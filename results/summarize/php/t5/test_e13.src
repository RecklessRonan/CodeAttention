12504	public static function rollbackTransaction ( $ connection ) { $ connection -> query = 'ROLLBACK' ; $ connection -> method = 'POST' ; $ connection -> action = '/_query' ; return self :: sendQuery ( $ connection ) ; }
3923	protected function getConnection ( ) { if ( null === $ this -> connection ) { @ trigger_error ( 'Connection is missing in class ' . static :: class . '. The automatic fallback will be dropped in MetaModels 3.0. Please use dependency injection' , E_USER_DEPRECATED ) ; return $ this -> connection = System :: getContainer ( ) -> get ( 'database_connection' ) ; } return $ this -> connection ; }
11401	public function startAt ( $ startAt = 0 ) { if ( ! is_numeric ( $ startAt ) || $ startAt < 0 ) { throw new Exception ( "startAt: bad value" , 10 ) ; } $ this -> startAt = $ startAt ; return $ this ; }
3201	public function getItems ( \ core_kernel_classes_Class $ itemClass , array $ propertyFilters = [ ] , $ offset = 0 , $ limit = 30 ) { $ result = $ this -> getListResourceLookupService ( ) -> getResources ( $ itemClass , [ ] , $ propertyFilters , $ offset , $ limit ) ; array_map ( function ( $ item ) { return array_merge ( $ item , [ 'categories' => $ this -> getCategoryService ( ) -> getItemCategories ( $ this -> getResource ( $ item [ 'uri' ] ) ) ] ) ; } , $ result [ 'nodes' ] ) ; return $ result ; }
4571	public function setAnonymousUuid ( ? string $ anonymousUuid ) { $ this -> anonymousUuid = $ anonymousUuid ; $ this -> _anonymousUuid = true ; return $ this ; }
1672	public function protect ( ) { if ( ! $ this -> isUnprotected ( ) ) { return ; } if ( ! file_exists ( $ this -> strRootDir . '/' . $ this -> strFolder . '/.public' ) ) { throw new \ RuntimeException ( sprintf ( 'Cannot protect folder "%s" because one of its parent folders is public' , $ this -> strFolder ) ) ; } ( new File ( $ this -> strFolder . '/.public' ) ) -> delete ( ) ; }
12660	public function removeAll ( ) { $ fs = $ this -> env -> getFileSystem ( ) ; $ fs -> deleteFile ( $ this -> baseDir . $ this -> pageName . '.js' ) ; $ fs -> deleteFile ( $ this -> outdatedDir . $ this -> baseLang . '/' . $ this -> pageName . '.json' ) ; foreach ( $ this -> extraLangs as $ language ) { $ fs -> deleteFile ( $ this -> baseDir . $ language . '/' . $ this -> pageName . '.js' ) ; $ fs -> deleteFile ( $ this -> outdatedDir . $ language . '/' . $ this -> pageName . '.json' ) ; } }
8766	protected function loadConfigFiles ( ) { try { if ( file_exists ( $ this -> cachePath ( 'config.php' ) ) ) { $ this -> config = require $ this -> cachePath ( 'config.php' ) ; } else { $ dotenv = new \ Dotenv \ Dotenv ( $ this -> root ) ; $ dotenv -> load ( ) ; foreach ( glob ( $ this -> root . '/config/*.php' ) as $ file ) { $ keyName = strtolower ( str_replace ( [ $ this -> root . '/config/' , '.php' ] , '' , $ file ) ) ; $ this -> config [ $ keyName ] = require $ file ; } } } catch ( Exception $ e ) { die ( printf ( "Configuration information could not be retrieved properly.\nError Message: %s" , $ e -> getMessage ( ) ) ) ; } }
11342	public function setDesigner ( Designer $ designer ) { $ this -> designer = $ designer ; $ this -> designer -> build ( $ this ) ; }
7535	function delete ( ) { if ( ( $ p = $ this -> parent ) !== null ) { $ this -> parent = null ; $ p -> deleteChild ( $ this ) ; } else { $ this -> clear ( ) ; } }
9117	public function unregisterView ( $ view , $ order , $ applicationName = 'default' ) { if ( isset ( $ this -> views [ $ applicationName ] [ $ order ] [ $ view ] ) ) { unset ( $ this -> views [ $ applicationName ] [ $ order ] [ $ view ] ) ; } return $ this ; }
5232	public function equals ( $ compare ) { if ( $ compare instanceof self ) { return ( get_class ( $ compare ) === get_class ( $ this ) && $ compare -> name ( ) === $ this -> name ) ; } return false ; }
12207	public function refresh ( ) { if ( null === $ this -> options || null === $ this -> sourceDir ) { return ; } $ this -> render ( $ this -> sourceDir , $ this -> options , $ this -> username ) ; }
6566	public function request ( array $ data ) { $ data = array_replace ( $ this -> config , $ data ) ; return $ this -> client -> callRequest ( $ data ) ; }
2416	protected function addTableTlFiles ( \ DOMDocument $ xml , \ DOMElement $ tables , Result $ objTheme , ZipWriter $ objArchive ) { $ table = $ xml -> createElement ( 'table' ) ; $ table -> setAttribute ( 'name' , 'tl_files' ) ; $ table = $ tables -> appendChild ( $ table ) ; $ this -> loadDataContainer ( 'tl_files' ) ; $ objDcaExtractor = DcaExtractor :: getInstance ( 'tl_files' ) ; $ arrOrder = $ objDcaExtractor -> getOrderFields ( ) ; $ arrFolders = StringUtil :: deserialize ( $ objTheme -> folders ) ; if ( ! empty ( $ arrFolders ) && \ is_array ( $ arrFolders ) ) { $ objFolders = FilesModel :: findMultipleByUuids ( $ arrFolders ) ; if ( $ objFolders !== null ) { foreach ( $ this -> eliminateNestedPaths ( $ objFolders -> fetchEach ( 'path' ) ) as $ strFolder ) { $ this -> addFolderToArchive ( $ objArchive , $ strFolder , $ xml , $ table , $ arrOrder ) ; } } } }
7909	protected function renderSearchInput ( ) { $ lines = [ ] ; $ lines [ ] = Html :: beginTag ( 'div' , [ 'class' => 'ui icon search input' ] ) ; $ lines [ ] = Html :: tag ( 'i' , '' , [ 'class' => 'search icon' ] ) ; $ lines [ ] = Html :: input ( 'text' , $ this -> getId ( ) . '-search' , '' , $ this -> searchInputOptions ) ; $ lines [ ] = Html :: endTag ( 'div' ) ; $ lines [ ] = Html :: tag ( 'div' , '' , [ 'class' => 'divider' ] ) ; return implode ( "\n" , $ lines ) ; }
7876	protected function generateRequestIfGuarded ( ) { if ( ! $ this -> option ( 'unguard' ) ) { $ name = $ this -> inflector -> getRequest ( ) ; $ this -> call ( 'make:request' , compact ( 'name' ) ) ; } }
11291	protected function _getAttributeDataWhenSet ( $ attributeName , $ query = false , $ loadMap = false , $ record = false ) { if ( is_numeric ( $ this -> model_data [ $ attributeName ] ) ) { if ( $ this -> _isRelation ( $ attributeName ) && ! isset ( $ this -> model_dynamicOff ) ) { $ this -> $ attributeName = $ this -> _getRelation ( $ attributeName , $ query , $ loadMap , $ record ) ; } } $ this -> beforeGet ( $ attributeName ) ; $ returnValue = $ this -> model_data [ $ attributeName ] ; $ this -> afterGet ( $ attributeName , $ returnValue ) ; return $ returnValue ; }
5855	protected function addStatisticsAndSocialLink ( ) { $ fileName = PATH_site . 'typo3temp/.tx_imageautoresize' ; if ( ! is_file ( $ fileName ) ) { return ; } $ data = json_decode ( file_get_contents ( $ fileName ) , true ) ; if ( ! is_array ( $ data ) || ! ( isset ( $ data [ 'images' ] ) && isset ( $ data [ 'bytes' ] ) ) ) { return ; } $ resourcesPath = '../' . ExtensionManagementUtility :: siteRelPath ( $ this -> extKey ) . 'Resources/Public/' ; $ pageRenderer = $ this -> moduleTemplate -> getPageRenderer ( ) ; $ pageRenderer -> addCssFile ( $ resourcesPath . 'Css/twitter.css' ) ; $ pageRenderer -> addJsFile ( $ resourcesPath . 'JavaScript/popup.js' ) ; $ totalSpaceClaimed = GeneralUtility :: formatSize ( ( int ) $ data [ 'bytes' ] ) ; $ messagePattern = $ this -> languageService -> getLL ( 'storage.claimed' ) ; $ message = sprintf ( $ messagePattern , $ totalSpaceClaimed , ( int ) $ data [ 'images' ] ) ; $ flashMessage = htmlspecialchars ( $ message ) ; $ twitterMessagePattern = $ this -> languageService -> getLL ( 'social.twitter' ) ; $ message = sprintf ( $ twitterMessagePattern , $ totalSpaceClaimed ) ; $ url = 'https://extensions.typo3.org/extension/image_autoresize/' ; $ twitterLink = 'https://twitter.com/intent/tweet?text=' . urlencode ( $ message ) . '&url=' . urlencode ( $ url ) ; $ twitterLink = GeneralUtility :: quoteJSvalue ( $ twitterLink ) ; $ flashMessage .= ' <div class="custom-tweet-button"> <a href="#" onclick="popitup(' . $ twitterLink . ',\'twitter\')" title="' . htmlspecialchars ( $ this -> languageService -> getLL ( 'social.share' ) ) . '"> <i class="btn-icon"></i> <span class="btn-text">Tweet</span> </a> </div>' ; $ this -> content .= ' <div class="alert alert-info"> <div class="media"> <div class="media-left"> <span class="fa-stack fa-lg"> <i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-info fa-stack-1x"></i> </span> </div> <div class="media-body"> ' . $ flashMessage . ' </div> </div> </div> ' ; }
7227	public function url ( $ url = null ) { if ( $ url ) { $ this -> url = $ url ; $ this -> option ( [ CURLOPT_URL => $ url ] ) ; } return $ this -> url ; }
6528	public static function registerMap ( array $ map ) { @ trigger_error ( sprintf ( '"%s" is deprecated. Use "registerManifest" instead.' , __CLASS__ ) , E_USER_DEPRECATED ) ; $ nextId = count ( self :: $ curies ) + 30000 ; foreach ( $ map as $ curie => $ class ) { ++ $ nextId ; self :: $ curies [ $ curie ] = $ nextId ; self :: $ classes [ $ nextId ] = $ class ; } }
1566	public function substituteBindings ( StoreInterface $ store ) : void { $ this -> resourceId = $ this -> getResourceId ( ) ? : false ; $ this -> processId = $ this -> getProcessId ( ) ? : false ; if ( $ this -> resourceId ) { $ this -> route -> setParameter ( ResourceRegistrar :: PARAM_RESOURCE_ID , $ store -> findOrFail ( $ this -> getResourceType ( ) , $ this -> resourceId ) ) ; } if ( $ this -> processId ) { $ this -> route -> setParameter ( ResourceRegistrar :: PARAM_PROCESS_ID , $ store -> findOrFail ( $ this -> getProcessType ( ) , $ this -> processId ) ) ; } }
183	public function getPublishedUrl ( $ path ) { $ path = Yii :: getAlias ( $ path ) ; if ( isset ( $ this -> _published [ $ path ] ) ) { return $ this -> _published [ $ path ] [ 1 ] ; } if ( is_string ( $ path ) && ( $ path = realpath ( $ path ) ) !== false ) { return $ this -> baseUrl . '/' . $ this -> hash ( $ path ) . ( is_file ( $ path ) ? '/' . basename ( $ path ) : '' ) ; } return false ; }
3134	public function getItemData ( RunnerServiceContext $ context , $ itemRef ) { if ( $ context instanceof QtiRunnerServiceContext ) { return $ this -> loadItemData ( $ itemRef , QtiJsonItemCompiler :: ITEM_FILE_NAME ) ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'getItemData' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } }
1201	public function isCurrent ( ItemInterface $ item ) { if ( null === $ this -> matcher ) { throw new \ BadMethodCallException ( 'The matcher must be set to get the breadcrumbs array' ) ; } return $ this -> matcher -> isCurrent ( $ item ) ; }
1966	public static function findByPk ( $ varValue , array $ arrOptions = array ( ) ) { if ( static :: $ strPk == 'id' ) { return static :: findById ( $ varValue , $ arrOptions ) ; } return parent :: findByPk ( $ varValue , $ arrOptions ) ; }
9487	private function installModules ( ) { $ this -> frame ( 'Installing the modules' ) ; $ this -> line ( '' ) ; foreach ( $ this -> config ( ) -> get ( 'arcanesoft.foundation.modules.commands.install' , [ ] ) as $ command ) { $ this -> call ( $ command ) ; } $ this -> call ( 'db:seed' , [ '--class' => DatabaseSeeder :: class ] ) ; $ this -> line ( '' ) ; $ this -> comment ( 'Modules installed !' ) ; $ this -> line ( '' ) ; }
5211	public function convert ( Node $ node , $ parentPrecedence , $ parentAssociativity , $ childPosition ) { $ type = $ node -> getType ( ) ; if ( $ this -> dispatcher -> issetPrecedenceMap ( $ type ) === true ) { $ childPrecedences = $ this -> dispatcher -> getPrecedenceMap ( $ type ) ; $ childPrecedence = $ childPrecedences [ 0 ] ; if ( $ childPrecedence > $ parentPrecedence || ( $ parentPrecedence == $ childPrecedence && $ parentAssociativity != $ childPosition ) ) { return '(' . $ this -> dispatcher -> { 'p' . $ type } ( $ node ) . ')' ; } } return $ this -> dispatcher -> { 'p' . $ type } ( $ node ) ; }
9766	function instanceOf ( string $ className ) : self { return $ this -> expect ( $ this -> target , isInstanceOf ( $ className ) ) ; }
11825	public function add ( $ encoding = 'UTF-8' ) { $ str = file_get_contents ( $ this -> uri ) ; return file_put_contents ( $ this -> uri , $ this -> getBom ( $ encoding ) . $ str ) ; }
7145	public function add_custom_profile_fields ( $ user ) { $ user_settings = apply_filters ( 'iac_get_user_settings' , array ( ) , $ user -> ID ) ; $ nonce = wp_create_nonce ( 'iac_user_settings' ) ; ?> <h3> <?php _e ( 'Informer?' , $ this -> get_textdomain ( ) ) ; ?> </h3> <table class="form-table"> <tr id="post_subscription"> <th> <label for="post_subscription_checkbox"> <?php _e ( 'Posts subscription' , $ this -> get_textdomain ( ) ) ; ?> </label> </th> <td> <input type="checkbox" id="post_subscription_checkbox" name="post_subscription" value="1" <?php checked ( '1' , $ user_settings [ 'inform_about_posts' ] ) ; ?> /> <span class="description"> <?php _e ( 'Inform about new posts via e-mail, without your own posts.' , $ this -> get_textdomain ( ) ) ; ?> </span> </td> </tr> <tr id="comment_subscription"> <th> <label for="comment_subscription_checkbox"> <?php _e ( 'Comments subscription' , $ this -> get_textdomain ( ) ) ; ?> </label> </th> <td> <input type="checkbox" id="comment_subscription_checkbox" name="comment_subscription" value="1" <?php checked ( '1' , $ user_settings [ 'inform_about_comments' ] ) ; ?> /> <span class="description"> <?php _e ( 'Inform about new comments via e-mail, without your own comments.' , $ this -> get_textdomain ( ) ) ; ?> </span> <input type="hidden" name="iac_nonce" value=" <?php echo $ nonce ; ?> " /> </td> </tr> </table> <?php }
6201	public function addRoute ( $ newRoute ) { $ this -> routeMap [ 'routes' ] = array_merge ( $ this -> routeMap [ 'routes' ] , $ newRoute ) ; $ this -> routeMapParse = array_merge ( $ this -> routeMapParse , $ newRoute ) ; }
11521	public function off ( $ eventType , $ listener = null ) { foreach ( $ this -> _eventListeners as $ i => $ l ) { if ( $ l -> getType ( ) == $ eventType ) { if ( $ listener === null || $ l -> getListener ( ) === $ listener ) { unset ( $ this -> _eventListeners [ $ i ] ) ; } } } }
1353	protected function invalid ( ) : Collection { if ( ! is_array ( $ this -> value ) ) { return collect ( ) ; } return collect ( $ this -> value ) -> map ( function ( $ value , $ key ) { return $ this -> notAllowed ( $ key , $ value ) ; } ) -> flatMap ( function ( Collection $ fields , $ type ) { return $ fields -> map ( function ( $ field ) use ( $ type ) { return "{$type}.{$field}" ; } ) ; } ) ; }
11198	public function delete ( $ name ) { $ name = $ this -> getName ( $ name ) ; $ resourceKey = $ name ; if ( is_numeric ( $ name ) ) { $ resourceKey = $ this -> fetchOffsetKey ( $ name ) ; } if ( $ this -> processDelete ( $ resourceKey ) ) { $ this -> contentModified = true ; $ this -> size -= 1 ; } }
905	public function isUnaryPredecessorOperator ( $ index ) { static $ potentialSuccessorOperator = [ T_INC , T_DEC ] ; static $ potentialBinaryOperator = [ '+' , '-' , '&' , [ CT :: T_RETURN_REF ] ] ; static $ otherOperators ; if ( null === $ otherOperators ) { $ otherOperators = [ '!' , '~' , '@' , [ T_ELLIPSIS ] ] ; } static $ disallowedPrevTokens ; if ( null === $ disallowedPrevTokens ) { $ disallowedPrevTokens = [ ']' , '}' , ')' , '"' , '`' , [ CT :: T_ARRAY_SQUARE_BRACE_CLOSE ] , [ CT :: T_DYNAMIC_PROP_BRACE_CLOSE ] , [ CT :: T_DYNAMIC_VAR_BRACE_CLOSE ] , [ T_CLASS_C ] , [ T_CONSTANT_ENCAPSED_STRING ] , [ T_DEC ] , [ T_DIR ] , [ T_DNUMBER ] , [ T_FILE ] , [ T_FUNC_C ] , [ T_INC ] , [ T_LINE ] , [ T_LNUMBER ] , [ T_METHOD_C ] , [ T_NS_C ] , [ T_STRING ] , [ T_TRAIT_C ] , [ T_VARIABLE ] , ] ; } $ tokens = $ this -> tokens ; $ token = $ tokens [ $ index ] ; if ( $ token -> isGivenKind ( $ potentialSuccessorOperator ) ) { return ! $ this -> isUnarySuccessorOperator ( $ index ) ; } if ( $ token -> equalsAny ( $ otherOperators ) ) { return true ; } if ( ! $ token -> equalsAny ( $ potentialBinaryOperator ) ) { return false ; } $ prevToken = $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ index ) ] ; if ( ! $ prevToken -> equalsAny ( $ disallowedPrevTokens ) ) { return true ; } if ( ! $ token -> equals ( '&' ) || ! $ prevToken -> isGivenKind ( T_STRING ) ) { return false ; } static $ searchTokens = [ ';' , '{' , '}' , [ T_FUNCTION ] , [ T_OPEN_TAG ] , [ T_OPEN_TAG_WITH_ECHO ] , ] ; $ prevToken = $ tokens [ $ tokens -> getPrevTokenOfKind ( $ index , $ searchTokens ) ] ; return $ prevToken -> isGivenKind ( T_FUNCTION ) ; }
1867	private function validateSessionLifetime ( User $ user ) : void { if ( ! $ this -> session -> isStarted ( ) ) { return ; } $ config = $ this -> framework -> getAdapter ( Config :: class ) ; $ timeout = ( int ) $ config -> get ( 'sessionTimeout' ) ; if ( $ timeout > 0 && ( time ( ) - $ this -> session -> getMetadataBag ( ) -> getLastUsed ( ) ) < $ timeout ) { return ; } if ( null !== $ this -> logger ) { $ this -> logger -> info ( sprintf ( 'User "%s" has been logged out automatically due to inactivity' , $ user -> username ) , [ 'contao' => new ContaoContext ( __METHOD__ , ContaoContext :: ACCESS , $ user -> username ) ] ) ; } throw new UsernameNotFoundException ( sprintf ( 'User "%s" has been logged out automatically due to inactivity.' , $ user -> username ) ) ; }
1542	protected function query ( $ query ) { return new CursorBuilder ( $ query , $ this -> column , $ this -> identifier , $ this -> descending ) ; }
316	public function renderAjax ( $ view , $ params = [ ] , $ context = null ) { $ viewFile = $ this -> findViewFile ( $ view , $ context ) ; ob_start ( ) ; ob_implicit_flush ( false ) ; $ this -> beginPage ( ) ; $ this -> head ( ) ; $ this -> beginBody ( ) ; echo $ this -> renderFile ( $ viewFile , $ params , $ context ) ; $ this -> endBody ( ) ; $ this -> endPage ( true ) ; return ob_get_clean ( ) ; }
11241	public function rule ( $ fieldName , $ checks , $ humanName = false ) { $ checkFailures = 0 ; if ( $ humanName == false ) { $ humanName = ucfirst ( $ fieldName ) ; } $ fieldData = $ this -> getValue ( $ fieldName ) ; if ( ! is_array ( $ checks ) ) { $ checks = explode ( '|' , $ checks ) ; } foreach ( $ checks as $ check ) { $ checkName = $ check ; if ( isset ( $ this -> customChecks -> $ check ) ) { $ customCheckDef = $ this -> customChecks -> $ check ; $ customType = $ customCheckDef [ 0 ] ; $ arguments = array ( $ fieldData , $ customCheckDef [ 1 ] , $ customCheckDef [ 2 ] , $ customCheckDef [ 3 ] , $ customCheckDef [ 4 ] ) ; $ checkResult = call_user_func_array ( array ( $ this , $ customType ) , $ arguments ) ; } else { $ checkArgs = explode ( '[' , $ check , 2 ) ; if ( count ( $ checkArgs ) > 1 ) { $ check = $ checkArgs [ 0 ] ; $ checkName = $ checkArgs [ 0 ] ; $ checkArgs [ 1 ] = '[' . $ checkArgs [ 1 ] ; $ args = array ( ) ; preg_match_all ( "/\[([^\]]*)\]/" , $ checkArgs [ 1 ] , $ args ) ; $ this -> matchedArg = $ args [ 1 ] [ 0 ] ; $ check = '_' . $ checkName ; $ checkResult = $ this -> $ check ( $ fieldData , $ args [ 1 ] ) ; } else { $ check = '_' . $ checkName ; $ checkResult = $ this -> $ check ( $ fieldData ) ; } } if ( $ checkResult == false ) { $ this -> errors [ ] = sprintf ( $ this -> lang -> $ checkName , $ humanName , $ this -> matchedArg ) ; $ this -> matchedArg = false ; $ checkFailures ++ ; } } return $ checkFailures == 0 ? true : false ; }
6871	private function initializeMethod ( ShipmentInterface $ shipment ) { if ( null !== $ shipment -> getMethod ( ) ) { return ; } $ sale = $ shipment -> getSale ( ) ; if ( null === $ method = $ sale -> getShipmentMethod ( ) ) { return ; } $ gateway = $ this -> registry -> getGateway ( $ method -> getGatewayName ( ) ) ; if ( ! $ shipment -> isReturn ( ) && $ gateway -> supports ( GatewayInterface :: CAPABILITY_SHIPMENT ) ) { $ shipment -> setMethod ( $ method ) ; return ; } if ( $ shipment -> isReturn ( ) && $ gateway -> supports ( GatewayInterface :: CAPABILITY_RETURN ) ) { $ shipment -> setMethod ( $ method ) ; return ; } }
1762	public static function convertXlfToPhp ( $ strName , $ strLanguage , $ blnLoad = false ) { @ trigger_error ( 'Using System::convertXlfToPhp() has been deprecated and will no longer work in Contao 5.0. Use the Contao\CoreBundle\Config\Loader\XliffFileLoader instead.' , E_USER_DEPRECATED ) ; $ rootDir = self :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( strpos ( $ strName , $ rootDir . '/' ) === false ) { $ strName = $ rootDir . '/' . $ strName ; } $ loader = new XliffFileLoader ( static :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) , $ blnLoad ) ; return $ loader -> load ( $ strName , $ strLanguage ) ; }
6564	public static function load ( $ class ) { $ class = static :: normalizeClass ( $ class ) ; foreach ( static :: $ directories as $ directory ) { if ( Sbp :: fileExists ( $ directory . DIRECTORY_SEPARATOR . $ class , $ path ) ) { require_once $ path ; return true ; } } }
11368	public static function deduplicate ( $ array ) { if ( empty ( $ array ) ) { return $ array ; } $ known = array ( ) ; foreach ( $ array as $ _index => $ entry ) { if ( is_array ( $ entry ) ) { foreach ( $ entry as $ i => $ _email ) { if ( ! in_array ( $ _email , $ known ) ) { $ known [ ] = $ _email ; } else { unset ( $ array [ $ _index ] ) ; } } } elseif ( is_string ( $ entry ) ) { if ( ! in_array ( $ entry , $ known ) ) { $ known [ ] = $ entry ; } else { unset ( $ array [ $ _index ] ) ; } } } return $ array ; }
9121	public function retrieveHeaders ( ) : array { $ this -> setHeader ( 'Connection' , 'close' ) ; $ this -> setHeader ( 'Accept' , '' ) ; $ this -> setHeader ( 'Accept-Language' , '' ) ; $ this -> setHeader ( 'User-Agent' , '' ) ; $ savedProto = $ this -> protocol ; $ this -> protocol = 'HTTP/1.0' ; $ this -> request ( 'HEAD' ) ; $ this -> protocol = $ savedProto ; return $ this -> getHeaders ( ) ; }
11915	public static function from ( Reader $ reader , \ Reflector $ reflector ) { if ( $ reflector instanceof \ ReflectionClass ) { return new static ( Psi :: it ( $ reader -> getClassAnnotations ( $ reflector ) ) -> toArray ( ) ) ; } if ( $ reflector instanceof \ ReflectionMethod ) { return new static ( Psi :: it ( $ reader -> getMethodAnnotations ( $ reflector ) ) -> toArray ( ) ) ; } return new static ( ) ; }
5894	public function retrieveAudioTemplate ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/templates/audiotemplate' , $ parameters , $ cachePolicy ) ; $ result = new AudioTemplate ( $ result ) ; return $ result ; }
12192	protected function doSave ( $ id , $ data , $ lifeTime = 0 ) { return $ this -> delegate -> doSave ( $ id , $ data , $ lifeTime ) ; }
10365	public function login ( LoginRequest $ request ) { $ this -> bus -> pipeThrough ( $ this -> pipesOf ( 'login' ) ) -> dispatchFrom ( LoginJob :: class , $ request ) ; return redirect ( ) -> route ( config ( '_auth.login.redirect' ) ) ; }
4757	protected function transformIterable ( $ value ) { $ params = array ( ) ; foreach ( $ value as $ key => $ val ) { if ( ! empty ( $ val ) ) { $ params [ $ key ] = $ this -> transform ( $ val ) ; } } return $ params ; }
7604	protected function renderAddOn ( $ aAddOnOptions ) { if ( empty ( $ aAddOnOptions ) ) { throw new InvalidArgumentException ( 'Addon options are empty' ) ; } if ( $ aAddOnOptions instanceof ElementInterface ) { $ aAddOnOptions = array ( 'element' => $ aAddOnOptions ) ; } elseif ( is_scalar ( $ aAddOnOptions ) ) { $ aAddOnOptions = array ( 'text' => $ aAddOnOptions ) ; } elseif ( ! is_array ( $ aAddOnOptions ) ) { throw new InvalidArgumentException ( sprintf ( 'Addon options expects an array or a scalar value, "%s" given' , is_object ( $ aAddOnOptions ) ? get_class ( $ aAddOnOptions ) : gettype ( $ aAddOnOptions ) ) ) ; } $ sMarkup = '' ; $ sAddonTagName = 'span' ; $ sAddonClass = '' ; if ( ! empty ( $ aAddOnOptions [ 'text' ] ) ) { if ( ! is_scalar ( $ aAddOnOptions [ 'text' ] ) ) { throw new InvalidArgumentException ( sprintf ( '"text" option expects a scalar value, "%s" given' , is_object ( $ aAddOnOptions [ 'text' ] ) ? get_class ( $ aAddOnOptions [ 'text' ] ) : gettype ( $ aAddOnOptions [ 'text' ] ) ) ) ; } elseif ( ( $ oTranslator = $ this -> getTranslator ( ) ) ) { $ sMarkup .= $ oTranslator -> translate ( $ aAddOnOptions [ 'text' ] , $ this -> getTranslatorTextDomain ( ) ) ; } else { $ sMarkup .= $ aAddOnOptions [ 'text' ] ; } $ sAddonClass .= ' input-group-addon' ; } elseif ( ! empty ( $ aAddOnOptions [ 'element' ] ) ) { if ( is_array ( $ aAddOnOptions [ 'element' ] ) || ( $ aAddOnOptions [ 'element' ] instanceof Traversable && ! ( $ aAddOnOptions [ 'element' ] instanceof ElementInterface ) ) ) { $ oFactory = new Factory ( ) ; $ aAddOnOptions [ 'element' ] = $ oFactory -> create ( $ aAddOnOptions [ 'element' ] ) ; } elseif ( ! ( $ aAddOnOptions [ 'element' ] instanceof ElementInterface ) ) { throw new LogicException ( sprintf ( '"element" option expects an instanceof Zend\Form\ElementInterface, "%s" given' , is_object ( $ aAddOnOptions [ 'element' ] ) ? get_class ( $ aAddOnOptions [ 'element' ] ) : gettype ( $ aAddOnOptions [ 'element' ] ) ) ) ; } $ aAddOnOptions [ 'element' ] -> setOptions ( array_merge ( $ aAddOnOptions [ 'element' ] -> getOptions ( ) , array ( 'disable-twb' => true ) ) ) ; $ sMarkup .= $ this -> render ( $ aAddOnOptions [ 'element' ] ) ; if ( $ aAddOnOptions [ 'element' ] instanceof Button ) { $ sAddonClass .= ' input-group-btn' ; $ sAddonTagName = 'div' ; } else { $ sAddonClass .= ' input-group-addon' ; } } return sprintf ( static :: $ addonFormat , $ sAddonTagName , trim ( $ sAddonClass ) , $ sMarkup , $ sAddonTagName ) ; }
11807	public function lists ( $ column , $ key = null ) { return $ this -> buildQuery ( [ $ column ] ) -> lists ( $ column , $ key ) ; }
10555	public static function findBestMatching ( URL $ url , array $ sites ) { $ vhosts = array ( ) ; foreach ( $ sites as $ site ) foreach ( $ site -> getVirtualHosts ( ) as $ vhost ) $ vhosts [ ] = $ vhost ; $ my_url = new URL ( $ url ) ; $ my_url -> set ( 'query' , null ) -> set ( 'fragment' , null ) -> toString ( ) ; $ best_percentage = 0 ; $ best_idx = null ; foreach ( $ vhosts as $ idx => $ vhost ) { $ host = $ vhost -> getHost ( ) -> toString ( ) ; similar_text ( $ my_url , $ host , $ percentage ) ; if ( $ best_idx === null || $ percentage > $ best_percentage ) { $ best_idx = $ idx ; $ best_percentage = $ percentage ; } } if ( $ best_idx === null ) return null ; return $ vhosts [ $ best_idx ] ; }
467	public function buildExistsCondition ( $ operator , $ operands , & $ params ) { array_unshift ( $ operands , $ operator ) ; return $ this -> buildCondition ( $ operands , $ params ) ; }
10070	public function make ( $ tag , $ props = null , $ content = null ) { $ tag = parent :: make ( $ tag , $ props , $ content ) ; $ tag = $ this -> decorators -> apply ( $ tag , $ this ) ; return $ tag ; }
12359	public static function decodeHashId ( $ idHashed ) { if ( ! config ( 'odin.hashid.active' ) ) { return $ idHashed ; } $ hashids = App :: make ( 'Hashids' ) ; $ hashId = $ hashids -> decode ( $ idHashed ) ; return ( count ( $ hashId ) > 0 ) ? $ hashId [ 0 ] : '' ; }
9150	public function fetchAll ( $ columns = null , \ Closure $ Closure = null ) { $ select = $ this -> getSelect ( ) ; if ( $ columns ) { $ select -> columns ( $ columns ) ; } if ( $ Closure ) { $ Closure ( $ select ) ; } return $ this -> select ( $ select ) ; }
3985	private function isActive ( $ route , $ params , Request $ request ) { if ( '/contao' === $ request -> getPathInfo ( ) || ! ( $ request -> attributes -> get ( '_route' ) === $ route ) ) { return false ; } $ attributes = $ request -> attributes -> get ( '_route_params' ) ; $ query = $ request -> query ; foreach ( $ params as $ param => $ value ) { if ( isset ( $ attributes [ $ param ] ) && ( $ value !== $ request -> attributes [ '_route_params' ] [ $ param ] ) ) { return false ; } if ( $ query -> has ( $ param ) && ( $ value !== $ query -> get ( $ param ) ) ) { return false ; } } return true ; }
7862	protected function setPipesOfWorkflow ( $ workflow ) { $ pipes = $ this -> pipelines -> getPipesByPipeline ( $ workflow ) ; $ this -> pipes = array_map ( function ( $ pipe ) { $ chunks = explode ( '\\' , $ pipe ) ; return end ( $ chunks ) ; } , $ pipes ) ; $ this -> geometry -> setPipes ( $ this -> pipes ) ; }
1775	protected function isChecked ( $ arrOption ) { if ( empty ( $ this -> varValue ) && empty ( $ _POST ) && $ arrOption [ 'default' ] ) { return static :: optionChecked ( 1 , 1 ) ; } return static :: optionChecked ( $ arrOption [ 'value' ] , $ this -> varValue ) ; }
3390	public function redirectAfterResendConfirmationPath ( ) { if ( method_exists ( $ this , 'redirectAfterResendConfirmationTo' ) ) { return $ this -> redirectAfterResendConfirmationTo ( ) ; } return property_exists ( $ this , 'redirectAfterResendConfirmationTo' ) ? $ this -> redirectAfterResendConfirmationTo : route ( 'login' ) ; }
8102	public function getStatement ( $ sql , $ args = false ) { $ query = $ this -> buildQuery ( $ sql , $ args ) ; if ( $ connection = $ this -> db -> getConnection ( ) ) { if ( $ stmt = $ connection -> prepare ( $ query ) ) { $ this -> log -> report ( "SQL Statement: {$query}" ) ; $ stmt -> setFetchMode ( \ PDO :: FETCH_INTO , new Collection ( ) ) ; if ( $ args ) { $ this -> log -> report ( "SQL Data Sent: [" . implode ( ', ' , $ args ) . "]" ) ; $ stmt -> execute ( $ args ) ; } if ( $ stmt -> errorCode ( ) > 0 ) { $ error = $ stmt -> errorInfo ( ) ; $ this -> log -> error ( "PDO({$error[0]})[{$error[1]}] {$error[2]}" ) ; return false ; } return $ stmt ; } else { $ this -> log -> error ( 'Failed to create a PDO statement with: ' . $ query ) ; return false ; } } else { return false ; } }
5266	public static function merge ( Model $ model1 , Model $ model2 , array $ attributes ) { foreach ( $ attributes as $ attribute ) { $ model1 -> $ attribute = $ model2 -> $ attribute ; } return $ model1 ; }
6008	protected function init ( $ ftkey ) { if ( strlen ( $ ftkey ) != 32 ) { throw new Ts3Exception ( "invalid file transfer key format" ) ; } $ this -> getProfiler ( ) -> start ( ) ; $ this -> getTransport ( ) -> send ( $ ftkey ) ; Signal :: getInstance ( ) -> emit ( "filetransferHandshake" , $ this ) ; }
9900	private function advance ( ) { $ i = $ this -> currentCharacter ; $ formula_length = strlen ( $ this -> formula ) ; if ( $ i < $ formula_length ) { while ( $ this -> formula [ $ i ] == ' ' ) { ++ $ i ; } if ( $ i < ( $ formula_length - 1 ) ) { $ this -> lookAhead = $ this -> formula [ $ i + 1 ] ; } $ token = '' ; } while ( $ i < $ formula_length ) { $ token .= $ this -> formula [ $ i ] ; if ( $ i < ( $ formula_length - 1 ) ) { $ this -> lookAhead = $ this -> formula [ $ i + 1 ] ; } else { $ this -> lookAhead = '' ; } if ( $ this -> match ( $ token ) != '' ) { $ this -> currentCharacter = $ i + 1 ; $ this -> currentToken = $ token ; return 1 ; } if ( $ i < ( $ formula_length - 2 ) ) { $ this -> lookAhead = $ this -> formula [ $ i + 2 ] ; } else { $ this -> lookAhead = '' ; } ++ $ i ; } }
9257	public function get ( $ id , $ invalidBehavior = ContainerInterface :: EXCEPTION_ON_INVALID_REFERENCE ) { if ( ! $ this -> booted ) { $ this -> boot ( ) ; } return $ this -> container -> get ( $ id , $ invalidBehavior ) ; }
3301	public function request ( $ method , $ url , $ options = [ ] ) { $ method = strtoupper ( $ method ) ; $ options = array_merge ( self :: $ defaults , [ 'headers' => $ this -> headers ] , $ options ) ; return $ this -> getClient ( ) -> request ( $ method , $ url , $ options ) ; }
6525	public function createMessage ( array $ data = [ ] ) { $ className = $ this -> className ; if ( empty ( $ data ) ) { return $ className :: create ( ) ; } return $ className :: fromArray ( $ data ) ; }
6461	public function shouldSeeThumbnail ( ) { $ thumb = false ; foreach ( [ '.upload-preview' , '.media-thumbnail img' , '.image-preview img' ] as $ selector ) { if ( $ thumb ) { break ; } $ thumb = $ this -> findByCss ( $ selector ) ; } if ( null === $ thumb ) { throw new \ Exception ( 'An expected image tag was not found.' ) ; } $ file = explode ( '?' , $ thumb -> getAttribute ( 'src' ) ) ; $ file = reset ( $ file ) ; $ curl = new CurlService ( ) ; list ( , $ info ) = $ curl -> execute ( 'GET' , $ file ) ; if ( empty ( $ info ) || strpos ( $ info [ 'content_type' ] , 'image/' ) === false ) { throw new FileNotFoundException ( sprintf ( '%s did not return an image' , $ file ) ) ; } }
8647	private function configureCurlOptions ( $ action , array $ converted , $ streamHandle = null , $ contentMd5 = null ) { $ curlOptions = $ this -> getDefaultCurlOptions ( ) ; if ( ! is_null ( $ this -> config [ 'ProxyHost' ] ) ) { $ proxy = $ this -> config [ 'ProxyHost' ] ; $ proxy .= ':' . ( $ this -> config [ 'ProxyPort' ] == - 1 ? '80' : $ this -> config [ 'ProxyPort' ] ) ; $ curlOptions [ CURLOPT_PROXY ] = $ proxy ; } if ( array_key_exists ( 'CURLOPT_VERBOSE' , $ this -> config ) && ! is_null ( $ this -> config [ 'CURLOPT_VERBOSE' ] ) ) { $ curlOptions [ CURLOPT_VERBOSE ] = $ this -> config [ 'CURLOPT_VERBOSE' ] ; } $ serviceUrl = $ this -> config [ 'ServiceURL' ] ; if ( ! ( substr ( $ serviceUrl , strlen ( $ serviceUrl ) - 1 ) === '/' ) ) { $ serviceUrl .= '/' ; } $ requestType = MarketplaceWebService_RequestType :: getRequestType ( $ action ) ; if ( $ requestType == MarketplaceWebService_RequestType :: POST_UPLOAD ) { if ( is_null ( $ streamHandle ) || ! is_resource ( $ streamHandle ) ) { throw new MarketplaceWebService_Exception ( array ( 'Message' => 'Missing stream resource.' ) ) ; } $ serviceUrl .= '?' . $ this -> getParametersAsString ( $ converted [ CONVERTED_PARAMETERS_KEY ] ) ; $ curlOptions [ CURLOPT_URL ] = $ serviceUrl ; $ header [ ] = 'Expect: ' ; $ header [ ] = 'Accept: ' ; $ header [ ] = 'Transfer-Encoding: chunked' ; $ header [ ] = 'Content-MD5: ' . $ contentMd5 ; $ curlOptions [ CURLOPT_HTTPHEADER ] = array_merge ( $ header , $ converted [ CONVERTED_HEADERS_KEY ] ) ; rewind ( $ streamHandle ) ; $ curlOptions [ CURLOPT_INFILE ] = $ streamHandle ; $ curlOptions [ CURLOPT_UPLOAD ] = true ; $ curlOptions [ CURLOPT_CUSTOMREQUEST ] = self :: REQUEST_TYPE ; } else if ( ! ( $ requestType === MarketplaceWebService_RequestType :: UNKNOWN ) ) { $ curlOptions [ CURLOPT_URL ] = $ this -> config [ 'ServiceURL' ] ; $ curlOptions [ CURLOPT_POSTFIELDS ] = $ this -> getParametersAsString ( $ converted [ CONVERTED_PARAMETERS_KEY ] ) ; if ( $ requestType == MarketplaceWebService_RequestType :: POST_DOWNLOAD ) { $ this -> responseBodyContents = $ streamHandle ; $ curlOptions [ CURLOPT_WRITEFUNCTION ] = array ( $ this , 'responseCallback' ) ; } } else { throw new InvalidArgumentException ( "$action is not a valid request type." ) ; } return $ curlOptions ; }
5586	public function restart ( $ date = false ) { $ this -> cookie_jar -> restartSession ( $ date ) ; $ this -> authenticator -> restartSession ( ) ; $ this -> http_referer = null ; }
2959	public function confFlowControl ( $ mode ) { if ( $ this -> _dState !== SERIAL_DEVICE_SET ) { trigger_error ( "Unable to set flow control mode : the device is " . "either not set or opened" , E_USER_WARNING ) ; return false ; } $ linuxModes = array ( "none" => "clocal -crtscts -ixon -ixoff" , "rts/cts" => "-clocal crtscts -ixon -ixoff" , "xon/xoff" => "-clocal -crtscts ixon ixoff" ) ; $ windowsModes = array ( "none" => "xon=off octs=off rts=on" , "rts/cts" => "xon=off octs=on rts=hs" , "xon/xoff" => "xon=on octs=off rts=on" , ) ; if ( $ mode !== "none" and $ mode !== "rts/cts" and $ mode !== "xon/xoff" ) { trigger_error ( "Invalid flow control mode specified" , E_USER_ERROR ) ; return false ; } if ( $ this -> _os === "linux" ) { $ ret = $ this -> _exec ( "stty -F " . $ this -> _device . " " . $ linuxModes [ $ mode ] , $ out ) ; } elseif ( $ this -> _os === "osx" ) { $ ret = $ this -> _exec ( "stty -f " . $ this -> _device . " " . $ linuxModes [ $ mode ] , $ out ) ; } else { $ ret = $ this -> _exec ( "mode " . $ this -> _winDevice . " " . $ windowsModes [ $ mode ] , $ out ) ; } if ( $ ret === 0 ) { return true ; } else { trigger_error ( "Unable to set flow control : " . $ out [ 1 ] , E_USER_ERROR ) ; return false ; } }
7728	public function quickReplies ( $ text , $ quickReplies ) { $ this -> setText ( $ text ) ; foreach ( $ quickReplies as $ quickReplie ) { $ this -> setQuickReplies ( $ quickReplie ) ; } return $ this ; }
8356	public function generateModels ( ) { $ definition = $ this -> getDefinition ( ) ; foreach ( $ definition as $ modelName => $ modelDefinition ) { $ type = 'model' ; if ( isset ( $ modelDefinition [ 'type' ] ) === true && in_array ( $ modelDefinition [ 'type' ] , [ 'enum' , 'model' ] ) === true ) { $ type = $ modelDefinition [ 'type' ] ; } if ( $ type == 'enum' ) { $ this -> generateEnum ( $ modelName , $ modelDefinition ) ; } else { $ this -> generateModel ( $ modelName , $ modelDefinition ) ; } } }
624	public function findWith ( $ with , & $ models ) { $ primaryModel = reset ( $ models ) ; if ( ! $ primaryModel instanceof ActiveRecordInterface ) { $ modelClass = $ this -> modelClass ; $ primaryModel = $ modelClass :: instance ( ) ; } $ relations = $ this -> normalizeRelations ( $ primaryModel , $ with ) ; foreach ( $ relations as $ name => $ relation ) { if ( $ relation -> asArray === null ) { $ relation -> asArray ( $ this -> asArray ) ; } $ relation -> populateRelation ( $ name , $ models ) ; } }
4834	public function fetch_access_token ( $ params ) { if ( ! isset ( $ params [ 'redirect_uri' ] ) ) { throw new GoCardless_ArgumentsException ( 'redirect_uri required' ) ; } $ params [ 'http_authorization' ] = $ this -> account_details [ 'app_id' ] . ':' . $ this -> account_details [ 'app_secret' ] ; $ response = $ this -> request ( 'post' , '/oauth/access_token' , $ params ) ; $ merchant = explode ( ':' , $ response [ 'scope' ] ) ; $ merchant_id = isset ( $ merchant [ 1 ] ) ? $ merchant [ 1 ] : null ; $ access_token = $ response [ 'access_token' ] ; return array ( 'merchant_id' => $ merchant_id , 'access_token' => $ access_token ) ; }
7984	public function getCurrentMonitoring ( $ domain , $ type ) { $ type = strtolower ( $ type ) ; if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; if ( ! in_array ( $ type , array ( 'cpu:max' , 'cpu:used' , 'mem:max' , 'mem:used' , 'net:rx' , 'net:tx' ) ) ) throw new BadMethodCallException ( 'Parameter $type must be "cpu:max" or "cpu:used" or "mem:max" or "mem:used" or "net:rx" or "net:tx". "' . $ type . '" given.' ) ; try { $ r = $ this -> get ( 'vps/' . $ domain . '/use?type=' . $ type ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new VpsException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
7796	protected function accountNumber ( $ text ) { $ format = $ this -> format == self :: FORMAT_CLASSIC ? '/^[0-9.]+/' : '/^[0-9A-Z]+/' ; if ( $ account = $ this -> getLine ( '25' , $ text ) ) { if ( preg_match ( $ format , $ account , $ match ) ) { return str_replace ( '.' , '' , $ match [ 0 ] ) ; } } return null ; }
8154	public function addFunction ( $ name , $ function = null ) { if ( ! $ name instanceof Twig_SimpleFunction && ! ( $ function instanceof Twig_SimpleFunction || $ function instanceof Twig_FunctionInterface ) ) { throw new LogicException ( 'A function must be an instance of Twig_FunctionInterface or Twig_SimpleFunction.' ) ; } if ( $ name instanceof Twig_SimpleFunction ) { $ function = $ name ; $ name = $ function -> getName ( ) ; } else { @ trigger_error ( sprintf ( 'Passing a name as a first argument to the %s method is deprecated since version 1.21. Pass an instance of "Twig_SimpleFunction" instead when defining function "%s".' , __METHOD__ , $ name ) , E_USER_DEPRECATED ) ; } if ( $ this -> extensionInitialized ) { throw new LogicException ( sprintf ( 'Unable to add function "%s" as extensions have already been initialized.' , $ name ) ) ; } $ this -> staging -> addFunction ( $ name , $ function ) ; }
534	protected function fixFileDoc ( & $ lines ) { $ namespace = false ; $ namespaceLine = '' ; $ contentAfterNamespace = false ; foreach ( $ lines as $ i => $ line ) { $ line = trim ( $ line ) ; if ( ! empty ( $ line ) ) { if ( strncmp ( $ line , 'namespace' , 9 ) === 0 ) { $ namespace = $ i ; $ namespaceLine = $ line ; } elseif ( $ namespace !== false ) { $ contentAfterNamespace = $ i ; break ; } } } if ( $ namespace !== false && $ contentAfterNamespace !== false ) { while ( $ contentAfterNamespace > 0 ) { array_shift ( $ lines ) ; $ contentAfterNamespace -- ; } $ lines = array_merge ( [ '<?php' , '/**' , ' * @link http://www.yiiframework.com/' , ' * @copyright Copyright (c) 2008 Yii Software LLC' , ' * @license http://www.yiiframework.com/license/' , ' */' , '' , $ namespaceLine , '' , ] , $ lines ) ; } }
10902	public function loadRelation ( string $ name ) { if ( ! isset ( $ this -> relationObjects [ $ name ] ) || empty ( $ this -> relationObjects [ $ name ] ) ) { $ relation = $ this -> getRelations ( ) [ $ name ] ; if ( ! $ relation || ! $ relation [ 'entity' ] || ! $ this -> get ( $ relation [ 'key' ] ?? 'id' ) ) { return null ; } $ entity = $ this -> entity ( $ relation [ 'entity' ] ) ; $ type = $ relation [ 'type' ] ?? 'has_one' ; $ key = $ relation [ 'key' ] ?? ( 'has_one' === $ type ? $ this -> __getEntityName ( ) . '_id' : 'id' ) ; $ foreignKey = $ relation [ 'foreign_key' ] ?? ( 'has_one' === $ type ? 'id' : $ this -> __getEntityName ( ) . '_id' ) ; $ assoc = $ relation [ 'assoc' ] ?? false ; $ this -> relationObjects [ $ name ] = ( 'has_one' === $ type ) ? $ entity -> load ( $ this -> get ( $ key ) , $ foreignKey ) : $ entity -> loadAll ( [ $ foreignKey => $ this -> get ( $ key ) ] , $ assoc ) ; } return $ this -> relationObjects [ $ name ] ?? null ; }
2957	public function confCharacterLength ( $ int ) { if ( $ this -> _dState !== SERIAL_DEVICE_SET ) { trigger_error ( "Unable to set length of a character : the device " . "is either not set or opened" , E_USER_WARNING ) ; return false ; } $ int = ( int ) $ int ; if ( $ int < 5 ) { $ int = 5 ; } elseif ( $ int > 8 ) { $ int = 8 ; } if ( $ this -> _os === "linux" ) { $ ret = $ this -> _exec ( "stty -F " . $ this -> _device . " cs" . $ int , $ out ) ; } elseif ( $ this -> _os === "osx" ) { $ ret = $ this -> _exec ( "stty -f " . $ this -> _device . " cs" . $ int , $ out ) ; } else { $ ret = $ this -> _exec ( "mode " . $ this -> _winDevice . " DATA=" . $ int , $ out ) ; } if ( $ ret === 0 ) { return true ; } trigger_error ( "Unable to set character length : " . $ out [ 1 ] , E_USER_WARNING ) ; return false ; }
198	public function xSendFile ( $ filePath , $ attachmentName = null , $ options = [ ] ) { if ( $ attachmentName === null ) { $ attachmentName = basename ( $ filePath ) ; } if ( isset ( $ options [ 'mimeType' ] ) ) { $ mimeType = $ options [ 'mimeType' ] ; } elseif ( ( $ mimeType = FileHelper :: getMimeTypeByExtension ( $ filePath ) ) === null ) { $ mimeType = 'application/octet-stream' ; } if ( isset ( $ options [ 'xHeader' ] ) ) { $ xHeader = $ options [ 'xHeader' ] ; } else { $ xHeader = 'X-Sendfile' ; } $ disposition = empty ( $ options [ 'inline' ] ) ? 'attachment' : 'inline' ; $ this -> getHeaders ( ) -> setDefault ( $ xHeader , $ filePath ) -> setDefault ( 'Content-Type' , $ mimeType ) -> setDefault ( 'Content-Disposition' , $ this -> getDispositionHeaderValue ( $ disposition , $ attachmentName ) ) ; $ this -> format = self :: FORMAT_RAW ; return $ this ; }
4242	public function onOutput ( ) { if ( $ this -> debug -> parentInstance ) { return ; } $ vals = $ this -> runtimeVals ( ) ; $ this -> debug -> groupSummary ( 1 ) ; $ this -> debug -> info ( 'Built In ' . $ vals [ 'runtime' ] . ' sec' ) ; $ this -> debug -> info ( 'Peak Memory Usage' . ( $ this -> debug -> getCfg ( 'output/outputAs' ) == 'html' ? ' <span title="Includes debug overhead">?&#x20dd;</span>' : '' ) . ': ' . $ this -> debug -> utilities -> getBytes ( $ vals [ 'memoryPeakUsage' ] ) . ' / ' . $ this -> debug -> utilities -> getBytes ( $ vals [ 'memoryLimit' ] ) ) ; $ this -> debug -> groupEnd ( ) ; }
10000	public function setSoftEdgesSize ( $ size ) { if ( $ size !== null ) { $ this -> activateObject ( ) ; $ softEdges [ 'size' ] = ( string ) $ this -> getExcelPointsWidth ( $ size ) ; } }
3327	private function correctProductAssignment ( $ variationModel , $ productIdentitiy ) { if ( null === $ variationModel ) { return ; } if ( ( int ) $ productIdentitiy -> getAdapterIdentifier ( ) === $ variationModel -> getArticle ( ) -> getId ( ) ) { return ; } $ this -> entityManager -> getConnection ( ) -> update ( 's_articles_details' , [ 'articleID' => $ productIdentitiy -> getAdapterIdentifier ( ) ] , [ 'id' => $ variationModel -> getId ( ) ] ) ; $ this -> logger -> notice ( 'migrated variation from existing product to connector handeled product.' , [ 'variation' => $ variationModel -> getNumber ( ) , 'old shopware product id' => $ variationModel -> getArticle ( ) -> getId ( ) , 'new shopware product id' => $ productIdentitiy -> getAdapterIdentifier ( ) , ] ) ; }
2288	public static function findUnactivatedByEmail ( $ strEmail , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ objDatabase = Database :: getInstance ( ) ; $ objResult = $ objDatabase -> prepare ( "SELECT * FROM $t WHERE email=? AND disable='1' AND EXISTS (SELECT * FROM tl_opt_in_related r LEFT JOIN tl_opt_in o ON r.pid=o.id WHERE r.relTable='$t' AND r.relId=$t.id AND o.createdOn>? AND o.confirmedOn=0)" ) -> limit ( 1 ) -> execute ( $ strEmail , strtotime ( '-24 hours' ) ) ; if ( $ objResult -> numRows < 1 ) { return null ; } $ objRegistry = Registry :: getInstance ( ) ; if ( $ objMember = $ objRegistry -> fetch ( $ t , $ objResult -> id ) ) { return $ objMember ; } return new static ( $ objResult ) ; }
1517	public function readRelationship ( StoreInterface $ store , FetchRelationship $ request ) { $ record = $ request -> getRecord ( ) ; $ result = $ this -> beforeReadingRelationship ( $ record , $ request ) ; if ( $ this -> isResponse ( $ result ) ) { return $ result ; } $ related = $ store -> queryRelationship ( $ record , $ request -> getRelationshipName ( ) , $ request -> getParameters ( ) ) ; $ records = ( $ related instanceof PageInterface ) ? $ related -> getData ( ) : $ related ; $ result = $ this -> afterReadingRelationship ( $ record , $ records , $ request ) ; if ( $ this -> isInvokedResult ( $ result ) ) { return $ result ; } return $ this -> reply ( ) -> relationship ( $ related ) ; }
7762	public function getContext ( $ exposedClassName ) { $ classes = $ this -> metadata -> getAllMetadata ( ) ; $ metadata = null ; foreach ( $ classes as $ class ) { if ( $ class -> getExposeAs ( ) === $ exposedClassName ) { $ metadata = $ class ; break ; } } if ( null === $ metadata ) { return null ; } $ context = array ( 'hydra' => 'http://www.w3.org/ns/hydra/core#' , 'vocab' => $ this -> vocabUrl . '#' ) ; $ context [ $ exposedClassName ] = ( $ metadata -> isExternalReference ( ) ) ? $ metadata -> getIri ( ) : 'vocab:' . $ metadata -> getIri ( ) ; foreach ( $ metadata -> getProperties ( ) as $ property ) { if ( 0 === strncmp ( $ property -> getExposeAs ( ) , '@' , 1 ) ) { continue ; } $ termDefinition = ( $ property -> isExternalReference ( ) ) ? $ property -> getIri ( ) : 'vocab:' . $ property -> getIri ( ) ; if ( $ property -> getRoute ( ) ) { $ termDefinition = array ( '@id' => $ termDefinition , '@type' => '@id' ) ; } elseif ( $ this -> hasNormalizer ( $ property -> getType ( ) ) ) { $ normalizer = $ this -> getNormalizer ( $ property -> getType ( ) ) ; $ termDefinition = array ( '@id' => $ termDefinition , '@type' => $ normalizer -> getTypeIri ( ) ) ; } $ context [ $ property -> getExposeAs ( ) ] = $ termDefinition ; } return array ( '@context' => $ context ) ; }
5690	public static function normalise ( $ html ) { $ rules = array ( '#<!--.*? , '#<(script|option|textarea)[^>]*>.*?</\1>#si' , '#<img[^>]*alt\s*=\s*("([^"]*)"|\'([^\']*)\'|([a-zA-Z_]+))[^>]*>#' , '#<[^>]*>#' , ) ; $ replace = array ( '' , '' , ' \2\3\4 ' , '' , ) ; $ text = preg_replace ( $ rules , $ replace , $ html ) ; $ text = html_entity_decode ( $ text , ENT_QUOTES ) ; $ text = preg_replace ( '#\s+#' , ' ' , $ text ) ; return trim ( trim ( $ text ) , "\xA0" ) ; }
5952	public function setTransition ( $ transition ) { if ( $ transition instanceof SlideTransition ) { $ this -> transition = $ transition ; } elseif ( is_array ( $ transition ) ) { $ this -> transition = new SlideTransition ( $ transition ) ; } else { $ this -> transition = null ; trigger_error ( 'Argument must be an object of class SlideTransition. Data loss!' , E_USER_WARNING ) ; } return $ this ; }
12282	private function stopCustomProcess ( ) : void { if ( $ this -> isCustomProcessSet ( ) ) { $ this -> getCustomProcess ( ) -> stop ( ) ; } elseif ( class_exists ( '\extensions\core\Process' ) ) { \ extensions \ core \ Process :: getInstance ( ) -> stop ( ) ; } }
11177	public function create ( ? string $ name = null ) { Whois :: print ( $ this -> getNotify ( ) ) ; $ this -> creator -> create ( $ this -> filesystem , $ name ) ; }
5938	public function addFunctionality ( $ item ) { if ( ! ( $ item instanceof Functionality ) ) { if ( is_array ( $ item ) ) { try { $ item = new Functionality ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate Functionality. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "Functionality"!' , E_USER_WARNING ) ; } } $ this -> functionalities [ ] = $ item ; return $ this ; }
5956	public function channelClientPermList ( $ cid , $ cldbid , $ permsid = false ) { return $ this -> execute ( "channelclientpermlist" , array ( "cid" => $ cid , "cldbid" => $ cldbid , $ permsid ? "-permsid" : null ) ) -> toAssocArray ( $ permsid ? "permsid" : "permid" ) ; }
6962	public static function B ( $ year ) { $ jd = static :: B1900 ( ) -> jd + ( $ year - 1900 ) * static :: DaysBesselianYear ; $ epoch = new static ( $ jd ) ; $ epoch -> type = YearType :: Besselian ( ) ; return $ epoch ; }
9553	public function allowExtensions ( $ extensions ) { if ( ! is_array ( $ extensions ) ) { $ extensions = [ $ extensions ] ; } $ this -> constraints [ ] = new ExtensionConstraint ( $ extensions ) ; return $ this ; }
844	public function clearEmptyTokens ( ) { $ limit = $ this -> count ( ) ; $ index = 0 ; for ( ; $ index < $ limit ; ++ $ index ) { if ( $ this -> isEmptyAt ( $ index ) ) { break ; } } if ( $ limit === $ index ) { return ; } for ( $ count = $ index ; $ index < $ limit ; ++ $ index ) { if ( ! $ this -> isEmptyAt ( $ index ) ) { $ this [ $ count ++ ] = $ this [ $ index ] ; } } $ this -> setSize ( $ count ) ; }
4645	public function setDimension ( $ name , array $ values ) { if ( empty ( $ values ) ) { $ values = array ( null ) ; } $ this -> dimensions [ $ name ] = $ values ; }
3080	public static function isAssessmentSectionAdaptive ( AssessmentSection $ section , $ namespace = '' ) { if ( $ namespace === '' ) { $ namespace = CatService :: QTI_2X_ADAPTIVE_XML_NAMESPACE ; } $ isAdaptive = false ; if ( ( $ selection = $ section -> getSelection ( ) ) !== null && ( ( $ xmlExtension = $ selection -> getXml ( ) ) ) !== null ) { $ xpath = new \ DOMXPath ( $ xmlExtension ) ; $ xpath -> registerNamespace ( 'ais' , $ namespace ) ; if ( $ xpath -> query ( './/ais:adaptiveItemSelection' , $ xmlExtension ) -> length > 0 ) { $ isAdaptive = true ; } } return $ isAdaptive ; }
1536	protected function fillRelationships ( $ record , Collection $ relationships , EncodingParametersInterface $ parameters ) { $ relationships -> filter ( function ( $ value , $ field ) use ( $ record ) { return $ this -> isFillableRelation ( $ field , $ record ) ; } ) -> each ( function ( $ value , $ field ) use ( $ record , $ parameters ) { $ this -> fillRelationship ( $ record , $ field , $ value , $ parameters ) ; } ) ; }
7718	function meth_Conv_Prepare ( & $ Loc , $ StrConv ) { $ x = strtolower ( $ StrConv ) ; $ x = '+' . str_replace ( ' ' , '' , $ x ) . '+' ; if ( strpos ( $ x , '+esc+' ) !== false ) { $ this -> f_Misc_ConvSpe ( $ Loc ) ; $ Loc -> ConvStr = false ; $ Loc -> ConvEsc = true ; } if ( strpos ( $ x , '+wsp+' ) !== false ) { $ this -> f_Misc_ConvSpe ( $ Loc ) ; $ Loc -> ConvWS = true ; } if ( strpos ( $ x , '+js+' ) !== false ) { $ this -> f_Misc_ConvSpe ( $ Loc ) ; $ Loc -> ConvStr = false ; $ Loc -> ConvJS = true ; } if ( strpos ( $ x , '+url+' ) !== false ) { $ this -> f_Misc_ConvSpe ( $ Loc ) ; $ Loc -> ConvStr = false ; $ Loc -> ConvUrl = true ; } if ( strpos ( $ x , '+utf8+' ) !== false ) { $ this -> f_Misc_ConvSpe ( $ Loc ) ; $ Loc -> ConvStr = false ; $ Loc -> ConvUtf8 = true ; } if ( strpos ( $ x , '+no+' ) !== false ) $ Loc -> ConvStr = false ; if ( strpos ( $ x , '+yes+' ) !== false ) $ Loc -> ConvStr = true ; if ( strpos ( $ x , '+nobr+' ) !== false ) { $ Loc -> ConvStr = true ; $ Loc -> ConvBr = false ; } }
7864	protected function drawPipesBeginning ( ) { foreach ( $ this -> pipes as $ pipe ) { $ this -> drawBorderTop ( ) ; $ this -> drawBordered ( $ this -> geometry -> getSpacedPipe ( $ pipe , static :: NOCK , 'before()' ) ) ; } }
6101	public function listPropertySets ( CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/propertysets' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new PropertySet ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
9747	public function setTimeZone ( $ timezone ) { if ( ! $ timezone ) { return $ this ; } try { Carbon :: now ( $ timezone ) ; } catch ( \ Exception $ e ) { $ this -> invalidArguments ( '10004' , sprintf ( 'Invalid timezone set "%s"' , $ timezone ) ) ; } return $ this -> setParameter ( 'timezone' , $ timezone ) ; }
1719	public function getNewsArchives ( ) { if ( ! $ this -> User -> isAdmin && ! \ is_array ( $ this -> User -> news ) ) { return array ( ) ; } $ arrArchives = array ( ) ; $ objArchives = $ this -> Database -> execute ( "SELECT id, title FROM tl_news_archive ORDER BY title" ) ; while ( $ objArchives -> next ( ) ) { if ( $ this -> User -> hasAccess ( $ objArchives -> id , 'news' ) ) { $ arrArchives [ $ objArchives -> id ] = $ objArchives -> title ; } } return $ arrArchives ; }
4549	public function get ( string $ alias ) { $ stat = $ this -> statCollection -> filter ( function ( $ element ) use ( $ alias ) { return $ element -> getAlias ( ) === $ alias ; } ) -> first ( ) ; if ( ! $ stat ) { throw new InvalidAliasException ( 'Stat alias "' . $ alias . '" does not exist.' ) ; } $ datum = $ stat -> get ( ) ; return $ datum ; }
9802	public static function getLibXmlLoaderOptions ( ) { if ( self :: $ libXmlLoaderOptions === null && defined ( 'LIBXML_DTDLOAD' ) ) { self :: setLibXmlLoaderOptions ( LIBXML_DTDLOAD | LIBXML_DTDATTR ) ; } elseif ( self :: $ libXmlLoaderOptions === null ) { self :: $ libXmlLoaderOptions = true ; } return self :: $ libXmlLoaderOptions ; }
5040	public function setPermissions ( PermissionsInterface $ permissions ) { foreach ( $ this -> getImages ( ) as $ file ) { $ filePermissions = $ file -> getPermissions ( ) ; $ filePermissions -> clear ( ) ; $ filePermissions -> inherit ( $ permissions ) ; } return $ this ; }
9030	public function exception ( Request $ request ) { $ ex = $ request -> getException ( ) ; $ this -> response -> setCode ( 500 ) ; printf ( "<h2>%s</h2>" , HttpStatus :: getStatus ( 500 ) ) ; while ( $ ex != null ) { printf ( "<h3>%s</h3><pre>%s</pre>" , $ ex -> getMessage ( ) , $ ex -> getTraceAsString ( ) ) ; $ ex = $ ex -> getPrevious ( ) ; } }
7510	function addError ( $ error ) { $ this -> errors [ ] = htmlentities ( $ error . ' at ' . ( $ this -> line_pos [ 0 ] + 1 ) . ', ' . ( $ this -> pos - $ this -> line_pos [ 1 ] + 1 ) . '!' ) ; }
5859	public function getAllDirectories ( ) { $ directories = [ ] ; foreach ( $ this -> rulesets as $ ruleset ) { $ dirs = GeneralUtility :: trimExplode ( ',' , $ ruleset [ 'directories_config' ] , true ) ; $ directories = array_merge ( $ directories , $ dirs ) ; } $ directories = array_unique ( $ directories ) ; asort ( $ directories ) ; return $ directories ; }
6699	public function setBuild ( $ build ) { $ this -> build = array_values ( ( array ) $ build ) ; array_walk ( $ this -> build , function ( & $ v ) { if ( preg_match ( '/^[0-9]+$/' , $ v ) ) { $ v = ( int ) $ v ; } } ) ; }
3938	private function setExplanation ( PropertyInterface $ property , $ propInfo ) { if ( $ property -> getExplanation ( ) || ! isset ( $ propInfo [ 'explanation' ] ) ) { return ; } $ property -> setExplanation ( $ propInfo [ 'explanation' ] ) ; }
9135	public static function parseUrl ( $ url ) : Url { $ parts = parse_url ( $ url ) ; if ( false === $ parts || false === Arrays :: hasElement ( $ parts , 'host' ) || false === Arrays :: hasElement ( $ parts , 'scheme' ) ) { throw new InvalidUrlException ( 'The URL {url} does not contain necessary parts' , array ( 'url' => $ url ) ) ; } $ address = $ parts [ 'host' ] ; $ scheme = $ parts [ 'scheme' ] ; $ query = ( isset ( $ parts [ 'query' ] ) ? $ parts [ 'query' ] : '' ) ; $ port = 0 ; $ path = "/" ; if ( isset ( $ parts [ 'port' ] ) ) { $ port = intval ( $ parts [ 'port' ] ) ; } if ( $ port == 0 ) { $ port = self :: getPortByScheme ( $ scheme ) ; } if ( isset ( $ parts [ 'path' ] ) ) { $ path = $ parts [ 'path' ] ; } return new Url ( $ address , $ port , $ path , $ scheme , $ query ) ; }
1777	public static function optionSelected ( $ strOption , $ varValues ) { if ( $ strOption === '' ) { return '' ; } return ( \ is_array ( $ varValues ) ? \ in_array ( $ strOption , $ varValues ) : $ strOption == $ varValues ) ? ' selected' : '' ; }
7088	public function error ( Callable $ action = null ) { if ( $ action ) $ this -> errorAction = $ action ; return $ this -> errorAction ; }
3146	public function resume ( RunnerServiceContext $ context ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ context -> getTestSession ( ) -> resume ( ) ; $ this -> persist ( $ context ) ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'resume' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } return true ; }
9963	public function removeRow ( $ pRow , $ pNumRows = 1 ) { if ( $ pRow >= 1 ) { $ highestRow = $ this -> getHighestDataRow ( ) ; $ objReferenceHelper = ReferenceHelper :: getInstance ( ) ; $ objReferenceHelper -> insertNewBefore ( 'A' . ( $ pRow + $ pNumRows ) , 0 , - $ pNumRows , $ this ) ; for ( $ r = 0 ; $ r < $ pNumRows ; ++ $ r ) { $ this -> getCellCollection ( ) -> removeRow ( $ highestRow ) ; -- $ highestRow ; } } else { throw new Exception ( 'Rows to be deleted should at least start from row 1.' ) ; } return $ this ; }
3006	static public function jump ( \ Base $ f3 , $ params ) { $ target = $ f3 -> get ( 'GET.target' ) ; if ( $ f3 -> exists ( 'mailer.on.jump' , $ jump_handler ) ) $ f3 -> call ( $ jump_handler , array ( $ target , $ params ) ) ; $ f3 -> reroute ( urldecode ( $ target ) ) ; }
1405	protected function findRelated ( $ record , array $ relationship ) { $ inverse = $ this -> getRelation ( $ record , $ this -> key ) -> getRelated ( ) ; $ related = $ this -> findToMany ( $ relationship ) ; $ related = collect ( $ related ) -> filter ( function ( $ model ) use ( $ inverse ) { return $ model instanceof $ inverse ; } ) ; return new Collection ( $ related ) ; }
4350	private function setCopyValues ( $ values ) { if ( isset ( $ values [ 'debug' ] [ 'emailLog' ] ) && $ values [ 'debug' ] [ 'emailLog' ] === true ) { $ values [ 'debug' ] [ 'emailLog' ] = 'onError' ; } foreach ( array ( 'emailFrom' , 'emailFunc' , 'emailTo' ) as $ key ) { if ( isset ( $ values [ 'debug' ] [ $ key ] ) && ! isset ( $ values [ 'errorEmailer' ] [ $ key ] ) ) { $ values [ 'errorEmailer' ] [ $ key ] = $ values [ 'debug' ] [ $ key ] ; } } return $ values ; }
12945	public function getTagValues ( $ asString = false ) { if ( $ this -> _tagsList === null && ! $ this -> owner -> getIsNewRecord ( ) ) { $ this -> _tagsList = [ ] ; $ relation = $ this -> owner -> getRelation ( 'tagsList' , false ) ; if ( $ relation instanceof ActiveQuery ) { $ this -> _tagsList = array_unique ( $ relation -> select ( 'text' ) -> column ( ) ) ; } } return $ asString === true ? implode ( ',' , $ this -> _tagsList ) : $ this -> _tagsList ; }
5664	private function collectFrames ( $ node ) { $ frames = array ( ) ; if ( $ node -> name === 'frame' ) { $ frames = array ( $ this -> tags ( ) -> createTag ( $ node -> name , ( array ) $ node -> attribute ) ) ; } elseif ( $ node -> hasChildren ( ) ) { $ frames = array ( ) ; foreach ( $ node -> child as $ child ) { $ frames = array_merge ( $ frames , $ this -> collectFrames ( $ child ) ) ; } } return $ frames ; }
9213	public function getOptionParser ( ) { $ parser = parent :: getOptionParser ( ) ; $ parser -> description ( 'Provides a mechanism for loading data into any of Cake\'s configured databases.' ) -> addSubcommand ( 'init' , [ 'help' => 'Initialize a new, empty seed file. Respects both the --dev and --file options.' , ] ) -> addOption ( 'dev' , [ 'short' => 'd' , 'boolean' => true , 'default' => false , 'help' => 'Use the "dev" seed file instead of the default.' ] ) -> addOption ( 'file' , [ 'short' => 'f' , 'help' => 'Manually specify the file that should be used. When this option is present, its argument will always be used explicitly, overriding the --dev option if it is also present.' ] ) ; return $ parser ; }
1875	private function getBundlePackageName ( string $ className ) : string { if ( 'Bundle' === substr ( $ className , - 6 ) ) { $ className = substr ( $ className , 0 , - 6 ) ; } return Container :: underscore ( $ className ) ; }
9192	public function init ( ) { if ( $ this -> isInitialized ( ) ) return true ; $ sm = $ this -> getServiceManager ( ) ; $ defaultListeners = $ sm -> get ( 'yimaTheme.Manager.ListenerAggregate' ) ; if ( $ defaultListeners instanceof self ) $ defaultListeners -> manager = $ this ; $ sharedEvents = $ this -> getEventManager ( ) -> getSharedManager ( ) ; $ sharedEvents -> attachAggregate ( $ defaultListeners ) ; $ this -> isInitialized = true ; return $ this ; }
4238	public function hasLog ( ) { $ entryCountInitial = $ this -> debug -> getData ( 'entryCountInitial' ) ; $ entryCountCurrent = $ this -> debug -> getData ( 'log/__count__' ) ; $ haveLog = $ entryCountCurrent > $ entryCountInitial ; $ lastEntryMethod = $ this -> debug -> getData ( 'log/__end__/0' ) ; return $ haveLog && $ lastEntryMethod !== 'clear' ; }
2896	public function captureEmail ( ) { $ email = Mage :: getModel ( 'sheep_debug/email' ) ; $ email -> setFromEmail ( $ this -> getFromEmail ( ) ) ; $ email -> setFromName ( $ this -> getFromName ( ) ) ; $ email -> setToEmail ( $ this -> getToEmail ( ) ) ; $ email -> setToName ( $ this -> getToName ( ) ) ; $ email -> setSubject ( $ this -> getSubject ( ) ) ; $ email -> setIsPlain ( $ this -> getType ( ) != 'html' ) ; $ email -> setBody ( $ this -> getBody ( ) ) ; $ email -> setIsSmtpDisabled ( ( bool ) Mage :: getStoreConfigFlag ( 'system/smtp/disable' ) ) ; $ email -> setIsAccepted ( true ) ; $ requestInfo = Mage :: getSingleton ( 'sheep_debug/observer' ) -> getRequestInfo ( ) ; $ requestInfo -> addEmail ( $ email ) ; }
2942	protected static function unitNameOrAliasesAlreadyRegistered ( UnitOfMeasureInterface $ unit ) { if ( ! is_array ( static :: $ unitDefinitions ) ) { static :: $ unitDefinitions = [ ] ; static :: initialize ( ) ; } $ currentUnitNamesAndAliases = [ ] ; foreach ( static :: $ unitDefinitions as $ unitOfMeasure ) { $ currentUnitNamesAndAliases [ ] = $ unitOfMeasure -> getName ( ) ; $ currentUnitNamesAndAliases = array_merge ( $ currentUnitNamesAndAliases , $ unitOfMeasure -> getAliases ( ) ) ; } $ newUnitNamesAndAliases = array_merge ( [ $ unit -> getName ( ) ] , $ unit -> getAliases ( ) ) ; return count ( array_intersect ( $ currentUnitNamesAndAliases , $ newUnitNamesAndAliases ) ) > 0 ; }
840	public function setSize ( $ size ) { if ( $ this -> getSize ( ) !== $ size ) { $ this -> changed = true ; parent :: setSize ( $ size ) ; } }
8795	public function view ( $ name , array $ data = [ ] ) { $ file = app_path ( 'Views' . DIRECTORY_SEPARATOR . $ name . '.php' ) ; if ( file_exists ( $ file ) ) { extract ( $ data ) ; require $ file ; return ob_get_clean ( ) ; } throw new ExceptionHandler ( 'Oppss! File not found.' , 'View::' . $ name . ' not found.' ) ; }
3153	public function storeTraceVariable ( RunnerServiceContext $ context , $ itemUri , $ variableIdentifier , $ variableValue ) { $ this -> assertQtiRunnerServiceContext ( $ context ) ; $ metaVariable = $ this -> getTraceVariable ( $ variableIdentifier , $ variableValue ) ; return $ this -> storeVariable ( $ context , $ itemUri , $ metaVariable ) ; }
11567	public function set ( string $ sNameOfDi , callable $ cFunction , bool $ bShared = false ) : Di { if ( $ bShared === true ) { self :: $ _aSharedDependencyInjectorContener [ md5 ( $ sNameOfDi ) ] = $ cFunction ; } else { $ this -> _aDependencyInjectorContener [ md5 ( $ sNameOfDi ) ] = $ cFunction ; } return $ this ; }
2630	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ aclId = $ this -> getRequest ( ) -> getParam ( 'acl_id' ) ; $ value = $ this -> getRequest ( ) -> getParam ( 'item_value' ) ; $ comment = $ this -> getRequest ( ) -> getParam ( 'comment_value' ) ; $ negated = 0 ; if ( $ value [ 0 ] == '!' ) { $ negated = 1 ; $ value = ltrim ( $ value , '!' ) ; } $ ipParts = explode ( '/' , $ value ) ; $ subnet = false ; if ( ! empty ( $ ipParts [ 1 ] ) ) { if ( is_numeric ( $ ipParts [ 1 ] ) && ( int ) $ ipParts [ 1 ] < 129 ) { $ subnet = $ ipParts [ 1 ] ; } else { return $ result -> setData ( [ 'status' => false , 'msg' => 'Invalid IP subnet format.' ] ) ; } } if ( ! filter_var ( $ ipParts [ 0 ] , FILTER_VALIDATE_IP ) ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Invalid IP address format.' ] ) ; } $ createAclItem = $ this -> api -> upsertAclItem ( $ aclId , $ ipParts [ 0 ] , $ negated , $ comment , $ subnet ) ; if ( ! $ createAclItem ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to create Acl entry.' ] ) ; } return $ result -> setData ( [ 'status' => true , 'id' => $ createAclItem -> id , 'comment' => $ createAclItem -> comment , 'created_at' => $ createAclItem -> created_at ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
516	public function actionMark ( $ version ) { $ originalVersion = $ version ; if ( ( $ namespaceVersion = $ this -> extractNamespaceMigrationVersion ( $ version ) ) !== false ) { $ version = $ namespaceVersion ; } elseif ( ( $ migrationName = $ this -> extractMigrationVersion ( $ version ) ) !== false ) { $ version = $ migrationName ; } elseif ( $ version !== static :: BASE_MIGRATION ) { throw new Exception ( "The version argument must be either a timestamp (e.g. 101129_185401)\nor the full name of a migration (e.g. m101129_185401_create_user_table)\nor the full name of a namespaced migration (e.g. app\\migrations\\M101129185401CreateUserTable)." ) ; } $ migrations = $ this -> getNewMigrations ( ) ; foreach ( $ migrations as $ i => $ migration ) { if ( strpos ( $ migration , $ version ) === 0 ) { if ( $ this -> confirm ( "Set migration history at $originalVersion?" ) ) { for ( $ j = 0 ; $ j <= $ i ; ++ $ j ) { $ this -> addMigrationHistory ( $ migrations [ $ j ] ) ; } $ this -> stdout ( "The migration history is set at $originalVersion.\nNo actual migration was performed.\n" , Console :: FG_GREEN ) ; } return ExitCode :: OK ; } } $ migrations = array_keys ( $ this -> getMigrationHistory ( null ) ) ; $ migrations [ ] = static :: BASE_MIGRATION ; foreach ( $ migrations as $ i => $ migration ) { if ( strpos ( $ migration , $ version ) === 0 ) { if ( $ i === 0 ) { $ this -> stdout ( "Already at '$originalVersion'. Nothing needs to be done.\n" , Console :: FG_YELLOW ) ; } else { if ( $ this -> confirm ( "Set migration history at $originalVersion?" ) ) { for ( $ j = 0 ; $ j < $ i ; ++ $ j ) { $ this -> removeMigrationHistory ( $ migrations [ $ j ] ) ; } $ this -> stdout ( "The migration history is set at $originalVersion.\nNo actual migration was performed.\n" , Console :: FG_GREEN ) ; } } return ExitCode :: OK ; } } throw new Exception ( "Unable to find the version '$originalVersion'." ) ; }
9369	protected function resolve ( ContainerInterface $ container , ServerRequestInterface $ request , ResponseInterface $ response ) { if ( class_exists ( 'Zend\Diactoros\ServerRequestFactory' ) ) { $ response = new ZendResponse ; $ request = ServerRequestFactory :: fromGlobals ( ) ; } $ container -> set ( 'Psr\Http\Message\ServerRequestInterface' , $ request ) ; return $ container -> set ( 'Psr\Http\Message\ResponseInterface' , $ response ) ; }
5982	protected function getClient ( ) { if ( ! ( $ this -> client instanceof Client ) ) { $ handlerStack = HandlerStack :: create ( ) ; $ handlerStack = $ this -> withOAuth2MiddleWare ( $ handlerStack ) ; $ this -> client = new Client ( [ 'handler' => $ handlerStack , 'auth' => 'oauth2' , 'base_uri' => $ this -> basepath , 'headers' => [ 'Accept' => 'application/json' , 'Content-type' => 'application/json' , 'User-Agent' => 'qbank3api-phpwrapper/2 (qbankapi: 1; swagger: 1.1)' , ] , 'verify' => $ this -> verifyCertificates , ] ) ; $ this -> logger -> debug ( 'Guzzle client instantiated.' , [ 'basepath' => $ this -> basepath ] ) ; } return $ this -> client ; }
10813	public function callMethodInWrappedInst ( $ method , $ args ) { $ i = $ this -> getWrappedInst ( ) ; if ( method_exists ( $ i , $ method ) ) { return call_user_method_array ( $ method , $ i , $ args ) ; } throw new UnknownMethodException ( 'Calling unknown method: ' . get_class ( $ i ) . "::$method()" ) ; }
799	private function removeSpaceAroundToken ( Tokens $ tokens , $ index ) { $ token = $ tokens [ $ index ] ; if ( $ token -> isWhitespace ( ) && false === strpos ( $ token -> getContent ( ) , "\n" ) ) { $ tokens -> clearAt ( $ index ) ; } }
8189	final protected function getContext ( $ context , $ item , $ ignoreStrictCheck = false ) { if ( ! array_key_exists ( $ item , $ context ) ) { if ( $ ignoreStrictCheck || ! $ this -> env -> isStrictVariables ( ) ) { return ; } throw new Twig_Error_Runtime ( sprintf ( 'Variable "%s" does not exist.' , $ item ) , - 1 , $ this -> getSourceContext ( ) ) ; } return $ context [ $ item ] ; }
11625	public function processContent ( Operation $ operation , $ data ) { if ( is_array ( $ data ) ) { $ status = $ this -> contentService -> getSocialMediaScheduleByOperation ( $ operation ) ; if ( ! $ data [ 'locations' ] instanceof ArrayCollection ) { $ locations = $ this -> em -> getRepository ( 'CampaignChainCoreBundle:Location' ) -> findById ( array_values ( $ data [ 'locations' ] ) ) ; $ locations = new ArrayCollection ( $ locations ) ; } else { $ locations = $ data [ 'locations' ] ; } $ status -> setLocations ( $ locations ) ; $ status -> setMessage ( $ data [ 'message' ] ) ; } else { $ status = $ data ; } return $ status ; }
8452	protected function checkUrlExistsAndSize ( $ fileUri , array $ mediaFileInfo ) { $ mediaFileInfo [ 'url' ] = $ fileUri ; $ curl = curl_init ( ) ; curl_setopt ( $ curl , CURLOPT_URL , "$fileUri" ) ; curl_setopt ( $ curl , CURLOPT_USERAGENT , "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.11) Gecko/20071127 Firefox/2.0.0.11" ) ; curl_setopt ( $ curl , CURLOPT_RETURNTRANSFER , true ) ; curl_setopt ( $ curl , CURLOPT_HEADER , false ) ; curl_setopt ( $ curl , CURLOPT_NOBODY , true ) ; if ( curl_exec ( $ curl ) === false ) { return false ; } $ info = curl_getinfo ( $ curl ) ; $ mediaFileInfo [ 'filesize' ] = $ info [ 'download_content_length' ] ; $ mediaFileInfo [ 'filemimetype' ] = $ info [ 'content_type' ] ; $ mediaFileInfo [ 'fileextension' ] = pathinfo ( parse_url ( $ mediaFileInfo [ 'url' ] , PHP_URL_PATH ) , PATHINFO_EXTENSION ) ; curl_close ( $ curl ) ; return $ mediaFileInfo ; }
7168	public function updateTab ( $ tabLabel , array $ formInputs ) { $ tabExists = false ; foreach ( $ this -> getTabs ( ) as $ tabIndex => $ tabInfo ) { if ( array_get ( $ tabInfo , 'label' ) === $ tabLabel ) { $ this -> currentTab = $ tabIndex ; $ this -> currentInputsGroup = null ; if ( count ( ( array ) array_get ( $ tabInfo , 'groups' , [ ] ) ) === 1 && is_int ( array_keys ( $ tabInfo [ 'groups' ] ) [ 0 ] ) ) { $ this -> currentInputsGroup = array_keys ( $ tabInfo [ 'groups' ] ) [ 0 ] ; } $ tabExists = true ; break ; } } if ( ! $ tabExists ) { $ this -> newTab ( $ tabLabel ) ; } $ this -> setFormInputs ( $ formInputs ) ; $ this -> currentTab = null ; $ this -> currentInputsGroup = null ; return $ this ; }
11799	public function setReplyTo ( $ mail = '' , $ name = null ) { if ( strlen ( $ mail ) && Helper :: isEmail ( $ mail ) ) { if ( ! empty ( $ name ) ) { $ _m = Helper :: mailTagger ( $ mail , $ name ) ; } else { $ _m = $ mail ; } $ this -> getMailer ( ) -> setRegistry ( 'Reply-To' , $ _m , 'headers' ) ; } return $ this ; }
10609	public function classifiedAnswerAction ( ) { $ request = $ this -> getRequest ( ) ; $ response = $ this -> getResponse ( ) ; if ( ! $ request -> isPost ( ) ) { $ response -> setStatusCode ( Response :: STATUS_CODE_500 ) ; return new JsonModel ( array ( 'status' => 'danger' , 'message' => 'Invalid method call' ) ) ; } $ userService = $ this -> getServiceLocator ( ) -> get ( 'user.service.user' ) ; $ data = array_merge_recursive ( $ this -> params ( ) -> fromPost ( ) , Json :: decode ( $ request -> getContent ( ) , Json :: TYPE_ARRAY ) ) ; try { $ response -> setStatusCode ( Response :: STATUS_CODE_200 ) ; $ userService -> classifiedAnswer ( $ data ) ; $ returnData = array ( 'status' => 'success' , 'message' => 'La tua risposta  stata inviata!' ) ; } catch ( \ Exception $ e ) { $ response -> setStatusCode ( Response :: STATUS_CODE_500 ) ; $ returnData = @ unserialize ( $ e -> getMessage ( ) ) ; if ( ! is_array ( $ returnData ) ) { $ returnData = array ( 'status' => 'danger' , 'message' => $ e -> getMessage ( ) ) ; } } return new JsonModel ( $ returnData ) ; }
9803	public function setCreated ( $ time ) { if ( $ time === null ) { $ time = time ( ) ; } elseif ( is_string ( $ time ) ) { if ( is_numeric ( $ time ) ) { $ time = ( int ) $ time ; } else { $ time = strtotime ( $ time ) ; } } $ this -> created = $ time ; return $ this ; }
2871	public function getModules ( ) { $ items = array ( ) ; $ items [ ] = array ( 'module' => 'Magento' , 'codePool' => 'core' , 'active' => true , 'version' => $ this -> getMagentoVersion ( ) ) ; $ modulesConfig = Mage :: getConfig ( ) -> getModuleConfig ( ) ; foreach ( $ modulesConfig as $ node ) { foreach ( $ node as $ module => $ data ) { $ items [ ] = array ( 'module' => $ module , 'codePool' => ( string ) $ data -> codePool , 'active' => $ data -> active == 'true' , 'version' => ( string ) $ data -> version ) ; } } return $ items ; }
11743	public function remove ( $ pageName ) { if ( $ pageName == $ this -> configurationHandler -> homepage ( ) ) { throw new RuntimeException ( "exception_homepage_cannot_be_removed" ) ; } $ pageDir = $ this -> pagesDir . '/' . $ pageName ; Dispatcher :: dispatch ( PageCollectionEvents :: PAGE_COLLECTION_REMOVING , new PageCollectionRemovingEvent ( $ this -> username , $ pageDir ) ) ; $ filesystem = new Filesystem ( ) ; if ( file_exists ( $ pageDir . '/page.json' ) ) { $ filesystem -> mirror ( $ pageDir , $ this -> pagesRemovedDir . '/' . $ pageName . "-" . date ( "Y-m-d-H.i.s" ) ) ; } $ filesystem -> remove ( $ pageDir ) ; Dispatcher :: dispatch ( PageCollectionEvents :: PAGE_COLLECTION_REMOVED , new PageCollectionRemovedEvent ( $ this -> username , $ pageDir ) ) ; DataLogger :: log ( sprintf ( 'Page "%s" was successfully removed from website' , $ pageName ) ) ; }
12106	public function error ( $ level , $ message , $ file , $ line ) { throw new SyntaxException ( $ message , $ file , $ line , $ level ) ; }
12964	private function getPerMonth ( $ months ) { $ per_month = [ ] ; $ log = $ this -> logger -> perMonth ( $ months ) ; foreach ( $ log as $ date => $ hits ) { array_push ( $ per_month , [ $ date , $ hits ] ) ; } return $ per_month ; }
5759	public function buildPermission ( int $ id , string $ title , ? string $ description , bool $ active , \ DateTimeImmutable $ created , array $ roles ) : Permission { return new Permission ( $ id , $ title , $ description , $ active , $ created , $ roles ) ; }
11820	public function cell_default ( $ item , $ column ) { $ ret = $ this -> val ( $ item , $ column ) ; return is_null ( $ ret ) ? '' : $ ret ; }
10651	public function validateCreate ( ) { $ validator = $ this -> getValidator ( 'create' ) ; if ( $ validator -> fails ( ) ) { $ this -> errors = $ validator -> messages ( ) ; return false ; } return true ; }
5200	public function setOptions ( array $ options ) { $ this -> validateOptions ( $ options ) ; foreach ( $ options as $ option => $ value ) $ this -> $ option = $ value ; return $ this ; }
7788	public function setContraAccountClass ( $ contraAccountClass ) { if ( ! is_callable ( $ contraAccountClass ) && ! class_exists ( $ contraAccountClass ) ) { throw new \ InvalidArgumentException ( '$contraAccountClass must be a valid classname or a PHP callable' ) ; } $ this -> contraAccountClass = $ contraAccountClass ; return $ this ; }
1381	protected function validateToMany ( array $ value , ? string $ field = null ) : bool { $ path = $ field ? "/data/relationships/{$field}/data" : "/data" ; $ valid = true ; foreach ( $ value as $ index => $ item ) { if ( ! $ this -> validateIdentifier ( $ item , $ path , $ index ) ) { $ valid = false ; continue ; } if ( $ this -> isNotFound ( $ item -> type , $ item -> id ) ) { $ this -> resourceDoesNotExist ( "{$path}/{$index}" ) ; $ valid = false ; } } return $ valid ; }
244	public function export ( ) { openlog ( $ this -> identity , $ this -> options , $ this -> facility ) ; foreach ( $ this -> messages as $ message ) { if ( syslog ( $ this -> _syslogLevels [ $ message [ 1 ] ] , $ this -> formatMessage ( $ message ) ) === false ) { throw new LogRuntimeException ( 'Unable to export log through system log!' ) ; } } closelog ( ) ; }
6584	public function sum ( $ n , $ m = 0 ) { if ( $ m > 0 ) return $ this -> sum ( $ n + $ m ) - $ this -> sum ( $ m ) ; static :: ensureValid ( $ n ) ; return $ this -> b * ( 1 - pow ( $ this -> q , $ n ) ) / ( 1 - $ this -> q ) ; }
3361	private function exists ( $ offset = null ) { return isset ( $ this -> container [ $ offset !== null ? $ offset : $ this -> position ] ) ; }
10317	function getUniqueBouncesCount ( $ fromDate = null , $ toDate = null , $ mailingIds = null , $ contactIds = null , $ contactEmails = null , $ contactExternalIds = null , $ excludeAnonymousBounces = false ) { $ params = $ this -> createCountQueryParameters ( $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , $ mailingIds , null ) ; if ( isset ( $ excludeAnonymousBounces ) ) $ params [ 'exclude_anonymous_bounces' ] = ( $ excludeAnonymousBounces == true ) ? "true" : "false" ; return $ this -> get ( 'reports/bounces/unique/count' , $ params ) ; }
9799	public static function compareCells ( self $ a , self $ b ) { if ( $ a -> getRow ( ) < $ b -> getRow ( ) ) { return - 1 ; } elseif ( $ a -> getRow ( ) > $ b -> getRow ( ) ) { return 1 ; } elseif ( Coordinate :: columnIndexFromString ( $ a -> getColumn ( ) ) < Coordinate :: columnIndexFromString ( $ b -> getColumn ( ) ) ) { return - 1 ; } return 1 ; }
4632	public function responseHeaderCallback ( $ ch , $ header ) { if ( strpos ( $ header , ':' ) ) { list ( $ key , $ value ) = explode ( ':' , $ header , 2 ) ; $ value = trim ( $ value ) ; if ( ! empty ( $ value ) ) { if ( ! isset ( $ this -> responseHeaders [ $ key ] ) ) { $ this -> responseHeaders [ $ key ] = $ value ; } elseif ( is_array ( $ this -> responseHeaders [ $ key ] ) ) { $ this -> responseHeaders [ $ key ] = array_merge ( $ this -> responseHeaders [ $ key ] , [ $ value ] ) ; } else { $ this -> responseHeaders [ $ key ] = array_merge ( [ $ this -> responseHeaders [ $ key ] ] , [ $ value ] ) ; } } } return strlen ( $ header ) ; }
4634	public function getComputedAttachments ( ) : array { if ( ! $ this -> hasAttachments ( ) ) { return [ ] ; } $ attachments = $ this -> getAttachments ( ) ; $ dir = $ this -> getAttachmentsDir ( ) ; $ path = $ dir [ 'path' ] ?? null ; $ recursive = $ dir [ 'recursive' ] ?? false ; if ( is_string ( $ path ) && is_dir ( $ path ) ) { $ files = $ recursive ? new RecursiveIteratorIterator ( new RecursiveDirectoryIterator ( $ path , RecursiveDirectoryIterator :: SKIP_DOTS ) , RecursiveIteratorIterator :: CHILD_FIRST ) : new DirectoryIterator ( $ path ) ; foreach ( $ files as $ fileInfo ) { if ( $ fileInfo -> isDir ( ) ) { continue ; } $ attachments [ ] = $ fileInfo -> getPathname ( ) ; } } return $ attachments ; }
6377	public function toArray ( ) : array { $ res = [ ] ; Iterators :: each ( $ this -> iterator ( ) , function ( $ element ) use ( & $ res ) { $ res [ ] = $ element ; } ) ; return $ res ; }
7438	public static function handleException ( \ Throwable $ e ) { self :: render ( $ e -> getCode ( ) , $ e -> getMessage ( ) , $ e -> getFile ( ) , $ e -> getLine ( ) , null , $ e -> getTrace ( ) , get_class ( $ e ) ) ; }
2723	public function execute ( Observer $ observer ) { if ( $ this -> fastlyConfig -> isFastlyEnabled ( ) != true ) { return ; } $ event = $ observer -> getEvent ( ) ; $ name = $ event -> getElementName ( ) ; $ layout = $ event -> getLayout ( ) ; $ block = $ layout -> getBlock ( $ name ) ; if ( $ block instanceof AbstractBlock ) { $ blockTtl = $ block -> getTtl ( ) ; if ( isset ( $ blockTtl ) ) { $ this -> response -> setHeader ( "x-esi" , "1" ) ; } } }
1861	public function chmod ( $ strFile , $ varMode ) { $ this -> validate ( $ strFile ) ; return chmod ( $ this -> strRootDir . '/' . $ strFile , $ varMode ) ; }
1074	public function toArray ( $ debug = false ) { $ result = [ ] ; if ( ! empty ( $ this -> errors ) ) { $ errorsHandler = $ this -> errorsHandler ? : static function ( array $ errors , callable $ formatter ) { return array_map ( $ formatter , $ errors ) ; } ; $ result [ 'errors' ] = $ errorsHandler ( $ this -> errors , FormattedError :: prepareFormatter ( $ this -> errorFormatter , $ debug ) ) ; } if ( $ this -> data !== null ) { $ result [ 'data' ] = $ this -> data ; } if ( ! empty ( $ this -> extensions ) ) { $ result [ 'extensions' ] = $ this -> extensions ; } return $ result ; }
1220	private function validateSeq ( $ from , array $ types , $ a , $ b ) { $ ta = Utils :: type ( $ a ) ; $ tb = Utils :: type ( $ b ) ; if ( $ ta !== $ tb ) { $ msg = "encountered a type mismatch in sequence: {$ta}, {$tb}" ; $ this -> typeError ( $ from , $ msg ) ; } $ typeMatch = ( $ types && $ types [ 0 ] == 'any' ) || in_array ( $ ta , $ types ) ; if ( ! $ typeMatch ) { $ msg = 'encountered a type error in sequence. The argument must be ' . 'an array of ' . implode ( '|' , $ types ) . ' types. ' . "Found {$ta}, {$tb}." ; $ this -> typeError ( $ from , $ msg ) ; } }
1326	public function getSignableParameters ( ) { $ params = $ this -> parameters ; if ( isset ( $ params [ 'oauth_signature' ] ) ) { unset ( $ params [ 'oauth_signature' ] ) ; } return Util :: buildHttpQuery ( $ params ) ; }
10715	public function update ( Model $ model , array $ newAttributes ) { $ results = $ model -> update ( $ newAttributes ) ; if ( ! $ results ) { throw new UpdateFailedRepositoryException ( ) ; } return $ model ; }
4326	public static function getInterface ( ) { $ return = 'http' ; $ isCliOrCron = \ count ( \ array_filter ( array ( \ defined ( 'STDIN' ) , isset ( $ _SERVER [ 'argv' ] ) , ! \ array_key_exists ( 'REQUEST_METHOD' , $ _SERVER ) , ) ) ) > 0 ; if ( $ isCliOrCron ) { $ return = isset ( $ _SERVER [ 'TERM' ] ) || \ array_key_exists ( 'PATH' , $ _SERVER ) ? 'cli' : 'cron' ; } elseif ( isset ( $ _SERVER [ 'HTTP_X_REQUESTED_WITH' ] ) && $ _SERVER [ 'HTTP_X_REQUESTED_WITH' ] == 'XMLHttpRequest' ) { $ return = 'ajax' ; } return $ return ; }
728	public static function off ( $ class , $ name , $ handler = null ) { $ class = ltrim ( $ class , '\\' ) ; if ( empty ( self :: $ _events [ $ name ] [ $ class ] ) && empty ( self :: $ _eventWildcards [ $ name ] [ $ class ] ) ) { return false ; } if ( $ handler === null ) { unset ( self :: $ _events [ $ name ] [ $ class ] ) ; unset ( self :: $ _eventWildcards [ $ name ] [ $ class ] ) ; return true ; } if ( isset ( self :: $ _events [ $ name ] [ $ class ] ) ) { $ removed = false ; foreach ( self :: $ _events [ $ name ] [ $ class ] as $ i => $ event ) { if ( $ event [ 0 ] === $ handler ) { unset ( self :: $ _events [ $ name ] [ $ class ] [ $ i ] ) ; $ removed = true ; } } if ( $ removed ) { self :: $ _events [ $ name ] [ $ class ] = array_values ( self :: $ _events [ $ name ] [ $ class ] ) ; return $ removed ; } } $ removed = false ; if ( isset ( self :: $ _eventWildcards [ $ name ] [ $ class ] ) ) { foreach ( self :: $ _eventWildcards [ $ name ] [ $ class ] as $ i => $ event ) { if ( $ event [ 0 ] === $ handler ) { unset ( self :: $ _eventWildcards [ $ name ] [ $ class ] [ $ i ] ) ; $ removed = true ; } } if ( $ removed ) { self :: $ _eventWildcards [ $ name ] [ $ class ] = array_values ( self :: $ _eventWildcards [ $ name ] [ $ class ] ) ; if ( empty ( self :: $ _eventWildcards [ $ name ] [ $ class ] ) ) { unset ( self :: $ _eventWildcards [ $ name ] [ $ class ] ) ; if ( empty ( self :: $ _eventWildcards [ $ name ] ) ) { unset ( self :: $ _eventWildcards [ $ name ] ) ; } } } } return $ removed ; }
11026	protected function country ( ) { $ this -> parts [ '{country}' ] = $ this -> form -> field ( $ this -> model , $ this -> model -> getCountryPropertyName ( ) , [ 'options' => [ 'class' => 'form-group' ] ] ) -> dropDownList ( ArrayHelper :: map ( Country :: find ( ) -> orderBy ( [ 'name' => SORT_ASC ] ) -> all ( ) , 'id' , 'name' ) , [ 'id' => $ this -> fieldIds [ 'country' ] , 'prompt' => Yii :: t ( 'jlorente/location' , 'Select country' ) , 'name' => $ this -> getSubmitModelName ( $ this -> model -> getCountryPropertyName ( ) ) ] ) ; }
2226	private function renderErrorScreenByException ( GetResponseForExceptionEvent $ event ) : void { $ exception = $ event -> getException ( ) ; $ statusCode = $ this -> getStatusCodeForException ( $ exception ) ; $ template = null ; $ this -> logException ( $ exception ) ; do { if ( $ exception instanceof \ Exception ) { $ template = $ this -> getTemplateForException ( $ exception ) ; } } while ( null === $ template && null !== ( $ exception = $ exception -> getPrevious ( ) ) ) ; $ this -> renderTemplate ( $ template ? : 'error' , $ statusCode , $ event ) ; }
11449	public function fill ( array $ attributes ) { if ( $ this -> getFieldManager ( ) ) { $ attributes = $ this -> getFieldManager ( ) -> transformToResource ( $ attributes ) ; } return parent :: fill ( $ attributes ) ; }
7036	protected function dropMigrationTable ( ) { try { return Db :: query ( "drop table if exists migrations" , [ ] , $ this -> dbName , false ) ; } catch ( PDOException $ e ) { error_log ( $ e -> getMessage ( ) ) ; return false ; } }
5432	protected function isAbstractMethod ( $ name ) { $ interface = new ReflectionClass ( $ this -> interface ) ; if ( ! $ interface -> hasMethod ( $ name ) ) { return false ; } return $ interface -> getMethod ( $ name ) -> isAbstract ( ) ; }
7508	function setWhitespace ( $ ws ) { if ( is_array ( $ ws ) ) { $ this -> whitespace = array_fill_keys ( array_values ( $ ws ) , true ) ; $ this -> buildCharMap ( ) ; } else { $ this -> setWhiteSpace ( str_split ( $ ws ) ) ; } }
5896	public function retrieveImageTemplate ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/templates/images/' . $ id . '' , $ parameters , $ cachePolicy ) ; $ result = new ImageTemplate ( $ result ) ; return $ result ; }
9373	public function display ( ) { $ handler = new PrettyPageHandler ; error_reporting ( E_ALL ) ; $ this -> __call ( 'pushHandler' , array ( $ handler ) ) ; return $ this -> whoops -> register ( ) ; }
9564	protected function makeFatalErrorException ( ) { $ error = error_get_last ( ) ; if ( $ error !== null ) { return new FatalErrorException ( $ error [ 'message' ] , $ error [ 'type' ] , 0 , $ error [ 'file' ] , $ error [ 'line' ] ) ; } return null ; }
10279	public static function coordinateFromString ( $ pCoordinateString ) { if ( preg_match ( '/^([$]?[A-Z]{1,3})([$]?\\d{1,7})$/' , $ pCoordinateString , $ matches ) ) { return [ $ matches [ 1 ] , $ matches [ 2 ] ] ; } elseif ( self :: coordinateIsRange ( $ pCoordinateString ) ) { throw new Exception ( 'Cell coordinate string can not be a range of cells' ) ; } elseif ( $ pCoordinateString == '' ) { throw new Exception ( 'Cell coordinate can not be zero-length string' ) ; } throw new Exception ( 'Invalid cell coordinate ' . $ pCoordinateString ) ; }
5869	protected static function getVirtualFileObject ( $ fileName , array $ metadata ) { $ resourceFactory = GeneralUtility :: makeInstance ( \ TYPO3 \ CMS \ Core \ Resource \ ResourceFactory :: class ) ; $ recordData = [ 'uid' => 0 , 'pid' => 0 , 'name' => 'Temporary Upload Storage' , 'description' => 'Internal storage, mounting the temporary PHP upload directory.' , 'driver' => 'Local' , 'processingfolder' => '' , 'configuration' => '' , 'is_online' => true , 'is_browsable' => false , 'is_public' => false , 'is_writable' => false , 'is_default' => false , ] ; $ storageConfiguration = [ 'basePath' => PathUtility :: dirname ( $ fileName ) , 'pathType' => 'absolute' ] ; $ virtualStorage = $ resourceFactory -> createStorageObject ( $ recordData , $ storageConfiguration ) ; $ name = PathUtility :: basename ( $ fileName ) ; $ extension = strtolower ( substr ( $ name , strrpos ( $ name , '.' ) + 1 ) ) ; $ virtualFileObject = GeneralUtility :: makeInstance ( \ TYPO3 \ CMS \ Core \ Resource \ File :: class , [ 'identifier' => '/' . $ name , 'name' => $ name , 'extension' => $ extension , ] , $ virtualStorage , $ metadata ) ; return $ virtualFileObject ; }
5291	public static function simpleDetect ( $ text ) { $ detections = self :: detect ( $ text ) ; if ( count ( $ detections ) > 0 ) return $ detections [ 0 ] -> language ; else return null ; }
1895	private function addHtaccess ( string $ webDir ) : void { $ htaccess = __DIR__ . '/../Resources/skeleton/web/.htaccess' ; if ( ! file_exists ( $ webDir . '/.htaccess' ) ) { $ this -> fs -> copy ( $ htaccess , $ webDir . '/.htaccess' , true ) ; $ this -> io -> writeln ( 'Added the <comment>web/.htaccess</comment> file.' ) ; return ; } $ existingContent = file_get_contents ( $ webDir . '/.htaccess' ) ; if ( preg_match ( '/^\s*RewriteRule\s/im' , $ existingContent ) ) { return ; } $ this -> fs -> dumpFile ( $ webDir . '/.htaccess' , $ existingContent . "\n\n" . file_get_contents ( $ htaccess ) ) ; $ this -> io -> writeln ( 'Updated the <comment>web/.htaccess</comment> file.' ) ; }
10897	public function setScheme ( $ scheme ) { foreach ( $ this -> uris as $ name => $ uri ) { $ this -> add ( $ name , $ uri -> withScheme ( $ scheme ) ) ; } }
7001	public function method ( $ method = null ) { if ( $ method ) $ this -> method = trim ( $ method ) ; return $ this -> method ; }
4983	public function getIterator ( ) { $ iterator = new PriorityList ( ) ; $ iterator -> isLIFO ( false ) ; foreach ( $ this -> activeForms as $ key ) { $ spec = $ this -> forms [ $ key ] ; $ priority = isset ( $ spec [ 'priority' ] ) ? $ spec [ 'priority' ] : 0 ; $ iterator -> insert ( $ key , $ this -> getForm ( $ key ) , $ priority ) ; } return $ iterator ; }
3602	public function isDebug ( ) { if ( null !== $ this -> container && $ this -> container -> has ( 'kernel' ) ) { return $ this -> container -> get ( 'kernel' ) -> isDebug ( ) ; } return true ; }
11349	public function setData ( $ data ) { $ data = $ this -> transformer -> encode ( $ data ) ; foreach ( $ this -> fields as $ field ) { if ( isset ( $ data [ $ field -> getName ( ) ] ) ) { $ field -> setData ( $ data [ $ field -> getName ( ) ] ) ; } } }
10234	public function main ( ) { $ config = $ this -> app [ 'config' ] [ 'auja' ] ? : $ this -> app [ 'config' ] [ 'auja-laravel::config' ] ; $ authenticationForm = $ this -> app [ 'auja' ] -> authenticationForm ( $ config [ 'title' ] , $ this -> app [ 'url' ] -> route ( 'auja.support.login' , [ ] , false ) ) ; $ username = ( $ this -> app [ 'auth' ] -> user ( ) == null ) ? null : $ this -> app [ 'auth' ] -> user ( ) -> name ; $ main = $ this -> app [ 'auja' ] -> main ( $ config [ 'title' ] , $ this -> app [ 'auth' ] -> check ( ) , $ username , $ this -> app [ 'url' ] -> route ( 'auja.support.logout' , [ ] , false ) , $ authenticationForm ) ; $ main -> setColor ( Main :: COLOR_MAIN , $ config [ 'color' ] [ 'main' ] ) ; $ main -> setColor ( Main :: COLOR_ALERT , $ config [ 'color' ] [ 'alert' ] ) ; $ main -> setColor ( Main :: COLOR_SECONDARY , $ config [ 'color' ] [ 'secondary' ] ) ; return new JsonResponse ( $ main ) ; }
675	public function getPage ( $ recalculate = false ) { if ( $ this -> _page === null || $ recalculate ) { $ page = ( int ) $ this -> getQueryParam ( $ this -> pageParam , 1 ) - 1 ; $ this -> setPage ( $ page , true ) ; } return $ this -> _page ; }
10644	public function getRelativePath ( string $ path ) : string { $ from = $ this -> path ; $ fromParts = explode ( "/" , $ from ) ; $ toParts = explode ( "/" , $ path ) ; $ max = max ( count ( $ fromParts ) , count ( $ toParts ) ) ; for ( $ i = 0 ; $ i < $ max ; $ i ++ ) { if ( ! isset ( $ fromParts [ $ i ] ) || ! isset ( $ toParts [ $ i ] ) || $ fromParts [ $ i ] !== $ toParts [ $ i ] ) { break ; } } $ len = count ( $ fromParts ) - $ i - 1 ; $ path = array_slice ( $ toParts , $ i ) ; if ( $ len < 0 ) { return implode ( "/" , $ path ) ; } return str_repeat ( "../" , $ len ) . implode ( "/" , $ path ) ; }
11764	protected function handleStage ( & $ stages , $ stage ) { if ( $ stage instanceof Pipeline ) { $ stages = array_merge ( $ stages , $ stage -> stages ( ) ) ; } elseif ( $ stage instanceof MiddlewareInterface ) { $ stages [ ] = $ stage ; } elseif ( $ stage instanceof RequestHandlerInterface ) { $ stages [ ] = new RequestHandler ( $ stage ) ; } elseif ( is_callable ( $ stage ) ) { $ stages [ ] = new Lambda ( $ stage ) ; } else { throw new InvalidMiddlewareArgument ( is_string ( $ stage ) ? $ stage : get_class ( $ stage ) ) ; } }
11629	private function createOperation ( $ trans , $ dsBegin ) { $ datePerformed = $ this -> hlpDate -> getUtcNowForDb ( ) ; $ req = new \ Praxigento \ Accounting \ Api \ Service \ Operation \ Create \ Request ( ) ; $ req -> setOperationTypeCode ( Cfg :: CODE_TYPE_OPER_PV_WRITE_OFF ) ; $ req -> setDatePerformed ( $ datePerformed ) ; $ req -> setTransactions ( $ trans ) ; $ period = substr ( $ dsBegin , 0 , 6 ) ; $ note = "PV Write Off ($period)" ; $ req -> setOperationNote ( $ note ) ; $ resp = $ this -> servOperation -> exec ( $ req ) ; $ result = $ resp -> getOperationId ( ) ; return $ result ; }
6225	public function cd ( array $ path ) : void { array_unshift ( $ path , $ this -> path ) ; $ this -> path = new Path ( $ path ) ; }
7048	protected function formatPhoneNumber ( PhoneNumber $ number = null ) { if ( $ number ) { return $ this -> phoneNumberUtil -> format ( $ number , PhoneNumberFormat :: INTERNATIONAL ) ; } return null ; }
1689	public function updateStyleSheets ( ) { $ objStyleSheets = $ this -> Database -> execute ( "SELECT * FROM tl_style_sheet" ) ; $ arrStyleSheets = $ objStyleSheets -> fetchEach ( 'name' ) ; if ( file_exists ( $ this -> strRootDir . '/system/config/dcaconfig.php' ) ) { @ trigger_error ( 'Using the dcaconfig.php file has been deprecated and will no longer work in Contao 5.0. Create one or more DCA files in app/Resources/contao/dca instead.' , E_USER_DEPRECATED ) ; include $ this -> strRootDir . '/system/config/dcaconfig.php' ; } foreach ( scan ( $ this -> strRootDir . '/assets/css' , true ) as $ file ) { if ( is_dir ( $ this -> strRootDir . '/assets/css/' . $ file ) ) { continue ; } if ( \ is_array ( Config :: get ( 'rootFiles' ) ) && \ in_array ( $ file , Config :: get ( 'rootFiles' ) ) ) { continue ; } if ( preg_match ( '/^[a-f0-9]{12}\.css$/' , $ file ) ) { continue ; } $ objFile = new File ( 'assets/css/' . $ file ) ; if ( $ objFile -> extension == 'css' && ! \ in_array ( $ objFile -> filename , $ arrStyleSheets ) ) { $ objFile -> delete ( ) ; } } $ objStyleSheets -> reset ( ) ; while ( $ objStyleSheets -> next ( ) ) { $ this -> writeStyleSheet ( $ objStyleSheets -> row ( ) ) ; $ this -> log ( 'Generated style sheet "' . $ objStyleSheets -> name . '.css"' , __METHOD__ , TL_CRON ) ; } }
994	private function getDescription ( $ node ) { if ( $ node -> description ) { return $ node -> description -> value ; } if ( isset ( $ this -> options [ 'commentDescriptions' ] ) ) { $ rawValue = $ this -> getLeadingCommentBlock ( $ node ) ; if ( $ rawValue !== null ) { return BlockString :: value ( "\n" . $ rawValue ) ; } } return null ; }
10010	public function addSheet ( Worksheet $ pSheet , $ iSheetIndex = null ) { if ( $ this -> sheetNameExists ( $ pSheet -> getTitle ( ) ) ) { throw new Exception ( "Workbook already contains a worksheet named '{$pSheet->getTitle()}'. Rename this worksheet first." ) ; } if ( $ iSheetIndex === null ) { if ( $ this -> activeSheetIndex < 0 ) { $ this -> activeSheetIndex = 0 ; } $ this -> workSheetCollection [ ] = $ pSheet ; } else { array_splice ( $ this -> workSheetCollection , $ iSheetIndex , 0 , [ $ pSheet ] ) ; if ( $ this -> activeSheetIndex >= $ iSheetIndex ) { ++ $ this -> activeSheetIndex ; } } if ( $ pSheet -> getParent ( ) === null ) { $ pSheet -> rebindParent ( $ this ) ; } return $ pSheet ; }
10450	public function delete ( $ key ) { try { $ this -> get ( $ key ) ; } catch ( KeyNotFoundException $ e ) { return false ; } return $ this -> getClient ( ) -> delete ( $ key ) ; }
6959	protected function updateExpiresAt ( CartInterface $ cart ) { $ date = new \ DateTime ( ) ; $ date -> modify ( $ this -> expirationDelay ) ; $ cart -> setExpiresAt ( $ date ) ; return true ; }
4450	public function popByJid ( string $ jid , ? string $ worker = null ) : ? BaseJob { $ workerName = $ worker ? : $ this -> client -> getWorkerName ( ) ; $ data = json_decode ( $ this -> client -> popByJid ( $ this -> name , $ jid , $ workerName ) , true ) ; $ jobData = array_reduce ( $ data , 'array_merge' , [ ] ) ; if ( isset ( $ jobData [ 'jid' ] ) === false ) { return null ; } if ( $ jobData [ 'jid' ] === $ jid ) { $ job = new BaseJob ( $ this -> client , $ jobData ) ; $ job -> setEventsManager ( $ this -> getEventsManager ( ) ) ; } return $ job ?? null ; }
10033	function addUnsubscriptionReasonsToUnsubscribedContact ( $ id , $ checksum = null , $ reasons = null , $ ignore_checksum = false ) { $ queryParameters = array ( ) ; $ queryParameters [ 'id' ] = $ id ; if ( ! empty ( $ checksum ) ) { $ queryParameters [ 'checksum' ] = $ checksum ; } if ( $ ignore_checksum === true ) $ queryParameters [ 'ignore_checksum' ] = "true" ; if ( ! empty ( $ reasons ) ) { if ( is_array ( $ reasons ) ) { $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , 'reason' , $ reasons ) ; } else { $ queryParameters [ 'reason' ] = urlencode ( $ reasons ) ; } } return $ this -> put ( "contacts/contact/unsubscribe/reasons" , null , $ queryParameters ) ; }
10837	protected function buildOrderBy ( ) { $ result = [ ] ; foreach ( $ this -> clause_orderby as $ ord ) { $ result [ ] = $ ord [ 0 ] ? $ ord [ 1 ] : ( $ this -> quote ( $ ord [ 1 ] ) . ' ' . $ ord [ 2 ] ) ; } return $ result ; }
2522	protected function callMessage ( $ messageName , $ options , $ messageOptions , $ endSession = false ) { $ messageOptions = $ this -> makeMessageOptions ( $ messageOptions , $ endSession ) ; $ this -> lastMessage = $ messageName ; $ sendResult = $ this -> sessionHandler -> sendMessage ( $ messageName , $ this -> requestCreator -> createRequest ( $ messageName , $ options ) , $ messageOptions ) ; $ response = $ this -> responseHandler -> analyzeResponse ( $ sendResult , $ messageName ) ; if ( $ messageOptions [ 'returnXml' ] === false ) { $ response -> responseXml = null ; } return $ response ; }
9693	public function getToken ( $ pId = 0 ) { if ( isset ( $ this -> tokens [ $ pId ] ) ) { return $ this -> tokens [ $ pId ] ; } throw new Exception ( "Token with id $pId does not exist." ) ; }
1780	public function generate ( ) { if ( TL_MODE == 'BE' ) { $ objTemplate = new BackendTemplate ( 'be_wildcard' ) ; $ objTemplate -> wildcard = '### ' . Utf8 :: strtoupper ( $ GLOBALS [ 'TL_LANG' ] [ 'FMD' ] [ 'calendar' ] [ 0 ] ) . ' ###' ; $ objTemplate -> title = $ this -> headline ; $ objTemplate -> id = $ this -> id ; $ objTemplate -> link = $ this -> name ; $ objTemplate -> href = 'contao/main.php?do=themes&amp;table=tl_module&amp;act=edit&amp;id=' . $ this -> id ; return $ objTemplate -> parse ( ) ; } $ this -> cal_calendar = $ this -> sortOutProtected ( StringUtil :: deserialize ( $ this -> cal_calendar , true ) ) ; if ( empty ( $ this -> cal_calendar ) || ! \ is_array ( $ this -> cal_calendar ) ) { return '' ; } $ this -> strUrl = preg_replace ( '/\?.*$/' , '' , Environment :: get ( 'request' ) ) ; $ this -> strLink = $ this -> strUrl ; if ( ( $ objTarget = $ this -> objModel -> getRelated ( 'jumpTo' ) ) instanceof PageModel ) { $ this -> strLink = $ objTarget -> getFrontendUrl ( ) ; } return parent :: generate ( ) ; }
1886	public function getItemsAsArray ( ) { $ arrLinks = array ( ) ; $ intNumberOfLinks = floor ( $ this -> intNumberOfLinks / 2 ) ; $ intFirstOffset = $ this -> intPage - $ intNumberOfLinks - 1 ; if ( $ intFirstOffset > 0 ) { $ intFirstOffset = 0 ; } $ intLastOffset = $ this -> intPage + $ intNumberOfLinks - $ this -> intTotalPages ; if ( $ intLastOffset < 0 ) { $ intLastOffset = 0 ; } $ intFirstLink = $ this -> intPage - $ intNumberOfLinks - $ intLastOffset ; if ( $ intFirstLink < 1 ) { $ intFirstLink = 1 ; } $ intLastLink = $ this -> intPage + $ intNumberOfLinks - $ intFirstOffset ; if ( $ intLastLink > $ this -> intTotalPages ) { $ intLastLink = $ this -> intTotalPages ; } for ( $ i = $ intFirstLink ; $ i <= $ intLastLink ; $ i ++ ) { if ( $ i == $ this -> intPage ) { $ arrLinks [ ] = array ( 'page' => $ i , 'href' => null , 'title' => null ) ; } else { $ arrLinks [ ] = array ( 'page' => $ i , 'href' => $ this -> linkToPage ( $ i ) , 'title' => StringUtil :: specialchars ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'goToPage' ] , $ i ) ) ) ; } } return $ arrLinks ; }
2222	public static function countPublishedFromToByPids ( $ intFrom , $ intTo , $ arrPids , array $ arrOptions = array ( ) ) { if ( empty ( $ arrPids ) || ! \ is_array ( $ arrPids ) ) { return null ; } $ t = static :: $ strTable ; $ arrColumns = array ( "$t.date>=? AND $t.date<=? AND $t.pid IN(" . implode ( ',' , array_map ( '\intval' , $ arrPids ) ) . ")" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } return static :: countBy ( $ arrColumns , array ( $ intFrom , $ intTo ) , $ arrOptions ) ; }
11460	public function send ( ) : bool { $ sHeaders = 'From: ' . $ this -> _sFrom . "\r\n" ; if ( empty ( $ this -> _aAttachments ) ) { if ( $ this -> _sFormat == "HTML" ) { $ sHeaders .= 'MIME-Version: 1.0' . "\r\n" ; $ sHeaders .= 'Content-type: text/html; charset=UTF-8' . "\r\n" ; } return mail ( implode ( ',' , $ this -> _aRecipient ) , $ this -> _sSubject , $ this -> _sMessage , $ sHeaders ) ; } else { $ sBoundary = "_" . md5 ( uniqid ( rand ( ) ) ) ; $ sAttached = "" ; foreach ( $ this -> _aAttachments as $ aAttachment ) { $ sAttached_file = chunk_split ( base64_encode ( $ aAttachment [ "content" ] ) ) ; $ sAttached = "\n\n" . "--" . $ sBoundary . "\nContent-Type: application; name=\"" . $ aAttachment [ "name" ] . "\"\r\nContent-Transfer-Encoding: base64\r\nContent-Disposition: attachment; filename=\"" . $ aAttachment [ "name" ] . "\"\r\n\n" . $ sAttached_file . "--" . $ sBoundary . "--" ; } $ sHeaders = 'From: ' . $ this -> _sFrom . "\r\n" ; $ sHeaders .= "MIME-Version: 1.0\r\nContent-Type: multipart/mixed; boundary=\"$sBoundary\"\r\n" ; $ sBody = "--" . $ sBoundary . "\nContent-Type: " . ( $ this -> _sFormat == "HTML" ? "text/html" : "text/plain" ) . "; charset=UTF-8\r\n\n" . $ this -> _sMessage . $ sAttached ; return mail ( implode ( ',' , $ this -> _aRecipient ) , $ this -> _sSubject , $ sBody , $ sHeaders ) ; } }
12680	public function hasFlag ( $ name ) { $ option = $ this -> definition -> getOption ( $ name ) ; if ( ! $ option -> isFlag ( ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The "--%s" option is not a flag.' , $ name ) ) ; } return ! empty ( $ this -> options [ $ name ] ) ; }
4801	public function injectSpecialBindings ( string $ sql , array $ bindings ) : string { foreach ( self :: SPECIAL_BINDINGS as $ special ) { $ specialPlaceholder = ":" . $ special ; if ( ! array_key_exists ( $ special , $ bindings ) ) { continue ; } $ replacement = $ this -> escapeSpecialBinding ( $ bindings [ $ special ] , $ special ) ; $ sql = str_replace ( $ specialPlaceholder , $ replacement , $ sql ) ; unset ( $ bindings [ $ special ] ) ; } foreach ( $ bindings as $ key => $ value ) { if ( is_array ( $ value ) ) { $ inString = "" ; foreach ( $ value as $ i => $ innerValue ) { $ newKey = $ key . "__" . $ i ; $ keyParamString = ":$newKey" ; $ inString .= "$keyParamString, " ; } $ inString = rtrim ( $ inString , " ," ) ; $ sql = str_replace ( ":$key" , $ inString , $ sql ) ; } } return $ sql ; }
8690	protected function validateElementValues ( ) { foreach ( self :: $ mandatoryFields as $ field ) { if ( array_key_exists ( $ field , $ this -> attributes ) ) { $ value = ( int ) $ this -> attributes [ $ field ] ; if ( $ value < 0 ) { throw new \ SVGCreator \ SVGException ( "The " . $ field . " value is lesser than 0, in element " . self :: TYPE , 1 ) ; } } } }
1211	public function callRecursively ( ItemInterface $ item , $ method , $ arguments = array ( ) ) { call_user_func_array ( array ( $ item , $ method ) , $ arguments ) ; foreach ( $ item -> getChildren ( ) as $ child ) { $ this -> callRecursively ( $ child , $ method , $ arguments ) ; } }
6195	protected function findControllerFiles ( ) { $ result = [ ] ; foreach ( $ this -> controllerDirs as $ dir ) { $ directoryIterator = new \ RecursiveDirectoryIterator ( $ dir ) ; $ iterator = new \ RecursiveIteratorIterator ( $ directoryIterator ) ; $ files = new \ RegexIterator ( $ iterator , '/\.php$/i' , \ RecursiveRegexIterator :: GET_MATCH ) ; foreach ( $ files as $ k => $ v ) { $ result [ $ k ] = filemtime ( $ k ) ; } } return $ result ; }
7716	static function FindElement ( & $ TxtOrObj , $ Tag , $ PosBeg , $ Forward = true ) { $ XmlLoc = clsTbsXmlLoc :: FindStartTag ( $ TxtOrObj , $ Tag , $ PosBeg , $ Forward ) ; if ( $ XmlLoc === false ) return false ; $ XmlLoc -> FindEndTag ( ) ; return $ XmlLoc ; }
2721	private function getMessageInStoreLocale ( StoreInterface $ emulatedStore ) { $ currentStore = $ this -> storeManager -> getStore ( ) ; $ this -> localeResolver -> emulate ( $ emulatedStore -> getId ( ) ) ; $ this -> storeManager -> setCurrentStore ( $ emulatedStore -> getId ( ) ) ; $ message = __ ( 'You are in the wrong store. Click OK to visit the %1 store.' , [ $ emulatedStore -> getName ( ) ] ) -> __toString ( ) ; $ this -> localeResolver -> revert ( ) ; $ this -> storeManager -> setCurrentStore ( $ currentStore -> getId ( ) ) ; return $ message ; }
8642	public function getReportRequestListByNextToken ( $ request ) { if ( ! $ request instanceof MarketplaceWebService_Model_GetReportRequestListByNextTokenRequest ) { $ request = new MarketplaceWebService_Model_GetReportRequestListByNextTokenRequest ( $ request ) ; } $ httpResponse = $ this -> invoke ( $ this -> convertGetReportRequestListByNextToken ( $ request ) ) ; $ response = MarketplaceWebService_Model_GetReportRequestListByNextTokenResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
7437	public static function handleFatal ( ) { $ error = error_get_last ( ) ; if ( null !== $ error ) { self :: render ( $ error [ "type" ] , $ error [ "message" ] , $ error [ "file" ] , $ error [ "line" ] ) ; } }
11151	public function getApi ( ) { if ( $ this -> api === null ) { $ this -> api = new ExtDirectApi ( $ this -> useCache ( ) , $ this -> getApplicationPath ( ) , $ this -> getApplicationNameSpace ( ) ) ; } return $ this -> api ; }
649	public function dropCommentFromColumn ( $ table , $ column ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> dropCommentFromColumn ( $ table , $ column ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; }
12643	public function getWidgetId ( ) { if ( ! is_null ( $ this -> _widgetId ) ) { return $ this -> _widgetId ; } return $ this -> _widgetId = 'ic-widget-' . md5 ( microtime ( ) . mt_rand ( ) ) ; }
8167	public function addIndentation ( ) { @ trigger_error ( 'The ' . __METHOD__ . ' method is deprecated since version 1.27 and will be removed in 2.0. Use write(\'\') instead.' , E_USER_DEPRECATED ) ; $ this -> source .= str_repeat ( ' ' , $ this -> indentation * 4 ) ; return $ this ; }
8523	public function setAdvertisingRecommendations ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'AdvertisingRecommendations' ] [ 'FieldValue' ] = $ value ; return $ this ; }
2470	public function getMaxDepthForContent ( ContentType $ contentType ) : int { if ( isset ( $ this -> contentTypeMap [ $ contentType -> identifier ] ) ) { return $ this -> contentTypeMap [ $ contentType -> identifier ] ; } return $ this -> defaultIndexingDepth ; }
4227	public function unregister ( ) { if ( ! $ this -> registered ) { return ; } $ errHandlerCur = \ set_error_handler ( array ( $ this , 'handleError' ) ) ; \ restore_error_handler ( ) ; if ( $ errHandlerCur == array ( $ this , 'handleError' ) ) { \ restore_error_handler ( ) ; } $ exHandlerCur = \ set_exception_handler ( array ( $ this , 'handleException' ) ) ; \ restore_exception_handler ( ) ; if ( $ exHandlerCur == array ( $ this , 'handleException' ) ) { \ restore_exception_handler ( ) ; } \ ini_set ( 'display_errors' , $ this -> prevDisplayErrors ) ; $ this -> prevErrorHandler = null ; $ this -> prevExceptionHandler = null ; $ this -> registered = false ; return ; }
6512	public function updateJob ( EntityJobInterface $ job , Status $ status , $ processingTime = 0 , $ response = null ) { $ job -> setStatus ( $ status ) ; $ job -> setProcessingTime ( $ job -> getProcessingTime ( ) + ( $ processingTime === null ? 0 : $ processingTime ) ) ; $ job -> setResponse ( $ response ) ; if ( Status :: isTerminated ( $ status ) ) { $ job -> setTerminatedAt ( new \ DateTime ( ) ) ; } if ( $ job -> hasSchedules ( ) && Status :: isTerminated ( $ status ) ) { foreach ( $ job -> getSchedules ( ) as $ schedule ) { if ( method_exists ( $ schedule , 'setIsActive' ) ) { $ schedule -> setIsActive ( false ) ; } } } }
6025	public function addMetaData ( $ item ) { if ( ! ( $ item instanceof MetaData ) ) { if ( is_array ( $ item ) ) { try { $ item = new MetaData ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate MetaData. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "MetaData"!' , E_USER_WARNING ) ; } } $ this -> metadata [ ] = $ item ; return $ this ; }
151	public function createCommand ( $ db = null ) { if ( $ db === null ) { $ db = Yii :: $ app -> getDb ( ) ; } list ( $ sql , $ params ) = $ db -> getQueryBuilder ( ) -> build ( $ this ) ; $ command = $ db -> createCommand ( $ sql , $ params ) ; $ this -> setCommandCache ( $ command ) ; return $ command ; }
9755	function a ( string $ type = '' ) : self { return mb_strlen ( $ type ) ? $ this -> expect ( $ this -> target , isType ( $ type ) ) : $ this ; }
6030	public function setChildMedias ( array $ childMedias ) { $ this -> childMedias = [ ] ; foreach ( $ childMedias as $ item ) { $ this -> addself ( $ item ) ; } return $ this ; }
7175	public static function set_path ( & $ array , $ path , $ value , $ delimiter = null ) : void { if ( ! $ delimiter ) { $ delimiter = static :: $ delimiter ; } $ keys = $ path ; if ( ! is_array ( $ path ) ) { $ keys = explode ( $ delimiter , $ path ) ; } while ( count ( $ keys ) > 1 ) { $ key = array_shift ( $ keys ) ; if ( is_string ( $ key ) && ctype_digit ( $ key ) ) { $ key = ( int ) $ key ; } if ( ! isset ( $ array [ $ key ] ) ) { $ array [ $ key ] = array ( ) ; } $ array = & $ array [ $ key ] ; } $ array [ array_shift ( $ keys ) ] = $ value ; }
11694	protected function getCompiler ( SplFileInfo $ file ) : Compiler { $ source_type = $ this -> getSourceType ( $ file ) ; $ compiler_type = '\Gears\Asset\Compilers\\' ; $ compiler_type .= ucfirst ( $ source_type ) ; if ( ! class_exists ( $ compiler_type ) ) { throw new RuntimeException ( 'The source file type is not supported! - (' . $ file . ')' ) ; } return new $ compiler_type ( $ file , $ this -> destination , $ this -> debug , $ this -> autoprefix ) ; }
9650	public function delete ( ) { $ options = $ this -> Options ( ) ; if ( $ options ) { foreach ( $ options as $ option ) { $ option -> delete ( ) ; } } parent :: delete ( ) ; }
5723	public function unPublish ( ) { $ origStage = Versioned :: get_stage ( ) ; Versioned :: set_stage ( 'Live' ) ; $ clone = clone $ this -> owner -> record ; $ clone -> delete ( ) ; Versioned :: set_stage ( $ origStage ) ; return $ this -> owner -> edit ( Controller :: curr ( ) -> getRequest ( ) ) ; }
8925	public function mapJson ( $ json , $ targetClass ) { if ( ! is_array ( $ data = json_decode ( $ json , true ) ) ) { throw new InvalidJsonException ( ) ; } $ result = null ; if ( substr ( $ targetClass , - 2 ) == '[]' ) { $ result = [ ] ; foreach ( $ data as $ key => $ entryData ) { $ result [ ] = $ this -> mapDataToObject ( $ entryData , substr ( $ targetClass , 0 , - 2 ) ) ; } } else { $ result = $ this -> mapDataToObject ( $ data , $ targetClass ) ; } return $ result ; }
8543	public function setShipmentEventList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ShipmentEventList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
5404	public function restartSession ( $ date = false ) { $ surviving_cookies = array ( ) ; for ( $ i = 0 ; $ i < count ( $ this -> cookies ) ; $ i ++ ) { if ( ! $ this -> cookies [ $ i ] -> getValue ( ) ) { continue ; } if ( ! $ this -> cookies [ $ i ] -> getExpiry ( ) ) { continue ; } if ( $ date && $ this -> cookies [ $ i ] -> isExpired ( $ date ) ) { continue ; } $ surviving_cookies [ ] = $ this -> cookies [ $ i ] ; } $ this -> cookies = $ surviving_cookies ; }
3644	public function map ( array $ keys , bool $ trim = true , bool $ clean = true ) { $ values = $ this -> only ( array_keys ( $ keys ) , $ trim , $ clean ) ; $ new = [ ] ; foreach ( $ keys as $ key => $ value ) { $ new [ $ value ] = array_get ( $ values , $ key ) ; } return $ new ; }
3083	public function getAssessmentItemRefByIdentifier ( \ tao_models_classes_service_StorageDirectory $ privateCompilationDirectory , $ identifier ) { $ compilationDataService = $ this -> getServiceLocator ( ) -> get ( CompilationDataService :: SERVICE_ID ) ; $ filename = "adaptive-assessment-item-ref-${identifier}" ; return $ compilationDataService -> readPhpCompilationData ( $ privateCompilationDirectory , "${filename}.php" , "${filename}" ) ; }
7767	public function loadMetadataForClass ( $ className ) { foreach ( $ this -> drivers as $ namespace => $ driver ) { if ( strpos ( $ className , $ namespace ) === 0 ) { return $ driver -> loadMetadataForClass ( $ className ) ; } } return null ; }
4467	private function reload ( ) : void { $ this -> sha = ( string ) @ sha1_file ( $ this -> corePath ) ; if ( empty ( $ this -> sha ) ) { throw new RuntimeException ( 'Unable to locate qless-core file at path: ' . $ this -> corePath ) ; } $ res = $ this -> redis -> script ( 'exists' , $ this -> sha ) ; if ( $ res [ 0 ] !== 1 ) { $ this -> sha = $ this -> redis -> script ( 'load' , file_get_contents ( $ this -> corePath ) ) ; } }
4720	public function register ( Text $ text ) { $ hash = $ this -> generateHash ( $ text ) ; $ this -> set ( $ hash , $ text ) ; return new Text ( $ hash ) ; }
10613	protected function authenticateUser ( UserInterface $ user , Response $ response ) { try { $ this -> get ( 'fos_user.security.login_manager' ) -> loginUser ( $ this -> container -> getParameter ( 'fos_user.firewall_name' ) , $ user , $ response ) ; } catch ( AccountStatusException $ ex ) { } }
9723	private function getTemporaryFolder ( ) { $ tempFolder = sys_get_temp_dir ( ) . '/phpspreadsheet' ; if ( ! is_dir ( $ tempFolder ) ) { if ( ! mkdir ( $ tempFolder ) && ! is_dir ( $ tempFolder ) ) { throw new \ RuntimeException ( sprintf ( 'Directory "%s" was not created' , $ tempFolder ) ) ; } } return $ tempFolder ; }
10964	public static function getHost ( ) { $ host = null ; if ( isset ( $ _SERVER [ 'HTTP_X_FORWARDED_HOST' ] ) ) { $ host = $ _SERVER [ 'HTTP_X_FORWARDED_HOST' ] ; } elseif ( isset ( $ _SERVER [ 'HTTP_HOST' ] ) ) { $ host = $ _SERVER [ 'HTTP_HOST' ] ; } elseif ( isset ( $ _SERVER [ 'SERVER_NAME' ] ) ) { $ host = $ _SERVER [ 'SERVER_NAME' ] ; } else { $ host = gethostname ( ) ; } return $ host ; }
12476	public function setCurrentTheme ( $ identifier ) { $ theme = $ this -> getTheme ( $ identifier ) ; $ this -> container -> get ( 'session' ) -> set ( '_admin_theme' , $ theme ) ; }
9309	public function show ( $ id , $ params = [ ] ) { $ data = [ 'id' => $ id ] + $ params ; return $ this -> query ( __FUNCTION__ , $ data ) ; }
1499	public function when ( bool $ test , $ encodings ) : self { if ( ! $ test || is_null ( $ encodings ) ) { return $ this ; } if ( $ encodings instanceof \ Closure ) { return $ encodings ( $ this ) ; } if ( is_string ( $ encodings ) ) { $ encodings = Encoding :: custom ( $ encodings ) ; } $ encodings = $ encodings instanceof Encoding ? [ $ encodings ] : $ encodings ; return $ this -> push ( ... $ encodings ) ; }
10840	protected function getRaw ( $ Key ) { $ CacheFile = $ this -> getCacheFile ( $ Key ) ; if ( ! file_exists ( $ CacheFile ) ) { return false ; } return unserialize ( file_get_contents ( $ CacheFile ) ) ; }
10595	protected function initViewPanelTableData ( ) { $ items = [ ] ; $ currentRouteName = $ this -> currentRoute ? $ this -> currentRoute -> GetName ( ) : NULL ; foreach ( $ this -> routes as & $ route ) { $ matched = FALSE ; if ( $ currentRouteName !== NULL && $ route -> GetName ( ) === $ currentRouteName ) { $ matched = TRUE ; } $ items [ ] = $ this -> initViewPanelTableRow ( $ route , $ matched ) ; } $ this -> view -> items = $ items ; }
5571	public function back ( ) { if ( ! $ this -> history -> back ( ) ) { return false ; } $ content = $ this -> retry ( ) ; if ( ! $ content ) { $ this -> history -> forward ( ) ; } return $ content ; }
7676	function TbsQuickLoad ( $ NameLst ) { if ( ! is_array ( $ NameLst ) ) $ NameLst = array ( $ NameLst ) ; $ nbr = 0 ; $ TBS = & $ this -> TBS ; foreach ( $ NameLst as $ FileName ) { $ idx = $ this -> FileGetIdx ( $ FileName ) ; if ( ( ! isset ( $ this -> TbsStoreLst [ $ idx ] ) ) && ( ! isset ( $ this -> TbsNoField [ $ idx ] ) ) ) { $ txt = $ this -> FileRead ( $ idx , true ) ; if ( strpos ( $ txt , $ TBS -> _ChrOpen ) !== false ) { $ nbr ++ ; if ( $ nbr == 1 ) { $ MergeAutoFields = $ this -> TbsMergeAutoFields ( ) ; $ SaveIdx = $ this -> TbsCurrIdx ; $ SaveName = $ TBS -> OtbsCurrFile ; $ this -> TbsSwitchMode ( true ) ; } $ this -> TbsStorePark ( ) ; $ TBS -> Source = $ txt ; unset ( $ txt ) ; $ TBS -> OtbsCurrFile = $ FileName ; $ this -> TbsCurrIdx = $ idx ; if ( $ MergeAutoFields ) $ TBS -> LoadTemplate ( null , '+' ) ; } else { $ this -> TbsNoField [ $ idx ] = true ; } } } if ( $ nbr > 0 ) { $ this -> TbsSwitchMode ( false ) ; $ this -> TbsStorePark ( ) ; $ this -> TbsStoreLoad ( $ SaveIdx , $ SaveName ) ; } return $ nbr ; }
11829	public function getByTag ( $ tag ) { $ taggings = $ this -> getTaggings ( ) ; if ( array_key_exists ( $ tag , $ taggings ) ) { return $ taggings [ $ tag ] ; } return array ( ) ; }
3140	public function hasFeedbacks ( RunnerServiceContext $ context , $ itemRef ) { $ hasFeedbacks = false ; $ displayFeedbacks = $ this -> displayFeedbacks ( $ context ) ; if ( $ displayFeedbacks ) { $ feedbacks = $ this -> getFeedbacks ( $ context , $ itemRef ) ; foreach ( $ feedbacks as $ entry ) { if ( isset ( $ entry [ 'feedbackRules' ] ) ) { if ( count ( $ entry [ 'feedbackRules' ] ) > 0 ) { $ hasFeedbacks = true ; } break ; } } } return $ hasFeedbacks ; }
12143	public static function user ( ) { if ( ! static :: $ user and static :: $ factory ) { $ id = static :: provider ( ) -> get ( 'id' ) ; static :: $ user = call_user_func ( static :: $ factory , $ id ) ; } return static :: $ user ; }
5512	public function expectMaximumCallCount ( $ method , $ count , $ message = '%s' ) { $ this -> dieOnNoMethod ( $ method , 'set maximum call count' ) ; $ message .= Mock :: getExpectationLine ( ) ; $ this -> max_counts [ strtolower ( $ method ) ] = new MaximumCallCountExpectation ( $ method , $ count , $ message ) ; }
12349	public function getTaxonomy ( $ system_id ) { foreach ( $ this -> getTaxonomies ( ) as $ taxonomy ) { if ( $ taxonomy -> system_id === $ system_id ) { return $ taxonomy ; } } return false ; }
9475	public function stripQuotes ( $ string ) { if ( strlen ( $ string ) < 2 || substr ( $ string , 0 , 1 ) !== '"' || substr ( $ string , - 1 , 1 ) !== '"' ) { return $ string ; } return substr ( $ string , 1 , - 1 ) ; }
10498	public function root ( $ value ) { $ value = Cast :: Float ( $ value ) ; if ( $ this -> value === null ) { return new FloatType ( $ this -> value ) ; } return new FloatType ( pow ( $ this -> value , 1 / $ value ) ) ; }
1804	protected function invalidateCacheTags ( self $ dc ) { if ( ! System :: getContainer ( ) -> has ( 'fos_http_cache.cache_manager' ) ) { return ; } $ ns = 'contao.db.' ; $ tags = array ( $ ns . $ dc -> table , $ ns . $ dc -> table . '.' . $ dc -> id ) ; if ( $ dc -> ptable && $ dc -> activeRecord && $ dc -> activeRecord -> pid > 0 ) { $ tags [ ] = $ ns . $ dc -> ptable ; $ tags [ ] = $ ns . $ dc -> ptable . '.' . $ dc -> activeRecord -> pid ; } if ( \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'config' ] [ 'oninvalidate_cache_tags_callback' ] ) ) { foreach ( $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'config' ] [ 'oninvalidate_cache_tags_callback' ] as $ callback ) { if ( \ is_array ( $ callback ) ) { $ this -> import ( $ callback [ 0 ] ) ; $ tags = $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ dc , $ tags ) ; } elseif ( \ is_callable ( $ callback ) ) { $ tags = $ callback ( $ dc , $ tags ) ; } } } $ tags = array_filter ( array_unique ( $ tags ) ) ; $ cacheManager = System :: getContainer ( ) -> get ( 'fos_http_cache.cache_manager' ) ; $ cacheManager -> invalidateTags ( $ tags ) ; }
789	public function getFirstError ( $ attribute ) { return isset ( $ this -> _errors [ $ attribute ] ) ? reset ( $ this -> _errors [ $ attribute ] ) : null ; }
5774	public function isDeletable ( ) : bool { if ( is_null ( $ this -> authorization ) ) { throw new \ Exception ( "Authorization must be set" ) ; } $ id = $ this -> getId ( ) ; if ( $ this -> isLoggedIn ( ) ) { $ this -> notDeletableReason = "Administrator cannot delete own account: id $id" ; return false ; } if ( ! $ this -> getAuthorization ( ) -> hasTopRole ( ) && $ this -> hasTopRole ( ) ) { $ this -> notDeletableReason = "Not authorized to delete administrator: id $id" ; return false ; } if ( ( EventsTableMapper :: getInstance ( ) ) -> existForAdministrator ( $ id ) ) { $ this -> notDeletableReason = "Events exist for administrator: id $id" ; return false ; } return true ; }
2554	protected static function makePricingOptionFareFamilyOverride ( $ fareFamily ) { $ opt = [ ] ; if ( $ fareFamily !== null ) { $ po = new PricingOptionGroup ( PricingOptionKey :: OPTION_FARE_FAMILY ) ; $ po -> optionDetail = new OptionDetail ( [ [ 'FF' => $ fareFamily ] ] ) ; $ opt [ ] = $ po ; } return $ opt ; }
12487	public static function enableLogging ( $ writePath ) { if ( is_file ( $ writePath ) ) { self :: $ enabled = true ; self :: $ logFilePath = $ writePath ; return true ; } throw new \ Exception ( 'Impossible d\'activer les logs dans le fichier ' . $ writePath . ' : celui ci n\'existe pas.' ) ; return false ; }
7616	public function authenticateApp ( $ consumer_key , $ consumer_secret ) { $ bearer_token = $ this -> encodeBearer ( $ consumer_key , $ consumer_secret ) ; $ headers = array ( 'Authorization' => 'Basic ' . $ bearer_token , 'Content-Type' => 'application/x-www-form-urlencoded;charset=UTF-8' ) ; $ body = 'grant_type=client_credentials' ; $ response = $ this -> client -> post ( '/oauth2/token' , $ headers , $ body ) -> send ( ) ; $ data = $ response -> json ( ) ; $ this -> bearer = $ data [ 'access_token' ] ; return $ this -> bearer ; }
12652	public function getPageTexts ( $ language ) { if ( ! isset ( $ this -> contents [ $ language ] ) ) { $ this -> contents [ $ language ] = $ this -> readFileContents ( $ language ) ; } return $ this -> contents [ $ language ] ; }
11944	private function validateGetPost ( $ data , ConfigContainer $ config , $ position ) { $ argumentName = $ config -> getValue ( 'name' ) ; $ default = $ config -> getValue ( 'default' ) ; if ( ! isset ( $ data [ $ argumentName ] ) ) { if ( $ default !== false ) { return $ default ; } else { throw new RequiredArgumentException ( $ position , $ argumentName ) ; } } return $ data [ $ argumentName ] ; }
10780	private function addCacheLimiterHeaders ( ResponseInterface $ response ) : ResponseInterface { $ cache = new CacheUtil ( ) ; switch ( session_cache_limiter ( ) ) { case 'public' : $ response = $ cache -> withExpires ( $ response , time ( ) + session_cache_limiter ( ) * 60 ) ; $ response = $ cache -> withCacheControl ( $ response , ( new ResponseCacheControl ( ) ) -> withPublic ( ) -> withMaxAge ( session_cache_limiter ( ) * 60 ) ) ; break ; case 'private_no_expire' : $ response = $ cache -> withCacheControl ( $ response , ( new ResponseCacheControl ( ) ) -> withPrivate ( ) -> withMaxAge ( session_cache_limiter ( ) * 60 ) ) ; break ; case 'private' : $ response = $ cache -> withExpires ( $ response , 'Thu, 19 Nov 1981 08:52:00 GMT' ) ; $ response = $ cache -> withCacheControl ( $ response , ( new ResponseCacheControl ( ) ) -> withPrivate ( ) -> withMaxAge ( session_cache_limiter ( ) * 60 ) ) ; break ; case 'nocache' : $ response = $ cache -> withExpires ( $ response , 'Thu, 19 Nov 1981 08:52:00 GMT' ) ; $ response = $ cache -> withCacheControl ( $ response , ( new ResponseCacheControl ( ) ) -> withPrivate ( ) -> withCachePrevention ( ) ) ; $ response = $ response -> withHeader ( "Pragma" , "no-cache" ) ; break ; } return $ response ; }
4993	public function getActiveFormActual ( $ setDefault = true ) { $ key = null ; if ( ! empty ( $ this -> activeForms ) ) { $ key = $ this -> activeForms [ 0 ] ; } if ( ! isset ( $ key ) && $ setDefault ) { $ formsAvailable = array_keys ( $ this -> forms ) ; $ key = array_shift ( $ formsAvailable ) ; } return $ key ; }
7065	public function getAuthActions ( ) { if ( ! $ this -> _AuthActions ) { if ( Configure :: load ( 'auth_actions' ) === false ) { trigger_error ( 'AuthActions: Could not load config/auth_actions.php' , E_USER_WARNING ) ; } $ actionConfig = Configure :: read ( 'auth_actions' ) ; $ publicActionsConfig = Configure :: read ( 'public_actions' ) ; $ options = Configure :: read ( 'auth_settings' ) ; if ( ! is_array ( $ options ) ) { $ options = [ ] ; } if ( ! is_array ( $ publicActionsConfig ) ) { $ publicActionsConfig = [ ] ; } $ this -> _AuthActions = new AuthActions ( $ actionConfig , $ publicActionsConfig , $ options ) ; } return $ this -> _AuthActions ; }
9606	public function multiplyByScalar ( $ scalar ) { $ result = [ ] ; foreach ( $ this -> components ( ) as $ i => $ component ) { $ result [ $ i ] = $ component * $ scalar ; } return new static ( $ result ) ; }
5944	public function categories ( $ categoryIds , $ deploymentSiteIds = null , $ ignoreGrouping = false , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'deploymentSiteIds' => $ deploymentSiteIds , 'ignoreGrouping' => $ ignoreGrouping ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/filters/categories/' . $ categoryIds . '' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new FilterItem ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
4582	public function created ( JWTCreatedEvent $ event ) { $ payload = $ event -> getData ( ) ; $ user = $ event -> getUser ( ) ; $ payload [ $ this -> attribute ] = $ user -> getTenant ( ) ; $ event -> setData ( $ payload ) ; }
3291	public function signal ( int $ signo ) { if ( ! $ this -> isRunning ( ) ) { throw new StatusError ( "Process is not running." ) ; } $ this -> processRunner -> signal ( $ this -> handle , $ signo ) ; }
5986	public function getTokens ( ) { $ tokens = [ 'accessToken' => null , 'refreshToken' => null ] ; if ( $ this -> oauth2Middleware instanceof OAuthMiddleware ) { $ tokens [ 'accessToken' ] = $ this -> oauth2Middleware -> getAccessToken ( ) ; $ tokens [ 'refreshToken' ] = $ this -> oauth2Middleware -> getRefreshToken ( ) ; } if ( $ this -> cache instanceof Cache && empty ( $ tokens [ 'accessToken' ] ) && $ this -> cache -> contains ( 'oauth2accesstoken' ) ) { $ tokens [ 'accessToken' ] = unserialize ( $ this -> cache -> fetch ( 'oauth2accesstoken' ) ) ; } if ( $ this -> cache instanceof Cache && empty ( $ tokens [ 'accessToken' ] ) && $ this -> cache -> contains ( 'oauth2refreshtoken' ) ) { $ tokens [ 'refreshToken' ] = unserialize ( $ this -> cache -> fetch ( 'oauth2refreshtoken' ) ) ; } if ( empty ( $ tokens [ 'accessToken' ] ) ) { $ response = $ this -> getClient ( ) -> get ( '/' ) ; $ tokens [ 'accessToken' ] = $ this -> oauth2Middleware -> getAccessToken ( ) ; $ tokens [ 'refreshToken' ] = $ this -> oauth2Middleware -> getRefreshToken ( ) ; } return $ tokens ; }
5780	private function setNav ( ) { $ this -> nav = [ 'System' => [ 'subSections' => [ 'Administrators' => [ 'route' => ROUTE_ADMINISTRATORS , 'authorization' => ADMINISTRATORS_VIEW_RESOURCE , 'subSections' => [ 'Insert' => [ 'route' => ROUTE_ADMINISTRATORS_INSERT , 'authorization' => ADMINISTRATORS_INSERT_RESOURCE , ] , ] ] , 'Roles' => [ 'route' => ROUTE_ADMINISTRATORS_ROLES , 'authorization' => ROLES_VIEW_RESOURCE , 'subSections' => [ 'Insert' => [ 'route' => ROUTE_ADMINISTRATORS_ROLES_INSERT , 'authorization' => ROLES_INSERT_RESOURCE , ] , ] , ] , 'Permissions' => [ 'route' => ROUTE_ADMINISTRATORS_PERMISSIONS , 'authorization' => PERMISSIONS_VIEW_RESOURCE , 'subSections' => [ 'Insert' => [ 'route' => ROUTE_ADMINISTRATORS_PERMISSIONS_INSERT , 'authorization' => PERMISSIONS_INSERT_RESOURCE , ] , ] ] , 'Events' => [ 'route' => ROUTE_EVENTS , 'authorization' => EVENTS_VIEW_RESOURCE , 'subSections' => [ 'Types' => [ 'route' => ROUTE_DATABASE_TABLES , 'args' => [ ROUTEARG_DATABASE_TABLE_NAME => 'event_types' ] , 'authorization' => EVENTS_VIEW_RESOURCE , ] , ] ] , 'Database' => [ 'authorization' => DATABASE_TABLES_VIEW_RESOURCE , 'subSections' => $ this -> getDatabaseTablesSection ( ) ] , ] ] , 'Logout' => [ 'route' => ROUTE_LOGOUT , ] , ] ; if ( isset ( $ this -> container [ 'settings' ] [ 'adminNav' ] ) ) { if ( ! is_array ( $ this -> container [ 'settings' ] [ 'adminNav' ] ) ) { throw new \ Exception ( "adminNav config must be array" ) ; } $ this -> nav = array_merge ( $ this -> container [ 'settings' ] [ 'adminNav' ] , $ this -> nav ) ; } }
12571	public function previewVoice ( $ message , $ to , $ by = self :: PREVIEW_BY_OPENID ) { return $ this -> preview ( self :: MSG_TYPE_VOICE , $ message , $ to , $ by ) ; }
5854	protected function persistFlexForm ( array & $ valueArray ) { foreach ( $ valueArray as $ key => $ value ) { if ( $ key === 'el' ) { foreach ( $ value as $ idx => $ v ) { if ( $ v && substr ( $ idx , 0 , 3 ) === 'ID-' ) { $ valueArray [ $ key ] [ substr ( $ idx , 3 ) ] = $ v ; unset ( $ valueArray [ $ key ] [ $ idx ] ) ; } } } elseif ( isset ( $ valueArray [ $ key ] ) ) { $ this -> persistFlexForm ( $ valueArray [ $ key ] ) ; } } }
6848	public static function days ( $ month , $ year = null ) { static $ months ; if ( ! isset ( $ year ) ) { $ year = date ( 'Y' ) ; } $ month = ( int ) $ month ; $ year = ( int ) $ year ; if ( empty ( $ months [ $ year ] [ $ month ] ) ) { $ total = date ( 't' , mktime ( 1 , 0 , 0 , $ month , 1 , $ year ) ) + 1 ; $ months [ $ year ] [ $ month ] = array ( ) ; for ( $ i = 1 ; $ i < $ total ; $ i ++ ) { $ months [ $ year ] [ $ month ] [ $ i ] = ( string ) $ i ; } } return $ months [ $ year ] [ $ month ] ; }
5032	public function getLoadedPage ( $ default = null ) { if ( ! $ this -> loadedPage ) { if ( is_callable ( $ default ) ) { $ page = call_user_func ( $ default , $ this ) ; if ( $ page !== null ) { $ this -> setLoadedPage ( $ page ) ; } } if ( ! $ this -> loadedPage ) { throw new NotFoundHttpException ( "There is no page currently loaded, but it was expected" ) ; } } return $ this -> loadedPage ; }
12690	protected function merge ( array $ configs ) { $ objects = array_filter ( $ configs , 'is_object' ) ; if ( ! empty ( $ objects ) ) { $ listConfigs = [ ] ; foreach ( $ configs as $ config ) { if ( ! is_object ( $ config ) ) { throw new RuntimeException ( 'Cannot merge object with other types' ) ; } $ listConfigs [ ] = ( array ) $ config ; } $ result = ( object ) $ this -> merge ( $ listConfigs ) ; } else { foreach ( $ configs as $ config ) { foreach ( $ config as $ key => $ value ) { $ existed = isset ( $ result [ $ key ] ) ; switch ( true ) { case ( $ existed && ( is_object ( $ result [ $ key ] ) || is_object ( $ value ) ) ) : case ( $ existed && ( is_array ( $ result [ $ key ] ) && is_array ( $ value ) ) ) : $ result [ $ key ] = $ this -> merge ( array ( $ result [ $ key ] , $ value ) ) ; break ; default : $ result [ $ key ] = $ value ; } } } } return $ result ; }
10452	public function format ( string $ question , string $ default = null ) : string { if ( $ default != '' ) { $ default = sprintf ( '[%s]' , $ default ) ; } return trim ( $ question . $ default ) . sprintf ( '%s ' , $ this -> getDelimiter ( ) ) ; }
2712	public function _getElementHtml ( AbstractElement $ element ) { $ this -> setNamePrefix ( $ element -> getName ( ) ) -> setHtmlId ( $ element -> getHtmlId ( ) ) ; return $ this -> _toHtml ( ) ; }
4170	public function prettify ( Collection $ packages ) { $ summary = [ ] ; foreach ( $ packages as $ key => $ package ) { $ summary [ ] = [ 'id' => $ key + 1 , 'name' => $ this -> prettifyPackageInfo ( $ package ) , ] ; } return $ packages [ $ this -> askPackageKey ( $ summary ) ] [ 'name' ] ; }
6586	protected function request ( array $ options ) { $ this -> info = null ; $ this -> setOpt ( $ options ) ; $ result = $ this -> perform ( 'curl_exec' ) ; $ this -> info = $ this -> perform ( 'curl_getinfo' ) ; return $ result ; }
690	protected function getUrlFromCache ( $ cacheKey , $ route , $ params ) { if ( ! empty ( $ this -> _ruleCache [ $ cacheKey ] ) ) { foreach ( $ this -> _ruleCache [ $ cacheKey ] as $ rule ) { if ( ( $ url = $ rule -> createUrl ( $ this , $ route , $ params ) ) !== false ) { return $ url ; } } } else { $ this -> _ruleCache [ $ cacheKey ] = [ ] ; } return false ; }
6973	private function buildFieldValue ( ClassMetadata $ metadata , $ propertyPath , $ value ) { $ type = $ metadata -> getTypeOfField ( $ propertyPath ) ; switch ( $ type ) { case 'smallint' : case 'integer' : case 'bigint' : if ( ! is_int ( $ value ) ) { throw new \ Exception ( 'Expected integer.' ) ; } return intval ( $ value ) ; case 'boolean' : if ( ! is_bool ( $ value ) ) { throw new \ Exception ( 'Expected boolean.' ) ; } return ( bool ) $ value ; case 'float' : case 'double' : case 'decimal' : if ( ! is_numeric ( $ value ) ) { throw new \ Exception ( 'Expected float.' ) ; } return floatval ( $ value ) ; case 'datetime' : return new \ DateTime ( $ value ) ; case 'string' : return ( string ) $ value ; } throw new \ Exception ( "Unsupported field type '$type' for path '$propertyPath'." ) ; }
9791	public function getCalculatedValue ( $ resetLog = true ) { if ( $ this -> dataType == DataType :: TYPE_FORMULA ) { try { $ result = Calculation :: getInstance ( $ this -> getWorksheet ( ) -> getParent ( ) ) -> calculateCellValue ( $ this , $ resetLog ) ; if ( is_array ( $ result ) ) { while ( is_array ( $ result ) ) { $ result = array_pop ( $ result ) ; } } } catch ( Exception $ ex ) { if ( ( $ ex -> getMessage ( ) === 'Unable to access External Workbook' ) && ( $ this -> calculatedValue !== null ) ) { return $ this -> calculatedValue ; } throw new \ PhpOffice \ PhpSpreadsheet \ Calculation \ Exception ( $ this -> getWorksheet ( ) -> getTitle ( ) . '!' . $ this -> getCoordinate ( ) . ' -> ' . $ ex -> getMessage ( ) ) ; } if ( $ result === '#Not Yet Implemented' ) { return $ this -> calculatedValue ; } return $ result ; } elseif ( $ this -> value instanceof RichText ) { return $ this -> value -> getPlainText ( ) ; } return $ this -> value ; }
8160	public function confirm ( ) { $ this -> status = User :: STATUS_ACTIVE ; if ( $ this -> save ( FALSE ) ) return TRUE ; return FALSE ; }
12365	public function init ( ) { $ config = new Zend_Config_Ini ( $ this -> config_path == null ? APPLICATION_PATH . DS . "configs" . DS . "secret.ini" : $ config_path , APPLICATION_ENV ) ; $ this -> setConsumer ( new Zend_Oauth_Consumer ( array ( 'callbackUrl' => $ config -> oauth -> callback , 'siteUrl' => $ config -> oauth -> siteurl , 'consumerKey' => $ config -> oauth -> consumerkey , 'consumerSecret' => $ config -> oauth -> consumersecret ) ) ) ; }
1163	public function validate ( $ field , $ parameters = [ ] ) { $ attribute = $ this -> parseAttributeName ( $ field ) ; $ validationParams = $ this -> parseParameters ( $ parameters ) ; $ validationResult = $ this -> validateJsRemoteRequest ( $ attribute , $ validationParams ) ; $ this -> throwValidationException ( $ validationResult , $ this -> validator ) ; }
9772	function property ( string $ name , $ value = null ) : self { $ isArray = is_array ( $ this -> target ) || $ this -> target instanceof \ ArrayAccess ; if ( ! $ isArray && ! is_object ( $ this -> target ) ) throw new \ BadMethodCallException ( 'The target is not an array nor an object.' ) ; $ hasProperty = $ isArray ? array_key_exists ( $ name , $ this -> target ) : property_exists ( $ this -> target , $ name ) ; $ hasPropertyConstraint = $ isArray ? arrayHasKey ( $ name ) : objectHasAttribute ( $ name ) ; $ property = $ isArray ? ( $ this -> target [ $ name ] ?? null ) : ( $ this -> target -> $ name ?? null ) ; if ( ! $ hasProperty || $ value === null ) $ this -> expect ( $ this -> target , $ hasPropertyConstraint ) ; else { assertThat ( $ this -> target , $ hasPropertyConstraint ) ; $ this -> expect ( $ property , equalTo ( $ value ) ) ; } $ this -> target = $ property ; return $ this ; }
10390	public static function loadString ( $ xmlString ) { $ xmlFile = tempnam ( self :: getSysTempDir ( ) , 'xml_' ) ; file_put_contents ( $ xmlFile , $ xmlString ) ; $ xml = self :: parseXml ( $ xmlFile ) ; unlink ( $ xmlFile ) ; return $ xml ; }
197	public function setDownloadHeaders ( $ attachmentName , $ mimeType = null , $ inline = false , $ contentLength = null ) { $ headers = $ this -> getHeaders ( ) ; $ disposition = $ inline ? 'inline' : 'attachment' ; $ headers -> setDefault ( 'Pragma' , 'public' ) -> setDefault ( 'Accept-Ranges' , 'bytes' ) -> setDefault ( 'Expires' , '0' ) -> setDefault ( 'Cache-Control' , 'must-revalidate, post-check=0, pre-check=0' ) -> setDefault ( 'Content-Disposition' , $ this -> getDispositionHeaderValue ( $ disposition , $ attachmentName ) ) ; if ( $ mimeType !== null ) { $ headers -> setDefault ( 'Content-Type' , $ mimeType ) ; } if ( $ contentLength !== null ) { $ headers -> setDefault ( 'Content-Length' , $ contentLength ) ; } return $ this ; }
8739	private function updateBase ( array $ values , array $ ids ) { $ query = $ this -> model -> newQuery ( ) -> whereIn ( $ this -> model -> getKeyName ( ) , $ ids ) -> getQuery ( ) ; return $ query -> update ( $ values ) ; }
1327	public function toUrl ( ) { $ postData = $ this -> toPostdata ( ) ; $ out = $ this -> getNormalizedHttpUrl ( ) ; if ( $ postData ) { $ out .= '?' . $ postData ; } return $ out ; }
6331	private function registerPostProcessor ( string $ type , string $ class ) : void { if ( \ class_exists ( $ class ) ) { $ interfaces = \ class_implements ( $ class ) ; if ( \ in_array ( PostProcessor :: class , $ interfaces , true ) ) { $ this -> postProcessorsMap [ $ type ] = $ class ; } else { throw new ConfigException ( "Class {$class} don't implement interface " . PostProcessor :: class ) ; } } else { throw new ConfigException ( "Class {$class} not found" ) ; } }
1287	private function fetchCollectionFromApi ( array $ resourceIds , string $ type , string $ locale = null ) : array { $ query = ( new Query ( ) ) -> where ( 'sys.id[in]' , $ resourceIds ) ; if ( 'Asset' === $ type || 'Entry' === $ type ) { $ query -> setLocale ( $ locale ) ; } switch ( $ type ) { case 'Asset' : return $ this -> client -> getAssets ( $ query ) -> getItems ( ) ; case 'ContentType' : return $ this -> client -> getContentTypes ( $ query ) -> getItems ( ) ; case 'Entry' : return $ this -> client -> getEntries ( $ query ) -> getItems ( ) ; case 'Environment' : return [ $ this -> client -> getEnvironment ( ) ] ; case 'Space' : return [ $ this -> client -> getSpace ( ) ] ; default : throw new \ InvalidArgumentException ( \ sprintf ( 'Trying to resolve link for unknown type "%s".' , $ type ) ) ; } }
8531	public function listFinancialEventsByNextToken ( $ request ) { if ( ! ( $ request instanceof MWSFinancesService_Model_ListFinancialEventsByNextTokenRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/ListFinancialEventsByNextTokenRequest.php' ) ; $ request = new MWSFinancesService_Model_ListFinancialEventsByNextTokenRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListFinancialEventsByNextToken' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/ListFinancialEventsByNextTokenResponse.php' ) ; $ response = MWSFinancesService_Model_ListFinancialEventsByNextTokenResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
3531	public static function sendFortniteGetRequest ( $ endpoint , $ access_token , $ extra_headers = array ( ) ) { $ client = new Client ( ) ; $ headers = [ 'User-Agent' => self :: FORTNITE_USER_AGENT , 'Authorization' => 'bearer ' . $ access_token ] ; $ headers = array_merge ( $ headers , $ extra_headers ) ; try { $ response = $ client -> get ( $ endpoint , [ 'headers' => $ headers ] ) ; return json_decode ( $ response -> getBody ( ) -> getContents ( ) ) ; } catch ( GuzzleException $ e ) { throw $ e ; } }
4839	public function request ( $ method , $ endpoint , $ params = array ( ) ) { if ( ! isset ( $ params [ 'http_authorization' ] ) ) { if ( ! isset ( $ this -> account_details [ 'access_token' ] ) ) { throw new GoCardless_ClientException ( 'Access token missing' ) ; } $ params [ 'http_bearer' ] = $ this -> account_details [ 'access_token' ] ; } if ( isset ( $ this -> account_details [ 'ua_tag' ] ) ) { $ params [ 'ua_tag' ] = $ this -> account_details [ 'ua_tag' ] ; } if ( substr ( $ endpoint , 0 , 6 ) == '/oauth' ) { $ url = $ this -> base_url . $ endpoint ; } else { $ url = $ this -> base_url . self :: $ api_path . $ endpoint ; } return call_user_func ( GoCardless :: getClass ( 'Request' ) . '::' . $ method , $ url , $ params ) ; }
9323	protected function registerMarkdownParser ( ) { $ app = $ this -> app ; $ app -> singleton ( 'commonmark.docparser' , function ( $ app ) { $ environment = $ app [ 'commonmark.environment' ] ; return new DocParser ( $ environment ) ; } ) ; $ app -> alias ( 'commonmark.docparser' , DocParser :: class ) ; }
5475	public function getAction ( ) { $ url = $ this -> action ; if ( $ this -> default_target && ! $ url -> getTarget ( ) ) { $ url -> setTarget ( $ this -> default_target ) ; } if ( $ this -> getMethod ( ) === 'get' ) { $ url -> clearRequest ( ) ; } return $ url ; }
2573	protected function loadAuthParams ( $ params ) { if ( isset ( $ params [ 'authParams' ] ) ) { if ( $ params [ 'authParams' ] instanceof AuthParams ) { $ this -> authParams = $ params [ 'authParams' ] ; } elseif ( is_array ( $ params [ 'authParams' ] ) ) { $ this -> authParams = new AuthParams ( $ params [ 'authParams' ] ) ; } } }
7199	protected function assignSaleItemRecursively ( SaleItemInterface $ item ) { $ this -> stockAssigner -> assignSaleItem ( $ item ) ; foreach ( $ item -> getChildren ( ) as $ child ) { $ this -> assignSaleItemRecursively ( $ child ) ; } }
11534	public static function writeFile ( $ file , $ content ) { $ handle = fopen ( $ file , 'w' ) ; if ( ! self :: lockFile ( $ handle , LOCK_EX | LOCK_NB ) ) { $ exception = array ( "message" => 'exception_file_cannot_be_locked_for_writing' , "parameters" => array ( "%file%" => basename ( $ file ) , ) ) ; throw new RuntimeException ( json_encode ( $ exception ) ) ; } if ( fwrite ( $ handle , $ content ) === false ) { $ exception = array ( "message" => 'exception_file_cannot_be_written' , "parameters" => array ( "%file%" => basename ( $ file ) , ) ) ; throw new RuntimeException ( json_encode ( $ exception ) ) ; } self :: unlockFile ( $ handle ) ; }
1614	private function sendCommandInternal ( $ command , $ params ) { $ written = @ fwrite ( $ this -> _socket , $ command ) ; if ( $ written === false ) { throw new SocketException ( "Failed to write to socket.\nRedis command was: " . $ command ) ; } if ( $ written !== ( $ len = mb_strlen ( $ command , '8bit' ) ) ) { throw new SocketException ( "Failed to write to socket. $written of $len bytes written.\nRedis command was: " . $ command ) ; } return $ this -> parseResponse ( implode ( ' ' , $ params ) ) ; }
12895	public function setPerson ( \ Chill \ PersonBundle \ Entity \ Person $ person = null ) { $ this -> person = $ person ; return $ this ; }
8027	public function killAllProcesses ( ) { foreach ( $ this -> processDetails as $ pid => $ processDetails ) { $ this -> remove ( $ processDetails ) ; posix_kill ( $ pid , SIGKILL ) ; } }
1462	protected function getColumnValue ( $ id ) { $ value = $ this -> getQuery ( ) -> where ( $ this -> key , $ id ) -> value ( $ this -> column ) ; if ( is_null ( $ value ) ) { throw new \ OutOfRangeException ( "Cursor key {$id} does not exist or has a null value." ) ; } return $ value ; }
12672	public static function emulate ( $ emulation , callable $ assertionCallable = null ) { if ( ( is_string ( $ emulation ) ) && ( class_exists ( $ emulation ) ) ) { $ emulation = new $ emulation ( $ assertionCallable ) ; } static :: $ emulation = $ emulation ; }
625	public function handleHhvmError ( $ code , $ message , $ file , $ line , $ context , $ backtrace ) { if ( $ this -> handleError ( $ code , $ message , $ file , $ line ) ) { return true ; } if ( E_ERROR & $ code ) { $ exception = new ErrorException ( $ message , $ code , $ code , $ file , $ line ) ; $ ref = new \ ReflectionProperty ( '\Exception' , 'trace' ) ; $ ref -> setAccessible ( true ) ; $ ref -> setValue ( $ exception , $ backtrace ) ; $ this -> _hhvmException = $ exception ; } return false ; }
1490	public function equalsTo ( MediaTypeInterface $ mediaType ) : ? Decoding { return collect ( $ this -> stack ) -> first ( function ( Decoding $ decoding ) use ( $ mediaType ) { return $ decoding -> equalsTo ( $ mediaType ) ; } ) ; }
5195	protected function getMethodResult ( $ method , array $ arguments ) { if ( ! is_callable ( [ 'Elasticsearch\Client' , $ method ] ) ) { trigger_error ( sprintf ( 'Call to undefined or protected/private method %s::%s()' , get_called_class ( ) , $ method ) , E_USER_ERROR ) ; } if ( empty ( $ this -> results [ $ method ] ) ) { throw new \ Exception ( sprintf ( "ElasticsearchMock results is empty for %s" , $ method ) ) ; } $ this -> calls [ $ method ] [ ] = $ arguments ; return array_shift ( $ this -> results [ $ method ] ) ; }
6117	public function serverGetByUid ( $ uid ) { foreach ( $ this -> serverList ( ) as $ server ) { if ( $ server [ "virtualserver_unique_identifier" ] == $ uid ) { return $ server ; } } throw new Ts3Exception ( "invalid serverID" , 0x400 ) ; }
503	public function batchInsert ( $ table , $ columns , $ rows , & $ params = [ ] ) { if ( empty ( $ rows ) ) { return '' ; } $ this -> db -> open ( ) ; if ( version_compare ( $ this -> db -> getServerVersion ( ) , '3.7.11' , '>=' ) ) { return parent :: batchInsert ( $ table , $ columns , $ rows , $ params ) ; } $ schema = $ this -> db -> getSchema ( ) ; if ( ( $ tableSchema = $ schema -> getTableSchema ( $ table ) ) !== null ) { $ columnSchemas = $ tableSchema -> columns ; } else { $ columnSchemas = [ ] ; } $ values = [ ] ; foreach ( $ rows as $ row ) { $ vs = [ ] ; foreach ( $ row as $ i => $ value ) { if ( isset ( $ columnSchemas [ $ columns [ $ i ] ] ) ) { $ value = $ columnSchemas [ $ columns [ $ i ] ] -> dbTypecast ( $ value ) ; } if ( is_string ( $ value ) ) { $ value = $ schema -> quoteValue ( $ value ) ; } elseif ( is_float ( $ value ) ) { $ value = StringHelper :: floatToString ( $ value ) ; } elseif ( $ value === false ) { $ value = 0 ; } elseif ( $ value === null ) { $ value = 'NULL' ; } elseif ( $ value instanceof ExpressionInterface ) { $ value = $ this -> buildExpression ( $ value , $ params ) ; } $ vs [ ] = $ value ; } $ values [ ] = implode ( ', ' , $ vs ) ; } if ( empty ( $ values ) ) { return '' ; } foreach ( $ columns as $ i => $ name ) { $ columns [ $ i ] = $ schema -> quoteColumnName ( $ name ) ; } return 'INSERT INTO ' . $ schema -> quoteTableName ( $ table ) . ' (' . implode ( ', ' , $ columns ) . ') SELECT ' . implode ( ' UNION SELECT ' , $ values ) ; }
9440	protected function value ( $ name ) { $ object = isset ( $ this -> instances [ $ name ] ) ? $ this -> get ( $ name ) : null ; $ exists = ! $ object && $ this -> extra -> has ( $ name ) === true ; return $ exists === true ? $ this -> extra -> get ( $ name ) : $ object ; }
155	public function scalar ( $ db = null ) { if ( $ this -> emulateExecution ) { return null ; } return $ this -> createCommand ( $ db ) -> queryScalar ( ) ; }
7082	public function uri ( $ uri = NULL ) : string { if ( $ uri === NULL ) { return empty ( $ this -> _uri ) ? '/' : $ this -> _uri ; } return $ this -> _uri = $ uri ; }
6963	public function toDate ( ) { if ( $ this -> dt ) return $ this -> dt ; else return AstroDate :: jd ( $ this -> jd , TimeScale :: TT ( ) ) ; }
11802	public static function import ( $ name ) { $ importPath = FOREVERPHP_ROOT . DS . $ name . '.php' ; if ( file_exists ( $ importPath ) ) { include_once $ importPath ; } else { throw new SetupException ( "The object to import ($name) not exists." ) ; } }
5703	public function bindGridField ( Form $ form , GridFieldDetailForm_ItemRequest $ request ) { $ this -> setForm ( $ form ) ; $ this -> gridFieldRequest = $ request ; return $ this ; }
12008	public function getMessages ( $ domain = 'default' , $ locale = null ) { if ( $ locale === null ) { $ locale = $ this -> getLocale ( ) ; } if ( ! isset ( $ this -> messages [ $ domain ] [ $ locale ] ) ) { $ this -> loadMessages ( $ domain , $ locale ) ; } return $ this -> messages [ $ domain ] [ $ locale ] ; }
2543	public function analyzeWithErrCodeAndMsgQueryFixedCat ( SendResult $ response , $ qErr , $ qMsg , $ category ) { $ analyzeResponse = new Result ( $ response ) ; $ domXpath = $ this -> makeDomXpath ( $ response -> responseXml ) ; $ errorCodeNodeList = $ domXpath -> query ( $ qErr ) ; $ errorMsgNodeList = $ domXpath -> query ( $ qMsg ) ; if ( $ errorCodeNodeList -> length > 0 || $ errorMsgNodeList -> length > 0 ) { $ analyzeResponse -> status = $ category ; $ errorCode = ( $ errorCodeNodeList -> length > 0 ) ? $ errorCodeNodeList -> item ( 0 ) -> nodeValue : null ; $ analyzeResponse -> messages [ ] = new Result \ NotOk ( $ errorCode , $ this -> makeMessageFromMessagesNodeList ( $ errorMsgNodeList ) ) ; } return $ analyzeResponse ; }
2243	public static function getForm ( $ varId , $ strColumn = 'main' , $ blnModule = false ) { if ( \ is_object ( $ varId ) ) { $ objRow = $ varId ; } else { if ( $ varId == '' ) { return '' ; } $ objRow = FormModel :: findByIdOrAlias ( $ varId ) ; if ( $ objRow === null ) { return '' ; } } $ strClass = $ blnModule ? Module :: findClass ( 'form' ) : ContentElement :: findClass ( 'form' ) ; if ( ! class_exists ( $ strClass ) ) { static :: log ( 'Form class "' . $ strClass . '" does not exist' , __METHOD__ , TL_ERROR ) ; return '' ; } $ objRow -> typePrefix = $ blnModule ? 'mod_' : 'ce_' ; $ objRow -> form = $ objRow -> id ; $ objElement = new $ strClass ( $ objRow , $ strColumn ) ; $ strBuffer = $ objElement -> generate ( ) ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getForm' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getForm' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getForm' ] as $ callback ) { $ strBuffer = static :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ objRow , $ strBuffer , $ objElement ) ; } } return $ strBuffer ; }
4666	protected function configure ( array $ config ) { $ this -> config = $ config ; $ this -> registerSwiftTransport ( ) ; $ this -> registerSwiftMailer ( ) ; $ this -> registerQueue ( ) ; }
2546	protected function makeStatusFromErrorQualifier ( $ qualifier , $ defaultStatus = Result :: STATUS_ERROR ) { $ statusQualMapping = [ 'INF' => Result :: STATUS_INFO , 'WEC' => Result :: STATUS_WARN , 'WZZ' => Result :: STATUS_WARN , 'WA' => Result :: STATUS_WARN , 'W' => Result :: STATUS_WARN , 'EC' => Result :: STATUS_ERROR , 'ERR' => Result :: STATUS_ERROR , 'ERC' => Result :: STATUS_ERROR , 'X' => Result :: STATUS_ERROR , '001' => Result :: STATUS_ERROR , 'O' => Result :: STATUS_OK , 'STA' => Result :: STATUS_OK , 'ZZZ' => Result :: STATUS_UNKNOWN ] ; if ( array_key_exists ( $ qualifier , $ statusQualMapping ) ) { $ status = $ statusQualMapping [ $ qualifier ] ; } elseif ( is_null ( $ qualifier ) ) { $ status = $ defaultStatus ; } else { $ status = Result :: STATUS_UNKNOWN ; } return $ status ; }
9241	public function getUrl ( $ language ) { $ lang = [ 'lang' => $ language ] ; $ query = Hash :: merge ( $ this -> request -> query , $ lang ) ; $ urlArray = Hash :: merge ( $ this -> request -> params [ 'pass' ] , [ '?' => $ query ] ) ; return Router :: url ( $ urlArray ) ; }
11380	public function deleteAction ( ) { if ( ! preg_match ( '/\/page\/(\w+[\-\w]*)\/text\/..\/(\w+)$/' , $ this -> name , $ matches ) ) { throw new InvalidParameterException ( "Invalid parameters" ) ; } list ( $ dummy , $ pageName , $ containerName ) = $ matches ; $ pageTexts = $ this -> getTextModel ( $ pageName ) ; $ pageTexts -> deleteTextContainer ( $ containerName ) ; $ this -> environment -> sendJSONResult ( 'ok' ) ; }
6722	public function fetchAccessToken ( $ code ) { $ this -> validateTokenParams ( ) ; $ this -> oauth2 -> tokenUrl = $ this -> tokenUrl ; $ this -> oauth2 -> clientId = $ this -> clientId ; $ this -> oauth2 -> clientSecret = $ this -> clientSecret ; try { $ response = $ this -> oauth2 -> fetchAccessToken ( $ code ) ; } catch ( Exception $ ex ) { throw new Oauth2ClientException ( $ ex -> getMessage ( ) ) ; } return $ this -> handleTokenResponse ( $ response ) ; }
4169	public function tokenizePackageInfo ( ) { $ info = explode ( ':' , $ this -> argument ( 'package' ) ) ; return [ 'name' => $ info [ 0 ] , 'version' => ( count ( $ info ) > 1 ) ? last ( $ info ) : null , ] ; }
949	public function sanitizeShopDomain ( $ domain ) { if ( empty ( $ domain ) ) { return ; } $ configEndDomain = Config :: get ( 'shopify-app.myshopify_domain' ) ; $ domain = strtolower ( preg_replace ( '/https?:\/\//i' , '' , trim ( $ domain ) ) ) ; if ( strpos ( $ domain , $ configEndDomain ) === false && strpos ( $ domain , '.' ) === false ) { $ domain .= ".{$configEndDomain}" ; } return parse_url ( "http://{$domain}" , PHP_URL_HOST ) ; }
9976	public static function builtInFormatCode ( $ pIndex ) { $ pIndex = ( int ) $ pIndex ; self :: fillBuiltInFormatCodes ( ) ; if ( isset ( self :: $ builtInFormats [ $ pIndex ] ) ) { return self :: $ builtInFormats [ $ pIndex ] ; } return '' ; }
6662	public function get ( $ url , $ params = [ ] ) { if ( ! is_array ( $ params ) ) { throw new HttpClientException ( HttpClientErrorMessages :: INVALID_QUERY_PARAMS ) ; } $ params = $ this -> filterParams ( $ params ) ; $ this -> lastRequestParams = $ params ; $ this -> lastRequestUrl = $ this -> buildUrl ( $ url , $ params ) ; return $ this -> curlAgent -> get ( $ this -> lastRequestUrl , $ this -> rawResponse ) ; }
9317	public function perform ( $ src , $ dst ) { $ inClusterHandler = eZClusterFileHandler :: instance ( $ src ) ; $ inClusterHandler -> fetch ( ) ; try { $ this -> converter -> transform ( 'transformation' , $ src , $ dst ) ; } catch ( Exception $ e ) { $ inClusterHandler -> deleteLocal ( ) ; throw $ e ; } $ outClusterHandler = eZClusterFileHandler :: instance ( ) ; $ outClusterHandler -> fileStore ( $ dst , 'image' ) ; eZImageHandler :: changeFilePermissions ( $ dst ) ; }
11797	public function setText ( $ text = '' , $ clear = false ) { if ( true === $ clear ) { $ this -> clear ( 'text' ) ; } if ( 'auto' == $ text ) { if ( ! empty ( $ this -> html ) ) { $ html_content = preg_replace ( "/.*<body[^>]*>|<\/body>.*/si" , "" , $ this -> html ) ; $ this -> text .= Helper :: formatText ( Helper :: html2text ( $ html_content ) ) ; } } else { $ this -> text .= Helper :: formatText ( $ text ) ; } return $ this ; }
1712	public function getArticleAlias ( Contao \ DataContainer $ dc ) { $ arrPids = array ( ) ; $ arrAlias = array ( ) ; if ( ! $ this -> User -> isAdmin ) { foreach ( $ this -> User -> pagemounts as $ id ) { $ arrPids [ ] = array ( $ id ) ; $ arrPids [ ] = $ this -> Database -> getChildRecords ( $ id , 'tl_page' ) ; } if ( ! empty ( $ arrPids ) ) { $ arrPids = array_merge ( ... $ arrPids ) ; } else { return $ arrAlias ; } $ objAlias = $ this -> Database -> prepare ( "SELECT a.id, a.title, a.inColumn, p.title AS parent FROM tl_article a LEFT JOIN tl_page p ON p.id=a.pid WHERE a.pid IN(" . implode ( ',' , array_map ( '\intval' , array_unique ( $ arrPids ) ) ) . ") ORDER BY parent, a.sorting" ) -> execute ( $ dc -> id ) ; } else { $ objAlias = $ this -> Database -> prepare ( "SELECT a.id, a.title, a.inColumn, p.title AS parent FROM tl_article a LEFT JOIN tl_page p ON p.id=a.pid ORDER BY parent, a.sorting" ) -> execute ( $ dc -> id ) ; } if ( $ objAlias -> numRows ) { Contao \ System :: loadLanguageFile ( 'tl_article' ) ; while ( $ objAlias -> next ( ) ) { $ arrAlias [ $ objAlias -> parent ] [ $ objAlias -> id ] = $ objAlias -> title . ' (' . ( $ GLOBALS [ 'TL_LANG' ] [ 'COLS' ] [ $ objAlias -> inColumn ] ? : $ objAlias -> inColumn ) . ', ID ' . $ objAlias -> id . ')' ; } } return $ arrAlias ; }
2914	public function formatStacktrace ( array $ trace , $ stripFilepath = '' , $ trimPath = '' ) { $ out = '' ; foreach ( $ trace as $ index => $ row ) { if ( $ stripFilepath && isset ( $ row [ 'file' ] ) && strpos ( $ row [ 'file' ] , $ stripFilepath ) !== false ) { continue ; } if ( $ trimPath && isset ( $ row [ 'file' ] ) ) { $ row [ 'file' ] = str_replace ( $ trimPath , '' , $ row [ 'file' ] ) ; } if ( isset ( $ row [ 'file' ] ) ) { $ out .= "[$index] {$row['file']}:{$row['line']}\n" ; } else { $ out .= "[$index] (?) {$row['class']}:{$row['function']}\n" ; } } return $ out ; }
12766	public function run ( ) : void { $ this -> isRan = true ; foreach ( $ this -> getAll ( ) as $ header ) { header ( $ header ) ; } }
11444	public function setTransporter ( TransportInterface $ transporter ) { if ( $ transporter -> validate ( ) ) { $ this -> transporter = $ transporter ; } else { throw new \ Exception ( sprintf ( 'Transporter "%s" is not valid for current environment!' , get_class ( $ transporter ) ) ) ; } return $ this ; }
9473	public function deleteFaild ( $ message = null ) { if ( is_null ( $ message ) ) $ message = $ this -> config [ 'fail' ] [ 'delete' ] ; return $ this -> setStatusCode ( 447 ) -> setStatusText ( 'fail' ) -> setErrorCode ( 5447 ) -> respondWithMessage ( $ message ) ; }
12388	public function logout ( AdapterChainEvent $ e ) { $ session = new Container ( $ this -> getStorage ( ) -> getNameSpace ( ) ) ; $ session -> getManager ( ) -> forgetMe ( ) ; $ session -> getManager ( ) -> destroy ( ) ; }
11247	public function getLast ( ) : array { $ sql = "select migration from {$this->table} as b where exists (select max(batch) from {$this->table} as a where b.batch = a.batch) order by migration desc" ; $ stmt = $ this -> pdo -> prepare ( $ sql ) ; $ stmt -> execute ( ) ; return $ stmt -> fetchAll ( PDO :: FETCH_COLUMN ) ; }
6344	public static function from ( Traversable $ traversable ) : Iterator { Preconditions :: checkArgument ( $ traversable instanceof Iterator || $ traversable instanceof IteratorAggregate ) ; return $ traversable instanceof Iterator ? $ traversable : Iterators :: from ( $ traversable -> getIterator ( ) ) ; }
7312	public static function equinoxAutumn ( $ year ) { $ jd = static :: equinoxSeptember ( ( int ) $ year , false ) ; return AstroDate :: jd ( $ jd , TimeScale :: TT ( ) ) ; }
9638	public function getAttributes ( ) { $ attributes = array ( 'placeholder' => $ this -> config [ 'defaultparts' ] [ 'scheme' ] . "://example.com" ) ; if ( $ this -> config [ 'html5validation' ] ) { $ attributes += array ( 'type' => 'url' , 'pattern' => 'https?://.+' , ) ; } return array_merge ( parent :: getAttributes ( ) , $ attributes ) ; }
5727	public function recordIsDeletedFromStage ( ) { if ( $ this -> owner -> hasMethod ( 'getIsDeletedFromStage' ) ) { return $ this -> owner -> IsDeletedFromStage ; } if ( ! $ this -> owner -> record -> checkVersioned ( ) ) { return false ; } if ( ! $ this -> owner -> record -> isInDB ( ) ) { return true ; } $ class = $ this -> owner -> record -> class ; $ stageVersion = Versioned :: get_versionnumber_by_stage ( $ class , 'Stage' , $ this -> owner -> record -> ID ) ; return ! ( $ stageVersion ) ; }
2685	public function aroundDispatch ( FrontController $ subject , callable $ proceed , ... $ args ) { $ isRateLimitingEnabled = $ this -> config -> isRateLimitingEnabled ( ) ; $ isCrawlerProtectionEnabled = $ this -> config -> isCrawlerProtectionEnabled ( ) ; if ( ! $ isRateLimitingEnabled && ! $ isCrawlerProtectionEnabled ) { return $ proceed ( ... $ args ) ; } $ path = strtolower ( $ this -> request -> getPathInfo ( ) ) ; if ( $ isRateLimitingEnabled && $ this -> sensitivePathProtection ( $ path ) ) { return $ this -> response ; } if ( $ isCrawlerProtectionEnabled && $ this -> crawlerProtection ( $ path ) ) { return $ this -> response ; } return $ proceed ( ... $ args ) ; }
12519	public function getByCalcId ( $ calcId ) { $ where = Entity :: A_CALC_REF . '=' . ( int ) $ calcId ; $ result = $ this -> get ( $ where ) ; return $ result ; }
9743	public function setCountry ( $ country ) { if ( ! ( $ country instanceof Country ) ) { $ country = new Country ( $ country ) ; } if ( $ country -> isEmpty ( ) ) { $ this -> invalidArguments ( '10001' ) ; } return $ this -> setParameter ( 'country' , $ country ) ; }
7447	function decrypt ( $ data , $ password ) { $ data = base64_decode ( $ data ) ; $ salt = substr ( $ data , 0 , 16 ) ; $ ct = substr ( $ data , 16 ) ; $ rounds = 3 ; $ data00 = $ password . $ salt ; $ hash = array ( ) ; $ hash [ 0 ] = hash ( 'sha256' , $ data00 , true ) ; $ result = $ hash [ 0 ] ; for ( $ i = 1 ; $ i < $ rounds ; $ i ++ ) { $ hash [ $ i ] = hash ( 'sha256' , $ hash [ $ i - 1 ] . $ data00 , true ) ; $ result .= $ hash [ $ i ] ; } $ key = substr ( $ result , 0 , 32 ) ; $ iv = substr ( $ result , 32 , 16 ) ; return openssl_decrypt ( $ ct , 'AES-256-CBC' , $ key , true , $ iv ) ; }
396	public static function deleteAll ( $ condition = null , $ params = [ ] ) { $ command = static :: getDb ( ) -> createCommand ( ) ; $ command -> delete ( static :: tableName ( ) , $ condition , $ params ) ; return $ command -> execute ( ) ; }
7222	protected function clearShipment ( Shipment \ ShipmentInterface $ shipment ) { if ( empty ( $ shipment -> getTrackingNumber ( ) ) && ! $ shipment -> hasLabels ( ) ) { return false ; } $ shipment -> setTrackingNumber ( null ) ; foreach ( $ shipment -> getLabels ( ) as $ label ) { $ shipment -> removeLabel ( $ label ) ; } return true ; }
7936	public function getSeeOffers ( $ countryDestination , $ countryCurrencyPrice , $ quantity ) { return json_decode ( self :: getClient ( ) -> getSeeOffers ( $ this -> domain , $ countryDestination , $ countryCurrencyPrice , $ quantity ) ) ; }
10013	public function getSheetByName ( $ pName ) { $ worksheetCount = count ( $ this -> workSheetCollection ) ; for ( $ i = 0 ; $ i < $ worksheetCount ; ++ $ i ) { if ( $ this -> workSheetCollection [ $ i ] -> getTitle ( ) === $ pName ) { return $ this -> workSheetCollection [ $ i ] ; } } return null ; }
3969	protected function deleteConditionSettings ( PreDeleteModelEvent $ event ) { $ environment = $ event -> getEnvironment ( ) ; $ model = $ event -> getModel ( ) ; $ dataProvider = $ environment -> getDataProvider ( 'tl_metamodel_dcasetting_condition' ) ; $ conditions = $ dataProvider -> fetchAll ( $ dataProvider -> getEmptyConfig ( ) -> setFilter ( [ [ 'operation' => '=' , 'property' => 'attr_id' , 'value' => $ model -> getId ( ) ] ] ) ) ; if ( $ conditions -> count ( ) < 1 ) { return ; } $ conditionsGeneral = new \ DC_General ( $ dataProvider -> getEmptyModel ( ) -> getProviderName ( ) ) ; $ conditionsEnvironment = $ conditionsGeneral -> getEnvironment ( ) ; $ conditionsDataDefinition = $ conditionsEnvironment -> getDataDefinition ( ) ; $ conditionsPalettesDefinition = $ conditionsDataDefinition -> getPalettesDefinition ( ) ; $ conditionsIterator = $ conditions -> getIterator ( ) ; while ( $ currentCondition = $ conditionsIterator -> current ( ) ) { $ conditionPalette = $ conditionsPalettesDefinition -> getPaletteByName ( $ currentCondition -> getProperty ( 'type' ) ) ; $ conditionProperties = $ conditionPalette -> getVisibleProperties ( $ currentCondition ) ; foreach ( $ conditionProperties as $ conditionProperty ) { if ( $ conditionProperty -> getName ( ) !== 'attr_id' ) { continue ; } $ dataProvider -> delete ( $ currentCondition ) ; } $ conditionsIterator -> next ( ) ; } }
6291	private function loadTheme ( $ theme ) { if ( ! isset ( $ theme ) ) { return ; } $ th = $ this -> findThemeByDirectory ( $ theme ) ; if ( isset ( $ th ) ) { $ viewFinder = $ this -> view -> getFinder ( ) ; $ viewFinder -> prependPath ( $ th -> getPath ( ) ) ; if ( ! is_null ( $ th -> getParent ( ) ) ) { $ this -> loadTheme ( $ th -> getParent ( ) ) ; } $ this -> activeTheme = $ theme ; } }
2261	public function prepare ( $ strQuery ) { $ objStatement = new Statement ( $ this -> resConnection , $ this -> blnDisableAutocommit ) ; return $ objStatement -> prepare ( $ strQuery ) ; }
196	public function sendStreamAsFile ( $ handle , $ attachmentName , $ options = [ ] ) { $ headers = $ this -> getHeaders ( ) ; if ( isset ( $ options [ 'fileSize' ] ) ) { $ fileSize = $ options [ 'fileSize' ] ; } else { fseek ( $ handle , 0 , SEEK_END ) ; $ fileSize = ftell ( $ handle ) ; } $ range = $ this -> getHttpRange ( $ fileSize ) ; if ( $ range === false ) { $ headers -> set ( 'Content-Range' , "bytes */$fileSize" ) ; throw new RangeNotSatisfiableHttpException ( ) ; } list ( $ begin , $ end ) = $ range ; if ( $ begin != 0 || $ end != $ fileSize - 1 ) { $ this -> setStatusCode ( 206 ) ; $ headers -> set ( 'Content-Range' , "bytes $begin-$end/$fileSize" ) ; } else { $ this -> setStatusCode ( 200 ) ; } $ mimeType = isset ( $ options [ 'mimeType' ] ) ? $ options [ 'mimeType' ] : 'application/octet-stream' ; $ this -> setDownloadHeaders ( $ attachmentName , $ mimeType , ! empty ( $ options [ 'inline' ] ) , $ end - $ begin + 1 ) ; $ this -> format = self :: FORMAT_RAW ; $ this -> stream = [ $ handle , $ begin , $ end ] ; return $ this ; }
7771	protected function fetchMessage ( $ field , $ rule ) { if ( isset ( $ this -> fieldMessages [ $ field ] [ $ rule ] ) ) { return $ this -> fieldMessages [ $ field ] [ $ rule ] ; } if ( isset ( $ this -> ruleMessages [ $ rule ] ) ) { return $ this -> ruleMessages [ $ rule ] ; } return $ this -> usedRules [ $ rule ] -> error ( ) ; }
882	private function normalizeType ( $ type ) { if ( '[]' === substr ( $ type , - 2 ) ) { return $ this -> normalize ( substr ( $ type , 0 , - 2 ) ) . '[]' ; } return $ this -> normalize ( $ type ) ; }
9379	protected function parse ( $ httpMethod , $ uri , $ route ) { $ matched = preg_match ( $ route [ 4 ] , $ uri , $ parameters ) ; if ( $ matched && ( $ httpMethod == $ route [ 0 ] || $ httpMethod == 'OPTIONS' ) ) { $ this -> allowed ( $ route [ 0 ] ) ; array_shift ( $ parameters ) ; return array ( $ route [ 2 ] , $ parameters , $ route [ 3 ] , $ route [ 5 ] ) ; } return null ; }
7407	public function serialize ( ) : string { return serialize ( [ '_type' => $ this -> _type , '_arrayOptions' => $ this -> _arrayOptions , '_jsonOptions' => $ this -> _jsonOptions , '_container' => $ this -> _container , ] ) ; }
11647	function parseAndAddServiceFromFile ( $ serviceFilename ) { $ service = require $ serviceFilename ; if ( $ service == false ) { throw new APIBuilderException ( "Failed to open service file `$serviceFilename`." ) ; } if ( is_array ( $ service ) == false ) { throw new APIBuilderException ( "File `$serviceFilename` did not return a service array. Cannot build API from it." ) ; } $ this -> parseAndAddService ( $ service ) ; }
12196	public static function current ( ) { if ( defined ( 'PHPUNIT_RUNNING' ) ) { return 'http://localhost' ; } $ protocol = 'http://' ; if ( ! empty ( $ _SERVER [ 'HTTPS' ] ) || ( ! empty ( $ _SERVER [ 'HTTP_X_FORWARDED_PROTO' ] ) && $ _SERVER [ 'HTTP_X_FORWARDED_PROTO' ] === 'https' ) ) { $ protocol = 'https://' ; } return $ protocol . request ( ) -> server ( 'HTTP_HOST' ) . request ( ) -> server ( 'REQUEST_URI' ) ; }
10520	public function constraint ( $ string ) { if ( ! isset ( $ this -> tbl_constraint [ 'other' ] ) ) { $ this -> tbl_constraint [ 'other' ] = [ ] ; } $ this -> tbl_constraint [ 'other' ] [ ] = $ string ; return $ this ; }
10743	public function getDateTime ( $ keys , DateTime $ default = null ) { $ value = $ this -> getString ( $ keys ) ; if ( empty ( $ value ) ) { $ result = $ default ; } elseif ( $ value === ( string ) ( int ) $ value ) { $ result = new DateTime ( ) ; $ result -> setTimestamp ( ( int ) $ value ) ; } else { $ result = new DateTime ( $ value ) ; } return $ result ; }
9273	public function filter ( $ text ) { $ text = str_replace ( "\r" , '' , $ text ) ; $ text = str_replace ( ' ' , ' &nbsp;' , $ text ) ; $ this -> _parseBbcodeNobbcode ( $ text ) ; $ this -> _parseBbcodeCode ( $ text ) ; $ this -> _parseBbcodeQuote ( $ text ) ; $ this -> _parseBbcodeList ( $ text ) ; $ this -> _parseSimpleBbcode ( 'i' , '<em>$1</em>' , $ text ) ; $ this -> _parseSimpleBbcode ( 'u' , '<u>$1</u>' , $ text ) ; $ this -> _parseSimpleBbcode ( 'b' , '<strong>$1</strong>' , $ text ) ; $ this -> _parseSimpleBbcode ( 'del' , '<del>$1</del>' , $ text ) ; $ this -> _parseSimpleBbcode ( 'strike' , '<del>$1</del>' , $ text ) ; $ this -> _parseParamBbcode ( 'color' , '([a-zA-Z]*|\#?[0-9a-fA-F]{6})' , '<span style="color: $1">$2</span>' , $ text ) ; $ this -> _parseParamBbcode ( 'bgcolor' , '([a-zA-Z]*|\#?[0-9a-fA-F]{6})' , '<span style="background-color: $1">$2</span>' , $ text ) ; $ this -> _parseParamBbcode ( 'align' , '(center|left|right|justify){1}' , '<div style="text-alignement: $1">$2</div>' , $ text ) ; $ this -> _parseParamBbcode ( 'size' , '([0-9].*)' , '<span style="font-size: $1">$2</span>' , $ text ) ; $ this -> _parseBbcodeEmail ( $ text ) ; $ this -> _parseBbcodeUrl ( $ text ) ; $ this -> _parseBbcodeImg ( $ text ) ; $ this -> _parseBbcodeSpoiler ( $ text ) ; $ this -> _parseScriptTags ( $ text ) ; $ this -> _parseSmiley ( $ text ) ; $ this -> _parseBbcodeBr ( $ text ) ; return $ text ; }
12673	public function setSourceFiles ( $ value ) { foreach ( $ value as $ key => $ settings ) { if ( $ settings === false ) { $ this -> _sourceFiles [ $ key ] = false ; continue ; } if ( ! isset ( $ settings [ 'class' ] ) ) { $ settings [ 'class' ] = $ this -> sourceFileClass ; } $ settings [ 'id' ] = $ key ; $ this -> _sourceFiles [ $ key ] = Yii :: createObject ( $ settings ) ; } }
4848	public function destinationsFor ( string $ filePath ) : array { $ filePath = Path :: canonicalize ( $ filePath ) ; $ source = $ this -> matchingSource ( $ filePath ) ; return $ this -> resolveDestinations ( $ filePath , $ source ) ; }
2662	public function getBackends ( $ version ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/backend' ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: GET ) ; return $ result ; }
2392	public function getAllowedCalendars ( ) { if ( $ this -> User -> isAdmin ) { $ objCalendar = Contao \ CalendarModel :: findAll ( ) ; } else { $ objCalendar = Contao \ CalendarModel :: findMultipleByIds ( $ this -> User -> calendars ) ; } $ return = array ( ) ; if ( $ objCalendar !== null ) { while ( $ objCalendar -> next ( ) ) { $ return [ $ objCalendar -> id ] = $ objCalendar -> title ; } } return $ return ; }
10001	public function add ( callable $ decorator , $ priority = 0 ) { $ this -> stack [ ] = array ( 'decorator' => $ decorator , 'priority' => $ priority , 'index' => $ this -> index ) ; $ this -> index -- ; uasort ( $ this -> stack , array ( $ this , 'compareStackItems' ) ) ; return $ this ; }
6401	public function getResource ( $ resource ) : ? string { Preconditions :: checkState ( $ this -> isPsr0Compatible ( ) , "Class '%s' must be PSR-0 compatible!" , $ this -> getName ( ) ) ; $ slashedFileName = $ this -> getSlashedFileName ( ) ; $ filePath = $ resource [ 0 ] == '/' ? str_replace ( "/{$this->getSlashedName()}.php" , '' , $ slashedFileName ) . $ resource : dirname ( $ slashedFileName ) . '/' . $ resource ; return is_file ( $ filePath ) ? $ filePath : null ; }
4307	public function timeEnd ( $ label = null , $ returnOrTemplate = false , $ precision = 4 ) { $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) , array ( 'label' => null , 'returnOrTemplate' => false , 'precision' => 4 , ) ) ; \ extract ( $ args ) ; if ( \ is_bool ( $ label ) || \ strpos ( $ label , '%time' ) !== false ) { if ( \ is_numeric ( $ returnOrTemplate ) ) { $ precision = $ returnOrTemplate ; } $ returnOrTemplate = $ label ; $ label = null ; } $ ret = $ this -> timeGet ( $ label , true , null ) ; if ( isset ( $ label ) ) { if ( isset ( $ this -> data [ 'timers' ] [ 'labels' ] [ $ label ] ) ) { $ this -> data [ 'timers' ] [ 'labels' ] [ $ label ] = array ( $ ret , null , ) ; } } else { $ label = 'time' ; \ array_pop ( $ this -> data [ 'timers' ] [ 'stack' ] ) ; } if ( \ is_int ( $ precision ) ) { $ ret = \ number_format ( $ ret , $ precision , '.' , '' ) ; } $ this -> doTime ( $ ret , $ returnOrTemplate , $ label , $ meta ) ; return $ ret ; }
10730	public function getHour ( ) { if ( $ this -> value !== null ) { preg_match ( '/^(?P<year>[0-9]{4,4})-(?P<month>[0-9]{2,2})-(?P<day>[0-9]{2,2}) (?P<hour>[0-9]{2,2}):(?P<minute>[0-9]{2,2}):(?P<second>[0-9]{2,2})$/ui' , $ this -> value , $ m ) ; return ( int ) $ m [ 'hour' ] ; } }
6070	public function downloadArchive ( array $ ids , $ template = null , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'ids' => $ ids , 'template' => $ template ] , 'body' => json_encode ( [ ] ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/media/download' , $ parameters , $ cachePolicy ) ; return $ result ; }
1887	protected function linkToPage ( $ intPage ) { if ( $ intPage <= 1 && ! $ this -> blnForceParam ) { return ampersand ( $ this -> strUrl ) ; } else { return ampersand ( $ this -> strUrl ) . $ this -> strVarConnector . $ this -> strParameter . '=' . $ intPage ; } }
3401	public function getValue ( ApistMethod $ method , Crawler $ rootNode = null ) { if ( is_null ( $ rootNode ) ) { $ rootNode = $ method -> getCrawler ( ) ; } $ result = $ rootNode -> filter ( $ this -> selector ) ; return $ this -> applyResultCallbackChain ( $ result , $ method ) ; }
1650	public function getLngs ( ) : array { $ lngs = [ ] ; foreach ( $ this -> points as $ point ) { $ lngs [ ] = $ point -> getLng ( ) ; } return $ lngs ; }
2932	public function setKey ( $ key , $ value = null , $ comment = null , $ export = false ) { $ data = [ compact ( 'key' , 'value' , 'comment' , 'export' ) ] ; return $ this -> setKeys ( $ data ) ; }
2919	public function updateSetter ( $ key , $ value = null , $ comment = null , $ export = false ) { $ pattern = "/^(export\h)?\h*{$key}=.*/m" ; $ line = $ this -> formatter -> formatSetterLine ( $ key , $ value , $ comment , $ export ) ; $ this -> buffer = preg_replace ( $ pattern , $ line , $ this -> buffer ) ; return $ this ; }
2425	public static function shouldBeSynchronized ( $ strPath ) { if ( ! isset ( static :: $ arrShouldBeSynchronized [ $ strPath ] ) || ! \ is_bool ( static :: $ arrShouldBeSynchronized [ $ strPath ] ) ) { static :: $ arrShouldBeSynchronized [ $ strPath ] = ! static :: isFileSyncExclude ( $ strPath ) ; } return static :: $ arrShouldBeSynchronized [ $ strPath ] ; }
6027	public function setUploaded ( $ uploaded ) { if ( $ uploaded instanceof DateTime ) { $ this -> uploaded = $ uploaded ; } else { try { $ this -> uploaded = new DateTime ( $ uploaded ) ; } catch ( \ Exception $ e ) { $ this -> uploaded = null ; } } return $ this ; }
7811	private static function filterArray ( $ needle , $ heystack , $ always = array ( ) ) { foreach ( $ heystack as $ k => $ v ) { if ( ! in_array ( $ v , $ needle ) && ! in_array ( $ v , $ always ) ) unset ( $ heystack [ $ k ] ) ; } return $ heystack ; }
10341	protected function validateColumns ( $ columns ) { $ patterns = array ( '((?P<minute>(?:\*|(?:(?:[0-9]|[1-5][0-9])(?:-(?:[0-9]|[1-5][0-9]))?)(?:,(?:[0-9]|[1-5][0-9])(?:-(?:[0-9]|[1-5][0-9]))?)*)(?:/(?:[1-9]|[1-5][0-9]))?)$)AD' , '((?P<hour>(?:\*|(?:(?:[0-9]|1[0-9]|2[0-3])(?:-(?:[0-9]|1[0-9]|2[0-3]))?)(?:,(?:[0-9]|1[0-9]|2[0-3])(?:-(?:[0-9]|1[0-9]|2[0-3]))?)*)(?:/(?:[1-9]|1[0-9]|2[0-3]))?)$)AD' , '((?P<dayOfMonth>(?:\*|(?:(?:[1-9]|[1-2][0-9]|3[0-1])(?:-(?:[1-9]|[1-2][0-9]|3[0-1]))?)(?:,(?:[1-9]|[1-2][0-9]|3[0-1])(?:-(?:[1-9]|[1-2][0-9]|3[0-1]))?)*)(?:/(?:[1-9]|[1-2][0-9]|3[0-1]))?)$)AD' , '((?P<month>(?:\*|(?:(?:[1-9]|1[0-2])(?:-(?:[1-9]|1[1-2]))?)(?:,(?:[1-9]|1[1-2])(?:-(?:[1-9]|1[1-2]))?)*)(?:/(?:[1-9]|1[1-2]))?)$)AD' , '((?P<dayOfWeek>(?:\*|(?:(?:[0-7])(?:-(?:[0-7]))?)(?:,(?:[0-7])(?:-(?:[0-7]))?)*)(?:/(?:[1-7]))?)$)AD' , ) ; if ( count ( $ columns ) !== 5 ) { return false ; } foreach ( $ columns as $ key => $ column ) { if ( preg_match ( $ patterns [ $ key ] , $ column ) !== 1 ) { return ( int ) $ key ; } } return true ; }
2764	public function run ( string $ command , array $ argsAndOptions = [ ] , bool $ setDirectory = true ) : string { $ command = new GitCommand ( $ command , ... $ argsAndOptions ) ; if ( $ setDirectory ) { $ command -> setDirectory ( $ this -> directory ) ; } return $ this -> gitWrapper -> run ( $ command ) ; }
10147	private function readPalette ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; if ( ! $ this -> readDataOnly ) { $ nm = self :: getUInt2d ( $ recordData , 0 ) ; for ( $ i = 0 ; $ i < $ nm ; ++ $ i ) { $ rgb = substr ( $ recordData , 2 + 4 * $ i , 4 ) ; $ this -> palette [ ] = self :: readRGB ( $ rgb ) ; } } }
9130	public static function create ( $ name , SymfonyRoute $ route , $ method , $ description = '' ) { return new static ( $ name , $ route , $ method , $ description ) ; }
4281	public function stream_tell ( ) { if ( ! $ this -> handle ) { return false ; } self :: restorePrev ( ) ; $ position = \ ftell ( $ this -> handle ) ; self :: register ( ) ; return $ position ; }
12009	public function setTitle ( string $ title ) : void { $ this -> title = $ this -> translator !== null ? $ this -> translator -> translate ( $ title ) : $ title ; }
4130	public function createNativeQuery ( $ designDocName , $ viewName ) { $ designDoc = $ this -> config -> getDesignDocument ( $ designDocName ) ; if ( $ designDoc ) { $ designDoc = new $ designDoc [ 'className' ] ( $ designDoc [ 'options' ] ) ; } $ query = new Query ( $ this -> couchDBClient -> getHttpClient ( ) , $ this -> couchDBClient -> getDatabase ( ) , $ designDocName , $ viewName , $ designDoc ) ; return $ query ; }
9355	public function det ( ) { if ( ! $ this -> isSquare ( ) ) { throw new \ RuntimeException ( 'Cannot compute determinant of non square matrix!' ) ; } if ( $ this -> size -> rows == 2 ) { return $ this -> get ( 0 , 0 ) * $ this -> get ( 1 , 1 ) - $ this -> get ( 0 , 1 ) * $ this -> get ( 1 , 0 ) ; } else { $ int_out = 0 ; $ arr_row = $ this -> arr [ 0 ] ; foreach ( $ arr_row as $ n => $ v ) { $ int_out += pow ( - 1 , $ n + 2 ) * $ v * $ this -> subMatrix ( 0 , $ n ) -> det ( ) ; } return $ int_out ; } }
9405	public function push ( $ middleware ) { if ( is_array ( $ middleware ) ) { $ this -> stack = array_merge ( $ this -> stack , $ middleware ) ; return $ this ; } $ this -> stack [ ] = $ middleware ; return $ this ; }
4393	public function cancel ( \ Aimeos \ MShop \ Order \ Item \ Iface $ order ) { $ provider = $ this -> getProvider ( ) ; if ( ! $ provider -> supportsVoid ( ) ) { return ; } $ base = $ this -> getOrderBase ( $ order -> getBaseId ( ) ) ; $ data = array ( 'transactionReference' => $ this -> getTransactionReference ( $ base ) , 'currency' => $ base -> getPrice ( ) -> getCurrencyId ( ) , 'amount' => $ this -> getAmount ( $ base -> getPrice ( ) ) , 'transactionId' => $ order -> getId ( ) , ) ; $ response = $ provider -> void ( $ data ) -> send ( ) ; if ( $ response -> isSuccessful ( ) ) { $ status = \ Aimeos \ MShop \ Order \ Item \ Base :: PAY_CANCELED ; $ order -> setPaymentStatus ( $ status ) ; $ this -> saveOrder ( $ order ) ; } }
7316	public function setTimezone ( $ timezone ) { if ( is_string ( $ timezone ) ) { $ timezone = TimeZone :: parse ( $ timezone ) ; } else { if ( $ timezone instanceof TimeZone == false ) { throw new \ InvalidArgumentException ( ) ; } } $ jd = $ this -> toJD ( ) ; $ tzOffset = $ timezone -> offset ( $ jd ) - $ this -> timezone -> offset ( $ jd ) ; $ this -> add ( Time :: hours ( $ tzOffset ) ) ; $ this -> timezone = $ timezone ; $ this -> timezone0 = $ timezone ; return $ this ; }
7179	public function getType ( ) { if ( is_string ( $ this -> type ) ) { $ type = $ this -> type ; } elseif ( is_array ( $ this -> type ) ) { $ type = reset ( $ this -> type ) ; } else { $ type = null ; } return $ this -> isValidType ( $ type ) ? $ type : self :: ANY ; }
2683	public function getWafSettings ( $ id ) { $ url = $ this -> _getWafEndpoint ( ) . $ id ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: GET ) ; return $ result ; }
6553	public function unlock ( ) { try { if ( $ this -> pid === $ this -> getSerial ( ) && is_resource ( $ this -> fh ) ) { $ this -> removeLineFromFile ( $ this -> pid , $ this -> fh ) ; flock ( $ this -> fh , LOCK_UN ) ; fclose ( $ this -> fh ) ; if ( filesize ( $ filename = $ this -> getPidFilename ( ) ) === 0 ) { unlink ( $ filename ) ; } } } catch ( FileNotFoundException $ fnfe ) { $ this -> getSystemLogger ( ) -> notice ( sprintf ( 'PID file %s doesn\'t exist' , $ this -> getPidFilename ( ) ) ) ; } catch ( LineNotFoundException $ lnfe ) { $ this -> getSystemLogger ( ) -> notice ( sprintf ( 'PID %s is can not be found in PID file %s' , $ this -> pid , $ this -> getPidFilename ( ) ) ) ; } catch ( \ Exception $ e ) { throw new \ Exception ( sprintf ( 'Can\'t remove PID %s from PID file %s' , $ this -> pid , $ this -> getPidFilename ( ) ) , null , $ e ) ; } }
6782	public function setFormParameters ( $ optionNames ) { foreach ( ( array ) $ optionNames as $ option ) { $ this -> formParameters [ $ option ] = true ; } return $ this ; }
12472	public static function isEnabled ( ) { $ class = self :: className ( ) ; foreach ( \ Yii :: $ app -> modules as $ module => $ params ) { switch ( gettype ( $ params ) ) { case 'array' : if ( $ class == @ $ params [ 'class' ] ) return true ; break ; case 'object' : if ( $ class == get_class ( $ params ) ) return true ; break ; default : if ( $ class == $ params ) return true ; } if ( $ module == $ class || ( isset ( $ module [ 'class' ] ) && $ module [ 'class' ] == $ class ) ) { return true ; } } return false ; }
2053	public function getTemplateData ( ) { $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; $ image = System :: getContainer ( ) -> get ( 'contao.image.image_factory' ) -> create ( $ rootDir . '/' . $ this -> image -> getOriginalPath ( ) ) ; $ config = new PictureConfiguration ( ) ; $ config -> setSize ( $ this -> getConfigurationItem ( $ this -> imageSize ) ) ; $ sizeItems = array ( ) ; foreach ( $ this -> imageSizeItems as $ imageSizeItem ) { $ sizeItems [ ] = $ this -> getConfigurationItem ( $ imageSizeItem ) ; } $ config -> setSizeItems ( $ sizeItems ) ; $ importantPart = $ this -> image -> getImportantPart ( ) ; $ image -> setImportantPart ( new ImportantPart ( new Point ( $ importantPart [ 'x' ] , $ importantPart [ 'y' ] ) , new Box ( $ importantPart [ 'width' ] , $ importantPart [ 'height' ] ) ) ) ; $ container = System :: getContainer ( ) ; $ staticUrl = $ container -> get ( 'contao.assets.files_context' ) -> getStaticUrl ( ) ; $ picture = $ container -> get ( 'contao.image.picture_generator' ) -> generate ( $ image , $ config , ( new ResizeOptions ( ) ) -> setImagineOptions ( $ container -> getParameter ( 'contao.image.imagine_options' ) ) -> setBypassCache ( $ container -> getParameter ( 'contao.image.bypass_cache' ) ) ) ; return array ( 'img' => $ picture -> getImg ( $ rootDir , $ staticUrl ) , 'sources' => $ picture -> getSources ( $ rootDir , $ staticUrl ) , ) ; }
3398	private function parseStr ( $ string ) { $ params = array ( ) ; $ pairs = explode ( '&' , $ string ) ; foreach ( $ pairs as $ pair ) { if ( ! $ pair ) { continue ; } $ var = explode ( '=' , $ pair , 2 ) ; $ val = ( isset ( $ var [ 1 ] ) ? $ var [ 1 ] : '' ) ; if ( isset ( $ params [ $ var [ 0 ] ] ) ) { if ( is_array ( $ params [ $ var [ 0 ] ] ) ) { $ params [ $ var [ 0 ] ] [ ] = $ val ; } else { $ params [ $ var [ 0 ] ] = array ( $ params [ $ var [ 0 ] ] , $ val ) ; } } else { $ params [ $ var [ 0 ] ] = $ val ; } } return $ params ; }
8121	public function ReviewContentForm ( HTTPRequest $ request ) { $ id = $ request -> param ( 'ID' ) ? : $ request -> postVar ( 'ID' ) ; return $ this -> getReviewContentForm ( $ id ) ; }
5188	private function createPage ( string $ title , string $ body , string $ source , int $ order , string $ cover , string $ lead ) : \ One \ Model \ Page { return new Page ( $ title , $ body , $ source , $ order , $ cover , $ lead ) ; }
3218	function chunkedUploadFinish ( $ uploadId , $ path , $ writeMode ) { Checker :: argStringNonEmpty ( "uploadId" , $ uploadId ) ; Path :: checkArgNonRoot ( "path" , $ path ) ; WriteMode :: checkArg ( "writeMode" , $ writeMode ) ; $ params = array_merge ( array ( "upload_id" => $ uploadId ) , $ writeMode -> getExtraParams ( ) ) ; $ response = $ this -> doPost ( $ this -> contentHost , $ this -> appendFilePath ( "1/commit_chunked_upload" , $ path ) , $ params ) ; if ( $ response -> statusCode === 404 ) return null ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; return RequestUtil :: parseResponseJson ( $ response -> body ) ; }
1411	public function resourceIdNotSupported ( string $ id , string $ path = '/data' ) : ErrorInterface { return new Error ( null , null , Response :: HTTP_CONFLICT , $ this -> trans ( 'resource_id_not_supported' , 'code' ) , $ this -> trans ( 'resource_id_not_supported' , 'title' ) , $ this -> trans ( 'resource_id_not_supported' , 'detail' , compact ( 'id' ) ) , $ this -> pointer ( $ path , 'id' ) ) ; }
7254	static public function isBetterState ( $ stateA , $ stateB ) { if ( $ stateA === static :: STATE_IN_STOCK ) { return $ stateB !== static :: STATE_IN_STOCK ; } elseif ( $ stateA === static :: STATE_PRE_ORDER ) { return $ stateB === static :: STATE_OUT_OF_STOCK ; } return false ; }
8199	public function expect ( $ type , $ value = null , $ message = null ) { $ token = $ this -> tokens [ $ this -> current ] ; if ( ! $ token -> test ( $ type , $ value ) ) { $ line = $ token -> getLine ( ) ; throw new Twig_Error_Syntax ( sprintf ( '%sUnexpected token "%s" of value "%s" ("%s" expected%s).' , $ message ? $ message . '. ' : '' , Twig_Token :: typeToEnglish ( $ token -> getType ( ) ) , $ token -> getValue ( ) , Twig_Token :: typeToEnglish ( $ type ) , $ value ? sprintf ( ' with value "%s"' , $ value ) : '' ) , $ line , $ this -> source ) ; } $ this -> next ( ) ; return $ token ; }
6592	protected function checkAndGetBusters ( ) { if ( $ this -> fileSystem -> fileExists ( $ this -> config [ 'bustersJsonPath' ] ) === false ) { throw new LengthException ( 'busters json not found.' ) ; } $ bustersJson = $ this -> fileSystem -> getFile ( $ this -> config [ 'bustersJsonPath' ] ) ; if ( $ bustersJson == '' ) { throw new UnderflowException ( 'busters json is empty.' ) ; } $ busters = json_decode ( $ bustersJson ) ; if ( json_last_error ( ) !== JSON_ERROR_NONE ) { throw new UnexpectedValueException ( 'bustersJson is invalid JSON.' ) ; } return $ busters ; }
9604	public function scalarTripleProduct ( self $ b , self $ c ) { return $ this -> dotProduct ( $ b -> crossProduct ( $ c ) ) ; }
306	public function getSizeLimit ( ) { $ limit = $ this -> sizeToBytes ( ini_get ( 'upload_max_filesize' ) ) ; $ postLimit = $ this -> sizeToBytes ( ini_get ( 'post_max_size' ) ) ; if ( $ postLimit > 0 && $ postLimit < $ limit ) { Yii :: warning ( 'PHP.ini\'s \'post_max_size\' is less than \'upload_max_filesize\'.' , __METHOD__ ) ; $ limit = $ postLimit ; } if ( $ this -> maxSize !== null && $ limit > 0 && $ this -> maxSize < $ limit ) { $ limit = $ this -> maxSize ; } if ( isset ( $ _POST [ 'MAX_FILE_SIZE' ] ) && $ _POST [ 'MAX_FILE_SIZE' ] > 0 && $ _POST [ 'MAX_FILE_SIZE' ] < $ limit ) { $ limit = ( int ) $ _POST [ 'MAX_FILE_SIZE' ] ; } return $ limit ; }
9861	private function writeDimension ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { $ objWriter -> startElement ( 'dimension' ) ; $ objWriter -> writeAttribute ( 'ref' , $ pSheet -> calculateWorksheetDimension ( ) ) ; $ objWriter -> endElement ( ) ; }
9508	public function showByLevel ( Log $ log , $ level ) { $ this -> authorize ( LogViewerPolicy :: PERMISSION_SHOW ) ; if ( $ level == 'all' ) return redirect ( ) -> route ( 'admin::foundation.system.log-viewer.logs.show' , [ $ log -> date ] ) ; $ levels = $ this -> logViewer -> levelsNames ( ) ; $ entries = $ this -> logViewer -> entries ( $ log -> date , $ level ) -> paginate ( $ this -> perPage ) ; $ this -> addBreadcrumbRoute ( trans ( 'foundation::log-viewer.titles.logs-list' ) , 'admin::foundation.system.log-viewer.logs.list' ) ; $ this -> setTitle ( $ log -> date . ' | ' . ucfirst ( $ level ) ) ; $ this -> addBreadcrumbRoute ( $ log -> date , 'admin::foundation.system.log-viewer.logs.show' , [ $ log -> date ] ) ; $ this -> addBreadcrumb ( ucfirst ( $ level ) ) ; return $ this -> view ( 'admin.system.log-viewer.show' , compact ( 'log' , 'levels' , 'entries' , 'level' ) ) ; }
2196	protected function sendAdminNotification ( $ intId , $ arrData ) { $ objEmail = new Email ( ) ; $ objEmail -> from = $ GLOBALS [ 'TL_ADMIN_EMAIL' ] ; $ objEmail -> fromName = $ GLOBALS [ 'TL_ADMIN_NAME' ] ; $ objEmail -> subject = sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'adminSubject' ] , Idna :: decode ( Environment :: get ( 'host' ) ) ) ; $ strData = "\n\n" ; foreach ( $ arrData as $ k => $ v ) { if ( $ k == 'password' || $ k == 'tstamp' || $ k == 'dateAdded' ) { continue ; } $ v = StringUtil :: deserialize ( $ v ) ; if ( $ k == 'dateOfBirth' && \ strlen ( $ v ) ) { $ v = Date :: parse ( Config :: get ( 'dateFormat' ) , $ v ) ; } $ strData .= $ GLOBALS [ 'TL_LANG' ] [ 'tl_member' ] [ $ k ] [ 0 ] . ': ' . ( \ is_array ( $ v ) ? implode ( ', ' , $ v ) : $ v ) . "\n" ; } $ objEmail -> text = sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'adminText' ] , $ intId , $ strData . "\n" ) . "\n" ; $ objEmail -> sendTo ( $ GLOBALS [ 'TL_ADMIN_EMAIL' ] ) ; $ this -> log ( 'A new user (ID ' . $ intId . ') has registered on the website' , __METHOD__ , TL_ACCESS ) ; }
12507	public static function singleDocument ( $ document ) { if ( gettype ( $ document ) != "array" && gettype ( $ document ) != "object" ) { throw new ClusterpointException ( "\"->insert()\" function: parametr passed " . json_encode ( self :: escape_string ( $ document ) ) . " is not in valid document format." , 9002 ) ; } $ query = "{" ; $ first = true ; foreach ( $ document as $ key => $ value ) { if ( ! $ first ) { $ query .= "," ; } $ query .= '"' . self :: escape_string ( $ key ) . '" : ' . json_encode ( $ value ) ; $ first = false ; } $ query .= '}' ; return $ query ; }
3782	public function modelToLabel ( ModelToLabelEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ model = $ event -> getModel ( ) ; $ type = $ model -> getProperty ( 'type' ) ; $ image = '<img src="' . $ this -> attributeFactory -> getIconForType ( $ type ) . '" />' ; $ metaModel = $ this -> getMetaModelByModelPid ( $ model ) ; $ attribute = $ this -> attributeFactory -> createAttribute ( $ model -> getPropertiesAsArray ( ) , $ metaModel ) ; if ( ! $ attribute ) { $ translator = $ event -> getEnvironment ( ) -> getTranslator ( ) ; $ event -> setLabel ( '<div class="field_heading cte_type"><strong>%s</strong> <em>[%s]</em></div> <div class="field_type block"> <strong>%s</strong><br /> </div>' ) -> setArgs ( array ( $ translator -> translate ( 'error_unknown_attribute.0' , 'tl_metamodel_attribute' ) , $ type , $ translator -> translate ( 'error_unknown_attribute.1' , 'tl_metamodel_attribute' , array ( $ type ) ) , ) ) ; return ; } $ colName = $ attribute -> getColName ( ) ; $ name = $ attribute -> getName ( ) ; $ arrDescription = StringUtil :: deserialize ( $ attribute -> get ( 'description' ) ) ; if ( is_array ( $ arrDescription ) ) { $ description = $ arrDescription [ $ attribute -> getMetaModel ( ) -> getActiveLanguage ( ) ] ; if ( ! $ description ) { $ description = $ arrDescription [ $ attribute -> getMetaModel ( ) -> getFallbackLanguage ( ) ] ; } } else { $ description = $ arrDescription ? : $ attribute -> getName ( ) ; } $ event -> setLabel ( '<div class="field_heading cte_type"><strong>%s</strong> <em>[%s]</em></div> <div class="field_type block"> %s<strong>%s</strong> - %s </div>' ) -> setArgs ( array ( $ colName , $ type , $ image , $ name , $ description ) ) ; }
1387	protected function resourceTypeNotSupported ( string $ actual , string $ path = '/data' ) : void { $ this -> errors -> add ( $ this -> translator -> resourceTypeNotSupported ( $ actual , $ path ) ) ; }
8015	protected function execute ( Command $ command ) { $ command -> setJar ( $ this -> getPathToPdfBox ( ) ) ; $ command -> setOptions ( $ this -> _options ) ; exec ( ( string ) $ command . ' 2>&1' , $ stdErr , $ exitCode ) ; if ( $ command -> getPdfFileIsTemp ( ) ) { unlink ( $ command -> getPdfFile ( ) ) ; } if ( $ exitCode > 0 ) { throw new \ RuntimeException ( join ( "\n" , $ stdErr ) , $ exitCode ) ; } $ resultFile = $ command -> getTextFile ( ) ; $ result = file_get_contents ( $ resultFile ) ; if ( $ command -> getTextFileIsTemp ( ) ) { unlink ( $ resultFile ) ; } return $ result ; }
10349	public function validateArgSet ( $ set ) { if ( isset ( $ set ) ) { foreach ( $ set as $ arg ) { if ( ! isset ( $ this -> { $ arg } ) ) { throw new \ Exception ( 'Response not valid: ' . $ arg . ' has not been set!' ) ; } } } }
4792	function select ( $ columns ) { $ this -> __destruct ( ) ; if ( $ columns != "" ) { foreach ( func_get_args ( ) as $ columns ) { $ this -> select [ ] = $ columns ; } } else { $ this -> select = array ( ) ; } return $ this ; }
10762	public function setAlternativeAccount ( $ iban1 , $ swift1 = null , $ iban2 = null , $ swift2 = null ) { if ( $ swift1 !== null ) { $ iban1 .= '+' . $ swift1 ; } if ( $ iban2 !== null ) { if ( $ swift2 !== null ) { $ iban2 .= '+' . $ swift2 ; } $ iban1 .= ',' . $ iban2 ; } return $ this -> add ( 'ALT-ACC' , $ iban1 ) ; }
1292	private function buildResult ( array $ data ) : Result { $ token = $ this -> getTokenFromResponse ( $ data ) ; $ done = isset ( $ data [ 'nextSyncUrl' ] ) ; $ items = \ array_map ( function ( array $ item ) : ResourceInterface { return $ this -> builder -> build ( $ item ) ; } , $ data [ 'items' ] ) ; return new Result ( $ items , $ token , $ done ) ; }
4453	public function isPaused ( ) : bool { $ stat = json_decode ( $ this -> client -> queues ( $ this -> name ) , true ) ; return isset ( $ stat [ 'name' ] ) && $ stat [ 'name' ] === $ this -> name && $ stat [ 'paused' ] == true ; }
10919	public static function getArray ( $ language ) { $ fileName = __DIR__ . '/stop-words/' . $ language . '.txt' ; if ( file_exists ( $ fileName ) ) { return array_map ( 'trim' , file ( $ fileName ) ) ; } return [ ] ; }
3412	public function finishedCrawling ( ) { $ this -> consoleOutput -> writeln ( '' ) ; $ this -> consoleOutput -> writeln ( 'Crawling summary' ) ; $ this -> consoleOutput -> writeln ( '----------------' ) ; ksort ( $ this -> crawledUrls ) ; foreach ( $ this -> crawledUrls as $ statusCode => $ urls ) { $ colorTag = $ this -> getColorTagForStatusCode ( $ statusCode ) ; $ count = count ( $ urls ) ; if ( is_numeric ( $ statusCode ) ) { $ this -> consoleOutput -> writeln ( "<{$colorTag}>Crawled {$count} url(s) with statuscode {$statusCode}</{$colorTag}>" ) ; } if ( $ statusCode == static :: UNRESPONSIVE_HOST ) { $ this -> consoleOutput -> writeln ( "<{$colorTag}>{$count} url(s) did have unresponsive host(s)</{$colorTag}>" ) ; } } $ this -> consoleOutput -> writeln ( '' ) ; }
3659	public static function getSubscribedServices ( ) { return [ Connection :: class => Connection :: class , Input :: class => Input :: class , InsertTags :: class => InsertTags :: class , Session :: class => Session :: class , IMetaModelsServiceContainer :: class => IMetaModelsServiceContainer :: class ] ; }
6983	public function validateAndReturnErrors ( $ dataOrRequest , array $ rules , array $ messages = [ ] , array $ customAttributes = [ ] ) { $ messages = Set :: flatten ( $ messages ) ; if ( $ dataOrRequest instanceof Request ) { $ dataOrRequest = $ dataOrRequest -> all ( ) ; } $ validator = $ this -> getValidationFactory ( ) -> make ( $ dataOrRequest , $ rules , $ messages , $ customAttributes ) ; if ( $ validator -> fails ( ) ) { return $ validator -> getMessageBag ( ) -> toArray ( ) ; } return [ ] ; }
2237	public function generatePdf ( ) { $ this -> headline = $ this -> title ; $ this -> printable = false ; $ strArticle = $ this -> replaceInsertTags ( $ this -> generate ( ) , false ) ; $ strArticle = html_entity_decode ( $ strArticle , ENT_QUOTES , Config :: get ( 'characterSet' ) ) ; $ strArticle = $ this -> convertRelativeUrls ( $ strArticle , '' , true ) ; $ arrSearch = array ( '@<form.*</form>@Us' , '@<a [^>]*href="[^"]*javascript:[^>]+>.*</a>@Us' ) ; $ strArticle = preg_replace ( $ arrSearch , '' , $ strArticle ) ; if ( empty ( $ GLOBALS [ 'TL_HOOKS' ] [ 'printArticleAsPdf' ] ) ) { throw new \ Exception ( 'No PDF extension found. Did you forget to install contao/tcpdf-bundle?' ) ; } if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'printArticleAsPdf' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'printArticleAsPdf' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'printArticleAsPdf' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ strArticle , $ this ) ; } } }
7164	private function buildSaleDiscountsLinesViews ( Model \ SaleInterface $ sale ) { if ( ! $ sale -> hasAdjustments ( Model \ AdjustmentTypes :: TYPE_DISCOUNT ) ) { return ; } foreach ( $ sale -> getAdjustments ( Model \ AdjustmentTypes :: TYPE_DISCOUNT ) as $ adjustment ) { $ this -> view -> addDiscount ( $ this -> buildDiscountLine ( $ adjustment ) ) ; } }
10640	protected function createUniquePath ( UploadedFile $ file ) { $ dir = 'mmmb/' . mb_substr ( mb_strtolower ( ( string ) $ file -> getClientOriginalName ( ) ) , 0 , 2 ) ; $ filename = str_replace ( array ( ' ' , $ file -> getClientOriginalExtension ( ) ) , '-' , $ file -> getClientOriginalName ( ) ) ; $ name = mb_strtolower ( $ filename . uniqid ( ) . '.' . $ file -> getClientOriginalExtension ( ) ) ; return array ( 'dir' => $ dir , 'filename' => $ name , 'path' => $ dir . '/' . $ name , ) ; }
4007	public function createMetaModel ( CreateMetaModelEvent $ event ) { if ( $ event -> getMetaModel ( ) !== null ) { return ; } if ( isset ( $ this -> instancesByTable [ $ event -> getMetaModelName ( ) ] ) ) { $ event -> setMetaModel ( $ this -> instancesByTable [ $ event -> getMetaModelName ( ) ] ) ; return ; } $ table = $ this -> database -> createQueryBuilder ( ) -> select ( '*' ) -> from ( 'tl_metamodel' ) -> where ( 'tableName=:tableName' ) -> setParameter ( 'tableName' , $ event -> getMetaModelName ( ) ) -> setMaxResults ( 1 ) -> execute ( ) -> fetch ( \ PDO :: FETCH_ASSOC ) ; if ( $ table ) { $ table [ 'system_columns' ] = $ this -> systemColumns ; $ this -> createInstance ( $ event , $ table ) ; } }
10913	public function setVariable ( string $ name , $ value , bool $ as_instance = true ) { $ this -> variables [ $ name ] = $ value ; if ( is_object ( $ value ) ) $ this -> instances [ get_class ( $ value ) ] = $ value ; return $ this ; }
7997	public static function getSpecificationString ( $ reversed = false ) { $ reflection = new ReflectionClass ( get_class ( ) ) ; $ constants = $ reflection -> getConstants ( ) ; if ( $ reversed ) { $ constants = array_reverse ( $ constants ) ; } $ string = '' ; foreach ( $ constants as $ name => $ int_val ) { $ binary_val_string = base_convert ( ( string ) $ int_val , '10' , '2' ) ; $ string .= sprintf ( '0b%s : %s' , str_pad ( $ binary_val_string , 32 , '0' , STR_PAD_LEFT ) , $ name ) ; $ string .= PHP_EOL ; } return $ string ; }
6077	public function uploadNewVersionChunked ( $ fileData , $ id , $ revisionComment , $ name , $ chunk , $ chunks , $ fileId ) { $ parameters = [ 'query' => [ 'revisionComment' => $ revisionComment , 'name' => $ name , 'chunk' => $ chunk , 'chunks' => $ chunks , 'fileId' => $ fileId , ] , 'multipart' => [ [ 'name' => 'file' , 'contents' => \ GuzzleHttp \ Psr7 \ stream_for ( $ fileData ) , 'filename' => $ name , ] , ] , 'headers' => null , ] ; $ result = $ this -> post ( 'v1/media.json/' . $ id . '/version' , $ parameters ) ; return $ result ; }
5939	public function setExtraData ( array $ extraData ) { $ this -> extraData = [ ] ; foreach ( $ extraData as $ item ) { $ this -> addExtraData ( $ item ) ; } return $ this ; }
1671	public function copyTo ( $ strNewName ) { $ strParent = \ dirname ( $ strNewName ) ; if ( ! is_dir ( $ this -> strRootDir . '/' . $ strParent ) ) { new self ( $ strParent ) ; } $ this -> Files -> rcopy ( $ this -> strFolder , $ strNewName ) ; $ syncSource = Dbafs :: shouldBeSynchronized ( $ this -> strFolder ) ; $ syncTarget = Dbafs :: shouldBeSynchronized ( $ strNewName ) ; if ( $ syncSource && $ syncTarget ) { Dbafs :: copyResource ( $ this -> strFolder , $ strNewName ) ; } elseif ( $ syncTarget ) { Dbafs :: addResource ( $ strNewName ) ; } return true ; }
4174	public function build ( ) { $ providers = $ this -> getProviders ( ) -> search ( ) ; $ facades = $ this -> getFacades ( ) -> search ( ) ; if ( ! ConfigFile :: instance ( $ providers , $ facades ) -> make ( ) ) { throw new ErrorException ( 'Unable to register providers and facades. Please report this incident at Qafeen/Manager' ) ; } $ this -> getResources ( ) -> publish ( $ providers [ 0 ] ) ; return $ this ; }
605	protected function indexAfter ( $ string , $ offset = null ) { if ( $ offset === null ) { $ offset = $ this -> offset ; } if ( $ offset + mb_strlen ( $ string , 'UTF-8' ) > $ this -> length ) { return $ this -> length ; } $ afterIndexOf = mb_strpos ( $ this -> sql , $ string , $ offset , 'UTF-8' ) ; if ( $ afterIndexOf === false ) { $ afterIndexOf = $ this -> length ; } else { $ afterIndexOf += mb_strlen ( $ string , 'UTF-8' ) ; } return $ afterIndexOf ; }
5973	public function events ( ) { if ( ! $ this -> events instanceof EventsController ) { $ this -> events = new EventsController ( $ this -> getClient ( ) , $ this -> cachePolicy , $ this -> cache ) ; $ this -> events -> setLogger ( $ this -> logger ) ; } return $ this -> events ; }
9019	public function getKeywords ( $ string , $ amount = 10 ) { $ words = $ this -> getWords ( $ string ) ; $ analysis = new FrequencyAnalysis ( $ words ) ; $ keywords = $ analysis -> getKeyValuesByFrequency ( ) ; return array_slice ( $ keywords , 0 , $ amount ) ; }
8165	public function compile ( Twig_NodeInterface $ node , $ indentation = 0 ) { $ this -> lastLine = null ; $ this -> source = '' ; $ this -> debugInfo = array ( ) ; $ this -> sourceOffset = 0 ; $ this -> sourceLine = 1 ; $ this -> indentation = $ indentation ; $ this -> varNameSalt = 0 ; if ( $ node instanceof Twig_Node_Module ) { $ this -> filename = $ node -> getTemplateName ( ) ; } $ node -> compile ( $ this ) ; return $ this ; }
12614	public function have_required_properties ( ) { return ( ! empty ( $ this -> handle ) && ! empty ( $ this -> relative_path ) && ! empty ( $ this -> filename ) ) ; }
4037	private function getTemplatesForBaseFrom ( $ base , $ folder , $ themeName ) { if ( ! is_dir ( $ folder ) ) { return [ ] ; } $ themeName = trim ( $ themeName ) ; $ foundTemplates = Finder :: create ( ) -> in ( $ folder ) -> name ( $ base . '*' ) ; $ templates = [ ] ; foreach ( $ foundTemplates as $ template ) { $ templates [ $ template -> getBasename ( '.' . $ template -> getExtension ( ) ) ] = [ $ themeName => $ themeName ] ; } return $ templates ; }
4854	protected function profiling ( $ signal = true ) { static $ timeStart ; if ( $ signal ) { $ timeStart = microtime ( true ) ; } if ( ! $ signal ) { $ this -> timeExecution = ( microtime ( true ) - $ timeStart ) / 60 ; return $ this -> timeExecution ; } }
929	public function clean ( ) { foreach ( $ this -> files as $ file => $ value ) { $ this -> unlink ( $ file ) ; } $ this -> files = [ ] ; }
7200	protected function detachSaleItemRecursively ( SaleItemInterface $ item ) { $ this -> stockAssigner -> detachSaleItem ( $ item ) ; foreach ( $ item -> getChildren ( ) as $ child ) { $ this -> detachSaleItemRecursively ( $ child ) ; } }
3795	private function checkEmpty ( $ action ) { if ( $ this -> hasVariants ( ) && $ this -> currentModel !== null ) { $ this -> disablePA = false ; } elseif ( $ action == 'create' ) { $ this -> disablePA = false ; $ this -> disablePI = false ; } }
3671	private function getFolderUrlFragments ( string $ alias , string $ host , string $ locale = null ) : ? array { $ pages = $ this -> getPageCandidates ( $ alias ) ; if ( null === $ pages ) { return null ; } if ( isset ( $ pages [ $ host ] ) ) { $ languages = $ pages [ $ host ] ; } else { $ languages = $ pages [ '*' ] ? : [ ] ; } unset ( $ pages ) ; $ pages = [ ] ; if ( ! $ this -> isLocalePrepended ) { $ pages = current ( $ languages ) ; } elseif ( $ locale && isset ( $ languages [ $ locale ] ) ) { $ pages = $ languages [ $ locale ] ; } if ( empty ( $ pages ) ) { return null ; } $ page = $ pages [ 0 ] ; if ( $ alias == $ page -> alias ) { $ arrFragments = [ $ alias ] ; } else { $ arrFragments = explode ( '/' , substr ( $ alias , ( \ strlen ( $ page -> alias ) + 1 ) ) ) ; array_unshift ( $ arrFragments , $ page -> alias ) ; } return $ arrFragments ; }
11814	protected function step1 ( ) { $ this -> view -> addToBlock ( "form" , "import://admin/setup/license" ) ; $ this -> view -> setData ( "step" , "1" ) ; $ this -> view -> setData ( "title" , t ( "Installation | EULA" ) ) ; return ; }
3033	public function getSessionDescription ( \ taoQtiTest_helpers_TestSession $ session ) { if ( $ session -> isRunning ( ) ) { $ config = \ common_ext_ExtensionsManager :: singleton ( ) -> getExtensionById ( 'taoQtiTest' ) -> getConfig ( 'testRunner' ) ; $ progressScope = isset ( $ config [ 'progress-indicator-scope' ] ) ? $ config [ 'progress-indicator-scope' ] : 'test' ; $ progress = $ this -> getSessionProgress ( $ session ) ; $ itemPosition = $ progress [ $ progressScope ] ; $ itemCount = $ progress [ $ progressScope . 'Length' ] ; $ format = $ this -> hasOption ( self :: OPTION_STATE_FORMAT ) ? $ this -> getOption ( self :: OPTION_STATE_FORMAT ) : __ ( '%s - item %p/%c' ) ; $ map = array ( '%s' => $ session -> getCurrentAssessmentSection ( ) -> getTitle ( ) , '%p' => $ itemPosition , '%c' => $ itemCount ) ; return strtr ( $ format , $ map ) ; } else { return __ ( 'finished' ) ; } }
10675	private function _sklon ( $ nPad , $ vzndx , $ txt , $ zivotne = false ) { if ( $ vzndx < 0 || $ vzndx >= \ count ( $ this -> vzor ) ) { return '???' ; } $ txt3 = $ this -> _xEdeten ( $ txt ) ; $ kndx = $ this -> _isShoda ( $ this -> vzor [ $ vzndx ] [ 1 ] , $ txt3 ) ; if ( $ kndx < 0 || $ nPad < 1 || $ nPad > 14 ) { return '???' ; } if ( $ this -> vzor [ $ vzndx ] [ $ nPad ] === '?' ) { return '?' ; } if ( ! $ this -> isDbgMode & $ nPad === 1 ) { $ rv = $ this -> _xDetene ( $ txt3 ) ; } else { $ rv = $ this -> _leftStr ( $ kndx , $ txt3 ) . '-' . $ this -> _cmpFrm ( $ this -> vzor [ $ vzndx ] [ $ nPad ] ) ; } if ( $ this -> isDbgMode ) { return $ rv ; } $ length = mb_strlen ( $ rv , 'UTF-8' ) ; for ( $ nnn = 0 ; $ nnn < $ length ; $ nnn ++ ) { if ( mb_substr ( $ rv , $ nnn , 1 , 'UTF-8' ) === '-' ) { break ; } } $ ndx1 = $ nnn ; for ( $ nnn = 0 ; $ nnn < $ length ; $ nnn ++ ) { if ( mb_substr ( $ rv , $ nnn , 1 , 'UTF-8' ) === '/' ) { break ; } } $ ndx2 = $ nnn ; if ( $ ndx1 !== $ length && $ ndx2 !== $ length ) { if ( $ zivotne ) { $ rv = $ this -> _leftStr ( $ ndx1 , $ rv ) . $ this -> _rightStr ( $ ndx2 + 1 , $ rv ) ; } else { $ rv = $ this -> _leftStr ( $ ndx2 , $ rv ) ; } $ length = mb_strlen ( $ rv , 'UTF-8' ) ; } $ txt3 = '' ; for ( $ nnn = 0 ; $ nnn < $ length ; $ nnn ++ ) { $ subStr = mb_substr ( $ rv , $ nnn , 1 , 'UTF-8' ) ; if ( ! ( $ subStr === '-' || $ subStr === '/' ) ) { $ txt3 .= mb_substr ( $ rv , $ nnn , 1 , 'UTF-8' ) ; } } $ rv = $ this -> _xDetene ( $ txt3 ) ; return $ rv ; }
2454	public function showAll ( ) { $ return = '' ; $ this -> limit = '' ; $ objSession = System :: getContainer ( ) -> get ( 'session' ) ; $ undoPeriod = ( int ) Config :: get ( 'undoPeriod' ) ; $ logPeriod = ( int ) Config :: get ( 'logPeriod' ) ; if ( $ this -> strTable == 'tl_undo' && $ undoPeriod > 0 ) { $ this -> Database -> prepare ( "DELETE FROM tl_undo WHERE tstamp<?" ) -> execute ( time ( ) - $ undoPeriod ) ; } elseif ( $ this -> strTable == 'tl_log' && $ logPeriod > 0 ) { $ this -> Database -> prepare ( "DELETE FROM tl_log WHERE tstamp<?" ) -> execute ( time ( ) - $ logPeriod ) ; } $ this -> reviseTable ( ) ; if ( Input :: get ( 'act' ) == 'paste' ) { $ arrClipboard = $ objSession -> get ( 'CLIPBOARD' ) ; $ arrClipboard [ $ this -> strTable ] = array ( 'id' => Input :: get ( 'id' ) , 'childs' => Input :: get ( 'childs' ) , 'mode' => Input :: get ( 'mode' ) ) ; $ objSession -> set ( 'CLIPBOARD' , $ arrClipboard ) ; } if ( ! empty ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'filter' ] ) && \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'filter' ] ) ) { foreach ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'filter' ] as $ filter ) { $ this -> procedure [ ] = $ filter [ 0 ] ; $ this -> values [ ] = $ filter [ 1 ] ; } } if ( $ this -> treeView ) { $ return .= $ this -> panel ( ) ; $ return .= $ this -> treeView ( ) ; } else { if ( Input :: get ( 'table' ) && $ this -> ptable && $ this -> Database -> fieldExists ( 'pid' , $ this -> strTable ) ) { $ this -> procedure [ ] = 'pid=?' ; $ this -> values [ ] = CURRENT_ID ; } $ return .= $ this -> panel ( ) ; $ return .= ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'mode' ] == 4 ) ? $ this -> parentView ( ) : $ this -> listView ( ) ; if ( strpos ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'panelLayout' ] , 'limit' ) !== false ) { $ return .= $ this -> paginationMenu ( ) ; } } return $ return ; }
5749	public static function arrayWalkToStringRecursive ( array $ arr , int $ level = 0 , int $ maxLevel = 1000 , $ newLine = '<br>' ) : string { $ out = "" ; $ tabs = " " ; for ( $ i = 0 ; $ i < $ level ; $ i ++ ) { $ tabs .= " ^" ; } foreach ( $ arr as $ k => $ v ) { $ out .= "$newLine$tabs$k: " ; if ( is_object ( $ v ) ) { $ out .= 'object type: ' . get_class ( $ v ) ; } elseif ( is_array ( $ v ) ) { $ newLevel = $ level + 1 ; if ( $ newLevel > $ maxLevel ) { $ out .= ' array too deep, quitting' ; } else { $ out .= self :: arrayWalkToStringRecursive ( $ v , $ newLevel , $ maxLevel , $ newLine ) ; } } else { $ out .= ( string ) $ v ; } } return $ out ; }
2428	protected function hasToWait ( ) { $ return = true ; $ time = strtotime ( date ( 'Y-m-d H:i' ) ) ; $ this -> Database -> lockTables ( array ( 'tl_cron' => 'WRITE' ) ) ; $ objCron = $ this -> Database -> prepare ( "SELECT * FROM tl_cron WHERE name='lastrun'" ) -> limit ( 1 ) -> execute ( ) ; if ( $ objCron -> numRows < 1 ) { $ this -> Database -> query ( "INSERT INTO tl_cron (name, value) VALUES ('lastrun', $time)" ) ; $ return = false ; } elseif ( $ objCron -> value <= ( $ time - $ this -> getCronTimeout ( ) ) ) { $ this -> Database -> query ( "UPDATE tl_cron SET value=$time WHERE name='lastrun'" ) ; $ return = false ; } $ this -> Database -> unlockTables ( ) ; return $ return ; }
5056	public function attachEvents ( EventManagerInterface $ events , array $ eventsSpec = null ) { if ( null === $ eventsSpec ) { $ eventsSpec = $ this -> eventsProvider ( ) ; } foreach ( $ eventsSpec as $ spec ) { if ( ! is_array ( $ spec ) || 2 > count ( $ spec ) ) { throw new \ UnexpectedValueException ( 'Event specification must be an array with at least two entries: event name and method name.' ) ; } $ event = $ spec [ 0 ] ; $ method = $ spec [ 1 ] ; $ priority = isset ( $ spec [ 2 ] ) ? $ spec [ 2 ] : 0 ; $ this -> listeners [ ] = $ events -> attach ( $ event , [ $ this , $ method ] , $ priority ) ; } return $ this ; }
12243	public function XSLT ( $ filepath , $ use_xslcache = true ) { if ( $ use_xslcache && extension_loaded ( 'xslcache' ) ) { $ xslt = new XSLTCache ; $ xslt -> importStylesheet ( $ filepath ) ; } else { $ xsl = new DOMDocument ; $ xsl -> load ( $ filepath ) ; $ xslt = new XSLTProcessor ; $ xslt -> importStylesheet ( $ xsl ) ; } return $ xslt -> transformToXML ( dom_import_simplexml ( $ this ) ) ; }
501	protected function getHeaderCheckBoxName ( ) { $ name = $ this -> name ; if ( substr_compare ( $ name , '[]' , - 2 , 2 ) === 0 ) { $ name = substr ( $ name , 0 , - 2 ) ; } if ( substr_compare ( $ name , ']' , - 1 , 1 ) === 0 ) { $ name = substr ( $ name , 0 , - 1 ) . '_all]' ; } else { $ name .= '_all' ; } return $ name ; }
328	public static function instance ( $ refresh = false ) { $ className = get_called_class ( ) ; if ( $ refresh || ! isset ( self :: $ _instances [ $ className ] ) ) { self :: $ _instances [ $ className ] = Yii :: createObject ( $ className ) ; } return self :: $ _instances [ $ className ] ; }
10792	public function get ( $ idOrUser ) { $ main = $ this -> getServiceLocator ( ) -> get ( 'neobazaar.service.main' ) ; $ userRepository = $ main -> getUserEntityRepository ( ) ; if ( 'current' == $ idOrUser ) { return $ userRepository -> get ( $ idOrUser , $ this -> getServiceLocator ( ) ) ; } $ user = $ this -> getEntity ( $ idOrUser ) ; if ( ! $ this -> checkIfOwnerOrAdmin ( $ user ) ) { throw new \ Exception ( 'Non possiedi i permessi per agire su questo documento' ) ; } return $ userRepository -> get ( $ user , $ this -> getServiceLocator ( ) ) ; }
7095	private function throwIllegalOperationIfItemIsImmutable ( ResourceEventInterface $ event ) { if ( $ event -> getHard ( ) ) { return ; } $ item = $ this -> getSaleItemFromEvent ( $ event ) ; if ( $ item -> isImmutable ( ) ) { throw new IllegalOperationException ( 'ekyna_commerce.sale.message.immutable_element' ) ; } }
8654	private function convertSubmitFeed ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'SubmitFeed' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetMarketplaceIdList ( ) ) { $ marketplaceIdList = $ request -> getMarketplaceIdList ( ) ; foreach ( $ marketplaceIdList -> getId ( ) as $ idIndex => $ id ) { $ parameters [ 'MarketplaceIdList.Id.' . ( $ idIndex + 1 ) ] = $ id ; } } if ( $ request -> isSetFeedType ( ) ) { $ parameters [ 'FeedType' ] = $ request -> getFeedType ( ) ; } if ( $ request -> isSetPurgeAndReplace ( ) ) { $ parameters [ 'PurgeAndReplace' ] = $ request -> getPurgeAndReplace ( ) ? "true" : "false" ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } $ headers = array ( ) ; array_push ( $ headers , "Content-Type: " . $ request -> getContentType ( ) -> toString ( ) ) ; return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ headers ) ; }
10230	public function getContext ( ) { $ s = '' ; foreach ( [ 'a' , 'b' , 'c' , 'd' ] as $ i ) { $ v = $ this -> { $ i } ; $ s .= chr ( $ v & 0xff ) ; $ s .= chr ( ( $ v >> 8 ) & 0xff ) ; $ s .= chr ( ( $ v >> 16 ) & 0xff ) ; $ s .= chr ( ( $ v >> 24 ) & 0xff ) ; } return $ s ; }
6451	public function isLoggedIn ( ) { $ cookieName = session_name ( ) ; $ cookie = $ this -> getSession ( ) -> getCookie ( $ cookieName ) ; if ( null !== $ cookie ) { $ this -> getSession ( 'goutte' ) -> setCookie ( $ cookieName , $ cookie ) ; return true ; } return false ; }
9380	protected function retrieve ( array $ routes , $ uri ) { $ routes = array_values ( array_filter ( $ routes ) ) ; if ( empty ( $ routes ) ) { $ message = 'Route "' . $ uri . '" not found' ; throw new \ UnexpectedValueException ( $ message ) ; } $ route = current ( $ routes ) ; $ route [ 1 ] = ( count ( $ route [ 1 ] ) > 0 ) ? array_combine ( $ route [ 3 ] , $ route [ 1 ] ) : $ route [ 1 ] ; return $ route ; }
4957	public function onFlush ( OnFlushEventArgs $ args ) { $ dm = $ args -> getDocumentManager ( ) ; $ uow = $ dm -> getUnitOfWork ( ) ; $ filter = function ( $ element ) { return $ element instanceof $ this -> targetDocument && $ element instanceof PermissionsAwareInterface && $ element -> getPermissions ( ) -> hasChanged ( ) ; } ; $ inserts = array_filter ( $ uow -> getScheduledDocumentInsertions ( ) , $ filter ) ; $ updates = array_filter ( $ uow -> getScheduledDocumentUpdates ( ) , $ filter ) ; $ this -> process ( $ inserts , $ dm , $ uow , true ) ; $ this -> process ( $ updates , $ dm , $ uow ) ; }
2602	public function execute ( ) { $ result = $ this -> resultJsonFactory -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ dictionaryName = Config :: AUTH_DICTIONARY_NAME ; $ dictionary = $ this -> api -> getSingleDictionary ( $ activeVersion , $ dictionaryName ) ; if ( ( is_array ( $ dictionary ) && empty ( $ dictionary ) ) || $ dictionary == false ) { return $ result -> setData ( [ 'status' => false ] ) ; } else { return $ result -> setData ( [ 'status' => true ] ) ; } } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
12959	public function update ( $ table , $ data = array ( ) , $ where = '1=1' ) { if ( ! $ this -> getDb ( ) -> update ( $ table , $ data , $ where ) ) { throw new DbException ( "Failed updating " . $ table ) ; } return true ; }
7795	protected function statementBody ( $ text ) { switch ( substr ( $ this -> getLine ( '20' , $ text ) , 0 , 4 ) ) { case '940A' : $ this -> format = self :: FORMAT_CLASSIC ; break ; case '940S' : $ this -> format = self :: FORMAT_STRUCTURED ; break ; default : throw new \ RuntimeException ( 'Unknown file format' ) ; } return parent :: statementBody ( $ text ) ; }
1209	public function slice ( ItemInterface $ item , $ offset , $ length = null ) { $ names = array_keys ( $ item -> getChildren ( ) ) ; if ( $ offset instanceof ItemInterface ) { $ offset = $ offset -> getName ( ) ; } if ( ! is_numeric ( $ offset ) ) { $ offset = array_search ( $ offset , $ names ) ; } if ( null !== $ length ) { if ( $ length instanceof ItemInterface ) { $ length = $ length -> getName ( ) ; } if ( ! is_numeric ( $ length ) ) { $ index = array_search ( $ length , $ names ) ; $ length = ( $ index < $ offset ) ? 0 : $ index - $ offset ; } } $ slicedItem = $ item -> copy ( ) ; $ children = array_slice ( $ slicedItem -> getChildren ( ) , $ offset , $ length ) ; $ slicedItem -> setChildren ( $ children ) ; return $ slicedItem ; }
12352	public function allow ( array $ level_select = [ "min" => 4 , "max" => 4 ] ) : bool { if ( $ this -> details !== false ) { if ( is_array ( $ level_select ) === true && isset ( $ level_select [ "min" ] ) === true && isset ( $ level_select [ "max" ] ) === true ) { $ level_select [ "min" ] = Model \ Role :: find ( $ level_select [ "min" ] ) -> priority ; $ level_select [ "max" ] = Model \ Role :: find ( $ level_select [ "max" ] ) -> priority ; $ level_select = [ "min" => $ level_select [ "min" ] , "max" => $ level_select [ "max" ] ] ; } else { return false ; } $ current_priority = $ this -> details -> role -> priority ; if ( is_numeric ( $ level_select [ "min" ] ) === true && is_numeric ( $ level_select [ "max" ] ) === true ) { if ( $ level_select [ "min" ] >= $ current_priority && $ level_select [ "max" ] <= $ current_priority ) { return true ; } else { return false ; } } else { return false ; } } else { return false ; } }
401	public static function processParagraph ( $ markdown , $ flavor = null ) { $ parser = static :: getParser ( $ flavor ) ; return $ parser -> parseParagraph ( $ markdown ) ; }
9984	function fromXML ( $ xmlElement ) { if ( isset ( $ xmlElement -> id ) ) $ this -> id = $ xmlElement -> id ; if ( isset ( $ xmlElement -> name ) ) $ this -> name = $ xmlElement -> name ; if ( isset ( $ xmlElement -> entries ) ) { $ this -> entries = array ( ) ; foreach ( $ xmlElement -> entries -> children ( ) as $ entry ) { $ this -> entries [ ] = $ entry ; } } }
4773	public function order ( Request $ request , WidgetInterface $ widget , string $ widgetId , int $ order ) { $ widgets = $ widget -> getWidgets ( ) ; if ( isset ( $ widgets [ $ widgetId ] ) ) { $ widgetConfig = $ this -> getDoctrine ( ) -> getRepository ( 'PdWidgetBundle:WidgetUser' ) -> findOneBy ( [ 'owner' => $ this -> getUser ( ) ] ) ?? ( new WidgetUser ( ) ) -> setOwner ( $ this -> getUser ( ) ) ; $ widgetConfig -> addWidgetConfig ( $ widgetId , [ 'order' => $ order ] ) ; $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ em -> persist ( $ widgetConfig ) ; $ em -> flush ( ) ; } return $ this -> json ( [ 'result' => 'success' , ] ) ; }
7368	protected function checkShipmentIntegrity ( SaleItemInterface $ item , SaleItem $ constraint ) { $ sale = $ item -> getSale ( ) ; if ( ! $ sale instanceof Shipment \ ShipmentSubjectInterface ) { return ; } if ( empty ( $ sale -> getShipments ( ) -> toArray ( ) ) ) { return ; } $ min = $ this -> shipmentCalculator -> calculateShippedQuantity ( $ item ) ; if ( 1 === bccomp ( $ min , 0 , 3 ) && 1 === bccomp ( $ min , $ item -> getTotalQuantity ( ) , 3 ) ) { $ this -> context -> buildViolation ( $ constraint -> quantity_is_lower_than_shipped , [ '%min%' => $ min , ] ) -> setInvalidValue ( $ item -> getQuantity ( ) ) -> atPath ( 'quantity' ) -> addViolation ( ) ; throw new ValidationFailedException ( ) ; } }
6311	public function getTable ( Table $ table ) { return $ this -> container -> get ( 'rentgen.get_table' ) -> setTableName ( $ table -> getName ( ) ) -> execute ( ) ; }
9571	public function bootConsole ( ) { $ this -> console = new ConsoleApplication ( 'Autarky' , static :: VERSION ) ; $ this -> console -> setAutarkyApplication ( $ this ) ; $ this -> boot ( ) ; return $ this -> console ; }
1609	public function delete ( $ id ) { $ redirect = RedirectRecord :: findOne ( compact ( 'id' ) ) -> delete ( ) ; if ( $ redirect === false ) return 'Unable find redirect with ID: ' . $ id ; return false ; }
4584	public function created ( JWTCreatedEvent $ event ) { $ data = $ event -> getData ( ) ; $ this -> accessor -> setValue ( $ data , $ this -> property , $ this -> getSignature ( ) ) ; $ event -> setData ( $ data ) ; }
10702	public static function getPasswordComplexity ( $ password , $ minLength ) { $ group = [ 'upper' => '/[A-Z]/' , 'lower' => '/[a-z]/' , 'number' => '/[0-9]/' , 'special' => '/[^A-Za-z0-9]/' , ] ; $ score = 0 ; $ length = \ strlen ( $ password ) ; if ( $ length < $ minLength ) { return 0 ; } foreach ( $ group as $ pattern ) { if ( preg_match ( $ pattern , $ password ) ) { $ score ++ ; } } if ( $ score < 3 ) { $ score -- ; } if ( $ length > $ minLength ) { $ score += ( int ) floor ( ( $ length - $ minLength ) / 2 ) ; } return $ score ; }
10142	private function readDefault ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ this -> pos += 4 + $ length ; }
1684	public function checkAdminStatus ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ varValue == '' && $ this -> User -> id == $ dc -> id ) { $ varValue = 1 ; } return $ varValue ; }
10283	public static function buildRange ( array $ pRange ) { if ( empty ( $ pRange ) || ! is_array ( $ pRange [ 0 ] ) ) { throw new Exception ( 'Range does not contain any information' ) ; } $ imploded = [ ] ; $ counter = count ( $ pRange ) ; for ( $ i = 0 ; $ i < $ counter ; ++ $ i ) { $ pRange [ $ i ] = implode ( ':' , $ pRange [ $ i ] ) ; } $ imploded = implode ( ',' , $ pRange ) ; return $ imploded ; }
9222	public function serialize ( ) { $ this -> requestAllPages ( ) ; return serialize ( array ( 'page' => $ this -> page , 'key' => $ this -> key , 'data' => $ this -> data ) ) ; }
4806	protected function processMemberVar ( File $ phpcsFile , $ stackPtr ) { $ tokens = $ phpcsFile -> getTokens ( ) ; $ commentToken = [ T_COMMENT , T_DOC_COMMENT_CLOSE_TAG , ] ; $ commentEnd = $ phpcsFile -> findPrevious ( $ commentToken , $ stackPtr ) ; $ commentStart = $ tokens [ $ commentEnd ] [ 'comment_opener' ] ; if ( $ tokens [ $ commentEnd ] [ 'line' ] === $ tokens [ $ commentStart ] [ 'line' ] ) { $ phpcsFile -> addError ( 'Member variable comment should not be inline' , $ stackPtr , static :: ERROR_CODE ) ; } }
5957	public function channelGetByName ( $ name ) { foreach ( $ this -> channelList ( ) as $ channel ) { if ( $ channel [ "channel_name" ] == $ name ) { return $ channel ; } } throw new Ts3Exception ( "invalid channelID" , 0x300 ) ; }
7557	function getChildrenByTag ( $ tag , $ compare = 'total' , $ recursive = true ) { if ( $ this -> childCount ( ) < 1 ) { return array ( ) ; } $ tag = explode ( ' ' , strtolower ( $ tag ) ) ; $ match = ( ( isset ( $ tag [ 1 ] ) && ( $ tag [ 1 ] === 'not' ) ) ? 'false' : 'true' ) ; return $ this -> getChildrenByMatch ( array ( 'tags' => array ( $ tag [ 0 ] => array ( 'match' => $ match , 'compare' => $ compare ) ) ) , $ recursive ) ; }
1130	public function makeFirstChildOf ( $ node ) { if ( $ node -> children ( ) -> count ( ) == 0 ) return $ this -> makeChildOf ( $ node ) ; return $ this -> moveToLeftOf ( $ node -> children ( ) -> first ( ) ) ; }
2379	public static function deserialize ( $ varValue , $ blnForceArray = false ) { if ( \ is_array ( $ varValue ) ) { return $ varValue ; } if ( $ varValue === null ) { return $ blnForceArray ? array ( ) : null ; } if ( ! \ is_string ( $ varValue ) ) { return $ blnForceArray ? array ( $ varValue ) : $ varValue ; } if ( trim ( $ varValue ) == '' ) { return $ blnForceArray ? array ( ) : '' ; } if ( strncmp ( $ varValue , 'a:' , 2 ) !== 0 ) { return $ blnForceArray ? array ( $ varValue ) : $ varValue ; } if ( preg_match ( '/[OoC]:\+?[0-9]+:"/' , $ varValue ) ) { trigger_error ( 'StringUtil::deserialize() does not allow serialized objects' , E_USER_WARNING ) ; return $ blnForceArray ? array ( $ varValue ) : $ varValue ; } $ varUnserialized = @ unserialize ( $ varValue , array ( 'allowed_classes' => false ) ) ; if ( \ is_array ( $ varUnserialized ) ) { $ varValue = $ varUnserialized ; } elseif ( $ blnForceArray ) { $ varValue = array ( $ varValue ) ; } return $ varValue ; }
10073	public function allDrawings ( Spreadsheet $ spreadsheet ) { $ aDrawings = [ ] ; $ sheetCount = $ spreadsheet -> getSheetCount ( ) ; for ( $ i = 0 ; $ i < $ sheetCount ; ++ $ i ) { $ iterator = $ spreadsheet -> getSheet ( $ i ) -> getDrawingCollection ( ) -> getIterator ( ) ; while ( $ iterator -> valid ( ) ) { $ aDrawings [ ] = $ iterator -> current ( ) ; $ iterator -> next ( ) ; } } return $ aDrawings ; }
1736	public function getQrCode ( User $ user , Request $ request ) : string { $ renderer = new ImageRenderer ( new RendererStyle ( 180 , 0 ) , new SvgImageBackEnd ( ) ) ; $ writer = new Writer ( $ renderer ) ; return $ writer -> writeString ( $ this -> getProvisionUri ( $ user , $ request ) ) ; }
6160	public function setProperties ( array $ properties ) { $ this -> properties = [ ] ; foreach ( $ properties as $ item ) { $ this -> addPropertyRequest ( $ item ) ; } return $ this ; }
1582	public function withRelationships ( $ relationships ) : self { $ copy = clone $ this ; $ copy -> relationships = collect ( $ relationships ) -> all ( ) ; $ copy -> normalize ( ) ; return $ copy ; }
8117	public function onBeforeWrite ( ) { $ changedFields = $ this -> owner -> getChangedFields ( true , 2 ) ; if ( $ changedFields ) { $ this -> owner -> LastEditedByName = $ this -> owner -> getEditorName ( ) ; $ this -> owner -> OwnerNames = $ this -> owner -> getOwnerNames ( ) ; } if ( $ this -> owner -> isChanged ( "ContentReviewType" , 2 ) ) { if ( $ this -> owner -> ContentReviewType == "Disabled" ) { $ this -> setDefaultReviewDateForDisabled ( ) ; } elseif ( $ this -> owner -> ContentReviewType == "Custom" ) { $ this -> setDefaultReviewDateForCustom ( ) ; } else { $ this -> setDefaultReviewDateForInherited ( ) ; } } if ( $ this -> owner -> ContentReviewType == "Inherit" && ! $ this -> owner -> NextReviewDate ) { $ this -> setDefaultReviewDateForInherited ( ) ; } if ( ! $ this -> owner -> exists ( ) ) { return ; } if ( $ this -> owner -> isChanged ( 'ReviewPeriodDays' , 2 ) ) { $ nextReviewUnixSec = strtotime ( ' + ' . $ this -> owner -> ReviewPeriodDays . ' days' , DBDatetime :: now ( ) -> getTimestamp ( ) ) ; $ this -> owner -> NextReviewDate = DBDate :: create ( ) -> setValue ( $ nextReviewUnixSec ) -> Format ( 'y-MM-dd' ) ; } }
5378	public function wrapIsEnabled ( ) { if ( $ this -> getAttribute ( 'cols' ) ) { $ wrap = $ this -> getAttribute ( 'wrap' ) ; if ( ( $ wrap === 'physical' ) || ( $ wrap === 'hard' ) ) { return true ; } } return false ; }
7717	function FileGetState ( $ NameOrIdx ) { $ idx = $ this -> FileGetIdx ( $ NameOrIdx ) ; if ( $ idx === false ) { $ idx = $ this -> FileGetIdxAdd ( $ NameOrIdx ) ; if ( $ idx === false ) { return false ; } else { return 'a' ; } } elseif ( isset ( $ this -> ReplInfo [ $ idx ] ) ) { if ( $ this -> ReplInfo [ $ idx ] === false ) { return 'd' ; } else { return 'm' ; } } else { return 'u' ; } }
8534	public function setChargeInstrumentList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ChargeInstrumentList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
1724	public static function generateRandomSecret ( Event $ event ) : void { $ extra = $ event -> getComposer ( ) -> getPackage ( ) -> getExtra ( ) ; if ( ! isset ( $ extra [ 'incenteev-parameters' ] ) || ! self :: canGenerateSecret ( $ extra [ 'incenteev-parameters' ] ) ) { return ; } if ( ! \ function_exists ( 'random_bytes' ) ) { self :: loadRandomCompat ( $ event ) ; } putenv ( static :: RANDOM_SECRET_NAME . '=' . bin2hex ( random_bytes ( 32 ) ) ) ; }
11234	protected function checkValue ( $ value , $ subject , $ reference ) { if ( is_null ( $ value ) ) { return $ subject ; } elseif ( $ subject != $ reference ) { throw new RuntimeException ( Message :: get ( Message :: MSG_REF_MALFORMED , $ reference ) , Message :: MSG_REF_MALFORMED ) ; } else { return $ value ; } }
3442	public function fetchUsing ( $ methodAndParams ) { if ( is_string ( $ methodAndParams ) || empty ( $ methodAndParams [ 'method' ] ) ) { $ this -> fetchUsing = in_array ( $ methodAndParams , [ 'GetNext' , 'getNext' ] ) ? [ 'method' => 'GetNext' , 'params' => [ true , true ] ] : [ 'method' => 'Fetch' ] ; return $ this ; } if ( in_array ( $ methodAndParams [ 'method' ] , [ 'GetNext' , 'getNext' ] ) ) { $ bTextHtmlAuto = isset ( $ methodAndParams [ 'params' ] [ 0 ] ) ? $ methodAndParams [ 'params' ] [ 0 ] : true ; $ useTilda = isset ( $ methodAndParams [ 'params' ] [ 1 ] ) ? $ methodAndParams [ 'params' ] [ 1 ] : true ; $ this -> fetchUsing = [ 'method' => 'GetNext' , 'params' => [ $ bTextHtmlAuto , $ useTilda ] ] ; } else { $ this -> fetchUsing = [ 'method' => 'Fetch' ] ; } return $ this ; }
4846	public static function register ( array $ aliases ) { if ( ! $ aliases ) { return ; } if ( ! isset ( self :: $ autoloadFn ) ) { $ classAliases = & self :: $ aliases ; self :: $ autoloadFn = function ( $ className ) use ( & $ classAliases ) { if ( isset ( $ classAliases [ $ className ] ) ) { if ( strtolower ( $ classAliases [ $ className ] ) === strtolower ( $ className ) ) { throw new \ LogicException ( "Class alias is referencing the alias itself" ) ; } $ facadeClass = $ classAliases [ $ className ] ; class_alias ( $ facadeClass , $ className ) ; } } ; spl_autoload_register ( self :: $ autoloadFn ) ; } self :: $ aliases = array_merge ( self :: $ aliases , $ aliases ) ; }
963	public function postProcess ( ) { if ( ! $ this -> shop -> trashed ( ) ) { return ; } $ this -> shop -> restore ( ) ; $ this -> shop -> charges ( ) -> restore ( ) ; $ this -> shop -> save ( ) ; }
5023	public function allowSelectMultipleItems ( ) { $ flagOrCallback = $ this -> allowSelectMultipleItems ; return is_callable ( $ flagOrCallback ) ? ( bool ) $ flagOrCallback ( ) : ( bool ) $ flagOrCallback ; }
11739	public function getMd5Address ( $ scheme = true , $ www = true ) { return md5 ( $ this -> normalize ( $ scheme , $ www ) ) ; }
9146	public function get ( $ key ) { if ( ! isset ( $ this -> sessionContainer [ $ key ] ) ) { return null ; } return $ this -> sessionContainer [ $ key ] ; }
12956	public function remove ( $ id ) { if ( ! $ this -> has ( $ id ) ) { throw new NotFoundException ( sprintf ( '%s not found in %s' , $ id , __CLASS__ ) ) ; } unset ( $ this -> objects [ $ id ] ) ; }
174	protected function isOptional ( $ action ) { $ id = $ this -> getActionId ( $ action ) ; foreach ( $ this -> optional as $ pattern ) { if ( StringHelper :: matchWildcard ( $ pattern , $ id ) ) { return true ; } } return false ; }
12211	public function addSnippet ( string $ snptName ) : void { $ this -> snippets [ $ snptName ] = ViewFactory :: createSnippet ( $ snptName ) ; }
434	private function isIncorrectClassNameOrPrefix ( $ className , $ prefix ) { if ( ! preg_match ( '%^[a-z][a-z0-9\\-_]*$%' , $ className ) ) { return true ; } if ( $ prefix !== '' && ! preg_match ( '%^[a-z0-9_/]+$%i' , $ prefix ) ) { return true ; } return false ; }
2099	public static function getNumericDateFormat ( ) { if ( TL_MODE == 'FE' ) { global $ objPage ; if ( $ objPage -> dateFormat != '' && static :: isNumericFormat ( $ objPage -> dateFormat ) ) { return $ objPage -> dateFormat ; } } return Config :: get ( 'dateFormat' ) ; }
9561	protected function makeResponse ( $ response , Exception $ exception ) { if ( ! $ response instanceof Response ) { $ response = new Response ( $ response ) ; } if ( ! $ response -> isClientError ( ) && ! $ response -> isServerError ( ) && ! $ response -> isRedirect ( ) ) { if ( $ exception instanceof HttpExceptionInterface ) { $ response -> setStatusCode ( $ exception -> getStatusCode ( ) ) ; $ response -> headers -> add ( $ exception -> getHeaders ( ) ) ; } else { $ response -> setStatusCode ( 500 ) ; } } return $ response ; }
6189	public function renderJSONP ( $ data ) { $ callback = null ; if ( isset ( $ _GET [ 'callback' ] ) ) { $ callback = $ _GET [ 'callback' ] ; } exit ( Response :: Create ( $ callback . '(' . json_encode ( $ data ) . ')' ) -> headers ( [ 'Content-Type' => 'application/jsonp' ] ) -> display ( ) ) ; }
1006	public function resolveType ( $ objectValue , $ context , ResolveInfo $ info ) { if ( isset ( $ this -> config [ 'resolveType' ] ) ) { $ fn = $ this -> config [ 'resolveType' ] ; return $ fn ( $ objectValue , $ context , $ info ) ; } return null ; }
11205	public function merge ( $ data , $ key = false , $ dataKey = false ) { if ( $ data != false && ( is_array ( $ data ) || is_object ( $ data ) ) ) { foreach ( $ data as $ item ) { $ this -> add ( $ item , $ key , $ dataKey , true ) ; } } else { $ this -> add ( $ data , $ key , $ dataKey ) ; } return $ this ; }
1436	public static function camelize ( $ value ) { if ( isset ( self :: $ camelized [ $ value ] ) ) { return self :: $ camelized [ $ value ] ; } return self :: $ camelized [ $ value ] = lcfirst ( self :: classify ( $ value ) ) ; }
11074	public function setDateTime ( string $ key , $ value , string $ format , string $ ignoredDefaultValue = null ) { if ( $ value instanceof DateTime ) { $ this -> set ( $ key , $ value -> format ( $ format ) , $ ignoredDefaultValue ) ; } return $ this ; }
895	private function findComparisonEnd ( Tokens $ tokens , $ index ) { ++ $ index ; $ count = \ count ( $ tokens ) ; while ( $ index < $ count ) { $ token = $ tokens [ $ index ] ; if ( $ token -> isGivenKind ( [ T_WHITESPACE , T_COMMENT , T_DOC_COMMENT ] ) ) { ++ $ index ; continue ; } if ( $ this -> isOfLowerPrecedence ( $ token ) ) { break ; } $ block = Tokens :: detectBlockType ( $ token ) ; if ( null === $ block ) { ++ $ index ; continue ; } if ( ! $ block [ 'isStart' ] ) { break ; } $ index = $ tokens -> findBlockEnd ( $ block [ 'type' ] , $ index ) + 1 ; } $ prev = $ tokens -> getPrevMeaningfulToken ( $ index ) ; return $ tokens [ $ prev ] -> isGivenKind ( T_CLOSE_TAG ) ? $ tokens -> getPrevMeaningfulToken ( $ prev ) : $ prev ; }
3050	protected function initStorage ( ) { $ deliveryServerService = $ this -> getServiceManager ( ) -> get ( DeliveryServerService :: SERVICE_ID ) ; $ resultStore = $ deliveryServerService -> getResultStoreWrapper ( $ this -> getTestExecutionUri ( ) ) ; $ testResource = new \ core_kernel_classes_Resource ( $ this -> getTestDefinitionUri ( ) ) ; $ sessionManager = new \ taoQtiTest_helpers_SessionManager ( $ resultStore , $ testResource ) ; $ seeker = new BinaryAssessmentTestSeeker ( $ this -> getTestDefinition ( ) ) ; $ userUri = $ this -> getUserUri ( ) ; $ config = \ common_ext_ExtensionsManager :: singleton ( ) -> getExtensionById ( 'taoQtiTest' ) -> getConfig ( 'testRunner' ) ; $ storageClassName = $ config [ 'test-session-storage' ] ; $ this -> storage = new $ storageClassName ( $ sessionManager , $ seeker , $ userUri ) ; $ this -> sessionManager = $ sessionManager ; }
2001	private function getFiles ( FileUpload $ uploader ) : array { $ files = $ uploader -> uploadTo ( 'system/tmp' ) ; if ( \ count ( $ files ) < 1 ) { throw new \ RuntimeException ( $ this -> translator -> trans ( 'ERR.all_fields' , [ ] , 'contao_default' ) ) ; } foreach ( $ files as & $ file ) { $ extension = pathinfo ( $ file , PATHINFO_EXTENSION ) ; if ( 'csv' !== $ extension ) { throw new \ RuntimeException ( sprintf ( $ this -> translator -> trans ( 'ERR.filetype' , [ ] , 'contao_default' ) , $ extension ) ) ; } $ file = $ this -> projectDir . '/' . $ file ; } return $ files ; }
7103	public static function query ( array $ params = null , $ use_get = null ) { if ( $ use_get ) { if ( $ params === NULL ) { $ params = $ _GET ; } else { $ params = Arr :: merge ( $ _GET , $ params ) ; } } if ( empty ( $ params ) ) { return '' ; } $ query = http_build_query ( $ params , '' , '&' ) ; return ( $ query === '' ) ? '' : ( '?' . $ query ) ; }
4798	function offsetGet ( $ key ) { if ( $ this -> single && ! isset ( $ this -> data ) ) { $ clone = clone $ this ; if ( is_array ( $ key ) ) { $ clone -> where ( $ key ) -> limit ( 1 ) ; } else { $ clone -> where ( $ this -> primary , $ key ) ; } $ return = $ clone -> fetch ( ) ; if ( $ return ) { return $ return ; } } else { $ this -> execute ( ) ; if ( is_array ( $ key ) ) { foreach ( $ this -> data as $ row ) { foreach ( $ key as $ k => $ v ) { if ( ( isset ( $ v ) && $ row [ $ k ] !== null ? $ row [ $ k ] != $ v : $ row [ $ k ] !== $ v ) ) { continue 2 ; } } return $ row ; } } elseif ( isset ( $ this -> data [ $ key ] ) ) { return $ this -> data [ $ key ] ; } } return NULL ; }
2191	public function registerAlias ( Model $ objModel , $ strAlias , $ varValue ) { $ strTable = $ objModel -> getTable ( ) ; $ strPk = $ objModel -> getPk ( ) ; $ varPk = $ objModel -> $ strPk ; if ( isset ( $ this -> arrAliases [ $ strTable ] [ $ strAlias ] [ $ varValue ] ) ) { throw new \ RuntimeException ( "The registry already contains an alias for $strTable::$strPk($varPk) ($strAlias/$varValue)" ) ; } $ this -> arrAliases [ $ strTable ] [ $ strAlias ] [ $ varValue ] = $ varPk ; }
8894	protected function _initialize_schema ( ) { $ this -> set_database ( $ this -> _database_group ) ; $ this -> _fetch_table ( ) ; $ this -> _fetch_primary_key ( ) ; if ( $ this -> primary_key == null && $ this -> is_base_model_instance ( ) ) { return ; } $ this -> _fields = $ this -> get_fields ( ) ; $ this -> _guess_is_soft_deletable ( ) ; $ this -> _guess_is_blamable ( ) ; $ this -> _guess_is_timestampable ( ) ; }
12462	private function createCreateForm ( CustomFieldsGroup $ entity ) { $ form = $ this -> createForm ( 'custom_fields_group' , $ entity , array ( 'action' => $ this -> generateUrl ( 'customfieldsgroup_create' ) , 'method' => 'POST' , ) ) ; $ form -> add ( 'submit' , 'submit' , array ( 'label' => 'Create' ) ) ; return $ form ; }
6737	public function uninstallation ( ) { $ this -> model -> delete_post_meta ( ) ; $ this -> model -> delete_options ( ) ; $ this -> model -> remove_tables ( ) ; }
3560	protected function getValueType ( $ value ) { $ type = is_object ( $ value ) ? get_class ( $ value ) : gettype ( $ value ) ; return ( $ type == 'double' ) ? 'float' : $ type ; }
2182	public function listImageSizeItem ( $ row ) { $ html = '<div class="tl_content_left">' ; $ html .= $ row [ 'media' ] ; if ( $ row [ 'width' ] || $ row [ 'height' ] ) { $ html .= ' <span style="padding-left:3px">' . $ row [ 'width' ] . 'x' . $ row [ 'height' ] . '</span>' ; } if ( $ row [ 'zoom' ] ) { $ html .= ' <span style="color:#999;padding-left:3px">(' . $ row [ 'zoom' ] . '%)</span>' ; } $ html .= "</div>\n" ; return $ html ; }
2495	protected function addEndpointsSection ( ArrayNodeDefinition $ node ) { $ node -> children ( ) -> arrayNode ( 'endpoints' ) -> info ( 'Solr Search Engine endpoint configuration' ) -> useAttributeAsKey ( 'endpoint_name' ) -> performNoDeepMerging ( ) -> prototype ( 'array' ) -> children ( ) -> scalarNode ( 'dsn' ) -> defaultNull ( ) -> end ( ) -> scalarNode ( 'scheme' ) -> defaultValue ( $ this -> defaultEndpointValues [ 'scheme' ] ) -> end ( ) -> scalarNode ( 'host' ) -> defaultValue ( $ this -> defaultEndpointValues [ 'host' ] ) -> end ( ) -> scalarNode ( 'port' ) -> defaultValue ( $ this -> defaultEndpointValues [ 'port' ] ) -> end ( ) -> scalarNode ( 'user' ) -> defaultValue ( $ this -> defaultEndpointValues [ 'user' ] ) -> end ( ) -> scalarNode ( 'pass' ) -> defaultValue ( $ this -> defaultEndpointValues [ 'pass' ] ) -> end ( ) -> scalarNode ( 'path' ) -> defaultValue ( $ this -> defaultEndpointValues [ 'path' ] ) -> end ( ) -> scalarNode ( 'core' ) -> isRequired ( ) -> end ( ) -> end ( ) -> end ( ) -> end ( ) -> end ( ) ; }
6581	public function translate ( $ shift , $ y = null , $ z = null ) { if ( $ shift instanceof self ) return new static ( $ this -> gps [ 'x' ] + $ shift -> gps [ 'x' ] , $ this -> gps [ 'y' ] + $ shift -> gps [ 'y' ] , $ this -> gps [ 'z' ] + $ shift -> gps [ 'z' ] ) ; else return new static ( $ this -> gps [ 'x' ] + $ shift , $ this -> gps [ 'y' ] + $ y , $ this -> gps [ 'z' ] + $ z ) ; }
12612	public function getIP ( ) { $ ip = "UNKNOWN" ; if ( getenv ( "HTTP_CLIENT_IP" ) ) { $ ip = getenv ( "HTTP_CLIENT_IP" ) ; } else if ( getenv ( "HTTP_X_FORWARDED_FOR" ) ) { $ ip = getenv ( "HTTP_X_FORWARDED_FOR" ) ; } else if ( getenv ( "REMOTE_ADDR" ) ) { $ ip = getenv ( "REMOTE_ADDR" ) ; } return $ ip ; }
113	private function getInstallPath ( PackageInterface $ package , $ global = false ) { if ( ! $ global ) { return $ this -> composer -> getInstallationManager ( ) -> getInstallPath ( $ package ) ; } return $ this -> globalComposer -> getInstallationManager ( ) -> getInstallPath ( $ package ) ; }
6433	protected function getSerializeVars ( $ skip = array ( ) ) { $ vars = get_object_vars ( $ this ) ; $ servars = array ( ) ; foreach ( $ vars as $ k => $ v ) { if ( in_array ( $ k , $ skip ) ) { continue ; } if ( $ k == 'options' || $ k == 'logger' ) { continue ; } $ servars [ ] = $ k ; } return $ servars ; }
5482	public function setField ( SelectorInterface $ selector , $ value , $ position = false ) { $ success = false ; $ _position = 0 ; for ( $ i = 0 , $ count = count ( $ this -> widgets ) ; $ i < $ count ; $ i ++ ) { if ( $ selector -> isMatch ( $ this -> widgets [ $ i ] ) ) { $ _position ++ ; if ( $ position === false or $ _position === ( int ) $ position ) { if ( $ this -> widgets [ $ i ] -> setValue ( $ value ) ) { $ success = true ; } } } } return $ success ; }
8729	protected function updateFolderName ( HTTPRequest $ request ) { if ( ! $ this -> getCanSelectFolder ( ) ) { return ; } $ folderID = $ request -> requestVar ( "{$this->Name}/folder" ) ; $ path = $ this -> folderPathFromID ( $ folderID ) ; if ( $ path !== false ) { $ this -> setFolderName ( $ path ) ; $ this -> selectField -> setValue ( $ folderID ) ; } }
3731	protected function fetchRows ( $ arrIds , $ arrAttrOnly = array ( ) ) { $ builder = $ this -> getConnection ( ) -> createQueryBuilder ( ) ; $ query = $ builder -> select ( '*' ) -> from ( $ this -> getTableName ( ) ) -> where ( $ builder -> expr ( ) -> in ( 'id' , ':values' ) ) -> setParameter ( 'values' , $ arrIds , Connection :: PARAM_STR_ARRAY ) -> orderBy ( 'FIELD(id, :values)' ) -> execute ( ) ; if ( $ arrAttrOnly ) { $ arrAttrOnly = array_merge ( $ this -> systemColumns , $ arrAttrOnly ) ; } $ result = [ ] ; while ( $ row = $ query -> fetch ( \ PDO :: FETCH_ASSOC ) ) { $ data = [ ] ; foreach ( $ row as $ attribute => $ value ) { if ( ( ! $ arrAttrOnly ) || ( in_array ( $ attribute , $ arrAttrOnly , true ) ) ) { $ data [ $ attribute ] = $ value ; } } $ result [ $ row [ 'id' ] ] = $ data ; } return $ result ; }
10773	public static function with ( array $ theseObjects ) : MapsObjectsByIdentity { $ objects = [ ] ; $ entityIds = [ ] ; foreach ( $ theseObjects as $ id => $ object ) { $ objects = IdentityMap :: addTo ( $ objects , ( string ) $ id , $ object ) ; $ entityIds [ theInstanceIdOf ( $ object ) ] = ( string ) $ id ; } return new self ( $ objects , $ entityIds ) ; }
6949	private function getByCountryAndCustomerQuery ( ) { if ( null === $ this -> byCountryAndCustomerQuery ) { $ qb = $ this -> getBaseQueryBuilder ( ) ; $ this -> byCountryAndCustomerQuery = $ qb -> andWhere ( $ qb -> expr ( ) -> eq ( 'r.customer' , ':customer' ) ) -> getQuery ( ) -> setParameter ( 'customer' , true ) -> setMaxResults ( 1 ) ; } return $ this -> byCountryAndCustomerQuery ; }
4253	public function processLogEntry ( $ method , $ args = array ( ) , $ meta = array ( ) ) { if ( $ method == 'alert' ) { list ( $ method , $ args ) = $ this -> methodAlert ( $ args , $ meta ) ; } elseif ( $ method == 'assert' ) { \ array_unshift ( $ args , false ) ; } elseif ( \ in_array ( $ method , array ( 'count' , 'time' ) ) ) { $ method = 'log' ; } elseif ( \ in_array ( $ method , array ( 'profileEnd' , 'table' ) ) ) { $ method = 'log' ; if ( \ is_array ( $ args [ 0 ] ) ) { $ method = 'table' ; $ args = array ( $ this -> methodTable ( $ args [ 0 ] , $ meta [ 'columns' ] ) ) ; } elseif ( $ meta [ 'caption' ] ) { \ array_unshift ( $ args , $ meta [ 'caption' ] ) ; } } elseif ( $ method == 'trace' ) { $ method = 'table' ; $ args = array ( $ this -> methodTable ( $ args [ 0 ] , array ( 'function' , 'file' , 'line' ) ) ) ; } elseif ( \ in_array ( $ method , array ( 'error' , 'warn' ) ) ) { if ( isset ( $ meta [ 'file' ] ) ) { $ args [ ] = $ meta [ 'file' ] . ': line ' . $ meta [ 'line' ] ; } } if ( ! \ in_array ( $ method , $ this -> consoleMethods ) ) { $ method = 'log' ; } foreach ( $ args as $ k => $ arg ) { $ args [ $ k ] = \ json_encode ( $ this -> dump ( $ arg ) ) ; } $ str = 'console.' . $ method . '(' . \ implode ( ',' , $ args ) . ');' . "\n" ; $ str = \ str_replace ( \ json_encode ( $ this -> debug -> abstracter -> UNDEFINED ) , 'undefined' , $ str ) ; return $ str ; }
2853	public function purgeAllProfiles ( ) { $ table = Mage :: getResourceModel ( 'sheep_debug/requestInfo' ) -> getMainTable ( ) ; $ deleteSql = "DELETE FROM {$table}" ; $ connection = Mage :: getSingleton ( 'core/resource' ) -> getConnection ( 'core_write' ) ; $ result = $ connection -> query ( $ deleteSql ) ; return $ result -> rowCount ( ) ; }
8365	public function createPostTimelineEntry ( EntityPublishedEvent $ event ) : void { $ post = $ event -> getObject ( ) ; if ( ! $ post instanceof Post ) { return ; } $ author = $ this -> user_provider -> loadUserByUsername ( $ post -> getAuthor ( ) ) ; $ post_component = $ this -> action_manager -> findOrCreateComponent ( $ post ) ; $ author_component = $ this -> action_manager -> findOrCreateComponent ( $ author ) ; foreach ( $ post -> getGroups ( ) as $ group ) { $ group_component = $ this -> action_manager -> findOrCreateComponent ( $ group ) ; if ( null === $ post -> getParent ( ) ) { $ verb = 'post' ; } else { $ verb = 'reply' ; } $ action = $ this -> action_manager -> create ( $ author_component , $ verb , [ 'directComplement' => $ post_component , 'indirectComplement' => $ group_component , ] ) ; $ this -> action_manager -> updateAction ( $ action ) ; } }
7618	public function get ( $ name ) { if ( ! isset ( $ this -> accounts [ $ name ] ) ) { throw new \ RuntimeException ( "No account found with " . $ name ) ; } return $ this -> accounts [ $ name ] ; }
8016	public function close ( ) { $ uri = $ this -> current ( ) -> getNextUri ( ) ; if ( ! is_null ( $ uri ) ) { $ this -> client -> deleteAsync ( $ uri ) -> wait ( ) ; } $ this -> closed = true ; }
11525	private function getDom ( $ url ) { $ ch = curl_init ( ) ; $ timeout = 5 ; curl_setopt ( $ ch , CURLOPT_URL , $ url ) ; curl_setopt ( $ ch , CURLOPT_RETURNTRANSFER , 1 ) ; curl_setopt ( $ ch , CURLOPT_CONNECTTIMEOUT , $ timeout ) ; $ dom = curl_exec ( $ ch ) ; curl_close ( $ ch ) ; return $ dom ; }
7049	protected function buildGoodsLines ( Document \ DocumentInterface $ document ) { foreach ( $ document -> getSale ( ) -> getItems ( ) as $ item ) { $ this -> buildGoodLine ( $ item , $ document ) ; } }
7176	public static function extract ( $ array , array $ paths , $ default = null ) { $ found = array ( ) ; foreach ( $ paths as $ path ) { static :: set_path ( $ found , $ path , static :: path ( $ array , $ path , $ default ) ) ; } return $ found ; }
1643	public function getCenter ( ) : Coordinate { $ centerLat = ( $ this -> getNorth ( ) + $ this -> getSouth ( ) ) / 2 ; return new Coordinate ( $ centerLat , $ this -> getCenterLng ( ) ) ; }
11466	public static function writeLogLine ( $ log_file , $ input , $ timestamp = null ) { if ( is_null ( self :: $ _error_folder ) ) { return false ; } $ log_file = basename ( $ log_file ) ; $ fp = @ fopen ( self :: $ _error_folder . $ log_file , 'ab' ) ; if ( ! $ fp ) { return false ; } if ( empty ( $ timestamp ) ) { $ timestamp = time ( ) ; } $ line = [ ] ; $ line [ ] = date ( \ DateTime :: ISO8601 , $ timestamp ) ; if ( $ input instanceof \ Throwable ) { $ message = $ input -> getMessage ( ) ; if ( ! ( $ input instanceof BaseException ) ) { $ message = preg_replace ( '/\s+/' , ' ' , $ message ) ; } $ line [ ] = BaseException :: getShortName ( get_class ( $ input ) ) ; $ line [ ] = $ message ; $ line [ ] = $ input -> getFile ( ) ; $ line [ ] = $ input -> getLine ( ) ; $ line_out = vsprintf ( '[%s] %s: %s in %s on line %d' , $ line ) ; } elseif ( is_string ( $ input ) ) { $ line [ ] = $ input ; $ line_out = vsprintf ( '[%s] %s' , $ line ) ; } else { return false ; } if ( flock ( $ fp , LOCK_EX ) ) { fwrite ( $ fp , $ line_out . PHP_EOL ) ; flock ( $ fp , LOCK_UN ) ; fclose ( $ fp ) ; return true ; } else { return false ; } }
7816	public function event ( string $ event ) : self { $ events = [ 'MESSAGE_RECEIVED' , 'MESSAGE_SENT' , 'MESSAGE_FAILED' , ] ; if ( ! in_array ( $ event , $ events ) ) { abort ( 500 , sprintf ( 'Event %s not available.' , $ event ) ) ; } $ this -> event = $ event ; return $ this ; }
4754	public function startProfiling ( ) { if ( PHP_SAPI == 'cli' ) { $ _SERVER [ 'REMOTE_ADDR' ] = null ; $ _SERVER [ 'REQUEST_URI' ] = $ _SERVER [ 'SCRIPT_NAME' ] ; } if ( function_exists ( 'xhprof_enable' ) && count ( $ this -> probes ) > 0 ) { $ this -> profiling = true ; xhprof_enable ( $ this -> memory ? XHPROF_FLAGS_MEMORY : null ) ; } }
5121	private function sendRequest ( RequestInterface $ request , int $ attempt = 0 ) : \ Psr \ Http \ Message \ StreamInterface { if ( $ attempt >= $ this -> options -> get ( 'max_attempt' ) ) { throw new \ Exception ( 'MAX attempt reached for ' . $ request -> getUri ( ) . ' with payload ' . ( string ) $ request ) ; } try { $ response = $ this -> httpClient -> send ( $ request , [ 'allow_redirects' => false , 'synchronous' => true , 'curl' => [ CURLOPT_FORBID_REUSE => true , CURLOPT_MAXCONNECTS => 30 , CURLOPT_SSL_VERIFYPEER => false , CURLOPT_SSL_VERIFYSTATUS => false , ] , ] ) ; if ( $ response -> getStatusCode ( ) === 200 ) { return $ response -> getBody ( ) ; } return $ this -> sendRequest ( $ request , $ attempt ++ ) ; } catch ( ClientException $ err ) { if ( $ err -> getResponse ( ) -> getStatusCode ( ) === 401 && $ request -> getRequestTarget ( ) !== self :: AUTHENTICATION ) { $ this -> renewAuthToken ( ) ; return $ this -> sendRequest ( $ request , $ attempt ++ ) ; } throw $ err ; } catch ( \ Throwable $ err ) { throw $ err ; } }
5245	private function replace ( string $ pattern , string $ replacement , string $ targetFile ) { $ this -> filesystem -> put ( $ targetFile , preg_replace ( $ pattern , $ replacement , $ this -> filesystem -> get ( $ targetFile ) ) ) ; }
2697	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ activateVcl = $ this -> getRequest ( ) -> getParam ( 'activate_flag' ) ; $ service = $ this -> api -> checkServiceDetails ( ) ; $ enabled = false ; $ this -> vcl -> checkCurrentVersionActive ( $ service -> versions , $ activeVersion ) ; $ currActiveVersion = $ this -> vcl -> getCurrentVersion ( $ service -> versions ) ; $ vclPath = Config :: VCL_AUTH_SNIPPET_PATH ; $ snippets = $ this -> config -> getVclSnippets ( $ vclPath ) ; $ status = true ; foreach ( $ snippets as $ key => $ value ) { $ name = Config :: FASTLY_MAGENTO_MODULE . '_basic_auth_' . $ key ; $ status = $ this -> api -> getSnippet ( $ activeVersion , $ name ) ; if ( ! $ status ) { break ; } } if ( ! $ status ) { $ this -> api -> checkAuthDictionaryPopulation ( $ activeVersion ) ; $ clone = $ this -> api -> cloneVersion ( $ currActiveVersion ) ; foreach ( $ snippets as $ key => $ value ) { $ snippetData = [ 'name' => Config :: FASTLY_MAGENTO_MODULE . '_basic_auth_' . $ key , 'type' => $ key , 'dynamic' => "0" , 'content' => $ value , 'priority' => 10 ] ; $ this -> api -> uploadSnippet ( $ clone -> number , $ snippetData ) ; } $ enabled = true ; } else { $ clone = $ this -> api -> cloneVersion ( $ currActiveVersion ) ; foreach ( $ snippets as $ key => $ value ) { $ name = Config :: FASTLY_MAGENTO_MODULE . '_basic_auth_' . $ key ; $ this -> api -> removeSnippet ( $ clone -> number , $ name ) ; } } $ this -> api -> validateServiceVersion ( $ clone -> number ) ; if ( $ activateVcl === 'true' ) { $ this -> api -> activateVersion ( $ clone -> number ) ; } $ this -> sendWebhook ( $ enabled , $ clone ) ; $ comment = [ 'comment' => 'Magento Module turned ON Basic Authentication' ] ; if ( ! $ enabled ) { $ comment = [ 'comment' => 'Magento Module turned OFF Basic Authentication' ] ; } $ this -> api -> addComment ( $ clone -> number , $ comment ) ; return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
1316	public function post ( $ path , array $ parameters = [ ] , $ json = false ) { return $ this -> http ( 'POST' , self :: API_HOST , $ path , $ parameters , $ json ) ; }
6217	public static function thumbnailToId ( string $ thumbnailUrl ) : string { if ( 1 !== \ preg_match ( '/\/([\d]+)\/([\d]+)(\-avatar\.jpg)$/' , $ thumbnailUrl , $ match ) ) { throw new \ RuntimeException ( \ vsprintf ( 'Invalid thumbnail URL "%s"' , [ $ thumbnailUrl , ] ) ) ; } return ltrim ( $ match [ 1 ] . $ match [ 2 ] , '0' ) ; }
9168	public static function parseUrl ( $ url ) : Endpoint { $ url = UrlParser :: parseUrl ( $ url ) ; return new Endpoint ( $ url -> getAddress ( ) , $ url -> getPort ( ) ) ; }
8434	private function write ( array $ mapping , string $ mappingName , string $ name , array $ up = [ ] , array $ down = [ ] , array $ import = [ ] ) { $ path = rtrim ( $ mapping [ 'config' ] [ 'migrations' ] [ 'path' ] , DIRECTORY_SEPARATOR ) . DIRECTORY_SEPARATOR ; $ path .= $ name . DIRECTORY_SEPARATOR ; if ( file_exists ( $ path . $ name . '.php' ) === true ) { echo 'A migration with this name already exists. Do you want to overwrite it ? [y/n] : ' ; if ( fgetc ( STDIN ) != 'y' ) { return false ; } } if ( is_dir ( $ path ) === false ) { if ( mkdir ( $ path ) === false ) { throw new FileNotWritable ( 'can\'t mkdir "' . $ path . '"' ) ; } } $ path .= $ name . '.php' ; $ file = fopen ( $ path , 'w+' ) ; if ( $ file === false ) { throw new FileNotWritable ( 'can\'t open "' . $ path . '" with write permission' ) ; } $ content = "<?php\n\nnamespace " . ltrim ( rtrim ( $ mapping [ 'config' ] [ 'migrations' ] [ 'namespace' ] , '\\' ) , '\\' ) . '\\' . $ name . ";\n\nuse " . ltrim ( rtrim ( $ mapping [ 'config' ] [ 'provider' ] , '\\' ) , '\\' ) . '\\Migration;' . PHP_EOL ; if ( count ( $ import ) >= 1 ) { $ content .= 'use ' . ltrim ( rtrim ( $ mapping [ 'config' ] [ 'provider' ] , '\\' ) , '\\' ) . '\\Mutation\\{' ; $ content .= implode ( ', ' , $ import ) . "};\n" ; } $ up = implode ( '' , array_map ( function ( string $ a ) { return ' ' . $ a . '->execute();' . PHP_EOL ; } , $ up ) ) ; $ down = implode ( '' , array_map ( function ( string $ a ) { return ' ' . $ a . '->execute();' . PHP_EOL ; } , $ down ) ) ; var_dump ( $ up ) ; $ content .= "\nclass " . $ name . " extends Migration\n{\n" ; $ content .= ' const NAME = \'' . $ name . "';\n\n" ; $ content .= " public function getMappingName() : string\n {\n return '" . $ mappingName . "';\n }\n\n" ; $ content .= " public function up()\n {\n" . $ up . " }\n\n" ; $ content .= " public function down()\n {\n" . $ down . " }\n" ; $ content .= "}" ; if ( fwrite ( $ file , $ content ) === false ) { throw new FileNotWritable ( 'can\'t write in "' . $ path . '"' ) ; } fclose ( $ file ) ; return true ; }
5674	protected function isMatchingKeys ( $ first , $ second , $ identical ) { $ first_keys = array_keys ( $ first ) ; $ second_keys = array_keys ( $ second ) ; if ( $ identical ) { return ( $ first_keys === $ second_keys ) ; } sort ( $ first_keys ) ; sort ( $ second_keys ) ; return ( $ first_keys == $ second_keys ) ; }
12096	public function generateSignCode ( array $ params , $ secret ) { ksort ( $ params ) ; if ( isset ( $ params [ self :: SIGN_NAMESPACE ] ) ) { unset ( $ params [ self :: SIGN_NAMESPACE ] ) ; } return md5 ( implode ( '' , $ params ) . $ secret ) ; }
129	protected function requestContent ( $ origin , $ path ) { $ url = rtrim ( $ origin , '/' ) . '/' . ltrim ( $ path , '/' ) ; $ content = $ this -> rfs -> getContents ( $ origin , $ url , false ) ; if ( ! $ content ) { throw new \ UnexpectedValueException ( 'The PEAR channel at ' . $ url . ' did not respond.' ) ; } return str_replace ( 'http://pear.php.net/rest/' , 'https://pear.php.net/rest/' , $ content ) ; }
7925	public function registerPlugin ( PluginInterface $ plugin ) { $ plugin -> register ( $ this ) ; $ this -> plugins [ ] = $ plugin ; return $ this ; }
1975	public static function findMultipleFilesByFolder ( $ strPath , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ strPath = str_replace ( array ( '\\' , '%' , '_' ) , array ( '\\\\' , '\\%' , '\\_' ) , $ strPath ) ; return static :: findBy ( array ( "$t.type='file' AND $t.path LIKE ? AND $t.path NOT LIKE ?" ) , array ( $ strPath . '/%' , $ strPath . '/%/%' ) , $ arrOptions ) ; }
2025	public static function findPublishedByIdOrAlias ( $ varId , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = ! preg_match ( '/^[1-9]\d*$/' , $ varId ) ? array ( "$t.alias=?" ) : array ( "$t.id=?" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } return static :: findBy ( $ arrColumns , $ varId , $ arrOptions ) ; }
4392	public function checkConfigBE ( array $ attributes ) { return array_merge ( parent :: checkConfigBE ( $ attributes ) , $ this -> checkConfig ( $ this -> beConfig , $ attributes ) ) ; }
6506	public function serializeReturnValue ( $ type , $ value ) { $ jobType = $ this -> registry -> get ( $ type ) ; return $ this -> serializer -> serialize ( $ value , 'json' , $ this -> getResponseSerializationContext ( $ jobType ) ) ; }
3196	public function getConsumedExtraTime ( $ tags = null , $ maxTime = 0 , $ target = TimePoint :: TARGET_SERVER ) { if ( $ maxTime ) { $ totalConsumed = $ this -> compute ( $ tags , $ target ) ; $ consumedExtraTime = $ totalConsumed - $ maxTime < 0 ? 0 : $ totalConsumed - $ maxTime ; $ this -> setConsumedExtraTime ( $ consumedExtraTime ) -> save ( ) ; } return $ this -> consumedExtraTime ; }
8906	public function count_by ( ) { $ where = func_get_args ( ) ; $ this -> _set_where ( $ where ) ; $ this -> apply_soft_delete_filter ( ) ; return $ this -> _database -> count_all_results ( $ this -> _table ) ; }
8010	private static function expand56BitKeyTo64BitKey ( $ string_key , $ set_parity = true ) { $ byte_array_56 = new SplFixedArray ( 7 ) ; $ byte_array_64 = new SplFixedArray ( 8 ) ; $ key_64bit = '' ; for ( $ i = 0 ; $ i < $ byte_array_56 -> getSize ( ) ; $ i ++ ) { $ byte_array_56 [ $ i ] = isset ( $ string_key [ $ i ] ) ? ord ( $ string_key [ $ i ] ) : 0 ; } $ byte_array_64 [ 0 ] = $ byte_array_56 [ 0 ] & 254 ; $ byte_array_64 [ 1 ] = ( $ byte_array_56 [ 0 ] << 7 ) | ( $ byte_array_56 [ 1 ] >> 1 ) ; $ byte_array_64 [ 2 ] = ( $ byte_array_56 [ 1 ] << 6 ) | ( $ byte_array_56 [ 2 ] >> 2 ) ; $ byte_array_64 [ 3 ] = ( $ byte_array_56 [ 2 ] << 5 ) | ( $ byte_array_56 [ 3 ] >> 3 ) ; $ byte_array_64 [ 4 ] = ( $ byte_array_56 [ 3 ] << 4 ) | ( $ byte_array_56 [ 4 ] >> 4 ) ; $ byte_array_64 [ 5 ] = ( $ byte_array_56 [ 4 ] << 3 ) | ( $ byte_array_56 [ 5 ] >> 5 ) ; $ byte_array_64 [ 6 ] = ( $ byte_array_56 [ 5 ] << 2 ) | ( $ byte_array_56 [ 6 ] >> 6 ) ; $ byte_array_64 [ 7 ] = $ byte_array_56 [ 6 ] << 1 ; foreach ( $ byte_array_64 as $ byte_val ) { $ byte_val = $ set_parity ? self :: setParityBit ( $ byte_val ) : $ byte_val ; $ key_64bit .= chr ( $ byte_val ) ; } return $ key_64bit ; }
1288	private function buildContentTypeCollection ( array $ data ) { $ items = \ array_merge ( $ data [ 'items' ] , $ data [ 'includes' ] [ 'Entry' ] ?? [ ] ) ; $ ids = \ array_map ( function ( array $ item ) { return 'Entry' === $ item [ 'sys' ] [ 'type' ] ? $ item [ 'sys' ] [ 'contentType' ] [ 'sys' ] [ 'id' ] : null ; } , $ items ) ; $ ids = \ array_filter ( \ array_unique ( $ ids ) , function ( $ id ) : bool { return $ id && ! $ this -> resourcePool -> has ( 'ContentType' , $ id ) ; } ) ; if ( $ ids ) { $ query = ( new Query ( ) ) -> where ( 'sys.id[in]' , \ implode ( ',' , $ ids ) ) ; $ this -> client -> getContentTypes ( $ query ) ; } }
12167	private function createMenuGroupTable ( ) { $ this -> database -> query ( "DROP TABLE IF EXISTS `?menu_group`;" ) ; $ this -> database -> query ( "CREATE TABLE IF NOT EXISTS `?menu_group` ( `menu_group_id` int(11) NOT NULL AUTO_INCREMENT, `menu_group_title` varchar(45) NOT NULL, `menu_group_order` int(11) NOT NULL DEFAULT '0', `menu_group_uid` varchar(45) NOT NULL, `menu_group_iscore` TINYINT(1) NOT NULL DEFAULT '0', PRIMARY KEY (`menu_group_id`), UNIQUE KEY `menu_group_id_UNIQUE` (`menu_group_id`), UNIQUE KEY `menu_group_uid_UNIQUE` (`menu_group_uid`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 AUTO_INCREMENT=6 ; " ) ; $ this -> database -> query ( "INSERT INTO `?menu_group` (`menu_group_id`, `menu_group_title`, `menu_group_order`, `menu_group_uid`, `menu_group_iscore`) VALUES (1, 'Media Menu', 1, 'mediamenu', 1), (2, 'User Menu', 2, 'usermenu', 1), (3, 'Dashboard Menu', 3, 'dashboardmenu', 1), (4, 'Messages Menu', 4, 'messagesmenu', 1), (5, 'Profile Menu', 5, 'profilemenu', 1), (6, 'People Menu', 6, 'peoplemenu', 1);" ) ; }
11583	public function exchangeArray ( $ array ) { return $ this -> setId ( isset ( $ array [ 'id' ] ) ? $ array [ 'id' ] : null ) -> setAutenticacaoId ( $ array [ 'autenticacao_id' ] ) -> setValor ( $ array [ 'valor' ] ) -> setData ( isset ( $ array [ 'data' ] ) ? $ array [ 'data' ] : null ) ; }
8415	public function beginTransaction ( ) : bool { if ( $ this -> isConnected ( ) === false ) { $ this -> connect ( ) ; } ++ $ this -> transactionLevel ; if ( $ this -> transactionLevel == 1 ) { return $ this -> providerDatabase -> beginTransaction ( $ this -> GetMasterLink ( ) ) ; } return $ this -> providerDatabase -> savePoint ( $ this -> GetMasterLink ( ) , 'LEVEL' . ( $ this -> transactionLevel - 1 ) ) ; }
1837	public static function findOneBy ( $ strColumn , $ varValue , array $ arrOptions = array ( ) ) { $ arrOptions = array_merge ( array ( 'limit' => 1 , 'column' => $ strColumn , 'value' => $ varValue , 'return' => 'Model' ) , $ arrOptions ) ; return static :: find ( $ arrOptions ) ; }
8838	private function getStatus ( ) : array { $ status = proc_get_status ( $ this -> process ) ; if ( ! $ status [ 'running' ] && is_null ( $ this -> exitCode ) ) { $ this -> exitCode = $ status [ 'exitcode' ] ; } return $ status ; }
11185	public function addMatch ( string $ method , string $ uri , $ next ) { $ method = strtoupper ( $ method ) ; if ( ! in_array ( $ method , $ this -> supported_methods ) ) { throw new Exception ( "Method " . $ method . " is not supported." ) ; } if ( ! is_string ( $ uri ) ) { throw new Exception ( "Uri " . $ uri . " is not valid." ) ; } if ( is_callable ( $ next ) ) { $ new_match = array ( $ this -> ARRAY_METHOD_KEY => $ method , $ this -> ARRAY_URI_KEY => $ uri , $ this -> ARRAY_CALLABLE_BOOL_KEY => true , $ this -> ARRAY_CALLABLE_KEY => $ next ) ; } elseif ( is_string ( $ next ) ) { if ( file_exists ( $ next ) ) { $ new_match = array ( $ this -> ARRAY_METHOD_KEY => $ method , $ this -> ARRAY_URI_KEY => $ uri , $ this -> ARRAY_CALLABLE_BOOL_KEY => false , $ this -> ARRAY_FILE_KEY => $ next ) ; } else { $ dir_next = __DIR__ . "/" . $ next ; if ( file_exists ( $ dir_next ) ) { $ new_match = array ( $ this -> ARRAY_METHOD_KEY => $ method , $ this -> ARRAY_URI_KEY => $ uri , $ this -> ARRAY_CALLABLE_BOOL_KEY => false , $ this -> ARRAY_FILE_KEY => $ dir_next ) ; } else { throw new Exception ( "File " . $ next . " not found." ) ; } } } else { throw new Exception ( "Invalid third parameter. Expecting callable or file." ) ; } array_push ( $ this -> match_list , $ new_match ) ; }
2194	protected function activateAcount ( ) { $ this -> strTemplate = 'mod_message' ; $ this -> Template = new FrontendTemplate ( $ this -> strTemplate ) ; $ optIn = System :: getContainer ( ) -> get ( 'contao.opt-in' ) ; if ( ( ! $ optInToken = $ optIn -> find ( Input :: get ( 'token' ) ) ) || ! $ optInToken -> isValid ( ) || \ count ( $ arrRelated = $ optInToken -> getRelatedRecords ( ) ) != 1 || key ( $ arrRelated ) != 'tl_member' || \ count ( $ arrIds = current ( $ arrRelated ) ) != 1 || ( ! $ objMember = MemberModel :: findByPk ( $ arrIds [ 0 ] ) ) ) { $ this -> Template -> type = 'error' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'invalidToken' ] ; return ; } if ( $ optInToken -> isConfirmed ( ) ) { $ this -> Template -> type = 'error' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'tokenConfirmed' ] ; return ; } if ( $ optInToken -> getEmail ( ) != $ objMember -> email ) { $ this -> Template -> type = 'error' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'tokenEmailMismatch' ] ; return ; } $ objMember -> disable = '' ; $ objMember -> save ( ) ; $ optInToken -> confirm ( ) ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'activateAccount' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'activateAccount' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'activateAccount' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ objMember , $ this ) ; } } $ this -> log ( 'User account ID ' . $ objMember -> id . ' (' . Idna :: decodeEmail ( $ objMember -> email ) . ') has been activated' , __METHOD__ , TL_ACCESS ) ; if ( ( $ objTarget = $ this -> objModel -> getRelated ( 'reg_jumpTo' ) ) instanceof PageModel ) { $ this -> redirect ( $ objTarget -> getFrontendUrl ( ) ) ; } $ this -> Template -> type = 'confirm' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'accountActivated' ] ; }
4244	private function buildErrorList ( ) { $ errorStr = '' ; $ errors = $ this -> debug -> errorHandler -> get ( 'errors' ) ; \ uasort ( $ errors , function ( $ a1 , $ a2 ) { return \ strcmp ( $ a1 [ 'file' ] . $ a1 [ 'line' ] , $ a2 [ 'file' ] . $ a2 [ 'line' ] ) ; } ) ; $ lastFile = '' ; foreach ( $ errors as $ error ) { if ( $ error [ 'isSuppressed' ] ) { continue ; } if ( $ error [ 'file' ] !== $ lastFile ) { $ errorStr .= $ error [ 'file' ] . ':' . "\n" ; $ lastFile = $ error [ 'file' ] ; } $ typeStr = $ error [ 'type' ] === E_STRICT ? 'Strict' : $ error [ 'typeStr' ] ; $ errorStr .= ' Line ' . $ error [ 'line' ] . ': (' . $ typeStr . ') ' . $ error [ 'message' ] . "\n" ; } return $ errorStr ; }
7893	public function add ( $ property_name , $ value ) { $ this -> validateProperty ( $ property_name , $ value ) ; $ this -> data [ $ property_name ] [ ] = & $ value ; return $ this ; }
7836	protected function deleteAllFilesOfWorkflowIfForced ( $ workflow ) { $ files = $ this -> pipelines -> getPipesByPipeline ( $ workflow ) ; $ files [ ] = $ this -> inflector -> getRequest ( ) ; $ files [ ] = $ this -> inflector -> getJob ( ) ; $ this -> deleteIfForced ( $ files ) ; }
5147	protected function getOpenedEmail ( $ fetchNextUnread = FALSE ) { if ( $ fetchNextUnread || $ this -> openedEmail == NULL ) { $ this -> openNextUnreadEmail ( ) ; } return $ this -> openedEmail ; }
5283	public function insert ( $ data , $ format = null ) { global $ wpdb ; $ wpdb -> insert ( $ this -> table , $ data , $ format ) ; return $ wpdb -> insert_id ; }
9941	public function setTitle ( $ pValue , $ updateFormulaCellReferences = true , $ validate = true ) { if ( $ this -> getTitle ( ) == $ pValue ) { return $ this ; } $ oldTitle = $ this -> getTitle ( ) ; if ( $ validate ) { self :: checkSheetTitle ( $ pValue ) ; if ( $ this -> parent ) { if ( $ this -> parent -> sheetNameExists ( $ pValue ) ) { if ( Shared \ StringHelper :: countCharacters ( $ pValue ) > 29 ) { $ pValue = Shared \ StringHelper :: substring ( $ pValue , 0 , 29 ) ; } $ i = 1 ; while ( $ this -> parent -> sheetNameExists ( $ pValue . ' ' . $ i ) ) { ++ $ i ; if ( $ i == 10 ) { if ( Shared \ StringHelper :: countCharacters ( $ pValue ) > 28 ) { $ pValue = Shared \ StringHelper :: substring ( $ pValue , 0 , 28 ) ; } } elseif ( $ i == 100 ) { if ( Shared \ StringHelper :: countCharacters ( $ pValue ) > 27 ) { $ pValue = Shared \ StringHelper :: substring ( $ pValue , 0 , 27 ) ; } } } $ pValue .= " $i" ; } } } $ this -> title = $ pValue ; $ this -> dirty = true ; if ( $ this -> parent && $ this -> parent -> getCalculationEngine ( ) ) { $ newTitle = $ this -> getTitle ( ) ; $ this -> parent -> getCalculationEngine ( ) -> renameCalculationCacheForWorksheet ( $ oldTitle , $ newTitle ) ; if ( $ updateFormulaCellReferences ) { ReferenceHelper :: getInstance ( ) -> updateNamedFormulas ( $ this -> parent , $ oldTitle , $ newTitle ) ; } } return $ this ; }
11783	public function add ( $ title , $ description , $ pageUrl , $ iconUrl , $ comment = '' ) { $ params = [ 'title' => $ title , 'description' => $ description , 'page_url' => $ pageUrl , 'icon_url' => $ iconUrl , ] ; if ( $ comment !== '' ) { $ params [ 'comment' ] = $ comment ; } return $ this -> parseJSON ( 'json' , [ self :: API_ADD , $ params ] ) ; }
5326	public function begin ( string $ profile ) { Craft :: beginProfile ( $ profile , Craft :: t ( 'twig-profiler' , self :: CATEGORY_PREFIX ) . TwigProfiler :: $ renderingTemplate ) ; }
8685	public static function set ( & $ data , $ path , $ value ) { Assert :: isArrayAccessible ( $ data ) ; Assert :: stringNotEmpty ( $ path ) ; $ queue = explode ( '/' , $ path ) ; if ( count ( $ queue ) === 1 ) { if ( $ path === '[]' ) { $ data [ ] = $ value ; } elseif ( static :: $ unsetMarker && $ value === static :: $ unsetMarker ) { unset ( $ data [ $ path ] ) ; } else { $ data [ $ path ] = $ value ; } return ; } $ invalidKey = null ; $ current = & $ data ; while ( ( $ key = array_shift ( $ queue ) ) !== null ) { if ( ! is_array ( $ current ) && ! ( $ current instanceof ArrayAccess ) ) { throw new RuntimeException ( sprintf ( "Cannot set '%s', because '%s' is already set and not an array or an object implementing ArrayAccess." , $ path , $ invalidKey ) ) ; } if ( ! $ queue ) { if ( $ key === '[]' ) { $ current [ ] = $ value ; } elseif ( static :: $ unsetMarker && $ value === static :: $ unsetMarker ) { unset ( $ current [ $ key ] ) ; } else { $ current [ $ key ] = $ value ; } return ; } if ( $ current instanceof Bag && ! ( $ current instanceof MutableBag ) ) { Deprecated :: warn ( 'Mutating items in a ' . Bag :: class , 1.1 , 'Use a ' . MutableBag :: class . ' instead.' ) ; } if ( ! isset ( $ current [ $ key ] ) ) { $ current [ $ key ] = [ ] ; } $ next = null ; if ( $ current instanceof ArrayAccess && ! static :: canReturnArraysByReference ( $ current , $ key , $ next , $ e ) ) { throw new RuntimeException ( sprintf ( "Cannot set '%s', because '%s' is an %s which does not return arrays by reference from its offsetGet() method. See %s for an example of how to do this." , $ path , $ invalidKey , get_class ( $ current ) , MutableBag :: class ) , 0 , $ e ) ; } if ( $ next !== null ) { $ current = & $ next ; unset ( $ next ) ; } else { $ current = & $ current [ $ key ] ; } $ invalidKey = $ key ; } }
12184	public static function getById ( $ relationshipId ) { $ key = md5 ( $ relationshipId ) ; if ( isset ( self :: $ _relationships [ $ key ] ) ) { return self :: $ _relationships [ $ key ] ; } return false ; }
2093	protected function validator ( $ varInput ) { $ this -> blnSubmitInput = false ; if ( ! \ strlen ( $ varInput ) && ( \ strlen ( $ this -> varValue ) || ! $ this -> mandatory ) ) { return '' ; } $ intLength = $ this -> minlength ? : Config :: get ( 'minPasswordLength' ) ; if ( Utf8 :: strlen ( $ varInput ) < $ intLength ) { $ this -> addError ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'passwordLength' ] , $ intLength ) ) ; } if ( $ varInput != $ this -> getPost ( $ this -> strName . '_confirm' ) ) { $ this -> addError ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'passwordMatch' ] ) ; } $ varInput = parent :: validator ( $ varInput ) ; if ( ! $ this -> hasErrors ( ) ) { $ this -> blnSubmitInput = true ; return password_hash ( $ varInput , PASSWORD_DEFAULT ) ; } return '' ; }
4147	protected function getResponse ( ) { $ url = $ this -> getUrl ( ) ; $ params = array ( 'get' => $ this -> getParams , 'post' => $ this -> postParams , 'headers' => $ this -> buildRequestHeader ( ) , ) ; return $ this -> curl -> send ( $ url , $ params ) ; }
4371	public function markupClassname ( $ str , $ tagName = 'span' , $ attribs = array ( ) ) { if ( \ preg_match ( '/^(.+)(::|->)(.+)$/' , $ str , $ matches ) ) { $ classname = $ matches [ 1 ] ; $ opMethod = '<span class="t_operator">' . \ htmlspecialchars ( $ matches [ 2 ] ) . '</span>' . '<span class="method-name">' . $ matches [ 3 ] . '</span>' ; } else { $ classname = $ str ; $ opMethod = '' ; } $ idx = \ strrpos ( $ classname , '\\' ) ; if ( $ idx ) { $ classname = '<span class="namespace">' . \ substr ( $ classname , 0 , $ idx + 1 ) . '</span>' . \ substr ( $ classname , $ idx + 1 ) ; } $ attribs = \ array_merge ( array ( 'class' => 't_classname' , ) , $ attribs ) ; return $ this -> debug -> utilities -> buildTag ( $ tagName , $ attribs , $ classname ) . $ opMethod ; }
10389	public static function loadFile ( $ xmlFile ) { if ( ! is_file ( $ xmlFile ) || ! is_readable ( $ xmlFile ) ) { throw new NoSuchFileException ( $ xmlFile ) ; } return self :: parseXml ( $ xmlFile ) ; }
6820	protected function writeInvoiceTaxesLine ( ) { $ sale = $ this -> invoice -> getSale ( ) ; $ date = $ sale -> getCreatedAt ( ) ; $ credit = $ this -> invoice -> getType ( ) === InvoiceTypes :: TYPE_CREDIT ; foreach ( $ this -> invoice -> getTaxesDetails ( ) as $ detail ) { $ amount = $ this -> round ( $ detail [ 'amount' ] ) ; if ( 0 === $ this -> compare ( $ amount , 0 ) ) { continue ; } $ account = $ this -> getTaxAccountNumber ( $ detail [ 'rate' ] , $ this -> invoice -> getNumber ( ) ) ; if ( $ credit ) { $ this -> writer -> credit ( $ account , ( string ) $ amount , $ date ) ; $ this -> balance -= $ amount ; } else { $ this -> writer -> debit ( $ account , ( string ) $ amount , $ date ) ; $ this -> balance += $ amount ; } } }
9208	protected function truncateTable ( $ Table ) { $ truncateSql = $ Table -> schema ( ) -> truncateSql ( $ Table -> connection ( ) ) [ 0 ] ; $ success = $ Table -> connection ( ) -> query ( $ truncateSql ) ; if ( $ success ) { $ this -> verbose ( "<success>{$Table->alias()}: Existing DB records truncated.</success>" ) ; } else { $ this -> quiet ( "<warning>{$Table->alias()}: Can not truncate existing records.</warning>" ) ; } return $ success ; }
10611	public function confirmAction ( $ token ) { $ user = $ this -> get ( 'fos_user.user_manager' ) -> findUserByConfirmationToken ( $ token ) ; if ( null === $ user ) { throw new NotFoundHttpException ( sprintf ( 'The user with confirmation token "%s" does not exist' , $ token ) ) ; } $ user -> setConfirmationToken ( null ) ; $ user -> setEnabled ( true ) ; $ user -> setLastLogin ( new \ DateTime ( ) ) ; $ this -> get ( 'fos_user.user_manager' ) -> updateUser ( $ user ) ; $ response = $ this -> redirect ( $ this -> generateUrl ( 'miky_app_customer_registration_confirmed' ) ) ; $ this -> authenticateUser ( $ user , $ response ) ; return $ response ; }
10690	public static function handleException ( \ Throwable $ e ) { $ app = self :: getInstance ( ) ; if ( $ app -> request === null ) $ app -> request = Request :: createFromGlobals ( ) ; $ req = $ app -> request ; try { if ( ! Request :: cli ( ) ) { $ mgr = $ app -> resolver ; $ res = $ mgr -> getResolver ( 'template' ) ; $ assets = $ mgr -> getResolver ( 'assets' ) ; $ amgr = new AssetManager ( $ assets ) ; $ tpl = new Template ( $ res , $ amgr , $ req ) ; $ tpl -> setExceptionTemplate ( $ e ) ; $ tpl -> assign ( 'exception' , $ e ) ; $ tpl -> assign ( 'request' , $ req ) ; $ tpl -> assign ( 'dev' , $ app -> dev ) ; $ app -> i18n ; $ response = $ tpl -> renderReturn ( ) ; $ responder = new \ Wedeto \ HTTP \ Responder ( ) ; $ result = new \ Wedeto \ HTTP \ Result ( ) ; $ result -> setResponse ( $ response ) ; $ responder -> setRequest ( $ req ) ; $ responder -> setResult ( $ result ) ; $ params = new Dictionary ( [ 'responder' => $ responder , 'mime' => 'text/html' ] ) ; $ amgr -> executeHook ( $ params ) ; $ responder -> respond ( ) ; } } catch ( \ Throwable $ e2 ) { echo "<h1>Error while showing error template:</h1>\n\n" ; echo "<pre>" . WF :: html ( $ e2 ) . "</pre>\n" ; } if ( Request :: cli ( ) ) { fprintf ( STDERR , \ Wedeto \ Application \ CLI \ ANSI :: bright ( "An uncaught exception has occurred:" ) . "\n\n" ) ; WF :: debug ( WF :: str ( $ e ) ) ; } else { echo "<h2>Original error:</h2>\n\n" ; echo "<pre>" . WF :: html ( $ e ) . "</pre>\n" ; } }
338	protected function extractColumnSize ( $ column , $ dbType , $ precision , $ scale , $ length ) { $ column -> size = trim ( $ length ) === '' ? null : ( int ) $ length ; $ column -> precision = trim ( $ precision ) === '' ? null : ( int ) $ precision ; $ column -> scale = trim ( $ scale ) === '' ? null : ( int ) $ scale ; }
1268	private function createRequest ( ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; $ avRequest = $ xml -> appendChild ( $ xml -> createElement ( 'AddressValidationRequest' ) ) ; $ avRequest -> setAttribute ( 'xml:lang' , 'en-US' ) ; $ request = $ avRequest -> appendChild ( $ xml -> createElement ( 'Request' ) ) ; $ node = $ xml -> importNode ( $ this -> createTransactionNode ( ) , true ) ; $ request -> appendChild ( $ node ) ; $ request -> appendChild ( $ xml -> createElement ( 'RequestAction' , 'AV' ) ) ; if ( null !== $ this -> address ) { $ addressNode = $ avRequest -> appendChild ( $ xml -> createElement ( 'Address' ) ) ; if ( $ this -> address -> getStateProvinceCode ( ) ) { $ addressNode -> appendChild ( $ xml -> createElement ( 'StateProvinceCode' , $ this -> address -> getStateProvinceCode ( ) ) ) ; } if ( $ this -> address -> getCity ( ) ) { $ addressNode -> appendChild ( $ xml -> createElement ( 'City' , $ this -> address -> getCity ( ) ) ) ; } if ( $ this -> address -> getCountryCode ( ) ) { $ addressNode -> appendChild ( $ xml -> createElement ( 'CountryCode' , $ this -> address -> getCountryCode ( ) ) ) ; } if ( $ this -> address -> getPostalCode ( ) ) { $ addressNode -> appendChild ( $ xml -> createElement ( 'PostalCode' , $ this -> address -> getPostalCode ( ) ) ) ; } } return $ xml -> saveXML ( ) ; }
10626	public static function docroot ( ) { if ( ! empty ( $ _SERVER [ 'DOCUMENT_ROOT' ] ) ) { $ docroot = str_replace ( '\\' , '/' , $ _SERVER [ 'DOCUMENT_ROOT' ] ) ; } else { $ docroot = str_replace ( '\\' , '/' , dirname ( __FILE__ ) ) ; } return $ docroot ; }
2772	public function init ( array $ options = [ ] ) : string { $ argsAndOptions = [ $ this -> directory , $ options ] ; return $ this -> run ( 'init' , $ argsAndOptions , false ) ; }
10706	public function getUserAddForm ( ) { if ( null === $ this -> userAddForm ) { $ this -> userAddForm = $ this -> getServiceLocator ( ) -> get ( 'user.form.useradd' ) ; } return $ this -> userAddForm ; }
161	public function orHaving ( $ condition , $ params = [ ] ) { if ( $ this -> having === null ) { $ this -> having = $ condition ; } else { $ this -> having = [ 'or' , $ this -> having , $ condition ] ; } $ this -> addParams ( $ params ) ; return $ this ; }
2349	public function renameTo ( $ strNewName ) { $ strParent = \ dirname ( $ strNewName ) ; if ( ! is_dir ( $ this -> strRootDir . '/' . $ strParent ) ) { new Folder ( $ strParent ) ; } $ return = $ this -> Files -> rename ( $ this -> strFile , $ strNewName ) ; $ syncSource = Dbafs :: shouldBeSynchronized ( $ this -> strFile ) ; $ syncTarget = Dbafs :: shouldBeSynchronized ( $ strNewName ) ; if ( $ syncSource && $ syncTarget ) { $ this -> objModel = Dbafs :: moveResource ( $ this -> strFile , $ strNewName ) ; } elseif ( $ syncSource ) { $ this -> objModel = Dbafs :: deleteResource ( $ this -> strFile ) ; } elseif ( $ syncTarget ) { $ this -> objModel = Dbafs :: addResource ( $ strNewName ) ; } if ( $ return != false ) { $ this -> strFile = $ strNewName ; $ this -> arrImageSize = array ( ) ; $ this -> arrPathinfo = array ( ) ; } return $ return ; }
6297	protected function registerNavigation ( ) { $ this -> app -> singleton ( 'navigation' , function ( $ app ) { $ request = $ app [ 'request' ] ; $ events = $ app [ 'events' ] ; $ url = $ app [ 'url' ] ; $ view = $ app [ 'view' ] ; $ name = 'navigation::bootstrap' ; $ navigation = new Navigation ( $ request , $ events , $ url , $ view , $ name ) ; $ app -> refresh ( 'request' , $ navigation , 'setRequest' ) ; return $ navigation ; } ) ; $ this -> app -> alias ( 'navigation' , Navigation :: class ) ; }
7706	function _ApplyDiffFromStart ( $ Diff ) { $ this -> pST_PosEnd += $ Diff ; $ this -> pST_Src = false ; if ( $ this -> pET_PosBeg !== false ) $ this -> pET_PosBeg += $ Diff ; $ this -> PosEnd += $ Diff ; }
10129	private function writeProtect ( ) { if ( ! $ this -> phpSheet -> getProtection ( ) -> getSheet ( ) ) { return ; } $ record = 0x0012 ; $ length = 0x0002 ; $ fLock = 1 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ fLock ) ; $ this -> append ( $ header . $ data ) ; }
3379	protected function getDefaultNamespace ( $ rootNamespace ) { $ controllersPath = \ Config :: get ( 'panel.controllers' ) ; if ( isset ( $ controllersPath ) && $ controllersPath != NULL ) { return $ controllersPath ; } else { return $ rootNamespace . '\Http\Controllers' ; } }
3374	protected function getFilename ( $ filename ) { $ callback = $ this -> fileCallback ; if ( null === $ callback || substr ( $ filename , 0 , 1 ) == '/' ) { return $ filename ; } return $ callback ( $ filename ) ; }
1685	public function checkAdminDisable ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ varValue == 1 && $ this -> User -> id == $ dc -> id ) { $ varValue = '' ; } return $ varValue ; }
4714	public function replaceString ( $ search , $ replace ) { $ this -> text = str_replace ( $ search , $ replace , $ this -> text ) ; return $ this ; }
11186	public function setPrivateChatUpdateRead ( Neuron_GameServer_Player $ from , Neuron_GameServer_Player $ target ) { $ db = Neuron_DB_Database :: getInstance ( ) ; $ db -> query ( " UPDATE n_privatechat_updates SET pu_read = '1' WHERE pu_to = {$target->getId ()} AND pu_from = {$from->getId ()} " ) ; }
7774	protected function canSkipRule ( $ ruleToCall , $ value ) { return ( ( is_array ( $ ruleToCall ) && method_exists ( $ ruleToCall [ 0 ] , 'canSkip' ) && $ ruleToCall [ 0 ] -> canSkip ( ) ) || empty ( $ value ) && ! is_array ( $ value ) ) ; }
12178	public function getIndividual ( ) { if ( ! isset ( $ this -> _individual ) && ! empty ( $ this -> object_individual_id ) ) { $ this -> _individual = false ; $ individualType = Yii :: $ app -> collectors [ 'types' ] -> getOne ( 'Individual' ) ; if ( ! empty ( $ individualType -> object ) ) { $ individualClass = $ individualType -> object -> primaryModel ; $ this -> _individual = $ individualClass :: get ( $ this -> object_individual_id ) ; } } return $ this -> _individual ; }
10258	public function getCompanyName ( $ base_name = null ) { $ suffixes = [ 'Corporation' , 'Company' , 'Company, Limited' , 'Computer Repair' , 'Incorporated' , 'and Sons' , 'Group' , 'Group, PLC' , 'Furniture' , 'Flowers' , 'Sales' , 'Systems' , 'Tire' , 'Auto' , 'Plumbing' , 'Roofing' , 'Realty' , 'Foods' , 'Books' ] ; if ( empty ( $ base_name ) ) { $ base_name = $ this -> getLastName ( ) ; } return $ base_name . ' ' . $ this -> fromArray ( $ suffixes ) ; }
6530	public static function findAllUsingMixin ( $ mixin ) : array { if ( $ mixin instanceof Mixin ) { $ key = $ mixin -> getId ( ) -> getCurieMajor ( ) ; } else { $ key = $ mixin ; } if ( ! isset ( self :: $ resolvedMixins [ $ key ] ) ) { $ schemas = [ ] ; foreach ( ( self :: $ mixins [ $ key ] ?? [ ] ) as $ id ) { $ schemas [ ] = self :: $ classes [ $ id ] :: schema ( ) ; } self :: $ resolvedMixins [ $ key ] = $ schemas ; } if ( empty ( self :: $ resolvedMixins [ $ key ] ) ) { throw new NoMessageForMixin ( $ mixin ) ; } return self :: $ resolvedMixins [ $ key ] ; }
2119	public function getFromDca ( ) { $ return = array ( ) ; $ processed = array ( ) ; $ files = System :: getContainer ( ) -> get ( 'contao.resource_finder' ) -> findIn ( 'dca' ) -> depth ( 0 ) -> files ( ) -> name ( '*.php' ) ; foreach ( $ files as $ file ) { if ( \ in_array ( $ file -> getBasename ( ) , $ processed ) ) { continue ; } $ processed [ ] = $ file -> getBasename ( ) ; $ strTable = $ file -> getBasename ( '.php' ) ; $ objExtract = DcaExtractor :: getInstance ( $ strTable ) ; if ( $ objExtract -> isDbTable ( ) ) { $ return [ $ strTable ] = $ objExtract -> getDbInstallerArray ( ) ; } } ksort ( $ return ) ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'sqlGetFromDca' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'sqlGetFromDca' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'sqlGetFromDca' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ return = $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ return ) ; } } return $ return ; }
6270	private function matchesAcademicDomain ( $ domain ) { if ( empty ( $ domain [ 'tld' ] ) or empty ( $ domain [ 'sld' ] ) ) { return false ; } return file_exists ( $ this -> getPath ( $ domain ) ) ; }
2123	public function addMultiple ( array $ arrFiles , $ strVersion = null , $ strMedia = 'screen' ) { foreach ( $ arrFiles as $ strFile ) { $ this -> add ( $ strFile , $ strVersion , $ strMedia ) ; } }
12656	public function modifyTextContainer ( $ oldName , $ newName , $ content , $ language ) { foreach ( $ this -> languages as $ lang ) { $ modified = false ; $ allTexts = $ this -> getPageTexts ( $ lang ) ; if ( ! isset ( $ allTexts [ $ oldName ] ) ) { throw new \ Exception ( "Text container unknown." ) ; } if ( $ oldName !== $ newName ) { if ( isset ( $ allTexts [ $ newName ] ) ) { throw new \ Exception ( "Text container already exists" ) ; } $ this -> contents [ $ lang ] [ $ newName ] = $ this -> contents [ $ lang ] [ $ oldName ] ; $ this -> contents [ $ lang ] [ $ newName ] [ 'id' ] = $ newName ; $ this -> contents [ $ lang ] [ $ newName ] [ 'name' ] = $ newName ; unset ( $ this -> contents [ $ lang ] [ $ oldName ] ) ; $ modified = true ; } if ( $ language === $ lang ) { $ this -> contents [ $ lang ] [ $ newName ] [ 'content' ] = $ content ; $ this -> contents [ $ lang ] [ $ newName ] [ 'outdated' ] = false ; $ modified = true ; } elseif ( $ language === $ this -> baseLang ) { $ this -> contents [ $ lang ] [ $ newName ] [ 'outdated' ] = true ; $ modified = true ; } if ( $ modified ) { $ this -> writeTextsToFile ( $ lang ) ; } } return $ this -> contents [ $ language ] [ $ newName ] ; }
2341	protected function getUsername ( ) { if ( $ this -> strUsername !== null ) { return $ this -> strUsername ; } $ this -> import ( BackendUser :: class , 'User' ) ; return $ this -> User -> username ; }
8324	public function getPingbacks ( ) { $ response = $ this -> getHttpClient ( ) -> request ( 'GET' , "/res.php?key={$this->apiKey}&action=get_pingback" ) ; $ responseText = $ response -> getBody ( ) -> __toString ( ) ; if ( strpos ( $ responseText , 'OK|' ) !== false ) { $ data = explode ( '|' , $ responseText ) ; unset ( $ data [ 0 ] ) ; return empty ( $ data [ 1 ] ) ? [ ] : array_values ( $ data ) ; } throw new ErrorResponseException ( $ this -> getErrorMessage ( $ responseText ) ? : $ responseText , $ this -> getErrorCode ( $ responseText ) ? : 0 ) ; }
10785	public function runQuery ( \ Peyote \ Query $ query ) { return $ this -> run ( $ query -> compile ( ) , $ query -> getParams ( ) ) ; }
3183	private function durationToMs ( $ duration ) { if ( ! is_null ( $ duration ) && $ duration instanceof QtiDuration ) { return TestRunnerUtils :: getDurationWithMicroseconds ( $ duration ) ; } return false ; }
4276	public function stream_metadata ( $ path , $ option , $ value ) { self :: restorePrev ( ) ; switch ( $ option ) { case STREAM_META_TOUCH : if ( ! empty ( $ value ) ) { $ success = \ touch ( $ path , $ value [ 0 ] , $ value [ 1 ] ) ; } else { $ success = \ touch ( $ path ) ; } break ; case STREAM_META_OWNER_NAME : case STREAM_META_OWNER : $ success = \ chown ( $ path , $ value ) ; break ; case STREAM_META_GROUP_NAME : case STREAM_META_GROUP : $ success = \ chgrp ( $ path , $ value ) ; break ; case STREAM_META_ACCESS : $ success = \ chmod ( $ path , $ value ) ; break ; default : $ success = false ; } self :: register ( ) ; return $ success ; }
10847	protected function runCommand ( $ command , $ basePath , $ asset , $ result ) { $ command = Yii :: getAlias ( $ command ) ; $ command = strtr ( $ command , [ '{from}' => escapeshellarg ( "$basePath/$asset" ) , '{to}' => escapeshellarg ( "$basePath/$result" ) , ] ) ; $ descriptor = [ 1 => [ 'pipe' , 'w' ] , 2 => [ 'pipe' , 'w' ] , ] ; $ pipes = [ ] ; $ proc = proc_open ( $ command , $ descriptor , $ pipes , $ basePath ) ; $ stdout = stream_get_contents ( $ pipes [ 1 ] ) ; $ stderr = stream_get_contents ( $ pipes [ 2 ] ) ; foreach ( $ pipes as $ pipe ) { fclose ( $ pipe ) ; } $ status = proc_close ( $ proc ) ; if ( $ status === 0 ) { Yii :: trace ( "Converted $asset into $result:\nSTDOUT:\n$stdout\nSTDERR:\n$stderr" , __METHOD__ ) ; } elseif ( YII_DEBUG ) { throw new Exception ( "AssetConverter command '$command' failed with exit code $status:\nSTDOUT:\n$stdout\nSTDERR:\n$stderr" ) ; } else { Yii :: error ( "AssetConverter command '$command' failed with exit code $status:\nSTDOUT:\n$stdout\nSTDERR:\n$stderr" , __METHOD__ ) ; } return $ status === 0 ; }
10374	public static function remove ( $ type , $ name ) { if ( isset ( self :: $ data [ $ type ] [ $ name ] ) ) { unset ( self :: $ data [ $ type ] [ $ name ] ) ; } return true ; }
1629	public function getMonolog ( ) { foreach ( $ this -> loggers as $ logger ) { if ( is_callable ( [ $ logger , 'getMonolog' ] ) ) { $ monolog = $ logger -> getMonolog ( ) ; if ( $ monolog === null ) { continue ; } return $ monolog ; } } }
642	public function createIndex ( $ name , $ table , $ columns , $ unique = false ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> createIndex ( $ name , $ table , $ columns , $ unique ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; }
2653	public function updateSnippet ( array $ snippet ) { $ url = $ this -> _getApiServiceUri ( ) . 'snippet' . '/' . $ snippet [ 'name' ] ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: PUT , $ snippet ) ; return $ result ; }
6371	public static function add ( $ classname , $ columns = array ( ) , $ title = null ) { if ( $ title ) { Deprecation :: notice ( 1.1 , "Title is no longer used, instead set ClassName.PluralName in translations" ) ; } self :: config ( ) -> objects [ $ classname ] = $ columns ; $ cols_string = '"' . implode ( '","' , $ columns ) . '"' ; }
2900	public function initFromAction ( $ action ) { if ( ! $ action ) { return ; } $ request = $ action -> getRequest ( ) ; $ this -> httpMethod = $ request -> getMethod ( ) ; $ this -> requestOriginalPath = $ request -> getOriginalPathInfo ( ) ; $ this -> requestPath = $ request -> getPathInfo ( ) ; $ this -> remoteIp = Mage :: helper ( 'core/http' ) -> getRemoteAddr ( ) ; $ this -> routeName = $ request -> getRouteName ( ) ; $ this -> module = $ request -> getControllerModule ( ) ; $ this -> class = get_class ( $ action ) ; $ this -> action = $ action -> getActionMethodName ( $ request -> getActionName ( ) ) ; }
385	public function getOrders ( $ recalculate = false ) { $ attributeOrders = $ this -> getAttributeOrders ( $ recalculate ) ; $ orders = [ ] ; foreach ( $ attributeOrders as $ attribute => $ direction ) { $ definition = $ this -> attributes [ $ attribute ] ; $ columns = $ definition [ $ direction === SORT_ASC ? 'asc' : 'desc' ] ; if ( is_array ( $ columns ) || $ columns instanceof \ Traversable ) { foreach ( $ columns as $ name => $ dir ) { $ orders [ $ name ] = $ dir ; } } else { $ orders [ ] = $ columns ; } } return $ orders ; }
12006	final public function getAuthorityTree ( ) { $ database = $ this -> database ; $ statement = $ database -> select ( ) -> from ( '?authority' ) -> between ( "lft" , '1' , '6' ) -> prepare ( ) ; $ results = $ statement -> execute ( ) ; $ right = array ( ) ; }
8896	public function get_many_by ( ) { $ where = func_get_args ( ) ; $ this -> apply_soft_delete_filter ( ) ; $ this -> _set_where ( $ where ) ; return $ this -> get_all ( ) ; }
11348	public function getField ( $ name ) { foreach ( $ this -> fields as $ field ) { if ( $ field -> getName ( ) == $ name ) return $ field ; } throw new FieldNotFoundException ( $ name ) ; }
10825	public static function choice ( $ question , array $ choices , $ defaultValue = null ) { $ value = '' ; while ( trim ( $ value ) == '' ) { self :: writeln ( '' ) ; self :: write ( ' ' . $ question , 'info' ) ; if ( $ defaultValue !== null ) { self :: write ( ' [' ) ; self :: write ( ( string ) $ defaultValue , 'comment' ) ; self :: write ( ']' ) ; } self :: writeln ( ':' ) ; if ( count ( $ choices ) > 0 ) { foreach ( $ choices as $ index => $ choice ) { self :: write ( ' [' ) ; self :: write ( ( string ) ( $ index + 1 ) , 'comment' ) ; self :: writeln ( '] ' . $ choice ) ; } } if ( self :: $ testValue === null ) { $ value = readline ( ' > ' ) ; } else { $ value = self :: $ testValue ; } if ( trim ( $ value ) == '' ) { $ value = $ defaultValue ; } if ( ! isset ( $ choices [ intval ( $ value ) - 1 ] ) ) { self :: writeln ( '' ) ; self :: block ( '[ERROR] Value "' . $ value . '" is invalid' , 'error' ) ; $ value = '' ; } elseif ( trim ( $ value ) == '' ) { self :: writeln ( '' ) ; self :: block ( '[ERROR] A value is required' , 'error' ) ; } self :: writeln ( '' ) ; } return trim ( $ value ) ; }
3336	public function getIntegrationData ( ) { $ integrationData = '' ; $ framework = $ this -> api -> getFramework ( ) ; if ( $ framework ) { $ integrationData .= $ framework ; } $ extension = $ this -> api -> getExtension ( ) ; if ( $ extension ) { $ integrationData .= '; ' . $ extension ; } return $ integrationData ; }
648	public function addCommentOnTable ( $ table , $ comment ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> addCommentOnTable ( $ table , $ comment ) ; return $ this -> setSql ( $ sql ) ; }
2492	protected function defineEndpoint ( ContainerBuilder $ container , $ alias , $ params ) { $ definition = new Definition ( self :: ENDPOINT_CLASS , array ( $ params ) ) ; $ definition -> addTag ( self :: ENDPOINT_TAG , array ( 'alias' => $ alias ) ) ; $ container -> setDefinition ( sprintf ( $ this -> getAlias ( ) . '.endpoints.%s' , $ alias ) , $ definition ) ; }
7282	public static function current ( ) { $ url = $ _SERVER [ "REQUEST_URI" ] ; $ method = $ _SERVER [ "REQUEST_METHOD" ] ; $ time = $ _SERVER [ "REQUEST_TIME_FLOAT" ] ; $ headers = getallheaders ( ) ? : [ ] ; $ inputs = [ ] ; $ files = [ ] ; $ raw = [ ] ; switch ( $ method ) { case "GET" : $ raw = $ _GET ; break ; case "POST" : $ raw = $ _POST ; break ; default : parse_str ( file_get_contents ( "php://input" ) , $ raw ) ; } foreach ( $ raw as $ input => $ val ) $ inputs [ $ input ] = parse_string ( $ val ) ; foreach ( $ _FILES as $ name => $ file ) $ files [ $ name ] = $ file ; return new static ( $ url , $ method , $ time , $ headers , $ inputs , $ files ) ; }
5907	public function retrieveSetting ( $ key , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/accounts/settings/' . $ key . '' , $ parameters , $ cachePolicy ) ; return $ result ; }
1433	public static function dasherize ( $ value ) { if ( isset ( self :: $ dasherized [ $ value ] ) ) { return self :: $ dasherized [ $ value ] ; } return self :: $ dasherized [ $ value ] = str_replace ( '_' , '-' , self :: decamelize ( $ value ) ) ; }
10495	public function mod ( $ value ) { $ value = Cast :: Float ( $ value ) ; if ( $ value == 0 ) { throw new InvalidArgumentException ( 'Division by zero' ) ; } if ( $ this -> value === null ) { return new FloatType ( $ this -> value ) ; } return new FloatType ( $ this -> value % $ value ) ; }
7284	public function status ( $ status = NULL ) { if ( $ status === NULL ) { return $ this -> status ; } elseif ( array_key_exists ( $ status , Response :: $ messages ) ) { $ this -> status = ( int ) $ status ; $ this -> status_message = Response :: $ messages [ $ this -> status ] ; return $ this ; } else { throw new Exception ( __METHOD__ . ' unknown status value : :value' , array ( ':value' => $ status ) ) ; } }
2318	public static function getPath ( $ src ) { if ( $ src == '' ) { return '' ; } $ src = rawurldecode ( $ src ) ; if ( strpos ( $ src , '/' ) !== false ) { return $ src ; } $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( strncmp ( $ src , 'icon' , 4 ) === 0 ) { if ( pathinfo ( $ src , PATHINFO_EXTENSION ) == 'svg' ) { return 'assets/contao/images/' . $ src ; } $ filename = pathinfo ( $ src , PATHINFO_FILENAME ) ; if ( file_exists ( $ rootDir . '/assets/contao/images/' . $ filename . '.svg' ) ) { return 'assets/contao/images/' . $ filename . '.svg' ; } return 'assets/contao/images/' . $ src ; } else { $ theme = Backend :: getTheme ( ) ; if ( pathinfo ( $ src , PATHINFO_EXTENSION ) == 'svg' ) { return 'system/themes/' . $ theme . '/icons/' . $ src ; } $ filename = pathinfo ( $ src , PATHINFO_FILENAME ) ; if ( file_exists ( $ rootDir . '/system/themes/' . $ theme . '/icons/' . $ filename . '.svg' ) ) { return 'system/themes/' . $ theme . '/icons/' . $ filename . '.svg' ; } return 'system/themes/' . $ theme . '/images/' . $ src ; } }
6384	public function readFeedbackQuestions ( $ id ) { $ questions = $ this -> readStoreRecords ( 'feedback_item' , [ 'feedback' => $ id ] ) ; $ expandedQuestions = [ ] ; foreach ( $ questions as $ index => $ question ) { $ expandedQuestion = $ question ; $ expandedQuestion -> template = $ this -> readStoreRecord ( 'feedback_template' , [ 'id' => $ question -> template ] ) ; $ expandedQuestion -> url = $ this -> cfg -> wwwroot . '/mod/feedback/edit_item.php?id=' . $ question -> id ; $ expandedQuestions [ $ index ] = $ expandedQuestion ; } return $ expandedQuestions ; }
8340	public static function set ( string $ fileName , array $ content ) { try { $ json = Yaml :: dump ( $ content , 2 ) ; if ( file_put_contents ( $ fileName , $ json ) === false ) { throw new FileNotWritable ( 'can\'t write to "' . $ fileName . '"' ) ; } } catch ( DumpException $ e ) { throw new BadUse ( 'Config::set() content parameter can\'t be dump to YAML' ) ; } self :: $ files [ $ fileName ] = $ content ; }
9202	public function createBearerToken ( ) { $ bearerCredentials = $ this -> createBearerCredentials ( ) ; $ headers = array ( 'Authorization' => 'Basic ' . $ bearerCredentials , 'Content-Type' => 'application/x-www-form-urlencoded;charset=UTF-8' ) ; $ body = 'grant_type=client_credentials' ; $ data = $ this -> guzzleClient -> post ( Config :: get ( 'oauth2_token' ) , array ( 'headers' => $ headers , 'body' => $ body ) ) -> json ( ) ; $ this -> credentials -> setBearerToken ( $ data [ 'access_token' ] ) ; return $ this ; }
11259	public static function pascal2snake ( string $ pascal ) : string { preg_match_all ( '/((?:^|[A-Z])[a-z]+)/' , $ pascal , $ matches ) ; if ( $ matches !== null && count ( $ matches ) > 1 && count ( $ matches [ 1 ] ) > 1 ) { $ nameParts = $ matches [ 1 ] ; $ nameParts = array_map ( "lcfirst" , $ nameParts ) ; return implode ( "_" , $ nameParts ) ; } else { return lcfirst ( $ pascal ) ; } }
6071	public function uploadFileChunked ( $ fileData , $ name , $ chunk , $ chunks , $ fileId , $ categoryId , $ title = null ) { $ parameters = [ 'query' => [ 'name' => $ name , 'chunk' => $ chunk , 'chunks' => $ chunks , 'fileId' => $ fileId , 'categoryId' => $ categoryId , 'title' => $ title , ] , 'multipart' => [ [ 'name' => 'file' , 'contents' => \ GuzzleHttp \ Psr7 \ stream_for ( $ fileData ) , 'filename' => $ name , ] , ] , 'headers' => null , ] ; $ result = $ this -> post ( 'v1/media.json' , $ parameters ) ; return $ result ; }
11929	public function setDataInterface ( $ value ) { if ( ( $ interfaceItem = Yii :: $ app -> collectors [ 'dataInterfaces' ] -> getOne ( $ value ) ) && ( $ interface = $ interfaceItem -> object ) ) { $ this -> _interface = $ interfaceItem ; } else { throw new Exception ( "Invalid interface!" ) ; } }
3620	public function setFanEveryDaySchedule ( $ start_hour , $ end_hour , $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ data = json_encode ( array ( 'fan_duty_start_time' => $ start_hour * 3600 , 'fan_duty_end_time' => $ end_hour * 3600 ) ) ; return $ this -> doPOST ( "/v2/put/device." . $ serial_number , $ data ) ; }
12260	private function _cacheCustomFields ( $ class ) { $ customFieldsGroups = $ this -> em -> getRepository ( 'ChillCustomFieldsBundle:CustomFieldsGroup' ) -> findBy ( array ( 'entity' => ( is_string ( $ class ) ) ? $ class : get_class ( $ class ) ) ) ; if ( ! $ customFieldsGroups ) { throw CustomFieldsHelperException :: customFieldsGroupNotFound ( ( is_string ( $ class ) ) ? $ class : get_class ( $ class ) ) ; } foreach ( $ customFieldsGroup as $ cfGroup ) { $ this -> _cacheCustomFields ( $ cfGroup ) ; } }
6140	public function checkUser ( $ username = null ) { if ( $ username === null ) { $ username = $ this -> user ; } if ( strlen ( $ username ) == 0 ) { return true ; } $ pattern = "/^(" . $ this -> regex [ "alphanum" ] . "|" . $ this -> regex [ "mark" ] . "|" . $ this -> regex [ "escaped" ] . "|[;:&=+$,])+$/" ; $ status = @ preg_match ( $ pattern , $ username ) ; if ( $ status === false ) { throw new Ts3Exception ( "URI username validation failed" ) ; } return ( $ status == 1 ) ; }
10457	public function to ( Uom $ uom ) { $ conversionFactor = Uom :: getConversionFactor ( $ this -> getUom ( ) , $ uom ) ; return new static ( $ this -> getAmount ( ) -> multiply ( $ conversionFactor ) , $ uom ) ; }
12761	protected function checkBrowsers ( ) { return ( $ this -> checkBrowserWebTv ( ) || $ this -> checkBrowserInternetExplorer ( ) || $ this -> checkBrowserOpera ( ) || $ this -> checkBrowserGaleon ( ) || $ this -> checkBrowserNetscapeNavigator9Plus ( ) || $ this -> checkBrowserFirefox ( ) || $ this -> checkBrowserChrome ( ) || $ this -> checkBrowserOmniWeb ( ) || $ this -> checkBrowserAndroid ( ) || $ this -> checkBrowseriPad ( ) || $ this -> checkBrowseriPod ( ) || $ this -> checkBrowseriPhone ( ) || $ this -> checkBrowserBlackBerry ( ) || $ this -> checkBrowserNokia ( ) || $ this -> checkBrowserGoogleBot ( ) || $ this -> checkBrowserMSNBot ( ) || $ this -> checkBrowserBingBot ( ) || $ this -> checkBrowserSlurp ( ) || $ this -> checkFacebookExternalHit ( ) || $ this -> checkBrowserSafari ( ) || $ this -> checkBrowserNetPositive ( ) || $ this -> checkBrowserFirebird ( ) || $ this -> checkBrowserKonqueror ( ) || $ this -> checkBrowserIcab ( ) || $ this -> checkBrowserPhoenix ( ) || $ this -> checkBrowserAmaya ( ) || $ this -> checkBrowserLynx ( ) || $ this -> checkBrowserShiretoko ( ) || $ this -> checkBrowserIceCat ( ) || $ this -> checkBrowserIceweasel ( ) || $ this -> checkBrowserW3CValidator ( ) || $ this -> checkBrowserMozilla ( ) ) ; }
4317	private static function getMethodDefaultArgs ( $ methodName ) { $ defaultArgs = array ( ) ; if ( isset ( self :: $ methodDefaultArgs [ $ methodName ] ) ) { $ defaultArgs = self :: $ methodDefaultArgs [ $ methodName ] ; } elseif ( \ method_exists ( self :: $ instance , $ methodName ) ) { $ reflectionMethod = new ReflectionMethod ( self :: $ instance , $ methodName ) ; $ params = $ reflectionMethod -> getParameters ( ) ; foreach ( $ params as $ reflectionParameter ) { $ defaultArgs [ ] = $ reflectionParameter -> isOptional ( ) ? $ reflectionParameter -> getDefaultValue ( ) : null ; } self :: $ methodDefaultArgs [ $ methodName ] = $ defaultArgs ; } return $ defaultArgs ; }
11995	public function getCatalog ( array $ catalogData ) { $ skuIndex = [ ] ; $ slugIndex = [ ] ; $ index = 1 ; $ products = [ ] ; foreach ( $ catalogData as $ catalogItem ) { try { $ product = $ this -> productMapper -> getProduct ( $ catalogItem ) ; $ sku = strtolower ( $ product -> getSku ( ) -> __toString ( ) ) ; if ( array_key_exists ( $ sku , $ skuIndex ) ) { throw new CatalogException ( sprintf ( "Cannot add a second product with the SKU '%s' to the catalog" , $ sku ) ) ; } $ skuIndex [ $ sku ] = 1 ; $ slug = strtolower ( $ product -> getSlug ( ) -> __toString ( ) ) ; if ( array_key_exists ( $ slug , $ slugIndex ) ) { throw new CatalogException ( sprintf ( "Cannot add a second product with the Slug '%s' to the catalog" , $ slug ) ) ; } $ slugIndex [ $ slug ] = 1 ; $ products [ ] = $ product ; } catch ( \ Exception $ productException ) { throw new CatalogException ( sprintf ( "Cannot convert catalog item %s into a product: %s" , $ index , $ productException -> getMessage ( ) ) , $ productException ) ; } $ index ++ ; } return new Catalog ( $ products ) ; }
8596	public function listMarketplaceParticipations ( $ request ) { if ( ! ( $ request instanceof MarketplaceWebServiceSellers_Model_ListMarketplaceParticipationsRequest ) ) { $ request = new MarketplaceWebServiceSellers_Model_ListMarketplaceParticipationsRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListMarketplaceParticipations' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = MarketplaceWebServiceSellers_Model_ListMarketplaceParticipationsResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
11146	public function move ( Neuron_GameServer_Map_MapObject $ object , Neuron_GameServer_Map_Location $ location , Neuron_GameServer_Map_Date $ start , Neuron_GameServer_Map_Date $ end ) { throw new Neuron_Exceptions_NotImplemented ( "The move method is not implemented in this map." ) ; }
1516	public function readRelatedResource ( StoreInterface $ store , FetchRelated $ request ) { $ record = $ request -> getRecord ( ) ; $ result = $ this -> beforeReadingRelationship ( $ record , $ request ) ; if ( $ this -> isResponse ( $ result ) ) { return $ result ; } $ related = $ store -> queryRelated ( $ record , $ request -> getRelationshipName ( ) , $ request -> getParameters ( ) ) ; $ records = ( $ related instanceof PageInterface ) ? $ related -> getData ( ) : $ related ; $ result = $ this -> afterReadingRelationship ( $ record , $ records , $ request ) ; if ( $ this -> isInvokedResult ( $ result ) ) { return $ result ; } return $ this -> reply ( ) -> content ( $ related ) ; }
5011	public function getLogger ( ) : LoggerInterface { if ( ! $ this -> logger ) { $ logger = new class implements LoggerInterface { public function emerg ( $ message , $ extra = [ ] ) : void { } public function alert ( $ message , $ extra = [ ] ) : void { } public function crit ( $ message , $ extra = [ ] ) : void { } public function err ( $ message , $ extra = [ ] ) : void { } public function warn ( $ message , $ extra = [ ] ) : void { } public function notice ( $ message , $ extra = [ ] ) : void { } public function info ( $ message , $ extra = [ ] ) : void { } public function debug ( $ message , $ extra = [ ] ) : void { } } ; $ this -> setLogger ( $ logger ) ; } return $ this -> logger ; }
10387	public function newApp ( ) : ApplicationInterface { $ app = new CalgamoApplication ( $ this -> filesystem ) ; $ app -> requireModule ( CalgamoLogExceptionHandlerModule :: class ) ; $ app -> requireModule ( CalgamoRouterModule :: class ) ; $ app -> requireModule ( CalgamoDiModule :: class ) ; $ app -> requireModule ( Wa72SimpleLoggerModule :: class ) ; return $ app ; }
5201	public function buildConnectionOptions ( ) { $ connection_name = $ this -> config -> get ( "tail-settings.default" ) ; if ( $ this -> connection_name ) $ connection_name = $ this -> connection_name ; $ connectionOptions = $ this -> config -> get ( "tail-settings.connections.$connection_name" ) ; if ( ! isset ( $ connectionOptions [ 'exchange_type' ] ) ) $ connectionOptions [ 'exchange_type' ] = 'direct' ; if ( ! isset ( $ connectionOptions [ 'content_type' ] ) ) $ connectionOptions [ 'content_type' ] = 'text/plain' ; if ( $ this -> vhost ) $ connectionOptions [ 'vhost' ] = $ this -> vhost ; if ( $ this -> exchange ) $ connectionOptions [ 'exchange' ] = $ this -> exchange ; if ( $ this -> exchange_type ) $ connectionOptions [ 'exchange_type' ] = $ this -> exchange_type ; if ( $ this -> content_type ) $ connectionOptions [ 'content_type' ] = $ this -> content_type ; $ connectionOptions [ 'queue_name' ] = $ this -> queue_name ; return $ connectionOptions ; }
3048	public function init ( ) { $ sessionStateService = $ this -> getServiceManager ( ) -> get ( SessionStateService :: SERVICE_ID ) ; $ sessionStateService -> resumeSession ( $ this -> getTestSession ( ) ) ; $ this -> retrieveItemIndex ( ) ; }
9877	private function writeFileVersion ( XMLWriter $ objWriter ) { $ objWriter -> startElement ( 'fileVersion' ) ; $ objWriter -> writeAttribute ( 'appName' , 'xl' ) ; $ objWriter -> writeAttribute ( 'lastEdited' , '4' ) ; $ objWriter -> writeAttribute ( 'lowestEdited' , '4' ) ; $ objWriter -> writeAttribute ( 'rupBuild' , '4505' ) ; $ objWriter -> endElement ( ) ; }
727	public static function on ( $ class , $ name , $ handler , $ data = null , $ append = true ) { $ class = ltrim ( $ class , '\\' ) ; if ( strpos ( $ class , '*' ) !== false || strpos ( $ name , '*' ) !== false ) { if ( $ append || empty ( self :: $ _eventWildcards [ $ name ] [ $ class ] ) ) { self :: $ _eventWildcards [ $ name ] [ $ class ] [ ] = [ $ handler , $ data ] ; } else { array_unshift ( self :: $ _eventWildcards [ $ name ] [ $ class ] , [ $ handler , $ data ] ) ; } return ; } if ( $ append || empty ( self :: $ _events [ $ name ] [ $ class ] ) ) { self :: $ _events [ $ name ] [ $ class ] [ ] = [ $ handler , $ data ] ; } else { array_unshift ( self :: $ _events [ $ name ] [ $ class ] , [ $ handler , $ data ] ) ; } }
9327	protected function registerMarkdownEngine ( $ resolver ) { $ app = $ this -> app ; $ app -> singleton ( 'markdown.compiler' , function ( $ app ) { $ cache = $ app [ 'config' ] [ 'view.compiled' ] ; return new MarkdownCompiler ( $ app [ 'files' ] , $ cache ) ; } ) ; $ resolver -> register ( 'markdown' , function ( ) use ( $ app ) { return new MarkdownEngine ( $ app [ 'markdown.compiler' ] , $ app [ 'files' ] ) ; } ) ; $ app [ 'view' ] -> addExtension ( 'md' , 'markdown' ) ; }
480	public function alterColumn ( $ table , $ column , $ type ) { $ time = $ this -> beginCommand ( "alter column $column in table $table to $type" ) ; $ this -> db -> createCommand ( ) -> alterColumn ( $ table , $ column , $ type ) -> execute ( ) ; if ( $ type instanceof ColumnSchemaBuilder && $ type -> comment !== null ) { $ this -> db -> createCommand ( ) -> addCommentOnColumn ( $ table , $ column , $ type -> comment ) -> execute ( ) ; } $ this -> endCommand ( $ time ) ; }
8662	private function convertGetFeedSubmissionList ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetFeedSubmissionList' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetFeedSubmissionIdList ( ) ) { $ feedSubmissionIdList = $ request -> getFeedSubmissionIdList ( ) ; foreach ( $ feedSubmissionIdList -> getId ( ) as $ idIndex => $ id ) { $ parameters [ 'FeedSubmissionIdList' . '.' . 'Id' . '.' . ( $ idIndex + 1 ) ] = $ id ; } } if ( $ request -> isSetMaxCount ( ) ) { $ parameters [ 'MaxCount' ] = $ request -> getMaxCount ( ) ; } if ( $ request -> isSetFeedTypeList ( ) ) { $ feedTypeList = $ request -> getFeedTypeList ( ) ; foreach ( $ feedTypeList -> getType ( ) as $ typeIndex => $ type ) { $ parameters [ 'FeedTypeList' . '.' . 'Type' . '.' . ( $ typeIndex + 1 ) ] = $ type ; } } if ( $ request -> isSetFeedProcessingStatusList ( ) ) { $ feedProcessingStatusList = $ request -> getFeedProcessingStatusList ( ) ; foreach ( $ feedProcessingStatusList -> getStatus ( ) as $ statusIndex => $ status ) { $ parameters [ 'FeedProcessingStatusList' . '.' . 'Status' . '.' . ( $ statusIndex + 1 ) ] = $ status ; } } if ( $ request -> isSetSubmittedFromDate ( ) ) { $ parameters [ 'SubmittedFromDate' ] = $ this -> getFormattedTimestamp ( $ request -> getSubmittedFromDate ( ) ) ; } if ( $ request -> isSetSubmittedToDate ( ) ) { $ parameters [ 'SubmittedToDate' ] = $ this -> getFormattedTimestamp ( $ request -> getSubmittedToDate ( ) ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
7760	protected function detectMetadataDriver ( $ dir , ContainerBuilder $ container ) { $ configPath = $ this -> getMappingResourceConfigDirectory ( ) ; $ resource = $ dir . '/' . $ configPath ; while ( ! is_dir ( $ resource ) ) { $ resource = dirname ( $ resource ) ; } $ container -> addResource ( new FileResource ( $ resource ) ) ; $ extension = $ this -> getMappingResourceExtension ( ) ; if ( ( $ files = glob ( $ dir . '/' . $ configPath . '/*.' . $ extension . '.xml' ) ) && count ( $ files ) ) { return 'xml' ; } elseif ( ( $ files = glob ( $ dir . '/' . $ configPath . '/*.' . $ extension . '.yml' ) ) && count ( $ files ) ) { return 'yml' ; } elseif ( ( $ files = glob ( $ dir . '/' . $ configPath . '/*.' . $ extension . '.php' ) ) && count ( $ files ) ) { return 'php' ; } $ container -> addResource ( new FileResource ( $ dir ) ) ; if ( is_dir ( $ dir . '/' . $ this -> getMappingObjectDefaultName ( ) ) ) { return 'annotation' ; } return null ; }
11419	protected function getValues ( $ fields , $ preCalculatedResult = false ) { if ( $ preCalculatedResult ) { return $ preCalculatedResult ; } $ app = App :: getInstance ( ) ; $ sql = $ this -> constructSelectSQL ( $ fields ) ; $ item = $ this -> getCache ( $ fields [ $ this -> pk ] ) ; $ results = $ item -> get ( \ Stash \ Invalidation :: PRECOMPUTE , 300 ) ; if ( $ item -> isMiss ( ) ) { $ results = $ this -> runGetRow ( $ sql ) ; if ( $ app [ 'db' ] -> last_error ) { throw new SQLException ( $ app [ 'db' ] -> last_error , $ app [ 'db' ] -> captured_errors ) ; } if ( is_null ( $ results ) ) { throw new ModelNotFoundException ( 'No model in database' , $ this -> dbtable , $ this -> constructorId ) ; } $ app [ 'cache' ] -> save ( $ item -> set ( $ results ) ) ; } return $ results ; }
2284	protected static function ip ( ) { $ request = System :: getContainer ( ) -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; if ( $ request === null ) { return '' ; } return $ request -> getClientIp ( ) ; }
6173	public function read ( $ path , $ file ) { return $ this -> driver -> read ( $ this -> root . $ path , $ file ) ; }
1447	protected function dataForDelete ( $ record ) : array { $ schema = $ this -> container -> getSchema ( $ record ) ; return ResourceObject :: create ( [ 'type' => $ schema -> getResourceType ( ) , 'id' => $ schema -> getId ( $ record ) , 'attributes' => $ schema -> getAttributes ( $ record ) , 'relationships' => collect ( $ this -> existingRelationships ( $ record ) ) -> all ( ) , ] ) -> all ( ) ; }
5157	public function executeFor ( Route $ route ) : bool { if ( null === $ this -> pathConstraint ) { return true ; } return strpos ( $ route -> getPath ( ) , $ this -> pathConstraint ) === 0 ; }
11790	public function clear ( $ name = null ) { if ( ! is_null ( $ name ) ) { $ name = strtolower ( $ name ) ; if ( array_key_exists ( $ name , self :: $ clearings ) ) { $ this -> { $ name } = self :: $ clearings [ $ self :: $ clearings ] ; } } else { foreach ( self :: $ clearings as $ n => $ v ) { $ this -> { $ n } = $ v ; } } return $ this ; }
12177	public function addArgument ( ArgumentInterface $ argument ) { $ this -> argumentPositions [ $ argument -> getPosition ( ) ] = $ argument ; $ this -> argumentNames [ $ argument -> getName ( ) ] = $ argument ; if ( $ argument -> isClass ( ) ) { $ this -> argumentClasses [ $ argument -> getClass ( ) ] = $ argument ; } return $ argument ; }
12604	public static function upload ( $ src , $ dest ) { $ dest = Path :: clean ( $ dest ) ; $ baseDir = dirname ( $ dest ) ; try { if ( ! Folder :: exists ( $ baseDir ) ) { Folder :: create ( $ baseDir ) ; } } catch ( Exception $ e ) { throw $ e ; } if ( is_writeable ( $ baseDir ) && move_uploaded_file ( $ src , $ dest ) ) { if ( Path :: setPermissions ( $ dest ) ) { return true ; } throw new Exception ( Helper :: getTranslation ( 'FAILED_CHMOD' ) ) ; } throw new Exception ( Helper :: getTranslation ( 'FAILED_MOVE_UPLOAD' ) ) ; }
7008	private function format_l ( & $ str ) { if ( strstr ( $ str , '%l' ) ) $ str = str_replace ( '%l' , $ this -> dayName ( true ) , $ str ) ; }
8499	public function updateFulfillmentOrder ( $ request ) { if ( ! ( $ request instanceof FBAOutboundServiceMWS_Model_UpdateFulfillmentOrderRequest ) ) { $ request = new FBAOutboundServiceMWS_Model_UpdateFulfillmentOrderRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'UpdateFulfillmentOrder' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAOutboundServiceMWS_Model_UpdateFulfillmentOrderResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
1475	public function createRelationshipValidator ( ResourceObject $ resource , array $ rules , array $ messages = [ ] , array $ customAttributes = [ ] ) { return $ this -> createValidator ( $ resource -> all ( ) , $ rules , $ messages , $ customAttributes , function ( $ key , $ detail , $ failed ) use ( $ resource ) { return $ this -> invalidResource ( $ resource -> pointerForRelationship ( $ key , '/data' ) , $ detail , $ failed ) ; } ) ; }
6013	public function listProtocols ( CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/deployment/protocols' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new Protocol ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
1321	private function request ( $ url , $ method , $ authorization , array $ postfields , $ json = false ) { $ options = $ this -> curlOptions ( ) ; $ options [ CURLOPT_URL ] = $ url ; $ options [ CURLOPT_HTTPHEADER ] = [ 'Accept: application/json' , $ authorization , 'Expect:' ] ; switch ( $ method ) { case 'GET' : break ; case 'POST' : $ options [ CURLOPT_POST ] = true ; if ( $ json ) { $ options [ CURLOPT_HTTPHEADER ] [ ] = 'Content-type: application/json' ; $ options [ CURLOPT_POSTFIELDS ] = json_encode ( $ postfields ) ; } else { $ options [ CURLOPT_POSTFIELDS ] = Util :: buildHttpQuery ( $ postfields ) ; } break ; case 'DELETE' : $ options [ CURLOPT_CUSTOMREQUEST ] = 'DELETE' ; break ; case 'PUT' : $ options [ CURLOPT_CUSTOMREQUEST ] = 'PUT' ; break ; } if ( in_array ( $ method , [ 'GET' , 'PUT' , 'DELETE' ] ) && ! empty ( $ postfields ) ) { $ options [ CURLOPT_URL ] .= '?' . Util :: buildHttpQuery ( $ postfields ) ; } $ curlHandle = curl_init ( ) ; curl_setopt_array ( $ curlHandle , $ options ) ; $ response = curl_exec ( $ curlHandle ) ; if ( curl_errno ( $ curlHandle ) > 0 ) { throw new TwitterOAuthException ( curl_error ( $ curlHandle ) , curl_errno ( $ curlHandle ) ) ; } $ this -> response -> setHttpCode ( curl_getinfo ( $ curlHandle , CURLINFO_HTTP_CODE ) ) ; $ parts = explode ( "\r\n\r\n" , $ response ) ; $ responseBody = array_pop ( $ parts ) ; $ responseHeader = array_pop ( $ parts ) ; $ this -> response -> setHeaders ( $ this -> parseHeaders ( $ responseHeader ) ) ; curl_close ( $ curlHandle ) ; return $ responseBody ; }
4185	public function search ( ) { $ this -> console -> info ( 'Searching directory for service providers.' ) ; $ sps = $ this -> getProviders ( ) ; if ( ! $ sps -> count ( ) ) { $ this -> console -> warn ( 'No service provider file found. Nothing to install.' ) ; return [ ] ; } $ this -> console -> line ( " Found {$sps->count()} Service provider" . ( $ sps -> count ( ) > 1 ? 's' : '' ) . '.' ) ; $ sps -> each ( function ( $ sp , $ index ) { $ currentCount = $ index + 1 ; $ this -> console -> line ( " $currentCount. $sp" ) ; } ) ; if ( ! $ this -> console -> confirm ( 'Register service providers?' , true ) ) { return [ ] ; } $ this -> registered = true ; return $ this -> getProviders ( ) -> toArray ( ) ; }
9253	protected function getContainerInitializer ( ) { $ initializer = new DefaultInitializer ( $ this -> getConfigurationProvider ( ) ) ; if ( $ this -> cache ) { $ initializer = new CachedInitializer ( $ initializer , $ this -> getCacheDir ( ) ) ; } return $ initializer ; }
4520	public function set ( string $ key , $ value ) { $ parameter = $ this -> repository -> findOneBy ( [ 'key' => $ key ] ) ; if ( ! $ parameter ) { throw new OutOfRangeException ( 'Parameter "' . $ key . '" does not exist.' ) ; } $ parameter -> setKey ( $ key ) -> setValue ( $ value ) ; $ this -> manager -> persist ( $ parameter ) ; $ this -> manager -> flush ( ) ; $ this -> manager -> detach ( $ parameter ) ; }
1114	protected static function boot ( ) { parent :: boot ( ) ; static :: creating ( function ( $ node ) { $ node -> setDefaultLeftAndRight ( ) ; } ) ; static :: saving ( function ( $ node ) { $ node -> storeNewParent ( ) ; } ) ; static :: saved ( function ( $ node ) { $ node -> moveToNewParent ( ) ; $ node -> setDepth ( ) ; } ) ; static :: deleting ( function ( $ node ) { $ node -> destroyDescendants ( ) ; } ) ; if ( static :: softDeletesEnabled ( ) ) { static :: restoring ( function ( $ node ) { $ node -> shiftSiblingsForRestore ( ) ; } ) ; static :: restored ( function ( $ node ) { $ node -> restoreDescendants ( ) ; } ) ; } }
1470	public function createResolver ( $ apiName , array $ config ) { $ factoryName = isset ( $ config [ 'resolver' ] ) ? $ config [ 'resolver' ] : ResolverFactory :: class ; $ factory = $ this -> container -> make ( $ factoryName ) ; if ( $ factory instanceof ResolverInterface ) { return $ factory ; } if ( ! is_callable ( $ factory ) ) { throw new RuntimeException ( "Factory {$factoryName} cannot be invoked." ) ; } $ resolver = $ factory ( $ apiName , $ config ) ; if ( ! $ resolver instanceof ResolverInterface ) { throw new RuntimeException ( "Factory {$factoryName} did not create a resolver instance." ) ; } return $ resolver ; }
8465	public static function getUriMethods ( ) { $ root = str_replace ( $ _SERVER [ 'DOCUMENT_ROOT' ] , '' , getcwd ( ) ) ; $ subfolder = trim ( $ root , '/' ) ; return trim ( str_replace ( $ subfolder , '' , self :: getUri ( ) ) , '/' ) ; }
10834	public function using ( $ column ) { if ( $ this -> active_join === null ) { throw new \ Peyote \ Exception ( "You need to start a join before calling \Peyote\Join::using()" ) ; } list ( $ table , $ type ) = $ this -> active_join ; $ this -> active_join = null ; $ this -> joins [ ] = array ( "USING" , $ table , $ type , $ column ) ; return $ this ; }
889	private function shouldClearToken ( Tokens $ tokens , $ index ) { $ token = $ tokens [ $ index ] ; return ! $ token -> isComment ( ) && ! ( $ token -> isWhitespace ( ) && $ tokens [ $ index + 1 ] -> isComment ( ) ) ; }
9061	private function getTableData ( $ table ) : self { if ( $ table instanceof Table ) { return $ table ; } elseif ( is_subclass_of ( $ table , Mapper :: class ) ) { $ mapper = $ this -> container -> getByType ( $ table ) ; return $ mapper -> getStructure ( ) ; } else { throw new InvalidArgumentException ; } }
11425	public function remark ( $ openId , $ remark ) { $ params = [ 'openid' => $ openId , 'remark' => $ remark , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_REMARK , $ params ] ) ; }
9691	private function compile ( $ file ) { if ( ! file_exists ( $ file ) ) { throw new \ Exception ( "Could not compile $file, file not found" ) ; } if ( ! file_exists ( $ this -> views_cache ) && ! mkdir ( $ this -> views_cache ) ) { throw new \ Exception ( "Could no create cache directory." . " Make sure you have write permissions." ) ; } $ hash = md5 ( $ file ) ; $ compiled_file = $ this -> views_cache . '/' . $ hash ; $ compiled = null ; if ( $ this -> debug || ( ! file_exists ( $ compiled_file ) || filemtime ( $ compiled_file ) < filemtime ( $ file ) ) ) { $ source = file_get_contents ( $ file ) ; $ compiled = $ this -> compileString ( $ source ) ; $ compiled = "<?php\nfunction katar_" . $ hash . "(\$args) {\nextract(\$args);\n\$output = null;\n" . $ compiled . "\nreturn \$output;\n}\n" ; file_put_contents ( $ compiled_file , $ compiled ) ; } else { $ compiled = file_get_contents ( $ cache_file ) ; } return $ compiled ; }
5887	public function iconGetName ( $ key ) { $ iconid = ( $ this [ $ key ] < 0 ) ? ( pow ( 2 , 32 ) ) - ( $ this [ $ key ] * - 1 ) : $ this [ $ key ] ; return new StringHelper ( "/icon_" . $ iconid ) ; }
1056	public static function findRemovedTypes ( Schema $ oldSchema , Schema $ newSchema ) { $ oldTypeMap = $ oldSchema -> getTypeMap ( ) ; $ newTypeMap = $ newSchema -> getTypeMap ( ) ; $ breakingChanges = [ ] ; foreach ( array_keys ( $ oldTypeMap ) as $ typeName ) { if ( isset ( $ newTypeMap [ $ typeName ] ) ) { continue ; } $ breakingChanges [ ] = [ 'type' => self :: BREAKING_CHANGE_TYPE_REMOVED , 'description' => "${typeName} was removed." , ] ; } return $ breakingChanges ; }
2068	public function copyPageWithSubpages ( $ row , $ href , $ label , $ title , $ icon , $ attributes , $ table ) { if ( $ GLOBALS [ 'TL_DCA' ] [ $ table ] [ 'config' ] [ 'closed' ] ) { return '' ; } $ objSubpages = Contao \ PageModel :: findByPid ( $ row [ 'id' ] ) ; return ( $ objSubpages !== null && $ objSubpages -> count ( ) > 0 && $ this -> User -> hasAccess ( $ row [ 'type' ] , 'alpty' ) && $ this -> User -> isAllowed ( Contao \ BackendUser :: CAN_EDIT_PAGE_HIERARCHY , $ row ) ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' ; }
3695	protected function getBreadcrumbElements ( EnvironmentInterface $ environment , BreadcrumbStore $ elements ) { if ( $ this -> parent ) { $ this -> parent -> getBreadcrumbElements ( $ environment , $ elements ) ; } }
12132	static public function addParams ( $ url , $ params ) { $ query = parse_url ( $ url , PHP_URL_QUERY ) ; $ separator = ( Text :: isEmpty ( $ query ) ? "?" : "&" ) ; return Text :: concat ( $ separator , $ url , http_build_query ( $ params ) ) ; }
6489	private function addHeaderValue ( HttpHeaders $ headers , string $ name , $ value , bool $ append ) : void { $ decodedValue = trim ( ( string ) ( isset ( self :: $ headersToUrlDecode [ $ name ] ) ? urldecode ( $ value ) : $ value ) ) ; if ( isset ( self :: $ specialCaseHeaders [ $ name ] ) ) { $ headers -> add ( $ name , $ decodedValue , $ append ) ; } elseif ( strpos ( $ name , 'HTTP_' ) === 0 ) { $ normalizedName = substr ( $ name , 5 ) ; $ headers -> add ( $ normalizedName , $ decodedValue , $ append ) ; } }
10530	public function toJson ( $ prettyPrint = false ) { $ options = 0 ; if ( $ prettyPrint ) { $ options += JSON_PRETTY_PRINT ; } return json_encode ( $ this -> items , $ options ) ; }
5055	protected function getEntityClassName ( $ name ) { $ repositoryName = str_replace ( 'Repository/' , '' , $ name ) ; $ nameParts = explode ( '/' , $ repositoryName ) ; $ namespace = $ nameParts [ 0 ] ; $ entity = isset ( $ nameParts [ 1 ] ) ? $ nameParts [ 1 ] : substr ( $ namespace , 0 , - 1 ) ; $ class = "\\$namespace\\Entity\\$entity" ; return $ class ; }
4929	public function attach ( EventManagerInterface $ events , $ priority = 1 ) { foreach ( $ this -> listenerSpecs as $ name => $ spec ) { $ this -> listeners [ ] = $ events -> attach ( $ spec [ 'event' ] , array ( $ this , "do$name" ) , $ spec [ 'priority' ] ) ; } }
7016	private function format_g ( & $ str ) { if ( strstr ( $ str , '%g' ) ) { $ h = $ this -> hour > 12 ? $ this -> hour - 12 : $ this -> hour ; $ str = str_replace ( '%g' , sprintf ( '%1d' , $ h ) , $ str ) ; } }
10383	protected static function compress_files ( $ content ) { $ var = array ( "\r\n" , "\r" , "\n" , "\t" , ' ' , ' ' , ' ' ) ; $ content = preg_replace ( '!/\*[^*]*\*+([^/][^*]*\*+)*/!' , '' , $ content ) ; $ content = str_replace ( $ var , '' , $ content ) ; $ content = str_replace ( '{ ' , '{' , $ content ) ; $ content = str_replace ( ' }' , '}' , $ content ) ; $ content = str_replace ( '; ' , ';' , $ content ) ; return $ content ; }
6641	public function init ( ) { $ this -> query = $ this -> controller -> query ; if ( $ this -> query ) { $ modelClass = Yii :: createObject ( $ this -> query -> modelClass ) ; $ this -> modelClass = $ modelClass ; $ this -> tableName = $ modelClass :: tableName ( ) ; } parent :: init ( ) ; }
4947	protected function checkPermission ( $ permission ) { $ perms = array ( self :: PERMISSION_ALL , self :: PERMISSION_CHANGE , self :: PERMISSION_NONE , self :: PERMISSION_VIEW , ) ; if ( ! in_array ( $ permission , $ perms ) ) { throw new \ InvalidArgumentException ( 'Invalid permission. Must be one of ' . implode ( ', ' , $ perms ) ) ; } }
977	protected function getUrlFromName ( string $ name ) { if ( Str :: endsWith ( $ name , 'Job' ) ) { $ name = substr ( $ name , 0 , - 3 ) ; } return strtolower ( preg_replace ( '/(?<!^)[A-Z]/' , '-$0' , $ name ) ) ; }
3669	public function getCurrentFilterUrl ( $ options = null ) : FilterUrl { $ this -> addFromCurrentRequest ( $ filterUrl = new FilterUrl ( ) , $ options ) ; return $ filterUrl ; }
8277	public function onConfigLoaded ( array & $ config ) { $ config [ self :: PLUGIN_NAME ] = $ this -> loadDefaultConfig ( $ config ) ; $ this -> config = $ config [ self :: PLUGIN_NAME ] ; $ this -> createContainer ( ) ; $ this -> initLogger ( ) ; }
3642	public function only ( $ keys , bool $ trim = true , bool $ clean = true ) { $ values = [ ] ; foreach ( ( array ) $ keys as $ key ) { $ values [ $ key ] = $ this -> get ( $ key , null , $ trim , $ clean ) ; } return $ values ; }
6769	public function onStateChange ( ResourceEventInterface $ event ) { $ sale = $ this -> getSaleFromEvent ( $ event ) ; if ( $ this -> persistenceHelper -> isScheduledForRemove ( $ sale ) ) { $ event -> stopPropagation ( ) ; return ; } $ this -> handleStateChange ( $ sale ) ; }
11149	protected function process ( array $ requestParams ) { $ request = new ExtDirectRequest ( $ this -> useCache ( ) , $ this -> getApplicationPath ( ) , $ this -> getApplicationNameSpace ( ) ) ; $ response = new ExtDirectResponse ( ) ; $ requestParameters = new Parameters ( ) ; try { $ request -> setApplicationPath ( $ this -> getApplicationPath ( ) ) ; $ requestParameters -> setParameters ( $ requestParams ) ; $ request -> injectParameters ( $ requestParameters ) ; $ response -> injectParameters ( $ requestParameters ) ; $ request -> injectResponse ( $ response ) ; $ request -> setParamMethod ( $ this -> getParamMethod ( ) ) ; $ request -> setMethodCalls ( $ this -> getMethodsToCall ( ) ) ; $ request -> run ( ) ; } catch ( ExtDirectApplicationException $ e ) { $ result = $ e -> getResponse ( ) ; if ( ! empty ( $ result ) ) { $ response -> setResult ( array ( "success" => false , "message" => $ e -> getMessage ( ) , "actions" => $ result ) ) ; } else { $ response -> setResult ( array ( "success" => false , "message" => $ e -> getMessage ( ) ) ) ; } } catch ( \ Exception $ e ) { $ response -> setResult ( array ( "success" => false , "message" => $ e -> getMessage ( ) ) ) ; } return $ response ; }
12798	public function getLines ( $ lazy = true , $ raw = false ) { if ( is_null ( $ this -> _lines ) ) { $ file = $ this -> filePointer ; if ( ! $ file ) { return false ; } rewind ( $ file ) ; $ this -> _lines = [ ] ; $ currentLineNumber = 0 ; while ( ( $ buffer = fgetcsv ( $ this -> filePointer , 0 , $ this -> delimeter ) ) !== false ) { $ currentLineNumber ++ ; if ( $ currentLineNumber <= $ this -> skipLines ) { continue ; } $ line = Yii :: createObject ( [ 'class' => SourceFileLine :: className ( ) , 'sourceFile' => $ this , 'lineNumber' => $ currentLineNumber - 1 , 'content' => $ buffer ] ) ; if ( $ this -> testIgnore ( $ line ) ) { continue ; } $ lineId = $ line -> id ; if ( ! isset ( $ lineId ) ) { continue ; } $ this -> _lines [ $ lineId ] = $ line ; if ( $ lazy ) { $ line -> clean ( ) ; } } } return $ this -> _lines ; }
5683	public function getUrls ( ) { $ all = array ( ) ; foreach ( $ this -> links as $ link ) { $ url = $ this -> getUrlFromLink ( $ link ) ; $ all [ ] = $ url -> asString ( ) ; } return $ all ; }
11736	public function setAddress ( $ address ) { $ address = trim ( $ address , self :: SEPARATOR ) ; if ( ! filter_var ( $ address , FILTER_VALIDATE_URL ) ) { throw new \ InvalidArgumentException ( "$address is not valid format of url address." ) ; } $ this -> address = $ address ; $ this -> parse = parse_url ( $ address ) ; return $ this ; }
12482	private function mapByGeneration ( $ mapByDepthDesc , $ mapById ) { $ result = [ ] ; foreach ( $ mapByDepthDesc as $ depth => $ ids ) { foreach ( $ ids as $ custId ) { $ entry = $ mapById [ $ custId ] ; $ path = $ entry -> getPath ( ) ; $ parents = $ this -> hlpTree -> getParentsFromPathReversed ( $ path ) ; $ level = 0 ; foreach ( $ parents as $ parentId ) { $ level += 1 ; if ( ! isset ( $ result [ $ parentId ] ) ) { $ result [ $ parentId ] = [ ] ; } if ( ! isset ( $ result [ $ parentId ] [ $ level ] ) ) { $ result [ $ parentId ] [ $ level ] = [ ] ; } $ result [ $ parentId ] [ $ level ] [ ] = $ custId ; } } } return $ result ; }
3996	protected function jumpTo ( $ mixMetaModel , $ mixDataId , $ intIdRenderSetting , $ strParam = 'url' ) { if ( empty ( $ strParam ) ) { $ strParam = 'url' ; } $ objMetaModel = $ this -> loadMetaModel ( $ mixMetaModel ) ; if ( $ objMetaModel == null ) { return false ; } $ objRenderSettings = $ this -> getServiceContainer ( ) -> getRenderSettingFactory ( ) -> createCollection ( $ objMetaModel , $ intIdRenderSetting ) ; if ( $ objRenderSettings == null ) { return false ; } $ objItem = $ objMetaModel -> findById ( $ mixDataId ) ; if ( $ objItem == null ) { return false ; } $ arrRenderedItem = $ objItem -> parseValue ( 'text' , $ objRenderSettings ) ; if ( ! isset ( $ arrRenderedItem [ 'jumpTo' ] ) ) { return false ; } if ( stripos ( $ strParam , 'params.' ) !== false ) { $ mixAttName = StringUtil :: trimsplit ( '.' , $ strParam ) ; $ mixAttName = array_pop ( $ mixAttName ) ; if ( isset ( $ arrRenderedItem [ 'jumpTo' ] [ 'params' ] [ $ mixAttName ] ) ) { return $ arrRenderedItem [ 'jumpTo' ] [ 'params' ] [ $ mixAttName ] ; } } elseif ( isset ( $ arrRenderedItem [ 'jumpTo' ] [ $ strParam ] ) ) { return $ arrRenderedItem [ 'jumpTo' ] [ $ strParam ] ; } return false ; }
2135	public static function preload ( ) { include __DIR__ . '/../../config/default.php' ; include __DIR__ . '/../../config/agents.php' ; include __DIR__ . '/../../config/mimetypes.php' ; $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( ( $ blnHasLcf = file_exists ( $ rootDir . '/system/config/localconfig.php' ) ) === true ) { include $ rootDir . '/system/config/localconfig.php' ; } static :: loadParameters ( ) ; static :: $ blnHasLcf = $ blnHasLcf ; }
3678	public function generateAjax ( $ folder , $ strField , $ level , $ mount = false ) { return parent :: generateAjax ( $ folder , $ this -> strField , $ level , $ mount ) ; }
938	public function isGivenKind ( $ possibleKind ) { return $ this -> isArray && ( \ is_array ( $ possibleKind ) ? \ in_array ( $ this -> id , $ possibleKind , true ) : $ this -> id === $ possibleKind ) ; }
3138	public function emptyResponse ( RunnerServiceContext $ context , $ responses ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ similar = 0 ; foreach ( $ responses as $ responseVariable ) { $ value = $ responseVariable -> getValue ( ) ; $ default = $ responseVariable -> getDefaultValue ( ) ; if ( TestRunnerUtils :: isQtiValueNull ( $ value ) === true ) { if ( TestRunnerUtils :: isQtiValueNull ( $ default ) === true ) { $ similar ++ ; } } elseif ( $ value -> equals ( $ default ) === true ) { $ similar ++ ; } } $ respCount = count ( $ responses ) ; return $ respCount > 0 && $ similar == $ respCount ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'storeItemResponse' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } }
448	protected function renderPageButtons ( ) { $ pageCount = $ this -> pagination -> getPageCount ( ) ; if ( $ pageCount < 2 && $ this -> hideOnSinglePage ) { return '' ; } $ buttons = [ ] ; $ currentPage = $ this -> pagination -> getPage ( ) ; $ firstPageLabel = $ this -> firstPageLabel === true ? '1' : $ this -> firstPageLabel ; if ( $ firstPageLabel !== false ) { $ buttons [ ] = $ this -> renderPageButton ( $ firstPageLabel , 0 , $ this -> firstPageCssClass , $ currentPage <= 0 , false ) ; } if ( $ this -> prevPageLabel !== false ) { if ( ( $ page = $ currentPage - 1 ) < 0 ) { $ page = 0 ; } $ buttons [ ] = $ this -> renderPageButton ( $ this -> prevPageLabel , $ page , $ this -> prevPageCssClass , $ currentPage <= 0 , false ) ; } list ( $ beginPage , $ endPage ) = $ this -> getPageRange ( ) ; for ( $ i = $ beginPage ; $ i <= $ endPage ; ++ $ i ) { $ buttons [ ] = $ this -> renderPageButton ( $ i + 1 , $ i , null , $ this -> disableCurrentPageButton && $ i == $ currentPage , $ i == $ currentPage ) ; } if ( $ this -> nextPageLabel !== false ) { if ( ( $ page = $ currentPage + 1 ) >= $ pageCount - 1 ) { $ page = $ pageCount - 1 ; } $ buttons [ ] = $ this -> renderPageButton ( $ this -> nextPageLabel , $ page , $ this -> nextPageCssClass , $ currentPage >= $ pageCount - 1 , false ) ; } $ lastPageLabel = $ this -> lastPageLabel === true ? $ pageCount : $ this -> lastPageLabel ; if ( $ lastPageLabel !== false ) { $ buttons [ ] = $ this -> renderPageButton ( $ lastPageLabel , $ pageCount - 1 , $ this -> lastPageCssClass , $ currentPage >= $ pageCount - 1 , false ) ; } $ options = $ this -> options ; $ tag = ArrayHelper :: remove ( $ options , 'tag' , 'ul' ) ; return Html :: tag ( $ tag , implode ( "\n" , $ buttons ) , $ options ) ; }
6827	public static function isValid ( $ action , $ throw = false ) { if ( in_array ( $ action , static :: getActions ( ) , true ) ) { return true ; } if ( $ throw ) { throw new InvalidArgumentException ( "Unknown gateway action '$action'." ) ; } return false ; }
7358	private function loadPriceMap ( ) { if ( null === $ this -> pricesMap ) { $ this -> pricesMap = $ this -> getPricesMapLoader ( ) -> load ( $ this -> currency ) ; } }
3805	public function generate ( ) { $ GLOBALS [ 'TL_CSS' ] [ ] = 'bundles/metamodelscore/css/style.css' ; $ arrModule = $ GLOBALS [ 'BE_MOD' ] [ 'metamodels' ] [ 'metamodels' ] ; if ( \ Input :: get ( 'key' ) && isset ( $ arrModule [ \ Input :: get ( 'key' ) ] ) ) { Callbacks :: call ( $ arrModule [ \ Input :: get ( 'key' ) ] , $ this , $ arrModule ) ; } $ act = \ Input :: get ( 'act' ) ; if ( ! strlen ( $ act ) ) { $ act = 'showAll' ; } return $ this -> dataContainer -> getEnvironment ( ) -> getController ( ) -> handle ( new Action ( $ act ) ) ; }
11589	public function matrix ( ) { if ( $ this -> _matrix ) { return $ this -> _matrix ; } $ this -> _matrix = new Matrix ( $ this -> tasks ( ) ) ; $ this -> _matrix -> process ( ) ; return $ this -> _matrix ; }
12162	public function getForm ( $ primaryModel = false , $ settings = [ ] ) { if ( ! $ primaryModel ) { return false ; } $ formSegments = [ $ this -> getFormSegment ( $ primaryModel , $ settings ) ] ; $ config = [ 'class' => $ this -> formGeneratorClass , 'models' => $ primaryModel -> collectModels ( ) , 'items' => $ formSegments ] ; return Yii :: createObject ( $ config ) ; }
5599	public function tally ( ) { while ( list ( $ severity , $ message , $ file , $ line ) = $ this -> extract ( ) ) { $ severity = $ this -> getSeverityAsString ( $ severity ) ; $ this -> test -> error ( $ severity , $ message , $ file , $ line ) ; } while ( list ( $ expected , $ message ) = $ this -> extractExpectation ( ) ) { $ this -> test -> assert ( $ expected , false , '%s -> Expected error not caught' ) ; } }
6840	public function getData ( $ key ) { if ( isset ( $ this -> data [ $ key ] ) ) { return $ this -> data [ $ key ] ; } throw new InjectorException ( "data $key not found" ) ; }
12041	public function getFullName ( $ first = NULL , $ middle = NULL , $ last = NULL ) { $ user_first_name = $ this -> getPropertyValue ( "user_first_name" ) ; $ user_middle_name = $ this -> getPropertyValue ( "user_middle_name" ) ; $ user_last_name = $ this -> getPropertyValue ( "user_last_name" ) ; $ user_full_name = implode ( ' ' , array ( empty ( $ user_first_name ) ? $ first : $ user_first_name , empty ( $ user_middle_name ) ? $ middle : $ user_middle_name , empty ( $ user_last_name ) ? $ last : $ user_last_name ) ) ; if ( ! empty ( $ user_full_name ) ) { return $ user_full_name ; } }
847	public function getNextTokenOfKind ( $ index , array $ tokens = [ ] , $ caseSensitive = true ) { return $ this -> getTokenOfKindSibling ( $ index , 1 , $ tokens , $ caseSensitive ) ; }
9686	public function implode ( $ value , $ glue = null ) { $ new_collection = new Collection ( $ this -> toArray ( ) ) ; $ first = $ new_collection -> first ( ) ; if ( is_array ( $ first ) || is_object ( $ first ) ) { return implode ( $ glue , $ new_collection -> pluck ( $ value ) -> all ( ) ) ; } return implode ( $ value , $ new_collection -> all ( ) ) ; }
7394	public function replace ( $ in ) : void { $ this -> _massageBlockInput ( $ in ) ; if ( empty ( $ in ) ) { return ; } foreach ( $ in as $ k => $ v ) { if ( $ this -> _keyExists ( $ k ) ) { if ( $ this -> { $ k } instanceof TypedAbstract ) { $ this -> { $ k } -> replace ( $ v ) ; } else { $ this -> _setByName ( $ k , $ v ) ; } } } $ this -> _checkRelatedProperties ( ) ; }
7904	protected function renderSides ( $ sides ) { $ lines = [ ] ; $ lines [ ] = Html :: beginTag ( 'div' , $ this -> sidesOptions ) ; foreach ( $ sides as $ side ) { if ( ! array_key_exists ( 'content' , $ side ) ) { throw new InvalidConfigException ( "The 'content' option is required per sides" ) ; } $ options = ArrayHelper :: getValue ( $ side , 'options' , [ ] ) ; Ui :: addCssClass ( $ options , 'side' ) ; $ active = ArrayHelper :: getValue ( $ side , 'active' , false ) ; if ( $ active === true ) { Ui :: addCssClass ( $ options , 'active' ) ; } $ lines [ ] = Html :: tag ( 'div' , $ side [ 'content' ] , $ options ) ; } $ lines [ ] = Html :: endTag ( 'div' ) ; return implode ( "\n" , $ lines ) ; }
10871	public function existLogin ( string $ login ) : int { return ( int ) $ this -> connection -> select ( self :: COLUMN_ID ) -> from ( $ this -> tableIdentity ) -> where ( [ 'login' => $ login ] ) -> fetchSingle ( ) ; }
5197	protected function version ( ) { $ version = explode ( '(' , $ this -> app -> version ( ) ) ; if ( isset ( $ version [ 1 ] ) ) { return substr ( $ version [ 1 ] , 0 , 3 ) ; } return null ; }
5594	protected function createRequest ( $ url , $ encoding ) { $ request = $ this -> createHttpRequest ( $ url , $ encoding ) ; $ this -> addAdditionalHeaders ( $ request ) ; if ( $ this -> cookies_enabled ) { $ request -> readCookiesFromJar ( $ this -> cookie_jar , $ url ) ; } $ this -> authenticator -> addHeaders ( $ request , $ url ) ; if ( $ this -> http_referer ) { $ headers = $ request -> getHeaders ( ) ; if ( is_array ( $ headers ) ) { $ custom_referer = false ; foreach ( $ headers as $ header ) { if ( preg_match ( '~^referer:~i' , $ header ) ) { $ custom_referer = true ; break ; } } if ( ! $ custom_referer ) { $ request -> addHeaderLine ( 'Referer: ' . $ this -> http_referer ) ; } } } return $ request ; }
11118	protected function runDown ( array $ file ) : void { $ this -> notify -> note ( "<comment>Rolling back:</comment> {$file['basename']}" ) ; $ this -> runMigration ( $ file ) ; $ this -> repository -> delete ( $ this -> getMigrationName ( $ file ) ) ; $ this -> notify -> note ( "<info>Rolled back:</info> {$file['basename']}" ) ; }
12750	public function getUserAlias4User ( UserInterface $ user ) { if ( ! isset ( $ this -> userAliasCache [ $ user -> getUsername ( ) ] ) ) { $ userAliasEntityTmp = $ this -> getUserAliasEntity4User ( $ user ) ; if ( ! $ userAliasEntityTmp ) { $ userAliasEntityTmp = false ; } $ this -> userAliasCache [ $ user -> getUsername ( ) ] = $ userAliasEntityTmp ; } $ userAliasEntity = $ this -> userAliasCache [ $ user -> getUsername ( ) ] ; if ( $ userAliasEntity ) { $ result = $ userAliasEntity -> getCharName ( ) ; } else { $ result = $ user -> getUsername ( ) ; } return $ result ; }
6634	public function parseProfileResponse ( Response $ response , AccessTokenInterface $ access_token ) { $ profile = $ response -> json ( ) ; if ( gettype ( $ profile ) !== 'object' ) { throw new InvalidProfileException ( ) ; } if ( isset ( $ profile -> error ) ) { $ error = $ profile -> error ; throw new InvalidProfileException ( $ error -> type . ': ' . $ error -> message , $ error -> code ) ; } $ profile -> access_token = $ access_token -> token ( ) ; return $ this -> profile -> instantiate ( $ profile , $ this -> name ) ; }
5029	public function findForView ( $ id ) { $ type = $ this -> doctrine -> getConnection ( ) -> fetchColumn ( 'SELECT type FROM page WHERE id=:id' , array ( 'id' => $ id ) ) ; if ( ! $ type ) { throw new NotFoundHttpException ; } $ types = $ this -> em -> getClassMetadata ( $ this -> pageClassName ) -> discriminatorMap ; $ class = $ types [ $ type ] ; $ repos = $ this -> em -> getRepository ( $ class ) ; if ( $ repos instanceof ViewablePageRepository ) { $ ret = $ repos -> findForView ( $ id ) ; } else { $ ret = $ repos -> find ( $ id ) ; } if ( ! $ ret ) { throw new NotFoundHttpException ; } $ this -> setLoadedPage ( $ ret ) ; return $ ret ; }
11477	public function boot ( Plugin $ theme ) { $ this -> plugin = $ theme ; parent :: boot ( $ theme ) ; $ this -> initTemplates ( ) ; $ this -> initHomepageTemplate ( ) ; return $ this ; }
4466	private function normalizeCommandArgs ( string $ command , array $ args ) : array { $ arguments = array_merge ( [ $ command , microtime ( true ) ] , $ args ) ; array_unshift ( $ arguments , 0 ) ; array_unshift ( $ arguments , $ this -> sha ) ; return $ arguments ; }
627	public function bindParam ( $ name , & $ value , $ dataType = null , $ length = null , $ driverOptions = null ) { $ this -> prepare ( ) ; if ( $ dataType === null ) { $ dataType = $ this -> db -> getSchema ( ) -> getPdoType ( $ value ) ; } if ( $ length === null ) { $ this -> pdoStatement -> bindParam ( $ name , $ value , $ dataType ) ; } elseif ( $ driverOptions === null ) { $ this -> pdoStatement -> bindParam ( $ name , $ value , $ dataType , $ length ) ; } else { $ this -> pdoStatement -> bindParam ( $ name , $ value , $ dataType , $ length , $ driverOptions ) ; } $ this -> params [ $ name ] = & $ value ; return $ this ; }
7053	public static function get_instance ( ) { if ( ! self :: $ instance instanceof self ) { $ new = new self ; $ new -> init ( ) ; self :: $ instance = $ new ; } return self :: $ instance ; }
3581	protected function pluckMeta ( Builder $ query , ArgumentBag $ args , $ alias ) { list ( $ column , $ key ) = [ $ args -> get ( 'column' ) , $ args -> get ( 'key' ) ] ; $ query -> select ( "{$alias}.meta_value as {$column}" ) ; if ( ! is_null ( $ key ) ) { $ this -> metaSelectListsKey ( $ query , $ key ) ; } return $ query -> callParent ( 'pluck' , $ args -> all ( ) ) ; }
5610	public function paintCaseStart ( $ message ) { parent :: paintCaseStart ( $ message ) ; $ node = new TreemapNode ( 'TestCase' , $ message ) ; $ this -> _stack -> push ( $ node ) ; }
10380	protected static function is_modified_hash ( $ url , $ path ) { if ( self :: is_external_url ( $ url ) ) { if ( sha1_file ( $ url ) !== sha1_file ( $ path ) ) { self :: $ changes = true ; return self :: $ changes ; } } return false ; }
4526	protected function createZoneMemberZoneFromDefinition ( array $ definition ) { $ zone = $ this -> get ( $ definition [ 'zone' ] ) ; $ zoneMember = new ZoneMemberZone ( ) ; $ zoneMember -> setZone ( $ zone ) ; $ setValues = \ Closure :: bind ( function ( $ definition ) { $ this -> id = $ definition [ 'id' ] ; } , $ zoneMember , '\CommerceGuys\Zone\Model\ZoneMemberZone' ) ; $ setValues ( $ definition ) ; return $ zoneMember ; }
10739	public function supports ( $ query ) { foreach ( $ this -> engines as $ eachEngine ) { if ( $ eachEngine -> supports ( $ query ) ) { return true ; } } return false ; }
2797	public function getAdapter ( ) { if ( is_null ( $ this -> adapter ) ) { $ name = ucfirst ( strtolower ( $ this -> get ( 'adapter' ) ) ) ; $ class = '\\Humbug\\Adapter\\' . $ name ; $ this -> adapter = new $ class ; } return $ this -> adapter ; }
11666	public function addFunction ( $ functionName , $ callback ) { if ( is_string ( $ functionName ) && is_callable ( $ callback ) ) { $ functions = [ 'name' => $ functionName , 'callable' => $ callback , ] ; array_push ( $ this -> functionList , $ functions ) ; } }
7244	public function load_options ( ) { $ options = get_option ( self :: OPTION_KEY , '' ) ; if ( ! is_array ( $ options ) ) { $ options = self :: $ default_options ; update_option ( self :: OPTION_KEY , $ options ) ; } else { foreach ( self :: $ default_options as $ key => $ value ) { if ( ! isset ( $ options [ $ key ] ) ) $ options [ $ key ] = $ value ; } } $ this -> options = $ options ; }
1998	public function getLocale ( ) : string { foreach ( $ this -> getAcceptedLocales ( ) as $ locale ) { if ( file_exists ( $ this -> translationsDir . '/messages.' . $ locale . '.xlf' ) ) { return $ locale ; } } return 'en' ; }
2733	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ activateVcl = $ this -> getRequest ( ) -> getParam ( 'activate_flag' ) ; $ html = $ this -> getRequest ( ) -> getParam ( 'html' ) ; $ service = $ this -> api -> checkServiceDetails ( ) ; $ this -> vcl -> checkCurrentVersionActive ( $ service -> versions , $ activeVersion ) ; $ currActiveVersion = $ this -> vcl -> getCurrentVersion ( $ service -> versions ) ; $ clone = $ this -> api -> cloneVersion ( $ currActiveVersion ) ; $ snippets = $ this -> config -> getVclSnippets ( Config :: VCL_ERROR_SNIPPET_PATH , Config :: VCL_ERROR_SNIPPET ) ; foreach ( $ snippets as $ key => $ value ) { $ snippetData = [ 'name' => Config :: FASTLY_MAGENTO_MODULE . '_error_page_' . $ key , 'type' => $ key , 'dynamic' => '0' , 'content' => $ value ] ; $ this -> api -> uploadSnippet ( $ clone -> number , $ snippetData ) ; } $ condition = [ 'name' => Config :: FASTLY_MAGENTO_MODULE . '_error_page_condition' , 'statement' => 'req.http.ResponseObject == "970"' , 'type' => 'REQUEST' , 'priority' => '9' ] ; $ createCondition = $ this -> api -> createCondition ( $ clone -> number , $ condition ) ; $ response = [ 'name' => Config :: ERROR_PAGE_RESPONSE_OBJECT , 'request_condition' => $ createCondition -> name , 'content' => $ html , 'status' => "503" , 'content_type' => "text/html; charset=utf-8" , 'response' => "Service Temporarily Unavailable" ] ; $ createResponse = $ this -> api -> createResponse ( $ clone -> number , $ response ) ; if ( ! $ createResponse ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to create a RESPONSE object.' ] ) ; } $ this -> api -> validateServiceVersion ( $ clone -> number ) ; if ( $ activateVcl === 'true' ) { $ this -> api -> activateVersion ( $ clone -> number ) ; } if ( $ this -> config -> areWebHooksEnabled ( ) && $ this -> config -> canPublishConfigChanges ( ) ) { $ this -> api -> sendWebHook ( '*New Error/Maintenance page has updated and activated under config version ' . $ clone -> number . '*' ) ; } $ comment = [ 'comment' => 'Magento Module updated Error Page html' ] ; $ this -> api -> addComment ( $ clone -> number , $ comment ) ; return $ result -> setData ( [ 'status' => true , 'active_version' => $ clone -> number ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
11541	public function editProfile ( $ data ) { if ( ! ( $ user = $ this -> hydrate ( $ data , $ this -> getEditProfileForm ( ) ) ) ) { return ; } $ eventManager = $ this -> getEventManager ( ) ; $ eventManager -> trigger ( __FUNCTION__ , $ this , compact ( 'user' ) ) ; $ this -> getMapper ( ) -> update ( $ user ) -> save ( ) ; $ eventManager -> trigger ( __FUNCTION__ . '.post' , $ this , compact ( 'user' ) ) ; return $ user ; }
8554	public function setLoanServicingEventList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'LoanServicingEventList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
6136	public function folderSearch ( FolderSearch $ search ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'search' => $ search ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/search/folder' , $ parameters ) ; $ result = new SearchResult ( $ result ) ; return $ result ; }
6627	public function getData ( $ defaultValue = null ) { return ArrayHelper :: getValue ( $ this -> parsedResponse , self :: RESPONSE_DATA_PARAM , $ defaultValue ) ; }
9038	protected function execute ( QueryBuilder $ builder ) : ? Result { return $ this -> connection -> queryArgs ( $ builder -> getQuerySql ( ) , $ builder -> getQueryParameters ( ) ) ; }
7644	protected function parseMetadataElement ( $ element = null ) { if ( ! is_null ( $ element ) && isset ( $ element -> Metadata ) && ! is_null ( $ element -> Metadata ) ) { return get_object_vars ( $ element -> Metadata ) ; } return array ( ) ; }
11961	public function each ( Closure $ fn ) { foreach ( $ this -> elements as $ key => $ element ) { if ( $ fn ( $ element , $ key ) === false ) { return false ; } } return true ; }
6932	private function isShipmentAmountInvoiced ( Invoice \ InvoiceInterface $ invoice ) { $ sale = $ invoice -> getSale ( ) ; foreach ( $ sale -> getInvoices ( ) as $ i ) { if ( $ i === $ invoice ) { continue ; } if ( $ i -> hasLineByType ( Document \ DocumentLineTypes :: TYPE_SHIPMENT ) ) { return true ; } } return false ; }
12395	abstract public function __construct ( ConnectionInterface $ connection ) ;
8618	public function removeBlock ( $ spec ) { if ( $ spec instanceof Block ) $ spec = $ spec -> getKey ( ) ; if ( is_string ( $ spec ) ) { if ( $ this -> blocks [ $ spec ] ) { unset ( $ this -> blocks [ $ spec ] ) ; } } }
12129	public function failed ( $ fail = true ) { if ( ! func_num_args ( ) ) { return $ this -> _failed ; } $ this -> _failed = $ fail ; return $ this ; }
134	public function isPackageInstalled ( InstalledRepositoryInterface $ repo , PackageInterface $ package ) { if ( $ package instanceof AliasPackage ) { return $ repo -> hasPackage ( $ package ) && $ this -> isPackageInstalled ( $ repo , $ package -> getAliasOf ( ) ) ; } return $ this -> getInstaller ( $ package -> getType ( ) ) -> isInstalled ( $ repo , $ package ) ; }
10286	public static function stringFromColumnIndex ( $ columnIndex ) { static $ indexCache = [ ] ; if ( ! isset ( $ indexCache [ $ columnIndex ] ) ) { $ indexValue = $ columnIndex ; $ base26 = null ; do { $ characterValue = ( $ indexValue % 26 ) ? : 26 ; $ indexValue = ( $ indexValue - $ characterValue ) / 26 ; $ base26 = chr ( $ characterValue + 64 ) . ( $ base26 ? : '' ) ; } while ( $ indexValue > 0 ) ; $ indexCache [ $ columnIndex ] = $ base26 ; } return $ indexCache [ $ columnIndex ] ; }
7446	public function updateAction ( $ id ) { $ em = $ this -> getDoctrine ( ) -> getEntityManager ( ) ; $ group = $ em -> getRepository ( 'Orkestra\Bundle\ApplicationBundle\Entity\Group' ) -> find ( $ id ) ; if ( ! $ group ) { throw $ this -> createNotFoundException ( 'Unable to locate Group' ) ; } $ form = $ this -> createForm ( GroupType :: class , $ group ) ; $ form -> bindRequest ( $ this -> getRequest ( ) ) ; if ( $ form -> isValid ( ) ) { $ em -> persist ( $ group ) ; $ em -> flush ( ) ; $ this -> get ( 'session' ) -> getFlashBag ( ) -> set ( 'success' , 'Your changes have been saved.' ) ; return $ this -> redirect ( $ this -> generateUrl ( 'orkestra_group_show' , array ( 'id' => $ id ) ) ) ; } return array ( 'group' => $ group , 'form' => $ form -> createView ( ) , ) ; }
6242	public function reload ( ) : self { if ( $ this -> loaded === false ) { return $ this ; } clearstatcache ( false , $ this -> raw ) ; $ this -> loaded = false ; return $ this ; }
2964	public function performRequest ( $ method , $ path , array $ params = [ ] ) { $ request = $ this -> buildRequest ( $ method , $ path , $ params ) ; try { $ response = $ this -> httpClient -> send ( $ request ) ; $ content = json_decode ( $ response -> getBody ( ) -> getContents ( ) , true ) ; } catch ( ClientException $ ex ) { if ( $ ex -> getResponse ( ) -> getStatusCode ( ) == 401 ) { if ( $ this -> isPsr7Version ( ) ) { $ uri = $ request -> getUri ( ) ; } else { $ uri = $ request -> getUrl ( ) ; } $ message = sprintf ( 'Unauthorized %s Request to %s' , $ request -> getMethod ( ) , $ uri ) ; throw new UnauthorizedRequestException ( $ message ) ; } throw $ ex ; } return $ this -> createResponseFromData ( $ content ) ; }
2165	public static function convertMultiField ( $ table , $ field ) { $ objDatabase = Database :: getInstance ( ) ; $ objRow = $ objDatabase -> query ( "SELECT id, $field FROM $table WHERE $field!=''" ) ; $ objDesc = $ objDatabase -> query ( "DESC $table $field" ) ; if ( $ objDesc -> Type != 'blob' ) { $ objDatabase -> query ( "ALTER TABLE `$table` CHANGE `$field` `$field` blob NULL" ) ; $ objDatabase -> query ( "UPDATE `$table` SET `$field`=NULL WHERE `$field`=''" ) ; } while ( $ objRow -> next ( ) ) { $ arrValues = StringUtil :: deserialize ( $ objRow -> $ field , true ) ; if ( empty ( $ arrValues ) ) { continue ; } $ objHelper = static :: generateHelperObject ( $ arrValues ) ; if ( $ objHelper -> isUuid ) { continue ; } foreach ( $ arrValues as $ k => $ v ) { if ( $ objHelper -> isNumeric ) { $ objFile = FilesModel :: findByPk ( $ objHelper -> value [ $ k ] ) ; $ arrValues [ $ k ] = $ objFile -> uuid ; } else { $ objFile = FilesModel :: findByPath ( $ objHelper -> value [ $ k ] ) ; $ arrValues [ $ k ] = $ objFile -> uuid ; } } $ objDatabase -> prepare ( "UPDATE $table SET $field=? WHERE id=?" ) -> execute ( serialize ( $ arrValues ) , $ objRow -> id ) ; } }
8192	public static function guess ( $ name ) { if ( in_array ( substr ( $ name , - 1 ) , array ( '/' , '\\' ) ) ) { return 'html' ; } if ( '.twig' === substr ( $ name , - 5 ) ) { $ name = substr ( $ name , 0 , - 5 ) ; } $ extension = pathinfo ( $ name , PATHINFO_EXTENSION ) ; switch ( $ extension ) { case 'js' : return 'js' ; case 'css' : return 'css' ; case 'txt' : return false ; default : return 'html' ; } }
3276	public function flush ( ) { $ this -> getDatabase ( ) -> flushFile ( ) ; if ( $ cache = $ this -> getConfig ( ) -> getCache ( ) ) { $ cache -> flush ( ) ; } }
9758	function closeTo ( $ value , float $ delta ) : self { return $ this -> expect ( $ this -> target , equalTo ( $ value , $ delta ) ) ; }
5062	public function output ( ) : string { if ( is_null ( $ this -> buffer ) ) { $ this -> exec ( ) ; } curl_close ( $ this -> ch ) ; if ( strlen ( $ this -> buffer ) === 0 ) { throw new NoOutputException ( ) ; } return $ this -> buffer ; }
7983	public function addRestoreTask ( $ sessionId ) { return json_decode ( self :: getClient ( ) -> createPcaRestoreTask ( $ this -> pp , $ this -> sn , $ sessionId ) ) ; }
8127	public static function findByUsernameOrEmail ( $ emailOrUsername ) { if ( filter_var ( $ emailOrUsername , FILTER_VALIDATE_EMAIL ) ) { return UserIdentity :: findByEmail ( $ emailOrUsername ) ; } return UserIdentity :: findByUsername ( $ emailOrUsername ) ; }
7694	function MsExcel_GetDrawingLst ( ) { $ lst = array ( ) ; $ dir = '../drawings/' ; $ dir_len = strlen ( $ dir ) ; $ o = $ this -> OpenXML_Rels_GetObj ( $ this -> TBS -> OtbsCurrFile , $ dir ) ; foreach ( $ o -> TargetLst as $ t ) { if ( ( substr ( $ t , 0 , $ dir_len ) === $ dir ) && ( substr ( $ t , - 4 ) === '.xml' ) ) $ lst [ ] = 'xl/drawings/' . substr ( $ t , $ dir_len ) ; } return $ lst ; }
12894	public function close ( $ account , $ openId ) { $ params = [ 'kf_account' => $ account , 'openid' => $ openId , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_CLOSE , $ params ] ) ; }
6887	private function httpGet ( $ path , array $ query = array ( ) ) { $ url = new Uri ( $ this -> baseUrl . $ path ) ; foreach ( $ query as $ name => $ value ) { $ url = Uri :: withQueryValue ( $ url , $ name , $ value ) ; } $ request = new Request ( 'GET' , $ url , $ this -> buildHeaders ( ) ) ; try { $ response = $ this -> getHttpClient ( ) -> sendRequest ( $ request ) ; } catch ( \ RuntimeException $ e ) { throw new Exception \ PostcodeException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } if ( $ response -> getStatusCode ( ) != 200 ) { throw $ this -> createErrorException ( $ response ) ; } return $ response ; }
10636	protected function resolvePaths ( array $ fixPaths ) { $ this -> rootDir = \ realpath ( isset ( $ fixPaths [ 'rootDir' ] ) ? $ fixPaths [ 'rootDir' ] : __DIR__ . '/../../../../' ) ; $ this -> packageDir = \ realpath ( isset ( $ fixPaths [ 'packageDir' ] ) ? $ fixPaths [ 'packageDir' ] : __DIR__ . '/../' ) ; $ this -> configPath = Utils :: fixPath ( isset ( $ fixPaths [ 'configPath' ] ) ? $ fixPaths [ 'configPath' ] : '/app/' ) ; if ( $ this -> rootDir === false || $ this -> packageDir === false ) throw new \ InvalidArgumentException ( 'Bootstrap directories do not exists or are not accessible' ) ; if ( $ this [ 'minion.usePropel' ] ) { $ this -> propelConfigPath = \ realpath ( isset ( $ fixPaths [ 'propelConfigPath' ] ) ? $ fixPaths [ 'propelConfigPath' ] : Utils :: fixPath ( $ this -> packageDir . '/propel.php' ) ) ; if ( $ this -> propelConfigPath === false ) throw new \ InvalidArgumentException ( 'Propel configuration file in vendor Minion not found' ) ; } }
9353	public function inverse ( ) { $ det = $ this -> det ( ) ; if ( $ det == 0 ) { throw new \ RuntimeException ( 'Cannot get inverse matrix: determinant is nul!' ) ; } return $ this -> adjugate ( ) -> multiply ( 1 / $ det ) ; }
8478	public function log ( $ level , $ message , array $ context = [ ] ) { if ( $ this -> config ( 'requiredScope' ) && ( empty ( $ context [ 'scope' ] ) ) ) return false ; $ scopes = ( empty ( $ context [ 'scope' ] ) ) ? [ null ] : $ context [ 'scope' ] ; unset ( $ context [ 'scope' ] ) ; $ this -> _context = $ context ; $ Table = TableRegistry :: get ( $ this -> config ( 'model' ) , [ 'table' => $ this -> config ( 'table' ) ] ) ; foreach ( $ scopes as $ scope ) { $ entity = $ Table -> newEntity ( ) ; $ data = [ 'level' => $ level , 'user_id' => $ this -> _userId ( ) , 'scope' => $ scope , 'message' => $ message , 'context' => $ this -> _context , ] ; $ entity = $ Table -> patchEntity ( $ entity , $ data ) ; $ Table -> save ( $ entity ) ; } return true ; }
12668	public function setCacheOptions ( $ cacheOptions ) { if ( $ cacheOptions instanceof CacheOptionsInterface ) { $ this -> cacheOptions = $ cacheOptions ; } elseif ( is_array ( $ cacheOptions ) ) { $ this -> cacheOptions = new CacheOptions ( $ cacheOptions ) ; } else { throw new Exception \ InvalidArgumentException ( sprintf ( '%s expects parameter 1 to be array or an instance of HtSettingsModule\Options\CacheOptionsInterface, %s provided instead' , __METHOD__ , is_object ( $ cacheOptions ) ? get_class ( $ cacheOptions ) : gettype ( $ cacheOptions ) ) ) ; } return $ this ; }
343	protected function renderSortLinks ( ) { $ attributes = empty ( $ this -> attributes ) ? array_keys ( $ this -> sort -> attributes ) : $ this -> attributes ; $ links = [ ] ; foreach ( $ attributes as $ name ) { $ links [ ] = $ this -> sort -> link ( $ name , $ this -> linkOptions ) ; } return Html :: ul ( $ links , array_merge ( $ this -> options , [ 'encode' => false ] ) ) ; }
2098	public static function formatToJs ( $ strFormat ) { $ chunks = str_split ( $ strFormat ) ; foreach ( $ chunks as $ k => $ v ) { switch ( $ v ) { case 'D' : $ chunks [ $ k ] = 'a' ; break ; case 'j' : $ chunks [ $ k ] = 'e' ; break ; case 'l' : $ chunks [ $ k ] = 'A' ; break ; case 'S' : $ chunks [ $ k ] = 'o' ; break ; case 'F' : $ chunks [ $ k ] = 'B' ; break ; case 'M' : $ chunks [ $ k ] = 'b' ; break ; case 'a' : $ chunks [ $ k ] = 'p' ; break ; case 'A' : $ chunks [ $ k ] = 'p' ; break ; case 'g' : $ chunks [ $ k ] = 'l' ; break ; case 'G' : $ chunks [ $ k ] = 'k' ; break ; case 'h' : $ chunks [ $ k ] = 'I' ; break ; case 'i' : $ chunks [ $ k ] = 'M' ; break ; case 's' : $ chunks [ $ k ] = 'S' ; break ; case 'U' : $ chunks [ $ k ] = 's' ; break ; } } return preg_replace ( '/([a-zA-Z])/' , '%$1' , implode ( '' , $ chunks ) ) ; }
7293	public function save_transit_posts ( $ new_status , $ old_status , $ post ) { $ this -> transit_posts [ $ post -> ID ] = array ( 'old_status' => $ old_status , 'new_status' => $ new_status ) ; }
12405	public function approveAction ( Request $ request , Application $ app ) { $ options = array ( "request" => $ request , "page_manager" => $ app [ "red_kite_cms.page_manager" ] , "username" => $ this -> fetchUsername ( $ app [ "security" ] , $ app [ "red_kite_cms.configuration_handler" ] ) , ) ; return parent :: approve ( $ options ) ; }
7532	function html ( $ value = null ) { if ( $ value !== null ) { $ this -> setInnerText ( $ value ) ; } return $ this -> getInnerText ( ) ; }
1644	public function simplify ( Polyline $ polyline ) : Polyline { $ counterPoints = $ polyline -> getNumberOfPoints ( ) ; if ( $ counterPoints < 3 ) { return clone $ polyline ; } $ result = new Polyline ( ) ; $ bearingCalc = new BearingEllipsoidal ( ) ; $ points = $ polyline -> getPoints ( ) ; $ index = 0 ; $ result -> addPoint ( $ points [ $ index ] ) ; do { $ index ++ ; if ( $ index === ( $ counterPoints - 1 ) ) { $ result -> addPoint ( $ points [ $ index ] ) ; break ; } $ bearing1 = $ bearingCalc -> calculateBearing ( $ points [ $ index - 1 ] , $ points [ $ index ] ) ; $ bearing2 = $ bearingCalc -> calculateBearing ( $ points [ $ index ] , $ points [ $ index + 1 ] ) ; $ bearingDifference = min ( fmod ( $ bearing1 - $ bearing2 + 360 , 360 ) , fmod ( $ bearing2 - $ bearing1 + 360 , 360 ) ) ; if ( $ bearingDifference > $ this -> bearingAngle ) { $ result -> addPoint ( $ points [ $ index ] ) ; } } while ( $ index < $ counterPoints ) ; return $ result ; }
3663	private function getValueFromServiceContainer ( $ valueName , $ arguments ) { if ( ! empty ( $ arguments [ 'service' ] ) ) { $ serviceName = $ arguments [ 'service' ] ; } else { $ serviceName = $ valueName ; } $ service = $ this -> container -> get ( IMetaModelsServiceContainer :: class ) -> getService ( $ serviceName ) ; if ( is_callable ( $ service ) ) { return call_user_func ( $ service , $ valueName , $ arguments ) ; } return 'NULL' ; }
7117	protected function getFindBySubjectQuery ( ) { if ( null !== $ this -> findBySubjectQuery ) { return $ this -> findBySubjectQuery ; } $ qb = $ this -> createFindBySubjectQueryBuilder ( ) ; return $ this -> findBySubjectQuery = $ qb -> getQuery ( ) ; }
984	public function usageCharge ( StoreUsageCharge $ request ) { $ validated = $ request -> validated ( ) ; $ uc = new UsageCharge ( ShopifyApp :: shop ( ) , $ validated ) ; $ uc -> activate ( ) ; $ uc -> save ( ) ; return isset ( $ validated [ 'redirect' ] ) ? Redirect :: to ( $ validated [ 'redirect' ] ) -> with ( 'success' , 'usage_charge' ) : Redirect :: back ( ) -> with ( 'success' , 'usage_charge' ) ; }
228	public function getTableNames ( $ schema = '' , $ refresh = false ) { if ( ! isset ( $ this -> _tableNames [ $ schema ] ) || $ refresh ) { $ this -> _tableNames [ $ schema ] = $ this -> findTableNames ( $ schema ) ; } return $ this -> _tableNames [ $ schema ] ; }
12587	public function init ( ) { parent :: init ( ) ; $ db = $ this -> getDbConnection ( ) ; $ db -> setActive ( true ) ; if ( $ this -> autoCreateTokenTable ) { $ sql = "DELETE FROM {$this->tokenTableName} WHERE (expires>0 AND expires<" . time ( ) . ") OR (uses_allowed>0 AND uses_remaining<1)" ; try { $ db -> createCommand ( $ sql ) -> execute ( ) ; } catch ( Exception $ e ) { $ this -> createTokenTable ( $ db , $ this -> tokenTableName ) ; } } }
8680	public function sortKeys ( $ order = SORT_ASC , $ flags = SORT_REGULAR ) { $ this -> validateSortArgs ( $ order , $ flags ) ; $ items = $ this -> items ; if ( $ order === SORT_ASC ) { ksort ( $ items , $ flags ) ; } else { krsort ( $ items , $ flags ) ; } return $ this -> createFrom ( $ items ) ; }
8153	public function removeExtension ( $ name ) { @ trigger_error ( sprintf ( 'The %s method is deprecated since version 1.12 and will be removed in Twig 2.0.' , __METHOD__ ) , E_USER_DEPRECATED ) ; if ( $ this -> extensionInitialized ) { throw new LogicException ( sprintf ( 'Unable to remove extension "%s" as extensions have already been initialized.' , $ name ) ) ; } $ class = ltrim ( $ name , '\\' ) ; if ( ! isset ( $ this -> extensionsByClass [ $ class ] ) && class_exists ( $ class , false ) ) { $ class = new ReflectionClass ( $ class ) ; $ class = $ class -> name ; } if ( isset ( $ this -> extensions [ $ class ] ) ) { if ( $ class !== get_class ( $ this -> extensions [ $ class ] ) ) { @ trigger_error ( sprintf ( 'Referencing the "%s" extension by its name (defined by getName()) is deprecated since 1.26 and will be removed in Twig 2.0. Use the Fully Qualified Extension Class Name instead.' , $ class ) , E_USER_DEPRECATED ) ; } unset ( $ this -> extensions [ $ class ] ) ; } unset ( $ this -> extensions [ $ class ] ) ; $ this -> updateOptionsHash ( ) ; }
11575	public function actionRegister ( ) { if ( ! $ this -> module -> enableRegistration ) { throw new NotFoundHttpException ; } $ model = \ Yii :: createObject ( RegistrationForm :: className ( ) ) ; $ this -> performAjaxValidation ( $ model ) ; if ( $ model -> load ( \ Yii :: $ app -> request -> post ( ) ) && $ model -> register ( ) ) { return $ this -> render ( '/message' , [ 'title' => \ Yii :: t ( 'user' , 'Your account has been created' ) , 'module' => $ this -> module , ] ) ; } return $ this -> render ( 'register' , [ 'model' => $ model , 'module' => $ this -> module , ] ) ; }
9099	public function serve ( ServiceCallback $ callback ) { $ this -> bind ( ) ; $ this -> listen ( ) ; $ runOn = true ; while ( $ runOn ) { $ clientHandle = @ socket_accept ( $ this -> handle ) ; if ( ! is_resource ( $ clientHandle ) ) { $ code = socket_last_error ( $ this -> handle ) ; throw new SocketException ( socket_strerror ( $ code ) , array ( ) , $ code ) ; } $ address = null ; $ port = 0 ; if ( ! @ socket_getpeername ( $ clientHandle , $ address , $ port ) ) { $ code = socket_last_error ( $ clientHandle ) ; throw new SocketException ( socket_strerror ( $ code ) , array ( ) , $ code ) ; } $ client = new ClientSocket ( new Endpoint ( $ address , $ port ) , $ clientHandle ) ; $ runOn = boolval ( $ callback -> callback ( $ client ) ) ; } }
2675	public function aclItemsList ( $ aclId ) { $ url = $ this -> _getApiServiceUri ( ) . 'acl/' . $ aclId . '/entries' ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: GET ) ; return $ result ; }
10606	public function addHeader ( string $ header , $ value ) : void { if ( is_iterable ( $ value ) || is_array ( $ value ) ) { $ iterable = $ value ; $ value = [ ] ; foreach ( $ iterable as $ key => $ entry ) { $ value [ $ key ] = ( string ) $ entry ; } } else { $ value = ( string ) $ value ; } $ this -> headers [ ] = [ $ header , $ value ] ; }
10102	public function writeUrlInternal ( $ row1 , $ col1 , $ row2 , $ col2 , $ url ) { $ record = 0x01B8 ; $ length = 0x00000 ; $ url = preg_replace ( '/^internal:/' , '' , $ url ) ; $ unknown1 = pack ( 'H*' , 'D0C9EA79F9BACE118C8200AA004BA90B02000000' ) ; $ options = pack ( 'V' , 0x08 ) ; $ url .= "\0" ; $ url_len = StringHelper :: countCharacters ( $ url ) ; $ url_len = pack ( 'V' , $ url_len ) ; $ url = StringHelper :: convertEncoding ( $ url , 'UTF-16LE' , 'UTF-8' ) ; $ length = 0x24 + strlen ( $ url ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vvvv' , $ row1 , $ row2 , $ col1 , $ col2 ) ; $ this -> append ( $ header . $ data . $ unknown1 . $ options . $ url_len . $ url ) ; return 0 ; }
2532	protected function loadOptionalSegmentInformation ( $ options ) { if ( ! empty ( $ options -> operatingCompany ) ) { $ this -> segmentInformation -> companyDetails -> operatingCompany = $ options -> operatingCompany ; } if ( $ options -> arrivalDate instanceof \ DateTime ) { $ this -> segmentInformation -> flightDate -> setArrivalDate ( $ options -> arrivalDate ) ; } if ( ! empty ( $ options -> groupNumber ) ) { $ this -> segmentInformation -> flightTypeDetails = new FlightTypeDetails ( $ options -> groupNumber ) ; } $ this -> loadAdditionalSegmentDetails ( $ options -> airplaneCode , $ options -> nrOfStops ) ; }
6306	private function register ( array $ providers , array $ values ) { foreach ( $ providers as $ provider ) { $ factories = $ provider -> getFactories ( ) ; foreach ( $ factories as $ key => $ callable ) { $ this [ $ key ] = function ( ContainerInterface $ c ) use ( $ callable ) { return call_user_func ( $ callable , $ c ) ; } ; } } foreach ( $ providers as $ provider ) { $ extensions = $ provider -> getExtensions ( ) ; foreach ( $ extensions as $ key => $ callable ) { if ( isset ( $ this -> keys [ $ key ] ) ) { $ this [ $ key ] = $ this -> extend ( $ key , function ( $ previous , ContainerInterface $ c ) use ( $ callable ) { return call_user_func ( $ callable , $ c , $ previous ) ; } ) ; } else { $ this [ $ key ] = function ( ContainerInterface $ c ) use ( $ callable ) { return call_user_func ( $ callable , $ c ) ; } ; } } } foreach ( $ values as $ key => $ value ) { $ this [ $ key ] = $ value ; } }
6955	private function getTaxesRates ( ShipmentMethodInterface $ method , CountryInterface $ country ) { return array_map ( function ( TaxInterface $ tax ) { return $ tax -> getRate ( ) ; } , $ this -> taxResolver -> resolveTaxes ( $ method , $ country ) ) ; }
6387	public function readDiscussion ( $ id ) { $ model = $ this -> readObject ( $ id , 'forum_discussions' ) ; $ model -> url = $ this -> cfg -> wwwroot . '/mod/forum/discuss.php?d=' . $ id ; return $ model ; }
11007	public function requireSriFor ( bool $ script , bool $ style ) : void { if ( $ script && $ style ) { $ this -> tags [ 'require-sri-for' ] = [ 'script' , 'style' ] ; } else if ( $ script ) { $ this -> tags [ 'require-sri-for' ] = [ 'script' ] ; } else if ( $ style ) { $ this -> tags [ 'require-sri-for' ] = [ 'style' ] ; } }
7473	public function editAction ( $ id ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ user = $ em -> getRepository ( 'Orkestra\Bundle\ApplicationBundle\Entity\User' ) -> find ( $ id ) ; if ( ! $ user ) { throw $ this -> createNotFoundException ( 'Unable to locate User' ) ; } $ form = $ this -> createForm ( UserType :: class , $ user , array ( 'include_password' => false ) ) ; return array ( 'user' => $ user , 'form' => $ form -> createView ( ) , ) ; }
1659	public static function create ( $ reply = null ) { $ suggestion = new self ( ) ; if ( $ reply ) { $ suggestion -> reply ( $ reply ) ; } return $ suggestion ; }
428	public function init ( ) { if ( $ this -> controllerNamespace === null ) { $ class = get_class ( $ this ) ; if ( ( $ pos = strrpos ( $ class , '\\' ) ) !== false ) { $ this -> controllerNamespace = substr ( $ class , 0 , $ pos ) . '\\controllers' ; } } }
2302	public static function getDcaPickerWizard ( $ extras , $ table , $ field , $ inputName ) { $ context = 'link' ; $ extras = \ is_array ( $ extras ) ? $ extras : array ( ) ; $ providers = ( isset ( $ extras [ 'providers' ] ) && \ is_array ( $ extras [ 'providers' ] ) ) ? $ extras [ 'providers' ] : null ; if ( isset ( $ extras [ 'context' ] ) ) { $ context = $ extras [ 'context' ] ; unset ( $ extras [ 'context' ] ) ; } $ factory = System :: getContainer ( ) -> get ( 'contao.picker.builder' ) ; if ( ! $ factory -> supportsContext ( $ context , $ providers ) ) { return '' ; } return ' <a href="' . ampersand ( $ factory -> getUrl ( $ context , $ extras ) ) . '" title="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'pagepicker' ] ) . '" id="pp_' . $ inputName . '">' . Image :: getHtml ( ( \ is_array ( $ extras ) && isset ( $ extras [ 'icon' ] ) ? $ extras [ 'icon' ] : 'pickpage.svg' ) , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'pagepicker' ] ) . '</a> <script> $("pp_' . $ inputName . '").addEvent("click", function(e) { e.preventDefault(); Backend.openModalSelector({ "id": "tl_listing", "title": ' . json_encode ( $ GLOBALS [ 'TL_DCA' ] [ $ table ] [ 'fields' ] [ $ field ] [ 'label' ] [ 0 ] ) . ', "url": this.href + "&value=" + document.getElementById("ctrl_' . $ inputName . '").value, "callback": function(picker, value) { $("ctrl_' . $ inputName . '").value = value.join(","); }.bind(this) }); }); </script>' ; }
4950	public function createDraft ( array $ data = null , $ persist = false ) { $ data [ 'isDraft' ] = true ; return $ this -> create ( $ data , $ persist ) ; }
8386	public function having ( $ having ) { $ this -> having = ( $ having instanceof Condition ? $ having : new Condition ( $ having ) ) ; return $ this ; }
3038	public function get ( $ userId , $ callId ) { $ key = $ this -> getCacheKey ( $ userId , $ callId ) ; if ( ! isset ( $ this -> cache [ $ key ] ) ) { $ data = $ this -> getStorage ( ) -> get ( $ userId , $ callId ) ; $ state = is_null ( $ data ) ? self :: STATE_NOT_FOUND : self :: STATE_ALIGNED ; $ this -> putInCache ( $ key , $ userId , $ callId , $ data , $ state ) ; } return $ this -> getFromCache ( $ key ) ; }
11984	public function boot ( ) { if ( $ this -> booted ) { return $ this ; } if ( extension_loaded ( 'pinba' ) ) { ini_set ( 'pinba.enabled' , false ) ; } if ( extension_loaded ( 'newrelic' ) ) { ini_set ( 'newrelic.enabled' , false ) ; } if ( ! empty ( $ this -> settings [ 'timezone' ] ) ) { date_default_timezone_set ( $ this -> settings [ 'timezone' ] ) ; } $ this -> booted = true ; return $ this ; }
3432	protected function normalizeSelect ( ) { if ( $ this -> fieldsMustBeSelected ( ) ) { $ this -> select = array_merge ( $ this -> standardFields , $ this -> select ) ; } if ( $ this -> propsMustBeSelected ( ) ) { $ this -> select [ ] = 'IBLOCK_ID' ; $ this -> select [ ] = 'UF_*' ; } $ this -> select [ ] = 'ID' ; return $ this -> clearSelectArray ( ) ; }
2628	protected function getOptions ( $ label = false ) { $ options = [ ] ; foreach ( $ this -> _storeManager -> getStores ( ) as $ store ) { $ options [ ] = [ 'value' => $ store -> getId ( ) , 'label' => $ store -> getName ( ) ] ; } if ( $ label ) { array_unshift ( $ options , [ 'value' => '' , 'label' => $ label ] ) ; } return $ options ; }
5219	public static function castFrom ( $ predicate ) { if ( $ predicate instanceof self ) { return $ predicate ; } elseif ( is_callable ( $ predicate ) ) { return new CallablePredicate ( $ predicate ) ; } throw new \ InvalidArgumentException ( 'Given predicate is neither a callable nor an instance of ' . __CLASS__ ) ; }
10435	public function post ( $ request ) { if ( $ request instanceof Request ) { $ request = $ request -> xml ( ) ; } $ ch = curl_init ( ) ; curl_setopt ( $ ch , CURLOPT_URL , $ this -> url ) ; if ( $ this -> user_agent != null ) { curl_setopt ( $ ch , CURLOPT_USERAGENT , $ this -> user_agent ) ; } curl_setopt ( $ ch , CURLOPT_HEADER , 0 ) ; curl_setopt ( $ ch , CURLOPT_RETURNTRANSFER , 1 ) ; curl_setopt ( $ ch , CURLOPT_POST , 1 ) ; curl_setopt ( $ ch , CURLOPT_POSTFIELDS , $ request ) ; curl_setopt ( $ ch , CURLOPT_HTTPHEADER , array ( 'Content-type: application/xml; charset=utf-8' , ) ) ; $ response = curl_exec ( $ ch ) ; curl_close ( $ ch ) ; if ( empty ( $ response ) ) { return null ; } return $ response ; }
11548	public function getGroup ( $ name ) { if ( array_key_exists ( $ name , $ this -> groups ) ) { return $ this -> groups [ $ name ] ; } throw new KeyNotFoundInSetException ( $ name , array_keys ( $ this -> groups ) , 'groups' ) ; }
3791	protected function fetchExistingIdsFor ( $ idList , $ langCode ) { $ queryBuilder = $ this -> connection -> createQueryBuilder ( ) -> select ( 'item_id' ) -> from ( $ this -> getValueTable ( ) ) ; $ this -> buildWhere ( $ queryBuilder , $ idList , $ langCode ) ; $ statement = $ queryBuilder -> execute ( ) ; return $ statement -> fetchAll ( \ PDO :: FETCH_COLUMN ) ; }
8784	protected function log ( $ level , $ message ) { if ( is_array ( $ message ) || is_object ( $ message ) ) { $ message = print_r ( $ message , true ) ; } $ text = '[' . date ( $ this -> timeFormat , time ( ) ) . '] - [' . strtoupper ( $ level ) . '] - [' . http ( ) -> getClientIP ( ) . '] . $ message ; $ this -> save ( $ text ) ; }
8612	public function setMarketplace ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'Marketplace' ] [ 'FieldValue' ] = $ value ; return $ this ; }
8954	public function createWay ( $ changeset , $ tags , $ nds ) { $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = 'way/create' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ tagList = '' ; if ( ! empty ( $ tags ) ) { foreach ( $ tags as $ key => $ value ) { $ tagList .= '<tag k="' . $ key . '" v="' . $ value . '"/>' ; } } $ ndList = '' ; if ( ! empty ( $ nds ) ) { foreach ( $ nds as $ value ) { $ ndList .= '<nd ref="' . $ value . '"/>' ; } } $ xml = '<?xml version="1.0" encoding="UTF-8"?> <osm version="0.6" generator="JoomlaOpenStreetMap"> <way changeset="' . $ changeset . '">' . $ tagList . $ ndList . '</way> </osm>' ; $ header [ 'Content-Type' ] = 'text/xml' ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'PUT' , $ parameters , $ xml , $ header ) ; return $ response -> body ; }
12088	public function view ( UserPolicy $ user , Response $ response ) { if ( $ user -> canDo ( 'forum.response.view' ) && $ user -> isAdmin ( ) ) { return true ; } return $ response -> user_id == user_id ( ) && $ response -> user_type == user_type ( ) ; }
261	protected function typecastValue ( $ value , $ type ) { if ( is_scalar ( $ type ) ) { if ( is_object ( $ value ) && method_exists ( $ value , '__toString' ) ) { $ value = $ value -> __toString ( ) ; } switch ( $ type ) { case self :: TYPE_INTEGER : return ( int ) $ value ; case self :: TYPE_FLOAT : return ( float ) $ value ; case self :: TYPE_BOOLEAN : return ( bool ) $ value ; case self :: TYPE_STRING : if ( is_float ( $ value ) ) { return StringHelper :: floatToString ( $ value ) ; } return ( string ) $ value ; default : throw new InvalidArgumentException ( "Unsupported type '{$type}'" ) ; } } return call_user_func ( $ type , $ value ) ; }
6332	public function createResponse ( $ status , $ errorCode , $ errorDescription ) { $ document = new \ DOMDocument ( '1.0' , 'utf-8' ) ; $ document -> formatOutput = false ; $ response = $ document -> appendChild ( $ document -> createElement ( 'SVSPurchaseStatusNotificationResponse' ) ) ; $ result = $ response -> appendChild ( $ document -> createElement ( 'TransactionResult' ) ) ; $ result -> appendChild ( $ document -> createElement ( 'Description' , $ errorDescription ) ) ; $ result -> appendChild ( $ document -> createElement ( 'Code' , $ errorCode ) ) ; $ response -> appendChild ( $ document -> createElement ( 'Status' , $ status ) ) ; $ authentication = $ response -> appendChild ( $ document -> createElement ( 'Authentication' ) ) ; $ checksum = $ authentication -> appendChild ( $ document -> createElement ( 'Checksum' , $ this -> getMerchantPassword ( ) ) ) ; $ checksum -> nodeValue = $ this -> calculateXmlChecksum ( $ document -> saveXML ( ) ) ; return $ document -> saveXML ( ) ; }
2344	protected function createIfNotExists ( ) { if ( file_exists ( $ this -> strRootDir . '/' . $ this -> strFile ) ) { return ; } if ( ( $ strFolder = \ dirname ( $ this -> strFile ) ) == '.' ) { $ strFolder = '' ; } if ( ! is_dir ( $ this -> strRootDir . '/' . $ strFolder ) ) { new Folder ( $ strFolder ) ; } if ( ! $ this -> resFile = $ this -> Files -> fopen ( $ this -> strFile , 'wb' ) ) { throw new \ Exception ( sprintf ( 'Cannot create file "%s"' , $ this -> strFile ) ) ; } }
9299	public function postAction ( Request $ request ) { try { $ data = $ this -> get ( 'ongr_api.batch_request_handler' ) -> handleRequest ( $ request , $ repository = $ this -> getRequestRepository ( $ request ) , 'create' ) ; return $ this -> renderRest ( $ request , $ data , Response :: HTTP_OK ) ; } catch ( \ Exception $ e ) { return $ this -> renderError ( $ request , $ e -> getMessage ( ) , Response :: HTTP_BAD_REQUEST ) ; } }
10369	public function reset ( ResetRequest $ request , $ token ) { $ this -> bus -> pipeThrough ( $ this -> pipesOf ( 'reset' ) ) -> dispatchFrom ( ResetJob :: class , $ request , compact ( 'token' ) ) ; return redirect ( ) -> route ( 'login.index' ) -> withSuccess ( trans ( 'auth::reset.success' ) ) ; }
12963	public function checkDbExists ( $ name ) { $ data = $ this -> query ( "SELECT COUNT(*) AS total FROM INFORMATION_SCHEMA.SCHEMATA WHERE SCHEMA_NAME = '" . $ this -> escape ( $ name ) . "'" , true ) ; if ( isset ( $ data [ '0' ] [ 'total' ] ) && $ data [ '0' ] [ 'total' ] == '1' ) { return true ; } return false ; }
8423	public function mappings ( Request $ request ) { $ table = new \ cli \ Table ( ) ; $ table -> setHeaders ( [ 'Mapping' , 'Database' , 'Models path' ] ) ; $ rows = [ ] ; $ mappings = Mapping :: getMappings ( ) ; usort ( $ mappings , function ( array $ a , array $ b ) { return strcmp ( $ a [ 'config' ] [ 'name' ] , $ b [ 'config' ] [ 'name' ] ) ; } ) ; foreach ( $ mappings as $ mapping ) { $ rows [ ] = [ $ mapping [ 'config' ] [ 'name' ] , $ mapping [ 'config' ] [ 'database' ] , $ mapping [ 'config' ] [ 'models' ] [ 'path' ] , ] ; } $ table -> setRows ( $ rows ) ; $ table -> display ( ) ; }
10639	protected function processUrls ( Request $ request ) { $ externalRawMediaUrls = array ( ) ; if ( $ request -> get ( 'urls' ) ) { foreach ( $ request -> get ( 'urls' ) as $ url ) { $ externalRawMediaUrls [ ] = $ url ; } } return $ externalRawMediaUrls ; }
5010	public function getPermissions ( ) { if ( ! $ this -> permissions ) { $ type = property_exists ( $ this , 'permissionsType' ) ? $ this -> permissionsType : str_replace ( '\\Entity\\' , '/' , static :: class ) ; $ permissions = new Permissions ( $ type ) ; if ( method_exists ( $ this , 'setupPermissions' ) ) { $ this -> setupPermissions ( $ permissions ) ; } $ this -> setPermissions ( $ permissions ) ; } return $ this -> permissions ; }
7442	public function showAction ( $ id ) { $ em = $ this -> getDoctrine ( ) -> getEntityManager ( ) ; $ group = $ em -> getRepository ( 'Orkestra\Bundle\ApplicationBundle\Entity\Group' ) -> find ( $ id ) ; if ( ! $ group ) { throw $ this -> createNotFoundException ( 'Unable to locate Group' ) ; } return array ( 'group' => $ group , ) ; }
4100	public function setType ( $ type ) { if ( is_array ( $ type ) ) $ type = implode ( "," , array_filter ( $ type ) ) ; $ this -> type = $ type ; $ this -> transport -> setType ( $ type ) ; return $ this ; }
2512	public function setStatus ( $ newStatus ) { if ( $ this -> isWorseStatus ( $ newStatus , $ this -> status ) ) { $ this -> status = $ newStatus ; } }
11812	public static function setPointInLog ( string $ sName = 'default' ) { $ oLogger = Debug :: getInstance ( ) ; $ oLogger -> info ( 'BENCHMARK: Time at this point ' . ( microtime ( true ) - self :: $ _fStart ) . ' - ' . $ sName ) ; }
5929	public function updateCategory ( $ id , Category $ category ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'category' => $ category ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/categories/' . $ id . '' , $ parameters ) ; $ result = new CategoryResponse ( $ result ) ; return $ result ; }
12700	public function createServiceWithName ( ServiceLocatorInterface $ serviceLocator , $ name , $ requestedName ) { $ config = $ serviceLocator -> get ( 'config' ) ; if ( isset ( $ config [ 'rznviewcomponent' ] [ 'cache_adapter' ] ) ) { $ config = $ config [ 'rznviewcomponent' ] [ 'cache_adapter' ] ; } else $ config = array ( 'name' => 'filesystem' , 'options' => array ( 'ttl' => 3600 , 'dirLevel' => 2 , 'file_locking' => false , 'cacheDir' => 'data/cache' , 'dirPermission' => 0755 , 'filePermission' => 0666 , ) , ) ; return \ Zend \ Cache \ StorageFactory :: factory ( array ( 'adapter' => $ config , 'plugins' => array ( 'serializer' ) , ) ) ; }
1154	public function makeReplacements ( $ message , $ attribute , $ rule , $ parameters ) { if ( is_object ( $ rule ) ) { $ rule = get_class ( $ rule ) ; } return $ this -> callValidator ( 'makeReplacements' , [ $ message , $ attribute , $ rule , $ parameters ] ) ; }
2442	protected function getUser ( ) : BackendUser { if ( null === $ this -> tokenStorage ) { throw new \ RuntimeException ( 'No token storage provided' ) ; } $ token = $ this -> tokenStorage -> getToken ( ) ; if ( null === $ token ) { throw new \ RuntimeException ( 'No token provided' ) ; } $ user = $ token -> getUser ( ) ; if ( ! $ user instanceof BackendUser ) { throw new \ RuntimeException ( 'The token does not contain a back end user object' ) ; } return $ user ; }
5779	public function getOne ( ) : ? string { $ result = $ this -> execute ( ) ; if ( pg_num_rows ( $ result ) == 1 ) { if ( pg_num_fields ( $ result ) == 1 ) { return pg_fetch_array ( $ result ) [ 0 ] ; } else { throw new \ Exception ( "Too many result fields" ) ; } } else { if ( pg_num_rows ( $ result ) == 0 ) { return null ; } else { throw new \ Exception ( "Multiple results" ) ; } } }
1912	public function pickerAction ( Request $ request ) : RedirectResponse { $ extras = [ ] ; if ( $ request -> query -> has ( 'extras' ) ) { $ extras = $ request -> query -> get ( 'extras' ) ; if ( ! \ is_array ( $ extras ) ) { throw new BadRequestHttpException ( 'Invalid picker extras' ) ; } } $ config = new PickerConfig ( $ request -> query -> get ( 'context' ) , $ extras , $ request -> query -> get ( 'value' ) ) ; $ picker = $ this -> get ( 'contao.picker.builder' ) -> create ( $ config ) ; if ( null === $ picker ) { throw new BadRequestHttpException ( 'Unsupported picker context' ) ; } return new RedirectResponse ( $ picker -> getCurrentUrl ( ) ) ; }
5061	public function calculateWidth ( $ text , $ size = self :: TEXT_SIZE ) { $ size = $ this -> convertToPt ( $ size ) ; $ box = imagettfbbox ( $ size , 0 , $ this -> fontPath , $ text ) ; return round ( abs ( $ box [ 2 ] - $ box [ 0 ] ) + self :: SHIELD_PADDING_EXTERNAL + self :: SHIELD_PADDING_INTERNAL , 1 ) ; }
4636	public function send ( $ email , array $ options = [ ] ) : ResultInterface { if ( is_string ( $ email ) ) { $ email = $ this -> emailBuilder -> build ( $ email , $ options ) ; } elseif ( is_array ( $ email ) ) { $ email = $ this -> emailBuilder -> build ( Email :: class , $ email ) ; } elseif ( ! $ email instanceof Email ) { throw Exception \ InvalidArgumentException :: fromValidTypes ( [ 'string' , 'array' , Email :: class ] , $ email , 'email' ) ; } $ this -> events -> triggerEvent ( $ this -> createMailEvent ( $ email , MailEvent :: EVENT_MAIL_PRE_RENDER ) ) ; $ this -> renderEmailBody ( $ email ) ; $ eventResp = $ this -> events -> triggerEvent ( $ this -> createMailEvent ( $ email , MailEvent :: EVENT_MAIL_PRE_SEND ) ) ; if ( $ eventResp -> contains ( false ) ) { return new MailResult ( $ email , false ) ; } try { $ message = MessageFactory :: createMessageFromEmail ( $ email ) -> setBody ( $ this -> buildBody ( $ email -> getBody ( ) , $ email -> getCharset ( ) ) ) ; $ this -> attachFiles ( $ message , $ email ) ; $ this -> addCustomHeaders ( $ message , $ email ) ; $ this -> transport -> send ( $ message ) ; $ result = new MailResult ( $ email ) ; $ this -> events -> triggerEvent ( $ this -> createMailEvent ( $ email , MailEvent :: EVENT_MAIL_POST_SEND , $ result ) ) ; return $ result ; } catch ( Throwable $ e ) { $ this -> events -> triggerEvent ( $ this -> createMailEvent ( $ email , MailEvent :: EVENT_MAIL_SEND_ERROR , new MailResult ( $ email , false , $ e ) ) ) ; throw new Exception \ MailException ( 'An error occurred while trying to send the email' , $ e -> getCode ( ) , $ e ) ; } }
11317	public function note ( string $ message ) : void { $ this -> logger -> log ( $ this -> level , strip_tags ( $ message ) ) ; }
9713	private function writeExternalsheetBiff8 ( ) { $ totalReferences = count ( $ this -> parser -> references ) ; $ record = 0x0017 ; $ length = 2 + 6 * $ totalReferences ; $ supbook_index = 0 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ totalReferences ) ; for ( $ i = 0 ; $ i < $ totalReferences ; ++ $ i ) { $ data .= $ this -> parser -> references [ $ i ] ; } return $ this -> writeData ( $ header . $ data ) ; }
12111	private function persist ( ) { $ bootstrap = Bootstrap :: getInstance ( ) ; $ config = $ bootstrap -> getConfiguration ( ) ; $ config [ 'pages' ] = array ( ) ; foreach ( $ this -> pages as $ page ) { $ page -> appendConfig ( $ config [ 'pages' ] ) ; } $ bootstrap -> setConfiguration ( $ config ) ; }
4229	protected function errorHash ( $ errorValues ) { $ errMsg = $ errorValues [ 'message' ] ; $ errMsg = \ preg_replace ( '/(\(.*?)\d+(.*?\))/' , '\1x\2' , $ errMsg ) ; $ errMsg = \ preg_replace ( '/\b([a-z]+\d+)+\b/' , 'xxx' , $ errMsg ) ; $ errMsg = \ preg_replace ( '/\b[\d.-]{4,}\b/' , 'xxx' , $ errMsg ) ; $ errMsg = \ preg_replace ( '/\s*##.+$/' , '' , $ errMsg ) ; $ hash = \ md5 ( $ errorValues [ 'file' ] . $ errorValues [ 'line' ] . $ errorValues [ 'type' ] . $ errMsg ) ; return $ hash ; }
654	protected function internalExecute ( $ rawSql ) { $ attempt = 0 ; while ( true ) { try { if ( ++ $ attempt === 1 && $ this -> _isolationLevel !== false && $ this -> db -> getTransaction ( ) === null ) { $ this -> db -> transaction ( function ( ) use ( $ rawSql ) { $ this -> internalExecute ( $ rawSql ) ; } , $ this -> _isolationLevel ) ; } else { $ this -> pdoStatement -> execute ( ) ; } break ; } catch ( \ Exception $ e ) { $ rawSql = $ rawSql ? : $ this -> getRawSql ( ) ; $ e = $ this -> db -> getSchema ( ) -> convertException ( $ e , $ rawSql ) ; if ( $ this -> _retryHandler === null || ! call_user_func ( $ this -> _retryHandler , $ e , $ attempt ) ) { throw $ e ; } } } }
4871	public function setEventPrototype ( EventInterface $ prototype ) { if ( ! $ prototype instanceof DependencyResultEvent ) { throw new \ InvalidArgumentException ( 'This event manager only accepts events of the type ' . DependencyResultEvent :: class ) ; } parent :: setEventPrototype ( $ prototype ) ; }
6266	public function reject ( Exception $ exception ) { if ( HttpPromise :: PENDING !== $ this -> state ) { throw new \ RuntimeException ( 'Promise is already resolved' ) ; } $ this -> state = HttpPromise :: REJECTED ; $ this -> exception = $ exception ; $ this -> doReject ( $ exception ) ; }
7440	protected function reloadModule ( Wrapper $ wrapper , $ module ) { $ moduleStatus = $ wrapper -> ModuleManager -> reload ( $ module ) ; $ module = Inflector :: camelize ( $ module ) ; switch ( $ moduleStatus ) { case 'AU' : $ wrapper -> Channel -> sendMessage ( 'The Module `' . $ module . '` doesn\'t exist and cannot be reloaded.' ) ; break ; case 'AL' : $ wrapper -> Channel -> sendMessage ( 'The Module `' . $ module . '` is already loaded.' ) ; break ; case 'L' : $ wrapper -> Channel -> sendMessage ( 'Module `' . $ module . '` reloaded successfully.' ) ; break ; case 'NF' : $ wrapper -> Channel -> sendMessage ( 'Failed to reload the Module `' . $ module . '`.' ) ; break ; } }
8664	private function convertManageReportSchedule ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'ManageReportSchedule' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetReportType ( ) ) { $ parameters [ 'ReportType' ] = $ request -> getReportType ( ) ; } if ( $ request -> isSetSchedule ( ) ) { $ parameters [ 'Schedule' ] = $ request -> getSchedule ( ) ; } if ( $ request -> isSetScheduleDate ( ) ) { $ parameters [ 'ScheduleDate' ] = $ this -> getFormattedTimestamp ( $ request -> getScheduleDate ( ) ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
9007	public function sort ( ) { $ this -> uasort ( function ( $ a , $ b ) { $ priority_a = ( int ) $ a -> get ( 'priority' ) ? : 500 ; $ priority_b = ( int ) $ b -> get ( 'priority' ) ? : 500 ; if ( $ priority_a == $ priority_b ) { return 0 ; } return ( $ priority_a < $ priority_b ) ? - 1 : 1 ; } ) ; return $ this ; }
4375	protected function buildGroupMethod ( $ method , $ args = array ( ) , $ meta = array ( ) ) { $ str = '' ; if ( \ in_array ( $ method , array ( 'group' , 'groupCollapsed' ) ) ) { $ label = \ array_shift ( $ args ) ; $ levelClass = isset ( $ meta [ 'level' ] ) ? 'level-' . $ meta [ 'level' ] : null ; if ( ! empty ( $ meta [ 'isMethodName' ] ) ) { $ label = $ this -> markupClassname ( $ label ) ; } foreach ( $ args as $ k => $ v ) { $ args [ $ k ] = $ this -> dump ( $ v ) ; } $ argStr = \ implode ( ', ' , $ args ) ; $ str .= $ this -> debug -> utilities -> buildTag ( 'div' , array ( 'class' => array ( 'group-header' , $ method == 'groupCollapsed' ? 'collapsed' : 'expanded' , $ levelClass , ) , 'data-channel' => $ meta [ 'channel' ] , ) , '<span class="group-label">' . $ label . ( ! empty ( $ argStr ) ? '(</span>' . $ argStr . '<span class="group-label">)' : '' ) . '</span>' ) . "\n" ; $ str .= '<div' . $ this -> debug -> utilities -> buildAttribString ( array ( 'class' => array ( 'm_group' , $ levelClass , ) , ) ) . '>' ; } elseif ( $ method == 'groupEnd' ) { $ str = '</div>' ; } return $ str ; }
1333	protected function applyFilters ( $ query , Collection $ filters ) { if ( $ this -> isFindMany ( $ filters ) ) { $ this -> filterByIds ( $ query , $ filters ) ; } $ this -> filter ( $ query , $ filters ) ; }
4894	public function end ( ) { if ( ! $ this -> captureLock ) { throw new \ RuntimeException ( 'Cannot end capture, there is no capture running.' ) ; } $ type = $ this -> captureType ; $ content = ob_get_clean ( ) ; $ options = $ this -> captureOptions ; $ this -> captureLock = false ; $ this -> captureType = null ; $ this -> captureOptions = null ; return $ this -> render ( $ type , $ content , $ options ) ; }
6187	public function assign ( $ name , $ value ) { if ( ! isset ( $ this -> view ) ) { throw new ViewException ( 'Please Define view engine in app/View.php' , 500 ) ; } return $ this -> view -> assign ( $ name , $ value ) ; }
3866	private function getOrCreateBasicDefinition ( IMetaModelDataDefinition $ container ) { if ( $ container -> hasBasicDefinition ( ) ) { return $ container -> getBasicDefinition ( ) ; } $ config = new DefaultBasicDefinition ( ) ; $ container -> setBasicDefinition ( $ config ) ; return $ config ; }
6611	public function getFirstError ( $ attribute = null ) { if ( ! $ this -> errors ) { return null ; } elseif ( is_null ( $ attribute ) ) { $ errors = $ this -> getErrors ( ) ; reset ( $ errors ) ; $ firstError = current ( $ errors ) ; $ arrayKeys = array_keys ( $ firstError ) ; $ error = $ firstError [ $ arrayKeys [ 0 ] ] ; return $ error ; } return parent :: getFirstError ( $ attribute ) ; }
2266	public function indexExists ( $ strName , $ strTable , $ blnNoCache = false ) { if ( $ strName == '' || $ strTable == '' ) { return false ; } foreach ( $ this -> listFields ( $ strTable , $ blnNoCache ) as $ arrField ) { if ( $ arrField [ 'name' ] == $ strName && $ arrField [ 'type' ] == 'index' ) { return true ; } } return false ; }
11117	protected function rollbackMigrations ( array $ migrations ) : void { $ this -> notify -> note ( '' ) ; foreach ( $ this -> getMigrationFiles ( M :: TYPE_DOWN ) as $ file ) { if ( in_array ( $ name = $ this -> getMigrationName ( $ file ) , $ migrations , true ) ) { $ this -> runDown ( $ file ) ; continue ; } $ this -> notify -> note ( "<fg=red>Migrate not found (in database table):</> {$name}" ) ; } }
6459	public function fillInWithValueOfFieldOfCurrentUser ( $ field , $ user_field ) { if ( ! empty ( $ this -> user ) && ! $ this -> user -> uid ) { throw new \ Exception ( 'Anonymous user have no fields' ) ; } $ entity = new EntityDrupalWrapper ( 'user' ) ; $ wrapper = $ entity -> wrapper ( $ this -> user -> uid ) ; $ user_field = $ entity -> getFieldNameByLocator ( $ user_field ) ; if ( empty ( $ wrapper -> { $ user_field } ) ) { throw new \ InvalidArgumentException ( sprintf ( 'User entity has no "%s" field.' , $ user_field ) ) ; } $ value = $ wrapper -> { $ user_field } -> value ( ) ; if ( empty ( $ value ) ) { throw new \ UnexpectedValueException ( 'The value of "%s" field is empty.' , $ user_field ) ; } $ this -> fillField ( $ field , $ value ) ; }
9509	public function search ( Log $ log , $ level = 'all' , Request $ request ) { if ( is_null ( $ query = $ request -> get ( 'query' ) ) ) return redirect ( ) -> route ( 'admin::foundation.system.log-viewer.logs.show' , [ $ log -> date ] ) ; $ levels = $ this -> logViewer -> levelsNames ( ) ; $ entries = $ log -> entries ( $ level ) -> filter ( function ( LogEntry $ value ) use ( $ query ) { return Str :: contains ( $ value -> header , $ query ) ; } ) -> paginate ( $ this -> perPage ) ; return $ this -> view ( 'admin.system.log-viewer.show' , compact ( 'log' , 'levels' , 'level' , 'query' , 'entries' ) ) ; }
5392	public function paintPass ( $ message ) { parent :: paintPass ( $ message ) ; print $ this -> getIndent ( 1 ) ; print '<' . $ this -> namespace . 'pass>' ; print $ this -> toParsedXml ( $ message ) ; print '</' . $ this -> namespace . "pass>\n" ; }
1938	public function adjustPermissions ( $ insertId ) { if ( \ func_num_args ( ) == 4 ) { $ insertId = func_get_arg ( 1 ) ; } if ( $ this -> User -> isAdmin ) { return ; } if ( empty ( $ this -> User -> newsletters ) || ! \ is_array ( $ this -> User -> newsletters ) ) { $ root = array ( 0 ) ; } else { $ root = $ this -> User -> newsletters ; } if ( \ in_array ( $ insertId , $ root ) ) { return ; } $ objSessionBag = Contao \ System :: getContainer ( ) -> get ( 'session' ) -> getBag ( 'contao_backend' ) ; $ arrNew = $ objSessionBag -> get ( 'new_records' ) ; if ( \ is_array ( $ arrNew [ 'tl_newsletter_channel' ] ) && \ in_array ( $ insertId , $ arrNew [ 'tl_newsletter_channel' ] ) ) { if ( $ this -> User -> inherit != 'custom' ) { $ objGroup = $ this -> Database -> execute ( "SELECT id, newsletters, newsletterp FROM tl_user_group WHERE id IN(" . implode ( ',' , array_map ( '\intval' , $ this -> User -> groups ) ) . ")" ) ; while ( $ objGroup -> next ( ) ) { $ arrNewsletterp = Contao \ StringUtil :: deserialize ( $ objGroup -> newsletterp ) ; if ( \ is_array ( $ arrNewsletterp ) && \ in_array ( 'create' , $ arrNewsletterp ) ) { $ arrNewsletters = Contao \ StringUtil :: deserialize ( $ objGroup -> newsletters , true ) ; $ arrNewsletters [ ] = $ insertId ; $ this -> Database -> prepare ( "UPDATE tl_user_group SET newsletters=? WHERE id=?" ) -> execute ( serialize ( $ arrNewsletters ) , $ objGroup -> id ) ; } } } if ( $ this -> User -> inherit != 'group' ) { $ objUser = $ this -> Database -> prepare ( "SELECT newsletters, newsletterp FROM tl_user WHERE id=?" ) -> limit ( 1 ) -> execute ( $ this -> User -> id ) ; $ arrNewsletterp = Contao \ StringUtil :: deserialize ( $ objUser -> newsletterp ) ; if ( \ is_array ( $ arrNewsletterp ) && \ in_array ( 'create' , $ arrNewsletterp ) ) { $ arrNewsletters = Contao \ StringUtil :: deserialize ( $ objUser -> newsletters , true ) ; $ arrNewsletters [ ] = $ insertId ; $ this -> Database -> prepare ( "UPDATE tl_user SET newsletters=? WHERE id=?" ) -> execute ( serialize ( $ arrNewsletters ) , $ this -> User -> id ) ; } } $ root [ ] = $ insertId ; $ this -> User -> newsletter = $ root ; } }
2822	protected function _afterLoad ( ) { $ info = $ this -> getUnserializedInfo ( ) ; $ this -> logging = $ info [ 'logging' ] ; $ this -> action = $ info [ 'action' ] ; $ this -> design = $ info [ 'design' ] ; $ this -> blocks = $ info [ 'blocks' ] ; $ this -> models = $ info [ 'models' ] ; $ this -> collections = $ info [ 'collections' ] ; $ this -> queries = $ info [ 'queries' ] ; $ this -> timers = $ info [ 'timers' ] ; $ this -> emails = $ info [ 'emails' ] ; return parent :: _afterLoad ( ) ; }
3587	protected function getMetaWhereConstraint ( $ method , ArgumentBag $ args ) { $ column = $ args -> get ( 'column' ) ; $ args -> set ( 'column' , 'meta_value' ) ; if ( $ method === 'whereBetween' ) { return $ this -> getMetaBetweenConstraint ( $ column , $ args -> get ( 'values' ) ) ; } return function ( $ query ) use ( $ column , $ method , $ args ) { $ query -> where ( 'meta_key' , $ column ) ; if ( $ args -> get ( 'value' ) || $ args -> get ( 'values' ) ) { call_user_func_array ( [ $ query , $ method ] , $ args -> all ( ) ) ; } } ; }
3893	private function renderEditButton ( $ caption , $ title , UrlBuilder $ url ) { $ icon = $ this -> iconBuilder -> getBackendIconImageTag ( 'system/themes/flexible/icons/alias.svg' , $ caption , 'style="vertical-align:top"' ) ; return sprintf ( '<a href="%s" title="%s" style="padding-left:3px">%s</a>' , $ url -> getUrl ( ) , $ title , $ icon ) ; }
9321	protected function compileMarkdownEchos ( $ value ) { $ pattern = sprintf ( '/(@)?%s\s*(.+?)\s*%s(\r?\n)?/s' , $ this -> markdownTags [ 0 ] , $ this -> markdownTags [ 1 ] ) ; $ callback = function ( $ matches ) { $ wrapper = sprintf ( $ this -> markdownFormat , $ this -> compileEchoDefaults ( $ matches [ 2 ] ) ) ; return $ matches [ 1 ] ? strlen ( stripcslashes ( $ this -> markdownTags [ 0 ] ) ) > 2 ? $ matches [ 0 ] : substr ( $ matches [ 0 ] , 1 ) : '<?php echo ' . $ wrapper . '; ?>' ; } ; return preg_replace_callback ( $ pattern , $ callback , $ value ) ; }
2105	protected function generateFaqLink ( $ objFaq ) { $ objCategory = $ objFaq -> getRelated ( 'pid' ) ; $ jumpTo = ( int ) $ objCategory -> jumpTo ; if ( $ jumpTo < 1 ) { throw new \ Exception ( "FAQ categories without redirect page cannot be used in an FAQ list" ) ; } if ( ! isset ( $ this -> arrTargets [ $ jumpTo ] ) ) { $ this -> arrTargets [ $ jumpTo ] = ampersand ( Environment :: get ( 'request' ) , true ) ; if ( $ jumpTo > 0 && ( $ objTarget = PageModel :: findByPk ( $ jumpTo ) ) !== null ) { $ this -> arrTargets [ $ jumpTo ] = ampersand ( $ objTarget -> getFrontendUrl ( Config :: get ( 'useAutoItem' ) ? '/%s' : '/items/%s' ) ) ; } } return sprintf ( preg_replace ( '/%(?!s)/' , '%%' , $ this -> arrTargets [ $ jumpTo ] ) , ( $ objFaq -> alias ? : $ objFaq -> id ) ) ; }
5730	public function getButtonHTML ( ) { $ html = '<div class="btn-group" role="group">' ; $ params = array ( 'q' => ( array ) $ this -> gridFieldRequest -> getRequest ( ) -> getVar ( 'q' ) ) ; $ searchVars = ( bool ) $ params ? '?' . http_build_query ( $ params ) : '' ; $ previousRecordID = $ this -> gridFieldRequest -> getPreviousRecordID ( ) ; $ cssClass = $ previousRecordID ? "cms-panel-link" : "disabled" ; $ prevLink = $ previousRecordID ? Controller :: join_links ( $ this -> gridFieldRequest -> gridField -> Link ( ) , "item" , $ previousRecordID . $ searchVars ) : "javascript:void(0);" ; $ linkTitle = $ previousRecordID ? _t ( 'GridFieldBetterButtons.PREVIOUSRECORD' , 'Go to the previous record' ) : "" ; $ linkText = $ previousRecordID ? _t ( 'GridFieldBetterButtons.PREVIOUS' , 'Previous' ) : "" ; $ html .= sprintf ( "<a class='ss-ui-button btn btn-default gridfield-better-buttons-prevnext gridfield-better-buttons-prev %s' href='%s' title='%s'><img src='" . BETTER_BUTTONS_DIR . "/images/prev.png' alt='previous' /> %s</a>" , $ cssClass , $ prevLink , $ linkTitle , $ linkText ) ; $ nextRecordID = $ this -> gridFieldRequest -> getNextRecordID ( ) ; $ cssClass = $ nextRecordID ? "cms-panel-link" : "disabled" ; $ nextLink = $ nextRecordID ? Controller :: join_links ( $ this -> gridFieldRequest -> gridField -> Link ( ) , "item" , $ nextRecordID . $ searchVars ) : "javascript:void(0);" ; $ linkTitle = $ nextRecordID ? _t ( 'GridFieldBetterButtons.NEXTRECORD' , 'Go to the next record' ) : "" ; $ linkText = $ nextRecordID ? _t ( 'GridFieldBetterButtons.NEXT' , 'Next' ) : "" ; $ html .= sprintf ( "<a class='ss-ui-button btn btn-default gridfield-better-buttons-prevnext gridfield-better-buttons-next %s' href='%s' title='%s'>%s <img src='" . BETTER_BUTTONS_DIR . "/images/next.png' alt='next' /></a>" , $ cssClass , $ nextLink , $ linkTitle , $ linkText ) ; $ html .= '</div>' ; return $ html ; }
11664	public function isValid ( array $ values ) { $ this -> errorMessages = [ ] ; foreach ( $ this -> elements -> getElements ( ) as $ element ) { $ elementId = $ element -> getID ( ) ; if ( empty ( $ elementId ) ) { continue ; } $ value = null ; if ( array_key_exists ( $ elementId , $ values ) ) { $ value = $ values [ $ elementId ] ; } $ element -> setValue ( $ value ) ; $ this -> filterElement ( $ element ) ; $ this -> validateElement ( $ element ) ; } return count ( $ this -> errorMessages ) === 0 ; }
4183	public function fileHas ( $ contains ) { $ this -> files = ( new ClassIterator ( $ this -> finder -> contains ( $ contains ) ) ) -> getClassMap ( ) ; $ this -> count = count ( $ this -> files ) ; return $ this ; }
12438	public function get ( $ id ) { if ( isset ( $ this -> children [ $ id ] ) ) { return $ this -> children [ $ id ] ; } throw new FormalException ( "Unknown form field '$id' on form '" . get_called_class ( ) . "'. Available fields are: " . implode ( ', ' , array_keys ( $ this -> children ) ) ) ; }
6576	public function stop ( ) : void { if ( $ this -> isStarted ( ) ) { $ this -> getHandler ( ) -> destroy ( $ this -> getDataHolder ( ) -> getId ( ) ) ; $ this -> dataHolder = null ; } }
5791	public function isDeletable ( ) : bool { if ( in_array ( $ this -> title , self :: UNDELETABLE ) ) { return false ; } return ( PermissionsTableMapper :: getInstance ( ) ) -> isDeletable ( ) ; }
4246	private function logRequest ( ) { $ this -> logRequestHeaders ( ) ; if ( $ this -> debug -> getCfg ( 'logEnvInfo.cookies' ) ) { $ cookieVals = $ _COOKIE ; \ ksort ( $ cookieVals , SORT_NATURAL ) ; $ this -> debug -> log ( '$_COOKIE' , $ cookieVals ) ; } $ noBody = ! isset ( $ _SERVER [ 'REQUEST_METHOD' ] ) || \ in_array ( $ _SERVER [ 'REQUEST_METHOD' ] , array ( 'CONNECT' , 'GET' , 'HEAD' , 'OPTIONS' , 'TRACE' ) ) ; if ( $ this -> debug -> getCfg ( 'logEnvInfo.post' ) && ! $ noBody ) { if ( $ _POST ) { $ this -> debug -> log ( '$_POST' , $ _POST ) ; } else { $ input = \ file_get_contents ( 'php://input' ) ; if ( $ input ) { $ this -> debug -> log ( 'php://input' , $ input ) ; } elseif ( isset ( $ _SERVER [ 'REQUEST_METHOD' ] ) && empty ( $ _FILES ) ) { $ this -> debug -> warn ( $ _SERVER [ 'REQUEST_METHOD' ] . ' request with no body' ) ; } } if ( ! empty ( $ _FILES ) ) { $ this -> debug -> log ( '$_FILES' , $ _FILES ) ; } } }
3052	public function getItemIndexValue ( $ id , $ name ) { return $ this -> itemIndex -> getItemValue ( $ id , \ common_session_SessionManager :: getSession ( ) -> getInterfaceLanguage ( ) , $ name ) ; }
5478	protected function setWidget ( $ tag ) { if ( strtolower ( $ tag -> getAttribute ( 'type' ) ) === 'radio' ) { $ this -> addRadioButton ( $ tag ) ; } elseif ( strtolower ( $ tag -> getAttribute ( 'type' ) ) === 'checkbox' ) { $ this -> addCheckbox ( $ tag ) ; } else { $ this -> widgets [ ] = $ tag ; } }
2975	public function bindTo ( $ newthis , $ newscope = 'static' ) { return new self ( $ this -> closure -> bindTo ( $ newthis , $ newscope ) , $ this -> serializer ) ; }
11970	public function extendExpiration ( ) { if ( null === $ this -> ttl ) { throw new DomainException ( 'There is no TTL set for this Lock.' ) ; } if ( ! $ this -> expiresAt ) { $ this -> expiresAt = new \ DateTime ( ) ; $ this -> expiresAt -> setTimestamp ( time ( ) ) ; } $ this -> expiresAt -> add ( $ this -> ttl ) ; }
12118	public function getParam ( $ key , $ default = null ) { $ param = parent :: getParam ( $ key , $ default ) ; if ( is_string ( $ param ) ) { return trim ( $ param ) ; } return $ param ; }
8005	public static function calculatePayloadOffset ( $ negotiate_flags ) { $ offset = 0 ; $ offset += strlen ( static :: SIGNATURE ) ; $ offset += 4 ; $ offset += 4 ; $ offset += 8 ; $ offset += 8 ; return $ offset ; }
639	public function renameColumn ( $ table , $ oldName , $ newName ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> renameColumn ( $ table , $ oldName , $ newName ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; }
6095	public function permAssign ( $ permid , $ permvalue , $ permskip = false ) { return $ this -> getParent ( ) -> clientPermAssign ( $ this [ "client_database_id" ] , $ permid , $ permvalue , $ permskip ) ; }
4136	public function getParams ( array $ params ) { $ r = '' ; ksort ( $ params ) ; foreach ( $ params as $ key => $ value ) { $ r .= '&' . $ key . '=' . rawurlencode ( $ value ) ; } unset ( $ params , $ key , $ value ) ; return trim ( $ r , '&' ) ; }
5601	public function paintPass ( $ message ) { if ( ! $ this -> pass ) { $ this -> message = self :: escapeVal ( $ message ) ; } $ this -> pass = true ; }
8094	public function set ( $ keyPath , $ value ) { $ stops = explode ( '.' , $ keyPath ) ; $ currentLocation = $ previousLocation = $ this ; foreach ( $ stops as $ key ) { if ( $ currentLocation instanceof Collection ) { if ( ! ( $ currentLocation -> $ key instanceof Collection ) ) { $ currentLocation -> $ key = array ( ) ; } } else { $ currentLocation = array ( ) ; $ currentLocation -> $ key = array ( ) ; } $ previousLocation = $ currentLocation ; $ currentLocation = $ currentLocation -> $ key ; } $ previousLocation -> $ key = $ value ; }
12914	protected function getWhereAsArray ( ) { $ filters = [ ] ; if ( ! empty ( $ this -> filters ) ) { $ filters = $ this -> filters ; } if ( ! $ this -> allowDeleted ) { $ filters [ ] = "(`" . $ this -> table . "`.deleted = 0 OR `" . $ this -> table . "`.deleted IS NULL)" ; } if ( ! empty ( $ this -> joins ) ) { foreach ( $ this -> joins as $ join ) { $ manager = $ join [ 'manager' ] ; $ filters = array_merge ( $ filters , $ manager -> getWhereAsArray ( ) ) ; } } return $ filters ; }
12377	public function superadmin ( User $ account , Container $ application , Database $ database ) { $ config = $ this -> config ; $ username = $ application -> input -> getString ( "user_first_name" , "" , "post" , FALSE , array ( ) ) ; $ usernameid = $ application -> input -> getString ( "user_name_id" , "" , "post" , FALSE , array ( ) ) ; $ userpass = $ application -> input -> getString ( "user_password" , "" , "post" , FALSE , array ( ) ) ; $ userpass2 = $ application -> input -> getString ( "user_password_2" , "" , "post" , FALSE , array ( ) ) ; $ useremail = $ application -> input -> getString ( "user_email" , "" , "post" , FALSE , array ( ) ) ; if ( empty ( $ userpass ) || empty ( $ username ) || empty ( $ usernameid ) || empty ( $ useremail ) ) { throw new Exception ( t ( 'Please provide at least a Name, Username, E-mail and Password' ) ) ; return false ; } if ( $ userpass <> $ userpass2 ) { throw new Exception ( t ( 'The user passwords do not match' ) ) ; return false ; } if ( ! $ account -> store ( $ application -> input -> data ( "post" ) , true ) ) { throw new Exception ( t ( 'Could not store the admin user account' ) ) ; return false ; } $ adminAuthority = $ this -> config -> get ( "setup.site.superadmin-authority" , NULL ) ; if ( ! empty ( $ adminAuthority ) ) { $ query = "INSERT INTO ?objects_authority( authority_id, object_id ) SELECT {$database->quote((int)$adminAuthority)}, object_id FROM ?objects WHERE object_uri={$database->quote($usernameid)}" ; $ database -> exec ( $ query ) ; } $ config -> set ( "setup.session.store" , "database" ) ; $ config -> set ( "setup.database.installed" , TRUE ) ; if ( ! $ config -> saveParams ( ) ) { throw new Exception ( "could not save config" ) ; return false ; } return true ; }
8369	public function archiveAction ( string $ production_slug , AuthorizationCheckerInterface $ auth , PaginatorInterface $ paginator , Request $ request ) : Response { $ production_repo = $ this -> em -> getRepository ( Production :: class ) ; if ( null === $ production = $ production_repo -> findOneBy ( [ 'slug' => $ production_slug ] ) ) { throw new NotFoundHttpException ( ) ; } if ( ! $ auth -> isGranted ( 'GROUP_ROLE_EDITOR' , $ production ) ) { throw new AccessDeniedException ( ) ; } $ query = $ this -> em -> getRepository ( Post :: class ) -> getAllInactiveQuery ( $ production ) ; $ posts = $ paginator -> paginate ( $ query , $ request -> query -> getInt ( 'page' , 1 ) ) ; return new Response ( $ this -> templating -> render ( '@BkstgNoticeBoard/Board/archive.html.twig' , [ 'production' => $ production , 'posts' => $ posts , ] ) ) ; }
4614	public function withRangeValue ( $ lowerBound , $ upperBound ) { $ this -> lowerBound = $ lowerBound ; $ this -> upperBound = $ upperBound ; $ this -> match = null ; return $ this ; }
12147	public function hasException ( \ Exception $ exception ) { $ class = get_class ( $ exception ) ; $ exceptions = $ this -> getExceptions ( ) ; return isset ( $ exceptions [ $ class ] ) ; }
10144	private function readBof ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = substr ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; $ substreamType = self :: getUInt2d ( $ recordData , 2 ) ; switch ( $ substreamType ) { case self :: XLS_WORKBOOKGLOBALS : $ version = self :: getUInt2d ( $ recordData , 0 ) ; if ( ( $ version != self :: XLS_BIFF8 ) && ( $ version != self :: XLS_BIFF7 ) ) { throw new Exception ( 'Cannot read this Excel file. Version is too old.' ) ; } $ this -> version = $ version ; break ; case self :: XLS_WORKSHEET : break ; default : do { $ code = self :: getUInt2d ( $ this -> data , $ this -> pos ) ; $ this -> readDefault ( ) ; } while ( $ code != self :: XLS_TYPE_EOF && $ this -> pos < $ this -> dataSize ) ; break ; } }
7166	private function buildShipmentLine ( Model \ SaleInterface $ sale ) { if ( null === $ sale -> getShipmentMethod ( ) && ! $ this -> options [ 'private' ] ) { return ; } $ lineNumber = $ this -> lineNumber ++ ; $ view = new LineView ( 'shipment' , 'shipment' , $ lineNumber , 0 ) ; $ designation = 'Shipping cost' ; if ( null !== $ method = $ sale -> getShipmentMethod ( ) ) { $ designation = $ method -> getTitle ( ) ; } $ designation .= ' (' . $ this -> formatter -> number ( $ sale -> getWeightTotal ( ) ) . ' kg)' ; $ result = $ sale -> getShipmentResult ( ) ; $ view -> setDesignation ( $ designation ) -> setBase ( $ this -> formatter -> currency ( $ result -> getBase ( ) ) ) -> setTaxRates ( $ this -> formatter -> rates ( ... $ result -> getTaxAdjustments ( ) ) ) -> setTaxAmount ( $ this -> formatter -> currency ( $ result -> getTax ( ) ) ) -> setTotal ( $ this -> formatter -> currency ( $ result -> getTotal ( ) ) ) ; foreach ( $ this -> types as $ type ) { $ type -> buildShipmentView ( $ sale , $ view , $ this -> options ) ; } $ this -> view -> setShipment ( $ view ) ; }
8396	public static function ensureTable ( array $ mapping ) : bool { $ database = Database :: get ( $ mapping [ 'config' ] [ 'database' ] ) ; $ statement = 'CREATE TABLE IF NOT EXISTS _stray_migration (' ; $ statement .= 'date TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL, ' ; $ statement .= 'migration VARCHAR(255)' ; $ statement .= ')' ; $ statement = $ database -> getMasterLink ( ) -> prepare ( $ statement ) ; if ( $ statement -> execute ( ) === false ) { echo 'Can\'t create _stray_migration (' . $ statement -> errorInfo ( ) [ 2 ] . ')' . PHP_EOL ; return false ; } $ select = new Select ( $ mapping [ 'config' ] [ 'database' ] , true ) ; $ select -> select ( 'COUNT(*) as count' ) -> from ( '_stray_migration' ) ; if ( $ select -> execute ( ) === false ) { echo 'Can\'t fetch from _stray_migration (' . $ select -> getErrorMessage ( ) . ')' . PHP_EOL ; return false ; } if ( $ select -> fetch ( ) [ 'count' ] == 0 ) { $ insert = new Insert ( $ mapping [ 'config' ] [ 'database' ] ) ; $ insert -> into ( '_stray_migration' ) ; if ( $ insert -> execute ( ) === false ) { echo 'Can\'t insert into _stray_migration (' . $ insert -> getErrorMessage ( ) . ')' . PHP_EOL ; return false ; } } return true ; }
11284	protected function _populateNonModelData ( $ record ) { $ nonObjectData = array_diff_key ( $ record , $ this -> model_attributes ) ; if ( count ( $ nonObjectData ) > 0 ) { foreach ( $ nonObjectData as $ key => $ value ) { $ this -> $ key = $ value ; } } }
10190	public function getAllSpContainers ( ) { $ allSpContainers = [ ] ; foreach ( $ this -> children as $ child ) { if ( $ child instanceof self ) { $ allSpContainers = array_merge ( $ allSpContainers , $ child -> getAllSpContainers ( ) ) ; } else { $ allSpContainers [ ] = $ child ; } } return $ allSpContainers ; }
12293	public function update ( array $ data , $ id ) { $ resource = $ this -> model -> find ( $ id ) ; if ( ! $ resource ) { return '' ; } $ resource -> update ( $ data ) ; return $ resource ; }
10528	protected function getIpAddressFromProxy ( ) { if ( ! $ this -> useProxy || ( isset ( $ _SERVER [ 'REMOTE_ADDR' ] ) && ! in_array ( $ _SERVER [ 'REMOTE_ADDR' ] , $ this -> trustedProxies ) ) ) { return false ; } $ header = $ this -> proxyHeader ; if ( ! isset ( $ _SERVER [ $ header ] ) || empty ( $ _SERVER [ $ header ] ) ) { return false ; } $ ips = explode ( ',' , $ _SERVER [ $ header ] ) ; $ ips = array_map ( 'trim' , $ ips ) ; $ ips = array_diff ( $ ips , $ this -> trustedProxies ) ; if ( empty ( $ ips ) ) { return false ; } $ ip = array_pop ( $ ips ) ; return $ ip ; }
2802	public static function parseBooleanValue ( $ value ) : bool { if ( \ is_bool ( $ value ) ) { return $ value ; } if ( \ is_string ( $ value ) ) { $ value = \ strtolower ( $ value ) ; return 'true' === $ value ; } if ( \ is_object ( $ value ) || \ is_array ( $ value ) || \ is_callable ( $ value ) ) { return false ; } return ( bool ) $ value ; }
9543	public function getMessages ( ) { $ messages = array ( ) ; if ( ! empty ( $ this -> error ) ) { $ messages [ ] = $ this -> error ; } if ( ! empty ( $ this -> warning ) ) { $ messages [ ] = $ this -> warning ; } return $ messages ; }
2864	public function getLastFilePosition ( $ filePath ) { if ( ! file_exists ( $ filePath ) ) { return 0 ; } $ f = fopen ( $ filePath , 'r' ) ; fseek ( $ f , - 1 , SEEK_END ) ; return ftell ( $ f ) ; }
379	public function renderCallStackItem ( $ file , $ line , $ class , $ method , $ args , $ index ) { $ lines = [ ] ; $ begin = $ end = 0 ; if ( $ file !== null && $ line !== null ) { $ line -- ; $ lines = @ file ( $ file ) ; if ( $ line < 0 || $ lines === false || ( $ lineCount = count ( $ lines ) ) < $ line ) { return '' ; } $ half = ( int ) ( ( $ index === 1 ? $ this -> maxSourceLines : $ this -> maxTraceSourceLines ) / 2 ) ; $ begin = $ line - $ half > 0 ? $ line - $ half : 0 ; $ end = $ line + $ half < $ lineCount ? $ line + $ half : $ lineCount - 1 ; } return $ this -> renderFile ( $ this -> callStackItemView , [ 'file' => $ file , 'line' => $ line , 'class' => $ class , 'method' => $ method , 'index' => $ index , 'lines' => $ lines , 'begin' => $ begin , 'end' => $ end , 'args' => $ args , ] ) ; }
10641	public function andWhere ( $ column , $ op , $ value , $ isParam = true ) { $ this -> clauses [ ] = array ( "AND" , $ column , $ op , $ value , $ isParam ) ; return $ this ; }
11471	public function edit ( ResponseRequest $ request , Response $ response ) { return $ this -> response -> title ( trans ( 'app.edit' ) . ' ' . trans ( 'forum::response.name' ) ) -> view ( 'forum::response.edit' , true ) -> data ( compact ( 'response' ) ) -> output ( ) ; }
6727	public function set_movie_votes ( $ post_id , $ total_votes ) { $ total_votes = $ total_votes ? : 'N/B' ; if ( ! add_post_meta ( $ post_id , 'imdbVotes' , $ total_votes , true ) ) { update_post_meta ( $ post_id , 'imdbVotes' , $ total_votes ) ; } }
5830	public function prepareRequest ( Request $ request ) { $ this -> ch = curl_init ( ) ; curl_setopt ( $ this -> ch , CURLOPT_RETURNTRANSFER , true ) ; curl_setopt ( $ this -> ch , CURLOPT_HEADER , true ) ; curl_setopt ( $ this -> ch , CURLOPT_URL , $ request -> getUrl ( ) ) ; $ options = $ request -> getOptions ( ) ; if ( ! empty ( $ options ) ) { curl_setopt_array ( $ this -> ch , $ options ) ; } $ method = $ request -> getMethod ( ) ; if ( $ method === 'post' ) { curl_setopt ( $ this -> ch , CURLOPT_POST , 1 ) ; } elseif ( $ method !== 'get' ) { curl_setopt ( $ this -> ch , CURLOPT_CUSTOMREQUEST , strtoupper ( $ method ) ) ; } curl_setopt ( $ this -> ch , CURLOPT_HTTPHEADER , $ request -> formatHeaders ( ) ) ; if ( $ this -> methods [ $ method ] === true ) { curl_setopt ( $ this -> ch , CURLOPT_POSTFIELDS , $ request -> encodeData ( ) ) ; } }
11250	public function delete ( string $ migration ) : void { $ stmt = $ this -> pdo -> prepare ( "delete from {$this->table} where migration = ?" ) ; $ stmt -> bindParam ( 1 , $ migration ) ; $ stmt -> execute ( ) ; }
2708	public function afterSave ( \ Magento \ Config \ Model \ Config $ subject ) { if ( $ this -> purge ) { $ this -> api -> cleanBySurrogateKey ( [ 'text' ] ) ; } }
2652	public function uploadSnippet ( $ version , array $ snippet ) { if ( isset ( $ snippet [ 'content' ] ) ) { $ adminUrl = $ this -> vcl -> getAdminFrontName ( ) ; $ adminPathTimeout = $ this -> config -> getAdminPathTimeout ( ) ; $ ignoredUrlParameters = $ this -> config -> getIgnoredUrlParameters ( ) ; $ ignoredUrlParameterPieces = explode ( "," , $ ignoredUrlParameters ) ; $ filterIgnoredUrlParameterPieces = array_filter ( array_map ( 'trim' , $ ignoredUrlParameterPieces ) ) ; $ queryParameters = implode ( '|' , $ filterIgnoredUrlParameterPieces ) ; $ snippet [ 'content' ] = str_replace ( '####ADMIN_PATH####' , $ adminUrl , $ snippet [ 'content' ] ) ; $ snippet [ 'content' ] = str_replace ( '####ADMIN_PATH_TIMEOUT####' , $ adminPathTimeout , $ snippet [ 'content' ] ) ; $ snippet [ 'content' ] = str_replace ( '####QUERY_PARAMETERS####' , $ queryParameters , $ snippet [ 'content' ] ) ; } $ checkIfExists = $ this -> hasSnippet ( $ version , $ snippet [ 'name' ] ) ; $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/snippet' ; if ( ! $ checkIfExists ) { $ verb = \ Zend_Http_Client :: POST ; } else { $ verb = \ Zend_Http_Client :: PUT ; $ url .= '/' . $ snippet [ 'name' ] ; unset ( $ snippet [ 'name' ] , $ snippet [ 'type' ] , $ snippet [ 'dynamic' ] , $ snippet [ 'priority' ] ) ; } $ result = $ this -> _fetch ( $ url , $ verb , $ snippet ) ; if ( ! $ result ) { throw new LocalizedException ( __ ( 'Failed to upload the Snippet file.' ) ) ; } }
4979	public function get ( $ form , $ options = null , $ params = null ) { if ( ! is_object ( $ form ) ) { $ form = $ this -> formElementManager -> get ( $ form , $ options ) ; } $ params = $ params ? : clone $ this -> getController ( ) -> getRequest ( ) -> getQuery ( ) ; $ hydrator = $ form -> getHydrator ( ) ; $ data = $ hydrator -> extract ( $ params ) ; $ form -> setData ( $ data ) ; $ hydrator -> hydrate ( $ data , $ params ) ; return $ form ; }
10178	public function removeRow ( $ row ) { foreach ( $ this -> getCoordinates ( ) as $ coord ) { sscanf ( $ coord , '%[A-Z]%d' , $ c , $ r ) ; if ( $ r == $ row ) { $ this -> delete ( $ coord ) ; } } }
2321	public static function get ( $ image , $ width , $ height , $ mode = '' , $ target = null , $ force = false ) { @ trigger_error ( 'Using Image::get() has been deprecated and will no longer work in Contao 5.0. Use the contao.image.image_factory service instead.' , E_USER_DEPRECATED ) ; if ( $ image == '' ) { return null ; } try { $ imageObj = static :: create ( $ image , array ( $ width , $ height , $ mode ) ) ; $ imageObj -> setTargetPath ( $ target ) ; $ imageObj -> setForceOverride ( $ force ) ; if ( $ path = $ imageObj -> executeResize ( ) -> getResizedPath ( ) ) { return $ path ; } } catch ( \ Exception $ e ) { System :: log ( 'Image "' . $ image . '" could not be processed: ' . $ e -> getMessage ( ) , __METHOD__ , 'ERROR' ) ; } return null ; }
3016	public function reblogPost ( $ blogName , $ postId , $ reblogKey , $ options = null ) { $ params = array ( 'id' => $ postId , 'reblog_key' => $ reblogKey ) ; $ params = array_merge ( $ options ? : array ( ) , $ params ) ; $ path = $ this -> blogPath ( $ blogName , '/post/reblog' ) ; return $ this -> postRequest ( $ path , $ params , false ) ; }
164	public static function create ( $ from ) { return new self ( [ 'where' => $ from -> where , 'limit' => $ from -> limit , 'offset' => $ from -> offset , 'orderBy' => $ from -> orderBy , 'indexBy' => $ from -> indexBy , 'select' => $ from -> select , 'selectOption' => $ from -> selectOption , 'distinct' => $ from -> distinct , 'from' => $ from -> from , 'groupBy' => $ from -> groupBy , 'join' => $ from -> join , 'having' => $ from -> having , 'union' => $ from -> union , 'params' => $ from -> params , ] ) ; }
11108	public function logRequest ( APIRequest $ request ) : void { $ item = $ this -> cacheItemPool -> getItem ( $ this -> deriveCacheKey ( $ request ) ) ; if ( $ requestCount = $ item -> get ( ) ) { $ item -> set ( $ requestCount + 1 ) ; } else { $ item -> set ( 1 ) -> expiresAfter ( $ this -> perXSeconds ) ; } $ this -> cacheItemPool -> save ( $ item ) ; }
8438	public function setPostLink ( TimelineLinkEvent $ event ) : void { $ action = $ event -> getAction ( ) ; if ( ! in_array ( $ action -> getVerb ( ) , [ 'post' , 'reply' ] ) ) { return ; } $ production = $ action -> getComponent ( 'indirectComplement' ) -> getData ( ) ; $ post = $ action -> getComponent ( 'directComplement' ) -> getData ( ) ; $ event -> setLink ( $ this -> url_generator -> generate ( 'bkstg_board_show' , [ 'production_slug' => $ production -> getSlug ( ) , '_fragment' => 'post-' . $ post -> getId ( ) , ] ) ) ; }
5250	public function save ( $ columns = [ '*' ] ) { $ columns = $ columns ? ( array ) $ columns : [ '*' ] ; if ( $ this -> saving ( ) === false ) { return false ; } $ this -> fillTimestamp ( ) ; $ this -> _dal -> put ( $ columns ) ; $ this -> _exist = true ; if ( $ this -> saved ( ) === false ) { return false ; } return true ; }
5272	protected function translateOrderBy ( ) { $ build = array ( ) ; foreach ( $ this -> statements [ 'orders' ] as $ column => $ direction ) { if ( is_array ( $ direction ) ) { list ( $ column , $ direction ) = $ direction ; } if ( ! is_null ( $ direction ) ) { $ column .= ' ' . $ direction ; } $ build [ ] = $ column ; } return 'order by ' . join ( ', ' , $ build ) ; }
3429	protected function propsMustBeSelected ( ) { return in_array ( 'PROPS' , $ this -> select ) || in_array ( 'PROPERTIES' , $ this -> select ) || in_array ( 'PROPERTY_VALUES' , $ this -> select ) ; }
6816	public function isSameAs ( Adjustment $ adjustment ) : bool { return $ this -> name === $ adjustment -> getName ( ) && $ this -> rate === $ adjustment -> getRate ( ) ; }
8241	protected function getDirFiles ( $ searchDir ) { $ files = @ scandir ( $ searchDir , SCANDIR_SORT_NONE ) ; if ( $ files === false ) { throw new \ RuntimeException ( "Cannot list directory contents: {$searchDir}." ) ; } return array_diff ( $ files , array ( '..' , '.' ) ) ; }
719	public function time ( $ precision = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_TIME , $ precision ) ; }
2750	public function getVclSnippets ( $ path = '/vcl_snippets' , $ specificFile = null ) { $ snippetsData = [ ] ; $ moduleEtcPath = $ this -> reader -> getModuleDir ( Dir :: MODULE_ETC_DIR , 'Fastly_Cdn' ) . $ path ; $ directoryRead = $ this -> readFactory -> create ( $ moduleEtcPath ) ; if ( ! $ specificFile ) { $ files = $ directoryRead -> read ( ) ; if ( is_array ( $ files ) ) { foreach ( $ files as $ file ) { if ( substr ( $ file , strpos ( $ file , "." ) + 1 ) !== 'vcl' ) { continue ; } $ snippetFilePath = $ moduleEtcPath . '/' . $ file ; $ snippetFilePath = $ directoryRead -> getRelativePath ( $ snippetFilePath ) ; $ type = explode ( '.' , $ file ) [ 0 ] ; $ snippetsData [ $ type ] = $ directoryRead -> readFile ( $ snippetFilePath ) ; } } } else { $ snippetFilePath = $ moduleEtcPath . '/' . $ specificFile ; $ snippetFilePath = $ directoryRead -> getRelativePath ( $ snippetFilePath ) ; $ type = explode ( '.' , $ specificFile ) [ 0 ] ; $ snippetsData [ $ type ] = $ directoryRead -> readFile ( $ snippetFilePath ) ; } return $ snippetsData ; }
3815	protected function process ( $ table , $ metaModelName , $ parentId , Request $ request ) { $ this -> knownAttributes = $ this -> fetchExisting ( $ table , $ parentId ) ; $ metaModel = $ this -> factory -> getMetaModel ( $ metaModelName ) ; if ( ! $ metaModel ) { throw new \ RuntimeException ( 'Could not retrieve MetaModel ' . $ metaModelName ) ; } if ( $ request -> request -> has ( 'add' ) || $ request -> request -> has ( 'saveNclose' ) ) { $ this -> perform ( $ table , $ request , $ metaModel , $ parentId ) ; if ( $ request -> request -> has ( 'saveNclose' ) ) { return new RedirectResponse ( $ this -> getReferer ( $ request , $ table , false ) ) ; } } return new Response ( $ this -> templating -> render ( 'MetaModelsCoreBundle::Backend/add-all.html.twig' , $ this -> render ( $ table , $ metaModel , $ request ) ) ) ; }
6705	public function getWriterFactory ( ) { if ( ! $ this -> writerFactory ) { $ xmlFormatter = new Xml ( ) ; $ jsonFormatter = new Json ( ) ; $ this -> writerFactory = new WriterFactory ( [ 'xml' => $ xmlFormatter , 'text/xml' => $ xmlFormatter , 'application/xml' => $ xmlFormatter , 'json' => $ jsonFormatter , 'application/json' => $ jsonFormatter , ] ) ; } return $ this -> writerFactory ; }
10115	private function writeFooter ( ) { $ record = 0x0015 ; $ recordData = StringHelper :: UTF8toBIFF8UnicodeLong ( $ this -> phpSheet -> getHeaderFooter ( ) -> getOddFooter ( ) ) ; $ length = strlen ( $ recordData ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ this -> append ( $ header . $ recordData ) ; }
3023	public function getBlogFollowers ( $ blogName , $ options = null ) { $ path = $ this -> blogPath ( $ blogName , '/followers' ) ; return $ this -> getRequest ( $ path , $ options , false ) ; }
11345	public function render ( ) { $ html = $ this -> formatter -> renderFormBegin ( $ this -> formTags ) ; foreach ( $ this -> fields as $ field ) { $ html .= $ this -> formatter -> renderField ( $ field ) ; } $ html .= $ this -> renderSubmit ( ) ; $ html .= $ this -> renderEnd ( ) ; return $ html ; }
797	public function getArrayEnd ( $ index ) { $ level = 1 ; for ( ++ $ index , $ max = \ count ( $ this ) ; $ index < $ max ; ++ $ index ) { if ( $ this [ $ index ] -> isType ( DocLexer :: T_OPEN_CURLY_BRACES ) ) { ++ $ level ; } elseif ( $ this [ $ index ] -> isType ( $ index , DocLexer :: T_CLOSE_CURLY_BRACES ) ) { -- $ level ; } if ( 0 === $ level ) { return $ index ; } } return null ; }
8176	public function actionRecoverPassword ( ) { $ model = new AccountRecoverPasswordForm ( ) ; if ( $ model -> load ( Yii :: $ app -> request -> post ( ) ) ) { if ( $ model -> validate ( ) ) { $ model -> recoverPassword ( ) ; } } return $ this -> render ( 'recoverPassword' , [ 'model' => $ model ] ) ; }
5274	public function groupBy ( $ columns ) { if ( is_string ( $ columns ) ) { $ columns = $ this -> argument_to_array ( $ columns ) ; } $ this -> statements [ 'groups' ] = $ this -> statements [ 'groups' ] + $ columns ; return $ this ; }
6430	public function completeLogin ( $ extrainputs = array ( ) ) { $ facebook = $ this -> getFacebookObject ( ) ; $ old_GET = $ _GET ; $ _GET = $ extrainputs ; $ helper = $ facebook -> getRedirectLoginHelper ( ) ; $ accessToken = $ helper -> getAccessToken ( ) ; $ _GET = $ old_GET ; if ( ! isset ( $ accessToken ) ) { if ( $ helper -> getError ( ) ) { throw new \ Exception ( $ helper -> getError ( ) . ' ' . $ helper -> getErrorCode ( ) . ' ' . $ helper -> getErrorReason ( ) . ' ' . $ helper -> getErrorDescription ( ) ) ; } else { throw new \ Exception ( 'Unknown error from Facebook' ) ; } } $ this -> accesstoken = $ accessToken ; return $ this -> getUserProfile ( ) ; }
3001	public function setHTML ( $ message ) { $ f3 = \ Base :: instance ( ) ; $ tmpl = new \ Template ( ) ; if ( $ f3 -> exists ( 'mailer.jumplinks' , $ jumplink ) && $ jumplink ) $ tmpl -> extend ( 'a' , function ( $ node ) use ( $ f3 , $ tmpl ) { if ( isset ( $ node [ '@attrib' ] ) ) { $ attr = $ node [ '@attrib' ] ; unset ( $ node [ '@attrib' ] ) ; } else $ attr = array ( ) ; if ( isset ( $ attr [ 'href' ] ) ) { if ( ! $ f3 -> exists ( 'mailer.jump_route' , $ ping_route ) ) $ ping_route = '/mailer-jump' ; $ attr [ 'href' ] = $ f3 -> get ( 'SCHEME' ) . '://' . $ f3 -> get ( 'HOST' ) . $ f3 -> get ( 'BASE' ) . $ ping_route . '?target=' . urlencode ( $ attr [ 'href' ] ) ; } $ params = '' ; foreach ( $ attr as $ key => $ value ) $ params .= ' ' . $ key . '="' . $ value . '"' ; return '<a' . $ params . '>' . $ tmpl -> build ( $ node ) . '</a>' ; } ) ; $ message = $ tmpl -> build ( $ tmpl -> parse ( $ message ) ) ; $ this -> setContent ( $ message , 'text/html' ) ; }
2071	private function getDateAndTime ( CalendarEventsModel $ objEvent , PageModel $ objPage , $ intStartTime , $ intEndTime , $ span ) { $ strDate = Date :: parse ( $ objPage -> dateFormat , $ intStartTime ) ; if ( $ span > 0 ) { $ strDate = Date :: parse ( $ objPage -> dateFormat , $ intStartTime ) . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'cal_timeSeparator' ] . Date :: parse ( $ objPage -> dateFormat , $ intEndTime ) ; } $ strTime = '' ; if ( $ objEvent -> addTime ) { if ( $ span > 0 ) { $ strDate = Date :: parse ( $ objPage -> datimFormat , $ intStartTime ) . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'cal_timeSeparator' ] . Date :: parse ( $ objPage -> datimFormat , $ intEndTime ) ; } elseif ( $ intStartTime == $ intEndTime ) { $ strTime = Date :: parse ( $ objPage -> timeFormat , $ intStartTime ) ; } else { $ strTime = Date :: parse ( $ objPage -> timeFormat , $ intStartTime ) . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'cal_timeSeparator' ] . Date :: parse ( $ objPage -> timeFormat , $ intEndTime ) ; } } return array ( $ strDate , $ strTime ) ; }
7603	public function render ( ElementInterface $ oElement ) { $ sElementType = $ oElement -> getAttribute ( 'type' ) ; if ( ! in_array ( $ sElementType , $ this -> options -> getIgnoredViewHelpers ( ) ) && ! ( $ oElement instanceof Collection ) ) { if ( $ sElementClass = $ oElement -> getAttribute ( 'class' ) ) { if ( ! preg_match ( '/(\s|^)form-control(\s|$)/' , $ sElementClass ) ) { $ oElement -> setAttribute ( 'class' , trim ( $ sElementClass . ' form-control' ) ) ; } } else { $ oElement -> setAttribute ( 'class' , 'form-control' ) ; } } $ sMarkup = parent :: render ( $ oElement ) ; if ( $ aAddOnPrepend = $ oElement -> getOption ( 'add-on-prepend' ) ) { $ sMarkup = $ this -> renderAddOn ( $ aAddOnPrepend ) . $ sMarkup ; } if ( $ aAddOnAppend = $ oElement -> getOption ( 'add-on-append' ) ) { $ sMarkup .= $ this -> renderAddOn ( $ aAddOnAppend ) ; } if ( $ aAddOnAppend || $ aAddOnPrepend ) { $ sSpecialClass = '' ; if ( $ sElementClass = $ oElement -> getAttribute ( 'class' ) ) { if ( preg_match ( '/(\s|^)input-lg(\s|$)/' , $ sElementClass ) ) { $ sSpecialClass .= ' input-group-lg' ; } elseif ( preg_match ( '/(\s|^)input-sm(\s|$)/' , $ sElementClass ) ) { $ sSpecialClass .= ' input-group-sm' ; } } return sprintf ( static :: $ inputGroupFormat , trim ( $ sSpecialClass ) , $ sMarkup ) ; } return $ sMarkup ; }
773	public function actionExtract ( $ configFile = null ) { $ this -> initConfig ( $ configFile ) ; $ files = FileHelper :: findFiles ( realpath ( $ this -> config [ 'sourcePath' ] ) , $ this -> config ) ; $ messages = [ ] ; foreach ( $ files as $ file ) { $ messages = array_merge_recursive ( $ messages , $ this -> extractMessages ( $ file , $ this -> config [ 'translator' ] , $ this -> config [ 'ignoreCategories' ] ) ) ; } $ catalog = isset ( $ this -> config [ 'catalog' ] ) ? $ this -> config [ 'catalog' ] : 'messages' ; if ( in_array ( $ this -> config [ 'format' ] , [ 'php' , 'po' ] ) ) { foreach ( $ this -> config [ 'languages' ] as $ language ) { $ dir = $ this -> config [ 'messagePath' ] . DIRECTORY_SEPARATOR . $ language ; if ( ! is_dir ( $ dir ) && ! @ mkdir ( $ dir ) ) { throw new Exception ( "Directory '{$dir}' can not be created." ) ; } if ( $ this -> config [ 'format' ] === 'po' ) { $ this -> saveMessagesToPO ( $ messages , $ dir , $ this -> config [ 'overwrite' ] , $ this -> config [ 'removeUnused' ] , $ this -> config [ 'sort' ] , $ catalog , $ this -> config [ 'markUnused' ] ) ; } else { $ this -> saveMessagesToPHP ( $ messages , $ dir , $ this -> config [ 'overwrite' ] , $ this -> config [ 'removeUnused' ] , $ this -> config [ 'sort' ] , $ this -> config [ 'markUnused' ] ) ; } } } elseif ( $ this -> config [ 'format' ] === 'db' ) { $ db = Instance :: ensure ( $ this -> config [ 'db' ] , Connection :: className ( ) ) ; $ sourceMessageTable = isset ( $ this -> config [ 'sourceMessageTable' ] ) ? $ this -> config [ 'sourceMessageTable' ] : '{{%source_message}}' ; $ messageTable = isset ( $ this -> config [ 'messageTable' ] ) ? $ this -> config [ 'messageTable' ] : '{{%message}}' ; $ this -> saveMessagesToDb ( $ messages , $ db , $ sourceMessageTable , $ messageTable , $ this -> config [ 'removeUnused' ] , $ this -> config [ 'languages' ] , $ this -> config [ 'markUnused' ] ) ; } elseif ( $ this -> config [ 'format' ] === 'pot' ) { $ this -> saveMessagesToPOT ( $ messages , $ this -> config [ 'messagePath' ] , $ catalog ) ; } }
4793	function order ( $ columns ) { $ this -> rows = null ; if ( $ columns != "" ) { foreach ( func_get_args ( ) as $ columns ) { if ( $ this -> union ) { $ this -> unionOrder [ ] = $ columns ; } else { $ this -> order [ ] = $ columns ; } } } elseif ( $ this -> union ) { $ this -> unionOrder = array ( ) ; } else { $ this -> order = array ( ) ; } return $ this ; }
1744	public function deleteFile ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { $ rootDir = Contao \ System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; $ path = $ rootDir . '/' . urldecode ( $ row [ 'id' ] ) ; if ( ! is_dir ( $ path ) ) { return ( $ this -> User -> hasAccess ( 'f3' , 'fop' ) || $ this -> User -> hasAccess ( 'f4' , 'fop' ) ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' ; } $ finder = Symfony \ Component \ Finder \ Finder :: create ( ) -> in ( $ path ) ; if ( $ finder -> count ( ) > 0 ) { return $ this -> User -> hasAccess ( 'f4' , 'fop' ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' ; } return $ this -> User -> hasAccess ( 'f3' , 'fop' ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' ; }
11336	public function getBaseNamespace ( ) { if ( ! empty ( $ this -> moduleSet ) && isset ( Yii :: $ app -> extensions [ $ this -> moduleSet ] ) ) { $ bsClass = Yii :: $ app -> extensions [ $ this -> moduleSet ] [ 'bootstrap' ] ; $ bsReflector = new \ ReflectionClass ( new $ bsClass ( ) ) ; return $ bsReflector -> getNamespaceName ( ) ; } return 'cascade\modules' ; }
8602	public function deregisterDestination ( $ request ) { if ( ! ( $ request instanceof MWSSubscriptionsService_Model_DeregisterDestinationInput ) ) { require_once ( dirname ( __FILE__ ) . '/Model/DeregisterDestinationInput.php' ) ; $ request = new MWSSubscriptionsService_Model_DeregisterDestinationInput ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'DeregisterDestination' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/DeregisterDestinationResponse.php' ) ; $ response = MWSSubscriptionsService_Model_DeregisterDestinationResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
6329	private function getColumnComments ( ) { $ escapement = new Escapement ( ) ; $ comments = '' ; foreach ( $ this -> table -> getColumns ( ) as $ column ) { $ columnDescription = $ column -> getDescription ( ) ; if ( ! empty ( $ columnDescription ) ) { $ comments .= sprintf ( "COMMENT ON COLUMN %s.%s IS '%s';" , $ escapement -> escape ( $ this -> table -> getQualifiedName ( ) ) , $ escapement -> escape ( $ column -> getName ( ) ) , $ columnDescription ) ; } } return $ comments ; }
2863	public function getLogging ( ) { $ logging = array ( ) ; foreach ( $ this -> files as $ logFile ) { $ logging [ $ logFile ] = $ this -> getLoggedContent ( $ logFile ) ; } return $ logging ; }
3719	protected function wantToHandle ( AbstractEnvironmentAwareEvent $ event ) { if ( ! parent :: wantToHandle ( $ event ) ) { return false ; } if ( $ event -> getPropertyName ( ) !== 'type' ) { return false ; } $ request = $ this -> requestStack -> getCurrentRequest ( ) ; if ( $ request -> request -> get ( 'act' , null ) === 'select' && ! $ event -> getModel ( ) -> getId ( ) ) { return false ; } return true ; }
7900	public function upload ( $ file , Closure $ callback = null ) { $ uploadedFile = $ this -> runUpload ( $ file ) ; if ( ! $ uploadedFile ) { return false ; } if ( $ callback ) { $ callback ( $ uploadedFile ) ; } return true ; }
1464	private function guessKey ( ) { if ( $ this -> query instanceof EloquentBuilder || $ this -> query instanceof Relation ) { return $ this -> query -> getModel ( ) -> getRouteKeyName ( ) ; } return 'id' ; }
5861	protected function compileRulesets ( array $ rulesets ) { $ out = [ ] ; $ elements = $ rulesets [ 'data' ] [ 'sDEF' ] [ 'lDEF' ] [ 'ruleset' ] [ 'el' ] ; foreach ( $ elements as $ container ) { if ( isset ( $ container [ 'container' ] [ 'el' ] ) ) { $ values = [ ] ; foreach ( $ container [ 'container' ] [ 'el' ] as $ key => $ value ) { if ( $ key === 'title' ) { continue ; } $ values [ $ key ] = $ value [ 'vDEF' ] ; } $ out [ ] = $ this -> expandValuesInRuleset ( $ values ) ; } } return $ out ; }
5509	public function expect ( $ method , $ args , $ message = '%s' ) { $ this -> dieOnNoMethod ( $ method , 'set expected arguments' ) ; $ this -> checkArgumentsIsArray ( $ args , 'set expected arguments' ) ; $ this -> expectations -> expectArguments ( $ method , $ args , $ message ) ; $ args = $ this -> replaceWildcards ( $ args ) ; $ message .= Mock :: getExpectationLine ( ) ; $ this -> expected_args [ strtolower ( $ method ) ] = new ParametersExpectation ( $ args , $ message ) ; }
6855	private function transform ( SaleInterface $ sale ) { $ order = $ this -> newOrder ( ) ; $ this -> saleTransformer -> initialize ( $ sale , $ order ) ; if ( null === $ event = $ this -> saleTransformer -> transform ( ) ) { return $ order ; } return null ; }
10589	public function buildPayoutFromId ( $ sPayoutId ) { $ oPayout = new Freeagent \ DataWrapper \ PayoutVO ( ) ; $ oPayout -> setId ( $ sPayoutId ) ; try { $ oDets = $ this -> getTxnChargeDetails ( $ sPayoutId ) ; $ oPayout -> setDateArrival ( strtotime ( $ oDets -> PaymentDate ) ) -> setCurrency ( $ oDets -> GrossAmount -> currencyID ) ; $ oPayout -> addCharge ( $ this -> buildChargeFromTransaction ( $ sPayoutId ) ) ; } catch ( \ Exception $ oE ) { } return $ oPayout ; }
11550	private function preencherLista ( $ pagamentos ) { $ resultado = array ( ) ; foreach ( $ pagamentos as $ pagamento ) { $ resultado [ ] = $ pagamento -> setAutenticacao ( $ this -> getAutenticacaoManager ( ) -> obterAutenticacaoBasica ( $ pagamento -> getAutenticacaoId ( ) ) ) ; } return $ resultado ; }
1940	public function checkUniqueRecipient ( $ varValue , Contao \ DataContainer $ dc ) { $ objRecipient = $ this -> Database -> prepare ( "SELECT COUNT(*) AS count FROM tl_newsletter_recipients WHERE email=? AND pid=(SELECT pid FROM tl_newsletter_recipients WHERE id=?) AND id!=?" ) -> execute ( $ varValue , $ dc -> id , $ dc -> id ) ; if ( $ objRecipient -> count > 0 ) { throw new Exception ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'unique' ] , $ GLOBALS [ 'TL_LANG' ] [ $ dc -> table ] [ $ dc -> field ] [ 0 ] ) ) ; } return $ varValue ; }
2655	public function createCondition ( $ version , array $ condition ) { $ checkIfExists = $ this -> getCondition ( $ version , $ condition [ 'name' ] ) ; $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/condition' ; if ( ! $ checkIfExists ) { $ verb = \ Zend_Http_Client :: POST ; } else { $ verb = \ Zend_Http_Client :: PUT ; $ url .= '/' . $ condition [ 'name' ] ; } $ result = $ this -> _fetch ( $ url , $ verb , $ condition ) ; if ( ! $ result ) { throw new LocalizedException ( __ ( 'Failed to create a REQUEST condition.' ) ) ; } return $ result ; }
4087	protected function transformDSLTermToString ( $ dslTerm ) { $ string = "" ; if ( is_array ( $ dslTerm ) ) { $ key = key ( $ dslTerm ) ; $ value = $ dslTerm [ $ key ] ; if ( is_string ( $ key ) ) $ string .= "$key:" ; } else $ value = $ dslTerm ; if ( strpos ( $ value , " " ) !== false ) $ string .= '"' . $ value . '"' ; else $ string .= $ value ; return $ string ; }
11361	public function isClicked ( string $ sType ) : bool { if ( $ this -> getType ( ) === 'submit' || $ this -> getType ( ) === 'button' ) { if ( isset ( $ _POST [ $ this -> getName ( ) ] ) ) { return true ; } } return false ; }
886	private function clear ( Tokens $ tokens , $ index ) { while ( ! $ tokens [ ++ $ index ] -> equals ( ';' ) ) { if ( $ this -> shouldClearToken ( $ tokens , $ index ) ) { $ tokens -> clearAt ( $ index ) ; } } }
5119	private function assessOptions ( array $ options ) : void { $ defaultOptions = [ 'rest_server' => self :: REST_SERVER , 'auth_url' => self :: AUTHENTICATION , 'max_attempt' => self :: DEFAULT_MAX_ATTEMPT , 'default_headers' => [ 'Accept' => 'application/json' , ] , ] ; $ this -> options = new Collection ( array_merge ( $ defaultOptions , $ options ) ) ; if ( isset ( $ options [ 'access_token' ] ) ) { $ this -> setAuthorizationHeader ( $ options [ 'access_token' ] ) ; } if ( isset ( $ options [ 'recycle_token' ] ) && is_callable ( $ options [ 'recycle_token' ] ) ) { $ this -> recycleToken ( $ options [ 'recycle_token' ] ) ; } if ( isset ( $ options [ 'token_saver' ] ) && is_callable ( $ options [ 'token_saver' ] ) ) { $ this -> setTokenSaver ( $ options [ 'token_saver' ] ) ; } $ this -> httpClient = new Client ( [ 'base_uri' => $ this -> options -> get ( 'rest_server' ) , ] ) ; }
1052	public static function build ( $ source , ? callable $ typeConfigDecorator = null , array $ options = [ ] ) { $ doc = $ source instanceof DocumentNode ? $ source : Parser :: parse ( $ source ) ; return self :: buildAST ( $ doc , $ typeConfigDecorator , $ options ) ; }
8514	public function listInboundShipmentsByNextToken ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_ListInboundShipmentsByNextTokenRequest ) ) { $ request = new FBAInboundServiceMWS_Model_ListInboundShipmentsByNextTokenRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListInboundShipmentsByNextToken' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_ListInboundShipmentsByNextTokenResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
4032	private function preCreateInverseImage ( ModelInterface $ model , string $ image ) : void { if ( false === $ intPos = strrpos ( $ image , '.' ) ) { return ; } if ( $ model -> getProperty ( 'enabled' ) ) { $ this -> iconBuilder -> getBackendIcon ( substr_replace ( $ image , '_1' , $ intPos , 0 ) ) ; return ; } $ this -> iconBuilder -> getBackendIcon ( $ image ) ; }
10225	public function itemsFor ( $ model , $ items = null , $ targetUrl = null , $ nextPageUrl = null , $ offset = - 1 , ModelConfig $ config = null ) { $ modelName = $ this -> resolveModelName ( $ model ) ; if ( $ items == null ) { $ items = call_user_func ( array ( $ modelName , 'simplePaginate' ) , 10 ) ; } $ factory = $ this -> app -> make ( 'Label305\AujaLaravel\Factory\ResourceItemsFactory' ) ; return $ factory -> create ( $ modelName , $ items , $ targetUrl , $ nextPageUrl , $ offset , $ config ) ; }
6362	public function convert ( float $ duration , TimeUnit $ timeUnit ) : float { return $ duration * ( $ timeUnit -> inMicros / $ this -> inMicros ) ; }
3981	private function getChildModelCaption ( $ metaModel , $ screen ) { $ caption = [ '' , sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'metamodel_edit_as_child' ] [ 'label' ] , $ metaModel -> getName ( ) ) ] ; foreach ( $ screen [ 'label' ] as $ langCode => $ label ) { if ( ! empty ( $ label ) && $ langCode === $ GLOBALS [ 'TL_LANGUAGE' ] ) { $ caption = [ $ screen [ 'description' ] [ $ langCode ] , $ label ] ; } } return $ caption ; }
3244	public function getWasPurchasedAttribute ( ) { if ( Auth :: guest ( ) ) return false ; return Auth :: user ( ) -> orders ( ) -> whereSKU ( $ this -> attributes [ 'sku' ] ) -> whereStatusIn ( config ( 'shop.order_status_purchase' ) ) -> count ( ) > 0 ; }
6340	public function SearchForm ( ) { if ( count ( Searchable :: config ( ) -> objects ) ) { $ searchText = "" ; if ( $ this -> owner -> request && $ this -> owner -> request -> getVar ( 'Search' ) ) { $ searchText = $ this -> owner -> request -> getVar ( 'Search' ) ; } $ fields = FieldList :: create ( TextField :: create ( 'Search' , false , $ searchText ) -> setAttribute ( "placeholder" , _t ( 'Searchable.Search' , 'Search' ) ) ) ; $ actions = FieldList :: create ( FormAction :: create ( 'results' , _t ( 'Searchable.Go' , 'Go' ) ) ) ; $ template_class = Searchable :: config ( ) -> template_class ; $ results_page = Injector :: inst ( ) -> create ( $ template_class ) ; $ form = Form :: create ( $ this -> owner , 'SearchForm' , $ fields , $ actions ) -> setFormMethod ( 'get' ) -> setFormAction ( $ results_page -> Link ( ) ) -> setTemplate ( 'ilateral\SilverStripe\Searchable\Includes\SearchForm' ) -> disableSecurityToken ( ) ; $ this -> owner -> extend ( "updateSearchForm" , $ form ) ; return $ form ; } }
8576	public function setItemChargeAdjustmentList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ItemChargeAdjustmentList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
8133	public function setSourceContext ( Twig_Source $ source = null ) { if ( null === $ source ) { $ this -> sourceCode = $ this -> filename = $ this -> sourcePath = null ; } else { $ this -> sourceCode = $ source -> getCode ( ) ; $ this -> filename = $ source -> getName ( ) ; $ this -> sourcePath = $ source -> getPath ( ) ; } $ this -> updateRepr ( ) ; }
12049	public static function showImageInSize ( int $ iImageUri , int $ iWidth , int $ iHeight , bool $ bKeepDimension = false ) { $ aSize = getimagesize ( $ iImageUri ) ; $ rActualImage = imagecreatefromjpeg ( $ iImageUri ) ; $ ImageChoisie = imagecreatefromjpeg ( $ _FILES [ 'ImageNews' ] [ 'tmp_name' ] ) ; $ TailleImageChoisie = getimagesize ( $ _FILES [ 'ImageNews' ] [ 'tmp_name' ] ) ; $ rNewImage = imagecreatetruecolor ( $ iWidth , $ iHeight ) ; if ( $ bKeepDimension === false ) { imagecopyresampled ( $ rNewImage , $ rActualImage , 0 , 0 , 0 , 0 , $ iWidth , $ iHeight , $ aSize [ 0 ] , $ aSize [ 1 ] ) ; } else { if ( $ aSize [ 0 ] > $ aSize [ 1 ] ) { $ rWhite = imagecolorallocate ( $ rNewImage , 255 , 255 , 255 ) ; imagefilledrectangle ( $ rNewImage , 0 , 0 , $ iWidth , $ iHeight , $ rWhite ) ; $ fCoef = $ aSize [ 1 ] / $ aSize [ 0 ] ; $ iHeight = round ( $ iWidth * $ fCoef ) ; $ iDestY = round ( ( $ iWidth - $ iHeight ) / 2 ) ; $ iDestX = 0 ; } else { $ rWhite = imagecolorallocate ( $ rNewImage , 255 , 255 , 255 ) ; imagefilledrectangle ( $ rNewImage , 0 , 0 , $ iWidth , $ iHeight , $ rWhite ) ; $ fCoef = $ aSize [ 0 ] / $ aSize [ 1 ] ; $ iWidth = round ( $ iHeight * $ fCoef ) ; $ iDestX = round ( ( $ iHeight - $ iWidth ) / 2 ) ; $ iDestY = 0 ; } $ rWhite = imagecolorallocate ( $ rNewImage , 255 , 255 , 255 ) ; imagefilledrectangle ( $ rNewImage , 0 , 0 , $ iWidth , $ iHeight , $ rWhite ) ; imagecopyresampled ( $ rNewImage , $ rActualImage , $ iDestX , $ iDestY , 0 , 0 , $ iWidth , $ iHeight , $ aSize [ 0 ] , $ aSize [ 1 ] ) ; } imagedestroy ( $ rActualImage ) ; $ NomImageChoisie = explode ( '.' , $ rNewImage ) ; $ NomImageExploitable = time ( ) ; header ( 'Content-Type: image/jpeg' ) ; imagejpeg ( $ rNewImage , null , 100 ) ; }
4397	protected function getRedirectForm ( \ Omnipay \ Common \ Message \ RedirectResponseInterface $ response ) { $ list = [ ] ; foreach ( ( array ) $ response -> getRedirectData ( ) as $ key => $ value ) { $ list [ $ key ] = new \ Aimeos \ MW \ Criteria \ Attribute \ Standard ( array ( 'label' => $ key , 'code' => $ key , 'type' => 'string' , 'internalcode' => $ key , 'internaltype' => 'string' , 'default' => $ value , 'public' => false , ) ) ; } $ url = $ response -> getRedirectUrl ( ) ; $ method = $ response -> getRedirectMethod ( ) ; return new \ Aimeos \ MShop \ Common \ Helper \ Form \ Standard ( $ url , $ method , $ list ) ; }
7692	function MsExcel_ConvertToExplicit_Item ( & $ Txt , $ Tag , $ Att , $ CellRow ) { $ tag_pc = strlen ( $ Tag ) + 1 ; $ rpl = '<' . $ Tag . ' ' . $ Att . '="' ; $ rpl_len = strlen ( $ rpl ) ; $ rpl_nbr = 0 ; $ p = 0 ; $ empty_first_pos = false ; $ empty_nbr = 0 ; $ item_num = 0 ; $ rpl_nbr = 0 ; while ( ( $ p = clsTinyButStrong :: f_Xml_FindTagStart ( $ Txt , $ Tag , true , $ p , true , true ) ) !== false ) { $ item_num ++ ; if ( $ empty_first_pos === false ) $ empty_first_pos = $ p ; $ p = $ p + $ tag_pc ; if ( substr ( $ Txt , $ p , 1 ) == '/' ) { $ empty_nbr ++ ; } else { $ ref = ( $ CellRow === false ) ? $ item_num : $ this -> Misc_CellRef ( $ item_num , $ CellRow ) ; $ x = $ rpl . $ ref . '"' ; $ len = $ p - $ empty_first_pos ; $ Txt = substr_replace ( $ Txt , $ x , $ empty_first_pos , $ len ) ; $ rpl_nbr ++ ; if ( $ CellRow === false ) { $ loc = new clsTbsXmlLoc ( $ Txt , $ Tag , $ p ) ; $ loc -> FindEndTag ( ) ; $ src = $ loc -> GetSrc ( ) ; $ nbr = $ this -> MsExcel_ConvertToExplicit_Item ( $ src , 'c' , 'r' , $ item_num ) ; if ( $ nbr > 0 ) { $ loc -> ReplaceSrc ( $ src ) ; } $ p = $ loc -> PosEnd ; } else { $ p = $ empty_first_pos + $ tag_pc ; } $ empty_nbr = 0 ; $ empty_first_pos = false ; } } return $ rpl_nbr ; }
3254	private function getItem ( $ sku ) { $ className = Config :: get ( 'shop.item' ) ; $ item = new $ className ( ) ; return $ item -> where ( 'sku' , $ sku ) -> where ( 'cart_id' , $ this -> attributes [ 'id' ] ) -> first ( ) ; }
7953	public function getSpam ( $ ipblock , $ spamstate ) { if ( ! $ ipblock ) throw new BadMethodCallException ( 'Parameter $ipblock is missing.' ) ; if ( ! $ spamstate ) throw new BadMethodCallException ( 'Parameter $spamstate is missing.' ) ; switch ( $ spamstate ) { case "blockedForSpam" : case "unblocked" : case "unblocking" : break ; default : throw new BadMethodCallException ( 'Parameter $spamstate is invalid.' ) ; } try { $ r = $ this -> get ( 'ip/' . urlencode ( $ ipblock ) . '/spam/?state=' . $ spamstate ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new IpException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
3986	public function getCombinations ( ) { $ user = $ this -> getUser ( ) ; switch ( true ) { case ( $ user instanceof BackendUser ) : $ mode = 'be' ; $ groups = $ user -> groups ; if ( $ user -> admin ) { $ groups [ ] = - 1 ; } break ; case ( $ user instanceof FrontendUser ) : $ mode = 'fe' ; $ groups = $ user -> groups ; if ( ! $ this -> getUser ( ) -> id ) { $ groups = [ - 1 ] ; } break ; default : $ mode = 'fe' ; $ groups = [ - 1 ] ; } $ groups = array_filter ( $ groups ) ; if ( $ this -> cache -> contains ( $ cacheKey = 'combinations_' . $ mode . '_' . implode ( ',' , $ groups ) ) ) { return $ this -> cache -> fetch ( $ cacheKey ) ; } $ combinations = $ this -> builder -> getCombinationsForUser ( $ groups , $ mode ) ; $ this -> cache -> save ( $ cacheKey , $ combinations ) ; return $ combinations ; }
5312	protected function getHTMLFromGenerator ( IconFontGenerator $ generator , $ fontFile ) { $ fontOptions = $ generator -> getFont ( ) -> getOptions ( ) ; $ html = '<!doctype html> <html> <head> <title>' . htmlspecialchars ( $ fontOptions [ 'id' ] ) . '</title> <style> @font-face { font-family: "' . $ fontOptions [ 'id' ] . '"; src: url("' . $ fontFile . '") format("svg"), url("' . substr ( $ fontFile , 0 , - 4 ) . '.woff") format("woff"), url("' . substr ( $ fontFile , 0 , - 4 ) . '.ttf") format("truetype"); font-weight: normal; font-style: normal; } body { font-family: sans-serif; color: #444; line-height: 1.5; font-size: 16px; padding: 20px; } * { -moz-box-sizing: border-box; -webkit-box-sizing: border-box; box-sizing: border-box; margin: 0; paddin: 0; } .glyph{ display: inline-block; width: 120px; margin: 10px; text-align: center; vertical-align: top; background: #eee; border-radius: 10px; box-shadow: 1px 1px 5px rgba(0, 0, 0, .2); } .glyph-icon{ padding: 10px; display: block; font-family: "' . $ fontOptions [ 'id' ] . '"; font-size: 64px; line-height: 1; } .glyph-icon:before{ content: attr(data-icon); } .class-name{ font-size: 12px; } .glyph > input{ display: block; width: 100px; margin: 5px auto; text-align: center; font-size: 12px; cursor: text; } .glyph > input.icon-input{ font-family: "' . $ fontOptions [ 'id' ] . '"; font-size: 16px; margin-bottom: 10px; } </style> </head> <body> <section id="glyphs">' ; $ glyphNames = $ generator -> getGlyphNames ( ) ; asort ( $ glyphNames ) ; foreach ( $ glyphNames as $ unicode => $ glyph ) { $ html .= '<div class="glyph"> <div class="glyph-icon" data-icon="&#x' . $ unicode . ';"></div> <div class="class-name">icon-' . $ glyph . '</div> <input type="text" readonly="readonly" value="&amp;#x' . $ unicode . ';" /> <input type="text" readonly="readonly" value="\\' . $ unicode . '" /> <input type="text" readonly="readonly" value="&#x' . $ unicode . ';" class="icon-input" /> </div>' ; } $ html .= '</section> </body> </html>' ; return $ html ; }
7703	function OpenDoc_ChartInit ( ) { $ this -> OpenDocCharts = array ( ) ; $ idx = $ this -> Ext_GetMainIdx ( ) ; $ Txt = $ this -> TbsStoreGet ( $ idx , 'OpenDoc_ChartInit' ) ; $ p = 0 ; while ( $ drEl = clsTbsXmlLoc :: FindElement ( $ Txt , 'draw:frame' , $ p ) ) { $ src = $ drEl -> GetInnerSrc ( ) ; $ objEl = clsTbsXmlLoc :: FindStartTag ( $ src , 'draw:object' , 0 ) ; if ( $ objEl ) { $ href = $ objEl -> GetAttLazy ( 'xlink:href' ) ; if ( $ href ) { $ imgEl = clsTbsXmlLoc :: FindElement ( $ src , 'draw:image' , 0 ) ; $ img_href = ( $ imgEl ) ? $ imgEl -> GetAttLazy ( 'xlink:href' ) : false ; $ img_src = ( $ imgEl ) ? $ imgEl -> GetSrc ( 'xlink:href' ) : false ; $ titEl = clsTbsXmlLoc :: FindElement ( $ src , 'svg:title' , 0 ) ; $ title = ( $ titEl ) ? $ titEl -> GetInnerSrc ( ) : '' ; if ( substr ( $ href , 0 , 2 ) == './' ) $ href = substr ( $ href , 2 ) ; if ( is_string ( $ img_href ) && ( substr ( $ img_href , 0 , 2 ) == './' ) ) $ img_href = substr ( $ img_href , 2 ) ; $ this -> OpenDocCharts [ ] = array ( 'href' => $ href , 'title' => $ title , 'img_href' => $ img_href , 'img_src' => $ img_src , 'to_clear' => ( $ img_href !== false ) ) ; } } $ p = $ drEl -> PosEnd ; } }
9365	public function multiply ( $ z ) { if ( is_numeric ( $ z ) ) { $ z = new self ( $ z , 0 ) ; } return new self ( ( $ this -> float_r * $ z -> re ) - ( $ this -> float_i * $ z -> im ) , ( $ this -> float_r * $ z -> im ) + ( $ z -> re * $ this -> float_i ) ) ; }
8992	public function getAttributeNames ( $ entity ) { if ( ! $ entity instanceof \ ElggEntity ) { return array ( ) ; } $ default = array ( 'guid' , 'type' , 'subtype' , 'owner_guid' , 'container_guid' , 'site_guid' , 'access_id' , 'time_created' , 'time_updated' , 'last_action' , 'enabled' , ) ; switch ( $ entity -> getType ( ) ) { case 'user' ; $ attributes = array ( 'name' , 'username' , 'email' , 'language' , 'banned' , 'admin' , 'password' , 'salt' ) ; break ; case 'group' : $ attributes = array ( 'name' , 'description' , ) ; break ; case 'object' : $ attributes = array ( 'title' , 'description' , ) ; break ; } return array_merge ( $ default , $ attributes ) ; }
869	private function createProcessForSource ( $ source ) { if ( null === $ this -> temporaryFile ) { $ this -> temporaryFile = tempnam ( '.' , 'cs_fixer_tmp_' ) ; $ this -> fileRemoval -> observe ( $ this -> temporaryFile ) ; } if ( false === @ file_put_contents ( $ this -> temporaryFile , $ source ) ) { throw new IOException ( sprintf ( 'Failed to write file "%s".' , $ this -> temporaryFile ) , 0 , null , $ this -> temporaryFile ) ; } return $ this -> createProcessForFile ( $ this -> temporaryFile ) ; }
4324	public static function getBytes ( $ size ) { if ( \ is_string ( $ size ) && \ preg_match ( '/^([\d,.]+)\s?([kmgtp])b?$/i' , $ size , $ matches ) ) { $ size = \ str_replace ( ',' , '' , $ matches [ 1 ] ) ; switch ( \ strtolower ( $ matches [ 2 ] ) ) { case 'p' : $ size *= 1024 ; case 't' : $ size *= 1024 ; case 'g' : $ size *= 1024 ; case 'm' : $ size *= 1024 ; case 'k' : $ size *= 1024 ; } } $ units = array ( 'B' , 'kB' , 'MB' , 'GB' , 'TB' , 'PB' ) ; $ pow = \ pow ( 1024 , ( $ i = \ floor ( \ log ( $ size , 1024 ) ) ) ) ; $ size = $ pow == 0 ? '0 B' : \ round ( $ size / $ pow , 2 ) . ' ' . $ units [ $ i ] ; return $ size ; }
4079	protected function buildInputScreen ( $ metaModel ) { $ metaModelName = $ this -> getMetaModelName ( $ metaModel ) ; $ inputScreen = $ this -> information [ $ metaModelName ] [ self :: INPUTSCREEN ] ; if ( ! is_object ( $ inputScreen ) ) { $ inputScreen = $ this -> information [ $ metaModelName ] [ self :: INPUTSCREEN ] = new InputScreen ( $ this -> container , $ inputScreen [ 'row' ] , $ inputScreen [ 'properties' ] , $ inputScreen [ 'conditions' ] , $ inputScreen [ 'groupSort' ] ) ; } return $ inputScreen ; }
9627	protected function matchParams ( Route $ route , array $ params ) : bool { $ matchers = $ route -> getMatchers ( ) ; foreach ( $ params as $ name => $ value ) { if ( ! isset ( $ matchers [ $ name ] ) ) { continue ; } $ valueMatchers = $ matchers [ $ name ] ; foreach ( $ valueMatchers as $ matcher ) { if ( ! $ matcher ( $ value ) ) { $ this -> logger -> debug ( sprintf ( 'Value "%s" for param "%s" did not match criteria of matcher "%s"' , $ value , $ name , get_class ( $ matcher ) ) ) ; return false ; } } } return true ; }
3175	private function getItemLabel ( RunnerServiceContext $ context , $ itemUri , $ useTitle = false ) { $ label = '' ; if ( $ useTitle ) { $ label = $ context -> getItemIndexValue ( $ itemUri , 'title' ) ; } if ( ! $ label ) { $ label = $ context -> getItemIndexValue ( $ itemUri , 'label' ) ; } if ( ! $ label ) { $ item = new \ core_kernel_classes_Resource ( $ itemUri ) ; $ label = $ item -> getLabel ( ) ; } return $ label ; }
4343	protected function popStack ( ) { $ stackInfo = \ array_pop ( $ this -> funcStack ) ; $ funcPopped = $ stackInfo [ 'function' ] ; $ timeElapsed = \ microtime ( true ) - $ stackInfo [ 'tsStart' ] ; $ this -> data [ $ funcPopped ] [ 'ownTime' ] += $ timeElapsed - $ stackInfo [ 'subTime' ] ; $ this -> data [ $ funcPopped ] [ 'totalTime' ] += $ timeElapsed ; if ( $ this -> data [ $ funcPopped ] [ 'calls' ] === 0 ) { $ this -> data [ $ funcPopped ] [ 'calls' ] ++ ; } if ( $ this -> funcStack ) { $ this -> funcStack [ \ count ( $ this -> funcStack ) - 1 ] [ 'subTime' ] += $ timeElapsed ; } return $ stackInfo [ 'function' ] ; }
7576	protected function configureData ( $ data ) { if ( is_string ( $ data ) ) { if ( ! empty ( $ this -> Options ) ) { $ fileField = end ( $ this -> Options ) ; $ data = array ( $ fileField => $ data ) ; } else { throw new RequiredOptionsException ( get_called_class ( ) , "Options are required, when passing String for data." ) ; } } if ( is_array ( $ data ) ) { foreach ( $ data as $ key => $ value ) { if ( ! array_key_exists ( $ key , $ this -> _REQUIRED_DATA ) ) { $ data [ $ key ] = $ this -> setFileFieldValue ( $ value ) ; } } } parent :: configureData ( $ data ) ; }
2120	public function getFromFile ( ) { $ return = array ( ) ; $ files = System :: getContainer ( ) -> get ( 'contao.resource_finder' ) -> findIn ( 'config' ) -> depth ( 0 ) -> files ( ) -> name ( 'database.sql' ) ; foreach ( $ files as $ file ) { $ return = array_replace_recursive ( $ return , SqlFileParser :: parse ( $ file ) ) ; } ksort ( $ return ) ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'sqlGetFromFile' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'sqlGetFromFile' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'sqlGetFromFile' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ return = $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ return ) ; } } return $ return ; }
4129	public function createQuery ( $ designDocName , $ viewName ) { $ designDoc = $ this -> config -> getDesignDocument ( $ designDocName ) ; if ( $ designDoc ) { $ designDoc = new $ designDoc [ 'className' ] ( $ designDoc [ 'options' ] ) ; } $ query = new ODMQuery ( $ this -> couchDBClient -> getHttpClient ( ) , $ this -> couchDBClient -> getDatabase ( ) , $ designDocName , $ viewName , $ designDoc ) ; $ query -> setDocumentManager ( $ this ) ; return $ query ; }
9591	public function radioListWithGap ( $ items , $ options = [ ] ) { $ this -> addListInputCssClass ( $ options , $ this -> radioGapCssClass ) ; return self :: radioList ( $ items , $ options ) ; }
3346	public function request ( $ method , $ path , $ data = array ( ) , $ headers = array ( ) ) { $ ch = curl_init ( sprintf ( 'https://%s%s' , $ this -> api_host , $ path ) ) ; $ this -> __setRequestType ( $ ch , $ method ) ; $ this -> __setHeaders ( $ ch , $ headers , $ data ) ; $ response = curl_exec ( $ ch ) ; if ( $ response === false ) { throw new \ Exception ( curl_error ( $ ch ) ) ; } $ ch_info = curl_getinfo ( $ ch ) ; $ header_size = curl_getinfo ( $ ch , CURLINFO_HEADER_SIZE ) ; $ header = substr ( $ response , 0 , $ header_size ) ; $ body = substr ( $ response , $ header_size ) ; $ error = false ; if ( $ method == 'DELETE' ) { if ( $ ch_info [ 'http_code' ] != 302 && $ ch_info [ 'http_code' ] != 200 ) { $ error = true ; } } else { if ( ! ( ( $ ch_info [ 'http_code' ] >= 200 ) && ( $ ch_info [ 'http_code' ] < 300 ) ) ) { $ error = true ; } } if ( $ ch_info [ 'http_code' ] == 429 ) { $ exception = new ThrottledRequestException ( ) ; $ response_headers = Helper :: parseHttpHeaders ( $ header ) ; $ exception -> setResponseHeaders ( $ response_headers ) ; throw $ exception ; } if ( $ error ) { $ errorInfo = array_filter ( array ( curl_error ( $ ch ) , $ body ) ) ; throw new \ Exception ( 'Request returned unexpected http code ' . $ ch_info [ 'http_code' ] . '. ' . join ( ', ' , $ errorInfo ) ) ; } curl_close ( $ ch ) ; if ( ! defined ( 'PHPUNIT_UPLOADCARE_TESTSUITE' ) && ( $ this -> public_key == 'demopublic_key' || $ this -> secret_key == 'demoprivatekey' ) ) { trigger_error ( 'You are using the demo account. Please get an Uploadcare account at https://uploadcare.com/accounts/create/' , E_USER_WARNING ) ; } return json_decode ( $ body ) ; }
7868	private function replaceUtf8 ( & $ original , $ replacement , $ position ) { $ start = mb_substr ( $ original , 0 , $ position , "UTF-8" ) ; $ end = mb_substr ( $ original , $ position + 1 , mb_strlen ( $ original , 'UTF-8' ) , "UTF-8" ) ; $ original = $ start . $ replacement . $ end ; }
927	private function getCommentBlock ( Tokens $ tokens , $ index ) { $ commentType = $ this -> getCommentType ( $ tokens [ $ index ] -> getContent ( ) ) ; $ empty = $ this -> isEmptyComment ( $ tokens [ $ index ] -> getContent ( ) ) ; $ start = $ index ; $ count = \ count ( $ tokens ) ; ++ $ index ; for ( ; $ index < $ count ; ++ $ index ) { if ( $ tokens [ $ index ] -> isComment ( ) ) { if ( $ commentType !== $ this -> getCommentType ( $ tokens [ $ index ] -> getContent ( ) ) ) { break ; } if ( $ empty ) { $ empty = $ this -> isEmptyComment ( $ tokens [ $ index ] -> getContent ( ) ) ; } continue ; } if ( ! $ tokens [ $ index ] -> isWhitespace ( ) || $ this -> getLineBreakCount ( $ tokens , $ index , $ index + 1 ) > 1 ) { break ; } } return [ $ start , $ index - 1 , $ empty ] ; }
8083	public function & getFormErrors ( $ channel = '' ) { $ channel = $ this -> namespaceChannel ( $ channel ) ; if ( ! isset ( $ this -> console [ 'form' ] [ $ channel ] ) ) { $ this -> console [ 'form' ] [ $ channel ] = array ( ) ; } return $ this -> console [ 'form' ] [ $ channel ] ; }
8373	protected function configure ( ) { $ this -> setName ( 'worker/process' ) -> setHidden ( true ) -> setDescription ( 'Runs a given worker' ) -> setDefinition ( new InputDefinition ( [ new InputOption ( 'config' , 'c' , InputOption :: VALUE_REQUIRED , 'A YAML configuration file' ) , new InputOption ( 'jobId' , null , InputOption :: VALUE_REQUIRED , 'A Job UUID' ) , new InputOption ( 'name' , null , InputOption :: VALUE_REQUIRED , 'The queue name to work with. Defaults to `default`.' ) , ] ) ) ; }
9667	private function writeGradientFill ( XMLWriter $ objWriter , Fill $ pFill ) { $ objWriter -> startElement ( 'fill' ) ; $ objWriter -> startElement ( 'gradientFill' ) ; $ objWriter -> writeAttribute ( 'type' , $ pFill -> getFillType ( ) ) ; $ objWriter -> writeAttribute ( 'degree' , $ pFill -> getRotation ( ) ) ; $ objWriter -> startElement ( 'stop' ) ; $ objWriter -> writeAttribute ( 'position' , '0' ) ; $ objWriter -> startElement ( 'color' ) ; $ objWriter -> writeAttribute ( 'rgb' , $ pFill -> getStartColor ( ) -> getARGB ( ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'stop' ) ; $ objWriter -> writeAttribute ( 'position' , '1' ) ; $ objWriter -> startElement ( 'color' ) ; $ objWriter -> writeAttribute ( 'rgb' , $ pFill -> getEndColor ( ) -> getARGB ( ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; }
9950	public function duplicateStyle ( Style $ pCellStyle , $ pRange ) { $ workbook = $ this -> parent ; if ( $ existingStyle = $ this -> parent -> getCellXfByHashCode ( $ pCellStyle -> getHashCode ( ) ) ) { $ xfIndex = $ existingStyle -> getIndex ( ) ; } else { $ workbook -> addCellXf ( $ pCellStyle ) ; $ xfIndex = $ pCellStyle -> getIndex ( ) ; } list ( $ rangeStart , $ rangeEnd ) = Coordinate :: rangeBoundaries ( $ pRange . ':' . $ pRange ) ; if ( $ rangeStart [ 0 ] > $ rangeEnd [ 0 ] && $ rangeStart [ 1 ] > $ rangeEnd [ 1 ] ) { $ tmp = $ rangeStart ; $ rangeStart = $ rangeEnd ; $ rangeEnd = $ tmp ; } for ( $ col = $ rangeStart [ 0 ] ; $ col <= $ rangeEnd [ 0 ] ; ++ $ col ) { for ( $ row = $ rangeStart [ 1 ] ; $ row <= $ rangeEnd [ 1 ] ; ++ $ row ) { $ this -> getCell ( Coordinate :: stringFromColumnIndex ( $ col ) . $ row ) -> setXfIndex ( $ xfIndex ) ; } } return $ this ; }
1983	public static function hasMessages ( $ strScope = TL_MODE ) { return static :: hasError ( $ strScope ) || static :: hasConfirmation ( $ strScope ) || static :: hasNew ( $ strScope ) || static :: hasInfo ( $ strScope ) || static :: hasRaw ( $ strScope ) ; }
11962	private function parseConfig ( $ connection ) { $ this -> debug = false ; $ allowed_keys = array_keys ( get_object_vars ( $ this ) ) ; foreach ( $ connection as $ key => $ value ) { if ( $ key === 'host' && substr ( $ value , - 1 ) === '/' ) { $ value = substr ( $ value , 0 , - 1 ) ; } $ this -> setParam ( $ this -> camelCase ( $ key ) , $ value , $ allowed_keys ) ; } $ this -> transactionId = null ; $ this -> query = null ; }
12309	public function resetPasswordAction ( ) { if ( $ this -> cmsAuthentication ( ) -> hasIdentity ( ) ) { return $ this -> redirect ( ) -> toRoute ( $ this -> getOptions ( ) -> getDefaultUserRoute ( ) ) ; } if ( $ token = $ this -> params ( ) -> fromRoute ( 'token' ) ) { $ identity = $ this -> getUserService ( ) -> confirmPasswordReset ( $ token ) ; if ( $ identity instanceof ResponseInterface ) { return $ identity ; } elseif ( $ identity ) { $ viewModel = new ViewModel ( compact ( 'identity' ) ) ; $ viewModel -> setTemplate ( 'cms-user/authentication/reset-password-success' ) ; return $ viewModel ; } return $ this -> redirect ( ) -> toRoute ( ) ; } $ url = $ this -> url ( ) -> fromRoute ( ) ; $ prg = $ this -> prg ( $ url , true ) ; if ( $ prg instanceof ResponseInterface ) { return $ prg ; } $ post = $ prg ; $ form = $ this -> getUserService ( ) -> getResetPasswordForm ( ) ; $ form -> setAttribute ( 'action' , $ url ) ; if ( $ post && $ form -> setData ( $ post ) -> isValid ( ) ) { $ identity = $ this -> getUserService ( ) -> resetPassword ( $ form -> get ( 'identity' ) -> getValue ( ) ) ; if ( $ identity instanceof ResponseInterface ) { return $ identity ; } elseif ( $ identity ) { $ viewModel = new ViewModel ( compact ( 'identity' ) ) ; $ viewModel -> setTemplate ( 'cms-user/authentication/reset-password-warning' ) ; return $ viewModel ; } } return new ViewModel ( compact ( 'form' ) ) ; }
5635	public function paintException ( $ exception ) { parent :: paintException ( $ exception ) ; print '<span class="fail">Exception</span>: ' ; $ breadcrumb = $ this -> getTestList ( ) ; array_shift ( $ breadcrumb ) ; print implode ( ' -&gt; ' , $ breadcrumb ) ; $ message = 'Unexpected exception of type [' . get_class ( $ exception ) . '] with message [' . $ exception -> getMessage ( ) . '] in [' . $ exception -> getFile ( ) . ' line ' . $ exception -> getLine ( ) . ']' ; print ' -&gt; <strong>' . $ this -> htmlEntities ( $ message ) . "</strong><br />\n" ; }
5235	public function withEntryFromProvider ( $ key , $ provider ) { $ this -> bindings [ $ key ] = $ this -> getProviderCreator ( $ provider ) ; return $ this ; }
8825	protected function valid_cc ( $ data ) { $ number = preg_replace ( '/\D/' , '' , $ data ) ; if ( function_exists ( 'mb_strlen' ) ) { $ number_length = mb_strlen ( $ number ) ; } else { $ number_length = strlen ( $ number ) ; } $ parity = $ number_length % 2 ; $ total = 0 ; for ( $ i = 0 ; $ i < $ number_length ; $ i ++ ) { $ digit = $ number [ $ i ] ; if ( $ i % 2 == $ parity ) { $ digit *= 2 ; if ( $ digit > 9 ) { $ digit -= 9 ; } } $ total += $ digit ; } return ( $ total % 10 == 0 ) ? true : false ; }
4155	protected function buildRequestHeader ( ) { $ bearerToken = $ this -> bearerToken ; if ( $ this -> bearerToken === null ) { $ bearerToken = $ this -> getBearerToken ( ) ; } return array ( 'Authorization: Bearer ' . rawurlencode ( $ bearerToken ) , 'Expect:' ) ; }
958	public function remainingTrialDaysFromCancel ( ) { if ( ! $ this -> isTrial ( ) ) { return ; } $ cancelledDate = Carbon :: parse ( $ this -> cancelled_on ) ; $ trialEndsDate = Carbon :: parse ( $ this -> trial_ends_on ) ; if ( $ this -> isCancelled ( ) && $ cancelledDate -> lte ( $ trialEndsDate ) ) { return $ this -> trial_days - ( $ this -> trial_days - $ cancelledDate -> diffInDays ( $ trialEndsDate ) ) ; } return 0 ; }
9637	public function handle ( GetResponseEvent $ event ) { $ apiKey = $ this -> getApiKeyFromQueryOrHeader ( $ event -> getRequest ( ) ) ; if ( false === $ apiKey ) { return ; } try { $ token = $ this -> authenticationManager -> authenticate ( new ApiKeyToken ( $ apiKey ) ) ; $ this -> tokenStorage -> setToken ( $ token ) ; } catch ( AuthenticationException $ failed ) { $ this -> tokenStorage -> setToken ( null ) ; $ this -> doFailureResponse ( $ event ) ; } }
10688	private function configureAutoloaderAndResolver ( ) { if ( $ this -> autoloader !== null ) return ; $ cache = $ this -> cachemanager -> getCache ( "resolution" ) ; $ this -> autoloader = new Autoloader ( ) ; $ this -> autoloader -> setCache ( $ cache ) ; $ this -> injector -> setInstance ( Autoloader :: class , $ this -> autoloader ) ; $ this -> resolver = new Resolver ( $ cache ) ; $ this -> resolver -> addResolverType ( 'template' , 'template' , '.php' ) -> addResolverType ( 'assets' , 'assets' ) -> addResolverType ( 'app' , 'app' ) -> addResolverType ( 'code' , 'src' ) -> addResolverType ( 'language' , 'language' ) -> addResolverType ( 'migrations' , 'migrations' ) -> setResolver ( "app" , new Router ( "router" ) ) ; $ this -> injector -> setInstance ( Resolver :: class , $ this -> resolver ) ; spl_autoload_register ( array ( $ this -> autoloader , 'autoload' ) , true , true ) ; $ cl = Autoloader :: findComposerAutoloader ( ) ; if ( ! empty ( $ cl ) ) { $ vendor_dir = Autoloader :: findComposerAutoloaderVendorDir ( $ cl ) ; $ this -> autoloader -> importComposerAutoloaderConfiguration ( $ vendor_dir ) ; $ this -> resolver -> autoConfigureFromComposer ( $ vendor_dir ) ; } else { $ my_dir = __DIR__ ; $ wedeto_dir = dirname ( dirname ( $ my_dir ) ) ; $ this -> autoloader -> registerNS ( "Wedeto\\" , $ wedeto_dir , Autoloader :: PSR4 ) ; $ modules = $ this -> resolver -> findModules ( $ wedeto_dir , '/modules' , "" , 0 ) ; foreach ( $ modules as $ name => $ path ) $ this -> resolver -> registerModule ( $ name , $ path ) ; } }
4201	private function addMethodsMin ( Event $ abs ) { $ obj = $ abs -> getSubject ( ) ; if ( \ method_exists ( $ obj , '__toString' ) ) { $ abs [ 'methods' ] [ '__toString' ] = array ( 'returnValue' => \ call_user_func ( array ( $ obj , '__toString' ) ) , 'visibility' => 'public' , ) ; } if ( \ method_exists ( $ obj , '__get' ) ) { $ abs [ 'methods' ] [ '__get' ] = array ( 'visibility' => 'public' ) ; } if ( \ method_exists ( $ obj , '__set' ) ) { $ abs [ 'methods' ] [ '__set' ] = array ( 'visibility' => 'public' ) ; } return ; }
3545	protected function write ( $ file , $ file_path ) { if ( ! is_dir ( dirname ( $ file_path ) ) ) { mkdir ( dirname ( $ file_path ) , 0755 , true ) ; } file_put_contents ( $ file_path , file_get_contents ( dirname ( __FILE__ ) . DIRECTORY_SEPARATOR . '..' . DIRECTORY_SEPARATOR . '..' . DIRECTORY_SEPARATOR . '..' . DIRECTORY_SEPARATOR . 'templates' . DIRECTORY_SEPARATOR . $ file . '.txt' ) ) ; }
12367	protected function getOption ( $ name ) { if ( ! isset ( $ this -> options [ $ name ] ) ) { throw new ValueNotFoundException ( $ name ) ; } return $ this -> options [ $ name ] ; }
4191	protected function dumpMethodParams ( $ params ) { $ paramStr = '' ; foreach ( $ params as $ info ) { $ paramStr .= '<span class="parameter">' ; if ( ! empty ( $ info [ 'type' ] ) ) { $ paramStr .= '<span class="t_type">' . $ info [ 'type' ] . '</span> ' ; } $ paramStr .= '<span class="t_parameter-name"' . ' title="' . \ htmlspecialchars ( $ info [ 'desc' ] ) . '"' . '>' . \ htmlspecialchars ( $ info [ 'name' ] ) . '</span>' ; if ( $ info [ 'defaultValue' ] !== $ this -> debug -> abstracter -> UNDEFINED ) { $ defaultValue = $ info [ 'defaultValue' ] ; $ paramStr .= ' <span class="t_operator">=</span> ' ; if ( $ info [ 'constantName' ] ) { $ title = '' ; $ type = $ this -> debug -> abstracter -> getType ( $ defaultValue ) ; if ( ! \ in_array ( $ type , array ( 'array' , 'resource' ) ) ) { $ title = $ this -> debug -> output -> text -> dump ( $ defaultValue ) ; $ title = \ htmlspecialchars ( 'value: ' . $ title ) ; } $ paramStr .= '<span class="t_parameter-default t_const"' . ' title="' . $ title . '"' . '>' . $ info [ 'constantName' ] . '</span>' ; } else { if ( \ is_string ( $ defaultValue ) ) { $ defaultValue = \ str_replace ( "\n" , ' ' , $ defaultValue ) ; } $ parsed = $ this -> debug -> utilities -> parseTag ( $ this -> debug -> output -> html -> dump ( $ defaultValue ) ) ; $ class = \ trim ( 't_parameter-default ' . $ parsed [ 'attribs' ] [ 'class' ] ) ; $ paramStr .= '<span class="' . $ class . '">' . $ parsed [ 'innerhtml' ] . '</span>' ; } } $ paramStr .= '</span>, ' ; } $ paramStr = \ trim ( $ paramStr , ', ' ) ; return $ paramStr ; }
7757	public function processData ( $ data = array ( ) ) { if ( is_array ( $ data ) && 0 === count ( $ data ) ) { $ data = new \ stdClass ( ) ; } if ( ! is_string ( $ data ) ) { $ options = 0 ; if ( PHP_VERSION_ID >= 50400 ) { $ options |= JSON_UNESCAPED_SLASHES | JSON_UNESCAPED_UNICODE ; if ( self :: $ pretty ) { $ options |= JSON_PRETTY_PRINT ; } $ data = json_encode ( $ data , $ options ) ; } else { $ data = json_encode ( $ data ) ; $ data = str_replace ( '\\/' , '/' , $ data ) ; $ data = preg_replace_callback ( '/\\\\u([a-f0-9]{4})/' , function ( $ match ) { return iconv ( 'UCS-4LE' , 'UTF-8' , pack ( 'V' , hexdec ( $ match [ 1 ] ) ) ) ; } , $ data ) ; } } return $ this -> setContent ( $ data ) ; }
2174	private function setUpDatabaseConnection ( ) : Response { $ request = $ this -> container -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; if ( null === $ request ) { throw new \ RuntimeException ( 'The request stack did not contain a request' ) ; } if ( false !== getenv ( 'DATABASE_URL' ) ) { return $ this -> render ( 'misconfigured_database_url.html.twig' ) ; } $ parameters = [ 'parameters' => [ 'database_host' => $ this -> getContainerParameter ( 'database_host' ) , 'database_port' => $ this -> getContainerParameter ( 'database_port' ) , 'database_user' => $ this -> getContainerParameter ( 'database_user' ) , 'database_password' => $ this -> getContainerParameter ( 'database_password' ) , 'database_name' => $ this -> getContainerParameter ( 'database_name' ) , ] , ] ; if ( 'tl_database_login' !== $ request -> request -> get ( 'FORM_SUBMIT' ) ) { return $ this -> render ( 'database.html.twig' , $ parameters ) ; } $ parameters = [ 'parameters' => [ 'database_host' => $ request -> request -> get ( 'dbHost' ) , 'database_port' => $ request -> request -> get ( 'dbPort' ) , 'database_user' => $ request -> request -> get ( 'dbUser' ) , 'database_password' => $ this -> getContainerParameter ( 'database_password' ) , 'database_name' => $ request -> request -> get ( 'dbName' ) , ] , ] ; if ( '*****' !== $ request -> request -> get ( 'dbPassword' ) ) { $ parameters [ 'parameters' ] [ 'database_password' ] = $ request -> request -> get ( 'dbPassword' ) ; } if ( false !== strpos ( $ parameters [ 'parameters' ] [ 'database_name' ] , '.' ) ) { return $ this -> render ( 'database.html.twig' , array_merge ( $ parameters , [ 'database_error' => $ this -> trans ( 'database_dot_in_dbname' ) ] ) ) ; } $ installTool = $ this -> container -> get ( 'contao.install_tool' ) ; $ installTool -> setConnection ( ConnectionFactory :: create ( $ parameters ) ) ; if ( ! $ installTool -> canConnectToDatabase ( $ parameters [ 'parameters' ] [ 'database_name' ] ) ) { return $ this -> render ( 'database.html.twig' , array_merge ( $ parameters , [ 'database_error' => $ this -> trans ( 'database_could_not_connect' ) ] ) ) ; } $ dumper = new ParameterDumper ( $ this -> getContainerParameter ( 'kernel.project_dir' ) ) ; $ dumper -> setParameters ( $ parameters ) ; $ dumper -> dump ( ) ; $ this -> purgeSymfonyCache ( ) ; return $ this -> getRedirectResponse ( ) ; }
3212	static function loadFromJsonFileWithRaw ( $ path ) { if ( ! file_exists ( $ path ) ) { throw new AppInfoLoadException ( "File doesn't exist: \"$path\"" ) ; } $ str = Util :: stripUtf8Bom ( file_get_contents ( $ path ) ) ; $ jsonArr = json_decode ( $ str , true , 10 ) ; if ( is_null ( $ jsonArr ) ) { throw new AppInfoLoadException ( "JSON parse error: \"$path\"" ) ; } $ appInfo = self :: loadFromJson ( $ jsonArr ) ; return array ( $ jsonArr , $ appInfo ) ; }
12973	public function setMappings ( $ mappingName , array $ mappingConfig = null ) { if ( is_array ( $ mappingName ) === false ) { $ mappingName = array ( $ mappingName => $ mappingConfig ) ; } \ Arr :: set ( $ this -> config [ 'mappings' ] , $ mappingName ) ; return $ this ; }
5168	private function convertNonAscii ( string $ string ) : string { $ search = $ replace = [ ] ; $ search [ ] = chr ( 226 ) . chr ( 128 ) . chr ( 152 ) ; $ replace [ ] = "'" ; $ search [ ] = chr ( 226 ) . chr ( 128 ) . chr ( 153 ) ; $ replace [ ] = "'" ; $ search [ ] = chr ( 226 ) . chr ( 128 ) . chr ( 156 ) ; $ replace [ ] = '"' ; $ search [ ] = chr ( 226 ) . chr ( 128 ) . chr ( 157 ) ; $ replace [ ] = '"' ; $ search [ ] = chr ( 226 ) . chr ( 128 ) . chr ( 147 ) ; $ replace [ ] = '--' ; $ search [ ] = chr ( 226 ) . chr ( 128 ) . chr ( 148 ) ; $ replace [ ] = '---' ; $ search [ ] = chr ( 226 ) . chr ( 128 ) . chr ( 162 ) ; $ replace [ ] = '*' ; $ search [ ] = chr ( 194 ) . chr ( 183 ) ; $ replace [ ] = '*' ; $ search [ ] = chr ( 226 ) . chr ( 128 ) . chr ( 166 ) ; $ replace [ ] = '...' ; $ string = str_replace ( $ search , $ replace , $ string ) ; return preg_replace ( "/[^\x01-\x7F]/" , '' , $ string ) ; }
4286	public function processLogEntry ( $ method , $ args = array ( ) , $ meta = array ( ) ) { if ( $ method === 'alert' ) { list ( $ method , $ args ) = $ this -> methodAlert ( $ args , $ meta ) ; } elseif ( $ method == 'assert' ) { \ array_unshift ( $ args , false ) ; } elseif ( \ in_array ( $ method , array ( 'count' , 'time' ) ) ) { $ method = 'log' ; } elseif ( \ in_array ( $ method , array ( 'profileEnd' , 'table' ) ) ) { $ method = 'log' ; if ( \ is_array ( $ args [ 0 ] ) ) { $ method = 'table' ; $ args = array ( $ this -> methodTable ( $ args [ 0 ] , $ meta [ 'columns' ] ) ) ; } elseif ( $ meta [ 'caption' ] ) { \ array_unshift ( $ args , $ meta [ 'caption' ] ) ; } } elseif ( $ method === 'trace' ) { $ method = 'table' ; $ args = array ( $ this -> methodTable ( $ args [ 0 ] , array ( 'function' , 'file' , 'line' ) ) ) ; } if ( ! \ in_array ( $ method , $ this -> consoleMethods ) ) { $ method = 'log' ; } foreach ( $ args as $ i => $ arg ) { $ args [ $ i ] = $ this -> dump ( $ arg ) ; } $ this -> json [ 'rows' ] [ ] = array ( $ args , isset ( $ meta [ 'file' ] ) ? $ meta [ 'file' ] . ': ' . $ meta [ 'line' ] : null , $ method === 'log' ? '' : $ method , ) ; }
7500	public function requestJson ( $ method , $ url , $ options = array ( ) ) { $ options [ 'headers' ] [ ] = 'Content-Type: application/json' ; $ options [ 'headers' ] [ ] = 'Content-Length: ' . strlen ( $ options [ 'body' ] ) ; $ this -> request ( $ method , $ url , $ options ) ; }
3851	public function setLimit ( $ blnUse , $ intOffset , $ intLimit ) { $ this -> paginationLimitCalculator -> setApplyLimitAndOffset ( $ blnUse ) -> setOffset ( $ intOffset ) -> setLimit ( $ intLimit ) ; return $ this ; }
9505	public function index ( ) { $ this -> authorize ( LogViewerPolicy :: PERMISSION_DASHBOARD ) ; $ stats = $ this -> logViewer -> statsTable ( ) ; $ percents = $ this -> calcPercentages ( $ stats -> footer ( ) , $ stats -> header ( ) ) ; $ this -> setTitle ( 'LogViewer Dashboard' ) ; $ this -> addBreadcrumb ( 'Dashboard' ) ; return $ this -> view ( 'admin.system.log-viewer.dashboard' , compact ( 'percents' ) ) ; }
1910	protected function createTemplate ( Model $ model , string $ templateName ) : Template { if ( isset ( $ this -> options [ 'template' ] ) ) { $ templateName = $ this -> options [ 'template' ] ; } if ( $ model -> customTpl ) { $ templateName = $ model -> customTpl ; } $ template = $ this -> get ( 'contao.framework' ) -> createInstance ( FrontendTemplate :: class , [ $ templateName ] ) ; $ template -> setData ( $ model -> row ( ) ) ; return $ template ; }
4394	public function capture ( \ Aimeos \ MShop \ Order \ Item \ Iface $ order ) { $ provider = $ this -> getProvider ( ) ; if ( ! $ provider -> supportsCapture ( ) ) { return ; } $ base = $ this -> getOrderBase ( $ order -> getBaseId ( ) ) ; $ data = array ( 'transactionReference' => $ this -> getTransactionReference ( $ base ) , 'currency' => $ base -> getPrice ( ) -> getCurrencyId ( ) , 'amount' => $ this -> getAmount ( $ base -> getPrice ( ) ) , 'transactionId' => $ order -> getId ( ) , ) ; $ response = $ provider -> capture ( $ data ) -> send ( ) ; if ( $ response -> isSuccessful ( ) ) { $ status = \ Aimeos \ MShop \ Order \ Item \ Base :: PAY_RECEIVED ; $ order -> setPaymentStatus ( $ status ) ; } }
4525	protected function createZoneMemberCountryFromDefinition ( array $ definition ) { $ zoneMember = new ZoneMemberCountry ( ) ; $ setValues = \ Closure :: bind ( function ( $ definition ) { $ this -> id = $ definition [ 'id' ] ; $ this -> name = $ definition [ 'name' ] ; $ this -> countryCode = $ definition [ 'country_code' ] ; if ( isset ( $ definition [ 'administrative_area' ] ) ) { $ this -> administrativeArea = $ definition [ 'administrative_area' ] ; } if ( isset ( $ definition [ 'locality' ] ) ) { $ this -> locality = $ definition [ 'locality' ] ; } if ( isset ( $ definition [ 'dependent_locality' ] ) ) { $ this -> dependentLocality = $ definition [ 'dependent_locality' ] ; } if ( isset ( $ definition [ 'included_postal_codes' ] ) ) { $ this -> includedPostalCodes = $ definition [ 'included_postal_codes' ] ; } if ( isset ( $ definition [ 'excluded_postal_codes' ] ) ) { $ this -> excludedPostalCodes = $ definition [ 'excluded_postal_codes' ] ; } } , $ zoneMember , '\CommerceGuys\Zone\Model\ZoneMemberCountry' ) ; $ setValues ( $ definition ) ; return $ zoneMember ; }
2067	public function getPageLayouts ( ) { $ objLayout = $ this -> Database -> execute ( "SELECT l.id, l.name, t.name AS theme FROM tl_layout l LEFT JOIN tl_theme t ON l.pid=t.id ORDER BY t.name, l.name" ) ; if ( $ objLayout -> numRows < 1 ) { return array ( ) ; } $ return = array ( ) ; while ( $ objLayout -> next ( ) ) { $ return [ $ objLayout -> theme ] [ $ objLayout -> id ] = $ objLayout -> name ; } return $ return ; }
4373	protected function buildArgString ( $ args , $ sanitize = true ) { $ glue = ', ' ; $ glueAfterFirst = true ; if ( \ is_string ( $ args [ 0 ] ) ) { if ( \ preg_match ( '/[=:] ?$/' , $ args [ 0 ] ) ) { $ glueAfterFirst = false ; } elseif ( \ count ( $ args ) == 2 ) { $ glue = ' = ' ; } } foreach ( $ args as $ i => $ v ) { $ args [ $ i ] = $ i > 0 ? $ this -> dump ( $ v , $ sanitize ) : $ this -> dump ( $ v , false ) ; } if ( ! $ glueAfterFirst ) { return $ args [ 0 ] . \ implode ( $ glue , \ array_slice ( $ args , 1 ) ) ; } else { return \ implode ( $ glue , $ args ) ; } }
6233	public function addChild ( $ key , $ value = null , $ namespace = null ) { if ( $ value != null ) { $ value = htmlspecialchars ( $ value , ENT_XML1 ) ; } return parent :: addChild ( $ key , $ value , $ namespace ) ; }
2734	public function afterGenerateXml ( \ Magento \ Framework \ View \ Layout $ subject , $ result ) { if ( $ subject -> isCacheable ( ) && $ this -> config -> isEnabled ( ) && $ this -> config -> getType ( ) == Config :: FASTLY && $ this -> config -> getTtl ( ) ) { $ header = $ this -> response -> getHeader ( 'cache-control' ) ; if ( ( $ header instanceof \ Zend \ Http \ Header \ HeaderInterface ) && ( $ value = $ header -> getFieldValue ( ) ) ) { if ( $ ttl = $ this -> config -> getStaleTtl ( ) ) { $ value .= ', stale-while-revalidate=' . $ ttl ; } if ( $ ttl = $ this -> config -> getStaleErrorTtl ( ) ) { $ value .= ', stale-if-error=' . $ ttl ; } $ this -> response -> setHeader ( $ header -> getFieldName ( ) , $ value , true ) ; } } if ( $ subject -> isCacheable ( ) ) { $ this -> response -> setHeader ( "fastly-page-cacheable" , "YES" ) ; } else { $ this -> response -> setHeader ( "fastly-page-cacheable" , "NO" ) ; } return $ result ; }
1947	private function setCacheHeaders ( Response $ response ) { global $ objPage ; if ( ( $ objPage -> cache === false || $ objPage -> cache < 1 ) && ( $ objPage -> clientCache === false || $ objPage -> clientCache < 1 ) ) { $ response -> headers -> addCacheControlDirective ( 'no-cache' ) ; $ response -> headers -> addCacheControlDirective ( 'no-store' ) ; return $ response -> setPrivate ( ) ; } if ( FE_USER_LOGGED_IN === true || BE_USER_LOGGED_IN === true || $ objPage -> protected || $ this -> hasAuthenticatedBackendUser ( ) ) { $ response -> headers -> addCacheControlDirective ( 'no-cache' ) ; $ response -> headers -> addCacheControlDirective ( 'no-store' ) ; return $ response -> setPrivate ( ) ; } if ( $ objPage -> clientCache > 0 ) { $ response -> setMaxAge ( $ objPage -> clientCache ) ; } if ( $ objPage -> cache > 0 ) { $ response -> setSharedMaxAge ( $ objPage -> cache ) ; } if ( System :: getContainer ( ) -> has ( 'fos_http_cache.http.symfony_response_tagger' ) ) { $ responseTagger = System :: getContainer ( ) -> get ( 'fos_http_cache.http.symfony_response_tagger' ) ; $ responseTagger -> addTags ( array ( 'contao.db.tl_page.' . $ objPage -> id ) ) ; } return $ response ; }
2714	public function getCheckedValues ( ) { if ( $ this -> values === null ) { $ data = $ this -> config -> getImageOptimizationRatios ( ) ; if ( ! isset ( $ data ) ) { $ data = '' ; } $ this -> values = explode ( ',' , $ data ) ; } return $ this -> values ; }
1901	public function validate ( ) { $ mandatory = $ this -> mandatory ; $ options = $ this -> getPost ( $ this -> strName ) ; if ( $ mandatory && \ is_array ( $ options ) ) { foreach ( $ options as $ option ) { if ( \ strlen ( $ option ) ) { $ this -> mandatory = false ; break ; } } } $ varInput = $ this -> validator ( $ options ) ; if ( ! empty ( $ varInput ) && ! $ this -> isValidOption ( $ varInput ) ) { $ this -> addError ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'invalid' ] ) ; } if ( $ this -> hasErrors ( ) ) { $ this -> class = 'error' ; } else { $ this -> varValue = $ varInput ; } if ( $ mandatory ) { $ this -> mandatory = true ; } }
7628	public function getContainerAcl ( $ containerName = '' , $ signedIdentifiers = false ) { Assertion :: notEmpty ( $ containerName , 'Container name is not specified' ) ; self :: assertValidContainerName ( $ containerName ) ; $ response = $ this -> performRequest ( $ containerName , array ( 'restype' => 'container' , 'comp' => 'acl' ) , 'GET' , array ( ) , false , null , self :: RESOURCE_CONTAINER , self :: PERMISSION_READ ) ; if ( ! $ response -> isSuccessful ( ) ) { throw new BlobException ( $ this -> getErrorMessage ( $ response , 'Resource could not be accessed.' ) ) ; } if ( $ signedIdentifiers == false ) { $ accessType = $ response -> getHeader ( Storage :: PREFIX_STORAGE_HEADER . 'blob-public-access' ) ; if ( strtolower ( $ accessType ) == 'true' ) { $ accessType = self :: ACL_PUBLIC_CONTAINER ; } return $ accessType ; } $ result = $ this -> parseResponse ( $ response ) ; if ( ! $ result ) { return array ( ) ; } $ entries = null ; if ( $ result -> SignedIdentifier ) { if ( count ( $ result -> SignedIdentifier ) > 1 ) { $ entries = $ result -> SignedIdentifier ; } else { $ entries = array ( $ result -> SignedIdentifier ) ; } } $ returnValue = array ( ) ; foreach ( $ entries as $ entry ) { $ returnValue [ ] = new SignedIdentifier ( $ entry -> Id , $ entry -> AccessPolicy ? $ entry -> AccessPolicy -> Start ? $ entry -> AccessPolicy -> Start : '' : '' , $ entry -> AccessPolicy ? $ entry -> AccessPolicy -> Expiry ? $ entry -> AccessPolicy -> Expiry : '' : '' , $ entry -> AccessPolicy ? $ entry -> AccessPolicy -> Permission ? $ entry -> AccessPolicy -> Permission : '' : '' ) ; } return $ returnValue ; }
4601	public function kernelRequest ( GetResponseEvent $ event ) { $ request = $ event -> getRequest ( ) ; if ( ! $ request -> isMethod ( Request :: METHOD_PUT ) ) { return ; } if ( ! $ request -> attributes -> has ( 'data' ) ) { return ; } $ data = $ request -> attributes -> get ( 'data' ) ; if ( ! $ data instanceof Access ) { return ; } $ access = $ data ; $ manager = $ this -> accessService -> getManager ( ) ; foreach ( $ access -> getPermissions ( ) as $ permission ) { $ manager -> remove ( $ permission ) ; } $ manager -> flush ( ) ; }
632	public function update ( $ table , $ columns , $ condition = '' , $ params = [ ] ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> update ( $ table , $ columns , $ condition , $ params ) ; return $ this -> setSql ( $ sql ) -> bindValues ( $ params ) ; }
4444	public function failedForGroup ( $ group , int $ start = 0 , int $ limit = 25 ) : array { $ results = json_decode ( $ this -> client -> failed ( $ group , $ start , $ limit ) , true ) ; if ( isset ( $ results [ 'jobs' ] ) && ! empty ( $ results [ 'jobs' ] ) ) { $ results [ 'jobs' ] = $ this -> multiget ( $ results [ 'jobs' ] ) ; } return is_array ( $ results ) ? $ results : [ ] ; }
9362	public function argument ( ) { if ( $ this -> original ) { return $ this -> original -> theta ; } return atan2 ( $ this -> float_i , $ this -> float_r ) ; }
11778	public function startAction ( Request $ request , Application $ app ) { $ options = array ( "request" => $ request , "configuration_handler" => $ app [ "red_kite_cms.configuration_handler" ] , ) ; return parent :: start ( $ options ) ; }
11713	private function getCalcData ( ) { $ req = new AGetPeriodRequest ( ) ; $ req -> setBaseCalcTypeCode ( Cfg :: CODE_TYPE_CALC_PV_WRITE_OFF ) ; $ req -> setDepCalcTypeCode ( Cfg :: CODE_TYPE_CALC_UNQUALIFIED_PROCESS ) ; $ resp = $ this -> servPeriodGet -> exec ( $ req ) ; $ writeOffCalc = $ resp -> getBaseCalcData ( ) ; $ processCalc = $ resp -> getDepCalcData ( ) ; $ result = [ $ writeOffCalc , $ processCalc ] ; return $ result ; }
8995	protected function addActions ( SymfonyController $ controller , Resource $ resource , $ chainName = '' ) { $ actions = array ( ) ; $ chainName = $ chainName . '_' . strtolower ( str_replace ( array ( '{' , '}' ) , '' , $ resource -> getDisplayName ( ) ) ) ; foreach ( $ resource -> getMethods ( ) as $ method ) { $ actionName = strtolower ( $ method -> getType ( ) ) . str_replace ( ' ' , '' , ucwords ( str_replace ( '_' , ' ' , $ chainName ) ) ) . 'Action' ; $ route = new SymfonyRoute ( $ resource -> getUri ( ) , strtolower ( $ method -> getType ( ) . $ chainName ) ) ; $ action = new SymfonyAction ( $ actionName , $ route , $ method -> getType ( ) , $ method -> getDescription ( ) ) ; preg_match_all ( '/\{[a-zA-Z]+\}/' , $ resource -> getUri ( ) , $ parameters ) ; foreach ( $ parameters [ 0 ] as $ parameter ) { $ action -> addParameter ( substr ( $ parameter , 1 , strlen ( $ parameter ) - 2 ) ) ; } if ( $ method -> getResponses ( ) ) { foreach ( $ method -> getResponses ( ) as $ code => $ response ) { $ headers = array ( ) ; foreach ( $ response -> getHeaders ( ) as $ key => $ value ) { if ( isset ( $ value [ 'required' ] ) && $ value [ 'required' ] ) { $ headers [ $ key ] = isset ( $ value [ 'example' ] ) ? $ value [ 'example' ] : '' ; } } $ _response = new SymfonyResponse ( $ code , $ headers ) ; foreach ( $ this -> config [ 'allowed_response_types' ] as $ allowedResponsetype ) { if ( null !== $ example = $ response -> getExampleByType ( $ allowedResponsetype ) ) { $ _response -> addContent ( new SymfonyResponseContent ( $ allowedResponsetype , str_replace ( array ( "\r\n" , "\n" , "\r" , "\t" , " " ) , '' , $ example ) ) ) ; } } $ action -> addResponse ( $ _response ) ; } } $ controller -> addAction ( $ action ) ; } foreach ( $ resource -> getResources ( ) as $ subresource ) { $ this -> addActions ( $ controller , $ subresource , $ chainName ) ; } }
5630	public function getIdentity ( ) { if ( $ this -> username && $ this -> password ) { return $ this -> username . ':' . $ this -> password ; } return false ; }
5636	public function paintFail ( $ message ) { parent :: paintFail ( $ message ) ; print $ this -> getFailCount ( ) . ") $message\n" ; $ breadcrumb = $ this -> getTestList ( ) ; array_shift ( $ breadcrumb ) ; print "\tin " . implode ( "\n\tin " , array_reverse ( $ breadcrumb ) ) ; print "\n" ; }
8780	protected function scheme ( ) { if ( $ this -> cachedHttps === true ) { $ this -> https = true ; } return "http" . ( $ this -> https === true ? 's' : '' ) . "://" ; }
2698	public function upgrade ( ModuleDataSetupInterface $ setup , ModuleContextInterface $ context ) { $ version = $ context -> getVersion ( ) ; if ( ! $ version ) { return ; } $ oldConfigPaths = [ 'stale_ttl' => 'system/full_page_cache/fastly/stale_ttl' , 'stale_error_ttl' => 'system/full_page_cache/fastly/stale_error_ttl' , 'purge_catalog_category' => 'system/full_page_cache/fastly/purge_catalog_category' , 'purge_catalog_product' => 'system/full_page_cache/fastly/purge_catalog_product' , 'purge_cms_page' => 'system/full_page_cache/fastly/purge_cms_page' , 'soft_purge' => 'system/full_page_cache/fastly/soft_purge' , 'enable_geoip' => 'system/full_page_cache/fastly/enable_geoip' , 'geoip_action' => 'system/full_page_cache/fastly/geoip_action' , 'geoip_country_mapping' => 'system/full_page_cache/fastly/geoip_country_mapping' , ] ; $ newConfigPaths = [ 'stale_ttl' => 'system/full_page_cache/fastly/fastly_advanced_configuration/stale_ttl' , 'stale_error_ttl' => 'system/full_page_cache/fastly/fastly_advanced_configuration/stale_error_ttl' , 'purge_catalog_category' => 'system/full_page_cache/fastly/fastly_advanced_configuration/purge_catalog_category' , 'purge_catalog_product' => 'system/full_page_cache/fastly/fastly_advanced_configuration/purge_catalog_product' , 'purge_cms_page' => 'system/full_page_cache/fastly/fastly_advanced_configuration/purge_cms_page' , 'soft_purge' => 'system/full_page_cache/fastly/fastly_advanced_configuration/soft_purge' , 'enable_geoip' => 'system/full_page_cache/fastly/fastly_advanced_configuration/enable_geoip' , 'geoip_action' => 'system/full_page_cache/fastly/fastly_advanced_configuration/geoip_action' , 'geoip_country_mapping' => 'system/full_page_cache/fastly/fastly_advanced_configuration/geoip_country_mapping' ] ; $ setup -> startSetup ( ) ; if ( version_compare ( $ version , '1.0.8' , '<=' ) ) { $ this -> upgrade108 ( $ oldConfigPaths , $ newConfigPaths ) ; } if ( version_compare ( $ version , '1.0.9' , '<=' ) ) { $ this -> upgrade109 ( $ setup ) ; } $ magVer = $ this -> productMetadata -> getVersion ( ) ; if ( version_compare ( $ version , '1.0.10' , '<=' ) && version_compare ( $ magVer , '2.2' , '>=' ) ) { $ this -> upgrade1010 ( $ newConfigPaths ) ; $ setup -> endSetup ( ) ; } elseif ( version_compare ( $ magVer , '2.2' , '<' ) ) { $ setup -> endSetup ( ) ; } }
981	public function planCharge ( ) { return $ this -> charges ( ) -> whereIn ( 'type' , [ Charge :: CHARGE_RECURRING , Charge :: CHARGE_ONETIME ] ) -> where ( 'plan_id' , $ this -> plan_id ) -> orderBy ( 'created_at' , 'desc' ) -> first ( ) ; }
5098	private function appendByPosition ( $ values ) { $ this -> setPart ( CmdInsert :: PART_AS , false ) ; if ( ! $ this -> placeholder ) $ this -> placeholder = Assembly :: placeholder ( count ( $ values ) , true ) ; return $ this -> appendPart ( CmdInsert :: PART_VALUES , $ this -> placeholder , $ values ) ; }
4055	private function convertLegends ( array $ properties , IMetaModel $ metaModel , array $ conditions ) : array { $ result = [ ] ; $ label = [ ] ; if ( $ trans = $ metaModel -> isTranslated ( ) ) { foreach ( $ metaModel -> getAvailableLanguages ( ) as $ availableLanguage ) { $ label [ $ availableLanguage ] = $ metaModel -> getName ( ) ; } } else { $ label [ $ metaModel -> getActiveLanguage ( ) ] = $ metaModel -> getName ( ) ; } $ legend = [ 'label' => $ label , 'hide' => false , 'properties' => [ ] ] ; $ condition = function ( $ property ) use ( $ conditions ) { if ( ! isset ( $ conditions [ $ property [ 'id' ] ] ) ) { return null ; } return [ 'type' => 'conditionand' , 'children' => $ conditions [ $ property [ 'id' ] ] ] ; } ; foreach ( $ properties as $ property ) { switch ( $ property [ 'dcatype' ] ) { case 'legend' : $ this -> convertLegend ( $ property , $ trans , $ condition , $ legend , $ result ) ; break ; case 'attribute' : $ this -> convertAttribute ( $ property , $ condition , $ legend ) ; break ; default : break ; } } if ( ! empty ( $ legend [ 'properties' ] ) ) { $ result [ 'legend' . ( \ count ( $ result ) + 1 ) ] = $ legend ; } return $ result ; }
8590	public function setGetMatchingProductResult ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'GetMatchingProductResult' ] [ 'FieldValue' ] = $ value ; return $ this ; }
10268	function createMailing ( $ name , $ subject , $ deprecatedParameter = false , $ type = "regular" ) { $ queryParameters = array ( 'name' => urlencode ( $ name ) , 'subject' => urlencode ( $ subject ) , 'type' => urlencode ( $ type ) , ) ; return $ this -> post ( 'mailings' , "" , $ queryParameters ) ; }
1213	public static function type ( $ arg ) { $ type = gettype ( $ arg ) ; if ( isset ( self :: $ typeMap [ $ type ] ) ) { return self :: $ typeMap [ $ type ] ; } elseif ( $ type === 'array' ) { if ( empty ( $ arg ) ) { return 'array' ; } reset ( $ arg ) ; return key ( $ arg ) === 0 ? 'array' : 'object' ; } elseif ( $ arg instanceof \ stdClass ) { return 'object' ; } elseif ( $ arg instanceof JmesPathableObjectInterface ) { return 'object' ; } elseif ( $ arg instanceof \ Closure ) { return 'expression' ; } elseif ( $ arg instanceof \ ArrayAccess && $ arg instanceof \ Countable ) { return count ( $ arg ) == 0 || $ arg -> offsetExists ( 0 ) ? 'array' : 'object' ; } elseif ( method_exists ( $ arg , '__toString' ) ) { return 'string' ; } throw new \ InvalidArgumentException ( 'Unable to determine JMESPath type from ' . get_class ( $ arg ) ) ; }
2339	public function renderDropdown ( ) { $ objVersion = $ this -> Database -> prepare ( "SELECT tstamp, version, username, active FROM tl_version WHERE fromTable=? AND pid=? ORDER BY version DESC" ) -> execute ( $ this -> strTable , $ this -> intPid ) ; if ( $ objVersion -> numRows < 2 ) { return '' ; } $ versions = '' ; while ( $ objVersion -> next ( ) ) { $ versions .= ' <option value="' . $ objVersion -> version . '"' . ( $ objVersion -> active ? ' selected="selected"' : '' ) . '>' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'version' ] . ' ' . $ objVersion -> version . ' (' . Date :: parse ( Config :: get ( 'datimFormat' ) , $ objVersion -> tstamp ) . ') ' . $ objVersion -> username . '</option>' ; } return '<div class="tl_version_panel"><form action="' . ampersand ( Environment :: get ( 'request' ) , true ) . '" id="tl_version" class="tl_form" method="post" aria-label="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'versioning' ] ) . '"><div class="tl_formbody"><input type="hidden" name="FORM_SUBMIT" value="tl_version"><input type="hidden" name="REQUEST_TOKEN" value="' . REQUEST_TOKEN . '"><select name="version" class="tl_select">' . $ versions . '</select><button type="submit" name="showVersion" id="showVersion" class="tl_submit">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'restore' ] . '</button><a href="' . Backend :: addToUrl ( 'versions=1&amp;popup=1' ) . '" title="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'showDifferences' ] ) . '" onclick="Backend.openModalIframe({\'title\':\'' . StringUtil :: specialchars ( str_replace ( "'" , "\\'" , sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'recordOfTable' ] , $ this -> intPid , $ this -> strTable ) ) ) . '\',\'url\':this.href});return false">' . Image :: getHtml ( 'diff.svg' ) . '</a></div></form></div>' ; }
10600	public function returnUrl ( ) { $ return = '' ; $ return .= empty ( $ this -> _urlParts [ 'scheme' ] ) ? '' : $ this -> _urlParts [ 'scheme' ] . '://' ; $ return .= empty ( $ this -> _urlParts [ 'user' ] ) ? '' : $ this -> _urlParts [ 'user' ] ; $ return .= empty ( $ this -> _urlParts [ 'pass' ] ) || empty ( $ this -> _urlParts [ 'user' ] ) ? '' : ':' . $ this -> _urlParts [ 'pass' ] ; $ return .= empty ( $ this -> _urlParts [ 'user' ] ) ? '' : '@' ; $ return .= empty ( $ this -> _urlParts [ 'host' ] ) ? '' : $ this -> _urlParts [ 'host' ] ; $ return .= empty ( $ this -> _urlParts [ 'port' ] ) ? '' : ':' . $ this -> _urlParts [ 'port' ] ; $ return .= empty ( $ this -> _urlParts [ 'path' ] ) ? '' : '/' . ltrim ( $ this -> _urlParts [ 'path' ] , '/' ) ; $ return .= empty ( $ this -> _urlParts [ 'query' ] ) ? '' : '?' . $ this -> _urlParts [ 'query' ] ; $ return .= empty ( $ this -> _urlParts [ 'fragment' ] ) ? '' : '#' . $ this -> _urlParts [ 'fragment' ] ; return $ return ; }
10784	public function parse ( UriInterface $ uri ) : ParsedURL { $ matches = [ ] ; if ( preg_match ( $ this -> pattern , $ uri -> getPath ( ) , $ matches ) === 0 ) { throw new InvalidRequestURLException ( "Unable to parse request path: did not match regex" ) ; } if ( ! ( $ endpoint = $ matches [ "endpoint" ] ?? null ) ) { throw new InvalidRequestURLException ( "Unable to match endpoint in url" ) ; } $ element = $ matches [ "element" ] ?? null ; $ version = $ matches [ "version" ] ?? null ; $ apiKey = $ matches [ "apiKey" ] ?? null ; $ acceptableMimeTypes = [ ] ; if ( ( $ acceptableExtension = $ matches [ "acceptableExtension" ] ?? null ) ) { if ( ! $ this -> MIMEProvider ) { throw new UnableToParseURLException ( "Unable to accept acceptable extensions" ) ; } else { try { $ acceptableMimeTypes [ ] = $ this -> MIMEProvider -> provideMIME ( $ acceptableExtension ) ; } catch ( UnableToProvideMIMEException $ exception ) { throw new UnableToParseURLException ( $ exception -> getMessage ( ) ) ; } } } return new ParsedURL ( $ endpoint , $ element , $ version , $ apiKey , $ acceptableMimeTypes , $ uri -> getQuery ( ) ) ; }
11697	public function __ ( $ key , array $ parameters = [ ] , $ locale = null , $ default = null , $ parseBBCode = true ) { return $ this -> translate ( $ key , $ parameters , $ locale , $ default , $ parseBBCode ) ; }
12368	public function set ( string $ name , string $ value = null ) : Headers { if ( $ value !== null ) { header ( $ name . ': ' . $ value ) ; } else { header ( $ name ) ; } return $ this ; }
12665	public function install ( ) : ApplicationInterface { try { $ resolved_modules = ( new ModuleDependencyResolver ( $ this -> required_modules ) ) -> resolve ( ) ; $ this -> installModules ( $ resolved_modules ) ; return $ this ; } catch ( \ Throwable $ e ) { throw new ApplicationInstallationException ( __METHOD__ . ' failed: ' . $ e -> getMessage ( ) , $ e ) ; } }
931	public function clear ( ) { @ trigger_error ( __METHOD__ . ' is deprecated and will be removed in 3.0.' , E_USER_DEPRECATED ) ; Tokens :: setLegacyMode ( true ) ; $ this -> content = '' ; $ this -> id = null ; $ this -> isArray = false ; }
5438	public function match ( $ subject , & $ match ) { if ( count ( $ this -> patterns ) === 0 ) { return false ; } if ( ! preg_match ( $ this -> getCompoundedRegex ( ) , $ subject , $ matches ) ) { $ match = '' ; return false ; } $ match = $ matches [ 0 ] ; for ( $ i = 1 ; $ i < count ( $ matches ) ; $ i ++ ) { if ( $ matches [ $ i ] ) { return $ this -> labels [ $ i - 1 ] ; } } return true ; }
10437	public function inject_template ( midgardmvc_core_request $ request ) { $ route = $ request -> get_route ( ) ; $ route -> template_aliases [ 'content-sidebar' ] = 'cmp-show-sidebar' ; $ route -> template_aliases [ 'main-menu' ] = 'cmp-show-main_menu' ; midgardmvc_core :: get_instance ( ) -> head -> add_link ( array ( 'rel' => 'stylesheet' , 'type' => 'text/css' , 'href' => MIDGARDMVC_STATIC_URL . '/com_meego_planet/planet.css' ) ) ; }
9578	protected function registerPlugin ( $ name ) { $ view = $ this -> getView ( ) ; if ( $ this -> materializeAsset ) { MaterializeAsset :: register ( $ view ) ; } if ( $ this -> customAsset ) { MaterializeCustomAsset :: register ( $ view ) ; } $ id = $ this -> options [ 'id' ] ; if ( $ this -> clientOptions !== false ) { $ options = empty ( $ this -> clientOptions ) ? '' : Json :: encode ( $ this -> clientOptions ) ; $ js = "jQuery('#$id').$name($options);" ; $ view -> registerJs ( $ js ) ; } $ this -> registerClientEvents ( ) ; }
7743	public function setValue ( $ entity , $ value ) { if ( false === ( $ entity instanceof $ this -> class ) ) { throw new \ Exception ( "Can't set the entity's {$this->name} property as the entity is not an instance of {$this->class}." ) ; } if ( ! is_array ( $ value ) && ! ( $ value instanceof \ Traversable ) ) { if ( ( null !== $ this -> adderRemover ) && ( null !== $ this -> getter ) ) { $ itemsToAdd = is_object ( $ value ) ? iterator_to_array ( $ value ) : $ value ; $ itemToRemove = array ( ) ; $ previousValue = $ this -> getValue ( $ entity ) ; if ( is_array ( $ previousValue ) || $ previousValue instanceof \ Traversable ) { foreach ( $ previousValue as $ previousItem ) { foreach ( $ value as $ key => $ item ) { if ( $ item === $ previousItem ) { unset ( $ itemsToAdd [ $ key ] ) ; continue 2 ; } } $ itemToRemove [ ] = $ previousItem ; } } foreach ( $ itemToRemove as $ item ) { call_user_func ( array ( $ entity , 'remove' . $ this -> adderRemover ) , $ item ) ; } foreach ( $ itemsToAdd as $ item ) { call_user_func ( array ( $ entity , 'add' . $ this -> adderRemover ) , $ item ) ; } return ; } } if ( null === $ this -> setter ) { throw new \ Exception ( "Can't set the entity's {$this->name} property as no setter has been found." ) ; } if ( self :: GETTER_SETTER_METHOD === $ this -> setterType ) { return $ entity -> { $ this -> setter } ( $ value ) ; } else { return $ entity -> { $ this -> setter } = $ value ; } }
2926	public function load ( $ filePath = null , $ restoreIfNotFound = false , $ restorePath = null ) { $ this -> resetContent ( ) ; if ( ! is_null ( $ filePath ) ) { $ this -> filePath = $ filePath ; } else { if ( method_exists ( $ this -> app , 'environmentPath' ) && method_exists ( $ this -> app , 'environmentFile' ) ) { $ this -> filePath = $ this -> app -> environmentPath ( ) . '/' . $ this -> app -> environmentFile ( ) ; } else { $ this -> filePath = __DIR__ . '/../../../../../../.env' ; } } $ this -> reader -> load ( $ this -> filePath ) ; if ( file_exists ( $ this -> filePath ) ) { $ this -> writer -> setBuffer ( $ this -> getContent ( ) ) ; return $ this ; } elseif ( $ restoreIfNotFound ) { return $ this -> restore ( $ restorePath ) ; } else { return $ this ; } }
12597	public function getCacheAdapter ( $ namespace ) { if ( ! $ this -> isCacheable ( $ namespace ) ) { return null ; } if ( is_array ( $ this -> cacheOptions -> getAdapter ( ) ) ) { if ( ! isset ( $ this -> cacheOptions -> getAdapter ( ) [ $ namespace ] ) ) { return null ; } $ adapter = $ this -> cacheOptions -> getAdapter ( ) [ $ namespace ] ; } else { $ adapter = $ this -> cacheOptions -> getAdapter ( ) ; } if ( is_object ( $ adapter ) ) { return $ adapter ; } if ( $ this -> getServiceLocator ( ) -> has ( $ adapter ) ) { return $ this -> getServiceLocator ( ) -> get ( $ adapter ) ; } return new $ adapter ; }
5768	public function addColumn ( string $ name , $ value ) { $ this -> args [ ] = $ value ; if ( count ( $ this -> args ) > 1 ) { $ this -> setColumnsValues .= ", " ; } $ argNum = count ( $ this -> args ) ; $ this -> setColumnsValues .= "$name = \$" . $ argNum ; }
7429	public function loginAction ( Request $ request ) { $ session = $ request -> getSession ( ) ; $ form = $ this -> createFormBuilder ( ) -> add ( 'username' , TextType :: class , array ( 'label' => 'Username' ) ) -> add ( 'password' , PasswordType :: class , array ( 'label' => 'Password' ) ) -> add ( 'rememberMe' , CheckboxType :: class , array ( 'label' => 'Remember Me' , 'required' => false ) ) -> getForm ( ) ; $ helper = $ this -> get ( 'security.authentication_utils' ) ; if ( $ lastUsername = $ helper -> getLastUsername ( ) ) { $ form -> setData ( array ( 'username' => $ lastUsername ) ) ; } return array ( 'form' => $ form -> createView ( ) ) ; }
5758	protected function getFromClause ( ) : string { return "FROM " . self :: TABLE_NAME . " JOIN " . self :: ROLES_JOIN_TABLE_NAME . " ON " . self :: TABLE_NAME . ".id = " . self :: ROLES_JOIN_TABLE_NAME . ".permission_id JOIN " . self :: ROLES_TABLE_NAME . " ON " . self :: ROLES_JOIN_TABLE_NAME . ".role_id=" . self :: ROLES_TABLE_NAME . ".id" ; }
6835	protected function preventForbiddenChange ( Model \ InvoiceLineInterface $ line ) { if ( $ this -> persistenceHelper -> isChanged ( $ line , 'type' ) ) { list ( $ old , $ new ) = $ this -> persistenceHelper -> getChangeSet ( $ line , 'type' ) ; if ( $ old !== $ new ) { throw new Exception \ RuntimeException ( "Changing the invoice line's type is not supported." ) ; } } }
3320	public function getValidValues ( ) { if ( $ this -> validValues ) { if ( is_callable ( $ this -> validValues ) ) { return call_user_func ( $ this -> validValues ) ; } return $ this -> validValues ; } return ; }
7944	public function ipGetRange ( $ id , $ ip ) { if ( ! $ id ) throw new BadMethodCallException ( 'Missing parameter $id.' ) ; if ( ! $ ip ) throw new BadMethodCallException ( 'Missing parameter $ip.' ) ; return json_decode ( $ this -> getIpProperties ( $ id , $ ip ) ) -> range ; }
11679	protected function log ( $ message , $ priority = Logger :: DEBUG , array $ extra = [ ] ) { if ( $ this -> getLogger ( ) === null ) { return $ this ; } $ this -> getLogger ( ) -> log ( $ priority , $ message , $ extra ) ; return $ this ; }
6277	protected function readInt32 ( $ pos = 0 ) { static $ lookups ; if ( ! $ lookups ) { $ lookups = [ ] ; for ( $ i = 1 ; $ i < 256 ; $ i ++ ) { $ lookups [ chr ( $ i ) ] = $ i ; } } $ buf = $ this -> read ( $ pos , 4 ) ; $ rv = 0 ; if ( $ buf [ 0 ] !== "\x0" ) { $ rv = $ lookups [ $ buf [ 0 ] ] ; } if ( $ buf [ 1 ] !== "\x0" ) { $ rv |= ( $ lookups [ $ buf [ 1 ] ] << 8 ) ; } if ( $ buf [ 2 ] !== "\x0" ) { $ rv |= ( $ lookups [ $ buf [ 2 ] ] << 16 ) ; } if ( $ buf [ 3 ] !== "\x0" ) { $ rv |= ( $ lookups [ $ buf [ 3 ] ] << 24 ) ; } return $ rv ; }
3217	function chunkedUploadContinue ( $ uploadId , $ byteOffset , $ data ) { Checker :: argStringNonEmpty ( "uploadId" , $ uploadId ) ; Checker :: argNat ( "byteOffset" , $ byteOffset ) ; Checker :: argString ( "data" , $ data ) ; $ response = $ this -> _chunkedUpload ( array ( "upload_id" => $ uploadId , "offset" => $ byteOffset ) , $ data ) ; if ( $ response -> statusCode === 404 ) { return false ; } $ correction = self :: _chunkedUploadCheckForOffsetCorrection ( $ response ) ; if ( $ correction !== null ) { list ( $ correctedUploadId , $ correctedByteOffset ) = $ correction ; if ( $ correctedUploadId !== $ uploadId ) throw new Exception_BadResponse ( "Corrective 400 upload_id mismatch: us=" . Util :: q ( $ uploadId ) . " server=" . Util :: q ( $ correctedUploadId ) ) ; if ( $ correctedByteOffset === $ byteOffset ) throw new Exception_BadResponse ( "Corrective 400 offset is the same as ours: $byteOffset" ) ; return $ correctedByteOffset ; } if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; list ( $ retUploadId , $ retByteOffset ) = self :: _chunkedUploadParse200Response ( $ response -> body ) ; $ nextByteOffset = $ byteOffset + strlen ( $ data ) ; if ( $ uploadId !== $ retUploadId ) throw new Exception_BadResponse ( "upload_id mismatch: us=" . Util :: q ( $ uploadId ) . ", server=" . Util :: q ( $ uploadId ) ) ; if ( $ nextByteOffset !== $ retByteOffset ) throw new Exception_BadResponse ( "next-offset mismatch: us=$nextByteOffset, server=$retByteOffset" ) ; return true ; }
3876	private function getMetaModelsPages ( $ config , $ rootPage = null , $ language = null ) { $ metaModelsIdentifier = $ config [ 'pid' ] ; $ filterIdentifier = $ config [ 'filter' ] ; $ presetParams = StringUtil :: deserialize ( $ config [ 'filterparams' ] , true ) ; $ renderSettingId = $ config [ 'rendersetting' ] ; $ metaModels = $ this -> getMetaModel ( $ metaModelsIdentifier , false ) ; $ availableLanguages = $ this -> getLanguage ( $ language , $ metaModels ) ; $ currentLanguage = $ GLOBALS [ 'TL_LANGUAGE' ] ; foreach ( $ availableLanguages as $ newLanguage ) { $ GLOBALS [ 'TL_LANGUAGE' ] = $ newLanguage ; $ view = $ this -> getView ( $ metaModelsIdentifier , $ renderSettingId ) ; $ jumpTos = $ view -> get ( 'jumpTo' ) ; $ processed = $ this -> setFilterParameters ( $ filterIdentifier , $ presetParams , array ( ) ) ; $ filter = $ metaModels -> getEmptyFilter ( ) ; $ filterSetting = $ this -> getFilterSettings ( $ filterIdentifier ) ; $ filterSetting -> addRules ( $ filter , $ processed ) ; $ newEntries = $ this -> getJumpTosFor ( $ metaModels , $ filter , $ view , $ rootPage ) ; $ this -> removeEmptyDetailPages ( $ jumpTos ) ; $ GLOBALS [ 'TL_LANGUAGE' ] = $ currentLanguage ; $ this -> foundPages = array_merge ( $ this -> foundPages , $ newEntries ) ; } $ GLOBALS [ 'TL_LANGUAGE' ] = $ currentLanguage ; }
3310	public function getAccessToken ( $ forceRefresh = false ) { $ cacheKey = $ this -> getCacheKey ( ) ; $ cached = $ this -> getCache ( ) -> fetch ( $ cacheKey ) ; if ( empty ( $ cached ) || $ forceRefresh ) { $ token = $ this -> getTokenFormApi ( ) ; $ this -> getCache ( ) -> save ( $ cacheKey , $ token [ $ this -> tokenSucessKey ] , $ token [ 'expires_in' ] ) ; return $ token [ $ this -> tokenSucessKey ] ; } return $ cached ; }
12967	public function getObjectType ( ) { if ( is_null ( $ this -> _objectType ) && isset ( $ this -> object ) ) { $ this -> _objectType = $ this -> object -> objectType -> systemId ; } return $ this -> _objectType ; }
9144	public static function generate ( $ length = 8 , $ allowed = RandomString :: ASCII , $ repeatable = true ) : string { $ allowedChars = array ( ) ; $ currentLocale = setlocale ( LC_ALL , "0" ) ; if ( $ allowed == RandomString :: ASCII ) { setlocale ( LC_ALL , "C" ) ; } for ( $ i = 32 ; $ i < 256 ; $ i ++ ) { if ( ( $ allowed == RandomString :: ASCII && ! ctype_alnum ( chr ( $ i ) ) ) || ( ! ctype_print ( chr ( $ i ) ) ) ) { continue ; } $ allowedChars [ ] = $ i ; } self :: resetLocaleTo ( $ currentLocale ) ; $ used = array ( ) ; $ string = "" ; $ i = $ length ; while ( $ i > 0 ) { $ index = mt_rand ( 0 , count ( $ allowedChars ) - 1 ) ; if ( ! $ repeatable && in_array ( $ index , $ used ) ) { continue ; } $ string .= chr ( $ allowedChars [ $ index ] ) ; $ used [ ] = $ i ; $ i -- ; } return $ string ; }
10858	public function eachMarked ( callable $ callback , $ result = null ) { $ ref = new \ ReflectionFunction ( $ callback ) ; $ params = $ ref -> getParameters ( ) ; if ( \ count ( $ params ) < 2 ) { throw new \ InvalidArgumentException ( \ sprintf ( 'Callback for marker processing must declare at least 2 arguments (object and marker)' ) ) ; } try { $ markerType = $ params [ 1 ] -> getClass ( ) ; } catch ( \ ReflectionException $ e ) { throw new \ InvalidArgumentException ( \ sprintf ( 'Marker class not found: %s' , $ params [ 1 ] -> getType ( ) ) , 0 , $ e ) ; } if ( $ markerType === null ) { throw new \ InvalidArgumentException ( \ sprintf ( 'Argument #2 of marker callback needs to declare a type-hint for the marker' ) ) ; } $ marker = $ markerType -> getName ( ) ; if ( ! $ markerType -> isSubclassOf ( Marker :: class ) ) { throw new \ InvalidArgumentException ( \ sprintf ( 'Marker implementation %s must extend %s' , $ marker , Marker :: class ) ) ; } if ( ! isset ( $ this -> marked [ $ marker ] ) ) { $ this -> cacheMarkers ( $ marker ) ; } foreach ( $ this -> marked [ $ marker ] as list ( $ definition , $ registration ) ) { $ result = $ callback ( $ this -> shared [ $ definition -> typeName ] ?? $ this -> get ( $ definition -> typeName ) , clone $ registration , $ result ) ; } return $ result ; }
2699	private function upgrade108 ( $ oldConfigPaths , $ newConfigPaths ) { foreach ( $ oldConfigPaths as $ key => $ value ) { $ oldValue = $ this -> scopeConfig -> getValue ( $ value ) ; if ( $ oldValue != null ) { $ this -> configWriter -> save ( $ newConfigPaths [ $ key ] , $ oldValue ) ; } } }
10515	public function inc ( $ key , $ expire = 0 ) { $ this -> getLock ( $ key ) ; $ this -> set ( $ key , ( int ) $ this -> get ( $ key ) + 1 ) ; $ this -> releaseLock ( $ key ) ; return true ; }
12576	public function previewTextByName ( $ message , $ to ) { return $ this -> preview ( self :: MSG_TYPE_TEXT , $ message , $ to , self :: PREVIEW_BY_NAME ) ; }
12452	static function run_update_package_xml ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { $ opts = self :: getOpts ( @ $ args [ 0 ] , @ $ args [ 1 ] , $ cliopts ) ; if ( ! SharedLock :: acquire ( $ opts [ 'extension' ] [ 'name' ] , LOCK_EX , $ opts ) ) throw new PakeException ( "Source code locked by another process" ) ; $ destdir = $ opts [ 'build' ] [ 'dir' ] ; $ files = pakeFinder :: type ( 'file' ) -> name ( 'package.xml' ) -> maxdepth ( 0 ) ; if ( count ( $ files ) == 1 ) { pake_replace_regexp ( $ files , $ destdir , array ( '#^( *\074name\076)(.*)(\074/name\076\r?\n?)$#m' => '${1}' . $ opts [ 'extension' ] [ 'name' ] . '_extension' . '$3' , '#^( *\074version\076)(.*)(\074/version\076\r?\n?)$#m' => '${1}' . $ opts [ 'ezp' ] [ 'version' ] [ 'major' ] . '.' . $ opts [ 'ezp' ] [ 'version' ] [ 'minor' ] . '.' . $ opts [ 'ezp' ] [ 'version' ] [ 'release' ] . '$3' , '#^( *\074named-version\076)(.*)(\074/named-version\076\r?\n?)$#m' => '${1}' . $ opts [ 'ezp' ] [ 'version' ] [ 'major' ] . '.' . $ opts [ 'ezp' ] [ 'version' ] [ 'minor' ] . '$3' , '#^( *\074number\076)(.*)(\074/number\076\r?\n?)$#m' => '${1}' . $ opts [ 'version' ] [ 'alias' ] . '$3' , '#^( *\074release\076)(.*)(\074/release\076\r?\n?)$#m' => '${1}' . $ opts [ 'version' ] [ 'release' ] . '$3' , '#^( *\074timestamp\076)(.*)(\074/timestamp\076\r?\n?)$#m' => '${1}' . time ( ) . '$3' , '#^( *\074host\076)(.*)(\074/host\076\r?\n?)$#m' => '${1}' . gethostname ( ) . '$3' , '#^( *\074licence\076)(.*)(\074/licence\076\r?\n?)$#m' => '${1}' . $ opts [ 'version' ] [ 'license' ] . '$3' , ) ) ; pake_replace_tokens ( $ files , $ destdir , '{' , '}' , array ( '$name' => $ opts [ 'extension' ] [ 'name' ] , '$version' => $ opts [ 'version' ] [ 'alias' ] , '$ezp_version' => $ opts [ 'ezp' ] [ 'version' ] [ 'major' ] . '.' . $ opts [ 'ezp' ] [ 'version' ] [ 'minor' ] . '.' . $ opts [ 'ezp' ] [ 'version' ] [ 'release' ] ) ) ; } SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_EX , $ opts ) ; }
6565	public static function register ( $ prepend = true , $ callback = null , $ app = null ) { if ( ! static :: $ registered ) { static :: $ registered = spl_autoload_register ( array ( '\\Sbp\\Laravel\\ClassLoader' , 'load' ) , true , $ prepend ) ; if ( is_null ( $ app ) ) { $ app = __DIR__ . '/../../../../../../app' ; } if ( ! file_exists ( $ app . '/storage' ) || ! is_writable ( $ app . '/storage' ) ) { throw new SbpException ( "Laravel app and/or writable storage directory not found at $app, please specify the path with the following code:\nSbp\\Laravel\\ClassLoader::register(true, 'sha1', \$laravelAppPath)" ) ; } Sbp :: writeIn ( Sbp :: SAME_DIR ) ; Sbp :: fileExists ( $ app . '/routes' ) ; $ storage = $ app . '/storage/sbp' ; if ( ! file_exists ( $ storage ) ) { if ( mkdir ( $ storage , 0777 ) ) { file_put_contents ( $ storage . '/.gitignore' , "*\n!.gitignore" ) ; } } Sbp :: writeIn ( $ storage , $ callback ) ; } }
8076	public function post ( $ endpoint , $ data , $ query = [ ] ) { $ endpoint = $ this -> buildUri ( $ endpoint , $ query ) ; $ headers = $ this -> buildHeaders ( ) ; $ data = $ this -> prepareData ( $ data ) ; $ this -> response = $ this -> client -> post ( $ endpoint , $ data , $ headers ) ; return $ this -> response ; }
9882	private function writeSheet ( XMLWriter $ objWriter , $ pSheetname , $ pSheetId = 1 , $ pRelId = 1 , $ sheetState = 'visible' ) { if ( $ pSheetname != '' ) { $ objWriter -> startElement ( 'sheet' ) ; $ objWriter -> writeAttribute ( 'name' , $ pSheetname ) ; $ objWriter -> writeAttribute ( 'sheetId' , $ pSheetId ) ; if ( $ sheetState != 'visible' && $ sheetState != '' ) { $ objWriter -> writeAttribute ( 'state' , $ sheetState ) ; } $ objWriter -> writeAttribute ( 'r:id' , 'rId' . $ pRelId ) ; $ objWriter -> endElement ( ) ; } else { throw new WriterException ( 'Invalid parameters passed.' ) ; } }
12153	public function getPossibleRoles ( ) { $ roles = [ ] ; foreach ( Yii :: $ app -> collectors [ 'roles' ] -> getAll ( ) as $ roleItem ) { $ test = true ; switch ( $ roleItem -> systemId ) { case 'owner' : $ test = $ this -> isOwnable ; break ; } if ( $ test ) { $ roles [ ] = $ roleItem -> object -> primaryKey ; } } return $ roles ; }
1227	private function parseJson ( array $ token ) { $ value = json_decode ( $ token [ 'value' ] , true ) ; if ( $ error = json_last_error ( ) ) { $ value = json_decode ( '"' . $ token [ 'value' ] . '"' , true ) ; if ( $ error = json_last_error ( ) ) { $ token [ 'type' ] = self :: T_UNKNOWN ; return $ token ; } } $ token [ 'value' ] = $ value ; return $ token ; }
11519	protected function GenerateAndroidPinicon ( SiteConfig $ config , SiteTree $ owner , & $ metadata ) { $ metadata .= $ owner -> MarkupComment ( 'Android Pinned Icon' ) ; if ( $ config -> fetchAndroidPiniconThemeColor ( ) ) { $ metadata .= $ owner -> MarkupMeta ( 'theme-color' , $ config -> fetchAndroidPiniconThemeColor ( ) ) ; } $ metadata .= $ owner -> MarkupLink ( 'manifest' , '/manifest.json' ) ; }
9682	function fromXML ( $ xmlElement ) { $ this -> contact = new ReportContact ( ) ; $ this -> contact -> fromXML ( $ xmlElement -> contact ) ; if ( isset ( $ xmlElement -> mailing_id ) ) $ this -> mailingId = $ xmlElement -> mailing_id ; if ( isset ( $ xmlElement -> timestamp ) ) $ this -> timestamp = $ xmlElement -> timestamp ; if ( isset ( $ xmlElement -> link_id ) ) $ this -> linkId = $ xmlElement -> link_id ; if ( isset ( $ xmlElement -> link_url ) ) $ this -> linkUrl = $ xmlElement -> link_url ; if ( isset ( $ xmlElement -> link_tags ) ) { $ this -> linkTags = array ( ) ; foreach ( $ xmlElement -> link_tags -> children ( ) as $ field ) { array_push ( $ this -> linkTags , $ field [ 0 ] ) ; } } }
11740	public function exportAction ( ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ chillSecurityHelper = $ this -> get ( 'chill.main.security.authorization.helper' ) ; $ user = $ this -> get ( 'security.context' ) -> getToken ( ) -> getUser ( ) ; $ reachableCenters = $ chillSecurityHelper -> getReachableCenters ( $ user , new Role ( 'CHILL_PERSON_SEE' ) ) ; $ personRepository = $ em -> getRepository ( 'ChillPersonBundle:Person' ) ; $ qb = $ personRepository -> createQueryBuilder ( 'p' ) ; $ qb -> where ( $ qb -> expr ( ) -> in ( 'p.center' , ':centers' ) ) -> setParameter ( 'centers' , $ reachableCenters ) ; $ persons = $ qb -> getQuery ( ) -> getResult ( ) ; $ response = $ this -> render ( 'ChillPersonBundle:Person:export.csv.twig' , array ( 'persons' => $ persons , 'cf_group' => $ this -> getCFGroup ( ) ) ) ; $ response -> headers -> set ( 'Content-Type' , 'text/csv; charset=utf-8' ) ; $ response -> headers -> set ( 'Content-Disposition' , 'attachment; filename="export_person.csv"' ) ; return $ response ; }
1354	protected function sort ( $ query , array $ sortBy ) { foreach ( $ sortBy as $ param ) { $ this -> sortBy ( $ query , $ param ) ; } }
6964	protected function getYear ( ) { $ year = 0 ; if ( $ this -> type == YearType :: Besselian ( ) ) $ year = 1900 + ( $ this -> jd - Epoch :: B1900 ( ) -> jd ) / static :: DaysBesselianYear ; else $ year = 2000 + ( $ this -> jd - Epoch :: J2000 ( ) -> jd ) / static :: DaysJulianYear ; return round ( $ year , 6 ) ; }
5148	protected function getMostRecentUnreadEmail ( ) { if ( empty ( $ this -> unreadInbox ) ) { $ this -> fail ( 'Unread Inbox is Empty' ) ; } $ email = array_shift ( $ this -> unreadInbox ) ; $ content = $ this -> getFullEmail ( $ email -> id ) ; $ content -> Headers = $ this -> getHeaders ( $ email -> id ) -> headers ; return $ content ; }
3872	protected function getJumpTosFor ( $ metaModels , $ filter , $ view , $ rootPage = null ) { $ entries = array ( ) ; $ items = $ metaModels -> findByFilter ( $ filter ) ; foreach ( $ items as $ item ) { $ jumpTo = $ item -> buildJumpToLink ( $ view ) ; $ event = new GetPageDetailsEvent ( $ jumpTo [ 'page' ] ) ; $ this -> getEventDispatcher ( ) -> dispatch ( ContaoEvents :: CONTROLLER_GET_PAGE_DETAILS , $ event ) ; $ pageDetails = $ event -> getPageDetails ( ) ; if ( $ pageDetails === null || ( $ rootPage !== null && $ pageDetails [ 'rootId' ] != $ rootPage ) ) { continue ; } $ url = $ this -> getBaseUrl ( $ pageDetails , $ jumpTo [ 'url' ] ) ; $ entries [ ] = $ url -> getUrl ( ) ; } return $ entries ; }
6408	public static function filterBy ( IteratorAggregate $ unfiltered , string $ className ) : IteratorAggregate { return self :: from ( Iterators :: filterBy ( Iterators :: from ( $ unfiltered -> getIterator ( ) ) , $ className ) ) ; }
3685	protected function optimizedFilter ( $ filterRule , $ children , $ operation ) { $ procedure = new FilterBuilderSql ( $ this -> getMetaModel ( ) -> getTableName ( ) , $ operation , $ this -> connection ) ; $ skipped = $ this -> buildNativeSqlProcedure ( $ procedure , $ children ) ; if ( ! $ procedure -> isEmpty ( ) ) { $ filterRule -> addChild ( $ this -> getMetaModel ( ) -> getEmptyFilter ( ) -> addFilterRule ( $ procedure -> build ( ) ) ) ; } return $ skipped ; }
8705	public function extend ( EloquentBuilder $ builder ) { $ builder -> macro ( 'onlyTranslated' , function ( EloquentBuilder $ builder , $ locale = null ) { $ builder -> getModel ( ) -> setOnlyTranslated ( true ) ; if ( $ locale ) { $ builder -> getModel ( ) -> setLocale ( $ locale ) ; } return $ builder ; } ) ; $ builder -> macro ( 'withUntranslated' , function ( EloquentBuilder $ builder ) { $ builder -> getModel ( ) -> setOnlyTranslated ( false ) ; return $ builder ; } ) ; $ builder -> macro ( 'withFallback' , function ( EloquentBuilder $ builder , $ fallbackLocale = null ) { $ builder -> getModel ( ) -> setWithFallback ( true ) ; if ( $ fallbackLocale ) { $ builder -> getModel ( ) -> setFallbackLocale ( $ fallbackLocale ) ; } return $ builder ; } ) ; $ builder -> macro ( 'withoutFallback' , function ( EloquentBuilder $ builder ) { $ builder -> getModel ( ) -> setWithFallback ( false ) ; return $ builder ; } ) ; $ builder -> macro ( 'translateInto' , function ( EloquentBuilder $ builder , $ locale ) { if ( $ locale ) { $ builder -> getModel ( ) -> setLocale ( $ locale ) ; } return $ builder ; } ) ; $ builder -> macro ( 'withoutTranslations' , function ( EloquentBuilder $ builder ) { $ builder -> withoutGlobalScope ( static :: class ) ; return $ builder ; } ) ; $ builder -> macro ( 'withAllTranslations' , function ( EloquentBuilder $ builder ) { $ builder -> withoutGlobalScope ( static :: class ) -> with ( 'translations' ) ; return $ builder ; } ) ; }
9276	public function validateFields ( Request $ request , Repository $ repository , $ data ) { $ config = [ ] ; $ validation = [ ] ; foreach ( $ this -> versions as $ version ) { foreach ( $ version [ 'endpoints' ] as $ endpoint ) { if ( $ endpoint [ 'repository' ] == $ request -> attributes -> get ( 'repository' ) ) { $ config = $ endpoint ; break ; } } if ( $ config != [ ] ) { break ; } } if ( ! $ config [ 'allow_extra_fields' ] || $ config [ 'allow_fields' ] ) { $ mapping = $ this -> manager -> getMetadataCollector ( ) -> getMapping ( $ repository -> getClassName ( ) ) ; $ forbiddenFields = $ mapping [ 'properties' ] ; if ( $ config [ 'allow_fields' ] ) { foreach ( $ config [ 'allow_fields' ] as $ field ) { unset ( $ forbiddenFields [ $ field ] ) ; } } foreach ( $ data as $ parameter => $ value ) { if ( ! array_key_exists ( $ parameter , $ mapping [ 'properties' ] ) && $ parameter != '_id' ) { $ validation [ 'message' ] = sprintf ( 'Property `%s` does not exist in the mapping of `%s`.' , $ parameter , $ repository -> getType ( ) ) ; return $ validation ; } if ( $ config [ 'allow_fields' ] && array_key_exists ( $ parameter , $ forbiddenFields ) ) { $ validation [ 'message' ] = sprintf ( 'You are not allowed to insert or modify the field `%s` in `%s`' , $ parameter , $ repository -> getType ( ) ) ; return $ validation ; } } } return $ validation ; }
12970	private function getReflectionAndClassObject ( ) { if ( $ this -> isCalledAfterOn ) { $ this -> isCalledAfterOn = false ; $ classObj = $ this -> classObjOn ; $ reflection = $ this -> reflectionOn ; unset ( $ this -> classObjOn ) ; unset ( $ this -> reflectionOn ) ; return [ $ reflection , $ classObj ] ; } return [ $ this -> reflection , $ this -> classObj ] ; }
10007	public function getRibbonBinObjects ( $ what = 'all' ) { $ ReturnData = null ; $ what = strtolower ( $ what ) ; switch ( $ what ) { case 'all' : return $ this -> ribbonBinObjects ; break ; case 'names' : case 'data' : if ( is_array ( $ this -> ribbonBinObjects ) && isset ( $ this -> ribbonBinObjects [ $ what ] ) ) { $ ReturnData = $ this -> ribbonBinObjects [ $ what ] ; } break ; case 'types' : if ( is_array ( $ this -> ribbonBinObjects ) && isset ( $ this -> ribbonBinObjects [ 'data' ] ) && is_array ( $ this -> ribbonBinObjects [ 'data' ] ) ) { $ tmpTypes = array_keys ( $ this -> ribbonBinObjects [ 'data' ] ) ; $ ReturnData = array_unique ( array_map ( [ $ this , 'getExtensionOnly' ] , $ tmpTypes ) ) ; } else { $ ReturnData = [ ] ; } break ; } return $ ReturnData ; }
691	protected function isActive ( $ action ) { $ id = $ this -> getActionId ( $ action ) ; if ( empty ( $ this -> only ) ) { $ onlyMatch = true ; } else { $ onlyMatch = false ; foreach ( $ this -> only as $ pattern ) { if ( StringHelper :: matchWildcard ( $ pattern , $ id ) ) { $ onlyMatch = true ; break ; } } } $ exceptMatch = false ; foreach ( $ this -> except as $ pattern ) { if ( StringHelper :: matchWildcard ( $ pattern , $ id ) ) { $ exceptMatch = true ; break ; } } return ! $ exceptMatch && $ onlyMatch ; }
12840	static public function getMimeType ( $ filePath , $ default = 'application/octet-stream' ) { $ mimeType = finfo_file ( finfo_open ( FILEINFO_MIME_TYPE ) , $ filePath ) ; if ( $ mimeType === false ) { $ mimeType = $ default ; } return $ mimeType ; }
9215	public function actionUpdate ( $ id ) { $ model = $ this -> findModel ( $ id ) ; $ model -> tags = ! empty ( $ model -> tags ) ? explode ( "," , $ model -> tags ) : [ ] ; $ post = Yii :: $ app -> request -> post ( ) ; if ( isset ( $ post [ 'StaticPage' ] [ 'tags' ] ) ) { if ( is_array ( $ post [ 'StaticPage' ] [ 'tags' ] ) ) { $ post [ 'StaticPage' ] [ 'tags' ] = implode ( "," , $ post [ 'StaticPage' ] [ 'tags' ] ) ; } } if ( $ model -> load ( $ post ) && $ model -> save ( ) ) { return $ this -> redirect ( [ 'view' , 'id' => $ model -> id ] ) ; } else { return $ this -> render ( 'update' , [ 'model' => $ model , ] ) ; } }
2297	public static function handleRunOnce ( ) { try { $ files = System :: getContainer ( ) -> get ( 'contao.resource_locator' ) -> locate ( 'config/runonce.php' , null , false ) ; } catch ( \ InvalidArgumentException $ e ) { return ; } foreach ( $ files as $ file ) { try { include $ file ; } catch ( \ Exception $ e ) { } $ strRelpath = StringUtil :: stripRootDir ( $ file ) ; if ( ! unlink ( $ file ) ) { throw new \ Exception ( "The file $strRelpath cannot be deleted. Please remove the file manually and correct the file permission settings on your server." ) ; } System :: log ( "File $strRelpath ran once and has then been removed successfully" , __METHOD__ , TL_GENERAL ) ; } }
10963	public static function getUri ( ) { $ parts = [ $ uri = self :: getScheme ( ) , '://' ] ; $ authUsername = self :: getAuthUsername ( ) ; $ authPassword = self :: getAuthPassword ( ) ; if ( $ authUsername !== null && $ authPassword !== null ) { $ parts [ ] = $ authUsername . ':' . $ authPassword . '@' ; } $ parts [ ] = self :: getHost ( ) ; $ port = self :: getPort ( ) ; if ( $ port != self :: getStandardPort ( self :: getScheme ( ) ) ) { $ parts [ ] = ':' . $ port ; } $ path = self :: getPath ( ) ; if ( $ path !== null && $ path != '' ) { $ parts [ ] = '/' . $ path ; } $ query = Input :: getQuery ( ) ; if ( is_array ( $ query ) && count ( $ query ) > 0 ) { $ queryString = [ ] ; foreach ( $ query as $ key => $ value ) { $ queryKeyValue = $ key . '=' ; if ( $ value !== null ) { if ( is_string ( $ value ) ) { $ value = urlencode ( $ value ) ; } $ queryKeyValue .= $ value ; } $ queryString [ ] = $ queryKeyValue ; } if ( count ( $ queryString ) > 0 ) { $ parts [ ] = '?' . implode ( '&' , $ queryString ) ; } } return implode ( '' , $ parts ) ; }
2842	public function getBlocksAsTree ( ) { $ blocks = $ this -> getRequestInfo ( ) -> getBlocks ( ) ; $ tree = new Varien_Data_Tree ( ) ; $ rootNodes = array ( ) ; foreach ( $ blocks as $ block ) { $ parentNode = $ tree -> getNodeById ( $ block -> getParentName ( ) ) ; $ node = new Varien_Data_Tree_Node ( array ( 'name' => $ block -> getName ( ) , 'class' => $ block -> getClass ( ) , 'template' => $ block -> getTemplateFile ( ) , 'duration' => $ block -> getRenderedDuration ( ) , 'count' => $ block -> getRenderedCount ( ) ) , 'name' , $ tree , $ parentNode ) ; $ tree -> addNode ( $ node , $ parentNode ) ; if ( ! $ parentNode ) { $ rootNodes [ ] = $ node ; } } return $ rootNodes ; }
5863	protected function expandConversionMapping ( array $ mapping ) { $ ret = [ ] ; $ matches = [ ] ; foreach ( $ mapping as $ m ) { if ( preg_match ( '/^(.*)\s*=>\s*(.*)/' , $ m , $ matches ) ) { $ ret [ trim ( $ matches [ 1 ] ) ] = trim ( $ matches [ 2 ] ) ; } } return $ ret ; }
9709	private function writeCodepage ( ) { $ record = 0x0042 ; $ length = 0x0002 ; $ cv = $ this -> codepage ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ cv ) ; $ this -> append ( $ header . $ data ) ; }
4785	function offsetExists ( $ key ) { $ this -> access ( $ key ) ; $ return = array_key_exists ( $ key , $ this -> row ) ; if ( ! $ return ) { $ this -> access ( $ key , true ) ; } return $ return ; }
8025	public function addFree ( ProcessDetails $ processDetails ) { $ pid = $ processDetails -> getPid ( ) ; $ this -> processDetails [ $ pid ] = $ processDetails ; $ this -> sockets [ $ pid ] = $ processDetails -> getSocket ( ) ; $ this -> registerFreeProcess ( $ processDetails ) ; return $ this ; }
2640	public function cleanUrl ( $ url ) { $ result = $ this -> _purge ( $ url , 'PURGE' , 'PURGE' ) ; if ( $ result [ 'status' ] ) { $ this -> logger -> execute ( $ url ) ; } if ( $ this -> config -> areWebHooksEnabled ( ) && $ this -> config -> canPublishKeyUrlChanges ( ) ) { $ this -> sendWebHook ( '*clean by URL for* ' . $ url ) ; } return $ result ; }
7634	public function putBlockList ( $ containerName = '' , $ blobName = '' , $ blockList = array ( ) , $ metadata = array ( ) , $ leaseId = null , $ additionalHeaders = array ( ) ) { Assertion :: notEmpty ( $ containerName , 'Container name is not specified' ) ; self :: assertValidContainerName ( $ containerName ) ; Assertion :: notEmpty ( $ blobName , 'Blob name is not specified.' ) ; Assertion :: notEmpty ( $ blockList , 'Block list does not contain any elements.' ) ; self :: assertValidRootContainerBlobName ( $ containerName , $ blobName ) ; $ blocks = '' ; foreach ( $ blockList as $ block ) { $ blocks .= ' <Latest>' . base64_encode ( $ block ) . '</Latest>' . "\n" ; } $ fileContents = utf8_encode ( implode ( "\n" , array ( '<?xml version="1.0" encoding="utf-8"?>' , '<BlockList>' , $ blocks , '</BlockList>' ) ) ) ; $ headers = array ( ) ; if ( ! is_null ( $ leaseId ) ) { $ headers [ 'x-ms-lease-id' ] = $ leaseId ; } $ headers = array_merge ( $ headers , $ this -> generateMetadataHeaders ( $ metadata ) ) ; foreach ( $ additionalHeaders as $ key => $ value ) { $ headers [ $ key ] = $ value ; } $ resourceName = self :: createResourceName ( $ containerName , $ blobName ) ; $ response = $ this -> performRequest ( $ resourceName , array ( 'comp' => 'blocklist' ) , 'PUT' , $ headers , false , $ fileContents , self :: RESOURCE_BLOB , self :: PERMISSION_WRITE ) ; if ( ! $ response -> isSuccessful ( ) ) { throw new BlobException ( $ this -> getErrorMessage ( $ response , 'Resource could not be accessed.' ) ) ; } }
4964	public function addViewVariables ( $ name , $ data = [ ] , $ priority = 0 ) { if ( is_array ( $ name ) ) { if ( ! isset ( $ name [ 'name' ] ) ) { throw new \ DomainException ( 'Key "name" must be specified, if array is passed as first parameter.' ) ; } if ( is_int ( $ data ) ) { $ priority = $ data ; } $ data = $ name ; $ name = $ data [ 'name' ] ; } elseif ( is_int ( $ data ) ) { $ priority = $ data ; $ data = [ ] ; } if ( ! isset ( $ data [ 'name' ] ) ) { $ data [ 'name' ] = $ name ; } return $ this -> addViewTemplate ( $ name , "core/admin/dashboard-widget" , $ data , $ priority ) ; }
1442	protected function replaceRecord ( & $ stub ) { $ resource = $ this -> getResourceName ( ) ; $ stub = str_replace ( 'DummyRecord' , Str :: classify ( str_singular ( $ resource ) ) , $ stub ) ; return $ this ; }
4463	private function handleProcessExitStatus ( int $ pid , int $ childType , int $ exitStatus ) { switch ( $ childType ) { case self :: PROCESS_TYPE_JOB : $ childType = 'Child' ; break ; default : $ childType = 'Watchdog' ; } if ( $ exitStatus === 0 ) { $ this -> logger -> debug ( "{type}: {$childType} process exited successfully" , $ this -> logContext ) ; return false ; } $ error = $ this -> readErrorFromSocket ( $ this -> sockets [ $ pid ] ) ; $ jobFailedMessage = $ error ? : "{$childType} process failed with status: {$exitStatus}" ; $ this -> logger -> error ( "{type}: fatal error in {$childType} process: {$jobFailedMessage}" , $ this -> logContext ) ; return $ jobFailedMessage ; }
8463	public static function getProtocol ( $ url = false ) { if ( $ url ) { return ( preg_match ( '/^https/' , $ url ) ) ? 'https' : 'http' ; } $ protocol = strtolower ( $ _SERVER [ 'SERVER_PROTOCOL' ] ) ; $ protocol = substr ( $ protocol , 0 , strpos ( $ protocol , '/' ) ) ; $ ssl = ( isset ( $ _SERVER [ 'HTTPS' ] ) && $ _SERVER [ 'HTTPS' ] == 'on' ) ; return ( $ ssl ) ? $ protocol . 's' : $ protocol ; }
9403	public static function get ( ContainerInterface $ container , array $ components = array ( ) , & $ globals = null ) { $ configuration = new Configuration ; $ collection = new Collection ; foreach ( ( array ) $ components as $ component ) { $ instance = self :: prepare ( $ collection , $ component ) ; $ container = $ instance -> define ( $ container , $ configuration ) ; } $ collection -> setContainer ( $ container ) ; $ globals === null || $ globals [ 'container' ] = $ container ; return $ collection ; }
8616	public function setId ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'Id' ] [ 'FieldValue' ] = $ value ; return $ this ; }
7809	public static function toDebugReport ( ) { $ report = 'PHP SDK (zipMoney) Debug Report:' . PHP_EOL ; $ report .= ' OS: ' . php_uname ( ) . PHP_EOL ; $ report .= ' PHP Version: ' . phpversion ( ) . PHP_EOL ; $ report .= ' OpenAPI Spec Version: 2017-03-01' . PHP_EOL ; $ report .= ' Temp Folder Path: ' . self :: getDefaultConfiguration ( ) -> getTempFolderPath ( ) . PHP_EOL ; return $ report ; }
12738	public function addClass ( $ name ) { $ classParts = explode ( ' ' , $ this -> tags [ 'class' ] ) ; foreach ( $ classParts as $ part ) { if ( $ name == $ part ) return ; } $ this -> tags [ 'class' ] .= ' ' . $ name ; $ this -> tags [ 'class' ] = trim ( $ this -> tags [ 'class' ] ) ; }
11374	private function getInjectHint ( \ ReflectionMethod $ method , \ ReflectionParameter $ parameter ) { $ hint = Psi :: it ( $ this -> reader -> getMethodAnnotations ( $ method ) ) -> filter ( new IsInstanceOf ( Di \ DiInjectHintAnnotation :: class ) ) -> filter ( function ( Di \ DiInjectHintAnnotation $ i ) use ( $ parameter ) { return $ i -> getParameter ( ) === $ parameter -> getName ( ) ; } ) -> getFirst ( ) ; if ( $ hint !== null ) { return $ hint ; } try { if ( $ parameter -> getClass ( ) === null ) { throw new \ InvalidArgumentException ( "Cannot inject constructor-param '{$parameter->getName()}' into {$method->getDeclaringClass()->getName()}. " . 'The parameter does not have a an @Inject hint and it has no type-hint.' ) ; } } catch ( \ ReflectionException $ e ) { } return Di \ Inject \ ByType :: create ( $ parameter -> getName ( ) , Util :: normalizeFqcn ( ( string ) $ parameter -> getType ( ) ) ) ; }
9995	private function writeComment ( Worksheet $ pSheet , $ coordinate ) { $ result = '' ; if ( ! $ this -> isPdf && isset ( $ pSheet -> getComments ( ) [ $ coordinate ] ) ) { $ result .= '<a class="comment-indicator"></a>' ; $ result .= '<div class="comment">' . nl2br ( $ pSheet -> getComment ( $ coordinate ) -> getText ( ) -> getPlainText ( ) ) . '</div>' ; $ result .= PHP_EOL ; } return $ result ; }
2487	protected function search ( array $ parameters ) { $ queryString = $ this -> generateQueryString ( $ parameters ) ; $ response = $ this -> client -> request ( 'POST' , $ this -> endpointRegistry -> getEndpoint ( $ this -> endpointResolver -> getEntryEndpoint ( ) ) , '/select' , new Message ( [ 'Content-Type' => 'application/x-www-form-urlencoded' , ] , $ queryString ) ) ; $ result = json_decode ( $ response -> body ) ; if ( ! isset ( $ result -> response ) ) { throw new RuntimeException ( '->response not set: ' . var_export ( array ( $ result , $ parameters ) , true ) ) ; } return $ result ; }
8284	protected function init ( ) { $ this -> loadModules ( ) ; $ this -> session = $ this -> container -> get ( 'session' ) ; $ this -> csrf = new CSRF ( $ this -> session ) ; $ this -> user = $ this -> getUserFromSession ( ) ; $ this -> request = Request :: createFromGlobals ( ) ; $ this -> sessionTimeoutCheck ( "sessionInterval" , "_migT" , false ) ; $ this -> sessionTimeoutCheck ( "sessionTimeout" , "_start" , true ) ; $ this -> sessionTimeoutCheck ( "sessionIdle" , "_idle" , true , true ) ; }
11130	protected function matchTemplate ( & $ template , array & $ arguments ) { $ count = substr_count ( $ template , '%s' ) ; $ size = sizeof ( $ arguments ) ; if ( $ count > $ size ) { $ arguments = $ arguments + array_fill ( $ size , $ count - $ size , '' ) ; } else { $ template .= str_repeat ( ' %s' , $ size - $ count ) ; } return $ this ; }
7183	protected function updateExchangeRate ( PaymentInterface $ payment ) { if ( null !== $ payment -> getExchangeRate ( ) ) { return false ; } $ date = new \ DateTime ( ) ; $ rate = $ this -> currencyConverter -> getRate ( $ this -> currencyConverter -> getDefaultCurrency ( ) , $ payment -> getCurrency ( ) -> getCode ( ) , $ date ) ; $ payment -> setExchangeRate ( $ rate ) -> setExchangeDate ( $ date ) ; return true ; }
11928	public function getDataInterface ( ) { if ( ! $ this -> started ) { return $ this -> _interface ; } if ( is_null ( $ this -> _interface ) ) { $ interfaces = ArrayHelper :: map ( Yii :: $ app -> collectors [ 'dataInterfaces' ] -> getAll ( ) , 'systemId' , 'object.name' ) ; $ this -> dataInterface = $ this -> select ( "Choose interface" , $ interfaces ) ; } return $ this -> _interface ; }
12537	public function setRelatedObjects ( $ relatedObjects ) { foreach ( $ relatedObjects as $ modelName => $ objects ) { if ( ! isset ( $ this -> _relatedObjects [ $ modelName ] ) ) { $ this -> _relatedObjects [ $ modelName ] = [ ] ; } foreach ( $ objects as $ tabId => $ objectAttributes ) { if ( ! isset ( $ objectAttributes [ '_moduleHandler' ] ) ) { continue ; } list ( $ relationship , $ role ) = $ this -> owner -> objectType -> getRelationship ( $ objectAttributes [ '_moduleHandler' ] ) ; $ relatedHandler = $ this -> owner -> objectType -> getRelatedType ( $ objectAttributes [ '_moduleHandler' ] ) ; if ( ! $ relatedHandler ) { continue ; } $ objectAttributes = array_merge ( [ 'companionObject' => $ this -> owner , 'companionRelationship' => $ relationship , 'companionRole' => $ role , ] , $ objectAttributes ) ; $ object = $ relatedHandler -> getModel ( null , $ objectAttributes ) ; $ object -> tabularId = $ objectAttributes [ '_moduleHandler' ] ; if ( ( ! $ object || $ object -> isEmptyObject ( ) ) && ! ( $ relationship -> required ) ) { continue ; } $ object -> companionObject = $ object -> indirectObject = $ this -> owner ; $ object -> companionRelationship = $ relationship ; $ object -> companionRole = $ role ; $ this -> _relatedObjects [ $ modelName ] [ $ tabId ] = $ object ; $ this -> _relatedObjectsFlat [ ] = $ object ; } } }
11510	public static function parse ( $ program ) { $ i = 0 ; $ len = strlen ( $ program ) ; $ forms = [ ] ; while ( $ i < $ len ) { if ( strpos ( self :: WHITESPACES , $ program [ $ i ] ) === false ) { try { $ form = self :: parseExpression ( substr ( $ program , $ i ) , $ offset ) ; if ( ! is_null ( $ form ) ) $ forms [ ] = $ form ; } catch ( ParseException $ e ) { throw new ParseException ( $ program , $ e -> offset + $ i ) ; } $ i += $ offset ; } else ++ $ i ; } return $ forms ; }
10514	private function updateObserverState ( \ StdClass $ observer ) { $ this -> event -> function = $ observer -> function ; $ observerObject = $ observer -> observer ; $ observerObject -> update ( $ this ) ; }
3979	private function createCommand ( CommandCollectionInterface $ collection , $ operationName , $ queryParameters , $ icon , $ extraValues = [ ] ) { $ command = $ this -> getCommandInstance ( $ collection , $ operationName ) ; $ parameters = $ command -> getParameters ( ) ; foreach ( $ queryParameters as $ name => $ value ) { if ( ! isset ( $ parameters [ $ name ] ) ) { $ parameters [ $ name ] = $ value ; } } if ( ! $ command -> getLabel ( ) ) { $ command -> setLabel ( $ operationName . '.0' ) ; if ( isset ( $ extraValues [ 'label' ] ) ) { $ command -> setLabel ( $ extraValues [ 'label' ] ) ; } } if ( ! $ command -> getDescription ( ) ) { $ command -> setDescription ( $ operationName . '.1' ) ; if ( isset ( $ extraValues [ 'description' ] ) ) { $ command -> setDescription ( $ extraValues [ 'description' ] ) ; } } $ extra = $ command -> getExtra ( ) ; $ extra [ 'icon' ] = $ icon ; foreach ( $ extraValues as $ name => $ value ) { if ( ! isset ( $ extra [ $ name ] ) ) { $ extra [ $ name ] = $ value ; } } }
2514	public function setConsumerId ( $ id ) { $ this -> sessionHandler -> setTransactionFlowLink ( true ) ; $ this -> sessionHandler -> setConsumerId ( $ id ) ; }
8351	protected function toSqlLevel ( array $ tree ) : string { if ( count ( $ tree ) == 0 ) { return '' ; } $ sql = '(' ; reset ( $ tree ) ; if ( is_numeric ( key ( $ tree ) ) === true ) { foreach ( $ tree as $ elem ) { $ sql .= $ elem . ' AND ' ; } $ sql = substr ( $ sql , 0 , - 5 ) ; } elseif ( key ( $ tree ) === 'OR' ) { foreach ( $ tree as $ value ) { if ( is_array ( $ value ) === true ) { $ sql .= $ this -> toSqlLevel ( $ value ) ; } else { $ sql .= $ value ; } $ sql .= ' OR ' ; } $ sql = substr ( $ sql , 0 , - 4 ) ; } elseif ( key ( $ tree ) === 'AND' ) { foreach ( $ tree as $ value ) { if ( is_array ( $ value ) === true ) { $ sql .= $ this -> toSqlLevel ( $ value ) ; } else { $ sql .= $ value ; } $ sql .= ' AND ' ; } $ sql = substr ( $ sql , 0 , - 5 ) ; } else { foreach ( $ tree as $ key => $ value ) { $ sql .= $ key . ' = ' . $ value . ' AND ' ; } $ sql = substr ( $ sql , 0 , - 5 ) ; } $ sql .= ')' ; return $ sql ; }
2228	public function addBreadcrumb ( ) { $ objSessionBag = Contao \ System :: getContainer ( ) -> get ( 'session' ) -> getBag ( 'contao_backend' ) ; if ( isset ( $ _GET [ 'fn' ] ) ) { if ( Contao \ Validator :: isInsecurePath ( Contao \ Input :: get ( 'fn' , true ) ) ) { throw new RuntimeException ( 'Insecure path ' . Contao \ Input :: get ( 'fn' , true ) ) ; } $ objSessionBag -> set ( 'tl_templates_node' , Contao \ Input :: get ( 'fn' , true ) ) ; $ this -> redirect ( preg_replace ( '/(&|\?)fn=[^&]*/' , '' , Contao \ Environment :: get ( 'request' ) ) ) ; } $ strNode = $ objSessionBag -> get ( 'tl_templates_node' ) ; if ( $ strNode == '' ) { return ; } if ( Contao \ Validator :: isInsecurePath ( $ strNode ) ) { throw new RuntimeException ( 'Insecure path ' . $ strNode ) ; } $ rootDir = Contao \ System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( ! is_dir ( $ rootDir . '/' . $ strNode ) ) { $ objSessionBag -> set ( 'tl_templates_node' , '' ) ; return ; } $ strPath = 'templates' ; $ arrNodes = explode ( '/' , preg_replace ( '/^templates\//' , '' , $ strNode ) ) ; $ arrLinks = array ( ) ; $ arrLinks [ ] = Contao \ Image :: getHtml ( 'filemounts.svg' ) . ' <a href="' . $ this -> addToUrl ( 'fn=' ) . '" title="' . Contao \ StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'selectAllNodes' ] ) . '">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'filterAll' ] . '</a>' ; foreach ( $ arrNodes as $ strFolder ) { $ strPath .= '/' . $ strFolder ; if ( $ strFolder == basename ( $ strNode ) ) { $ arrLinks [ ] = Contao \ Image :: getHtml ( 'folderC.svg' ) . ' ' . $ strFolder ; } else { $ arrLinks [ ] = Contao \ Image :: getHtml ( 'folderC.svg' ) . ' <a href="' . $ this -> addToUrl ( 'fn=' . $ strPath ) . '" title="' . Contao \ StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'selectNode' ] ) . '">' . $ strFolder . '</a>' ; } } $ GLOBALS [ 'TL_DCA' ] [ 'tl_templates' ] [ 'list' ] [ 'sorting' ] [ 'root' ] = array ( $ strNode ) ; $ GLOBALS [ 'TL_DCA' ] [ 'tl_templates' ] [ 'list' ] [ 'sorting' ] [ 'breadcrumb' ] .= '<nav aria-label="' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'breadcrumbMenu' ] . '"> <ul id="tl_breadcrumb"> <li>' . implode ( '  </li><li>', $ r rLinks) . ' /li> </ul></nav>' ; }
7405	public function assign ( $ in ) { $ this -> _massageBlockInput ( $ in ) ; $ this -> _container = [ ] ; foreach ( $ in as $ k => $ v ) { $ this -> offsetSet ( $ k , $ v ) ; } }
5439	public function addPattern ( $ pattern , $ mode = 'accept' ) { if ( ! isset ( $ this -> regexes [ $ mode ] ) ) { $ this -> regexes [ $ mode ] = new ParallelRegex ( $ this -> case ) ; } $ this -> regexes [ $ mode ] -> addPattern ( $ pattern ) ; if ( ! isset ( $ this -> mode_handlers [ $ mode ] ) ) { $ this -> mode_handlers [ $ mode ] = $ mode ; } }
9049	private function renderButtons ( $ rendered , $ buttons ) { foreach ( $ buttons as $ button ) { if ( ! isset ( $ button [ 'name' ] ) ) { throw new ControlException ( "Button must have at least a name!" ) ; } $ buttonType = isset ( $ button [ 'type' ] ) ? $ button [ 'type' ] : "submit" ; $ id = isset ( $ button [ 'id' ] ) ? $ button [ 'id' ] : $ button [ 'name' ] ; $ class = isset ( $ button [ 'class' ] ) ? $ button [ 'class' ] : $ button [ 'name' ] ; $ label = isset ( $ button [ 'label' ] ) ? $ button [ 'label' ] : $ button [ 'name' ] ; $ rendered .= sprintf ( '<button type="%s" id="%s" class="%s" name="%s">%s</button>' , $ buttonType , $ id , $ class , $ button [ 'name' ] , $ label ) ; } return $ rendered ; }
1714	public static function getInstance ( ) { if ( static :: $ objInstance !== null ) { return static :: $ objInstance ; } $ objToken = System :: getContainer ( ) -> get ( 'security.token_storage' ) -> getToken ( ) ; if ( $ objToken !== null && is_a ( $ objToken -> getUser ( ) , static :: class ) ) { return $ objToken -> getUser ( ) ; } $ strUser = System :: getContainer ( ) -> get ( 'contao.security.token_checker' ) -> getBackendUsername ( ) ; if ( $ strUser !== null ) { static :: $ objInstance = static :: loadUserByUsername ( $ strUser ) ; return static :: $ objInstance ; } return parent :: getInstance ( ) ; }
726	public function getAttribute ( $ attribute ) { try { return parent :: getAttribute ( $ attribute ) ; } catch ( \ PDOException $ e ) { switch ( $ attribute ) { case self :: ATTR_SERVER_VERSION : return $ this -> query ( "SELECT CAST(SERVERPROPERTY('productversion') AS VARCHAR)" ) -> fetchColumn ( ) ; default : throw $ e ; } } }
7770	public function errors ( ) { $ messages = [ ] ; foreach ( $ this -> errors as $ rule => $ items ) { foreach ( $ items as $ item ) { $ field = $ item [ 'field' ] ; $ message = $ this -> fetchMessage ( $ field , $ rule ) ; if ( isset ( $ this -> fieldAliases [ $ field ] ) ) { $ item [ 'field' ] = $ this -> fieldAliases [ $ field ] ; } $ messages [ $ field ] [ ] = $ this -> replaceMessageFormat ( $ message , $ item ) ; } } return new MessageBag ( $ messages ) ; }
3710	protected function getFilters ( ) { $ filterOptions = $ this -> getFrontendFilterOptions ( ) ; $ jumpToInformation = $ this -> objFilterConfig -> getJumpTo ( ) ; $ filterSetting = $ this -> objFilterConfig -> getFilterCollection ( ) ; $ wantedNames = $ this -> getWantedNames ( ) ; $ this -> buildParameters ( $ other = new FilterUrl ( $ jumpToInformation ) , $ all = new FilterUrl ( $ jumpToInformation ) , $ wantedNames ) ; foreach ( $ wantedNames as $ name ) { if ( $ all -> hasSlug ( $ name ) ) { Input :: get ( $ name ) ; } } $ arrWidgets = $ filterSetting -> getParameterFilterWidgets ( $ all -> getSlugParameters ( ) , $ jumpToInformation , $ filterOptions ) ; if ( Input :: post ( 'FORM_SUBMIT' ) === $ this -> formId ) { foreach ( $ wantedNames as $ widgetName ) { $ filter = $ arrWidgets [ $ widgetName ] ; if ( null !== $ filter [ 'urlvalue' ] ) { $ other -> setSlug ( $ widgetName , $ filter [ 'urlvalue' ] ) ; } } throw new RedirectResponseException ( $ this -> filterUrlBuilder -> generate ( $ other ) ) ; } $ renderedWidgets = [ ] ; foreach ( $ wantedNames as $ strWidget ) { $ renderedWidgets [ $ strWidget ] = $ this -> renderWidget ( $ arrWidgets [ $ strWidget ] , $ filterOptions ) ; } return [ 'action' => $ this -> filterUrlBuilder -> generate ( $ other ) , 'formid' => $ this -> formId , 'filters' => $ renderedWidgets , 'submit' => ( $ filterOptions -> isAutoSubmit ( ) ? '' : $ GLOBALS [ 'TL_LANG' ] [ 'metamodels_frontendfilter' ] [ 'submit' ] ) ] ; }
8225	public function handleRegistration ( Request $ httpRequest ) { if ( ! $ this -> config [ "enabled" ] ) { return ; } $ user = $ this -> picoAuth -> getUser ( ) ; if ( $ user -> getAuthenticated ( ) ) { $ this -> picoAuth -> redirectToPage ( "index" ) ; } $ this -> picoAuth -> addAllowed ( "register" ) ; $ this -> picoAuth -> setRequestFile ( $ this -> picoAuth -> getPluginPath ( ) . '/content/register.md' ) ; $ post = $ httpRequest -> request ; if ( $ post -> has ( "username" ) && $ post -> has ( "email" ) && $ post -> has ( "password" ) && $ post -> has ( "password_repeat" ) ) { if ( ! $ this -> picoAuth -> isValidCSRF ( $ post -> get ( "csrf_token" ) , self :: REGISTER_CSRF_ACTION ) ) { $ this -> picoAuth -> redirectToPage ( "register" ) ; } $ this -> assertLimits ( ) ; $ reg = array ( "username" => strtolower ( trim ( $ post -> get ( "username" ) ) ) , "email" => trim ( $ post -> get ( "email" ) ) , "password" => new Password ( $ post -> get ( "password" ) ) , "passwordRepeat" => new Password ( $ post -> get ( "password_repeat" ) ) , ) ; $ isValid = $ this -> validateRegistration ( $ reg ) ; if ( $ isValid ) { if ( ! $ this -> limit -> action ( "registration" ) ) { $ this -> session -> addFlash ( "error" , $ this -> limit -> getError ( ) ) ; $ this -> picoAuth -> redirectToPage ( "register" ) ; } $ this -> logSuccessfulRegistration ( $ reg ) ; $ userData = array ( 'email' => $ reg [ "email" ] ) ; $ localAuth = $ this -> picoAuth -> getContainer ( ) -> get ( 'LocalAuth' ) ; $ localAuth -> userDataEncodePassword ( $ userData , $ reg [ "password" ] ) ; $ this -> storage -> saveUser ( $ reg [ "username" ] , $ userData ) ; $ this -> session -> addFlash ( "success" , "Registration completed successfully, you can now log in." ) ; $ this -> picoAuth -> redirectToLogin ( ) ; } else { $ this -> session -> addFlash ( "old" , array ( 'username' => $ reg [ "username" ] , 'email' => $ reg [ "email" ] ) ) ; $ this -> picoAuth -> redirectToPage ( "register" ) ; } } }
8609	private function _convertRegisterDestination ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'RegisterDestination' ; if ( $ request -> isSetSellerId ( ) ) { $ parameters [ 'SellerId' ] = $ request -> getSellerId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } if ( $ request -> isSetMarketplaceId ( ) ) { $ parameters [ 'MarketplaceId' ] = $ request -> getMarketplaceId ( ) ; } if ( $ request -> isSetDestination ( ) ) { $ DestinationRegisterDestinationInput = $ request -> getDestination ( ) ; foreach ( $ DestinationRegisterDestinationInput -> getDeliveryChannel ( ) as $ DeliveryChannelDestinationIndex => $ DeliveryChannelDestination ) { $ parameters [ 'Destination' . '.' . 'DeliveryChannel' . '.' . ( $ DeliveryChannelDestinationIndex + 1 ) ] = $ DeliveryChannelDestination ; } } return $ parameters ; }
3774	public function getTypeNames ( ) { $ names = $ this -> factories -> ids ( ) ; if ( [ ] !== $ fallback = $ this -> fallbackFactory -> getIds ( ) ) { $ names = array_unique ( array_merge ( $ fallback , $ names ) ) ; } return $ names ; }
12877	public function generateAndroidManifest ( ) { $ pinicon = $ this -> owner -> AndroidPinicon ( ) ; if ( $ pinicon -> exists ( ) ) { $ manifest = new stdClass ( ) ; $ manifest -> name = $ this -> owner -> PiniconTitle ; $ manifest -> icons = array ( ) ; array_push ( $ manifest -> icons , array ( 'src' => $ pinicon -> Fill ( 36 , 36 ) -> getAbsoluteURL ( ) , 'sizes' => '36x36' , 'type' => 'image/png' , 'density' => 0.75 ) ) ; array_push ( $ manifest -> icons , array ( 'src' => $ pinicon -> Fill ( 48 , 48 ) -> getAbsoluteURL ( ) , 'sizes' => '48x48' , 'type' => 'image/png' , 'density' => 1 ) ) ; array_push ( $ manifest -> icons , array ( 'src' => $ pinicon -> Fill ( 72 , 72 ) -> getAbsoluteURL ( ) , 'sizes' => '72x72' , 'type' => 'image/png' , 'density' => 1.5 ) ) ; array_push ( $ manifest -> icons , array ( 'src' => $ pinicon -> Fill ( 96 , 96 ) -> getAbsoluteURL ( ) , 'sizes' => '96x96' , 'type' => 'image/png' , 'density' => 2 ) ) ; array_push ( $ manifest -> icons , array ( 'src' => $ pinicon -> Fill ( 144 , 144 ) -> getAbsoluteURL ( ) , 'sizes' => '144x144' , 'type' => 'image/png' , 'density' => 3 ) ) ; array_push ( $ manifest -> icons , array ( 'src' => $ pinicon -> Fill ( 192 , 192 ) -> getAbsoluteURL ( ) , 'sizes' => '192x192' , 'type' => 'image/png' , 'density' => 4 ) ) ; $ bytes = file_put_contents ( Director :: baseFolder ( ) . '/manifest.json' , json_encode ( $ manifest ) ) ; if ( $ bytes !== false ) { return true ; } } return false ; }
3615	public function setEcoTemperatures ( $ temp_low , $ temp_high , $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ temp_low = $ this -> temperatureInCelsius ( $ temp_low , $ serial_number ) ; $ temp_high = $ this -> temperatureInCelsius ( $ temp_high , $ serial_number ) ; $ data = array ( ) ; if ( $ temp_low === FALSE ) { $ data [ 'away_temperature_low_enabled' ] = FALSE ; } elseif ( $ temp_low != NULL ) { $ data [ 'away_temperature_low_enabled' ] = TRUE ; $ data [ 'away_temperature_low' ] = $ temp_low ; } if ( $ temp_high === FALSE ) { $ data [ 'away_temperature_high_enabled' ] = FALSE ; } elseif ( $ temp_high != NULL ) { $ data [ 'away_temperature_high_enabled' ] = TRUE ; $ data [ 'away_temperature_high' ] = $ temp_high ; } $ data = json_encode ( $ data ) ; return $ this -> doPOST ( "/v2/put/device." . $ serial_number , $ data ) ; }
4064	private static function calculateDiff ( $ expected , $ actual , $ strict ) { if ( $ expected === $ actual ) { return ; } if ( gettype ( $ expected ) !== gettype ( $ actual ) ) { if ( ! $ strict && self :: isEmptyArrayEquivalent ( $ expected , $ actual ) ) { return ; } throw new \ LogicException ( sprintf ( 'Encountered type %s expected %s (Found %s, expected %s)' , gettype ( $ actual ) , gettype ( $ expected ) , var_export ( $ actual , true ) , var_export ( $ expected , true ) ) , self :: TYPE_MISMATCH ) ; } if ( is_array ( $ expected ) ) { self :: calculateArrayDiff ( $ expected , $ actual , $ strict ) ; } throw new \ LogicException ( sprintf ( 'Found %s expected %s' , var_export ( $ actual , true ) , var_export ( $ expected , true ) ) , self :: VALUE_MISMATCH ) ; }
6646	public function authenticate ( ) { $ request_token = $ this -> oauth -> getRequestToken ( $ this -> settings , $ this -> consumer , $ this -> token ) ; $ auth_url = $ this -> settings ( 'auth_api_url' ) . $ this -> settings ( 'authentication_uri' ) ; $ auth_url .= '?' . http_build_query ( [ 'oauth_token' => $ request_token -> key ] ) ; return $ this -> redirect -> to ( $ auth_url ) ; }
4106	public function commitBulk ( ) { if ( $ this -> bulk && $ this -> bulk -> count ( ) ) { $ result = $ this -> bulk -> commit ( ) ; $ this -> bulk = null ; return $ result ; } }
3827	protected function getFrontendFilterValue ( $ arrWidget , $ arrFilterUrl , $ strKeyOption ) { if ( $ this -> isActiveFrontendFilterValue ( $ arrWidget , $ arrFilterUrl , $ strKeyOption ) ) { return '' ; } return $ strKeyOption ; }
10523	protected function getDepDropParents ( $ post = 'depdrop_parents' ) { $ parents = Yii :: $ app -> request -> post ( $ post ) ; $ filteredParents = [ ] ; foreach ( $ parents as $ key => $ parent ) { if ( is_numeric ( $ parent ) ) { $ filteredParents [ $ key ] = $ parent ; } else { return [ ] ; } } return $ filteredParents ; }
8718	public static function forceCreateInLocale ( $ locale , array $ attributes , $ translations = [ ] ) { $ model = new static ; return static :: unguarded ( function ( ) use ( $ locale , $ model , $ attributes , $ translations ) { return $ model -> createInLocale ( $ locale , $ attributes , $ translations ) ; } ) ; }
10216	public function addFromSource ( array $ pSource = null ) { if ( $ pSource == null ) { return ; } foreach ( $ pSource as $ item ) { $ this -> add ( $ item ) ; } }
10152	private function readHcenter ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; if ( ! $ this -> readDataOnly ) { $ isHorizontalCentered = ( bool ) self :: getUInt2d ( $ recordData , 0 ) ; $ this -> phpSheet -> getPageSetup ( ) -> setHorizontalCentered ( $ isHorizontalCentered ) ; } }
3003	public function attachFile ( $ path , $ alias = null , $ cid = null ) { $ this -> smtp -> attach ( $ path , $ alias , $ cid ) ; }
9318	public function rotate ( $ angle , $ background = 'FFFFFF' ) { $ angle = intval ( $ angle ) ; if ( ! is_int ( $ angle ) || ( $ angle < 0 ) || ( $ angle > 360 ) ) { throw new ezcBaseValueException ( 'height' , $ height , 'angle < 0 or angle > 360' ) ; } $ angle = 360 - $ angle ; $ background = "#{$background}" ; $ this -> addFilterOption ( $ this -> getActiveReference ( ) , '-background' , $ background ) ; $ this -> addFilterOption ( $ this -> getActiveReference ( ) , '-rotate' , $ angle ) ; }
8483	public static function getKernelVersion ( ) { $ wmi = Windows :: getInstance ( ) ; foreach ( $ wmi -> ExecQuery ( "SELECT WindowsVersion FROM Win32_Process WHERE Handle = 0" ) as $ process ) { return $ process -> WindowsVersion ; } return "Unknown" ; }
5	private function buildDepPackageConstraints ( $ depItem , $ depType ) { if ( $ this -> isHash ( $ depItem ) ) { $ depItem = array ( $ depItem ) ; } $ result = array ( ) ; foreach ( $ depItem as $ subDepItem ) { if ( ! array_key_exists ( 'channel' , $ subDepItem ) ) { $ subDepItem [ 'channel' ] = $ subDepItem [ 'uri' ] ; } $ depChannelName = $ subDepItem [ 'channel' ] ; $ depPackageName = $ subDepItem [ 'name' ] ; $ depVersionConstraint = $ this -> parse20VersionConstraint ( $ subDepItem ) ; if ( isset ( $ subDepItem [ 'conflicts' ] ) ) { $ depType = 'conflicts' ; } $ result [ ] = new DependencyConstraint ( $ depType , $ depVersionConstraint , $ depChannelName , $ depPackageName ) ; } return $ result ; }
6104	public function wait ( ) { if ( $ this -> getTransport ( ) -> getConfig ( "blocking" ) ) { throw new Ts3Exception ( "only available in non-blocking mode" ) ; } do { $ evt = $ this -> getTransport ( ) -> readLine ( ) ; var_dump ( $ evt ) ; } while ( $ evt instanceof StringHelper && ! $ evt -> section ( TeamSpeak3 :: SEPARATOR_CELL ) -> startsWith ( TeamSpeak3 :: EVENT ) ) ; return new Event ( $ evt , $ this -> getHost ( ) ) ; }
12630	public function pay ( Order $ order ) { return $ this -> request ( $ this -> wrapApi ( self :: API_PAY_ORDER ) , $ order -> all ( ) ) ; }
9295	public function buildCustomFields ( $ form_fields = [ ] , $ config_name = 'custom_form' ) { $ fields = collect ( $ form_fields ) -> map ( function ( $ field , $ name ) use ( $ config_name ) { return $ this -> render ( isset ( $ field [ 'type' ] ) ? $ field [ 'type' ] : 'text' , [ $ name , $ field [ 'label' ] , [ 'data-table' => $ config_name ] ] ) ; } ) ; return $ fields ; }
2480	protected function mapSearchFieldValue ( $ value , FieldType $ searchFieldType = null ) { if ( null === $ searchFieldType ) { return $ value ; } $ searchField = new SearchField ( 'field' , $ value , $ searchFieldType ) ; $ value = ( array ) $ this -> fieldValueMapper -> map ( $ searchField ) ; return current ( $ value ) ; }
1694	public function exportStyleSheet ( DataContainer $ dc ) { $ objStyleSheet = $ this -> Database -> prepare ( "SELECT * FROM tl_style_sheet WHERE id=?" ) -> limit ( 1 ) -> execute ( $ dc -> id ) ; if ( $ objStyleSheet -> numRows < 1 ) { throw new \ Exception ( "Invalid style sheet ID {$dc->id}" ) ; } $ vars = array ( ) ; $ objTheme = $ this -> Database -> prepare ( "SELECT vars FROM tl_theme WHERE id=?" ) -> limit ( 1 ) -> execute ( $ objStyleSheet -> pid ) ; if ( $ objTheme -> vars != '' ) { if ( \ is_array ( ( $ tmp = StringUtil :: deserialize ( $ objTheme -> vars ) ) ) ) { foreach ( $ tmp as $ v ) { $ vars [ $ v [ 'key' ] ] = $ v [ 'value' ] ; } } } if ( $ objStyleSheet -> vars != '' ) { if ( \ is_array ( ( $ tmp = StringUtil :: deserialize ( $ objStyleSheet -> vars ) ) ) ) { foreach ( $ tmp as $ v ) { $ vars [ $ v [ 'key' ] ] = $ v [ 'value' ] ; } } } uksort ( $ vars , 'length_sort_desc' ) ; $ objFile = new File ( 'system/tmp/' . md5 ( uniqid ( mt_rand ( ) , true ) ) ) ; $ objFile -> write ( '' ) ; if ( $ objStyleSheet -> mediaQuery != '' ) { $ objFile -> append ( '@media ' . $ objStyleSheet -> mediaQuery . ' {' ) ; } $ objDefinitions = $ this -> Database -> prepare ( "SELECT * FROM tl_style WHERE pid=? AND invisible!='1' ORDER BY sorting" ) -> execute ( $ objStyleSheet -> id ) ; while ( $ objDefinitions -> next ( ) ) { $ objFile -> append ( $ this -> compileDefinition ( $ objDefinitions -> row ( ) , false , $ vars , $ objStyleSheet -> row ( ) , true ) , '' ) ; } if ( $ objStyleSheet -> mediaQuery != '' ) { $ objFile -> append ( '}' ) ; } $ objFile -> close ( ) ; $ objFile -> sendToBrowser ( $ objStyleSheet -> name . '.css' ) ; $ objFile -> delete ( ) ; }
4096	public function build ( ) { $ built = array ( ) ; if ( $ this -> fieldname ) { $ built [ $ this -> fieldname ] = array ( ) ; foreach ( array ( "from" , "to" , "includeLower" , "includeUpper" , "boost" ) as $ opt ) { if ( $ this -> $ opt !== null ) $ built [ $ this -> fieldname ] [ $ opt ] = $ this -> $ opt ; } if ( count ( $ built [ $ this -> fieldname ] ) == 0 ) throw new \ ElasticSearch \ Exception ( "Empty RangeQuery cant be created" ) ; } return $ built ; }
11545	public function changeEmail ( $ data ) { if ( ! ( $ user = $ this -> hydrate ( $ data , $ this -> getChangeEmailForm ( ) ) ) ) { return ; } $ eventManager = $ this -> getEventManager ( ) ; $ eventManager -> trigger ( __METHOD__ , $ this , $ user ) ; $ user -> setEmailConfirmed ( false ) ; $ viewModel = new ViewModel ( compact ( 'user' ) ) ; $ viewModel -> setTemplate ( 'mail-message/user-confirm-email' ) ; $ mailService = $ this -> getMailService ( ) ; $ message = $ mailService -> getMessage ( ) ; $ message -> setTo ( $ user -> getEmail ( ) , $ user -> getDisplayName ( ) ) ; $ subject = 'Please, confirm your email!' ; if ( $ this -> getTranslator ( ) && $ this -> isTranslatorEnabled ( ) ) { $ subject = $ this -> getTranslator ( ) -> translate ( $ subject , $ this -> getTranslatorTextDomain ( ) ) ; } $ message -> setSubject ( $ subject ) ; $ mailService -> setBody ( $ viewModel ) -> sendMessage ( ) ; $ this -> getMapper ( ) -> update ( $ user ) -> save ( ) ; $ eventManager -> trigger ( __METHOD__ . '.post' , $ this , $ user ) ; return $ user ; }
12298	public function onlyFillablePivot ( $ pivotRelation , $ data ) { $ fillable = $ this -> getPivotFields ( $ pivotRelation , 'pivotColumns' ) ; return array_only ( $ data , $ fillable ) ; }
10179	public function removeColumn ( $ column ) { foreach ( $ this -> getCoordinates ( ) as $ coord ) { sscanf ( $ coord , '%[A-Z]%d' , $ c , $ r ) ; if ( $ c == $ column ) { $ this -> delete ( $ coord ) ; } } }
12632	public function query ( $ orderNo , $ type = self :: OUT_TRADE_NO ) { $ params = [ $ type => $ orderNo , ] ; return $ this -> request ( $ this -> wrapApi ( self :: API_QUERY ) , $ params ) ; }
10263	public function getCreditCard ( $ weighted = true ) { if ( $ weighted ) { $ weight [ ] = [ 'American Express' , 1 ] ; $ weight [ ] = [ 'Discover' , 2 ] ; $ weight [ ] = [ 'MasterCard' , 10 ] ; $ weight [ ] = [ 'Visa' , 10 ] ; foreach ( $ weight as $ w ) { $ type = $ w [ 0 ] ; $ count = $ w [ 1 ] ; for ( $ i = 0 ; $ i < $ count ; $ i ++ ) { $ card_types [ ] = $ type ; } } } else { $ card_types = [ 'American Express' , 'Discover' , 'MasterCard' , 'Visa' ] ; } $ cc = new Entities \ CreditCard ; $ cc -> type = $ this -> fromArray ( $ card_types ) ; $ cc -> number = $ this -> getBankNumber ( $ cc -> type ) ; $ cc -> expiration = $ this -> getExpiration ( ) ; return $ cc ; }
864	private function registerFoundToken ( $ token ) { $ tokenKind = $ token instanceof Token ? ( $ token -> isArray ( ) ? $ token -> getId ( ) : $ token -> getContent ( ) ) : ( \ is_array ( $ token ) ? $ token [ 0 ] : $ token ) ; if ( ! isset ( $ this -> foundTokenKinds [ $ tokenKind ] ) ) { $ this -> foundTokenKinds [ $ tokenKind ] = 0 ; } ++ $ this -> foundTokenKinds [ $ tokenKind ] ; }
1761	protected static function readPhpFileWithoutTags ( $ strName ) { @ trigger_error ( 'Using System::readPhpFileWithoutTags() has been deprecated and will no longer work in Contao 5.0. Use the Contao\CoreBundle\Config\Loader\PhpFileLoader instead.' , E_USER_DEPRECATED ) ; $ rootDir = self :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( strpos ( $ strName , $ rootDir . '/' ) === false ) { $ strName = $ rootDir . '/' . $ strName ; } $ loader = new PhpFileLoader ( ) ; return $ loader -> load ( $ strName ) ; }
9494	private function formatSize ( $ bytes ) { $ kb = 1024 ; $ mb = $ kb * 1024 ; $ gb = $ mb * 1024 ; $ tb = $ gb * 1024 ; if ( ( $ bytes >= 0 ) && ( $ bytes < $ kb ) ) { return $ bytes . ' B' ; } elseif ( ( $ bytes >= $ kb ) && ( $ bytes < $ mb ) ) { return ceil ( $ bytes / $ kb ) . ' KB' ; } elseif ( ( $ bytes >= $ mb ) && ( $ bytes < $ gb ) ) { return ceil ( $ bytes / $ mb ) . ' MB' ; } elseif ( ( $ bytes >= $ gb ) && ( $ bytes < $ tb ) ) { return ceil ( $ bytes / $ gb ) . ' GB' ; } elseif ( $ bytes >= $ tb ) { return ceil ( $ bytes / $ tb ) . ' TB' ; } return $ bytes . ' B' ; }
10558	public function createI18n ( array $ args ) { $ i18n = new I18n ; I18nShortcut :: setInstance ( $ i18n ) ; $ modules = $ this -> app -> resolver -> getResolver ( "language" ) ; $ log = \ Wedeto \ Log \ Logger :: getLogger ( I18nPlugin :: class ) ; $ search_path = $ modules -> getSearchPath ( ) ; foreach ( $ search_path as $ name => $ path ) { $ i18n -> registerTextDomain ( $ name , $ path ) ; } $ site_language = $ this -> app -> config -> dget ( 'site' , 'default_language' , 'en' ) ; $ locale = $ args [ 'locale' ] ?? $ site_language ; $ i18n -> setLocale ( $ locale ) ; $ this -> setupTranslateLog ( ) ; return $ i18n ; }
382	public function argumentsToString ( $ args ) { $ count = 0 ; $ isAssoc = $ args !== array_values ( $ args ) ; foreach ( $ args as $ key => $ value ) { $ count ++ ; if ( $ count >= 5 ) { if ( $ count > 5 ) { unset ( $ args [ $ key ] ) ; } else { $ args [ $ key ] = '...' ; } continue ; } if ( is_object ( $ value ) ) { $ args [ $ key ] = '<span class="title">' . $ this -> htmlEncode ( get_class ( $ value ) ) . '</span>' ; } elseif ( is_bool ( $ value ) ) { $ args [ $ key ] = '<span class="keyword">' . ( $ value ? 'true' : 'false' ) . '</span>' ; } elseif ( is_string ( $ value ) ) { $ fullValue = $ this -> htmlEncode ( $ value ) ; if ( mb_strlen ( $ value , 'UTF-8' ) > 32 ) { $ displayValue = $ this -> htmlEncode ( mb_substr ( $ value , 0 , 32 , 'UTF-8' ) ) . '...' ; $ args [ $ key ] = "<span class=\"string\" title=\"$fullValue\">'$displayValue'</span>" ; } else { $ args [ $ key ] = "<span class=\"string\">'$fullValue'</span>" ; } } elseif ( is_array ( $ value ) ) { $ args [ $ key ] = '[' . $ this -> argumentsToString ( $ value ) . ']' ; } elseif ( $ value === null ) { $ args [ $ key ] = '<span class="keyword">null</span>' ; } elseif ( is_resource ( $ value ) ) { $ args [ $ key ] = '<span class="keyword">resource</span>' ; } else { $ args [ $ key ] = '<span class="number">' . $ value . '</span>' ; } if ( is_string ( $ key ) ) { $ args [ $ key ] = '<span class="string">\'' . $ this -> htmlEncode ( $ key ) . "'</span> => $args[$key]" ; } elseif ( $ isAssoc ) { $ args [ $ key ] = "<span class=\"number\">$key</span> => $args[$key]" ; } } return implode ( ', ' , $ args ) ; }
1297	private function resolveFieldLinks ( $ field , string $ locale = null ) { if ( null === $ locale ) { $ locale = null === $ this -> sys -> getLocale ( ) ? '*' : $ this -> getLocale ( ) ; } if ( $ field instanceof Link ) { return $ this -> client -> resolveLink ( $ field , $ locale ) ; } if ( \ is_array ( $ field ) && isset ( $ field [ 0 ] ) && $ field [ 0 ] instanceof Link ) { return $ this -> client -> resolveLinkCollection ( $ field , $ locale ) ; } return $ field ; }
4933	public function loadEntities ( $ entity , $ id = null ) { $ params = $ this -> options ; $ params [ 'id' ] = $ id ; $ params [ 'repositories' ] = $ this -> repositories ; $ event = $ this -> loadEntitiesEvents -> getEvent ( $ entity , $ this , $ params ) ; $ responses = $ this -> loadEntitiesEvents -> triggerEventUntil ( function ( $ response ) { return ( is_array ( $ response ) || $ response instanceof \ Traversable ) && count ( $ response ) ; } , $ event ) ; $ entities = $ responses -> last ( ) ; return $ entities ; }
10231	public function write ( Spreadsheet $ spreadsheet = null ) { if ( ! $ spreadsheet ) { $ spreadsheet = $ this -> getParentWriter ( ) -> getSpreadsheet ( ) ; } $ objWriter = null ; if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' ) ; $ objWriter -> startElement ( 'office:document-meta' ) ; $ objWriter -> writeAttribute ( 'xmlns:office' , 'urn:oasis:names:tc:opendocument:xmlns:office:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:xlink' , 'http://www.w3.org/1999/xlink' ) ; $ objWriter -> writeAttribute ( 'xmlns:dc' , 'http://purl.org/dc/elements/1.1/' ) ; $ objWriter -> writeAttribute ( 'xmlns:meta' , 'urn:oasis:names:tc:opendocument:xmlns:meta:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:ooo' , 'http://openoffice.org/2004/office' ) ; $ objWriter -> writeAttribute ( 'xmlns:grddl' , 'http://www.w3.org/2003/g/data-view#' ) ; $ objWriter -> writeAttribute ( 'office:version' , '1.2' ) ; $ objWriter -> startElement ( 'office:meta' ) ; $ objWriter -> writeElement ( 'meta:initial-creator' , $ spreadsheet -> getProperties ( ) -> getCreator ( ) ) ; $ objWriter -> writeElement ( 'dc:creator' , $ spreadsheet -> getProperties ( ) -> getCreator ( ) ) ; $ objWriter -> writeElement ( 'meta:creation-date' , date ( DATE_W3C , $ spreadsheet -> getProperties ( ) -> getCreated ( ) ) ) ; $ objWriter -> writeElement ( 'dc:date' , date ( DATE_W3C , $ spreadsheet -> getProperties ( ) -> getCreated ( ) ) ) ; $ objWriter -> writeElement ( 'dc:title' , $ spreadsheet -> getProperties ( ) -> getTitle ( ) ) ; $ objWriter -> writeElement ( 'dc:description' , $ spreadsheet -> getProperties ( ) -> getDescription ( ) ) ; $ objWriter -> writeElement ( 'dc:subject' , $ spreadsheet -> getProperties ( ) -> getSubject ( ) ) ; $ keywords = explode ( ' ' , $ spreadsheet -> getProperties ( ) -> getKeywords ( ) ) ; foreach ( $ keywords as $ keyword ) { $ objWriter -> writeElement ( 'meta:keyword' , $ keyword ) ; } $ objWriter -> startElement ( 'meta:user-defined' ) ; $ objWriter -> writeAttribute ( 'meta:name' , 'Company' ) ; $ objWriter -> writeRaw ( $ spreadsheet -> getProperties ( ) -> getCompany ( ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'meta:user-defined' ) ; $ objWriter -> writeAttribute ( 'meta:name' , 'category' ) ; $ objWriter -> writeRaw ( $ spreadsheet -> getProperties ( ) -> getCategory ( ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
1622	private function addColumn ( $ column , & $ columns ) { if ( isset ( $ columns [ $ column ] ) ) { return $ columns [ $ column ] ; } $ name = 'c' . preg_replace ( "/[^a-z]+/i" , "" , $ column ) . count ( $ columns ) ; return $ columns [ $ column ] = $ name ; }
956	public function isActiveTrial ( ) { return $ this -> isTrial ( ) && Carbon :: today ( ) -> lte ( Carbon :: parse ( $ this -> trial_ends_on ) ) ; }
440	public function canGetProperty ( $ name , $ checkVars = true , $ checkBehaviors = true ) { if ( method_exists ( $ this , 'get' . $ name ) || $ checkVars && property_exists ( $ this , $ name ) ) { return true ; } elseif ( $ checkBehaviors ) { $ this -> ensureBehaviors ( ) ; foreach ( $ this -> _behaviors as $ behavior ) { if ( $ behavior -> canGetProperty ( $ name , $ checkVars ) ) { return true ; } } } return false ; }
6628	public function get ( $ key , $ default = null ) { return ArrayHelper :: getValue ( $ this -> parsedResponse , sprintf ( '%s.%s' , self :: RESPONSE_DATA_PARAM , $ key ) , $ default ) ; }
5649	public function assign ( $ key , $ value ) { if ( $ this -> $ key === false ) { $ this -> all [ $ key ] = $ value ; } elseif ( ! is_array ( $ this -> $ key ) ) { $ this -> all [ $ key ] = array ( $ this -> $ key , $ value ) ; } else { $ this -> all [ $ key ] [ ] = $ value ; } }
6292	private function findThemeByDirectory ( $ directory ) { if ( isset ( $ this -> themes [ $ directory ] ) ) { return $ this -> themes [ $ directory ] ; } return null ; }
8368	private static function validateConfig ( array $ config ) { if ( isset ( $ config [ 'name' ] ) === false ) { throw new BadUse ( 'there\'s no name in mapping configuration' ) ; } if ( isset ( $ config [ 'schema' ] ) === false ) { throw new BadUse ( 'there\'s no schema in mapping configuration' ) ; } if ( isset ( $ config [ 'provider' ] ) === false ) { throw new BadUse ( 'there\'s no provider in mapping configuration' ) ; } if ( isset ( $ config [ 'models' ] ) === false ) { throw new BadUse ( 'there\'s no models in mapping configuration' ) ; } if ( isset ( $ config [ 'models' ] [ 'path' ] ) === false ) { throw new BadUse ( 'there\'s no models.path in mapping configuration' ) ; } if ( isset ( $ config [ 'models' ] [ 'namespace' ] ) === false ) { throw new BadUse ( 'there\'s no models.namespace in mapping configuration' ) ; } }
259	protected function findViewFile ( $ view , $ context = null ) { if ( strncmp ( $ view , '@' , 1 ) === 0 ) { $ file = Yii :: getAlias ( $ view ) ; } elseif ( strncmp ( $ view , '//' , 2 ) === 0 ) { $ file = Yii :: $ app -> getViewPath ( ) . DIRECTORY_SEPARATOR . ltrim ( $ view , '/' ) ; } elseif ( strncmp ( $ view , '/' , 1 ) === 0 ) { if ( Yii :: $ app -> controller !== null ) { $ file = Yii :: $ app -> controller -> module -> getViewPath ( ) . DIRECTORY_SEPARATOR . ltrim ( $ view , '/' ) ; } else { throw new InvalidCallException ( "Unable to locate view file for view '$view': no active controller." ) ; } } elseif ( $ context instanceof ViewContextInterface ) { $ file = $ context -> getViewPath ( ) . DIRECTORY_SEPARATOR . $ view ; } elseif ( ( $ currentViewFile = $ this -> getRequestedViewFile ( ) ) !== false ) { $ file = dirname ( $ currentViewFile ) . DIRECTORY_SEPARATOR . $ view ; } else { throw new InvalidCallException ( "Unable to resolve view file for view '$view': no active view context." ) ; } if ( pathinfo ( $ file , PATHINFO_EXTENSION ) !== '' ) { return $ file ; } $ path = $ file . '.' . $ this -> defaultExtension ; if ( $ this -> defaultExtension !== 'php' && ! is_file ( $ path ) ) { $ path = $ file . '.php' ; } return $ path ; }
1071	private function subfieldConflicts ( array $ conflicts , $ responseName , FieldNode $ ast1 , FieldNode $ ast2 ) { if ( count ( $ conflicts ) === 0 ) { return null ; } return [ [ $ responseName , array_map ( static function ( $ conflict ) { return $ conflict [ 0 ] ; } , $ conflicts ) , ] , array_reduce ( $ conflicts , static function ( $ allFields , $ conflict ) { return array_merge ( $ allFields , $ conflict [ 1 ] ) ; } , [ $ ast1 ] ) , array_reduce ( $ conflicts , static function ( $ allFields , $ conflict ) { return array_merge ( $ allFields , $ conflict [ 2 ] ) ; } , [ $ ast2 ] ) , ] ; }
6785	public function buildFormDataString ( $ options ) { $ options = $ this -> resolve ( $ options ) ; $ formOptions = [ ] ; foreach ( $ this -> formParameters as $ key => $ isFormParameter ) { if ( $ isFormParameter && isset ( $ options [ $ key ] ) ) { $ formOptions [ $ key ] = $ options [ $ key ] ; } } return http_build_query ( $ formOptions ) ; }
9795	public function setDataValidation ( DataValidation $ pDataValidation = null ) { if ( ! isset ( $ this -> parent ) ) { throw new Exception ( 'Cannot set data validation for cell that is not bound to a worksheet' ) ; } $ this -> getWorksheet ( ) -> setDataValidation ( $ this -> getCoordinate ( ) , $ pDataValidation ) ; return $ this -> updateInCollection ( ) ; }
7682	function Ext_DeductFormat ( & $ Ext , $ Search ) { if ( strpos ( ',odt,ods,odg,odf,odp,odm,ott,ots,otg,otp,' , ',' . $ Ext . ',' ) !== false ) return 'odf' ; if ( strpos ( ',docx,xlsx,xlsm,pptx,' , ',' . $ Ext . ',' ) !== false ) return 'openxml' ; if ( ! $ Search ) return false ; if ( $ this -> FileExists ( 'content.xml' ) ) { if ( $ this -> FileExists ( 'META-INF/manifest.xml' ) ) { $ Ext = '?' ; return 'odf' ; } } elseif ( $ this -> FileExists ( '[Content_Types].xml' ) ) { if ( $ this -> FileExists ( 'word/document.xml' ) ) { $ Ext = 'docx' ; return 'openxml' ; } elseif ( $ this -> FileExists ( 'xl/workbook.xml' ) ) { $ Ext = 'xlsx' ; return 'openxml' ; } elseif ( $ this -> FileExists ( 'ppt/presentation.xml' ) ) { $ Ext = 'pptx' ; return 'openxml' ; } } return false ; }
8727	public function getDirty ( ) { $ dirty = parent :: getDirty ( ) ; if ( ! $ this -> localeChanged ) { return $ dirty ; } foreach ( $ this -> translatableAttributes ( ) as $ key ) { if ( isset ( $ this -> attributes [ $ key ] ) ) { $ dirty [ $ key ] = $ this -> attributes [ $ key ] ; } } return $ dirty ; }
7174	public static function path ( $ array , $ path , $ default = null , $ delimiter = null ) { if ( ! static :: is_array ( $ array ) ) { return $ default ; } if ( is_array ( $ path ) ) { $ keys = $ path ; } else { if ( array_key_exists ( $ path , $ array ) ) { return $ array [ $ path ] ; } if ( ! $ delimiter ) { $ delimiter = static :: $ delimiter ; } $ path = trim ( $ path , "{$delimiter} " ) ; $ keys = explode ( $ delimiter , $ path ) ; } do { $ key = array_shift ( $ keys ) ; if ( ctype_digit ( $ key ) ) { $ key = ( int ) $ key ; } if ( isset ( $ array [ $ key ] ) ) { if ( ! $ keys ) { return $ array [ $ key ] ; } if ( ! static :: is_array ( $ array [ $ key ] ) ) { break ; } $ array = $ array [ $ key ] ; } else { break ; } } while ( $ keys ) ; return $ default ; }
8956	public function waysForNode ( $ id ) { $ base = 'node/' . $ id . '/ways' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ xmlString = $ this -> sendRequest ( $ path ) ; return $ xmlString -> way ; }
9069	public function purge ( $ days_older_than = 60 , \ wpdb $ wpdb ) { $ days_older_than = absint ( $ days_older_than ) ; $ tn = $ this -> table -> get_table_name ( $ wpdb ) ; $ sql = "DELETE FROM {$tn} WHERE time < DATE_SUB(NOW(), INTERVAL $days_older_than DAY)" ; $ wpdb -> query ( $ sql ) ; }
9964	public function getComment ( $ pCellCoordinate ) { $ pCellCoordinate = strtoupper ( $ pCellCoordinate ) ; if ( Coordinate :: coordinateIsRange ( $ pCellCoordinate ) ) { throw new Exception ( 'Cell coordinate string can not be a range of cells.' ) ; } elseif ( strpos ( $ pCellCoordinate , '$' ) !== false ) { throw new Exception ( 'Cell coordinate string must not be absolute.' ) ; } elseif ( $ pCellCoordinate == '' ) { throw new Exception ( 'Cell coordinate can not be zero-length string.' ) ; } if ( isset ( $ this -> comments [ $ pCellCoordinate ] ) ) { return $ this -> comments [ $ pCellCoordinate ] ; } $ newComment = new Comment ( ) ; $ this -> comments [ $ pCellCoordinate ] = $ newComment ; return $ newComment ; }
2976	public function serialize ( ) { try { $ this -> data = $ this -> data ? : $ this -> serializer -> getData ( $ this -> closure , true ) ; return serialize ( $ this -> data ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Serialization of closure failed: ' . $ e -> getMessage ( ) , E_USER_NOTICE ) ; return null ; } }
12157	public function getObjectTypeModel ( ) { if ( ! isset ( $ this -> _objectTypeModel ) && isset ( Yii :: $ app -> collectors [ 'types' ] -> tableRegistry [ $ this -> systemId ] ) ) { $ this -> _objectTypeModel = Yii :: $ app -> collectors [ 'types' ] -> tableRegistry [ $ this -> systemId ] ; } return $ this -> _objectTypeModel ; }
5822	public function renderFlashAlerts ( array $ options = array ( ) ) { $ options = $ this -> resolveOptions ( $ options ) ; return $ this -> templating -> render ( $ options [ 'template' ] , $ options ) ; }
12276	private function buildTemplatesMap ( ) { if ( ! empty ( $ this -> templatesMap ) ) { return $ this -> templatesMap ; } $ this -> templatesMap = [ ] ; foreach ( $ this -> templatesPaths as $ templatesPath => $ templatesNamespace ) { if ( ! is_readable ( $ templatesPath ) ) { throw new \ RuntimeException ( "Templates path '$templatesPath' does not exist or is not readable." ) ; } foreach ( glob ( $ templatesPath . '/*.phtml' ) as $ templatePath ) { $ template = pathinfo ( $ templatePath , PATHINFO_FILENAME ) ; if ( $ templatesNamespace !== null ) { $ template .= '@' . $ templatesNamespace ; } if ( array_key_exists ( $ template , $ this -> templatesMap ) ) { throw new \ OverflowException ( "Can't import template '$template' from '$templatePath' as a template with the same name already exists at '{$this->templatesMap[$template]}'. You may want to use namespaces." ) ; } $ this -> templatesMap [ $ template ] = $ templatePath ; } } return $ this -> templatesMap ; }
4887	public function createAttachedEntity ( $ entityClass , $ values = [ ] , $ key = null ) { if ( is_string ( $ values ) ) { $ key = $ values ; $ values = [ ] ; } $ entity = $ this -> repositories -> getRepository ( $ entityClass ) -> create ( $ values ) ; $ this -> addAttachedEntity ( $ entity , $ key ) ; return $ entity ; }
4195	public function getAbstraction ( $ obj , $ method = null , & $ hist = array ( ) ) { if ( ! \ is_object ( $ obj ) ) { return $ obj ; } $ reflector = new \ ReflectionObject ( $ obj ) ; $ className = $ reflector -> getName ( ) ; $ isTableTop = $ method === 'table' && \ count ( $ hist ) < 2 ; $ abs = new Event ( $ obj , array ( 'className' => $ className , 'collectMethods' => ! $ isTableTop && $ this -> abstracter -> getCfg ( 'collectMethods' ) || $ className == 'Closure' , 'constants' => array ( ) , 'debug' => $ this -> abstracter -> ABSTRACTION , 'debugMethod' => $ method , 'definition' => array ( 'fileName' => $ reflector -> getFileName ( ) , 'startLine' => $ reflector -> getStartLine ( ) , 'extensionName' => $ reflector -> getExtensionName ( ) , ) , 'extends' => array ( ) , 'implements' => $ reflector -> getInterfaceNames ( ) , 'isExcluded' => $ this -> isObjExcluded ( $ obj ) , 'isRecursion' => \ in_array ( $ obj , $ hist , true ) , 'methods' => array ( ) , 'phpDoc' => array ( 'summary' => null , 'description' => null , ) , 'properties' => array ( ) , 'scopeClass' => $ this -> getScopeClass ( $ hist ) , 'stringified' => null , 'type' => 'object' , 'traverseValues' => array ( ) , 'viaDebugInfo' => $ this -> abstracter -> getCfg ( 'useDebugInfo' ) && $ reflector -> hasMethod ( '__debugInfo' ) , 'collectPropertyValues' => true , 'hist' => $ hist , 'propertyOverrideValues' => array ( ) , 'reflector' => $ reflector , ) ) ; $ keysTemp = \ array_flip ( array ( 'collectPropertyValues' , 'hist' , 'propertyOverrideValues' , 'reflector' ) ) ; if ( $ abs [ 'isRecursion' ] ) { return \ array_diff_key ( $ abs -> getValues ( ) , $ keysTemp ) ; } $ abs = $ this -> abstracter -> debug -> internal -> publishBubbleEvent ( 'debug.objAbstractStart' , $ abs ) ; if ( \ array_filter ( array ( $ abs [ 'isExcluded' ] , $ abs -> isPropagationStopped ( ) ) ) ) { return \ array_diff_key ( $ abs -> getValues ( ) , $ keysTemp ) ; } $ this -> getAbstractionDetails ( $ abs ) ; $ return = $ this -> abstracter -> debug -> internal -> publishBubbleEvent ( 'debug.objAbstractEnd' , $ abs ) -> getValues ( ) ; $ this -> sort ( $ return [ 'properties' ] ) ; $ this -> sort ( $ return [ 'methods' ] ) ; return \ array_diff_key ( $ return , $ keysTemp ) ; }
12066	public function invokeRpcCall ( $ method , $ arguments = [ ] ) { if ( ! is_null ( $ this -> namespace ) ) { $ method = $ this -> namespace . '.' . $ method ; } $ body = XmlRpcBuilder :: createRequest ( $ method , $ arguments ) ; $ guzzle = new \ GuzzleHttp \ Client ( ) ; $ this -> getLogger ( ) -> info ( "sending request for $method to {$this->url}" ) ; $ this -> getLogger ( ) -> debug ( "sending request for $method to {$this->url}, with parameters: " . print_r ( $ arguments , true ) ) ; $ response = $ guzzle -> post ( $ this -> url , [ 'body' => $ body , 'headers' => [ 'User-Agent' => 'Devedge\XmlRpc\Client/' . self :: $ version , 'Content-Type' => 'text/xml' ] ] ) ; if ( $ response -> xml ( ) -> fault -> count ( ) > 0 ) { $ this -> logger -> warning ( "serverside error occured, details: " . $ response -> getBody ( ) ) ; throw XmlRpcParser :: parseFault ( $ response -> xml ( ) -> fault ) ; } return array_shift ( XmlRpcParser :: parseParams ( $ response -> xml ( ) -> params ) ) ; }
101	public function setPsr4 ( $ prefix , $ paths ) { if ( ! $ prefix ) { $ this -> fallbackDirsPsr4 = ( array ) $ paths ; } else { $ length = strlen ( $ prefix ) ; if ( '\\' !== $ prefix [ $ length - 1 ] ) { throw new \ InvalidArgumentException ( "A non-empty PSR-4 prefix must end with a namespace separator." ) ; } $ this -> prefixLengthsPsr4 [ $ prefix [ 0 ] ] [ $ prefix ] = $ length ; $ this -> prefixDirsPsr4 [ $ prefix ] = ( array ) $ paths ; } }
8990	public function getTemplates ( ) { $ templates = array ( ) ; $ types = $ this -> config -> getTypes ( ) ; foreach ( $ types as $ type => $ type_options ) { foreach ( $ type_options as $ subtype => $ subtype_options ) { $ templates [ $ type ] [ $ subtype ] = ( array ) $ subtype_options ; } } return $ templates ; }
5430	public function hasFinal ( ) { $ reflection = new ReflectionClass ( $ this -> interface ) ; $ methods = $ reflection -> getMethods ( ) ; foreach ( $ methods as $ method ) { if ( $ method -> isFinal ( ) ) { return true ; } } return false ; }
6508	public function doStop ( ) { if ( $ this -> controller -> doStop ( ) ) { $ this -> job -> setStatus ( Status :: CANCELLED ( ) ) ; return true ; } return false ; }
1908	private function getArgumentName ( Request $ request , ArgumentMetadata $ argument ) : ? string { if ( $ request -> attributes -> has ( $ argument -> getName ( ) ) ) { return $ argument -> getName ( ) ; } $ className = lcfirst ( $ this -> stripNamespace ( $ argument -> getType ( ) ) ) ; if ( $ request -> attributes -> has ( $ className ) ) { return $ className ; } return null ; }
6496	public function getCurrentId ( ) { $ args = arg ( ) ; return count ( $ args ) > 1 && $ this -> entityType ( ) === $ args [ 0 ] && $ args [ 1 ] > 0 ? ( int ) $ args [ 1 ] : 0 ; }
8131	protected function removeNodeFilter ( Twig_Node $ node ) { if ( $ node instanceof Twig_Node_Expression_Filter ) { return $ this -> removeNodeFilter ( $ node -> getNode ( 'node' ) ) ; } return $ node ; }
3752	public function resetFallback ( $ strField ) { @ trigger_error ( __CLASS__ . '::' . __METHOD__ . ' is deprecated - handle resetting manually' , E_USER_DEPRECATED ) ; $ metaModel = $ this -> getMetaModel ( ) ; $ attribute = $ metaModel -> getAttribute ( $ strField ) ; $ ids = $ metaModel -> getIdsFromFilter ( null ) ; if ( $ attribute instanceof IComplex ) { $ attribute -> unsetDataFor ( $ ids ) ; } if ( $ attribute instanceof ITranslated ) { $ attribute -> unsetValueFor ( $ ids , $ this -> getCurrentLanguage ( ) ) ; } if ( $ attribute instanceof IAttribute ) { $ data = array ( ) ; foreach ( $ ids as $ id ) { $ data [ $ id ] = null ; } $ attribute -> setDataFor ( $ data ) ; } throw new \ RuntimeException ( 'Unknown attribute or type ' . $ strField ) ; }
2809	public function getVisiblePanels ( ) { if ( $ this -> visiblePanels === null ) { $ this -> visiblePanels = array ( ) ; $ panels = $ this -> getSortedChildBlocks ( ) ; foreach ( $ panels as $ panel ) { if ( ! $ panel instanceof Sheep_Debug_Block_Panel ) { continue ; } $ this -> visiblePanels [ ] = $ panel ; } } return $ this -> visiblePanels ; }
818	private function fixNewline ( Tokens $ tokens , $ index , $ indentation , $ override = true ) { if ( $ tokens [ $ index + 1 ] -> isComment ( ) ) { return ; } if ( $ tokens [ $ index + 2 ] -> isComment ( ) ) { $ nextMeaningfulTokenIndex = $ tokens -> getNextMeaningfulToken ( $ index + 2 ) ; if ( ! $ this -> isNewline ( $ tokens [ $ nextMeaningfulTokenIndex - 1 ] ) ) { $ tokens -> ensureWhitespaceAtIndex ( $ nextMeaningfulTokenIndex , 0 , $ this -> whitespacesConfig -> getLineEnding ( ) . $ indentation ) ; } return ; } $ tokens -> ensureWhitespaceAtIndex ( $ index + 1 , 0 , $ this -> whitespacesConfig -> getLineEnding ( ) . $ indentation ) ; }
3949	private function buildCaption ( $ metaModel , $ inputScreen ) : array { $ caption = [ sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'metamodel_edit_as_child' ] [ 'label' ] , $ metaModel -> getName ( ) ) , '' ] ; foreach ( $ inputScreen [ 'label' ] as $ langCode => $ label ) { if ( $ label !== '' && $ langCode === $ GLOBALS [ 'TL_LANGUAGE' ] ) { $ caption = [ $ label , $ inputScreen [ 'description' ] [ $ langCode ] ] ; } } return $ caption ; }
2114	public function onBuild ( MenuEvent $ event ) : void { $ token = $ this -> tokenStorage -> getToken ( ) ; if ( null === $ token ) { return ; } $ user = $ token -> getUser ( ) ; if ( ! $ user instanceof BackendUser ) { return ; } $ factory = $ event -> getFactory ( ) ; $ tree = $ event -> getTree ( ) ; $ modules = $ user -> navigation ( ) ; foreach ( $ modules as $ categoryName => $ categoryData ) { $ categoryNode = $ tree -> getChild ( $ categoryName ) ; if ( ! $ categoryNode ) { $ categoryNode = $ this -> createNode ( $ factory , $ categoryName , $ categoryData ) ; if ( isset ( $ categoryData [ 'class' ] ) && preg_match ( '/\bnode-collapsed\b/' , $ categoryData [ 'class' ] ) ) { $ categoryNode -> setDisplayChildren ( false ) ; } $ tree -> addChild ( $ categoryNode ) ; } foreach ( $ categoryData [ 'modules' ] as $ moduleName => $ moduleData ) { $ moduleNode = $ this -> createNode ( $ factory , $ moduleName , $ moduleData ) ; $ moduleNode -> setCurrent ( ( bool ) $ moduleData [ 'isActive' ] ) ; $ categoryNode -> addChild ( $ moduleNode ) ; } } }
6538	public function init ( ) { Html :: addCssClass ( $ this -> options , [ 'panel' , 'sx-panel' , $ this -> color ] ) ; $ options = ArrayHelper :: merge ( $ this -> options , [ 'id' => $ this -> id , ] ) ; echo Html :: beginTag ( 'div' , $ options ) ; echo Html :: beginTag ( 'div' , $ this -> headingOptions ) ; echo <<<HTML <div class="pull-left"> <h2> {$this->name} </h2> </div> <div class="panel-actions panel-hidden-actions"> {$this->actions} </div>HTML ; echo Html :: endTag ( 'div' ) ; echo Html :: beginTag ( 'div' , $ this -> bodyOptions ) ; echo $ this -> content ; }
2775	public function streamOutput ( bool $ streamOutput = true ) : void { if ( $ streamOutput && ! isset ( $ this -> gitOutputListener ) ) { $ this -> gitOutputListener = new GitOutputStreamListener ( ) ; $ this -> addOutputListener ( $ this -> gitOutputListener ) ; } if ( ! $ streamOutput && isset ( $ this -> gitOutputListener ) ) { $ this -> removeOutputListener ( $ this -> gitOutputListener ) ; unset ( $ this -> gitOutputListener ) ; } }
11819	public function addAppDependencies ( ) { $ container = $ this -> getContainer ( ) ; $ container [ 'person' ] = $ container -> protect ( function ( $ name ) { return 'Person name: ' . $ name ; } ) ; return $ this ; }
3482	public function withContentAvailable ( bool $ contentAvailable ) : Aps { $ cloned = clone $ this ; $ cloned -> contentAvailable = $ contentAvailable ; return $ cloned ; }
2530	protected function makeSoapClientOptions ( ) { $ options = $ this -> soapClientOptions ; $ options [ 'classmap' ] = array_merge ( Classmap :: $ soapheader4map , Classmap :: $ map ) ; if ( ! empty ( $ this -> params -> soapClientOptions ) ) { $ options = array_merge ( $ options , $ this -> params -> soapClientOptions ) ; } return $ options ; }
1881	protected function isValid ( $ strFile ) { $ strFolder = Input :: get ( 'pid' , true ) ; if ( Validator :: isInsecurePath ( $ strFile ) ) { throw new AccessDeniedException ( 'Invalid file name "' . $ strFile . '" (hacking attempt).' ) ; } elseif ( Validator :: isInsecurePath ( $ strFolder ) ) { throw new AccessDeniedException ( 'Invalid folder name "' . $ strFolder . '" (hacking attempt).' ) ; } if ( ! empty ( $ this -> arrValidFileTypes ) && is_file ( $ this -> strRootDir . '/' . $ strFile ) ) { $ fileinfo = preg_replace ( '/.*\.(.*)$/u' , '$1' , $ strFile ) ; if ( ! \ in_array ( strtolower ( $ fileinfo ) , $ this -> arrValidFileTypes ) ) { throw new AccessDeniedException ( 'File "' . $ strFile . '" is not an allowed file type.' ) ; } } if ( ! preg_match ( '/^' . preg_quote ( Config :: get ( 'uploadPath' ) , '/' ) . '/i' , $ strFile ) ) { throw new AccessDeniedException ( 'File or folder "' . $ strFile . '" is not within the files directory.' ) ; } if ( $ strFolder && ! preg_match ( '/^' . preg_quote ( Config :: get ( 'uploadPath' ) , '/' ) . '/i' , $ strFolder ) ) { throw new AccessDeniedException ( 'Parent folder "' . $ strFolder . '" is not within the files directory.' ) ; } if ( Input :: get ( 'act' ) == 'edit' || Input :: get ( 'act' ) == 'paste' || Input :: get ( 'act' ) == 'delete' ) { $ this -> import ( BackendUser :: class , 'User' ) ; if ( ! $ this -> User -> isAdmin && \ in_array ( $ strFile , $ this -> User -> filemounts ) ) { throw new AccessDeniedException ( 'Attempt to edit, copy, move or delete the root folder "' . $ strFile . '".' ) ; } } return true ; }
12000	static protected function doctrineQuery ( $ tableName , $ field , $ generate ) { return \ Doctrine_Query :: create ( ) -> select ( $ field ) -> from ( $ tableName ) -> where ( "$field = ?" , $ generate ) -> execute ( array ( ) , \ Doctrine_Core :: HYDRATE_SINGLE_SCALAR ) ; }
10697	public function send ( ResponseInterface $ response ) : ResponseInterface { $ response -> getBody ( ) -> write ( json_encode ( $ this -> toArray ( ) ) ) ; return $ response -> withHeader ( 'Content-Type' , self :: MIME_TYPE_JSON ) ; }
2136	protected static function loadParameters ( ) { $ container = System :: getContainer ( ) ; if ( $ container === null ) { return ; } if ( $ container -> hasParameter ( 'contao.localconfig' ) && \ is_array ( $ params = $ container -> getParameter ( 'contao.localconfig' ) ) ) { foreach ( $ params as $ key => $ value ) { $ GLOBALS [ 'TL_CONFIG' ] [ $ key ] = $ value ; } } $ arrMap = array ( 'dbHost' => 'database_host' , 'dbPort' => 'database_port' , 'dbUser' => 'database_user' , 'dbPass' => 'database_password' , 'dbDatabase' => 'database_name' , 'smtpHost' => 'mailer_host' , 'smtpUser' => 'mailer_user' , 'smtpPass' => 'mailer_password' , 'smtpPort' => 'mailer_port' , 'smtpEnc' => 'mailer_encryption' , 'addLanguageToUrl' => 'contao.prepend_locale' , 'encryptionKey' => 'contao.encryption_key' , 'urlSuffix' => 'contao.url_suffix' , 'uploadPath' => 'contao.upload_path' , 'debugMode' => 'kernel.debug' , ) ; foreach ( $ arrMap as $ strKey => $ strParam ) { if ( $ container -> hasParameter ( $ strParam ) ) { $ GLOBALS [ 'TL_CONFIG' ] [ $ strKey ] = $ container -> getParameter ( $ strParam ) ; } } if ( $ container -> hasParameter ( 'contao.image.valid_extensions' ) ) { $ GLOBALS [ 'TL_CONFIG' ] [ 'validImageTypes' ] = implode ( ',' , $ container -> getParameter ( 'contao.image.valid_extensions' ) ) ; } if ( $ container -> hasParameter ( 'contao.image.imagine_options' ) ) { $ GLOBALS [ 'TL_CONFIG' ] [ 'jpgQuality' ] = $ container -> getParameter ( 'contao.image.imagine_options' ) [ 'jpeg_quality' ] ; } }
10918	public function getUserEntity ( $ identity , $ credential ) { $ credential = $ this -> preProcessCredential ( $ credential ) ; $ userObject = NULL ; $ fields = $ this -> getOptions ( ) -> getAuthIdentityFields ( ) ; while ( ! is_object ( $ userObject ) && count ( $ fields ) > 0 ) { $ mode = array_shift ( $ fields ) ; switch ( $ mode ) { case 'username' : $ userObject = $ this -> getMapper ( ) -> findByUsername ( $ identity ) ; break ; case 'email' : $ userObject = $ this -> getMapper ( ) -> findByEmail ( $ identity ) ; break ; } } if ( ! $ userObject ) { return null ; } $ bcrypt = new Bcrypt ( ) ; $ bcrypt -> setCost ( $ this -> getOptions ( ) -> getPasswordCost ( ) ) ; if ( ! $ bcrypt -> verify ( $ credential , $ userObject -> getPassword ( ) ) ) { return null ; } return $ userObject ; }
6933	public function transform ( ) { if ( null === $ this -> source || null === $ this -> target ) { throw new LogicException ( "Please call initialize first." ) ; } $ event = new SaleTransformEvent ( $ this -> source , $ this -> target ) ; $ this -> eventDispatcher -> dispatch ( SaleTransformEvents :: PRE_TRANSFORM , $ event ) ; if ( $ event -> hasErrors ( ) || $ event -> isPropagationStopped ( ) ) { return $ event ; } $ targetEvent = $ this -> getOperator ( $ this -> target ) -> persist ( $ this -> target ) ; if ( ! $ targetEvent -> isPropagationStopped ( ) && ! $ targetEvent -> hasErrors ( ) ) { $ this -> uploadableListener -> setEnabled ( false ) ; $ sourceEvent = $ this -> getOperator ( $ this -> source ) -> delete ( $ this -> source , true ) ; if ( ! $ sourceEvent -> isPropagationStopped ( ) && ! $ sourceEvent -> hasErrors ( ) ) { $ targetEvent = null ; } $ this -> uploadableListener -> setEnabled ( true ) ; } $ this -> eventDispatcher -> dispatch ( SaleTransformEvents :: POST_TRANSFORM , $ event ) ; if ( $ event -> hasErrors ( ) || $ event -> isPropagationStopped ( ) ) { return $ event ; } $ this -> source = null ; $ this -> target = null ; return $ targetEvent ; }
8172	private function getSourceExcerpt ( $ source = '' , $ line = 1 , $ plus = 1 , $ format = false ) { $ excerpt = [ ] ; $ twig = Escape :: html ( $ source ) ; $ lines = preg_split ( "/(\r\n|\n|\r)/" , $ twig ) ; $ start = max ( 1 , $ line - $ plus ) ; $ limit = min ( count ( $ lines ) , $ line + $ plus ) ; for ( $ i = $ start - 1 ; $ i < $ limit ; $ i ++ ) { if ( $ format ) { $ attr = 'data-line="' . ( $ i + 1 ) . '"' ; if ( $ i === $ line - 1 ) $ excerpt [ ] = "<mark $attr>$lines[$i]</mark>" ; else $ excerpt [ ] = "<span $attr>$lines[$i]</span>" ; } else { $ excerpt [ ] = $ lines [ $ i ] ; } } return implode ( "\n" , $ excerpt ) ; }
4847	public static function unregister ( ) { if ( isset ( self :: $ autoloadFn ) ) { spl_autoload_unregister ( self :: $ autoloadFn ) ; self :: $ autoloadFn = null ; } self :: $ aliases = [ ] ; }
3139	public function storeItemResponse ( RunnerServiceContext $ context , $ itemRef , $ responses ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ session = $ this -> getCurrentAssessmentSession ( $ context ) ; try { \ common_Logger :: t ( 'Responses sent from the client-side. The Response Processing will take place.' ) ; if ( $ context -> isAdaptive ( ) ) { $ session -> beginItemSession ( ) ; $ session -> beginAttempt ( ) ; $ session -> endAttempt ( $ responses ) ; $ assessmentItem = $ session -> getAssessmentItem ( ) ; $ assessmentItemIdentifier = $ assessmentItem -> getIdentifier ( ) ; $ score = $ session -> getVariable ( 'SCORE' ) ; $ output = $ context -> getLastCatItemOutput ( ) ; if ( $ score !== null ) { $ output [ $ assessmentItemIdentifier ] = new ItemResult ( $ assessmentItemIdentifier , new ResultVariable ( $ score -> getIdentifier ( ) , BaseType :: getNameByConstant ( $ score -> getBaseType ( ) ) , $ score -> getValue ( ) -> getValue ( ) , null , $ score -> getCardinality ( ) ) , microtime ( true ) ) ; } else { \ common_Logger :: i ( "No 'SCORE' outcome variable for item '${assessmentItemIdentifier}' involved in an adaptive section." ) ; } $ context -> persistLastCatItemOutput ( $ output ) ; $ resultTransmitter = new \ taoQtiCommon_helpers_ResultTransmitter ( $ context -> getSessionManager ( ) -> getResultServer ( ) ) ; $ outcomeVariables = [ ] ; $ hrefParts = explode ( '|' , $ assessmentItem -> getHref ( ) ) ; $ sessionId = $ context -> getTestSession ( ) -> getSessionId ( ) ; $ itemIdentifier = $ assessmentItem -> getIdentifier ( ) ; $ attempt = $ context -> getCatAttempts ( $ itemIdentifier ) ; $ transmissionId = "${sessionId}.${itemIdentifier}.${attempt}" ; $ attempt ++ ; foreach ( $ session -> getAllVariables ( ) as $ var ) { if ( $ var -> getIdentifier ( ) === 'numAttempts' ) { $ var -> setValue ( new \ qtism \ common \ datatypes \ QtiInteger ( $ attempt ) ) ; } $ variables [ ] = $ var ; } $ resultTransmitter -> transmitItemVariable ( $ variables , $ transmissionId , $ hrefParts [ 0 ] , $ hrefParts [ 2 ] ) ; $ context -> persistCatAttempts ( $ itemIdentifier , $ attempt ) ; $ context -> getTestSession ( ) -> endAttempt ( new State ( ) , true ) ; } else { $ session -> endAttempt ( $ responses , true ) ; } return true ; } catch ( AssessmentTestSessionException $ e ) { \ common_Logger :: w ( $ e -> getMessage ( ) ) ; return false ; } } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'storeItemResponse' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } }
12568	public function preview ( $ msgType , $ message , $ to , $ by = self :: PREVIEW_BY_OPENID ) { $ message = ( new MessageBuilder ( ) ) -> msgType ( $ msgType ) -> message ( $ message ) -> to ( $ to ) -> buildPreview ( $ by ) ; return $ this -> post ( self :: API_PREVIEW , $ message ) ; }
11076	public function getHttpClient ( ) { if ( null === $ this -> httpClient ) { $ this -> httpClient = new HttpClient ( ) ; $ this -> httpClient -> setAdapter ( $ this -> getHttpAdapter ( ) ) ; } return $ this -> httpClient ; }
2605	public function aroundSetHeader ( Http $ subject , callable $ proceed , ... $ args ) { if ( $ this -> config -> getType ( ) !== Config :: FASTLY ) { return $ proceed ( ... $ args ) ; } if ( isset ( $ args [ 0 ] ) == true && $ args [ 0 ] !== 'X-Magento-Tags' ) { return $ proceed ( ... $ args ) ; } $ args [ 1 ] = $ this -> cacheTags -> convertCacheTags ( str_replace ( ',' , ' ' , $ args [ 1 ] ) ) ; $ tagsSize = $ this -> config -> getXMagentoTagsSize ( ) ; if ( strlen ( $ args [ 1 ] ) > $ tagsSize ) { $ trimmedArgs = substr ( $ args [ 1 ] , 0 , $ tagsSize ) ; $ args [ 1 ] = substr ( $ trimmedArgs , 0 , strrpos ( $ trimmedArgs , ' ' , - 1 ) ) ; } return $ proceed ( ... $ args ) ; }
6997	public function getViewersForRelations ( ) { $ ret = [ ] ; foreach ( $ this -> getValueViewers ( ) as $ key => $ viewer ) { if ( $ viewer -> isLinkedToDbColumn ( ) && $ viewer -> hasRelation ( ) ) { $ ret [ $ key ] = $ viewer ; } } return $ ret ; }
12004	public static function objectToArray ( $ mObject ) : array { if ( is_object ( $ mObject ) ) { $ mObject = ( array ) $ mObject ; } if ( is_array ( $ mObject ) ) { $ aNew = array ( ) ; foreach ( $ mObject as $ sKey => $ mValues ) { $ sKey = preg_replace ( "/^\\0(.*)\\0/" , "" , $ sKey ) ; $ aNew [ $ sKey ] = self :: objectToArray ( $ mValues ) ; } } else { $ aNew = $ mObject ; } return $ aNew ; }
7160	public function buildSaleView ( Model \ SaleInterface $ sale , array $ options = [ ] ) { $ this -> initialize ( $ sale , $ options ) ; $ this -> amountCalculator -> calculateSale ( $ sale ) ; $ grossResult = $ sale -> getGrossResult ( ) ; $ this -> view -> setGross ( new TotalView ( $ this -> formatter -> currency ( $ grossResult -> getGross ( $ this -> view -> isAti ( ) ) ) , $ this -> formatter -> currency ( $ grossResult -> getDiscount ( $ this -> view -> isAti ( ) ) ) , $ this -> formatter -> currency ( $ grossResult -> getBase ( $ this -> view -> isAti ( ) ) ) ) ) ; $ finalResult = $ sale -> getFinalResult ( ) ; $ this -> view -> setFinal ( new TotalView ( $ this -> formatter -> currency ( $ finalResult -> getBase ( ) ) , $ this -> formatter -> currency ( $ finalResult -> getTax ( ) ) , $ this -> formatter -> currency ( $ finalResult -> getTotal ( ) ) ) ) ; if ( $ this -> options [ 'private' ] && null !== $ margin = $ this -> marginCalculator -> calculateSale ( $ sale ) ) { $ prefix = $ margin -> isAverage ( ) ? '~' : '' ; $ this -> view -> setMargin ( new MarginView ( $ prefix . $ this -> formatter -> currency ( $ margin -> getAmount ( ) ) , $ prefix . $ this -> formatter -> percent ( $ margin -> getPercent ( ) ) ) ) ; $ this -> view -> vars [ 'show_margin' ] = true ; } $ this -> buildSaleItemsLinesViews ( $ sale ) ; $ this -> buildSaleDiscountsLinesViews ( $ sale ) ; $ this -> buildShipmentLine ( $ sale ) ; $ this -> buildSaleTaxesViews ( $ sale ) ; foreach ( $ this -> types as $ type ) { $ type -> buildSaleView ( $ sale , $ this -> view , $ this -> options ) ; } $ columnsCount = 6 ; if ( $ this -> view -> vars [ 'show_availability' ] ) { $ columnsCount ++ ; } if ( $ this -> view -> vars [ 'show_discounts' ] = 0 < count ( $ grossResult -> getDiscountAdjustments ( ) ) ) { $ columnsCount += 3 ; } if ( $ this -> view -> vars [ 'show_taxes' ] = 1 < count ( $ finalResult -> getTaxAdjustments ( ) ) ) { $ columnsCount ++ ; } if ( $ this -> view -> vars [ 'show_margin' ] ) { $ columnsCount ++ ; } if ( $ this -> options [ 'editable' ] ) { $ columnsCount ++ ; } $ this -> view -> vars [ 'columns_count' ] = $ columnsCount ; return $ this -> view ; }
11511	protected static function unescapeString ( $ matches ) { static $ map = [ 'n' => "\n" , 'r' => "\r" , 't' => "\t" , 'v' => "\v" , 'f' => "\f" ] ; if ( ! empty ( $ matches [ 2 ] ) ) return chr ( octdec ( $ matches [ 2 ] ) ) ; elseif ( ! empty ( $ matches [ 3 ] ) ) return chr ( hexdec ( $ matches [ 3 ] ) ) ; elseif ( isset ( $ map [ $ matches [ 1 ] ] ) ) return $ map [ $ matches [ 1 ] ] ; return $ matches [ 1 ] ; }
3090	public function process ( ) { $ this -> validate ( ) ; $ itemRef = $ this -> hasRequestParameter ( 'itemDefinition' ) ? $ this -> getItemRef ( $ this -> getRequestParameter ( 'itemDefinition' ) ) : null ; $ traceData = json_decode ( html_entity_decode ( $ this -> getRequestParameter ( 'traceData' ) ) , true ) ; try { $ serviceContext = $ this -> getServiceContext ( ) ; $ stored = 0 ; $ size = count ( $ traceData ) ; foreach ( $ traceData as $ variableIdentifier => $ variableValue ) { if ( $ this -> getRunnerService ( ) -> storeTraceVariable ( $ serviceContext , $ itemRef , $ variableIdentifier , $ variableValue ) ) { $ stored ++ ; } } $ response = [ 'success' => $ stored == $ size ] ; common_Logger :: d ( 'Stored "' . $ stored . '/' . $ size . '" trace variables' ) ; $ eventManager = $ this -> getServiceLocator ( ) -> get ( EventManager :: SERVICE_ID ) ; $ event = new TraceVariableStored ( $ serviceContext -> getTestSession ( ) -> getSessionId ( ) , $ traceData ) ; $ eventManager -> trigger ( $ event ) ; } catch ( Exception $ e ) { $ response = $ this -> getErrorResponse ( $ e ) ; } return $ response ; }
4120	public static function overrideType ( $ name , $ className ) { if ( ! isset ( self :: $ _typesMap [ $ name ] ) ) { throw TypeException :: typeNotFound ( $ name ) ; } self :: $ _typesMap [ $ name ] = $ className ; }
11246	public function getMigrations ( int $ steps ) : array { $ sql = "select migration from {$this->table} where batch >= 1 order by batch, migration desc limit ?" ; $ stmt = $ this -> pdo -> prepare ( $ sql ) ; $ stmt -> bindParam ( 1 , $ steps , PDO :: PARAM_INT ) ; $ stmt -> execute ( ) ; return $ stmt -> fetchAll ( PDO :: FETCH_COLUMN ) ; }
9718	private function writePalette ( ) { $ aref = $ this -> palette ; $ record = 0x0092 ; $ length = 2 + 4 * count ( $ aref ) ; $ ccv = count ( $ aref ) ; $ data = '' ; foreach ( $ aref as $ color ) { foreach ( $ color as $ byte ) { $ data .= pack ( 'C' , $ byte ) ; } } $ header = pack ( 'vvv' , $ record , $ length , $ ccv ) ; $ this -> append ( $ header . $ data ) ; }
3363	private function loadChunk ( ) { $ portion = $ this -> pdGetDataChunk ( $ this -> api , $ this -> options , $ this -> reverse ) ; $ this -> options = $ portion [ 'params' ] ; $ this -> nextPageParams = $ portion [ 'nextParams' ] ; $ this -> prevPageParams = $ portion [ 'prevParams' ] ; if ( $ portion [ 'data' ] ) { $ this -> container = array_merge ( $ this -> container , $ portion [ 'data' ] ) ; } if ( ! count ( $ portion [ 'params' ] ) ) { $ this -> fullyLoaded = true ; } }
11245	public function getRan ( ) : array { $ stmt = $ this -> pdo -> query ( "select migration from {$this->table} order by batch, migration" ) ; $ stmt -> execute ( ) ; $ results = $ stmt -> fetchAll ( PDO :: FETCH_COLUMN ) ; return $ results ; }
12715	protected function circularDependencyResolver ( $ class ) { if ( ! is_string ( $ class ) && ! class_exists ( $ class ) ) { throw Internal \ Exception \ ReflectionExceptionFactory :: invalidArgument ( sprintf ( "Parameter 1 of %s must be a string of valid class name." , __METHOD__ ) ) ; } $ reflector = Internal \ ReflectionClassFactory :: create ( $ class ) ; if ( ! $ this -> hasConstructor ( $ reflector ) ) { return $ this -> resolveInstanceWithoutConstructor ( $ reflector ) ; } else { $ param = $ this -> getMethodParameters ( $ reflector , '__construct' ) ; if ( empty ( $ param ) ) { return $ reflector -> newInstance ( ) ; } else { foreach ( $ param as $ key => $ value ) { $ class = $ value -> getClass ( ) ; if ( $ class instanceof \ ReflectionClass ) { if ( $ class -> isInterface ( ) ) { $ param [ $ key ] = $ this -> getConcreteFromInterface ( $ class -> getName ( ) ) ; } else { $ param [ $ key ] = $ this -> circularDependencyResolver ( $ class -> getName ( ) ) ; } } } return $ reflector -> newInstanceArgs ( $ param ) ; } } }
8785	public function fullUrlWithQuery ( array $ query ) { $ question = $ this -> getBaseUrl ( ) . $ this -> getPathInfo ( ) == '/' ? '/?' : '?' ; return count ( $ this -> query ( ) ) > 0 ? $ this -> url ( ) . $ question . http_build_query ( array_merge ( $ this -> query ( ) , $ query ) ) : $ this -> fullUrl ( ) . $ question . http_build_query ( $ query ) ; }
2262	public function query ( $ strQuery ) { $ objStatement = new Statement ( $ this -> resConnection , $ this -> blnDisableAutocommit ) ; return $ objStatement -> query ( $ strQuery ) ; }
1580	public function withId ( ? string $ id ) : self { $ copy = clone $ this ; $ copy -> id = $ id ? : null ; $ copy -> normalize ( ) ; return $ copy ; }
1811	public function addCteType ( $ arrRow ) { $ key = $ arrRow [ 'invisible' ] ? 'unpublished' : 'published' ; $ type = $ GLOBALS [ 'TL_LANG' ] [ 'CTE' ] [ $ arrRow [ 'type' ] ] [ 0 ] ? : '&nbsp;' ; $ class = 'limit_height' ; if ( \ in_array ( $ arrRow [ 'type' ] , $ GLOBALS [ 'TL_WRAPPERS' ] [ 'start' ] ) || \ in_array ( $ arrRow [ 'type' ] , $ GLOBALS [ 'TL_WRAPPERS' ] [ 'separator' ] ) || \ in_array ( $ arrRow [ 'type' ] , $ GLOBALS [ 'TL_WRAPPERS' ] [ 'stop' ] ) ) { $ class = '' ; if ( ( $ group = $ this -> getContentElementGroup ( $ arrRow [ 'type' ] ) ) !== null ) { $ type = $ GLOBALS [ 'TL_LANG' ] [ 'CTE' ] [ $ group ] . ' (' . $ type . ')' ; } } elseif ( \ in_array ( $ arrRow [ 'type' ] , $ GLOBALS [ 'TL_WRAPPERS' ] [ 'single' ] ) ) { if ( ( $ group = $ this -> getContentElementGroup ( $ arrRow [ 'type' ] ) ) !== null ) { $ type = $ GLOBALS [ 'TL_LANG' ] [ 'CTE' ] [ $ group ] . ' (' . $ type . ')' ; } } if ( $ arrRow [ 'type' ] == 'alias' ) { $ type .= ' ID ' . $ arrRow [ 'cteAlias' ] ; } if ( $ arrRow [ 'protected' ] ) { $ type .= ' (' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'protected' ] . ')' ; } elseif ( $ arrRow [ 'guests' ] ) { $ type .= ' (' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'guests' ] . ')' ; } if ( $ arrRow [ 'type' ] == 'headline' ) { if ( \ is_array ( $ headline = Contao \ StringUtil :: deserialize ( $ arrRow [ 'headline' ] ) ) ) { $ type .= ' (' . $ headline [ 'unit' ] . ')' ; } } if ( ! Contao \ Config :: get ( 'doNotCollapse' ) ) { $ class .= ' h40' ; } $ objModel = new Contao \ ContentModel ( ) ; $ objModel -> setRow ( $ arrRow ) ; return '<div class="cte_type ' . $ key . '">' . $ type . '</div><div class="' . trim ( $ class ) . '">' . Contao \ StringUtil :: insertTagToSrc ( $ this -> getContentElement ( $ objModel ) ) . '</div>' . "\n" ; }
12116	public static function getShortName ( $ fqn ) { $ fqn_parts = explode ( '\\' , $ fqn ) ; $ final = array_pop ( $ fqn_parts ) ; if ( empty ( $ fqn_parts ) ) { return $ final ; } $ fqn_caps = preg_replace ( '/[a-z]+/' , '' , $ fqn_parts ) ; return implode ( '\\' , $ fqn_caps ) . '\\' . $ final ; }
10125	private function writeAutoFilterInfo ( ) { $ record = 0x009D ; $ length = 0x0002 ; $ rangeBounds = Coordinate :: rangeBoundaries ( $ this -> phpSheet -> getAutoFilter ( ) -> getRange ( ) ) ; $ iNumFilters = 1 + $ rangeBounds [ 1 ] [ 0 ] - $ rangeBounds [ 0 ] [ 0 ] ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ iNumFilters ) ; $ this -> append ( $ header . $ data ) ; }
7798	public function parse ( $ text ) { $ statements = array ( ) ; foreach ( $ this -> splitStatements ( $ text ) as $ chunk ) { if ( $ statement = $ this -> statement ( $ chunk ) ) { $ statements [ ] = $ statement ; } } return $ statements ; }
5145	public function _after ( \ Codeception \ TestCase $ test ) { if ( isset ( $ this -> config [ 'deleteEmailsAfterScenario' ] ) && $ this -> config [ 'deleteEmailsAfterScenario' ] ) { $ this -> deleteAllEmails ( ) ; } }
2909	public function getModuleVersion ( ) { $ moduleConfig = $ this -> getConfig ( ) -> getModuleConfig ( $ this -> getModuleName ( ) ) ; return ( string ) $ moduleConfig -> version ; }
4630	protected function prepareRequestHeaders ( ) { $ curl_headers = [ ] ; foreach ( $ this -> headers as $ key => $ value ) { $ curl_headers [ ] = sprintf ( '%s: %s' , $ key , $ value ) ; } $ object = $ this -> command -> getObject ( ) ; if ( $ object ) { if ( $ object -> getVclock ( ) ) { $ curl_headers [ ] = sprintf ( '%s: %s' , static :: VCLOCK_KEY , $ object -> getVclock ( ) ) ; } if ( $ object -> getContentType ( ) ) { $ charset = '' ; if ( $ object -> getCharset ( ) ) { $ charset = sprintf ( '; charset=%s' , $ object -> getCharset ( ) ) ; } $ curl_headers [ ] = sprintf ( '%s: %s' , static :: CONTENT_TYPE_KEY , $ object -> getContentType ( ) , $ charset ) ; } $ translator = new Api \ Http \ Translator \ SecondaryIndex ( ) ; $ indexHeaders = $ translator -> createHeadersFromIndexes ( $ object -> getIndexes ( ) ) ; foreach ( $ indexHeaders as $ value ) { $ curl_headers [ ] = sprintf ( '%s: %s' , $ value [ 0 ] , $ value [ 1 ] ) ; } foreach ( $ object -> getMetaData ( ) as $ key => $ value ) { $ curl_headers [ ] = sprintf ( '%s%s: %s' , static :: METADATA_PREFIX , $ key , $ value ) ; } } $ this -> options [ CURLOPT_HTTPHEADER ] = $ curl_headers ; $ this -> headers = [ ] ; return $ this ; }
8529	public function listFinancialEvents ( $ request ) { if ( ! ( $ request instanceof MWSFinancesService_Model_ListFinancialEventsRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/ListFinancialEventsRequest.php' ) ; $ request = new MWSFinancesService_Model_ListFinancialEventsRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListFinancialEvents' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/ListFinancialEventsResponse.php' ) ; $ response = MWSFinancesService_Model_ListFinancialEventsResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
855	public function insertAt ( $ index , $ items ) { $ items = \ is_array ( $ items ) || $ items instanceof self ? $ items : [ $ items ] ; $ itemsCnt = \ count ( $ items ) ; if ( 0 === $ itemsCnt ) { return ; } $ oldSize = \ count ( $ this ) ; $ this -> changed = true ; $ this -> blockEndCache = [ ] ; $ this -> setSize ( $ oldSize + $ itemsCnt ) ; for ( $ i = $ oldSize + $ itemsCnt - 1 ; $ i >= $ index ; -- $ i ) { $ oldItem = parent :: offsetExists ( $ i - $ itemsCnt ) ? parent :: offsetGet ( $ i - $ itemsCnt ) : new Token ( '' ) ; parent :: offsetSet ( $ i , $ oldItem ) ; } for ( $ i = 0 ; $ i < $ itemsCnt ; ++ $ i ) { if ( '' === $ items [ $ i ] -> getContent ( ) ) { throw new \ InvalidArgumentException ( 'Must not add empty token to collection.' ) ; } $ this -> registerFoundToken ( $ items [ $ i ] ) ; parent :: offsetSet ( $ i + $ index , $ items [ $ i ] ) ; } }
10668	public static function build ( $ input , array $ options = [ ] ) { if ( ! \ is_array ( $ options ) ) { $ options = [ 'return' => ( string ) $ options ] ; } $ defaults = [ 'return' => 'simplexml' , ] ; $ options = array_merge ( $ defaults , $ options ) ; if ( is_array ( $ input ) || is_object ( $ input ) ) { return self :: fromArray ( ( array ) $ input , $ options ) ; } if ( strpos ( $ input , '<' ) !== false ) { if ( $ options [ 'return' ] === 'simplexml' || $ options [ 'return' ] === 'simplexmlelement' ) { return new \ SimpleXMLElement ( $ input , LIBXML_NOCDATA ) ; } $ dom = new \ DOMDocument ( ) ; $ dom -> loadXML ( $ input ) ; return $ dom ; } if ( file_exists ( $ input ) || strpos ( $ input , 'http://' ) === 0 || strpos ( $ input , 'https://' ) === 0 ) { if ( $ options [ 'return' ] === 'simplexml' || $ options [ 'return' ] === 'simplexmlelement' ) { return new \ SimpleXMLElement ( $ input , LIBXML_NOCDATA , true ) ; } $ dom = new \ DOMDocument ( ) ; $ dom -> load ( $ input ) ; return $ dom ; } if ( ! \ is_string ( $ input ) ) { throw new \ RuntimeException ( Tools :: poorManTranslate ( 'fts-shared' , 'Invalid input.' ) ) ; } throw new \ RuntimeException ( Tools :: poorManTranslate ( 'fts-shared' , 'XML cannot be read.' ) ) ; }
9189	public function present ( ) { $ presenterClass = $ this -> getPresenterClass ( ) ; if ( ! class_exists ( $ presenterClass ) ) { throw new Exceptions \ PresenterException ( 'The specified presenter does not exist.' ) ; } if ( ! $ this -> presenterInstance ) { $ this -> presenterInstance = new $ presenterClass ( $ this ) ; } return $ this -> presenterInstance ; }
11260	public static function snake2pascal ( string $ snake ) : string { $ nameParts = explode ( "_" , $ snake ) ; $ nameParts = array_map ( "ucfirst" , $ nameParts ) ; return implode ( "" , $ nameParts ) ; }
851	public function getTokenNotOfKindSibling ( $ index , $ direction , array $ tokens = [ ] ) { while ( true ) { $ index += $ direction ; if ( ! $ this -> offsetExists ( $ index ) ) { return null ; } if ( $ this -> isEmptyAt ( $ index ) ) { continue ; } if ( $ this [ $ index ] -> equalsAny ( $ tokens ) ) { continue ; } return $ index ; } }
2726	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ dictionary = $ this -> api -> getSingleDictionary ( $ activeVersion , 'magentomodule_basic_auth' ) ; if ( ! $ dictionary || ( is_array ( $ dictionary ) && empty ( $ dictionary ) ) ) { return $ result -> setData ( [ 'status' => 'none' , 'msg' => 'Authentication dictionary does not exist.' ] ) ; } $ authItems = false ; if ( isset ( $ dictionary -> id ) ) { $ authItems = $ this -> api -> dictionaryItemsList ( $ dictionary -> id ) ; } if ( is_array ( $ authItems ) && empty ( $ authItems ) ) { return $ result -> setData ( [ 'status' => 'empty' , 'msg' => 'There are no dictionary items.' ] ) ; } if ( ! $ authItems ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to fetch dictionary items.' ] ) ; } foreach ( $ authItems as $ key => $ item ) { $ userData = explode ( ':' , base64_decode ( $ item -> item_key ) ) ; $ username = $ userData [ 0 ] ; $ item -> item_key_id = $ item -> item_key ; $ item -> item_key = $ username ; $ authItems [ $ key ] = $ item ; } return $ result -> setData ( [ 'status' => true , 'auths' => $ authItems ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
1483	public function register ( AbstractProvider $ provider ) { $ this -> resolver -> attach ( $ provider -> getResolver ( ) ) ; $ this -> errors = array_replace ( $ provider -> getErrors ( ) , $ this -> errors ) ; }
3641	public function get ( string $ key , $ default = null , bool $ trim = true , bool $ clean = true ) { $ value = $ this -> request -> input ( $ key , $ default ) ; return $ this -> clean ( $ value , $ trim , $ clean ) ; }
7052	public function logoutCurrentUser ( ) { $ this -> getAuthGuard ( ) -> logout ( ) ; \ Session :: remove ( $ this -> originalUserFromLoginAsActionSessionKey ) ; \ Session :: invalidate ( ) ; $ this -> getCmfConfig ( ) -> resetLocale ( ) ; }
11242	protected function _call ( $ fieldData , $ controller , $ method , $ passing , $ arguments ) { $ fieldData = array ( $ fieldData , $ arguments ) ; $ result = call_user_func_array ( array ( $ controller , $ method ) , $ fieldData ) ; return $ result == $ passing ? true : false ; }
6428	protected function getFacebookObject ( ) { if ( is_object ( $ this -> fb ) ) { return $ this -> fb ; } $ fb = new \ Facebook \ Facebook ( [ 'app_id' => $ this -> options [ 'api_key' ] , 'app_secret' => $ this -> options [ 'secret_key' ] , 'default_graph_version' => 'v3.0' , ] ) ; $ this -> fb = $ fb ; return $ fb ; }
11059	public static function files ( $ path , array $ extensions = array ( ) ) { $ files = array ( ) ; $ it = new \ RecursiveDirectoryIterator ( $ path ) ; $ filter = false ; if ( ! empty ( $ extensions ) && is_array ( $ extensions ) ) { $ filter = true ; } foreach ( new \ RecursiveIteratorIterator ( $ it ) as $ file ) { if ( $ filter ) { $ f = explode ( '.' , $ file ) ; $ ext = strtolower ( array_pop ( $ f ) ) ; if ( in_array ( $ ext , $ extensions ) ) { $ files [ ] = $ file ; } } else { $ files [ ] = $ file ; } } return $ files ; }
12697	static function getOpts ( $ extname = '' , $ version = '' , $ cliopts = array ( ) ) { self :: setConfigDir ( $ cliopts ) ; if ( $ version == '' && self :: isValidVersion ( $ extname ) ) { $ version = $ extname ; $ extname = '' ; } if ( $ version != '' && ! self :: isValidVersion ( $ version ) ) { throw new PakeException ( "'$version' is not a valid version number" ) ; } if ( $ extname == '' ) { $ extname = self :: getDefaultExtName ( ) ; } if ( ! isset ( self :: $ options [ $ extname ] ) || ! is_array ( self :: $ options [ $ extname ] ) ) { if ( isset ( $ cliopts [ 'config-file' ] ) ) { $ cfgfile = $ cliopts [ 'config-file' ] ; } else { $ cfgfile = self :: getOptionsDir ( ) . "/options-$extname.yaml" ; } if ( isset ( $ cliopts [ 'user-config-file' ] ) ) { $ usercfgfile = $ cliopts [ 'user-config-file' ] ; if ( ! is_file ( $ cliopts [ 'user-config-file' ] ) ) { throw new PakeException ( "Could not find user-configuration-file {$cliopts['user-config-file']}" ) ; } } else { $ usercfgfile = self :: getOptionsDir ( ) . "/options-user.yaml" ; } foreach ( $ cliopts as $ opt => $ val ) { if ( substr ( $ opt , 0 , 7 ) == 'option.' ) { unset ( $ cliopts [ $ opt ] ) ; $ work = array_reverse ( explode ( '.' , substr ( $ opt , 7 ) ) ) ; $ built = array ( array_shift ( $ work ) => $ val ) ; foreach ( $ work as $ key ) { $ built = array ( $ key => $ built ) ; } self :: recursivemerge ( $ cliopts , $ built ) ; } } self :: loadConfiguration ( $ cfgfile , $ extname , $ version , $ usercfgfile , $ cliopts ) ; } pake_echo ( "Building extension $extname ( " . self :: $ options [ $ extname ] [ 'extension' ] [ 'name' ] . " ) version " . self :: $ options [ $ extname ] [ 'version' ] [ 'alias' ] . self :: $ options [ $ extname ] [ 'releasenr' ] [ 'separator' ] . self :: $ options [ $ extname ] [ 'version' ] [ 'release' ] ) ; return self :: $ options [ $ extname ] ; }
1757	public static function getReadableSize ( $ intSize , $ intDecimals = 1 ) { for ( $ i = 0 ; $ intSize >= 1024 ; $ i ++ ) { $ intSize /= 1024 ; } return static :: getFormattedNumber ( $ intSize , $ intDecimals ) . ' ' . $ GLOBALS [ 'TL_LANG' ] [ 'UNITS' ] [ $ i ] ; }
731	protected function getUniqueIndexInformation ( $ table ) { $ sql = <<<'SQL'SELECT i.relname as indexname, pg_get_indexdef(idx.indexrelid, k + 1, TRUE) AS columnnameFROM ( SELECT *, generate_subscripts(indkey, 1) AS k FROM pg_index) idxINNER JOIN pg_class i ON i.oid = idx.indexrelidINNER JOIN pg_class c ON c.oid = idx.indrelidINNER JOIN pg_namespace ns ON c.relnamespace = ns.oidWHERE idx.indisprimary = FALSE AND idx.indisunique = TRUEAND c.relname = :tableName AND ns.nspname = :schemaNameORDER BY i.relname, kSQL ; return $ this -> db -> createCommand ( $ sql , [ ':schemaName' => $ table -> schemaName , ':tableName' => $ table -> name , ] ) -> queryAll ( ) ; }
5085	protected function buildUrl ( $ iTotal , $ iPage , $ iPageOffset ) { $ aParams = [ 'page' => $ iPage + $ iPageOffset , ] ; if ( $ aParams [ 'page' ] <= 0 ) { return null ; } elseif ( $ aParams [ 'page' ] === 1 ) { unset ( $ aParams [ 'page' ] ) ; } $ iTotalPages = ceil ( $ iTotal / static :: CONFIG_PER_PAGE ) ; if ( ! empty ( $ aParams [ 'page' ] ) && $ aParams [ 'page' ] > $ iTotalPages ) { return null ; } $ sUrl = site_url ( ) . uri_string ( ) ; if ( ! empty ( $ aParams ) ) { $ sUrl .= '?' . http_build_query ( $ aParams ) ; } return $ sUrl ; }
9466	private function getServerModules ( array $ requirements ) { if ( ! function_exists ( 'apache_get_modules' ) ) { return collect ( [ ] ) ; } $ modules = apache_get_modules ( ) ; $ requirements = array_combine ( $ requirements , $ requirements ) ; return collect ( $ requirements ) -> transform ( function ( $ requirement ) use ( $ modules ) { return in_array ( $ requirement , $ modules ) ; } ) ; }
3210	function disableOAuth1AccessToken ( $ oauth1AccessToken ) { OAuth1AccessToken :: checkArg ( "oauth1AccessToken" , $ oauth1AccessToken ) ; $ response = self :: doPost ( $ oauth1AccessToken , "1/disable_access_token" ) ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; }
4635	private function attachMailListeners ( EventsCapableInterface $ service , ContainerInterface $ container , array $ mailOptions ) : void { $ listeners = ( array ) ( $ mailOptions [ 'mail_listeners' ] ?? [ ] ) ; if ( empty ( $ listeners ) ) { return ; } $ definitions = [ ] ; $ eventManager = $ service -> getEventManager ( ) ; foreach ( $ listeners as $ listener ) { $ this -> addDefinitions ( $ definitions , $ listener , $ eventManager ) ; } if ( ! empty ( $ definitions ) ) { ( new LazyListenerAggregate ( $ definitions , $ container ) ) -> attach ( $ eventManager ) ; } }
276	private function printHelpMessage ( ) { $ this -> stdout ( $ this -> getHelpSummary ( ) . "\n" ) ; $ helpCommand = Console :: ansiFormat ( 'yii help fixture' , [ Console :: FG_CYAN ] ) ; $ this -> stdout ( "Use $helpCommand to get usage info.\n" ) ; }
2883	public function getRequestInfo ( ) { if ( $ this -> requestInfo === null ) { $ this -> requestInfo = Mage :: getModel ( 'sheep_debug/requestInfo' ) ; } return $ this -> requestInfo ; }
10424	public function parseXml ( $ xml ) { if ( is_null ( $ xml ) ) { return null ; } $ xml = new QuiteSimpleXMLElement ( $ xml ) ; $ xml -> registerXPathNamespaces ( $ this -> namespaces ) ; return $ xml ; }
2489	public function hasMultipleEndpoints ( ) { if ( $ this -> hasMultiple !== null ) { return $ this -> hasMultiple ; } $ endpointSet = array_flip ( $ this -> endpointMap ) ; if ( isset ( $ this -> defaultEndpoint ) ) { $ endpointSet [ $ this -> defaultEndpoint ] = true ; } if ( isset ( $ this -> mainLanguagesEndpoint ) ) { $ endpointSet [ $ this -> mainLanguagesEndpoint ] = true ; } return $ this -> hasMultiple = count ( $ endpointSet ) > 1 ; }
10916	private function logScriptOutput ( ) { $ output_buffers = array ( ) ; $ ob_cnt = 0 ; while ( ob_get_level ( ) > $ this -> output_buffer_level ) { $ output = trim ( ob_get_contents ( ) ) ; ++ $ ob_cnt ; ob_end_clean ( ) ; if ( ! empty ( $ output ) ) { $ lines = explode ( "\n" , $ output ) ; foreach ( $ lines as $ n => $ line ) self :: $ logger -> debug ( "Script output: {0}/{1}: {2}" , [ $ ob_cnt , $ n + 1 , $ line ] ) ; } } }
2322	public static function getPixelValue ( $ size ) { @ trigger_error ( 'Using Image::getPixelValue() has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; $ value = preg_replace ( '/[^0-9.-]+/' , '' , $ size ) ; $ unit = preg_replace ( '/[^acehimnprtvwx%]/' , '' , $ size ) ; switch ( $ unit ) { case '' : case 'px' : return ( int ) round ( $ value ) ; break ; case 'em' : return ( int ) round ( $ value * 16 ) ; break ; case 'ex' : return ( int ) round ( $ value * 16 / 2 ) ; break ; case 'pt' : return ( int ) round ( $ value * 16 / 12 ) ; break ; case 'pc' : return ( int ) round ( $ value * 16 ) ; break ; case 'in' : return ( int ) round ( $ value * 16 * 6 ) ; break ; case 'cm' : return ( int ) round ( $ value * 16 / ( 2.54 / 6 ) ) ; break ; case 'mm' : return ( int ) round ( $ value * 16 / ( 25.4 / 6 ) ) ; break ; case '%' : return ( int ) round ( $ value * 16 / 100 ) ; break ; } return 0 ; }
3723	public function addMetaModelNames ( $ metaModelNames ) { $ this -> metaModelNames = array_unique ( array_merge ( $ this -> metaModelNames , $ metaModelNames ) ) ; return $ this ; }
10745	public function getObjectArray ( $ keys ) : array { return array_map ( function ( $ value ) { return $ this -> createObject ( $ value ) ; } , $ this -> getArray ( $ keys ) ) ; }
9845	public function createSymmetricEncryptedRequest ( string $ method , string $ uri , string $ body , SharedEncryptionKey $ key , array $ headers = [ ] ) : RequestInterface { return new Request ( $ method , Uri :: createFromString ( $ uri ) , new Headers ( $ headers ) , [ ] , [ ] , $ this -> stringToStream ( Base64UrlSafe :: encode ( Simple :: encrypt ( $ body , $ key ) ) ) , [ ] ) ; }
12768	public function get ( string $ key = '' ) { if ( empty ( $ key ) ) { return $ this -> store ; } else { return $ this -> store [ $ key ] ?? null ; } }
5099	public function into ( $ table , array $ fields = null ) { $ this -> setPart ( CmdInsert :: PART_INTO , $ table ) ; if ( ! is_null ( $ fields ) ) { $ this -> placeholder = false ; $ this -> fields = $ fields ; } return $ this ; }
11935	public function primaryKey ( ) { $ pk = $ this -> meta -> schema -> primaryKey ; if ( is_array ( $ pk ) ) { $ ppk = [ ] ; foreach ( $ pk as $ key ) { $ ppk [ ] = $ key ; } return implode ( '.' , $ ppk ) ; } return $ pk ; }
1191	private function addCustomDefinition ( array $ definitionConfig , HTMLPurifier_Config $ configObject = null ) { if ( ! $ configObject ) { $ configObject = HTMLPurifier_Config :: createDefault ( ) ; $ configObject -> loadArray ( $ this -> getConfig ( ) ) ; } $ configObject -> set ( 'HTML.DefinitionID' , $ definitionConfig [ 'id' ] ) ; $ configObject -> set ( 'HTML.DefinitionRev' , $ definitionConfig [ 'rev' ] ) ; if ( ! isset ( $ definitionConfig [ 'debug' ] ) || $ definitionConfig [ 'debug' ] ) { $ configObject -> set ( 'Cache.DefinitionImpl' , null ) ; } if ( $ def = $ configObject -> maybeGetRawHTMLDefinition ( ) ) { if ( ! empty ( $ definitionConfig [ 'attributes' ] ) ) { $ this -> addCustomAttributes ( $ definitionConfig [ 'attributes' ] , $ def ) ; } if ( ! empty ( $ definitionConfig [ 'elements' ] ) ) { $ this -> addCustomElements ( $ definitionConfig [ 'elements' ] , $ def ) ; } } return $ configObject ; }
8619	public function getBlockWithKey ( $ key ) { if ( isset ( $ this -> blocks [ $ key ] ) ) return $ this -> blocks [ $ key ] ; return null ; }
6425	public function getLoginStartUrl ( $ redirecturl ) { $ client = $ this -> getClient ( $ redirecturl ) ; $ authUrl = $ client -> createAuthUrl ( ) ; return $ authUrl ; }
5669	public function clipString ( $ string , $ size , $ position = 0 ) { $ utf8 = false ; if ( function_exists ( 'mb_detect_encoding' ) && mb_detect_encoding ( $ string ) == 'UTF-8' ) { $ utf8 = true ; } $ length = ( $ utf8 == true ) ? mb_strlen ( $ string , "UTF-8" ) : strlen ( $ string ) ; if ( $ length <= $ size ) { return $ string ; } $ position = min ( $ position , $ length ) ; $ start = ( $ size / 2 > $ position ? 0 : $ position - $ size / 2 ) ; if ( $ start + $ size > $ length ) { $ start = $ length - $ size ; } $ string = ( $ utf8 == true ) ? mb_substr ( $ string , $ start , $ size ) : substr ( $ string , $ start , $ size ) ; return ( $ start > 0 ? '...' : '' ) . $ string . ( $ start + $ size < $ length ? '...' : '' ) ; }
3223	function createTemporaryDirectLink ( $ path ) { Path :: checkArgNonRoot ( "path" , $ path ) ; $ response = $ this -> doPost ( $ this -> apiHost , $ this -> appendFilePath ( "1/media" , $ path ) ) ; if ( $ response -> statusCode === 404 ) return null ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; $ j = RequestUtil :: parseResponseJson ( $ response -> body ) ; $ url = self :: getField ( $ j , "url" ) ; $ expires = self :: parseDateTime ( self :: getField ( $ j , "expires" ) ) ; return array ( $ url , $ expires ) ; }
4050	private function prepareInputScreen ( $ modelName , $ screen ) : array { if ( null === $ metaModel = $ this -> factory -> getMetaModel ( $ modelName ) ) { throw new \ InvalidArgumentException ( 'Could not retrieve MetaModel ' . $ modelName ) ; } $ caption = [ '' => $ metaModel -> getName ( ) ] ; $ description = [ '' => $ metaModel -> getName ( ) ] ; foreach ( StringUtil :: deserialize ( $ screen [ 'backendcaption' ] , true ) as $ languageEntry ) { $ langCode = $ languageEntry [ 'langcode' ] ; $ caption [ $ langCode ] = ! empty ( $ label = $ languageEntry [ 'label' ] ) ? $ label : $ caption [ '' ] ; $ description [ $ langCode ] = ! empty ( $ title = $ languageEntry [ 'description' ] ) ? $ title : $ description [ '' ] ; if ( $ metaModel -> getFallbackLanguage ( ) === $ langCode ) { $ caption [ '' ] = $ label ; $ description [ '' ] = $ title ; } } $ result = [ 'meta' => $ screen , 'properties' => $ this -> fetchPropertiesFor ( $ screen [ 'id' ] , $ metaModel ) , 'conditions' => $ this -> fetchConditions ( $ screen [ 'id' ] ) , 'groupSort' => $ this -> fetchGroupSort ( $ screen [ 'id' ] , $ metaModel ) , 'label' => $ caption , 'description' => $ description ] ; $ bySetting = $ this -> buildConditionTree ( $ result [ 'conditions' ] ) ; $ result [ 'legends' ] = $ this -> convertLegends ( $ result [ 'properties' ] , $ metaModel , $ bySetting ) ; return $ result ; }
1051	public static function getArgumentValues ( $ def , $ node , $ variableValues = null ) { if ( empty ( $ def -> args ) ) { return [ ] ; } $ argumentNodes = $ node -> arguments ; if ( empty ( $ argumentNodes ) ) { return [ ] ; } $ argumentValueMap = [ ] ; foreach ( $ argumentNodes as $ argumentNode ) { $ argumentValueMap [ $ argumentNode -> name -> value ] = $ argumentNode -> value ; } return static :: getArgumentValuesForMap ( $ def , $ argumentValueMap , $ variableValues , $ node ) ; }
10648	private function normalizeRules ( ) { foreach ( $ this -> rules as $ scope => $ rules ) { foreach ( $ rules as $ field => $ rule ) { if ( is_array ( $ rule ) ) { $ this -> rules [ $ scope ] [ $ field ] = implode ( '|' , $ rule ) ; } } } }
10965	public static function getStandardPort ( $ scheme = null ) { if ( $ scheme === null ) { $ scheme = self :: getScheme ( ) ; } if ( isset ( self :: $ schemes [ $ scheme ] ) ) { return self :: $ schemes [ $ scheme ] ; } return 0 ; }
3145	public function pause ( RunnerServiceContext $ context ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ context -> getTestSession ( ) -> suspend ( ) ; $ this -> persist ( $ context ) ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'pause' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } return true ; }
2496	private function getIndexFieldName ( int $ depth ) : string { if ( $ depth === 0 ) { return self :: $ fieldName ; } return sprintf ( self :: $ relatedContentFieldName , $ depth ) ; }
10517	private function getMediaIdentifiers ( $ values ) { $ identifiers = [ ] ; foreach ( $ values as $ key => $ id ) { if ( is_int ( $ key ) ) { $ identifiers [ ] = $ id ; } } return $ identifiers ; }
5803	public function whitelist ( array $ whitelist ) { $ this -> _definitions = array ( ) ; foreach ( $ whitelist as $ definition ) { if ( is_object ( $ definition ) ) { if ( $ definition instanceof Definition \ IDefinition ) $ definitionObject = $ definition ; else throw new \ InvalidArgumentException ( 'Definition objects must implement IDefinition' ) ; } elseif ( preg_match ( '/[a-z:\/]/' , $ definition ) === 0 ) $ definitionObject = new Definition \ IPv4Address ( $ definition ) ; elseif ( preg_match ( '/[a-z:]/' , $ definition ) === 0 ) $ definitionObject = new Definition \ IPv4CIDR ( $ definition ) ; elseif ( preg_match ( '/^[0-9a-f:]+$/' , $ definition ) ) $ definitionObject = new Definition \ IPv6Address ( $ definition ) ; elseif ( preg_match ( '/^[0-9a-f:\/]+$/' , $ definition ) ) $ definitionObject = new Definition \ IPv6CIDR ( $ definition ) ; elseif ( preg_match ( '/^\*\.[\w\.\-]+$/' , $ definition ) ) $ definitionObject = new Definition \ WildcardDomain ( $ definition ) ; elseif ( preg_match ( '/^[\w\.\-]+$/' , $ definition ) ) $ definitionObject = new Definition \ Domain ( $ definition ) ; else throw new \ InvalidArgumentException ( 'Unable to parse definition "' . $ definition . '"' ) ; $ this -> _definitions [ ] = $ definitionObject ; } }
739	protected function saveAssignments ( ) { $ assignmentData = [ ] ; foreach ( $ this -> assignments as $ userId => $ assignments ) { foreach ( $ assignments as $ name => $ assignment ) { $ assignmentData [ $ userId ] [ ] = $ assignment -> roleName ; } } $ this -> saveToFile ( $ assignmentData , $ this -> assignmentFile ) ; }
6829	protected function prioritizeAssignment ( Stock \ StockAssignmentInterface $ assignment ) { if ( $ assignment -> isFullyShipped ( ) || $ assignment -> isFullyShippable ( ) ) { return false ; } if ( 0 >= $ quantity = $ assignment -> getSoldQuantity ( ) - $ assignment -> getShippableQuantity ( ) ) { return false ; } $ changed = false ; $ helper = new PrioritizeHelper ( $ this -> unitResolver ) ; $ sourceUnit = $ assignment -> getStockUnit ( ) ; $ candidates = $ helper -> getUnitCandidates ( $ assignment , $ quantity ) ; foreach ( $ candidates as $ candidate ) { $ targetUnit = $ candidate -> unit ; if ( ( 0 < $ quantity - $ targetUnit -> getReservableQuantity ( ) ) && ( $ combination = $ candidate -> combination ) ) { foreach ( $ combination -> map as $ id => $ qty ) { if ( null === $ a = $ candidate -> getAssignmentById ( $ id ) ) { throw new StockLogicException ( "Assignment not found." ) ; } $ this -> moveAssignment ( $ a , $ sourceUnit , min ( $ qty , $ quantity ) ) ; } } $ delta = min ( $ quantity , $ targetUnit -> getReservableQuantity ( ) ) ; $ quantity -= $ this -> moveAssignment ( $ assignment , $ targetUnit , $ delta ) ; $ changed = true ; if ( 0 >= $ quantity ) { break ; } } return $ changed ; }
687	protected function getChildrenRecursive ( $ name , $ childrenList , & $ result ) { if ( isset ( $ childrenList [ $ name ] ) ) { foreach ( $ childrenList [ $ name ] as $ child ) { $ result [ $ child ] = true ; $ this -> getChildrenRecursive ( $ child , $ childrenList , $ result ) ; } } }
6310	private function getCommand ( DatabaseObjectInterface $ databaseObject , $ isCreate = true ) { if ( $ databaseObject instanceof Column ) { $ command = $ this -> container -> get ( $ isCreate ? 'rentgen.add_column' : 'rentgen.drop_column' ) -> setColumn ( $ databaseObject ) ; } elseif ( $ databaseObject instanceof ConstraintInterface ) { $ command = $ this -> container -> get ( $ isCreate ? 'rentgen.add_constraint' : 'rentgen.drop_constraint' ) -> setConstraint ( $ databaseObject ) ; } elseif ( $ databaseObject instanceof Index ) { $ command = $ this -> container -> get ( $ isCreate ? 'rentgen.create_index' : 'rentgen.drop_index' ) -> setIndex ( $ databaseObject ) ; } elseif ( $ databaseObject instanceof Schema ) { $ command = $ this -> container -> get ( $ isCreate ? 'rentgen.create_schema' : 'rentgen.drop_schema' ) -> setSchema ( $ databaseObject ) ; } elseif ( $ databaseObject instanceof Table ) { $ command = $ this -> container -> get ( $ isCreate ? 'rentgen.create_table' : 'rentgen.drop_table' ) -> setTable ( $ databaseObject ) ; } else { throw new \ Exception ( sprintf ( "Class %s is not supported" , get_class ( $ databaseObject ) ) ) ; } return $ command ; }
3720	protected function validator ( $ varInput ) { if ( is_array ( $ varInput ) ) { $ value = array ( ) ; foreach ( $ varInput as $ key => $ input ) { $ value [ $ key ] = parent :: validator ( $ input ) ; } return $ value ; } return parent :: validator ( trim ( $ varInput ) ) ; }
581	public function getAssetManager ( ) { if ( ! is_object ( $ this -> _assetManager ) ) { $ options = $ this -> _assetManager ; if ( ! isset ( $ options [ 'class' ] ) ) { $ options [ 'class' ] = 'yii\\web\\AssetManager' ; } if ( ! isset ( $ options [ 'basePath' ] ) ) { throw new Exception ( "Please specify 'basePath' for the 'assetManager' option." ) ; } if ( ! isset ( $ options [ 'baseUrl' ] ) ) { throw new Exception ( "Please specify 'baseUrl' for the 'assetManager' option." ) ; } if ( ! isset ( $ options [ 'forceCopy' ] ) ) { $ options [ 'forceCopy' ] = true ; } $ this -> _assetManager = Yii :: createObject ( $ options ) ; } return $ this -> _assetManager ; }
529	public function actionPackage ( array $ what ) { $ this -> validateWhat ( $ what , [ 'app' ] ) ; $ versions = $ this -> getCurrentVersions ( $ what ) ; $ this -> stdout ( "You are about to generate packages for the following things:\n\n" ) ; foreach ( $ what as $ ext ) { if ( strncmp ( 'app-' , $ ext , 4 ) === 0 ) { $ this -> stdout ( ' - ' ) ; $ this -> stdout ( substr ( $ ext , 4 ) , Console :: FG_RED ) ; $ this -> stdout ( ' application version ' ) ; } elseif ( $ ext === 'framework' ) { $ this -> stdout ( ' - Yii Framework version ' ) ; } else { $ this -> stdout ( ' - ' ) ; $ this -> stdout ( $ ext , Console :: FG_RED ) ; $ this -> stdout ( ' extension version ' ) ; } $ this -> stdout ( $ versions [ $ ext ] , Console :: BOLD ) ; $ this -> stdout ( "\n" ) ; } $ this -> stdout ( "\n" ) ; $ packagePath = "{$this->basePath}/packages" ; $ this -> stdout ( "Packages will be stored in $packagePath\n\n" ) ; if ( ! $ this -> confirm ( 'Continue?' , false ) ) { $ this -> stdout ( "Canceled.\n" ) ; return 1 ; } foreach ( $ what as $ ext ) { if ( $ ext === 'framework' ) { throw new Exception ( 'Can not package framework.' ) ; } elseif ( strncmp ( 'app-' , $ ext , 4 ) === 0 ) { $ this -> packageApplication ( substr ( $ ext , 4 ) , $ versions [ $ ext ] , $ packagePath ) ; } else { throw new Exception ( 'Can not package extension.' ) ; } } $ this -> stdout ( "\ndone. verify the versions composer installed above and push it to github!\n\n" ) ; return 0 ; }
9342	public function populate ( $ arrAll ) { $ this -> arr = array_chunk ( $ arrAll , $ this -> size -> cols ) ; return $ this ; }
11199	public function processDelete ( $ name , $ container = false ) { if ( ! $ container ) { $ container = $ this ; } if ( isset ( $ container -> singleton -> $ name ) ) { unset ( $ container -> singleton -> $ name ) ; return true ; } if ( isset ( $ container -> signature -> $ name ) ) { unset ( $ container -> signature -> $ name ) ; return true ; } elseif ( $ container -> parent ) { return $ container -> processDelete ( $ name , $ container -> parent ) ; } return false ; }
5289	protected static function requestStream ( $ url , $ params ) { $ opts = array ( 'http' => array ( 'method' => 'POST' , 'header' => implode ( "\n" , self :: getHeaders ( ) ) , 'content' => json_encode ( $ params ) , 'timeout' => self :: $ requestTimeout , 'ignore_errors' => true , ) ) ; $ context = stream_context_create ( $ opts ) ; return file_get_contents ( $ url , false , $ context ) ; }
9415	public function precision ( $ n ) { if ( ! is_numeric ( $ n ) || $ n < 0 ) { throw new \ InvalidArgumentException ( 'Precision must be positive number' ) ; } $ this -> int_precision = ( integer ) $ n ; }
5403	protected function fixPath ( $ path ) { if ( substr ( $ path , 0 , 1 ) != '/' ) { $ path = '/' . $ path ; } if ( substr ( $ path , - 1 , 1 ) != '/' ) { $ path .= '/' ; } return $ path ; }
2516	public function pnrCreatePnr ( RequestOptions \ PnrCreatePnrOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'PNR_AddMultiElements' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; }
4676	public function render ( $ region = "main" ) { if ( ! isset ( $ this -> views [ $ region ] ) ) { return $ this ; } mergesort ( $ this -> views [ $ region ] , function ( $ viewA , $ viewB ) { $ sortA = $ viewA -> sortOrder ( ) ; $ sortB = $ viewB -> sortOrder ( ) ; if ( $ sortA == $ sortB ) { return 0 ; } return $ sortA < $ sortB ? - 1 : 1 ; } ) ; foreach ( $ this -> views [ $ region ] as $ view ) { $ view -> render ( $ this -> di ) ; } }
9841	public function createSealedJsonRequest ( string $ method , string $ uri , array $ arrayToJsonify , SealingPublicKey $ key , array $ headers = [ ] ) : RequestInterface { if ( empty ( $ headers [ 'Content-Type' ] ) ) { $ headers [ 'Content-Type' ] = 'application/json' ; } $ body = \ json_encode ( $ arrayToJsonify , JSON_PRETTY_PRINT ) ; if ( ! \ is_string ( $ body ) ) { throw new InvalidMessageException ( 'Cannot JSON-encode this message.' ) ; } return $ this -> createSealedRequest ( $ method , $ uri , $ body , $ key , $ headers ) ; }
5473	public function isMatch ( $ widget ) { if ( method_exists ( $ widget , 'isLabel' ) ) { if ( $ widget -> isLabel ( $ this -> label ) ) { return true ; } } return ( $ widget -> getName ( ) == $ this -> label ) ; }
3416	protected function normalizeFieldsForSave ( $ selectedFields ) { $ fields = [ ] ; if ( $ this -> fields === null ) { return [ ] ; } foreach ( $ this -> fields as $ field => $ value ) { if ( ! $ this -> fieldShouldNotBeSaved ( $ field , $ value , $ selectedFields ) ) { $ fields [ $ field ] = $ value ; } } return $ fields ? : null ; }
8696	public function handle ( ) { $ config = $ this -> option ( 'config' ) ; if ( ! $ config ) { throw new Exception ( 'Config option is required.' ) ; } $ configPath = realpath ( $ config ) ; if ( ! file_exists ( $ configPath ) ) { throw new Exception ( 'Configuration file not found.' ) ; } $ config = require ( $ configPath ) ; $ this -> info ( sprintf ( 'Configuring with file "%s".' , $ configPath ) ) ; $ this -> getRbacService ( ) -> configure ( $ config ) ; $ this -> info ( 'Configuration done.' ) ; }
8560	public function setProduct ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'Product' ] [ 'FieldValue' ] = $ value ; return $ this ; }
11058	protected function _getDataStore ( ) { return $ this -> dataStore === null ? $ this -> dataStore = $ this -> _createDataStore ( ) : $ this -> dataStore ; }
6691	public function addRoute ( $ httpMethod , $ route , $ handler , array $ middleware = [ ] ) { if ( ! $ handler instanceof HandlerContainer ) { $ handler = new HandlerContainer ( $ handler , array_merge ( $ this -> middlewareStack , $ middleware ) ) ; } else { $ handler -> addMiddleware ( array_merge ( $ this -> middlewareStack , $ middleware ) ) ; } $ handler = serialize ( $ handler ) ; $ route = $ this -> currentGroupPrefix . $ route ; $ routeDatas = $ this -> routeParser -> parse ( $ route ) ; foreach ( ( array ) $ httpMethod as $ method ) { foreach ( $ routeDatas as $ routeData ) { $ this -> dataGenerator -> addRoute ( $ method , $ routeData , $ handler ) ; } } }
4539	public function setIndividualUuid ( ? string $ individualUuid ) { $ this -> individualUuid = $ individualUuid ; $ this -> _individualUuid = true ; return $ this ; }
6987	protected function fillFromCustomer ( ContextInterface $ context , CustomerInterface $ customer ) : void { if ( null === $ context -> getCustomerGroup ( ) ) { $ context -> setCustomerGroup ( $ customer -> getCustomerGroup ( ) ) ; } if ( null === $ context -> getInvoiceCountry ( ) ) { if ( null !== $ address = $ customer -> getDefaultInvoiceAddress ( true ) ) { $ context -> setInvoiceCountry ( $ address -> getCountry ( ) ) ; } } if ( null === $ context -> getDeliveryCountry ( ) ) { if ( null !== $ address = $ customer -> getDefaultDeliveryAddress ( true ) ) { $ context -> setDeliveryCountry ( $ address -> getCountry ( ) ) ; } } }
4313	protected function autoloader ( $ className ) { $ className = \ ltrim ( $ className , '\\' ) ; if ( ! \ strpos ( $ className , '\\' ) ) { return ; } $ psr4Map = array ( 'bdk\\Debug\\' => __DIR__ , 'bdk\\PubSub\\' => __DIR__ . '/../PubSub' , 'bdk\\ErrorHandler\\' => __DIR__ . '/../ErrorHandler' , ) ; foreach ( $ psr4Map as $ namespace => $ dir ) { if ( \ strpos ( $ className , $ namespace ) === 0 ) { $ rel = \ substr ( $ className , \ strlen ( $ namespace ) ) ; $ rel = \ str_replace ( '\\' , '/' , $ rel ) ; require $ dir . '/' . $ rel . '.php' ; return ; } } $ classMap = array ( 'bdk\\ErrorHandler' => __DIR__ . '/../ErrorHandler/ErrorHandler.php' , ) ; if ( isset ( $ classMap [ $ className ] ) ) { require $ classMap [ $ className ] ; } }
1413	public function resourceDoesNotExist ( string $ path ) : ErrorInterface { return new Error ( null , null , Response :: HTTP_NOT_FOUND , $ this -> trans ( 'resource_not_found' , 'code' ) , $ this -> trans ( 'resource_not_found' , 'title' ) , $ this -> trans ( 'resource_not_found' , 'detail' ) , $ this -> pointer ( $ path ) ) ; }
6399	public function createEvents ( array $ events ) { $ results = [ ] ; foreach ( $ events as $ index => $ opts ) { $ route = isset ( $ opts [ 'eventname' ] ) ? $ opts [ 'eventname' ] : '' ; if ( isset ( static :: $ routes [ $ route ] ) && ( $ opts [ 'userid' ] > 0 || $ opts [ 'relateduserid' ] > 0 ) ) { try { $ event = '\LogExpander\Events\\' . static :: $ routes [ $ route ] ; array_push ( $ results , ( new $ event ( $ this -> repo ) ) -> read ( $ opts ) ) ; } catch ( \ Exception $ e ) { } } } return $ results ; }
12666	public function edit ( $ sourceDir , array $ options , $ username , $ values ) { $ this -> resolveOptions ( $ options ) ; $ this -> init ( $ sourceDir , $ options , $ username ) ; $ this -> createContributorDir ( $ sourceDir , $ options , $ username ) ; $ filename = sprintf ( '%s/blocks/%s.json' , $ this -> getDirInUse ( ) , $ options [ "blockname" ] ) ; $ currentBlock = $ options [ "baseBlock" ] = JsonTools :: jsonDecode ( FilesystemTools :: readFile ( $ filename ) ) ; $ values = $ this -> parseChildren ( $ values ) ; $ block = JsonTools :: join ( $ currentBlock , $ values ) ; $ encodedBlock = json_encode ( $ block ) ; $ blockClass = BlockFactory :: getBlockClass ( $ block [ "type" ] ) ; $ event = Dispatcher :: dispatch ( BlockEvents :: BLOCK_EDITING , new BlockEditingEvent ( $ this -> serializer , $ filename , $ encodedBlock , $ blockClass ) ) ; $ blockContent = $ event -> getFileContent ( ) ; FilesystemTools :: writeFile ( $ filename , $ blockContent ) ; Dispatcher :: dispatch ( BlockEvents :: BLOCK_EDITED , new BlockEditedEvent ( $ this -> serializer , $ filename , $ encodedBlock , $ blockClass ) ) ; DataLogger :: log ( sprintf ( 'Block "%s" has been edited on the "%s" slot on page "%s" for the "%s_%s" language' , $ options [ "blockname" ] , $ options [ "slot" ] , $ options [ "page" ] , $ options [ "language" ] , $ options [ "country" ] ) ) ; }
9344	public function addCol ( $ arr_col ) { if ( isset ( $ this -> arr [ 0 ] ) && ( count ( $ this -> arr [ 0 ] ) == $ this -> size -> cols ) ) { throw new \ OutOfRangeException ( sprintf ( 'You cannot add another column! Max number of columns is %d' , $ this -> size -> cols ) ) ; } if ( count ( $ arr_col ) != $ this -> size -> rows ) { throw new \ InvalidArgumentException ( 'New column must have same amout of rows than previous columns.' ) ; } $ arr_col = array_values ( $ arr_col ) ; foreach ( $ arr_col as $ k => $ v ) { $ this -> arr [ $ k ] [ ] = $ arr_col [ $ k ] ; } return $ this ; }
10805	protected function build ( ) { $ settings = $ this -> getSettings ( ) ; $ this -> beforeBuild ( ) ; $ configs = $ this -> getConfig ( ) ; $ result = [ $ this -> getType ( ) ] ; $ sp = $ settings [ 'seperator' ] ; $ in = $ settings [ 'indent' ] ; $ si = $ sp . $ in ; foreach ( $ configs as $ pos => $ part ) { if ( isset ( $ this -> before [ $ pos ] ) ) { $ result [ ] = join ( $ sp , $ this -> before [ $ pos ] ) ; } $ built = call_user_func ( [ $ this , $ part [ 'func' ] ] ) ; if ( ! empty ( $ built ) ) { $ prefix = $ part [ 'prefix' ] . ( empty ( $ part [ 'prefix' ] ) ? ( $ part [ 'indent' ] ? $ in : '' ) : $ si ) ; $ result [ ] = $ prefix . join ( $ part [ 'join' ] . $ si , $ built ) ; } if ( isset ( $ this -> after [ $ pos ] ) ) { $ result [ ] = join ( $ sp , $ this -> after [ $ pos ] ) ; } } return join ( $ sp , $ result ) ; }
1793	private function getHostAndPort ( string $ domain ) : array { if ( false !== strpos ( $ domain , ':' ) ) { return explode ( ':' , $ domain , 2 ) ; } return [ $ domain , null ] ; }
3645	public function old ( string $ key , $ default = null , bool $ trim = true , bool $ clean = true ) { $ value = $ this -> request -> old ( $ key , $ default ) ; return $ this -> clean ( $ value , $ trim , $ clean ) ; }
4296	public function assert ( $ assertion , $ msg = null ) { array ( $ msg ) ; $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args ) ; $ assertion = \ array_shift ( $ args ) ; if ( ! $ assertion ) { if ( ! $ args ) { $ callerInfo = $ this -> utilities -> getCallerInfo ( ) ; $ args [ ] = 'Assertion failed in ' . $ callerInfo [ 'file' ] . ' on line ' . $ callerInfo [ 'line' ] ; } $ this -> appendLog ( 'assert' , $ args , $ meta ) ; } }
1616	public function count ( $ q = '*' , $ db = null ) { if ( $ this -> emulateExecution ) { return 0 ; } if ( $ this -> where === null ) { $ modelClass = $ this -> modelClass ; if ( $ db === null ) { $ db = $ modelClass :: getDb ( ) ; } return $ db -> executeCommand ( 'LLEN' , [ $ modelClass :: keyPrefix ( ) ] ) ; } else { return $ this -> executeScript ( $ db , 'Count' ) ; } }
4695	public function limitBy ( ? int $ limit , int $ offset = null ) : self { $ this -> dirty ( ) ; $ this -> limit = $ limit || $ offset ? [ $ limit , $ offset ] : null ; return $ this ; }
2783	public function renderSummaryReport ( Collector $ collector ) { $ pkills = str_pad ( $ collector -> getKilledCount ( ) , 8 , ' ' , STR_PAD_LEFT ) ; $ pescapes = str_pad ( $ collector -> getEscapeCount ( ) , 8 , ' ' , STR_PAD_LEFT ) ; $ perrors = str_pad ( $ collector -> getErrorCount ( ) , 8 , ' ' , STR_PAD_LEFT ) ; $ ptimeouts = str_pad ( $ collector -> getTimeoutCount ( ) , 8 , ' ' , STR_PAD_LEFT ) ; $ pshadows = str_pad ( $ collector -> getShadowCount ( ) , 8 , ' ' , STR_PAD_LEFT ) ; $ this -> write ( PHP_EOL , false ) ; $ this -> write ( $ collector -> getTotalCount ( ) . ' mutations were generated:' ) ; $ this -> write ( $ pkills . ' mutants were killed' ) ; $ this -> write ( $ pshadows . ' mutants were not covered by tests' ) ; $ this -> write ( $ pescapes . ' covered mutants were not detected' ) ; $ this -> write ( $ perrors . ' fatal errors were encountered' ) ; $ this -> write ( $ ptimeouts . ' time outs were encountered' ) ; $ this -> write ( PHP_EOL , false ) ; $ vanquishedTotal = $ collector -> getVanquishedTotal ( ) ; $ measurableTotal = $ collector -> getMeasurableTotal ( ) ; if ( $ measurableTotal !== 0 ) { $ detectionRateTested = round ( 100 * ( $ vanquishedTotal / $ measurableTotal ) ) ; } else { $ detectionRateTested = 0 ; } if ( $ collector -> getTotalCount ( ) !== 0 ) { $ coveredRate = round ( 100 * ( ( $ measurableTotal ) / $ collector -> getTotalCount ( ) ) ) ; $ detectionRateAll = round ( 100 * ( $ vanquishedTotal / $ collector -> getTotalCount ( ) ) ) ; } else { $ coveredRate = 0 ; $ detectionRateAll = 0 ; } $ this -> write ( 'Metrics:' ) ; $ this -> write ( ' Mutation Score Indicator (MSI): <options=bold>' . $ detectionRateAll . '%</options=bold>' ) ; $ this -> write ( ' Mutation Code Coverage: <options=bold>' . $ coveredRate . '%</options=bold>' ) ; $ this -> write ( ' Covered Code MSI: <options=bold>' . $ detectionRateTested . '%</options=bold>' ) ; $ this -> write ( PHP_EOL , false ) ; $ this -> write ( 'Remember that some mutants will inevitably be harmless (i.e. false positives).' ) ; }
8346	public static function route ( $ method , $ path , $ action ) { if ( self :: $ isInit === true ) { self :: $ routes [ ] = array ( 'type' => 'route' , 'method' => $ method , 'path' => $ path , 'action' => $ action , 'namespace' => self :: $ namespace , 'subdomain' => self :: $ subdomain , 'uri' => self :: $ uri ) ; } }
6429	public function getLoginStartUrl ( $ redirecturl ) { $ facebook = $ this -> getFacebookObject ( ) ; $ helper = $ facebook -> getRedirectLoginHelper ( ) ; $ permissions = [ 'email' ] ; $ loginUrl = $ helper -> getLoginUrl ( $ redirecturl , $ permissions ) ; return $ loginUrl ; }
12344	public function showAction ( Post $ post ) { $ deleteForm = $ this -> createDeleteForm ( $ post ) ; return array ( 'entity' => $ post , 'delete_form' => $ deleteForm -> createView ( ) , ) ; }
11356	public function getInputFilter ( ) { if ( $ this -> filter ) { return $ this -> filter ; } $ specifications = [ ] ; if ( $ this -> object && $ this -> object instanceof InputFilterProviderInterface ) { $ specifications = $ this -> object -> getInputFilterSpecification ( ) ; } if ( $ this instanceof InputFilterProviderInterface ) { $ specifications = ArrayUtils :: merge ( $ specifications , $ this -> getInputFilterSpecification ( ) ) ; } $ this -> addRequiredAttributeToFields ( $ specifications ) ; if ( ! empty ( $ specifications ) && null === $ this -> baseFieldset ) { $ formFactory = $ this -> getFormFactory ( ) ; $ inputFactory = $ formFactory -> getInputFilterFactory ( ) ; if ( ! ( $ this -> filter instanceof InputFilterInterface ) ) { $ this -> filter = new InputFilter ( ) ; $ this -> filter -> setFactory ( $ inputFactory ) ; } foreach ( $ specifications as $ name => $ specification ) { $ input = $ inputFactory -> createInput ( $ specification ) ; $ this -> filter -> add ( $ input , $ name ) ; } } return parent :: getInputFilter ( ) ; }
651	public function dropView ( $ viewName ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> dropView ( $ viewName ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ viewName ) ; }
7099	private function ceilComparison ( UnitCandidate $ a , UnitCandidate $ b , $ property , $ quantity ) { if ( $ a -> { $ property } >= $ quantity && $ b -> { $ property } < $ quantity ) { return - 1 ; } if ( $ a -> { $ property } < $ quantity && $ b -> { $ property } >= $ quantity ) { return 1 ; } return false ; }
800	private function findStart ( Tokens $ tokens , $ index ) { while ( ! $ tokens [ $ index ] -> equalsAny ( [ '$' , [ T_VARIABLE ] ] ) ) { if ( $ tokens [ $ index ] -> equals ( ']' ) ) { $ index = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_INDEX_SQUARE_BRACE , $ index ) ; } elseif ( $ tokens [ $ index ] -> isGivenKind ( CT :: T_DYNAMIC_PROP_BRACE_CLOSE ) ) { $ index = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_DYNAMIC_PROP_BRACE , $ index ) ; } elseif ( $ tokens [ $ index ] -> isGivenKind ( CT :: T_DYNAMIC_VAR_BRACE_CLOSE ) ) { $ index = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_DYNAMIC_VAR_BRACE , $ index ) ; } elseif ( $ tokens [ $ index ] -> isGivenKind ( CT :: T_ARRAY_INDEX_CURLY_BRACE_CLOSE ) ) { $ index = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_ARRAY_INDEX_CURLY_BRACE , $ index ) ; } else { $ index = $ tokens -> getPrevMeaningfulToken ( $ index ) ; } } while ( $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ index ) ] -> equals ( '$' ) ) { $ index = $ tokens -> getPrevMeaningfulToken ( $ index ) ; } if ( $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ index ) ] -> isGivenKind ( T_OBJECT_OPERATOR ) ) { return $ this -> findStart ( $ tokens , $ tokens -> getPrevMeaningfulToken ( $ index ) ) ; } return $ index ; }
1311	public function checkSignature ( Request $ request , Consumer $ consumer , Token $ token , $ signature ) { $ built = $ this -> buildSignature ( $ request , $ consumer , $ token ) ; if ( strlen ( $ built ) == 0 || strlen ( $ signature ) == 0 ) { return false ; } if ( strlen ( $ built ) != strlen ( $ signature ) ) { return false ; } $ result = 0 ; for ( $ i = 0 ; $ i < strlen ( $ signature ) ; $ i ++ ) { $ result |= ord ( $ built { $ i } ) ^ ord ( $ signature { $ i } ) ; } return $ result == 0 ; }
10434	protected function prepareTypeServiceConfigs ( $ serviceConfig , $ typeConfig , $ type ) { return array_merge ( $ serviceConfig , $ typeConfig [ 'config' ] , [ 'entity_class' => $ typeConfig [ 'entity_class' ] , 'document_class' => $ typeConfig [ 'document_class' ] , 'document_type' => $ type , ] ) ; }
5576	public function clickSubmitById ( $ id , $ additional = false ) { if ( ! ( $ form = $ this -> page -> getFormBySubmit ( new SelectById ( $ id ) ) ) ) { return false ; } $ success = $ this -> load ( $ form -> getAction ( ) , $ form -> submitButton ( new SelectById ( $ id ) , $ additional ) ) ; return ( $ success ? $ this -> getContent ( ) : $ success ) ; }
9699	public function text ( $ paragraphs = null ) { $ this -> paragraphs = $ paragraphs ; $ this -> params [ 'plaintext' ] = true ; return $ this -> generate ( ) ; }
7028	static function getDefaultImplementations ( ) { return [ Cart \ Model \ CartInterface :: class => Cart \ Entity \ Cart :: class , Cart \ Model \ CartAddressInterface :: class => Cart \ Entity \ CartAddress :: class , Customer \ Model \ CustomerInterface :: class => Customer \ Entity \ Customer :: class , Customer \ Model \ CustomerGroupInterface :: class => Customer \ Entity \ CustomerGroup :: class , Customer \ Model \ CustomerAddressInterface :: class => Customer \ Entity \ CustomerAddress :: class , Order \ Model \ OrderInterface :: class => Order \ Entity \ Order :: class , Order \ Model \ OrderAddressInterface :: class => Order \ Entity \ OrderAddress :: class , Payment \ Model \ PaymentMethodInterface :: class => Payment \ Entity \ PaymentMethod :: class , Payment \ Model \ PaymentTermInterface :: class => Payment \ Entity \ PaymentTerm :: class , Quote \ Model \ QuoteInterface :: class => Quote \ Entity \ Quote :: class , Quote \ Model \ QuoteAddressInterface :: class => Quote \ Entity \ QuoteAddress :: class , Shipment \ Model \ ShipmentMethodInterface :: class => Shipment \ Entity \ ShipmentMethod :: class , Supplier \ Model \ SupplierInterface :: class => Supplier \ Entity \ Supplier :: class , Supplier \ Model \ SupplierAddressInterface :: class => Supplier \ Entity \ SupplierAddress :: class , Supplier \ Model \ SupplierDeliveryInterface :: class => Supplier \ Entity \ SupplierDelivery :: class , Supplier \ Model \ SupplierOrderInterface :: class => Supplier \ Entity \ SupplierOrder :: class , Supplier \ Model \ SupplierProductInterface :: class => Supplier \ Entity \ SupplierProduct :: class , Support \ Model \ TicketInterface :: class => Support \ Entity \ Ticket :: class , Support \ Model \ TicketMessageInterface :: class => Support \ Entity \ TicketMessage :: class , ] ; }
142	public function getInstallPath ( PackageInterface $ package ) { $ installer = $ this -> getInstaller ( $ package -> getType ( ) ) ; return $ installer -> getInstallPath ( $ package ) ; }
2209	public function fetchRow ( ) { if ( $ this -> intIndex >= $ this -> count ( ) - 1 ) { return false ; } $ this -> arrCache = array_values ( $ this -> resultSet [ ++ $ this -> intIndex ] ) ; return $ this -> arrCache ; }
12590	public function getDataTablesI18nAction ( ) { $ locale = $ this -> get ( 'request_stack' ) -> getCurrentRequest ( ) -> getLocale ( ) ; $ format = $ this -> get ( 'request_stack' ) -> getCurrentRequest ( ) -> getRequestFormat ( ) ; return $ this -> render ( 'AdminBundle:Default/DataTables_i18n:' . $ locale . '.txt.' . $ format ) ; }
1085	private function parseName ( ) { $ token = $ this -> expect ( Token :: NAME ) ; return new NameNode ( [ 'value' => $ token -> value , 'loc' => $ this -> loc ( $ token ) , ] ) ; }
8366	public static function registerMapping ( array $ config ) { self :: validateConfig ( $ config ) ; if ( isset ( self :: $ mappings [ $ config [ 'name' ] ] ) === false ) { self :: $ mappings [ $ config [ 'name' ] ] = array ( 'config' => $ config ) ; Database :: registerDatabase ( $ config [ 'database' ] ) ; } else { Logger :: get ( ) -> warning ( 'mapping with name "' . $ config [ 'name' ] . '" was already set' ) ; } }
268	protected function getContextMessage ( ) { $ context = ArrayHelper :: filter ( $ GLOBALS , $ this -> logVars ) ; foreach ( $ this -> maskVars as $ var ) { if ( ArrayHelper :: getValue ( $ context , $ var ) !== null ) { ArrayHelper :: setValue ( $ context , $ var , '***' ) ; } } $ result = [ ] ; foreach ( $ context as $ key => $ value ) { $ result [ ] = "\${$key} = " . VarDumper :: dumpAsString ( $ value ) ; } return implode ( "\n\n" , $ result ) ; }
2162	public function run35Update ( ) { $ this -> Database -> query ( "ALTER TABLE `tl_member` CHANGE `username` `username` varchar(64) COLLATE utf8_bin NULL" ) ; $ this -> Database -> query ( "UPDATE `tl_member` SET username=NULL WHERE username=''" ) ; $ this -> Database -> query ( "ALTER TABLE `tl_member` DROP INDEX `username`, ADD UNIQUE KEY `username` (`username`)" ) ; }
5398	public function paintSignal ( $ type , $ payload ) { parent :: paintSignal ( $ type , $ payload ) ; print $ this -> getIndent ( 1 ) ; print '<' . $ this -> namespace . "signal type=\"$type\">" ; print '<![CDATA[' . serialize ( $ payload ) . ']]>' ; print '</' . $ this -> namespace . "signal>\n" ; }
3992	public function decodeValue ( DecodePropertyValueForWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ metaModel = $ this -> getMetaModelFromModel ( $ event -> getModel ( ) ) ; $ values = Helper :: decodeLangArray ( $ event -> getValue ( ) , $ metaModel ) ; $ event -> setValue ( unserialize ( $ values ) ) ; }
10502	public function setParameters ( $ subject , ParameterBagInterface $ parameters ) { if ( ! is_object ( $ subject ) ) { throw new InvalidSubjectException ( $ subject ) ; } if ( $ subject instanceof ParameterBagAwareInterface ) { $ subject -> setParameters ( $ parameters ) ; } else { foreach ( $ parameters as $ key => $ value ) { $ this -> setParameter ( $ subject , $ key , $ value ) ; } } }
11524	public function parseBotUA ( $ botName ) { $ dom = $ this -> getDom ( 'https://udger.com/resources/ua-list/bot-detail?bot=' . $ botName ) ; if ( false === $ dom ) { echo "Can not parse DOM" . PHP_EOL ; return false ; } $ this -> currentBotName = $ botName ; $ crawlerBot = new Crawler ( ) ; $ crawlerBot -> addContent ( $ dom ) ; $ crawlerBot -> filter ( 'body #container table tr td > a' ) -> each ( function ( $ el , $ i ) { if ( strpos ( $ el -> attr ( 'href' ) , '/resources/online-parser' ) !== false ) { $ botUA = $ el -> text ( ) ; $ this -> addBotUA ( $ botUA ) ; } } ) ; return true ; }
5940	public function addExtraData ( $ item ) { if ( ! ( $ item instanceof ExtraData ) ) { if ( is_array ( $ item ) ) { try { $ item = new ExtraData ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate ExtraData. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "ExtraData"!' , E_USER_WARNING ) ; } } $ this -> extraData [ ] = $ item ; return $ this ; }
1783	protected function countItems ( $ newsArchives , $ blnFeatured ) { if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'newsListCountItems' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'newsListCountItems' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'newsListCountItems' ] as $ callback ) { if ( ( $ intResult = System :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ newsArchives , $ blnFeatured , $ this ) ) === false ) { continue ; } if ( \ is_int ( $ intResult ) ) { return $ intResult ; } } } return NewsModel :: countPublishedByPids ( $ newsArchives , $ blnFeatured ) ; }
10281	public static function absoluteCoordinate ( $ pCoordinateString ) { if ( self :: coordinateIsRange ( $ pCoordinateString ) ) { throw new Exception ( 'Cell coordinate string can not be a range of cells' ) ; } $ worksheet = '' ; $ cellAddress = explode ( '!' , $ pCoordinateString ) ; if ( count ( $ cellAddress ) > 1 ) { list ( $ worksheet , $ pCoordinateString ) = $ cellAddress ; } if ( $ worksheet > '' ) { $ worksheet .= '!' ; } list ( $ column , $ row ) = self :: coordinateFromString ( $ pCoordinateString ) ; $ column = ltrim ( $ column , '$' ) ; $ row = ltrim ( $ row , '$' ) ; return $ worksheet . '$' . $ column . '$' . $ row ; }
9252	protected function initializeContainer ( ) { $ this -> registerDefaultExtensions ( ) ; $ initializer = $ this -> getContainerInitializer ( ) ; $ this -> container = $ initializer -> initializeContainer ( $ this , $ this -> extensions , $ this -> compilerPasses ) ; $ this -> container -> set ( 'app' , $ this ) ; return $ this -> container ; }
12561	public function send ( $ msgType , $ message , $ to = null ) { $ message = ( new MessageBuilder ( ) ) -> msgType ( $ msgType ) -> message ( $ message ) -> to ( $ to ) -> build ( ) ; $ api = is_array ( $ to ) ? self :: API_SEND_BY_OPENID : self :: API_SEND_BY_GROUP ; return $ this -> post ( $ api , $ message ) ; }
4884	public function addDependencies ( $ name , $ entities = null , array $ options = null ) { return $ this -> dependencyResultCollection -> add ( $ name , $ entities , $ options ) ; }
2391	public function adjustPermissions ( $ insertId ) { if ( \ func_num_args ( ) == 4 ) { $ insertId = func_get_arg ( 1 ) ; } if ( $ this -> User -> isAdmin ) { return ; } if ( empty ( $ this -> User -> calendarfeeds ) || ! \ is_array ( $ this -> User -> calendarfeeds ) ) { $ root = array ( 0 ) ; } else { $ root = $ this -> User -> calendarfeeds ; } if ( \ in_array ( $ insertId , $ root ) ) { return ; } $ objSessionBag = Contao \ System :: getContainer ( ) -> get ( 'session' ) -> getBag ( 'contao_backend' ) ; $ arrNew = $ objSessionBag -> get ( 'new_records' ) ; if ( \ is_array ( $ arrNew [ 'tl_calendar_feed' ] ) && \ in_array ( $ insertId , $ arrNew [ 'tl_calendar_feed' ] ) ) { if ( $ this -> User -> inherit != 'custom' ) { $ objGroup = $ this -> Database -> execute ( "SELECT id, calendarfeeds, calendarfeedp FROM tl_user_group WHERE id IN(" . implode ( ',' , array_map ( '\intval' , $ this -> User -> groups ) ) . ")" ) ; while ( $ objGroup -> next ( ) ) { $ arrCalendarfeedp = Contao \ StringUtil :: deserialize ( $ objGroup -> calendarfeedp ) ; if ( \ is_array ( $ arrCalendarfeedp ) && \ in_array ( 'create' , $ arrCalendarfeedp ) ) { $ arrCalendarfeeds = Contao \ StringUtil :: deserialize ( $ objGroup -> calendarfeeds , true ) ; $ arrCalendarfeeds [ ] = $ insertId ; $ this -> Database -> prepare ( "UPDATE tl_user_group SET calendarfeeds=? WHERE id=?" ) -> execute ( serialize ( $ arrCalendarfeeds ) , $ objGroup -> id ) ; } } } if ( $ this -> User -> inherit != 'group' ) { $ objUser = $ this -> Database -> prepare ( "SELECT calendarfeeds, calendarfeedp FROM tl_user WHERE id=?" ) -> limit ( 1 ) -> execute ( $ this -> User -> id ) ; $ arrCalendarfeedp = Contao \ StringUtil :: deserialize ( $ objUser -> calendarfeedp ) ; if ( \ is_array ( $ arrCalendarfeedp ) && \ in_array ( 'create' , $ arrCalendarfeedp ) ) { $ arrCalendarfeeds = Contao \ StringUtil :: deserialize ( $ objUser -> calendarfeeds , true ) ; $ arrCalendarfeeds [ ] = $ insertId ; $ this -> Database -> prepare ( "UPDATE tl_user SET calendarfeeds=? WHERE id=?" ) -> execute ( serialize ( $ arrCalendarfeeds ) , $ this -> User -> id ) ; } } $ root [ ] = $ insertId ; $ this -> User -> calendarfeeds = $ root ; } }
11731	protected function generateSlot ( $ path , $ blocks = array ( ) , $ username = null ) { if ( is_dir ( $ path ) && ! $ this -> override ) { return ; } $ folders = array ( ) ; $ activeDir = $ path . '/active' ; $ contributorsDir = $ path . '/contributors' ; $ folders [ ] = $ activeDir . '/blocks' ; $ folders [ ] = $ activeDir . '/archive' ; $ folders [ ] = $ contributorsDir ; $ targetDir = $ activeDir ; $ blocksDir = $ activeDir . '/blocks' ; if ( null !== $ username ) { $ targetDir = $ contributorsDir . '/' . $ username ; $ blocksDir = $ targetDir . '/blocks' ; $ folders [ ] = $ targetDir ; $ folders [ ] = $ targetDir . '/archive' ; $ folders [ ] = $ blocksDir ; } $ this -> filesystem -> mkdir ( $ folders ) ; $ this -> generateBlocks ( $ blocks , $ blocksDir , $ targetDir ) ; }
5886	public function resolve ( $ tsdns ) { $ this -> getTransport ( ) -> sendLine ( $ tsdns ) ; $ repl = $ this -> getTransport ( ) -> readLine ( ) ; $ this -> getTransport ( ) -> disconnect ( ) ; if ( $ repl -> section ( ":" , 0 ) -> toInt ( ) == 404 ) { throw new Ts3Exception ( "unable to resolve TSDNS hostname (" . $ tsdns . ")" ) ; } Signal :: getInstance ( ) -> emit ( "tsdnsResolved" , $ tsdns , $ repl ) ; return $ repl ; }
12601	public static function write ( $ filename , $ buffer ) { $ fs = new Filesystem ( ) ; try { $ fs -> dumpFile ( $ filename , $ buffer ) ; } catch ( IOExceptionInterface $ e ) { throw new Exception ( $ e -> getMessage ( ) ) ; } return true ; }
10912	public function convertDateTimeToUtcTimeZone ( $ inStrictIso8601DtTm ) { $ tmpDateTimeIn = $ this -> convertTimeFromFormatSafely ( $ inStrictIso8601DtTm ) ; $ tmpDateTimeIn -> setTimezone ( new \ DateTimeZone ( 'UTC' ) ) ; return $ tmpDateTimeIn -> format ( 'Y-m-d H:i:s' ) ; }
6869	protected function buildInvoiceList ( IM \ InvoiceSubjectInterface $ subject ) { $ invoices = $ subject -> getInvoices ( true ) -> toArray ( ) ; usort ( $ invoices , function ( IM \ InvoiceInterface $ a , IM \ InvoiceInterface $ b ) { return $ a -> getCreatedAt ( ) -> getTimestamp ( ) - $ b -> getCreatedAt ( ) -> getTimestamp ( ) ; } ) ; return array_map ( function ( IM \ InvoiceInterface $ invoice ) { return [ 'invoice' => $ invoice , 'total' => $ invoice -> getGrandTotal ( ) , ] ; } , $ invoices ) ; }
7226	public function info ( $ name = null ) { if ( $ name ) { return $ this -> info ? $ this -> info [ $ name ] : curl_getinfo ( $ this -> curl , "CURLINFO" . strtoupper ( $ name ) ) ; } else { return $ this -> info ? : curl_getinfo ( $ this -> curl ) ; } }
3787	protected function getMetaModelById ( $ modelId ) { $ services = $ this -> getServiceContainer ( ) ; $ modelFactory = $ services -> getFactory ( ) ; $ name = $ modelFactory -> translateIdToMetaModelName ( $ modelId ) ; return $ modelFactory -> getMetaModel ( $ name ) ; }
644	public function addDefaultValue ( $ name , $ table , $ column , $ value ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> addDefaultValue ( $ name , $ table , $ column , $ value ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; }
7374	public function has ( string $ key ) : bool { return isset ( $ _SESSION ) ? array_key_exists ( $ key , $ _SESSION ) : false ; }
1550	protected function getRelation ( $ record , $ key ) { $ relation = $ record -> { $ key } ( ) ; if ( ! $ relation || ! $ this -> acceptRelation ( $ relation ) ) { throw new RuntimeException ( sprintf ( 'JSON API relation %s cannot be used for an Eloquent %s relation.' , class_basename ( $ this ) , class_basename ( $ relation ) ) ) ; } return $ relation ; }
8019	public function getClient ( ) { if ( $ this -> _client === null ) { $ settings = [ 'key' => $ this -> key , 'secret' => $ this -> secret ] ; if ( $ this -> enableV4 ) $ settings [ 'signature' ] = 'v4' ; $ this -> _client = S3Client :: factory ( $ settings ) ; } return $ this -> _client ; }
12063	public function can_save_post_meta ( $ post_id , $ action , $ nonce ) { $ is_autosave = wp_is_post_autosave ( $ post_id ) ; $ is_revision = wp_is_post_revision ( $ post_id ) ; $ is_valid_nonce = ( isset ( $ _POST [ $ nonce ] ) && wp_verify_nonce ( $ _POST [ $ nonce ] , $ action ) ) ; return ! ( $ is_autosave || $ is_revision ) && $ is_valid_nonce ; }
11184	protected function generateActions ( ) { $ parser = new Parser ( ) ; $ parser -> setPath ( $ this -> getApplicationPath ( ) ) ; $ parser -> setNameSpace ( $ this -> getApplicationNameSpace ( ) ) ; $ list = $ parser -> run ( ) ; return $ list ; }
10060	public function set ( $ key , $ value ) { $ meta = $ this -> metaModel :: where ( 'key' , $ key ) -> first ( ) ; if ( $ meta === null ) { $ meta = new $ this -> metaModel ; $ meta -> key = $ key ; } $ meta -> value = $ value ; $ meta -> save ( ) ; }
5596	public function invoke ( $ method ) { $ queue = $ this -> createErrorQueue ( ) ; set_error_handler ( 'SimpleTestErrorHandler' ) ; parent :: invoke ( $ method ) ; restore_error_handler ( ) ; $ queue -> tally ( ) ; }
8698	public function attr ( $ attrKey , $ attrValue = null ) { if ( ! is_null ( $ attrValue ) ) { if ( ! is_array ( $ this -> attributes ) ) { $ this -> attributes = array ( ) ; } $ this -> attributes [ $ attrKey ] = $ attrValue ; return $ this ; } else { if ( array_key_exists ( $ attrKey , $ this -> attributes ) ) { return $ this -> attributes [ $ attrKey ] ; } else { return null ; } } }
11461	public static function enable ( $ state = true , $ enable_assert = false ) { $ state = ( bool ) $ state ; self :: enableAssert ( ( bool ) $ enable_assert ) ; if ( $ state && self :: $ _enabled || ! $ state && ! self :: $ _enabled ) { return ; } if ( $ state ) { set_exception_handler ( __CLASS__ . '::exception' ) ; set_error_handler ( __CLASS__ . '::error' , error_reporting ( ) ) ; assert_options ( ASSERT_CALLBACK , __CLASS__ . '::assert' ) ; self :: $ _enabled = true ; } else { restore_exception_handler ( ) ; restore_error_handler ( ) ; assert_options ( ASSERT_CALLBACK , function ( ) { } ) ; self :: $ _enabled = false ; } }
7552	function getChildrenByCallback ( $ callback , $ recursive = true , $ check_self = false ) { $ count = $ this -> childCount ( ) ; if ( $ check_self && $ callback ( $ this ) ) { $ res = array ( $ this ) ; } else { $ res = array ( ) ; } if ( $ count > 0 ) { if ( is_int ( $ recursive ) ) { $ recursive = ( ( $ recursive > 1 ) ? $ recursive - 1 : false ) ; } for ( $ i = 0 ; $ i < $ count ; $ i ++ ) { if ( $ callback ( $ this -> children [ $ i ] ) ) { $ res [ ] = $ this -> children [ $ i ] ; } if ( $ recursive ) { $ res = array_merge ( $ res , $ this -> children [ $ i ] -> getChildrenByCallback ( $ callback , $ recursive ) ) ; } } } return $ res ; }
5714	protected function filterFieldList ( Form $ form , FieldList $ actions ) { $ list = FieldList :: create ( ) ; foreach ( $ actions as $ a ) { if ( ! $ a instanceof BetterButtonInterface ) { throw new Exception ( "{$buttonObj->class} must implement BetterButtonInterface" ) ; } $ a -> bindGridField ( $ form , $ this -> owner ) ; if ( ! $ a -> shouldDisplay ( ) ) { continue ; } if ( ( $ a instanceof BetterButton_Versioned ) && ! $ this -> owner -> record -> checkVersioned ( ) ) { continue ; } $ list -> push ( $ a ) ; } return $ list ; }
2066	public function getPageTypes ( Contao \ DataContainer $ dc ) { $ arrOptions = array ( ) ; foreach ( array_keys ( $ GLOBALS [ 'TL_PTY' ] ) as $ pty ) { if ( $ pty == 'root' && $ dc -> activeRecord && $ dc -> activeRecord -> pid > 0 ) { continue ; } if ( $ pty == $ dc -> value || $ this -> User -> hasAccess ( $ pty , 'alpty' ) ) { $ arrOptions [ ] = $ pty ; } } return $ arrOptions ; }
3999	protected function getCount ( $ strType , $ intID ) { switch ( $ strType ) { case 'mod' : $ objMetaModelResult = $ this -> getMetaModelDataFrom ( 'tl_module' , $ intID ) ; break ; case 'ce' : $ objMetaModelResult = $ this -> getMetaModelDataFrom ( 'tl_content' , $ intID ) ; break ; default : return false ; } if ( $ objMetaModelResult != null ) { return $ this -> getCountFor ( $ objMetaModelResult -> metamodel , $ objMetaModelResult -> metamodel_filtering ) ; } return false ; }
3272	public function setConfig ( Config $ config ) { $ this -> config = $ config ; $ this -> getDatabase ( ) -> setConfig ( $ config ) ; }
3205	protected function get_docblock_tags ( $ comment_opener ) { $ tags = array ( ) ; $ opener = $ this -> tokens [ $ comment_opener ] ; if ( ! isset ( $ opener [ 'comment_tags' ] ) ) { return $ tags ; } $ closer = null ; if ( isset ( $ opener [ 'comment_closer' ] ) ) { $ closer = $ opener [ 'comment_closer' ] ; } $ tag_count = count ( $ opener [ 'comment_tags' ] ) ; for ( $ i = 0 ; $ i < $ tag_count ; $ i ++ ) { $ tag_token = $ opener [ 'comment_tags' ] [ $ i ] ; $ tag = trim ( $ this -> tokens [ $ tag_token ] [ 'content' ] , '@' ) ; $ search_end = $ closer ; if ( ( $ i + 1 ) < $ tag_count ) { $ search_end = $ opener [ 'comment_tags' ] [ ( $ i + 1 ) ] ; } $ value_token = $ this -> phpcsFile -> findNext ( T_DOC_COMMENT_STRING , ( $ tag_token + 1 ) , $ search_end ) ; $ tags [ $ tag ] = trim ( $ this -> tokens [ $ value_token ] [ 'content' ] ) ; unset ( $ tag_token , $ tag , $ search_end , $ value ) ; } return $ tags ; }
9074	protected function getRouteInformation ( Route $ route ) { return $ this -> filterRoute ( [ 'name' => $ route -> getName ( ) , 'isAuthorized' => $ this -> isAuthorized ( $ route ) , ] ) ; }
8758	public function tick ( $ status = Tick :: SUCCESS , $ msg = null , array $ extraInfo = [ ] , $ incrementBy = 1 ) { if ( ! $ this -> isRunning ( ) ) { $ this -> start ( ) ; } $ tick = new Tick ( $ this , $ status , $ msg , $ extraInfo , $ incrementBy ) ; if ( array_key_exists ( $ tick -> getStatus ( ) , $ this -> numProcessedItems ) ) { $ this -> numProcessedItems [ $ tick -> getStatus ( ) ] += $ tick -> getIncrementBy ( ) ; } else { $ this -> numProcessedItems [ $ tick -> getStatus ( ) ] = $ tick -> getIncrementBy ( ) ; } $ this -> dispatcher -> dispatch ( Events :: TRACKER_TICK , $ tick ) ; $ this -> lastTick = $ tick ; return $ tick -> getReport ( ) ; }
5163	public function serialize ( EntityContract $ entity , Collection $ select = null ) { $ bag = parent :: serialize ( $ entity , $ select ) ; return $ bag ; }
9920	private function findSimpleRelations ( Model $ model ) { foreach ( $ model -> getColumns ( ) as $ column ) { if ( ends_with ( $ column -> getName ( ) , self :: ID_SUFFIX ) ) { $ this -> defineRelation ( $ model , $ column -> getName ( ) ) ; } } }
8846	public function getBlogPosts ( ) { $ blogPosts = BlogPost :: get ( ) -> filter ( "ParentID" , $ this -> ID ) ; $ this -> extend ( 'updateGetBlogPosts' , $ blogPosts ) ; return $ blogPosts ; }
2187	public function fetchByAlias ( $ strTable , $ strAlias , $ varValue ) { if ( isset ( $ this -> arrAliases [ $ strTable ] [ $ strAlias ] [ $ varValue ] ) ) { $ strPk = $ this -> arrAliases [ $ strTable ] [ $ strAlias ] [ $ varValue ] ; if ( isset ( $ this -> arrRegistry [ $ strTable ] [ $ strPk ] ) ) { return $ this -> arrRegistry [ $ strTable ] [ $ strPk ] ; } } return null ; }
2823	public function deleteExpiredRequests ( ) { $ helper = Mage :: helper ( 'sheep_debug' ) ; if ( ! $ helper -> isEnabled ( ) ) { return 'skipped: module is disabled.' ; } if ( $ helper -> getPersistLifetime ( ) == 0 ) { return 'skipped: lifetime is set to 0' ; } $ expirationDate = $ this -> getExpirationDate ( date ( self :: DATE_FORMAT ) ) ; $ table = $ this -> getRequestsTable ( ) ; $ deleteSql = "DELETE FROM {$table} WHERE date <= '{$expirationDate}'" ; $ connection = Mage :: getSingleton ( 'core/resource' ) -> getConnection ( 'core_write' ) ; $ result = $ connection -> query ( $ deleteSql ) ; return "{$result->rowCount()} requests deleted" ; }
3002	public function setContent ( $ data , $ mime , $ charset = NULL ) { if ( ! $ charset ) $ charset = $ this -> charset ; $ this -> message [ $ mime ] = [ 'content' => $ data , 'type' => $ mime . '; ' . $ charset ] ; }
10598	protected function initViewPanelRequestedUrlData ( ) { $ req = & $ this -> request ; $ this -> view -> requestedUrl = ( object ) [ 'method' => htmlSpecialChars ( $ req -> GetMethod ( ) , ENT_IGNORE , 'UTF-8' ) , 'baseUrl' => htmlSpecialChars ( $ req -> GetBaseUrl ( ) , ENT_IGNORE , 'UTF-8' ) , 'path' => htmlSpecialChars ( $ req -> GetRequestPath ( ) , ENT_IGNORE , 'UTF-8' ) , ] ; }
7957	public function getProperties ( ) { $ this -> properties = json_decode ( self :: getClient ( ) -> getProperties ( $ this -> id ) ) ; return $ this -> properties ; }
4997	public function setSearchParams ( $ params ) { if ( $ params instanceof \ Traversable ) { $ params = ArrayUtils :: iteratorToArray ( $ params ) ; } $ params = Json :: encode ( $ params ) ; $ this -> setAttribute ( 'data-search-params' , $ params ) ; return $ this ; }
7646	protected function getFileName ( $ path ) { $ url = parse_url ( $ path ) ; if ( $ url [ 'host' ] ) { $ fileName = isset ( $ url [ 'path' ] ) ? $ url [ 'path' ] : $ url [ 'host' ] ; if ( strpos ( $ fileName , '/' ) === 0 ) { $ fileName = substr ( $ fileName , 1 ) ; } return $ fileName ; } return '' ; }
683	private function normalizeComplexFilter ( array $ filter ) { $ result = [ ] ; foreach ( $ filter as $ key => $ value ) { if ( isset ( $ this -> filterControls [ $ key ] ) ) { $ key = $ this -> filterControls [ $ key ] ; } elseif ( isset ( $ this -> attributeMap [ $ key ] ) ) { $ key = $ this -> attributeMap [ $ key ] ; } if ( is_array ( $ value ) ) { $ result [ $ key ] = $ this -> normalizeComplexFilter ( $ value ) ; } else { $ result [ $ key ] = $ value ; } } return $ result ; }
5754	protected function setIndexFilter ( Request $ request , Response $ response , $ args , array $ listViewColumns , AdminListView $ view ) { $ this -> setRequestInput ( $ request , [ $ view -> getSessionFilterFieldKey ( ) ] ) ; if ( ! isset ( $ this -> requestInput [ $ view -> getSessionFilterFieldKey ( ) ] ) ) { throw new \ Exception ( "session filter input must be set" ) ; } $ this -> storeFilterFieldValueInSession ( $ view ) ; if ( null !== $ filterColumnsInfo = $ this -> getFilterColumns ( $ view -> getSessionFilterFieldKey ( ) , $ listViewColumns ) ) { $ this -> storeFilterColumnsInfoInSession ( $ filterColumnsInfo , $ view ) ; } }
9052	public function getMenuItemsJson ( Collection $ menuItems , $ currentOwner ) { $ this -> alreadySetIds = [ ] ; $ this -> position = 0 ; $ this -> currentOwner = $ currentOwner ; return json_encode ( $ this -> recursiveMenuItemHandling ( $ menuItems ) ) ; }
11939	public function findOne ( $ params = [ ] ) { return $ this -> populateRecord ( $ this -> find ( $ params ) -> one ( $ this -> interface -> db ) ) ; }
8796	public function helper ( $ name , $ directory = 'Helpers' ) { $ file = app_path ( $ directory . DIRECTORY_SEPARATOR . $ name . '.php' ) ; if ( file_exists ( $ file ) ) { return require $ file ; } throw new ExceptionHandler ( 'Oppss! File not found.' , 'Helper::' . $ name . ' not found.' ) ; }
12376	public function equals ( ) { foreach ( $ this -> comparisonList as $ valuePair ) { $ a = $ valuePair [ 0 ] ; $ b = $ valuePair [ 1 ] ; $ callback = $ valuePair [ 2 ] ; if ( ! is_null ( $ callback ) ) { if ( ! is_callable ( $ callback ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Provided callback of type %s is not callable!' , is_object ( $ callback ) ? get_class ( $ callback ) : gettype ( $ callback ) ) ) ; } if ( is_array ( $ a ) && is_array ( $ b ) && $ this -> isList ( $ a ) && $ this -> isList ( $ b ) ) { $ result = $ this -> compareListsWithCallback ( $ a , $ b , $ callback ) ; } else { $ result = call_user_func ( $ callback , $ a , $ b ) ; } if ( ! is_bool ( $ result ) ) { throw new \ RuntimeException ( sprintf ( 'Provided callback of type %s does not return a boolean value!' , is_object ( $ callback ) ? get_class ( $ callback ) : gettype ( $ callback ) ) ) ; } return $ result ; } if ( ! ( ( $ this -> strict ) ? $ a === $ b : $ a == $ b ) ) { return false ; } } return true ; }
2010	public function indexAction ( ) : InitializeControllerResponse { @ trigger_error ( 'Custom entry points are deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; $ masterRequest = $ this -> get ( 'request_stack' ) -> getMasterRequest ( ) ; if ( null === $ masterRequest ) { throw new \ RuntimeException ( 'The request stack did not contain a master request.' ) ; } $ realRequest = Request :: createFromGlobals ( ) ; foreach ( [ 'REQUEST_URI' , 'SCRIPT_NAME' , 'SCRIPT_FILENAME' , 'PHP_SELF' ] as $ name ) { $ realRequest -> server -> set ( $ name , str_replace ( TL_SCRIPT , 'index.php' , $ realRequest -> server -> get ( $ name ) ) ) ; } $ realRequest -> attributes -> replace ( $ masterRequest -> attributes -> all ( ) ) ; $ this -> get ( 'request_stack' ) -> push ( $ realRequest ) ; $ this -> get ( 'contao.framework' ) -> initialize ( ) ; $ this -> get ( 'request_stack' ) -> push ( $ masterRequest ) ; return new InitializeControllerResponse ( '' , 204 ) ; }
6918	public function hasAdjustments ( $ type = null ) { if ( null !== $ type ) { AdjustmentTypes :: isValidType ( $ type ) ; return $ this -> getAdjustments ( $ type ) -> count ( ) ; } return 0 < $ this -> adjustments -> count ( ) ; }
1899	private function createConfig ( $ size , ImageInterface $ image ) : array { if ( ! \ is_array ( $ size ) ) { $ size = [ 0 , 0 , $ size ] ; } $ config = new ResizeConfiguration ( ) ; if ( isset ( $ size [ 2 ] ) && is_numeric ( $ size [ 2 ] ) ) { $ imageModel = $ this -> framework -> getAdapter ( ImageSizeModel :: class ) ; $ imageSize = $ imageModel -> findByPk ( $ size [ 2 ] ) ; if ( null !== $ imageSize ) { $ config -> setWidth ( $ imageSize -> width ) -> setHeight ( $ imageSize -> height ) -> setMode ( $ imageSize -> resizeMode ) -> setZoomLevel ( $ imageSize -> zoom ) ; } return [ $ config , null ] ; } if ( ! empty ( $ size [ 0 ] ) ) { $ config -> setWidth ( $ size [ 0 ] ) ; } if ( ! empty ( $ size [ 1 ] ) ) { $ config -> setHeight ( $ size [ 1 ] ) ; } if ( ! isset ( $ size [ 2 ] ) || 1 !== substr_count ( $ size [ 2 ] , '_' ) ) { if ( ! empty ( $ size [ 2 ] ) ) { $ config -> setMode ( $ size [ 2 ] ) ; } return [ $ config , null ] ; } $ config -> setMode ( ResizeConfigurationInterface :: MODE_CROP ) ; return [ $ config , $ this -> getImportantPartFromLegacyMode ( $ image , $ size [ 2 ] ) ] ; }
4680	public function render ( ContainerInterface $ di = null ) { switch ( $ this -> type ) { case "file" : if ( $ di -> has ( "viewRenderFile" ) ) { $ viewRender = $ di -> get ( "viewRenderFile" ) ; } else { $ viewRender = new ViewRenderFile ( $ di ) ; $ viewRender -> setDI ( $ di ) ; } $ viewRender -> render ( $ this -> template , $ this -> templateData ) ; break ; case "callback" : if ( ! is_callable ( $ this -> template ) ) { throw new Exception ( "View is expecting a valid callback, provided callback seems to not be a callable." ) ; } echo call_user_func ( $ this -> template , $ this -> templateData ) ; break ; case "string" : echo $ this -> template ; break ; case "empty" : break ; default : throw new Exception ( "Not a valid template type: '{$this->type}'." ) ; } }
4868	protected function parseOptionsToDateTime ( $ options ) { $ time = microtime ( true ) ; $ micro = sprintf ( "%06d" , ( $ time - floor ( $ time ) ) * 1000000 ) ; $ this -> now = new \ DateTime ( date ( 'Y-m-d H:i:s.' . $ micro , $ time ) , new \ DateTimeZone ( date_default_timezone_get ( ) ) ) ; $ scheduled = isset ( $ options [ 'scheduled' ] ) ? Utils :: createDateTime ( $ options [ 'scheduled' ] ) : clone ( $ this -> now ) ; if ( isset ( $ options [ 'delay' ] ) ) { $ delay = Utils :: createDateInterval ( $ options [ 'delay' ] ) ; $ scheduled -> add ( $ delay ) ; } return $ scheduled ; }
5611	public function paintMethodStart ( $ message ) { parent :: paintMethodStart ( $ message ) ; $ node = new TreemapNode ( 'Method' , $ message ) ; $ this -> _stack -> push ( $ node ) ; }
11758	public function reply ( $ msgId , $ index , $ commentId , $ content ) { $ params = [ 'msg_data_id' => $ msgId , 'index' => $ index , 'user_comment_id' => $ commentId , 'content' => $ content , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_REPLY_COMMENT , $ params ] ) ; }
548	protected function addMemcachedServers ( $ cache , $ servers ) { $ existingServers = [ ] ; if ( $ this -> persistentId !== null ) { foreach ( $ cache -> getServerList ( ) as $ s ) { $ existingServers [ $ s [ 'host' ] . ':' . $ s [ 'port' ] ] = true ; } } foreach ( $ servers as $ server ) { if ( empty ( $ existingServers ) || ! isset ( $ existingServers [ $ server -> host . ':' . $ server -> port ] ) ) { $ cache -> addServer ( $ server -> host , $ server -> port , $ server -> weight ) ; } } }
9218	protected function pageNumberToKey ( $ pageNumber ) { if ( isset ( $ this -> pagination [ CanvasPageLink :: CURRENT ] ) ) { return ( $ pageNumber - 1 ) * $ this -> pagination [ CanvasPageLink :: CURRENT ] -> getPerPage ( ) ; } return false ; }
1599	protected function authenticate ( ) { if ( empty ( $ this -> guards ) && Auth :: check ( ) ) { return ; } foreach ( $ this -> guards as $ guard ) { if ( Auth :: guard ( $ guard ) -> check ( ) ) { Auth :: shouldUse ( $ guard ) ; return ; } } throw new AuthenticationException ( 'Unauthenticated.' , $ this -> guards ) ; }
5216	public static function createInstance ( $ className , $ projectPath ) { Runtime :: reset ( ) ; self :: $ projectPath = $ projectPath ; $ binder = new Binder ( ) ; foreach ( static :: getBindingsForApp ( $ className ) as $ bindingModule ) { if ( is_string ( $ bindingModule ) ) { $ bindingModule = new $ bindingModule ( ) ; } if ( $ bindingModule instanceof BindingModule ) { $ bindingModule -> configure ( $ binder , $ projectPath ) ; } elseif ( $ bindingModule instanceof \ Closure ) { $ bindingModule ( $ binder , $ projectPath ) ; } else { throw new \ InvalidArgumentException ( 'Given module class ' . get_class ( $ bindingModule ) . ' is not an instance of stubbles\ioc\module\BindingModule' ) ; } } return $ binder -> getInjector ( ) -> getInstance ( $ className ) ; }
4301	public function groupSummary ( $ priority = 0 ) { array ( $ priority ) ; $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) , array ( 'priority' => 0 ) , array ( 'priority' ) ) ; $ this -> data [ 'groupPriorityStack' ] [ ] = $ meta [ 'priority' ] ; $ this -> setLogDest ( 'summary' ) ; $ this -> internal -> publishBubbleEvent ( 'debug.log' , $ this , array ( 'method' => __FUNCTION__ , 'args' => array ( ) , 'meta' => $ meta , ) ) ; }
1539	protected function isExpectingContent ( $ request ) : bool { $ methods = $ this -> route -> isNotRelationship ( ) ? [ 'POST' , 'PATCH' ] : [ 'POST' , 'PATCH' , 'DELETE' ] ; return \ in_array ( $ request -> getMethod ( ) , $ methods ) ; }
6640	private function getContainerRoute ( array $ routes , $ name ) { foreach ( $ routes as $ route => $ names ) { if ( in_array ( $ name , $ names , false ) ) { return $ route ; } } throw new Exception ( "Unknown configuration class name '{$name}'" ) ; }
2075	public function purgeVersionTable ( ) { $ objDatabase = Database :: getInstance ( ) ; $ objDatabase -> execute ( "TRUNCATE TABLE tl_version" ) ; $ this -> log ( 'Purged the version table' , __METHOD__ , TL_CRON ) ; }
10695	public function select ( $ col = '' , $ colAlias = '' ) { return $ this -> getBuilder ( ) -> setPrevious ( $ this ) -> select ( $ col , $ colAlias ) ; }
12800	public function getHeaders ( ) { if ( ! isset ( $ this -> _headers ) ) { $ this -> _headers = $ this -> readLine ( 1 ) ; if ( ! $ this -> _headers ) { $ this -> _headers = [ ] ; } } return $ this -> _headers ; }
2785	private function extractFail ( $ output ) { if ( preg_match ( '%##teamcity\[testFailed.*\]%' , $ output , $ matches ) ) { preg_match ( "/##teamcity\\[testFailed.*name='(.*)' message='(.*)' details='\\s*(.*)' flowId=.*/" , $ output , $ matches ) ; $ matches = $ this -> replaceEscapedChars ( $ matches ) ; $ fail = sprintf ( 'Test Name: %s' . PHP_EOL . 'Failure Message: %s' . PHP_EOL . 'Trace:' . PHP_EOL . '%s' , $ matches [ 1 ] , $ matches [ 2 ] , $ matches [ 3 ] ) ; return $ fail ; } return 'No failure output was detected by Humbug, but a failure was reported by PHPUnit.' ; }
4247	private function logRequestHeaders ( ) { if ( ! $ this -> debug -> getCfg ( 'logEnvInfo.headers' ) ) { return ; } if ( ! empty ( $ _SERVER [ 'argv' ] ) ) { return ; } $ headers = $ this -> debug -> utilities -> getAllHeaders ( ) ; \ ksort ( $ headers , SORT_NATURAL ) ; $ this -> debug -> log ( 'request headers' , $ headers ) ; }
9071	protected function prepareException ( Exception $ e ) { $ e = parent :: prepareException ( $ e ) ; if ( $ e instanceof PermissionDoesNotExist || $ e instanceof AuthorizationException ) { $ e = new AuthenticationException ( $ e -> getMessage ( ) ) ; } return $ e ; }
8484	public static function getHostname ( ) { $ wmi = Windows :: getInstance ( ) ; foreach ( $ wmi -> ExecQuery ( "SELECT Name FROM Win32_ComputerSystem" ) as $ cs ) { return $ cs -> Name ; } return "Unknown" ; }
8320	public function getCaptchaResultBulk ( array $ captchaIds ) { $ response = $ this -> getHttpClient ( ) -> request ( 'GET' , '/res.php?' . http_build_query ( [ 'key' => $ this -> apiKey , 'action' => 'get' , 'ids' => join ( ',' , $ captchaIds ) ] ) ) ; $ captchaTexts = $ response -> getBody ( ) -> __toString ( ) ; $ this -> getLogger ( ) -> info ( "Got bulk response: `{$captchaTexts}`." ) ; $ captchaTexts = explode ( "|" , $ captchaTexts ) ; $ result = [ ] ; foreach ( $ captchaTexts as $ index => $ captchaText ) { $ captchaText = html_entity_decode ( trim ( $ captchaText ) ) ; $ result [ $ captchaIds [ $ index ] ] = ( $ captchaText == self :: STATUS_CAPTCHA_NOT_READY ) ? false : $ captchaText ; } return $ result ; }
9076	public function addTag ( $ name , array $ attributes = array ( ) ) { foreach ( $ this -> rules as $ rule ) { $ rule -> addTag ( $ name , $ attributes ) ; } }
11663	public static function saveToFile ( $ file , $ properties ) { $ prop_string = self :: saveToString ( $ properties ) ; $ real_file = File :: asFile ( $ file ) ; if ( ! $ real_file -> exists ( ) ) { $ real_file -> touch ( ) ; } $ real_file -> setContent ( $ prop_string ) ; }
10564	public function variant ( array $ attrs ) { return new self ( $ this -> id , $ attrs , null , $ this -> info -> all ( ) ) ; }
1086	private function parseDocument ( ) { $ start = $ this -> lexer -> token ; $ this -> expect ( Token :: SOF ) ; $ definitions = [ ] ; do { $ definitions [ ] = $ this -> parseDefinition ( ) ; } while ( ! $ this -> skip ( Token :: EOF ) ) ; return new DocumentNode ( [ 'definitions' => new NodeList ( $ definitions ) , 'loc' => $ this -> loc ( $ start ) , ] ) ; }
5643	public function makeDry ( $ is_dry = true ) { $ numberOfReporters = count ( $ this -> reporters ) ; for ( $ i = 0 ; $ i < $ numberOfReporters ; $ i ++ ) { $ this -> reporters [ $ i ] -> makeDry ( $ is_dry ) ; } }
9329	protected function registerMarkdownBladeEngine ( $ resolver ) { $ app = $ this -> app ; $ app -> singleton ( 'markdown.blade.compiler' , function ( $ app ) { $ cache = $ app [ 'config' ] [ 'view.compiled' ] ; return new MarkdownBladeCompiler ( $ app [ 'files' ] , $ cache ) ; } ) ; $ resolver -> register ( 'markdown.blade' , function ( ) use ( $ app ) { return new MarkdownEngine ( $ app [ 'markdown.blade.compiler' ] , $ app [ 'files' ] ) ; } ) ; $ app [ 'view' ] -> addExtension ( 'md.blade.php' , 'markdown.blade' ) ; }
3599	public function handleHttpRequest ( HttpRequest $ httpRequest ) { $ event = $ this -> dispatch ( Event \ HttpRequestEvent :: EVENT , new Event \ HttpRequestEvent ( $ httpRequest ) ) ; $ httpRequest = $ event -> getHttpRequest ( ) ; try { $ jsonRequests = $ this -> parserHttpRequest ( $ httpRequest ) ; } catch ( Exceptions \ ParseException $ e ) { return $ this -> createHttpResponseFromException ( $ e ) ; } $ jsonResponses = $ this -> jsonHandler -> handleJsonRequest ( $ jsonRequests ) ; $ httpResponse = HttpResponse :: create ( ) ; if ( $ this -> profiler ) { $ collect = function ( $ jsonResponse ) use ( & $ collect , $ httpRequest , $ httpResponse ) { if ( \ is_array ( $ jsonResponse ) ) { foreach ( $ jsonResponse as $ value ) { $ collect ( $ value ) ; } } else { if ( $ jsonResponse -> isError ( ) ) { $ this -> collectException ( $ httpRequest , $ httpResponse , new Exceptions \ ErrorException ( $ jsonResponse -> getErrorMessage ( ) , $ jsonResponse -> getErrorCode ( ) , $ jsonResponse -> getErrorData ( ) , $ jsonResponse -> getId ( ) ) ) ; } } } ; $ collect ( $ jsonResponses ) ; } if ( \ is_array ( $ jsonResponses ) ) { $ results = [ ] ; foreach ( $ jsonResponses as $ jsonResponse ) { if ( $ jsonResponse -> isError ( ) || $ jsonResponse -> getId ( ) ) { $ results [ ] = $ jsonResponse ; } if ( $ jsonResponse -> isError ( ) ) { $ httpResponse -> setStatusCode ( $ this -> errorCode ) ; } } $ httpResponse -> setContent ( \ json_encode ( $ results ) ) ; } else { if ( $ jsonResponses -> isError ( ) || $ jsonResponses -> getId ( ) ) { $ httpResponse -> setContent ( \ json_encode ( $ jsonResponses ) ) ; } if ( $ jsonResponses -> isError ( ) ) { $ httpResponse -> setStatusCode ( $ this -> errorCode ) ; } } if ( \ is_array ( $ jsonResponses ) ) { foreach ( $ jsonResponses as $ jsonResponse ) { if ( $ jsonResponse -> isError ( ) || $ jsonResponse -> getId ( ) ) { $ httpResponse -> headers -> add ( $ jsonResponse -> headers ( ) -> all ( ) ) ; } } } else { $ httpResponse -> headers -> add ( $ jsonResponses -> headers ( ) -> all ( ) ) ; } $ httpResponse -> headers -> set ( 'Content-Type' , 'application/json' ) ; $ this -> dispatch ( Event \ HttpResponseEvent :: EVENT , new Event \ HttpResponseEvent ( $ httpResponse ) ) ; return $ httpResponse ; }
4817	public function insertRowBefore ( $ rowNumber , $ row = null ) { if ( $ rowNumber > count ( $ this -> collection ) ) { $ this -> appendRow ( $ row ) ; } else { $ singleRow = $ row ; if ( ! ( $ row instanceof Row ) ) { $ singleRow = new Row ( $ row ) ; } array_splice ( $ this -> collection , $ rowNumber , 0 , '' ) ; $ this -> collection [ $ rowNumber ] = $ singleRow ; } }
11749	public function material ( ) { if ( is_null ( $ this -> material ) ) { $ this -> material = new Material ( $ this -> accessToken ) ; } return $ this -> material ; }
12573	public function previewVideo ( $ message , $ to , $ by = self :: PREVIEW_BY_OPENID ) { return $ this -> preview ( self :: MSG_TYPE_VIDEO , $ message , $ to , $ by ) ; }
1551	protected function requiresInverseAdapter ( $ record , EncodingParametersInterface $ parameters ) { return ! empty ( $ parameters -> getFilteringParameters ( ) ) || ! empty ( $ parameters -> getSortParameters ( ) ) || ! empty ( $ parameters -> getPaginationParameters ( ) ) || ! empty ( $ parameters -> getIncludePaths ( ) ) ; }
12037	function generate ( ) { if ( $ this -> namespace ) { $ fqcn = $ this -> namespace . '\\' . $ this -> className ; } else { $ fqcn = $ this -> className ; } $ this -> addProperties ( ) ; $ this -> addConstructorMethod ( ) ; $ this -> addSetAPIMethod ( ) ; $ this -> addSetParameterMethod ( ) ; $ this -> addCheckScopeMethod ( ) ; $ this -> addAccessorMethods ( ) ; $ this -> addFilteredParameterMethod ( ) ; $ this -> addCreateRequestMethod ( ) ; $ this -> addCreateAndExecuteMethod ( ) ; $ this -> addCallMethod ( ) ; $ this -> addExecuteMethod ( ) ; $ this -> addExecuteAsyncMethod ( ) ; $ this -> addDispatchMethod ( ) ; $ this -> addDispatchAsyncMethod ( ) ; $ this -> addProcessResponseMethod ( ) ; $ this -> addShouldResponseBeProcessedMethod ( ) ; $ this -> addTranslateResponseToExceptionMethod ( ) ; $ this -> addShouldUseCachedResponseMethod ( ) ; $ this -> addShouldResponseBeCachedMethod ( ) ; $ this -> addSetOriginalResponseMethod ( ) ; $ this -> addGetOriginalResponseMethod ( ) ; $ this -> addGetResultInstantiationInfoMethod ( ) ; $ this -> classGenerator -> setImplementedInterfaces ( [ 'ArtaxServiceBuilder\Operation' ] ) ; $ this -> classGenerator -> setFQCN ( $ fqcn ) ; $ text = $ this -> classGenerator -> generate ( ) ; saveFile ( $ this -> outputPath , $ fqcn , $ text ) ; }
2128	public function endblock ( ) { if ( empty ( $ this -> arrBlockNames ) ) { throw new \ Exception ( 'You must start a block before you can end it' ) ; } $ name = array_pop ( $ this -> arrBlockNames ) ; if ( $ this -> strParent === null ) { if ( $ this -> arrBlocks [ $ name ] != '[[TL_PARENT]]' ) { if ( strpos ( $ this -> arrBlocks [ $ name ] , '[[TL_PARENT]]' ) !== false ) { list ( , $ content ) = explode ( '[[TL_PARENT]]' , $ this -> arrBlocks [ $ name ] , 2 ) ; echo $ content ; } else { ob_end_clean ( ) ; -- $ this -> intBufferLevel ; } } } else { $ this -> arrBlocks [ $ name ] [ ] = ob_get_clean ( ) ; ob_start ( ) ; } }
12921	public function getRemaining ( ) { if ( is_null ( $ this -> _countRemaining ) ) { $ this -> _countRemaining = $ this -> total ; } return $ this -> _countRemaining ; }
11837	public function getLogo ( $ size = null ) { if ( ! $ this -> logoPath || ! file_exists ( $ this -> logoPath ) ) { return ; } $ cacheLogo = $ this -> sizeImageCache ( $ this -> logoPath , $ size ) ; if ( $ cacheLogo ) { return $ this -> getCacheAssetUrl ( $ cacheLogo ) ; } return false ; }
5228	public static function createInjector ( callable ... $ applyBindings ) { $ self = new self ( ) ; foreach ( $ applyBindings as $ applyBinding ) { $ applyBinding ( $ self ) ; } return $ self -> getInjector ( ) ; }
6414	public static function limit ( IteratorAggregate $ iterable , int $ limitSize ) : IteratorAggregate { return new CallableIterable ( function ( ) use ( $ iterable , $ limitSize ) { return Iterators :: limit ( Iterators :: from ( $ iterable -> getIterator ( ) ) , $ limitSize ) ; } ) ; }
7935	public function send ( $ from , $ to , $ msg ) { $ opt = array ( 'sender' => $ from , 'receivers' => array ( $ to ) , 'message' => $ msg ) ; return $ this -> createJob ( $ opt ) ; }
4285	public function onOutput ( Event $ event ) { $ this -> channelName = $ this -> debug -> getCfg ( 'channel' ) ; $ this -> data = $ this -> debug -> getData ( ) ; $ this -> processAlerts ( ) ; $ this -> processSummary ( ) ; $ this -> processLog ( ) ; if ( $ this -> json [ 'rows' ] ) { \ array_unshift ( $ this -> json [ 'rows' ] , array ( array ( 'PHP' , isset ( $ _SERVER [ 'REQUEST_METHOD' ] ) ? $ _SERVER [ 'REQUEST_METHOD' ] . ' ' . $ _SERVER [ 'REQUEST_URI' ] : '$: ' . \ implode ( ' ' , $ _SERVER [ 'argv' ] ) ) , null , 'groupCollapsed' , ) ) ; \ array_push ( $ this -> json [ 'rows' ] , array ( array ( ) , null , 'groupEnd' , ) ) ; $ encoded = $ this -> encode ( $ this -> json ) ; if ( \ strlen ( $ encoded ) > 250000 ) { $ this -> debug -> warn ( 'chromeLogger: output limit exceeded' ) ; } else { $ event [ 'headers' ] [ ] = array ( self :: HEADER_NAME , $ encoded ) ; } } $ this -> data = array ( ) ; $ this -> json [ 'rows' ] = array ( ) ; }
7483	public function startsWith ( $ string ) { $ string = static :: convertString ( $ string , $ this -> encoding ) ; return $ string === $ this -> substring ( 0 , ( mb_strlen ( $ string , $ this -> encoding ) - 1 ) ) -> __toString ( ) ; }
12383	public static function perMonth ( $ months = 1 , $ date_format = "Y-m" ) { $ hits_per_month = [ ] ; for ( $ i = 1 ; $ i <= $ months ; $ i ++ ) { $ hits_count = self :: interval ( Carbon :: now ( ) -> subMonths ( $ i ) -> firstOfMonth ( ) , Carbon :: now ( ) -> subMonths ( $ i ) -> lastOfMonth ( ) ) ; $ hits_per_month [ Carbon :: now ( ) -> subMonths ( $ i ) -> format ( $ date_format ) ] = $ hits_count ; } return $ hits_per_month ; }
5212	public function getConstant ( $ name ) { return $ this -> getBinding ( ConstantBinding :: TYPE , $ name ) -> getInstance ( $ this , $ name ) ; }
7241	private function getDefaultClasses ( ) { return [ 'address' => [ Cart \ Model \ CartInterface :: class => Cart \ Entity \ CartAddress :: class , Order \ Model \ OrderInterface :: class => Order \ Entity \ OrderAddress :: class , Quote \ Model \ QuoteInterface :: class => Quote \ Entity \ QuoteAddress :: class , ] , 'attachment' => [ Cart \ Model \ CartInterface :: class => Cart \ Entity \ CartAttachment :: class , Order \ Model \ OrderInterface :: class => Order \ Entity \ OrderAttachment :: class , Quote \ Model \ QuoteInterface :: class => Quote \ Entity \ QuoteAttachment :: class , ] , 'notification' => [ Cart \ Model \ CartInterface :: class => Cart \ Entity \ CartNotification :: class , Order \ Model \ OrderInterface :: class => Order \ Entity \ OrderNotification :: class , Quote \ Model \ QuoteInterface :: class => Quote \ Entity \ QuoteNotification :: class , ] , 'item' => [ Cart \ Model \ CartInterface :: class => Cart \ Entity \ CartItem :: class , Order \ Model \ OrderInterface :: class => Order \ Entity \ OrderItem :: class , Quote \ Model \ QuoteInterface :: class => Quote \ Entity \ QuoteItem :: class , ] , 'adjustment' => [ Cart \ Model \ CartInterface :: class => Cart \ Entity \ CartAdjustment :: class , Order \ Model \ OrderInterface :: class => Order \ Entity \ OrderAdjustment :: class , Quote \ Model \ QuoteInterface :: class => Quote \ Entity \ QuoteAdjustment :: class , ] , 'item_adjustment' => [ Cart \ Model \ CartItemInterface :: class => Cart \ Entity \ CartItemAdjustment :: class , Order \ Model \ OrderItemInterface :: class => Order \ Entity \ OrderItemAdjustment :: class , Quote \ Model \ QuoteItemInterface :: class => Quote \ Entity \ QuoteItemAdjustment :: class , ] , 'item_stock_assignment' => [ Order \ Model \ OrderItemInterface :: class => Order \ Entity \ OrderItemStockAssignment :: class , ] , 'payment' => [ Cart \ Model \ CartInterface :: class => Cart \ Entity \ CartPayment :: class , Order \ Model \ OrderInterface :: class => Order \ Entity \ OrderPayment :: class , Quote \ Model \ QuoteInterface :: class => Quote \ Entity \ QuotePayment :: class , ] , 'shipment' => [ Order \ Model \ OrderInterface :: class => Order \ Entity \ OrderShipment :: class , ] , 'shipment_item' => [ Order \ Model \ OrderShipmentInterface :: class => Order \ Entity \ OrderShipmentItem :: class , ] , 'invoice' => [ Order \ Model \ OrderInterface :: class => Order \ Entity \ OrderInvoice :: class , ] , 'invoice_line' => [ Order \ Model \ OrderInvoiceInterface :: class => Order \ Entity \ OrderInvoiceLine :: class , ] , ] ; }
7833	protected function generatePipes ( ) { foreach ( $ this -> getPipesByOption ( 'attach' ) as $ pipe ) { $ this -> currentPipe = $ pipe ; parent :: fire ( ) ; } }
879	private function resolveSet ( ) { $ rules = $ this -> set ; $ resolvedRules = [ ] ; foreach ( $ rules as $ name => $ value ) { if ( '@' === $ name [ 0 ] ) { if ( ! \ is_bool ( $ value ) ) { throw new \ UnexpectedValueException ( sprintf ( 'Nested rule set "%s" configuration must be a boolean.' , $ name ) ) ; } $ set = $ this -> resolveSubset ( $ name , $ value ) ; $ resolvedRules = array_merge ( $ resolvedRules , $ set ) ; } else { $ resolvedRules [ $ name ] = $ value ; } } $ resolvedRules = array_filter ( $ resolvedRules ) ; $ this -> rules = $ resolvedRules ; return $ this ; }
4771	public function status ( Request $ request , WidgetInterface $ widget , string $ widgetId , bool $ status = true ) { $ widgets = $ widget -> getWidgets ( ) ; if ( isset ( $ widgets [ $ widgetId ] ) ) { $ widgetConfig = $ this -> getDoctrine ( ) -> getRepository ( 'PdWidgetBundle:WidgetUser' ) -> findOneBy ( [ 'owner' => $ this -> getUser ( ) ] ) ?? ( new WidgetUser ( ) ) -> setOwner ( $ this -> getUser ( ) ) ; $ widgetConfig -> addWidgetConfig ( $ widgetId , [ 'status' => $ status ] ) ; $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ em -> persist ( $ widgetConfig ) ; $ em -> flush ( ) ; } return $ this -> redirect ( $ request -> headers -> get ( 'referer' ) ?? $ this -> generateUrl ( $ this -> getParameter ( 'pd_widget.return_route' ) ) ) ; }
257	public function init ( ) { parent :: init ( ) ; if ( is_array ( $ this -> theme ) ) { if ( ! isset ( $ this -> theme [ 'class' ] ) ) { $ this -> theme [ 'class' ] = 'yii\base\Theme' ; } $ this -> theme = Yii :: createObject ( $ this -> theme ) ; } elseif ( is_string ( $ this -> theme ) ) { $ this -> theme = Yii :: createObject ( $ this -> theme ) ; } }
4474	public function perform ( ) : bool { try { $ instance = $ this -> getInstance ( ) ; if ( method_exists ( $ instance , 'setUp' ) ) { $ instance -> setUp ( ) ; } $ this -> getEventsManager ( ) -> fire ( new JobEvent \ BeforePerform ( $ this , $ this ) ) ; $ performMethod = $ this -> getPerformMethod ( ) ; $ instance -> $ performMethod ( $ this ) ; $ this -> getEventsManager ( ) -> fire ( new JobEvent \ AfterPerform ( $ this , $ this ) ) ; if ( method_exists ( $ instance , 'tearDown' ) ) { $ instance -> tearDown ( ) ; } } catch ( \ Throwable $ e ) { $ this -> fail ( 'system:fatal' , sprintf ( '%s: %s in %s on line %d' , get_class ( $ e ) , $ e -> getMessage ( ) , $ e -> getFile ( ) , $ e -> getLine ( ) ) ) ; return false ; } return true ; }
106	public function moveWatch ( $ from , $ to ) { if ( $ this -> watch1 == $ from ) { $ this -> watch1 = $ to ; } else { $ this -> watch2 = $ to ; } }
8445	public function getUser ( IncomingMessage $ matchingMessage ) { $ sender_id = $ matchingMessage -> getRecipient ( ) ; $ user = Collection :: make ( $ this -> payload -> get ( 'users' ) ) -> first ( function ( $ user ) use ( $ sender_id ) { return $ user [ 'id' ] === $ sender_id ; } ) ; return new User ( $ user [ 'id' ] , null , null , $ user [ 'name' ] , $ user ) ; }
9572	public function boot ( ) { if ( $ this -> booted ) return ; $ this -> booting = true ; $ this -> registerProviders ( ) ; foreach ( $ this -> configurators as $ configurator ) { $ this -> invokeConfigurator ( $ configurator ) ; } $ this -> resolveStack ( ) ; $ this -> booted = true ; }
1786	public function generateAlias ( $ varValue , Contao \ DataContainer $ dc ) { $ aliasExists = function ( string $ alias ) use ( $ dc ) : bool { if ( \ in_array ( $ alias , array ( 'top' , 'wrapper' , 'header' , 'container' , 'main' , 'left' , 'right' , 'footer' ) , true ) ) { return true ; } return $ this -> Database -> prepare ( "SELECT id FROM tl_article WHERE alias=? AND id!=?" ) -> execute ( $ alias , $ dc -> id ) -> numRows > 0 ; } ; if ( $ varValue == '' ) { $ varValue = Contao \ System :: getContainer ( ) -> get ( 'contao.slug' ) -> generate ( $ dc -> activeRecord -> title , $ dc -> activeRecord -> pid , $ aliasExists ) ; } elseif ( $ aliasExists ( $ varValue ) ) { throw new Exception ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'aliasExists' ] , $ varValue ) ) ; } return $ varValue ; }
4266	public static function register ( $ pathsExclude = array ( ) ) { $ result = \ stream_wrapper_unregister ( static :: PROTOCOL ) ; if ( $ result === false ) { throw new \ UnexpectedValueException ( 'Failed to unregister' ) ; } if ( $ pathsExclude ) { self :: $ pathsExclude = $ pathsExclude ; } \ stream_wrapper_register ( static :: PROTOCOL , \ get_called_class ( ) ) ; \ ini_set ( 'opcache.enable' , 0 ) ; }
405	public function addCorsHeaders ( $ response , $ headers ) { if ( empty ( $ headers ) === false ) { $ responseHeaders = $ response -> getHeaders ( ) ; foreach ( $ headers as $ field => $ value ) { $ responseHeaders -> set ( $ field , $ value ) ; } } }
6315	public function setUpdateAction ( $ updateAction ) { $ updateAction = strtoupper ( $ updateAction ) ; if ( ! in_array ( $ updateAction , $ this -> getAvailableActions ( ) ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Action %s does not exist.' , $ updateAction ) ) ; } $ this -> updateAction = $ updateAction ; }
4863	public function retry ( JobInterface $ job , array $ options = [ ] ) { $ tried = $ job -> getMetadata ( 'mongoqueue.tries' , 0 ) + 1 ; $ job -> setMetaData ( 'mongoqueue.tries' , $ tried ) ; $ options [ 'tried' ] = $ tried ; $ envelope = $ this -> createEnvelope ( $ job , $ options ) ; unset ( $ envelope [ 'created' ] ) ; $ this -> mongoCollection -> findOneAndUpdate ( [ '_id' => new \ MongoDB \ BSON \ ObjectID ( $ job -> getId ( ) ) ] , [ '$set' => $ envelope ] ) ; }
532	protected function resortChangelog ( $ changelog ) { foreach ( $ changelog as $ i => $ line ) { $ changelog [ $ i ] = rtrim ( $ line ) ; } $ changelog = array_filter ( $ changelog ) ; $ i = 0 ; ArrayHelper :: multisort ( $ changelog , function ( $ line ) use ( & $ i ) { if ( preg_match ( '/^- (Chg|Enh|Bug|New)( #\d+(, #\d+)*)?: .+/' , $ line , $ m ) ) { $ o = [ 'Bug' => 'C' , 'Enh' => 'D' , 'Chg' => 'E' , 'New' => 'F' ] ; return $ o [ $ m [ 1 ] ] . ' ' . ( ! empty ( $ m [ 2 ] ) ? $ m [ 2 ] : 'AAAA' . $ i ++ ) ; } return 'B' . $ i ++ ; } , SORT_ASC , SORT_NATURAL ) ; array_unshift ( $ changelog , '' ) ; $ changelog [ ] = '' ; $ changelog [ ] = '' ; return $ changelog ; }
8604	public function getSubscription ( $ request ) { if ( ! ( $ request instanceof MWSSubscriptionsService_Model_GetSubscriptionInput ) ) { require_once ( dirname ( __FILE__ ) . '/Model/GetSubscriptionInput.php' ) ; $ request = new MWSSubscriptionsService_Model_GetSubscriptionInput ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetSubscription' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/GetSubscriptionResponse.php' ) ; $ response = MWSSubscriptionsService_Model_GetSubscriptionResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
12566	public function sendVideo ( $ message , $ to = null ) { return $ this -> send ( self :: MSG_TYPE_VIDEO , $ message , $ to ) ; }
12046	public function getThumbnails ( $ videoId , $ format = null ) { $ listResponse = $ this -> videos -> listVideos ( 'snippet' , array ( 'id' => $ videoId ) ) ; if ( empty ( $ listResponse ) ) { throw new \ RuntimeException ( sprintf ( 'Could not find video with id %s' , $ videoId ) ) ; } $ video = $ listResponse [ 0 ] ; $ videoSnippet = $ video [ 'snippet' ] ; if ( is_null ( $ format ) ) { return $ videoSnippet [ 'thumbnails' ] [ 'data' ] ; } if ( ! in_array ( $ format , array ( 'default' , 'medium' , 'high' ) ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Invalid format "%s"' , $ format ) ) ; } return $ videoSnippet [ 'thumbnails' ] [ 'data' ] [ $ format ] ; }
7930	public function setCollection ( array $ collection ) { list ( $ collection ) = $ this -> fireEvent ( 'collection.set' , [ $ collection ] ) ; $ this -> collection = [ ] ; foreach ( $ collection as $ asset ) { $ this -> appendToCollection ( $ asset ) ; } return $ this ; }
3351	private function __setRequestType ( $ ch , $ type = 'GET' ) { $ this -> current_method = strtoupper ( $ type ) ; switch ( $ type ) { case 'GET' : break ; case 'POST' : curl_setopt ( $ ch , CURLOPT_POST , true ) ; break ; case 'PUT' : curl_setopt ( $ ch , CURLOPT_CUSTOMREQUEST , 'PUT' ) ; break ; case 'DELETE' : curl_setopt ( $ ch , CURLOPT_CUSTOMREQUEST , 'DELETE' ) ; break ; case 'HEAD' : curl_setopt ( $ ch , CURLOPT_CUSTOMREQUEST , 'HEAD' ) ; curl_setopt ( $ ch , CURLOPT_NOBODY , true ) ; break ; case 'OPTIONS' : curl_setopt ( $ ch , CURLOPT_CUSTOMREQUEST , 'OPTIONS' ) ; break ; default : throw new \ Exception ( 'No request type is provided for request. Use post, put, delete, get or appropriate constants.' ) ; } }
697	public function actionAll ( ) { if ( ! $ this -> confirm ( 'Install all applications and all extensions now?' ) ) { return 1 ; } foreach ( $ this -> extensions as $ ext => $ repo ) { $ ret = $ this -> actionExt ( $ ext ) ; if ( $ ret !== 0 ) { return $ ret ; } } foreach ( $ this -> apps as $ app => $ repo ) { $ ret = $ this -> actionApp ( $ app ) ; if ( $ ret !== 0 ) { return $ ret ; } } return 0 ; }
10486	protected function retrieveMapping ( $ table ) { $ result = $ this -> connection -> fetchAll ( 'SELECT COLUMN_NAME, ORDINAL_POSITION FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = ?' , [ $ table ] ) ; if ( empty ( $ result ) ) { return false ; } $ columns = [ ] ; foreach ( $ result as $ column ) { $ columns [ $ column [ 'ORDINAL_POSITION' ] ] = $ column [ 'COLUMN_NAME' ] ; } return $ columns ; }
7260	protected function createPercentAdjustment ( Model \ AdjustmentInterface $ data , float $ base , string $ currency ) : Adjustment { $ this -> assertAdjustmentMode ( $ data , Model \ AdjustmentModes :: MODE_PERCENT ) ; $ rate = ( float ) $ data -> getAmount ( ) ; if ( $ data -> getType ( ) === Model \ AdjustmentTypes :: TYPE_TAXATION ) { $ amount = Money :: round ( $ base * ( 1 + $ rate / 100 ) , $ currency ) - Money :: round ( $ base , $ currency ) ; } else { $ amount = Money :: round ( $ base * $ rate / 100 , $ currency ) ; } return new Adjustment ( ( string ) $ data -> getDesignation ( ) , $ amount , $ rate ) ; }
8056	public function setChildProcessTitleFormat ( $ string ) { if ( $ this -> created ) { throw new WorkerPoolException ( 'Cannot set the Parent\'s Process Title Format for a created pool.' ) ; } $ this -> childProcessTitleFormat = ProcessDetails :: sanitizeProcessTitleFormat ( $ string ) ; return $ this ; }
3371	private function visitAssociation ( $ className , $ association = null ) { if ( null === $ association ) { if ( isset ( $ this -> visitedAssociations [ $ className ] ) ) { return false ; } $ this -> visitedAssociations [ $ className ] = [ ] ; return true ; } if ( isset ( $ this -> visitedAssociations [ $ className ] [ $ association ] ) ) { return false ; } if ( ! isset ( $ this -> visitedAssociations [ $ className ] ) ) { $ this -> visitedAssociations [ $ className ] = [ ] ; } $ this -> visitedAssociations [ $ className ] [ $ association ] = true ; return true ; }
7657	function Send ( ) { $ header = "" ; $ body = "" ; $ result = true ; if ( ( count ( $ this -> to ) + count ( $ this -> cc ) + count ( $ this -> bcc ) ) < 1 ) { $ this -> SetError ( $ this -> Lang ( "provide_address" ) ) ; return false ; } if ( ! empty ( $ this -> AltBody ) ) $ this -> ContentType = "multipart/alternative" ; $ this -> error_count = 0 ; $ this -> SetMessageType ( ) ; $ header .= $ this -> CreateHeader ( ) ; $ body = $ this -> CreateBody ( ) ; if ( $ body == "" ) { return false ; } switch ( $ this -> Mailer ) { case "sendmail" : $ result = $ this -> SendmailSend ( $ header , $ body ) ; break ; case "mail" : $ result = $ this -> MailSend ( $ header , $ body ) ; break ; case "smtp" : $ result = $ this -> SmtpSend ( $ header , $ body ) ; break ; default : $ this -> SetError ( $ this -> Mailer . $ this -> Lang ( "mailer_not_supported" ) ) ; $ result = false ; break ; } return $ result ; }
12045	public function destroy ( UserPolicy $ user , Question $ question ) { return $ question -> user_id == user_id ( ) && $ question -> user_type == user_type ( ) ; }
2930	public function getValue ( $ key ) { $ allKeys = $ this -> getKeys ( [ $ key ] ) ; if ( array_key_exists ( $ key , $ allKeys ) ) { return $ allKeys [ $ key ] [ 'value' ] ; } throw new KeyNotFoundException ( 'Requested key not found in your file.' ) ; }
7469	protected function parseColor ( $ color , $ code = null ) { $ colors = is_array ( $ color ) ? $ color : [ $ color => $ code ] ; $ return = [ ] ; array_walk ( $ colors , function ( $ code , $ color ) use ( & $ return ) { $ color = $ this -> snakeCase ( $ color ) ; $ return [ $ color ] = $ code ; } ) ; return $ return ; }
3626	protected function getDefaultSerial ( $ serial_number ) { if ( empty ( $ serial_number ) ) { $ devices_serials = $ this -> getDevices ( ) ; if ( count ( $ devices_serials ) == 0 ) { $ devices_serials = $ this -> getDevices ( DEVICE_TYPE_PROTECT ) ; } $ serial_number = $ devices_serials [ 0 ] ; } return $ serial_number ; }
5698	public function baseTransform ( ) { parent :: baseTransform ( ) ; $ disabled = ( ! $ this -> gridFieldRequest -> getNextRecordID ( ) ) ; return $ this -> setDisabled ( $ disabled ) ; }
80	public static function suppress ( $ mask = null ) { if ( ! isset ( $ mask ) ) { $ mask = E_WARNING | E_NOTICE | E_USER_WARNING | E_USER_NOTICE | E_DEPRECATED | E_USER_DEPRECATED | E_STRICT ; } $ old = error_reporting ( ) ; self :: $ stack [ ] = $ old ; error_reporting ( $ old & ~ $ mask ) ; return $ old ; }
240	private function saveTableMetadataToCache ( $ cache , $ name ) { if ( $ cache === null ) { return ; } $ metadata = $ this -> _tableMetadata [ $ name ] ; $ metadata [ 'cacheVersion' ] = static :: SCHEMA_CACHE_VERSION ; $ cache -> set ( $ this -> getCacheKey ( $ name ) , $ metadata , $ this -> db -> schemaCacheDuration , new TagDependency ( [ 'tags' => $ this -> getCacheTag ( ) ] ) ) ; }
449	public function init ( ) { parent :: init ( ) ; $ this -> cachePath = Yii :: getAlias ( $ this -> cachePath ) ; if ( ! is_dir ( $ this -> cachePath ) ) { FileHelper :: createDirectory ( $ this -> cachePath , $ this -> dirMode , true ) ; } }
2859	public function getHttpMethodsSelect ( ) { $ options = $ this -> getHttpMethodOptions ( ) ; array_unshift ( $ options , array ( 'value' => '' , 'label' => 'Any' ) ) ; $ select = $ this -> getLayout ( ) -> createBlock ( 'core/html_select' ) ; $ select -> setName ( 'method' ) -> setId ( 'method' ) -> setValue ( $ this -> getRequest ( ) -> getParam ( 'method' ) ) -> setOptions ( $ options ) ; return $ select -> getHtml ( ) ; }
4579	public function getStartForm ( $ id , Parameters $ parameters = null ) { if ( null !== $ id ) { $ resource = str_replace ( '{id}' , $ id , static :: RESOURCE_OBJECT_START_FORM ) ; } else { $ key = $ parameters -> getKey ( ) ; $ tenantId = $ parameters -> getTenantId ( ) ; switch ( true ) { case null !== $ key && null !== $ tenantId : $ resource = str_replace ( [ '{key}' , '{tenant-id}' ] , [ $ key , $ tenantId ] , static :: RESOURCE_OBJECT_START_FORM_BY_KEY_AND_TENANT_ID ) ; break ; case null !== $ key : $ resource = str_replace ( '{key}' , $ key , static :: RESOURCE_OBJECT_START_FORM_BY_KEY ) ; break ; default : throw new LogicException ( '"Key" and/or "TenantId" parameters are not defined.' ) ; } } $ options = [ 'headers' => [ 'Accept' => 'application/json' ] ] ; $ result = $ this -> execute ( 'GET' , $ resource , $ options ) ; return $ result -> key ; }
6259	protected function _isAllowedRole ( $ userRoles , array $ allowedRoles ) { if ( in_array ( '*' , $ allowedRoles ) ) { return true ; } if ( is_string ( $ userRoles ) ) { $ userRoles = [ $ userRoles ] ; } foreach ( $ userRoles as $ userRole ) { if ( in_array ( $ userRole , $ allowedRoles ) ) { return true ; } } return false ; }
7948	public function getPppLoginByMail ( $ id ) { if ( ! $ id ) throw new BadMethodCallException ( 'Missing parameter $id.' ) ; try { $ this -> post ( 'xdsl/' . $ id . '/requestPPPLoginMail' ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new XdslException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return ; }
3273	public function get ( string $ key ) { Validation :: validateKey ( $ key ) ; if ( $ cache = $ this -> getConfig ( ) -> getCache ( ) ) { if ( $ cache -> contains ( $ key ) ) { return $ cache -> get ( $ key ) ; } } $ file = $ this -> getDatabase ( ) -> readFromFile ( ) ; $ data = false ; foreach ( $ file as $ line ) { if ( $ line -> getKey ( ) == $ key ) { $ data = $ this -> decodeData ( $ line -> getData ( ) ) ; break ; } } if ( $ cache && $ data !== false ) { $ cache -> set ( $ key , $ data ) ; } return $ data ; }
2397	public function parseBbCode ( $ strComment ) { $ arrSearch = array ( '@\[b\](.*)\[/b\]@Uis' , '@\[i\](.*)\[/i\]@Uis' , '@\[u\](.*)\[/u\]@Uis' , '@\s*\[code\](.*)\[/code\]\s*@Uis' , '@\[color=([^\]" ]+)\](.*)\[/color\]@Uis' , '@\s*\[quote\](.*)\[/quote\]\s*@Uis' , '@\s*\[quote=([^\]]+)\](.*)\[/quote\]\s*@Uis' , '@\[img\]\s*([^\[" ]+\.(jpe?g|png|gif|bmp|tiff?|ico))\s*\[/img\]@i' , '@\[url\]\s*([^\[" ]+)\s*\[/url\]@i' , '@\[url=([^\]" ]+)\](.*)\[/url\]@Uis' , '@\[email\]\s*([^\[" ]+)\s*\[/email\]@i' , '@\[email=([^\]" ]+)\](.*)\[/email\]@Uis' , '@href="(([a-z0-9]+\.)*[a-z0-9]+\.([a-z]{2}|asia|biz|com|info|name|net|org|tel)(/|"))@i' ) ; $ arrReplace = array ( '<strong>$1</strong>' , '<em>$1</em>' , '<span style="text-decoration:underline">$1</span>' , "\n\n" . '<div class="code"><p>' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'com_code' ] . '</p><pre>$1</pre></div>' . "\n\n" , '<span style="color:$1">$2</span>' , "\n\n" . '<blockquote>$1</blockquote>' . "\n\n" , "\n\n" . '<blockquote><p>' . sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'com_quote' ] , '$1' ) . '</p>$2</blockquote>' . "\n\n" , '<img src="$1" alt="" />' , '<a href="$1">$1</a>' , '<a href="$1">$2</a>' , '<a href="mailto:$1">$1</a>' , '<a href="mailto:$1">$2</a>' , 'href="http://$1' ) ; $ strComment = preg_replace ( $ arrSearch , $ arrReplace , $ strComment ) ; if ( strpos ( $ strComment , 'mailto:' ) !== false ) { $ strComment = StringUtil :: encodeEmail ( $ strComment ) ; } return $ strComment ; }
10086	public function writeDebugLog ( ... $ args ) { if ( $ this -> writeDebugLog ) { $ message = implode ( $ args ) ; $ cellReference = implode ( ' -> ' , $ this -> cellStack -> showStack ( ) ) ; if ( $ this -> echoDebugLog ) { echo $ cellReference , ( $ this -> cellStack -> count ( ) > 0 ? ' => ' : '' ) , $ message , PHP_EOL ; } $ this -> debugLog [ ] = $ cellReference . ( $ this -> cellStack -> count ( ) > 0 ? ' => ' : '' ) . $ message ; } }
4356	protected function methodTable ( $ array , $ columns = array ( ) ) { if ( ! \ is_array ( $ array ) ) { return $ this -> dump ( $ array ) ; } $ keys = $ columns ? : $ this -> debug -> methodTable -> colKeys ( $ array ) ; $ table = array ( ) ; $ classnames = array ( ) ; if ( $ this -> debug -> abstracter -> isAbstraction ( $ array ) && $ array [ 'traverseValues' ] ) { $ array = $ array [ 'traverseValues' ] ; } foreach ( $ array as $ k => $ row ) { $ values = $ this -> debug -> methodTable -> keyValues ( $ row , $ keys , $ objInfo ) ; $ values = $ this -> methodTableCleanValues ( $ values ) ; $ table [ $ k ] = $ values ; $ classnames [ $ k ] = $ objInfo [ 'row' ] ? $ objInfo [ 'row' ] [ 'className' ] : '' ; } if ( \ array_filter ( $ classnames ) ) { foreach ( $ classnames as $ k => $ classname ) { $ table [ $ k ] = \ array_merge ( array ( ' class_name' => $ classname ) , $ table [ $ k ] ) ; } } return $ table ; }
103	protected function pruneToHighestPriorityOrInstalled ( Pool $ pool , array $ installedMap , array $ literals ) { $ selected = array ( ) ; $ priority = null ; foreach ( $ literals as $ literal ) { $ package = $ pool -> literalToPackage ( $ literal ) ; if ( isset ( $ installedMap [ $ package -> id ] ) ) { $ selected [ ] = $ literal ; continue ; } if ( null === $ priority ) { $ priority = $ this -> getPriority ( $ pool , $ package ) ; } if ( $ this -> getPriority ( $ pool , $ package ) != $ priority ) { break ; } $ selected [ ] = $ literal ; } return $ selected ; }
1688	public function updateStyleSheet ( $ intId ) { $ objStyleSheet = $ this -> Database -> prepare ( "SELECT * FROM tl_style_sheet WHERE id=?" ) -> limit ( 1 ) -> execute ( $ intId ) ; if ( $ objStyleSheet -> numRows < 1 ) { return ; } if ( Input :: get ( 'act' ) == 'delete' ) { $ this -> import ( Files :: class , 'Files' ) ; $ this -> Files -> delete ( 'assets/css/' . $ objStyleSheet -> name . '.css' ) ; } else { $ this -> writeStyleSheet ( $ objStyleSheet -> row ( ) ) ; $ this -> log ( 'Generated style sheet "' . $ objStyleSheet -> name . '.css"' , __METHOD__ , TL_CRON ) ; } }
11895	public function decrypt ( $ data ) { if ( ! is_string ( $ data ) || ! preg_match ( '/^[0-9A-Fa-f]*$/' , $ data ) ) { throw new \ InvalidArgumentException ( 'blowfishDecryptCBC require hex input' , 1502 ) ; } $ data = pack ( 'H*' , $ data ) ; if ( $ this -> iv === null ) { $ return = mcrypt_decrypt ( $ this -> cipher , $ this -> key , $ data , $ this -> mode ) ; } else { $ return = mcrypt_decrypt ( $ this -> cipher , $ this -> key , $ data , $ this -> mode , $ this -> iv ) ; } return rtrim ( $ return , "\0" ) ; }
5131	protected function filterPort ( ? int $ port ) : ? int { if ( ( integer ) $ port >= 0 && ( integer ) $ port <= 65535 ) { return $ port ; } throw new InvalidArgumentException ( 'Uri port must be null or an integer between 1 and 65535 (inclusive)' ) ; }
715	public function double ( $ precision = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_DOUBLE , $ precision ) ; }
10721	public function getLabel ( ) { $ label = $ this -> label ; $ title = $ this -> title ; if ( $ label ) { return $ label ; } else { return $ title ; } }
132	public function disablePlugins ( ) { foreach ( $ this -> installers as $ i => $ installer ) { if ( ! $ installer instanceof PluginInstaller ) { continue ; } unset ( $ this -> installers [ $ i ] ) ; } }
4948	public function findDraftsBy ( array $ criteria , array $ sort = null , $ limit = null , $ skip = null ) { $ criteria [ 'isDraft' ] = true ; return parent :: findBy ( $ criteria , $ sort , $ limit , $ skip ) ; }
7460	public function lookup ( $ hash , $ className = 'Orkestra\Bundle\ApplicationBundle\Entity\User' ) { try { return $ this -> hashedEntityHelper -> lookup ( $ hash , $ className ) ; } catch ( \ RuntimeException $ e ) { return null ; } }
8975	public function parse ( $ stream ) { if ( ! ( $ this -> isValidStream ( $ stream ) ) ) { throw new \ InvalidArgumentException ( __METHOD__ . ' requires a valid stream resource' ) ; } $ original_position = \ ftell ( $ stream ) ; try { \ fseek ( $ stream , 0 ) ; return new PaddedTableNode ( $ this -> readCSVRows ( $ stream ) ) ; } finally { \ fseek ( $ stream , $ original_position ) ; } }
6143	public function checkQuery ( $ query = null ) { if ( $ query === null ) { $ query = $ this -> query ; } if ( strlen ( $ query ) == 0 ) { return true ; } $ pattern = "/^" . $ this -> regex [ "uric" ] . "*$/" ; $ status = @ preg_match ( $ pattern , $ query ) ; if ( $ status === false ) { throw new Ts3Exception ( "URI query string validation failed" ) ; } return ( $ status == 1 ) ; }
8700	public function append ( $ element ) { if ( true === $ element instanceof \ SVGCreator \ Element ) { $ this -> childElements [ ] = $ element ; return $ element ; } else { $ elementCreated = $ this -> factoryElement ( $ element ) ; $ this -> childElements [ ] = $ elementCreated ; return $ elementCreated ; } }
1374	private function filterCommands ( Collection $ commands , $ type ) { $ baseCommandName = 'make:json-api:' ; $ filterValues = explode ( ',' , $ this -> option ( $ type ) ) ; $ targetCommands = collect ( $ filterValues ) -> map ( function ( $ target ) use ( $ baseCommandName ) { return $ baseCommandName . strtolower ( trim ( $ target ) ) ; } ) ; return $ commands -> { $ type } ( $ targetCommands -> toArray ( ) ) ; }
3503	private function prepareCurlResourceByRequest ( Request $ request ) : void { curl_setopt ( $ this -> resource , CURLOPT_URL , $ request -> getUrl ( ) ) ; curl_setopt ( $ this -> resource , CURLOPT_POSTFIELDS , $ request -> getContent ( ) ) ; if ( $ request -> getCertificate ( ) ) { curl_setopt ( $ this -> resource , CURLOPT_SSLCERT , $ request -> getCertificate ( ) ) ; curl_setopt ( $ this -> resource , CURLOPT_SSLCERTPASSWD , $ request -> getCertificatePassPhrase ( ) ) ; } $ inlineHeaders = [ ] ; foreach ( $ request -> getHeaders ( ) as $ name => $ value ) { $ inlineHeaders [ ] = sprintf ( '%s: %s' , $ name , $ value ) ; } curl_setopt ( $ this -> resource , CURLOPT_HTTPHEADER , $ inlineHeaders ) ; }
6716	protected function getRequestChainFromUri ( $ requestedUri ) { $ requestedUri = preg_replace ( '/[\?\.].*$/' , '' , $ requestedUri ) ; $ requestChain = explode ( '/' , $ requestedUri ) ; if ( ! $ requestChain [ 0 ] ) { unset ( $ requestChain [ 0 ] ) ; } return array_values ( $ requestChain ) ; }
12638	public static function select ( string $ table , array $ columns = [ ] , string $ orderBy = "" ) : array { $ pdo = self :: connect ( ) ; $ sql = "SELECT " . ( $ columns === [ ] ? "*" : "\"" . implode ( "\", \"" , $ columns ) . "\"" ) . " FROM \"$table\"" . ( $ orderBy !== "" ? " ORDER BY $orderBy" : "" ) ; $ results = $ pdo -> query ( $ sql ) -> fetchAll ( ) ; return $ results ; }
352	public static function getInputId ( $ model , $ attribute ) { $ charset = Yii :: $ app ? Yii :: $ app -> charset : 'UTF-8' ; $ name = mb_strtolower ( static :: getInputName ( $ model , $ attribute ) , $ charset ) ; return str_replace ( [ '[]' , '][' , '[' , ']' , ' ' , '.' ] , [ '' , '-' , '-' , '' , '-' , '-' ] , $ name ) ; }
8712	public function whereTranslated ( $ column , $ operator = null , $ value = null , $ boolean = 'and' ) { if ( func_num_args ( ) == 2 ) { list ( $ value , $ operator ) = [ $ operator , '=' ] ; } elseif ( $ this -> invalidOperatorAndValue ( $ operator , $ value ) ) { throw new InvalidArgumentException ( 'Illegal operator and value combination.' ) ; } if ( ! in_array ( strtolower ( $ operator ) , $ this -> operators , true ) ) { list ( $ value , $ operator ) = [ $ operator , '=' ] ; } $ fallbackColumn = $ this -> qualifyTranslationColumn ( $ column , true ) ; $ column = $ this -> qualifyTranslationColumn ( $ column ) ; if ( ! $ this -> model -> shouldFallback ( ) || $ column instanceof Closure ) { return $ this -> where ( $ column , $ operator , $ value , $ boolean ) ; } $ condition = $ this -> compileIfNull ( $ column , $ fallbackColumn ) ; return $ this -> whereRaw ( "$condition $operator ?" , [ $ value ] , $ boolean ) ; }
2097	public static function getRegexp ( $ strFormat = null ) { if ( $ strFormat === null ) { $ strFormat = static :: getNumericDateFormat ( ) ; } if ( ! static :: isNumericFormat ( $ strFormat ) ) { throw new \ Exception ( sprintf ( 'Invalid date format "%s"' , $ strFormat ) ) ; } return preg_replace_callback ( '/[a-zA-Z]/' , function ( $ matches ) { $ arrRegexp = array ( 'a' => '(?P<a>am|pm)' , 'A' => '(?P<A>AM|PM)' , 'd' => '(?P<d>0[1-9]|[12][0-9]|3[01])' , 'g' => '(?P<g>[1-9]|1[0-2])' , 'G' => '(?P<G>[0-9]|1[0-9]|2[0-3])' , 'h' => '(?P<h>0[1-9]|1[0-2])' , 'H' => '(?P<H>[01][0-9]|2[0-3])' , 'i' => '(?P<i>[0-5][0-9])' , 'j' => '(?P<j>[1-9]|[12][0-9]|3[01])' , 'm' => '(?P<m>0[1-9]|1[0-2])' , 'n' => '(?P<n>[1-9]|1[0-2])' , 's' => '(?P<s>[0-5][0-9])' , 'Y' => '(?P<Y>[0-9]{4})' , 'y' => '(?P<y>[0-9]{2})' , ) ; return $ arrRegexp [ $ matches [ 0 ] ] ?? $ matches [ 0 ] ; } , preg_quote ( $ strFormat ) ) ; }
9486	protected function checkFieldsSet ( $ fields ) { foreach ( $ fields as $ field ) { if ( property_exists ( $ this , $ field ) && $ this -> $ field === null ) { throw new \ Exception ( "'$field' is required" ) ; } } }
12044	public function view ( UserPolicy $ user , Question $ question ) { if ( $ user -> canDo ( 'forum.question.view' ) && $ user -> isAdmin ( ) ) { return true ; } return $ question -> user_id == user_id ( ) && $ question -> user_type == user_type ( ) ; }
10890	public static function input ( $ prompt , $ default = null ) { $ ret = false ; while ( ! $ ret ) { if ( $ prompt ) { echo $ prompt ; if ( $ default ) echo " (" . $ default . ")" ; echo ": " ; } $ ret = trim ( fgets ( STDIN ) ) ; if ( ! $ ret && $ default !== null ) return $ default ; } return trim ( $ ret ) ; }
1514	public function update ( StoreInterface $ store , UpdateResource $ request ) { $ record = $ this -> transaction ( function ( ) use ( $ store , $ request ) { return $ this -> doUpdate ( $ store , $ request ) ; } ) ; if ( $ this -> isResponse ( $ record ) ) { return $ record ; } return $ this -> reply ( ) -> updated ( $ record ) ; }
2933	public function deleteKeys ( $ keys = [ ] ) { foreach ( $ keys as $ key ) { $ this -> writer -> deleteSetter ( $ key ) ; } return $ this ; }
7003	public function match ( $ test ) { $ isArray = [ ] ; $ pattern = preg_replace_callback ( "~/\{(?<arg>\w+)(?<arr>\[\])?\}(?<num>\?|\+|\*|\{[0-9,]+\})?~" , function ( $ matches ) use ( & $ isArray ) { $ name = $ matches [ "arg" ] ; $ num = $ matches [ "num" ] ?? "" ; $ isArray [ $ name ] = ! empty ( $ matches [ 2 ] ) ; return "(?<$name>(?:/[^\\s/?]+)$num)" ; } , $ this -> url ) ; if ( ! $ pattern || empty ( $ pattern ) ) { error_log ( "pattern error: found in route with pattern: {$this->url}" ) ; return false ; } $ pattern = "^$pattern/?(?:\?.*)?$" ; if ( preg_match ( "~$pattern~" , $ test , $ matches ) ) { foreach ( $ matches as $ name => $ val ) { $ val = urldecode ( $ val ) ; if ( is_int ( $ name ) ) { if ( $ name === 0 ) $ this -> args [ $ name ] = $ val ; } else { $ val = ltrim ( $ val , "/" ) ; $ this -> args [ $ name ] = $ isArray [ $ name ] ? explode ( "/" , $ val ) : $ val ; } } return true ; } return false ; }
12615	public function addAttribute ( AttributeInterface $ attribute ) { if ( isset ( $ this -> attributes [ $ attribute -> getName ( ) ] ) ) trigger_error ( "Attribute " . $ attribute -> getName ( ) . " already exists" , E_USER_NOTICE ) ; $ this -> attributes [ $ attribute -> getName ( ) ] = $ attribute ; }
9430	public function getFontIconTag ( ) { if ( $ this -> owner -> hasFontIcon ( ) ) { return $ this -> backend -> getTag ( $ this -> owner -> FontIconClass , $ this -> owner -> FontIconColor ) ; } }
12218	public function shutdownHandler ( ) { $ error = error_get_last ( ) ; if ( $ error && $ error [ 'type' ] & $ this -> fatalErrors ) { $ this -> errorHandler ( $ error [ 'type' ] , $ error [ 'message' ] , $ error [ 'file' ] , $ error [ 'line' ] ) ; } }
2113	public function generate ( ) { if ( TL_MODE == 'BE' ) { $ objTemplate = new BackendTemplate ( 'be_wildcard' ) ; $ objTemplate -> wildcard = '### ' . Utf8 :: strtoupper ( $ GLOBALS [ 'TL_LANG' ] [ 'FMD' ] [ 'articlenav' ] [ 0 ] ) . ' ###' ; $ objTemplate -> title = $ this -> headline ; $ objTemplate -> id = $ this -> id ; $ objTemplate -> link = $ this -> name ; $ objTemplate -> href = 'contao/main.php?do=themes&amp;table=tl_module&amp;act=edit&amp;id=' . $ this -> id ; return $ objTemplate -> parse ( ) ; } global $ objPage ; $ this -> objArticles = ArticleModel :: findPublishedWithTeaserByPidAndColumn ( $ objPage -> id , $ this -> strColumn ) ; if ( $ this -> objArticles === null ) { return '' ; } if ( ! Input :: get ( 'articles' ) ) { if ( ! $ this -> loadFirst ) { return '' ; } $ objArticle = $ this -> objArticles -> current ( ) ; $ strAlias = $ objArticle -> alias ? : $ objArticle -> id ; $ this -> redirect ( $ objPage -> getFrontendUrl ( '/articles/' . $ strAlias ) ) ; } return parent :: generate ( ) ; }
8267	public function close ( ) { if ( ! $ this -> isOpened ( ) ) { return ; } $ this -> unlock ( ) ; if ( $ this -> handle && ! fclose ( $ this -> handle ) ) { throw new \ RuntimeException ( "Could not close file " . $ this -> filePath ) ; } }
473	public function batchInsert ( $ table , $ columns , $ rows ) { $ time = $ this -> beginCommand ( "insert into $table" ) ; $ this -> db -> createCommand ( ) -> batchInsert ( $ table , $ columns , $ rows ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
2898	public function queryEnd ( $ queryId ) { $ result = $ this -> parentQueryEnd ( $ queryId ) ; if ( $ this -> captureStacktraces ) { $ this -> stackTraces [ $ queryId ] = $ this -> getStackTrace ( ) ; } return $ result ; }
1008	public static function suggestionList ( $ input , array $ options ) { $ optionsByDistance = [ ] ; $ inputThreshold = mb_strlen ( $ input ) / 2 ; foreach ( $ options as $ option ) { if ( $ input === $ option ) { $ distance = 0 ; } else { $ distance = ( strtolower ( $ input ) === strtolower ( $ option ) ? 1 : levenshtein ( $ input , $ option ) ) ; } $ threshold = max ( $ inputThreshold , mb_strlen ( $ option ) / 2 , 1 ) ; if ( $ distance > $ threshold ) { continue ; } $ optionsByDistance [ $ option ] = $ distance ; } asort ( $ optionsByDistance ) ; return array_keys ( $ optionsByDistance ) ; }
1763	public function onKernelTerminate ( PostResponseEvent $ event ) : void { if ( ! $ this -> framework -> isInitialized ( ) || ! $ this -> canRunController ( $ event -> getRequest ( ) ) ) { return ; } $ controller = $ this -> framework -> createInstance ( FrontendCron :: class ) ; $ controller -> run ( ) ; }
4901	public static function loadConfig ( $ configuration = [ ] ) { $ configDir = static :: getConfigDir ( ) ; if ( empty ( $ configuration ) ) { $ configFile = $ configDir . '/config.php' ; if ( ! is_file ( $ configFile ) ) { throw new InvalidArgumentException ( sprintf ( 'Can not load config file "%s". Please be sure that this file exists and readable' , $ configFile ) ) ; } $ configuration = include $ configFile ; } $ isCli = php_sapi_name ( ) === 'cli' ; $ modules = $ configuration [ 'modules' ] ; $ modules = static :: generateModuleConfiguration ( $ modules ) ; $ yawikConfig = $ configDir . '/autoload/yawik.config.global.php' ; $ installMode = false ; if ( ! $ isCli && ! file_exists ( $ yawikConfig ) ) { $ modules = static :: generateModuleConfiguration ( [ 'Install' ] ) ; $ installMode = true ; } elseif ( in_array ( 'Install' , $ modules ) ) { $ modules = array_diff ( $ modules , [ 'Install' ] ) ; } static :: $ env = $ env = getenv ( 'APPLICATION_ENV' ) ? : 'production' ; $ defaults = [ 'module_listener_options' => [ 'module_paths' => [ './module' , './vendor' , './modules' ] , 'config_glob_paths' => [ sprintf ( $ configDir . '/autoload/{,*.}{global,%s,local}.php' , $ env ) ] , 'config_cache_enabled' => ( $ env == 'production' ) , 'module_map_cache_enabled' => ( $ env == 'production' ) , 'module_map_cache_key' => 'module_map' , 'check_dependencies' => ( $ env != 'production' ) , 'cache_dir' => getcwd ( ) . "/var/cache" , ] , ] ; $ envConfig = [ ] ; $ envConfigFile = $ configDir . '/config.' . $ env . '.php' ; if ( file_exists ( $ envConfigFile ) ) { if ( is_readable ( $ envConfigFile ) ) { $ envConfig = include $ envConfigFile ; } else { \ trigger_error ( sprintf ( 'Environment config file "%s" is not readable.' , $ envConfigFile ) , E_USER_NOTICE ) ; } } $ configuration = ArrayUtils :: merge ( $ defaults , $ configuration ) ; $ configuration = ArrayUtils :: merge ( $ configuration , $ envConfig ) ; $ configuration [ 'modules' ] = $ modules ; if ( $ installMode ) { $ configuration [ 'module_listener_options' ] [ 'config_cache_enabled' ] = false ; $ configuration [ 'module_listener_options' ] [ 'module_map_cache_enabled' ] = false ; } if ( getenv ( 'DOCKER_ENV' ) == 'yes' ) { $ configuration = ArrayUtils :: merge ( $ configuration , static :: getDockerEnv ( $ configuration ) ) ; } return $ configuration ; }
12515	public static function exists ( $ path ) { $ path = Path :: clean ( $ path ) ; $ fs = new Filesystem ( ) ; return $ fs -> exists ( $ path ) ; }
5489	public static function parseArguments ( $ argv , $ mutliValueMode = false ) { $ args = array ( ) ; $ args [ 'extraArguments' ] = array ( ) ; array_shift ( $ argv ) ; foreach ( $ argv as $ arg ) { if ( preg_match ( '#^--([^=]+)=(.*)#' , $ arg , $ reg ) ) { $ args [ $ reg [ 1 ] ] = $ reg [ 2 ] ; if ( $ mutliValueMode ) { self :: addItemAsArray ( $ args , $ reg [ 1 ] , $ reg [ 2 ] ) ; } } elseif ( preg_match ( '#^[-]{1,2}([^[:blank:]]+)#' , $ arg , $ reg ) ) { $ nonnull = '' ; $ args [ $ reg [ 1 ] ] = $ nonnull ; if ( $ mutliValueMode ) { self :: addItemAsArray ( $ args , $ reg [ 1 ] , $ nonnull ) ; } } else { $ args [ 'extraArguments' ] [ ] = $ arg ; } } return $ args ; }
9428	public function updateCMSFields ( FieldList $ fields ) { $ fields -> insertAfter ( Tab :: create ( 'Icon' , $ this -> owner -> fieldLabel ( 'Icon' ) ) , 'Main' ) ; $ fields -> addFieldsToTab ( 'Root.Icon' , [ FontIconField :: create ( 'FontIcon' , $ this -> owner -> fieldLabel ( 'FontIcon' ) ) , ColorField :: create ( 'FontIconColor' , $ this -> owner -> fieldLabel ( 'FontIconColor' ) ) ] ) ; }
11340	public function generateRules ( $ table ) { $ types = [ ] ; $ lengths = [ ] ; foreach ( $ table -> columns as $ column ) { if ( $ column -> autoIncrement ) { continue ; } if ( ! $ column -> allowNull && $ column -> defaultValue === null && ! $ column -> isPrimaryKey ) { $ types [ 'required' ] [ ] = $ column -> name ; } switch ( $ column -> type ) { case Schema :: TYPE_SMALLINT : case Schema :: TYPE_INTEGER : case Schema :: TYPE_BIGINT : $ types [ 'integer' ] [ ] = $ column -> name ; break ; case Schema :: TYPE_BOOLEAN : $ types [ 'boolean' ] [ ] = $ column -> name ; break ; case Schema :: TYPE_FLOAT : case Schema :: TYPE_DECIMAL : case Schema :: TYPE_MONEY : $ types [ 'number' ] [ ] = $ column -> name ; break ; case Schema :: TYPE_DATE : case Schema :: TYPE_TIME : case Schema :: TYPE_DATETIME : case Schema :: TYPE_TIMESTAMP : if ( ! in_array ( $ column -> name , [ 'created' , 'deleted' , 'modified' ] ) ) { $ types [ 'safe' ] [ ] = $ column -> name ; } break ; default : if ( $ column -> size > 0 ) { $ lengths [ $ column -> size ] [ ] = $ column -> name ; } else { $ types [ 'string' ] [ ] = $ column -> name ; } } } $ rules = [ ] ; foreach ( $ types as $ type => $ columns ) { $ rules [ ] = "[['" . implode ( "', '" , $ columns ) . "'], '$type']" ; } foreach ( $ lengths as $ length => $ columns ) { $ rules [ ] = "[['" . implode ( "', '" , $ columns ) . "'], 'string', 'max' => $length]" ; } return $ rules ; }
12539	public static function dasherize ( $ str , $ replacement = '_' ) { return preg_replace_callback ( '/([A-Z0-9-\s]+)/' , function ( $ match ) use ( $ replacement ) { return $ replacement . strtolower ( $ match [ 1 ] ) ; } , lcfirst ( $ str ) ) ; }
2849	public function setSqlProfilerStatus ( $ isEnabled ) { $ filePath = $ this -> getLocalXmlFilePath ( ) ; $ xml = $ this -> loadXmlFile ( $ filePath ) ; if ( $ xml === false ) { throw new Exception ( "Unable to parse local.xml configuration file: {$filePath}" ) ; } $ connectionNode = $ xml -> global -> resources -> default_setup -> connection ; if ( $ isEnabled ) { $ connectionNode -> profiler = '1' ; } else { unset ( $ connectionNode -> profiler ) ; } if ( $ this -> saveXml ( $ xml , $ filePath ) === false ) { throw new Exception ( "Unable to save {$filePath}: check if web server user has write permission" ) ; } }
12594	protected function makeDir ( $ dirName , LoggerInterface $ logger ) { $ dn = explode ( getcwd ( ) , $ dirName ) [ 1 ] ?? $ dirName ; if ( @ mkdir ( $ dirName ) ) { $ logger -> logText ( "Created directory <fg=green>%s</>" , LoggerInterface :: VERBOSITY_NORMAL , NULL , $ dn ) ; } else { $ logger -> logWarning ( "Creating directory $dn failed" ) ; } }
997	public function offsetUnset ( $ offset ) { if ( $ offset === true ) { $ this -> trueValue = null ; $ this -> trueValueIsSet = false ; } elseif ( $ offset === false ) { $ this -> falseValue = null ; $ this -> falseValueIsSet = false ; } elseif ( is_int ( $ offset ) || is_string ( $ offset ) ) { unset ( $ this -> standardStore [ $ offset ] ) ; } elseif ( is_float ( $ offset ) ) { unset ( $ this -> floatStore [ ( string ) $ offset ] ) ; } elseif ( is_object ( $ offset ) ) { $ this -> objectStore -> offsetUnset ( $ offset ) ; } elseif ( is_array ( $ offset ) ) { $ index = array_search ( $ offset , $ this -> arrayKeys , true ) ; if ( $ index !== false ) { array_splice ( $ this -> arrayKeys , $ index , 1 ) ; array_splice ( $ this -> arrayValues , $ index , 1 ) ; } } elseif ( $ offset === null ) { $ this -> nullValue = null ; $ this -> nullValueIsSet = false ; } }
5046	public function form ( $ form , $ options = null , $ as = 'searchform' ) { if ( is_string ( $ options ) ) { $ as = $ options ; $ options = null ; } $ this -> stack [ 'form' ] = [ 'as' => $ as , $ form , $ options ] ; return $ this ; }
3911	protected function fetchAdditionalData ( ) { $ this -> modifiedTime = array ( ) ; $ this -> outputBuffer = array ( ) ; if ( ! $ this -> foundFiles ) { return ; } foreach ( $ this -> foundFiles as $ strFile ) { $ this -> processFile ( $ strFile ) ; } }
3636	public function rpcMiddles ( Request $ request ) : array { $ beanName = 'serviceDispatcher' ; if ( ! \ Swoft :: hasBean ( $ beanName ) ) { return [ ] ; } $ dispatcher = \ bean ( $ beanName ) ; $ middleType = ( int ) $ request -> query ( 'type' ) ; if ( $ middleType === 1 ) { return $ dispatcher -> getMiddlewares ( ) ; } return $ dispatcher -> requestMiddleware ( ) ; }
4766	protected function validateInvoiceAddressOptIn ( ) { $ return = true ; $ optin = ( int ) $ this -> getRequestParameter ( 'oegdproptin_invoiceaddress' ) ; $ changeExistigAddress = ( int ) $ this -> getRequestParameter ( 'oegdproptin_changeInvAddress' ) ; if ( \ OxidEsales \ Eshop \ Core \ Registry :: getConfig ( ) -> getConfigParam ( 'blOeGdprOptinInvoiceAddress' ) && ( 1 == $ changeExistigAddress ) && ( 1 !== $ optin ) ) { $ return = false ; } return $ return ; }
4739	public static function clearTmp ( $ clearFolderPath = '' ) { $ folderPath = self :: _getFolderToClear ( $ clearFolderPath ) ; $ directoryHandler = opendir ( $ folderPath ) ; if ( ! empty ( $ directoryHandler ) ) { while ( false !== ( $ fileName = readdir ( $ directoryHandler ) ) ) { $ filePath = $ folderPath . DIRECTORY_SEPARATOR . $ fileName ; self :: _clear ( $ fileName , $ filePath ) ; } closedir ( $ directoryHandler ) ; } return true ; }
2844	public function renderTreeNode ( Varien_Data_Tree_Node $ node , $ indentLevel = 0 ) { $ block = $ this -> getLayout ( ) -> createBlock ( 'sheep_debug/view' ) ; $ block -> setRequestInfo ( $ this -> getRequestInfo ( ) ) ; $ block -> setTemplate ( 'sheep_debug/view/panel/_block_node.phtml' ) ; $ block -> setNode ( $ node ) ; $ block -> setIndent ( $ indentLevel ) ; return $ block -> toHtml ( ) ; }
376	protected function parseDocCommentDetail ( $ reflection ) { $ comment = strtr ( trim ( preg_replace ( '/^\s*\**( |\t)?/m' , '' , trim ( $ reflection -> getDocComment ( ) , '/' ) ) ) , "\r" , '' ) ; if ( preg_match ( '/^\s*@\w+/m' , $ comment , $ matches , PREG_OFFSET_CAPTURE ) ) { $ comment = trim ( substr ( $ comment , 0 , $ matches [ 0 ] [ 1 ] ) ) ; } if ( $ comment !== '' ) { return rtrim ( Console :: renderColoredString ( Console :: markdownToAnsi ( $ comment ) ) ) ; } return '' ; }
297	public function getDirtyAttributes ( $ names = null ) { if ( $ names === null ) { $ names = $ this -> attributes ( ) ; } $ names = array_flip ( $ names ) ; $ attributes = [ ] ; if ( $ this -> _oldAttributes === null ) { foreach ( $ this -> _attributes as $ name => $ value ) { if ( isset ( $ names [ $ name ] ) ) { $ attributes [ $ name ] = $ value ; } } } else { foreach ( $ this -> _attributes as $ name => $ value ) { if ( isset ( $ names [ $ name ] ) && ( ! array_key_exists ( $ name , $ this -> _oldAttributes ) || $ value !== $ this -> _oldAttributes [ $ name ] ) ) { $ attributes [ $ name ] = $ value ; } } } return $ attributes ; }
8257	protected function startAuthentication ( ) { $ authorizationUrl = $ this -> provider -> getAuthorizationUrl ( ) ; $ this -> session -> migrate ( true ) ; $ this -> session -> set ( "oauth2state" , $ this -> provider -> getState ( ) ) ; $ this -> picoAuth -> redirectToPage ( $ authorizationUrl , null , false ) ; }
1389	protected function resourceExists ( string $ type , string $ id , string $ path = '/data' ) : void { $ this -> errors -> add ( $ this -> translator -> resourceExists ( $ type , $ id , $ path ) ) ; }
1305	public function index ( ) { $ discussions = Discussion :: limit ( 20 ) -> orderBy ( 'created_at' , 'DESC' ) -> get ( ) ; $ discussions -> load ( [ 'user' , 'posts' ] ) ; $ xml = new SimpleXMLElement ( '<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/" xml:lang="en-US"/>' ) ; $ xml -> addChild ( 'id' , route ( 'chatter.home' ) ) ; $ link = $ xml -> addChild ( 'link' ) ; $ link -> addAttribute ( 'type' , 'text/html' ) ; $ link -> addAttribute ( 'href' , route ( 'chatter.home' ) ) ; $ link = $ xml -> addChild ( 'link' ) ; $ link -> addAttribute ( 'type' , 'application/atom+xml' ) ; $ link -> addAttribute ( 'rel' , 'self' ) ; $ link -> addAttribute ( 'href' , route ( 'chatter.atom' ) ) ; $ xml -> addChild ( 'title' , config ( 'app.name' ) . ' Discussions' ) ; $ updated = count ( $ discussions ) ? Carbon :: parse ( $ discussions [ 0 ] -> created_at ) : Carbon :: now ( ) ; $ xml -> addChild ( 'updated' , $ updated -> toAtomString ( ) ) ; foreach ( $ discussions as $ discussion ) { $ child = $ xml -> addChild ( 'entry' ) ; $ child -> addChild ( 'id' , route ( 'chatter.discussion.show' , [ 'discussion' => $ discussion -> slug ] ) ) ; $ child -> addChild ( 'title' , $ discussion -> title ) ; $ link = $ child -> addChild ( 'link' ) ; $ link -> addAttribute ( 'type' , 'text/html' ) ; $ link -> addAttribute ( 'rel' , 'alternate' ) ; $ link -> addAttribute ( 'href' , route ( 'chatter.discussion.show' , [ 'discussion' => $ discussion -> slug ] ) ) ; $ child -> addChild ( 'updated' , Carbon :: parse ( $ discussion -> created_at ) -> toAtomString ( ) ) ; $ author = $ child -> addChild ( 'author' ) ; $ author -> addChild ( 'name' , $ discussion -> user -> name ) ; $ content = $ child -> addChild ( 'content' , htmlentities ( count ( $ discussion -> posts ) ? $ discussion -> posts [ 0 ] -> body : '' ) ) ; $ content -> addAttribute ( 'type' , 'html' ) ; } return response ( $ xml -> asXML ( ) , 200 , [ 'Content-Type' => 'application/atom+xml' , ] ) ; }
837	public static function detectBlockType ( Token $ token ) { foreach ( self :: getBlockEdgeDefinitions ( ) as $ type => $ definition ) { if ( $ token -> equals ( $ definition [ 'start' ] ) ) { return [ 'type' => $ type , 'isStart' => true ] ; } if ( $ token -> equals ( $ definition [ 'end' ] ) ) { return [ 'type' => $ type , 'isStart' => false ] ; } } }
6224	public function removeDir ( ) : bool { if ( ! $ this -> isDir ( ) ) { throw new AccessDeniedException ( sprintf ( 'unable to remove directory for path: "%s"' , $ this -> path -> raw ) , 500 ) ; } try { $ iterator = $ this -> getIterator ( true , \ RecursiveIteratorIterator :: CHILD_FIRST ) ; foreach ( $ iterator as $ splFile ) { if ( ! $ splFile -> isReadable ( ) ) { throw new AccessDeniedException ( sprintf ( 'unable to access file for path: "%s"' , $ splFile -> getPathname ( ) ) , 500 ) ; } switch ( $ splFile -> getType ( ) ) { case 'dir' : rmdir ( $ splFile -> getRealPath ( ) ) ; break ; case 'link' : unlink ( $ splFile -> getPathname ( ) ) ; break ; default : unlink ( $ splFile -> getRealPath ( ) ) ; } } return rmdir ( $ this -> path -> raw ) ; } finally { $ this -> selfdestruct = false ; $ this -> path -> reload ( ) ; } }
1043	public static function printError ( Error $ error ) { $ printedLocations = [ ] ; if ( $ error -> nodes ) { foreach ( $ error -> nodes as $ node ) { if ( ! $ node -> loc ) { continue ; } if ( $ node -> loc -> source === null ) { continue ; } $ printedLocations [ ] = self :: highlightSourceAtLocation ( $ node -> loc -> source , $ node -> loc -> source -> getLocation ( $ node -> loc -> start ) ) ; } } elseif ( $ error -> getSource ( ) && $ error -> getLocations ( ) ) { $ source = $ error -> getSource ( ) ; foreach ( $ error -> getLocations ( ) as $ location ) { $ printedLocations [ ] = self :: highlightSourceAtLocation ( $ source , $ location ) ; } } return ! $ printedLocations ? $ error -> getMessage ( ) : implode ( "\n\n" , array_merge ( [ $ error -> getMessage ( ) ] , $ printedLocations ) ) . "\n" ; }
1792	private function addHostToContext ( RequestContext $ context , array $ parameters , int & $ referenceType ) : void { [ $ host , $ port ] = $ this -> getHostAndPort ( $ parameters [ '_domain' ] ) ; if ( $ context -> getHost ( ) === $ host ) { return ; } $ context -> setHost ( $ host ) ; $ referenceType = UrlGeneratorInterface :: ABSOLUTE_URL ; if ( ! $ port ) { return ; } if ( isset ( $ parameters [ '_ssl' ] ) && true === $ parameters [ '_ssl' ] ) { $ context -> setHttpsPort ( $ port ) ; } else { $ context -> setHttpPort ( $ port ) ; } }
4351	private function setDebugCfg ( $ cfg ) { if ( isset ( $ cfg [ 'key' ] ) ) { $ cfg = \ array_merge ( $ cfg , $ this -> debugKeyValues ( $ cfg [ 'key' ] ) ) ; } if ( isset ( $ cfg [ 'logEnvInfo' ] ) && \ is_bool ( $ cfg [ 'logEnvInfo' ] ) ) { $ keys = \ array_keys ( $ this -> cfg [ 'logEnvInfo' ] ) ; $ cfg [ 'logEnvInfo' ] = \ array_fill_keys ( $ keys , $ cfg [ 'logEnvInfo' ] ) ; } if ( isset ( $ cfg [ 'logServerKeys' ] ) ) { $ this -> cfg [ 'logServerKeys' ] = array ( ) ; } $ this -> cfg = $ this -> debug -> utilities -> arrayMergeDeep ( $ this -> cfg , $ cfg ) ; }
3631	public function events ( Request $ request ) : array { $ type = ( int ) $ request -> query ( 'type' ) ; if ( $ type === 1 ) { return ServerListenerCollector :: getCollector ( ) ; } if ( $ type === 2 ) { return SwooleListenerCollector :: getCollector ( ) ; } return [ 'server' => ServerListenerCollector :: getCollector ( ) , 'swoole' => SwooleListenerCollector :: getCollector ( ) , ] ; }
310	protected function composeMessage ( $ body ) { $ message = $ this -> mailer -> compose ( ) ; Yii :: configure ( $ message , $ this -> message ) ; $ message -> setTextBody ( $ body ) ; return $ message ; }
10416	protected function addStatusField ( Table $ table ) { if ( empty ( $ this -> shops ) ) { $ table -> addColumn ( 'status' , 'boolean' , [ 'default' => 0 ] ) -> setComment ( '0-new,1-done' ) ; $ table -> addIndex ( [ 'status' ] ) ; } else { foreach ( $ this -> shops as $ shop ) { $ fieldName = "status_{$shop}" ; $ table -> addColumn ( $ fieldName , 'boolean' , [ 'default' => 0 ] ) -> setComment ( '0-new,1-done' ) ; $ table -> addIndex ( [ $ fieldName ] ) ; } } }
2199	public static function findPublishedByIdOrAliasAndPid ( $ varId , $ intPid , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = ! preg_match ( '/^[1-9]\d*$/' , $ varId ) ? array ( "$t.alias=?" ) : array ( "$t.id=?" ) ; $ arrValues = array ( $ varId ) ; if ( $ intPid ) { $ arrColumns [ ] = "$t.pid=?" ; $ arrValues [ ] = $ intPid ; } if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } return static :: findOneBy ( $ arrColumns , $ arrValues , $ arrOptions ) ; }
7463	private static function renderTemplate ( string $ __file__ , array $ data ) : string { ob_start ( ) ; extract ( $ data ) ; include $ __file__ ; return ob_get_clean ( ) ; }
6049	public function setProperties ( array $ properties ) { $ this -> properties = [ ] ; foreach ( $ properties as $ item ) { $ this -> addPropertyResponse ( $ item ) ; } return $ this ; }
371	public function isColorEnabled ( $ stream = \ STDOUT ) { return $ this -> color === null ? Console :: streamSupportsAnsiColors ( $ stream ) : $ this -> color ; }
6778	protected function updateVatDisplayMode ( SaleInterface $ sale ) { if ( $ sale -> hasPayments ( ) ) { return false ; } $ mode = null ; if ( null !== $ group = $ sale -> getCustomerGroup ( ) ) { $ mode = $ group -> getVatDisplayMode ( ) ; } if ( null === $ mode ) { $ mode = $ this -> defaultVatDisplayMode ; } if ( $ mode !== $ sale -> getVatDisplayMode ( ) ) { $ sale -> setVatDisplayMode ( $ mode ) ; return true ; } return false ; }
8143	public function getLexer ( ) { @ trigger_error ( sprintf ( 'The %s() method is deprecated since version 1.25 and will be removed in 2.0.' , __FUNCTION__ ) , E_USER_DEPRECATED ) ; if ( null === $ this -> lexer ) { $ this -> lexer = new Twig_Lexer ( $ this ) ; } return $ this -> lexer ; }
11925	public function generate ( string $ outputDir ) : array { $ generatedFiles = [ ] ; foreach ( $ this -> generators as $ generator ) { $ this -> logger -> info ( 'Running generator ' . get_class ( $ generator ) ) ; $ result = $ generator -> generate ( ) ; foreach ( $ result -> all ( ) as $ phpFile ) { $ path = str_replace ( [ '/' , "\\" ] , DIRECTORY_SEPARATOR , $ outputDir . '/' . $ phpFile -> getFqcn ( ) -> getNamespace ( ) ) ; BaseUtil :: ensureDirectory ( $ path , 0711 ) ; $ filePath = $ path . DIRECTORY_SEPARATOR . $ phpFile -> getFqcn ( ) -> getName ( ) . '.php' ; $ this -> logger -> info ( 'Writing to file ' . $ filePath ) ; file_put_contents ( $ filePath , $ phpFile -> getText ( ) ) ; $ generatedFiles [ ] = new GeneratedFile ( $ filePath , $ phpFile ) ; } } return $ generatedFiles ; }
2389	private function applyFallback ( array & $ config , array $ action , bool $ skipLegends = false ) : void { if ( \ is_callable ( $ action [ 'fallback' ] ) ) { $ action [ 'fallback' ] ( $ config , $ action , $ skipLegends ) ; } else { $ this -> applyFallbackPalette ( $ config , $ action ) ; } }
11208	protected function getValue ( $ data , $ key = false ) { $ returnValue = $ data ; if ( $ key && is_object ( $ data ) ) { $ returnValue = $ data -> $ key ; } else if ( $ key && is_array ( $ data ) ) { $ returnValue = $ data [ $ key ] ; } return $ returnValue ; }
1858	public function rename ( $ strOldName , $ strNewName ) { if ( $ strOldName == $ strNewName ) { return true ; } $ this -> validate ( $ strOldName , $ strNewName ) ; if ( \ defined ( 'PHP_WINDOWS_VERSION_BUILD' ) && file_exists ( $ this -> strRootDir . '/' . $ strNewName ) && strcasecmp ( $ strOldName , $ strNewName ) !== 0 ) { $ this -> delete ( $ strNewName ) ; } if ( strcasecmp ( $ strOldName , $ strNewName ) === 0 && strcmp ( $ strOldName , $ strNewName ) !== 0 ) { rename ( $ this -> strRootDir . '/' . $ strOldName , $ this -> strRootDir . '/' . $ strOldName . '__' ) ; $ strOldName .= '__' ; } return rename ( $ this -> strRootDir . '/' . $ strOldName , $ this -> strRootDir . '/' . $ strNewName ) ; }
4555	protected function addJoinTranslation ( QueryBuilder $ queryBuilder , string $ resourceClass ) { $ rootAlias = $ queryBuilder -> getRootAliases ( ) [ 0 ] ; $ translationAlias = $ rootAlias . '_t' ; $ translationClass = call_user_func ( $ resourceClass . '::getTranslationEntityClass' ) ; $ parts = $ queryBuilder -> getDQLParts ( ) [ 'join' ] ; foreach ( $ parts as $ joins ) { foreach ( $ joins as $ join ) { if ( $ translationAlias === $ join -> getAlias ( ) ) { return $ translationAlias ; } } } $ queryBuilder -> leftJoin ( $ translationClass , $ translationAlias , Join :: WITH , $ rootAlias . '.id = ' . $ translationAlias . '.translatable' ) ; return $ translationAlias ; }
7531	function toString ( $ attributes = true , $ recursive = true , $ content_only = false ) { if ( $ content_only ) { if ( is_int ( $ content_only ) ) { -- $ content_only ; } return $ this -> toString_content ( $ attributes , $ recursive , $ content_only ) ; } $ s = '<' . $ this -> tag ; if ( $ attributes ) { $ s .= $ this -> toString_attributes ( ) ; } if ( $ this -> self_close ) { $ s .= $ this -> self_close_str . '>' ; } else { $ s .= '>' ; if ( $ recursive ) { $ s .= $ this -> toString_content ( $ attributes ) ; } $ s .= '</' . $ this -> tag . '>' ; } return $ s ; }
10910	public function decorate ( callable $ decorator ) : Binding { if ( empty ( $ this -> definition -> decorators ) ) { $ this -> definition -> decorators = [ ] ; } $ this -> definition -> decorators [ ] = new Decorator ( $ decorator ) ; return $ this ; }
9805	private function readDefault ( ) { $ verInstance = Xls :: getUInt2d ( $ this -> data , $ this -> pos ) ; $ fbt = Xls :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recVer = ( 0x000F & $ verInstance ) >> 0 ; $ length = Xls :: getInt4d ( $ this -> data , $ this -> pos + 4 ) ; $ recordData = substr ( $ this -> data , $ this -> pos + 8 , $ length ) ; $ this -> pos += 8 + $ length ; }
11522	public function get ( $ name ) { return isset ( $ this -> _items [ $ name ] ) ? $ this -> _items [ $ name ] : null ; }
580	public static function current ( array $ params = [ ] , $ scheme = false ) { $ currentParams = Yii :: $ app -> getRequest ( ) -> getQueryParams ( ) ; $ currentParams [ 0 ] = '/' . Yii :: $ app -> controller -> getRoute ( ) ; $ route = array_replace_recursive ( $ currentParams , $ params ) ; return static :: toRoute ( $ route , $ scheme ) ; }
4665	public function createMessage ( ) { $ eventsManager = $ this -> getEventsManager ( ) ; if ( $ eventsManager ) { $ eventsManager -> fire ( 'mailer:beforeCreateMessage' , $ this ) ; } $ message = $ this -> getDI ( ) -> get ( '\Baka\Mail\Message' , [ $ this ] ) ; if ( ( $ from = $ this -> getConfig ( 'from' ) ) ) { $ message -> from ( $ from [ 'email' ] , isset ( $ from [ 'name' ] ) ? $ from [ 'name' ] : null ) ; } if ( $ eventsManager ) { $ eventsManager -> fire ( 'mailer:afterCreateMessage' , $ this , $ message ) ; } return $ message ; }
3831	protected function prepareFrontendFilterWidget ( $ arrWidget , $ arrFilterUrl , $ arrJumpTo , FrontendFilterOptions $ objFrontendFilterOptions ) { $ strClass = $ GLOBALS [ 'TL_FFL' ] [ $ arrWidget [ 'inputType' ] ] ; if ( ! $ strClass ) { return array ( ) ; } $ arrWidget [ 'value' ] = isset ( $ arrFilterUrl [ $ arrWidget [ 'eval' ] [ 'urlparam' ] ] ) ? $ arrFilterUrl [ $ arrWidget [ 'eval' ] [ 'urlparam' ] ] : null ; $ event = new GetAttributesFromDcaEvent ( $ arrWidget , $ arrWidget [ 'eval' ] [ 'urlparam' ] ) ; $ this -> eventDispatcher -> dispatch ( ContaoEvents :: WIDGET_GET_ATTRIBUTES_FROM_DCA , $ event ) ; if ( $ objFrontendFilterOptions -> isAutoSubmit ( ) && TL_MODE == 'FE' ) { $ GLOBALS [ 'TL_JAVASCRIPT' ] [ 'metamodels' ] = 'bundles/metamodelscore/js/metamodels.js' ; } $ objWidget = new $ strClass ( $ event -> getResult ( ) ) ; $ this -> validateWidget ( $ objWidget , $ arrWidget [ 'value' ] ) ; $ strField = $ objWidget -> generateWithError ( ) ; return array ( 'class' => sprintf ( 'mm_%s %s%s%s' , $ arrWidget [ 'inputType' ] , $ arrWidget [ 'eval' ] [ 'urlparam' ] , ( ( $ arrWidget [ 'value' ] !== null ) ? ' used' : ' unused' ) , ( $ objFrontendFilterOptions -> isAutoSubmit ( ) ? ' submitonchange' : '' ) ) , 'label' => $ objWidget -> generateLabel ( ) , 'formfield' => $ strField , 'raw' => $ arrWidget , 'urlparam' => $ arrWidget [ 'eval' ] [ 'urlparam' ] , 'options' => $ this -> prepareFrontendFilterOptions ( $ arrWidget , $ arrFilterUrl , $ arrJumpTo , $ objFrontendFilterOptions -> isAutoSubmit ( ) ) , 'count' => isset ( $ arrWidget [ 'count' ] ) ? $ arrWidget [ 'count' ] : null , 'showCount' => $ objFrontendFilterOptions -> isShowCountValues ( ) , 'autosubmit' => $ objFrontendFilterOptions -> isAutoSubmit ( ) , 'urlvalue' => array_key_exists ( 'urlvalue' , $ arrWidget ) ? $ arrWidget [ 'urlvalue' ] : $ arrWidget [ 'value' ] , 'errors' => $ objWidget -> hasErrors ( ) ? $ objWidget -> getErrors ( ) : array ( ) ) ; }
1495	public static function createCustom ( ... $ mediaTypes ) : self { $ encodings = new self ( ) ; $ encodings -> stack = collect ( $ mediaTypes ) -> map ( function ( $ mediaType ) { return Encoding :: custom ( $ mediaType ) ; } ) -> all ( ) ; return $ encodings ; }
2755	public function onImport ( ImportEvent $ event ) { $ uuids = [ '0bd5c257-2231-450f-b4c2-ab156af7b78d' , '36b2e2b2-3df0-43eb-a282-d792b0999c07' , '94ad928b-3ec8-4bcb-b617-ab1607bf69cb' , 'bbb1ee17-15f8-46bd-9df5-21c58040d741' , ] ; foreach ( $ event -> getImportedEntities ( ) as $ entity ) { if ( in_array ( $ entity -> uuid ( ) , $ uuids ) ) { $ entity -> moderation_state -> value = 'published' ; $ entity -> save ( ) ; } } }
312	public function run ( ) { try { $ this -> state = self :: STATE_BEFORE_REQUEST ; $ this -> trigger ( self :: EVENT_BEFORE_REQUEST ) ; $ this -> state = self :: STATE_HANDLING_REQUEST ; $ response = $ this -> handleRequest ( $ this -> getRequest ( ) ) ; $ this -> state = self :: STATE_AFTER_REQUEST ; $ this -> trigger ( self :: EVENT_AFTER_REQUEST ) ; $ this -> state = self :: STATE_SENDING_RESPONSE ; $ response -> send ( ) ; $ this -> state = self :: STATE_END ; return $ response -> exitStatus ; } catch ( ExitException $ e ) { $ this -> end ( $ e -> statusCode , isset ( $ response ) ? $ response : null ) ; return $ e -> statusCode ; } }
3993	public function encodeValue ( EncodePropertyValueFromWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ metaModel = $ this -> getMetaModelFromModel ( $ event -> getModel ( ) ) ; $ values = Helper :: encodeLangArray ( $ event -> getValue ( ) , $ metaModel ) ; $ event -> setValue ( $ values ) ; }
1882	protected function getMD5Folders ( $ strPath ) { $ arrFiles = array ( ) ; foreach ( scan ( $ this -> strRootDir . '/' . $ strPath ) as $ strFile ) { if ( ! is_dir ( $ this -> strRootDir . '/' . $ strPath . '/' . $ strFile ) ) { continue ; } $ arrFiles [ substr ( md5 ( $ this -> strRootDir . '/' . $ strPath . '/' . $ strFile ) , 0 , 8 ) ] = 1 ; foreach ( $ this -> getMD5Folders ( $ strPath . '/' . $ strFile ) as $ k => $ v ) { $ arrFiles [ $ k ] = $ v ; } } return $ arrFiles ; }
7627	public function createContainerIfNotExists ( $ containerName = '' , $ metadata = array ( ) ) { if ( ! $ this -> containerExists ( $ containerName ) ) { $ this -> createContainer ( $ containerName , $ metadata ) ; } }
4457	public function detach ( string $ eventName , $ handler ) : void { if ( is_object ( $ handler ) == false && is_callable ( $ handler ) == false ) { throw new InvalidArgumentException ( sprintf ( 'Event handler must be either an object or a callable %s given.' , gettype ( $ handler ) ) ) ; } if ( isset ( $ this -> events [ $ eventName ] ) == false ) { return ; } $ priorityQueue = $ this -> events [ $ eventName ] ; $ priorityQueue -> setExtractFlags ( SplPriorityQueue :: EXTR_BOTH ) ; $ priorityQueue -> top ( ) ; $ newPriorityQueue = $ this -> createQueue ( ) ; while ( $ priorityQueue -> valid ( ) ) { $ data = $ priorityQueue -> current ( ) ; $ priorityQueue -> next ( ) ; if ( $ data [ 'data' ] !== $ handler ) { $ newPriorityQueue -> insert ( $ data [ 'data' ] , $ data [ 'priority' ] ) ; } } $ this -> events [ $ eventName ] = $ newPriorityQueue ; }
1104	protected function quoteIdentifier ( $ value ) { if ( is_null ( $ value ) ) return 'NULL' ; $ connection = $ this -> node -> getConnection ( ) ; $ pdo = $ connection -> getPdo ( ) ; return $ pdo -> quote ( $ value ) ; }
11897	public function getStatusLog ( $ checkRecent = false ) { if ( ! isset ( $ this -> _statusLog ) ) { $ this -> _statusLog = Cacher :: get ( [ get_called_class ( ) , $ this -> primaryKey , $ this -> created ] ) ; if ( empty ( $ this -> _statusLog ) ) { if ( is_null ( $ this -> message ) ) { $ this -> _statusLog = $ this -> _startStatus ( ) ; } else { $ this -> _statusLog = unserialize ( $ this -> message ) ; } } elseif ( $ checkRecent ) { $ testStatusLog = unserialize ( $ this -> message ) ; if ( $ testStatusLog && $ testStatusLog -> lastUpdate > $ this -> _statusLog -> lastUpdate ) { $ this -> _statusLog = $ testStatusLog ; } } if ( empty ( $ this -> _statusLog ) ) { $ this -> _statusLog = new Status ( ) ; } } $ this -> _statusLog -> log = $ this ; return $ this -> _statusLog ; }
8230	public static function writeFile ( $ fileName , $ data , $ options = [ ] ) { $ writer = new File \ FileWriter ( $ fileName , $ options ) ; $ isSuccess = true ; $ written = 0 ; try { $ writer -> open ( ) ; $ written = $ writer -> write ( $ data ) ; } catch ( \ RuntimeException $ e ) { self :: $ lastError = $ e -> getMessage ( ) ; $ isSuccess = false ; } try { $ writer -> close ( ) ; } catch ( \ RuntimeException $ e ) { self :: $ lastError = $ e -> getMessage ( ) ; $ isSuccess = false ; } return $ isSuccess ; }
6846	public static function hours ( $ step = 1 , $ long = false , $ start = null ) { if ( ! $ start ) { $ start = $ long ? 0 : 1 ; } $ size = $ long ? 23 : 12 ; $ step = ( int ) $ step ; $ hours = array ( ) ; for ( $ i = $ start ; $ i <= $ size ; $ i += $ step ) { $ hours [ $ i ] = ( string ) $ i ; } return $ hours ; }
11315	public static function getNormalizedParameters ( array $ data ) { $ params = array ( ) ; $ keys = array_map ( 'PSX\Oauth\Consumer::urlEncode' , array_keys ( $ data ) ) ; $ values = array_map ( 'PSX\Oauth\Consumer::urlEncode' , array_values ( $ data ) ) ; $ data = array_combine ( $ keys , $ values ) ; uksort ( $ data , 'strnatcmp' ) ; foreach ( $ data as $ k => $ v ) { if ( $ k != 'oauth_signature' ) { $ params [ ] = $ k . '=' . $ v ; } } return implode ( '&' , $ params ) ; }
11835	public function save ( IUser $ user ) : bool { if ( ! $ user instanceof Entity ) { return false ; } return entityManager ( ) -> save ( $ user ) ; }
11798	public function setHtml ( $ html = '' , $ clear = false ) { if ( true === $ clear ) { $ this -> clear ( 'text' ) ; } $ this -> html .= Helper :: formatText ( $ html , 'ascii' ) ; return $ this ; }
6518	public static function fromDateTime ( \ DateTimeInterface $ date ) { $ str = $ date -> format ( 'U' ) . str_pad ( $ date -> format ( 'u' ) , 6 , '0' ) ; $ m = new self ( ) ; $ m -> int = ( int ) $ str ; $ m -> sec = ( int ) substr ( $ str , 0 , 10 ) ; $ m -> usec = ( int ) substr ( $ str , - 6 ) ; return $ m ; }
7105	public function onParse ( $ finalText ) { $ func = $ this -> getParam ( 'postParseFunction' ) ; if ( isset ( $ func ) ) $ finalText = $ func ( $ finalText ) ; if ( $ this -> getParam ( 'addFootnotes' ) ) { $ footnotes = $ this -> getFootnotes ( ) ; if ( ! empty ( $ footnotes ) ) $ finalText .= "\n" . $ footnotes ; } $ finalText .= str_repeat ( '</section>' , count ( $ this -> _sectionLevel ) ) ; return ( $ finalText ) ; }
6552	public function lock ( ) { if ( $ this -> pid === $ this -> getSerial ( ) ) { return ; } $ this -> pid = $ this -> getSerial ( ) ; $ this -> fh = fopen ( $ filename = $ this -> getPidFilename ( ) , 'a+' ) ; if ( ! flock ( $ this -> fh , LOCK_EX | LOCK_NB ) ) { throw new ImportAlreadyRunningException ( sprintf ( 'PID file %s is already in use' , $ filename ) ) ; } if ( fwrite ( $ this -> fh , $ this -> pid . PHP_EOL ) === false ) { throw new \ Exception ( sprintf ( 'Can\'t write PID %s to PID file %s' , $ this -> pid , $ filename ) ) ; } }
7064	protected function supports ( PaymentInterface $ payment ) { if ( null === $ method = $ payment -> getMethod ( ) ) { throw new RuntimeException ( "Payment method must be set." ) ; } if ( $ method -> isCredit ( ) || $ method -> isOutstanding ( ) ) { return true ; } return false ; }
3165	public function switchClientStoreId ( RunnerServiceContext $ context , $ receivedStoreId ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ session = $ context -> getTestSession ( ) ; $ sessionId = $ session -> getSessionId ( ) ; $ stateService = $ this -> getServiceManager ( ) -> get ( ExtendedStateService :: SERVICE_ID ) ; $ lastStoreId = $ stateService -> getStoreId ( $ sessionId ) ; if ( $ lastStoreId == false || $ lastStoreId != $ receivedStoreId ) { $ stateService -> setStoreId ( $ sessionId , $ receivedStoreId ) ; } return $ lastStoreId ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'switchClientStoreId' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } }
4098	public function config ( $ key , $ value = null ) { if ( is_array ( $ key ) ) $ this -> config = $ key + $ this -> config ; else { if ( $ value !== null ) $ this -> config [ $ key ] = $ value ; if ( ! isset ( $ this -> config [ $ key ] ) ) throw new \ Exception ( "Configuration key `type` is not set" ) ; return $ this -> config [ $ key ] ; } }
8949	function constructUrl ( Request $ appRequest , Nette \ Http \ Url $ refUrl ) { return $ this -> getRouter ( ) -> constructUrl ( $ appRequest , $ refUrl ) ; }
2422	public static function deleteResource ( $ strResource ) { $ objModel = FilesModel :: findByPath ( $ strResource ) ; if ( $ objModel !== null ) { $ objModel -> delete ( ) ; } $ objFiles = FilesModel :: findMultipleByBasepath ( $ strResource . '/' ) ; if ( $ objFiles !== null ) { while ( $ objFiles -> next ( ) ) { $ objFiles -> delete ( ) ; } } static :: updateFolderHashes ( \ dirname ( $ strResource ) ) ; return null ; }
554	private function notifyCachesCanBeFlushed ( $ caches ) { $ this -> stdout ( "The following caches were found in the system:\n\n" , Console :: FG_YELLOW ) ; foreach ( $ caches as $ name => $ class ) { if ( $ this -> canBeFlushed ( $ class ) ) { $ this -> stdout ( "\t* $name ($class)\n" , Console :: FG_GREEN ) ; } else { $ this -> stdout ( "\t* $name ($class) - can not be flushed via console\n" , Console :: FG_YELLOW ) ; } } $ this -> stdout ( "\n" ) ; }
12412	public function getDetails ( $ groupId , $ begin , $ count ) { $ params = [ 'group_id' => intval ( $ groupId ) , 'begin' => intval ( $ begin ) , 'count' => intval ( $ count ) , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_GET_DETAIL , $ params ] ) ; }
10083	protected function registerRouter ( ) { $ this -> app -> singleton ( 'auja.router' , function ( $ app ) { $ config = $ app [ 'config' ] [ 'auja-laravel' ] ? : $ app [ 'config' ] [ 'auja-laravel::config' ] ; return new AujaRouter ( $ app [ 'auja' ] , $ app [ 'router' ] , $ config [ 'route' ] ) ; } ) ; $ this -> app -> bind ( 'Label305\AujaLaravel\Routing\AujaRouter' , 'auja.router' ) ; }
10419	public static function parse ( $ path ) { if ( ! file_exists ( $ path ) ) { throw new Exception ( 'The give file ' . $ path . ' doesn\'t exist.' ) ; } return Yaml :: parse ( file_get_contents ( $ path ) ) ; }
4629	protected function prepareRequestParameters ( ) { if ( $ this -> command -> hasParameters ( ) ) { $ this -> query = http_build_query ( $ this -> command -> getParameters ( ) , '' , '&' , PHP_QUERY_RFC3986 ) ; } return $ this ; }
6116	public function serverGetByName ( $ name ) { foreach ( $ this -> serverList ( ) as $ server ) { if ( $ server [ "virtualserver_name" ] == $ name ) { return $ server ; } } throw new Ts3Exception ( "invalid serverID" , 0x400 ) ; }
10660	public function withHeaders ( array $ headers ) { $ object = clone $ this ; $ object -> configs [ 'headers' ] = [ ] ; $ object -> inProcessingLoop = true ; $ object -> replaceHeaders ( $ headers ) ; $ object -> inProcessingLoop = true ; return $ object -> buildConfigClient ( ) ; }
11006	public function setRefererPolicy ( string $ refererPolicy ) : void { if ( ! in_array ( $ refererPolicy , self :: REFERER_POLICY_VALUES ) ) { throw new MiddlewareException ( $ this , sprintf ( "%s is not a valid CSP referer policy, correct values are: %s (see %s)" , $ refererPolicy , implode ( ', ' , self :: REFERER_POLICY_VALUES ) , 'https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Security-Policy/referrer' ) ) ; } $ this -> tags [ 'referer' ] = $ refererPolicy ; }
853	public function getNonEmptySibling ( $ index , $ direction ) { while ( true ) { $ index += $ direction ; if ( ! $ this -> offsetExists ( $ index ) ) { return null ; } if ( ! $ this -> isEmptyAt ( $ index ) ) { return $ index ; } } }
12704	public function getTitleAttribute ( $ value ) { if ( $ value === null ) { $ value = '' ; } if ( getenv ( "BYPASS_HOOKS" ) != true ) { global $ hooks , $ codes ; return $ hooks -> apply_filters ( "TCT-Core-Main-Model-Page-Title" , $ codes -> do_shortcode ( $ value ) ) ; } else { return $ value ; } }
8382	public function fetch ( ) { if ( $ this -> statement == null || $ this -> getErrorState ( ) != '00000' ) { return false ; } return $ this -> statement -> fetch ( \ PDO :: FETCH_ASSOC ) ; }
8345	public static function prefix ( string $ namespace , $ subdomain = null , string $ uri = null ) { self :: $ namespace = $ namespace ; self :: $ subdomain = is_array ( $ subdomain ) ? $ subdomain : [ $ subdomain ] ; self :: $ uri = $ uri ; }
8448	public function broadcastMsg ( array $ peers , $ msg ) { $ peerList = $ this -> formatPeers ( $ peers ) ; return $ this -> exec ( 'broadcast ' . $ peerList . ' ' . $ msg ) ; }
499	protected function writeInteger ( $ fileHandle , $ integer ) { return $ this -> writeBytes ( $ fileHandle , pack ( $ this -> useBigEndian ? 'N' : 'V' , ( int ) $ integer ) ) ; }
9685	public function setStorage ( $ storage , $ options = null ) { if ( ! $ storage instanceof Storage \ StorageInterface ) { $ storage = $ this -> getStoragePluginManager ( ) -> get ( $ storage , $ options ) ; } $ this -> storage = $ storage ; return $ this ; }
2395	public function close ( ) { $ arrArchive [ 'archive_signature' ] = self :: CENTRAL_DIR_END ; $ arrArchive [ 'number_of_this_disk' ] = "\x00\x00" ; $ arrArchive [ 'number_of_disk_with_cd' ] = "\x00\x00" ; $ arrArchive [ 'total_cd_entries_disk' ] = pack ( 'v' , $ this -> intCount ) ; $ arrArchive [ 'total_cd_entries' ] = pack ( 'v' , $ this -> intCount ) ; $ arrArchive [ 'size_of_cd' ] = pack ( 'V' , \ strlen ( $ this -> strCentralDir ) ) ; $ arrArchive [ 'offset_start_cd' ] = pack ( 'V' , @ ftell ( $ this -> resFile ) ) ; $ arrArchive [ 'zipfile_comment_length' ] = "\x00\x00" ; $ arrArchive [ 'zipfile_comment' ] = '' ; fwrite ( $ this -> resFile , $ this -> strCentralDir ) ; fwrite ( $ this -> resFile , implode ( '' , $ arrArchive ) ) ; fclose ( $ this -> resFile ) ; if ( ! file_exists ( $ this -> strRootDir . '/' . $ this -> strFile ) ) { if ( ( $ strFolder = \ dirname ( $ this -> strFile ) ) == '.' ) { $ strFolder = '' ; } if ( ! is_dir ( $ this -> strRootDir . '/' . $ strFolder ) ) { new Folder ( $ strFolder ) ; } } Files :: getInstance ( ) -> rename ( self :: TEMPORARY_FOLDER . '/' . basename ( $ this -> strTemp ) , $ this -> strFile ) ; }
4421	public function generate ( InputInterface $ input , OutputInterface $ output ) { $ fileSystem = $ this -> container -> get ( 'filesystem' ) ; $ legacyRootDir = $ this -> container -> getParameter ( 'ezpublish_legacy.root_dir' ) ; $ siteAccessName = $ input -> getOption ( 'site-access-name' ) ; $ languageCode = $ input -> getOption ( 'language-code' ) ; $ siteAccessLocation = $ legacyRootDir . '/settings/siteaccess/' . $ siteAccessName ; $ skeletonDir = __DIR__ . '/../_templates/legacy_siteaccess' ; if ( $ fileSystem -> exists ( $ siteAccessLocation ) ) { if ( ! $ this -> questionHelper -> ask ( $ input , $ output , new ConfirmationQuestion ( '<info><comment>' . $ siteAccessName . '</comment> legacy siteaccess already exists. Do you want to overwrite it?</info> [<comment>no</comment>] ' , false ) ) ) { return ; } } $ fileSystem -> remove ( $ siteAccessLocation ) ; $ languageService = $ this -> container -> get ( 'ezpublish.api.repository' ) -> getContentLanguageService ( ) ; $ relatedSiteAccessList = $ this -> container -> getParameter ( 'ezpublish.siteaccess.list' ) ; $ relatedSiteAccessList [ ] = $ siteAccessName ; $ availableLocales = array_map ( function ( Language $ language ) { return $ language -> languageCode ; } , $ languageService -> loadLanguages ( ) ) ; $ availableLocales = array_values ( array_diff ( $ availableLocales , array ( $ languageCode ) ) ) ; $ siteLanguageList = array_merge ( array ( $ languageCode ) , $ availableLocales ) ; $ translationList = implode ( ';' , $ availableLocales ) ; $ fileSystem -> mirror ( $ skeletonDir , $ siteAccessLocation ) ; $ this -> setSkeletonDirs ( $ siteAccessLocation ) ; $ this -> renderFile ( 'site.ini.append.php' , $ siteAccessLocation . '/site.ini.append.php' , array ( 'relatedSiteAccessList' => $ relatedSiteAccessList , 'siteAccessLocale' => $ languageCode , 'siteLanguageList' => $ siteLanguageList , 'translationList' => $ translationList , ) ) ; $ output -> writeln ( array ( '' , 'Generated <comment>' . $ siteAccessName . '</comment> legacy siteaccess!' , '' , ) ) ; }
7051	private function addViolation ( $ value , Constraint $ constraint ) { if ( $ this -> context instanceof ExecutionContextInterface ) { $ this -> context -> buildViolation ( $ constraint -> getMessage ( ) ) -> setParameter ( '{{ type }}' , $ constraint -> getType ( ) ) -> setParameter ( '{{ value }}' , $ this -> formatValue ( $ value ) ) -> setCode ( PhoneNumber :: INVALID_PHONE_NUMBER_ERROR ) -> addViolation ( ) ; } else { $ this -> context -> addViolation ( $ constraint -> getMessage ( ) , array ( '{{ type }}' => $ constraint -> getType ( ) , '{{ value }}' => $ value ) ) ; } }
9140	public static function parseFromServerRequest ( $ serverVars , $ defaultController = 'Index' , $ defaultAction = 'index' ) { if ( ! isset ( $ serverVars [ 'REQUEST_URI' ] ) ) { throw new InvalidUrlException ( "No such uri provided" ) ; } return self :: parse ( $ serverVars [ 'REQUEST_URI' ] , $ serverVars , $ defaultController , $ defaultAction ) ; }
12508	public function msgType ( $ msgType ) { if ( ! in_array ( $ msgType , $ this -> msgTypes , true ) ) { throw new InvalidArgumentException ( 'This message type not exist.' ) ; } $ this -> msgType = $ msgType ; return $ this ; }
4503	public function replaceWith ( DOMNode $ replacement ) : void { $ this -> parentNode -> insertBefore ( $ replacement , $ this ) ; $ this -> remove ( ) ; }
5848	public function populateMetadata ( \ TYPO3 \ CMS \ Core \ Resource \ FileInterface $ file , \ TYPO3 \ CMS \ Core \ Resource \ Folder $ folder ) { if ( is_array ( static :: $ metadata ) && count ( static :: $ metadata ) ) { \ Causal \ ImageAutoresize \ Utility \ FAL :: indexFile ( $ file , '' , '' , static :: $ metadata [ 'COMPUTED' ] [ 'Width' ] , static :: $ metadata [ 'COMPUTED' ] [ 'Height' ] , static :: $ metadata ) ; } }
4593	public static function replace ( string $ string , array $ data = [ ] ) : string { $ expressionLanguage = new ExpressionLanguage ; preg_match_all ( '/\%([a-z0-9_\[\]\"\.]+)\%/i' , $ string , $ matches ) ; $ placeholders = array_unique ( $ matches [ 1 ] ) ; $ translations = [ ] ; foreach ( $ placeholders as $ placeholder ) { $ translations [ '%' . $ placeholder . '%' ] = $ expressionLanguage -> evaluate ( $ placeholder , $ data ) ; } $ string = strtr ( $ string , $ translations ) ; return $ string ; }
8540	public function setmember ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'member' ] [ 'FieldValue' ] = $ value ; return $ this ; }
7903	protected function dynamicUploadTo ( $ uploadTo ) { $ disk = Str :: snake ( substr ( $ uploadTo , 8 ) ) ; return $ this -> uploadTo ( $ disk ) ; }
1946	public function getCustomSections ( $ strKey = null ) { @ trigger_error ( 'Using FrontendTemplate::getCustomSections() has been deprecated and will no longer work in Contao 5.0. Use FrontendTemplate::sections() instead.' , E_USER_DEPRECATED ) ; if ( $ strKey != '' && ! isset ( $ this -> positions [ $ strKey ] ) ) { return '' ; } $ tag = 'div' ; if ( $ strKey == 'main' ) { $ tag = 'section' ; } $ sections = '' ; foreach ( $ this -> positions [ $ strKey ] as $ sect ) { if ( isset ( $ this -> sections [ $ sect [ 'id' ] ] ) ) { $ sections .= "\n" . '<' . $ tag . ' id="' . StringUtil :: standardize ( $ sect [ 'id' ] , true ) . '">' . "\n" . '<div class="inside">' . "\n" . $ this -> sections [ $ sect [ 'id' ] ] . "\n" . '</div>' . "\n" . '</' . $ tag . '>' . "\n" ; } } if ( $ sections == '' ) { return '' ; } return '<div class="custom">' . "\n" . $ sections . "\n" . '</div>' . "\n" ; }
1697	public function removeFrontendAuthentication ( ) : bool { if ( ! $ this -> session -> isStarted ( ) || ! $ this -> session -> has ( FrontendUser :: SECURITY_SESSION_KEY ) ) { return false ; } $ this -> session -> remove ( FrontendUser :: SECURITY_SESSION_KEY ) ; return true ; }
11204	public function where ( $ key = false , $ desiredValue , $ op = "==" ) { $ collection = $ this -> getIterator ( ) ; $ subset = new Collection ( ) ; foreach ( $ collection as $ prop => $ result ) { $ realValue = $ result ; if ( is_object ( $ result ) ) { $ realValue = $ result -> $ key ; } else if ( is_array ( $ result ) ) { $ realValue = $ result [ $ key ] ; } $ add = false ; if ( $ op == '==' && $ realValue == $ desiredValue ) { $ add = true ; } else if ( $ op == '>=' && $ realValue >= $ desiredValue ) { $ add = true ; } else if ( $ op == '<=' && $ realValue <= $ desiredValue ) { $ add = true ; } else if ( $ op == '>' && $ realValue > $ desiredValue ) { $ add = true ; } else if ( $ op == '<' && $ realValue < $ desiredValue ) { $ add = true ; } else if ( $ op == '===' && $ realValue === $ desiredValue ) { $ add = true ; } else if ( $ op == '!=' && $ realValue != $ desiredValue ) { $ add = true ; } if ( $ add ) { $ subset -> add ( $ result , $ prop ) ; } } return $ subset ; }
1578	public static function create ( array $ data ) : self { if ( ! isset ( $ data [ 'type' ] ) ) { throw new \ InvalidArgumentException ( 'Expecting a resource type.' ) ; } return new self ( $ data [ 'type' ] , $ data [ 'id' ] ?? null , $ data [ 'attributes' ] ?? [ ] , $ data [ 'relationships' ] ?? [ ] , $ data [ 'meta' ] ?? [ ] , $ data [ 'links' ] ?? [ ] ) ; }
523	protected function includeMigrationFile ( $ class ) { $ class = trim ( $ class , '\\' ) ; if ( strpos ( $ class , '\\' ) === false ) { if ( is_array ( $ this -> migrationPath ) ) { foreach ( $ this -> migrationPath as $ path ) { $ file = $ path . DIRECTORY_SEPARATOR . $ class . '.php' ; if ( is_file ( $ file ) ) { require_once $ file ; break ; } } } else { $ file = $ this -> migrationPath . DIRECTORY_SEPARATOR . $ class . '.php' ; require_once $ file ; } } }
127	public function ensureBinariesPresence ( PackageInterface $ package ) { $ this -> binaryInstaller -> installBinaries ( $ package , $ this -> getInstallPath ( $ package ) , false ) ; }
5159	private static function createGallery ( String $ body , int $ order , String $ photo , String $ source , string $ lead ) : \ One \ Model \ Gallery { return new Gallery ( $ body , $ order , $ photo , $ source , $ lead ) ; }
9085	public function getAlias ( string $ abstract ) : string { if ( ! isset ( $ this -> aliases [ $ abstract ] ) ) { return $ abstract ; } if ( $ this -> aliases [ $ abstract ] === $ abstract ) { throw new ContainerException ( "[{$abstract}] is aliased to itself." ) ; } return $ this -> getAlias ( $ this -> aliases [ $ abstract ] ) ; }
5623	protected function parseRequest ( $ raw ) { $ this -> raw = $ raw ; $ request = new SimpleGetEncoding ( ) ; foreach ( explode ( '&' , $ raw ) as $ pair ) { if ( preg_match ( '/(.*?)=(.*)/' , $ pair , $ matches ) ) { $ request -> add ( urldecode ( $ matches [ 1 ] ) , urldecode ( $ matches [ 2 ] ) ) ; } elseif ( $ pair ) { $ request -> add ( urldecode ( $ pair ) , '' ) ; } } return $ request ; }
5172	public function setEncoder ( callable $ encoder ) : Yaml { if ( ! is_callable ( $ encoder ) ) { throw new \ InvalidArgumentException ( 'The provided encoder must be callable.' ) ; } $ this -> encoder = $ encoder ; return $ this ; }
4302	public function groupUncollapse ( ) { if ( ! $ this -> cfg [ 'collect' ] ) { return ; } $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) ) ; $ curDepth = 0 ; foreach ( $ this -> rootInstance -> groupStackRef as $ group ) { $ curDepth += ( int ) $ group [ 'collect' ] ; } $ entryKeys = \ array_keys ( $ this -> internal -> getCurrentGroups ( $ this -> rootInstance -> logRef , $ curDepth ) ) ; foreach ( $ entryKeys as $ key ) { $ this -> rootInstance -> logRef [ $ key ] [ 0 ] = 'group' ; } $ this -> internal -> publishBubbleEvent ( 'debug.log' , $ this , array ( 'method' => __FUNCTION__ , 'args' => array ( ) , 'meta' => $ meta , ) ) ; }
679	protected function validateCondition ( $ condition ) { if ( ! is_array ( $ condition ) ) { $ this -> addError ( $ this -> filterAttributeName , $ this -> parseErrorMessage ( 'invalidFilter' ) ) ; return ; } if ( empty ( $ condition ) ) { return ; } foreach ( $ condition as $ key => $ value ) { $ method = 'validateAttributeCondition' ; if ( isset ( $ this -> filterControls [ $ key ] ) ) { $ controlKey = $ this -> filterControls [ $ key ] ; if ( isset ( $ this -> conditionValidators [ $ controlKey ] ) ) { $ method = $ this -> conditionValidators [ $ controlKey ] ; } } $ this -> $ method ( $ key , $ value ) ; } }
2577	protected function hasPricingOption ( $ optionKey , $ priceOptions ) { $ found = false ; foreach ( $ priceOptions as $ pog ) { if ( $ pog -> pricingOptionKey -> pricingOptionKey === $ optionKey ) { $ found = true ; } } return $ found ; }
6815	protected function buildFile ( array $ orders , string $ name ) { if ( false === $ path = tempnam ( sys_get_temp_dir ( ) , $ name ) ) { throw new RuntimeException ( "Failed to create temporary file." ) ; } if ( false === $ handle = fopen ( $ path , "w" ) ) { throw new RuntimeException ( "Failed to open '$path' for writing." ) ; } if ( ! empty ( $ headers = $ this -> buildHeaders ( ) ) ) { fputcsv ( $ handle , $ headers , ';' , '"' ) ; } $ supplierTotal = 0 ; $ forwarderTotal = 0 ; foreach ( $ orders as $ order ) { if ( ! empty ( $ row = $ this -> buildRow ( $ order ) ) ) { fputcsv ( $ handle , $ row , ';' , '"' ) ; $ supplierTotal += $ row [ 'payment_total' ] ; $ forwarderTotal += $ row [ 'forwarder_total' ] ; } } fputcsv ( $ handle , [ 'id' => '' , 'number' => '' , 'state' => '' , 'ordered_at' => '' , 'completed_at' => '' , 'supplier' => '' , 'payment_total' => $ supplierTotal , 'payment_date' => '' , 'payment_due_date' => '' , 'carrier' => '' , 'forwarder_total' => $ forwarderTotal , 'forwarder_date' => '' , 'forwarder_due_date' => '' , ] , ';' , '"' ) ; fclose ( $ handle ) ; return $ path ; }
4775	private function loadUserConfig ( ) { if ( ! $ this -> widgetConfig ) { $ this -> widgetConfig = $ this -> entityManager -> getRepository ( 'PdWidgetBundle:WidgetUser' ) -> findOneBy ( [ 'owner' => $ this -> tokenStorage -> getToken ( ) -> getUser ( ) , ] ) ; if ( null !== $ this -> widgetConfig ) { $ this -> widgetConfig = $ this -> widgetConfig -> getConfig ( ) ; } } }
12948	public function removeTagValues ( $ tags ) { $ this -> _tagsList = array_diff ( $ this -> getTagValues ( ) , $ this -> parseTags ( $ tags ) ) ; $ this -> updateOwnerTags ( ) ; }
756	protected function renderImage ( $ code ) { if ( isset ( $ this -> imageLibrary ) ) { $ imageLibrary = $ this -> imageLibrary ; } else { $ imageLibrary = Captcha :: checkRequirements ( ) ; } if ( $ imageLibrary === 'gd' ) { return $ this -> renderImageByGD ( $ code ) ; } elseif ( $ imageLibrary === 'imagick' ) { return $ this -> renderImageByImagick ( $ code ) ; } throw new InvalidConfigException ( "Defined library '{$imageLibrary}' is not supported" ) ; }
11214	public function count ( $ coraDbQuery = false ) { if ( ! $ coraDbQuery ) { $ coraDbQuery = $ this -> gateway -> getDb ( ) ; } $ coraDbQuery = $ this -> model :: model_constraints ( $ coraDbQuery ) ; return $ this -> gateway -> count ( $ coraDbQuery ) ; }
481	public function addPrimaryKey ( $ name , $ table , $ columns ) { $ time = $ this -> beginCommand ( "add primary key $name on $table (" . ( is_array ( $ columns ) ? implode ( ',' , $ columns ) : $ columns ) . ')' ) ; $ this -> db -> createCommand ( ) -> addPrimaryKey ( $ name , $ table , $ columns ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
1849	protected function generateLink ( $ strLink , $ objArticle , $ blnAddArchive = false , $ blnIsReadMore = false ) { if ( $ objArticle -> source != 'external' ) { return sprintf ( '<a href="%s" title="%s" itemprop="url"><span itemprop="headline">%s</span>%s</a>' , News :: generateNewsUrl ( $ objArticle , $ blnAddArchive ) , StringUtil :: specialchars ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'readMore' ] , $ objArticle -> headline ) , true ) , $ strLink , ( $ blnIsReadMore ? '<span class="invisible"> ' . $ objArticle -> headline . '</span>' : '' ) ) ; } if ( substr ( $ objArticle -> url , 0 , 7 ) == 'mailto:' ) { $ strArticleUrl = StringUtil :: encodeEmail ( $ objArticle -> url ) ; } else { $ strArticleUrl = ampersand ( $ objArticle -> url ) ; } return sprintf ( '<a href="%s" title="%s"%s itemprop="url"><span itemprop="headline">%s</span></a>' , $ strArticleUrl , StringUtil :: specialchars ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'open' ] , $ strArticleUrl ) ) , ( $ objArticle -> target ? ' target="_blank"' : '' ) , $ strLink ) ; }
7945	public function ipDeleteMonitoringNotification ( $ id , $ ip , $ notificationId ) { if ( ! $ id ) throw new BadMethodCallException ( 'Missing parameter $id.' ) ; if ( ! $ ip ) throw new BadMethodCallException ( 'Missing parameter $ip.' ) ; if ( ! $ notificationId ) throw new BadMethodCallException ( 'Missing parameter $notificationId.' ) ; try { $ r = $ this -> delete ( 'xdsl/' . $ id . '/ips/' . $ ip . '/monitoringNotifications/' . $ notificationId ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new XdslException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return ; }
4203	private function addProperties ( Event $ abs ) { if ( $ abs [ 'debugMethod' ] === 'table' && $ abs [ 'traverseValues' ] ) { return ; } $ obj = $ abs -> getSubject ( ) ; $ reflectionObject = $ abs [ 'reflector' ] ; while ( $ reflectionObject ) { $ className = $ reflectionObject -> getName ( ) ; $ properties = $ reflectionObject -> getProperties ( ) ; $ isDebugObj = $ className == __NAMESPACE__ ; while ( $ properties ) { $ reflectionProperty = \ array_shift ( $ properties ) ; $ name = $ reflectionProperty -> getName ( ) ; if ( isset ( $ abs [ 'properties' ] [ $ name ] ) ) { $ abs [ 'properties' ] [ $ name ] [ 'overrides' ] = $ this -> propOverrides ( $ reflectionProperty , $ abs [ 'properties' ] [ $ name ] , $ className ) ; $ abs [ 'properties' ] [ $ name ] [ 'originallyDeclared' ] = $ className ; continue ; } if ( $ isDebugObj && $ name == 'data' ) { $ abs [ 'properties' ] [ 'data' ] = \ array_merge ( self :: $ basePropInfo , array ( 'value' => array ( 'NOT INSPECTED' ) , 'visibility' => 'protected' , ) ) ; continue ; } $ abs [ 'properties' ] [ $ name ] = $ this -> getPropInfo ( $ abs , $ reflectionProperty ) ; } $ reflectionObject = $ reflectionObject -> getParentClass ( ) ; } $ this -> addPropertiesPhpDoc ( $ abs ) ; $ this -> addPropertiesDebug ( $ abs ) ; $ properties = $ abs [ 'properties' ] ; $ abs [ 'hist' ] [ ] = $ obj ; foreach ( $ properties as $ name => $ info ) { if ( $ this -> abstracter -> needsAbstraction ( $ info [ 'value' ] ) ) { $ properties [ $ name ] [ 'value' ] = $ this -> abstracter -> getAbstraction ( $ info [ 'value' ] , $ abs [ 'debugMethod' ] , $ abs [ 'hist' ] ) ; } } $ abs [ 'properties' ] = $ properties ; return ; }
7878	protected function registerLogFilesystem ( ) { $ this -> app -> singleton ( 'logviewer.filesystem' , function ( $ app ) { $ files = $ app [ 'files' ] ; $ path = $ app [ 'path.storage' ] . '/logs' ; return new Filesystem ( $ files , $ path ) ; } ) ; $ this -> app -> alias ( 'logviewer.filesystem' , Filesystem :: class ) ; }
12478	public function connect ( ) { $ this -> loadConnectors ( ) ; $ connector = new \ elFinderConnector ( new \ elFinder ( $ this -> options ) ) ; $ connector -> run ( ) ; }
331	public function mset ( $ items , $ duration = 0 , $ dependency = null ) { return $ this -> multiSet ( $ items , $ duration , $ dependency ) ; }
861	public function isMonolithicPhp ( ) { $ size = $ this -> count ( ) ; if ( 0 === $ size ) { return false ; } if ( self :: isLegacyMode ( ) ) { if ( $ this [ 0 ] -> isGivenKind ( T_INLINE_HTML ) || $ this [ $ size - 1 ] -> isGivenKind ( T_INLINE_HTML ) ) { return false ; } for ( $ index = 1 ; $ index < $ size ; ++ $ index ) { if ( $ this [ $ index ] -> isGivenKind ( [ T_INLINE_HTML , T_OPEN_TAG , T_OPEN_TAG_WITH_ECHO ] ) ) { return false ; } } return true ; } if ( $ this -> isTokenKindFound ( T_INLINE_HTML ) ) { return false ; } return 1 >= ( $ this -> countTokenKind ( T_OPEN_TAG ) + $ this -> countTokenKind ( T_OPEN_TAG_WITH_ECHO ) ) ; }
11165	protected function getDurationFormat ( array $ config ) { if ( isset ( $ config [ 'durationFormat' ] ) ) { if ( ! is_string ( $ config [ 'durationFormat' ] ) ) { throw new \ DomainException ( 'durationFormat must reference a string' , self :: ERR_INVALID_DURATIONFORMAT ) ; } return $ config [ 'durationFormat' ] ; } return '%im%ss' ; }
6285	public static function unsignedShiftRight ( $ a , $ b ) { if ( $ b == 0 ) { return $ a ; } if ( $ a & 0x80000000 ) { return ( ( $ a & 0x7fffffff ) >> $ b ) | ( 0x40000000 >> ( $ b - 1 ) ) ; } else { return $ a >> $ b ; } }
897	private function fixTokensCompare ( Tokens $ tokens , $ startLeft , $ endLeft , $ compareOperatorIndex , $ startRight , $ endRight ) { $ type = $ tokens [ $ compareOperatorIndex ] -> getId ( ) ; $ content = $ tokens [ $ compareOperatorIndex ] -> getContent ( ) ; if ( \ array_key_exists ( $ type , $ this -> candidatesMap ) ) { $ tokens [ $ compareOperatorIndex ] = clone $ this -> candidatesMap [ $ type ] ; } elseif ( \ array_key_exists ( $ content , $ this -> candidatesMap ) ) { $ tokens [ $ compareOperatorIndex ] = clone $ this -> candidatesMap [ $ content ] ; } $ right = $ this -> fixTokensComparePart ( $ tokens , $ startRight , $ endRight ) ; $ left = $ this -> fixTokensComparePart ( $ tokens , $ startLeft , $ endLeft ) ; for ( $ i = $ startRight ; $ i <= $ endRight ; ++ $ i ) { $ tokens -> clearAt ( $ i ) ; } for ( $ i = $ startLeft ; $ i <= $ endLeft ; ++ $ i ) { $ tokens -> clearAt ( $ i ) ; } $ tokens -> insertAt ( $ startRight , $ left ) ; $ tokens -> insertAt ( $ startLeft , $ right ) ; return $ startLeft ; }
413	public function setPort ( $ value ) { if ( $ value != $ this -> _port ) { $ this -> _port = ( int ) $ value ; $ this -> _hostInfo = null ; } }
11415	private function calcBonus ( $ dwnlCurrent , $ dwnlCompress , $ levels ) { $ result = [ ] ; $ mapCustomer = $ this -> hlpDwnlTree -> mapById ( $ dwnlCurrent , ECustomer :: A_CUSTOMER_REF ) ; foreach ( $ dwnlCompress as $ one ) { $ custId = $ one -> getCustomerRef ( ) ; $ pvValue = $ one -> getPv ( ) ; $ customer = $ mapCustomer [ $ custId ] ; $ scheme = $ this -> hlpScheme -> getSchemeByCustomer ( $ customer ) ; if ( $ scheme == Cfg :: SCHEMA_DEFAULT ) { $ bonusValue = $ this -> hlpCalc -> calcForLevelPercent ( $ pvValue , $ levels ) ; if ( $ bonusValue > 0 ) { $ entry = new DBonus ( ) ; $ entry -> setCustomerRef ( $ custId ) ; $ entry -> setValue ( $ bonusValue ) ; $ result [ ] = $ entry ; } } } return $ result ; }
12927	public function lists ( $ offset = 0 , $ limit = 10 ) { $ params = [ 'begin' => $ offset , 'limit' => $ limit , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_LIST , $ params ] ) ; }
6931	private function feedShipmentInvoice ( Invoice \ InvoiceInterface $ invoice ) { $ changed = false ; $ shipment = $ invoice -> getShipment ( ) ; $ calculator = $ this -> invoiceBuilder -> getInvoiceCalculator ( ) ; foreach ( $ shipment -> getItems ( ) as $ shipmentItem ) { $ saleItem = $ shipmentItem -> getSaleItem ( ) ; $ max = $ shipment -> isReturn ( ) ? $ calculator -> calculateCreditableQuantity ( $ saleItem ) : $ calculator -> calculateInvoiceableQuantity ( $ saleItem ) ; if ( 0 < $ quantity = min ( $ max , $ shipmentItem -> getQuantity ( ) ) ) { $ line = $ this -> invoiceBuilder -> findOrCreateGoodLine ( $ invoice , $ saleItem , $ max ) ; if ( $ line -> getQuantity ( ) !== $ quantity ) { $ line -> setQuantity ( $ quantity ) ; $ changed = true ; } } } if ( $ invoice -> hasLineByType ( Document \ DocumentLineTypes :: TYPE_GOOD ) ) { $ sale = $ invoice -> getSale ( ) ; foreach ( $ sale -> getAdjustments ( Common \ AdjustmentTypes :: TYPE_DISCOUNT ) as $ saleAdjustment ) { foreach ( $ invoice -> getLinesByType ( Document \ DocumentLineTypes :: TYPE_DISCOUNT ) as $ line ) { if ( $ saleAdjustment === $ line -> getSaleAdjustment ( ) ) { continue 2 ; } } $ this -> invoiceBuilder -> buildDiscountLine ( $ saleAdjustment , $ invoice ) ; $ changed = true ; } if ( null !== $ sale -> getShipmentMethod ( ) && ! $ this -> isShipmentAmountInvoiced ( $ invoice ) ) { $ this -> invoiceBuilder -> buildShipmentLine ( $ invoice ) ; } } return $ changed ; }
5963	public function serverGroupGetProfiles ( ) { $ profiles = array ( ) ; foreach ( $ this -> serverGroupList ( ) as $ sgid => $ sgroup ) { if ( $ sgroup [ "type" ] != TeamSpeak3 :: GROUP_DBTYPE_REGULAR ) { continue ; } $ profiles [ $ sgid ] = array ( "b_permission_modify_power_ignore" => 0 , "i_group_needed_member_add_power" => 0 , "i_group_member_add_power" => 0 , "i_group_needed_member_remove_power" => 0 , "i_group_member_remove_power" => 0 , "i_needed_modify_power_count" => 0 , "i_needed_modify_power_total" => 0 , "i_permission_modify_power" => 0 , "i_group_needed_modify_power" => 0 , "i_group_modify_power" => 0 , "i_client_needed_modify_power" => 0 , "i_client_modify_power" => 0 , "b_virtualserver_servergroup_create" => 0 , "b_virtualserver_servergroup_delete" => 0 , "b_client_ignore_bans" => 0 , "b_client_ignore_antiflood" => 0 , "b_group_is_permanent" => 0 , "i_client_needed_ban_power" => 0 , "i_client_needed_kick_power" => 0 , "i_client_needed_move_power" => 0 , "i_client_talk_power" => 0 , "__sgid" => $ sgid , "__name" => $ sgroup -> toString ( ) , "__node" => $ sgroup , ) ; try { $ perms = $ this -> serverGroupPermList ( $ sgid , true ) ; $ grant = isset ( $ perms [ "i_permission_modify_power" ] ) ? $ perms [ "i_permission_modify_power" ] [ "permvalue" ] : null ; } catch ( Ts3Exception $ e ) { if ( $ e -> getCode ( ) != 0x501 ) { throw $ e ; } $ perms = array ( ) ; $ grant = null ; } foreach ( $ perms as $ permsid => $ perm ) { if ( in_array ( $ permsid , array_keys ( $ profiles [ $ sgid ] ) ) ) { $ profiles [ $ sgid ] [ $ permsid ] = $ perm [ "permvalue" ] ; } elseif ( StringHelper :: factory ( $ permsid ) -> startsWith ( "i_needed_modify_power_" ) ) { if ( ! $ grant || $ perm [ "permvalue" ] > $ grant ) { continue ; } $ profiles [ $ sgid ] [ "i_needed_modify_power_total" ] = $ profiles [ $ sgid ] [ "i_needed_modify_power_total" ] + $ perm [ "permvalue" ] ; $ profiles [ $ sgid ] [ "i_needed_modify_power_count" ] ++ ; } } } array_multisort ( $ profiles , SORT_DESC ) ; return $ profiles ; }
8312	public function handlePasswordReset ( Request $ httpRequest ) { $ this -> httpRequest = $ httpRequest ; $ this -> checkResetLink ( ) ; $ resetData = $ this -> session -> get ( "pwreset" ) ; if ( $ resetData === null ) { $ this -> beginPasswordReset ( ) ; } else { $ this -> finishPasswordReset ( $ resetData ) ; } }
772	public function actionConfigTemplate ( $ filePath ) { $ filePath = Yii :: getAlias ( $ filePath ) ; if ( file_exists ( $ filePath ) ) { if ( ! $ this -> confirm ( "File '{$filePath}' already exists. Do you wish to overwrite it?" ) ) { return ExitCode :: OK ; } } if ( ! copy ( Yii :: getAlias ( '@yii/views/messageConfig.php' ) , $ filePath ) ) { $ this -> stdout ( "Configuration file template was NOT created at '{$filePath}'.\n\n" , Console :: FG_RED ) ; return ExitCode :: UNSPECIFIED_ERROR ; } $ this -> stdout ( "Configuration file template created at '{$filePath}'.\n\n" , Console :: FG_GREEN ) ; return ExitCode :: OK ; }
11579	private function config ( ) { $ handler = new RotatingFileHandler ( $ this -> getFullPath ( ) , 0 , MonoLogger :: INFO ) ; $ handler -> setFormatter ( $ this -> getLineFormater ( ) ) ; $ this -> logger -> pushHandler ( $ handler ) ; $ this -> logger -> pushProcessor ( new WebProcessor ( ) ) ; $ this -> logger -> pushProcessor ( new MemoryUsageProcessor ( ) ) ; }
7867	protected function drawBorder ( $ left , $ middle , $ right ) { $ width = $ this -> geometry -> getWidthButBorders ( ) ; $ border = str_repeat ( static :: BORDER_Y , $ width ) ; $ this -> replaceUtf8 ( $ border , $ left , 0 ) ; $ this -> replaceUtf8 ( $ border , $ middle , floor ( $ width / 2 ) ) ; $ this -> replaceUtf8 ( $ border , $ right , $ width - 1 ) ; $ this -> drawBordered ( $ border ) ; }
3127	protected function isEndPoint ( TimePoint $ point ) { return $ point -> match ( null , TimePoint :: TARGET_ALL , TimePoint :: TYPE_END ) ; }
3280	protected function normalizeConfig ( array $ config ) : array { $ defaultConfig = [ 'dir' => getcwd ( ) , 'ext' => '.dat' , 'gzip' => false , 'cache' => true , 'formatter' => null , 'swap_memory_limit' => 2097152 , ] ; return array_replace ( $ defaultConfig , $ config ) ; }
2002	public static function getVersion ( string $ packageName ) : string { $ version = Versions :: getVersion ( $ packageName ) ; return static :: parseVersion ( $ version ) ; }
3471	public function merge ( Config $ config ) : Config { $ this -> config = array_merge_recursive ( $ this -> config , $ config -> config ) ; return $ this ; }
827	public function getCommentBlockIndices ( Tokens $ tokens , $ index ) { if ( ! $ tokens [ $ index ] -> isGivenKind ( T_COMMENT ) ) { throw new \ InvalidArgumentException ( 'Given index must point to a comment.' ) ; } $ commentType = $ this -> getCommentType ( $ tokens [ $ index ] -> getContent ( ) ) ; $ indices = [ $ index ] ; if ( self :: TYPE_SLASH_ASTERISK === $ commentType ) { return $ indices ; } $ count = \ count ( $ tokens ) ; ++ $ index ; for ( ; $ index < $ count ; ++ $ index ) { if ( $ tokens [ $ index ] -> isComment ( ) ) { if ( $ commentType === $ this -> getCommentType ( $ tokens [ $ index ] -> getContent ( ) ) ) { $ indices [ ] = $ index ; continue ; } break ; } if ( ! $ tokens [ $ index ] -> isWhitespace ( ) || $ this -> getLineBreakCount ( $ tokens , $ index , $ index + 1 ) > 1 ) { break ; } } return $ indices ; }
10841	public function sayHello ( ) { $ text = $ this -> getHALLogo ( ) ; if ( $ this -> showText ) { $ text .= $ this -> getHelloDave ( ) ; } $ lines = explode ( "\n" , $ text ) ; $ spaces = '' ; if ( $ this -> center ) { $ max_length = 0 ; foreach ( $ lines as $ line ) { $ max_length = max ( $ max_length , Helper :: strlenWithoutDecoration ( $ this -> output -> getFormatter ( ) , $ line ) ) ; } $ numberOfSpaces = floor ( ( $ this -> screenSize [ 0 ] - $ max_length ) / 2 ) ; if ( $ numberOfSpaces > 0 ) { $ spaces = str_repeat ( ' ' , $ numberOfSpaces ) ; } } foreach ( $ lines as $ line ) { $ this -> output -> writeln ( $ spaces . $ line ) ; } }
12516	public static function delete ( $ path ) { if ( ! Folder :: exists ( $ path ) ) { return true ; } $ path = Path :: clean ( $ path ) ; if ( trim ( $ path ) === '' ) { throw new Exception ( Helper :: getTranslation ( 'FAILED_DELETING' ) . ' : Cannot delete root path' ) ; } $ fs = new Filesystem ( ) ; try { $ fs -> remove ( $ path ) ; } catch ( IOExceptionInterface $ e ) { throw new Exception ( Helper :: getTranslation ( 'FAILED_DELETING' ) . ' - (' . $ e -> getMessage ( ) . ')' ) ; } return true ; }
12509	public function build ( ) { if ( empty ( $ this -> msgType ) ) { throw new RuntimeException ( 'message type not exist.' ) ; } if ( empty ( $ this -> message ) ) { throw new RuntimeException ( 'No message content to send.' ) ; } if ( $ this -> msgType === Broadcast :: MSG_TYPE_VIDEO ) { if ( is_array ( $ this -> message ) ) { $ this -> message = array_shift ( $ this -> message ) ; } $ this -> msgType = 'mpvideo' ; } $ content = ( new Transformer ( $ this -> msgType , $ this -> message ) ) -> transform ( ) ; $ group = isset ( $ this -> to ) ? $ this -> to : null ; $ message = array_merge ( $ this -> buildGroup ( $ group ) , $ content ) ; return $ message ; }
7641	protected function getErrorMessage ( $ response , $ alternativeError = 'Unknown error.' ) { $ xml = $ this -> parseResponse ( $ response ) ; if ( $ xml && $ xml -> Message ) { return "[" . $ response -> getStatusCode ( ) . "] " . ( string ) $ xml -> Message . "\n" . ( string ) $ xml -> AuthenticationErrorDetail ; } else { return $ alternativeError ; } }
5370	public function add ( $ key , $ value ) { if ( $ value === false ) { return ; } if ( is_array ( $ value ) ) { foreach ( $ value as $ item ) { $ this -> addPair ( $ key , $ item ) ; } } else { $ this -> addPair ( $ key , $ value ) ; } }
10949	protected function loadCsrfToken ( ) { if ( $ this -> enableCsrfCookie ) { return $ this -> getCookies ( ) -> getValue ( $ this -> csrfParam ) ; } else { return Yii :: $ app -> getSession ( ) -> get ( $ this -> csrfParam ) ; } }
3514	public function postMissingKeys ( ) { $ missingKeys = Request :: json ( 'missingKeys' ) ; $ this -> manager -> setConnectionName ( '' ) ; $ translator = App :: make ( 'translator' ) ; $ affectedGroups = [ ] ; foreach ( $ missingKeys as $ key ) { $ key = decodeKey ( $ key ) ; list ( $ namespace , $ group , $ item ) = $ translator -> parseKey ( $ key ) ; if ( $ item && $ group ) { if ( ! in_array ( $ group , $ this -> manager -> config ( Manager :: EXCLUDE_GROUPS_KEY ) ) ) { $ t = $ this -> manager -> missingKey ( $ namespace , $ group , $ item , null , false , true ) ; if ( ! $ t -> exists ) { $ affectedGroups [ ] = $ t -> group ; $ t -> save ( ) ; } } } else { } } $ data = [ 'connectionName' => '' , 'affectedGroups' => $ affectedGroups , 'missingKeys' => [ ] , ] ; $ pretty = Request :: has ( 'pretty-json' ) ? JSON_PRETTY_PRINT : 0 ; return Response :: json ( $ data , 200 , [ ] , JSON_UNESCAPED_SLASHES | $ pretty ) ; }
1769	public function __isset ( $ strKey ) { switch ( $ strKey ) { case 'id' : return isset ( $ this -> strId ) ; break ; case 'name' : return isset ( $ this -> strName ) ; break ; case 'label' : return isset ( $ this -> strLabel ) ; break ; case 'value' : return isset ( $ this -> varValue ) ; break ; case 'class' : return isset ( $ this -> strClass ) ; break ; case 'template' : return isset ( $ this -> strTemplate ) ; break ; case 'wizard' : return isset ( $ this -> strWizard ) ; break ; case 'required' : return isset ( $ this -> arrConfiguration [ $ strKey ] ) ; break ; case 'forAttribute' : return isset ( $ this -> blnForAttribute ) ; break ; case 'dataContainer' : return isset ( $ this -> objDca ) ; break ; case 'activeRecord' : return isset ( $ this -> objDca -> activeRecord ) ; break ; default : return isset ( $ this -> arrAttributes [ $ strKey ] ) || isset ( $ this -> arrConfiguration [ $ strKey ] ) ; break ; } }
10848	protected function getTableName ( $ returnAlias = false ) { $ result = '' ; foreach ( $ this -> clause_table as $ k => $ v ) { if ( ! is_int ( $ k ) && $ returnAlias ) { return $ k ; } else { return $ v ; } } return $ result ; }
9651	public function duplicate ( $ doWrite = true ) { $ clonedNode = parent :: duplicate ( $ doWrite ) ; if ( $ this -> Options ( ) ) { foreach ( $ this -> Options ( ) as $ field ) { $ newField = $ field -> duplicate ( ) ; $ newField -> ParentID = $ clonedNode -> ID ; $ newField -> write ( ) ; } } return $ clonedNode ; }
4446	public function tagged ( string $ tag , int $ offset = 0 , int $ limit = 25 ) : array { $ response = json_decode ( $ this -> client -> call ( 'tag' , 'get' , $ tag , $ offset , $ limit ) , true ) ; if ( empty ( $ response [ 'jobs' ] ) ) { $ response [ 'jobs' ] = [ ] ; } return $ response [ 'jobs' ] ; }
4439	public static function unregister ( ? array $ signals = null ) : void { if ( empty ( $ signals ) ) { $ signals = self :: KNOWN_SIGNALS ; } foreach ( $ signals as $ signal ) { if ( is_string ( $ signal ) ) { if ( ! defined ( $ signal ) ) { continue ; } $ signal = constant ( $ signal ) ; } pcntl_signal ( $ signal , SIG_DFL ) ; } }
2611	public function getActiveVersion ( $ service , $ activeVersion ) { $ currActiveVersion = $ this -> determineVersions ( $ service -> versions ) ; if ( $ currActiveVersion [ 'active_version' ] != $ activeVersion ) { throw new LocalizedException ( __ ( 'Active versions mismatch.' ) ) ; } return $ currActiveVersion ; }
8571	public function listRecommendations ( $ request ) { if ( ! ( $ request instanceof MWSRecommendationsSectionService_Model_ListRecommendationsRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/ListRecommendationsRequest.php' ) ; $ request = new MWSRecommendationsSectionService_Model_ListRecommendationsRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListRecommendations' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/ListRecommendationsResponse.php' ) ; $ response = MWSRecommendationsSectionService_Model_ListRecommendationsResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
893	private function getTypesContent ( ) { if ( null === $ this -> typesContent ) { $ name = $ this -> getTag ( ) -> getName ( ) ; if ( ! $ this -> supportTypes ( ) ) { throw new \ RuntimeException ( 'This tag does not support types.' ) ; } $ matchingResult = Preg :: match ( '{^(?:\s*\*|/\*\*)\s*@' . $ name . '\s+' . self :: REGEX_TYPES . '(?:[ \t].*)?$}sx' , $ this -> lines [ 0 ] -> getContent ( ) , $ matches ) ; $ this -> typesContent = 1 === $ matchingResult ? $ matches [ 'types' ] : '' ; } return $ this -> typesContent ; }
9661	public static function createReaderForFile ( $ filename ) { File :: assertFile ( $ filename ) ; $ guessedReader = self :: getReaderTypeFromExtension ( $ filename ) ; if ( $ guessedReader !== null ) { $ reader = self :: createReader ( $ guessedReader ) ; if ( isset ( $ reader ) && $ reader -> canRead ( $ filename ) ) { return $ reader ; } } foreach ( self :: $ readers as $ type => $ class ) { if ( $ type !== $ guessedReader ) { $ reader = self :: createReader ( $ type ) ; if ( $ reader -> canRead ( $ filename ) ) { return $ reader ; } } } throw new Reader \ Exception ( 'Unable to identify a reader for this file' ) ; }
12860	public function getDispatcher ( ) : Dispatcher { if ( $ this -> forceReload || ! file_exists ( $ this -> cacheFile ) ) { $ dispatchData = $ this -> buildCache ( ) ; } else { $ dispatchData = require $ this -> cacheFile ; } return call_user_func ( $ this -> dispatcherFactory , $ dispatchData ) ; }
8536	public function setRentalChargeList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'RentalChargeList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
1701	protected function decToUnix ( $ intTime , $ intDate ) { return mktime ( ( $ intTime & 0xf800 ) >> 11 , ( $ intTime & 0x07e0 ) >> 5 , ( $ intTime & 0x001f ) << 1 , ( $ intDate & 0x01e0 ) >> 5 , ( $ intDate & 0x001f ) , ( ( $ intDate & 0xfe00 ) >> 9 ) + 1980 ) ; }
12713	protected function resolve ( $ instance , $ parameters = [ ] ) { if ( $ this -> isInterface ( $ instance ) ) { return $ this -> getConcreteFromInterface ( $ instance ) ; } try { return $ this -> getResolvedSingleton ( $ instance ) ; } catch ( \ Exception $ e ) { } $ concrete = $ this -> getConcrete ( $ instance ) ; if ( ! is_null ( $ concrete ) ) { $ object = $ this -> build ( $ instance , $ concrete instanceof \ Closure ? $ concrete ( $ this ) : $ concrete ) ; if ( $ this -> isShared ( $ instance ) ) { $ this -> markAsResolved ( $ instance , $ object , 'singleton' ) ; } else { $ this -> markAsResolved ( $ instance , $ object ) ; } } else { $ object = $ this -> build ( $ instance , $ parameters ) ; } return $ object ; }
7879	protected function registerLogViewer ( ) { $ this -> app -> singleton ( 'logviewer' , function ( $ app ) { $ factory = $ app [ 'logviewer.factory' ] ; $ filesystem = $ app [ 'logviewer.filesystem' ] ; $ data = $ app [ 'logviewer.data' ] ; return new LogViewer ( $ factory , $ filesystem , $ data ) ; } ) ; $ this -> app -> alias ( 'logviewer' , LogViewer :: class ) ; }
10881	public function checkPaths ( ) { if ( $ this -> path_checked ) return true ; foreach ( array ( 'root' , 'webroot' ) as $ type ) { $ path = $ this -> $ type ; if ( ! file_exists ( $ path ) || ! is_dir ( $ path ) ) throw new IOException ( "Path '$type' does not exist: " . $ path ) ; if ( ! is_readable ( $ path ) ) throw new PermissionError ( $ path , "Path '$type' cannot be read" ) ; } if ( ! is_dir ( $ this -> config ) || is_readable ( $ this -> config ) ) $ this -> config = null ; foreach ( array ( 'var' , 'cache' , 'log' , 'uploads' ) as $ write_dir ) { $ path = $ this -> $ write_dir ; if ( ! is_dir ( $ path ) ) { $ dn = dirname ( $ path ) ; if ( ! file_exists ( $ path ) && $ dn === $ this -> var ) { Path :: mkdir ( $ path ) ; } else { if ( file_exists ( $ path ) ) throw new IOException ( "Path '$write_dir' exists but is not a directory: " . $ path ) ; $ this -> $ write_dir = null ; continue ; } } if ( ! is_writable ( $ path ) ) { try { Path :: makeWritable ( $ path ) ; } catch ( PermissionError $ e ) { $ this -> $ write_dir = null ; if ( $ this -> cli ) WF :: debug ( "Failed to get write access to: %s" , $ e -> getMessage ( ) ) ; } } } $ this -> path_checked = true ; return true ; }
2867	public function getContent ( $ filePath , $ startPosition , $ endPosition ) { if ( ! file_exists ( $ filePath ) ) { return '' ; } if ( ! $ endPosition ) { return trim ( file_get_contents ( $ filePath , null , null , $ startPosition ) ) ; } if ( $ endPosition <= $ startPosition ) { return '' ; } return trim ( file_get_contents ( $ filePath , null , null , $ startPosition , $ endPosition - $ startPosition ) ) ; }
1102	protected function hasChange ( ) { return ! ( $ this -> bound1 ( ) == $ this -> node -> getRight ( ) || $ this -> bound1 ( ) == $ this -> node -> getLeft ( ) ) ; }
9630	public function verifyAndMoveUploadedFile ( $ originSize , $ tmpDestination , $ publicDestination ) { $ remoteTempSize = $ this -> getSize ( $ tmpDestination ) ; $ this -> logger -> debug ( 'Temp size: ' . $ remoteTempSize ) ; $ this -> logger -> debug ( 'Origin size: ' . $ originSize ) ; if ( $ remoteTempSize <= 0 ) { throw new VerifySizeException ( 'Uploaded file has size ' . $ remoteTempSize ) ; } if ( $ remoteTempSize !== $ originSize ) { throw new VerifySizeException ( sprintf ( 'Uploaded file has wrong size. Expected %s, got %s.' , $ originSize , $ remoteTempSize ) ) ; } $ this -> logger -> info ( 'OK: Uploaded temp file has right size.' ) ; if ( ! $ this -> move ( $ tmpDestination , $ publicDestination ) ) { throw new FtpException ( 'Error renaming uploaded file from temp to public.' ) ; } $ remotePublicSize = $ this -> getSize ( $ publicDestination ) ; $ this -> logger -> debug ( 'Renamed size: ' . $ remotePublicSize ) ; if ( $ remotePublicSize <= 0 ) { throw new VerifySizeException ( 'Renamed file has size ' . $ remotePublicSize ) ; } if ( $ remotePublicSize !== $ originSize ) { throw new VerifySizeException ( sprintf ( 'Renamed file has wrong size. Expected %s, got %s.' , $ originSize , $ remotePublicSize ) ) ; } $ this -> logger -> info ( 'OK: Renamed file has right size.' ) ; return true ; }
8337	public function values ( $ values ) { if ( is_array ( $ values ) === true ) { if ( is_numeric ( key ( $ values ) ) === true ) { $ this -> values = array ( null , implode ( ', ' , $ values ) ) ; } else { $ this -> values = array ( '' , '' ) ; foreach ( $ values as $ key => $ value ) { if ( stripos ( $ key , '.' ) !== false ) { $ key = substr ( $ key , stripos ( $ key , '.' ) + 1 ) ; } $ this -> values [ 0 ] .= $ key . ', ' ; $ this -> values [ 1 ] .= $ value . ', ' ; } $ this -> values [ 0 ] = substr ( $ this -> values [ 0 ] , 0 , - 2 ) ; $ this -> values [ 1 ] = substr ( $ this -> values [ 1 ] , 0 , - 2 ) ; } } else { $ this -> values = array ( null , $ values ) ; } return $ this ; }
1314	public function url ( $ path , array $ parameters ) { $ this -> resetLastResponse ( ) ; $ this -> response -> setApiPath ( $ path ) ; $ query = http_build_query ( $ parameters ) ; return sprintf ( '%s/%s?%s' , self :: API_HOST , $ path , $ query ) ; }
1857	public function fopen ( $ strFile , $ strMode ) { $ this -> validate ( $ strFile ) ; return fopen ( $ this -> strRootDir . '/' . $ strFile , $ strMode ) ; }
12131	public function handle ( ) { $ view = $ this -> application -> createInstance ( "view" , [ $ this -> application -> response , $ this -> application -> createInstance ( "viewengine" , [ $ this -> application -> response ] ) , $ this -> application ] ) ; $ view -> setData ( "title" , "An Error Occured" ) ; $ this -> application -> response -> send ( $ view -> render ( "errors/error" ) ) ; return Handler :: LAST_HANDLER ; }
5766	private function clear ( ) { if ( ! isset ( $ this -> phpMailer ) ) { return ; } $ this -> phpMailer -> clearAddresses ( ) ; $ this -> phpMailer -> clearCCs ( ) ; $ this -> phpMailer -> clearBCCs ( ) ; $ this -> phpMailer -> clearReplyTos ( ) ; $ this -> phpMailer -> clearAllRecipients ( ) ; $ this -> phpMailer -> clearAttachments ( ) ; $ this -> phpMailer -> clearCustomHeaders ( ) ; }
3262	public static function callback ( $ order , $ transaction , $ status , $ data = null ) { $ statusCode = $ order -> statusCode ; try { if ( in_array ( $ status , [ 'success' , 'fail' ] ) ) { static :: $ gatewayKey = $ transaction -> gateway ; static :: $ gateway = static :: instanceGateway ( ) ; if ( $ status == 'success' ) { static :: $ gateway -> onCallbackSuccess ( $ order , $ data ) ; $ order -> statusCode = static :: $ gateway -> getTransactionStatusCode ( ) ; $ order -> placeTransaction ( static :: $ gatewayKey , static :: $ gateway -> getTransactionId ( ) , static :: $ gateway -> getTransactionDetail ( ) , static :: $ gateway -> getTransactionToken ( ) ) ; if ( $ order -> isCompleted ) \ event ( new OrderCompleted ( $ order -> id ) ) ; } else if ( $ status == 'fail' ) { static :: $ gateway -> onCallbackFail ( $ order , $ data ) ; $ order -> statusCode = 'failed' ; } $ order -> save ( ) ; } } catch ( ShopException $ e ) { static :: setException ( $ e ) ; $ order -> statusCode = 'failed' ; $ order -> save ( ) ; } catch ( GatewayException $ e ) { static :: setException ( $ e ) ; $ order -> statusCode = 'failed' ; $ order -> save ( ) ; } static :: checkStatusChange ( $ order , $ statusCode ) ; }
2680	public function checkImageOptimizationStatus ( ) { $ url = $ this -> _getApiServiceUri ( ) . 'dynamic_io_settings' ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: GET ) ; return $ result ; }
10122	private function writePrintHeaders ( ) { $ record = 0x002a ; $ length = 0x0002 ; $ fPrintRwCol = $ this -> printHeaders ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ fPrintRwCol ) ; $ this -> append ( $ header . $ data ) ; }
974	public function handle ( Request $ request , Closure $ next ) { $ hmac = $ request -> header ( 'x-shopify-hmac-sha256' ) ? : '' ; $ shop = $ request -> header ( 'x-shopify-shop-domain' ) ; $ data = $ request -> getContent ( ) ; $ hmacLocal = ShopifyApp :: createHmac ( [ 'data' => $ data , 'raw' => true , 'encode' => true ] ) ; if ( ! hash_equals ( $ hmac , $ hmacLocal ) || empty ( $ shop ) ) { return Response :: make ( 'Invalid webhook signature.' , 401 ) ; } return $ next ( $ request ) ; }
2012	public static function addNamespace ( $ name ) { @ trigger_error ( 'Using ClassLoader::addNamespace() has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; if ( \ in_array ( $ name , self :: $ namespaces ) ) { return ; } array_unshift ( self :: $ namespaces , $ name ) ; }
11658	public static function addEntriesToFile ( $ file , $ entries ) { $ properties = self :: readFromFile ( $ file ) ; foreach ( $ entries as $ key => $ value ) { $ properties [ $ key ] = $ value ; } self :: saveToFile ( $ file , $ properties ) ; }
7085	public function setDbQueryConditionsForDefaultOptionsLoader ( $ conditonsAndOptions ) { if ( ! is_array ( $ conditonsAndOptions ) && ! ( $ conditonsAndOptions instanceof DbExpr ) && ! ( $ conditonsAndOptions instanceof \ Closure ) ) { throw new \ InvalidArgumentException ( '$conditonsAndOptions argument must be a string, DbExpr or a Closure' ) ; } $ this -> dbQueryConditionsForDefaultOptionsLoader = $ conditonsAndOptions ; return $ this ; }
527	public function registerAssetFiles ( $ view ) { $ manager = $ view -> getAssetManager ( ) ; foreach ( $ this -> js as $ js ) { if ( is_array ( $ js ) ) { $ file = array_shift ( $ js ) ; $ options = ArrayHelper :: merge ( $ this -> jsOptions , $ js ) ; $ view -> registerJsFile ( $ manager -> getAssetUrl ( $ this , $ file ) , $ options ) ; } else { if ( $ js !== null ) { $ view -> registerJsFile ( $ manager -> getAssetUrl ( $ this , $ js ) , $ this -> jsOptions ) ; } } } foreach ( $ this -> css as $ css ) { if ( is_array ( $ css ) ) { $ file = array_shift ( $ css ) ; $ options = ArrayHelper :: merge ( $ this -> cssOptions , $ css ) ; $ view -> registerCssFile ( $ manager -> getAssetUrl ( $ this , $ file ) , $ options ) ; } else { if ( $ css !== null ) { $ view -> registerCssFile ( $ manager -> getAssetUrl ( $ this , $ css ) , $ this -> cssOptions ) ; } } } }
12094	public function getMd5Url ( $ address , $ scheme = true , $ www = true ) { $ this -> urlAddress -> setAddress ( $ address ) ; return $ this -> urlAddress -> getMd5Address ( $ scheme , $ www ) ; }
8720	protected function initTranslatableAttributes ( ) { if ( property_exists ( $ this , 'translatable' ) ) { $ attributes = $ this -> translatable ; } else { $ attributes = $ this -> getTranslatableAttributesFromSchema ( ) ; } static :: $ i18nAttributes [ $ this -> getTable ( ) ] = $ attributes ; }
7107	static public function round ( $ amount , $ currency ) { $ precision = static :: getPrecision ( $ currency ) ; $ roundingIncrement = static :: getRoundingIncrement ( $ currency ) ; $ amount = round ( $ amount , $ precision , \ PHP_ROUND_HALF_EVEN ) ; if ( 0 < $ roundingIncrement && 0 < $ precision ) { $ roundingFactor = $ roundingIncrement / pow ( 10 , $ precision ) ; $ amount = round ( $ amount / $ roundingFactor ) * $ roundingFactor ; } return $ amount ; }
6454	private function createNotAcceptableException ( string $ type ) : HttpException { $ headers = new HttpHeaders ( ) ; $ headers -> add ( 'Content-Type' , 'application/json' ) ; $ body = new StringBody ( json_encode ( $ this -> contentNegotiator -> getAcceptableResponseMediaTypes ( $ type ) ) ) ; $ response = new Response ( HttpStatusCodes :: HTTP_NOT_ACCEPTABLE , $ headers , $ body ) ; return new HttpException ( $ response ) ; }
4231	public static function findInheritedDoc ( \ Reflector $ reflector ) { $ name = $ reflector -> getName ( ) ; $ reflectionClass = $ reflector -> getDeclaringClass ( ) ; $ interfaces = $ reflectionClass -> getInterfaceNames ( ) ; foreach ( $ interfaces as $ className ) { $ reflectionClass2 = new \ ReflectionClass ( $ className ) ; if ( $ reflectionClass2 -> hasMethod ( $ name ) ) { return self :: getParsed ( $ reflectionClass2 -> getMethod ( $ name ) ) ; } } $ reflectionClass = $ reflectionClass -> getParentClass ( ) ; if ( $ reflectionClass && $ reflectionClass -> hasMethod ( $ name ) ) { return self :: getParsed ( $ reflectionClass -> getMethod ( $ name ) ) ; } }
149	public function isActive ( $ scenario ) { return ! in_array ( $ scenario , $ this -> except , true ) && ( empty ( $ this -> on ) || in_array ( $ scenario , $ this -> on , true ) ) ; }
11568	public function count ( ) { if ( is_null ( $ this -> recordSet ) ) { $ this -> fetchData ( ) ; } if ( is_null ( $ this -> recordcount ) ) { $ this -> recordcount = $ this -> recordSet -> RecordCount ( ) ; } return $ this -> recordcount ; }
11344	public function removeField ( $ name ) { for ( $ i = 0 ; $ i < count ( $ this -> fields ) ; $ i ++ ) { if ( $ this -> fields [ $ i ] -> getName ( ) == $ name ) { array_splice ( $ this -> fields , $ i , 1 ) ; break ; } } }
2956	public function deviceClose ( ) { if ( $ this -> _dState !== SERIAL_DEVICE_OPENED ) { return true ; } if ( fclose ( $ this -> _dHandle ) ) { $ this -> _dHandle = null ; $ this -> _dState = SERIAL_DEVICE_SET ; return true ; } trigger_error ( "Unable to close the device" , E_USER_ERROR ) ; return false ; }
11139	protected function getSetItem ( $ dataMember , $ offset , $ quote = true ) { $ item = $ this -> { $ dataMember } [ $ offset ] ; switch ( $ item [ 1 ] ) { case 'varchar' : $ type = 'varchar(255)' ; break ; default : $ type = $ item [ 1 ] ; } $ this -> { $ dataMember } [ $ offset ] [ 1 ] = $ type ; return $ this -> getArrayItem ( $ dataMember , $ offset , $ quote ) ; }
11540	protected function resolveAddOptions ( array $ options ) { if ( $ this -> optionsResolved ) { return ; } $ this -> optionsResolver -> clear ( ) ; $ this -> optionsResolver -> setRequired ( array ( 'page' , 'language' , 'country' , 'slot' , 'blockname' , 'type' , 'position' , 'direction' , ) ) ; $ this -> optionsResolver -> resolve ( $ options ) ; $ this -> optionsResolved = true ; }
10226	public function noAssociationsMenuFor ( $ model , ModelConfig $ config = null ) { $ modelName = $ this -> resolveModelName ( $ model ) ; $ menuFactory = $ this -> app -> make ( 'Label305\AujaLaravel\Factory\NoAssociationsIndexMenuFactory' ) ; return $ menuFactory -> create ( $ modelName , $ config ) ; }
6372	public function append ( IteratorAggregate $ other ) : FluentIterable { return self :: from ( Iterables :: concat ( $ this , $ other ) ) ; }
12374	public function run ( ) : void { if ( ! $ this -> isRan ) { $ this -> isRan = true ; foreach ( $ this -> items as $ item ) { $ options = $ item [ 2 ] ?? [ ] ; $ ruleName = $ item [ 1 ] ; foreach ( is_array ( $ item [ 0 ] ) ? $ item [ 0 ] : [ $ item [ 0 ] ] as $ fieldName ) { self :: applyRuleToField ( $ fieldName , $ ruleName , $ options ) ; } } } }
6034	public function setMimeType ( $ mimeType ) { if ( $ mimeType instanceof MimeType ) { $ this -> mimeType = $ mimeType ; } elseif ( is_array ( $ mimeType ) ) { $ this -> mimeType = new MimeType ( $ mimeType ) ; } else { $ this -> mimeType = null ; trigger_error ( 'Argument must be an object of class MimeType. Data loss!' , E_USER_WARNING ) ; } return $ this ; }
935	public static function isKeyCaseSensitive ( $ caseSensitive , $ key ) { if ( \ is_array ( $ caseSensitive ) ) { return isset ( $ caseSensitive [ $ key ] ) ? $ caseSensitive [ $ key ] : true ; } return $ caseSensitive ; }
4269	public function dir_readdir ( ) { if ( ! $ this -> handle ) { return false ; } self :: restorePrev ( ) ; $ success = \ readdir ( $ this -> handle ) ; self :: register ( ) ; return $ success ; }
11588	public function duration ( ) { $ duration = 0 ; foreach ( $ this -> _tasks as $ task ) { $ duration += $ task -> duration ( ) ; } return $ duration ; }
8416	public function commit ( ) : bool { if ( $ this -> isConnected ( ) === false ) { $ this -> connect ( ) ; } if ( $ this -> transactionLevel > 0 ) { -- $ this -> transactionLevel ; if ( $ this -> transactionLevel == 0 ) { return $ this -> providerDatabase -> commit ( $ this -> GetMasterLink ( ) ) ; } return $ this -> providerDatabase -> releaseSavePoint ( $ this -> GetMasterLink ( ) , 'LEVEL' . $ this -> transactionLevel ) ; } return false ; }
11009	public function addPluginType ( string $ mediaType ) : bool { if ( ! preg_match ( '#^[-\w]+/[-\w]+$#ui' , $ mediaType ) ) { throw new MiddlewareException ( $ this , sprintf ( "'%s' is not a valid media type and can not be used as a CSP plugin type" , $ mediaType ) ) ; } if ( ! in_array ( $ mediaType , $ this -> tags [ 'plugin-types' ] ) ) { $ this -> tags [ 'plugin-types' ] [ ] = $ mediaType ; return true ; } return false ; }
6817	protected function buildAdjustments ( $ type , Model \ AdjustableInterface $ adjustable , array $ data , $ persistence = false ) { Model \ AdjustmentTypes :: isValidType ( $ type ) ; $ change = false ; $ newAdjustments = [ ] ; foreach ( $ data as $ d ) { $ adjustment = $ this -> saleFactory -> createAdjustmentFor ( $ adjustable ) ; $ adjustment -> setType ( $ type ) -> setMode ( $ d -> getMode ( ) ) -> setDesignation ( $ d -> getDesignation ( ) ) -> setAmount ( $ d -> getAmount ( ) ) -> setImmutable ( $ d -> isImmutable ( ) ) ; $ newAdjustments [ ] = $ adjustment ; } $ oldAdjustments = $ adjustable -> getAdjustments ( $ type ) ; foreach ( $ oldAdjustments as $ oldAdjustment ) { if ( ! $ oldAdjustment -> isImmutable ( ) ) { continue ; } foreach ( $ newAdjustments as $ index => $ newAdjustment ) { if ( $ oldAdjustment -> equals ( $ newAdjustment ) ) { unset ( $ newAdjustments [ $ index ] ) ; continue 2 ; } } $ adjustable -> removeAdjustment ( $ oldAdjustment ) ; if ( $ persistence ) { $ this -> persistenceHelper -> remove ( $ oldAdjustment , true ) ; } $ change = true ; } foreach ( $ newAdjustments as $ newAdjustment ) { $ adjustable -> addAdjustment ( $ newAdjustment ) ; if ( $ persistence ) { $ this -> persistenceHelper -> persistAndRecompute ( $ newAdjustment , true ) ; } $ change = true ; } return $ change ; }
1194	public function setRequest ( Request $ request ) { @ trigger_error ( sprintf ( 'The %s() method is deprecated since version 2.3 and will be removed in 3.0. Pass a RequestStack in the constructor instead.' , __METHOD__ ) , E_USER_DEPRECATED ) ; $ this -> request = $ request ; }
12104	public function handleRequest ( ) : void { global $ argv ; if ( ! is_array ( $ argv ) || empty ( $ argv ) ) { throw new Exception ( 'Invalid value of the cli args array was given.' ) ; } ( new CliCtrlResolver ( $ argv ) ) -> run ( ) ; }
9174	private function hierarchyToFlatArray ( $ items ) { $ flatArray = [ ] ; foreach ( $ items as $ item ) { $ flatArray [ ] = $ item -> getId ( ) ; if ( $ items -> getChildren ( ) -> count ( ) > 0 ) { $ flatArray = array_merge ( $ flatArray , $ this -> hierarchyToFlatArray ( $ items -> getChildren ( ) ) ) ; } } return $ flatArray ; }
2180	private function findIn ( string $ path ) : Finder { return Finder :: create ( ) -> ignoreDotFiles ( false ) -> sort ( static function ( SplFileInfo $ a , SplFileInfo $ b ) : int { $ countA = substr_count ( strtr ( $ a -> getRelativePath ( ) , '\\' , '/' ) , '/' ) ; $ countB = substr_count ( strtr ( $ b -> getRelativePath ( ) , '\\' , '/' ) , '/' ) ; return $ countA <=> $ countB ; } ) -> followLinks ( ) -> in ( $ path ) ; }
45	public function dispatchPackageEvent ( $ eventName , $ devMode , PolicyInterface $ policy , Pool $ pool , CompositeRepository $ installedRepo , Request $ request , array $ operations , OperationInterface $ operation ) { return $ this -> doDispatch ( new PackageEvent ( $ eventName , $ this -> composer , $ this -> io , $ devMode , $ policy , $ pool , $ installedRepo , $ request , $ operations , $ operation ) ) ; }
659	public function noCache ( callable $ callable ) { $ this -> _queryCacheInfo [ ] = false ; try { $ result = call_user_func ( $ callable , $ this ) ; array_pop ( $ this -> _queryCacheInfo ) ; return $ result ; } catch ( \ Exception $ e ) { array_pop ( $ this -> _queryCacheInfo ) ; throw $ e ; } catch ( \ Throwable $ e ) { array_pop ( $ this -> _queryCacheInfo ) ; throw $ e ; } }
7870	protected function drawBorderBottom ( $ isCore = false ) { $ this -> geometry -> decreaseNesting ( ) ; $ crossroads = $ isCore ? static :: CROSSROADS_DOWN : static :: CROSSROADS ; $ this -> drawBorder ( static :: BORDER_SW , $ crossroads , static :: BORDER_SE ) ; }
11035	function check_level ( $ error_level , $ errno , $ message ) { if ( error_reporting ( ) & $ error_level ) { switch ( $ error_level ) { case E_NOTICE : $ type = 'notice' ; break ; case E_WARNING : $ type = 'warning' ; break ; case E_ERROR : $ type = 'error' ; break ; } echo "<b>ETS $type:</b> $message" ; } if ( $ error_level == E_ERROR ) { exit ; } }
117	protected function getCommand ( $ cmd , $ url , $ path = null ) { $ cmd = sprintf ( '%s %s%s %s' , $ cmd , '--non-interactive ' , $ this -> getCredentialString ( ) , ProcessExecutor :: escape ( $ url ) ) ; if ( $ path ) { $ cmd .= ' ' . ProcessExecutor :: escape ( $ path ) ; } return $ cmd ; }
2464	public static function findSentByPids ( $ arrPids , array $ arrOptions = array ( ) ) { if ( empty ( $ arrPids ) || ! \ is_array ( $ arrPids ) ) { return null ; } $ t = static :: $ strTable ; $ arrColumns = array ( "$t.pid IN(" . implode ( ',' , array_map ( '\intval' , $ arrPids ) ) . ")" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ arrColumns [ ] = "$t.sent=1" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.date DESC" ; } return static :: findBy ( $ arrColumns , null , $ arrOptions ) ; }
1929	public function generate ( ) { if ( TL_MODE == 'BE' ) { $ return = '<pre>' . StringUtil :: specialchars ( $ this -> code ) . '</pre>' ; if ( $ this -> headline != '' ) { $ return = '<' . $ this -> hl . '>' . $ this -> headline . '</' . $ this -> hl . '>' . $ return ; } return $ return ; } return parent :: generate ( ) ; }
11953	public function deleteFromDB ( ) { if ( ! $ this -> isValid ( ) ) { return false ; } if ( count ( $ this -> key_properties ) == 0 ) { return false ; } $ where_part = '' ; foreach ( $ this -> key_properties as $ key ) { if ( $ where_part ) { $ where_part .= ' AND ' ; } if ( $ this -> { $ key } instanceof Web2All_Table_SQLOperation ) { trigger_error ( 'Web2All_Table_SaveObjectTrait->deleteFromDB(): using Web2All_Table_SQLOperation object for key value ' . $ key , E_USER_NOTICE ) ; $ where_part .= $ this -> obj_to_db_trans [ $ key ] . '=' . $ this -> { $ key } -> toSQLString ( ) ; } else if ( $ this -> { $ key } instanceof Web2All_Table_SQLOperationList ) { throw new Exception ( "Web2All_Table_SaveObjectTrait: can't delete using a Web2All_Table_SQLOperationList for key value " . $ key ) ; } else { $ where_part .= $ this -> obj_to_db_trans [ $ key ] . '=' . $ this -> db -> Quote ( $ this -> { $ key } ) ; } } $ this -> db -> Execute ( 'DELETE FROM ' . $ this -> quote ( $ this -> tablename ) . ' WHERE ' . $ where_part . ' ' ) ; return true ; }
4674	public function addCallback ( $ callback , $ data = [ ] , $ region = "main" , $ sort = 0 ) { $ view = new View ( ) ; $ view -> set ( [ "callback" => $ callback ] , $ data , $ sort , "callback" ) ; $ this -> views [ $ region ] [ ] = $ view ; return $ this ; }
4105	public function beginBulk ( ) { if ( ! $ this -> bulk ) { $ this -> bulk = $ this -> createBulk ( $ this ) ; } return $ this -> bulk ; }
9374	protected function dispatcher ( ResponseInterface $ response , $ stack ) { $ dispatcher = new Dispatcher ( $ stack , $ response ) ; if ( class_exists ( 'Zend\Stratigility\MiddlewarePipe' ) ) { $ pipe = new MiddlewarePipe ; $ dispatcher = new StratigilityDispatcher ( $ pipe , $ stack , $ response ) ; } return $ dispatcher ; }
6766	public function onAddressChange ( ResourceEventInterface $ event ) { $ sale = $ this -> getSaleFromEvent ( $ event ) ; if ( $ this -> persistenceHelper -> isScheduledForRemove ( $ sale ) ) { $ event -> stopPropagation ( ) ; return ; } if ( $ this -> handleAddressChange ( $ sale ) ) { $ this -> persistenceHelper -> persistAndRecompute ( $ sale , false ) ; $ this -> scheduleContentChangeEvent ( $ sale ) ; } }
12899	public function getResponse ( ) { if ( $ this -> response ) { return $ this -> response ; } return $ this -> response = \ GuzzleHttp \ Psr7 \ parse_response ( $ this -> getResponseStream ( ) ) ; }
1017	public static function getAllBuiltInTypes ( ) { if ( self :: $ builtInTypes === null ) { self :: $ builtInTypes = array_merge ( Introspection :: getTypes ( ) , self :: getStandardTypes ( ) ) ; } return self :: $ builtInTypes ; }
6033	public function getMetadata ( $ section = null , $ key = null ) { if ( null === $ section ) { return $ this -> metadata ; } foreach ( $ this -> metadata as $ md ) { if ( $ section != $ md -> getSection ( ) ) { continue ; } if ( null === $ key ) { return $ md ; } foreach ( $ md -> getData ( ) as $ k => $ data ) { if ( $ key == $ k ) { return $ data ; } } throw new NotFoundException ( 'No metadata with section "' . $ section . '" and key "' . $ key . '" exists.' ) ; } throw new NotFoundException ( 'No metadata with section "' . $ section . '" exists.' ) ; }
10952	protected function write ( Response $ response , $ body ) : Response { $ response -> getBody ( ) -> write ( ( string ) $ body ) ; return $ response ; }
5632	protected function removeTrailingSlash ( $ path ) { if ( substr ( $ path , - 1 ) == DIRECTORY_SEPARATOR ) { return substr ( $ path , 0 , - 1 ) ; } elseif ( substr ( $ path , - 1 ) == '/' ) { return substr ( $ path , 0 , - 1 ) ; } else { return $ path ; } }
1341	public function find ( ResourceIdentifierInterface $ identifier ) { $ record = $ this -> lookup ( $ identifier ) ; if ( false === $ record ) { return false ; } return is_object ( $ record ) ? $ record : null ; }
12297	public function getRules ( array $ fields = [ ] ) { $ default_rules = $ this -> model -> getRules ( ) ; if ( count ( $ fields ) < 1 ) { return $ default_rules ; } foreach ( $ fields as $ field => $ rule ) { if ( is_int ( $ field ) ) { $ rules [ $ rule ] = $ default_rules [ $ rule ] ; continue ; } if ( ! key_exists ( $ field , $ default_rules ) ) { continue ; } $ default_rules [ $ field ] .= '|' . $ rule ; } $ rules = [ ] ; $ transformation = $ this -> model -> getTransformation ( ) ; foreach ( $ transformation as $ original => $ transformed ) { $ rules [ $ transformed ] = $ default_rules [ $ original ] ; } foreach ( $ fields as $ field => $ rule ) { if ( ! key_exists ( $ field , $ rules ) ) { continue ; } $ rules [ $ field ] .= '|' . $ rule ; } return $ rules ; }
7842	public function handle ( $ job , Closure $ next ) { $ this -> callBefore ( $ job ) ; $ handled = $ next ( $ job ) ; $ this -> callAfter ( $ handled , $ job ) ; return $ handled ; }
2705	public function execute ( ) { $ result = $ this -> resultJsonFactory -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ snippets = $ this -> config -> getVclSnippets ( Config :: VCL_AUTH_SNIPPET_PATH ) ; foreach ( $ snippets as $ key => $ value ) { $ name = Config :: FASTLY_MAGENTO_MODULE . '_basic_auth_' . $ key ; $ status = $ this -> api -> hasSnippet ( $ activeVersion , $ name ) ; if ( $ status == false ) { return $ result -> setData ( [ 'status' => false ] ) ; } } return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
329	public function buildKey ( $ key ) { if ( is_string ( $ key ) ) { $ key = ctype_alnum ( $ key ) && StringHelper :: byteLength ( $ key ) <= 32 ? $ key : md5 ( $ key ) ; } else { if ( $ this -> _igbinaryAvailable ) { $ serializedKey = igbinary_serialize ( $ key ) ; } else { $ serializedKey = serialize ( $ key ) ; } $ key = md5 ( $ serializedKey ) ; } return $ this -> keyPrefix . $ key ; }
7777	protected function extractFieldAliases ( array $ data ) { foreach ( $ data as $ field => $ fieldRules ) { $ extraction = explode ( '|' , $ field ) ; if ( isset ( $ extraction [ 1 ] ) ) { $ updatedField = $ extraction [ 0 ] ; $ alias = $ extraction [ 1 ] ; $ this -> fieldAliases [ $ updatedField ] = $ alias ; $ data [ $ updatedField ] = $ data [ $ field ] ; unset ( $ data [ $ field ] ) ; } } return $ data ; }
4332	private static function buildAttribArrayVal ( $ key , $ value = array ( ) ) { if ( $ key == 'class' ) { if ( ! \ is_array ( $ value ) ) { $ value = \ explode ( ' ' , $ value ) ; } $ value = \ array_filter ( \ array_unique ( $ value ) ) ; \ sort ( $ value ) ; $ value = \ implode ( ' ' , $ value ) ; } elseif ( $ key == 'style' ) { $ keyValues = array ( ) ; foreach ( $ value as $ k => $ v ) { $ keyValues [ ] = $ k . ':' . $ v . ';' ; } \ sort ( $ keyValues ) ; $ value = \ implode ( '' , $ keyValues ) ; } else { $ value = null ; } return $ value ; }
8212	protected function validateFile ( $ filePath , $ message = 'File' , $ allowEmpty = true ) { if ( ! file_exists ( $ filePath ) || ! is_readable ( $ filePath ) ) { throw new \ RuntimeException ( "$message '{$filePath}' doesn't exist or is not readable." ) ; } if ( ! $ allowEmpty && 0 === filesize ( $ filePath ) ) { throw new \ RuntimeException ( "$message '{$filePath}' is empty." ) ; } return realpath ( $ filePath ) ; }
4575	public function getCount ( Parameters $ parameters = null ) { $ options = [ 'headers' => [ 'Accept' => 'application/json' ] ] ; $ result = $ this -> execute ( 'GET' , static :: RESOURCE_COUNT , $ options ) ; return $ result -> count ; }
7335	private function addMappings ( ClassMetadata $ metadata , array $ mappings ) { foreach ( $ mappings as $ mapping ) { if ( ! $ metadata -> hasField ( $ mapping [ 'fieldName' ] ) ) { $ metadata -> mapField ( $ mapping ) ; } } }
8577	public function setItemFeeList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ItemFeeList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
5092	public function assemble ( ) { $ command = 'CREATE ' . $ this -> getPartIfSet ( self :: PART_TEMP ) . 'TABLE ' . $ this -> getPartIfSet ( self :: PART_IF_NOT_EXIST ) . $ this -> parts [ self :: PART_DB ] . $ this -> parts [ self :: PART_NAME ] ; if ( $ this -> parts [ self :: PART_LIKE ] ) { return $ command . ' ' . $ this -> parts [ self :: PART_LIKE ] ; } if ( ! $ this -> columnsList -> isEmpty ( ) ) { $ command .= '(' ; $ columns = $ this -> columnsList -> assemble ( ) ; $ keys = $ this -> indexes -> assemble ( ) ; $ combined = array_merge ( $ columns , $ keys ) ; $ command .= implode ( ',' , $ combined ) ; $ command .= ') ' . $ this -> getPartIfSet ( self :: PART_ENGINE , 'ENGINE=' ) . $ this -> getPartIfSet ( self :: PART_CHARSET , 'CHARSET=' ) . $ this -> getPartIfSet ( self :: PART_CHARSET , 'AUTO_INCREMENT=' ) . $ this -> getPartIfSet ( self :: PART_COMMENT , 'COMMENT=' ) ; } if ( $ this -> parts [ self :: PART_AS ] ) { $ command .= " {$this->getAsExpression()}" ; } return $ command ; }
7093	private function checkHierarchyIntegrity ( InvoiceInterface $ invoice ) { if ( null !== $ shipment = $ invoice -> getShipment ( ) ) { if ( $ invoice -> getSale ( ) !== $ shipment -> getSale ( ) ) { throw new ValidationFailedException ( ) ; } if ( InvoiceTypes :: isCredit ( $ invoice ) && ! $ shipment -> isReturn ( ) ) { throw new ValidationFailedException ( ) ; } if ( InvoiceTypes :: isInvoice ( $ invoice ) && $ shipment -> isReturn ( ) ) { throw new ValidationFailedException ( ) ; } } }
7277	public function time ( $ timestamp = false ) { return $ timestamp ? ( new DateTime ( $ this -> time ) ) -> getTimestamp ( ) : $ this -> time ; }
10400	public static function skip ( ItemPipelineEvent $ event , $ reason = '' ) { $ itemSkip = new ItemSkip ( ) ; $ itemSkip -> setReason ( $ reason ) ; $ event -> setItemSkip ( $ itemSkip ) ; $ event -> stopPropagation ( ) ; }
12263	public function renderCustomField ( array $ fields , $ classOrCustomField , $ documentType = 'html' , $ slug = null , $ showIfEmpty = true ) { $ customField = ( $ classOrCustomField instanceof CustomField ) ? $ classOrCustomField : $ this -> getCustomField ( $ classOrCustomField , $ slug ) ; $ slug = $ customField -> getSlug ( ) ; $ rawValue = ( isset ( $ fields [ $ slug ] ) ) ? $ fields [ $ slug ] : null ; $ customFieldType = $ this -> provider -> getCustomFieldByType ( $ customField -> getType ( ) ) ; return $ customFieldType -> render ( $ rawValue , $ customField , $ documentType ) ; }
4802	protected function locateDirectory ( string $ name ) : ? string { $ parts = [ $ name ] ; foreach ( Database :: COLLECTION_SEPARATOR_CHARACTERS as $ char ) { if ( ! strstr ( $ name , $ char ) ) { continue ; } $ parts = explode ( $ char , $ name ) ; break ; } return $ this -> recurseLocateDirectory ( $ parts ) ; }
5566	public function get ( $ url , $ parameters = false ) { if ( ! is_object ( $ url ) ) { $ url = new SimpleUrl ( $ url ) ; } if ( $ this -> getUrl ( ) ) { $ url = $ url -> makeAbsolute ( $ this -> getUrl ( ) ) ; } return $ this -> load ( $ url , new SimpleGetEncoding ( $ parameters ) ) ; }
3510	public static function dbValue ( $ value , $ nullValue = 'NULL' ) { if ( $ value === null ) { return $ nullValue ; } if ( is_string ( $ value ) ) { return '\'' . str_replace ( '\'' , '\'\'' , $ value ) . '\'' ; } if ( is_bool ( $ value ) ) { return $ value ? '1' : '0' ; } return $ value ; }
4298	public function count ( $ label = null , $ flags = 0 ) { $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) ) ; if ( \ count ( $ args ) == 1 && \ is_int ( $ args [ 0 ] ) ) { $ label = null ; $ flags = $ args [ 0 ] ; } else { $ args = \ array_combine ( array ( 'label' , 'flags' ) , \ array_replace ( array ( null , 0 ) , $ args ) ) ; \ extract ( $ args ) ; } if ( isset ( $ label ) ) { $ dataLabel = ( string ) $ label ; } else { $ callerInfo = $ this -> utilities -> getCallerInfo ( ) ; $ meta = \ array_merge ( array ( 'file' => $ callerInfo [ 'file' ] , 'line' => $ callerInfo [ 'line' ] , ) , $ meta ) ; $ label = 'count' ; $ dataLabel = $ meta [ 'file' ] . ': ' . $ meta [ 'line' ] ; } if ( ! isset ( $ this -> data [ 'counts' ] [ $ dataLabel ] ) ) { $ this -> data [ 'counts' ] [ $ dataLabel ] = 0 ; } if ( ! ( $ flags & self :: COUNT_NO_INC ) ) { $ this -> data [ 'counts' ] [ $ dataLabel ] ++ ; } $ count = $ this -> data [ 'counts' ] [ $ dataLabel ] ; if ( ! ( $ flags & self :: COUNT_NO_OUT ) ) { $ this -> appendLog ( 'count' , array ( ( string ) $ label , $ count , ) , $ meta ) ; } return $ count ; }
4608	public function createStatus ( string $ status , array $ options = null ) : array { $ url = '/statuses' ; if ( empty ( $ options ) ) { $ options = [ ] ; } $ params = array_merge ( [ 'status' => $ status , ] , $ options ) ; return $ this -> post ( $ url , $ params ) ; }
5328	public function getCpuinfoByLsCpu ( ) { if ( ! $ this -> cpuInfoByLsCpu ) { $ lscpu = shell_exec ( 'lscpu' ) ; $ lscpu = explode ( "\n" , $ lscpu ) ; $ values = [ ] ; foreach ( $ lscpu as $ v ) { $ v = array_map ( 'trim' , explode ( ':' , $ v ) ) ; if ( isset ( $ v [ 0 ] , $ v [ 1 ] ) ) { $ values [ $ v [ 0 ] ] = $ v [ 1 ] ; } } $ this -> cpuInfoByLsCpu = $ values ; } return $ this -> cpuInfoByLsCpu ; }
9080	private static function parseElement ( Request & $ req , $ serverVars , $ elementName , $ paramName ) { if ( isset ( $ serverVars [ $ elementName ] ) ) { $ req -> setParam ( $ paramName , $ serverVars [ $ elementName ] ) ; } }
3755	public function sameModels ( $ objModel1 , $ objModel2 ) { if ( ! ( $ objModel1 instanceof Model && $ objModel2 instanceof Model ) ) { throw new \ InvalidArgumentException ( 'Passed models are not valid.' ) ; } $ objNative1 = $ objModel1 -> getItem ( ) ; $ objNative2 = $ objModel2 -> getItem ( ) ; if ( $ objNative1 -> getMetaModel ( ) === $ objNative2 -> getMetaModel ( ) ) { return true ; } foreach ( $ objNative1 -> getMetaModel ( ) -> getAttributes ( ) as $ objAttribute ) { if ( $ objNative1 -> get ( $ objAttribute -> getColName ( ) ) != $ objNative2 -> get ( $ objAttribute -> getColName ( ) ) ) { return false ; } } return true ; }
6613	public function settings ( $ setting = null ) { if ( ! is_null ( $ setting ) ) { return isset ( $ this -> settings [ $ setting ] ) ? $ this -> settings [ $ setting ] : null ; } return $ this -> settings ; }
11959	public function splice ( $ offset = 0 , $ length = 0 , $ replacement = [ ] ) { return new static ( array_splice ( $ this -> elements , $ offset , $ length , $ replacement ) ) ; }
5815	public function onBeforeWrite ( ) { parent :: onBeforeWrite ( ) ; $ types = $ this -> Types ? explode ( ',' , $ this -> Types ) : array ( ) ; if ( is_string ( $ this -> TagTypes ) ) { $ types = array_merge ( $ types , array_keys ( unserialize ( $ this -> TagTypes ) ) ) ; } if ( ! empty ( $ types ) ) { sort ( $ types ) ; $ formatted = array ( ) ; $ existing = $ this -> service -> getFusionTagTypes ( ) ; foreach ( $ types as $ type ) { if ( isset ( $ existing [ $ type ] ) ) { $ formatted [ $ type ] = $ type ; } } $ this -> TagTypes = ! empty ( $ formatted ) ? serialize ( $ formatted ) : null ; $ this -> Types = implode ( ',' , $ formatted ) ; } }
10939	public function get ( $ key ) { if ( ! ( $ time = $ this -> driver -> get ( $ key ) ) ) { if ( $ key == self :: LAST_UPDATE_KEY ) { $ time = $ this -> reset ( ) ; } else { $ time = $ this -> get ( self :: LAST_UPDATE_KEY ) ; } } return $ time ; }
5307	protected function getPathFromPolygon ( SimpleXMLElement $ polygon ) { $ points = $ this -> getValuesFromList ( $ polygon [ 'points' ] ) ; $ path = 'M' . array_shift ( $ points ) . ' ' . array_shift ( $ points ) ; while ( count ( $ points ) ) { $ path .= 'L' . array_shift ( $ points ) . ' ' . array_shift ( $ points ) ; } return $ path . 'Z' ; }
3654	public function purge ( ) { foreach ( $ GLOBALS [ 'TL_PURGE' ] [ 'folders' ] [ 'metamodels_assets' ] [ 'affected' ] as $ folderName ) { $ folder = new \ Folder ( $ folderName ) ; $ folder -> purge ( ) ; } $ dispatcher = $ GLOBALS [ 'container' ] [ 'event-dispatcher' ] ; $ dispatcher -> dispatch ( ContaoEvents :: SYSTEM_LOG , new LogEvent ( 'Purged the MetaModels assets' , __METHOD__ , TL_CRON ) ) ; }
11886	public function addChild ( $ structureName , $ prefix = '' , $ suffix = '' ) { if ( isset ( $ this -> children [ $ structureName ] ) ) { throw new DefinitionDuplicateException ( sprintf ( 'Child structure with same name "%s" already exists' , $ structureName ) ) ; } $ this -> children [ $ structureName ] = array ( 'name' => $ structureName , 'prefix' => ( string ) $ prefix , 'suffix' => ( string ) $ suffix ) ; }
11818	public function setServiceLocator ( ServiceLocatorInterface $ serviceLocator ) { $ this -> serviceLocator = $ serviceLocator ; $ config = $ serviceLocator -> getServiceLocator ( ) -> get ( 'config' ) ; if ( isset ( $ config [ 'rznviewcomponent' ] ) ) { $ this -> config = $ config [ 'rznviewcomponent' ] ; } return $ this ; }
11107	public function shouldThrottle ( APIRequest $ request ) : bool { $ item = $ this -> cacheItemPool -> getItem ( $ this -> deriveCacheKey ( $ request ) ) ; return $ item -> get ( ) >= $ this -> limit ; }
5448	public function acceptStartToken ( $ token , $ event ) { if ( $ event == LEXER_ENTER ) { $ this -> tag = strtolower ( substr ( $ token , 1 ) ) ; return true ; } if ( $ event == LEXER_EXIT ) { $ success = $ this -> listener -> startElement ( $ this -> tag , $ this -> attributes ) ; $ this -> tag = '' ; $ this -> attributes = array ( ) ; return $ success ; } if ( $ token !== '=' ) { $ this -> current_attribute = strtolower ( html_entity_decode ( $ token , ENT_QUOTES ) ) ; $ this -> attributes [ $ this -> current_attribute ] = '' ; } return true ; }
3798	private function checkModelWithVariants ( $ containedModel ) { $ isVarbase = ( bool ) $ containedModel -> getProperty ( 'varbase' ) ; $ vargroup = $ containedModel -> getProperty ( 'vargroup' ) ; $ isCurrentVarbase = ( bool ) $ this -> currentModel -> getProperty ( 'varbase' ) ; $ currentVargroup = $ this -> currentModel -> getProperty ( 'vargroup' ) ; if ( $ isVarbase && ! $ this -> circularReference && $ isCurrentVarbase ) { $ this -> disablePA = false ; } elseif ( ! $ isVarbase && ! $ isCurrentVarbase && $ vargroup == $ currentVargroup ) { $ this -> disablePA = false ; } $ this -> disablePI = ! $ isCurrentVarbase || $ isVarbase ; }
11496	public static function end ( ) { if ( self :: $ startTime ) { $ time = round ( ( microtime ( true ) - self :: $ startTime ) , 4 ) ; self :: $ startTime = false ; } return ( isset ( $ time ) ) ? $ time : false ; }
1493	public function index ( $ resourceType , $ meta = null , array $ queryParams = [ ] ) { return $ this -> factory -> createLink ( $ this -> urls -> index ( $ resourceType , $ queryParams ) , $ meta , true ) ; }
3594	public static function getCurrentMacAddress ( $ interface ) { $ ifconfig = self :: runCommand ( "ifconfig {$interface}" ) ; preg_match ( "/" . self :: $ valid_mac . "/i" , $ ifconfig , $ ifconfig ) ; if ( isset ( $ ifconfig [ 0 ] ) ) { return trim ( strtoupper ( $ ifconfig [ 0 ] ) ) ; } return false ; }
8891	public function singleton ( $ key , $ value ) { if ( is_callable ( $ value ) ) { $ this -> registerFactory ( $ key , $ value ) ; } else { $ this -> sm -> setService ( $ key , $ value ) ; } }
1435	public static function underscore ( $ value ) { if ( isset ( self :: $ underscored [ $ value ] ) ) { return self :: $ underscored [ $ value ] ; } return self :: $ underscored [ $ value ] = str_replace ( '-' , '_' , self :: decamelize ( $ value ) ) ; }
3449	public function setAttribute ( $ key , $ value ) { if ( in_array ( $ key , $ this -> multipleHighloadBlockFields ) ) { $ this -> attributes [ $ key ] = serialize ( $ value ) ; return $ this ; } parent :: setAttribute ( $ key , $ value ) ; return $ this ; }
2692	public function getFastlyUrl ( ) { $ baseFile = $ this -> getBaseFile ( ) ; $ url = $ this -> getBaseFileUrl ( $ baseFile ) ; $ imageQuality = $ this -> _scopeConfig -> getValue ( Config :: XML_FASTLY_IMAGE_OPTIMIZATION_IMAGE_QUALITY ) ; $ this -> setQuality ( $ imageQuality ) ; $ this -> fastlyParameters [ 'quality' ] = $ this -> _quality ; if ( $ this -> _scopeConfig -> isSetFlag ( Config :: XML_FASTLY_IMAGE_OPTIMIZATION_BG_COLOR ) == true ) { $ this -> fastlyParameters [ 'bg-color' ] = implode ( ',' , $ this -> _backgroundColor ) ; } if ( $ this -> _keepAspectRatio == true ) { $ this -> fastlyParameters [ 'fit' ] = 'bounds' ; } $ this -> fastlyUrl = $ url . '?' . $ this -> compileFastlyParameters ( ) ; }
10661	public function withoutCookie ( $ cookieName = null ) { $ object = clone $ this ; if ( ! $ this -> configs [ 'cookies' ] instanceof CookieJarInterface ) { return $ object ; } if ( ! $ cookieName ) { unset ( $ object -> configs [ 'cookies' ] ) ; } else { if ( ! is_array ( $ cookieName ) ) { $ cookieName = [ $ cookieName ] ; } $ cookies = $ this -> configs [ 'cookies' ] -> toArray ( ) ; foreach ( $ cookieName as $ cookie ) { if ( ! is_string ( $ cookie ) || ! $ cookie ) { continue ; } unset ( $ cookies [ $ cookie ] ) ; } $ this -> configs [ 'cookies' ] = new CookieJar ( $ cookies ) ; } return $ object -> buildConfigClient ( ) ; }
327	public function send ( MailerInterface $ mailer = null ) { if ( $ mailer === null && $ this -> mailer === null ) { $ mailer = Yii :: $ app -> getMailer ( ) ; } elseif ( $ mailer === null ) { $ mailer = $ this -> mailer ; } return $ mailer -> send ( $ this ) ; }
3026	private function parseResponse ( $ response ) { $ response -> json = json_decode ( $ response -> body ) ; if ( $ response -> status < 400 ) { return $ response -> json -> response ; } else { throw new RequestException ( $ response ) ; } }
1188	public function validatorClosure ( ) { return function ( $ attribute , $ value , $ parameters , BaseValidator $ validator ) { $ remoteValidator = new Validator ( $ validator ) ; $ remoteValidator -> validate ( $ value , $ parameters ) ; return $ attribute ; } ; }
11989	public function sort ( $ entityName , $ values ) { $ values = json_decode ( $ values ) ; for ( $ i = 0 ; $ i < count ( $ values ) ; $ i ++ ) { $ this -> entityManager -> getRepository ( $ entityName ) -> createQueryBuilder ( 'e' ) -> update ( ) -> set ( 'e.order' , $ i ) -> where ( 'e.id = :id' ) -> setParameter ( 'id' , $ values [ $ i ] -> id ) -> getQuery ( ) -> execute ( ) ; } }
7102	public static function site ( string $ uri = '' , $ protocol = null ) : string { $ path = preg_replace ( '~^[-a-z0-9+.]++://[^/]++/?~' , '' , trim ( $ uri , '/' ) ) ; if ( preg_match ( '/[^\x00-\x7F]/S' , $ path ) ) { $ path = preg_replace_callback ( '~([^/]+)~' , '\mii\util\URL::_rawurlencode_callback' , $ path ) ; } return URL :: base ( $ protocol ) . $ path ; }
295	public function getOldAttribute ( $ name ) { return isset ( $ this -> _oldAttributes [ $ name ] ) ? $ this -> _oldAttributes [ $ name ] : null ; }
3236	public function getTotalPriceAttribute ( ) { if ( empty ( $ this -> shopCalculations ) ) $ this -> runCalculations ( ) ; return round ( $ this -> shopCalculations -> totalPrice , 2 ) ; }
1302	public function getDefaultLocale ( ) : Locale { foreach ( $ this -> locales as $ locale ) { if ( $ locale -> isDefault ( ) ) { return $ locale ; } } throw new \ RuntimeException ( 'No locale marked as default exists in this environment.' ) ; }
9254	public function handle ( Request $ request , $ type = self :: MASTER_REQUEST , $ catch = true ) { if ( ! $ this -> booted ) { $ this -> boot ( ) ; } $ request -> attributes -> set ( 'app' , $ this ) ; return $ this -> kernel -> handle ( $ request , $ type , $ catch ) ; }
387	public function setAttributeOrders ( $ attributeOrders , $ validate = true ) { if ( $ attributeOrders === null || ! $ validate ) { $ this -> _attributeOrders = $ attributeOrders ; } else { $ this -> _attributeOrders = [ ] ; foreach ( $ attributeOrders as $ attribute => $ order ) { if ( isset ( $ this -> attributes [ $ attribute ] ) ) { $ this -> _attributeOrders [ $ attribute ] = $ order ; if ( ! $ this -> enableMultiSort ) { break ; } } } } }
3934	private function setExcluded ( PropertyInterface $ property , $ propInfo ) { if ( ! isset ( $ propInfo [ 'exclude' ] ) ) { return ; } $ property -> setExcluded ( ( bool ) $ propInfo [ 'exclude' ] ) ; }
2757	public function permissions ( ) { $ permissions = [ ] ; foreach ( $ this -> entityTypeManager -> getStorage ( 'taxonomy_vocabulary' ) -> loadMultiple ( ) as $ vocabulary ) { $ permissions += [ 'view published terms in ' . $ vocabulary -> id ( ) => [ 'title' => $ this -> t ( 'View published terms in %vocabulary' , [ '%vocabulary' => $ vocabulary -> label ( ) ] ) , ] , 'view unpublished terms in ' . $ vocabulary -> id ( ) => [ 'title' => $ this -> t ( 'View unpublished terms in %vocabulary' , [ '%vocabulary' => $ vocabulary -> label ( ) ] ) , ] , ] ; } return $ permissions ; }
7512	function next ( ) { $ this -> token_start = null ; if ( ++ $ this -> pos < $ this -> size ) { if ( isset ( $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ) { if ( is_string ( $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ) { return ( $ this -> token = $ this -> { $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] } ( ) ) ; } else { return ( $ this -> token = $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ; } } else { return ( $ this -> token = self :: TOK_UNKNOWN ) ; } } else { return ( $ this -> token = self :: TOK_NULL ) ; } }
8755	public function buildTracker ( $ numItems = Tracker :: UNKNOWN , array $ extraSubscribers = [ ] ) { $ tracker = new Tracker ( $ numItems ) ; foreach ( array_merge ( $ this -> defaultSubscribers , $ extraSubscribers ) as $ listener ) { $ tracker -> getDispatcher ( ) -> addSubscriber ( $ listener ) ; } return $ tracker ; }
10594	public function getViewData ( ) { if ( $ this -> view !== NULL ) return $ this -> view ; $ this -> view = new \ stdClass ; try { $ this -> initMainApplicationProperties ( ) ; if ( $ this -> router === NULL ) return $ this -> view ; $ this -> initViewPanelTitle ( ) ; $ this -> initViewPanelTableData ( ) ; $ this -> initViewPanelRequestedUrlData ( ) ; } catch ( \ Exception $ e ) { $ this -> _debug ( $ e ) ; $ this -> _debug ( $ e -> getTrace ( ) ) ; } $ this -> view -> _debugCode = $ this -> _debugCode ; return $ this -> view ; }
1558	protected function doesRequireOrdering ( $ query ) { if ( ! $ this -> primaryKey ) { return false ; } $ query = ( $ query instanceof Relation ) ? $ query -> getBaseQuery ( ) : $ query -> getQuery ( ) ; return ! collect ( $ query -> orders ? : [ ] ) -> contains ( function ( array $ order ) { $ col = $ order [ 'column' ] ?? '' ; return $ this -> primaryKey === $ col ; } ) ; }
9523	private function getConfig ( ) { $ yaml = new Parser ( ) ; $ configFile = getenv ( 'TRAVIS_BUILD_DIR' ) . '/.travis.yml' ; $ config = $ yaml -> parse ( file_get_contents ( $ configFile ) ) ; $ config = $ config [ 'travisdeployer' ] ; $ this -> branches = $ config [ 'branches' ] ; if ( count ( $ this -> branches ) === 0 ) { die ( 'No branches are configured to deploy to.' . PHP_EOL ) ; } $ this -> verbose = filter_input ( FILTER_VALIDATE_BOOLEAN , $ config [ 'verbose' ] ) ; }
10081	protected function registerManager ( ) { $ this -> app -> singleton ( 'auja' , function ( $ app ) { $ config = $ app [ 'config' ] [ 'auja-laravel' ] ? : $ app [ 'config' ] [ 'auja-laravel::config' ] ; return new Auja ( $ app , $ app [ 'auja.configurator' ] , $ config [ 'models' ] ) ; } ) ; $ this -> app -> bind ( 'Label305\AujaLaravel\Auja' , 'auja' ) ; }
12078	public function childAssociate ( $ request , $ idParent , $ idChild , $ relation ) { $ request -> request -> merge ( [ 'url' => $ request -> request -> path ( ) ] ) ; $ idParent = $ this -> getRealId ( $ idParent ) ; $ idChild = $ this -> getRealId ( $ idChild ) ; $ resourceChild = $ this -> repository -> attach ( $ idParent , $ idChild , $ relation , $ request -> all ( ) ) ; if ( ! $ resourceChild ) { } return $ this -> success ( [ $ resourceChild ] ) ; }
4085	public function createStore ( ) { $ request = $ this -> requestStack -> getCurrentRequest ( ) ; return new BreadcrumbStore ( $ this -> iconBuilder , $ this -> translator , $ request ? $ request -> getUri ( ) : '' ) ; }
3742	public function delete ( $ varItem ) { if ( is_object ( $ varItem ) && ( $ varItem instanceof Model ) ) { $ objModelItem = $ varItem -> getItem ( ) ; } else { $ objModelItem = $ this -> getMetaModel ( ) -> findById ( $ varItem ) ; } if ( $ objModelItem ) { $ this -> getMetaModel ( ) -> delete ( $ objModelItem ) ; } }
8582	public function setAny ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'Any' ] [ 'FieldValue' ] = $ value ; return $ this ; }
12928	public function update ( $ poiId , array $ data ) { $ data = array_merge ( $ data , [ 'poi_id' => $ poiId ] ) ; $ params = [ 'business' => [ 'base_info' => $ data ] , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_UPDATE , $ params ] ) ; }
6268	public function isAcademic ( $ text ) { if ( empty ( $ text ) ) { return false ; } $ domain = $ this -> getDomain ( $ text ) ; if ( $ domain === null ) { return false ; } foreach ( $ this -> getBlacklistedTopLevelDomains ( ) as $ blacklistedDomain ) { $ name = ( string ) $ domain [ 'host' ] ; if ( preg_match ( '/' . preg_quote ( $ blacklistedDomain ) . '$/' , $ name ) ) { return false ; } } if ( in_array ( $ domain [ 'tld' ] , $ this -> getAcademicTopLevelDomains ( ) ) ) { return true ; } if ( $ this -> matchesAcademicDomain ( $ domain ) ) { return true ; } return false ; }
1626	public static function buildKey ( $ key ) { if ( is_numeric ( $ key ) ) { return $ key ; } elseif ( is_string ( $ key ) ) { return ctype_alnum ( $ key ) && StringHelper :: byteLength ( $ key ) <= 32 ? $ key : md5 ( $ key ) ; } elseif ( is_array ( $ key ) ) { if ( count ( $ key ) == 1 ) { return self :: buildKey ( reset ( $ key ) ) ; } ksort ( $ key ) ; $ isNumeric = true ; foreach ( $ key as $ value ) { if ( ! is_numeric ( $ value ) ) { $ isNumeric = false ; } } if ( $ isNumeric ) { return implode ( '-' , $ key ) ; } } return md5 ( json_encode ( $ key , JSON_NUMERIC_CHECK ) ) ; }
9332	public function requireField ( ) { $ charset = MySQLDatabase :: config ( ) -> charset ; $ collation = MySQLDatabase :: config ( ) -> collation ; $ spec = [ 'type' => 'varchar' , 'parts' => [ 'datatype' => 'varchar' , 'precision' => 64 , 'collate' => $ collation , 'character set' => $ charset , 'arrayValue' => $ this -> arrayValue ] ] ; DB :: require_field ( $ this -> tableName , $ this -> name , $ spec ) ; }
623	protected function createModels ( $ rows ) { if ( $ this -> asArray ) { return $ rows ; } else { $ models = [ ] ; $ class = $ this -> modelClass ; foreach ( $ rows as $ row ) { $ model = $ class :: instantiate ( $ row ) ; $ modelClass = get_class ( $ model ) ; $ modelClass :: populateRecord ( $ model , $ row ) ; $ models [ ] = $ model ; } return $ models ; } }
3570	public function __unsetHook ( ) { return function ( $ next , $ value , $ args ) { $ key = $ args -> get ( 'key' ) ; if ( $ this -> hasMeta ( $ key ) ) { return $ this -> setMeta ( $ key , null ) ; } return $ next ( $ value , $ args ) ; } ; }
9420	public function search ( HTTPRequest $ request ) { if ( ! $ request -> isAjax ( ) ) { return ; } $ data = [ ] ; if ( $ term = $ request -> getVar ( 'term' ) ) { $ groups = [ ] ; foreach ( $ this -> backend -> getGroupedIcons ( ) as $ group => $ icons ) { $ children = [ ] ; foreach ( $ icons as $ id => $ icon ) { if ( stripos ( $ id , $ term ) !== false ) { $ children [ ] = $ this -> getResultData ( $ this -> getIconData ( $ id ) ) ; } } if ( ! empty ( $ children ) ) { $ groups [ ] = [ 'text' => $ group , 'children' => $ children ] ; } } $ data [ 'results' ] = $ groups ; } return $ this -> respond ( $ data ) ; }
10315	function getUniqueClicksCount ( $ fromDate = null , $ toDate = null , $ mailingIds = null , $ contactIds = null , $ contactEmails = null , $ contactExternalIds = null , $ excludeAnonymousClicks = false ) { $ params = $ this -> createCountQueryParameters ( $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , $ mailingIds , null ) ; if ( isset ( $ excludeAnonymousClicks ) ) $ params [ 'exclude_anonymous_clicks' ] = ( $ excludeAnonymousClicks == true ) ? "true" : "false" ; return $ this -> get ( 'reports/clicks/unique/count' , $ params ) ; }
12915	protected function getColumnReference ( $ column , $ tableless ) { if ( $ tableless ) { return $ column ; } if ( count ( explode ( "." , $ column ) ) > 1 ) { return $ column ; } return "`" . $ this -> table . "`.`" . $ column . "`" ; }
6131	protected function getSuffixIconServer ( ) { $ html = "" ; if ( $ this -> currObj [ "virtualserver_icon_id" ] ) { if ( ! $ this -> currObj -> iconIsLocal ( "virtualserver_icon_id" ) && $ this -> ftclient ) { if ( ! isset ( $ this -> cacheIcon [ $ this -> currObj [ "virtualserver_icon_id" ] ] ) ) { $ download = $ this -> currObj -> transferInitDownload ( rand ( 0x0000 , 0xFFFF ) , 0 , $ this -> currObj -> iconGetName ( "virtualserver_icon_id" ) ) ; if ( $ this -> ftclient == "data:image" ) { $ download = TeamSpeak3 :: factory ( "filetransfer://" . $ download [ "host" ] . ":" . $ download [ "port" ] ) -> download ( $ download [ "ftkey" ] , $ download [ "size" ] ) ; } $ this -> cacheIcon [ $ this -> currObj [ "virtualserver_icon_id" ] ] = $ download ; } else { $ download = $ this -> cacheIcon [ $ this -> currObj [ "virtualserver_icon_id" ] ] ; } if ( $ this -> ftclient == "data:image" ) { $ html .= $ this -> getImage ( "data:" . Convert :: imageMimeType ( $ download ) . ";base64," . base64_encode ( $ download ) , "Server Icon" , null , false ) ; } else { $ html .= $ this -> getImage ( $ this -> ftclient . "?ftdata=" . base64_encode ( serialize ( $ download ) ) , "Server Icon" , null , false ) ; } } elseif ( in_array ( $ this -> currObj [ "virtualserver_icon_id" ] , $ this -> cachedIcons ) ) { $ html .= $ this -> getImage ( "group_icon_" . $ this -> currObj [ "virtualserver_icon_id" ] . ".png" , "Server Icon" ) ; } } return $ html ; }
11787	public static function getAgeByDate ( string $ sBirthday ) : int { list ( $ iYear , $ iMonth , $ iDay ) = preg_split ( '/[-.]/' , $ sBirthday ) ; $ aToday = array ( ) ; $ aToday [ 'mois' ] = date ( 'n' ) ; $ aToday [ 'jour' ] = date ( 'j' ) ; $ aToday [ 'annee' ] = date ( 'Y' ) ; $ iYears = $ aToday [ 'annee' ] - $ iYear ; if ( $ aToday [ 'mois' ] <= $ iMonth ) { if ( $ iMonth == $ aToday [ 'mois' ] ) { if ( $ iDay > $ aToday [ 'jour' ] ) { $ iYears -- ; } } else { $ iYears -- ; } } return $ iYears ; }
4171	public function askPackageKey ( $ summary , $ message = 'Please provide an id' ) { $ this -> table ( [ 'id' , 'name' ] , $ summary ) ; $ selected = $ this -> ask ( $ message ) ; $ key = collect ( $ summary ) -> pluck ( 'id' ) -> search ( $ selected ) ; if ( $ key === false ) { $ this -> warn ( 'Invalid package name or id given.' ) ; return $ this -> askPackageKey ( $ summary , 'Please provide a valid id' ) ; } return $ key ; }
2216	public function last ( ) { $ this -> intIndex = $ this -> count ( ) - 1 ; $ this -> blnDone = true ; $ this -> arrCache = $ this -> resultSet [ $ this -> intIndex ] ; return $ this ; }
9910	function toArray ( ) { $ result = array ( ) ; $ object_vars = get_object_vars ( $ this ) ; foreach ( $ object_vars as $ key => $ value ) { if ( $ value == null ) { continue ; } if ( gettype ( $ value ) == "object" && is_subclass_of ( $ value , 'AbstractJSONWrapper' ) ) { if ( ! $ value -> isEmpty ( ) ) { $ result [ $ key ] = $ value -> toArray ( ) ; } } else { $ result [ $ key ] = $ value ; } } return $ result ; }
7411	public function combine ( array $ keys ) : self { if ( count ( $ keys ) !== count ( $ this -> _container ) ) { throw new LengthException ( 'array counts do not match' ) ; } $ this -> _container = array_combine ( $ keys , $ this -> _container ) ; return $ this ; }
9029	public function error ( Request $ request ) { $ this -> response -> setCode ( 404 ) ; printf ( "<h2>%s</h2>" , HttpStatus :: getStatus ( 404 ) ) ; printf ( "Requested document %s on %s could not be found!" , $ request -> getAction ( ) , $ request -> getController ( ) ) ; }
8528	public function listFinancialEventGroupsByNextToken ( $ request ) { if ( ! ( $ request instanceof MWSFinancesService_Model_ListFinancialEventGroupsByNextTokenRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/ListFinancialEventGroupsByNextTokenRequest.php' ) ; $ request = new MWSFinancesService_Model_ListFinancialEventGroupsByNextTokenRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListFinancialEventGroupsByNextToken' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/ListFinancialEventGroupsByNextTokenResponse.php' ) ; $ response = MWSFinancesService_Model_ListFinancialEventGroupsByNextTokenResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
3794	private function checkForAction ( $ clipboard , $ action ) { $ filter = new Filter ( ) ; $ filter -> andActionIs ( $ action ) ; $ items = $ clipboard -> fetch ( $ filter ) ; if ( $ items === null ) { return ; } foreach ( $ items as $ item ) { $ itemProviderName = $ item -> getDataProviderName ( ) ; $ modelId = $ item -> getModelId ( ) ; if ( $ this -> providerName !== $ itemProviderName ) { continue ; } if ( ! $ modelId ) { $ this -> checkEmpty ( $ action ) ; continue ; } $ containedModel = $ this -> getModelById ( $ modelId -> getId ( ) ) ; if ( $ this -> currentModel == null ) { $ this -> checkForRoot ( $ containedModel , $ action ) ; } elseif ( $ containedModel ) { $ this -> checkForModel ( $ containedModel , $ action ) ; } else { $ this -> checkEmpty ( $ action ) ; } } }
7186	public function getCombination ( $ quantity , $ reset = false ) { if ( null !== $ this -> combination && ! $ reset ) { return $ this -> combination ; } $ this -> combination = null ; if ( ! empty ( $ combinations = $ this -> buildCombinations ( $ quantity ) ) ) { usort ( $ combinations , function ( AssignmentCombination $ a , AssignmentCombination $ b ) use ( $ quantity ) { if ( $ a -> diff == $ b -> diff ) { if ( $ a -> size == $ b -> size ) { return 0 ; } return $ a -> size < $ b -> size ? - 1 : 1 ; } if ( 0 <= $ a -> diff ) { return intval ( 0 > $ b -> diff ? - 1 : $ a -> diff - $ b -> diff ) ; } return intval ( 0 < $ b -> diff ? 1 : $ b -> diff - $ a -> diff ) ; } ) ; $ this -> combination = reset ( $ combinations ) ; } return $ this -> combination ; }
5234	public function withEntry ( $ key , $ value ) { $ this -> bindings [ $ key ] = $ this -> getValueCreator ( $ value ) ; return $ this ; }
693	public function compose ( $ view = null , array $ params = [ ] ) { $ message = $ this -> createMessage ( ) ; if ( $ view === null ) { return $ message ; } if ( ! array_key_exists ( 'message' , $ params ) ) { $ params [ 'message' ] = $ message ; } $ this -> _message = $ message ; if ( is_array ( $ view ) ) { if ( isset ( $ view [ 'html' ] ) ) { $ html = $ this -> render ( $ view [ 'html' ] , $ params , $ this -> htmlLayout ) ; } if ( isset ( $ view [ 'text' ] ) ) { $ text = $ this -> render ( $ view [ 'text' ] , $ params , $ this -> textLayout ) ; } } else { $ html = $ this -> render ( $ view , $ params , $ this -> htmlLayout ) ; } $ this -> _message = null ; if ( isset ( $ html ) ) { $ message -> setHtmlBody ( $ html ) ; } if ( isset ( $ text ) ) { $ message -> setTextBody ( $ text ) ; } elseif ( isset ( $ html ) ) { if ( preg_match ( '~<body[^>]*>(.*?)</body>~is' , $ html , $ match ) ) { $ html = $ match [ 1 ] ; } $ html = preg_replace ( '~<((style|script))[^>]*>(.*?)</\1>~is' , '' , $ html ) ; $ text = html_entity_decode ( strip_tags ( $ html ) , ENT_QUOTES | ENT_HTML5 , Yii :: $ app ? Yii :: $ app -> charset : 'UTF-8' ) ; $ text = preg_replace ( "~^[ \t]+~m" , '' , trim ( $ text ) ) ; $ text = preg_replace ( '~\R\R+~mu' , "\n\n" , $ text ) ; $ message -> setTextBody ( $ text ) ; } return $ message ; }
793	public function getAttributes ( $ names = null , $ except = [ ] ) { $ values = [ ] ; if ( $ names === null ) { $ names = $ this -> attributes ( ) ; } foreach ( $ names as $ name ) { $ values [ $ name ] = $ this -> $ name ; } foreach ( $ except as $ name ) { unset ( $ values [ $ name ] ) ; } return $ values ; }
4828	public function create_bill ( $ attrs ) { if ( ! isset ( $ attrs [ 'amount' ] ) ) { throw new GoCardless_ArgumentsException ( 'Amount required' ) ; } $ params = array ( 'bill' => array ( 'amount' => $ attrs [ 'amount' ] , 'pre_authorization_id' => $ this -> id ) ) ; if ( isset ( $ attrs [ 'name' ] ) ) { $ params [ 'bill' ] [ 'name' ] = $ attrs [ 'name' ] ; } if ( isset ( $ attrs [ 'description' ] ) ) { $ params [ 'bill' ] [ 'description' ] = $ attrs [ 'description' ] ; } if ( isset ( $ attrs [ 'charge_customer_at' ] ) ) { $ params [ 'bill' ] [ 'charge_customer_at' ] = $ attrs [ 'charge_customer_at' ] ; } $ endpoint = GoCardless_Bill :: $ endpoint ; return new GoCardless_Bill ( $ this -> client , $ this -> client -> request ( 'post' , $ endpoint , $ params ) ) ; }
5826	public function setJson ( $ toggle ) { $ this -> setEncoding ( $ toggle ? Request :: ENCODING_JSON : Request :: ENCODING_QUERY ) ; return $ this ; }
6240	public static function getMimeFor ( string $ extension ) : ? string { $ extensions = static :: getExtensions ( ) ; if ( isset ( $ extensions [ $ extension ] ) ) { return $ extensions [ $ extension ] ; } return null ; }
11097	public static function secondsBetweenDates ( $ start , $ end , $ absolute = true , $ timezone = 'Europe/Prague' ) { $ timezoneObj = new \ DateTimeZone ( $ timezone ) ; $ date = new DateTime ( $ end , $ timezoneObj ) ; $ diff = $ date -> diff ( new DateTime ( $ start , $ timezoneObj ) , $ absolute ) ; return ( $ diff -> invert ? - 1 : 1 ) * ( ( $ diff -> days * 86400 ) + ( $ diff -> h * 3600 ) + ( $ diff -> i * 60 ) + $ diff -> s ) ; }
12381	public static function interval ( $ startDate , $ endDate ) { $ hits = DB :: table ( 'views' ) -> select ( 'id' , 'ip' , 'created_at' ) -> whereBetween ( 'created_at' , [ $ startDate , $ endDate ] ) -> groupBy ( 'ip' ) -> get ( ) ; return count ( $ hits ) ; }
2551	protected function loadRequestCreator ( $ requestCreator , $ params , $ libIdentifier , $ originatorOffice , $ mesVer ) { if ( $ requestCreator instanceof RequestCreatorInterface ) { $ newRequestCreator = $ requestCreator ; } else { $ params -> originatorOfficeId = $ originatorOffice ; $ params -> messagesAndVersions = $ mesVer ; $ newRequestCreator = RequestCreatorFactory :: createRequestCreator ( $ params , $ libIdentifier ) ; } return $ newRequestCreator ; }
6861	public function doDefaultValueConversionByType ( $ value , $ type , array $ record ) { switch ( $ type ) { case static :: TYPE_DATETIME : return date ( static :: FORMAT_DATETIME , is_numeric ( $ value ) ? $ value : strtotime ( $ value ) ) ; case static :: TYPE_DATE : return date ( static :: FORMAT_DATE , is_numeric ( $ value ) ? $ value : strtotime ( $ value ) ) ; case static :: TYPE_TIME : return date ( static :: FORMAT_TIME , is_numeric ( $ value ) ? $ value : strtotime ( $ value ) ) ; case static :: TYPE_MULTILINE : return '<pre class="multiline-text">' . $ value . '</pre>' ; case static :: TYPE_JSON : case static :: TYPE_JSONB : if ( ! is_array ( $ value ) && $ value !== null ) { if ( is_string ( $ value ) || is_numeric ( $ value ) || is_bool ( $ value ) ) { $ value = json_decode ( $ value , true ) ; if ( $ value === null && strtolower ( $ value ) !== 'null' ) { $ value = 'Failed to decode JSON: ' . print_r ( $ value , true ) ; } } else { $ value = 'Invalid value for JSON: ' . print_r ( $ value , true ) ; } } return '<pre class="json-text">' . htmlentities ( stripslashes ( json_encode ( $ value , JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE ) ) ) . '</pre>' ; break ; } return $ value ; }
1388	protected function resourceDoesNotSupportClientIds ( string $ type , string $ path = '/data' ) : void { $ this -> errors -> add ( $ this -> translator -> resourceDoesNotSupportClientIds ( $ type , $ path ) ) ; }
6556	public function log ( $ msg , $ logLevel = null ) { $ helper = new FormatterHelper ( ) ; $ style = $ this -> mapLogLevelToStyle ( $ logLevel ) ; $ this -> getOutput ( ) -> writeln ( $ logLevel ? $ helper -> formatBlock ( $ msg , $ style ) : $ msg ) ; if ( $ logLevel && $ systemLogger = $ this -> getSystemLogger ( ) ) { $ systemLogger -> log ( $ logLevel , $ msg ) ; } }
6094	public function isUtf8 ( ) { $ pattern = array ( ) ; $ pattern [ ] = "[\xC2-\xDF][\x80-\xBF]" ; $ pattern [ ] = "\xE0[\xA0-\xBF][\x80-\xBF]" ; $ pattern [ ] = "[\xE1-\xEC\xEE\xEF][\x80-\xBF]{2}" ; $ pattern [ ] = "\xED[\x80-\x9F][\x80-\xBF]" ; $ pattern [ ] = "\xF0[\x90-\xBF][\x80-\xBF]{2}" ; $ pattern [ ] = "[\xF1-\xF3][\x80-\xBF]{3}" ; $ pattern [ ] = "\xF4[\x80-\x8F][\x80-\xBF]{2}" ; return preg_match ( "%(?:" . implode ( "|" , $ pattern ) . ")+%xs" , $ this -> string ) ; }
1231	public function resolveOptions ( array $ configuration ) { foreach ( $ configuration as $ key => $ value ) { if ( isset ( $ this -> definitions [ $ key ] ) ) { $ def = $ this -> definitions [ $ key ] ; $ this -> checkType ( $ def [ 'valid' ] , $ key , $ value ) ; if ( isset ( $ def [ 'fn' ] ) ) { $ def [ 'fn' ] ( $ configuration [ $ key ] , $ configuration ) ; } } } return $ configuration ; }
11999	static protected function phalconQuery ( $ modelName , $ field , $ generate ) { $ return = \ Phalcon \ Mvc \ Model :: query ( ) -> setModelName ( $ modelName ) -> where ( "$field = :value:" ) -> bind ( array ( 'value' => $ generate ) ) -> execute ( ) ; return ( boolean ) $ return -> count ( ) ; }
5742	public function getParserForContentType ( $ contentType ) { if ( 0 !== stripos ( $ contentType , 'multipart/' ) ) { return null ; } list ( $ mime , $ boundary ) = $ this -> parseContentType ( $ contentType ) ; $ parser = new MultipartParser ( ) ; $ parser -> setBoundary ( $ boundary ) ; return $ parser ; }
11458	public function batchPageSummary ( $ timestamp , $ pageIndex ) { $ params = [ 'date' => $ timestamp , 'page_index' => $ pageIndex , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_PAGE_LIST , $ params ] ) ; }
6906	public function addExtraRecipient ( Recipient $ recipient ) { if ( ! $ this -> extraRecipients -> contains ( $ recipient ) ) { $ this -> extraRecipients -> add ( $ recipient ) ; } return $ this ; }
9764	function equal ( $ value ) : self { if ( $ this -> hasFlag ( 'file' ) ) { if ( $ this -> hasFlag ( 'negate' ) ) assertFileNotEquals ( $ value , $ this -> target , $ this -> message ) ; else assertFileEquals ( $ value , $ this -> target , $ this -> message ) ; return $ this ; } $ target = $ this -> hasFlag ( 'length' ) ? $ this -> getLength ( $ this -> target ) : $ this -> target ; return $ this -> expect ( $ target , equalTo ( $ value ) ) ; }
7364	protected function updateInvoiceTotal ( SaleInterface $ sale ) { if ( ! $ sale instanceof InvoiceSubjectInterface ) { return false ; } $ changed = false ; $ invoice = $ this -> invoiceCalculator -> calculateInvoiceTotal ( $ sale ) ; if ( 0 != Money :: compare ( $ invoice , $ sale -> getInvoiceTotal ( ) , $ sale -> getCurrency ( ) -> getCode ( ) ) ) { $ sale -> setInvoiceTotal ( $ invoice ) ; $ changed = true ; } $ credit = $ this -> invoiceCalculator -> calculateCreditTotal ( $ sale ) ; if ( 0 != Money :: compare ( $ credit , $ sale -> getCreditTotal ( ) , $ sale -> getCurrency ( ) -> getCode ( ) ) ) { $ sale -> setCreditTotal ( $ credit ) ; $ changed = true ; } return $ changed ; }
2968	protected function pickMetadata ( $ data ) { $ metadata = [ ] ; if ( ArrayUtils :: has ( $ data , 'rows' ) ) { $ metadata = ArrayUtils :: omit ( $ data , 'rows' ) ; } else if ( ArrayUtils :: has ( $ data , 'meta' ) ) { $ metadata = ArrayUtils :: get ( $ data , 'meta' ) ; } return new Entry ( $ metadata ) ; }
9078	private static function parseContextPrefix ( Request & $ request , $ serverVars = array ( ) ) { if ( isset ( $ serverVars [ 'CONTEXT_PREFIX' ] ) && $ serverVars [ 'CONTEXT_PREFIX' ] != '' ) { $ request -> setContextPrefix ( $ serverVars [ 'CONTEXT_PREFIX' ] . '/' ) ; } elseif ( isset ( $ serverVars [ 'REDIRECT_BASE' ] ) ) { $ request -> setContextPrefix ( $ serverVars [ 'REDIRECT_BASE' ] ) ; } elseif ( isset ( $ serverVars [ 'SCRIPT_FILENAME' ] ) && isset ( $ serverVars [ 'SCRIPT_NAME' ] ) ) { if ( isset ( $ serverVars [ 'HTTP_HOST' ] ) ) { $ scriptName = preg_replace ( '/^.+[\\\\\\/]/' , '' , $ serverVars [ 'SCRIPT_FILENAME' ] ) ; $ request -> contextPrefix = str_replace ( $ scriptName , '' , $ serverVars [ 'SCRIPT_NAME' ] ) ; } } }
8009	protected function processKey ( $ raw_key ) { $ key = $ raw_key ; if ( $ this -> expand_and_normalize_keys ) { $ key = self :: expand56BitKeyTo64BitKey ( $ key , true ) ; } return $ key ; }
6740	public function front ( ) { add_action ( 'wp' , function ( ) { App :: setCurrentID ( 'EFG' ) ; if ( App :: main ( ) -> is_single ( ) && ! is_preview ( ) ) { $ this -> add_scripts ( 'customRatingGrifus' ) ; $ this -> add_styles ( ) ; } elseif ( is_home ( ) || is_category ( ) || is_archive ( ) || is_search ( ) ) { $ this -> add_scripts ( 'customRatingGrifusHome' ) ; } } ) ; }
3409	public function setLockPath ( string $ path ) : Application { if ( ! is_dir ( $ path ) ) { ( new Filesystem ( ) ) -> mkdir ( $ path ) ; } if ( ! $ realpath = realpath ( $ path ) ) { throw new \ InvalidArgumentException ( "The directory (" . $ path . ") is unavailable" ) ; } $ this -> lockPath = $ realpath ; return $ this ; }
8503	public function setGetCompetitivePricingForASINResult ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'GetCompetitivePricingForASINResult' ] [ 'FieldValue' ] = $ value ; return $ this ; }
6735	public function getMiddleware ( $ name ) : Middleware { if ( ! array_key_exists ( $ name , $ this -> namedMiddleware ) ) { throw new \ UnexpectedValueException ( "No middleware registered under name '{$name}'" ) ; } return $ this -> namedMiddleware [ $ name ] ; }
9238	private function getTextualPath ( array $ path , Vertex $ startVertex ) { $ currentVertex = $ startVertex ; $ currentTable = $ currentVertex -> getId ( ) ; $ textPath = $ currentTable ; foreach ( $ path as $ edge ) { if ( $ fk = $ edge -> getAttribute ( 'fk' ) ) { if ( $ fk -> getForeignTableName ( ) == $ currentTable ) { $ currentTable = $ fk -> getLocalTable ( ) -> getName ( ) ; $ isForward = false ; } else { $ currentTable = $ fk -> getForeignTableName ( ) ; $ isForward = true ; } $ columns = implode ( ',' , $ fk -> getLocalColumns ( ) ) ; $ textPath .= ' ' . ( ! $ isForward ? '<' : '' ) ; $ textPath .= '--(' . $ columns . ')--' ; $ textPath .= ( $ isForward ? '>' : '' ) . ' ' ; $ textPath .= $ currentTable ; } elseif ( $ junctionTable = $ edge -> getAttribute ( 'junction' ) ) { $ junctionFks = array_values ( $ junctionTable -> getForeignKeys ( ) ) ; $ fk = $ junctionFks [ 0 ] ; if ( $ fk -> getForeignTableName ( ) == $ currentTable ) { $ currentTable = $ junctionFks [ 1 ] -> getForeignTableName ( ) ; } else { $ currentTable = $ fk -> getForeignTableName ( ) ; } $ textPath .= ' <=(' . $ junctionTable -> getName ( ) . ')=> ' . $ currentTable ; } else { throw new SchemaAnalyzerException ( 'Unexpected edge. We should have a fk or a junction attribute.' ) ; } } return $ textPath ; }
9732	public function writeFont ( ) { $ font_outline = 0 ; $ font_shadow = 0 ; $ icv = $ this -> colorIndex ; if ( $ this -> font -> getSuperscript ( ) ) { $ sss = 1 ; } elseif ( $ this -> font -> getSubscript ( ) ) { $ sss = 2 ; } else { $ sss = 0 ; } $ bFamily = 0 ; $ bCharSet = \ PhpOffice \ PhpSpreadsheet \ Shared \ Font :: getCharsetFromFontName ( $ this -> font -> getName ( ) ) ; $ record = 0x31 ; $ reserved = 0x00 ; $ grbit = 0x00 ; if ( $ this -> font -> getItalic ( ) ) { $ grbit |= 0x02 ; } if ( $ this -> font -> getStrikethrough ( ) ) { $ grbit |= 0x08 ; } if ( $ font_outline ) { $ grbit |= 0x10 ; } if ( $ font_shadow ) { $ grbit |= 0x20 ; } $ data = pack ( 'vvvvvCCCC' , $ this -> font -> getSize ( ) * 20 , $ grbit , $ icv , self :: mapBold ( $ this -> font -> getBold ( ) ) , $ sss , self :: mapUnderline ( $ this -> font -> getUnderline ( ) ) , $ bFamily , $ bCharSet , $ reserved ) ; $ data .= StringHelper :: UTF8toBIFF8UnicodeShort ( $ this -> font -> getName ( ) ) ; $ length = strlen ( $ data ) ; $ header = pack ( 'vv' , $ record , $ length ) ; return $ header . $ data ; }
8250	protected function passwordRehash ( $ username , Password $ password ) { $ userData = $ this -> storage -> getUserByName ( $ username ) ; try { $ this -> userDataEncodePassword ( $ userData , $ password ) ; } catch ( \ PicoAuth \ Security \ Password \ Encoder \ EncoderException $ e ) { $ this -> session -> addFlash ( "error" , "Please set a new password." ) ; $ this -> picoAuth -> getContainer ( ) -> get ( 'PasswordReset' ) -> startPasswordResetSession ( $ username ) ; $ this -> picoAuth -> redirectToPage ( "password_reset" ) ; } $ this -> storage -> saveUser ( $ username , $ userData ) ; }
1485	public function prepend ( Decoding ... $ decodings ) : self { $ copy = clone $ this ; array_unshift ( $ copy -> stack , ... $ decodings ) ; return $ copy ; }
6941	private function getPurchaseCost ( Model \ SaleItemInterface $ item ) { if ( null === $ subject = $ this -> subjectHelper -> resolve ( $ item ) ) { return null ; } $ currency = $ item -> getSale ( ) -> getCurrency ( ) -> getCode ( ) ; if ( null !== $ cost = $ this -> purchaseCostGuesser -> guess ( $ subject , $ currency ) ) { return $ cost ; } return null ; }
11607	public function actionProfile ( ) { $ model = $ this -> finder -> findProfileById ( \ Yii :: $ app -> user -> identity -> getId ( ) ) ; $ this -> performAjaxValidation ( $ model ) ; if ( $ model -> load ( \ Yii :: $ app -> request -> post ( ) ) && $ model -> save ( ) ) { \ Yii :: $ app -> getSession ( ) -> setFlash ( 'success' , \ Yii :: t ( 'user' , 'Your profile has been updated' ) ) ; return $ this -> refresh ( ) ; } return $ this -> render ( 'profile' , [ 'model' => $ model , ] ) ; }
4008	public function collectMetaModelTableNames ( CollectMetaModelTableNamesEvent $ event ) { if ( $ this -> tableNamesCollected ) { $ event -> addMetaModelNames ( $ this -> tableNames ) ; return ; } $ tables = $ this -> database -> createQueryBuilder ( ) -> select ( '*' ) -> from ( 'tl_metamodel' ) -> orderBy ( 'sorting' ) -> execute ( ) -> fetchAll ( \ PDO :: FETCH_ASSOC ) ; foreach ( $ tables as $ table ) { $ this -> tableNames [ $ table [ 'id' ] ] = $ table [ 'tableName' ] ; } $ event -> addMetaModelNames ( $ this -> tableNames ) ; $ this -> tableNamesCollected = true ; }
11595	private function getPageId ( ) { if ( preg_match ( '/\/page\/(\w+)$/' , $ this -> name , $ matches ) ) { $ id = $ matches [ 1 ] ; } else { $ id = $ this -> environment -> getRequestHelper ( ) -> getIdentifierParam ( 'id' , null , true ) ; } return $ id ; }
871	public static function getDisplayableAllowedValues ( FixerOptionInterface $ option ) { $ allowed = $ option -> getAllowedValues ( ) ; if ( null !== $ allowed ) { $ allowed = array_filter ( $ allowed , static function ( $ value ) { return ! ( $ value instanceof \ Closure ) ; } ) ; usort ( $ allowed , static function ( $ valueA , $ valueB ) { if ( $ valueA instanceof AllowedValueSubset ) { return - 1 ; } if ( $ valueB instanceof AllowedValueSubset ) { return 1 ; } return strcasecmp ( self :: toString ( $ valueA ) , self :: toString ( $ valueB ) ) ; } ) ; if ( 0 === \ count ( $ allowed ) ) { $ allowed = null ; } } return $ allowed ; }
8400	public function button ( Environment $ environment , $ link , $ button , $ size = 'md' , $ iconDisplay = 'true' , $ location = 'right' , $ label = null , $ userStyle = null ) { extract ( $ this -> toolbarService -> defineButton ( $ button ) ) ; return $ environment -> render ( '@c975LToolbar/buttonText.html.twig' , array ( 'link' => $ link , 'style' => $ style , 'size' => $ size , 'button' => $ button , 'icon' => $ icon , 'label' => $ label , 'iconDisplay' => $ iconDisplay , 'location' => $ location , ) ) ; }
5728	public function Field ( $ properties = array ( ) ) { Requirements :: css ( BETTER_BUTTONS_DIR . '/css/dropdown_form_action.css' ) ; Requirements :: javascript ( BETTER_BUTTONS_DIR . '/javascript/dropdown_form_action.js' ) ; $ this -> setAttribute ( 'data-form-action-dropdown' , '#' . $ this -> DropdownID ( ) ) ; return parent :: Field ( ) ; }
848	public function getNonWhitespaceSibling ( $ index , $ direction , $ whitespaces = null ) { while ( true ) { $ index += $ direction ; if ( ! $ this -> offsetExists ( $ index ) ) { return null ; } $ token = $ this [ $ index ] ; if ( ! $ token -> isWhitespace ( $ whitespaces ) ) { return $ index ; } } }
6472	public function getBestEncodingMatch ( IMediaTypeFormatter $ formatter , array $ acceptCharsetHeaders , ? MediaTypeHeaderValue $ mediaTypeHeader ) : ? string { $ rankedAcceptCharsetHeaders = $ this -> rankAcceptCharsetHeaders ( $ acceptCharsetHeaders ) ; foreach ( $ rankedAcceptCharsetHeaders as $ acceptCharsetHeader ) { foreach ( $ formatter -> getSupportedEncodings ( ) as $ supportedEncoding ) { $ charset = $ acceptCharsetHeader -> getCharset ( ) ; if ( $ charset === '*' || strcasecmp ( $ charset , $ supportedEncoding ) === 0 ) { return $ supportedEncoding ; } } } if ( $ mediaTypeHeader === null || $ mediaTypeHeader -> getCharset ( ) === null ) { return null ; } foreach ( $ formatter -> getSupportedEncodings ( ) as $ supportedEncoding ) { $ charset = $ mediaTypeHeader -> getCharset ( ) ; if ( $ charset === '*' || strcasecmp ( $ charset , $ supportedEncoding ) === 0 ) { return $ supportedEncoding ; } } return null ; }
3074	public function getRubrics ( RunnerServiceContext $ context , AssessmentItemRef $ itemRef = null ) { $ session = $ context -> getTestSession ( ) ; $ routeItem = null ; if ( ! is_null ( $ itemRef ) ) { try { $ routeItem = $ session -> getRoute ( ) -> getRouteItemsByAssessmentItemRef ( $ itemRef ) ; if ( $ routeItem ) { $ routeItem = $ routeItem [ 0 ] ; } } catch ( OutOfBoundsException $ obe ) { \ common_Logger :: d ( "Could not retrieve the route for item '${itemRef}'." ) ; } } else { $ routeItem = $ session -> getRoute ( ) -> current ( ) ; } return implode ( '' , $ this -> getRubricBlock ( $ routeItem , $ session , $ context -> getCompilationDirectory ( ) ) ) ; }
5150	protected function getEmailRecipients ( $ email ) { $ recipients = $ email -> Headers -> to . ' ' . $ email -> Headers -> cc ; if ( $ email -> Headers -> bcc != NULL ) { $ recipients .= ' ' . $ email -> Headers -> bcc ; } return $ recipients ; }
11255	public function call ( string $ class ) : void { $ files = $ this -> all ( $ class ) ; if ( count ( $ files ) < 1 ) { throw InvalidArgumentException :: forNotFoundSeeder ( ) ; } foreach ( $ files as [ $ file , $ content ] ) { $ this -> load ( $ content ) ; $ this -> resolve ( $ file [ 'filename' ] ) -> run ( ) ; } }
5222	public function hasProperty ( $ name ) { if ( $ this -> properties -> containValue ( $ this -> environment , $ name ) ) { return true ; } return $ this -> properties -> containValue ( 'config' , $ name ) ; }
1543	protected function cursor ( EncodingParametersInterface $ parameters ) { return Cursor :: create ( ( array ) $ parameters -> getPaginationParameters ( ) , $ this -> before , $ this -> after , $ this -> limit ) ; }
8473	public function warning ( $ scope , $ message , $ context = [ ] , $ config = [ ] ) { return $ this -> write ( 'warning' , $ scope , $ message , $ context , $ config ) ; }
10526	public function setFieldFromData ( $ name ) { $ value = $ this -> getFieldFormData ( $ name ) ; return $ this -> setFieldValue ( $ name , $ value ) ; }
6130	protected function getCorpusName ( ) { if ( $ this -> currObj instanceof Channel && $ this -> currObj -> isSpacer ( ) ) { if ( $ this -> currObj -> spacerGetType ( ) != TeamSpeak3 :: SPACER_CUSTOM ) { return "" ; } $ string = $ this -> currObj [ "channel_name" ] -> section ( "]" , 1 , 99 ) ; if ( $ this -> currObj -> spacerGetAlign ( ) == TeamSpeak3 :: SPACER_ALIGN_REPEAT ) { $ string -> resize ( 30 , $ string ) ; } return htmlspecialchars ( $ string ) ; } if ( $ this -> currObj instanceof Client ) { $ before = array ( ) ; $ behind = array ( ) ; foreach ( $ this -> currObj -> memberOf ( ) as $ group ) { if ( $ group -> getProperty ( "namemode" ) == TeamSpeak3 :: GROUP_NAMEMODE_BEFORE ) { $ before [ ] = "[" . htmlspecialchars ( $ group [ "name" ] ) . "]" ; } elseif ( $ group -> getProperty ( "namemode" ) == TeamSpeak3 :: GROUP_NAMEMODE_BEHIND ) { $ behind [ ] = "[" . htmlspecialchars ( $ group [ "name" ] ) . "]" ; } } return implode ( "" , $ before ) . " " . htmlspecialchars ( $ this -> currObj ) . " " . implode ( "" , $ behind ) ; } return htmlspecialchars ( $ this -> currObj ) ; }
12217	private function register ( ) { ini_set ( 'display_errors' , false ) ; if ( $ this -> displayErrors ) { ini_set ( 'display_errors' , true ) ; } register_shutdown_function ( [ $ this , 'shutdownHandler' ] ) ; set_error_handler ( [ $ this , 'errorHandler' ] ) ; set_exception_handler ( [ $ this , 'exceptionHandler' ] ) ; }
9855	protected function storeBof ( $ type ) { $ record = 0x0809 ; $ length = 0x0010 ; $ unknown = pack ( 'VV' , 0x000100D1 , 0x00000406 ) ; $ build = 0x0DBB ; $ year = 0x07CC ; $ version = 0x0600 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vvvv' , $ version , $ type , $ build , $ year ) ; $ this -> append ( $ header . $ data . $ unknown ) ; }
7740	public function validate ( $ entity ) { if ( ! $ this -> container -> has ( 'validator' ) ) { throw new \ LogicException ( 'The validator service is not available.' ) ; } $ errors = $ this -> container -> get ( 'validator' ) -> validate ( $ entity ) ; if ( count ( $ errors ) === 0 ) { return false ; } return new JsonLdResponse ( '{ "error": "Validation error" }' , 400 ) ; }
7124	protected function getMessageFromEvent ( ResourceEventInterface $ event ) { $ message = $ event -> getResource ( ) ; if ( ! $ message instanceof TicketMessageInterface ) { throw new UnexpectedValueException ( "Expected instance of " . TicketMessageInterface :: class ) ; } return $ message ; }
4239	public function onBootstrap ( ) { if ( $ this -> debug -> parentInstance ) { return ; } $ collectWas = $ this -> debug -> setCfg ( 'collect' , true ) ; $ this -> debug -> groupSummary ( ) ; $ this -> debug -> group ( 'environment' , $ this -> debug -> meta ( array ( 'hideIfEmpty' => true , 'level' => 'info' , ) ) ) ; $ this -> logPhpInfo ( ) ; $ this -> logServerVals ( ) ; $ this -> logRequest ( ) ; $ this -> debug -> groupEnd ( ) ; $ this -> debug -> groupEnd ( ) ; $ this -> debug -> setCfg ( 'collect' , $ collectWas ) ; }
5760	public function getObjects ( array $ whereColumnsInfo = null , string $ orderBy = null ) : array { $ permissions = [ ] ; foreach ( $ this -> selectArray ( null , $ whereColumnsInfo , $ orderBy ) as $ permissionArray ) { $ permissions [ ] = $ this -> buildPermission ( $ permissionArray [ 'id' ] , $ permissionArray [ 'title' ] , $ permissionArray [ 'description' ] , $ permissionArray [ 'active' ] , $ permissionArray [ 'created' ] , $ permissionArray [ 'roles' ] ) ; } return $ permissions ; }
8428	public function getFileIcon ( $ fileType , $ iconLib = 'cmti' ) { switch ( $ iconLib ) { case 'cmti' : { return $ this -> getCmtiFileIcon ( $ fileType ) ; } case 'fa' : { return $ this -> getFaFileIcon ( $ fileType ) ; } } }
3892	public function getFilterParameterNames ( \ DC_Table $ objDc ) { $ return = array ( ) ; $ filter = $ objDc -> activeRecord -> metamodel_filtering ; if ( ! $ filter ) { return $ return ; } $ collection = $ this -> filterFactory -> createCollection ( $ filter ) ; return $ collection -> getParameterFilterNames ( ) ; }
3303	public function getClient ( ) { if ( empty ( $ this -> client ) || ! ( $ this -> client instanceof HttpClient ) ) { $ this -> client = new HttpClient ( ) ; } return $ this -> client ; }
1628	public function useDailyFiles ( $ path , $ days = 0 , $ level = 'debug' ) { foreach ( $ this -> loggers as $ logger ) { if ( $ logger instanceof Log ) { $ logger -> useDailyFiles ( $ path , $ days , $ level ) ; } } }
1232	public function offsetSet ( $ offset , $ value ) { self :: ensurePropertyType ( $ value ) ; if ( is_null ( $ offset ) ) { $ this -> data [ ] = $ value ; } else { $ this -> data [ $ offset ] = $ value ; } }
6415	public static function get ( IteratorAggregate $ iterable , int $ position ) { return Iterators :: get ( Iterators :: from ( $ iterable -> getIterator ( ) ) , $ position ) ; }
8182	public function getDuration ( ) { if ( $ this -> isRoot ( ) && $ this -> profiles ) { $ duration = 0 ; foreach ( $ this -> profiles as $ profile ) { $ duration += $ profile -> getDuration ( ) ; } return $ duration ; } return isset ( $ this -> ends [ 'wt' ] ) && isset ( $ this -> starts [ 'wt' ] ) ? $ this -> ends [ 'wt' ] - $ this -> starts [ 'wt' ] : 0 ; }
1126	public function isSelfOrDescendantOf ( $ other ) { return ( $ this -> getLeft ( ) >= $ other -> getLeft ( ) && $ this -> getLeft ( ) < $ other -> getRight ( ) && $ this -> inSameScope ( $ other ) ) ; }
10787	public function onlineHelpAction ( Request $ request ) { $ template = $ this -> searchService -> getOnlineHelp ( $ request -> getLocale ( ) , $ this -> getDefaultLocale ( ) ) ; return $ this -> render ( $ template ? : 'StingerSoftEntitySearchBundle:Help:no_help.html.twig' ) ; }
7773	protected function validateAgainstRule ( $ field , $ value , $ rule , array $ args ) { $ ruleToCall = $ this -> getRuleToCall ( $ rule ) ; $ passed = call_user_func_array ( $ ruleToCall , [ $ value , $ this -> input , $ args ] ) ; if ( ! $ passed ) { $ this -> handleError ( $ field , $ value , $ rule , $ args ) ; return $ this -> canSkipRule ( $ ruleToCall , $ value ) ; } return true ; }
12848	private function _getPage403 ( ) { var_dump ( debug_backtrace ( ) ) ; header ( "HTTP/1.0 403 Forbidden" ) ; if ( isset ( $ this -> _oRoutes -> e403 ) ) { $ this -> _oRoutes -> e403 -> route = '/' ; $ _SERVER [ 'REQUEST_URI' ] = '/' ; $ this -> _route ( $ this -> _oRoutes -> e403 , $ _SERVER [ 'REQUEST_URI' ] ) ; } exit ; }
10716	public function deleteMany ( ArrayAccess $ models ) { $ results = [ ] ; foreach ( $ models as $ model ) { $ results [ ] = $ this -> delete ( $ model ) ; } return $ this -> returnResults ( $ results ) ; }
7267	public function has ( $ forClass , $ forColumn = null ) { $ refTable = static :: tableName ( ) ; $ forTable = $ forClass :: tableName ( ) ; $ refColumn = static :: $ idColumn ; $ forColumn = $ forColumn ? : strtolower ( static :: modelName ( ) ) . "_id" ; $ rows = Db :: query ( " select F.* from $refTable as R, $forTable as F where R.$refColumn = F.$forColumn and R.$refColumn = :id " , [ "id" => $ this -> $ refColumn ] , static :: getDbName ( ) ) ; if ( $ rows === false ) return false ; if ( empty ( $ rows ) ) return null ; $ forModel = new $ forClass ; foreach ( $ rows [ 0 ] as $ col => $ val ) $ forModel -> $ col = $ forModel -> decodeValue ( $ val , $ col ) ; return $ forModel ; }
2578	protected function loadArnk ( Segment \ ArrivalUnknown $ segment ) { $ this -> travelProduct = new TravelProduct ( ) ; $ this -> travelProduct -> productDetails = new ProductDetails ( $ segment -> identification ) ; $ this -> messageAction = new MessageAction ( Business :: FUNC_ARNK ) ; }
6881	public function reverseTransform ( $ address ) { if ( null === $ address ) { return null ; } if ( ! $ address instanceof ShipmentAddress ) { throw new InvalidArgumentException ( "Expected instance of " . ShipmentAddress :: class ) ; } $ data = [ ] ; foreach ( $ this -> fields as $ field ) { $ value = $ this -> accessor -> getValue ( $ address , $ field ) ; if ( empty ( $ value ) ) { continue ; } if ( $ value instanceof CountryInterface ) { $ value = $ value -> getId ( ) ; } elseif ( $ value instanceof StateInterface ) { $ value = $ value -> getId ( ) ; } elseif ( $ value instanceof PhoneNumber ) { $ value = serialize ( $ value ) ; } $ data [ $ field ] = $ value ; } if ( empty ( $ data ) ) { return null ; } return $ data ; }
1024	private function getOperationRootType ( Schema $ schema , OperationDefinitionNode $ operation ) { switch ( $ operation -> operation ) { case 'query' : $ queryType = $ schema -> getQueryType ( ) ; if ( ! $ queryType ) { throw new Error ( 'Schema does not define the required query root type.' , [ $ operation ] ) ; } return $ queryType ; case 'mutation' : $ mutationType = $ schema -> getMutationType ( ) ; if ( ! $ mutationType ) { throw new Error ( 'Schema is not configured for mutations.' , [ $ operation ] ) ; } return $ mutationType ; case 'subscription' : $ subscriptionType = $ schema -> getSubscriptionType ( ) ; if ( ! $ subscriptionType ) { throw new Error ( 'Schema is not configured for subscriptions.' , [ $ operation ] ) ; } return $ subscriptionType ; default : throw new Error ( 'Can only execute queries, mutations and subscriptions.' , [ $ operation ] ) ; } }
4304	public function profileEnd ( $ name = null ) { $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) , array ( 'name' => null ) , array ( 'name' ) ) ; if ( $ meta [ 'name' ] === null ) { \ end ( $ this -> data [ 'profileInstances' ] ) ; $ meta [ 'name' ] = \ key ( $ this -> data [ 'profileInstances' ] ) ; } $ name = $ meta [ 'name' ] ; if ( isset ( $ this -> data [ 'profileInstances' ] [ $ name ] ) ) { $ instance = $ this -> data [ 'profileInstances' ] [ $ name ] ; $ data = $ instance -> end ( ) ; $ caption = 'Profile \'' . $ name . '\' Results' ; if ( $ data ) { $ args = array ( $ data ) ; $ meta [ 'sortable' ] = true ; $ meta [ 'caption' ] = $ caption ; $ meta [ 'totalCols' ] = array ( 'ownTime' ) ; $ meta [ 'columns' ] = array ( ) ; } else { $ args = array ( $ caption , 'no data' ) ; } unset ( $ this -> data [ 'profileInstances' ] [ $ name ] ) ; } else { $ args = array ( $ name !== null ? 'profileEnd: No such Profile: ' . $ name : 'profileEnd: Not currently profiling' ) ; } $ this -> appendLog ( __FUNCTION__ , $ args , $ meta ) ; }
704	public function setDefaultRoles ( $ roles ) { if ( is_array ( $ roles ) ) { $ this -> defaultRoles = $ roles ; } elseif ( $ roles instanceof \ Closure ) { $ roles = call_user_func ( $ roles ) ; if ( ! is_array ( $ roles ) ) { throw new InvalidValueException ( 'Default roles closure must return an array' ) ; } $ this -> defaultRoles = $ roles ; } else { throw new InvalidArgumentException ( 'Default roles must be either an array or a callable' ) ; } }
3372	private function getFormFactory ( ContainerInterface $ services ) { $ elements = null ; if ( $ services -> has ( 'FormElementManager' ) ) { $ elements = $ services -> get ( 'FormElementManager' ) ; } return new Factory ( $ elements ) ; }
10527	public function getValue ( ) { static $ ip = null ; if ( is_null ( $ ip ) ) { $ ip = $ this -> getIpAddressFromProxy ( ) ; if ( isset ( $ _SERVER [ 'REMOTE_ADDR' ] ) ) { $ ip = $ _SERVER [ 'REMOTE_ADDR' ] ; } } return $ ip ; }
4010	public function getMaxPaginationLinks ( ) { if ( null === $ this -> maxPaginationLinks ) { $ this -> setMaxPaginationLinks ( \ Config :: get ( 'maxPaginationLinks' ) ) ; } return $ this -> maxPaginationLinks ; }
296	public function isAttributeChanged ( $ name , $ identical = true ) { if ( isset ( $ this -> _attributes [ $ name ] , $ this -> _oldAttributes [ $ name ] ) ) { if ( $ identical ) { return $ this -> _attributes [ $ name ] !== $ this -> _oldAttributes [ $ name ] ; } return $ this -> _attributes [ $ name ] != $ this -> _oldAttributes [ $ name ] ; } return isset ( $ this -> _attributes [ $ name ] ) || isset ( $ this -> _oldAttributes [ $ name ] ) ; }
46	public function dispatchInstallerEvent ( $ eventName , $ devMode , PolicyInterface $ policy , Pool $ pool , CompositeRepository $ installedRepo , Request $ request , array $ operations = array ( ) ) { return $ this -> doDispatch ( new InstallerEvent ( $ eventName , $ this -> composer , $ this -> io , $ devMode , $ policy , $ pool , $ installedRepo , $ request , $ operations ) ) ; }
995	private function getDeprecationReason ( $ node ) { $ deprecated = Values :: getDirectiveValues ( Directive :: deprecatedDirective ( ) , $ node ) ; return $ deprecated [ 'reason' ] ?? null ; }
4427	protected function askForChoiceData ( $ optionIdentifier , $ optionName , array $ choices , $ defaultValue ) { $ optionValue = $ this -> input -> getOption ( $ optionIdentifier ) ; $ optionValue = ! empty ( $ optionValue ) ? $ optionValue : $ defaultValue ; $ question = $ this -> getChoiceQuestion ( $ optionName , $ optionValue , $ choices ) ; $ optionValue = $ this -> questionHelper -> ask ( $ this -> input , $ this -> output , $ question ) ; $ this -> input -> setOption ( $ optionIdentifier , $ optionValue ) ; return $ optionValue ; }
9680	public function getColumnDisplayName ( $ columnName ) { return isset ( $ this -> columnDisplayNames [ $ columnName ] ) ? $ this -> columnDisplayNames [ $ columnName ] : $ columnName ; }
10612	public function confirmedAction ( ) { $ user = $ this -> getUser ( ) ; if ( ! is_object ( $ user ) || ! $ user instanceof UserInterface ) { throw $ this -> createAccessDeniedException ( 'This user does not have access to this section.' ) ; } return $ this -> render ( "@MikyUser/Frontend/Registration/confirmed.html.twig" , array ( 'user' => $ user , ) ) ; }
3675	private function collectAttributeFactories ( $ container ) { $ attributeFactory = $ container -> getDefinition ( 'metamodels.attribute_factory' ) ; foreach ( array_keys ( $ container -> findTaggedServiceIds ( self :: TAG_ATTRIBUTE_FACTORY ) ) as $ factory ) { $ attributeFactory -> addMethodCall ( 'addTypeFactory' , [ new Reference ( $ factory ) ] ) ; } }
5638	public function shouldInvoke ( $ test_case , $ method ) { if ( $ this -> shouldRunTest ( $ test_case , $ method ) ) { return $ this -> reporter -> shouldInvoke ( $ test_case , $ method ) ; } return false ; }
7061	private function setClasses ( array $ classes ) { if ( ! empty ( $ classes ) ) { $ this -> vars [ 'attr' ] [ 'class' ] = ' ' . trim ( implode ( ' ' , $ classes ) ) ; } else { unset ( $ this -> vars [ 'attr' ] [ 'class' ] ) ; } }
5379	protected function wrap ( $ text ) { $ text = str_replace ( "\r\r\n" , "\r\n" , str_replace ( "\n" , "\r\n" , $ text ) ) ; $ text = str_replace ( "\r\n\n" , "\r\n" , str_replace ( "\r" , "\r\n" , $ text ) ) ; if ( strncmp ( $ text , "\r\n" , strlen ( "\r\n" ) ) == 0 ) { $ text = substr ( $ text , strlen ( "\r\n" ) ) ; } if ( $ this -> wrapIsEnabled ( ) ) { return wordwrap ( $ text , ( integer ) $ this -> getAttribute ( 'cols' ) , "\r\n" ) ; } return $ text ; }
2308	public function setImportantPart ( array $ importantPart = null ) { if ( $ importantPart !== null ) { if ( ! isset ( $ importantPart [ 'x' ] ) || ! isset ( $ importantPart [ 'y' ] ) || ! isset ( $ importantPart [ 'width' ] ) || ! isset ( $ importantPart [ 'height' ] ) ) { throw new \ InvalidArgumentException ( 'Malformed array for setting the important part!' ) ; } $ this -> importantPart = array ( 'x' => max ( 0 , min ( $ this -> fileObj -> viewWidth - 1 , ( int ) $ importantPart [ 'x' ] ) ) , 'y' => max ( 0 , min ( $ this -> fileObj -> viewHeight - 1 , ( int ) $ importantPart [ 'y' ] ) ) , ) ; $ this -> importantPart [ 'width' ] = max ( 1 , min ( $ this -> fileObj -> viewWidth - $ this -> importantPart [ 'x' ] , ( int ) $ importantPart [ 'width' ] ) ) ; $ this -> importantPart [ 'height' ] = max ( 1 , min ( $ this -> fileObj -> viewHeight - $ this -> importantPart [ 'y' ] , ( int ) $ importantPart [ 'height' ] ) ) ; } else { $ this -> importantPart = null ; } return $ this ; }
2360	public static function findPublishedById ( $ intId , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = array ( "$t.id=?" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.disable=''" ; } return static :: findOneBy ( $ arrColumns , $ intId , $ arrOptions ) ; }
11546	public function changeSecurityQuestion ( $ data ) { if ( ! ( $ user = $ this -> hydrate ( $ data , $ this -> getChangeSecurityQuestionForm ( ) ) ) ) { return ; } $ eventManager = $ this -> getEventManager ( ) ; $ eventManager -> trigger ( __METHOD__ , $ this , $ user ) ; $ this -> getMapper ( ) -> update ( $ user ) -> save ( ) ; $ eventManager -> trigger ( __METHOD__ . '.post' , $ this , $ user ) ; return $ user ; }
6868	protected function buildInvoicePayments ( SaleInterface $ sale ) { $ currency = $ sale -> getCurrency ( ) -> getCode ( ) ; $ payments = $ this -> buildPaymentList ( $ sale ) ; $ invoices = $ this -> buildInvoiceList ( $ sale ) ; foreach ( $ invoices as $ x => & $ i ) { $ oid = spl_object_id ( $ i [ 'invoice' ] ) ; $ this -> cache [ $ oid ] = [ ] ; foreach ( $ payments as $ y => & $ p ) { $ r = new IM \ InvoicePayment ( ) ; $ r -> setPayment ( $ p [ 'payment' ] ) ; $ c = Money :: compare ( $ i [ 'total' ] , $ p [ 'amount' ] , $ currency ) ; if ( 0 === $ c ) { $ r -> setAmount ( $ p [ 'amount' ] ) ; $ i [ 'total' ] = 0 ; $ p [ 'amount' ] = 0 ; unset ( $ payments [ $ y ] ) ; } elseif ( 1 === $ c ) { $ r -> setAmount ( $ p [ 'amount' ] ) ; $ i [ 'total' ] -= $ p [ 'amount' ] ; $ p [ 'amount' ] = 0 ; unset ( $ payments [ $ y ] ) ; } else { $ r -> setAmount ( $ i [ 'total' ] ) ; $ p [ 'amount' ] -= $ i [ 'total' ] ; $ i [ 'total' ] = 0 ; } $ this -> cache [ $ oid ] [ ] = $ r ; unset ( $ p ) ; } unset ( $ i ) ; } }
9583	public function addCachedRoute ( Route $ route ) { $ this -> routes -> attach ( $ route ) ; if ( $ name = $ route -> getName ( ) ) { $ this -> addNamedRoute ( $ name , $ route ) ; } }
11533	public static function readFile ( $ file ) { if ( ! file_exists ( $ file ) ) { return null ; } $ handle = fopen ( $ file , 'r' ) ; if ( ! self :: lockFile ( $ handle , LOCK_SH | LOCK_NB ) ) { $ exception = array ( "message" => 'exception_file_cannot_be_locked_for_reading' , "parameters" => array ( "%file%" => basename ( $ file ) , ) ) ; throw new RuntimeException ( json_encode ( $ exception ) ) ; } $ contents = file_get_contents ( $ file ) ; self :: unlockFile ( $ handle ) ; return $ contents ; }
11981	public function isAccessible ( AcquirerInterface $ acquirer , ResourceInterface $ resource ) { if ( ! $ resource -> isLocked ( ) ) { return true ; } $ lock = $ resource -> getLock ( ) ; if ( $ lock instanceof ExpiringLockInterface and $ this -> isLockExpired ( $ lock ) ) { $ this -> release ( $ lock ) ; return true ; } return $ lock -> getAcquirer ( ) -> getIdentifier ( ) === $ acquirer -> getIdentifier ( ) ; }
7955	public function setUnblockSpam ( $ ipblock , $ ipv4 ) { if ( ! $ ipblock ) throw new BadMethodCallException ( 'Parameter $ipblock is missing.' ) ; if ( ! $ ipv4 ) throw new BadMethodCallException ( 'Parameter $ipv4 is missing.' ) ; try { $ r = $ this -> post ( 'ip/' . urlencode ( $ ipblock ) . '/spam/' . $ ipv4 . '/unblock' ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new IpException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
1032	private function completeValue ( Type $ returnType , $ fieldNodes , ResolveInfo $ info , $ path , & $ result ) { $ promise = $ this -> getPromise ( $ result ) ; if ( $ promise ) { return $ promise -> then ( function ( & $ resolved ) use ( $ returnType , $ fieldNodes , $ info , $ path ) { return $ this -> completeValue ( $ returnType , $ fieldNodes , $ info , $ path , $ resolved ) ; } ) ; } if ( $ result instanceof Exception || $ result instanceof Throwable ) { throw $ result ; } if ( $ returnType instanceof NonNull ) { $ completed = $ this -> completeValue ( $ returnType -> getWrappedType ( ) , $ fieldNodes , $ info , $ path , $ result ) ; if ( $ completed === null ) { throw new InvariantViolation ( 'Cannot return null for non-nullable field ' . $ info -> parentType . '.' . $ info -> fieldName . '.' ) ; } return $ completed ; } if ( $ result === null ) { return null ; } if ( $ returnType instanceof ListOfType ) { return $ this -> completeListValue ( $ returnType , $ fieldNodes , $ info , $ path , $ result ) ; } if ( $ returnType !== $ this -> exeContext -> schema -> getType ( $ returnType -> name ) ) { $ hint = '' ; if ( $ this -> exeContext -> schema -> getConfig ( ) -> typeLoader ) { $ hint = sprintf ( 'Make sure that type loader returns the same instance as defined in %s.%s' , $ info -> parentType , $ info -> fieldName ) ; } throw new InvariantViolation ( sprintf ( 'Schema must contain unique named types but contains multiple types named "%s". %s ' . '(see http://webonyx.github.io/graphql-php/type-system/#type-registry).' , $ returnType , $ hint ) ) ; } if ( $ returnType instanceof LeafType ) { return $ this -> completeLeafValue ( $ returnType , $ result ) ; } if ( $ returnType instanceof AbstractType ) { return $ this -> completeAbstractValue ( $ returnType , $ fieldNodes , $ info , $ path , $ result ) ; } if ( $ returnType instanceof ObjectType ) { return $ this -> completeObjectValue ( $ returnType , $ fieldNodes , $ info , $ path , $ result ) ; } throw new RuntimeException ( sprintf ( 'Cannot complete value of unexpected type "%s".' , $ returnType ) ) ; }
8684	public static function fromRecursive ( $ iterable ) { $ arr = static :: from ( $ iterable ) ; foreach ( $ arr as $ key => $ value ) { if ( $ value instanceof \ stdClass || \ is_iterable ( $ value ) ) { $ value = static :: fromRecursive ( $ value ) ; } $ arr [ $ key ] = $ value ; } return $ arr ; }
12056	public function getLabels ( ) { $ labels = [ ] ; $ labels [ 'delete_object' ] = [ 'short' => 'Delete ' . $ this -> object -> objectType -> title -> getSingular ( true ) , 'long' => 'delete the ' . $ this -> object -> objectType -> title -> getSingular ( false ) . ' <em>' . $ this -> object -> descriptor . '</em>' , 'past' => $ this -> object -> objectType -> title -> getSingular ( false ) . ' <em>' . $ this -> object -> descriptor . '</em> has been deleted' , 'options' => [ 'class' => 'btn-danger' ] , 'response' => 'home' , ] ; $ labels [ 'archive_object' ] = [ 'short' => 'Archive ' . $ this -> object -> objectType -> title -> getSingular ( true ) , 'long' => 'archive the ' . $ this -> object -> objectType -> title -> getSingular ( false ) . ' <em>' . $ this -> object -> descriptor . '</em>' , 'past' => $ this -> object -> objectType -> title -> getSingular ( false ) . ' <em>' . $ this -> object -> descriptor . '</em> has been archived' , 'response' => 'refresh' , ] ; $ labels [ 'unarchive_object' ] = [ 'short' => 'Unarchive ' . $ this -> object -> objectType -> title -> getSingular ( true ) , 'long' => 'unarchive the ' . $ this -> object -> objectType -> title -> getSingular ( false ) . ' <em>' . $ this -> object -> descriptor . '</em>' , 'past' => $ this -> object -> objectType -> title -> getSingular ( false ) . ' <em>' . $ this -> object -> descriptor . '</em> has been unarchived' , 'response' => 'refresh' , ] ; if ( isset ( $ this -> relationshipWith ) ) { $ labels [ 'delete_relationship' ] = [ 'short' => 'Delete Relationship' , 'long' => 'delete the relationship between <em>' . $ this -> object -> descriptor . '</em> and <em>' . $ this -> relationshipWith -> descriptor . '</em>' , 'past' => 'the relationship between <em>' . $ this -> object -> descriptor . '</em> and <em>' . $ this -> relationshipWith -> descriptor . '</em> has been deleted' , 'options' => [ 'class' => 'btn-warning' ] , ] ; $ labels [ 'end_relationship' ] = [ 'short' => 'End Relationship' , 'long' => 'end the relationship between <em>' . $ this -> object -> descriptor . '</em> and <em>' . $ this -> relationshipWith -> descriptor . '</em>' , 'past' => 'the relationship between <em>' . $ this -> object -> descriptor . '</em> and <em>' . $ this -> relationshipWith -> descriptor . '</em> has been ended' , ] ; } return $ labels ; }
2022	public static function findFirstPublishedRootByHostAndLanguage ( $ strHost , $ varLanguage , array $ arrOptions = array ( ) ) { @ trigger_error ( 'Using PageModel::findFirstPublishedRootByHostAndLanguage() has been deprecated and will no longer work Contao 5.0.' , E_USER_DEPRECATED ) ; $ t = static :: $ strTable ; $ objDatabase = Database :: getInstance ( ) ; if ( \ is_array ( $ varLanguage ) ) { $ arrColumns = array ( "$t.type='root' AND ($t.dns=? OR $t.dns='')" ) ; if ( ! empty ( $ varLanguage ) ) { $ arrColumns [ ] = "($t.language IN('" . implode ( "','" , $ varLanguage ) . "') OR $t.fallback='1')" ; } else { $ arrColumns [ ] = "$t.fallback='1'" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.dns DESC" . ( ! empty ( $ varLanguage ) ? ", " . $ objDatabase -> findInSet ( "$t.language" , array_reverse ( $ varLanguage ) ) . " DESC" : "" ) . ", $t.sorting" ; } if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } return static :: findOneBy ( $ arrColumns , $ strHost , $ arrOptions ) ; } else { $ arrColumns = array ( "$t.type='root' AND ($t.dns=? OR $t.dns='') AND ($t.language=? OR $t.fallback='1')" ) ; $ arrValues = array ( $ strHost , $ varLanguage ) ; if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.dns DESC, $t.fallback" ; } if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } return static :: findOneBy ( $ arrColumns , $ arrValues , $ arrOptions ) ; } }
2252	protected function redirectToFrontendPage ( $ intPage , $ strArticle = null , $ blnReturn = false ) { if ( ( $ intPage = ( int ) $ intPage ) <= 0 ) { return '' ; } $ objPage = PageModel :: findWithDetails ( $ intPage ) ; if ( $ objPage === null ) { return '' ; } $ strParams = null ; if ( $ strArticle !== null && ( $ objArticle = ArticleModel :: findByAlias ( $ strArticle ) ) !== null ) { $ strParams = '/articles/' . ( ( $ objArticle -> inColumn != 'main' ) ? $ objArticle -> inColumn . ':' : '' ) . $ strArticle ; } $ strUrl = $ objPage -> getFrontendUrl ( $ strParams ) ; if ( strncmp ( $ strUrl , 'http://' , 7 ) !== 0 && strncmp ( $ strUrl , 'https://' , 8 ) !== 0 ) { $ strUrl = Environment :: get ( 'base' ) . $ strUrl ; } if ( ! $ blnReturn ) { $ this -> redirect ( $ strUrl ) ; } return $ strUrl ; }
6200	public function currentPath ( ) { $ request = preg_replace ( '!' . $ this -> uri . '(.*)$!i' , '$1' , $ _SERVER [ 'REQUEST_URI' ] ) ; if ( defined ( 'MOD_REWRITE' ) and MOD_REWRITE === true ) { if ( substr ( $ request , - 1 ) != '/' ) { $ request .= '/' ; } $ parseUrl = $ this -> parseUrl ( $ request ) ; $ gets = $ parseUrl [ 'sVars' ] ; } else { $ gets = $ _SERVER [ 'QUERY_STRING' ] ; } return $ gets ; }
1293	private function getTokenFromResponse ( array $ data ) : string { $ url = $ data [ 'nextSyncUrl' ] ?? $ data [ 'nextPageUrl' ] ; $ queryValues = [ ] ; \ parse_str ( \ parse_url ( $ url , \ PHP_URL_QUERY ) , $ queryValues ) ; return $ queryValues [ 'sync_token' ] ; }
5318	public function wait ( ) { $ this -> internalWait ( ) ; $ event = $ this -> isSuccessExit ( ) ? 'success' : 'error' ; $ this -> internalEmit ( 'exit' , $ this -> pid ) ; $ this -> internalEmit ( $ event ) ; return $ this ; }
6838	public function mapDatas ( $ kvs ) { foreach ( $ kvs as $ k => $ v ) { $ this -> mapData ( $ k , $ v ) ; } }
8850	public function rss ( ) { $ rss = new RSSFeed ( $ this -> getBlogPosts ( ) , $ this -> Link ( ) , $ this -> MetaTitle , $ this -> MetaDescription ) ; $ this -> extend ( 'updateRss' , $ rss ) ; return $ rss -> outputToBrowser ( ) ; }
9221	public function offsetExists ( $ offset ) { if ( ! isset ( $ this -> data [ $ offset ] ) ) { $ this -> requestAllPages ( ) ; } return isset ( $ this -> data [ $ offset ] ) ; }
2970	private function doSend ( MessageInterface $ message ) { $ content = $ this -> format ( $ message ) ; $ headers = $ this -> getHeaders ( ) ; $ files = $ this -> getFiles ( $ message ) ; if ( ! empty ( $ files ) ) { parse_str ( $ content , $ fields ) ; $ builder = new MultipartStreamBuilder ( ) ; foreach ( $ fields as $ name => $ value ) { if ( is_array ( $ value ) ) { foreach ( $ value as $ c ) { $ builder -> addResource ( $ name . '[]' , $ c ) ; } continue ; } $ builder -> addResource ( $ name , $ value ) ; } foreach ( $ files as $ key => $ items ) { foreach ( $ items as $ name => $ path ) { $ options = [ ] ; if ( ! is_numeric ( $ name ) ) { $ options [ 'filename' ] = $ name ; } $ value = fopen ( $ path , 'r' ) ; $ builder -> addResource ( $ key , $ value , $ options ) ; } } $ content = $ builder -> build ( ) ; $ headers [ 'Content-Type' ] = 'multipart/form-data; boundary="' . $ builder -> getBoundary ( ) . '"' ; } $ request = $ this -> getMessageFactory ( ) -> createRequest ( 'POST' , $ this -> getEndpoint ( ) , $ headers , $ content ) ; return $ this -> getHttpClient ( ) -> sendRequest ( $ request ) ; }
10657	public function getArrayCopyRec ( ) { $ ret = array ( ) ; $ it = $ this -> getIterator ( ) ; while ( $ it -> valid ( ) ) { if ( $ it -> current ( ) instanceof self ) { $ ret [ $ it -> key ( ) ] = $ it -> current ( ) -> getArrayCopyRec ( ) ; } else { $ ret [ $ it -> key ( ) ] = $ it -> current ( ) ; } $ it -> next ( ) ; } return $ ret ; }
1696	public static function findByIds ( $ arrIds ) { if ( empty ( $ arrIds ) || ! \ is_array ( $ arrIds ) ) { return null ; } $ objDatabase = Database :: getInstance ( ) ; $ arrIds = array_map ( '\intval' , $ arrIds ) ; $ objResult = $ objDatabase -> execute ( "SELECT *, (SELECT tstamp FROM tl_theme WHERE tl_theme.id=tl_style_sheet.pid) AS tstamp3, (SELECT MAX(tstamp) FROM tl_style WHERE tl_style.pid=tl_style_sheet.id) AS tstamp2, (SELECT COUNT(*) FROM tl_style WHERE tl_style.selector='@font-face' AND tl_style.invisible='' AND tl_style.pid=tl_style_sheet.id) AS hasFontFace FROM tl_style_sheet WHERE id IN (" . implode ( ',' , $ arrIds ) . ") ORDER BY " . $ objDatabase -> findInSet ( 'id' , $ arrIds ) ) ; return static :: createCollectionFromDbResult ( $ objResult , 'tl_style_sheet' ) ; }
1662	public function reply ( $ message ) { if ( is_string ( $ message ) ) { $ this -> messages [ ] = Text :: create ( ) -> text ( $ message ) -> setAgentVersion ( $ this -> agentVersion ) -> setRequestSource ( $ this -> requestSource ) ; if ( ! $ this -> doesSupportRichMessage ( ) ) { $ this -> text = $ message ; } } elseif ( $ message instanceof RichMessage ) { if ( ! $ this -> doesSupportRichMessage ( ) ) { $ this -> text = $ message -> getFallbackText ( ) ; } $ message -> setAgentVersion ( $ this -> agentVersion ) -> setRequestSource ( $ this -> requestSource ) ; $ this -> messages [ ] = $ message ; } elseif ( $ message instanceof Conversation ) { $ this -> messages [ ] = Payload :: create ( $ message -> render ( ) ) -> setAgentVersion ( $ this -> agentVersion ) -> setRequestSource ( $ this -> requestSource ) ; } return $ this ; }
3874	protected function removeEmptyDetailPages ( $ jumpTos ) { foreach ( $ jumpTos as $ jumpTo ) { $ event = new GetPageDetailsEvent ( $ jumpTo [ 'value' ] ) ; $ this -> getEventDispatcher ( ) -> dispatch ( ContaoEvents :: CONTROLLER_GET_PAGE_DETAILS , $ event ) ; $ pageDetails = $ event -> getPageDetails ( ) ; if ( $ pageDetails === null ) { continue ; } $ baseUrl = $ this -> getBaseUrl ( $ pageDetails ) ; if ( ( $ strKey = array_search ( $ baseUrl -> getUrl ( ) , $ this -> foundPages ) ) !== false ) { unset ( $ this -> foundPages [ $ strKey ] ) ; } $ baseUrl = $ this -> getBaseUrl ( $ pageDetails , null , true ) ; if ( ( $ strKey = array_search ( $ baseUrl -> getUrl ( ) , $ this -> foundPages ) ) !== false ) { unset ( $ this -> foundPages [ $ strKey ] ) ; } } }
1101	protected function parentId ( ) { switch ( $ this -> position ) { case 'root' : return NULL ; case 'child' : return $ this -> target -> getKey ( ) ; default : return $ this -> target -> getParentId ( ) ; } }
12258	public function getOrganizedCompilers ( ) { if ( NULL === $ this -> orderedCompilers ) { $ depCollection = new DependencyCollection ( false ) ; $ depCollection -> setAcceptsDuplicates ( false ) ; foreach ( $ this -> compilers as $ compiler ) { if ( $ compiler instanceof CompilerInterface ) { $ id = $ compiler -> getCompilerID ( ) ; $ deps = $ compiler -> getDependsOnCompilerIDs ( ) ; if ( $ deps ) $ depCollection -> add ( $ id , $ compiler , $ deps ) ; else $ depCollection -> add ( $ id , $ compiler ) ; } elseif ( $ compiler instanceof CompilerFactoryInterface ) { $ compiler -> registerCompilerInstances ( $ depCollection , $ this ) ; } } $ this -> orderedCompilers = $ depCollection -> getOrderedElements ( ) ; } return $ this -> orderedCompilers ; }
6171	protected function onAddFailure ( $ e ) { $ this -> writeProgressWithColor ( 'fg-red,bold' , 'F' ) ; $ this -> failure = $ e ; $ this -> lastTestFailed = true ; $ this -> flawless = false ; }
1909	private function stripNamespace ( string $ fqcn ) : string { if ( false !== ( $ pos = strrpos ( $ fqcn , '\\' ) ) ) { return substr ( $ fqcn , $ pos + 1 ) ; } return $ fqcn ; }
3464	public function get ( string $ route , callable $ controller ) : void { $ this -> register ( $ controller , Route :: get ( $ route ) ) ; }
4810	private function is_scheduled ( $ name ) { $ crons = _get_cron_array ( ) ; if ( empty ( $ crons ) ) { return false ; } foreach ( $ crons as $ cron ) { if ( isset ( $ cron [ $ name ] ) ) { return true ; } } return false ; }
863	private function changeCodeHash ( $ codeHash ) { if ( null !== $ this -> codeHash ) { self :: clearCache ( $ this -> codeHash ) ; } $ this -> codeHash = $ codeHash ; self :: setCache ( $ this -> codeHash , $ this ) ; }
7786	public function createStatement ( AccountInterface $ account , $ number ) { return $ this -> createObject ( $ this -> statementClass , 'Jejik\MT940\StatementInterface' , array ( $ account , $ number ) ) ; }
7142	private function registerActions ( ContainerBuilder $ container ) { if ( class_exists ( 'Ekyna\Component\Payum\Payzen\PayzenGatewayFactory' ) ) { $ definition = new Definition ( 'Ekyna\Component\Commerce\Bridge\Payum\Payzen\Action\ConvertAction' ) ; $ definition -> addTag ( 'payum.action' , [ 'factory' => 'payzen' , 'prepend' => true ] ) ; $ container -> setDefinition ( 'ekyna_commerce.payum.action.payzen.convert_payment' , $ definition ) ; $ definition = new Definition ( 'Ekyna\Component\Commerce\Bridge\Payum\Payzen\Action\FraudLevelAction' ) ; $ definition -> addTag ( 'payum.action' , [ 'factory' => 'payzen' , 'prepend' => true ] ) ; $ container -> setDefinition ( 'ekyna_commerce.payum.action.payzen.fraud_level' , $ definition ) ; } if ( class_exists ( 'Ekyna\Component\Payum\Sips\SipsGatewayFactory' ) ) { $ definition = new Definition ( 'Ekyna\Component\Commerce\Bridge\Payum\Sips\Action\ConvertAction' ) ; $ definition -> addTag ( 'payum.action' , [ 'factory' => 'atos_sips' , 'prepend' => true ] ) ; $ container -> setDefinition ( 'ekyna_commerce.payum.action.sips.convert_payment' , $ definition ) ; } if ( class_exists ( 'Payum\Paypal\ExpressCheckout\Nvp\PaypalExpressCheckoutGatewayFactory' ) ) { $ definition = new Definition ( 'Ekyna\Component\Commerce\Bridge\Payum\Paypal\Action\EcNvpConvertAction' ) ; $ definition -> setArgument ( 0 , new Reference ( 'ekyna_commerce.common.amount_calculator' ) ) ; if ( $ container -> has ( 'ekyna_setting.manager' ) && class_exists ( 'Ekyna\Bundle\AdminBundle\Settings\GeneralSettingsSchema' ) ) { $ definition -> setArgument ( 1 , new Expression ( "service('ekyna_setting.manager').getParameter('general.site_name')" ) ) ; } $ definition -> addTag ( 'payum.action' , [ 'factory' => 'paypal_express_checkout' , 'prepend' => true ] ) ; $ container -> setDefinition ( 'ekyna_commerce.payum.action.paypal_ec_nvp.convert_payment' , $ definition ) ; } $ actions = [ 'capture_payment' => Action \ CaptureAction :: class , 'notify_payment' => Action \ NotifyAction :: class , 'status_payment' => Action \ StatusAction :: class , ] ; foreach ( $ actions as $ name => $ class ) { $ definition = new Definition ( $ class ) ; $ definition -> addTag ( 'payum.action' , [ 'all' => true , 'prepend' => true ] ) ; $ container -> setDefinition ( 'ekyna_commerce.payum.action.' . $ name , $ definition ) ; } }
6257	public function authorize ( $ user , Request $ request ) { $ roleField = $ this -> _config [ 'roleField' ] ; if ( ! isset ( $ user [ $ roleField ] ) ) { throw new RuntimeException ( sprintf ( 'The role field `%s` does not exist!' , $ roleField ) ) ; } if ( is_string ( $ user [ $ roleField ] ) ) { $ user [ $ roleField ] = array ( $ user [ $ roleField ] ) ; } if ( $ this -> authorizeByPrefix ( $ user [ $ roleField ] , $ request ) ) { return true ; } if ( $ this -> authorizeByControllerAndAction ( $ user , $ request ) ) { return true ; } return false ; }
7969	public function getVoiceConsumptions ( $ params = null ) { $ consumptionList = json_decode ( self :: getClient ( ) -> getVoiceConsumptions ( $ this -> service , $ this -> billingAccount , $ params ) ) ; $ consumptions = array ( ) ; foreach ( $ consumptionList as $ consumption ) { $ consumptions [ ] = new VoiceConsumption ( $ consumption , $ this ) ; } return $ consumptions ; }
10970	public static function getRequest ( $ name , $ defaultValue = null ) { if ( isset ( $ _REQUEST [ $ name ] ) ) { return $ _REQUEST [ $ name ] ; } return $ defaultValue ; }
9602	public function dotProduct ( self $ b ) { $ this -> _checkVectorSpace ( $ b ) ; $ bComponents = $ b -> components ( ) ; $ product = 0 ; foreach ( $ this -> components ( ) as $ i => $ component ) { $ product += $ component * $ bComponents [ $ i ] ; } return $ product ; }
1446	protected function dataForUpdate ( $ record , array $ document ) : array { $ resource = $ document [ 'data' ] ?? [ ] ; if ( $ this -> mustValidateExisting ( $ record , $ document ) ) { $ resource [ 'attributes' ] = $ this -> extractAttributes ( $ record , $ resource [ 'attributes' ] ?? [ ] ) ; $ resource [ 'relationships' ] = $ this -> extractRelationships ( $ record , $ resource [ 'relationships' ] ?? [ ] ) ; } return $ resource ; }
11497	public static function all ( $ pageNumber = 0 , $ pageSize = 10 , $ order = null ) { return ( new static ( ) ) -> fetchAll ( null , $ order , $ pageSize , $ pageNumber ) ; }
12557	private static function init ( ) : void { static $ inited = false ; if ( ! $ inited ) { if ( ! isset ( $ _SESSION [ 'Booby' ] ) || ! $ _SESSION [ 'Booby' ] ) { $ _SESSION [ 'Booby' ] = [ ] ; } self :: $ store = & $ _SESSION [ 'Booby' ] ; $ inited = true ; } }
7577	protected function setFileFieldValue ( $ value ) { if ( version_compare ( PHP_VERSION , '5.5.0' ) >= 0 ) { if ( ! ( $ value instanceof \ CURLFile ) ) { $ value = ltrim ( $ value , "@" ) ; $ value = new \ CURLFile ( $ value ) ; } } else { if ( strpos ( $ value , '@' ) !== 0 ) { $ value = '@' . $ value ; } } return $ value ; }
362	protected function getClientOptions ( ) { $ filterUrl = isset ( $ this -> filterUrl ) ? $ this -> filterUrl : Yii :: $ app -> request -> url ; $ id = $ this -> filterRowOptions [ 'id' ] ; $ filterSelector = "#$id input, #$id select" ; if ( isset ( $ this -> filterSelector ) ) { $ filterSelector .= ', ' . $ this -> filterSelector ; } return [ 'filterUrl' => Url :: to ( $ filterUrl ) , 'filterSelector' => $ filterSelector , ] ; }
4488	private function broadcastToPlatform ( $ message , string $ platform ) { if ( $ this -> debug ) { $ this -> logger && $ this -> logger -> notice ( "Message would have been sent to $platform" , [ 'Message' => $ message , ] ) ; return ; } foreach ( $ this -> sns -> getPaginator ( 'ListEndpointsByPlatformApplication' , [ 'PlatformApplicationArn' => $ this -> arns [ $ platform ] , ] ) as $ endpointsResult ) { foreach ( $ endpointsResult [ 'Endpoints' ] as $ endpoint ) { if ( $ endpoint [ 'Attributes' ] [ 'Enabled' ] == 'true' ) { try { $ this -> send ( $ message , $ endpoint [ 'EndpointArn' ] ) ; } catch ( \ Exception $ e ) { $ this -> logger && $ this -> logger -> error ( "Failed to push to {$endpoint['EndpointArn']}" , [ 'Message' => $ message , 'Exception' => $ e , 'Endpoint' => $ endpoint , ] ) ; } } else { $ this -> logger && $ this -> logger -> info ( "Disabled endpoint {$endpoint['EndpointArn']}" , [ 'Message' => $ message , 'Endpoint' => $ endpoint , ] ) ; } } } }
9023	public function hasConfirmation ( $ string ) { $ result = false ; $ words = $ this -> getWords ( $ string ) ; foreach ( $ words as $ word ) { if ( in_array ( $ word , $ this -> confirmationWords ) ) { $ result = true ; } } return $ result ; }
6102	public function listPropertyTypes ( $ systemName = null , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/propertysets/propertytypes' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new PropertyType ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; if ( null !== $ systemName ) { foreach ( $ result as $ entry ) { if ( $ entry -> getSystemName ( ) === $ systemName ) { return $ entry ; } } return null ; } return $ result ; }
6555	public function stop ( $ reason ) { $ this -> log ( $ reason , LogLevel :: INFO ) ; $ this -> stopped = true ; }
3914	protected function sortByName ( $ blnAscending = true ) { $ arrFiles = $ this -> foundFiles ; if ( ! $ arrFiles ) { return array ( 'files' => array ( ) , 'source' => array ( ) ) ; } \ uasort ( $ arrFiles , ( $ blnAscending ) ? '\basename_natcasecmp' : '\basename_natcasercmp' ) ; return $ this -> remapSorting ( $ arrFiles , $ this -> outputBuffer ) ; }
12146	public function get ( $ name ) { if ( $ this -> exists ( $ name ) ) { $ value = $ this -> settings [ $ name ] ; return $ value ; } return false ; }
3786	public function addListener ( $ eventName , $ listener , $ priority = 200 ) { $ dispatcher = $ this -> getServiceContainer ( ) -> getEventDispatcher ( ) ; $ dispatcher -> addListener ( $ eventName , $ listener , $ priority ) ; return $ this ; }
7495	private static function convertString ( $ string , $ outputEncoding ) { if ( $ string instanceof StringBuilder ) { $ inputEncoding = $ string -> getEncoding ( ) ; } else { $ inputEncoding = mb_detect_encoding ( ( string ) $ string ) ; } $ string = ( string ) $ string ; if ( $ inputEncoding != $ outputEncoding ) { $ string = iconv ( $ inputEncoding , $ outputEncoding , $ string ) ; } return $ string ; }
1428	public static function createMany ( array $ input ) { $ errors = new ErrorCollection ( ) ; foreach ( $ input as $ item ) { $ errors -> add ( self :: create ( $ item ) ) ; } return $ errors ; }
8967	public static function clean ( $ currencyCode ) { $ clean = trim ( strtoupper ( $ currencyCode ) ) ; if ( ! self :: exists ( $ clean ) ) { throw new UnknownCurrencyCodeException ( sprintf ( 'Unknown currency code "%s".' , $ currencyCode ) ) ; } return $ clean ; }
10772	public function getMediaTypeMatch ( $ data ) { foreach ( $ this -> getMediaTypes ( ) as $ mediaTypeClass ) { $ instance = forward_static_call ( array ( $ mediaTypeClass , 'check' ) , $ data ) ; if ( $ instance ) { return $ instance ; } } }
11480	private function getJsonBody ( RequestInterface $ request , ResponseInterface $ response ) : array { $ data = json_decode ( $ response -> getBody ( ) , true ) ; if ( ! $ data || ! is_array ( $ data ) || ! array_key_exists ( "data" , $ data ) ) { throw new ClientException ( "Response body does not contain a valid JSON object." , $ request , $ response ) ; } if ( ! is_array ( $ data ) || ! is_array ( $ data [ "data" ] ) ) { throw new ClientException ( "Not sure what happened. The list jobs endpoint didn't return a list. :worried:" , $ request , $ response ) ; } return $ data [ "data" ] ; }
3633	public function pools ( Request $ request ) : array { if ( $ name = $ request -> query ( 'name' ) ) { if ( ! App :: hasPool ( $ name ) ) { return [ ] ; } $ poolConfig = App :: getPool ( $ name ) -> getPoolConfig ( ) ; return $ poolConfig -> toArray ( ) ; } return PoolCollector :: getCollector ( ) ; }
2815	public function addCollection ( Varien_Data_Collection_Db $ collection ) { $ info = Mage :: getModel ( 'sheep_debug/collection' ) ; $ info -> init ( $ collection ) ; $ key = $ info -> getClass ( ) ; if ( ! array_key_exists ( $ key , $ this -> collections ) ) { $ this -> collections [ $ key ] = $ info ; } $ this -> collections [ $ key ] -> incrementCount ( ) ; }
12941	public function storePermissions ( $ params = array ( ) ) { $ authorityAreaTitle = $ this -> input -> getString ( "area-title" ) ; $ authorityAreaURI = $ this -> input -> getString ( "area-uri" ) ; $ authorityAreaAction = $ this -> input -> getString ( "area-action" ) ; $ authorityAreaPermission = $ this -> input -> getString ( "area-permission" ) ; $ authorityId = $ this -> input -> getInt ( "area-authority" ) ; $ table = $ this -> load -> table ( "?authority_permissions" ) ; $ aData = array ( "authority_id" => $ authorityId , "permission_area_uri" => strtolower ( $ authorityAreaURI ) , "permission" => strtolower ( $ authorityAreaPermission ) , "permission_type" => strtolower ( $ authorityAreaAction ) , "permission_title" => $ authorityAreaTitle ) ; foreach ( $ aData as $ k => $ item ) { if ( empty ( $ item ) ) { $ this -> setError ( _t ( "Please complete all permission fields; Provide a title and uri defining the area, a permission type and value" ) ) ; return false ; } } if ( ! $ table -> bindData ( $ aData ) ) { throw new \ Platform \ Exception ( $ table -> getError ( ) ) ; return false ; } if ( $ table -> isNewRow ( ) ) { } if ( ! $ table -> save ( ) ) { return false ; } return true ; }
11768	public function updateSentinels ( ) { SENTINEL_QUERY : { $ sentinel = $ this -> getSentinelConnection ( ) ; try { $ payload = $ sentinel -> executeCommand ( RawCommand :: create ( 'SENTINEL' , 'sentinels' , $ this -> service ) ) ; $ this -> sentinels = array ( ) ; $ this -> sentinels [ ] = $ sentinel -> getParameters ( ) -> toArray ( ) ; foreach ( $ payload as $ sentinel ) { $ this -> sentinels [ ] = array ( 'host' => $ sentinel [ 3 ] , 'port' => $ sentinel [ 5 ] , 'role' => 'sentinel' , ) ; } } catch ( ConnectionException $ exception ) { $ this -> sentinelConnection = null ; goto SENTINEL_QUERY ; } } }
7445	public function editAction ( $ id ) { $ em = $ this -> getDoctrine ( ) -> getEntityManager ( ) ; $ group = $ em -> getRepository ( 'Orkestra\Bundle\ApplicationBundle\Entity\Group' ) -> find ( $ id ) ; if ( ! $ group ) { throw $ this -> createNotFoundException ( 'Unable to locate Group' ) ; } $ form = $ this -> createForm ( GroupType :: class , $ group ) ; return array ( 'group' => $ group , 'form' => $ form -> createView ( ) , ) ; }
7386	public static final function moveFile ( $ file ) { try { if ( $ file -> is_temp ) { rename ( $ file -> temp_destination . '/' . $ file -> temp_name , $ file -> original_destination . '/' . $ file -> temp_name ) ; if ( ! file_exists ( $ file -> original_destination . '/' . $ file -> temp_name ) ) { throw new CannotSaveFileInHardDriveException ( ) ; } $ file -> is_temp = false ; $ file -> expire = null ; $ file -> save ( ) ; } } catch ( \ Exception $ exception ) { throw new FileException ( $ exception -> getMessage ( ) ) ; } }
4825	public function replaceValue ( $ fieldName , $ oldvalue , $ newvalue ) { $ result = $ this -> row [ $ fieldName ] ; if ( ! is_array ( $ result ) ) { if ( $ oldvalue == $ result ) { $ this -> row [ $ fieldName ] = $ newvalue ; $ this -> informChanges ( ) ; } } else { for ( $ i = count ( $ result ) - 1 ; $ i >= 0 ; $ i -- ) { if ( $ result [ $ i ] == $ oldvalue ) { $ this -> row [ $ fieldName ] [ $ i ] = $ newvalue ; $ this -> informChanges ( ) ; } } } }
5525	protected function createCodeForClass ( $ methods ) { $ implements = '' ; $ interfaces = $ this -> reflection -> getInterfaces ( ) ; $ interfaces = array_diff ( $ interfaces , [ 'Traversable' , 'Throwable' ] ) ; if ( count ( $ interfaces ) > 0 ) { $ implements = 'implements ' . implode ( ', ' , $ interfaces ) ; } $ code = 'class ' . $ this -> mock_class . ' extends ' . $ this -> mock_base . ' ' . $ implements . " {\n" ; $ code .= " function __construct() {\n" ; $ code .= " parent::__construct();\n" ; $ code .= " }\n" ; $ code .= $ this -> createCodeForConstructor ( ) ; $ code .= $ this -> createCodeForMethods ( $ methods ) ; $ code .= "}\n" ; return $ code ; }
3606	public function get ( $ name ) { if ( ! isset ( $ this -> httpHandlers [ $ name ] ) ) { throw new \ Exception ( "HttpHandler {$name} not found" ) ; } return $ this -> httpHandlers [ $ name ] ; }
4700	protected function handleInput ( InputInterface $ input ) { if ( $ file = $ input -> getArgument ( 'file' ) ) { if ( ! file_exists ( $ file ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The input file "%s" not found' , $ file ) ) ; } return file_get_contents ( $ file ) ; } else { $ contents = '' ; if ( $ stdin = fopen ( 'php://stdin' , 'r' ) ) { if ( stream_set_blocking ( $ stdin , false ) ) { $ contents = stream_get_contents ( $ stdin ) ; } fclose ( $ stdin ) ; } if ( $ contents ) { return $ contents ; } } throw new \ InvalidArgumentException ( 'No input file' ) ; }
9610	public function getRouteUrl ( $ name , array $ params = array ( ) , $ relative = false ) { $ route = $ this -> router -> getRoute ( $ name ) ; $ routeParams = [ ] ; $ query = [ ] ; foreach ( $ params as $ key => $ value ) { if ( is_int ( $ key ) ) { $ routeParams [ ] = $ value ; } else { $ query [ $ key ] = $ value ; } } $ path = $ this -> routePathGenerator -> getRoutePath ( $ route , $ routeParams ) ; if ( $ query ) { $ path .= '?' . http_build_query ( $ query ) ; } if ( $ relative ) { $ root = $ this -> requests -> getCurrentRequest ( ) -> getBaseUrl ( ) ; } else { $ root = $ this -> getRootUrl ( ) ; } return $ root . $ path ; }
6664	public function instantiate ( $ profile , $ provider ) { $ this -> provider = $ provider ; switch ( $ provider ) { case 'facebook' : $ this -> info = $ this -> parseFb ( $ profile ) ; break ; case 'twitter' : $ this -> info = $ this -> parseTwt ( $ profile ) ; break ; } return $ this ; }
3829	protected function buildFilterUrl ( $ fragments , $ searchKey ) { @ trigger_error ( sprintf ( '"%1$s" has been deprecated in favor of the "FilterUrlBuilder"' , __METHOD__ ) , E_USER_DEPRECATED ) ; $ url = '' ; $ found = false ; foreach ( $ fragments as $ key => $ value ) { if ( ( $ key == 'language' ) && $ GLOBALS [ 'TL_CONFIG' ] [ 'addLanguageToUrl' ] ) { continue ; } if ( $ key == $ searchKey ) { if ( $ key !== 'auto_item' ) { $ url .= '%s' ; } else { $ url = '%s' . $ url ; } $ found = true ; } else { $ url = $ this -> addUrlParameter ( $ url , $ key , $ value ) ; } } if ( ! $ found ) { if ( $ searchKey !== 'auto_item' ) { $ url .= '%s' ; } else { $ url = '%s' . $ url ; } } return $ url ; }
538	protected function serializeDataProvider ( $ dataProvider ) { if ( $ this -> preserveKeys ) { $ models = $ dataProvider -> getModels ( ) ; } else { $ models = array_values ( $ dataProvider -> getModels ( ) ) ; } $ models = $ this -> serializeModels ( $ models ) ; if ( ( $ pagination = $ dataProvider -> getPagination ( ) ) !== false ) { $ this -> addPaginationHeaders ( $ pagination ) ; } if ( $ this -> request -> getIsHead ( ) ) { return null ; } elseif ( $ this -> collectionEnvelope === null ) { return $ models ; } $ result = [ $ this -> collectionEnvelope => $ models , ] ; if ( $ pagination !== false ) { return array_merge ( $ result , $ this -> serializePagination ( $ pagination ) ) ; } return $ result ; }
4207	private function getPropCommentInfo ( \ ReflectionProperty $ reflectionProperty ) { $ name = $ reflectionProperty -> name ; $ phpDoc = $ this -> phpDoc -> getParsed ( $ reflectionProperty ) ; $ info = array ( 'type' => null , 'desc' => $ phpDoc [ 'summary' ] ? $ phpDoc [ 'summary' ] : null , ) ; if ( isset ( $ phpDoc [ 'var' ] ) ) { if ( \ count ( $ phpDoc [ 'var' ] ) == 1 ) { $ var = $ phpDoc [ 'var' ] [ 0 ] ; } else { foreach ( $ phpDoc [ 'var' ] as $ var ) { if ( $ var [ 'name' ] == $ name ) { break ; } } } $ info [ 'type' ] = $ var [ 'type' ] ; if ( ! $ info [ 'desc' ] ) { $ info [ 'desc' ] = $ var [ 'desc' ] ; } elseif ( $ var [ 'desc' ] ) { $ info [ 'desc' ] = $ info [ 'desc' ] . ': ' . $ var [ 'desc' ] ; } } return $ info ; }
11950	private function buildAuthorizationHeader ( array $ params ) { foreach ( $ params as $ key => $ value ) { $ params [ $ key ] = $ key . '="' . rawurlencode ( $ value ) . '"' ; } if ( $ this -> realm ) { array_unshift ( $ params , 'realm="' . rawurlencode ( $ this -> realm ) . '"' ) ; } return [ 'Authorization' , 'OAuth ' . implode ( ', ' , $ params ) ] ; }
3983	private function buildBackendMenuSection ( $ groupName , Request $ request ) { $ strRefererId = $ request -> attributes -> get ( '_contao_referer_id' ) ; $ label = $ this -> translator -> trans ( 'MOD.' . $ groupName , [ ] , 'contao_modules' ) ; if ( \ is_array ( $ label ) ) { $ label = $ label [ 0 ] ; } return [ 'class' => ' node-expanded' , 'title' => StringUtil :: specialchars ( $ this -> translator -> trans ( 'MSC.collapseNode' , [ ] , 'contao_modules' ) ) , 'label' => $ label , 'href' => $ this -> urlGenerator -> generate ( 'contao_backend' , [ 'do' => $ request -> get ( 'do' ) , 'mtg' => $ groupName , 'ref' => $ strRefererId ] ) , 'ajaxUrl' => $ this -> urlGenerator -> generate ( 'contao_backend' ) , 'icon' => 'modPlus.gif' , 'modules' => [ ] , ] ; }
9892	protected function createError ( ) { $ error = $ this -> getForm ( ) -> getValidator ( ) -> getMessages ( $ this -> getElement ( ) -> getName ( ) ) ; if ( $ error ) { $ this -> error = $ this -> builder -> make ( 'error' , [ ] , $ error ) ; } }
6440	public function transform ( $ target = null , $ controller = null , $ action = null , array $ params = [ ] , array $ trailing = [ ] , array $ config = [ ] ) { if ( ! empty ( $ trailing ) ) { $ params [ 'trailing' ] = join ( '_' , $ trailing ) ; } $ params = $ this -> sanitize ( $ params ) ; $ refType = \ Symfony \ Component \ Routing \ Generator \ UrlGeneratorInterface :: ABSOLUTE_PATH ; if ( isset ( $ config [ 'absoluteUri' ] ) ) { $ refType = \ Symfony \ Component \ Routing \ Generator \ UrlGeneratorInterface :: ABSOLUTE_URL ; } return $ this -> router -> generate ( $ target , $ params + $ this -> fixed , $ refType ) ; }
8068	public function connect ( ) { $ port = $ this -> ssl ? $ this :: PORT_SSL : $ this :: PORT ; $ hostname = $ this -> domainController -> getHostname ( ) ; return $ this -> connection = ldap_connect ( $ hostname , $ port ) ; }
2303	public function addCustomLayoutSectionReferences ( ) { $ objLayout = $ this -> Database -> getInstance ( ) -> query ( "SELECT sections FROM tl_layout WHERE sections!=''" ) ; while ( $ objLayout -> next ( ) ) { $ arrCustom = StringUtil :: deserialize ( $ objLayout -> sections ) ; if ( ! empty ( $ arrCustom ) && \ is_array ( $ arrCustom ) ) { foreach ( $ arrCustom as $ v ) { if ( ! empty ( $ v [ 'id' ] ) ) { $ GLOBALS [ 'TL_LANG' ] [ 'COLS' ] [ $ v [ 'id' ] ] = $ v [ 'title' ] ; } } } } }
8410	public function connect ( ) { if ( $ this -> isConnected ( ) === false ) { try { if ( isset ( $ this -> servers [ 'all' ] ) === true ) { $ dsn = $ this -> providerDatabase -> getDsn ( $ this -> servers [ 'all' ] ) ; $ this -> servers [ 'all' ] [ 'link' ] = new \ PDO ( $ dsn , $ this -> servers [ 'all' ] [ 'user' ] , $ this -> servers [ 'all' ] [ 'pass' ] ) ; } else { $ dsn = $ this -> providerDatabase -> getDsn ( $ this -> servers [ 'read' ] ) ; $ this -> servers [ 'read' ] [ 'link' ] = new \ PDO ( $ dsn , $ this -> servers [ 'read' ] [ 'user' ] , $ this -> servers [ 'read' ] [ 'pass' ] ) ; $ dsn = $ this -> providerDatabase -> getDsn ( $ this -> servers [ 'write' ] ) ; $ this -> servers [ 'write' ] [ 'link' ] = new \ PDO ( $ dsn , $ this -> servers [ 'write' ] [ 'user' ] , $ this -> servers [ 'write' ] [ 'pass' ] ) ; } } catch ( \ PDOException $ e ) { throw new ExternalLink ( 'can\'t connect to database (' . $ e -> getMessage ( ) . ')' ) ; } } }
9885	private function writeDefinedNameForNamedRange ( XMLWriter $ objWriter , NamedRange $ pNamedRange ) { $ objWriter -> startElement ( 'definedName' ) ; $ objWriter -> writeAttribute ( 'name' , $ pNamedRange -> getName ( ) ) ; if ( $ pNamedRange -> getLocalOnly ( ) ) { $ objWriter -> writeAttribute ( 'localSheetId' , $ pNamedRange -> getScope ( ) -> getParent ( ) -> getIndex ( $ pNamedRange -> getScope ( ) ) ) ; } $ range = Coordinate :: splitRange ( $ pNamedRange -> getRange ( ) ) ; $ iMax = count ( $ range ) ; for ( $ i = 0 ; $ i < $ iMax ; ++ $ i ) { $ range [ $ i ] [ 0 ] = '\'' . str_replace ( "'" , "''" , $ pNamedRange -> getWorksheet ( ) -> getTitle ( ) ) . '\'!' . Coordinate :: absoluteReference ( $ range [ $ i ] [ 0 ] ) ; if ( isset ( $ range [ $ i ] [ 1 ] ) ) { $ range [ $ i ] [ 1 ] = Coordinate :: absoluteReference ( $ range [ $ i ] [ 1 ] ) ; } } $ range = Coordinate :: buildRange ( $ range ) ; $ objWriter -> writeRawData ( $ range ) ; $ objWriter -> endElement ( ) ; }
5672	protected function describeFloatDifference ( $ first , $ second , $ identical ) { if ( is_object ( $ second ) || is_array ( $ second ) ) { return $ this -> describeGenericDifference ( $ first , $ second ) ; } return sprintf ( 'because [%s] differs from [%s] by %s' , $ this -> describeValue ( $ first ) , $ this -> describeValue ( $ second ) , abs ( $ first - $ second ) ) ; }
10586	protected static function registerEntity ( entity \ EntityInterface $ entity ) { if ( count ( self :: $ entities ) === 0 ) { register_shutdown_function ( "sndsgd\\fs\\Temp::cleanup" ) ; } self :: $ entities [ $ entity -> getPath ( ) ] = $ entity ; }
9645	public function makePdo ( array $ config , $ connection = null ) { if ( ! isset ( $ config [ 'driver' ] ) && ! isset ( $ config [ 'dsn' ] ) ) { throw new InvalidArgumentException ( 'DSN or driver must be set' ) ; } $ options = isset ( $ config [ 'pdo_options' ] ) ? $ config [ 'pdo_options' ] : [ ] ; unset ( $ config [ 'pdo_options' ] ) ; $ options = array_replace ( $ this -> defaultPdoOptions , $ options ) ; $ initCommands = isset ( $ config [ 'pdo_init_commands' ] ) ? $ config [ 'pdo_init_commands' ] : [ ] ; unset ( $ config [ 'pdo_init_commands' ] ) ; if ( isset ( $ config [ 'driver' ] ) && $ config [ 'driver' ] == 'sqlite' ) { $ this -> validate ( $ config , 'path' , $ connection ) ; $ dsn = $ this -> makeSqliteDsn ( $ config [ 'path' ] ) ; return $ this -> makePdoInner ( $ dsn , null , null , $ options , $ initCommands ) ; } elseif ( isset ( $ config [ 'dsn' ] ) && strpos ( $ config [ 'dsn' ] , 'sqlite:' ) === 0 ) { return $ this -> makePdoInner ( $ config [ 'dsn' ] , null , null , $ options , $ initCommands ) ; } $ this -> validate ( $ config , 'username' , $ connection , false ) ; $ username = $ config [ 'username' ] ; unset ( $ config [ 'username' ] ) ; $ this -> validate ( $ config , 'password' , $ connection , true ) ; $ password = $ config [ 'password' ] ; unset ( $ config [ 'password' ] ) ; if ( isset ( $ config [ 'dsn' ] ) ) { $ dsn = $ config [ 'dsn' ] ; } else { $ driver = $ config [ 'driver' ] ; unset ( $ config [ 'driver' ] ) ; $ this -> validate ( $ config , 'host' , $ connection ) ; $ this -> validate ( $ config , 'dbname' , $ connection ) ; $ dsn = $ this -> makeDsn ( $ driver , $ config ) ; } return $ this -> makePdoInner ( $ dsn , $ username , $ password , $ options , $ initCommands ) ; }
7854	protected function deleteIfForced ( array $ files ) { if ( ! $ this -> option ( 'force' ) ) return ; foreach ( $ files as $ file ) { if ( $ this -> files -> exists ( $ path = $ this -> getPath ( $ file ) ) ) { $ this -> files -> delete ( $ path ) ; } } }
12867	public function init_options ( ) { if ( ! is_array ( $ this -> options ) ) { $ this -> options = array ( ) ; } $ options_id = $ this -> get_id ( '-options' ) ; $ options = get_option ( $ options_id ) ; $ need_update = false ; if ( $ options === false ) { $ need_update = true ; $ options = array ( ) ; } foreach ( $ this -> options as $ key => $ value ) { if ( ! array_key_exists ( $ key , $ options ) ) { $ options [ $ key ] = $ value ; } } if ( ! array_key_exists ( 'latest_used_version' , $ options ) ) { $ options [ 'latest_used_version' ] = $ this -> version ; $ need_update = true ; } if ( $ need_update === true ) { update_option ( $ options_id , $ options ) ; } return $ options ; }
12498	public static function insertOne ( $ document , $ connection ) { $ connection -> query = self :: singleDocument ( $ document ) ; return self :: insert ( $ connection ) ; }
8693	public static function createSymlink ( $ symlinkTarget , $ symlinkName ) { if ( false === @ symlink ( $ symlinkTarget , $ symlinkName ) ) { throw new \ UnexpectedValueException ( "An error occurred while creating symlink '{$symlinkName}'" ) ; } if ( false === $ target = readlink ( $ symlinkName ) ) { throw new \ UnexpectedValueException ( "Symlink {$symlinkName} points to target {$target}" ) ; } }
9301	public function setScheduleAhead ( $ time ) { if ( ! is_numeric ( $ time ) ) { throw new \ InvalidArgumentException ( '`scheduleAhead` expects integer value!' ) ; } $ this -> options [ 'scheduleAhead' ] = ( int ) $ time ; return $ this ; }
7431	public static function getInstance ( ) : MimeType { if ( null === self :: $ instance ) { self :: $ instance = new self ( ) ; } return self :: $ instance ; }
2074	public function purgeSearchTables ( ) { $ objDatabase = Database :: getInstance ( ) ; $ objDatabase -> execute ( "TRUNCATE TABLE tl_search" ) ; $ objDatabase -> execute ( "TRUNCATE TABLE tl_search_index" ) ; $ strCachePath = StringUtil :: stripRootDir ( System :: getContainer ( ) -> getParameter ( 'kernel.cache_dir' ) ) ; $ objFolder = new Folder ( $ strCachePath . '/contao/search' ) ; $ objFolder -> purge ( ) ; $ this -> log ( 'Purged the search tables' , __METHOD__ , TL_CRON ) ; }
6367	public function min ( Traversable $ traversable ) { $ array = iterator_to_array ( $ traversable , false ) ; Arrays :: sort ( $ array , $ this ) ; return Preconditions :: checkElementExists ( $ array , 0 ) ; }
12494	public static function find ( $ id = null , $ connection ) { if ( gettype ( $ id ) != "string" && ! is_numeric ( $ id ) ) { throw new ClusterpointException ( "\"->find()\" function: \"_id\" is not in valid format." , 9002 ) ; } $ connection -> method = 'GET' ; $ connection -> action = '[' . urlencode ( $ id ) . ']' ; $ connection -> multiple = false ; return self :: sendQuery ( $ connection ) ; }
11931	protected function generateField ( $ fieldType , $ fieldId , array $ labels ) { $ field = new FieldType ( ) ; $ field -> setType ( $ fieldType ) ; $ field -> setFieldId ( $ fieldId ) ; $ field -> setDefaultValue ( null ) ; $ field -> setSearchable ( true ) ; $ field -> setLabels ( $ labels ) ; return $ field ; }
3132	public function init ( RunnerServiceContext $ context ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ session = $ context -> getTestSession ( ) ; if ( $ session -> getState ( ) === AssessmentTestSessionState :: INITIAL ) { $ session -> beginTestSession ( ) ; $ event = new TestInitEvent ( $ session ) ; $ this -> getServiceManager ( ) -> get ( EventManager :: SERVICE_ID ) -> trigger ( $ event ) ; \ common_Logger :: i ( "Assessment Test Session begun." ) ; if ( $ context -> isAdaptive ( ) ) { \ common_Logger :: t ( "Very first item is adaptive." ) ; $ nextCatItemId = $ context -> selectAdaptiveNextItem ( ) ; $ context -> persistCurrentCatItemId ( $ nextCatItemId ) ; $ context -> persistSeenCatItemIds ( $ nextCatItemId ) ; } } elseif ( $ session -> getState ( ) === AssessmentTestSessionState :: SUSPENDED ) { $ session -> resume ( ) ; } $ session -> initItemTimer ( ) ; if ( $ session -> isTimeout ( ) === false ) { TestRunnerUtils :: beginCandidateInteraction ( $ session ) ; } $ this -> getServiceManager ( ) -> get ( ExtendedStateService :: SERVICE_ID ) -> clearEvents ( $ session -> getSessionId ( ) ) ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'init' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } return true ; }
12581	public function previewCardByName ( $ message , $ to ) { return $ this -> preview ( self :: MSG_TYPE_CARD , $ message , $ to , self :: PREVIEW_BY_NAME ) ; }
232	public function quoteValue ( $ str ) { if ( ! is_string ( $ str ) ) { return $ str ; } if ( ( $ value = $ this -> db -> getSlavePdo ( ) -> quote ( $ str ) ) !== false ) { return $ value ; } return "'" . addcslashes ( str_replace ( "'" , "''" , $ str ) , "\000\n\r\\\032" ) . "'" ; }
11054	public static function printts ( $ datatree , $ containers , $ entry = 'main' ) { $ this -> printt ( $ datatree , $ containers , $ entry , _ETS_STRING_READ , '' , '' ) ; }
915	public static function camelCaseToUnderscore ( $ string ) { return Preg :: replaceCallback ( '/(^|[a-z0-9])([A-Z])/' , static function ( array $ matches ) { return strtolower ( '' !== $ matches [ 1 ] ? $ matches [ 1 ] . '_' . $ matches [ 2 ] : $ matches [ 2 ] ) ; } , $ string ) ; }
10678	public function inflect ( $ text , $ zivotne = false , $ preferovanyRod = '' ) { $ aTxt = $ this -> _txtSplit ( $ text ) ; $ this -> PrefRod = '0' ; $ out = [ ] ; for ( $ i = \ count ( $ aTxt ) - 1 ; $ i >= 0 ; $ i -- ) { $ this -> _skl2 ( $ aTxt [ $ i ] , $ preferovanyRod , $ zivotne ) ; if ( $ i === \ count ( $ aTxt ) - 1 ) { $ this -> PrefRod = $ this -> astrTvar [ 0 ] ; } if ( $ i < \ count ( $ aTxt ) - 1 && mb_substr ( $ this -> PrefRod , 0 , 1 , 'UTF-8' ) !== '?' && mb_substr ( $ this -> astrTvar [ 0 ] , 0 , 1 , 'UTF-8' ) === '?' ) { for ( $ j = 1 ; $ j < 15 ; $ j ++ ) { $ this -> astrTvar [ $ j ] = $ aTxt [ $ i ] ; } } if ( mb_substr ( $ this -> astrTvar [ 0 ] , 0 , 1 , 'UTF-8' ) === '?' ) { $ this -> astrTvar [ 0 ] = '' ; } if ( $ i < \ count ( $ aTxt ) ) { for ( $ j = 1 ; $ j < 15 ; $ j ++ ) { @ $ out [ $ j ] = $ this -> astrTvar [ $ j ] . ' ' . @ $ out [ $ j ] ; } } else { for ( $ j = 1 ; $ j < 15 ; $ j ++ ) { @ $ out [ $ j ] = $ this -> astrTvar [ $ j ] ; } } } return $ out ; }
2122	public function add ( $ strFile , $ strVersion = null , $ strMedia = 'all' ) { $ strType = strrchr ( $ strFile , '.' ) ; if ( $ strType != self :: CSS && $ strType != self :: JS && $ strType != self :: SCSS && $ strType != self :: LESS ) { throw new \ InvalidArgumentException ( "Invalid file $strFile" ) ; } $ strMode = ( $ strType == self :: JS ) ? self :: JS : self :: CSS ; if ( $ this -> strMode === null ) { $ this -> strMode = $ strMode ; } elseif ( $ this -> strMode != $ strMode ) { throw new \ LogicException ( 'You cannot mix different file types. Create another Combiner object instead.' ) ; } if ( ! file_exists ( $ this -> strRootDir . '/' . $ strFile ) ) { if ( file_exists ( $ this -> strRootDir . '/' . $ this -> strWebDir . '/' . $ strFile ) ) { $ strFile = $ this -> strWebDir . '/' . $ strFile ; } else { return ; } } if ( isset ( $ this -> arrFiles [ $ strFile ] ) ) { return ; } if ( $ strVersion === null ) { $ strVersion = filemtime ( $ this -> strRootDir . '/' . $ strFile ) ; } $ arrFile = array ( 'name' => $ strFile , 'version' => $ strVersion , 'media' => $ strMedia , 'extension' => $ strType ) ; $ this -> arrFiles [ $ strFile ] = $ arrFile ; $ this -> strKey .= '-f' . $ strFile . '-v' . $ strVersion . '-m' . $ strMedia ; }
5713	public function updateItemEditForm ( $ form ) { if ( $ this -> owner -> record -> stat ( 'better_buttons_enabled' ) !== true ) { return false ; } Requirements :: css ( BETTER_BUTTONS_DIR . '/css/gridfield_betterbuttons.css' ) ; Requirements :: javascript ( BETTER_BUTTONS_DIR . '/javascript/gridfield_betterbuttons.js' ) ; $ actions = $ this -> owner -> record -> getBetterButtonsActions ( ) ; $ form -> setActions ( $ this -> filterFieldList ( $ form , $ actions ) ) ; if ( $ form -> Fields ( ) -> hasTabSet ( ) ) { $ form -> Fields ( ) -> findOrMakeTab ( 'Root' ) -> setTemplate ( TabSet :: class ) ; $ form -> addExtraClass ( 'cms-tabset' ) ; } $ utils = $ this -> owner -> record -> getBetterButtonsUtils ( ) ; $ form -> Utils = $ this -> filterFieldList ( $ form , $ utils ) ; $ form -> setTemplate ( [ 'type' => 'Includes' , 'BetterButtons_EditForm' , ] ) ; $ form -> addExtraClass ( 'better-buttons-form' ) ; }
2650	public function validateServiceVersion ( $ version ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/validate' ; $ result = $ this -> _fetch ( $ url , 'GET' ) ; if ( $ result -> status == 'error' ) { throw new LocalizedException ( __ ( 'Failed to validate service version: ' . $ result -> msg ) ) ; } }
9629	protected function getRouteIdentifier ( Route $ route ) : string { return empty ( $ route -> getName ( ) ) ? $ route -> getTarget ( ) : $ route -> getName ( ) ; }
7875	protected function settleRepositoryIfNotExists ( ) { $ source = $ this -> pipelines -> getSource ( ) ; if ( ! $ this -> files -> exists ( $ source ) ) { $ this -> pipelines -> settle ( ) ; } }
5686	public function expandUrl ( $ url ) { if ( ! is_object ( $ url ) ) { $ url = new SimpleUrl ( $ url ) ; } $ location = $ this -> getBaseUrl ( ) ? $ this -> getBaseUrl ( ) : new SimpleUrl ( ) ; return $ url -> makeAbsolute ( $ location -> makeAbsolute ( $ this -> getUrl ( ) ) ) ; }
9485	public function checkCreatable ( ) { if ( property_exists ( $ this , 'id' ) && $ this -> id > 0 ) { throw new \ Exception ( get_class ( $ this ) . " has ID:" . $ this -> id ( ) . " thus not creatable." ) ; } }
6167	protected function writePerformance ( $ time ) { $ ms = round ( $ time * 1000 ) ; foreach ( self :: $ performanceThresholds as $ colour => $ threshold ) { if ( $ ms > $ threshold ) { break ; } } $ this -> writeWithColor ( $ colour , " ($ms ms)" ) ; }
2350	public function copyTo ( $ strNewName ) { $ strParent = \ dirname ( $ strNewName ) ; if ( ! is_dir ( $ this -> strRootDir . '/' . $ strParent ) ) { new Folder ( $ strParent ) ; } $ return = $ this -> Files -> copy ( $ this -> strFile , $ strNewName ) ; $ syncSource = Dbafs :: shouldBeSynchronized ( $ this -> strFile ) ; $ syncTarget = Dbafs :: shouldBeSynchronized ( $ strNewName ) ; if ( $ syncSource && $ syncTarget ) { Dbafs :: copyResource ( $ this -> strFile , $ strNewName ) ; } elseif ( $ syncTarget ) { Dbafs :: addResource ( $ strNewName ) ; } return $ return ; }
3959	public function parseValue ( $ strOutputFormat = 'text' , $ objSettings = null ) { $ this -> registerAssets ( $ objSettings ) ; $ arrResult = [ 'raw' => $ this -> arrData , 'text' => [ ] , 'attributes' => [ ] , $ strOutputFormat => [ ] , 'class' => '' , 'actions' => [ ] ] ; if ( ! $ objSettings ) { foreach ( $ this -> getMetaModel ( ) -> getAttributes ( ) as $ objAttribute ) { $ arrResult [ 'attributes' ] [ $ objAttribute -> getColName ( ) ] = $ objAttribute -> getName ( ) ; foreach ( $ this -> internalParseAttribute ( $ objAttribute , $ strOutputFormat , null ) as $ strKey => $ varValue ) { $ arrResult [ $ strKey ] [ $ objAttribute -> getColName ( ) ] = $ varValue ; } } return $ arrResult ; } $ jumpTo = $ this -> buildJumpToLink ( $ objSettings ) ; if ( true === $ jumpTo [ 'deep' ] ) { $ arrResult [ 'actions' ] [ 'jumpTo' ] = [ 'href' => $ jumpTo [ 'url' ] , 'label' => $ this -> getCaptionText ( 'details' ) , 'class' => 'details' ] ; } $ arrResult [ 'jumpTo' ] = $ jumpTo ; foreach ( $ objSettings -> getSettingNames ( ) as $ strAttrName ) { $ objAttribute = $ this -> getMetaModel ( ) -> getAttribute ( $ strAttrName ) ; if ( $ objAttribute ) { $ arrResult [ 'attributes' ] [ $ objAttribute -> getColName ( ) ] = $ objAttribute -> getName ( ) ; foreach ( $ this -> internalParseAttribute ( $ objAttribute , $ strOutputFormat , $ objSettings ) as $ strKey => $ varValue ) { $ arrResult [ $ strKey ] [ $ objAttribute -> getColName ( ) ] = $ varValue ; } } } if ( $ this -> getMetaModel ( ) -> hasVariants ( ) ) { $ arrResult [ 'class' ] = $ this -> variantCssClass ( ) ; } $ event = new ParseItemEvent ( $ objSettings , $ this , $ strOutputFormat , $ arrResult ) ; $ this -> getEventDispatcher ( ) -> dispatch ( MetaModelsEvents :: PARSE_ITEM , $ event ) ; return $ event -> getResult ( ) ; }
3037	public function set ( $ userId , $ callId , $ data ) { $ key = $ this -> getCacheKey ( $ userId , $ callId ) ; $ cache = $ this -> getFromCache ( $ key ) ; if ( is_null ( $ cache ) || $ cache != $ data ) { $ this -> putInCache ( $ key , $ userId , $ callId , $ data , self :: STATE_PENDING_WRITE ) ; } return true ; }
291	public function populateRelation ( $ name , $ records ) { foreach ( $ this -> _relationsDependencies as & $ relationNames ) { unset ( $ relationNames [ $ name ] ) ; } $ this -> _related [ $ name ] = $ records ; }
6763	public function append ( Collection $ collection ) { if ( ! $ collection ) return $ this ; $ this -> models = array_merge ( $ this -> array ( ) , $ collection -> array ( ) ) ; return $ this ; }
10576	public static function applyStyle ( $ text , $ style ) { $ foreground = self :: getForeground ( $ style ) ; $ background = self :: getBackground ( $ style ) ; return self :: apply ( $ text , $ foreground , $ background ) ; }
2387	private function explode ( string $ palette ) : array { if ( '' === $ palette ) { return [ ] ; } $ legendCount = 0 ; $ legendMap = [ ] ; $ groups = StringUtil :: trimsplit ( ';' , $ palette ) ; foreach ( $ groups as $ group ) { if ( '' === $ group ) { continue ; } $ hide = false ; $ fields = StringUtil :: trimsplit ( ',' , $ group ) ; if ( preg_match ( '#\{(.+?)(:hide)?\}#' , $ fields [ 0 ] , $ matches ) ) { $ legend = $ matches [ 1 ] ; $ hide = \ count ( $ matches ) > 2 && ':hide' === $ matches [ 2 ] ; array_shift ( $ fields ) ; } else { $ legend = $ legendCount ++ ; } $ legendMap [ $ legend ] = compact ( 'fields' , 'hide' ) ; } return $ legendMap ; }
2111	private function askForPassword ( string $ label , InputInterface $ input , OutputInterface $ output ) : string { $ question = new Question ( $ label ) ; $ question -> setHidden ( true ) ; $ question -> setMaxAttempts ( 3 ) ; $ helper = $ this -> getHelper ( 'question' ) ; return $ helper -> ask ( $ input , $ output , $ question ) ; }
11064	public function upperFirst ( ) { $ this -> value = mb_strtoupper ( mb_substr ( $ this -> value , 0 , 1 , 'UTF-8' ) , 'UTF-8' ) . mb_substr ( $ this -> value , 1 , null , 'UTF-8' ) ; return $ this ; }
468	public function buildSimpleCondition ( $ operator , $ operands , & $ params ) { array_unshift ( $ operands , $ operator ) ; return $ this -> buildCondition ( $ operands , $ params ) ; }
2329	public function delete ( ) { if ( $ this -> intIndex < 0 ) { $ this -> first ( ) ; } return $ this -> arrModels [ $ this -> intIndex ] -> delete ( ) ; }
1079	public static function enable ( $ enable = true ) { if ( $ enable === true ) { self :: $ enableWarnings = self :: ALL ; } elseif ( $ enable === false ) { self :: $ enableWarnings = 0 ; } else { self :: $ enableWarnings |= $ enable ; } }
11517	protected function GenerateIOSPinicon ( SiteConfig $ config , SiteTree $ owner , & $ metadata , Image $ IOSPinicon ) { $ metadata .= $ this -> owner -> MarkupComment ( 'iOS Pinned Icon' ) ; if ( $ config -> fetchPiniconTitle ( ) ) { $ metadata .= $ owner -> MarkupMeta ( 'apple-mobile-web-app-title' , $ config -> fetchPiniconTitle ( ) ) ; } $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 57 , 57 ) -> getAbsoluteURL ( ) , 'image/png' ) ; $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 60 , 60 ) -> getAbsoluteURL ( ) , 'image/png' , '60x60' ) ; $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 72 , 72 ) -> getAbsoluteURL ( ) , 'image/png' , '72x72' ) ; $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 76 , 76 ) -> getAbsoluteURL ( ) , 'image/png' , '76x76' ) ; $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 114 , 114 ) -> getAbsoluteURL ( ) , 'image/png' , '114x114' ) ; $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 120 , 120 ) -> getAbsoluteURL ( ) , 'image/png' , '120x120' ) ; $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 144 , 144 ) -> getAbsoluteURL ( ) , 'image/png' , '144x144' ) ; $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 152 , 152 ) -> getAbsoluteURL ( ) , 'image/png' , '152x152' ) ; $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 180 , 180 ) -> getAbsoluteURL ( ) , 'image/png' , '180x180' ) ; }
12589	protected function sendEmails ( ContactInquiry $ inquiry ) { $ recipients = $ this -> container -> getParameter ( 'c33s_contact_form.email.recipients' ) ; if ( $ this -> container -> getParameter ( 'c33s_contact_form.email.send_copy_to_user' ) && $ inquiry -> hasSenderEmail ( ) ) { $ recipients [ ] = $ inquiry -> getSenderEmail ( ) ; } if ( empty ( $ recipients ) ) { return ; } $ translator = $ this -> get ( 'translator' ) ; $ subject = $ this -> container -> getParameter ( 'c33s_contact_form.email.subject' ) ; $ message = \ Swift_Message :: newInstance ( ) -> setSubject ( $ translator -> trans ( $ subject , array ( ) , 'C33sContactForm' ) ) -> setFrom ( $ this -> container -> getParameter ( 'c33s_contact_form.email.sender_email' ) ) -> setTo ( $ recipients ) -> setBody ( $ this -> renderView ( 'C33sContactFormBundle:ContactForm:email.txt.twig' , array ( 'inquiry' => $ inquiry ) ) ) ; $ this -> get ( 'mailer' ) -> send ( $ message ) ; }
2774	public function setPrivateKey ( string $ privateKey , int $ port = 22 , ? string $ wrapper = null ) : void { if ( $ wrapper === null ) { $ wrapper = __DIR__ . '/../bin/git-ssh-wrapper.sh' ; } if ( ! $ wrapperPath = realpath ( $ wrapper ) ) { throw new GitException ( 'Path to GIT_SSH wrapper script could not be resolved: ' . $ wrapper ) ; } if ( ! $ privateKeyPath = realpath ( $ privateKey ) ) { throw new GitException ( 'Path private key could not be resolved: ' . $ privateKey ) ; } $ this -> setEnvVar ( 'GIT_SSH' , $ wrapperPath ) ; $ this -> setEnvVar ( 'GIT_SSH_KEY' , $ privateKeyPath ) ; $ this -> setEnvVar ( 'GIT_SSH_PORT' , $ port ) ; }
11696	protected function normaliseSrcInput ( $ input ) : array { $ output = [ ] ; if ( $ input instanceof Finder ) { foreach ( $ input as $ fileInfo ) { $ output [ ] = $ fileInfo -> getRealpath ( ) ; } } else { if ( ! is_array ( $ input ) ) $ input = [ $ input ] ; if ( count ( $ input ) === 0 ) throw new \ UnexpectedValueException ; if ( ! is_string ( $ input [ 0 ] ) ) throw new \ UnexpectedValueException ; $ output = $ input ; } return $ output ; }
12544	public function setLink ( string $ link = null ) : \ TheCMSThread \ Core \ Main \ View { $ this -> link = $ link ; return $ this ; }
1038	private function executeFields ( ObjectType $ parentType , $ source , $ path , $ fields ) { $ containsPromise = false ; $ finalResults = [ ] ; foreach ( $ fields as $ responseName => $ fieldNodes ) { $ fieldPath = $ path ; $ fieldPath [ ] = $ responseName ; $ result = $ this -> resolveField ( $ parentType , $ source , $ fieldNodes , $ fieldPath ) ; if ( $ result === self :: $ UNDEFINED ) { continue ; } if ( ! $ containsPromise && $ this -> getPromise ( $ result ) ) { $ containsPromise = true ; } $ finalResults [ $ responseName ] = $ result ; } if ( ! $ containsPromise ) { return self :: fixResultsIfEmptyArray ( $ finalResults ) ; } return $ this -> promiseForAssocArray ( $ finalResults ) ; }
11796	public function setSubject ( $ subject = '' , $ clear = false ) { if ( true === $ clear ) { $ this -> clear ( 'subject' ) ; } $ this -> subject = $ subject ; return $ this ; }
2348	public static function putContent ( $ strFile , $ strContent ) { $ objFile = new static ( $ strFile ) ; $ objFile -> write ( $ strContent ) ; $ objFile -> close ( ) ; }
3961	private function variantCssClass ( ) { if ( $ this -> isVariant ( ) ) { return 'variant' ; } if ( $ this -> isVariantBase ( ) ) { $ result = 'varbase' ; if ( 0 !== $ this -> getVariants ( null ) -> getCount ( ) ) { $ result .= ' varbase-with-variants' ; } return $ result ; } return '' ; }
9989	public function generateNavigation ( ) { if ( $ this -> spreadsheet === null ) { throw new WriterException ( 'Internal Spreadsheet object not set to an instance of an object.' ) ; } $ sheets = [ ] ; if ( $ this -> sheetIndex === null ) { $ sheets = $ this -> spreadsheet -> getAllSheets ( ) ; } else { $ sheets [ ] = $ this -> spreadsheet -> getSheet ( $ this -> sheetIndex ) ; } $ html = '' ; if ( count ( $ sheets ) > 1 ) { $ sheetId = 0 ; $ html .= '<ul class="navigation">' . PHP_EOL ; foreach ( $ sheets as $ sheet ) { $ html .= ' <li class="sheet' . $ sheetId . '"><a href="#sheet' . $ sheetId . '">' . $ sheet -> getTitle ( ) . '</a></li>' . PHP_EOL ; ++ $ sheetId ; } $ html .= '</ul>' . PHP_EOL ; } return $ html ; }
1752	public static function isInstalledLanguage ( $ strLanguage ) { if ( ! isset ( static :: $ arrLanguages [ $ strLanguage ] ) ) { $ rootDir = self :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( is_dir ( $ rootDir . '/vendor/contao/core-bundle/src/Resources/contao/languages/' . $ strLanguage ) ) { static :: $ arrLanguages [ $ strLanguage ] = true ; } elseif ( is_dir ( static :: getContainer ( ) -> getParameter ( 'kernel.cache_dir' ) . '/contao/languages/' . $ strLanguage ) ) { static :: $ arrLanguages [ $ strLanguage ] = true ; } else { $ files = static :: getContainer ( ) -> get ( 'contao.resource_finder' ) -> findIn ( 'languages' ) -> depth ( 0 ) -> directories ( ) -> name ( $ strLanguage ) ; static :: $ arrLanguages [ $ strLanguage ] = \ count ( $ files ) > 0 ; } } return static :: $ arrLanguages [ $ strLanguage ] ; }
9304	public function setFailureLogLifetime ( $ time ) { if ( ! is_numeric ( $ time ) ) { throw new \ InvalidArgumentException ( '`failureLogLifetime` expects integer value!' ) ; } $ this -> options [ 'failureLogLifetime' ] = ( int ) $ time ; return $ this ; }
11785	public function pagination ( $ begin , $ count ) { $ params = [ 'type' => 2 , 'begin' => intval ( $ begin ) , 'count' => intval ( $ count ) , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_SEARCH , $ params ] ) ; }
9066	public function persist ( MessageInterface $ message ) { if ( $ message -> getMessageId ( ) > 0 ) { $ this -> update ( $ message , null , null , new MessageHydrator ) ; } else { $ this -> insert ( $ message , null , new MessageHydrator ) ; } return $ message ; }
2375	public static function insertTagToSrc ( $ data ) { $ return = '' ; $ paths = preg_split ( '/((src|href)="([^"]*)\{\{file::([^"\}]+)\}\}")/i' , $ data , - 1 , PREG_SPLIT_DELIM_CAPTURE ) ; for ( $ i = 0 , $ c = \ count ( $ paths ) ; $ i < $ c ; $ i += 5 ) { $ return .= $ paths [ $ i ] ; if ( ! isset ( $ paths [ $ i + 1 ] ) ) { continue ; } $ file = FilesModel :: findByUuid ( $ paths [ $ i + 4 ] ) ; if ( $ file !== null ) { $ return .= $ paths [ $ i + 2 ] . '="' . $ paths [ $ i + 3 ] . $ file -> path . '"' ; } else { $ return .= $ paths [ $ i + 2 ] . '="' . $ paths [ $ i + 3 ] . $ paths [ $ i + 4 ] . '"' ; } } return $ return ; }
6720	public function authorize ( ) { $ this -> validateAuthParams ( ) ; try { $ response = $ this -> curl -> setOption ( CURLOPT_POSTFIELDS , http_build_query ( array ( 'grant_type' => self :: GRANT_TYPE_AUTHORIZATION_CODE , 'client_id' => $ this -> clientId , 'client_secret' => $ this -> clientSecret , 'response_type' => self :: RESPONSE_TYPE_CODE , 'state' => self :: STATE_ALIVE ) ) ) -> post ( $ this -> authUrl , false ) ; } catch ( InvalidParamException $ invalidParamException ) { throw new Oauth2ClientException ( $ invalidParamException -> getMessage ( ) ) ; } return $ this -> handleAuthorizeResponse ( $ response ) ; }
1185	public function resolver ( $ field ) { return function ( $ translator , $ data , $ rules , $ messages , $ customAttributes ) use ( $ field ) { return $ this -> resolve ( $ translator , $ data , $ rules , $ messages , $ customAttributes , $ field ) ; } ; }
11070	public function setBoolean ( string $ key , $ value , bool $ ignoredDefaultValue = null ) { $ this -> set ( $ key , ( bool ) $ value , $ ignoredDefaultValue ) ; return $ this ; }
7702	function OpenDoc_GetDraw ( $ Tag , $ Txt , $ Pos , $ Forward , $ LevelStop ) { return $ this -> XML_BlockAlias_Prefix ( 'draw:' , $ Txt , $ Pos , $ Forward , $ LevelStop ) ; }
5343	public function build ( SoapClientBuilderInterface $ builder ) { $ builder -> createWsdl ( $ this -> endpoint ) ; $ builder -> createSoapClient ( ) ; $ builder -> setLogin ( $ this -> login ) ; $ builder -> setMode ( $ this -> mode ) ; $ builder -> setClientVersion ( self :: CLIENT_VERSION ) ; return $ builder -> getSoapClient ( ) ; }
11832	public function getCache ( ) { if ( ! $ this -> cache ) { $ services = $ this -> getServices ( ) ; $ cache = $ services -> get ( 'Cache' ) ; $ this -> setCache ( $ cache ) ; } return $ this -> cache ; }
5369	protected function isOnlyAscii ( $ ascii ) { for ( $ i = 0 , $ length = strlen ( $ ascii ) ; $ i < $ length ; $ i ++ ) { if ( ord ( $ ascii [ $ i ] ) > 127 ) { return false ; } } return true ; }
2107	public static function findOneByRelatedTableAndId ( $ strTable , $ intId , array $ arrOptions = array ( ) ) { @ trigger_error ( 'Using the Contao\OptInModel::findOneByRelatedTableAndIds() method has been deprecated and will no longer work in Contao 5.0. Use the Contao\OptInModel::findByRelatedTableAndIds() method instead.' , E_USER_DEPRECATED ) ; $ t = static :: $ strTable ; $ objDatabase = Database :: getInstance ( ) ; $ objResult = $ objDatabase -> prepare ( "SELECT * FROM $t WHERE id IN (SELECT pid FROM tl_opt_in_related WHERE relTable=? AND relId=?)" ) -> execute ( $ strTable , $ intId ) ; if ( $ objResult -> numRows < 1 ) { return null ; } $ objRegistry = Registry :: getInstance ( ) ; if ( $ objOptIn = $ objRegistry -> fetch ( $ t , $ objResult -> id ) ) { return $ objOptIn ; } return new static ( $ objResult ) ; }
3457	protected function replay ( Iterator $ historyEvents ) : void { foreach ( $ historyEvents as $ pastEvent ) { $ this -> version = $ pastEvent -> version ( ) ; $ this -> apply ( $ pastEvent ) ; } }
3399	public function get ( $ arguments = [ ] ) { try { $ this -> makeRequest ( $ arguments ) ; } catch ( ConnectException $ e ) { $ url = $ e -> getRequest ( ) -> getUrl ( ) ; return $ this -> errorResponse ( $ e -> getCode ( ) , $ e -> getMessage ( ) , $ url ) ; } catch ( RequestException $ e ) { $ url = $ e -> getRequest ( ) -> getUrl ( ) ; $ status = $ e -> getCode ( ) ; $ response = $ e -> getResponse ( ) ; $ reason = $ e -> getMessage ( ) ; if ( ! is_null ( $ response ) ) { $ reason = $ response -> getReasonPhrase ( ) ; } return $ this -> errorResponse ( $ status , $ reason , $ url ) ; } return $ this -> parseBlueprint ( $ this -> schemaBlueprint ) ; }
7420	protected function getNumList ( ) : array { preg_match_all ( '/\/\d+/u' , $ this -> request -> route ( ) , $ numList ) ; $ numList = $ numList [ 0 ] ; $ numList = array_map ( function ( $ val ) { return intval ( ltrim ( $ val , '/' ) ) ; } , $ numList ) ; return $ numList ; }
3439	public function section ( $ load = false ) { $ fields = $ this -> getFields ( ) ; $ sectionModel = static :: sectionModel ( ) ; return $ load ? $ sectionModel :: query ( ) -> getById ( $ fields [ 'IBLOCK_SECTION_ID' ] ) : new $ sectionModel ( $ fields [ 'IBLOCK_SECTION_ID' ] ) ; }
8893	protected function registerFactory ( $ key , callable $ callable , $ shared = true ) { $ this -> sm -> setFactory ( $ key , new CallbackWrapper ( $ this , $ callable ) ) ; $ this -> sm -> setShared ( $ key , $ shared ) ; }
1012	private function readDigits ( ) { [ $ char , $ code ] = $ this -> readChar ( ) ; if ( $ code >= 48 && $ code <= 57 ) { $ value = '' ; do { $ value .= $ char ; [ $ char , $ code ] = $ this -> moveStringCursor ( 1 , 1 ) -> readChar ( ) ; } while ( $ code >= 48 && $ code <= 57 ) ; return $ value ; } if ( $ this -> position > $ this -> source -> length - 1 ) { $ code = null ; } throw new SyntaxError ( $ this -> source , $ this -> position , 'Invalid number, expected digit but got: ' . Utils :: printCharCode ( $ code ) ) ; }
1284	private function resolveLinksForResourceType ( string $ type , array $ links , string $ locale = null ) : array { $ resourceIds = \ array_map ( function ( Link $ link ) : string { return $ link -> getId ( ) ; } , \ array_filter ( $ links , function ( Link $ link ) use ( $ type ) : bool { return $ link -> getLinkType ( ) === $ type ; } ) ) ; $ resources = [ ] ; $ collection = $ this -> fetchResourcesForGivenIds ( $ resourceIds , $ type , $ locale ) ; foreach ( $ collection as $ resource ) { $ resources [ $ type . '.' . $ resource -> getId ( ) ] = $ resource ; } return $ resources ; }
8639	public function setDirectPaymentList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'DirectPaymentList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
123	public function binaryVersion ( ) { if ( ! self :: $ version ) { if ( 0 === $ this -> process -> execute ( 'svn --version' , $ output ) ) { if ( preg_match ( '{(\d+(?:\.\d+)+)}' , $ output , $ match ) ) { self :: $ version = $ match [ 1 ] ; } } } return self :: $ version ; }
6976	protected function scheduleSaleContentChangeEvent ( Model \ AdjustmentInterface $ adjustment ) { if ( $ adjustment instanceof Model \ SaleAdjustmentInterface ) { if ( null === $ sale = $ this -> getSaleFromAdjustment ( $ adjustment ) ) { return ; } } elseif ( $ adjustment instanceof Model \ SaleItemAdjustmentInterface ) { if ( null === $ item = $ this -> getItemFromAdjustment ( $ adjustment ) ) { return ; } if ( null === $ sale = $ this -> getSaleFromItem ( $ item ) ) { return ; } } else { throw new InvalidArgumentException ( "Unexpected adjustment type." ) ; } $ this -> persistenceHelper -> scheduleEvent ( $ this -> getSaleChangeEvent ( ) , $ sale ) ; }
8074	public function delete ( $ endpoint , $ headers = [ ] ) { $ request = new Request ( 'DELETE' , $ endpoint , $ headers ) ; $ response = $ this -> guzzle -> send ( $ request ) ; return $ this -> handle ( $ response ) ; }
4084	public function getParentOf ( $ metaModel ) { $ metaModelName = $ this -> getMetaModelName ( $ metaModel ) ; return isset ( $ this -> childMap [ $ metaModelName ] ) ? $ this -> childMap [ $ metaModelName ] : null ; }
9157	final public function call ( $ action , Request $ request , View $ view ) { $ this -> request = $ request ; ob_start ( ) ; $ rf = new \ ReflectionMethod ( $ this , $ action ) ; $ anno = $ rf -> getDocComment ( ) ; $ matches = array ( ) ; if ( preg_match ( '#@responseType ([\w\/]+)#' , $ anno , $ matches ) ) { $ this -> response -> setType ( $ matches [ 1 ] ) ; } if ( preg_match ( '#@title ([^\\n]+)#' , $ anno , $ matches ) ) { $ this -> response -> setTitle ( $ matches [ 1 ] ) ; } $ rf -> invoke ( $ this , $ this -> request ) ; $ this -> response -> appendBody ( ob_get_clean ( ) ) ; $ view -> render ( $ this -> response , $ request , $ this -> viewParams ) ; $ this -> addControls ( $ this -> response , $ request , $ view ) ; return $ this -> response ; }
2874	public function enableAction ( ) { $ moduleName = ( string ) $ this -> getRequest ( ) -> getParam ( 'module' ) ; try { $ this -> getService ( ) -> setModuleStatus ( $ moduleName , true ) ; $ this -> getService ( ) -> flushCache ( ) ; Mage :: getSingleton ( 'core/session' ) -> addSuccess ( 'Module was enabled.' ) ; } catch ( Exception $ e ) { Mage :: getSingleton ( 'core/session' ) -> addError ( 'Unable to enable module: ' . $ e -> getMessage ( ) ) ; } $ this -> _redirectReferer ( ) ; }
3386	public function authenticate ( $ identity , $ credential ) { $ adapter = $ this -> auth -> getAdapter ( ) ; $ adapter -> setIdentity ( $ identity ) ; $ adapter -> setCredential ( $ credential ) ; return $ this -> auth -> authenticate ( ) ; }
3040	public function del ( $ userId , $ callId ) { $ key = $ this -> getCacheKey ( $ userId , $ callId ) ; $ this -> putInCache ( $ key , $ userId , $ callId , null , self :: STATE_PENDING_DELETE ) ; return true ; }
5104	public function execute ( ) { if ( is_null ( $ this -> conn ) ) throw new SquidException ( "Can't execute query, implicitly created without connection!" ) ; $ cmd = $ this -> assemble ( ) ; $ bind = $ this -> bind ( ) ; return $ this -> conn -> execute ( $ cmd , $ bind ) ; }
11714	public function getTokenFromServer ( ) { $ params = [ 'appid' => $ this -> appId , 'secret' => $ this -> secret , 'grant_type' => 'client_credential' , ] ; $ http = $ this -> getHttp ( ) ; $ token = $ http -> parseJSON ( $ http -> get ( self :: API_TOKEN_GET , $ params ) ) ; if ( empty ( $ token [ $ this -> tokenJsonKey ] ) ) { throw new HttpException ( 'Request AccessToken fail. response: ' . json_encode ( $ token , JSON_UNESCAPED_UNICODE ) ) ; } return $ token ; }
5454	protected function hasNamedTagOnOpenTagStack ( $ name ) { return isset ( $ this -> tags [ $ name ] ) && ( count ( $ this -> tags [ $ name ] ) > 0 ) ; }
10041	function toString ( ) { return "Rule [isCustomfield=" . ( $ this -> isCustomfield ) ? "true" : "false" . ", field=" . $ this -> field . ", operator=" . $ this -> operator . ", value=" . $ this -> value . " (type = " . $ this -> type . ")" ; }
6258	public function authorizeByControllerAndAction ( $ user , Request $ request ) { $ roleField = $ this -> _config [ 'roleField' ] ; extract ( $ this -> getControllerNameAndAction ( $ request ) ) ; $ actionMap = $ this -> getActionMap ( ) ; if ( isset ( $ actionMap [ $ name ] [ '*' ] ) ) { if ( $ this -> _isAllowedRole ( $ user [ $ roleField ] , $ actionMap [ $ name ] [ '*' ] ) ) { return true ; } } if ( isset ( $ actionMap [ $ name ] [ $ action ] ) ) { if ( $ this -> _isAllowedRole ( $ user [ $ roleField ] , $ actionMap [ $ name ] [ $ action ] ) ) { return true ; } } if ( $ this -> config ( 'undefinedActionsAreAllowed' ) === true ) { return true ; } return false ; }
9656	public function merge ( array $ routes ) { foreach ( $ routes as $ name => $ route ) { $ this -> override ( $ name , $ route ) ; } }
8504	public function confirmTransportRequest ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_ConfirmTransportInputRequest ) ) { $ request = new FBAInboundServiceMWS_Model_ConfirmTransportInputRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ConfirmTransportRequest' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_ConfirmTransportRequestResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
1331	public function queryToOne ( $ relation , EncodingParametersInterface $ parameters ) { return $ this -> queryOne ( $ relation -> newQuery ( ) , $ this -> getQueryParameters ( $ parameters ) ) ; }
12300	public function storeChild ( $ id , $ relation , array $ data ) { $ parent = $ this -> model -> find ( $ id ) ; if ( ! $ parent ) { return null ; } $ resource = $ parent -> $ relation ( ) -> create ( $ data ) ; return $ resource ; }
5325	protected function lockExecute ( callable $ task ) { if ( $ this -> mutex -> isAcquired ( ) ) { return $ task ( ) ; } return $ this -> mutex -> lockExecute ( $ task ) ; }
4355	protected function checkTimestamp ( $ val ) { $ secs = 86400 * 90 ; $ tsNow = \ time ( ) ; if ( $ val > $ tsNow - $ secs && $ val < $ tsNow + $ secs ) { return \ date ( 'Y-m-d H:i:s' , $ val ) ; } return false ; }
3163	public function startTimer ( RunnerServiceContext $ context , $ timestamp = null ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ session = $ context -> getTestSession ( ) ; if ( $ session -> getState ( ) === AssessmentTestSessionState :: INTERACTING ) { $ session -> startItemTimer ( $ timestamp ) ; } } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'startTimer' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } return true ; }
9417	public function fwhm ( ) { $ float_fwhm = 2 * sqrt ( 2 * log ( 2 ) ) * $ this -> float_sigma ; if ( $ this -> int_precision ) { return round ( $ float_fwhm , $ this -> int_precision ) ; } return $ float_fwhm ; }
12646	public function setTrue ( $ obData = null ) { $ this -> bStatus = true ; $ this -> obData = $ obData ; return $ this ; }
5278	public function orWhere ( $ column , $ param1 = null , $ param2 = null ) { return $ this -> where ( $ column , $ param1 , $ param2 , 'or' ) ; }
66	public function isSymlinkedDirectory ( $ directory ) { if ( ! is_dir ( $ directory ) ) { return false ; } $ resolved = $ this -> resolveSymlinkedDirectorySymlink ( $ directory ) ; return is_link ( $ resolved ) ; }
10409	protected function getUrlsByDocumentParameter ( ) { if ( count ( $ this -> documentParamCache ) < 1 ) { return [ ] ; } $ urls = [ ] ; $ query = new Query ( ) ; $ queryTerms = [ ] ; foreach ( $ this -> documentParamCache as $ param ) { $ queryTerms [ $ param [ 0 ] ] [ ] = $ param [ 1 ] ; } foreach ( $ queryTerms as $ field => $ values ) { $ termQuery = new TermQuery ( $ field , $ values ) ; $ query -> addQuery ( $ termQuery , 'should' ) ; } $ limitFilter = new LimitFilter ( count ( $ this -> documentParamCache ) ) ; $ repository = $ this -> manager -> getRepository ( 'MultiModel' ) ; $ search = $ repository -> createSearch ( ) -> addQuery ( $ query ) -> addFilter ( $ limitFilter ) ; $ documents = $ repository -> execute ( $ search ) ; foreach ( $ documents as $ document ) { if ( is_array ( $ document -> url ) ) { foreach ( $ document -> url as $ url ) { $ urls [ ] = $ url [ 'url' ] ; } } } array_walk ( $ urls , [ $ this , 'addWildcard' ] ) ; $ this -> addUrls ( $ urls ) ; return $ urls ; }
5246	public function get ( string $ path ) : string { if ( ! $ this -> isFile ( $ path ) ) { throw new RuntimeException ( 'File does not exist at path ' . $ path ) ; } return file_get_contents ( $ path ) ; }
10213	public function getSharedComponent ( ) { switch ( $ this -> parentPropertyName ) { case 'allBorders' : case 'horizontal' : case 'inside' : case 'outline' : case 'vertical' : throw new PhpSpreadsheetException ( 'Cannot get shared component for a pseudo-border.' ) ; break ; case 'bottom' : return $ this -> parent -> getSharedComponent ( ) -> getBottom ( ) ; case 'diagonal' : return $ this -> parent -> getSharedComponent ( ) -> getDiagonal ( ) ; case 'left' : return $ this -> parent -> getSharedComponent ( ) -> getLeft ( ) ; case 'right' : return $ this -> parent -> getSharedComponent ( ) -> getRight ( ) ; case 'top' : return $ this -> parent -> getSharedComponent ( ) -> getTop ( ) ; } }
3974	protected function build ( IMetaModelDataDefinition $ container ) { $ inputScreen = $ this -> viewCombination -> getScreen ( $ container -> getName ( ) ) ; if ( ! $ inputScreen ) { return ; } $ meta = $ inputScreen [ 'meta' ] ; $ config = $ this -> getDataProviderDefinition ( $ container ) ; if ( ! $ config -> hasInformation ( $ container -> getName ( ) ) ) { $ providerInformation = new ContaoDataProviderInformation ( ) ; $ providerInformation -> setName ( $ container -> getName ( ) ) ; $ config -> addInformation ( $ providerInformation ) ; } else { $ providerInformation = $ config -> getInformation ( $ container -> getName ( ) ) ; } $ basicDefinition = $ container -> getBasicDefinition ( ) ; if ( $ providerInformation instanceof ContaoDataProviderInformation ) { $ providerInformation -> setTableName ( $ container -> getName ( ) ) -> setClassName ( Driver :: class ) -> setInitializationData ( [ 'source' => $ container -> getName ( ) ] ) -> setVersioningEnabled ( false ) ; $ basicDefinition -> setDataProvider ( $ container -> getName ( ) ) ; } if ( $ basicDefinition -> getMode ( ) == BasicDefinitionInterface :: MODE_HIERARCHICAL ) { $ basicDefinition -> setRootDataProvider ( $ container -> getName ( ) ) ; } if ( 'ctable' === $ meta [ 'rendertype' ] ) { $ parentTable = $ meta [ 'ptable' ] ; if ( ! $ config -> hasInformation ( $ parentTable ) ) { $ providerInformation = new ContaoDataProviderInformation ( ) ; $ providerInformation -> setName ( $ parentTable ) ; $ config -> addInformation ( $ providerInformation ) ; } else { $ providerInformation = $ config -> getInformation ( $ parentTable ) ; } if ( $ providerInformation instanceof ContaoDataProviderInformation ) { $ providerInformation -> setTableName ( $ parentTable ) -> setInitializationData ( [ 'source' => $ parentTable ] ) ; if ( in_array ( $ parentTable , $ this -> factory -> collectNames ( ) ) ) { $ providerInformation -> setClassName ( Driver :: class ) ; } $ basicDefinition -> setParentDataProvider ( $ parentTable ) ; } } }
7602	public function render ( FormInterface $ oForm , $ sMessage , $ bDismissable = false ) { $ errorHtml = sprintf ( $ this -> messageOpenFormat , $ sMessage ) ; $ sMessagesArray = array ( ) ; foreach ( $ oForm -> getMessages ( ) as $ fieldName => $ sMessages ) { foreach ( $ sMessages as $ sMessage ) { if ( $ oForm -> get ( $ fieldName ) -> getAttribute ( 'id' ) ) { $ sMessagesArray [ ] = sprintf ( '<a href="#%s">%s</a>' , $ oForm -> get ( $ fieldName ) -> getAttribute ( 'id' ) , $ oForm -> get ( $ fieldName ) -> getLabel ( ) . ': ' . $ sMessage ) ; } else { $ sMessagesArray [ ] = $ oForm -> get ( $ fieldName ) -> getLabel ( ) . ': ' . $ sMessage ; } } } return $ this -> dangerAlert ( $ errorHtml . implode ( $ this -> messageSeparatorString , $ sMessagesArray ) . $ this -> messageCloseString , $ bDismissable ) ; }
3940	private function setEmptyValue ( PropertyInterface $ property , array $ propInfo ) { if ( ! array_key_exists ( 'empty_value' , $ propInfo ) || ! ( $ property instanceof EmptyValueAwarePropertyInterface ) ) { return ; } $ property -> setEmptyValue ( $ propInfo [ 'empty_value' ] ) ; }
9416	public function max ( ) { $ float_max = 1 / ( $ this -> float_sigma * sqrt ( 2 * pi ( ) ) ) ; if ( $ this -> int_precision ) { return round ( $ float_max , $ this -> int_precision ) ; } return $ float_max ; }
9114	public function init ( ) { $ this -> registerController ( \ Nkey \ Caribu \ Mvc \ Controller \ ErrorController :: class ) ; $ this -> registerView ( \ Nkey \ Caribu \ Mvc \ View \ DefaultView :: class ) ; }
6176	public static function arrayUniqueMultidimensional ( array $ input ) { $ serialized = array_map ( 'serialize' , $ input ) ; $ unique = array_unique ( $ serialized ) ; $ output = array_intersect_key ( $ input , $ unique ) ; return array_values ( $ output ) ; }
10853	public function setLimit ( $ num , $ offset = 0 ) { $ this -> limit = ( int ) $ num ; $ this -> offset = ( int ) $ offset ; }
2695	public function execute ( Observer $ observer ) { if ( $ this -> fastlyConfig -> isFastlyEnabled ( ) != true ) { return ; } $ this -> response -> setHeader ( "x-esi" , "1" ) ; }
8649	private function calculateStringToSignV2 ( array $ parameters , $ queuepath = null ) { $ parsedUrl = parse_url ( $ this -> config [ 'ServiceURL' ] ) ; $ endpoint = $ parsedUrl [ 'host' ] ; if ( isset ( $ parsedUrl [ 'port' ] ) && ! is_null ( $ parsedUrl [ 'port' ] ) ) { $ endpoint .= ':' . $ parsedUrl [ 'port' ] ; } $ data = 'POST' ; $ data .= "\n" ; $ data .= $ endpoint ; $ data .= "\n" ; if ( $ queuepath ) { $ uri = $ queuepath ; } else { $ uri = "/" ; } $ uriencoded = implode ( "/" , array_map ( array ( $ this , "urlencode" ) , explode ( "/" , $ uri ) ) ) ; $ data .= $ uriencoded ; $ data .= "\n" ; uksort ( $ parameters , 'strcmp' ) ; $ data .= $ this -> getParametersAsString ( $ parameters ) ; return $ data ; }
7587	protected function extractFileName ( ) { foreach ( explode ( "\r\n" , $ this -> headers ) as $ header ) { if ( strpos ( $ header , 'filename' ) !== false && strpos ( $ header , 'Content-Disposition' ) !== false ) { $ fileName = substr ( $ header , ( strpos ( $ header , "=" ) + 1 ) ) ; $ this -> setFileName ( $ fileName ) ; break ; } } }
767	public function login ( IdentityInterface $ identity , $ duration = 0 ) { if ( $ this -> beforeLogin ( $ identity , false , $ duration ) ) { $ this -> switchIdentity ( $ identity , $ duration ) ; $ id = $ identity -> getId ( ) ; $ ip = Yii :: $ app -> getRequest ( ) -> getUserIP ( ) ; if ( $ this -> enableSession ) { $ log = "User '$id' logged in from $ip with duration $duration." ; } else { $ log = "User '$id' logged in from $ip. Session not enabled." ; } $ this -> regenerateCsrfToken ( ) ; Yii :: info ( $ log , __METHOD__ ) ; $ this -> afterLogin ( $ identity , false , $ duration ) ; } return ! $ this -> getIsGuest ( ) ; }
5300	public function getGlyphNames ( ) { $ glyphNames = array ( ) ; foreach ( $ this -> font -> getGlyphs ( ) as $ glyph ) { $ glyphNames [ static :: unicodeToHex ( $ glyph [ 'char' ] ) ] = empty ( $ glyph [ 'name' ] ) ? null : $ glyph [ 'name' ] ; } return $ glyphNames ; }
12950	public function beforeDelete ( ) { $ this -> _tagsForDelete = [ ] ; $ relation = $ this -> owner -> getRelation ( 'tagsList' , false ) ; if ( $ relation instanceof ActiveQuery ) { $ this -> _tagsForDelete = ( new Query ( ) ) -> select ( current ( $ relation -> link ) ) -> from ( $ relation -> via -> from [ 0 ] ) -> where ( [ key ( $ relation -> via -> link ) => $ this -> owner -> getPrimaryKey ( ) ] ) -> column ( $ this -> owner -> getDb ( ) ) ; } }
11095	public static function generatePin ( $ salt , $ length = 6 , $ useMinutes = false ) { $ seed = sha1 ( $ salt . ( new \ DateTime ( 'now' , new \ DateTimeZone ( 'Europe/Prague' ) ) ) -> format ( 'Ymd' . ( $ useMinutes ? 'i' : '' ) ) , true ) ; for ( $ i = 0 ; $ i <= ( new \ DateTime ( 'now' , new \ DateTimeZone ( 'Europe/Prague' ) ) ) -> format ( 'G' ) ; $ i ++ ) { $ seed = sha1 ( $ seed . $ i ) ; } $ data = unpack ( 'V1/V2' , $ seed ) ; $ data [ 1 ] = $ data [ 1 ] < 0 ? $ data [ 1 ] * - 1 : $ data [ 1 ] ; $ data [ 2 ] = $ data [ 2 ] < 0 ? $ data [ 2 ] * - 1 : $ data [ 2 ] ; $ mask = $ data [ 1 ] ^ $ data [ 2 ] ; if ( $ mask % 1000000 === 0 || $ mask % 1000000 === 999999 ) { return self :: generatePin ( $ salt . $ seed , $ length , $ useMinutes ) ; } return round ( ( ( ( float ) ( $ mask % 1000000 ) - 0.5 + ( ( float ) ( $ mask % 200 ) / 199 ) ) / 999999 ) * ( ( ( 10 ** $ length ) - 1 ) - ( 10 ** ( $ length - 1 ) ) ) + ( 10 ** ( $ length - 1 ) ) ) ; }
10220	public static function getConversionGroups ( ) { $ conversionGroups = [ ] ; foreach ( self :: $ conversionUnits as $ conversionUnit ) { $ conversionGroups [ ] = $ conversionUnit [ 'Group' ] ; } return array_merge ( array_unique ( $ conversionGroups ) ) ; }
2878	public function enableFPCDebugAction ( ) { try { $ this -> getService ( ) -> setFPCDebug ( 1 ) ; $ this -> getService ( ) -> flushCache ( ) ; $ message = $ this -> __ ( 'FPC debug was enabled' ) ; $ this -> getSession ( ) -> addSuccess ( $ message ) ; } catch ( Exception $ e ) { $ message = $ this -> __ ( 'FPC debug cannot be enabled: %s' , $ e -> getMessage ( ) ) ; $ this -> getSession ( ) -> addError ( $ message ) ; } $ this -> _redirectReferer ( ) ; }
3863	private function getCaptionText ( $ langKey ) { $ tableName = $ this -> getMetaModel ( ) -> getTableName ( ) ; if ( isset ( $ this -> objView ) && isset ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ tableName ] [ $ this -> objView -> get ( 'id' ) ] [ $ langKey ] ) ) { return $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ tableName ] [ $ this -> objView -> get ( 'id' ) ] [ $ langKey ] ; } elseif ( isset ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ tableName ] [ $ langKey ] ) ) { return $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ tableName ] [ $ langKey ] ; } return $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ langKey ] ; }
12219	public function errorHandler ( $ errno , $ errstr , $ errfile , $ errline , array $ errcontext = [ ] ) { $ codes = array ( 256 => 'E_USER_ERROR' , 512 => 'E_USER_WARNING' , 1024 => 'E_USER_NOTICE' , 2048 => 'E_STRICT' , 4096 => 'E_RECOVERABLE_ERROR' , 8192 => 'E_DEPRECATED' , 16384 => 'E_USER_DEPRECATED' , 8 => 'E_NOTICE' , 2 => 'E_WARNING' ) ; $ message = 'Error of level ' ; if ( array_key_exists ( $ errno , $ codes ) ) { $ message .= $ codes [ $ errno ] ; } else { $ message .= sprintf ( 'Unknown error level, code of %d passed' , $ errno ) ; } $ message .= sprintf ( '. Error message was "%s" in file %s at line %d.' , $ errstr , $ errfile , $ errline ) ; $ this -> container [ 'log' ] -> error ( $ message , $ errcontext ) ; $ this -> exceptionHandler ( new InternalServerError ( 'An unexpected error occurred.' ) ) ; }
5072	public function getHtmlMenu ( $ markup , $ topLevel = 1 , $ depth = 6 , RendererInterface $ renderer = null ) { if ( ! $ renderer ) { $ renderer = new ListRenderer ( new Matcher ( ) , [ 'currentClass' => 'active' , 'ancestorClass' => 'active_ancestor' ] ) ; } return $ renderer -> render ( $ this -> getMenu ( $ markup , $ topLevel , $ depth ) ) ; }
8174	protected function checkLoopUsageCondition ( Twig_TokenStream $ stream , Twig_NodeInterface $ node ) { if ( $ node instanceof Twig_Node_Expression_GetAttr && $ node -> getNode ( 'node' ) instanceof Twig_Node_Expression_Name && 'loop' == $ node -> getNode ( 'node' ) -> getAttribute ( 'name' ) ) { throw new Twig_Error_Syntax ( 'The "loop" variable cannot be used in a looping condition.' , $ node -> getTemplateLine ( ) , $ stream -> getSourceContext ( ) ) ; } foreach ( $ node as $ n ) { if ( ! $ n ) { continue ; } $ this -> checkLoopUsageCondition ( $ stream , $ n ) ; } }
11506	public function offsetSet ( $ slot , $ connection ) { if ( ! static :: isValid ( $ slot ) ) { throw new \ OutOfBoundsException ( "Invalid slot $slot for `$connection`" ) ; } $ this -> slots [ ( int ) $ slot ] = ( string ) $ connection ; }
5496	public function register ( $ method , $ args , $ action ) { $ args = $ this -> replaceWildcards ( $ args ) ; $ method = strtolower ( $ method ) ; if ( ! isset ( $ this -> always [ $ method ] ) ) { $ this -> always [ $ method ] = new SimpleSignatureMap ( ) ; } $ this -> always [ $ method ] -> add ( $ args , $ action ) ; }
11789	public function filesAction ( Request $ request , Application $ app ) { $ options = array ( "connector" => $ app [ "red_kite_cms.elfinder_files_connector" ] , ) ; return parent :: show ( $ options ) ; }
1817	public function deleteElement ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { $ objElement = $ this -> Database -> prepare ( "SELECT id FROM tl_content WHERE cteAlias=? AND type='alias'" ) -> limit ( 1 ) -> execute ( $ row [ 'id' ] ) ; return $ objElement -> numRows ? Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' : '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' ; }
2044	public static function create ( array $ parameters ) : ? Connection { $ params = [ 'driver' => 'pdo_mysql' , 'host' => $ parameters [ 'parameters' ] [ 'database_host' ] , 'port' => $ parameters [ 'parameters' ] [ 'database_port' ] , 'user' => $ parameters [ 'parameters' ] [ 'database_user' ] , 'password' => $ parameters [ 'parameters' ] [ 'database_password' ] , 'dbname' => $ parameters [ 'parameters' ] [ 'database_name' ] , ] ; try { return DriverManager :: getConnection ( $ params ) ; } catch ( DBALException $ e ) { } return null ; }
4542	public function postFlush ( PostFlushEventArgs $ args ) { $ maps = $ args -> getEntityManager ( ) -> getUnitOfWork ( ) -> getIdentityMap ( ) ; foreach ( $ maps as $ entities ) { foreach ( $ entities as $ entity ) { if ( ! $ entity instanceof Parameter ) { continue ; } $ entity -> setValue ( unserialize ( $ entity -> getValue ( ) ) ) ; } } }
8776	public function route ( $ name , array $ params = null , $ secure = false ) { $ routes = file_exists ( cache_path ( 'routes.php' ) ) ? require cache_path ( 'routes.php' ) : app ( 'route' ) -> getRoutes ( ) ; $ found = false ; foreach ( $ routes as $ key => $ value ) { if ( $ value [ 'alias' ] == $ name ) { $ found = true ; break ; } } if ( $ found ) { if ( strstr ( $ routes [ $ key ] [ 'route' ] , '{' ) ) { $ segment = explode ( '/' , $ routes [ $ key ] [ 'route' ] ) ; $ i = 0 ; foreach ( $ segment as $ key => $ value ) { if ( strstr ( $ value , '{' ) ) { $ segment [ $ key ] = $ params [ $ i ] ; $ i ++ ; } } $ newUrl = implode ( '/' , $ segment ) ; } else { $ newUrl = $ routes [ $ key ] [ 'route' ] ; } $ data = str_replace ( $ this -> base , '' , $ this -> url ) . '/' . $ newUrl ; return $ this -> getUrl ( $ data , $ secure ) ; } return $ this -> getUrl ( $ this -> url , $ secure ) ; }
2238	private function handlePrependLocale ( array $ extensionConfigs , ContainerBuilder $ container ) : array { if ( ! $ container -> hasParameter ( 'prepend_locale' ) ) { return $ extensionConfigs ; } foreach ( $ extensionConfigs as $ extensionConfig ) { if ( isset ( $ extensionConfig [ 'prepend_locale' ] ) ) { return $ extensionConfigs ; } } @ trigger_error ( 'Defining the "prepend_locale" parameter in the parameters.yml file has been deprecated and will no longer work in Contao 5.0. Define the "contao.prepend_locale" parameter in the config.yml file instead.' , E_USER_DEPRECATED ) ; $ extensionConfigs [ ] = [ 'prepend_locale' => '%prepend_locale%' , ] ; return $ extensionConfigs ; }
11982	public function acquire ( AcquirerInterface $ acquirer , ResourceInterface $ resource ) { if ( ! $ this -> isAccessible ( $ acquirer , $ resource ) ) { throw new ResourceLockedException ( sprintf ( 'The resource is not accessible. It is locked by "%s".' , $ resource -> getLock ( ) -> getAcquirer ( ) -> getIdentifier ( ) ) ) ; } return $ this -> repository -> acquire ( $ acquirer , $ resource ) ; }
12403	public function replace ( $ id , $ document = null ) { return Parser :: replace ( $ id , $ document , $ this -> connection ) ; }
5628	public function makeAbsolute ( $ base ) { if ( ! is_object ( $ base ) ) { $ base = new self ( $ base ) ; } if ( $ this -> getHost ( ) ) { $ scheme = $ this -> getScheme ( ) ; $ host = $ this -> getHost ( ) ; $ port = $ this -> getPort ( ) ? ':' . $ this -> getPort ( ) : '' ; $ identity = $ this -> getIdentity ( ) ? $ this -> getIdentity ( ) . '@' : '' ; if ( ! $ identity ) { $ identity = $ base -> getIdentity ( ) ? $ base -> getIdentity ( ) . '@' : '' ; } } else { $ scheme = $ base -> getScheme ( ) ; $ host = $ base -> getHost ( ) ; $ port = $ base -> getPort ( ) ? ':' . $ base -> getPort ( ) : '' ; $ identity = $ base -> getIdentity ( ) ? $ base -> getIdentity ( ) . '@' : '' ; } $ path = $ this -> normalisePath ( $ this -> extractAbsolutePath ( $ base ) ) ; $ encoded = $ this -> getEncodedRequest ( ) ; $ fragment = $ this -> getFragment ( ) ? '#' . $ this -> getFragment ( ) : '' ; $ coords = $ this -> getX ( ) === false ? '' : '?' . $ this -> getX ( ) . ',' . $ this -> getY ( ) ; return new self ( "$scheme://$identity$host$port$path$encoded$fragment$coords" ) ; }
9933	public function setRuleType ( $ pRuleType ) { if ( ! in_array ( $ pRuleType , self :: $ ruleTypes ) ) { throw new PhpSpreadsheetException ( 'Invalid rule type for column AutoFilter Rule.' ) ; } $ this -> ruleType = $ pRuleType ; return $ this ; }
713	public function bigInteger ( $ length = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_BIGINT , $ length ) ; }
640	public function dropPrimaryKey ( $ name , $ table ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> dropPrimaryKey ( $ name , $ table ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; }
2327	public function setRow ( array $ arrData ) { if ( $ this -> intIndex < 0 ) { $ this -> first ( ) ; } $ this -> arrModels [ $ this -> intIndex ] -> setRow ( $ arrData ) ; return $ this ; }
10163	private function readSheetLayout ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; $ offset = 0 ; if ( ! $ this -> readDataOnly ) { $ sz = self :: getInt4d ( $ recordData , 12 ) ; switch ( $ sz ) { case 0x14 : $ colorIndex = self :: getUInt2d ( $ recordData , 16 ) ; $ color = Xls \ Color :: map ( $ colorIndex , $ this -> palette , $ this -> version ) ; $ this -> phpSheet -> getTabColor ( ) -> setRGB ( $ color [ 'rgb' ] ) ; break ; case 0x28 : return ; break ; } } }
11660	public static function readFromString ( $ string ) { $ xml = new \ DOMDocument ( ) ; $ xml -> loadXML ( $ string ) ; $ result = [ ] ; $ props = $ xml -> childNodes -> item ( $ xml -> childNodes -> length - 1 ) -> childNodes ; for ( $ i = 0 ; $ i < $ props -> length ; $ i ++ ) { $ entry = $ props -> item ( $ i ) ; if ( $ entry -> nodeName == "entry" ) $ result [ $ entry -> attributes -> getNamedItem ( "key" ) -> nodeValue ] = $ entry -> textContent ; } return $ result ; }
6262	public function getPrefixMap ( ) { $ prefixMap = ( array ) Configure :: read ( 'SimpleRbac.prefixMap' ) ; if ( empty ( $ prefixMap ) && $ this -> _config [ 'allowEmptyPrefixMap' ] === false ) { throw new \ RuntimeException ( 'SimpleRbac.prefixMap configuration is empty!' ) ; } return $ prefixMap ; }
7266	public static function find ( $ id , $ idColumn = null ) { $ tableName = static :: tableName ( ) ; $ idColumn = $ idColumn ? : static :: $ idColumn ; $ rows = Db :: query ( " select * from $tableName where $idColumn = :id " , [ "id" => $ id ] , static :: getDbName ( ) ) ; if ( $ rows === false ) return false ; if ( empty ( $ rows ) ) return null ; $ model = new static ; foreach ( $ rows [ 0 ] as $ col => $ val ) $ model -> $ col = $ model -> decodeValue ( $ val , $ col ) ; return $ model ; }
12513	public static function copy ( $ src , $ dest , $ force = false , $ delete = false ) { $ src = Path :: clean ( $ src ) ; $ dest = Path :: clean ( $ dest ) ; $ fs = new Filesystem ( ) ; try { $ fs -> mirror ( $ src , $ dest , null , [ 'override' => $ force , 'delete' => $ delete , 'copy_on_windows' => true ] ) ; } catch ( IOExceptionInterface $ e ) { throw new Exception ( Helper :: getTranslation ( 'CANNOT_FIND_SOURCE' ) . ' ' . $ e -> getPath ( ) ) ; } return true ; }
933	public function equals ( $ other , $ caseSensitive = true ) { if ( $ other instanceof self ) { if ( ! $ other -> isArray ) { $ otherPrototype = $ other -> content ; } else { $ otherPrototype = [ $ other -> id , $ other -> content , ] ; } } else { $ otherPrototype = $ other ; } if ( $ this -> isArray !== \ is_array ( $ otherPrototype ) ) { return false ; } if ( ! $ this -> isArray ) { return $ this -> content === $ otherPrototype ; } if ( $ this -> id !== $ otherPrototype [ 0 ] ) { return false ; } if ( isset ( $ otherPrototype [ 1 ] ) ) { if ( $ caseSensitive ) { if ( $ this -> content !== $ otherPrototype [ 1 ] ) { return false ; } } elseif ( 0 !== strcasecmp ( $ this -> content , $ otherPrototype [ 1 ] ) ) { return false ; } } unset ( $ otherPrototype [ 0 ] , $ otherPrototype [ 1 ] ) ; return empty ( $ otherPrototype ) ; }
3171	public function getMap ( RunnerServiceContext $ context , RunnerConfig $ config ) { return $ this -> getScopedMap ( $ context , $ config , RunnerMap :: SCOPE_TEST ) ; }
9720	public function setEscher ( \ PhpOffice \ PhpSpreadsheet \ Shared \ Escher $ pValue = null ) { $ this -> escher = $ pValue ; }
8360	private function startProcessQueue ( ) { $ this -> logger -> info ( 'Starting queue in process mode' ) ; $ dispatcher = new ProcessDispatcher ( $ this -> client , $ this -> logger , $ this -> queue , \ array_merge ( $ this -> queueConfig , [ 'process' => $ this -> config [ 'process' ] ] ) , [ 'configFile' => $ this -> configName ] ) ; $ dispatcher -> start ( ) ; }
6542	public function current ( ) { if ( true === $ this -> wantNewModel ) { return $ this -> entityManager -> load ( $ this -> modelClassName , $ this -> selector -> current ( ) ) ; } else { $ this -> initializeModel ( $ this -> selector -> current ( ) , $ this -> selector -> currentShardingKey ( ) ) ; $ this -> entityManager -> resetModel ( $ this -> model , $ this -> selector -> current ( ) ) ; return $ this -> model ; } }
2625	protected function _toHtml ( ) { if ( $ this -> config -> isGeoIpEnabled ( ) == false || $ this -> config -> isFastlyEnabled ( ) == false ) { return parent :: _toHtml ( ) ; } $ actionUrl = $ this -> getUrl ( 'fastlyCdn/geoip/getaction' ) ; $ header = $ this -> response -> getHeader ( 'x-esi' ) ; if ( empty ( $ header ) ) { $ this -> response -> setHeader ( "x-esi" , "1" ) ; } return sprintf ( '<esi:include src=\'%s\' />' , preg_replace ( "/^https/" , "http" , $ actionUrl ) ) ; }
1860	public function rcopy ( $ strSource , $ strDestination ) { $ this -> validate ( $ strSource , $ strDestination ) ; $ this -> mkdir ( $ strDestination ) ; $ arrFiles = scan ( $ this -> strRootDir . '/' . $ strSource , true ) ; foreach ( $ arrFiles as $ strFile ) { if ( is_dir ( $ this -> strRootDir . '/' . $ strSource . '/' . $ strFile ) ) { $ this -> rcopy ( $ strSource . '/' . $ strFile , $ strDestination . '/' . $ strFile ) ; } else { $ this -> copy ( $ strSource . '/' . $ strFile , $ strDestination . '/' . $ strFile ) ; } } }
10096	protected function processSize ( $ size ) { if ( $ size === null ) { return $ size ; } $ size = ( int ) $ size ; if ( $ size <= 0 ) { throw new InvalidArgumentException ( 'Size has to be larger than 0' ) ; } return ( int ) $ size ; }
1832	public function onRegister ( Registry $ registry ) { foreach ( static :: getUniqueFields ( ) as $ strColumn ) { $ varAliasValue = $ this -> { $ strColumn } ; if ( ! $ registry -> isRegisteredAlias ( $ this , $ strColumn , $ varAliasValue ) ) { $ registry -> registerAlias ( $ this , $ strColumn , $ varAliasValue ) ; } } }
11484	protected function getFunctionArguments ( ReflectionFunctionAbstract $ func , array $ params = array ( ) ) { $ args = [ ] ; foreach ( $ func -> getParameters ( ) as $ param ) { $ class = $ param -> getClass ( ) ; if ( $ class ) { $ args [ ] = $ this -> resolveClassArg ( $ class , $ param , $ params ) ; } else { $ args [ ] = $ this -> resolveNonClassArg ( $ param , $ params , $ func ) ; } } return $ args ; }
6772	protected function didInvoiceCountryChanged ( SaleInterface $ sale ) { $ saleCs = $ this -> persistenceHelper -> getChangeSet ( $ sale ) ; $ oldCountry = $ newCountry = null ; $ oldAddress = isset ( $ saleCs [ 'invoiceAddress' ] ) ? $ saleCs [ 'invoiceAddress' ] [ 0 ] : $ sale -> getInvoiceAddress ( ) ; if ( null !== $ oldAddress ) { $ oldAddressCs = $ this -> persistenceHelper -> getChangeSet ( $ oldAddress ) ; $ oldCountry = isset ( $ oldAddressCs [ 'country' ] ) ? $ oldAddressCs [ 'country' ] [ 0 ] : $ oldAddress -> getCountry ( ) ; } if ( null !== $ newAddress = $ sale -> getInvoiceAddress ( ) ) { $ newCountry = $ newAddress -> getCountry ( ) ; } if ( $ oldCountry !== $ newCountry ) { return true ; } return false ; }
11262	public static function main ( $ argv , ContainerInterface $ container = null ) { $ output = self :: cyanLine ( $ argv ) ; $ app = new Application ( '' ) ; $ app -> add ( new MigrateMakeCommand ( ) ) ; $ app -> add ( new MigrateUpCommand ( $ container ) ) ; $ app -> add ( new MigrateDownCommand ( ) ) ; $ app -> add ( new MigrateResetCommand ( ) ) ; $ app -> add ( new MigrateStatusCommand ( ) ) ; $ app -> add ( new MigrateRefreshCommand ( ) ) ; $ app -> add ( new MigrateFreshCommand ( $ container ) ) ; $ app -> add ( new MigrateDropCommand ( ) ) ; $ app -> add ( new SeedRunCommand ( $ container ) ) ; $ app -> add ( new SeedMakeCommand ( ) ) ; $ app -> add ( new BinMakeCommand ( ) ) ; $ app -> run ( null , $ output ) ; }
9532	private function preloadAliases ( ) { foreach ( array_keys ( $ this -> parameterCluster -> prefixes ) as $ prefix ) { foreach ( $ this -> parameterCluster -> prefixes [ $ prefix ] as $ parameterClosure ) { foreach ( $ parameterClosure -> aliases as $ prefix => $ alias ) { $ aliasClosure = new ParameterClosure ( $ prefix , $ alias , $ parameterClosure -> parameterClosure ) ; $ aliasClosure -> parent = $ parameterClosure ; $ this -> parameterCluster -> add ( $ aliasClosure ) ; } } } }
6374	public function transformAndConcat ( callable $ transformer ) : FluentIterable { return self :: from ( Iterables :: concatIterables ( $ this -> transform ( $ transformer ) ) ) ; }
12747	public function getInputSpecification ( ) { $ dateValidator = $ this -> getDateValidator ( ) ; $ dateValidatorName = get_class ( $ dateValidator ) ; return [ 'name' => $ this -> getName ( ) , 'required' => true , 'filters' => [ Filter \ StringTrim :: class => [ 'name' => Filter \ StringTrim :: class ] , Filter \ StripNewlines :: class => [ 'name' => Filter \ StripNewlines :: class ] , Filter \ StripTags :: class => [ 'name' => Filter \ StripTags :: class ] , TimeToDateTime :: class => [ 'name' => TimeToDateTime :: class , 'options' => [ 'time_format' => $ this -> getFormat ( ) ] ] ] , 'validators' => [ $ dateValidatorName => $ dateValidator ] ] ; }
5972	public function deployment ( ) { if ( ! $ this -> deployment instanceof DeploymentController ) { $ this -> deployment = new DeploymentController ( $ this -> getClient ( ) , $ this -> cachePolicy , $ this -> cache ) ; $ this -> deployment -> setLogger ( $ this -> logger ) ; } return $ this -> deployment ; }
7749	public function getAllMetadata ( ) { $ metadata = array ( ) ; foreach ( $ this -> driver -> getAllClassNames ( ) as $ className ) { $ metadata [ ] = $ this -> getMetadataFor ( $ className ) ; } $ this -> validate ( $ metadata ) ; return $ metadata ; }
6535	protected function hydrate ( $ propertyName ) { if ( isset ( $ this -> yuccaMappingManager ) && ( false === isset ( $ this -> yuccaInitialized [ $ propertyName ] ) ) && ( false === empty ( $ this -> yuccaIdentifier ) ) ) { $ values = $ this -> yuccaMappingManager -> getMapper ( get_class ( $ this ) ) -> load ( $ this -> yuccaIdentifier , $ propertyName , $ this -> yuccaShardingKey ) ; foreach ( $ values as $ property => $ value ) { if ( false === isset ( $ this -> yuccaInitialized [ $ property ] ) ) { $ this -> $ property = $ value ; $ this -> yuccaInitialized [ $ property ] = true ; } } } $ this -> yuccaInitialized [ $ propertyName ] = true ; return $ this ; }
6527	public static function resolveCurie ( $ curie ) : string { $ key = ( string ) $ curie ; if ( isset ( self :: $ curies [ $ key ] ) ) { return self :: $ classes [ self :: $ curies [ $ key ] ] ; } throw new NoMessageForCurie ( SchemaCurie :: fromString ( $ key ) ) ; }
9489	public function getFileData ( $ sFieldName ) { if ( empty ( $ sFieldName ) ) { return null ; } $ obFile = $ this -> $ sFieldName ; if ( empty ( $ obFile ) || ! $ obFile instanceof File ) { return null ; } return $ this -> getFileDataValue ( $ obFile ) ; }
12770	public function authorize ( RecordInterface & $ user , $ remember = false ) { if ( parent :: authorize ( $ user , $ remember ) ) { if ( $ remember ) { $ token = $ user [ $ this -> dbHashEmailField ] . ( time ( ) + ( $ this -> cookieTime ) ) . $ user [ $ this -> dbHashPasswordField ] ; $ user [ $ this -> dbAccessToken ] = $ token ; $ user -> save ( ) ; $ expiry = time ( ) + ( $ this -> cookieTime ) ; $ cookieData = array ( "token" => $ token , "expiry" => $ expiry ) ; setcookie ( '_cookie_accessToken' , serialize ( $ cookieData ) , $ expiry ) ; } } }
7629	public function setContainerAcl ( $ containerName = '' , $ acl = self :: ACL_PRIVATE , $ signedIdentifiers = array ( ) ) { Assertion :: notEmpty ( $ containerName , 'Container name is not specified' ) ; self :: assertValidContainerName ( $ containerName ) ; $ headers = array ( ) ; if ( $ acl != self :: ACL_PRIVATE && ! is_null ( $ acl ) && $ acl != '' ) { $ headers [ Storage :: PREFIX_STORAGE_HEADER . 'blob-public-access' ] = $ acl ; } $ policies = null ; if ( is_array ( $ signedIdentifiers ) && count ( $ signedIdentifiers ) > 0 ) { $ policies = '' ; $ policies .= '<?xml version="1.0" encoding="utf-8"?>' . "\r\n" ; $ policies .= '<SignedIdentifiers>' . "\r\n" ; foreach ( $ signedIdentifiers as $ signedIdentifier ) { $ policies .= ' <SignedIdentifier>' . "\r\n" ; $ policies .= ' <Id>' . $ signedIdentifier -> Id . '</Id>' . "\r\n" ; $ policies .= ' <AccessPolicy>' . "\r\n" ; if ( $ signedIdentifier -> Start != '' ) $ policies .= ' <Start>' . $ signedIdentifier -> Start . '</Start>' . "\r\n" ; if ( $ signedIdentifier -> Expiry != '' ) $ policies .= ' <Expiry>' . $ signedIdentifier -> Expiry . '</Expiry>' . "\r\n" ; if ( $ signedIdentifier -> Permissions != '' ) $ policies .= ' <Permission>' . $ signedIdentifier -> Permissions . '</Permission>' . "\r\n" ; $ policies .= ' </AccessPolicy>' . "\r\n" ; $ policies .= ' </SignedIdentifier>' . "\r\n" ; } $ policies .= '</SignedIdentifiers>' . "\r\n" ; } $ response = $ this -> performRequest ( $ containerName , array ( 'restype' => 'container' , 'comp' => 'acl' ) , 'PUT' , $ headers , false , $ policies , self :: RESOURCE_CONTAINER , self :: PERMISSION_WRITE ) ; if ( ! $ response -> isSuccessful ( ) ) { throw new BlobException ( $ this -> getErrorMessage ( $ response , 'Resource could not be accessed.' ) ) ; } }
8675	public function merge ( $ list ) { return $ this -> createFrom ( array_merge ( $ this -> items , Arr :: from ( $ list ) ) ) ; }
5591	public function fetchResponse ( $ url , $ encoding ) { if ( ! in_array ( $ encoding -> getMethod ( ) , array ( 'POST' , 'PUT' ) ) ) { $ url -> addRequestParameters ( $ encoding ) ; $ encoding -> clear ( ) ; } $ response = $ this -> fetchWhileRedirected ( $ url , $ encoding ) ; if ( $ headers = $ response -> getHeaders ( ) ) { if ( $ headers -> isChallenge ( ) ) { $ this -> authenticator -> addRealm ( $ url , $ headers -> getAuthentication ( ) , $ headers -> getRealm ( ) ) ; } } return $ response ; }
5719	public function cancel ( ) { Controller :: curr ( ) -> getResponse ( ) -> addHeader ( "X-Pjax" , "Content" ) ; return Controller :: curr ( ) -> redirect ( $ this -> getBackLink ( ) ) ; }
11860	public function setCompanionObject ( $ value ) { if ( $ this -> isForeign ) { return $ this -> localObject = $ value ; } else { return $ this -> foreignObject = $ value ; } }
9409	protected function transform ( $ middleware , $ wrappable = true ) { if ( is_a ( $ middleware , Application :: MIDDLEWARE ) === false ) { $ approach = ( boolean ) $ this -> approach ( $ middleware ) ; $ response = $ approach === self :: SINGLE_PASS ? $ this -> response : null ; $ wrapper = new CallableMiddlewareWrapper ( $ middleware , $ response ) ; $ middleware = $ wrappable === true ? $ wrapper : $ middleware ; } return $ middleware ; }
1706	public function clearResponseCookie ( Response $ response ) : Response { $ response -> headers -> clearCookie ( self :: COOKIE_NAME ) ; return $ response ; }
5399	public function setHost ( $ host ) { if ( $ host = $ this -> truncateHost ( $ host ) ) { $ this -> host = $ host ; return true ; } return false ; }
5360	protected function createBodyStatements ( Operation $ operation , $ queryParamVariable , Context $ context ) { $ bodyParameter = null ; $ bodyVariable = new Expr \ Variable ( 'body' ) ; $ parameterKey = 0 ; if ( $ operation -> getOperation ( ) -> getParameters ( ) ) { foreach ( $ operation -> getOperation ( ) -> getParameters ( ) as $ key => $ parameter ) { if ( $ parameter instanceof BodyParameter ) { $ bodyParameter = $ parameter ; $ parameterKey = $ key ; } } } if ( null === $ bodyParameter ) { return [ [ new Expr \ Assign ( $ bodyVariable , new Expr \ MethodCall ( $ queryParamVariable , 'buildFormDataString' , [ new Arg ( new Expr \ Variable ( 'parameters' ) ) ] ) ) ] , $ bodyVariable ] ; } if ( $ bodyParameter -> getSchema ( ) instanceof Reference || $ context -> getRegistry ( ) -> hasClass ( $ operation -> getReference ( ) . '/parameters/' . $ parameterKey ) ) { return [ [ new Expr \ Assign ( $ bodyVariable , new Expr \ MethodCall ( new Expr \ PropertyFetch ( new Expr \ Variable ( 'this' ) , 'serializer' ) , 'serialize' , [ new Arg ( new Expr \ Variable ( Inflector :: camelize ( $ bodyParameter -> getName ( ) ) ) ) , new Arg ( new Scalar \ String_ ( 'json' ) ) ] ) ) ] , $ bodyVariable ] ; } return [ [ new Expr \ Assign ( $ bodyVariable , new Expr \ Variable ( Inflector :: camelize ( $ bodyParameter -> getName ( ) ) ) ) ] , $ bodyVariable ] ; }
12696	static function getAvailableExtNames ( ) { $ files = pakeFinder :: type ( 'file' ) -> name ( 'options-*.yaml' ) -> not_name ( 'options-sample.yaml' ) -> not_name ( 'options-user.yaml' ) -> maxdepth ( 0 ) -> in ( self :: getOptionsDir ( ) ) ; foreach ( $ files as $ i => $ file ) { $ files [ $ i ] = substr ( basename ( $ file ) , 8 , - 5 ) ; } return $ files ; }
6896	public function set ( $ key , $ value ) { $ this -> open ( ) ; $ this -> _data [ $ key ] = $ value ; return $ this ; }
5692	public function baseTransform ( ) { parent :: baseTransform ( ) ; Requirements :: javascript ( BETTER_BUTTONS_DIR . '/javascript/gridfield_betterbuttons_delete.js' ) ; return $ this -> setUseButtonTag ( true ) -> addExtraClass ( 'btn-danger-outline btn-hide-outline font-icon-trash-bin gridfield-better-buttons-delete' ) -> setAttribute ( "data-toggletext" , _t ( 'GridFieldBetterButtons.AREYOUSURE' , 'Yes. Delete this item.' ) ) -> setAttribute ( "data-confirmtext" , _t ( 'GridFieldDetailForm.CANCELDELETE' , 'No. Don\'t delete.' ) ) ; }
7506	function setDoc ( $ doc , $ pos = 0 ) { $ this -> doc = $ doc ; $ this -> size = strlen ( $ doc ) ; $ this -> setPos ( $ pos ) ; }
5770	public function getLoggedInAdministrator ( ) : Administrator { if ( ! isset ( $ _SESSION [ SlimPostgres :: SESSION_KEY_ADMINISTRATOR_ID ] ) ) { throw new \ Exception ( "No one is logged in" ) ; } if ( null === $ administrator = ( AdministratorsEntityMapper :: getInstance ( ) ) -> getObjectById ( $ _SESSION [ SlimPostgres :: SESSION_KEY_ADMINISTRATOR_ID ] ) ) { unset ( $ _SESSION [ SlimPostgres :: SESSION_KEY_ADMINISTRATOR_ID ] ) ; throw new \ Exception ( "Invalid administrator id " . $ _SESSION [ SlimPostgres :: SESSION_KEY_ADMINISTRATOR_ID ] . " in session" ) ; } return $ administrator ; }
3873	private function getBaseUrl ( $ pageDetails , $ path = null , $ ignoreSSL = false ) { $ url = new UrlBuilder ( ) ; if ( $ pageDetails [ 'domain' ] ) { $ url -> setHost ( $ pageDetails [ 'domain' ] ) ; } else { $ url -> setHost ( \ Environment :: get ( 'host' ) ) ; } if ( $ pageDetails [ 'rootUseSSL' ] && ! $ ignoreSSL ) { $ url -> setScheme ( 'https' ) ; } else { $ url -> setScheme ( 'http' ) ; } $ fullPath = array ( ) ; $ fullPath [ ] = TL_PATH ; if ( $ path === null ) { $ event = new GenerateFrontendUrlEvent ( $ pageDetails , null , $ pageDetails [ 'language' ] , true ) ; $ this -> getEventDispatcher ( ) -> dispatch ( ContaoEvents :: CONTROLLER_GENERATE_FRONTEND_URL , $ event ) ; $ fullPath [ ] = $ event -> getUrl ( ) ; } else { $ fullPath [ ] = $ path ; } $ url -> setPath ( implode ( '/' , $ fullPath ) ) ; return $ url ; }
1357	public function field ( string $ field , string $ inverse = null ) : self { $ this -> defaults = array_merge ( $ this -> defaults , [ ResourceRegistrar :: PARAM_RELATIONSHIP_NAME => $ field , ResourceRegistrar :: PARAM_RELATIONSHIP_INVERSE_TYPE => $ inverse ? : Str :: plural ( $ field ) , ] ) ; return $ this ; }
1519	public function addToRelationship ( StoreInterface $ store , UpdateRelationship $ request ) { $ result = $ this -> transaction ( function ( ) use ( $ store , $ request ) { return $ this -> doAddToRelationship ( $ store , $ request ) ; } ) ; if ( $ this -> isResponse ( $ result ) ) { return $ result ; } return $ this -> reply ( ) -> noContent ( ) ; }
2315	protected function prepareImportantPart ( ) { $ importantPart = $ this -> getImportantPart ( ) ; if ( substr_count ( $ this -> resizeMode , '_' ) === 1 ) { $ importantPart = array ( 'x' => 0 , 'y' => 0 , 'width' => $ this -> fileObj -> viewWidth , 'height' => $ this -> fileObj -> viewHeight , ) ; $ mode = explode ( '_' , $ this -> resizeMode ) ; if ( $ mode [ 0 ] === 'left' ) { $ importantPart [ 'width' ] = 1 ; } elseif ( $ mode [ 0 ] === 'right' ) { $ importantPart [ 'x' ] = $ importantPart [ 'width' ] - 1 ; $ importantPart [ 'width' ] = 1 ; } if ( $ mode [ 1 ] === 'top' ) { $ importantPart [ 'height' ] = 1 ; } elseif ( $ mode [ 1 ] === 'bottom' ) { $ importantPart [ 'y' ] = $ importantPart [ 'height' ] - 1 ; $ importantPart [ 'height' ] = 1 ; } } if ( ! $ importantPart [ 'width' ] || ! $ importantPart [ 'height' ] ) { return null ; } return new ImportantPart ( new Point ( $ importantPart [ 'x' ] , $ importantPart [ 'y' ] ) , new Box ( $ importantPart [ 'width' ] , $ importantPart [ 'height' ] ) ) ; }
7890	protected function getDefaultProjectHook ( ) { $ default = $ this -> config -> get ( self :: CONFIG_DEFAULT ) ; return $ this -> config -> get ( sprintf ( self :: CONFIG_PROJECT , $ default ) ) ; }
4256	protected function buildNotInConsole ( ) { if ( ! $ this -> stats [ 'notInConsole' ] ) { return '' ; } $ errors = $ this -> errorHandler -> get ( 'errors' ) ; $ lis = array ( ) ; foreach ( $ errors as $ err ) { if ( \ array_intersect_assoc ( array ( 'category' => 'fatal' , 'inConsole' => true , 'isSuppressed' => true , ) , $ err -> getValues ( ) ) ) { continue ; } $ lis [ ] = '<li>' . $ err [ 'typeStr' ] . ': ' . $ err [ 'file' ] . ' (line ' . $ err [ 'line' ] . '): ' . ( $ err [ 'isHtml' ] ? $ err [ 'message' ] : \ htmlspecialchars ( $ err [ 'message' ] ) ) . '</li>' ; } if ( ! $ lis ) { return '' ; } $ count = \ count ( $ lis ) ; $ header = \ sprintf ( '%s %s captured while not collecting debug log' , $ this -> stats [ 'inConsole' ] || isset ( $ this -> stats [ 'counts' ] [ 'fatal' ] ) ? 'Additionally, there' : 'There' , $ count === 1 ? 'was 1 error' : 'were ' . $ count . ' errors' ) ; $ html = '<h3>' . $ header . '</h3>' . '<ul class="list-unstyled indent">' . "\n" . \ implode ( "\n" , $ lis ) . "\n" . '</ul>' ; return $ html ; }
5892	public static function logEntry ( $ entry ) { $ parts = explode ( "|" , $ entry , 5 ) ; $ array = array ( ) ; if ( count ( $ parts ) != 5 ) { $ array [ "timestamp" ] = 0 ; $ array [ "level" ] = TeamSpeak3 :: LOGLEVEL_ERROR ; $ array [ "channel" ] = "ParamParser" ; $ array [ "server_id" ] = "" ; $ array [ "msg" ] = StringHelper :: factory ( "convert error (" . trim ( $ entry ) . ")" ) ; $ array [ "msg_plain" ] = $ entry ; $ array [ "malformed" ] = true ; } else { $ array [ "timestamp" ] = strtotime ( trim ( $ parts [ 0 ] ) ) ; $ array [ "level" ] = self :: logLevel ( trim ( $ parts [ 1 ] ) ) ; $ array [ "channel" ] = trim ( $ parts [ 2 ] ) ; $ array [ "server_id" ] = trim ( $ parts [ 3 ] ) ; $ array [ "msg" ] = StringHelper :: factory ( trim ( $ parts [ 4 ] ) ) ; $ array [ "msg_plain" ] = $ entry ; $ array [ "malformed" ] = false ; } return $ array ; }
6447	public function getUserProfile ( ) { $ linkedin = $ this -> getClient ( ) ; $ response = $ linkedin -> get ( '/people/~:(id,first-name,last-name,picture-url,public-profile-url,email-address)' ) ; if ( isset ( $ response [ 'emailAddress' ] ) ) { return array ( 'userid' => $ response [ 'id' ] , 'name' => $ response [ 'firstName' ] . ' ' . $ response [ 'lastName' ] , 'email' => $ response [ 'emailAddress' ] , 'imageurl' => $ response [ 'pictureUrl' ] ) ; } }
9785	public function parseFor ( ) { $ for_open_token = $ this -> pop ( 'FOR_OPEN' ) ; $ this -> currLine ++ ; $ output = '$for_index = 0; foreach(' . $ for_open_token [ 1 ] [ 1 ] . ' as ' . $ for_open_token [ 1 ] [ 0 ] . ') {' . "\n" ; while ( true ) { list ( $ type , $ value ) = $ this -> peek ( ) ; if ( $ type == 'FOR_CLOSE' ) { $ this -> pop ( ) ; $ output .= '$for_index++; }' . "\n" ; $ this -> currLine ++ ; break ; } else { $ output .= $ this -> parseExpression ( ) ; } } return $ output ; }
4189	protected function dumpConstants ( $ constants ) { $ str = '' ; if ( $ constants && $ this -> debug -> output -> getCfg ( 'outputConstants' ) ) { $ str = '<dt class="constants">constants</dt>' . "\n" ; foreach ( $ constants as $ k => $ value ) { $ str .= '<dd class="constant">' . '<span class="constant-name">' . $ k . '</span>' . ' <span class="t_operator">=</span> ' . $ this -> debug -> output -> html -> dump ( $ value ) . '</dd>' . "\n" ; } } return $ str ; }
7296	private function get_mail_to_chunk ( $ to , $ send_next_group = array ( ) ) { $ object_id = $ this -> options [ 'static_options' ] [ 'object' ] [ 'id' ] ; $ object_type = $ this -> options [ 'static_options' ] [ 'object' ] [ 'type' ] ; if ( empty ( $ send_next_group ) ) { $ chunk_size = $ this -> options [ 'static_options' ] [ 'mail_to_chunking' ] [ 'chunksize' ] ; $ send_next_group = array_chunk ( $ to , $ chunk_size ) ; } $ to = apply_filters ( 'iac_email_address_chunk' , array_shift ( $ send_next_group ) , $ object_id , $ object_type ) ; $ to = implode ( ',' , $ to ) ; if ( ! empty ( $ send_next_group ) ) { wp_schedule_single_event ( time ( ) + $ this -> options [ 'static_options' ] [ 'schedule_interval' ] , 'iac_schedule_send_chunks' , array ( $ object_id , $ object_type , $ send_next_group ) ) ; } return $ to ; }
8317	protected function sendResetMail ( $ userData ) { if ( ! $ this -> mailer ) { $ this -> getLogger ( ) -> critical ( "Sending mail but no mailer is set!" ) ; return ; } $ url = $ this -> createResetToken ( $ userData [ 'name' ] ) ; $ message = $ this -> picoAuth -> getPico ( ) -> substituteFileContent ( $ this -> config [ "emailMessage" ] ) ; $ subject = $ this -> picoAuth -> getPico ( ) -> substituteFileContent ( $ this -> config [ "emailSubject" ] ) ; $ message = str_replace ( "%url%" , $ url , $ message ) ; $ message = str_replace ( "%username%" , $ userData [ 'name' ] , $ message ) ; $ this -> mailer -> setup ( ) ; $ this -> mailer -> setTo ( $ userData [ 'email' ] ) ; $ this -> mailer -> setSubject ( $ subject ) ; $ this -> mailer -> setBody ( $ message ) ; if ( ! $ this -> mailer -> send ( ) ) { $ this -> getLogger ( ) -> critical ( "Mailer error: {e}" , [ "e" => $ this -> mailer -> getError ( ) ] ) ; } else { $ this -> getLogger ( ) -> info ( "PwReset email sent to {email}" , [ "email" => $ userData [ 'email' ] ] ) ; } }
7566	protected function parse_single ( $ recursive = true ) { if ( ( $ c = $ this -> parse_conditions ( ) ) === false ) { return false ; } $ this -> parse_callback ( $ c , $ recursive , $ this -> search_root ) ; return true ; }
8255	protected function handlePasswordReset ( Request $ httpRequest ) { $ passwordReset = $ this -> picoAuth -> getContainer ( ) -> get ( 'PasswordReset' ) ; $ passwordReset -> setConfig ( $ this -> config ) -> handlePasswordReset ( $ httpRequest ) ; }
9596	public function makeSession ( ) { $ session = new Session ( $ this -> dic -> resolve ( 'Symfony\Component\HttpFoundation\Session\Storage\SessionStorageInterface' ) , $ this -> dic -> resolve ( 'Symfony\Component\HttpFoundation\Session\Attribute\AttributeBagInterface' ) , $ this -> dic -> resolve ( 'Symfony\Component\HttpFoundation\Session\Flash\FlashBagInterface' ) ) ; $ session -> setName ( $ this -> config -> get ( 'session.cookie.name' , 'autarky_session' ) ) ; return $ session ; }
8482	public static function getOS ( ) { $ wmi = Windows :: getInstance ( ) ; foreach ( $ wmi -> ExecQuery ( "SELECT Caption FROM Win32_OperatingSystem" ) as $ os ) { return $ os -> Caption ; } return "Windows" ; }
9794	public function getDataValidation ( ) { if ( ! isset ( $ this -> parent ) ) { throw new Exception ( 'Cannot get data validation for cell that is not bound to a worksheet' ) ; } return $ this -> getWorksheet ( ) -> getDataValidation ( $ this -> getCoordinate ( ) ) ; }
2606	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ aclId = $ this -> getRequest ( ) -> getParam ( 'acl_id' ) ; $ aclItemId = $ this -> getRequest ( ) -> getParam ( 'acl_item_id' ) ; $ deleteItem = $ this -> api -> deleteAclItem ( $ aclId , $ aclItemId ) ; if ( ! $ deleteItem ) { return $ result -> setData ( [ 'status' => false ] ) ; } return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
9514	public function addFacetedQuery ( $ query , $ index , array $ keys ) { $ this -> AddQuery ( $ query , $ index ) ; $ currentOffset = $ this -> _offset ; $ mode = $ this -> _sort ; $ sortby = $ this -> _sortby ; $ limit = $ this -> _limit ; $ this -> _offset = 0 ; $ this -> _sort = 0 ; $ this -> _sortby = '' ; $ this -> SetLimits ( 0 , 999 ) ; foreach ( $ keys as $ key ) { $ this -> setGroupByAttr ( $ key ) ; $ this -> AddQuery ( $ query , $ index ) ; } $ this -> _offset = $ currentOffset ; $ this -> _sort = $ mode ; $ this -> _sortby = $ sortby ; $ this -> SetLimits ( $ currentOffset , $ limit ) ; }
5210	public static function getInstance ( OutputInterface $ output ) { $ questionHelper = new QuestionHelper ( ) ; $ application = new Application ( 'PHP to Zephir Command Line Interface' , 'Beta 0.2.1' ) ; $ application -> getHelperSet ( ) -> set ( new FormatterHelper ( ) , 'formatter' ) ; $ application -> getHelperSet ( ) -> set ( $ questionHelper , 'question' ) ; $ application -> add ( ConvertFactory :: getInstance ( $ output ) ) ; return $ application ; }
12809	private static function isPrimaryKey ( string $ table , string $ column ) : bool { return self :: getPrimaryKey ( $ table ) [ "column_name" ] === $ column ; }
7239	protected function getAddressFromEvent ( ResourceEventInterface $ event ) { $ resource = $ event -> getResource ( ) ; if ( ! $ resource instanceof CustomerAddressInterface ) { throw new InvalidArgumentException ( 'Expected instance of ' . CustomerAddressInterface :: class ) ; } return $ resource ; }
3383	public function authenticate ( ) { $ user = $ this -> findUser ( ) ; if ( $ user === false ) { return new AuthenticationResult ( AuthenticationResult :: FAILURE_IDENTITY_NOT_FOUND , array ( ) , array ( 'User not found.' ) ) ; } $ validationResult = $ this -> passwordValidator -> isValid ( $ this -> credential , $ user [ $ this -> credentialColumn ] , $ user [ $ this -> identityColumn ] ) ; if ( $ validationResult -> isValid ( ) ) { unset ( $ user [ $ this -> getCredentialColumn ( ) ] ) ; return new AuthenticationResult ( AuthenticationResult :: SUCCESS , $ user , array ( ) ) ; } return new AuthenticationResult ( AuthenticationResult :: FAILURE_CREDENTIAL_INVALID , array ( ) , array ( 'Invalid username or password provided' ) ) ; }
10075	public static function controlCharacterOOXML2PHP ( $ value ) { self :: buildCharacterSets ( ) ; return str_replace ( array_keys ( self :: $ controlCharacters ) , array_values ( self :: $ controlCharacters ) , $ value ) ; }
562	public static function debug ( $ message , $ category = 'application' ) { if ( YII_DEBUG ) { static :: getLogger ( ) -> log ( $ message , Logger :: LEVEL_TRACE , $ category ) ; } }
857	public function overrideRange ( $ indexStart , $ indexEnd , $ items ) { $ oldCode = $ this -> generatePartialCode ( $ indexStart , $ indexEnd ) ; $ newCode = '' ; foreach ( $ items as $ item ) { $ newCode .= $ item -> getContent ( ) ; } if ( $ oldCode === $ newCode ) { return ; } $ indexToChange = $ indexEnd - $ indexStart + 1 ; $ itemsCount = \ count ( $ items ) ; if ( $ itemsCount > $ indexToChange ) { $ placeholders = [ ] ; while ( $ itemsCount > $ indexToChange ) { $ placeholders [ ] = new Token ( '__PLACEHOLDER__' ) ; ++ $ indexToChange ; } $ this -> insertAt ( $ indexEnd + 1 , $ placeholders ) ; } foreach ( $ items as $ itemIndex => $ item ) { $ this [ $ indexStart + $ itemIndex ] = $ item ; } if ( $ itemsCount < $ indexToChange ) { $ this -> clearRange ( $ indexStart + $ itemsCount , $ indexEnd ) ; } }
7914	protected function renderLabel ( ) { $ label = $ this -> encodeLabel ? Html :: encode ( $ this -> label ) : $ this -> label ; return $ this -> hasModel ( ) ? Html :: activeLabel ( $ this -> model , $ this -> attribute , $ this -> labelOptions ) : Html :: label ( $ label , $ this -> getId ( ) , $ this -> labelOptions ) ; }
11715	protected function getCachedToken ( array $ options ) { $ authOptions = array_intersect_key ( $ options , $ this -> api -> postTokens ( ) [ 'params' ] ) ; $ optionsToHash = array_merge ( $ authOptions , array_intersect_key ( $ options , [ 'authUrl' => true , ] ) ) ; if ( isset ( $ optionsToHash [ 'user' ] ) ) { unset ( $ optionsToHash [ 'user' ] [ 'password' ] ) ; } $ key = 'openstack-token-' . md5 ( json_encode ( $ optionsToHash ) ) ; if ( $ this -> cache -> has ( $ key ) ) { return $ this -> cache -> get ( $ key ) ; } $ token = $ this -> generateToken ( $ authOptions ) ; $ cachedToken = $ token -> export ( ) ; $ expiresAt = new DateTime ( $ cachedToken [ 'expires_at' ] ) ; $ this -> cache -> put ( $ key , $ cachedToken , $ expiresAt -> sub ( new DateInterval ( 'PT1M' ) ) ) ; return $ cachedToken ; }
7835	protected function getWorkflowsNamespace ( ) { $ relative = ltrim ( config ( 'workflow.path' ) , app_path ( ) ) ; $ chunks = array_map ( 'ucfirst' , explode ( '/' , $ relative ) ) ; return implode ( '\\' , $ chunks ) ; }
12669	public function addNamespace ( $ namespaceOptions , $ namespace = null ) { if ( ! $ namespaceOptions instanceof NamespaceOptionsInterface ) { if ( is_array ( $ namespaceOptions ) ) { $ namespaceOptions = new NamespaceOptions ( $ namespaceOptions ) ; if ( $ namespace !== null ) { $ namespaceOptions -> setName ( $ namespace ) ; } } else { throw new Exception \ InvalidArgumentException ( sprintf ( '%s expects parameter 1 to be array or an instance of HtSettingsModule\Options\NamespaceOptionsInterface, %s provided instead' , __METHOD__ , is_object ( $ namespaceOptions ) ? get_class ( $ namespaceOptions ) : gettype ( $ namespaceOptions ) ) ) ; } } else { if ( ! $ namespaceOptions -> getName ( ) && $ namespace ) { $ namespaceOptions -> setName ( $ namespace ) ; } } if ( $ namespace === null ) { $ namespace = $ namespaceOptions -> getName ( ) ; } $ this -> namespaces [ $ namespace ] = $ namespaceOptions ; }
9180	final public function getViewSettings ( ) { $ rf = new \ ReflectionClass ( $ this ) ; $ this -> viewName = str_replace ( 'View' , '' , $ rf -> getShortName ( ) ) ; $ matches = array ( ) ; if ( preg_match ( "#@applyTo\((.*)\)#" , $ rf -> getDocComment ( ) , $ matches ) ) { $ params = array ( ) ; parse_str ( str_replace ( ',' , '&' , $ matches [ 1 ] ) , $ params ) ; if ( is_array ( $ params ) ) { foreach ( $ params as $ param => $ value ) { if ( $ param == 'controller' ) { $ this -> controllers = explode ( '|' , $ value ) ; } if ( $ param == 'action' ) { $ this -> actions = explode ( '|' , $ value ) ; } } } } return $ this ; }
599	private function joinWithRelation ( $ parent , $ child , $ joinType ) { $ via = $ child -> via ; $ child -> via = null ; if ( $ via instanceof self ) { $ this -> joinWithRelation ( $ parent , $ via , $ joinType ) ; $ this -> joinWithRelation ( $ via , $ child , $ joinType ) ; return ; } elseif ( is_array ( $ via ) ) { $ this -> joinWithRelation ( $ parent , $ via [ 1 ] , $ joinType ) ; $ this -> joinWithRelation ( $ via [ 1 ] , $ child , $ joinType ) ; return ; } list ( $ parentTable , $ parentAlias ) = $ parent -> getTableNameAndAlias ( ) ; list ( $ childTable , $ childAlias ) = $ child -> getTableNameAndAlias ( ) ; if ( ! empty ( $ child -> link ) ) { if ( strpos ( $ parentAlias , '{{' ) === false ) { $ parentAlias = '{{' . $ parentAlias . '}}' ; } if ( strpos ( $ childAlias , '{{' ) === false ) { $ childAlias = '{{' . $ childAlias . '}}' ; } $ on = [ ] ; foreach ( $ child -> link as $ childColumn => $ parentColumn ) { $ on [ ] = "$parentAlias.[[$parentColumn]] = $childAlias.[[$childColumn]]" ; } $ on = implode ( ' AND ' , $ on ) ; if ( ! empty ( $ child -> on ) ) { $ on = [ 'and' , $ on , $ child -> on ] ; } } else { $ on = $ child -> on ; } $ this -> join ( $ joinType , empty ( $ child -> from ) ? $ childTable : $ child -> from , $ on ) ; if ( ! empty ( $ child -> where ) ) { $ this -> andWhere ( $ child -> where ) ; } if ( ! empty ( $ child -> having ) ) { $ this -> andHaving ( $ child -> having ) ; } if ( ! empty ( $ child -> orderBy ) ) { $ this -> addOrderBy ( $ child -> orderBy ) ; } if ( ! empty ( $ child -> groupBy ) ) { $ this -> addGroupBy ( $ child -> groupBy ) ; } if ( ! empty ( $ child -> params ) ) { $ this -> addParams ( $ child -> params ) ; } if ( ! empty ( $ child -> join ) ) { foreach ( $ child -> join as $ join ) { $ this -> join [ ] = $ join ; } } if ( ! empty ( $ child -> union ) ) { foreach ( $ child -> union as $ union ) { $ this -> union [ ] = $ union ; } } }
1481	public function getDefaultCodec ( ) : Codec { return $ this -> factory -> createCodec ( $ this -> getContainer ( ) , $ this -> encodings -> find ( MediaTypeInterface :: JSON_API_MEDIA_TYPE ) ? : Encoding :: jsonApi ( ) , $ this -> decodings -> find ( MediaTypeInterface :: JSON_API_MEDIA_TYPE ) ) ; }
9800	public static function setChartRenderer ( $ rendererClass ) { if ( ! is_a ( $ rendererClass , IRenderer :: class , true ) ) { throw new Exception ( 'Chart renderer must implement ' . IRenderer :: class ) ; } self :: $ chartRenderer = $ rendererClass ; }
8500	protected function setSSLCurlOptions ( $ ch ) { curl_setopt ( $ ch , CURLOPT_SSL_VERIFYPEER , $ this -> _config [ 'SSL_VerifyPeer' ] ) ; curl_setopt ( $ ch , CURLOPT_SSL_VERIFYHOST , $ this -> _config [ 'SSL_VerifyHost' ] ) ; }
8435	public function delete ( ) : bool { $ status = false ; if ( $ this -> new === false ) { $ deleteQuery = new Delete ( $ this -> getDatabaseName ( ) ) ; $ deleteQuery -> from ( $ this -> getTableName ( ) ) ; $ where = array ( ) ; foreach ( $ this -> getPrimary ( ) as $ primary ) { $ field = $ this -> { 'field' . ucfirst ( $ primary ) } ; $ realName = constant ( get_called_class ( ) . '::FIELD_' . strtoupper ( Helper :: codifyName ( $ primary ) ) ) ; $ where [ $ realName ] = ':primary' . ucfirst ( $ primary ) ; $ deleteQuery -> bind ( 'primary' . ucfirst ( $ primary ) , $ field [ 'value' ] ) ; } $ deleteQuery -> where ( $ where ) ; $ status = $ deleteQuery -> execute ( ) ; } return $ status ; }
2800	protected static function generateBeanCreationCode ( string $ padding , string $ beanId , string $ methodParams , BeanPostProcessorsProperty $ postProcessorsProperty ) : string { $ content = $ padding . '$instance = parent::' . $ beanId . '(' . $ methodParams . ');' . PHP_EOL ; $ content .= $ padding . 'if ($instance instanceof \\' . InitializedBean :: class . ') { ' . PHP_EOL ; $ content .= $ padding . ' $instance->postInitialization();' . PHP_EOL ; $ content .= $ padding . '}' . PHP_EOL ; $ content .= PHP_EOL ; $ content .= $ padding . 'foreach ($this->' . $ postProcessorsProperty -> getName ( ) . ' as $postProcessor) { ' . PHP_EOL ; $ content .= $ padding . ' $postProcessor->postProcess($instance, "' . $ beanId . '");' . PHP_EOL ; $ content .= $ padding . '}' . PHP_EOL ; return $ content ; }
10056	public function getItem ( $ key ) { if ( $ this -> hasItem ( $ key ) !== true ) { $ this -> data [ $ key ] = new CacheItem ( $ key , null , false ) ; } return $ this -> data [ $ key ] ; }
6875	public static function query ( $ queryString , array $ queryParams = [ ] , $ dbName = "master" , $ fetchResults = true ) { $ query = static :: instance ( $ dbName ) -> prepare ( $ queryString ) ; foreach ( $ queryParams as $ column => $ val ) $ query -> bindValue ( is_int ( $ column ) ? $ column + 1 : ":" . $ column , $ val ) ; if ( $ query -> execute ( ) ) return $ fetchResults ? $ query -> fetchAll ( PDO :: FETCH_ASSOC ) : $ query -> rowCount ( ) ; return false ; }
11396	private static function _setFileNameInErrorFile ( ) { if ( defined ( 'BASH_CALLED' ) ) { error_log ( Bash :: setColor ( '############### ' . BASH_CALLED . ' ###############' , 'cyan' ) ) ; } else { if ( isset ( $ _SERVER [ 'HTTP_HOST' ] ) && isset ( $ _SERVER [ 'REQUEST_URI' ] ) ) { error_log ( Bash :: setColor ( '############### ' . $ _SERVER [ 'HTTP_HOST' ] . $ _SERVER [ 'REQUEST_URI' ] . ' ###############' , 'cyan' ) ) ; } } }
4860	public function push ( JobInterface $ job , array $ options = [ ] ) { $ envelope = $ this -> createEnvelope ( $ job , $ options ) ; $ result = $ this -> mongoCollection -> insertOne ( $ envelope ) ; $ job -> setId ( ( string ) $ result -> getInsertedId ( ) ) ; }
147	protected function processUrl ( PackageInterface $ package , $ url ) { if ( ! extension_loaded ( 'openssl' ) && 0 === strpos ( $ url , 'https:' ) ) { throw new \ RuntimeException ( 'You must enable the openssl extension to download files via https' ) ; } if ( $ package -> getDistReference ( ) ) { $ url = UrlUtil :: updateDistReference ( $ this -> config , $ url , $ package -> getDistReference ( ) ) ; } return $ url ; }
4886	public function plugin ( $ plugin , $ options = null ) { $ renderer = $ this -> getView ( ) ; if ( ! method_exists ( $ renderer , 'getHelperPluginManager' ) ) { return true === $ options ? false : new HelperProxy ( false ) ; } $ manager = $ renderer -> getHelperPluginManager ( ) ; $ hasPlugin = $ manager -> has ( $ plugin ) ; if ( true === $ options ) { return $ hasPlugin ; } if ( $ hasPlugin ) { $ pluginInstance = $ manager -> get ( $ plugin , $ options ) ; } else { $ pluginInstance = false ; } return new HelperProxy ( $ pluginInstance ) ; }
6327	private function getConstraintsSql ( ) { $ sql = '' ; foreach ( $ this -> table -> getConstraints ( ) as $ constraint ) { $ sql .= ',' ; if ( $ constraint instanceof PrimaryKey ) { $ sql .= ( string ) $ constraint ; } elseif ( $ constraint instanceof ForeignKey ) { $ sql .= sprintf ( 'CONSTRAINT %s FOREIGN KEY (%s) REFERENCES %s (%s) MATCH SIMPLE ON UPDATE %s ON DELETE %s' , $ constraint -> getName ( ) , implode ( ',' , $ constraint -> getColumns ( ) ) , $ constraint -> getReferencedTable ( ) -> getQualifiedName ( ) , implode ( ',' , $ constraint -> getReferencedColumns ( ) ) , $ constraint -> getUpdateAction ( ) , $ constraint -> getDeleteAction ( ) ) ; } elseif ( $ constraint instanceof Unique ) { $ sql .= sprintf ( 'CONSTRAINT %s UNIQUE (%s)' , $ constraint -> getName ( ) , implode ( ',' , $ constraint -> getColumns ( ) ) ) ; } } return rtrim ( $ sql , ',' ) ; }
8908	public function created_at ( $ row ) { if ( is_object ( $ row ) ) { $ row -> { $ this -> created_at_key } = date ( 'Y-m-d H:i:s' ) ; } else { $ row [ $ this -> created_at_key ] = date ( 'Y-m-d H:i:s' ) ; } return $ row ; }
4175	public function getProviders ( ) { return $ this -> providers ? : $ this -> providers = new ServiceProvider ( clone $ this -> getFiles ( ) , $ this -> console ) ; }
5947	public function getAdapterType ( ) { if ( $ this -> adapter instanceof AbstractAdapter ) { $ string = StringHelper :: factory ( get_class ( $ this -> adapter ) ) ; return $ string -> substr ( $ string -> findLast ( "\\" ) ) -> replace ( array ( "\\" , " " ) , "" ) -> toString ( ) ; } return "Unknown" ; }
4761	public function flush ( ) { if ( $ this -> doNotTrack ) { return ; } if ( empty ( $ this -> queue ) ) { return ; } if ( $ this -> mergePackets ) { $ this -> send ( implode ( "\n" , $ this -> queue ) ) ; } else { foreach ( $ this -> queue as $ data ) { $ this -> send ( $ data ) ; } } $ this -> queue = array ( ) ; $ this -> queueSize = 0 ; }
11179	protected function get ( $ key ) { $ cache = apc_fetch ( $ this -> getKey ( ) ) ; if ( ! is_array ( $ cache ) ) { return false ; } else { if ( isset ( $ cache [ $ key ] ) ) { return $ cache [ $ key ] ; } return false ; } }
595	private function deletePublishedAssets ( $ bundles ) { $ this -> stdout ( "Deleting source files...\n" ) ; if ( $ this -> getAssetManager ( ) -> linkAssets ) { $ this -> stdout ( "`AssetManager::linkAssets` option is enabled. Deleting of source files canceled.\n" , Console :: FG_YELLOW ) ; return ; } foreach ( $ bundles as $ bundle ) { if ( $ bundle -> sourcePath !== null ) { foreach ( $ bundle -> js as $ jsFile ) { @ unlink ( $ bundle -> basePath . DIRECTORY_SEPARATOR . $ jsFile ) ; } foreach ( $ bundle -> css as $ cssFile ) { @ unlink ( $ bundle -> basePath . DIRECTORY_SEPARATOR . $ cssFile ) ; } } } $ this -> stdout ( "Source files deleted.\n" , Console :: FG_GREEN ) ; }
7209	public static function createFinalFromGross ( Amount $ gross ) : Amount { $ final = new Amount ( $ gross -> getCurrency ( ) , $ gross -> getBase ( ) , $ gross -> getBase ( ) , 0 , $ gross -> getBase ( ) , $ gross -> getTax ( ) , $ gross -> getTotal ( ) ) ; foreach ( $ gross -> getTaxAdjustments ( ) as $ t ) { $ final -> addTaxAdjustment ( $ t ) ; } return $ final ; }
2301	public static function convertLayoutSectionIdsToAssociativeArray ( $ arrSections ) { $ arrSections = array_flip ( array_values ( array_unique ( $ arrSections ) ) ) ; foreach ( array_keys ( $ arrSections ) as $ k ) { $ arrSections [ $ k ] = $ GLOBALS [ 'TL_LANG' ] [ 'COLS' ] [ $ k ] ; } asort ( $ arrSections ) ; return $ arrSections ; }
1441	protected function replaceResourceType ( & $ stub ) { $ resource = $ this -> getResourceName ( ) ; $ stub = str_replace ( 'dummyResourceType' , Str :: dasherize ( $ resource ) , $ stub ) ; return $ this ; }
11377	public function getAction ( ) { if ( ! preg_match ( '/\/page\/(\w+[\-\w]*)\/text\/(..)(\/(\w+))?$/' , $ this -> name , $ matches ) ) { throw new InvalidParameterException ( "Invalid parameters" ) ; } $ pageName = $ matches [ 1 ] ; $ language = $ matches [ 2 ] ; $ pageTexts = $ this -> getTextModel ( $ pageName ) ; if ( empty ( $ matches [ 4 ] ) ) { $ result = array_values ( $ pageTexts -> getTextsWithBaseTexts ( $ language ) ) ; } else { $ result = $ pageTexts -> getText ( $ matches [ 4 ] , $ language ) ; } $ this -> environment -> sendJSONResult ( $ result ) ; }
76	public function remove ( ) { $ offset = $ this -> key ( ) ; $ this -> offsetUnset ( $ offset ) ; $ this -> seek ( $ offset ) ; }
1270	private function createRequest ( ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; $ quantumViewRequest = $ xml -> appendChild ( $ xml -> createElement ( 'QuantumViewRequest' ) ) ; $ quantumViewRequest -> setAttribute ( 'xml:lang' , 'en-US' ) ; if ( null !== $ this -> name || null !== $ this -> beginDateTime || null !== $ this -> fileName ) { $ subscriptionRequest = $ quantumViewRequest -> appendChild ( $ xml -> createElement ( 'SubscriptionRequest' ) ) ; if ( null !== $ this -> name ) { $ subscriptionRequest -> appendChild ( $ xml -> createElement ( 'Name' , $ this -> name ) ) ; } if ( null !== $ this -> beginDateTime ) { $ dateTimeRange = $ subscriptionRequest -> appendChild ( $ xml -> createElement ( 'DateTimeRange' ) ) ; $ dateTimeRange -> appendChild ( $ xml -> createElement ( 'BeginDateTime' , $ this -> beginDateTime ) ) ; $ dateTimeRange -> appendChild ( $ xml -> createElement ( 'EndDateTime' , $ this -> endDateTime ) ) ; } elseif ( null !== $ this -> fileName ) { $ subscriptionRequest -> appendChild ( $ xml -> createElement ( 'FileName' , $ this -> fileName ) ) ; } } if ( null !== $ this -> bookmark ) { $ quantumViewRequest -> appendChild ( $ xml -> createElement ( 'Bookmark' , $ this -> bookmark ) ) ; } $ request = $ quantumViewRequest -> appendChild ( $ xml -> createElement ( 'Request' ) ) ; $ node = $ xml -> importNode ( $ this -> createTransactionNode ( ) , true ) ; $ request -> appendChild ( $ node ) ; $ request -> appendChild ( $ xml -> createElement ( 'RequestAction' , 'QVEvents' ) ) ; return $ xml -> saveXML ( ) ; }
8379	public function getNested ( $ keyString , $ default = null , $ separator = '.' ) { $ keys = explode ( $ separator , $ keyString ) ; $ data = $ this -> array ; foreach ( $ keys as $ key ) { if ( ! is_array ( $ data ) or ! array_key_exists ( $ key , $ data ) ) { return $ default ; } $ data = $ data [ $ key ] ; } return $ data ; }
12019	function addProperties ( ) { $ requiredProperties = [ 'api' => '\\' . $ this -> apiClassname , 'parameters' => 'array' , 'response' => '\Amp\Artax\Response' , 'originalResponse' => '\Amp\Artax\Response' , ] ; foreach ( $ requiredProperties as $ propertyName => $ typehint ) { $ propertyGenerator = new PropertyGenerator ( $ propertyName , null ) ; $ docBlock = new DocBlockGenerator ( '@var ' . $ typehint ) ; $ propertyGenerator -> setDocBlock ( $ docBlock ) ; $ this -> classGenerator -> addPropertyFromGenerator ( $ propertyGenerator ) ; } $ docBlock = new DocBlockGenerator ( 'Get the last response.' ) ; $ body = 'return $this->response;' ; $ methodGenerator = $ this -> createMethodGenerator ( 'getResponse' , $ body , $ docBlock , [ ] , '\Amp\Artax\Response' ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; $ docBlock = new DocBlockGenerator ( 'Set the last response. This should only be used by the API class when the operation has been dispatched. Storing the response is required as some APIs store out-of-bound information in the headers e.g. rate-limit info, pagination that is not really part of the operation.' ) ; $ body = '$this->response = $response;' ; $ methodGenerator = $ this -> createMethodGenerator ( 'setResponse' , $ body , $ docBlock , [ [ 'response' , 'Amp\Artax\Response' ] ] ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; }
11408	public function onBootstrap ( MvcEvent $ e ) { if ( ! $ e -> getRequest ( ) instanceof HttpRequest ) { return ; } $ app = $ e -> getApplication ( ) ; $ services = $ app -> getServiceManager ( ) ; $ eventManager = $ app -> getEventManager ( ) ; $ sharedEventManager = $ eventManager -> getSharedManager ( ) ; $ sharedEventManager -> attach ( UserService :: class , 'register' , function ( $ e ) use ( $ services ) { $ user = $ e -> getParam ( 'user' ) ; if ( $ user instanceof RoleableInterface && $ services -> has ( AuthorizationModuleOptions :: class ) ) { $ config = $ services -> get ( PermissionsModuleOptions :: class ) ; $ roleClass = $ config -> getRoleEntityClass ( ) ; $ mapper = $ services -> get ( 'MapperManager' ) -> get ( $ roleClass ) ; if ( $ defaultRole = $ mapper -> find ( $ config -> getAuthenticatedRole ( ) ) ) { $ user -> addRole ( $ defaultRole ) ; } } } , 100 ) ; }
4042	public function getReadableValue ( RenderReadablePropertyValueEvent $ event ) { $ environment = $ event -> getEnvironment ( ) ; $ definition = $ environment -> getDataDefinition ( ) ; $ model = $ event -> getModel ( ) ; if ( ! ( $ model instanceof Model ) ) { return ; } $ nativeItem = $ model -> getItem ( ) ; $ metaModel = $ nativeItem -> getMetaModel ( ) ; $ renderSetting = $ this -> renderSettingFactory -> createCollection ( $ metaModel , $ definition -> getMetaModelDefinition ( ) -> getActiveRenderSetting ( ) ) ; if ( ! $ renderSetting ) { return ; } $ result = $ nativeItem -> parseAttribute ( $ event -> getProperty ( ) -> getName ( ) , 'text' , $ renderSetting ) ; if ( ! isset ( $ result [ 'text' ] ) ) { $ event -> setRendered ( sprintf ( 'Unexpected behaviour, attribute %s text representation was not rendered.' , $ event -> getProperty ( ) -> getName ( ) ) ) ; return ; } $ event -> setRendered ( $ result [ 'text' ] ) ; }
2486	public function commit ( $ flush = false ) { $ payload = $ flush ? '<commit/>' : '<commit softCommit="true"/>' ; foreach ( $ this -> endpointResolver -> getEndpoints ( ) as $ endpointName ) { $ result = $ this -> client -> request ( 'POST' , $ this -> endpointRegistry -> getEndpoint ( $ endpointName ) , '/update' , new Message ( array ( 'Content-Type' => 'text/xml' , ) , $ payload ) ) ; if ( $ result -> headers [ 'status' ] !== 200 ) { throw new RuntimeException ( 'Wrong HTTP status received from Solr: ' . $ result -> headers [ 'status' ] . var_export ( $ result , true ) ) ; } } }
3861	public function prepare ( ) { if ( $ this -> objItems ) { return $ this ; } if ( ! $ this -> objFilter ) { $ this -> objFilter = $ this -> objMetaModel -> getEmptyFilter ( ) ; } if ( $ this -> objFilterSettings ) { $ this -> objFilterSettings -> addRules ( $ this -> objFilter , $ this -> arrParam ) ; } $ this -> modifyFilter ( ) ; $ intTotal = $ this -> objMetaModel -> getCount ( $ this -> objFilter ) ; $ calculator = $ this -> paginationLimitCalculator ; $ calculator -> setTotalAmount ( $ intTotal ) ; $ curPage = ( int ) \ Input :: get ( 'page' ) ; if ( $ curPage > 1 ) { $ calculator -> setCurrentPage ( $ curPage ) ; } $ this -> objTemplate -> total = $ intTotal ; $ this -> objItems = $ this -> objMetaModel -> findByFilter ( $ this -> objFilter , $ this -> strSortBy , $ calculator -> getCalculatedOffset ( ) , $ calculator -> getCalculatedLimit ( ) , $ this -> strSortDirection , $ this -> getAttributeNames ( ) ) ; return $ this ; }
7544	function getNextSibling ( $ skip_text_comments = true ) { $ offset = 1 ; while ( ( $ n = $ this -> getSibling ( $ offset ) ) !== null ) { if ( $ skip_text_comments && ( $ n -> tag [ 0 ] === '~' ) ) { ++ $ offset ; } else { break ; } } return $ n ; }
10121	private function writeMarginBottom ( ) { $ record = 0x0029 ; $ length = 0x0008 ; $ margin = $ this -> phpSheet -> getPageMargins ( ) -> getBottom ( ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'd' , $ margin ) ; if ( self :: getByteOrder ( ) ) { $ data = strrev ( $ data ) ; } $ this -> append ( $ header . $ data ) ; }
3012	public function unfollow ( $ blogName ) { $ options = array ( 'url' => $ this -> blogUrl ( $ blogName ) ) ; return $ this -> postRequest ( 'v2/user/unfollow' , $ options , false ) ; }
5458	protected function openTag ( $ tag ) { $ name = $ tag -> getTagName ( ) ; if ( ! in_array ( $ name , array_keys ( $ this -> tags ) ) ) { $ this -> tags [ $ name ] = array ( ) ; } $ this -> tags [ $ name ] [ ] = $ tag ; }
8036	public static function convert ( $ input , $ outputFormat = Code :: FORMAT_ALNUM , $ minLength = null ) { if ( is_int ( $ minLength ) ) { $ input += self :: getMinForlength ( $ outputFormat , $ minLength ) ; } static :: throwUnlessAcceptable ( $ outputFormat , $ input ) ; return self :: convertBase ( $ input , self :: FORMAT_NUMBER , $ outputFormat ) ; }
6009	public function setDeleted ( $ deleted ) { if ( $ deleted instanceof DateTime ) { $ this -> deleted = $ deleted ; } else { try { $ this -> deleted = new DateTime ( $ deleted ) ; } catch ( \ Exception $ e ) { $ this -> deleted = null ; } } return $ this ; }
5290	protected static function requestCurl ( $ url , $ params ) { $ ch = curl_init ( ) ; $ options = array ( CURLOPT_URL => $ url , CURLOPT_HTTPHEADER => self :: getHeaders ( ) , CURLOPT_POSTFIELDS => json_encode ( $ params ) , CURLOPT_CONNECTTIMEOUT => self :: $ connectTimeout , CURLOPT_TIMEOUT => self :: $ requestTimeout , CURLOPT_USERAGENT => self :: getUserAgent ( ) , CURLOPT_RETURNTRANSFER => true ) ; curl_setopt_array ( $ ch , $ options ) ; $ result = curl_exec ( $ ch ) ; if ( $ result === false ) { $ e = new Error ( curl_error ( $ ch ) ) ; curl_close ( $ ch ) ; throw $ e ; } curl_close ( $ ch ) ; return $ result ; }
6118	public function serverCreate ( array $ properties = array ( ) ) { $ this -> serverListReset ( ) ; $ detail = $ this -> execute ( "servercreate" , $ properties ) -> toList ( ) ; $ server = new Server ( $ this , array ( "virtualserver_id" => intval ( $ detail [ "sid" ] ) ) ) ; Signal :: getInstance ( ) -> emit ( "notifyServercreated" , $ this , $ detail [ "sid" ] ) ; Signal :: getInstance ( ) -> emit ( "notifyTokencreated" , $ server , $ detail [ "token" ] ) ; return $ detail ; }
5900	public function retrieveFunctionality ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/accounts/functionalities/' . $ id . '' , $ parameters , $ cachePolicy ) ; $ result = new Functionality ( $ result ) ; return $ result ; }
2210	public function fetchAssoc ( ) { if ( $ this -> intIndex >= $ this -> count ( ) - 1 ) { return false ; } $ this -> arrCache = $ this -> resultSet [ ++ $ this -> intIndex ] ; return $ this -> arrCache ; }
152	public function batch ( $ batchSize = 100 , $ db = null ) { return Yii :: createObject ( [ 'class' => BatchQueryResult :: className ( ) , 'query' => $ this , 'batchSize' => $ batchSize , 'db' => $ db , 'each' => false , ] ) ; }
12453	static function run_generate_sample_package_xml ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { pake_copy ( self :: getResourceDir ( ) . '/package_master.xml' , 'package.xml' ) ; $ tokens = array ( '$summary' => '[Summary]' , '$description' => '[Description]' , '$vendor' => '' , '$maintainers' => '' , '$documents' => '' , '$changelog' => '' , '$simple-files' => '' , '$state' => '[State]' , '$requires' => '' ) ; pake_replace_tokens ( 'package.xml' , '.' , '{' , '}' , $ tokens ) ; pake_echo ( "File package.xml generated. Please replace all tokens in square brackets in it (but do not replace values in curly brackets) then commit it to sources in the top dir of the extension" ) ; }
3098	public function getStateMessage ( $ testSession ) { if ( $ testSession instanceof AssessmentTestSession ) { switch ( $ testSession -> getState ( ) ) { case AssessmentTestSessionState :: SUSPENDED : return $ this -> getPausedStateMessage ( $ testSession ) ; case AssessmentTestSessionState :: CLOSED : return $ this -> getTerminatedStateMessage ( $ testSession ) ; case AssessmentTestSessionState :: INITIAL : return $ this -> getInitialStateMessage ( $ testSession ) ; default : return $ this -> getRunningStateMessages ( $ testSession ) ; } } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerMessageService' , 'getStateMessage' , 0 , 'qtism\runtime\tests\AssessmentTestSession' , $ testSession ) ; } }
2433	public function get ( $ strKey ) { if ( \ in_array ( $ strKey , $ this -> mappedKeys ) ) { return $ this -> session -> get ( $ strKey ) ; } return $ this -> sessionBag -> get ( $ strKey ) ; }
11938	public function findAll ( $ params = [ ] ) { $ return = $ this -> populateRecords ( $ this -> find ( $ params ) -> all ( $ this -> interface -> db ) ) ; return $ return ; }
504	protected function renderHtmlResponse ( ) { return $ this -> controller -> render ( $ this -> view ? : $ this -> id , $ this -> getViewRenderParams ( ) ) ; }
12087	public static function create ( $ validator , $ command ) { static $ cache = [ ] ; $ cacheKey = $ validator ; if ( isset ( $ cache [ $ cacheKey ] ) ) { $ class = $ cache [ $ cacheKey ] [ 'class' ] ; $ validator = $ cache [ $ cacheKey ] [ 'validator' ] ; } else { if ( false === strpos ( $ validator , '.' ) ) { $ class = __NAMESPACE__ . '\\' . String :: convertToCamelCase ( $ validator ) ; } else { $ class = explode ( '.' , $ validator ) ; $ class = array_map ( array ( 'In2pire\\Component\\Utility\\Text' , 'convertToCamelCase' ) , $ class ) ; $ class = implode ( '\\' , $ class ) ; $ validator = substr ( $ validator , strrpos ( $ validator , '.' ) + 1 ) ; } $ cache [ $ cacheKey ] = [ 'class' => $ class , 'validator' => $ validator ] ; } if ( ! class_exists ( $ class ) ) { throw new \ RuntimeException ( 'Unknow validator ' . $ cacheKey ) ; } return new $ class ( $ command ) ; }
3353	public function updateInfo ( ) { $ this -> cached_data = ( array ) $ this -> api -> __preparedRequest ( 'file' , 'GET' , array ( 'uuid' => $ this -> uuid ) ) ; return $ this -> cached_data ; }
5827	public function buildUrl ( $ url , array $ query ) { if ( ! empty ( $ query ) ) { $ queryString = http_build_query ( $ query ) ; $ url .= '?' . $ queryString ; } return $ url ; }
8768	protected function registerApplicationAliases ( ) { foreach ( $ this -> config [ 'services' ] [ 'aliases' ] as $ key => $ alias ) { $ this -> alias ( $ key , $ alias ) ; if ( ! class_exists ( $ key ) ) { class_alias ( $ alias , $ key ) ; } } }
9738	public function setFitToHeight ( $ pValue , $ pUpdate = true ) { $ this -> fitToHeight = $ pValue ; if ( $ pUpdate ) { $ this -> fitToPage = true ; } return $ this ; }
7243	public function description ( ) { $ default = Inform_About_Content :: default_opt_in ( NULL ) ; $ subscribed_by_default = apply_filters ( 'iac_default_opt_in' , $ default ) ; $ description = $ subscribed_by_default ? __ ( 'Note: Users must opt-out from e-mail notifications by default' , Inform_About_Content :: TEXTDOMAIN ) : __ ( 'Note: Users must opt-in to e-mail notifications by default' , Inform_About_Content :: TEXTDOMAIN ) ; printf ( '<p class="description">%s</p>' , $ description ) ; }
4576	public function get ( $ id , Parameters $ parameters = null ) { if ( null !== $ id ) { $ resource = str_replace ( '{id}' , $ id , static :: RESOURCE_OBJECT ) ; } else { $ key = $ parameters -> getKey ( ) ; $ tenantId = $ parameters -> getTenantId ( ) ; switch ( true ) { case null !== $ key && null !== $ tenantId : $ resource = str_replace ( [ '{key}' , '{tenant-id}' ] , [ $ key , $ tenantId ] , static :: RESOURCE_OBJECT_BY_KEY_AND_TENANT_ID ) ; break ; case null !== $ key : $ resource = str_replace ( '{key}' , $ key , static :: RESOURCE_OBJECT_BY_KEY ) ; break ; default : throw new LogicException ( '"Key" and/or "TenantId" parameters are not defined.' ) ; } } $ options = [ 'headers' => [ 'Accept' => 'application/json' ] ] ; $ object = $ this -> execute ( 'GET' , $ resource , $ options ) ; $ model = static :: toModel ( $ object ) ; return $ model ; }
3583	protected function joinMeta ( Builder $ query , $ column ) { $ query -> prefixColumnsForJoin ( ) ; $ alias = $ this -> generateMetaAlias ( ) ; $ table = ( new Attribute ) -> getTable ( ) ; $ query -> leftJoin ( "{$table} as {$alias}" , function ( $ join ) use ( $ alias , $ column ) { $ join -> on ( "{$alias}.metable_id" , '=' , $ this -> getQualifiedKeyName ( ) ) -> where ( "{$alias}.metable_type" , '=' , $ this -> getMorphClass ( ) ) -> where ( "{$alias}.meta_key" , '=' , $ column ) ; } ) ; return $ alias ; }
7291	private function getByMethodAndStatesFromDateQuery ( ) { if ( null !== $ this -> byMethodAndStatesFromDateQuery ) { return $ this -> byMethodAndStatesFromDateQuery ; } $ qb = $ this -> createQueryBuilder ( 'p' ) ; $ query = $ qb -> andWhere ( $ qb -> expr ( ) -> eq ( 'p.method' , ':method' ) ) -> andWhere ( $ qb -> expr ( ) -> in ( 'p.state' , ':states' ) ) -> andWhere ( $ qb -> expr ( ) -> gte ( 'p.createdAt' , ':date' ) ) -> addOrderBy ( 'p.createdAt' , 'ASC' ) -> getQuery ( ) -> useQueryCache ( true ) ; return $ this -> byMethodAndStatesFromDateQuery = $ query ; }
289	protected function isLanguageSupported ( $ requested , $ supported ) { $ supported = str_replace ( '_' , '-' , strtolower ( $ supported ) ) ; $ requested = str_replace ( '_' , '-' , strtolower ( $ requested ) ) ; return strpos ( $ requested . '-' , $ supported . '-' ) === 0 ; }
3288	private function readDataFromPendingClient ( $ socket , int $ length , PendingSocketClient $ state ) { $ data = \ fread ( $ socket , $ length ) ; if ( $ data === false || $ data === '' ) { return null ; } $ data = $ state -> receivedDataBuffer . $ data ; if ( \ strlen ( $ data ) < $ length ) { $ state -> receivedDataBuffer = $ data ; return null ; } $ state -> receivedDataBuffer = '' ; Loop :: cancel ( $ state -> readWatcher ) ; return $ data ; }
2229	public function dragFile ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { return '<button type="button" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '" ' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</button> ' ; }
11892	public function newAction ( Request $ request ) { $ entity = new CustomField ( ) ; $ cfGroupId = $ request -> query -> get ( 'customFieldsGroup' , null ) ; if ( $ cfGroupId !== null ) { $ cfGroup = $ this -> getDoctrine ( ) -> getManager ( ) -> getRepository ( 'ChillCustomFieldsBundle:CustomFieldsGroup' ) -> find ( $ cfGroupId ) ; if ( ! $ cfGroup ) { throw $ this -> createNotFoundException ( 'CustomFieldsGroup with id ' . $ cfGroupId . ' is not found !' ) ; } $ entity -> setCustomFieldsGroup ( $ cfGroup ) ; } $ form = $ this -> createCreateForm ( $ entity , $ request -> query -> get ( 'type' ) ) ; return $ this -> render ( 'ChillCustomFieldsBundle:CustomField:new.html.twig' , array ( 'entity' => $ entity , 'form' => $ form -> createView ( ) , ) ) ; }
3477	public function withLocalizedTitle ( Localized $ localized ) : Alert { $ cloned = clone $ this ; $ cloned -> title = '' ; $ cloned -> titleLocalized = $ localized ; return $ cloned ; }
12277	public function update ( $ groupId , $ name ) { $ params = [ 'group' => [ 'id' => $ groupId , 'name' => $ name , ] , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_UPDATE , $ params ] ) ; }
71	protected function filterPackageMap ( array $ packageMap , PackageInterface $ mainPackage ) { $ packages = array ( ) ; $ include = array ( ) ; foreach ( $ packageMap as $ item ) { $ package = $ item [ 0 ] ; $ name = $ package -> getName ( ) ; $ packages [ $ name ] = $ package ; } $ add = function ( PackageInterface $ package ) use ( & $ add , $ packages , & $ include ) { foreach ( $ package -> getRequires ( ) as $ link ) { $ target = $ link -> getTarget ( ) ; if ( ! isset ( $ include [ $ target ] ) ) { $ include [ $ target ] = true ; if ( isset ( $ packages [ $ target ] ) ) { $ add ( $ packages [ $ target ] ) ; } } } } ; $ add ( $ mainPackage ) ; return array_filter ( $ packageMap , function ( $ item ) use ( $ include ) { $ package = $ item [ 0 ] ; foreach ( $ package -> getNames ( ) as $ name ) { if ( isset ( $ include [ $ name ] ) ) { return true ; } } return false ; } ) ; }
11747	public function group ( ) { if ( is_null ( $ this -> group ) ) { $ this -> group = new Group ( $ this -> accessToken ) ; } return $ this -> group ; }
12451	static function run_check_php_files ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { $ opts = self :: getOpts ( @ $ args [ 0 ] , @ $ args [ 1 ] , $ cliopts ) ; if ( ! SharedLock :: acquire ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ) throw new PakeException ( "Source code locked by another process" ) ; $ destdir = self :: getBuildDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ; $ files = pakeFinder :: type ( 'file' ) -> name ( array ( '*.php' ) ) -> in ( $ destdir ) ; if ( count ( $ files ) ) { $ php = self :: getTool ( 'php' , $ opts ) ; if ( strpos ( pake_sh ( $ php . " -v" ) , 'PHP' ) === false ) { SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; throw new pakeException ( "$php does not seem to be a valid php executable" ) ; } foreach ( pakeFinder :: type ( 'file' ) -> name ( array ( '*.php' ) ) -> in ( $ destdir ) as $ file ) { if ( strpos ( pake_sh ( $ php . " -l " . escapeshellarg ( $ file ) ) , 'No syntax errors detected' ) === false ) { SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; throw new pakeException ( "$file does not seem to be a valid php file" ) ; } } } SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; }
966	public function dispatchAfterAuthenticate ( ) { $ jobsConfig = Config :: get ( 'shopify-app.after_authenticate_job' ) ; $ fireJob = function ( $ config ) { $ job = $ config [ 'job' ] ; if ( isset ( $ config [ 'inline' ] ) && $ config [ 'inline' ] === true ) { $ job :: dispatchNow ( $ this -> shop ) ; } else { $ job :: dispatch ( $ this -> shop ) -> onQueue ( Config :: get ( 'shopify-app.job_queues.after_authenticate' ) ) ; } return true ; } ; if ( isset ( $ jobsConfig [ 0 ] ) ) { foreach ( $ jobsConfig as $ jobConfig ) { $ fireJob ( $ jobConfig ) ; } return true ; } if ( isset ( $ jobsConfig [ 'job' ] ) ) { return $ fireJob ( $ jobsConfig ) ; } return false ; }
489	protected function findTableConstraints ( $ table , $ type ) { $ keyColumnUsageTableName = 'INFORMATION_SCHEMA.KEY_COLUMN_USAGE' ; $ tableConstraintsTableName = 'INFORMATION_SCHEMA.TABLE_CONSTRAINTS' ; if ( $ table -> catalogName !== null ) { $ keyColumnUsageTableName = $ table -> catalogName . '.' . $ keyColumnUsageTableName ; $ tableConstraintsTableName = $ table -> catalogName . '.' . $ tableConstraintsTableName ; } $ keyColumnUsageTableName = $ this -> quoteTableName ( $ keyColumnUsageTableName ) ; $ tableConstraintsTableName = $ this -> quoteTableName ( $ tableConstraintsTableName ) ; $ sql = <<<SQLSELECT [kcu].[constraint_name] AS [index_name], [kcu].[column_name] AS [field_name]FROM {$keyColumnUsageTableName} AS [kcu]LEFT JOIN {$tableConstraintsTableName} AS [tc] ON [kcu].[table_schema] = [tc].[table_schema] AND [kcu].[table_name] = [tc].[table_name] AND [kcu].[constraint_name] = [tc].[constraint_name]WHERE [tc].[constraint_type] = :type AND [kcu].[table_name] = :tableName AND [kcu].[table_schema] = :schemaNameSQL ; return $ this -> db -> createCommand ( $ sql , [ ':tableName' => $ table -> name , ':schemaName' => $ table -> schemaName , ':type' => $ type , ] ) -> queryAll ( ) ; }
4913	public function add ( $ name , $ entities = null , array $ options = null ) { if ( $ name instanceof DependencyResult ) { return $ this -> addResult ( $ name ) ; } if ( $ name instanceof \ Traversable ) { return $ this -> addTraversable ( $ name ) ; } if ( is_array ( $ name ) ) { return $ this -> addArray ( $ name ) ; } if ( null === $ entities ) { throw new \ UnexpectedValueException ( '$entities must not be null.' ) ; } return $ this -> addArray ( [ 'name' => $ name , 'entities' => $ entities , 'options' => $ options , ] ) ; }
4895	public function render ( $ type = null , $ content = true , array $ options = array ( ) ) { if ( is_array ( $ type ) ) { $ options = $ type ; $ type = self :: TYPE_INFO ; $ content = true ; } elseif ( is_array ( $ content ) ) { $ options = $ content ; $ content = true ; } if ( true === $ content ) { return $ this -> start ( $ type , $ options ) ; } $ id = isset ( $ options [ 'id' ] ) ? ' id="' . $ options [ 'id' ] . '"' : '' ; $ class = isset ( $ options [ 'class' ] ) ? ' ' . $ options [ 'class' ] : '' ; if ( ( isset ( $ options [ 'dismissable' ] ) && $ options [ 'dismissable' ] ) || ! isset ( $ options [ 'dismissable' ] ) ) { $ class .= ' alert-dismissable' ; $ content = '<button type="button" class="close" data-dismiss="alert">&times;</button>' . '<span class="notification-content">' . $ content . '</span>' ; } $ target = array_key_exists ( 'target' , $ options ) ? ' target="' . $ options [ 'target' ] . '"' : '' ; $ markup = '<div ' . $ id . ' class="alert alert-' . $ type . $ class . '" ' . $ target . '>' . $ content . '</div>' . PHP_EOL ; return $ markup ; }
4795	function aggregation ( $ function ) { $ join = $ this -> createJoins ( implode ( "," , $ this -> conditions ) . ",$function" ) ; $ query = "SELECT $function FROM $this->table" . implode ( $ join ) ; if ( $ this -> where ) { $ query .= " WHERE " . implode ( $ this -> where ) ; } foreach ( $ this -> query ( $ query , $ this -> parameters ) -> fetch ( ) as $ return ) { return $ return ; } }
10817	public static function info ( $ messages , $ linebreak = true , $ length = 0 ) { $ separator = $ linebreak ? "\n" : '' ; self :: write ( $ messages , 'info' , $ length , $ separator ) ; }
12445	private function getPlainCalcId ( $ period ) { if ( $ period ) { $ dsMax = $ this -> hlpPeriod -> getPeriodLastDate ( $ period ) ; } else { $ dsMax = Cfg :: DEF_MAX_DATESTAMP ; } $ query = $ this -> qbCalcGetLast -> build ( ) ; $ bind = [ QBCalcGetLast :: BND_CODE => Cfg :: CODE_TYPE_CALC_FORECAST_PLAIN , QBCalcGetLast :: BND_DATE => $ dsMax , QBCalcGetLast :: BND_STATE => Cfg :: CALC_STATE_COMPLETE ] ; $ conn = $ query -> getConnection ( ) ; $ rs = $ conn -> fetchRow ( $ query , $ bind ) ; $ result = $ rs [ QBCalcGetLast :: A_CALC_ID ] ; return $ result ; }
11404	public function changeAction ( ) { $ theme = $ this -> container -> get ( 'request' ) -> request -> get ( 'admin_theme' ) ; $ this -> container -> get ( 'vince_t.admin.theme.handler' ) -> setCurrentTheme ( $ theme ) ; $ headers = $ this -> container -> get ( 'request' ) -> server -> getHeaders ( ) ; $ referer = $ headers [ 'REFERER' ] ; return new RedirectResponse ( $ referer ) ; }
11513	public function actionReset ( $ id , $ code ) { if ( ! $ this -> module -> enablePasswordRecovery ) { throw new NotFoundHttpException ; } $ token = $ this -> finder -> findToken ( [ 'user_id' => $ id , 'code' => $ code , 'type' => Token :: TYPE_RECOVERY ] ) -> one ( ) ; if ( $ token === null || $ token -> isExpired || $ token -> user === null ) { \ Yii :: $ app -> session -> setFlash ( 'danger' , \ Yii :: t ( 'user' , 'Recovery link is invalid or expired. Please try requesting a new one.' ) ) ; return $ this -> render ( '/message' , [ 'title' => \ Yii :: t ( 'user' , 'Invalid or expired link' ) , 'module' => $ this -> module , ] ) ; } $ model = \ Yii :: createObject ( [ 'class' => RecoveryForm :: className ( ) , 'scenario' => 'reset' , ] ) ; $ this -> performAjaxValidation ( $ model ) ; if ( $ model -> load ( \ Yii :: $ app -> getRequest ( ) -> post ( ) ) && $ model -> resetPassword ( $ token ) ) { return $ this -> render ( '/message' , [ 'title' => \ Yii :: t ( 'user' , 'Password has been changed' ) , 'module' => $ this -> module , ] ) ; } return $ this -> render ( 'reset' , [ 'model' => $ model , ] ) ; }
4193	protected function dumpProperties ( $ abs ) { $ label = \ count ( $ abs [ 'properties' ] ) ? 'properties' : 'no properties' ; if ( $ abs [ 'viaDebugInfo' ] ) { $ label .= ' <span class="text-muted">(via __debugInfo)</span>' ; } $ str = '<dt class="properties">' . $ label . '</dt>' . "\n" ; $ magicMethods = \ array_intersect ( array ( '__get' , '__set' ) , \ array_keys ( $ abs [ 'methods' ] ) ) ; $ str .= $ this -> magicMethodInfo ( $ magicMethods ) ; foreach ( $ abs [ 'properties' ] as $ k => $ info ) { $ vis = ( array ) $ info [ 'visibility' ] ; $ isPrivateAncestor = \ in_array ( 'private' , $ vis ) && $ info [ 'inheritedFrom' ] ; $ classes = \ array_keys ( \ array_filter ( array ( 'debuginfo-value' => $ info [ 'valueFrom' ] == 'debugInfo' , 'excluded' => $ info [ 'isExcluded' ] , 'forceShow' => $ info [ 'forceShow' ] , 'debug-value' => $ info [ 'valueFrom' ] == 'debug' , 'private-ancestor' => $ isPrivateAncestor , 'property' => true , \ implode ( ' ' , $ vis ) => $ info [ 'visibility' ] !== 'debug' , ) ) ) ; $ modifiers = $ vis ; if ( $ info [ 'isStatic' ] ) { $ modifiers [ ] = 'static' ; } $ str .= '<dd class="' . \ implode ( ' ' , $ classes ) . '">' . \ implode ( ' ' , \ array_map ( function ( $ modifier ) { return '<span class="t_modifier_' . $ modifier . '">' . $ modifier . '</span>' ; } , $ modifiers ) ) . ( $ isPrivateAncestor ? ' (<i>' . $ info [ 'inheritedFrom' ] . '</i>)' : '' ) . ( $ info [ 'type' ] ? ' <span class="t_type">' . $ info [ 'type' ] . '</span>' : '' ) . ' <span class="property-name"' . ' title="' . \ htmlspecialchars ( $ info [ 'desc' ] ) . '"' . '>' . $ k . '</span>' . ( $ info [ 'value' ] !== $ this -> debug -> abstracter -> UNDEFINED ? ' <span class="t_operator">=</span> ' . $ this -> debug -> output -> html -> dump ( $ info [ 'value' ] ) : '' ) . '</dd>' . "\n" ; } return $ str ; }
10882	protected function aggregateTernaryValues ( array $ values ) { if ( in_array ( false , $ values , true ) ) { return false ; } elseif ( in_array ( true , $ values , true ) ) { return true ; } else { return null ; } }
9988	public function generateHTMLHeader ( $ pIncludeStyles = false ) { if ( $ this -> spreadsheet === null ) { throw new WriterException ( 'Internal Spreadsheet object not set to an instance of an object.' ) ; } $ properties = $ this -> spreadsheet -> getProperties ( ) ; $ html = '<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">' . PHP_EOL ; $ html .= '<html>' . PHP_EOL ; $ html .= ' <head>' . PHP_EOL ; $ html .= ' <meta http-equiv="Content-Type" content="text/html; charset=utf-8">' . PHP_EOL ; $ html .= ' <meta name="generator" content="PhpSpreadsheet, https://github.com/PHPOffice/PhpSpreadsheet">' . PHP_EOL ; if ( $ properties -> getTitle ( ) > '' ) { $ html .= ' <title>' . htmlspecialchars ( $ properties -> getTitle ( ) ) . '</title>' . PHP_EOL ; } if ( $ properties -> getCreator ( ) > '' ) { $ html .= ' <meta name="author" content="' . htmlspecialchars ( $ properties -> getCreator ( ) ) . '" />' . PHP_EOL ; } if ( $ properties -> getTitle ( ) > '' ) { $ html .= ' <meta name="title" content="' . htmlspecialchars ( $ properties -> getTitle ( ) ) . '" />' . PHP_EOL ; } if ( $ properties -> getDescription ( ) > '' ) { $ html .= ' <meta name="description" content="' . htmlspecialchars ( $ properties -> getDescription ( ) ) . '" />' . PHP_EOL ; } if ( $ properties -> getSubject ( ) > '' ) { $ html .= ' <meta name="subject" content="' . htmlspecialchars ( $ properties -> getSubject ( ) ) . '" />' . PHP_EOL ; } if ( $ properties -> getKeywords ( ) > '' ) { $ html .= ' <meta name="keywords" content="' . htmlspecialchars ( $ properties -> getKeywords ( ) ) . '" />' . PHP_EOL ; } if ( $ properties -> getCategory ( ) > '' ) { $ html .= ' <meta name="category" content="' . htmlspecialchars ( $ properties -> getCategory ( ) ) . '" />' . PHP_EOL ; } if ( $ properties -> getCompany ( ) > '' ) { $ html .= ' <meta name="company" content="' . htmlspecialchars ( $ properties -> getCompany ( ) ) . '" />' . PHP_EOL ; } if ( $ properties -> getManager ( ) > '' ) { $ html .= ' <meta name="manager" content="' . htmlspecialchars ( $ properties -> getManager ( ) ) . '" />' . PHP_EOL ; } if ( $ pIncludeStyles ) { $ html .= $ this -> generateStyles ( true ) ; } $ html .= ' </head>' . PHP_EOL ; $ html .= '' . PHP_EOL ; $ html .= ' <body>' . PHP_EOL ; return $ html ; }
3926	public function encodeValue ( EncodePropertyValueFromWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } if ( is_array ( $ event -> getValue ( ) ) ) { $ values = [ ] ; foreach ( $ event -> getValue ( ) as $ value ) { $ values [ ] = substr ( $ value , 6 ) ; } $ event -> setValue ( $ values ) ; } else { $ event -> setValue ( substr ( $ event -> getValue ( ) , 6 ) ) ; } }
10282	public static function splitRange ( $ pRange ) { if ( empty ( $ pRange ) ) { $ pRange = self :: DEFAULT_RANGE ; } $ exploded = explode ( ',' , $ pRange ) ; $ counter = count ( $ exploded ) ; for ( $ i = 0 ; $ i < $ counter ; ++ $ i ) { $ exploded [ $ i ] = explode ( ':' , $ exploded [ $ i ] ) ; } return $ exploded ; }
7590	public function renderTemplate ( CollectionElement $ collection ) { if ( false != ( $ sElementLayout = $ collection -> getOption ( 'twb-layout' ) ) ) { $ elementOrFieldset = $ collection -> getTemplateElement ( ) ; $ elementOrFieldset -> setOption ( 'twb-layout' , $ sElementLayout ) ; } return parent :: renderTemplate ( $ collection ) ; }
3840	private function parsePanelRow ( $ fields , PanelRowInterface $ panelRow ) { foreach ( $ fields as $ field ) { switch ( $ field ) { case 'sort' : $ this -> parsePanelSort ( $ panelRow ) ; break ; case 'limit' : $ this -> parsePanelLimit ( $ panelRow ) ; break ; case 'filter' : $ this -> parsePanelFilter ( $ panelRow ) ; break ; case 'search' : $ this -> parsePanelSearch ( $ panelRow ) ; break ; case 'submit' : $ this -> parsePanelSubmit ( $ panelRow ) ; break ; default : break ; } } }
6193	protected function loadModels ( $ path ) { $ this -> app -> config [ 'model' ] = array_unique ( array_merge ( $ this -> app -> config [ 'model' ] ?? [ ] , $ path ) ) ; }
4144	public function get ( $ call , array $ getParams = null ) { $ this -> resetCallState ( ) ; $ this -> call = $ call ; $ this -> method = 'GET' ; if ( $ getParams !== null && is_array ( $ getParams ) ) { $ this -> getParams = $ getParams ; } $ response = $ this -> getResponse ( ) ; $ response [ 'body' ] = $ this -> findExceptions ( $ response ) ; $ this -> headers = $ response [ 'headers' ] ; unset ( $ call , $ getParams ) ; return $ this -> serializer -> format ( $ response [ 'body' ] ) ; }
8872	private function buildAttachmentPart ( ) { if ( count ( $ this -> attachments ) > 0 ) { $ attachment_part = '' ; foreach ( $ this -> attachments as $ attachment ) { $ file_str = chunk_split ( base64_encode ( file_get_contents ( $ attachment ) ) ) ; $ attachment_part .= "--MIME_BOUNDRY\nContent-Type: " . $ this -> getMimeType ( $ attachment ) . "; name=" . basename ( $ attachment ) . "\nContent-disposition: attachment\nContent-Transfer-Encoding: base64\n\n{$file_str}\n\n" ; } return $ attachment_part ; } }
2390	private function findLegendForField ( array & $ config , string $ field ) { foreach ( $ config as $ legend => $ group ) { if ( \ in_array ( $ field , $ group [ 'fields' ] , true ) ) { return $ legend ; } } return false ; }
7837	public function register ( ) { $ className = studly_case ( strtolower ( config ( 'message.vendor' , 'smsgatewayme' ) ) ) ; $ classPath = '\Yugo\SMSGateway\Vendors\\' . $ className ; if ( ! class_exists ( $ classPath ) ) { abort ( 500 , sprintf ( 'SMS vendor %s is not available.' , $ className ) ) ; } app ( ) -> bind ( SMS :: class , $ classPath ) ; }
360	function normalizeRequirement ( $ requirement , $ requirementKey = 0 ) { if ( ! is_array ( $ requirement ) ) { $ this -> usageError ( 'Requirement must be an array!' ) ; } if ( ! array_key_exists ( 'condition' , $ requirement ) ) { $ this -> usageError ( "Requirement '{$requirementKey}' has no condition!" ) ; } else { $ evalPrefix = 'eval:' ; if ( is_string ( $ requirement [ 'condition' ] ) && strpos ( $ requirement [ 'condition' ] , $ evalPrefix ) === 0 ) { $ expression = substr ( $ requirement [ 'condition' ] , strlen ( $ evalPrefix ) ) ; $ requirement [ 'condition' ] = $ this -> evaluateExpression ( $ expression ) ; } } if ( ! array_key_exists ( 'name' , $ requirement ) ) { $ requirement [ 'name' ] = is_numeric ( $ requirementKey ) ? 'Requirement #' . $ requirementKey : $ requirementKey ; } if ( ! array_key_exists ( 'mandatory' , $ requirement ) ) { if ( array_key_exists ( 'required' , $ requirement ) ) { $ requirement [ 'mandatory' ] = $ requirement [ 'required' ] ; } else { $ requirement [ 'mandatory' ] = false ; } } if ( ! array_key_exists ( 'by' , $ requirement ) ) { $ requirement [ 'by' ] = 'Unknown' ; } if ( ! array_key_exists ( 'memo' , $ requirement ) ) { $ requirement [ 'memo' ] = '' ; } return $ requirement ; }
12396	public function where ( $ field , $ operator = null , $ value = null , $ logical = '&&' ) { if ( $ field instanceof Closure ) { $ this -> scope -> where .= $ this -> scope -> where == '' ? ' (' : $ logical . ' (' ; call_user_func ( $ field , $ this ) ; $ this -> scope -> where .= ') ' ; } else { $ logical = ( strlen ( $ this -> scope -> where ) <= 1 || substr ( $ this -> scope -> where , - 1 ) == '(' ) ? '' : $ logical ; $ this -> scope -> where .= Parser :: where ( $ field , $ operator , $ value , $ logical ) ; } return $ this ; }
12675	public function getForeignModel ( $ model ) { $ models = $ this -> foreignModels ; if ( isset ( $ models [ $ model ] ) ) { return $ models [ $ model ] ; } return false ; }
2346	public function close ( ) { if ( \ is_resource ( $ this -> resFile ) ) { $ this -> Files -> fclose ( $ this -> resFile ) ; } if ( ! file_exists ( $ this -> strRootDir . '/' . $ this -> strFile ) ) { if ( ( $ strFolder = \ dirname ( $ this -> strFile ) ) == '.' ) { $ strFolder = '' ; } if ( ! is_dir ( $ this -> strRootDir . '/' . $ strFolder ) ) { new Folder ( $ strFolder ) ; } } $ return = $ this -> Files -> rename ( $ this -> strTmp , $ this -> strFile ) ; $ this -> strTmp = null ; if ( Dbafs :: shouldBeSynchronized ( $ this -> strFile ) ) { $ this -> objModel = Dbafs :: addResource ( $ this -> strFile ) ; } return $ return ; }
9170	public function updateCompany ( \ Unite \ Contacts \ Http \ Requests \ UpdateRequest $ request ) { $ this -> service -> saveCompanyProfile ( $ request -> all ( ) ) ; return $ this -> successJsonResponse ( ) ; }
11585	public function setSpoolDirectory ( $ dir ) { if ( ! DirectoryHelper :: ensureExists ( $ dir ) ) { throw new \ Exception ( sprintf ( 'Can not create emails spooling directory "%s"!' , $ dir ) ) ; } $ this -> spool_dir = $ dir ; return $ this ; }
12136	public function edit ( QuestionRequest $ request , Question $ question ) { return $ this -> response -> title ( trans ( 'forum::question.name' ) ) -> view ( 'forum::public.question.newdiscussion' ) -> data ( compact ( 'question' ) ) -> output ( ) ; }
4838	public function new_limit_url ( $ type , $ params ) { $ request = array ( ) ; $ params [ 'merchant_id' ] = $ this -> account_details [ 'merchant_id' ] ; $ opt_params = array ( 'redirect_uri' , 'cancel_uri' , 'state' ) ; foreach ( $ opt_params as $ opt_param ) { if ( isset ( $ params [ $ opt_param ] ) ) { $ request [ $ opt_param ] = $ params [ $ opt_param ] ; unset ( $ params [ $ opt_param ] ) ; } } if ( ! isset ( $ request [ 'redirect_uri' ] ) && isset ( $ this -> redirect_uri ) ) { $ request [ 'redirect_uri' ] = $ this -> redirect_uri ; } $ payment_params = array ( $ type => $ params ) ; $ request = array_merge ( $ request , $ payment_params , $ this -> generate_mandatory_params ( ) ) ; $ request [ 'signature' ] = GoCardless_Utils :: generate_signature ( $ request , $ this -> account_details [ 'app_secret' ] ) ; $ query_string = GoCardless_Utils :: generate_query_string ( $ request ) ; return $ this -> base_url . '/connect/' . $ type . 's/new?' . $ query_string ; }
12503	public static function beginTransaction ( $ connection ) { $ connection -> query = 'BEGIN_TRANSACTION' ; $ connection -> method = 'POST' ; $ connection -> action = '/_query' ; return self :: sendQuery ( $ connection ) ; }
10972	public static function getAuthUsername ( ) { $ result = null ; if ( isset ( $ _SERVER [ 'PHP_AUTH_USER' ] ) ) { $ result = $ _SERVER [ 'PHP_AUTH_USER' ] ; } if ( trim ( $ result ) == '' ) { $ result = null ; } return $ result ; }
9546	public function count ( $ table , $ search , $ where = '' ) { if ( empty ( $ where ) ) { $ where = 'WHERE' ; } else { $ where = ( stripos ( $ where , 'WHERE' ) === false ) ? "WHERE {$where} AND" : "{$where} AND" ; } return $ this -> db -> value ( "SELECT COUNT(*) FROM {$table} AS s {$where} s.{$table} MATCH ?" , $ search ) ; }
2345	public function truncate ( ) { if ( \ is_resource ( $ this -> resFile ) ) { ftruncate ( $ this -> resFile , 0 ) ; rewind ( $ this -> resFile ) ; } return $ this -> write ( '' ) ; }
12027	function addExecuteMethod ( ) { $ body = $ this -> generateCreateFragment ( ) ; $ body .= 'return $this->dispatch($request);' ; $ docBlock = $ this -> generateExecuteDocBlock ( 'Execute the operation, returning the parsed response' ) ; $ methodGenerator = new MethodGenerator ( 'execute' ) ; $ methodGenerator -> setBody ( $ body ) ; $ methodGenerator -> setDocBlock ( $ docBlock ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; }
11330	public function getMultiline ( ) { if ( is_null ( $ this -> _multiline ) ) { $ this -> _multiline = MultilineDetector :: test ( $ this -> fieldSchema ) ; } return $ this -> _multiline ; }
10650	private function getValidator ( $ scope = 'create' ) { $ rules = $ this -> buildValidationRules ( $ scope ) ; $ custom_messages = $ this -> buildMessages ( $ scope ) ; $ validation_values = $ this -> buildValidationValues ( ) ; return Validator :: make ( $ validation_values , $ rules , $ custom_messages ) ; }
11164	protected function getPublishedFormat ( array $ config ) { if ( isset ( $ config [ 'publishedFormat' ] ) ) { if ( ! is_string ( $ config [ 'publishedFormat' ] ) ) { throw new \ DomainException ( 'publishedFormat must reference a string' , self :: ERR_INVALID_PUBLISHEDFORMAT ) ; } return $ config [ 'publishedFormat' ] ; } return 'n/j/y g:i A' ; }
7635	public function getBlockList ( $ containerName = '' , $ blobName = '' , $ snapshotId = null , $ leaseId = null , $ type = 0 ) { Assertion :: notEmpty ( $ containerName , 'Container name is not specified' ) ; self :: assertValidContainerName ( $ containerName ) ; Assertion :: notEmpty ( $ blobName , 'Blob name is not specified.' ) ; if ( $ type < 0 || $ type > 2 ) { throw new BlobException ( 'Invalid type of block list to retrieve.' ) ; } $ blockListType = 'all' ; if ( $ type == 1 ) { $ blockListType = 'committed' ; } if ( $ type == 2 ) { $ blockListType = 'uncommitted' ; } $ headers = array ( ) ; if ( ! is_null ( $ leaseId ) ) { $ headers [ 'x-ms-lease-id' ] = $ leaseId ; } $ query = array ( 'comp' => 'blocklist' , 'blocklisttype' => $ blockListType ) ; if ( ! is_null ( $ snapshotId ) ) { $ query [ 'snapshot' ] = $ snapshotId ; } $ resourceName = self :: createResourceName ( $ containerName , $ blobName ) ; $ response = $ this -> performRequest ( $ resourceName , $ query , 'GET' , $ headers , false , null , self :: RESOURCE_BLOB , self :: PERMISSION_READ ) ; if ( ! $ response -> isSuccessful ( ) ) { throw new BlobException ( $ this -> getErrorMessage ( $ response , 'Resource could not be accessed.' ) ) ; } $ blockList = $ this -> parseResponse ( $ response ) ; $ returnValue = array ( ) ; if ( $ blockList -> CommittedBlocks ) { foreach ( $ blockList -> CommittedBlocks -> Block as $ block ) { $ returnValue [ 'CommittedBlocks' ] [ ] = ( object ) array ( 'Name' => ( string ) $ block -> Name , 'Size' => ( string ) $ block -> Size ) ; } } if ( $ blockList -> UncommittedBlocks ) { foreach ( $ blockList -> UncommittedBlocks -> Block as $ block ) { $ returnValue [ 'UncommittedBlocks' ] [ ] = ( object ) array ( 'Name' => ( string ) $ block -> Name , 'Size' => ( string ) $ block -> Size ) ; } } return $ returnValue ; }
7687	function Misc_CellRef ( $ Col , $ Row ) { $ r = '' ; $ x = $ Col ; do { $ x = $ x - 1 ; $ c = ( $ x % 26 ) ; $ x = ( $ x - $ c ) / 26 ; $ r = chr ( 65 + $ c ) . $ r ; } while ( $ x > 0 ) ; return $ r . $ Row ; }
7910	public function init ( ) { parent :: init ( ) ; Html :: addCssClass ( $ this -> options , 'ui' ) ; if ( ! isset ( $ this -> options [ 'id' ] ) ) { $ this -> options [ 'id' ] = $ this -> getId ( ) ; } $ this -> registerTranslations ( ) ; }
1988	public static function getRootPageFromUrl ( ) { $ host = Environment :: get ( 'host' ) ; $ logger = System :: getContainer ( ) -> get ( 'monolog.logger.contao' ) ; $ accept_language = Environment :: get ( 'httpAcceptLanguage' ) ; if ( ! empty ( $ _GET [ 'language' ] ) && Config :: get ( 'addLanguageToUrl' ) ) { $ strUri = Environment :: get ( 'url' ) . '/' . Input :: get ( 'language' ) . '/' ; $ strError = 'No root page found (host "' . $ host . '", language "' . Input :: get ( 'language' ) . '")' ; } else { if ( Config :: get ( 'addLanguageToUrl' ) && Config :: get ( 'doNotRedirectEmpty' ) ) { $ accept_language = '-' ; } $ strUri = Environment :: get ( 'url' ) . '/' ; $ strError = 'No root page found (host "' . Environment :: get ( 'host' ) . '", languages "' . implode ( ', ' , Environment :: get ( 'httpAcceptLanguage' ) ) . '")' ; } try { $ objRequest = Request :: create ( $ strUri ) ; $ objRequest -> headers -> set ( 'Accept-Language' , $ accept_language ) ; $ arrParameters = System :: getContainer ( ) -> get ( 'contao.routing.nested_matcher' ) -> matchRequest ( $ objRequest ) ; $ objRootPage = $ arrParameters [ 'pageModel' ] ?? null ; if ( ! $ objRootPage instanceof PageModel ) { throw new MissingMandatoryParametersException ( 'Every Contao route must have a "pageModel" parameter' ) ; } } catch ( RoutingExceptionInterface $ exception ) { $ logger -> log ( LogLevel :: ERROR , $ strError , array ( 'contao' => new ContaoContext ( __METHOD__ , 'ERROR' ) ) ) ; throw new NoRootPageFoundException ( 'No root page found' , 0 , $ exception ) ; } if ( Environment :: get ( 'relativeRequest' ) == '' ) { if ( Config :: get ( 'addLanguageToUrl' ) && ! Config :: get ( 'doNotRedirectEmpty' ) ) { $ arrParams = array ( '_locale' => $ objRootPage -> language ) ; $ strUrl = System :: getContainer ( ) -> get ( 'router' ) -> generate ( 'contao_index' , $ arrParams ) ; $ strUrl = substr ( $ strUrl , \ strlen ( Environment :: get ( 'path' ) ) + 1 ) ; static :: redirect ( $ strUrl , 301 ) ; } elseif ( $ objRootPage -> type !== 'root' && ! \ in_array ( $ objRootPage -> alias , array ( 'index' , '/' ) ) ) { static :: redirect ( $ objRootPage -> getAbsoluteUrl ( ) , 302 ) ; } } if ( $ objRootPage -> type != 'root' ) { return PageModel :: findByPk ( $ objRootPage -> rootId ) ; } return $ objRootPage ; }
12065	public function destroy ( ) { session_start ( ) ; $ _SESSION = array ( ) ; if ( ini_get ( "session.use_cookies" ) ) { $ aParams = session_get_cookie_params ( ) ; setcookie ( session_name ( ) , '' , time ( ) - 42000 , $ aParams [ "path" ] , $ aParams [ "domain" ] , $ aParams [ "secure" ] , $ aParams [ "httponly" ] ) ; } session_destroy ( ) ; }
5112	protected function setPart ( $ part , $ sql , $ bind = false ) { $ this -> parts [ $ part ] = $ sql ; if ( is_array ( $ bind ) ) $ this -> bind [ $ part ] = $ bind ; else if ( $ bind === false ) $ this -> bind [ $ part ] = false ; else $ this -> bind [ $ part ] = [ $ bind ] ; return $ this ; }
945	private function setOption ( $ name , $ value ) { if ( ! \ array_key_exists ( $ name , $ this -> options ) ) { throw new InvalidConfigurationException ( sprintf ( 'Unknown option name: "%s".' , $ name ) ) ; } $ this -> options [ $ name ] = $ value ; }
6774	protected function didDeliveryCountryChanged ( SaleInterface $ sale ) { $ saleCs = $ this -> persistenceHelper -> getChangeSet ( $ sale ) ; $ oldCountry = $ newCountry = null ; $ oldSameAddress = isset ( $ saleCs [ 'sameAddress' ] ) ? $ saleCs [ 'sameAddress' ] [ 0 ] : $ sale -> isSameAddress ( ) ; if ( $ oldSameAddress ) { $ oldAddress = isset ( $ saleCs [ 'invoiceAddress' ] ) ? $ saleCs [ 'invoiceAddress' ] [ 0 ] : $ sale -> getInvoiceAddress ( ) ; } else { $ oldAddress = isset ( $ saleCs [ 'deliveryAddress' ] ) ? $ saleCs [ 'deliveryAddress' ] [ 0 ] : $ sale -> getDeliveryAddress ( ) ; } if ( null !== $ oldAddress ) { $ oldAddressCs = $ this -> persistenceHelper -> getChangeSet ( $ oldAddress ) ; $ oldCountry = isset ( $ oldAddressCs [ 'country' ] ) ? $ oldAddressCs [ 'country' ] [ 0 ] : $ oldAddress -> getCountry ( ) ; } $ newAddress = $ sale -> isSameAddress ( ) ? $ sale -> getInvoiceAddress ( ) : $ sale -> getDeliveryAddress ( ) ; if ( null !== $ newAddress ) { $ newCountry = $ newAddress -> getCountry ( ) ; } if ( $ oldCountry !== $ newCountry ) { return true ; } return false ; }
1451	protected function validatorForDelete ( array $ data , array $ rules , array $ messages = [ ] , array $ customAttributes = [ ] ) : ValidatorInterface { return $ this -> createValidator ( $ data , $ rules , $ messages , $ customAttributes ) ; }
5184	private function lookUp ( array $ articleConstant ) : array { $ copyListAttributes = $ this -> listAttributes ; return array_map ( function ( $ singleConst ) use ( $ copyListAttributes ) { $ res = $ copyListAttributes [ $ singleConst ] ; return array_map ( function ( $ str ) use ( $ singleConst ) { return $ singleConst . $ str ; } , $ res ) ; } , $ articleConstant ) ; }
4212	private static function filterConstantsByLevel ( $ constants , $ level ) { foreach ( $ constants as $ constantName => $ value ) { if ( ! self :: inBitmask ( $ value , $ level ) ) { unset ( $ constants [ $ constantName ] ) ; } } unset ( $ constants [ 'E_ALL' ] ) ; return $ constants ; }
7143	private function sortAssignments ( array $ assignments , $ direction = SORT_DESC ) { usort ( $ assignments , function ( StockAssignmentInterface $ a , StockAssignmentInterface $ b ) use ( $ direction ) { $ aDate = $ a -> getSaleItem ( ) -> getSale ( ) -> getCreatedAt ( ) ; $ bDate = $ b -> getSaleItem ( ) -> getSale ( ) -> getCreatedAt ( ) ; if ( $ aDate == $ bDate ) { return 0 ; } if ( $ direction === SORT_ASC ) { return $ aDate < $ bDate ? - 1 : 1 ; } return $ aDate > $ bDate ? - 1 : 1 ; } ) ; return $ assignments ; }
1037	private function completeObjectValue ( ObjectType $ returnType , $ fieldNodes , ResolveInfo $ info , $ path , & $ result ) { $ isTypeOf = $ returnType -> isTypeOf ( $ result , $ this -> exeContext -> contextValue , $ info ) ; if ( $ isTypeOf !== null ) { $ promise = $ this -> getPromise ( $ isTypeOf ) ; if ( $ promise ) { return $ promise -> then ( function ( $ isTypeOfResult ) use ( $ returnType , $ fieldNodes , $ path , & $ result ) { if ( ! $ isTypeOfResult ) { throw $ this -> invalidReturnTypeError ( $ returnType , $ result , $ fieldNodes ) ; } return $ this -> collectAndExecuteSubfields ( $ returnType , $ fieldNodes , $ path , $ result ) ; } ) ; } if ( ! $ isTypeOf ) { throw $ this -> invalidReturnTypeError ( $ returnType , $ result , $ fieldNodes ) ; } } return $ this -> collectAndExecuteSubfields ( $ returnType , $ fieldNodes , $ path , $ result ) ; }
6309	public function drop ( DatabaseObjectInterface $ databaseObject , $ cascade = false ) { $ command = $ this -> getCommand ( $ databaseObject , false ) ; if ( $ cascade ) { $ command -> cascade ( ) ; } return $ command -> execute ( ) ; }
11945	protected function handleEventMessage ( array $ message ) { Log :: debug ( 'OpenPlatform Event Message detail:' , $ message ) ; $ message = new Collection ( $ message ) ; $ infoType = $ message -> get ( 'InfoType' ) ; if ( $ handler = $ this -> getHandler ( $ infoType ) ) { $ handler -> handle ( $ message ) ; } else { Log :: notice ( "No existing handler for '{$infoType}'." ) ; } if ( $ messageHandler = $ this -> getMessageHandler ( ) ) { call_user_func_array ( $ messageHandler , [ $ message ] ) ; } }
10327	function fromXML ( $ xmlElement ) { $ this -> author = $ xmlElement -> author ; $ this -> countContacts = $ xmlElement -> count_contacts ; $ this -> countRules = $ xmlElement -> count_rules ; $ this -> created = $ xmlElement -> created ; $ this -> id = $ xmlElement -> id ; $ this -> name = $ xmlElement -> name ; $ this -> state = $ xmlElement -> state ; if ( $ xmlElement -> rules ) { $ rules = $ xmlElement -> rules ; foreach ( $ rules as $ rule ) { array_push ( $ this -> rules , new Rule ( $ rule -> is_customfield , $ rule -> field , $ rule -> operator , $ rule -> value , $ rule -> type ) ) ; } } }
93	public function filter ( $ relativePath , $ exclude ) { foreach ( $ this -> excludePatterns as $ patternData ) { list ( $ pattern , $ negate , $ stripLeadingSlash ) = $ patternData ; if ( $ stripLeadingSlash ) { $ path = substr ( $ relativePath , 1 ) ; } else { $ path = $ relativePath ; } if ( preg_match ( $ pattern , $ path ) ) { $ exclude = ! $ negate ; } } return $ exclude ; }
1137	public function setDepthWithSubtree ( ) { $ self = $ this ; $ this -> getConnection ( ) -> transaction ( function ( ) use ( $ self ) { $ self -> reload ( ) ; $ self -> descendantsAndSelf ( ) -> select ( $ self -> getKeyName ( ) ) -> lockForUpdate ( ) -> get ( ) ; $ oldDepth = ! is_null ( $ self -> getDepth ( ) ) ? $ self -> getDepth ( ) : 0 ; $ newDepth = $ self -> getLevel ( ) ; $ self -> newNestedSetQuery ( ) -> where ( $ self -> getKeyName ( ) , '=' , $ self -> getKey ( ) ) -> update ( array ( $ self -> getDepthColumnName ( ) => $ newDepth ) ) ; $ self -> setAttribute ( $ self -> getDepthColumnName ( ) , $ newDepth ) ; $ diff = $ newDepth - $ oldDepth ; if ( ! $ self -> isLeaf ( ) && $ diff != 0 ) $ self -> descendants ( ) -> increment ( $ self -> getDepthColumnName ( ) , $ diff ) ; } ) ; return $ this ; }
634	public function createTable ( $ table , $ columns , $ options = null ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> createTable ( $ table , $ columns , $ options ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; }
3924	public function getValueOptions ( GetPropertyOptionsEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ model = $ event -> getModel ( ) ; $ metaModel = $ this -> getMetaModel ( $ event -> getEnvironment ( ) ) ; $ attribute = $ metaModel -> getAttributeById ( $ model -> getProperty ( 'attr_id' ) ) ; if ( $ attribute ) { $ options = $ this -> getOptionsViaDcGeneral ( $ metaModel , $ event -> getEnvironment ( ) , $ attribute ) ; $ mangled = [ ] ; foreach ( ( array ) $ options as $ key => $ option ) { $ mangled [ 'value_' . $ key ] = $ option ; } $ event -> setOptions ( $ mangled ) ; } }
12897	public function to ( string $ path , int $ status = 301 , array $ headers = array ( ) ) { return $ this -> makeRedirect ( $ path , $ status , $ headers ) ; }
9748	public function checkOrderStatus ( $ orderId ) { $ function = 'CheckOrderStatus' ; $ parameters = [ 'entityCode' => $ this -> connector -> getEntityCode ( ) , 'pedidoIDCliente' => $ orderId ] ; $ response = $ this -> connector -> doRequest ( $ function , $ parameters ) ; $ packageStatusResponse = new PackageStatus ( $ response -> CheckOrderStatusResult ) ; $ this -> connector -> log ( 'Integration@checkOrderStatus' , compact ( 'packageStatusResponse' ) ) ; return $ packageStatusResponse ; }
4850	public function prepare ( $ value ) { $ importer = $ this -> getVariably ( ) -> get ( 'importer' ) ; $ table = $ importer -> getCurrentTable ( ) ; if ( ! isset ( $ this -> counter [ $ table ] ) ) { $ db = $ importer -> getDb ( ) ; $ counter = $ db -> fetchOne ( 'SELECT MAX(DISTINCT counter) AS counter FROM ' . $ table ) ; $ this -> counter [ $ table ] = $ counter [ 'counter' ] + 1 ; } return $ this -> counter [ $ table ] ; }
6856	protected static function equinoxMarch ( $ year , $ vsop = true ) { $ month = 3 ; if ( $ vsop ) return static :: accurate ( $ year , static :: meanTerms ( $ month , $ year ) , $ month ) ; else return static :: approx ( $ year , static :: meanTerms ( $ month , $ year ) ) ; }
8993	public function expecting ( ) { $ possibilities = count ( $ this -> samples ) ; $ orderedByOccurance = array_count_values ( $ this -> samples ) ; array_multisort ( $ orderedByOccurance , SORT_DESC ) ; $ probabilities = [ ] ; foreach ( $ orderedByOccurance as $ item => $ value ) { $ probabilities [ $ item ] = $ value / $ possibilities ; } return $ probabilities ; }
5090	public function execute ( $ path ) { if ( ! file_exists ( $ path ) || ! is_readable ( $ path ) ) throw new SquidException ( "The file at [$path] is unreadable or doesn't exists" ) ; $ data = file_get_contents ( $ path ) ; $ result = $ this -> connector -> bulk ( ) -> add ( $ data ) -> executeAll ( ) ; return ( bool ) $ result ; }
1772	public function getAttribute ( $ strKey ) { if ( ! isset ( $ this -> arrAttributes [ $ strKey ] ) ) { return '' ; } $ varValue = $ this -> arrAttributes [ $ strKey ] ; if ( $ strKey == 'autofocus' ) { unset ( $ this -> arrAttributes [ $ strKey ] ) ; } if ( $ strKey == 'disabled' || $ strKey == 'readonly' || $ strKey == 'required' || $ strKey == 'autofocus' || $ strKey == 'multiple' ) { return ' ' . $ strKey ; } elseif ( $ varValue != '' ) { return ' ' . $ strKey . '="' . StringUtil :: specialchars ( $ varValue ) . '"' ; } return '' ; }
8215	protected function getServerStats ( $ pattern = '' ) { $ stats = ( array ) $ this -> getPheanstalk ( ) -> stats ( ) ; if ( ! empty ( $ pattern ) ) { $ stats = array_filter ( $ stats , function ( $ key ) use ( $ pattern ) { return 1 === preg_match ( "/$pattern/i" , $ key ) ; } , ARRAY_FILTER_USE_KEY ) ; } ksort ( $ stats ) ; return $ stats ; }
12721	public function isShared ( $ abstract ) { if ( ! isset ( $ this -> bindings [ $ abstract ] ) ) { throw Internal \ Exception \ ReflectionExceptionFactory :: invalidArgument ( sprintf ( "Parameter 1 of %s must be valid keys in binding container stack." , __METHOD__ ) ) ; } return ( $ this -> bindings [ $ abstract ] [ 'shared' ] ? true : false ) ; }
3565	public function getAttribute ( ) { return function ( $ next , $ value , $ args ) { $ key = $ args -> get ( 'key' ) ; if ( is_null ( $ value ) ) { $ value = $ this -> getMeta ( $ key ) ; } return $ next ( $ value , $ args ) ; } ; }
11719	public function saveAction ( Request $ request , Application $ app ) { $ options = array ( "request" => $ request , "configuration_handler" => $ app [ "red_kite_cms.configuration_handler" ] , 'security' => $ app [ "security" ] , "queue_manager" => $ app [ "red_kite_cms.queue_manager" ] , ) ; $ response = parent :: save ( $ options ) ; if ( $ app [ "red_kite_cms.queue_manager" ] -> hasQueue ( ) && $ response -> getContent ( ) == "Queue saved" ) { $ lastRoute = $ request -> getSession ( ) -> get ( 'last_uri' ) ; return $ app -> redirect ( $ lastRoute ) ; } return $ response ; }
4026	public function modelToLabel ( ModelToLabelEvent $ event ) { if ( ! $ this -> scopeMatcher -> currentScopeIsBackend ( ) ) { return ; } $ model = $ event -> getModel ( ) ; if ( ( $ model -> getProviderName ( ) !== 'tl_metamodel_filtersetting' ) || ! in_array ( $ event -> getModel ( ) -> getProperty ( 'type' ) , $ this -> getTypes ( ) ) ) { return ; } $ environment = $ event -> getEnvironment ( ) ; $ event -> setLabel ( $ this -> getLabelPattern ( $ environment , $ model ) ) -> setArgs ( $ this -> getLabelParameters ( $ environment , $ model ) ) ; }
1805	public function getActiveGroups ( ) { $ arrGroups = array ( ) ; $ objGroup = Contao \ MemberGroupModel :: findAllActive ( ) ; if ( $ objGroup !== null ) { while ( $ objGroup -> next ( ) ) { $ arrGroups [ $ objGroup -> id ] = $ objGroup -> name ; } } return $ arrGroups ; }
4385	protected function dumpObject ( $ abs ) { $ isNested = $ this -> valueDepth > 0 ; $ this -> valueDepth ++ ; if ( $ abs [ 'isRecursion' ] ) { $ str = '(object) ' . $ abs [ 'className' ] . ' *RECURSION*' ; } elseif ( $ abs [ 'isExcluded' ] ) { $ str = '(object) ' . $ abs [ 'className' ] . ' (not inspected)' ; } else { $ str = '(object) ' . $ abs [ 'className' ] . "\n" ; $ str .= $ this -> dumpProperties ( $ abs ) ; if ( $ abs [ 'collectMethods' ] && $ this -> debug -> output -> getCfg ( 'outputMethods' ) ) { $ str .= $ this -> dumpMethods ( $ abs [ 'methods' ] ) ; } } $ str = \ trim ( $ str ) ; if ( $ isNested ) { $ str = \ str_replace ( "\n" , "\n " , $ str ) ; } return $ str ; }
334	protected function getTableSequenceName ( $ tableName ) { $ sequenceNameSql = <<<'SQL'SELECT UD.REFERENCED_NAME AS SEQUENCE_NAMEFROM USER_DEPENDENCIES UD JOIN USER_TRIGGERS UT ON (UT.TRIGGER_NAME = UD.NAME)WHERE UT.TABLE_NAME = :tableName AND UD.TYPE = 'TRIGGER' AND UD.REFERENCED_TYPE = 'SEQUENCE'SQL ; $ sequenceName = $ this -> db -> createCommand ( $ sequenceNameSql , [ ':tableName' => $ tableName ] ) -> queryScalar ( ) ; return $ sequenceName === false ? null : $ sequenceName ; }
4628	protected function prepareRequestUrl ( ) { $ protocol = $ this -> node -> useTls ( ) ? 'https' : 'http' ; $ this -> requestURL = sprintf ( '%s://%s%s?%s' , $ protocol , $ this -> node -> getUri ( ) , $ this -> path , $ this -> query ) ; $ this -> options [ CURLOPT_URL ] = $ this -> requestURL ; return $ this ; }
429	public function getUniqueId ( ) { return $ this -> module ? ltrim ( $ this -> module -> getUniqueId ( ) . '/' . $ this -> id , '/' ) : $ this -> id ; }
11853	protected function redirect ( string $ uri , bool $ isPermanent = false ) : void { $ nCode = $ isPermanent ? 301 : 302 ; Headers :: getInstance ( ) -> addByHttpCode ( $ nCode ) -> add ( 'Location: ' . $ uri ) -> run ( ) ; exit ; }
5670	protected function describeGenericDifference ( $ first , $ second ) { return sprintf ( 'as [%s] does not match [%s]' , $ this -> describeValue ( $ first ) , $ this -> describeValue ( $ second ) ) ; }
280	private function confirmLoad ( $ fixtures , $ except ) { $ this -> stdout ( "Fixtures namespace is: \n" , Console :: FG_YELLOW ) ; $ this -> stdout ( "\t" . $ this -> namespace . "\n\n" , Console :: FG_GREEN ) ; if ( count ( $ this -> globalFixtures ) ) { $ this -> stdout ( "Global fixtures will be used:\n\n" , Console :: FG_YELLOW ) ; $ this -> outputList ( $ this -> globalFixtures ) ; } if ( count ( $ fixtures ) ) { $ this -> stdout ( "\nFixtures below will be loaded:\n\n" , Console :: FG_YELLOW ) ; $ this -> outputList ( $ fixtures ) ; } if ( count ( $ except ) ) { $ this -> stdout ( "\nFixtures that will NOT be loaded: \n\n" , Console :: FG_YELLOW ) ; $ this -> outputList ( $ except ) ; } $ this -> stdout ( "\nBe aware that:\n" , Console :: BOLD ) ; $ this -> stdout ( "Applying leads to purging of certain data in the database!\n" , Console :: FG_RED ) ; return $ this -> confirm ( "\nLoad above fixtures?" ) ; }
5671	protected function describeStringDifference ( $ first , $ second , $ identical ) { if ( is_object ( $ second ) || is_array ( $ second ) ) { return $ this -> describeGenericDifference ( $ first , $ second ) ; } $ position = $ this -> stringDiffersAt ( $ first , $ second ) ; return sprintf ( 'at character %s with [%s] and [%s]' , $ position , $ this -> clipString ( $ first , 200 , $ position ) , $ this -> clipString ( $ second , 200 , $ position ) ) ; }
1121	public function ancestorsAndSelf ( ) { return $ this -> newNestedSetQuery ( ) -> where ( $ this -> getLeftColumnName ( ) , '<=' , $ this -> getLeft ( ) ) -> where ( $ this -> getRightColumnName ( ) , '>=' , $ this -> getRight ( ) ) ; }
9063	private function getKeys ( ) : array { $ result = [ ] ; $ rows = $ this -> connection -> query ( " SELECT [INDEX_NAME], [COLUMN_NAME], [INDEX_TYPE], [NON_UNIQUE], [SEQ_IN_INDEX] FROM [information_schema.STATISTICS] WHERE [TABLE_SCHEMA] = %s AND [TABLE_NAME] = %s AND [INDEX_NAME] != %s" , $ this -> database , $ this -> name , 'PRIMARY' ) ; foreach ( $ rows as $ row ) { $ name = $ row -> INDEX_NAME ; if ( isset ( $ result [ $ name ] ) ) { $ obj = $ result [ $ name ] ; } else { $ obj = new Key ; } $ obj -> name = $ name ; $ obj -> addColumn ( $ row -> SEQ_IN_INDEX , $ row -> COLUMN_NAME ) ; $ obj -> type = $ row -> INDEX_TYPE ; $ obj -> unique = ! $ row -> NON_UNIQUE ; $ result [ $ name ] = $ obj ; } return $ result ; }
7778	protected function extractInput ( array $ data ) { $ input = [ ] ; foreach ( $ data as $ field => $ fieldData ) { $ input [ $ field ] = $ fieldData [ 0 ] ; } return $ input ; }
8772	protected function markAsRegistered ( ServiceProvider $ provider ) { $ this -> serviceProviders [ ] = $ provider ; $ this -> loadedProviders [ get_class ( $ provider ) ] = true ; }
12572	public function previewImage ( $ message , $ to , $ by = self :: PREVIEW_BY_OPENID ) { return $ this -> preview ( self :: MSG_TYPE_IMAGE , $ message , $ to , $ by ) ; }
6876	private function findRevenues ( $ type , \ DateTime $ from , \ DateTime $ to = null , $ detailed = false ) { if ( $ type === OrderStat :: TYPE_DAY ) { if ( null === $ to ) { $ from = ( clone $ from ) -> modify ( 'first day of this month' ) ; $ to = ( clone $ from ) -> modify ( 'last day of this month' ) ; } $ interval = new \ DateInterval ( 'P1D' ) ; $ format = 'Y-m-d' ; } elseif ( $ type === OrderStat :: TYPE_MONTH ) { if ( null === $ to ) { $ from = ( clone $ from ) -> modify ( 'first day of january ' . $ from -> format ( 'Y' ) ) ; $ to = ( clone $ from ) -> modify ( 'last day of december ' . $ from -> format ( 'Y' ) ) ; } $ interval = new \ DateInterval ( 'P1M' ) ; $ format = 'Y-m' ; } else { throw new InvalidArgumentException ( "Unexpected order stat type." ) ; } $ result = $ this -> getRevenueQuery ( ) -> setParameters ( [ 'type' => $ type , 'from' => $ from -> format ( $ format ) , 'to' => $ to -> format ( $ format ) , ] ) -> getScalarResult ( ) ; $ data = $ this -> buildRevenueData ( $ result , $ detailed ) ; $ period = new \ DatePeriod ( $ from , $ interval , $ to ) ; $ defaults = $ detailed ? [ ] : 0 ; if ( $ detailed ) { foreach ( SaleSources :: getSources ( ) as $ source ) { $ defaults [ $ source ] = 0 ; } } foreach ( $ period as $ d ) { $ index = $ d -> format ( $ format ) ; if ( ! isset ( $ data [ $ index ] ) ) { $ data [ $ index ] = $ defaults ; } ; } ksort ( $ data ) ; return $ data ; }
9987	private function mapBorderStyle ( $ borderStyle ) { switch ( $ borderStyle ) { case Border :: BORDER_NONE : return 'none' ; case Border :: BORDER_DASHDOT : return '1px dashed' ; case Border :: BORDER_DASHDOTDOT : return '1px dotted' ; case Border :: BORDER_DASHED : return '1px dashed' ; case Border :: BORDER_DOTTED : return '1px dotted' ; case Border :: BORDER_DOUBLE : return '3px double' ; case Border :: BORDER_HAIR : return '1px solid' ; case Border :: BORDER_MEDIUM : return '2px solid' ; case Border :: BORDER_MEDIUMDASHDOT : return '2px dashed' ; case Border :: BORDER_MEDIUMDASHDOTDOT : return '2px dotted' ; case Border :: BORDER_MEDIUMDASHED : return '2px dashed' ; case Border :: BORDER_SLANTDASHDOT : return '2px dashed' ; case Border :: BORDER_THICK : return '3px solid' ; case Border :: BORDER_THIN : return '1px solid' ; default : return '1px solid' ; } }
985	public function getCharge ( ) { if ( ! $ this -> chargeId ) { throw new Exception ( 'Can not get charge information without charge ID.' ) ; } return $ this -> api -> rest ( 'GET' , "/admin/{$this->plan->typeAsString(true)}/{$this->chargeId}.json" ) -> body -> { $ this -> plan -> typeAsString ( ) } ; }
9034	protected function init ( $ key ) { if ( ! isset ( $ this -> files [ $ key ] ) ) { $ this -> files [ $ key ] = fopen ( $ this -> dir . $ key . '.lockfile' , 'w+' ) ; $ this -> owns [ $ key ] = false ; } }
3632	public function config ( Request $ request ) { if ( $ key = $ request -> query ( 'key' ) ) { return \ config ( $ key ) ; } return \ bean ( 'config' ) -> toArray ( ) ; }
8211	protected function buildCommandSignature ( ) { $ this -> signature = $ this -> namespace . ':' . $ this -> commandName . ' ' . $ this -> commandArguments . $ this -> commandOptions . $ this -> commonOptions ; }
8371	protected function shutdown ( ) { $ this -> shutdown = true ; $ this -> args [ 'messages' ] = array_filter ( $ this -> messages , function ( $ message ) { if ( ! isset ( $ message [ 'sent' ] ) || $ message [ 'sent' ] === false ) { return $ message ; } } ) ; $ redis = new Redis ; $ client = new Client ( $ redis ) ; $ client -> push ( static :: class , $ this -> args , 1 , 100 ) ; return true ; }
11791	public function setFrom ( $ mail = '' , $ name = null , $ reply = true ) { $ mail = trim ( $ mail ) ; if ( strlen ( $ mail ) && Helper :: isEmail ( $ mail ) ) { $ this -> from = ! empty ( $ name ) ? array ( $ name => $ mail ) : array ( $ mail ) ; $ this -> getMailer ( ) -> setRegistry ( 'Return-Path' , '<' . $ mail . '>' , 'headers' ) ; $ this -> getMailer ( ) -> setRegistry ( 'X-Sender' , $ mail , 'headers' ) ; if ( $ reply ) { $ this -> setReplyTo ( $ mail , $ name ) ; } } return $ this ; }
10766	private function implodeContent ( ) { ksort ( $ this -> content ) ; $ output = '' ; foreach ( $ this -> content as $ key => $ value ) { $ output .= $ key . self :: KV_DELIMITER . $ value . self :: DELIMITER ; } return rtrim ( $ output , self :: DELIMITER ) ; }
11613	public function create ( $ account , $ nickname ) { $ params = [ 'kf_account' => $ account , 'nickname' => $ nickname , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_CREATE , $ params ] ) ; }
1236	public function attachment ( $ data = null , $ mimeType = 'application/octet-stream' ) { if ( $ data !== null ) { if ( is_array ( $ data ) ) { $ this -> attachment [ 'data' ] = array_key_exists ( 'data' , $ data ) ? $ data [ 'data' ] : null ; $ this -> attachment [ 'mimeType' ] = array_key_exists ( 'mimeType' , $ data ) ? $ data [ 'mimeType' ] : 'application/octet-stream' ; } else { $ this -> attachment [ 'data' ] = $ data ; $ this -> attachment [ 'mimeType' ] = $ mimeType ; } } return $ this -> attachment ; }
6503	public function produce ( Message $ message ) { $ type = $ message -> getType ( ) ; $ body = array ( 'ticket' => $ message -> getTicket ( ) ) ; try { $ this -> logger -> debug ( sprintf ( 'Publish message for job %s to sonata backend' , $ message -> getTicket ( ) ) , [ 'type' => $ type , 'body' => $ body ] ) ; $ queue = $ this -> registry -> get ( $ message -> getType ( ) ) -> getQueue ( ) ; $ this -> backendProvider -> getBackend ( $ queue ) -> createAndPublish ( $ type , $ body ) ; } catch ( \ Exception $ e ) { $ this -> logger -> error ( sprintf ( 'Failed to publish message (Error: %s)' , $ e -> getMessage ( ) ) , [ 'exception' => $ e ] ) ; if ( ! $ e instanceof \ RuntimeException ) { $ e = new \ RuntimeException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } throw $ e ; } }
3278	public function getAll ( ) : array { $ data = [ ] ; $ file = $ this -> getDatabase ( ) -> readFromFile ( ) ; foreach ( $ file as $ line ) { $ data [ $ line -> getKey ( ) ] = $ this -> decodeData ( $ line -> getData ( ) ) ; } return $ data ; }
1665	public function getListForSelect ( $ display = 'name' ) { foreach ( $ this -> getList ( $ display ) as $ key => $ value ) { $ countries [ $ key ] = $ value [ $ display ] ; } return $ countries ; }
1933	protected function getLocaleString ( ) { $ container = System :: getContainer ( ) ; return 'var Contao={' . 'theme:"' . Backend :: getTheme ( ) . '",' . 'lang:{' . 'close:"' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'close' ] . '",' . 'collapse:"' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'collapseNode' ] . '",' . 'expand:"' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'expandNode' ] . '",' . 'loading:"' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'loadingData' ] . '",' . 'apply:"' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'apply' ] . '"' . '},' . 'script_url:"' . $ container -> get ( 'contao.assets.assets_context' ) -> getStaticUrl ( ) . '",' . 'path:"' . Environment :: get ( 'path' ) . '",' . 'request_token:"' . REQUEST_TOKEN . '",' . 'referer_id:"' . $ container -> get ( 'request_stack' ) -> getCurrentRequest ( ) -> attributes -> get ( '_contao_referer_id' ) . '"' . '};' ; }
11265	public function model ( $ pathname ) { $ fullPath = $ this -> config [ 'pathToModels' ] . $ this -> getPath ( $ pathname ) . $ this -> config [ 'modelsPrefix' ] . $ this -> getName ( $ pathname ) . $ this -> config [ 'modelsPostfix' ] . '.php' ; include_once ( $ fullPath ) ; }
4587	public function setStaffUuid ( ? string $ staffUuid ) { $ this -> staffUuid = $ staffUuid ; $ this -> _staffUuid = true ; return $ this ; }
11956	function addQueue ( $ channel , $ queue , $ weight = 1 ) { $ orig = $ channel ; $ channel = $ this -> _normalizeQueueName ( $ channel ) ; if ( ! $ queue instanceof iQueueDriver ) throw new \ Exception ( sprintf ( 'Queue must be instance of iQueueDriver; given: (%s).' , \ Poirot \ Std \ flatten ( $ queue ) ) ) ; if ( isset ( $ this -> channels_queue [ $ channel ] ) ) throw new \ RuntimeException ( sprintf ( 'Channel (%s) is currently filled with (%s) and is not empty.' , $ orig , get_class ( $ this -> channels_queue [ $ channel ] ) ) ) ; $ this -> channels_queue [ $ channel ] = $ queue ; $ this -> channels_weight [ $ channel ] = $ weight ; return $ this ; }
8427	public static function get ( string $ class ) { if ( isset ( self :: $ controllers [ $ class ] ) === false ) { self :: $ controllers [ $ class ] = new $ class ( ) ; } return self :: $ controllers [ $ class ] ; }
1100	protected function guardAgainstImpossibleMove ( ) { if ( ! $ this -> node -> exists ) throw new MoveNotPossibleException ( 'A new node cannot be moved.' ) ; if ( array_search ( $ this -> position , array ( 'child' , 'left' , 'right' , 'root' ) ) === FALSE ) throw new MoveNotPossibleException ( "Position should be one of ['child', 'left', 'right'] but is {$this->position}." ) ; if ( ! $ this -> promotingToRoot ( ) ) { if ( is_null ( $ this -> target ) ) { if ( $ this -> position === 'left' || $ this -> position === 'right' ) throw new MoveNotPossibleException ( "Could not resolve target node. This node cannot move any further to the {$this->position}." ) ; else throw new MoveNotPossibleException ( 'Could not resolve target node.' ) ; } if ( $ this -> node -> equals ( $ this -> target ) ) throw new MoveNotPossibleException ( 'A node cannot be moved to itself.' ) ; if ( $ this -> target -> insideSubtree ( $ this -> node ) ) throw new MoveNotPossibleException ( 'A node cannot be moved to a descendant of itself (inside moved tree).' ) ; if ( ! $ this -> node -> inSameScope ( $ this -> target ) ) throw new MoveNotPossibleException ( 'A node cannot be moved to a different scope.' ) ; } }
8946	public function changePreference ( $ key , $ preference ) { $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = 'user/preferences/' . $ key ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'PUT' , $ parameters , $ preference ) ; return $ response -> body ; }
3075	public function process ( ) { $ this -> validate ( ) ; try { $ serviceContext = $ this -> getServiceContext ( ) ; $ this -> saveToolStates ( ) ; if ( $ this -> getRequestParameter ( 'offline' ) === true ) { $ this -> setOffline ( ) ; } $ result = $ this -> getRunnerService ( ) -> pause ( $ serviceContext ) ; $ response = [ 'success' => $ result ] ; } catch ( Exception $ e ) { $ response = $ this -> getErrorResponse ( $ e ) ; } return $ response ; }
1635	protected function setupEvents ( Dispatcher $ events , array $ config ) { if ( isset ( $ config [ 'auto_capture_sessions' ] ) && $ config [ 'auto_capture_sessions' ] ) { $ events -> listen ( RouteMatched :: class , function ( $ event ) { $ this -> app -> bugsnag -> getSessionTracker ( ) -> startSession ( ) ; } ) ; } if ( isset ( $ config [ 'query' ] ) && ! $ config [ 'query' ] ) { return ; } $ show = isset ( $ config [ 'bindings' ] ) && $ config [ 'bindings' ] ; if ( class_exists ( QueryExecuted :: class ) ) { $ events -> listen ( QueryExecuted :: class , function ( QueryExecuted $ query ) use ( $ show ) { $ this -> app -> bugsnag -> leaveBreadcrumb ( 'Query executed' , Breadcrumb :: PROCESS_TYPE , $ this -> formatQuery ( $ query -> sql , $ show ? $ query -> bindings : [ ] , $ query -> time , $ query -> connectionName ) ) ; } ) ; } else { $ events -> listen ( 'illuminate.query' , function ( $ sql , array $ bindings , $ time , $ connection ) use ( $ show ) { $ this -> app -> bugsnag -> leaveBreadcrumb ( 'Query executed' , Breadcrumb :: PROCESS_TYPE , $ this -> formatQuery ( $ sql , $ show ? $ bindings : [ ] , $ time , $ connection ) ) ; } ) ; } }
8792	public function tag ( $ tag , $ content , array $ attributes = [ ] ) { $ content = is_array ( $ content ) ? implode ( PHP_EOL , $ content ) : $ content ; return $ this -> toHtmlString ( '<' . $ tag . $ this -> attributes ( $ attributes ) . '>' . PHP_EOL . $ this -> toHtmlString ( $ content ) . PHP_EOL . '</' . $ tag . '>' . PHP_EOL ) ; }
5573	public function setField ( $ label , $ value , $ position = false ) { return $ this -> page -> setField ( new SelectByLabelOrName ( $ label ) , $ value , $ position ) ; }
11917	public function newInstanceQuery ( array $ data = [ ] , array $ selectable = [ '*' ] ) { $ tm = new TextGenerator ( ) ; $ r = $ this -> newInstanceRepository ( ) ; $ query = $ r -> newQuery ( ) ; if ( ! empty ( $ this -> filter ) ) { $ filter = new Filter ( $ r -> getTableName ( ) , $ selectable ) ; $ filter -> build ( $ query , $ tm -> generateAndRender ( $ this -> filter , $ data ) ) ; } return $ query ; }
11566	public function register ( string ... $ mods ) : void { $ this -> kms = array_unique ( array_merge ( $ this -> kms , $ mods ) ) ; }
12883	public function getUnmappedLocalKeys ( ) { $ u = array_diff ( array_keys ( $ this -> localModel -> getMetaData ( ) -> columns ) , array_keys ( $ this -> _map ) ) ; unset ( $ u [ $ this -> localPrimaryKeyName ] ) ; return $ u ; }
12455	public function hasToolbar ( ) { $ fileSkeleton = '/Resources/views/Editor/Toolbar/_toolbar_%s_buttons.html.twig' ; return file_exists ( $ this -> pluginDir . sprintf ( $ fileSkeleton , 'left' ) ) || file_exists ( $ this -> pluginDir . sprintf ( $ fileSkeleton , 'right' ) ) ; }
8107	protected function getTemplateVariables ( $ recipient , $ config , $ pages ) { return [ 'Subject' => $ config -> ReviewSubject , 'PagesCount' => $ pages -> count ( ) , 'FromEmail' => $ config -> ReviewFrom , 'ToFirstName' => $ recipient -> FirstName , 'ToSurname' => $ recipient -> Surname , 'ToEmail' => $ recipient -> Email , ] ; }
4135	public static function decryptWithAppendedTag ( $ K , $ IV , $ Ciphertext = null , $ A = null , $ tag_length = 128 ) { $ tag_length_in_bits = $ tag_length / 8 ; $ C = mb_substr ( $ Ciphertext , 0 , - $ tag_length_in_bits , '8bit' ) ; $ T = mb_substr ( $ Ciphertext , - $ tag_length_in_bits , null , '8bit' ) ; return self :: decrypt ( $ K , $ IV , $ C , $ A , $ T ) ; }
6849	public static function months ( $ format = null ) { $ months = array ( ) ; if ( $ format === static :: MONTHS_LONG || $ format === static :: MONTHS_SHORT ) { for ( $ i = 1 ; $ i <= 12 ; ++ $ i ) { $ months [ $ i ] = strftime ( $ format , mktime ( 0 , 0 , 0 , $ i , 1 ) ) ; } } else { $ months = static :: hours ( ) ; } return $ months ; }
7125	static public function equals ( AddressInterface $ source , AddressInterface $ target ) { if ( ! ( $ source -> getCompany ( ) === $ target -> getCompany ( ) && $ source -> getGender ( ) === $ target -> getGender ( ) && $ source -> getFirstName ( ) === $ target -> getFirstName ( ) && $ source -> getLastName ( ) === $ target -> getLastName ( ) && $ source -> getStreet ( ) === $ target -> getStreet ( ) && $ source -> getComplement ( ) === $ target -> getComplement ( ) && $ source -> getSupplement ( ) === $ target -> getSupplement ( ) && $ source -> getExtra ( ) === $ target -> getExtra ( ) && $ source -> getCity ( ) === $ target -> getCity ( ) && $ source -> getPostalCode ( ) === $ target -> getPostalCode ( ) && $ source -> getDigicode1 ( ) === $ target -> getDigicode1 ( ) && $ source -> getDigicode2 ( ) === $ target -> getDigicode2 ( ) && $ source -> getIntercom ( ) === $ target -> getIntercom ( ) ) ) { return false ; } $ sourceCountryId = $ source -> getCountry ( ) ? $ source -> getCountry ( ) -> getId ( ) : null ; $ targetCountryId = $ target -> getCountry ( ) ? $ target -> getCountry ( ) -> getId ( ) : null ; if ( $ sourceCountryId != $ targetCountryId ) { return false ; } $ sourceStateId = $ source -> getState ( ) ? $ source -> getState ( ) -> getId ( ) : null ; $ targetStateId = $ target -> getState ( ) ? $ target -> getState ( ) -> getId ( ) : null ; if ( $ sourceStateId != $ targetStateId ) { return false ; } $ sourcePhone = ( string ) $ source -> getPhone ( ) ; $ targetPhone = ( string ) $ target -> getPhone ( ) ; if ( $ sourcePhone !== $ targetPhone ) { return false ; } $ sourceMobile = ( string ) $ source -> getMobile ( ) ; $ targetMobile = ( string ) $ target -> getMobile ( ) ; if ( $ sourceMobile !== $ targetMobile ) { return false ; } return true ; }
2401	public function route ( $ strName , $ arrParams = array ( ) ) { $ strUrl = System :: getContainer ( ) -> get ( 'router' ) -> generate ( $ strName , $ arrParams ) ; $ strUrl = substr ( $ strUrl , \ strlen ( Environment :: get ( 'path' ) ) + 1 ) ; return ampersand ( $ strUrl ) ; }
3180	public function useClientContainer ( ) { if ( $ this -> hasOption ( self :: OPTION_CLIENT_TESTRUNNER ) ) { return $ this -> getOption ( self :: OPTION_CLIENT_TESTRUNNER ) ; } else { $ itemModel = $ this -> getServiceLocator ( ) -> get ( ItemModel :: SERVICE_ID ) ; return $ itemModel -> getCompilerClass ( ) == QtiJsonItemCompiler :: class ; } }
6761	public function find ( $ criteria ) { if ( ! $ criteria ) { error_log ( "collection error: no criteria specified" ) ; return null ; } else if ( is_callable ( $ criteria ) ) { foreach ( $ this -> models as $ model ) if ( $ criteria ( $ model ) ) return $ model ; } else if ( is_a ( $ criteria , "SnooPHP\Model\Model" ) ) { foreach ( $ this -> models as $ i => $ model ) if ( $ model == $ criteria ) return $ i ; } return null ; }
11487	protected function callResolvingCallbacks ( $ key , $ object ) { foreach ( $ this -> resolvingAnyCallbacks as $ callback ) { call_user_func ( $ callback , $ object , $ this ) ; } if ( isset ( $ this -> resolvingCallbacks [ $ key ] ) ) { foreach ( $ this -> resolvingCallbacks [ $ key ] as $ callback ) { call_user_func ( $ callback , $ object , $ this ) ; } } }
3596	protected function createTables ( ) { $ tablesCreated = false ; $ tableSchema = Craft :: $ app -> db -> schema -> getTableSchema ( '{{%dolphiq_sitemap_entries}}' ) ; if ( $ tableSchema === null ) { $ tablesCreated = true ; $ this -> createTable ( '{{%dolphiq_sitemap_entries}}' , [ 'id' => $ this -> primaryKey ( ) , 'dateCreated' => $ this -> dateTime ( ) -> notNull ( ) , 'dateUpdated' => $ this -> dateTime ( ) -> notNull ( ) , 'uid' => $ this -> uid ( ) , 'linkId' => $ this -> integer ( ) -> notNull ( ) , 'type' => $ this -> string ( 30 ) -> notNull ( ) -> defaultValue ( '' ) , 'priority' => $ this -> double ( 2 ) -> notNull ( ) -> defaultValue ( 0.5 ) , 'changefreq' => $ this -> string ( 30 ) -> notNull ( ) -> defaultValue ( '' ) , ] ) ; } return $ tablesCreated ; }
3233	static function useExternalPaths ( ) { if ( ! self :: $ useExternalFile and self :: $ paths !== null ) { throw new \ Exception ( "You called \"useExternalFile\" too late. The SDK already used the root " . "certificate file (probably to make an API call)." ) ; } self :: $ useExternalFile = true ; }
8266	public function lock ( $ lockType ) { if ( ! $ this -> isOpened ( ) ) { return false ; } if ( $ this -> options [ "blocking" ] ) { return flock ( $ this -> handle , $ lockType ) ; } else { $ tries = 0 ; do { if ( flock ( $ this -> handle , $ lockType | LOCK_NB ) ) { return true ; } else { ++ $ tries ; usleep ( self :: LOCK_RETRY_WAIT ) ; } } while ( $ tries < self :: LOCK_MAX_TRIES ) ; return false ; } }
1392	public function isJsonApi ( $ request , Exception $ e ) { if ( Helpers :: wantsJsonApi ( $ request ) ) { return true ; } $ route = app ( JsonApiService :: class ) -> currentRoute ( ) ; return $ route -> hasCodec ( ) && $ route -> getCodec ( ) -> willEncode ( ) ; }
8658	private function convertRequestReport ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'RequestReport' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetMarketplaceIdList ( ) ) { $ marketplaceIdList = $ request -> getMarketplaceIdList ( ) ; foreach ( $ marketplaceIdList -> getId ( ) as $ idIndex => $ id ) { $ parameters [ 'MarketplaceIdList.Id.' . ( $ idIndex + 1 ) ] = $ id ; } } if ( $ request -> isSetReportType ( ) ) { $ parameters [ 'ReportType' ] = $ request -> getReportType ( ) ; } if ( $ request -> isSetStartDate ( ) ) { $ parameters [ 'StartDate' ] = $ this -> getFormattedTimestamp ( $ request -> getStartDate ( ) ) ; } if ( $ request -> isSetEndDate ( ) ) { $ parameters [ 'EndDate' ] = $ this -> getFormattedTimestamp ( $ request -> getEndDate ( ) ) ; } if ( $ request -> isSetReportOptions ( ) ) { $ parameters [ 'ReportOptions' ] = $ request -> getReportOptions ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
214	public function getParams ( ) { if ( $ this -> _params === null ) { if ( isset ( $ _SERVER [ 'argv' ] ) ) { $ this -> _params = $ _SERVER [ 'argv' ] ; array_shift ( $ this -> _params ) ; } else { $ this -> _params = [ ] ; } } return $ this -> _params ; }
415	public function getAcceptableContentTypes ( ) { if ( $ this -> _contentTypes === null ) { if ( $ this -> headers -> get ( 'Accept' ) !== null ) { $ this -> _contentTypes = $ this -> parseAcceptHeader ( $ this -> headers -> get ( 'Accept' ) ) ; } else { $ this -> _contentTypes = [ ] ; } } return $ this -> _contentTypes ; }
10481	public function getDocuments ( ) { return new SyncStorageImportIterator ( [ 'sync_storage' => $ this -> getSyncStorage ( ) , 'shop_id' => $ this -> getShopId ( ) , 'document_type' => $ this -> getDocumentType ( ) , ] , $ this -> getElasticsearchManager ( ) -> getRepository ( $ this -> getDocumentClass ( ) ) , $ this -> getDoctrineManager ( ) , $ this -> getEntityClass ( ) ) ; }
11016	public function addDefaultListeners ( ) { $ this -> dispatcher -> addListener ( Events :: EVENT_BEFORE_CONTROLLER_RUN , $ this ) ; $ this -> dispatcher -> addListener ( Events :: EVENT_AFTER_CONTROLLER_RUN , $ this ) ; }
10321	function getUnsubscribersCount ( $ fromDate = null , $ toDate = null , $ mailingIds = null , $ contactIds = null , $ contactEmails = null , $ contactExternalIds = null , $ source = null ) { $ params = $ this -> createCountQueryParameters ( $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , $ mailingIds , $ source ) ; return $ this -> get ( 'reports/unsubscriptions/count' , $ params ) ; }
4097	public function field ( $ field , $ config = array ( ) ) { if ( is_string ( $ config ) ) $ config = array ( 'type' => $ config ) ; $ this -> properties [ $ field ] = $ config ; return $ this ; }
11912	public function setIndustry ( $ industryOne , $ industryTwo ) { $ params = [ 'industry_id1' => $ industryOne , 'industry_id2' => $ industryTwo , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_SET_INDUSTRY , $ params ] ) ; }
12695	static function getVendorDir ( $ vendorPrefix = 'vendor' ) { if ( is_dir ( __DIR__ . '/../../../composer' ) && is_file ( __DIR__ . '/../../../autoload.php' ) ) { return realpath ( __DIR__ . '/../../..' ) ; } if ( is_dir ( __DIR__ . "/../$vendorPrefix/composer" ) && is_file ( __DIR__ . "/../$vendorPrefix/autoload.php" ) ) { return realpath ( __DIR__ . "/../$vendorPrefix" ) ; } return false ; }
12610	public function getParents ( ) { $ parents = [ ] ; foreach ( $ this -> _parents as $ key => $ parent ) { if ( ! $ parent -> active ) { continue ; } $ parents [ $ key ] = $ parent ; } return $ parents ; }
176	public static function removeValue ( & $ array , $ value ) { $ result = [ ] ; if ( is_array ( $ array ) ) { foreach ( $ array as $ key => $ val ) { if ( $ val === $ value ) { $ result [ $ key ] = $ val ; unset ( $ array [ $ key ] ) ; } } } return $ result ; }
8039	public function buildEventData ( array $ data ) { $ start = strtotime ( $ data [ 'start' ] [ 'date' ] . ' ' . $ data [ 'start' ] [ 'time' ] ) ; $ start = date ( 'Y-m-d H:i:s' , $ start ) ; $ end = null ; if ( array_key_exists ( 'end' , $ data ) ) { $ end = strtotime ( $ data [ 'end' ] [ 'date' ] . ' ' . $ data [ 'end' ] [ 'time' ] ) ; $ end = date ( 'Y-m-d H:i:s' , $ end ) ; if ( strtotime ( $ end ) < strtotime ( $ start ) ) { throw new DateDifferenceException ( 'Start date bigger then end date!' ) ; } } $ event = [ 'title' => $ data [ 'title' ] , 'description' => $ data [ 'description' ] , 'start' => $ start , 'end' => $ end , 'all_day' => array_key_exists ( 'all_day' , $ data ) , 'border_color' => $ data [ 'border_color' ] , 'background_color' => $ data [ 'background_color' ] , 'text_color' => $ data [ 'text_color' ] , ] ; return $ event ; }
3309	protected function buildSignatureKey ( ) { $ signatures = [ 'a' => $ this -> appId , 'b' => $ this -> bucket , 'k' => $ this -> secretId , 'e' => time ( ) + 2592000 , 't' => time ( ) , 'r' => rand ( ) , 'u' => '0' , 'f' => '' ] ; return http_build_query ( $ signatures ) ; }
10183	private function getAllCacheKeys ( ) { $ keys = [ ] ; foreach ( $ this -> getCoordinates ( ) as $ coordinate ) { $ keys [ ] = $ this -> cachePrefix . $ coordinate ; } return $ keys ; }
4192	protected function dumpPhpDoc ( $ phpDoc ) { $ str = '' ; foreach ( $ phpDoc as $ k => $ values ) { if ( ! \ is_array ( $ values ) ) { continue ; } foreach ( $ values as $ value ) { if ( $ k == 'link' ) { $ value = '<a href="' . $ value [ 'uri' ] . '" target="_blank">' . \ htmlspecialchars ( $ value [ 'desc' ] ? : $ value [ 'uri' ] ) . '</a>' ; } elseif ( $ k == 'see' && $ value [ 'uri' ] ) { $ value = '<a href="' . $ value [ 'uri' ] . '" target="_blank">' . \ htmlspecialchars ( $ value [ 'desc' ] ? : $ value [ 'uri' ] ) . '</a>' ; } else { $ value = \ htmlspecialchars ( \ implode ( ' ' , $ value ) ) ; } $ str .= '<dd class="phpdoc phpdoc-' . $ k . '">' . '<span class="phpdoc-tag">' . $ k . '</span>' . '<span class="t_operator">:</span> ' . $ value . '</dd>' . "\n" ; } } if ( $ str ) { $ str = '<dt class="phpDoc">phpDoc</dt>' . "\n" . $ str ; } return $ str ; }
5233	public function handleException ( \ Exception $ exception ) { if ( $ this -> loggingEnabled ) { $ this -> exceptionLogger -> log ( $ exception ) ; } if ( 'cgi' === $ this -> sapi ) { $ this -> header ( 'Status: 500 Internal Server Error' ) ; } else { $ this -> header ( 'HTTP/1.1 500 Internal Server Error' ) ; } $ this -> writeBody ( $ this -> createResponseBody ( $ exception ) ) ; }
9090	function isMultipart ( ) { foreach ( $ this -> fields as $ field ) { if ( ! $ field instanceof Field ) { continue ; } if ( $ field -> getType ( ) == 'file' || $ field -> getValueType ( ) == 'file' || $ field -> getDataType ( ) ) { return true ; } } return false ; }
5767	private function create ( ) { $ m = new \ PHPMailer ( ) ; switch ( $ this -> protocol ) { case 'sendmail' : $ m -> isSendmail ( ) ; break ; case 'smtp' : $ m -> isSMTP ( ) ; $ m -> Host = $ this -> smtpHost ; $ m -> SMTPAuth = false ; $ m -> SMTPAutoTLS = false ; $ m -> Port = $ this -> smtpPort ; break ; case 'mail' : $ m -> isMail ( ) ; break ; case 'qmail' : $ m -> isQmail ( ) ; break ; default : throw new \ Exception ( 'bad phpmailerType: ' . $ this -> protocol ) ; } return $ m ; }
4679	public function set ( $ template , $ data = [ ] , $ sort = 0 , $ type = "file" ) { if ( empty ( $ template ) ) { $ type = "empty" ; } elseif ( is_array ( $ template ) ) { if ( isset ( $ template [ "callback" ] ) ) { $ type = "callback" ; $ this -> template = $ template [ "callback" ] ; } else { $ this -> template = $ template [ "template" ] ; } $ this -> sortOrder = $ template [ "sort" ] ?? $ sort ; $ this -> type = $ template [ "type" ] ?? $ type ; $ data1 = $ template [ "data" ] ?? [ ] ; if ( empty ( $ data ) ) { $ this -> templateData = $ data1 ; } else if ( empty ( $ data1 ) ) { $ this -> templateData = $ data ; } else { foreach ( $ data as $ key => $ val ) { if ( is_array ( $ val ) ) { if ( ! array_key_exists ( $ key , $ data1 ) ) { $ data1 [ $ key ] = [ ] ; } $ data1 [ $ key ] = array_merge ( $ data1 [ $ key ] , $ val ) ; } else { $ data1 [ $ key ] = $ val ; } $ this -> templateData = $ data1 ; } } return ; } $ this -> template = $ template ; $ this -> templateData = $ data ; $ this -> sortOrder = $ sort ; $ this -> type = $ type ; return $ this ; }
2715	public function render ( ) { return [ 'id' => $ this -> getId ( ) , 'translate' => 'label comment' , 'showInDefault' => 1 , 'showInWebsite' => 0 , 'showInStore' => 0 , 'sortOrder' => 1 , 'label' => $ this -> label , 'comment' => $ this -> comment , '_elementType' => 'group' , 'path' => self :: BASE_CONFIG_PATH , 'children' => $ this -> children ] ; }
2048	private function createStatement ( ) : void { if ( null !== $ this -> statement ) { return ; } if ( null === $ this -> container || ! $ this -> container -> has ( $ this -> dbalServiceName ) ) { throw new \ RuntimeException ( 'The container has not been injected or the database service is missing' ) ; } $ connection = $ this -> container -> get ( $ this -> dbalServiceName ) ; $ this -> statement = $ connection -> prepare ( ' INSERT INTO tl_log (tstamp, source, action, username, text, func, browser) VALUES (:tstamp, :source, :action, :username, :text, :func, :browser) ' ) ; }
1116	public function newNestedSetQuery ( $ excludeDeleted = true ) { $ builder = $ this -> newQuery ( $ excludeDeleted ) -> orderBy ( $ this -> getQualifiedOrderColumnName ( ) ) ; if ( $ this -> isScoped ( ) ) { foreach ( $ this -> scoped as $ scopeFld ) $ builder -> where ( $ scopeFld , '=' , $ this -> $ scopeFld ) ; } return $ builder ; }
5074	public function outputSetFormat ( $ sFormat ) { if ( static :: isValidFormat ( $ sFormat ) ) { $ this -> sOutputFormat = strtoupper ( $ sFormat ) ; return true ; } return false ; }
11760	public static function getArray ( ) { $ object = new \ ReflectionClass ( Collection :: class ) ; $ properties = $ object -> getProperties ( \ ReflectionProperty :: IS_PUBLIC ) ; $ array = array ( ) ; foreach ( $ properties as $ property ) { $ value = $ property -> getValue ( ) ; if ( ! empty ( $ value ) ) { $ array [ $ property -> getName ( ) ] = $ value ; } } return $ array ; }
5985	public function setTokens ( AccessToken $ accessToken , AccessToken $ refreshToken = null ) { if ( $ accessToken instanceof AccessToken && false === $ accessToken -> isExpired ( ) ) { if ( $ this -> cache instanceof Cache ) { $ this -> cache -> save ( 'oauth2accesstoken' , serialize ( $ accessToken ) , $ accessToken -> getExpires ( ) -> getTimestamp ( ) - ( new \ DateTime ( ) ) -> getTimestamp ( ) ) ; } $ this -> oauth2Middleware -> setAccessToken ( $ accessToken ) ; } if ( $ refreshToken instanceof AccessToken && false === $ accessToken -> isExpired ( ) ) { if ( $ this -> cache instanceof Cache ) { $ this -> cache -> save ( 'oauth2refreshtoken' , serialize ( $ refreshToken ) , $ refreshToken -> getExpires ( ) instanceof \ DateTime ? $ refreshToken -> getExpires ( ) -> getTimestamp ( ) - ( new \ DateTime ( ) ) -> getTimestamp ( ) : 3600 * 24 * 13 ) ; } $ this -> oauth2Middleware -> setRefreshToken ( $ refreshToken ) ; } }
1977	public function onPreviewUrlCreate ( PreviewUrlCreateEvent $ event ) : void { if ( ! $ this -> framework -> isInitialized ( ) || 'news' !== $ event -> getKey ( ) ) { return ; } $ request = $ this -> requestStack -> getCurrentRequest ( ) ; if ( null === $ request ) { throw new \ RuntimeException ( 'The request stack did not contain a request' ) ; } if ( 'tl_news' === $ request -> query -> get ( 'table' ) && ! $ request -> query -> has ( 'act' ) ) { return ; } if ( null === ( $ newsModel = $ this -> getNewsModel ( $ this -> getId ( $ event , $ request ) ) ) ) { return ; } $ event -> setQuery ( 'news=' . $ newsModel -> id ) ; }
5480	protected function addCheckbox ( $ tag ) { if ( ! isset ( $ this -> checkboxes [ $ tag -> getName ( ) ] ) ) { $ this -> widgets [ ] = $ tag ; $ this -> checkboxes [ $ tag -> getName ( ) ] = count ( $ this -> widgets ) - 1 ; } else { $ index = $ this -> checkboxes [ $ tag -> getName ( ) ] ; if ( ! is_a ( $ this -> widgets [ $ index ] , 'SimpleCheckboxGroup' ) ) { $ previous = $ this -> widgets [ $ index ] ; $ this -> widgets [ $ index ] = new SimpleCheckboxGroup ( ) ; $ this -> widgets [ $ index ] -> addWidget ( $ previous ) ; } $ this -> widgets [ $ index ] -> addWidget ( $ tag ) ; } }
8426	public function getAllInactiveQuery ( Production $ production ) : Query { $ qb = $ this -> createQueryBuilder ( 'p' ) ; return $ qb -> join ( 'p.groups' , 'g' ) -> andWhere ( $ qb -> expr ( ) -> eq ( 'g' , ':group' ) ) -> andWhere ( $ qb -> expr ( ) -> isNull ( 'p.parent' ) ) -> andWhere ( $ qb -> expr ( ) -> orX ( $ qb -> expr ( ) -> eq ( 'p.active' , ':active' ) , $ qb -> expr ( ) -> lt ( 'p.expiry' , ':now' ) ) ) -> setParameter ( 'group' , $ production ) -> setParameter ( 'active' , false ) -> setParameter ( 'now' , new \ DateTime ( ) ) -> addOrderBy ( 'p.updated' , 'DESC' ) -> getQuery ( ) ; }
11720	public function countPost ( $ actor ) { $ em = $ this -> container -> get ( 'doctrine' ) -> getManager ( ) ; $ entities = $ em -> getRepository ( 'BlogBundle:Post' ) -> findBy ( array ( 'actor' => $ actor ) ) ; return count ( $ entities ) ; }
7857	public function register ( ) { $ this -> registerPipelineRepository ( ) ; $ this -> registerInflector ( ) ; $ this -> registerDispatcher ( ) ; $ this -> registerWorkflow ( ) ; $ this -> registerWorkflowRunnersHook ( ) ; $ this -> registerCommands ( ) ; }
1202	public function buildItem ( ItemInterface $ item , array $ options ) { $ item -> setUri ( $ options [ 'uri' ] ) -> setLabel ( $ options [ 'label' ] ) -> setAttributes ( $ options [ 'attributes' ] ) -> setLinkAttributes ( $ options [ 'linkAttributes' ] ) -> setChildrenAttributes ( $ options [ 'childrenAttributes' ] ) -> setLabelAttributes ( $ options [ 'labelAttributes' ] ) -> setCurrent ( $ options [ 'current' ] ) -> setDisplay ( $ options [ 'display' ] ) -> setDisplayChildren ( $ options [ 'displayChildren' ] ) ; $ this -> buildExtras ( $ item , $ options ) ; }
10944	public function onPrerenderPre ( PrerenderEvent $ events ) { $ cache = $ this -> getServiceLocator ( ) -> get ( $ this -> moduleOptions -> getCacheKey ( ) ) ; return $ cache -> getItem ( $ this -> getCacheEntryKey ( $ events -> getRequest ( ) ) ) ; }
2848	public function setModuleStatus ( $ moduleName , $ isActive ) { $ moduleConfigFile = $ this -> getModuleConfigFilePath ( $ moduleName ) ; $ configXml = $ this -> loadXmlFile ( $ moduleConfigFile ) ; if ( $ configXml === false ) { throw new Exception ( "Unable to parse module configuration file {$moduleConfigFile}" ) ; } $ configXml -> modules -> { $ moduleName } -> active = $ isActive ? 'true' : 'false' ; if ( $ this -> saveXml ( $ configXml , $ moduleConfigFile ) === false ) { throw new Exception ( "Unable to save module configuration file {$moduleConfigFile}. Check to see if web server user has write permissions." ) ; } }
28	public static function register ( IOInterface $ io = null ) { set_error_handler ( array ( __CLASS__ , 'handle' ) ) ; error_reporting ( E_ALL | E_STRICT ) ; self :: $ io = $ io ; }
12390	public function setEntityPrototype ( $ entityPrototype ) { if ( ! is_object ( $ entityPrototype ) ) { throw new Exception \ InvalidArgumentException ( sprintf ( '%s expects parameter 1 to be an object, %s provided instead' , __METHOD__ , is_object ( $ entityPrototype ) ? get_class ( $ entityPrototype ) : gettype ( $ entityPrototype ) ) ) ; } $ this -> entityPrototype = $ entityPrototype ; return $ this ; }
1563	protected function isDateAttribute ( $ field , $ record ) { if ( empty ( $ this -> dates ) ) { return in_array ( $ this -> modelKeyForField ( $ field , $ record ) , $ record -> getDates ( ) , true ) ; } return in_array ( $ field , $ this -> dates , true ) ; }
7439	protected function initializeProductMediaGalleryValue ( array $ attr ) { $ rowId = $ attr [ MemberNames :: ROW_ID ] ; $ valueId = $ attr [ MemberNames :: VALUE_ID ] ; $ storeId = $ attr [ MemberNames :: STORE_ID ] ; if ( $ entity = $ this -> loadProductMediaGalleryValueByValueIdAndStoreIdAndRowId ( $ valueId , $ storeId , $ rowId ) ) { return $ this -> mergeEntity ( $ entity , $ attr ) ; } return $ attr ; }
4651	public function clean ( $ projectPath , $ keep = 1 , $ force = false ) { $ builds = $ this -> getJobsToRemove ( $ projectPath , $ keep ) ; $ this -> cleanDirectories ( $ builds ) ; $ this -> cleanContainers ( $ builds ) ; $ this -> cleanImages ( $ builds , $ force ) ; }
4003	protected function isPublishedItem ( $ objMetaModel , $ intItemId ) { $ statement = $ this -> connection -> prepare ( 'SELECT colname FROM tl_metamodel_attribute WHERE pid=? AND check_publish=1 LIMIT 0,1' ) ; $ statement -> bindValue ( 1 , $ objMetaModel -> get ( 'id' ) ) ; $ statement -> execute ( ) ; if ( $ statement -> rowCount ( ) > 0 ) { $ objAttrCheckPublish = $ statement -> fetch ( \ PDO :: FETCH_OBJ ) ; $ objItem = $ objMetaModel -> findById ( $ intItemId ) ; if ( ! $ objItem -> get ( $ objAttrCheckPublish -> colname ) ) { return false ; } } return true ; }
1951	public function resendButton ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { return ( ! $ row [ 'confirmedOn' ] && ! $ row [ 'invalidatedThrough' ] && $ row [ 'emailSubject' ] && $ row [ 'emailText' ] && $ row [ 'createdOn' ] > strtotime ( '-24 hours' ) ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : '' ; }
1515	public function delete ( StoreInterface $ store , DeleteResource $ request ) { $ result = $ this -> transaction ( function ( ) use ( $ store , $ request ) { return $ this -> doDelete ( $ store , $ request ) ; } ) ; if ( $ this -> isResponse ( $ result ) ) { return $ result ; } return $ this -> reply ( ) -> deleted ( $ result ) ; }
9642	public function resolve ( $ path ) { $ paths = [ ] ; foreach ( $ this -> paths as $ configuredPath ) { $ paths [ ] = $ configuredPath . '/' . $ path ; } $ parts = explode ( '/' , $ path ) ; if ( count ( $ parts ) == 1 ) { return $ paths ; } $ current = '' ; $ mountPaths = [ ] ; foreach ( $ parts as $ part ) { if ( $ current ) { $ current .= '/' . $ part ; } else { $ current = $ part ; } if ( isset ( $ this -> mounts [ $ current ] ) ) { foreach ( $ this -> mounts [ $ current ] as $ mount ) { $ relativePath = str_replace ( $ current , '' , $ path ) ; $ mountPaths [ ] = $ mount . $ relativePath ; } } } return array_merge ( $ mountPaths , $ paths ) ; }
7998	private function getOpenSslEncryptionOptions ( ) { $ options = self :: DEFAULT_OPENSSL_OPTIONS ; if ( $ this -> zero_pad ) { $ options = $ options | OPENSSL_ZERO_PADDING ; } return $ options ; }
4851	protected function applyId ( & $ row , $ id , $ identifierField ) { $ ids = ( array ) $ id ; $ findId = function ( $ row ) use ( $ ids , $ identifierField ) { foreach ( $ ids as $ id ) { $ bool = true ; $ identifierField = $ this -> flatten ( $ identifierField ) ; foreach ( $ identifierField as $ identifier ) { $ bool = $ bool && ( mb_strtolower ( $ id [ $ identifier ] ) === mb_strtolower ( $ row [ $ identifier ] ) ) ; } if ( $ bool ) { return $ id [ 'id' ] ; } } return 0 ; } ; $ isDeep = $ this -> isDeep ( $ row ) ; if ( $ isDeep ) { foreach ( $ row as $ i => & $ r ) { $ r [ 'id' ] = $ findId ( $ r ) ; } } else { $ row [ 'id' ] = $ findId ( $ row ) ; } }
6010	public function setDateRange ( $ dateRange ) { if ( $ dateRange instanceof DateTimeRange ) { $ this -> dateRange = $ dateRange ; } elseif ( is_array ( $ dateRange ) ) { $ this -> dateRange = new DateTimeRange ( $ dateRange ) ; } else { $ this -> dateRange = null ; trigger_error ( 'Argument must be an object of class DateTimeRange. Data loss!' , E_USER_WARNING ) ; } return $ this ; }
11695	protected function bustCacheBalls ( string $ asset_contents ) { $ asset_ext = $ this -> destination -> getExtension ( ) ; $ asset_name = $ this -> destination -> getBasename ( '.' . $ asset_ext ) ; $ asset_name_quoted = preg_quote ( $ asset_name , '/' ) ; $ search_for = '/' . $ asset_name_quoted . '\..*?\.' . $ asset_ext . '|' . $ asset_name_quoted . '\..*?\.min\.' . $ asset_ext . '|' . $ asset_name_quoted . '\.min\.' . $ asset_ext . '|' . $ asset_name_quoted . '\.' . $ asset_ext . '/' ; $ replace_with = $ asset_name . '.' . md5 ( $ asset_contents ) . '.' . $ asset_ext ; foreach ( $ this -> template as $ templateFile ) { $ this -> printTaskInfo ( 'Updating template file - <info>' . $ templateFile . '</info>' ) ; $ this -> collectionBuilder ( ) -> taskReplaceInFile ( $ templateFile ) -> regex ( $ search_for ) -> to ( $ replace_with ) -> run ( ) ; } $ asset_base_dir = $ this -> destination -> getPath ( ) ; $ this -> destination = new SplFileInfo ( $ asset_base_dir . '/' . $ replace_with ) ; $ files_to_delete = new Finder ( ) ; $ files_to_delete -> files ( ) ; $ files_to_delete -> name ( $ asset_name . '.' . $ asset_ext ) ; $ files_to_delete -> name ( $ asset_name . '.*.' . $ asset_ext ) ; $ files_to_delete -> name ( $ asset_name . '.*.' . $ asset_ext . '.gz' ) ; $ files_to_delete -> in ( $ asset_base_dir ) ; $ files_to_delete -> depth ( '== 0' ) ; foreach ( $ files_to_delete as $ file_to_delete ) { unlink ( $ file_to_delete -> getPathname ( ) ) ; } }
1522	public function process ( StoreInterface $ store , FetchProcess $ request ) { $ record = $ store -> readRecord ( $ request -> getProcess ( ) , $ request -> getEncodingParameters ( ) ) ; return $ this -> reply ( ) -> process ( $ record ) ; }
5017	public function logJobEnd ( ProcessJobEvent $ event ) : void { $ result = $ event -> getResult ( ) ; $ job = $ event -> getJob ( ) ; $ queue = $ event -> getQueue ( ) -> getName ( ) ; $ logger = $ this -> getLogger ( ) ; switch ( $ result ) { default : $ logger -> info ( sprintf ( $ this -> tmpl [ 'job' ] , $ queue , 'SUCCESS' , $ this -> formatJob ( $ job ) ) ) ; break ; case ProcessJobEvent :: JOB_STATUS_FAILURE_RECOVERABLE : $ logger -> warn ( sprintf ( $ this -> tmpl [ 'job' ] , $ queue , 'RECOVERABLE' , $ this -> formatJob ( $ job ) ) ) ; break ; case ProcessJobEvent :: JOB_STATUS_FAILURE : $ logger -> err ( sprintf ( $ this -> tmpl [ 'job' ] , $ queue , 'FAILURE' , $ this -> formatJob ( $ job ) ) ) ; break ; } }
12556	private function createDeleteForm ( Tag $ tag ) { return $ this -> createFormBuilder ( ) -> setAction ( $ this -> generateUrl ( 'blog_tag_delete' , array ( 'id' => $ tag -> getId ( ) ) ) ) -> setMethod ( 'DELETE' ) -> getForm ( ) ; }
5976	public function media ( ) { if ( ! $ this -> media instanceof MediaController ) { $ this -> media = new MediaController ( $ this -> getClient ( ) , $ this -> cachePolicy , $ this -> cache ) ; $ this -> media -> setLogger ( $ this -> logger ) ; } return $ this -> media ; }
5977	public function moodboards ( ) { if ( ! $ this -> moodboards instanceof MoodboardsController ) { $ this -> moodboards = new MoodboardsController ( $ this -> getClient ( ) , $ this -> cachePolicy , $ this -> cache ) ; $ this -> moodboards -> setLogger ( $ this -> logger ) ; } return $ this -> moodboards ; }
3652	public function parse ( $ strOutputFormat , $ blnFailIfNotFound = false ) { if ( $ this -> strTemplate == '' ) { return '' ; } $ this -> strFormat = $ strOutputFormat ; $ this -> callParseTemplateHook ( ) ; $ strBuffer = '' ; $ this -> strParent = $ this -> strTemplate ; while ( $ this -> strParent !== null ) { $ strCurrent = $ this -> strParent ; $ strParent = $ this -> strDefault ? : $ this -> getTemplate ( $ this -> strParent , $ this -> strFormat , $ blnFailIfNotFound ) ; if ( empty ( $ strParent ) ) { return sprintf ( 'Template %s not found (it is maybe within a unreachable theme folder?).' , $ this -> strParent ) ; } $ this -> strParent = null ; $ this -> strDefault = null ; ob_start ( ) ; include ( $ strParent ) ; if ( $ this -> strParent === null ) { $ strBuffer = ob_get_contents ( ) ; } elseif ( $ this -> strParent == $ strCurrent ) { $ this -> strDefault = $ this -> getTemplate ( $ this -> strParent , $ this -> strFormat , $ blnFailIfNotFound ) ; } ob_end_clean ( ) ; } $ this -> arrBlocks = array ( ) ; if ( \ Config :: get ( 'debugMode' ) && in_array ( $ this -> strFormat , [ 'html5' , 'xhtml' ] ) ) { $ strRelPath = str_replace ( TL_ROOT . '/' , '' , $ this -> getTemplate ( $ this -> strTemplate , $ this -> strFormat ) ) ; $ strBuffer = <<<EOF<!-- TEMPLATE START: $strRelPath ; } return $ strBuffer ; }
2000	private function fetchData ( FileUpload $ uploader , string $ separator , callable $ callback ) : array { $ data = [ ] ; $ files = $ this -> getFiles ( $ uploader ) ; $ delimiter = $ this -> getDelimiter ( $ separator ) ; foreach ( $ files as $ file ) { $ fp = fopen ( $ file , 'r' ) ; while ( false !== ( $ row = fgetcsv ( $ fp , 0 , $ delimiter ) ) ) { $ data = $ callback ( $ data , $ row ) ; } } return $ data ; }
10614	public function createMigrateRepository ( array $ args ) { $ db = $ this -> app -> db ; $ repo = new Repository ( $ db ) ; $ resolver = $ this -> app -> resolver -> getResolver ( "migrations" ) ; $ mods = [ ] ; foreach ( $ resolver -> getSearchPath ( ) as $ name => $ path ) { $ module = new Module ( $ name , $ path , $ db ) ; if ( $ name === "wedeto.db" ) array_unshift ( $ mods , $ module ) ; else array_push ( $ mods , $ module ) ; } foreach ( $ mods as $ module ) $ repo -> addModule ( $ module ) ; return $ repo ; }
11238	public function getRedirect ( $ url = null ) { if ( $ url ) { if ( is_numeric ( $ url ) ) { $ steps = $ url ; $ offset = count ( $ _SESSION [ 'redirect' ] [ 'history' ] ) + $ steps ; if ( isset ( $ _SESSION [ 'redirect' ] [ 'history' ] [ $ offset ] ) ) { $ redirect = $ _SESSION [ 'redirect' ] [ 'history' ] [ $ offset ] ; if ( ! empty ( $ redirect ) ) { return $ redirect ; } else { return BASE_URL ; } } else { return $ this -> config [ 'site_url' ] ; } } else { if ( substr ( $ url , 0 , 1 ) == '/' ) { return $ this -> config [ 'site_url' ] . substr ( $ url , 1 ) ; } else { return $ url ; } } } else { return $ this -> config [ 'site_url' ] ; } }
1645	public function getDistance ( Coordinate $ coordinate , DistanceInterface $ calculator ) : float { return $ calculator -> getDistance ( $ this , $ coordinate ) ; }
6779	protected function configureAcceptedSale ( SaleInterface $ sale ) { if ( null === $ date = $ sale -> getAcceptedAt ( ) ) { return false ; } $ changed = $ this -> updateExchangeRate ( $ sale ) ; $ changed |= $ this -> updateLocale ( $ sale ) ; return $ changed ; }
39	protected function generatePackageTree ( PackageInterface $ package , RepositoryInterface $ installedRepo , RepositoryInterface $ distantRepos ) { $ requires = $ package -> getRequires ( ) ; ksort ( $ requires ) ; $ children = array ( ) ; foreach ( $ requires as $ requireName => $ require ) { $ packagesInTree = array ( $ package -> getName ( ) , $ requireName ) ; $ treeChildDesc = array ( 'name' => $ requireName , 'version' => $ require -> getPrettyConstraint ( ) , ) ; $ deepChildren = $ this -> addTree ( $ requireName , $ require , $ installedRepo , $ distantRepos , $ packagesInTree ) ; if ( $ deepChildren ) { $ treeChildDesc [ 'requires' ] = $ deepChildren ; } $ children [ ] = $ treeChildDesc ; } $ tree = array ( 'name' => $ package -> getPrettyName ( ) , 'version' => $ package -> getPrettyVersion ( ) , 'description' => $ package -> getDescription ( ) , ) ; if ( $ children ) { $ tree [ 'requires' ] = $ children ; } return $ tree ; }
12370	public static function getArrayItemByPointSeparatedKey ( array & $ data , string $ key ) { if ( strpos ( $ key , '.' ) !== false ) { preg_match ( '/([a-zA-Z0-9_\-]+)\.([a-zA-Z0-9_\-\.]+)/' , $ key , $ keys ) ; if ( ! isset ( $ data [ $ keys [ 1 ] ] ) ) { throw new Exception ( 'Undefined index: ' . $ keys [ 1 ] ) ; } if ( ! is_array ( $ data [ $ keys [ 1 ] ] ) ) { throw new Exception ( "The element indexed {$keys[1]} isn't an array." ) ; } return self :: getArrayItemByPointSeparatedKey ( $ data [ $ keys [ 1 ] ] , $ keys [ 2 ] ) ; } elseif ( isset ( $ data [ $ key ] ) ) { return $ data [ $ key ] ; } else { throw new Exception ( 'Undefined index: ' . $ key ) ; } }
10744	public function getArray ( $ keys , array $ default = [ ] ) : array { $ result = $ this -> get ( $ keys , $ default ) ; if ( ! is_array ( $ result ) ) { $ result = $ default ; } return $ result ; }
5208	public function p ( ) { $ args = func_get_args ( ) ; $ node = $ args [ 0 ] ; if ( null === $ node ) { return ; } $ this -> logger -> trace ( 'p' . $ node -> getType ( ) , $ node , $ this -> getMetadata ( ) -> getFullQualifiedNameClass ( ) ) ; $ class = $ this -> getClass ( 'p' . $ node -> getType ( ) ) ; return call_user_func_array ( array ( $ class , "convert" ) , $ args ) ; }
6456	public function selectable ( ) { $ this -> restrictElements ( [ 'select' => [ ] ] ) ; $ data = [ $ this -> value , $ this -> element -> find ( 'xpath' , "//option[@value='$this->value']" ) -> getText ( ) ] ; self :: debug ( [ 'Expected: %s' , 'Value: %s' , 'Tag: %s' , ] , [ $ this -> expected , implode ( ' => ' , $ data ) , $ this -> tag , ] ) ; $ this -> assert ( in_array ( $ this -> expected , $ data ) , 'selected' ) ; }
9815	public function setWorksheet ( Worksheet $ value = null ) { if ( $ value !== null ) { $ this -> worksheet = $ value ; } return $ this ; }
9153	public function getUrlString ( ) : string { $ query = "" ; if ( strlen ( $ this -> queryString ) > 0 ) { $ query = sprintf ( "?%s" , $ this -> queryString ) ; } if ( ( $ this -> scheme == 'http' && $ this -> getPort ( ) == 80 ) || ( $ this -> scheme == 'ftp' && $ this -> getPort ( ) == 21 ) || ( $ this -> scheme == 'https' && $ this -> getPort ( ) == 443 ) ) { return sprintf ( "%s://%s%s%s" , $ this -> scheme , $ this -> getAddress ( ) , $ this -> path , $ query ) ; } return sprintf ( "%s://%s:%d%s%s" , $ this -> scheme , $ this -> getAddress ( ) , $ this -> getPort ( ) , $ this -> path , $ query ) ; }
5123	private function getAttachmentEndPoint ( string $ idArticle , string $ field ) : string { return $ this -> replaceEndPointId ( $ idArticle , $ this -> attachmentUrl [ $ field ] ) ; }
5395	public function paintException ( $ exception ) { parent :: paintException ( $ exception ) ; print $ this -> getIndent ( 1 ) ; print '<' . $ this -> namespace . 'exception>' ; $ message = 'Unexpected exception of type [' . get_class ( $ exception ) . '] with message [' . $ exception -> getMessage ( ) . '] in [' . $ exception -> getFile ( ) . ' line ' . $ exception -> getLine ( ) . ']' ; print $ this -> toParsedXml ( $ message ) ; print '</' . $ this -> namespace . "exception>\n" ; }
3459	public function add ( Route $ route ) : void { if ( $ route instanceof Route ) { $ name = $ route -> getName ( ) ; } else { $ name = Route :: generateNameFromPath ( $ route -> getPath ( ) ) ; } $ baseRoute = new SymfonyRoute ( $ route -> getPath ( ) ) ; $ baseRoute -> setMethods ( $ route -> getMethods ( ) ) ; $ this -> routeCollection -> add ( $ name , $ baseRoute ) ; $ this -> routes [ $ name ] = $ route ; }
1890	public function grantsAccess ( ) : bool { $ content = array_filter ( file ( ( string ) $ this -> file ) ) ; foreach ( $ content as $ line ) { if ( $ this -> hasRequireGranted ( $ line ) ) { return true ; } } return false ; }
160	public function andHaving ( $ condition , $ params = [ ] ) { if ( $ this -> having === null ) { $ this -> having = $ condition ; } else { $ this -> having = [ 'and' , $ this -> having , $ condition ] ; } $ this -> addParams ( $ params ) ; return $ this ; }
11045	function read_content ( ) { if ( $ this -> external_source_read ) { $ fct = $ this -> source_read_name ; return $ fct ( $ this -> container ) ; } else { $ content = FALSE ; if ( $ handle = @ fopen ( $ this -> container , 'rb' ) ) { $ size = @ filesize ( $ this -> container ) ; $ content = @ fread ( $ handle , $ size ) ; fclose ( $ handle ) ; } return $ content ; } }
8542	public function setPluralForm ( $ key , $ plural ) { if ( ! is_array ( $ plural ) ) $ plural = [ $ plural ] ; if ( ! $ this -> msgstr_plural ) $ this -> msgstr_plural = [ ] ; $ this -> msgstr_plural [ $ key ] = $ plural ; }
12489	protected static function setPath ( $ writePath ) { if ( is_file ( $ writePath ) ) { self :: $ logFilePath = $ writePath ; return true ; } throw new \ Exception ( 'Impossible de modifier la destination des logs : le fichier ' . $ writePath . ' n\'existe pas.' ) ; return false ; }
3373	public function indexAction ( ) { $ request = $ this -> getRequest ( ) ; $ this -> httpClient -> setMethod ( Request :: METHOD_POST ) ; $ this -> httpClient -> setParameterPost ( [ 'dsl_text' => $ request -> getPost ( 'dsl_text' ) ] ) ; $ response = $ this -> httpClient -> send ( ) ; if ( ! $ response -> isSuccess ( ) ) { throw new \ UnexpectedValueException ( 'HTTP Request failed' ) ; } $ redirect = $ this -> plugin ( 'redirect' ) ; return $ redirect -> toUrl ( 'https://yuml.me/' . $ response -> getBody ( ) ) ; }
11111	public function migrate ( array $ options = [ ] ) : void { $ files = $ this -> getMigrationFiles ( M :: TYPE_UP ) ; $ migrations = $ this -> pendingMigrations ( $ files , $ this -> repository -> getRan ( ) ) ; $ this -> runPending ( $ migrations , $ options ) ; }
1129	public function getLeftSibling ( ) { return $ this -> siblings ( ) -> where ( $ this -> getLeftColumnName ( ) , '<' , $ this -> getLeft ( ) ) -> orderBy ( $ this -> getOrderColumnName ( ) , 'desc' ) -> get ( ) -> last ( ) ; }
3976	public function handle ( EncodePropertyValueFromWidgetEvent $ event ) { if ( ! parent :: wantToHandle ( $ event ) || ( $ event -> getProperty ( ) !== 'colname' ) ) { return ; } $ oldColumnName = $ event -> getModel ( ) -> getProperty ( $ event -> getProperty ( ) ) ; $ columnName = $ event -> getValue ( ) ; $ metaModel = $ this -> getMetaModelByModelPid ( $ event -> getModel ( ) ) ; if ( ( ! $ columnName ) || $ oldColumnName !== $ columnName ) { $ this -> tableManipulator -> checkColumnDoesNotExist ( $ metaModel -> getTableName ( ) , $ columnName ) ; $ colNames = array_keys ( $ metaModel -> getAttributes ( ) ) ; if ( in_array ( $ columnName , $ colNames ) ) { throw new \ RuntimeException ( sprintf ( $ event -> getEnvironment ( ) -> getTranslator ( ) -> translate ( 'columnExists' , 'ERR' ) , $ columnName , $ metaModel -> getTableName ( ) ) ) ; } } }
11603	public function align ( PagesCollectionParser $ pagesCollectionParser ) { $ themeSlots = $ this -> findSlotsInTemplates ( ) ; $ slots = $ this -> mergeSlotsByStatus ( $ themeSlots ) ; if ( ! array_key_exists ( "page" , $ slots ) ) { return ; } $ pageSlots = $ slots [ "page" ] ; unset ( $ slots [ "page" ] ) ; $ files = $ this -> removeCommonSlots ( $ slots ) ; $ files = array_merge ( $ files , $ this -> removePageSlots ( $ pagesCollectionParser , $ pageSlots ) ) ; if ( ! empty ( $ files ) ) { $ fs = new Filesystem ( ) ; $ fs -> remove ( $ files ) ; } }
9027	public function isQuestion ( $ string ) { $ probability = 0 ; if ( strpos ( $ string , '?' ) ) { $ probability += 1 ; } $ words = $ this -> getWords ( $ string ) ; foreach ( $ this -> inquiryWords as $ queryWord ) { if ( ! strncmp ( strtolower ( $ string ) , $ queryWord , strlen ( $ queryWord ) ) ) { $ probability += 1 ; } elseif ( stristr ( strtolower ( $ string ) , $ queryWord ) ) { $ probability += 0.5 ; } } if ( $ probability >= 2 ) { return true ; } return false ; }
5744	public static function getDatabaseColumnValidationValue ( ColumnMapper $ databaseColumnMapper , string $ validationType ) { foreach ( self :: getDatabaseColumnValidation ( $ databaseColumnMapper ) as $ validation ) { if ( ! is_array ( $ validation ) && $ validation == $ validationType ) { return true ; } elseif ( is_array ( $ validation ) && $ validation [ 0 ] == $ validationType ) { return $ validation [ 1 ] ; } } return false ; }
8821	public function filter ( $ data = null , $ filter = false ) { if ( is_null ( $ data ) ) { return null ; } if ( is_array ( $ data ) ) { return array_map ( function ( $ value ) use ( $ filter ) { return $ this -> filter ( $ value , $ filter ) ; } , $ data ) ; } return ( $ filter == true ? $ this -> xssClean ( $ data ) : trim ( $ data ) ) ; }
8806	protected function ensureFacadeExists ( $ alias ) { if ( file_exists ( $ path = storage_path ( 'cache/facade-' . sha1 ( $ alias ) . '.php' ) ) ) { return $ path ; } file_put_contents ( $ path , $ this -> formatFacadeStub ( $ alias , file_get_contents ( __DIR__ . '/stubs/facade.stub' ) ) ) ; return $ path ; }
8367	public static function get ( string $ name ) : array { if ( isset ( self :: $ mappings [ $ name ] ) === false ) { throw new MappingNotFound ( 'there\'s no registered mapping with name "' . $ name . '"' ) ; } return self :: $ mappings [ $ name ] ; }
5888	public function getClass ( $ prefix = "ts3_" ) { if ( $ this instanceof Channel && $ this -> isSpacer ( ) ) { return $ prefix . "spacer" ; } elseif ( $ this instanceof Client && $ this [ "client_type" ] ) { return $ prefix . "query" ; } return $ prefix . StringHelper :: factory ( get_class ( $ this ) ) -> toLower ( ) ; }
9131	public function load ( $ file , $ type = null ) { $ path = $ this -> locator -> locate ( $ file ) ; if ( ! stream_is_local ( $ path ) ) { throw new \ InvalidArgumentException ( sprintf ( 'This is not a local file "%s".' , $ path ) ) ; } if ( ! file_exists ( $ path ) ) { throw new \ InvalidArgumentException ( sprintf ( 'File "%s" not found.' , $ path ) ) ; } if ( null === $ this -> yamlParser ) { $ this -> yamlParser = new YamlParser ( ) ; } $ config = $ this -> yamlParser -> parse ( file_get_contents ( $ path ) ) ; $ collection = new RuleCollection ( ) ; $ collection -> addResource ( new FileResource ( $ path ) ) ; if ( null === $ config ) { return $ collection ; } if ( ! is_array ( $ config ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The file "%s" must contain a YAML array.' , $ path ) ) ; } foreach ( $ config as $ name => $ subConfig ) { $ this -> validate ( $ subConfig , $ name , $ path ) ; if ( isset ( $ subConfig [ 'resource' ] ) ) { $ this -> parseImport ( $ collection , $ subConfig , $ path , $ file ) ; } else { $ this -> parseRule ( $ collection , $ name , $ subConfig , $ path ) ; } } return $ collection ; }
5834	protected function setCode ( $ code ) { $ this -> code = $ code ; $ this -> statusText = $ code ; list ( $ this -> statusCode , ) = explode ( ' ' , $ code ) ; }
3355	public function getUrl ( $ postfix = null ) { $ url = sprintf ( '%s%s' , $ this -> api -> getCdnUri ( ) , $ this -> getPath ( $ postfix ) ) ; return $ url ; }
1885	public function getItemsAsString ( $ strSeparator = ' ' ) { $ arrLinks = array ( ) ; foreach ( $ this -> getItemsAsArray ( ) as $ arrItem ) { if ( $ arrItem [ 'href' ] === null ) { $ arrLinks [ ] = sprintf ( '<li><strong class="active">%s</strong></li>' , $ arrItem [ 'page' ] ) ; } else { $ arrLinks [ ] = sprintf ( '<li><a href="%s" class="link" title="%s">%s</a></li>' , $ arrItem [ 'href' ] , $ arrItem [ 'title' ] , $ arrItem [ 'page' ] ) ; } } return implode ( $ strSeparator , $ arrLinks ) ; }
4205	private function getParams ( \ ReflectionMethod $ reflectionMethod , $ phpDoc = array ( ) ) { $ paramArray = array ( ) ; $ params = $ reflectionMethod -> getParameters ( ) ; if ( empty ( $ phpDoc ) ) { $ phpDoc = $ this -> phpDoc -> getParsed ( $ reflectionMethod ) ; } foreach ( $ params as $ i => $ reflectionParameter ) { $ nameNoPrefix = $ reflectionParameter -> getName ( ) ; $ name = '$' . $ nameNoPrefix ; if ( \ method_exists ( $ reflectionParameter , 'isVariadic' ) && $ reflectionParameter -> isVariadic ( ) ) { $ name = '...' . $ name ; } if ( $ reflectionParameter -> isPassedByReference ( ) ) { $ name = '&' . $ name ; } $ constantName = null ; $ defaultValue = $ this -> abstracter -> UNDEFINED ; if ( $ reflectionParameter -> isDefaultValueAvailable ( ) ) { $ defaultValue = $ reflectionParameter -> getDefaultValue ( ) ; if ( \ version_compare ( PHP_VERSION , '5.4.6' , '>=' ) && $ reflectionParameter -> isDefaultValueConstant ( ) ) { $ constantName = $ reflectionParameter -> getDefaultValueConstantName ( ) ; } } $ paramInfo = array ( 'constantName' => $ constantName , 'defaultValue' => $ defaultValue , 'desc' => null , 'isOptional' => $ reflectionParameter -> isOptional ( ) , 'name' => $ name , 'type' => $ this -> getParamTypeHint ( $ reflectionParameter ) , ) ; if ( isset ( $ phpDoc [ 'param' ] [ $ i ] ) ) { $ paramInfo [ 'desc' ] = $ phpDoc [ 'param' ] [ $ i ] [ 'desc' ] ; if ( ! isset ( $ paramInfo [ 'type' ] ) ) { $ paramInfo [ 'type' ] = $ phpDoc [ 'param' ] [ $ i ] [ 'type' ] ; } } $ paramArray [ $ nameNoPrefix ] = $ paramInfo ; } return $ paramArray ; }
4398	protected function getTransactionReference ( \ Aimeos \ MShop \ Order \ Item \ Base \ Iface $ base ) { $ code = $ this -> getServiceItem ( ) -> getCode ( ) ; $ service = $ base -> getService ( \ Aimeos \ MShop \ Order \ Item \ Base \ Service \ Base :: TYPE_PAYMENT , $ code ) ; return $ service -> getAttribute ( 'TRANSACTIONID' , 'payment/omnipay' ) ; }
11364	public static function headerTagger ( $ name = '' , $ value = '' , $ adds = array ( ) ) { $ str = $ name . ': ' . $ value ; if ( count ( $ adds ) ) { foreach ( $ adds as $ n => $ v ) { $ str .= Mailer :: $ HEADERS_SEPARATOR . ( $ n == 'boundary' ? "\n\t" : '' ) . $ n . "=\"" . $ v . "\"" ; } } return ( trim ( $ str , Mailer :: $ HEADERS_SEPARATOR ) ) ; }
8674	public function mapKeys ( callable $ callback ) { $ items = [ ] ; foreach ( $ this -> items as $ key => $ value ) { $ items [ $ callback ( $ key , $ value ) ] = $ value ; } return $ this -> createFrom ( $ items ) ; }
7908	protected function renderDropdown ( ) { $ lines = [ ] ; $ lines [ ] = $ this -> encodeText ? Html :: encode ( $ this -> text ) : $ this -> text ; if ( $ this -> icon && is_string ( $ this -> icon ) ) { $ lines [ ] = $ this -> icon ; } $ lines [ ] = $ this -> renderItems ( $ this -> items , $ this -> options , $ this -> displaySearchInput ) ; return Html :: tag ( 'div' , implode ( "\n" , $ lines ) , $ this -> options ) ; }
8338	public function returning ( $ returning ) { if ( is_array ( $ returning ) === true ) { $ this -> returning = implode ( ', ' , $ returning ) ; } else { $ this -> returning = $ returning ; } return $ this ; }
1721	private function getStringRepresentation ( array $ chunks , $ value ) : string { switch ( \ count ( $ chunks ) ) { case 2 : return sprintf ( "\$GLOBALS['TL_LANG']['%s'][%s] = %s;\n" , $ chunks [ 0 ] , $ this -> quoteKey ( $ chunks [ 1 ] ) , $ this -> quoteValue ( $ value ) ) ; case 3 : return sprintf ( "\$GLOBALS['TL_LANG']['%s'][%s][%s] = %s;\n" , $ chunks [ 0 ] , $ this -> quoteKey ( $ chunks [ 1 ] ) , $ this -> quoteKey ( $ chunks [ 2 ] ) , $ this -> quoteValue ( $ value ) ) ; case 4 : return sprintf ( "\$GLOBALS['TL_LANG']['%s'][%s][%s][%s] = %s;\n" , $ chunks [ 0 ] , $ this -> quoteKey ( $ chunks [ 1 ] ) , $ this -> quoteKey ( $ chunks [ 2 ] ) , $ this -> quoteKey ( $ chunks [ 3 ] ) , $ this -> quoteValue ( $ value ) ) ; } throw new \ OutOfBoundsException ( 'Cannot load less than 2 or more than 4 levels in XLIFF language files.' ) ; }
12259	public function compile ( callable $ validator = NULL ) { if ( ! ( $ project = $ this -> getProject ( ) ) ) { $ project = CC :: get ( $ this -> getConfiguration ( ) , CC :: COMPILER_PROJECT ) ; if ( ! $ project ) throw new CompilerException ( "Compilation without project settings is not possible" ) ; } $ this -> project = $ project ; try { set_error_handler ( function ( $ code , $ msg , $ file , $ line ) { switch ( AbstractErrorHandlerService :: detectErrorLevel ( $ code ) ) { case AbstractErrorHandlerService :: NOTICE_ERROR_LEVEL : return $ this -> getLogger ( ) -> logNotice ( $ msg , [ $ file , $ line ] ) ; case AbstractErrorHandlerService :: DEPRECATED_ERROR_LEVEL : case AbstractErrorHandlerService :: WARNING_ERROR_LEVEL : return $ this -> getLogger ( ) -> logWarning ( $ msg , [ $ file , $ line ] ) ; default : return $ this -> getLogger ( ) -> logError ( $ msg , [ $ file , $ line ] ) ; } } ) ; foreach ( $ this -> getOrganizedCompilers ( ) as $ compiler ) { if ( ! $ validator || $ validator ( $ compiler ) ) $ compiler -> compile ( $ this ) ; } } catch ( Throwable $ throwable ) { $ this -> getLogger ( ) -> logException ( $ throwable ) ; } finally { restore_error_handler ( ) ; } }
1048	public static function value ( $ rawString ) { $ lines = preg_split ( "/\\r\\n|[\\n\\r]/" , $ rawString ) ; $ commonIndent = null ; $ linesLength = count ( $ lines ) ; for ( $ i = 1 ; $ i < $ linesLength ; $ i ++ ) { $ line = $ lines [ $ i ] ; $ indent = self :: leadingWhitespace ( $ line ) ; if ( $ indent >= mb_strlen ( $ line ) || ( $ commonIndent !== null && $ indent >= $ commonIndent ) ) { continue ; } $ commonIndent = $ indent ; if ( $ commonIndent === 0 ) { break ; } } if ( $ commonIndent ) { for ( $ i = 1 ; $ i < $ linesLength ; $ i ++ ) { $ line = $ lines [ $ i ] ; $ lines [ $ i ] = mb_substr ( $ line , $ commonIndent ) ; } } while ( count ( $ lines ) > 0 && trim ( $ lines [ 0 ] , " \t" ) === '' ) { array_shift ( $ lines ) ; } while ( count ( $ lines ) > 0 && trim ( $ lines [ count ( $ lines ) - 1 ] , " \t" ) === '' ) { array_pop ( $ lines ) ; } return implode ( "\n" , $ lines ) ; }
7072	protected function getAttachmentFromEvent ( ResourceEventInterface $ event ) { $ attachment = $ event -> getResource ( ) ; if ( ! $ attachment instanceof TicketAttachmentInterface ) { throw new UnexpectedValueException ( "Expected instance of " . TicketAttachmentInterface :: class ) ; } return $ attachment ; }
4468	public function setPriority ( int $ priority ) : void { if ( $ this -> client -> call ( 'priority' , $ this -> jid , $ priority ) ) { parent :: setPriority ( $ priority ) ; } }
4908	public function render ( SummaryFormInterface $ form , $ layout = Form :: LAYOUT_HORIZONTAL , $ parameter = array ( ) ) { $ renderer = $ this -> getView ( ) ; $ renderer -> headscript ( ) -> appendFile ( $ renderer -> basepath ( 'modules/Core/js/jquery.summary-form.js' ) ) ; $ label = $ form -> getLabel ( ) ; $ labelContent = $ label ? '<div class="sf-headline"><h3>' . $ this -> getView ( ) -> translate ( $ label ) . '</h3></div>' : '' ; $ formContent = $ this -> renderForm ( $ form , $ layout , $ parameter ) ; $ summaryContent = $ this -> renderSummary ( $ form ) ; $ formContent = sprintf ( '<div class="sf-form"><div class="panel panel-info"><div class="panel-body">%s</div></div></div> <div class="sf-summary">%s</div> ' , $ formContent , $ summaryContent ) ; if ( $ form instanceof DescriptionAwareFormInterface && $ form -> isDescriptionsEnabled ( ) ) { $ this -> getView ( ) -> headscript ( ) -> appendFile ( $ this -> getView ( ) -> basepath ( 'modules/Core/js/forms.descriptions.js' ) ) ; if ( $ desc = $ form -> getOption ( 'description' , '' ) ) { $ translator = $ this -> getTranslator ( ) ; $ textDomain = $ this -> getTranslatorTextDomain ( ) ; $ desc = $ translator -> translate ( $ desc , $ textDomain ) ; } $ formContent = sprintf ( '<div class="daf-form-container row"> <div class="daf-form col-md-8">%s</div> <div class="daf-desc col-md-4"> <div class="daf-desc-content alert alert-info">%s</div> </div> </div>' , $ formContent , $ desc ) ; } $ markup = '<div id="sf-%s" class="sf-container" data-display-mode="%s">' . '%s' . '%s' . '</div>' ; $ id = str_replace ( '.' , '-' , $ form -> getAttribute ( 'name' ) ) ; $ content = sprintf ( $ markup , $ id , $ form -> getDisplayMode ( ) , $ labelContent , $ formContent ) ; return $ content ; }
2991	private function encodeRecord ( $ record , $ childName , & $ xml ) { foreach ( $ record as $ key => $ value ) { if ( $ value instanceof \ DateTime ) { if ( $ value -> format ( 'His' ) === '000000' ) { $ value = $ value -> format ( 'm/d/Y' ) ; } else { $ value = $ value -> format ( 'Y-m-d H:i:s' ) ; } } $ keyValue = $ xml -> addChild ( $ childName ) ; $ keyValue -> addAttribute ( 'val' , $ key ) ; if ( is_array ( $ value ) ) { $ this -> parseNestedValues ( $ value , $ keyValue ) ; } else { $ keyValue [ 0 ] = $ value ; } } }
698	public function actionRun ( $ command ) { $ command = implode ( ' ' , \ func_get_args ( ) ) ; $ base = \ dirname ( \ dirname ( __DIR__ ) ) ; $ dirs = $ this -> listSubDirs ( "$base/extensions" ) ; $ dirs = array_merge ( $ dirs , $ this -> listSubDirs ( "$base/apps" ) ) ; asort ( $ dirs ) ; $ oldcwd = getcwd ( ) ; foreach ( $ dirs as $ dir ) { $ displayDir = substr ( $ dir , \ strlen ( $ base ) ) ; $ this -> stdout ( "Running '$command' in $displayDir...\n" , Console :: BOLD ) ; chdir ( $ dir ) ; passthru ( $ command ) ; $ this -> stdout ( "done.\n" , Console :: BOLD , Console :: FG_GREEN ) ; } chdir ( $ oldcwd ) ; }
9697	function findTransactionTypeByName ( $ type_name ) { $ types = $ this -> getTransactionTypes ( 1 , 1000 ) -> getResult ( ) ; $ type_name = mb_strtolower ( $ type_name ) ; foreach ( $ types as $ type ) { if ( strcmp ( mb_strtolower ( $ type -> name ) , $ type_name ) == 0 ) { return ( int ) $ type -> id ; } } return null ; }
2244	protected function getSpellcheckerString ( ) { System :: loadLanguageFile ( 'languages' ) ; $ return = array ( ) ; $ langs = scan ( __DIR__ . '/../../languages' ) ; array_unshift ( $ langs , $ GLOBALS [ 'TL_LANGUAGE' ] ) ; foreach ( $ langs as $ lang ) { $ lang = substr ( $ lang , 0 , 2 ) ; if ( isset ( $ GLOBALS [ 'TL_LANG' ] [ 'LNG' ] [ $ lang ] ) ) { $ return [ $ lang ] = $ GLOBALS [ 'TL_LANG' ] [ 'LNG' ] [ $ lang ] . '=' . $ lang ; } } return '+' . implode ( ',' , array_unique ( $ return ) ) ; }
1469	public static function httpErrorStatus ( $ errors , int $ default = SymfonyResponse :: HTTP_BAD_REQUEST ) : int { if ( $ errors instanceof ErrorInterface ) { $ errors = [ $ errors ] ; } $ statuses = collect ( $ errors ) -> reject ( function ( ErrorInterface $ error ) { return is_null ( $ error -> getStatus ( ) ) ; } ) -> map ( function ( ErrorInterface $ error ) { return ( int ) $ error -> getStatus ( ) ; } ) -> unique ( ) ; if ( 2 > count ( $ statuses ) ) { return $ statuses -> first ( ) ? : $ default ; } $ only4xx = $ statuses -> every ( function ( int $ status ) { return 400 <= $ status && 499 >= $ status ; } ) ; return $ only4xx ? SymfonyResponse :: HTTP_BAD_REQUEST : SymfonyResponse :: HTTP_INTERNAL_SERVER_ERROR ; }
245	public function getColumn ( $ name ) { return isset ( $ this -> columns [ $ name ] ) ? $ this -> columns [ $ name ] : null ; }
12843	protected function addOptionShortcut ( $ name , $ description , $ default ) { $ this -> addOption ( $ name , null , InputOption :: VALUE_OPTIONAL , $ description , $ default ) ; return $ this ; }
2272	public static function quoteIdentifier ( $ strName ) { static $ strQuoteCharacter = null ; if ( $ strQuoteCharacter === null ) { $ strQuoteCharacter = System :: getContainer ( ) -> get ( 'database_connection' ) -> getDatabasePlatform ( ) -> getIdentifierQuoteCharacter ( ) ; } if ( strncmp ( $ strName , $ strQuoteCharacter , 1 ) === 0 ) { return $ strName ; } if ( ! preg_match ( '/^[A-Za-z0-9_$.]+$/' , $ strName ) ) { return $ strName ; } return System :: getContainer ( ) -> get ( 'database_connection' ) -> quoteIdentifier ( $ strName ) ; }
369	public function getViewNames ( $ schema = '' , $ refresh = false ) { if ( ! isset ( $ this -> _viewNames [ $ schema ] ) || $ refresh ) { $ this -> _viewNames [ $ schema ] = $ this -> findViewNames ( $ schema ) ; } return $ this -> _viewNames [ $ schema ] ; }
7146	public function save_custom_profile_fields ( $ user_id ) { if ( 'POST' !== $ _SERVER [ 'REQUEST_METHOD' ] || ! isset ( $ _POST [ 'iac_nonce' ] ) ) { return ; } if ( ! wp_verify_nonce ( $ _POST [ 'iac_nonce' ] , 'iac_user_settings' ) ) { return ; } do_action ( 'iac_save_user_settings' , $ user_id , isset ( $ _POST [ 'post_subscription' ] ) ? $ _POST [ 'post_subscription' ] : NULL , isset ( $ _POST [ 'comment_subscription' ] ) ? $ _POST [ 'comment_subscription' ] : NULL ) ; }
8820	public function getClientIP ( ) { $ ip = null ; $ client = $ this -> server ( 'HTTP_CLIENT_IP' ) ; $ forward = $ this -> server ( 'HTTP_X_FORWARDED_FOR' ) ; $ remote = $ this -> server ( 'REMOTE_ADDR' ) ; if ( filter_var ( $ client , FILTER_VALIDATE_IP ) ) { $ ip = $ client ; } elseif ( filter_var ( $ forward , FILTER_VALIDATE_IP ) ) { $ ip = $ forward ; } else { $ ip = $ remote ; } return $ ip ; }
3410	public function runCommand ( string $ command , array $ options , InputInterface $ current , OutputInterface $ output ) : int { array_unshift ( $ options , $ command ) ; $ input = new ArrayInput ( $ options ) ; if ( ! $ current -> isInteractive ( ) ) { $ input -> setInteractive ( false ) ; } $ command = $ this -> get ( $ command ) ; return $ this -> doRunCommand ( $ command , $ input , $ output ) ; }
1243	private static function actualValue ( array $ info , $ value ) { if ( is_object ( $ value ) ) { return $ value ; } $ types = explode ( '|' , $ info [ 'type' ] ) ; foreach ( $ types as $ type ) { switch ( $ type ) { case 'integer' : case 'string' : case 'double' : case 'boolean' : case 'any' : return $ value ; case 'DateTime' : return new \ DateTime ( $ value , new \ DateTimeZone ( 'UTC' ) ) ; } } return new $ info [ 'type' ] ( $ value ) ; }
10215	protected function scanElementForText ( \ DOMNode $ element ) { $ str = '' ; foreach ( $ element -> childNodes as $ child ) { if ( $ child -> nodeType == XML_TEXT_NODE ) { $ str .= $ child -> nodeValue ; } elseif ( $ child -> nodeType == XML_ELEMENT_NODE && $ child -> nodeName == 'text:s' ) { $ cAttr = $ child -> attributes -> getNamedItem ( 'c' ) ; if ( $ cAttr ) { $ multiplier = ( int ) $ cAttr -> nodeValue ; } else { $ multiplier = 1 ; } $ str .= str_repeat ( ' ' , $ multiplier ) ; } if ( $ child -> hasChildNodes ( ) ) { $ str .= $ this -> scanElementForText ( $ child ) ; } } return $ str ; }
12900	public function offsetGet ( $ offset ) { if ( $ offset === 'headers' ) { $ headers = [ 'HTTP/' . $ this -> getResponse ( ) -> getProtocolVersion ( ) . ' ' . $ this -> getResponse ( ) -> getStatusCode ( ) . ' ' . $ this -> getResponse ( ) -> getReasonPhrase ( ) ] ; foreach ( $ this -> getResponse ( ) -> getHeaders ( ) as $ header => $ values ) { foreach ( $ values as $ value ) { $ headers [ ] = $ header . ': ' . $ value ; } } return $ headers ; } }
5125	public function serve ( ) { foreach ( $ this -> dispatchers as $ dispatcher ) { if ( $ dispatcher -> canServe ( ) ) { ContainerScope :: runScope ( $ this -> container , [ $ dispatcher , 'serve' ] ) ; return ; } } throw new BootException ( "Unable to locate active dispatcher." ) ; }
274	public function renderDataCell ( $ model , $ key , $ index ) { if ( $ this -> contentOptions instanceof Closure ) { $ options = call_user_func ( $ this -> contentOptions , $ model , $ key , $ index , $ this ) ; } else { $ options = $ this -> contentOptions ; } return Html :: tag ( 'td' , $ this -> renderDataCellContent ( $ model , $ key , $ index ) , $ options ) ; }
5355	protected function getClassFromOperation ( $ name , Operation $ operation = null , $ reference , $ registry ) { if ( $ operation === null ) { return ; } if ( $ operation -> getParameters ( ) ) { foreach ( $ operation -> getParameters ( ) as $ key => $ parameter ) { if ( $ parameter instanceof BodyParameter ) { $ this -> chainGuesser -> guessClass ( $ parameter -> getSchema ( ) , $ name . 'Body' , $ reference . '/parameters/' . $ key , $ registry ) ; } } } if ( $ operation -> getResponses ( ) ) { foreach ( $ operation -> getResponses ( ) as $ status => $ response ) { if ( $ response instanceof Response ) { $ this -> chainGuesser -> guessClass ( $ response -> getSchema ( ) , $ name . 'Response' . $ status , $ reference . '/responses/' . $ status , $ registry ) ; } } } }
7755	private function doDeserialize ( $ data , $ entity ) { $ metadata = $ this -> hydraApi -> getMetadataFor ( get_class ( $ entity ) ) ; if ( null === $ metadata ) { throw new \ Exception ( sprintf ( '"%s" cannot be serialized as it is not documented.' , get_class ( $ data ) ) ) ; } $ vocabPrefix = $ this -> router -> generate ( 'hydra_vocab' , array ( ) , true ) . '#' ; $ typeIri = ( $ metadata -> isExternalReference ( ) ) ? $ metadata -> getIri ( ) : $ vocabPrefix . $ metadata -> getIri ( ) ; $ graph = JsonLD :: getDocument ( $ data ) -> getGraph ( ) ; $ node = $ graph -> getNodesByType ( $ typeIri ) ; if ( 1 !== count ( $ node ) ) { throw new RuntimeException ( 'The passed data contains ' . count ( $ node ) . ' nodes of the type ' . $ typeIri . '; expected 1.' ) ; } $ node = reset ( $ node ) ; foreach ( $ metadata -> getProperties ( ) as $ property ) { if ( $ property -> isReadOnly ( ) ) { continue ; } if ( null !== ( $ route = $ property -> getRoute ( ) ) ) { continue ; } $ propertyIri = ( $ property -> isExternalReference ( ) ) ? $ property -> getIri ( ) : $ vocabPrefix . $ property -> getIri ( ) ; $ value = $ node -> getProperty ( $ propertyIri ) ; if ( $ value instanceof \ ML \ JsonLD \ Value ) { $ value = $ value -> getValue ( ) ; } if ( ! is_null ( $ value ) && $ this -> hydraApi -> hasNormalizer ( $ property -> getType ( ) ) ) { $ normalizer = $ this -> hydraApi -> getNormalizer ( $ property -> getType ( ) ) ; $ value = $ normalizer -> denormalize ( $ value , $ property -> getType ( ) ) ; } $ property -> setValue ( $ entity , $ value ) ; } return $ entity ; }
7584	protected function extractResponse ( $ curlResponse ) { $ this -> headers = substr ( $ curlResponse , 0 , $ this -> info [ 'header_size' ] ) ; $ this -> body = substr ( $ curlResponse , $ this -> info [ 'header_size' ] ) ; }
9852	public function setPath ( $ pValue , $ pVerifyFile = true ) { if ( $ pVerifyFile ) { if ( file_exists ( $ pValue ) ) { $ this -> path = $ pValue ; if ( $ this -> width == 0 && $ this -> height == 0 ) { list ( $ this -> width , $ this -> height ) = getimagesize ( $ pValue ) ; } } else { throw new PhpSpreadsheetException ( "File $pValue not found!" ) ; } } else { $ this -> path = $ pValue ; } return $ this ; }
9860	private static function getInt4d ( $ data , $ pos ) { if ( trim ( $ data ) == '' ) { throw new ReaderException ( 'Parameter data is empty.' ) ; } elseif ( $ pos < 0 ) { throw new ReaderException ( 'Parameter pos=' . $ pos . ' is invalid.' ) ; } $ len = strlen ( $ data ) ; if ( $ len < $ pos + 4 ) { $ data .= str_repeat ( "\0" , $ pos + 4 - $ len ) ; } $ _or_24 = ord ( $ data [ $ pos + 3 ] ) ; if ( $ _or_24 >= 128 ) { $ _ord_24 = - abs ( ( 256 - $ _or_24 ) << 24 ) ; } else { $ _ord_24 = ( $ _or_24 & 127 ) << 24 ; } return ord ( $ data [ $ pos ] ) | ( ord ( $ data [ $ pos + 1 ] ) << 8 ) | ( ord ( $ data [ $ pos + 2 ] ) << 16 ) | $ _ord_24 ; }
8950	private function addRouters ( ) { $ builder = $ this -> getContainerBuilder ( ) ; $ router = $ builder -> getDefinition ( 'router' ) ; $ routerFactories = array ( ) ; foreach ( $ builder -> findByTag ( self :: TAG_ROUTER ) as $ serviceName => $ priority ) { if ( is_bool ( $ priority ) ) { $ priority = 100 ; } $ routerFactories [ $ priority ] [ $ serviceName ] = $ serviceName ; } if ( ! empty ( $ routerFactories ) ) { krsort ( $ routerFactories , SORT_NUMERIC ) ; foreach ( $ routerFactories as $ priority => $ items ) { $ routerFactories [ $ priority ] = $ items ; } foreach ( $ routerFactories as $ priority => $ items ) { foreach ( $ items as $ serviceName ) { $ factory = new Nette \ DI \ Statement ( array ( '@' . $ serviceName , 'createRouter' ) ) ; $ router -> addSetup ( 'offsetSet' , array ( NULL , $ factory ) ) ; } } } }
10080	public static function getCurrencyCode ( ) { if ( ! empty ( self :: $ currencyCode ) ) { return self :: $ currencyCode ; } self :: $ currencyCode = '$' ; $ localeconv = localeconv ( ) ; if ( ! empty ( $ localeconv [ 'currency_symbol' ] ) ) { self :: $ currencyCode = $ localeconv [ 'currency_symbol' ] ; return self :: $ currencyCode ; } if ( ! empty ( $ localeconv [ 'int_curr_symbol' ] ) ) { self :: $ currencyCode = $ localeconv [ 'int_curr_symbol' ] ; return self :: $ currencyCode ; } return self :: $ currencyCode ; }
4829	public function cancel ( ) { $ endpoint = self :: $ endpoint . '/' . $ this -> id . '/cancel' ; return new self ( $ this -> client , $ this -> client -> request ( 'put' , $ endpoint ) ) ; }
4935	private function triggerEvent ( $ name , EntityInterface $ entity ) { $ params = $ this -> options ; $ params [ 'entity' ] = $ entity ; $ params [ 'repositories' ] = $ this -> repositories ; $ event = $ this -> entityEraserEvents -> getEvent ( $ name , $ this , $ params ) ; $ this -> entityEraserEvents -> triggerEvent ( $ event ) ; $ dependencies = $ event -> getDependencyResultCollection ( ) ; return $ dependencies ; }
11196	public function __isset ( $ name ) { $ value = $ this -> find ( $ name ) ; if ( $ value !== null && ! ( $ value instanceof \ Exception ) ) { return true ; } return false ; }
5515	public function expectAtLeastOnce ( $ method , $ args = false , $ message = '%s' ) { $ this -> expectMinimumCallCount ( $ method , 1 , $ message ) ; if ( $ args !== false ) { $ this -> expect ( $ method , $ args , $ message ) ; } }
544	public function export ( ) { $ logPath = dirname ( $ this -> logFile ) ; FileHelper :: createDirectory ( $ logPath , $ this -> dirMode , true ) ; $ text = implode ( "\n" , array_map ( [ $ this , 'formatMessage' ] , $ this -> messages ) ) . "\n" ; if ( ( $ fp = @ fopen ( $ this -> logFile , 'a' ) ) === false ) { throw new InvalidConfigException ( "Unable to append to log file: {$this->logFile}" ) ; } @ flock ( $ fp , LOCK_EX ) ; if ( $ this -> enableRotation ) { clearstatcache ( ) ; } if ( $ this -> enableRotation && @ filesize ( $ this -> logFile ) > $ this -> maxFileSize * 1024 ) { @ flock ( $ fp , LOCK_UN ) ; @ fclose ( $ fp ) ; $ this -> rotateFiles ( ) ; $ writeResult = @ file_put_contents ( $ this -> logFile , $ text , FILE_APPEND | LOCK_EX ) ; if ( $ writeResult === false ) { $ error = error_get_last ( ) ; throw new LogRuntimeException ( "Unable to export log through file!: {$error['message']}" ) ; } $ textSize = strlen ( $ text ) ; if ( $ writeResult < $ textSize ) { throw new LogRuntimeException ( "Unable to export whole log through file! Wrote $writeResult out of $textSize bytes." ) ; } } else { $ writeResult = @ fwrite ( $ fp , $ text ) ; if ( $ writeResult === false ) { $ error = error_get_last ( ) ; throw new LogRuntimeException ( "Unable to export log through file!: {$error['message']}" ) ; } $ textSize = strlen ( $ text ) ; if ( $ writeResult < $ textSize ) { throw new LogRuntimeException ( "Unable to export whole log through file! Wrote $writeResult out of $textSize bytes." ) ; } @ flock ( $ fp , LOCK_UN ) ; @ fclose ( $ fp ) ; } if ( $ this -> fileMode !== null ) { @ chmod ( $ this -> logFile , $ this -> fileMode ) ; } }
7847	public function info ( int $ id ) : ? array { $ this -> checkConfig ( ) ; $ key = sprintf ( 'smsgatewayme.info.%s' , $ id ) ; if ( $ this -> cache === true and Cache :: has ( $ key ) ) { $ message = [ 'code' => 200 , 'message' => 'OK' , 'data' => Cache :: get ( $ key ) , ] ; } else { $ response = Request :: get ( $ this -> baseUrl . 'message/' . $ id ) ; if ( $ response -> code == 200 ) { Cache :: put ( $ key , $ response -> body , 3600 * 24 ) ; } else { if ( ! empty ( $ response -> body -> message ) ) { Log :: error ( $ response -> body -> message ) ; } } $ message = [ 'code' => $ response -> code , 'message' => ( $ response -> code == 200 ) ? 'OK' : $ response -> body -> message ?? '' , 'data' => $ response -> body , ] ; } return $ message ; }
11966	public function renderSlots ( Page $ page , array $ slots , array $ options = array ( ) ) { $ renderedSlots = array ( ) ; $ slots = $ this -> dispatchSlotsEvent ( RenderEvents :: SLOTS_RENDERING , $ page , $ slots ) ; foreach ( $ slots as $ slotName => $ slot ) { if ( is_string ( $ slot ) ) { $ renderedSlots [ $ slotName ] = $ slot ; continue ; } if ( ! $ slot instanceof Slot ) { continue ; } $ renderedSlots [ $ slotName ] = implode ( "" , $ this -> renderSlot ( $ slot ) ) ; } $ this -> mediaFiles = array_unique ( $ this -> mediaFiles ) ; return $ this -> dispatchSlotsEvent ( RenderEvents :: SLOTS_RENDERED , $ page , $ renderedSlots ) ; }
5053	public function setResponse ( Response $ response ) { $ this -> setParam ( 'response' , $ response ) ; $ this -> response = $ response ; return $ this ; }
6473	private function compareAcceptCharsetHeaders ( AcceptCharsetHeaderValue $ a , AcceptCharsetHeaderValue $ b ) : int { $ aQuality = $ a -> getQuality ( ) ; $ bQuality = $ b -> getQuality ( ) ; if ( $ aQuality < $ bQuality ) { return 1 ; } if ( $ aQuality > $ bQuality ) { return - 1 ; } $ aValue = $ a -> getCharset ( ) ; $ bValue = $ b -> getCharset ( ) ; if ( $ aValue === '*' ) { if ( $ bValue === '*' ) { return 0 ; } return 1 ; } if ( $ bValue === '*' ) { return - 1 ; } return 0 ; }
6219	public function getPeriodEnd ( ) { if ( is_null ( $ this -> parsedPeriodEnd ) ) { $ this -> parsedPeriodEnd = strtotime ( $ this -> periodEnd ) ; } return $ this -> parsedPeriodEnd ; }
4842	public static function generate_query_string ( $ params , & $ pairs = array ( ) , $ namespace = null ) { if ( is_array ( $ params ) ) { foreach ( $ params as $ k => $ v ) { if ( is_int ( $ k ) ) { GoCardless_Utils :: generate_query_string ( $ v , $ pairs , $ namespace . '[]' ) ; } else { GoCardless_Utils :: generate_query_string ( $ v , $ pairs , $ namespace !== null ? $ namespace . "[$k]" : $ k ) ; } } if ( $ namespace !== null ) { return $ pairs ; } if ( empty ( $ pairs ) ) { return '' ; } usort ( $ pairs , array ( __CLASS__ , 'sortPairs' ) ) ; $ strs = array ( ) ; foreach ( $ pairs as $ pair ) { $ strs [ ] = $ pair [ 0 ] . '=' . $ pair [ 1 ] ; } return implode ( '&' , $ strs ) ; } else { $ pairs [ ] = array ( rawurlencode ( $ namespace ) , rawurlencode ( $ params ) ) ; } }
7598	public function render ( $ sGlyphicon , array $ aGlyphiconAttributes = null ) { if ( ! is_scalar ( $ sGlyphicon ) ) { throw new InvalidArgumentException ( 'Glyphicon expects a scalar value, "' . gettype ( $ sGlyphicon ) . '" given' ) ; } if ( empty ( $ aGlyphiconAttributes ) ) { $ aGlyphiconAttributes = array ( 'class' => 'glyphicon' ) ; } else { if ( empty ( $ aGlyphiconAttributes [ 'class' ] ) ) { $ aGlyphiconAttributes [ 'class' ] = 'glyphicon' ; } elseif ( ! preg_match ( '/(\s|^)glyphicon(\s|$)/' , $ aGlyphiconAttributes [ 'class' ] ) ) { $ aGlyphiconAttributes [ 'class' ] .= ' glyphicon' ; } } if ( strpos ( 'glyphicon-' , $ sGlyphicon ) !== 0 ) { $ sGlyphicon = 'glyphicon-' . $ sGlyphicon ; } if ( ! preg_match ( '/(\s|^)' . preg_quote ( $ sGlyphicon , '/' ) . '(\s|$)/' , $ aGlyphiconAttributes [ 'class' ] ) ) { $ aGlyphiconAttributes [ 'class' ] .= ' ' . $ sGlyphicon ; } return sprintf ( static :: $ glyphiconFormat , $ this -> createAttributesString ( $ aGlyphiconAttributes ) ) ; }
9540	private function getParameterClosure ( $ parameter ) { $ parameterClosure = null ; foreach ( array_keys ( $ this -> parameterCluster -> prefixes ) as $ prefix ) { if ( substr ( $ parameter , 0 , strlen ( $ prefix ) ) == $ prefix ) { @ $ parameterClosure = $ this -> parameterCluster -> prefixes [ $ prefix ] [ substr ( $ parameter , strlen ( $ prefix ) , strlen ( $ parameter ) - strlen ( $ prefix ) ) ] ; } } return $ parameterClosure ; }
1598	protected function validateAllFields ( ) : bool { $ duplicates = collect ( ( array ) $ this -> dataGet ( 'attributes' , [ ] ) ) -> intersectByKeys ( ( array ) $ this -> dataGet ( 'relationships' , [ ] ) ) -> keys ( ) ; $ this -> resourceFieldsExistInAttributesAndRelationships ( $ duplicates ) ; return $ duplicates -> isEmpty ( ) ; }
5665	private function innerHtml ( $ node ) { $ raw = '' ; if ( $ node -> hasChildren ( ) ) { foreach ( $ node -> child as $ child ) { $ raw .= $ child -> value ; } } return $ this -> stripGuards ( $ raw ) ; }
876	private function isCommentWithFixableIndentation ( Tokens $ tokens , $ index ) { if ( ! $ tokens [ $ index ] -> isComment ( ) ) { return false ; } if ( 0 === strpos ( $ tokens [ $ index ] -> getContent ( ) , '/*' ) ) { return true ; } $ firstCommentIndex = $ index ; while ( true ) { $ i = $ this -> getSiblingContinuousSingleLineComment ( $ tokens , $ firstCommentIndex , false ) ; if ( null === $ i ) { break ; } $ firstCommentIndex = $ i ; } $ lastCommentIndex = $ index ; while ( true ) { $ i = $ this -> getSiblingContinuousSingleLineComment ( $ tokens , $ lastCommentIndex , true ) ; if ( null === $ i ) { break ; } $ lastCommentIndex = $ i ; } if ( $ firstCommentIndex === $ lastCommentIndex ) { return true ; } for ( $ i = $ firstCommentIndex + 1 ; $ i < $ lastCommentIndex ; ++ $ i ) { if ( ! $ tokens [ $ i ] -> isWhitespace ( ) && ! $ tokens [ $ i ] -> isComment ( ) ) { return false ; } } return true ; }
11230	public function get ( $ section , array $ params = [ ] , $ headers = [ ] ) { $ params = array_merge ( $ this -> parameters , $ params , $ this -> defaultParameters ) ; return $ this -> client -> get ( $ this -> getUrl ( $ section , $ params ) , $ headers ) ; }
4509	public function getContext ( ) : string { $ tenant = $ this -> parameterService -> get ( 'ds_tenant.tenant.default' ) ; $ request = $ this -> requestStack -> getCurrentRequest ( ) ; if ( $ request -> request -> has ( 'tenant' ) && $ request -> request -> get ( 'tenant' ) ) { $ tenant = $ request -> request -> get ( 'tenant' ) ; } if ( $ request -> query -> has ( 'tenant' ) && $ request -> query -> get ( 'tenant' ) ) { $ tenant = $ request -> query -> get ( 'tenant' ) ; } $ token = $ this -> tokenStorage -> getToken ( ) ; if ( $ token ) { $ user = $ token -> getUser ( ) ; if ( $ user instanceof User ) { $ tenant = $ user -> getTenant ( ) ; } } return $ tenant ; }
9314	public function storageClearAction ( ) { if ( ! $ this -> isConsoleRequest ( ) ) { throw new \ RuntimeException ( 'You can only use this action from a console!' ) ; } $ dbAdapter = $ this -> getDbAdapter ( ) ; $ console = $ this -> getConsole ( ) ; $ this -> printConsoleBanner ( $ console ) ; try { $ table = new JobTable ( $ dbAdapter ) ; $ table -> truncate ( ) ; } catch ( \ Exception $ exception ) { $ console -> writeLine ( 'Truncating database table failed!' , ConsoleColor :: LIGHT_RED ) ; return ; } $ console -> writeLine ( 'Storage was successfully cleared!' , ConsoleColor :: LIGHT_GREEN ) ; }
10873	public function cleanUser ( string $ validate = null ) : int { $ result = 0 ; if ( $ validate ) { $ validateTo = new DateTime ; $ validateTo -> modify ( $ validate ) ; $ list = $ this -> getList ( ) -> where ( [ $ this -> tableName [ 0 ] . '.active' => false , $ this -> tableName [ 0 ] . '.added IS NOT NULL' , [ $ this -> tableName [ 0 ] . '.added<=%dt' , $ validateTo ] , ] ) ; foreach ( $ list as $ item ) { if ( $ this -> delete ( $ item [ self :: COLUMN_ID ] ) ) { $ result ++ ; } } } return $ result ; }
11043	function is_space ( $ char ) { $ asc = ord ( $ char ) ; if ( $ asc == 32 ) { return TRUE ; } elseif ( $ asc > 8 && $ asc < 14 ) { return TRUE ; } return FALSE ; }
4432	protected function getRunner ( & $ errors ) { $ output = $ this -> output ; $ runner = function ( $ err ) use ( $ output , & $ errors ) { if ( ! empty ( $ err ) ) { $ output -> writeln ( '<fg=red>FAILED</>' ) ; $ errors = array_merge ( $ errors , $ err ) ; } else { $ output -> writeln ( '<info>OK</info>' ) ; } } ; return $ runner ; }
6404	public static function propagateIfInstanceOf ( Exception $ exception , string $ exceptionClass ) : void { if ( is_a ( $ exception , $ exceptionClass ) ) { throw $ exception ; } }
10551	public function determineVirtualHost ( ) { $ cfg = $ this -> config -> getSection ( 'site' ) ; $ vhost = self :: findVirtualHost ( $ this -> request -> webroot , $ this -> sites ) ; if ( $ vhost === null ) { $ result = $ this -> handleUnknownHost ( $ this -> request -> webroot , $ this -> request -> url , $ this -> sites , $ cfg ) ; if ( $ result === null ) throw new HTTPError ( 404 , "Not found: " . $ this -> url ) ; if ( $ result instanceof URL ) throw new RedirectRequest ( $ result , 301 ) ; if ( $ result instanceof VirtualHost ) { $ vhost = $ result ; $ site = $ vhost -> getSite ( ) ; if ( isset ( $ this -> sites [ $ site -> getName ( ) ] ) ) $ this -> sites [ $ site -> getName ( ) ] = $ site ; } else throw \ RuntimeException ( "Unexpected response from handleUnknownWebsite" ) ; } else { $ target = $ vhost -> getRedirect ( $ this -> request -> url ) ; if ( $ target ) throw new RedirectRequest ( $ target , 301 ) ; } $ this -> setVirtualHost ( $ vhost ) ; return $ this ; }
1952	public static function findBySourceParentAndEmail ( $ strSource , $ intParent , $ strEmail , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; return static :: findOneBy ( array ( "$t.source=? AND $t.parent=? AND $t.email=?" ) , array ( $ strSource , $ intParent , $ strEmail ) , $ arrOptions ) ; }
5812	public function onBeforeWrite ( ) { parent :: onBeforeWrite ( ) ; $ types = array ( ) ; foreach ( singleton ( 'FusionService' ) -> getFusionTagTypes ( ) as $ type => $ field ) { $ types [ $ type ] = $ type ; } $ types = array_intersect ( $ this -> owner -> many_many ( ) , $ types ) ; if ( empty ( $ types ) ) { $ tagging = array ( ) ; foreach ( $ this -> owner -> FusionTags ( ) as $ tag ) { $ tagging [ ] = $ tag -> Title ; } } else { $ this -> owner -> FusionTags ( ) -> removeAll ( ) ; $ tagging = array ( ) ; foreach ( $ types as $ relationship => $ type ) { foreach ( $ this -> owner -> $ relationship ( ) as $ tag ) { $ fusion = FusionTag :: get ( ) -> byID ( $ tag -> FusionTagID ) ; $ this -> owner -> FusionTags ( ) -> add ( $ fusion ) ; $ tagging [ ] = $ fusion -> Title ; } } } $ this -> owner -> Tagging = implode ( ' ' , $ tagging ) ; }
10372	public static function add_styles ( ) { self :: look_if_process_files ( 'style' ) ; foreach ( self :: $ data [ 'style' ] as $ data ) { wp_register_style ( $ data [ 'name' ] , $ data [ 'url' ] , $ data [ 'deps' ] , $ data [ 'version' ] , $ data [ 'media' ] ) ; wp_enqueue_style ( $ data [ 'name' ] ) ; } }
7017	private function formatG ( & $ str ) { if ( strstr ( $ str , '%G' ) ) $ str = str_replace ( '%G' , sprintf ( '%1d' , $ this -> hour ) , $ str ) ; }
12252	public function addMissing ( $ objStructure , & $ objElement ) { foreach ( $ objStructure -> attributes ( ) as $ strName => $ objAttribute ) { if ( ! isset ( $ objElement -> attributes ( ) -> $ strName ) ) { $ objElement -> addAttribute ( $ strName , ( string ) $ objAttribute ) ; } } foreach ( $ objStructure -> children ( ) as $ strName => $ varNode ) { if ( count ( $ varNode ) > 0 ) { $ objNode = $ objElement -> addChild ( $ strName ) ; $ this -> addMissing ( $ varNode , $ objNode ) ; } else { $ objElement -> addChild ( $ strName , ( string ) $ varNode ) ; } } }
11800	public function substitution ( $ search , $ replace ) { $ this -> body = str_replace ( $ search , $ replace , $ this -> body ) ; return $ this -> body ; }
9043	protected function logImpl ( $ level , $ message , array $ context = array ( ) ) { if ( ! $ this -> levelHasReached ( $ level ) ) { return ; } if ( $ this -> isRotationNeeded ( ) ) { unlink ( $ this -> file ) ; } $ ms = $ this -> getMessage ( $ level , $ message , $ context ) ; $ fos = new FileOutputStream ( $ this -> file , true ) ; $ fos -> write ( $ ms ) ; $ fos -> flush ( ) ; $ fos -> close ( ) ; }
4605	public function setEntityUuid ( ? string $ entityUuid ) { if ( null !== $ entityUuid ) { if ( ! preg_match ( '/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i' , $ entityUuid ) ) { throw new InvalidArgumentException ( 'Entity uuid is not valid.' ) ; } } $ this -> entityUuid = $ entityUuid ; return $ this ; }
7650	public function unlink ( $ path ) { $ this -> getStorageClient ( $ path ) -> deleteBlob ( $ this -> getContainerName ( $ path ) , $ this -> getFileName ( $ path ) ) ; clearstatcache ( true , $ path ) ; return true ; }
5178	public function filter ( \ Closure $ callback ) : self { $ collection = new static ( ) ; foreach ( $ this -> props as $ key => $ value ) { if ( $ callback ( $ value , $ key ) ) { $ collection -> add ( $ key , $ value ) ; } } return $ collection ; }
10171	function fromXML ( $ xmlElement ) { foreach ( $ xmlElement -> children ( ) as $ field ) { $ this -> custom_fields [ trim ( $ field -> name ) ] = $ field -> type ; } }
1547	public function registerCustom ( ) : void { if ( ! $ fn = $ this -> group ) { return ; } $ this -> router -> group ( [ ] , function ( ) use ( $ fn ) { $ fn ( new RouteRegistrar ( $ this -> router , [ 'controller' => $ this -> controller ( ) ] , [ self :: PARAM_RESOURCE_TYPE => $ this -> resourceType ] ) ) ; } ) ; }
9434	public function rho ( $ float_min , $ float_max ) { self :: checkOrder ( $ float_min , $ float_max ) ; if ( $ float_min < 0 || $ float_max < 0 ) { throw new \ InvalidArgumentException ( 'Rho value must be a positive number!' ) ; } if ( $ this -> r || $ this -> i ) { throw new \ RuntimeException ( 'You cannot set rho value, because algebraic form is in use.' ) ; } $ this -> rho = new \ stdClass ( ) ; $ this -> rho -> min = $ float_min ; $ this -> rho -> max = $ float_max ; return $ this ; }
8989	public function getTemplate ( $ data_type , $ type ) { $ options = ( array ) $ this -> config -> getType ( $ data_type , $ type ) ; return new UI \ Template ( $ data_type , $ type , $ options ) ; }
10271	function addAttachment ( $ mailingId , $ filename , $ contentType , $ contents ) { $ queryParameters = array ( 'filename' => $ filename ) ; return $ this -> post ( "mailings/${mailingId}/attachments" , $ contents , $ queryParameters , null , null , $ contentType , strlen ( $ contents ) ) ; }
2576	protected function mergeOptions ( $ existingOptions , $ newOptions ) { if ( ! empty ( $ newOptions ) ) { $ existingOptions = array_merge ( $ existingOptions , $ newOptions ) ; } return $ existingOptions ; }
411	private function utf8Encode ( $ s ) { $ s .= $ s ; $ len = \ strlen ( $ s ) ; for ( $ i = $ len >> 1 , $ j = 0 ; $ i < $ len ; ++ $ i , ++ $ j ) { switch ( true ) { case $ s [ $ i ] < "\x80" : $ s [ $ j ] = $ s [ $ i ] ; break ; case $ s [ $ i ] < "\xC0" : $ s [ $ j ] = "\xC2" ; $ s [ ++ $ j ] = $ s [ $ i ] ; break ; default : $ s [ $ j ] = "\xC3" ; $ s [ ++ $ j ] = \ chr ( \ ord ( $ s [ $ i ] ) - 64 ) ; break ; } } return substr ( $ s , 0 , $ j ) ; }
6014	public function retrieveProtocol ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/deployment/protocols/' . $ id . '' , $ parameters , $ cachePolicy ) ; $ result = new Protocol ( $ result ) ; return $ result ; }
6442	public function getAllResources ( $ name , $ full = false , array $ filters = [ ] , array $ fields = [ ] ) { $ this -> lastRequest = new Request ; $ this -> lastRequest -> setMode ( Request :: MODE_READ ) ; $ this -> lastRequest -> setResourceName ( $ name ) ; if ( $ full ) { $ this -> lastRequest -> enableFullResults ( ) ; } $ this -> lastRequest -> setFilters ( $ filters ) ; $ this -> lastRequest -> setFields ( $ fields ) ; $ data = [ ] ; $ page = 1 ; do { $ this -> lastRequest -> setCurrentPage ( $ page ) ; $ response = $ this -> proceed ( ) ; $ data = ArrayUtils :: merge ( $ data , $ response -> getData ( ) -> getData ( ) ) ; $ page ++ ; } while ( $ response -> getPagination ( ) -> getPage ( ) != $ response -> getPagination ( ) -> getPages ( ) ) ; return $ data ; }
2619	public function generateCid ( ) { return sprintf ( '%04x%04x-%04x-%04x-%04x-%04x%04x%04x' , mt_rand ( 0 , 0xffff ) , mt_rand ( 0 , 0xffff ) , mt_rand ( 0 , 0xffff ) , mt_rand ( 0 , 0x0fff ) | 0x4000 , mt_rand ( 0 , 0x3fff ) | 0x8000 , mt_rand ( 0 , 0xffff ) , mt_rand ( 0 , 0xffff ) , mt_rand ( 0 , 0xffff ) ) ; }
1383	protected function dataGet ( $ key , $ default = null ) { if ( ! isset ( $ this -> document -> data ) ) { return $ default ; } return data_get ( $ this -> document -> data , $ key , $ default ) ; }
8242	protected function handleLogin ( Request $ httpRequest ) { $ post = $ httpRequest -> request ; if ( ! $ post -> has ( "username" ) || ! $ post -> has ( "password" ) ) { return ; } if ( ! $ this -> picoAuth -> isValidCSRF ( $ post -> get ( "csrf_token" ) , self :: LOGIN_CSRF_ACTION ) ) { $ this -> picoAuth -> redirectToLogin ( null , $ httpRequest ) ; return ; } $ username = strtolower ( trim ( $ post -> get ( "username" ) ) ) ; $ password = new Password ( $ post -> get ( "password" ) ) ; if ( ! $ this -> limit -> action ( "login" , false , array ( "name" => $ username ) ) ) { $ this -> session -> addFlash ( "error" , $ this -> limit -> getError ( ) ) ; $ this -> picoAuth -> redirectToLogin ( null , $ httpRequest ) ; return ; } if ( ! $ this -> loginAttempt ( $ username , $ password ) ) { $ this -> logInvalidLoginAttempt ( $ username ) ; $ this -> limit -> action ( "login" , true , array ( "name" => $ username ) ) ; $ this -> session -> addFlash ( "error" , "Invalid username or password" ) ; $ this -> picoAuth -> redirectToLogin ( null , $ httpRequest ) ; return ; } else { $ userData = $ this -> storage -> getUserByName ( $ username ) ; if ( $ this -> needsPasswordRehash ( $ userData ) ) { $ this -> passwordRehash ( $ username , $ password ) ; } $ this -> login ( $ username , $ userData ) ; $ this -> picoAuth -> afterLogin ( ) ; } }
10382	protected static function save_external_file ( $ url , $ path ) { $ data = file_get_contents ( $ url ) ; return ( $ data && self :: save_file ( $ path , $ data ) ) ? $ data : '' ; }
9527	private function parseEvery ( ) { $ results = [ ] ; $ i = 0 ; while ( $ i < count ( $ this -> argv ) ) { $ parameter = $ this -> argv [ $ i ] ; if ( $ this -> parseSingle ( $ i , $ parameter , $ results ) === false ) { break ; } } return $ results ; }
8181	public function getDefaultStrategy ( $ name ) { if ( ! is_string ( $ this -> defaultStrategy ) && false !== $ this -> defaultStrategy ) { return call_user_func ( $ this -> defaultStrategy , $ name ) ; } return $ this -> defaultStrategy ; }
4411	public function process ( ContainerBuilder $ container ) { if ( ! $ container -> has ( 'netgen_admin_ui.menu_plugin.registry' ) ) { return ; } $ menuPluginRegistry = $ container -> findDefinition ( 'netgen_admin_ui.menu_plugin.registry' ) ; $ menuPlugins = $ container -> findTaggedServiceIds ( 'netgen_admin_ui.menu_plugin' ) ; $ flattenedMenuPlugins = array ( ) ; foreach ( $ menuPlugins as $ identifier => $ menuPlugin ) { $ flattenedMenuPlugins [ $ identifier ] = isset ( $ menuPlugin [ 0 ] [ 'priority' ] ) ? $ menuPlugin [ 0 ] [ 'priority' ] : 0 ; } arsort ( $ flattenedMenuPlugins ) ; foreach ( array_keys ( $ flattenedMenuPlugins ) as $ menuPlugin ) { $ menuPluginRegistry -> addMethodCall ( 'addMenuPlugin' , array ( new Reference ( $ menuPlugin ) ) ) ; } }
12280	protected function initTemplateAssetsManager ( ) { $ templateAssetsManager = $ this -> options [ "template_assets" ] ; $ pluginManager = $ this -> options [ "plugin_manager" ] ; $ templateAssetsManager -> backend ( ) -> add ( $ pluginManager -> getAssets ( ) ) ; return $ templateAssetsManager ; }
1521	public function processes ( StoreInterface $ store , FetchProcesses $ request ) { $ result = $ store -> queryRecords ( $ request -> getProcessType ( ) , $ request -> getEncodingParameters ( ) ) ; return $ this -> reply ( ) -> content ( $ result ) ; }
9451	protected function logDLStatDetails ( ) { $ pageId = $ GLOBALS [ 'objPage' ] -> id ; $ pageHost = \ Environment :: get ( 'host' ) ; if ( isset ( $ GLOBALS [ 'TL_CONFIG' ] [ 'dlstatdets' ] ) && ( bool ) $ GLOBALS [ 'TL_CONFIG' ] [ 'dlstatdets' ] === true ) { $ username = '' ; $ strCookie = 'FE_USER_AUTH' ; $ hash = sha1 ( session_id ( ) . ( ! $ GLOBALS [ 'TL_CONFIG' ] [ 'disableIpCheck' ] ? $ this -> IP : '' ) . $ strCookie ) ; if ( \ Input :: cookie ( $ strCookie ) == $ hash ) { $ qs = \ Database :: getInstance ( ) -> prepare ( "SELECT pid, tstamp, sessionID, ip FROM `tl_session` WHERE `hash`=? AND `name`=?" ) -> execute ( $ hash , $ strCookie ) ; if ( $ qs -> next ( ) && $ qs -> sessionID == session_id ( ) && ( $ GLOBALS [ 'TL_CONFIG' ] [ 'disableIpCheck' ] || $ qs -> ip == $ this -> IP ) && ( $ qs -> tstamp + $ GLOBALS [ 'TL_CONFIG' ] [ 'sessionTimeout' ] ) > time ( ) ) { $ qm = \ Database :: getInstance ( ) -> prepare ( "SELECT `username` FROM `tl_member` WHERE id=?" ) -> execute ( $ qs -> pid ) ; if ( $ qm -> next ( ) ) { $ username = $ qm -> username ; } } } \ Database :: getInstance ( ) -> prepare ( "INSERT INTO `tl_dlstatdets` %s" ) -> set ( array ( 'tstamp' => time ( ) , 'pid' => $ this -> _statId , 'ip' => $ this -> dlstatsAnonymizeIP ( ) , 'domain' => $ this -> dlstatsAnonymizeDomain ( ) , 'username' => $ username , 'page_host' => $ pageHost , 'page_id' => $ pageId , 'browser_lang' => $ this -> dlstatsGetLang ( ) ) ) -> execute ( ) ; } else { \ Database :: getInstance ( ) -> prepare ( "INSERT INTO `tl_dlstatdets` %s" ) -> set ( array ( 'tstamp' => time ( ) , 'pid' => $ this -> _statId ) ) -> execute ( ) ; } }
12033	function addDispatchAsyncMethod ( ) { $ methodGenerator = new MethodGenerator ( 'dispatchAsync' ) ; $ body = 'return $this->api->executeAsync($request, $this, $callable);' ; $ docBlock = $ this -> generateExecuteDocBlock ( 'Dispatch the request for this operation and process the response asynchronously. Allows you to modify the request before it is sent.' ) ; $ requestParameter = new ParameterGenerator ( 'request' , 'Amp\Artax\Request' ) ; $ methodGenerator -> setParameter ( $ requestParameter ) ; $ tag = createParamTag ( $ requestParameter , 'The request to be processed' ) ; $ docBlock -> setTag ( $ tag ) ; $ callableParameter = new ParameterGenerator ( 'callable' , 'callable' ) ; $ methodGenerator -> setParameter ( $ callableParameter ) ; $ callableTag = createParamTag ( $ callableParameter , 'The callable that processes the response' ) ; $ docBlock -> setTag ( $ callableTag ) ; $ methodGenerator -> setDocBlock ( $ docBlock ) ; $ methodGenerator -> setBody ( $ body ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; }
10800	public function renderPageHistoricTableAction ( ) { $ translator = $ this -> getServiceLocator ( ) -> get ( 'translator' ) ; $ melisKey = $ this -> params ( ) -> fromRoute ( 'melisKey' , '' ) ; $ melisTool = $ this -> getServiceLocator ( ) -> get ( 'MelisCoreTool' ) ; $ melisTool -> setMelisToolKey ( self :: PLUGIN_INDEX , self :: TOOL_KEY ) ; $ columns = $ melisTool -> getColumns ( ) ; $ idPage = $ this -> params ( ) -> fromRoute ( 'idPage' , $ this -> params ( ) -> fromQuery ( 'idPage' , '' ) ) ; $ container = new Container ( 'meliscore' ) ; $ locale = $ container [ 'melis-lang-locale' ] ; $ view = new ViewModel ( ) ; $ view -> melisKey = $ melisKey ; $ view -> tableColumns = $ columns ; $ view -> getToolDataTableConfig = $ melisTool -> getDataTableConfiguration ( '#tableHistoricPageId' . $ idPage , true ) ; $ view -> idPage = $ idPage ; $ view -> tableId = 'tableHistoricPageId' . $ idPage ; return $ view ; }
4336	private function closeOpenGroups ( ) { $ this -> data [ 'groupPriorityStack' ] [ ] = 'main' ; while ( $ this -> data [ 'groupPriorityStack' ] ) { $ priority = \ array_pop ( $ this -> data [ 'groupPriorityStack' ] ) ; foreach ( $ this -> data [ 'groupStacks' ] [ $ priority ] as $ i => $ info ) { if ( $ info [ 'collect' ] ) { unset ( $ this -> data [ 'groupStacks' ] [ $ priority ] [ $ i ] ) ; $ meta = array ( 'channel' => $ info [ 'channel' ] , ) ; if ( $ priority === 'main' ) { $ this -> data [ 'log' ] [ ] = array ( 'groupEnd' , array ( ) , $ meta ) ; } else { $ this -> data [ 'logSummary' ] [ $ priority ] [ ] = array ( 'groupEnd' , array ( ) , $ meta ) ; } } } } }
10436	public function channel ( string $ channel_id ) : LoggerChannelInterface { $ logger = $ this -> log_manager -> get ( $ channel_id ) ; if ( ! $ logger ) { return new NullLoggerChannel ( ) ; } return new CalgamoLoggerChannelAdapter ( $ logger ) ; }
849	public function getPrevTokenOfKind ( $ index , array $ tokens = [ ] , $ caseSensitive = true ) { return $ this -> getTokenOfKindSibling ( $ index , - 1 , $ tokens , $ caseSensitive ) ; }
2566	protected function checkAnyNotEmpty ( ) { $ foundNotEmpty = false ; $ args = func_get_args ( ) ; foreach ( $ args as $ arg ) { if ( ! empty ( $ arg ) ) { $ foundNotEmpty = true ; break ; } } return $ foundNotEmpty ; }
2494	protected function escapeExpressions ( $ string , $ allowWildcard = false ) { if ( $ allowWildcard ) { $ reservedCharacters = preg_quote ( '+-&|!(){}[]^"~?:\\ ' ) ; } else { $ reservedCharacters = preg_quote ( '+-&|!(){}[]^"~*?:\\ ' ) ; } return preg_replace_callback ( '/([' . $ reservedCharacters . '])/' , function ( $ matches ) { return '\\' . $ matches [ 0 ] ; } , $ string ) ; }
9021	public function getWordsByComplexity ( $ string ) { $ words = $ this -> getWords ( $ string ) ; $ analysis = new FrequencyAnalysis ( $ words ) ; $ sortedWords = $ analysis -> getKeyValuesByFrequency ( ) ; $ wordsByFrequency = array_unique ( array_keys ( $ sortedWords ) ) ; usort ( $ wordsByFrequency , function ( $ a , $ b ) { return strlen ( $ b ) - strlen ( $ a ) ; } ) ; return $ wordsByFrequency ; }
1414	public function resourceCannotBeDeleted ( string $ detail = null ) : ErrorInterface { return new Error ( null , null , Response :: HTTP_UNPROCESSABLE_ENTITY , $ this -> trans ( 'resource_cannot_be_deleted' , 'code' ) , $ this -> trans ( 'resource_cannot_be_deleted' , 'title' ) , $ detail ? : $ this -> trans ( 'resource_cannot_be_deleted' , 'detail' ) ) ; }
11371	public function destroy ( $ menuId = null ) { if ( $ menuId !== null ) { return $ this -> parseJSON ( 'json' , [ self :: API_CONDITIONAL_DELETE , [ 'menuid' => $ menuId ] ] ) ; } return $ this -> parseJSON ( 'get' , [ self :: API_DELETE ] ) ; }
1695	public function checkStyleSheetName ( $ strName ) { $ objStyleSheet = $ this -> Database -> prepare ( "SELECT COUNT(*) AS count FROM tl_style_sheet WHERE name=?" ) -> limit ( 1 ) -> execute ( $ strName ) ; if ( $ objStyleSheet -> count < 1 ) { return $ strName ; } $ chunks = explode ( '-' , $ strName ) ; $ i = ( \ count ( $ chunks ) > 1 ) ? array_pop ( $ chunks ) : 0 ; $ strName = implode ( '-' , $ chunks ) . '-' . ( ( int ) $ i + 1 ) ; return $ this -> checkStyleSheetName ( $ strName ) ; }
3799	private function checkModelWithoutVariants ( $ containedModel ) { $ parentDefinition = $ this -> environment -> getDataDefinition ( ) -> getBasicDefinition ( ) -> getParentDataProvider ( ) ; $ this -> disablePA = ( $ this -> currentModel -> getId ( ) == $ containedModel -> getId ( ) ) || ( $ parentDefinition && $ this -> currentModel -> getProperty ( 'pid' ) == $ containedModel -> getProperty ( 'pid' ) ) ; $ this -> disablePI = ( $ this -> circularReference ) || ( $ this -> currentModel -> getId ( ) == $ containedModel -> getId ( ) ) || ( $ parentDefinition && $ this -> currentModel -> getProperty ( 'pid' ) == $ containedModel -> getId ( ) ) ; }
1432	public function allow ( string ... $ params ) : self { $ this -> all = false ; foreach ( $ params as $ param ) { $ this -> allowed -> put ( $ param , $ param ) ; } return $ this ; }
8399	public function display ( Environment $ environment , $ template , $ type = null , $ size = 'md' , $ object = null ) { $ tools = $ environment -> render ( $ template , array ( 'type' => $ type , 'object' => $ object , ) ) ; return $ environment -> render ( '@c975LToolbar/toolbar.html.twig' , array ( 'tools' => $ tools , 'size' => $ size , ) ) ; }
3880	private function getJumpToLabel ( ) { $ tableName = $ this -> metaModel -> getTableName ( ) ; if ( isset ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ tableName ] [ $ this -> get ( 'id' ) ] [ 'details' ] ) ) { return $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ tableName ] [ $ this -> get ( 'id' ) ] [ 'details' ] ; } elseif ( isset ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ tableName ] [ 'details' ] ) ) { return $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ tableName ] [ 'details' ] ; } return $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'details' ] ; }
2491	private function configureSearchServices ( ContainerBuilder $ container , $ connectionName , $ connectionParams ) { $ alias = $ this -> getAlias ( ) ; $ endpointResolverDefinition = new DefinitionDecorator ( self :: ENDPOINT_RESOLVER_ID ) ; $ endpointResolverDefinition -> replaceArgument ( 0 , $ connectionParams [ 'entry_endpoints' ] ) ; $ endpointResolverDefinition -> replaceArgument ( 1 , $ connectionParams [ 'mapping' ] [ 'translations' ] ) ; $ endpointResolverDefinition -> replaceArgument ( 2 , $ connectionParams [ 'mapping' ] [ 'default' ] ) ; $ endpointResolverDefinition -> replaceArgument ( 3 , $ connectionParams [ 'mapping' ] [ 'main_translations' ] ) ; $ endpointResolverId = "$alias.connection.$connectionName.endpoint_resolver_id" ; $ container -> setDefinition ( $ endpointResolverId , $ endpointResolverDefinition ) ; $ coreFilterDefinition = new DefinitionDecorator ( self :: CORE_FILTER_ID ) ; $ coreFilterDefinition -> replaceArgument ( 0 , new Reference ( $ endpointResolverId ) ) ; $ coreFilterId = "$alias.connection.$connectionName.core_filter_id" ; $ container -> setDefinition ( $ coreFilterId , $ coreFilterDefinition ) ; $ gatewayDefinition = new DefinitionDecorator ( self :: GATEWAY_ID ) ; $ gatewayDefinition -> replaceArgument ( 1 , new Reference ( $ endpointResolverId ) ) ; $ gatewayId = "$alias.connection.$connectionName.gateway_id" ; $ container -> setDefinition ( $ gatewayId , $ gatewayDefinition ) ; }
4782	public function removeWidgetConfig ( string $ widgetId , array $ config = [ ] ) { foreach ( $ config as $ id => $ content ) { if ( isset ( $ this -> config [ $ widgetId ] [ $ id ] ) ) { unset ( $ this -> config [ $ widgetId ] [ $ id ] ) ; } } return $ this ; }
4641	private function buildCallback ( BuildInfo $ output ) { $ message = "" ; if ( $ output -> getError ( ) ) { $ this -> logger -> error ( sprintf ( "Error when creating job: %s\n" , $ output -> getError ( ) ) , array ( 'static' => false , 'static-id' => null ) ) ; return ; } if ( $ output -> getStream ( ) ) { $ message = $ output -> getStream ( ) ; } if ( $ output -> getStatus ( ) ) { $ message = $ output -> getStatus ( ) ; if ( $ output -> getProgress ( ) ) { $ message .= " " . $ output -> getProgress ( ) ; } } if ( ! $ output -> getId ( ) && ! preg_match ( '#\n#' , $ message ) ) { $ message .= "\n" ; } $ this -> logger -> debug ( $ message , array ( 'static' => $ output -> getId ( ) !== null , 'static-id' => $ output -> getId ( ) , ) ) ; }
11236	public function url ( $ url = null , $ append = '' ) { unset ( $ _POST ) ; unset ( $ _FILES ) ; header ( 'location: ' . $ this -> getRedirect ( $ url ) . $ append ) ; exit ; }
8575	public function setItemChargeList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ItemChargeList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
2316	protected function prepareResizeConfig ( ) { $ resizeConfig = new ResizeConfiguration ( ) ; $ resizeConfig -> setWidth ( $ this -> targetWidth ) ; $ resizeConfig -> setHeight ( $ this -> targetHeight ) ; $ resizeConfig -> setZoomLevel ( $ this -> zoomLevel ) ; if ( substr_count ( $ this -> resizeMode , '_' ) === 1 ) { $ resizeConfig -> setMode ( ResizeConfiguration :: MODE_CROP ) ; $ resizeConfig -> setZoomLevel ( 0 ) ; } else { try { $ resizeConfig -> setMode ( $ this -> resizeMode ) ; } catch ( \ InvalidArgumentException $ exception ) { $ resizeConfig -> setMode ( ResizeConfiguration :: MODE_CROP ) ; } } return $ resizeConfig ; }
10603	public function checkQuery ( $ name ) { $ parts = explode ( '&' , $ this -> _urlParts [ 'query' ] ) ; foreach ( $ parts as $ p ) { $ paramData = explode ( '=' , $ p ) ; if ( $ paramData [ 0 ] === $ name ) { return true ; } } return false ; }
1859	public function copy ( $ strSource , $ strDestination ) { $ this -> validate ( $ strSource , $ strDestination ) ; return copy ( $ this -> strRootDir . '/' . $ strSource , $ this -> strRootDir . '/' . $ strDestination ) ; }
7987	public function setSnapshotProperties ( $ domain , array $ properties ) { $ domain = ( string ) $ domain ; if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; if ( ! $ properties || ! is_array ( $ properties ) || count ( $ properties ) == 0 ) throw new BadMethodCallException ( 'Parameter $properties must be a non empty array.' ) ; $ qr = '' ; foreach ( $ properties as $ k => $ v ) { $ qr .= $ k . '=' . $ v . '&' ; } $ qr = substr ( $ qr , 0 , strlen ( $ qr ) - 1 ) ; try { $ r = $ this -> put ( 'vps/' . $ domain . '/snapshot/?' . $ qr ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new VpsException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r ; }
9310	protected function doPostAction ( $ uri , array $ data = [ ] ) { $ this -> setActionUri ( $ uri ) ; try { $ response = $ this -> client -> post ( $ this -> uri , [ 'json' => $ data ] ) ; } catch ( ClientException $ e ) { $ response = $ e -> getResponse ( ) ; } catch ( ServerException $ e ) { $ response = $ e -> getResponse ( ) ; } return $ this -> responseToJson ( $ response ) ; }
7116	public function watch ( Repository \ PaymentRepositoryInterface $ paymentRepository ) { if ( null === $ term = $ this -> termRepository -> findLongest ( ) ) { return false ; } $ today = new \ DateTime ( ) ; $ today -> setTime ( 0 , 0 , 0 ) ; $ fromDate = clone $ today ; $ fromDate -> modify ( '-1 year' ) ; $ states = [ Model \ PaymentStates :: STATE_AUTHORIZED , Model \ PaymentStates :: STATE_CAPTURED ] ; $ method = $ this -> methodRepository -> findOneBy ( [ 'factoryName' => Constants :: FACTORY_NAME , ] ) ; if ( ! $ method || ! $ method -> isOutstanding ( ) ) { return false ; } $ result = false ; $ payments = $ paymentRepository -> findByMethodAndStates ( $ method , $ states , $ fromDate ) ; foreach ( $ payments as $ payment ) { $ sale = $ payment -> getSale ( ) ; if ( null === $ date = $ sale -> getOutstandingDate ( ) ) { continue ; } $ diff = $ date -> diff ( $ today ) ; if ( 0 < $ diff -> days && ! $ diff -> invert ) { $ payment -> setState ( Model \ PaymentStates :: STATE_EXPIRED ) ; $ this -> persist ( $ payment ) ; $ result = true ; } } return $ result ; }
12440	public function get ( $ key ) { if ( ! isset ( $ this -> instances [ $ key ] ) ) { throw new \ LogicException ( 'No instance for given key! (key: ' . $ key . ')' ) ; } return $ this -> instances [ $ key ] ; }
269	public function formatMessage ( $ message ) { list ( $ text , $ level , $ category , $ timestamp ) = $ message ; $ level = Logger :: getLevelName ( $ level ) ; if ( ! is_string ( $ text ) ) { if ( $ text instanceof \ Throwable || $ text instanceof \ Exception ) { $ text = ( string ) $ text ; } else { $ text = VarDumper :: export ( $ text ) ; } } $ traces = [ ] ; if ( isset ( $ message [ 4 ] ) ) { foreach ( $ message [ 4 ] as $ trace ) { $ traces [ ] = "in {$trace['file']}:{$trace['line']}" ; } } $ prefix = $ this -> getMessagePrefix ( $ message ) ; return $ this -> getTime ( $ timestamp ) . " {$prefix}[$level][$category] $text" . ( empty ( $ traces ) ? '' : "\n " . implode ( "\n " , $ traces ) ) ; }
3152	protected function onTimeout ( RunnerServiceContext $ context , AssessmentTestSessionException $ timeOutException ) { $ session = $ context -> getTestSession ( ) ; $ event = new TestTimeoutEvent ( $ session , $ timeOutException -> getCode ( ) , true ) ; $ this -> getServiceManager ( ) -> get ( EventManager :: SERVICE_ID ) -> trigger ( $ event ) ; $ isLinear = $ session -> getCurrentNavigationMode ( ) === NavigationMode :: LINEAR ; switch ( $ timeOutException -> getCode ( ) ) { case AssessmentTestSessionException :: ASSESSMENT_TEST_DURATION_OVERFLOW : \ common_Logger :: i ( 'TIMEOUT: closing the assessment test session' ) ; $ session -> endTestSession ( ) ; break ; case AssessmentTestSessionException :: TEST_PART_DURATION_OVERFLOW : if ( $ isLinear ) { \ common_Logger :: i ( 'TIMEOUT: moving to the next test part' ) ; $ session -> moveNextTestPart ( ) ; } else { \ common_Logger :: i ( 'TIMEOUT: closing the assessment test part' ) ; $ session -> closeTestPart ( ) ; } break ; case AssessmentTestSessionException :: ASSESSMENT_SECTION_DURATION_OVERFLOW : if ( $ isLinear ) { \ common_Logger :: i ( 'TIMEOUT: moving to the next assessment section' ) ; $ session -> moveNextAssessmentSection ( ) ; } else { \ common_Logger :: i ( 'TIMEOUT: closing the assessment section session' ) ; $ session -> closeAssessmentSection ( ) ; } break ; case AssessmentTestSessionException :: ASSESSMENT_ITEM_DURATION_OVERFLOW : if ( $ isLinear ) { \ common_Logger :: i ( 'TIMEOUT: moving to the next item' ) ; $ session -> moveNextAssessmentItem ( ) ; } else { \ common_Logger :: i ( 'TIMEOUT: closing the assessment item session' ) ; $ session -> closeAssessmentItem ( ) ; } break ; } $ event = new TestTimeoutEvent ( $ session , $ timeOutException -> getCode ( ) , false ) ; $ this -> getServiceManager ( ) -> get ( EventManager :: SERVICE_ID ) -> trigger ( $ event ) ; $ this -> continueInteraction ( $ context ) ; }
388	public function getAttributeOrder ( $ attribute ) { $ orders = $ this -> getAttributeOrders ( ) ; return isset ( $ orders [ $ attribute ] ) ? $ orders [ $ attribute ] : null ; }
8816	public function put ( $ key = null , $ filter = true ) { parse_str ( file_get_contents ( "php://input" ) , $ _PUT ) ; if ( $ key == null ) { return $ _PUT ; } return $ this -> filter ( $ _PUT [ $ key ] , $ filter ) ; }
815	private function fixAnnotation ( DocBlock $ doc , Annotation $ annotation ) { $ types = $ annotation -> getNormalizedTypes ( ) ; if ( 1 === \ count ( $ types ) && ( 'null' === $ types [ 0 ] || 'void' === $ types [ 0 ] ) ) { $ annotation -> remove ( ) ; } }
194	public function sendFile ( $ filePath , $ attachmentName = null , $ options = [ ] ) { if ( ! isset ( $ options [ 'mimeType' ] ) ) { $ options [ 'mimeType' ] = FileHelper :: getMimeTypeByExtension ( $ filePath ) ; } if ( $ attachmentName === null ) { $ attachmentName = basename ( $ filePath ) ; } $ handle = fopen ( $ filePath , 'rb' ) ; $ this -> sendStreamAsFile ( $ handle , $ attachmentName , $ options ) ; return $ this ; }
10789	protected function setSearchFacets ( SessionInterface $ session , $ facets ) { $ session -> set ( $ this -> getSessionPrefix ( ) . '_facets' , \ json_encode ( $ facets ) ) ; }
866	public function isType ( $ types ) { if ( ! \ is_array ( $ types ) ) { $ types = [ $ types ] ; } return \ in_array ( $ this -> getType ( ) , $ types , true ) ; }
6180	protected function write ( array $ record ) { $ severity = $ this -> getSeverity ( $ record [ 'level' ] ) ; if ( isset ( $ record [ 'context' ] [ 'exception' ] ) ) { $ this -> client -> notifyException ( $ record [ 'context' ] [ 'exception' ] , function ( \ Bugsnag \ Report $ report ) use ( $ record , $ severity ) { $ report -> setSeverity ( $ severity ) ; if ( isset ( $ record [ 'extra' ] ) ) { $ report -> setMetaData ( $ record [ 'extra' ] ) ; } } ) ; } else { $ this -> client -> notifyError ( ( string ) $ record [ 'message' ] , ( string ) $ record [ 'formatted' ] , function ( \ Bugsnag \ Report $ report ) use ( $ record , $ severity ) { $ report -> setSeverity ( $ severity ) ; if ( isset ( $ record [ 'extra' ] ) ) { $ report -> setMetaData ( $ record [ 'extra' ] ) ; } } ) ; } }
9867	private function writeMergeCells ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { if ( count ( $ pSheet -> getMergeCells ( ) ) > 0 ) { $ objWriter -> startElement ( 'mergeCells' ) ; foreach ( $ pSheet -> getMergeCells ( ) as $ mergeCell ) { $ objWriter -> startElement ( 'mergeCell' ) ; $ objWriter -> writeAttribute ( 'ref' , $ mergeCell ) ; $ objWriter -> endElement ( ) ; } $ objWriter -> endElement ( ) ; } }
5041	public function onBootstrap ( MvcEvent $ e ) { if ( ! DoctrineType :: hasType ( 'tz_date' ) ) { DoctrineType :: addType ( 'tz_date' , '\Core\Repository\DoctrineMongoODM\Types\TimezoneAwareDate' ) ; } $ sm = $ e -> getApplication ( ) -> getServiceManager ( ) ; $ translator = $ sm -> get ( 'translator' ) ; \ Zend \ Validator \ AbstractValidator :: setDefaultTranslator ( $ translator ) ; $ eventManager = $ e -> getApplication ( ) -> getEventManager ( ) ; $ sharedManager = $ eventManager -> getSharedManager ( ) ; if ( ! \ Zend \ Console \ Console :: isConsole ( ) ) { ( new ErrorHandlerListener ( ) ) -> attach ( $ eventManager ) ; $ languageRouteListener = new LanguageRouteListener ( $ sm -> get ( 'Core/Locale' ) , $ sm -> get ( 'Core/Options' ) ) ; $ languageRouteListener -> attach ( $ eventManager ) ; $ ajaxRenderListener = new AjaxRenderListener ( ) ; $ ajaxRenderListener -> attach ( $ eventManager ) ; $ ajaxRouteListener = $ sm -> get ( AjaxRouteListener :: class ) ; $ ajaxRouteListener -> attach ( $ eventManager ) ; $ xmlRenderListener = new XmlRenderListener ( ) ; $ xmlRenderListener -> attach ( $ eventManager ) ; $ enforceJsonResponseListener = new EnforceJsonResponseListener ( ) ; $ enforceJsonResponseListener -> attach ( $ eventManager ) ; $ stringListener = new StringListener ( ) ; $ stringListener -> attach ( $ eventManager ) ; } $ notificationListener = $ sm -> get ( 'Core/Listener/Notification' ) ; $ notificationListener -> attachShared ( $ sharedManager ) ; $ notificationAjaxHandler = new NotificationAjaxHandler ( ) ; $ eventManager -> attach ( MvcEvent :: EVENT_DISPATCH , array ( $ notificationAjaxHandler , 'injectView' ) , - 20 ) ; $ notificationListener -> attach ( NotificationEvent :: EVENT_NOTIFICATION_HTML , array ( $ notificationAjaxHandler , 'render' ) , - 20 ) ; $ eventManager -> attach ( MvcEvent :: EVENT_DISPATCH_ERROR , function ( $ event ) { if ( $ event instanceof MvcEvent ) { $ application = $ event -> getApplication ( ) ; if ( $ application :: ERROR_EXCEPTION == $ event -> getError ( ) ) { $ ex = $ event -> getParam ( 'exception' ) ; if ( 404 == $ ex -> getCode ( ) ) { $ event -> setError ( $ application :: ERROR_CONTROLLER_NOT_FOUND ) ; } } } } , 500 ) ; $ eventManager -> attach ( MvcEvent :: EVENT_DISPATCH , function ( $ event ) use ( $ eventManager ) { $ eventManager -> trigger ( 'postDispatch' , $ event ) ; } , - 150 ) ; $ sm -> get ( 'Tracy' ) -> startDebug ( ) ; }
12821	private function resolveDependencies ( callable $ callback , array $ vars ) : array { $ method = new \ ReflectionMethod ( $ callback [ 0 ] , $ callback [ 1 ] ) ; $ dependencies = [ ] ; foreach ( $ method -> getParameters ( ) as $ parameter ) { if ( $ parameter -> getClass ( ) === null && ! count ( $ vars ) ) { break ; } if ( $ parameter -> getClass ( ) === null && count ( $ vars ) ) { $ dependencies [ ] = array_shift ( $ vars ) ; continue ; } $ dependencies [ ] = $ this -> injector -> make ( $ parameter -> getClass ( ) -> name ) ; } return $ dependencies ; }
1822	public function adjustPermissions ( $ insertId ) { if ( \ func_num_args ( ) == 4 ) { $ insertId = func_get_arg ( 1 ) ; } if ( $ this -> User -> isAdmin ) { return ; } if ( empty ( $ this -> User -> imageSizes ) || ! \ is_array ( $ this -> User -> imageSizes ) ) { $ imageSizes = array ( ) ; } else { $ imageSizes = $ this -> User -> imageSizes ; } if ( \ in_array ( $ insertId , $ imageSizes ) ) { return ; } $ objSessionBag = Contao \ System :: getContainer ( ) -> get ( 'session' ) -> getBag ( 'contao_backend' ) ; $ arrNew = $ objSessionBag -> get ( 'new_records' ) ; if ( \ is_array ( $ arrNew [ 'tl_image_size' ] ) && \ in_array ( $ insertId , $ arrNew [ 'tl_image_size' ] ) ) { if ( $ this -> User -> inherit != 'custom' ) { $ objGroup = $ this -> Database -> execute ( "SELECT id, themes, imageSizes FROM tl_user_group WHERE id IN(" . implode ( ',' , array_map ( '\intval' , $ this -> User -> groups ) ) . ")" ) ; while ( $ objGroup -> next ( ) ) { $ arrThemes = Contao \ StringUtil :: deserialize ( $ objGroup -> themes ) ; if ( \ is_array ( $ arrThemes ) && \ in_array ( 'image_sizes' , $ arrThemes ) ) { $ arrImageSizes = Contao \ StringUtil :: deserialize ( $ objGroup -> imageSizes , true ) ; $ arrImageSizes [ ] = $ insertId ; $ this -> Database -> prepare ( "UPDATE tl_user_group SET imageSizes=? WHERE id=?" ) -> execute ( serialize ( $ arrImageSizes ) , $ objGroup -> id ) ; } } } if ( $ this -> User -> inherit != 'group' ) { $ objUser = $ this -> Database -> prepare ( "SELECT themes, imageSizes FROM tl_user WHERE id=?" ) -> limit ( 1 ) -> execute ( $ this -> User -> id ) ; $ arrThemes = Contao \ StringUtil :: deserialize ( $ objUser -> themes ) ; if ( \ is_array ( $ arrThemes ) && \ in_array ( 'image_sizes' , $ arrThemes ) ) { $ arrImageSizes = Contao \ StringUtil :: deserialize ( $ objUser -> imageSizes , true ) ; $ arrImageSizes [ ] = $ insertId ; $ this -> Database -> prepare ( "UPDATE tl_user SET imageSizes=? WHERE id=?" ) -> execute ( serialize ( $ arrImageSizes ) , $ this -> User -> id ) ; } } $ imageSizes [ ] = $ insertId ; $ this -> User -> imageSizes = $ imageSizes ; } }
7258	protected function mergeItemsResults ( Model \ SaleItemInterface $ item , Amount $ result ) : void { foreach ( $ item -> getChildren ( ) as $ child ) { if ( $ child -> isPrivate ( ) ) { continue ; } if ( ! ( $ child -> isCompound ( ) && ! $ child -> hasPrivateChildren ( ) ) ) { $ result -> merge ( $ child -> getResult ( ) ) ; } if ( $ child -> hasChildren ( ) ) { $ this -> mergeItemsResults ( $ child , $ result ) ; } } }
12151	public function getRelatedType ( $ name ) { list ( $ relationship , $ role ) = $ this -> getRelationship ( $ name ) ; if ( $ relationship ) { return $ relationship -> roleType ( $ role ) ; } return false ; }
9858	private function isValueInList ( Cell $ cell ) { $ cellValue = $ cell -> getValue ( ) ; $ dataValidation = $ cell -> getDataValidation ( ) ; $ formula1 = $ dataValidation -> getFormula1 ( ) ; if ( ! empty ( $ formula1 ) ) { if ( $ formula1 [ 0 ] === '"' ) { return in_array ( strtolower ( $ cellValue ) , explode ( ',' , strtolower ( trim ( $ formula1 , '"' ) ) ) , true ) ; } elseif ( strpos ( $ formula1 , ':' ) > 0 ) { $ matchFormula = '=MATCH(' . $ cell -> getCoordinate ( ) . ', ' . $ formula1 . ', 0)' ; $ calculation = Calculation :: getInstance ( $ cell -> getWorksheet ( ) -> getParent ( ) ) ; try { $ result = $ calculation -> calculateFormula ( $ matchFormula , $ cell -> getCoordinate ( ) , $ cell ) ; return $ result !== Functions :: NA ( ) ; } catch ( Exception $ ex ) { return false ; } } } return true ; }
9363	public function add ( $ z ) { if ( is_numeric ( $ z ) ) { $ z = new self ( $ z , 0 ) ; } return new self ( $ this -> float_r + $ z -> re , $ this -> float_i + $ z -> im ) ; }
9261	public function map ( $ route , $ name , $ handler , array $ methods = array ( 'GET' ) ) { foreach ( $ methods as $ method ) { if ( null === $ name ) { $ this -> addRoute ( $ method , $ route , $ handler ) ; } else { $ this -> addNamedRoute ( $ name , $ method , $ route , $ handler ) ; } } }
12677	public function approveRemoval ( $ sourceDir , array $ options , $ username ) { $ this -> init ( $ sourceDir , $ options , $ username ) ; $ targetFilename = sprintf ( '%s/blocks/%s.json' , $ this -> productionDir , $ options [ 'blockname' ] ) ; if ( ! file_exists ( $ targetFilename ) ) { return ; } Dispatcher :: dispatch ( BlockEvents :: BLOCK_APPROVING_REMOVAL , new BlockApprovingRemovalEvent ( $ this -> serializer , $ targetFilename ) ) ; $ this -> filesystem -> remove ( $ targetFilename ) ; $ slotDefinition = $ this -> getSlotDefinition ( $ this -> productionDir ) ; $ blocks = $ slotDefinition [ "blocks" ] ; $ key = array_search ( $ options [ 'blockname' ] , $ blocks ) ; unset ( $ blocks [ $ key ] ) ; $ slotDefinition [ "blocks" ] = $ blocks ; $ this -> saveSlotDefinition ( $ this -> productionDir , $ slotDefinition , $ username ) ; Dispatcher :: dispatch ( BlockEvents :: BLOCK_APPROVED_REMOVAL , new BlockApprovedRemovalEvent ( $ this -> serializer , $ targetFilename ) ) ; DataLogger :: log ( sprintf ( 'Block "%s" has been approved for removal on the "%s" slot on page "%s" for the "%s_%s" language' , $ options [ "blockname" ] , $ options [ "slot" ] , $ options [ "page" ] , $ options [ "language" ] , $ options [ "country" ] ) ) ; }
12823	protected function createContributorDir ( $ sourceDir , array $ options , $ username ) { if ( null === $ username ) { return ; } $ this -> init ( $ sourceDir , $ options , $ username ) ; if ( is_dir ( $ this -> contributorDir ) ) { return ; } $ this -> filesystem -> copy ( $ this -> productionDir . '/slot.json' , $ this -> contributorDir . '/slot.json' , true ) ; $ this -> filesystem -> mirror ( $ this -> productionDir . '/blocks' , $ this -> contributorDir . '/blocks' ) ; }
9744	public function setState ( $ state ) { if ( ! $ state ) { return $ this ; } if ( ! ( $ state instanceof State ) ) { $ state = new State ( $ state ) ; } if ( $ state -> isEmpty ( ) ) { $ this -> invalidArguments ( '10002' ) ; } return $ this -> setParameter ( 'state' , $ state ) ; }
12171	public static function getDefaultForClass ( $ class , array $ params = array ( ) ) { $ reflectionClass = new ReflectionClass ( $ class ) ; if ( ! $ reflectionClass -> isInstantiable ( ) ) { throw new NotInstantiableException ( "Class $class is not instantiable" ) ; } $ factory = new static ( [ $ reflectionClass , 'newInstance' ] , "$class::__construct" ) ; if ( $ reflectionClass -> hasMethod ( '__construct' ) ) { static :: addReflectionArguments ( $ factory , $ reflectionClass -> getMethod ( '__construct' ) ) ; } return $ factory -> getFactory ( $ params ) ; }
8897	public function insert_many ( $ data , $ insert_individual = false ) { if ( $ insert_individual ) { return $ this -> _insert_individual ( $ data ) ; } return $ this -> _insert_batch ( $ data ) ; }
159	public function having ( $ condition , $ params = [ ] ) { $ this -> having = $ condition ; $ this -> addParams ( $ params ) ; return $ this ; }
8714	public function whereSubQuery ( $ column , $ query , $ boolean = 'and' ) { list ( $ type , $ operator ) = [ 'Sub' , 'in' ] ; $ this -> wheres [ ] = compact ( 'type' , 'column' , 'operator' , 'query' , 'boolean' ) ; $ this -> addBinding ( $ query -> getBindings ( ) , 'where' ) ; return $ this ; }
3590	public function allowsMeta ( $ key ) { $ allowed = $ this -> getAllowedMeta ( ) ; return empty ( $ allowed ) || in_array ( $ key , $ allowed ) ; }
10729	public function getDay ( ) { if ( $ this -> value !== null ) { preg_match ( '/^(?P<year>[0-9]{4,4})-(?P<month>[0-9]{2,2})-(?P<day>[0-9]{2,2}) (?P<hour>[0-9]{2,2}):(?P<minute>[0-9]{2,2}):(?P<second>[0-9]{2,2})$/ui' , $ this -> value , $ m ) ; return ( int ) $ m [ 'day' ] ; } }
12497	public static function deleteMany ( array $ ids = array ( ) , $ connection ) { if ( ! is_array ( $ ids ) ) { throw new ClusterpointException ( "\"->deleteMany()\" function: \"_id\" is not in valid format." , 9002 ) ; } $ connection -> method = 'DELETE' ; $ connection -> action = '' ; foreach ( $ ids as & $ id ) { $ id = ( string ) $ id ; } $ connection -> query = json_encode ( $ ids ) ; return self :: sendQuery ( $ connection ) ; }
6873	protected function buildItem ( SaleItemInterface $ saleItem , ShipmentInterface $ shipment ) { if ( $ saleItem -> isCompound ( ) ) { $ available = $ expected = null ; foreach ( $ saleItem -> getChildren ( ) as $ childSaleItem ) { if ( null !== $ child = $ this -> buildItem ( $ childSaleItem , $ shipment ) ) { $ saleItemQty = $ childSaleItem -> getQuantity ( ) ; $ e = $ child -> getExpected ( ) / $ saleItemQty ; if ( null === $ expected || $ expected > $ e ) { $ expected = $ e ; } $ a = $ child -> getAvailable ( ) / $ saleItemQty ; if ( null === $ available || $ available > $ a ) { $ available = $ a ; } } } if ( 0 < $ expected ) { return $ this -> findOrCreateItem ( $ shipment , $ saleItem , $ expected , $ available ) ; } return null ; } $ item = null ; if ( ! ( $ saleItem -> isCompound ( ) && ! $ saleItem -> hasPrivateChildren ( ) ) ) { $ expected = $ shipment -> isReturn ( ) ? $ this -> calculator -> calculateReturnableQuantity ( $ saleItem , $ shipment ) : $ this -> calculator -> calculateShippableQuantity ( $ saleItem , $ shipment ) ; if ( 0 < $ expected ) { $ item = $ this -> findOrCreateItem ( $ shipment , $ saleItem , $ expected ) ; } } if ( $ saleItem -> hasChildren ( ) ) { foreach ( $ saleItem -> getChildren ( ) as $ childSaleItem ) { $ this -> buildItem ( $ childSaleItem , $ shipment ) ; } } return $ item ; }
5362	public function createContext ( Registry $ registry , $ name ) { $ schemas = array_values ( $ registry -> getSchemas ( ) ) ; foreach ( $ schemas as $ schema ) { $ openApiSpec = $ this -> schemaParser -> parseSchema ( $ schema -> getOrigin ( ) ) ; $ this -> chainGuesser -> guessClass ( $ openApiSpec , $ schema -> getRootName ( ) , $ schema -> getOrigin ( ) . '#' , $ registry ) ; $ schema -> setParsed ( $ openApiSpec ) ; } foreach ( $ registry -> getSchemas ( ) as $ schema ) { foreach ( $ schema -> getClasses ( ) as $ class ) { $ properties = $ this -> chainGuesser -> guessProperties ( $ class -> getObject ( ) , $ schema -> getRootName ( ) , $ class -> getReference ( ) , $ registry ) ; foreach ( $ properties as $ property ) { $ property -> setType ( $ this -> chainGuesser -> guessType ( $ property -> getObject ( ) , $ property -> getName ( ) , $ property -> getReference ( ) , $ registry ) ) ; } $ class -> setProperties ( $ properties ) ; } } return new Context ( $ registry ) ; }
2130	protected function markModified ( ) { if ( $ this -> blnIsModified === true ) { return ; } $ this -> blnIsModified = true ; $ this -> strTop = '' ; $ this -> strBottom = '' ; $ this -> Files = Files :: getInstance ( ) ; if ( static :: $ blnHasLcf ) { $ strMode = 'top' ; $ resFile = fopen ( $ this -> strRootDir . '/system/config/localconfig.php' , 'rb' ) ; while ( ! feof ( $ resFile ) ) { $ strLine = fgets ( $ resFile ) ; $ strTrim = trim ( $ strLine ) ; if ( $ strTrim == '?>' ) { continue ; } if ( $ strTrim == '### INSTALL SCRIPT START ###' ) { $ strMode = 'data' ; continue ; } if ( $ strTrim == '### INSTALL SCRIPT STOP ###' ) { $ strMode = 'bottom' ; continue ; } if ( $ strMode == 'top' ) { $ this -> strTop .= $ strLine ; } elseif ( $ strMode == 'bottom' ) { $ this -> strBottom .= $ strLine ; } elseif ( $ strTrim != '' ) { $ arrChunks = array_map ( 'trim' , explode ( '=' , $ strLine , 2 ) ) ; $ this -> arrData [ $ arrChunks [ 0 ] ] = $ arrChunks [ 1 ] ; } } fclose ( $ resFile ) ; } }
3738	private function getConnection ( ) { if ( $ this -> connection ) { return $ this -> connection ; } $ reflection = new \ ReflectionProperty ( \ Contao \ Database :: class , 'resConnection' ) ; $ reflection -> setAccessible ( true ) ; return $ this -> connection = $ reflection -> getValue ( $ this -> getDatabase ( ) ) ; }
1169	protected function purgeNonRemoteRules ( $ rules , $ validator ) { $ protectedValidator = $ this -> createProtectedCaller ( $ validator ) ; foreach ( $ rules as $ i => $ rule ) { $ parsedRule = ValidationRuleParser :: parse ( [ $ rule ] ) ; if ( ! $ this -> isRemoteRule ( $ parsedRule [ 0 ] ) ) { unset ( $ rules [ $ i ] ) ; } } return $ rules ; }
3635	public function httpMiddles ( Request $ request ) : array { $ dispatcher = \ bean ( 'serverDispatcher' ) ; $ middleType = ( int ) $ request -> query ( 'type' ) ; if ( $ middleType === 1 ) { return $ dispatcher -> getMiddlewares ( ) ; } return $ dispatcher -> requestMiddleware ( ) ; }
1417	public function failedValidator ( ValidatorContract $ validator , \ Closure $ closure = null ) : ErrorCollection { $ failed = $ this -> doesIncludeFailed ( ) ? $ validator -> failed ( ) : [ ] ; $ errors = new ErrorCollection ( ) ; foreach ( $ validator -> errors ( ) -> messages ( ) as $ key => $ messages ) { $ failures = $ this -> createValidationFailures ( $ failed [ $ key ] ?? [ ] ) ; foreach ( $ messages as $ detail ) { $ failed = $ failures -> shift ( ) ? : [ ] ; if ( $ closure ) { $ errors -> add ( $ this -> call ( $ closure , $ key , $ detail , $ failed ) ) ; continue ; } $ errors -> add ( new Error ( null , null , Response :: HTTP_UNPROCESSABLE_ENTITY , $ this -> trans ( 'failed_validator' , 'code' ) , $ this -> trans ( 'failed_validator' , 'title' ) , $ detail ? : $ this -> trans ( 'failed_validator' , 'detail' ) ) ) ; } } return $ errors ; }
3307	protected function buildRequestParam ( $ images , $ options = [ ] ) { if ( is_array ( $ images ) && ! empty ( $ images [ 0 ] ) ) { $ images = $ images [ 0 ] ; } if ( $ this -> supportUrl && FileConverter :: isUrl ( $ images ) ) { $ options [ 'url' ] = $ images ; } else { $ options [ 'image' ] = FileConverter :: toBase64Encode ( $ images ) ; } return $ options ; }
4986	public function executeAction ( $ name , array $ data = [ ] ) { if ( false !== strpos ( $ name , '.' ) ) { list ( $ name , $ childKey ) = explode ( '.' , $ name , 2 ) ; $ container = $ this -> getForm ( $ name ) ; return $ container -> executeAction ( $ childKey , $ data ) ; } return [ ] ; }
8330	public function connect ( array $ params , $ username = null , $ password = null , array $ driverOptions = [ ] ) { if ( PlatformHelper :: isWindows ( ) ) { return $ this -> connectWindows ( $ params , $ username , $ password , $ driverOptions ) ; } return $ this -> connectUnix ( $ params , $ username , $ password , $ driverOptions ) ; }
4119	public static function addType ( $ name , $ className ) { if ( isset ( self :: $ _typesMap [ $ name ] ) ) { throw TypeException :: typeExists ( $ name ) ; } self :: $ _typesMap [ $ name ] = $ className ; }
8676	public function flip ( ) { if ( ! $ this -> items ) { return $ this -> createFrom ( [ ] ) ; } try { return $ this -> createFrom ( Thrower :: call ( 'array_flip' , $ this -> items ) ) ; } catch ( ErrorException $ e ) { throw new LogicException ( 'Only string and integer values can be flipped' ) ; } }
3953	public function get ( $ strAttributeName ) { return array_key_exists ( $ strAttributeName , $ this -> arrData ) ? $ this -> arrData [ $ strAttributeName ] : null ; }
10579	private function codesEqual ( string $ known , string $ given ) : bool { if ( strlen ( $ given ) !== strlen ( $ known ) ) { return false ; } $ res = 0 ; $ knownLen = strlen ( $ known ) ; for ( $ i = 0 ; $ i < $ knownLen ; ++ $ i ) { $ res |= ( ord ( $ known [ $ i ] ) ^ ord ( $ given [ $ i ] ) ) ; } return $ res === 0 ; }
4956	protected function proxy ( ) { $ args = func_get_args ( ) ; $ method = array_shift ( $ args ) ; $ callback = array ( $ this -> object , $ method ) ; if ( ! is_callable ( $ callback ) ) { throw new \ BadMethodCallException ( sprintf ( 'Cannot proxy "%s" to "%s": Unknown method.' , $ method , get_class ( $ this -> object ) ) ) ; } $ return = call_user_func_array ( $ callback , $ args ) ; if ( $ return === $ this -> object ) { $ return = $ this ; } return $ return ; }
10758	protected function prepareHeader ( array $ data ) { return array_merge_recursive ( [ 'date' => trans ( 'dashboard::logs.date' ) , 'all' => trans ( 'dashboard::logs.all' ) , ] , $ this -> levels -> names ( $ this -> locale ) ) ; }
11788	private function updateTv ( $ dwnl ) { $ entity = new EBonDwnl ( ) ; foreach ( $ dwnl as $ one ) { $ tv = $ one -> getTv ( ) ; $ calcId = $ one -> getCalculationRef ( ) ; $ custId = $ one -> getCustomerRef ( ) ; $ entity -> setTv ( $ tv ) ; $ id = [ EBonDwnl :: A_CALC_REF => $ calcId , EBonDwnl :: A_CUST_REF => $ custId ] ; $ this -> daoBonDwnl -> updateById ( $ id , $ entity ) ; } }
7643	protected function parseMetadataHeaders ( $ headers = array ( ) ) { if ( ! is_array ( $ headers ) ) { return array ( ) ; } $ metadata = array ( ) ; foreach ( $ headers as $ key => $ value ) { if ( substr ( strtolower ( $ key ) , 0 , 10 ) == "x-ms-meta-" ) { $ metadata [ str_replace ( "x-ms-meta-" , '' , strtolower ( $ key ) ) ] = $ value ; } } return $ metadata ; }
3021	public function getBlogAvatar ( $ blogName , $ size = null ) { $ path = $ this -> blogPath ( $ blogName , '/avatar' ) ; if ( $ size ) { $ path .= "/$size" ; } return $ this -> getRedirect ( $ path , null , true ) ; }
8299	public function addRule ( $ url , $ rule ) { if ( ! is_string ( $ url ) || ! is_array ( $ rule ) ) { throw new \ InvalidArgumentException ( "addRule() expects a string and an array." ) ; } $ this -> runtimeRules [ $ url ] = $ rule ; }
8977	public function setParameter ( $ name , $ value ) { if ( ! isset ( $ ref ) ) { $ ref = new \ ReflectionClass ( $ this -> config ) ; } $ function = sprintf ( 'set%s' , ucfirst ( $ name ) ) ; if ( ! $ ref -> hasMethod ( $ function ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The function "%s" does not exists on configuration' , $ name ) ) ; } $ this -> config -> $ function ( $ value ) ; return $ this ; }
12415	public static function init ( $ options = array ( ) ) { Flight :: map ( "render" , function ( $ template , $ data , $ toVar = false ) { Flight :: view ( ) -> render ( $ template , $ data , $ toVar ) ; } ) ; Flight :: register ( 'view' , get_called_class ( ) , $ options ) ; }
1907	protected function escapeParams ( $ arrValues ) { foreach ( $ arrValues as $ k => $ v ) { switch ( \ gettype ( $ v ) ) { case 'string' : $ arrValues [ $ k ] = $ this -> resConnection -> quote ( $ v ) ; break ; case 'boolean' : $ arrValues [ $ k ] = ( $ v === true ) ? 1 : 0 ; break ; case 'object' : $ arrValues [ $ k ] = $ this -> resConnection -> quote ( serialize ( $ v ) ) ; break ; case 'array' : $ arrValues [ $ k ] = $ this -> resConnection -> quote ( serialize ( $ v ) ) ; break ; default : $ arrValues [ $ k ] = $ v ?? 'NULL' ; break ; } } return $ arrValues ; }
1473	public function createValidator ( array $ data , array $ rules , array $ messages = [ ] , array $ customAttributes = [ ] , \ Closure $ callback = null ) : ValidatorInterface { $ translator = $ this -> createErrorTranslator ( ) ; return new Validation \ Validator ( $ this -> makeValidator ( $ data , $ rules , $ messages , $ customAttributes ) , $ translator , $ callback ) ; }
7753	public function serialize ( $ data , $ format , array $ context = array ( ) ) { if ( 'jsonld' !== $ format ) { throw new UnexpectedValueException ( 'Serialization for the format ' . $ format . ' is not supported' ) ; } if ( false === is_object ( $ data ) ) { throw new \ Exception ( 'Only objects can be serialized' ) ; } return JsonLD :: toString ( $ this -> doSerialize ( $ data , true ) , true ) ; }
6713	public function getParameter ( $ key , $ default = null ) { if ( array_key_exists ( $ key , $ this -> parameters ) ) { return $ this -> parameters [ $ key ] ; } $ flatKey = $ this -> flatten ( $ key ) ; foreach ( $ this -> parameters as $ index => $ value ) { if ( $ flatKey == $ this -> flatten ( $ index ) ) { return $ value ; } } return $ default ; }
1371	protected function make ( array $ data ) { $ validator = $ this -> validatorFactory -> make ( $ data , $ this -> getRules ( ) , $ this -> getMessages ( ) , $ this -> getAttributes ( ) ) ; $ this -> configureValidator ( $ validator ) ; return $ validator ; }
11432	protected function head ( $ path , array $ parameters = array ( ) , $ requestHeaders = array ( ) ) { if ( array_key_exists ( 'ref' , $ parameters ) && is_null ( $ parameters [ 'ref' ] ) ) { unset ( $ parameters [ 'ref' ] ) ; } $ response = $ this -> client -> getHttpClient ( ) -> request ( $ path , null , 'HEAD' , $ requestHeaders , array ( 'query' => $ parameters ) ) ; return $ response ; }
6910	public function addExtraCopy ( Recipient $ copy ) { if ( ! $ this -> extraCopies -> contains ( $ copy ) ) { $ this -> extraCopies -> add ( $ copy ) ; } return $ this ; }
8332	public function listSequences ( $ database = null ) { $ query = "SELECT name FROM sysobjects WHERE xtype = 'U'" ; $ tableNames = $ this -> _conn -> fetchAll ( $ query ) ; return array_map ( [ $ this -> _conn -> formatter , 'fixSequenceName' ] , $ tableNames ) ; }
7205	public function getBase ( bool $ ati = false ) : float { return $ ati ? $ this -> ati ( $ this -> base ) : $ this -> base ; }
11827	public function getBom ( $ encoding = 'UTF-8' ) { $ boms = array ( 'UTF-8' => pack ( 'CCC' , 0xef , 0xbb , 0xbf ) , 'UTF-16 Big Endian' => pack ( 'CC' , 0xfe , 0xff ) , 'UTF-16 Little Endian' => pack ( 'CC' , 0xff , 0xfe ) , 'UTF-32 Big Endian' => pack ( 'CCCC' , 0x00 , 0x00 , 0xfe , 0xff ) , 'UTF-32 Little Endian' => pack ( 'CCCC' , 0xff , 0xfe , 0x00 , 0x00 ) , 'SCSU' => pack ( 'CCC' , 0x0e , 0xfe , 0xff ) , 'UTF-7 (1)' => pack ( 'CCCC' , 0x2b , 0x2f , 0x76 , 0x38 ) , 'UTF-7 (2)' => pack ( 'CCCC' , 0x2b , 0x2f , 0x76 , 0x39 ) , 'UTF-7 (3)' => pack ( 'CCCC' , 0x2b , 0x2f , 0x76 , 0x2b ) , 'UTF-7 (4)' => pack ( 'CCCC' , 0x2b , 0x2f , 0x76 , 0x2f ) , 'UTF-7 (5)' => pack ( 'CCCCC' , 0x2b , 0x2f , 0x76 , 0x38 , 0x2d ) , 'UTF-1' => pack ( 'CCC' , 0xF7 , 0x64 , 0x4c ) , 'UTF-EBCDIC' => pack ( 'CCCC' , 0xdd , 0x73 , 0x66 , 0x73 ) , 'BOCU-1' => pack ( 'CCC' , 0xfb , 0xee , 0x28 ) , 'GB-18030' => pack ( 'CCCC' , 0x84 , 0x31 , 0x95 , 0x33 ) , ) ; if ( 'all' == $ encoding ) { return $ boms ; } return $ boms [ $ encoding ] ; }
551	public function actionFlush ( ) { $ cachesInput = func_get_args ( ) ; if ( empty ( $ cachesInput ) ) { throw new Exception ( 'You should specify cache components names' ) ; } $ caches = $ this -> findCaches ( $ cachesInput ) ; $ cachesInfo = [ ] ; $ foundCaches = array_keys ( $ caches ) ; $ notFoundCaches = array_diff ( $ cachesInput , array_keys ( $ caches ) ) ; if ( $ notFoundCaches ) { $ this -> notifyNotFoundCaches ( $ notFoundCaches ) ; } if ( ! $ foundCaches ) { $ this -> notifyNoCachesFound ( ) ; return ExitCode :: OK ; } if ( ! $ this -> confirmFlush ( $ foundCaches ) ) { return ExitCode :: OK ; } foreach ( $ caches as $ name => $ class ) { $ cachesInfo [ ] = [ 'name' => $ name , 'class' => $ class , 'is_flushed' => $ this -> canBeFlushed ( $ class ) ? Yii :: $ app -> get ( $ name ) -> flush ( ) : false , ] ; } $ this -> notifyFlushed ( $ cachesInfo ) ; }
5058	public function generate ( $ subject , $ status , $ color , $ format ) { $ badge = new Badge ( $ subject , $ status , $ color , $ format ) ; return $ this -> getRenderFor ( $ badge -> getFormat ( ) ) -> render ( $ badge ) ; }
12763	public function remove ( $ name , $ path = null , $ domain = null , $ secure = false , $ httpOnly = false ) { if ( $ this -> exists ( $ name ) ) { $ expire = time ( ) - ( 3600 * 24 * 365 ) ; $ this -> set ( $ name , '' , $ expire , $ path , $ domain , $ secure , $ httpOnly ) ; } }
4389	public function repay ( \ Aimeos \ MShop \ Order \ Item \ Iface $ order ) { $ base = $ this -> getOrderBase ( $ order -> getBaseId ( ) ) ; if ( ( $ cfg = $ this -> getCustomerData ( $ base -> getCustomerId ( ) , 'repay' ) ) === null ) { $ msg = sprintf ( 'No reoccurring payment data available for customer ID "%1$s"' , $ base -> getCustomerId ( ) ) ; throw new \ Aimeos \ MShop \ Service \ Exception ( $ msg ) ; } if ( ! isset ( $ cfg [ 'token' ] ) ) { $ msg = sprintf ( 'No payment token available for customer ID "%1$s"' , $ base -> getCustomerId ( ) ) ; throw new \ Aimeos \ MShop \ Service \ Exception ( $ msg ) ; } $ data = array ( 'transactionId' => $ order -> getId ( ) , 'currency' => $ base -> getPrice ( ) -> getCurrencyId ( ) , 'amount' => $ this -> getAmount ( $ base -> getPrice ( ) ) , 'cardReference' => $ cfg [ 'token' ] , 'paymentPage' => false , ) ; if ( isset ( $ cfg [ 'month' ] ) && isset ( $ cfg [ 'year' ] ) ) { $ data [ 'card' ] = new \ Omnipay \ Common \ CreditCard ( [ 'expiryMonth' => $ cfg [ 'month' ] , 'expiryYear' => $ cfg [ 'year' ] , ] ) ; } $ response = $ this -> getXmlProvider ( ) -> purchase ( $ data ) -> send ( ) ; if ( $ response -> isSuccessful ( ) ) { $ this -> saveTransationRef ( $ base , $ response -> getTransactionReference ( ) ) ; $ order -> setPaymentStatus ( \ Aimeos \ MShop \ Order \ Item \ Base :: PAY_RECEIVED ) ; $ this -> saveOrder ( $ order ) ; } else { $ msg = ( method_exists ( $ response , 'getMessage' ) ? $ response -> getMessage ( ) : '' ) ; throw new \ Aimeos \ MShop \ Service \ Exception ( sprintf ( 'Token based payment failed: %1$s' , $ msg ) ) ; } }
10866	protected function createNewInst ( ) { $ classReflection = new \ ReflectionClass ( $ this -> instClass ) ; if ( $ this -> constructorArgs === null ) { return $ classReflection -> newInstance ( ) ; } else { return $ classReflection -> newInstanceArgs ( $ this -> concstructorArgs ) ; } }
3315	public function set ( $ key , $ value ) { Arr :: set ( $ this -> configs , $ key , $ value ) ; return $ this ; }
12040	public function getCurrentUser ( ) { $ this -> authenticated = false ; $ authenticate = $ this -> session -> get ( "handler" , "auth" ) ; if ( is_a ( $ authenticate , Authenticate :: class ) ) { if ( $ authenticate -> authenticated ) { $ this -> authenticated = true ; $ this -> authority = $ this -> session -> getAuthority ( ) ; return $ this -> loadObjectByURI ( $ authenticate -> get ( "user_name_id" ) , [ ] , true ) ; } } return $ this ; }
1290	public function setContentType ( $ contentType ) { if ( $ contentType instanceof ContentType ) { $ contentType = $ contentType -> getId ( ) ; } $ this -> contentType = $ contentType ; $ this -> setType ( 'Entry' ) ; return $ this ; }
12958	public function inject ( ... $ injects ) : void { $ container = new Container ; $ requested = [ ] ; foreach ( $ injects as $ inject ) { if ( is_string ( $ inject ) ) { $ requested [ ] = $ inject ; } elseif ( is_callable ( $ inject ) ) { $ reflection = new ReflectionFunction ( $ inject ) ; foreach ( $ reflection -> getParameters ( ) as $ param ) { $ requested [ ] = $ param -> name ; } } } foreach ( $ requested as $ dependency ) { $ this -> $ dependency = $ container -> get ( $ dependency ) ; } }
37	protected function printLicenses ( CompletePackageInterface $ package ) { $ spdxLicenses = new SpdxLicenses ( ) ; $ licenses = $ package -> getLicense ( ) ; $ io = $ this -> getIO ( ) ; foreach ( $ licenses as $ licenseId ) { $ license = $ spdxLicenses -> getLicenseByIdentifier ( $ licenseId ) ; if ( ! $ license ) { $ out = $ licenseId ; } else { if ( $ license [ 1 ] === true ) { $ out = sprintf ( '%s (%s) (OSI approved) %s' , $ license [ 0 ] , $ licenseId , $ license [ 2 ] ) ; } else { $ out = sprintf ( '%s (%s) %s' , $ license [ 0 ] , $ licenseId , $ license [ 2 ] ) ; } } $ io -> write ( '<info>license</info> : ' . $ out ) ; } }
1233	private function ensurePropertyType ( $ value ) { $ actualType = gettype ( $ value ) ; if ( 'object' === $ actualType ) { $ actualType = get_class ( $ value ) ; } $ valid = explode ( '|' , $ this -> expectedType ) ; $ isValid = false ; foreach ( $ valid as $ check ) { if ( $ check !== 'any' && \ DTS \ eBaySDK \ checkPropertyType ( $ check ) ) { if ( $ check === $ actualType ) { return ; } $ isValid = false ; } else { $ isValid = true ; } } if ( ! $ isValid ) { throw new Exceptions \ InvalidPropertyTypeException ( $ this -> property , $ this -> expectedType , $ actualType ) ; } }
1356	protected function getSortColumn ( $ field , Model $ model ) { if ( isset ( $ this -> sortColumns [ $ field ] ) ) { return $ this -> sortColumns [ $ field ] ; } return $ model :: $ snakeAttributes ? Str :: underscore ( $ field ) : Str :: camelize ( $ field ) ; }
2358	public function getBackendUsername ( ) : ? string { $ token = $ this -> getToken ( BackendUser :: SECURITY_SESSION_KEY ) ; if ( null === $ token || ! $ token -> getUser ( ) instanceof BackendUser ) { return null ; } return $ token -> getUser ( ) -> getUsername ( ) ; }
2117	public function getExcludedFields ( ) { $ processed = array ( ) ; $ files = Contao \ System :: getContainer ( ) -> get ( 'contao.resource_finder' ) -> findIn ( 'dca' ) -> depth ( 0 ) -> files ( ) -> name ( '*.php' ) ; foreach ( $ files as $ file ) { if ( \ in_array ( $ file -> getBasename ( ) , $ processed ) ) { continue ; } $ processed [ ] = $ file -> getBasename ( ) ; $ strTable = $ file -> getBasename ( '.php' ) ; Contao \ System :: loadLanguageFile ( $ strTable ) ; $ this -> loadDataContainer ( $ strTable ) ; } $ arrReturn = array ( ) ; foreach ( $ GLOBALS [ 'TL_DCA' ] as $ k => $ v ) { if ( \ is_array ( $ v [ 'fields' ] ) ) { foreach ( $ v [ 'fields' ] as $ kk => $ vv ) { if ( $ k == 'tl_user' && $ kk == 'admin' && ! $ this -> User -> isAdmin ) { continue ; } if ( $ vv [ 'exclude' ] || $ vv [ 'orig_exclude' ] ) { $ arrReturn [ $ k ] [ Contao \ StringUtil :: specialchars ( $ k . '::' . $ kk ) ] = isset ( $ vv [ 'label' ] [ 0 ] ) ? $ vv [ 'label' ] [ 0 ] . ' <span style="color:#999;padding-left:3px">[' . $ kk . ']</span>' : $ kk ; } } } } ksort ( $ arrReturn ) ; return $ arrReturn ; }
5845	public function execute ( ) { $ configuration = ConfigurationController :: readConfiguration ( ) ; $ this -> imageResizer = GeneralUtility :: makeInstance ( \ Causal \ ImageAutoresize \ Service \ ImageResizer :: class ) ; $ this -> imageResizer -> initializeRulesets ( $ configuration ) ; if ( empty ( $ this -> directories ) ) { $ directories = $ this -> imageResizer -> getAllDirectories ( ) ; } else { $ directories = GeneralUtility :: trimExplode ( LF , $ this -> directories , true ) ; } $ processedDirectories = [ ] ; $ expandedDirectories = [ ] ; foreach ( $ directories as $ directory ) { if ( ( $ pos = strpos ( $ directory , '/*' ) ) !== false ) { $ pattern = $ this -> imageResizer -> getDirectoryPattern ( $ directory ) ; $ basePath = substr ( $ directory , 0 , $ pos + 1 ) ; $ objects = new \ RecursiveIteratorIterator ( new \ RecursiveDirectoryIterator ( PATH_site . $ basePath ) , \ RecursiveIteratorIterator :: SELF_FIRST ) ; foreach ( $ objects as $ name => $ object ) { $ relativePath = substr ( $ name , strlen ( PATH_site ) ) ; if ( substr ( $ relativePath , - 2 ) === DIRECTORY_SEPARATOR . '.' ) { if ( preg_match ( $ pattern , $ relativePath ) ) { $ expandedDirectories [ ] = substr ( $ relativePath , 0 , - 1 ) ; } } } } else { $ expandedDirectories [ ] = $ directory ; } } $ directories = $ expandedDirectories ; $ success = true ; foreach ( $ directories as $ directory ) { $ skip = false ; foreach ( $ processedDirectories as $ processedDirectory ) { if ( GeneralUtility :: isFirstPartOfStr ( $ directory , $ processedDirectory ) ) { continue 2 ; } } $ success |= $ this -> batchResizePictures ( $ directory ) ; $ processedDirectories [ ] = $ directory ; } return $ success ; }
6202	public function methodFail ( $ errors = null ) { if ( $ errors === null ) { return $ this -> methodResult ( false ) ; } if ( ! is_array ( $ errors ) ) { $ errors = [ $ errors ] ; } return $ this -> methodResult ( false , [ 'errors' => $ errors ] ) ; }
4491	public function registerDeviceOnTopic ( string $ deviceArn , string $ topicArn ) { $ this -> sns -> subscribe ( [ 'TopicArn' => $ topicArn , 'Protocol' => 'application' , 'Endpoint' => $ deviceArn , ] ) ; }
2828	public function getOptionArray ( array $ data ) { $ options = array ( ) ; foreach ( $ data as $ value ) { $ options [ ] = array ( 'value' => $ value , 'label' => $ value ) ; } return $ options ; }
2693	private function compileFastlyParameters ( ) { if ( isset ( $ this -> fastlyParameters [ 'width' ] ) == false ) { $ this -> fastlyParameters [ 'height' ] = $ this -> _height ; $ this -> fastlyParameters [ 'width' ] = $ this -> _width ; } $ params = [ ] ; foreach ( $ this -> fastlyParameters as $ key => $ value ) { $ params [ ] = $ key . '=' . $ value ; } return implode ( '&' , $ params ) ; }
2960	public function sendMessage ( $ str , $ waitForReply = 0.1 ) { $ this -> _buffer .= $ str ; if ( $ this -> autoFlush === true ) { $ this -> serialflush ( ) ; } usleep ( ( int ) ( $ waitForReply * 1000000 ) ) ; }
10936	protected function authenticateUser ( CustomerInterface $ user , Response $ response ) { try { $ this -> get ( 'fos_user.security.login_manager' ) -> loginUser ( $ this -> getParameter ( 'fos_user.firewall_name' ) , $ user , $ response ) ; } catch ( AccountStatusException $ ex ) { } }
1743	public function uploadFile ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { if ( ! $ GLOBALS [ 'TL_DCA' ] [ 'tl_files' ] [ 'config' ] [ 'closed' ] && ! $ GLOBALS [ 'TL_DCA' ] [ 'tl_files' ] [ 'config' ] [ 'notCreatable' ] && Contao \ Input :: get ( 'act' ) != 'select' && isset ( $ row [ 'type' ] ) && $ row [ 'type' ] == 'folder' ) { return '<a href="' . $ this -> addToUrl ( $ href . '&amp;pid=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '" ' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' ; } return ' ' ; }
6700	public function setPreRelease ( $ pre ) { $ this -> pre = array_values ( ( array ) $ pre ) ; array_walk ( $ this -> pre , function ( & $ v ) { if ( preg_match ( '/^[0-9]+$/' , $ v ) ) { $ v = ( int ) $ v ; } } ) ; }
10351	public function channel ( string $ channel_id ) : EventChannelInterface { if ( isset ( $ this -> channel_adapters [ $ channel_id ] ) ) { return $ this -> channel_adapters [ $ channel_id ] ; } $ adapter = new Stk2kEventChannelAdapter ( $ this -> eventstream -> channel ( $ channel_id , function ( ) { return new SimpleEventSource ( ) ; } , function ( ) { return new WildCardEventEmitter ( ) ; } ) ) ; $ this -> channel_adapters [ $ channel_id ] = $ adapter ; return $ adapter ; }
2569	protected function checkAnyTrue ( ) { $ foundTrue = false ; $ args = func_get_args ( ) ; foreach ( $ args as $ arg ) { if ( $ arg === true ) { $ foundTrue = true ; break ; } } return $ foundTrue ; }
10929	public function getCountOf ( string $ strSQL , ? array $ parans = null ) : int { $ r = $ this -> getDataColumn ( $ strSQL , $ parans , "int" ) ; return ( ( $ r === null ) ? 0 : $ r ) ; }
4735	public function regenerate_id ( $ delete_old = false ) { if ( $ delete_old ) { delete_option ( "_wp_session_{$this->session_id}" ) ; } $ this -> session_id = $ this -> generate_id ( ) ; $ this -> set_cookie ( ) ; }
4789	function update ( array $ data ) { if ( $ this -> notORM -> freeze ) { return false ; } if ( ! $ data ) { return 0 ; } $ values = array ( ) ; $ parameters = array ( ) ; $ quoteChar = $ this -> getQuoteChar ( ) ; foreach ( $ data as $ key => $ val ) { $ values [ ] = "{$quoteChar}{$key}{$quoteChar} = " . $ this -> quote ( $ val ) ; if ( $ val instanceof NotORM_Literal && $ val -> parameters ) { $ parameters = array_merge ( $ parameters , $ val -> parameters ) ; } } if ( $ this -> parameters ) { $ parameters = array_merge ( $ parameters , $ this -> parameters ) ; } $ return = $ this -> query ( "UPDATE" . $ this -> topString ( $ this -> limit ) . " $this->table SET " . implode ( ", " , $ values ) . $ this -> whereString ( ) , $ parameters ) ; if ( ! $ return ) { return false ; } return $ return -> rowCount ( ) ; }
10768	public static function accountToIBAN ( $ account , $ country = 'CZ' ) { $ allowedCountries = [ 'AT' , 'BE' , 'BG' , 'CZ' , 'CY' , 'DK' , 'EE' , 'FI' , 'FR' , 'DE' , 'GI' , 'GR' , 'HU' , 'IE' , 'IS' , 'IT' , 'LI' , 'LT' , 'LU' , 'LV' , 'MC' , 'MT' , 'NL' , 'NO' , 'PL' , 'PT' , 'RO' , 'SE' , 'CH' , 'SI' , 'SK' , 'ES' , 'GB' ] ; $ account = self :: normalizeAccountNumber ( $ account ) ; $ accountArray = explode ( '/' , str_replace ( '-' , '' , $ account ) ) ; if ( 2 !== \ count ( $ accountArray ) ) { throw new RuntimeException ( Tools :: poorManTranslate ( 'fts-shared' , 'Wrong bank account (some part missing).' ) ) ; } $ country = strtoupper ( $ country ) ; if ( ! \ in_array ( $ country , $ allowedCountries , true ) ) { throw new RuntimeException ( Tools :: poorManTranslate ( 'fts-shared' , 'Invalid country code.' ) ) ; } $ accountStr = str_pad ( $ accountArray [ 1 ] , 4 , '0' , STR_PAD_LEFT ) . str_pad ( $ accountArray [ 0 ] , 16 , '0' , STR_PAD_LEFT ) . ( \ ord ( $ country [ 0 ] ) - 55 ) . ( \ ord ( $ country [ 1 ] ) - 55 ) . '00' ; $ crc = '' ; $ pos = 0 ; while ( \ strlen ( $ accountStr ) > 0 ) { $ len = 9 - \ strlen ( $ crc ) ; $ crc = ( int ) ( $ crc . substr ( $ accountStr , $ pos , $ len ) ) % 97 ; $ accountStr = substr ( $ accountStr , $ len ) ; } return ( $ country . str_pad ( 98 - $ crc , 2 , '0' , STR_PAD_LEFT ) . $ accountArray [ 1 ] . $ accountArray [ 0 ] ) ; }
10032	function unsubscribeContactByEmail ( $ email , $ mailingId = "" , $ reasons = null ) { $ queryParameters = array ( ) ; if ( ! empty ( $ mailingId ) ) { $ queryParameters [ 'mailingId' ] = $ mailingId ; } if ( ! empty ( $ reasons ) ) { if ( is_array ( $ reasons ) ) { $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , 'reason' , $ reasons ) ; } else { $ queryParameters [ 'reason' ] = urlencode ( $ reasons ) ; } } $ encodedEmail = utf8_encode ( $ email ) ; return $ this -> delete ( "contacts/email/${encodedEmail}/unsubscribe" , $ queryParameters ) ; }
223	protected function normalizeNumericStringValue ( $ value ) { $ powerPosition = strrpos ( $ value , 'E' ) ; if ( $ powerPosition !== false ) { $ valuePart = substr ( $ value , 0 , $ powerPosition ) ; $ powerPart = substr ( $ value , $ powerPosition + 1 ) ; } else { $ powerPart = null ; $ valuePart = $ value ; } $ separatorPosition = strrpos ( $ valuePart , '.' ) ; if ( $ separatorPosition !== false ) { $ integerPart = substr ( $ valuePart , 0 , $ separatorPosition ) ; $ fractionalPart = substr ( $ valuePart , $ separatorPosition + 1 ) ; } else { $ integerPart = $ valuePart ; $ fractionalPart = null ; } $ integerPart = preg_replace ( '/^\+?(-?)0*(\d+)$/' , '$1$2' , $ integerPart ) ; $ integerPart = preg_replace ( '/^\+?(-?)0*$/' , '${1}0' , $ integerPart ) ; if ( $ fractionalPart !== null ) { $ fractionalPart = rtrim ( $ fractionalPart , '0' ) ; if ( empty ( $ fractionalPart ) ) { $ fractionalPart = $ powerPart !== null ? '0' : null ; } } $ normalizedValue = $ integerPart ; if ( $ fractionalPart !== null ) { $ normalizedValue .= '.' . $ fractionalPart ; } elseif ( $ normalizedValue === '-0' ) { $ normalizedValue = '0' ; } if ( $ powerPart !== null ) { $ normalizedValue .= 'E' . $ powerPart ; } return $ normalizedValue ; }
4409	protected function render ( $ template , $ parameters ) { $ twig = new Twig_Environment ( new Twig_Loader_Filesystem ( $ this -> skeletonDirs ) , array ( 'debug' => true , 'cache' => false , 'strict_variables' => true , 'autoescape' => false , ) ) ; return $ twig -> render ( $ template , $ parameters ) ; }
6018	public function addMediaToDeploymentSite ( $ id , array $ mediaIds ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'mediaIds' => $ mediaIds ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/deployment/' . $ id . '/media' , $ parameters ) ; return $ result ; }
5009	public function setSubject ( $ subject , $ translate = true ) { if ( false !== $ translate ) { $ translator = $ this -> getTranslator ( ) ; $ domain = $ this -> getTranslatorTextDomain ( ) ; if ( true === $ translate ) { $ subject = $ translator -> translate ( $ subject , $ domain ) ; } else { $ args = func_get_args ( ) ; $ args [ 0 ] = $ translator -> translate ( $ args [ 0 ] , $ domain ) ; $ subject = call_user_func_array ( 'sprintf' , $ args ) ; } } return parent :: setSubject ( $ subject ) ; }
1633	protected function fireLogEvent ( $ level , $ message , array $ context = [ ] ) { if ( ! isset ( $ this -> dispatcher ) ) { return ; } if ( class_exists ( MessageLogged :: class ) ) { $ this -> dispatcher -> dispatch ( new MessageLogged ( $ level , $ message , $ context ) ) ; } else { $ this -> dispatcher -> fire ( 'illuminate.log' , compact ( 'level' , 'message' , 'context' ) ) ; } }
8943	public function diffUploadChangeset ( $ xml , $ id ) { $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = 'changeset/' . $ id . '/upload' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ header [ 'Content-Type' ] = 'text/xml' ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'POST' , $ parameters , $ xml , $ header ) ; $ xmlString = simplexml_load_string ( $ response -> body ) ; return $ xmlString -> diffResult ; }
9347	public function isDiagonal ( ) { $ int_size = min ( ( array ) $ this -> size ) ; if ( $ int_size > 0 ) { for ( $ i = 0 ; $ i < $ int_size ; $ i ++ ) { $ arr_row = $ this -> getRow ( $ i ) ; if ( $ arr_row [ $ i ] != 0 ) { unset ( $ arr_row [ $ i ] ) ; foreach ( $ arr_row as $ v ) { if ( $ v != 0 ) { return false ; } } } else { return false ; } } return true ; } return false ; }
11413	public function batchUntagUsers ( array $ openIds , $ tagId ) { $ params = [ 'openid_list' => $ openIds , 'tagid' => $ tagId , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_MEMBER_BATCH_UNTAG , $ params ] ) ; }
3428	public function paginate ( $ perPage = 15 , $ pageName = 'page' ) { $ page = Paginator :: resolveCurrentPage ( $ pageName ) ; $ total = $ this -> count ( ) ; $ results = $ this -> forPage ( $ page , $ perPage ) -> getList ( ) ; return new LengthAwarePaginator ( $ results , $ total , $ perPage , $ page , [ 'path' => Paginator :: resolveCurrentPath ( ) , 'pageName' => $ pageName , ] ) ; }
7559	function select ( $ query = '*' , $ index = false , $ recursive = true , $ check_self = false ) { $ s = new $ this -> selectClass ( $ this , $ query , $ check_self , $ recursive ) ; $ res = $ s -> result ; unset ( $ s ) ; if ( is_array ( $ res ) && ( $ index === true ) && ( count ( $ res ) === 1 ) ) { return $ res [ 0 ] ; } elseif ( is_int ( $ index ) && is_array ( $ res ) ) { if ( $ index < 0 ) { $ index += count ( $ res ) ; } return ( $ index < count ( $ res ) ) ? $ res [ $ index ] : null ; } else { return $ res ; } }
2988	public function hasResourceInAnnotation ( $ bundle ) { if ( ! file_exists ( $ this -> file ) ) { return false ; } $ config = Yaml :: parse ( file_get_contents ( $ this -> file ) ) ; $ search = sprintf ( '@%s/Controller/' , $ bundle ) ; foreach ( $ config as $ resource ) { if ( array_key_exists ( 'resource' , $ resource ) ) { return $ resource [ 'resource' ] === $ search ; } } return false ; }
6191	public function run ( $ controller = null , $ action = null , $ args = [ ] ) { $ this -> router = $ this -> router -> boot ( $ this ) ; if ( is_null ( $ controller ?? null ) and is_null ( $ action ?? null ) ) { $ this -> router -> parseGets ( ) ; $ controller = $ this -> router -> controller ; $ action = $ this -> router -> action ; $ namespace = $ this -> router -> namespace ; } $ loader = new Loader ( $ this -> baseClass ) ; $ Controller = $ loader -> loadController ( $ controller , $ namespace ?? '\\' ) ; $ response = [ ] ; if ( method_exists ( $ Controller , 'start' ) ) { $ response [ ] = [ 'start' , [ ] ] ; } if ( method_exists ( $ Controller , 'init' ) ) { $ response [ ] = [ 'init' , [ ] ] ; } if ( method_exists ( $ Controller , $ action ) or is_callable ( [ $ Controller , $ action ] ) ) { $ response [ ] = [ $ action , $ args ] ; } if ( method_exists ( $ Controller , 'end' ) ) { $ response [ ] = [ 'end' , [ ] ] ; } foreach ( $ response as $ key => $ data ) { $ run = call_user_func_array ( [ $ Controller , $ data [ 0 ] ] , $ data [ 1 ] ) ; if ( $ run instanceof Response ) { if ( isset ( $ this -> debug ) ) { $ this -> debug -> addHeader ( [ 'X-DF-Debug-Controller' => $ controller ] ) ; $ this -> debug -> addHeader ( [ 'X-DF-Debug-Method' => $ action ] ) ; $ run -> headers ( $ this -> debug -> getHeader ( ) ) ; } return $ run -> display ( ) ; } } return true ; }
1535	protected function fill ( $ record , ResourceObject $ resource , EncodingParametersInterface $ parameters ) { $ this -> fillAttributes ( $ record , $ resource -> getAttributes ( ) ) ; $ this -> fillRelationships ( $ record , $ resource -> getRelationships ( ) , $ parameters ) ; }
11392	public static function getInstance ( ) : Debug { if ( ! ( self :: $ _oInstance instanceof self ) ) { self :: $ _oInstance = new self ( ) ; } return self :: $ _oInstance ; }
3766	private function addInputScreenTranslations ( StaticTranslator $ translator , $ inputScreen , $ containerName ) { $ currentLocale = $ GLOBALS [ 'TL_LANGUAGE' ] ; foreach ( $ inputScreen [ 'legends' ] as $ legendName => $ legendInfo ) { foreach ( $ legendInfo [ 'label' ] as $ langCode => $ label ) { $ translator -> setValue ( $ legendName . '_legend' , $ label , $ containerName , $ langCode ) ; if ( $ currentLocale === $ langCode ) { $ translator -> setValue ( $ legendName . '_legend' , $ label , $ containerName ) ; } } } }
9201	private function createBearerCredentials ( ) { $ consumerKey = rawurlencode ( $ this -> credentials -> getConsumerKey ( ) ) ; $ consumerSecret = rawurlencode ( $ this -> credentials -> getConsumerSecret ( ) ) ; $ bearerTokenCredentials = $ consumerKey . ':' . $ consumerSecret ; return base64_encode ( $ bearerTokenCredentials ) ; }
4036	private function fetchTemplatesFromResourceDirectories ( $ templateBaseName ) { $ allTemplates = [ ] ; $ themeName = $ this -> getNoThemeMessage ( ) ; foreach ( $ this -> resourceDirs as $ resourceDir ) { $ allTemplates = array_replace_recursive ( $ allTemplates , $ this -> getTemplatesForBaseFrom ( $ templateBaseName , $ resourceDir . '/templates' , $ themeName ) ) ; } return $ allTemplates ; }
7819	public function settle ( ) { $ this -> files -> makeDirectory ( $ this -> path , 0755 , true , true ) ; $ this -> files -> put ( $ this -> getSource ( ) , '' ) ; }
555	private function notifyNotFoundCaches ( $ cachesNames ) { $ this -> stdout ( "The following cache components were NOT found:\n\n" , Console :: FG_RED ) ; foreach ( $ cachesNames as $ name ) { $ this -> stdout ( "\t* $name \n" , Console :: FG_GREEN ) ; } $ this -> stdout ( "\n" ) ; }
9947	public function getRowDimension ( $ pRow , $ create = true ) { $ found = null ; if ( ! isset ( $ this -> rowDimensions [ $ pRow ] ) ) { if ( ! $ create ) { return null ; } $ this -> rowDimensions [ $ pRow ] = new RowDimension ( $ pRow ) ; $ this -> cachedHighestRow = max ( $ this -> cachedHighestRow , $ pRow ) ; } return $ this -> rowDimensions [ $ pRow ] ; }
12337	public function confirmEmailAction ( ) { $ token = $ this -> params ( ) -> fromRoute ( 'token' ) ; if ( $ token ) { $ identity = $ this -> getUserService ( ) -> confirmEmail ( $ token ) ; if ( $ identity instanceof ResponseInterface ) { return $ identity ; } elseif ( $ identity ) { $ viewModel = new ViewModel ( compact ( 'identity' ) ) ; $ viewModel -> setTemplate ( 'cms-user/index/confirm-email' ) ; return $ viewModel ; } } return $ this -> redirect ( ) -> toRoute ( $ this -> getOptions ( ) -> getDefaultUserRoute ( ) ) ; }
4518	public function preFlush ( PreFlushEventArgs $ args ) { $ entities = $ args -> getEntityManager ( ) -> getUnitOfWork ( ) -> getScheduledEntityInsertions ( ) ; foreach ( $ entities as $ entity ) { if ( ! $ entity instanceof Parameter ) { continue ; } $ entity -> setValue ( serialize ( $ entity -> getValue ( ) ) ) ; } }
12411	public function lists ( $ begin , $ count ) { $ params = [ 'begin' => intval ( $ begin ) , 'count' => intval ( $ count ) , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_GET_LIST , $ params ] ) ; }
7397	public function header ( string $ name , string $ value ) : bool { if ( ! empty ( $ name ) && ! empty ( $ value ) && ! headers_sent ( ) ) { header ( $ name . ': ' . $ value ) ; return true ; } return false ; }
4220	private function getLogArgs ( $ cleared ) { $ cleared = \ array_filter ( $ cleared ) ; if ( ! $ cleared ) { return array ( ) ; } $ count = \ count ( $ cleared ) ; $ glue = $ count == 2 ? ' and ' : ', ' ; if ( $ count > 2 ) { $ cleared [ $ count - 1 ] = 'and ' . $ cleared [ $ count - 1 ] ; } $ msg = 'Cleared ' . \ implode ( $ glue , $ cleared ) ; if ( $ this -> channelName ) { return array ( $ msg . ' %c(%s)' , 'background-color:#c0c0c0; padding:0 .33em;' , $ this -> channelName , ) ; } return array ( $ msg ) ; }
5477	public function addWidget ( $ tag ) { if ( strtolower ( $ tag -> getAttribute ( 'type' ) ) === 'submit' ) { $ this -> buttons [ ] = $ tag ; } elseif ( strtolower ( $ tag -> getAttribute ( 'type' ) ) === 'image' ) { $ this -> images [ ] = $ tag ; } elseif ( $ tag -> getName ( ) ) { $ this -> setWidget ( $ tag ) ; } }
308	protected function createRule ( $ pattern , $ prefix , $ action ) { $ verbs = 'GET|HEAD|POST|PUT|PATCH|DELETE|OPTIONS' ; if ( preg_match ( "/^((?:($verbs),)*($verbs))(?:\\s+(.*))?$/" , $ pattern , $ matches ) ) { $ verbs = explode ( ',' , $ matches [ 1 ] ) ; $ pattern = isset ( $ matches [ 4 ] ) ? $ matches [ 4 ] : '' ; } else { $ verbs = [ ] ; } $ config = $ this -> ruleConfig ; $ config [ 'verb' ] = $ verbs ; $ config [ 'pattern' ] = rtrim ( $ prefix . '/' . strtr ( $ pattern , $ this -> tokens ) , '/' ) ; $ config [ 'route' ] = $ action ; if ( ! empty ( $ verbs ) && ! in_array ( 'GET' , $ verbs ) ) { $ config [ 'mode' ] = WebUrlRule :: PARSING_ONLY ; } $ config [ 'suffix' ] = $ this -> suffix ; return Yii :: createObject ( $ config ) ; }
9482	private function prepare ( array $ folders ) { return collect ( $ folders ) -> mapWithKeys ( function ( $ folder ) { $ path = base_path ( $ folder ) ; return [ $ folder => [ 'chmod' => ( int ) substr ( sprintf ( '%o' , fileperms ( $ path ) ) , - 4 ) , 'writable' => is_writable ( $ path ) , ] , ] ; } ) ; }
12442	public function detach ( $ key ) { if ( isset ( $ this -> instances [ $ key ] ) ) { unset ( $ this -> instances [ $ key ] ) ; } return $ this ; }
6966	public function clearIdentity ( ) { $ this -> gender = null ; $ this -> firstName = null ; $ this -> lastName = null ; return $ this ; }
5911	public function createUser ( User $ user , $ password = null , $ redirectTo = null , $ sendNotificationEmail = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'user' => $ user , 'password' => $ password , 'redirectTo' => $ redirectTo , 'sendNotificationEmail' => $ sendNotificationEmail ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/accounts/users' , $ parameters ) ; $ result = new User ( $ result ) ; return $ result ; }
7070	static function round ( $ value , $ unit = 'piece' ) { if ( 0 < $ precision = static :: getPrecision ( $ unit ) ) { $ divider = pow ( 10 , $ precision ) ; return round ( floor ( $ value * $ divider ) / $ divider , $ precision ) ; } return floor ( $ value ) ; }
4648	private function getConfigValue ( $ config , $ language , $ key ) { if ( ! isset ( $ config [ $ key ] ) || empty ( $ config [ $ key ] ) ) { if ( isset ( $ this -> defaults [ $ language ] [ $ key ] ) ) { return $ this -> defaults [ $ language ] [ $ key ] ; } return array ( ) ; } if ( ! is_array ( $ config [ $ key ] ) ) { return array ( $ config [ $ key ] ) ; } return $ config [ $ key ] ; }
10874	public function getEncodeHash ( int $ id , string $ slug , string $ linkValidate = null ) : string { return base64_encode ( uniqid ( ( $ linkValidate ? strtotime ( $ linkValidate ) : self :: NO_TIME ) . self :: TIME_SEPARATOR , true ) . self :: PART_SEPARATOR . $ this -> getHash ( $ id . $ slug ) . self :: ID_SEPARATOR . $ id ) ; }
859	public function isAllTokenKindsFound ( array $ tokenKinds ) { foreach ( $ tokenKinds as $ tokenKind ) { if ( empty ( $ this -> foundTokenKinds [ $ tokenKind ] ) ) { return false ; } } return true ; }
2233	public function checkPermission ( ) { if ( $ this -> User -> isAdmin ) { return ; } $ objSteps = $ this -> Database -> prepare ( "SELECT id FROM tl_undo WHERE pid=?" ) -> execute ( $ this -> User -> id ) ; $ GLOBALS [ 'TL_DCA' ] [ 'tl_undo' ] [ 'list' ] [ 'sorting' ] [ 'root' ] = $ objSteps -> numRows ? $ objSteps -> fetchEach ( 'id' ) : array ( 0 ) ; if ( Contao \ Input :: get ( 'act' ) && ! \ in_array ( Contao \ Input :: get ( 'id' ) , $ GLOBALS [ 'TL_DCA' ] [ 'tl_undo' ] [ 'list' ] [ 'sorting' ] [ 'root' ] ) ) { throw new Contao \ CoreBundle \ Exception \ AccessDeniedException ( 'Not enough permissions to ' . Contao \ Input :: get ( 'act' ) . ' undo step ID ' . Contao \ Input :: get ( 'id' ) . '.' ) ; } }
9998	public function setShadowProperties ( $ sh_presets , $ sh_color_value = null , $ sh_color_type = null , $ sh_color_alpha = null , $ sh_blur = null , $ sh_angle = null , $ sh_distance = null ) { $ this -> activateObject ( ) -> setShadowPresetsProperties ( ( int ) $ sh_presets ) -> setShadowColor ( $ sh_color_value === null ? $ this -> shadowProperties [ 'color' ] [ 'value' ] : $ sh_color_value , $ sh_color_alpha === null ? ( int ) $ this -> shadowProperties [ 'color' ] [ 'alpha' ] : $ this -> getTrueAlpha ( $ sh_color_alpha ) , $ sh_color_type === null ? $ this -> shadowProperties [ 'color' ] [ 'type' ] : $ sh_color_type ) -> setShadowBlur ( $ sh_blur ) -> setShadowAngle ( $ sh_angle ) -> setShadowDistance ( $ sh_distance ) ; }
8713	public function orWhereTranslated ( $ column , $ operator = null , $ value = null ) { return $ this -> whereTranslated ( $ column , $ operator , $ value , 'or' ) ; }
4682	private static function formatTime ( float $ value , $ format ) : string { switch ( $ format ) { case static :: FORMAT_PRECISE : return ( string ) ( $ value * 1000 ) ; case static :: FORMAT_MILLISECONDS : return ( string ) round ( $ value * 1000 , 2 ) ; case static :: FORMAT_SECONDS : return ( string ) round ( $ value , 3 ) ; default : return ( string ) ( $ value * 1000 ) ; } }
2768	public function checkoutNewBranch ( string $ branch , array $ options = [ ] ) : string { $ options [ 'b' ] = true ; return $ this -> checkout ( $ branch , $ options ) ; }
2709	public function beforeSave ( \ Magento \ Config \ Model \ Config $ subject ) { $ data = $ subject -> getData ( ) ; if ( ! empty ( $ data [ 'groups' ] [ 'full_page_cache' ] [ 'fields' ] [ 'caching_application' ] [ 'value' ] ) ) { $ currentCacheConfig = $ data [ 'groups' ] [ 'full_page_cache' ] [ 'fields' ] [ 'caching_application' ] [ 'value' ] ; $ oldCacheConfig = $ this -> scopeConfig -> getValue ( \ Magento \ PageCache \ Model \ Config :: XML_PAGECACHE_TYPE ) ; if ( $ oldCacheConfig == \ Fastly \ Cdn \ Model \ Config :: FASTLY && $ currentCacheConfig != $ oldCacheConfig ) { $ this -> purge = true ; } } }
2289	protected function activateRecipient ( ) { $ this -> Template = new FrontendTemplate ( 'mod_newsletter' ) ; $ optIn = System :: getContainer ( ) -> get ( 'contao.opt-in' ) ; if ( ( ! $ optInToken = $ optIn -> find ( Input :: get ( 'token' ) ) ) || ! $ optInToken -> isValid ( ) || \ count ( $ arrRelated = $ optInToken -> getRelatedRecords ( ) ) < 1 || key ( $ arrRelated ) != 'tl_newsletter_recipients' || \ count ( $ arrIds = current ( $ arrRelated ) ) < 1 ) { $ this -> Template -> type = 'error' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'invalidToken' ] ; return ; } if ( $ optInToken -> isConfirmed ( ) ) { $ this -> Template -> type = 'error' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'tokenConfirmed' ] ; return ; } $ arrRecipients = array ( ) ; foreach ( $ arrIds as $ intId ) { if ( ! $ objRecipient = NewsletterRecipientsModel :: findByPk ( $ intId ) ) { $ this -> Template -> type = 'error' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'invalidToken' ] ; return ; } if ( $ optInToken -> getEmail ( ) != $ objRecipient -> email ) { $ this -> Template -> type = 'error' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'tokenEmailMismatch' ] ; return ; } $ arrRecipients [ ] = $ objRecipient ; } $ time = time ( ) ; $ arrAdd = array ( ) ; $ arrCids = array ( ) ; foreach ( $ arrRecipients as $ objRecipient ) { $ arrAdd [ ] = $ objRecipient -> id ; $ arrCids [ ] = $ objRecipient -> pid ; $ objRecipient -> tstamp = $ time ; $ objRecipient -> active = '1' ; $ objRecipient -> save ( ) ; } $ optInToken -> confirm ( ) ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'activateRecipient' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'activateRecipient' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'activateRecipient' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ optInToken -> getEmail ( ) , $ arrAdd , $ arrCids ) ; } } $ this -> Template -> mclass = 'confirm' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'nl_activate' ] ; }
5729	public function bindGridField ( Form $ form , GridFieldDetailForm_ItemRequest $ request ) { $ this -> setForm ( $ form ) ; $ this -> gridFieldRequest = $ request ; foreach ( $ this -> children as $ child ) { if ( ! $ child instanceof BetterButton && ! $ child instanceof BetterButtonAction ) { throw new Exception ( "DropdownFormAction must be passed instances of BetterButton" ) ; } $ child -> bindGridField ( $ form , $ request ) ; $ child -> setIsGrouped ( true ) ; if ( $ child instanceof FormAction ) { $ child -> setUseButtonTag ( true ) ; } } return $ this ; }
3604	public function handleJsonRequest ( $ jsonRequest ) { if ( \ is_array ( $ jsonRequest ) ) { $ jsonResponse = [ ] ; foreach ( $ jsonRequest as $ request ) { $ jsonResponse [ ] = $ this -> handleJsonRequest ( $ request ) ; } return $ jsonResponse ; } if ( $ this -> stopwatch ) { $ this -> stopwatch -> start ( 'rpc.execute' ) ; } try { $ this -> dispatch ( Event \ JsonRequestEvent :: EVENT , new Event \ JsonRequestEvent ( $ jsonRequest ) ) ; $ metadata = $ this -> getMethod ( $ jsonRequest ) ; $ isCache = $ this -> isCacheSupport ( $ jsonRequest ) ; $ cacheId = $ jsonRequest -> getHash ( ) ; $ jsonResponse = new JsonResponse ( $ jsonRequest ) ; if ( true === $ isCache && true === $ this -> getCache ( ) -> contains ( $ cacheId ) ) { $ jsonResponse -> setResult ( $ this -> getCache ( ) -> fetch ( $ cacheId ) ) ; $ isCache = false ; } $ result = $ jsonResponse -> getResult ( ) ; if ( null === $ result ) { $ result = $ this -> executeJsonRequest ( $ metadata , $ jsonRequest ) ; } if ( $ result instanceof JsonResponse ) { $ jsonResponse = $ result ; $ jsonResponse -> setRequest ( $ jsonRequest ) ; } else { $ jsonResponse -> setResult ( $ this -> serialize ( $ result ) ) ; } $ isCache && $ this -> cache -> save ( $ cacheId , $ jsonResponse -> getResult ( ) , $ metadata -> getCache ( ) ) ; $ this -> dispatch ( Event \ JsonResponseEvent :: EVENT , new Event \ JsonResponseEvent ( $ jsonResponse ) ) ; } catch ( \ Exception $ exception ) { $ jsonResponse = $ this -> createJsonResponseFromException ( $ exception , $ jsonRequest ) ; } if ( $ this -> stopwatch ) { $ this -> stopwatch -> stop ( 'rpc.execute' ) ; } return $ jsonResponse ; }
8116	public function canBeReviewedBy ( Member $ member = null ) { if ( ! $ this -> owner -> obj ( "NextReviewDate" ) -> exists ( ) ) { return false ; } if ( $ this -> owner -> obj ( "NextReviewDate" ) -> InFuture ( ) ) { return false ; } $ options = $ this -> getOptions ( ) ; if ( ! $ options ) { return false ; } if ( ! $ options || ( ! $ options -> hasExtension ( __CLASS__ ) && ! $ options -> hasExtension ( ContentReviewDefaultSettings :: class ) ) ) { return false ; } if ( $ options -> OwnerGroups ( ) -> count ( ) == 0 && $ options -> OwnerUsers ( ) -> count ( ) == 0 ) { return false ; } if ( ! $ member ) { return true ; } if ( $ member -> inGroups ( $ options -> OwnerGroups ( ) ) ) { return true ; } if ( $ options -> OwnerUsers ( ) -> find ( "ID" , $ member -> ID ) ) { return true ; } return false ; }
2253	protected function getParentEntries ( $ strTable , $ intId ) { if ( ! isset ( $ GLOBALS [ 'TL_DCA' ] [ $ strTable ] [ 'config' ] [ 'ptable' ] ) ) { return '' ; } $ arrParent = array ( ) ; do { $ objParent = $ this -> Database -> prepare ( "SELECT pid FROM " . $ strTable . " WHERE id=?" ) -> limit ( 1 ) -> execute ( $ intId ) ; if ( $ objParent -> numRows < 1 ) { break ; } $ strTable = $ GLOBALS [ 'TL_DCA' ] [ $ strTable ] [ 'config' ] [ 'ptable' ] ; $ intId = $ objParent -> pid ; $ arrParent [ ] = $ strTable . '.id=' . $ intId ; $ this -> loadDataContainer ( $ strTable ) ; } while ( $ intId && isset ( $ GLOBALS [ 'TL_DCA' ] [ $ strTable ] [ 'config' ] [ 'ptable' ] ) ) ; if ( empty ( $ arrParent ) ) { return '' ; } return ' (parent records: ' . implode ( ', ' , $ arrParent ) . ')' ; }
1280	public function extractEnvironmentId ( array $ data ) : string { if ( isset ( $ data [ 'sys' ] [ 'type' ] ) && 'Space' === $ data [ 'sys' ] [ 'type' ] ) { return $ this -> environmentId ; } if ( isset ( $ data [ 'sys' ] [ 'type' ] ) && 'Environment' === $ data [ 'sys' ] [ 'type' ] ) { return $ data [ 'sys' ] [ 'id' ] ; } if ( isset ( $ data [ 'sys' ] [ 'environment' ] ) ) { return $ data [ 'sys' ] [ 'environment' ] [ 'sys' ] [ 'id' ] ; } if ( isset ( $ data [ 'items' ] [ 0 ] [ 'sys' ] [ 'environment' ] ) ) { return $ data [ 'items' ] [ 0 ] [ 'sys' ] [ 'environment' ] [ 'sys' ] [ 'id' ] ; } if ( isset ( $ data [ 'items' ] ) && ! $ data [ 'items' ] ) { return $ this -> environmentId ; } return 'master' ; }
2981	private function findLastImportedPath ( $ yamlContents ) { $ data = Yaml :: parse ( $ yamlContents ) ; if ( ! isset ( $ data [ 'imports' ] ) ) { return false ; } $ lastImport = end ( $ data [ 'imports' ] ) ; if ( ! isset ( $ lastImport [ 'resource' ] ) ) { return false ; } return $ lastImport [ 'resource' ] ; }
7412	protected function customChmod ( string $ target , $ mode = 0666 ) { if ( false === @ chmod ( $ target , $ mode & ~ umask ( ) ) ) { throw new FileException ( sprintf ( 'Unable to change mode of the "%s"' , $ target ) ) ; } }
1934	protected function getDateString ( ) { return 'Locale.define("en-US","Date",{' . 'months:["' . implode ( '","' , $ GLOBALS [ 'TL_LANG' ] [ 'MONTHS' ] ) . '"],' . 'days:["' . implode ( '","' , $ GLOBALS [ 'TL_LANG' ] [ 'DAYS' ] ) . '"],' . 'months_abbr:["' . implode ( '","' , $ GLOBALS [ 'TL_LANG' ] [ 'MONTHS_SHORT' ] ) . '"],' . 'days_abbr:["' . implode ( '","' , $ GLOBALS [ 'TL_LANG' ] [ 'DAYS_SHORT' ] ) . '"]' . '});' . 'Locale.define("en-US","DatePicker",{' . 'select_a_time:"' . $ GLOBALS [ 'TL_LANG' ] [ 'DP' ] [ 'select_a_time' ] . '",' . 'use_mouse_wheel:"' . $ GLOBALS [ 'TL_LANG' ] [ 'DP' ] [ 'use_mouse_wheel' ] . '",' . 'time_confirm_button:"' . $ GLOBALS [ 'TL_LANG' ] [ 'DP' ] [ 'time_confirm_button' ] . '",' . 'apply_range:"' . $ GLOBALS [ 'TL_LANG' ] [ 'DP' ] [ 'apply_range' ] . '",' . 'cancel:"' . $ GLOBALS [ 'TL_LANG' ] [ 'DP' ] [ 'cancel' ] . '",' . 'week:"' . $ GLOBALS [ 'TL_LANG' ] [ 'DP' ] [ 'week' ] . '"' . '});' ; }
9872	private function writeSheetData ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet , array $ pStringTable ) { $ aFlippedStringTable = $ this -> getParentWriter ( ) -> getWriterPart ( 'stringtable' ) -> flipStringTable ( $ pStringTable ) ; $ objWriter -> startElement ( 'sheetData' ) ; $ colCount = Coordinate :: columnIndexFromString ( $ pSheet -> getHighestColumn ( ) ) ; $ highestRow = $ pSheet -> getHighestRow ( ) ; $ cellsByRow = [ ] ; foreach ( $ pSheet -> getCoordinates ( ) as $ coordinate ) { $ cellAddress = Coordinate :: coordinateFromString ( $ coordinate ) ; $ cellsByRow [ $ cellAddress [ 1 ] ] [ ] = $ coordinate ; } $ currentRow = 0 ; while ( $ currentRow ++ < $ highestRow ) { $ rowDimension = $ pSheet -> getRowDimension ( $ currentRow ) ; $ writeCurrentRow = isset ( $ cellsByRow [ $ currentRow ] ) || $ rowDimension -> getRowHeight ( ) >= 0 || $ rowDimension -> getVisible ( ) == false || $ rowDimension -> getCollapsed ( ) == true || $ rowDimension -> getOutlineLevel ( ) > 0 || $ rowDimension -> getXfIndex ( ) !== null ; if ( $ writeCurrentRow ) { $ objWriter -> startElement ( 'row' ) ; $ objWriter -> writeAttribute ( 'r' , $ currentRow ) ; $ objWriter -> writeAttribute ( 'spans' , '1:' . $ colCount ) ; if ( $ rowDimension -> getRowHeight ( ) >= 0 ) { $ objWriter -> writeAttribute ( 'customHeight' , '1' ) ; $ objWriter -> writeAttribute ( 'ht' , StringHelper :: formatNumber ( $ rowDimension -> getRowHeight ( ) ) ) ; } if ( $ rowDimension -> getVisible ( ) == false ) { $ objWriter -> writeAttribute ( 'hidden' , 'true' ) ; } if ( $ rowDimension -> getCollapsed ( ) == true ) { $ objWriter -> writeAttribute ( 'collapsed' , 'true' ) ; } if ( $ rowDimension -> getOutlineLevel ( ) > 0 ) { $ objWriter -> writeAttribute ( 'outlineLevel' , $ rowDimension -> getOutlineLevel ( ) ) ; } if ( $ rowDimension -> getXfIndex ( ) !== null ) { $ objWriter -> writeAttribute ( 's' , $ rowDimension -> getXfIndex ( ) ) ; $ objWriter -> writeAttribute ( 'customFormat' , '1' ) ; } if ( isset ( $ cellsByRow [ $ currentRow ] ) ) { foreach ( $ cellsByRow [ $ currentRow ] as $ cellAddress ) { $ this -> writeCell ( $ objWriter , $ pSheet , $ cellAddress , $ aFlippedStringTable ) ; } } $ objWriter -> endElement ( ) ; } } $ objWriter -> endElement ( ) ; }
6251	protected function createGroupPresence ( $ id , $ label , array $ children = [ ] ) { return new AclPresence ( [ 'type' => AclPresenceType :: GROUP , 'id' => $ id , 'label' => $ label , 'children' => $ children , ] ) ; }
7300	public static function load_class ( $ class_name = NULL ) { if ( NULL === $ class_name ) { foreach ( glob ( dirname ( __FILE__ ) . '/*.php' ) as $ path ) { require_once $ path ; } } else { if ( 0 !== strpos ( $ class_name , 'Iac_' ) ) return FALSE ; $ path = dirname ( __FILE__ ) . '/class-' . $ class_name . '.php' ; if ( file_exists ( $ path ) ) { require_once $ path ; return TRUE ; } } return FALSE ; }
4376	protected function buildTableFooter ( $ keys ) { $ haveTotal = false ; $ cells = array ( ) ; foreach ( $ keys as $ key ) { $ colHasTotal = isset ( $ this -> tableInfo [ 'totals' ] [ $ key ] ) ; $ cells [ ] = $ colHasTotal ? $ this -> dump ( \ round ( $ this -> tableInfo [ 'totals' ] [ $ key ] , 6 ) , true , 'td' ) : '<td></td>' ; $ haveTotal = $ haveTotal || $ colHasTotal ; } if ( ! $ haveTotal ) { return '' ; } return '<tfoot>' . "\n" . '<tr><td>&nbsp;</td>' . ( $ this -> tableInfo [ 'haveObjRow' ] ? '<td>&nbsp;</td>' : '' ) . \ implode ( '' , $ cells ) . '</tr>' . "\n" . '</tfoot>' . "\n" ; }
12511	private function buildGroup ( $ group ) { if ( is_null ( $ group ) ) { $ group = [ 'filter' => [ 'is_to_all' => true , ] , ] ; } elseif ( is_array ( $ group ) ) { $ group = [ 'touser' => $ group , ] ; } else { $ group = [ 'filter' => [ 'is_to_all' => false , 'group_id' => $ group , ] , ] ; } return $ group ; }
11338	public function getPrimaryKeyLocation ( $ table ) { $ count = 0 ; foreach ( $ table -> columns as $ column ) { if ( $ column -> isPrimaryKey ) { $ count ++ ; } if ( $ count > 1 ) { return 'index' ; } } return 'table_build' ; }
1877	public function delete ( $ source = null ) { if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notDeletable' ] ) { throw new InternalServerErrorException ( 'Table "' . $ this -> strTable . '" is not deletable.' ) ; } $ blnDoNotRedirect = ( $ source !== null ) ; if ( $ source === null ) { $ source = $ this -> intId ; } $ this -> isValid ( $ source ) ; if ( ! file_exists ( $ this -> strRootDir . '/' . $ source ) || ! $ this -> isMounted ( $ source ) ) { throw new AccessDeniedException ( 'File or folder "' . $ source . '" is not mounted or cannot be found.' ) ; } if ( \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'ondelete_callback' ] ) ) { foreach ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'ondelete_callback' ] as $ callback ) { if ( \ is_array ( $ callback ) ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ source , $ this ) ; } elseif ( \ is_callable ( $ callback ) ) { $ callback ( $ source , $ this ) ; } } } $ this -> import ( Files :: class , 'Files' ) ; if ( is_dir ( $ this -> strRootDir . '/' . $ source ) ) { $ this -> Files -> rrdir ( $ source ) ; $ strWebDir = StringUtil :: stripRootDir ( System :: getContainer ( ) -> getParameter ( 'contao.web_dir' ) ) ; if ( is_link ( $ this -> strRootDir . '/' . $ strWebDir . '/' . $ source ) ) { $ this -> Files -> delete ( $ strWebDir . '/' . $ source ) ; } } else { $ this -> Files -> delete ( $ source ) ; } if ( $ this -> blnIsDbAssisted && Dbafs :: shouldBeSynchronized ( $ source ) ) { Dbafs :: deleteResource ( $ source ) ; } $ this -> log ( 'File or folder "' . $ source . '" has been deleted' , __METHOD__ , TL_FILES ) ; if ( ! $ blnDoNotRedirect ) { $ this -> redirect ( $ this -> getReferer ( ) ) ; } }
11709	public function actionUpdate ( $ id ) { $ user = $ this -> findModel ( $ id ) ; $ user -> scenario = 'update' ; $ profile = $ this -> finder -> findProfileById ( $ id ) ; $ r = \ Yii :: $ app -> request ; $ this -> performAjaxValidation ( [ $ user , $ profile ] ) ; if ( $ user -> load ( $ r -> post ( ) ) && $ profile -> load ( $ r -> post ( ) ) && $ user -> save ( ) && $ profile -> save ( ) ) { \ Yii :: $ app -> getSession ( ) -> setFlash ( 'success' , \ Yii :: t ( 'user' , 'User has been updated' ) ) ; return $ this -> refresh ( ) ; } return $ this -> render ( 'update' , [ 'user' => $ user , 'profile' => $ profile , 'module' => $ this -> module , ] ) ; }
10775	public function loginRequired ( $ checkAjax = true ) { $ request = Yii :: $ app -> getRequest ( ) ; if ( $ this -> enableSession && ( ! $ checkAjax || ! $ request -> getIsAjax ( ) ) ) { $ this -> setReturnUrl ( $ request -> getUrl ( ) ) ; } if ( $ this -> loginUrl !== null ) { $ loginUrl = ( array ) $ this -> loginUrl ; if ( $ loginUrl [ 0 ] !== Yii :: $ app -> requestedRoute ) { return Yii :: $ app -> getResponse ( ) -> redirect ( $ this -> loginUrl ) ; } } throw new ForbiddenHttpException ( Yii :: t ( 'yii' , 'Login Required' ) ) ; }
12103	private function phpSizeToBytes ( $ size ) { if ( is_numeric ( $ size ) ) { return $ size ; } $ suffix = substr ( $ size , - 1 ) ; $ value = substr ( $ size , 0 , - 1 ) ; switch ( strtolower ( $ suffix ) ) { case 'p' : $ value *= 1024 ; case 't' : $ value *= 1024 ; case 'g' : $ value *= 1024 ; case 'm' : $ value *= 1024 ; case 'k' : $ value *= 1024 ; break ; } return $ value ; }
9407	protected function callback ( $ middleware , ResponseInterface $ response ) { $ middleware = is_string ( $ middleware ) ? new $ middleware : $ middleware ; $ callback = function ( $ request , $ next = null ) use ( $ middleware ) { return $ middleware ( $ request , $ next ) ; } ; if ( $ this -> approach ( $ middleware ) == self :: SINGLE_PASS ) { $ callback = function ( $ request , $ next = null ) use ( $ middleware , $ response ) { return $ middleware ( $ request , $ response , $ next ) ; } ; } return $ callback ; }
753	public function init ( ) { $ this -> fontFile = Yii :: getAlias ( $ this -> fontFile ) ; if ( ! is_file ( $ this -> fontFile ) ) { throw new InvalidConfigException ( "The font file does not exist: {$this->fontFile}" ) ; } }
2115	private function getFieldValue ( ? PageModel $ page ) : string { if ( null === $ page ) { return '' ; } return ( string ) $ page -> { $ this -> field } ; }
11972	protected function validateParams ( Event $ event ) { return ( $ this -> genericParamValidation ( $ event ) && $ this -> firstParamValidation ( $ event ) && $ this -> secondParamValidation ( $ event ) ) ; }
3708	protected function checkRedirect ( $ widgets , $ wantedParameter , $ allParameter ) { @ trigger_error ( sprintf ( '"%1$s" has been deprecated in favor of the new "FilterUrlBuilder"' , __METHOD__ ) , E_USER_DEPRECATED ) ; if ( Input :: post ( 'FORM_SUBMIT' ) != $ this -> formId ) { return ; } $ redirectParameters = $ allParameter [ 'other' ] ; foreach ( $ wantedParameter as $ widgetName ) { $ filter = $ widgets [ $ widgetName ] ; if ( $ filter [ 'urlvalue' ] !== null ) { $ redirectParameters [ $ widgetName ] = $ filter [ 'urlvalue' ] ; } } $ filterUrl = new FilterUrl ( $ this -> objFilterConfig -> getJumpTo ( ) , [ ] , $ redirectParameters ) ; $ dispatcher = $ this -> getDispatcher ( ) ; $ dispatcher -> dispatch ( ContaoEvents :: CONTROLLER_REDIRECT , new RedirectEvent ( $ this -> filterUrlBuilder -> generate ( $ filterUrl ) ) ) ; }
6336	public function overlay ( $ title , $ message , $ level = 'info' , $ key = 'flash_message' ) { return $ this -> create ( $ title , $ message , $ level , $ key . '_overlay' ) ; }
4655	protected function getJobFromImage ( ImageItem $ image , $ imageName , $ strategy , $ project ) { $ tag = explode ( ':' , $ imageName ) [ 1 ] ; list ( $ uniq , $ timestamp ) = explode ( '-' , $ tag ) ; return new Job ( $ project , $ strategy , $ uniq , array ( 'image' => $ image ) , "" , \ DateTime :: createFromFormat ( 'U' , $ timestamp ) ) ; }
238	protected function normalizePdoRowKeyCase ( array $ row , $ multiple ) { if ( $ this -> db -> getSlavePdo ( ) -> getAttribute ( \ PDO :: ATTR_CASE ) !== \ PDO :: CASE_UPPER ) { return $ row ; } if ( $ multiple ) { return array_map ( function ( array $ row ) { return array_change_key_case ( $ row , CASE_LOWER ) ; } , $ row ) ; } return array_change_key_case ( $ row , CASE_LOWER ) ; }
8868	public function notify ( PayloadInterface $ payload ) { foreach ( $ this -> runners as $ runner ) { $ runner -> run ( $ payload ) ; } return $ this ; }
10955	protected function redirect ( Response $ response , int $ code , string $ url ) : Response { return $ response -> withStatus ( $ code ) -> withHeader ( 'Location' , $ url ) ; }
716	public function decimal ( $ precision = null , $ scale = null ) { $ length = [ ] ; if ( $ precision !== null ) { $ length [ ] = $ precision ; } if ( $ scale !== null ) { $ length [ ] = $ scale ; } return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_DECIMAL , $ length ) ; }
1096	protected function scopedAttributes ( $ node ) { $ keys = $ this -> node -> getScopedColumns ( ) ; if ( count ( $ keys ) == 0 ) return array ( ) ; $ values = array_map ( function ( $ column ) use ( $ node ) { return $ node -> getAttribute ( $ column ) ; } , $ keys ) ; return array_combine ( $ keys , $ values ) ; }
9307	public function setJsonApiSecurityHash ( $ jsonApiSecurityHash ) { if ( ! is_string ( $ jsonApiSecurityHash ) ) { throw new \ InvalidArgumentException ( '`jsonApiSecurityHash` expects string value!' ) ; } $ this -> options [ 'jsonApiSecurityHash' ] = ( string ) $ jsonApiSecurityHash ; return $ this ; }
4963	public function addViewTemplate ( $ name , $ template , $ vars = [ ] , $ priority = 0 ) { if ( is_int ( $ vars ) ) { $ priority = $ vars ; $ vars = [ ] ; } $ model = new ViewModel ( $ vars ) ; $ model -> setTemplate ( $ template ) ; return $ this -> addViewModel ( $ name , $ model , $ priority ) ; }
9303	public function setSuccessLogLifetime ( $ time ) { if ( ! is_numeric ( $ time ) ) { throw new \ InvalidArgumentException ( '`successLogLifetime` expects integer value!' ) ; } $ this -> options [ 'successLogLifetime' ] = ( int ) $ time ; return $ this ; }
10285	public static function columnIndexFromString ( $ pString ) { static $ indexCache = [ ] ; if ( isset ( $ indexCache [ $ pString ] ) ) { return $ indexCache [ $ pString ] ; } static $ columnLookup = [ 'A' => 1 , 'B' => 2 , 'C' => 3 , 'D' => 4 , 'E' => 5 , 'F' => 6 , 'G' => 7 , 'H' => 8 , 'I' => 9 , 'J' => 10 , 'K' => 11 , 'L' => 12 , 'M' => 13 , 'N' => 14 , 'O' => 15 , 'P' => 16 , 'Q' => 17 , 'R' => 18 , 'S' => 19 , 'T' => 20 , 'U' => 21 , 'V' => 22 , 'W' => 23 , 'X' => 24 , 'Y' => 25 , 'Z' => 26 , 'a' => 1 , 'b' => 2 , 'c' => 3 , 'd' => 4 , 'e' => 5 , 'f' => 6 , 'g' => 7 , 'h' => 8 , 'i' => 9 , 'j' => 10 , 'k' => 11 , 'l' => 12 , 'm' => 13 , 'n' => 14 , 'o' => 15 , 'p' => 16 , 'q' => 17 , 'r' => 18 , 's' => 19 , 't' => 20 , 'u' => 21 , 'v' => 22 , 'w' => 23 , 'x' => 24 , 'y' => 25 , 'z' => 26 , ] ; if ( isset ( $ pString [ 0 ] ) ) { if ( ! isset ( $ pString [ 1 ] ) ) { $ indexCache [ $ pString ] = $ columnLookup [ $ pString ] ; return $ indexCache [ $ pString ] ; } elseif ( ! isset ( $ pString [ 2 ] ) ) { $ indexCache [ $ pString ] = $ columnLookup [ $ pString [ 0 ] ] * 26 + $ columnLookup [ $ pString [ 1 ] ] ; return $ indexCache [ $ pString ] ; } elseif ( ! isset ( $ pString [ 3 ] ) ) { $ indexCache [ $ pString ] = $ columnLookup [ $ pString [ 0 ] ] * 676 + $ columnLookup [ $ pString [ 1 ] ] * 26 + $ columnLookup [ $ pString [ 2 ] ] ; return $ indexCache [ $ pString ] ; } } throw new Exception ( 'Column string index can not be ' . ( ( isset ( $ pString [ 0 ] ) ) ? 'longer than 3 characters' : 'empty' ) ) ; }
1824	public function originalRow ( ) { $ row = $ this -> row ( ) ; if ( ! $ this -> isModified ( ) ) { return $ row ; } $ originalRow = array ( ) ; foreach ( $ row as $ k => $ v ) { $ originalRow [ $ k ] = $ this -> arrModified [ $ k ] ?? $ v ; } return $ originalRow ; }
2227	public function editHeader ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { return $ this -> User -> canEditFieldsOf ( 'tl_faq_category' ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' ; }
8170	public function recoverPassword ( ) { $ user = User :: findOne ( [ 'email' => $ this -> email ] ) ; if ( $ user != NULL ) { $ user -> password_reset_token = Yii :: $ app -> getSecurity ( ) -> generateRandomString ( ) . '_' . time ( ) ; $ user -> save ( FALSE ) ; } Mailer :: sendRecoveryMessage ( $ user ) ; Yii :: $ app -> session -> setFlash ( 'info' , 'You will receive an email with instructions on how to reset your password in a few minutes.' ) ; }
11407	public function actionTriggerEvents ( ) { Yii :: $ app -> response -> format = Response :: FORMAT_JSON ; $ result = ( $ post = Yii :: $ app -> request -> post ( 'depdrop_parents' ) ) ? Item :: eventList ( $ post [ 0 ] ) : [ ] ; $ output = [ ] ; foreach ( $ result as $ id => $ name ) { $ output [ ] = compact ( 'id' , 'name' ) ; } echo Json :: encode ( [ 'output' => $ output , 'selected' => '' ] ) ; }
3918	private function checkDownloads ( ) { if ( $ this -> getShowImages ( ) ) { return ; } if ( ( $ file = Input :: get ( 'file' ) ) && ( $ key = Input :: get ( 'fileKey' ) ) ) { if ( ! ( array_key_exists ( $ file , $ _SESSION [ 'metaModels_downloads' ] ) && $ _SESSION [ 'metaModels_downloads' ] [ $ file ] === $ key ) ) { $ objHandler = new $ GLOBALS [ 'TL_PTY' ] [ 'error_403' ] ( ) ; $ objHandler -> generate ( $ file ) ; } Controller :: sendFileToBrowser ( $ file ) ; } }
7815	public static function uploadImgFile ( $ path ) { try { if ( Request :: hasFile ( 'image' ) ) { $ pic = Request :: file ( 'image' ) ; if ( $ pic -> isValid ( ) ) { $ newName = md5 ( rand ( 1 , 1000 ) . $ pic -> getClientOriginalName ( ) ) . "." . $ pic -> getClientOriginalExtension ( ) ; $ pic -> move ( $ path , $ newName ) ; $ url = asset ( $ path . '/' . $ newName ) ; } else { self :: addError ( 'The file is invalid' ) ; } } else { self :: addError ( 'Not File' ) ; } } catch ( \ Exception $ e ) { self :: addError ( $ e -> getMessage ( ) ) ; } $ data = array ( 'status' => empty ( $ message ) ? 0 : 1 , 'message' => self :: getLastError ( ) , 'url' => ! empty ( $ url ) ? $ url : '' ) ; return $ data ; }
2592	public static function createRequestCreator ( $ params , $ libIdentifier ) { $ params -> receivedFrom = self :: makeReceivedFrom ( $ params -> receivedFrom , $ libIdentifier ) ; $ theRequestCreator = new Base ( $ params ) ; return $ theRequestCreator ; }
2779	public function git ( string $ commandLine , ? string $ cwd = null ) : string { $ command = new GitCommand ( $ commandLine ) ; $ command -> executeRaw ( is_string ( $ commandLine ) ) ; $ command -> setDirectory ( $ cwd ) ; return $ this -> run ( $ command ) ; }
5798	public function routeIndex ( Request $ request , Response $ response , $ args ) { $ this -> tableName = $ args [ ROUTEARG_DATABASE_TABLE_NAME ] ; $ this -> tableMapper = new TableMapper ( $ this -> tableName ) ; parent :: __construct ( $ this -> container , $ this -> tableMapper , ROUTEPREFIX_ROLES ) ; return $ this -> indexView ( $ response ) ; }
2908	public function decodeSubject ( $ subject ) { if ( $ this -> hasQueue ( ) && $ queue = $ this -> getQueue ( ) ) { return $ queue -> getMessageParameters ( 'subject' ) ; } return base64_decode ( substr ( $ subject , strlen ( '=?utf-8?B?' ) , - 1 * strlen ( '?=' ) ) ) ; }
3472	public function extract ( string $ namespace ) : Config { $ extracted = $ this -> get ( $ namespace ) ; if ( ! is_array ( $ extracted ) ) { throw ConfigException :: forExtractionFailure ( $ namespace ) ; } return new self ( $ extracted ) ; }
11160	public function resolve ( $ url , \ GuzzleHttp \ Message \ Response $ data , Event $ event , Queue $ queue ) { $ logger = $ this -> getLogger ( ) ; $ json = json_decode ( $ data -> getBody ( ) ) ; $ logger -> info ( 'resolve' , array ( 'url' => $ url , 'json' => $ json ) ) ; if ( isset ( $ json -> error ) ) { return $ logger -> warning ( 'Query response contained an error' , array ( 'url' => $ url , 'error' => $ json -> error , ) ) ; } $ entries = $ json -> items ; if ( ! is_array ( $ entries ) || ! $ entries ) { return $ logger -> warning ( 'Query returned no results' , array ( 'url' => $ url ) ) ; } $ entry = reset ( $ entries ) ; $ replacements = $ this -> getReplacements ( $ entry ) ; $ message = str_replace ( array_keys ( $ replacements ) , array_values ( $ replacements ) , $ this -> responseFormat ) ; $ queue -> ircPrivmsg ( $ event -> getSource ( ) , $ message ) ; }
572	public function validatePassword ( $ password , $ hash ) { if ( ! is_string ( $ password ) || $ password === '' ) { throw new InvalidArgumentException ( 'Password must be a string and cannot be empty.' ) ; } if ( ! preg_match ( '/^\$2[axy]\$(\d\d)\$[\.\/0-9A-Za-z]{22}/' , $ hash , $ matches ) || $ matches [ 1 ] < 4 || $ matches [ 1 ] > 30 ) { throw new InvalidArgumentException ( 'Hash is invalid.' ) ; } if ( function_exists ( 'password_verify' ) ) { return password_verify ( $ password , $ hash ) ; } $ test = crypt ( $ password , $ hash ) ; $ n = strlen ( $ test ) ; if ( $ n !== 60 ) { return false ; } return $ this -> compareString ( $ test , $ hash ) ; }
6802	public function installTaxGroups ( $ codes = [ 'US' ] ) { $ codes = ( array ) $ codes ; if ( empty ( $ codes ) ) { return ; } $ taxGroupRepository = $ this -> manager -> getRepository ( TaxGroup :: class ) ; $ taxRepository = $ this -> manager -> getRepository ( Tax :: class ) ; foreach ( $ codes as $ code ) { $ path = __DIR__ . '/data/' . $ code . '_tax_groups.yml' ; if ( ! ( file_exists ( $ path ) && is_readable ( $ path ) ) ) { call_user_func ( $ this -> log , 'Tax groups data' , 'not found' ) ; continue ; } $ data = Yaml :: parse ( file_get_contents ( $ path ) ) ; if ( ! is_array ( $ data ) || empty ( $ data ) ) { continue ; } foreach ( $ data as $ datum ) { $ name = $ datum [ 'name' ] ; $ result = 'already exists' ; if ( $ datum [ 'default' ] ) { $ taxGroup = $ this -> manager -> getRepository ( TaxGroup :: class ) -> findOneBy ( [ 'default' => true ] ) ; if ( null !== $ taxGroup ) { call_user_func ( $ this -> log , $ name , 'skipped' ) ; continue ; } } if ( null === $ taxGroupRepository -> findOneBy ( [ 'name' => $ name ] ) ) { $ taxGroup = new TaxGroup ( ) ; $ taxGroup -> setName ( $ name ) -> setDefault ( $ datum [ 'default' ] ) ; if ( ! empty ( $ taxNames = $ datum [ 'taxes' ] ) ) { $ taxGroup -> setTaxes ( $ taxRepository -> findBy ( [ 'name' => $ taxNames ] ) ) ; } $ this -> manager -> persist ( $ taxGroup ) ; $ result = 'done' ; } call_user_func ( $ this -> log , $ name , $ result ) ; } } $ this -> manager -> flush ( ) ; }
6328	private function getColumnsSql ( ) { $ columnTypeMapper = new ColumnTypeMapper ( ) ; foreach ( $ this -> table -> getConstraints ( ) as $ constraint ) { if ( $ constraint instanceof PrimaryKey ) { $ primaryKey = $ constraint ; } } if ( ! isset ( $ primaryKey ) ) { $ primaryKey = new PrimaryKey ( ) ; $ primaryKey -> setTable ( $ this -> table ) ; $ this -> table -> addConstraint ( $ primaryKey ) ; } $ sql = '' ; if ( ! $ primaryKey -> isMulti ( ) && $ primaryKey -> isAutoCreateColumn ( ) ) { $ sql = sprintf ( '%s %s NOT NULL,' , $ primaryKey -> getColumns ( ) , $ primaryKey -> isAutoIncrement ( ) ? 'serial' : 'integer' ) ; } foreach ( $ this -> table -> getColumns ( ) as $ column ) { if ( $ column instanceof CustomColumn ) { $ columnType = $ column -> getType ( ) ; } else { $ columnType = $ columnTypeMapper -> getNative ( $ column -> getType ( ) ) ; } $ sql .= sprintf ( '%s %s%s %s %s,' , $ column -> getName ( ) , $ columnType , $ this -> getTypeConstraints ( $ column ) , $ column -> isNotNull ( ) ? 'NOT NULL' : '' , null === $ column -> getDefault ( ) ? '' : 'DEFAULT' . ' ' . $ this -> addQuotesIfNeeded ( $ column , $ column -> getDefault ( ) ) ) ; } return rtrim ( $ sql , ',' ) ; }
9223	public function unserialize ( $ data ) { $ _data = unserialize ( $ data ) ; $ this -> page = $ _data [ 'page' ] ; $ this -> key = $ _data [ 'key' ] ; $ this -> data = $ _data [ 'data' ] ; $ this -> api = null ; $ this -> endpoint = null ; $ this -> pagination = array ( ) ; }
11593	public function getAction ( ) { $ id = $ this -> getPageId ( ) ; if ( $ id !== null ) { $ result = $ this -> pageList -> getPage ( $ id ) -> getJSON ( ) ; } else { $ result = array ( ) ; foreach ( $ this -> pageList -> getPages ( ) as $ pageName ) { $ result [ ] = $ this -> pageList -> getPage ( $ pageName ) -> getJSON ( ) ; } } $ this -> environment -> sendJSONResult ( $ result ) ; }
3323	protected function consumeOptionToken ( Option $ spec , $ arg , $ next , & $ success = false ) { if ( $ spec -> isFlag ( ) ) { if ( $ spec -> isIncremental ( ) ) { $ spec -> increaseValue ( ) ; } else { $ spec -> setValue ( true ) ; } return 0 ; } else if ( $ spec -> isRequired ( ) ) { if ( $ next && ! $ next -> isEmpty ( ) && ! $ next -> anyOfOptions ( $ this -> specs ) ) { $ spec -> setValue ( $ next -> arg ) ; return 1 ; } else { throw new RequireValueException ( "Option '{$arg->getOptionName()}' requires a value." ) ; } } else if ( $ spec -> isMultiple ( ) ) { if ( $ next && ! $ next -> isEmpty ( ) && ! $ next -> anyOfOptions ( $ this -> specs ) ) { $ this -> pushOptionValue ( $ spec , $ arg , $ next ) ; return 1 ; } } else if ( $ spec -> isOptional ( ) && $ next && ! $ next -> isEmpty ( ) && ! $ next -> anyOfOptions ( $ this -> specs ) ) { $ spec -> setValue ( $ next -> arg ) ; return 1 ; } return 0 ; }
7279	public function file ( $ name = null ) { return ! $ name ? $ this -> files : ( $ this -> files [ $ name ] ?? null ) ; }
1040	public function processPsrRequest ( ServerRequestInterface $ request , ResponseInterface $ response , StreamInterface $ writableBodyStream ) { $ result = $ this -> executePsrRequest ( $ request ) ; return $ this -> helper -> toPsrResponse ( $ result , $ response , $ writableBodyStream ) ; }
2201	public static function initialize ( ) { $ _GET = static :: cleanKey ( $ _GET ) ; $ _POST = static :: cleanKey ( $ _POST ) ; $ _COOKIE = static :: cleanKey ( $ _COOKIE ) ; }
7863	protected function drawCenteredChar ( $ character ) { $ spaces = str_repeat ( ' ' , $ this -> geometry -> getHalfWidth ( ) ) ; $ this -> drawRow ( $ spaces . $ character ) ; }
9463	public function compose ( View $ view ) { $ this -> sidebar -> loadItemsFromConfig ( 'arcanesoft.foundation.sidebar.items' ) ; $ this -> sidebar -> setCurrent ( Arr :: get ( $ view -> getData ( ) , 'current_page' , '' ) ) ; }
6638	protected function initContainer ( $ module ) { $ map = [ ] ; $ defaultClassMap = [ 'AddPermissionForm' => AddPermissionForm :: class , 'AssignRoleForm' => AssignRoleForm :: class , 'LoginForm' => LoginForm :: class , 'RequestPasswordResetForm' => RequestPasswordResetForm :: class , 'ResetPasswordForm' => ResetPasswordForm :: class , 'AuthAssignment' => AuthAssignment :: class , 'AuthItem' => AuthItem :: class , 'AuthItemChild' => AuthItemChild :: class , 'AuthRule' => AuthRule :: class , 'Message' => Message :: class , 'SourceMessage' => SourceMessage :: class , 'User' => User :: class , 'MessageQuery' => MessageQuery :: class , 'SourceMessageQuery' => SourceMessageQuery :: class , 'UserQuery' => UserQuery :: class , 'SourceMessageSearch' => SourceMessageSearch :: class , 'UserSearch' => UserSearch :: class , ] ; $ routes = [ 'mrstroz\\wavecms\\forms' => [ 'AddPermissionForm' , 'AssignRoleForm' , 'LoginForm' , 'RequestPasswordResetForm' , 'ResetPasswordForm' , ] , 'mrstroz\\wavecms\\models' => [ 'AuthAssignment' , 'AuthItem' , 'AuthItemChild' , 'AuthRule' , 'Message' , 'SourceMessage' , 'User' , ] , 'mrstroz\\wavecms\\models\\query' => [ 'MessageQuery' , 'SourceMessageQuery' , 'UserQuery' , ] , 'mrstroz\\wavecms\\models\\search' => [ 'SourceMessageSearch' , 'UserSearch' , ] ] ; $ mapping = array_merge ( $ defaultClassMap , $ module -> classMap ) ; foreach ( $ mapping as $ name => $ definition ) { $ map [ $ this -> getContainerRoute ( $ routes , $ name ) . "\\$name" ] = $ definition ; } $ di = Yii :: $ container ; foreach ( $ map as $ class => $ definition ) { if ( ! $ di -> has ( $ class ) ) { $ di -> set ( $ class , $ definition ) ; } } }
184	public function init ( ) { parent :: init ( ) ; $ this -> cache = $ this -> enabled ? Instance :: ensure ( $ this -> cache , 'yii\caching\CacheInterface' ) : null ; if ( $ this -> cache instanceof CacheInterface && $ this -> getCachedContent ( ) === false ) { $ this -> getView ( ) -> pushDynamicContent ( $ this ) ; ob_start ( ) ; ob_implicit_flush ( false ) ; } }
616	public function setDefinitions ( array $ definitions ) { foreach ( $ definitions as $ class => $ definition ) { if ( is_array ( $ definition ) && count ( $ definition ) === 2 && array_values ( $ definition ) === $ definition ) { $ this -> set ( $ class , $ definition [ 0 ] , $ definition [ 1 ] ) ; continue ; } $ this -> set ( $ class , $ definition ) ; } }
1443	protected function replaceApplicationNamespace ( & $ stub ) { $ namespace = rtrim ( $ this -> laravel -> getNamespace ( ) , '\\' ) ; $ stub = str_replace ( 'DummyApplicationNamespace' , $ namespace , $ stub ) ; return $ this ; }
1398	public function error ( $ error , $ defaultStatusCode = null , array $ headers = [ ] ) { if ( is_string ( $ error ) ) { $ error = $ this -> api -> getErrors ( ) -> error ( $ error ) ; } else if ( is_array ( $ error ) ) { $ error = Error :: create ( $ error ) ; } if ( ! $ error instanceof ErrorInterface ) { throw new \ InvalidArgumentException ( 'Expecting a string, array or error object.' ) ; } return $ this -> errors ( $ error , $ defaultStatusCode , $ headers ) ; }
9515	private function _initLoggerCascade ( $ configFile , $ loggerName ) { $ err = '' ; try { $ fs = $ this -> _obm -> get ( Filesystem :: class ) ; if ( $ fs -> isAbsolutePath ( $ configFile ) ) { $ fileName = $ configFile ; } else { $ fileName = BP . '/' . $ configFile ; } $ realPath = realpath ( $ fileName ) ; if ( $ realPath ) { Cascade :: fileConfig ( $ realPath ) ; $ this -> _logger = Cascade :: getLogger ( $ loggerName ) ; } else { $ err = "Cannot open logging configuration file '$fileName'. Default Magento logger is used." ; } } catch ( \ Exception $ e ) { $ err = $ e -> getMessage ( ) ; } finally { if ( is_null ( $ this -> _logger ) ) { $ this -> _logger = $ this -> _obm -> get ( \ Magento \ Framework \ Logger \ Monolog :: class ) ; $ this -> warning ( $ err ) ; } } }
7136	public function merge ( Margin $ margin ) : void { $ this -> purchaseCost += $ margin -> getPurchaseCost ( ) ; $ this -> sellingPrice += $ margin -> getSellingPrice ( ) ; $ this -> average = $ this -> average || $ margin -> isAverage ( ) ; }
11197	public function add ( $ item , $ key = false , $ dataKey = false ) { $ keyPrefix = '' ; if ( is_array ( $ dataKey ) ) { $ keyPrefix = $ dataKey [ 1 ] ; $ dataKey = $ dataKey [ 0 ] ; } if ( is_object ( $ item ) ) { if ( $ key ) { if ( ! isset ( $ this -> key ) ) { $ this -> size += 1 ; } $ this -> singleton -> $ key = $ item ; } else if ( $ dataKey && isset ( $ item -> $ dataKey ) ) { $ key = $ item -> $ dataKey ; if ( ! isset ( $ this -> key ) ) { $ this -> size += 1 ; } $ this -> singleton -> { $ keyPrefix . $ key } = $ item ; } else { $ offset = '_item' . $ this -> size ; $ this -> size += 1 ; $ this -> singleton -> { "$offset" } = $ item ; } } else if ( is_array ( $ item ) ) { if ( $ key ) { if ( ! isset ( $ this -> key ) ) { $ this -> size += 1 ; } $ this -> singleton -> $ key = $ item ; } else if ( $ dataKey && isset ( $ item [ $ dataKey ] ) ) { $ key = $ item [ $ dataKey ] ; if ( ! isset ( $ this -> key ) ) { $ this -> size += 1 ; } $ this -> singleton -> { $ keyPrefix . $ key } = $ item ; } else { $ offset = '_item' . $ this -> size ; $ this -> size += 1 ; $ this -> singleton -> { "$offset" } = $ item ; } } else { if ( $ key ) { if ( ! $ this -> __isset ( $ key ) ) { $ this -> size += 1 ; } $ this -> singleton -> $ key = $ item ; } else { $ offset = '_item' . $ this -> size ; $ this -> size += 1 ; $ this -> singleton -> { "$offset" } = $ item ; } } $ this -> contentModified = true ; return $ this ; }
6417	public static function size ( IteratorAggregate $ iterable ) : int { if ( $ iterable instanceof Countable ) { return $ iterable -> count ( ) ; } return Iterators :: size ( Iterators :: from ( $ iterable -> getIterator ( ) ) ) ; }
12551	public function isSerialized ( ) { if ( ! is_string ( $ this -> serialized ) ) { return false ; } $ this -> serialized = trim ( $ this -> serialized ) ; if ( 'N;' == $ this -> serialized ) { return true ; } $ length = strlen ( $ this -> serialized ) ; if ( $ length < 4 ) { return false ; } if ( ':' !== $ this -> serialized [ 1 ] ) { return false ; } $ lastc = $ this -> serialized [ $ length - 1 ] ; if ( ';' !== $ lastc && '}' !== $ lastc ) { return false ; } $ token = $ this -> serialized [ 0 ] ; switch ( $ token ) { case 's' : if ( '"' !== $ this -> serialized [ $ length - 2 ] ) { return false ; } case 'a' : case 'O' : return ( bool ) preg_match ( "/^{$token}:[0-9]+:/s" , $ this -> serialized ) ; case 'b' : case 'i' : case 'd' : return ( bool ) preg_match ( "/^{$token}:[0-9.E-]+;\$/" , $ this -> serialized ) ; } return false ; }
1797	private function addLocaleToRoute ( Route $ route ) : void { if ( ! $ this -> prependLocale ) { return ; } $ route -> setPath ( '/{_locale}' . $ route -> getPath ( ) ) ; $ route -> addRequirements ( [ '_locale' => '[a-z]{2}(\-[A-Z]{2})?' ] ) ; }
6325	public function stop ( ) { $ fp = @ fopen ( $ this -> _file , 'w' ) ; fwrite ( $ fp , ob_get_contents ( ) ) ; fclose ( $ fp ) ; ob_end_flush ( ) ; }
10253	public function getFullName ( $ gender = null ) { if ( empty ( $ gender ) ) { $ gender = $ this -> getGender ( ) ; } $ person_name = new Entities \ FullName ; $ person_name -> first = $ this -> getFirstName ( $ gender ) ; $ person_name -> middle = $ this -> getMiddleName ( $ gender ) ; $ person_name -> last = $ this -> getLastName ( ) ; $ person_name -> gender = $ gender ; return $ person_name ; }
9308	public function register ( ) { $ app = $ this -> app ; $ app -> bind ( 'Germanazo\CkanApi\CkanApiClient' , function ( ) { $ config = [ 'base_uri' => config ( 'ckan_api.url' ) , 'headers' => [ 'Authorization' => config ( 'ckan_api.api_key' ) ] , ] ; return new CkanApiClient ( new Client ( $ config ) ) ; } ) ; $ app -> alias ( 'Germanazo\CkanApi\CkanApiClient' , 'CkanApi' ) ; }
1488	public function when ( bool $ test , $ decodings ) : self { if ( ! $ test ) { return $ this ; } if ( $ decodings instanceof \ Closure ) { return $ decodings ( $ this ) ; } $ decodings = $ decodings instanceof Decoding ? [ $ decodings ] : $ decodings ; return $ this -> push ( ... $ decodings ) ; }
12324	protected function doExecute ( InputInterface $ input , OutputInterface $ output ) { if ( $ this -> askQuestions ( $ input , $ output ) == static :: RETURN_ERROR ) { return static :: RETURN_ERROR ; } $ data = $ this -> prepareData ( $ input ) ; $ this -> doPreExecuteTasks ( $ input , $ output , $ data ) ; $ return = $ this -> executeTasks ( $ input , $ output , $ data ) ; $ this -> doPostExecuteTasks ( $ input , $ output , $ data , $ return ) ; return $ return ; }
594	private function composeCircularDependencyTrace ( $ circularDependencyName , array $ registered ) { $ dependencyTrace = [ ] ; $ startFound = false ; foreach ( $ registered as $ name => $ value ) { if ( $ name === $ circularDependencyName ) { $ startFound = true ; } if ( $ startFound && $ value === false ) { $ dependencyTrace [ ] = $ name ; } } $ dependencyTrace [ ] = $ circularDependencyName ; return implode ( ' -> ' , $ dependencyTrace ) ; }
130	protected function requestXml ( $ origin , $ path ) { $ xml = simplexml_load_string ( $ this -> requestContent ( $ origin , $ path ) , "SimpleXMLElement" , LIBXML_NOERROR ) ; if ( false === $ xml ) { throw new \ UnexpectedValueException ( sprintf ( 'The PEAR channel at ' . $ origin . ' is broken. (Invalid XML at file `%s`)' , $ path ) ) ; } return $ xml ; }
1739	public function generate ( ) { if ( TL_MODE == 'BE' ) { $ objTemplate = new BackendTemplate ( 'be_wildcard' ) ; $ objTemplate -> wildcard = '### ' . Utf8 :: strtoupper ( $ GLOBALS [ 'TL_LANG' ] [ 'FMD' ] [ 'login' ] [ 0 ] ) . ' ###' ; $ objTemplate -> title = $ this -> headline ; $ objTemplate -> id = $ this -> id ; $ objTemplate -> link = $ this -> name ; $ objTemplate -> href = 'contao/main.php?do=themes&amp;table=tl_module&amp;act=edit&amp;id=' . $ this -> id ; return $ objTemplate -> parse ( ) ; } if ( ! $ _POST && $ this -> redirectBack && ( $ strReferer = $ this -> getReferer ( ) ) != Environment :: get ( 'request' ) ) { $ _SESSION [ 'LAST_PAGE_VISITED' ] = $ strReferer ; } return parent :: generate ( ) ; }
8362	public static function registerTranslations ( $ baseDir , $ localesDir , $ prefix = null ) { if ( self :: $ isInit === true ) { $ dir = $ baseDir . DIRECTORY_SEPARATOR . $ localesDir ; if ( is_dir ( $ dir ) === false ) { throw new InvalidDirectory ( 'directory "' . $ dir . '" can\'t be identified' ) ; } $ language = self :: $ currentLanguage ; if ( ( $ pos = strpos ( $ language , '-' ) ) !== false ) { $ pos = ( int ) $ pos ; $ language = substr ( $ language , 0 , $ pos ) ; } if ( ( $ pos = strpos ( $ language , '_' ) ) !== false ) { $ pos = ( int ) $ pos ; $ language = substr ( $ language , 0 , $ pos ) ; } if ( is_readable ( $ dir . DIRECTORY_SEPARATOR . $ language . '.yml' ) === true ) { $ newOnes = Config :: get ( $ dir . DIRECTORY_SEPARATOR . $ language . '.yml' ) ; if ( is_array ( $ newOnes ) === true ) { if ( $ prefix != null ) { $ newOnes = array ( $ prefix => $ newOnes ) ; } self :: $ translations = array_merge ( self :: $ translations , $ newOnes ) ; } } else { Logger :: get ( ) -> notice ( 'can\'t find language "' . $ language . '" in directory "' . $ dir . '"' ) ; } } }
7206	public function addTaxAdjustment ( Adjustment $ tax ) : void { foreach ( $ this -> taxes as $ t ) { if ( $ t -> isSameAs ( $ tax ) ) { $ t -> addAmount ( $ tax -> getAmount ( ) ) ; return ; } } $ this -> taxes [ ] = clone $ tax ; }
11089	public static function isCzechHoliday ( $ date ) { if ( ! $ date instanceof DateTime ) { if ( \ is_int ( $ date ) ) { $ date = new DateTime ( '@' . $ date ) ; } elseif ( \ is_string ( $ date ) ) { $ date = new DateTime ( $ date ) ; } else { throw new RuntimeException ( self :: poorManTranslate ( 'fts-shared' , 'Invalid date format' ) ) ; } } $ holidays = [ '01-01' , '05-01' , '05-08' , '07-05' , '07-06' , '09-28' , '10-28' , '11-17' , '12-24' , '12-25' , '12-26' ] ; if ( \ in_array ( $ date -> format ( 'm-d' ) , $ holidays , true ) ) { return true ; } $ easterDays = easter_days ( $ date -> format ( 'Y' ) ) ; $ easter = new DateTime ( $ date -> format ( 'Y' ) . '-03-21' ) ; $ easter -> add ( new \ DateInterval ( 'P' . $ easterDays . 'D' ) ) ; $ easter -> sub ( new \ DateInterval ( 'P2D' ) ) ; if ( $ date -> format ( 'Y-m-d' ) === $ easter -> format ( 'Y-m-d' ) ) { return true ; } $ easter -> add ( new \ DateInterval ( 'P3D' ) ) ; return ( $ easter -> format ( 'Y-m-d' ) === $ date -> format ( 'Y-m-d' ) ) ; }
7834	protected function getPipesByOption ( $ option ) { $ pipes = $ this -> option ( $ option ) ; preg_match_all ( '/\w+/' , $ pipes , $ matches ) ; return array_map ( 'ucfirst' , $ matches [ 0 ] ) ; }
11195	public function asArray ( ) { $ result = array ( ) ; foreach ( $ this -> collection as $ response ) { $ result [ ] = $ response -> getResultAsArray ( ) ; } return $ result ; }
3294	protected function buildLink ( $ provider , $ url ) { $ fontAwesomeVersion = config ( 'laravel-share.fontAwesomeVersion' , 4 ) ; $ this -> html .= trans ( "laravel-share::laravel-share-fa$fontAwesomeVersion.$provider" , [ 'url' => $ url , 'class' => key_exists ( 'class' , $ this -> options ) ? $ this -> options [ 'class' ] : '' , 'id' => key_exists ( 'id' , $ this -> options ) ? $ this -> options [ 'id' ] : '' , ] ) ; }
8156	public function addPath ( $ path , $ namespace = self :: MAIN_NAMESPACE ) { $ this -> cache = $ this -> errorCache = array ( ) ; $ checkPath = $ this -> isAbsolutePath ( $ path ) ? $ path : $ this -> rootPath . $ path ; if ( ! is_dir ( $ checkPath ) ) { throw new Twig_Error_Loader ( sprintf ( 'The "%s" directory does not exist ("%s").' , $ path , $ checkPath ) ) ; } $ this -> paths [ $ namespace ] [ ] = rtrim ( $ path , '/\\' ) ; }
10398	protected function doReplacement ( $ inputString ) { if ( is_string ( $ inputString ) ) { $ inputString = str_replace ( array_keys ( $ this -> replacements ) , array_values ( $ this -> replacements ) , $ inputString ) ; } return $ inputString ; }
7229	public static function create ( $ method , $ url , $ data = "" , array $ headers = [ ] , array $ options = [ ] , $ initOnly = false ) { $ curl = null ; if ( ! strcasecmp ( $ method , "GET" ) ) $ curl = new static ( $ url , $ options + [ CURLOPT_CUSTOMREQUEST => "GET" , CURLOPT_RETURNTRANSFER => true ] , $ headers , $ initOnly ) ; else if ( ! strcasecmp ( $ method , "POST" ) ) $ curl = new static ( $ url , $ options + [ CURLOPT_CUSTOMREQUEST => "POST" , CURLOPT_POSTFIELDS => $ data , CURLOPT_RETURNTRANSFER => true ] , $ headers , $ initOnly ) ; else if ( ! strcasecmp ( $ method , "PUT" ) ) $ curl = new static ( $ url , $ options + [ CURLOPT_CUSTOMREQUEST => "PUT" , CURLOPT_POSTFIELDS => $ data , CURLOPT_RETURNTRANSFER => true ] , $ headers , $ initOnly ) ; else if ( ! strcasecmp ( $ method , "DELETE" ) ) $ curl = new static ( $ url , $ options + [ CURLOPT_CUSTOMREQUEST => "DELETE" , CURLOPT_RETURNTRANSFER => true ] , $ headers , $ initOnly ) ; return $ curl ; }
2036	public function getAbsoluteUrl ( $ strParams = null ) { $ this -> loadDetails ( ) ; $ objUrlGenerator = System :: getContainer ( ) -> get ( 'contao.routing.url_generator' ) ; $ strUrl = $ objUrlGenerator -> generate ( ( $ this -> alias ? : $ this -> id ) . $ strParams , array ( '_locale' => $ this -> rootLanguage , '_domain' => $ this -> domain , '_ssl' => ( bool ) $ this -> rootUseSSL , ) , UrlGeneratorInterface :: ABSOLUTE_URL ) ; $ strUrl = $ this -> applyLegacyLogic ( $ strUrl , $ strParams ) ; return $ strUrl ; }
9088	public function slurp ( ) : string { $ str = "" ; while ( $ this -> ready ( ) ) { $ str .= $ this -> read ( $ this -> count ( ) ) ; } return $ str ; }
10809	protected function __templates ( $ customTemplate = null , $ customTemplateSuffix = null ) { $ templates = SSViewer :: get_templates_by_class ( $ this -> class , $ customTemplateSuffix , \ FormField :: class ) ; if ( ! $ templates ) { throw new \ Exception ( "No template found for {$this->class}" ) ; } if ( $ customTemplate ) { array_unshift ( $ templates , $ customTemplate ) ; } return $ templates ; }
4153	public function invalidateBearerToken ( ) { $ url = $ this -> getInvalidateBearerTokenUrl ( ) ; $ bearerToken = $ this -> bearerToken ; if ( $ bearerToken === null ) { $ bearerToken = $ this -> getBearerToken ( ) ; } $ params = array ( 'post' => array ( 'access_token' => $ bearerToken ) , 'headers' => $ this -> buildBearerTokenHeader ( ) , ) ; $ response = $ this -> curl -> send ( $ url , $ params ) ; $ obj = json_decode ( $ response [ 'body' ] ) ; if ( ! $ obj || ! isset ( $ obj -> access_token ) || $ obj -> access_token != $ bearerToken ) { $ this -> findExceptions ( $ response ) ; } unset ( $ url , $ bearerToken , $ params , $ response , $ obj ) ; return true ; }
12062	protected function migrate ( Module $ module ) { $ path = str_replace ( base_path ( ) , '' , ( new Migrator ( $ module ) ) -> getPath ( ) ) ; if ( $ this -> option ( 'subpath' ) ) { $ path = $ path . "/" . $ this -> option ( "subpath" ) ; } $ this -> call ( 'migrate' , [ '--path' => $ path , '--database' => $ this -> option ( 'database' ) , '--pretend' => $ this -> option ( 'pretend' ) , '--force' => $ this -> option ( 'force' ) , ] ) ; if ( $ this -> option ( 'seed' ) ) { $ this -> call ( 'component:seed' , [ 'module' => $ module -> getName ( ) ] ) ; } }
4750	public function filterPlans ( array $ plans , array $ filters ) : array { foreach ( $ filters as $ key => $ filter ) { if ( array_key_exists ( $ key , current ( $ plans ) ) ) { $ plans = array_filter ( $ plans , function ( $ element ) use ( $ key , $ filter ) { return $ element [ $ key ] == $ filter ; } ) ; } } return $ plans ; }
4407	public function getCurrentMenuPlugin ( ) { $ currentRequest = $ this -> requestStack -> getCurrentRequest ( ) ; if ( ! $ currentRequest instanceof Request ) { return false ; } foreach ( $ this -> menuPluginRegistry -> getMenuPlugins ( ) as $ identifier => $ menuPlugin ) { if ( $ menuPlugin -> matches ( $ currentRequest ) ) { return $ identifier ; } } return false ; }
12765	public function addByHttpCode ( int $ code ) : self { $ serverProtocol = filter_input ( \ INPUT_SERVER , 'SERVER_PROTOCOL' , \ FILTER_SANITIZE_STRING ) ; $ protocol = ! empty ( $ serverProtocol ) ? $ serverProtocol : 'HTTP/1.1' ; $ sHeader = "{$protocol} {$code} " . self :: getHTTPExplanationByCode ( $ code ) ; return $ this -> add ( $ sHeader ) ; }
1134	public function storeNewParent ( ) { if ( $ this -> isDirty ( $ this -> getParentColumnName ( ) ) && ( $ this -> exists || ! $ this -> isRoot ( ) ) ) static :: $ moveToNewParentId = $ this -> getParentId ( ) ; else static :: $ moveToNewParentId = FALSE ; }
11264	public function repeat ( & $ property , $ repeatTag , $ classes = '' , $ outerTag = false , $ outerClasses = '' ) { if ( isset ( $ property ) ) { $ output = '' ; if ( $ outerTag ) { $ output .= '<' . $ outerTag . ' class="' . $ outerClasses . '">' ; } if ( is_array ( $ property ) ) { foreach ( $ property as $ value ) { $ output .= '<' . $ repeatTag . ' class="' . $ classes . '">' ; $ output .= $ value ; $ output .= '</' . $ repeatTag . '>' ; } } else { $ output .= '<' . $ repeatTag . ' class="' . $ classes . '">' ; $ output .= $ property ; $ output .= '</' . $ repeatTag . '>' ; } if ( $ outerTag ) { $ output .= '</' . $ outerTag . '>' ; } echo $ output ; } else echo '' ; }
1205	protected function renderItem ( ItemInterface $ item , array $ options ) { if ( ! $ item -> isDisplayed ( ) ) { return '' ; } $ class = ( array ) $ item -> getAttribute ( 'class' ) ; if ( $ this -> matcher -> isCurrent ( $ item ) ) { $ class [ ] = $ options [ 'currentClass' ] ; } elseif ( $ this -> matcher -> isAncestor ( $ item , $ options [ 'matchingDepth' ] ) ) { $ class [ ] = $ options [ 'ancestorClass' ] ; } if ( $ item -> actsLikeFirst ( ) ) { $ class [ ] = $ options [ 'firstClass' ] ; } if ( $ item -> actsLikeLast ( ) ) { $ class [ ] = $ options [ 'lastClass' ] ; } if ( $ item -> hasChildren ( ) && $ options [ 'depth' ] !== 0 ) { if ( null !== $ options [ 'branch_class' ] && $ item -> getDisplayChildren ( ) ) { $ class [ ] = $ options [ 'branch_class' ] ; } } elseif ( null !== $ options [ 'leaf_class' ] ) { $ class [ ] = $ options [ 'leaf_class' ] ; } $ attributes = $ item -> getAttributes ( ) ; if ( ! empty ( $ class ) ) { $ attributes [ 'class' ] = implode ( ' ' , $ class ) ; } $ html = $ this -> format ( '<li' . $ this -> renderHtmlAttributes ( $ attributes ) . '>' , 'li' , $ item -> getLevel ( ) , $ options ) ; $ html .= $ this -> renderLink ( $ item , $ options ) ; $ childrenClass = ( array ) $ item -> getChildrenAttribute ( 'class' ) ; $ childrenClass [ ] = 'menu_level_' . $ item -> getLevel ( ) ; $ childrenAttributes = $ item -> getChildrenAttributes ( ) ; $ childrenAttributes [ 'class' ] = implode ( ' ' , $ childrenClass ) ; $ html .= $ this -> renderList ( $ item , $ childrenAttributes , $ options ) ; $ html .= $ this -> format ( '</li>' , 'li' , $ item -> getLevel ( ) , $ options ) ; return $ html ; }
1026	private function doesFragmentConditionMatch ( $ fragment , ObjectType $ type ) { $ typeConditionNode = $ fragment -> typeCondition ; if ( $ typeConditionNode === null ) { return true ; } $ conditionalType = TypeInfo :: typeFromAST ( $ this -> exeContext -> schema , $ typeConditionNode ) ; if ( $ conditionalType === $ type ) { return true ; } if ( $ conditionalType instanceof AbstractType ) { return $ this -> exeContext -> schema -> isPossibleType ( $ conditionalType , $ type ) ; } return false ; }
505	public function init ( ) { parent :: init ( ) ; if ( ! isset ( $ this -> translations [ 'yii' ] ) && ! isset ( $ this -> translations [ 'yii*' ] ) ) { $ this -> translations [ 'yii' ] = [ 'class' => 'yii\i18n\PhpMessageSource' , 'sourceLanguage' => 'en-US' , 'basePath' => '@yii/messages' , ] ; } if ( ! isset ( $ this -> translations [ 'app' ] ) && ! isset ( $ this -> translations [ 'app*' ] ) ) { $ this -> translations [ 'app' ] = [ 'class' => 'yii\i18n\PhpMessageSource' , 'sourceLanguage' => Yii :: $ app -> sourceLanguage , 'basePath' => '@app/messages' , ] ; } }
12115	public static function getExceptionTree ( \ Throwable $ Throwable ) { $ exception = get_class ( $ Throwable ) ; for ( $ exception_tree [ ] = $ exception ; $ exception = get_parent_class ( $ exception ) ; $ exception_tree [ ] = $ exception ) { ; } $ exception_tree = array_reverse ( $ exception_tree ) ; if ( count ( $ exception_tree ) > 1 ) { array_shift ( $ exception_tree ) ; } return $ exception_tree ; }
12205	public function generate ( $ date = 'global' , Response $ response = null ) { if ( ! $ response ) $ response = new Response ; if ( $ this -> maxAge ) $ response -> setMaxAge ( $ this -> maxAge ) ; if ( $ this -> sharedMaxAge ) $ response -> setSharedMaxAge ( $ this -> sharedMaxAge ) ; if ( $ date instanceof \ DateTime ) { $ response -> setLastModified ( $ date ) ; } else { $ response -> setLastModified ( $ this -> manager -> getLastUpdate ( $ date ) ) ; } return $ response ; }
5587	public function getCookies ( ) { $ lstCookies = $ this -> cookie_jar -> getCookies ( ) ; $ aCookies = [ ] ; foreach ( $ lstCookies as $ oCookies ) { $ aCookies [ ] = [ 'name' => $ oCookies -> getName ( ) , 'value' => $ oCookies -> getValue ( ) , 'host' => $ oCookies -> getHost ( ) , 'path' => $ oCookies -> getPath ( ) , 'expiry' => $ oCookies -> getExpiry ( ) , ] ; } return $ aCookies ; }
205	public static function wrapText ( $ text , $ indent = 0 , $ refresh = false ) { $ size = static :: getScreenSize ( $ refresh ) ; if ( $ size === false || $ size [ 0 ] <= $ indent ) { return $ text ; } $ pad = str_repeat ( ' ' , $ indent ) ; $ lines = explode ( "\n" , wordwrap ( $ text , $ size [ 0 ] - $ indent , "\n" , true ) ) ; $ first = true ; foreach ( $ lines as $ i => $ line ) { if ( $ first ) { $ first = false ; continue ; } $ lines [ $ i ] = $ pad . $ line ; } return implode ( "\n" , $ lines ) ; }
10532	public function valid ( ) { if ( $ this -> items === null ) { return false ; } $ key = key ( $ this -> items ) ; return ( $ key !== null && $ key !== false ) ; }
5286	private function reset ( ) { $ this -> distinct = false ; $ this -> found_rows = false ; $ this -> limit = null ; $ this -> statements = [ 'select' => [ ] , 'wheres' => [ ] , 'orders' => [ ] , 'values' => [ ] , 'groups' => [ ] , 'having' => '' , ] ; return $ this ; }
852	public function getMeaningfulTokenSibling ( $ index , $ direction ) { return $ this -> getTokenNotOfKindSibling ( $ index , $ direction , [ [ T_WHITESPACE ] , [ T_COMMENT ] , [ T_DOC_COMMENT ] ] ) ; }
4765	protected function validateRegistrationOptin ( ) { $ return = true ; $ optin = ( int ) $ this -> getRequestParameter ( 'oegdproptin_userregistration' ) ; $ registrationOption = ( int ) $ this -> getRequestParameter ( 'option' ) ; if ( \ OxidEsales \ Eshop \ Core \ Registry :: getConfig ( ) -> getConfigParam ( 'blOeGdprOptinUserRegistration' ) && ( 3 == $ registrationOption ) && ( 1 !== $ optin ) ) { $ return = false ; } return $ return ; }
12463	public function newAction ( ) { $ entity = new CustomFieldsGroup ( ) ; $ form = $ this -> createCreateForm ( $ entity ) ; return $ this -> render ( 'ChillCustomFieldsBundle:CustomFieldsGroup:new.html.twig' , array ( 'entity' => $ entity , 'form' => $ form -> createView ( ) , ) ) ; }
2016	public function generateMarkup ( ) { $ return = ' <div> <input type="file" name="' . $ this -> strName . '[]" class="tl_upload_field" onfocus="Backend.getScrollOffset()" multiple required> </div>' ; if ( isset ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_files' ] [ 'fileupload' ] [ 1 ] ) ) { $ return .= ' <p class="tl_help tl_tip">' . sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_files' ] [ 'fileupload' ] [ 1 ] , System :: getReadableSize ( static :: getMaxUploadSize ( ) ) , Config :: get ( 'gdMaxImgWidth' ) . 'x' . Config :: get ( 'gdMaxImgHeight' ) ) . '</p>' ; } return $ return ; }
6427	public function getUserProfile ( ) { $ client = $ this -> getClient ( ) ; $ client -> setAccessToken ( $ this -> access_token ) ; $ plus = new \ Google_Service_Plus ( $ client ) ; $ oauth2 = new \ Google_Service_Oauth2 ( $ client ) ; if ( $ client -> getAccessToken ( ) ) { $ user = $ oauth2 -> userinfo -> get ( ) ; if ( isset ( $ user -> id ) ) { $ name = $ user -> givenName ; if ( ! empty ( $ user -> familyName ) ) { $ name = $ user -> familyName . ' ' . $ user -> givenName ; } $ profile = array ( 'userid' => $ user -> id , 'name' => $ name , 'imageurl' => $ user -> picture , 'email' => $ user -> email ) ; return $ profile ; } } throw new \ Exception ( 'Can not get google profile' ) ; }
5801	protected function getDeleteCell ( bool $ showDeleteLink , ? string $ primaryKeyValue ) : string { if ( $ showDeleteLink && $ this -> deleteRoute == null ) { throw new \ Exception ( "Must have deleteRoute" ) ; } if ( $ showDeleteLink && $ primaryKeyValue === null ) { throw new \ Exception ( "Must have primaryKeyValue to delete" ) ; } $ cellValue = ( $ showDeleteLink ) ? '<a href="' . $ this -> router -> pathFor ( $ this -> deleteRoute , [ "primaryKey" => $ primaryKeyValue ] ) . '" title="delete" onclick="return confirm(\'Are you sure you want to delete ' . $ primaryKeyValue . '?\');">X</a>' : '&nbsp;' ; return '<td>' . $ cellValue . '</td>' ; }
8171	public function renderString ( $ tplString = '' , $ tplData = [ ] ) { try { return $ this -> twig -> createTemplate ( $ tplString ) -> render ( $ tplData ) ; } catch ( Twig_Error $ err ) { return $ this -> error ( $ err , false , $ tplString ) ; } }
6557	protected function mapLogLevelToStyle ( $ logLevel ) { if ( isset ( $ this -> logLevelStyleMapping [ $ logLevel ] ) ) { return $ this -> logLevelStyleMapping [ $ logLevel ] ; } return Simple :: DEFAULT_STYLE ; }
8807	public function set ( $ key , $ value , $ time = 0 ) { if ( is_array ( $ key ) ) { foreach ( $ key as $ k => $ v ) { setcookie ( $ k , $ v , ( $ time == 0 ? 0 : time ( ) + $ time ) , '/' ) ; $ _COOKIE [ $ k ] = $ v ; } } else { setcookie ( $ key , $ value , ( $ time == 0 ? 0 : time ( ) + $ time ) , '/' ) ; $ _COOKIE [ $ key ] = $ value ; } return ; }
12872	public function setElementRequired ( \ Zend \ Form \ Element $ element ) { $ element -> setAttribute ( 'required' , 'true' ) ; $ this -> form -> getInputFilter ( ) -> get ( $ element -> getAttribute ( 'name' ) ) -> setAllowEmpty ( false ) ; }
3289	public function start ( ) : Promise { if ( $ this -> handle ) { throw new StatusError ( "Process has already been started." ) ; } return call ( function ( ) { $ this -> handle = $ this -> processRunner -> start ( $ this -> command , $ this -> cwd , $ this -> env , $ this -> options ) ; return $ this -> pid = yield $ this -> handle -> pidDeferred -> promise ( ) ; } ) ; }
542	protected function serializeModels ( array $ models ) { list ( $ fields , $ expand ) = $ this -> getRequestedFields ( ) ; foreach ( $ models as $ i => $ model ) { if ( $ model instanceof Arrayable ) { $ models [ $ i ] = $ model -> toArray ( $ fields , $ expand ) ; } elseif ( is_array ( $ model ) ) { $ models [ $ i ] = ArrayHelper :: toArray ( $ model ) ; } } return $ models ; }
3664	private function getValueFromSource ( $ source , $ valueName , $ arguments ) { switch ( strtolower ( $ source ) ) { case 'get' : return $ this -> container -> get ( Input :: class ) -> get ( $ valueName ) ; case 'post' : return $ this -> container -> get ( Input :: class ) -> post ( $ valueName ) ; case 'cookie' : return $ this -> container -> get ( Input :: class ) -> cookie ( $ valueName ) ; case 'session' : return $ this -> container -> get ( Session :: class ) -> get ( $ valueName ) ; case 'filter' : if ( is_array ( $ this -> filterParameters ) ) { if ( array_key_exists ( $ valueName , $ this -> filterParameters ) ) { return $ this -> filterParameters [ $ valueName ] ; } return null ; } break ; case 'container' : @ trigger_error ( 'Getting filter values from the service container is deprecated, the container will get removed.' , E_USER_DEPRECATED ) ; return $ this -> getValueFromServiceContainer ( $ valueName , $ arguments ) ; default : } return null ; }
8763	public function delete ( $ server_filename ) { $ upload_path = config ( 'dropzoner.upload-path' ) ; $ full_path = $ upload_path . $ server_filename ; if ( \ File :: exists ( $ full_path ) ) { \ File :: delete ( $ full_path ) ; } event ( new ImageWasDeleted ( $ server_filename ) ) ; return response ( ) -> json ( [ 'error' => false , 'code' => 200 ] , 200 ) ; }
8669	protected function computeFileSystemDifferences ( ) { $ entityPathByFilesystems = [ ] ; foreach ( $ this -> resourceManager -> getResourceConfigurations ( ) as $ resourceConfiguration ) { $ className = $ resourceConfiguration -> getEntity ( ) ; $ entityManager = $ this -> doctrine -> getManagerForClass ( $ className ) ; if ( ! $ entityManager instanceof EntityManagerInterface ) { throw new \ UnexpectedValueException ( "No manager found for class {$className}" ) ; } $ repository = $ entityManager -> getRepository ( $ className ) ; if ( ! $ repository instanceof ResourceRepositoryInterface ) { throw new \ UnexpectedValueException ( "Repository for class {$className} must implement ResourceRepositoryInterface" ) ; } $ paths = $ repository -> getPaths ( ) ; $ adapterReference = $ this -> adaptersByResourceType [ $ resourceConfiguration -> getCode ( ) ] ; if ( array_key_exists ( $ adapterReference , $ entityPathByFilesystems ) ) { $ entityPathByFilesystems [ $ adapterReference ] = array_merge ( $ entityPathByFilesystems [ $ adapterReference ] , $ paths ) ; } else { $ entityPathByFilesystems [ $ adapterReference ] = $ paths ; } } foreach ( $ this -> adapters as $ adapterReference => $ adapter ) { $ existingPaths = [ ] ; foreach ( $ adapter -> listContents ( ) as $ metadata ) { $ entityPath = $ metadata [ 'path' ] ; if ( '.gitkeep' === $ entityPath ) { continue ; } $ existingPaths [ $ entityPath ] = $ entityPath ; } $ entityPaths = $ entityPathByFilesystems [ $ adapterReference ] ; $ this -> extraFiles [ $ adapterReference ] = array_diff_key ( $ existingPaths , $ entityPaths ) ; $ this -> missingFiles [ $ adapterReference ] = array_diff_key ( $ entityPaths , $ existingPaths ) ; } }
10687	private function setCreatePermissions ( ) { if ( $ this -> config -> has ( 'io' , 'group' ) ) Path :: setDefaultFileGroup ( $ this -> config -> get ( 'io' , 'group' ) ) ; $ file_mode = ( int ) $ this -> config -> get ( 'io' , 'file_mode' ) ; if ( $ file_mode ) { $ of = $ file_mode ; $ file_mode = octdec ( sprintf ( "%04d" , $ file_mode ) ) ; Path :: setDefaultFileMode ( $ file_mode ) ; } $ dir_mode = ( int ) $ this -> config -> get ( 'io' , 'dir_mode' ) ; if ( $ dir_mode ) { $ of = $ dir_mode ; $ dir_mode = octdec ( sprintf ( "%04d" , $ dir_mode ) ) ; Path :: setDefaultDirMode ( $ dir_mode ) ; } }
11847	final public function save ( ) { $ this -> checkReadOnly ( ) ; $ this -> _save ( ) ; if ( count ( $ this -> _errors ) ) { throw new Zend_Db_Table_Row_Exception ( 'This row contain errors.' ) ; } foreach ( $ this -> _data as $ column => & $ value ) { if ( $ value instanceof DateTime ) { if ( ! ( $ value instanceof Benri_Util_DateTime ) ) { $ value = new Benri_Util_DateTime ( $ value -> format ( 'U' ) ) ; } $ value -> setFormat ( 'Y-m-d H:i:s' ) ; } } if ( $ this -> isNewRecord ( ) ) { if ( $ this -> offsetExists ( 'created_at' ) ) { $ this -> created_at = new Benri_Util_DateTime ( ) ; $ this -> created_at -> setFormat ( 'Y-m-d H:i:s' ) ; } } if ( $ this -> offsetExists ( 'updated_at' ) ) { $ this -> updated_at = new Benri_Util_DateTime ( ) ; $ this -> updated_at -> setFormat ( 'Y-m-d H:i:s' ) ; } parent :: save ( ) ; $ this -> _postSave ( ) ; return $ this ; }
8836	public function setMaxRetries ( $ retries ) { switch ( gettype ( $ retries ) ) { case 'integer' : $ this -> maxRetries = new Retries ( $ retries ) ; break ; case 'object' : $ this -> maxRetries = $ retries ; break ; default : throw new InvalidArgumentException ( 'Invalid type for max retries given.' ) ; break ; } }
680	protected function validateConjunctionCondition ( $ operator , $ condition ) { if ( ! is_array ( $ condition ) || ! ArrayHelper :: isIndexed ( $ condition ) ) { $ this -> addError ( $ this -> filterAttributeName , $ this -> parseErrorMessage ( 'operatorRequireMultipleOperands' , [ 'operator' => $ operator ] ) ) ; return ; } foreach ( $ condition as $ part ) { $ this -> validateCondition ( $ part ) ; } }
7550	function wrapInner ( $ node , $ start = 0 , $ end = - 1 , $ wrap_index = - 1 , $ node_index = null ) { if ( $ end < 0 ) { $ end += count ( $ this -> children ) ; } if ( $ node_index === null ) { $ node_index = $ end + 1 ; } if ( ! is_object ( $ node ) ) { $ node = $ this -> addChild ( $ node , $ node_index ) ; } elseif ( $ node -> parent !== $ this ) { $ node -> changeParent ( $ this -> parent , $ node_index ) ; } $ this -> moveChildren ( $ node , $ wrap_index , $ start , $ end ) ; return $ node ; }
6948	private function setDueParameters ( $ query ) { $ query -> setParameter ( 'trigger_invoiced' , Trigger :: TRIGGER_INVOICED ) -> setParameter ( 'state_invoiced' , [ InvoiceStates :: STATE_PARTIAL , InvoiceStates :: STATE_COMPLETED ] ) -> setParameter ( 'trigger_fully_invoiced' , Trigger :: TRIGGER_FULLY_INVOICED ) -> setParameter ( 'state_fully_invoiced' , InvoiceStates :: STATE_COMPLETED ) -> setParameter ( 'trigger_shipped' , Trigger :: TRIGGER_SHIPPED ) -> setParameter ( 'state_shipped' , [ ShipmentStates :: STATE_PARTIAL , ShipmentStates :: STATE_COMPLETED ] ) -> setParameter ( 'trigger_fully_shipped' , Trigger :: TRIGGER_FULLY_SHIPPED ) -> setParameter ( 'state_fully_shipped' , ShipmentStates :: STATE_COMPLETED ) ; }
7018	private function format_h ( & $ str ) { if ( strstr ( $ str , '%h' ) ) { $ h = $ this -> hour > 12 ? $ this -> hour - 12 : $ this -> hour ; $ str = str_replace ( '%h' , sprintf ( '%02d' , $ h ) , $ str ) ; } }
2658	public function getResponse ( $ version , $ name ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/response_object/' . $ name ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: GET ) ; return $ result ; }
335	protected function createColumn ( $ column ) { $ c = $ this -> createColumnSchema ( ) ; $ c -> name = $ column [ 'COLUMN_NAME' ] ; $ c -> allowNull = $ column [ 'NULLABLE' ] === 'Y' ; $ c -> comment = $ column [ 'COLUMN_COMMENT' ] === null ? '' : $ column [ 'COLUMN_COMMENT' ] ; $ c -> isPrimaryKey = false ; $ this -> extractColumnType ( $ c , $ column [ 'DATA_TYPE' ] , $ column [ 'DATA_PRECISION' ] , $ column [ 'DATA_SCALE' ] , $ column [ 'DATA_LENGTH' ] ) ; $ this -> extractColumnSize ( $ c , $ column [ 'DATA_TYPE' ] , $ column [ 'DATA_PRECISION' ] , $ column [ 'DATA_SCALE' ] , $ column [ 'DATA_LENGTH' ] ) ; $ c -> phpType = $ this -> getColumnPhpType ( $ c ) ; if ( ! $ c -> isPrimaryKey ) { if ( stripos ( $ column [ 'DATA_DEFAULT' ] , 'timestamp' ) !== false ) { $ c -> defaultValue = null ; } else { $ defaultValue = $ column [ 'DATA_DEFAULT' ] ; if ( $ c -> type === 'timestamp' && $ defaultValue === 'CURRENT_TIMESTAMP' ) { $ c -> defaultValue = new Expression ( 'CURRENT_TIMESTAMP' ) ; } else { if ( $ defaultValue !== null ) { if ( ( $ len = strlen ( $ defaultValue ) ) > 2 && $ defaultValue [ 0 ] === "'" && $ defaultValue [ $ len - 1 ] === "'" ) { $ defaultValue = substr ( $ column [ 'DATA_DEFAULT' ] , 1 , - 1 ) ; } else { $ defaultValue = trim ( $ defaultValue ) ; } } $ c -> defaultValue = $ c -> phpTypecast ( $ defaultValue ) ; } } } return $ c ; }
12416	static function run_coding_style_report ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { $ opts = self :: getOpts ( @ $ args [ 0 ] , @ $ args [ 1 ] , $ cliopts ) ; if ( ! SharedLock :: acquire ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ) throw new PakeException ( "Source code locked by another process" ) ; $ destdir = self :: getReportDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ; $ phpcs = self :: getTool ( 'phpcs' , $ opts , true ) ; $ rulesDir = self :: getVendorDir ( ) . '/squizlabs/php_codesniffer/Codesniffer/Standards/' . $ opts [ 'tools' ] [ 'phpcs' ] [ 'rules' ] ; if ( ! is_dir ( $ rulesDir ) ) { if ( $ opts [ 'tools' ] [ 'phpcs' ] [ 'rules' ] == 'ezcs' ) { $ sourceDir = self :: getVendorDir ( ) . '/ezsystems/ezcs/php/ezcs' ; if ( is_dir ( $ sourceDir ) ) { pake_symlink ( $ sourceDir , $ rulesDir ) ; } } } try { $ out = pake_sh ( "$phpcs --standard=" . escapeshellarg ( $ opts [ 'tools' ] [ 'phpcs' ] [ 'rules' ] ) . " " . "--report=" . escapeshellarg ( $ opts [ 'tools' ] [ 'phpcs' ] [ 'format' ] ) . " " . "--extensions=php " . escapeshellarg ( self :: getBuildDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ) ) ; } catch ( pakeException $ e ) { $ out = preg_replace ( '/^Problem executing command/' , '' , $ e -> getMessage ( ) ) ; } pake_mkdirs ( $ destdir ) ; pake_write_file ( $ destdir . '/phpcs.txt' , $ out , true ) ; SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; }
5884	protected function _normalizeConfig ( $ orders ) { if ( empty ( $ orders ) ) { $ orders = [ [ ] ] ; } elseif ( isset ( $ orders [ 'order' ] ) || isset ( $ orders [ 'callback' ] ) ) { $ orders = [ $ orders ] ; } $ default = [ 'order' => $ this -> _table -> aliasField ( $ this -> _table -> getDisplayField ( ) ) , 'callback' => null , ] ; foreach ( $ orders as $ key => $ value ) { $ orders [ $ key ] = $ orders [ $ key ] + $ default ; } $ this -> _config = [ 'orders' => $ orders , ] ; }
6689	public function setSessionAndRedirect ( $ key , $ value , $ redirectUrl ) { $ this -> getSession ( ) -> set ( $ key , $ value ) ; return $ this -> redirect ( $ redirectUrl ) ; }
5612	public function paintPass ( $ message ) { parent :: paintPass ( $ message ) ; $ node = new TreemapNode ( 'Assertion' , $ message , true ) ; $ current = $ this -> _stack -> peek ( ) ; if ( $ current ) { $ current -> putChild ( $ node ) ; } else { echo 'no current node' ; } }
10985	public static function checkPhpVersion ( ) { $ version = null ; if ( \ defined ( 'PHP_VERSION' ) ) { $ version = PHP_VERSION ; } else { $ version = phpversion ( '' ) ; } if ( strpos ( $ version , '-' ) !== false ) { $ version = substr ( $ version , 0 , strpos ( $ version , '-' ) ) ; } return $ version ; }
5712	public function addnew ( HTTPRequest $ r ) { return Controller :: curr ( ) -> redirect ( Controller :: join_links ( $ this -> owner -> gridField -> Link ( "item" ) , "new" ) ) ; }
10899	public function save ( bool $ validate = true ) : self { if ( $ validate && $ this -> validate ( ) ) { throw new Exception ( 'Entity ' . $ this -> __getEntityName ( ) . ' data is not valid' ) ; } $ scheme = \ array_keys ( $ this -> getScheme ( ) ) ; foreach ( $ this -> data as $ key => $ value ) { if ( ! \ in_array ( $ key , $ scheme , true ) ) { unset ( $ this -> data [ $ key ] ) ; } } if ( $ this -> getId ( ) ) { $ this -> medoo -> update ( $ this -> getTable ( ) , $ this -> data , [ 'id' => $ this -> getId ( ) ] ) ; } else { $ this -> medoo -> insert ( $ this -> getTable ( ) , $ this -> data ) ; $ this -> setId ( $ this -> medoo -> id ( ) ) ; } $ this -> sentry -> breadcrumbs -> record ( [ 'message' => 'Entity ' . $ this -> __getEntityName ( ) . '::save()' , 'data' => [ 'query' => $ this -> medoo -> last ( ) ] , 'category' => 'Database' , 'level' => 'info' , ] ) ; return $ this ; }
10153	private function readVcenter ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; if ( ! $ this -> readDataOnly ) { $ isVerticalCentered = ( bool ) self :: getUInt2d ( $ recordData , 0 ) ; $ this -> phpSheet -> getPageSetup ( ) -> setVerticalCentered ( $ isVerticalCentered ) ; } }
8232	protected function readConfiguration ( ) { if ( is_array ( $ this -> config ) ) { return ; } $ fileName = $ this -> dir . static :: CONFIG_FILE ; if ( ! file_exists ( $ fileName ) ) { $ this -> config = $ this -> validateConfiguration ( ) ; return ; } $ modifyTime = filemtime ( $ fileName ) ; if ( false === $ modifyTime ) { throw new \ RuntimeException ( "Unable to get mtime of the configuration file." ) ; } $ cacheKey = md5 ( $ fileName ) ; if ( $ this -> cache -> has ( $ cacheKey ) ) { $ this -> config = $ this -> cache -> get ( $ cacheKey ) ; if ( $ this -> config [ "_mtime" ] === $ modifyTime ) { return ; } } if ( ( $ yaml = self :: readFile ( $ fileName ) ) !== false ) { $ config = \ Symfony \ Component \ Yaml \ Yaml :: parse ( $ yaml ) ; $ this -> config = $ this -> validateConfiguration ( $ config ) ; } else { throw new \ RuntimeException ( "Unable to read configuration file." ) ; } $ storedConfig = $ this -> config ; $ storedConfig [ "_mtime" ] = $ modifyTime ; $ this -> cache -> set ( $ cacheKey , $ storedConfig ) ; }
7441	protected function hasAccessToAction ( $ packageKey , $ subpackageKey , $ controllerName , $ actionName ) { $ actionControllerName = $ this -> router -> getControllerObjectName ( $ packageKey , $ subpackageKey , $ controllerName ) ; try { return $ this -> privilegeManager -> isGranted ( 'Neos\Flow\Security\Authorization\Privilege\Method\MethodPrivilege' , new MethodPrivilegeSubject ( new JoinPoint ( NULL , $ actionControllerName , $ actionName . 'Action' , array ( ) ) ) ) ; } catch ( AccessDeniedException $ e ) { return FALSE ; } }
3848	public static function perform ( ) { self :: upgradeJumpTo ( ) ; self :: upgradeDcaSettingsPublished ( ) ; self :: changeSubPalettesToConditions ( ) ; self :: upgradeClosed ( ) ; self :: upgradeInputScreenMode ( ) ; self :: upgradeInputScreenFlag ( ) ; }
2221	public static function findPublishedFromToByPids ( $ intFrom , $ intTo , $ arrPids , $ intLimit = 0 , $ intOffset = 0 , array $ arrOptions = array ( ) ) { if ( empty ( $ arrPids ) || ! \ is_array ( $ arrPids ) ) { return null ; } $ t = static :: $ strTable ; $ arrColumns = array ( "$t.date>=? AND $t.date<=? AND $t.pid IN(" . implode ( ',' , array_map ( '\intval' , $ arrPids ) ) . ")" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.date DESC" ; } $ arrOptions [ 'limit' ] = $ intLimit ; $ arrOptions [ 'offset' ] = $ intOffset ; return static :: findBy ( $ arrColumns , array ( $ intFrom , $ intTo ) , $ arrOptions ) ; }
11493	public function removeAll ( ) : array { $ res = [ ] ; foreach ( $ this -> getKeys ( ) as $ key ) { $ res [ $ key ] = $ this -> remove ( $ key ) ; } return $ res ; }
2353	protected function fputs ( $ varData , $ strMode ) { if ( ! \ is_resource ( $ this -> resFile ) ) { $ this -> strTmp = 'system/tmp/' . md5 ( uniqid ( mt_rand ( ) , true ) ) ; if ( strncmp ( $ strMode , 'a' , 1 ) === 0 && file_exists ( $ this -> strRootDir . '/' . $ this -> strFile ) ) { $ this -> Files -> copy ( $ this -> strFile , $ this -> strTmp ) ; } if ( ! $ this -> resFile = $ this -> Files -> fopen ( $ this -> strTmp , $ strMode ) ) { return false ; } } fwrite ( $ this -> resFile , $ varData ) ; return true ; }
11968	public static function GetAuthClass ( ) { if ( self :: $ authClass === NULL ) { if ( class_exists ( self :: AUTH_CLASS_FULL ) ) { self :: $ authClass = self :: AUTH_CLASS_FULL ; } else { self :: $ authClass = self :: AUTH_CLASS_BASIC ; } } return self :: $ authClass ; }
7731	public function supportsNormalization ( $ data , $ format = null ) { return is_object ( $ data ) && ( $ data instanceof \ DateTime ) && ( self :: FORMAT === $ format ) ; }
2474	public function bulkIndexContent ( array $ contentObjects ) { $ documents = array ( ) ; foreach ( $ contentObjects as $ content ) { try { $ documents [ ] = $ this -> mapper -> mapContentBlock ( $ content ) ; } catch ( NotFoundException $ ex ) { } } if ( ! empty ( $ documents ) ) { $ this -> gateway -> bulkIndexDocuments ( $ documents ) ; } }
3300	public function post ( $ url , $ params = [ ] ) { $ key = is_array ( $ params ) ? 'form_params' : 'body' ; return $ this -> request ( 'POST' , $ url , [ $ key => $ params ] ) ; }
7700	function MsWord_InitHeaderFooter ( ) { if ( $ this -> MsWord_HeaderFooter !== false ) return ; $ types_ok = array ( 'default' => true , 'first' => false , 'even' => false ) ; $ idx = $ this -> FileGetIdx ( 'word/settings.xml' ) ; if ( $ idx !== false ) { $ Txt = $ this -> TbsStoreGet ( $ idx , 'GetHeaderFooterFile' ) ; $ types_ok [ 'even' ] = ( strpos ( $ Txt , '<w:evenAndOddHeaders/>' ) !== false ) ; unset ( $ Txt ) ; } $ idx = $ this -> FileGetIdx ( 'word/document.xml' ) ; if ( $ idx === false ) return false ; $ Txt = $ this -> TbsStoreGet ( $ idx , 'GetHeaderFooterFile' ) ; $ types_ok [ 'first' ] = ( strpos ( $ Txt , '<w:titlePg/>' ) !== false ) ; $ places = array ( 'header' , 'footer' ) ; $ files = array ( ) ; $ rels = $ this -> OpenXML_Rels_GetObj ( 'word/document.xml' , '' ) ; foreach ( $ places as $ place ) { $ p = 0 ; $ entity = 'w:' . $ place . 'Reference' ; while ( $ loc = clsTbsXmlLoc :: FindStartTag ( $ Txt , $ entity , $ p ) ) { $ p = $ loc -> PosEnd ; $ type = $ loc -> GetAttLazy ( 'w:type' ) ; if ( isset ( $ types_ok [ $ type ] ) && $ types_ok [ $ type ] ) { $ rid = $ loc -> GetAttLazy ( 'r:id' ) ; if ( isset ( $ rels -> TargetLst [ $ rid ] ) ) { $ target = $ rels -> TargetLst [ $ rid ] ; $ files [ ] = array ( 'file' => ( 'word/' . $ target ) , 'type' => $ type , 'place' => $ place ) ; } } } } $ this -> MsWord_HeaderFooter = $ files ; }
819	private function isCommentLastLineToken ( Tokens $ tokens , $ index ) { if ( ! $ tokens [ $ index ] -> isComment ( ) || ! $ tokens [ $ index + 1 ] -> isWhitespace ( ) ) { return false ; } $ content = $ tokens [ $ index + 1 ] -> getContent ( ) ; return $ content !== ltrim ( $ content , "\r\n" ) ; }
11767	protected function wipeServerList ( ) { $ this -> reset ( ) ; $ this -> master = null ; $ this -> slaves = array ( ) ; $ this -> pool = array ( ) ; }
4728	private function setCache ( $ singular , $ plural = null ) { $ singular = StringHelper :: strtolower ( $ singular ) ; if ( $ plural === null ) { $ plural = $ singular ; } else { $ plural = StringHelper :: strtolower ( $ plural ) ; } $ this -> cache [ $ singular ] = $ plural ; }
7686	function Misc_ColNum ( $ ColRef , $ IsODF ) { if ( $ IsODF ) { $ p = strpos ( $ ColRef , '.' ) ; if ( $ p !== false ) $ ColRef = substr ( $ ColRef , $ p ) ; $ ColRef = str_replace ( array ( '.' , '$' ) , '' , $ ColRef ) ; $ ColRef = explode ( ':' , $ ColRef ) ; $ ColRef = $ ColRef [ 0 ] ; } $ num = 0 ; $ rank = 0 ; for ( $ i = strlen ( $ ColRef ) - 1 ; $ i >= 0 ; $ i -- ) { $ l = $ ColRef [ $ i ] ; if ( ! is_numeric ( $ l ) ) { $ l = ord ( strtoupper ( $ l ) ) - 64 ; if ( $ l > 0 && $ l < 27 ) { $ num = $ num + $ l * pow ( 26 , $ rank ) ; } else { return $ this -> RaiseError ( '(Sheet) Reference of cell \'' . $ ColRef . '\' cannot be recognized.' ) ; } $ rank ++ ; } } return $ num ; }
9536	private function prefixExists ( $ parameter ) { $ prefixExists = false ; foreach ( array_keys ( $ this -> parameterCluster -> prefixes ) as $ prefix ) { if ( substr ( $ parameter , 0 , strlen ( $ prefix ) ) == $ prefix ) { $ prefixExists = true ; break ; } } return $ prefixExists ; }
5945	public function freetext ( $ freetext , $ deploymentSiteIds = null , $ mode = self :: FREETEXT_OR , $ ignoreGrouping = false , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'deploymentSiteIds' => $ deploymentSiteIds , 'mode' => $ mode , 'ignoreGrouping' => $ ignoreGrouping ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/filters/freetext/' . $ freetext . '' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new FilterItem ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
273	public function asXml ( $ data ) { $ response = Yii :: $ app -> getResponse ( ) ; $ response -> format = Response :: FORMAT_XML ; $ response -> data = $ data ; return $ response ; }
11166	protected function buildHeader ( ) { if ( $ this -> getExtNamespace ( ) === null ) { throw new ExtDirectException ( "Ext js Namespace not set" ) ; } $ var = 'Ext.ns("' . $ this -> getNameSpace ( ) . '"); ' . $ this -> getNameSpace ( ) . "." . Keys :: EXT_HEADER . ' = ' ; return $ var ; }
8802	public function get ( $ key = null ) { return ( is_null ( $ key ) ? $ _SESSION : ( $ this -> has ( $ key ) ? $ _SESSION [ $ key ] : null ) ) ; }
156	public function addSelect ( $ columns ) { if ( $ columns instanceof ExpressionInterface ) { $ columns = [ $ columns ] ; } elseif ( ! is_array ( $ columns ) ) { $ columns = preg_split ( '/\s*,\s*/' , trim ( $ columns ) , - 1 , PREG_SPLIT_NO_EMPTY ) ; } $ columns = $ this -> getUniqueColumns ( $ columns ) ; if ( $ this -> select === null ) { $ this -> select = $ columns ; } else { $ this -> select = array_merge ( $ this -> select , $ columns ) ; } return $ this ; }
3971	public function getAttributeOptions ( GetPropertyOptionsEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ result = [ ] ; $ metaModel = $ this -> getMetaModel ( $ event -> getEnvironment ( ) ) ; $ conditionType = $ event -> getModel ( ) -> getProperty ( 'type' ) ; foreach ( $ metaModel -> getAttributes ( ) as $ attribute ) { if ( ! $ this -> conditionFactory -> supportsAttribute ( $ conditionType , $ attribute -> get ( 'type' ) ) ) { continue ; } $ typeName = $ attribute -> get ( 'type' ) ; $ strSelectVal = $ metaModel -> getTableName ( ) . '_' . $ attribute -> getColName ( ) ; $ result [ $ strSelectVal ] = $ attribute -> getName ( ) . ' [' . $ typeName . ']' ; } $ event -> setOptions ( $ result ) ; }
11044	function masktree_merge ( $ masktree1 , $ masktree2 , $ maskname ) { $ merged = array_merge ( $ masktree1 , $ masktree2 ) ; if ( count ( $ merged ) < count ( $ masktree1 ) + count ( $ masktree2 ) ) { $ keys1 = array_keys ( $ masktree1 ) ; $ keys2 = array_keys ( $ masktree2 ) ; $ keysm = array_merge ( $ keys1 , $ keys2 ) ; $ keysc = array_count_values ( $ keysm ) ; foreach ( $ keysc as $ keyn => $ keyc ) { if ( $ keyc > 1 ) { if ( $ keyn == '0reduce' ) { $ this -> error ( 6 , 49 , 'reduce element already used' ) ; } elseif ( $ keyn != '0include' ) { $ this -> error ( 16 , 60 , "template $keyn already defined in <b>$maskname</b>" ) ; } } } } return $ merged ; }
836	public static function clearCache ( $ key = null ) { if ( null === $ key ) { self :: $ cache = [ ] ; return ; } if ( self :: hasCache ( $ key ) ) { unset ( self :: $ cache [ $ key ] ) ; } }
12856	function performPayload ( iPayloadQueued $ processPayload ) { $ triesCount = 0 ; if ( $ processPayload instanceof FailedPayload ) { if ( $ processPayload -> getCountRetries ( ) > $ this -> getMaxTries ( ) ) throw new exPayloadMaxTriesExceed ( $ processPayload , sprintf ( 'Max Tries Exceeds After %s Tries.' , $ processPayload -> getCountRetries ( ) ) , null ) ; } $ payLoadData = $ processPayload -> getData ( ) ; try { if ( ob_get_level ( ) ) ob_end_clean ( ) ; ob_start ( ) ; $ this -> event ( ) -> trigger ( EventHeapOfWorker :: EVENT_PAYLOAD_RECEIVED , [ 'payload' => $ processPayload , 'data' => $ payLoadData , 'worker' => $ this ] ) ; ob_end_flush ( ) ; flush ( ) ; } catch ( \ LogicException $ e ) { throw $ e ; } catch ( \ Exception $ e ) { if ( ! $ processPayload instanceof FailedPayload ) $ failedPayload = new FailedPayload ( $ processPayload , $ triesCount ) ; else $ failedPayload = $ processPayload ; throw new exPayloadPerformFailed ( $ failedPayload , $ e ) ; } }
2469	public function mapContentBlock ( Content $ content ) { $ contentInfo = $ content -> versionInfo -> contentInfo ; $ locations = $ this -> locationHandler -> loadLocationsByContent ( $ contentInfo -> id ) ; $ blockFields = $ this -> getBlockFields ( $ content ) ; $ contentFields = $ this -> getContentFields ( $ content ) ; $ documents = [ ] ; $ locationFieldsMap = [ ] ; foreach ( $ locations as $ location ) { $ locationFieldsMap [ $ location -> id ] = $ this -> getLocationFields ( $ location ) ; } foreach ( array_keys ( $ content -> versionInfo -> names ) as $ languageCode ) { $ blockTranslationFields = $ this -> getBlockTranslationFields ( $ content , $ languageCode ) ; $ translationLocationDocuments = array ( ) ; foreach ( $ locations as $ location ) { $ translationLocationDocuments [ ] = new Document ( array ( 'id' => $ this -> generateLocationDocumentId ( $ location -> id , $ languageCode ) , 'fields' => array_merge ( $ blockFields , $ locationFieldsMap [ $ location -> id ] , $ blockTranslationFields ) , ) ) ; } $ isMainTranslation = ( $ contentInfo -> mainLanguageCode === $ languageCode ) ; $ alwaysAvailable = ( $ isMainTranslation && $ contentInfo -> alwaysAvailable ) ; $ contentTranslationFields = $ this -> getContentTranslationFields ( $ content , $ languageCode ) ; $ documents [ ] = new Document ( array ( 'id' => $ this -> generateContentDocumentId ( $ contentInfo -> id , $ languageCode ) , 'languageCode' => $ languageCode , 'alwaysAvailable' => $ alwaysAvailable , 'isMainTranslation' => $ isMainTranslation , 'fields' => array_merge ( $ blockFields , $ contentFields , $ blockTranslationFields , $ contentTranslationFields ) , 'documents' => $ translationLocationDocuments , ) ) ; } return $ documents ; }
5459	protected function acceptTag ( $ tag ) { if ( $ tag -> getTagName ( ) === 'a' ) { $ this -> page -> addLink ( $ tag ) ; } elseif ( $ tag -> getTagName ( ) === 'base' ) { $ this -> page -> setBase ( $ tag -> getAttribute ( 'href' ) ) ; } elseif ( $ tag -> getTagName ( ) === 'title' ) { $ this -> page -> setTitle ( $ tag ) ; } elseif ( $ this -> isFormElement ( $ tag -> getTagName ( ) ) ) { for ( $ i = 0 ; $ i < count ( $ this -> open_forms ) ; $ i ++ ) { $ this -> open_forms [ $ i ] -> addWidget ( $ tag ) ; } $ this -> last_widget = $ tag ; } }
12273	public static function cast ( $ date ) { return $ date instanceof self ? $ date : new self ( $ date -> format ( self :: ISO8601 ) , $ date -> getTimezone ( ) ) ; }
11900	public function getIsMostRecent ( ) { return ! empty ( $ this -> dataInterface ) && $ this -> dataInterface -> lastDataInterfaceLog && $ this -> dataInterface -> lastDataInterfaceLog -> primaryKey === $ this -> primaryKey ; }
10331	public function load ( $ url ) { if ( ! is_string ( $ url ) ) { throw new \ InvalidArgumentException ( 'The url argument must be of type string' ) ; } $ this -> url = $ url ; set_error_handler ( function ( ) { throw new \ Exception ( func_get_arg ( 1 ) ) ; } ) ; $ errorReason = '' ; try { $ urlData = parse_url ( $ this -> url ) ; if ( isset ( $ urlData [ 'host' ] ) ) { $ hostname = $ urlData [ 'host' ] ; if ( substr ( $ hostname , 0 , 4 ) === 'www.' ) { $ hostname = substr ( $ hostname , 4 ) ; } foreach ( self :: $ providers as $ name => $ domains ) { $ done = false ; foreach ( $ domains as $ domain ) { if ( preg_match ( '/^' . str_replace ( [ '.' , '*' ] , [ '\.' , '.*' ] , $ domain ) . '$/' , $ hostname ) ) { include_once __DIR__ . DIRECTORY_SEPARATOR . 'VideoEmbed' . DIRECTORY_SEPARATOR . 'Internal' . DIRECTORY_SEPARATOR . 'Providers' . DIRECTORY_SEPARATOR . $ name . '.php' ; call_user_func ( [ '\IvoPetkov\VideoEmbed\Internal\Providers\\' . $ name , 'load' ] , $ this -> url , $ this ) ; $ done = true ; break ; } } if ( $ done ) { break ; } } } } catch ( \ Exception $ e ) { $ errorReason = $ e -> getMessage ( ) ; } restore_error_handler ( ) ; if ( $ this -> html === null ) { throw new \ Exception ( 'Cannot retrieve information about ' . $ this -> url . ' (reason: ' . ( isset ( $ errorReason { 0 } ) ? $ errorReason : 'unknown' ) . ')' ) ; } }
57	public function remove ( PackageInterface $ package , $ targetDir ) { $ downloader = $ this -> getDownloaderForInstalledPackage ( $ package ) ; if ( $ downloader ) { $ downloader -> remove ( $ package , $ targetDir ) ; } }
5589	public function getBaseCookieValue ( $ name , $ base ) { if ( ! $ base ) { return ; } return $ this -> getCookieValue ( $ base -> getHost ( ) , $ base -> getPath ( ) , $ name ) ; }
2601	public function getLiteral ( $ token ) { $ className = get_class ( $ this ) ; $ reflClass = new \ ReflectionClass ( $ className ) ; $ constants = $ reflClass -> getConstants ( ) ; foreach ( $ constants as $ name => $ value ) { if ( $ value === $ token ) { return $ className . '::' . $ name ; } } return $ token ; }
10635	public function update ( \ SplSubject $ eventManager ) { $ this -> isUpdate = true ; if ( $ eventManager -> event -> function !== NULL ) { $ this -> { $ eventManager -> event -> function } ( $ eventManager ) ; } }
8043	public function onProcessCreate ( Semaphore $ semaphore ) { $ this -> semaphore = $ semaphore ; $ this -> create -> __invoke ( $ this -> semaphore , $ this -> storage ) ; }
7558	public function query ( $ query = '*' ) { $ select = $ this -> select ( $ query ) ; $ result = new \ pQuery ( ( array ) $ select ) ; return $ result ; }
609	public function convert ( $ asset , $ basePath ) { $ pos = strrpos ( $ asset , '.' ) ; if ( $ pos !== false ) { $ ext = substr ( $ asset , $ pos + 1 ) ; if ( isset ( $ this -> commands [ $ ext ] ) ) { list ( $ ext , $ command ) = $ this -> commands [ $ ext ] ; $ result = substr ( $ asset , 0 , $ pos + 1 ) . $ ext ; if ( $ this -> forceConvert || @ filemtime ( "$basePath/$result" ) < @ filemtime ( "$basePath/$asset" ) ) { $ this -> runCommand ( $ command , $ basePath , $ asset , $ result ) ; } return $ result ; } } return $ asset ; }
6355	public function setTimestamp ( $ ts = false ) { $ m = [ ] ; $ da = [ ] ; $ strtime = '' ; if ( ! $ ts || $ ts === "\0\0\0\0\0\0\0\0\0\0\0\0\0\0" ) { $ uts = self :: time ( ) ; $ strtime = "@$uts" ; } elseif ( preg_match ( '/^(\d{4})\-(\d\d)\-(\d\d) (\d\d):(\d\d):(\d\d)$/D' , $ ts , $ da ) ) { } elseif ( preg_match ( '/^(\d{4}):(\d\d):(\d\d) (\d\d):(\d\d):(\d\d)$/D' , $ ts , $ da ) ) { } elseif ( preg_match ( '/^(\d{4})(\d\d)(\d\d)(\d\d)(\d\d)(\d\d)$/D' , $ ts , $ da ) ) { } elseif ( preg_match ( '/^(-?\d{1,13})$/D' , $ ts , $ m ) ) { $ strtime = "@{$m[1]}" ; } elseif ( preg_match ( '/^(-?\d{1,13})(\.\d+)$/D' , $ ts , $ m ) ) { $ strtime = 'unixmicro' ; } elseif ( preg_match ( '/^\d{2}-\d{2}-\d{4} \d{2}:\d{2}:\d{2}.\d{6}$/' , $ ts ) ) { $ strtime = preg_replace ( '/(\d\d)\.(\d\d)\.(\d\d)(\.(\d+))?/' , "$1:$2:$3" , str_replace ( '+00:00' , 'UTC' , $ ts ) ) ; } elseif ( preg_match ( '/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})(?:\.*\d*)?Z?$/' , $ ts , $ da ) ) { } elseif ( preg_match ( '/^(\d{4})(\d{2})(\d{2})T(\d{2})(\d{2})(\d{2})(?:\.*\d*)?Z?$/' , $ ts , $ da ) ) { } elseif ( preg_match ( '/^(\d{4})\-(\d\d)\-(\d\d) (\d\d):(\d\d):(\d\d)\.*\d*[\+\- ](\d\d)$/' , $ ts , $ da ) ) { } elseif ( preg_match ( '/^(\d{4})\-(\d\d)\-(\d\d) (\d\d):(\d\d):(\d\d)\.*\d* GMT$/' , $ ts , $ da ) ) { } elseif ( preg_match ( '/^[ \t\r\n]*([A-Z][a-z]{2},[ \t\r\n]*)?' . '\d\d?[ \t\r\n]*[A-Z][a-z]{2}[ \t\r\n]*\d{2}(?:\d{2})?' . '[ \t\r\n]*\d\d[ \t\r\n]*:[ \t\r\n]*\d\d[ \t\r\n]*:[ \t\r\n]*\d\d/S' , $ ts ) ) { $ strtime = strtok ( $ ts , ';' ) ; } elseif ( preg_match ( '/^[A-Z][a-z]{5,8}, \d\d-[A-Z][a-z]{2}-\d{2} \d\d:\d\d:\d\d/' , $ ts ) ) { $ strtime = $ ts ; } elseif ( preg_match ( '/^[A-Z][a-z]{2} [A-Z][a-z]{2} +\d{1,2} \d\d:\d\d:\d\d \d{4}/' , $ ts ) ) { $ strtime = $ ts ; } else { throw new TimestampException ( __METHOD__ . ": Invalid timestamp - $ts" ) ; } if ( ! $ strtime ) { $ da = array_map ( 'intval' , $ da ) ; $ da [ 0 ] = "%04d-%02d-%02dT%02d:%02d:%02d.00+00:00" ; $ strtime = call_user_func_array ( "sprintf" , $ da ) ; } try { if ( $ strtime === 'unixmicro' ) { $ final = DateTime :: createFromFormat ( 'U.u' , $ ts , new DateTimeZone ( 'GMT' ) ) ; } else { $ final = new DateTime ( $ strtime , new DateTimeZone ( 'GMT' ) ) ; } } catch ( Exception $ e ) { throw new TimestampException ( __METHOD__ . ': Invalid timestamp format.' , $ e -> getCode ( ) , $ e ) ; } if ( $ final === false ) { throw new TimestampException ( __METHOD__ . ': Invalid timestamp format.' ) ; } $ this -> timestamp = $ final ; }
6925	private function getFindOneByCountryAndMethodAndWeightQuery ( ) { if ( null === $ this -> findOneByCountryAndMethodAndWeightQuery ) { $ qb = $ this -> getCollectionQueryBuilder ( 'o' ) ; $ qb -> join ( 'o.zone' , 'z' ) -> join ( 'o.method' , 'm' ) -> andWhere ( $ qb -> expr ( ) -> isMemberOf ( ':country' , 'z.countries' ) ) -> andWhere ( $ qb -> expr ( ) -> gte ( 'o.weight' , ':weight' ) ) -> andWhere ( $ qb -> expr ( ) -> eq ( 'o.method' , ':method' ) ) -> addOrderBy ( 'o.weight' , 'ASC' ) -> setMaxResults ( 1 ) ; $ this -> findOneByCountryAndMethodAndWeightQuery = $ qb -> getQuery ( ) ; } return $ this -> findOneByCountryAndMethodAndWeightQuery ; }
2738	private function setToken ( $ token ) { $ this -> configWriter -> save ( Config :: XML_FASTLY_API_KEY , $ token ) ; $ this -> output -> writeln ( '<info>Token updated.</info>' , OutputInterface :: OUTPUT_NORMAL ) ; }
3765	private function mapTranslations ( $ array , $ domain , StaticTranslator $ translator , $ baseKey = '' ) { foreach ( $ array as $ key => $ value ) { $ newKey = ( $ baseKey ? $ baseKey . '.' : '' ) . $ key ; if ( is_array ( $ value ) ) { $ this -> mapTranslations ( $ value , $ domain , $ translator , $ newKey ) ; } else { $ translator -> setValue ( $ newKey , $ value , $ domain ) ; } } }
7347	static public function calculateDeliveryRemainingQuantity ( $ item ) { if ( $ item instanceof SupplierOrderItemInterface ) { return $ item -> getQuantity ( ) - static :: calculateReceivedQuantity ( $ item ) ; } if ( ! $ item instanceof SupplierDeliveryItemInterface ) { throw new InvalidArgumentException ( "Expected instance of " . SupplierOrderItemInterface :: class . " or " . SupplierDeliveryItemInterface :: class ) ; } $ orderItem = $ item -> getOrderItem ( ) ; $ result = $ orderItem -> getQuantity ( ) - static :: calculateReceivedQuantity ( $ orderItem ) ; if ( 0 < $ item -> getQuantity ( ) ) { $ result += $ item -> getQuantity ( ) ; } return $ result ; }
5619	public function paintFail ( $ message ) { parent :: paintFail ( $ message ) ; $ msg = '<span class="fail">Fail</span>: ' ; $ breadcrumb = $ this -> getTestList ( ) ; array_shift ( $ breadcrumb ) ; $ msg .= implode ( '-&gt;' , $ breadcrumb ) ; $ msg .= '-&gt;' . htmlentities ( $ message ) . '<br />' ; echo "add_fail('$msg');\n" ; }
10914	public function execute ( ) { try { $ this -> output_buffer_level = ob_get_level ( ) ; ob_start ( ) ; $ response = $ this -> doExecute ( ) ; if ( ( is_object ( $ response ) && ! ( $ response instanceof Response ) ) || ( is_string ( $ response ) && class_exists ( $ response ) ) ) { $ response = $ this -> reflect ( $ response ) ; } if ( $ response instanceof Response ) throw $ response ; throw new HTTPError ( 500 , "App did not produce any response" ) ; } catch ( Response $ response ) { self :: $ logger -> debug ( "Response type {0} returned from controller: {1}" , [ get_class ( $ response ) , $ this -> app ] ) ; throw $ response ; } catch ( Throwable $ e ) { self :: $ logger -> debug ( "While executing controller: {0}" , [ $ this -> app ] ) ; self :: $ logger -> notice ( "Unexpected exception of type {0} thrown while processing request: {1}" , [ get_class ( $ e ) , $ e ] ) ; throw $ e ; } finally { $ this -> logScriptOutput ( ) ; } }
1642	public static function fromString ( string $ string , Ellipsoid $ ellipsoid = null ) : Coordinate { $ string = self :: mergeSecondsToMinutes ( $ string ) ; $ result = self :: parseDecimalMinutesWithoutCardinalLetters ( $ string , $ ellipsoid ) ; if ( $ result instanceof Coordinate ) { return $ result ; } $ result = self :: parseDecimalMinutesWithCardinalLetters ( $ string , $ ellipsoid ) ; if ( $ result instanceof Coordinate ) { return $ result ; } $ result = self :: parseDecimalDegreesWithoutCardinalLetters ( $ string , $ ellipsoid ) ; if ( $ result instanceof Coordinate ) { return $ result ; } $ result = self :: parseDecimalDegreesWithCardinalLetters ( $ string , $ ellipsoid ) ; if ( $ result instanceof Coordinate ) { return $ result ; } throw new InvalidArgumentException ( 'Format of coordinates was not recognized' ) ; }
1279	private function extractSpaceId ( array $ data ) : string { if ( isset ( $ data [ 'sys' ] [ 'type' ] ) && 'Space' === $ data [ 'sys' ] [ 'type' ] ) { return $ data [ 'sys' ] [ 'id' ] ; } if ( isset ( $ data [ 'sys' ] [ 'type' ] ) && 'Environment' === $ data [ 'sys' ] [ 'type' ] ) { return $ this -> spaceId ; } if ( isset ( $ data [ 'sys' ] [ 'space' ] ) ) { return $ data [ 'sys' ] [ 'space' ] [ 'sys' ] [ 'id' ] ; } if ( isset ( $ data [ 'items' ] [ 0 ] [ 'sys' ] [ 'space' ] ) ) { return $ data [ 'items' ] [ 0 ] [ 'sys' ] [ 'space' ] [ 'sys' ] [ 'id' ] ; } if ( isset ( $ data [ 'items' ] ) && ! $ data [ 'items' ] ) { return $ this -> spaceId ; } return '[blank]' ; }
6263	public function nextkey ( ) { if ( $ this -> keys === null ) { return $ this -> firstkey ( ) ; } return empty ( $ this -> keys ) ? false : array_shift ( $ this -> keys ) ; }
2005	protected function validateForm ( Widget $ objWidget = null ) { $ varInput = Idna :: encodeEmail ( Input :: post ( 'email' , true ) ) ; if ( ! Validator :: isEmail ( $ varInput ) ) { $ this -> Template -> mclass = 'error' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'email' ] ; return false ; } $ this -> Template -> email = $ varInput ; $ arrChannels = Input :: post ( 'channels' ) ; if ( ! \ is_array ( $ arrChannels ) ) { $ this -> Template -> mclass = 'error' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'noChannels' ] ; return false ; } $ arrChannels = array_intersect ( $ arrChannels , $ this -> nl_channels ) ; if ( empty ( $ arrChannels ) || ! \ is_array ( $ arrChannels ) ) { $ this -> Template -> mclass = 'error' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'noChannels' ] ; return false ; } $ this -> Template -> selectedChannels = $ arrChannels ; $ arrSubscriptions = array ( ) ; if ( ( $ objSubscription = NewsletterRecipientsModel :: findBy ( array ( "email=? AND active='1'" ) , $ varInput ) ) !== null ) { $ arrSubscriptions = $ objSubscription -> fetchEach ( 'pid' ) ; } $ arrChannels = array_intersect ( $ arrChannels , $ arrSubscriptions ) ; if ( empty ( $ arrChannels ) ) { $ this -> Template -> mclass = 'error' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'unsubscribed' ] ; return false ; } if ( $ objWidget !== null ) { $ objWidget -> validate ( ) ; if ( $ objWidget -> hasErrors ( ) ) { return false ; } } return array ( $ varInput , $ arrChannels ) ; }
937	public static function getKeywords ( ) { static $ keywords = null ; if ( null === $ keywords ) { $ keywords = self :: getTokenKindsForNames ( [ 'T_ABSTRACT' , 'T_ARRAY' , 'T_AS' , 'T_BREAK' , 'T_CALLABLE' , 'T_CASE' , 'T_CATCH' , 'T_CLASS' , 'T_CLONE' , 'T_CONST' , 'T_CONTINUE' , 'T_DECLARE' , 'T_DEFAULT' , 'T_DO' , 'T_ECHO' , 'T_ELSE' , 'T_ELSEIF' , 'T_EMPTY' , 'T_ENDDECLARE' , 'T_ENDFOR' , 'T_ENDFOREACH' , 'T_ENDIF' , 'T_ENDSWITCH' , 'T_ENDWHILE' , 'T_EVAL' , 'T_EXIT' , 'T_EXTENDS' , 'T_FINAL' , 'T_FINALLY' , 'T_FOR' , 'T_FOREACH' , 'T_FUNCTION' , 'T_GLOBAL' , 'T_GOTO' , 'T_HALT_COMPILER' , 'T_IF' , 'T_IMPLEMENTS' , 'T_INCLUDE' , 'T_INCLUDE_ONCE' , 'T_INSTANCEOF' , 'T_INSTEADOF' , 'T_INTERFACE' , 'T_ISSET' , 'T_LIST' , 'T_LOGICAL_AND' , 'T_LOGICAL_OR' , 'T_LOGICAL_XOR' , 'T_NAMESPACE' , 'T_NEW' , 'T_PRINT' , 'T_PRIVATE' , 'T_PROTECTED' , 'T_PUBLIC' , 'T_REQUIRE' , 'T_REQUIRE_ONCE' , 'T_RETURN' , 'T_STATIC' , 'T_SWITCH' , 'T_THROW' , 'T_TRAIT' , 'T_TRY' , 'T_UNSET' , 'T_USE' , 'T_VAR' , 'T_WHILE' , 'T_YIELD' , 'T_YIELD_FROM' , ] ) + [ CT :: T_ARRAY_TYPEHINT => CT :: T_ARRAY_TYPEHINT , CT :: T_CLASS_CONSTANT => CT :: T_CLASS_CONSTANT , CT :: T_CONST_IMPORT => CT :: T_CONST_IMPORT , CT :: T_FUNCTION_IMPORT => CT :: T_FUNCTION_IMPORT , CT :: T_NAMESPACE_OPERATOR => CT :: T_NAMESPACE_OPERATOR , CT :: T_USE_TRAIT => CT :: T_USE_TRAIT , CT :: T_USE_LAMBDA => CT :: T_USE_LAMBDA , ] ; } return $ keywords ; }
5189	private function createVideo ( string $ body , string $ source , int $ order , string $ cover , string $ lead ) : \ One \ Model \ Video { return new Video ( $ body , $ source , $ order , $ cover , $ lead ) ; }
7735	private function documentRouteAndOperations ( $ metadata , Reflector $ element ) { if ( ( null !== ( $ annotation = $ this -> getAnnotation ( $ element , 'ML\HydraBundle\Mapping\Id' ) ) ) || ( null !== ( $ annotation = $ this -> getAnnotation ( $ element , 'ML\HydraBundle\Mapping\Route' ) ) ) ) { $ metadata -> setRoute ( $ this -> getRouteMetadata ( $ annotation -> route ) ) ; } $ annotation = $ this -> getAnnotation ( $ element , 'ML\HydraBundle\Mapping\Operations' ) ; if ( null !== $ annotation ) { $ operations = array_unique ( $ annotation -> operations ) ; $ operationsMetadata = array_map ( array ( $ this , 'getRouteMetadata' ) , $ operations ) ; $ metadata -> setOperations ( $ operationsMetadata ) ; } if ( null !== ( $ route = $ metadata -> getRoute ( ) ) ) { $ metadata -> addOperation ( $ this -> getRouteMetadata ( $ route -> getName ( ) ) ) ; } elseif ( null !== $ annotation ) { $ metadata -> setRoute ( $ this -> getRouteMetadata ( reset ( $ annotation -> operations ) ) ) ; } if ( ( $ metadata instanceof PropertyDefinition ) && ( count ( $ operations = $ metadata -> getOperations ( ) ) > 0 ) ) { foreach ( $ operations as $ operation ) { if ( ( 'GET' === $ operation -> getMethod ( ) ) && ( null !== $ operation -> getReturns ( ) ) ) { $ metadata -> setType ( $ operation -> getReturns ( ) ) ; return ; } } $ metadata -> setType ( 'ML\HydraBundle\Entity\Resource' ) ; } }
5060	public static function fromURI ( $ URI ) { $ regex = '/^(([^-]|--)+)-(([^-]|--)+)-(([^-]|--)+)\.(svg|png|gif|jpg)$/' ; $ match = array ( ) ; if ( 1 != preg_match ( $ regex , $ URI , $ match ) && ( 7 != count ( $ match ) ) ) { throw new \ InvalidArgumentException ( 'The URI given is not a valid URI' . $ URI ) ; } $ subject = $ match [ 1 ] ; $ status = $ match [ 3 ] ; $ color = $ match [ 5 ] ; $ format = $ match [ 7 ] ; return new self ( $ subject , $ status , $ color , $ format ) ; }
2439	public function cloneForCurrent ( string $ current ) : self { return new self ( $ this -> context , $ this -> extras , $ this -> value , $ current ) ; }
6745	private function applyResponseEncoding ( Request $ request , Response $ response ) { $ allowedCompressionAsString = $ request -> headers -> get ( 'Accept-Encoding' ) ; if ( ! $ allowedCompressionAsString ) { return ; } $ allowedCompression = explode ( ',' , $ allowedCompressionAsString ) ; $ allowedCompression = array_map ( 'trim' , $ allowedCompression ) ; if ( in_array ( 'gzip' , $ allowedCompression ) ) { $ response -> setContent ( gzencode ( $ response -> getContent ( ) ) ) ; $ response -> headers -> set ( 'Content-Encoding' , 'gzip' ) ; return ; } if ( in_array ( 'deflate' , $ allowedCompression ) ) { $ response -> setContent ( gzdeflate ( $ response -> getContent ( ) ) ) ; $ response -> headers -> set ( 'Content-Encoding' , 'deflate' ) ; return ; } }
3184	public function jsonSerialize ( ) { $ source = $ this -> getSource ( ) ; $ timeLimits = $ source -> getTimeLimits ( ) ; if ( ! is_null ( $ timeLimits ) ) { $ identifier = $ source -> getIdentifier ( ) ; $ maxTime = $ timeLimits -> getMaxTime ( ) ; $ minTime = $ timeLimits -> getMinTime ( ) ; $ maxTimeRemaining = $ this -> getMaximumRemainingTime ( ) ; $ minTimeRemaining = $ this -> getMinimumRemainingTime ( ) ; if ( $ maxTimeRemaining !== false || $ minTimeRemaining !== false ) { $ label = method_exists ( $ source , 'getTitle' ) ? $ source -> getTitle ( ) : $ identifier ; $ extraTime = [ ] ; if ( ! is_null ( $ this -> getTimer ( ) ) && $ source -> getTimeLimits ( ) -> hasMaxTime ( ) ) { $ timer = $ this -> getTimer ( ) ; $ maxTimeSeconds = $ source -> getTimeLimits ( ) -> getMaxTime ( ) -> getSeconds ( true ) ; $ extraTime = [ 'total' => $ timer -> getExtraTime ( $ maxTimeSeconds ) , 'consumed' => $ timer -> getConsumedExtraTime ( $ identifier , $ maxTimeSeconds , $ this -> timerTarget ) , 'remaining' => $ timer -> getRemainingExtraTime ( $ identifier , $ maxTimeSeconds , $ this -> timerTarget ) , ] ; } $ labelFormatter = ServiceManager :: getServiceManager ( ) -> get ( TimerLabelFormatterService :: SERVICE_ID ) ; return [ 'label' => $ labelFormatter -> format ( $ label ) , 'source' => $ identifier , 'qtiClassName' => $ source -> getQtiClassName ( ) , 'extraTime' => $ extraTime , 'allowLateSubmission' => $ this -> allowLateSubmission ( ) , 'minTime' => $ this -> durationToMs ( $ minTime ) , 'minTimeRemaining' => $ this -> durationToMs ( $ minTimeRemaining ) , 'maxTime' => $ this -> durationToMs ( $ maxTime ) , 'maxTimeRemaining' => $ this -> durationToMs ( $ maxTimeRemaining ) , ] ; } } return null ; }
5853	protected function loadVirtualTca ( ) { $ GLOBALS [ 'TCA' ] [ static :: virtualTable ] = include ( ExtensionManagementUtility :: extPath ( $ this -> extKey ) . 'Configuration/TCA/Module/Options.php' ) ; ExtensionManagementUtility :: addLLrefForTCAdescr ( static :: virtualTable , 'EXT:' . $ this -> extKey . '/Resource/Private/Language/locallang_csh_' . static :: virtualTable . '.xlf' ) ; }
6667	public function prepareResponse ( ) { if ( ! $ this -> writer ) { $ this -> writer = $ this -> writerFactory -> getWriterFor ( $ this -> request -> getFormats ( ) ) ; } $ this -> preparedResponse = $ this -> writer -> format ( $ this -> getBody ( ) , $ this -> responseName ) ; return $ this ; }
7744	public function getValue ( $ entity ) { if ( null === $ this -> getter ) { throw new \ Exception ( "Can't get the entity's {$this->name} property as no getter has been found." ) ; } elseif ( false === ( $ entity instanceof $ this -> class ) ) { throw new \ Exception ( "Can't get the entity's {$this->name} property as the entity is not an instance of {$this->class}." ) ; } if ( self :: GETTER_SETTER_METHOD === $ this -> getterType ) { return $ entity -> { $ this -> getter } ( ) ; } else { return $ entity -> { $ this -> getter } ; } }
5087	public function commit ( ) : bool { if ( ! $ this -> isInTransaction ) throw new NotInTransactionException ( ) ; $ this -> isInTransaction = false ; return $ this -> executeDirect ( 'COMMIT' ) ; }
12339	private function getColoredMsg ( string $ msg , ? string $ fontColor , ? string $ bgColor ) : string { $ res = '' ; if ( ! is_null ( $ fontColor ) ) { $ res .= "\033[{$fontColor}m" ; } if ( ! is_null ( $ bgColor ) ) { $ res .= "\033[{$bgColor}m" ; } if ( ! is_null ( $ fontColor ) || ! is_null ( $ bgColor ) ) { return "{$res}{$msg}\033[0m" ; } return $ msg ; }
6001	public function addImageTemplate ( $ item ) { if ( ! ( $ item instanceof ImageTemplate ) ) { if ( is_array ( $ item ) ) { try { $ item = new ImageTemplate ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate ImageTemplate. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "ImageTemplate"!' , E_USER_WARNING ) ; } } $ this -> imagetemplates [ ] = $ item ; return $ this ; }
636	public function dropTable ( $ table ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> dropTable ( $ table ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; }
6982	public function validate ( $ dataOrRequest , array $ rules , array $ messages = [ ] , array $ customAttributes = [ ] ) { $ errors = $ this -> validateAndReturnErrors ( $ dataOrRequest , $ rules , $ messages , $ customAttributes ) ; if ( ! empty ( $ errors ) ) { $ this -> throwValidationErrorsResponse ( $ errors ) ; } return $ this -> extractInputFromRules ( $ dataOrRequest , $ rules ) ; }
5877	protected static function findExistingFile ( $ fileName ) { $ file = null ; $ relativePath = substr ( PathUtility :: dirname ( $ fileName ) , strlen ( PATH_site ) ) ; $ resourceFactory = \ TYPO3 \ CMS \ Core \ Resource \ ResourceFactory :: getInstance ( ) ; $ targetFolder = $ resourceFactory -> retrieveFileOrFolderObject ( $ relativePath ) ; $ storageConfiguration = $ targetFolder -> getStorage ( ) -> getConfiguration ( ) ; if ( isset ( $ storageConfiguration [ 'basePath' ] ) ) { $ basePath = rtrim ( $ storageConfiguration [ 'basePath' ] , '/' ) . '/' ; $ basePath = GeneralUtility :: getFileAbsFileName ( $ basePath ) ; $ identifier = substr ( $ fileName , strlen ( $ basePath ) - 1 ) ; $ row = GeneralUtility :: makeInstance ( ConnectionPool :: class ) -> getConnectionForTable ( 'sys_file' ) -> select ( [ 'uid' ] , 'sys_file' , [ 'storage' => $ targetFolder -> getStorage ( ) -> getUid ( ) , 'identifier' => $ identifier , ] ) -> fetch ( ) ; if ( ! empty ( $ row [ 'uid' ] ) ) { $ fileRepository = GeneralUtility :: makeInstance ( \ TYPO3 \ CMS \ Core \ Resource \ FileRepository :: class ) ; $ file = $ fileRepository -> findByUid ( $ row [ 'uid' ] ) ; } } return $ file ; }
721	public function money ( $ precision = null , $ scale = null ) { $ length = [ ] ; if ( $ precision !== null ) { $ length [ ] = $ precision ; } if ( $ scale !== null ) { $ length [ ] = $ scale ; } return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_MONEY , $ length ) ; }
11433	public function query ( $ keyword , $ categories , array $ other = [ ] ) { $ params = [ 'query' => $ keyword , 'category' => implode ( ',' , ( array ) $ categories ) , 'appid' => $ this -> getAccessToken ( ) -> getAppId ( ) , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_SEARCH , array_merge ( $ params , $ other ) ] ) ; }
9670	private function writeBorder ( XMLWriter $ objWriter , Borders $ pBorders ) { $ objWriter -> startElement ( 'border' ) ; switch ( $ pBorders -> getDiagonalDirection ( ) ) { case Borders :: DIAGONAL_UP : $ objWriter -> writeAttribute ( 'diagonalUp' , 'true' ) ; $ objWriter -> writeAttribute ( 'diagonalDown' , 'false' ) ; break ; case Borders :: DIAGONAL_DOWN : $ objWriter -> writeAttribute ( 'diagonalUp' , 'false' ) ; $ objWriter -> writeAttribute ( 'diagonalDown' , 'true' ) ; break ; case Borders :: DIAGONAL_BOTH : $ objWriter -> writeAttribute ( 'diagonalUp' , 'true' ) ; $ objWriter -> writeAttribute ( 'diagonalDown' , 'true' ) ; break ; } $ this -> writeBorderPr ( $ objWriter , 'left' , $ pBorders -> getLeft ( ) ) ; $ this -> writeBorderPr ( $ objWriter , 'right' , $ pBorders -> getRight ( ) ) ; $ this -> writeBorderPr ( $ objWriter , 'top' , $ pBorders -> getTop ( ) ) ; $ this -> writeBorderPr ( $ objWriter , 'bottom' , $ pBorders -> getBottom ( ) ) ; $ this -> writeBorderPr ( $ objWriter , 'diagonal' , $ pBorders -> getDiagonal ( ) ) ; $ objWriter -> endElement ( ) ; }
10535	protected function _getData ( $ key ) { $ store = $ this -> _getDataStore ( ) ; try { $ result = $ this -> _containerGet ( $ store , $ key ) ; } catch ( OutOfRangeException $ e ) { throw $ this -> _createInvalidArgumentException ( $ this -> __ ( 'Invalid key' ) , null , $ e , $ key ) ; } return $ result ; }
4613	public function withScalarValue ( $ value ) { $ this -> match = $ value ; $ this -> lowerBound = null ; $ this -> upperBound = null ; return $ this ; }
3250	public function scopeWhereCurrent ( $ query ) { if ( Auth :: guest ( ) ) return $ query ; return $ query -> whereUser ( Auth :: user ( ) -> shopId ) ; }
10814	protected function _setDataStore ( $ dataStore ) { if ( ! is_null ( $ dataStore ) ) { $ dataStore = $ this -> _normalizeContainer ( $ dataStore ) ; } $ this -> dataStore = $ dataStore ; }
6121	public function permissionGetIdByName ( $ name ) { if ( ! array_key_exists ( ( string ) $ name , $ this -> permissionList ( ) ) ) { throw new Ts3Exception ( "invalid permission ID" , 0xA02 ) ; } return $ this -> permissionList [ ( string ) $ name ] [ "permid" ] ; }
12130	public function clear ( ) { $ this -> _repeat = 1 ; $ this -> _startTime = 0 ; $ this -> _duration = 0 ; $ this -> _average = 0 ; $ this -> _rate = 0 ; $ this -> _startMem = 0 ; $ this -> _memory = 0 ; }
5418	public function writeCookiesToJar ( $ jar , $ url ) { foreach ( $ this -> cookies as $ cookie ) { $ jar -> setCookie ( $ cookie -> getName ( ) , $ cookie -> getValue ( ) , $ url -> getHost ( ) , $ cookie -> getPath ( ) , $ cookie -> getExpiry ( ) ) ; } }
7549	function deleteChild ( $ child , $ soft_delete = false ) { if ( is_object ( $ child ) ) { $ child = $ this -> findChild ( $ child ) ; } elseif ( $ child < 0 ) { $ child += count ( $ this -> children ) ; } if ( ! $ soft_delete ) { $ this -> children [ $ child ] -> delete ( ) ; } unset ( $ this -> children [ $ child ] ) ; $ tmp = array ( ) ; foreach ( array_keys ( $ this -> children ) as $ k ) { $ tmp [ ] = & $ this -> children [ $ k ] ; } $ this -> children = $ tmp ; }
8075	private function handle ( Response $ response ) { $ stream = stream_for ( $ response -> getBody ( ) ) ; $ data = json_decode ( $ stream -> getContents ( ) ) ; return $ data ; }
4972	private function flattenTree ( $ tree , & $ data , $ curId = '1' ) { $ data [ ] = new \ ArrayObject ( [ 'id' => $ tree -> getId ( ) , 'current' => $ curId , 'name' => $ tree -> getName ( ) , 'value' => $ tree -> getValue ( ) , 'priority' => $ tree -> getPriority ( ) , 'do' => 'nothing' , ] ) ; if ( $ tree -> hasChildren ( ) ) { foreach ( $ tree -> getChildren ( ) as $ i => $ child ) { $ this -> flattenTree ( $ child , $ data , $ curId . '-' . ( $ i + 1 ) ) ; } } }
1571	public function getProcessId ( ) : ? string { if ( is_null ( $ this -> processId ) ) { return $ this -> parameter ( ResourceRegistrar :: PARAM_PROCESS_ID ) ; } return $ this -> processId ? : null ; }
2868	public function preDispatch ( ) { parent :: preDispatch ( ) ; if ( ! Mage :: helper ( 'sheep_debug' ) -> isAllowed ( ) ) { $ this -> setFlag ( '' , 'no-dispatch' , true ) ; $ this -> getResponse ( ) -> setHttpResponseCode ( 404 ) ; } }
1981	public static function reset ( ) { $ session = System :: getContainer ( ) -> get ( 'session' ) ; if ( ! $ session -> isStarted ( ) ) { return ; } $ session -> getFlashBag ( ) -> clear ( ) ; }
2207	protected function compileYearlyMenu ( ) { $ arrData = array ( ) ; $ arrAllEvents = $ this -> getAllEvents ( $ this -> cal_calendar , 0 , 2145913200 ) ; foreach ( $ arrAllEvents as $ intDay => $ arrDay ) { foreach ( $ arrDay as $ arrEvents ) { $ arrData [ substr ( $ intDay , 0 , 4 ) ] += \ count ( $ arrEvents ) ; } } ( $ this -> cal_order == 'ascending' ) ? ksort ( $ arrData ) : krsort ( $ arrData ) ; $ arrItems = array ( ) ; $ count = 0 ; $ limit = \ count ( $ arrData ) ; foreach ( $ arrData as $ intYear => $ intCount ) { $ intDate = $ intYear ; $ quantity = sprintf ( ( ( $ intCount < 2 ) ? $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'entry' ] : $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'entries' ] ) , $ intCount ) ; $ arrItems [ $ intYear ] [ 'date' ] = $ intDate ; $ arrItems [ $ intYear ] [ 'link' ] = $ intYear ; $ arrItems [ $ intYear ] [ 'href' ] = $ this -> strLink . '?year=' . $ intDate ; $ arrItems [ $ intYear ] [ 'title' ] = StringUtil :: specialchars ( $ intYear . ' (' . $ quantity . ')' ) ; $ arrItems [ $ intYear ] [ 'class' ] = trim ( ( ( ++ $ count == 1 ) ? 'first ' : '' ) . ( ( $ count == $ limit ) ? 'last' : '' ) ) ; $ arrItems [ $ intYear ] [ 'isActive' ] = ( Input :: get ( 'year' ) == $ intDate ) ; $ arrItems [ $ intYear ] [ 'quantity' ] = $ quantity ; } $ this -> Template -> yearly = true ; $ this -> Template -> items = $ arrItems ; $ this -> Template -> showQuantity = ( $ this -> cal_showQuantity != '' ) ? true : false ; }
10904	public function isEmpty ( ) { if ( $ this -> test ( \ sndsgd \ Fs :: EXISTS | \ sndsgd \ Fs :: READABLE ) === false ) { throw new \ RuntimeException ( "failed to determine if a directory is empty; " . $ this -> getError ( ) ) ; } return count ( scandir ( $ this -> path ) ) === 2 ; }
7032	public function run ( $ prog = "migrate" ) { switch ( trim ( $ prog ) ) { case "migrate" : return $ this -> migrate ( ) ; case "drop" : return $ this -> drop ( ) ; case "reset" : return $ this -> drop ( ) & $ this -> migrate ( ) ; default : error_log ( "\n\e[1;31m!\e[0m program $prog not applicable\n" ) ; return false ; } }
12093	public function getDomainUrl ( $ address , $ scheme = false ) { $ this -> urlAddress -> setAddress ( $ address ) ; return $ this -> urlAddress -> getDomain ( $ scheme ) ; }
8682	public function setPath ( $ path , $ value ) { Deprecated :: method ( 1.1 , MutableBag :: class ) ; Arr :: set ( $ this -> items , $ path , $ value ) ; }
5510	public function expectAt ( $ timing , $ method , $ args , $ message = '%s' ) { $ this -> dieOnNoMethod ( $ method , 'set expected arguments at time' ) ; $ this -> checkArgumentsIsArray ( $ args , 'set expected arguments at time' ) ; $ args = $ this -> replaceWildcards ( $ args ) ; if ( ! isset ( $ this -> expected_args_at [ $ timing ] ) ) { $ this -> expected_args_at [ $ timing ] = array ( ) ; } $ method = strtolower ( $ method ) ; $ message .= Mock :: getExpectationLine ( ) ; $ this -> expected_args_at [ $ timing ] [ $ method ] = new ParametersExpectation ( $ args , $ message ) ; }
4306	public function time ( $ label = null ) { $ args = \ func_get_args ( ) ; $ this -> internal -> getMetaVals ( $ args , array ( ) , array ( 'label' => null ) ) ; \ extract ( $ args ) ; if ( isset ( $ label ) ) { $ timers = & $ this -> data [ 'timers' ] [ 'labels' ] ; if ( ! isset ( $ timers [ $ label ] ) ) { $ timers [ $ label ] = array ( 0 , \ microtime ( true ) ) ; } elseif ( ! isset ( $ timers [ $ label ] [ 1 ] ) ) { $ timers [ $ label ] [ 1 ] = \ microtime ( true ) ; } } else { $ this -> data [ 'timers' ] [ 'stack' ] [ ] = \ microtime ( true ) ; } }
12237	public function setAttributes ( array $ attr , $ ns = null ) { $ dom = dom_import_simplexml ( $ this ) ; foreach ( $ attr as $ k => $ v ) { $ dom -> setAttributeNS ( $ ns , $ k , $ v ) ; } return $ this ; }
4014	protected function getHelpWizard ( $ key , $ field ) { if ( empty ( $ field [ 'eval' ] [ 'helpwizard' ] ) ) { return '' ; } $ event = new GenerateHtmlEvent ( 'about.svg' , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'helpWizard' ] , 'style="vertical-align:text-bottom;"' ) ; $ this -> getEventDispatcher ( ) -> dispatch ( ContaoEvents :: IMAGE_GET_HTML , $ event ) ; return sprintf ( ' <a href="%shelp.php?table=%s&amp;field=%s_%s" title="%s" rel="lightbox[help 610 80%]">%s</a>' , TL_PATH . 'contao/' , $ this -> strTable , $ this -> strName , $ key , StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'helpWizard' ] ) , $ event -> getHtml ( ) ) ; }
611	public function set ( $ class , $ definition = [ ] , array $ params = [ ] ) { $ this -> _definitions [ $ class ] = $ this -> normalizeDefinition ( $ class , $ definition ) ; $ this -> _params [ $ class ] = $ params ; unset ( $ this -> _singletons [ $ class ] ) ; return $ this ; }
12239	public function innerXML ( ) { $ xml = $ this -> outerXML ( ) ; $ pos = 1 + strpos ( $ xml , '>' ) ; $ len = strrpos ( $ xml , '<' ) - $ pos ; return substr ( $ xml , $ pos , $ len ) ; }
6911	public function removeExtraCopy ( Recipient $ copy ) { if ( $ this -> extraCopies -> contains ( $ copy ) ) { $ this -> extraCopies -> removeElement ( $ copy ) ; } return $ this ; }
5423	public function invoke ( $ method ) { $ trap = SimpleTest :: getContext ( ) -> get ( 'SimpleExceptionTrap' ) ; $ trap -> clear ( ) ; try { $ has_thrown = false ; parent :: invoke ( $ method ) ; } catch ( Exception $ exception ) { $ has_thrown = true ; if ( ! $ trap -> isExpected ( $ this -> getTestCase ( ) , $ exception ) ) { $ this -> getTestCase ( ) -> exception ( $ exception ) ; } $ trap -> clear ( ) ; } if ( $ message = $ trap -> getOutstanding ( ) ) { $ this -> getTestCase ( ) -> fail ( $ message ) ; } if ( $ has_thrown ) { try { parent :: getTestCase ( ) -> tearDown ( ) ; } catch ( Exception $ e ) { } } }
5998	public function setMax ( $ max ) { if ( $ max instanceof DateTime ) { $ this -> max = $ max ; } else { try { $ this -> max = new DateTime ( $ max ) ; } catch ( \ Exception $ e ) { $ this -> max = null ; } } return $ this ; }
11769	public function getConnectionByRole ( $ role ) { if ( $ role === 'master' ) { return $ this -> getMaster ( ) ; } elseif ( $ role === 'slave' ) { return $ this -> pickSlave ( ) ; } elseif ( $ role === 'sentinel' ) { return $ this -> getSentinelConnection ( ) ; } }
1889	protected function getPathNodes ( ) { if ( ! $ this -> varValue ) { return ; } if ( ! \ is_array ( $ this -> varValue ) ) { $ this -> varValue = array ( $ this -> varValue ) ; } foreach ( $ this -> varValue as $ id ) { $ arrPids = $ this -> Database -> getParentRecords ( $ id , 'tl_page' ) ; array_shift ( $ arrPids ) ; $ this -> arrNodes = array_merge ( $ this -> arrNodes , $ arrPids ) ; } }
114	private function openBrowser ( $ url ) { $ url = ProcessExecutor :: escape ( $ url ) ; $ process = new ProcessExecutor ( $ this -> getIO ( ) ) ; if ( Platform :: isWindows ( ) ) { return $ process -> execute ( 'start "web" explorer "' . $ url . '"' , $ output ) ; } $ linux = $ process -> execute ( 'which xdg-open' , $ output ) ; $ osx = $ process -> execute ( 'which open' , $ output ) ; if ( 0 === $ linux ) { $ process -> execute ( 'xdg-open ' . $ url , $ output ) ; } elseif ( 0 === $ osx ) { $ process -> execute ( 'open ' . $ url , $ output ) ; } else { $ this -> getIO ( ) -> writeError ( 'No suitable browser opening command found, open yourself: ' . $ url ) ; } }
466	public function buildInCondition ( $ operator , $ operands , & $ params ) { array_unshift ( $ operands , $ operator ) ; return $ this -> buildCondition ( $ operands , $ params ) ; }
11318	public function getBaseData ( ) { $ data = new FluidXml ( false ) ; $ message = $ data -> addChild ( 'Message' , [ 'version' => $ this -> getApiVersion ( ) ] , true ) ; $ header = $ message -> addChild ( 'Header' , true ) ; $ header -> addChild ( 'Time' , $ this -> getTime ( ) ) ; $ itentity = $ header -> addChild ( 'Identity' , true ) ; $ itentity -> addChild ( 'UserID' , $ this -> getUserId ( ) ) ; $ body = $ message -> addChild ( 'Body' , [ 'type' => 'GetInvoice' , 'live' => $ this -> getLive ( ) ] , true ) ; $ order = $ body -> addChild ( 'Order' , [ 'paymentMethod' => $ this -> getPaymentMethod ( ) ] , true ) ; $ order -> addChild ( 'MerchantID' , $ this -> getMerchantId ( ) ) ; $ order -> addChild ( 'SiteAddress' , $ this -> getSiteAddress ( ) ) ; $ order -> addChild ( 'PostbackURL' , $ this -> getNotifyUrl ( ) ) ; $ order -> addChild ( 'SuccessURL' , $ this -> getReturnUrl ( ) ) ; $ order -> addChild ( 'FailureURL' , $ this -> getCancelUrl ( ) ) ; return $ message ; }
326	public static function sentence ( array $ words , $ twoWordsConnector = null , $ lastWordConnector = null , $ connector = ', ' ) { if ( $ twoWordsConnector === null ) { $ twoWordsConnector = Yii :: t ( 'yii' , ' and ' ) ; } if ( $ lastWordConnector === null ) { $ lastWordConnector = $ twoWordsConnector ; } switch ( count ( $ words ) ) { case 0 : return '' ; case 1 : return reset ( $ words ) ; case 2 : return implode ( $ twoWordsConnector , $ words ) ; default : return implode ( $ connector , array_slice ( $ words , 0 , - 1 ) ) . $ lastWordConnector . end ( $ words ) ; } }
8979	protected function initialize ( ) { if ( $ this -> connection -> getSchemaManager ( ) -> tablesExist ( [ $ this -> tableName ] ) ) { return ; } $ schema = new Schema ( ) ; $ table = $ schema -> createTable ( $ this -> tableName ) ; $ table -> addColumn ( 'source_name' , 'string' , [ 'length' => 255 ] ) ; $ table -> addColumn ( 'rate_value' , 'float' , [ 'precision' => 10 , 'scale' => 4 ] ) ; $ table -> addColumn ( 'currency_code' , 'string' , [ 'length' => 3 ] ) ; $ table -> addColumn ( 'rate_type' , 'string' , [ 'length' => 255 ] ) ; $ table -> addColumn ( 'rate_date' , 'date' , [ ] ) ; $ table -> addColumn ( 'base_currency_code' , 'string' , [ 'length' => 3 ] ) ; $ table -> addColumn ( 'created_at' , 'datetime' , [ ] ) ; $ table -> addColumn ( 'modified_at' , 'datetime' , [ ] ) ; $ table -> setPrimaryKey ( [ 'currency_code' , 'rate_date' , 'rate_type' , 'source_name' ] ) ; $ this -> connection -> exec ( $ schema -> toSql ( $ this -> connection -> getDatabasePlatform ( ) ) [ 0 ] ) ; }
9122	private function prepareRequest ( $ requestType ) : MemoryStream { $ ms = new MemoryStream ( ) ; $ ms -> interpolate ( "{rqtype} {path}{query} {proto}\r\n" , array ( 'rqtype' => $ requestType , 'path' => $ this -> path , 'proto' => $ this -> protocol , 'query' => ( strlen ( $ this -> queryString ) ? '?' . $ this -> queryString : '' ) ) ) ; $ ms -> interpolate ( "Host: {host}\r\n" , array ( 'host' => $ this -> getEndpoint ( ) -> getAddress ( ) ) ) ; $ this -> adjustHeaders ( $ requestType ) ; foreach ( $ this -> getHeaders ( ) as $ headerName => $ headerValue ) { if ( isset ( $ headerValue ) && strlen ( $ headerValue ) > 0 ) { $ ms -> interpolate ( "{headerName}: {headerValue}\r\n" , array ( 'headerName' => $ headerName , 'headerValue' => $ headerValue ) ) ; } } $ ms -> write ( "\r\n" ) ; return $ ms ; }
8660	private function convertGetReportList ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetReportList' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetMaxCount ( ) ) { $ parameters [ 'MaxCount' ] = $ request -> getMaxCount ( ) ; } if ( $ request -> isSetReportTypeList ( ) ) { $ reportTypeList = $ request -> getReportTypeList ( ) ; foreach ( $ reportTypeList -> getType ( ) as $ typeIndex => $ type ) { $ parameters [ 'ReportTypeList' . '.' . 'Type' . '.' . ( $ typeIndex + 1 ) ] = $ type ; } } if ( $ request -> isSetAcknowledged ( ) ) { $ parameters [ 'Acknowledged' ] = $ request -> getAcknowledged ( ) ? "true" : "false" ; } if ( $ request -> isSetAvailableFromDate ( ) ) { $ parameters [ 'AvailableFromDate' ] = $ this -> getFormattedTimestamp ( $ request -> getAvailableFromDate ( ) ) ; } if ( $ request -> isSetAvailableToDate ( ) ) { $ parameters [ 'AvailableToDate' ] = $ this -> getFormattedTimestamp ( $ request -> getAvailableToDate ( ) ) ; } if ( $ request -> isSetReportRequestIdList ( ) ) { $ reportRequestIdList = $ request -> getReportRequestIdList ( ) ; foreach ( $ reportRequestIdList -> getId ( ) as $ idIndex => $ id ) { $ parameters [ 'ReportRequestIdList' . '.' . 'Id' . '.' . ( $ idIndex + 1 ) ] = $ id ; } } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
11960	public function reduce ( Closure $ fn , $ initial = null ) { return array_reduce ( $ this -> elements , $ fn , $ initial ) ; }
235	protected function getColumnPhpType ( $ column ) { static $ typeMap = [ self :: TYPE_TINYINT => 'integer' , self :: TYPE_SMALLINT => 'integer' , self :: TYPE_INTEGER => 'integer' , self :: TYPE_BIGINT => 'integer' , self :: TYPE_BOOLEAN => 'boolean' , self :: TYPE_FLOAT => 'double' , self :: TYPE_DOUBLE => 'double' , self :: TYPE_BINARY => 'resource' , self :: TYPE_JSON => 'array' , ] ; if ( isset ( $ typeMap [ $ column -> type ] ) ) { if ( $ column -> type === 'bigint' ) { return PHP_INT_SIZE === 8 && ! $ column -> unsigned ? 'integer' : 'string' ; } elseif ( $ column -> type === 'integer' ) { return PHP_INT_SIZE === 4 && $ column -> unsigned ? 'string' : 'integer' ; } return $ typeMap [ $ column -> type ] ; } return 'string' ; }
5462	public function stretch ( $ url ) { $ this -> root = $ this -> getCommonPath ( $ this -> root , $ url -> getPath ( ) ) ; }
12101	public function setAccept ( $ accept ) { $ this -> setTag ( 'accept' , $ accept ) ; if ( $ this -> getValidator ( ) ) { $ this -> getValidator ( ) -> setOption ( 'accept' , $ accept ) ; } }
3443	public function offsetExists ( $ offset ) { return $ this -> getAccessor ( $ offset ) || $ this -> getAccessorForLanguageField ( $ offset ) ? true : isset ( $ this -> fields [ $ offset ] ) ; }
7928	public function unregisterNamespace ( $ ns ) { list ( $ ns ) = $ this -> fireEvent ( 'namespace.unregister' , [ $ ns ] ) ; unset ( $ this -> namespaces [ $ ns ] ) ; return $ this ; }
10203	public function setVertical ( $ pValue ) { if ( $ pValue == '' ) { $ pValue = self :: VERTICAL_BOTTOM ; } if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'vertical' => $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> vertical = $ pValue ; } return $ this ; }
11848	private function checkReadOnly ( ) { if ( true === $ this -> _readOnly ) { $ this -> _pushError ( '' , self :: ERR_READ_ONLY , 'This row has been marked read-only' ) ; return false ; } return true ; }
5786	private function databaseRecordNotFound ( Response $ response , $ primaryKey , TableMapper $ tableMapper , string $ routeAction , ? string $ title = null ) { if ( $ routeAction != 'update' && $ routeAction != 'delete' ) { throw new \ Exception ( "routeAction $routeAction must be update or delete" ) ; } $ this -> events -> insertWarning ( EVENT_QUERY_NO_RESULTS , [ $ tableMapper -> getPrimaryKeyColumnName ( ) => $ primaryKey , 'table' => $ tableMapper -> getTableName ( ) ] ) ; $ noticeTitle = ( $ title != null ) ? $ title : 'Record' ; SlimPostgres :: setAdminNotice ( "$noticeTitle $primaryKey Not Found" , 'failure' ) ; return $ response -> withRedirect ( $ this -> router -> pathFor ( SlimPostgres :: getRouteName ( true , $ this -> routePrefix , 'index' ) ) ) ; }
7674	function TbsStoreLoad ( $ idx , $ file = false ) { $ this -> TBS -> Source = $ this -> TbsStoreGet ( $ idx , false ) ; $ this -> TbsCurrIdx = $ idx ; if ( $ file === false ) $ file = $ this -> TbsGetFileName ( $ idx ) ; $ this -> TBS -> OtbsCurrFile = $ file ; }
2230	protected function getTargetFolders ( $ strFolder , $ intLevel = 1 ) { $ strFolders = '' ; $ strPath = Contao \ System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) . '/' . $ strFolder ; foreach ( scan ( $ strPath ) as $ strFile ) { if ( ! is_dir ( $ strPath . '/' . $ strFile ) || strncmp ( $ strFile , '.' , 1 ) === 0 ) { continue ; } $ strRelPath = $ strFolder . '/' . $ strFile ; $ strFolders .= sprintf ( '<option value="%s"%s>%s%s</option>' , $ strRelPath , ( ( Contao \ Input :: post ( 'target' ) == $ strRelPath ) ? ' selected="selected"' : '' ) , str_repeat ( ' &nbsp; ' , $ intLevel ) , basename ( $ strRelPath ) ) ; $ strFolders .= $ this -> getTargetFolders ( $ strRelPath , ( $ intLevel + 1 ) ) ; } return $ strFolders ; }
7681	function TbsPrepareMergeCell ( & $ Txt , & $ Loc ) { if ( $ this -> ExtEquiv == 'docx' ) { $ xml = clsTbsXmlLoc :: FindStartTag ( $ Txt , 'w:tcPr' , $ Loc -> PosBeg , false ) ; if ( $ xml ) { $ Txt = substr_replace ( $ Txt , '' , $ Loc -> PosBeg , $ Loc -> PosEnd - $ Loc -> PosBeg + 1 ) ; $ Loc -> PosBeg = $ xml -> PosEnd + 1 ; $ Loc -> PosEnd = $ xml -> PosEnd ; $ this -> PrevVals [ $ Loc -> FullName ] = '' ; $ Loc -> ConvStr = false ; } } }
8364	public static function setCurrentLanguage ( $ language ) { self :: $ currentLanguage = $ language ; Session :: set ( '_stray_language' , self :: $ currentLanguage ) ; setlocale ( LC_ALL , $ language ) ; }
10892	public function isPrime ( ) { if ( $ this -> value < 2 ) { return false ; } if ( $ this -> value === 2 ) { return true ; } if ( $ this -> isEven ( ) ) { return false ; } for ( $ i = 3 ; $ i <= ceil ( sqrt ( $ this -> value ) ) ; $ i = $ i + 2 ) { if ( $ this -> value % $ i == 0 ) { return false ; } } return true ; }
7278	public function input ( $ name = null , $ default = null ) { return ! $ name ? $ this -> inputs : ( $ this -> inputs [ $ name ] ?? $ default ) ; }
3699	private function parseListing ( ) { $ listing = $ this -> definition -> getListingConfig ( ) ; if ( null === $ listing -> getRootLabel ( ) ) { $ listing -> setRootLabel ( $ this -> metaModel -> get ( 'name' ) ) ; } if ( null === $ listing -> getRootIcon ( ) ) { $ listing -> setRootIcon ( $ this -> iconBuilder -> getBackendIcon ( $ this -> inputScreen [ 'meta' ] [ 'backendicon' ] ) ) ; } $ this -> parseListSorting ( $ listing ) ; $ this -> parseListLabel ( $ listing ) ; $ listing -> setShowColumns ( ( bool ) $ this -> inputScreen [ 'meta' ] [ 'showColumns' ] ) ; }
4047	public function buildWidget ( BuildWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) || ( $ event -> getProperty ( ) -> getName ( ) !== 'jumpTo' ) ) { return ; } $ model = $ event -> getModel ( ) ; $ metaModel = $ this -> factory -> getMetaModel ( $ this -> factory -> translateIdToMetaModelName ( $ model -> getProperty ( 'pid' ) ) ) ; $ extra = $ event -> getProperty ( ) -> getExtra ( ) ; if ( $ metaModel -> isTranslated ( ) ) { $ arrLanguages = [ ] ; foreach ( ( array ) $ metaModel -> getAvailableLanguages ( ) as $ strLangCode ) { $ arrLanguages [ $ strLangCode ] = $ this -> translator -> trans ( 'LNG.' . $ strLangCode , [ ] , 'contao_languages' ) ; } asort ( $ arrLanguages ) ; $ extra [ 'minCount' ] = count ( $ arrLanguages ) ; $ extra [ 'maxCount' ] = count ( $ arrLanguages ) ; $ extra [ 'columnFields' ] [ 'langcode' ] [ 'options' ] = $ arrLanguages ; } else { $ extra [ 'minCount' ] = 1 ; $ extra [ 'maxCount' ] = 1 ; $ extra [ 'columnFields' ] [ 'langcode' ] [ 'options' ] = [ 'xx' => $ this -> translator -> trans ( 'tl_metamodel_rendersettings.jumpTo_allLanguages' , [ ] , 'contao_tl_metamodel_rendersettings' ) ] ; } $ extra [ 'columnFields' ] [ 'filter' ] [ 'options' ] = $ this -> getFilterSettings ( $ model ) ; $ event -> getProperty ( ) -> setExtra ( $ extra ) ; }
4808	public function unschedule_specific_event ( $ timestamp = '' ) { if ( empty ( $ timestamp ) ) { $ timestamp = wp_next_scheduled ( $ this -> args [ 'name' ] , $ this -> args [ 'args' ] ) ; } wp_unschedule_event ( $ timestamp , $ this -> args [ 'name' ] , $ this -> args [ 'args' ] ) ; }
2287	public static function findActiveByEmailAndUsername ( $ strEmail , $ strUsername = null , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ time = Date :: floorToMinute ( ) ; $ arrColumns = array ( "$t.email=? AND $t.login='1' AND ($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.disable=''" ) ; if ( $ strUsername !== null ) { $ arrColumns [ ] = "$t.username=?" ; } return static :: findOneBy ( $ arrColumns , array ( $ strEmail , $ strUsername ) , $ arrOptions ) ; }
536	protected function cleanDocComment ( $ doc ) { $ lines = explode ( "\n" , $ doc ) ; $ n = \ count ( $ lines ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ lines [ $ i ] = rtrim ( $ lines [ $ i ] ) ; if ( trim ( $ lines [ $ i ] ) == '*' && trim ( $ lines [ $ i + 1 ] ) == '*' ) { unset ( $ lines [ $ i ] ) ; } } return implode ( "\n" , $ lines ) ; }
8485	public static function getCpuModel ( ) { $ wmi = Windows :: getInstance ( ) ; $ object = $ wmi -> ExecQuery ( "SELECT Name FROM Win32_Processor" ) ; foreach ( $ object as $ cpu ) { return $ cpu -> Name ; } return 'Unknown' ; }
8507	public function getPackageLabels ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_GetPackageLabelsRequest ) ) { $ request = new FBAInboundServiceMWS_Model_GetPackageLabelsRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetPackageLabels' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_GetPackageLabelsResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
9320	protected function getEchoMethods ( ) { $ methods = [ 'compileRawEchos' => strlen ( stripcslashes ( $ this -> rawTags [ 0 ] ) ) , 'compileEscapedEchos' => strlen ( stripcslashes ( $ this -> escapedTags [ 0 ] ) ) , 'compileMarkdownEchos' => strlen ( stripcslashes ( $ this -> markdownTags [ 0 ] ) ) , 'compileRegularEchos' => strlen ( stripcslashes ( $ this -> contentTags [ 0 ] ) ) , ] ; uksort ( $ methods , function ( $ method1 , $ method2 ) use ( $ methods ) { if ( $ methods [ $ method1 ] > $ methods [ $ method2 ] ) { return - 1 ; } if ( $ methods [ $ method1 ] < $ methods [ $ method2 ] ) { return 1 ; } if ( $ method1 === 'compileRawEchos' ) { return - 1 ; } if ( $ method2 === 'compileRawEchos' ) { return 1 ; } if ( $ method1 === 'compileEscapedEchos' ) { return - 1 ; } if ( $ method2 === 'compileEscapedEchos' ) { return 1 ; } if ( $ method1 === 'compileMarkdownEchos' ) { return - 1 ; } if ( $ method2 === 'compileMarkdownEchos' ) { return 1 ; } } ) ; return $ methods ; }
4691	public function having ( ? string $ expression = null , ... $ args ) : self { $ this -> dirty ( ) ; $ this -> having = $ expression ; $ this -> args [ 'having' ] = $ args ; return $ this ; }
8898	public function update ( $ primary_value , $ data ) { $ data = $ this -> _do_pre_update ( $ data ) ; if ( $ data !== FALSE ) { $ result = $ this -> _database -> where ( $ this -> primary_key , $ primary_value ) -> set ( $ data ) -> update ( $ this -> _table ) ; $ this -> trigger ( 'after_update' , array ( $ data , $ result ) ) ; return $ result ; } else { return FALSE ; } }
10536	public function extractHeaders ( ) { $ headers = [ ] ; $ requestHeaders = array_keys ( $ this -> cors ) ; foreach ( $ requestHeaders as $ headerField ) { $ serverField = $ this -> headerizeToPhp ( $ headerField ) ; $ headerData = isset ( $ _SERVER [ $ serverField ] ) ? $ _SERVER [ $ serverField ] : null ; if ( $ headerData !== null ) { $ headers [ $ headerField ] = $ headerData ; } } return $ headers ; }
10082	protected function registerConfigurator ( ) { $ this -> app -> singleton ( 'auja.database' , function ( $ app ) { $ config = $ app [ 'config' ] [ 'auja-laravel' ] ? : $ app [ 'config' ] [ 'auja-laravel::config' ] ; switch ( $ config [ 'database' ] ) { case 'mysql' : return new MySQLDatabaseHelper ( ) ; break ; default : throw new NoDatabaseHelperException ( 'No Auja database helper for ' . $ config [ 'database' ] ) ; break ; } } ) ; $ this -> app -> bind ( 'Label305\AujaLaravel\Database\DatabaseHelper' , 'auja.database' ) ; $ this -> app -> singleton ( 'auja.configurator' , function ( $ app ) { return new AujaConfigurator ( $ app , $ app [ 'auja.database' ] ) ; } ) ; $ this -> app -> bind ( 'Label305\AujaLaravel\Config\AujaConfigurator' , 'auja.configurator' ) ; }
11765	public function remove ( ExpressionContract $ e ) { unset ( $ this -> expressions [ $ this -> indexOf ( $ e ) ] ) ; $ this -> expressions = array_values ( $ this -> expressions ) ; return $ this ; }
3495	public function add ( HttpProtocolVisitorInterface $ visitor , int $ priority = 0 ) : void { $ this -> visitors -> insert ( $ visitor , $ priority ) ; }
2488	protected function getSortFieldName ( SortClause $ sortClause , $ contentTypeIdentifier , $ fieldDefinitionIdentifier ) { return $ this -> fieldNameResolver -> getSortFieldName ( $ sortClause , $ contentTypeIdentifier , $ fieldDefinitionIdentifier ) ; }
11063	public function getRealEncoding ( $ encoding ) { if ( static :: isEncodingSupported ( $ encoding ) === false ) { throw new \ Exception ( 'Encoding is not supported: "' . $ encoding . '"' ) ; } return static :: supportedEncodings ( ) [ strtolower ( $ encoding ) ] ; }
10148	private function readMsoDrawingGroup ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ splicedRecordData = $ this -> getSplicedRecordData ( ) ; $ recordData = $ splicedRecordData [ 'recordData' ] ; $ this -> drawingGroupData .= $ recordData ; }
7884	public function getShow ( $ date , $ level = null ) { $ logs = LogViewer :: logs ( ) ; if ( ! is_string ( $ level ) ) { $ level = 'all' ; } $ page = Input :: get ( 'page' ) ; if ( empty ( $ page ) ) { $ page = '1' ; } $ data = [ 'logs' => $ logs , 'date' => $ date , 'url' => 'logviewer' , 'data_url' => URL :: route ( 'logviewer.index' ) . '/data/' . $ date . '/' . $ level . '?page=' . $ page , 'levels' => LogViewer :: levels ( ) , 'current' => $ level , ] ; return View :: make ( 'logviewer::show' , $ data ) ; }
7651	public function rename ( $ path_from , $ path_to ) { if ( $ this -> getContainerName ( $ path_from ) != $ this -> getContainerName ( $ path_to ) ) { throw new BlobException ( 'Container name can not be changed.' ) ; } if ( $ this -> getFileName ( $ path_from ) == $ this -> getContainerName ( $ path_to ) ) { return true ; } $ this -> getStorageClient ( $ path_from ) -> copyBlob ( $ this -> getContainerName ( $ path_from ) , $ this -> getFileName ( $ path_from ) , $ this -> getContainerName ( $ path_to ) , $ this -> getFileName ( $ path_to ) ) ; $ this -> getStorageClient ( $ path_from ) -> deleteBlob ( $ this -> getContainerName ( $ path_from ) , $ this -> getFileName ( $ path_from ) ) ; clearstatcache ( true , $ path_from ) ; clearstatcache ( true , $ path_to ) ; return true ; }
3995	public function replaceTags ( $ strTag ) { $ arrElements = explode ( '::' , $ strTag ) ; if ( $ arrElements [ 0 ] != 'mm' ) { return false ; } try { switch ( $ arrElements [ 1 ] ) { case 'total' : return $ this -> getCount ( $ arrElements [ 2 ] , $ arrElements [ 3 ] ) ; case 'attribute' : return $ this -> getAttribute ( $ arrElements [ 2 ] , $ arrElements [ 3 ] , $ arrElements [ 4 ] , $ arrElements [ 5 ] ) ; case 'item' : return $ this -> getItem ( $ arrElements [ 2 ] , $ arrElements [ 3 ] , $ arrElements [ 4 ] , $ arrElements [ 5 ] ) ; case 'jumpTo' : return $ this -> jumpTo ( $ arrElements [ 2 ] , $ arrElements [ 3 ] , $ arrElements [ 4 ] , $ arrElements [ 5 ] ) ; default : } } catch ( \ Exception $ exc ) { System :: log ( 'Error by replace tags: ' . $ exc -> getMessage ( ) , __CLASS__ . ' | ' . __FUNCTION__ , TL_ERROR ) ; } return false ; }
4861	public function pushLazy ( $ service , $ payload = null , array $ options = [ ] ) { $ manager = $ this -> getJobPluginManager ( ) ; $ serviceOptions = [ ] ; if ( is_array ( $ service ) ) { $ serviceOptions = $ service [ 'options' ] ?? $ service [ 1 ] ?? [ ] ; $ service = $ service [ 'name' ] ?? $ service [ 0 ] ?? null ; } if ( ! $ manager -> has ( $ service ) && ! class_exists ( $ service ) ) { throw new \ UnexpectedValueException ( sprintf ( 'Service name "%s" is not a known job service or existent class' , $ service ) ) ; } $ lazyOptions = [ 'name' => $ service , 'options' => $ serviceOptions , 'content' => $ payload , ] ; $ job = $ this -> getJobPluginManager ( ) -> build ( 'lazy' , $ lazyOptions ) ; $ this -> push ( $ job , $ options ) ; }
7317	public function toJD ( $ scale = null ) { if ( $ scale ) { return bcadd ( ( string ) $ this -> jd , ( string ) $ this -> dayFrac , $ scale ) ; } else { return $ this -> jd + $ this -> dayFrac ; } }
11882	private function prepareFieldOptions ( CustomField $ customField , $ type ) { $ options = $ customField -> getOptions ( ) ; $ fieldOptions = array ( ) ; $ fieldOptions [ 'required' ] = False ; $ fieldOptions [ 'label' ] = $ this -> translatableStringHelper -> localize ( $ customField -> getName ( ) ) ; if ( $ options [ self :: MIN ] !== NULL ) { $ fieldOptions [ 'constraints' ] [ ] = new GreaterThanOrEqual ( array ( 'value' => $ options [ self :: MIN ] ) ) ; } if ( $ options [ self :: MAX ] !== NULL ) { $ fieldOptions [ 'constraints' ] [ ] = new LessThanOrEqual ( array ( 'value' => $ options [ self :: MAX ] ) ) ; } if ( $ type === 'number' ) { $ fieldOptions [ 'scale' ] = $ options [ self :: SCALE ] ; } if ( ! empty ( $ options [ self :: POST_TEXT ] ) ) { $ fieldOptions [ 'post_text' ] = $ options [ self :: POST_TEXT ] ; } return $ fieldOptions ; }
2291	public function onKernelTerminate ( PostResponseEvent $ event ) : void { if ( ! $ this -> framework -> isInitialized ( ) ) { return ; } $ request = $ event -> getRequest ( ) ; if ( ! $ request -> isMethod ( Request :: METHOD_GET ) ) { return ; } if ( preg_match ( '~(?:^|/)' . preg_quote ( $ this -> fragmentPath , '~' ) . '/~' , $ request -> getPathInfo ( ) ) ) { return ; } $ frontend = $ this -> framework -> getAdapter ( Frontend :: class ) ; $ frontend -> indexPageIfApplicable ( $ event -> getResponse ( ) ) ; }
7513	function next_no_whitespace ( ) { $ this -> token_start = null ; while ( ++ $ this -> pos < $ this -> size ) { if ( ! isset ( $ this -> whitespace [ $ this -> doc [ $ this -> pos ] ] ) ) { if ( isset ( $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ) { if ( is_string ( $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ) { return ( $ this -> token = $ this -> { $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] } ( ) ) ; } else { return ( $ this -> token = $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ; } } else { return ( $ this -> token = self :: TOK_UNKNOWN ) ; } } else { $ this -> parse_linebreak ( ) ; } } return ( $ this -> token = self :: TOK_NULL ) ; }
2857	public function viewHandleAction ( ) { $ area = $ this -> getRequest ( ) -> getParam ( 'area' ) ; $ storeId = ( int ) $ this -> getRequest ( ) -> getParam ( 'store' ) ; $ handle = $ this -> getRequest ( ) -> getParam ( 'handle' ) ; $ updatesByFile = $ this -> getService ( ) -> getFileUpdatesWithHandle ( $ handle , $ storeId , $ area ) ; $ databaseUpdates = $ this -> getService ( ) -> getDatabaseUpdatesWithHandle ( $ handle , $ storeId , $ area ) ; $ block = $ this -> getLayout ( ) -> createBlock ( 'sheep_debug/view' , '' , array ( 'template' => 'sheep_debug/view/panel/_layout_updates.phtml' , 'file_updates' => $ updatesByFile , 'db_updates' => $ databaseUpdates ) ) ; $ this -> getResponse ( ) -> setBody ( $ block -> toHtml ( ) ) ; }
6804	public function installCustomerGroups ( ) { $ groups = ( array ) $ this -> customerGroupRepository -> findBy ( [ ] , [ ] , 1 ) -> getIterator ( ) ; if ( ! empty ( $ groups ) ) { call_user_func ( $ this -> log , 'All' , 'skipped' ) ; return ; } $ groups = [ 'Particuliers' => [ 'default' => true , 'business' => false , 'registration' => true , ] , 'Entreprise' => [ 'default' => false , 'business' => true , 'registration' => true , ] , ] ; foreach ( $ groups as $ name => $ config ) { $ result = 'already exists' ; if ( null === $ this -> customerGroupRepository -> findOneBy ( [ 'name' => $ name ] ) ) { $ customerGroup = $ this -> customerGroupRepository -> createNew ( ) ; $ customerGroup -> setName ( $ name ) -> setDefault ( $ config [ 'default' ] ) -> setBusiness ( $ config [ 'business' ] ) -> setRegistration ( $ config [ 'registration' ] ) -> translate ( ) -> setTitle ( $ name ) ; $ this -> manager -> persist ( $ customerGroup ) ; $ result = 'done' ; } call_user_func ( $ this -> log , $ name , $ result ) ; } $ this -> manager -> flush ( ) ; }
3684	protected function buildNativeSqlProcedure ( FilterBuilderSql $ procedure , $ children ) { $ skipped = array ( ) ; $ metaModel = $ this -> getMetaModel ( ) ; $ tableName = $ metaModel -> getTableName ( ) ; foreach ( $ children as $ child ) { if ( isset ( $ child [ 'property' ] ) && $ metaModel -> hasAttribute ( $ child [ 'property' ] ) ) { $ skipped [ ] = $ child ; continue ; } if ( ( 'AND' === $ child [ 'operation' ] ) || ( 'OR' === $ child [ 'operation' ] ) ) { if ( null === $ child [ 'children' ] ) { continue ; } $ subProcedure = new FilterBuilderSql ( $ tableName , $ child [ 'operation' ] , $ this -> connection ) ; $ subSkipped = $ this -> buildNativeSqlProcedure ( $ subProcedure , $ child [ 'children' ] ) ; if ( count ( $ subSkipped ) !== count ( $ child [ 'children' ] ) ) { $ procedure -> addSubProcedure ( $ subProcedure ) ; } if ( ! empty ( $ subSkipped ) ) { $ skipped += $ subSkipped ; } continue ; } $ procedure -> addChild ( $ child ) ; } return $ skipped ; }
5248	public function find ( $ id ) { $ child = $ this -> childClassName ; $ model = $ child :: findWithParentId ( $ id , $ this -> parent -> getId ( ) ) ; if ( $ model ) { $ model -> setParent ( $ this -> parent ) ; } return $ model ; }
5773	public function isUpdatable ( ) : bool { if ( is_null ( $ this -> authorization ) ) { throw new \ Exception ( "Authorization must be set" ) ; } if ( $ this -> authorization -> hasTopRole ( ) ) { return true ; } if ( ! $ this -> hasTopRole ( ) ) { return true ; } return false ; }
6760	static public function buildCacheKey ( $ columns = '*' , array $ conditionsAndOptions = [ ] ) { foreach ( $ conditionsAndOptions as & $ value ) { if ( $ value instanceof DbExpr ) { $ value = $ value -> get ( ) ; } else if ( is_object ( $ value ) ) { throw new \ InvalidArgumentException ( '$conditionsAndOptions argument may contain only strings and objects of class \PeskyORM\Core\DbExpr.' . ' Object of class ' . get_class ( $ value ) . ' detected' ) ; } } unset ( $ value ) ; if ( is_array ( $ columns ) ) { foreach ( $ columns as & $ value ) { if ( $ value instanceof DbExpr ) { $ value = $ value -> get ( ) ; } else if ( is_object ( $ value ) ) { throw new \ InvalidArgumentException ( '$columns argument may contain only strings and objects of class \PeskyORM\Core\DbExpr.' . ' Object of class ' . get_class ( $ value ) . ' detected' ) ; } } unset ( $ value ) ; } else if ( $ columns instanceof DbExpr ) { $ columns = $ columns -> get ( ) ; } return hash ( 'sha256' , json_encode ( array ( $ columns , $ conditionsAndOptions ) ) ) ; }
11771	private function retryCommandOnFailure ( CommandInterface $ command , $ method ) { $ retries = 0 ; SENTINEL_RETRY : { try { $ response = $ this -> getConnectionByCommand ( $ command ) -> $ method ( $ command ) ; } catch ( CommunicationException $ exception ) { $ this -> wipeServerList ( ) ; $ exception -> getConnection ( ) -> disconnect ( ) ; if ( $ retries == $ this -> retryLimit ) { throw $ exception ; } usleep ( $ this -> retryWait * 1000 ) ; ++ $ retries ; goto SENTINEL_RETRY ; } } return $ response ; }
12797	public function mb_str_pad ( $ input , $ length , $ string = ' ' , $ type = STR_PAD_LEFT ) { return str_pad ( $ input , $ length + strlen ( $ input ) - mb_strlen ( $ input ) , $ string , $ type ) ; }
2006	protected function removeRecipient ( $ strEmail , $ arrRemove ) { if ( ( $ objRemove = NewsletterRecipientsModel :: findByEmailAndPids ( $ strEmail , $ arrRemove ) ) !== null ) { while ( $ objRemove -> next ( ) ) { $ strHash = md5 ( $ objRemove -> email ) ; if ( ( $ objBlacklist = NewsletterBlacklistModel :: findByHashAndPid ( $ strHash , $ objRemove -> pid ) ) === null ) { $ objBlacklist = new NewsletterBlacklistModel ( ) ; $ objBlacklist -> pid = $ objRemove -> pid ; $ objBlacklist -> hash = $ strHash ; $ objBlacklist -> save ( ) ; } $ objRemove -> delete ( ) ; } } $ objChannels = NewsletterChannelModel :: findByIds ( $ arrRemove ) ; $ arrChannels = $ objChannels -> fetchEach ( 'title' ) ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'removeRecipient' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'removeRecipient' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'removeRecipient' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ strEmail , $ arrRemove ) ; } } $ arrData = array ( ) ; $ arrData [ 'domain' ] = Idna :: decode ( Environment :: get ( 'host' ) ) ; $ arrData [ 'channel' ] = $ arrData [ 'channels' ] = implode ( "\n" , $ arrChannels ) ; $ objEmail = new Email ( ) ; $ objEmail -> from = $ GLOBALS [ 'TL_ADMIN_EMAIL' ] ; $ objEmail -> fromName = $ GLOBALS [ 'TL_ADMIN_NAME' ] ; $ objEmail -> subject = sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'nl_subject' ] , Idna :: decode ( Environment :: get ( 'host' ) ) ) ; $ objEmail -> text = StringUtil :: parseSimpleTokens ( $ this -> nl_unsubscribe , $ arrData ) ; $ objEmail -> sendTo ( $ strEmail ) ; if ( ( $ objTarget = $ this -> objModel -> getRelated ( 'jumpTo' ) ) instanceof PageModel ) { $ this -> redirect ( $ objTarget -> getFrontendUrl ( ) ) ; } System :: getContainer ( ) -> get ( 'session' ) -> getFlashBag ( ) -> set ( 'nl_removed' , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'nl_removed' ] ) ; $ this -> reload ( ) ; }
8140	public function createTemplate ( $ template ) { $ name = sprintf ( '__string_template__%s' , hash ( 'sha256' , $ template , false ) ) ; $ loader = new Twig_Loader_Chain ( array ( new Twig_Loader_Array ( array ( $ name => $ template ) ) , $ current = $ this -> getLoader ( ) , ) ) ; $ this -> setLoader ( $ loader ) ; try { $ template = $ this -> loadTemplate ( $ name ) ; } catch ( Exception $ e ) { $ this -> setLoader ( $ current ) ; throw $ e ; } catch ( Throwable $ e ) { $ this -> setLoader ( $ current ) ; throw $ e ; } $ this -> setLoader ( $ current ) ; return $ template ; }
11518	protected function GenerateHTML5Favicon ( SiteTree $ owner , & $ metadata , Image $ HTML5Favicon ) { $ metadata .= $ owner -> MarkupComment ( 'HTML5 Favicon' ) ; $ metadata .= $ owner -> MarkupLink ( 'icon' , $ HTML5Favicon -> Fill ( 192 , 192 ) -> getAbsoluteURL ( ) , 'image/png' , '192x192' ) ; $ metadata .= $ owner -> MarkupLink ( 'icon' , $ HTML5Favicon -> Fill ( 128 , 128 ) -> getAbsoluteURL ( ) , 'image/png' , '128x128' ) ; $ metadata .= $ owner -> MarkupLink ( 'icon' , $ HTML5Favicon -> Fill ( 96 , 96 ) -> getAbsoluteURL ( ) , 'image/png' , '96x96' ) ; $ metadata .= $ owner -> MarkupLink ( 'icon' , $ HTML5Favicon -> Fill ( 32 , 32 ) -> getAbsoluteURL ( ) , 'image/png' , '32x32' ) ; $ metadata .= $ owner -> MarkupLink ( 'icon' , $ HTML5Favicon -> Fill ( 16 , 16 ) -> getAbsoluteURL ( ) , 'image/png' , '16x16' ) ; }
11350	public function getData ( ) { $ data = [ ] ; foreach ( $ this -> fields as $ field ) { if ( preg_match ( '/^(.*?)(\[.*\])$/' , $ field -> getName ( ) , $ result ) ) { if ( $ result [ 2 ] == '' ) { } else { if ( ! preg_match_all ( "/\[(.*?)\]/" , $ result [ 2 ] , $ resultDeep ) ) { throw new \ Exception ( 'Invalid field name.' ) ; } $ storage = & $ data [ $ result [ 1 ] ] ; foreach ( $ resultDeep [ 1 ] as $ deep ) { if ( ! isset ( $ storage [ $ deep ] ) ) { $ storage [ $ deep ] = [ ] ; } $ storage = & $ storage [ $ deep ] ; } $ storage = $ field -> getData ( ) ; } } else { $ data [ $ field -> getName ( ) ] = $ field -> getData ( ) ; } } return $ this -> transformer -> decode ( $ data ) ; }
1348	public function allow ( string $ resourceType , array $ fields = null ) : self { $ this -> all = false ; $ this -> allowed [ $ resourceType ] = $ fields ; return $ this ; }
4952	protected function checkRatingValue ( $ rating , $ throwException = true ) { if ( ! is_int ( $ rating ) || static :: RATING_EXCELLENT < $ rating || static :: RATING_NONE > $ rating ) { if ( $ throwException ) { throw new \ InvalidArgumentException ( sprintf ( '%s is not a valid rating value.' , $ rating ) ) ; } return false ; } return true ; }
9290	public function applySerializeMetadataToArray ( array $ array , $ className ) { $ classMetadata = $ this -> documentManager -> getClassMetadata ( $ className ) ; $ fieldList = $ this -> fieldListForSerialize ( $ classMetadata ) ; $ return = array_merge ( $ array , $ this -> serializeClassNameAndDiscriminator ( $ classMetadata ) ) ; foreach ( $ classMetadata -> fieldMappings as $ field => $ mapping ) { if ( ! in_array ( $ field , $ fieldList ) ) { if ( isset ( $ return [ $ field ] ) ) { unset ( $ return [ $ field ] ) ; } continue ; } if ( isset ( $ mapping [ 'id' ] ) && $ mapping [ 'id' ] && isset ( $ array [ '_id' ] ) ) { $ return [ $ field ] = $ array [ '_id' ] ; unset ( $ return [ '_id' ] ) ; } if ( ! isset ( $ return [ $ field ] ) ) { continue ; } $ return [ $ field ] = $ this -> applySerializeMetadataToField ( $ return [ $ field ] , $ field , $ className ) ; } return $ return ; }
3965	protected function authenticateUser ( ) { if ( \ System :: getContainer ( ) -> get ( 'cca.dc-general.scope-matcher' ) -> currentScopeIsUnknown ( ) ) { return false ; } if ( strpos ( Environment :: get ( 'script' ) , 'contao/login' ) !== false ) { return false ; } if ( strpos ( Environment :: get ( 'request' ) , 'install' ) !== false ) { return false ; } if ( strpos ( Environment :: get ( 'script' ) , 'system/bin' ) !== false ) { return false ; } $ authResult = $ this -> getUser ( ) -> authenticate ( ) ; return ( $ authResult === true || $ authResult === null ) ? true : false ; }
6145	public function checkFragment ( $ fragment = null ) { if ( $ fragment === null ) { $ fragment = $ this -> fragment ; } if ( strlen ( $ fragment ) == 0 ) { return true ; } $ pattern = "/^" . $ this -> regex [ "uric" ] . "*$/" ; $ status = @ preg_match ( $ pattern , $ fragment ) ; if ( $ status === false ) { throw new Ts3Exception ( "URI fragment validation failed" ) ; } return ( $ status == 1 ) ; }
11716	public static function entry ( $ argv ) : void { self :: initialize ( ) ; if ( isset ( $ argv [ 1 ] ) ) { $ command = $ argv [ 1 ] ; } else { return ; } if ( ! in_array ( $ command , array_keys ( self :: $ commands ) ) ) { return ; } $ arguments = [ ] ; $ options = [ ] ; for ( $ index = 2 ; $ index < count ( $ argv ) ; $ index ++ ) { list ( $ key , $ value ) = Service :: parse ( $ argv [ $ index ] ) ; if ( Service :: determineTypeOfWord ( $ argv [ $ index ] ) == Service :: OPTION_TYPE ) { if ( ! $ value ) { $ options [ $ key ] = true ; } else { $ options [ $ key ] = $ value ; } } else { $ arguments [ ] = $ key ; } } Service :: runCommand ( self :: $ commands [ $ command ] , $ arguments , $ options ) ; }
1726	protected function checkAccountStatus ( ) { @ trigger_error ( 'Using User::checkAccountStatus() has been deprecated and will no longer work in Contao 5.0. Use Symfony security instead.' , E_USER_DEPRECATED ) ; try { $ userChecker = System :: getContainer ( ) -> get ( 'contao.security.user_checker' ) ; $ userChecker -> checkPreAuth ( $ this ) ; $ userChecker -> checkPostAuth ( $ this ) ; } catch ( AuthenticationException $ exception ) { return false ; } return true ; }
4592	public function submit ( $ id , array $ variables ) { foreach ( $ variables as $ variable ) { if ( ! $ variable instanceof Variable ) { throw new InvalidArgumentException ( 'Array of variables is not valid.' ) ; } } $ resource = str_replace ( '{id}' , $ id , static :: RESOURCE_SUBMIT ) ; $ options = [ 'headers' => [ 'Accept' => 'application/json' , 'Content-Type' => 'application/json' ] ] ; foreach ( $ variables as $ variable ) { $ options [ 'json' ] [ 'variables' ] [ $ variable -> getName ( ) ] = [ 'value' => Variable :: TYPE_JSON === $ variable -> getType ( ) ? json_encode ( $ variable -> getValue ( ) ) : $ variable -> getValue ( ) , 'type' => $ variable -> getType ( ) ] ; } $ this -> execute ( 'POST' , $ resource , $ options ) ; }
8152	public function getExtension ( $ class ) { $ class = ltrim ( $ class , '\\' ) ; if ( ! isset ( $ this -> extensionsByClass [ $ class ] ) && class_exists ( $ class , false ) ) { $ class = new ReflectionClass ( $ class ) ; $ class = $ class -> name ; } if ( isset ( $ this -> extensions [ $ class ] ) ) { if ( $ class !== get_class ( $ this -> extensions [ $ class ] ) ) { @ trigger_error ( sprintf ( 'Referencing the "%s" extension by its name (defined by getName()) is deprecated since 1.26 and will be removed in Twig 2.0. Use the Fully Qualified Extension Class Name instead.' , $ class ) , E_USER_DEPRECATED ) ; } return $ this -> extensions [ $ class ] ; } if ( ! isset ( $ this -> extensionsByClass [ $ class ] ) ) { throw new Twig_Error_Runtime ( sprintf ( 'The "%s" extension is not enabled.' , $ class ) ) ; } return $ this -> extensionsByClass [ $ class ] ; }
9102	protected function build_sql ( ) { $ builder = new Builder ( ) ; $ select = $ this -> parse_select ( ) ; $ from = new From ( $ this -> table -> get_table_name ( $ GLOBALS [ 'wpdb' ] ) , 'q' ) ; $ where = new Where ( 1 , true , 1 ) ; if ( ( $ message = $ this -> parse_message ( ) ) !== null ) { $ where -> qAnd ( $ message ) ; } if ( ( $ level = $ this -> parse_level ( ) ) !== null ) { $ where -> qAnd ( $ level ) ; } if ( ( $ user = $ this -> parse_user ( ) ) !== null ) { $ where -> qAnd ( $ user ) ; } if ( ( $ group = $ this -> parse_group ( ) ) !== null ) { $ where -> qAnd ( $ group ) ; } if ( ( $ time = $ this -> parse_time ( ) ) !== null ) { $ where -> qAnd ( $ time ) ; } $ order = $ this -> parse_order ( ) ; $ limit = $ this -> parse_pagination ( ) ; $ builder -> append ( $ select ) -> append ( $ from ) ; $ builder -> append ( $ where ) ; $ builder -> append ( $ order ) ; if ( $ limit !== null ) { $ builder -> append ( $ limit ) ; } return $ builder -> build ( ) ; }
2400	public function output ( ) { @ trigger_error ( 'Using Template::output() has been deprecated and will no longer work in Contao 5.0. Use Template::getResponse() instead.' , E_USER_DEPRECATED ) ; $ this -> compile ( ) ; header ( 'Content-Type: ' . $ this -> strContentType . '; charset=' . Config :: get ( 'characterSet' ) ) ; echo $ this -> strBuffer ; $ this -> flushAllData ( ) ; }
8464	public static function getDomain ( $ url = false ) { if ( $ url ) { preg_match ( '/([\w]+[.]){1,}[a-z]+/' , $ url , $ matches ) ; return isset ( $ matches [ 0 ] ) ? $ matches [ 0 ] : false ; } return $ _SERVER [ 'SERVER_NAME' ] ; }
10131	private function writeObjectProtect ( ) { if ( ! $ this -> phpSheet -> getProtection ( ) -> getSheet ( ) ) { return ; } if ( ! $ this -> phpSheet -> getProtection ( ) -> getObjects ( ) ) { return ; } $ record = 0x0063 ; $ length = 0x0002 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , 1 ) ; $ this -> append ( $ header . $ data ) ; }
10872	public function existEmail ( string $ email ) : int { return ( int ) $ this -> connection -> select ( self :: COLUMN_ID ) -> from ( $ this -> tableIdentity ) -> where ( [ 'email' => $ email ] ) -> fetchSingle ( ) ; }
10050	public function resolve ( ) { if ( is_null ( $ this -> config -> getDisplayField ( ) ) || $ this -> config -> getDisplayField ( ) == '' ) { $ this -> config -> setDisplayField ( $ this -> resolveDisplayField ( ) ) ; $ this -> config -> setVisibleFields ( $ this -> resolveVisibleFields ( ) ) ; } return $ this -> config ; }
2812	public function getObservers ( ) { if ( $ this -> observers === null ) { $ this -> observers = array ( ) ; foreach ( $ this -> getTimers ( ) as $ timerName => $ timer ) { if ( strpos ( $ timerName , 'OBSERVER' ) === 0 ) { $ this -> observers [ ] = array ( 'name' => $ timerName , 'count' => $ timer [ 'count' ] , 'sum' => round ( $ timer [ 'sum' ] * 1000 , 2 ) , 'mem_diff' => $ timer [ 'realmem' ] / pow ( 1024 , 2 ) , ) ; } } } return $ this -> observers ; }
5810	public function updateSearchableFields ( & $ fields ) { $ fields = array_merge ( array ( 'Tagging' => array ( 'title' => 'Tags' , 'field' => ListboxField :: create ( 'Tagging' , 'Tags' , FusionTag :: get ( ) -> map ( 'Title' , 'Title' ) -> toArray ( ) , ( Controller :: has_curr ( ) && ( $ filtering = Controller :: curr ( ) -> getRequest ( ) -> getVar ( 'q' ) ) && isset ( $ filtering [ 'Tagging' ] ) ) ? $ filtering [ 'Tagging' ] : array ( ) , null , true ) , 'filter' => $ this -> owner -> dbObject ( 'Tagging' ) -> stat ( 'default_search_filter_class' ) ) ) , $ fields ) ; $ this -> owner -> extend ( 'updateTaggingExtensionSearchableFields' , $ fields ) ; }
8300	public function handleEvent ( $ eventName , array $ params ) { parent :: handleEvent ( $ eventName , $ params ) ; if ( $ this -> isEnabled ( ) ) { $ this -> picoAuthPlugin -> handleEvent ( $ eventName , $ params ) ; } }
2112	public function generate ( ) { global $ objPage ; $ obj404 = $ this -> prepare ( ) ; $ objPage = $ obj404 -> loadDetails ( ) ; $ objHandler = new $ GLOBALS [ 'TL_PTY' ] [ 'regular' ] ( ) ; header ( 'HTTP/1.1 404 Not Found' ) ; $ objHandler -> generate ( $ objPage ) ; }
5679	protected function noResponse ( ) { $ this -> transport_error = 'No page fetched yet' ; $ this -> raw = false ; $ this -> sent = false ; $ this -> headers = false ; $ this -> method = 'GET' ; $ this -> url = false ; $ this -> request_data = false ; }
11940	public function getUrl ( string $ sCode , array $ aParams = array ( ) ) : string { if ( isset ( $ _SERVER ) && isset ( $ _SERVER [ 'HTTP_HOST' ] ) ) { foreach ( Config :: get ( 'route' ) as $ sHost => $ oHost ) { if ( ( ! strstr ( $ sHost , '/' ) && $ sHost == $ _SERVER [ 'HTTP_HOST' ] ) || ( strstr ( $ sHost , '/' ) && strstr ( $ _SERVER [ 'HTTP_HOST' ] . $ _SERVER [ 'REQUEST_URI' ] , $ sHost ) ) ) { if ( strstr ( $ sHost , '/' ) && strstr ( $ _SERVER [ 'HTTP_HOST' ] . $ _SERVER [ 'REQUEST_URI' ] , $ sHost ) ) { $ this -> _sBaseUri = preg_replace ( '#^[^/]+#' , '' , $ sHost ) ; } if ( isset ( $ oHost -> routes ) ) { foreach ( $ oHost -> routes as $ sKey => $ oRoute ) { if ( $ sKey === $ sCode ) { $ sRoute = $ this -> _sBaseUri . $ oRoute -> route ; if ( isset ( $ oRoute -> constraints ) ) { foreach ( $ oRoute -> constraints as $ sName => $ sType ) { if ( ! isset ( $ aParams [ $ sName ] ) ) { $ aParams [ $ sName ] = '' ; } if ( preg_match ( '#' . $ sType . '#' , $ aParams [ $ sName ] ) ) { if ( $ aParams [ $ sName ] ) { $ sRoute = str_replace ( '[/:' . $ sName . ']' , '/' . $ aParams [ $ sName ] , $ sRoute ) ; } else { $ sRoute = str_replace ( '[/:' . $ sName . ']' , '' , $ sRoute ) ; } $ sRoute = str_replace ( '[:' . $ sName . ']' , $ aParams [ $ sName ] , $ sRoute ) ; continue ; } else if ( isset ( $ oRoute -> defaults_constraints ) && isset ( $ oRoute -> defaults_constraints -> { $ sName } ) && preg_match ( '#' . $ sType . '#' , $ oRoute -> defaults_constraints -> { $ sName } ) ) { continue ; } throw new \ Exception ( 'For the route ' . $ sCode . ' the parameter ' . $ sName . ' is not good!' ) ; } } return $ sRoute ; } } } } } } }
1152	public function selector ( $ selector ) { $ this -> selector = is_null ( $ selector ) ? $ this -> selector : $ selector ; return $ this ; }
12220	public function exceptionHandler ( $ exception ) { $ request = ( isset ( $ this -> container [ 'latestRequest' ] ) ? $ this -> container [ 'latestRequest' ] : $ this -> container [ 'request' ] ) ; $ response = ( isset ( $ this -> container [ 'latestResponse' ] ) ? $ this -> container [ 'latestResponse' ] : $ this -> container [ 'response' ] ) ; if ( ! ( $ exception instanceof Exception ) ) { $ exception = new InternalServerError ( $ exception -> getMessage ( ) , $ exception -> getCode ( ) , $ exception -> getPrevious ( ) ) ; } $ this -> logException ( $ exception ) ; $ response = $ response -> withBody ( new Stream ( 'php://memory' , 'w+' ) ) ; $ response = $ response -> withStatus ( $ exception -> getStatusCode ( ) ) ; $ body = $ this -> prepareErrorBody ( $ exception ) ; $ response = $ response -> withUnserializedBody ( $ body ) ; $ this -> container [ 'pipeline' ] -> prepareErrorQueue ( ) ; $ this -> container [ 'pipeline' ] ( $ request , $ response ) ; }
4540	public function get ( string $ key ) { $ config = $ this -> repository -> findOneBy ( [ 'key' => $ key ] ) ; if ( ! $ config ) { throw new OutOfRangeException ( 'Config "' . $ key . '" does not exist.' ) ; } $ this -> manager -> detach ( $ config ) ; return $ config -> getValue ( ) ; }
423	public function hiddenInput ( $ options = [ ] ) { $ options = array_merge ( $ this -> inputOptions , $ options ) ; $ this -> adjustLabelFor ( $ options ) ; $ this -> parts [ '{input}' ] = Html :: activeHiddenInput ( $ this -> model , $ this -> attribute , $ options ) ; return $ this ; }
10354	protected function getEventName ( ) { $ chunks = explode ( '\\' , get_class ( $ this ) ) ; $ name = $ chunks [ count ( $ chunks ) - 2 ] ; return strtolower ( $ name ) ; }
6544	public function currentShardingKey ( ) { return isset ( $ this -> options [ SelectorSourceInterface :: SHARDING_KEY ] ) ? $ this -> options [ SelectorSourceInterface :: SHARDING_KEY ] : null ; }
573	public function compareString ( $ expected , $ actual ) { if ( ! is_string ( $ expected ) ) { throw new InvalidArgumentException ( 'Expected expected value to be a string, ' . gettype ( $ expected ) . ' given.' ) ; } if ( ! is_string ( $ actual ) ) { throw new InvalidArgumentException ( 'Expected actual value to be a string, ' . gettype ( $ actual ) . ' given.' ) ; } if ( function_exists ( 'hash_equals' ) ) { return hash_equals ( $ expected , $ actual ) ; } $ expected .= "\0" ; $ actual .= "\0" ; $ expectedLength = StringHelper :: byteLength ( $ expected ) ; $ actualLength = StringHelper :: byteLength ( $ actual ) ; $ diff = $ expectedLength - $ actualLength ; for ( $ i = 0 ; $ i < $ actualLength ; $ i ++ ) { $ diff |= ( ord ( $ actual [ $ i ] ) ^ ord ( $ expected [ $ i % $ expectedLength ] ) ) ; } return $ diff === 0 ; }
12682	private function registerProfilerConfiguration ( array $ config , XmlFileLoader $ loader ) { if ( $ config [ 'enabled' ] && $ config [ 'collect' ] && class_exists ( 'Symfony\Component\Debug\Debug' ) ) { $ loader -> load ( 'block_debug.xml' ) ; $ loader -> load ( 'collectors.xml' ) ; } }
11421	public function constructSelectSQL ( $ fields ) { $ sql = array ( ) ; $ sql [ ] = "SELECT" ; $ sql [ ] = "`" . implode ( "`, `" , array_keys ( $ fields ) ) . "`" ; $ sql [ ] = "FROM `" . $ this -> dbtable . "`" ; $ sql [ ] = "WHERE `" . $ this -> pk . "` = " . $ fields [ $ this -> pk ] -> getSQL ( ) ; return implode ( " " , $ sql ) ; }
10105	private function writeDefaultRowHeight ( ) { $ defaultRowHeight = $ this -> phpSheet -> getDefaultRowDimension ( ) -> getRowHeight ( ) ; if ( $ defaultRowHeight < 0 ) { return ; } $ defaultRowHeight = ( int ) 20 * $ defaultRowHeight ; $ record = 0x0225 ; $ length = 0x0004 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vv' , 1 , $ defaultRowHeight ) ; $ this -> append ( $ header . $ data ) ; }
12756	protected function deleteFieldsForCFGroup ( $ customFieldsGroup ) { $ em = $ this -> getContainer ( ) -> get ( 'doctrine.orm.default_entity_manager' ) ; foreach ( $ customFieldsGroup -> getCustomFields ( ) as $ field ) { $ em -> remove ( $ field ) ; } }
8521	public function setListingQualityRecommendations ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ListingQualityRecommendations' ] [ 'FieldValue' ] = $ value ; return $ this ; }
2858	public function layoutUpdatesAction ( ) { $ token = $ this -> getRequest ( ) -> getParam ( 'token' ) ; if ( ! $ token ) { return $ this -> getResponse ( ) -> setHttpResponseCode ( 400 ) -> setBody ( 'Invalid parameters' ) ; } $ requestProfile = Mage :: getModel ( 'sheep_debug/requestInfo' ) -> load ( $ token , 'token' ) ; if ( ! $ requestProfile -> getId ( ) ) { return $ this -> getResponse ( ) -> setHttpResponseCode ( 404 ) -> setBody ( 'Request profile not found' ) ; } $ layoutUpdates = $ requestProfile -> getDesign ( ) -> getLayoutUpdates ( ) ; $ this -> renderArray ( $ layoutUpdates , 'No Data' , array ( '#' , 'XML' ) ) ; }
7027	public function autoLogin ( EntityInterface $ user ) : ? Response { $ controller = $ this -> getController ( ) ; $ request = $ controller -> request ; $ token = $ request -> getQuery ( 't' ) ; if ( empty ( $ token ) ) { return null ; } $ this -> Auth -> logout ( ) ; $ tokenData = $ user -> validateLoginToken ( $ token , $ user -> getKey ( ) , $ user -> getSalt ( ) ) ; if ( ! is_array ( $ tokenData ) ) { return null ; } if ( ! empty ( $ tokenData [ 'addRememberMeCookie' ] ) && $ tokenData [ 'addRememberMeCookie' ] ) { $ this -> addRememberMeCookie ( ( string ) $ user -> id ) ; } $ userData = $ user -> toArray ( ) ; $ userData [ 'user' ] = $ user ; $ this -> Auth -> setUser ( $ userData ) ; if ( ! empty ( $ tokenData [ 'url' ] ) ) { return $ controller -> redirect ( $ tokenData [ 'url' ] ) ; } return $ controller -> redirect ( $ this -> getConfig ( 'defaultRedirect' ) ) ; }
8229	public static function readFile ( $ fileName , $ options = [ ] ) { $ reader = new File \ FileReader ( $ fileName , $ options ) ; $ success = true ; $ contents = null ; try { $ reader -> open ( ) ; $ contents = $ reader -> read ( ) ; } catch ( \ RuntimeException $ e ) { self :: $ lastError = $ e -> getMessage ( ) ; $ success = false ; } try { $ reader -> close ( ) ; } catch ( \ RuntimeException $ e ) { self :: $ lastError = $ e -> getMessage ( ) ; $ success = false ; } return ( $ success ) ? $ contents : false ; }
577	protected static function normalizeRoute ( $ route ) { $ route = Yii :: getAlias ( ( string ) $ route ) ; if ( strncmp ( $ route , '/' , 1 ) === 0 ) { return ltrim ( $ route , '/' ) ; } if ( Yii :: $ app -> controller === null ) { throw new InvalidArgumentException ( "Unable to resolve the relative route: $route. No active controller is available." ) ; } if ( strpos ( $ route , '/' ) === false ) { return $ route === '' ? Yii :: $ app -> controller -> getRoute ( ) : Yii :: $ app -> controller -> getUniqueId ( ) . '/' . $ route ; } return ltrim ( Yii :: $ app -> controller -> module -> getUniqueId ( ) . '/' . $ route , '/' ) ; }
7507	function getTokenString ( $ start_offset = 0 , $ end_offset = 0 ) { $ token_start = ( ( is_int ( $ this -> token_start ) ) ? $ this -> token_start : $ this -> pos ) + $ start_offset ; $ len = $ this -> pos - $ token_start + 1 + $ end_offset ; return ( ( $ len > 0 ) ? substr ( $ this -> doc , $ token_start , $ len ) : '' ) ; }
7918	public static function labelGroup ( $ labels = [ ] , $ options = [ ] ) { Ui :: addCssClasses ( $ options , [ 'ui' , 'labels' ] ) ; $ lines = [ ] ; foreach ( $ labels as $ label ) { $ content = ArrayHelper :: remove ( $ label , 'content' ) ; $ lines [ ] = static :: label ( $ content , $ label ) ; } return Ui :: tag ( 'div' , implode ( "\n" , $ lines ) , $ options ) ; }
2298	public static function findSearchablePages ( $ pid = 0 , $ domain = '' , $ blnIsSitemap = false ) { $ objPages = PageModel :: findPublishedByPid ( $ pid , array ( 'ignoreFePreview' => true ) ) ; if ( $ objPages === null ) { return array ( ) ; } $ arrPages = array ( ) ; foreach ( $ objPages as $ objPage ) { if ( $ objPage -> type == 'regular' ) { if ( ( ! $ objPage -> noSearch || $ blnIsSitemap ) && ( ! $ objPage -> protected || ( Config :: get ( 'indexProtected' ) && ( ! $ blnIsSitemap || $ objPage -> sitemap == 'map_always' ) ) ) && ( ! $ blnIsSitemap || $ objPage -> sitemap != 'map_never' ) && ! $ objPage -> requireItem ) { $ arrPages [ ] = $ objPage -> getAbsoluteUrl ( ) ; if ( ( $ objArticles = ArticleModel :: findPublishedWithTeaserByPid ( $ objPage -> id , array ( 'ignoreFePreview' => true ) ) ) !== null ) { foreach ( $ objArticles as $ objArticle ) { $ arrPages [ ] = $ objPage -> getAbsoluteUrl ( '/articles/' . ( $ objArticle -> alias ? : $ objArticle -> id ) ) ; } } } } if ( ( ! $ objPage -> protected || Config :: get ( 'indexProtected' ) ) && ( $ arrSubpages = static :: findSearchablePages ( $ objPage -> id , $ domain , $ blnIsSitemap ) ) ) { $ arrPages = array_merge ( $ arrPages , $ arrSubpages ) ; } } return $ arrPages ; }
1401	protected function isNoContent ( $ resource , $ links , $ meta ) { return is_null ( $ resource ) && empty ( $ links ) && empty ( $ meta ) ; }
9959	public function unprotectCellsByColumnAndRow ( $ columnIndex1 , $ row1 , $ columnIndex2 , $ row2 ) { $ cellRange = Coordinate :: stringFromColumnIndex ( $ columnIndex1 ) . $ row1 . ':' . Coordinate :: stringFromColumnIndex ( $ columnIndex2 ) . $ row2 ; return $ this -> unprotectCells ( $ cellRange ) ; }
9996	protected function checkSeparator ( ) { $ line = fgets ( $ this -> fileHandle ) ; if ( $ line === false ) { return ; } if ( ( strlen ( trim ( $ line , "\r\n" ) ) == 5 ) && ( stripos ( $ line , 'sep=' ) === 0 ) ) { $ this -> delimiter = substr ( $ line , 4 , 1 ) ; return ; } return $ this -> skipBOM ( ) ; }
12527	public function getDataSources ( ) { if ( is_null ( $ this -> _dataSources ) ) { $ this -> _dataSources = [ ] ; foreach ( $ this -> dataSources ( ) as $ foreignModel => $ dataSource ) { if ( is_numeric ( $ foreignModel ) || isset ( $ dataSources [ 'foreignModel' ] ) ) { if ( ! isset ( $ dataSources [ 'foreignModel' ] ) ) { continue ; } $ foreignModel = $ dataSources [ 'foreignModel' ] ; unset ( $ dataSources [ 'foreignModel' ] ) ; } if ( ! isset ( $ dataSource [ 'class' ] ) ) { $ dataSource [ 'class' ] = $ this -> dataSourceClass ; } $ dataSource [ 'name' ] = $ foreignModel ; $ dataSource [ 'foreignModel' ] = $ this -> getForeignModel ( $ foreignModel ) ; if ( empty ( $ dataSource [ 'foreignModel' ] ) ) { continue ; } $ this -> _dataSources [ $ foreignModel ] = Yii :: createObject ( array_merge ( [ 'module' => $ this ] , $ dataSource ) ) ; } } return $ this -> _dataSources ; }
12109	public function renamePage ( $ id , $ newName ) { $ this -> pages [ $ newName ] = $ this -> getPage ( $ id ) ; unset ( $ this -> pages [ $ id ] ) ; $ this -> persist ( ) ; }
4088	protected function transformDSLSortToString ( $ dslSort ) { $ string = "" ; if ( is_array ( $ dslSort ) ) { foreach ( $ dslSort as $ sort ) { if ( is_array ( $ sort ) ) { $ field = key ( $ sort ) ; $ info = current ( $ sort ) ; } else $ field = $ sort ; $ string .= "&sort=" . $ field ; if ( isset ( $ info ) ) { if ( is_string ( $ info ) && $ info == "desc" ) $ string .= ":reverse" ; elseif ( is_array ( $ info ) && array_key_exists ( "reverse" , $ info ) && $ info [ 'reverse' ] ) $ string .= ":reverse" ; } } } return $ string ; }
607	private function tokenizeOperator ( & $ length ) { if ( ! $ this -> isOperator ( $ length , $ content ) ) { return false ; } $ this -> addTokenFromBuffer ( ) ; switch ( $ this -> substring ( $ length ) ) { case '(' : $ this -> _currentToken [ ] = new SqlToken ( [ 'type' => SqlToken :: TYPE_OPERATOR , 'content' => is_string ( $ content ) ? $ content : $ this -> substring ( $ length ) , 'startOffset' => $ this -> offset , 'endOffset' => $ this -> offset + $ length , ] ) ; $ this -> _currentToken [ ] = new SqlToken ( [ 'type' => SqlToken :: TYPE_PARENTHESIS ] ) ; $ this -> _tokenStack -> push ( $ this -> _currentToken [ - 1 ] ) ; $ this -> _currentToken = $ this -> _tokenStack -> top ( ) ; break ; case ')' : $ this -> _tokenStack -> pop ( ) ; $ this -> _currentToken = $ this -> _tokenStack -> top ( ) ; $ this -> _currentToken [ ] = new SqlToken ( [ 'type' => SqlToken :: TYPE_OPERATOR , 'content' => ')' , 'startOffset' => $ this -> offset , 'endOffset' => $ this -> offset + $ length , ] ) ; break ; case ';' : if ( ! $ this -> _currentToken -> getHasChildren ( ) ) { break ; } $ this -> _currentToken [ ] = new SqlToken ( [ 'type' => SqlToken :: TYPE_OPERATOR , 'content' => is_string ( $ content ) ? $ content : $ this -> substring ( $ length ) , 'startOffset' => $ this -> offset , 'endOffset' => $ this -> offset + $ length , ] ) ; $ this -> _tokenStack -> pop ( ) ; $ this -> _currentToken = $ this -> _tokenStack -> top ( ) ; $ this -> _currentToken [ ] = new SqlToken ( [ 'type' => SqlToken :: TYPE_STATEMENT ] ) ; $ this -> _tokenStack -> push ( $ this -> _currentToken [ - 1 ] ) ; $ this -> _currentToken = $ this -> _tokenStack -> top ( ) ; break ; default : $ this -> _currentToken [ ] = new SqlToken ( [ 'type' => SqlToken :: TYPE_OPERATOR , 'content' => is_string ( $ content ) ? $ content : $ this -> substring ( $ length ) , 'startOffset' => $ this -> offset , 'endOffset' => $ this -> offset + $ length , ] ) ; break ; } return true ; }
6830	protected function moveAssignment ( Stock \ StockAssignmentInterface $ assignment , Stock \ StockUnitInterface $ targetUnit , $ quantity ) { $ quantity = min ( $ quantity , $ assignment -> getSoldQuantity ( ) - $ assignment -> getShippedQuantity ( ) ) ; if ( 0 >= $ quantity ) { return 0 ; } $ sourceUnit = $ assignment -> getStockUnit ( ) ; $ saleItem = $ assignment -> getSaleItem ( ) ; $ this -> logger -> unitSold ( $ sourceUnit , - $ quantity ) ; $ sourceUnit -> setSoldQuantity ( $ sourceUnit -> getSoldQuantity ( ) - $ quantity ) ; $ this -> manager -> persist ( $ sourceUnit ) ; $ this -> logger -> unitSold ( $ targetUnit , $ quantity ) ; $ targetUnit -> setSoldQuantity ( $ targetUnit -> getSoldQuantity ( ) + $ quantity ) ; $ this -> manager -> persist ( $ targetUnit ) ; $ merge = null ; foreach ( $ targetUnit -> getStockAssignments ( ) as $ m ) { if ( $ m -> getSaleItem ( ) === $ saleItem ) { $ merge = $ m ; break ; } } if ( $ quantity == $ assignment -> getSoldQuantity ( ) ) { if ( null !== $ merge ) { $ this -> logger -> assignmentSold ( $ merge , $ quantity ) ; $ merge -> setSoldQuantity ( $ merge -> getSoldQuantity ( ) + $ quantity ) ; $ this -> manager -> persist ( $ merge ) ; $ this -> logger -> assignmentSold ( $ assignment , 0 , false ) ; $ assignment -> setSoldQuantity ( 0 ) -> setSaleItem ( null ) -> setStockUnit ( null ) ; $ this -> manager -> remove ( $ assignment ) ; } else { $ this -> logger -> assignmentUnit ( $ assignment , $ targetUnit ) ; $ assignment -> setStockUnit ( $ targetUnit ) ; $ this -> manager -> persist ( $ assignment ) ; } } else { $ this -> logger -> assignmentSold ( $ assignment , - $ quantity ) ; $ assignment -> setSoldQuantity ( $ assignment -> getSoldQuantity ( ) - $ quantity ) ; $ this -> manager -> persist ( $ assignment ) ; if ( null !== $ merge ) { $ this -> logger -> assignmentSold ( $ merge , $ quantity ) ; $ merge -> setSoldQuantity ( $ merge -> getSoldQuantity ( ) + $ quantity ) ; $ this -> manager -> persist ( $ merge ) ; } else { $ create = $ this -> saleFactory -> createStockAssignmentForItem ( $ saleItem ) ; $ this -> logger -> assignmentSold ( $ create , $ quantity , false ) ; $ create -> setSoldQuantity ( $ quantity ) -> setSaleItem ( $ saleItem ) -> setStockUnit ( $ targetUnit ) ; $ this -> manager -> persist ( $ create ) ; } } return $ quantity ; }
3402	protected function applyResultCallbackChain ( Crawler $ node , ApistMethod $ method ) { if ( empty ( $ this -> resultMethodChain ) ) { $ this -> addCallback ( 'text' ) ; } $ traceStack = [ ] ; foreach ( $ this -> resultMethodChain as $ resultCallback ) { try { $ traceStack [ ] = $ resultCallback ; $ node = $ resultCallback -> apply ( $ node , $ method ) ; } catch ( InvalidArgumentException $ e ) { if ( $ method -> getResource ( ) -> isSuppressExceptions ( ) ) { return null ; } $ message = $ this -> createExceptionMessage ( $ e , $ traceStack ) ; throw new InvalidArgumentException ( $ message , 0 , $ e ) ; } } return $ node ; }
2131	public function save ( ) { if ( $ this -> strTop == '' ) { $ this -> strTop = '<?php' ; } $ strFile = trim ( $ this -> strTop ) . "\n\n" ; $ strFile .= "### INSTALL SCRIPT START ###\n" ; foreach ( $ this -> arrData as $ k => $ v ) { $ strFile .= "$k = $v\n" ; } $ strFile .= "### INSTALL SCRIPT STOP ###\n" ; $ this -> strBottom = trim ( $ this -> strBottom ) ; if ( $ this -> strBottom != '' ) { $ strFile .= "\n" . $ this -> strBottom . "\n" ; } $ strTemp = md5 ( uniqid ( mt_rand ( ) , true ) ) ; $ objFile = fopen ( $ this -> strRootDir . '/system/tmp/' . $ strTemp , 'wb' ) ; fwrite ( $ objFile , $ strFile ) ; fclose ( $ objFile ) ; if ( ! filesize ( $ this -> strRootDir . '/system/tmp/' . $ strTemp ) ) { System :: log ( 'The local configuration file could not be written. Have your reached your quota limit?' , __METHOD__ , TL_ERROR ) ; return ; } $ this -> Files -> chmod ( 'system/tmp/' . $ strTemp , 0666 & ~ umask ( ) ) ; $ this -> Files -> rename ( 'system/tmp/' . $ strTemp , 'system/config/localconfig.php' ) ; if ( \ function_exists ( 'opcache_invalidate' ) ) { opcache_invalidate ( $ this -> strRootDir . '/system/config/localconfig.php' , true ) ; } if ( \ function_exists ( 'apc_compile_file' ) && ! ini_get ( 'apc.stat' ) ) { apc_compile_file ( $ this -> strRootDir . '/system/config/localconfig.php' ) ; } $ this -> blnIsModified = false ; }
12439	public function render ( $ template , $ data ) { $ tplReady = '' ; $ this -> template = $ template ; $ this -> data = $ data ; if ( $ this -> loadTemplate ( ) ) { $ tplReady = $ this -> dataRender ; } if ( Settings :: getInstance ( ) -> get ( 'minifyTemplate' ) && ! Settings :: getInstance ( ) -> inDebug ( ) ) { $ tplReady = $ this -> minify ( $ tplReady ) ; } $ this -> release ( ) ; return $ tplReady ; }
9901	public function parse ( $ formula ) { $ this -> currentCharacter = 0 ; $ this -> formula = $ formula ; $ this -> lookAhead = isset ( $ formula [ 1 ] ) ? $ formula [ 1 ] : '' ; $ this -> advance ( ) ; $ this -> parseTree = $ this -> condition ( ) ; return true ; }
11547	public function addGroup ( Group $ group ) { $ group -> setService ( $ this ) ; $ this -> groups [ $ group -> getName ( ) ] = $ group ; }
2690	public function getResizedImageInfo ( ) { if ( $ this -> isFastlyImageOptimizationEnabled ( ) == false ) { return parent :: getResizedImageInfo ( ) ; } if ( $ this -> getBaseFile ( ) !== null ) { return [ 0 => $ this -> getWidth ( ) , 1 => $ this -> getHeight ( ) ] ; } $ asset = $ this -> _assetRepo -> createAsset ( "Magento_Catalog::images/product/placeholder/{$this->getDestinationSubdir()}.jpg" ) ; $ img = $ asset -> getSourceFile ( ) ; $ imageInfo = getimagesize ( $ img ) ; $ this -> setWidth ( $ imageInfo [ 0 ] ) ; $ this -> setHeight ( $ imageInfo [ 1 ] ) ; return $ imageInfo ; }
2763	public function isCloned ( ) : bool { if ( $ this -> cloned === null ) { $ gitDir = $ this -> directory ; if ( is_dir ( $ gitDir . '/.git' ) ) { $ gitDir .= '/.git' ; } $ this -> cloned = is_dir ( $ gitDir . '/objects' ) && is_dir ( $ gitDir . '/refs' ) && is_file ( $ gitDir . '/HEAD' ) ; } return $ this -> cloned ; }
2166	public static function convertOrderField ( $ table , $ field ) { $ objDatabase = Database :: getInstance ( ) ; $ objRow = $ objDatabase -> query ( "SELECT id, $field FROM $table WHERE $field LIKE '%,%'" ) ; while ( $ objRow -> next ( ) ) { $ objDatabase -> prepare ( "UPDATE $table SET $field=? WHERE id=?" ) -> execute ( serialize ( explode ( ',' , $ objRow -> $ field ) ) , $ objRow -> id ) ; } static :: convertMultiField ( $ table , $ field ) ; }
10138	private function writePageLayoutView ( ) { $ record = 0x088B ; $ length = 0x0010 ; $ rt = 0x088B ; $ grbitFrt = 0x0000 ; $ reserved = 0x0000000000000000 ; $ wScalvePLV = $ this -> phpSheet -> getSheetView ( ) -> getZoomScale ( ) ; if ( $ this -> phpSheet -> getSheetView ( ) -> getView ( ) == SheetView :: SHEETVIEW_PAGE_LAYOUT ) { $ fPageLayoutView = 1 ; } else { $ fPageLayoutView = 0 ; } $ fRulerVisible = 0 ; $ fWhitespaceHidden = 0 ; $ grbit = $ fPageLayoutView ; $ grbit |= $ fRulerVisible << 1 ; $ grbit |= $ fWhitespaceHidden << 3 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vvVVvv' , $ rt , $ grbitFrt , 0x00000000 , 0x00000000 , $ wScalvePLV , $ grbit ) ; $ this -> append ( $ header . $ data ) ; }
5996	public function setSavedSearch ( $ savedSearch ) { if ( $ savedSearch instanceof SavedSearch ) { $ this -> savedSearch = $ savedSearch ; } elseif ( is_array ( $ savedSearch ) ) { $ this -> savedSearch = new SavedSearch ( $ savedSearch ) ; } else { $ this -> savedSearch = null ; trigger_error ( 'Argument must be an object of class SavedSearch. Data loss!' , E_USER_WARNING ) ; } return $ this ; }
12882	public function getUnmappedKeys ( ) { $ u = [ ] ; $ f = $ this -> unmappedForeignKeys ; $ l = $ this -> unmappedLocalKeys ; if ( ! empty ( $ f ) ) { $ u [ 'foreign' ] = $ f ; } if ( ! empty ( $ l ) ) { $ u [ 'local' ] = $ l ; } return $ u ; }
4132	public function clear ( $ objectName = null ) { if ( $ objectName === null ) { $ this -> unitOfWork = new UnitOfWork ( $ this ) ; } else { throw new CouchDBException ( "DocumentManager#clear(\$objectName) not yet implemented." ) ; } }
10991	public function getName ( bool $ includeExtension = false ) : string { $ filename = basename ( $ this -> path ) ; if ( $ includeExtension ) { return $ filename ; } return $ this -> splitName ( ) [ 0 ] ; }
2381	public static function stripRootDir ( $ path ) { $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; $ length = \ strlen ( $ rootDir ) ; if ( strncmp ( $ path , $ rootDir , $ length ) !== 0 || \ strlen ( $ path ) <= $ length || ( $ path [ $ length ] !== '/' && $ path [ $ length ] !== '\\' ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Path "%s" is not inside the Contao root dir "%s"' , $ path , $ rootDir ) ) ; } return ( string ) substr ( $ path , $ length + 1 ) ; }
3647	protected function process ( string $ value , bool $ trim = true , bool $ clean = true ) { if ( $ trim ) { $ value = trim ( $ value ) ; } if ( $ clean ) { $ value = $ this -> security -> clean ( $ value ) ; } return $ value ; }
3835	protected function prepareTemplate ( Template $ objTemplate , $ arrRowData , $ objSettings ) { $ objTemplate -> setData ( array ( 'attribute' => $ this , 'settings' => $ objSettings , 'row' => $ arrRowData , 'raw' => $ arrRowData [ $ this -> getColName ( ) ] , 'additional_class' => $ objSettings -> get ( 'additional_class' ) ? ' ' . $ objSettings -> get ( 'additional_class' ) : '' ) ) ; }
1267	private function createRequest ( $ labelRecoveryRequest ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; $ trackRequest = $ xml -> appendChild ( $ xml -> createElement ( 'LabelRecoveryRequest' ) ) ; $ trackRequest -> setAttribute ( 'xml:lang' , 'en-US' ) ; $ request = $ trackRequest -> appendChild ( $ xml -> createElement ( 'Request' ) ) ; $ node = $ xml -> importNode ( $ this -> createTransactionNode ( ) , true ) ; $ request -> appendChild ( $ node ) ; $ request -> appendChild ( $ xml -> createElement ( 'RequestAction' , 'LabelRecovery' ) ) ; $ labelSpecificationNode = $ trackRequest -> appendChild ( $ xml -> createElement ( 'LabelSpecification' ) ) ; if ( isset ( $ labelRecoveryRequest -> LabelSpecification ) ) { $ labelSpecificationNode -> appendChild ( $ xml -> createElement ( 'HTTPUserAgent' , $ labelRecoveryRequest -> LabelSpecification -> HTTPUserAgent ) ) ; $ labelImageFormatNode = $ labelSpecificationNode -> appendChild ( $ xml -> createElement ( 'LabelImageFormat' ) ) ; $ labelImageFormatNode -> appendChild ( $ xml -> createElement ( 'Code' , $ labelRecoveryRequest -> LabelSpecification -> LabelImageFormat -> Code ) ) ; } if ( isset ( $ labelRecoveryRequest -> Translate ) ) { $ translateNode = $ trackRequest -> appendChild ( $ xml -> createElement ( 'Translate' ) ) ; $ translateNode -> appendChild ( $ xml -> createElement ( 'LanguageCode' , $ labelRecoveryRequest -> Translate -> LanguageCode ) ) ; $ translateNode -> appendChild ( $ xml -> createElement ( 'DialectCode' , $ labelRecoveryRequest -> Translate -> DialectCode ) ) ; $ translateNode -> appendChild ( $ xml -> createElement ( 'Code' , $ labelRecoveryRequest -> Translate -> Code ) ) ; } if ( isset ( $ labelRecoveryRequest -> LabelLinkIndicator ) ) { $ labelLinkIndicatorNode = $ trackRequest -> appendChild ( $ xml -> createElement ( 'LabelLinkIndicator' ) ) ; $ labelLinkIndicatorNode -> appendChild ( $ xml -> createElement ( 'LabelLinkIndicator' ) ) ; } if ( isset ( $ labelRecoveryRequest -> TrackingNumber ) ) { $ trackRequest -> appendChild ( $ xml -> createElement ( 'TrackingNumber' , $ labelRecoveryRequest -> TrackingNumber ) ) ; } if ( isset ( $ labelRecoveryRequest -> ReferenceNumber ) ) { $ referenceNumberNode = $ trackRequest -> appendChild ( $ xml -> createElement ( 'ReferenceNumber' ) ) ; $ referenceNumberNode -> appendChild ( $ xml -> createElement ( 'Value' , $ labelRecoveryRequest -> ReferenceNumber -> getValue ( ) ) ) ; } if ( isset ( $ labelRecoveryRequest -> ShipperNumber ) ) { $ trackRequest -> appendChild ( $ xml -> createElement ( 'ShipperNumber' , $ labelRecoveryRequest -> ShipperNumber ) ) ; } return $ xml -> saveXML ( ) ; }
6011	public function setReplies ( array $ replies ) { $ this -> replies = [ ] ; foreach ( $ replies as $ item ) { $ this -> addCommentResponse ( $ item ) ; } return $ this ; }
10574	public function remove ( $ key ) { $ this -> open ( ) ; if ( isset ( $ _SESSION [ $ key ] ) ) { $ value = $ _SESSION [ $ key ] ; unset ( $ _SESSION [ $ key ] ) ; return $ value ; } else { return null ; } }
3885	private function collectRulesFor ( $ parentSetting , $ filterSettings ) { $ childInformation = $ this -> database -> createQueryBuilder ( ) -> select ( '*' ) -> from ( 'tl_metamodel_filtersetting' ) -> where ( 'pid=:pid' ) -> andWhere ( 'enabled=1' ) -> orderBy ( 'sorting' , 'ASC' ) -> setParameter ( 'pid' , $ parentSetting -> get ( 'id' ) ) -> execute ( ) ; foreach ( $ childInformation -> fetchAll ( \ PDO :: FETCH_ASSOC ) as $ item ) { $ childSetting = $ this -> createSetting ( $ item , $ filterSettings ) ; if ( $ childSetting ) { $ parentSetting -> addChild ( $ childSetting ) ; } } }
6004	public function setCategories ( array $ categories ) { $ this -> categories = [ ] ; foreach ( $ categories as $ item ) { $ this -> addCategoryResponse ( $ item ) ; } return $ this ; }
4045	public function decodeValue ( DecodePropertyValueForWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) || ( $ event -> getProperty ( ) !== 'jumpTo' ) ) { return ; } $ propInfo = $ event -> getEnvironment ( ) -> getDataDefinition ( ) -> getPropertiesDefinition ( ) -> getProperty ( 'jumpTo' ) ; $ value = StringUtil :: deserialize ( $ event -> getValue ( ) , true ) ; $ extra = $ propInfo -> getExtra ( ) ; $ newValues = [ ] ; $ languages = $ extra [ 'columnFields' ] [ 'langcode' ] [ 'options' ] ; foreach ( array_keys ( $ languages ) as $ key ) { $ newValue = '' ; $ filter = 0 ; if ( $ value ) { foreach ( $ value as $ arr ) { if ( ! is_array ( $ arr ) ) { break ; } if ( array_search ( $ key , $ arr ) !== false ) { $ newValue = '{{link_url::' . $ arr [ 'value' ] . '}}' ; $ filter = $ arr [ 'filter' ] ; break ; } } } $ newValues [ ] = [ 'langcode' => $ key , 'value' => $ newValue , 'filter' => $ filter ] ; } $ event -> setValue ( $ newValues ) ; }
10155	private function readMulRk ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; $ row = self :: getUInt2d ( $ recordData , 0 ) ; $ colFirst = self :: getUInt2d ( $ recordData , 2 ) ; $ colLast = self :: getUInt2d ( $ recordData , $ length - 2 ) ; $ columns = $ colLast - $ colFirst + 1 ; $ offset = 4 ; for ( $ i = 1 ; $ i <= $ columns ; ++ $ i ) { $ columnString = Coordinate :: stringFromColumnIndex ( $ colFirst + $ i ) ; if ( ( $ this -> getReadFilter ( ) !== null ) && $ this -> getReadFilter ( ) -> readCell ( $ columnString , $ row + 1 , $ this -> phpSheet -> getTitle ( ) ) ) { $ xfIndex = self :: getUInt2d ( $ recordData , $ offset ) ; $ numValue = self :: getIEEE754 ( self :: getInt4d ( $ recordData , $ offset + 2 ) ) ; $ cell = $ this -> phpSheet -> getCell ( $ columnString . ( $ row + 1 ) ) ; if ( ! $ this -> readDataOnly ) { $ cell -> setXfIndex ( $ this -> mapCellXfIndex [ $ xfIndex ] ) ; } $ cell -> setValueExplicit ( $ numValue , DataType :: TYPE_NUMERIC ) ; } $ offset += 6 ; } }
12126	public function validate ( string $ sValue = null ) : bool { if ( $ this -> _sType == 'DateTime' ) { if ( preg_match ( '#^[0-9]{4}/[0-9]{2}/[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}#' , $ sValue ) ) { return true ; } } return false ; }
646	public function checkIntegrity ( $ check = true , $ schema = '' , $ table = '' ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> checkIntegrity ( $ check , $ schema , $ table ) ; return $ this -> setSql ( $ sql ) ; }
8883	public function getQuote ( $ credentials , $ options ) { $ this -> loadCredentials ( $ credentials ) ; $ options = $ this -> checkDefaults ( $ options ) ; $ residential_flag = ( $ this -> commercial_rates ) ? '' : '<ResidentialAddressIndicator/>' ; $ negotiated_flag = ( $ this -> negotiated_rates ) ? '<RateInformation><NegotiatedRatesIndicator/></RateInformation>' : '' ; $ this -> xml = '<?xml version="1.0"?> <AccessRequest xml:lang="en-US"> <AccessLicenseNumber>' . $ this -> access_key . '</AccessLicenseNumber> <UserId>' . $ this -> username . '</UserId> <Password>' . $ this -> password . '</Password> </AccessRequest> <?xml version="1.0"?> <RatingServiceSelectionRequest xml:lang="en-US"> <Request> <TransactionReference> <CustomerContext>Rate Request</CustomerContext> <XpciVersion>1.0001</XpciVersion> </TransactionReference> <RequestAction>Rate</RequestAction> <RequestOption>' . $ options [ 'request_option' ] . '</RequestOption> </Request> <PickupType> <Code>01</Code> </PickupType> <Shipment> <Shipper> <ShipperNumber>' . $ this -> account_number . '</ShipperNumber> <Address> <PostalCode>' . $ options [ 'from_zip' ] . '</PostalCode> <StateProvinceCode>' . $ options [ 'from_state' ] . '</StateProvinceCode> <CountryCode>' . $ options [ 'from_country' ] . '</CountryCode> </Address> </Shipper> <ShipTo> <Address> <PostalCode>' . $ options [ 'to_zip' ] . '</PostalCode> <StateProvinceCode>' . $ options [ 'to_state' ] . '</StateProvinceCode> <CountryCode>' . $ options [ 'to_country' ] . '</CountryCode> ' . $ residential_flag . ' </Address> </ShipTo> <Service> <Code>' . $ options [ 'service_type' ] . '</Code> <Description>Package</Description> </Service> <ShipmentServiceOptions/> ' . $ this -> buildPackages ( $ options [ 'packages' ] , $ options [ 'weight' ] , $ options [ 'measurement' ] ) . $ negotiated_flag . ' </Shipment> </RatingServiceSelectionRequest>' ; return $ this -> send ( ) ; }
3104	public function save ( ) { $ storage = $ this -> getStorage ( ) ; if ( $ storage ) { $ success = $ storage -> set ( $ this -> userId , $ this -> getStorageKey ( ) , json_encode ( $ this -> state ) ) ; } else { $ success = false ; } return $ success ; }
8687	public static function replaceRecursive ( $ iterable1 , $ iterable2 ) { Assert :: allIsIterable ( [ $ iterable1 , $ iterable2 ] ) ; if ( $ iterable1 instanceof Traversable ) { $ iterable1 = iterator_to_array ( $ iterable1 ) ; } if ( $ iterable2 instanceof Traversable ) { $ iterable2 = iterator_to_array ( $ iterable2 ) ; } $ merged = $ iterable1 ; foreach ( $ iterable2 as $ key => $ value ) { if ( $ value instanceof Traversable ) { $ value = iterator_to_array ( $ value ) ; } if ( is_array ( $ value ) && static :: isAssociative ( $ value ) && isset ( $ merged [ $ key ] ) && \ is_iterable ( $ merged [ $ key ] ) ) { $ merged [ $ key ] = static :: replaceRecursive ( $ merged [ $ key ] , $ value ) ; } elseif ( $ value === null && isset ( $ merged [ $ key ] ) && \ is_iterable ( $ merged [ $ key ] ) ) { if ( $ merged [ $ key ] instanceof Traversable ) { $ merged [ $ key ] = iterator_to_array ( $ merged [ $ key ] ) ; } continue ; } else { $ merged [ $ key ] = $ value ; } } return $ merged ; }
12382	public static function lastMonth ( ) { $ hits_count = self :: interval ( Carbon :: now ( ) -> subMonth ( ) -> firstOfMonth ( ) , Carbon :: now ( ) -> subMonth ( ) -> lastOfMonth ( ) ) ; return $ hits_count ; }
3773	private function buildMetaPaletteConditions ( $ palette , $ metaPalettes ) { foreach ( $ metaPalettes as $ typeName => $ paletteInfo ) { if ( 'default' === $ typeName ) { continue ; } if ( preg_match ( '#^(\w+) extends (\w+)$#' , $ typeName , $ matches ) ) { $ typeName = $ matches [ 1 ] ; } foreach ( $ paletteInfo as $ legendName => $ properties ) { foreach ( $ properties as $ propertyName ) { $ condition = new AttributeByIdIsOfType ( $ typeName , $ this -> connection , 'attr_id' ) ; $ legend = $ this -> getLegend ( $ legendName , $ palette ) ; $ property = $ this -> getProperty ( $ propertyName , $ legend ) ; $ this -> addCondition ( $ property , $ condition ) ; } } } }
1601	public function injectRobots ( ) { $ headers = \ Craft :: $ app -> getResponse ( ) -> getHeaders ( ) ; if ( \ Craft :: $ app -> config -> general -> devMode ) { $ headers -> set ( 'x-robots-tag' , 'none, noimageindex' ) ; return ; } list ( $ field , $ element ) = $ this -> _getElementAndSeoFields ( ) ; $ robots = $ field -> robots ; if ( $ robots !== null ) $ headers -> set ( 'x-robots-tag' , $ robots ) ; if ( isset ( $ element -> expiryDate ) ) $ expiry = $ element -> expiryDate -> format ( \ DATE_RFC850 ) ; else $ expiry = null ; if ( $ expiry ) $ headers -> add ( 'x-robots-tag' , 'unavailable_after: ' . $ expiry ) ; }
5109	public function orderBy ( $ column , $ type = OrderBy :: ASC ) : IWithLimit { if ( $ type == OrderBy :: DESC ) { $ this -> appendDesc ( $ column ) ; } else if ( ! is_array ( $ column ) ) { $ column = [ $ column ] ; } return $ this -> _orderBy ( $ column ) ; }
7533	function setInnerText ( $ text , $ parser = null ) { $ this -> clear ( ) ; if ( trim ( $ text ) ) { if ( $ parser === null ) { $ parser = new $ this -> parserClass ( ) ; } $ parser -> root = & $ this ; $ parser -> setDoc ( $ text ) ; $ parser -> parse_all ( ) ; } return ( ( $ parser && $ parser -> errors ) ? $ parser -> errors : true ) ; }
10367	public function register ( RegisterRequest $ request ) { $ this -> bus -> pipeThrough ( $ this -> pipesOf ( 'register' ) ) -> dispatchFrom ( RegisterJob :: class , $ request ) ; return redirect ( ) -> route ( config ( '_auth.register.redirect' ) ) -> withSuccess ( trans ( 'auth::register.success' ) ) ; }
192	public function send ( ) { if ( $ this -> isSent ) { return ; } $ this -> trigger ( self :: EVENT_BEFORE_SEND ) ; $ this -> prepare ( ) ; $ this -> trigger ( self :: EVENT_AFTER_PREPARE ) ; $ this -> sendHeaders ( ) ; $ this -> sendContent ( ) ; $ this -> trigger ( self :: EVENT_AFTER_SEND ) ; $ this -> isSent = true ; }
3222	function createShareableLink ( $ path ) { Path :: checkArg ( "path" , $ path ) ; $ response = $ this -> doPost ( $ this -> apiHost , $ this -> appendFilePath ( "1/shares" , $ path ) , array ( "short_url" => "false" , ) ) ; if ( $ response -> statusCode === 404 ) return null ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; $ j = RequestUtil :: parseResponseJson ( $ response -> body ) ; return self :: getField ( $ j , "url" ) ; }
6388	public function readSite ( ) { $ model = $ this -> readCourse ( 1 ) ; $ model -> url = $ this -> cfg -> wwwroot ; $ model -> type = "site" ; return $ model ; }
7927	public function registerNamespace ( $ ns , $ def ) { list ( $ ns , $ def ) = $ this -> fireEvent ( 'namespace.register' , [ $ ns , $ def ] ) ; $ this -> namespaces [ $ ns ] = $ def ; return $ this ; }
11228	protected function getUrl ( $ section , array $ uriParams = [ ] ) { $ endpoint = rtrim ( $ this -> getEndpoint ( ) , '/' ) ; $ section = ltrim ( $ section , '/' ) ; $ params = http_build_query ( $ uriParams ) ; if ( $ params ) { return sprintf ( "%s/%s?%s" , $ endpoint , $ section , $ params ) ; } else { return sprintf ( "%s/%s" , $ endpoint , $ section ) ; } }
11515	public function getNamedParam ( string $ category , string $ key ) { $ params = $ this -> getNamedParams ( $ category ) ; return $ params [ $ key ] ?? '' ; }
7246	private function hasStockableSubject ( Common \ SaleItemInterface $ saleItem ) { if ( ! $ saleItem instanceof Stock \ StockAssignmentsInterface ) { return false ; } if ( null === $ subject = $ this -> subjectHelper -> resolve ( $ saleItem ) ) { return false ; } if ( ! $ subject instanceof Stock \ StockSubjectInterface ) { return false ; } if ( $ subject -> isStockCompound ( ) ) { return false ; } if ( $ subject -> getStockMode ( ) === Stock \ StockSubjectModes :: MODE_DISABLED ) { return false ; } return true ; }
12533	public function bindLocation ( array $ deviceIdentifier , $ poiId , $ type = 1 , $ poiAppid = null ) { $ params = [ 'device_identifier' => $ deviceIdentifier , 'poi_id' => intval ( $ poiId ) , ] ; if ( $ type === 2 ) { if ( is_null ( $ poiAppid ) ) { throw new InvalidArgumentException ( 'If value of argument #3 is 2, argument #4 is required.' ) ; } $ params [ 'type' ] = 2 ; $ params [ 'poi_appid' ] = $ poiAppid ; } return $ this -> parseJSON ( 'json' , [ self :: API_DEVICE_BINDLOCATION , $ params ] ) ; }
11728	private function _fetch ( $ attrName , $ default = NULL ) { return $ this -> hasAttribute ( $ attrName ) ? $ this -> getAttribute ( $ attrName ) -> getValue ( ) : $ default ; }
1076	private static function isMissingVariable ( $ valueNode , $ variables ) { return $ valueNode instanceof VariableNode && ( count ( $ variables ) === 0 || ! array_key_exists ( $ valueNode -> name -> value , $ variables ) ) ; }
2866	public function getTotalLineCount ( ) { if ( $ this -> logLineCount === null ) { $ this -> logLineCount = 0 ; foreach ( $ this -> getFiles ( ) as $ log ) { $ this -> logLineCount += $ this -> getLineCount ( $ log ) ; } } return $ this -> logLineCount ; }
4154	protected function getBearerTokenCredentials ( ) { $ signingKey = rawurlencode ( $ this -> getConsumerKey ( ) ) . ':' . rawurlencode ( $ this -> getConsumerSecret ( ) ) ; return base64_encode ( $ signingKey ) ; }
5642	public function paintCaseEnd ( $ test_name ) { $ this -> progress ++ ; array_pop ( $ this -> test_stack ) ; if ( count ( $ this -> test_stack ) == 0 ) { $ this -> paintFooter ( $ test_name ) ; } }
9087	public function attach ( ResolverInterface $ detector , $ priority = 1 ) { $ this -> queue -> insert ( $ detector , $ priority ) ; return $ this ; }
4510	public function created ( JWTCreatedEvent $ event ) { $ data = $ event -> getData ( ) ; $ user = $ event -> getUser ( ) ; $ this -> accessor -> setValue ( $ data , $ this -> property , $ user -> getUuid ( ) ) ; $ event -> setData ( $ data ) ; }
12401	public function get ( $ multiple = true ) { $ scope = $ this -> scope ; return Parser :: get ( $ scope , $ this -> connection , $ multiple ) ; }
4995	public function getActiveFormNext ( ) { $ key = null ; $ actualKey = $ this -> getActiveFormActual ( ) ; if ( isset ( $ actualKey ) ) { $ forms = array_keys ( $ this -> forms ) ; $ formsFlip = array_flip ( $ forms ) ; $ index = $ formsFlip [ $ actualKey ] ; if ( $ index < count ( $ forms ) - 1 ) { $ key = $ forms [ $ index + 1 ] ; } } return $ key ; }
7130	public function getNotifications ( $ type = null ) { if ( null !== $ type ) { NotificationTypes :: isValidType ( $ type ) ; return $ this -> notifications -> filter ( function ( NotificationInterface $ n ) use ( $ type ) { return $ n -> getType ( ) === $ type ; } ) ; } return $ this -> notifications ; }
264	protected function escapeColumnName ( $ columnName , & $ params = [ ] ) { if ( $ columnName instanceof Query ) { list ( $ sql , $ params ) = $ this -> queryBuilder -> build ( $ columnName , $ params ) ; return "($sql)" ; } elseif ( $ columnName instanceof ExpressionInterface ) { return $ this -> queryBuilder -> buildExpression ( $ columnName , $ params ) ; } elseif ( strpos ( $ columnName , '(' ) === false ) { return $ this -> queryBuilder -> db -> quoteColumnName ( $ columnName ) ; } return $ columnName ; }
5856	public function initializeRulesets ( array $ configuration ) { $ general = $ configuration ; $ general [ 'usergroup' ] = '' ; unset ( $ general [ 'rulesets' ] ) ; $ general = $ this -> expandValuesInRuleset ( $ general ) ; if ( $ general [ 'conversion_mapping' ] === '' ) { $ general [ 'conversion_mapping' ] = [ ] ; } if ( isset ( $ configuration [ 'rulesets' ] ) ) { $ rulesets = $ this -> compileRuleSets ( $ configuration [ 'rulesets' ] ) ; } else { $ rulesets = [ ] ; } foreach ( $ rulesets as $ k => & $ ruleset ) { foreach ( $ general as $ key => $ value ) { if ( ! isset ( $ ruleset [ $ key ] ) ) { $ ruleset [ $ key ] = $ value ; } elseif ( $ ruleset [ $ key ] === '' ) { $ ruleset [ $ key ] = $ value ; } } if ( count ( $ ruleset [ 'usergroup' ] ) == 0 ) { $ ruleset [ 'directories' ] = array_diff ( $ ruleset [ 'directories' ] , $ general [ 'directories' ] ) ; if ( count ( $ ruleset [ 'directories' ] ) == 0 ) { unset ( $ rulesets [ $ k ] ) ; } } } $ rulesets [ ] = $ general ; $ this -> rulesets = $ rulesets ; }
1262	protected function compileEndpointUrl ( $ segment ) { $ base = ( $ this -> useIntegration ? $ this -> integrationBaseUrl : $ this -> productionBaseUrl ) ; return $ base . $ segment ; }
585	protected function loadBundles ( $ bundles ) { $ this -> stdout ( "Collecting source bundles information...\n" ) ; $ am = $ this -> getAssetManager ( ) ; $ result = [ ] ; foreach ( $ bundles as $ name ) { $ result [ $ name ] = $ am -> getBundle ( $ name ) ; } foreach ( $ result as $ bundle ) { $ this -> loadDependency ( $ bundle , $ result ) ; } return $ result ; }
340	public function field ( $ model , $ attribute , $ options = [ ] ) { $ config = $ this -> fieldConfig ; if ( $ config instanceof \ Closure ) { $ config = call_user_func ( $ config , $ model , $ attribute ) ; } if ( ! isset ( $ config [ 'class' ] ) ) { $ config [ 'class' ] = $ this -> fieldClass ; } return Yii :: createObject ( ArrayHelper :: merge ( $ config , $ options , [ 'model' => $ model , 'attribute' => $ attribute , 'form' => $ this , ] ) ) ; }
12535	public function fetchByApplyId ( $ applyId , $ lastSeen , $ count ) { $ params = [ 'type' => 3 , 'apply_id' => intval ( $ applyId ) , 'last_seen' => intval ( $ lastSeen ) , 'count' => intval ( $ count ) , ] ; return $ this -> fetch ( $ params ) ; }
729	protected function addDefaultPrimaryKey ( & $ fields ) { foreach ( $ fields as $ field ) { if ( false !== strripos ( $ field [ 'decorators' ] , 'primarykey()' ) ) { return ; } } array_unshift ( $ fields , [ 'property' => 'id' , 'decorators' => 'primaryKey()' ] ) ; }
10276	public static function getTextWidthPixelsApprox ( $ columnText , \ PhpOffice \ PhpSpreadsheet \ Style \ Font $ font , $ rotation = 0 ) { $ fontName = $ font -> getName ( ) ; $ fontSize = $ font -> getSize ( ) ; switch ( $ fontName ) { case 'Calibri' : $ columnWidth = ( int ) ( 8.26 * StringHelper :: countCharacters ( $ columnText ) ) ; $ columnWidth = $ columnWidth * $ fontSize / 11 ; break ; case 'Arial' : $ columnWidth = ( int ) ( 8 * StringHelper :: countCharacters ( $ columnText ) ) ; $ columnWidth = $ columnWidth * $ fontSize / 10 ; break ; case 'Verdana' : $ columnWidth = ( int ) ( 8 * StringHelper :: countCharacters ( $ columnText ) ) ; $ columnWidth = $ columnWidth * $ fontSize / 10 ; break ; default : $ columnWidth = ( int ) ( 8.26 * StringHelper :: countCharacters ( $ columnText ) ) ; $ columnWidth = $ columnWidth * $ fontSize / 11 ; break ; } if ( $ rotation !== 0 ) { if ( $ rotation == - 165 ) { $ columnWidth = 4 ; } else { $ columnWidth = $ columnWidth * cos ( deg2rad ( $ rotation ) ) + $ fontSize * abs ( sin ( deg2rad ( $ rotation ) ) ) / 5 ; } } return ( int ) $ columnWidth ; }
2231	protected function hasUser ( ) : bool { $ user = $ this -> tokenStorage -> getToken ( ) ; if ( null === $ user ) { return false ; } return ! ( $ user instanceof AnonymousToken ) ; }
1277	private function createRequest ( ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; $ trackRequest = $ xml -> appendChild ( $ xml -> createElement ( 'TrackRequest' ) ) ; $ trackRequest -> setAttribute ( 'xml:lang' , 'en-US' ) ; $ request = $ trackRequest -> appendChild ( $ xml -> createElement ( 'Request' ) ) ; $ node = $ xml -> importNode ( $ this -> createTransactionNode ( ) , true ) ; $ request -> appendChild ( $ node ) ; $ request -> appendChild ( $ xml -> createElement ( 'RequestAction' , 'Track' ) ) ; if ( null !== $ this -> requestOption ) { $ request -> appendChild ( $ xml -> createElement ( 'RequestOption' , $ this -> requestOption ) ) ; } if ( null !== $ this -> trackingNumber ) { $ trackRequest -> appendChild ( $ xml -> createElement ( 'TrackingNumber' , $ this -> trackingNumber ) ) ; } if ( $ this -> isMailInnovations ( ) ) { $ trackRequest -> appendChild ( $ xml -> createElement ( 'IncludeMailInnovationIndicator' ) ) ; } if ( null !== $ this -> referenceNumber ) { $ trackRequest -> appendChild ( $ xml -> createElement ( 'ReferenceNumber' ) ) -> appendChild ( $ xml -> createElement ( 'Value' , $ this -> referenceNumber ) ) ; } if ( null !== $ this -> shipperNumber ) { $ trackRequest -> appendChild ( $ xml -> createElement ( 'ShipperNumber' , $ this -> shipperNumber ) ) ; } if ( null !== $ this -> beginDate || null !== $ this -> endDate ) { $ DateRange = $ xml -> createElement ( 'PickupDateRange' ) ; if ( null !== $ this -> beginDate ) { $ beginDate = $ this -> beginDate -> format ( 'Ymd' ) ; $ DateRange -> appendChild ( $ xml -> createElement ( 'BeginDate' , $ beginDate ) ) ; } if ( null !== $ this -> endDate ) { $ endDate = $ this -> endDate -> format ( 'Ymd' ) ; $ DateRange -> appendChild ( $ xml -> createElement ( 'EndDate' , $ endDate ) ) ; } $ trackRequest -> appendChild ( $ DateRange ) ; } return $ xml -> saveXML ( ) ; }
10593	public function toArray ( ) { return [ 'level' => $ this -> level , 'datetime' => $ this -> datetime -> format ( 'Y-m-d H:i:s' ) , 'header' => $ this -> header , 'stack' => $ this -> stack , ] ; }
7357	static public function isValidState ( $ state , $ throwException = true ) { if ( in_array ( $ state , static :: getStates ( ) , true ) ) { return true ; } if ( $ throwException ) { throw new InvalidArgumentException ( "Invalid payment states '$state'." ) ; } return false ; }
6032	public function getDeployedFile ( $ templateId , $ templateType = self :: TEMPLATE_IMAGE , $ siteId = null ) { foreach ( $ this -> deployedFiles as $ deployedFile ) { if ( null === $ siteId || $ siteId == $ deployedFile -> getDeployMentSiteId ( ) ) { if ( self :: TEMPLATE_VIDEO == $ templateType ) { if ( $ templateId == $ deployedFile -> getVideoTemplateId ( ) && null === $ deployedFile -> getImageTemplateId ( ) ) { return $ deployedFile ; } } elseif ( self :: TEMPLATE_IMAGE == $ templateType && $ templateId == $ deployedFile -> getImageTemplateId ( ) || ( null === $ templateId && null === $ deployedFile -> getImageTemplateId ( ) && null === $ deployedFile -> getVideoTemplateId ( ) ) ) { return $ deployedFile ; } } } throw new NotFoundException ( 'No DeploymentFile with the id "' . $ templateId . '" exists.' ) ; }
8677	public function unique ( ) { $ items = [ ] ; foreach ( $ this -> items as $ item ) { if ( array_search ( $ item , $ items , true ) === false ) { $ items [ ] = $ item ; } } return $ this -> createFrom ( $ items ) ; }
11412	public function batchTagUsers ( array $ openIds , $ tagId ) { $ params = [ 'openid_list' => $ openIds , 'tagid' => $ tagId , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_MEMBER_BATCH_TAG , $ params ] ) ; }
4134	public static function encryptAndAppendTag ( $ K , $ IV , $ P = null , $ A = null , $ tag_length = 128 ) { return implode ( self :: encrypt ( $ K , $ IV , $ P , $ A , $ tag_length ) ) ; }
10537	public function prepareHeaders ( $ requestHeaders ) { $ responseHeaders = [ ] ; if ( isset ( $ requestHeaders [ 'Origin' ] , $ this -> cors [ 'Origin' ] ) ) { if ( in_array ( '*' , $ this -> cors [ 'Origin' ] ) || in_array ( $ requestHeaders [ 'Origin' ] , $ this -> cors [ 'Origin' ] ) ) { $ responseHeaders [ 'Access-Control-Allow-Origin' ] = $ requestHeaders [ 'Origin' ] ; } } $ this -> prepareAllowHeaders ( 'Headers' , $ requestHeaders , $ responseHeaders ) ; if ( isset ( $ requestHeaders [ 'Access-Control-Request-Method' ] ) ) { $ responseHeaders [ 'Access-Control-Allow-Methods' ] = implode ( ', ' , $ this -> cors [ 'Access-Control-Request-Method' ] ) ; } if ( isset ( $ this -> cors [ 'Access-Control-Allow-Credentials' ] ) ) { $ responseHeaders [ 'Access-Control-Allow-Credentials' ] = $ this -> cors [ 'Access-Control-Allow-Credentials' ] ? 'true' : 'false' ; } if ( isset ( $ this -> cors [ 'Access-Control-Max-Age' ] ) && Yii :: $ app -> getRequest ( ) -> getIsOptions ( ) ) { $ responseHeaders [ 'Access-Control-Max-Age' ] = $ this -> cors [ 'Access-Control-Max-Age' ] ; } if ( isset ( $ this -> cors [ 'Access-Control-Expose-Headers' ] ) ) { $ responseHeaders [ 'Access-Control-Expose-Headers' ] = implode ( ', ' , $ this -> cors [ 'Access-Control-Expose-Headers' ] ) ; } return $ responseHeaders ; }
6403	public function isValid ( ) { if ( $ this -> getFromDay ( ) == null || $ this -> getFromHour ( ) == null || $ this -> getToDay ( ) == null || $ this -> getToHour ( ) == null ) { return false ; } if ( $ this -> getFromDay ( ) < 1 || $ this -> getFromDay ( ) > 31 ) { return false ; } if ( $ this -> getToDay ( ) < 1 || $ this -> getToDay ( ) > 31 ) { return false ; } if ( $ this -> getFromHour ( ) > 24 || $ this -> getToHour ( ) > 24 ) { return false ; } if ( $ this -> getFromDay ( ) == $ this -> getToDay ( ) && $ this -> getFromHour ( ) >= $ this -> getToHour ( ) ) { return false ; } return true ; }
4365	public function onErrorHighPri ( Event $ error ) { $ this -> throttleDataRead ( ) ; $ hash = $ error [ 'hash' ] ; $ error [ 'email' ] = ( $ error [ 'type' ] & $ this -> cfg [ 'emailMask' ] ) && $ error [ 'isFirstOccur' ] && $ this -> cfg [ 'emailTo' ] ; $ error [ 'stats' ] = array ( 'tsEmailed' => 0 , 'countSince' => 0 , 'emailedTo' => '' , ) ; if ( isset ( $ this -> throttleData [ 'errors' ] [ $ hash ] ) ) { $ stats = \ array_intersect_key ( $ this -> throttleData [ 'errors' ] [ $ hash ] , $ error [ 'stats' ] ) ; $ error [ 'stats' ] = \ array_merge ( $ error [ 'stats' ] , $ stats ) ; } return ; }
10342	protected function isValidDate ( $ year , $ month , $ day ) { if ( $ month <= 0 || $ month > 12 || $ day <= 0 || $ day > 31 ) { return false ; } if ( ( $ month == 4 || $ month == 6 || $ month == 9 || $ month == 11 ) && ( $ day == 31 ) ) { return false ; } if ( $ month == 2 ) { if ( $ day > 29 ) { return false ; } $ leap = date ( 'L' , strtotime ( $ year . '-01-01' ) ) ; if ( $ leap === '0' && $ day > 28 ) { return false ; } } return true ; }
2292	public static function getTheme ( ) { $ theme = Config :: get ( 'backendTheme' ) ; $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( $ theme != '' && $ theme != 'flexible' && is_dir ( $ rootDir . '/system/themes/' . $ theme ) ) { return $ theme ; } return 'flexible' ; }
9293	protected function getAssetsUrl ( ) { if ( ! isset ( $ this -> _assetsUrl ) ) { $ path = dirname ( __FILE__ ) . DIRECTORY_SEPARATOR . '..' . DIRECTORY_SEPARATOR . 'assets' ; $ this -> _assetsUrl = Yii :: app ( ) -> assetManager -> publish ( $ path , false , - 1 , $ this -> forceCopyAssets ) ; } return $ this -> _assetsUrl ; }
10733	public static function checkLeapYear ( $ year ) { $ year = Cast :: _Int ( $ year ) ; if ( $ year % 4 !== 0 ) { return false ; } elseif ( $ year % 100 !== 0 ) { return true ; } elseif ( $ year % 400 !== 0 ) { return false ; } elseif ( $ year === 0 ) { return false ; } return true ; }
3173	protected function getRouteItemAssessmentItemRefs ( RunnerServiceContext $ context , RouteItem $ routeItem , & $ catSession ) { $ catService = $ this -> getServiceManager ( ) -> get ( CatService :: SERVICE_ID ) ; $ compilationDirectory = $ context -> getCompilationDirectory ( ) [ 'private' ] ; $ itemRefs = [ ] ; $ catSession = false ; if ( $ context -> isAdaptive ( $ routeItem -> getAssessmentItemRef ( ) ) ) { $ catSession = $ context -> getCatSession ( $ routeItem ) ; $ itemRefs = $ catService -> getAssessmentItemRefByIdentifiers ( $ compilationDirectory , $ context -> getShadowTest ( $ routeItem ) ) ; } else { $ itemRefs [ ] = $ routeItem -> getAssessmentItemRef ( ) ; } return $ itemRefs ; }
11551	public function saveConsignment ( ConsignmentInterface $ consignment ) { $ adapter = $ this -> getAdapter ( $ consignment ) ; $ event = new EventConsignment ( $ consignment ) ; $ this -> eventDispatcher -> dispatch ( Events :: PRE_CONSIGNMENT_SAVE , $ event ) ; if ( ! $ consignment -> getStatus ( ) ) { $ consignment -> setStatus ( ConsignmentStatusList :: STATUS_NEW ) ; } try { $ adapter -> saveConsignment ( $ consignment ) ; $ this -> consignmentRepository -> saveConsignment ( $ consignment ) ; } catch ( \ Exception $ e ) { throw new VendorAdapterException ( 'Error during consignment saving.' , null , $ e ) ; } $ event = new EventConsignment ( $ consignment ) ; $ this -> eventDispatcher -> dispatch ( Events :: POST_CONSIGNMENT_SAVE , $ event ) ; }
6833	public function userHasRight ( array $ user , $ right ) { $ hasRight = false ; if ( isset ( $ user [ 'role' ] ) && ! empty ( $ right ) && isset ( $ this -> _rightsConfig [ $ right ] ) ) { if ( in_array ( $ user [ 'role' ] , $ this -> _rightsConfig [ $ right ] ) ) { $ hasRight = true ; } } return $ hasRight ; }
6519	private function unFreeze ( ) { $ this -> isFrozen = false ; $ this -> isReplay = null ; foreach ( static :: schema ( ) -> getFields ( ) as $ field ) { if ( $ field -> getType ( ) -> isMessage ( ) ) { $ value = $ this -> get ( $ field -> getName ( ) ) ; if ( empty ( $ value ) ) { continue ; } if ( $ value instanceof Message ) { $ value -> unFreeze ( ) ; continue ; } foreach ( $ value as $ v ) { $ v -> unFreeze ( ) ; } } } }
1821	protected function getQuicknavPages ( $ pid , $ level = 1 , $ host = null ) { global $ objPage ; $ groups = array ( ) ; $ arrPages = array ( ) ; if ( FE_USER_LOGGED_IN ) { $ this -> import ( FrontendUser :: class , 'User' ) ; $ groups = $ this -> User -> groups ; } $ objSubpages = PageModel :: findPublishedRegularWithoutGuestsByPid ( $ pid ) ; if ( $ objSubpages === null ) { return array ( ) ; } ++ $ level ; foreach ( $ objSubpages as $ objSubpage ) { $ _groups = StringUtil :: deserialize ( $ objSubpage -> groups ) ; if ( $ host !== null ) { $ objSubpage -> domain = $ host ; } if ( ! $ objSubpage -> protected || $ this -> showProtected || ( \ is_array ( $ _groups ) && \ is_array ( $ groups ) && array_intersect ( $ _groups , $ groups ) ) ) { if ( ! $ objSubpage -> hide || $ this -> showHidden ) { $ arrPages [ ] = array ( 'level' => ( $ level - 2 ) , 'title' => StringUtil :: specialchars ( StringUtil :: stripInsertTags ( $ objSubpage -> pageTitle ? : $ objSubpage -> title ) ) , 'href' => $ objSubpage -> getFrontendUrl ( ) , 'link' => StringUtil :: stripInsertTags ( $ objSubpage -> title ) , 'active' => ( $ objPage -> id == $ objSubpage -> id || ( $ objSubpage -> type == 'forward' && $ objPage -> id == $ objSubpage -> jumpTo ) ) ) ; if ( ! $ this -> showLevel || $ this -> showLevel >= $ level || ( ! $ this -> hardLimit && ( $ objPage -> id == $ objSubpage -> id || \ in_array ( $ objPage -> id , $ this -> Database -> getChildRecords ( $ objSubpage -> id , 'tl_page' ) ) ) ) ) { $ subpages = $ this -> getQuicknavPages ( $ objSubpage -> id , $ level ) ; if ( \ is_array ( $ subpages ) ) { $ arrPages = array_merge ( $ arrPages , $ subpages ) ; } } } } } return $ arrPages ; }
11080	public static function getDayName ( $ day ) { if ( $ day < self :: DOW_MONDAY || $ day > self :: DOW_SUNDAY ) { return '' ; } $ dayNames = [ self :: DOW_MONDAY => self :: poorManTranslate ( 'fts-shared' , 'Monday' ) , self :: DOW_TUESDAY => self :: poorManTranslate ( 'fts-shared' , 'Tuesday' ) , self :: DOW_WEDNESDAY => self :: poorManTranslate ( 'fts-shared' , 'Wednesday' ) , self :: DOW_THURSDAY => self :: poorManTranslate ( 'fts-shared' , 'Thursday' ) , self :: DOW_FRIDAY => self :: poorManTranslate ( 'fts-shared' , 'Friday' ) , self :: DOW_SATURDAY => self :: poorManTranslate ( 'fts-shared' , 'Saturday' ) , self :: DOW_SUNDAY => self :: poorManTranslate ( 'fts-shared' , 'Sunday' ) , ] ; return $ dayNames [ $ day ] ; }
6560	public static function splitPath ( $ path ) { $ fragments = [ ] ; while ( true ) { $ cur = dirname ( $ path ) ; if ( $ cur [ 0 ] === DIRECTORY_SEPARATOR ) { $ cur [ 0 ] = '/' ; } if ( $ cur === $ path || ( $ cur === '.' && basename ( $ path ) === $ path ) ) { break ; } $ fragment = trim ( substr ( $ path , strlen ( $ cur ) ) , '/' ) ; if ( ! $ fragments ) { $ fragments [ ] = $ fragment ; } elseif ( $ fragment === '..' && basename ( $ cur ) !== '..' ) { $ cur = dirname ( $ cur ) ; } elseif ( $ fragment !== '.' ) { $ fragments [ ] = $ fragment ; } $ path = $ cur ; } if ( $ path !== '' ) { $ fragments [ ] = trim ( $ path , '/' ) ; } return array_reverse ( $ fragments ) ; }
9813	protected function deleteRaw ( string $ path , $ body = null , array $ headers = [ ] ) { $ response = $ this -> client -> delete ( $ path , $ headers , $ body ) ; return ResponseMediator :: getContent ( $ response ) ; }
2248	public static function addToUrl ( $ strRequest , $ blnAddRef = true , $ arrUnset = array ( ) ) { $ query = new Query ( Environment :: get ( 'queryString' ) ) ; $ query = $ query -> withoutPairs ( array_merge ( array ( 'rt' , 'ref' ) , $ arrUnset ) ) ; $ query = $ query -> merge ( str_replace ( '&amp;' , '&' , $ strRequest ) ) ; if ( isset ( $ _GET [ 'ref' ] ) || ( $ strRequest != '' && $ blnAddRef ) ) { $ query = $ query -> merge ( 'ref=' . System :: getContainer ( ) -> get ( 'request_stack' ) -> getCurrentRequest ( ) -> attributes -> get ( '_contao_referer_id' ) ) ; } $ uri = $ query -> getUriComponent ( ) ; if ( strpos ( $ strRequest , '%2B' ) !== false ) { $ uri = str_replace ( '+' , '%2B' , $ uri ) ; } return TL_SCRIPT . ampersand ( $ uri ) ; }
7019	private function formatH ( & $ str ) { if ( strstr ( $ str , '%H' ) ) $ str = str_replace ( '%H' , sprintf ( '%02d' , $ this -> hour ) , $ str ) ; }
3245	public function onCharge ( $ order ) { $ this -> statusCode = 'pending' ; $ this -> detail = 'pending response, token:' . $ this -> token ; return parent :: onCharge ( $ order ) ; }
4631	protected function prepareRequestMethod ( ) { switch ( $ this -> command -> getMethod ( ) ) { case "POST" : $ this -> options [ CURLOPT_POST ] = 1 ; break ; case "PUT" : $ this -> options [ CURLOPT_CUSTOMREQUEST ] = 'PUT' ; break ; case "DELETE" : $ this -> options [ CURLOPT_CUSTOMREQUEST ] = 'DELETE' ; break ; case "HEAD" : $ this -> options [ CURLOPT_NOBODY ] = 1 ; break ; default : $ this -> options [ CURLOPT_HTTPGET ] = 1 ; } return $ this ; }
10917	private function isCmsActive ( ) { $ melisCms = 'MelisCms' ; $ moduleSvc = $ this -> getServiceLocator ( ) -> get ( 'ModulesService' ) ; $ modules = $ moduleSvc -> getActiveModules ( ) ; if ( in_array ( $ melisCms , $ modules ) ) { return true ; } return false ; }
3819	private function checkboxCaption ( $ key , $ table , IAttribute $ attribute ) { return $ this -> translator -> trans ( $ table . '.' . $ key , [ $ attribute -> getName ( ) ] , 'contao_' . $ table ) ; }
8264	protected function onOAuthError ( $ errorCode ) { $ errorCode = strlen ( $ errorCode > 100 ) ? substr ( $ errorCode , 0 , 100 ) : $ errorCode ; $ this -> logger -> notice ( "OAuth2 error response: code {code}, provider {provider}" , array ( "code" => $ errorCode , "provider" => get_class ( $ this -> provider ) , ) ) ; $ this -> session -> addFlash ( "error" , "The provider returned an error ($errorCode)" ) ; $ this -> picoAuth -> redirectToLogin ( ) ; }
2506	public static function exaluateXpathQueryOnWsdl ( $ wsdlId , $ wsdlFilePath , $ xpath ) { WsdlAnalyser :: loadWsdlXpath ( $ wsdlFilePath , $ wsdlId ) ; return self :: $ wsdlDomXpath [ $ wsdlId ] -> evaluate ( $ xpath ) ; }
9018	public function getActionWords ( $ string , $ language = 'english' ) { $ words = $ this -> getWords ( $ string ) ; $ filter = new ActionWordsFilter ( $ language ) ; $ actionWords = [ ] ; foreach ( $ words as $ word ) { $ word = $ this -> removePunctuation ( $ word ) ; if ( ! is_null ( $ filter -> filter ( $ word ) ) ) { $ actionWords [ ] = $ word ; } } return $ actionWords ; }
12334	private function _checkPasswordIsGood ( ) : bool { $ sLogin = self :: $ _sLogin ; $ sPassword = Config :: get ( 'security' ) -> users -> $ sLogin -> password ; if ( $ sPassword == self :: $ _sPassword ) { return true ; } else if ( $ sPassword == md5 ( self :: $ _sPassword ) ) { return true ; } else { return false ; } }
4173	public function hasMigrationFile ( ) { $ this -> count = $ this -> fileHas ( '/class [A-Z]\w+ extends Migration/i' ) -> getClasses ( ) -> count ( ) ; return $ this -> hasMigrationFile = $ this -> count > 0 ; }
11109	public function getExtensions ( Container $ app ) { $ directories = $ this -> findExtensionsDirectories ( $ app ) ; foreach ( $ directories as $ directory ) { $ extensionName = $ directory -> getRelativePathname ( ) ; $ this -> extensions [ $ extensionName ] [ 'name' ] = $ extensionName ; $ this -> extensions [ $ extensionName ] [ 'pathName' ] = $ directory -> getPathName ( ) ; } return $ this -> extensions ; }
9567	public function config ( $ configurator ) { if ( $ this -> booted ) { $ this -> invokeConfigurator ( $ configurator ) ; } else { $ this -> configurators -> push ( $ configurator ) ; } }
4161	public function modifyRelationship ( $ action , $ user ) { if ( true === in_array ( $ action , $ this -> _actions ) && isset ( $ user ) ) { return $ this -> _makeCall ( 'users/' . $ user . '/relationship' , array ( 'action' => $ action ) , 'POST' ) ; } throw new InvalidParameterException ( 'Error: modifyRelationship() - This method requires an action command and the target user id.' ) ; }
1525	protected function doCreate ( StoreInterface $ store , CreateResource $ request ) { if ( $ response = $ this -> beforeCommit ( $ request ) ) { return $ response ; } $ record = $ store -> createRecord ( $ request -> getResourceType ( ) , $ request -> all ( ) , $ request -> getParameters ( ) ) ; return $ this -> afterCommit ( $ request , $ record , false ) ? : $ record ; }
9967	public function getHyperlink ( $ pCellCoordinate ) { if ( isset ( $ this -> hyperlinkCollection [ $ pCellCoordinate ] ) ) { return $ this -> hyperlinkCollection [ $ pCellCoordinate ] ; } $ this -> hyperlinkCollection [ $ pCellCoordinate ] = new Hyperlink ( ) ; return $ this -> hyperlinkCollection [ $ pCellCoordinate ] ; }
7624	protected function performRequest ( $ path = '/' , $ query = array ( ) , $ httpVerb = 'GET' , $ headers = array ( ) , $ forTableStorage = false , $ rawData = null , $ resourceType = self :: RESOURCE_UNKNOWN , $ requiredPermission = self :: PERMISSION_READ ) { if ( strpos ( $ path , '/' ) !== 0 ) { $ path = '/' . $ path ; } if ( ! isset ( $ headers [ 'Content-Type' ] ) ) { $ headers [ 'Content-Type' ] = '' ; } if ( ! isset ( $ headers [ 'content-length' ] ) && ( $ rawData !== null || $ httpVerb == "PUT" ) ) { $ headers [ 'Content-Length' ] = strlen ( ( string ) $ rawData ) ; } $ headers [ 'Expect' ] = '' ; $ headers [ 'x-ms-version' ] = $ this -> apiVersion ; $ path = str_replace ( ' ' , '%20' , $ path ) ; $ requestUrl = $ this -> getBaseUrl ( ) . $ path ; if ( count ( $ query ) > 0 ) { $ queryString = '' ; foreach ( $ query as $ key => $ value ) { $ queryString .= ( $ queryString ? '&' : '?' ) . rawurlencode ( $ key ) . '=' . rawurlencode ( $ value ) ; } $ requestUrl .= $ queryString ; } $ requestUrl = $ this -> credentials -> signRequestUrl ( $ requestUrl , $ resourceType , $ requiredPermission ) ; $ headers = $ this -> credentials -> signRequestHeaders ( $ httpVerb , $ path , $ query , $ headers , $ forTableStorage , $ resourceType , $ requiredPermission , $ rawData ) ; return $ this -> httpClient -> request ( $ httpVerb , $ requestUrl , $ rawData , $ headers ) ; }
10076	public static function controlCharacterPHP2OOXML ( $ value ) { self :: buildCharacterSets ( ) ; return str_replace ( array_values ( self :: $ controlCharacters ) , array_keys ( self :: $ controlCharacters ) , $ value ) ; }
1265	public function recoverLabel ( $ trackingData , $ labelSpecification = null , $ labelDelivery = null , $ translate = null ) { if ( is_array ( $ trackingData ) ) { if ( ! isset ( $ trackingData [ 'value' ] ) ) { throw new InvalidArgumentException ( '$trackingData parameter is required to contain `value`.' ) ; } if ( ! isset ( $ trackingData [ 'shipperNumber' ] ) ) { throw new InvalidArgumentException ( '$trackingData parameter is required to contain `shipperNumber`.' ) ; } } if ( ! empty ( $ translate ) ) { if ( ! isset ( $ translateOpts [ 'language' ] ) ) { $ translateOpts [ 'language' ] = 'eng' ; } if ( ! isset ( $ translateOpts [ 'dialect' ] ) ) { $ translateOpts [ 'dialect' ] = 'US' ; } } $ request = $ this -> createRecoverLabelRequest ( $ trackingData , $ labelSpecification , $ labelDelivery , $ translate ) ; $ response = $ this -> request ( $ this -> createAccess ( ) , $ request , $ this -> compileEndpointUrl ( $ this -> recoverLabelEndpoint ) ) ; if ( $ response -> Response -> ResponseStatusCode == 0 ) { throw new Exception ( "Failure ({$response->Response->Error->ErrorSeverity}): {$response->Response->Error->ErrorDescription}" , ( int ) $ response -> Response -> Error -> ErrorCode ) ; } else { unset ( $ response -> Response ) ; return $ this -> formatResponse ( $ response ) ; } }
2889	public function onCollectionLoad ( Varien_Event_Observer $ observer ) { if ( ! $ this -> canCollect ( ) ) { return ; } $ collection = $ observer -> getData ( 'collection' ) ; $ this -> getRequestInfo ( ) -> addCollection ( $ collection ) ; }
12193	public function onKernelException ( GetResponseForExceptionEvent $ event ) { $ exception = $ event -> getException ( ) ; if ( $ exception instanceof AuthenticationCredentialsNotFoundException ) { return new RedirectResponse ( "/login" ) ; } $ message = $ exception -> getMessage ( ) ; if ( $ exception instanceof NotFoundHttpException || $ exception instanceof PageNotPublishedException ) { $ this -> render404page ( $ event , $ message ) ; return ; } if ( ! $ exception instanceof RedKiteCmsExceptionInterface ) { DataLogger :: log ( $ message , DataLogger :: CRITICAL ) ; if ( $ this -> debug ) { return $ event ; } $ this -> setUpResponse ( $ event , $ message ) ; return ; } $ message = Utils :: translateException ( $ message , $ exception ) ; $ this -> setUpResponse ( $ event , $ message ) ; DataLogger :: log ( $ message , DataLogger :: ERROR ) ; }
12345	public function editAction ( Request $ request , Post $ post ) { if ( is_object ( $ post -> getPublished ( ) ) && $ post -> getPublished ( ) -> format ( 'dmY' ) == '3011-0001' ) { $ post -> setPublished ( null ) ; } $ deleteForm = $ this -> createDeleteForm ( $ post ) ; $ editForm = $ this -> createForm ( 'BlogBundle\Form\PostType' , $ post , array ( 'translator' => $ this -> get ( 'translator' ) ) ) ; $ editForm -> handleRequest ( $ request ) ; if ( $ editForm -> isSubmitted ( ) && $ editForm -> isValid ( ) ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ em -> persist ( $ post ) ; $ em -> flush ( ) ; $ this -> get ( 'session' ) -> getFlashBag ( ) -> add ( 'success' , 'post.edited' ) ; return $ this -> redirectToRoute ( 'blog_post_index' ) ; } return array ( 'entity' => $ post , 'edit_form' => $ editForm -> createView ( ) , 'delete_form' => $ deleteForm -> createView ( ) , ) ; }
10328	public function getNestingLevel ( ) { $ nestingLevel = 0 ; $ parent = $ this -> getParent ( ) ; while ( $ parent instanceof SpgrContainer ) { ++ $ nestingLevel ; $ parent = $ parent -> getParent ( ) ; } return $ nestingLevel ; }
7336	private function getStockSubjectMappings ( ) { return [ [ 'fieldName' => 'stockMode' , 'columnName' => 'stock_mode' , 'type' => 'string' , 'length' => 16 , 'nullable' => false , 'default' => Stock \ StockSubjectModes :: MODE_AUTO , ] , [ 'fieldName' => 'stockState' , 'columnName' => 'stock_state' , 'type' => 'string' , 'length' => 16 , 'nullable' => false , 'default' => Stock \ StockSubjectStates :: STATE_OUT_OF_STOCK , ] , [ 'fieldName' => 'stockFloor' , 'columnName' => 'stock_floor' , 'type' => 'decimal' , 'precision' => 10 , 'scale' => 3 , 'nullable' => true , 'default' => 0 , ] , [ 'fieldName' => 'inStock' , 'columnName' => 'in_stock' , 'type' => 'decimal' , 'precision' => 10 , 'scale' => 3 , 'nullable' => false , 'default' => 0 , ] , [ 'fieldName' => 'availableStock' , 'columnName' => 'available_stock' , 'type' => 'decimal' , 'precision' => 10 , 'scale' => 3 , 'nullable' => false , 'default' => 0 , ] , [ 'fieldName' => 'virtualStock' , 'columnName' => 'virtual_stock' , 'type' => 'decimal' , 'precision' => 10 , 'scale' => 3 , 'nullable' => false , 'default' => 0 , ] , [ 'fieldName' => 'replenishmentTime' , 'columnName' => 'replenishment_time' , 'type' => 'smallint' , 'nullable' => false , 'default' => 7 , ] , [ 'fieldName' => 'estimatedDateOfArrival' , 'columnName' => 'estimated_date_of_arrival' , 'type' => 'datetime' , 'nullable' => true , ] , [ 'fieldName' => 'geocode' , 'columnName' => 'geocode' , 'type' => 'string' , 'length' => 16 , 'nullable' => true , ] , [ 'fieldName' => 'minimumOrderQuantity' , 'columnName' => 'minimum_order_quantity' , 'type' => 'decimal' , 'precision' => 10 , 'scale' => 3 , 'nullable' => false , 'default' => 1 , ] , [ 'fieldName' => 'quoteOnly' , 'columnName' => 'quote_only' , 'type' => 'boolean' , 'nullable' => false , 'default' => false , ] , [ 'fieldName' => 'endOfLife' , 'columnName' => 'end_of_life' , 'type' => 'boolean' , 'nullable' => false , 'default' => false , ] , ] ; }
12029	function generateParamFilterBlock ( \ ArtaxServiceBuilder \ Parameter $ parameter ) { $ i1 = ' ' ; $ i2 = ' ' ; $ text = '' ; $ text .= sprintf ( $ i1 . "case ('%s'): {" . PHP_EOL , $ parameter -> getName ( ) ) ; foreach ( $ parameter -> getFilters ( ) as $ filter ) { if ( is_array ( $ filter ) ) { $ text .= $ i2 . '$args = [];' . PHP_EOL ; if ( isset ( $ filter [ 'args' ] ) == true ) { if ( is_array ( $ filter [ 'args' ] ) == false ) { throw new \ ArtaxServiceBuilder \ APIBuilderException ( "Filter args should be an array instead received " . var_export ( $ filter [ 'args' ] , true ) ) ; } foreach ( $ filter [ 'args' ] as $ data ) { if ( $ data == '@value' ) { $ text .= $ i2 . '$args[] = $value;' . PHP_EOL ; } elseif ( $ data == '@api' ) { $ text .= $ i2 . "\$args[] = \$this->\$api;" . PHP_EOL ; } else { $ text .= $ i2 . "\$args[] = $data;" . PHP_EOL ; } } } $ text .= sprintf ( $ i2 . '$value = call_user_func_array([$value, \'%s\'], $args);' . PHP_EOL , $ filter [ 'method' ] ) ; } else { $ text .= sprintf ( $ i2 . 'call_user_func(\'%s\', $value);' . PHP_EOL , $ filter ) ; } } $ text .= $ i1 . ' break;' . PHP_EOL ; $ text .= $ i1 . '}' . PHP_EOL ; return $ text ; }
7856	private function publishConfig ( ) { $ config = __DIR__ . '/config/workflow.php' ; $ this -> publishes ( [ $ config => config_path ( 'workflow.php' ) ] ) ; $ this -> mergeConfigFrom ( $ config , 'workflow' ) ; }
11661	public static function readFromFile ( $ file ) { $ real_file = File :: asFile ( $ file ) ; if ( $ real_file -> exists ( ) ) return self :: readFromString ( $ file -> getContent ( ) ) ; else return array ( ) ; }
9274	public function getServiceConfig ( ) { return array ( 'factories' => array ( 'CronHelper\Service\CronService' => function ( $ serviceManager ) { $ mainConfig = $ serviceManager -> get ( 'config' ) ; $ serviceConfig = array ( ) ; if ( is_array ( $ mainConfig ) ) { if ( array_key_exists ( 'cron_helper' , $ mainConfig ) ) { $ serviceConfig = $ mainConfig [ 'cron_helper' ] ; } } $ cronService = new CronService ( $ serviceConfig ) ; return $ cronService ; } , ) , ) ; }
432	public function getModules ( $ loadedOnly = false ) { if ( $ loadedOnly ) { $ modules = [ ] ; foreach ( $ this -> _modules as $ module ) { if ( $ module instanceof self ) { $ modules [ ] = $ module ; } } return $ modules ; } return $ this -> _modules ; }
7365	protected function resolveOutstandingDate ( SaleInterface $ sale ) { if ( ! $ sale instanceof InvoiceSubjectInterface ) { return null ; } if ( ! $ sale instanceof ShipmentSubjectInterface ) { return null ; } if ( null === $ term = $ sale -> getPaymentTerm ( ) ) { return null ; } if ( ! $ this -> saleHasOutstandingPayments ( $ sale ) ) { return null ; } $ from = null ; switch ( $ term -> getTrigger ( ) ) { case PaymentTermTriggers :: TRIGGER_SHIPPED : $ from = $ sale -> getShippedAt ( ) ; break ; case PaymentTermTriggers :: TRIGGER_FULLY_SHIPPED : if ( $ sale -> getShipmentState ( ) === ShipmentStates :: STATE_COMPLETED ) { $ from = $ sale -> getShippedAt ( true ) ; } break ; case PaymentTermTriggers :: TRIGGER_INVOICED : $ from = $ sale -> getInvoicedAt ( ) ; break ; case PaymentTermTriggers :: TRIGGER_FULLY_INVOICED : if ( $ sale -> getInvoiceState ( ) === InvoiceStates :: STATE_COMPLETED ) { $ from = $ sale -> getInvoicedAt ( true ) ; } break ; } if ( null === $ from ) { return null ; } $ date = clone $ from ; $ date -> setTime ( 23 , 59 , 59 ) ; $ date -> modify ( sprintf ( '+%s days' , $ term -> getDays ( ) ) ) ; if ( $ term -> getEndOfMonth ( ) ) { $ date -> modify ( 'last day of this month' ) ; } return $ date ; }
7172	protected function resolveSaleTargetCountry ( SaleInterface $ sale ) : ? CountryInterface { if ( null !== $ country = $ sale -> getDeliveryCountry ( ) ) { return $ country ; } if ( null !== $ customer = $ sale -> getCustomer ( ) ) { return $ this -> resolveCustomerTargetCountry ( $ customer ) ; } return null ; }
7408	public function merge ( $ ta ) : self { $ this -> _massageBlockInput ( $ in ) ; $ ret = clone $ this ; foreach ( $ ta as $ k => $ v ) { if ( is_int ( $ k ) ) { $ ret [ ] = $ v ; } else { $ ret [ $ k ] = $ v ; } } return $ ret ; }
7594	public function render ( $ sLabelMessage , $ aLabelAttributes = 'label-default' ) { if ( ! is_scalar ( $ sLabelMessage ) ) { throw new InvalidArgumentException ( 'Label message expects a scalar value, "' . gettype ( $ sLabelMessage ) . '" given' ) ; } if ( empty ( $ aLabelAttributes ) ) { throw new InvalidArgumentException ( 'Label attributes are empty' ) ; } if ( is_string ( $ aLabelAttributes ) ) { $ aLabelAttributes = array ( 'class' => $ aLabelAttributes ) ; } elseif ( ! is_array ( $ aLabelAttributes ) ) { throw new InvalidArgumentException ( 'Label attributes expects a string or an array, "' . gettype ( $ aLabelAttributes ) . '" given' ) ; } elseif ( empty ( $ aLabelAttributes [ 'class' ] ) ) { throw new \ InvalidArgumentException ( 'Label "class" attribute is empty' ) ; } elseif ( ! is_string ( $ aLabelAttributes [ 'class' ] ) ) { throw new InvalidArgumentException ( 'Label "class" attribute expects string, "' . gettype ( $ aLabelAttributes ) . '" given' ) ; } if ( ! preg_match ( '/(\s|^)label(\s|$)/' , $ aLabelAttributes [ 'class' ] ) ) { $ aLabelAttributes [ 'class' ] .= ' label' ; } if ( null !== ( $ oTranslator = $ this -> getTranslator ( ) ) ) { $ sLabelMessage = $ oTranslator -> translate ( $ sLabelMessage , $ this -> getTranslatorTextDomain ( ) ) ; } return sprintf ( static :: $ labelFormat , isset ( $ aLabelAttributes [ 'tagName' ] ) ? $ aLabelAttributes [ 'tagName' ] : $ this -> tagName , $ this -> createAttributesString ( $ aLabelAttributes ) , $ sLabelMessage ) ; }
1242	private static function determineActualValueToAssign ( $ class , $ property , $ value ) { if ( ! array_key_exists ( $ property , self :: $ properties [ $ class ] ) ) { return $ value ; } $ info = self :: propertyInfo ( $ class , $ property ) ; if ( $ info [ 'repeatable' ] && is_array ( $ value ) ) { $ values = [ ] ; foreach ( $ value as $ val ) { $ values [ ] = self :: actualValue ( $ info , $ val ) ; } return $ values ; } return self :: actualValue ( $ info , $ value ) ; }
3148	public function isItemCompleted ( RunnerServiceContext $ context , $ routeItem , $ itemSession , $ partially = true ) { if ( $ context instanceof QtiRunnerServiceContext && $ context -> isAdaptive ( ) ) { $ itemIdentifier = $ context -> getCurrentAssessmentItemRef ( ) -> getIdentifier ( ) ; $ itemState = $ this -> getItemState ( $ context , $ itemIdentifier ) ; if ( $ itemState !== null ) { $ itemResponse = [ ] ; foreach ( $ itemState as $ key => $ value ) { if ( isset ( $ value [ 'response' ] ) ) { $ itemResponse [ $ key ] = $ value [ 'response' ] ; } } $ responses = $ this -> parsesItemResponse ( $ context , $ itemIdentifier , $ itemResponse ) ; $ excludedResponseVariables = array ( 'numAttempts' , 'duration' ) ; foreach ( $ responses as $ var ) { if ( $ var instanceof ResponseVariable && in_array ( $ var -> getIdentifier ( ) , $ excludedResponseVariables ) === false ) { $ value = $ var -> getValue ( ) ; $ defaultValue = $ var -> getDefaultValue ( ) ; if ( Utils :: isNull ( $ value ) === true ) { if ( Utils :: isNull ( $ defaultValue ) === ( ( $ partially ) ? false : true ) ) { return ( ( $ partially ) ? true : false ) ; } } else { if ( $ value -> equals ( $ defaultValue ) === ( ( $ partially ) ? false : true ) ) { return ( ( $ partially ) ? true : false ) ; } } } } } return ( ( $ partially ) ? false : true ) ; } else { return TestRunnerUtils :: isItemCompleted ( $ routeItem , $ itemSession , $ partially ) ; } }
2727	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ service = $ this -> api -> checkServiceDetails ( ) ; $ currActiveVersion = $ this -> vcl -> determineVersions ( $ service -> versions ) ; $ snippet = $ this -> config -> getVclSnippets ( Config :: VCL_WAF_PATH , Config :: VCL_WAF_ALLOWLIST_SNIPPET ) ; $ acls = $ this -> prepareAcls ( $ this -> request -> getParam ( 'acls' ) ) ; $ allowedItems = $ acls ; $ strippedAllowedItems = substr ( $ allowedItems , 0 , strrpos ( $ allowedItems , '||' , - 1 ) ) ; foreach ( $ snippet as $ key => $ value ) { if ( $ strippedAllowedItems === '' ) { $ value = '' ; } else { $ value = str_replace ( '####WAF_ALLOWLIST####' , $ strippedAllowedItems , $ value ) ; } $ snippetName = Config :: FASTLY_MAGENTO_MODULE . '_waf_' . $ key ; $ snippetId = $ this -> api -> getSnippet ( $ currActiveVersion [ 'active_version' ] , $ snippetName ) -> id ; $ params = [ 'name' => $ snippetId , 'content' => $ value ] ; $ this -> api -> updateSnippet ( $ params ) ; } $ this -> cacheTypeList -> cleanType ( 'config' ) ; $ this -> systemConfig -> clean ( ) ; return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
8803	public function setFlash ( $ key , $ value , $ redirect = null ) { $ this -> set ( '_nur_flash' , [ $ key => $ value ] ) ; if ( ! is_null ( $ redirect ) ) { uri ( ) -> redirect ( $ redirect ) ; } return false ; }
3060	public function getCurrentAssessmentItemRef ( ) { if ( $ this -> isAdaptive ( ) ) { return $ this -> getServiceManager ( ) -> get ( CatService :: SERVICE_ID ) -> getAssessmentItemRefByIdentifier ( $ this -> getCompilationDirectory ( ) [ 'private' ] , $ this -> getCurrentCatItemId ( ) ) ; } else { return $ this -> getTestSession ( ) -> getCurrentAssessmentItemRef ( ) ; } }
5206	public function areActiveRoutes ( array $ routeNames , $ output = "active" ) { foreach ( $ routeNames as $ routeName ) { if ( $ this -> isActiveRoute ( $ routeName , true ) ) { return $ output ; } } return null ; }
1492	public function current ( $ meta = null , array $ queryParams = [ ] ) { $ url = $ this -> generator -> current ( ) ; if ( $ queryParams ) { $ url .= '?' . http_build_query ( $ queryParams ) ; } return $ this -> factory -> createLink ( $ url , $ meta , true ) ; }
10227	public function pageFor ( $ model , $ itemId = 0 , ModelConfig $ config = null ) { $ modelName = $ this -> resolveModelName ( $ model ) ; $ item = $ this -> findItem ( $ modelName , $ itemId ) ; $ pageFactory = $ this -> app -> make ( 'Label305\AujaLaravel\Factory\PageFactory' ) ; return $ pageFactory -> create ( $ modelName , $ item , $ config ) ; }
1835	public static function findByIdOrAlias ( $ varId , array $ arrOptions = array ( ) ) { $ isAlias = ! preg_match ( '/^[1-9]\d*$/' , $ varId ) ; if ( ! $ isAlias && empty ( $ arrOptions ) ) { $ objModel = Registry :: getInstance ( ) -> fetch ( static :: $ strTable , $ varId ) ; if ( $ objModel !== null ) { return $ objModel ; } } $ t = static :: $ strTable ; $ arrOptions = array_merge ( array ( 'limit' => 1 , 'column' => $ isAlias ? array ( "$t.alias=?" ) : array ( "$t.id=?" ) , 'value' => $ varId , 'return' => 'Model' ) , $ arrOptions ) ; return static :: find ( $ arrOptions ) ; }
9999	private function setShadowColor ( $ color , $ alpha , $ type ) { if ( $ color !== null ) { $ this -> shadowProperties [ 'color' ] [ 'value' ] = ( string ) $ color ; } if ( $ alpha !== null ) { $ this -> shadowProperties [ 'color' ] [ 'alpha' ] = $ this -> getTrueAlpha ( ( int ) $ alpha ) ; } if ( $ type !== null ) { $ this -> shadowProperties [ 'color' ] [ 'type' ] = ( string ) $ type ; } return $ this ; }
4455	public function attach ( string $ eventName , $ handler , int $ priority = 100 ) : void { if ( is_object ( $ handler ) == false && is_callable ( $ handler ) == false ) { throw new InvalidArgumentException ( sprintf ( 'Event handler must be either an object or a callable %s given.' , gettype ( $ handler ) ) ) ; } $ priorityQueue = $ this -> fetchQueue ( $ eventName ) ; $ priorityQueue -> insert ( $ handler , $ priority ) ; }
5474	protected function createAction ( $ action , $ page ) { if ( ( $ action === '' ) || ( $ action === false ) ) { return $ page -> expandUrl ( $ page -> getUrl ( ) ) ; } return $ page -> expandUrl ( new SimpleUrl ( $ action ) ) ; }
913	private function moveReturnAnnotations ( $ content ) { $ doc = new DocBlock ( $ content ) ; $ returns = $ doc -> getAnnotationsOfType ( 'return' ) ; if ( empty ( $ returns ) ) { return $ content ; } $ others = $ doc -> getAnnotationsOfType ( [ 'param' , 'throws' ] ) ; if ( empty ( $ others ) ) { return $ content ; } $ start = $ returns [ 0 ] -> getStart ( ) ; $ line = $ doc -> getLine ( $ start ) ; foreach ( array_reverse ( $ others ) as $ other ) { if ( $ other -> getEnd ( ) > $ start ) { $ line -> setContent ( $ other -> getContent ( ) . $ line -> getContent ( ) ) ; $ other -> remove ( ) ; } } return $ doc -> getContent ( ) ; }
2398	public static function changeSubscriptionStatus ( FrontendTemplate $ objTemplate ) { if ( strncmp ( Input :: get ( 'token' ) , 'com-' , 4 ) === 0 ) { $ optIn = System :: getContainer ( ) -> get ( 'contao.opt-in' ) ; if ( ( ! $ optInToken = $ optIn -> find ( Input :: get ( 'token' ) ) ) || ! $ optInToken -> isValid ( ) || \ count ( $ arrRelated = $ optInToken -> getRelatedRecords ( ) ) != 1 || key ( $ arrRelated ) != 'tl_comments_notify' || \ count ( $ arrIds = current ( $ arrRelated ) ) != 1 || ( ! $ objNotify = CommentsNotifyModel :: findByPk ( $ arrIds [ 0 ] ) ) ) { $ objTemplate -> confirm = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'invalidToken' ] ; return ; } if ( $ optInToken -> isConfirmed ( ) ) { $ objTemplate -> confirm = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'tokenConfirmed' ] ; return ; } if ( $ optInToken -> getEmail ( ) != $ objNotify -> email ) { $ objTemplate -> confirm = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'tokenEmailMismatch' ] ; return ; } $ objNotify -> active = '1' ; $ objNotify -> save ( ) ; $ optInToken -> confirm ( ) ; $ objTemplate -> confirm = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'com_optInConfirm' ] ; } elseif ( strncmp ( Input :: get ( 'token' ) , 'cor-' , 4 ) === 0 ) { $ objNotify = CommentsNotifyModel :: findOneByTokenRemove ( Input :: get ( 'token' ) ) ; if ( $ objNotify === null ) { $ objTemplate -> confirm = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'invalidToken' ] ; return ; } $ objNotify -> delete ( ) ; $ objTemplate -> confirm = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'com_optInCancel' ] ; } }
11457	public function pageSummary ( $ pageId , $ beginDate , $ endDate ) { $ params = [ 'page_id' => $ pageId , 'begin_date' => $ beginDate , 'end_date' => $ endDate , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_PAGE , $ params ] ) ; }
7992	public function setPassword ( $ pp , $ pca , $ passwd ) { if ( ! $ pp ) throw new BadMethodCallException ( 'Missing parameter $pp (OVH cloud passport).' ) ; if ( ! $ pca ) throw new BadMethodCallException ( 'Missing parameter $pca (PCA ServiceName).' ) ; if ( ! $ passwd ) throw new BadMethodCallException ( 'Missing parameter $passwd (Password for this pca).' ) ; $ payload = array ( 'password' => $ passwd ) ; try { $ this -> put ( 'cloud/' . $ pp . '/pca/' . $ pca , array ( 'Content-Type' => 'application/json;charset=UTF-8' ) , json_encode ( $ payload ) ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new CloudException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } }
1146	public function addConditionalRules ( $ attribute , $ rules = [ ] ) { foreach ( ( array ) $ attribute as $ key ) { $ current = isset ( $ this -> conditional [ $ key ] ) ? $ this -> conditional [ $ key ] : [ ] ; $ merge = head ( $ this -> validator -> explodeRules ( ( array ) $ rules ) ) ; $ this -> conditional [ $ key ] = array_merge ( $ current , $ merge ) ; } }
10855	public function getLocationString ( ) { $ normalized = '' ; if ( $ this -> city !== null ) { $ normalized .= $ this -> city -> name ; } if ( $ this -> region !== null ) { $ normalized .= ' ' . $ this -> region -> name ; } if ( $ this -> postal_code !== null ) { $ normalized .= ' ' . $ this -> postal_code ; } return $ normalized ; }
5734	public function getLeagueMatches ( int $ leagueID , array $ filter = [ 'dateFrom' => '' , 'dateTo' => '' , 'stage' => '' , 'status' => '' , 'matchday' => '' , 'group' => '' ] ) { $ leagueMatches = $ this -> run ( "v2/competitions/{$leagueID}/matches" . "?" . http_build_query ( $ filter ) ) ; return collect ( $ leagueMatches -> matches ) ; }
74	public function requestToken ( $ originUrl , $ consumerKey , $ consumerSecret ) { if ( ! empty ( $ this -> token ) || $ this -> getTokenFromConfig ( $ originUrl ) ) { return $ this -> token [ 'access_token' ] ; } $ this -> io -> setAuthentication ( $ originUrl , $ consumerKey , $ consumerSecret ) ; if ( ! $ this -> requestAccessToken ( $ originUrl ) ) { return '' ; } $ this -> storeInAuthConfig ( $ originUrl , $ consumerKey , $ consumerSecret ) ; return $ this -> token [ 'access_token' ] ; }
2164	public static function convertSingleField ( $ table , $ field ) { $ objDatabase = Database :: getInstance ( ) ; $ objRow = $ objDatabase -> query ( "SELECT id, $field FROM $table WHERE $field!=''" ) ; $ objDesc = $ objDatabase -> query ( "DESC $table $field" ) ; if ( $ objDesc -> Type != 'binary(16)' ) { $ objDatabase -> query ( "ALTER TABLE `$table` CHANGE `$field` `$field` binary(16) NULL" ) ; $ objDatabase -> query ( "UPDATE `$table` SET `$field`=NULL WHERE `$field`='' OR `$field`=0" ) ; } while ( $ objRow -> next ( ) ) { $ objHelper = static :: generateHelperObject ( $ objRow -> $ field ) ; if ( $ objHelper -> isUuid ) { continue ; } if ( $ objHelper -> isNumeric ) { $ objFile = FilesModel :: findByPk ( $ objHelper -> value ) ; $ objDatabase -> prepare ( "UPDATE $table SET $field=? WHERE id=?" ) -> execute ( $ objFile -> uuid , $ objRow -> id ) ; } else { $ objFile = FilesModel :: findByPath ( $ objHelper -> value ) ; $ objDatabase -> prepare ( "UPDATE $table SET $field=? WHERE id=?" ) -> execute ( $ objFile -> uuid , $ objRow -> id ) ; } } }
11182	public function cacheActions ( DirectCollection $ collection ) { $ serializedCollection = serialize ( $ collection ) ; $ this -> set ( Keys :: EXT_ACTION , $ serializedCollection ) ; }
11384	protected function resolve ( ) { if ( $ this -> resolved ) { return ; } $ this -> resolved = [ ] ; foreach ( $ this -> stages as $ stage ) { $ this -> resolved [ ] = $ this -> build ( $ stage ) ; } }
320	protected function renderBodyEndHtml ( $ ajaxMode ) { $ lines = [ ] ; if ( ! empty ( $ this -> jsFiles [ self :: POS_END ] ) ) { $ lines [ ] = implode ( "\n" , $ this -> jsFiles [ self :: POS_END ] ) ; } if ( $ ajaxMode ) { $ scripts = [ ] ; if ( ! empty ( $ this -> js [ self :: POS_END ] ) ) { $ scripts [ ] = implode ( "\n" , $ this -> js [ self :: POS_END ] ) ; } if ( ! empty ( $ this -> js [ self :: POS_READY ] ) ) { $ scripts [ ] = implode ( "\n" , $ this -> js [ self :: POS_READY ] ) ; } if ( ! empty ( $ this -> js [ self :: POS_LOAD ] ) ) { $ scripts [ ] = implode ( "\n" , $ this -> js [ self :: POS_LOAD ] ) ; } if ( ! empty ( $ scripts ) ) { $ lines [ ] = Html :: script ( implode ( "\n" , $ scripts ) ) ; } } else { if ( ! empty ( $ this -> js [ self :: POS_END ] ) ) { $ lines [ ] = Html :: script ( implode ( "\n" , $ this -> js [ self :: POS_END ] ) ) ; } if ( ! empty ( $ this -> js [ self :: POS_READY ] ) ) { $ js = "jQuery(function ($) {\n" . implode ( "\n" , $ this -> js [ self :: POS_READY ] ) . "\n});" ; $ lines [ ] = Html :: script ( $ js ) ; } if ( ! empty ( $ this -> js [ self :: POS_LOAD ] ) ) { $ js = "jQuery(window).on('load', function () {\n" . implode ( "\n" , $ this -> js [ self :: POS_LOAD ] ) . "\n});" ; $ lines [ ] = Html :: script ( $ js ) ; } } return empty ( $ lines ) ? '' : implode ( "\n" , $ lines ) ; }
186	protected function renderStrike ( $ element ) { return Console :: ansiFormat ( $ this -> parseInline ( $ this -> renderAbsy ( $ element [ 1 ] ) ) , [ Console :: CROSSED_OUT ] ) ; }
4199	public function addConstants ( Event $ abs ) { if ( ! $ this -> abstracter -> getCfg ( 'collectConstants' ) ) { return ; } $ reflector = $ abs [ 'reflector' ] ; $ constants = $ reflector -> getConstants ( ) ; while ( $ reflector = $ reflector -> getParentClass ( ) ) { $ constants = \ array_merge ( $ reflector -> getConstants ( ) , $ constants ) ; } if ( $ this -> abstracter -> getCfg ( 'objectSort' ) == 'name' ) { \ ksort ( $ constants ) ; } $ abs [ 'constants' ] = $ constants ; }
3991	public function acceptsAnotherChild ( ModelInterface $ model , ModelCollector $ collector ) { $ conditionType = $ model -> getProperty ( 'type' ) ; if ( ! $ this -> conditionFactory -> supportsNesting ( $ conditionType ) ) { return false ; } if ( - 1 === ( $ max = $ this -> conditionFactory -> maxChildren ( $ conditionType ) ) ) { return true ; } return \ count ( $ collector -> collectDirectChildrenOf ( $ model ) ) < $ max ; }
12201	public function mediaAction ( Request $ request , Application $ app ) { $ options = array ( "connector" => $ app [ "red_kite_cms.elfinder_media_connector" ] , ) ; return parent :: show ( $ options ) ; }
5183	public function article ( string $ singleJsonArticle ) : Article { if ( json_decode ( $ singleJsonArticle , true ) ) { $ dataArticle = json_decode ( $ singleJsonArticle , true ) [ 'data' ] ; $ article = new Article ( $ this -> filterString ( $ this -> getValue ( 'title' , $ dataArticle ) ) , $ this -> filterString ( $ this -> getValue ( 'body' , $ dataArticle ) ) , $ this -> filterString ( $ this -> getValue ( 'source' , $ dataArticle ) ) , $ this -> getValue ( 'unique_id' , $ dataArticle ) , $ this -> filterInteger ( $ this -> getValue ( 'type_id' , $ dataArticle [ 'type' ] ) ) , $ this -> filterInteger ( $ this -> getValue ( 'category_id' , $ dataArticle [ 'category' ] ) ) , $ this -> getValue ( 'reporter' , $ dataArticle ) , $ this -> filterString ( $ this -> getValue ( 'lead' , $ dataArticle ) ) , $ this -> getValue ( 'tag_name' , $ dataArticle [ 'tags' ] ) , $ this -> filterString ( $ this -> getValue ( 'published_at' , $ dataArticle ) ) , ( string ) $ this -> filterInteger ( $ this -> getValue ( 'id' , $ dataArticle ) ) ) ; $ attachmentConstants = [ Article :: ATTACHMENT_FIELD_PHOTO , Article :: ATTACHMENT_FIELD_PAGE , Article :: ATTACHMENT_FIELD_GALLERY , Article :: ATTACHMENT_FIELD_VIDEO , ] ; $ attachmentTypes = [ self :: JSON_PHOTO_FIELD , self :: JSON_PAGE_FIELD , self :: JSON_GALLERY_FIELD , self :: JSON_VIDEO_FIELD , ] ; $ attachmentAttributes = $ this -> lookUp ( $ attachmentConstants ) ; return $ this -> generalAttachment ( $ article , $ attachmentConstants , $ attachmentTypes , $ attachmentAttributes , $ dataArticle ) ; } throw new \ Exception ( 'Empty or invalid JSON Response' , 1 ) ; }
1073	private function getSuggestedFieldNames ( Schema $ schema , $ type , $ fieldName ) { if ( $ type instanceof ObjectType || $ type instanceof InterfaceType ) { $ possibleFieldNames = array_keys ( $ type -> getFields ( ) ) ; return Utils :: suggestionList ( $ fieldName , $ possibleFieldNames ) ; } return [ ] ; }
10447	public function post ( Payload $ payload , $ endpoint ) { if ( ! Type :: isValidWebhookType ( $ payload -> getAction ( ) ) ) { throw new \ Exception ( sprintf ( 'Webhook "%s" isn\'t valid' , $ payload -> getAction ( ) ) ) ; } $ requestContent = [ 'headers' => [ 'Content-Type' => 'application/json' ] , 'body' => json_encode ( $ payload ) , 'timeout' => self :: DEFAULT_REQUEST_TIMEOUT ] ; return $ this -> guzzleClient -> post ( $ endpoint , $ requestContent ) ; }
8620	public function parse ( ) { $ handle = fopen ( $ this -> source_file , 'r' ) ; $ currentBlock = null ; while ( ! feof ( $ handle ) ) { $ line = fgets ( $ handle ) ; if ( preg_match ( "/^msgid (.*?)$/us" , $ line , $ match ) ) { $ currentBlock = $ match [ 1 ] == '""' ? new HeaderBlock ( ) : new Block ( ) ; rewind ( $ handle ) ; break ; } } while ( ! feof ( $ handle ) ) { $ line = fgets ( $ handle ) ; if ( trim ( $ line ) == '' ) { if ( $ currentBlock ) { $ this -> addBlock ( $ currentBlock ) ; $ currentBlock = new Block ( ) ; } } else { $ currentBlock -> process ( $ line ) ; } } fclose ( $ handle ) ; if ( $ currentBlock && $ currentBlock -> isInitialized ( ) ) { $ this -> addBlock ( $ currentBlock ) ; } }
4322	public static function buildAttribString ( $ attribs ) { if ( \ is_string ( $ attribs ) ) { return \ rtrim ( ' ' . \ trim ( $ attribs ) ) ; } $ attribPairs = array ( ) ; foreach ( $ attribs as $ k => $ v ) { if ( \ is_int ( $ k ) ) { $ k = $ v ; $ v = true ; } $ k = \ strtolower ( $ k ) ; if ( \ strpos ( $ k , 'data-' ) === 0 ) { $ v = \ json_encode ( $ v ) ; $ v = \ trim ( $ v , '"' ) ; } elseif ( \ is_bool ( $ v ) ) { $ v = self :: buildAttribBoolVal ( $ k , $ v ) ; } elseif ( \ is_array ( $ v ) || $ k === 'class' ) { $ v = self :: buildAttribArrayVal ( $ k , $ v ) ; } if ( \ array_filter ( array ( $ v === null , $ v === '' && \ in_array ( $ k , array ( 'class' , 'style' ) ) ) ) ) { continue ; } $ v = \ trim ( $ v ) ; $ attribPairs [ ] = $ k . '="' . \ htmlspecialchars ( $ v ) . '"' ; } \ sort ( $ attribPairs ) ; return \ rtrim ( ' ' . \ implode ( ' ' , $ attribPairs ) ) ; }
3648	protected function registerBinput ( ) { $ this -> app -> singleton ( 'binput' , function ( Container $ app ) { $ request = $ app [ 'request' ] ; $ security = $ app [ 'security' ] ; $ binput = new Binput ( $ request , $ security ) ; $ app -> refresh ( 'request' , $ binput , 'setRequest' ) ; return $ binput ; } ) ; $ this -> app -> alias ( 'binput' , Binput :: class ) ; }
6926	protected function didStateChangeTo ( $ resource , $ state ) { if ( empty ( $ stateCs = $ this -> tracker -> getChangeSet ( $ resource , 'state' ) ) ) { return false ; } if ( $ stateCs [ 1 ] === $ state && $ stateCs [ 0 ] !== $ state ) { return true ; } return false ; }
12702	public function get ( $ id ) { if ( isset ( $ this -> singletons [ $ id ] ) ) { return $ this -> singletons [ $ id ] ; } $ methodName = 'get' . Util :: mapIdToCamelCase ( $ id ) ; if ( method_exists ( $ this , $ methodName ) ) { return $ this -> $ methodName ( ) ; } throw new \ InvalidArgumentException ( "Unknown service '$id' in container '" . get_called_class ( ) . "'" ) ; }
9675	public function allFills ( Spreadsheet $ spreadsheet ) { $ aFills = [ ] ; $ fill0 = new Fill ( ) ; $ fill0 -> setFillType ( Fill :: FILL_NONE ) ; $ aFills [ ] = $ fill0 ; $ fill1 = new Fill ( ) ; $ fill1 -> setFillType ( Fill :: FILL_PATTERN_GRAY125 ) ; $ aFills [ ] = $ fill1 ; $ aStyles = $ this -> allStyles ( $ spreadsheet ) ; foreach ( $ aStyles as $ style ) { if ( ! isset ( $ aFills [ $ style -> getFill ( ) -> getHashCode ( ) ] ) ) { $ aFills [ $ style -> getFill ( ) -> getHashCode ( ) ] = $ style -> getFill ( ) ; } } return $ aFills ; }
4222	public function get ( $ key = null ) { if ( $ key == 'lastError' ) { return isset ( $ this -> data [ 'lastError' ] ) ? $ this -> data [ 'lastError' ] -> getValues ( ) : null ; } if ( isset ( $ this -> data [ $ key ] ) ) { return $ this -> data [ $ key ] ; } if ( isset ( $ this -> { $ key } ) ) { return $ this -> { $ key } ; } return null ; }
9516	public function settings ( $ name = null , $ value = null ) { switch ( func_num_args ( ) ) { case 0 : return $ this -> info ( 'settings' ) ; break ; case 1 : return $ this -> info ( 'settings' , func_get_arg ( 0 ) ) ; break ; case 2 : $ update = false ; list ( $ name , $ value ) = func_get_args ( ) ; $ current = $ this -> info ( 'settings' , $ name ) ; if ( is_null ( $ value ) ) { if ( ! is_null ( $ current ) ) { unset ( $ this -> info [ 'settings' ] [ $ name ] ) ; $ update = true ; } } elseif ( $ current !== $ value ) { $ this -> info [ 'settings' ] [ $ name ] = $ value ; $ update = true ; } if ( $ update ) { $ this -> exec ( 'UPDATE config SET settings = ?' , serialize ( $ this -> info [ 'settings' ] ) ) ; } break ; } }
6449	private function compareAcceptLanguageHeaders ( AcceptLanguageHeaderValue $ a , AcceptLanguageHeaderValue $ b ) : int { $ aQuality = $ a -> getQuality ( ) ; $ bQuality = $ b -> getQuality ( ) ; if ( $ aQuality < $ bQuality ) { return 1 ; } if ( $ aQuality > $ bQuality ) { return - 1 ; } $ aValue = $ a -> getLanguage ( ) ; $ bValue = $ b -> getLanguage ( ) ; if ( $ aValue === '*' ) { if ( $ bValue === '*' ) { return 0 ; } return 1 ; } if ( $ bValue === '*' ) { return - 1 ; } return 0 ; }
1592	protected function validateResource ( ) : bool { $ identifier = $ this -> validateTypeAndId ( ) ; $ attributes = $ this -> validateAttributes ( ) ; $ relationships = $ this -> validateRelationships ( ) ; if ( $ attributes && $ relationships ) { return $ this -> validateAllFields ( ) && $ identifier ; } return $ identifier && $ attributes && $ relationships ; }
4646	public function compute ( ) { $ dimensions = $ this -> dimensions ; if ( empty ( $ dimensions ) ) { return array ( ) ; } $ values = reset ( $ dimensions ) ; $ name = key ( $ dimensions ) ; unset ( $ dimensions [ $ name ] ) ; $ posibilities = array ( ) ; foreach ( $ values as $ v ) { $ posibilities [ ] = array ( $ name => $ v ) ; } if ( empty ( $ dimensions ) ) { return $ posibilities ; } $ matrix = new Matrix ( ) ; foreach ( $ dimensions as $ name => $ values ) { $ matrix -> setDimension ( $ name , $ values ) ; } $ result = $ matrix -> compute ( ) ; $ newResult = array ( ) ; foreach ( $ result as $ value ) { foreach ( $ posibilities as $ possiblity ) { $ newResult [ ] = $ value + $ possiblity ; } } return $ newResult ; }
1310	public static function categoriesMenu ( $ categories ) { $ menu = '<ul class="nav nav-pills nav-stacked">' ; foreach ( $ categories as $ category ) { $ menu .= '<li>' ; $ menu .= '<a href="/' . config ( 'chatter.routes.home' ) . '/' . config ( 'chatter.routes.category' ) . '/' . $ category [ 'slug' ] . '">' ; $ menu .= '<div class="chatter-box" style="background-color:' . $ category [ 'color' ] . '"></div>' ; $ menu .= $ category [ 'name' ] . '</a>' ; if ( count ( $ category [ 'parents' ] ) ) { $ menu .= static :: categoriesMenu ( $ category [ 'parents' ] ) ; } $ menu .= '</li>' ; } $ menu .= '</ul>' ; return $ menu ; }
10126	private function writeGuts ( ) { $ record = 0x0080 ; $ length = 0x0008 ; $ dxRwGut = 0x0000 ; $ dxColGut = 0x0000 ; $ maxRowOutlineLevel = 0 ; foreach ( $ this -> phpSheet -> getRowDimensions ( ) as $ rowDimension ) { $ maxRowOutlineLevel = max ( $ maxRowOutlineLevel , $ rowDimension -> getOutlineLevel ( ) ) ; } $ col_level = 0 ; $ colcount = count ( $ this -> columnInfo ) ; for ( $ i = 0 ; $ i < $ colcount ; ++ $ i ) { $ col_level = max ( $ this -> columnInfo [ $ i ] [ 5 ] , $ col_level ) ; } $ col_level = max ( 0 , min ( $ col_level , 7 ) ) ; if ( $ maxRowOutlineLevel ) { ++ $ maxRowOutlineLevel ; } if ( $ col_level ) { ++ $ col_level ; } $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vvvv' , $ dxRwGut , $ dxColGut , $ maxRowOutlineLevel , $ col_level ) ; $ this -> append ( $ header . $ data ) ; }
11297	protected function _getModelsFromTableColumn ( $ attributeName , $ objName , $ relationColumnName , $ query = false , $ loadMap = false ) { $ relatedObj = $ this -> fetchRelatedObj ( $ objName ) ; $ idField = $ relatedObj -> getPrimaryKey ( ) ; $ repo = \ Cora \ RepositoryFactory :: make ( $ objName , false , false , false , $ this -> model_db ) ; if ( ! $ query ) $ query = $ this -> _getQueryObjectForRelation ( $ attributeName ) ; $ query -> where ( $ relationColumnName , $ this -> { $ this -> getPrimaryKey ( ) } ) ; return $ repo -> findAll ( $ query , false , $ loadMap ) ; }
1931	public function attachFileFromString ( $ strContent , $ strFilename , $ strMime = 'application/octet-stream' ) { $ this -> objMessage -> attach ( new \ Swift_Attachment ( $ strContent , $ strFilename , $ strMime ) ) ; }
8301	public function handleAccountPage ( Request $ httpRequest ) { if ( ! $ this -> config [ "enabled" ] ) { return ; } $ user = $ this -> picoAuth -> getUser ( ) ; $ this -> picoAuth -> addAllowed ( "account" ) ; $ this -> picoAuth -> setRequestFile ( $ this -> picoAuth -> getPluginPath ( ) . '/content/account.md' ) ; $ post = $ httpRequest -> request ; if ( $ post -> has ( "new_password" ) && $ post -> has ( "new_password_repeat" ) && $ post -> has ( "old_password" ) ) { $ newPassword = new Password ( $ post -> get ( "new_password" ) ) ; $ newPasswordRepeat = new Password ( $ post -> get ( "new_password_repeat" ) ) ; $ oldPassword = new Password ( $ post -> get ( "old_password" ) ) ; $ username = $ user -> getId ( ) ; if ( ! $ this -> picoAuth -> isValidCSRF ( $ post -> get ( "csrf_token" ) ) ) { $ this -> picoAuth -> redirectToPage ( "account" ) ; } if ( $ newPassword -> get ( ) !== $ newPasswordRepeat -> get ( ) ) { $ this -> session -> addFlash ( "error" , "The passwords do not match." ) ; $ this -> picoAuth -> redirectToPage ( "account" ) ; } $ localAuth = $ this -> picoAuth -> getContainer ( ) -> get ( 'LocalAuth' ) ; if ( ! $ localAuth -> loginAttempt ( $ username , $ oldPassword ) ) { $ this -> session -> addFlash ( "error" , "The current password is incorrect" ) ; $ this -> picoAuth -> redirectToPage ( "account" ) ; } if ( ! $ localAuth -> checkPasswordPolicy ( $ newPassword ) ) { $ this -> picoAuth -> redirectToPage ( "account" ) ; } $ userData = $ this -> storage -> getUserByName ( $ username ) ; $ localAuth -> userDataEncodePassword ( $ userData , $ newPassword ) ; $ this -> storage -> saveUser ( $ username , $ userData ) ; $ this -> session -> addFlash ( "success" , "Password changed successfully." ) ; $ this -> picoAuth -> redirectToPage ( "account" ) ; } }
1362	public function accept ( AcceptMediaTypeInterface $ mediaType ) : bool { if ( 0 === $ mediaType -> getQuality ( ) ) { return false ; } return $ this -> matchesTo ( $ mediaType ) ; }
10698	public static function isPasswd ( $ passwd , $ size = Validate :: PASSWORD_LENGTH ) { return self :: getPasswordComplexity ( $ passwd , $ size ) >= self :: PASSWORD_COMPLEXITY_MEDIUM ; }
11948	public function getSignature ( $ baseString , array $ params ) { unset ( $ params [ 'oauth_signature' ] ) ; if ( $ this -> signature_method === 'HMAC-SHA1' ) { $ result = $ this -> sign_HMAC_SHA1 ( $ baseString ) ; } else if ( $ this -> signature_method == 'RSA-SHA1' ) { $ result = $ this -> sign_RSA_SHA1 ( $ baseString ) ; } else if ( $ this -> signature_method == 'PLAINTEXT' ) { $ result = $ this -> sign_PLAINTEXT ( $ baseString ) ; } else { throw new ArtaxServiceException ( 'Unknown signature method: ' . $ this -> signature_method ) ; } return base64_encode ( $ result ) ; }
2618	public function getSiteLocation ( ) { $ countryId = $ this -> scopeConfig -> getValue ( 'general/store_information/country_id' ) ; if ( $ countryId ) { $ country = $ this -> countryFactory -> create ( ) -> loadByCode ( $ countryId ) ; $ countryName = $ country -> getName ( ) ; } else { $ countryName = 'Unknown country' ; } $ regionId = $ this -> scopeConfig -> getValue ( 'general/store_information/region_id' ) ; $ regionName = 'Unknown region' ; if ( $ regionId ) { $ region = $ this -> regionFactory -> create ( ) ; $ region = $ region -> load ( $ regionId ) ; if ( $ region -> getId ( ) ) { $ regionName = $ region -> getName ( ) ; } } $ postCode = $ this -> scopeConfig -> getValue ( 'general/store_information/postcode' ) ; if ( ! $ postCode ) { $ postCode = 'Unknown zip code' ; } return $ countryName . ' | ' . $ regionName . ' | ' . $ postCode ; }
4869	public function createService ( ServiceLocatorInterface $ serviceLocator ) { $ helper = new DateFormat ( ) ; $ helper -> setLocale ( Locale :: DEFAULT_LOCALE ) ; return $ helper ; }
3313	protected function appendAppIdAndBucketIfEmpty ( array $ options = [ ] ) { $ options [ 'appid' ] = empty ( $ options [ 'appid' ] ) ? $ this -> authorization -> getAppId ( ) : $ options [ 'appid' ] ; $ options [ 'bucket' ] = empty ( $ options [ 'bucket' ] ) ? $ this -> authorization -> getBucket ( ) : $ options [ 'bucket' ] ; return $ options ; }
4671	public function addBlockToBody ( $ block ) { $ this -> body = array_merge ( $ this -> body , explode ( PHP_EOL , $ block ) ) ; }
3582	protected function metaSelectListsKey ( Builder $ query , $ key ) { if ( strpos ( $ key , '.' ) !== false ) { return $ query -> addSelect ( $ key ) ; } elseif ( $ this -> hasColumn ( $ key ) ) { return $ query -> addSelect ( $ this -> getTable ( ) . '.' . $ key ) ; } $ alias = $ this -> joinMeta ( $ query , $ key ) ; return $ query -> addSelect ( "{$alias}.meta_value as {$key}" ) ; }
8673	private function iterateReverseFromIndex ( $ fromIndex ) { Assert :: nullOrInteger ( $ fromIndex ) ; $ index = count ( $ this -> items ) ; if ( $ index === 0 ) { return ; } if ( $ fromIndex !== null ) { $ index = $ fromIndex < 0 ? max ( $ index + $ fromIndex , 1 ) : min ( $ fromIndex + 1 , $ index ) ; } $ keys = array_keys ( $ this -> items ) ; while ( -- $ index >= 0 ) { $ key = $ keys [ $ index ] ; yield $ key => $ this -> items [ $ key ] ; } }
4325	public static function getCallerInfo ( $ offset = 0 ) { $ return = array ( 'file' => null , 'line' => null , 'function' => null , 'class' => null , 'type' => null , ) ; $ backtrace = \ debug_backtrace ( DEBUG_BACKTRACE_IGNORE_ARGS | DEBUG_BACKTRACE_PROVIDE_OBJECT , 8 ) ; $ numFrames = \ count ( $ backtrace ) ; $ regexInternal = '/^' . \ preg_quote ( __NAMESPACE__ ) . '\b/' ; if ( isset ( $ backtrace [ 1 ] [ 'class' ] ) && \ preg_match ( $ regexInternal , $ backtrace [ 1 ] [ 'class' ] ) ) { for ( $ i = $ numFrames - 1 ; $ i >= 0 ; $ i -- ) { if ( isset ( $ backtrace [ $ i ] [ 'class' ] ) && \ preg_match ( $ regexInternal , $ backtrace [ $ i ] [ 'class' ] ) ) { break ; } } } else { $ i = 1 ; } $ i += $ offset ; $ iLine = $ i ; $ iFunc = $ i + 1 ; if ( isset ( $ backtrace [ $ iFunc ] ) && \ in_array ( $ backtrace [ $ iFunc ] [ 'function' ] , array ( 'call_user_func' , 'call_user_func_array' ) ) ) { $ iLine ++ ; $ iFunc ++ ; } elseif ( isset ( $ backtrace [ $ iFunc ] [ 'class' ] ) && $ backtrace [ $ iFunc ] [ 'class' ] == 'ReflectionMethod' && $ backtrace [ $ iFunc ] [ 'function' ] == 'invoke' ) { $ iLine ++ ; $ iFunc -- ; } if ( isset ( $ backtrace [ $ iFunc ] ) ) { $ return = \ array_merge ( $ return , \ array_intersect_key ( $ backtrace [ $ iFunc ] , $ return ) ) ; if ( $ return [ 'type' ] == '->' ) { $ return [ 'class' ] = \ get_class ( $ backtrace [ $ iFunc ] [ 'object' ] ) ; } } if ( isset ( $ backtrace [ $ iLine ] ) ) { $ return [ 'file' ] = $ backtrace [ $ iLine ] [ 'file' ] ; $ return [ 'line' ] = $ backtrace [ $ iLine ] [ 'line' ] ; } else { $ return [ 'file' ] = $ backtrace [ $ numFrames - 1 ] [ 'file' ] ; $ return [ 'line' ] = 0 ; } return $ return ; }
9888	static function getPermission ( $ code ) { switch ( $ code ) { case 1 : return self :: $ NONE ; case "none" : return self :: $ NONE ; case 2 : return self :: $ SOI ; case "soi" : return self :: $ SOI ; case 3 : return self :: $ COI ; case "coi" : return self :: $ COI ; case 4 : return self :: $ DOI ; case "doi" : return self :: $ DOI ; case 5 : return self :: $ DOI_PLUS ; case "doi+" : return self :: $ DOI_PLUS ; case 6 : return self :: $ OTHER ; case "other" : return self :: $ OTHER ; default : return self :: $ OTHER ; } }
11086	public static function getOctets ( $ option ) { if ( preg_match ( '/\d+k/i' , $ option ) ) { return 1024 * ( int ) $ option ; } if ( preg_match ( '/\d+m/i' , $ option ) ) { return 1024 * 1024 * ( int ) $ option ; } if ( preg_match ( '/\d+g/i' , $ option ) ) { return 1024 * 1024 * 1024 * ( int ) $ option ; } return $ option ; }
983	public function process ( Plan $ plan ) { $ shop = ShopifyApp :: shop ( ) ; $ bp = new BillingPlan ( $ shop , $ plan ) ; $ bp -> setChargeId ( Request :: query ( 'charge_id' ) ) ; $ bp -> activate ( ) ; $ bp -> save ( ) ; $ shop -> update ( [ 'freemium' => false , 'plan_id' => $ plan -> id , ] ) ; return Redirect :: route ( 'home' ) -> with ( 'success' , 'billing' ) ; }
2078	public function purgePageCache ( ) { $ strCacheDir = StringUtil :: stripRootDir ( System :: getContainer ( ) -> getParameter ( 'kernel.cache_dir' ) ) ; $ objFolder = new Folder ( $ strCacheDir . '/http_cache' ) ; $ objFolder -> purge ( ) ; $ this -> log ( 'Purged the page cache' , __METHOD__ , TL_CRON ) ; }
2770	public function getRemoteUrl ( string $ remote , string $ operation = 'fetch' ) : string { $ argsAndOptions = [ 'get-url' , $ remote ] ; if ( $ operation === 'push' ) { $ argsAndOptions [ ] = '--push' ; } return rtrim ( $ this -> remote ( ... $ argsAndOptions ) ) ; }
7578	protected function configureData ( $ data ) { if ( ! empty ( $ this -> _REQUIRED_DATA ) && is_array ( $ data ) ) { $ data = $ this -> configureDefaultData ( $ data ) ; } $ this -> setData ( $ data ) ; }
313	public function setRuntimePath ( $ path ) { $ this -> _runtimePath = Yii :: getAlias ( $ path ) ; Yii :: setAlias ( '@runtime' , $ this -> _runtimePath ) ; }
7563	protected function parse_not ( ) { if ( ( ( $ this -> pos + 1 ) < $ this -> size ) && ( $ this -> doc [ $ this -> pos + 1 ] === '=' ) ) { ++ $ this -> pos ; return ( $ this -> token = self :: TOK_COMPARE_NOT_EQUAL ) ; } else { return ( $ this -> token = self :: TOK_NOT ) ; } }
1896	private function purgeOldFiles ( string $ webDir ) : void { if ( file_exists ( $ webDir . '/app_dev.php' ) ) { $ this -> fs -> remove ( $ webDir . '/app_dev.php' ) ; $ this -> io -> writeln ( 'Deleted the <comment>web/app_dev.php</comment> file.' ) ; } if ( file_exists ( $ webDir . '/install.php' ) ) { $ this -> fs -> remove ( $ webDir . '/install.php' ) ; $ this -> io -> writeln ( 'Deleted the <comment>web/install.php</comment> file.' ) ; } }
10553	public static function findVirtualHost ( URL $ url , array $ sites ) { foreach ( $ sites as $ site ) { $ vhost = $ site -> match ( $ url ) ; if ( $ vhost !== null ) return $ vhost ; } return null ; }
3476	protected function request ( $ verb , $ endpoint , array $ data ) { $ url = rtrim ( $ this -> baseUrl , '/' ) . '/' . ltrim ( $ endpoint , '/' ) ; try { $ response = $ this -> httpClient -> request ( $ verb , $ url , [ 'headers' => [ 'Authorization' => 'Bot ' . $ this -> token , ] , 'json' => $ data , ] ) ; } catch ( RequestException $ exception ) { if ( $ response = $ exception -> getResponse ( ) ) { throw CouldNotSendNotification :: serviceRespondedWithAnHttpError ( $ response ) ; } throw CouldNotSendNotification :: serviceCommunicationError ( $ exception ) ; } catch ( Exception $ exception ) { throw CouldNotSendNotification :: serviceCommunicationError ( $ exception ) ; } $ body = json_decode ( $ response -> getBody ( ) , true ) ; if ( Arr :: get ( $ body , 'code' , 0 ) > 0 ) { throw CouldNotSendNotification :: serviceRespondedWithAnApiError ( $ body ) ; } return $ body ; }
9676	public function allFonts ( Spreadsheet $ spreadsheet ) { $ aFonts = [ ] ; $ aStyles = $ this -> allStyles ( $ spreadsheet ) ; foreach ( $ aStyles as $ style ) { if ( ! isset ( $ aFonts [ $ style -> getFont ( ) -> getHashCode ( ) ] ) ) { $ aFonts [ $ style -> getFont ( ) -> getHashCode ( ) ] = $ style -> getFont ( ) ; } } return $ aFonts ; }
2440	public function urlEncode ( ) : string { $ data = json_encode ( $ this ) ; if ( \ function_exists ( 'gzencode' ) && false !== ( $ encoded = @ gzencode ( $ data ) ) ) { $ data = $ encoded ; } return strtr ( base64_encode ( $ data ) , '+/=' , '-_,' ) ; }
7111	static public function isValidReason ( $ reason , $ throw = true ) { if ( in_array ( $ reason , static :: getReasons ( ) , true ) ) { return true ; } if ( $ throw ) { throw new InvalidArgumentException ( "Invalid stock adjustment reason." ) ; } return false ; }
138	public function update ( RepositoryInterface $ repo , UpdateOperation $ operation ) { $ initial = $ operation -> getInitialPackage ( ) ; $ target = $ operation -> getTargetPackage ( ) ; $ initialType = $ initial -> getType ( ) ; $ targetType = $ target -> getType ( ) ; if ( $ initialType === $ targetType ) { $ installer = $ this -> getInstaller ( $ initialType ) ; $ installer -> update ( $ repo , $ initial , $ target ) ; $ this -> markForNotification ( $ target ) ; } else { $ this -> getInstaller ( $ initialType ) -> uninstall ( $ repo , $ initial ) ; $ this -> getInstaller ( $ targetType ) -> install ( $ repo , $ target ) ; } }
9524	public function deploy ( ) { $ pullRequest = getenv ( 'TRAVIS_PULL_REQUEST' ) ; $ branch = getenv ( 'TRAVIS_BRANCH' ) ; if ( ( int ) $ pullRequest >= 1 ) { die ( 'Not deploying pull requests.' . PHP_EOL ) ; } if ( ! array_key_exists ( $ branch , $ this -> branches ) ) { die ( 'Branch ' . $ branch . ' has no environment to deploy to.' . PHP_EOL ) ; } $ environment = $ this -> branches [ $ branch ] ; echo 'Downloading Deployer.phar...' . PHP_EOL ; passthru ( 'wget http://deployer.org/deployer.phar' ) ; echo 'Deploying...' . PHP_EOL ; $ deployCommand = 'php deployer.phar deploy' ; $ deployCommand .= ' ' . $ environment ; $ deployCommand .= $ this -> verbose ? ' -vvv' : '' ; passthru ( $ deployCommand ) ; }
10012	public function getSheet ( $ pIndex ) { if ( ! isset ( $ this -> workSheetCollection [ $ pIndex ] ) ) { $ numSheets = $ this -> getSheetCount ( ) ; throw new Exception ( "Your requested sheet index: {$pIndex} is out of bounds. The actual number of sheets is {$numSheets}." ) ; } return $ this -> workSheetCollection [ $ pIndex ] ; }
5500	protected function replaceWildcards ( $ args ) { if ( $ args === false ) { return false ; } for ( $ i = 0 ; $ i < count ( $ args ) ; $ i ++ ) { if ( $ args [ $ i ] === $ this -> wildcard ) { $ args [ $ i ] = new AnythingExpectation ( ) ; } } return $ args ; }
2620	public function sendInstalledReq ( ) { $ pageViewParams = [ 'dl' => self :: GA_PAGEVIEW_URL . self :: FASTLY_INSTALLED_FLAG , 'dh' => preg_replace ( '#^https?://#' , '' , rtrim ( self :: GA_PAGEVIEW_URL , '/' ) ) , 'dp' => '/' . self :: FASTLY_INSTALLED_FLAG , 'dt' => ucfirst ( self :: FASTLY_INSTALLED_FLAG ) , 't' => self :: GA_HITTYPE_PAGEVIEW , ] ; $ this -> sendReqToGA ( $ pageViewParams , self :: GA_HITTYPE_PAGEVIEW ) ; $ eventParams = [ 'ec' => self :: GA_FASTLY_SETUP , 'ea' => 'Fastly ' . self :: FASTLY_INSTALLED_FLAG , 'el' => $ this -> getWebsiteName ( ) , 'ev' => 0 , 't' => self :: GA_HITTYPE_EVENT ] ; $ result = $ this -> sendReqToGA ( array_merge ( $ pageViewParams , $ eventParams ) ) ; return $ result ; }
8723	public function translateOrNew ( $ locale ) { if ( is_null ( $ instance = $ this -> translate ( $ locale ) ) ) { return $ this -> newModelInstance ( ) ; } return $ instance ; }
5833	protected function headerToArray ( $ header ) { $ tmp = explode ( "\r\n" , $ header ) ; $ headers = array ( ) ; foreach ( $ tmp as $ singleHeader ) { $ delimiter = strpos ( $ singleHeader , ': ' ) ; if ( $ delimiter !== false ) { $ key = substr ( $ singleHeader , 0 , $ delimiter ) ; $ val = substr ( $ singleHeader , $ delimiter + 2 ) ; $ headers [ $ key ] = $ val ; } else { $ delimiter = strpos ( $ singleHeader , ' ' ) ; if ( $ delimiter !== false ) { $ key = substr ( $ singleHeader , 0 , $ delimiter ) ; $ val = substr ( $ singleHeader , $ delimiter + 1 ) ; $ headers [ $ key ] = $ val ; } } } return $ headers ; }
5521	public static function generate ( $ class , $ mock_class = false , $ methods = false ) { $ generator = new MockGenerator ( $ class , $ mock_class ) ; return $ generator -> generateSubclass ( $ methods ) ; }
6090	public function addMediaToMoodboard ( $ moodboardId , array $ mediaIds ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'mediaIds' => $ mediaIds ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/moodboards/' . $ moodboardId . '/media' , $ parameters ) ; return $ result ; }
8296	public function write ( $ data ) { if ( ! is_string ( $ data ) ) { throw new \ InvalidArgumentException ( "The data is not a string." ) ; } $ this -> open ( ) ; if ( ! ftruncate ( $ this -> handle , 0 ) ) { $ this -> writeErrors = true ; throw new \ RuntimeException ( "Could not truncate file " . $ this -> filePath ) ; } fseek ( $ this -> handle , 0 ) ; $ res = fwrite ( $ this -> handle , $ data ) ; if ( strlen ( $ data ) !== $ res ) { $ this -> writeErrors = true ; throw new \ RuntimeException ( "Could not write to file " . $ this -> filePath ) ; } }
943	private function computeConfigFiles ( ) { $ configFile = $ this -> options [ 'config' ] ; if ( null !== $ configFile ) { if ( false === file_exists ( $ configFile ) || false === is_readable ( $ configFile ) ) { throw new InvalidConfigurationException ( sprintf ( 'Cannot read config file "%s".' , $ configFile ) ) ; } return [ $ configFile ] ; } $ path = $ this -> getPath ( ) ; if ( $ this -> isStdIn ( ) || 0 === \ count ( $ path ) ) { $ configDir = $ this -> cwd ; } elseif ( 1 < \ count ( $ path ) ) { throw new InvalidConfigurationException ( 'For multiple paths config parameter is required.' ) ; } elseif ( is_file ( $ path [ 0 ] ) && $ dirName = pathinfo ( $ path [ 0 ] , PATHINFO_DIRNAME ) ) { $ configDir = $ dirName ; } else { $ configDir = $ path [ 0 ] ; } $ candidates = [ $ configDir . \ DIRECTORY_SEPARATOR . '.php_cs' , $ configDir . \ DIRECTORY_SEPARATOR . '.php_cs.dist' , ] ; if ( $ configDir !== $ this -> cwd ) { $ candidates [ ] = $ this -> cwd . \ DIRECTORY_SEPARATOR . '.php_cs' ; $ candidates [ ] = $ this -> cwd . \ DIRECTORY_SEPARATOR . '.php_cs.dist' ; } return $ candidates ; }
9427	public function render ( $ template , array $ data = array ( ) , $ extension = 'twig' ) { $ file = $ template . '.' . $ extension ; return $ this -> twig -> render ( $ file , $ data ) ; }
8247	public function userDataEncodePassword ( & $ userData , Password $ newPassword ) { $ encoderName = $ this -> config [ "encoder" ] ; $ encoder = $ this -> picoAuth -> getContainer ( ) -> get ( $ encoderName ) ; $ userData [ 'pwhash' ] = $ encoder -> encode ( $ newPassword -> get ( ) ) ; $ userData [ 'encoder' ] = $ encoderName ; if ( isset ( $ userData [ 'pwreset' ] ) ) { unset ( $ userData [ 'pwreset' ] ) ; } }
3916	protected function sortByIdList ( $ sortIds ) { $ fileMap = $ this -> foundFiles ; if ( ! $ fileMap ) { return array ( 'files' => array ( ) , 'source' => array ( ) ) ; } $ fileKeys = array_flip ( array_keys ( $ this -> uuidMap ) ) ; $ sorted = array ( ) ; foreach ( $ sortIds as $ sortStringId ) { $ key = $ fileKeys [ $ sortStringId ] ; $ sorted [ $ key ] = $ fileMap [ $ key ] ; unset ( $ fileMap [ $ key ] ) ; } $ sorted += $ fileMap ; return $ this -> remapSorting ( $ sorted , $ this -> outputBuffer ) ; }
9778	function writable ( ) : self { if ( ! $ this -> hasFlag ( 'directory' ) && ! $ this -> hasFlag ( 'file' ) ) throw new \ BadMethodCallException ( 'This assertion is not a file or directory one.' ) ; return $ this -> expect ( $ this -> target , isWritable ( ) ) ; }
4932	public function renderJSON ( MvcEvent $ event ) { if ( ! $ this -> hasRunned ) { $ valueToPlainStati = array ( 1 => 'error' , 2 => 'error' , 3 => 'error' , 4 => 'error' , 5 => 'success' , 6 => 'info' , 7 => 'info' ) ; $ viewModel = $ event -> getViewModel ( ) ; if ( $ viewModel instanceof JsonModel ) { if ( ! empty ( $ this -> notifications ) ) { $ jsonNotifications = $ viewModel -> getVariable ( 'notifications' , array ( ) ) ; foreach ( $ this -> notifications as $ notification ) { $ status = 'info' ; if ( array_key_exists ( $ notification -> getPriority ( ) , $ valueToPlainStati ) ) { $ status = $ valueToPlainStati [ $ notification -> getPriority ( ) ] ; } $ jsonNotifications [ ] = array ( 'text' => $ notification -> getNotification ( ) , 'status' => $ status ) ; } $ viewModel -> setVariable ( 'notifications' , $ jsonNotifications ) ; } $ this -> hasRunned = true ; } } return ; }
3778	protected function getLabel ( ) { if ( null === ( $ attribute = $ this -> getFilteredAttribute ( ) ) ) { return null ; } if ( $ label = $ this -> get ( 'label' ) ) { return $ label ; } return $ attribute -> getName ( ) ; }
6529	public static function findOneUsingMixin ( $ mixin ) : Schema { $ schemas = self :: findAllUsingMixin ( $ mixin ) ; if ( 1 !== count ( $ schemas ) ) { throw new MoreThanOneMessageForMixin ( $ mixin , $ schemas ) ; } return current ( $ schemas ) ; }
7738	public function serialize ( $ entity ) { if ( ! $ this -> container -> has ( 'hydra.serializer' ) ) { throw new \ LogicException ( 'The HydraBundle is not registered in your application.' ) ; } return $ this -> container -> get ( 'hydra.serializer' ) -> serialize ( $ entity , self :: FORMAT ) ; }
6826	protected function getUnpaidAccountNumber ( CustomerGroupInterface $ group , string $ origin ) { foreach ( $ this -> accounts as $ account ) { if ( $ account -> getType ( ) !== AccountingTypes :: TYPE_UNPAID ) { continue ; } foreach ( $ account -> getCustomerGroups ( ) as $ g ) { if ( $ g -> getId ( ) === $ group -> getId ( ) ) { return $ account -> getNumber ( ) ; } } } foreach ( $ this -> accounts as $ account ) { if ( $ account -> getType ( ) !== AccountingTypes :: TYPE_UNPAID ) { continue ; } if ( 0 < $ account -> getCustomerGroups ( ) -> count ( ) ) { continue ; } return $ account -> getNumber ( ) ; } throw new LogicException ( sprintf ( "No unpaid account number configured for customer group '%s' (%s)" , $ group -> getName ( ) , $ origin ) ) ; }
5850	protected function buildForm ( array $ row ) { $ record = [ 'uid' => static :: virtualRecordId , 'pid' => 0 , ] ; $ record = array_merge ( $ record , $ row ) ; $ dataProviders = & $ GLOBALS [ 'TYPO3_CONF_VARS' ] [ 'SYS' ] [ 'formEngine' ] [ 'formDataGroup' ] [ 'tcaDatabaseRecord' ] ; $ dataProviders [ \ Causal \ ImageAutoresize \ Backend \ Form \ FormDataProvider \ VirtualDatabaseEditRow :: class ] = [ 'before' => [ \ TYPO3 \ CMS \ Backend \ Form \ FormDataProvider \ DatabaseEditRow :: class , ] ] ; \ Causal \ ImageAutoresize \ Backend \ Form \ FormDataProvider \ VirtualDatabaseEditRow :: initialize ( $ record ) ; $ formDataGroup = GeneralUtility :: makeInstance ( \ TYPO3 \ CMS \ Backend \ Form \ FormDataGroup \ TcaDatabaseRecord :: class ) ; $ formDataCompiler = GeneralUtility :: makeInstance ( \ TYPO3 \ CMS \ Backend \ Form \ FormDataCompiler :: class , $ formDataGroup ) ; $ nodeFactory = GeneralUtility :: makeInstance ( \ TYPO3 \ CMS \ Backend \ Form \ NodeFactory :: class ) ; $ formDataCompilerInput = [ 'tableName' => static :: virtualTable , 'vanillaUid' => $ record [ 'uid' ] , 'command' => 'edit' , 'returnUrl' => '' , ] ; $ this -> loadVirtualTca ( ) ; $ formData = $ formDataCompiler -> compile ( $ formDataCompilerInput ) ; $ formData [ 'renderType' ] = 'outerWrapContainer' ; $ formResult = $ nodeFactory -> create ( $ formData ) -> render ( ) ; $ html = preg_replace ( '/<h1>.*<\/h1>/' , '' , $ formResult [ 'html' ] ) ; $ startFooter = strrpos ( $ html , '<div class="help-block text-right">' ) ; $ endTag = '</div>' ; if ( $ startFooter !== false ) { $ endFooter = strpos ( $ html , $ endTag , $ startFooter ) ; $ html = substr ( $ html , 0 , $ startFooter ) . substr ( $ html , $ endFooter + strlen ( $ endTag ) ) ; } $ formResult [ 'html' ] = '' ; $ formResult [ 'doSaveFieldName' ] = 'doSave' ; $ this -> formResultCompiler -> mergeResult ( $ formResult ) ; $ formContent = ' <!-- EDITING FORM . $ html . ' <input type="hidden" name="returnUrl" value="' . htmlspecialchars ( $ this -> retUrl ) . '" /> <input type="hidden" name="closeDoc" value="0" /> <input type="hidden" name="doSave" value="0" /> <input type="hidden" name="_serialNumber" value="' . md5 ( microtime ( ) ) . '" /> <input type="hidden" name="_scrollPosition" value="" />' ; $ overriddenAjaxUrl = GeneralUtility :: quoteJSvalue ( BackendUtility :: getModuleUrl ( 'TxImageAutoresize::record_flex_container_add' ) ) ; $ formContent .= <<<HTML<script type="text/javascript"> TYPO3.settings.ajaxUrls['record_flex_container_add'] = $overriddenAjaxUrl;</script>HTML ; return $ formContent ; }
321	public function normalizePathInfo ( $ pathInfo , $ suffix , & $ normalized = false ) { if ( empty ( $ pathInfo ) ) { return $ pathInfo ; } $ sourcePathInfo = $ pathInfo ; if ( $ this -> collapseSlashes ) { $ pathInfo = $ this -> collapseSlashes ( $ pathInfo ) ; } if ( $ this -> normalizeTrailingSlash === true ) { $ pathInfo = $ this -> normalizeTrailingSlash ( $ pathInfo , $ suffix ) ; } $ normalized = $ sourcePathInfo !== $ pathInfo ; return $ pathInfo ; }
3151	protected function continueInteraction ( RunnerServiceContext $ context ) { $ continue = false ; $ session = $ context -> getTestSession ( ) ; if ( $ session -> isRunning ( ) === true && $ session -> isTimeout ( ) === false ) { $ event = new QtiContinueInteractionEvent ( $ context , $ this ) ; $ this -> getServiceManager ( ) -> get ( EventManager :: SERVICE_ID ) -> trigger ( $ event ) ; TestRunnerUtils :: beginCandidateInteraction ( $ session ) ; $ continue = true ; } else { $ this -> finish ( $ context ) ; } return $ continue ; }
2616	private function prepareCustomVariables ( ) { if ( $ this -> validationServiceId != null ) { $ serviceId = $ this -> validationServiceId ; } else { $ serviceId = $ this -> scopeConfig -> getValue ( Config :: XML_FASTLY_SERVICE_ID ) ; } $ customVars = [ 'cd1' => $ serviceId , 'cd2' => ( $ this -> isApiKeyValid ( ) ) ? 'yes' : 'no' , 'cd3' => $ this -> getWebsiteName ( ) , 'cd4' => $ this -> request -> getServer ( 'HTTP_HOST' ) , 'cd5' => $ this -> getSiteLocation ( ) , 'cd6' => $ this -> helper -> getModuleVersion ( ) , 'cd7' => $ this -> config -> getCID ( ) , 'cd8' => 'fastlyext' ] ; return $ customVars ; }
6420	public function stop ( ) : Stopwatch { $ tick = $ this -> ticker -> read ( ) ; Preconditions :: checkState ( $ this -> isRunning , 'This stopwatch is already stopped.' ) ; $ this -> isRunning = false ; $ this -> elapsedMicros += ( $ tick - $ this -> startTick ) ; return $ this ; }
10755	protected function buildTblOpt ( ) { $ result = [ ] ; foreach ( $ this -> tbl_option as $ opt ) { $ result [ ] = $ opt ; } if ( empty ( $ result ) ) { $ result [ ] = '' ; } return $ result ; }
1482	public function encoder ( $ options = 0 , $ depth = 512 ) { if ( $ options instanceof Encoding ) { $ options = $ options -> getOptions ( ) ; } if ( ! $ options instanceof EncoderOptions ) { $ options = new EncoderOptions ( $ options , $ this -> getUrl ( ) -> toString ( ) , $ depth ) ; } return $ this -> factory -> createEncoder ( $ this -> getContainer ( ) , $ options ) ; }
1892	public function accept ( ) { if ( strncmp ( $ this -> current ( ) -> getFilename ( ) , '.' , 1 ) === 0 ) { return false ; } $ strPath = $ this -> current ( ) -> getPathname ( ) ; if ( is_file ( $ strPath ) ) { $ strPath = \ dirname ( $ strPath ) ; } $ objFolder = new Folder ( StringUtil :: stripRootDir ( $ strPath ) ) ; return ! $ objFolder -> isUnsynchronized ( ) ; }
7548	function childCount ( $ ignore_text_comments = false ) { if ( ! $ ignore_text_comments ) { return count ( $ this -> children ) ; } else { $ count = 0 ; foreach ( array_keys ( $ this -> children ) as $ k ) { if ( ! $ this -> children [ $ k ] -> isTextOrComment ( ) ) { ++ $ count ; } } return $ count ; } }
10135	public function processBitmapGd ( $ image ) { $ width = imagesx ( $ image ) ; $ height = imagesy ( $ image ) ; $ data = pack ( 'Vvvvv' , 0x000c , $ width , $ height , 0x01 , 0x18 ) ; for ( $ j = $ height ; -- $ j ; ) { for ( $ i = 0 ; $ i < $ width ; ++ $ i ) { $ color = imagecolorsforindex ( $ image , imagecolorat ( $ image , $ i , $ j ) ) ; foreach ( [ 'red' , 'green' , 'blue' ] as $ key ) { $ color [ $ key ] = $ color [ $ key ] + round ( ( 255 - $ color [ $ key ] ) * $ color [ 'alpha' ] / 127 ) ; } $ data .= chr ( $ color [ 'blue' ] ) . chr ( $ color [ 'green' ] ) . chr ( $ color [ 'red' ] ) ; } if ( 3 * $ width % 4 ) { $ data .= str_repeat ( "\x00" , 4 - 3 * $ width % 4 ) ; } } return [ $ width , $ height , strlen ( $ data ) , $ data ] ; }
458	public function dropCheck ( $ name , $ table ) { return 'ALTER TABLE ' . $ this -> db -> quoteTableName ( $ table ) . ' DROP CONSTRAINT ' . $ this -> db -> quoteColumnName ( $ name ) ; }
4609	protected function registerPlugin ( ) { $ view = $ this -> getView ( ) ; MultiSelectAsset :: register ( $ view ) ; $ id = $ this -> options [ 'id' ] ; $ options = $ this -> clientOptions !== false && ! empty ( $ this -> clientOptions ) ? Json :: encode ( $ this -> clientOptions ) : '' ; $ js = "jQuery('#$id').multiselect($options);" ; $ view -> registerJs ( $ js ) ; }
1524	protected function doRead ( StoreInterface $ store , FetchResource $ request ) { $ record = $ request -> getRecord ( ) ; if ( $ result = $ this -> invoke ( 'reading' , $ record , $ request ) ) { return $ result ; } $ record = $ store -> readRecord ( $ record , $ request -> getParameters ( ) ) ; if ( $ result = $ this -> invoke ( 'didRead' , $ record , $ request ) ) { return $ result ; } return $ record ; }
7444	public function createAction ( ) { $ group = new Group ( ) ; $ form = $ this -> createForm ( GroupType :: class , $ group ) ; $ form -> bindRequest ( $ this -> getRequest ( ) ) ; if ( $ form -> isValid ( ) ) { $ em = $ this -> getDoctrine ( ) -> getEntityManager ( ) ; $ em -> persist ( $ group ) ; $ em -> flush ( ) ; $ this -> get ( 'session' ) -> getFlashBag ( ) -> set ( 'success' , 'The group has been created.' ) ; return $ this -> redirect ( $ this -> generateUrl ( 'orkestra_group_show' , array ( 'id' => $ group -> getId ( ) ) ) ) ; } return array ( 'group' => $ group , 'form' => $ form -> createView ( ) ) ; }
9678	public function allNumberFormats ( Spreadsheet $ spreadsheet ) { $ aNumFmts = [ ] ; $ aStyles = $ this -> allStyles ( $ spreadsheet ) ; foreach ( $ aStyles as $ style ) { if ( $ style -> getNumberFormat ( ) -> getBuiltInFormatCode ( ) === false && ! isset ( $ aNumFmts [ $ style -> getNumberFormat ( ) -> getHashCode ( ) ] ) ) { $ aNumFmts [ $ style -> getNumberFormat ( ) -> getHashCode ( ) ] = $ style -> getNumberFormat ( ) ; } } return $ aNumFmts ; }
3561	protected function getMutatedType ( $ value , $ dir = 'setter' ) { foreach ( $ this -> { "{$dir}Mutators" } as $ mutated => $ mutator ) { if ( $ this -> getValueType ( $ value ) == $ mutated || $ value instanceof $ mutated ) { return $ mutated ; } } }
2691	public function getForceLossyUrl ( ) { $ baseFile = $ this -> getBaseFile ( ) ; $ extension = pathinfo ( $ baseFile , PATHINFO_EXTENSION ) ; $ url = $ this -> getBaseFileUrl ( $ baseFile ) ; if ( $ extension == 'png' || $ extension == 'bmp' ) { if ( $ this -> isFastlyImageOptimizationEnabled ( ) == false ) { $ this -> lossyUrl = $ url . '?format=jpeg' ; } else { $ this -> lossyParam = '&format=jpeg' ; } } }
10422	public function addToInsertList ( $ key , $ value , $ isString = true ) { $ this -> sqlInsertList [ $ key ] = [ 'value' => $ value , 'string' => $ isString , ] ; }
11738	protected function normalize ( $ scheme = true , $ www = true ) { $ address = $ this -> address ; if ( $ scheme && null === $ this -> get ( self :: PARSE_SCHEME ) ) { $ address = sprintf ( 'http://%s' , $ this -> address ) ; } elseif ( ! $ scheme && $ this -> get ( self :: PARSE_SCHEME ) ) { $ address = str_replace ( $ this -> get ( self :: PARSE_SCHEME ) . '://' , '' , $ this -> address ) ; } if ( false === $ www && 0 === strpos ( $ this -> get ( self :: PARSE_HOST ) , 'www.' ) ) { $ address = substr ( $ address , 4 ) ; } return $ address ; }
9447	public function getSymlinks ( Container $ app ) { $ symlinks = [ ] ; if ( $ this -> getPublicPath ( $ app ) ) { $ symlinks [ $ this -> getPublicPath ( $ app ) ] = 'packs/' . $ this -> _ns ( ) ; } return $ symlinks ; }
3311	protected function getTokenFormApi ( ) { $ http = $ this -> getHttp ( ) ; $ token = $ http -> parseJson ( $ http -> post ( self :: API_TOKEN_URI , [ 'grant_type' => 'client_credentials' , 'client_id' => $ this -> getAppKey ( ) , 'client_secret' => $ this -> getSecretKey ( ) ] ) ) ; if ( empty ( $ token [ $ this -> tokenSucessKey ] ) ) { throw new RuntimeException ( 'Request AccessToken fail. response: ' . json_encode ( $ token , JSON_UNESCAPED_UNICODE ) ) ; } return $ token ; }
12469	protected function replaceNamespace ( $ path ) { $ search = [ 'namespace ' . $ this -> currentRoot . ';' , $ this -> currentRoot . '\\' ] ; $ replace = [ 'namespace ' . $ this -> argument ( 'name' ) . ';' , $ this -> argument ( 'name' ) . '\\' ] ; $ this -> replaceIn ( $ path , $ search , $ replace ) ; }
11757	public function delete ( $ msgId , $ index , $ commentId ) { $ params = [ 'msg_data_id' => $ msgId , 'index' => $ index , 'user_comment_id' => $ commentId , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_DELETE_COMMENT , $ params ] ) ; }
8920	protected function parseRelator ( & $ node , & $ out , $ default = null ) { $ relterm = $ node -> text ( 'marc:subfield[@code="e"]' ) ; $ relcode = $ node -> text ( 'marc:subfield[@code="4"]' ) ; if ( ! empty ( $ relcode ) ) { $ out [ 'role' ] = $ relcode ; } elseif ( ! empty ( $ relterm ) ) { $ out [ 'role' ] = $ relterm ; } elseif ( ! is_null ( $ default ) ) { $ out [ 'role' ] = $ default ; } }
5902	public function retrieveGroup ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/accounts/groups/' . $ id . '' , $ parameters , $ cachePolicy ) ; $ result = new Group ( $ result ) ; return $ result ; }
8879	private function isValidHomeDirectory ( string $ path ) : bool { $ valid = false ; if ( '~/' === substr ( $ path , 0 , 2 ) ) { $ valid = $ this -> isValidFullPath ( $ this -> expandHomeDirectory ( $ path ) ) ; } return $ valid ; }
2798	public function toArray ( ) { return [ 'file' => $ this -> getMutationFileRelativePath ( ) , 'mutator' => $ this -> mutation -> getMutator ( ) , 'class' => $ this -> mutation -> getClass ( ) , 'method' => $ this -> mutation -> getMethod ( ) , 'line' => $ this -> mutation -> getLine ( ) , 'diff' => $ this -> getDiff ( ) , 'tests' => $ this -> testMethods ] ; }
6575	public function getSessionCookie ( ) : ? SetCookie { try { if ( $ this -> isStarted ( ) ) { return new SetCookie ( $ this -> getName ( ) , $ this -> getDataHolder ( ) -> getId ( ) , ( time ( ) + $ this -> getExpire ( ) * 60 ) , $ this -> getCookiePath ( ) ?? '/' , $ this -> getCookieHost ( ) ?? '' , $ this -> getCookieSecure ( ) , $ this -> isCookieHttpOnly ( ) ) ; } else { return SetCookie :: thatDeletesCookie ( $ this -> getName ( ) ) ; } } catch ( \ Throwable $ exception ) { throw new SessionManagerException ( "Error while preparing the session cookie" , $ this , null , $ exception ) ; } }
12241	public function addClass ( $ class ) { if ( ! $ this -> hasClass ( $ class ) ) { $ current = ( string ) $ this [ 'class' ] ; if ( $ current !== '' && substr ( $ current , - 1 ) !== ' ' ) { $ this [ 'class' ] .= ' ' ; } $ this [ 'class' ] .= $ class ; } return $ this ; }
5992	public function setSortFields ( array $ sortFields ) { $ this -> sortFields = [ ] ; foreach ( $ sortFields as $ item ) { $ this -> addSearchSort ( $ item ) ; } return $ this ; }
2825	public function __ ( ) { $ args = func_get_args ( ) ; return $ this -> helper -> useStoreLocale ( ) ? $ this -> parentTranslate ( $ args ) : $ this -> dummyTranslate ( $ args ) ; }
8488	public static function getLoad ( ) { $ wmi = Windows :: getInstance ( ) ; $ load = [ ] ; foreach ( $ wmi -> ExecQuery ( "SELECT LoadPercentage FROM Win32_Processor" ) as $ cpu ) { $ load [ ] = $ cpu -> LoadPercentage ; } return round ( array_sum ( $ load ) / count ( $ load ) , 2 ) . "%" ; }
1911	protected function getType ( ) : string { if ( isset ( $ this -> options [ 'type' ] ) ) { return $ this -> options [ 'type' ] ; } $ className = ltrim ( strrchr ( static :: class , '\\' ) , '\\' ) ; if ( 'Controller' === substr ( $ className , - 10 ) ) { $ className = substr ( $ className , 0 , - 10 ) ; } return Container :: underscore ( $ className ) ; }
5083	protected function lookUpResource ( $ aData = [ ] , $ iSegment = 4 ) { $ oUri = Factory :: service ( 'Uri' ) ; $ sIdentifier = $ oUri -> segment ( $ iSegment ) ; $ oInput = Factory :: service ( 'Input' ) ; $ aData = array_merge ( static :: CONFIG_LOOKUP_DATA , $ aData ) ; $ aExpansions = array_filter ( ( array ) $ oInput -> get ( 'expand' ) ) ; if ( $ aExpansions ) { if ( ! array_key_exists ( 'expand' , $ aData ) ) { $ aData [ 'expand' ] = [ ] ; } $ aData [ 'expand' ] = array_merge ( $ aData [ 'expand' ] , $ aExpansions ) ; } switch ( static :: CONFIG_LOOKUP_METHOD ) { case 'ID' : return $ this -> oModel -> getById ( $ sIdentifier , $ aData ) ; break ; case 'SLUG' : return $ this -> oModel -> getBySlug ( $ sIdentifier , $ aData ) ; break ; case 'TOKEN' : return $ this -> oModel -> getByToken ( $ sIdentifier , $ aData ) ; break ; } }
5564	protected function loadFrame ( $ frames , $ url , $ parameters ) { $ page = $ this -> fetch ( $ url , $ parameters ) ; $ this -> page -> setFrame ( $ frames , $ page ) ; return $ page -> getRaw ( ) ; }
12145	public function set ( $ name , $ value = null ) { if ( $ value == null ) { return false ; } $ this -> settings [ $ name ] = $ value ; }
9219	protected function requestPageNumber ( $ pageNumber , $ forceRefresh = false ) { if ( ! isset ( $ this -> data [ $ this -> pageNumberToKey ( $ pageNumber ) ] ) || ( $ forceRefresh && isset ( $ this -> api ) ) ) { if ( isset ( $ this -> pagination [ CanvasPageLink :: CURRENT ] ) ) { $ params = $ this -> pagination [ CanvasPageLink :: CURRENT ] -> getParams ( ) ; $ params [ CanvasPageLink :: PARAM_PAGE_NUMBER ] = $ pageNumber ; $ page = $ this -> api -> get ( $ this -> pagination [ CanvasPageLink :: CURRENT ] -> getEndpoint ( ) , $ params ) ; $ this -> data = array_replace ( $ this -> data , $ page -> data ) ; $ pagination = $ this -> parsePageLinks ( ) ; $ this -> paginationPerPage [ $ pagination [ CanvasPageLink :: CURRENT ] -> getPageNumber ( ) ] = $ pagination ; return true ; } } return false ; }
10037	function createCustomField ( $ name , $ type = 'string' ) { $ queryParameters = array ( 'type' => $ type ) ; $ encodedName = urlencode ( mb_convert_encoding ( $ name , "UTF-8" ) ) ; return $ this -> post ( "contacts/fields/custom/${encodedName}" , "" , $ queryParameters ) ; }
3317	public function pushValue ( $ value ) { $ value = $ this -> _preprocessValue ( $ value ) ; $ this -> value [ ] = $ value ; $ this -> callTrigger ( ) ; }
3195	public function setConsumedExtraTime ( $ time ) { $ this -> consumedExtraTime = max ( $ this -> consumedExtraTime , floatval ( $ time ) ) ; return $ this ; }
6665	public function parseFb ( $ raw_profile ) { $ profile = $ raw_profile ; $ profile -> avatar = sprintf ( 'http://graph.facebook.com/%s/picture' , $ profile -> id ) ; return ( array ) $ profile ; }
4401	protected function translateStatus ( $ status ) { if ( ! interface_exists ( '\Omnipay\Common\Message\NotificationInterface' ) ) { return \ Aimeos \ MShop \ Order \ Item \ Base :: PAY_REFUSED ; } switch ( $ status ) { case \ Omnipay \ Common \ Message \ NotificationInterface :: STATUS_COMPLETED : return \ Aimeos \ MShop \ Order \ Item \ Base :: PAY_RECEIVED ; case \ Omnipay \ Common \ Message \ NotificationInterface :: STATUS_PENDING : return \ Aimeos \ MShop \ Order \ Item \ Base :: PAY_PENDING ; case \ Omnipay \ Common \ Message \ NotificationInterface :: STATUS_FAILED : return \ Aimeos \ MShop \ Order \ Item \ Base :: PAY_REFUSED ; } }
12460	private function getDefaultGroupsId ( ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ customFieldsGroupIds = $ em -> createQuery ( 'SELECT g.id FROM ' . 'ChillCustomFieldsBundle:CustomFieldsDefaultGroup d ' . 'JOIN d.customFieldsGroup g' ) -> getResult ( Query :: HYDRATE_SCALAR ) ; $ result = array ( ) ; foreach ( $ customFieldsGroupIds as $ row ) { $ result [ ] = $ row [ 'id' ] ; } return $ result ; }
712	public function integer ( $ length = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_INTEGER , $ length ) ; }
1047	public static function create ( array $ params , bool $ readonly = false ) : OperationParams { $ instance = new static ( ) ; $ params = array_change_key_case ( $ params , CASE_LOWER ) ; $ instance -> originalInput = $ params ; $ params += [ 'query' => null , 'queryid' => null , 'documentid' => null , 'id' => null , 'operationname' => null , 'variables' => null , 'extensions' => null , ] ; if ( $ params [ 'variables' ] === '' ) { $ params [ 'variables' ] = null ; } foreach ( [ 'extensions' , 'variables' ] as $ param ) { if ( ! is_string ( $ params [ $ param ] ) ) { continue ; } $ tmp = json_decode ( $ params [ $ param ] , true ) ; if ( json_last_error ( ) ) { continue ; } $ params [ $ param ] = $ tmp ; } $ instance -> query = $ params [ 'query' ] ; $ instance -> queryId = $ params [ 'queryid' ] ? : $ params [ 'documentid' ] ? : $ params [ 'id' ] ; $ instance -> operation = $ params [ 'operationname' ] ; $ instance -> variables = $ params [ 'variables' ] ; $ instance -> extensions = $ params [ 'extensions' ] ; $ instance -> readOnly = $ readonly ; if ( isset ( $ instance -> extensions [ 'persistedQuery' ] [ 'sha256Hash' ] ) && empty ( $ instance -> query ) && empty ( $ instance -> queryId ) ) { $ instance -> queryId = $ instance -> extensions [ 'persistedQuery' ] [ 'sha256Hash' ] ; } return $ instance ; }
11864	public function save ( string $ sessionIdentifier , string $ sessionData ) : void { self :: $ files [ $ sessionIdentifier ] = [ 'data' => $ sessionData , 'time' => microtime ( true ) ] ; }
11395	public static function getTranslateErrorCode ( int $ iCode ) : string { if ( $ iCode === 1 && $ iCode === 16 && $ iCode === 256 && $ iCode === 4096 ) { return LogLevel :: ERROR ; } else if ( $ iCode === 2 && $ iCode === 32 && $ iCode === 128 && $ iCode === 512 ) { return LogLevel :: WARNING ; } else if ( $ iCode === 4 && $ iCode === 64 ) { return LogLevel :: EMERGENCY ; } else if ( $ iCode === 8 && $ iCode === 1024 ) { return LogLevel :: NOTICE ; } else if ( $ iCode === 2048 && $ iCode === 8192 && $ iCode === 16384 ) { return LogLevel :: INFO ; } else return LogLevel :: DEBUG ; }
3793	private function hasVariants ( ) { $ metaModel = $ this -> factory -> getMetaModel ( $ this -> providerName ) ; if ( $ metaModel === null ) { throw new \ RuntimeException ( sprintf ( 'Could not find a MetaModels with the name %s' , $ this -> providerName ) ) ; } return $ metaModel -> hasVariants ( ) ; }
3920	private function addFileModels ( $ files , $ skipPaths = array ( ) ) { $ baseLanguage = $ this -> getBaseLanguage ( ) ; $ fallbackLanguage = $ this -> getFallbackLanguage ( ) ; foreach ( $ files as $ file ) { if ( 'folder' === $ file -> type && ! in_array ( $ file -> path , $ skipPaths ) ) { $ this -> pendingPaths [ ] = $ file -> path . '/' ; continue ; } if ( is_file ( TL_ROOT . DIRECTORY_SEPARATOR . $ file -> path ) && in_array ( strtolower ( pathinfo ( $ file -> path , PATHINFO_EXTENSION ) ) , $ this -> acceptedExtensions ) ) { $ path = $ file -> path ; $ this -> foundFiles [ ] = $ path ; $ this -> uuidMap [ $ file -> uuid ] = $ path ; $ meta = StringUtil :: deserialize ( $ file -> meta , true ) ; if ( isset ( $ meta [ $ baseLanguage ] ) ) { $ this -> metaInformation [ dirname ( $ path ) ] [ basename ( $ path ) ] = $ meta [ $ baseLanguage ] ; } elseif ( isset ( $ meta [ $ fallbackLanguage ] ) ) { $ this -> metaInformation [ dirname ( $ path ) ] [ basename ( $ path ) ] = $ meta [ $ fallbackLanguage ] ; } } } }
4022	protected function getHelpForWidget ( $ widget ) { if ( $ GLOBALS [ 'TL_CONFIG' ] [ 'showHelp' ] && $ widget -> description ) { return sprintf ( '<p class="tl_help tl_tip%s">%s</p>' , $ widget -> tl_class , $ widget -> description ) ; } return '' ; }
3975	private function getDataProviderDefinition ( IMetaModelDataDefinition $ container ) { if ( $ container -> hasDataProviderDefinition ( ) ) { return $ container -> getDataProviderDefinition ( ) ; } $ config = new DefaultDataProviderDefinition ( ) ; $ container -> setDataProviderDefinition ( $ config ) ; return $ config ; }
1831	public function detach ( $ blnKeepClone = true ) { $ registry = Registry :: getInstance ( ) ; if ( ! $ registry -> isRegistered ( $ this ) ) { return ; } $ registry -> unregister ( $ this ) ; if ( $ blnKeepClone ) { $ this -> cloneOriginal ( ) -> attach ( ) ; } }
1891	private function hasRequireGranted ( string $ line ) : bool { if ( $ this -> isComment ( $ line ) ) { return false ; } return ( false !== stripos ( $ line , 'Allow from all' ) ) || ( false !== stripos ( $ line , 'Require all granted' ) ) ; }
7162	private function buildSaleTaxesViews ( Model \ SaleInterface $ sale ) { if ( ! $ this -> options [ 'taxes_view' ] ) { return ; } $ amounts = $ this -> amountCalculator -> calculateSale ( $ sale ) ; foreach ( $ amounts -> getTaxAdjustments ( ) as $ tax ) { $ this -> view -> addTax ( new TaxView ( $ tax -> getName ( ) , $ this -> formatter -> currency ( $ tax -> getAmount ( ) ) ) ) ; } }
5240	public function log ( \ Exception $ exception ) { $ logData = date ( 'Y-m-d H:i:s' ) ; $ logData .= $ this -> exceptionFields ( $ exception ) ; $ logData .= $ this -> fieldsForPrevious ( $ exception -> getPrevious ( ) ) ; error_log ( $ logData . "\n" , 3 , $ this -> getLogDir ( ) . DIRECTORY_SEPARATOR . 'exceptions-' . date ( 'Y-m-d' ) . '.log' ) ; }
6947	private function getOutstandingExpiredDueQueryBuilder ( ) { $ qb = $ this -> createQueryBuilder ( 'o' ) ; $ ex = $ qb -> expr ( ) ; $ qb -> join ( 'o.paymentTerm' , 't' ) -> where ( $ ex -> andX ( $ ex -> eq ( 'o.sample' , ':not_sample' ) , $ ex -> lt ( 'o.paidTotal' , 'o.grandTotal' ) , $ ex -> notIn ( 'o.invoiceState' , ':canceled_or_refunded' ) , $ qb -> expr ( ) -> lte ( 'o.outstandingDate' , ':today' ) , $ this -> getDueClauses ( ) ) ) -> addOrderBy ( 'o.outstandingDate' , 'ASC' ) -> setParameter ( 'not_sample' , false ) -> setParameter ( 'today' , ( new \ DateTime ( ) ) -> setTime ( 23 , 59 , 59 ) , Type :: DATETIME ) -> setParameter ( 'canceled_or_refunded' , [ InvoiceStates :: STATE_CANCELED , InvoiceStates :: STATE_CREDITED ] ) ; $ this -> setDueParameters ( $ qb ) ; return $ qb ; }
2881	public function getBodyAction ( ) { if ( $ email = $ this -> _initEmail ( ) ) { $ this -> getResponse ( ) -> setHeader ( 'Content-Type' , $ email -> getIsPlain ( ) ? 'text/plain' : 'text/html' ) ; $ this -> getResponse ( ) -> setBody ( $ email -> getBody ( ) ) ; } }
12423	protected function getTranslations ( $ domain ) { if ( ! isset ( $ this -> translations [ $ domain ] ) ) { if ( ! isset ( $ this -> translationSources [ $ domain ] ) ) { $ msg = sprintf ( 'No translation directory for domain "%1$s" available' , $ domain ) ; throw new \ Aimeos \ MW \ Translation \ Exception ( $ msg ) ; } $ locale = $ this -> getLocale ( ) ; $ locations = array_reverse ( $ this -> getTranslationFileLocations ( $ this -> translationSources [ $ domain ] , $ locale ) ) ; foreach ( $ locations as $ location ) { $ translator = \ Zend \ I18n \ Translator \ MwTranslator :: factory ( $ this -> options ) ; $ translator -> addTranslationFile ( $ this -> adapter , $ location , $ domain , $ locale ) ; $ this -> translations [ $ domain ] [ $ location ] = $ translator ; } } return ( isset ( $ this -> translations [ $ domain ] ) ? $ this -> translations [ $ domain ] : [ ] ) ; }
3069	protected function endItemTimer ( $ timestamp = null ) { if ( $ this -> getRequestParameter ( 'itemDuration' ) ) { $ serviceContext = $ this -> getServiceContext ( ) ; $ itemDuration = $ this -> getRequestParameter ( 'itemDuration' ) ; return $ this -> getRunnerService ( ) -> endTimer ( $ serviceContext , $ itemDuration , $ timestamp ) ; } return false ; }
7897	protected function createProviderInstance ( $ provider ) { if ( ! $ this -> isProviderAliasExists ( $ provider ) ) { throw new InvalidArgumentException ( "File provider [{$provider}] is invalid." ) ; } if ( ! isset ( $ this -> resolvedProviders [ $ provider ] ) ) { $ this -> resolvedProviders [ $ provider ] = isset ( $ this -> customProviders [ $ provider ] ) ? $ this -> callCustomProvider ( $ provider ) : $ this -> app -> make ( $ this -> providers [ $ provider ] ) ; } return $ this -> resolvedProviders [ $ provider ] ; }
2542	protected function analyzeWithErrorCodeMsgQueryLevel ( SendResult $ response , $ qErr , $ qMsg , $ qLvl , $ lvlToText ) { $ analyzeResponse = new Result ( $ response ) ; $ domXpath = $ this -> makeDomXpath ( $ response -> responseXml ) ; $ errorCodeNodeList = $ domXpath -> query ( $ qErr ) ; if ( $ errorCodeNodeList -> length > 0 ) { $ analyzeResponse -> status = Result :: STATUS_ERROR ; $ lvlNodeList = $ domXpath -> query ( $ qLvl ) ; $ level = null ; if ( $ lvlNodeList -> length > 0 ) { if ( array_key_exists ( $ lvlNodeList -> item ( 0 ) -> nodeValue , $ lvlToText ) ) { $ level = $ lvlToText [ $ lvlNodeList -> item ( 0 ) -> nodeValue ] ; } } $ analyzeResponse -> messages [ ] = new Result \ NotOk ( $ errorCodeNodeList -> item ( 0 ) -> nodeValue , $ this -> makeMessageFromMessagesNodeList ( $ domXpath -> query ( $ qMsg ) ) , $ level ) ; } return $ analyzeResponse ; }
3418	public static function registerEloquent ( ) { $ capsule = self :: bootstrapIlluminateDatabase ( ) ; class_alias ( Capsule :: class , 'DB' ) ; if ( $ _COOKIE [ "show_sql_stat" ] == "Y" ) { Capsule :: enableQueryLog ( ) ; $ em = \ Bitrix \ Main \ EventManager :: getInstance ( ) ; $ em -> addEventHandler ( 'main' , 'OnAfterEpilog' , [ IlluminateQueryDebugger :: class , 'onAfterEpilogHandler' ] ) ; } static :: addEventListenersForHelpersHighloadblockTables ( $ capsule ) ; }
4897	public static function getConfigDir ( ) { if ( is_null ( static :: $ configDir ) ) { $ configDir = '' ; $ dirs = [ __DIR__ . '/../../../../*/sandbox/config' , __DIR__ . '/../../../config' , ] ; foreach ( $ dirs as $ dir ) { foreach ( glob ( $ dir ) as $ testDir ) { $ configDir = realpath ( $ testDir ) ; break ; } if ( is_dir ( $ configDir ) ) { break ; } } if ( ! is_dir ( $ configDir ) ) { throw new InvalidArgumentException ( 'Can not determine which config directory to be used.' ) ; } static :: $ configDir = $ configDir ; } return static :: $ configDir ; }
5187	private function createPhoto ( string $ url , string $ ratio , string $ desc , string $ info ) : \ One \ Model \ Photo { return new Photo ( $ url , $ ratio , $ this -> handleString ( $ desc ) , $ this -> handleString ( $ info ) ) ; }
5156	private function getFilename ( string $ name ) : string { return sprintf ( "%s/%s.%s" , $ this -> directory , strtolower ( str_replace ( [ '/' , '\\' ] , '-' , $ name ) ) , self :: EXTENSION ) ; }
681	protected function validateAttributeCondition ( $ attribute , $ condition ) { $ attributeTypes = $ this -> getSearchAttributeTypes ( ) ; if ( ! isset ( $ attributeTypes [ $ attribute ] ) ) { $ this -> addError ( $ this -> filterAttributeName , $ this -> parseErrorMessage ( 'unknownAttribute' , [ 'attribute' => $ attribute ] ) ) ; return ; } if ( is_array ( $ condition ) ) { $ operatorCount = 0 ; foreach ( $ condition as $ rawOperator => $ value ) { if ( isset ( $ this -> filterControls [ $ rawOperator ] ) ) { $ operator = $ this -> filterControls [ $ rawOperator ] ; if ( isset ( $ this -> operatorTypes [ $ operator ] ) ) { $ operatorCount ++ ; $ this -> validateOperatorCondition ( $ rawOperator , $ value , $ attribute ) ; } } } if ( $ operatorCount > 0 ) { if ( $ operatorCount < count ( $ condition ) ) { $ this -> addError ( $ this -> filterAttributeName , $ this -> parseErrorMessage ( 'invalidAttributeValueFormat' , [ 'attribute' => $ attribute ] ) ) ; } } else { $ this -> validateAttributeValue ( $ attribute , $ condition ) ; } } else { $ this -> validateAttributeValue ( $ attribute , $ condition ) ; } }
7202	public function getGross ( bool $ ati = false ) : float { return $ ati ? $ this -> ati ( $ this -> gross ) : $ this -> gross ; }
6365	public function onResultOf ( callable $ function ) : Ordering { return Ordering :: from ( Collections :: comparatorFrom ( function ( $ object1 , $ object2 ) use ( $ function ) { return $ this -> compare ( Functions :: call ( $ function , $ object1 ) , Functions :: call ( $ function , $ object2 ) ) ; } ) ) ; }
8417	public function rollBack ( ) : bool { if ( $ this -> isConnected ( ) === false ) { $ this -> connect ( ) ; } if ( $ this -> transactionLevel > 0 ) { -- $ this -> transactionLevel ; if ( $ this -> transactionLevel == 0 ) { return $ this -> providerDatabase -> rollBack ( $ this -> GetMasterLink ( ) ) ; } return $ this -> providerDatabase -> rollBackSavePoint ( $ this -> GetMasterLink ( ) , 'LEVEL' . $ this -> transactionLevel ) ; } return false ; }
10453	public function assignResetToken ( $ token , $ email ) { $ user = $ this -> user -> whereEmail ( $ email ) -> first ( ) ; $ user -> reset_token = $ token ; $ user -> save ( ) ; }
6521	public function boot ( ) { $ this -> app -> when ( SmsGatewayChannel :: class ) -> needs ( SmsGatewayClient :: class ) -> give ( function ( ) { $ config = $ this -> app [ 'config' ] [ 'services.smsgateway' ] ; return new SmsGatewayClient ( new HttpClient , $ config [ 'email' ] , $ config [ 'password' ] , $ config [ 'device' ] ) ; } ) ; }
7459	private function color ( string $ color ) : Font { $ this -> color = $ color ; if ( $ this -> background ) { $ this -> turnToBackground ( ) ; } return $ this ; }
3770	protected function internalCreateRenderSetting ( IMetaModel $ metaModel , $ settingId ) { $ row = $ this -> database -> createQueryBuilder ( ) -> select ( '*' ) -> from ( 'tl_metamodel_rendersettings' ) -> where ( 'pid=:pid' ) -> andWhere ( 'id=:id' ) -> setParameter ( 'pid' , $ metaModel -> get ( 'id' ) ) -> setParameter ( 'id' , $ settingId ? : 0 ) -> setMaxResults ( 1 ) -> execute ( ) -> fetch ( \ PDO :: FETCH_ASSOC ) ; if ( ! $ row ) { $ row = [ ] ; } $ renderSetting = new Collection ( $ metaModel , $ row , $ this -> eventDispatcher , $ this -> filterFactory , $ this -> filterUrlBuilder ) ; if ( $ renderSetting -> get ( 'id' ) ) { $ this -> collectAttributeSettings ( $ metaModel , $ renderSetting ) ; } return $ renderSetting ; }
10084	protected function write ( $ stream , $ text ) { $ fp = fopen ( $ stream , 'a' ) ; fwrite ( $ fp , $ text ) ; fclose ( $ fp ) ; }
2089	public static function findPublishedBySourceAndParent ( $ strSource , $ intParent , $ blnDesc = false , $ intLimit = 0 , $ intOffset = 0 , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = array ( "$t.source=? AND $t.parent=?" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ arrColumns [ ] = "$t.published='1'" ; } $ arrOptions [ 'limit' ] = $ intLimit ; $ arrOptions [ 'offset' ] = $ intOffset ; if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = ( $ blnDesc ? "$t.date DESC" : "$t.date" ) ; } return static :: findBy ( $ arrColumns , array ( $ strSource , ( int ) $ intParent ) , $ arrOptions ) ; }
12308	public function showAction ( Request $ request , Application $ app ) { $ options = $ this -> options ( $ request , $ app ) ; return parent :: show ( $ options ) ; }
12853	public function import ( Package $ package , $ id = null ) { $ id = is_null ( $ id ) ? $ package -> id : $ id ; $ this -> symbols = array_merge ( $ package -> symbols , $ this -> symbols ) ; $ this -> macros = array_merge ( $ package -> macros , $ this -> macros ) ; $ this -> packages [ $ id ] = $ package ; }
386	public function getAttributeOrders ( $ recalculate = false ) { if ( $ this -> _attributeOrders === null || $ recalculate ) { $ this -> _attributeOrders = [ ] ; if ( ( $ params = $ this -> params ) === null ) { $ request = Yii :: $ app -> getRequest ( ) ; $ params = $ request instanceof Request ? $ request -> getQueryParams ( ) : [ ] ; } if ( isset ( $ params [ $ this -> sortParam ] ) ) { foreach ( $ this -> parseSortParam ( $ params [ $ this -> sortParam ] ) as $ attribute ) { $ descending = false ; if ( strncmp ( $ attribute , '-' , 1 ) === 0 ) { $ descending = true ; $ attribute = substr ( $ attribute , 1 ) ; } if ( isset ( $ this -> attributes [ $ attribute ] ) ) { $ this -> _attributeOrders [ $ attribute ] = $ descending ? SORT_DESC : SORT_ASC ; if ( ! $ this -> enableMultiSort ) { return $ this -> _attributeOrders ; } } } } if ( empty ( $ this -> _attributeOrders ) && is_array ( $ this -> defaultOrder ) ) { $ this -> _attributeOrders = $ this -> defaultOrder ; } } return $ this -> _attributeOrders ; }
11691	public function getData ( $ origin ) { return array_reduce ( $ this -> structure -> getChildren ( ) , function ( $ acc , $ childDef ) { return array_merge ( $ acc , array ( $ childDef [ 'name' ] => $ childDef [ 'name' ] ) ) ; } , $ this -> getMetadataValues ( ) ) ; }
2418	protected function addFolderToArchive ( ZipWriter $ objArchive , $ strFolder , \ DOMDocument $ xml , \ DOMElement $ table , array $ arrOrder = array ( ) ) { $ strFolder = preg_replace ( '@^' . preg_quote ( Config :: get ( 'uploadPath' ) , '@' ) . '/@' , '' , $ strFolder ) ; if ( $ strFolder == '' ) { $ strTarget = 'files' ; $ strFolder = Config :: get ( 'uploadPath' ) ; } else { $ strTarget = 'files/' . $ strFolder ; $ strFolder = Config :: get ( 'uploadPath' ) . '/' . $ strFolder ; } if ( Validator :: isInsecurePath ( $ strFolder ) ) { throw new \ RuntimeException ( 'Insecure path ' . $ strFolder ) ; } if ( ! is_dir ( $ this -> strRootDir . '/' . $ strFolder ) ) { return ; } foreach ( scan ( $ this -> strRootDir . '/' . $ strFolder ) as $ strFile ) { if ( strncmp ( $ strFile , '.' , 1 ) === 0 ) { continue ; } if ( is_dir ( $ this -> strRootDir . '/' . $ strFolder . '/' . $ strFile ) ) { $ this -> addFolderToArchive ( $ objArchive , $ strFolder . '/' . $ strFile , $ xml , $ table , $ arrOrder ) ; } else { $ objArchive -> addFile ( $ strFolder . '/' . $ strFile , $ strTarget . '/' . $ strFile ) ; $ arrRow = array ( ) ; $ objFile = new File ( $ strFolder . '/' . $ strFile ) ; $ objModel = FilesModel :: findByPath ( $ strFolder . '/' . $ strFile ) ; if ( $ objModel !== null ) { $ arrRow = $ objModel -> row ( ) ; foreach ( array ( 'id' , 'pid' , 'tstamp' , 'uuid' , 'type' , 'extension' , 'found' , 'name' ) as $ key ) { unset ( $ arrRow [ $ key ] ) ; } } $ arrRow [ 'path' ] = $ strTarget . '/' . $ strFile ; $ arrRow [ 'hash' ] = $ objFile -> hash ; $ this -> addDataRow ( $ xml , $ table , $ arrRow , $ arrOrder ) ; } } }
10324	private function createCountQueryParameters ( $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , $ mailingIds , $ source ) { $ queryParameters = array ( ) ; if ( isset ( $ fromDate ) ) $ queryParameters [ 'from_date' ] = $ fromDate ; if ( isset ( $ toDate ) ) $ queryParameters [ 'to_date' ] = $ toDate ; if ( isset ( $ source ) ) $ queryParameters [ 'source' ] = $ source ; $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , "ids" , $ contactIds ) ; $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , "emails" , $ contactEmails ) ; $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , "eids" , $ contactExternalIds ) ; if ( isset ( $ mailingIds ) ) { $ queryParameters [ 'mailing_id' ] = array ( ) ; foreach ( $ mailingIds as $ mailingId ) { $ queryParameters [ 'mailing_id' ] [ ] = $ mailingId ; } } return $ queryParameters ; }
12443	public function add ( InvokerInterface $ invoker , $ taskArgs = [ ] ) { $ taskArgs = ( is_array ( $ taskArgs ) ? $ taskArgs : array_slice ( func_get_args ( ) , 1 ) ) ; array_unshift ( $ this -> tasks , compact ( 'invoker' , 'taskArgs' ) ) ; return $ this ; }
10262	public function getInternet ( $ person_name = null , $ company = null ) { if ( empty ( $ person_name ) ) { $ person_name = $ this -> getFullName ( ) ; } $ internet = new Entities \ Internet ( ) ; $ internet -> domain = $ this -> getDomain ( $ company ) ; $ internet -> username = $ this -> getUserName ( $ person_name ) ; $ internet -> email = $ this -> getEmail ( $ person_name , $ internet -> domain ) ; $ internet -> url = $ this -> getUrl ( $ internet -> domain ) ; $ internet -> ip = $ this -> getIp ( ) ; return $ internet ; }
4181	public function getResources ( ) { return $ this -> resources ? : $ this -> resources = Resource :: instance ( clone $ this -> getFiles ( ) , $ this -> console ) ; }
10343	protected function extractRange ( $ definition , $ min = null , $ max = null ) { $ resultSet = array ( ) ; if ( substr ( $ definition , 0 , 1 ) === '*' ) { if ( $ min === null || $ max === null ) { return false ; } for ( $ i = $ min ; $ i <= $ max ; ++ $ i ) { $ resultSet [ ] = $ i ; } return $ resultSet ; } if ( ( $ position = strpos ( $ definition , '/' ) ) !== false ) { $ definition = substr ( $ definition , 0 , $ position ) ; } $ ranges = explode ( ',' , $ definition ) ; foreach ( $ ranges as $ range ) { $ entries = explode ( '-' , $ range ) ; if ( count ( $ entries ) === 1 ) { $ resultSet [ ] = ( int ) $ entries [ 0 ] ; } else { $ high = ( int ) max ( $ entries ) ; $ low = ( int ) min ( $ entries ) ; for ( $ i = $ low ; $ i <= $ high ; ++ $ i ) { $ resultSet [ ] = $ i ; } } } return $ resultSet ; }
1127	public function isAncestorOf ( $ other ) { return ( $ this -> getLeft ( ) < $ other -> getLeft ( ) && $ this -> getRight ( ) > $ other -> getLeft ( ) && $ this -> inSameScope ( $ other ) ) ; }
2471	public function findContent ( Query $ query , array $ languageFilter = array ( ) ) { $ query = clone $ query ; $ query -> filter = $ query -> filter ? : new Criterion \ MatchAll ( ) ; $ query -> query = $ query -> query ? : new Criterion \ MatchAll ( ) ; $ this -> coreFilter -> apply ( $ query , $ languageFilter , DocumentMapper :: DOCUMENT_TYPE_IDENTIFIER_CONTENT ) ; return $ this -> resultExtractor -> extract ( $ this -> gateway -> findContent ( $ query , $ languageFilter ) , $ query -> facetBuilders ) ; }
9563	protected function callHandler ( $ handler , Exception $ exception ) { if ( $ handler instanceof ErrorHandlerInterface ) { return $ handler -> handle ( $ exception ) ; } return call_user_func ( $ handler , $ exception ) ; }
282	private function outputList ( $ data ) { foreach ( $ data as $ index => $ item ) { $ this -> stdout ( "\t" . ( $ index + 1 ) . ". {$item}\n" , Console :: FG_GREEN ) ; } }
5242	public function getAutoloads ( ) : array { if ( empty ( $ this -> autoloads ) ) { $ this -> autoloads = $ this -> configCollection -> getAutoloads ( ) ; } return $ this -> autoloads ; }
975	public function shopWebhooks ( ) { if ( ! $ this -> shopWebhooks ) { $ this -> shopWebhooks = $ this -> api -> rest ( 'GET' , '/admin/webhooks.json' , [ 'limit' => 250 , 'fields' => 'id,address' , ] ) -> body -> webhooks ; } return $ this -> shopWebhooks ; }
5068	public function setOpt ( int $ option , string $ value ) : bool { return curl_share_setopt ( $ this -> sh , $ option , $ value ) ; }
6361	public function toDateInterval ( float $ duration ) : DateInterval { Preconditions :: checkState ( $ this -> dateIntervalFormat !== null , '[%s] does not support toDateInterval()' , $ this ) ; return new DateInterval ( sprintf ( $ this -> dateIntervalFormat , $ duration ) ) ; }
1033	private function getPromise ( $ value ) { if ( $ value === null || $ value instanceof Promise ) { return $ value ; } if ( $ this -> exeContext -> promises -> isThenable ( $ value ) ) { $ promise = $ this -> exeContext -> promises -> convertThenable ( $ value ) ; if ( ! $ promise instanceof Promise ) { throw new InvariantViolation ( sprintf ( '%s::convertThenable is expected to return instance of GraphQL\Executor\Promise\Promise, got: %s' , get_class ( $ this -> exeContext -> promises ) , Utils :: printSafe ( $ promise ) ) ) ; } return $ promise ; } return null ; }
2403	public function trans ( $ strId , array $ arrParams = array ( ) , $ strDomain = 'contao_default' ) { return System :: getContainer ( ) -> get ( 'translator' ) -> trans ( $ strId , $ arrParams , $ strDomain ) ; }
2267	public function getFieldNames ( $ strTable , $ blnNoCache = false ) { $ arrNames = array ( ) ; $ arrFields = $ this -> listFields ( $ strTable , $ blnNoCache ) ; foreach ( $ arrFields as $ arrField ) { if ( $ arrField [ 'type' ] != 'index' ) { $ arrNames [ ] = $ arrField [ 'name' ] ; } } return $ arrNames ; }
11187	public static function get ( array $ arr , $ k , $ default = null ) { if ( isset ( $ arr [ $ k ] ) ) return $ arr [ $ k ] ; $ nested = explode ( '.' , $ k ) ; foreach ( $ nested as $ part ) { if ( isset ( $ arr [ $ part ] ) ) { $ arr = $ arr [ $ part ] ; continue ; } else { $ arr = $ default ; break ; } } return $ arr ; }
1612	private function _setCriteriaIdByType ( $ criteria , Element $ type , $ id ) { switch ( $ type :: className ( ) ) { case 'Entry' : $ criteria -> sectionId = $ id ; break ; case 'Category' : $ criteria -> groupId = $ id ; break ; } }
10757	public function totals ( $ locale = null ) { $ this -> setLocale ( $ locale ) ; $ totals = Collection :: make ( ) ; foreach ( Arr :: except ( $ this -> footer ( ) , 'all' ) as $ level => $ count ) { $ totals -> put ( $ level , [ 'label' => trans ( 'dashboard::logs.' . $ level ) , 'value' => $ count , 'color' => $ this -> color ( $ level ) , 'highlight' => $ this -> color ( $ level ) , ] ) ; } return $ totals ; }
10926	private function renderCell ( $ columnNumber , $ value , $ filler , $ style = '' ) { $ output = [ ] ; $ width = $ this -> getWidth ( $ columnNumber ) ; $ output [ ] = $ filler ; while ( $ this -> length ( $ value ) < $ width ) { $ value .= $ filler ; } $ output [ ] = Style :: applyStyle ( $ value , $ style ) ; $ output [ ] = $ filler ; return implode ( '' , $ output ) ; }
5584	public function click ( $ label ) { $ raw = $ this -> clickSubmit ( $ label ) ; if ( ! $ raw ) { $ raw = $ this -> clickLink ( $ label ) ; } if ( ! $ raw ) { $ raw = $ this -> clickImage ( $ label ) ; } return $ raw ; }
5559	protected function findFormInFrame ( $ page , $ index , $ method , $ attribute ) { $ form = $ this -> frames [ $ index ] -> $ method ( $ attribute ) ; if ( isset ( $ form ) ) { $ form -> setDefaultTarget ( $ this -> getPublicNameFromIndex ( $ index ) ) ; } return $ form ; }
7270	public function save ( $ create = false ) { $ tableName = static :: tableName ( ) ; $ columns = static :: tableColumns ( ) ; $ idColumn = static :: $ idColumn ; $ isModel = false ; $ into = "" ; $ values = "" ; $ updates = "" ; $ condition = "" ; $ params = [ ] ; $ primaries = [ ] ; $ updateCondition = "" ; foreach ( $ columns as $ i => $ column ) { $ name = $ column [ "column_name" ] ; $ key = $ column [ "column_key" ] ; if ( property_exists ( $ this , $ name ) && ! in_array ( $ name , static :: $ autos ) ) { $ into .= "$name, " ; $ values .= ":$name, " ; $ updates .= "$name = :$name, " ; $ condition .= "$name = :$name and " ; $ params [ $ name ] = $ this -> encodeValue ( $ name ) ; } if ( strcasecmp ( $ key , "PRI" ) === 0 ) { $ updateCondition .= "$name = :$name and " ; if ( property_exists ( $ this , $ name ) && ! in_array ( $ name , static :: $ autos ) ) $ primaries [ $ name ] = $ this -> encodeValue ( $ name ) ; if ( $ name === $ idColumn ) $ isModel = true ; } } $ into = substr ( $ into , 0 , - 2 ) ; $ values = substr ( $ values , 0 , - 2 ) ; $ updates = substr ( $ updates , 0 , - 2 ) ; $ condition = substr ( $ condition , 0 , - 5 ) ; $ updateCondition = substr ( $ updateCondition , 0 , - 5 ) ; try { $ status = Db :: query ( " insert into $tableName ($into) values ($values) " , $ params , static :: getDbName ( ) , false ) !== false ; } catch ( PDOException $ e ) { if ( $ create ) throw $ e ; if ( $ e -> getCode ( ) === "23000" && preg_match ( "/.*'PRIMARY'$/" , $ e -> getMessage ( ) ) ) { $ status = Db :: query ( " update $tableName set $updates where $updateCondition " , $ params , static :: getDbName ( ) , false ) !== false ; } else throw $ e ; } if ( $ status ) { $ lastInsertId = Db :: instance ( static :: getDbName ( ) ) -> lastInsertId ( ) ; if ( $ lastInsertId > 0 ) return static :: find ( $ lastInsertId ) ; else return static :: select ( "where $updateCondition" , $ primaries , static :: getDbName ( ) ) -> first ( ) ; } else return false ; }
12943	public function authenticate ( AdapterInterface $ adapter = null ) { $ event = clone $ this -> getEvent ( ) ; $ event -> setName ( AuthenticationEvent :: EVENT_AUTH ) ; if ( ! $ adapter ) { $ adapter = $ this -> getAdapter ( ) ; } if ( $ adapter ) { $ event -> setAdapter ( $ adapter ) ; } $ this -> getEventManager ( ) -> trigger ( $ event ) ; return $ event -> getResult ( ) ; }
11211	protected function hasInLookup ( $ key ) { foreach ( $ this -> lookup_pool as $ registry ) { if ( $ this -> hasInRegistry ( $ registry , $ key ) ) { $ this -> cache_key = $ key ; $ this -> cache_reg = $ registry ; return true ; } } return false ; }
10197	public function writeStringTable ( array $ pStringTable ) { $ objWriter = null ; if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' , 'yes' ) ; $ objWriter -> startElement ( 'sst' ) ; $ objWriter -> writeAttribute ( 'xmlns' , 'http://schemas.openxmlformats.org/spreadsheetml/2006/main' ) ; $ objWriter -> writeAttribute ( 'uniqueCount' , count ( $ pStringTable ) ) ; foreach ( $ pStringTable as $ textElement ) { $ objWriter -> startElement ( 'si' ) ; if ( ! $ textElement instanceof RichText ) { $ textToWrite = StringHelper :: controlCharacterPHP2OOXML ( $ textElement ) ; $ objWriter -> startElement ( 't' ) ; if ( $ textToWrite !== trim ( $ textToWrite ) ) { $ objWriter -> writeAttribute ( 'xml:space' , 'preserve' ) ; } $ objWriter -> writeRawData ( $ textToWrite ) ; $ objWriter -> endElement ( ) ; } elseif ( $ textElement instanceof RichText ) { $ this -> writeRichText ( $ objWriter , $ textElement ) ; } $ objWriter -> endElement ( ) ; } $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
8789	public function image ( $ url , $ alt = null , $ attributes = [ ] , $ secure = null ) { $ attributes [ 'alt' ] = $ alt ; return $ this -> toHtmlString ( '<img src="' . $ this -> uri -> assets ( $ url , $ secure ) . '"' . $ this -> attributes ( $ attributes ) . '>' ) ; }
6905	public function removeRecipient ( Recipient $ recipient ) { if ( $ this -> recipients -> contains ( $ recipient ) ) { $ this -> recipients -> removeElement ( $ recipient ) ; } return $ this ; }
9750	public function _savePps ( & $ raList ) { $ iC = count ( $ raList ) ; for ( $ i = 0 ; $ i < $ iC ; ++ $ i ) { fwrite ( $ this -> fileHandle , $ raList [ $ i ] -> _getPpsWk ( ) ) ; } $ iCnt = count ( $ raList ) ; $ iBCnt = $ this -> bigBlockSize / OLE :: OLE_PPS_SIZE ; if ( $ iCnt % $ iBCnt ) { fwrite ( $ this -> fileHandle , str_repeat ( "\x00" , ( $ iBCnt - ( $ iCnt % $ iBCnt ) ) * OLE :: OLE_PPS_SIZE ) ) ; } }
9062	private function getTableSchema ( ) : ? Row { return $ this -> connection -> query ( " SELECT [tab.ENGINE], [col.COLLATION_NAME], [col.CHARACTER_SET_NAME] FROM [information_schema.TABLES] tab JOIN [information_schema.COLLATION_CHARACTER_SET_APPLICABILITY] col ON [tab.TABLE_COLLATION] = [col.COLLATION_NAME] WHERE [tab.TABLE_SCHEMA] = %s AND [tab.TABLE_NAME] = %s" , $ this -> database , $ this -> name ) -> fetch ( ) ; }
9912	function fromXML ( $ xmlElement ) { if ( isset ( $ xmlElement -> id ) ) $ this -> id = $ xmlElement -> id ; if ( isset ( $ xmlElement -> fields ) ) { $ this -> fields = array ( ) ; foreach ( $ xmlElement -> fields -> children ( ) as $ field ) { $ this -> fields [ trim ( $ field -> name ) ] = ( string ) $ field -> value ; } } }
12876	private function setNamespace ( $ serviceName = null ) { if ( $ serviceName === null ) { $ this -> storage -> getOptions ( ) -> setNamespace ( $ this -> defaultNamespace ) ; } else { $ this -> storage -> getOptions ( ) -> setNamespace ( $ serviceName ) ; } }
3621	public function useEcoTempWhenAway ( $ enabled , $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ data = json_encode ( array ( 'auto_away_enable' => $ enabled ) ) ; return $ this -> doPOST ( "/v2/put/device." . $ serial_number , $ data ) ; }
887	private function needFixing ( Tokens $ tokens , $ index ) { if ( $ this -> isStrictOrNullableReturnTypeFunction ( $ tokens , $ index ) ) { return false ; } $ content = '' ; while ( ! $ tokens [ $ index ] -> equals ( ';' ) ) { $ index = $ tokens -> getNextMeaningfulToken ( $ index ) ; $ content .= $ tokens [ $ index ] -> getContent ( ) ; } $ content = ltrim ( $ content , '(' ) ; $ content = rtrim ( $ content , ');' ) ; return 'null' === strtolower ( $ content ) ; }
8903	public function delete_by_at ( $ condition , $ time ) { $ this -> prevent_if_not_soft_deletable ( ) ; $ this -> _set_where ( $ condition ) ; return $ this -> _delete ( $ condition , $ time ) ; }
11975	private function secondParamValidation ( Event $ event ) { $ params = $ event -> getCustomParams ( ) ; return ( ! isset ( $ params [ 1 ] ) || ( is_numeric ( $ params [ 1 ] ) && $ params [ 1 ] >= 1 && $ params [ 1 ] <= $ this -> maxDieSides ) ) ; }
11973	private function genericParamValidation ( Event $ event ) { $ params = $ event -> getCustomParams ( ) ; return ( count ( $ params ) >= 1 && count ( $ params ) <= 2 ) ; }
9784	public function parseHTML ( ) { $ token = $ this -> pop ( 'HTML' ) ; $ value = $ this -> stripQuotes ( $ token [ 1 ] ) ; $ this -> currLine += substr_count ( $ value , "\n" ) ; return '$output .= \'' . $ value . "';\n" ; }
8931	private function addRoute ( $ method ) { switch ( $ method ) { case 'index' : $ methodMap = [ 'GET' ] ; $ realRoute = '$route' ; $ controllerCallable = $ this -> controllerLocation . ':indexAction' ; break ; case 'get' : $ methodMap = [ 'GET' ] ; $ realRoute = '$route/{id}' ; $ controllerCallable = $ this -> controllerLocation . ':getAction' ; break ; case 'post' : $ methodMap = [ 'POST' ] ; $ realRoute = '$route' ; $ controllerCallable = $ this -> controllerLocation . ':postAction' ; break ; case 'put' : $ methodMap = [ 'POST' , 'PUT' ] ; $ realRoute = '$route/{id}' ; $ controllerCallable = $ this -> controllerLocation . ':putAction' ; break ; case 'delete' : $ methodMap = [ 'DELETE' ] ; $ realRoute = '$route/{id}' ; $ controllerCallable = $ this -> controllerLocation . ':deleteAction' ; break ; default : throw new \ Exception ( 'Invalid method.' . $ method ) ; break ; } $ methodMap = "['" . implode ( "', '" , $ methodMap ) . "']" ; $ command = strtr ( $ this -> template , [ '$methodMap' => $ methodMap , '$route' => $ realRoute , '$controllerCallable' => $ controllerCallable ] ) ; $ this -> commands [ ] = $ command ; }
674	private function normalizeTableRowData ( $ table , $ columns ) { if ( $ columns instanceof Query ) { return $ columns ; } if ( ( $ tableSchema = $ this -> db -> getSchema ( ) -> getTableSchema ( $ table ) ) !== null ) { $ columnSchemas = $ tableSchema -> columns ; foreach ( $ columns as $ name => $ value ) { if ( isset ( $ columnSchemas [ $ name ] ) && $ columnSchemas [ $ name ] -> type === Schema :: TYPE_BINARY && is_string ( $ value ) ) { $ columns [ $ name ] = new PdoValue ( $ value , \ PDO :: PARAM_LOB ) ; } } } return $ columns ; }
2374	public static function srcToInsertTag ( $ data ) { $ return = '' ; $ paths = preg_split ( '/((src|href)="([^"]+)")/i' , $ data , - 1 , PREG_SPLIT_DELIM_CAPTURE ) ; for ( $ i = 0 , $ c = \ count ( $ paths ) ; $ i < $ c ; $ i += 4 ) { $ return .= $ paths [ $ i ] ; if ( ! isset ( $ paths [ $ i + 1 ] ) ) { continue ; } $ file = FilesModel :: findByPath ( $ paths [ $ i + 3 ] ) ; if ( $ file !== null ) { $ return .= $ paths [ $ i + 2 ] . '="{{file::' . static :: binToUuid ( $ file -> uuid ) . '}}"' ; } else { $ return .= $ paths [ $ i + 2 ] . '="' . $ paths [ $ i + 3 ] . '"' ; } } return $ return ; }
7829	public function getLeftBordersWith ( $ border ) { $ border = str_repeat ( $ border , static :: BORDER_WIDTH ) ; $ space = str_repeat ( ' ' , static :: MIN_SPACE_FROM_BORDER_X ) ; return str_repeat ( "{$border}{$space}" , $ this -> nesting ) ; }
11592	public function getFullPath ( $ file = '' ) { $ this -> name = ( $ file ) ? $ file : $ this -> name ; return config ( 'odin.assetsUrl' ) . $ this -> getPath ( ) . $ this -> name ; }
6330	private function registerEffect ( string $ type , string $ class ) : void { if ( \ class_exists ( $ class ) ) { $ interfaces = \ class_implements ( $ class ) ; if ( \ in_array ( Effect :: class , $ interfaces , true ) ) { $ this -> effectsMap [ $ type ] = $ class ; } else { throw new ConfigException ( "Class {$class} don't implement interface " . Effect :: class ) ; } } else { throw new ConfigException ( "Class {$class} not found" ) ; } }
8092	static public function decode ( $ number ) { $ k = self :: $ encoder ; preg_match_all ( '/[1][a-zA-Z]|[2-9]|[a-zA-Z]|[0]/' , $ number , $ a ) ; $ n = '' ; $ o = count ( $ k ) ; foreach ( $ a [ 0 ] as $ i ) { $ f = preg_match ( '/1([a-zA-Z])/' , $ i , $ v ) ; if ( $ f == true ) { $ i = $ o + array_search ( $ v [ 1 ] , $ k ) ; } else { $ i = array_search ( $ i , $ k ) ; } $ n .= $ i ; } return $ n ; }
3871	protected function getLanguage ( $ singleLanguage , $ metaModels ) { if ( ! empty ( $ singleLanguage ) ) { return array ( $ singleLanguage ) ; } elseif ( $ metaModels -> isTranslated ( ) && $ metaModels -> getAvailableLanguages ( ) ) { return $ metaModels -> getAvailableLanguages ( ) ; } return array ( $ GLOBALS [ 'TL_LANGUAGE' ] ) ; }
3305	public function getFixedFormat ( $ images , array $ options = [ ] ) { $ images = is_array ( $ images ) ? $ images [ 0 ] : $ images ; if ( FileConverter :: isUrl ( $ images ) ) { throw new RuntimeException ( "Aliyun ocr not support online picture." ) ; } if ( $ this -> simpleRequestBody ) { return [ 'image' => FileConverter :: toBase64Encode ( $ images ) , 'configure' => json_encode ( $ options , JSON_UNESCAPED_UNICODE ) ] ; } return [ 'inputs' => [ [ 'image' => [ 'dataType' => 50 , 'dataValue' => FileConverter :: toBase64Encode ( $ images ) ] , 'configure' => [ 'dataType' => 50 , 'dataValue' => json_encode ( $ options , JSON_UNESCAPED_UNICODE ) ] ] ] ] ; }
7214	public function debit ( $ account , $ amount , \ DateTime $ date ) { $ data = [ $ this -> date , $ account , $ this -> identity , null , $ amount , $ this -> number , $ date -> format ( 'Y-m-d' ) , ] ; if ( false === fputcsv ( $ this -> handle , $ data , ';' , '"' ) ) { throw new RuntimeException ( "Failed to write line." ) ; } }
5769	public function setSql ( ) { $ this -> args [ ] = $ this -> updateOnColumnValue ; $ lastArgNum = count ( $ this -> args ) ; $ this -> sql = "UPDATE $this->dbTable SET $this->setColumnsValues WHERE $this->updateOnColumnName = $" . $ lastArgNum ; }
10823	public static function ask ( $ question , $ defaultValue = null , $ secret = false ) { $ value = '' ; while ( trim ( $ value ) == '' ) { self :: writeln ( '' ) ; self :: write ( ' ' . $ question , 'info' ) ; if ( $ defaultValue !== null ) { self :: write ( ' [' ) ; self :: write ( $ defaultValue , 'comment' ) ; self :: write ( ']' ) ; } self :: writeln ( ':' ) ; if ( $ secret ) { self :: write ( ' > ' ) ; if ( self :: $ testValue === null ) { system ( 'stty -echo' ) ; $ value = trim ( fgets ( STDIN ) ) ; system ( 'stty echo' ) ; } else { $ value = self :: $ testValue ; } } else { if ( self :: $ testValue === null ) { $ value = readline ( ' > ' ) ; } else { $ value = self :: $ testValue ; } } if ( trim ( $ value ) == '' ) { $ value = $ defaultValue ; } if ( trim ( $ value ) == '' ) { self :: writeln ( '' ) ; self :: block ( '[ERROR] A value is required' , 'error' ) ; } self :: writeln ( '' ) ; } return trim ( $ value ) ; }
2448	public function sendNotifications ( $ varValue ) { if ( $ varValue ) { Contao \ Comments :: notifyCommentsSubscribers ( Contao \ CommentsModel :: findByPk ( Contao \ Input :: get ( 'id' ) ) ) ; } return $ varValue ; }
1045	public static function createFromException ( $ e , $ debug = false , $ internalErrorMessage = null ) { Utils :: invariant ( $ e instanceof Exception || $ e instanceof Throwable , 'Expected exception, got %s' , Utils :: getVariableType ( $ e ) ) ; $ internalErrorMessage = $ internalErrorMessage ? : self :: $ internalErrorMessage ; if ( $ e instanceof ClientAware ) { $ formattedError = [ 'message' => $ e -> isClientSafe ( ) ? $ e -> getMessage ( ) : $ internalErrorMessage , 'extensions' => [ 'category' => $ e -> getCategory ( ) , ] , ] ; } else { $ formattedError = [ 'message' => $ internalErrorMessage , 'extensions' => [ 'category' => Error :: CATEGORY_INTERNAL , ] , ] ; } if ( $ e instanceof Error ) { $ locations = Utils :: map ( $ e -> getLocations ( ) , static function ( SourceLocation $ loc ) { return $ loc -> toSerializableArray ( ) ; } ) ; if ( ! empty ( $ locations ) ) { $ formattedError [ 'locations' ] = $ locations ; } if ( ! empty ( $ e -> path ) ) { $ formattedError [ 'path' ] = $ e -> path ; } if ( ! empty ( $ e -> getExtensions ( ) ) ) { $ formattedError [ 'extensions' ] = $ e -> getExtensions ( ) + $ formattedError [ 'extensions' ] ; } } if ( $ debug ) { $ formattedError = self :: addDebugEntries ( $ formattedError , $ e , $ debug ) ; } return $ formattedError ; }
8391	public function addFullOuterJoin ( $ table , $ on ) { $ this -> fullOuterJoins [ ] = array ( 'table' => $ table , 'on' => ( $ on instanceof Condition ? $ on : new Condition ( $ on ) ) ) ; return $ this ; }
1282	public function getField ( string $ fieldId , bool $ tryCaseInsensitive = false ) { if ( isset ( $ this -> fields [ $ fieldId ] ) ) { return $ this -> fields [ $ fieldId ] ; } if ( $ tryCaseInsensitive ) { foreach ( $ this -> fields as $ name => $ field ) { if ( \ mb_strtolower ( $ name ) === \ mb_strtolower ( $ fieldId ) ) { return $ field ; } } } return null ; }
3547	public function boot ( ) { $ this -> loadViewsFrom ( realpath ( __DIR__ . '/../views' ) , 'entrust-gui' ) ; $ this -> setupRoutes ( $ this -> app -> router ) ; $ this -> loadTranslationsFrom ( realpath ( __DIR__ . '/../translations' ) , 'entrust-gui' ) ; $ this -> publishes ( [ __DIR__ . '/../config/entrust-gui.php' => config_path ( 'entrust-gui.php' ) ] , 'config' ) ; $ this -> publishes ( [ __DIR__ . '/../views' => base_path ( 'resources/views/vendor/entrust-gui' ) ] , 'views' ) ; $ this -> publishes ( [ __DIR__ . '/../translations' => base_path ( 'resources/lang/vendor/entrust-gui' ) ] , 'translations' ) ; $ this -> commands ( 'command.entrust-gui.models' ) ; }
11124	public static function create ( $ notify ) { switch ( true ) { case $ notify === NotifyInterface :: STDOUT : return new NotifyStdout ( ) ; case $ notify === NotifyInterface :: LOGGER : return new NotifyLogger ( PrettyLogger :: create ( ) ) ; case $ notify === NotifyInterface :: BLACKHOLE : return new NotifyBlackhole ( ) ; case $ notify instanceof Output : return new NotifyConsole ( $ notify ) ; case $ notify instanceof LoggerInterface : return new NotifyLogger ( $ notify ) ; default : throw InvalidArgumentException :: forNotSupportedNotifier ( ) ; } }
9649	public function getMapping ( $ className ) { $ mapping = null ; if ( null != $ this -> originalDriver ) { if ( $ this -> originalDriver instanceof FileDriver ) { $ mapping = $ this -> originalDriver -> getElement ( $ className ) ; } } if ( null == $ mapping ) { $ mappings = $ this -> loadMappingFile ( $ this -> locator -> findMappingFile ( $ className ) ) ; $ mapping = $ mappings [ $ className ] ; } return $ mapping ; }
9010	public function char ( int $ size = 36 , string $ charset = null ) : self { $ this -> type = 'char(' . $ size . ')' . $ this -> stringOptions ( $ charset ) ; return $ this ; }
9928	protected function valueIsEmpty ( $ value ) { return ( is_object ( $ value ) && $ value instanceof Parameters && $ value -> isEmpty ( ) ) || ( is_array ( $ value ) && ! count ( $ value ) ) ; }
12548	public function getThemePlugin ( $ name ) { if ( ! array_key_exists ( $ name , $ this -> themes ) ) { return null ; } return $ this -> themes [ $ name ] ; }
784	protected function validateCache ( $ lastModified , $ etag ) { if ( Yii :: $ app -> request -> headers -> has ( 'If-None-Match' ) ) { return $ etag !== null && in_array ( $ etag , Yii :: $ app -> request -> getETags ( ) , true ) ; } elseif ( Yii :: $ app -> request -> headers -> has ( 'If-Modified-Since' ) ) { return $ lastModified !== null && @ strtotime ( Yii :: $ app -> request -> headers -> get ( 'If-Modified-Since' ) ) >= $ lastModified ; } return false ; }
2501	private function getFacetParams ( array $ facetBuilders ) { $ facetSets = array_map ( function ( $ facetBuilder ) { return $ this -> facetBuilderVisitor -> visitBuilder ( $ facetBuilder , spl_object_hash ( $ facetBuilder ) ) ; } , $ facetBuilders ) ; $ facetParams = array ( ) ; foreach ( $ facetSets as $ facetSet ) { foreach ( $ facetSet as $ key => $ value ) { if ( isset ( $ facetParams [ $ key ] ) ) { if ( ! is_array ( $ facetParams [ $ key ] ) ) { $ facetParams [ $ key ] = array ( $ facetParams [ $ key ] ) ; } $ facetParams [ $ key ] [ ] = $ value ; } else { $ facetParams [ $ key ] = $ value ; } } } return $ facetParams ; }
5568	public function put ( $ url , $ parameters = false , $ content_type = false ) { if ( ! is_object ( $ url ) ) { $ url = new SimpleUrl ( $ url ) ; } return $ this -> load ( $ url , new SimplePutEncoding ( $ parameters , $ content_type ) ) ; }
5811	public function updateCMSFields ( FieldList $ fields ) { $ fields -> removeByName ( 'FusionTags' ) ; $ types = array ( ) ; foreach ( singleton ( 'FusionService' ) -> getFusionTagTypes ( ) as $ type => $ field ) { $ types [ $ type ] = $ type ; } $ types = array_intersect ( $ this -> owner -> many_many ( ) , $ types ) ; if ( empty ( $ types ) ) { $ fields -> addFieldToTab ( 'Root.Tagging' , ListboxField :: create ( 'FusionTags' , 'Tags' , FusionTag :: get ( ) -> map ( ) -> toArray ( ) ) -> setMultiple ( true ) ) ; } $ this -> owner -> extend ( 'updateTaggingExtensionCMSFields' , $ fields ) ; }
4342	public function start ( ) { if ( $ this -> isProfiling ) { return false ; } $ backtrace = \ debug_backtrace ( DEBUG_BACKTRACE_IGNORE_ARGS ) ; $ backtrace = $ this -> backtraceRemoveInternal ( $ backtrace ) ; foreach ( $ backtrace as $ frame ) { $ class = isset ( $ frame [ 'class' ] ) ? $ frame [ 'class' ] . '::' : '' ; $ this -> rootStack [ ] = $ class . $ frame [ 'function' ] ; } \ register_tick_function ( array ( $ this , 'tickFunction' ) ) ; $ this -> isProfiling = true ; $ this -> timeLastTick = \ microtime ( true ) ; return true ; }
9050	private static function checkLevel ( $ level ) { if ( $ level != LogLevel :: ALERT && $ level != LogLevel :: CRITICAL && $ level != LogLevel :: DEBUG && $ level != LogLevel :: EMERGENCY && $ level != LogLevel :: ERROR && $ level != LogLevel :: INFO && $ level != LogLevel :: NOTICE && $ level != LogLevel :: WARNING ) { throw new \ Psr \ Log \ InvalidArgumentException ( "Invalid log level provided!" ) ; } }
3450	public function getDirectChildren ( array $ filter = [ ] ) { return static :: query ( ) -> filter ( $ filter ) -> filter ( [ 'SECTION_ID' => $ this -> id ] ) -> select ( 'ID' ) -> getList ( ) -> transform ( function ( $ section ) { return ( int ) $ section [ 'ID' ] ; } ) -> all ( ) ; }
5835	private function clearExpiredCacheEntries ( int $ now ) { $ this -> now = $ now ; foreach ( $ this -> cacheTimeouts as $ path => $ timeout ) { if ( $ now <= $ timeout ) { break ; } $ fileInfo = $ this -> cache [ $ path ] ; unset ( $ this -> cache [ $ path ] , $ this -> cacheTimeouts [ $ path ] ) ; $ this -> bufferedFileCount -= isset ( $ fileInfo -> buffer ) ; $ this -> cacheEntryCount -- ; } }
10124	private function writeGridset ( ) { $ record = 0x0082 ; $ length = 0x0002 ; $ fGridSet = ! $ this -> phpSheet -> getPrintGridlines ( ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ fGridSet ) ; $ this -> append ( $ header . $ data ) ; }
12418	static function run_php_loc_report ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { $ opts = self :: getOpts ( @ $ args [ 0 ] , @ $ args [ 1 ] , $ cliopts ) ; if ( ! SharedLock :: acquire ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ) throw new PakeException ( "Source code locked by another process" ) ; $ destdir = self :: getReportDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ; $ phploc = self :: getTool ( 'phploc' , $ opts , true ) ; $ out = pake_sh ( "$phploc -n " . escapeshellarg ( self :: getBuildDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ) ) ; pake_mkdirs ( $ destdir ) ; pake_write_file ( $ destdir . '/phploc.txt' , $ out , true ) ; SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; }
10761	public function encodeString ( $ string ) { $ string = strtolower ( $ string ) ; $ src = "abcdefghijklmnopqrstuvwxyz0123456789 " ; $ dst = "jklmnopqrstuvwxyz0123456789abcdefghi " ; for ( $ i = 0 ; $ i < strlen ( $ string ) ; $ i ++ ) { $ pos = strpos ( $ src , $ string [ $ i ] ) ; if ( $ pos === false ) { throw new \ Exception ( "Please provide only numbers and alphanumerical characters" ) ; } $ string [ $ i ] = $ dst [ $ pos ] ; } return $ string ; }
10202	public function setHorizontal ( $ pValue ) { if ( $ pValue == '' ) { $ pValue = self :: HORIZONTAL_GENERAL ; } if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'horizontal' => $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> horizontal = $ pValue ; } return $ this ; }
10852	public function echo ( $ type , $ content ) { if ( $ this -> option ( 'debug' ) == false ) { return ; } if ( trim ( $ content ) ) { $ this -> { $ type } ( $ content ) ; } }
10771	public function registerMediaType ( $ mediaType ) { if ( $ this -> check ( $ mediaType ) ) { $ this -> mediaTypes [ ( new \ ReflectionClass ( $ mediaType ) ) -> getConstant ( 'NAME' ) ] = $ mediaType ; return $ this ; } else { throw new \ Exception ( 'registered MediaType must implement \MandarinMedien\MMMediaBundle\Model\MediaTypeInterface' ) ; } }
10459	public function finish ( $ outputStat = true ) { if ( $ outputStat === true ) { $ this -> output -> writeln ( '' ) ; $ this -> output -> writeln ( sprintf ( '<info>Job finished in %.2f s</info>' , microtime ( true ) - $ this -> start ) ) ; $ this -> output -> writeln ( sprintf ( '<info>Memory usage: %.2f MB</info>' , memory_get_peak_usage ( ) >> 20 ) ) ; } else { $ end = microtime ( true ) ; return [ 'start' => $ this -> start , 'finish' => $ end , 'duration' => $ end - $ this -> start , 'memory_peak' => memory_get_peak_usage ( ) >> 20 , ] ; } }
464	public function buildNotCondition ( $ operator , $ operands , & $ params ) { array_unshift ( $ operands , $ operator ) ; return $ this -> buildCondition ( $ operands , $ params ) ; }
9467	protected function initializer ( string $ key , array $ storage ) : void { $ this -> _name = $ key ; $ this -> attached ( $ storage ) ; }
3753	public function save ( ModelInterface $ objItem , $ timestamp = null ) { if ( null === $ timestamp ) { @ \ trigger_error ( 'Not passing a timestamp has been deprecated and will cause an error in MetaModels 3' , E_USER_DEPRECATED ) ; } if ( $ objItem instanceof Model ) { $ backupLanguage = $ this -> setLanguage ( $ this -> getCurrentLanguage ( ) ) ; $ objItem -> getItem ( ) -> save ( $ timestamp ) ; $ this -> setLanguage ( $ backupLanguage ) ; return $ objItem ; } throw new \ RuntimeException ( 'ERROR: incompatible object passed to GeneralDataMetaModel::save()' ) ; }
8572	private function _convertListRecommendations ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'ListRecommendations' ; if ( $ request -> isSetMarketplaceId ( ) ) { $ parameters [ 'MarketplaceId' ] = $ request -> getMarketplaceId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } if ( $ request -> isSetSellerId ( ) ) { $ parameters [ 'SellerId' ] = $ request -> getSellerId ( ) ; } if ( $ request -> isSetRecommendationCategory ( ) ) { $ parameters [ 'RecommendationCategory' ] = $ request -> getRecommendationCategory ( ) ; } if ( $ request -> isSetCategoryQueryList ( ) ) { $ parameters [ 'CategoryQueryList' ] = $ request -> getCategoryQueryList ( ) ; } return $ parameters ; }
6234	protected function applyAccessMode ( int $ mode ) : void { if ( $ this -> mode === self :: MODE_CLOSED ) { $ this -> mode = $ mode ; return ; } elseif ( $ mode === $ this -> mode ) { return ; } throw new AccessDeniedException ( 'unable to switch access-mode for existing binary file handle' , 500 ) ; }
8055	public static function get ( $ length = 8 , $ outputFormat = Code :: FORMAT_ALNUM ) { static :: throwUnlessAcceptable ( $ outputFormat , $ length ) ; $ number = rand ( 100 , 900 ) . str_replace ( '.' , '' , microtime ( true ) ) ; $ output = self :: convertBase ( $ number , self :: FORMAT_NUMBER , $ outputFormat ) ; if ( strlen ( $ output ) < $ length ) { $ output .= substr ( str_shuffle ( $ outputFormat . $ outputFormat ) , 0 , ( $ length - strlen ( $ output ) ) ) ; } if ( strlen ( $ output ) > $ length ) { $ output = substr ( $ output , 0 , $ length ) ; } return $ output ; }
6965	public function isIdentityEmpty ( ) { return empty ( $ this -> gender ) && empty ( $ this -> firstName ) && empty ( $ this -> lastName ) ; }
5702	public function isCustomActionAllowed ( $ action ) { $ actions = $ this -> owner -> config ( ) -> better_buttons_actions ; if ( $ actions ) { return in_array ( $ action , $ actions ) ; } return false ; }
4402	protected function getProvider ( ) { $ config = $ this -> getServiceItem ( ) -> getConfig ( ) ; $ config [ 'apiKey' ] = $ this -> getServiceItem ( ) -> getConfigValue ( 'stripe.apiKey' ) ; if ( ! isset ( $ this -> provider ) ) { $ this -> provider = OPay :: create ( 'Stripe' ) ; $ this -> provider -> setTestMode ( ( bool ) $ this -> getValue ( 'testmode' , false ) ) ; $ this -> provider -> initialize ( $ config ) ; } return $ this -> provider ; }
1423	protected function with ( $ query , EncodingParametersInterface $ parameters ) { $ query -> with ( $ this -> getRelationshipPaths ( ( array ) $ parameters -> getIncludePaths ( ) ) ) ; }
5036	public function indexAction ( ) { $ events = $ this -> adminControllerEvents ; $ event = $ events -> getEvent ( AdminControllerEvent :: EVENT_DASHBOARD , $ this ) ; $ events -> trigger ( $ event , $ this ) ; $ model = new ViewModel ( ) ; $ widgets = [ ] ; foreach ( $ event -> getViewModels ( ) as $ name => $ child ) { $ model -> addChild ( $ child , $ name ) ; $ widgets [ ] = $ name ; } $ model -> setVariable ( 'widgets' , $ widgets ) ; return $ model ; }
1058	public static function findTypesRemovedFromUnions ( Schema $ oldSchema , Schema $ newSchema ) { $ oldTypeMap = $ oldSchema -> getTypeMap ( ) ; $ newTypeMap = $ newSchema -> getTypeMap ( ) ; $ typesRemovedFromUnion = [ ] ; foreach ( $ oldTypeMap as $ typeName => $ oldType ) { $ newType = $ newTypeMap [ $ typeName ] ?? null ; if ( ! ( $ oldType instanceof UnionType ) || ! ( $ newType instanceof UnionType ) ) { continue ; } $ typeNamesInNewUnion = [ ] ; foreach ( $ newType -> getTypes ( ) as $ type ) { $ typeNamesInNewUnion [ $ type -> name ] = true ; } foreach ( $ oldType -> getTypes ( ) as $ type ) { if ( isset ( $ typeNamesInNewUnion [ $ type -> name ] ) ) { continue ; } $ typesRemovedFromUnion [ ] = [ 'type' => self :: BREAKING_CHANGE_TYPE_REMOVED_FROM_UNION , 'description' => sprintf ( '%s was removed from union type %s.' , $ type -> name , $ typeName ) , ] ; } } return $ typesRemovedFromUnion ; }
8965	public function rewriteCountQuery ( $ query ) { if ( \ preg_match ( '/^\s*SELECT\s+\bDISTINCT\b/is' , $ query ) || \ preg_match ( '/\s+GROUP\s+BY\s+/is' , $ query ) ) { return '' ; } $ openParenthesis = '(?:\()' ; $ closeParenthesis = '(?:\))' ; $ subQueryInSelect = $ openParenthesis . '.*\bFROM\b.*' . $ closeParenthesis ; $ pattern = '/(?:.*' . $ subQueryInSelect . '.*)\bFROM\b\s+/Uims' ; if ( \ preg_match ( $ pattern , $ query ) ) { return '' ; } $ subQueryWithLimitOrder = $ openParenthesis . '.*\b(LIMIT|ORDER)\b.*' . $ closeParenthesis ; $ pattern = '/.*\bFROM\b.*(?:.*' . $ subQueryWithLimitOrder . '.*).*/Uims' ; if ( \ preg_match ( $ pattern , $ query ) ) { return '' ; } $ queryCount = \ preg_replace ( '/(?:.*)\bFROM\b\s+/Uims' , 'SELECT COUNT(*) FROM ' , $ query , 1 ) ; list ( $ queryCount ) = \ preg_split ( '/\s+ORDER\s+BY\s+/is' , $ queryCount ) ; list ( $ queryCount ) = \ preg_split ( '/\bLIMIT\b/is' , $ queryCount ) ; return \ trim ( $ queryCount ) ; }
1520	public function removeFromRelationship ( StoreInterface $ store , UpdateRelationship $ request ) { $ result = $ this -> transaction ( function ( ) use ( $ store , $ request ) { return $ this -> doRemoveFromRelationship ( $ store , $ request ) ; } ) ; if ( $ this -> isResponse ( $ result ) ) { return $ result ; } return $ this -> reply ( ) -> noContent ( ) ; }
7719	function meth_Conv_Str ( & $ Txt , $ ConvBr = true ) { if ( $ this -> Charset === '' ) { $ Txt = htmlspecialchars ( $ Txt ) ; if ( $ ConvBr ) $ Txt = nl2br ( $ Txt ) ; } elseif ( $ this -> _CharsetFct ) { $ Txt = call_user_func ( $ this -> Charset , $ Txt , $ ConvBr ) ; } else { $ Txt = htmlspecialchars ( $ Txt , ENT_COMPAT , $ this -> Charset ) ; if ( $ ConvBr ) $ Txt = nl2br ( $ Txt ) ; } }
9185	protected function toArray ( $ data , $ type , $ format ) { $ serializer = SerializerBuilder :: create ( ) -> build ( ) ; return $ serializer -> toArray ( $ serializer -> deserialize ( $ data , $ type , $ format ) ) ; }
3605	private function isCacheSupport ( JsonRequest $ jsonRequest ) { try { return $ jsonRequest -> getId ( ) && null !== $ this -> getMethod ( $ jsonRequest ) -> getCache ( ) && ! $ this -> isDebug ( ) && $ this -> getCache ( ) ; } catch ( \ Exception $ e ) { return false ; } }
10418	public static function extract ( $ yamlArray , $ key , $ needed = false ) { if ( ! empty ( $ yamlArray ) && array_key_exists ( $ key , $ yamlArray ) ) return $ yamlArray [ $ key ] ; if ( $ needed ) { throw new \ Deployer \ Exception \ Exception ( 'Cannot find the setting: ' . $ key . '. This key needs to be given!' ) ; } return null ; }
8553	public function setDebtRecoveryEventList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'DebtRecoveryEventList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
2580	protected function loadWsdl ( $ params ) { if ( isset ( $ params [ 'wsdl' ] ) ) { if ( is_string ( $ params [ 'wsdl' ] ) ) { $ this -> wsdl = [ $ params [ 'wsdl' ] ] ; } elseif ( is_array ( $ params [ 'wsdl' ] ) ) { $ this -> wsdl = $ params [ 'wsdl' ] ; } } }
2127	protected function fixPaths ( $ content , $ arrFile ) { $ strName = $ arrFile [ 'name' ] ; if ( strpos ( $ strName , $ this -> strWebDir . '/' ) === 0 ) { $ strName = substr ( $ strName , \ strlen ( $ this -> strWebDir ) + 1 ) ; } $ strDirname = \ dirname ( $ strName ) ; $ strGlue = ( $ strDirname != '.' ) ? $ strDirname . '/' : '' ; return preg_replace_callback ( '/url\(("[^"\n]+"|\'[^\'\n]+\'|[^"\'\s()]+)\)/' , function ( $ matches ) use ( $ strDirname , $ strGlue ) { $ strData = $ matches [ 1 ] ; if ( $ strData [ 0 ] == '"' || $ strData [ 0 ] == "'" ) { $ strData = substr ( $ strData , 1 , - 1 ) ; } if ( strncmp ( $ strData , 'data:' , 5 ) === 0 || strncmp ( $ strData , 'http://' , 7 ) === 0 || strncmp ( $ strData , 'https://' , 8 ) === 0 || strncmp ( $ strData , '/' , 1 ) === 0 || strncmp ( $ strData , 'assets/css3pie/' , 15 ) === 0 ) { return $ matches [ 0 ] ; } if ( strncmp ( $ strData , '../' , 3 ) !== 0 ) { $ strData = '../../' . $ strGlue . $ strData ; } else { $ dir = $ strDirname ; while ( strncmp ( $ strData , '../' , 3 ) === 0 ) { $ dir = \ dirname ( $ dir ) ; $ strData = substr ( $ strData , 3 ) ; } $ glue = ( $ dir != '.' ) ? $ dir . '/' : '' ; $ strData = '../../' . $ glue . $ strData ; } $ strQuote = '' ; if ( $ matches [ 1 ] [ 0 ] == "'" || $ matches [ 1 ] [ 0 ] == '"' ) { $ strQuote = $ matches [ 1 ] [ 0 ] ; } if ( preg_match ( '/[(),\s"\']/' , $ strData ) ) { if ( $ matches [ 1 ] [ 0 ] == "'" ) { $ strData = str_replace ( "'" , "\\'" , $ strData ) ; } else { $ strQuote = '"' ; $ strData = str_replace ( '"' , '\"' , $ strData ) ; } } return 'url(' . $ strQuote . $ strData . $ strQuote . ')' ; } , $ content ) ; }
10487	public function applyMapping ( $ params , $ mapping ) { $ newParams = [ ] ; foreach ( $ params as $ key => $ value ) { $ newParams [ $ mapping [ $ key ] ] = $ value ; } return $ newParams ; }
7059	public function addClass ( $ class ) { $ classes = $ this -> getClasses ( ) ; if ( ! in_array ( $ class , $ classes ) ) { $ classes [ ] = $ class ; } $ this -> setClasses ( $ classes ) ; return $ this ; }
11013	protected function importDataFile ( string $ dataFile , string $ controlTableName = null ) : void { if ( $ controlTableName !== null ) { $ query = $ this -> db -> createQueryBuilder ( ) ; $ query -> select ( 'count(*) AS count' ) -> from ( $ controlTableName ) ; $ data = $ query -> execute ( ) -> fetchAll ( ) ; $ contentCount = ( int ) $ data [ 0 ] [ 'count' ] ; if ( $ contentCount > 0 ) { $ this -> output -> writeln ( '<comment>Data already exists in the database, skipping data import for file <info>' . $ dataFile . '</info></comment>' ) ; return ; } } $ this -> runQueriesFromFile ( $ dataFile ) ; }
5089	public function queryMapRow ( $ key = 0 , $ removeColumnFromRow = false ) { $ fetchMode = $ this -> resolveFetchMode ( is_string ( $ key ) ) ; $ result = $ this -> execute ( ) ; $ map = [ ] ; try { while ( $ row = $ result -> fetch ( $ fetchMode ) ) { if ( ! isset ( $ row [ $ key ] ) ) throw new MySqlException ( "Key '$key' column not found in the query result: " . implode ( array_keys ( $ row ) ) ) ; if ( $ removeColumnFromRow ) { $ map [ $ row [ $ key ] ] = $ row ; unset ( $ map [ $ row [ $ key ] ] [ $ key ] ) ; } else { $ map [ $ row [ $ key ] ] = $ row ; } } } finally { $ result -> closeCursor ( ) ; } return $ map ; }
8297	protected function createBkFile ( ) { if ( ! is_writable ( dirname ( $ this -> filePath ) ) ) { return ; } $ this -> bkFilePath = $ this -> filePath . '.' . date ( "y-m-d-H-i-s" ) . '.bak' ; $ bkHandle = @ fopen ( $ this -> bkFilePath , 'x+' ) ; if ( $ bkHandle === false ) { $ this -> close ( ) ; throw new \ RuntimeException ( "Could not create a temporary file " . $ this -> bkFilePath ) ; } $ stat = fstat ( $ this -> handle ) ; if ( stream_copy_to_stream ( $ this -> handle , $ bkHandle ) !== $ stat [ 'size' ] ) { $ this -> close ( ) ; throw new \ RuntimeException ( "Could not create a copy of " . $ this -> filePath ) ; } if ( ! fclose ( $ bkHandle ) ) { throw new \ RuntimeException ( "Could not close a backup file " . $ this -> bkFilePath ) ; } fseek ( $ this -> handle , 0 ) ; }
4417	public function showLocationLayouts ( $ locationId ) { $ repository = $ this -> getRepository ( ) ; $ location = $ repository -> getLocationService ( ) -> loadLocation ( $ locationId ) ; $ content = $ repository -> getContentService ( ) -> loadContent ( $ location -> contentInfo -> id ) ; $ request = $ this -> createRequest ( $ content , $ location ) ; return $ this -> render ( '@NetgenAdminUI/layouts/location_layouts.html.twig' , array ( 'rules' => $ this -> layoutResolver -> resolveRules ( $ request , array ( 'ez_content_type' ) ) , 'related_layouts' => $ this -> relatedLayoutsLoader -> loadRelatedLayouts ( $ location ) , 'location' => $ location , ) ) ; }
478	public function dropColumn ( $ table , $ column ) { $ time = $ this -> beginCommand ( "drop column $column from table $table" ) ; $ this -> db -> createCommand ( ) -> dropColumn ( $ table , $ column ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
10207	public function get ( $ resourcePath , $ queryParameters = array ( ) , $ mimeType = 'application/vnd.maileon.api+xml' , $ deserializationType = null ) { $ curlSession = $ this -> prepareSession ( $ resourcePath , $ queryParameters , $ mimeType ) ; return $ this -> performRequest ( $ curlSession , $ deserializationType ) ; }
11390	public function getStatus ( ) { if ( isset ( $ this -> _log ) ) { $ this -> _status = $ this -> log -> statusLog ; } elseif ( ! isset ( $ this -> _status ) ) { $ this -> _status = new Status ( $ this -> log ) ; } return $ this -> _status ; }
4796	protected function execute ( ) { if ( ! isset ( $ this -> rows ) ) { $ result = false ; $ exception = null ; $ parameters = array ( ) ; foreach ( array_merge ( $ this -> select , array ( $ this , $ this -> group , $ this -> having ) , $ this -> order , $ this -> unionOrder ) as $ val ) { if ( ( $ val instanceof NotORM_Literal || $ val instanceof self ) && $ val -> parameters ) { $ parameters = array_merge ( $ parameters , $ val -> parameters ) ; } } try { $ result = $ this -> query ( $ this -> __toString ( ) , $ parameters ) ; } catch ( PDOException $ exception ) { } if ( ! $ result ) { if ( ! $ this -> select && $ this -> accessed ) { $ this -> accessed = '' ; $ this -> access = array ( ) ; $ result = $ this -> query ( $ this -> __toString ( ) , $ parameters ) ; } elseif ( $ exception ) { throw $ exception ; } } $ this -> rows = array ( ) ; if ( $ result ) { $ result -> setFetchMode ( PDO :: FETCH_ASSOC ) ; foreach ( $ result as $ key => $ row ) { if ( isset ( $ row [ $ this -> primary ] ) ) { $ key = $ row [ $ this -> primary ] ; if ( ! is_string ( $ this -> access ) ) { $ this -> access [ $ this -> primary ] = true ; } } if ( $ this -> notORM -> isKeepPrimaryKeyIndex ) { $ this -> rows [ $ key ] = $ row ; } else { $ this -> rows [ ] = $ row ; } } } $ this -> data = $ this -> rows ; } }
7494	public function trimRight ( $ characters = null ) { $ this -> string = rtrim ( $ this -> string , $ characters ) ; return $ this ; }
7285	protected function initializeInvoiceSubject ( ) { $ this -> invoiceTotal = 0 ; $ this -> creditTotal = 0 ; $ this -> invoiceState = InvoiceStates :: STATE_NEW ; $ this -> invoices = new ArrayCollection ( ) ; }
8060	private function createWorker ( $ i ) { $ sockets = array ( ) ; if ( socket_create_pair ( AF_UNIX , SOCK_STREAM , 0 , $ sockets ) === FALSE ) { throw new \ RuntimeException ( 'socket_create_pair failed.' ) ; return ; } $ processId = pcntl_fork ( ) ; if ( $ processId < 0 ) { throw new \ RuntimeException ( 'pcntl_fork failed.' ) ; return ; } elseif ( $ processId === 0 ) { $ this -> workerProcesses = new ProcessDetailsCollection ( ) ; $ this -> workerPoolSize = 0 ; socket_close ( $ sockets [ 1 ] ) ; $ this -> runWorkerProcess ( $ this -> worker , new SimpleSocket ( $ sockets [ 0 ] ) , $ i ) ; } else { socket_close ( $ sockets [ 0 ] ) ; $ this -> workerProcesses -> addFree ( new ProcessDetails ( $ processId , new SimpleSocket ( $ sockets [ 1 ] ) ) ) ; } }
12051	protected function _createRendererException ( $ message = null , $ code = null , RootException $ previous = null , RendererInterface $ renderer = null ) { return new RendererException ( $ message , $ code , $ previous , $ renderer ) ; }
10934	protected function is_php ( $ version ) { static $ _is_php ; $ version = ( string ) $ version ; if ( ! isset ( $ _is_php [ $ version ] ) ) { $ _is_php [ $ version ] = version_compare ( PHP_VERSION , $ version , '>=' ) ; } return $ _is_php [ $ version ] ; }
5076	public function getIndex ( $ aData = [ ] , $ iPage = null , $ iPerPage = null ) { $ oInput = Factory :: service ( 'Input' ) ; $ oItemModel = Factory :: model ( static :: CONFIG_MODEL_NAME , static :: CONFIG_MODEL_PROVIDER ) ; if ( is_null ( $ iPage ) ) { $ iPage = ( int ) $ oInput -> get ( 'page' ) ? : 1 ; } if ( is_null ( $ iPerPage ) ) { $ iPerPage = static :: CONFIG_MAX_ITEMS_PER_PAGE ; } $ aResults = $ oItemModel -> getAll ( $ iPage , $ iPerPage , $ aData ) ; $ oResponse = Factory :: factory ( 'ApiResponse' , 'nails/module-api' ) ; $ oResponse -> setData ( array_map ( [ $ this , 'formatObject' ] , $ aResults ) ) ; return $ oResponse ; }
12306	protected function __apiUpdateStrict ( string $ id ) { HCLanguages :: where ( 'id' , $ id ) -> update ( $ this -> getStrictRequestParameters ( ) ) ; return $ this -> apiShow ( $ id ) ; }
2062	public function generateArticle ( Contao \ DataContainer $ dc ) { if ( ! $ dc -> activeRecord ) { return ; } if ( $ dc -> activeRecord -> title == '' || ! \ in_array ( $ dc -> activeRecord -> type , array ( 'regular' , 'error_401' , 'error_403' , 'error_404' ) ) ) { return ; } $ objSessionBag = Contao \ System :: getContainer ( ) -> get ( 'session' ) -> getBag ( 'contao_backend' ) ; $ new_records = $ objSessionBag -> get ( 'new_records' ) ; if ( ! $ new_records || ! \ is_array ( $ new_records [ $ dc -> table ] ) || ! \ in_array ( $ dc -> id , $ new_records [ $ dc -> table ] ) ) { return ; } $ objTotal = $ this -> Database -> prepare ( "SELECT COUNT(*) AS count FROM tl_article WHERE pid=?" ) -> execute ( $ dc -> id ) ; if ( $ objTotal -> count > 0 ) { return ; } $ arrSet [ 'pid' ] = $ dc -> id ; $ arrSet [ 'sorting' ] = 128 ; $ arrSet [ 'tstamp' ] = time ( ) ; $ arrSet [ 'author' ] = $ this -> User -> id ; $ arrSet [ 'inColumn' ] = 'main' ; $ arrSet [ 'title' ] = $ dc -> activeRecord -> title ; $ arrSet [ 'alias' ] = str_replace ( '/' , '-' , $ dc -> activeRecord -> alias ) ; $ arrSet [ 'published' ] = $ dc -> activeRecord -> published ; $ this -> Database -> prepare ( "INSERT INTO tl_article %s" ) -> set ( $ arrSet ) -> execute ( ) ; }
10441	protected function getLineType ( $ line ) { if ( preg_match ( '/^###\s+@[0-9]+=.*$/' , $ line ) ) { return self :: LINE_TYPE_PARAM ; } elseif ( preg_match ( '/^###/' , $ line ) ) { return self :: LINE_TYPE_QUERY ; } elseif ( preg_match ( '/^#[0-9]/' , $ line ) ) { return self :: LINE_TYPE_META ; } elseif ( preg_match ( '/Errcode|ERROR/' , $ line ) ) { return self :: LINE_TYPE_ERROR ; } return self :: LINE_TYPE_UNKNOWN ; }
181	public function getConverter ( ) { if ( $ this -> _converter === null ) { $ this -> _converter = Yii :: createObject ( AssetConverter :: className ( ) ) ; } elseif ( is_array ( $ this -> _converter ) || is_string ( $ this -> _converter ) ) { if ( is_array ( $ this -> _converter ) && ! isset ( $ this -> _converter [ 'class' ] ) ) { $ this -> _converter [ 'class' ] = AssetConverter :: className ( ) ; } $ this -> _converter = Yii :: createObject ( $ this -> _converter ) ; } return $ this -> _converter ; }
3406	public function loadCommands ( string $ path , string $ namespace = "" , string $ suffix = "Command" ) : Application { $ commands = [ ] ; $ realpath = ( string ) realpath ( $ path ) ; $ finder = ( new Finder ( ) ) -> files ( ) -> in ( $ path ) -> name ( "/[A-Z].*{$suffix}.php/" ) ; foreach ( $ finder as $ file ) { $ filename = ( string ) $ file -> getRealPath ( ) ; require_once $ filename ; $ class = $ filename ; $ class = str_replace ( $ realpath , "" , $ class ) ; $ class = str_replace ( ".php" , "" , $ class ) ; $ class = str_replace ( "/" , "\\" , $ class ) ; $ command = $ class ; if ( substr ( $ command , 0 , 1 ) == "\\" ) { $ command = substr ( $ command , 1 ) ; } $ command = ( string ) preg_replace_callback ( "/^([A-Z])(.*){$suffix}$/" , function ( $ match ) { return strtolower ( $ match [ 1 ] ) . $ match [ 2 ] ; } , $ command ) ; $ command = preg_replace_callback ( "/(\\\\)?([A-Z])/" , function ( $ match ) { $ result = ( $ match [ 1 ] ) ? ":" : "-" ; $ result .= strtolower ( $ match [ 2 ] ) ; return $ result ; } , $ command ) ; $ class = $ namespace . $ class ; $ reflected = new \ ReflectionClass ( $ class ) ; if ( ! $ reflected -> isInstantiable ( ) ) { continue ; } $ commands [ ] = new $ class ( $ command ) ; } if ( count ( $ commands ) < 1 ) { throw new \ InvalidArgumentException ( "No commands were found in the path (" . $ path . ")" ) ; } $ this -> addCommands ( $ commands ) ; return $ this ; }
3681	public function getJumpTo ( ) { if ( ! isset ( $ this -> arrJumpTo ) ) { $ page = $ GLOBALS [ 'objPage' ] ; $ this -> setJumpTo ( $ page -> row ( ) ) ; if ( $ this -> metamodel_jumpTo ) { $ statement = $ this -> getConnection ( ) -> prepare ( 'SELECT id, alias FROM tl_page WHERE id=? LIMIT 0,1' ) ; $ statement -> bindValue ( 1 , $ this -> metamodel_jumpTo ) ; $ statement -> execute ( ) ; if ( $ statement -> rowCount ( ) ) { $ this -> setJumpTo ( $ statement -> fetch ( \ PDO :: FETCH_ASSOC ) ) ; } } } return $ this -> arrJumpTo ; }
7298	public function append_signature ( $ message , $ signature = '' ) { if ( empty ( $ signature ) ) { return $ message ; } $ separator = apply_filters ( 'iac_signature_separator' , str_repeat ( PHP_EOL , 2 ) . '--' . PHP_EOL ) ; return $ message . $ separator . $ signature ; }
8823	public function rule ( $ field , $ label , $ rules , array $ text = [ ] ) { $ this -> labels [ $ field ] = $ label ; $ this -> rules [ $ field ] = $ rules ; $ this -> texts [ $ field ] = ( ! empty ( $ text ) ? $ text : null ) ; }
5118	public function deleteAttachment ( string $ idArticle , string $ field , string $ order ) : string { return $ this -> delete ( $ this -> getAttachmentEndPoint ( $ idArticle , $ field ) . "/${order}" ) ; }
6831	protected function synchronizeWithProduct ( SupplierOrderItemInterface $ item ) { $ changed = false ; if ( null !== $ product = $ item -> getProduct ( ) ) { $ productSID = $ product -> getSubjectIdentity ( ) ; if ( $ productSID -> hasIdentity ( ) ) { $ itemSID = $ item -> getSubjectIdentity ( ) ; if ( $ itemSID -> hasIdentity ( ) ) { if ( ! $ itemSID -> equals ( $ productSID ) ) { throw new LogicException ( 'Breaking synchronization between supplier order item and supplier product is not supported.' ) ; } $ changed = false ; } else { $ itemSID -> copy ( $ productSID ) ; $ changed = true ; } } else { throw new InvalidArgumentException ( 'Supplier product subject identity is not set.' ) ; } if ( 0 == strlen ( $ item -> getDesignation ( ) ) ) { $ item -> setDesignation ( $ product -> getDesignation ( ) ) ; } if ( 0 == strlen ( $ item -> getReference ( ) ) ) { $ item -> setReference ( $ product -> getReference ( ) ) ; } if ( 0 == $ item -> getNetPrice ( ) ) { $ item -> setNetPrice ( $ product -> getNetPrice ( ) ) ; } } elseif ( $ item -> hasSubjectIdentity ( ) ) { throw new LogicException ( 'Breaking synchronization between supplier order item and supplier product is not supported.' ) ; } return $ changed ; }
2861	public function getRange ( $ logFile ) { if ( ! array_key_exists ( $ logFile , $ this -> ranges ) ) { throw new Exception ( 'Invalid log file' ) ; } return $ this -> ranges [ $ logFile ] ; }
4063	private static function calculateArrayDiff ( $ expected , $ actual , $ strict ) { if ( count ( $ expected ) !== count ( $ actual ) ) { throw new \ LogicException ( sprintf ( 'Array element count mismatch. Found %s, expected %s.' , count ( $ actual ) , count ( $ expected ) ) , self :: ARRAY_COUNT_MISMATCH ) ; } reset ( $ actual ) ; foreach ( $ expected as $ key => $ value ) { if ( $ key !== key ( $ actual ) ) { throw new \ LogicException ( sprintf ( 'Array key mismatch. Found %s, expected %s.' , key ( $ actual ) , $ key ) , self :: ARRAY_KEY_MISMATCH ) ; } try { self :: calculateDiff ( $ value , current ( $ actual ) , $ strict ) ; } catch ( \ Exception $ exception ) { throw new \ LogicException ( sprintf ( 'Array value mismatch for key %s.' , key ( $ actual ) ) , self :: ARRAY_VALUE_MISMATCH , $ exception ) ; } next ( $ actual ) ; } }
12538	public function setRelations ( $ value ) { if ( $ this -> companionObject ) { $ baseObject = $ this -> companionObject ; } else { $ baseObject = $ this -> owner ; } $ fields = $ baseObject -> getFields ( ) ; foreach ( $ value as $ tabId => $ relation ) { if ( ! isset ( $ relation [ '_moduleHandler' ] ) ) { \ d ( "boom" ) ; exit ; continue ; } if ( ! isset ( $ fields [ $ relation [ '_moduleHandler' ] ] ) ) { \ d ( $ relation [ '_moduleHandler' ] ) ; \ d ( array_keys ( $ fields ) ) ; exit ; continue ; } $ baseAttributes = [ ] ; $ model = $ fields [ $ relation [ '_moduleHandler' ] ] -> model ; if ( empty ( $ model ) ) { $ model = $ fields [ $ relation [ '_moduleHandler' ] ] -> resetModel ( ) ; } $ model -> attributes = $ relation ; $ model -> _moduleHandler = $ relation [ '_moduleHandler' ] ; $ model -> tabularId = $ relation [ '_moduleHandler' ] ; list ( $ relationship , $ role ) = $ baseObject -> objectType -> getRelationship ( $ model -> _moduleHandler ) ; $ relatedHandler = $ baseObject -> objectType -> getRelatedType ( $ model -> _moduleHandler ) ; if ( ! $ relatedHandler ) { continue ; } if ( ! $ this -> owner -> tabularId && ! $ this -> owner -> isNewRecord && empty ( $ model -> parent_object_id ) && empty ( $ model -> child_object_id ) ) { continue ; } $ this -> _relations [ $ tabId ] = $ model ; } }
9067	public static function bootUuidForKey ( ) { static :: creating ( function ( $ model ) { $ model -> incrementing = false ; $ model -> attributes [ $ model -> getKeyName ( ) ] = ( string ) Str :: orderedUuid ( ) ; } ) ; }
9065	protected function checkMVC ( ) { $ viewResolver = $ this -> sm -> get ( 'ViewResolver' ) ; $ return = true ; if ( $ viewResolver instanceof ViewResolver \ AggregateResolver ) { if ( $ viewResolver -> count ( ) == 2 ) { $ defResolvers = array ( 'Zend\View\Resolver\TemplateMapResolver' , 'Zend\View\Resolver\TemplatePathStack' ) ; foreach ( $ viewResolver -> getIterator ( ) -> toArray ( ) as $ i => $ ro ) { if ( $ defResolvers [ $ i ] != get_class ( $ ro ) ) { $ return = false ; break ; } } } else { $ return = false ; } } else { $ return = false ; } $ viewTemplatePathStack = $ this -> sm -> get ( 'ViewTemplatePathStack' ) ; if ( ! $ viewTemplatePathStack instanceof ViewResolver \ TemplatePathStack ) { throw new \ Exception ( 'yimaTheme work with PathStack' ) ; } return $ return ; }
9377	protected function extract ( $ filepath , array $ data ) { extract ( $ data ) ; ob_start ( ) ; include $ filepath ; $ contents = ob_get_contents ( ) ; ob_end_clean ( ) ; return $ contents ; }
10066	public function actionGenerate ( ) { $ input = $ this -> parseArguments ( func_get_args ( ) ) ; $ container = new Container ( ) ; $ container -> set ( GeneratorInterface :: class , array_merge ( [ 'class' => $ this -> generator_fqn ] , $ input [ 'generator' ] ) ) ; $ container -> set ( DbProviderInterface :: class , array_merge ( [ 'class' => $ this -> dbprovider_fqn ] , $ input [ 'dbprovider' ] ) ) ; $ this -> generator_obj = $ container -> get ( GeneratorInterface :: class ) ; if ( ! $ this -> force && ! $ this -> confirmGeneration ( ) ) { return ; } $ this -> dbprovider_obj = $ container -> get ( DbProviderInterface :: class ) ; Console :: startProgress ( 0 , $ this -> count ) ; foreach ( $ this -> dbprovider_obj -> export ( $ this -> count ) as $ count ) { Console :: updateProgress ( $ this -> count - $ count , $ this -> count ) ; } Console :: endProgress ( true ) ; }
4976	public static function factory ( ContainerInterface $ container ) { $ manager = $ container -> get ( 'ModuleManager' ) ; $ modules = $ manager -> getLoadedModules ( ) ; return new static ( $ modules ) ; }
4202	private function addMethodsPhpDoc ( Event $ abs ) { $ inheritedFrom = null ; if ( empty ( $ abs [ 'phpDoc' ] [ 'method' ] ) ) { if ( \ array_intersect_key ( $ abs [ 'methods' ] , \ array_flip ( array ( '__call' , '__callStatic' ) ) ) ) { $ reflector = $ abs [ 'reflector' ] ; while ( $ reflector = $ reflector -> getParentClass ( ) ) { $ parsed = $ this -> phpDoc -> getParsed ( $ reflector ) ; if ( isset ( $ parsed [ 'method' ] ) ) { $ inheritedFrom = $ reflector -> getName ( ) ; $ abs [ 'phpDoc' ] [ 'method' ] = $ parsed [ 'method' ] ; break ; } } } if ( empty ( $ abs [ 'phpDoc' ] [ 'method' ] ) ) { return ; } } foreach ( $ abs [ 'phpDoc' ] [ 'method' ] as $ phpDocMethod ) { $ className = $ inheritedFrom ? $ inheritedFrom : $ abs [ 'className' ] ; $ abs [ 'methods' ] [ $ phpDocMethod [ 'name' ] ] = array ( 'implements' => null , 'inheritedFrom' => $ inheritedFrom , 'isAbstract' => false , 'isDeprecated' => false , 'isFinal' => false , 'isStatic' => $ phpDocMethod [ 'static' ] , 'params' => \ array_map ( function ( $ param ) use ( $ className ) { $ info = $ this -> phpDocParam ( $ param , $ className ) ; return array ( 'constantName' => $ info [ 'constantName' ] , 'defaultValue' => $ info [ 'defaultValue' ] , 'desc' => null , 'name' => $ param [ 'name' ] , 'optional' => false , 'type' => $ param [ 'type' ] , ) ; } , $ phpDocMethod [ 'param' ] ) , 'phpDoc' => array ( 'summary' => $ phpDocMethod [ 'desc' ] , 'description' => null , 'return' => array ( 'type' => $ phpDocMethod [ 'type' ] , 'desc' => null , ) ) , 'visibility' => 'magic' , ) ; } unset ( $ abs [ 'phpDoc' ] [ 'method' ] ) ; return ; }
8964	private static function matchesArrayCriteria ( $ key , $ object , array $ criteria ) { $ criteria = self :: extractArrayCriteria ( $ key , $ criteria ) ; if ( count ( $ criteria ) === 0 ) { return true ; } $ getter = sprintf ( 'get%s' , ucfirst ( $ key ) ) ; if ( ! method_exists ( $ object , $ getter ) ) { throw new RuntimeException ( sprintf ( 'Object instance of "%s" does not have required getter "%s" to be used for filtering.' , get_class ( $ object ) , $ getter ) ) ; } return in_array ( $ object -> { $ getter } ( ) , $ criteria , true ) ; }
9179	public function getDatabase ( ) { if ( $ useDbId = $ this -> getUseDbId ( ) ) { return $ this -> getDatabaseById ( $ useDbId ) ; } foreach ( $ this -> databases as $ database ) { if ( $ database -> isDefault ( ) ) { return $ database ; } } if ( $ this -> databases -> count ( ) > 0 ) { return $ this -> databases -> first ( ) ; } throw new \ Exception ( 'There is no database configuration available' ) ; }
12016	public function unwatch ( ) { if ( ! $ this -> client -> getCommandFactory ( ) -> supportsCommand ( 'UNWATCH' ) ) { throw new NotSupportedException ( 'UNWATCH is not supported by the current command factory.' ) ; } $ this -> state -> unflag ( MultiExecState :: WATCH ) ; $ this -> __call ( 'UNWATCH' , array ( ) ) ; return $ this ; }
4566	public function getForms ( $ id ) { $ forms = [ ] ; $ form = $ this -> getForm ( $ id ) ; $ form -> setMethod ( 'POST' ) -> setPrimary ( true ) ; $ forms [ ] = $ form ; switch ( $ form -> getType ( ) ) { case Form :: TYPE_FORMIO : $ components = $ form -> getSchema ( ) ; $ resolverCollection = $ this -> resolverCollection ; $ extract = function ( & $ container , $ key , & $ component ) use ( & $ extract , & $ forms , $ resolverCollection ) { switch ( true ) { case property_exists ( $ component , 'components' ) : foreach ( $ component -> components as $ key => & $ subComponent ) { $ extract ( $ component -> components , $ key , $ subComponent ) ; } break ; case property_exists ( $ component , 'columns' ) : foreach ( $ component -> columns as & $ column ) { foreach ( $ column -> components as $ key => & $ subComponent ) { $ extract ( $ column -> components , $ key , $ subComponent ) ; } } break ; case property_exists ( $ component , 'properties' ) && is_object ( $ component -> properties ) && property_exists ( $ component -> properties , 'ds_form' ) : $ form = $ this -> getForm ( $ component -> properties -> ds_form ) ; $ data = [ ] ; if ( property_exists ( $ component , 'defaultValue' ) ) { try { $ data = $ resolverCollection -> resolve ( $ component -> defaultValue ) ; } catch ( UnresolvedException $ exception ) { $ data = [ ] ; } catch ( UnmatchedException $ exception ) { } } $ form -> setData ( $ data ) ; $ forms [ ] = $ form ; unset ( $ container [ $ key ] ) ; break ; } } ; foreach ( $ components as $ key => & $ component ) { $ extract ( $ components , $ key , $ component ) ; } $ form -> setSchema ( array_values ( $ components ) ) ; break ; case Form :: TYPE_SYMFONY : break ; default : throw new DomainException ( 'Form type does not exist.' ) ; } return $ forms ; }
12524	public function deserializeJSON ( $ jsonString ) { $ data = json_decode ( $ jsonString ) ; $ this -> setContent ( $ data -> content ) ; $ this -> setContext ( $ data -> context ) ; }
8261	protected function saveAfterLogin ( Request $ httpRequest ) { $ referer = $ httpRequest -> headers -> get ( "referer" , null , true ) ; $ afterLogin = Utils :: getRefererQueryParam ( $ referer , "afterLogin" ) ; if ( $ afterLogin && Utils :: isValidPageId ( $ afterLogin ) ) { $ this -> session -> set ( "afterLogin" , $ afterLogin ) ; } }
6978	protected function normalizeAttachment ( AttachmentInterface $ attachment ) { $ formatter = $ this -> getFormatter ( ) ; return [ 'id' => $ attachment -> getId ( ) , 'title' => $ attachment -> getTitle ( ) , 'type' => $ attachment -> getType ( ) , 'size' => $ attachment -> getSize ( ) , 'internal' => $ attachment -> isInternal ( ) , 'file' => pathinfo ( $ attachment -> getPath ( ) , PATHINFO_BASENAME ) , 'created_at' => ( $ date = $ attachment -> getCreatedAt ( ) ) ? $ date -> format ( 'Y-m-d H:i:s' ) : null , 'f_created_at' => ( $ date = $ attachment -> getCreatedAt ( ) ) ? $ formatter -> dateTime ( $ date ) : null , 'updated_at' => ( $ date = $ attachment -> getUpdatedAt ( ) ) ? $ date -> format ( 'Y-m-d H:i:s' ) : null , 'f_updated_at' => ( $ date = $ attachment -> getUpdatedAt ( ) ) ? $ formatter -> dateTime ( $ date ) : null , ] ; }
1573	public function getProcessIdentifier ( ) : ? ResourceIdentifierInterface { if ( ! $ id = $ this -> getProcessId ( ) ) { return null ; } return ResourceIdentifier :: create ( $ this -> getProcessType ( ) , $ id ) ; }
8970	protected function toJson ( RateInterface $ rate ) { return json_encode ( array ( 'sourceName' => $ rate -> getSourceName ( ) , 'value' => $ rate -> getValue ( ) , 'currencyCode' => $ rate -> getCurrencyCode ( ) , 'rateType' => $ rate -> getRateType ( ) , 'date' => $ rate -> getDate ( ) -> format ( \ DateTime :: ATOM ) , 'baseCurrencyCode' => $ rate -> getBaseCurrencyCode ( ) , 'createdAt' => $ rate -> getCreatedAt ( ) -> format ( \ DateTime :: ATOM ) , 'modifiedAt' => $ rate -> getModifiedAt ( ) -> format ( \ DateTime :: ATOM ) , ) ) ; }
3928	private function getOptionsViaDcGeneral ( $ metaModel , $ environment , $ attribute ) { $ factory = DcGeneralFactory :: deriveEmptyFromEnvironment ( $ environment ) -> setContainerName ( $ metaModel -> getTableName ( ) ) ; $ dcGeneral = $ factory -> createDcGeneral ( ) ; $ subEnv = $ dcGeneral -> getEnvironment ( ) ; $ optEv = new GetPropertyOptionsEvent ( $ subEnv , $ subEnv -> getDataProvider ( ) -> getEmptyModel ( ) ) ; $ optEv -> setPropertyName ( $ attribute -> getColName ( ) ) ; $ subEnv -> getEventDispatcher ( ) -> dispatch ( GetPropertyOptionsEvent :: NAME , $ optEv ) ; $ options = $ optEv -> getOptions ( ) ; return $ options ; }
12456	public function installAssets ( $ targetFolder = "web" , $ force = false ) { $ sourceDir = $ this -> pluginDir . '/Resources/public' ; $ targetDir = $ this -> rootDir . '/' . $ targetFolder . '/plugins/' . strtolower ( $ this -> name ) ; if ( is_dir ( $ targetDir ) && ! $ force ) { return ; } $ this -> filesystem -> symlink ( $ sourceDir , $ targetDir , true ) ; }
8173	private function addCallable ( $ type = 'function' , $ name , $ func ) { if ( ! is_string ( $ name ) || ! is_callable ( $ func ) ) { return ; } $ twname = trim ( $ name , '*' ) ; $ params = [ ] ; if ( strpos ( $ name , '*' ) === 0 ) { $ params [ 'is_safe' ] = [ 'html' ] ; } if ( $ type === 'function' ) { $ this -> twig -> addFunction ( new Twig_SimpleFunction ( $ twname , $ func , $ params ) ) ; } if ( $ type === 'filter' ) { $ this -> twig -> addFilter ( new Twig_SimpleFilter ( $ twname , $ func , $ params ) ) ; } }
11742	public function add ( Theme $ theme , array $ pageValues ) { $ pageName = $ pageValues [ "name" ] ; $ pageDir = $ this -> pagesDir . '/' . $ pageName ; $ this -> pageExists ( $ pageDir ) ; if ( ! @ mkdir ( $ pageDir ) ) { $ this -> folderNotCreated ( $ pageDir ) ; } $ seoValues = $ pageValues [ "seo" ] ; unset ( $ pageValues [ "seo" ] ) ; $ encodedPage = json_encode ( $ pageValues ) ; $ pageFile = $ pageDir . '/' . $ this -> pageFile ; $ event = Dispatcher :: dispatch ( PageCollectionEvents :: PAGE_COLLECTION_ADDING , new PageCollectionAddingEvent ( $ pageFile , $ encodedPage ) ) ; $ encodedPage = $ event -> getFileContent ( ) ; FilesystemTools :: writeFile ( $ pageFile , $ encodedPage ) ; if ( $ this -> pageFile != 'page.json' ) { FilesystemTools :: writeFile ( $ pageDir . '/page.json' , $ encodedPage ) ; } foreach ( $ seoValues as $ seoValue ) { $ languageName = $ seoValue [ "language" ] ; unset ( $ seoValue [ "language" ] ) ; $ languageDir = $ pageDir . '/' . $ languageName ; @ mkdir ( $ languageDir ) ; FilesystemTools :: writeFile ( $ languageDir . '/' . $ this -> seoFile , json_encode ( $ seoValue ) ) ; $ theme -> addTemplateSlots ( $ pageValues [ "template" ] , $ this -> username ) ; } Dispatcher :: dispatch ( PageCollectionEvents :: PAGE_COLLECTION_ADDED , new PageCollectionAddedEvent ( $ pageFile , $ encodedPage ) ) ; DataLogger :: log ( sprintf ( 'Page "%s" was successfully added to the website' , $ pageName ) ) ; return $ pageValues ; }
11946	protected function getCurrentUser ( ) { try { return JWTAuth :: parseToken ( ) -> authenticate ( ) ; } catch ( \ Tymon \ JWTAuth \ Exceptions \ JWTException $ ex ) { return null ; } }
3638	public function env ( Output $ output ) : void { $ info = [ 'OS' => \ PHP_OS , 'Php version' => \ PHP_VERSION , 'Swoole version' => \ SWOOLE_VERSION , 'Swoft version' => \ Swoft :: VERSION , 'App Name' => \ config ( 'name' , 'unknown' ) , 'Base Path' => \ BASE_PATH , ] ; Show :: aList ( $ info , 'System Environment Info' ) ; }
8953	public function createNode ( $ changeset , $ latitude , $ longitude , $ tags ) { $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = 'node/create' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ tagList = '' ; if ( ! empty ( $ tags ) ) { foreach ( $ tags as $ key => $ value ) { $ tagList .= '<tag k="' . $ key . '" v="' . $ value . '"/>' ; } } $ xml = '<?xml version="1.0" encoding="UTF-8"?> <osm version="0.6" generator="JoomlaOpenStreetMap"> <node changeset="' . $ changeset . '" lat="' . $ latitude . '" lon="' . $ longitude . '">' . $ tagList . '</node> </osm>' ; $ header [ 'Content-Type' ] = 'text/xml' ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'PUT' , $ parameters , $ xml , $ header ) ; return $ response -> body ; }
5625	public function getEncodedRequest ( ) { if ( $ this -> raw ) { $ encoded = $ this -> raw ; } else { $ encoded = $ this -> request -> asUrlRequest ( ) ; } if ( $ encoded ) { return '?' . preg_replace ( '/^\?/' , '' , $ encoded ) ; } return '' ; }
8958	public function validateResponse ( $ url , $ response ) { if ( $ response -> code != 200 ) { $ error = htmlspecialchars ( $ response -> body ) ; throw new \ DomainException ( $ error , $ response -> code ) ; } }
4818	public function addField ( $ name , $ value ) { if ( $ this -> currentRow < 0 ) { $ this -> appendRow ( ) ; } $ this -> collection [ $ this -> currentRow ] -> addField ( $ name , $ value ) ; }
941	public function getPath ( ) { if ( null === $ this -> path ) { $ filesystem = new Filesystem ( ) ; $ cwd = $ this -> cwd ; if ( 1 === \ count ( $ this -> options [ 'path' ] ) && '-' === $ this -> options [ 'path' ] [ 0 ] ) { $ this -> path = $ this -> options [ 'path' ] ; } else { $ this -> path = array_map ( static function ( $ path ) use ( $ cwd , $ filesystem ) { $ absolutePath = $ filesystem -> isAbsolutePath ( $ path ) ? $ path : $ cwd . \ DIRECTORY_SEPARATOR . $ path ; if ( ! file_exists ( $ absolutePath ) ) { throw new InvalidConfigurationException ( sprintf ( 'The path "%s" is not readable.' , $ path ) ) ; } return $ absolutePath ; } , $ this -> options [ 'path' ] ) ; } } return $ this -> path ; }
1654	public function getReverse ( ) : Polygon { $ reversed = new static ( ) ; foreach ( array_reverse ( $ this -> points ) as $ point ) { $ reversed -> addPoint ( $ point ) ; } return $ reversed ; }
1990	protected function jumpToOrReload ( $ intId , $ strParams = null , $ strForceLang = null ) { if ( $ strForceLang !== null ) { @ trigger_error ( 'Using Frontend::jumpToOrReload() with $strForceLang has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; } global $ objPage ; $ blnForceRedirect = ( $ strParams !== null || $ strForceLang !== null ) ; if ( \ is_array ( $ intId ) ) { $ intId = $ intId [ 'id' ] ?? 0 ; } if ( $ intId > 0 && ( $ intId != $ objPage -> id || $ blnForceRedirect ) && ( $ objNextPage = PageModel :: findPublishedById ( $ intId ) ) !== null ) { $ this -> redirect ( $ objNextPage -> getFrontendUrl ( $ strParams , $ strForceLang ) ) ; } $ this -> reload ( ) ; }
10462	public function getTableName ( $ shopId = null ) { $ tableName = parent :: getTableName ( ) ; if ( $ shopId === null ) { $ shopId = $ this -> getActiveShopId ( ) ; } if ( ! $ this -> isShopValid ( $ shopId ) ) { throw new InvalidArgumentException ( "Shop id \"{$shopId}\" is invalid." ) ; } $ tableName .= '_' . $ shopId ; try { SqlValidator :: validateTableName ( $ tableName ) ; } catch ( InvalidArgumentException $ e ) { throw new InvalidArgumentException ( "Shop id \"{$shopId}\" is invalid." , 0 , $ e ) ; } return $ tableName ; }
12727	public function getValueMappedToTemplate ( ) { if ( $ this -> submitted ) { return $ this -> submittedValue ; } if ( $ this -> mapper ) { return $ this -> mapper -> mapToFrom ( $ this -> getValue ( ) ) ; } return $ this -> getValue ( ) ; }
12272	public function exec ( $ calcId ) { $ result = [ ] ; $ dwnlCompress = $ this -> daoBonDwnl -> getByCalcId ( $ calcId ) ; $ mapById = $ this -> hlpDwnlTree -> mapById ( $ dwnlCompress , EBonDwnl :: A_CUST_REF ) ; $ mapDepth = $ this -> hlpDwnlTree -> mapByTreeDepthDesc ( $ dwnlCompress , EBonDwnl :: A_CUST_REF , EBonDwnl :: A_DEPTH ) ; $ mapTeams = $ this -> hlpDwnlTree -> mapByTeams ( $ dwnlCompress , EBonDwnl :: A_CUST_REF , EBonDwnl :: A_PARENT_REF ) ; $ signupDebitCustomers = $ this -> hlpSignUpDebitCust -> exec ( ) ; foreach ( $ mapDepth as $ depth => $ levelCustomers ) { $ this -> logger -> debug ( "Process level #$depth of the downline tree." ) ; foreach ( $ levelCustomers as $ custId ) { $ entity = $ mapById [ $ custId ] ; $ ov = $ entity -> getPv ( ) ; $ isSignUpDebit = in_array ( $ custId , $ signupDebitCustomers ) ; if ( $ isSignUpDebit ) { $ ov += Cfg :: SIGNUP_DEBIT_PV ; } if ( isset ( $ mapTeams [ $ custId ] ) ) { $ team = $ mapTeams [ $ custId ] ; foreach ( $ team as $ memberId ) { $ member = $ result [ $ memberId ] ; $ memberOv = $ member -> getOv ( ) ; $ ov += $ memberOv ; } } $ entity -> setOv ( $ ov ) ; $ result [ $ custId ] = $ entity ; } } unset ( $ mapPv ) ; unset ( $ mapTeams ) ; unset ( $ mapDepth ) ; return $ result ; }
4519	public function get ( string $ key ) { $ parameter = $ this -> repository -> findOneBy ( [ 'key' => $ key ] ) ; if ( ! $ parameter ) { throw new OutOfRangeException ( 'Parameter "' . $ key . '" does not exist.' ) ; } $ this -> manager -> detach ( $ parameter ) ; return $ parameter -> getValue ( ) ; }
12854	public function process ( Pipeline \ Pipeline $ pipeline , $ payload ) { $ runner = clone ( $ this ) ; $ runner -> stages = $ pipeline -> getIterator ( ) ; return $ runner -> handle ( $ payload ) ; }
5535	public function divideMapNodes ( $ map , $ aspect ) { $ aspect = ! $ aspect ; $ divisions = $ map -> getSize ( ) ; $ total = $ map -> getTotalSize ( ) ; foreach ( $ map -> getChildren ( ) as $ node ) { if ( ! $ node -> isLeaf ( ) ) { $ dist = $ node -> getTotalSize ( ) / $ total * 100 ; } else { $ dist = 1 / $ total * 100 ; } if ( $ aspect ) { $ horiz = $ dist ; $ vert = 100 ; } else { $ horiz = 100 ; $ vert = $ dist ; } $ this -> paintRectangleStart ( $ node , $ horiz , $ vert ) ; $ this -> divideMapNodes ( $ node , $ aspect ) ; $ this -> paintRectangleEnd ( ) ; } }
6591	protected function asset ( $ type ) { $ busters = $ this -> checkAndGetBusters ( ) ; $ bustersOfThisType = array ( ) ; foreach ( $ busters as $ key => $ value ) { if ( strpos ( $ key , $ type ) !== false ) { $ bustersOfThisType [ $ key ] = $ value ; } } $ busterStrings = $ this -> parseTags ( $ bustersOfThisType , $ type ) ; return implode ( "\n" , $ busterStrings ) ; }
3722	public function handleUpdate ( PostPersistModelEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ old = $ event -> getOriginalModel ( ) ; $ new = $ event -> getModel ( ) ; $ oldTable = $ old ? $ old -> getProperty ( 'tableName' ) : null ; $ newTable = $ new -> getProperty ( 'tableName' ) ; if ( $ oldTable !== $ newTable ) { if ( ! empty ( $ oldTable ) ) { $ this -> tableManipulator -> renameTable ( $ oldTable , $ newTable ) ; } else { $ this -> tableManipulator -> createTable ( $ newTable ) ; } } $ this -> tableManipulator -> setVariantSupport ( $ newTable , $ new -> getProperty ( 'varsupport' ) ) ; }
11355	public function getValue ( $ name = null ) { if ( $ this -> has ( $ name ) ) { return $ this -> get ( $ name ) -> getValue ( ) ; } return parent :: getValue ( ) ; }
9598	protected function flashInput ( Request $ request = null ) { if ( $ request === null ) { $ request = $ this -> container -> resolve ( 'Symfony\Component\HttpFoundation\RequestStack' ) -> getCurrentRequest ( ) ; } $ this -> flash ( '_old_input' , $ request -> request -> all ( ) ) ; }
7699	function MsWord_Clean ( & $ Txt ) { $ Txt = str_replace ( '<w:lastRenderedPageBreak/>' , '' , $ Txt ) ; $ this -> XML_DeleteElements ( $ Txt , array ( 'w:proofErr' , 'w:noProof' , 'w:lang' , 'w:lastRenderedPageBreak' ) ) ; $ this -> MsWord_CleanSystemBookmarks ( $ Txt ) ; $ this -> MsWord_CleanRsID ( $ Txt ) ; $ this -> MsWord_CleanDuplicatedLayout ( $ Txt ) ; }
3690	public function handleCreateVariantAction ( ActionEvent $ event ) { if ( false === $ this -> scopeMatcher -> currentScopeIsBackend ( ) || 'createvariant' !== $ event -> getAction ( ) -> getName ( ) ) { return ; } $ environment = $ event -> getEnvironment ( ) ; $ view = $ environment -> getView ( ) ; $ dataProvider = $ environment -> getDataProvider ( ) ; $ inputProvider = $ environment -> getInputProvider ( ) ; $ modelId = $ inputProvider -> hasParameter ( 'id' ) ? ModelId :: fromSerialized ( $ inputProvider -> getParameter ( 'id' ) ) : null ; $ model = $ dataProvider -> createVariant ( $ dataProvider -> getEmptyConfig ( ) -> setId ( $ modelId -> getId ( ) ) ) ; if ( $ model == null ) { throw new \ RuntimeException ( sprintf ( 'Could not find model with id %s for creating a variant.' , $ modelId ) ) ; } $ metaModel = $ this -> factory -> getMetaModel ( $ model -> getProviderName ( ) ) ; if ( ! $ metaModel || ! $ metaModel -> hasVariants ( ) ) { return ; } $ preFunction = function ( $ environment , $ model ) { $ copyEvent = new PreCreateModelEvent ( $ environment , $ model ) ; $ environment -> getEventDispatcher ( ) -> dispatch ( $ copyEvent :: NAME , $ copyEvent ) ; } ; $ postFunction = function ( $ environment , $ model ) { $ copyEvent = new PostCreateModelEvent ( $ environment , $ model ) ; $ environment -> getEventDispatcher ( ) -> dispatch ( $ copyEvent :: NAME , $ copyEvent ) ; } ; if ( ! $ view instanceof BackendViewInterface ) { throw new \ InvalidArgumentException ( 'Invalid view registered in environment.' ) ; } $ editMask = new EditMask ( $ view , $ model , null , $ preFunction , $ postFunction , $ this -> breadcrumb ( $ environment ) ) ; $ event -> setResponse ( $ editMask -> execute ( ) ) ; }
7242	public function validate ( $ request ) { if ( ! empty ( $ request [ 'send_by_bcc' ] ) && '1' === $ request [ 'send_by_bcc' ] ) $ request [ 'send_by_bcc' ] = '1' ; else $ request [ 'send_by_bcc' ] = '0' ; if ( ! empty ( $ request [ 'send_attachments' ] ) && '1' === $ request [ 'send_attachments' ] ) $ request [ 'send_attachments' ] = '1' ; else $ request [ 'send_attachments' ] = '0' ; return $ request ; }
12080	public function updateChild ( $ idParent , FilterRequest $ filters , $ idChild , $ relation ) { $ idParent = $ this -> getRealId ( $ idParent ) ; $ idChild = $ this -> getRealId ( $ idChild ) ; $ resource = $ this -> repository -> updateChild ( $ idParent , $ relation , $ idChild , $ filters -> all ( ) ) ; if ( ! $ resource ) { } return $ this -> success ( $ resource ) ; }
4494	private function getApnsJsonInner ( ? string $ text ) : array { $ apns = [ 'aps' => [ ] , ] ; if ( null !== $ this -> localizedKey ) { $ apns [ 'aps' ] [ 'alert' ] = [ 'loc-key' => $ this -> localizedKey , ] ; if ( $ this -> localizedArguments ) { $ apns [ 'aps' ] [ 'alert' ] [ 'loc-args' ] = $ this -> localizedArguments ; } } elseif ( null !== $ text ) { $ apns [ 'aps' ] [ 'alert' ] = $ text ; } if ( $ this -> isContentAvailable ( ) ) { $ apns [ 'aps' ] [ 'content-available' ] = 1 ; } if ( null !== $ this -> badge ) { $ apns [ 'aps' ] [ 'badge' ] = $ this -> badge ; } if ( null !== $ this -> sound ) { $ apns [ 'aps' ] [ 'sound' ] = $ this -> sound ; } $ merged = $ this -> arrayMergeDeep ( $ apns , $ this -> custom , $ this -> apnsData ? $ this -> apnsData : [ ] ) ; if ( ! \ count ( $ merged [ 'aps' ] ) ) { $ merged [ 'aps' ] = new \ stdClass ( ) ; } return $ merged ; }
6493	private function compareAcceptMediaTypeHeaders ( AcceptMediaTypeHeaderValue $ a , AcceptMediaTypeHeaderValue $ b ) : int { $ aQuality = $ a -> getQuality ( ) ; $ bQuality = $ b -> getQuality ( ) ; if ( $ aQuality < $ bQuality ) { return 1 ; } if ( $ aQuality > $ bQuality ) { return - 1 ; } $ aType = $ a -> getType ( ) ; $ bType = $ b -> getType ( ) ; $ aSubType = $ a -> getSubType ( ) ; $ bSubType = $ b -> getSubType ( ) ; if ( $ aType === '*' ) { if ( $ bType === '*' ) { return 0 ; } return 1 ; } if ( $ aSubType === '*' ) { if ( $ bSubType === '*' ) { return 0 ; } return 1 ; } if ( $ bType === '*' || $ bSubType === '*' ) { return - 1 ; } return 0 ; }
12977	protected function getComponentDefaults ( $ mappingName , array $ mappingConfig ) { if ( strpos ( $ mappingName , '::' ) ) { list ( $ componentName , $ componentType ) = explode ( '::' , $ mappingName ) ; } else { $ componentName = $ mappingName ; $ componentType = $ this -> detectComponentType ( $ componentName ) ; if ( $ componentType === false and $ componentName === 'app' ) { $ componentType = 'app' ; } } if ( ( $ componentPath = $ this -> getComponentPath ( $ componentName , $ componentType ) ) === false ) { return false ; } $ configPath = $ mappingConfig [ 'dir' ] ; if ( $ configPath === false ) { $ configPath = $ this -> getConfigPath ( ) ; } if ( $ mappingConfig [ 'type' ] === false ) { $ mappingConfig [ 'type' ] = $ this -> detectMetadataDriver ( $ componentPath , $ configPath ) ; } if ( $ mappingConfig [ 'type' ] === false ) { return false ; } if ( $ mappingConfig [ 'dir' ] === false ) { if ( in_array ( $ mappingConfig [ 'type' ] , array ( 'annotation' , 'staticphp' ) ) ) { $ mappingConfig [ 'dir' ] = $ this -> getClassPath ( ) . $ this -> getObjectName ( ) ; } else { $ mappingConfig [ 'dir' ] = $ configPath ; } } if ( is_array ( $ mappingConfig [ 'dir' ] ) ) { foreach ( $ mappingConfig [ 'dir' ] as & $ path ) { $ path = $ componentPath . $ path ; } } else { $ mappingConfig [ 'dir' ] = $ componentPath . $ mappingConfig [ 'dir' ] ; } if ( $ mappingConfig [ 'prefix' ] === false ) { $ mappingConfig [ 'prefix' ] = $ this -> detectComponentNamespace ( $ componentName , $ componentType ) ; } $ mappingConfig [ 'is_component' ] = false ; return $ mappingConfig ; }
4959	public function detach ( EventManagerInterface $ events ) { foreach ( $ this -> listeners as $ index => $ listener ) { if ( $ events -> detach ( $ listener ) ) { unset ( $ this -> listeners [ $ index ] ) ; } } $ sharedEvents = $ events -> getSharedManager ( ) ; foreach ( $ this -> sharedListeners as $ index => $ listener ) { if ( $ sharedEvents -> detach ( $ listener ) ) { unset ( $ this -> sharedListeners [ $ index ] ) ; } } }
7620	public function createSignedQueryString ( $ path = '/' , $ queryString = '' , $ resource = 'b' , $ permissions = 'r' , $ start = '' , $ expiry = '' , $ identifier = '' ) { $ parts = array ( ) ; if ( $ start !== '' ) { $ parts [ ] = 'st=' . urlencode ( $ start ) ; } $ parts [ ] = 'se=' . urlencode ( $ expiry ) ; $ parts [ ] = 'sr=' . $ resource ; $ parts [ ] = 'sp=' . $ permissions ; if ( $ identifier !== '' ) { $ parts [ ] = 'si=' . urlencode ( $ identifier ) ; } $ parts [ ] = 'sig=' . urlencode ( $ this -> createSignature ( $ path , $ resource , $ permissions , $ start , $ expiry , $ identifier ) ) ; if ( $ queryString != '' ) { $ queryString .= '&' ; } $ queryString .= implode ( '&' , $ parts ) ; return $ queryString ; }
11823	public function replace ( $ middleware , $ with ) { $ this -> pipeline = $ this -> pipeline -> replace ( $ middleware , $ with ) ; return $ this ; }
4344	protected function pushStack ( $ funcName ) { $ this -> funcStack [ ] = array ( 'function' => $ funcName , 'tsStart' => $ this -> timeLastTick , 'subTime' => 0 , ) ; if ( ! isset ( $ this -> data [ $ funcName ] ) ) { $ this -> data [ $ funcName ] = array ( 'calls' => 0 , 'totalTime' => 0 , 'ownTime' => 0 , ) ; } $ this -> data [ $ funcName ] [ 'calls' ] ++ ; }
10503	private function setParameter ( $ subject , string $ key , $ value ) { $ setter = 'set' . $ this -> snakeToCamelCase ( $ key ) ; if ( is_callable ( [ $ subject , $ setter ] ) ) { call_user_func ( [ $ subject , $ setter ] , $ value ) ; } }
12144	public static function login ( $ rank = 1 , $ id = null ) { static :: provider ( ) -> set ( 'valid' , true ) ; static :: provider ( ) -> set ( 'rank' , $ rank ) ; static :: provider ( ) -> set ( 'id' , $ id ) ; return static :: user ( ) ; }
7191	private function copyNotification ( Model \ SaleNotificationInterface $ source , Model \ SaleNotificationInterface $ target ) { $ this -> copy ( $ source , $ target , [ 'type' , 'data' , 'sentAt' , 'details' ] ) ; }
10402	public function createApplication ( string $ app_type , FileSystemInterface $ filesystem ) : ApplicationInterface { switch ( $ app_type ) { case ApplicationType :: SHELL : return ( new Calgamo ( $ filesystem ) ) -> newApp ( ) -> requireModule ( CalgamoShellRequestModule :: class ) ; case ApplicationType :: CRON : return ( new Calgamo ( $ filesystem ) ) -> newApp ( ) -> requireModule ( CalgamoShellRequestModule :: class ) ; break ; case ApplicationType :: HTTP : return ( new Calgamo ( $ filesystem ) ) -> newApp ( ) -> requireModule ( 'zend.request' ) ; break ; case ApplicationType :: REST : return ( new Calgamo ( $ filesystem ) ) -> newApp ( ) -> requireModule ( ZendRequestModule :: class ) -> requireModule ( CalgamoRestApiModule :: class ) ; break ; } return new NullApplication ( ) ; }
2103	public function hasOldDatabase ( ) : bool { if ( ! $ this -> hasTable ( 'tl_layout' ) ) { return false ; } $ sql = $ this -> connection -> getDatabasePlatform ( ) -> getListTableColumnsSQL ( 'tl_layout' , $ this -> connection -> getDatabase ( ) ) ; $ columns = $ this -> connection -> fetchAll ( $ sql ) ; foreach ( $ columns as $ column ) { if ( 'sections' === $ column [ 'Field' ] ) { return ! \ in_array ( $ column [ 'Type' ] , [ 'varchar(1022)' , 'blob' ] , true ) ; } } return false ; }
226	protected function asCurrencyStringFallback ( $ value , $ currency = null ) { if ( $ currency === null ) { if ( $ this -> currencyCode === null ) { throw new InvalidConfigException ( 'The default currency code for the formatter is not defined.' ) ; } $ currency = $ this -> currencyCode ; } return $ currency . ' ' . $ this -> asDecimalStringFallback ( $ value , 2 ) ; }
9662	private static function getReaderTypeFromExtension ( $ filename ) { $ pathinfo = pathinfo ( $ filename ) ; if ( ! isset ( $ pathinfo [ 'extension' ] ) ) { return null ; } switch ( strtolower ( $ pathinfo [ 'extension' ] ) ) { case 'xlsx' : case 'xlsm' : case 'xltx' : case 'xltm' : return 'Xlsx' ; case 'xls' : case 'xlt' : return 'Xls' ; case 'ods' : case 'ots' : return 'Ods' ; case 'slk' : return 'Slk' ; case 'xml' : return 'Xml' ; case 'gnumeric' : return 'Gnumeric' ; case 'htm' : case 'html' : return 'Html' ; case 'csv' : return null ; default : return null ; } }
7721	public function actionIndex ( ) { $ searchModel = new MahasiswaSearch ( ) ; $ dataProvider = $ searchModel -> search ( Yii :: $ app -> request -> queryParams ) ; $ field = [ 'fileImport' => 'File Import' , ] ; $ modelImport = DynamicModel :: validateData ( $ field , [ [ [ 'fileImport' ] , 'required' ] , [ [ 'fileImport' ] , 'file' , 'extensions' => 'xls,xlsx' , 'maxSize' => 1024 * 1024 ] , ] ) ; return $ this -> render ( 'index' , [ 'searchModel' => $ searchModel , 'dataProvider' => $ dataProvider , 'modelImport' => $ modelImport , ] ) ; }
2904	public function send ( $ email , $ name = null , array $ variables = array ( ) ) { $ zendMail = $ this -> getMail ( ) ; $ result = $ this -> parentSend ( $ email , $ name , $ variables ) ; try { $ this -> addEmailToProfile ( $ email , $ name , $ variables , $ result , $ zendMail ) ; } catch ( Exception $ e ) { Mage :: logException ( $ e ) ; } return $ result ; }
822	private function fixSemicolonAfterCurlyBraceClose ( Tokens $ tokens , $ index , $ curlyCloseIndex ) { static $ beforeCurlyOpeningKinds = null ; if ( null === $ beforeCurlyOpeningKinds ) { $ beforeCurlyOpeningKinds = [ T_ELSE , T_FINALLY , T_NAMESPACE , T_OPEN_TAG ] ; } $ curlyOpeningIndex = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_CURLY_BRACE , $ curlyCloseIndex ) ; $ beforeCurlyOpening = $ tokens -> getPrevMeaningfulToken ( $ curlyOpeningIndex ) ; if ( $ tokens [ $ beforeCurlyOpening ] -> isGivenKind ( $ beforeCurlyOpeningKinds ) || $ tokens [ $ beforeCurlyOpening ] -> equalsAny ( [ ';' , '{' , '}' ] ) ) { $ tokens -> clearTokenAndMergeSurroundingWhitespace ( $ index ) ; return ; } if ( $ tokens [ $ beforeCurlyOpening ] -> isGivenKind ( T_STRING ) ) { $ classyTest = $ tokens -> getPrevMeaningfulToken ( $ beforeCurlyOpening ) ; while ( $ tokens [ $ classyTest ] -> equals ( ',' ) || $ tokens [ $ classyTest ] -> isGivenKind ( [ T_STRING , T_NS_SEPARATOR , T_EXTENDS , T_IMPLEMENTS ] ) ) { $ classyTest = $ tokens -> getPrevMeaningfulToken ( $ classyTest ) ; } $ tokensAnalyzer = new TokensAnalyzer ( $ tokens ) ; if ( $ tokens [ $ classyTest ] -> isGivenKind ( T_NAMESPACE ) || ( $ tokens [ $ classyTest ] -> isClassy ( ) && ! $ tokensAnalyzer -> isAnonymousClass ( $ classyTest ) ) ) { $ tokens -> clearTokenAndMergeSurroundingWhitespace ( $ index ) ; } return ; } if ( ! $ tokens [ $ beforeCurlyOpening ] -> equals ( ')' ) ) { return ; } $ openingBrace = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ beforeCurlyOpening ) ; $ beforeOpeningBrace = $ tokens -> getPrevMeaningfulToken ( $ openingBrace ) ; if ( $ tokens [ $ beforeOpeningBrace ] -> isGivenKind ( [ T_IF , T_ELSEIF , T_FOR , T_FOREACH , T_WHILE , T_SWITCH , T_CATCH , T_DECLARE ] ) ) { $ tokens -> clearTokenAndMergeSurroundingWhitespace ( $ index ) ; return ; } if ( $ tokens [ $ beforeOpeningBrace ] -> isGivenKind ( T_STRING ) ) { $ beforeString = $ tokens -> getPrevMeaningfulToken ( $ beforeOpeningBrace ) ; if ( $ tokens [ $ beforeString ] -> isGivenKind ( T_FUNCTION ) ) { $ tokens -> clearTokenAndMergeSurroundingWhitespace ( $ index ) ; } } }
4198	public function onEnd ( Event $ event ) { $ obj = $ event -> getSubject ( ) ; if ( $ obj instanceof \ DOMNodeList ) { $ event [ 'properties' ] [ 'length' ] = \ array_merge ( static :: $ basePropInfo , array ( 'type' => 'integer' , 'value' => $ obj -> length , ) ) ; } elseif ( $ obj instanceof \ Exception ) { if ( isset ( $ event [ 'properties' ] [ 'xdebug_message' ] ) ) { $ event [ 'properties' ] [ 'xdebug_message' ] [ 'isExcluded' ] = true ; } } elseif ( $ obj instanceof \ mysqli && ! $ event [ 'collectPropertyValues' ] ) { $ propsAlwaysAvail = array ( 'client_info' , 'client_version' , 'connect_errno' , 'connect_error' , 'errno' , 'error' , 'stat' ) ; $ reflectionObject = $ event [ 'reflector' ] ; foreach ( $ propsAlwaysAvail as $ name ) { $ reflectionProperty = $ reflectionObject -> getProperty ( $ name ) ; $ event [ 'properties' ] [ $ name ] [ 'value' ] = $ reflectionProperty -> getValue ( $ obj ) ; } } }
2686	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ req = $ this -> api -> checkImageOptimizationStatus ( ) ; if ( ! $ req ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to check image optimization status.' ] ) ; } return $ result -> setData ( [ 'status' => true , 'req_setting' => $ req ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
4544	public function kernelException ( GetResponseForExceptionEvent $ event ) { $ exception = $ event -> getException ( ) ; if ( $ exception instanceof ValidationException ) { return ; } $ data = [ 'type' => 'https://tools.ietf.org/html/rfc2616#section-10' , 'title' => 'An error occurred' ] ; if ( in_array ( $ this -> environment , [ 'dev' , 'test' ] , true ) ) { $ data [ 'detail' ] = $ exception -> getMessage ( ) ; $ data [ 'trace' ] = $ exception -> getTrace ( ) ; } $ request = $ event -> getRequest ( ) ; $ contentTypes = $ request -> getAcceptableContentTypes ( ) ; $ accept = array_shift ( $ contentTypes ) ; switch ( $ accept ) { case 'application/json' : case 'application/ld+json' : $ code = Response :: HTTP_INTERNAL_SERVER_ERROR ; if ( $ exception instanceof HttpException ) { $ code = $ exception -> getStatusCode ( ) ; } $ response = new JsonResponse ( $ data , $ code ) ; $ event -> setResponse ( $ response ) ; break ; } }
11824	public function detect ( ) { $ str = file_get_contents ( $ this -> uri ) ; foreach ( $ this -> getBom ( 'all' ) as $ encoding => $ bom ) { if ( 0 === strncmp ( $ str , $ bom , strlen ( $ bom ) ) ) { return $ encoding ; } } }
10273	function updateCustomProperty ( $ mailingId , $ property ) { $ queryParameters = array ( 'name' => $ property -> key , 'value' => $ property -> value ) ; return $ this -> put ( "mailings/${mailingId}/settings/properties" , "" , $ queryParameters ) ; }
12447	static function run_build_dependencies ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { $ opts = self :: getOpts ( @ $ args [ 0 ] , @ $ args [ 1 ] , $ cliopts ) ; $ current = $ opts [ 'extension' ] [ 'name' ] ; foreach ( $ opts [ 'dependencies' ] [ 'extensions' ] as $ ext => $ source ) { if ( $ ext != $ current ) { foreach ( $ source as $ type => $ def ) { break ; } $ tempconf = array ( 'extension' => array ( 'name' => $ ext ) , 'version' => array ( 'major' => 0 , 'minor' => 0 , 'release' => 0 ) , $ type => $ def ) ; $ tempconffile = self :: getOptionsDir ( ) . "/options-tmp_$ext.yaml" ; pakeYaml :: emitfile ( $ tempconf , $ tempconffile ) ; $ task = pakeTask :: get ( 'init' ) ; $ task -> execute ( array ( "tmp_$ext" ) , array_merge ( $ cliopts , array ( 'skip-init' => false , 'skip-init-fetch' => false , 'skip-init-clean' => true ) ) ) ; if ( is_file ( self :: getBuildDir ( $ opts ) . "/$ext/pake/options-$ext.yaml" ) ) { pake_copy ( self :: getBuildDir ( $ opts ) . "/$ext/pake/options-$ext.yaml" , self :: getOptionsDir ( ) . "/options-$ext.yaml" ) ; } else { throw new pakeException ( "Missing pake/options.yaml extension in dependent extension $ext" ) ; } $ task -> execute ( array ( "tmp_$ext" ) , array_merge ( $ cliopts , array ( 'skip-init' => false , 'skip-init-fetch' => true , 'skip-init-clean' => false ) ) ) ; pake_remove ( $ tempconffile , '' ) ; $ task = pakeTask :: get ( 'build' ) ; foreach ( $ task -> get_prerequisites ( ) as $ pretask ) { $ pretask = pakeTask :: get ( $ pretask ) ; $ pretask -> execute ( array ( $ ext ) , array_merge ( $ opts , array ( 'skip-init' => true ) ) ) ; } $ task -> execute ( array ( $ ext ) , array_merge ( $ opts , array ( 'skip-init' => true ) ) ) ; } } }
8757	public function run ( \ Traversable $ items , callable $ itemCallback ) { $ this -> start ( ) ; foreach ( $ items as $ item ) { call_user_func ( $ itemCallback , $ this , $ item ) ; } return $ this -> finish ( ) ; }
3263	public static function format ( $ value ) { return preg_replace ( [ '/:symbol/' , '/:price/' , '/:currency/' ] , [ Config :: get ( 'shop.currency_symbol' ) , $ value , Config :: get ( 'shop.currency' ) ] , Config :: get ( 'shop.display_price_format' ) ) ; }
2717	public function render ( AbstractElement $ element ) { $ element -> unsScope ( ) -> unsCanUseWebsiteValue ( ) -> unsCanUseDefaultValue ( ) ; return parent :: render ( $ element ) ; }
1691	protected function compileColor ( $ color , $ blnWriteToFile = false , $ vars = array ( ) ) { if ( ! \ is_array ( $ color ) ) { return '#' . $ this -> shortenHexColor ( $ color ) ; } elseif ( ! isset ( $ color [ 1 ] ) || empty ( $ color [ 1 ] ) ) { return '#' . $ this -> shortenHexColor ( $ color [ 0 ] ) ; } else { return 'rgba(' . implode ( ',' , $ this -> convertHexColor ( $ color [ 0 ] , $ blnWriteToFile , $ vars ) ) . ',' . ( $ color [ 1 ] / 100 ) . ')' ; } }
26	protected function getRemoteContents ( $ originUrl , $ fileUrl , $ context , array & $ responseHeaders = null ) { try { $ e = null ; $ result = file_get_contents ( $ fileUrl , false , $ context ) ; } catch ( \ Throwable $ e ) { } catch ( \ Exception $ e ) { } $ responseHeaders = isset ( $ http_response_header ) ? $ http_response_header : array ( ) ; if ( null !== $ e ) { throw $ e ; } return $ result ; }
12947	protected function ownerHasTagAttribute ( ) { if ( $ this -> _hasTagAttribute === null ) { $ this -> _hasTagAttribute = $ this -> owner -> hasAttribute ( 'tags' ) ; } return $ this -> _hasTagAttribute ; }
10620	public function boot ( ) { if ( ! $ this -> booted ) { foreach ( $ this -> providers as $ provider ) { $ provider -> boot ( $ this ) ; } } $ this -> booted = true ; }
10994	public function getSize ( int $ precision = 0 , string $ point = "." , string $ sep = "," ) : string { $ bytes = $ this -> getByteSize ( ) ; if ( $ bytes === - 1 ) { return "" ; } return \ sndsgd \ Fs :: formatSize ( $ bytes , $ precision , $ point , $ sep ) ; }
7537	function clear ( ) { foreach ( $ this -> children as $ c ) { $ c -> parent = null ; $ c -> delete ( ) ; } $ this -> children = array ( ) ; }
695	public function beforeSend ( $ message ) { $ event = new MailEvent ( [ 'message' => $ message ] ) ; $ this -> trigger ( self :: EVENT_BEFORE_SEND , $ event ) ; return $ event -> isValid ; }
11001	public function setLocale ( $ locale ) { $ locale = WF :: cast_array ( $ locale ) ; foreach ( $ locale as $ l ) $ this -> locales [ ] = new Locale ( $ l ) ; $ this -> locales = array_unique ( $ this -> locales ) ; return $ this ; }
11774	private function getMaxPercentForPersonalBonus ( $ levels ) { $ result = 0 ; foreach ( $ levels as $ percent ) { if ( $ percent > $ result ) { $ result = $ percent ; } } return $ result ; }
9997	protected function inferSeparator ( ) { if ( $ this -> delimiter !== null ) { return ; } $ potentialDelimiters = [ ',' , ';' , "\t" , '|' , ':' , ' ' ] ; $ counts = [ ] ; foreach ( $ potentialDelimiters as $ delimiter ) { $ counts [ $ delimiter ] = [ ] ; } $ numberLines = 0 ; while ( ( $ line = fgets ( $ this -> fileHandle ) ) !== false && ( ++ $ numberLines < 1000 ) ) { $ enclosure = preg_quote ( $ this -> enclosure , '/' ) ; $ line = preg_replace ( '/(' . $ enclosure . '.*' . $ enclosure . ')/U' , '' , $ line ) ; $ countLine = [ ] ; for ( $ i = strlen ( $ line ) - 1 ; $ i >= 0 ; -- $ i ) { $ char = $ line [ $ i ] ; if ( isset ( $ counts [ $ char ] ) ) { if ( ! isset ( $ countLine [ $ char ] ) ) { $ countLine [ $ char ] = 0 ; } ++ $ countLine [ $ char ] ; } } foreach ( $ potentialDelimiters as $ delimiter ) { $ counts [ $ delimiter ] [ ] = isset ( $ countLine [ $ delimiter ] ) ? $ countLine [ $ delimiter ] : 0 ; } } $ meanSquareDeviations = [ ] ; $ middleIdx = floor ( ( $ numberLines - 1 ) / 2 ) ; foreach ( $ potentialDelimiters as $ delimiter ) { $ series = $ counts [ $ delimiter ] ; sort ( $ series ) ; $ median = ( $ numberLines % 2 ) ? $ series [ $ middleIdx ] : ( $ series [ $ middleIdx ] + $ series [ $ middleIdx + 1 ] ) / 2 ; if ( $ median === 0 ) { continue ; } $ meanSquareDeviations [ $ delimiter ] = array_reduce ( $ series , function ( $ sum , $ value ) use ( $ median ) { return $ sum + pow ( $ value - $ median , 2 ) ; } ) / count ( $ series ) ; } $ min = INF ; foreach ( $ potentialDelimiters as $ delimiter ) { if ( ! isset ( $ meanSquareDeviations [ $ delimiter ] ) ) { continue ; } if ( $ meanSquareDeviations [ $ delimiter ] < $ min ) { $ min = $ meanSquareDeviations [ $ delimiter ] ; $ this -> delimiter = $ delimiter ; } } if ( $ this -> delimiter === null ) { $ this -> delimiter = reset ( $ potentialDelimiters ) ; } return $ this -> skipBOM ( ) ; }
7677	function TbsSearchInFiles ( $ files , $ str , $ returnFirstFound = true ) { $ keys_ok = array ( ) ; $ keys_todo = array ( ) ; $ idx_keys = array ( ) ; foreach ( $ files as $ k => $ f ) { $ idx = $ this -> FileGetIdx ( $ f ) ; if ( $ idx !== false ) { $ keys_todo [ $ k ] = $ idx ; $ idx_keys [ $ idx ] = $ k ; } } if ( ( $ this -> TbsCurrIdx !== false ) && isset ( $ idx_keys [ $ this -> TbsCurrIdx ] ) ) { $ key = $ idx_keys [ $ this -> TbsCurrIdx ] ; $ p = strpos ( $ this -> TBS -> Source , $ str ) ; if ( $ p !== false ) { $ keys_ok [ ] = array ( 'key' => $ key , 'idx' => $ this -> TbsCurrIdx , 'src' => & $ this -> TBS -> Source , 'pos' => $ p , 'curr' => true ) ; if ( $ returnFirstFound ) return $ keys_ok [ 0 ] ; } unset ( $ keys_todo [ $ key ] ) ; } foreach ( $ this -> TbsStoreLst as $ idx => $ s ) { if ( ( $ idx !== $ this -> TbsCurrIdx ) && isset ( $ idx_keys [ $ idx ] ) ) { $ key = $ idx_keys [ $ idx ] ; $ p = strpos ( $ s [ 'src' ] , $ str ) ; if ( $ p !== false ) { $ keys_ok [ ] = array ( 'key' => $ key , 'idx' => $ idx , 'src' => & $ s [ 'src' ] , 'pos' => $ p , 'curr' => false ) ; if ( $ returnFirstFound ) return $ keys_ok [ 0 ] ; } unset ( $ keys_todo [ $ key ] ) ; } } foreach ( $ keys_todo as $ key => $ idx ) { $ txt = $ this -> FileRead ( $ idx ) ; $ p = strpos ( $ txt , $ str ) ; if ( $ p !== false ) { $ keys_ok [ ] = array ( 'key' => $ key , 'idx' => $ idx , 'src' => $ txt , 'pos' => $ p , 'curr' => false ) ; if ( $ returnFirstFound ) return $ keys_ok [ 0 ] ; } } if ( $ returnFirstFound ) { return array ( 'key' => false , 'idx' => false , 'src' => false , 'pos' => false , 'curr' => false ) ; } else { return $ keys_ok ; } }
3847	protected static function upgradeClosed ( ) { $ objDB = self :: DB ( ) ; if ( $ objDB -> tableExists ( 'tl_metamodel_dca' , null , true ) && ! $ objDB -> fieldExists ( 'iseditable' , 'tl_metamodel_dca' ) ) { TableManipulation :: createColumn ( 'tl_metamodel_dca' , 'iseditable' , 'char(1) NOT NULL default \'\'' ) ; TableManipulation :: createColumn ( 'tl_metamodel_dca' , 'iscreatable' , 'char(1) NOT NULL default \'\'' ) ; TableManipulation :: createColumn ( 'tl_metamodel_dca' , 'isdeleteable' , 'char(1) NOT NULL default \'\'' ) ; $ objDB -> execute ( ' UPDATE tl_metamodel_dca SET iseditable=isclosed^1, iscreatable=isclosed^1, isdeleteable=isclosed^1 ' ) ; TableManipulation :: dropColumn ( 'tl_metamodel_dca' , 'isclosed' , true ) ; } }
10194	public static function getLastQuery ( $ connection = "" ) { $ last_query = "" ; $ pretty_queries = self :: getPrettyQueryLog ( $ connection ) ; if ( ! empty ( $ pretty_queries ) ) { $ last_query = $ pretty_queries [ count ( $ pretty_queries ) - 1 ] ; } return $ last_query ; }
5704	public function Field ( $ properties = array ( ) ) { if ( $ this -> isGrouped ( ) ) { $ this -> transformToInput ( ) ; } else { $ this -> transformToButton ( ) ; } return parent :: Field ( $ properties ) ; }
11397	public static function parseFault ( \ SimpleXMLElement $ fault ) { $ faultData = static :: parseStruct ( $ fault -> value -> struct ) ; return new \ Devedge \ XmlRpc \ Client \ RemoteException ( $ faultData [ 'faultString' ] , $ faultData [ 'faultCode' ] ) ; }
10229	public function set_language ( ) { $ plugin_slug = App :: EFG ( ) -> getOption ( 'slug' ) ; $ module_slug = Module :: CustomImagesGrifus ( ) -> getOption ( 'slug' ) ; $ path = $ plugin_slug . '/modules/' . $ module_slug . '/languages/' ; load_plugin_textdomain ( $ plugin_slug . '-images' , false , $ path ) ; }
6488	protected function getClientIPAddress ( array $ server ) : ? string { $ serverRemoteAddress = $ server [ 'REMOTE_ADDR' ] ?? null ; if ( $ this -> isUsingTrustedProxy ( $ server ) ) { return $ serverRemoteAddress ?? null ; } $ ipAddresses = [ ] ; if ( isset ( $ server [ $ this -> trustedHeaderNames [ 'HTTP_FORWARDED' ] ] ) ) { $ header = $ server [ $ this -> trustedHeaderNames [ 'HTTP_FORWARDED' ] ] ; preg_match_all ( "/for=(?:\"?\[?)([a-z0-9:\.\-\/_]*)/" , $ header , $ matches ) ; $ ipAddresses = $ matches [ 1 ] ; } elseif ( isset ( $ server [ $ this -> trustedHeaderNames [ 'HTTP_CLIENT_IP' ] ] ) ) { $ ipAddresses = explode ( ',' , $ server [ $ this -> trustedHeaderNames [ 'HTTP_CLIENT_IP' ] ] ) ; $ ipAddresses = array_map ( 'trim' , $ ipAddresses ) ; } if ( $ serverRemoteAddress !== null ) { $ ipAddresses [ ] = $ serverRemoteAddress ; } $ fallbackIPAddresses = count ( $ ipAddresses ) === 0 ? [ ] : [ $ ipAddresses [ 0 ] ] ; foreach ( $ ipAddresses as $ index => $ ipAddress ) { if ( filter_var ( $ ipAddress , FILTER_VALIDATE_IP , FILTER_FLAG_IPV4 ) === false ) { unset ( $ ipAddresses [ $ index ] ) ; } if ( in_array ( $ ipAddress , $ this -> trustedProxyIPAddresses , true ) ) { unset ( $ ipAddresses [ $ index ] ) ; } } $ clientIPAddresses = count ( $ ipAddresses ) === 0 ? $ fallbackIPAddresses : array_reverse ( $ ipAddresses ) ; return $ clientIPAddresses [ 0 ] ?? null ; }
658	public function cache ( callable $ callable , $ duration = null , $ dependency = null ) { $ this -> _queryCacheInfo [ ] = [ $ duration === null ? $ this -> queryCacheDuration : $ duration , $ dependency ] ; try { $ result = call_user_func ( $ callable , $ this ) ; array_pop ( $ this -> _queryCacheInfo ) ; return $ result ; } catch ( \ Exception $ e ) { array_pop ( $ this -> _queryCacheInfo ) ; throw $ e ; } catch ( \ Throwable $ e ) { array_pop ( $ this -> _queryCacheInfo ) ; throw $ e ; } }
12248	public function xpathSingle ( $ strXpathQuery ) { $ arrResults = $ this -> xpath ( $ strXpathQuery ) ; if ( $ arrResults === false ) { return null ; } if ( is_array ( $ arrResults ) && count ( $ arrResults ) == 0 ) { return null ; } else { if ( count ( $ arrResults ) > 1 ) { throw new Exception ( 'xpathSingle expects a single element as result, got ' . count ( $ arrResults ) . ' elements instead.' ) ; } else { return current ( $ arrResults ) ; } } }
7030	public function toArray ( ) { return [ 'o_msg' => $ this -> overflowMessage , 'min_qty' => $ this -> minimumQuantity , 'min_msg' => $ this -> minimumMessage , 'max_qty' => INF === $ this -> maximumQuantity ? 'INF' : $ this -> maximumQuantity , 'max_msg' => $ this -> maximumMessage , 'a_qty' => INF === $ this -> availableQuantity ? 'INF' : $ this -> availableQuantity , 'a_msg' => $ this -> availableMessage , 'r_qty' => $ this -> resupplyQuantity , 'r_msg' => $ this -> resupplyMessage , ] ; }
9796	public function hasHyperlink ( ) { if ( ! isset ( $ this -> parent ) ) { throw new Exception ( 'Cannot check for hyperlink when cell is not bound to a worksheet' ) ; } return $ this -> getWorksheet ( ) -> hyperlinkExists ( $ this -> getCoordinate ( ) ) ; }
3027	private function makeRequest ( $ method , $ path , $ options , $ addApiKey ) { if ( $ addApiKey ) { $ options = array_merge ( array ( 'api_key' => $ this -> apiKey ) , $ options ? : array ( ) ) ; } return $ this -> requestHandler -> request ( $ method , $ path , $ options ) ; }
5872	public static function getTransformation ( $ orientation ) { $ transformation = '' ; if ( ( isset ( $ GLOBALS [ 'TYPO3_CONF_VARS' ] [ 'GFX' ] [ 'processor' ] ) && $ GLOBALS [ 'TYPO3_CONF_VARS' ] [ 'GFX' ] [ 'processor' ] === 'ImageMagick' ) || ( isset ( $ GLOBALS [ 'TYPO3_CONF_VARS' ] [ 'GFX' ] [ 'im_version_5' ] ) && $ GLOBALS [ 'TYPO3_CONF_VARS' ] [ 'GFX' ] [ 'im_version_5' ] !== 'gm' ) ) { if ( $ orientation >= 2 && $ orientation <= 8 ) { $ transformation = '-auto-orient' ; } } else { switch ( $ orientation ) { case 2 : $ transformation = '-flip horizontal' ; break ; case 3 : $ transformation = '-rotate 180' ; break ; case 4 : $ transformation = '-flip vertical' ; break ; case 5 : $ transformation = '-transpose' ; break ; case 6 : $ transformation = '-rotate 90' ; break ; case 7 : $ transformation = '-transverse' ; break ; case 8 : $ transformation = '-rotate 270' ; break ; } } return $ transformation ; }
5737	public function selectRenderer ( ViewEvent $ e ) { if ( $ this -> renderer -> canRender ( $ e -> getModel ( ) -> getTemplate ( ) ) ) { return $ this -> renderer ; } return false ; }
5916	public function resetPassword ( $ hash , $ password ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'hash' => $ hash , 'password' => $ password ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/accounts/users/resetpassword' , $ parameters ) ; return $ result ; }
5296	public function setOptions ( $ options = array ( ) ) { $ this -> options = array_merge ( $ this -> options , $ options ) ; $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] [ 'id' ] = $ this -> options [ 'id' ] ; $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] [ 'horiz-adv-x' ] = $ this -> options [ 'horiz-adv-x' ] ; $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] -> { 'font-face' } [ 0 ] [ 'units-per-em' ] = $ this -> options [ 'units-per-em' ] ; $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] -> { 'font-face' } [ 0 ] [ 'ascent' ] = $ this -> options [ 'ascent' ] ; $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] -> { 'font-face' } [ 0 ] [ 'descent' ] = $ this -> options [ 'descent' ] ; $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] -> { 'font-face' } [ 0 ] [ 'x-height' ] = $ this -> options [ 'x-height' ] ; $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] -> { 'font-face' } [ 0 ] [ 'cap-height' ] = $ this -> options [ 'cap-height' ] ; $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] -> { 'missing-glyph' } [ 0 ] [ 'horiz-adv-x' ] = $ this -> options [ 'horiz-adv-x' ] ; }
11376	public function loadSubmodules ( ) { $ this -> modules = $ this -> submodules ; foreach ( $ this -> submodules as $ module => $ settings ) { $ mod = $ this -> getModule ( $ module ) ; $ mod -> init ( ) ; } return true ; }
4522	public function postLoad ( LifecycleEventArgs $ args ) { $ entity = $ args -> getEntity ( ) ; if ( ! $ entity instanceof Config ) { return ; } $ key = $ entity -> getKey ( ) ; $ encrypt = $ this -> configCollection -> get ( $ key ) [ 'encrypt' ] ; $ entity -> setEncrypt ( $ encrypt ) ; }
4340	private function uncollapseErrors ( & $ log ) { $ groupStack = array ( ) ; for ( $ i = 0 , $ count = \ count ( $ log ) ; $ i < $ count ; $ i ++ ) { $ method = $ log [ $ i ] [ 0 ] ; if ( \ in_array ( $ method , array ( 'group' , 'groupCollapsed' ) ) ) { $ groupStack [ ] = $ i ; } elseif ( $ method == 'groupEnd' ) { \ array_pop ( $ groupStack ) ; } elseif ( \ in_array ( $ method , array ( 'error' , 'warn' ) ) ) { foreach ( $ groupStack as $ i2 ) { $ log [ $ i2 ] [ 0 ] = 'group' ; } } } }
858	public function setCode ( $ code ) { if ( $ code === $ this -> generateCode ( ) ) { return ; } $ this -> setSize ( 0 ) ; $ tokens = \ defined ( 'TOKEN_PARSE' ) ? token_get_all ( $ code , TOKEN_PARSE ) : token_get_all ( $ code ) ; $ this -> setSize ( \ count ( $ tokens ) ) ; foreach ( $ tokens as $ index => $ token ) { $ this [ $ index ] = new Token ( $ token ) ; } $ transformers = Transformers :: create ( ) ; $ transformers -> transform ( $ this ) ; $ this -> foundTokenKinds = [ ] ; foreach ( $ this as $ token ) { $ this -> registerFoundToken ( $ token ) ; } $ this -> rewind ( ) ; $ this -> changeCodeHash ( self :: calculateCodeHash ( $ code ) ) ; $ this -> changed = true ; }
10091	protected function checkOptionsArray ( $ options ) { if ( isset ( $ options [ 's' ] ) ) { $ options [ 'size' ] = $ options [ 's' ] ; unset ( $ options [ 's' ] ) ; } if ( isset ( $ options [ 'd' ] ) ) { $ options [ 'default' ] = $ options [ 'd' ] ; unset ( $ options [ 'd' ] ) ; } $ allowedOptions = array ( 'algorithm' => true , 'default' => true , 'https' => true , 'size' => true , ) ; foreach ( $ options as $ key => $ value ) { if ( ! isset ( $ allowedOptions [ $ key ] ) ) { throw new InvalidArgumentException ( 'Invalid option in array: ' . $ key ) ; } } return $ options ; }
7381	public function route ( bool $ dropIndex = false ) : string { if ( $ dropIndex ) { if ( 'index' == $ this -> route ) { return '' ; } } return $ this -> route ; }
10888	public function addOption ( $ short , $ long , $ arg , $ description ) { $ this -> parameters [ ] = array ( $ short , $ long , $ arg , $ description ) ; return $ this ; }
5695	public function nestedFormSave ( $ data , $ form , $ request ) { $ formAction = $ this -> getFormActionFromRequest ( $ request ) ; $ actionName = $ formAction -> getButtonName ( ) ; $ this -> record -> $ actionName ( $ data , $ form , $ request ) ; return Controller :: curr ( ) -> redirectBack ( ) ; }
11958	public function remove ( $ element ) { if ( ! $ this -> contains ( $ element ) ) { return false ; } $ this -> offsetUnset ( $ this -> indexOf ( $ element ) ) ; return true ; }
12137	public function update ( QuestionRequest $ request , Question $ question ) { try { $ request = $ request -> all ( ) ; $ attributes [ 'title' ] = $ request [ 'title' ] ; $ attributes [ 'question' ] = $ request [ 'question' ] ; $ attributes [ 'category_id' ] = $ request [ 'category_id' ] ; $ question -> update ( $ attributes ) ; return redirect ( '/discussion/' . $ request [ 'slug' ] ) ; } catch ( Exception $ e ) { return $ this -> response -> message ( $ e -> getMessage ( ) ) -> code ( 400 ) -> status ( 'error' ) -> url ( guard_url ( 'forum/question/' . $ question -> getRouteKey ( ) ) ) -> redirect ( ) ; } }
12314	public function newAction ( Request $ request ) { $ category = new Category ( ) ; $ form = $ this -> createForm ( 'BlogBundle\Form\CategoryType' , $ category ) ; $ form -> handleRequest ( $ request ) ; if ( $ form -> isSubmitted ( ) && $ form -> isValid ( ) ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ em -> persist ( $ category ) ; $ em -> flush ( ) ; $ this -> get ( 'session' ) -> getFlashBag ( ) -> add ( 'success' , 'category.created' ) ; return $ this -> redirectToRoute ( 'blog_category_index' ) ; } return array ( 'category' => $ category , 'form' => $ form -> createView ( ) , ) ; }
336	protected function findConstraints ( $ table ) { $ sql = <<<'SQL'SELECT /*+ PUSH_PRED(C) PUSH_PRED(D) PUSH_PRED(E) */ D.CONSTRAINT_NAME, D.CONSTRAINT_TYPE, C.COLUMN_NAME, C.POSITION, D.R_CONSTRAINT_NAME, E.TABLE_NAME AS TABLE_REF, F.COLUMN_NAME AS COLUMN_REF, C.TABLE_NAMEFROM ALL_CONS_COLUMNS C INNER JOIN ALL_CONSTRAINTS D ON D.OWNER = C.OWNER AND D.CONSTRAINT_NAME = C.CONSTRAINT_NAME LEFT JOIN ALL_CONSTRAINTS E ON E.OWNER = D.R_OWNER AND E.CONSTRAINT_NAME = D.R_CONSTRAINT_NAME LEFT JOIN ALL_CONS_COLUMNS F ON F.OWNER = E.OWNER AND F.CONSTRAINT_NAME = E.CONSTRAINT_NAME AND F.POSITION = C.POSITIONWHERE C.OWNER = :schemaName AND C.TABLE_NAME = :tableNameORDER BY D.CONSTRAINT_NAME, C.POSITIONSQL ; $ command = $ this -> db -> createCommand ( $ sql , [ ':tableName' => $ table -> name , ':schemaName' => $ table -> schemaName , ] ) ; $ constraints = [ ] ; foreach ( $ command -> queryAll ( ) as $ row ) { if ( $ this -> db -> slavePdo -> getAttribute ( \ PDO :: ATTR_CASE ) === \ PDO :: CASE_LOWER ) { $ row = array_change_key_case ( $ row , CASE_UPPER ) ; } if ( $ row [ 'CONSTRAINT_TYPE' ] === 'P' ) { $ table -> columns [ $ row [ 'COLUMN_NAME' ] ] -> isPrimaryKey = true ; $ table -> primaryKey [ ] = $ row [ 'COLUMN_NAME' ] ; if ( empty ( $ table -> sequenceName ) ) { $ table -> sequenceName = $ this -> getTableSequenceName ( $ table -> name ) ; } } if ( $ row [ 'CONSTRAINT_TYPE' ] !== 'R' ) { continue ; } $ name = $ row [ 'CONSTRAINT_NAME' ] ; if ( ! isset ( $ constraints [ $ name ] ) ) { $ constraints [ $ name ] = [ 'tableName' => $ row [ 'TABLE_REF' ] , 'columns' => [ ] , ] ; } $ constraints [ $ name ] [ 'columns' ] [ $ row [ 'COLUMN_NAME' ] ] = $ row [ 'COLUMN_REF' ] ; } foreach ( $ constraints as $ constraint ) { $ name = current ( array_keys ( $ constraint ) ) ; $ table -> foreignKeys [ $ name ] = array_merge ( [ $ constraint [ 'tableName' ] ] , $ constraint [ 'columns' ] ) ; } }
9768	function lengthOf ( int $ value = null ) : self { if ( $ value === null ) return $ this -> setFlag ( 'length' ) ; if ( is_string ( $ this -> target ) ) { $ constraint = equalTo ( $ value ) ; $ target = mb_strlen ( $ this -> target ) ; } else { $ constraint = countOf ( $ value ) ; $ target = $ this -> target ; } return $ this -> expect ( $ target , $ constraint ) ; }
8185	public function getParent ( array $ context ) { if ( null !== $ this -> parent ) { return $ this -> parent ; } try { $ parent = $ this -> doGetParent ( $ context ) ; if ( false === $ parent ) { return false ; } if ( $ parent instanceof self ) { return $ this -> parents [ $ parent -> getTemplateName ( ) ] = $ parent ; } if ( ! isset ( $ this -> parents [ $ parent ] ) ) { $ this -> parents [ $ parent ] = $ this -> loadTemplate ( $ parent ) ; } } catch ( Twig_Error_Loader $ e ) { $ e -> setSourceContext ( null ) ; $ e -> guess ( ) ; throw $ e ; } return $ this -> parents [ $ parent ] ; }
5928	public function createCategory ( Category $ category ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'category' => $ category ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/categories' , $ parameters ) ; $ result = new CategoryResponse ( $ result ) ; return $ result ; }
8775	public function admin ( $ data = null , $ secure = false ) { $ data = ( ! is_null ( $ data ) ) ? $ this -> url . '/' . ADMIN_FOLDER . '/' . $ data : $ this -> url . '/' . ADMIN_FOLDER . '/' ; return $ this -> getUrl ( $ data , $ secure ) ; }
10836	private function compileUsing ( array $ join ) { $ sql = array ( ) ; list ( $ using , $ table , $ type , $ column ) = $ join ; if ( $ type !== null ) { $ sql [ ] = $ type ; } array_push ( $ sql , "JOIN" , $ table , "USING({$column})" ) ; return join ( ' ' , $ sql ) ; }
5314	protected function generate ( ) { $ this -> reset ( ) ; foreach ( range ( 1 , $ this -> getCount ( ) ) as $ counter ) { $ this -> codes [ ] = $ this -> generateBlocks ( ) ; } return $ this -> codes ; }
4060	public static function compare ( $ expected , $ actual , $ strict = true ) { try { self :: calculateDiff ( $ expected , $ actual , $ strict ) ; } catch ( \ Exception $ exception ) { $ instance = new DifferentValuesException ( $ expected , $ actual , $ strict , 'The values differ.' , 0 , $ exception ) ; throw $ instance ; } }
9390	public function getSortValBeforeAll ( $ groupingId = null ) { if ( $ groupingId === null && $ this -> grpColumn ) { throw new SortableException ( 'groupingId may be omitted only when grpColumn is not configured.' ) ; } $ query = ( new Query ( ) ) -> select ( [ $ this -> pkColumn , $ this -> srtColumn ] ) -> from ( $ this -> targetTable ) -> where ( [ 'and' , $ this -> grpColumn ? [ '=' , $ this -> grpColumn , $ groupingId ] : [ ] , $ this -> skipRowsClause ( ) ] ) -> orderBy ( [ $ this -> srtColumn => SORT_ASC ] ) -> limit ( 1 ) ; $ result = $ query -> one ( $ this -> db ) ; if ( $ result && $ result [ $ this -> srtColumn ] == 1 ) { $ this -> rebuildSortAfter ( $ result [ $ this -> pkColumn ] , true ) ; $ sortVal = $ this -> getIniSortVal ( ) ; } else if ( $ result ) { $ sortVal = ceil ( $ result [ $ this -> srtColumn ] / 2 ) ; } else $ sortVal = $ this -> getIniSortVal ( ) ; return ( int ) $ sortVal ; }
1181	protected function createFormRequest ( $ class ) { list ( $ class , $ params ) = $ this -> parseFormRequestName ( $ class ) ; $ request = $ this -> app -> __get ( 'request' ) ; $ formRequest = $ this -> app -> build ( $ class , $ params ) ; if ( $ session = $ request -> getSession ( ) ) { $ formRequest -> setLaravelSession ( $ session ) ; } $ formRequest -> setUserResolver ( $ request -> getUserResolver ( ) ) ; $ formRequest -> setRouteResolver ( $ request -> getRouteResolver ( ) ) ; $ formRequest -> setContainer ( $ this -> app ) ; $ formRequest -> query = $ request -> query ; return $ formRequest ; }
2995	protected function encodeHeader ( $ str ) { if ( extension_loaded ( 'iconv' ) ) { $ out = iconv_mime_encode ( 'Subject' , $ str , [ 'input-charset' => 'UTF-8' , 'output-charset' => $ this -> charset ] ) ; $ out = substr ( $ out , strlen ( 'Subject: ' ) ) ; } elseif ( extension_loaded ( 'mbstring' ) ) { mb_internal_encoding ( 'UTF-8' ) ; $ out = mb_encode_mimeheader ( $ str , $ this -> charset , 'B' , static :: $ EOL , strlen ( 'Subject: ' ) ) ; } else $ out = wordwrap ( $ str , 65 , static :: $ EOL ) ; return $ out ; }
8239	public function setAuthenticated ( $ v ) { if ( ! $ v ) { $ this -> authenticator = null ; } $ this -> authenticated = $ v ; return $ this ; }
6847	public static function adjust ( $ hour , $ ampm ) { $ hour = ( int ) $ hour ; $ ampm = strtolower ( $ ampm ) ; switch ( $ ampm ) { case 'am' : if ( $ hour == 12 ) { $ hour = 0 ; } break ; case 'pm' : if ( $ hour < 12 ) { $ hour += 12 ; } break ; } return sprintf ( '%02d' , $ hour ) ; }
3056	public function persistLastCatItemOutput ( array $ lastCatItemOutput ) { $ sessionId = $ this -> getTestSession ( ) -> getSessionId ( ) ; $ this -> getServiceManager ( ) -> get ( ExtendedStateService :: SERVICE_ID ) -> setCatValue ( $ sessionId , $ this -> getCatSection ( ) -> getSectionId ( ) , 'cat-item-output' , json_encode ( $ lastCatItemOutput ) ) ; }
2100	public static function getNumericTimeFormat ( ) { if ( TL_MODE == 'FE' ) { global $ objPage ; if ( $ objPage -> timeFormat != '' && static :: isNumericFormat ( $ objPage -> timeFormat ) ) { return $ objPage -> timeFormat ; } } return Config :: get ( 'timeFormat' ) ; }
11846	final public function reset ( $ column ) { if ( $ this -> isDirty ( $ column ) ) { $ this -> _data [ $ column ] = $ this -> _cleanData [ $ column ] ; unset ( $ this -> _modifiedFields [ $ column ] ) ; } }
9083	private static function parseGetPostSessionCookie ( Request & $ request ) { foreach ( $ _GET as $ name => $ value ) { $ request -> params [ $ name ] = $ value ; } foreach ( $ _POST as $ name => $ value ) { $ request -> params [ $ name ] = $ value ; } foreach ( $ _COOKIE as $ name => $ value ) { $ request -> params [ $ name ] = $ value ; } foreach ( $ _FILES as $ name => $ value ) { $ request -> params [ $ name ] = $ value ; } if ( isset ( $ _SESSION ) ) { foreach ( $ _SESSION as $ name => $ value ) { $ request -> params [ $ name ] = $ value ; } } }
9172	public function getViewHelpers ( ) { return [ 'aliases' => [ 'formmulticheckbox' => Form \ View \ Helper \ FormMultiCheckbox :: class , 'formradio' => Form \ View \ Helper \ FormRadio :: class , 'zettaFlashMessenger' => View \ Helper \ FlashMessenger :: class , 'zettaFormMultiCheckbox' => Form \ View \ Helper \ FormMultiCheckbox :: class , 'zettaFormRadio' => Form \ View \ Helper \ FormRadio :: class , 'zettaFormRow' => Form \ View \ Helper \ FormRow :: class , 'zettaPaginator' => View \ Helper \ Paginator :: class , 'zettaReferer' => View \ Helper \ Referer :: class , 'settings' => View \ Helper \ Settings :: class , 'thumbnail' => View \ Helper \ Thumbnail :: class , 'zettaUrl' => View \ Helper \ Url :: class , ] , 'factories' => [ Form \ View \ Helper \ FormMultiCheckbox :: class => InvokableFactory :: class , Form \ View \ Helper \ FormRadio :: class => InvokableFactory :: class , Form \ View \ Helper \ FormRow :: class => InvokableFactory :: class , View \ Helper \ FlashMessenger :: class => InvokableFactory :: class , View \ Helper \ Paginator :: class => View \ Helper \ Factory \ PaginatorFactory :: class , View \ Helper \ Referer :: class => View \ Helper \ Factory \ RefererFactory :: class , View \ Helper \ Settings :: class => Factory \ WithSettingsFactory :: class , View \ Helper \ Thumbnail :: class => Factory \ WithThumbnailFactory :: class , View \ Helper \ Url :: class => View \ Helper \ Factory \ UrlFactory :: class ] , ] ; }
10322	function getSubscribersCount ( $ fromDate = null , $ toDate = null , $ mailingIds = array ( ) , $ contactIds = array ( ) , $ contactEmails = array ( ) , $ contactExternalIds = array ( ) , $ excludeAnonymousContacts = false ) { $ params = $ this -> createCountQueryParameters ( $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , $ mailingIds , null ) ; if ( isset ( $ excludeAnonymousContacts ) ) $ params [ 'exclude_anonymous_contacts' ] = ( $ excludeAnonymousContacts == true ) ? "true" : "false" ; return $ this -> get ( 'reports/subscribers/count' , $ params ) ; }
2138	public function onKernelRequest ( GetResponseEvent $ event ) : void { $ request = $ event -> getRequest ( ) ; if ( \ in_array ( $ request -> getClientIp ( ) , [ '127.0.0.1' , 'fe80::1' , '::1' ] , true ) ) { return ; } if ( '' === $ request -> getBasePath ( ) ) { return ; } throw new InsecureInstallationException ( 'Your installation is not secure. Please set the document root to the /web subfolder.' ) ; }
10232	private function writeLine ( $ pFileHandle , array $ pValues ) { $ writeDelimiter = false ; $ line = '' ; foreach ( $ pValues as $ element ) { $ element = str_replace ( $ this -> enclosure , $ this -> enclosure . $ this -> enclosure , $ element ) ; if ( $ writeDelimiter ) { $ line .= $ this -> delimiter ; } else { $ writeDelimiter = true ; } $ line .= $ this -> enclosure . $ element . $ this -> enclosure ; } $ line .= $ this -> lineEnding ; fwrite ( $ pFileHandle , $ line ) ; }
7919	protected function renderInput ( $ options = [ ] , $ resultsOptions = [ ] ) { Html :: addCssClass ( $ options , 'prompt' ) ; $ lines = [ ] ; $ input = $ this -> hasModel ( ) ? Html :: activeTextInput ( $ this -> model , $ this -> attribute , $ options ) : Html :: textInput ( $ this -> name , $ this -> value , $ options ) ; if ( ! empty ( $ this -> displayIcon ) ) { $ lines [ ] = Html :: beginTag ( 'div' , [ 'class' => 'ui icon input' ] ) ; $ lines [ ] = $ input ; $ lines [ ] = Html :: tag ( 'i' , '' , [ 'class' => 'icon search' ] ) ; $ lines [ ] = Html :: endTag ( 'div' ) ; } else { $ lines [ ] = $ input ; } $ lines [ ] = Html :: tag ( 'div' , '' , $ resultsOptions ) ; return implode ( "\n" , $ lines ) ; }
4723	public function setAttribute ( $ attribute , $ value = null ) { $ this -> attributes -> set ( $ attribute , $ value ) ; return $ this ; }
12710	public function make ( $ instance , $ parameters = [ ] ) { return $ this -> resolve ( $ instance , is_array ( $ parameters ) ? $ parameters : array_slice ( func_get_args ( ) , 1 ) ) ; }
4748	public function getPlan ( string $ planCode ) : array { $ cacheKey = sprintf ( 'plan_%s' , $ planCode ) ; $ hit = $ this -> getFromCache ( $ cacheKey ) ; if ( false === $ hit ) { $ response = $ this -> sendRequest ( 'GET' , sprintf ( 'plans/%s' , $ planCode ) ) ; $ data = $ this -> processResponse ( $ response ) ; $ plan = $ data [ 'plan' ] ; $ this -> saveToCache ( $ cacheKey , $ plan ) ; return $ plan ; } return $ hit ; }
1872	protected function convertValuesToPaths ( ) { if ( empty ( $ this -> varValue ) ) { return ; } if ( ! \ is_array ( $ this -> varValue ) ) { $ this -> varValue = array ( $ this -> varValue ) ; } elseif ( empty ( $ this -> varValue [ 0 ] ) ) { $ this -> varValue = array ( ) ; } if ( empty ( $ this -> varValue ) ) { return ; } if ( strpos ( $ this -> varValue [ 0 ] , Config :: get ( 'uploadPath' ) . '/' ) === 0 ) { return ; } if ( Input :: get ( 'switch' ) ) { return ; } if ( $ this -> path != '' && strpos ( $ this -> path , Config :: get ( 'uploadPath' ) . '/' ) !== 0 ) { return ; } $ objFiles = FilesModel :: findMultipleByIds ( $ this -> varValue ) ; if ( $ objFiles !== null ) { $ this -> varValue = array_values ( $ objFiles -> fetchEach ( 'path' ) ) ; } }
10705	public function getEntityManager ( ) { if ( null === $ this -> em ) { $ mainService = $ this -> getServiceLocator ( ) -> get ( 'neobazaar.service.main' ) ; $ this -> em = $ mainService -> getEntityManager ( ) ; } return $ this -> em ; }
8069	public function bind ( $ username , $ password ) { if ( $ this -> tls ) { if ( ! ldap_start_tls ( $ this -> connection ) ) { throw new ConnectionException ( 'Unable to Connect to LDAP using TLS.' ) ; } } try { $ this -> bound = ldap_bind ( $ this -> connection , $ username , $ password ) ; } catch ( ErrorException $ e ) { $ this -> bound = false ; } return $ this -> bound ; }
12251	public function getNode ( $ strName , $ varDefault = false ) { $ varResult = $ this -> $ strName ; if ( ( $ varResult !== false ) && ( ( string ) $ varResult !== '' ) ) { return ( string ) $ varResult ; } else { return $ varDefault ; } }
6655	public function normalizeHeaders ( $ params ) { $ out = '' ; foreach ( $ params as $ key => $ param ) { $ out .= $ key . '="' . rawurlencode ( trim ( $ param ) ) . '",' ; } return rtrim ( $ out , ',' ) ; }
9663	public static function registerWriter ( $ writerType , $ writerClass ) { if ( ! is_a ( $ writerClass , Writer \ IWriter :: class , true ) ) { throw new Writer \ Exception ( 'Registered writers must implement ' . Writer \ IWriter :: class ) ; } self :: $ writers [ $ writerType ] = $ writerClass ; }
140	public function markAliasInstalled ( RepositoryInterface $ repo , MarkAliasInstalledOperation $ operation ) { $ package = $ operation -> getPackage ( ) ; if ( ! $ repo -> hasPackage ( $ package ) ) { $ repo -> addPackage ( clone $ package ) ; } }
766	public function setIdentity ( $ identity ) { if ( $ identity instanceof IdentityInterface ) { $ this -> _identity = $ identity ; } elseif ( $ identity === null ) { $ this -> _identity = null ; } else { throw new InvalidValueException ( 'The identity object must implement IdentityInterface.' ) ; } $ this -> _access = [ ] ; }
8084	public function clearErrors ( $ channelName = '' ) { $ channel = $ this -> namespaceChannel ( $ channelName ) ; $ this -> console [ 'errors' ] [ $ channel ] = array ( ) ; $ this -> console [ 'form' ] [ $ channel ] = array ( ) ; }
8093	public function get ( $ keyPath ) { $ stops = explode ( '.' , $ keyPath ) ; $ value = $ this ; foreach ( $ stops as $ key ) { if ( $ value instanceof Collection ) { $ value = $ value -> $ key ; } else { $ value = null ; break ; } } return $ value ; }
12289	private function make ( string $ block , array $ vars = null ) : string { $ commonVars = static :: COMMON_NAME . static :: VARS_PROPERTY_SUFFIX ; $ blockVars = $ block . static :: VARS_PROPERTY_SUFFIX ; $ allVars = [ ] ; if ( isset ( $ this -> $ commonVars ) && is_array ( $ this -> $ commonVars ) ) { $ allVars = $ this -> $ commonVars ; } if ( isset ( $ this -> $ blockVars ) && is_array ( $ this -> $ blockVars ) ) { $ allVars += $ this -> $ blockVars ; } if ( isset ( $ vars ) ) { $ allVars += $ vars ; } $ file = $ this -> path . $ this -> { $ block . static :: BLOCK_PROPERTY_SUFFIX } . '.' . static :: FILE_EXTENSION ; $ localScope = function ( $ vars , $ file ) { ob_start ( ) ; extract ( $ vars ) ; try { require $ file ; } catch ( \ Exception $ exception ) { ob_end_clean ( ) ; throw $ exception ; } $ _ = isset ( $ _ ) ? str_pad ( '' , $ _ ) : '' ; return str_replace ( PHP_EOL , PHP_EOL . $ _ , PHP_EOL . ob_get_clean ( ) ) ; } ; return $ localScope ( $ allVars , $ file ) ; }
8125	protected function getSchemaRequested ( ) { $ parts = $ this -> owner -> getRequest ( ) -> getHeader ( LeftAndMain :: SCHEMA_HEADER ) ; return ! empty ( $ parts ) ; }
8349	public static function toArray ( ) : array { if ( static :: $ array == null ) { $ ref = new \ ReflectionClass ( static :: class ) ; $ consts = $ ref -> getConstants ( ) ; static :: $ array = array ( ) ; foreach ( $ consts as $ key => $ value ) { if ( stripos ( $ key , 'VALUE_' ) === 0 ) { static :: $ array [ $ key ] = $ value ; } } } return static :: $ array ; }
8788	public function style ( $ url , $ attributes = [ ] , $ secure = null ) { $ defaults = [ 'media' => 'all' , 'type' => 'text/css' , 'rel' => 'stylesheet' ] ; $ attributes = array_merge ( $ attributes , $ defaults ) ; $ attributes [ 'href' ] = $ this -> uri -> assets ( $ url , $ secure ) ; return $ this -> toHtmlString ( '<link' . $ this -> attributes ( $ attributes ) . '>' . PHP_EOL ) ; }
5298	public function addGlyph ( $ char , $ path , $ name = null , $ width = null ) { $ glyph = $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] -> addChild ( 'glyph' ) ; $ glyph -> addAttribute ( 'unicode' , $ char ) ; if ( $ name !== null ) { $ glyph -> addAttribute ( 'glyph-name' , $ name ) ; } if ( $ width !== null ) { $ glyph -> addAttribute ( 'horiz-adv-x' , $ width ) ; } $ glyph -> addAttribute ( 'd' , $ path ) ; }
1683	public function getModules ( ) { $ arrModules = array ( ) ; foreach ( $ GLOBALS [ 'BE_MOD' ] as $ k => $ v ) { if ( ! empty ( $ v ) ) { if ( $ k == 'accounts' ) { unset ( $ v [ 'login' ] ) ; } if ( $ k == 'system' ) { unset ( $ v [ 'undo' ] ) ; } $ arrModules [ $ k ] = array_keys ( $ v ) ; } } return $ arrModules ; }
1942	public function listRecipient ( $ row ) { $ label = Contao \ Idna :: decodeEmail ( $ row [ 'email' ] ) ; if ( $ row [ 'addedOn' ] ) { $ label .= ' <span style="color:#999;padding-left:3px">(' . sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_newsletter_recipients' ] [ 'subscribed' ] , Contao \ Date :: parse ( Contao \ Config :: get ( 'datimFormat' ) , $ row [ 'addedOn' ] ) ) . ')</span>' ; } else { $ label .= ' <span style="color:#999;padding-left:3px">(' . $ GLOBALS [ 'TL_LANG' ] [ 'tl_newsletter_recipients' ] [ 'manually' ] . ')</span>' ; } return sprintf ( '<div class="tl_content_left"><div class="list_icon" style="background-image:url(\'%ssystem/themes/%s/icons/%s.svg\')" data-icon="member.svg" data-icon-disabled="member_.svg">%s</div></div>' , Contao \ System :: getContainer ( ) -> get ( 'contao.assets.assets_context' ) -> getStaticUrl ( ) , Contao \ Backend :: getTheme ( ) , ( $ row [ 'active' ] ? 'member' : 'member_' ) , $ label ) . "\n" ; }
2950	private function failedDispatch ( $ queue , \ Exception $ error ) { foreach ( $ queue as $ index => $ data ) { $ this -> clear ( $ data [ 'key' ] ) ; $ data [ 'reject' ] ( $ error ) ; } }
1021	public function toSerializableArray ( ) { $ arr = [ 'message' => $ this -> getMessage ( ) , ] ; $ locations = Utils :: map ( $ this -> getLocations ( ) , static function ( SourceLocation $ loc ) { return $ loc -> toSerializableArray ( ) ; } ) ; if ( ! empty ( $ locations ) ) { $ arr [ 'locations' ] = $ locations ; } if ( ! empty ( $ this -> path ) ) { $ arr [ 'path' ] = $ this -> path ; } if ( ! empty ( $ this -> extensions ) ) { $ arr [ 'extensions' ] = $ this -> extensions ; } return $ arr ; }
9702	public function addFont ( \ PhpOffice \ PhpSpreadsheet \ Style \ Font $ font ) { $ fontHashCode = $ font -> getHashCode ( ) ; if ( isset ( $ this -> addedFonts [ $ fontHashCode ] ) ) { $ fontIndex = $ this -> addedFonts [ $ fontHashCode ] ; } else { $ countFonts = count ( $ this -> fontWriters ) ; $ fontIndex = ( $ countFonts < 4 ) ? $ countFonts : $ countFonts + 1 ; $ fontWriter = new Font ( $ font ) ; $ fontWriter -> setColorIndex ( $ this -> addColor ( $ font -> getColor ( ) -> getRGB ( ) ) ) ; $ this -> fontWriters [ ] = $ fontWriter ; $ this -> addedFonts [ $ fontHashCode ] = $ fontIndex ; } return $ fontIndex ; }
2575	protected function loadRequestCreatorParams ( $ params ) { if ( isset ( $ params [ 'requestCreatorParams' ] ) ) { if ( $ params [ 'requestCreatorParams' ] instanceof RequestCreatorParams ) { $ this -> requestCreatorParams = $ params [ 'requestCreatorParams' ] ; } elseif ( is_array ( $ params [ 'requestCreatorParams' ] ) ) { $ this -> requestCreatorParams = new RequestCreatorParams ( $ params [ 'requestCreatorParams' ] ) ; } } }
8997	public function isEmpty ( $ filter = null ) : bool { if ( ! $ this -> exists ( ) ) { throw new DirectoryException ( "Directory {dir} does not exist" , array ( 'dir' => $ this -> path ) ) ; } $ iter = new \ DirectoryIterator ( $ this -> path ) ; while ( $ iter -> valid ( ) ) { if ( ! $ iter -> isDot ( ) && ( $ filter === null || ! preg_match ( "/$filter/" , $ iter -> getFilename ( ) ) ) ) { return false ; } $ iter -> next ( ) ; } return true ; }
8018	public function getUrl ( $ name , $ expires = NULL ) { return $ this -> getClient ( ) -> getObjectUrl ( $ this -> bucket , $ name , $ expires ) ; }
9385	public function getGroupedIcons ( ) { if ( $ icons = self :: cache ( ) -> get ( $ this -> getCacheKey ( ) ) ) { return $ icons ; } $ icons = [ ] ; $ data = Yaml :: parse ( $ this -> getSourceData ( ) ) ; if ( isset ( $ data [ 'icons' ] ) ) { foreach ( $ data [ 'icons' ] as $ icon ) { foreach ( $ icon [ 'categories' ] as $ category ) { if ( ! isset ( $ icons [ $ category ] ) ) { $ icons [ $ category ] = [ ] ; } $ icons [ $ category ] [ $ icon [ 'id' ] ] = [ 'name' => $ icon [ 'name' ] , 'unicode' => $ icon [ 'unicode' ] ] ; } } } ksort ( $ icons ) ; foreach ( $ icons as & $ group ) { uasort ( $ group , function ( $ a , $ b ) { return strcasecmp ( $ a [ 'name' ] , $ b [ 'name' ] ) ; } ) ; } self :: cache ( ) -> set ( $ this -> getCacheKey ( ) , $ icons ) ; return $ icons ; }
11243	public function setDirection ( Neuron_GameServer_Map_Vector3 $ start , Neuron_GameServer_Map_Vector3 $ end ) { $ this -> startRotation = $ start ; $ this -> endRotation = $ end ; }
2885	public function saveProfiling ( ) { if ( ! $ this -> canCollect ( ) || ! Mage :: helper ( 'sheep_debug' ) -> canPersist ( ) ) { return ; } if ( Mage :: helper ( 'sheep_debug' ) -> hasDisablePersistenceCookie ( ) ) { return ; } if ( ! $ this -> getRequestInfo ( ) -> getIsStarted ( ) ) { return ; } $ this -> getRequestInfo ( ) -> save ( ) ; }
6598	protected function getParameters ( array $ lines ) { $ comment = implode ( "\n" , $ lines ) ; preg_match_all ( '/@param\s([\s\S]+?(?=@))/' , $ comment , $ paramsDoc ) ; $ params = [ ] ; if ( isset ( $ paramsDoc [ 1 ] ) ) { foreach ( $ paramsDoc [ 1 ] as $ paramDoc ) { $ documentation = [ ] ; preg_match ( '/([^$]+)?\$(\w+)(.+)?/s' , $ paramDoc , $ documentation ) ; list ( , $ type , $ name , $ description ) = $ documentation ; $ lines = preg_split ( "/((\r?\n)|(\r\n?))/" , $ description ) ; foreach ( $ lines as $ key => $ value ) { $ value = preg_replace ( '/\r/' , '' , $ value ) ; $ value = preg_replace ( '/^\s+\*/' , '' , $ value ) ; $ value = trim ( $ value ) ; $ lines [ $ key ] = $ value ; } $ description = implode ( "\n" , $ lines ) ; $ params [ $ name ] = [ 'type' => trim ( $ type ) , 'description' => trim ( $ description ) , ] ; } } return $ params ; }
747	protected function getTypeCategory ( ) { return isset ( $ this -> categoryMap [ $ this -> type ] ) ? $ this -> categoryMap [ $ this -> type ] : null ; }
5444	protected function reduce ( $ raw ) { if ( $ action = $ this -> regexes [ $ this -> mode -> getCurrent ( ) ] -> match ( $ raw , $ match ) ) { $ unparsed_character_count = strpos ( $ raw , $ match ) ; $ unparsed = substr ( $ raw , 0 , $ unparsed_character_count ) ; $ raw = substr ( $ raw , $ unparsed_character_count + strlen ( $ match ) ) ; return array ( $ raw , $ unparsed , $ match , $ action ) ; } return true ; }
2740	public function execute ( ) { $ result = $ this -> resultJsonFactory -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ snippet = Config :: BLOCKING_SETTING_NAME ; $ req = $ this -> api -> hasSnippet ( $ activeVersion , $ snippet ) ; if ( $ req == false ) { return $ result -> setData ( [ 'status' => false ] ) ; } return $ result -> setData ( [ 'status' => true , 'req_setting' => $ req ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
8837	private function hasExceededTimeout ( ) : bool { return - 1 !== $ this -> timeout && ( microtime ( true ) - $ this -> startTime ) * 1000000 > $ this -> timeout ; }
1132	public function insideSubtree ( $ node ) { return ( $ this -> getLeft ( ) >= $ node -> getLeft ( ) && $ this -> getLeft ( ) <= $ node -> getRight ( ) && $ this -> getRight ( ) >= $ node -> getLeft ( ) && $ this -> getRight ( ) <= $ node -> getRight ( ) ) ; }
12583	static function run_tool_version ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { pake_echo ( "eZ Extension Builder ver." . self :: VERSION . "\nRunning on pake " . pakeApp :: VERSION ) ; }
233	public function quoteSimpleTableName ( $ name ) { if ( is_string ( $ this -> tableQuoteCharacter ) ) { $ startingCharacter = $ endingCharacter = $ this -> tableQuoteCharacter ; } else { list ( $ startingCharacter , $ endingCharacter ) = $ this -> tableQuoteCharacter ; } return strpos ( $ name , $ startingCharacter ) !== false ? $ name : $ startingCharacter . $ name . $ endingCharacter ; }
3137	public function parsesItemResponse ( RunnerServiceContext $ context , $ itemRef , $ response ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ session = $ context -> getTestSession ( ) ; $ currentItem = $ context -> getCurrentAssessmentItemRef ( ) ; $ responses = new State ( ) ; if ( $ currentItem === false ) { $ msg = "Trying to store item variables but the state of the test session is INITIAL or CLOSED.\n" ; $ msg .= "Session state value: " . $ session -> getState ( ) . "\n" ; $ msg .= "Session ID: " . $ session -> getSessionId ( ) . "\n" ; $ msg .= "JSON Payload: " . mb_substr ( json_encode ( $ response ) , 0 , 1000 ) ; \ common_Logger :: e ( $ msg ) ; } $ filler = new \ taoQtiCommon_helpers_PciVariableFiller ( $ currentItem , $ this -> getServiceManager ( ) -> get ( QtiFlysystemFileManager :: SERVICE_ID ) ) ; if ( is_array ( $ response ) ) { foreach ( $ response as $ id => $ responseData ) { try { $ var = $ filler -> fill ( $ id , $ responseData ) ; if ( \ taoQtiCommon_helpers_Utils :: isQtiFilePlaceHolder ( $ var ) === false ) { $ responses -> setVariable ( $ var ) ; } } catch ( \ OutOfRangeException $ e ) { \ common_Logger :: d ( "Could not convert client-side value for variable '${id}'." ) ; } catch ( \ OutOfBoundsException $ e ) { \ common_Logger :: d ( "Could not find variable with identifier '${id}' in current item." ) ; } } } else { \ common_Logger :: e ( 'Invalid json payload' ) ; } return $ responses ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'storeItemResponse' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } }
4749	public function getAddonsForPlan ( array $ plans , string $ addonType = null ) : array { $ addonApi = new Addon ( $ this -> token , $ this -> organizationId , $ this -> cache , $ this -> ttl ) ; foreach ( $ plans as & $ plan ) { $ addons = [ ] ; foreach ( $ plan [ 'addons' ] as $ planAddon ) { $ addon = $ addonApi -> getAddon ( $ planAddon [ 'addon_code' ] ) ; if ( null !== $ addonType ) { if ( ( $ addon [ 'type' ] == $ addonType ) && ( in_array ( $ addonType , self :: $ addonTypes ) ) ) { $ addons [ ] = $ addon ; } } else { $ addons [ ] = $ addon ; } } $ plan [ 'addons' ] = $ addons ; } return $ plans ; }
11689	public function isAccompanyingPeriodValid ( ExecutionContextInterface $ context ) { $ r = $ this -> checkAccompanyingPeriodsAreNotCollapsing ( ) ; if ( $ r !== true ) { if ( $ r [ 'result' ] === self :: ERROR_PERIODS_ARE_COLLAPSING ) { $ context -> addViolationAt ( 'accompanyingPeriods' , 'Two accompanying periods have days in commun' , array ( ) ) ; } if ( $ r [ 'result' ] === self :: ERROR_ADDIND_PERIOD_AFTER_AN_OPEN_PERIOD ) { $ context -> addViolationAt ( 'accompanyingPeriods' , 'A period is opened and a period is added after it' , array ( ) ) ; } } }
5199	public function validateOptions ( array $ options ) { foreach ( $ options as $ option => $ value ) { if ( ! in_array ( $ option , $ this -> allowedOptions ) ) throw new InvalidOptionException ( "Option [$option] is not valid" ) ; } return $ this ; }
11181	public function getActions ( ) { $ result = $ this -> get ( Keys :: EXT_ACTION ) ; if ( is_string ( $ result ) ) { return unserialize ( $ result ) ; } return array ( ) ; }
2280	protected static function httpAcceptLanguage ( ) { $ arrAccepted = array ( ) ; $ arrLanguages = array ( ) ; preg_match_all ( '/([a-z]{1,8}(-[a-z]{1,8})?)\s*(;\s*q\s*=\s*(1|0\.[0-9]+))?/i' , $ _SERVER [ 'HTTP_ACCEPT_LANGUAGE' ] , $ arrAccepted ) ; foreach ( $ arrAccepted [ 1 ] as $ v ) { $ chunks = explode ( '-' , $ v ) ; if ( isset ( $ chunks [ 1 ] ) ) { $ locale = $ chunks [ 0 ] . '-' . strtoupper ( $ chunks [ 1 ] ) ; if ( preg_match ( '/^[a-z]{2}(-[A-Z]{2})?$/' , $ locale ) ) { $ arrLanguages [ ] = $ locale ; } } $ locale = $ chunks [ 0 ] ; if ( preg_match ( '/^[a-z]{2}$/' , $ locale ) ) { $ arrLanguages [ ] = $ locale ; } } return \ array_slice ( array_unique ( $ arrLanguages ) , 0 , 8 ) ; }
4423	protected function doInteract ( ) { $ siteAccess = $ this -> askForData ( 'site-access-name' , 'Enter the name of the Netgen Admin UI siteaccess' , 'ngadminui' , function ( $ siteaccess ) { if ( ! preg_match ( '/^[a-z][a-z0-9_]*$/' , $ siteaccess ) ) { throw new InvalidArgumentException ( 'Siteaccess name is not valid. It must start with a letter, followed by any combination of letters, numbers and underscore.' ) ; } $ existingSiteAccesses = $ this -> getContainer ( ) -> getParameter ( 'ezpublish.siteaccess.list' ) ; if ( in_array ( $ siteaccess , $ existingSiteAccesses , true ) ) { throw new InvalidArgumentException ( sprintf ( 'Siteaccess "%s" already exists.' , $ siteaccess ) ) ; } return $ siteaccess ; } ) ; $ this -> output -> writeln ( '' ) ; $ languageCode = $ this -> askForData ( 'language-code' , 'Enter the language code in which the Netgen Admin UI will be translated' , 'eng-GB' , function ( $ languageCode ) { $ languageService = $ this -> getContainer ( ) -> get ( 'ezpublish.api.repository' ) -> getContentLanguageService ( ) ; try { $ languageService -> loadLanguage ( $ languageCode ) ; } catch ( NotFoundException $ e ) { throw new InvalidArgumentException ( sprintf ( 'Language code "%s" does not exist.' , $ languageCode ) ) ; } return $ languageCode ; } ) ; $ this -> output -> writeln ( '' ) ; $ availableGroups = array_keys ( $ this -> getContainer ( ) -> getParameter ( 'ezpublish.siteaccess.groups' ) ) ; $ availableGroups [ ] = 'default' ; $ siteAccessGroup = $ this -> askForChoiceData ( 'site-access-group' , 'Enter the siteaccess group name on which the Netgen Admin UI configuration will be based. This is usually the name of your frontend siteaccess group' , $ availableGroups , current ( $ availableGroups ) ) ; $ this -> writeSection ( 'Summary before installation' ) ; $ this -> output -> writeln ( array ( 'You are going to generate legacy <info>' . $ siteAccess . '</info> siteaccess with <info>' . $ languageCode . '</info> language code based on <info>' . $ siteAccessGroup . '</info> siteaccess group.' , '' , ) ) ; if ( ! $ this -> questionHelper -> ask ( $ this -> input , $ this -> output , $ this -> getConfirmationQuestion ( 'Do you confirm installation (answering <comment>no</comment> will restart the process)' , true ) ) ) { $ this -> output -> writeln ( '' ) ; return false ; } return true ; }
10563	private function _buildActionName ( $ controllerName , $ actionName ) { $ actionName = $ actionName . 'Action' ; if ( ! method_exists ( $ controllerName , $ actionName ) ) { $ actionName = $ this -> defaultAction . 'Action' ; } return $ actionName ; }
2799	public static function generate ( $ mutantFile = null , $ bootstrap = '' , $ replacingFile = null ) { $ loadHumbug = '' ; if ( 'phar:' === substr ( __FILE__ , 0 , 5 ) ) { $ loadHumbug = '\Phar::loadPhar(\'' . str_replace ( 'phar://' , '' , \ Phar :: running ( ) ) . '\', \'humbug.phar\');' ; $ humbugBootstrap = 'phar://humbug.phar' . '/bootstrap.php' ; } else { $ humbugBootstrap = realpath ( __DIR__ . '/../../../bootstrap.php' ) ; } $ file = sys_get_temp_dir ( ) . '/humbug.phpunit.bootstrap.php' ; if ( ! is_null ( $ mutantFile ) ) { $ mutantFile = addslashes ( $ mutantFile ) ; $ replacingFile = addslashes ( $ replacingFile ) ; $ prepend = <<<PREPEND<?php{$loadHumbug}require_once '{$humbugBootstrap}';use Humbug\StreamWrapper\IncludeInterceptor;IncludeInterceptor::intercept('{$replacingFile}', '{$mutantFile}');IncludeInterceptor::enable();PREPEND ; if ( ! empty ( $ bootstrap ) ) { $ buffer = $ prepend . "\nrequire_once '{$bootstrap}';" ; } else { $ buffer = $ prepend ; } file_put_contents ( $ file , $ buffer ) ; } else { if ( ! empty ( $ bootstrap ) ) { $ buffer = "<?php\n{$loadHumbug}\nrequire_once '{$humbugBootstrap}';\nrequire_once '{$bootstrap}';" ; } else { $ buffer = "<?php\n{$loadHumbug}\nrequire_once '{$humbugBootstrap}';" ; } file_put_contents ( $ file , $ buffer ) ; } }
12313	public function toArray ( ) { $ data = [ "uuid" => $ this -> uuid , "code" => $ this -> code , "modules" => $ this -> modules , "vars" => $ this -> vars , ] ; foreach ( [ 'modules' , 'vars' ] as $ key ) { if ( ! array_key_exists ( $ key , $ data ) ) { continue ; } if ( empty ( $ data [ $ key ] ) ) { $ data [ $ key ] = new \ stdClass ( ) ; } } return $ data ; }
9787	public function parseFilteredValue ( ) { list ( $ type , $ filters ) = $ this -> pop ( 'FILTERED_VALUE' ) ; $ value = array_shift ( $ filters ) ; $ opening = '' ; $ closing = '' ; foreach ( $ filters as $ filter ) { if ( function_exists ( $ filter ) ) { $ opening .= $ filter . '(' ; $ closing .= ')' ; } else { $ opening .= '\Katar\Katar::getInstance()->filter(\'' . $ filter . '\', ' ; $ closing .= ')' ; } } return '$output .= ' . $ opening . $ value . $ closing . ";\n" ; }
5995	public function addFolderResponse ( $ item ) { if ( ! ( $ item instanceof self ) ) { if ( is_array ( $ item ) ) { try { $ item = new self ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate FolderResponse. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "FolderResponse"!' , E_USER_WARNING ) ; } } $ this -> subFolders [ ] = $ item ; return $ this ; }
6801	public function installTaxes ( $ codes = [ 'US' ] ) { $ codes = ( array ) $ codes ; if ( empty ( $ codes ) ) { return ; } $ taxRepository = $ this -> manager -> getRepository ( Tax :: class ) ; foreach ( $ codes as $ code ) { $ path = __DIR__ . '/data/' . $ code . '_taxes.yml' ; if ( ! ( file_exists ( $ path ) && is_readable ( $ path ) ) ) { call_user_func ( $ this -> log , 'Taxes data' , 'not found' ) ; continue ; } $ data = Yaml :: parse ( file_get_contents ( $ path ) ) ; if ( ! is_array ( $ data ) || empty ( $ data ) ) { continue ; } $ country = $ this -> manager -> getRepository ( Country :: class ) -> findOneBy ( [ 'code' => $ code ] ) ; if ( null === $ country ) { continue ; } foreach ( $ data as $ datum ) { $ name = $ datum [ 'name' ] ; $ result = 'already exists' ; if ( null === $ taxRepository -> findOneBy ( [ 'name' => $ name ] ) ) { $ tax = new Tax ( ) ; $ tax -> setName ( $ name ) -> setRate ( $ datum [ 'rate' ] ) -> setCountry ( $ country ) ; $ this -> manager -> persist ( $ tax ) ; $ result = 'done' ; } call_user_func ( $ this -> log , $ name , $ result ) ; } } $ this -> manager -> flush ( ) ; }
10395	protected function getShopIds ( ) { $ shopIds = [ ] ; try { $ shops = $ this -> container -> getParameter ( 'ongr_connections.shops' ) ; } catch ( InvalidArgumentException $ e ) { $ shops = [ ] ; } foreach ( $ shops as $ shop ) { $ shopIds [ ] = $ shop [ 'shop_id' ] ; } return $ shopIds ; }
2436	public function getData ( ) { $ data = $ this -> sessionBag -> all ( ) ; foreach ( $ this -> mappedKeys as $ strKey ) { unset ( $ data [ $ strKey ] ) ; if ( $ this -> session -> has ( $ strKey ) ) { $ data [ $ strKey ] = $ this -> session -> get ( $ strKey ) ; } } return $ data ; }
3092	public function load ( ) { if ( ! isset ( $ this -> cache [ $ this -> testSessionId ] ) ) { $ encodedData = $ this -> getStorageService ( ) -> get ( $ this -> getUserKey ( ) , $ this -> getStorageKey ( ) ) ; \ common_Logger :: d ( sprintf ( 'QtiTimer: Loaded %d bytes from state storage' , strlen ( $ encodedData ) ) ) ; $ this -> cache [ $ this -> testSessionId ] = $ this -> getStorageFormat ( ) -> decode ( $ encodedData ) ; } return $ this -> cache [ $ this -> testSessionId ] ; }
10738	public function search ( $ query ) { $ results = new ResultCollection ( ) ; foreach ( $ this -> engines as $ eachEngine ) { if ( ! $ eachEngine -> supports ( $ query ) ) { continue ; } if ( $ more = $ eachEngine -> search ( $ query ) ) { if ( ! is_array ( $ more ) and ! $ more instanceof \ Traversable ) { throw new DomainException ( 'The returned result set is not traversable.' ) ; } foreach ( $ more as $ eachResult ) { $ results -> add ( $ eachResult ) ; } } } return $ results ; }
8327	public function recognizeRecaptchaV2 ( $ googleKey , $ pageUrl , $ extra = [ ] ) { $ captchaId = $ this -> sendRecaptchaV2 ( $ googleKey , $ pageUrl , $ extra ) ; $ startTime = time ( ) ; while ( true ) { $ this -> getLogger ( ) -> info ( "Waiting {$this->rTimeout} sec." ) ; sleep ( $ this -> recaptchaRTimeout ) ; if ( time ( ) - $ startTime >= $ this -> mTimeout ) { throw new RuntimeException ( "Captcha waiting timeout." ) ; } $ result = $ this -> getCaptchaResult ( $ captchaId ) ; if ( $ result === false ) { continue ; } $ this -> getLogger ( ) -> info ( "Elapsed " . ( time ( ) - $ startTime ) . " second(s)." ) ; return $ result ; } throw new RuntimeException ( 'Unknown recognition logic error.' ) ; }
10506	private function registerLogMenu ( ) { $ this -> app -> singleton ( Contracts \ Utilities \ LogMenu :: class , Utilities \ LogMenu :: class ) ; $ this -> app -> singleton ( 'arcanedev.log-viewer.menu' , Contracts \ Utilities \ LogMenu :: class ) ; }
3466	public function put ( string $ route , callable $ controller ) : void { $ this -> register ( $ controller , Route :: put ( $ route ) ) ; }
94	protected function hasVendorIgnore ( $ ignoreFile , $ vendor = 'vendor' ) { if ( ! file_exists ( $ ignoreFile ) ) { return false ; } $ pattern = sprintf ( '{^/?%s(/\*?)?$}' , preg_quote ( $ vendor ) ) ; $ lines = file ( $ ignoreFile , FILE_IGNORE_NEW_LINES ) ; foreach ( $ lines as $ line ) { if ( preg_match ( $ pattern , $ line ) ) { return true ; } } return false ; }
12399	public function orderBy ( $ field , $ order = null ) { $ this -> scope -> orderBy [ ] = Parser :: orderBy ( $ field , $ order ) ; return $ this ; }
8363	public static function translate ( $ key , array $ args = array ( ) ) { if ( self :: $ isInit === false ) { throw new BadUse ( 'locale doesn\'t seem to have been initialized' ) ; } $ oldKey = $ key ; $ section = self :: $ translations ; while ( isset ( $ section [ $ key ] ) === false && ( $ pos = strpos ( $ key , '.' ) ) !== false ) { if ( ! is_int ( $ pos ) ) { break ; } $ subSection = substr ( $ key , 0 , $ pos ) ; if ( isset ( $ section [ $ subSection ] ) === false ) { break ; } $ section = $ section [ $ subSection ] ; $ key = substr ( $ key , $ pos + 1 ) ; } if ( isset ( $ section [ $ key ] ) === false ) { Logger :: get ( ) -> error ( 'can\'t find translation for key "' . $ oldKey . '"' ) ; return '(null)' ; } return $ section [ $ key ] ; }
1579	public function withType ( string $ type ) : self { if ( empty ( $ type ) ) { throw new \ InvalidArgumentException ( 'Expecting a non-empty string.' ) ; } $ copy = clone $ this ; $ copy -> type = $ type ; $ copy -> normalize ( ) ; return $ copy ; }
11375	public function upload ( string $ sFile ) { if ( $ _FILES [ $ sFile ] [ 'error' ] > 0 ) { $ this -> _sError = "Error while the upload" ; return false ; } if ( $ _FILES [ $ sFile ] [ 'size' ] > $ this -> _iMaxFile ) { $ this -> _sError = "The file is too big" ; return false ; } $ sExtension = strtolower ( substr ( strrchr ( $ _FILES [ $ sFile ] [ 'name' ] , '.' ) , 1 ) ) ; if ( count ( $ this -> _aAllowExtension ) > 0 && ! in_array ( $ sExtension , $ this -> _aAllowExtension ) ) { $ this -> _sError = "The extension is not good" ; return false ; } $ sPath = str_replace ( 'bundles' . DIRECTORY_SEPARATOR . 'lib' , 'data' . DIRECTORY_SEPARATOR . 'upload' . DIRECTORY_SEPARATOR , __DIR__ ) ; if ( $ this -> _sExtension === null ) { $ this -> setExtension ( $ sExtension ) ; } if ( $ this -> _sName ) { $ sName = $ sPath . $ this -> _sName . '.' . $ this -> _sExtension ; } else { $ sName = $ sPath . md5 ( uniqid ( rand ( ) , true ) ) . '.' . $ this -> _sExtension ; } if ( $ this -> _bProportion === true && ( $ this -> _iWidth || $ this -> _iHeight ) ) { $ aImageSizes = getimagesize ( $ _FILES [ $ sFile ] [ 'tmp_name' ] ) ; $ fRatio = min ( $ aImageSizes [ 0 ] / $ this -> _iWidth , $ aImageSizes [ 1 ] / $ this -> _iHeight ) ; $ iHeight = $ aImageSizes [ 1 ] / $ fRatio ; $ iWidth = $ aImageSizes [ 0 ] / $ fRatio ; $ fY = ( $ iHeight - $ this -> _iHeight ) / 2 * $ fRatio ; $ fX = ( $ iWidth - $ this -> _iWidth ) / 2 * $ fRatio ; $ rNewImage = imagecreatefromjpeg ( $ _FILES [ $ sFile ] [ 'tmp_name' ] ) ; $ rNewImgTrueColor = imagecreatetruecolor ( $ this -> _iWidth , $ this -> _iHeight ) ; imagecopyresampled ( $ rNewImgTrueColor , $ rNewImage , 0 , 0 , $ fX , $ fY , $ this -> _iWidth , $ this -> _iHeight , $ iWidth * $ fRatio - $ fX * 2 , $ iHeight * $ fRatio - $ fY * 2 ) ; imagejpeg ( $ rNewImgTrueColor , $ sName , 100 ) ; } else { $ bResultat = move_uploaded_file ( $ _FILES [ $ sFile ] [ 'tmp_name' ] , $ sName ) ; if ( $ bResultat ) { return true ; } } }
12357	public function updateEntryName ( ContentfulEntry $ entry ) { $ displayField = $ this -> getDisplayField ( ) ; $ values = array_values ( ( array ) $ entry -> { $ displayField } ) ; $ entry -> setName ( isset ( $ values [ 0 ] ) ? $ values [ 0 ] : 'Untitled' ) ; }
4436	public function get ( string $ name , $ default = null ) { $ res = $ this -> client -> call ( 'config.get' , $ name ) ; return $ res === null ? $ default : $ res ; }
10338	function toXML ( ) { $ xml = new SimpleXMLElement ( "<?xml version=\"1.0\"?><property></property>" ) ; $ xml -> addChild ( "key" , $ this -> key ) ; $ xml -> addChild ( "value" , $ this -> value ) ; return $ xml ; }
653	protected function getCacheKey ( $ method , $ fetchMode , $ rawSql ) { return [ __CLASS__ , $ method , $ fetchMode , $ this -> db -> dsn , $ this -> db -> username , $ rawSql , ] ; }
502	public function registerClientScript ( ) { $ id = $ this -> grid -> options [ 'id' ] ; $ options = Json :: encode ( [ 'name' => $ this -> name , 'class' => $ this -> cssClass , 'multiple' => $ this -> multiple , 'checkAll' => $ this -> grid -> showHeader ? $ this -> getHeaderCheckBoxName ( ) : null , ] ) ; $ this -> grid -> getView ( ) -> registerJs ( "jQuery('#$id').yiiGridView('setSelectionColumn', $options);" ) ; }
8919	protected function parseAuthority ( $ authority , & $ out ) { if ( ! empty ( $ authority ) ) { $ out [ 'id' ] = $ authority ; if ( preg_match ( '/\((.*?)\)(.*)/' , $ authority , $ matches ) ) { $ out [ 'vocabulary' ] = $ matches [ 1 ] ; $ out [ 'id' ] = $ matches [ 2 ] ; } } }
8283	protected function resolveRealUrl ( $ fileName ) { $ fileNameClean = str_replace ( "\0" , '' , $ fileName ) ; $ realPath = realpath ( $ fileNameClean ) ; if ( $ realPath === false ) { return $ this -> requestUrl ; } $ contentPath = realpath ( $ this -> pico -> getConfig ( 'content_dir' ) ) ; $ contentExt = $ this -> pico -> getConfig ( 'content_ext' ) ; if ( strpos ( $ realPath , $ contentPath ) !== 0 ) { throw new \ RuntimeException ( "The plugin cannot be used with " . "symbolic links inside the content directory." ) ; } $ name = substr ( $ realPath , strlen ( $ contentPath ) + 1 , - strlen ( $ contentExt ) ) ; if ( DIRECTORY_SEPARATOR !== '/' ) { $ name = str_replace ( DIRECTORY_SEPARATOR , '/' , $ name ) ; } if ( strlen ( $ name ) >= 5 && 0 === substr_compare ( $ name , "index" , - 5 ) ) { $ name = rtrim ( substr ( $ name , 0 , - 5 ) , '/' ) ; } return $ name ; }
11099	public static function maxCount ( ) { $ array = \ func_get_args ( ) ; if ( ! \ is_array ( $ array ) ) { return 0 ; } $ maxCnt = 0 ; foreach ( $ array as $ item ) { if ( ! \ is_array ( $ item ) ) { continue ; } $ cnt = \ count ( $ item ) ; $ maxCnt = $ cnt > $ maxCnt ? $ cnt : $ maxCnt ; } return $ maxCnt ; }
10681	public function onBeforeWrite ( ) { if ( $ this -> owner -> Title ) { $ this -> owner -> URLSegment = $ this -> generateURLSegment ( $ this -> owner -> Title ) ; } parent :: onBeforeWrite ( ) ; }
11447	public function actionIndex ( $ option = null ) { $ fixtures = Yii :: createObject ( Fixtures :: className ( ) ) ; $ option = Question :: displayWithQuit ( 'Select operation' , [ 'Export' , 'Import' ] , $ option ) ; if ( $ option == 'e' ) { $ allTables = $ fixtures -> tableNameList ( ) ; if ( ! empty ( $ allTables ) ) { $ answer = Select :: display ( 'Select tables for export' , $ allTables , 1 ) ; $ tables = $ fixtures -> export ( $ answer ) ; Output :: items ( $ tables , 'Exported tables' ) ; } else { Output :: block ( "not tables for export!" ) ; } } elseif ( $ option == 'i' ) { $ allTables = $ fixtures -> fixtureNameList ( ) ; if ( ! empty ( $ allTables ) ) { $ answer = Select :: display ( 'Select tables for import' , $ allTables , 1 ) ; $ tables = $ fixtures -> import ( $ answer ) ; Output :: items ( $ tables , 'Imported tables' ) ; } else { Output :: block ( "not tables for import!" ) ; } } }
1009	public static function defaultFieldResolver ( $ source , $ args , $ context , ResolveInfo $ info ) { $ fieldName = $ info -> fieldName ; $ property = null ; if ( is_array ( $ source ) || $ source instanceof ArrayAccess ) { if ( isset ( $ source [ $ fieldName ] ) ) { $ property = $ source [ $ fieldName ] ; } } elseif ( is_object ( $ source ) ) { if ( isset ( $ source -> { $ fieldName } ) ) { $ property = $ source -> { $ fieldName } ; } } return $ property instanceof Closure ? $ property ( $ source , $ args , $ context , $ info ) : $ property ; }
12480	protected function findSlotsInTemplates ( ) { $ templates = $ this -> findTemplates ( ) ; $ slots = array ( ) ; foreach ( $ templates [ "base" ] as $ templateName => $ templateFile ) { $ templateContents = FilesystemTools :: readFile ( $ templateFile ) ; $ slots = array_merge_recursive ( $ slots , $ this -> findSlots ( $ templateName , $ templateContents ) ) ; } $ baseSlots [ "base" ] = $ slots ; $ slots = array ( ) ; foreach ( $ templates [ "template" ] as $ templateName => $ templateFile ) { $ templateContents = FilesystemTools :: readFile ( $ templateFile ) ; $ slots [ $ templateName ] = $ this -> findSlots ( $ templateName , $ templateContents ) ; } return array ( 'base' => $ baseSlots , 'templates' => $ slots , ) ; }
8234	protected function isExpired ( array $ tokenData , $ tokenValidity = null ) { return time ( ) > $ tokenData [ 'time' ] + ( ( $ tokenValidity !== null ) ? $ tokenValidity : self :: TOKEN_VALIDITY ) ; }
2549	protected function loadClientParams ( Params $ params , $ receivedFromIdentifier , $ version ) { if ( $ params -> authParams instanceof Params \ AuthParams ) { $ this -> authParams = $ params -> authParams ; if ( isset ( $ params -> sessionHandlerParams ) && $ params -> sessionHandlerParams instanceof Params \ SessionHandlerParams ) { $ params -> sessionHandlerParams -> authParams = $ this -> authParams ; } } elseif ( isset ( $ params -> sessionHandlerParams ) && $ params -> sessionHandlerParams -> authParams instanceof Params \ AuthParams ) { $ this -> authParams = $ params -> sessionHandlerParams -> authParams ; } $ this -> sessionHandler = $ this -> loadSessionHandler ( $ params -> sessionHandler , $ params -> sessionHandlerParams ) ; $ this -> requestCreator = $ this -> loadRequestCreator ( $ params -> requestCreator , $ params -> requestCreatorParams , $ receivedFromIdentifier . "-" . $ version , $ this -> sessionHandler -> getOriginatorOffice ( ) , $ this -> sessionHandler -> getMessagesAndVersions ( ) ) ; $ this -> responseHandler = $ this -> loadResponseHandler ( $ params -> responseHandler ) ; $ this -> returnResultXml = $ params -> returnXml ; }
10100	private function writeRichTextString ( $ row , $ col , $ str , $ xfIndex , $ arrcRun ) { $ record = 0x00FD ; $ length = 0x000A ; $ str = StringHelper :: UTF8toBIFF8UnicodeShort ( $ str , $ arrcRun ) ; if ( ! isset ( $ this -> stringTable [ $ str ] ) ) { $ this -> stringTable [ $ str ] = $ this -> stringUnique ++ ; } ++ $ this -> stringTotal ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vvvV' , $ row , $ col , $ xfIndex , $ this -> stringTable [ $ str ] ) ; $ this -> append ( $ header . $ data ) ; }
463	public function buildAndCondition ( $ operator , $ operands , & $ params ) { array_unshift ( $ operands , $ operator ) ; return $ this -> buildCondition ( $ operands , $ params ) ; }
1555	protected function queryValidatorWithoutSearch ( ) { return $ this -> validatorFactory ( ) -> queryParameters ( $ this -> queryRulesWithoutSearch ( ) , $ this -> queryMessages ( ) , $ this -> queryCustomAttributes ( ) , function ( Validator $ validator ) { return $ this -> conditionalQuery ( $ validator ) ; } ) ; }
5365	public function paintPass ( $ message ) { parent :: paintPass ( $ message ) ; $ this -> results [ ] = new SimpleResultOfPass ( parent :: getTestList ( ) , $ message ) ; }
8759	public function postUpload ( Request $ request ) { $ input = $ request -> all ( ) ; $ response = $ this -> uploadRepository -> upload ( $ input ) ; return $ response ; }
3990	private function getInputScreens ( ) { $ combinations = $ this -> getCombinations ( ) ; if ( null === $ combinations ) { return [ ] ; } $ screenIds = array_map ( function ( $ combination ) { return $ combination [ 'dca_id' ] ; } , $ combinations [ 'byName' ] ) ; if ( $ this -> cache -> contains ( $ cacheKey = 'screens_' . implode ( ',' , $ screenIds ) ) ) { return $ this -> cache -> fetch ( $ cacheKey ) ; } $ screens = $ this -> inputScreens -> fetchInputScreens ( $ screenIds ) ; $ this -> cache -> save ( $ cacheKey , $ screens ) ; return $ screens ; }
12595	protected function getMinifier ( SplFileInfo $ file , string $ source ) : Minifier { $ minifier = '\Gears\Asset\Minifiers\\' ; $ minifier .= ucfirst ( $ this -> destination -> getExtension ( ) ) ; if ( ! class_exists ( $ minifier ) ) { throw new RuntimeException ( 'Minification is not supported for type: ' . $ this -> destination -> getExtension ( ) ) ; } return new $ minifier ( $ file , $ source ) ; }
2816	public function getCollectionsAsArray ( ) { $ data = array ( ) ; foreach ( $ this -> getCollections ( ) as $ collection ) { $ data [ ] = array ( 'type' => $ collection -> getType ( ) , 'class' => $ collection -> getClass ( ) , 'sql' => $ collection -> getQuery ( ) , 'count' => $ collection -> getCount ( ) ) ; } return $ data ; }
11611	public function move ( $ path , $ filename = null ) { $ newFilename = ( $ filename != null ) ? $ filename : $ this -> filename ; $ lastSlash = substr ( $ path , strlen ( $ path ) , 1 ) ; if ( $ lastSlash !== '/' ) { $ path .= '/' ; } $ result = move_uploaded_file ( $ this -> realPath , $ path . $ newFilename ) ; return $ result ; }
3800	public function getMetaModel ( EnvironmentInterface $ interface ) { $ metaModelId = $ this -> connection -> createQueryBuilder ( ) -> select ( 'd.pid' ) -> from ( 'tl_metamodel_dca' , 'd' ) -> leftJoin ( 'd' , 'tl_metamodel_dcasetting' , 's' , '(d.id=s.pid)' ) -> where ( '(s.id=:id)' ) -> setParameter ( 'id' , ModelId :: fromSerialized ( $ interface -> getInputProvider ( ) -> getParameter ( 'pid' ) ) -> getId ( ) ) -> execute ( ) ; if ( $ tableName = $ this -> factory -> translateIdToMetaModelName ( $ metaModelId = $ metaModelId -> fetchColumn ( ) ) ) { return $ this -> factory -> getMetaModel ( $ tableName ) ; } throw new \ RuntimeException ( 'Could not retrieve MetaModel ' . $ metaModelId ) ; }
10960	private function prepareFilePathTo ( \ SplFileInfo $ file ) { if ( $ this -> currentCommand -> isUsePathReplace ( ) ) { $ fileWhereToMovePath = $ file -> getPath ( ) . DIRECTORY_SEPARATOR ; if ( $ this -> direction === self :: DIRECTION_FORWARD ) { $ filePathTo = $ this -> currentCommand -> replacePath ( $ fileWhereToMovePath ) ; } elseif ( $ this -> direction === self :: DIRECTION_BACK ) { $ filePathTo = $ this -> currentCommand -> replacePathBack ( $ fileWhereToMovePath ) ; } else { throw new \ Exception ( __METHOD__ . " wrong direction" ) ; } $ this -> currentCommand -> setToDirectory ( $ filePathTo ) ; } else { $ filePathTo = $ this -> currentCommand -> getToDirectory ( ) ; } if ( ! file_exists ( $ filePathTo ) && ! is_dir ( $ filePathTo ) ) { mkdir ( $ filePathTo , $ this -> defaultDirMod , TRUE ) ; } else { chmod ( $ filePathTo , $ this -> defaultDirMod ) ; } if ( $ this -> currentCommand -> getDestinationFileName ( ) ) { $ fileName = $ this -> currentCommand -> getDestinationFileName ( ) ; } else { $ fileName = $ file -> getFilename ( ) ; } $ filePathTo .= $ fileName ; return $ filePathTo ; }
9714	private function writeStyle ( ) { $ record = 0x0293 ; $ length = 0x0004 ; $ ixfe = 0x8000 ; $ BuiltIn = 0x00 ; $ iLevel = 0xff ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vCC' , $ ixfe , $ BuiltIn , $ iLevel ) ; $ this -> append ( $ header . $ data ) ; }
12939	public function setMax ( $ value ) { $ this -> setTag ( 'max' , $ value ) ; if ( $ this -> getValidator ( ) ) { $ this -> getValidator ( ) -> setOption ( 'max' , $ value ) ; } }
5882	protected static function read_1_byte ( $ handle ) { $ c = fgetc ( $ handle ) ; if ( $ c === false ) { throw new \ RuntimeException ( 'Premature EOF in JPEG file' , 1363533326 ) ; } return ord ( $ c ) ; }
12075	public function childShow ( FilterRequest $ filters , $ id , $ idChild , $ relation ) { $ id = $ this -> getRealId ( $ id ) ; $ idChild = $ this -> getRealId ( $ idChild ) ; $ resource = $ this -> repository -> getChild ( $ id , $ relation , $ idChild , $ filters ) ; if ( ! $ resource ) { } return $ this -> success ( $ resource ) ; }
12189	public function getPrimaryRelation ( $ baseObject , $ baseRole , $ relationOptions = [ ] ) { $ companionRole = $ this -> companionRole ( $ baseRole ) ; $ companionType = $ this -> companionRoleType ( $ baseRole ) ; $ companionModel = $ companionType -> primaryModel ; if ( ! isset ( $ relationOptions [ 'order' ] ) ) { $ relationOptions [ 'order' ] = [ ] ; } if ( $ companionRole === 'child' ) { array_unshift ( $ relationOptions [ 'order' ] , [ 'primary_child' , SORT_DESC ] ) ; $ relation = $ baseObject -> queryParentRelations ( $ companionModel , $ relationOptions ) -> one ( ) ; } else { array_unshift ( $ relationOptions [ 'order' ] , [ 'primary_parent' , SORT_DESC ] ) ; $ relation = $ baseObject -> queryParentRelations ( $ companionModel , $ relationOptions ) -> one ( ) ; } if ( empty ( $ relation ) ) { return false ; } else { return $ relation ; } }
7606	public function render ( array $ aDropdownOptions ) { if ( empty ( $ aDropdownOptions [ 'attributes' ] ) ) { $ aDropdownOptions [ 'attributes' ] = array ( 'class' => 'dropdown' ) ; } else { if ( ! is_array ( $ aDropdownOptions [ 'attributes' ] ) ) { throw new LogicException ( '"attributes" option expects an array, "' . gettype ( $ aDropdownOptions [ 'attributes' ] ) . '" given' ) ; } if ( empty ( $ aDropdownOptions [ 'attributes' ] [ 'class' ] ) ) { $ aDropdownOptions [ 'attributes' ] [ 'class' ] = 'dropdown' ; } elseif ( ! preg_match ( '/(\s|^)dropdown(\s|$)/' , $ aDropdownOptions [ 'attributes' ] [ 'class' ] ) ) { $ aDropdownOptions [ 'attributes' ] [ 'class' ] .= ' dropdown' ; } } return sprintf ( static :: $ dropdownContainerFormat , $ this -> createAttributesString ( $ aDropdownOptions [ 'attributes' ] ) , $ this -> renderToggle ( $ aDropdownOptions ) . $ this -> renderListItems ( $ aDropdownOptions ) ) ; }
4357	protected function processLog ( ) { $ str = '' ; foreach ( $ this -> data [ 'log' ] as $ entry ) { $ channel = isset ( $ entry [ 2 ] [ 'channel' ] ) ? $ entry [ 2 ] [ 'channel' ] : null ; if ( $ this -> channelTest ( $ channel ) ) { $ str .= $ this -> processLogEntryWEvent ( $ entry [ 0 ] , $ entry [ 1 ] , $ entry [ 2 ] ) ; } } return $ str ; }
9105	protected function parse_time ( ) { if ( ! empty ( $ this -> args [ 'time' ] ) ) { $ date_query = new \ WP_Date_Query ( $ this -> args [ 'time' ] , 'q.time' ) ; return new Where_Date ( $ date_query ) ; } else { return null ; } }
9550	public function getPdo ( ) { if ( empty ( $ this -> pdo ) ) { $ this -> pdo = new PDO ( sprintf ( "mysql:host=%s;port=%d" , $ this -> host , $ this -> port ) ) ; $ this -> pdo -> setAttribute ( PDO :: ATTR_DEFAULT_FETCH_MODE , PDO :: FETCH_ASSOC ) ; } return $ this -> pdo ; }
11730	public function validatePassword ( ) { $ user = User :: findByEmail ( $ this -> email ) ; if ( ! $ user || ! $ user -> validatePassword ( $ this -> password ) ) { $ this -> addError ( 'password' , 'Incorrect username or password.' ) ; } }
2484	protected function getAllSearchTargets ( ) { if ( $ this -> endpointResolver instanceof SingleEndpointResolver && ! $ this -> endpointResolver -> hasMultipleEndpoints ( ) ) { return '' ; } $ shards = [ ] ; $ searchTargets = $ this -> endpointResolver -> getEndpoints ( ) ; if ( ! empty ( $ searchTargets ) ) { foreach ( $ searchTargets as $ endpointName ) { $ shards [ ] = $ this -> endpointRegistry -> getEndpoint ( $ endpointName ) -> getIdentifier ( ) ; } } return implode ( ',' , $ shards ) ; }
8014	protected function prepareCommand ( $ filename , $ saveToFile , $ pdfIsTemp = false ) { $ resultIsTemp = false ; $ command = new Command ( ) ; $ command -> setPdfFile ( $ filename , $ pdfIsTemp ) ; if ( $ saveToFile === null ) { $ saveToFile = tempnam ( sys_get_temp_dir ( ) , 'pdfbox' ) ; $ resultIsTemp = true ; } $ command -> setTextFile ( $ saveToFile , $ resultIsTemp ) ; return $ command ; }
12806	public static function select ( ) : Collection { $ pdo = Database :: connect ( ) ; $ class = self :: getStaticChildClass ( ) ; $ tableName = self :: getTableName ( ) ; $ sql = "SELECT * FROM \"$tableName\"" ; $ results = $ pdo -> query ( $ sql ) -> fetchAll ( ) ; $ collection = new Collection ( $ class , [ ] ) ; foreach ( $ results as $ result ) { $ object = new $ class ( $ result ) ; $ collection -> push ( $ object ) ; } return $ collection ; }
9243	private function __setCookieAndLocale ( $ locale ) { if ( PHP_SAPI !== 'cli' ) { $ time = $ this -> __getCookieExpireTime ( ) ; I18n :: locale ( $ locale ) ; setcookie ( $ this -> __getCookieName ( ) , $ locale , $ time , '/' , $ this -> config ( 'Cookie.domain' ) ) ; } }
613	protected function build ( $ class , $ params , $ config ) { list ( $ reflection , $ dependencies ) = $ this -> getDependencies ( $ class ) ; foreach ( $ params as $ index => $ param ) { $ dependencies [ $ index ] = $ param ; } $ dependencies = $ this -> resolveDependencies ( $ dependencies , $ reflection ) ; if ( ! $ reflection -> isInstantiable ( ) ) { throw new NotInstantiableException ( $ reflection -> name ) ; } if ( empty ( $ config ) ) { return $ reflection -> newInstanceArgs ( $ dependencies ) ; } $ config = $ this -> resolveDependencies ( $ config ) ; if ( ! empty ( $ dependencies ) && $ reflection -> implementsInterface ( 'yii\base\Configurable' ) ) { $ dependencies [ count ( $ dependencies ) - 1 ] = $ config ; return $ reflection -> newInstanceArgs ( $ dependencies ) ; } $ object = $ reflection -> newInstanceArgs ( $ dependencies ) ; foreach ( $ config as $ name => $ value ) { $ object -> $ name = $ value ; } return $ object ; }
560	protected function buildOperatorCondition ( $ operator , $ condition , $ attribute ) { if ( isset ( $ this -> queryOperatorMap [ $ operator ] ) ) { $ operator = $ this -> queryOperatorMap [ $ operator ] ; } return [ $ operator , $ attribute , $ this -> filterAttributeValue ( $ attribute , $ condition ) ] ; }
5709	public function getButtonName ( ) { $ raw = $ this -> buttonName ? : $ this -> getButtonText ( ) ; return preg_replace ( '/[^a-z0-9-_]/' , '' , strtolower ( $ this -> getButtonText ( ) ) ) ; }
6256	public function searchPickupPointsByText ( $ query_text , $ service_provider = null , $ limit = 5 ) { if ( $ query_text == null || trim ( $ query_text ) == '' ) { return '[]' ; } $ post_params = array ( 'query' => ( string ) $ query_text , 'service_provider' => ( string ) $ service_provider , 'limit' => ( int ) $ limit ) ; return $ this -> doPost ( '/pickup-points/search' , $ post_params ) ; }
8477	public function run ( $ id ) { $ model = $ this -> controller -> findModel ( $ id ) ; if ( $ model -> is_system ) { \ Yii :: $ app -> session -> setFlash ( 'warning' , \ Yii :: t ( 'app' , 'You cannot update or delete system handlers' ) ) ; } else { $ model -> delete ( ) ; } return $ this -> controller -> redirect ( [ 'index' ] ) ; }
7596	protected function renderHelpBlock ( ElementInterface $ oElement ) { if ( $ sHelpBlock = $ oElement -> getOption ( 'help-block' ) ) { if ( $ oTranslator = $ this -> getTranslator ( ) ) { $ sHelpBlock = $ oTranslator -> translate ( $ sHelpBlock , $ this -> getTranslatorTextDomain ( ) ) ; } $ sHelpBlockString = strip_tags ( $ sHelpBlock ) ; if ( $ sHelpBlock === $ sHelpBlockString ) { $ sHelpBlock = $ this -> getEscapeHtmlHelper ( ) -> __invoke ( $ sHelpBlock ) ; } return sprintf ( static :: $ helpBlockFormat , $ sHelpBlock ) ; } else { return '' ; } }
5817	public function getFusionTagTypes ( ) { $ types = array ( ) ; $ configuration = Config :: inst ( ) ; $ exclusions = $ configuration -> get ( 'FusionService' , 'tag_type_exclusions' ) ; $ classes = ClassInfo :: subclassesFor ( 'DataObject' ) ; unset ( $ classes [ 'FusionTag' ] ) ; foreach ( $ classes as $ class ) { if ( ( strpos ( strrev ( $ class ) , strrev ( 'Tag' ) ) === 0 ) && ! in_array ( $ class , $ exclusions ) && ! ClassInfo :: classImplements ( $ class , 'TestOnly' ) ) { $ types [ $ class ] = 'Title' ; } } foreach ( $ configuration -> get ( 'FusionService' , 'custom_tag_types' ) as $ type => $ field ) { if ( in_array ( $ type , $ classes ) && ! in_array ( $ type , $ exclusions ) ) { $ types [ $ type ] = $ field ; } } return $ types ; }
7672	function TbsLoadSubFileAsTemplate ( $ SubFileLst ) { if ( ! is_array ( $ SubFileLst ) ) $ SubFileLst = array ( $ SubFileLst ) ; $ ok = true ; $ TBS = false ; foreach ( $ SubFileLst as $ SubFile ) { $ idx = $ this -> FileGetIdx ( $ SubFile ) ; if ( $ idx === false ) { $ ok = $ this -> RaiseError ( 'Cannot load "' . $ SubFile . '". The file is not found in the archive "' . $ this -> ArchFile . '".' ) ; } elseif ( $ idx !== $ this -> TbsCurrIdx ) { $ this -> TbsStorePark ( ) ; if ( ! is_string ( $ SubFile ) ) $ SubFile = $ this -> TbsGetFileName ( $ idx ) ; $ this -> TbsStoreLoad ( $ idx , $ SubFile ) ; if ( $ this -> LastReadNotStored ) { if ( $ TBS === false ) { $ this -> TbsSwitchMode ( true ) ; $ MergeAutoFields = $ this -> TbsMergeAutoFields ( ) ; $ TBS = & $ this -> TBS ; } if ( $ this -> LastReadComp <= 0 ) { if ( $ this -> ExtInfo !== false ) { $ i = $ this -> ExtInfo ; $ e = $ this -> ExtEquiv ; if ( isset ( $ i [ 'rpl_what' ] ) ) { $ TBS -> Source = str_replace ( $ i [ 'rpl_what' ] , $ i [ 'rpl_with' ] , $ TBS -> Source ) ; } if ( ( $ e === 'odt' ) && $ TBS -> OtbsClearWriter ) { $ this -> OpenDoc_CleanRsID ( $ TBS -> Source ) ; } if ( ( $ e === 'ods' ) && $ TBS -> OtbsMsExcelCompatibility ) { $ this -> OpenDoc_MsExcelCompatibility ( $ TBS -> Source ) ; } if ( $ e === 'docx' ) { if ( $ TBS -> OtbsSpacePreserve ) $ this -> MsWord_CleanSpacePreserve ( $ TBS -> Source ) ; if ( $ TBS -> OtbsClearMsWord ) $ this -> MsWord_Clean ( $ TBS -> Source ) ; } if ( ( $ e === 'pptx' ) && $ TBS -> OtbsClearMsPowerpoint ) { $ this -> MsPowerpoint_Clean ( $ TBS -> Source ) ; } if ( ( $ e === 'xlsx' ) && $ TBS -> OtbsMsExcelConsistent ) { $ this -> MsExcel_DeleteFormulaResults ( $ TBS -> Source ) ; $ this -> MsExcel_ConvertToRelative ( $ TBS -> Source ) ; } } if ( $ MergeAutoFields ) $ TBS -> LoadTemplate ( null , '+' ) ; } } } } if ( $ TBS !== false ) $ this -> TbsSwitchMode ( false ) ; return $ ok ; }
4980	public function convertToDatabaseValue ( $ value ) { if ( ! $ value instanceof \ DateTime ) { return null ; } $ timezone = $ value -> getTimezone ( ) -> getName ( ) ; $ timestamp = $ value -> getTimestamp ( ) ; $ date = new \ MongoDate ( $ timestamp ) ; return array ( 'date' => $ date , 'tz' => $ timezone , ) ; }
6645	public static function formatPhoneNumberToInternationalFormat ( $ countryCode , $ number , $ numberLength ) { $ actualNumber = substr ( $ number , - ( $ numberLength ) , $ numberLength ) ; if ( ! $ actualNumber ) { return $ number ; } return '+' . $ countryCode . $ actualNumber ; }
10720	public function removeThumbnail ( \ TYPO3 \ CMS \ Extbase \ Domain \ Model \ FileReference $ thumbnail ) { $ this -> thumbnails -> detach ( $ thumbnail ) ; }
4815	public function getAsDom ( ) { $ anyDataSet = XmlUtil :: createXmlDocumentFromStr ( "<anydataset></anydataset>" ) ; $ nodeRoot = $ anyDataSet -> getElementsByTagName ( "anydataset" ) -> item ( 0 ) ; foreach ( $ this -> collection as $ sr ) { $ row = $ sr -> getAsDom ( ) ; $ nodeRow = $ row -> getElementsByTagName ( "row" ) -> item ( 0 ) ; $ newRow = XmlUtil :: createChild ( $ nodeRoot , "row" ) ; XmlUtil :: addNodeFromNode ( $ newRow , $ nodeRow ) ; } return $ anyDataSet ; }
839	public static function fromCode ( $ code ) { $ codeHash = self :: calculateCodeHash ( $ code ) ; if ( self :: hasCache ( $ codeHash ) ) { $ tokens = self :: getCache ( $ codeHash ) ; $ tokens -> generateCode ( ) ; if ( $ codeHash === $ tokens -> codeHash ) { $ tokens -> clearEmptyTokens ( ) ; $ tokens -> clearChanged ( ) ; return $ tokens ; } } $ tokens = new self ( ) ; $ tokens -> setCode ( $ code ) ; $ tokens -> clearChanged ( ) ; return $ tokens ; }
7750	public function getMetadataFor ( $ className ) { if ( isset ( $ this -> loadedMetadata [ $ className ] ) ) { return $ this -> loadedMetadata [ $ className ] ; } $ realClassName = ClassUtils :: getRealClass ( $ className ) ; if ( isset ( $ this -> loadedMetadata [ $ realClassName ] ) ) { $ this -> loadedMetadata [ $ className ] = $ this -> loadedMetadata [ $ realClassName ] ; return $ this -> loadedMetadata [ $ realClassName ] ; } if ( $ this -> cacheDriver ) { if ( ( $ cached = $ this -> cacheDriver -> fetch ( $ realClassName . $ this -> cacheSalt ) ) !== false ) { $ this -> loadedMetadata [ $ realClassName ] = $ cached ; } else { $ this -> cacheDriver -> save ( $ realClassName . $ this -> cacheSalt , $ this -> loadMetadata ( $ realClassName ) , null ) ; } } else { $ this -> loadMetadata ( $ realClassName ) ; } if ( $ className != $ realClassName ) { $ this -> loadedMetadata [ $ className ] = $ this -> loadedMetadata [ $ realClassName ] ; } return $ this -> loadedMetadata [ $ className ] ; }
3548	public function create ( $ request ) { $ model = $ this -> repository -> create ( $ request -> all ( ) ) ; $ model -> { $ this -> getShortRelationName ( ) } ( ) -> sync ( $ request -> get ( $ this -> getRelationName ( ) , [ ] ) ) ; $ event_class = "Acoustep\EntrustGui\Events\\" . ucwords ( $ this -> getModelName ( ) ) . 'CreatedEvent' ; $ event = new $ event_class ; $ this -> dispatcher -> fire ( $ event -> setModel ( $ model ) ) ; return $ model ; }
3513	public function getPublish ( $ group ) { if ( $ group && $ group != '*' ) { $ this -> manager -> exportTranslations ( $ group ) ; } else { $ this -> manager -> exportAllTranslations ( ) ; } $ errors = $ this -> manager -> errors ( ) ; event ( new TranslationsPublished ( $ group , $ errors ) ) ; return Response :: json ( array ( 'status' => $ errors ? 'errors' : 'ok' , 'errors' => $ errors ) ) ; }
6162	public function start ( ) { if ( $ this -> isRunning ( ) ) { return ; } $ this -> data [ "realmem_start" ] = memory_get_usage ( true ) ; $ this -> data [ "emalloc_start" ] = memory_get_usage ( ) ; $ this -> started = microtime ( true ) ; $ this -> running = true ; }
6062	public function download ( $ id , $ template = null , $ templateType = 'image' , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'template' => $ template , 'templateType' => $ templateType ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/media/' . $ id . '/download' , $ parameters , $ cachePolicy ) ; $ tmpFile = tmpfile ( ) ; if ( false === fwrite ( $ tmpFile , $ result ) ) { throw new \ RuntimeException ( 'Could not write download data to temporary file!' ) ; } if ( false === fseek ( $ tmpFile , 0 ) ) { throw new \ RuntimeException ( 'Could not reset file pointer of temporary file!' ) ; } $ result = $ tmpFile ; return $ result ; }
7926	public function fireEvent ( $ event , array $ args = [ ] ) { if ( isset ( $ this -> eventListeners [ $ event ] ) === false ) return $ args ; foreach ( $ this -> eventListeners [ $ event ] as $ listener ) call_user_func_array ( $ listener , $ args ) ; return $ args ; }
4477	public function untrack ( ) : void { if ( $ this -> client -> call ( 'track' , 'untrack' , $ this -> jid ) ) { $ this -> tracked = false ; } }
5931	public function setDefinition ( $ definition ) { if ( is_array ( $ definition ) ) { $ this -> definition = $ definition ; return $ this ; } $ this -> definition = json_decode ( $ definition , true ) ; if ( null === $ this -> definition ) { $ this -> definition = $ definition ; } return $ this ; }
12133	public function createService ( ServiceLocatorInterface $ serviceLocator ) { $ options = $ serviceLocator -> get ( 'HtSettingsModule\Options\ModuleOptions' ) ; $ settingsService = new SettingsService ( $ options , $ serviceLocator -> get ( 'HtSettingsModule_SettingsMapper' ) , $ serviceLocator -> get ( 'HtSettingsModule\Service\NamespaceHydratorProvider' ) ) ; if ( $ options -> getCacheOptions ( ) -> isEnabled ( ) ) { $ settingsService -> setCacheManager ( $ serviceLocator -> get ( 'HtSettingsModule\Service\CacheManager' ) ) ; } return $ settingsService ; }
9639	public function setValue ( $ url ) { if ( $ url ) { $ url = $ this -> rebuildURL ( $ url ) ; } parent :: setValue ( $ url ) ; }
9717	private function writeRecalcId ( ) { $ record = 0x01C1 ; $ length = 8 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'VV' , 0x000001C1 , 0x00001E667 ) ; return $ this -> writeData ( $ header . $ data ) ; }
3877	public function build ( ) { if ( ! $ this -> isEmpty ( ) ) { return new SimpleQuery ( sprintf ( 'SELECT id FROM %s WHERE %s' , $ this -> tableName , $ this -> getProcedure ( ) ) , $ this -> getParameters ( ) , 'id' , $ this -> connection ) ; } return null ; }
141	public function markAliasUninstalled ( RepositoryInterface $ repo , MarkAliasUninstalledOperation $ operation ) { $ package = $ operation -> getPackage ( ) ; $ repo -> removePackage ( $ package ) ; }
5978	public function objecttypes ( ) { if ( ! $ this -> objecttypes instanceof ObjecttypesController ) { $ this -> objecttypes = new ObjecttypesController ( $ this -> getClient ( ) , $ this -> cachePolicy , $ this -> cache ) ; $ this -> objecttypes -> setLogger ( $ this -> logger ) ; } return $ this -> objecttypes ; }
9093	public function getPagePartial ( $ page ) { if ( isset ( $ this -> pagePartials [ $ page ] ) ) { return $ this -> pagePartials [ $ page ] ; } return null ; }
2782	public function renderShadowMark ( $ count , $ current , $ eolInterval = 60 ) { $ this -> progressCount ++ ; $ this -> write ( '<fg=blue;options=bold>S</fg=blue;options=bold>' , false ) ; if ( ( $ this -> progressCount % $ eolInterval ) == 0 ) { $ counter = str_pad ( $ this -> progressCount , 5 , ' ' , STR_PAD_LEFT ) ; $ this -> write ( ' |' . $ counter . ' (' . str_pad ( $ current , strlen ( $ count ) , ' ' , STR_PAD_LEFT ) . '/' . $ count . ')' . PHP_EOL , false ) ; } }
6110	public function fileList ( $ cpw = "" , $ path = "/" , $ recursive = false ) { return $ this -> getParent ( ) -> channelFileList ( $ this -> getId ( ) , $ cpw , $ path , $ recursive ) ; }
11927	public function actionRunOne ( ) { $ this -> out ( "Run Interface " . $ this -> dataInterface -> object -> name , Console :: UNDERLINE , Console :: FG_GREEN ) ; $ this -> hr ( ) ; $ this -> dataInterface -> run ( null , new ConsoleAction ( ) ) ; }
9164	protected function parseNode ( RuleCollection $ collection , \ DOMElement $ node , $ path , $ file ) { if ( self :: NAMESPACE_URI !== $ node -> namespaceURI ) { return ; } switch ( $ node -> localName ) { case 'rule' : $ this -> parseRule ( $ collection , $ node , $ path ) ; break ; case 'import' : $ this -> parseImport ( $ collection , $ node , $ path , $ file ) ; break ; default : throw new \ InvalidArgumentException ( sprintf ( 'Unknown tag "%s" used in file "%s". Expected "rule" or "import".' , $ node -> localName , $ path ) ) ; } }
6636	protected function initLanguages ( ) { if ( ! Yii :: $ app -> user -> isGuest ) { Yii :: $ app -> language = Yii :: $ app -> user -> identity -> lang ; } if ( ! isset ( Yii :: $ app -> wavecms ) ) throw new InvalidConfigException ( Yii :: t ( 'wavecms/main' , 'Component "wavecms" not defined in config.php' ) ) ; if ( ! count ( Yii :: $ app -> wavecms -> languages ) ) throw new InvalidConfigException ( Yii :: t ( 'wavecms/main' , 'Property "languages" is not defined in config file for component "wavecms"' ) ) ; if ( ! Yii :: $ app -> session -> get ( 'editedLanguage' ) ) { Yii :: $ app -> session -> set ( 'editedLanguage' , Yii :: $ app -> wavecms -> languages [ 0 ] ) ; } Yii :: $ app -> wavecms -> editedLanguage = Yii :: $ app -> session -> get ( 'editedLanguage' ) ; }
3144	public function finish ( RunnerServiceContext $ context , $ finalState = DeliveryExecution :: STATE_FINISHED ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ executionUri = $ context -> getTestExecutionUri ( ) ; $ userUri = \ common_session_SessionManager :: getSession ( ) -> getUserUri ( ) ; $ executionService = ServiceProxy :: singleton ( ) ; $ deliveryExecution = $ executionService -> getDeliveryExecution ( $ executionUri ) ; if ( $ deliveryExecution -> getUserIdentifier ( ) == $ userUri ) { \ common_Logger :: i ( "Finishing the delivery execution {$executionUri}" ) ; $ result = $ deliveryExecution -> setState ( $ finalState ) ; } else { \ common_Logger :: w ( "Non owner {$userUri} tried to finish deliveryExecution {$executionUri}" ) ; $ result = false ; } $ this -> getServiceManager ( ) -> get ( ExtendedStateService :: SERVICE_ID ) -> clearEvents ( $ executionUri ) ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'finish' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } return $ result ; }
10980	public function preRemove ( LifecycleEventArgs $ args ) : void { if ( ! $ this -> enableIndexing ) { return ; } $ this -> removeEntity ( $ args -> getObject ( ) , $ args -> getObjectManager ( ) ) ; }
738	protected function saveItems ( ) { $ items = [ ] ; foreach ( $ this -> items as $ name => $ item ) { $ items [ $ name ] = array_filter ( [ 'type' => $ item -> type , 'description' => $ item -> description , 'ruleName' => $ item -> ruleName , 'data' => $ item -> data , ] ) ; if ( isset ( $ this -> children [ $ name ] ) ) { foreach ( $ this -> children [ $ name ] as $ child ) { $ items [ $ name ] [ 'children' ] [ ] = $ child -> name ; } } } $ this -> saveToFile ( $ items , $ this -> itemFile ) ; }
1223	public function resolve ( $ uri , $ version , $ resource , array $ paramDefs , array $ paramValues ) { foreach ( $ paramValues as $ param => $ value ) { if ( ! array_key_exists ( $ param , $ paramDefs ) ) { throw new \ InvalidArgumentException ( "Unknown uri parameter \"$param\" provided" ) ; } } foreach ( $ paramDefs as $ key => $ def ) { if ( ! isset ( $ paramValues [ $ key ] ) ) { if ( isset ( $ def [ 'default' ] ) ) { $ paramValues [ $ key ] = is_callable ( $ def [ 'default' ] ) ? $ def [ 'default' ] ( $ paramValues ) : $ def [ 'default' ] ; } elseif ( empty ( $ def [ 'required' ] ) ) { continue ; } else { $ this -> throwRequired ( $ paramDefs , $ paramValues ) ; } } $ this -> checkType ( $ def [ 'valid' ] , $ key , $ paramValues [ $ key ] ) ; if ( isset ( $ def [ 'fn' ] ) ) { $ def [ 'fn' ] ( $ paramValues [ $ key ] , $ paramValues ) ; } } return ( "$uri/" . "$version/" . $ this -> fillPathParams ( $ resource , $ paramValues ) . $ this -> buildQueryParameters ( $ paramValues ) ) ; }
12870	public function unbind ( ) : bool { if ( $ this -> _bConnected ) { return $ this -> _bConnected = ldap_unbind ( $ this -> _rConnect ) ; } else { return true ; } }
2639	public function aroundGetElementByPathParts ( \ Closure $ proceed , array $ pathParts ) { $ result = $ proceed ( $ pathParts ) ; if ( $ this -> isLoaded == true || false ) { return $ result ; } if ( ( $ result instanceof Section ) == false ) { return $ result ; } if ( isset ( $ pathParts [ 0 ] ) == false || $ pathParts [ 0 ] != 'system' ) { return $ result ; } $ this -> isLoaded = true ; $ data = $ result -> getData ( ) ; if ( isset ( $ data [ 'children' ] [ 'full_page_cache' ] [ 'children' ] [ 'fastly_edge_modules' ] [ 'children' ] ) == false ) { return $ result ; } $ original = $ data [ 'children' ] [ 'full_page_cache' ] [ 'children' ] [ 'fastly_edge_modules' ] [ 'children' ] ; $ data [ 'children' ] [ 'full_page_cache' ] [ 'children' ] [ 'fastly_edge_modules' ] [ 'children' ] = array_merge ( $ original , $ this -> loadModlyData ( ) ) ; $ result -> setData ( $ data , $ this -> scopeDefiner -> getScope ( ) ) ; return $ result ; }
992	public static function visitUsingRules ( Schema $ schema , TypeInfo $ typeInfo , DocumentNode $ documentNode , array $ rules ) { $ context = new ValidationContext ( $ schema , $ documentNode , $ typeInfo ) ; $ visitors = [ ] ; foreach ( $ rules as $ rule ) { $ visitors [ ] = $ rule -> getVisitor ( $ context ) ; } Visitor :: visit ( $ documentNode , Visitor :: visitWithTypeInfo ( $ typeInfo , Visitor :: visitInParallel ( $ visitors ) ) ) ; return $ context -> getErrors ( ) ; }
9520	public function getAliasUsage ( $ withEncapsulation = true ) { $ aliases = '' ; foreach ( $ this -> aliases as $ prefix => $ alias ) { if ( $ withEncapsulation ) { $ aliases = ( $ aliases == '' ) ? ' (' : $ aliases ; $ aliases .= ' ' . $ prefix . $ alias ; } else { $ aliases = ( $ aliases == '' ) ? $ prefix . $ alias : $ aliases . ', ' . $ prefix . $ alias ; } } if ( $ withEncapsulation ) { $ aliases .= ( $ aliases == '' ) ? '' : ' )' ; } return $ aliases ; }
10469	public function post ( Request $ request ) { $ this -> emit ( 'message.send' , array ( $ request -> xml ( ) ) ) ; $ response = $ this -> connector -> post ( $ request ) ; $ this -> emit ( 'message.recv' , array ( $ response ) ) ; try { return $ this -> parseXml ( $ response ) ; } catch ( InvalidXMLException $ e ) { throw new InvalidNcipResponseException ( 'Invalid response received from the NCIP service "' . $ this -> connector -> url . '": ' . $ response ) ; } }
7680	function TbsSheetSlide_DeleteDisplay ( $ id_or_name , $ ok , $ delete ) { if ( is_null ( $ ok ) ) $ ok = true ; $ ext = $ this -> ExtEquiv ; $ ok = ( boolean ) $ ok ; if ( ! is_array ( $ id_or_name ) ) $ id_or_name = array ( $ id_or_name ) ; foreach ( $ id_or_name as $ item => $ action ) { if ( ! is_bool ( $ action ) ) { $ item = $ action ; $ action = $ ok ; } $ item_ref = ( is_string ( $ item ) ) ? 'n:' . htmlspecialchars ( $ item ) : 'i:' . $ item ; if ( $ delete ) { if ( $ ok ) { $ this -> OtbsSheetSlidesDelete [ $ item_ref ] = $ item ; } else { unset ( $ this -> OtbsSheetSlidesVisible [ $ item_ref ] ) ; } } else { $ this -> OtbsSheetSlidesVisible [ $ item_ref ] = $ ok ; } } }
7665	function EncodeFile ( $ path , $ encoding = "base64" ) { if ( ! @ $ fd = fopen ( $ path , "rb" ) ) { $ this -> SetError ( $ this -> Lang ( "file_open" ) . $ path ) ; return "" ; } $ magic_quotes = get_magic_quotes_runtime ( ) ; set_magic_quotes_runtime ( 0 ) ; $ file_buffer = fread ( $ fd , filesize ( $ path ) ) ; $ file_buffer = $ this -> EncodeString ( $ file_buffer , $ encoding ) ; fclose ( $ fd ) ; set_magic_quotes_runtime ( $ magic_quotes ) ; return $ file_buffer ; }
3939	private function setEval ( $ property , $ propInfo , $ isTranslated ) { $ extra = isset ( $ propInfo [ 'eval' ] ) ? $ propInfo [ 'eval' ] : [ ] ; if ( $ isTranslated ) { $ extra [ 'tl_class' ] = 'translat-attr' . ( ! empty ( $ extra [ 'tl_class' ] ) ? ' ' . $ extra [ 'tl_class' ] : '' ) ; } $ property -> setExtra ( array_merge ( ( array ) $ property -> getExtra ( ) , $ extra ) ) ; }
4988	public function setForms ( array $ forms , $ enabled = true ) { foreach ( $ forms as $ key => $ spec ) { if ( is_array ( $ spec ) && isset ( $ spec [ 'enabled' ] ) ) { $ currentEnabled = $ spec [ 'enabled' ] ; unset ( $ spec [ 'enabled' ] ) ; } else { $ currentEnabled = $ enabled ; } $ this -> setForm ( $ key , $ spec , $ currentEnabled ) ; } return $ this ; }
10901	public function loadAll ( array $ where = [ ] , bool $ assoc = false , array $ fields = null ) : Collection { $ allData = $ this -> medoo -> select ( $ this -> getTable ( ) , $ fields ? $ fields : '*' , $ where ) ; $ this -> sentry -> breadcrumbs -> record ( [ 'message' => 'Entity ' . $ this -> __getEntityName ( ) . '::loadAll(' . \ print_r ( $ where , true ) . ', ' . $ assoc . ', ' . \ print_r ( $ fields , true ) . ')' , 'data' => [ 'query' => $ this -> medoo -> last ( ) ] , 'category' => 'Database' , 'level' => 'info' , ] ) ; $ items = [ ] ; foreach ( $ allData as $ data ) { $ items [ ] = ( $ assoc ) ? $ data : $ this -> container [ 'entity' ] ( $ this -> __getEntityName ( ) ) -> setData ( $ data ) ; } return new Collection ( $ items ) ; }
1957	public function generate ( ) { if ( $ this -> vimeo == '' ) { return '' ; } if ( TL_MODE == 'BE' ) { $ return = '<p><a href="https://vimeo.com/' . $ this -> vimeo . '" target="_blank" rel="noreferrer noopener">vimeo.com/' . $ this -> vimeo . '</a></p>' ; if ( $ this -> headline != '' ) { $ return = '<' . $ this -> hl . '>' . $ this -> headline . '</' . $ this -> hl . '>' . $ return ; } return $ return ; } return parent :: generate ( ) ; }
1795	private function addFrontendRoute ( RouteCollection $ routes , array $ defaults ) : void { $ route = new Route ( '/{alias}' . $ this -> urlSuffix , $ defaults , [ 'alias' => '.+' ] ) ; $ this -> addLocaleToRoute ( $ route ) ; $ routes -> add ( 'contao_frontend' , $ route ) ; }
3445	private function getAccessor ( $ field ) { $ method = 'get' . camel_case ( $ field ) . 'Attribute' ; return method_exists ( $ this , $ method ) ? $ method : false ; }
10345	protected function applyStepping ( $ range , $ step ) { if ( $ step === false || $ step === 1 ) { return $ range ; } foreach ( $ range as $ value => $ tmp ) { if ( ( $ value % $ step ) !== 0 ) { unset ( $ range [ $ value ] ) ; } } return array_values ( $ range ) ; }
27	public function write ( ) { $ data = array ( ) ; $ dumper = new ArrayDumper ( ) ; foreach ( $ this -> getCanonicalPackages ( ) as $ package ) { $ data [ ] = $ dumper -> dump ( $ package ) ; } usort ( $ data , function ( $ a , $ b ) { return strcmp ( $ a [ 'name' ] , $ b [ 'name' ] ) ; } ) ; $ this -> file -> write ( $ data ) ; }
2934	public function save ( ) { if ( is_file ( $ this -> filePath ) && $ this -> autoBackup ) { $ this -> backup ( ) ; } $ this -> writer -> save ( $ this -> filePath ) ; return $ this ; }
12910	public function group ( $ group ) { if ( ! is_array ( $ group ) ) { $ this -> group = array ( $ group ) ; } else { $ this -> group = $ group ; } return $ this ; }
9239	private function isInheritanceRelationship ( ForeignKeyConstraint $ fk ) { if ( ! $ fk -> getLocalTable ( ) -> hasPrimaryKey ( ) ) { return false ; } $ fkColumnNames = $ fk -> getLocalColumns ( ) ; $ pkColumnNames = $ fk -> getLocalTable ( ) -> getPrimaryKeyColumns ( ) ; sort ( $ fkColumnNames ) ; sort ( $ pkColumnNames ) ; return $ fkColumnNames == $ pkColumnNames ; }
2636	public function getLastVersion ( ) { try { $ url = self :: CHECK_VERSION_URL ; $ client = $ this -> curlFactory -> create ( ) ; $ client -> write ( \ Zend_Http_Client :: GET , $ url , '1.1' ) ; $ responseBody = $ client -> read ( ) ; $ client -> close ( ) ; $ responseCode = \ Zend_Http_Response :: extractCode ( $ responseBody ) ; if ( $ responseCode !== 200 ) { return false ; } $ body = \ Zend_Http_Response :: extractBody ( $ responseBody ) ; $ json = json_decode ( $ body ) ; $ version = ! empty ( $ json -> version ) ? $ json -> version : false ; return $ version ; } catch ( \ Exception $ e ) { $ this -> _logger -> log ( 100 , $ e -> getMessage ( ) . $ url ) ; return false ; } }
11485	protected function resolveClassArg ( ReflectionClass $ class , ReflectionParameter $ param , array $ params ) { $ name = '$' . $ param -> getName ( ) ; $ class = $ class -> getName ( ) ; while ( $ name !== null ) { if ( $ params && array_key_exists ( $ name , $ params ) ) { $ class = $ params [ $ name ] ; } if ( $ class instanceof Factory \ FactoryInterface ) { return $ class -> invoke ( $ this ) ; } if ( is_object ( $ class ) ) { return $ class ; } $ name = ( $ name != $ class ) ? $ class : null ; } try { return $ this -> resolve ( $ class ) ; } catch ( ReflectionException $ exception ) { if ( $ param -> isOptional ( ) ) { return null ; } throw $ exception ; } }
10489	public static function unbufferConnection ( Connection $ connection ) { $ wrappedConnection = $ connection -> getWrappedConnection ( ) ; if ( ! $ wrappedConnection instanceof PDOConnection ) { throw new InvalidArgumentException ( 'unbufferConection can only be used with pdo_mysql Doctrine driver.' ) ; } if ( $ wrappedConnection -> getAttribute ( PDO :: ATTR_DRIVER_NAME ) != 'mysql' ) { throw new InvalidArgumentException ( 'unbufferConection can only be used with PDO mysql driver, got "' . $ wrappedConnection -> getAttribute ( PDO :: ATTR_DRIVER_NAME ) . '" instead.' ) ; } if ( $ connection -> isConnected ( ) ) { $ connection -> close ( ) ; } $ connection -> getWrappedConnection ( ) -> setAttribute ( PDO :: MYSQL_ATTR_USE_BUFFERED_QUERY , false ) ; $ connection -> connect ( ) ; }
2224	public function editCss ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { return $ this -> User -> hasAccess ( 'css' , 'themes' ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' ; }
7249	protected function validateShipmentMethodRequirements ( SaleInterface $ sale , Constraint $ constraint ) { if ( null === $ method = $ sale -> getShipmentMethod ( ) ) { return ; } if ( $ sale -> isSameAddress ( ) ) { $ address = $ sale -> getInvoiceAddress ( ) ; $ path = 'invoiceAddress' ; } else { $ address = $ sale -> getDeliveryAddress ( ) ; $ path = 'deliveryAddress' ; } if ( null === $ address ) { return ; } $ gateway = $ this -> gatewayRegistry -> getGateway ( $ method -> getGatewayName ( ) ) ; if ( $ gateway -> requires ( Gateway \ GatewayInterface :: REQUIREMENT_MOBILE ) ) { if ( is_null ( $ address -> getMobile ( ) ) ) { $ this -> context -> buildViolation ( $ constraint -> shipment_method_require_mobile ) -> atPath ( $ path . '.mobile' ) -> addViolation ( ) ; } } }
11907	public function doFullBootBuildIfNecessary ( AviatorApp $ app ) { $ beaconUpdatedAt = $ this -> getChangedAt ( Aviator :: getInstallDir ( ) . '/tmp/watch_beacon' ) ; if ( $ beaconUpdatedAt > LocalDate :: now ( ) -> modifyBySeconds ( 3 ) -> getTimestamp ( ) ) { echo DebugErrorHandler :: watcherBeaconInFuture ( ) ; die ( ) ; } if ( PHP_SAPI !== 'cli' && $ beaconUpdatedAt < LocalDate :: now ( ) -> modifyBySeconds ( - 3 ) -> getTimestamp ( ) ) { echo DebugErrorHandler :: watcherNotRunning ( ) ; exit ( - 1 ) ; } $ needsBuild = ! class_exists ( $ app -> getContainerFqcn ( ) ) ; if ( ! $ needsBuild ) { $ reflect = new \ ReflectionClass ( $ app -> getContainerFqcn ( ) ) ; $ containerFile = $ reflect -> getFileName ( ) ; clearstatcache ( true , $ containerFile ) ; $ fileUpdatedAt = $ this -> getChangedAt ( Aviator :: getInstallDir ( ) . '/tmp/file_update_found' ) ; $ needsBuild = filemtime ( $ containerFile ) < $ fileUpdatedAt ; } if ( $ needsBuild ) { $ this -> doFullBootBuild ( $ app ) ; } }
10793	public function delete ( $ idOrUser , $ forceLogout = true ) { $ main = $ this -> getServiceLocator ( ) -> get ( 'neobazaar.service.main' ) ; $ em = $ main -> getEntityManager ( ) ; $ user = $ this -> getEntity ( $ idOrUser ) ; $ classifiedService = $ this -> getServiceLocator ( ) -> get ( 'document.service.classified' ) ; if ( ! $ this -> checkIfOwnerOrAdmin ( $ user ) ) { throw new \ Exception ( 'Non possiedi i permessi per agire su questo documento' ) ; } $ this -> getEventManager ( ) -> trigger ( __FUNCTION__ , $ this , array ( 'user' => $ user ) ) ; $ user -> setState ( UserEntity :: USER_STATE_DELETED ) ; $ em -> persist ( $ user ) ; $ em -> flush ( ) ; $ documents = $ user -> getDocument ( ) ; foreach ( $ documents as $ document ) { try { $ classifiedService -> delete ( $ document ) ; } catch ( \ Exception $ e ) { } } $ this -> getEventManager ( ) -> trigger ( __FUNCTION__ . '.post' , $ this , array ( 'user' => $ user ) ) ; if ( $ forceLogout ) { $ this -> logout ( ) ; } return $ user ; }
11174	public static function hash ( $ string , $ algorithm = 'blowfish' ) { switch ( strtolower ( $ algorithm ) ) : case ( 'md5' ) : $ salt = '$1$' . ( static :: rand ( 12 ) ) . '$' ; break ; case ( 'sha256' ) : $ salt = '$5$rounds=5000$' . ( static :: rand ( 16 ) ) . '$' ; break ; case ( 'sha512' ) : $ salt = '$6$rounds=5000$' . ( static :: rand ( 16 ) ) . '$' ; break ; case ( 'blowfish' ) : default : $ salt = '$2a$09$' . ( static :: rand ( 22 ) ) . '$' ; break ; endswitch ; return base64_encode ( crypt ( $ string , $ salt ) ) ; }
1022	private static function buildExecutionContext ( Schema $ schema , DocumentNode $ documentNode , $ rootValue , $ contextValue , $ rawVariableValues , $ operationName = null , ? callable $ fieldResolver = null , ? PromiseAdapter $ promiseAdapter = null ) { $ errors = [ ] ; $ fragments = [ ] ; $ operation = null ; $ hasMultipleAssumedOperations = false ; foreach ( $ documentNode -> definitions as $ definition ) { switch ( $ definition -> kind ) { case NodeKind :: OPERATION_DEFINITION : if ( ! $ operationName && $ operation ) { $ hasMultipleAssumedOperations = true ; } if ( ! $ operationName || ( isset ( $ definition -> name ) && $ definition -> name -> value === $ operationName ) ) { $ operation = $ definition ; } break ; case NodeKind :: FRAGMENT_DEFINITION : $ fragments [ $ definition -> name -> value ] = $ definition ; break ; } } if ( $ operation === null ) { if ( $ operationName ) { $ errors [ ] = new Error ( sprintf ( 'Unknown operation named "%s".' , $ operationName ) ) ; } else { $ errors [ ] = new Error ( 'Must provide an operation.' ) ; } } elseif ( $ hasMultipleAssumedOperations ) { $ errors [ ] = new Error ( 'Must provide operation name if query contains multiple operations.' ) ; } $ variableValues = null ; if ( $ operation !== null ) { [ $ coercionErrors , $ coercedVariableValues ] = Values :: getVariableValues ( $ schema , $ operation -> variableDefinitions ? : [ ] , $ rawVariableValues ? : [ ] ) ; if ( empty ( $ coercionErrors ) ) { $ variableValues = $ coercedVariableValues ; } else { $ errors = array_merge ( $ errors , $ coercionErrors ) ; } } if ( ! empty ( $ errors ) ) { return $ errors ; } Utils :: invariant ( $ operation , 'Has operation if no errors.' ) ; Utils :: invariant ( $ variableValues !== null , 'Has variables if no errors.' ) ; return new ExecutionContext ( $ schema , $ fragments , $ rootValue , $ contextValue , $ operation , $ variableValues , $ errors , $ fieldResolver , $ promiseAdapter ) ; }
1407	protected function getModelAttributes ( Model $ model ) { $ attributes = [ ] ; foreach ( $ this -> attributeKeys ( $ model ) as $ modelKey => $ field ) { if ( is_numeric ( $ modelKey ) ) { $ modelKey = $ field ; $ field = $ this -> fieldForAttribute ( $ field ) ; } $ attributes [ $ field ] = $ this -> extractAttribute ( $ model , $ modelKey , $ field ) ; } return $ attributes ; }
4316	private function getDefaultServices ( ) { return array ( 'abstracter' => function ( Debug $ debug ) { return new Debug \ Abstracter ( $ debug , $ debug -> config -> getCfgLazy ( 'abstracter' ) ) ; } , 'config' => function ( Debug $ debug ) { return new Debug \ Config ( $ debug , $ debug -> cfg ) ; } , 'errorEmailer' => function ( Debug $ debug ) { return new ErrorEmailer ( $ debug -> config -> getCfgLazy ( 'errorEmailer' ) ) ; } , 'errorHandler' => function ( Debug $ debug ) { if ( ErrorHandler :: getInstance ( ) ) { return ErrorHandler :: getInstance ( ) ; } else { $ errorHandler = new ErrorHandler ( $ debug -> eventManager ) ; $ errorHandler -> setCfg ( 'onEUserError' , 'log' ) ; return $ errorHandler ; } } , 'eventManager' => function ( ) { return new EventManager ( ) ; } , 'internal' => function ( Debug $ debug ) { return new Debug \ Internal ( $ debug ) ; } , 'logger' => function ( Debug $ debug ) { return new Debug \ Logger ( $ debug ) ; } , 'methodClear' => function ( Debug $ debug ) { return new Debug \ MethodClear ( $ debug , $ debug -> data ) ; } , 'methodTable' => function ( ) { return new Debug \ MethodTable ( ) ; } , 'output' => function ( Debug $ debug ) { $ output = new Debug \ Output ( $ debug , $ debug -> config -> getCfgLazy ( 'output' ) ) ; $ debug -> eventManager -> addSubscriberInterface ( $ output ) ; return $ output ; } , 'utf8' => function ( ) { return new Debug \ Utf8 ( ) ; } , 'utilities' => function ( ) { return new Debug \ Utilities ( ) ; } , ) ; }
6308	public function setA ( StringType $ name , Attribute $ attribute ) { if ( $ this -> hasA ( $ name ) ) { $ this -> attributes = $ this -> attributes -> kDiff ( new AttributeMap ( [ $ name ( ) => $ attribute ] ) ) ; } $ this -> attributes = $ this -> attributes -> append ( [ $ name ( ) => $ attribute ] ) ; return $ this ; }
5317	public function run ( ) { $ signalHandler = $ this -> getSignalHandler ( ) ; $ signalHandler -> registerHandler ( SIGTERM , function ( ) { $ this -> shouldShutdown = true ; } ) ; $ this -> sharedMemory [ self :: STARTED_MARKER ] = true ; $ callable = $ this -> callable ; $ callable ( $ this ) ; }
92	protected static function validateSyntax ( $ json , $ file = null ) { $ parser = new JsonParser ( ) ; $ result = $ parser -> lint ( $ json ) ; if ( null === $ result ) { if ( defined ( 'JSON_ERROR_UTF8' ) && JSON_ERROR_UTF8 === json_last_error ( ) ) { throw new \ UnexpectedValueException ( '"' . $ file . '" is not UTF-8, could not parse as JSON' ) ; } return true ; } throw new ParsingException ( '"' . $ file . '" does not contain valid JSON' . "\n" . $ result -> getMessage ( ) , $ result -> getDetails ( ) ) ; }
12875	public static function getJSON ( $ src ) { $ src = file_get_contents ( $ src ) ; $ out = json_decode ( $ src , true ) ; return $ out ; }
3111	public function getStorageService ( ) { if ( ! $ this -> storageService ) { $ this -> storageService = $ this -> getServiceLocator ( ) -> get ( StorageManager :: SERVICE_ID ) ; } return $ this -> storageService ; }
12194	public function instantiate ( $ className , array $ data = [ ] ) { $ refl = new \ ReflectionClass ( $ className ) ; $ instanceArgs = [ ] ; if ( $ data ) { $ instanceArgs = $ this -> extractArguments ( $ refl -> getConstructor ( ) -> getParameters ( ) , $ data ) ; } return $ refl -> newInstanceArgs ( $ instanceArgs ) ; }
6812	private function getDateTimeFormatter ( ) { if ( $ this -> dateTimeFormatter ) { return $ this -> dateTimeFormatter ; } return $ this -> dateTimeFormatter = IntlDateFormatter :: create ( $ this -> locale , IntlDateFormatter :: SHORT , IntlDateFormatter :: SHORT , ini_get ( 'date.timezone' ) , IntlDateFormatter :: GREGORIAN ) ; }
10412	public function loadUrlsFromDocument ( $ type , SeoAwareInterface $ document ) { if ( $ this -> invalidateSeoUrls ) { $ urls = $ document -> getUrls ( ) ; if ( is_array ( $ urls ) || $ urls instanceof \ Traversable ) { foreach ( $ urls as $ url ) { $ this -> addUrl ( $ url -> getUrl ( ) ) ; } } } foreach ( $ this -> urlCollectors as $ collector ) { $ this -> addUrls ( $ collector -> getDocumentUrls ( $ type , $ document , $ this -> router ) ) ; $ this -> addMultipleDocumentParameters ( $ collector -> getDocumentParameters ( $ type , $ document ) ) ; } }
10386	protected function createInitializer ( ) { $ initializer = new Initializer ( ) ; $ initializer -> addTemplate ( 'Common' , new CommonTemplate ( ) ) ; $ initializer -> addTemplate ( 'Laravel' , new LaravelTemplate ( ) ) ; $ initializer -> addTemplate ( 'Symfony' , new SymfonyTemplate ( ) ) ; $ initializer -> addTemplate ( 'Yii' , new YiiTemplate ( ) ) ; $ initializer -> addTemplate ( 'Yii2 Basic App' , new Yii2BasicAppTemplate ( ) ) ; $ initializer -> addTemplate ( 'Yii2 Advanced App' , new Yii2AdvancedAppTemplate ( ) ) ; return $ initializer ; }
2821	protected function _beforeSave ( ) { parent :: _beforeSave ( ) ; if ( ! $ this -> getId ( ) ) { $ this -> setToken ( $ this -> generateToken ( ) ) ; $ this -> setHttpMethod ( $ this -> getController ( ) -> getHttpMethod ( ) ) ; $ this -> setResponseCode ( $ this -> getController ( ) -> getResponseCode ( ) ) ; $ this -> setIp ( $ this -> getController ( ) -> getRemoteIp ( ) ) ; } $ this -> setRequestPath ( $ this -> getController ( ) -> getRequestOriginalPath ( ) ) ; $ this -> setSessionId ( $ this -> getController ( ) -> getSessionId ( ) ) ; $ this -> setInfo ( $ this -> getSerializedInfo ( ) ) ; return $ this ; }
1039	private static function printPath ( ? array $ path = null ) { $ pathStr = '' ; $ currentPath = $ path ; while ( $ currentPath ) { $ pathStr = ( is_string ( $ currentPath [ 'key' ] ) ? '.' . $ currentPath [ 'key' ] : '[' . $ currentPath [ 'key' ] . ']' ) . $ pathStr ; $ currentPath = $ currentPath [ 'prev' ] ; } return $ pathStr ? 'value' . $ pathStr : '' ; }
9265	public function setProviders ( ) { $ services = $ this -> container [ 'services' ] ?? null ; if ( is_array ( $ services ) ) { foreach ( $ services as $ service ) { $ service :: register ( $ this -> container ) ; $ service :: boot ( $ this -> container ) ; } } }
9229	public function delete ( $ path , $ data = array ( ) , $ headers = array ( ) ) { if ( ! empty ( $ data ) ) { $ pathData = [ ] ; $ pos = strpos ( $ path , '?' ) ; if ( $ pos !== false ) { parse_str ( substr ( $ path , $ pos + 1 ) , $ pathData ) ; $ path = substr ( $ path , 0 , $ pos ) ; } $ path .= '?' . $ this -> http_build_query ( array_merge ( $ pathData , $ data ) ) ; } return $ this -> postprocessResponse ( parent :: delete ( $ path , $ headers ) ) ; }
7683	function Ext_GetMainIdx ( ) { if ( ( $ this -> ExtInfo !== false ) && isset ( $ this -> ExtInfo [ 'main' ] ) ) { return $ this -> FileGetIdx ( $ this -> ExtInfo [ 'main' ] ) ; } else { return false ; } }
2009	public function onInitializeSystem ( ) : void { foreach ( $ this -> globals as $ key => $ value ) { if ( \ is_array ( $ value ) && isset ( $ GLOBALS [ $ key ] ) && \ is_array ( $ GLOBALS [ $ key ] ) ) { $ GLOBALS [ $ key ] = array_replace_recursive ( $ GLOBALS [ $ key ] , $ value ) ; } else { $ GLOBALS [ $ key ] = $ value ; } } }
1987	private function filterOptions ( array $ allowedSizes ) : array { if ( empty ( $ allowedSizes ) ) { return [ ] ; } $ filteredSizes = [ ] ; foreach ( $ this -> options as $ group => $ sizes ) { if ( 'image_sizes' === $ group ) { $ this -> filterImageSizes ( $ sizes , $ allowedSizes , $ filteredSizes , $ group ) ; } else { $ this -> filterResizeModes ( $ sizes , $ allowedSizes , $ filteredSizes , $ group ) ; } } return $ filteredSizes ; }
381	public function createServerInformationLink ( ) { $ serverUrls = [ 'http://httpd.apache.org/' => [ 'apache' ] , 'http://nginx.org/' => [ 'nginx' ] , 'http://lighttpd.net/' => [ 'lighttpd' ] , 'http://gwan.com/' => [ 'g-wan' , 'gwan' ] , 'http://iis.net/' => [ 'iis' , 'services' ] , 'https://secure.php.net/manual/en/features.commandline.webserver.php' => [ 'development' ] , ] ; if ( isset ( $ _SERVER [ 'SERVER_SOFTWARE' ] ) ) { foreach ( $ serverUrls as $ url => $ keywords ) { foreach ( $ keywords as $ keyword ) { if ( stripos ( $ _SERVER [ 'SERVER_SOFTWARE' ] , $ keyword ) !== false ) { return '<a href="' . $ url . '" target="_blank">' . $ this -> htmlEncode ( $ _SERVER [ 'SERVER_SOFTWARE' ] ) . '</a>' ; } } } } return '' ; }
9990	private function writeImageInCell ( Worksheet $ pSheet , $ coordinates ) { $ html = '' ; foreach ( $ pSheet -> getDrawingCollection ( ) as $ drawing ) { if ( $ drawing instanceof Drawing ) { if ( $ drawing -> getCoordinates ( ) == $ coordinates ) { $ filename = $ drawing -> getPath ( ) ; if ( substr ( $ filename , 0 , 1 ) == '.' ) { $ filename = substr ( $ filename , 1 ) ; } $ filename = $ this -> getImagesRoot ( ) . $ filename ; if ( substr ( $ filename , 0 , 1 ) == '.' && substr ( $ filename , 0 , 2 ) != './' ) { $ filename = substr ( $ filename , 1 ) ; } $ filename = htmlspecialchars ( $ filename ) ; $ html .= PHP_EOL ; if ( ( ! $ this -> embedImages ) || ( $ this -> isPdf ) ) { $ imageData = $ filename ; } else { $ imageDetails = getimagesize ( $ filename ) ; if ( $ fp = fopen ( $ filename , 'rb' , 0 ) ) { $ picture = fread ( $ fp , filesize ( $ filename ) ) ; fclose ( $ fp ) ; $ base64 = chunk_split ( base64_encode ( $ picture ) ) ; $ imageData = 'data:' . $ imageDetails [ 'mime' ] . ';base64,' . $ base64 ; } else { $ imageData = $ filename ; } } $ html .= '<div style="position: relative;">' ; $ html .= '<img style="position: absolute; z-index: 1; left: ' . $ drawing -> getOffsetX ( ) . 'px; top: ' . $ drawing -> getOffsetY ( ) . 'px; width: ' . $ drawing -> getWidth ( ) . 'px; height: ' . $ drawing -> getHeight ( ) . 'px;" src="' . $ imageData . '" border="0" />' ; $ html .= '</div>' ; } } elseif ( $ drawing instanceof MemoryDrawing ) { if ( $ drawing -> getCoordinates ( ) != $ coordinates ) { continue ; } ob_start ( ) ; imagepng ( $ drawing -> getImageResource ( ) ) ; $ contents = ob_get_contents ( ) ; ob_end_clean ( ) ; $ dataUri = 'data:image/jpeg;base64,' . base64_encode ( $ contents ) ; $ html .= '<img src="' . $ dataUri . '" style="max-width:100%;width:' . $ drawing -> getWidth ( ) . 'px;" />' ; } } return $ html ; }
8011	private static function setParityBit ( $ byte ) { $ parity = 1 ; for ( $ i = 1 ; $ i < 8 ; $ i ++ ) { $ parity = ( $ parity + ( ( $ byte >> $ i ) & 1 ) ) % 2 ; } $ byte = $ byte | ( $ parity & 1 ) ; return $ byte ; }
12372	public function addRule ( string $ name , callable $ func , $ errorMsg = null ) : self { $ this -> rules [ $ name ] = array ( $ func , $ errorMsg ) ; return $ this ; }
5540	public function setFrameFocusByIndex ( $ choice ) { if ( is_integer ( $ this -> focus ) ) { if ( $ this -> frames [ $ this -> focus ] -> hasFrames ( ) ) { return $ this -> frames [ $ this -> focus ] -> setFrameFocusByIndex ( $ choice ) ; } } if ( ( $ choice < 1 ) || ( $ choice > count ( $ this -> frames ) ) ) { return false ; } $ this -> focus = $ choice - 1 ; return true ; }
11591	private function upload ( $ path , $ payload ) { return Storage :: disk ( 's3' ) -> put ( $ path , $ payload , $ this -> visibility ) ; }
361	public function renderErrors ( ) { if ( $ this -> filterModel instanceof Model && $ this -> filterModel -> hasErrors ( ) ) { return Html :: errorSummary ( $ this -> filterModel , $ this -> filterErrorSummaryOptions ) ; } return '' ; }
12048	public function render ( ElementInterface $ element ) { $ renderer = $ this -> getView ( ) ; if ( $ element instanceof CkEditor ) { $ plugin = $ renderer -> plugin ( 'form_ckeditor' ) ; return $ plugin ( $ element ) ; } return parent :: render ( $ element ) ; }
6436	public function getUserProfile ( ) { $ credentials = array ( 'identifier' => $ this -> options [ 'consumer_key' ] , 'secret' => $ this -> options [ 'consumer_secret' ] ) ; $ server = new \ League \ OAuth1 \ Client \ Server \ Xing ( $ credentials ) ; $ user = $ server -> getUserDetails ( $ this -> access_token ) ; return array ( 'userid' => $ user -> uid , 'name' => $ user -> display_name , 'imageurl' => $ user -> imageUrl ) ; }
9847	public function createSealedResponse ( int $ status , string $ body , SealingPublicKey $ key , array $ headers = [ ] , string $ version = '1.1' ) : ResponseInterface { return new Response ( $ status , new Headers ( $ headers ) , $ this -> stringToStream ( Base64UrlSafe :: encode ( Simple :: seal ( $ body , $ key ) ) ) ) ; }
7392	public function serialize ( ) : string { $ toSerialize = [ '_arrayOptions' => $ this -> _arrayOptions , '_jsonOptions' => $ this -> _jsonOptions , ] ; foreach ( $ this -> _publicNames as $ k ) { $ toSerialize [ $ k ] = $ this -> { $ k } ; } return serialize ( $ toSerialize ) ; }
2829	public function enableSqlProfilerAction ( ) { try { $ this -> getService ( ) -> setSqlProfilerStatus ( true ) ; $ this -> getService ( ) -> flushCache ( ) ; Mage :: getSingleton ( 'core/session' ) -> addSuccess ( 'SQL profiler was enabled.' ) ; } catch ( Exception $ e ) { Mage :: getSingleton ( 'core/session' ) -> addError ( 'Unable to enable SQL profiler: ' . $ e -> getMessage ( ) ) ; } $ this -> _redirectReferer ( ) ; }
8805	protected function driver ( ) { if ( $ this -> getDefaultDriver ( ) === 'argon' ) { return $ this -> createArgonDriver ( ) ; } elseif ( $ this -> getDefaultDriver ( ) === 'argon2id' ) { return $ this -> createArgon2IdDriver ( ) ; } return $ this -> createBcryptDriver ( ) ; }
5865	protected function reportAdditionalStorageClaimed ( $ bytes ) { $ legacyFileName = PATH_site . 'typo3conf/.tx_imageautoresize' ; $ fileName = PATH_site . 'typo3temp/.tx_imageautoresize' ; if ( file_exists ( $ legacyFileName ) && ! file_exists ( $ fileName ) ) { @ rename ( $ legacyFileName , $ fileName ) ; } $ data = [ ] ; if ( file_exists ( $ fileName ) ) { $ data = json_decode ( file_get_contents ( $ fileName ) , true ) ; if ( ! is_array ( $ data ) ) { $ data = [ ] ; } } $ data [ 'bytes' ] = $ bytes + ( isset ( $ data [ 'bytes' ] ) ? ( int ) $ data [ 'bytes' ] : 0 ) ; $ data [ 'images' ] = 1 + ( isset ( $ data [ 'images' ] ) ? ( int ) $ data [ 'images' ] : 0 ) ; GeneralUtility :: writeFile ( $ fileName , json_encode ( $ data ) ) ; }
6900	public function close ( ) : void { if ( $ this -> is_active ( ) ) { $ this -> _data [ 'last_active' ] = time ( ) ; config ( 'debug' ) ? session_write_close ( ) : @ session_write_close ( ) ; } }
9842	public function createSealedJsonResponse ( int $ status , array $ arrayToJsonify , SealingPublicKey $ key , array $ headers = [ ] , string $ version = '1.1' ) : ResponseInterface { if ( empty ( $ headers [ 'Content-Type' ] ) ) { $ headers [ 'Content-Type' ] = 'application/json' ; } $ body = \ json_encode ( $ arrayToJsonify , JSON_PRETTY_PRINT ) ; if ( ! \ is_string ( $ body ) ) { throw new InvalidMessageException ( 'Cannot JSON-encode this message.' ) ; } return $ this -> createSealedResponse ( $ status , $ body , $ key , $ headers , $ version ) ; }
8393	public static function run ( ) { if ( self :: $ isInit === true ) { self :: $ request = new Request ( self :: $ routes ) ; self :: $ controllers = array ( ) ; try { $ before = self :: $ request -> getBefore ( ) ; foreach ( $ before as $ b ) { $ controller = Controllers :: get ( $ b [ 'class' ] ) ; $ action = $ b [ 'action' ] ; $ controller -> $ action ( self :: $ request ) ; } if ( self :: $ request -> hasEnded ( ) === false ) { $ controller = Controllers :: get ( self :: $ request -> getClass ( ) ) ; $ action = self :: $ request -> getAction ( ) ; $ controller -> $ action ( self :: $ request ) ; if ( self :: $ request -> hasEnded ( ) === false ) { $ after = self :: $ request -> getAfter ( ) ; foreach ( $ after as $ a ) { $ controller = Controllers :: get ( $ a [ 'class' ] ) ; $ action = $ a [ 'action' ] ; $ controller -> $ action ( self :: $ request ) ; } } } } catch ( \ Exception $ e ) { echo 'Exception: ' . $ e -> getMessage ( ) . PHP_EOL ; echo $ e -> getTraceAsString ( ) ; } } }
7073	static public function isBetterAvailability ( $ stateA , $ stateB ) { if ( $ stateA === $ stateB ) { return false ; } switch ( $ stateA ) { case static :: STATE_PENDING : return in_array ( $ stateB , [ static :: STATE_NEW , static :: STATE_CLOSED ] , true ) ; case static :: STATE_READY : return in_array ( $ stateB , [ static :: STATE_NEW , static :: STATE_PENDING , static :: STATE_CLOSED ] , true ) ; } return false ; }
169	public static function unlink ( $ path ) { $ isWindows = DIRECTORY_SEPARATOR === '\\' ; if ( ! $ isWindows ) { return unlink ( $ path ) ; } if ( is_link ( $ path ) && is_dir ( $ path ) ) { return rmdir ( $ path ) ; } try { return unlink ( $ path ) ; } catch ( ErrorException $ e ) { if ( function_exists ( 'exec' ) && file_exists ( $ path ) ) { exec ( 'DEL /F/Q ' . escapeshellarg ( $ path ) ) ; return ! file_exists ( $ path ) ; } return false ; } }
5052	public function getContentType ( ) { if ( ! $ this -> contentType ) { $ this -> setContentType ( $ this -> getParam ( 'contentType' ) ? : static :: TYPE_JSON ) ; } return $ this -> contentType ; }
3341	public function getFileList ( $ options = array ( ) ) { $ options = array_replace ( array ( 'from' => null , 'to' => null , 'limit' => null , 'request_limit' => null , 'stored' => $ this -> defaultFilters [ 'file' ] [ 'stored' ] , 'removed' => $ this -> defaultFilters [ 'file' ] [ 'removed' ] , 'reversed' => false , ) , $ options ) ; if ( ! empty ( $ options [ 'from' ] ) && ! empty ( $ options [ 'to' ] ) ) { throw new \ Exception ( 'Only one of "from" and "to" arguments is allowed' ) ; } $ options [ 'from' ] = self :: dateTimeString ( $ options [ 'from' ] ) ; $ options [ 'to' ] = self :: dateTimeString ( $ options [ 'to' ] ) ; foreach ( $ this -> defaultFilters [ 'file' ] as $ k => $ v ) { if ( ! is_null ( $ options [ $ k ] ) ) { $ options [ $ k ] = self :: booleanString ( $ options [ $ k ] ) ; } } return new FileIterator ( $ this , $ options ) ; }
2972	protected function determineContext ( array & $ data ) { $ refs = 0 ; $ vars = array_map ( function ( $ node ) use ( & $ refs ) { if ( $ node -> byRef ) { $ refs ++ ; } if ( $ node -> var instanceof VariableNode ) { return $ node -> var -> name ; } else { return $ node -> var ; } } , $ data [ 'ast' ] -> uses ) ; $ data [ 'hasRefs' ] = ( $ refs > 0 ) ; $ values = $ data [ 'reflection' ] -> getStaticVariables ( ) ; foreach ( $ vars as $ name ) { if ( isset ( $ values [ $ name ] ) ) { $ data [ 'context' ] [ $ name ] = $ values [ $ name ] ; } } }
2892	public function onWebsiteRestriction ( Varien_Event_Observer $ observer ) { $ controller = $ observer -> getController ( ) ; $ result = $ observer -> getResult ( ) ; $ helper = Mage :: helper ( 'sheep_debug' ) ; if ( $ helper -> canShowToolbar ( ) && $ controller instanceof Sheep_Debug_Controller_Front_Action ) { $ result -> setShouldProceed ( false ) ; } }
11852	protected function setLayout ( string $ layoutName ) : void { if ( is_null ( $ this -> view ) ) { throw new Exception ( "It's unable to set Layout without View." ) ; } $ this -> layout = ViewFactory :: createLayout ( $ layoutName , $ this -> view ) ; }
9864	private function writeDataValidations ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { $ dataValidationCollection = $ pSheet -> getDataValidationCollection ( ) ; if ( ! empty ( $ dataValidationCollection ) ) { $ dataValidationCollection = Coordinate :: mergeRangesInCollection ( $ dataValidationCollection ) ; $ objWriter -> startElement ( 'dataValidations' ) ; $ objWriter -> writeAttribute ( 'count' , count ( $ dataValidationCollection ) ) ; foreach ( $ dataValidationCollection as $ coordinate => $ dv ) { $ objWriter -> startElement ( 'dataValidation' ) ; if ( $ dv -> getType ( ) != '' ) { $ objWriter -> writeAttribute ( 'type' , $ dv -> getType ( ) ) ; } if ( $ dv -> getErrorStyle ( ) != '' ) { $ objWriter -> writeAttribute ( 'errorStyle' , $ dv -> getErrorStyle ( ) ) ; } if ( $ dv -> getOperator ( ) != '' ) { $ objWriter -> writeAttribute ( 'operator' , $ dv -> getOperator ( ) ) ; } $ objWriter -> writeAttribute ( 'allowBlank' , ( $ dv -> getAllowBlank ( ) ? '1' : '0' ) ) ; $ objWriter -> writeAttribute ( 'showDropDown' , ( ! $ dv -> getShowDropDown ( ) ? '1' : '0' ) ) ; $ objWriter -> writeAttribute ( 'showInputMessage' , ( $ dv -> getShowInputMessage ( ) ? '1' : '0' ) ) ; $ objWriter -> writeAttribute ( 'showErrorMessage' , ( $ dv -> getShowErrorMessage ( ) ? '1' : '0' ) ) ; if ( $ dv -> getErrorTitle ( ) !== '' ) { $ objWriter -> writeAttribute ( 'errorTitle' , $ dv -> getErrorTitle ( ) ) ; } if ( $ dv -> getError ( ) !== '' ) { $ objWriter -> writeAttribute ( 'error' , $ dv -> getError ( ) ) ; } if ( $ dv -> getPromptTitle ( ) !== '' ) { $ objWriter -> writeAttribute ( 'promptTitle' , $ dv -> getPromptTitle ( ) ) ; } if ( $ dv -> getPrompt ( ) !== '' ) { $ objWriter -> writeAttribute ( 'prompt' , $ dv -> getPrompt ( ) ) ; } $ objWriter -> writeAttribute ( 'sqref' , $ coordinate ) ; if ( $ dv -> getFormula1 ( ) !== '' ) { $ objWriter -> writeElement ( 'formula1' , $ dv -> getFormula1 ( ) ) ; } if ( $ dv -> getFormula2 ( ) !== '' ) { $ objWriter -> writeElement ( 'formula2' , $ dv -> getFormula2 ( ) ) ; } $ objWriter -> endElement ( ) ; } $ objWriter -> endElement ( ) ; } }
7079	public static function getTypes ( ) { return [ self :: TYPE_WEBSITE , self :: TYPE_USER , self :: TYPE_ADMINISTRATOR , self :: TYPE_IN_CHARGE , self :: TYPE_CUSTOMER , self :: TYPE_SALESMAN , self :: TYPE_ACCOUNTABLE , self :: TYPE_SUPPLIER , ] ; }
11537	public function get ( $ name , $ default = "" ) { $ param = Arr :: get ( $ _REQUEST , $ name , $ default ) ; if ( $ _SERVER [ "REQUEST_METHOD" ] == "GET" && is_string ( $ param ) ) { $ param = urldecode ( $ param ) ; } return $ param ; }
2890	public function onModelLoad ( Varien_Event_Observer $ observer ) { if ( ! $ this -> canCollect ( ) ) { return ; } $ model = $ observer -> getData ( 'object' ) ; $ this -> getRequestInfo ( ) -> addModel ( $ model ) ; }
6250	protected function filterNestedEmptyGroups ( AclPresenceInterface $ presence ) { if ( $ presence [ 'type' ] !== AclPresenceType :: GROUP ) { return 1 ; } $ permissions = $ presence -> permissions ( ) ; if ( ! $ permissions ) { return 0 ; } if ( is_string ( $ permissions ) ) { return 1 ; } return count ( $ permissions ) ; }
6546	public function get ( $ name ) { if ( ( $ sheet = $ this -> container -> getSheetByName ( $ name ) ) === null ) { throw new \ Aimeos \ MW \ Container \ Exception ( sprintf ( 'No sheet "%1$s" available' , $ name ) ) ; } return new \ Aimeos \ MW \ Container \ Content \ PHPExcel ( $ sheet , $ sheet -> getTitle ( ) , $ this -> getOptions ( ) ) ; }
12976	public function parseMappingInfo ( ) { $ mappings = array ( ) ; foreach ( $ this -> getMappings ( ) as $ mappingName => $ mappingConfig ) { if ( is_array ( $ mappingConfig ) === false or \ Arr :: get ( $ mappingConfig , 'mapping' , true ) === false ) { continue ; } $ mappingConfig = array_replace ( array ( 'dir' => false , 'type' => false , 'prefix' => false , ) , $ mappingConfig ) ; if ( isset ( $ mappingConfig [ 'is_component' ] ) === false ) { $ mappingConfig [ 'is_component' ] = false ; if ( is_dir ( $ mappingConfig [ 'dir' ] ) === false ) { $ mappingConfig [ 'is_component' ] = ( \ Package :: loaded ( $ mappingName ) or \ Module :: loaded ( $ mappingName ) ) ; } } if ( $ mappingConfig [ 'is_component' ] ) { $ mappingConfig = $ this -> getComponentDefaults ( $ mappingName , $ mappingConfig ) ; } if ( empty ( $ mappingConfig ) ) { continue ; } $ mappings [ $ mappingName ] = $ mappingConfig ; } $ this -> config [ 'mappings' ] = $ mappings ; }
4962	public function addViewModel ( $ name , $ model , $ priority = 0 ) { $ this -> models -> insert ( $ name , $ model , $ priority ) ; return $ this ; }
11759	public function deleteReply ( $ msgId , $ index , $ commentId ) { $ params = [ 'msg_data_id' => $ msgId , 'index' => $ index , 'user_comment_id' => $ commentId , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_DELETE_REPLY , $ params ] ) ; }
3747	protected function extractSorting ( $ config ) { $ sorting = $ config -> getSorting ( ) ; $ sortBy = key ( $ sorting ) ; $ sortDir = current ( $ sorting ) ? : DCGE :: MODEL_SORTING_ASC ; return array ( $ sortBy , $ sortDir ) ; }
3672	private function getPageCandidates ( string $ alias ) { $ aliases = [ $ alias ] ; while ( '/' !== $ alias && false !== strpos ( $ alias , '/' ) ) { $ alias = \ dirname ( $ alias ) ; $ aliases [ ] = $ alias ; } $ pages = $ this -> pageModelAdapter -> findByAliases ( $ aliases ) ; if ( null === $ pages ) { return null ; } $ arrPages = [ ] ; while ( $ pages -> next ( ) ) { $ objModel = $ pages -> current ( ) ; $ objPage = $ objModel -> loadDetails ( ) ; $ domain = $ objPage -> domain ? : '*' ; $ arrPages [ $ domain ] [ $ objPage -> rootLanguage ] [ ] = $ objPage ; if ( $ objPage -> rootIsFallback ) { $ arrPages [ $ domain ] [ '*' ] [ ] = $ objPage ; } } return $ arrPages ; }
10484	public static function createSpamComplaint ( $ recipientEmailAddress , $ listExternalId , $ recipientExternalId = null , $ ipAddress = '127.0.0.1' ) { if ( $ recipientExternalId == null ) { $ recipientExternalId = rand ( 1 , 99999 ) ; } return ( new Payload ( ) ) -> setIpAddress ( $ ipAddress ) -> setAction ( Type :: SPAM_COMPLAINT ) -> setCampaignId ( rand ( 1 , 99999 ) ) -> setListExternalId ( $ listExternalId ) -> setReason ( Type :: REASON_USER_REQUEST ) -> setRecipientEmailAddress ( $ recipientEmailAddress ) -> setHash ( md5 ( $ recipientEmailAddress ) ) -> setRecipientExternalId ( $ recipientExternalId ) -> setTriggerDate ( new \ DateTime ( ) ) -> setType ( Type :: SPAM_COMPLAINT ) ; }
5387	public function setValue ( $ values ) { $ values = $ this -> makeArray ( $ values ) ; if ( ! $ this -> valuesArePossible ( $ values ) ) { return false ; } $ widgets = $ this -> getWidgets ( ) ; for ( $ i = 0 , $ count = count ( $ widgets ) ; $ i < $ count ; $ i ++ ) { $ possible = $ widgets [ $ i ] -> getAttribute ( 'value' ) ; if ( in_array ( $ widgets [ $ i ] -> getAttribute ( 'value' ) , $ values ) ) { $ widgets [ $ i ] -> setValue ( $ possible ) ; } else { $ widgets [ $ i ] -> setValue ( false ) ; } } return true ; }
965	public function dispatchScripttags ( ) { $ scripttags = Config :: get ( 'shopify-app.scripttags' ) ; if ( count ( $ scripttags ) > 0 ) { ScripttagInstaller :: dispatch ( $ this -> shop , $ scripttags ) -> onQueue ( Config :: get ( 'shopify-app.job_queues.scripttags' ) ) ; } }
9581	public function getChannel ( $ channel = null ) { $ channel = $ channel ? : $ this -> defaultChannel ; if ( isset ( $ this -> deferredChannels [ $ channel ] ) ) { $ this -> setChannel ( $ channel , $ this -> deferredChannels [ $ channel ] ( ) ) ; unset ( $ this -> deferredChannels [ $ channel ] ) ; } if ( isset ( $ this -> channels [ $ channel ] ) ) { return $ this -> channels [ $ channel ] ; } throw new InvalidArgumentException ( "Undefined channel: $channel" ) ; }
11258	private function invoker ( ContainerInterface $ container ) { $ resolvers = new ResolverChain ( [ new ParameterNameContainerResolver ( $ container ) , new DefaultValueResolver ( ) , ] ) ; $ invoker = new Invoker ( $ resolvers , $ container ) ; return $ invoker ; }
7898	protected function dynamicFrom ( $ from ) { $ provider = Str :: snake ( substr ( $ from , 4 ) ) ; return $ this -> from ( $ provider ) ; }
6680	public static function getDateTime ( $ format , $ timestamp = 'now' ) { $ date = strtotime ( $ timestamp ) ; if ( ! $ date ) { return $ timestamp ; } return date ( $ format , $ date ) ; }
3469	public function options ( string $ route , callable $ controller ) : void { $ this -> register ( $ controller , Route :: options ( $ route ) ) ; }
8146	public function parse ( Twig_TokenStream $ stream ) { if ( null === $ this -> parser ) { $ this -> parser = new Twig_Parser ( $ this ) ; } return $ this -> parser -> parse ( $ stream ) ; }
10353	private function fireEventOn ( $ action , $ payload ) { $ event = $ this -> getEventName ( ) ; $ this -> dispatcher -> fire ( "auth.{$event}.{$action}" , $ payload ) ; }
7303	public function onParentChange ( ResourceEventInterface $ event ) { $ customer = $ this -> getCustomerFromEvent ( $ event ) ; if ( $ this -> updateFromParent ( $ customer ) ) { $ this -> persistenceHelper -> persistAndRecompute ( $ customer , true ) ; } }
8032	public function validateDatesArray ( $ attribute , $ value , array $ parameters , Validator $ validator ) { foreach ( $ value as $ date ) { if ( false === strtotime ( $ date ) || empty ( $ date ) ) { return false ; } } return true ; }
11084	public static function deleteDirectory ( $ dirName , $ deleteSelf = true ) { $ dirName = rtrim ( $ dirName , '/' ) . '/' ; if ( file_exists ( $ dirName ) && $ files = scandir ( $ dirName , SCANDIR_SORT_NONE ) ) { foreach ( $ files as $ file ) { if ( $ file !== '.' && $ file !== '..' && $ file !== '.svn' ) { if ( is_dir ( $ dirName . $ file ) ) { self :: deleteDirectory ( $ dirName . $ file , true ) ; } elseif ( file_exists ( $ dirName . $ file ) ) { @ chmod ( $ dirName . $ file , 0777 ) ; unlink ( $ dirName . $ file ) ; } } } if ( $ deleteSelf && ! rmdir ( $ dirName ) ) { @ chmod ( $ dirName , 0777 ) ; return false ; } return true ; } return false ; }
6383	public function readFeedbackAttempt ( $ id ) { $ model = $ this -> readObject ( $ id , 'feedback_completed' ) ; $ model -> url = $ this -> cfg -> wwwroot . '/mod/feedback/complete.php?id=' . $ id ; $ model -> name = 'Attempt ' . $ id ; $ model -> responses = $ this -> readStoreRecords ( 'feedback_value' , [ 'completed' => $ id ] ) ; return $ model ; }
8151	public function hasExtension ( $ class ) { $ class = ltrim ( $ class , '\\' ) ; if ( ! isset ( $ this -> extensionsByClass [ $ class ] ) && class_exists ( $ class , false ) ) { $ class = new ReflectionClass ( $ class ) ; $ class = $ class -> name ; } if ( isset ( $ this -> extensions [ $ class ] ) ) { if ( $ class !== get_class ( $ this -> extensions [ $ class ] ) ) { @ trigger_error ( sprintf ( 'Referencing the "%s" extension by its name (defined by getName()) is deprecated since 1.26 and will be removed in Twig 2.0. Use the Fully Qualified Extension Class Name instead.' , $ class ) , E_USER_DEPRECATED ) ; } return true ; } return isset ( $ this -> extensionsByClass [ $ class ] ) ; }
6044	public function view ( $ sessionId , $ mediaId ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'sessionId' => $ sessionId , 'mediaId' => $ mediaId ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/events/view' , $ parameters , true ) ; return $ result ; }
2534	public function setSessionData ( array $ sessionData ) { if ( isset ( $ sessionData [ 'sessionId' ] , $ sessionData [ 'sequenceNumber' ] , $ sessionData [ 'securityToken' ] ) ) { $ this -> sessionData [ 'sessionId' ] = $ sessionData [ 'sessionId' ] ; $ this -> sessionData [ 'sequenceNumber' ] = $ sessionData [ 'sequenceNumber' ] ; $ this -> sessionData [ 'securityToken' ] = $ sessionData [ 'securityToken' ] ; $ this -> isAuthenticated = true ; } else { $ this -> isAuthenticated = false ; } return $ this -> isAuthenticated ; }
5781	private function getSectionForAdministrator ( array $ section , string $ sectionName ) : array { if ( isset ( $ section [ 'authorization' ] ) && ! $ this -> container -> authorization -> isAuthorized ( $ section [ 'authorization' ] ) ) { return [ ] ; } $ updatedSection = [ ] ; foreach ( $ section as $ key => $ value ) { if ( $ key != 'subSections' ) { $ updatedSection [ $ key ] = $ value ; } } $ updatedSubSections = [ ] ; if ( isset ( $ section [ 'subSections' ] ) ) { foreach ( $ section [ 'subSections' ] as $ subSectionName => $ subSection ) { $ updatedSubSection = $ this -> getSectionForAdministrator ( $ subSection , $ subSectionName ) ; if ( count ( $ updatedSubSection ) > 0 ) { $ updatedSubSections [ $ subSectionName ] = $ updatedSubSection ; } } } if ( count ( $ updatedSubSections ) > 0 ) { $ updatedSection [ 'subSections' ] = $ updatedSubSections ; } return $ updatedSection ; }
5158	public static function create ( array $ data ) : \ One \ Model \ Gallery { $ body = self :: validateString ( ( string ) self :: checkData ( $ data , 'body' , '' ) ) ; $ order = self :: validateInteger ( ( int ) self :: checkData ( $ data , 'order' , null ) ) ; $ photo = self :: validateUrl ( ( string ) self :: checkData ( $ data , 'photo' , '' ) ) ; $ source = self :: validateUrl ( ( string ) self :: checkData ( $ data , 'source' , '' ) ) ; $ lead = self :: validateString ( ( string ) self :: checkData ( $ data , 'lead' , '' ) ) ; return self :: createGallery ( $ body , $ order , $ photo , $ source , $ lead ) ; }
3809	protected function applyLegendConditions ( $ attributeId , $ activeLegendId ) { if ( ! isset ( $ this -> conditions [ $ activeLegendId ] ) ) { return ; } if ( ! isset ( $ this -> conditions [ $ attributeId ] ) ) { $ this -> conditions [ $ attributeId ] = new PropertyConditionChain ( ) ; } $ this -> conditions [ $ attributeId ] -> addCondition ( $ this -> conditions [ $ activeLegendId ] ) ; }
874	public function getAnnotationsOfType ( $ types ) { $ annotations = [ ] ; $ types = ( array ) $ types ; foreach ( $ this -> getAnnotations ( ) as $ annotation ) { $ tag = $ annotation -> getTag ( ) -> getName ( ) ; foreach ( $ types as $ type ) { if ( $ type === $ tag ) { $ annotations [ ] = $ annotation ; } } } return $ annotations ; }
12820	public function execute ( callable $ callback , array $ vars ) : Response { $ arguments = $ this -> resolveDependencies ( $ callback , $ vars ) ; return call_user_func_array ( $ callback , $ arguments ) ; }
5126	public static function init ( array $ directories , EnvironmentInterface $ environment = null , bool $ handleErrors = true ) : ? self { if ( $ handleErrors ) { ExceptionHandler :: register ( ) ; } $ core = new static ( new Container ( ) , $ directories ) ; $ core -> container -> bindSingleton ( EnvironmentInterface :: class , $ environment ?? new Environment ( ) ) ; try { ContainerScope :: runScope ( $ core -> container , function ( ) use ( $ core ) { $ core -> bootload ( ) ; $ core -> bootstrap ( ) ; } ) ; } catch ( \ Throwable $ e ) { ExceptionHandler :: handleException ( $ e ) ; return null ; } return $ core ; }
10608	public function passwordRecoveredAction ( ) { $ this -> getResponse ( ) -> setStatusCode ( Response :: STATUS_CODE_201 ) ; $ userService = $ this -> getServiceLocator ( ) -> get ( 'user.service.user' ) ; $ id = $ this -> params ( ) -> fromRoute ( 'id' ) ; try { $ userService -> passwordRecovered ( $ id ) ; $ returnData = array ( 'status' => 'success' , 'message' => 'Ti abbiamo inviato un\'email con la nuova password per il tuo account. Se vorrai potrai modificarla una volta connesso.' ) ; } catch ( \ Exception $ e ) { $ this -> getResponse ( ) -> setStatusCode ( Response :: STATUS_CODE_500 ) ; $ returnData = @ unserialize ( $ e -> getMessage ( ) ) ; if ( ! is_array ( $ returnData ) ) { $ returnData = array ( 'status' => 'danger' , 'message' => $ e -> getMessage ( ) ) ; } } return new JsonModel ( $ returnData ) ; }
5084	protected function validateUserInput ( $ aData , $ oItem = null ) { $ aOut = [ ] ; $ aFields = $ this -> oModel -> describeFields ( ) ; $ aKeys = array_unique ( array_merge ( array_keys ( $ aFields ) , arrayExtractProperty ( $ this -> oModel -> getExpandableFields ( ) , 'trigger' ) ) ) ; $ aValidKeys = array_diff ( $ aKeys , static :: IGNORE_FIELDS_WRITE ) ; foreach ( $ aValidKeys as $ sValidKey ) { $ oField = getFromArray ( $ sValidKey , $ aFields ) ; if ( array_key_exists ( $ sValidKey , $ aData ) ) { $ aOut [ $ sValidKey ] = getFromArray ( $ sValidKey , $ aData ) ; } } return $ aOut ; }
2020	public function getSearchablePages ( $ arrPages , $ intRoot = 0 , $ blnIsSitemap = false ) { $ arrRoot = array ( ) ; if ( $ intRoot > 0 ) { $ arrRoot = $ this -> Database -> getChildRecords ( $ intRoot , 'tl_page' ) ; } $ arrProcessed = array ( ) ; $ time = Date :: floorToMinute ( ) ; $ objFaq = FaqCategoryModel :: findAll ( ) ; if ( $ objFaq !== null ) { while ( $ objFaq -> next ( ) ) { if ( ! $ objFaq -> jumpTo ) { continue ; } if ( ! empty ( $ arrRoot ) && ! \ in_array ( $ objFaq -> jumpTo , $ arrRoot ) ) { continue ; } if ( ! isset ( $ arrProcessed [ $ objFaq -> jumpTo ] ) ) { $ objParent = PageModel :: findWithDetails ( $ objFaq -> jumpTo ) ; if ( $ objParent === null ) { continue ; } if ( ! $ objParent -> published || ( $ objParent -> start != '' && $ objParent -> start > $ time ) || ( $ objParent -> stop != '' && $ objParent -> stop <= ( $ time + 60 ) ) ) { continue ; } if ( $ blnIsSitemap ) { if ( $ objParent -> protected ) { continue ; } if ( $ objParent -> sitemap == 'map_never' ) { continue ; } } $ arrProcessed [ $ objFaq -> jumpTo ] = $ objParent -> getAbsoluteUrl ( Config :: get ( 'useAutoItem' ) ? '/%s' : '/items/%s' ) ; } $ strUrl = $ arrProcessed [ $ objFaq -> jumpTo ] ; $ objItems = FaqModel :: findPublishedByPid ( $ objFaq -> id ) ; if ( $ objItems !== null ) { while ( $ objItems -> next ( ) ) { $ arrPages [ ] = sprintf ( preg_replace ( '/%(?!s)/' , '%%' , $ strUrl ) , ( $ objItems -> alias ? : $ objItems -> id ) ) ; } } } } return $ arrPages ; }
8842	private function stringToArray ( string $ string ) : array { $ lines = preg_split ( '/\R/' , $ string ) ; if ( 1 === count ( $ lines ) && '' === $ lines [ 0 ] ) { $ lines = [ ] ; } return $ lines ; }
9923	public function requireParam ( $ key ) { $ param = $ this -> fetch ( $ key , function ( $ key ) { throw new ParameterMissingException ( "Missing param '$key'" ) ; } ) ; if ( $ this -> valueIsEmpty ( $ param ) ) { throw new ParameterMissingException ( "Missing param '$key'" ) ; } return $ param ; }
10943	public function encode ( $ rawString ) { $ bytes = unpack ( 'C*' , $ rawString ) ; $ byteCount = count ( $ bytes ) ; $ encodedString = '' ; $ byte = array_shift ( $ bytes ) ; $ bitsRead = 0 ; $ chars = $ this -> chars ; $ bitsPerCharacter = $ this -> bitsPerCharacter ; $ rightPadFinalBits = $ this -> rightPadFinalBits ; $ padFinalGroup = $ this -> padFinalGroup ; $ padCharacter = $ this -> padCharacter ; for ( $ c = 0 ; $ c < $ byteCount * 8 / $ bitsPerCharacter ; ++ $ c ) { if ( $ bitsRead + $ bitsPerCharacter > 8 ) { $ oldBitCount = 8 - $ bitsRead ; $ oldBits = $ byte ^ ( $ byte >> $ oldBitCount << $ oldBitCount ) ; $ newBitCount = $ bitsPerCharacter - $ oldBitCount ; if ( ! $ bytes ) { if ( $ rightPadFinalBits ) { $ oldBits <<= $ newBitCount ; } $ encodedString .= $ chars [ $ oldBits ] ; if ( $ padFinalGroup ) { $ lcmMap = array ( 1 => 1 , 2 => 1 , 3 => 3 , 4 => 1 , 5 => 5 , 6 => 3 , 7 => 7 , 8 => 1 ) ; $ bytesPerGroup = $ lcmMap [ $ bitsPerCharacter ] ; $ pads = $ bytesPerGroup * 8 / $ bitsPerCharacter - ceil ( ( strlen ( $ rawString ) % $ bytesPerGroup ) * 8 / $ bitsPerCharacter ) ; $ encodedString .= str_repeat ( $ padCharacter [ 0 ] , $ pads ) ; } break ; } $ byte = array_shift ( $ bytes ) ; $ bitsRead = 0 ; } else { $ oldBitCount = 0 ; $ newBitCount = $ bitsPerCharacter ; } $ bits = $ byte >> 8 - ( $ bitsRead + ( $ newBitCount ) ) ; $ bits ^= $ bits >> $ newBitCount << $ newBitCount ; $ bitsRead += $ newBitCount ; if ( $ oldBitCount ) { $ bits = ( $ oldBits << $ newBitCount ) | $ bits ; } $ encodedString .= $ chars [ $ bits ] ; } return $ encodedString ; }
1454	protected function validateRelationship ( RelationshipInterface $ relationship , $ key = null ) { if ( ! $ relationship -> has ( RelationshipInterface :: DATA ) ) { $ this -> addError ( $ this -> errorFactory -> memberRequired ( RelationshipInterface :: DATA , $ key ? P :: relationship ( $ key ) : P :: data ( ) ) ) ; return false ; } if ( ! $ relationship -> isHasOne ( ) && ! $ relationship -> isHasMany ( ) ) { $ this -> addError ( $ this -> errorFactory -> memberRelationshipExpected ( RelationshipInterface :: DATA , $ key ? P :: relationship ( $ key ) : P :: data ( ) ) ) ; return false ; } if ( ! $ this -> validateEmpty ( $ relationship , $ key ) ) { return false ; } return true ; }
9831	public function resource ( $ modelName , $ controller ) { if ( php_sapi_name ( ) == 'cli' ) { return ; } if ( ! class_exists ( $ controller ) ) { throw new ExpectedAujaControllerException ( $ controller . ' does not exist.' ) ; } if ( ! is_subclass_of ( $ controller , 'Label305\AujaLaravel\Controllers\Interfaces\AujaControllerInterface' ) ) { throw new ExpectedAujaControllerException ( $ controller . ' does not implement Label305\AujaLaravel\Controllers\Interfaces\AujaControllerInterface' ) ; } $ this -> registerIndex ( $ modelName , $ controller ) ; $ this -> registerMenu ( $ modelName , $ controller ) ; $ this -> registerShowMenu ( $ modelName , $ controller ) ; $ this -> registerCreate ( $ modelName , $ controller ) ; $ this -> registerStore ( $ modelName , $ controller ) ; $ this -> registerShow ( $ modelName , $ controller ) ; $ this -> registerEdit ( $ modelName , $ controller ) ; $ this -> registerUpdate ( $ modelName , $ controller ) ; $ this -> registerDelete ( $ modelName , $ controller ) ; $ model = $ this -> auja -> getModel ( ucfirst ( str_singular ( camel_case ( $ modelName ) ) ) ) ; $ relations = $ this -> auja -> getRelationsForModel ( $ model ) ; foreach ( $ relations as $ relation ) { $ otherModelName = $ relation -> getRight ( ) -> getName ( ) ; if ( $ relation -> getType ( ) == Relation :: BELONGS_TO ) { $ this -> registerBelongsToAssociationMenu ( $ modelName , $ otherModelName , $ controller ) ; } else { $ this -> registerAssociation ( $ modelName , $ otherModelName , $ controller ) ; $ this -> registerAssociationMenu ( $ modelName , $ otherModelName , $ controller ) ; $ this -> registerCreateAssociation ( $ modelName , $ otherModelName , $ controller ) ; } } }
6912	public function addInvoice ( InvoiceInterface $ invoice ) { if ( ! $ this -> invoices -> contains ( $ invoice ) ) { $ this -> invoices -> add ( $ invoice ) ; } return $ this ; }
7526	public static function parseFile ( $ path , $ context = null ) { $ html_str = file_get_contents ( $ path , false , $ context ) ; return static :: parseStr ( $ html_str ) ; }
153	public function each ( $ batchSize = 100 , $ db = null ) { return Yii :: createObject ( [ 'class' => BatchQueryResult :: className ( ) , 'query' => $ this , 'batchSize' => $ batchSize , 'db' => $ db , 'each' => true , ] ) ; }
2386	public function removeField ( $ name , string $ legend = null ) : self { $ this -> removes [ ] = [ 'fields' => ( array ) $ name , 'parents' => ( array ) $ legend , ] ; return $ this ; }
456	public function dropForeignKey ( $ name , $ table ) { return 'ALTER TABLE ' . $ this -> db -> quoteTableName ( $ table ) . ' DROP CONSTRAINT ' . $ this -> db -> quoteColumnName ( $ name ) ; }
8911	protected function apply_soft_delete_filter ( ) { if ( $ this -> soft_delete && $ this -> _temporary_with_deleted !== TRUE ) { if ( $ this -> _temporary_only_deleted ) { $ where = "`{$this->deleted_at_key}` <= NOW()" ; } else { $ where = sprintf ( '(%1$s > NOW() OR %1$s IS NULL OR %1$s = \'0000-00-00 00:00:00\')' , $ this -> deleted_at_key ) ; } $ this -> _database -> where ( $ where ) ; } }
133	public function getInstaller ( $ type ) { $ type = strtolower ( $ type ) ; if ( isset ( $ this -> cache [ $ type ] ) ) { return $ this -> cache [ $ type ] ; } foreach ( $ this -> installers as $ installer ) { if ( $ installer -> supports ( $ type ) ) { return $ this -> cache [ $ type ] = $ installer ; } } throw new \ InvalidArgumentException ( 'Unknown installer type: ' . $ type ) ; }
1735	public function getProvisionUri ( User $ user , Request $ request ) : string { $ issuer = rawurlencode ( $ request -> getSchemeAndHttpHost ( ) ) ; return sprintf ( 'otpauth://totp/%s:%s?secret=%s&issuer=%s' , $ issuer , rawurlencode ( $ user -> getUsername ( ) ) . '@' . $ issuer , $ this -> getUpperUnpaddedSecretForUser ( $ user ) , $ issuer ) ; }
10137	private function writeMsoDrawing ( ) { if ( isset ( $ this -> escher ) ) { $ writer = new Escher ( $ this -> escher ) ; $ data = $ writer -> close ( ) ; $ spOffsets = $ writer -> getSpOffsets ( ) ; $ spTypes = $ writer -> getSpTypes ( ) ; $ spOffsets [ 0 ] = 0 ; $ nm = count ( $ spOffsets ) - 1 ; for ( $ i = 1 ; $ i <= $ nm ; ++ $ i ) { $ record = 0x00EC ; $ dataChunk = substr ( $ data , $ spOffsets [ $ i - 1 ] , $ spOffsets [ $ i ] - $ spOffsets [ $ i - 1 ] ) ; $ length = strlen ( $ dataChunk ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ this -> append ( $ header . $ dataChunk ) ; $ record = 0x005D ; $ objData = '' ; if ( $ spTypes [ $ i ] == 0x00C9 ) { $ objData .= pack ( 'vvvvvVVV' , 0x0015 , 0x0012 , 0x0014 , $ i , 0x2101 , 0 , 0 , 0 ) ; $ objData .= pack ( 'vv' , 0x00C , 0x0014 ) ; $ objData .= pack ( 'H*' , '0000000000000000640001000A00000010000100' ) ; $ objData .= pack ( 'vv' , 0x0013 , 0x1FEE ) ; $ objData .= pack ( 'H*' , '00000000010001030000020008005700' ) ; } else { $ objData .= pack ( 'vvvvvVVV' , 0x0015 , 0x0012 , 0x0008 , $ i , 0x6011 , 0 , 0 , 0 ) ; } $ objData .= pack ( 'vv' , 0x0000 , 0x0000 ) ; $ length = strlen ( $ objData ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ this -> append ( $ header . $ objData ) ; } } }
8895	protected function _initialize_event_listeners ( ) { foreach ( $ this -> event_listeners as $ event_listener => $ e ) { if ( isset ( $ this -> $ event_listener ) && ! empty ( $ this -> $ event_listener ) ) { foreach ( $ this -> $ event_listener as $ event ) { $ this -> subscribe ( $ event_listener , $ event ) ; } } } $ this -> subscribe ( 'before_update' , 'protect_attributes' , TRUE ) ; }
9288	public function truncate ( ) { $ adapter = $ this -> dbAdapter ; $ mapper = new \ CronHelper \ Model \ JobMapper ( $ adapter ) ; $ where = new \ Zend \ Db \ Sql \ Where ( ) ; $ mapper -> deleteByWhere ( $ where ) ; }
188	private function getColumnDefinition ( $ table , $ column ) { $ row = $ this -> db -> createCommand ( 'SHOW CREATE TABLE ' . $ this -> db -> quoteTableName ( $ table ) ) -> queryOne ( ) ; if ( $ row === false ) { throw new Exception ( "Unable to find column '$column' in table '$table'." ) ; } if ( isset ( $ row [ 'Create Table' ] ) ) { $ sql = $ row [ 'Create Table' ] ; } else { $ row = array_values ( $ row ) ; $ sql = $ row [ 1 ] ; } $ sql = preg_replace ( '/^[^(]+\((.*)\).*$/' , '\1' , $ sql ) ; $ sql = str_replace ( ', [' , ",\n[" , $ sql ) ; if ( preg_match_all ( '/^\s*\[(.*?)\]\s+(.*?),?$/m' , $ sql , $ matches ) ) { foreach ( $ matches [ 1 ] as $ i => $ c ) { if ( $ c === $ column ) { return $ matches [ 2 ] [ $ i ] ; } } } return null ; }
8040	public function buildEventDates ( array $ data ) { $ dates = [ ] ; $ eventLength = $ this -> calculateEventLength ( $ data ) ; $ allDay = array_key_exists ( 'all_day' , $ data ) ; foreach ( $ data [ 'repeat_dates' ] as $ date ) { if ( strlen ( $ date ) > 0 ) { $ date = strtotime ( $ date . ' ' . $ data [ 'start' ] [ 'time' ] ) ; if ( false === $ date ) { throw new InvalidDateStringException ( 'Invalid date string!' ) ; } $ eventStart = $ this -> carbon -> copy ( ) -> setTimestamp ( $ date ) ; $ eventEnds = $ allDay ? null : $ eventStart -> copy ( ) -> addSeconds ( $ eventLength ) ; $ dates [ ] = [ 'start' => $ eventStart -> toDateTimeString ( ) , 'end' => ( null !== $ eventEnds ) ? $ eventEnds -> toDateTimeString ( ) : null , ] ; } } return $ dates ; }
11382	public function pipe ( $ stage ) { $ pipeline = new self ( $ this -> container , $ this -> stages ) ; $ this -> handleStage ( $ pipeline -> stages , $ stage ) ; return $ pipeline ; }
2504	protected static function getMessagesAndVersionsFromImportedWsdl ( $ import , $ wsdlPath , $ wsdlIdentifier ) { $ msgAndVer = [ ] ; $ domXpath = null ; $ importPath = realpath ( dirname ( $ wsdlPath ) ) . DIRECTORY_SEPARATOR . $ import ; $ wsdlContent = file_get_contents ( $ importPath ) ; if ( $ wsdlContent !== false ) { $ domDoc = new \ DOMDocument ( '1.0' , 'UTF-8' ) ; $ ok = $ domDoc -> loadXML ( $ wsdlContent ) ; if ( $ ok === true ) { $ domXpath = new \ DOMXPath ( $ domDoc ) ; $ domXpath -> registerNamespace ( 'wsdl' , 'http://schemas.xmlsoap.org/wsdl/' ) ; $ domXpath -> registerNamespace ( 'soap' , 'http://schemas.xmlsoap.org/wsdl/soap/' ) ; } } else { throw new InvalidWsdlFileException ( 'WSDL ' . $ importPath . ' import could not be loaded' ) ; } if ( $ domXpath instanceof \ DOMXPath ) { $ nodeList = $ domXpath -> query ( self :: XPATH_ALL_OPERATIONS ) ; $ msgAndVer = array_merge ( $ msgAndVer , self :: loopOperationsWithQuery ( $ nodeList , self :: XPATH_ALT_VERSION_FOR_OPERATION , $ wsdlIdentifier , $ domXpath ) ) ; } return $ msgAndVer ; }
1995	public function generateRss ( ) { $ this -> adjustPublicationDate ( ) ; $ xml = '<?xml version="1.0" encoding="' . Config :: get ( 'characterSet' ) . '"?>' ; $ xml .= '<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/" xmlns:atom="http://www.w3.org/2005/Atom">' ; $ xml .= '<channel>' ; $ xml .= '<title>' . StringUtil :: specialchars ( $ this -> title ) . '</title>' ; $ xml .= '<description>' . StringUtil :: specialchars ( $ this -> description ) . '</description>' ; $ xml .= '<link>' . StringUtil :: specialchars ( $ this -> link ) . '</link>' ; $ xml .= '<language>' . $ this -> language . '</language>' ; $ xml .= '<pubDate>' . date ( 'r' , $ this -> published ) . '</pubDate>' ; $ xml .= '<generator>Contao Open Source CMS</generator>' ; $ xml .= '<atom:link href="' . StringUtil :: specialchars ( Environment :: get ( 'base' ) . 'share/' . $ this -> strName ) . '.xml" rel="self" type="application/rss+xml" />' ; foreach ( $ this -> arrItems as $ objItem ) { $ xml .= '<item>' ; $ xml .= '<title>' . StringUtil :: specialchars ( strip_tags ( StringUtil :: stripInsertTags ( $ objItem -> title ) ) ) . '</title>' ; $ xml .= '<description><![CDATA[' . preg_replace ( '/[\n\r]+/' , ' ' , $ objItem -> description ) . ']]></description>' ; $ xml .= '<link>' . StringUtil :: specialchars ( $ objItem -> link ) . '</link>' ; $ xml .= '<pubDate>' . date ( 'r' , $ objItem -> published ) . '</pubDate>' ; if ( $ objItem -> guid ) { if ( strncmp ( $ objItem -> guid , 'http://' , 7 ) !== 0 && strncmp ( $ objItem -> guid , 'https://' , 8 ) !== 0 ) { $ xml .= '<guid isPermaLink="false">' . $ objItem -> guid . '</guid>' ; } else { $ xml .= '<guid>' . $ objItem -> guid . '</guid>' ; } } else { $ xml .= '<guid>' . StringUtil :: specialchars ( $ objItem -> link ) . '</guid>' ; } if ( \ is_array ( $ objItem -> enclosure ) ) { foreach ( $ objItem -> enclosure as $ arrEnclosure ) { if ( ! empty ( $ arrEnclosure [ 'media' ] ) && $ arrEnclosure [ 'media' ] == 'media:content' ) { $ xml .= '<media:content url="' . $ arrEnclosure [ 'url' ] . '" type="' . $ arrEnclosure [ 'type' ] . '" />' ; } else { $ xml .= '<enclosure url="' . $ arrEnclosure [ 'url' ] . '" length="' . $ arrEnclosure [ 'length' ] . '" type="' . $ arrEnclosure [ 'type' ] . '" />' ; } } } $ xml .= '</item>' ; } $ xml .= '</channel>' ; $ xml .= '</rss>' ; return $ xml ; }
1932	public function parse ( ) { $ strBuffer = parent :: parse ( ) ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'parseBackendTemplate' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'parseBackendTemplate' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'parseBackendTemplate' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ strBuffer = $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ strBuffer , $ this -> strTemplate ) ; } } return $ strBuffer ; }
8432	public function getDsn ( array $ info ) : string { $ dsn = 'pgsql:host=' ; $ dsn .= ( isset ( $ info [ 'host' ] ) === true ? $ info [ 'host' ] : 'localhost' ) . ';' ; if ( isset ( $ info [ 'port' ] ) === true ) { $ dsn .= 'port=' . $ info [ 'port' ] . ';' ; } $ dsn .= 'dbname=' . $ info [ 'name' ] . ';' ; return $ dsn ; }
11921	public static function arrayRecursiveDiff ( $ aArray1 , $ aArray2 ) { $ aReturn = array ( ) ; foreach ( $ aArray1 as $ mKey => $ mValue ) { if ( array_key_exists ( $ mKey , $ aArray2 ) ) { if ( is_array ( $ mValue ) ) { $ aRecursiveDiff = self :: arrayRecursiveDiff ( $ mValue , $ aArray2 [ $ mKey ] ) ; if ( count ( $ aRecursiveDiff ) ) { $ aReturn [ $ mKey ] = $ aRecursiveDiff ; } } else { if ( $ mValue != $ aArray2 [ $ mKey ] ) { $ aReturn [ $ mKey ] = $ mValue ; } } } else { $ aReturn [ $ mKey ] = $ mValue ; } } return $ aReturn ; }
389	public function link ( $ attribute , $ options = [ ] ) { if ( ( $ direction = $ this -> getAttributeOrder ( $ attribute ) ) !== null ) { $ class = $ direction === SORT_DESC ? 'desc' : 'asc' ; if ( isset ( $ options [ 'class' ] ) ) { $ options [ 'class' ] .= ' ' . $ class ; } else { $ options [ 'class' ] = $ class ; } } $ url = $ this -> createUrl ( $ attribute ) ; $ options [ 'data-sort' ] = $ this -> createSortParam ( $ attribute ) ; if ( isset ( $ options [ 'label' ] ) ) { $ label = $ options [ 'label' ] ; unset ( $ options [ 'label' ] ) ; } else { if ( isset ( $ this -> attributes [ $ attribute ] [ 'label' ] ) ) { $ label = $ this -> attributes [ $ attribute ] [ 'label' ] ; } else { $ label = Inflector :: camel2words ( $ attribute ) ; } } return Html :: a ( $ label , $ url , $ options ) ; }
9745	public function setCity ( $ city ) { if ( ! ( $ city instanceof City ) ) { $ city = new City ( $ city ) ; } if ( $ city -> isEmpty ( ) ) { $ this -> invalidArguments ( '10003' ) ; } return $ this -> setParameter ( 'city' , $ city ) ; }
3539	public static function getAdldapProvider ( ) { if ( static :: getExtensionOptions ( 'adldap-providername' ) != '__USE_DEFAULT_PROVIDER__' ) { $ provider = Yii :: $ app -> ad -> getProvider ( static :: getExtensionOptions ( 'adldap-providername' ) ) ; } else { $ provider = Yii :: $ app -> ad -> getDefaultProvider ( ) ; } return $ provider ; }
5955	public function channelPermList ( $ cid , $ permsid = false ) { return $ this -> execute ( "channelpermlist" , array ( "cid" => $ cid , $ permsid ? "-permsid" : null ) ) -> toAssocArray ( $ permsid ? "permsid" : "permid" ) ; }
8207	protected function putJob ( $ tube , $ body , $ priority , $ delay , $ ttr ) { $ id = $ this -> getPheanstalk ( ) -> putInTube ( $ tube , $ body , $ priority , $ delay , $ ttr ) ; return $ id ; }
1993	protected function prepareMetaDescription ( $ strText ) { $ strText = $ this -> replaceInsertTags ( $ strText , false ) ; $ strText = strip_tags ( $ strText ) ; $ strText = str_replace ( "\n" , ' ' , $ strText ) ; $ strText = StringUtil :: substr ( $ strText , 320 ) ; return trim ( $ strText ) ; }
3339	public function getGroupsChunk ( $ options = array ( ) , $ reverse = false ) { $ data = $ this -> __preparedRequest ( 'group_list' , 'GET' , $ options ) ; $ groups_raw = ( array ) $ data -> results ; $ resultArr = array ( ) ; foreach ( $ groups_raw as $ group_raw ) { $ resultArr [ ] = new Group ( $ group_raw -> id , $ this ) ; } return $ this -> __preparePagedParams ( $ data , $ reverse , $ resultArr ) ; }
694	public function sendMultiple ( array $ messages ) { $ successCount = 0 ; foreach ( $ messages as $ message ) { if ( $ this -> send ( $ message ) ) { $ successCount ++ ; } } return $ successCount ; }
2541	protected function analyzeWithErrCodeCategoryMsgQuery ( SendResult $ response , $ qErr , $ qCat , $ qMsg , $ errLevel = null ) { $ analyzeResponse = new Result ( $ response ) ; $ domXpath = $ this -> makeDomXpath ( $ response -> responseXml ) ; $ errorCodeNodeList = $ domXpath -> query ( $ qErr ) ; if ( $ errorCodeNodeList -> length > 0 ) { $ analyzeResponse -> status = Result :: STATUS_ERROR ; $ errorCatNode = $ domXpath -> query ( $ qCat ) -> item ( 0 ) ; if ( $ errorCatNode instanceof \ DOMNode ) { $ analyzeResponse -> status = $ this -> makeStatusFromErrorQualifier ( $ errorCatNode -> nodeValue ) ; } $ analyzeResponse -> messages [ ] = new Result \ NotOk ( $ errorCodeNodeList -> item ( 0 ) -> nodeValue , $ this -> makeMessageFromMessagesNodeList ( $ domXpath -> query ( $ qMsg ) ) , $ errLevel ) ; } return $ analyzeResponse ; }
11121	protected function pendingMigrations ( array $ files , array $ ran ) : array { $ array = [ ] ; foreach ( $ files as $ file ) { if ( ! in_array ( $ this -> getMigrationName ( $ file ) , $ ran , true ) ) { $ array [ ] = $ file ; } } return $ array ; }
8221	protected function getEntityId ( $ blockType , $ config , $ params = array ( ) ) { $ entityId = null ; if ( $ blockType === "account" && isset ( $ params [ "name" ] ) ) { $ entityId = md5 ( $ params [ "name" ] ) ; } elseif ( $ blockType === "email" && isset ( $ params [ "email" ] ) ) { $ entityId = md5 ( $ params [ "email" ] ) ; } elseif ( $ blockType === "ip" ) { $ entityId = $ this -> getIp ( $ config ) ; } return $ entityId ; }
11101	public static function countryCodeTwoToThree ( $ code ) { $ codes = array_flip ( self :: $ _countryCodes ) ; if ( ! array_key_exists ( $ code , $ codes ) ) { return false ; } return $ codes [ $ code ] ; }
665	protected function openFromPoolSequentially ( array $ pool , array $ sharedConfig ) { if ( empty ( $ pool ) ) { return null ; } if ( ! isset ( $ sharedConfig [ 'class' ] ) ) { $ sharedConfig [ 'class' ] = get_class ( $ this ) ; } $ cache = is_string ( $ this -> serverStatusCache ) ? Yii :: $ app -> get ( $ this -> serverStatusCache , false ) : $ this -> serverStatusCache ; foreach ( $ pool as $ config ) { $ config = array_merge ( $ sharedConfig , $ config ) ; if ( empty ( $ config [ 'dsn' ] ) ) { throw new InvalidConfigException ( 'The "dsn" option must be specified.' ) ; } $ key = [ __METHOD__ , $ config [ 'dsn' ] ] ; if ( $ cache instanceof CacheInterface && $ cache -> get ( $ key ) ) { continue ; } $ db = Yii :: createObject ( $ config ) ; try { $ db -> open ( ) ; return $ db ; } catch ( \ Exception $ e ) { Yii :: warning ( "Connection ({$config['dsn']}) failed: " . $ e -> getMessage ( ) , __METHOD__ ) ; if ( $ cache instanceof CacheInterface ) { $ cache -> set ( $ key , 1 , $ this -> serverRetryInterval ) ; } } } return null ; }
9003	protected function extra_tablenav ( $ which ) { if ( $ which !== 'top' ) { return ; } $ this -> months_dropdown ( '' ) ; $ selected = isset ( $ _GET [ 'level' ] ) ? $ _GET [ 'level' ] : '' ; ?> <label for="filter-by-level" class="screen-reader-text"> <?php echo $ this -> translations [ 'levelFilterLabel' ] ; ?> </label> <select name="level" id="filter-by-level"> <option value=""> <?php echo $ this -> translations [ 'allLevels' ] ; ?> </option> <?php foreach ( $ this -> get_levels ( ) as $ level => $ label ) : ?> <option value=" <?php echo esc_attr ( $ level ) ; ?> " <?php selected ( $ selected , $ level ) ; ?> > <?php echo $ label ; ?> </option> <?php endforeach ; ?> </select> <?php submit_button ( $ this -> translations [ 'filter' ] , 'button' , 'filter_action' , false ) ; }
1956	public function styleSheetLink ( Contao \ DataContainer $ dc ) { return ' <a href="contao/main.php?do=themes&amp;table=tl_style_sheet&amp;id=' . $ dc -> activeRecord -> pid . '&amp;popup=1&amp;nb=1&amp;rt=' . REQUEST_TOKEN . '" title="' . Contao \ StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_layout' ] [ 'edit_styles' ] ) . '" onclick="Backend.openModalIframe({\'title\':\'' . Contao \ StringUtil :: specialchars ( str_replace ( "'" , "\\'" , $ GLOBALS [ 'TL_LANG' ] [ 'tl_layout' ] [ 'edit_styles' ] ) ) . '\',\'url\':this.href});return false">' . Contao \ Image :: getHtml ( 'edit.svg' ) . '</a>' ; }
2907	public function getPartDecodedContent ( Zend_Mime_Part $ mimePart ) { if ( method_exists ( $ mimePart , 'getRawContent' ) ) { return $ mimePart -> getRawContent ( ) ; } $ content = '' ; if ( method_exists ( $ mimePart , 'getContent' ) ) { $ encoding = $ mimePart -> encoding ; $ mimePart -> encoding = 'none' ; $ content = $ mimePart -> getContent ( ) ; $ mimePart -> encoding = $ encoding ; } return $ content ; }
4287	public function getSubscriptions ( ) { if ( ! $ this -> isConnected ( ) ) { $ this -> debug -> alert ( 'WAMP publisher not connected to WAMP router' ) ; return array ( ) ; } $ this -> publishMeta ( ) ; $ this -> processExistingData ( ) ; return array ( 'debug.log' => array ( 'onLog' , PHP_INT_MAX * - 1 ) , 'errorHandler.error' => 'onError' , 'php.shutdown' => array ( 'onShutdown' , PHP_INT_MAX * - 1 ) , ) ; }
8035	public function isMemberOf ( $ group ) { foreach ( $ this -> attributes [ 'member_of' ] as $ groups ) { if ( preg_match ( '/^CN=' . $ group . '/' , $ groups ) ) { return true ; } } return false ; }
2142	private function getSessionBag ( Request $ request ) : SessionBagInterface { if ( ! $ request -> hasSession ( ) || null === ( $ session = $ request -> getSession ( ) ) ) { throw new \ RuntimeException ( 'The request did not contain a session.' ) ; } $ name = 'contao_frontend' ; if ( $ this -> scopeMatcher -> isBackendRequest ( $ request ) ) { $ name = 'contao_backend' ; } return $ session -> getBag ( $ name ) ; }
10237	public static function getInstance ( Spreadsheet $ spreadsheet = null ) { if ( $ spreadsheet !== null ) { $ instance = $ spreadsheet -> getCalculationEngine ( ) ; if ( isset ( $ instance ) ) { return $ instance ; } } if ( ! isset ( self :: $ instance ) || ( self :: $ instance === null ) ) { self :: $ instance = new self ( ) ; } return self :: $ instance ; }
11451	public function getParentKeyName ( ) { if ( $ this -> getParentName ( ) ) { $ func = $ this -> getParentName ( ) ; $ relat = $ this -> $ func ( ) ; $ field = $ relat -> getForeignKey ( ) ; return $ field ; } return 'id' ; }
6215	public function getParameters ( ) { $ parameters = $ this -> getUnfilteredParameters ( ) ; foreach ( $ this -> parameterFilters as $ filter ) { $ filter -> filter ( $ parameters ) ; } return $ parameters ; }
7294	public function inform_about_posts ( $ post_id = FALSE ) { if ( ! $ post_id ) { return $ post_id ; } if ( ! isset ( $ this -> transit_posts [ $ post_id ] ) ) { return $ post_id ; } $ transit = $ this -> transit_posts [ $ post_id ] ; if ( 'publish' != $ transit [ 'new_status' ] || 'publish' == $ transit [ 'old_status' ] ) { return $ post_id ; } $ post_data = get_post ( $ post_id ) ; $ user = get_userdata ( $ post_data -> post_author ) ; $ to = $ this -> get_members ( $ user -> data -> user_email , 'post' ) ; if ( empty ( $ to ) ) { return $ post_id ; } $ subject = get_option ( 'blogname' ) . ': ' . get_the_title ( $ post_data -> ID ) ; $ message = $ post_data -> post_content ; $ headers = array ( ) ; $ headers [ 'From' ] = get_the_author_meta ( 'display_name' , $ user -> ID ) . ' (' . get_bloginfo ( 'name' ) . ')' . ' <' . $ user -> data -> user_email . '>' ; if ( $ this -> options [ 'send_by_bcc' ] ) { $ bcc = $ to ; $ to = empty ( $ this -> options [ 'bcc_to_recipient' ] ) ? get_bloginfo ( 'admin_email' ) : $ this -> options [ 'bcc_to_recipient' ] ; $ headers [ 'Bcc' ] = $ bcc ; } $ to = apply_filters ( 'iac_post_to' , $ to , $ this -> options , $ post_id ) ; $ subject = apply_filters ( 'iac_post_subject' , $ subject , $ this -> options , $ post_id ) ; $ message = apply_filters ( 'iac_post_message' , $ message , $ this -> options , $ post_id ) ; $ headers = apply_filters ( 'iac_post_headers' , $ headers , $ this -> options , $ post_id ) ; $ attachments = apply_filters ( 'iac_post_attachments' , array ( ) , $ this -> options , $ post_id ) ; $ signature = apply_filters ( 'iac_post_signature' , '' , $ this -> options , $ post_id ) ; $ this -> options [ 'static_options' ] [ 'object' ] = array ( 'id' => $ post_id , 'type' => 'post' ) ; $ this -> send_mail ( $ to , $ subject , $ this -> append_signature ( $ message , $ signature ) , $ headers , $ attachments ) ; return $ post_id ; }
1545	public function decodes ( string ... $ mediaTypes ) : bool { if ( ! $ decoding = $ this -> getDecodingMediaType ( ) ) { return false ; } return collect ( $ mediaTypes ) -> contains ( function ( $ mediaType , $ index ) use ( $ decoding ) { return $ decoding -> equalsTo ( MediaType :: parse ( $ index , $ mediaType ) ) ; } ) ; }
7920	private function openZipFile ( $ zipFile ) { $ zipArchive = new \ ZipArchive ; if ( $ zipArchive -> open ( $ zipFile ) !== true ) { throw new \ Exception ( 'Error opening ' . $ zipFile ) ; } return $ zipArchive ; }
9932	public function addRule ( Column \ Rule $ pRule ) { $ pRule -> setParent ( $ this ) ; $ this -> ruleset [ ] = $ pRule ; return $ this ; }
11273	public function sendRequest ( RequestInterface $ request ) { $ this -> lastOperation = new Operation ( $ request ) ; $ response = parent :: sendRequest ( $ request ) ; $ this -> lastOperation -> setResponse ( $ response ) ; return $ response ; }
4915	private function addArray ( array $ result ) { if ( 1 < count ( $ result ) && ! isset ( $ result [ 'name' ] ) && ! is_string ( $ result [ 0 ] ) ) { foreach ( $ result as $ r ) { if ( is_array ( $ r ) ) { $ this -> add ( $ r ) ; } else { return $ this -> addTraversable ( new \ ArrayIterator ( $ result ) ) ; } } return $ this ; } if ( is_string ( $ result [ 0 ] ) ) { $ result = [ 'name' => $ result [ 0 ] , 'entities' => isset ( $ result [ 1 ] ) ? $ result [ 1 ] : null , 'options' => isset ( $ result [ 2 ] ) && is_array ( $ result [ 2 ] ) ? $ result [ 2 ] : [ 'description' => isset ( $ result [ 2 ] ) ? $ result [ 2 ] : null , 'viewScript' => isset ( $ result [ 3 ] ) ? $ result [ 3 ] : null , ] , ] ; } if ( ! isset ( $ result [ 'name' ] ) || ! isset ( $ result [ 'entities' ] ) ) { throw new \ UnexpectedValueException ( 'Array must have the keys "name" and "entities".' ) ; } if ( ! count ( $ result [ 'entities' ] ) ) { throw new \ UnexpectedValueException ( 'Entities must be non-empty.' ) ; } $ result = new DependencyResult ( $ result [ 'name' ] , $ result [ 'entities' ] , isset ( $ result [ 'options' ] ) ? $ result [ 'options' ] : null ) ; return $ this -> addResult ( $ result ) ; }
6407	public static function filter ( IteratorAggregate $ unfiltered , callable $ predicate ) : IteratorAggregate { return new CallableIterable ( function ( ) use ( $ unfiltered , $ predicate ) { return Iterators :: filter ( Iterators :: from ( $ unfiltered -> getIterator ( ) ) , $ predicate ) ; } ) ; }
8645	private function parseHttpHeader ( $ header ) { $ parsedHeader = array ( ) ; foreach ( explode ( "\n" , $ header ) as $ line ) { $ splitLine = preg_split ( '/:\s/' , $ line , 2 , PREG_SPLIT_NO_EMPTY ) ; if ( sizeof ( $ splitLine ) == 2 ) { $ k = strtolower ( trim ( $ splitLine [ 0 ] ) ) ; $ v = trim ( $ splitLine [ 1 ] ) ; if ( array_key_exists ( $ k , $ parsedHeader ) ) { $ parsedHeader [ $ k ] = $ parsedHeader [ $ k ] . "," . $ v ; } else { $ parsedHeader [ $ k ] = $ v ; } } } return $ parsedHeader ; }
778	public static function checkRequirements ( ) { if ( extension_loaded ( 'imagick' ) ) { $ imagickFormats = ( new \ Imagick ( ) ) -> queryFormats ( 'PNG' ) ; if ( in_array ( 'PNG' , $ imagickFormats , true ) ) { return 'imagick' ; } } if ( extension_loaded ( 'gd' ) ) { $ gdInfo = gd_info ( ) ; if ( ! empty ( $ gdInfo [ 'FreeType Support' ] ) ) { return 'gd' ; } } throw new InvalidConfigException ( 'Either GD PHP extension with FreeType support or ImageMagick PHP extension with PNG support is required.' ) ; }
1529	public function route ( ) : RouteRegistration { $ route = new RouteRegistration ( $ this -> router , $ this , $ this -> defaults ) ; $ route -> controller ( $ this -> options [ 'controller' ] ?? '' ) ; return $ route ; }
12113	public function getUnmappedForeignKeys ( ) { $ mappedForeign = ArrayHelper :: getColumn ( $ this -> _map , 'foreignKey' ) ; $ u = array_diff ( array_keys ( $ this -> foreignModel -> meta -> schema -> columns ) , $ mappedForeign ) ; unset ( $ u [ $ this -> foreignPrimaryKeyName ] ) ; return $ u ; }
10308	private function setGlowSize ( $ size ) { if ( $ size !== null ) { $ this -> glowProperties [ 'size' ] = $ this -> getExcelPointsWidth ( $ size ) ; } return $ this ; }
8854	public function getArchiveYear ( ) { $ year = $ this -> request -> param ( "Year" ) ; if ( preg_match ( "/^[0-9]{4}$/" , $ year ) ) { return ( int ) $ year ; } return null ; }
10293	protected static function validateTimeZone ( $ timeZone ) { if ( is_object ( $ timeZone ) && $ timeZone instanceof DateTimeZone ) { return $ timeZone ; } elseif ( is_string ( $ timeZone ) ) { return new DateTimeZone ( $ timeZone ) ; } throw new \ Exception ( 'Invalid timezone' ) ; }
9530	private function initialize ( $ argv , $ parameterCluster ) { $ this -> valid = true ; $ this -> haltedBy = null ; if ( $ parameterCluster != null ) { $ this -> parameterCluster = $ parameterCluster ; if ( $ argv != null ) { $ this -> preloadAliases ( $ argv ) ; } } if ( $ argv != null ) { $ this -> preloadParameters ( $ argv ) ; } }
8726	public function shouldFallback ( $ locale = null ) { if ( ! $ this -> getWithFallback ( ) || ! $ this -> getFallbackLocale ( ) ) { return false ; } $ locale = $ locale ? : $ this -> getLocale ( ) ; return $ locale != $ this -> getFallbackLocale ( ) ; }
298	public function updateAttributes ( $ attributes ) { $ attrs = [ ] ; foreach ( $ attributes as $ name => $ value ) { if ( is_int ( $ name ) ) { $ attrs [ ] = $ value ; } else { $ this -> $ name = $ value ; $ attrs [ ] = $ name ; } } $ values = $ this -> getDirtyAttributes ( $ attrs ) ; if ( empty ( $ values ) || $ this -> getIsNewRecord ( ) ) { return 0 ; } $ rows = static :: updateAll ( $ values , $ this -> getOldPrimaryKey ( true ) ) ; foreach ( $ values as $ name => $ value ) { $ this -> _oldAttributes [ $ name ] = $ this -> _attributes [ $ name ] ; } return $ rows ; }
3213	static function checkArgOrNull ( $ argName , $ argValue ) { if ( $ argValue === null ) return ; if ( ! ( $ argValue instanceof self ) ) Checker :: throwError ( $ argName , $ argValue , __CLASS__ ) ; }
3508	private static function doCharDiff ( $ from_text , $ to_text ) { $ result = array ( ) ; $ jobs = array ( array ( 0 , strlen ( $ from_text ) , 0 , strlen ( $ to_text ) ) ) ; while ( $ job = array_pop ( $ jobs ) ) { list ( $ from_segment_start , $ from_segment_end , $ to_segment_start , $ to_segment_end ) = $ job ; $ from_segment_len = $ from_segment_end - $ from_segment_start ; $ to_segment_len = $ to_segment_end - $ to_segment_start ; if ( ! $ from_segment_len || ! $ to_segment_len ) { if ( $ from_segment_len ) { $ result [ $ from_segment_start * 4 + 0 ] = new FineDiffDeleteOp ( $ from_segment_len ) ; } else if ( $ to_segment_len ) { $ result [ $ from_segment_start * 4 + 1 ] = new FineDiffInsertOp ( substr ( $ to_text , $ to_segment_start , $ to_segment_len ) ) ; } continue ; } if ( $ from_segment_len >= $ to_segment_len ) { $ copy_len = $ to_segment_len ; while ( $ copy_len ) { $ to_copy_start = $ to_segment_start ; $ to_copy_start_max = $ to_segment_end - $ copy_len ; while ( $ to_copy_start <= $ to_copy_start_max ) { $ from_copy_start = strpos ( substr ( $ from_text , $ from_segment_start , $ from_segment_len ) , substr ( $ to_text , $ to_copy_start , $ copy_len ) ) ; if ( $ from_copy_start !== false ) { $ from_copy_start += $ from_segment_start ; break 2 ; } $ to_copy_start ++ ; } $ copy_len -- ; } } else { $ copy_len = $ from_segment_len ; while ( $ copy_len ) { $ from_copy_start = $ from_segment_start ; $ from_copy_start_max = $ from_segment_end - $ copy_len ; while ( $ from_copy_start <= $ from_copy_start_max ) { $ to_copy_start = strpos ( substr ( $ to_text , $ to_segment_start , $ to_segment_len ) , substr ( $ from_text , $ from_copy_start , $ copy_len ) ) ; if ( $ to_copy_start !== false ) { $ to_copy_start += $ to_segment_start ; break 2 ; } $ from_copy_start ++ ; } $ copy_len -- ; } } if ( $ copy_len ) { $ jobs [ ] = array ( $ from_segment_start , $ from_copy_start , $ to_segment_start , $ to_copy_start ) ; $ result [ $ from_copy_start * 4 + 2 ] = new FineDiffCopyOp ( $ copy_len ) ; $ jobs [ ] = array ( $ from_copy_start + $ copy_len , $ from_segment_end , $ to_copy_start + $ copy_len , $ to_segment_end ) ; } else { $ result [ $ from_segment_start * 4 ] = new FineDiffReplaceOp ( $ from_segment_len , substr ( $ to_text , $ to_segment_start , $ to_segment_len ) ) ; } } ksort ( $ result , SORT_NUMERIC ) ; return array_values ( $ result ) ; }
2961	public function readPort ( $ count = 0 ) { if ( $ this -> _dState !== SERIAL_DEVICE_OPENED ) { trigger_error ( "Device must be opened to read it" , E_USER_WARNING ) ; return false ; } if ( $ this -> _os === "linux" || $ this -> _os === "osx" ) { $ content = "" ; $ i = 0 ; if ( $ count !== 0 ) { do { if ( $ i > $ count ) { $ content .= fread ( $ this -> _dHandle , ( $ count - $ i ) ) ; } else { $ content .= fread ( $ this -> _dHandle , 128 ) ; } } while ( ( $ i += 128 ) === strlen ( $ content ) ) ; } else { do { $ content .= fread ( $ this -> _dHandle , 128 ) ; } while ( ( $ i += 128 ) === strlen ( $ content ) ) ; } return $ content ; } elseif ( $ this -> _os === "windows" ) { $ content = "" ; $ i = 0 ; if ( $ count !== 0 ) { do { if ( $ i > $ count ) { $ content .= fread ( $ this -> _dHandle , ( $ count - $ i ) ) ; } else { $ content .= fread ( $ this -> _dHandle , 128 ) ; } } while ( ( $ i += 128 ) === strlen ( $ content ) ) ; } else { do { $ content .= fread ( $ this -> _dHandle , 128 ) ; } while ( ( $ i += 128 ) === strlen ( $ content ) ) ; } return $ content ; } return false ; }
3900	public function searchFor ( $ strPattern ) { $ strPattern = str_replace ( array ( '*' , '?' ) , array ( '%' , '_' ) , $ strPattern ) ; $ arrIds = $ this -> connection -> createQueryBuilder ( ) -> select ( 'id' ) -> from ( $ this -> getMetaModel ( ) -> getTableName ( ) ) -> where ( $ this -> getColName ( ) . ' LIKE :pattern' ) -> setParameter ( 'pattern' , $ strPattern ) -> execute ( ) -> fetchAll ( \ PDO :: FETCH_COLUMN , 'id' ) ; return $ arrIds ; }
2019	private function overwriteImageTargetDir ( array $ config , ContainerBuilder $ container ) : void { if ( ! isset ( $ config [ 'image' ] [ 'target_path' ] ) ) { return ; } $ container -> setParameter ( 'contao.image.target_dir' , $ container -> getParameter ( 'kernel.project_dir' ) . '/' . $ config [ 'image' ] [ 'target_path' ] ) ; @ trigger_error ( 'Using the contao.image.target_path parameter has been deprecated and will no longer work in Contao 5.0. Use the contao.image.target_dir parameter instead.' , E_USER_DEPRECATED ) ; }
1351	protected function allowed ( string $ resourceType , string $ fields ) : bool { return $ this -> notAllowed ( $ resourceType , $ fields ) -> isEmpty ( ) ; }
6360	public function filter ( callable $ predicate ) : BufferedIterable { return new BufferedIterable ( $ this -> chunkProvider , $ predicate , $ this -> limit , $ this -> providerCallLimit ) ; }
8384	public function select ( $ select ) { if ( is_array ( $ select ) === true ) { $ this -> select = '' ; foreach ( $ select as $ key => $ elem ) { $ this -> select .= $ elem ; if ( is_numeric ( $ key ) === false ) { $ this -> select .= ' AS ' . $ key ; } $ this -> select .= ', ' ; } $ this -> select = substr ( $ this -> select , 0 , - 2 ) ; } elseif ( ! is_string ( $ select ) ) { throw new InvalidArgumentException ( sprintf ( 'Argument 1 passed to %s must be an array or string!' , __METHOD__ ) ) ; } else { $ this -> select = $ select ; } return $ this ; }
537	protected function updateDocComment ( $ doc , $ properties ) { $ lines = explode ( "\n" , $ doc ) ; $ propertyPart = false ; $ propertyPosition = false ; foreach ( $ lines as $ i => $ line ) { $ line = trim ( $ line ) ; if ( strncmp ( $ line , '* @property ' , 12 ) === 0 ) { $ propertyPart = true ; } elseif ( $ propertyPart && $ line == '*' ) { $ propertyPosition = $ i ; $ propertyPart = false ; } if ( strncmp ( $ line , '* @author ' , 10 ) === 0 && $ propertyPosition === false ) { $ propertyPosition = $ i - 1 ; $ propertyPart = false ; } if ( $ propertyPart ) { unset ( $ lines [ $ i ] ) ; } } if ( $ propertyPosition === false ) { $ propertyPosition = \ count ( $ lines ) - 2 ; } $ finalDoc = '' ; foreach ( $ lines as $ i => $ line ) { $ finalDoc .= $ line . "\n" ; if ( $ i == $ propertyPosition ) { $ finalDoc .= $ properties ; } } return $ finalDoc ; }
7066	public function getUserRights ( ) { if ( ! $ this -> _UserRights ) { if ( Configure :: load ( 'user_rights' ) === false ) { trigger_error ( 'UserRights: Could not load config/user_rights.php' , E_USER_WARNING ) ; } $ rightsConfig = Configure :: read ( 'user_rights' ) ; if ( ! is_array ( $ rightsConfig ) ) { $ rightsConfig = [ ] ; } $ this -> _UserRights = new UserRights ( $ rightsConfig ) ; } return $ this -> _UserRights ; }
4936	protected function getEntities ( $ args ) { $ dm = $ args -> getDocumentManager ( ) ; $ resource = $ args -> getDocument ( ) ; $ repositoryName = $ this -> getRepositoryName ( ) ; $ resourceId = $ resource -> getPermissionsResourceId ( ) ; $ repository = $ dm -> getRepository ( $ repositoryName ) ; $ criteria = array ( 'permissions.assigned.' . $ resourceId => array ( '$exists' => true ) ) ; $ entities = $ repository -> findBy ( $ criteria ) ; return $ entities ; }
10656	public function usort ( $ cmp_function ) { $ tmp = $ this -> getArrayCopy ( ) ; $ ret = usort ( $ tmp , $ cmp_function ) ; $ tmp = new self ( $ tmp ) ; $ this -> exchangeArray ( $ tmp -> getArrayCopy ( ) ) ; return $ ret ; }
8144	public function tokenize ( $ source , $ name = null ) { if ( ! $ source instanceof Twig_Source ) { @ trigger_error ( sprintf ( 'Passing a string as the $source argument of %s() is deprecated since version 1.27. Pass a Twig_Source instance instead.' , __METHOD__ ) , E_USER_DEPRECATED ) ; $ source = new Twig_Source ( $ source , $ name ) ; } if ( null === $ this -> lexer ) { $ this -> lexer = new Twig_Lexer ( $ this ) ; } return $ this -> lexer -> tokenize ( $ source ) ; }
5352	public function getSupportedNamespaces ( ) { if ( empty ( $ this -> data -> namespaces ) || ! is_array ( $ this -> data -> namespaces ) ) { return array ( ) ; } return $ this -> data -> namespaces ; }
924	public function getInvalidErrors ( ) { return array_filter ( $ this -> errors , static function ( Error $ error ) { return Error :: TYPE_INVALID === $ error -> getType ( ) ; } ) ; }
11608	public function actionConfirm ( $ id , $ code ) { $ user = $ this -> finder -> findUserById ( $ id ) ; if ( $ user === null || $ this -> module -> emailChangeStrategy == Module :: STRATEGY_INSECURE ) { throw new NotFoundHttpException ; } $ user -> attemptEmailChange ( $ code ) ; return $ this -> redirect ( [ 'account' ] ) ; }
3114	public function clearEvents ( $ testSessionId ) { $ extendedState = $ this -> getExtendedState ( $ testSessionId ) ; $ extendedState -> clearEvents ( ) ; $ extendedState -> save ( ) ; }
8652	private function convertGetReportScheduleCount ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetReportScheduleCount' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetReportTypeList ( ) ) { $ reportTypeList = $ request -> getReportTypeList ( ) ; foreach ( $ reportTypeList -> getType ( ) as $ typeIndex => $ type ) { $ parameters [ 'ReportTypeList' . '.' . 'Type' . '.' . ( $ typeIndex + 1 ) ] = $ type ; } } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
9020	public function getUniqueWords ( $ string ) { $ words = $ this -> getWords ( $ string ) ; $ analysis = new FrequencyAnalysis ( $ words ) ; $ words = $ analysis -> getKeyValuesByFrequency ( ) ; return array_unique ( array_keys ( $ words ) ) ; }
217	public function asImage ( $ value , $ options = [ ] ) { if ( $ value === null ) { return $ this -> nullDisplay ; } return Html :: img ( $ value , $ options ) ; }
10423	public function setTriggerType ( $ type ) { if ( ! array_key_exists ( $ type , $ this -> validTypes ) ) { throw new \ InvalidArgumentException ( 'The type MUST be one of:' . implode ( ',' , $ this -> validTypes ) ) ; } $ this -> type = $ this -> validTypes [ $ type ] ; $ this -> typeAlias = $ type ; }
3658	public function handle ( EncodePropertyValueFromWidgetEvent $ event ) { if ( ( 'tl_metamodel_dca_combine' !== $ event -> getEnvironment ( ) -> getDataDefinition ( ) -> getName ( ) ) || ( 'rows' !== $ event -> getProperty ( ) ) ) { return ; } $ values = $ event -> getValue ( ) ; $ index = 0 ; $ time = time ( ) ; foreach ( array_keys ( $ values ) as $ key ) { $ values [ $ key ] [ 'sorting' ] = $ index ; $ values [ $ key ] [ 'tstamp' ] = $ time ; $ index += 128 ; } $ event -> setValue ( $ values ) ; }
2147	protected function sendNewsletter ( Email $ objEmail , Result $ objNewsletter , $ arrRecipient , $ text , $ html , $ css = null ) { $ objEmail -> text = StringUtil :: parseSimpleTokens ( $ text , $ arrRecipient ) ; if ( ! $ objNewsletter -> sendText ) { if ( $ objNewsletter -> template == '' ) { $ objNewsletter -> template = 'mail_default' ; } $ objTemplate = new BackendTemplate ( $ objNewsletter -> template ) ; $ objTemplate -> setData ( $ objNewsletter -> row ( ) ) ; $ objTemplate -> title = $ objNewsletter -> subject ; $ objTemplate -> body = StringUtil :: parseSimpleTokens ( $ html , $ arrRecipient ) ; $ objTemplate -> charset = Config :: get ( 'characterSet' ) ; $ objTemplate -> recipient = $ arrRecipient [ 'email' ] ; $ objTemplate -> css = $ css ; $ objEmail -> html = $ objTemplate -> parse ( ) ; $ objEmail -> imageDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) . '/' ; } try { $ objEmail -> sendTo ( $ arrRecipient [ 'email' ] ) ; } catch ( \ Swift_RfcComplianceException $ e ) { $ _SESSION [ 'REJECTED_RECIPIENTS' ] [ ] = $ arrRecipient [ 'email' ] ; } if ( $ objEmail -> hasFailures ( ) ) { $ _SESSION [ 'REJECTED_RECIPIENTS' ] [ ] = $ arrRecipient [ 'email' ] ; } if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'sendNewsletter' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'sendNewsletter' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'sendNewsletter' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ objEmail , $ objNewsletter , $ arrRecipient , $ text , $ html ) ; } } }
8378	public function setAction ( AbstractAction $ action ) { $ this -> action = $ action ; $ this -> action -> setArrayContainer ( $ this ) ; return $ this ; }
1183	protected function getSessionToken ( ) { $ token = null ; if ( $ session = $ this -> app -> __get ( 'session' ) ) { $ token = $ session -> token ( ) ; } if ( $ encrypter = $ this -> app -> __get ( 'encrypter' ) ) { $ token = $ encrypter -> encrypt ( $ token ) ; } return $ token ; }
4921	public function region ( $ region , $ reset = false ) { $ this -> currentRegion = $ region ; if ( $ reset ) { $ this -> matrix [ $ this -> currentRegion ] = [ ] ; } return $ this ; }
5841	public function addRole ( $ role ) { if ( is_string ( $ role ) ) { $ role = new Role ( $ role ) ; } elseif ( ! $ role instanceof RoleInterface ) { throw new \ InvalidArgumentException ( sprintf ( 'Role must be a string or RoleInterface instance, but got %s.' , gettype ( $ role ) ) ) ; } if ( ! \ in_array ( $ role , $ this -> roles ) ) { $ this -> roles [ ] = $ role ; } }
9763	function endWith ( string $ value ) : self { return $ this -> expect ( $ this -> target , stringEndsWith ( $ value ) ) ; }
9934	public function setValue ( $ pValue ) { if ( is_array ( $ pValue ) ) { $ grouping = - 1 ; foreach ( $ pValue as $ key => $ value ) { if ( ! in_array ( $ key , self :: $ dateTimeGroups ) ) { unset ( $ pValue [ $ key ] ) ; } else { $ grouping = max ( $ grouping , array_search ( $ key , self :: $ dateTimeGroups ) ) ; } } if ( count ( $ pValue ) == 0 ) { throw new PhpSpreadsheetException ( 'Invalid rule value for column AutoFilter Rule.' ) ; } $ this -> setGrouping ( self :: $ dateTimeGroups [ $ grouping ] ) ; } $ this -> value = $ pValue ; return $ this ; }
968	protected function cancelCharge ( ) { $ planCharge = $ this -> shop -> planCharge ( ) ; if ( $ planCharge && ! $ planCharge -> isDeclined ( ) && ! $ planCharge -> isCancelled ( ) ) { $ planCharge -> cancel ( ) ; } }
5618	public function paintHeader ( $ test_name ) { $ this -> sendNoCacheHeaders ( ) ; echo sprintf ( SIMPLETEST_WEBUNIT_HEAD , $ test_name , $ this -> path . 'js/' , $ this -> path . 'js/' , $ this -> path . 'css/' , $ this -> _getCss ( ) , $ test_name , $ this -> path . 'img/' ) ; flush ( ) ; }
10554	public static function handleUnknownHost ( URL $ webroot , URL $ request , array $ sites , Dictionary $ cfg ) { $ on_unknown = strtoupper ( $ cfg -> dget ( 'unknown_host_policy' , "IGNORE" ) ) ; $ best_matching = self :: findBestMatching ( $ webroot , $ sites ) ; if ( $ on_unknown === "ERROR" || ( $ best_matching === null && $ on_unknown === "REDIRECT" ) ) return null ; if ( $ on_unknown === "REDIRECT" ) { $ redir = $ best_matching -> URL ( $ request -> path ) ; return $ redir ; } $ url = new URL ( $ webroot ) ; $ url -> fragment = null ; $ url -> query = null ; $ lang = $ cfg -> dget ( 'default_language' , 'en' ) ; $ vhost = new VirtualHost ( $ url , $ lang ) ; if ( $ best_matching === null ) { $ site = new Site ( ) ; $ site -> addVirtualHost ( $ vhost ) ; } else $ best_matching -> getSite ( ) -> addVirtualHost ( $ vhost ) ; return $ vhost ; }
2404	public function asset ( $ path , $ packageName = null ) { $ url = System :: getContainer ( ) -> get ( 'assets.packages' ) -> getUrl ( $ path , $ packageName ) ; return ltrim ( $ url , '/' ) ; }
56	public function update ( PackageInterface $ initial , PackageInterface $ target , $ targetDir ) { $ downloader = $ this -> getDownloaderForInstalledPackage ( $ initial ) ; if ( ! $ downloader ) { return ; } $ installationSource = $ initial -> getInstallationSource ( ) ; if ( 'dist' === $ installationSource ) { $ initialType = $ initial -> getDistType ( ) ; $ targetType = $ target -> getDistType ( ) ; } else { $ initialType = $ initial -> getSourceType ( ) ; $ targetType = $ target -> getSourceType ( ) ; } if ( $ target -> isDev ( ) && 'dist' === $ installationSource ) { $ downloader -> remove ( $ initial , $ targetDir ) ; $ this -> download ( $ target , $ targetDir ) ; return ; } if ( $ initialType === $ targetType ) { $ target -> setInstallationSource ( $ installationSource ) ; try { $ downloader -> update ( $ initial , $ target , $ targetDir ) ; return ; } catch ( \ RuntimeException $ e ) { if ( ! $ this -> io -> isInteractive ( ) ) { throw $ e ; } $ this -> io -> writeError ( '<error> Update failed (' . $ e -> getMessage ( ) . ')</error>' ) ; if ( ! $ this -> io -> askConfirmation ( ' Would you like to try reinstalling the package instead [<comment>yes</comment>]? ' , true ) ) { throw $ e ; } } } $ downloader -> remove ( $ initial , $ targetDir ) ; $ this -> download ( $ target , $ targetDir , 'source' === $ installationSource ) ; }
6843	public function call ( Closure $ c , $ params = array ( ) ) { $ ref = new ReflectionFunction ( $ c ) ; $ params_need = $ ref -> getParameters ( ) ; $ args = $ this -> apply ( $ params_need , $ params ) ; return call_user_func_array ( $ c , $ args ) ; }
7240	private function resolveClassAndCreateObject ( $ type , $ subject ) { foreach ( $ this -> classes [ $ type ] as $ source => $ target ) { if ( $ subject instanceof $ source ) { return new $ target ; } } throw new InvalidArgumentException ( 'Unsupported object class.' ) ; }
5295	protected function execute ( InputInterface $ input , OutputInterface $ output ) { $ fontFile = realpath ( $ input -> getArgument ( 'font-file' ) ) ; if ( $ fontFile === false || ! file_exists ( $ fontFile ) ) { throw new \ InvalidArgumentException ( '"' . $ input -> getArgument ( 'font-file' ) . '" does not exist' ) ; } $ outputDirectory = realpath ( $ input -> getArgument ( 'output-directory' ) ) ; if ( $ outputDirectory === false || ! file_exists ( $ outputDirectory ) || ! is_dir ( $ outputDirectory ) ) { throw new \ InvalidArgumentException ( '"' . $ input -> getArgument ( 'output-directory' ) . '" is no directory' ) ; } $ generator = new IconFontGenerator ; $ output -> writeln ( 'reading font file from "' . $ fontFile . '" ...' ) ; $ generator -> generateFromFont ( new Font ( array ( ) , file_get_contents ( $ fontFile ) ) ) ; $ output -> writeln ( 'writing SVG files to "' . $ outputDirectory . '" ...' ) ; $ generator -> saveGlyphsToDir ( $ outputDirectory ) ; $ output -> getFormatter ( ) -> setStyle ( 'success' , new OutputFormatterStyle ( null , null , array ( 'bold' , 'reverse' ) ) ) ; $ output -> writeln ( '<success>created SVG files successfully</success>' ) ; }
2600	public function peek ( ) { if ( isset ( $ this -> tokens [ $ this -> position + $ this -> peek ] ) ) { return $ this -> tokens [ $ this -> position + $ this -> peek ++ ] ; } else { return null ; } }
10407	private function save ( Pair $ pair ) { $ this -> manager -> persist ( $ pair ) ; $ this -> manager -> commit ( ) ; $ this -> manager -> refresh ( ) ; }
9162	private function adjustNumbytes ( $ numBytes ) : int { if ( isset ( $ this -> headers [ 'Content-Length' ] ) ) { $ numBytes = intval ( $ this -> headers [ 'Content-Length' ] ) ; } return $ numBytes ; }
5383	public function isValue ( $ compare ) { $ compare = trim ( $ compare ) ; if ( trim ( $ this -> getValue ( ) ) == $ compare ) { return true ; } return trim ( strip_tags ( $ this -> getContent ( ) ) ) == $ compare ; }
3008	public function getAttribute ( $ key ) { if ( ! isset ( $ this -> attributes [ $ key ] ) ) { return false ; } return $ this -> attributes [ $ key ] ; }
8041	public function formatEventsToJson ( array $ calendarEvents ) { $ array = [ ] ; foreach ( $ calendarEvents as $ event ) { $ start = $ this -> carbon -> copy ( ) -> setTimestamp ( strtotime ( $ event -> start ) ) -> toIso8601String ( ) ; $ end = $ this -> carbon -> copy ( ) -> setTimestamp ( strtotime ( $ event -> end ) ) -> toIso8601String ( ) ; $ allDay = $ event -> all_day == 1 ; $ data = [ 'title' => $ event -> title , 'description' => $ event -> description , 'start' => $ start , 'end' => $ end , 'allDay' => $ allDay , 'borderColor' => $ event -> border_color , 'textColor' => $ event -> text_color , 'backgroundColor' => $ event -> background_color , ] ; $ array [ ] = $ data ; if ( $ event -> calendarEventRepeatDates ( ) -> count ( ) > 0 ) { foreach ( $ event -> calendarEventRepeatDates ( ) -> get ( ) as $ repeatDate ) { $ start = $ this -> carbon -> copy ( ) -> setTimestamp ( strtotime ( $ repeatDate -> start ) ) -> toIso8601String ( ) ; $ end = $ this -> carbon -> copy ( ) -> setTimestamp ( strtotime ( $ repeatDate -> end ) ) -> toIso8601String ( ) ; $ data [ 'start' ] = $ start ; $ data [ 'end' ] = $ end ; $ array [ ] = $ data ; } } } return $ array ; }
8388	public function addInnerJoin ( $ table , $ on ) { $ this -> innerJoins [ ] = array ( 'table' => $ table , 'on' => ( $ on instanceof Condition ? $ on : new Condition ( $ on ) ) ) ; return $ this ; }
9190	public function render ( array $ classes = [ ] , $ autoEscape = null ) { $ divOpen = '<div class="' . $ this -> divClass . '">' ; $ divClose = '</div>' ; $ hasMessages = false ; foreach ( $ this -> classes as $ namespace => $ namespaceClasses ) { $ namespaceClasses = ArrayUtils :: merge ( $ namespaceClasses , $ classes ) ; if ( $ this -> getFlashMessengerHelper ( ) -> getPluginFlashMessenger ( ) -> hasCurrentMessages ( $ namespace ) ) { $ hasMessages = true ; $ divOpen .= $ this -> getFlashMessengerHelper ( ) -> renderCurrent ( $ namespace , $ namespaceClasses , $ autoEscape ) ; $ this -> getFlashMessengerHelper ( ) -> getPluginFlashMessenger ( ) -> clearCurrentMessagesFromNamespace ( $ namespace ) ; } elseif ( $ this -> getFlashMessengerHelper ( ) -> getPluginFlashMessenger ( ) -> hasMessages ( $ namespace ) ) { $ hasMessages = true ; $ divOpen .= $ this -> getFlashMessengerHelper ( ) -> render ( $ namespace , $ namespaceClasses , $ autoEscape ) ; } } return $ hasMessages ? $ divOpen . $ divClose : '' ; }
1611	private function _createDocument ( $ withUrlSet = true ) { $ document = new \ DOMDocument ( '1.0' , 'utf-8' ) ; if ( \ Craft :: $ app -> config -> general -> devMode ) $ document -> formatOutput = true ; if ( $ withUrlSet ) { $ urlSet = $ document -> createElement ( 'urlset' ) ; $ urlSet -> setAttribute ( 'xmlns' , 'http://www.sitemaps.org/schemas/sitemap/0.9' ) ; $ urlSet -> setAttribute ( 'xmlns:xhtml' , 'http://www.w3.org/1999/xhtml' ) ; $ document -> appendChild ( $ urlSet ) ; $ this -> _urlSet = $ urlSet ; } $ this -> _document = $ document ; }
10658	private function _uxsortmRec ( ArrayObject $ a , array $ sortFuncs , $ depth = 0 , $ sortMode = '' ) { $ goOn = ( count ( $ sortFuncs ) > $ depth + 1 ) ; $ it = $ a -> getIterator ( ) ; while ( $ it -> valid ( ) ) { if ( null !== $ sortFuncs [ $ depth ] ) { if ( $ sortMode == 'a' ) { $ it -> current ( ) -> uasort ( $ sortFuncs [ $ depth ] ) ; } else if ( $ sortMode == 'k' ) { $ it -> current ( ) -> uksort ( $ sortFuncs [ $ depth ] ) ; } else { $ it -> current ( ) -> usort ( $ sortFuncs [ $ depth ] ) ; } } if ( $ goOn ) { $ this -> _uxsortmRec ( $ it -> current ( ) , $ sortFuncs , $ depth + 1 , $ sortMode ) ; } $ it -> next ( ) ; } }
540	protected function addPaginationHeaders ( $ pagination ) { $ links = [ ] ; foreach ( $ pagination -> getLinks ( true ) as $ rel => $ url ) { $ links [ ] = "<$url>; rel=$rel" ; } $ this -> response -> getHeaders ( ) -> set ( $ this -> totalCountHeader , $ pagination -> totalCount ) -> set ( $ this -> pageCountHeader , $ pagination -> getPageCount ( ) ) -> set ( $ this -> currentPageHeader , $ pagination -> getPage ( ) + 1 ) -> set ( $ this -> perPageHeader , $ pagination -> pageSize ) -> set ( 'Link' , implode ( ', ' , $ links ) ) ; }
2843	public function getBlockTreeHtml ( ) { $ content = '' ; $ rootNodes = $ this -> getBlocksAsTree ( ) ; foreach ( $ rootNodes as $ rootNode ) { $ content .= $ this -> renderTreeNode ( $ rootNode ) ; } return $ content ; }
10181	public function add ( $ pCoord , Cell $ cell ) { if ( $ pCoord !== $ this -> currentCoordinate ) { $ this -> storeCurrentCell ( ) ; } $ this -> index [ $ pCoord ] = true ; $ this -> currentCoordinate = $ pCoord ; $ this -> currentCell = $ cell ; $ this -> currentCellIsDirty = true ; return $ cell ; }
7234	protected function assertItemClass ( Common \ SaleItemInterface $ child ) { if ( ! $ child instanceof Model \ CartItemInterface ) { throw new InvalidArgumentException ( "Expected instance of " . Model \ CartItemInterface :: class ) ; } }
2870	public function getExtensionStatus ( ) { $ status = array ( ) ; $ extensions = $ this -> getExtensionRequirements ( ) ; foreach ( $ extensions as $ extension ) { $ status [ $ extension ] = extension_loaded ( $ extension ) ; } return $ status ; }
10870	public function verifyHash ( string $ password , string $ hash ) : bool { return Passwords :: verify ( $ password , $ hash ) ; }
3875	public function addPages ( $ pages , $ rootPage = null , $ fromSiteMap = false , $ language = null ) { $ this -> foundPages = $ pages ; unset ( $ pages ) ; foreach ( $ this -> getConfigs ( ) as $ config ) { if ( ! $ config [ 'published' ] ) { continue ; } $ this -> getMetaModelsPages ( $ config , $ rootPage , $ language ) ; } asort ( $ this -> foundPages ) ; return $ this -> foundPages ; }
8513	public function listInboundShipments ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_ListInboundShipmentsRequest ) ) { $ request = new FBAInboundServiceMWS_Model_ListInboundShipmentsRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListInboundShipments' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_ListInboundShipmentsResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
348	public static function cssStyleFromArray ( array $ style ) { $ result = '' ; foreach ( $ style as $ name => $ value ) { $ result .= "$name: $value; " ; } return $ result === '' ? null : rtrim ( $ result ) ; }
9542	public function runSyncAction ( $ syncActionBaseUrl , $ component , $ action , array $ configData ) { $ uriParts = [ ] ; if ( $ this -> super ) { $ uriParts [ ] = $ this -> super ; } $ uriParts [ ] = $ component ; $ uriParts [ ] = 'action' ; $ uriParts [ ] = $ action ; $ uri = rtrim ( $ syncActionBaseUrl , '/' ) . '/' . implode ( '/' , $ uriParts ) ; $ body = [ 'configData' => $ configData , ] ; try { $ request = new Request ( 'POST' , $ uri , [ ] , json_encode ( $ body ) ) ; $ response = $ this -> guzzle -> send ( $ request ) ; } catch ( RequestException $ e ) { throw new ClientException ( $ e -> getMessage ( ) , 0 , $ e ) ; } return $ this -> decodeResponse ( $ response ) ; }
11543	public function changePassword ( $ data ) { if ( ! ( $ user = $ this -> hydrate ( $ data , $ this -> getChangePasswordForm ( ) ) ) ) { return ; } $ eventManager = $ this -> getEventManager ( ) ; $ eventManager -> trigger ( __METHOD__ , $ this , $ user ) ; $ password = $ user -> getPassword ( ) ; $ passwordService = $ this -> getMapper ( ) -> getPasswordService ( ) ; $ user -> setPassword ( $ passwordService -> create ( $ password ) ) ; $ this -> getMapper ( ) -> update ( $ user ) -> save ( ) ; $ eventManager -> trigger ( __METHOD__ . '.post' , $ this , $ user ) ; return $ user ; }
4066	public function handle ( BuildWidgetEvent $ event ) { $ environment = $ event -> getEnvironment ( ) ; if ( ( $ environment -> getDataDefinition ( ) -> getName ( ) !== 'tl_metamodel_dcasetting' ) || ( $ event -> getProperty ( ) -> getName ( ) !== 'mandatory' ) || ( null === $ event -> getModel ( ) -> getId ( ) ) ) { return ; } $ model = $ event -> getModel ( ) ; $ metaModel = $ this -> getMetaModelFromModel ( $ model ) ; $ attribute = $ metaModel -> getAttributeById ( $ model -> getProperty ( 'attr_id' ) ) ; if ( null === $ attribute ) { return ; } if ( $ attribute -> get ( 'isunique' ) ) { Message :: addInfo ( $ this -> translator -> trans ( 'tl_metamodel_dcasetting.mandatory_for_unique_attr' , [ ] , 'contao_tl_metamodel_dcasetting' ) ) ; $ extra = $ event -> getProperty ( ) -> getExtra ( ) ; $ extra [ 'disabled' ] = true ; $ event -> getProperty ( ) -> setExtra ( $ extra ) ; $ model -> setProperty ( 'mandatory' , true ) ; } }
10522	protected function quoteIndex ( array $ cols ) { $ q = [ ] ; foreach ( $ cols as $ col ) { $ q [ ] = $ this -> quoteLeading ( $ col ) ; } return $ q ; }
190	private function loadTableColumnsInfo ( $ tableName ) { $ tableColumns = $ this -> db -> createCommand ( 'PRAGMA TABLE_INFO (' . $ this -> quoteValue ( $ tableName ) . ')' ) -> queryAll ( ) ; $ tableColumns = $ this -> normalizePdoRowKeyCase ( $ tableColumns , true ) ; return ArrayHelper :: index ( $ tableColumns , 'cid' ) ; }
4507	public function created ( JWTCreatedEvent $ event ) { $ request = $ this -> requestStack -> getCurrentRequest ( ) ; $ data = $ event -> getData ( ) ; $ this -> accessor -> setValue ( $ data , $ this -> property , $ request -> getClientIp ( ) ) ; $ event -> setData ( $ data ) ; }
8323	public function addPingback ( $ url ) { $ response = $ this -> getHttpClient ( ) -> request ( 'GET' , "/res.php?key={$this->apiKey}&action=add_pingback&addr={$url}" ) ; $ responseText = $ response -> getBody ( ) -> __toString ( ) ; if ( $ responseText === self :: STATUS_OK ) { return true ; } throw new ErrorResponseException ( $ this -> getErrorMessage ( $ responseText ) ? : $ responseText , $ this -> getErrorCode ( $ responseText ) ? : 0 ) ; }
733	public function toArray ( array $ fields = [ ] , array $ expand = [ ] , $ recursive = true ) { $ data = [ ] ; foreach ( $ this -> resolveFields ( $ fields , $ expand ) as $ field => $ definition ) { $ attribute = is_string ( $ definition ) ? $ this -> $ definition : $ definition ( $ this , $ field ) ; if ( $ recursive ) { $ nestedFields = $ this -> extractFieldsFor ( $ fields , $ field ) ; $ nestedExpand = $ this -> extractFieldsFor ( $ expand , $ field ) ; if ( $ attribute instanceof Arrayable ) { $ attribute = $ attribute -> toArray ( $ nestedFields , $ nestedExpand ) ; } elseif ( is_array ( $ attribute ) ) { $ attribute = array_map ( function ( $ item ) use ( $ nestedFields , $ nestedExpand ) { if ( $ item instanceof Arrayable ) { return $ item -> toArray ( $ nestedFields , $ nestedExpand ) ; } return $ item ; } , $ attribute ) ; } } $ data [ $ field ] = $ attribute ; } if ( $ this instanceof Linkable ) { $ data [ '_links' ] = Link :: serialize ( $ this -> getLinks ( ) ) ; } return $ recursive ? ArrayHelper :: toArray ( $ data ) : $ data ; }
5782	public function routeGetDelete ( Request $ request , Response $ response , $ args ) { if ( ! $ this -> authorization -> isAuthorized ( ROLES_DELETE_RESOURCE ) ) { throw new \ Exception ( 'No permission.' ) ; } $ primaryKey = $ args [ ROUTEARG_PRIMARY_KEY ] ; $ tableName = $ this -> tableMapper -> getFormalTableName ( false ) ; $ primaryKeyColumnName = $ this -> tableMapper -> getPrimaryKeyColumnName ( ) ; try { $ this -> tableMapper -> deleteByPrimaryKey ( $ primaryKey ) ; $ this -> events -> insertInfo ( EVENT_ROLE_DELETE , [ $ primaryKeyColumnName => $ primaryKey ] ) ; SlimPostgres :: setAdminNotice ( "Deleted $tableName $primaryKey" ) ; } catch ( Exceptions \ UnallowedActionException $ e ) { $ this -> events -> insertWarning ( EVENT_UNALLOWED_ACTION , [ 'error' => $ e -> getMessage ( ) ] ) ; SlimPostgres :: setAdminNotice ( $ e -> getMessage ( ) , 'failure' ) ; } catch ( Exceptions \ QueryResultsNotFoundException $ e ) { define ( 'EVENT_QUERY_NO_RESULTS' , 'Query Results Not Found' ) ; $ this -> events -> insertWarning ( EVENT_QUERY_NO_RESULTS , $ e -> getMessage ( ) ) ; SlimPostgres :: setAdminNotice ( $ e -> getMessage ( ) , 'failure' ) ; } catch ( Exceptions \ QueryFailureException $ e ) { $ this -> events -> insertError ( EVENT_QUERY_FAIL , [ 'error' => $ e -> getMessage ( ) ] ) ; SlimPostgres :: setAdminNotice ( 'Delete Failed' , 'failure' ) ; } return $ response -> withRedirect ( $ this -> router -> pathFor ( SlimPostgres :: getRouteName ( true , $ this -> routePrefix , 'index' ) ) ) ; }
1808	public function getContentElements ( ) { $ groups = array ( ) ; foreach ( $ GLOBALS [ 'TL_CTE' ] as $ k => $ v ) { foreach ( array_keys ( $ v ) as $ kk ) { $ groups [ $ k ] [ ] = $ kk ; } } return $ groups ; }
10264	public function getBank ( ) { $ bank_account = new Entities \ BankAccount ; $ bank_account -> type = $ this -> fromArray ( [ 'Checking' , 'Savings' ] ) ; $ bank_account -> name = $ this -> fromArray ( [ 'First National' , 'Arvest' , 'Regions' , 'Metropolitan' , 'Wells Fargo' ] ) ; $ bank_account -> account = $ this -> getInteger ( '1000' , '999999999' ) ; $ bank_account -> routing = $ this -> getBankNumber ( 'Routing' ) ; return $ bank_account ; }
1796	private function addIndexRoute ( RouteCollection $ routes , array $ defaults ) : void { $ route = new Route ( '/' , $ defaults ) ; $ this -> addLocaleToRoute ( $ route ) ; $ routes -> add ( 'contao_index' , $ route ) ; }
1179	protected function getValidationData ( array $ rules , array $ customAttributes = [ ] ) { $ attributes = array_filter ( array_keys ( $ rules ) , function ( $ attribute ) { return $ attribute !== '' && mb_strpos ( $ attribute , '*' ) !== false ; } ) ; $ attributes = array_merge ( array_keys ( $ customAttributes ) , $ attributes ) ; $ data = array_reduce ( $ attributes , function ( $ data , $ attribute ) { Arr :: set ( $ data , $ attribute , true ) ; return $ data ; } , [ ] ) ; return $ data ; }
1200	public function get ( $ menu , array $ path = array ( ) , array $ options = array ( ) ) { if ( ! $ menu instanceof ItemInterface ) { if ( null === $ this -> menuProvider ) { throw new \ BadMethodCallException ( 'A menu provider must be set to retrieve a menu' ) ; } $ menuName = $ menu ; $ menu = $ this -> menuProvider -> get ( $ menuName , $ options ) ; if ( ! $ menu instanceof ItemInterface ) { throw new \ LogicException ( sprintf ( 'The menu "%s" exists, but is not a valid menu item object. Check where you created the menu to be sure it returns an ItemInterface object.' , $ menuName ) ) ; } } foreach ( $ path as $ child ) { $ menu = $ menu -> getChild ( $ child ) ; if ( null === $ menu ) { throw new \ InvalidArgumentException ( sprintf ( 'The menu has no child named "%s"' , $ child ) ) ; } } return $ menu ; }
8935	public function add ( $ name , $ template ) { if ( array_key_exists ( $ name , $ this -> templates ) ) { throw new \ InvalidArgumentException ( 'Template already exists.' ) ; } $ this -> templates [ $ name ] = $ template ; }
9406	protected function approach ( $ middleware ) { if ( $ middleware instanceof \ Closure ) { $ object = new \ ReflectionFunction ( $ middleware ) ; return count ( $ object -> getParameters ( ) ) === 2 ; } $ class = ( string ) get_class ( $ middleware ) ; $ object = new \ ReflectionMethod ( $ class , '__invoke' ) ; return count ( $ object -> getParameters ( ) ) === 2 ; }
8706	public function setLastFolderID ( $ folderID ) { $ request = Controller :: curr ( ) -> getRequest ( ) ; $ session = $ request -> getSession ( ) ; $ session -> set ( get_class ( ) . '.FolderID' , $ folderID ) ; }
7913	protected function renderInput ( ) { return $ this -> hasModel ( ) ? Html :: activeCheckbox ( $ this -> model , $ this -> attribute , $ this -> options ) : Html :: checkbox ( $ this -> name , $ this -> checked , $ this -> options ) ; }
10177	public function cloneCellCollection ( Worksheet $ parent ) { $ this -> storeCurrentCell ( ) ; $ newCollection = clone $ this ; $ newCollection -> parent = $ parent ; if ( ( $ newCollection -> currentCell !== null ) && ( is_object ( $ newCollection -> currentCell ) ) ) { $ newCollection -> currentCell -> attach ( $ this ) ; } $ oldKeys = $ newCollection -> getAllCacheKeys ( ) ; $ oldValues = $ newCollection -> cache -> getMultiple ( $ oldKeys ) ; $ newValues = [ ] ; $ oldCachePrefix = $ newCollection -> cachePrefix ; $ newCollection -> cachePrefix = $ newCollection -> getUniqueID ( ) ; foreach ( $ oldValues as $ oldKey => $ value ) { $ newValues [ str_replace ( $ oldCachePrefix , $ newCollection -> cachePrefix , $ oldKey ) ] = clone $ value ; } $ stored = $ newCollection -> cache -> setMultiple ( $ newValues ) ; if ( ! $ stored ) { $ newCollection -> __destruct ( ) ; throw new PhpSpreadsheetException ( 'Failed to copy cells in cache' ) ; } return $ newCollection ; }
998	public function getTypeMap ( ) { if ( ! $ this -> fullyLoaded ) { $ this -> resolvedTypes = $ this -> collectAllTypes ( ) ; $ this -> fullyLoaded = true ; } return $ this -> resolvedTypes ; }
7484	public function endsWith ( $ string ) { $ string = static :: convertString ( $ string , $ this -> encoding ) ; return $ string === $ this -> substring ( $ this -> length ( ) - mb_strlen ( $ string , $ this -> encoding ) ) -> __toString ( ) ; }
40	protected function fetchRootIdentifier ( ) { if ( $ this -> repoData ) { return ; } $ repoDataUrl = $ this -> getApiUrl ( ) . '/repos/' . $ this -> owner . '/' . $ this -> repository ; $ this -> repoData = JsonFile :: parseJson ( $ this -> getContents ( $ repoDataUrl , true ) , $ repoDataUrl ) ; if ( null === $ this -> repoData && null !== $ this -> gitDriver ) { return ; } $ this -> owner = $ this -> repoData [ 'owner' ] [ 'login' ] ; $ this -> repository = $ this -> repoData [ 'name' ] ; $ this -> isPrivate = ! empty ( $ this -> repoData [ 'private' ] ) ; if ( isset ( $ this -> repoData [ 'default_branch' ] ) ) { $ this -> rootIdentifier = $ this -> repoData [ 'default_branch' ] ; } elseif ( isset ( $ this -> repoData [ 'master_branch' ] ) ) { $ this -> rootIdentifier = $ this -> repoData [ 'master_branch' ] ; } else { $ this -> rootIdentifier = 'master' ; } $ this -> hasIssues = ! empty ( $ this -> repoData [ 'has_issues' ] ) ; }
12011	private function addBlockSection ( ArrayNodeDefinition $ rootNode ) { $ rootNode -> fixXmlConfig ( 'block_theme' ) -> children ( ) -> arrayNode ( 'block_themes' ) -> prototype ( 'scalar' ) -> end ( ) -> example ( [ '@App/block.html.twig' ] ) -> end ( ) -> end ( ) ; }
9459	public function getByIds ( array $ ids , $ page = 1 , $ per_page = 100 ) { return $ this -> getCollection ( 'tickets/show_many.json?ids=' . implode ( ',' , $ ids ) , 'tickets' , $ page , $ per_page ) ; }
5908	public function listUsers ( $ includeDeleted = false , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'includeDeleted' => $ includeDeleted ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/accounts/users' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new User ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
10414	public function createTable ( $ connection = null ) { $ connection = $ connection ? : $ this -> connection ; $ schemaManager = $ connection -> getSchemaManager ( ) ; if ( $ schemaManager -> tablesExist ( [ $ this -> tableName ] ) ) { return null ; } $ table = new Table ( $ this -> tableName ) ; $ this -> buildTable ( $ table ) ; $ schemaManager -> createTable ( $ table ) ; return true ; }
743	private function initializeEventHandlers ( ) { $ this -> owner -> on ( Widget :: EVENT_BEFORE_RUN , [ $ this , 'beforeRun' ] ) ; $ this -> owner -> on ( Widget :: EVENT_AFTER_RUN , [ $ this , 'afterRun' ] ) ; }
72	public function authorizeOAuth ( $ originUrl ) { if ( $ originUrl !== 'bitbucket.org' ) { return false ; } if ( 0 === $ this -> process -> execute ( 'git config bitbucket.accesstoken' , $ output ) ) { $ this -> io -> setAuthentication ( $ originUrl , 'x-token-auth' , trim ( $ output ) ) ; return true ; } return false ; }
12917	public function sumValor ( ) { $ tableGateway = new TableGateway ( $ this -> tableName , $ this -> dbAdapter ) ; $ sql = $ tableGateway -> getSql ( ) ; $ select = $ sql -> select ( ) -> columns ( array ( 'sum' => new Expression ( 'SUM(valor)' ) ) ) ; return $ tableGateway -> selectWith ( $ select ) -> current ( ) ; }
4333	private static function buildAttribBoolVal ( $ key , $ value = true ) { if ( $ key == 'autocomplete' ) { $ value = $ value ? 'on' : 'off' ; } elseif ( $ key == 'spellcheck' ) { $ value = $ value ? 'true' : 'false' ; } elseif ( $ key == 'translate' ) { $ value = $ value ? 'yes' : 'no' ; } elseif ( $ value ) { $ value = $ key ; } else { $ value = null ; } return $ value ; }
9974	public function setBuiltInFormatCode ( $ pValue ) { if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'formatCode' => self :: builtInFormatCode ( $ pValue ) ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> builtInFormatCode = $ pValue ; $ this -> formatCode = self :: builtInFormatCode ( $ pValue ) ; } return $ this ; }
5842	public function getAdditionalFields ( array & $ taskInfo , $ task , \ TYPO3 \ CMS \ Scheduler \ Controller \ SchedulerModuleController $ parentObject ) { $ editCommand = version_compare ( TYPO3_branch , '9.5' , '>=' ) ? $ parentObject -> getCurrentAction ( ) === Action :: EDIT : $ parentObject -> CMD === 'edit' ; if ( ! isset ( $ taskInfo [ 'scheduler_batchResize_directories' ] ) ) { $ taskInfo [ 'scheduler_batchResize_directories' ] = $ this -> defaultDirectories ; if ( $ editCommand ) { $ taskInfo [ 'scheduler_batchResize_directories' ] = $ task -> directories ; } } if ( ! isset ( $ taskInfo [ 'scheduler_batchResize_excludeDirectories' ] ) ) { $ taskInfo [ 'scheduler_batchResize_excludeDirectories' ] = $ this -> defaultExcludeDirectories ; if ( $ editCommand ) { $ taskInfo [ 'scheduler_batchResize_excludeDirectories' ] = $ task -> excludeDirectories ; } } $ additionalFields = [ ] ; $ fieldName = 'tx_scheduler[scheduler_batchResize_directories]' ; $ fieldId = 'scheduler_batchResize_directories' ; $ fieldValue = trim ( $ taskInfo [ 'scheduler_batchResize_directories' ] ) ; $ fieldHtml = '<textarea class="form-control" rows="4" name="' . $ fieldName . '" id="' . $ fieldId . '">' . htmlspecialchars ( $ fieldValue ) . '</textarea>' ; $ additionalFields [ $ fieldId ] = [ 'code' => $ fieldHtml , 'label' => 'LLL:EXT:image_autoresize/Resources/Private/Language/locallang_mod.xlf:label.batchResize.directories' , ] ; $ fieldName = 'tx_scheduler[scheduler_batchResize_excludeDirectories]' ; $ fieldId = 'scheduler_batchResize_excludeDirectories' ; $ fieldValue = trim ( $ taskInfo [ 'scheduler_batchResize_excludeDirectories' ] ) ; $ fieldHtml = '<textarea class="form-control" rows="4" name="' . $ fieldName . '" id="' . $ fieldId . '">' . htmlspecialchars ( $ fieldValue ) . '</textarea>' ; $ additionalFields [ $ fieldId ] = [ 'code' => $ fieldHtml , 'label' => 'LLL:EXT:image_autoresize/Resources/Private/Language/locallang_mod.xlf:label.batchResize.excludeDirectories' , ] ; return $ additionalFields ; }
8447	public function sendRequest ( $ endpoint , array $ parameters , IncomingMessage $ matchingMessage ) { $ this -> connection -> post ( $ endpoint , $ parameters , true ) ; return Response :: create ( $ this -> connection -> getLastBody ( ) , $ this -> connection -> getLastHttpCode ( ) ) ; }
4310	public function getChannels ( $ allDescendants = false ) { if ( $ allDescendants ) { $ channels = array ( ) ; foreach ( $ this -> channels as $ channel ) { $ channels = \ array_merge ( $ channels , array ( $ channel -> getCfg ( 'channel' ) => $ channel ) , $ channel -> getChannels ( true ) ) ; } return $ channels ; } return $ this -> channels ; }
7423	protected function registerWidget ( $ name = null , $ id = null ) { if ( $ name === null ) { $ name = $ this -> getDefaultJsWidgetName ( ) ; } $ this -> _registerBundle ( ) ; if ( ! $ this -> isAjaxCrud && $ this -> getUpdateUrl ( ) ) { if ( $ id === null ) { $ id = $ this -> options [ 'id' ] ; } $ options = empty ( $ this -> clientOptions ) ? '' : Json :: htmlEncode ( [ 'updateUrl' => Url :: to ( $ this -> getUpdateUrl ( ) ) ] ) ; $ js = "jQuery('#$id').$name($options);" ; $ this -> getView ( ) -> registerJs ( $ js ) ; } }
2200	public static function findPublishedByPidAndColumn ( $ intPid , $ strColumn , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = array ( "$t.pid=? AND $t.inColumn=?" ) ; $ arrValues = array ( $ intPid , $ strColumn ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.sorting" ; } return static :: findBy ( $ arrColumns , $ arrValues , $ arrOptions ) ; }
9833	public function setWorkbookPassword ( $ pValue , $ pAlreadyHashed = false ) { if ( ! $ pAlreadyHashed ) { $ pValue = PasswordHasher :: hashPassword ( $ pValue ) ; } $ this -> workbookPassword = $ pValue ; return $ this ; }
2477	public function request ( $ method , Endpoint $ endpoint , $ path , Message $ message = null ) { $ message = $ message ? : new Message ( ) ; $ i = 0 ; do { ++ $ i ; if ( $ responseMessage = $ this -> requestStream ( $ method , $ endpoint , $ path , $ message ) ) { return $ responseMessage ; } usleep ( $ this -> retryWaitMs * 1000 ) ; } while ( $ i < $ this -> connectionRetry ) ; if ( $ this -> logger instanceof LoggerInterface ) { $ this -> logger -> error ( sprintf ( 'Connection to %s failed, attempted %d times' , $ endpoint -> getURL ( ) , $ this -> connectionRetry ) ) ; } throw new ConnectionException ( $ endpoint -> getURL ( ) , $ path , $ method ) ; }
6186	public function renderInclude ( $ name , $ path = null ) { $ twigConfig = Config :: load ( 'twig' ) ; $ pathFile = pathFile ( $ name ) ; $ folder = $ pathFile [ 0 ] ; $ name = $ pathFile [ 1 ] ; $ path = $ twigConfig -> get ( 'setTemplateDir' ) . DIRECTORY_SEPARATOR . $ folder . $ name . $ twigConfig -> get ( 'fileExtension' , '.twig' ) ; try { if ( ! is_file ( $ path ) ) { throw new ViewException ( 'Can not open template ' . $ name . ' in: ' . $ path ) ; } $ renderInclude = $ this -> twig -> render ( $ name , $ this -> assign ) ; } catch ( ViewException $ e ) { echo $ e -> getMessage ( ) . '<br /> File: ' . $ e -> getFile ( ) . '<br /> Code line: ' . $ e -> getLine ( ) . '<br /> Trace: ' . $ e -> getTraceAsString ( ) ; exit ( ) ; } return $ renderInclude ; }
2092	protected function initializeSession ( $ formId ) { if ( Input :: post ( 'FORM_SUBMIT' ) != $ formId ) { return ; } $ arrMessageBox = array ( 'TL_ERROR' , 'TL_CONFIRM' , 'TL_INFO' ) ; $ _SESSION [ 'FORM_DATA' ] = \ is_array ( $ _SESSION [ 'FORM_DATA' ] ) ? $ _SESSION [ 'FORM_DATA' ] : array ( ) ; foreach ( $ arrMessageBox as $ tl ) { if ( \ is_array ( $ _SESSION [ $ formId ] [ $ tl ] ) ) { $ _SESSION [ $ formId ] [ $ tl ] = array_unique ( $ _SESSION [ $ formId ] [ $ tl ] ) ; foreach ( $ _SESSION [ $ formId ] [ $ tl ] as $ message ) { $ objTemplate = new FrontendTemplate ( 'form_message' ) ; $ objTemplate -> message = $ message ; $ objTemplate -> class = strtolower ( $ tl ) ; $ this -> Template -> fields .= $ objTemplate -> parse ( ) . "\n" ; } $ _SESSION [ $ formId ] [ $ tl ] = array ( ) ; } } }
10071	public function render ( InputFilter $ inputFilter ) { $ inputFilter -> prepare ( ) ; $ props = $ inputFilter -> getAttributes ( ) ; $ treeBuilder = new TreeBuilder ( $ inputFilter ) ; $ props = array_merge ( $ props , $ treeBuilder -> getTree ( ) ) ; return $ this -> make ( 'widget-form' , $ props ) ; }
6076	public function uploadPreview ( $ fileData , $ id ) { $ parameters = [ 'query' => [ ] , 'multipart' => [ [ 'name' => 'file' , 'contents' => \ GuzzleHttp \ Psr7 \ stream_for ( $ fileData ) , 'filename' => 'preview-file' , ] , ] , 'headers' => null , ] ; $ this -> post ( 'v1/media.json/' . $ id . '/uploadpreview' , $ parameters ) ; }
11516	public function updateMetadata ( SiteConfig $ config , SiteTree $ owner , & $ metadata ) { $ HTML5Favicon = $ config -> HTML5Favicon ( ) ; $ IOSPinicon = $ config -> IOSPinicon ( ) ; $ AndroidPinicon = $ config -> AndroidPinicon ( ) ; $ WindowsPinicon = $ config -> WindowsPinicon ( ) ; if ( $ IOSPinicon -> exists ( ) ) { $ this -> GenerateIOSPinicon ( $ config , $ owner , $ metadata , $ IOSPinicon ) ; } if ( $ HTML5Favicon -> exists ( ) ) { $ this -> GenerateHTML5Favicon ( $ owner , $ metadata , $ HTML5Favicon ) ; } if ( $ AndroidPinicon -> exists ( ) ) { $ this -> GenerateAndroidPinicon ( $ config , $ owner , $ metadata ) ; } if ( $ WindowsPinicon -> exists ( ) ) { $ this -> GenerateWindowsPinicon ( $ config , $ owner , $ metadata , $ WindowsPinicon ) ; } }
5581	public function getLink ( $ label , $ index = 0 ) { $ urls = $ this -> page -> getUrlsByLabel ( $ label ) ; if ( count ( $ urls ) == 0 ) { return false ; } if ( count ( $ urls ) < $ index + 1 ) { return false ; } return $ urls [ $ index ] ; }
6284	protected static function buildHttpClient05 ( LoopInterface $ loop , $ connector = null ) { if ( $ connector instanceof DnsResolver ) { @ trigger_error ( sprintf ( 'Passing a %s to buildHttpClient is deprecated since version 2.1.0 and will be removed in 3.0. If you need no specific behaviour, omit the $dns argument, otherwise pass a %s' , DnsResolver :: class , ConnectorInterface :: class ) , E_USER_DEPRECATED ) ; $ connector = static :: buildConnector ( $ loop , $ connector ) ; } if ( null !== $ connector && ! $ connector instanceof ConnectorInterface ) { throw new \ InvalidArgumentException ( '$connector must be an instance of DnsResolver or ConnectorInterface' ) ; } return new HttpClient ( $ loop , $ connector ) ; }
618	private function parseString ( $ value , & $ i ) { $ isQuoted = $ value [ $ i ] === '"' ; $ stringEndChars = $ isQuoted ? [ '"' ] : [ $ this -> delimiter , '}' ] ; $ result = '' ; $ len = strlen ( $ value ) ; for ( $ i += $ isQuoted ? 1 : 0 ; $ i < $ len ; ++ $ i ) { if ( in_array ( $ value [ $ i ] , [ '\\' , '"' ] , true ) && in_array ( $ value [ $ i + 1 ] , [ $ value [ $ i ] , '"' ] , true ) ) { ++ $ i ; } elseif ( in_array ( $ value [ $ i ] , $ stringEndChars , true ) ) { break ; } $ result .= $ value [ $ i ] ; } $ i -= $ isQuoted ? 0 : 1 ; if ( ! $ isQuoted && $ result === 'NULL' ) { $ result = null ; } return $ result ; }
4811	public function create ( ) { $ language = new ExpressionLanguage ( ) ; foreach ( $ this -> providers as $ provider ) { $ language -> registerProvider ( $ provider ) ; } return $ language ; }
10915	protected function findController ( $ object ) { $ urlargs = $ this -> arguments ; $ arg = $ urlargs -> shift ( ) ; $ controller = $ arg ; if ( ( $ pos = strpos ( $ controller , '.' ) ) !== false ) $ controller = substr ( $ controller , 0 , $ pos ) ; if ( ! method_exists ( $ object , $ controller ) ) { if ( method_exists ( $ object , "index" ) ) { if ( $ controller !== null ) $ urlargs -> unshift ( $ arg ) ; $ controller = "index" ; } else throw new HTTPError ( 404 , "Unknown controller: " . $ controller ) ; } return $ controller ; }
10488	public function run ( \ de \ codenamephp \ platform \ cli \ command \ iCommand $ command ) { if ( $ this -> getDirectory ( ) !== '' && is_dir ( $ this -> getDirectory ( ) ) ) { $ currentDir = getcwd ( ) ; chdir ( $ this -> getDirectory ( ) ) ; } $ returnValue = $ this -> getActualPassthru ( ) -> run ( $ command ) ; if ( isset ( $ currentDir ) ) { chdir ( $ currentDir ) ; } return $ returnValue ; }
2673	public function getSingleAcl ( $ version , $ acl ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/acl/' . $ acl ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: GET ) ; return $ result ; }
1066	private function doTypesConflict ( OutputType $ type1 , OutputType $ type2 ) { if ( $ type1 instanceof ListOfType ) { return $ type2 instanceof ListOfType ? $ this -> doTypesConflict ( $ type1 -> getWrappedType ( ) , $ type2 -> getWrappedType ( ) ) : true ; } if ( $ type2 instanceof ListOfType ) { return $ type1 instanceof ListOfType ? $ this -> doTypesConflict ( $ type1 -> getWrappedType ( ) , $ type2 -> getWrappedType ( ) ) : true ; } if ( $ type1 instanceof NonNull ) { return $ type2 instanceof NonNull ? $ this -> doTypesConflict ( $ type1 -> getWrappedType ( ) , $ type2 -> getWrappedType ( ) ) : true ; } if ( $ type2 instanceof NonNull ) { return $ type1 instanceof NonNull ? $ this -> doTypesConflict ( $ type1 -> getWrappedType ( ) , $ type2 -> getWrappedType ( ) ) : true ; } if ( Type :: isLeafType ( $ type1 ) || Type :: isLeafType ( $ type2 ) ) { return $ type1 !== $ type2 ; } return false ; }
10851	public function executeProcess ( $ command , $ beforeNotice = false , $ afterNotice = false ) : void { $ this -> echo ( 'info' , $ beforeNotice ? ' ' . $ beforeNotice : $ command ) ; $ process = new Process ( $ command , null , null , null , $ this -> option ( 'timeout' ) , null ) ; $ process -> run ( function ( $ type , $ buffer ) { if ( Process :: ERR === $ type ) { $ this -> echo ( 'comment' , $ buffer ) ; } else { $ this -> echo ( 'line' , $ buffer ) ; } } ) ; if ( ! $ process -> isSuccessful ( ) ) { throw new ProcessFailedException ( $ process ) ; } if ( $ this -> progressBar ) { $ this -> progressBar -> advance ( ) ; } if ( $ afterNotice ) { $ this -> echo ( 'info' , $ afterNotice ) ; } }
1115	public function getQualifiedScopedColumns ( ) { if ( ! $ this -> isScoped ( ) ) return $ this -> getScopedColumns ( ) ; $ prefix = $ this -> getTable ( ) . '.' ; return array_map ( function ( $ c ) use ( $ prefix ) { return $ prefix . $ c ; } , $ this -> getScopedColumns ( ) ) ; }
10164	private function readRangeProtection ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; $ offset = 0 ; if ( ! $ this -> readDataOnly ) { $ offset += 12 ; $ isf = self :: getUInt2d ( $ recordData , 12 ) ; if ( $ isf != 2 ) { return ; } $ offset += 2 ; $ offset += 5 ; $ cref = self :: getUInt2d ( $ recordData , 19 ) ; $ offset += 2 ; $ offset += 6 ; $ cellRanges = [ ] ; for ( $ i = 0 ; $ i < $ cref ; ++ $ i ) { try { $ cellRange = $ this -> readBIFF8CellRangeAddressFixed ( substr ( $ recordData , 27 + 8 * $ i , 8 ) ) ; } catch ( PhpSpreadsheetException $ e ) { return ; } $ cellRanges [ ] = $ cellRange ; $ offset += 8 ; } $ rgbFeat = substr ( $ recordData , $ offset ) ; $ offset += 4 ; $ wPassword = self :: getInt4d ( $ recordData , $ offset ) ; $ offset += 4 ; if ( $ cellRanges ) { $ this -> phpSheet -> protectCells ( implode ( ' ' , $ cellRanges ) , strtoupper ( dechex ( $ wPassword ) ) , true ) ; } } }
6482	public function assertNoErrorMessages ( ) { foreach ( $ this -> getMessagesContainers ( 'error' ) as $ element ) { $ text = trim ( $ element -> getText ( ) ) ; if ( '' !== $ text ) { throw new \ RuntimeException ( sprintf ( 'The page "%s" contains following error messages: "%s".' , self :: $ pageUrl , $ text ) ) ; } } foreach ( $ this -> getSession ( ) -> getPage ( ) -> findAll ( 'css' , 'input, select, textarea' ) as $ formElement ) { if ( $ formElement -> hasClass ( 'error' ) ) { throw new \ Exception ( sprintf ( 'Element "#%s" has an error class.' , $ formElement -> getAttribute ( 'id' ) ) ) ; } } }
3120	public function remove ( $ tag , $ target = TimePoint :: TARGET_ALL , $ type = TimePoint :: TYPE_ALL ) { $ tags = is_array ( $ tag ) ? $ tag : [ $ tag ] ; $ removed = 0 ; foreach ( $ this -> points as $ idx => $ point ) { if ( $ point -> match ( $ tags , $ target , $ type ) ) { unset ( $ this -> points [ $ idx ] ) ; $ removed ++ ; } } return $ removed ; }
2737	private function setServiceID ( $ serviceId ) { $ this -> configWriter -> save ( Config :: XML_FASTLY_SERVICE_ID , $ serviceId ) ; $ this -> output -> writeln ( '<info>Service ID updated.</info>' , OutputInterface :: OUTPUT_NORMAL ) ; }
831	private function fixConstructor ( Tokens $ tokens , $ className , $ classStart , $ classEnd ) { $ php4 = $ this -> findFunction ( $ tokens , $ className , $ classStart , $ classEnd ) ; if ( null === $ php4 ) { return ; } if ( ! empty ( $ php4 [ 'modifiers' ] [ T_ABSTRACT ] ) || ! empty ( $ php4 [ 'modifiers' ] [ T_STATIC ] ) ) { return ; } $ php5 = $ this -> findFunction ( $ tokens , '__construct' , $ classStart , $ classEnd ) ; if ( null === $ php5 ) { $ tokens [ $ php4 [ 'nameIndex' ] ] = new Token ( [ T_STRING , '__construct' ] ) ; $ this -> fixInfiniteRecursion ( $ tokens , $ php4 [ 'bodyIndex' ] , $ php4 [ 'endIndex' ] ) ; return ; } list ( $ seq , $ case ) = $ this -> getWrapperMethodSequence ( $ tokens , '__construct' , $ php4 [ 'startIndex' ] , $ php4 [ 'bodyIndex' ] ) ; if ( null !== $ tokens -> findSequence ( $ seq , $ php4 [ 'bodyIndex' ] - 1 , $ php4 [ 'endIndex' ] , $ case ) ) { for ( $ i = $ php4 [ 'startIndex' ] ; $ i <= $ php4 [ 'endIndex' ] ; ++ $ i ) { $ tokens -> clearAt ( $ i ) ; } return ; } list ( $ seq , $ case ) = $ this -> getWrapperMethodSequence ( $ tokens , $ className , $ php4 [ 'startIndex' ] , $ php4 [ 'bodyIndex' ] ) ; if ( null !== $ tokens -> findSequence ( $ seq , $ php5 [ 'bodyIndex' ] - 1 , $ php5 [ 'endIndex' ] , $ case ) ) { for ( $ i = $ php5 [ 'startIndex' ] ; $ i <= $ php5 [ 'endIndex' ] ; ++ $ i ) { $ tokens -> clearAt ( $ i ) ; } $ tokens [ $ php4 [ 'nameIndex' ] ] = new Token ( [ T_STRING , '__construct' ] ) ; } }
2624	private function sendReqToGA ( $ body = '' , $ method = \ Zend_Http_Client :: POST , $ uri = self :: GA_API_ENDPOINT ) { $ reqGAData = ( array ) $ this -> getGAReqData ( ) ; if ( $ body != '' && is_array ( $ body ) && ! empty ( $ body ) ) { $ body = array_merge ( $ reqGAData , $ body ) ; } try { $ client = $ this -> curlFactory -> create ( ) ; $ client -> addOption ( CURLOPT_TIMEOUT , 10 ) ; $ client -> write ( $ method , $ uri , '1.1' , null , http_build_query ( $ body ) ) ; $ response = $ client -> read ( ) ; $ responseCode = \ Zend_Http_Response :: extractCode ( $ response ) ; $ client -> close ( ) ; if ( $ responseCode != '200' ) { throw new LocalizedException ( __ ( 'Return status ' . $ responseCode ) ) ; } return true ; } catch ( \ Exception $ e ) { return false ; } }
10542	public static function createFromApplication ( Application $ app ) { $ dispatch = new static ( $ app -> request , $ app -> resolver , $ app -> config ) ; $ dispatch -> setApplication ( $ app ) ; return $ dispatch ; }
4258	public function addSubscriberInterface ( SubscriberInterface $ interface ) { $ subscribers = $ this -> getInterfaceSubscribers ( $ interface ) ; foreach ( $ subscribers as $ row ) { $ this -> subscribe ( $ row [ 0 ] , $ row [ 1 ] , $ row [ 2 ] ) ; } return $ subscribers ; }
1228	public function parse ( $ expression ) { $ this -> expression = $ expression ; $ this -> tokens = $ this -> lexer -> tokenize ( $ expression ) ; $ this -> tpos = - 1 ; $ this -> next ( ) ; $ result = $ this -> expr ( ) ; if ( $ this -> token [ 'type' ] === T :: T_EOF ) { return $ result ; } throw $ this -> syntax ( 'Did not reach the end of the token stream' ) ; }
7252	protected function validatePaymentTermAndOutstandingLimit ( SaleInterface $ sale , Constraint $ constraint ) { if ( 0 >= $ sale -> getOutstandingLimit ( ) ) { return ; } if ( null === $ term = $ sale -> getPaymentTerm ( ) ) { if ( null !== $ customer = $ sale -> getCustomer ( ) ) { if ( $ customer -> hasParent ( ) ) { $ term = $ customer -> getParent ( ) -> getPaymentTerm ( ) ; } else { $ term = $ customer -> getPaymentTerm ( ) ; } } } if ( null === $ term ) { $ this -> context -> buildViolation ( $ constraint -> outstanding_limit_require_term ) -> atPath ( 'outstandingLimit' ) -> addViolation ( ) ; } }
9690	public function render ( $ file , $ env = array ( ) ) { $ file = $ this -> views_path . '/' . $ file ; if ( ! file_exists ( $ file ) ) { throw new \ Exception ( "Could not compile $file, file not found" ) ; } $ cacheHash = md5 ( $ file . serialize ( $ env ) ) ; $ cache_file = $ this -> views_cache . "/$cacheHash.cache" ; if ( ! $ this -> debug && ( file_exists ( $ cache_file ) && filemtime ( $ cache_file ) > filemtime ( $ file ) ) ) { return file_get_contents ( $ cache_file ) ; } $ this -> currFile = $ file ; $ hash = md5 ( $ file ) ; $ this -> compile ( $ file ) ; $ compiled_file = $ this -> views_cache . '/' . $ hash ; set_error_handler ( array ( $ this , 'onTemplateError' ) ) ; require_once ( $ compiled_file ) ; $ output = call_user_func ( 'katar_' . $ hash , $ env ) ; restore_error_handler ( ) ; file_put_contents ( $ cache_file , $ output ) ; return $ output ; }
12773	public function __async_authorize ( $ hashEmail = null , $ hashPassword = null ) { $ result = array ( 'status' => '0' ) ; if ( ! isset ( $ hashEmail ) ) { if ( isset ( $ _POST ) && isset ( $ _POST [ $ this -> dbHashEmailField ] ) ) { $ hashEmail = $ _POST [ $ this -> dbHashEmailField ] ; } elseif ( isset ( $ _GET ) && isset ( $ _GET [ $ this -> dbHashEmailField ] ) ) { $ hashEmail = $ _GET [ $ this -> dbHashEmailField ] ; } else { $ result [ 'email_error' ] = "\n" . '[' . $ this -> dbHashEmailField . '] field is not passed' ; } } if ( ! isset ( $ hashPassword ) ) { if ( isset ( $ _POST ) && isset ( $ _POST [ $ this -> dbHashPasswordField ] ) ) { $ hashPassword = $ _POST [ $ this -> dbHashPasswordField ] ; } elseif ( isset ( $ _GET ) && isset ( $ _GET [ $ this -> dbHashPasswordField ] ) ) { $ hashPassword = $ _GET [ $ this -> dbHashPasswordField ] ; } else { $ result [ 'email_error' ] = "\n" . '[' . $ this -> dbHashPasswordField . '] field is not passed' ; } } if ( isset ( $ hashEmail ) && isset ( $ hashPassword ) ) { $ hashEmail = $ this -> hash ( $ hashEmail ) ; $ hashPassword = $ this -> hash ( $ hashPassword ) ; $ authorizeResult = $ this -> authorizeWithEmail ( $ hashEmail , $ hashPassword ) ; if ( $ authorizeResult -> code == EmailStatus :: SUCCESS_EMAIL_AUTHORIZE ) { $ result [ 'status' ] = '1' ; } $ result [ self :: RESPONSE_STATUS_TEXTFIELD ] = $ authorizeResult -> text ; $ result [ self :: RESPONSE_STATUS_FIELD ] = $ authorizeResult -> code ; $ result = array_merge ( $ result , $ authorizeResult -> response ) ; } return $ result ; }
325	public static function variablize ( $ word ) { $ word = static :: camelize ( $ word ) ; return mb_strtolower ( mb_substr ( $ word , 0 , 1 , self :: encoding ( ) ) ) . mb_substr ( $ word , 1 , null , self :: encoding ( ) ) ; }
11969	public static function SetAuthClass ( $ authClass ) { $ toolClass = \ MvcCore \ Application :: GetInstance ( ) -> GetToolClass ( ) ; if ( $ toolClass :: CheckClassInterface ( $ authClass , 'MvcCore\Ext\Auths\Basics\IAuth' , TRUE , TRUE ) ) self :: $ authClass = $ authClass ; }
4145	protected function validateCredentials ( $ credentials ) { $ credentials = array_filter ( $ credentials ) ; $ keys = array_keys ( $ credentials ) ; $ diff = array_diff ( $ this -> requiredCredentials , $ keys ) ; if ( ! empty ( $ diff ) ) { throw new MissingCredentialsException ( 'Missing Credentials: ' . implode ( $ diff , ', ' ) ) ; } unset ( $ credentials , $ keys , $ diff ) ; }
7865	protected function drawBordered ( $ content ) { $ left = $ this -> geometry -> getLeftBordersWith ( static :: BORDER_X ) ; $ right = $ this -> geometry -> getRightBordersWith ( static :: BORDER_X ) ; $ this -> drawRow ( $ left . $ content . $ right ) ; }
2804	public function searchAction ( ) { $ requests = $ this -> _getFilteredRequests ( ) ; $ this -> loadLayout ( 'sheep_debug' ) ; $ rootBlock = $ this -> getLayout ( ) -> getBlock ( 'root' ) ; $ rootBlock -> setHeaderTitle ( $ this -> __ ( 'Request profiles' ) ) ; $ profileListBlock = $ this -> getLayout ( ) -> getBlock ( 'sheep_debug_list' ) ; $ profileListBlock -> setData ( 'results' , $ requests ) ; $ this -> renderLayout ( ) ; }
11646	private function generateExecuteDocBlock ( $ methodDescription , $ returnType ) { $ docBlock = new DocBlockGenerator ( $ methodDescription , null ) ; $ tags [ ] = new GenericTag ( 'return' , $ returnType ) ; $ docBlock -> setTags ( $ tags ) ; return $ docBlock ; }
6807	public function createFromContext ( ContextInterface $ context ) { return $ this -> create ( $ context -> getLocale ( ) , $ context -> getCurrency ( ) -> getCode ( ) ) ; }
7301	static public function getTargetsForSale ( SaleInterface $ sale ) { if ( $ sale instanceof CartInterface ) { return [ static :: TARGET_ORDER , static :: TARGET_QUOTE ] ; } elseif ( $ sale instanceof OrderInterface ) { if ( $ sale -> getState ( ) !== OrderStates :: STATE_NEW ) { return [ ] ; } return [ static :: TARGET_QUOTE ] ; } elseif ( $ sale instanceof QuoteInterface ) { return [ static :: TARGET_ORDER ] ; } throw new InvalidArgumentException ( "Unexpected sale type." ) ; }
10103	private function writeDimensions ( ) { $ record = 0x0200 ; $ length = 0x000E ; $ data = pack ( 'VVvvv' , $ this -> firstRowIndex , $ this -> lastRowIndex + 1 , $ this -> firstColumnIndex , $ this -> lastColumnIndex + 1 , 0x0000 ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ this -> append ( $ header . $ data ) ; }
4435	public static function fromErrorMessage ( string $ error ) : QlessException { $ area = null ; $ message = $ error ; if ( preg_match ( self :: ERROR_MESSAGE_RE , $ error , $ matches ) > 0 ) { $ area = $ matches [ 'area' ] ; $ message = $ matches [ 'message' ] ; } switch ( true ) { case ( $ area === 'Requeue' && stripos ( $ message , 'does not exist' ) !== false ) : case ( stripos ( $ message , 'Job does not exist' ) !== false ) : return new InvalidJobException ( $ message , $ area ) ; case ( stripos ( $ message , 'Job given out to another worker' ) !== false ) : return new JobLostException ( $ message , $ area ) ; case ( stripos ( $ message , 'Job not currently running' ) !== false ) : default : return new QlessException ( $ message , $ area ) ; } }
6127	public function setExpireDate ( $ expireDate ) { if ( $ expireDate instanceof DateTime ) { $ this -> expireDate = $ expireDate ; } else { try { $ this -> expireDate = new DateTime ( $ expireDate ) ; } catch ( \ Exception $ e ) { $ this -> expireDate = null ; } } return $ this ; }
7610	public function signup ( ) { if ( $ this -> validate ( ) ) { $ user = new User ( ) ; $ user -> username = $ this -> username ; $ user -> email = $ this -> email ; $ user -> setPassword ( $ this -> password ) ; $ user -> generateAuthKey ( ) ; if ( $ user -> save ( ) ) { return $ user ; } } return null ; }
2668	public function getAuthDictionary ( $ version ) { $ name = Config :: AUTH_DICTIONARY_NAME ; $ dictionary = $ this -> getSingleDictionary ( $ version , $ name ) ; return $ dictionary ; }
12432	public function listPermalinksAction ( Request $ request , Application $ app ) { $ options = array ( "request" => $ request , "pages_collection_parser" => $ app [ "red_kite_cms.pages_collection_parser" ] , "username" => $ this -> fetchUsername ( $ app [ "security" ] , $ app [ "red_kite_cms.configuration_handler" ] ) , ) ; return parent :: listPermalinks ( $ options ) ; }
1352	protected function notAllowed ( string $ resourceType , string $ fields ) : Collection { $ fields = collect ( explode ( ',' , $ fields ) ) ; if ( ! $ this -> allowed -> has ( $ resourceType ) ) { return $ fields ; } $ allowed = $ this -> allowed -> get ( $ resourceType ) ; if ( is_null ( $ allowed ) ) { return collect ( ) ; } $ allowed = collect ( ( array ) $ allowed ) ; return $ fields -> reject ( function ( $ value ) use ( $ allowed ) { return $ allowed -> contains ( $ value ) ; } ) ; }
5694	public function index ( HTTPRequest $ r ) { Requirements :: css ( BETTER_BUTTONS_DIR . '/css/betterbuttons_nested_form.css' ) ; return $ this -> customise ( array ( 'Form' => $ this -> Form ( ) ) ) -> renderWith ( BetterButtonNestedForm :: class ) ; }
8665	private function convertGetReportRequestCount ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetReportRequestCount' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetReportTypeList ( ) ) { $ reportTypeList = $ request -> getReportTypeList ( ) ; foreach ( $ reportTypeList -> getType ( ) as $ typeIndex => $ type ) { $ parameters [ 'ReportTypeList' . '.' . 'Type' . '.' . ( $ typeIndex + 1 ) ] = $ type ; } } if ( $ request -> isSetReportProcessingStatusList ( ) ) { $ reportProcessingStatusList = $ request -> getReportProcessingStatusList ( ) ; foreach ( $ reportProcessingStatusList -> getStatus ( ) as $ statusIndex => $ status ) { $ parameters [ 'ReportProcessingStatusList' . '.' . 'Status' . '.' . ( $ statusIndex + 1 ) ] = $ status ; } } if ( $ request -> isSetRequestedFromDate ( ) ) { $ parameters [ 'RequestedFromDate' ] = $ this -> getFormattedTimestamp ( $ request -> getRequestedFromDate ( ) ) ; } if ( $ request -> isSetRequestedToDate ( ) ) { $ parameters [ 'RequestedToDate' ] = $ this -> getFormattedTimestamp ( $ request -> getRequestedToDate ( ) ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
346	private static function mergeCssClasses ( array $ existingClasses , array $ additionalClasses ) { foreach ( $ additionalClasses as $ key => $ class ) { if ( is_int ( $ key ) && ! in_array ( $ class , $ existingClasses ) ) { $ existingClasses [ ] = $ class ; } elseif ( ! isset ( $ existingClasses [ $ key ] ) ) { $ existingClasses [ $ key ] = $ class ; } } return array_unique ( $ existingClasses ) ; }
10361	public static function writeLogs ( string $ message ) : bool { return ( bool ) file_put_contents ( rtrim ( LOGS_PATH , '/' ) . '/' . gmdate ( 'Y_m_d' ) . '.log' , '[' . gmdate ( 'd-M-Y H:i:s' ) . '] ' . $ message . PHP_EOL , FILE_APPEND ) ; }
11508	public function validate ( $ token ) { $ params = [ $ token , $ this -> request -> get ( 'timestamp' ) , $ this -> request -> get ( 'nonce' ) , ] ; if ( ! $ this -> debug && $ this -> request -> get ( 'signature' ) !== $ this -> signature ( $ params ) ) { throw new FaultException ( 'Invalid request signature.' , 400 ) ; } }
2922	protected function ensureFileIsReadable ( ) { if ( ! is_readable ( $ this -> filePath ) || ! is_file ( $ this -> filePath ) ) { throw new UnableReadFileException ( sprintf ( 'Unable to read the file at %s.' , $ this -> filePath ) ) ; } }
8411	public function disconnect ( ) { if ( isset ( $ this -> servers [ 'all' ] ) === true ) { unset ( $ this -> servers [ 'all' ] [ 'link' ] ) ; } else { unset ( $ this -> servers [ 'read' ] [ 'link' ] ) ; unset ( $ this -> servers [ 'write' ] [ 'link' ] ) ; } }
9330	static function filter ( $ width , $ height ) { return array ( new ezcImageFilter ( 'scale' , array ( 'width' => intval ( $ width ) , 'height' => intval ( $ height ) , 'direction' => ezcImageGeometryFilters :: SCALE_BOTH ) ) ) ; }
6265	public function resolve ( ResponseInterface $ response ) { if ( HttpPromise :: PENDING !== $ this -> state ) { throw new \ RuntimeException ( 'Promise is already resolved' ) ; } $ this -> state = HttpPromise :: FULFILLED ; $ this -> response = $ response ; $ this -> doResolve ( $ response ) ; }
10301	private function writeLayout ( XMLWriter $ objWriter , Layout $ layout = null ) { $ objWriter -> startElement ( 'c:layout' ) ; if ( $ layout !== null ) { $ objWriter -> startElement ( 'c:manualLayout' ) ; $ layoutTarget = $ layout -> getLayoutTarget ( ) ; if ( $ layoutTarget !== null ) { $ objWriter -> startElement ( 'c:layoutTarget' ) ; $ objWriter -> writeAttribute ( 'val' , $ layoutTarget ) ; $ objWriter -> endElement ( ) ; } $ xMode = $ layout -> getXMode ( ) ; if ( $ xMode !== null ) { $ objWriter -> startElement ( 'c:xMode' ) ; $ objWriter -> writeAttribute ( 'val' , $ xMode ) ; $ objWriter -> endElement ( ) ; } $ yMode = $ layout -> getYMode ( ) ; if ( $ yMode !== null ) { $ objWriter -> startElement ( 'c:yMode' ) ; $ objWriter -> writeAttribute ( 'val' , $ yMode ) ; $ objWriter -> endElement ( ) ; } $ x = $ layout -> getXPosition ( ) ; if ( $ x !== null ) { $ objWriter -> startElement ( 'c:x' ) ; $ objWriter -> writeAttribute ( 'val' , $ x ) ; $ objWriter -> endElement ( ) ; } $ y = $ layout -> getYPosition ( ) ; if ( $ y !== null ) { $ objWriter -> startElement ( 'c:y' ) ; $ objWriter -> writeAttribute ( 'val' , $ y ) ; $ objWriter -> endElement ( ) ; } $ w = $ layout -> getWidth ( ) ; if ( $ w !== null ) { $ objWriter -> startElement ( 'c:w' ) ; $ objWriter -> writeAttribute ( 'val' , $ w ) ; $ objWriter -> endElement ( ) ; } $ h = $ layout -> getHeight ( ) ; if ( $ h !== null ) { $ objWriter -> startElement ( 'c:h' ) ; $ objWriter -> writeAttribute ( 'val' , $ h ) ; $ objWriter -> endElement ( ) ; } $ objWriter -> endElement ( ) ; } $ objWriter -> endElement ( ) ; }
12737	protected function translate ( ) { $ translatorOptions = $ this -> getTranslatorOptions ( ) ; if ( empty ( $ translatorOptions ) && ! array_key_exists ( "fields" , $ translatorOptions ) ) { return ; } $ params = array ( ) ; if ( array_key_exists ( "params" , $ translatorOptions ) ) { $ params = $ translatorOptions [ "params" ] ; } $ domain = "RedKiteCms" ; if ( array_key_exists ( "domain" , $ translatorOptions ) ) { $ domain = $ translatorOptions [ "domain" ] ; } foreach ( $ translatorOptions [ "fields" ] as $ field ) { $ field = ucfirst ( $ field ) ; $ method = 'get' . $ field ; $ value = Translator :: translate ( $ this -> $ method ( ) , $ params , $ domain ) ; $ method = 'set' . $ field ; $ this -> $ method ( $ value ) ; } }
6927	protected function notify ( $ type , $ resource ) { $ notify = $ this -> builder -> create ( $ type , $ resource ) ; if ( ! $ this -> builder -> build ( $ notify ) ) { return ; } $ this -> queue -> add ( $ notify ) ; }
11711	public function actionBlock ( $ id , $ back = 'index' ) { if ( $ id == \ Yii :: $ app -> user -> getId ( ) ) { \ Yii :: $ app -> getSession ( ) -> setFlash ( 'danger' , \ Yii :: t ( 'user' , 'You can not block your own account' ) ) ; } else { $ user = $ this -> findModel ( $ id ) ; if ( $ user -> getIsBlocked ( ) ) { $ user -> unblock ( ) ; \ Yii :: $ app -> getSession ( ) -> setFlash ( 'success' , \ Yii :: t ( 'user' , 'User has been unblocked' ) ) ; } else { $ user -> block ( ) ; \ Yii :: $ app -> getSession ( ) -> setFlash ( 'success' , \ Yii :: t ( 'user' , 'User has been blocked' ) ) ; } } $ url = $ back == 'index' ? [ 'index' ] : [ 'update' , 'id' => $ id ] ; return $ this -> redirect ( $ url ) ; }
6799	public function installCountries ( $ code = 'US' ) { $ countryNames = Intl :: getRegionBundle ( ) -> getCountryNames ( ) ; if ( ! isset ( $ countryNames [ $ code ] ) ) { throw new InvalidArgumentException ( "Invalid default country code '$code'." ) ; } asort ( $ countryNames ) ; $ this -> generate ( Country :: class , $ countryNames , $ code ) ; }
12168	public function createPropertyValuesProxyTable ( $ group , $ dropExisting = true ) { $ group = strtolower ( $ group ) ; if ( ! empty ( $ group ) ) : $ this -> database -> query ( "DROP TABLE IF EXISTS `?{$group}_property_values`;" ) ; $ this -> database -> query ( "CREATE TABLE IF NOT EXISTS `?{$group}_property_values` ( `value_id` mediumint(11) NOT NULL AUTO_INCREMENT, `value_data` text NOT NULL, `value_updated_on` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP, `property_id` int(11) NOT NULL, `object_id` int(11) NOT NULL, PRIMARY KEY (`value_id`), UNIQUE KEY `object_property_uid` (`object_id`,`property_id`), KEY `property_id_idxfk` (`property_id`), KEY `object_id_idxfk` (`object_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8;" ) ; $ this -> database -> query ( "DROP TRIGGER IF EXISTS `?{$group}_property_value_validate_insert`;" ) ; $ this -> database -> query ( "CREATE TRIGGER `?{$group}_property_value_validate_insert` BEFORE INSERT ON `?{$group}_property_values` FOR EACH ROW BEGIN CALL ?property_value_validate(NEW.property_id, NEW.value_data); END;" ) ; $ this -> database -> query ( "DROP TRIGGER IF EXISTS `?{$group}_property_value_validate_update`;" ) ; $ this -> database -> query ( "CREATE TRIGGER `?{$group}_property_value_validate_update` BEFORE UPDATE ON `?{$group}_property_values` FOR EACH ROW BEGIN CALL ?property_value_validate(NEW.property_id, NEW.value_data); END;" ) ; $ this -> database -> query ( "ALTER TABLE `?{$group}_property_values` ADD CONSTRAINT `{$group}_property_values_ibfk_1` FOREIGN KEY (`object_id`) REFERENCES `?objects` (`object_id`), ADD CONSTRAINT `{$group}_property_values_ibfk_2` FOREIGN KEY (`property_id`) REFERENCES `?properties` (`property_id`) ON DELETE CASCADE;" ) ; endif ; }
10311	function getRecipients ( $ fromDate = null , $ toDate = null , $ mailingIds = null , $ contactIds = null , $ contactEmails = null , $ contactExternalIds = null , $ excludeDeletedRecipients = false , $ standardFields = null , $ customFields = null , $ embedFieldBackups = false , $ pageIndex = 1 , $ pageSize = 100 ) { $ params = $ this -> createQueryParameters ( $ pageIndex , $ pageSize , $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , $ mailingIds , null , $ embedFieldBackups ) ; $ params = $ this -> appendArrayFields ( $ params , "standard_field" , $ standardFields ) ; $ params = $ this -> appendArrayFields ( $ params , "custom_field" , $ customFields ) ; if ( isset ( $ excludeDeletedRecipients ) ) $ params [ 'exclude_deleted_recipients' ] = ( $ excludeDeletedRecipients == true ) ? "true" : "false" ; return $ this -> get ( 'reports/recipients' , $ params ) ; }
7509	function setIdentifiers ( $ ident ) { if ( is_array ( $ ident ) ) { $ this -> identifiers = array_fill_keys ( array_values ( $ ident ) , true ) ; $ this -> buildCharMap ( ) ; } else { $ this -> setIdentifiers ( str_split ( $ ident ) ) ; } }
10968	public static function getPath ( ) { $ uri = isset ( $ _SERVER [ 'REQUEST_URI' ] ) ? $ _SERVER [ 'REQUEST_URI' ] : '' ; if ( strpos ( $ uri , '?' ) > 0 ) { $ uri = substr ( $ uri , 0 , strpos ( $ uri , '?' ) ) ; } $ uri = preg_replace ( "/^\\/(.*)$/" , "$1" , $ uri ) ; $ uri = preg_replace ( "/^(.*)\\/$/" , "$1" , $ uri ) ; return $ uri ; }
10444	protected function handleStatement ( $ line , $ type ) { if ( ! preg_match ( "/^{$type}$/" , $ line ) ) { throw new \ UnexpectedValueException ( "Expected a {$type} statement, got {$line}" ) ; } $ params = [ ] ; $ param = $ this -> handleParam ( ) ; while ( $ param !== null ) { $ params = $ params + $ param ; $ param = $ this -> handleParam ( ) ; } return $ params ; }
2029	public static function findPublishedFallbackByHostname ( $ strHost , array $ arrOptions = array ( ) ) { if ( empty ( $ arrOptions ) ) { $ objModel = Registry :: getInstance ( ) -> fetch ( static :: $ strTable , $ strHost , 'contao.dns-fallback' ) ; if ( $ objModel !== null ) { return $ objModel ; } } $ t = static :: $ strTable ; $ arrColumns = array ( "$t.dns=? AND $t.fallback='1'" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } return static :: findOneBy ( $ arrColumns , $ strHost , $ arrOptions ) ; }
12613	private function checkOptions ( $ options ) { foreach ( $ this -> required as $ req ) { if ( ! array_key_exists ( $ req , $ options ) ) { throw new \ Exception ( '"' . $ req . '" option has not been defined' ) ; } } }
6443	public function httpRequest ( $ url ) { if ( DEBUG ) echo "HTTP request: $url\n" ; $ curl = curl_init ( ) ; curl_setopt ( $ curl , CURLOPT_URL , $ url ) ; curl_setopt ( $ curl , CURLOPT_HEADER , 0 ) ; curl_setopt ( $ curl , CURLOPT_RETURNTRANSFER , true ) ; curl_setopt ( $ curl , CURLOPT_TIMEOUT , CURL_TIMEOUT ) ; curl_setopt ( $ curl , CURLOPT_USERAGENT , SPIDER_NAME ) ; curl_setopt ( $ curl , CURLOPT_VERBOSE , false ) ; curl_setopt ( $ curl , CURLOPT_MAXREDIRS , 4 ) ; curl_setopt ( $ curl , CURLOPT_FOLLOWLOCATION , true ) ; $ response [ 'file' ] = curl_exec ( $ curl ) ; $ response [ 'status' ] = curl_getinfo ( $ curl ) ; $ response [ 'error' ] = curl_error ( $ curl ) ; curl_exec ( $ curl ) ; curl_close ( $ curl ) ; if ( DEBUG === 'verbose' ) { echo "Retrieved HTTP:\n" ; var_dump ( $ response [ 'status' ] ) ; var_dump ( $ response [ 'error' ] ) ; } if ( $ response [ 'file' ] == '' ) die ( "Error while making the HTTP request: no HTML retrieved." ) ; return $ response ; }
1562	protected function deserializeAttribute ( $ value , $ field , $ record ) { if ( $ this -> isDateAttribute ( $ field , $ record ) ) { return $ this -> deserializeDate ( $ value , $ field , $ record ) ; } $ method = 'deserialize' . Str :: classify ( $ field ) . 'Field' ; if ( method_exists ( $ this , $ method ) ) { return $ this -> { $ method } ( $ value , $ record ) ; } return $ value ; }
12801	public function createItem ( $ name , array $ options = array ( ) ) { if ( ! empty ( $ options [ 'admin' ] ) ) { $ admin = $ options [ 'admin' ] ; if ( ! $ options [ 'admin' ] instanceof AdminInterface ) { $ admin = $ this -> container -> get ( 'sonata.admin.pool' ) -> getAdminByAdminCode ( $ admin ) ; } $ action = isset ( $ options [ 'admin_action' ] ) ? $ options [ 'admin_action' ] : 'list' ; $ options [ 'uri' ] = $ admin -> generateUrl ( $ action ) ; $ options [ 'translationDomain' ] = $ admin -> getTranslationDomain ( ) ; } if ( ! empty ( $ options [ 'route' ] ) ) { $ params = isset ( $ options [ 'routeParameters' ] ) ? $ options [ 'routeParameters' ] : array ( ) ; $ absolute = isset ( $ options [ 'routeAbsolute' ] ) ? $ options [ 'routeAbsolute' ] : false ; $ options [ 'uri' ] = $ this -> generator -> generate ( $ options [ 'route' ] , $ params , $ absolute ) ; } $ item = new MenuItem ( $ name , $ this ) ; $ options = array_merge ( array ( 'uri' => null , 'label' => null , 'attributes' => array ( ) , 'linkAttributes' => array ( ) , 'childrenAttributes' => array ( ) , 'labelAttributes' => array ( ) , 'extras' => array ( ) , 'display' => true , 'displayChildren' => true , 'translationDomain' => 'messages' , 'displayLink' => true , 'displayLabel' => true , ) , $ options ) ; $ item -> setUri ( $ options [ 'uri' ] ) -> setLabel ( $ options [ 'label' ] ) -> setAttributes ( $ options [ 'attributes' ] ) -> setLinkAttributes ( $ options [ 'linkAttributes' ] ) -> setChildrenAttributes ( $ options [ 'childrenAttributes' ] ) -> setLabelAttributes ( $ options [ 'labelAttributes' ] ) -> setExtras ( $ options [ 'extras' ] ) -> setDisplay ( $ options [ 'display' ] ) -> setDisplayChildren ( $ options [ 'displayChildren' ] ) -> setTranslationDomain ( $ options [ 'translationDomain' ] ) -> setDisplayLink ( $ options [ 'displayLink' ] ) -> setDisplayLabel ( $ options [ 'displayLabel' ] ) ; return $ item ; return parent :: createItem ( $ name , $ options ) ; }
10696	public function toArray ( ) : array { if ( empty ( $ this -> output ) ) { $ problem = [ 'type' => $ this -> type ? ( string ) $ this -> type : 'about:blank' ] ; if ( $ this -> title ) { $ problem [ 'title' ] = $ this -> title ; } if ( $ this -> status ) { $ problem [ 'status' ] = $ this -> status ; } if ( $ this -> detail ) { $ problem [ 'detail' ] = $ this -> detail ; } if ( $ this -> instance ) { $ problem [ 'instance' ] = ( string ) $ this -> instance ; } $ this -> output = array_merge ( $ problem , $ this -> extensions ) ; } return $ this -> output ; }
8200	public function look ( $ number = 1 ) { if ( ! isset ( $ this -> tokens [ $ this -> current + $ number ] ) ) { throw new Twig_Error_Syntax ( 'Unexpected end of template.' , $ this -> tokens [ $ this -> current + $ number - 1 ] -> getLine ( ) , $ this -> source ) ; } return $ this -> tokens [ $ this -> current + $ number ] ; }
1264	private function createVoidRequest ( $ shipmentData ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; $ container = $ xml -> appendChild ( $ xml -> createElement ( 'VoidShipmentRequest' ) ) ; $ request = $ container -> appendChild ( $ xml -> createElement ( 'Request' ) ) ; $ node = $ xml -> importNode ( $ this -> createTransactionNode ( ) , true ) ; $ request -> appendChild ( $ node ) ; $ request -> appendChild ( $ xml -> createElement ( 'RequestAction' , '1' ) ) ; if ( is_string ( $ shipmentData ) ) { $ container -> appendChild ( $ xml -> createElement ( 'ShipmentIdentificationNumber' , strtoupper ( $ shipmentData ) ) ) ; } else { $ expanded = $ container -> appendChild ( $ xml -> createElement ( 'ExpandedVoidShipment' ) ) ; $ expanded -> appendChild ( $ xml -> createElement ( 'ShipmentIdentificationNumber' , strtoupper ( $ shipmentData [ 'shipmentId' ] ) ) ) ; if ( array_key_exists ( 'trackingNumbers' , $ shipmentData ) ) { foreach ( $ shipmentData [ 'trackingNumbers' ] as $ tn ) { $ expanded -> appendChild ( $ xml -> createElement ( 'TrackingNumber' , strtoupper ( $ tn ) ) ) ; } } } return $ xml -> saveXML ( ) ; }
732	public function evaluateAttributes ( $ event ) { if ( $ this -> skipUpdateOnClean && $ event -> name === ActiveRecord :: EVENT_BEFORE_UPDATE && empty ( $ this -> owner -> dirtyAttributes ) ) { return ; } $ attributes = array_keys ( array_filter ( $ this -> attributes , function ( $ carry ) use ( $ event ) { return array_key_exists ( $ event -> name , $ carry ) ; } ) ) ; if ( ! empty ( $ this -> order [ $ event -> name ] ) ) { $ attributes = array_merge ( array_intersect ( ( array ) $ this -> order [ $ event -> name ] , $ attributes ) , array_diff ( $ attributes , ( array ) $ this -> order [ $ event -> name ] ) ) ; } foreach ( $ attributes as $ attribute ) { if ( $ this -> preserveNonEmptyValues && ! empty ( $ this -> owner -> $ attribute ) ) { continue ; } $ this -> owner -> $ attribute = $ this -> getValue ( $ attribute , $ event ) ; } }
3562	protected function hasMutator ( $ value , $ dir = 'setter' , $ type = null ) { return ( bool ) $ this -> getMutator ( $ value , $ dir , $ type ) ; }
2047	public function onSchemaIndexDefinition ( SchemaIndexDefinitionEventArgs $ event ) : void { if ( method_exists ( AbstractPlatform :: class , 'supportsColumnLengthIndexes' ) ) { return ; } $ connection = $ event -> getConnection ( ) ; if ( ! $ connection -> getDatabasePlatform ( ) instanceof MySqlPlatform ) { return ; } $ data = $ event -> getTableIndex ( ) ; if ( 'PRIMARY' === $ data [ 'name' ] ) { return ; } $ columns = [ ] ; $ query = sprintf ( "SHOW INDEX FROM %s WHERE Key_name='%s'" , $ event -> getTable ( ) , $ data [ 'name' ] ) ; $ result = $ connection -> executeQuery ( $ query ) ; while ( $ row = $ result -> fetch ( ) ) { if ( null !== $ row [ 'Sub_part' ] ) { $ columns [ ] = sprintf ( '%s(%s)' , $ row [ 'Column_name' ] , $ row [ 'Sub_part' ] ) ; } else { $ columns [ ] = $ row [ 'Column_name' ] ; } } $ event -> setIndex ( new Index ( $ data [ 'name' ] , $ columns , $ data [ 'unique' ] , $ data [ 'primary' ] , $ data [ 'flags' ] , $ data [ 'options' ] ) ) ; $ event -> preventDefault ( ) ; }
6644	public static function getStatusHtml ( $ status , $ extraClasses = '' , $ baseClass = 'label' , $ tag = 'span' ) { $ status = strtolower ( $ status ) ; $ statusHyphenated = implode ( '-' , explode ( ' ' , $ status ) ) ; $ class = trim ( "{$baseClass} {$baseClass}-$statusHyphenated $extraClasses" ) ; return Html :: tag ( $ tag , $ status , [ 'class' => $ class ] ) ; }
7888	public function logs ( ) { $ logs = array_reverse ( $ this -> filesystem -> files ( ) ) ; foreach ( $ logs as $ index => $ file ) { $ logs [ $ index ] = preg_replace ( '/.*(\d{4}-\d{2}-\d{2}).*/' , '$1' , basename ( $ file ) ) ; } return $ logs ; }
2850	public function setTemplateHints ( $ status ) { $ this -> deleteTemplateHintsDbConfigs ( ) ; $ config = $ this -> getConfig ( ) ; $ config -> saveConfig ( 'dev/debug/template_hints' , ( int ) $ status ) ; $ config -> saveConfig ( 'dev/debug/template_hints_blocks' , ( int ) $ status ) ; }
2827	public function formatNumber ( $ number , $ precision = 2 ) { return $ this -> helper -> useStoreLocale ( ) ? $ this -> helper -> formatNumber ( $ number , $ precision ) : number_format ( $ number , $ precision ) ; }
7881	public function read ( $ date ) { try { return $ this -> files -> get ( $ this -> path ( $ date ) ) ; } catch ( FileNotFoundException $ e ) { throw new FilesystemException ( 'There was an reading the log.' ) ; } }
12866	public function init_locales ( ) { if ( ! empty ( $ this -> textdomain ) && $ this -> locales_initialized !== true ) { load_plugin_textdomain ( $ this -> textdomain , true , $ this -> get_id ( ) ) ; $ this -> locales_initialized = true ; } }
7542	function typeIndex ( ) { if ( ! $ this -> parent ) { return - 1 ; } else { $ index = - 1 ; foreach ( array_keys ( $ this -> parent -> children ) as $ k ) { if ( strcasecmp ( $ this -> tag , $ this -> parent -> children [ $ k ] -> tag ) === 0 ) { ++ $ index ; } if ( $ this -> parent -> children [ $ k ] === $ this ) { return $ index ; } } return - 1 ; } }
12335	public function editProfileAction ( ) { if ( ! $ this -> cmsAuthentication ( ) -> hasIdentity ( ) ) { return $ this -> redirect ( ) -> toRoute ( $ this -> getOptions ( ) -> getLoginRoute ( ) ) ; } $ url = $ this -> url ( ) -> fromRoute ( null , [ 'action' => 'edit-profile' ] ) ; $ prg = $ this -> prg ( $ url , true ) ; if ( $ prg instanceof ResponseInterface ) { return $ prg ; } $ post = $ prg ; $ form = $ this -> getUserService ( ) -> getEditProfileForm ( ) ; $ identity = $ this -> cmsAuthentication ( ) -> getIdentity ( ) ; $ form -> bind ( $ identity ) ; $ form -> setAttribute ( 'action' , $ url ) ; if ( $ post && $ form -> setData ( $ post ) -> isValid ( ) ) { $ result = $ this -> getUserService ( ) -> editProfile ( $ identity ) ; if ( $ result instanceof ResponseInterface ) { return $ result ; } elseif ( $ result ) { $ fm = $ this -> flashMessenger ( ) ; $ fm -> setNamespace ( $ form -> getName ( ) . '-' . $ fm :: NAMESPACE_SUCCESS ) -> addMessage ( $ this -> translate ( 'Data has been successfully saved' ) ) ; } } return new ViewModel ( compact ( 'form' ) ) ; }
11051	function build_all ( $ datatree , $ entry ) { if ( ! isset ( $ this -> masktree [ $ entry ] ) ) { $ this -> error ( 8 , 57 , $ entry ) ; } $ this -> datatree = $ datatree ; if ( is_array ( $ this -> datatree ) ) { $ this -> datatree [ '_parent' ] = NULL ; } elseif ( is_object ( $ this -> datatree ) ) { $ this -> datatree -> _parent = NULL ; } elseif ( isset ( $ this -> datatree ) ) { $ this -> error ( 9 , 58 ) ; $ this -> datatree = NULL ; } $ built = $ this -> build_mask ( $ this -> datatree , $ this -> masktree [ $ entry ] ) ; if ( ! isset ( $ this -> masktree [ '0reduce' ] ) ) { $ this -> masktree [ '0reduce' ] = _ETS_REDUCE_OFF ; } switch ( $ this -> masktree [ '0reduce' ] ) { case _ETS_REDUCE_OFF : break ; case _ETS_REDUCE_SPACES : $ built = preg_replace ( '/(\r\n|\r|\n)+/sm' , "\n" , preg_replace ( '/[ \t]*?(\r\n|\r|\n)+[\t ]*/sm' , "\n" , $ built ) ) ; break ; case _ETS_REDUCE_ALL : $ built = preg_replace ( '/[ \t]*?(\r\n|\r|\n)+[\t ]*/sm' , '' , $ built ) ; break ; } $ built = str_replace ( "\1n\1" , "\n" , $ built ) ; $ built = str_replace ( "\1r\1" , "\r" , $ built ) ; $ built = str_replace ( "\1t\1" , "\t" , $ built ) ; $ built = str_replace ( "\1s\1" , " " , $ built ) ; return $ built ; }
1980	public static function generateUnwrapped ( $ strScope = TL_MODE , $ blnRaw = false ) { $ session = System :: getContainer ( ) -> get ( 'session' ) ; if ( ! $ session -> isStarted ( ) ) { return '' ; } $ strMessages = '' ; $ flashBag = $ session -> getFlashBag ( ) ; foreach ( static :: getTypes ( ) as $ strType ) { $ strClass = strtolower ( $ strType ) ; $ arrMessages = $ flashBag -> get ( static :: getFlashBagKey ( $ strType , $ strScope ) ) ; foreach ( array_unique ( $ arrMessages ) as $ strMessage ) { if ( $ strType == 'TL_RAW' || $ blnRaw ) { $ strMessages .= $ strMessage ; } else { $ strMessages .= '<p class="' . $ strClass . '">' . $ strMessage . '</p>' ; } } } return trim ( $ strMessages ) ; }
2761	public function getLogLevelMapping ( string $ eventName ) : string { if ( ! isset ( $ this -> logLevelMappings [ $ eventName ] ) ) { throw new GitException ( sprintf ( 'Unknown event "%s"' , $ eventName ) ) ; } return $ this -> logLevelMappings [ $ eventName ] ; }
1830	public function refresh ( ) { $ intPk = $ this -> { static :: $ strPk } ; if ( isset ( $ this -> arrModified [ static :: $ strPk ] ) ) { $ intPk = $ this -> arrModified [ static :: $ strPk ] ; } $ res = Database :: getInstance ( ) -> prepare ( "SELECT * FROM " . static :: $ strTable . " WHERE " . Database :: quoteIdentifier ( static :: $ strPk ) . "=?" ) -> execute ( $ intPk ) ; $ this -> setRow ( $ res -> row ( ) ) ; }
2175	private function adjustDatabaseTables ( ) : ? RedirectResponse { $ this -> container -> get ( 'contao.install_tool' ) -> handleRunOnce ( ) ; $ installer = $ this -> container -> get ( 'contao.installer' ) ; $ this -> context [ 'sql_form' ] = $ installer -> getCommands ( ) ; $ request = $ this -> container -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; if ( null === $ request ) { throw new \ RuntimeException ( 'The request stack did not contain a request' ) ; } if ( 'tl_database_update' !== $ request -> request -> get ( 'FORM_SUBMIT' ) ) { return null ; } $ sql = $ request -> request -> get ( 'sql' ) ; if ( ! empty ( $ sql ) && \ is_array ( $ sql ) ) { foreach ( $ sql as $ hash ) { $ installer -> execCommand ( $ hash ) ; } } return $ this -> getRedirectResponse ( ) ; }
8666	public function setInvalidASIN ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'InvalidASIN' ] [ 'FieldValue' ] = $ value ; return $ this ; }
13	public function setClassMapAuthoritative ( $ classMapAuthoritative = false ) { $ this -> classMapAuthoritative = ( bool ) $ classMapAuthoritative ; if ( $ this -> classMapAuthoritative ) { $ this -> setOptimizeAutoloader ( true ) ; } return $ this ; }
12788	public static function setStatus ( $ iCode ) { if ( $ iCode === 200 ) { header ( 'HTTP/1.1 200 Ok' ) ; } else if ( $ iCode === 201 ) { header ( 'HTTP/1.1 201 Created' ) ; } else if ( $ iCode === 204 ) { header ( "HTTP/1.0 204 No Content" ) ; } else if ( $ iCode === 403 ) { header ( 'HTTP/1.1 403 Forbidden' ) ; } else if ( $ iCode === 404 ) { header ( 'HTTP/1.1 404 Not Found' ) ; } }
3952	protected function isArrayEmpty ( $ arrArray ) { if ( empty ( $ arrArray ) ) { return true ; } if ( is_array ( $ arrArray ) && array_key_exists ( 'value' , $ arrArray ) ) { return $ this -> isArrayEmpty ( $ arrArray [ 'value' ] ) ; } if ( is_array ( $ arrArray ) ) { foreach ( $ arrArray as $ value ) { if ( is_array ( $ value ) ) { return $ this -> isArrayEmpty ( $ value ) ; } elseif ( ! empty ( $ value ) ) { return false ; } } } return false ; }
7468	protected function colorize ( $ str , $ attrs ) { $ start = $ this -> start ( $ attrs ) ; return $ start . $ str . $ this -> end ( ) ; }
12746	protected function onMovedResponse ( CommandInterface $ command , $ details ) { list ( $ slot , $ connectionID ) = explode ( ' ' , $ details , 2 ) ; if ( ! $ connection = $ this -> getConnectionById ( $ connectionID ) ) { $ connection = $ this -> createConnection ( $ connectionID ) ; } if ( $ this -> useClusterSlots ) { $ this -> askSlotMap ( $ connection ) ; } $ this -> move ( $ connection , $ slot ) ; $ response = $ this -> executeCommand ( $ command ) ; return $ response ; }
10734	public function setLower ( $ lower ) : self { if ( ! is_numeric ( $ lower ) ) { throw new InvalidArgumentException ( __METHOD__ . "() expects parameter one, lower, to be a number" ) ; } $ this -> lower = + $ lower ; return $ this ; }
2550	protected function loadSessionHandler ( $ sessionHandler , $ params ) { if ( $ sessionHandler instanceof HandlerInterface ) { $ newSessionHandler = $ sessionHandler ; } else { $ newSessionHandler = HandlerFactory :: createHandler ( $ params ) ; } return $ newSessionHandler ; }
5722	public function save ( $ data , $ form ) { $ origStage = Versioned :: get_stage ( ) ; Versioned :: set_stage ( 'Stage' ) ; $ action = $ this -> owner -> doSave ( $ data , $ form ) ; Versioned :: set_stage ( $ origStage ) ; return $ action ; }
5926	public function listCategories ( CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/categories' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new CategoryResponse ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
3573	protected function setInstance ( Attribute $ attribute ) { if ( $ this -> has ( $ attribute -> getMetaKey ( ) ) ) { $ this -> update ( $ attribute ) ; } else { $ this -> items [ $ attribute -> getMetaKey ( ) ] = $ attribute ; } return $ this ; }
3491	public function withHeader ( string $ name , string $ value ) : Request { $ cloned = clone $ this ; $ cloned -> headers [ $ name ] = $ value ; return $ cloned ; }
9479	public function respondWithMessage ( $ message = null ) { $ res [ 'status' ] = $ this -> getStatusText ( ) ; if ( $ this -> getErrorCode ( ) ) { $ res [ 'error' ] = $ this -> getErrorCode ( ) ; if ( is_null ( $ message ) ) $ res [ 'message' ] = $ this -> getErrorMessage ( ) ; else $ res [ 'message' ] = $ message ; } else { $ res [ 'message' ] = $ message ; } return $ this -> respond ( $ res ) ; }
8809	public function delete ( $ key ) { if ( $ this -> has ( $ key ) ) { setcookie ( $ key , null , - 1 , '/' ) ; unset ( $ _COOKIE [ $ key ] ) ; } return ; }
7851	protected function grabParameter ( ReflectionParameter $ parameter ) { if ( isset ( $ this -> values [ $ parameter -> name ] ) ) { return $ this -> values [ $ parameter -> name ] ; } if ( $ parameter -> isDefaultValueAvailable ( ) ) { return $ parameter -> getDefaultValue ( ) ; } throw new Exception ( "Unable to map parameter [{$parameter->name}] to command [{$this->command}]" ) ; }
2197	public function onAuthenticationSuccess ( Request $ request , TokenInterface $ token ) : RedirectResponse { $ this -> user = $ token -> getUser ( ) ; if ( ! $ this -> user instanceof User ) { return $ this -> getRedirectResponse ( $ request ) ; } $ this -> user -> lastLogin = $ this -> user -> currentLogin ; $ this -> user -> currentLogin = time ( ) ; $ this -> user -> save ( ) ; if ( null !== $ this -> logger ) { $ this -> logger -> info ( sprintf ( 'User "%s" has logged in' , $ this -> user -> username ) , [ 'contao' => new ContaoContext ( __METHOD__ , ContaoContext :: ACCESS , $ this -> user -> username ) ] ) ; } $ this -> triggerPostLoginHook ( ) ; return $ this -> getRedirectResponse ( $ request ) ; }
583	public function actionCompress ( $ configFile , $ bundleFile ) { $ this -> loadConfiguration ( $ configFile ) ; $ bundles = $ this -> loadBundles ( $ this -> bundles ) ; $ targets = $ this -> loadTargets ( $ this -> targets , $ bundles ) ; foreach ( $ targets as $ name => $ target ) { $ this -> stdout ( "Creating output bundle '{$name}':\n" ) ; if ( ! empty ( $ target -> js ) ) { $ this -> buildTarget ( $ target , 'js' , $ bundles ) ; } if ( ! empty ( $ target -> css ) ) { $ this -> buildTarget ( $ target , 'css' , $ bundles ) ; } $ this -> stdout ( "\n" ) ; } $ targets = $ this -> adjustDependency ( $ targets , $ bundles ) ; $ this -> saveTargets ( $ targets , $ bundleFile ) ; if ( $ this -> deleteSource ) { $ this -> deletePublishedAssets ( $ bundles ) ; } }
3528	public function getFriends ( ) { $ data = FortniteClient :: sendUnrealClientGetRequest ( FortniteClient :: EPIC_FRIENDS_ENDPOINT . $ this -> account_id , $ this -> access_token , true ) ; return $ data ; }
4283	public function unlink ( $ path ) { self :: restorePrev ( ) ; $ success = \ unlink ( $ path ) ; self :: register ( ) ; return $ success ; }
9951	public function duplicateConditionalStyle ( array $ pCellStyle , $ pRange = '' ) { foreach ( $ pCellStyle as $ cellStyle ) { if ( ! ( $ cellStyle instanceof Conditional ) ) { throw new Exception ( 'Style is not a conditional style' ) ; } } list ( $ rangeStart , $ rangeEnd ) = Coordinate :: rangeBoundaries ( $ pRange . ':' . $ pRange ) ; if ( $ rangeStart [ 0 ] > $ rangeEnd [ 0 ] && $ rangeStart [ 1 ] > $ rangeEnd [ 1 ] ) { $ tmp = $ rangeStart ; $ rangeStart = $ rangeEnd ; $ rangeEnd = $ tmp ; } for ( $ col = $ rangeStart [ 0 ] ; $ col <= $ rangeEnd [ 0 ] ; ++ $ col ) { for ( $ row = $ rangeStart [ 1 ] ; $ row <= $ rangeEnd [ 1 ] ; ++ $ row ) { $ this -> setConditionalStyles ( Coordinate :: stringFromColumnIndex ( $ col ) . $ row , $ pCellStyle ) ; } } return $ this ; }
5284	public function limit ( $ limit , $ offset = 0 ) { global $ wpdb ; $ limit = \ absint ( $ limit ) ; $ offset = \ absint ( $ offset ) ; $ this -> limit = $ wpdb -> prepare ( 'limit %d, %d' , $ offset , $ limit ) ; return $ this ; }
10987	public static function D ( $ value , $ options = array ( ) ) { if ( is_numeric ( $ options ) ) { $ options = array ( 'depth' => $ options ) ; } elseif ( empty ( $ options ) ) { $ options = array ( ) ; } $ plop = new Dumpling ( $ options ) ; return $ plop -> dump ( $ value ) ; }
11992	public function toArray ( ) { $ urls = [ ] ; $ actions = [ ] ; if ( count ( $ this -> items ) < 1 ) { return parent :: toArray ( ) ; } $ entity = $ this -> items [ 0 ] ; if ( is_array ( $ entity -> load ) ) { foreach ( $ entity -> load as $ k => $ load ) { $ this -> load ( $ load ) ; } } $ data = parent :: toArray ( ) ; $ actions = $ entity -> getActions ( ) ; if ( count ( $ actions ) > 0 ) { foreach ( $ data as $ k => $ resource ) { if ( count ( $ resource ) < 2 ) { continue ; } $ data [ $ k ] += [ 'actions' => $ actions ] ; } } $ data = $ this -> normalizeArray ( $ data ) ; return $ data ; }
9376	protected function check ( array $ files , $ path , $ source , $ template ) { $ file = null ; foreach ( ( array ) $ files as $ key => $ value ) { $ filepath = ( string ) str_replace ( $ path , $ source , $ value ) ; $ filepath = str_replace ( '\\' , '/' , ( string ) $ filepath ) ; $ filepath = ( string ) preg_replace ( '/^\d\//i' , '' , $ filepath ) ; $ exists = ( string ) $ filepath === $ template ; $ lowercase = strtolower ( $ filepath ) === $ template ; ( $ exists || $ lowercase ) && $ file = $ value ; } return $ file ; }
2058	public function makeRedirectPageMandatory ( Contao \ DataContainer $ dc ) { $ objPage = $ this -> Database -> prepare ( "SELECT * FROM " . $ dc -> table . " WHERE id=?" ) -> limit ( 1 ) -> execute ( $ dc -> id ) ; if ( $ objPage -> numRows && $ objPage -> type == 'logout' ) { $ GLOBALS [ 'TL_DCA' ] [ 'tl_page' ] [ 'fields' ] [ 'jumpTo' ] [ 'eval' ] [ 'mandatory' ] = true ; } }
6296	private static function migrateConfig ( array $ config ) : array { if ( isset ( $ config [ 'class' ] ) ) { do_action ( 'inpsyde.assets.debug' , 'The asset config-format with "type" and "class" is deprecated.' , $ config ) ; $ config [ 'location' ] = $ config [ 'type' ] ?? Asset :: FRONTEND ; $ config [ 'type' ] = $ config [ 'class' ] ; unset ( $ config [ 'class' ] ) ; } return $ config ; }
10628	public static function cpuPercentages ( $ cpuCoreInfo1 , $ cpuCoreInfo2 ) { $ cpus = array ( ) ; foreach ( $ cpuCoreInfo1 as $ idx => $ core ) { $ dif = array ( ) ; $ cpu = array ( ) ; $ dif [ 'user' ] = $ cpuCoreInfo2 [ $ idx ] [ 'user' ] - $ cpuCoreInfo1 [ $ idx ] [ 'user' ] ; $ dif [ 'nice' ] = $ cpuCoreInfo2 [ $ idx ] [ 'nice' ] - $ cpuCoreInfo1 [ $ idx ] [ 'nice' ] ; $ dif [ 'sys' ] = $ cpuCoreInfo2 [ $ idx ] [ 'sys' ] - $ cpuCoreInfo1 [ $ idx ] [ 'sys' ] ; $ dif [ 'idle' ] = $ cpuCoreInfo2 [ $ idx ] [ 'idle' ] - $ cpuCoreInfo1 [ $ idx ] [ 'idle' ] ; $ dif [ 'iowait' ] = $ cpuCoreInfo2 [ $ idx ] [ 'iowait' ] - $ cpuCoreInfo1 [ $ idx ] [ 'iowait' ] ; $ dif [ 'irq' ] = $ cpuCoreInfo2 [ $ idx ] [ 'irq' ] - $ cpuCoreInfo1 [ $ idx ] [ 'irq' ] ; $ dif [ 'softirq' ] = $ cpuCoreInfo2 [ $ idx ] [ 'softirq' ] - $ cpuCoreInfo1 [ $ idx ] [ 'softirq' ] ; $ total = array_sum ( $ dif ) ; foreach ( $ dif as $ x => $ y ) { $ cpu [ $ x ] = round ( $ y / $ total * 100 , 2 ) ; } $ cpus [ 'cpu' . $ idx ] = $ cpu ; } return $ cpus ; }
286	public function remove ( $ name ) { $ name = strtolower ( $ name ) ; if ( isset ( $ this -> _headers [ $ name ] ) ) { $ value = $ this -> _headers [ $ name ] ; unset ( $ this -> _headers [ $ name ] ) ; return $ value ; } return null ; }
4086	public function handle ( BuildWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) || ( $ event -> getProperty ( ) -> getName ( ) !== 'filterparams' ) ) { return ; } $ model = $ event -> getModel ( ) ; $ objFilterSettings = $ this -> settingFactory -> createCollection ( $ model -> getProperty ( 'filter' ) ) ; $ extra = $ event -> getProperty ( ) -> getExtra ( ) ; $ extra [ 'subfields' ] = $ objFilterSettings -> getParameterDCA ( ) ; $ event -> getProperty ( ) -> setExtra ( $ extra ) ; }
1	public function buildDependencyInfo ( $ depArray ) { if ( ! is_array ( $ depArray ) ) { return new DependencyInfo ( array ( ) , array ( ) ) ; } if ( ! $ this -> isHash ( $ depArray ) ) { return new DependencyInfo ( $ this -> buildDependency10Info ( $ depArray ) , array ( ) ) ; } return $ this -> buildDependency20Info ( $ depArray ) ; }
5687	public function getFormBySubmit ( $ selector ) { for ( $ i = 0 ; $ i < count ( $ this -> forms ) ; $ i ++ ) { if ( $ this -> forms [ $ i ] -> hasSubmit ( $ selector ) ) { return $ this -> forms [ $ i ] ; } } return ; }
278	private function notifyUnloaded ( $ fixtures ) { $ this -> stdout ( "\nFixtures were successfully unloaded from namespace: " , Console :: FG_YELLOW ) ; $ this -> stdout ( Yii :: getAlias ( $ this -> namespace ) . "\"\n\n" , Console :: FG_GREEN ) ; $ this -> outputList ( $ fixtures ) ; }
12664	public function requirePackage ( string $ package_class ) : ApplicationInterface { if ( ! in_array ( PackageInterface :: class , class_implements ( $ package_class ) ) ) { throw new PackageRequireException ( 'Specified package does not implements PackageInterface: ' . $ package_class , $ package_class ) ; } $ module_list = call_user_func ( [ $ package_class , 'getModuleList' ] ) ; if ( ! is_array ( $ module_list ) ) { throw new PackageRequireException ( 'Failed to call getModuleList: ' . $ package_class , $ package_class ) ; } $ this -> required_modules = array_merge ( $ this -> required_modules , $ module_list ) ; return $ this ; }
5151	protected function textAfterString ( $ haystack , $ needle ) { $ result = "" ; $ needleLength = strlen ( $ needle ) ; if ( $ needleLength > 0 && preg_match ( "#$needle([^\r\n]+)#i" , $ haystack , $ match ) ) { $ result = trim ( substr ( $ match [ 0 ] , - ( strlen ( $ match [ 0 ] ) - $ needleLength ) ) ) ; } return $ result ; }
9438	public function reset ( ) { $ this -> rho = null ; $ this -> theta = null ; $ this -> r = null ; $ this -> i = null ; return $ this ; }
11722	public function getPosts ( $ limit = null , $ offset = null ) { $ em = $ this -> container -> get ( 'doctrine' ) -> getManager ( ) ; if ( is_null ( $ limit ) && is_null ( $ offset ) ) { $ entities = $ em -> getRepository ( 'BlogBundle:Post' ) -> findBy ( array ( ) , array ( 'published' => 'DESC' ) ) ; } elseif ( is_null ( $ limit ) && ! is_null ( $ offset ) ) { $ entities = $ em -> getRepository ( 'BlogBundle:Post' ) -> findBy ( array ( ) , array ( 'published' => 'DESC' ) , $ limit ) ; } elseif ( ! is_null ( $ limit ) && ! is_null ( $ offset ) ) { $ entities = $ em -> getRepository ( 'BlogBundle:Post' ) -> findBy ( array ( ) , array ( 'published' => 'DESC' ) , $ limit , $ offset ) ; } return $ entities ; }
3168	private function getCurrentThemeId ( ) { $ themeService = $ this -> getServiceLocator ( ) -> get ( ThemeService :: SERVICE_ID ) ; return $ themeService -> getTheme ( ) -> getId ( ) ; }
10605	public function addHeaders ( array $ headers ) : void { foreach ( $ headers as $ name => $ value ) { $ this -> addHeader ( ( string ) $ name , $ value ) ; } }
1556	protected function queryRulesWithoutSearch ( ) { return collect ( $ this -> queryRules ( ) ) -> reject ( function ( $ value , $ key ) { return Str :: startsWith ( $ key , [ 'filter.' , 'sort.' , 'page.' ] ) ; } ) -> all ( ) ; }
8191	public function actionConfirm ( $ id , $ code ) { $ user = UserIdentity :: findByActivationToken ( $ id , $ code ) ; if ( $ user == NULL ) throw new NotFoundHttpException ; if ( ! empty ( $ user ) ) { $ user -> activation_token = NULL ; $ user -> status = User :: STATUS_ACTIVE ; $ user -> save ( FALSE ) ; Yii :: $ app -> session -> setFlash ( 'success' , Yii :: t ( 'user' , 'Account ' . $ user -> email . ' has successfully been activated' ) ) ; } else Yii :: $ app -> session -> setFlash ( 'error' , Yii :: t ( 'user' , 'Account ' . $ user -> email . ' could not been activated. Please contact the Administrator' ) ) ; return $ this -> render ( 'confirm' , [ 'user' => $ user ] ) ; }
3024	public function getBlogPosts ( $ blogName , $ options = null ) { $ path = $ this -> blogPath ( $ blogName , '/posts' ) ; if ( $ options && isset ( $ options [ 'type' ] ) ) { $ path .= '/' . $ options [ 'type' ] ; unset ( $ options [ 'type' ] ) ; } return $ this -> getRequest ( $ path , $ options , true ) ; }
7977	public function deleteSecondaryDnsDomains ( $ domain2delete ) { json_decode ( self :: getClient ( ) -> deleteSecondaryDnsDomains ( $ this -> getDomain ( ) , $ domain2delete ) ) ; return true ; }
825	public function setName ( $ name ) { $ current = $ this -> getName ( ) ; if ( 'other' === $ current ) { throw new \ RuntimeException ( 'Cannot set name on unknown tag.' ) ; } $ this -> line -> setContent ( Preg :: replace ( "/@{$current}/" , "@{$name}" , $ this -> line -> getContent ( ) , 1 ) ) ; $ this -> name = $ name ; }
9282	public function getRunning ( array $ options = array ( ) ) { $ where = new Where ( ) ; $ where -> equalTo ( "{$this->tableName}.status" , JobEntity :: STATUS_RUNNING ) ; return $ this -> fetchByWhere ( $ where , $ options ) ; }
7503	public function tf ( string $ key , array $ args = null , array $ replacements = null , string ... $ namespaces ) { $ this -> view -> out ( $ this -> getTf ( $ key , $ args , $ replacements , ... $ namespaces ) ) ; }
4011	public function getPaginationString ( ) { $ this -> calculate ( ) ; if ( $ this -> getPerPage ( ) == 0 ) { return '' ; } $ objPagination = new \ Pagination ( $ this -> calculatedTotal , $ this -> getPerPage ( ) , $ this -> getMaxPaginationLinks ( ) ) ; return $ objPagination -> generate ( "\n " ) ; }
12499	public static function insertMany ( $ document , $ connection ) { if ( gettype ( $ document ) != "array" && gettype ( $ document ) != "object" ) { throw new ClusterpointException ( "\"->insert()\" function: parametr passed " . json_encode ( self :: escape_string ( $ document ) ) . " is not in valid document format." , 9002 ) ; } if ( gettype ( $ document ) == "object" ) { $ document_array = array ( ) ; foreach ( $ document as $ value ) { $ document_array [ ] = $ value ; } $ document = $ document_array ; } $ connection -> query = json_encode ( array_values ( $ document ) ) ; $ connection -> multiple = true ; return self :: insert ( $ connection ) ; }
8240	protected function saveResetTokens ( $ tokens , FileWriter $ writer = null ) { $ time = time ( ) ; foreach ( $ tokens as $ id => $ token ) { if ( $ time > $ token [ 'valid' ] ) { unset ( $ tokens [ $ id ] ) ; } } $ fileName = $ this -> dir . self :: RESET_TOKENS ; $ yaml = \ Symfony \ Component \ Yaml \ Yaml :: dump ( $ tokens , 1 , 2 ) ; if ( $ writer && $ writer -> isOpened ( ) ) { $ writer -> write ( $ yaml ) ; } else { self :: preparePath ( $ this -> dir , dirname ( self :: RESET_TOKENS ) ) ; if ( ( self :: writeFile ( $ fileName , $ yaml ) === false ) ) { throw new \ RuntimeException ( "Unable to save token file (" . self :: RESET_TOKENS . ")." ) ; } } }
4786	function offsetGet ( $ key ) { $ this -> access ( $ key ) ; if ( ! array_key_exists ( $ key , $ this -> row ) ) { $ this -> access ( $ key , true ) ; } return $ this -> row [ $ key ] ; }
6993	static protected function getCacheKeyForOptimizedUiTemplatesBasedOnUserRole ( $ group ) : string { if ( static :: getAuthModule ( ) -> getAccessPolicyClassName ( ) === CmfAccessPolicy :: class ) { $ userId = 'any' ; } else { $ userId = 'not_authenticated' ; $ user = static :: getUser ( ) ; if ( $ user && $ user -> existsInDb ( ) ) { if ( $ user :: hasColumn ( 'is_superadmin' ) ) { $ userId = '__superadmin__' ; } else if ( $ user :: hasColumn ( 'role' ) ) { $ userId = $ user -> role ; } else { $ userId = 'user' ; } } } return static :: url_prefix ( ) . '_templates_' . static :: getShortLocale ( ) . '_' . $ group . '_user_' . $ userId ; }
3366	private static function apache_modules ( ) { $ mods = WP_CLI :: get_config ( 'apache_modules' ) ; if ( ! empty ( $ mods ) && ! function_exists ( 'apache_get_modules' ) ) { global $ is_apache ; $ is_apache = true ; $ _SERVER [ 'SCRIPT_FILENAME' ] = ABSPATH ; function apache_get_modules ( ) { return WP_CLI :: get_config ( 'apache_modules' ) ; } } }
2076	public function purgeImageCache ( ) { $ container = System :: getContainer ( ) ; $ strTargetPath = StringUtil :: stripRootDir ( $ container -> getParameter ( 'contao.image.target_dir' ) ) ; $ strRootDir = $ container -> getParameter ( 'kernel.project_dir' ) ; foreach ( scan ( $ strRootDir . '/' . $ strTargetPath ) as $ dir ) { if ( strncmp ( $ dir , '.' , 1 ) !== 0 ) { $ objFolder = new Folder ( $ strTargetPath . '/' . $ dir ) ; $ objFolder -> purge ( ) ; } } $ this -> purgePageCache ( ) ; $ this -> log ( 'Purged the image cache' , __METHOD__ , TL_CRON ) ; }
804	private function hasReturnTypeHint ( Tokens $ tokens , $ index ) { $ endFuncIndex = $ tokens -> getPrevTokenOfKind ( $ index , [ ')' ] ) ; $ nextIndex = $ tokens -> getNextMeaningfulToken ( $ endFuncIndex ) ; return $ tokens [ $ nextIndex ] -> isGivenKind ( CT :: T_TYPE_COLON ) ; }
7060	public function removeClass ( $ class ) { $ classes = $ this -> getClasses ( ) ; if ( false !== $ index = array_search ( $ class , $ classes ) ) { unset ( $ classes [ $ index ] ) ; } $ this -> setClasses ( $ classes ) ; return $ this ; }
2946	public function setRolesById ( $ roles ) { $ roles = is_array ( $ roles ) ? $ roles : [ $ roles ] ; return $ this -> roles ( ) -> sync ( $ roles ) ; }
3668	public function generate ( FilterUrl $ filterUrl ) { $ jumpTo = $ filterUrl -> getPage ( ) ; if ( empty ( $ jumpTo [ 'alias' ] ) ) { $ this -> addFromCurrentRequest ( $ filterUrl = $ filterUrl -> clone ( ) , [ ] ) ; $ jumpTo = $ filterUrl -> getPage ( ) ; } $ alias = $ jumpTo [ 'alias' ] ; $ parameters = $ filterUrl -> getGetParameters ( ) ; $ url = $ alias ; if ( $ filterUrl -> hasSlug ( 'auto_item' ) ) { $ url .= '/' . $ this -> encodeForAllowEncodedSlashes ( $ filterUrl -> getSlug ( 'auto_item' ) ) ; } if ( ! empty ( $ jumpTo [ 'domain' ] ) ) { $ parameters [ '_domain' ] = $ jumpTo [ 'domain' ] ; } if ( ! empty ( $ jumpTo [ 'rootUseSSL' ] ) ) { $ parameters [ '_ssl' ] = ( bool ) $ jumpTo [ 'rootUseSSL' ] ; } if ( $ filterUrl -> hasSlug ( 'language' ) ) { $ parameters [ '_locale' ] = $ filterUrl -> getSlug ( 'language' ) ; } foreach ( $ filterUrl -> getSlugParameters ( ) as $ name => $ value ) { if ( in_array ( $ name , [ 'language' , 'auto_item' ] ) ) { continue ; } $ url .= '/' . $ this -> encodeForAllowEncodedSlashes ( $ name ) . '/' . $ this -> encodeForAllowEncodedSlashes ( $ value ) ; } return $ this -> urlGenerator -> generate ( $ url , $ parameters ) ; }
4162	public function searchMedia ( $ lat , $ lng , $ distance = 1000 , $ minTimestamp = NULL , $ maxTimestamp = NULL ) { return $ this -> _makeCall ( 'media/search' , array ( 'lat' => $ lat , 'lng' => $ lng , 'distance' => $ distance , 'min_timestamp' => $ minTimestamp , 'max_timestamp' => $ maxTimestamp ) ) ; }
6054	public function createFolder ( Folder $ folder , $ parentId = 0 , $ inheritAccess = null ) { $ parameters = [ 'query' => [ 'parentId' => $ parentId ] , 'body' => json_encode ( [ 'folder' => $ folder , 'inheritAccess' => $ inheritAccess ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/folders' , $ parameters ) ; $ result = new FolderResponse ( $ result ) ; return $ result ; }
1994	public static function indexPageIfApplicable ( Response $ objResponse ) { global $ objPage ; if ( $ objPage === null ) { return ; } if ( Config :: get ( 'enableSearch' ) && $ objResponse -> getStatusCode ( ) == 200 && ! BE_USER_LOGGED_IN && ! $ objPage -> noSearch ) { if ( Config :: get ( 'indexProtected' ) || ( ! FE_USER_LOGGED_IN && ! $ objPage -> protected ) ) { $ blnIndex = true ; foreach ( array_keys ( $ _GET ) as $ key ) { if ( \ in_array ( $ key , $ GLOBALS [ 'TL_NOINDEX_KEYS' ] ) || strncmp ( $ key , 'page_' , 5 ) === 0 ) { $ blnIndex = false ; break ; } } if ( $ blnIndex ) { $ arrData = array ( 'url' => Environment :: get ( 'base' ) . Environment :: get ( 'relativeRequest' ) , 'content' => $ objResponse -> getContent ( ) , 'title' => $ objPage -> pageTitle ? : $ objPage -> title , 'protected' => ( $ objPage -> protected ? '1' : '' ) , 'groups' => $ objPage -> groups , 'pid' => $ objPage -> id , 'language' => $ objPage -> language ) ; Search :: indexPage ( $ arrData ) ; } } } }
485	public function addCommentOnColumn ( $ table , $ column , $ comment ) { $ time = $ this -> beginCommand ( "add comment on column $column" ) ; $ this -> db -> createCommand ( ) -> addCommentOnColumn ( $ table , $ column , $ comment ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
9339	public function get ( $ key , $ default = null ) { $ keys = array_filter ( explode ( '.' , $ key ) ) ; $ length = count ( $ keys ) ; $ data = $ this -> data ; for ( $ i = 0 ; $ i < $ length ; $ i ++ ) { $ index = $ keys [ $ i ] ; $ data = & $ data [ $ index ] ; } return $ data !== null ? $ data : $ default ; }
870	public function configure ( array $ configuration = null ) { parent :: configure ( $ configuration ) ; $ this -> candidateTokenKind = 'long' === $ this -> configuration [ 'syntax' ] ? CT :: T_DESTRUCTURING_SQUARE_BRACE_OPEN : T_LIST ; }
2971	public static function processAttachments ( array $ attachments ) { $ processed = [ ] ; foreach ( $ attachments as $ attachment ) { if ( ! ( $ attachment instanceof Attachment ) ) { throw new \ InvalidArgumentException ( 'Attachments must implement Stampie\\Attachment' ) ; } $ name = $ attachment -> getName ( ) ; if ( isset ( $ processed [ $ name ] ) ) { $ name = static :: findUniqueName ( $ name , array_keys ( $ processed ) ) ; } $ processed [ $ name ] = $ attachment ; } return $ processed ; }
656	public function init ( ) { if ( $ this -> autoRelease ) { $ locks = & $ this -> _locks ; register_shutdown_function ( function ( ) use ( & $ locks ) { foreach ( $ locks as $ lock ) { $ this -> release ( $ lock ) ; } } ) ; } }
4437	public function set ( string $ name , $ value ) : void { $ this -> client -> call ( 'config.set' , $ name , $ value ) ; }
7084	public function delete_cookie ( $ name ) { unset ( $ _COOKIE [ $ name ] ) ; return setcookie ( $ name , null , - 86400 , $ this -> cookie_path , $ this -> cookie_domain , $ this -> cookie_secure , $ this -> cookie_httponly ) ; }
8169	public static function register ( $ prepend = false ) { @ trigger_error ( 'Using Twig_Autoloader is deprecated since version 1.21. Use Composer instead.' , E_USER_DEPRECATED ) ; if ( PHP_VERSION_ID < 50300 ) { spl_autoload_register ( array ( __CLASS__ , 'autoload' ) ) ; } else { spl_autoload_register ( array ( __CLASS__ , 'autoload' ) , true , $ prepend ) ; } }
5738	public function setDefaultSuffix ( $ defaultSuffix ) { $ this -> defaultSuffix = ( string ) $ defaultSuffix ; $ this -> defaultSuffix = ltrim ( $ this -> defaultSuffix , '.' ) ; return $ this ; }
6155	protected function convertValue ( $ value ) { switch ( $ this -> propertyType -> getDataTypeId ( ) ) { case PropertyType :: DATATYPE_BOOLEAN : return ( bool ) $ value ; break ; case PropertyType :: DATATYPE_DATETIME : if ( $ value instanceof \ DateTime ) { return $ value ; } try { return new \ DateTime ( $ value ) ; } catch ( \ Exception $ e ) { return null ; } break ; case PropertyType :: DATATYPE_FLOAT : return ( float ) $ value ; break ; case PropertyType :: DATATYPE_INTEGER : return ( int ) $ value ; break ; case PropertyType :: DATATYPE_STRING : return ( string ) $ value ; break ; default : return $ value ; break ; } }
6252	protected function createUngroupedGroupPresence ( $ id = null ) { $ id = $ id ? : 'automatic-ungrouped-permissions' ; return new AclPresence ( [ 'type' => AclPresenceType :: GROUP , 'id' => $ id , 'label' => 'acl.ungrouped-permissions' , 'translated' => true , ] ) ; }
2271	public function getUuid ( ) { static $ ids ; if ( empty ( $ ids ) ) { $ statement = $ this -> resConnection -> executeQuery ( implode ( ' UNION ALL ' , array_fill ( 0 , 10 , "SELECT UNHEX(REPLACE(UUID(), '-', '')) AS uuid" ) ) ) ; $ ids = $ statement -> fetchAll ( \ PDO :: FETCH_COLUMN ) ; } return array_pop ( $ ids ) ; }
3225	function createFolder ( $ path ) { Path :: checkArgNonRoot ( "path" , $ path ) ; $ response = $ this -> doPost ( $ this -> apiHost , "1/fileops/create_folder" , array ( "root" => "auto" , "path" => $ path , ) ) ; if ( $ response -> statusCode === 403 ) return null ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; return RequestUtil :: parseResponseJson ( $ response -> body ) ; }
7306	protected function getCustomerFromEvent ( ResourceEventInterface $ event ) { $ resource = $ event -> getResource ( ) ; if ( ! $ resource instanceof CustomerInterface ) { throw new InvalidArgumentException ( 'Expected instance of ' . CustomerInterface :: class ) ; } return $ resource ; }
7225	public function content ( $ decodeJson = false ) { return $ decodeJson && preg_match ( "~^application/json.*~" , $ this -> lastResultType ) && $ this -> lastResult ? from_json ( $ this -> lastResult ) : $ this -> lastResult ; }
1600	public function serialize ( $ record , $ meta = null , array $ links = [ ] ) { $ serializer = clone $ this -> serializer ; $ serializer -> withMeta ( $ meta ) -> withLinks ( $ links ) ; $ serialized = $ serializer -> serializeData ( $ record , $ this -> createEncodingParameters ( ) ) ; $ resourceLinks = null ; if ( empty ( $ serialized [ 'data' ] [ 'id' ] ) ) { unset ( $ serialized [ 'data' ] [ 'id' ] ) ; $ resourceLinks = false ; } $ resource = $ this -> parsePrimaryResource ( $ serialized [ 'data' ] , $ resourceLinks ) ; $ document = [ 'data' => $ resource ] ; if ( isset ( $ serialized [ 'included' ] ) && $ this -> doesSerializeCompoundDocuments ( ) ) { $ document [ 'included' ] = $ this -> parseIncludedResources ( $ serialized [ 'included' ] ) ; } return $ document ; }
9582	public function getFieldValidationOptions ( ) { $ min = ( $ this -> getSetting ( 'MinValue' ) ) ? $ this -> getSetting ( 'MinValue' ) : '' ; $ max = ( $ this -> getSetting ( 'MaxValue' ) ) ? $ this -> getSetting ( 'MaxValue' ) : '' ; return [ new NumericField ( $ this -> getSettingName ( 'MinValue' ) , _t ( 'Moo_EditableField.MINVALUE' , 'Min Value' ) , $ min ) , new NumericField ( $ this -> getSettingName ( 'MaxValue' ) , _t ( 'Moo_EditableField.MAXVALUE' , 'Max Value' ) , $ max ) , ] ; }
3757	public function decodeValue ( DecodePropertyValueForWidgetEvent $ event ) { if ( ! ( $ this -> wantToHandle ( $ event ) && \ in_array ( $ event -> getProperty ( ) , [ 'name' , 'description' ] ) ) ) { return ; } $ metaModel = $ this -> getMetaModelByModelPid ( $ event -> getModel ( ) ) ; $ values = Helper :: decodeLangArray ( $ event -> getValue ( ) , $ metaModel ) ; $ event -> setValue ( unserialize ( $ values , [ 'allowed_classes' => false ] ) ) ; }
5001	public function removeTab ( $ tabName , FormMapper $ formMapper ) { $ tabs = $ this -> getFormTabs ( ) ; if ( array_key_exists ( $ tabName , $ tabs ) ) { $ groups = $ this -> getFormGroups ( ) ; if ( ! is_array ( $ groups ) ) { return ; } foreach ( $ tabs [ $ tabName ] [ 'groups' ] as $ group ) { if ( isset ( $ groups [ $ group ] ) ) { foreach ( $ groups [ $ group ] [ 'fields' ] as $ field ) { $ formMapper -> remove ( $ field ) ; } } unset ( $ groups [ $ group ] ) ; } $ this -> setFormGroups ( $ groups ) ; $ this -> removeEmptyGroups ( ) ; } }
1950	public function resendToken ( Contao \ DataContainer $ dc ) { $ model = Contao \ OptInModel :: findByPk ( $ dc -> id ) ; Contao \ System :: getContainer ( ) -> get ( 'contao.opt-in' ) -> find ( $ model -> token ) -> send ( ) ; Contao \ Message :: addConfirmation ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'resendToken' ] , $ model -> email ) ) ; Contao \ Controller :: redirect ( $ this -> getReferer ( ) ) ; }
11450	public function getParentUri ( ) { if ( $ this -> getParentName ( ) ) { $ func = $ this -> getParentName ( ) ; if ( ! is_string ( $ func ) ) { return ; } $ relat = $ this -> $ func ( ) ; $ parentResourceName = $ relat -> getRelated ( ) -> getResourceName ( ) ; $ field = $ relat -> getForeignKey ( ) ; if ( ! $ this -> $ field ) { return Api :: url ( ) ; } return Api :: url ( ) . '/' . $ parentResourceName . '/' . Api :: encodeHashId ( $ this -> $ field ) ; } return Api :: url ( ) ; }
2613	private function prepareGAReqData ( ) { if ( ! empty ( $ this -> GAReqData ) ) { return $ this -> GAReqData ; } $ mandatoryReqData = [ ] ; $ mandatoryReqData [ 'v' ] = 1 ; $ mandatoryReqData [ 'tid' ] = $ this -> getGATrackingId ( ) ; $ cid = $ this -> config -> getCID ( ) ; $ mandatoryReqData [ 'cid' ] = $ cid ; $ mandatoryReqData [ 'uid' ] = $ cid ; $ mandatoryReqData [ 'ua' ] = $ this -> metaData -> getVersion ( ) ; $ mandatoryReqData [ 'geoid' ] = $ this -> getCountry ( ) ; $ mandatoryReqData [ 'ds' ] = 'Fastly' ; $ customVars = $ this -> prepareCustomVariables ( ) ; $ this -> GAReqData = array_merge ( $ mandatoryReqData , $ customVars ) ; return $ this -> GAReqData ; }
4262	public function subscribe ( $ eventName , $ callable , $ priority = 0 ) { unset ( $ this -> sorted [ $ eventName ] ) ; $ this -> subscribers [ $ eventName ] [ $ priority ] [ ] = $ callable ; }
12826	protected function saveSlotDefinition ( $ dir , array $ slot ) { $ slotsFilename = $ this -> getSlotDefinitionFile ( $ dir ) ; FilesystemTools :: writeFile ( $ slotsFilename , json_encode ( $ slot ) , $ this -> filesystem ) ; }
2396	protected function unixToHex ( $ intTime = 0 ) { $ arrTime = $ intTime ? getdate ( $ intTime ) : getdate ( ) ; $ hexTime = dechex ( ( ( $ arrTime [ 'year' ] - 1980 ) << 25 ) | ( $ arrTime [ 'mon' ] << 21 ) | ( $ arrTime [ 'mday' ] << 16 ) | ( $ arrTime [ 'hours' ] << 11 ) | ( $ arrTime [ 'minutes' ] << 5 ) | ( $ arrTime [ 'seconds' ] >> 1 ) ) ; return pack ( "H*" , $ hexTime [ 6 ] . $ hexTime [ 7 ] . $ hexTime [ 4 ] . $ hexTime [ 5 ] . $ hexTime [ 2 ] . $ hexTime [ 3 ] . $ hexTime [ 0 ] . $ hexTime [ 1 ] ) ; }
3115	public function storeItemHrefIndex ( $ testSessionId , $ table ) { $ extendedState = $ this -> getExtendedState ( $ testSessionId ) ; $ extendedState -> setItemHrefIndex ( $ table ) ; $ extendedState -> save ( ) ; }
9588	protected function isAttributeSet ( SimpleXmlElement $ node , $ name ) { $ attributes = $ node -> attributes ( ) ; return isset ( $ attributes [ $ name ] ) ; }
7885	public function getData ( $ date , $ level = null ) { if ( ! is_string ( $ level ) ) { $ level = 'all' ; } $ data = LogViewer :: data ( $ date , $ level ) ; $ paginator = new Paginator ( $ data , $ this -> perPage ) ; $ path = ( new \ ReflectionClass ( $ paginator ) ) -> getProperty ( 'path' ) ; $ path -> setAccessible ( true ) ; $ path -> setValue ( $ paginator , URL :: route ( 'logviewer.index' ) . '/' . $ date . '/' . $ level ) ; if ( count ( $ data ) > $ paginator -> perPage ( ) ) { $ log = array_slice ( $ data , $ paginator -> firstItem ( ) - 1 , $ paginator -> perPage ( ) ) ; } else { $ log = $ data ; } return View :: make ( 'logviewer::data' , compact ( 'paginator' , 'log' ) ) ; }
10455	public function consume ( ItemPipelineEvent $ event ) { if ( ! $ this -> setItem ( $ event ) ) { return ; } $ this -> log ( sprintf ( 'Start update single document of type %s id: %s' , get_class ( $ this -> getItem ( ) -> getDocument ( ) ) , $ this -> getItem ( ) -> getDocument ( ) -> getId ( ) ) ) ; if ( ! $ this -> persistDocument ( ) ) { return ; } ; $ this -> log ( 'End an update of a single document.' ) ; }
11065	public function icon ( $ level , $ default = null ) { if ( array_key_exists ( $ level , $ this -> icons ) ) { return $ this -> icons [ $ level ] ; } return $ default ; }
9068	protected function convert_value_to_string ( $ value ) { if ( $ this -> is_resource ( $ value ) ) { $ type = get_resource_type ( $ value ) ; return "(Resource:$type)" ; } if ( is_object ( $ value ) ) { if ( $ value instanceof \ Exception || $ value instanceof \ Throwable ) { return '(' . get_class ( $ value ) . "#{$value->getCode()}:{$value->getMessage()})" ; } elseif ( $ value instanceof \ DateTime || ( interface_exists ( '\DateTimeInterface' ) && $ value instanceof \ DateTimeInterface ) ) { return $ value -> format ( \ DateTime :: ATOM ) ; } elseif ( method_exists ( $ value , '__toString' ) ) { return ( string ) $ value ; } else { $ class = get_class ( $ value ) ; return "($class)" ; } } if ( is_array ( $ value ) ) { return '(Array)' ; } if ( is_scalar ( $ value ) ) { return $ value ; } if ( $ value === null ) { return '(Null)' ; } return '(Invalid)' ; }
12355	public function setVariables ( array $ data ) : void { foreach ( $ data as $ key => $ value ) { $ this -> $ key = $ value ; } }
1426	protected function convertIncludePath ( $ path ) { if ( array_key_exists ( $ path , $ this -> includePaths ) ) { return $ this -> includePaths [ $ path ] ? : null ; } return collect ( explode ( '.' , $ path ) ) -> map ( function ( $ segment ) { return $ this -> modelRelationForField ( $ segment ) ; } ) -> implode ( '.' ) ; }
11868	public function destroy ( string $ sessionIdentifier ) : void { if ( ! isset ( self :: $ files [ $ sessionIdentifier ] ) ) { throw new SessionNotFoundException ( ) ; } unset ( self :: $ files [ $ sessionIdentifier ] ) ; }
11875	final public function getModuleDir ( ) { if ( ! $ this -> moduleDir ) { $ reflection = new ReflectionClass ( static :: class ) ; $ this -> moduleDir = dirname ( $ reflection -> getFileName ( ) ) ; } return $ this -> moduleDir ; }
1974	public static function findMultipleByUuidsAndExtensions ( $ arrUuids , $ arrExtensions , array $ arrOptions = array ( ) ) { if ( empty ( $ arrUuids ) || empty ( $ arrExtensions ) || ! \ is_array ( $ arrUuids ) || ! \ is_array ( $ arrExtensions ) ) { return null ; } foreach ( $ arrExtensions as $ k => $ v ) { if ( ! preg_match ( '/^[a-z0-9]{2,5}$/i' , $ v ) ) { unset ( $ arrExtensions [ $ k ] ) ; } } $ t = static :: $ strTable ; foreach ( $ arrUuids as $ k => $ v ) { if ( Validator :: isStringUuid ( $ v ) ) { $ v = StringUtil :: uuidToBin ( $ v ) ; } $ arrUuids [ $ k ] = "UNHEX('" . bin2hex ( $ v ) . "')" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.uuid!=" . implode ( ", $t.uuid!=" , $ arrUuids ) ; } return static :: findBy ( array ( "$t.uuid IN(" . implode ( "," , $ arrUuids ) . ") AND $t.extension IN('" . implode ( "','" , $ arrExtensions ) . "')" ) , null , $ arrOptions ) ; }
8589	public function setReportScheduleList ( $ reportSchedule ) { if ( ! $ this -> _isNumericArray ( $ reportSchedule ) ) { $ reportSchedule = array ( $ reportSchedule ) ; } $ this -> fields [ 'ReportSchedule' ] [ 'FieldValue' ] = $ reportSchedule ; return $ this ; }
4865	public function listing ( array $ options = [ ] ) { $ filter = [ 'queue' => $ this -> getName ( ) ] ; if ( isset ( $ options [ 'status' ] ) ) { $ filter [ 'status' ] = $ options [ 'status' ] ; } $ opt = [ 'sort' => [ 'scheduled' => 1 , 'priority' => 1 ] ] ; if ( isset ( $ options [ 'limit' ] ) ) { $ opt [ 'limit' ] = $ options [ 'limit' ] ; } $ cursor = $ this -> mongoCollection -> find ( $ filter , $ opt ) ; $ jobs = $ cursor -> toArray ( ) ; foreach ( $ jobs as & $ envelope ) { $ envelope [ 'job' ] = $ this -> unserializeJob ( $ envelope [ 'data' ] , [ '__id__' => $ envelope [ '_id' ] ] ) ; } return $ jobs ; }
1935	public function generate ( $ objPage ) { $ this -> redirect ( $ this -> getForwardUrl ( $ objPage ) , $ this -> getRedirectStatusCode ( $ objPage ) ) ; }
1740	public function checkImportantPart ( Contao \ DataContainer $ dc ) { if ( ! $ dc -> id ) { return ; } $ rootDir = Contao \ System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( is_dir ( $ rootDir . '/' . $ dc -> id ) || ! \ in_array ( strtolower ( substr ( $ dc -> id , strrpos ( $ dc -> id , '.' ) + 1 ) ) , Contao \ StringUtil :: trimsplit ( ',' , strtolower ( Contao \ Config :: get ( 'validImageTypes' ) ) ) ) ) { $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'palettes' ] = str_replace ( ',importantPartX,importantPartY,importantPartWidth,importantPartHeight' , '' , $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'palettes' ] ) ; } }
11296	public function getAttributeValueExtended ( $ name , $ convertDates = true ) { if ( isset ( $ this -> model_data [ $ name ] ) ) { $ result = $ this -> model_data [ $ name ] ; if ( $ result instanceof \ DateTime && $ convertDates == true ) { $ result = $ result -> format ( 'Y-m-d H:i:s' ) ; } return $ result ; } if ( isset ( $ this -> data -> { $ name } ) ) { return $ this -> data -> { $ name } ; } else if ( isset ( $ this -> model_extends ) && isset ( $ this -> model_attributes [ $ this -> model_extends ] ) ) { $ extendedModel = $ this -> { $ this -> model_extends } ; if ( $ extendedModel && $ result = $ extendedModel -> getAttributeValue ( $ name ) ) { return $ result ; } } return null ; }
12231	public function copyAttributesFrom ( SimpleXMLElement $ src , $ overwrite = true ) { $ dom = dom_import_simplexml ( $ this ) ; foreach ( dom_import_simplexml ( $ src ) -> attributes as $ attr ) { if ( $ overwrite || ! $ dom -> hasAttributeNS ( $ attr -> namespaceURI , $ attr -> nodeName ) ) { $ dom -> setAttributeNS ( $ attr -> namespaceURI , $ attr -> nodeName , $ attr -> nodeValue ) ; } } return $ this ; }
5609	public function paintGroupStart ( $ message , $ size ) { parent :: paintGroupStart ( $ message , $ size ) ; $ node = new TreemapNode ( 'Group' , $ message ) ; $ this -> _stack -> push ( $ node ) ; }
6951	private function getBaseQueryBuilder ( ) { $ qb = $ this -> getQueryBuilder ( 'r' , 'r.id' ) ; return $ qb -> andWhere ( $ qb -> expr ( ) -> orX ( $ qb -> expr ( ) -> isMemberOf ( ':country' , 'r.countries' ) , 'r.countries IS EMPTY' ) ) -> addOrderBy ( 'r.priority' , 'DESC' ) ; }
2608	public function getCurrentVersion ( array $ versions ) { if ( ! empty ( $ versions ) ) { foreach ( $ versions as $ version ) { if ( $ version -> active ) { return $ activeVersion = $ version -> number ; } } } throw new LocalizedException ( __ ( 'Error fetching current version.' ) ) ; }
1717	public function canEditFieldsOf ( $ table ) { if ( $ this -> isAdmin ) { return true ; } return \ count ( preg_grep ( '/^' . preg_quote ( $ table , '/' ) . '::/' , $ this -> alexf ) ) > 0 ; }
12805	private static function getColumnName ( string $ name ) : ? string { $ class = self :: getStaticChildClass ( ) ; if ( self :: $ columnPropertiesCache === null || ! array_key_exists ( $ class , self :: $ columnPropertiesCache ) || self :: $ columnPropertiesCache [ $ class ] === null ) self :: buildColumnPropertiesCache ( ) ; if ( array_key_exists ( $ name , self :: $ columnPropertiesCache [ $ class ] ) ) return $ name ; foreach ( self :: $ columnPropertiesCache [ $ class ] as $ column => $ properties ) { if ( in_array ( $ name , $ properties ) ) return $ column ; } return null ; }
5247	public function get ( ) { $ child = $ this -> childClassName ; $ query = new QueryBuilder ( ) ; $ query -> filter ( new ParentFilter ( $ this -> parent -> getId ( ) ) ) ; $ collection = $ child :: search ( $ query ) ; $ collection -> each ( function ( ElasticsearchModel $ model ) { $ model -> setParent ( $ this -> parent ) ; } ) ; return $ collection ; }
2151	public function onToggleVisibility ( $ blnDisabled , DataContainer $ dc ) { if ( ! $ dc -> id ) { return $ blnDisabled ; } $ objUser = $ this -> Database -> prepare ( "SELECT email FROM tl_member WHERE id=?" ) -> limit ( 1 ) -> execute ( $ dc -> id ) ; if ( $ objUser -> numRows ) { $ this -> Database -> prepare ( "UPDATE tl_newsletter_recipients SET tstamp=?, active=? WHERE email=?" ) -> execute ( time ( ) , ( $ blnDisabled ? '' : '1' ) , $ objUser -> email ) ; } return $ blnDisabled ; }
6989	private function addRate ( $ pair , $ rate ) { if ( ! preg_match ( '~^[A-Z]{3}/[A-Z]{3}$~' , $ pair ) ) { throw new InvalidArgumentException ( "Unexpected currency pair '$pair'." ) ; } if ( ! ( is_float ( $ rate ) && 0 < $ rate ) ) { throw new InvalidArgumentException ( "Unexpected rate '$rate'." ) ; } $ this -> rates [ $ pair ] = $ rate ; return $ this ; }
4410	public function onBuildView ( CollectViewParametersEvent $ event ) { $ view = $ event -> getView ( ) ; if ( ! $ view instanceof LayoutViewInterface && ! $ view instanceof RuleViewInterface ) { return ; } if ( $ view -> getContext ( ) !== 'ngadminui' ) { return ; } $ event -> addParameter ( 'is_enterprise' , $ this -> isEnterpriseVersion ) ; }
12303	protected function generateSiteMap ( ) { $ urls = array ( ) ; $ siteName = $ this -> configurationHandler -> siteName ( ) ; foreach ( $ this -> pagesCollectionParser -> pages ( ) as $ page ) { foreach ( $ page [ "seo" ] as $ seo ) { $ urls [ ] = array ( 'href' => $ siteName . '/' . $ seo [ "permalink" ] , 'frequency' => $ seo [ "sitemap_frequency" ] , 'priority' => $ seo [ "sitemap_priority" ] , ) ; } } return $ this -> twig -> render ( 'RedKiteCms/Resources/views/Sitemap/sitemap.html.twig' , array ( 'urls' => $ urls ) ) ; }
1960	public static function decode ( $ strDomain ) { if ( $ strDomain == '' ) { return '' ; } $ objPunycode = new Punycode ( ) ; try { return $ objPunycode -> decode ( $ strDomain ) ; } catch ( LabelOutOfBoundsException $ e ) { return '' ; } }
4443	public function multiget ( array $ jids ) : array { if ( empty ( $ jids ) ) { return [ ] ; } $ results = call_user_func_array ( [ $ this -> client , 'multiget' ] , $ jids ) ; $ jobs = json_decode ( $ results , true ) ? : [ ] ; $ ret = [ ] ; foreach ( $ jobs as $ data ) { $ job = new BaseJob ( $ this -> client , $ data ) ; $ job -> setEventsManager ( $ this -> client -> getEventsManager ( ) ) ; $ ret [ $ job -> jid ] = $ job ; } return $ ret ; }
10864	protected function generateHashes ( ) : array { $ dirLength = strlen ( $ this -> dir ) ; foreach ( $ this -> createIterator ( ) as $ file ) { if ( ! $ file -> isFile ( ) ) { continue ; } $ realpath = $ file -> getRealPath ( ) ; $ path = $ file -> getPath ( ) . DIRECTORY_SEPARATOR . $ file -> getFilename ( ) ; if ( $ realpath !== $ path ) { continue ; } $ path = substr ( $ realpath , $ dirLength ) ; $ lowerPath = strtolower ( $ path ) ; if ( isset ( $ this -> hashes [ $ lowerPath ] ) ) { $ message = "duplicate file encountered: $path ($lowerPath)" ; throw new \ RuntimeException ( $ message ) ; } $ this -> hashes [ $ lowerPath ] = sha1_file ( $ realpath ) ; } ksort ( $ this -> hashes ) ; return $ this -> hashes ; }
638	public function addColumn ( $ table , $ column , $ type ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> addColumn ( $ table , $ column , $ type ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; }
9414	public function variance ( ) { $ float_variance = pow ( $ this -> float_sigma , 2 ) ; if ( $ this -> int_precision ) { return round ( $ float_variance , $ this -> int_precision ) ; } return $ float_variance ; }
6924	protected function getFindOneBySaleQuery ( ) { if ( null !== $ this -> findOneBySaleQuery ) { return $ this -> findOneBySaleQuery ; } $ qb = $ this -> createQueryBuilder ( 'r' ) ; $ e = $ qb -> expr ( ) ; return $ this -> findOneBySaleQuery = $ qb -> andWhere ( $ e -> orX ( $ e -> andX ( $ e -> eq ( 'r.vatMode' , ':net_mode' ) , $ e -> lte ( 'r.baseTotal' , ':net_base' ) ) , $ e -> andX ( $ e -> eq ( 'r.vatMode' , ':ati_mode' ) , $ e -> lte ( 'r.baseTotal' , ':ati_base' ) ) ) ) -> andWhere ( $ e -> orX ( 'r.methods IS EMPTY' , $ e -> isMemberOf ( ':method' , 'r.methods' ) ) ) -> andWhere ( $ e -> orX ( 'r.countries IS EMPTY' , $ e -> isMemberOf ( ':country' , 'r.countries' ) ) ) -> andWhere ( $ e -> orX ( 'r.customerGroups IS EMPTY' , $ e -> isMemberOf ( ':group' , 'r.customerGroups' ) ) ) -> andWhere ( $ e -> orX ( 'r.startAt IS NULL' , $ e -> lte ( 'r.startAt' , ':date' ) ) ) -> andWhere ( $ e -> orX ( 'r.endAt IS NULL' , $ e -> gte ( 'r.endAt' , ':date' ) ) ) -> getQuery ( ) -> setMaxResults ( 1 ) -> useQueryCache ( true ) ; }
6813	private function getNumberFormatter ( ) { if ( $ this -> numberFormatter ) { return $ this -> numberFormatter ; } return $ this -> numberFormatter = NumberFormatter :: create ( $ this -> locale , NumberFormatter :: DECIMAL ) ; }
1888	public function generateAjax ( $ id , $ strField , $ level ) { if ( ! Environment :: get ( 'isAjaxRequest' ) ) { return '' ; } $ this -> strField = $ strField ; $ this -> loadDataContainer ( $ this -> strTable ) ; switch ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'dataContainer' ] ) { case 'File' : if ( Config :: get ( $ this -> strField ) != '' ) { $ this -> varValue = Config :: get ( $ this -> strField ) ; } break ; case 'Table' : if ( ! $ this -> Database -> fieldExists ( $ this -> strField , $ this -> strTable ) ) { break ; } $ objField = $ this -> Database -> prepare ( "SELECT " . Database :: quoteIdentifier ( $ this -> strField ) . " FROM " . $ this -> strTable . " WHERE id=?" ) -> limit ( 1 ) -> execute ( $ this -> strId ) ; if ( $ objField -> numRows ) { $ this -> varValue = StringUtil :: deserialize ( $ objField -> { $ this -> strField } ) ; } break ; } $ this -> getPathNodes ( ) ; $ tree = '' ; $ level *= 20 ; $ objPage = $ this -> Database -> prepare ( "SELECT id FROM tl_page WHERE pid=? ORDER BY sorting" ) -> execute ( $ id ) ; while ( $ objPage -> next ( ) ) { $ tree .= $ this -> renderPagetree ( $ objPage -> id , $ level ) ; } return $ tree ; }
8305	public function assertGreaterThan ( $ config , $ keyGreater , $ keyLower ) { if ( ! isset ( $ config [ $ keyLower ] ) || ! isset ( $ config [ $ keyGreater ] ) || $ config [ $ keyLower ] >= $ config [ $ keyGreater ] ) { throw new ConfigurationException ( $ keyGreater . " must be greater than " . $ keyLower ) ; } return $ this ; }
10408	public function addDocumentParameter ( $ field , $ value ) { $ this -> documentParamCache [ md5 ( $ value . $ field ) ] = [ $ field , $ value ] ; }
2794	public function setTempDirectory ( $ dir ) { $ dir = rtrim ( $ dir , ' \\/' ) ; if ( ! is_dir ( $ dir ) || ! is_readable ( $ dir ) ) { throw new InvalidArgumentException ( 'Invalid cache directory: "' . $ dir . '"' ) ; } $ this -> tempDirectory = $ dir ; return $ this ; }
11172	public static function encrypt ( $ data , $ key , $ cipher = MCRYPT_RIJNDAEL_128 , $ mode = MCRYPT_MODE_CBC ) { $ data = serialize ( $ data ) ; $ key = hash ( 'sha256' , $ key , true ) ; $ iv_size = mcrypt_get_iv_size ( $ cipher , $ mode ) ; $ iv = mcrypt_create_iv ( $ iv_size , MCRYPT_RAND ) ; return base64_encode ( serialize ( array ( $ iv , mcrypt_encrypt ( $ cipher , $ key , $ data , $ mode , $ iv ) ) ) ) ; }
6438	public function completeLogin ( $ extrainputs = array ( ) ) { $ request_token = [ ] ; $ request_token [ 'oauth_token' ] = $ this -> request_token [ 'oauth_token' ] ; $ request_token [ 'oauth_token_secret' ] = $ this -> request_token [ 'oauth_token_secret' ] ; $ this -> logQ ( 'session token ' . print_r ( $ request_token , true ) , 'twitter' ) ; $ this -> logQ ( 'extra options ' . print_r ( $ extrainputs , true ) , 'twitter' ) ; if ( isset ( $ extrainputs [ 'oauth_token' ] ) && $ request_token [ 'oauth_token' ] !== $ extrainputs [ 'oauth_token' ] ) { throw new \ Exception ( 'Twitter oauth. Somethign went wrong. No token in the session' ) ; } $ connection = new TwitterOAuth ( $ this -> options [ 'consumer_key' ] , $ this -> options [ 'consumer_secret' ] , $ request_token [ 'oauth_token' ] , $ request_token [ 'oauth_token_secret' ] ) ; $ connection -> setTimeouts ( 10 , 15 ) ; $ access_token = $ connection -> oauth ( "oauth/access_token" , array ( "oauth_verifier" => $ extrainputs [ 'oauth_verifier' ] ) ) ; $ this -> access_token = $ access_token ; return $ this -> getUserProfile ( ) ; }
12525	static function release ( $ token , $ mode , $ opts = array ( ) ) { clearstatcache ( ) ; $ lockDir = self :: lockDir ( $ opts ) ; if ( $ mode == LOCK_EX ) { $ wLockFile = "$lockDir/{$token}_W.lock" ; if ( is_file ( $ wLockFile ) && ! unlink ( $ wLockFile ) ) { pake_echo_error ( "Could not remove W lock file '$wLockFile'" ) ; } return ; } $ rLockFile = "$lockDir/{$token}_R/" . getmypid ( ) . ".lock" ; if ( is_file ( $ rLockFile ) && ! unlink ( $ rLockFile ) ) { pake_echo_error ( "Could not remove R lock file '$rLockFile'" ) ; } }
12679	public static function boot ( ConfigurationHandler $ configurationHandler ) { $ pluginDirs = $ configurationHandler -> pluginFolders ( ) ; foreach ( $ pluginDirs as $ pluginDir ) { self :: $ blocks += self :: parse ( $ pluginDir ) ; } }
4594	public function postLoad ( LifecycleEventArgs $ args ) { $ entity = $ args -> getEntity ( ) ; if ( ! $ entity instanceof Parameter ) { return ; } $ key = $ entity -> getKey ( ) ; $ encrypt = $ this -> parameterCollection -> get ( $ key ) [ 'encrypt' ] ; $ entity -> setEncrypt ( $ encrypt ) ; }
2264	public function tableExists ( $ strTable , $ strDatabase = null , $ blnNoCache = false ) { if ( $ strTable == '' ) { return false ; } return \ in_array ( $ strTable , $ this -> listTables ( $ strDatabase , $ blnNoCache ) ) ; }
600	public function andOnCondition ( $ condition , $ params = [ ] ) { if ( $ this -> on === null ) { $ this -> on = $ condition ; } else { $ this -> on = [ 'and' , $ this -> on , $ condition ] ; } $ this -> addParams ( $ params ) ; return $ this ; }
6411	public static function any ( IteratorAggregate $ iterable , callable $ predicate ) : bool { return Iterators :: any ( Iterators :: from ( $ iterable -> getIterator ( ) ) , $ predicate ) ; }
1161	private function fakeRequiredIfData ( $ data , $ rule , $ parameters ) { if ( $ rule !== 'RequiredIf' ) { return ; } $ newData = $ data ; $ newData [ $ parameters [ 0 ] ] = $ parameters [ 1 ] ; $ this -> validator -> setData ( $ newData ) ; }
7289	protected function watch ( OrderInterface $ order ) { if ( ! $ order -> isAutoNotify ( ) || $ order -> isSample ( ) ) { return ; } if ( $ order -> hasNotifications ( NotificationTypes :: ORDER_ACCEPTED ) ) { return ; } if ( ! $ this -> didStateChangeTo ( $ order , OrderStates :: STATE_ACCEPTED ) ) { return ; } $ this -> notify ( NotificationTypes :: ORDER_ACCEPTED , $ order ) ; }
3804	private function buildCondition ( $ condition , $ metaModel ) { if ( null === $ condition ) { return null ; } return $ this -> conditionFactory -> createCondition ( $ condition , $ metaModel ) ; }
12522	public function renderWidget ( array $ fields , $ customFieldOrClass , $ documentType = 'html' , $ slug = null ) { return $ this -> container -> get ( 'chill.custom_field.helper' ) -> renderCustomField ( $ fields , $ customFieldOrClass , $ documentType , $ slug ) ; }
4299	public function countReset ( $ label = 'default' , $ flags = null ) { $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) ) ; if ( \ count ( $ args ) == 1 && \ is_int ( $ args [ 0 ] ) ) { $ label = 'default' ; $ flags = $ args [ 0 ] ; } else { $ args = \ array_combine ( array ( 'label' , 'flags' ) , \ array_replace ( array ( 'default' , 0 ) , $ args ) ) ; \ extract ( $ args ) ; } if ( isset ( $ this -> data [ 'counts' ] [ $ label ] ) ) { $ this -> data [ 'counts' ] [ $ label ] = 0 ; $ args = array ( ( string ) $ label , 0 , ) ; } else { $ args = array ( 'Counter \'' . $ label . '\' doesn\'t exist.' ) ; } if ( ! ( $ flags & self :: COUNT_NO_OUT ) ) { $ this -> appendLog ( 'countReset' , $ args , $ meta ) ; } }
8285	protected function sessionTimeoutCheck ( $ configKey , $ sessKey , $ clear , $ alwaysUpdate = false ) { if ( $ this -> config [ $ configKey ] !== false ) { $ t = time ( ) ; if ( $ this -> session -> has ( $ sessKey ) ) { if ( $ this -> session -> get ( $ sessKey ) < $ t - $ this -> config [ $ configKey ] ) { if ( $ clear ) { $ this -> session -> invalidate ( ) ; } else { $ this -> session -> migrate ( true ) ; } $ this -> session -> set ( $ sessKey , $ t ) ; } elseif ( $ alwaysUpdate ) { $ this -> session -> set ( $ sessKey , $ t ) ; } } else { $ this -> session -> set ( $ sessKey , $ t ) ; } } }
6452	public function findLabels ( $ text ) { $ xpath = new XPath \ InaccurateText ( '//label[@for]' , $ this -> getWorkingElement ( ) ) ; $ labels = [ ] ; foreach ( $ xpath -> text ( $ text ) -> findAll ( ) as $ label ) { $ labels [ $ label -> getAttribute ( 'for' ) ] = $ label ; } return $ labels ; }
8972	protected function paginate ( array $ rates , $ criteria ) { if ( ! array_key_exists ( 'offset' , $ criteria ) && ! array_key_exists ( 'limit' , $ criteria ) ) { return $ rates ; } $ range = array ( ) ; $ offset = array_key_exists ( 'offset' , $ criteria ) ? $ criteria [ 'offset' ] : 0 ; $ limit = min ( ( array_key_exists ( 'limit' , $ criteria ) ? $ criteria [ 'limit' ] : count ( $ rates ) ) + $ offset , count ( $ rates ) ) ; for ( $ i = $ offset ; $ i < $ limit ; $ i ++ ) { $ range [ ] = $ rates [ $ i ] ; } return $ range ; }
11748	public function page ( ) { if ( is_null ( $ this -> page ) ) { $ this -> page = new Page ( $ this -> accessToken ) ; } return $ this -> page ; }
3542	public static function getExtensionOptions ( $ optionName ) { if ( isset ( Yii :: $ app -> params [ 'yii2-adldap-extension-Options' ] ) && is_array ( Yii :: $ app -> params [ 'yii2-adldap-extension-Options' ] ) && array_key_exists ( $ optionName , Yii :: $ app -> params [ 'yii2-adldap-extension-Options' ] ) ) { return Yii :: $ app -> params [ 'yii2-adldap-extension-Options' ] [ $ optionName ] ; } else if ( array_key_exists ( $ optionName , static :: EXTENSION_OPTIONS_DEFAULT ) ) { return static :: EXTENSION_OPTIONS_DEFAULT [ $ optionName ] ; } else { throw new \ yii \ base \ Exception ( 'Extension-Option ' . $ optionName . ' not found. Please define settings in the config/params.php of the yii2 framework as described on top of the UserDbLdap.php' ) ; } }
4245	private function logPhpInfo ( ) { if ( ! $ this -> debug -> getCfg ( 'logEnvInfo.phpInfo' ) ) { return ; } $ this -> debug -> log ( 'PHP Version' , PHP_VERSION ) ; $ this -> debug -> log ( 'ini location' , \ php_ini_loaded_file ( ) ) ; $ this -> debug -> log ( 'memory_limit' , $ this -> debug -> utilities -> getBytes ( $ this -> debug -> utilities -> memoryLimit ( ) ) ) ; $ this -> debug -> log ( 'session.cache_limiter' , \ ini_get ( 'session.cache_limiter' ) ) ; if ( \ session_module_name ( ) === 'files' ) { $ this -> debug -> log ( 'session_save_path' , \ session_save_path ( ) ? : \ sys_get_temp_dir ( ) ) ; } $ extensionsCheck = array ( 'curl' , 'mbstring' ) ; $ extensionsCheck = \ array_filter ( $ extensionsCheck , function ( $ extension ) { return ! \ extension_loaded ( $ extension ) ; } ) ; if ( $ extensionsCheck ) { $ this -> debug -> warn ( 'These common extensions are not loaded:' , $ extensionsCheck ) ; } $ this -> logPhpInfoEr ( ) ; }
2787	protected function execute ( InputInterface $ input , OutputInterface $ output ) { if ( PHP_SAPI !== 'phpdbg' && ! defined ( 'HHVM_VERSION' ) && ! extension_loaded ( 'xdebug' ) ) { $ output -> writeln ( '<error>You need to install and enable xdebug, or use phpdbg, ' . 'in order to allow for code coverage generation.</error>' ) ; return 1 ; } Performance :: upMemProfiler ( ) ; $ this -> validate ( $ input ) ; $ container = $ this -> container = new Container ( $ input -> getOptions ( ) ) ; $ this -> doConfiguration ( $ input ) ; if ( $ this -> isLoggingEnabled ( ) ) { $ this -> removeOldLogFiles ( ) ; } else { $ output -> writeln ( '<error>No log file is specified. Detailed results ' . 'will not be available.</error>' ) ; $ output -> write ( PHP_EOL ) ; } if ( $ input -> getOption ( 'incremental' ) ) { $ output -> writeln ( '<error>Incremental Analysis is an experimental feature and will very likely</error>' ) ; $ output -> writeln ( '<error>yield inaccurate results at this time.</error>' ) ; $ output -> write ( PHP_EOL ) ; } if ( $ this -> textLogFile ) { $ renderer = new Text ( $ output , true ) ; } else { $ renderer = new Text ( $ output ) ; } $ testSuiteRunner = new UnitTestRunner ( $ container -> getAdapter ( ) , $ container -> getAdapter ( ) -> getProcess ( $ container , true ) , $ container -> getTempDirectory ( ) . '/coverage.humbug.txt' ) ; $ testSuiteRunner -> addObserver ( new LoggingObserver ( $ renderer , $ output , new ProgressBarObserver ( $ input , $ output ) ) ) ; $ result = $ testSuiteRunner -> run ( $ container ) ; if ( ! $ result -> isSuccess ( ) ) { return 1 ; } $ output -> write ( PHP_EOL ) ; $ renderer -> renderStaticAnalysisStart ( ) ; $ output -> write ( PHP_EOL ) ; $ incrementalCache = null ; if ( $ input -> getOption ( 'incremental' ) ) { $ incrementalCache = new IncrementalCache ( $ container ) ; } $ mutationTestingRunner = $ this -> builder -> build ( $ container , $ renderer , $ input , $ output ) ; $ mutationTestingRunner -> run ( $ result -> getCoverage ( ) , $ this -> mutableIterator , $ incrementalCache ) ; if ( $ this -> isLoggingEnabled ( ) ) { $ output -> write ( PHP_EOL ) ; } if ( $ input -> getOption ( 'incremental' ) ) { $ incrementalCache -> write ( ) ; } }
11102	public static function countryCodeThreeToTwo ( $ code ) { if ( ! array_key_exists ( $ code , self :: $ _countryCodes ) ) { return false ; } return self :: $ _countryCodes [ $ code ] ; }
11069	protected function getStatusData ( $ identifier ) { foreach ( $ this -> options [ 'statuses' ] as $ status ) { if ( ( int ) $ status [ 'id' ] === ( int ) $ identifier ) { return $ status ; } } return null ; }
1339	public function add ( ResourceIdentifierInterface $ identifier , $ record ) { if ( ! is_object ( $ record ) && ! is_bool ( $ record ) ) { throw new InvalidArgumentException ( 'Expecting an object or a boolean to add to the identity map.' ) ; } $ existing = $ this -> lookup ( $ identifier ) ; if ( is_object ( $ existing ) && is_bool ( $ record ) ) { throw new InvalidArgumentException ( 'Attempting to push a boolean into the map in place of an object.' ) ; } $ this -> map [ $ identifier -> toString ( ) ] = $ record ; return $ this ; }
765	private function extractUsedParams ( SqlToken $ statement , $ params ) { preg_match_all ( '/(?P<placeholder>[:][a-zA-Z0-9_]+)/' , $ statement -> getSql ( ) , $ matches , PREG_SET_ORDER ) ; $ result = [ ] ; foreach ( $ matches as $ match ) { $ phName = ltrim ( $ match [ 'placeholder' ] , ':' ) ; if ( isset ( $ params [ $ phName ] ) ) { $ result [ $ phName ] = $ params [ $ phName ] ; } elseif ( isset ( $ params [ ':' . $ phName ] ) ) { $ result [ ':' . $ phName ] = $ params [ ':' . $ phName ] ; } } return $ result ; }
9632	public function getSetting ( $ setting ) { $ settings = $ this -> getSettings ( ) ; if ( isset ( $ settings ) && count ( $ settings ) > 0 ) { if ( isset ( $ settings [ $ setting ] ) ) { return $ settings [ $ setting ] ; } } return '' ; }
8973	private function filter ( $ sources , array $ filters = array ( ) ) { $ result = array ( ) ; foreach ( $ sources as $ source ) { if ( SourceFilterUtil :: matches ( $ source , $ filters ) ) { $ result [ ] = $ source ; } } return $ result ; }
10790	protected function quote ( $ str ) { return $ this -> getDialect ( ) -> quote ( $ str , $ this -> getSettings ( ) [ 'autoQuote' ] ? DialectInterface :: QUOTE_YES : DialectInterface :: QUOTE_NO ) ; }
12819	public static function setPermission ( array $ paths ) { foreach ( $ paths as $ path => $ permission ) { echo "chmod('$path', $permission)..." ; if ( is_dir ( $ path ) || is_file ( $ path ) ) { chmod ( $ path , octdec ( $ permission ) ) ; echo "done.\n" ; } else { echo "file not found.\n" ; } } }
11123	public function getUp ( $ time = NOW ) { foreach ( $ this -> movements as $ v ) { if ( $ v -> isActive ( $ time ) ) { $ up = $ v -> getCurrentUp ( $ time ) ; if ( isset ( $ up ) ) { return $ v -> getCurrentUp ( $ time ) ; } } } return new Neuron_GameServer_Map_Vector3 ( 0 , 1 , 0 ) ; }
4104	protected static function parseDsn ( $ dsn ) { $ parts = parse_url ( $ dsn ) ; $ protocol = $ parts [ 'scheme' ] ; $ servers = $ parts [ 'host' ] . ':' . $ parts [ 'port' ] ; if ( isset ( $ parts [ 'path' ] ) ) { $ path = explode ( '/' , $ parts [ 'path' ] ) ; list ( $ index , $ type ) = array_values ( array_filter ( $ path ) ) ; } return compact ( 'protocol' , 'servers' , 'index' , 'type' ) ; }
9231	public function actionIndex ( $ format = false , $ arraymap = false , $ term = false , $ category = false , $ time = false ) { $ searchModel = new PostSearch ( ) ; $ req = Yii :: $ app -> request -> queryParams ; if ( $ term ) { $ req [ basename ( str_replace ( "\\" , "/" , get_class ( $ searchModel ) ) ) ] [ "term" ] = $ term ; } if ( $ category ) { $ req [ basename ( str_replace ( "\\" , "/" , get_class ( $ searchModel ) ) ) ] [ "category" ] = $ category ; } if ( $ time ) { $ req [ basename ( str_replace ( "\\" , "/" , get_class ( $ searchModel ) ) ) ] [ "time" ] = $ time ; } $ dataProvider = $ searchModel -> search ( $ req ) ; $ query = $ dataProvider -> query ; $ query -> andWhere ( [ 'status' => [ 1 ] ] ) ; if ( $ format == 'json' ) { $ model = [ ] ; foreach ( $ dataProvider -> getModels ( ) as $ d ) { $ obj = $ d -> attributes ; if ( $ arraymap ) { $ map = explode ( "," , $ arraymap ) ; if ( count ( $ map ) == 1 ) { $ obj = ( isset ( $ d [ $ arraymap ] ) ? $ d [ $ arraymap ] : null ) ; } else { $ obj = [ ] ; foreach ( $ map as $ a ) { $ k = explode ( ":" , $ a ) ; $ v = ( count ( $ k ) > 1 ? $ k [ 1 ] : $ k [ 0 ] ) ; $ obj [ $ k [ 0 ] ] = ( $ v == "Obj" ? json_encode ( $ d -> attributes ) : ( isset ( $ d -> $ v ) ? $ d -> $ v : null ) ) ; } } } if ( $ term ) { if ( ! in_array ( $ obj , $ model ) ) { array_push ( $ model , $ obj ) ; } } else { array_push ( $ model , $ obj ) ; } } header ( "Access-Control-Allow-Origin: *" ) ; header ( "Access-Control-Expose-Headers: X-Pagination-Per-Page,X-Pagination-Current-Page,X-Pagination-Page-Count,X-Pagination-Total-Count,Content-Type,Location" ) ; return \ yii \ helpers \ Json :: encode ( $ model ) ; } else { return $ this -> render ( 'index' , [ 'searchModel' => $ searchModel , 'dataProvider' => $ dataProvider , ] ) ; } }
8064	public function getFreeAndBusyWorkers ( ) { $ free = $ this -> getFreeWorkers ( ) ; return array ( 'free' => $ free , 'busy' => $ this -> workerPoolSize - $ free , 'total' => $ this -> workerPoolSize ) ; }
2671	public function deleteDictionaryItem ( $ dictionaryId , $ itemKey ) { $ url = $ this -> _getApiServiceUri ( ) . 'dictionary/' . $ dictionaryId . '/item/' . urlencode ( $ itemKey ) ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: DELETE ) ; return $ result ; }
971	public function getToken ( bool $ strict = false ) { $ tokens = [ self :: GRANT_PERUSER => Session :: get ( self :: TOKEN ) , self :: GRANT_OFFLINE => $ this -> shop -> { self :: TOKEN } , ] ; if ( $ strict ) { return $ tokens [ $ this -> getType ( ) ] ; } return $ tokens [ self :: GRANT_PERUSER ] ?? $ tokens [ self :: GRANT_OFFLINE ] ; }
10429	private function initSyncStorageForMysql ( ContainerBuilder $ container , array $ config ) { $ doctrineConnection = sprintf ( 'doctrine.dbal.%s_connection' , $ config [ 'connection' ] ) ; $ definition = $ container -> getDefinition ( 'ongr_connections.sync.storage_manager.mysql_storage_manager' ) ; $ definition -> setArguments ( [ new Reference ( $ doctrineConnection , ContainerInterface :: IGNORE_ON_INVALID_REFERENCE ) , $ config [ 'table_name' ] , ] ) ; $ definition -> addMethodCall ( 'setContainer' , [ new Reference ( 'service_container' ) ] ) ; $ container -> getDefinition ( 'ongr_connections.sync.sync_storage' ) -> setArguments ( [ $ definition ] ) ; }
3841	private function parsePanelFilter ( PanelRowInterface $ row ) { foreach ( $ this -> inputScreen [ 'properties' ] as $ value ) { if ( ! empty ( $ value [ 'filter' ] ) ) { $ element = new DefaultFilterElementInformation ( ) ; $ element -> setPropertyName ( $ value [ 'col_name' ] ) ; if ( ! $ row -> hasElement ( $ element -> getName ( ) ) ) { $ row -> addElement ( $ element ) ; } } } }
341	public static function validate ( $ model , $ attributes = null ) { $ result = [ ] ; if ( $ attributes instanceof Model ) { $ models = func_get_args ( ) ; $ attributes = null ; } else { $ models = [ $ model ] ; } foreach ( $ models as $ model ) { $ model -> validate ( $ attributes ) ; foreach ( $ model -> getErrors ( ) as $ attribute => $ errors ) { $ result [ Html :: getInputId ( $ model , $ attribute ) ] = $ errors ; } } return $ result ; }
9200	public function uploadMedia ( $ filepaths , $ client = null ) { $ maxMediaIds = Config :: get ( 'max_media_ids' ) ; if ( count ( $ filepaths ) > $ maxMediaIds ) { throw new MediaUploadLimitException ( "You cannot upload more than ${maxMediaIds} media files in a tweet!" ) ; } $ mediaIds = array ( ) ; if ( is_null ( $ client ) ) { $ client = $ this -> createGuzzleClient ( Config :: get ( 'base_upload_url' ) ) ; } $ endpoint = $ this -> prependVersionToEndpoint ( "media/upload.json" , Config :: get ( 'api_version' ) ) ; foreach ( $ filepaths as $ filepath ) { $ options = $ this -> constructRequestOptions ( array ( ) , $ client ) ; $ options [ 'body' ] = array ( 'media' => new PostFile ( 'media' , fopen ( $ filepath , 'r' ) ) ) ; $ response = $ client -> post ( $ endpoint , $ options ) ; array_push ( $ mediaIds , $ response -> json ( ) [ 'media_id_string' ] ) ; } return ( implode ( "," , $ mediaIds ) ) ; }
3089	protected function alterTimeoutCallValue ( array $ options ) { $ timeoutValue = null ; if ( $ this -> isInitialCall === true ) { if ( $ this -> hasOption ( self :: OPTION_INITIAL_CALL_TIMEOUT ) ) { $ timeoutValue = $ this -> getOption ( self :: OPTION_INITIAL_CALL_TIMEOUT ) ; } } else { if ( $ this -> hasOption ( self :: OPTION_NEXT_ITEM_CALL_TIMEOUT ) ) { $ timeoutValue = $ this -> getOption ( self :: OPTION_NEXT_ITEM_CALL_TIMEOUT ) ; } } if ( ! is_null ( $ timeoutValue ) ) { $ options [ self :: OPTION_ENGINE_CLIENT ] [ 'options' ] [ 'http_client_options' ] [ 'timeout' ] = $ timeoutValue ; } return $ options ; }
7761	protected function validateMappingConfiguration ( array $ mappingConfig , $ mappingName ) { if ( ! $ mappingConfig [ 'type' ] || ! $ mappingConfig [ 'dir' ] || ! $ mappingConfig [ 'prefix' ] ) { throw new \ InvalidArgumentException ( sprintf ( 'Hydra mapping definitions for "%s" require at least the "type", "dir" and "prefix" options.' , $ mappingName ) ) ; } if ( ! is_dir ( $ mappingConfig [ 'dir' ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Specified non-existing directory "%s" as Hydra mapping source.' , $ mappingConfig [ 'dir' ] ) ) ; } if ( ! in_array ( $ mappingConfig [ 'type' ] , array ( 'xml' , 'yml' , 'annotation' , 'php' , 'staticphp' ) ) ) { throw new \ InvalidArgumentException ( 'Can only configure "xml", "yml", "annotation", "php" or ' . '"staticphp" through the HydraBundle. Use your own bundle to configure other metadata drivers. ' . 'You can register them by adding a new driver to the ' . '"hydra.metadata_driver" service definition.' ) ; } }
10493	public function mul ( $ value ) { $ value = Cast :: Float ( $ value ) ; if ( $ this -> value === null ) { return new FloatType ( $ this -> value ) ; } return new FloatType ( $ this -> value * $ value ) ; }
4142	protected function getOauthString ( ) { $ oauth = array_merge ( $ this -> getOauthParameters ( ) , array ( 'oauth_signature' => $ this -> calculateSignature ( ) ) ) ; ksort ( $ oauth ) ; $ values = array ( ) ; foreach ( $ oauth as $ key => $ value ) { $ values [ ] = $ key . '="' . rawurlencode ( $ value ) . '"' ; } $ oauth = implode ( ', ' , $ values ) ; unset ( $ values , $ key , $ value ) ; return $ oauth ; }
7489	public function insert ( $ offset , $ string ) { $ offset = ( int ) $ offset ; $ string = static :: convertString ( $ string , $ this -> encoding ) ; if ( $ offset < 0 || $ offset >= $ this -> length ( ) ) { throw new \ OutOfBoundsException ( ) ; } $ this -> string = mb_substr ( $ this -> string , 0 , $ offset , $ this -> encoding ) . $ string . mb_substr ( $ this -> string , $ offset , $ this -> length ( ) , $ this -> encoding ) ; return $ this ; }
11552	public function removeConsignment ( ConsignmentInterface $ consignment ) { $ adapter = $ this -> getAdapter ( $ consignment ) ; $ event = new EventConsignment ( $ consignment ) ; $ this -> eventDispatcher -> dispatch ( Events :: PRE_CONSIGNMENT_REMOVE , $ event ) ; if ( $ consignment -> getStatus ( ) != ConsignmentStatusList :: STATUS_NEW ) { throw new OperationNotPermittedException ( sprintf ( 'Can not remove Consignment "%s" with status "%s"' , $ consignment -> getId ( ) , $ consignment -> getStatus ( ) ) ) ; } try { $ adapter -> removeConsignment ( $ consignment ) ; $ this -> consignmentRepository -> removeConsignment ( $ consignment ) ; } catch ( \ Exception $ e ) { throw new VendorAdapterException ( 'Error during consignment removing.' , null , $ e ) ; } $ event = new EventConsignment ( $ consignment ) ; $ this -> eventDispatcher -> dispatch ( Events :: POST_CONSIGNMENT_REMOVE , $ event ) ; }
5533	public function paintRectangleStart ( $ node , $ horiz , $ vert ) { $ name = $ node -> getName ( ) ; $ description = $ node -> getDescription ( ) ; $ status = $ node -> getStatus ( ) ; echo "<div title=\"$name: $description\" class=\"$status\" style=\"width:{$horiz}%;height:{$vert}%\">" ; }
8341	public static function init ( ) { if ( self :: $ isInit === false ) { self :: $ prettyPageHandler = new PrettyPageHandler ( ) ; self :: $ prettyPageHandler -> setPageTitle ( 'I just broke a string... - strayFw' ) ; $ whoops = new Run ( ) ; $ whoops -> pushHandler ( new JsonResponseHandler ( ) ) ; $ whoops -> pushHandler ( self :: $ prettyPageHandler ) ; $ whoops -> register ( ) ; self :: $ isInit = true ; } }
7848	private function checkConfig ( ) : void { if ( empty ( $ this -> device ) ) { Log :: warning ( 'Config "message.smsgatewayme.device" is not defined.' ) ; } if ( empty ( $ this -> token ) ) { Log :: warning ( 'Config "message.smsgatewayme.token" is not defined.' ) ; } }
3403	protected function loadFromYml ( $ file ) { $ this -> parser = new Parser ( $ file ) ; $ this -> parser -> load ( $ this ) ; }
12026	private function generateExecuteDocBlock ( $ methodDescription ) { $ responseClass = $ this -> operationDefinition -> getResponseClass ( ) ; $ docBlock = new DocBlockGenerator ( $ methodDescription , null ) ; if ( $ responseClass ) { $ tags [ ] = new GenericTag ( 'return' , '\\' . $ responseClass ) ; } else { $ tags [ ] = new GenericTag ( 'return' , 'mixed' ) ; } $ docBlock -> setTags ( $ tags ) ; return $ docBlock ; }
8584	public function setASIN ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ASIN' ] [ 'FieldValue' ] = $ value ; return $ this ; }
12758	public static function getNew ( ) { $ class = new MediaLink ; $ medialink = get_class_vars ( get_class ( $ class ) ) ; foreach ( $ medialink as $ name => $ default ) : $ class :: set ( $ name , null ) ; $ class :: set ( "objectType" , "medialink" ) ; endforeach ; return $ class ; }
2040	private function createConfigItem ( $ imageSize ) : PictureConfigurationItem { $ configItem = new PictureConfigurationItem ( ) ; $ resizeConfig = new ResizeConfiguration ( ) ; if ( null !== $ imageSize ) { $ resizeConfig -> setWidth ( $ imageSize -> width ) -> setHeight ( $ imageSize -> height ) -> setMode ( $ imageSize -> resizeMode ) -> setZoomLevel ( $ imageSize -> zoom ) ; $ configItem -> setResizeConfig ( $ resizeConfig ) -> setSizes ( $ imageSize -> sizes ) -> setDensities ( $ imageSize -> densities ) ; if ( isset ( $ imageSize -> media ) ) { $ configItem -> setMedia ( $ imageSize -> media ) ; } } return $ configItem ; }
7976	public function addSecondaryDnsDomains ( $ domain2add , $ ip ) { self :: getClient ( ) -> addSecondaryDnsDomains ( $ this -> getDomain ( ) , $ domain2add , $ ip ) ; return true ; }
1128	public function isSelfOrAncestorOf ( $ other ) { return ( $ this -> getLeft ( ) <= $ other -> getLeft ( ) && $ this -> getRight ( ) > $ other -> getLeft ( ) && $ this -> inSameScope ( $ other ) ) ; }
1851	public function generate ( $ rootPageId , $ blnReturn = false , $ blnPreferAlias = false ) { if ( ! $ blnReturn ) { $ this -> redirect ( $ this -> getRedirectUrl ( $ rootPageId ) , 302 ) ; } $ objNextPage = $ this -> getNextPage ( $ rootPageId ) ; return ( $ blnPreferAlias && $ objNextPage -> alias != '' ) ? $ objNextPage -> alias : $ objNextPage -> id ; }
12839	static public function generateFilename ( $ directory , $ extension , $ length = 16 ) { do { $ name = \ Extlib \ Generator :: generate ( $ length ) ; $ filepath = rtrim ( $ directory , DIRECTORY_SEPARATOR ) . DIRECTORY_SEPARATOR . sprintf ( '%s.%s' , $ name , $ extension ) ; } while ( file_exists ( $ filepath ) ) ; return $ name ; }
4354	protected function setFile ( $ file ) { if ( $ file == $ this -> file ) { return ; } if ( $ this -> fileHandle ) { \ fclose ( $ this -> fileHandle ) ; $ this -> fileHandle = null ; } $ this -> file = $ file ; if ( empty ( $ file ) ) { return ; } $ fileExists = \ file_exists ( $ file ) ; $ this -> fileHandle = \ fopen ( $ file , 'a' ) ; if ( $ this -> fileHandle ) { \ fwrite ( $ this -> fileHandle , '***** ' . \ date ( 'Y-m-d H:i:s' ) . ' *****' . "\n" ) ; if ( ! $ fileExists ) { \ chmod ( $ file , 0660 ) ; } } }
2347	public function getContent ( ) { $ strContent = file_get_contents ( $ this -> strRootDir . '/' . ( $ this -> strTmp ? : $ this -> strFile ) ) ; if ( strncmp ( $ strContent , "\xEF\xBB\xBF" , 3 ) === 0 ) { $ strContent = substr ( $ strContent , 3 ) ; } elseif ( strncmp ( $ strContent , "\xFF\xFE" , 2 ) === 0 ) { $ strContent = substr ( $ strContent , 2 ) ; } elseif ( strncmp ( $ strContent , "\xFE\xFF" , 2 ) === 0 ) { $ strContent = substr ( $ strContent , 2 ) ; } return $ strContent ; }
5852	protected function processData ( ) { $ close = GeneralUtility :: _GP ( 'closeDoc' ) ; $ save = GeneralUtility :: _GP ( '_savedok' ) ; $ saveAndClose = GeneralUtility :: _GP ( '_saveandclosedok' ) ; if ( $ save || $ saveAndClose ) { $ table = static :: virtualTable ; $ id = static :: virtualRecordId ; $ field = 'rulesets' ; $ inputData_tmp = GeneralUtility :: _GP ( 'data' ) ; $ data = $ inputData_tmp [ $ table ] [ $ id ] ; if ( count ( $ inputData_tmp [ $ table ] ) > 1 ) { foreach ( $ inputData_tmp [ $ table ] as $ key => $ values ) { if ( $ key === $ id ) continue ; ArrayUtility :: mergeRecursiveWithOverrule ( $ data , $ values ) ; } } $ newConfig = $ this -> config ; ArrayUtility :: mergeRecursiveWithOverrule ( $ newConfig , $ data ) ; $ ffValue = & $ data [ $ field ] ; if ( $ ffValue ) { $ actionCMDs = GeneralUtility :: _GP ( '_ACTION_FLEX_FORMdata' ) ; if ( is_array ( $ actionCMDs [ $ table ] [ $ id ] [ $ field ] [ 'data' ] ) ) { $ dataHandler = new CustomDataHandler ( ) ; $ dataHandler -> _ACTION_FLEX_FORMdata ( $ ffValue [ 'data' ] , $ actionCMDs [ $ table ] [ $ id ] [ $ field ] [ 'data' ] ) ; } $ this -> persistFlexForm ( $ ffValue [ 'data' ] ) ; $ newConfig [ $ field ] = $ ffValue ; } $ localconfConfig = $ newConfig ; $ localconfConfig [ 'conversion_mapping' ] = implode ( ',' , GeneralUtility :: trimExplode ( LF , $ localconfConfig [ 'conversion_mapping' ] , true ) ) ; if ( $ this -> persistConfiguration ( $ localconfConfig ) ) { $ this -> config = $ newConfig ; } } if ( $ close || $ saveAndClose ) { $ closeUrl = BackendUtility :: getModuleUrl ( 'tools_ExtensionmanagerExtensionmanager' ) ; \ TYPO3 \ CMS \ Core \ Utility \ HttpUtility :: redirect ( $ closeUrl ) ; } }
8637	public function setOrderFeeList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'OrderFeeList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
8907	public function get_next_id ( ) { return ( int ) $ this -> _database -> select ( 'AUTO_INCREMENT' ) -> from ( 'information_schema.TABLES' ) -> where ( 'TABLE_NAME' , $ this -> _database -> dbprefix ( $ this -> get_table ( ) ) ) -> where ( 'TABLE_SCHEMA' , $ this -> _database -> database ) -> get ( ) -> row ( ) -> AUTO_INCREMENT ; }
9432	protected static function random ( $ float_min , $ float_max ) { if ( $ float_max >= 0 ) { $ r = new Random ( ) ; while ( true ) { $ float_prov = $ float_max * $ r -> get ( ) ; if ( $ float_prov >= $ float_min ) { return $ float_prov ; } } } else { $ r = new Random ( ) ; while ( true ) { $ float_prov = $ float_min * $ r -> get ( ) ; if ( $ float_prov <= $ float_max ) { return $ float_prov ; } } } }
1653	public function getArea ( ) : float { $ area = 0 ; if ( $ this -> getNumberOfPoints ( ) <= 2 ) { return $ area ; } $ referencePoint = $ this -> points [ 0 ] ; $ radius = $ referencePoint -> getEllipsoid ( ) -> getArithmeticMeanRadius ( ) ; $ segments = $ this -> getSegments ( ) ; foreach ( $ segments as $ segment ) { $ point1 = $ segment -> getPoint1 ( ) ; $ point2 = $ segment -> getPoint2 ( ) ; $ x1 = deg2rad ( $ point1 -> getLng ( ) - $ referencePoint -> getLng ( ) ) * cos ( deg2rad ( $ point1 -> getLat ( ) ) ) ; $ y1 = deg2rad ( $ point1 -> getLat ( ) - $ referencePoint -> getLat ( ) ) ; $ x2 = deg2rad ( $ point2 -> getLng ( ) - $ referencePoint -> getLng ( ) ) * cos ( deg2rad ( $ point2 -> getLat ( ) ) ) ; $ y2 = deg2rad ( $ point2 -> getLat ( ) - $ referencePoint -> getLat ( ) ) ; $ area += ( $ x2 * $ y1 - $ x1 * $ y2 ) ; } $ area *= 0.5 * $ radius ** 2 ; return ( float ) abs ( $ area ) ; }
2660	public function getRequest ( $ version , $ name ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/request_settings/' . $ name ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: GET , '' , false , null , false ) ; return $ result ; }
12799	public function getFilePointer ( ) { if ( ! isset ( $ this -> _filePointer ) ) { ini_set ( 'auto_detect_line_endings' , true ) ; $ this -> _filePointer = false ; $ file = null ; if ( isset ( $ this -> local ) && file_exists ( $ this -> local ) ) { $ file = $ this -> local ; $ pathinfo = pathinfo ( $ this -> local ) ; } elseif ( isset ( $ this -> url ) ) { $ fileCacheKey = md5 ( __CLASS__ . __FUNCTION__ . $ this -> url ) ; $ fileContent = Yii :: $ app -> fileCache -> get ( $ fileCacheKey ) ; $ pathinfo = pathinfo ( $ this -> url ) ; $ file = Yii :: $ app -> fileStorage -> getTempFile ( false , $ pathinfo [ 'extension' ] ) ; if ( $ fileContent ) { file_put_contents ( $ file , $ fileContent ) ; } else { if ( ! $ this -> downloadFile ( $ this -> url , $ file ) ) { $ file = null ; } else { Yii :: $ app -> fileCache -> set ( $ fileCacheKey , file_get_contents ( $ file ) , 86400 ) ; } } } if ( isset ( $ file ) ) { $ file = $ this -> normalizeFile ( $ file ) ; } if ( file_exists ( $ file ) ) { $ this -> _filePointer = fopen ( $ file , 'r' ) ; } } return $ this -> _filePointer ; }
12706	public static function getAllCommands ( ) : array { $ commands = [ ] ; foreach ( get_declared_classes ( ) as $ class ) { if ( is_subclass_of ( $ class , 'Senhung\CLI\Command' ) ) { $ commandObject = new $ class ; $ command = $ commandObject -> getCommand ( ) ; $ commands [ $ command ] = $ class ; } } return $ commands ; }
780	public function getValue ( $ name , $ defaultValue = null ) { return isset ( $ this -> _cookies [ $ name ] ) ? $ this -> _cookies [ $ name ] -> value : $ defaultValue ; }
2928	public function getKeys ( $ keys = [ ] ) { $ allKeys = $ this -> reader -> keys ( ) ; return array_filter ( $ allKeys , function ( $ key ) use ( $ keys ) { if ( ! empty ( $ keys ) ) { return in_array ( $ key , $ keys ) ; } return true ; } , ARRAY_FILTER_USE_KEY ) ; }
12692	public function synchronize ( Page $ page , array $ pages ) { if ( ! $ this -> configurationHandler -> isTheme ( ) ) { return ; } foreach ( $ pages as $ pageValues ) { $ tokens = explode ( "_" , $ pageValues [ "seo" ] [ 0 ] [ "language" ] ) ; $ pageOptions = array ( 'page' => $ pageValues [ "name" ] , 'language' => $ tokens [ 0 ] , 'country' => $ tokens [ 1 ] , ) ; $ page -> render ( $ this -> configurationHandler -> siteDir ( ) , $ pageOptions ) ; $ this -> saveTemplateSlots ( $ page -> getPageSlots ( ) , $ pageValues [ "template" ] ) ; } $ this -> saveTemplateSlots ( $ page -> getCommonSlots ( ) , 'base' ) ; }
5574	public function clickSubmit ( $ label = 'Submit' , $ additional = false ) { if ( ! ( $ form = $ this -> page -> getFormBySubmit ( new SelectByLabel ( $ label ) ) ) ) { return false ; } $ success = $ this -> load ( $ form -> getAction ( ) , $ form -> submitButton ( new SelectByLabel ( $ label ) , $ additional ) ) ; return ( $ success ? $ this -> getContent ( ) : $ success ) ; }
3030	public function pauseSession ( AssessmentTestSession $ session ) { $ session -> updateDuration ( ) ; return $ this -> getDeliveryExecution ( $ session ) -> setState ( DeliveryExecution :: STATE_PAUSED ) ; }
9496	public function getCollection ( $ end_point , $ collectionName , $ page = 1 , $ per_page = 100 , $ sort_by = null , $ sort_order = 'asc' ) { $ end_point = strtolower ( $ end_point ) ; if ( strpos ( $ end_point , 'http' ) !== 0 ) { $ end_point = $ this -> api -> getApiUrl ( ) . $ end_point ; } $ request = $ this -> api -> get ( $ end_point ) ; $ query = $ request -> getQuery ( ) -> set ( 'page' , $ page ) -> set ( 'per_page' , $ per_page ) ; if ( $ sort_by ) { $ query -> set ( 'sort_by' , $ sort_by ) -> set ( 'sort_order' , $ sort_order == 'asc' ? 'asc' : 'desc' ) ; } $ response = $ this -> processRequest ( $ request ) ; $ values = $ response -> json ( ) ; $ result = new PaginatedResult ( ) ; $ result -> setClient ( $ this ) ; if ( array_key_exists ( 'count' , $ values ) ) { $ result -> setCount ( $ values [ 'count' ] ) ; } $ result -> setCurrentPage ( $ page ) ; $ result -> setPerPage ( $ per_page ) ; $ result -> setEndPoint ( $ end_point ) ; $ type = $ this -> getType ( ) ; if ( array_key_exists ( $ collectionName , $ values ) && is_array ( $ values [ $ collectionName ] ) ) { foreach ( $ values [ $ collectionName ] as $ value ) { $ entity = new $ type ( ) ; $ this -> manage ( $ entity ) ; $ result [ ] = $ entity -> fromArray ( $ value ) ; } } return $ result ; }
10375	protected static function validate ( $ type , $ data , $ admin ) { $ place = ( isset ( $ data [ 'place' ] ) ) ? $ data [ 'place' ] : 'front' ; $ place = $ admin && 'admin' == $ place || ! $ admin && 'front' == $ place ; if ( ! $ place || self :: set_params ( $ type , $ data ) === false ) { return false ; } return true ; }
11414	public function decryptData ( $ sessionKey , $ iv , $ encrypted ) { try { $ decrypted = openssl_decrypt ( base64_decode ( $ encrypted , true ) , 'aes-128-cbc' , base64_decode ( $ sessionKey , true ) , OPENSSL_RAW_DATA | OPENSSL_NO_PADDING , base64_decode ( $ iv , true ) ) ; } catch ( Exception $ e ) { throw new EncryptionException ( $ e -> getMessage ( ) , EncryptionException :: ERROR_DECRYPT_AES ) ; } if ( is_null ( $ result = json_decode ( $ this -> decode ( $ decrypted ) , true ) ) ) { throw new EncryptionException ( 'ILLEGAL_BUFFER' , EncryptionException :: ILLEGAL_BUFFER ) ; } return $ result ; }
290	public function __isset ( $ name ) { try { return $ this -> __get ( $ name ) !== null ; } catch ( \ Throwable $ t ) { return false ; } catch ( \ Exception $ e ) { return false ; } }
10277	public static function getDefaultRowHeightByFont ( \ PhpOffice \ PhpSpreadsheet \ Style \ Font $ font ) { switch ( $ font -> getName ( ) ) { case 'Arial' : switch ( $ font -> getSize ( ) ) { case 10 : $ rowHeight = 12.75 ; break ; case 9 : $ rowHeight = 12 ; break ; case 8 : $ rowHeight = 11.25 ; break ; case 7 : $ rowHeight = 9 ; break ; case 6 : case 5 : $ rowHeight = 8.25 ; break ; case 4 : $ rowHeight = 6.75 ; break ; case 3 : $ rowHeight = 6 ; break ; case 2 : case 1 : $ rowHeight = 5.25 ; break ; default : $ rowHeight = 12.75 * $ font -> getSize ( ) / 10 ; break ; } break ; case 'Calibri' : switch ( $ font -> getSize ( ) ) { case 11 : $ rowHeight = 15 ; break ; case 10 : $ rowHeight = 12.75 ; break ; case 9 : $ rowHeight = 12 ; break ; case 8 : $ rowHeight = 11.25 ; break ; case 7 : $ rowHeight = 9 ; break ; case 6 : case 5 : $ rowHeight = 8.25 ; break ; case 4 : $ rowHeight = 6.75 ; break ; case 3 : $ rowHeight = 6.00 ; break ; case 2 : case 1 : $ rowHeight = 5.25 ; break ; default : $ rowHeight = 15 * $ font -> getSize ( ) / 11 ; break ; } break ; case 'Verdana' : switch ( $ font -> getSize ( ) ) { case 10 : $ rowHeight = 12.75 ; break ; case 9 : $ rowHeight = 11.25 ; break ; case 8 : $ rowHeight = 10.50 ; break ; case 7 : $ rowHeight = 9.00 ; break ; case 6 : case 5 : $ rowHeight = 8.25 ; break ; case 4 : $ rowHeight = 6.75 ; break ; case 3 : $ rowHeight = 6 ; break ; case 2 : case 1 : $ rowHeight = 5.25 ; break ; default : $ rowHeight = 12.75 * $ font -> getSize ( ) / 10 ; break ; } break ; default : $ rowHeight = 15 * $ font -> getSize ( ) / 11 ; break ; } return $ rowHeight ; }
11712	protected function performAjaxValidation ( $ models ) { if ( \ Yii :: $ app -> request -> isAjax ) { if ( is_array ( $ models ) ) { $ result = [ ] ; foreach ( $ models as $ model ) { if ( $ model -> load ( \ Yii :: $ app -> request -> post ( ) ) ) { \ Yii :: $ app -> response -> format = Response :: FORMAT_JSON ; $ result = array_merge ( $ result , ActiveForm :: validate ( $ model ) ) ; } } echo json_encode ( $ result ) ; \ Yii :: $ app -> end ( ) ; } else { if ( $ models -> load ( \ Yii :: $ app -> request -> post ( ) ) ) { \ Yii :: $ app -> response -> format = Response :: FORMAT_JSON ; echo json_encode ( ActiveForm :: validate ( $ models ) ) ; \ Yii :: $ app -> end ( ) ; } } } }
8722	public function translate ( $ locale ) { $ found = $ this -> translations -> where ( $ this -> getLocaleKey ( ) , $ locale ) -> first ( ) ; if ( ! $ found && $ this -> shouldFallback ( $ locale ) ) { return $ this -> translate ( $ this -> getFallbackLocale ( ) ) ; } return $ found ; }
12053	public function set ( $ name , AbstractModule $ module ) { $ this -> container [ ( string ) $ name ] = $ module ; return $ this ; }
5615	public function paintGroupEnd ( $ message ) { $ node = $ this -> _stack -> pop ( ) ; $ current = $ this -> _stack -> peek ( ) ; if ( $ current ) { if ( $ node -> isFailed ( ) ) { $ current -> fail ( ) ; } $ current -> putChild ( $ node ) ; } else { $ this -> _graph = $ node ; } parent :: paintGroupEnd ( $ message ) ; }
6446	public function completeLogin ( $ extrainputs = array ( ) ) { $ linkedin = $ this -> getClient ( ) ; $ this -> token = $ linkedin -> getAccessToken ( $ extrainputs [ 'code' ] ) ; return $ this -> getUserProfile ( ) ; }
5772	public function getRolesString ( ) : string { $ rolesString = "" ; foreach ( $ this -> roleNames as $ role ) { $ rolesString .= "$role, " ; } return Functions :: removeLastCharsFromString ( $ rolesString , 2 ) ; }
38	protected function initStyles ( OutputInterface $ output ) { $ this -> colors = array ( 'green' , 'yellow' , 'cyan' , 'magenta' , 'blue' , ) ; foreach ( $ this -> colors as $ color ) { $ style = new OutputFormatterStyle ( $ color ) ; $ output -> getFormatter ( ) -> setStyle ( $ color , $ style ) ; } }
10158	private function readMulBlank ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; $ row = self :: getUInt2d ( $ recordData , 0 ) ; $ fc = self :: getUInt2d ( $ recordData , 2 ) ; if ( ! $ this -> readDataOnly && $ this -> readEmptyCells ) { for ( $ i = 0 ; $ i < $ length / 2 - 3 ; ++ $ i ) { $ columnString = Coordinate :: stringFromColumnIndex ( $ fc + $ i + 1 ) ; if ( ( $ this -> getReadFilter ( ) !== null ) && $ this -> getReadFilter ( ) -> readCell ( $ columnString , $ row + 1 , $ this -> phpSheet -> getTitle ( ) ) ) { $ xfIndex = self :: getUInt2d ( $ recordData , 4 + 2 * $ i ) ; $ this -> phpSheet -> getCell ( $ columnString . ( $ row + 1 ) ) -> setXfIndex ( $ this -> mapCellXfIndex [ $ xfIndex ] ) ; } } } }
6670	public function get_movie_rating ( $ votes ) { $ votations = [ ] ; foreach ( $ votes as $ key => $ value ) { for ( $ i = 0 ; $ i < $ value ; $ i ++ ) { $ votations [ ] = $ key ; } } if ( count ( $ votations ) ) { $ rating = array_sum ( $ votations ) / count ( $ votations ) ; return round ( $ rating , 1 ) ; } return 'N/A' ; }
1158	protected function ruleAfter ( $ attribute , array $ parameters ) { if ( ! ( $ date = strtotime ( $ parameters [ 0 ] ) ) ) { $ date = $ this -> getAttributeName ( $ parameters [ 0 ] ) ; } return [ $ attribute , [ $ date ] ] ; }
221	protected function normalizeNumericValue ( $ value ) { if ( empty ( $ value ) ) { return 0 ; } if ( is_string ( $ value ) && is_numeric ( $ value ) ) { $ value = ( float ) $ value ; } if ( ! is_numeric ( $ value ) ) { throw new InvalidArgumentException ( "'$value' is not a numeric value." ) ; } return $ value ; }
3713	public function isNestedType ( ) { if ( ! isset ( $ this -> isNestedType ) ) { $ this -> isNestedType = in_array ( 'MetaModels\Filter\Setting\IWithChildren' , class_implements ( $ this -> typeClass , true ) ) ; } return $ this -> isNestedType ; }
11200	public function checkIfSingleton ( $ name , $ item ) { if ( isset ( $ this -> signaturesToSingletons -> $ name ) and $ this -> signaturesToSingletons -> $ name ) { $ this -> $ name = $ item ; $ this -> signaturesToSingletons = false ; } }
4076	protected function getMetaModelName ( $ nameOrId ) { return isset ( $ this -> tableMap [ $ nameOrId ] ) ? $ this -> tableMap [ $ nameOrId ] : $ nameOrId ; }
9883	private function writeDefinedNames ( XMLWriter $ objWriter , Spreadsheet $ spreadsheet ) { $ objWriter -> startElement ( 'definedNames' ) ; if ( count ( $ spreadsheet -> getNamedRanges ( ) ) > 0 ) { $ this -> writeNamedRanges ( $ objWriter , $ spreadsheet ) ; } $ sheetCount = $ spreadsheet -> getSheetCount ( ) ; for ( $ i = 0 ; $ i < $ sheetCount ; ++ $ i ) { $ this -> writeDefinedNameForAutofilter ( $ objWriter , $ spreadsheet -> getSheet ( $ i ) , $ i ) ; $ this -> writeDefinedNameForPrintTitles ( $ objWriter , $ spreadsheet -> getSheet ( $ i ) , $ i ) ; $ this -> writeDefinedNameForPrintArea ( $ objWriter , $ spreadsheet -> getSheet ( $ i ) , $ i ) ; } $ objWriter -> endElement ( ) ; }
1930	public function attachFile ( $ strFile , $ strMime = 'application/octet-stream' ) { $ this -> objMessage -> attach ( \ Swift_Attachment :: fromPath ( $ strFile , $ strMime ) -> setFilename ( basename ( $ strFile ) ) ) ; }
6354	public static function setFakeTime ( $ fakeTime ) { if ( is_string ( $ fakeTime ) ) { $ fakeTime = ( int ) static :: convert ( TS_UNIX , $ fakeTime ) ; } if ( is_int ( $ fakeTime ) ) { $ fakeTime = function ( ) use ( $ fakeTime ) { return $ fakeTime ; } ; } $ old = static :: $ fakeTimeCallback ; static :: $ fakeTimeCallback = $ fakeTime ? $ fakeTime : null ; return $ old ; }
3400	protected function makeRequest ( $ arguments = [ ] ) { $ defaults = $ this -> getDefaultOptions ( ) ; $ arguments = array_merge ( $ defaults , $ arguments ) ; $ client = $ this -> resource -> getGuzzle ( ) ; $ request = $ client -> createRequest ( $ this -> getMethod ( ) , $ this -> url , $ arguments ) ; $ response = $ client -> send ( $ request ) ; $ this -> setResponse ( $ response ) ; $ this -> setContent ( ( string ) $ response -> getBody ( ) ) ; }
950	public function createHmac ( array $ opts ) { $ data = $ opts [ 'data' ] ; $ raw = $ opts [ 'raw' ] ?? false ; $ buildQuery = $ opts [ 'buildQuery' ] ?? false ; $ buildQueryWithJoin = $ opts [ 'buildQueryWithJoin' ] ?? false ; $ encode = $ opts [ 'encode' ] ?? false ; $ secret = $ opts [ 'secret' ] ?? Config :: get ( 'shopify-app.api_secret' ) ; if ( $ buildQuery ) { ksort ( $ data ) ; $ queryCompiled = [ ] ; foreach ( $ data as $ key => $ value ) { $ queryCompiled [ ] = "{$key}=" . ( is_array ( $ value ) ? implode ( $ value , ',' ) : $ value ) ; } $ data = implode ( $ queryCompiled , ( $ buildQueryWithJoin ? '&' : '' ) ) ; } $ hmac = hash_hmac ( 'sha256' , $ data , $ secret , $ raw ) ; return $ encode ? base64_encode ( $ hmac ) : $ hmac ; }
11924	public function onPermalinkChanged ( PermalinkChangedEvent $ event ) { $ previousPermalink = $ event -> getOriginalText ( ) ; $ newPermalink = $ event -> getChangedText ( ) ; $ this -> updatePermalinkOnBlocks ( $ previousPermalink , $ newPermalink ) ; $ this -> updateHomepagePermalink ( $ previousPermalink , $ newPermalink ) ; }
2035	public function onUnregister ( Registry $ registry ) { parent :: onUnregister ( $ registry ) ; if ( $ this -> fallback && $ this -> type == 'root' && $ registry -> isRegisteredAlias ( $ this , 'contao.dns-fallback' , $ this -> dns ) ) { $ registry -> unregisterAlias ( $ this , 'contao.dns-fallback' , $ this -> dns ) ; } }
7872	public function send ( array $ destinations , string $ message ) : ? array { $ this -> checkConfig ( ) ; if ( ! empty ( $ destinations ) ) { $ destination = $ destinations [ 0 ] ; } $ query = http_build_query ( [ 'userkey' => $ this -> userkey , 'passkey' => $ this -> passkey , 'nohp' => $ destination , 'pesan' => $ message , ] ) ; $ response = Request :: get ( $ this -> baseUrl . '/smsapi.php?' . $ query ) ; $ xml = simplexml_load_string ( $ response -> body ) ; $ body = json_decode ( json_encode ( $ xml ) , true ) ; if ( ! empty ( $ body [ 'message' ] ) and $ body [ 'message' ] [ 'status' ] != 0 ) { Log :: error ( sprintf ( 'Zenziva: %s.' , $ body [ 'message' ] [ 'text' ] ) ) ; } return [ 'code' => $ response -> code , 'message' => ( $ response -> code == 200 ) ? 'OK' : $ body [ 'message' ] [ 'text' ] ?? '' , 'data' => $ body , ] ; }
8930	protected function getStackIconElement ( $ key , $ value , $ index ) { $ element = $ value ; if ( is_string ( $ key ) ) { $ element = $ this -> icon ( $ key ) -> addClass ( $ value ) ; } else if ( is_string ( $ value ) ) { $ element = $ this -> icon ( $ value ) ; } if ( ! is_a ( $ element , FontAwesomeIcon :: class ) ) { throw new \ InvalidArgumentException ( 'Invalid icon passed to stack' ) ; } return $ element -> addClass ( "fa-stack-{$index}x" ) ; }
8480	public function run ( $ eventGroupId = null ) { $ eventGroups = EventGroup :: find ( ) -> asArray ( true ) -> all ( ) ; if ( count ( $ eventGroups ) === 0 ) { throw new Exception ( 'Event groups not found' ) ; } if ( $ eventGroupId === null ) { $ first = reset ( $ eventGroups ) ; $ eventGroupId = $ first [ 'id' ] ; } $ tabs = [ ] ; foreach ( $ eventGroups as $ eventGroup ) { $ tabs [ ] = [ 'label' => $ eventGroup [ 'name' ] , 'url' => [ 'index' , 'eventGroupId' => $ eventGroup [ 'id' ] ] , 'active' => $ eventGroupId == $ eventGroup [ 'id' ] , ] ; } $ model = new EventEventHandler ( [ 'scenario' => 'search' ] ) ; $ eventsList = Event :: find ( ) -> select ( [ 'name' , 'id' ] ) -> where ( [ 'event_group_id' => $ eventGroupId ] ) -> indexBy ( 'id' ) -> column ( ) ; return $ this -> controller -> render ( 'index' , [ 'dataProvider' => $ model -> search ( \ Yii :: $ app -> request -> get ( ) , array_keys ( $ eventsList ) ) , 'eventGroupId' => $ eventGroupId , 'eventsList' => $ eventsList , 'model' => $ model , 'tabs' => $ tabs , ] ) ; }
9498	public function saveEntity ( BaseEntity $ entity , $ endPoint = '' , $ extraData = null ) { $ end_point = strtolower ( $ endPoint ) ; if ( strpos ( $ end_point , 'http' ) !== 0 ) { $ end_point = $ this -> api -> getApiUrl ( ) . $ end_point ; } $ type = $ this -> getType ( ) ; $ className = explode ( '\\' , $ type ) ; $ baseName = strtolower ( end ( $ className ) ) ; $ method = $ entity -> getId ( ) ? 'put' : 'post' ; if ( $ method == 'post' ) { $ entity -> checkCreatable ( ) ; } $ changes = $ entity -> toArray ( true , $ extraData ) ; if ( empty ( $ changes ) ) { return null ; } $ request = $ this -> api -> $ method ( $ end_point , null , json_encode ( array ( $ baseName => $ changes ) ) ) ; $ response = $ this -> processRequest ( $ request ) ; $ result = $ response -> json ( ) ; if ( $ result && isset ( $ result [ $ baseName ] ) ) { $ changeResult = new ChangeResult ( ) ; $ t = new $ type ( ) ; $ this -> manage ( $ t ) ; $ t -> fromArray ( $ result [ $ baseName ] ) ; $ changeResult -> setItem ( $ t ) ; if ( isset ( $ result [ 'audit' ] ) ) { $ audit = new TicketAudit ( ) ; $ audit -> fromArray ( $ result [ 'audit' ] ) ; $ changeResult -> setAudit ( $ audit ) ; } return $ changeResult ; } return null ; }
7389	public function getResponse ( array $ packageList , array $ languageList , array $ customRouteList , string $ url = '' ) : Response { $ request = new Request ( $ languageList , $ packageList , $ url ) ; $ this -> packageRoot .= 'package/' . $ request -> package ( ) . '/' ; try { if ( isset ( $ customRouteList [ $ request -> package ( ) ] ) ) { $ path = $ this -> packageRoot . 'CustomRoute.php' ; if ( file_exists ( $ path ) ) { require $ path ; $ route = $ request -> package ( ) . '\\CustomRoute' ; $ route = new $ route ( ) ; $ this -> response = $ route -> getResponse ( $ this -> packageRoot , $ request ) ; if ( $ this -> response -> is404 ( ) ) { $ this -> set404 ( ) ; } return $ this -> response ; } else { throw new RouteException ( sprintf ( 'The file "%s" does not exist' , $ path ) ) ; } } else { $ this -> response = ( new DefaultRoute ( ) ) -> getResponse ( $ this -> packageRoot , $ request ) ; if ( $ this -> response -> is404 ( ) ) { $ this -> set404 ( ) ; } return $ this -> response ; } } catch ( RouteException $ e ) { if ( Wrap :: isEnabled ( ) ) { throw $ e ; } else { $ this -> response = new Response ( ) ; $ this -> set404 ( ) ; return $ this -> response ; } } }
3343	public function createLocalCopy ( $ source , $ store = true ) { $ data = $ this -> __preparedRequest ( 'file_copy' , 'POST' , array ( ) , array ( 'source' => $ source , 'store' => $ store ) ) ; if ( array_key_exists ( 'result' , ( array ) $ data ) == true ) { if ( $ data -> type == 'file' ) { return new File ( ( string ) $ data -> result -> uuid , $ this ) ; } else { return ( string ) $ data -> result ; } } else { return ( string ) $ data -> detail ; } }
1667	protected function disableTwoFactor ( BackendUser $ user , $ return ) { if ( ! $ user -> useTwoFactor ) { return ; } $ user -> secret = null ; $ user -> useTwoFactor = '' ; $ user -> save ( ) ; throw new RedirectResponseException ( $ return ) ; }
8849	public function category ( ) { $ category = $ this -> getCurrentCategory ( ) ; if ( $ category ) { $ this -> blogPosts = $ category -> BlogPosts ( ) ; return $ this -> render ( ) ; } return $ this -> httpError ( 404 , "Not Found" ) ; }
12413	public function addDevice ( $ groupId , array $ deviceIdentifiers ) { $ params = [ 'group_id' => intval ( $ groupId ) , 'device_identifiers' => $ deviceIdentifiers , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_ADD_DEVICE , $ params ] ) ; }
12351	public function invalidate ( string $ api_session = null ) { if ( empty ( $ api_session ) === false && is_string ( $ api_session ) === true ) { $ session = Model \ Session :: where ( 'code' , $ api_session ) -> first ( ) ; if ( $ session !== null ) { $ session -> delete ( ) ; } } elseif ( empty ( $ _SESSION [ 'api_session' ] ) === false && is_string ( $ _SESSION [ 'api_session' ] ) === true ) { $ session = Model \ Session :: where ( 'code' , $ _SESSION [ 'api_session' ] ) -> first ( ) ; if ( $ session !== null ) { $ session -> delete ( ) ; } } elseif ( empty ( $ _GET [ 'api_session' ] ) === false && is_string ( $ _GET [ 'api_session' ] ) === true ) { $ session = Model \ Session :: where ( 'code' , $ _GET [ 'api_session' ] ) -> first ( ) ; if ( $ session !== null ) { $ session -> delete ( ) ; } } $ this -> details = false ; $ _SESSION [ 'api_session' ] = null ; $ _GET [ 'api_session' ] = null ; }
8263	protected function onStateMismatch ( ) { $ this -> logger -> warning ( "OAuth2 response state mismatch: provider: {provider} from {addr}" , array ( "provider" => get_class ( $ this -> provider ) , "addr" => $ _SERVER [ 'REMOTE_ADDR' ] ) ) ; $ this -> session -> remove ( "oauth2state" ) ; $ this -> session -> addFlash ( "error" , "Invalid OAuth response." ) ; $ this -> picoAuth -> redirectToLogin ( ) ; }
6539	public function transform ( $ iterator ) { if ( null === $ iterator ) { return array ( ) ; } if ( is_array ( $ iterator ) ) { return $ iterator ; } if ( ! $ iterator instanceof Iterator ) { throw new TransformationFailedException ( 'Expected a Yucca\Component\Iterator\Iterator object.' ) ; } return $ iterator -> getArray ( ) ; }
3592	protected function loadMetaAttributes ( ) { if ( ! array_key_exists ( 'metaAttributes' , $ this -> relations ) ) { $ this -> reloadMetaAttributes ( ) ; } $ attributes = $ this -> getRelation ( 'metaAttributes' ) ; if ( ! $ attributes instanceof AttributeBag ) { $ this -> setRelation ( 'metaAttributes' , ( new Attribute ) -> newBag ( $ attributes -> all ( ) ) ) ; } }
2412	protected function addTableTlTheme ( \ DOMDocument $ xml , \ DOMNode $ tables , Result $ objTheme ) { $ table = $ xml -> createElement ( 'table' ) ; $ table -> setAttribute ( 'name' , 'tl_theme' ) ; $ table = $ tables -> appendChild ( $ table ) ; $ this -> loadDataContainer ( 'tl_theme' ) ; $ objDcaExtractor = DcaExtractor :: getInstance ( 'tl_theme' ) ; $ arrOrder = $ objDcaExtractor -> getOrderFields ( ) ; $ this -> addDataRow ( $ xml , $ table , $ objTheme -> row ( ) , $ arrOrder ) ; }
1276	private function isMailInnovations ( ) { $ patterns = [ '/^MI\d{6}\d{1,22}$/' , '/^94071\d{17}$/' , '/^7\d{19}$/' , '/^93033\d{17}$/' , '/^M\d{9}$/' , '/^82\d{10}$/' , '/^EC\d{9}US$/' , '/^927\d{23}$/' , '/^927\d{19}$/' , '/^EA\d{9}US$/' , '/^CP\d{9}US$/' , '/^92055\d{17}$/' , '/^14\d{18}$/' , '/^92088\d{17}$/' , '/^RA\d{9}US$/' , '/^9202\d{16}US$/' , '/^23\d{16}US$/' , '/^94\d{20}$/' , '/^03\d{18}$/' ] ; foreach ( $ patterns as $ pattern ) { if ( preg_match ( $ pattern , $ this -> trackingNumber ) ) { return true ; } } return false ; }
8120	public function canSubmitReview ( $ record ) { if ( ! $ record -> canEdit ( ) || ! $ record -> hasMethod ( 'canBeReviewedBy' ) || ! $ record -> canBeReviewedBy ( Security :: getCurrentUser ( ) ) ) { return false ; } return true ; }
1256	public static function search ( $ expression , $ data ) { static $ runtime ; if ( ! $ runtime ) { $ runtime = Env :: createRuntime ( ) ; } return $ runtime ( $ expression , $ data ) ; }
6669	public function set_movie_params ( ) { $ post_id = get_the_ID ( ) ; $ is_active = $ this -> get_rating_state ( $ post_id ) ; $ options = $ this -> model -> get_theme_options ( ) ; $ params = [ 'postID' => $ post_id , 'dark' => $ options [ 'enable-dark' ] , 'imdb_button' => __ ( 'TOTAL' , 'extensions-for-grifus-rating' ) , 'is_active' => $ is_active , ] ; return $ params ; }
1663	public function image ( $ imageUrl , $ accessibilityText = null ) { $ this -> imageUrl = $ imageUrl ; $ this -> accessibilityText = $ accessibilityText ; return $ this ; }
6580	public static function fromPolar ( $ length , $ ap , $ av ) { return new static ( $ length * cos ( $ ap ) * cos ( $ av ) , $ length * sin ( $ ap ) * cos ( $ av ) , $ length * sin ( $ av ) ) ; }
4361	public static function isUtf8 ( $ str , & $ special = false ) { self :: setStr ( $ str ) ; $ special = false ; while ( self :: $ curI < self :: $ stats [ 'strLen' ] ) { $ isUtf8 = self :: isOffsetUtf8 ( $ isSpecial ) ; if ( ! $ isUtf8 ) { return false ; } if ( $ isSpecial ) { $ special = true ; } } $ special = $ special || self :: hasSpecial ( $ str ) ; return true ; }
6141	public function checkPass ( $ password = null ) { if ( $ password === null ) { $ password = $ this -> pass ; } if ( strlen ( $ password ) == 0 ) { return true ; } $ pattern = "/^(" . $ this -> regex [ "alphanum" ] . "|" . $ this -> regex [ "mark" ] . "|" . $ this -> regex [ "escaped" ] . "|[;:&=+$,])+$/" ; $ status = @ preg_match ( $ pattern , $ password ) ; if ( $ status === false ) { throw new Ts3Exception ( "URI password validation failed" ) ; } return ( $ status == 1 ) ; }
9382	public function getTag ( $ classNames , $ color = null ) { return ArrayData :: create ( [ 'ClassNames' => $ classNames , 'Color' => $ color ] ) -> renderWith ( sprintf ( '%s\Tag' , self :: class ) ) ; }
2304	public function createPageList ( ) { $ this -> import ( BackendUser :: class , 'User' ) ; if ( $ this -> User -> isAdmin ) { return $ this -> doCreatePageList ( ) ; } $ return = '' ; $ processed = array ( ) ; foreach ( $ this -> eliminateNestedPages ( $ this -> User -> pagemounts ) as $ page ) { $ objPage = PageModel :: findWithDetails ( $ page ) ; if ( $ objPage -> type == 'root' ) { $ title = $ objPage -> title ; $ start = $ objPage -> id ; } else { $ title = $ objPage -> rootTitle ; $ start = $ objPage -> rootId ; } if ( \ in_array ( $ start , $ processed ) ) { continue ; } if ( $ objPage -> domain && $ objPage -> domain != Environment :: get ( 'host' ) ) { continue ; } $ processed [ ] = $ start ; $ return .= '<optgroup label="' . $ title . '">' . $ this -> doCreatePageList ( $ start ) . '</optgroup>' ; } return $ return ; }
8082	public function report ( $ message ) { $ channel = $ this -> currentChannel ; if ( $ message ) { $ reports = & $ this -> getReports ( $ channel ) ; $ reports [ ] = $ message ; } return $ this ; }
202	private function queryValueExists ( $ query , $ value ) { if ( is_array ( $ value ) ) { return $ query -> count ( "DISTINCT [[$this->targetAttribute]]" ) == count ( $ value ) ; } return $ query -> exists ( ) ; }
1472	public function createRelationshipDocumentValidator ( $ document ) { return new Validation \ Spec \ RelationValidator ( $ this -> container -> make ( StoreInterface :: class ) , $ this -> createErrorTranslator ( ) , $ document ) ; }
9279	public function save ( JobEntity $ job ) { $ query = null ; if ( ( int ) $ job -> getId ( ) == 0 ) { $ query = $ this -> sql -> insert ( ) ; $ query -> values ( $ job -> getArrayCopy ( ) ) ; } else { $ query = $ this -> sql -> update ( ) ; $ query -> set ( $ job -> getArrayCopy ( ) ) ; $ query -> where ( array ( 'id' => $ job -> getId ( ) ) ) ; } $ stmt = $ this -> sql -> prepareStatementForSqlObject ( $ query ) ; $ res = $ stmt -> execute ( ) ; if ( ( int ) $ job -> getId ( ) == 0 ) { $ job -> setId ( ( int ) $ res -> getGeneratedValue ( ) ) ; } return $ job ; }
9395	public function buildCommand ( ) { if ( $ this -> escape !== false ) { $ this -> options = $ this -> escape ( $ this -> options ) ; } if ( $ this -> builder !== null ) { $ this -> command = $ this -> builder -> build ( $ this -> options ) ; } return $ this ; }
175	public static function remove ( & $ array , $ key , $ default = null ) { if ( is_array ( $ array ) && ( isset ( $ array [ $ key ] ) || array_key_exists ( $ key , $ array ) ) ) { $ value = $ array [ $ key ] ; unset ( $ array [ $ key ] ) ; return $ value ; } return $ default ; }
9943	public function setCellValueExplicit ( $ pCoordinate , $ pValue , $ pDataType ) { $ this -> getCell ( $ pCoordinate ) -> setValueExplicit ( $ pValue , $ pDataType ) ; return $ this ; }
3377	public function postRemind ( ) { \ App :: make ( 'route' ) ; \ Config :: set ( 'auth.defaults.passwords' , 'panel' ) ; $ response = \ Password :: sendResetLink ( Input :: only ( 'email' ) , function ( $ message ) { $ message -> subject ( 'Password Reminder' ) ; } ) ; switch ( $ response ) { case PasswordBrokerContract :: INVALID_USER : return \ Redirect :: back ( ) -> with ( 'message' , \ Lang :: get ( $ response ) ) -> with ( 'mesType' , 'error' ) ; case PasswordBrokerContract :: RESET_LINK_SENT : return \ Redirect :: back ( ) -> with ( 'message' , \ Lang :: get ( $ response ) ) -> with ( 'mesType' , 'info' ) ; } }
146	protected function moveWatch ( $ fromLiteral , $ toLiteral , $ node ) { if ( ! isset ( $ this -> watchChains [ $ toLiteral ] ) ) { $ this -> watchChains [ $ toLiteral ] = new RuleWatchChain ; } $ node -> moveWatch ( $ fromLiteral , $ toLiteral ) ; $ this -> watchChains [ $ fromLiteral ] -> remove ( ) ; $ this -> watchChains [ $ toLiteral ] -> unshift ( $ node ) ; }
3967	protected function getMetaModelByModelPid ( ModelInterface $ model ) { $ metaModel = $ this -> factory -> getMetaModel ( $ this -> factory -> translateIdToMetaModelName ( $ model -> getProperty ( 'pid' ) ) ) ; if ( $ metaModel === null ) { throw new \ InvalidArgumentException ( 'Could not retrieve MetaModel ' . $ model -> getProperty ( 'pid' ) ) ; } return $ metaModel ; }
12634	public function reverse ( $ orderNo , $ type = self :: OUT_TRADE_NO ) { $ params = [ $ type => $ orderNo , ] ; return $ this -> safeRequest ( $ this -> wrapApi ( self :: API_REVERSE ) , $ params ) ; }
8231	public static function getItemByUrl ( $ items , $ url ) { if ( ! isset ( $ items ) ) { return null ; } if ( array_key_exists ( "/" . $ url , $ items ) ) { return $ items [ "/" . $ url ] ; } $ urlParts = explode ( "/" , trim ( $ url , "/" ) ) ; $ urlPartsLen = count ( $ urlParts ) ; while ( $ urlPartsLen > 0 ) { unset ( $ urlParts [ -- $ urlPartsLen ] ) ; $ subUrl = "/" . join ( "/" , $ urlParts ) ; if ( array_key_exists ( $ subUrl , $ items ) && ( ! isset ( $ items [ $ subUrl ] [ "recursive" ] ) || $ items [ $ subUrl ] [ "recursive" ] === true ) ) { return $ items [ $ subUrl ] ; } } return null ; }
1989	public static function addToUrl ( $ strRequest , $ blnIgnoreParams = false , $ arrUnset = array ( ) ) { $ arrGet = $ blnIgnoreParams ? array ( ) : $ _GET ; foreach ( array_keys ( $ arrGet ) as $ key ) { $ arrGet [ $ key ] = Input :: get ( $ key , true , true ) ; } $ arrFragments = preg_split ( '/&(amp;)?/i' , $ strRequest ) ; foreach ( $ arrFragments as $ strFragment ) { list ( $ key , $ value ) = explode ( '=' , $ strFragment ) ; if ( $ value == '' ) { unset ( $ arrGet [ $ key ] ) ; } else { $ arrGet [ $ key ] = $ value ; } } if ( Config :: get ( 'addLanguageToUrl' ) ) { unset ( $ arrGet [ 'language' ] ) ; } $ strParams = '' ; $ strConnector = '/' ; $ strSeparator = '/' ; foreach ( $ arrGet as $ k => $ v ) { if ( Config :: get ( 'useAutoItem' ) && ( $ k == 'auto_item' || \ in_array ( $ k , $ GLOBALS [ 'TL_AUTO_ITEM' ] ) ) ) { $ strParams = $ strConnector . urlencode ( $ v ) . $ strParams ; } else { $ strParams .= $ strConnector . urlencode ( $ k ) . $ strSeparator . urlencode ( $ v ) ; } } global $ objPage ; $ pageId = $ objPage -> alias ? : $ objPage -> id ; if ( empty ( $ pageId ) ) { $ pageId = static :: getPageIdFromUrl ( ) ; } $ arrParams = array ( ) ; $ arrParams [ 'alias' ] = $ pageId . $ strParams ; if ( Config :: get ( 'addLanguageToUrl' ) ) { $ arrParams [ '_locale' ] = $ objPage -> rootLanguage ; } $ strUrl = System :: getContainer ( ) -> get ( 'router' ) -> generate ( 'contao_frontend' , $ arrParams ) ; $ strUrl = substr ( $ strUrl , \ strlen ( Environment :: get ( 'path' ) ) + 1 ) ; return $ strUrl ; }
4471	public function requeue ( ? string $ queue = null , array $ opts = [ ] ) : string { $ opts = array_merge ( [ 'delay' => 0 , 'data' => $ this -> data , 'priority' => $ this -> priority , 'retries' => $ this -> retries , 'tags' => $ this -> tags , 'depends' => $ this -> dependencies , ] , $ opts ) ; $ queueName = $ queue ? : $ this -> queue ; $ data = json_encode ( $ opts [ 'data' ] , JSON_UNESCAPED_SLASHES ) ? : '{}' ; return $ this -> client -> requeue ( $ this -> worker , $ queueName , $ this -> jid , $ this -> klass , $ data , $ opts [ 'delay' ] , 'priority' , $ opts [ 'priority' ] , 'tags' , json_encode ( $ opts [ 'tags' ] , JSON_UNESCAPED_SLASHES ) , 'retries' , $ opts [ 'retries' ] , 'depends' , json_encode ( $ opts [ 'depends' ] , JSON_UNESCAPED_SLASHES ) ) ; }
10770	protected function resolveViewName ( ) { $ viewName = Yii :: $ app -> request -> get ( $ this -> viewParam , $ this -> defaultView ) ; if ( ! is_string ( $ viewName ) || ! preg_match ( '~^\w(?:(?!\/\.{0,2}\/)[\w\/\-\.])*$~' , $ viewName ) ) { if ( YII_DEBUG ) { throw new NotFoundHttpException ( "The requested view \"$viewName\" must start with a word character, must not contain /../ or /./, can contain only word characters, forward slashes, dots and dashes." ) ; } else { throw new NotFoundHttpException ( Yii :: t ( 'yii' , 'The requested view "{name}" was not found.' , [ 'name' => $ viewName ] ) ) ; } } return empty ( $ this -> viewPrefix ) ? $ viewName : $ this -> viewPrefix . '/' . $ viewName ; }
7859	private function registerWorkflowRunnersHook ( ) { $ this -> app -> afterResolving ( function ( WorkflowRunner $ runner , $ app ) { $ runner -> setWorkflow ( $ app [ 'cerbero.workflow' ] ) ; } ) ; }
2977	public function unserialize ( $ serialized ) { $ this -> data = unserialize ( $ serialized ) ; $ this -> closure = __reconstruct_closure ( $ this -> data ) ; if ( ! $ this -> closure instanceof Closure ) { throw new ClosureUnserializationException ( 'The closure is corrupted and cannot be unserialized.' ) ; } if ( $ this -> data [ 'binding' ] || $ this -> data [ 'isStatic' ] ) { $ this -> closure = $ this -> closure -> bindTo ( $ this -> data [ 'binding' ] , $ this -> data [ 'scope' ] ) ; } }
4156	function every ( $ interval , Job $ job ) { $ expression = new SimpleExpression ( $ interval ) ; $ this -> add ( $ expression , $ job ) ; return $ this ; }
11475	public function setObjectType ( $ type ) { if ( ! is_object ( $ type ) ) { if ( Yii :: $ app -> collectors [ 'types' ] -> has ( $ type ) ) { $ type = Yii :: $ app -> collectors [ 'types' ] -> getOne ( $ type ) -> object ; } else { $ type = null ; } } $ this -> _objectType = $ type ; }
1207	public function moveToPosition ( ItemInterface $ item , $ position ) { $ this -> moveChildToPosition ( $ item -> getParent ( ) , $ item , $ position ) ; }
4178	public function getFiles ( ) { return $ this -> files ? : $ this -> files = Finder :: create ( ) -> in ( realpath ( $ this -> directory ) ) ; }
3661	private function addParameters ( $ parameters ) { if ( empty ( $ parameters ) ) { return ; } $ this -> queryParameter = array_merge ( $ this -> queryParameter , $ parameters ) ; }
3440	public function saveProps ( $ selected = [ ] ) { $ propertyValues = $ this -> constructPropertyValuesForSave ( $ selected ) ; if ( empty ( $ propertyValues ) ) { return false ; } $ bxMethod = empty ( $ selected ) ? 'setPropertyValues' : 'setPropertyValuesEx' ; static :: $ bxObject -> $ bxMethod ( $ this -> id , static :: iblockId ( ) , $ propertyValues ) ; return true ; }
4521	public function created ( JWTCreatedEvent $ event ) { $ data = $ event -> getData ( ) ; $ user = $ event -> getUser ( ) ; if ( $ user instanceof User ) { $ this -> accessor -> setValue ( $ data , $ this -> property , $ user -> getIdentity ( ) -> getType ( ) ) ; } else { $ this -> accessor -> setValue ( $ data , $ this -> property , $ user -> getIdentity ( ) ) ; } $ event -> setData ( $ data ) ; }
6346	public static function concat ( Iterator $ a , Iterator $ b ) : Iterator { return self :: concatIterators ( new ArrayIterator ( [ $ a , $ b ] ) ) ; }
7395	protected function _getByName ( $ propName ) { if ( array_key_exists ( $ propName , $ this -> _map ) ) { $ propName = $ this -> _map [ $ propName ] ; } if ( $ this -> { $ propName } instanceof AtomicInterface ) { return $ this -> { $ propName } -> get ( ) ; } $ getter = '_get_' . $ propName ; if ( method_exists ( $ this -> _calledClass , $ getter ) ) { return $ this -> { $ getter } ( ) ; } return $ this -> { $ propName } ; }
3365	public function structure ( $ args , $ assoc_args ) { global $ wp_rewrite ; $ blog_prefix = '' ; $ prefix = $ blog_prefix ; if ( is_multisite ( ) && ! is_subdomain_install ( ) && is_main_site ( ) ) { $ blog_prefix = '/blog' ; } $ permalink_structure = ( 'default' === $ args [ 0 ] ) ? '' : $ args [ 0 ] ; if ( ! empty ( $ permalink_structure ) ) { $ permalink_structure = preg_replace ( '#/+#' , '/' , '/' . str_replace ( '#' , '' , $ permalink_structure ) ) ; if ( $ prefix && $ blog_prefix ) { $ permalink_structure = $ prefix . preg_replace ( '#^/?index\.php#' , '' , $ permalink_structure ) ; } else { $ permalink_structure = $ blog_prefix . $ permalink_structure ; } } $ wp_rewrite -> set_permalink_structure ( $ permalink_structure ) ; if ( isset ( $ assoc_args [ 'category-base' ] ) ) { $ category_base = $ assoc_args [ 'category-base' ] ; if ( ! empty ( $ category_base ) ) { $ category_base = $ blog_prefix . preg_replace ( '#/+#' , '/' , '/' . str_replace ( '#' , '' , $ category_base ) ) ; } $ wp_rewrite -> set_category_base ( $ category_base ) ; } if ( isset ( $ assoc_args [ 'tag-base' ] ) ) { $ tag_base = $ assoc_args [ 'tag-base' ] ; if ( ! empty ( $ tag_base ) ) { $ tag_base = $ blog_prefix . preg_replace ( '#/+#' , '/' , '/' . str_replace ( '#' , '' , $ tag_base ) ) ; } $ wp_rewrite -> set_tag_base ( $ tag_base ) ; } self :: apache_modules ( ) ; WP_CLI :: success ( 'Rewrite structure set.' ) ; $ new_assoc_args = [ ] ; $ cmd = 'rewrite flush' ; if ( Utils \ get_flag_value ( $ assoc_args , 'hard' ) ) { $ cmd .= ' --hard' ; $ new_assoc_args [ 'hard' ] = true ; if ( ! in_array ( 'mod_rewrite' , ( array ) WP_CLI :: get_config ( 'apache_modules' ) , true ) ) { WP_CLI :: warning ( 'Regenerating a .htaccess file requires special configuration. See usage docs.' ) ; } } $ process_run = WP_CLI :: runcommand ( $ cmd ) ; if ( ! empty ( $ process_run -> stderr ) ) { WP_CLI :: warning ( substr ( $ process_run -> stderr , 9 ) ) ; } }
10713	public function saveMany ( ArrayAccess $ models ) { if ( ! $ models instanceof Collection ) { $ models = collect ( $ models ) ; } foreach ( $ models as $ model ) { $ this -> save ( $ model ) ; } return $ models ; }
6677	public static function toRelativeTime ( $ fromTime , $ toTime = 'now' , $ format = 'days' ) { $ startTime = new DateTime ( $ fromTime ) ; $ endTime = new DateTime ( $ toTime ) ; return $ startTime -> diff ( $ endTime ) -> $ format ; }
5134	private static function createUri ( string $ scheme , string $ host , ? int $ port , string $ user , string $ password , string $ path , string $ query , string $ fragment ) : \ One \ Uri { return new Uri ( $ scheme , $ host , $ port , $ path , $ query , $ fragment , $ user , $ password ) ; }
2672	public function upsertDictionaryItem ( $ dictionaryId , $ itemKey , $ itemValue ) { $ body = [ 'item_value' => $ itemValue ] ; $ url = $ this -> _getApiServiceUri ( ) . 'dictionary/' . $ dictionaryId . '/item/' . urlencode ( $ itemKey ) ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: PUT , $ body ) ; if ( ! $ result ) { throw new LocalizedException ( __ ( 'Failed to create Dictionary item.' ) ) ; } }
11891	private function createCreateForm ( CustomField $ entity , $ type ) { $ form = $ this -> createForm ( 'custom_field_choice' , $ entity , array ( 'action' => $ this -> generateUrl ( 'customfield_create' , array ( 'type' => $ type ) ) , 'method' => 'POST' , 'type' => $ type , 'group_widget' => ( $ entity -> getCustomFieldsGroup ( ) ) ? 'hidden' : 'entity' ) ) ; $ form -> add ( 'submit' , 'submit' , array ( 'label' => 'Create' ) ) ; return $ form ; }
11157	public function handleUrl ( $ url , Event $ event , Queue $ queue ) { $ logger = $ this -> getLogger ( ) ; $ logger -> info ( 'handleUrl' , array ( 'url' => $ url ) ) ; $ v = $ this -> getVideoId ( $ url ) ; $ logger -> info ( 'getVideoId' , array ( 'url' => $ url , 'v' => $ v ) ) ; if ( ! $ v ) { return ; } $ apiUrl = $ this -> getApiUrl ( $ v ) ; $ request = $ this -> getApiRequest ( $ apiUrl , $ event , $ queue ) ; $ this -> getEventEmitter ( ) -> emit ( 'http.request' , array ( $ request ) ) ; }
7075	private function addItemDetails ( array & $ details , Model \ SaleItemInterface $ item ) { $ total = 0 ; if ( ! ( $ item -> isCompound ( ) && ! $ item -> hasPrivateChildren ( ) ) ) { $ itemResult = $ item -> getResult ( ) ; $ details [ 'L_PAYMENTREQUEST_0_NAME' . $ this -> line ] = $ item -> getTotalQuantity ( ) . 'x ' . $ item -> getDesignation ( ) ; $ details [ 'L_PAYMENTREQUEST_0_NUMBER' . $ this -> line ] = $ item -> getReference ( ) ; if ( ! empty ( $ description = $ item -> getDescription ( ) ) ) { $ details [ 'L_PAYMENTREQUEST_0_DESC' . $ this -> line ] = $ description ; } $ details [ 'L_PAYMENTREQUEST_0_AMT' . $ this -> line ] = $ this -> format ( $ itemResult -> getTotal ( ) ) ; $ total = $ itemResult -> getTotal ( ) ; $ this -> line ++ ; } foreach ( $ item -> getChildren ( ) as $ child ) { $ total += $ this -> addItemDetails ( $ details , $ child ) ; } return $ total ; }
792	public function clearErrors ( $ attribute = null ) { if ( $ attribute === null ) { $ this -> _errors = [ ] ; } else { unset ( $ this -> _errors [ $ attribute ] ) ; } }
6370	public static function forMap ( array $ map ) : callable { return function ( $ index ) use ( $ map ) { Preconditions :: checkArgument ( array_key_exists ( $ index , $ map ) , "The given key '%s' does not exist in the map" , $ index ) ; return $ map [ $ index ] ; } ; }
12855	function goWait ( $ maxExecution = null ) { $ jobExecution = 0 ; $ sleep = 0 ; while ( 1 ) { if ( 0 == $ executed = $ this -> goUntilEmpty ( ) ) { $ sleep += 100000 ; usleep ( $ sleep ) ; if ( $ sleep > 2 * 1000000 ) $ sleep = 100000 ; continue ; } $ jobExecution += $ executed ; if ( $ jobExecution >= $ maxExecution ) break ; if ( $ sleep = $ this -> getSleep ( ) ) usleep ( $ sleep ) ; $ sleep = 0 ; } }
97	private function selectRestVersion ( $ channelXml , $ supportedVersions ) { $ channelXml -> registerXPathNamespace ( 'ns' , self :: CHANNEL_NS ) ; foreach ( $ supportedVersions as $ version ) { $ xpathTest = "ns:servers/ns:*/ns:rest/ns:baseurl[@type='{$version}']" ; $ testResult = $ channelXml -> xpath ( $ xpathTest ) ; foreach ( $ testResult as $ result ) { $ result = ( string ) $ result ; if ( preg_match ( '{^https://}i' , $ result ) ) { return array ( 'version' => $ version , 'baseUrl' => $ result ) ; } } if ( count ( $ testResult ) > 0 ) { return array ( 'version' => $ version , 'baseUrl' => ( string ) $ testResult [ 0 ] ) ; } } return null ; }
3516	public function setLocale ( $ locale ) { if ( $ this -> useCookies ) { Cookie :: queue ( $ this -> cookiePrefix . 'lang_locale' , $ locale ) ; } parent :: setLocale ( $ locale ) ; }
5494	public function findFirstAction ( $ parameters ) { $ slot = $ this -> findFirstSlot ( $ parameters ) ; if ( isset ( $ slot ) && isset ( $ slot [ 'content' ] ) ) { return $ slot [ 'content' ] ; } return ; }
3897	public function pagePicker ( ManipulateWidgetEvent $ event ) { if ( ! $ this -> scopeDeterminator -> currentScopeIsBackend ( ) || ! ( 'tl_metamodel_rendersettings' === $ event -> getEnvironment ( ) -> getDataDefinition ( ) -> getName ( ) ) || ! ( ( 0 === strpos ( $ event -> getProperty ( ) -> getName ( ) , 'jumpTo' ) ) && ( '[value]' === substr ( $ event -> getProperty ( ) -> getName ( ) , - \ strlen ( '[value]' ) ) ) ) ) { return ; } $ environment = $ event -> getEnvironment ( ) ; $ pickerUrl = $ this -> pickerBuilder -> getUrl ( 'cca_link' ) ; $ urlEvent = new GenerateHtmlEvent ( 'pickpage.svg' , $ environment -> getTranslator ( ) -> translate ( 'MSC.pagepicker' ) , 'style="vertical-middle:top;cursor:pointer"' ) ; $ environment -> getEventDispatcher ( ) -> dispatch ( ContaoEvents :: IMAGE_GET_HTML , $ urlEvent ) ; $ template = new ContaoBackendViewTemplate ( 'dc_general_wizard_link_url_picker' ) ; $ template -> set ( 'name' , $ event -> getWidget ( ) -> name ) -> set ( 'popupUrl' , $ pickerUrl ) -> set ( 'html' , ' ' . $ urlEvent -> getHtml ( ) ) -> set ( 'label' , $ event -> getProperty ( ) -> getLabel ( ) [ 1 ] ) -> set ( 'id' , $ event -> getWidget ( ) -> id ) ; $ event -> getWidget ( ) -> wizard = $ template -> parse ( ) ; }
8292	protected function checkAccess ( $ url ) { foreach ( $ this -> modules as $ module ) { if ( false === $ module -> handleEvent ( 'checkAccess' , [ $ url ] ) ) { return false ; } } return true ; }
8394	public static function before ( string $ path , string $ usage , string $ help , string $ action ) { if ( self :: $ isInit === true ) { self :: $ routes [ ] = array ( 'type' => 'before' , 'path' => $ path , 'usage' => $ usage , 'help' => $ help , 'action' => $ action , 'namespace' => self :: $ namespace ) ; } }
8306	public function assertString ( $ config , $ key ) { if ( array_key_exists ( $ key , $ config ) && ! is_string ( $ config [ $ key ] ) ) { throw new ConfigurationException ( $ key . " must be a string." ) ; } return $ this ; }
1025	private static function getFieldEntryKey ( FieldNode $ node ) { return $ node -> alias ? $ node -> alias -> value : $ node -> name -> value ; }
11295	public function getAttributeValue ( $ name , $ convertDates = true ) { if ( isset ( $ this -> model_data [ $ name ] ) ) { $ result = $ this -> model_data [ $ name ] ; if ( $ result instanceof \ DateTime && $ convertDates == true ) { $ result = $ result -> format ( 'Y-m-d H:i:s' ) ; } return $ result ; } if ( isset ( $ this -> data -> { $ name } ) ) { return $ this -> data -> { $ name } ; } return null ; }
1063	private function findConflictsWithinSelectionSet ( ValidationContext $ context , $ parentType , SelectionSetNode $ selectionSet ) { [ $ fieldMap , $ fragmentNames ] = $ this -> getFieldsAndFragmentNames ( $ context , $ parentType , $ selectionSet ) ; $ conflicts = [ ] ; $ this -> collectConflictsWithin ( $ context , $ conflicts , $ fieldMap ) ; $ fragmentNamesLength = count ( $ fragmentNames ) ; if ( $ fragmentNamesLength !== 0 ) { $ comparedFragments = [ ] ; for ( $ i = 0 ; $ i < $ fragmentNamesLength ; $ i ++ ) { $ this -> collectConflictsBetweenFieldsAndFragment ( $ context , $ conflicts , $ comparedFragments , false , $ fieldMap , $ fragmentNames [ $ i ] ) ; for ( $ j = $ i + 1 ; $ j < $ fragmentNamesLength ; $ j ++ ) { $ this -> collectConflictsBetweenFragments ( $ context , $ conflicts , false , $ fragmentNames [ $ i ] , $ fragmentNames [ $ j ] ) ; } } } return $ conflicts ; }
8959	private function prepareArrayParameter ( $ name ) { if ( isset ( $ this -> parameters [ $ name ] ) ) { $ parameterArray = $ this -> parameters [ $ name ] ; $ count = count ( $ parameterArray ) ; $ str = "['" . $ parameterArray [ 0 ] . "'" ; for ( $ i = 1 ; $ i < $ count ; ++ $ i ) { $ str .= ", '" . $ parameterArray [ $ i ] . "'" ; } $ str .= ']' ; return $ str ; } }
8980	private function buildRateFromTableRowData ( array $ row ) { return new Rate ( $ row [ 'source_name' ] , ( float ) $ row [ 'rate_value' ] , $ row [ 'currency_code' ] , $ row [ 'rate_type' ] , \ DateTime :: createFromFormat ( 'Y-m-d' , $ row [ 'rate_date' ] ) , $ row [ 'base_currency_code' ] , \ DateTime :: createFromFormat ( 'Y-m-d H:i:s' , $ row [ 'created_at' ] ) , \ DateTime :: createFromFormat ( 'Y-m-d H:i:s' , $ row [ 'modified_at' ] ) ) ; }
6063	public function listFolders ( $ id , $ depth = 0 , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'depth' => $ depth ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/media/' . $ id . '/folders' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new FolderResponse ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
5761	public function delete ( int $ id ) : string { if ( null === $ permission = $ this -> getObjectById ( $ id ) ) { throw new Exceptions \ QueryResultsNotFoundException ( ) ; } $ this -> doDeleteTransaction ( $ id ) ; $ title = $ permission -> getTitle ( ) ; unset ( $ permission ) ; return $ title ; }
9340	public function load ( $ directory ) { $ configurations = glob ( $ directory . '/*.php' ) ; foreach ( $ configurations as $ configuration ) { $ items = require $ configuration ; $ name = basename ( $ configuration , '.php' ) ; $ this -> data = array_merge ( $ this -> data , array ( $ name => $ items ) ) ; } return $ this -> data ; }
4270	public function dir_rewinddir ( ) { if ( ! $ this -> handle ) { return false ; } self :: restorePrev ( ) ; \ rewinddir ( $ this -> handle ) ; self :: register ( ) ; return true ; }
7237	protected function fixInvoiceDefault ( CustomerAddressInterface $ address ) { if ( ! $ this -> persistenceHelper -> isChanged ( $ address , [ 'invoiceDefault' ] ) ) { return ; } $ customer = $ address -> getCustomer ( ) ; if ( $ address -> isInvoiceDefault ( ) ) { foreach ( $ customer -> getAddresses ( ) as $ a ) { if ( $ a === $ address ) { continue ; } if ( $ a -> isInvoiceDefault ( ) ) { $ a -> setInvoiceDefault ( false ) ; $ this -> persistenceHelper -> persistAndRecompute ( $ a , false ) ; } } } elseif ( null === $ customer -> getDefaultInvoiceAddress ( true ) ) { $ address -> setInvoiceDefault ( true ) ; $ this -> persistenceHelper -> persistAndRecompute ( $ address , false ) ; } }
12629	public function sendToDevice ( $ deviceId , $ openId , $ content ) { $ params = [ 'device_type' => $ this -> deviceType , 'device_id' => $ deviceId , 'open_id' => $ openId , 'content' => base64_encode ( $ content ) , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_TRANS_MSG , $ params ] ) ; }
11410	public function update ( $ tagId , $ name ) { $ params = [ 'tag' => [ 'id' => $ tagId , 'name' => $ name , ] , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_UPDATE , $ params ] ) ; }
7776	protected function getRuleArgs ( $ rule ) { if ( ! $ this -> ruleHasArgs ( $ rule ) ) { return [ ] ; } list ( $ ruleName , $ argsWithBracketAtTheEnd ) = explode ( '(' , $ rule ) ; $ args = rtrim ( $ argsWithBracketAtTheEnd , ')' ) ; $ args = preg_replace ( '/\s+/' , '' , $ args ) ; $ args = explode ( ',' , $ args ) ; return $ args ; }
12269	protected function generateEventNames ( $ baseEventName , Page $ page ) { $ pageName = $ page -> getPageName ( ) ; $ language = $ page -> getCurrentLanguage ( ) ; return array ( $ baseEventName , $ baseEventName . '.' . $ language , $ baseEventName . '.' . $ pageName , $ baseEventName . '.' . $ language . '.' . $ pageName , ) ; }
8539	public function setGetMyPriceForASINResult ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'GetMyPriceForASINResult' ] [ 'FieldValue' ] = $ value ; return $ this ; }
6375	public function first ( ) : Optional { try { return Optional :: ofNullable ( $ this -> get ( 0 ) ) ; } catch ( OutOfBoundsException $ e ) { return Optional :: absent ( ) ; } }
303	public function getAttributeHint ( $ attribute ) { $ hints = $ this -> attributeHints ( ) ; if ( isset ( $ hints [ $ attribute ] ) ) { return $ hints [ $ attribute ] ; } elseif ( strpos ( $ attribute , '.' ) ) { $ attributeParts = explode ( '.' , $ attribute ) ; $ neededAttribute = array_pop ( $ attributeParts ) ; $ relatedModel = $ this ; foreach ( $ attributeParts as $ relationName ) { if ( $ relatedModel -> isRelationPopulated ( $ relationName ) && $ relatedModel -> $ relationName instanceof self ) { $ relatedModel = $ relatedModel -> $ relationName ; } else { try { $ relation = $ relatedModel -> getRelation ( $ relationName ) ; } catch ( InvalidParamException $ e ) { return '' ; } $ modelClass = $ relation -> modelClass ; $ relatedModel = $ modelClass :: instance ( ) ; } } $ hints = $ relatedModel -> attributeHints ( ) ; if ( isset ( $ hints [ $ neededAttribute ] ) ) { return $ hints [ $ neededAttribute ] ; } } return '' ; }
9854	protected function append ( $ data ) { if ( strlen ( $ data ) - 4 > $ this -> limit ) { $ data = $ this -> addContinue ( $ data ) ; } $ this -> _data .= $ data ; $ this -> _datasize += strlen ( $ data ) ; }
10357	protected static function highlightCode ( string $ file , int $ line , int $ padding = 6 ) : array { if ( ! is_readable ( $ file ) ) { return false ; } $ handle = fopen ( $ file , 'r' ) ; $ lines = array ( ) ; $ currentLine = 0 ; while ( ! feof ( $ handle ) ) { $ currentLine ++ ; $ temp = fgets ( $ handle ) ; if ( $ currentLine > $ line + $ padding ) { break ; } if ( $ currentLine >= ( $ line - $ padding ) && $ currentLine <= ( $ line + $ padding ) ) { $ lines [ ] = array ( 'number' => str_pad ( $ currentLine , 4 , ' ' , STR_PAD_LEFT ) , 'highlighted' => ( $ currentLine === $ line ) , 'code' => ErrorHandler :: highlightString ( $ temp ) , ) ; } } fclose ( $ handle ) ; return $ lines ; }
23	public function removePackage ( PackageInterface $ package ) { $ packageId = $ package -> getUniqueName ( ) ; foreach ( $ this -> getPackages ( ) as $ key => $ repoPackage ) { if ( $ packageId === $ repoPackage -> getUniqueName ( ) ) { array_splice ( $ this -> packages , $ key , 1 ) ; return ; } } }
1552	protected function adapterFor ( $ relation ) { $ adapter = $ this -> getStore ( ) -> adapterFor ( $ relation -> getModel ( ) ) ; if ( ! $ adapter instanceof AbstractAdapter ) { throw new RuntimeException ( 'Expecting inverse resource adapter to be an Eloquent adapter.' ) ; } return $ adapter ; }
7497	public function createMessageFromTemplateFile ( $ template , $ params , $ subject , $ recipient , $ sender = null ) { $ body = $ this -> templating -> render ( $ template , $ params ) ; if ( ! $ sender ) { $ sender = $ this -> defaultSender ; } $ message = new \ Swift_Message ( ) ; $ message -> setFrom ( $ sender ) -> setReplyTo ( $ sender ) -> setTo ( $ recipient ) -> setSubject ( $ subject ) -> setBody ( $ body , 'text/html' ) ; return $ message ; }
9641	public function validate ( $ validator ) { $ this -> value = trim ( $ this -> value ) ; $ regex = $ this -> config [ 'validregex' ] ; if ( $ this -> value && $ regex && ! preg_match ( $ regex , $ this -> value ) ) { $ validator -> validationError ( $ this -> name , _t ( 'ExternalURLField.VALIDATION' , "Please enter a valid URL" ) , "validation" ) ; return false ; } return true ; }
9737	public function setWidth ( $ pValue ) { if ( $ this -> resizeProportional && $ pValue != 0 ) { $ ratio = $ this -> height / ( $ this -> width != 0 ? $ this -> width : 1 ) ; $ this -> height = round ( $ ratio * $ pValue ) ; } $ this -> width = $ pValue ; return $ this ; }
12567	public function sendCard ( $ message , $ to = null ) { return $ this -> send ( self :: MSG_TYPE_CARD , $ message , $ to ) ; }
7454	protected function getFirstTerm ( WP_Post $ post ) { $ taxonomies = $ this -> getTaxonomies ( $ post -> post_type ) ; foreach ( $ taxonomies as $ taxonomy ) { $ post_terms = \ get_the_terms ( $ post , $ taxonomy ) ; if ( ! $ post_terms || \ is_wp_error ( $ post_terms ) ) { continue ; } return $ post_terms [ 0 ] ; } }
8939	public function closeChangeset ( $ id ) { $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = 'changeset/' . $ id . '/close' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ header [ 'format' ] = 'text/xml' ; $ this -> oauth -> oauthRequest ( $ path , 'PUT' , $ parameters , $ header ) ; }
10218	private static function cleanComplex ( $ complexNumber ) { if ( $ complexNumber [ 0 ] == '+' ) { $ complexNumber = substr ( $ complexNumber , 1 ) ; } if ( $ complexNumber [ 0 ] == '0' ) { $ complexNumber = substr ( $ complexNumber , 1 ) ; } if ( $ complexNumber [ 0 ] == '.' ) { $ complexNumber = '0' . $ complexNumber ; } if ( $ complexNumber [ 0 ] == '+' ) { $ complexNumber = substr ( $ complexNumber , 1 ) ; } return $ complexNumber ; }
11781	public function fromEntityToDb ( $ document ) { $ unitOfWork = $ this -> documentManager -> getUnitOfWork ( ) ; $ persistenceBuilder = new PersistenceBuilder ( $ this -> documentManager , $ unitOfWork ) ; $ mapping = array ( 'targetDocument' => $ this -> documentClass , ) ; return $ persistenceBuilder -> prepareEmbeddedDocumentValue ( $ mapping , $ document , true ) ; }
7950	public function orderBackend ( $ nbBackend , $ duration ) { return json_decode ( self :: getClient ( ) -> orderBackend ( $ this -> sn , $ nbBackend , $ duration ) ) ; }
7956	public function getBillingAccountServices ( ) { $ serviceList = json_decode ( self :: getClient ( ) -> getBillingAccountServices ( $ this -> billingAccount ) ) ; $ services = array ( ) ; foreach ( $ serviceList as $ service ) { $ services [ ] = new TelephonyAccountService ( $ service , $ this ) ; } return $ services ; }
11831	public static function create ( $ command , $ app ) { static $ cache = [ ] ; $ cacheKey = $ command ; if ( isset ( $ cache [ $ cacheKey ] ) ) { $ class = $ cache [ $ cacheKey ] [ 'class' ] ; $ command = $ cache [ $ cacheKey ] [ 'command' ] ; } else { if ( false === strpos ( $ command , '.' ) ) { $ class = __NAMESPACE__ . '\\' . String :: convertToCamelCase ( $ command ) ; } else { $ class = explode ( '.' , $ command ) ; $ class = array_map ( array ( 'In2pire\\Component\\Utility\\Text' , 'convertToCamelCase' ) , $ class ) ; $ class = implode ( '\\' , $ class ) ; $ command = substr ( $ command , strrpos ( $ command , '.' ) + 1 ) ; } $ cache [ $ cacheKey ] = [ 'class' => $ class , 'command' => $ command ] ; } if ( ! class_exists ( $ class ) ) { throw new \ RuntimeException ( 'Unknow command ' . $ cacheKey ) ; } return new $ class ( $ app ) ; }
126	protected function createRemoveRule ( PackageInterface $ package , $ reason , $ job ) { return new GenericRule ( array ( - $ package -> id ) , $ reason , $ job [ 'packageName' ] , $ job ) ; }
1985	public function getOptionsForUser ( BackendUser $ user ) : array { $ this -> loadOptions ( ) ; if ( $ user -> isAdmin ) { $ event = new ImageSizesEvent ( $ this -> options , $ user ) ; } else { $ options = array_map ( static function ( $ val ) { return is_numeric ( $ val ) ? ( int ) $ val : $ val ; } , StringUtil :: deserialize ( $ user -> imageSizes , true ) ) ; $ event = new ImageSizesEvent ( $ this -> filterOptions ( $ options ) , $ user ) ; } $ this -> eventDispatcher -> dispatch ( ContaoCoreEvents :: IMAGE_SIZES_USER , $ event ) ; return $ event -> getImageSizes ( ) ; }
8180	public function setDefaultStrategy ( $ defaultStrategy ) { if ( true === $ defaultStrategy ) { @ trigger_error ( 'Using "true" as the default strategy is deprecated since version 1.21. Use "html" instead.' , E_USER_DEPRECATED ) ; $ defaultStrategy = 'html' ; } if ( 'filename' === $ defaultStrategy ) { @ trigger_error ( 'Using "filename" as the default strategy is deprecated since version 1.27. Use "name" instead.' , E_USER_DEPRECATED ) ; $ defaultStrategy = 'name' ; } if ( 'name' === $ defaultStrategy ) { $ defaultStrategy = array ( 'Twig_FileExtensionEscapingStrategy' , 'guess' ) ; } $ this -> defaultStrategy = $ defaultStrategy ; }
8440	public function createAction ( string $ production_slug , Request $ request , TokenStorageInterface $ token , AuthorizationCheckerInterface $ auth ) : Response { $ production_repo = $ this -> em -> getRepository ( Production :: class ) ; if ( null === $ production = $ production_repo -> findOneBy ( [ 'slug' => $ production_slug ] ) ) { throw new NotFoundHttpException ( ) ; } if ( ! $ auth -> isGranted ( 'GROUP_ROLE_USER' , $ production ) ) { throw new AccessDeniedException ( ) ; } $ user = $ token -> getToken ( ) -> getUser ( ) ; $ post = new Post ( ) ; $ post -> setActive ( true ) ; $ post -> setPinned ( false ) ; $ post -> setAuthor ( $ user -> getUsername ( ) ) ; $ post -> addGroup ( $ production ) ; if ( $ request -> query -> has ( 'reply-to' ) ) { $ repo = $ this -> em -> getRepository ( Post :: class ) ; if ( null === $ parent = $ repo -> findOneBy ( [ 'id' => $ request -> query -> get ( 'reply-to' ) ] ) ) { throw new NotFoundHttpException ( ) ; } if ( ! $ parent -> getGroups ( ) -> contains ( $ production ) ) { throw new AccessDeniedException ( ) ; } if ( null !== $ parent -> getParent ( ) ) { throw new AccessDeniedException ( ) ; } $ post -> setParent ( $ parent ) ; $ form = $ this -> form -> create ( ReplyType :: class , $ post ) ; } else { $ form = $ this -> form -> create ( PostType :: class , $ post ) ; } $ form -> handleRequest ( $ request ) ; if ( $ form -> isSubmitted ( ) && $ form -> isValid ( ) ) { $ this -> em -> persist ( $ post ) ; $ this -> em -> flush ( ) ; $ this -> session -> getFlashBag ( ) -> add ( 'success' , $ this -> translator -> trans ( 'post.created' , [ ] , BkstgNoticeBoardBundle :: TRANSLATION_DOMAIN ) ) ; return new RedirectResponse ( $ this -> url_generator -> generate ( 'bkstg_board_show' , [ 'production_slug' => $ production -> getSlug ( ) ] ) ) ; } return new Response ( $ this -> templating -> render ( '@BkstgNoticeBoard/Post/create.html.twig' , [ 'form' => $ form -> createView ( ) , 'post' => $ post , 'production' => $ production , ] ) ) ; }
6012	public function addCommentResponse ( $ item ) { if ( ! ( $ item instanceof self ) ) { if ( is_array ( $ item ) ) { try { $ item = new self ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate CommentResponse. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "CommentResponse"!' , E_USER_WARNING ) ; } } $ this -> replies [ ] = $ item ; return $ this ; }
11483	public function getFactory ( $ class , array $ params = array ( ) ) { if ( ! isset ( $ this -> factories [ $ class ] ) && $ this -> autowire ) { $ this -> factories [ $ class ] = Definition :: getDefaultForClass ( $ class ) ; } $ factory = $ this -> factories [ $ class ] ; if ( $ params ) { $ factory = $ factory -> getFactory ( $ params ) ; } return $ factory ; }
8683	public static function from ( $ iterable ) { if ( is_array ( $ iterable ) ) { return $ iterable ; } if ( $ iterable instanceof ImmutableBag ) { return $ iterable -> toArray ( ) ; } if ( $ iterable instanceof Traversable ) { return iterator_to_array ( $ iterable ) ; } if ( $ iterable === null ) { return [ ] ; } if ( $ iterable instanceof \ stdClass ) { return ( array ) $ iterable ; } Assert :: nullOrIsIterable ( $ iterable ) ; }
922	private function ensureAreTogether ( DocBlock $ doc , Annotation $ first , Annotation $ second ) { $ pos = $ first -> getEnd ( ) ; $ final = $ second -> getStart ( ) ; for ( $ pos = $ pos + 1 ; $ pos < $ final ; ++ $ pos ) { $ doc -> getLine ( $ pos ) -> remove ( ) ; } }
587	protected function buildTarget ( $ target , $ type , $ bundles ) { $ inputFiles = [ ] ; foreach ( $ target -> depends as $ name ) { if ( isset ( $ bundles [ $ name ] ) ) { if ( ! $ this -> isBundleExternal ( $ bundles [ $ name ] ) ) { foreach ( $ bundles [ $ name ] -> $ type as $ file ) { if ( is_array ( $ file ) ) { $ inputFiles [ ] = $ bundles [ $ name ] -> basePath . '/' . $ file [ 0 ] ; } else { $ inputFiles [ ] = $ bundles [ $ name ] -> basePath . '/' . $ file ; } } } } else { throw new Exception ( "Unknown bundle: '{$name}'" ) ; } } if ( empty ( $ inputFiles ) ) { $ target -> $ type = [ ] ; } else { FileHelper :: createDirectory ( $ target -> basePath , $ this -> getAssetManager ( ) -> dirMode ) ; $ tempFile = $ target -> basePath . '/' . strtr ( $ target -> $ type , [ '{hash}' => 'temp' ] ) ; if ( $ type === 'js' ) { $ this -> compressJsFiles ( $ inputFiles , $ tempFile ) ; } else { $ this -> compressCssFiles ( $ inputFiles , $ tempFile ) ; } $ targetFile = strtr ( $ target -> $ type , [ '{hash}' => md5_file ( $ tempFile ) ] ) ; $ outputFile = $ target -> basePath . '/' . $ targetFile ; rename ( $ tempFile , $ outputFile ) ; $ target -> $ type = [ $ targetFile ] ; } }
3945	public function onLoadDataContainer ( $ tableName ) { static $ tableExists ; if ( null === $ tableExists ) { $ tableExists = \ System :: getContainer ( ) -> get ( 'database_connection' ) -> getSchemaManager ( ) -> tablesExist ( [ 'tl_metamodel' ] ) ; } if ( false === $ tableExists ) { return ; } $ this -> handleMetaModelTable ( $ tableName ) ; $ this -> handleNonMetaModelTable ( $ tableName ) ; }
6232	public function setPickupPoint ( $ pickup_point_id ) { $ service = new AdditionalService ( ) ; $ service -> setServiceCode ( 2106 ) ; $ service -> addSpecifier ( 'pickup_point_id' , $ pickup_point_id ) ; $ this -> addAdditionalService ( $ service ) ; }
5868	public static function getMetadata ( $ fileName , $ fullExtract = false ) { $ metadata = static :: getBasicMetadata ( $ fileName ) ; if ( $ fullExtract && ! empty ( $ metadata ) ) { $ virtualFileObject = static :: getVirtualFileObject ( $ fileName , $ metadata ) ; $ extractorRegistry = \ TYPO3 \ CMS \ Core \ Resource \ Index \ ExtractorRegistry :: getInstance ( ) ; $ extractionServices = $ extractorRegistry -> getExtractorsWithDriverSupport ( 'Local' ) ; $ newMetadata = [ 0 => $ metadata , ] ; foreach ( $ extractionServices as $ service ) { if ( $ service -> canProcess ( $ virtualFileObject ) ) { $ newMetadata [ $ service -> getPriority ( ) ] = $ service -> extractMetaData ( $ virtualFileObject , $ newMetadata ) ; } } ksort ( $ newMetadata ) ; foreach ( $ newMetadata as $ data ) { $ metadata = array_merge ( $ metadata , $ data ) ; } } return $ metadata ; }
6341	final public static function init ( ) : void { $ className = static :: class ; self :: $ cache [ $ className ] = [ ] ; $ reflectionClass = self :: objectClass ( ) ; $ constructorParams = static :: constructorArgs ( ) ; $ ordinal = 0 ; foreach ( $ reflectionClass -> getProperties ( ReflectionProperty :: IS_STATIC ) as $ property ) { if ( $ property -> isPublic ( ) ) { $ name = $ property -> getName ( ) ; $ instance = self :: newInstance ( $ name , $ constructorParams ) ; $ property -> setValue ( $ instance ) ; self :: $ cache [ $ className ] [ $ name ] = $ instance ; self :: $ ordinals [ $ className ] [ $ name ] = $ ordinal ++ ; } } }
10505	private function registerStyler ( ) { $ this -> app -> singleton ( Contracts \ Utilities \ LogStyler :: class , Utilities \ LogStyler :: class ) ; $ this -> app -> singleton ( 'arcanedev.log-viewer.styler' , Contracts \ Utilities \ LogStyler :: class ) ; }
5617	public function getTotalSize ( ) { if ( ! isset ( $ this -> _size ) ) { $ size = $ this -> getSize ( ) ; if ( ! $ this -> isLeaf ( ) ) { foreach ( $ this -> getChildren ( ) as $ child ) { $ size += $ child -> getTotalSize ( ) ; } } $ this -> _size = $ size ; } return $ this -> _size ; }
5488	public function submit ( $ additional = false ) { $ encoding = $ this -> encode ( ) ; if ( $ additional ) { $ encoding -> merge ( $ additional ) ; } return $ encoding ; }
6693	public static function sort ( $ a , $ b ) { if ( ! isset ( $ a [ 'position' ] ) ) { return 0 ; } if ( ! isset ( $ b [ 'position' ] ) ) { return 0 ; } if ( $ a [ 'position' ] === $ b [ 'position' ] ) { return 0 ; } return ( $ a [ 'position' ] < $ b [ 'position' ] ) ? - 1 : 1 ; }
191	public function setStatusCodeByException ( $ e ) { if ( $ e instanceof HttpException ) { $ this -> setStatusCode ( $ e -> statusCode ) ; } else { $ this -> setStatusCode ( 500 ) ; } return $ this ; }
4949	public function createQueryBuilder ( $ findDrafts = false ) { $ qb = parent :: createQueryBuilder ( ) ; if ( null !== $ findDrafts ) { $ qb -> field ( 'isDraft' ) -> equals ( $ findDrafts ) ; } return $ qb ; }
1976	public static function findMultipleFoldersByFolder ( $ strPath , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ strPath = str_replace ( array ( '\\' , '%' , '_' ) , array ( '\\\\' , '\\%' , '\\_' ) , $ strPath ) ; return static :: findBy ( array ( "$t.type='folder' AND $t.path LIKE ? AND $t.path NOT LIKE ?" ) , array ( $ strPath . '/%' , $ strPath . '/%/%' ) , $ arrOptions ) ; }
11644	protected function getConnection ( ) { $ connection = $ this -> getClient ( ) -> getConnection ( ) ; if ( $ connection instanceof ReplicationInterface ) { $ connection -> switchToMaster ( ) ; } return $ connection ; }
6654	public function getRequestToken ( $ settings , OAuthConsumerInterface $ consumer , OAuthTokenInterface $ token ) { $ url = $ settings [ 'auth_api_url' ] . $ settings [ 'request_token_uri' ] ; $ options = [ 'oauth_callback' => $ settings [ 'callback_url' ] ] ; $ headers = $ this -> headers ( $ settings , 'POST' , $ url , $ consumer , $ token , $ options ) ; $ request = [ 'url' => $ url , 'headers' => $ headers ] ; return $ this -> token -> makeRequestToken ( $ this -> http -> post ( $ request ) ) ; }
5406	protected function findFirstMatch ( $ cookie ) { for ( $ i = 0 ; $ i < count ( $ this -> cookies ) ; $ i ++ ) { $ is_match = $ this -> isMatch ( $ cookie , $ this -> cookies [ $ i ] -> getHost ( ) , $ this -> cookies [ $ i ] -> getPath ( ) , $ this -> cookies [ $ i ] -> getName ( ) ) ; if ( $ is_match ) { return $ i ; } } return count ( $ this -> cookies ) ; }
7725	public function url ( $ text , $ title , $ url ) { $ payload = [ 'template_type' => 'button' , 'text' => $ text , 'buttons' => [ [ 'title' => $ title , 'url' => $ url ] ] , ] ; $ this -> setAttachment ( 'template' , $ payload ) ; return $ this ; }
10765	public function generateImage ( $ filename = false , $ level = Constants :: QR_ECLEVEL_L , $ size = 3 , $ margin = 4 ) { $ result = 'SPD' . self :: DELIMITER . $ this -> version . self :: DELIMITER . $ this -> implodeContent ( ) ; if ( $ this -> appendCRC32 ) { $ result .= self :: DELIMITER . 'CRC32:' . sprintf ( '%x' , crc32 ( $ result ) ) ; } QRcode :: png ( $ result , $ filename , $ level , $ size , $ margin ) ; die ( ) ; }
12007	final public function getPermissions ( $ authenticated ) { $ this -> userid = ( int ) $ authenticated -> get ( "user_id" ) ; if ( $ authenticated -> authenticated && ! empty ( $ this -> userid ) ) { $ this -> setAuthority ( AUTHROITY_IMPLIED_AUTHENTICATED ) ; } }
2609	public function getNextVersion ( array $ versions ) { if ( isset ( end ( $ versions ) -> number ) ) { return ( int ) end ( $ versions ) -> number + 1 ; } throw new LocalizedException ( __ ( 'Error fetching next version.' ) ) ; }
6244	protected function getPermissionGroupIndex ( $ groups ) { $ index = [ ] ; foreach ( $ groups as $ key => $ presence ) { $ permissions = $ presence -> permissions ( ) ; if ( ! $ permissions ) { continue ; } if ( ! is_array ( $ permissions ) ) { $ permissions = [ $ permissions ] ; } foreach ( $ permissions as $ permission ) { $ index [ $ permission ] = $ key ; } } return $ index ; }
10240	public function calculateCellValue ( Cell $ pCell = null , $ resetLog = true ) { if ( $ pCell === null ) { return null ; } $ returnArrayAsType = self :: $ returnArrayAsType ; if ( $ resetLog ) { $ this -> formulaError = null ; $ this -> debugLog -> clearLog ( ) ; $ this -> cyclicReferenceStack -> clear ( ) ; $ this -> cyclicFormulaCounter = 1 ; self :: $ returnArrayAsType = self :: RETURN_ARRAY_AS_ARRAY ; } $ this -> cellStack [ ] = [ 'sheet' => $ pCell -> getWorksheet ( ) -> getTitle ( ) , 'cell' => $ pCell -> getCoordinate ( ) , ] ; try { $ result = self :: unwrapResult ( $ this -> _calculateFormulaValue ( $ pCell -> getValue ( ) , $ pCell -> getCoordinate ( ) , $ pCell ) ) ; $ cellAddress = array_pop ( $ this -> cellStack ) ; $ this -> spreadsheet -> getSheetByName ( $ cellAddress [ 'sheet' ] ) -> getCell ( $ cellAddress [ 'cell' ] ) ; } catch ( \ Exception $ e ) { $ cellAddress = array_pop ( $ this -> cellStack ) ; $ this -> spreadsheet -> getSheetByName ( $ cellAddress [ 'sheet' ] ) -> getCell ( $ cellAddress [ 'cell' ] ) ; throw new Exception ( $ e -> getMessage ( ) ) ; } if ( ( is_array ( $ result ) ) && ( self :: $ returnArrayAsType != self :: RETURN_ARRAY_AS_ARRAY ) ) { self :: $ returnArrayAsType = $ returnArrayAsType ; $ testResult = Functions :: flattenArray ( $ result ) ; if ( self :: $ returnArrayAsType == self :: RETURN_ARRAY_AS_ERROR ) { return Functions :: VALUE ( ) ; } if ( count ( $ testResult ) != 1 ) { $ r = array_keys ( $ result ) ; $ r = array_shift ( $ r ) ; if ( ! is_numeric ( $ r ) ) { return Functions :: VALUE ( ) ; } if ( is_array ( $ result [ $ r ] ) ) { $ c = array_keys ( $ result [ $ r ] ) ; $ c = array_shift ( $ c ) ; if ( ! is_numeric ( $ c ) ) { return Functions :: VALUE ( ) ; } } } $ result = array_shift ( $ testResult ) ; } self :: $ returnArrayAsType = $ returnArrayAsType ; if ( $ result === null ) { return 0 ; } elseif ( ( is_float ( $ result ) ) && ( ( is_nan ( $ result ) ) || ( is_infinite ( $ result ) ) ) ) { return Functions :: NAN ( ) ; } return $ result ; }
1082	private function skip ( $ kind ) { $ match = $ this -> lexer -> token -> kind === $ kind ; if ( $ match ) { $ this -> lexer -> advance ( ) ; } return $ match ; }
10077	public static function sanitizeUTF8 ( $ value ) { if ( self :: getIsIconvEnabled ( ) ) { $ value = @ iconv ( 'UTF-8' , 'UTF-8' , $ value ) ; return $ value ; } $ value = mb_convert_encoding ( $ value , 'UTF-8' , 'UTF-8' ) ; return $ value ; }
8524	public function setItemList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ItemList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
7129	public function hasNotifications ( $ type = null ) { if ( null !== $ type ) { NotificationTypes :: isValidType ( $ type ) ; return $ this -> getNotifications ( $ type ) -> count ( ) ; } return 0 < $ this -> notifications -> count ( ) ; }
4919	public function attachInputFilterDefaults ( InputFilterInterface $ inputFilter , FieldsetInterface $ fieldset ) { parent :: attachInputFilterDefaults ( $ inputFilter , $ fieldset ) ; foreach ( $ inputFilter -> getInputs ( ) as $ name => $ input ) { if ( ! $ input instanceof InputFilterInterface ) { $ required = $ input -> isRequired ( ) ; $ inputExists = $ fieldset -> has ( $ name ) ; if ( ! $ inputExists && $ required ) { $ fieldsetName = '' ; if ( $ fieldset -> hasAttribute ( 'name' ) ) { $ fieldsetName = 'in Fieldset "' . $ fieldset -> getAttribute ( 'name' ) . '" ' ; } throw new \ RuntimeException ( 'input for "' . $ name . '" ' . $ fieldsetName . 'is required but a input-field with this name is not defined' ) ; } } } }
12161	public function getIsChildless ( ) { if ( empty ( $ this -> collectorItem ) || empty ( $ this -> collectorItem -> children ) ) { return true ; } return false ; }
10065	public function setPieces ( $ pieces ) { if ( $ pieces && ! $ pieces instanceof PieceBag ) { $ pieces = new PieceBag ( is_array ( $ pieces ) ? $ pieces : [ ] ) ; } return $ this -> setParameter ( 'pieces' , $ pieces ) ; }
12	public function setOptimizeAutoloader ( $ optimizeAutoloader = false ) { $ this -> optimizeAutoloader = ( bool ) $ optimizeAutoloader ; if ( ! $ this -> optimizeAutoloader ) { $ this -> setClassMapAuthoritative ( false ) ; } return $ this ; }
7886	public function levels ( ) { if ( ! $ this -> levels ) { $ class = new ReflectionClass ( new LogLevel ( ) ) ; $ this -> levels = $ class -> getConstants ( ) ; } return $ this -> levels ; }
7758	protected function loadMappingInformation ( array $ config , ContainerBuilder $ container ) { $ this -> drivers = array ( ) ; if ( $ config [ 'auto_mapping' ] ) { foreach ( array_keys ( $ container -> getParameter ( 'kernel.bundles' ) ) as $ bundle ) { if ( ! isset ( $ config [ 'mappings' ] [ $ bundle ] ) ) { $ config [ 'mappings' ] [ $ bundle ] = array ( 'mapping' => true , 'is_bundle' => true , ) ; } } } $ container -> setAlias ( 'hydra.naming_strategy' , new Alias ( $ config [ 'naming_strategy' ] , false ) ) ; foreach ( $ config [ 'mappings' ] as $ mappingName => $ mappingConfig ) { if ( null !== $ mappingConfig && false === $ mappingConfig [ 'mapping' ] ) { continue ; } $ mappingConfig = array_replace ( array ( 'dir' => false , 'type' => false , 'prefix' => false , ) , ( array ) $ mappingConfig ) ; $ mappingConfig [ 'dir' ] = $ container -> getParameterBag ( ) -> resolveValue ( $ mappingConfig [ 'dir' ] ) ; if ( ! isset ( $ mappingConfig [ 'is_bundle' ] ) ) { $ mappingConfig [ 'is_bundle' ] = ! is_dir ( $ mappingConfig [ 'dir' ] ) ; } if ( $ mappingConfig [ 'is_bundle' ] ) { $ bundle = null ; foreach ( $ container -> getParameter ( 'kernel.bundles' ) as $ name => $ class ) { if ( $ mappingName === $ name ) { $ bundle = new \ ReflectionClass ( $ class ) ; break ; } } if ( null === $ bundle ) { throw new \ InvalidArgumentException ( sprintf ( 'Bundle "%s" does not exist or it is not enabled.' , $ mappingName ) ) ; } $ mappingConfig = $ this -> getMappingDriverBundleConfigDefaults ( $ mappingConfig , $ bundle , $ container ) ; if ( ! $ mappingConfig ) { continue ; } } $ this -> validateMappingConfiguration ( $ mappingConfig , $ mappingName ) ; $ this -> setMappingDriverConfig ( $ mappingConfig , $ mappingName ) ; } $ this -> registerMappingDrivers ( $ config , $ container ) ; }
9454	protected function doParse ( StringReader $ string ) { $ val = null ; $ type = substr ( $ string -> read ( 2 ) , 0 , 1 ) ; switch ( $ type ) { case 'a' : $ count = ( int ) $ string -> readUntil ( ':' ) ; $ string -> read ( 1 ) ; $ val = [ ] ; for ( $ i = 0 ; $ i < $ count ; $ i ++ ) { $ array_key = $ this -> doParse ( $ string ) ; $ array_value = $ this -> doParse ( $ string ) ; $ val [ $ array_key ] = $ array_value ; } $ string -> read ( 1 ) ; break ; case 'O' : $ len = ( int ) $ string -> readUntil ( ':' ) ; $ class = $ string -> read ( 2 + $ len ) ; $ string -> read ( 1 ) ; $ properties = [ '__class_name' => $ class ] ; $ len = ( int ) $ string -> readUntil ( ':' ) ; $ string -> read ( 1 ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { $ prop_key = $ this -> doParse ( $ string ) ; $ prop_value = $ this -> doParse ( $ string ) ; if ( substr ( $ prop_key , 0 , strlen ( self :: PROTECTED_PREFIX ) ) == self :: PROTECTED_PREFIX ) { $ prop_key = substr ( $ prop_key , strlen ( self :: PROTECTED_PREFIX ) ) ; } if ( substr ( $ prop_key , 0 , 1 ) == "\0" ) { list ( , $ private_class , $ private_property_name ) = explode ( "\0" , $ prop_key ) ; $ prop_key = $ private_property_name ; } $ properties [ $ prop_key ] = $ prop_value ; } $ string -> read ( 1 ) ; $ val = ( object ) $ properties ; break ; case 's' : $ len = ( int ) $ string -> readUntil ( ':' ) ; $ val = $ string -> read ( $ len + 2 ) ; $ string -> read ( 1 ) ; break ; case 'i' : $ val = ( int ) $ string -> readUntil ( ';' ) ; break ; case 'd' : $ val = ( float ) $ string -> readUntil ( ';' ) ; break ; case 'b' : $ bool = $ string -> read ( 2 ) ; $ val = substr ( $ bool , 0 , 1 ) == '1' ; break ; case 'N' : $ val = null ; break ; default : throw new \ Exception ( sprintf ( 'Unable to unserialize type "%s"' , $ type ) ) ; } return $ val ; }
8996	protected function buildNamespace ( ApiDefinition $ definition , $ namespace ) { if ( $ this -> config [ 'version_in_namespace' ] && $ definition -> getVersion ( ) ) { $ namespace .= '\\' . preg_replace ( array ( '/(^[0-9])/' , '/[^a-zA-Z0-9]/' ) , array ( 'Version\1' , '_' ) , $ definition -> getVersion ( ) ) ; } return $ namespace ; }
5897	public function listVideoTemplates ( CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/templates/videos' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new VideoTemplate ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
909	private function getHeaderAsComment ( ) { $ lineEnding = $ this -> whitespacesConfig -> getLineEnding ( ) ; $ comment = ( self :: HEADER_COMMENT === $ this -> configuration [ 'comment_type' ] ? '/*' : '/**' ) . $ lineEnding ; $ lines = explode ( "\n" , str_replace ( "\r" , '' , $ this -> configuration [ 'header' ] ) ) ; foreach ( $ lines as $ line ) { $ comment .= rtrim ( ' * ' . $ line ) . $ lineEnding ; } return $ comment . ' */' ; }
1788	public function editArticle ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { $ objPage = Contao \ PageModel :: findById ( $ row [ 'pid' ] ) ; return $ this -> User -> isAllowed ( Contao \ BackendUser :: CAN_EDIT_ARTICLES , $ objPage -> row ( ) ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' ; }
10683	public function preferred ( array $ types ) : ? string { if ( empty ( $ types ) ) { return null ; } foreach ( $ this -> types as $ type ) { if ( in_array ( $ type , $ types , true ) ) { return $ type ; } elseif ( '*/*' == $ type ) { return current ( $ types ) ; } elseif ( strlen ( $ type ) > 2 && substr ( $ type , - 2 , 2 ) == '/*' ) { $ prefix = substr ( $ type , 0 , strpos ( $ type , '/' ) + 1 ) ; $ plen = strlen ( $ prefix ) ; foreach ( $ types as $ t ) { if ( strncmp ( $ prefix , $ t , $ plen ) === 0 ) { return $ t ; } } } } return null ; }
2069	public function cutPage ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { return ( $ this -> User -> hasAccess ( $ row [ 'type' ] , 'alpty' ) && $ this -> User -> isAllowed ( Contao \ BackendUser :: CAN_EDIT_PAGE_HIERARCHY , $ row ) ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' ; }
978	protected function validateShop ( Request $ request ) { $ shopParam = ShopifyApp :: sanitizeShopDomain ( $ request -> get ( 'shop' ) ) ; $ shop = ShopifyApp :: shop ( $ shopParam ) ; $ session = new ShopSession ( $ shop ) ; if ( $ shop === null || $ shop -> trashed ( ) || empty ( $ session -> getToken ( true ) ) || ( $ shopParam && $ shopParam !== $ shop -> shopify_domain ) === true ) { $ session -> forget ( ) ; Session :: put ( 'return_to' , $ request -> fullUrl ( ) ) ; return Redirect :: route ( 'authenticate' , [ 'shop' => $ shopParam ] ) ; } return true ; }
438	public function __isset ( $ name ) { $ getter = 'get' . $ name ; if ( method_exists ( $ this , $ getter ) ) { return $ this -> $ getter ( ) !== null ; } $ this -> ensureBehaviors ( ) ; foreach ( $ this -> _behaviors as $ behavior ) { if ( $ behavior -> canGetProperty ( $ name ) ) { return $ behavior -> $ name !== null ; } } return false ; }
4492	public function broadcast ( Message $ message , string $ topicArn ) { if ( $ this -> debug ) { $ this -> logger && $ this -> logger -> notice ( "Message would have been sent to $topicArn" , [ 'Message' => $ message , ] ) ; return ; } $ this -> messages -> send ( $ message , $ topicArn ) ; }
10500	public function lte ( $ value ) { $ value = Cast :: Float ( $ value ) ; if ( $ this -> value !== null && $ this -> value <= $ value ) { return true ; } return false ; }
4903	public function createService ( ServiceLocatorInterface $ serviceLocator ) { $ select = $ this ( $ serviceLocator , self :: class , $ this -> options ) ; $ this -> options = [ ] ; return $ select ; }
1503	public function handle ( $ request , Closure $ next , string $ namespace ) { $ api = $ this -> bindApi ( $ namespace , $ request -> getSchemeAndHttpHost ( ) . $ request -> getBaseUrl ( ) ) ; $ this -> substituteBindings ( $ api ) ; $ this -> bindPageResolver ( ) ; return $ next ( $ request ) ; }
11993	public function orderBy ( $ key , $ direction = 'asc' ) { return $ this -> sort ( function ( $ a , $ b ) use ( $ key , $ direction ) { $ valueA = is_object ( $ a ) ? $ a -> { $ key } : $ a [ $ key ] ; $ valueB = is_object ( $ b ) ? $ b -> { $ key } : $ b [ $ key ] ; if ( $ valueA == $ valueB ) return 0 ; $ result = ( $ valueA < $ valueB ) ? - 1 : 1 ; return $ direction === 'desc' ? - ( $ result ) : $ result ; } ) ; }
299	public function beforeSave ( $ insert ) { $ event = new ModelEvent ( ) ; $ this -> trigger ( $ insert ? self :: EVENT_BEFORE_INSERT : self :: EVENT_BEFORE_UPDATE , $ event ) ; return $ event -> isValid ; }
7695	function MsPowerpoint_InitSlideLst ( $ Master = false ) { if ( $ Master ) { $ RefLst = & $ this -> OpenXmlSlideMasterLst ; } else { $ RefLst = & $ this -> OpenXmlSlideLst ; } if ( $ RefLst !== false ) return $ RefLst ; $ PresFile = 'ppt/presentation.xml' ; $ prefix = ( $ Master ) ? 'slideMasters/' : 'slides/' ; $ o = $ this -> OpenXML_Rels_GetObj ( 'ppt/presentation.xml' , $ prefix ) ; $ Txt = $ this -> FileRead ( $ PresFile ) ; if ( $ Txt === false ) return false ; $ p = 0 ; $ i = 0 ; $ lst = array ( ) ; $ tag = ( $ Master ) ? 'p:sldMasterId' : 'p:sldId' ; while ( $ loc = clsTbsXmlLoc :: FindStartTag ( $ Txt , $ tag , $ p ) ) { $ i ++ ; $ rid = $ loc -> GetAttLazy ( 'r:id' ) ; if ( $ rid === false ) { $ this -> RaiseError ( "(Init Slide List) attribute 'r:id' is missing for slide #$i in '$PresFile'." ) ; } elseif ( isset ( $ o -> TargetLst [ $ rid ] ) ) { $ f = 'ppt/' . $ o -> TargetLst [ $ rid ] ; $ lst [ ] = array ( 'file' => $ f , 'idx' => $ this -> FileGetIdx ( $ f ) , 'rid' => $ rid ) ; } else { $ this -> RaiseError ( "(Init Slide List) Slide corresponding to rid=$rid is not found in the Rels file of '$PresFile'." ) ; } $ p = $ loc -> PosEnd ; } $ RefLst = $ lst ; return $ RefLst ; }
2974	public function analyze ( \ Closure $ closure ) { $ data = [ 'reflection' => new \ ReflectionFunction ( $ closure ) , 'code' => null , 'hasThis' => false , 'context' => [ ] , 'hasRefs' => false , 'binding' => null , 'scope' => null , 'isStatic' => $ this -> isClosureStatic ( $ closure ) , ] ; $ this -> determineCode ( $ data ) ; $ this -> determineContext ( $ data ) ; $ this -> determineBinding ( $ data ) ; return $ data ; }
9123	private function retrieveAndParseResponse ( $ requestType ) { $ this -> payload = new MemoryStream ( ) ; $ this -> headers = array ( ) ; $ delimiterFound = false ; $ tmp = "" ; $ numBytes = 1 ; $ start = time ( ) ; while ( true ) { if ( ! $ this -> checkConnection ( $ start ) ) { continue ; } $ c = $ this -> read ( $ numBytes ) ; if ( $ c == null ) { break ; } $ start = time ( ) ; $ tmp .= $ c ; if ( ! $ delimiterFound ) { $ this -> handleHeader ( $ delimiterFound , $ numBytes , $ tmp ) ; } if ( $ delimiterFound ) { if ( $ requestType == 'HEAD' ) { break ; } $ this -> payload -> write ( $ tmp ) ; $ tmp = "" ; if ( $ this -> checkContentLengthExceeded ( ) ) { break ; } } } $ size = $ this -> payload -> count ( ) ; if ( $ size == 0 ) { return ; } $ this -> payload -> reset ( ) ; $ mayCompressed = $ this -> payload -> read ( $ size ) ; switch ( $ this -> getContentEncoding ( ) ) { case 'gzip' : $ uncompressed = gzdecode ( strstr ( $ mayCompressed , "\x1f\x8b" ) ) ; $ this -> payload -> flush ( ) ; $ this -> payload -> write ( $ uncompressed ) ; break ; case 'deflate' : $ uncompressed = gzuncompress ( $ mayCompressed ) ; $ this -> payload -> flush ( ) ; $ this -> payload -> write ( $ uncompressed ) ; break ; default : break ; } $ this -> payload -> reset ( ) ; }
6658	public function jsonSerialize ( ) { $ serialized = [ 'message' => $ this -> getPublicMessage ( ) , 'code' => $ this -> getCode ( ) , ] ; if ( $ this -> getPrevious ( ) instanceof $ this ) { $ previous = $ this -> getPrevious ( ) ; $ serialized [ 'previous' ] = $ previous -> jsonSerialize ( ) ; } return $ serialized ; }
1770	public function getErrorsAsString ( $ strSeparator = null ) { if ( $ strSeparator === null ) { $ strSeparator = '<br' . $ this -> strTagEnding . "\n" ; } return $ this -> hasErrors ( ) ? implode ( $ strSeparator , $ this -> arrErrors ) : '' ; }
12155	public function getInitialRole ( ) { $ roles = [ ] ; foreach ( Yii :: $ app -> collectors [ 'roles' ] -> getAll ( ) as $ roleItem ) { $ test = $ roleItem -> level < 400 ; if ( $ test ) { $ roles [ ] = $ roleItem -> object -> primaryKey ; } } return $ roles ; }
6278	protected function find ( $ key ) { $ keyLen = strlen ( $ key ) ; $ u = Util :: hash ( $ key ) ; $ upos = ( $ u << 3 ) & 2047 ; $ hashSlots = $ this -> readInt31 ( $ upos + 4 ) ; if ( ! $ hashSlots ) { return false ; } $ hashPos = $ this -> readInt31 ( $ upos ) ; $ keyHash = $ u ; $ u = Util :: unsignedShiftRight ( $ u , 8 ) ; $ u = Util :: unsignedMod ( $ u , $ hashSlots ) ; $ u <<= 3 ; $ keyPos = $ hashPos + $ u ; for ( $ i = 0 ; $ i < $ hashSlots ; $ i ++ ) { $ hash = $ this -> readInt32 ( $ keyPos ) ; $ pos = $ this -> readInt31 ( $ keyPos + 4 ) ; if ( ! $ pos ) { return false ; } $ keyPos += 8 ; if ( $ keyPos == $ hashPos + ( $ hashSlots << 3 ) ) { $ keyPos = $ hashPos ; } if ( $ hash === $ keyHash ) { if ( $ keyLen === $ this -> readInt31 ( $ pos ) ) { $ dataLen = $ this -> readInt31 ( $ pos + 4 ) ; $ dataPos = $ pos + 8 + $ keyLen ; $ foundKey = $ this -> read ( $ pos + 8 , $ keyLen ) ; if ( $ foundKey === $ key ) { $ this -> dataLen = $ dataLen ; $ this -> dataPos = $ dataPos ; return true ; } } } } return false ; }
4454	private function registerSyncCompleteEvent ( ) : void { $ this -> getEventsManager ( ) -> attach ( QueueEvent \ AfterEnqueue :: getName ( ) , function ( QueueEvent \ AfterEnqueue $ event ) { if ( ! $ this -> client -> config -> get ( 'sync-enabled' ) ) { return ; } $ job = $ this -> popByJid ( $ event -> getJid ( ) ) ; if ( ! empty ( $ job ) ) { $ job -> perform ( ) ; } } ) ; }
7418	protected function setJSONContent ( array $ content ) { if ( $ this -> deleteJsonKeys ) { $ content = $ this -> deleteArrayKeys ( $ content ) ; } $ content = json_encode ( $ content , JSON_UNESCAPED_UNICODE ) ; $ this -> response -> setContentTypeJson ( ) ; $ this -> response -> setContent ( $ content ) ; }
6157	public function redirectSelf ( ) : object { $ url = $ this -> di -> get ( "request" ) -> getCurrentUrl ( ) ; return parent :: redirect ( $ this -> di -> get ( "url" ) -> create ( $ url ) ) ; }
6132	protected function getSuffixFlag ( ) { if ( ! $ this -> currObj instanceof Client ) { return "" ; } if ( $ this -> flagpath && $ this -> currObj [ "client_country" ] ) { return $ this -> getImage ( $ this -> currObj [ "client_country" ] -> toLower ( ) . ".png" , $ this -> currObj [ "client_country" ] , null , false , true ) ; } return "" ; }
11293	protected function _getAttributeData ( $ name , $ query = false , $ loadMap = false , $ record = false ) { if ( isset ( $ this -> model_data [ $ name ] ) ) { return $ this -> _getAttributeDataWhenSet ( $ name , $ query , $ loadMap , $ record ) ; } if ( isset ( $ this -> model_attributes [ $ name ] ) && ! isset ( $ this -> model_dynamicOff ) ) { return $ this -> _getAttributeDataWhenUnset ( $ name , $ query , $ loadMap , $ record ) ; } if ( isset ( $ this -> data -> { $ name } ) ) { $ this -> beforeGet ( $ name ) ; $ returnValue = $ this -> data -> { $ name } ; $ this -> afterGet ( $ name , $ returnValue ) ; return $ returnValue ; } $ class = get_class ( $ this ) ; if ( property_exists ( $ class , $ name ) ) { $ this -> beforeGet ( $ name ) ; $ returnValue = $ this -> { $ name } ; $ this -> afterGet ( $ name , $ returnValue ) ; return $ returnValue ; } if ( $ name == 'id' && property_exists ( $ class , 'id_name' ) ) { $ this -> beforeGet ( $ this -> id_name ) ; if ( isset ( $ this -> model_data [ $ this -> id_name ] ) ) { $ returnValue = $ this -> model_data [ $ this -> id_name ] ; } else { $ returnValue = $ this -> { $ this -> id_name } ; } $ this -> afterGet ( $ this -> id_name , $ returnValue ) ; return $ returnValue ; } if ( substr ( $ name , 0 , 6 ) != "model_" && $ this -> issetExtended ( $ name ) ) { $ this -> beforeGet ( $ name ) ; $ returnValue = $ this -> getExtendedAttribute ( $ name ) ; $ this -> afterGet ( $ name , $ returnValue ) ; return $ returnValue ; } $ this -> beforeGet ( $ name ) ; if ( isset ( $ this -> { $ name } ) ) { $ returnValue = $ this -> { $ name } ; } else { $ returnValue = null ; } $ this -> afterGet ( $ name , $ returnValue ) ; return $ returnValue ; }
11144	protected function processClass ( $ class ) { if ( ! class_exists ( '\\' . $ class ) ) { throw new ExtDirectException ( " '{$class}' does not exist!" ) ; } $ annotationReader = new AnnotationReader ( ) ; AnnotationRegistry :: registerLoader ( 'class_exists' ) ; $ reflectionClass = new ReflectionClass ( $ class ) ; $ classAnnotation = $ annotationReader -> getClassAnnotation ( $ reflectionClass , 'ExtDirect\Annotations\Direct' ) ; if ( $ classAnnotation instanceof \ ExtDirect \ Annotations \ Direct ) { $ classAnnotation -> setClassName ( $ class ) ; $ methodCollection = new RemotableCollection ( ) ; foreach ( $ reflectionClass -> getMethods ( ) as $ reflectionMethod ) { $ methodAnnotation = $ annotationReader -> getMethodAnnotation ( $ reflectionMethod , 'ExtDirect\Annotations\Remotable' ) ; if ( $ methodAnnotation instanceof \ ExtDirect \ Annotations \ Remotable ) { $ methodAnnotation -> setMethodName ( $ reflectionMethod -> getName ( ) ) ; $ methodCollection -> add ( $ methodAnnotation ) ; } } $ classAnnotation -> setMethods ( $ methodCollection ) ; return $ classAnnotation ; } return false ; }
1329	public function set ( $ key , $ value = null ) { $ keys = is_array ( $ key ) ? $ key : [ $ key => $ value ] ; foreach ( $ keys as $ key => $ value ) { self :: updateOrCreate ( [ 'key' => $ key ] , [ 'value' => $ value ] ) ; } }
10906	public function remove ( ) : bool { if ( $ this -> test ( \ sndsgd \ Fs :: EXISTS | \ sndsgd \ Fs :: READABLE | \ sndsgd \ Fs :: WRITABLE ) === false ) { $ this -> error = "failed to remove directory; {$this->error}" ; return false ; } foreach ( $ this -> getList ( ) as $ entity ) { if ( $ entity -> remove ( ) === false ) { $ this -> error = $ entity -> getError ( ) ; return false ; } } if ( @ rmdir ( $ this -> path ) === false ) { $ this -> setError ( "failed to remove directory '{$this->path}'" ) ; return false ; } return true ; }
12234	public function firstOf ( $ xpath ) { $ nodes = $ this -> xpath ( $ xpath ) ; return ( isset ( $ nodes [ 0 ] ) ) ? $ nodes [ 0 ] : null ; }
12620	public function createModel ( $ id , $ attributes ) { return Yii :: createObject ( [ 'class' => $ this -> foreignModelClass , 'tableName' => $ this -> fileSource -> id , 'interface' => $ this -> module , 'id' => $ id , 'attributes' => $ attributes ] ) ; }
7465	public static function createFromUploadedFile ( UploadedFile $ upload , $ uploadPath , $ filename = null ) { if ( ! $ upload -> isValid ( ) ) { throw new UploadException ( sprintf ( 'An error occurred during file upload. Error code: %s' , $ upload -> getError ( ) ) ) ; } elseif ( ( $ uploadPath = realpath ( $ uploadPath . '/' ) ) === false ) { throw new UploadException ( 'An error occurred during file upload. The specified upload path is invalid.' ) ; } if ( ! $ filename ) { $ fullPath = sprintf ( '%s%s%s.%s' , rtrim ( $ uploadPath , DIRECTORY_SEPARATOR ) , DIRECTORY_SEPARATOR , uniqid ( ) , ( $ upload -> getExtension ( ) ? : ( $ upload -> guessExtension ( ) ? : 'file' ) ) ) ; } else { $ fullPath = rtrim ( $ uploadPath , DIRECTORY_SEPARATOR ) . DIRECTORY_SEPARATOR . $ filename ; } $ file = new self ( $ fullPath , $ upload -> getClientOriginalName ( ) , $ upload -> getMimeType ( ) , $ upload -> getClientSize ( ) , md5_file ( $ upload -> getRealPath ( ) ) ) ; $ file -> _uploadedFile = $ upload ; return $ file ; }
10750	protected function sendVerb ( string $ verb , Response $ response , string $ type , array $ ids , array $ extra = [ ] ) : Response { $ send = array_merge ( [ ] , $ extra ) ; $ send [ 'success' ] = true ; $ send [ 'message' ] = "Objects $verb successfully" ; $ send [ 'objects' ] = array_map ( function ( $ id ) use ( $ type ) { return [ 'type' => $ type , 'id' => $ id ] ; } , $ ids ) ; return $ this -> sendJson ( $ response , $ send ) ; }
6462	public function add ( $ name , $ values , bool $ append = false ) : void { $ normalizedName = self :: normalizeHeaderName ( $ name ) ; if ( ! $ append || ! $ this -> containsKey ( $ normalizedName ) ) { parent :: add ( $ normalizedName , ( array ) $ values ) ; } else { $ currentValues = [ ] ; $ this -> tryGet ( $ normalizedName , $ currentValues ) ; parent :: add ( $ normalizedName , array_merge ( $ currentValues , ( array ) $ values ) ) ; } }
6790	protected function merge ( array $ cachedUnits , array $ fetchedUnits ) { $ cachedIds = [ ] ; foreach ( $ cachedUnits as $ unit ) { if ( null !== $ id = $ unit -> getId ( ) ) { $ cachedIds [ ] = $ unit -> getId ( ) ; } } foreach ( $ fetchedUnits as $ unit ) { if ( in_array ( $ unit -> getId ( ) , $ cachedIds ) ) { continue ; } if ( $ this -> unitCache -> isRemoved ( $ unit ) ) { continue ; } if ( $ this -> persistenceHelper -> isScheduledForRemove ( $ unit ) ) { continue ; } $ cachedUnits [ ] = $ unit ; } return $ cachedUnits ; }
10332	public function setSize ( $ width , $ height ) { if ( ! is_string ( $ width ) && ! is_int ( $ width ) ) { throw new \ InvalidArgumentException ( 'The width argument must be of type string or integer' ) ; } if ( ! is_string ( $ height ) && ! is_int ( $ height ) ) { throw new \ InvalidArgumentException ( 'The height argument must be of type string or integer' ) ; } $ this -> html = preg_replace ( "/ width([ ]?)=([ ]?)[\"\']([0-9\.]+)[\"\']/" , " width=\"" . $ width . "\"" , $ this -> html ) ; $ this -> html = preg_replace ( "/ height([ ]?)=([ ]?)[\"\']([0-9\.]+)[\"\']/" , " height=\"" . $ height . "\"" , $ this -> html ) ; $ this -> html = preg_replace ( "/width:([0-9\.]+)px/" , "width:" . ( is_numeric ( $ width ) ? $ width . 'px' : $ width ) . "" , $ this -> html ) ; $ this -> html = preg_replace ( "/height:([0-9\.]+)px/" , "height:" . ( is_numeric ( $ height ) ? $ height . 'px' : $ height ) . "" , $ this -> html ) ; $ this -> html = preg_replace ( "/ width([ ]?)=([ ]?)([0-9\.]+)/" , " width=" . $ width , $ this -> html ) ; $ this -> html = preg_replace ( "/ height([ ]?)=([ ]?)([0-9\.]+)/" , " height=" . $ height , $ this -> html ) ; $ this -> width = $ width ; $ this -> height = $ height ; }
9227	public function post ( $ path , $ data = array ( ) , $ headers = array ( ) ) { return $ this -> postprocessResponse ( parent :: post ( $ path , $ this -> preprocessData ( $ data ) , $ headers ) ) ; }
2143	public function generate ( $ objRootPage = null ) { global $ objPage ; $ obj403 = $ this -> prepare ( $ objRootPage ) ; $ objPage = $ obj403 -> loadDetails ( ) ; $ objHandler = new $ GLOBALS [ 'TL_PTY' ] [ 'regular' ] ( ) ; header ( 'HTTP/1.1 403 Forbidden' ) ; $ objHandler -> generate ( $ objPage ) ; }
9937	private static function checkSheetCodeName ( $ pValue ) { $ CharCount = Shared \ StringHelper :: countCharacters ( $ pValue ) ; if ( $ CharCount == 0 ) { throw new Exception ( 'Sheet code name cannot be empty.' ) ; } if ( ( str_replace ( self :: $ invalidCharacters , '' , $ pValue ) !== $ pValue ) || ( Shared \ StringHelper :: substring ( $ pValue , - 1 , 1 ) == '\'' ) || ( Shared \ StringHelper :: substring ( $ pValue , 0 , 1 ) == '\'' ) ) { throw new Exception ( 'Invalid character found in sheet code name' ) ; } if ( $ CharCount > 31 ) { throw new Exception ( 'Maximum 31 characters allowed in sheet code name.' ) ; } return $ pValue ; }
7502	private function getOrCreateGroup ( string $ namespace ) : Group { $ group = $ this -> em -> find ( Group :: getClass ( ) , $ namespace ) ; if ( null !== $ group ) { return $ group ; } $ group = new Group ( $ namespace ) ; $ t = $ this -> tm -> createTransaction ( ) ; $ this -> em -> persist ( $ group ) ; $ t -> commit ( ) ; return $ group ; }
332	public function madd ( $ items , $ duration = 0 , $ dependency = null ) { return $ this -> multiAdd ( $ items , $ duration , $ dependency ) ; }
8198	public function next ( ) { if ( ! isset ( $ this -> tokens [ ++ $ this -> current ] ) ) { throw new Twig_Error_Syntax ( 'Unexpected end of template.' , $ this -> tokens [ $ this -> current - 1 ] -> getLine ( ) , $ this -> source ) ; } return $ this -> tokens [ $ this -> current - 1 ] ; }
3763	private function getLegendProperty ( LegendInterface $ legend , $ propertyName ) { if ( $ legend -> hasProperty ( $ propertyName ) ) { $ property = $ legend -> getProperty ( $ propertyName ) ; } else { $ property = new Property ( $ propertyName ) ; $ legend -> addProperty ( $ property ) ; } return $ property ; }
9325	protected function registerMarkdown ( ) { $ app = $ this -> app ; $ app -> singleton ( 'markdown' , function ( $ app ) { return new Converter ( $ app [ 'commonmark.docparser' ] , $ app [ 'commonmark.htmlrenderer' ] ) ; } ) ; $ app -> alias ( 'markdown' , Converter :: class ) ; }
2751	public function validateCustomSnippet ( $ name , $ type , $ priority ) { $ snippetName = str_replace ( ' ' , '' , $ name ) ; $ types = [ 'init' , 'recv' , 'hit' , 'miss' , 'pass' , 'fetch' , 'error' , 'deliver' , 'log' , 'hash' , 'none' ] ; $ inArray = in_array ( $ type , $ types ) ; $ isNumeric = is_numeric ( $ priority ) ; $ isAlphanumeric = preg_match ( '/^[\w]+$/' , $ snippetName ) ; $ error = null ; if ( ! $ inArray ) { $ error = 'Type value is not recognised.' ; return [ 'snippet_name' => null , 'error' => $ error ] ; } if ( ! $ isNumeric ) { $ error = 'Please make sure that the priority value is a number.' ; return [ 'snippet_name' => null , 'error' => $ error ] ; } if ( ! $ isAlphanumeric ) { $ error = 'Please make sure that the name value contains only alphanumeric characters.' ; return [ 'snippet_name' => null , 'error' => $ error ] ; } return [ 'snippet_name' => $ snippetName , 'error' => $ error ] ; }
3004	public function save ( $ filename ) { $ f3 = \ Base :: instance ( ) ; $ lines = explode ( "\n" , $ this -> smtp -> log ( ) ) ; $ start = false ; $ out = '' ; for ( $ i = 0 , $ max = count ( $ lines ) ; $ i < $ max ; $ i ++ ) { if ( ! $ start && preg_match ( '/^354.*?$/' , $ lines [ $ i ] , $ matches ) ) { $ start = true ; continue ; } elseif ( preg_match ( '/^250.*?$\s^QUIT/m' , $ lines [ $ i ] . ( $ i + 1 < $ max ? "\n" . $ lines [ $ i + 1 ] : '' ) , $ matches ) ) break ; if ( $ start ) $ out .= $ lines [ $ i ] . "\n" ; } if ( $ out ) { $ path = $ f3 -> get ( 'mailer.storage_path' ) ; if ( ! is_dir ( $ path ) ) mkdir ( $ path , 0777 , true ) ; $ f3 -> write ( $ path . $ filename , $ out ) ; } }
5949	public function setResults ( array $ results ) { $ this -> results = [ ] ; foreach ( $ results as $ item ) { switch ( $ item [ 'discriminatorId' ] ) { case ObjectResponse :: DISCRIMINATOR_FOLDER : $ this -> addFolderResponse ( $ item ) ; break ; case ObjectResponse :: DISCRIMINATOR_MEDIA : default : $ this -> addMediaResponse ( $ item ) ; break ; } } return $ this ; }
8459	public function getVersion ( ) { if ( empty ( $ this -> drushVersion ) ) { $ isPrinted = $ this -> isPrinted ; $ this -> isPrinted = false ; $ result = $ this -> executeCommand ( $ this -> executable . ' version' ) ; $ output = $ result -> getMessage ( ) ; $ this -> drushVersion = 'unknown' ; if ( preg_match ( '#[0-9.]+#' , $ output , $ matches ) ) { $ this -> drushVersion = $ matches [ 0 ] ; } $ this -> isPrinted = $ isPrinted ; } return $ this -> drushVersion ; }
9730	public function setMaxParcelDimensions ( $ value = null ) { if ( is_array ( $ value ) ) { $ value = new ParcelDimensions ( $ value ) ; } elseif ( ! ( $ value instanceof ParcelDimensions ) ) { $ value = null ; } return $ this -> setParameter ( 'max_parcel_dimensions' , $ value ) ; }
12553	public function save ( $ path , $ name = null ) { if ( ! file_exists ( $ path ) ) { mkdir ( $ path , 0777 , true ) ; } $ destinationPath = rtrim ( $ path , '/' ) ; if ( $ name ) { $ destinationPath .= '/' . $ name ; } else { $ destinationPath .= '/' . $ this -> name ; } if ( ! copy ( $ this -> tmpName , $ destinationPath ) ) { $ reason = 'Unknown' ; if ( ! file_exists ( $ path ) ) { $ reason = 'Path "' . $ path . '" not exists.' ; } else if ( ! is_writeable ( $ path ) ) $ reason = 'Path "' . $ path . '" required permission to write.' ; throw new FileFailSavedException ( $ reason ) ; } }
8460	public function exec ( $ command ) { fwrite ( $ this -> _fp , str_replace ( "\n" , '\n' , $ command ) . PHP_EOL ) ; $ answer = fgets ( $ this -> _fp ) ; if ( is_string ( $ answer ) ) { if ( substr ( $ answer , 0 , 7 ) === 'ANSWER ' ) { $ bytes = ( int ) substr ( $ answer , 7 ) ; if ( $ bytes > 0 ) { $ jsonObj = json_decode ( trim ( fread ( $ this -> _fp , $ bytes + 1 ) ) ) ; if ( is_null ( $ jsonObj ) ) { return 'You must enable the json flag on the telegram daemon to get proper response messages here.' ; } return $ jsonObj ; } } else { return $ answer ; } } return false ; }
2217	public function getChannels ( ) { if ( ! $ this -> User -> isAdmin && ! \ is_array ( $ this -> User -> newsletters ) ) { return array ( ) ; } $ arrChannels = array ( ) ; $ objChannels = $ this -> Database -> execute ( "SELECT id, title FROM tl_newsletter_channel ORDER BY title" ) ; while ( $ objChannels -> next ( ) ) { if ( $ this -> User -> hasAccess ( $ objChannels -> id , 'newsletters' ) ) { $ arrChannels [ $ objChannels -> id ] = $ objChannels -> title ; } } return $ arrChannels ; }
4384	protected function dumpArray ( $ array ) { $ isNested = $ this -> valDepth > 0 ; $ this -> valDepth ++ ; $ array = parent :: dumpArray ( $ array ) ; $ str = \ trim ( \ print_r ( $ array , true ) ) ; $ str = \ preg_replace ( '#^Array\n\(#' , 'array(' , $ str ) ; $ str = \ preg_replace ( '#^array\s*\(\s+\)#' , 'array()' , $ str ) ; if ( $ isNested ) { $ str = \ str_replace ( "\n" , "\n " , $ str ) ; } return $ str ; }
10136	private function writeZoom ( ) { if ( $ this -> phpSheet -> getSheetView ( ) -> getZoomScale ( ) == 100 ) { return ; } $ record = 0x00A0 ; $ length = 0x0004 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vv' , $ this -> phpSheet -> getSheetView ( ) -> getZoomScale ( ) , 100 ) ; $ this -> append ( $ header . $ data ) ; }
10891	public function syntax ( $ error = "Please specify valid options" ) { $ ostr = ( ! $ error ) ? STDOUT : STDERR ; if ( is_string ( $ error ) ) fprintf ( $ ostr , "Error: %s\n" , $ error ) ; fprintf ( $ ostr , "Syntax: php " . $ _SERVER [ 'argv' ] [ 0 ] . " <options> <action>\n\n" ) ; fprintf ( $ ostr , "Options: \n" ) ; $ max_opt_length = 0 ; $ max_arg_length = 0 ; $ params = $ this -> parameters ; usort ( $ params , function ( $ a , $ b ) { $ lo = ! empty ( $ a [ 0 ] ) ? $ a [ 0 ] : $ a [ 1 ] ; $ ro = ! empty ( $ b [ 0 ] ) ? $ b [ 0 ] : $ b [ 1 ] ; return strcmp ( $ lo , $ ro ) ; } ) ; foreach ( $ params as $ param ) { $ max_opt_length = max ( strlen ( $ param [ 1 ] ) + 3 , $ max_opt_length ) ; $ max_arg_length = max ( strlen ( $ param [ 2 ] ) + 3 , $ max_arg_length ) ; } foreach ( $ this -> parameters as $ param ) { fprintf ( $ ostr , " " ) ; $ so = $ param [ 0 ] ? "-" . $ param [ 0 ] : "" ; $ lo = $ param [ 1 ] ? "--" . $ param [ 1 ] : "" ; $ arg = $ param [ 2 ] ? '<' . $ param [ 2 ] . '>' : "" ; $ pstr = sprintf ( "%-2s %-" . $ max_opt_length . "s %-" . $ max_arg_length . "s " , $ so , $ lo , $ arg ) ; $ indent = strlen ( $ pstr ) + 4 ; fprintf ( $ ostr , $ pstr ) ; self :: formatText ( $ indent , self :: MAX_LINE_LENGTH , $ param [ 3 ] , $ ostr ) ; } exit ( $ error === false ? 0 : 1 ) ; }
7011	private function formatS ( & $ str ) { if ( strstr ( $ str , '%S' ) ) $ str = str_replace ( '%S' , static :: ordinal ( $ this -> day ) , $ str ) ; }
4917	public function setParams ( array $ params ) { foreach ( $ params as $ key => $ value ) { $ this -> setParam ( $ key , $ value ) ; } return $ this ; }
7272	public static function deleteWhere ( $ condition = "" , array $ conditionParams = [ ] ) { $ tableName = static :: tableName ( ) ; if ( empty ( $ condition ) ) return Db :: query ( "delete from $tableName" , [ ] , static :: getDbName ( ) , false ) ; else return Db :: query ( " delete from $tableName where $condition " , $ conditionParams , static :: getDbName ( ) , false ) ; }
4751	public function getPriceByPlanCode ( string $ planCode ) : float { $ plan = $ this -> getPlan ( $ planCode ) ; return ( array_key_exists ( 'recurring_price' , $ plan ) ) ? $ plan [ 'recurring_price' ] : 0 ; }
5741	protected static function prefixData ( $ data ) { $ prefixedData = array ( ) ; foreach ( $ data as $ stat => $ value ) { $ prefixedKey = self :: prefix ( $ stat ) ; $ prefixedData [ $ prefixedKey ] = $ value ; } return $ prefixedData ; }
9284	private function checkImports ( $ lessPath , $ cssPath , $ callback ) { static $ needsRecompile = false ; if ( $ needsRecompile ) return $ needsRecompile ; $ lessContent = file_get_contents ( $ lessPath ) ; preg_match_all ( '/(?<=@import)\s+"([^"]+)/im' , $ lessContent , $ imports ) ; foreach ( $ imports [ 1 ] as $ import ) { $ importPath = realpath ( dirname ( $ lessPath ) . DIRECTORY_SEPARATOR . $ import ) ; if ( file_exists ( $ importPath ) ) { if ( $ callback ( $ importPath , $ cssPath ) ) { $ needsRecompile = true ; break ; } else $ needsRecompile = $ this -> checkImports ( $ importPath , $ cssPath , $ callback ) ; } } return $ needsRecompile ; }
2940	public static function addUnit ( UnitOfMeasureInterface $ unit ) { if ( static :: unitNameOrAliasesAlreadyRegistered ( $ unit ) ) { throw new Exception \ DuplicateUnitNameOrAlias ( [ ':labels' => implode ( ', ' , array_merge ( [ $ unit -> getName ( ) ] , $ unit -> getAliases ( ) ) ) ] ) ; } static :: $ unitDefinitions [ ] = $ unit ; }
12670	public function stream_open ( $ path ) { $ scheme = parse_url ( $ path , PHP_URL_SCHEME ) ; if ( substr ( $ scheme , - 10 ) === '-emulation' ) { $ scheme = substr ( $ scheme , 0 , - 10 ) ; } $ emulator = static :: getEmulatorInstance ( $ scheme , $ path , $ this -> getContext ( ) ) ; if ( ! $ emulator ) { return false ; } $ this -> setEmulator ( $ emulator ) ; $ this -> getEmulator ( ) -> setResponseStream ( $ this -> callEmulation ( $ this -> getEmulator ( ) -> getIncomingStream ( ) ) ) ; $ this -> setResponse ( $ this -> getEmulator ( ) -> getOutgoingStream ( ) ) ; return true ; }
5960	public function clientGetByDbid ( $ dbid ) { foreach ( $ this -> clientList ( ) as $ client ) { if ( $ client [ "client_database_id" ] == $ dbid ) { return $ client ; } } throw new Ts3Exception ( "invalid clientID" , 0x200 ) ; }
835	protected function find ( $ functionNameToSearch , Tokens $ tokens , $ start = 0 , $ end = null ) { $ end = null === $ end ? $ tokens -> count ( ) : $ end ; $ candidateSequence = [ [ T_STRING , $ functionNameToSearch ] , '(' ] ; $ matches = $ tokens -> findSequence ( $ candidateSequence , $ start , $ end , false ) ; if ( null === $ matches ) { return null ; } list ( $ functionName , $ openParenthesis ) = array_keys ( $ matches ) ; $ functionsAnalyzer = new FunctionsAnalyzer ( ) ; if ( ! $ functionsAnalyzer -> isGlobalFunctionCall ( $ tokens , $ functionName ) ) { return $ this -> find ( $ functionNameToSearch , $ tokens , $ openParenthesis , $ end ) ; } return [ $ functionName , $ openParenthesis , $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ openParenthesis ) ] ; }
11324	public static function convertCase ( $ string , $ toCase ) { $ str = strtolower ( ltrim ( preg_replace ( [ '/[A-Z]/' , '/[_]/' ] , [ ' $0' , ' ' ] , $ string ) ) ) ; switch ( strtoupper ( $ toCase ) ) { case 'PASCAL' : return str_replace ( ' ' , '' , ucwords ( $ str ) ) ; case 'CAMEL' : return lcfirst ( str_replace ( ' ' , '' , ucwords ( $ str ) ) ) ; default : return str_replace ( ' ' , '_' , $ str ) ; } }
3824	protected function getFilterParameters ( $ objItemRenderer ) { $ filterUrlBuilder = System :: getContainer ( ) -> get ( 'metamodels.filter_url' ) ; $ filterUrl = $ filterUrlBuilder -> getCurrentFilterUrl ( ) ; $ result = [ ] ; foreach ( $ objItemRenderer -> getFilterSettings ( ) -> getParameters ( ) as $ name ) { if ( $ filterUrl -> hasSlug ( $ name ) ) { $ result [ $ name ] = $ filterUrl -> getSlug ( $ name ) ; } Input :: get ( $ name ) ; } return $ filterUrl -> getSlugParameters ( ) ; }
4289	public function processLogEntry ( $ method , $ args = array ( ) , $ meta = array ( ) ) { $ meta = \ array_merge ( array ( 'format' => 'raw' , 'requestId' => $ this -> requestId , ) , $ meta ) ; if ( $ meta [ 'channel' ] == $ this -> debug -> getCfg ( 'channel' ) ) { unset ( $ meta [ 'channel' ] ) ; } if ( $ meta [ 'format' ] == 'raw' ) { $ args = $ this -> crateValues ( $ args ) ; } if ( ! empty ( $ meta [ 'backtrace' ] ) ) { $ meta [ 'backtrace' ] = $ this -> crateValues ( $ meta [ 'backtrace' ] ) ; } $ this -> wamp -> publish ( $ this -> topic , array ( $ method , $ args , $ meta ) ) ; }
7841	public function removeNumber ( int $ id , string $ number ) : ? array { $ response = Request :: delete ( $ this -> baseUrl . sprintf ( 'contact/%d/phone-number/%s' , $ id , $ number ) ) ; if ( $ response -> code != 200 ) { if ( ! empty ( $ response -> body -> message ) ) { Log :: error ( $ response -> body -> message ) ; } } return [ 'code' => $ response -> code , 'message' => ( $ response -> code == 200 ) ? 'OK' : $ response -> body -> message ?? '' , 'data' => $ response -> body , ] ; }
4146	protected function getUrl ( ) { $ domain = $ this -> urls [ 'domain' ] ; $ apiVersion = $ this -> urls [ 'api' ] ; $ jsonExt = '.json' ; if ( isset ( $ this -> withMedia ) && $ this -> withMedia === true ) { $ domain = $ this -> urls [ 'upload' ] ; } if ( $ this -> call === 'oauth/request_token' || $ this -> call === 'oauth/access_token' ) { $ apiVersion = '' ; $ jsonExt = '' ; } return $ domain . $ apiVersion . $ this -> call . $ jsonExt ; }
3630	protected function validateItems ( array $ items , $ type ) { foreach ( $ items as $ item ) { $ this -> validateItem ( $ item , $ type ) ; } }
12550	public function installAssets ( ) { $ this -> doInstallAssets ( $ this -> core ) ; $ this -> doInstallAssets ( $ this -> blocks ) ; $ this -> doInstallAssets ( $ this -> themes ) ; }
4441	public function fromSubscriptions ( string $ topic ) : array { $ response = [ ] ; if ( empty ( $ topic ) ) { return $ response ; } $ subscriptions = $ this -> client -> call ( 'subscription' , 'default' , 'all' , $ topic ) ; $ subscriptions = json_decode ( $ subscriptions , true ) ? : [ ] ; foreach ( $ subscriptions as $ subscription => $ queues ) { $ topicPattern = str_replace ( [ '.' , '*' , '#' ] , [ '\.' , '[a-zA-z0-9^.]{1,}' , '.*' ] , $ subscription ) ; if ( preg_match ( "/^$topicPattern$/" , $ topic ) ) { $ response = array_merge ( $ response , $ queues ) ; } } return array_unique ( $ response ) ; }
2241	public static function getArticle ( $ varId , $ blnMultiMode = false , $ blnIsInsertTag = false , $ strColumn = 'main' ) { global $ objPage ; if ( \ is_object ( $ varId ) ) { $ objRow = $ varId ; } else { if ( ! $ varId ) { return '' ; } $ objRow = ArticleModel :: findByIdOrAliasAndPid ( $ varId , ( ! $ blnIsInsertTag ? $ objPage -> id : null ) ) ; if ( $ objRow === null ) { return false ; } } if ( ! static :: isVisibleElement ( $ objRow ) ) { return '' ; } if ( isset ( $ _GET [ 'pdf' ] ) && Input :: get ( 'pdf' ) == $ objRow -> id ) { if ( $ objRow -> printable == 1 ) { @ trigger_error ( 'Setting tl_article.printable to "1" has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; $ objArticle = new ModuleArticle ( $ objRow ) ; $ objArticle -> generatePdf ( ) ; } elseif ( $ objRow -> printable != '' ) { $ options = StringUtil :: deserialize ( $ objRow -> printable ) ; if ( \ is_array ( $ options ) && \ in_array ( 'pdf' , $ options ) ) { $ objArticle = new ModuleArticle ( $ objRow ) ; $ objArticle -> generatePdf ( ) ; } } } $ objRow -> headline = $ objRow -> title ; $ objRow -> multiMode = $ blnMultiMode ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getArticle' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getArticle' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getArticle' ] as $ callback ) { static :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ objRow ) ; } } $ objArticle = new ModuleArticle ( $ objRow , $ strColumn ) ; $ strBuffer = $ objArticle -> generate ( $ blnIsInsertTag ) ; if ( $ objArticle -> protected && ! preg_match ( '/^\s*<!-- indexer::stop/' , $ strBuffer ) ) { $ strBuffer = "\n<!-- indexer::stop . $ strBuffer . "<!-- indexer::continue ; } return $ strBuffer ; }
9954	public function mergeCellsByColumnAndRow ( $ columnIndex1 , $ row1 , $ columnIndex2 , $ row2 ) { $ cellRange = Coordinate :: stringFromColumnIndex ( $ columnIndex1 ) . $ row1 . ':' . Coordinate :: stringFromColumnIndex ( $ columnIndex2 ) . $ row2 ; return $ this -> mergeCells ( $ cellRange ) ; }
342	public static function validateMultiple ( $ models , $ attributes = null ) { $ result = [ ] ; foreach ( $ models as $ i => $ model ) { $ model -> validate ( $ attributes ) ; foreach ( $ model -> getErrors ( ) as $ attribute => $ errors ) { $ result [ Html :: getInputId ( $ model , "[$i]" . $ attribute ) ] = $ errors ; } } return $ result ; }
11478	public function addTemplateSlots ( $ templateName , $ username ) { if ( ! array_key_exists ( $ templateName , $ this -> templateBlocks ) ) { return null ; } $ blocks = $ this -> templateBlocks [ $ templateName ] ; $ this -> addSlots ( $ blocks , $ username ) ; }
9826	private function writeRelationship ( XMLWriter $ objWriter , $ pId , $ pType , $ pTarget , $ pTargetMode = '' ) { if ( $ pType != '' && $ pTarget != '' ) { $ objWriter -> startElement ( 'Relationship' ) ; $ objWriter -> writeAttribute ( 'Id' , 'rId' . $ pId ) ; $ objWriter -> writeAttribute ( 'Type' , $ pType ) ; $ objWriter -> writeAttribute ( 'Target' , $ pTarget ) ; if ( $ pTargetMode != '' ) { $ objWriter -> writeAttribute ( 'TargetMode' , $ pTargetMode ) ; } $ objWriter -> endElement ( ) ; } else { throw new WriterException ( 'Invalid parameters passed.' ) ; } }
932	public function clearChanged ( ) { @ trigger_error ( __METHOD__ . ' is deprecated and will be removed in 3.0.' , E_USER_DEPRECATED ) ; Tokens :: setLegacyMode ( true ) ; $ this -> changed = false ; }
2788	public static function getMutation ( array & $ tokens , $ index ) { $ num = ( integer ) $ tokens [ $ index ] [ 1 ] ; if ( $ num == 0 ) { $ replace = 1 ; } elseif ( $ num == 1 ) { $ replace = 0 ; } else { $ replace = $ num + 1 ; } $ tokens [ $ index ] = [ T_LNUMBER , ( string ) $ replace ] ; }
2884	public function startProfiling ( ) { $ this -> canCapture = Mage :: helper ( 'sheep_debug' ) -> canCapture ( ) ; if ( ! $ this -> canCapture ) { return ; } $ requestInfo = $ this -> getRequestInfo ( ) ; $ requestInfo -> setIsStarted ( true ) ; $ this -> registerShutdown ( ) ; $ requestInfo -> setStoreId ( $ this -> getCurrentStore ( ) -> getId ( ) ) ; $ requestInfo -> setDate ( date ( 'Y-m-d H:i:s' ) ) ; $ requestInfo -> initController ( ) ; $ requestInfo -> initLogging ( ) ; if ( Mage :: helper ( 'sheep_debug' ) -> canEnableVarienProfiler ( ) ) { Varien_Profiler :: enable ( ) ; } $ stackTraceProfiler = Mage :: getModel ( 'sheep_debug/db_profiler' ) ; $ stackTraceProfiler -> setCaptureStacktraces ( Mage :: helper ( 'sheep_debug' ) -> canEnableSqlStacktrace ( ) ) ; $ stackTraceProfiler -> replaceProfiler ( ) ; }
4872	protected function triggerListeners ( EventInterface $ event , callable $ callback = null ) { if ( ! $ event instanceof DependencyResultEvent ) { throw new \ InvalidArgumentException ( 'This event manager only accepts events of the type ' . DependencyResultEvent :: class ) ; } $ results = parent :: triggerListeners ( $ event , $ callback ) ; $ dependencies = $ event -> getDependencyResultCollection ( ) ; foreach ( $ results as $ result ) { if ( null !== $ result ) { try { $ dependencies -> add ( $ result ) ; } catch ( \ UnexpectedValueException $ e ) { } catch ( \ InvalidArgumentException $ e ) { } } } return $ results ; }
11387	private function hydrate ( ) { if ( true === $ this -> hydrated ) { return ; } $ this -> filesystem -> get ( $ this -> file ) ; $ this -> hydrated = true ; }
9354	public function subMatrix ( $ int_m , $ int_n ) { $ sm = new self ( $ this -> size -> rows - 1 , $ this -> size -> cols - 1 ) ; foreach ( $ this -> arr as $ m => $ row ) { if ( $ m != $ int_m ) { $ arr_row = array ( ) ; foreach ( $ row as $ n => $ v ) { if ( $ n != $ int_n ) { $ arr_row [ ] = $ v ; } } $ sm -> addRow ( $ arr_row ) ; } } return $ sm ; }
11755	public function markElect ( $ msgId , $ index , $ commentId ) { $ params = [ 'msg_data_id' => $ msgId , 'index' => $ index , 'user_comment_id' => $ commentId , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_MARK_ELECT , $ params ] ) ; }
1807	public function storeDateAdded ( $ dc ) { if ( ! $ dc instanceof Contao \ DataContainer ) { return ; } if ( ! $ dc -> activeRecord || $ dc -> activeRecord -> dateAdded > 0 ) { return ; } if ( $ dc -> activeRecord -> lastLogin > 0 ) { $ time = $ dc -> activeRecord -> lastLogin ; } else { $ time = time ( ) ; } $ this -> Database -> prepare ( "UPDATE tl_member SET dateAdded=? WHERE id=?" ) -> execute ( $ time , $ dc -> id ) ; }
2340	protected function getEditUrl ( ) { if ( $ this -> strEditUrl !== null ) { return sprintf ( $ this -> strEditUrl , $ this -> intPid ) ; } $ strUrl = Environment :: get ( 'request' ) ; if ( preg_match ( '/&(amp;)?state=/' , $ strUrl ) ) { $ strUrl = preg_replace ( array ( '/&(amp;)?id=[^&]+/' , '/(&(amp;)?)t(id=[^&]+)/' , '/(&(amp;)?)state=[^&]*/' ) , array ( '' , '$1$3' , '$1act=edit' ) , $ strUrl ) ; } if ( preg_match ( '/do=login(&|$)/' , $ strUrl ) ) { $ strUrl = preg_replace ( '/do=login(&|$)/' , 'do=user$1' , $ strUrl ) ; $ strUrl .= '&amp;act=edit&amp;id=' . $ this -> User -> id . '&amp;rt=' . REQUEST_TOKEN ; } $ strUrl = preg_replace ( '/act=(edit|override)All/' , 'act=edit&id=' . $ this -> intPid , $ strUrl ) ; return $ strUrl ; }
2643	private function _purge ( $ uri , $ type , $ method = \ Zend_Http_Client :: POST , $ payload = null ) { if ( $ method == 'PURGE' ) { $ expiration = time ( ) + self :: PURGE_TOKEN_LIFETIME ; $ zendUri = \ Zend_Uri :: factory ( $ uri ) ; $ path = $ zendUri -> getPath ( ) ; $ stringToSign = $ path . $ expiration ; $ signature = hash_hmac ( 'sha1' , $ stringToSign , $ this -> config -> getServiceId ( ) ) ; $ token = $ expiration . '_' . urlencode ( $ signature ) ; $ headers = [ self :: FASTLY_HEADER_TOKEN . ': ' . $ token ] ; } else { $ headers = [ self :: FASTLY_HEADER_AUTH . ': ' . $ this -> config -> getApiKey ( ) ] ; } if ( $ this -> config -> canUseSoftPurge ( ) ) { array_push ( $ headers , self :: FASTLY_HEADER_SOFT_PURGE . ': 1' ) ; } $ result [ 'status' ] = true ; try { $ client = $ this -> curlFactory -> create ( ) ; $ client -> setConfig ( [ 'timeout' => self :: PURGE_TIMEOUT ] ) ; if ( $ method == 'PURGE' ) { $ client -> addOption ( CURLOPT_CUSTOMREQUEST , 'PURGE' ) ; } $ client -> write ( $ method , $ uri , '1.1' , $ headers , $ payload ) ; $ responseBody = $ client -> read ( ) ; $ responseCode = \ Zend_Http_Response :: extractCode ( $ responseBody ) ; $ responseMessage = \ Zend_Http_Response :: extractMessage ( $ responseBody ) ; $ client -> close ( ) ; if ( $ responseCode == '429' ) { throw new LocalizedException ( __ ( $ responseMessage ) ) ; } elseif ( $ responseCode != '200' ) { throw new LocalizedException ( __ ( $ responseCode . ': ' . $ responseMessage ) ) ; } } catch ( \ Exception $ e ) { $ this -> logger -> critical ( $ e -> getMessage ( ) , $ uri ) ; $ result [ 'status' ] = false ; $ result [ 'msg' ] = $ e -> getMessage ( ) ; } if ( empty ( $ type ) ) { return $ result ; } if ( $ this -> config -> areWebHooksEnabled ( ) && $ this -> config -> canPublishPurgeChanges ( ) ) { $ this -> sendWebHook ( '*initiated ' . $ type . '*' ) ; if ( $ this -> config -> canPublishPurgeDebugBacktrace ( ) == false ) { return $ result ; } $ this -> stackTrace ( $ type ) ; } return $ result ; }
10909	public function inject ( string ... $ methods ) : Binding { if ( $ this -> definition -> injects === null ) { $ this -> definition -> injects = \ array_fill_keys ( $ methods , true ) ; } else { foreach ( $ methods as $ f ) { $ this -> definition -> injects [ $ f ] = true ; } } return $ this ; }
10907	public static function get ( array $ server ) : array { $ params = [ ] ; if ( isset ( $ server [ 'QUERY_STRING' ] ) ) { $ query = ltrim ( $ server [ 'QUERY_STRING' ] , '?' ) ; foreach ( explode ( '&' , $ query ) as $ pair ) { if ( $ pair ) { list ( $ name , $ value ) = self :: normalize ( array_map ( 'urldecode' , explode ( '=' , $ pair , 2 ) ) ) ; $ params [ $ name ] [ ] = $ value ; } } } return $ params ? array_map ( function ( $ v ) { return count ( $ v ) === 1 ? $ v [ 0 ] : $ v ; } , $ params ) : $ params ; }
5301	public function getCss ( ) { $ css = '' ; foreach ( $ this -> getGlyphNames ( ) as $ unicode => $ name ) { $ css .= ".icon-" . $ name . ":before {" . "\n" ; $ css .= "\tcontent: \"\\" . $ unicode . "\";\n" ; $ css .= "}\n" ; } return $ css ; }
9660	public static function identify ( $ pFilename ) { $ reader = self :: createReaderForFile ( $ pFilename ) ; $ className = get_class ( $ reader ) ; $ classType = explode ( '\\' , $ className ) ; unset ( $ reader ) ; return array_pop ( $ classType ) ; }
9014	public function longtext ( string $ charset = null ) : self { $ this -> type = 'longtext' . $ this -> stringOptions ( $ charset ) ; return $ this ; }
5549	public function getBaseUrl ( ) { if ( is_integer ( $ this -> focus ) ) { $ url = $ this -> frames [ $ this -> focus ] -> getBaseUrl ( ) ; } else { $ url = $ this -> frameset -> getBaseUrl ( ) ; } return $ url ; }
12782	public function getAll ( ) { if ( is_null ( $ this -> intersections ) ) { $ this -> intersections = [ ] ; if ( $ this -> arraysSize >= 2 ) { $ this -> createIntersections ( ) ; } } return $ this -> intersections ; }
1992	public static function getMetaData ( $ strData , $ strLanguage ) { if ( empty ( $ strLanguage ) ) { return array ( ) ; } $ arrData = StringUtil :: deserialize ( $ strData ) ; $ strLanguage = str_replace ( '-' , '_' , $ strLanguage ) ; if ( ! \ is_array ( $ arrData ) || ! isset ( $ arrData [ $ strLanguage ] ) ) { return array ( ) ; } return $ arrData [ $ strLanguage ] ; }
11643	public function getFormatter ( ) { if ( $ this -> _formatter === null ) { $ this -> _formatter = Yii :: $ app -> format ; } return $ this -> _formatter ; }
7722	function meth_Misc_Alert ( $ Src , $ Msg , $ NoErrMsg = false , $ SrcType = false ) { $ this -> ErrCount ++ ; if ( $ this -> NoErr || ( php_sapi_name === 'cli' ) ) { $ t = array ( '' , '' , '' , '' , '' ) ; } else { $ t = array ( '<br /><b>' , '</b>' , '<em>' , '</em>' , '<br />' ) ; $ Msg = htmlentities ( $ Msg ) ; } if ( ! is_string ( $ Src ) ) { if ( $ SrcType === false ) $ SrcType = 'in field' ; if ( isset ( $ Src -> PrmLst [ 'tbstype' ] ) ) { $ Msg = 'Column \'' . $ Src -> SubName . '\' is expected but missing in the current record.' ; $ Src = 'Parameter \'' . $ Src -> PrmLst [ 'tbstype' ] . '=' . $ Src -> SubName . '\'' ; $ NoErrMsg = false ; } else { $ Src = $ SrcType . ' ' . $ this -> _ChrOpen . $ Src -> FullName . '...' . $ this -> _ChrClose ; } } $ x = $ t [ 0 ] . 'TinyButStrong Error' . $ t [ 1 ] . ' ' . $ Src . ': ' . $ Msg ; if ( $ NoErrMsg ) $ x = $ x . ' ' . $ t [ 2 ] . 'This message can be cancelled using parameter \'noerr\'.' . $ t [ 3 ] ; $ x = $ x . $ t [ 4 ] . "\n" ; if ( $ this -> NoErr ) { $ this -> ErrMsg .= $ x ; } else { if ( php_sapi_name !== 'cli' ) { $ x = str_replace ( $ this -> _ChrOpen , $ this -> _ChrProtect , $ x ) ; } echo $ x ; } return false ; }
6704	public function baseURL ( $ httpverb , $ url , $ params ) { uksort ( $ params , 'strcmp' ) ; return strtoupper ( $ httpverb ) . '&' . rawurlencode ( $ url ) . '&' . rawurlencode ( http_build_query ( $ params ) ) ; }
6797	private function convertRows ( Statement $ dbResult , $ idColumn , $ valueColumn ) { $ result = [ ] ; while ( $ row = $ dbResult -> fetch ( \ PDO :: FETCH_ASSOC ) ) { if ( ! isset ( $ result [ $ row [ $ idColumn ] ] ) ) { $ result [ $ row [ $ idColumn ] ] = [ ] ; } $ data = $ row ; unset ( $ data [ $ idColumn ] ) ; $ result [ $ row [ $ idColumn ] ] [ $ row [ $ valueColumn ] ] = $ data ; } return $ result ; }
11828	public function setUri ( $ uri ) { if ( ! empty ( $ uri ) && ! is_file ( $ uri ) ) { throw new \ Exception ( sprintf ( 'File %s not found.' , $ uri ) ) ; } $ this -> uri = $ uri ; return $ this ; }
7538	function getRoot ( ) { $ r = $ this -> parent ; $ n = ( $ r === null ) ? null : $ r -> parent ; while ( $ n !== null ) { $ r = $ n ; $ n = $ r -> parent ; } return $ r ; }
8287	protected function createContainer ( ) { $ configDir = $ this -> pico -> getConfigDir ( ) ; $ userContainer = $ configDir . "PicoAuth/container.php" ; if ( is_file ( $ userContainer ) && is_readable ( $ userContainer ) ) { $ this -> container = include $ userContainer ; if ( $ this -> container === false || ! ( $ this -> container instanceof \ League \ Container \ Container ) ) { throw new \ RuntimeException ( "The container.php does not return container instance." ) ; } } else { $ this -> container = include $ this -> pluginDir . '/src/container.php' ; } $ this -> container -> share ( 'configDir' , new \ League \ Container \ Argument \ RawArgument ( $ configDir ) ) ; $ this -> container -> share ( 'PicoAuth' , $ this ) ; if ( ! $ this -> config [ "rateLimit" ] ) { $ this -> container -> share ( 'RateLimit' , \ PicoAuth \ Security \ RateLimiting \ NullRateLimit :: class ) ; } }
617	private function parseArray ( $ value , & $ i = 0 ) { $ result = [ ] ; $ len = strlen ( $ value ) ; for ( ++ $ i ; $ i < $ len ; ++ $ i ) { switch ( $ value [ $ i ] ) { case '{' : $ result [ ] = $ this -> parseArray ( $ value , $ i ) ; break ; case '}' : break 2 ; case $ this -> delimiter : if ( empty ( $ result ) ) { $ result [ ] = null ; } if ( in_array ( $ value [ $ i + 1 ] , [ $ this -> delimiter , '}' ] , true ) ) { $ result [ ] = null ; } break ; default : $ result [ ] = $ this -> parseString ( $ value , $ i ) ; } } return $ result ; }
5293	protected function execute ( InputInterface $ input , OutputInterface $ output ) { $ directory = $ input -> getArgument ( 'directory' ) ; $ outputFile = $ input -> getArgument ( 'output-file' ) ; $ generator = new IconFontGenerator ; $ output -> writeln ( 'reading files from "' . $ directory . '" ...' ) ; $ generator -> generateFromDir ( $ directory , array ( 'id' => $ input -> getOption ( 'name' ) ? : 'SVGFont' , ) , $ input -> getOption ( 'rename-files' ) ) ; $ output -> writeln ( 'writing font to "' . $ outputFile . '" ...' ) ; file_put_contents ( $ outputFile , $ generator -> getFont ( ) -> getXML ( ) ) ; $ output -> getFormatter ( ) -> setStyle ( 'success' , new OutputFormatterStyle ( null , null , array ( 'bold' , 'reverse' ) ) ) ; $ output -> writeln ( '<success>created ' . $ outputFile . ' successfully</success>' ) ; }
10140	private function readRecordData ( $ data , $ pos , $ len ) { $ data = substr ( $ data , $ pos , $ len ) ; if ( $ this -> encryption == self :: MS_BIFF_CRYPTO_NONE || $ pos < $ this -> encryptionStartPos ) { return $ data ; } $ recordData = '' ; if ( $ this -> encryption == self :: MS_BIFF_CRYPTO_RC4 ) { $ oldBlock = floor ( $ this -> rc4Pos / self :: REKEY_BLOCK ) ; $ block = floor ( $ pos / self :: REKEY_BLOCK ) ; $ endBlock = floor ( ( $ pos + $ len ) / self :: REKEY_BLOCK ) ; if ( $ block != $ oldBlock || $ pos < $ this -> rc4Pos || ! $ this -> rc4Key ) { $ this -> rc4Key = $ this -> makeKey ( $ block , $ this -> md5Ctxt ) ; $ step = $ pos % self :: REKEY_BLOCK ; } else { $ step = $ pos - $ this -> rc4Pos ; } $ this -> rc4Key -> RC4 ( str_repeat ( "\0" , $ step ) ) ; while ( $ block != $ endBlock ) { $ step = self :: REKEY_BLOCK - ( $ pos % self :: REKEY_BLOCK ) ; $ recordData .= $ this -> rc4Key -> RC4 ( substr ( $ data , 0 , $ step ) ) ; $ data = substr ( $ data , $ step ) ; $ pos += $ step ; $ len -= $ step ; ++ $ block ; $ this -> rc4Key = $ this -> makeKey ( $ block , $ this -> md5Ctxt ) ; } $ recordData .= $ this -> rc4Key -> RC4 ( substr ( $ data , 0 , $ len ) ) ; $ this -> rc4Pos = $ pos + $ len ; } elseif ( $ this -> encryption == self :: MS_BIFF_CRYPTO_XOR ) { throw new Exception ( 'XOr encryption not supported' ) ; } return $ recordData ; }
9512	private function getLogViewerPermissions ( ) { return [ [ 'name' => 'LogViewer - View dashboard' , 'description' => 'Allow to view the LogViewer dashboard.' , 'slug' => LogViewerPolicy :: PERMISSION_DASHBOARD , ] , [ 'name' => 'LogViewer - List all logs' , 'description' => 'Allow to list all the logs.' , 'slug' => LogViewerPolicy :: PERMISSION_LIST , ] , [ 'name' => 'LogViewer - View a log' , 'description' => 'Allow to display a log.' , 'slug' => LogViewerPolicy :: PERMISSION_SHOW , ] , [ 'name' => 'LogViewer - Download a log' , 'description' => 'Allow to download a log.' , 'slug' => LogViewerPolicy :: PERMISSION_DOWNLOAD , ] , [ 'name' => 'LogViewer - Delete a log' , 'description' => 'Allow to delete a log.' , 'slug' => LogViewerPolicy :: PERMISSION_DELETE , ] , ] ; }
8271	protected function getKeyEncoder ( $ lockData ) { if ( isset ( $ lockData [ 'encoder' ] ) && is_string ( $ lockData [ 'encoder' ] ) ) { $ name = $ lockData [ 'encoder' ] ; } else { $ name = $ this -> config [ "encoder" ] ; } try { $ instance = $ this -> picoAuth -> getContainer ( ) -> get ( $ name ) ; } catch ( \ Exception $ e ) { throw new \ RuntimeException ( "Specified PageLock encoder not resolvable." ) ; } return $ instance ; }
11359	public function update ( $ previousPermalink , $ newPermalink ) { $ blocks = $ this -> permalinks [ $ previousPermalink ] ; $ this -> remove ( $ previousPermalink ) ; $ this -> permalinks [ $ newPermalink ] = $ blocks ; return $ this ; }
8491	public static function getCpuCores ( ) { $ wmi = Windows :: getInstance ( ) ; $ object = $ wmi -> ExecQuery ( "SELECT NumberOfLogicalProcessors FROM Win32_Processor" ) ; $ cores = 0 ; foreach ( $ object as $ obj ) { $ cores = $ obj -> NumberOfLogicalProcessors ; } return $ cores ; }
10170	public function setDiagonalDirection ( $ pValue ) { if ( $ pValue == '' ) { $ pValue = self :: DIAGONAL_NONE ; } if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'diagonalDirection' => $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> diagonalDirection = $ pValue ; } return $ this ; }
8012	public static function forChallengeMessage ( $ challenge_message , $ code = 0 , Exception $ previous = null ) { $ message = self :: DEFAULT_MESSAGE ; $ reason_messages = [ ] ; if ( ( self :: CODE_FOR_INVALID_SIGNATURE & $ code ) === self :: CODE_FOR_INVALID_SIGNATURE ) { $ reason_messages [ ] = self :: MESSAGE_FOR_INVALID_SIGNATURE ; } if ( ( self :: CODE_FOR_INVALID_MESSAGE_TYPE & $ code ) === self :: CODE_FOR_INVALID_MESSAGE_TYPE ) { $ reason_messages [ ] = self :: MESSAGE_FOR_INVALID_MESSAGE_TYPE ; } $ message .= sprintf ( self :: MESSAGE_EXTENSION_FOR_REASONS_FORMAT , implode ( self :: MESSAGE_REASON_GLUE , $ reason_messages ) ) ; $ instance = new static ( $ message , $ code , $ previous ) ; $ instance -> challenge_message = $ challenge_message ; return $ instance ; }
2042	public static function validateSymlink ( string $ target , string $ link , string $ rootDir ) : void { if ( '' === $ target ) { throw new \ InvalidArgumentException ( 'The symlink target must not be empty.' ) ; } if ( '' === $ link ) { throw new \ InvalidArgumentException ( 'The symlink path must not be empty.' ) ; } if ( false !== strpos ( $ link , '../' ) ) { throw new \ InvalidArgumentException ( 'The symlink path must not be relative.' ) ; } $ fs = new Filesystem ( ) ; if ( $ fs -> exists ( $ rootDir . '/' . $ link ) && ! is_link ( $ rootDir . '/' . $ link ) ) { throw new \ LogicException ( sprintf ( 'The path "%s" exists and is not a symlink.' , $ link ) ) ; } }
408	public function get ( $ name = null , $ defaultValue = null ) { if ( $ name === null ) { return $ this -> getQueryParams ( ) ; } return $ this -> getQueryParam ( $ name , $ defaultValue ) ; }
8909	public function serialize_row ( $ row ) { foreach ( $ this -> callback_parameters as $ column ) { $ row [ $ column ] = serialize ( $ row [ $ column ] ) ; } return $ row ; }
7074	private function addSaleDetails ( array & $ details , Model \ SaleInterface $ sale ) { if ( $ sale -> getCurrency ( ) -> getCode ( ) !== $ this -> currency ) { return ; } if ( 0 !== Money :: compare ( $ sale -> getGrandTotal ( ) , $ details [ 'PAYMENTREQUEST_0_AMT' ] , $ this -> currency ) ) { return ; } $ this -> calculator -> calculateSale ( $ sale ) ; $ this -> line = 0 ; $ lineTotals = 0 ; foreach ( $ sale -> getItems ( ) as $ item ) { $ lineTotals += $ this -> addItemDetails ( $ details , $ item ) ; } foreach ( $ sale -> getAdjustments ( Model \ AdjustmentTypes :: TYPE_DISCOUNT ) as $ discount ) { $ lineTotals += $ this -> addDiscountDetails ( $ details , $ discount ) ; } $ details [ 'PAYMENTREQUEST_0_ITEMAMT' ] = $ this -> format ( $ lineTotals ) ; $ details [ 'PAYMENTREQUEST_0_SHIPPINGAMT' ] = $ this -> format ( $ sale -> getShipmentResult ( ) -> getTotal ( ) ) ; }
5213	private function getBinding ( $ type , $ name = null ) { $ binding = $ this -> findBinding ( $ type , $ name ) ; if ( null === $ binding ) { throw new BindingException ( 'No binding for ' . $ type . ' defined' ) ; } return $ binding ; }
7067	protected function getAccountingFromEvent ( ResourceEventInterface $ event ) { $ resource = $ event -> getResource ( ) ; if ( ! $ resource instanceof AccountingInterface ) { throw new InvalidArgumentException ( 'Expected instance of ' . AccountingInterface :: class ) ; } return $ resource ; }
4004	public function getMetaModelNameFromId ( GetMetaModelNameFromIdEvent $ event ) { $ metaModelId = $ event -> getMetaModelId ( ) ; if ( array_key_exists ( $ metaModelId , $ this -> instancesById ) ) { $ event -> setMetaModelName ( $ this -> instancesById [ $ metaModelId ] -> getTableName ( ) ) ; return ; } if ( isset ( $ this -> tableNames [ $ metaModelId ] ) ) { $ event -> setMetaModelName ( $ this -> tableNames [ $ metaModelId ] ) ; return ; } if ( ! $ this -> tableNamesCollected ) { $ table = $ this -> database -> createQueryBuilder ( ) -> select ( '*' ) -> from ( 'tl_metamodel' ) -> where ( 'id=:id' ) -> setParameter ( 'id' , $ metaModelId ) -> setMaxResults ( 1 ) -> execute ( ) -> fetch ( \ PDO :: FETCH_ASSOC ) ; if ( $ table ) { $ this -> tableNames [ $ metaModelId ] = $ table [ 'tableName' ] ; $ event -> setMetaModelName ( $ this -> tableNames [ $ metaModelId ] ) ; } } }
4260	public function hasSubscribers ( $ eventName = null ) { if ( $ eventName !== null ) { return ! empty ( $ this -> subscribers [ $ eventName ] ) ; } foreach ( $ this -> subscribers as $ subscribers ) { if ( $ subscribers ) { return true ; } } return false ; }
484	public function dropIndex ( $ name , $ table ) { $ time = $ this -> beginCommand ( "drop index $name on $table" ) ; $ this -> db -> createCommand ( ) -> dropIndex ( $ name , $ table ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
8236	protected function checkServerConfiguration ( ) { $ pico = $ this -> picoAuth -> getPico ( ) ; $ configDir = $ pico -> getBaseUrl ( ) . basename ( $ pico -> getConfigDir ( ) ) ; $ configFile = $ configDir . "/config.yml" ; $ contentDir = $ pico -> getBaseUrl ( ) . basename ( $ pico -> getConfig ( 'content_dir' ) ) ; $ indexFile = $ contentDir . "/index" . $ pico -> getConfig ( 'content_ext' ) ; $ urls = array ( 'dir_listing' => $ configDir , 'config_file' => $ configFile , 'content_file' => $ indexFile ) ; $ this -> httpsTest ( ) ; $ this -> webRootDirsTest ( ) ; $ this -> picoAuth -> addOutput ( "installer_urltest" , $ urls ) ; }
7545	function getNamespace ( ) { if ( $ this -> tag_ns === null ) { $ a = explode ( ':' , $ this -> tag , 2 ) ; if ( empty ( $ a [ 1 ] ) ) { $ this -> tag_ns = array ( '' , $ a [ 0 ] ) ; } else { $ this -> tag_ns = array ( $ a [ 0 ] , $ a [ 1 ] ) ; } } return $ this -> tag_ns [ 0 ] ; }
8227	protected function logSuccessfulRegistration ( array $ reg ) { $ this -> getLogger ( ) -> info ( "New registration: {name} ({email}) from {addr}" , array ( "name" => $ reg [ "username" ] , "email" => $ reg [ "email" ] , "addr" => $ _SERVER [ 'REMOTE_ADDR' ] ) ) ; $ max = $ this -> config [ "maxUsers" ] ; $ count = $ this -> storage -> getUsersCount ( ) + 1 ; if ( $ count % ceil ( $ max / 10 ) === 0 ) { $ percent = intval ( $ count / ceil ( $ max / 100 ) ) ; $ this -> getLogger ( ) -> warning ( "The amount of users has reached {percent} of the maximum capacity {max}." , array ( "percent" => $ percent , "max" => $ max ) ) ; } }
4977	public function send ( \ Zend \ Mail \ Message $ message ) { $ options = $ this -> options ; $ filename = call_user_func ( $ options -> getCallback ( ) , $ this ) ; $ file = $ options -> getPath ( ) . DIRECTORY_SEPARATOR . $ filename ; $ contents = $ message -> toString ( ) ; $ umask = umask ( ) ; umask ( 022 ) ; if ( false === file_put_contents ( $ file , $ contents , LOCK_EX ) ) { throw new RuntimeException ( sprintf ( 'Unable to write mail to file (directory "%s")' , $ options -> getPath ( ) ) ) ; } umask ( $ umask ) ; $ this -> lastFile = $ file ; }
12812	private static function isForeignKey ( string $ table , string $ column ) : bool { return array_key_exists ( $ column , self :: getForeignKeys ( $ table ) ) ; }
10585	public static function createFile ( string $ name , int $ maxAttempts = 10 ) : entity \ FileEntity { $ tmpdir = static :: getDir ( ) ; $ name = \ sndsgd \ Fs :: sanitizeName ( $ name ) ; $ pos = strrpos ( $ name , "." ) ; if ( $ pos === false ) { $ extension = "" ; } else { $ extension = substr ( $ name , $ pos ) ; $ name = substr ( $ name , 0 , $ pos ) ; } $ attempts = 1 ; do { if ( $ attempts > $ maxAttempts ) { throw new \ RuntimeException ( "failed to create temp file; " . "reached max number ($maxAttempts) of attempts" ) ; } $ rand = \ sndsgd \ Str :: random ( 10 ) ; $ path = "$tmpdir/$name-$rand$extension" ; $ attempts ++ ; } while ( file_exists ( $ path ) ) ; touch ( $ path ) ; $ file = new entity \ FileEntity ( $ path ) ; static :: registerEntity ( $ file ) ; return $ file ; }
7712	function FindName ( ) { if ( $ this -> Name === '' ) { $ p = $ this -> PosBeg ; do { $ p ++ ; $ z = $ this -> Txt [ $ p ] ; } while ( ( $ z !== ' ' ) && ( $ z !== "\r" ) && ( $ z !== "\n" ) && ( $ z !== '>' ) && ( $ z !== '/' ) ) ; $ this -> Name = substr ( $ this -> Txt , $ this -> PosBeg + 1 , $ p - $ this -> PosBeg - 1 ) ; } return $ this -> Name ; }
9759	function contain ( $ value = null ) : self { if ( $ this -> hasFlag ( 'file' ) ) return $ this -> expect ( @ file_get_contents ( $ this -> target ) , stringContains ( $ value ) ) ; return $ this -> expect ( $ this -> target , is_string ( $ this -> target ) ? stringContains ( $ value ) : contains ( $ value ) ) ; }
7322	public function sidereal ( $ mode = 'a' , Angle $ lon = null ) { $ ut = $ this -> copy ( ) -> toUT1 ( ) ; $ uta = $ ut -> jd ; $ utb = $ ut -> dayFrac ; $ ut = null ; $ tt = $ this -> copy ( ) -> toTT ( ) ; $ tta = $ tt -> jd ; $ ttb = $ tt -> dayFrac ; $ tt = null ; $ st ; if ( $ mode == 'a' ) { $ strad = IAU :: Gst06a ( $ uta , $ utb , $ tta , $ ttb ) ; } else { $ strad = IAU :: Gmst06 ( $ uta , $ utb , $ tta , $ ttb ) ; } if ( $ lon ) { $ st = Angle :: rad ( $ strad ) -> add ( $ lon ) -> norm ( ) -> toTime ( ) ; } else { $ st = Angle :: rad ( $ strad ) -> toTime ( ) ; } return $ st ; }
12012	private function addDoctrineSection ( ArrayNodeDefinition $ rootNode ) { $ rootNode -> children ( ) -> arrayNode ( 'doctrine' ) -> info ( 'doctrine configuration' ) -> canBeEnabled ( ) -> children ( ) -> booleanNode ( 'enabled' ) -> defaultTrue ( ) -> end ( ) -> end ( ) -> end ( ) -> end ( ) ; }
4688	public function andWhere ( string $ expression , ... $ args ) : self { $ this -> dirty ( ) ; $ this -> where = $ this -> where ? '(' . $ this -> where . ') AND (' . $ expression . ')' : $ expression ; $ this -> pushArgs ( 'where' , $ args ) ; return $ this ; }
1531	public static function create ( ValidatorInterface $ validator ) : self { $ ex = new self ( $ validator -> getErrors ( ) ) ; $ ex -> validator = $ validator ; return $ ex ; }
9655	public function override ( $ name , array $ routeData ) { if ( ! isset ( $ this -> routes [ $ name ] ) ) { throw new \ InvalidArgumentException ( "No route for name $name defined" ) ; } $ this -> routes [ $ name ] = $ routeData + $ this -> routes [ $ name ] ; }
6590	public function put ( $ url , $ data = null , $ len = null , $ method = "PUT" ) { return $ this -> request ( [ CURLOPT_PUT => true , CURLOPT_CUSTOMREQUEST => $ method ? : "PUT" , CURLOPT_URL => "$url" , CURLOPT_INFILE => $ data , CURLOPT_INFILESIZE => $ len , ] ) ; }
11400	public function fromData ( $ data ) { $ this -> fromdata = $ data ; $ resource = fopen ( 'php://memory' , 'r+' ) ; fwrite ( $ resource , $ data ) ; rewind ( $ resource ) ; $ this -> setResource ( $ resource ) ; return $ this ; }
10573	protected function registerSessionHandler ( ) { if ( $ this -> handler !== null ) { if ( ! is_object ( $ this -> handler ) ) { $ this -> handler = Yii :: createObject ( $ this -> handler ) ; } if ( ! $ this -> handler instanceof \ SessionHandlerInterface ) { throw new InvalidConfigException ( '"' . get_class ( $ this ) . '::handler" must implement the SessionHandlerInterface.' ) ; } @ session_set_save_handler ( $ this -> handler , false ) ; } elseif ( $ this -> getUseCustomStorage ( ) ) { @ session_set_save_handler ( [ $ this , 'openSession' ] , [ $ this , 'closeSession' ] , [ $ this , 'readSession' ] , [ $ this , 'writeSession' ] , [ $ this , 'destroySession' ] , [ $ this , 'gcSession' ] ) ; } }
9260	private function isCacheable ( $ data ) { $ cacheable = true ; array_walk_recursive ( $ data , function ( $ value ) use ( & $ cacheable ) { if ( $ value instanceof \ Closure ) { $ cacheable = false ; } } ) ; return $ cacheable ; }
12547	public function getBlockPlugin ( $ name ) { if ( ! array_key_exists ( $ name , $ this -> blocks ) ) { return null ; } return $ this -> blocks [ $ name ] ; }
576	public function run ( $ id = null ) { if ( Yii :: $ app -> getRequest ( ) -> getMethod ( ) !== 'OPTIONS' ) { Yii :: $ app -> getResponse ( ) -> setStatusCode ( 405 ) ; } $ options = $ id === null ? $ this -> collectionOptions : $ this -> resourceOptions ; $ headers = Yii :: $ app -> getResponse ( ) -> getHeaders ( ) ; $ headers -> set ( 'Allow' , implode ( ', ' , $ options ) ) ; $ headers -> set ( 'Access-Control-Allow-Methods' , implode ( ', ' , $ options ) ) ; }
11445	public function getTransporter ( ) { if ( empty ( $ this -> transporter ) ) { $ transport_class = $ this -> getDefault ( 'transporter' ) ; if ( class_exists ( $ transport_class ) ) { $ this -> setTransporter ( new $ transport_class ) ; } else { throw new \ Exception ( sprintf ( 'Default transport class "%s" not found!' , $ transport_class ) ) ; } } return $ this -> transporter ; }
4328	public static function parseAttribString ( $ str , $ dataDecode = true ) { $ attribs = array ( ) ; $ regexAttribs = '/\b([\w\-]+)\b(?: \s*=\s*(["\'])(.*?)\\2 | \s*=\s*(\S+) )?/xs' ; \ preg_match_all ( $ regexAttribs , $ str , $ matches ) ; $ keys = \ array_map ( 'strtolower' , $ matches [ 1 ] ) ; $ values = \ array_replace ( $ matches [ 3 ] , \ array_filter ( $ matches [ 4 ] , 'strlen' ) ) ; foreach ( $ keys as $ i => $ k ) { $ attribs [ $ k ] = $ values [ $ i ] ; if ( \ in_array ( $ k , self :: $ htmlBoolAttr ) ) { $ attribs [ $ k ] = true ; } } \ ksort ( $ attribs ) ; foreach ( $ attribs as $ k => $ v ) { if ( \ is_string ( $ v ) ) { $ attribs [ $ k ] = \ htmlspecialchars_decode ( $ v ) ; } $ isDataAttrib = \ strpos ( $ k , 'data-' ) === 0 ; if ( $ isDataAttrib && $ dataDecode ) { $ val = $ attribs [ $ k ] ; $ attribs [ $ k ] = \ json_decode ( $ attribs [ $ k ] , true ) ; if ( $ attribs [ $ k ] === null && $ val !== 'null' ) { $ attribs [ $ k ] = \ json_decode ( '"' . $ val . '"' , true ) ; } } } return $ attribs ; }
2178	private function addDefaultsToContext ( array $ context ) : array { $ context = array_merge ( $ this -> context , $ context ) ; if ( ! isset ( $ context [ 'request_token' ] ) ) { $ context [ 'request_token' ] = $ this -> getRequestToken ( ) ; } if ( ! isset ( $ context [ 'language' ] ) ) { $ context [ 'language' ] = $ this -> container -> get ( 'translator' ) -> getLocale ( ) ; } if ( ! isset ( $ context [ 'ua' ] ) ) { $ context [ 'ua' ] = $ this -> getUserAgentString ( ) ; } if ( ! isset ( $ context [ 'path' ] ) ) { $ request = $ this -> container -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; if ( null === $ request ) { throw new \ RuntimeException ( 'The request stack did not contain a request' ) ; } $ context [ 'host' ] = $ request -> getHost ( ) ; $ context [ 'path' ] = $ request -> getBasePath ( ) ; } return $ context ; }
9287	public function drop ( ) { $ adapter = $ this -> dbAdapter ; $ ddl = new Ddl \ DropTable ( self :: TABLE_NAME ) ; $ sql = ( new Sql ( $ adapter ) ) -> getSqlStringForSqlObject ( $ ddl ) ; $ adapter -> query ( $ sql , $ adapter :: QUERY_MODE_EXECUTE ) ; }
7149	private function calculateAdjustment ( AdjustmentDataInterface $ adjustment , $ base ) { if ( $ adjustment -> getMode ( ) === AdjustmentModes :: MODE_PERCENT ) { return Money :: round ( $ base * $ adjustment -> getAmount ( ) / 100 , $ this -> currency ) ; } if ( $ adjustment -> getMode ( ) === AdjustmentModes :: MODE_FLAT ) { return $ adjustment -> getAmount ( ) ; } throw new InvalidArgumentException ( "Unexpected adjustment mode." ) ; }
12031	function addCreateAndExecuteMethod ( ) { $ methodGenerator = new MethodGenerator ( 'createAndExecute' ) ; $ body = '' ; $ body .= $ this -> generateCreateFragment ( ) ; $ body .= $ this -> generateExecuteFragment ( ) ; $ body .= PHP_EOL ; $ body .= 'return $response;' . PHP_EOL ; ; $ docBlock = new DocBlockGenerator ( 'Create and execute the operation, returning the raw response from the server.' , null ) ; $ tags [ ] = new GenericTag ( 'return' , '\Amp\Artax\Response' ) ; $ docBlock -> setTags ( $ tags ) ; $ methodGenerator -> setBody ( $ body ) ; $ methodGenerator -> setDocBlock ( $ docBlock ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; }
8564	public function getEligibleShippingServices ( $ request ) { if ( ! ( $ request instanceof MWSMerchantFulfillmentService_Model_GetEligibleShippingServicesRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/GetEligibleShippingServicesRequest.php' ) ; $ request = new MWSMerchantFulfillmentService_Model_GetEligibleShippingServicesRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetEligibleShippingServices' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/GetEligibleShippingServicesResponse.php' ) ; $ response = MWSMerchantFulfillmentService_Model_GetEligibleShippingServicesResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
11670	public function getClientBy ( $ selector , $ value , $ callable = null ) { $ selector = strtolower ( $ selector ) ; if ( ! in_array ( $ selector , array ( 'id' , 'key' , 'slot' , 'role' , 'alias' , 'command' ) ) ) { throw new \ InvalidArgumentException ( "Invalid selector type: `$selector`" ) ; } if ( ! method_exists ( $ this -> connection , $ method = "getConnectionBy$selector" ) ) { $ class = get_class ( $ this -> connection ) ; throw new \ InvalidArgumentException ( "Selecting connection by $selector is not supported by $class" ) ; } if ( ! $ connection = $ this -> connection -> $ method ( $ value ) ) { throw new \ InvalidArgumentException ( "Cannot find a connection by $selector matching `$value`" ) ; } $ client = new static ( $ connection , $ this -> getOptions ( ) ) ; if ( $ callable ) { return call_user_func ( $ callable , $ client ) ; } else { return $ client ; } }
520	protected function migrateUp ( $ class ) { if ( $ class === self :: BASE_MIGRATION ) { return true ; } $ this -> stdout ( "*** applying $class\n" , Console :: FG_YELLOW ) ; $ start = microtime ( true ) ; $ migration = $ this -> createMigration ( $ class ) ; if ( $ migration -> up ( ) !== false ) { $ this -> addMigrationHistory ( $ class ) ; $ time = microtime ( true ) - $ start ; $ this -> stdout ( "*** applied $class (time: " . sprintf ( '%.3f' , $ time ) . "s)\n\n" , Console :: FG_GREEN ) ; return true ; } $ time = microtime ( true ) - $ start ; $ this -> stdout ( "*** failed to apply $class (time: " . sprintf ( '%.3f' , $ time ) . "s)\n\n" , Console :: FG_RED ) ; return false ; }
4308	public function trace ( ) { if ( ! $ this -> cfg [ 'collect' ] ) { return ; } $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'caption' => 'trace' , 'channel' => $ this -> cfg [ 'channel' ] , 'columns' => array ( 'file' , 'line' , 'function' ) , ) ) ; $ backtrace = $ this -> errorHandler -> backtrace ( ) ; for ( $ i = 1 , $ count = \ count ( $ backtrace ) - 1 ; $ i < $ count ; $ i ++ ) { $ frame = $ backtrace [ $ i ] ; $ function = isset ( $ frame [ 'function' ] ) ? $ frame [ 'function' ] : '' ; if ( ! \ preg_match ( '/^' . \ preg_quote ( __CLASS__ ) . '(::|->)/' , $ function ) ) { break ; } } $ backtrace = \ array_slice ( $ backtrace , $ i - 1 ) ; unset ( $ backtrace [ 0 ] [ 'function' ] ) ; $ this -> appendLog ( 'trace' , array ( $ backtrace ) , $ meta ) ; }
1620	public function buildOne ( $ query ) { $ modelClass = $ query -> modelClass ; $ key = $ this -> quoteValue ( $ modelClass :: keyPrefix ( ) . ':a:' ) ; return $ this -> build ( $ query , "do return redis.call('HGETALL',$key .. pk) end" , 'pks' ) ; }
1905	public function query ( $ strQuery = '' ) { if ( ! empty ( $ strQuery ) ) { $ this -> strQuery = trim ( $ strQuery ) ; } if ( $ this -> strQuery == '' ) { throw new \ Exception ( 'Empty query string' ) ; } $ this -> statement = $ this -> resConnection -> executeQuery ( $ this -> strQuery ) ; if ( $ this -> statement -> columnCount ( ) < 1 ) { return $ this ; } return new Result ( $ this -> statement , $ this -> strQuery ) ; }
8834	private function getObserver ( ) : ProcessObserverInterface { if ( 1 === count ( $ this -> observerList ) ) { $ observer = $ this -> observerList [ 0 ] ; } elseif ( count ( $ this -> observerList ) ) { $ observer = new AggregateLogger ( $ this -> observerList ) ; } else { $ observer = new NullProcessObserver ( ) ; } return $ observer ; }
5164	public function send ( EmailSender $ email , array $ data = [ ] ) { $ result = ( new DataBuilderManager ( ) ) -> validateRaw ( $ email -> data_builder , $ data ) ; dispatch ( new SendEmail ( $ email , $ data , $ this -> getAgent ( ) ) ) ; return $ result ; }
4799	function exec ( $ query ) { $ conn = $ this -> getConn ( ) ; $ sql = $ conn -> quote ( $ query ) ; return $ conn -> exec ( $ sql ) ; }
6599	protected function getReturnType ( array $ lines ) { foreach ( $ lines as $ line ) { if ( strpos ( $ line , '@return' ) === 0 ) { $ type = trim ( str_replace ( '@return' , '' , $ line ) ) ; $ type = str_replace ( '$this' , 'self' , $ type ) ; $ type = explode ( '|' , $ type ) ; return $ type ; } } return [ ] ; }
3515	public function getLocale ( ) { if ( ! $ this -> cookiesLoaded ) { $ key = $ this -> cookiePrefix . 'lang_locale' ; $ queuedCookieLocale = \ Cookie :: queued ( $ key , null ) ; $ locale = getSupportedLocale ( $ queuedCookieLocale != null ? $ queuedCookieLocale -> getValue ( ) : \ Cookie :: get ( $ key , '' ) ) ; parent :: setLocale ( $ locale ) ; $ this -> getShowUnpublished ( ) ; $ this -> cookiesLoaded = true ; } return parent :: getLocale ( ) ; }
5026	protected function getCustomizationOptions ( ContainerInterface $ container , $ requestedName , array $ options = null ) { if ( ! static :: OPTIONS_NAME ) { throw new \ RuntimeException ( 'The class constants "OPTIONS_NAME" must be non empty.' ) ; } return $ container -> get ( static :: OPTIONS_NAME ) ; }
4770	public function renderWidget ( string $ widgetGroup = '' , array $ widgetId = [ ] ) { $ widgets = $ this -> widgetBuilder -> build ( $ this -> widgets -> getWidgets ( ) , $ widgetGroup , $ widgetId ) ; return $ this -> engine -> render ( $ widgets ) ; }
6742	public function apply ( Request $ request , ParamConverter $ configuration ) { $ param = $ this -> getRequestAttributeName ( $ request , $ configuration ) ; if ( ! $ request -> attributes -> has ( $ param ) ) { return false ; } $ value = $ request -> attributes -> get ( $ param ) ; if ( ! $ value && $ configuration -> isOptional ( ) ) { return false ; } $ convertedValue = $ this -> convertValue ( $ value , $ configuration ) ; if ( null === $ convertedValue && false === $ configuration -> isOptional ( ) ) { throw new NotFoundHttpException ( "Unable to find '{$configuration->getClass()}' with identifier '{$value}' not found" ) ; } $ request -> attributes -> set ( $ configuration -> getName ( ) , $ convertedValue ) ; return true ; }
1399	public function errors ( $ errors , $ defaultStatusCode = null , array $ headers = [ ] ) { if ( $ errors instanceof ErrorResponseInterface ) { return $ this -> getErrorResponse ( $ errors ) ; } if ( is_array ( $ errors ) ) { $ errors = $ this -> api -> getErrors ( ) -> errors ( ... $ errors ) ; } return $ this -> errors ( $ this -> factory -> createErrorResponse ( $ errors , $ defaultStatusCode , $ headers ) ) ; }
764	private function splitStatements ( $ sql , $ params ) { $ semicolonIndex = strpos ( $ sql , ';' ) ; if ( $ semicolonIndex === false || $ semicolonIndex === StringHelper :: byteLength ( $ sql ) - 1 ) { return false ; } $ tokenizer = new SqlTokenizer ( $ sql ) ; $ codeToken = $ tokenizer -> tokenize ( ) ; if ( count ( $ codeToken -> getChildren ( ) ) === 1 ) { return false ; } $ statements = [ ] ; foreach ( $ codeToken -> getChildren ( ) as $ statement ) { $ statements [ ] = [ $ statement -> getSql ( ) , $ this -> extractUsedParams ( $ statement , $ params ) ] ; } return $ statements ; }
8398	public static function getSchema ( string $ mapping ) : Schema { $ data = Mapping :: get ( $ mapping ) ; $ class = rtrim ( ucfirst ( $ data [ 'config' ] [ 'provider' ] ) , '\\' ) . '\\Schema' ; return new $ class ( $ mapping ) ; }
1044	private static function highlightSourceAtLocation ( Source $ source , SourceLocation $ location ) { $ line = $ location -> line ; $ lineOffset = $ source -> locationOffset -> line - 1 ; $ columnOffset = self :: getColumnOffset ( $ source , $ location ) ; $ contextLine = $ line + $ lineOffset ; $ contextColumn = $ location -> column + $ columnOffset ; $ prevLineNum = ( string ) ( $ contextLine - 1 ) ; $ lineNum = ( string ) $ contextLine ; $ nextLineNum = ( string ) ( $ contextLine + 1 ) ; $ padLen = strlen ( $ nextLineNum ) ; $ lines = preg_split ( '/\r\n|[\n\r]/' , $ source -> body ) ; $ lines [ 0 ] = self :: whitespace ( $ source -> locationOffset -> column - 1 ) . $ lines [ 0 ] ; $ outputLines = [ sprintf ( '%s (%s:%s)' , $ source -> name , $ contextLine , $ contextColumn ) , $ line >= 2 ? ( self :: lpad ( $ padLen , $ prevLineNum ) . ': ' . $ lines [ $ line - 2 ] ) : null , self :: lpad ( $ padLen , $ lineNum ) . ': ' . $ lines [ $ line - 1 ] , self :: whitespace ( 2 + $ padLen + $ contextColumn - 1 ) . '^' , $ line < count ( $ lines ) ? self :: lpad ( $ padLen , $ nextLineNum ) . ': ' . $ lines [ $ line ] : null , ] ; return implode ( "\n" , array_filter ( $ outputLines ) ) ; }
10442	protected function getNewPipe ( ) { $ cmd = 'mysqlbinlog ' . escapeshellarg ( $ this -> logDir . '/' . $ this -> baseName ) . '.[0-9]*' ; if ( $ this -> from !== null ) { if ( $ this -> startType == self :: START_TYPE_DATE ) { $ cmd .= ' --start-datetime=' . escapeshellarg ( $ this -> from -> format ( 'Y-m-d H:i:s' ) ) ; } elseif ( $ this -> startType == self :: START_TYPE_POSITION ) { $ cmd .= ' --start-position=' . escapeshellarg ( $ this -> from ) ; } } $ cmd .= " --base64-output=DECODE-ROWS -v 2>&1 | grep -E '###|#[0-9]|Errcode|ERROR'" ; $ this -> pipe = popen ( $ cmd , 'r' ) ; if ( empty ( $ this -> pipe ) ) { throw new \ RuntimeException ( 'Error while executing mysqlbinlog' ) ; } }
2877	public function searchGroupClassAction ( ) { if ( ! $ this -> getRequest ( ) -> isPost ( ) ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 405 ) ; return ; } $ uri = ( string ) $ this -> getRequest ( ) -> getPost ( 'uri' ) ; $ groupType = $ this -> getRequest ( ) -> getPost ( 'group' ) ; $ groupTypes = array ( $ groupType ) ; if ( $ groupType == 'all' ) { $ groupTypes = array ( 'model' , 'block' , 'helper' ) ; } $ items = array ( ) ; if ( $ uri ) { foreach ( $ groupTypes as $ type ) { $ items [ $ type ] [ 'class' ] = Mage :: getConfig ( ) -> getGroupedClassName ( $ type , $ uri ) ; $ items [ $ type ] [ 'filepath' ] = mageFindClassFile ( $ items [ $ type ] [ 'class' ] ) ; } $ block = $ this -> getLayout ( ) -> createBlock ( 'sheep_debug/array' ) ; $ block -> setTemplate ( 'sheep_debug/grouped_class_search.phtml' ) ; $ block -> assign ( 'items' , $ items ) ; $ this -> getResponse ( ) -> setBody ( $ block -> toHtml ( ) ) ; } else { $ this -> getResponse ( ) -> setBody ( $ this -> __ ( 'Please fill in a search query' ) ) ; } }
12833	private function generateConfigCreatorMethod ( ConfigService $ config ) { $ configClass = Util :: normalizeFqcn ( $ config -> getClass ( ) ) ; $ configData = var_export ( $ config -> getData ( ) , true ) ; return <<<PHP public function getAppConfig() : {$configClass} { if (isset(\$this->singletons['{$config->getId()}}'])) { return \$this->singletons['{$config->getId()}']; } \$data = {$configData}; return \$this->singletons['{$config->getId()}'] = new {$configClass}(\$data); }PHP ; }
1059	public static function findValuesRemovedFromEnums ( Schema $ oldSchema , Schema $ newSchema ) { $ oldTypeMap = $ oldSchema -> getTypeMap ( ) ; $ newTypeMap = $ newSchema -> getTypeMap ( ) ; $ valuesRemovedFromEnums = [ ] ; foreach ( $ oldTypeMap as $ typeName => $ oldType ) { $ newType = $ newTypeMap [ $ typeName ] ?? null ; if ( ! ( $ oldType instanceof EnumType ) || ! ( $ newType instanceof EnumType ) ) { continue ; } $ valuesInNewEnum = [ ] ; foreach ( $ newType -> getValues ( ) as $ value ) { $ valuesInNewEnum [ $ value -> name ] = true ; } foreach ( $ oldType -> getValues ( ) as $ value ) { if ( isset ( $ valuesInNewEnum [ $ value -> name ] ) ) { continue ; } $ valuesRemovedFromEnums [ ] = [ 'type' => self :: BREAKING_CHANGE_VALUE_REMOVED_FROM_ENUM , 'description' => sprintf ( '%s was removed from enum type %s.' , $ value -> name , $ typeName ) , ] ; } } return $ valuesRemovedFromEnums ; }
2129	protected function initialize ( ) { if ( static :: $ blnHasLcf === null ) { static :: preload ( ) ; } $ strCacheDir = System :: getContainer ( ) -> getParameter ( 'kernel.cache_dir' ) ; if ( file_exists ( $ strCacheDir . '/contao/config/config.php' ) ) { include $ strCacheDir . '/contao/config/config.php' ; } else { try { $ files = System :: getContainer ( ) -> get ( 'contao.resource_locator' ) -> locate ( 'config/config.php' , null , false ) ; } catch ( \ InvalidArgumentException $ e ) { $ files = array ( ) ; } foreach ( $ files as $ file ) { include $ file ; } } if ( static :: $ blnHasLcf ) { include $ this -> strRootDir . '/system/config/localconfig.php' ; } static :: loadParameters ( ) ; }
6492	private function getBestMediaTypeFormatterMatch ( string $ type , array $ formatters , array $ mediaTypeHeaders , string $ ioType ) : ? MediaTypeFormatterMatch { if ( count ( $ mediaTypeHeaders ) > 0 && $ mediaTypeHeaders [ 0 ] instanceof IHeaderValueWithQualityScore ) { $ mediaTypeHeaders = $ this -> rankAcceptMediaTypeHeaders ( $ mediaTypeHeaders ) ; } foreach ( $ mediaTypeHeaders as $ mediaTypeHeader ) { [ $ mediaType , $ mediaSubType ] = explode ( '/' , $ mediaTypeHeader -> getMediaType ( ) ) ; foreach ( $ formatters as $ formatter ) { foreach ( $ formatter -> getSupportedMediaTypes ( ) as $ supportedMediaType ) { if ( $ ioType === self :: FORMATTER_TYPE_INPUT && ! $ formatter -> canReadType ( $ type ) ) { continue ; } if ( $ ioType === self :: FORMATTER_TYPE_OUTPUT && ! $ formatter -> canWriteType ( $ type ) ) { continue ; } [ $ supportedType , $ supportedSubType ] = explode ( '/' , $ supportedMediaType ) ; if ( $ mediaType === '*' || ( $ mediaSubType === '*' && $ mediaType === $ supportedType ) || ( $ mediaType === $ supportedType && $ mediaSubType === $ supportedSubType ) ) { return new MediaTypeFormatterMatch ( $ formatter , $ supportedMediaType , $ mediaTypeHeader ) ; } } } } return null ; }
2781	public function getCommandLine ( ) { if ( $ this -> executeRaw ) { return $ this -> getCommand ( ) ; } $ command = array_merge ( [ $ this -> getCommand ( ) ] , $ this -> buildOptions ( ) , $ this -> args ) ; return array_filter ( $ command , 'strlen' ) ; }
4274	public function stream_flush ( ) { if ( ! $ this -> handle ) { return false ; } self :: restorePrev ( ) ; $ success = \ fflush ( $ this -> handle ) ; self :: register ( ) ; return $ success ; }
8219	protected function getIp ( $ config ) { $ remoteAddr = $ _SERVER [ 'REMOTE_ADDR' ] ; if ( filter_var ( $ remoteAddr , FILTER_VALIDATE_IP , FILTER_FLAG_IPV4 ) ) { $ netmask = ( isset ( $ config [ "netmask_IPv4" ] ) ) ? $ config [ "netmask_IPv4" ] : self :: DEFAULT_NETMASK_IPV4 ; } else { $ netmask = ( isset ( $ config [ "netmask_IPv6" ] ) ) ? $ config [ "netmask_IPv6" ] : self :: DEFAULT_NETMASK_IPV6 ; } $ ipSubnet = $ this -> getSubnet ( $ remoteAddr , $ netmask ) ; return $ ipSubnet ; }
12659	private function setExtraLanguagesOutdated ( $ name , $ content ) { foreach ( $ this -> extraLangs as $ lang ) { $ this -> getPageTexts ( $ lang ) ; $ this -> contents [ $ lang ] [ $ name ] [ 'outdated' ] = true ; if ( ! isset ( $ this -> contents [ $ lang ] [ $ name ] [ 'content' ] ) ) { $ this -> contents [ $ lang ] [ $ name ] [ 'content' ] = $ content ; } $ this -> writeTextsToFile ( $ lang ) ; } }
6480	private function getSetCookieHeaderValue ( Cookie $ cookie ) : string { $ headerValue = "{$cookie->getName()}=" . urlencode ( $ cookie -> getValue ( ) ) ; if ( ( $ expiration = $ cookie -> getExpiration ( ) ) !== null ) { $ headerValue .= '; Expires=' . $ expiration -> format ( self :: EXPIRATION_DATE_FORMAT ) ; } if ( ( $ maxAge = $ cookie -> getMaxAge ( ) ) !== null ) { $ headerValue .= "; Max-Age=$maxAge" ; } if ( ( $ domain = $ cookie -> getDomain ( ) ) !== null ) { $ headerValue .= '; Domain=' . urlencode ( $ domain ) ; } if ( ( $ path = $ cookie -> getPath ( ) ) !== null ) { $ headerValue .= '; Path=' . urlencode ( $ path ) ; } if ( $ cookie -> isSecure ( ) ) { $ headerValue .= '; Secure' ; } if ( $ cookie -> isHttpOnly ( ) ) { $ headerValue .= '; HttpOnly' ; } if ( ( $ sameSite = $ cookie -> getSameSite ( ) ) !== null ) { $ headerValue .= '; SameSite=' . urlencode ( $ sameSite ) ; } return $ headerValue ; }
4855	public function log ( $ level , $ message , array $ context = [ ] ) { static $ counter = [ ] ; ! $ this -> logger || $ this -> logger -> log ( $ level , $ message , $ context ) ; $ message = is_object ( $ message ) ? $ message -> __toString ( ) : $ message ; if ( isset ( $ this -> messages [ $ level ] [ $ hash = md5 ( $ message ) ] ) ) { $ this -> messages [ $ level ] [ $ hash ] = '(' . ++ $ counter [ $ hash ] . ') ' . $ message ; } else { $ counter [ $ hash ] = 1 ; $ this -> messages [ $ level ] [ $ hash ] = $ message ; } }
5658	private function addWidgetToForm ( $ node , $ form , $ enclosing_label ) { $ widget = $ this -> tags ( ) -> createTag ( $ node -> name , $ this -> attributes ( $ node ) ) ; if ( ! $ widget ) { return ; } $ widget -> setLabel ( $ enclosing_label ) -> addContent ( $ this -> innerHtml ( $ node ) ) ; if ( $ node -> name == 'select' ) { $ widget -> addTags ( $ this -> collectSelectOptions ( $ node ) ) ; } $ form -> addWidget ( $ widget ) ; $ this -> indexWidgetById ( $ widget ) ; }
10058	public function save ( CacheItemInterface $ item ) { $ item -> setIsHit ( true ) ; $ this -> data [ $ item -> getKey ( ) ] = $ item ; return true ; }
5043	public function addMessage ( $ message , $ namespace = self :: NAMESPACE_INFO ) { if ( ! $ message instanceof NotificationEntityInterface ) { $ messageText = $ this -> isTranslatorEnabled ( ) ? $ this -> getTranslator ( ) -> translate ( $ message , $ this -> getTranslatorTextDomain ( ) ) : $ message ; $ message = new NotificationEntity ( ) ; $ message -> setNotification ( $ messageText ) ; $ message -> setPriority ( $ this -> namespace2priority [ $ namespace ] ) ; } $ nEvent = new NotificationEvent ( ) ; $ nEvent -> setNotification ( $ message ) ; $ this -> notificationListener -> trigger ( NotificationEvent :: EVENT_NOTIFICATION_ADD , $ nEvent ) ; return $ this ; }
5522	public function generate ( $ methods ) { if ( ! $ this -> reflection -> classOrInterfaceExists ( ) ) { return false ; } $ mock_reflection = new SimpleReflection ( $ this -> mock_class ) ; if ( $ mock_reflection -> classExistsWithoutAutoload ( ) ) { return false ; } $ code = $ this -> createCodeForClass ( $ methods ? $ methods : array ( ) ) ; return eval ( "$code return \$code;" ) ; }
5049	public function __isset ( $ property ) { trigger_error ( sprintf ( 'Using isset() with entity properties is deprecated. Use %s::notEmpty("%s") instead.' , get_class ( $ this ) , $ property ) , E_USER_DEPRECATED ) ; return $ this -> notEmpty ( $ property ) ; }
6085	public function retrieveMoodboard ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/moodboards/' . $ id . '' , $ parameters , $ cachePolicy ) ; $ result = new MoodboardResponse ( $ result ) ; return $ result ; }
6845	public static function seconds ( $ step = 1 , $ start = 0 , $ end = 60 ) { $ step = ( int ) $ step ; $ seconds = array ( ) ; for ( $ i = $ start ; $ i < $ end ; $ i += $ step ) { $ seconds [ $ i ] = sprintf ( '%02d' , $ i ) ; } return $ seconds ; }
10316	function getBouncesCount ( $ fromDate = null , $ toDate = null , $ mailingIds = null , $ contactIds = null , $ contactEmails = null , $ contactExternalIds = null , $ statusCodeFilter = null , $ typeFilter = null , $ sourceFilter = null , $ excludeAnonymousBounces = false ) { $ params = $ this -> createCountQueryParameters ( $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , $ mailingIds , null ) ; if ( isset ( $ excludeAnonymousBounces ) ) $ params [ 'exclude_anonymous_bounces' ] = ( $ excludeAnonymousBounces == true ) ? "true" : "false" ; if ( isset ( $ typeFilter ) ) $ params [ 'type' ] = $ typeFilter ; if ( isset ( $ sourceFilter ) ) $ params [ 'source_filter' ] = $ sourceFilter ; return $ this -> get ( 'reports/bounces/count' , $ params ) ; }
12061	public function getPermissionMap ( $ forRequestPath , $ forRoutePath = "" ) { if ( isset ( $ this -> loaded [ $ forRequestPath ] ) ) { return $ this -> loaded [ $ forRequestPath ] ; } $ database = $ this -> database ; $ permissionsSQLd = NULL ; if ( ! empty ( $ forRoutePath ) && ( $ forRoutePath <> $ forRequestPath ) ) : $ permissionsSQLd = "OR {$database->quote($forRoutePath)} REGEXP p.permission_area_uri" ; endif ; $ premissionsSQLc = "SELECT p.*, a.lft, a.rgt, a.authority_name,a.authority_parent_id FROM ?authority_permissions AS p LEFT JOIN ?authority AS a ON p.authority_id=a.authority_id WHERE {$database->quote($forRequestPath)} REGEXP p.permission_area_uri {$permissionsSQLd} ORDER BY a.lft ASC" ; $ permissionsSQL = $ database -> prepare ( $ premissionsSQLc ) ; $ permissions = $ permissionsSQL -> execute ( ) -> fetchAll ( ) ; $ this -> loaded [ $ forRoutePath ] = $ permissions ; return $ this -> loaded [ $ forRoutePath ] ; }
5997	public function setMin ( $ min ) { if ( $ min instanceof DateTime ) { $ this -> min = $ min ; } else { try { $ this -> min = new DateTime ( $ min ) ; } catch ( \ Exception $ e ) { $ this -> min = null ; } } return $ this ; }
9196	public function config ( ) { if ( ! $ this -> config ) { $ config = array ( ) ; $ configFile = $ this -> getThemesPath ( ) . DIRECTORY_SEPARATOR . $ this -> getName ( ) . DIRECTORY_SEPARATOR . 'theme.config.php' ; if ( file_exists ( $ configFile ) ) { ob_start ( ) ; set_error_handler ( function ( $ errno , $ errstr ) { throw new \ ErrorException ( $ errstr , $ errno ) ; } , E_ALL ) ; $ config = include $ configFile ; restore_error_handler ( ) ; ob_get_clean ( ) ; if ( ! is_array ( $ config ) ) throw new \ Exception ( 'Invalid "' . $ this -> getName ( ) . '" Theme Config File. It must return array.' ) ; } $ this -> config = new Entity ( $ config ) ; } return $ this -> config ; }
1206	protected function renderLink ( ItemInterface $ item , array $ options = array ( ) ) { if ( $ item -> getUri ( ) && ( ! $ item -> isCurrent ( ) || $ options [ 'currentAsLink' ] ) ) { $ text = $ this -> renderLinkElement ( $ item , $ options ) ; } else { $ text = $ this -> renderSpanElement ( $ item , $ options ) ; } return $ this -> format ( $ text , 'link' , $ item -> getLevel ( ) , $ options ) ; }
1168	protected function setRemoteValidation ( $ attribute , $ validateAll = false ) { $ validator = $ this -> validator ; $ rules = $ validator -> getRules ( ) ; $ rules = isset ( $ rules [ $ attribute ] ) ? $ rules [ $ attribute ] : [ ] ; if ( in_array ( 'no_js_validation' , $ rules ) ) { $ validator -> setRules ( [ $ attribute => [ ] ] ) ; return ; } if ( ! $ validateAll ) { $ rules = $ this -> purgeNonRemoteRules ( $ rules , $ validator ) ; } $ validator -> setRules ( [ $ attribute => $ rules ] ) ; }
10824	public static function confirm ( $ question , $ allowShort , $ defaultValue = false ) { $ value = $ defaultValue ? 'yes' : 'no' ; $ value = self :: ask ( $ question . ' (yes/no)' , $ value ) ; return $ value == 'yes' || ( $ value == 'y' && $ allowShort ) ; }
8103	private function buildQuery ( $ sql , $ arguments = null ) { if ( is_array ( $ arguments ) ) { $ finalArgs = array ( ) ; foreach ( $ arguments as $ field => $ val ) { $ finalArgs [ ] = " {$field}=:{$field}" ; } $ finalArgs = implode ( ' AND' , $ finalArgs ) ; if ( strpos ( $ sql , ' _arguments_' ) ) { $ sql = str_replace ( ' _arguments_' , $ finalArgs , $ sql ) ; } else { } } $ sql = str_replace ( ' _table_' , " {$this->tableName} " , $ sql ) ; return $ sql ; }
11439	public function getErrors ( $ echoable = false ) { if ( true === $ echoable ) { return join ( "\n<br />" , $ this -> errors ) ; } else { return $ this -> errors ; } }
12584	static function run_generate_extension_config ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { self :: setConfigDir ( $ cliopts ) ; $ overwrite = @ $ cliopts [ 'overwrite-existing' ] ; if ( count ( $ args ) == 0 ) { throw new pakeException ( "Missing extension name" ) ; } $ extname = $ args [ 0 ] ; $ configfile = self :: getOptionsDir ( ) . "/options-$extname.yaml" ; if ( file_exists ( $ configfile ) && ! $ overwrite ) { pake_echo ( "File $configfile already exists. Must overwrite it to continue" ) ; $ ok = pake_input ( "Do you want to overwrite it? [y/n]" , 'n' ) ; if ( $ ok != 'y' ) { return ; } } pake_mkdirs ( self :: getOptionsDir ( ) ) ; pake_copy ( self :: getResourceDir ( ) . '/options-sample.yaml' , $ configfile , array ( 'override' => true ) ) ; pake_echo ( "Created file $configfile, now go and edit it" ) ; }
12227	public function deleteSelf ( ) { $ tmp = dom_import_simplexml ( $ this ) ; if ( $ tmp -> isSameNode ( $ tmp -> ownerDocument -> documentElement ) ) { throw new BadMethodCallException ( 'deleteSelf() cannot be used to delete the root node' ) ; } $ tmp -> parentNode -> removeChild ( $ tmp ) ; }
8971	protected function fromJson ( $ json ) { $ data = json_decode ( $ json , true ) ; return new Rate ( $ data [ 'sourceName' ] , ( float ) $ data [ 'value' ] , $ data [ 'currencyCode' ] , $ data [ 'rateType' ] , \ DateTime :: createFromFormat ( \ DateTime :: ATOM , $ data [ 'date' ] ) , $ data [ 'baseCurrencyCode' ] , \ DateTime :: createFromFormat ( \ DateTime :: ATOM , $ data [ 'createdAt' ] ) , \ DateTime :: createFromFormat ( \ DateTime :: ATOM , $ data [ 'modifiedAt' ] ) ) ; }
3567	public function toArray ( ) { return function ( $ next , $ attributes ) { unset ( $ attributes [ 'meta_attributes' ] , $ attributes [ 'metaAttributes' ] ) ; $ attributes = array_merge ( $ attributes , $ this -> getMetaAttributesArray ( ) ) ; return $ next ( $ attributes ) ; } ; }
2060	public function scheduleUpdate ( Contao \ DataContainer $ dc ) { if ( ! $ dc -> activeRecord || ! $ dc -> activeRecord -> id || Contao \ Input :: get ( 'act' ) == 'copy' ) { return ; } $ objSession = Contao \ System :: getContainer ( ) -> get ( 'session' ) ; $ session = $ objSession -> get ( 'sitemap_updater' ) ; $ session [ ] = Contao \ PageModel :: findWithDetails ( $ dc -> activeRecord -> id ) -> rootId ; $ objSession -> set ( 'sitemap_updater' , array_unique ( $ session ) ) ; }
9443	public function setPackOptions ( Container $ app ) { foreach ( $ this -> packOptions as $ key => & $ value ) { $ key = $ this -> _ns ( $ key ) ; if ( isset ( $ app [ $ key ] ) ) { $ value = $ app [ $ key ] ; } } }
4210	private function phpDocParam ( $ param , $ className ) { $ constantName = null ; $ defaultValue = $ this -> abstracter -> UNDEFINED ; if ( \ array_key_exists ( 'defaultValue' , $ param ) ) { $ defaultValue = $ param [ 'defaultValue' ] ; if ( \ in_array ( $ defaultValue , array ( 'true' , 'false' , 'null' ) ) ) { $ defaultValue = \ json_decode ( $ defaultValue ) ; } elseif ( \ is_numeric ( $ defaultValue ) ) { $ defaultValue = $ defaultValue * 1 ; } elseif ( \ preg_match ( '/^array\(\s*\)|\[\s*\]$/i' , $ defaultValue ) ) { $ defaultValue = array ( ) ; } elseif ( \ preg_match ( '/^(self::)?([^\(\)\[\]]+)$/i' , $ defaultValue , $ matches ) ) { if ( $ matches [ 1 ] ) { if ( \ defined ( $ className . '::' . $ matches [ 2 ] ) ) { $ constantName = $ matches [ 0 ] ; $ defaultValue = \ constant ( $ className . '::' . $ matches [ 2 ] ) ; } } elseif ( \ defined ( $ defaultValue ) ) { $ constantName = $ defaultValue ; $ defaultValue = \ constant ( $ defaultValue ) ; } } else { $ defaultValue = \ trim ( $ defaultValue , '\'"' ) ; } } return array ( 'constantName' => $ constantName , 'defaultValue' => $ defaultValue , ) ; }
5372	public function merge ( $ query ) { if ( is_object ( $ query ) ) { $ this -> request = array_merge ( $ this -> request , $ query -> getAll ( ) ) ; } elseif ( is_array ( $ query ) ) { foreach ( $ query as $ key => $ value ) { $ this -> add ( $ key , $ value ) ; } } }
10953	protected function ifModSince ( Request $ request , Response $ response , int $ timestamp ) : Response { $ ifModSince = $ request -> getHeaderLine ( 'If-Modified-Since' ) ; if ( $ ifModSince && $ timestamp <= strtotime ( $ ifModSince ) ) { return $ response -> withStatus ( 304 , "Not Modified" ) ; } return $ response ; }
12436	public function addExtra ( $ id , IFormField $ formField ) { $ formField -> setId ( $ id ) ; return $ this -> addFormField ( $ formField , true ) ; }
2612	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ dictionary = $ this -> api -> getAuthDictionary ( $ activeVersion ) ; if ( ( is_array ( $ dictionary ) && empty ( $ dictionary ) ) || ! isset ( $ dictionary -> id ) ) { return $ result -> setData ( [ 'status' => 'empty' , 'msg' => 'Authentication dictionary does not exist.' ] ) ; } $ user = $ this -> getRequest ( ) -> getParam ( 'auth_user' ) ; $ pass = $ this -> getRequest ( ) -> getParam ( 'auth_pass' ) ; $ key = base64_encode ( $ user . ':' . $ pass ) ; $ this -> api -> upsertDictionaryItem ( $ dictionary -> id , $ key , true ) ; return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
8359	public function dashboards ( Environment $ environment , $ size ) { $ dashboards = null ; if ( $ this -> tokenStorage -> getToken ( ) -> getUser ( ) !== null ) { $ dashboardsAvailable = array ( 'ContactForm' , 'Email' , 'Events' , 'ExceptionChecker' , 'GiftVoucher' , 'PageEdit' , 'Payment' , 'PurchaseCredits' , 'Site' , 'User' ) ; foreach ( $ dashboardsAvailable as $ dashboardAvailable ) { if ( is_dir ( $ this -> container -> getParameter ( 'kernel.root_dir' ) . '/../vendor/c975l/' . strtolower ( $ dashboardAvailable ) . '-bundle' ) && $ this -> configService -> hasParameter ( 'c975L' . $ dashboardAvailable . '.roleNeeded' ) && $ this -> container -> get ( 'security.authorization_checker' ) -> isGranted ( $ this -> configService -> getParameter ( 'c975L' . $ dashboardAvailable . '.roleNeeded' ) ) ) { $ dashboards [ ] = strtolower ( $ dashboardAvailable ) ; } } } return $ environment -> render ( '@c975LToolbar/dashboards.html.twig' , array ( 'dashboards' => $ dashboards , 'size' => $ size , ) ) ; }
7849	public function dispatchFrom ( $ command , ArrayAccess $ source , array $ extras = [ ] ) { $ this -> command = $ command ; $ this -> values = array_merge ( ( array ) $ source , $ extras ) ; return $ this -> dispatcher -> dispatch ( $ this -> marshal ( ) ) ; }
4117	public function isWithinCachedBlock ( Mage_Core_Block_Abstract $ block ) { $ step = $ block ; $ i = 0 ; while ( $ i ++ < 20 && $ step instanceof Mage_Core_Block_Abstract ) { if ( ! is_null ( $ step -> getCacheLifetime ( ) ) ) { return true ; } $ step = $ step -> getParentBlock ( ) ; } return false ; }
11495	public function showAction ( Request $ request , Application $ app ) { $ options = array ( "request" => $ request , "configuration_handler" => $ app [ "red_kite_cms.configuration_handler" ] , "page_collection_manager" => $ app [ "red_kite_cms.page_collection_manager" ] , 'form_factory' => $ app [ "form.factory" ] , "pages_collection_parser" => $ app [ "red_kite_cms.pages_collection_parser" ] , "username" => $ this -> fetchUsername ( $ app [ "security" ] , $ app [ "red_kite_cms.configuration_handler" ] ) , 'theme' => $ app [ "red_kite_cms.theme" ] , 'template_assets' => $ app [ "red_kite_cms.template_assets" ] , 'twig' => $ app [ "twig" ] , ) ; return parent :: show ( $ options ) ; }
1991	protected function getLoginStatus ( $ strCookie ) { @ trigger_error ( 'Using Frontend::getLoginStatus() has been deprecated and will no longer work in Contao 5.0. Use Symfony security instead.' , E_USER_DEPRECATED ) ; $ objTokenChecker = System :: getContainer ( ) -> get ( 'contao.security.token_checker' ) ; if ( $ strCookie == 'BE_USER_AUTH' && $ objTokenChecker -> hasBackendUser ( ) ) { if ( TL_MODE == 'FE' && ! $ objTokenChecker -> isPreviewMode ( ) ) { return false ; } return true ; } if ( $ strCookie == 'FE_USER_AUTH' && $ objTokenChecker -> hasFrontendUser ( ) ) { return true ; } return false ; }
8555	public function setAdjustmentEventList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'AdjustmentEventList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
9410	protected function collect ( ) { $ collector = new RouteCollector ; foreach ( $ this -> router -> routes ( ) as $ route ) { $ collector -> addRoute ( $ route [ 0 ] , $ route [ 1 ] , $ route [ 2 ] ) ; } return $ collector -> getData ( ) ; }
1825	public function setRow ( array $ arrData ) { foreach ( $ arrData as $ k => $ v ) { if ( strpos ( $ k , '__' ) !== false ) { unset ( $ arrData [ $ k ] ) ; } } $ this -> arrData = $ arrData ; return $ this ; }
9927	private function cleanUnwanted ( Parameters $ params , $ permitted ) { foreach ( $ params -> toArray ( ) as $ key => $ value ) { if ( is_array ( $ value ) && ! is_int ( $ key ) ) { if ( ! array_key_exists ( $ key , $ permitted ) ) { $ this -> handleUnpermittedParam ( $ key , $ params ) ; } } elseif ( ! is_int ( $ key ) && ! in_array ( $ key , $ permitted ) && ! array_key_exists ( $ key , $ permitted ) ) { $ this -> handleUnpermittedParam ( $ key , $ params ) ; } } }
11170	private function refreshSession ( ) { $ mapper = Neuron_GameServer_Mappers_UpdateMapper :: getInstance ( ) ; if ( ! isset ( $ _SESSION [ 'ngpu_lastlog' ] ) ) { $ _SESSION [ 'ngpu_lastlog' ] = $ mapper -> getLastLogId ( $ this -> objProfile ) ; $ _SESSION [ 'ngpu_data' ] = array ( ) ; } else { $ lastLogId = $ _SESSION [ 'ngpu_lastlog' ] ; $ updates = $ mapper -> getUpdates ( $ this -> objProfile , $ lastLogId ) ; foreach ( $ updates as $ v ) { $ _SESSION [ 'ngpu_data' ] [ $ v [ 'key' ] ] = $ v [ 'value' ] ; $ lastLogId = max ( $ v [ 'id' ] , $ lastLogId ) ; } $ _SESSION [ 'ngpu_lastlog' ] = $ lastLogId ; } }
2456	public function deleteAll ( ) { if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notDeletable' ] ) { throw new InternalServerErrorException ( 'Table "' . $ this -> strTable . '" is not deletable.' ) ; } $ objSession = System :: getContainer ( ) -> get ( 'session' ) ; $ session = $ objSession -> all ( ) ; $ ids = $ session [ 'CURRENT' ] [ 'IDS' ] ; if ( \ is_array ( $ ids ) && \ strlen ( $ ids [ 0 ] ) ) { foreach ( $ ids as $ id ) { $ this -> intId = $ id ; $ this -> delete ( true ) ; } } $ this -> redirect ( $ this -> getReferer ( ) ) ; }
380	public function renderCallStack ( $ exception ) { $ out = '<ul>' ; $ out .= $ this -> renderCallStackItem ( $ exception -> getFile ( ) , $ exception -> getLine ( ) , null , null , [ ] , 1 ) ; for ( $ i = 0 , $ trace = $ exception -> getTrace ( ) , $ length = count ( $ trace ) ; $ i < $ length ; ++ $ i ) { $ file = ! empty ( $ trace [ $ i ] [ 'file' ] ) ? $ trace [ $ i ] [ 'file' ] : null ; $ line = ! empty ( $ trace [ $ i ] [ 'line' ] ) ? $ trace [ $ i ] [ 'line' ] : null ; $ class = ! empty ( $ trace [ $ i ] [ 'class' ] ) ? $ trace [ $ i ] [ 'class' ] : null ; $ function = null ; if ( ! empty ( $ trace [ $ i ] [ 'function' ] ) && $ trace [ $ i ] [ 'function' ] !== 'unknown' ) { $ function = $ trace [ $ i ] [ 'function' ] ; } $ args = ! empty ( $ trace [ $ i ] [ 'args' ] ) ? $ trace [ $ i ] [ 'args' ] : [ ] ; $ out .= $ this -> renderCallStackItem ( $ file , $ line , $ class , $ function , $ args , $ i + 2 ) ; } $ out .= '</ul>' ; return $ out ; }
5689	public function getFormById ( $ id ) { for ( $ i = 0 ; $ i < count ( $ this -> forms ) ; $ i ++ ) { if ( $ this -> forms [ $ i ] -> getId ( ) == $ id ) { return $ this -> forms [ $ i ] ; } } return ; }
2888	public function onBlockToHtml ( Varien_Event_Observer $ observer ) { if ( ! $ this -> canCollect ( ) ) { return ; } $ block = $ observer -> getData ( 'block' ) ; if ( $ block -> getNameInLayout ( ) == 'debug_panels' ) { $ this -> updateProfiling ( ) ; } if ( ! $ this -> canCaptureBlock ( $ block ) ) { return ; } $ blockName = Mage :: helper ( 'sheep_debug' ) -> getBlockName ( $ block ) ; $ requestInfo = $ this -> getRequestInfo ( ) ; try { $ blockInfo = $ requestInfo -> getBlock ( $ blockName ) ; } catch ( Exception $ e ) { $ blockInfo = $ requestInfo -> addBlock ( $ block ) ; } $ blockInfo -> startRendering ( $ block ) ; }
9399	protected function compute ( $ n ) { $ int_fact = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ int_fact *= $ i ; } return $ int_fact ; }
1019	public static function createLocatedError ( $ error , $ nodes = null , $ path = null ) { if ( $ error instanceof self ) { if ( $ error -> path && $ error -> nodes ) { return $ error ; } $ nodes = $ nodes ? : $ error -> nodes ; $ path = $ path ? : $ error -> path ; } $ source = $ positions = $ originalError = null ; $ extensions = [ ] ; if ( $ error instanceof self ) { $ message = $ error -> getMessage ( ) ; $ originalError = $ error ; $ nodes = $ error -> nodes ? : $ nodes ; $ source = $ error -> source ; $ positions = $ error -> positions ; $ extensions = $ error -> extensions ; } elseif ( $ error instanceof Exception || $ error instanceof Throwable ) { $ message = $ error -> getMessage ( ) ; $ originalError = $ error ; } else { $ message = ( string ) $ error ; } return new static ( $ message ? : 'An unknown error occurred.' , $ nodes , $ source , $ positions , $ path , $ originalError , $ extensions ) ; }
5553	public function getRequest ( ) { if ( is_integer ( $ this -> focus ) ) { return $ this -> frames [ $ this -> focus ] -> getRequest ( ) ; } return $ this -> frameset -> getRequest ( ) ; }
12238	public function innerHTML ( ) { $ dom = dom_import_simplexml ( $ this ) ; $ doc = $ dom -> ownerDocument ; $ html = '' ; foreach ( $ dom -> childNodes as $ child ) { $ html .= ( $ child instanceof DOMText ) ? $ child -> textContent : $ doc -> saveXML ( $ child ) ; } return $ html ; }
3107	public function getItemHrefIndex ( ) { if ( isset ( $ this -> state [ self :: VAR_HREF_INDEX ] ) ) { $ table = $ this -> state [ self :: VAR_HREF_INDEX ] ; } else { $ table = [ ] ; } return $ table ; }
9000	private function fixDirectorySeparator ( $ path ) : string { $ path = str_replace ( "\\" , DIRECTORY_SEPARATOR , $ path ) ; $ path = str_replace ( "/" , DIRECTORY_SEPARATOR , $ path ) ; return $ path ; }
10307	public function setGlowProperties ( $ size , $ color_value = null , $ color_alpha = null , $ color_type = null ) { $ this -> setGlowSize ( $ size ) -> setGlowColor ( $ color_value === null ? $ this -> glowProperties [ 'color' ] [ 'value' ] : $ color_value , $ color_alpha === null ? ( int ) $ this -> glowProperties [ 'color' ] [ 'alpha' ] : $ color_alpha , $ color_type === null ? $ this -> glowProperties [ 'color' ] [ 'type' ] : $ color_type ) ; }
252	public function removeAllFlashes ( ) { $ counters = $ this -> get ( $ this -> flashParam , [ ] ) ; foreach ( array_keys ( $ counters ) as $ key ) { unset ( $ _SESSION [ $ key ] ) ; } unset ( $ _SESSION [ $ this -> flashParam ] ) ; }
1518	public function replaceRelationship ( StoreInterface $ store , UpdateRelationship $ request ) { $ result = $ this -> transaction ( function ( ) use ( $ store , $ request ) { return $ this -> doReplaceRelationship ( $ store , $ request ) ; } ) ; if ( $ this -> isResponse ( $ result ) ) { return $ result ; } return $ this -> reply ( ) -> noContent ( ) ; }
3717	public static function withName ( $ columnName , $ tableName , $ code = 0 , $ previous = null ) { return new static ( sprintf ( 'Column "%s" already exists on table "%s' , $ columnName , $ tableName ) , $ code , $ previous ) ; }
3543	public function actionCreateExampleRole ( ) { $ auth = Yii :: $ app -> authManager ; $ displayDetailedAbout = $ auth -> createPermission ( 'permissionDisplayDetailedAbout' ) ; $ displayDetailedAbout -> description = 'Permission to display detailed about informations' ; $ auth -> add ( $ displayDetailedAbout ) ; $ useContactPage = $ auth -> createPermission ( 'permissionToUseContanctPage' ) ; $ useContactPage -> description = 'Permission to use the contanct page' ; $ auth -> add ( $ useContactPage ) ; $ yii2ExampleGroup = $ auth -> createRole ( 'yii2_example_group' ) ; $ auth -> add ( $ yii2ExampleGroup ) ; $ auth -> addChild ( $ yii2ExampleGroup , $ displayDetailedAbout ) ; $ auth -> addChild ( $ yii2ExampleGroup , $ useContactPage ) ; $ useHomePage = $ auth -> createPermission ( 'permissionToSeeHome' ) ; $ useHomePage -> description = 'Permission to use the home page' ; $ auth -> add ( $ useHomePage ) ; $ yii2HomeGroup = $ auth -> createRole ( 'yii2_see_home_group' ) ; $ auth -> add ( $ yii2HomeGroup ) ; $ auth -> addChild ( $ yii2HomeGroup , $ useHomePage ) ; echo "\n\n!!!! TODO !!!!\nTow roles with the name yii2_example_group and yii2_see_home_group were created in yii2.\nPlease create the groups with the same name in Active Directory.\nAssign the user you are using for the login to this groups in Active Directory.\n" ; }
11136	protected function calculateINSERT ( ) { $ this -> query .= 'INSERT INTO ' ; $ this -> queryStringFromArray ( 'tables' , '' , ', ' ) ; if ( ! empty ( $ this -> inserts ) ) { $ this -> query .= ' (' ; $ this -> queryStringFromArray ( 'inserts' , '' , ', ' ) ; $ this -> query .= ')' ; } $ this -> valueStringFromArray ( 'values' , ' VALUES ' , ', ' ) ; }
3593	public static function setFakeMacAddress ( $ interface , $ mac = null ) { if ( ! self :: validateMacAddress ( $ mac ) ) { $ mac = self :: generateMacAddress ( ) ; } self :: runCommand ( "ifconfig {$interface} down" ) ; self :: runCommand ( "ifconfig {$interface} hw ether {$mac}" ) ; self :: runCommand ( "ifconfig {$interface} up" ) ; self :: runCommand ( "dhclient {$interface}" ) ; if ( self :: getCurrentMacAddress ( $ interface ) == $ mac ) { return true ; } return false ; }
4588	public function setMaxResults ( ? int $ maxResults ) { $ this -> maxResults = $ maxResults ; $ this -> _maxResults = null !== $ maxResults ; return $ this ; }
5304	public function getPath ( $ scale = 1 , $ roundPrecision = null , $ flip = 'none' , $ onlyFilled = true , $ xOffset = 0 , $ yOffset = 0 ) { $ path = $ this -> getPathPart ( $ this -> xmlDocument , $ onlyFilled ) ; if ( $ scale !== 1 || $ roundPrecision !== null || $ flip !== 'none' || $ xOffset !== 0 || $ yOffset !== 0 ) { $ path = $ this -> transformPath ( $ path , $ scale , $ roundPrecision , $ flip , $ xOffset / $ scale , $ yOffset / $ scale ) ; } return trim ( $ path ) ; }
9499	public function processRequest ( RequestInterface $ request ) { $ response = $ request -> send ( ) ; $ attempt = 0 ; while ( $ response -> getStatusCode ( ) == 429 && $ attempt < 5 ) { $ wait = $ response -> getHeader ( 'Retry-After' ) ; if ( $ wait > 0 ) { sleep ( $ wait ) ; } $ attempt ++ ; $ response = $ request -> send ( ) ; } if ( $ response -> getStatusCode ( ) >= 500 ) { throw new ZendeskException ( 'Zendesk Server Error Detected.' ) ; } if ( $ response -> getStatusCode ( ) >= 400 ) { if ( $ response -> getContentType ( ) == 'application/json' ) { $ result = $ response -> json ( ) ; $ description = array_key_exists ( $ result , 'description' ) ? $ result [ 'description' ] : 'Invalid Request' ; $ value = array_key_exists ( $ result , 'value' ) ? $ result [ 'value' ] : array ( ) ; $ exception = new ZendeskException ( $ description ) ; $ exception -> setError ( $ value ) ; throw $ exception ; } else { throw new ZendeskException ( 'Invalid API Request' ) ; } } return $ response ; }
500	protected function readString ( $ fileHandle , $ length , $ offset = null ) { if ( $ offset !== null ) { fseek ( $ fileHandle , $ offset ) ; } return $ this -> readBytes ( $ fileHandle , $ length ) ; }
10085	public function setMapping ( $ severity , $ pipe ) { if ( ! isset ( $ this -> mapping [ $ severity ] ) ) { throw new \ RuntimeException ( "Unknown severity: " . $ severity ) ; } if ( ( $ pipe !== self :: SILENCE ) && ( $ pipe !== self :: STDOUT ) && ( $ pipe !== self :: STDERR ) ) { throw new \ RuntimeException ( "Unknown output pipe: " . $ pipe ) ; } $ this -> mapping [ $ severity ] = $ pipe ; }
6822	protected function getGoodAccountNumber ( TaxRuleInterface $ rule , float $ rate , string $ origin ) { foreach ( $ this -> accounts as $ account ) { if ( $ account -> getType ( ) !== AccountingTypes :: TYPE_GOOD ) { continue ; } if ( $ account -> getTaxRule ( ) !== $ rule ) { continue ; } if ( is_null ( $ account -> getTax ( ) ) ) { if ( $ rate == 0 ) { return $ account -> getNumber ( ) ; } continue ; } if ( 0 === bccomp ( $ account -> getTax ( ) -> getRate ( ) , $ rate , 5 ) ) { return $ account -> getNumber ( ) ; } } throw new LogicException ( sprintf ( "No goods account number configured for tax rule '%s' and tax rate %s (%s)" , $ rule -> getName ( ) , $ rate , $ origin ) ) ; }
6882	public static function format ( $ number , $ places , $ monetary = FALSE ) { $ info = localeconv ( ) ; if ( $ monetary ) { $ decimal = $ info [ 'mon_decimal_point' ] ; $ thousands = $ info [ 'mon_thousands_sep' ] ; } else { $ decimal = $ info [ 'decimal_point' ] ; $ thousands = $ info [ 'thousands_sep' ] ; } return number_format ( $ number , $ places , $ decimal , $ thousands ) ; }
750	public function save ( $ filePath , $ messages ) { $ language = str_replace ( '-' , '_' , basename ( dirname ( $ filePath ) ) ) ; $ headers = [ 'msgid ""' , 'msgstr ""' , '"Project-Id-Version: \n"' , '"POT-Creation-Date: \n"' , '"PO-Revision-Date: \n"' , '"Last-Translator: \n"' , '"Language-Team: \n"' , '"Language: ' . $ language . '\n"' , '"MIME-Version: 1.0\n"' , '"Content-Type: text/plain; charset=' . Yii :: $ app -> charset . '\n"' , '"Content-Transfer-Encoding: 8bit\n"' , ] ; $ content = implode ( "\n" , $ headers ) . "\n\n" ; foreach ( $ messages as $ id => $ message ) { $ separatorPosition = strpos ( $ id , chr ( 4 ) ) ; if ( $ separatorPosition !== false ) { $ content .= 'msgctxt "' . substr ( $ id , 0 , $ separatorPosition ) . "\"\n" ; $ id = substr ( $ id , $ separatorPosition + 1 ) ; } $ content .= 'msgid "' . $ this -> encode ( $ id ) . "\"\n" ; $ content .= 'msgstr "' . $ this -> encode ( $ message ) . "\"\n\n" ; } file_put_contents ( $ filePath , $ content ) ; }
4234	private static function splitParams ( $ paramStr ) { $ depth = 0 ; $ startPos = 0 ; $ chars = \ str_split ( $ paramStr ) ; $ params = array ( ) ; foreach ( $ chars as $ pos => $ char ) { switch ( $ char ) { case ',' : if ( $ depth === 0 ) { $ params [ ] = \ trim ( \ substr ( $ paramStr , $ startPos , $ pos - $ startPos ) ) ; $ startPos = $ pos + 1 ; } break ; case '[' : case '(' : $ depth ++ ; break ; case ']' : case ')' : $ depth -- ; break ; } } $ params [ ] = \ trim ( \ substr ( $ paramStr , $ startPos , $ pos + 1 - $ startPos ) ) ; return $ params ; }
11654	protected function _initMultiDbResources ( ) { $ registry = $ this -> getPluginResource ( 'multidb' ) ; if ( ! $ registry ) { return ; } $ options = $ registry -> getOptions ( ) ; foreach ( $ options as & $ connection ) { if ( 'db://' === substr ( $ connection [ 'dbname' ] , 0 , 5 ) ) { $ connection = array_replace ( $ connection , $ this -> _parseDsn ( $ connection [ 'dbname' ] ) ) ; } } Zend_Registry :: set ( 'multidb' , $ registry -> setOptions ( $ options ) ) ; }
4452	public function stats ( ? int $ date = null ) : array { $ date = $ date ? : time ( ) ; return json_decode ( $ this -> client -> stats ( $ this -> name , $ date ) , true ) ; }
2997	public function setFrom ( $ email , $ title = null ) { $ this -> set ( 'From' , $ this -> buildMail ( $ email , $ title ) ) ; }
2421	public static function copyResource ( $ strSource , $ strDestination ) { $ objDatabase = Database :: getInstance ( ) ; $ objFile = FilesModel :: findByPath ( $ strSource ) ; if ( $ objFile === null ) { $ objFile = static :: addResource ( $ strSource ) ; } $ strFolder = \ dirname ( $ strDestination ) ; $ objNewFile = clone $ objFile -> current ( ) ; if ( $ strFolder == Config :: get ( 'uploadPath' ) ) { $ objNewFile -> pid = null ; } else { $ objFolder = FilesModel :: findByPath ( $ strFolder ) ; if ( $ objFolder === null ) { $ objFolder = static :: addResource ( $ strFolder ) ; } $ objNewFile -> pid = $ objFolder -> uuid ; } $ objNewFile -> tstamp = time ( ) ; $ objNewFile -> uuid = $ objDatabase -> getUuid ( ) ; $ objNewFile -> path = $ strDestination ; $ objNewFile -> name = basename ( $ strDestination ) ; $ objNewFile -> save ( ) ; if ( $ objFile -> type == 'folder' ) { $ objFiles = FilesModel :: findMultipleByBasepath ( $ strSource . '/' ) ; if ( $ objFiles !== null ) { while ( $ objFiles -> next ( ) ) { $ objNew = clone $ objFiles -> current ( ) ; $ objNew -> pid = $ objNewFile -> uuid ; $ objNew -> tstamp = time ( ) ; $ objNew -> uuid = $ objDatabase -> getUuid ( ) ; $ objNew -> path = str_replace ( $ strSource . '/' , $ strDestination . '/' , $ objFiles -> path ) ; $ objNew -> save ( ) ; } } } if ( ( $ strPath = \ dirname ( $ strSource ) ) != Config :: get ( 'uploadPath' ) ) { static :: updateFolderHashes ( $ strPath ) ; } if ( ( $ strPath = \ dirname ( $ strDestination ) ) != Config :: get ( 'uploadPath' ) ) { static :: updateFolderHashes ( $ strPath ) ; } return $ objNewFile ; }
10511	public function notify ( ) { $ observersToNotify = array ( ) ; foreach ( $ this -> _observers as $ observer ) { if ( $ this -> checkIfObserverMustBeUpdate ( $ observer ) ) { $ observersToNotify [ ] = $ observer ; } } usort ( $ observersToNotify , array ( $ this , 'orderObserversForPriority' ) ) ; foreach ( $ observersToNotify as $ observer ) { try { $ this -> updateObserverState ( $ observer ) ; } catch ( \ Exception $ e ) { if ( ( int ) $ e -> getCode ( ) === 600 ) { break 1 ; } } } }
5644	public function getStatus ( ) { $ numberOfReporters = count ( $ this -> reporters ) ; for ( $ i = 0 ; $ i < $ numberOfReporters ; $ i ++ ) { if ( ! $ this -> reporters [ $ i ] -> getStatus ( ) ) { return false ; } } return true ; }
10287	protected function parseCrontab ( $ crontab ) { $ lines = preg_split ( '(\r\n|\r|\n)' , $ crontab ) ; $ this -> crontab = array ( ) ; foreach ( $ lines as $ line ) { $ line = trim ( $ line ) ; if ( ! empty ( $ line ) && ( $ line [ 0 ] !== '#' ) && ( $ line [ 0 ] !== ';' ) ) { $ this -> crontab [ ] = new Cronjob ( $ line ) ; } } }
5371	public function attach ( $ key , $ content , $ filename ) { $ this -> request [ ] = new SimpleAttachment ( $ key , $ content , $ filename ) ; }
5904	public function listRoles ( $ includeDeleted = false , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'includeDeleted' => $ includeDeleted ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/accounts/roles' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new Role ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
8818	public function files ( $ key = null , $ name = null ) { if ( is_null ( $ key ) ) { return $ _FILES ; } if ( isset ( $ _FILES [ $ key ] ) ) { if ( ! is_null ( $ name ) ) { return $ _FILES [ $ key ] [ $ name ] ; } return $ _FILES [ $ key ] ; } return false ; }
12105	public function exception ( Exception $ exception ) { if ( $ this -> stopPropagation ) { return false ; } $ this -> fireHandlers ( $ exception ) ; $ this -> stopPropagation = true ; return false ; }
11693	public function run ( ) : Robo \ Result { $ result = $ this -> collectionBuilder ( ) -> taskFilesystemStack ( ) -> mkdir ( $ this -> destination -> getPath ( ) ) -> touch ( $ this -> destination -> getPathname ( ) ) -> run ( ) -> wasSuccessful ( ) ; if ( ! $ result ) { throw new RuntimeException ( 'We can not write to the destination file: ' . $ this -> destination -> getPathname ( ) ) ; } $ asset_contents = '' ; foreach ( $ this -> source as $ file ) { $ this -> printTaskInfo ( 'Compiling - <info>' . $ file . '</info>' ) ; $ asset_contents .= $ this -> getCompiler ( new SplFileInfo ( $ file ) ) -> compile ( ) ; } if ( $ this -> cachebust === true ) { $ this -> bustCacheBalls ( $ asset_contents ) ; } $ this -> writeAsset ( $ asset_contents ) ; return \ Robo \ Result :: success ( $ this ) ; }
9731	public function canRead ( $ pFilename ) { try { $ this -> openFile ( $ pFilename ) ; } catch ( Exception $ e ) { return false ; } $ data = fread ( $ this -> fileHandle , 2048 ) ; $ delimiterCount = substr_count ( $ data , ';' ) ; $ hasDelimiter = $ delimiterCount > 0 ; $ lines = explode ( "\n" , $ data ) ; $ hasId = substr ( $ lines [ 0 ] , 0 , 4 ) === 'ID;P' ; fclose ( $ this -> fileHandle ) ; return $ hasDelimiter && $ hasId ; }
4380	protected function visualWhiteSpace ( $ str ) { $ str = \ preg_replace_callback ( '/(\r\n|\r|\n)/' , array ( $ this , 'visualWhiteSpaceCallback' ) , $ str ) ; $ str = \ preg_replace ( '#(<br />)?\n$#' , '' , $ str ) ; $ str = \ str_replace ( "\t" , '<span class="ws_t">' . "\t" . '</span>' , $ str ) ; return $ str ; }
4772	public function configs ( Request $ request , WidgetInterface $ widget , CacheInterface $ cache , string $ widgetId ) { $ widgets = $ widget -> getWidgets ( ) ; if ( isset ( $ widgets [ $ widgetId ] ) ) { $ widgetConfig = $ this -> getDoctrine ( ) -> getRepository ( 'PdWidgetBundle:WidgetUser' ) -> findOneBy ( [ 'owner' => $ this -> getUser ( ) ] ) ?? ( new WidgetUser ( ) ) -> setOwner ( $ this -> getUser ( ) ) ; if ( $ request -> get ( 'remove' ) ) { $ widgetConfig -> removeWidgetConfig ( $ widgetId , $ widgets [ $ widgetId ] -> getConfigProcess ( $ request ) ?? [ ] ) ; } else { $ widgetConfig -> addWidgetConfig ( $ widgetId , $ widgets [ $ widgetId ] -> getConfigProcess ( $ request ) ?? [ ] ) ; } $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ em -> persist ( $ widgetConfig ) ; $ em -> flush ( ) ; $ cache -> delete ( $ widgetId . $ this -> getUser ( ) -> getId ( ) ) ; } return $ this -> redirect ( $ request -> headers -> get ( 'referer' ) ?? $ this -> generateUrl ( $ this -> getParameter ( 'pd_widget.return_route' ) ) ) ; }
10623	public static function synchronizeMigrations ( CommandEvent $ event ) { $ packages = $ event -> getComposer ( ) -> getRepositoryManager ( ) -> getLocalRepository ( ) -> getPackages ( ) ; $ installer = $ event -> getComposer ( ) -> getInstallationManager ( ) ; $ appMigrationDir = self :: getDestinationDir ( $ event -> getComposer ( ) ) ; $ io = $ event -> getIO ( ) ; $ areFileMigrated = array ( ) ; $ areFileMigrated [ ] = self :: handlePackage ( '.' , $ event -> getComposer ( ) -> getPackage ( ) , $ io , $ appMigrationDir ) ; foreach ( $ packages as $ package ) { $ areFileMigrated [ ] = self :: handlePackage ( $ installer -> getInstallPath ( $ package ) , $ package , $ io , $ appMigrationDir ) ; } if ( in_array ( true , $ areFileMigrated ) ) { $ io -> write ( "<warning>Some migration files have been imported. " . "You should run `php app/console doctrine:migrations:status` and/or " . "`php app/console doctrine:migrations:migrate` to apply them to your DB." ) ; } }
3043	protected function unpackTimeLine ( & $ data ) { $ timeLine = new QtiTimeLine ( ) ; if ( isset ( $ data [ self :: STORAGE_KEY_TIMELINE_POINTS ] ) ) { $ epoch = 0 ; if ( isset ( $ data [ self :: STORAGE_KEY_TIMELINE_EPOCH ] ) ) { $ epoch = $ data [ self :: STORAGE_KEY_TIMELINE_EPOCH ] ; } $ tags = $ data [ self :: STORAGE_KEY_TIMELINE_TAGS ] ; foreach ( $ data [ self :: STORAGE_KEY_TIMELINE_POINTS ] as & $ dataPoint ) { $ point = new TimePoint ( $ tags , $ dataPoint [ 2 ] + $ epoch , $ dataPoint [ 1 ] , $ dataPoint [ 0 ] ) ; $ timeLine -> add ( $ point ) ; } $ points = $ timeLine -> getPoints ( ) ; foreach ( $ data [ self :: STORAGE_KEY_TIMELINE_INDEX ] as $ tag => & $ list ) { foreach ( $ list as $ index ) { $ points [ $ index ] -> addTag ( $ tag ) ; } } } else { $ timeLine -> fromArray ( $ data ) ; } return $ timeLine ; }
3882	private function determineJumpToInformation ( ) { $ translated = $ this -> metaModel -> isTranslated ( ) ; $ desiredLanguage = $ this -> metaModel -> getActiveLanguage ( ) ; $ fallbackLanguage = $ this -> metaModel -> getFallbackLanguage ( ) ; $ jumpToPageId = '' ; $ filterSettingId = '' ; if ( ! isset ( $ this -> jumpToCache [ $ desiredLanguage . '.' . $ fallbackLanguage ] ) ) { foreach ( ( array ) $ this -> get ( 'jumpTo' ) as $ jumpTo ) { $ langCode = $ jumpTo [ 'langcode' ] ; if ( ! $ translated || ( $ langCode == $ desiredLanguage ) || ( $ langCode == $ fallbackLanguage ) ) { $ jumpToPageId = $ jumpTo [ 'value' ] ; $ filterSettingId = $ jumpTo [ 'filter' ] ; if ( $ desiredLanguage == $ jumpTo [ 'langcode' ] ) { break ; } } } $ pageDetails = $ this -> getPageDetails ( $ jumpToPageId ) ; $ filterSetting = $ filterSettingId ? $ this -> getFilterFactory ( ) -> createCollection ( $ filterSettingId ) : null ; $ this -> jumpToCache [ $ desiredLanguage . '.' . $ fallbackLanguage ] = array ( 'page' => $ jumpToPageId , 'pageDetails' => $ pageDetails , 'filter' => $ filterSettingId , 'filterSetting' => $ filterSetting , 'language' => $ pageDetails [ 'language' ] , 'label' => $ this -> getJumpToLabel ( ) ) ; } return $ this -> jumpToCache [ $ desiredLanguage . '.' . $ fallbackLanguage ] ; }
1785	private function isRequestPrivate ( Request $ request ) : bool { if ( $ request -> headers -> has ( 'Authorization' ) ) { return true ; } if ( \ count ( $ request -> cookies -> all ( ) ) ) { return true ; } return false ; }
11501	protected function loadContainer ( array $ config = [ ] , $ environment = null ) { $ containerConfigs = $ this -> provideContainerConfigs ( $ config , $ environment ) ; array_unshift ( $ containerConfigs , new WeaveConfig ( function ( $ pipelineName ) { return $ this -> provideMiddlewarePipeline ( $ pipelineName ) ; } , function ( $ router ) { return $ this -> provideRouteConfiguration ( $ router ) ; } ) ) ; $ this -> container = ( new ContainerBuilder ) -> newConfiguredInstance ( $ containerConfigs , ContainerBuilder :: AUTO_RESOLVE ) ; return $ this -> container -> get ( 'instantiator' ) ; }
1248	private static function getHomeDir ( ) { if ( $ homeDir = getenv ( 'HOME' ) ) { return $ homeDir ; } $ homeDrive = getenv ( 'HOMEDRIVE' ) ; $ homePath = getenv ( 'HOMEPATH' ) ; return ( $ homeDrive && $ homePath ) ? $ homeDrive . $ homePath : null ; }
7006	private function formatD ( & $ str ) { if ( strstr ( $ str , '%D' ) ) $ str = str_replace ( '%D' , $ this -> dayName ( false ) , $ str ) ; }
7197	protected function setIsFirst ( OrderInterface $ order ) { if ( null !== $ customer = $ order -> getCustomer ( ) ) { if ( $ customer -> hasParent ( ) ) { $ customer = $ customer -> getParent ( ) ; } $ first = ! $ this -> orderRepository -> existsForCustomer ( $ customer ) ; } else { $ first = ! $ this -> orderRepository -> existsForEmail ( $ order -> getEmail ( ) ) ; } if ( $ first != $ order -> isFirst ( ) ) { $ order -> setFirst ( $ first ) ; return true ; } return false ; }
12393	public function onSiteSaved ( SiteSavedEvent $ event ) { $ fs = new Filesystem ( ) ; $ fs -> mirror ( $ this -> configurationHandler -> uploadAssetsDir ( ) , $ this -> configurationHandler -> uploadAssetsDirProduction ( ) ) ; }
2234	public function showDeletedRecords ( $ data , $ row ) { $ arrData = Contao \ StringUtil :: deserialize ( $ row [ 'data' ] ) ; foreach ( $ arrData as $ strTable => $ arrTableData ) { Contao \ System :: loadLanguageFile ( $ strTable ) ; Contao \ Controller :: loadDataContainer ( $ strTable ) ; foreach ( $ arrTableData as $ arrRow ) { $ arrBuffer = array ( ) ; foreach ( $ arrRow as $ i => $ v ) { if ( \ is_array ( Contao \ StringUtil :: deserialize ( $ v ) ) ) { continue ; } if ( isset ( $ GLOBALS [ 'TL_DCA' ] [ $ strTable ] [ 'fields' ] [ $ i ] [ 'label' ] ) ) { $ label = \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ strTable ] [ 'fields' ] [ $ i ] [ 'label' ] ) ? $ GLOBALS [ 'TL_DCA' ] [ $ strTable ] [ 'fields' ] [ $ i ] [ 'label' ] [ 0 ] : $ GLOBALS [ 'TL_DCA' ] [ $ strTable ] [ 'fields' ] [ $ i ] [ 'label' ] ; } else { $ label = \ is_array ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ i ] ) ? $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ i ] [ 0 ] : $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ i ] ; } if ( ! $ label ) { $ label = $ i ; } $ arrBuffer [ $ label ] = $ v ; } $ data [ $ strTable ] [ ] = $ arrBuffer ; } } return $ data ; }
11703	public function getForm ( ) { $ oForm = $ this -> getFormInObject ( ) ; $ sFormContent = $ oForm -> start ; foreach ( $ oForm -> form as $ sValue ) { $ sFormContent .= $ sValue . $ this -> _sSeparator ; } $ sFormContent .= $ oForm -> end ; $ oContainer = new Container ; $ oContainer -> setView ( $ sFormContent ) -> setForm ( $ this ) ; return $ oContainer ; }
8657	private function convertCancelFeedSubmissions ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'CancelFeedSubmissions' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetFeedSubmissionIdList ( ) ) { $ feedSubmissionIdList = $ request -> getFeedSubmissionIdList ( ) ; foreach ( $ feedSubmissionIdList -> getId ( ) as $ idIndex => $ id ) { $ parameters [ 'FeedSubmissionIdList' . '.' . 'Id' . '.' . ( $ idIndex + 1 ) ] = $ id ; } } if ( $ request -> isSetFeedTypeList ( ) ) { $ feedTypeList = $ request -> getFeedTypeList ( ) ; foreach ( $ feedTypeList -> getType ( ) as $ typeIndex => $ type ) { $ parameters [ 'FeedTypeList' . '.' . 'Type' . '.' . ( $ typeIndex + 1 ) ] = $ type ; } } if ( $ request -> isSetSubmittedFromDate ( ) ) { $ parameters [ 'SubmittedFromDate' ] = $ this -> getFormattedTimestamp ( $ request -> getSubmittedFromDate ( ) ) ; } if ( $ request -> isSetSubmittedToDate ( ) ) { $ parameters [ 'SubmittedToDate' ] = $ this -> getFormattedTimestamp ( $ request -> getSubmittedToDate ( ) ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
5637	public function paintError ( $ message ) { parent :: paintError ( $ message ) ; print 'Exception ' . $ this -> getExceptionCount ( ) . "!\n$message\n" ; $ breadcrumb = $ this -> getTestList ( ) ; array_shift ( $ breadcrumb ) ; print "\tin " . implode ( "\n\tin " , array_reverse ( $ breadcrumb ) ) ; print "\n" ; }
8486	public static function getCpuVendor ( ) { $ wmi = Windows :: getInstance ( ) ; $ object = $ wmi -> ExecQuery ( "SELECT Manufacturer FROM Win32_Processor" ) ; foreach ( $ object as $ cpu ) { return $ cpu -> Manufacturer ; } return 'Unknown' ; }
3344	public function __batchProcessFiles ( $ filesUuidArr , $ request_type ) { $ filesChunkedArr = array_chunk ( $ filesUuidArr , $ this -> batchFilesChunkSize ) ; $ filesArr = array ( ) ; $ problemsArr = array ( ) ; $ lastStatus = '' ; foreach ( $ filesChunkedArr as $ chunk ) { $ res = $ this -> __batchProcessFilesChunk ( $ chunk , $ request_type ) ; $ lastStatus = $ res [ 'status' ] ; if ( $ lastStatus == "ok" ) { $ problemsObj = $ res [ 'problems' ] ; if ( count ( get_object_vars ( $ problemsObj ) ) > 0 ) { $ problemsArr [ ] = $ problemsObj ; } $ filesArr = array_merge ( $ filesArr , $ res [ 'files' ] ) ; } else { throw new \ Exception ( 'Error process multiple files' , $ res ) ; } } return array ( 'status' => $ lastStatus , 'files' => $ filesArr , 'problems' => $ problemsArr , ) ; }
8331	public function constructPdoDsn ( array $ params ) { if ( PlatformHelper :: isWindows ( ) ) { return $ this -> constructPdoDsnWindows ( $ params ) ; } return $ this -> constructPdoDsnUnix ( $ params ) ; }
2218	public function getFields ( ) { $ arrFields = $ GLOBALS [ 'TL_FFL' ] ; foreach ( array_keys ( $ arrFields ) as $ key ) { $ arrFields [ $ key ] = $ GLOBALS [ 'TL_LANG' ] [ 'FFL' ] [ $ key ] [ 0 ] ; } return $ arrFields ; }
4	private function buildDepExtensionConstraints ( $ depItem , $ depType ) { if ( $ this -> isHash ( $ depItem ) ) { $ depItem = array ( $ depItem ) ; } $ result = array ( ) ; foreach ( $ depItem as $ subDepItem ) { $ depChannelName = 'ext' ; $ depPackageName = $ subDepItem [ 'name' ] ; $ depVersionConstraint = $ this -> parse20VersionConstraint ( $ subDepItem ) ; $ result [ ] = new DependencyConstraint ( $ depType , $ depVersionConstraint , $ depChannelName , $ depPackageName ) ; } return $ result ; }
5013	public function attach ( EventManagerInterface $ events , $ priority = 1 ) : void { $ this -> listeners [ ] = $ events -> attach ( AbstractWorkerEvent :: EVENT_BOOTSTRAP , [ $ this , 'logBootstrap' ] , 1000 ) ; $ this -> listeners [ ] = $ events -> attach ( AbstractWorkerEvent :: EVENT_FINISH , [ $ this , 'logFinish' ] , 1000 ) ; $ this -> listeners [ ] = $ events -> attach ( AbstractWorkerEvent :: EVENT_PROCESS_JOB , [ $ this , 'logJobStart' ] , 1000 ) ; $ this -> listeners [ ] = $ events -> attach ( AbstractWorkerEvent :: EVENT_PROCESS_JOB , [ $ this , 'logJobEnd' ] , - 1000 ) ; $ this -> listeners [ ] = $ events -> attach ( AbstractWorkerEvent :: EVENT_PROCESS_IDLE , [ $ this , 'injectLoggerInEvent' ] , 1000 ) ; $ this -> listeners [ ] = $ events -> attach ( AbstractWorkerEvent :: EVENT_PROCESS_STATE , [ $ this , 'injectLoggerInEvent' ] , 1000 ) ; }
8315	protected function checkResetLink ( ) { if ( ! $ this -> config [ "enabled" ] || ! ( $ token = $ this -> httpRequest -> query -> get ( "confirm" , false ) ) || ! preg_match ( "/^[a-f0-9]+$/" , $ token ) || strlen ( $ token ) !== 2 * ( $ this -> config [ "tokenIdLen" ] + $ this -> config [ "tokenLen" ] ) ) { return ; } $ this -> session -> remove ( "pwreset" ) ; $ tokenId = substr ( $ token , 0 , 2 * $ this -> config [ "tokenIdLen" ] ) ; $ verifier = substr ( $ token , 2 * $ this -> config [ "tokenIdLen" ] ) ; $ tokenData = $ this -> storage -> getResetToken ( $ tokenId ) ; if ( ! $ tokenData || time ( ) > $ tokenData [ 'valid' ] ) { $ this -> session -> addFlash ( "error" , "Reset link has expired." ) ; $ this -> getLogger ( ) -> warning ( "Bad reset token {t} from {addr}" , [ $ token , $ _SERVER [ 'REMOTE_ADDR' ] ] ) ; $ this -> picoAuth -> redirectToPage ( "password_reset" ) ; } if ( hash_equals ( $ tokenData [ 'token' ] , hash ( 'sha256' , $ verifier ) ) ) { $ this -> session -> addFlash ( "success" , "Please set a new password." ) ; $ this -> startPasswordResetSession ( $ tokenData [ 'user' ] ) ; $ this -> logResetLinkVisit ( $ tokenData ) ; $ this -> picoAuth -> redirectToPage ( "password_reset" ) ; } }
4625	public function prepare ( Command $ command , Node $ node ) { if ( $ this -> connection ) { $ this -> resetConnection ( ) ; } parent :: prepare ( $ command , $ node ) ; $ this -> buildPath ( ) ; $ this -> prepareConnection ( ) ; $ this -> prepareRequest ( ) ; return $ this ; }
10333	function fromXML ( $ xmlElement ) { parent :: fromXML ( $ xmlElement ) ; if ( isset ( $ xmlElement -> permissionType ) ) $ this -> permission = Permission :: getPermission ( $ xmlElement -> permissionType ) ; if ( isset ( $ xmlElement -> field_backups ) ) $ this -> fieldBackups = XMLDeserializer :: deserialize ( $ xmlElement -> field_backups ) ; }
4110	protected function arrayToTabList ( array $ array , array $ skipKeys = array ( ) , $ indentationLevel = 1 ) { $ output = '' ; foreach ( $ array as $ key => $ value ) { if ( in_array ( $ key , $ skipKeys , true ) ) { continue ; } $ output .= $ this -> tabsForIndentation ( $ indentationLevel ) ; if ( ! is_array ( $ value ) ) { if ( ! is_int ( $ key ) ) { $ output .= ucfirst ( $ key ) . ":\n" ; $ output .= $ this -> tabsForIndentation ( $ indentationLevel + 1 ) ; } $ output .= $ value . "\n" ; } else { $ output .= ucfirst ( $ key ) . ":\n" ; $ output .= $ this -> arrayToTabList ( $ value , $ skipKeys , $ indentationLevel + 1 ) ; } } return $ output ; }
10672	private static function addSegmentsToPath ( $ path , $ segments ) { $ segments = Arr :: toArray ( $ segments ) ; if ( count ( $ segments ) > 0 ) { $ path .= '/' . implode ( '/' , $ segments ) ; } return $ path ; }
8195	protected function checkConstantExpression ( Twig_NodeInterface $ node ) { if ( ! ( $ node instanceof Twig_Node_Expression_Constant || $ node instanceof Twig_Node_Expression_Array || $ node instanceof Twig_Node_Expression_Unary_Neg || $ node instanceof Twig_Node_Expression_Unary_Pos ) ) { return false ; } foreach ( $ node as $ n ) { if ( ! $ this -> checkConstantExpression ( $ n ) ) { return false ; } } return true ; }
5790	private function setDefaultValue ( $ columnDefault ) { if ( is_null ( $ columnDefault ) ) { $ this -> defaultValue = '' ; } else { switch ( $ this -> type ) { case 'character' : case 'character varying' : case 'text' : case 'USER-DEFINED' : $ parseColumnDefault = explode ( "'" , $ columnDefault ) ; $ this -> defaultValue = $ parseColumnDefault [ 1 ] ; break ; case 'boolean' : if ( $ columnDefault == 'true' ) { $ this -> defaultValue = Postgres :: BOOLEAN_TRUE ; } break ; default : $ this -> defaultValue = $ columnDefault ; } } }
1548	private function registerProcesses ( ) : void { $ this -> routeForProcess ( 'get' , $ this -> baseProcessUrl ( ) , $ this -> actionForRoute ( 'processes' ) ) ; $ this -> routeForProcess ( 'get' , $ this -> processUrl ( ) , $ this -> actionForRoute ( 'process' ) ) ; }
11309	protected function populateStub ( string $ stub , ? string $ class = null ) : string { return str_replace ( '{class}' , $ this -> getName ( $ class ) , $ stub ) ; }
9156	final public function getControllerSettings ( ) { $ rf = new \ ReflectionClass ( $ this ) ; $ this -> response = new Response ( ) ; $ this -> controllerClass = $ rf -> getShortName ( ) ; $ this -> controllerName = ucfirst ( str_replace ( 'Controller' , '' , $ this -> controllerClass ) ) ; $ this -> response -> setTitle ( $ this -> controllerName ) ; $ actions = $ rf -> getMethods ( \ ReflectionMethod :: IS_PUBLIC ) ; foreach ( $ actions as $ action ) { $ this -> parseAnnotations ( $ action ) ; } return $ this ; }
6476	public function readAsJson ( ? IHttpBody $ body ) : array { if ( $ body === null ) { return [ ] ; } $ json = json_decode ( $ body -> readAsString ( ) , true ) ; if ( $ json === null ) { throw new RuntimeException ( 'Body could not be decoded as JSON' ) ; } return $ json ; }
8114	public function addReviewNote ( Member $ reviewer , $ message ) { $ reviewLog = ContentReviewLog :: create ( ) ; $ reviewLog -> Note = $ message ; $ reviewLog -> ReviewerID = $ reviewer -> ID ; $ this -> owner -> ReviewLogs ( ) -> add ( $ reviewLog ) ; }
11203	public function max ( $ key = false ) { $ collection = $ this -> getIterator ( ) ; $ max = 0 ; $ valueToReturn = 0 ; foreach ( $ collection as $ result ) { if ( $ key && isset ( $ result -> $ key ) ) { if ( $ result -> $ key > $ max ) { $ max = $ result -> $ key ; $ valueToReturn = $ result ; } } else if ( $ key && isset ( $ result [ $ key ] ) ) { if ( $ result [ $ key ] > $ max ) { $ max = $ result [ $ key ] ; $ valueToReturn = $ result ; } } else { if ( $ result > $ max ) { $ max = $ result ; $ valueToReturn = $ result ; } } } return $ valueToReturn ; }
5045	public function paginator ( $ paginatorName , $ defaultParams = [ ] , $ as = 'paginator' ) { if ( is_string ( $ defaultParams ) ) { $ as = $ defaultParams ; $ defaultParams = [ ] ; } $ this -> stack [ 'paginator' ] = [ 'as' => $ as , $ paginatorName , $ defaultParams ] ; return $ this ; }
5994	public function setSubFolders ( array $ subFolders ) { $ this -> subFolders = [ ] ; foreach ( $ subFolders as $ item ) { $ this -> addFolderResponse ( $ item ) ; } return $ this ; }
12793	public function create ( $ params = array ( ) ) { $ serverConfig = array_merge ( $ this -> defaults , $ params ) ; try { $ response = $ this -> client -> request -> post ( $ this -> apiEndpoint . "/droplets" , [ 'json' => $ serverConfig ] ) ; if ( 202 != $ this -> client -> getStatus ( $ response ) ) { throw new Exception ( 'Unable to create server.' ) ; } } catch ( Exception $ e ) { echo 'Unable to create server because ' . $ e -> getMessage ( ) ; } return $ this -> client -> getBody ( $ response ) ; }
3122	public function find ( $ tag = null , $ target = TimePoint :: TARGET_ALL , $ type = TimePoint :: TYPE_ALL ) { $ tags = null ; if ( isset ( $ tag ) ) { $ tags = is_array ( $ tag ) ? $ tag : [ $ tag ] ; } $ points = [ ] ; foreach ( $ this -> points as $ point ) { if ( $ point -> match ( $ tags , $ target , $ type ) ) { $ points [ ] = $ point ; } } return $ points ; }
11507	public function serve ( ) { Log :: debug ( 'Request received:' , [ 'Method' => $ this -> request -> getMethod ( ) , 'URI' => $ this -> request -> getRequestUri ( ) , 'Query' => $ this -> request -> getQueryString ( ) , 'Protocal' => $ this -> request -> server -> get ( 'SERVER_PROTOCOL' ) , 'Content' => $ this -> request -> getContent ( ) , ] ) ; $ this -> validate ( $ this -> token ) ; if ( $ str = $ this -> request -> get ( 'echostr' ) ) { Log :: debug ( "Output 'echostr' is '$str'." ) ; return new Response ( $ str ) ; } $ result = $ this -> handleRequest ( ) ; $ response = $ this -> buildResponse ( $ result [ 'to' ] , $ result [ 'from' ] , $ result [ 'response' ] ) ; Log :: debug ( 'Server response created:' , compact ( 'response' ) ) ; return new Response ( $ response ) ; }
6746	public function getCatalogue ( $ locale = null ) { if ( $ this -> translator instanceof TranslatorBagInterface ) { return $ this -> translator -> getCatalogue ( $ locale ) ; } return null ; }
2	private function buildDependency10Info ( $ depArray ) { static $ dep10toOperatorMap = array ( 'has' => '==' , 'eq' => '==' , 'ge' => '>=' , 'gt' => '>' , 'le' => '<=' , 'lt' => '<' , 'not' => '!=' ) ; $ result = array ( ) ; foreach ( $ depArray as $ depItem ) { if ( empty ( $ depItem [ 'rel' ] ) || ! array_key_exists ( $ depItem [ 'rel' ] , $ dep10toOperatorMap ) ) { continue ; } $ depType = ! empty ( $ depItem [ 'optional' ] ) && 'yes' == $ depItem [ 'optional' ] ? 'optional' : 'required' ; $ depType = 'not' == $ depItem [ 'rel' ] ? 'conflicts' : $ depType ; $ depVersion = ! empty ( $ depItem [ 'version' ] ) ? $ this -> parseVersion ( $ depItem [ 'version' ] ) : '*' ; $ depVersionConstraint = ( 'has' == $ depItem [ 'rel' ] || 'not' == $ depItem [ 'rel' ] ) && '*' == $ depVersion ? '*' : $ dep10toOperatorMap [ $ depItem [ 'rel' ] ] . $ depVersion ; switch ( $ depItem [ 'type' ] ) { case 'php' : $ depChannelName = 'php' ; $ depPackageName = '' ; break ; case 'pkg' : $ depChannelName = ! empty ( $ depItem [ 'channel' ] ) ? $ depItem [ 'channel' ] : 'pear.php.net' ; $ depPackageName = $ depItem [ 'name' ] ; break ; case 'ext' : $ depChannelName = 'ext' ; $ depPackageName = $ depItem [ 'name' ] ; break ; case 'os' : case 'sapi' : $ depChannelName = '' ; $ depPackageName = '' ; break ; default : $ depChannelName = '' ; $ depPackageName = '' ; break ; } if ( '' != $ depChannelName ) { $ result [ ] = new DependencyConstraint ( $ depType , $ depVersionConstraint , $ depChannelName , $ depPackageName ) ; } } return $ result ; }
4318	private function setLogDest ( $ where = 'auto' ) { if ( $ where == 'auto' ) { $ where = $ this -> data [ 'groupPriorityStack' ] ? 'summary' : 'log' ; } if ( $ where == 'log' ) { $ this -> rootInstance -> logRef = & $ this -> rootInstance -> data [ 'log' ] ; $ this -> rootInstance -> groupStackRef = & $ this -> rootInstance -> data [ 'groupStacks' ] [ 'main' ] ; } elseif ( $ where == 'alerts' ) { $ this -> rootInstance -> logRef = & $ this -> rootInstance -> data [ 'alerts' ] ; } else { $ priority = \ end ( $ this -> data [ 'groupPriorityStack' ] ) ; if ( ! isset ( $ this -> data [ 'logSummary' ] [ $ priority ] ) ) { $ this -> data [ 'logSummary' ] [ $ priority ] = array ( ) ; $ this -> data [ 'groupStacks' ] [ $ priority ] = array ( ) ; } $ this -> rootInstance -> logRef = & $ this -> rootInstance -> data [ 'logSummary' ] [ $ priority ] ; $ this -> rootInstance -> groupStackRef = & $ this -> rootInstance -> data [ 'groupStacks' ] [ $ priority ] ; } }
2720	public function execute ( ) { $ resultLayout = null ; try { $ resultLayout = $ this -> resultLayoutFactory -> create ( ) ; $ resultLayout -> addDefaultHandle ( ) ; $ countryCode = $ this -> getRequest ( ) -> getParam ( self :: REQUEST_PARAM_COUNTRY ) ; $ storeId = $ this -> config -> getGeoIpMappingForCountry ( $ countryCode ) ; if ( $ storeId !== null ) { $ redirectUrl = null ; $ targetStore = $ this -> storeRepository -> getActiveStoreById ( $ storeId ) ; $ currentStore = $ this -> storeManager -> getStore ( ) ; if ( $ currentStore -> getId ( ) != $ targetStore -> getId ( ) ) { $ this -> url -> setScope ( $ targetStore -> getId ( ) ) ; $ this -> url -> addQueryParams ( [ ' store' => $ targetStore -> getCode ( ) , ' from_store' => $ currentStore -> getCode ( ) ] ) ; $ redirectUrl = $ this -> url -> getUrl ( 'stores/store/switch' ) ; } if ( $ redirectUrl ) { switch ( $ this -> config -> getGeoIpAction ( ) ) { case Config :: GEOIP_ACTION_DIALOG : $ resultLayout -> getLayout ( ) -> getUpdate ( ) -> load ( [ 'geoip_getaction_dialog' ] ) ; $ resultLayout -> getLayout ( ) -> getBlock ( 'geoip_getaction' ) -> setMessage ( $ this -> getMessageInStoreLocale ( $ targetStore ) ) ; break ; case Config :: GEOIP_ACTION_REDIRECT : $ resultLayout -> getLayout ( ) -> getUpdate ( ) -> load ( [ 'geoip_getaction_redirect' ] ) ; break ; } $ resultLayout -> getLayout ( ) -> getBlock ( 'geoip_getaction' ) -> setRedirectUrl ( $ redirectUrl ) ; } } } catch ( \ Exception $ e ) { $ this -> logger -> critical ( $ e -> getMessage ( ) ) ; } $ resultLayout -> setHeader ( "x-esi" , "1" ) ; return $ resultLayout ; }
939	public function isWhitespace ( $ whitespaces = " \t\n\r\0\x0B" ) { if ( null === $ whitespaces ) { $ whitespaces = " \t\n\r\0\x0B" ; } if ( $ this -> isArray && ! $ this -> isGivenKind ( T_WHITESPACE ) ) { return false ; } return '' === trim ( $ this -> content , $ whitespaces ) ; }
8769	public function bootstrap ( ) { $ this -> hasBeenBootstrapped = true ; $ this [ 'events' ] -> dispatch ( 'bootstrapping' , [ $ this ] ) ; $ this -> boot ( ) ; $ this [ 'events' ] -> dispatch ( 'bootstrapped' , [ $ this ] ) ; }
11017	public function run ( ) { $ event = new BeforeControllerRunEvent ( ) ; $ this -> dispatcher -> fire ( Events :: EVENT_BEFORE_CONTROLLER_RUN , $ event ) ; $ action = $ this -> action -> getName ( ) ; if ( $ this -> action -> hasParams ( ) ) { call_user_func_array ( [ $ this , $ action ] , $ this -> action -> getParams ( ) ) ; } else { $ this -> $ action ( ) ; } $ event = new AfterControllerRunEvent ( ) ; $ this -> dispatcher -> fire ( Events :: EVENT_AFTER_CONTROLLER_RUN , $ event ) ; }
8000	public function calculateNtResponse ( HashCredentialInterface $ hash_credential , $ client_challenge = null , $ server_challenge_nonce = null ) { $ encryption_data = $ server_challenge_nonce ; if ( null !== $ client_challenge ) { $ extended_security_hasher = $ this -> crypt_hasher_factory -> build ( static :: EXTENDED_SESSION_SECURITY_HASHER_ALGORITHM ) ; $ nt_extended_security_challenge_source = $ server_challenge_nonce . $ client_challenge ; $ nt_extended_security_hash = $ extended_security_hasher -> update ( $ nt_extended_security_challenge_source ) -> digest ( ) ; $ nt_extended_security_challenge = substr ( $ nt_extended_security_hash , 0 , static :: EXTENDED_SESSION_SECURITY_CHALLENGE_LENGTH ) ; $ encryption_data = $ nt_extended_security_challenge ; } return $ this -> calculateChallengeResponseData ( $ hash_credential , $ encryption_data ) ; }
4419	protected function checkPermissions ( ) { if ( $ this -> isGranted ( 'ROLE_NGBM_EDITOR' ) ) { return ; } if ( $ this -> isGranted ( 'nglayouts:ui:access' ) ) { return ; } $ exception = $ this -> createAccessDeniedException ( ) ; $ exception -> setAttributes ( 'nglayouts:ui:access' ) ; throw $ exception ; }
7190	private function copyAttachment ( Model \ SaleAttachmentInterface $ source , Model \ SaleAttachmentInterface $ target ) { $ this -> copy ( $ source , $ target , [ 'path' , 'title' , 'type' , 'size' , 'internal' , 'createdAt' , 'updatedAt' , ] ) ; }
6541	public function fetchOne ( $ tableName , array $ identifier , $ shardingKey = null , $ forceFromMaster = true ) { return $ this -> fetch ( $ tableName , $ identifier , $ shardingKey , array ( '*' ) , false , $ forceFromMaster ) ; }
1939	public function clearOptInData ( Contao \ DataContainer $ dc ) { $ this -> Database -> prepare ( "UPDATE tl_newsletter_recipients SET addedOn='' WHERE id=?" ) -> execute ( $ dc -> id ) ; }
6968	protected function calculateGoodLine ( Model \ DocumentLineInterface $ line ) : ? Amount { if ( $ line -> getType ( ) !== Model \ DocumentLineTypes :: TYPE_GOOD ) { throw new LogicException ( sprintf ( "Expected document line with type '%s'." , Model \ DocumentLineTypes :: TYPE_GOOD ) ) ; } if ( null === $ item = $ line -> getSaleItem ( ) ) { throw new LogicException ( "Document can't be recalculated." ) ; } $ result = $ this -> calculator -> calculateSaleItem ( $ item , $ line -> getQuantity ( ) ) ; $ this -> syncLineWithResult ( $ line , $ result ) ; if ( $ item -> isPrivate ( ) ) { return null ; } return $ result ; }
7630	public function getContainerMetadata ( $ containerName = '' ) { Assertion :: notEmpty ( $ containerName , 'Container name is not specified' ) ; self :: assertValidContainerName ( $ containerName ) ; return $ this -> getContainer ( $ containerName ) -> Metadata ; }
3902	public function deleteColumn ( ) { $ schemaManager = $ this -> connection -> getSchemaManager ( ) ; $ columns = $ schemaManager -> listTableColumns ( $ this -> getMetaModel ( ) -> getTableName ( ) ) ; if ( $ this -> getColName ( ) && isset ( $ columns [ $ this -> getColName ( ) ] ) ) { $ this -> tableManipulator -> dropColumn ( $ this -> getMetaModel ( ) -> getTableName ( ) , $ this -> getColName ( ) ) ; } }
8457	protected function injectArguments ( $ command , $ assumeYes ) { $ cmd = $ this -> siteAlias . ' ' . $ command . ( $ assumeYes ? ' -y' : '' ) . $ this -> arguments . $ this -> argumentsForNextCommand ; $ this -> argumentsForNextCommand = '' ; return $ cmd ; }
9991	private function writeChartInCell ( Worksheet $ pSheet , $ coordinates ) { $ html = '' ; foreach ( $ pSheet -> getChartCollection ( ) as $ chart ) { if ( $ chart instanceof Chart ) { $ chartCoordinates = $ chart -> getTopLeftPosition ( ) ; if ( $ chartCoordinates [ 'cell' ] == $ coordinates ) { $ chartFileName = File :: sysGetTempDir ( ) . '/' . uniqid ( '' , true ) . '.png' ; if ( ! $ chart -> render ( $ chartFileName ) ) { return ; } $ html .= PHP_EOL ; $ imageDetails = getimagesize ( $ chartFileName ) ; if ( $ fp = fopen ( $ chartFileName , 'rb' , 0 ) ) { $ picture = fread ( $ fp , filesize ( $ chartFileName ) ) ; fclose ( $ fp ) ; $ base64 = chunk_split ( base64_encode ( $ picture ) ) ; $ imageData = 'data:' . $ imageDetails [ 'mime' ] . ';base64,' . $ base64 ; $ html .= '<div style="position: relative;">' ; $ html .= '<img style="position: absolute; z-index: 1; left: ' . $ chartCoordinates [ 'xOffset' ] . 'px; top: ' . $ chartCoordinates [ 'yOffset' ] . 'px; width: ' . $ imageDetails [ 0 ] . 'px; height: ' . $ imageDetails [ 1 ] . 'px;" src="' . $ imageData . '" border="0" />' . PHP_EOL ; $ html .= '</div>' ; unlink ( $ chartFileName ) ; } } } } return $ html ; }
4583	public function decoded ( JWTDecodedEvent $ event ) { $ payload = $ event -> getPayload ( ) ; $ payload = json_decode ( json_encode ( $ payload ) , true ) ; if ( ! array_key_exists ( $ this -> attribute , $ payload ) ) { $ event -> markAsInvalid ( ) ; } $ uuid = $ payload [ $ this -> attribute ] ; $ tenant = $ this -> tenantService -> getRepository ( ) -> findBy ( [ 'uuid' => $ uuid ] ) ; if ( ! $ tenant ) { $ event -> markAsInvalid ( ) ; } }
7256	public function user ( $ key = null ) { if ( $ this -> sessionKey && $ this -> request -> session ( ) -> check ( $ this -> sessionKey ) ) { $ user = $ this -> request -> session ( ) -> read ( $ this -> sessionKey ) ; } else { return null ; } if ( $ key === null ) { return $ user ; } return Hash :: get ( $ user , $ key ) ; }
4462	private function readErrorFromSocket ( $ socket ) : ? string { $ error = '' ; while ( ! empty ( $ res = socket_read ( $ socket , 8192 ) ) ) { $ error .= $ res ; } $ error = unserialize ( $ error ) ; if ( is_array ( $ error ) ) { $ handler = new ErrorFormatter ( ) ; return sprintf ( '%s: %s in %s on line %d' , $ handler -> constant ( $ error [ 'type' ] ) ? : 'Unknown' , $ error [ 'message' ] , $ error [ 'file' ] , $ error [ 'line' ] ) ; } return null ; }
8436	public static function fetchArray ( array $ conditions , array $ orderBy = null , bool $ critical = false ) { $ entity = new static ( ) ; $ selectQuery = new Select ( $ entity -> getDatabaseName ( ) , $ critical ) ; $ selectQuery -> select ( $ entity -> getAllFieldsRealNames ( ) ) ; $ selectQuery -> from ( $ entity -> getTableName ( ) ) ; if ( count ( $ conditions ) > 0 ) { $ where = array ( ) ; foreach ( $ conditions as $ key => $ value ) { $ realName = constant ( get_called_class ( ) . '::FIELD_' . strtoupper ( Helper :: codifyName ( $ key ) ) ) ; $ where [ $ realName ] = ':where' . ucfirst ( $ key ) ; $ selectQuery -> bind ( 'where' . ucfirst ( $ key ) , $ value ) ; } $ selectQuery -> where ( $ where ) ; } if ( is_array ( $ orderBy ) && count ( $ orderBy ) > 0 ) { $ orders = array ( ) ; foreach ( $ orderBy as $ key => $ value ) { $ realName = constant ( get_called_class ( ) . '::FIELD_' . strtoupper ( Helper :: codifyName ( $ key ) ) ) ; $ orders [ $ realName ] = strtoupper ( ucfirst ( $ value ) ) ; } $ selectQuery -> orderBy ( $ orders ) ; } $ selectQuery -> limit ( 1 ) ; if ( $ selectQuery -> execute ( ) === false ) { return false ; } $ data = $ selectQuery -> fetch ( ) ; if ( is_array ( $ data ) === false ) { return false ; } return $ data ; }
1674	public function synchronize ( ) { if ( ! $ this -> isUnsynchronized ( ) ) { return ; } if ( ! file_exists ( $ this -> strRootDir . '/' . $ this -> strFolder . '/.nosync' ) ) { throw new \ RuntimeException ( sprintf ( 'Cannot synchronize the folder "%s" because one of its parent folders is unsynchronized' , $ this -> strFolder ) ) ; } ( new File ( $ this -> strFolder . '/.nosync' ) ) -> delete ( ) ; }
9502	public function runPeridot ( InputInterface $ input , OutputInterface $ output ) { global $ argv ; $ command = $ this -> joinCommand ( $ argv ) ; $ process = new Process ( $ command ) ; $ process -> run ( function ( $ type , $ buffer ) use ( $ output ) { $ buffer = preg_replace ( '/\[([\d]{1,2})m/' , "\033[$1m" , $ buffer ) ; $ output -> write ( $ buffer ) ; } ) ; }
6320	public function getColumn ( $ name ) { foreach ( $ this -> columns as $ column ) { if ( $ column -> getName ( ) == $ name ) { return $ column ; } } return null ; }
1347	public function isReadProcesses ( ) : bool { return $ this -> isMethod ( 'get' ) && $ this -> getRoute ( ) -> isProcesses ( ) && $ this -> getRoute ( ) -> isNotProcess ( ) ; }
9966	public function fromArray ( array $ source , $ nullValue = null , $ startCell = 'A1' , $ strictNullComparison = false ) { if ( ! is_array ( end ( $ source ) ) ) { $ source = [ $ source ] ; } list ( $ startColumn , $ startRow ) = Coordinate :: coordinateFromString ( $ startCell ) ; foreach ( $ source as $ rowData ) { $ currentColumn = $ startColumn ; foreach ( $ rowData as $ cellValue ) { if ( $ strictNullComparison ) { if ( $ cellValue !== $ nullValue ) { $ this -> getCell ( $ currentColumn . $ startRow ) -> setValue ( $ cellValue ) ; } } else { if ( $ cellValue != $ nullValue ) { $ this -> getCell ( $ currentColumn . $ startRow ) -> setValue ( $ cellValue ) ; } } ++ $ currentColumn ; } ++ $ startRow ; } return $ this ; }
947	protected function scripttagExists ( array $ shopScripttags , array $ scripttag ) { foreach ( $ shopScripttags as $ shopScripttag ) { if ( $ shopScripttag -> src === $ scripttag [ 'src' ] ) { return true ; } } return false ; }
6609	public static function getIdByField ( $ field , $ value ) { $ result = self :: find ( ) -> where ( [ $ field => $ value ] ) -> limit ( 1 ) -> one ( ) ; return ( $ result ) ? $ result -> id : null ; }
3274	public function set ( string $ key , $ data ) { Validation :: validateKey ( $ key ) ; if ( $ this -> get ( $ key ) !== false ) { $ this -> replace ( $ key , $ data ) ; return ; } $ this -> getDatabase ( ) -> appendToFile ( $ this -> getLineString ( $ key , $ data ) ) ; if ( $ cache = $ this -> getConfig ( ) -> getCache ( ) ) { $ cache -> delete ( $ key ) ; } }
2754	public static function plainText ( $ value ) { $ element = render ( $ value ) ; $ element = strip_tags ( $ element ) ; $ element = html_entity_decode ( $ element , ENT_QUOTES ) ; return $ element ; }
5735	public function getMatchesForTeam ( int $ teamID , array $ filter = [ 'dateFrom' => '' , 'dateTo' => '' , 'status' => '' , 'venue' => '' ] ) { $ matches = $ this -> run ( "v2/teams/{$teamID}/matches" . "?" . http_build_query ( $ filter ) ) ; return collect ( $ matches -> matches ) ; }
4966	public function fromHeader ( $ header = null , $ default = null ) { if ( $ header === null ) { return $ this -> event -> getRequest ( ) -> getHeaders ( $ header , $ default ) -> toArray ( ) ; } return $ this -> event -> getRequest ( ) -> getHeaders ( $ header , $ default ) ; }
4408	public function onKernelController ( FilterControllerEvent $ event ) { if ( $ event -> getRequestType ( ) !== HttpKernelInterface :: MASTER_REQUEST ) { return ; } if ( ! $ this -> isAdminSiteAccess ) { return ; } $ currentRoute = $ event -> getRequest ( ) -> attributes -> get ( '_route' ) ; foreach ( $ this -> legacyRoutes as $ legacyRoute ) { if ( stripos ( $ currentRoute , $ legacyRoute ) === 0 ) { $ event -> getRequest ( ) -> attributes -> set ( '_controller' , 'ezpublish_legacy.controller:indexAction' ) ; $ event -> setController ( $ this -> controllerResolver -> getController ( $ event -> getRequest ( ) ) ) ; return ; } } }
11394	public static function setKindOfReportLog ( string $ sKindOfReportLog ) { if ( $ sKindOfReportLog === 'screen' || $ sKindOfReportLog === 'all' ) { self :: $ _sKindOfReportLog = $ sKindOfReportLog ; } else { self :: $ _sKindOfReportLog = 'error_log' ; } }
4158	function run ( ) { $ now = new DateTime ( 'now' ) ; $ sleep = min ( array_map ( function ( $ entry ) use ( $ now ) { list ( $ expression , $ job ) = $ entry ; return $ expression -> getNextRunDate ( $ now ) -> getTimestamp ( ) ; } , $ this -> entries ) ) ; time_sleep_until ( $ sleep ) ; $ scheduled = 0 ; foreach ( $ this -> entries as $ entry ) { list ( $ expression , $ job ) = $ entry ; if ( $ expression -> isDue ( $ now ) ) { $ this -> queue -> push ( $ job ) ; $ scheduled += 1 ; } } $ this -> queue -> flush ( ) ; return $ scheduled ; }
12253	public function dump ( ) { $ dom = new DOMDocument ( '1.0' ) ; $ dom -> preserveWhiteSpace = false ; $ dom -> formatOutput = true ; $ dom -> loadXML ( $ this -> asXML ( ) ) ; return $ dom -> saveXML ( ) ; }
1031	public function completeValueWithLocatedError ( Type $ returnType , $ fieldNodes , ResolveInfo $ info , $ path , $ result ) { try { $ completed = $ this -> completeValue ( $ returnType , $ fieldNodes , $ info , $ path , $ result ) ; $ promise = $ this -> getPromise ( $ completed ) ; if ( $ promise ) { return $ promise -> then ( null , function ( $ error ) use ( $ fieldNodes , $ path ) { return $ this -> exeContext -> promises -> createRejected ( Error :: createLocatedError ( $ error , $ fieldNodes , $ path ) ) ; } ) ; } return $ completed ; } catch ( Exception $ error ) { throw Error :: createLocatedError ( $ error , $ fieldNodes , $ path ) ; } catch ( Throwable $ error ) { throw Error :: createLocatedError ( $ error , $ fieldNodes , $ path ) ; } }
4312	public function setErrorCaller ( $ caller = null ) { if ( $ caller === null ) { $ caller = $ this -> utilities -> getCallerInfo ( 1 ) ; $ caller = array ( 'file' => $ caller [ 'file' ] , 'line' => $ caller [ 'line' ] , ) ; } if ( $ caller ) { $ caller [ 'groupDepth' ] = $ this -> getGroupDepth ( ) ; } $ this -> errorHandler -> setErrorCaller ( $ caller ) ; }
4187	public function publish ( $ provider ) { $ class = last ( explode ( '\\' , $ provider ) ) ; $ this -> console -> info ( "Searching {$provider} to publish vendor file." ) ; if ( ! $ this -> finder -> contains ( $ class ) -> contains ( '/\$this->publishes/i' ) -> count ( ) ) { $ this -> console -> warn ( 'Nothing to publish.' ) ; return true ; } $ tag = $ this -> console -> ask ( "If the \"{$this->console->tokenizePackageInfo()['name']}\" has specify vendor publish tag in installation guide then please add it here or press enter to skip adding tag." , false ) ; $ this -> console -> call ( 'vendor:publish' , [ '--provider' => $ provider , '--tag' => $ tag , ] ) ; return $ this -> registered = true ; }
12735	public function setKeyTitle ( $ class , $ column , $ title ) { $ class = ltrim ( $ this -> getClassName ( $ class ) , '\\' ) ; $ this -> manualKeyTitles [ $ class . '|' . $ column ] = $ title ; return $ this ; }
8743	public function start ( ) { $ this -> eventDispatcher -> addListener ( 'key:stop:listening' , function ( ) { $ this -> isListening = false ; } ) ; $ this -> resetListener ( ) -> overrideReadlineHandler ( ) -> runLoop ( ) -> restoreReadlineHandler ( ) ; }
7245	private function buildSaleItemRemaining ( Common \ SaleItemInterface $ saleItem , Shipment \ RemainingList $ list , array $ shipments ) { if ( ! ( $ saleItem -> isCompound ( ) && ! $ saleItem -> hasPrivateChildren ( ) ) ) { $ quantity = $ saleItem -> getTotalQuantity ( ) ; foreach ( $ shipments as $ shipment ) { foreach ( $ shipment -> getItems ( ) as $ item ) { if ( $ item -> getSaleItem ( ) === $ saleItem ) { $ quantity += $ shipment -> isReturn ( ) ? $ item -> getQuantity ( ) : - $ item -> getQuantity ( ) ; continue 2 ; } } } if ( 0 < $ quantity ) { $ entry = new Shipment \ RemainingEntry ( ) ; $ entry -> setSaleItem ( $ saleItem ) -> setQuantity ( $ quantity ) ; $ list -> addEntry ( $ entry ) ; } } foreach ( $ saleItem -> getChildren ( ) as $ child ) { $ this -> buildSaleItemRemaining ( $ child , $ list , $ shipments ) ; } }
6916	public function removeAttachment ( AttachmentInterface $ attachment ) { if ( $ this -> attachments -> contains ( $ attachment ) ) { $ this -> attachments -> removeElement ( $ attachment ) ; } return $ this ; }
1884	public static function count ( array $ arrOptions ) { $ strQuery = "SELECT COUNT(*) AS count FROM " . $ arrOptions [ 'table' ] ; if ( $ arrOptions [ 'column' ] !== null ) { $ strQuery .= " WHERE " . ( \ is_array ( $ arrOptions [ 'column' ] ) ? implode ( " AND " , $ arrOptions [ 'column' ] ) : $ arrOptions [ 'table' ] . '.' . Database :: quoteIdentifier ( $ arrOptions [ 'column' ] ) . "=?" ) ; } return $ strQuery ; }
5849	protected function moduleContent ( array $ row ) { $ this -> formResultCompiler = GeneralUtility :: makeInstance ( \ TYPO3 \ CMS \ Backend \ Form \ FormResultCompiler :: class ) ; $ wizard = $ this -> formResultCompiler -> addCssFiles ( ) ; $ wizard .= $ this -> buildForm ( $ row ) ; $ wizard .= $ this -> formResultCompiler -> printNeededJSFunctions ( ) ; $ this -> content .= $ wizard ; }
9736	public function setWorksheet ( Worksheet $ pValue = null , $ pOverrideOld = false ) { if ( $ this -> worksheet === null ) { $ this -> worksheet = $ pValue ; $ this -> worksheet -> getCell ( $ this -> coordinates ) ; $ this -> worksheet -> getDrawingCollection ( ) -> append ( $ this ) ; } else { if ( $ pOverrideOld ) { $ iterator = $ this -> worksheet -> getDrawingCollection ( ) -> getIterator ( ) ; while ( $ iterator -> valid ( ) ) { if ( $ iterator -> current ( ) -> getHashCode ( ) == $ this -> getHashCode ( ) ) { $ this -> worksheet -> getDrawingCollection ( ) -> offsetUnset ( $ iterator -> key ( ) ) ; $ this -> worksheet = null ; break ; } } $ this -> setWorksheet ( $ pValue ) ; } else { throw new PhpSpreadsheetException ( 'A Worksheet has already been assigned. Drawings can only exist on one \\PhpOffice\\PhpSpreadsheet\\Worksheet.' ) ; } } return $ this ; }
11911	public static function trimStringRight ( $ str , $ remove ) { if ( ! is_string ( $ str ) ) throw new InvalidArgumentException ( '$str has to be a string' ) ; if ( ! is_string ( $ remove ) ) throw new InvalidArgumentException ( '$remove has to be a string' ) ; $ len = strlen ( $ remove ) ; $ offset = strlen ( $ str ) - $ len ; while ( 0 < $ offset && strpos ( $ str , $ remove , $ offset ) === $ offset ) { $ str = substr ( $ str , 0 , $ offset ) ; $ offset = strlen ( $ str ) - $ len ; } return $ str ; }
8272	public function validateUsersSection ( & $ config ) { if ( ! isset ( $ config [ "users" ] ) ) { return ; } $ this -> assertArray ( $ config , "users" ) ; foreach ( $ config [ "users" ] as $ username => $ userData ) { $ this -> assertUsername ( $ username , $ config ) ; try { $ this -> validateUserData ( $ userData ) ; } catch ( ConfigurationException $ e ) { $ e -> addBeforeMessage ( "Invalid userdata for $username:" ) ; throw $ e ; } $ lowercaseName = strtolower ( $ username ) ; if ( $ username !== $ lowercaseName ) { if ( ! isset ( $ config [ "users" ] [ $ lowercaseName ] ) ) { $ config [ "users" ] [ $ lowercaseName ] = $ userData ; unset ( $ config [ "users" ] [ $ username ] ) ; } else { throw new ConfigurationException ( "User $username is defined multiple times." ) ; } } } }
2558	protected function loadPaymentModule ( MopInfo $ options ) { if ( $ this -> checkAnyNotEmpty ( $ options -> fopType , $ options -> payMerchant , $ options -> payments , $ options -> installmentsInfo , $ options -> mopPaymentType , $ options -> creditCardInfo , $ options -> fraudScreening , $ options -> payIds , $ options -> paySupData ) ) { if ( $ this instanceof MopDescription14 ) { $ this -> paymentModule = new PaymentModule14 ( $ options -> fopType ) ; } else { $ this -> paymentModule = new PaymentModule ( $ options -> fopType ) ; } $ this -> paymentModule -> loadPaymentData ( $ options ) ; $ this -> loadMopInformation ( $ options ) ; $ this -> loadPaymentSupplementaryData ( $ options ) ; } }
2354	public function getResponse ( $ objPage ) { if ( $ objPage -> redirectBack ) { $ _SESSION [ 'LAST_PAGE_VISITED' ] = $ this -> getReferer ( ) ; } $ strLogoutUrl = System :: getContainer ( ) -> get ( 'security.logout_url_generator' ) -> getLogoutUrl ( ) ; $ strRedirect = Environment :: get ( 'base' ) ; if ( $ objPage -> redirectBack && ! empty ( $ _SESSION [ 'LAST_PAGE_VISITED' ] ) ) { $ strRedirect = $ _SESSION [ 'LAST_PAGE_VISITED' ] ; } elseif ( ( $ objTarget = $ objPage -> getRelated ( 'jumpTo' ) ) instanceof PageModel ) { $ strRedirect = $ objTarget -> getAbsoluteUrl ( ) ; } $ uri = Http :: createFromString ( $ strLogoutUrl ) ; $ query = new Query ( $ uri -> getQuery ( ) ) ; $ query = $ query -> merge ( 'redirect=' . $ strRedirect ) ; return new RedirectResponse ( ( string ) $ uri -> withQuery ( ( string ) $ query ) ) ; }
650	public function dropCommentFromTable ( $ table ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> dropCommentFromTable ( $ table ) ; return $ this -> setSql ( $ sql ) ; }
2561	public function loadSpecificChanges ( $ changeTicketing , $ changeQueueing , $ changeOptQueueEl ) { if ( $ changeTicketing ) { $ this -> specificChanges [ ] = new SpecificChanges ( SpecificChanges :: ACTION_TICKETING_OFFICE ) ; } if ( $ changeQueueing ) { $ this -> specificChanges [ ] = new SpecificChanges ( SpecificChanges :: ACTION_QUEUEING_OFFICE ) ; } if ( $ changeOptQueueEl ) { $ this -> specificChanges [ ] = new SpecificChanges ( SpecificChanges :: ACTION_OPT_QUEUE_ELEMENT ) ; } }
9749	public function _calcSize ( & $ raList ) { list ( $ iSBDcnt , $ iBBcnt , $ iPPScnt ) = [ 0 , 0 , 0 ] ; $ iSmallLen = 0 ; $ iSBcnt = 0 ; $ iCount = count ( $ raList ) ; for ( $ i = 0 ; $ i < $ iCount ; ++ $ i ) { if ( $ raList [ $ i ] -> Type == OLE :: OLE_PPS_TYPE_FILE ) { $ raList [ $ i ] -> Size = $ raList [ $ i ] -> getDataLen ( ) ; if ( $ raList [ $ i ] -> Size < OLE :: OLE_DATA_SIZE_SMALL ) { $ iSBcnt += floor ( $ raList [ $ i ] -> Size / $ this -> smallBlockSize ) + ( ( $ raList [ $ i ] -> Size % $ this -> smallBlockSize ) ? 1 : 0 ) ; } else { $ iBBcnt += ( floor ( $ raList [ $ i ] -> Size / $ this -> bigBlockSize ) + ( ( $ raList [ $ i ] -> Size % $ this -> bigBlockSize ) ? 1 : 0 ) ) ; } } } $ iSmallLen = $ iSBcnt * $ this -> smallBlockSize ; $ iSlCnt = floor ( $ this -> bigBlockSize / OLE :: OLE_LONG_INT_SIZE ) ; $ iSBDcnt = floor ( $ iSBcnt / $ iSlCnt ) + ( ( $ iSBcnt % $ iSlCnt ) ? 1 : 0 ) ; $ iBBcnt += ( floor ( $ iSmallLen / $ this -> bigBlockSize ) + ( ( $ iSmallLen % $ this -> bigBlockSize ) ? 1 : 0 ) ) ; $ iCnt = count ( $ raList ) ; $ iBdCnt = $ this -> bigBlockSize / OLE :: OLE_PPS_SIZE ; $ iPPScnt = ( floor ( $ iCnt / $ iBdCnt ) + ( ( $ iCnt % $ iBdCnt ) ? 1 : 0 ) ) ; return [ $ iSBDcnt , $ iBBcnt , $ iPPScnt ] ; }
3282	public function setExt ( string $ ext ) { if ( substr ( $ ext , 0 , 1 ) !== '.' ) { $ ext = '.' . $ ext ; } $ this -> config [ 'ext' ] = $ ext ; }
12931	public function createRouter ( $ debug = false ) { if ( null === $ this -> routesFile ) { throw new LogicException ( 'The derived class must define the string variable "routesFile"' ) ; } if ( ! is_string ( $ this -> routesFile ) ) { throw new LogicException ( '"routesFile" variable must be a string value' ) ; } $ isProduction = $ this -> configurationHandler -> isProduction ( ) ; $ cacheDir = null ; if ( ! $ debug && $ isProduction ) { $ cacheDir = $ this -> configurationHandler -> siteCacheDir ( ) . '/routes' ; } $ this -> router = new Router ( new YamlFileLoader ( $ this -> fileLocator ) , $ this -> routesFile , array ( 'cache_dir' => $ cacheDir ) ) ; return $ this -> router ; }
2502	protected function mapData ( array $ data ) { $ values = array ( ) ; reset ( $ data ) ; while ( $ key = current ( $ data ) ) { $ values [ $ key ] = next ( $ data ) ; next ( $ data ) ; } return $ values ; }
1312	public function setTimeouts ( $ connectionTimeout , $ timeout ) { $ this -> connectionTimeout = ( int ) $ connectionTimeout ; $ this -> timeout = ( int ) $ timeout ; }
10388	protected function handleTtl ( $ key , $ expireSetTs , $ expireSec ) { $ ttl = $ expireSetTs + $ expireSec - time ( ) ; if ( $ ttl <= 0 ) { $ this -> getClient ( ) -> delete ( $ key ) ; throw new KeyNotFoundException ( ) ; } return $ ttl ; }
11106	public function having ( $ column , $ op , $ value , $ isParam = true ) { $ this -> having -> andHaving ( $ column , $ op , $ value , $ isParam ) ; return $ this ; }
9824	public function writeWorksheetRelationships ( \ PhpOffice \ PhpSpreadsheet \ Worksheet \ Worksheet $ pWorksheet , $ pWorksheetId = 1 , $ includeCharts = false ) { $ objWriter = null ; if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' , 'yes' ) ; $ objWriter -> startElement ( 'Relationships' ) ; $ objWriter -> writeAttribute ( 'xmlns' , 'http://schemas.openxmlformats.org/package/2006/relationships' ) ; $ d = 0 ; if ( $ includeCharts ) { $ charts = $ pWorksheet -> getChartCollection ( ) ; } else { $ charts = [ ] ; } if ( ( $ pWorksheet -> getDrawingCollection ( ) -> count ( ) > 0 ) || ( count ( $ charts ) > 0 ) ) { $ this -> writeRelationship ( $ objWriter , ++ $ d , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing' , '../drawings/drawing' . $ pWorksheetId . '.xml' ) ; } $ i = 1 ; foreach ( $ pWorksheet -> getHyperlinkCollection ( ) as $ hyperlink ) { if ( ! $ hyperlink -> isInternal ( ) ) { $ this -> writeRelationship ( $ objWriter , '_hyperlink_' . $ i , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink' , $ hyperlink -> getUrl ( ) , 'External' ) ; ++ $ i ; } } $ i = 1 ; if ( count ( $ pWorksheet -> getComments ( ) ) > 0 ) { $ this -> writeRelationship ( $ objWriter , '_comments_vml' . $ i , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/vmlDrawing' , '../drawings/vmlDrawing' . $ pWorksheetId . '.vml' ) ; $ this -> writeRelationship ( $ objWriter , '_comments' . $ i , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments' , '../comments' . $ pWorksheetId . '.xml' ) ; } $ i = 1 ; if ( count ( $ pWorksheet -> getHeaderFooter ( ) -> getImages ( ) ) > 0 ) { $ this -> writeRelationship ( $ objWriter , '_headerfooter_vml' . $ i , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/vmlDrawing' , '../drawings/vmlDrawingHF' . $ pWorksheetId . '.vml' ) ; } $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
11269	public function getPath ( Neuron_GameServer_Map_Location $ start , Neuron_GameServer_Map_Location $ end ) { $ x1 = $ start [ 0 ] ; $ y1 = $ start [ 1 ] ; $ x2 = $ end [ 0 ] ; $ y2 = $ end [ 1 ] ; if ( ! $ this -> isPassable ( $ x2 , $ y2 ) ) { return false ; } $ astar = $ this -> astar ( $ start , $ end ) ; return $ astar ; }
11983	public function getConfig ( $ name , $ default = null ) { return array_key_exists ( $ name , $ this -> settings ) ? $ this -> settings [ $ name ] : $ default ; }
1294	public static function create ( JsonDecoderClientInterface $ client , ClientOptions $ options ) : ResourcePoolInterface { if ( $ options -> usesLowMemoryResourcePool ( ) ) { return new Standard ( $ client -> getApi ( ) , $ client -> getSpaceId ( ) , $ client -> getEnvironmentId ( ) ) ; } return new Extended ( $ client , $ options -> getCacheItemPool ( ) , $ options -> hasCacheAutoWarmup ( ) , $ options -> hasCacheContent ( ) ) ; }
4372	public function onOutput ( Event $ event ) { $ this -> data = $ this -> debug -> getData ( ) ; $ this -> channels = array ( ) ; $ str = '<div' . $ this -> debug -> utilities -> buildAttribString ( array ( 'class' => 'debug' , 'data-channels' => '{{channels}}' , 'data-channel-root' => $ this -> channelNameRoot , ) ) . ">\n" ; if ( $ this -> debug -> getCfg ( 'output.outputCss' ) ) { $ str .= '<style type="text/css">' . "\n" . $ this -> debug -> output -> getCss ( ) . "\n" . '</style>' . "\n" ; } if ( $ this -> debug -> getCfg ( 'output.outputScript' ) ) { $ str .= '<script type="text/javascript">' . \ file_get_contents ( $ this -> debug -> getCfg ( 'filepathScript' ) ) . '</script>' . "\n" ; } $ str .= '<div class="debug-bar"><h3>Debug Log</h3></div>' . "\n" ; $ str .= $ this -> processAlerts ( ) ; if ( $ this -> debug -> getCfg ( 'output.outputScript' ) ) { $ str .= '<div class="loading">Loading <i class="fa fa-spinner fa-pulse fa-2x fa-fw" aria-hidden="true"></i></div>' . "\n" ; } $ str .= '<div class="debug-header m_group"' . ( $ this -> debug -> getCfg ( 'outputScript' ) ? ' style="display:none;"' : '' ) . '>' . "\n" ; $ str .= $ this -> processSummary ( ) ; $ str .= '</div>' . "\n" ; $ str .= '<div class="debug-content m_group"' . ( $ this -> debug -> getCfg ( 'outputScript' ) ? ' style="display:none;"' : '' ) . '>' . "\n" ; $ str .= $ this -> processLog ( ) ; $ str .= '</div>' . "\n" ; $ str .= '</div>' . "\n" ; $ str = \ strtr ( $ str , array ( '{{channels}}' => \ htmlspecialchars ( \ json_encode ( $ this -> buildChannelTree ( ) , JSON_FORCE_OBJECT ) ) , ) ) ; $ this -> data = array ( ) ; $ event [ 'return' ] .= $ str ; }
7123	protected function updateTicket ( TicketMessageInterface $ message ) { $ ticket = $ message -> getTicket ( ) -> setUpdatedAt ( new \ DateTime ( ) ) ; if ( $ message -> isLatest ( ) && ( $ ticket -> getState ( ) !== TicketStates :: STATE_CLOSED ) ) { if ( $ message -> isCustomer ( ) ) { if ( $ ticket -> getState ( ) === TicketStates :: STATE_PENDING ) { $ ticket -> setState ( TicketStates :: STATE_OPENED ) ; } } elseif ( $ ticket -> getState ( ) === TicketStates :: STATE_OPENED ) { $ ticket -> setState ( TicketStates :: STATE_PENDING ) ; } } $ this -> persistenceHelper -> persistAndRecompute ( $ ticket , false ) ; }
12428	public function setAuthorizerOption ( $ authorizerAppId , $ optionName , $ optionValue ) { $ params = [ 'component_appid' => $ this -> getAppId ( ) , 'authorizer_appid' => $ authorizerAppId , 'option_name' => $ optionName , 'option_value' => $ optionValue , ] ; return $ this -> parseJSON ( 'json' , [ self :: SET_AUTHORIZER_OPTION , $ params ] ) ; }
7536	function detach ( $ move_children_up = false ) { if ( ( $ p = $ this -> parent ) !== null ) { $ index = $ this -> index ( ) ; $ this -> parent = null ; if ( $ move_children_up ) { $ this -> moveChildren ( $ p , $ index ) ; } $ p -> deleteChild ( $ this , true ) ; } }
10288	protected function getJobsSince ( $ time ) { $ now = time ( ) ; $ jobs = array ( ) ; foreach ( $ this -> rescheduled as $ scheduled => $ cronjob ) { if ( $ scheduled <= $ now ) { $ jobs [ $ scheduled ] [ ] = $ cronjob ; unset ( $ this -> rescheduled [ $ scheduled ] ) ; } } foreach ( $ this -> crontab as $ cronjob ) { $ cronjob -> iterator -> startTime = $ time ; if ( ( $ scheduled = $ cronjob -> iterator -> current ( ) ) < $ now ) { $ jobs [ $ scheduled ] [ ] = $ cronjob ; } } ksort ( $ jobs ) ; return $ jobs ; }
8915	public function encode ( $ value , $ b = 62 ) { $ r = ( int ) $ value % $ b ; $ result = $ this -> base [ $ r ] ; $ q = floor ( ( int ) $ value / $ b ) ; while ( $ q ) { $ r = $ q % $ b ; $ q = floor ( $ q / $ b ) ; $ result = $ this -> base [ $ r ] . $ result ; } return $ result ; }
4774	public function build ( $ widgets , string $ widgetGroup = '' , array $ widgetId = [ ] ) { if ( ! $ widgets ) { return $ widgets ; } $ this -> loadUserConfig ( ) ; $ outputWidget = [ ] ; if ( $ widgetId ) { foreach ( $ widgetId as $ id ) { if ( isset ( $ widgets [ $ id ] ) ) { $ widgets [ $ id ] -> setActive ( $ this -> widgetConfig [ $ widget -> getId ( ) ] [ 'status' ] ?? false ) ; $ widgets [ $ id ] -> setConfig ( $ this -> widgetConfig [ $ widget -> getId ( ) ] ?? [ ] ) ; $ outputWidget [ ] = $ widgets [ $ id ] ; } } return $ outputWidget ; } foreach ( $ widgets as $ widget ) { if ( '' !== $ widgetGroup && $ widget -> getGroup ( ) !== $ widgetGroup ) { continue ; } if ( isset ( $ this -> widgetConfig [ $ widget -> getId ( ) ] [ 'order' ] ) ) { $ widget -> setOrder ( $ this -> widgetConfig [ $ widget -> getId ( ) ] [ 'order' ] ) ; } if ( null !== $ widget -> getOrder ( ) ) { while ( isset ( $ outputWidget [ $ widget -> getOrder ( ) ] ) ) { $ widget -> setOrder ( $ widget -> getOrder ( ) + 1 ) ; } $ outputWidget [ $ widget -> getOrder ( ) ] = $ widget ; } else { $ outputWidget [ ] = $ widget ; } $ widget -> setActive ( $ this -> widgetConfig [ $ widget -> getId ( ) ] [ 'status' ] ?? false ) ; $ widget -> setConfig ( $ this -> widgetConfig [ $ widget -> getId ( ) ] ?? [ ] ) ; } ksort ( $ outputWidget ) ; return $ outputWidget ; }
7309	public static function now ( $ timezone = null ) { $ now = explode ( ' ' , microtime ( ) ) ; $ unix = $ now [ 1 ] ; $ micro = Time :: sec ( $ now [ 0 ] ) ; $ jd = ( $ unix / 86400.0 ) + static :: UJD ; if ( $ timezone == null ) { $ timezone = TimeZone :: UTC ( ) ; } if ( is_string ( $ timezone ) ) { $ timezone = TimeZone :: parse ( $ timezone ) ; } return static :: jd ( $ jd ) -> add ( $ micro ) -> setTimezone ( $ timezone ) ; }
12974	protected function autoLoadMappingInfo ( ) { $ mappings = array ( ) ; foreach ( \ Package :: loaded ( ) as $ package => $ path ) { $ mappings [ ] = $ package . '::package' ; } foreach ( \ Module :: loaded ( ) as $ module => $ path ) { $ mappings [ ] = $ module . '::module' ; } $ mappings [ ] = 'app' ; $ mappings = array_fill_keys ( $ mappings , array ( 'is_component' => true ) ) ; $ this -> setMappings ( $ mappings ) ; }
11637	public function getTableRegistry ( ) { if ( is_null ( $ this -> _tableRegistry ) ) { $ objectTypeClass = Yii :: $ app -> classes [ 'ObjectTypeRegistry' ] ; $ this -> _tableRegistry = [ ] ; if ( $ objectTypeClass :: tableExists ( ) ) { $ om = $ objectTypeClass :: find ( ) -> all ( ) ; $ this -> _tableRegistry = ArrayHelper :: index ( $ om , 'name' ) ; } } return $ this -> _tableRegistry ; }
960	public function handle ( Request $ request , Closure $ next ) { if ( Config :: get ( 'shopify-app.billing_enabled' ) === true ) { $ shop = ShopifyApp :: shop ( ) ; if ( ! $ shop -> isFreemium ( ) && ! $ shop -> isGrandfathered ( ) && ! $ shop -> plan ) { return Redirect :: route ( 'billing' ) ; } } return $ next ( $ request ) ; }
12884	public function getKeyTranslation ( Model $ foreignObject , $ key = null ) { if ( isset ( $ key ) ) { return $ this -> internalGetKeyTranslation ( $ foreignObject , $ key ) ; } foreach ( $ this -> keys as $ keyName => $ keyField ) { if ( ! empty ( $ foreignObject -> { $ keyField } ) ) { $ key = $ this -> generateKey ( $ foreignObject , $ keyName , $ foreignObject -> { $ keyField } ) ; $ result = $ this -> internalGetKeyTranslation ( $ foreignObject , $ key ) ; if ( ! empty ( $ result ) ) { return $ result ; } } } return false ; }
7478	public function getFormFor ( $ entity , $ className = null , array $ options = array ( ) ) { if ( empty ( $ this -> _formHelper ) && ( $ this -> _formHelper = $ this -> get ( 'orkestra.application.helper.form' ) ) == null ) { throw new \ RuntimeException ( 'Orkestra FormHelper is not registered as a service' ) ; } $ type = $ this -> container -> get ( 'orkestra.application.helper.form' ) -> getType ( $ entity , $ className ) ; return $ this -> createForm ( $ type , $ entity , $ options ) ; }
8179	public function login ( ) { return $ this -> validate ( ) ? Yii :: $ app -> user -> login ( $ this -> getUser ( ) , $ this -> rememberMe ? UserModule :: $ rememberMeDuration : 0 ) : FALSE ; }
3204	protected function detect_manual_editing ( $ version ) { if ( false === $ version || true === version_compare ( $ version , '2.2.0' , '<' ) ) { return ; } $ checkTokens = array ( T_FUNCTION => true , T_CLASS => true , T_ARRAY => true , T_OPEN_SHORT_ARRAY => true , ) ; for ( $ ptr = 0 ; $ ptr < $ this -> phpcsFile -> numTokens ; $ ptr ++ ) { if ( ! isset ( $ checkTokens [ $ this -> tokens [ $ ptr ] [ 'code' ] ] ) ) { continue ; } if ( T_CLASS === $ this -> tokens [ $ ptr ] [ 'code' ] && isset ( $ this -> tokens [ $ ptr ] [ 'scope_closer' ] ) ) { $ ptr = $ this -> tokens [ $ ptr ] [ 'scope_closer' ] ; continue ; } elseif ( T_OPEN_SHORT_ARRAY === $ this -> tokens [ $ ptr ] [ 'code' ] && isset ( $ this -> tokens [ $ ptr ] [ 'bracket_closer' ] ) ) { $ ptr = $ this -> tokens [ $ ptr ] [ 'bracket_closer' ] ; continue ; } elseif ( T_ARRAY === $ this -> tokens [ $ ptr ] [ 'code' ] && isset ( $ this -> tokens [ $ ptr ] [ 'parenthesis_closer' ] ) ) { $ ptr = $ this -> tokens [ $ ptr ] [ 'parenthesis_closer' ] ; continue ; } if ( T_FUNCTION === $ this -> tokens [ $ ptr ] [ 'code' ] ) { $ function_name = $ this -> phpcsFile -> getDeclarationName ( $ ptr ) ; if ( 'tgmpa' !== $ function_name ) { if ( isset ( $ this -> tokens [ $ ptr ] [ 'scope_closer' ] ) ) { $ ptr = $ this -> tokens [ $ ptr ] [ 'scope_closer' ] ; } continue ; } $ function_exists = $ this -> phpcsFile -> findPrevious ( T_STRING , ( $ ptr - 1 ) , null , false , 'function_exists' ) ; $ param = false ; if ( false !== $ function_exists ) { $ param = $ this -> get_function_call_parameter ( $ function_exists , 1 ) ; $ param = $ this -> strip_quotes ( $ param [ 'raw' ] ) ; } if ( false === $ function_exists || 'tgmpa' !== $ param ) { $ this -> phpcsFile -> recordMetric ( 0 , 'Manual editing detected' , 'yes' ) ; $ this -> phpcsFile -> addError ( 'Manual editing of the TGM Plugin Activation file detected. Your edit will cause fatal errors for end-users. Download an official copy using the Custom TGMPA Generator. http://tgmpluginactivation.com/download/' , 0 , 'ManualEditDetected' , array ( ) , 9 ) ; } else { $ this -> phpcsFile -> recordMetric ( 0 , 'Manual editing detected' , 'no' ) ; } break ; } } }
8767	protected function registerBaseBindings ( ) { static :: setInstance ( $ this ) ; $ this -> instance ( 'app' , $ this ) ; $ this -> instance ( Container :: class , $ this ) ; $ this -> singleton ( 'config' , function ( ) { return new \ Nur \ Config \ Config ( $ this -> config ) ; } ) ; $ this -> singleton ( 'files' , function ( ) { return new Filesystem ; } ) ; $ this -> instance ( PackageManifest :: class , new PackageManifest ( new Filesystem , $ this -> basePath ( ) , $ this -> getCachedPackagesPath ( ) ) ) ; }
7583	protected function extractInfo ( ) { $ this -> info = curl_getinfo ( $ this -> CurlRequest ) ; $ this -> status = $ this -> info [ 'http_code' ] ; if ( curl_errno ( $ this -> CurlRequest ) !== CURLE_OK ) { $ this -> error = curl_error ( $ this -> CurlRequest ) ; } else { $ this -> error = false ; } }
10306	public function setLineStyleProperties ( $ line_width = null , $ compound_type = null , $ dash_type = null , $ cap_type = null , $ join_type = null , $ head_arrow_type = null , $ head_arrow_size = null , $ end_arrow_type = null , $ end_arrow_size = null ) { ( $ line_width !== null ) ? $ this -> lineStyleProperties [ 'width' ] = $ this -> getExcelPointsWidth ( ( float ) $ line_width ) : null ; ( $ compound_type !== null ) ? $ this -> lineStyleProperties [ 'compound' ] = ( string ) $ compound_type : null ; ( $ dash_type !== null ) ? $ this -> lineStyleProperties [ 'dash' ] = ( string ) $ dash_type : null ; ( $ cap_type !== null ) ? $ this -> lineStyleProperties [ 'cap' ] = ( string ) $ cap_type : null ; ( $ join_type !== null ) ? $ this -> lineStyleProperties [ 'join' ] = ( string ) $ join_type : null ; ( $ head_arrow_type !== null ) ? $ this -> lineStyleProperties [ 'arrow' ] [ 'head' ] [ 'type' ] = ( string ) $ head_arrow_type : null ; ( $ head_arrow_size !== null ) ? $ this -> lineStyleProperties [ 'arrow' ] [ 'head' ] [ 'size' ] = ( string ) $ head_arrow_size : null ; ( $ end_arrow_type !== null ) ? $ this -> lineStyleProperties [ 'arrow' ] [ 'end' ] [ 'type' ] = ( string ) $ end_arrow_type : null ; ( $ end_arrow_size !== null ) ? $ this -> lineStyleProperties [ 'arrow' ] [ 'end' ] [ 'size' ] = ( string ) $ end_arrow_size : null ; }
1373	public function all ( ) { if ( is_array ( $ this -> data ) ) { return $ this -> data ; } return $ this -> data = $ this -> route -> getCodec ( ) -> all ( $ this -> request ) ; }
10451	public function getTtl ( $ key ) { $ getResult = $ this -> getValue ( $ key ) ; $ unserialized = @ unserialize ( $ getResult ) ; if ( ! Util :: hasInternalExpireTime ( $ unserialized ) ) { throw new \ Exception ( 'Cannot retrieve ttl' ) ; } return $ this -> handleTtl ( $ key , $ unserialized [ 'ts' ] , $ unserialized [ 's' ] ) ; }
9669	private function writeFont ( XMLWriter $ objWriter , Font $ pFont ) { $ objWriter -> startElement ( 'font' ) ; if ( $ pFont -> getBold ( ) !== null ) { $ objWriter -> startElement ( 'b' ) ; $ objWriter -> writeAttribute ( 'val' , $ pFont -> getBold ( ) ? '1' : '0' ) ; $ objWriter -> endElement ( ) ; } if ( $ pFont -> getItalic ( ) !== null ) { $ objWriter -> startElement ( 'i' ) ; $ objWriter -> writeAttribute ( 'val' , $ pFont -> getItalic ( ) ? '1' : '0' ) ; $ objWriter -> endElement ( ) ; } if ( $ pFont -> getStrikethrough ( ) !== null ) { $ objWriter -> startElement ( 'strike' ) ; $ objWriter -> writeAttribute ( 'val' , $ pFont -> getStrikethrough ( ) ? '1' : '0' ) ; $ objWriter -> endElement ( ) ; } if ( $ pFont -> getUnderline ( ) !== null ) { $ objWriter -> startElement ( 'u' ) ; $ objWriter -> writeAttribute ( 'val' , $ pFont -> getUnderline ( ) ) ; $ objWriter -> endElement ( ) ; } if ( $ pFont -> getSuperscript ( ) === true || $ pFont -> getSubscript ( ) === true ) { $ objWriter -> startElement ( 'vertAlign' ) ; if ( $ pFont -> getSuperscript ( ) === true ) { $ objWriter -> writeAttribute ( 'val' , 'superscript' ) ; } elseif ( $ pFont -> getSubscript ( ) === true ) { $ objWriter -> writeAttribute ( 'val' , 'subscript' ) ; } $ objWriter -> endElement ( ) ; } if ( $ pFont -> getSize ( ) !== null ) { $ objWriter -> startElement ( 'sz' ) ; $ objWriter -> writeAttribute ( 'val' , StringHelper :: formatNumber ( $ pFont -> getSize ( ) ) ) ; $ objWriter -> endElement ( ) ; } if ( $ pFont -> getColor ( ) -> getARGB ( ) !== null ) { $ objWriter -> startElement ( 'color' ) ; $ objWriter -> writeAttribute ( 'rgb' , $ pFont -> getColor ( ) -> getARGB ( ) ) ; $ objWriter -> endElement ( ) ; } if ( $ pFont -> getName ( ) !== null ) { $ objWriter -> startElement ( 'name' ) ; $ objWriter -> writeAttribute ( 'val' , $ pFont -> getName ( ) ) ; $ objWriter -> endElement ( ) ; } $ objWriter -> endElement ( ) ; }
6156	public function redirect ( string $ url ) : object { return parent :: redirect ( $ this -> di -> get ( "url" ) -> create ( $ url ) ) ; }
12474	public function getTheme ( $ identifier ) { $ themes = $ this -> getAvailableThemes ( ) ; if ( ! isset ( $ themes [ $ identifier ] ) ) { $ themeIds = array ( ) ; foreach ( $ themes as $ key => $ value ) { $ themeIds [ ] = $ key ; } throw new \ Exception ( sprintf ( 'Theme "%s" does not exist. Possible values are [%s]' , $ identifier , implode ( ', ' , $ themeIds ) ) , 1 ) ; } return $ themes [ $ identifier ] ; }
4445	public function failed ( ) : array { $ results = json_decode ( $ this -> client -> failed ( ) , true ) ; return is_array ( $ results ) ? $ results : [ ] ; }
2945	public function removeRole ( $ role ) { if ( is_string ( $ role ) ) { return $ this -> roles ( ) -> detach ( Role :: where ( 'slug' , $ role ) -> first ( ) ) ; } return $ this -> roles ( ) -> detach ( $ role ) ; }
5814	public function validate ( ) { $ result = parent :: validate ( ) ; $ this -> Title = strtolower ( $ this -> Title ) ; if ( $ result -> valid ( ) && ! $ this -> Title ) { $ result -> error ( '"Title" required!' ) ; } else if ( $ result -> valid ( ) && FusionTag :: get_one ( 'FusionTag' , array ( 'ID != ?' => $ this -> ID , 'Title = ?' => $ this -> Title ) ) ) { $ result -> error ( 'Tag already exists!' ) ; } $ this -> extend ( 'validateFusionTag' , $ result ) ; return $ result ; }
12790	public static function createView ( string $ actionName , ? string $ ctrlName = null ) : ? View { $ viewsRoot = AppHelper :: getInstance ( ) -> getComponentRoot ( 'views' ) ; $ addPath = '' ; if ( ! empty ( $ ctrlName ) ) { $ addPath .= \ DIRECTORY_SEPARATOR . strtolower ( $ ctrlName ) ; } $ viewFile = $ viewsRoot . $ addPath . \ DIRECTORY_SEPARATOR . strtolower ( $ actionName ) . '.php' ; if ( is_readable ( $ viewFile ) ) { return new View ( $ viewFile ) ; } return null ; }
8325	public function deletePingback ( $ uri ) { $ response = $ this -> getHttpClient ( ) -> request ( 'GET' , "/res.php?key={$this->apiKey}&action=del_pingback&addr={$uri}" ) ; $ responseText = $ response -> getBody ( ) -> __toString ( ) ; if ( $ responseText === self :: STATUS_OK ) { return true ; } throw new ErrorResponseException ( $ this -> getErrorMessage ( $ responseText ) ? : $ responseText , $ this -> getErrorCode ( $ responseText ) ? : 0 ) ; }
2830	public function disableSqlProfilerAction ( ) { try { $ this -> getService ( ) -> setSqlProfilerStatus ( false ) ; $ this -> getService ( ) -> flushCache ( ) ; Mage :: getSingleton ( 'core/session' ) -> addSuccess ( 'SQL profiler was disabled.' ) ; } catch ( Exception $ e ) { Mage :: getSingleton ( 'core/session' ) -> addError ( 'Unable to disable SQL profiler: ' . $ e -> getMessage ( ) ) ; } $ this -> _redirectReferer ( ) ; }
7840	public function addNumber ( int $ id , string $ number ) : ? array { $ response = Request :: put ( $ this -> baseUrl . sprintf ( 'contact/%d/phone-number/%s' , $ id , $ number ) ) ; if ( $ response -> code != 200 ) { if ( ! empty ( $ response -> body -> message ) ) { Log :: error ( $ response -> body -> message ) ; } } return [ 'code' => $ response -> code , 'message' => ( $ response -> code == 200 ) ? 'OK' : $ response -> body -> message ?? '' , 'data' => $ response -> body , ] ; }
9783	public function parseExpression ( ) { $ token = $ this -> peek ( ) ; $ type = $ token [ 0 ] ; switch ( $ type ) { case 'IF_OPEN' : return $ this -> parseIf ( ) ; case 'FOR_OPEN' : return $ this -> parseFor ( ) ; case 'FILTERED_VALUE' : return $ this -> parseFilteredValue ( ) ; case 'VALUE' : return $ this -> parseValue ( ) ; case 'HTML' : return $ this -> parseHTML ( ) ; case 'ESCAPE' : return $ this -> parseEscape ( ) ; case 'INCLUDE' : return $ this -> parseInclude ( ) ; default : throw new SyntaxErrorException ( "Could not parse expression, invalid token '$type'" ) ; } }
12698	static function archiveDir ( $ sourcedir , $ archivefile , $ no_top_dir = false ) { $ archivefile = str_replace ( '\\' , '/' , $ archivefile ) ; $ sourcedir = str_replace ( '\\' , '/' , realpath ( $ sourcedir ) ) ; if ( $ no_top_dir ) { $ srcdir = '.' ; $ workdir = $ sourcedir ; } else { $ srcdir = basename ( $ sourcedir ) ; $ workdir = dirname ( $ sourcedir ) ; } $ archivedir = dirname ( $ archivefile ) ; $ extra = '' ; $ tar = self :: getTool ( 'tar' ) ; if ( substr ( $ archivefile , - 7 ) == '.tar.gz' || substr ( $ archivefile , - 4 ) == '.tgz' ) { $ cmd = "$tar -z -cvf" ; $ extra = "-C " . escapeshellarg ( $ workdir ) ; $ workdir = $ archivedir ; $ archivefile = basename ( $ archivefile ) ; } else if ( substr ( $ archivefile , - 8 ) == '.tar.bz2' ) { $ cmd = "$tar -j -cvf" ; $ extra = "-C " . escapeshellarg ( $ workdir ) ; $ workdir = $ archivedir ; $ archivefile = basename ( $ archivefile ) ; } else if ( substr ( $ archivefile , - 4 ) == '.tar' ) { $ cmd = "$tar -cvf" ; $ extra = "-C " . escapeshellarg ( $ workdir ) ; $ workdir = $ archivedir ; $ archivefile = basename ( $ archivefile ) ; } else if ( substr ( $ archivefile , - 4 ) == '.zip' ) { $ zip = self :: getTool ( 'zip' ) ; $ cmd = "$zip -9 -r" ; } else { throw new pakeException ( "Can not determine archive type from filename: $archivefile" ) ; } pake_sh ( self :: getCdCmd ( $ workdir ) . " && $cmd $archivefile $extra $srcdir" ) ; pake_echo_action ( 'file+' , $ archivefile ) ; }
5453	public function endElement ( $ name ) { if ( $ name === 'label' ) { $ this -> acceptLabelEnd ( ) ; return true ; } if ( $ name === 'form' ) { $ this -> acceptFormEnd ( ) ; return true ; } if ( $ name === 'frameset' ) { $ this -> acceptFramesetEnd ( ) ; return true ; } if ( $ this -> hasNamedTagOnOpenTagStack ( $ name ) ) { $ tag = array_pop ( $ this -> tags [ $ name ] ) ; if ( $ tag -> isPrivateContent ( ) && $ this -> private_content_tag -> getTagName ( ) == $ name ) { unset ( $ this -> private_content_tag ) ; } $ this -> addContentTagToOpenTags ( $ tag ) ; $ this -> acceptTag ( $ tag ) ; return true ; } return true ; }
3818	private function generateForm ( $ table , $ metaModel , Request $ request ) { $ fields = [ ] ; foreach ( $ metaModel -> getAttributes ( ) as $ attribute ) { $ attrId = $ attribute -> get ( 'id' ) ; if ( ! $ this -> accepts ( $ attribute ) ) { continue ; } if ( $ this -> knowsAttribute ( $ attribute ) ) { $ fields [ ] = [ 'checkbox' => false , 'text' => $ this -> checkboxCaption ( 'addAll_alreadycontained' , $ table , $ attribute ) , 'class' => 'tl_info' , 'attr_id' => $ attrId , 'name' => 'attribute_' . $ attrId ] ; continue ; } elseif ( $ this -> isAttributeSubmitted ( $ attrId , $ request ) ) { $ fields [ ] = array ( 'checkbox' => false , 'text' => $ this -> checkboxCaption ( 'addAll_addsuccess' , $ table , $ attribute ) , 'class' => 'tl_confirm' , 'attr_id' => $ attrId , 'name' => 'attribute_' . $ attrId ) ; continue ; } $ fields [ ] = [ 'checkbox' => true , 'text' => $ this -> checkboxCaption ( 'addAll_willadd' , $ table , $ attribute ) , 'class' => 'tl_new' , 'attr_id' => $ attrId , 'name' => 'attribute_' . $ attrId ] ; } return $ fields ; }
7013	private function format_m ( & $ str ) { if ( strstr ( $ str , '%m' ) ) $ str = str_replace ( '%m' , sprintf ( '%02d' , $ this -> month ) , $ str ) ; }
8773	public function registerCoreContainerAliases ( ) { Facade :: clearResolvedInstances ( ) ; Facade :: setApplication ( $ this ) ; foreach ( $ this -> registerCoreAliases as $ key => $ alias ) { $ this -> alias ( $ key , $ alias ) ; if ( ! class_exists ( $ key ) ) { class_alias ( $ alias , $ key ) ; } } }
8716	public static function createInLocale ( $ locale , array $ attributes = [ ] , $ translations = [ ] ) { $ model = ( new static ( $ attributes ) ) -> setLocale ( $ locale ) ; if ( $ model -> save ( ) && is_array ( $ translations ) ) { $ model -> saveTranslations ( $ translations ) ; } return $ model ; }
5970	public function accounts ( ) { if ( ! $ this -> accounts instanceof AccountsController ) { $ this -> accounts = new AccountsController ( $ this -> getClient ( ) , $ this -> cachePolicy , $ this -> cache ) ; $ this -> accounts -> setLogger ( $ this -> logger ) ; } return $ this -> accounts ; }
8228	protected function assertLimits ( ) { if ( $ this -> storage -> getUsersCount ( ) >= $ this -> config [ "maxUsers" ] ) { $ this -> session -> addFlash ( "error" , "New registrations are currently disabled." ) ; $ this -> picoAuth -> redirectToPage ( "register" ) ; } }
10995	public function write ( string $ contents , int $ opts = 0 ) : bool { if ( $ this -> prepareWrite ( ) !== true ) { $ this -> error = "failed to write '{$this->path}; {$this->error}" ; return false ; } return $ this -> writeFile ( $ contents , $ opts ) ; }
7360	private function getInStock ( SaleItemInterface $ item ) { if ( null === $ subject = $ this -> subjectHelper -> resolve ( $ item , false ) ) { return INF ; } if ( ! $ subject instanceof StockSubjectInterface ) { return INF ; } if ( $ subject -> isStockCompound ( ) ) { return INF ; } if ( $ subject -> getStockMode ( ) === StockSubjectModes :: MODE_DISABLED ) { return INF ; } return $ subject -> getInStock ( ) ; }
1801	protected function switchToEdit ( $ id ) { $ arrKeys = array ( ) ; $ arrUnset = array ( 'act' , 'id' , 'table' ) ; foreach ( array_keys ( $ _GET ) as $ strKey ) { if ( ! \ in_array ( $ strKey , $ arrUnset ) ) { $ arrKeys [ $ strKey ] = $ strKey . '=' . Input :: get ( $ strKey ) ; } } $ strUrl = TL_SCRIPT . '?' . implode ( '&' , $ arrKeys ) ; return $ strUrl . ( ! empty ( $ arrKeys ) ? '&' : '' ) . ( Input :: get ( 'table' ) ? 'table=' . Input :: get ( 'table' ) . '&amp;' : '' ) . 'act=edit&amp;id=' . rawurlencode ( $ id ) ; }
375	public function getActionArgsHelp ( $ action ) { $ method = $ this -> getActionMethodReflection ( $ action ) ; $ tags = $ this -> parseDocCommentTags ( $ method ) ; $ params = isset ( $ tags [ 'param' ] ) ? ( array ) $ tags [ 'param' ] : [ ] ; $ args = [ ] ; foreach ( $ method -> getParameters ( ) as $ i => $ reflection ) { if ( $ reflection -> getClass ( ) !== null ) { continue ; } $ name = $ reflection -> getName ( ) ; $ tag = isset ( $ params [ $ i ] ) ? $ params [ $ i ] : '' ; if ( preg_match ( '/^(\S+)\s+(\$\w+\s+)?(.*)/s' , $ tag , $ matches ) ) { $ type = $ matches [ 1 ] ; $ comment = $ matches [ 3 ] ; } else { $ type = null ; $ comment = $ tag ; } if ( $ reflection -> isDefaultValueAvailable ( ) ) { $ args [ $ name ] = [ 'required' => false , 'type' => $ type , 'default' => $ reflection -> getDefaultValue ( ) , 'comment' => $ comment , ] ; } else { $ args [ $ name ] = [ 'required' => true , 'type' => $ type , 'default' => null , 'comment' => $ comment , ] ; } } return $ args ; }
4670	protected function afterGeneration ( ) { $ this -> mapTemplate -> writeToFile ( ) ; $ this -> autoloadMap -> writeToFile ( ) ; $ responseParserTemplate = new ResponseParserTemplate ( $ this -> config ) ; $ this -> autoloadMap -> addEntry ( $ responseParserTemplate -> getClassName ( ) , $ responseParserTemplate -> getClassPath ( ) ) ; $ responseParserTemplate -> writeToFile ( ) ; }
4442	public function completed ( int $ offset = 0 , int $ count = 25 ) { return $ this -> client -> jobs ( 'complete' , null , $ offset , $ count ) ; }
10394	protected function transform ( DocumentInterface $ document , $ entity , $ skip = null ) { $ entityMethods = get_class_methods ( $ entity ) ; $ documentMethods = get_class_methods ( $ document ) ; if ( $ skip === null ) { $ skip = $ this -> getCopySkipFields ( ) ; } foreach ( $ entityMethods as $ method ) { if ( strpos ( $ method , 'get' ) !== 0 ) { continue ; } $ property = substr ( $ method , 3 ) ; if ( in_array ( lcfirst ( $ property ) , $ skip ) ) { continue ; } $ setter = 'set' . $ property ; if ( in_array ( $ setter , $ documentMethods ) ) { $ document -> { $ setter } ( $ entity -> { $ method } ( ) ) ; } } }
1559	protected function fillAttributes ( $ record , Collection $ attributes ) { $ record -> fill ( $ this -> deserializeAttributes ( $ attributes , $ record ) ) ; }
8913	protected function _set_where ( $ params ) { if ( count ( $ params ) == 1 ) { $ this -> _database -> where ( $ params [ 0 ] ) ; } else if ( count ( $ params ) == 2 ) { $ this -> _database -> where ( $ params [ 0 ] , $ params [ 1 ] ) ; } else if ( count ( $ params ) == 3 ) { $ this -> _database -> where ( $ params [ 0 ] , $ params [ 1 ] , $ params [ 2 ] ) ; } else { $ this -> _database -> where ( $ params ) ; } }
3994	public function buildWidget ( BuildWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ metaModel = $ this -> getMetaModelFromModel ( $ event -> getModel ( ) ) ; Helper :: prepareLanguageAwareWidget ( $ event -> getEnvironment ( ) , $ event -> getProperty ( ) , $ metaModel , $ event -> getEnvironment ( ) -> getTranslator ( ) -> translate ( 'name_langcode' , 'tl_metamodel_dcasetting' ) , $ event -> getEnvironment ( ) -> getTranslator ( ) -> translate ( 'name_value' , 'tl_metamodel_dcasetting' ) , false , StringUtil :: deserialize ( $ event -> getModel ( ) -> getProperty ( 'legendtitle' ) , true ) ) ; }
6246	public function files ( ? int $ constraints = null ) : \ Generator { foreach ( $ this -> all ( $ constraints ) as $ file ) { if ( ! $ file -> isDir ( ) ) { yield $ file ; } } }
8686	public static function remove ( & $ data , $ path , $ default = null ) { if ( ! static :: $ unsetMarker ) { static :: $ unsetMarker = new \ stdClass ( ) ; } $ value = static :: get ( $ data , $ path , static :: $ unsetMarker ) ; if ( $ value === static :: $ unsetMarker ) { return $ default ; } static :: set ( $ data , $ path , static :: $ unsetMarker ) ; return $ value ; }
10822	public static function block ( $ messages , $ style ) { if ( is_string ( $ messages ) ) { $ messages = [ $ messages ] ; } if ( count ( $ messages ) > 0 ) { self :: writeln ( str_repeat ( ' ' , self :: $ lineLength ) , $ style ) ; foreach ( $ messages as $ message ) { $ message = ' ' . $ message ; while ( strlen ( $ message ) < self :: $ lineLength ) { $ message .= ' ' ; } self :: writeln ( $ message , $ style ) ; } self :: writeln ( str_repeat ( ' ' , self :: $ lineLength ) , $ style ) ; } }
5825	public function encodeData ( ) { switch ( $ this -> encoding ) { case Request :: ENCODING_JSON : return json_encode ( $ this -> data ) ; break ; case Request :: ENCODING_RAW : return ( string ) $ this -> data ; break ; case Request :: ENCODING_QUERY : return http_build_query ( $ this -> data ) ; break ; default : throw new \ UnexpectedValueException ( "Encoding [$encoding] not a known Request::ENCODING_* constant" ) ; } }
5885	protected function renderDropdown ( ) { $ config = $ this -> dropdown ; $ config [ 'clientOptions' ] = false ; $ config [ 'view' ] = $ this -> getView ( ) ; return Dropdown :: widget ( $ config ) ; }
7315	public function setDateTime ( $ year , $ month , $ day , $ hour , $ min , $ sec ) { return $ this -> setDate ( $ year , $ month , $ day ) -> setTime ( $ hour , $ min , $ sec ) ; }
8449	public function contactAdd ( $ phoneNumber , $ firstName , $ lastName ) { $ phoneNumber = $ this -> formatPhoneNumber ( $ phoneNumber ) ; return $ this -> exec ( 'add_contact ' . $ phoneNumber . ' ' . $ this -> escapeStringArgument ( $ firstName ) . ' ' . $ this -> escapeStringArgument ( $ lastName ) ) ; }
2793	public function getCacheDirectory ( ) { if ( ! is_null ( $ this -> cacheDirectory ) ) { return $ this -> cacheDirectory ; } if ( defined ( 'PHP_WINDOWS_VERSION_MAJOR' ) ) { if ( ! getenv ( 'APPDATA' ) ) { throw new RuntimeException ( 'The APPDATA environment variable must be set for humbug.' ) ; } $ home = strtr ( getenv ( 'APPDATA' ) , '\\' , '/' ) . '/Humbug' ; } else { if ( ! getenv ( 'HOME' ) ) { throw new RuntimeException ( 'The HOME environment variable must be set for humbug.' ) ; } $ home = rtrim ( getenv ( 'HOME' ) , '/' ) . '/.humbug' ; } $ cache = $ home . '/cache' ; foreach ( [ $ home , $ cache ] as $ dir ) { if ( ! is_dir ( $ dir ) ) { mkdir ( $ dir , 0777 ) ; } } file_put_contents ( $ home . '/.htaccess' , 'Deny from all' ) ; $ this -> cacheDirectory = $ cache ; return $ cache ; }
6668	public function respond ( ) { if ( is_null ( $ this -> preparedResponse ) ) { $ this -> prepareResponse ( ) ; } if ( $ this -> status instanceof Status ) { header ( $ this -> status -> getHttpHeader ( ) ) ; } header ( "Content-Type: {$this->writer->getContentType()}" ) ; echo $ this -> preparedResponse ; return $ this ; }
5082	public function deleteRemap ( $ sMethod ) { $ oUri = Factory :: service ( 'Uri' ) ; $ sMethod = 'put' . ucfirst ( $ oUri -> segment ( 4 ) ) ; if ( method_exists ( $ this , $ sMethod ) ) { return $ this -> $ sMethod ( ) ; } $ oHttpCodes = Factory :: service ( 'HttpCodes' ) ; $ oItem = $ this -> lookUpResource ( ) ; if ( ! $ oItem ) { throw new ApiException ( 'Resource not found' , $ oHttpCodes :: STATUS_NOT_FOUND ) ; } $ this -> userCan ( static :: ACTION_DELETE , $ oItem ) ; if ( ! $ this -> oModel -> delete ( $ oItem -> id ) ) { throw new ApiException ( 'Failed to delete resource. ' . $ this -> oModel -> lastError ( ) , $ oHttpCodes :: STATUS_INTERNAL_SERVER_ERROR ) ; } return Factory :: factory ( 'ApiResponse' , 'nails/module-api' ) ; }
530	public function actionSortChangelog ( array $ what ) { if ( \ count ( $ what ) > 1 ) { $ this -> stdout ( "Currently only one simultaneous release is supported.\n" ) ; return 1 ; } $ this -> validateWhat ( $ what , [ 'framework' , 'ext' ] , false ) ; $ version = $ this -> version ? : array_values ( $ this -> getNextVersions ( $ this -> getCurrentVersions ( $ what ) , self :: PATCH ) ) [ 0 ] ; $ this -> stdout ( 'sorting CHANGELOG of ' ) ; $ this -> stdout ( reset ( $ what ) , Console :: BOLD ) ; $ this -> stdout ( ' for version ' ) ; $ this -> stdout ( $ version , Console :: BOLD ) ; $ this -> stdout ( '...' ) ; $ this -> resortChangelogs ( $ what , $ version ) ; $ this -> stdout ( "done.\n" , Console :: BOLD , Console :: FG_GREEN ) ; }
979	protected function response ( Request $ request , Closure $ next ) { $ response = $ next ( $ request ) ; if ( Config :: get ( 'shopify-app.esdk_enabled' ) && ( $ request -> ajax ( ) || $ request -> expectsJson ( ) || $ request -> isJson ( ) ) === false ) { if ( ( $ response instanceof BaseResponse ) === false ) { $ response = new Response ( $ response ) ; } $ response -> headers -> set ( 'P3P' , 'CP="Not used"' ) ; $ response -> headers -> remove ( 'X-Frame-Options' ) ; } return $ response ; }
12190	public function getActive ( ) { return ( isset ( $ this -> _child ) and $ this -> _child -> active ) and ( isset ( $ this -> _parent ) and $ this -> _parent -> active ) ; }
6809	public function currency ( float $ number , string $ currency = null ) : string { return $ this -> getCurrencyFormatter ( ) -> formatCurrency ( $ number , $ currency ? $ currency : $ this -> currency ) ; }
7201	public function getUnit ( bool $ ati = false ) : float { return $ ati ? $ this -> ati ( $ this -> unit ) : $ this -> unit ; }
11229	public function init ( ) { $ this -> pluginClient = new PluginClient ( $ this -> httpClient ? : HttpClientDiscovery :: find ( ) , $ this -> plugins ) ; $ this -> client = new HttpMethodsClient ( $ this -> pluginClient , $ this -> messageFactory ? : MessageFactoryDiscovery :: find ( ) ) ; }
6545	public function create ( $ name ) { $ sheet = $ this -> container -> createSheet ( ) ; $ sheet -> setTitle ( $ name ) ; return new \ Aimeos \ MW \ Container \ Content \ PHPExcel ( $ sheet , $ name , $ this -> getOptions ( ) ) ; }
11600	public function getConfig ( string $ sName = '' ) { if ( empty ( $ sName ) ) { return $ this -> configSet ; } elseif ( isset ( $ this -> configSet [ $ sName ] ) ) { return $ this -> configSet [ $ sName ] ; } else { return null ; } }
11584	public function exec ( $ calcId ) { $ result = [ ] ; $ bonusPercent = Cfg :: TEAM_BONUS_EU_PERCENT ; $ dwnlCompress = $ this -> daoBonDwnl -> getByCalcId ( $ calcId ) ; $ dwnlCurrent = $ this -> daoDwnl -> get ( ) ; $ mapDwnlById = $ this -> hlpDwnlTree -> mapById ( $ dwnlCompress , EBonDwnl :: A_CUST_REF ) ; $ mapCustById = $ this -> hlpDwnlTree -> mapById ( $ dwnlCurrent , ECustomer :: A_CUSTOMER_REF ) ; foreach ( $ mapDwnlById as $ custId => $ custDwnl ) { $ custData = $ mapCustById [ $ custId ] ; $ custMlmId = $ custData -> getMlmId ( ) ; $ pv = $ custDwnl -> getPv ( ) ; $ parentId = $ custDwnl -> getParentRef ( ) ; $ parentDwnl = $ mapDwnlById [ $ parentId ] ; $ parentData = $ mapCustById [ $ parentId ] ; $ parentMlmId = $ parentData -> getMlmId ( ) ; $ scheme = $ this -> hlpScheme -> getSchemeByCustomer ( $ parentData ) ; if ( $ scheme == Cfg :: SCHEMA_EU ) { $ pvParent = $ parentDwnl -> getPv ( ) ; if ( $ pvParent > ( Cfg :: PV_QUALIFICATION_LEVEL_EU - Cfg :: DEF_ZERO ) ) { $ bonus = $ this -> hlpFormat -> roundBonus ( $ pv * $ bonusPercent ) ; if ( $ bonus > Cfg :: DEF_ZERO ) { $ entry = new DBonus ( ) ; $ entry -> setCustomerRef ( $ parentId ) ; $ entry -> setDonatorRef ( $ custId ) ; $ entry -> setValue ( $ bonus ) ; $ result [ ] = $ entry ; } $ this -> logger -> debug ( "parent #$parentId (ref. #$parentMlmId) has '$bonus' as EU Team Bonus from downline customer #$custId (ref. #$custMlmId )." ) ; } else { $ this -> logger -> debug ( "parent #$parentId (ref. #$parentMlmId) does not qualified t oget EU Team Bonus from downline customer #$custId (ref. #$custMlmId )." ) ; } } else { $ this -> logger -> debug ( "Parent #$parentId (ref. #$parentMlmId) has incompatible scheme '$scheme' for EU Team Bonus." ) ; } } unset ( $ mapCustById ) ; unset ( $ mapDwnlById ) ; return $ result ; }
11145	protected function scanDir ( $ dir ) { $ result = array ( ) ; $ list = $ this -> scanDirExec ( $ dir ) ; foreach ( $ list as $ element ) { $ elementPath = $ dir . DIRECTORY_SEPARATOR . $ element ; if ( is_file ( $ elementPath ) ) { $ fileInfo = pathinfo ( $ element ) ; if ( in_array ( $ fileInfo [ 'extension' ] , $ this -> getAllowedFileExtensions ( ) ) ) { $ result [ ] = $ this -> getNameSpace ( ) . "\\" . $ fileInfo [ 'filename' ] ; } } } return $ result ; }
10474	public function lookupItem ( $ item_id ) { $ request = new ItemRequest ( $ item_id ) ; $ this -> emit ( 'request.item' , array ( $ item_id ) ) ; $ response = $ this -> post ( $ request ) ; return new ItemResponse ( $ response ) ; }
1754	public static function getLanguages ( $ blnInstalledOnly = false ) { $ return = array ( ) ; $ languages = array ( ) ; $ arrAux = array ( ) ; $ langsNative = array ( ) ; static :: loadLanguageFile ( 'languages' ) ; include __DIR__ . '/../../config/languages.php' ; foreach ( $ languages as $ strKey => $ strName ) { $ arrAux [ $ strKey ] = isset ( $ GLOBALS [ 'TL_LANG' ] [ 'LNG' ] [ $ strKey ] ) ? Utf8 :: toAscii ( $ GLOBALS [ 'TL_LANG' ] [ 'LNG' ] [ $ strKey ] ) : $ strName ; } asort ( $ arrAux ) ; $ arrBackendLanguages = self :: getContainer ( ) -> getParameter ( 'contao.locales' ) ; foreach ( array_keys ( $ arrAux ) as $ strKey ) { if ( $ blnInstalledOnly && ! \ in_array ( $ strKey , $ arrBackendLanguages ) ) { continue ; } $ return [ $ strKey ] = $ GLOBALS [ 'TL_LANG' ] [ 'LNG' ] [ $ strKey ] ?? $ languages [ $ strKey ] ; if ( isset ( $ langsNative [ $ strKey ] ) && $ langsNative [ $ strKey ] != $ return [ $ strKey ] ) { $ return [ $ strKey ] .= ' - ' . $ langsNative [ $ strKey ] ; } } if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getLanguages' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getLanguages' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getLanguages' ] as $ callback ) { static :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ return , $ languages , $ langsNative , $ blnInstalledOnly ) ; } } return $ return ; }
6494	private function rankAcceptMediaTypeHeaders ( array $ mediaTypeHeaders ) : array { usort ( $ mediaTypeHeaders , [ $ this , 'compareAcceptMediaTypeHeaders' ] ) ; $ rankedMediaTypeHeaders = array_filter ( $ mediaTypeHeaders , [ $ this , 'filterZeroScores' ] ) ; return array_values ( $ rankedMediaTypeHeaders ) ; }
1313	public function setRetries ( $ maxRetries , $ retriesDelay ) { $ this -> maxRetries = ( int ) $ maxRetries ; $ this -> retriesDelay = ( int ) $ retriesDelay ; }
3540	public static function getSyncOptions ( $ optionName , $ individualSyncOptions = null ) { if ( $ individualSyncOptions != null && is_array ( $ individualSyncOptions ) && array_key_exists ( $ optionName , $ individualSyncOptions ) ) { return $ individualSyncOptions [ $ optionName ] ; } else if ( isset ( Yii :: $ app -> params [ 'LDAP-User-Sync-Options' ] ) && is_array ( Yii :: $ app -> params [ 'LDAP-User-Sync-Options' ] ) && array_key_exists ( $ optionName , Yii :: $ app -> params [ 'LDAP-User-Sync-Options' ] ) ) { return Yii :: $ app -> params [ 'LDAP-User-Sync-Options' ] [ $ optionName ] ; } else if ( array_key_exists ( $ optionName , static :: SYNC_OPTIONS_TEMPLATE_WITHOUT_BACKEND_TASK ) ) { return static :: SYNC_OPTIONS_TEMPLATE_WITHOUT_BACKEND_TASK [ $ optionName ] ; } else { throw new \ yii \ base \ Exception ( 'Sync-option ' . $ optionName . ' not found. Please define settings in the config/params.php of the yii2 framework as described on top of the UserDbLdap.php' ) ; } }
2966	public function createRequest ( $ method , $ path , $ options ) { if ( $ this -> isPsr7Version ( ) ) { $ headers = [ 'Content-Type' => 'application/json' , 'Authorization' => 'Bearer ' . $ this -> getAccessToken ( ) , ] ; $ body = ArrayUtils :: get ( $ options , 'body' , null ) ; $ uri = UriResolver :: resolve ( new Uri ( $ this -> getBaseEndpoint ( ) . '/' ) , new Uri ( $ path ) ) ; if ( $ body ) { $ body = json_encode ( $ body ) ; } if ( ArrayUtils :: has ( $ options , 'query' ) ) { $ query = $ options [ 'query' ] ; if ( is_array ( $ query ) ) { $ query = http_build_query ( $ query , null , '&' , PHP_QUERY_RFC3986 ) ; } if ( ! is_string ( $ query ) ) { throw new \ InvalidArgumentException ( 'query must be a string or array' ) ; } $ uri = $ uri -> withQuery ( $ query ) ; } $ request = new Request ( $ method , $ uri , $ headers , $ body ) ; } else { $ options [ 'auth' ] = [ $ this -> accessToken , '' ] ; $ request = $ this -> httpClient -> createRequest ( $ method , $ path , $ options ) ; $ query = ArrayUtils :: get ( $ options , 'query' ) ; if ( $ query ) { $ q = $ request -> getQuery ( ) ; foreach ( $ query as $ key => $ value ) { $ q -> set ( $ key , $ value ) ; } } } return $ request ; }
1787	public function getActiveLayoutSections ( Contao \ DataContainer $ dc ) { if ( $ dc -> activeRecord -> pid ) { $ arrSections = array ( ) ; $ objPage = Contao \ PageModel :: findWithDetails ( $ dc -> activeRecord -> pid ) ; if ( $ objPage -> layout ) { $ objLayout = Contao \ LayoutModel :: findByPk ( $ objPage -> layout ) ; if ( $ objLayout === null ) { return array ( ) ; } $ arrModules = Contao \ StringUtil :: deserialize ( $ objLayout -> modules ) ; if ( empty ( $ arrModules ) || ! \ is_array ( $ arrModules ) ) { return array ( ) ; } foreach ( $ arrModules as $ arrModule ) { if ( $ arrModule [ 'mod' ] == 0 && $ arrModule [ 'enable' ] ) { $ arrSections [ ] = $ arrModule [ 'col' ] ; } } } } else { $ arrSections = array ( 'header' , 'left' , 'right' , 'main' , 'footer' ) ; $ objLayout = $ this -> Database -> query ( "SELECT sections FROM tl_layout WHERE sections!=''" ) ; while ( $ objLayout -> next ( ) ) { $ arrCustom = Contao \ StringUtil :: deserialize ( $ objLayout -> sections ) ; if ( ! empty ( $ arrCustom ) && \ is_array ( $ arrCustom ) ) { foreach ( $ arrCustom as $ v ) { if ( ! empty ( $ v [ 'id' ] ) ) { $ arrSections [ ] = $ v [ 'id' ] ; } } } } } return Contao \ Backend :: convertLayoutSectionIdsToAssociativeArray ( $ arrSections ) ; }
11357	public function add ( $ blockFile , $ blockContent ) { $ this -> removeBlock ( $ blockFile ) ; $ blockPermalinks = $ this -> fetchPermalinksFromBlock ( $ blockContent , $ blockFile ) ; if ( ! empty ( $ blockPermalinks ) ) { $ this -> permalinks = array_merge_recursive ( $ this -> permalinks , $ blockPermalinks ) ; } return $ this ; }
3612	public function setTargetTemperatureMode ( $ mode , $ temperature = NULL , $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; if ( $ temperature !== NULL ) { if ( $ mode == TARGET_TEMP_MODE_RANGE ) { if ( ! is_array ( $ temperature ) || count ( $ temperature ) != 2 || ! is_numeric ( $ temperature [ 0 ] ) || ! is_numeric ( $ temperature [ 1 ] ) ) { echo "Error: when using TARGET_TEMP_MODE_RANGE, you need to set the target temperatures (second argument of setTargetTemperatureMode) using an array of two numeric values.\n" ; return FALSE ; } $ temp_low = $ this -> temperatureInCelsius ( $ temperature [ 0 ] , $ serial_number ) ; $ temp_high = $ this -> temperatureInCelsius ( $ temperature [ 1 ] , $ serial_number ) ; $ data = json_encode ( array ( 'target_change_pending' => TRUE , 'target_temperature_low' => $ temp_low , 'target_temperature_high' => $ temp_high ) ) ; $ set_temp_result = $ this -> doPOST ( "/v2/put/shared." . $ serial_number , $ data ) ; } elseif ( $ mode != TARGET_TEMP_MODE_OFF ) { if ( ! is_numeric ( $ temperature ) ) { echo "Error: when using TARGET_TEMP_MODE_HEAT or TARGET_TEMP_MODE_COLD, you need to set the target temperature (second argument of setTargetTemperatureMode) using an numeric value.\n" ; return FALSE ; } $ temperature = $ this -> temperatureInCelsius ( $ temperature , $ serial_number ) ; $ data = json_encode ( array ( 'target_change_pending' => TRUE , 'target_temperature' => $ temperature ) ) ; $ set_temp_result = $ this -> doPOST ( "/v2/put/shared." . $ serial_number , $ data ) ; } } $ data = json_encode ( array ( 'target_change_pending' => TRUE , 'target_temperature_type' => $ mode ) ) ; return $ this -> doPOST ( "/v2/put/shared." . $ serial_number , $ data ) ; }
9240	public function renderLanguageSwitcher ( ) { return $ this -> _View -> element ( $ this -> config ( 'element' ) , [ 'availableLanguages' => $ this -> config ( 'availableLanguages' ) , 'displayNames' => $ this -> config ( 'displayNames' ) , 'imageMapping' => $ this -> config ( 'imageMapping' ) , 'renderToggleButtonDisplayName' => $ this -> config ( 'renderToggleButtonDisplayName' ) ] ) ; }
982	public function index ( Plan $ plan ) { if ( is_null ( $ plan ) || ( $ plan && ! $ plan -> exists ) ) { $ plan = Plan :: where ( 'on_install' , true ) -> first ( ) ; } $ bp = new BillingPlan ( ShopifyApp :: shop ( ) , $ plan ) ; $ url = $ bp -> confirmationUrl ( ) ; return View :: make ( 'shopify-app::billing.fullpage_redirect' , compact ( 'url' ) ) ; }
10884	public function report ( ErrorStreamReport $ report ) { $ report -> tags = $ this -> tags ; $ report -> context = $ this -> context ; return $ this -> makeRequest ( $ report ) ; }
6339	private function getDocumentStream ( $ xmlDocument ) { foreach ( $ this -> streamAdapters as $ streamAdapter ) { if ( $ streamAdapter -> supports ( $ xmlDocument ) ) { return $ streamAdapter -> convert ( $ xmlDocument ) ; } } throw new RuntimeException ( sprintf ( 'Suitable XML document stream adapter is not registered for XML document of type "%s".' , is_object ( $ xmlDocument ) ? get_class ( $ xmlDocument ) : gettype ( $ xmlDocument ) ) ) ; }
6960	public static function dt ( AstroDate $ dt ) { $ epoch = new static ( $ dt -> toTT ( ) -> toJD ( ) ) ; $ epoch -> dt = $ dt -> copy ( ) ; return $ epoch ; }
7843	private function callIfExists ( $ method , array $ parameters = [ ] ) { if ( method_exists ( $ this , $ method ) ) { $ this -> container -> call ( [ $ this , $ method ] , $ parameters ) ; } }
12067	public function fetchProjects ( ) { $ response = $ this -> getResponse ( 'get' , 'v2/projects' ) ; $ projects = array ( ) ; if ( is_array ( $ response ) ) { foreach ( $ response as $ data ) { $ projects [ ] = $ this -> hydrator -> hydrate ( new Project ( ) , $ data ) ; } } return $ projects ; }
7428	public function renderObject ( ) { if ( ! $ this -> isValid ( $ this -> source ) ) { throw new InvalidSourceExtensionException ( ) ; } return sprintf ( $ this -> objectDecorator , $ this -> width , $ this -> height , $ this -> source ) ; }
108	private function addExtension ( $ name , $ prettyVersion ) { $ extraDescription = null ; try { $ version = $ this -> versionParser -> normalize ( $ prettyVersion ) ; } catch ( \ UnexpectedValueException $ e ) { $ extraDescription = ' (actual version: ' . $ prettyVersion . ')' ; if ( preg_match ( '{^(\d+\.\d+\.\d+(?:\.\d+)?)}' , $ prettyVersion , $ match ) ) { $ prettyVersion = $ match [ 1 ] ; } else { $ prettyVersion = '0' ; } $ version = $ this -> versionParser -> normalize ( $ prettyVersion ) ; } $ packageName = $ this -> buildPackageName ( $ name ) ; $ ext = new CompletePackage ( $ packageName , $ version , $ prettyVersion ) ; $ ext -> setDescription ( 'The ' . $ name . ' PHP extension' . $ extraDescription ) ; $ this -> addPackage ( $ ext ) ; }
7747	private function findAdderAndRemover ( ) { $ reflClass = new \ ReflectionClass ( $ this -> class ) ; $ singulars = ( array ) StringUtil :: singularify ( $ this -> camelize ( $ this -> name ) ) ; foreach ( $ singulars as $ singular ) { $ addMethod = 'add' . $ singular ; $ removeMethod = 'remove' . $ singular ; $ addMethodFound = $ this -> isAccessible ( $ reflClass , $ addMethod , 1 ) ; $ removeMethodFound = $ this -> isAccessible ( $ reflClass , $ removeMethod , 1 ) ; if ( $ addMethodFound && $ removeMethodFound ) { $ this -> adderRemover = $ singular ; return ; } } }
5443	protected function invokeParser ( $ content , $ is_match ) { if ( ( $ content === '' ) || ( $ content === false ) ) { return true ; } $ handler = $ this -> mode_handlers [ $ this -> mode -> getCurrent ( ) ] ; return $ this -> parser -> $ handler ( $ content , $ is_match ) ; }
9808	private function readOPT ( ) { $ recInstance = ( 0xFFF0 & Xls :: getUInt2d ( $ this -> data , $ this -> pos ) ) >> 4 ; $ length = Xls :: getInt4d ( $ this -> data , $ this -> pos + 4 ) ; $ recordData = substr ( $ this -> data , $ this -> pos + 8 , $ length ) ; $ this -> pos += 8 + $ length ; $ this -> readOfficeArtRGFOPTE ( $ recordData , $ recInstance ) ; }
10516	protected function createPhotosCollection ( Product $ product , $ values ) { $ photos = new ArrayCollection ( ) ; $ identifiers = $ this -> getMediaIdentifiers ( $ values ) ; $ hierarchy = 0 ; foreach ( $ identifiers as $ id ) { $ media = $ this -> getMediaById ( $ id ) ; $ photo = $ this -> getProductPhoto ( $ media , $ product , $ values ) ; $ photo -> setHierarchy ( $ hierarchy ++ ) ; if ( ! $ photos -> contains ( $ photo ) ) { $ photos -> add ( $ photo ) ; } } return $ photos ; }
9617	public function registerSubscriber ( $ class , callable $ callback ) { $ service_id = "event." . strtolower ( str_replace ( "\\" , "." , $ class ) ) ; $ this [ $ service_id ] = $ callback ; $ this [ "dispatcher" ] -> addSubscriberService ( $ service_id , $ class ) ; }
12204	public function makeEmojiAccessible ( $ text ) { return preg_replace_callback ( $ this -> search , function ( $ matches ) { $ desc = $ this -> emoji [ $ this -> utf8ToUnicode ( $ matches [ 0 ] ) ] ; return sprintf ( $ this -> output , $ desc , $ matches [ 0 ] ) ; } , $ text ) ; }
3231	static function loadFromJsonFile ( $ path ) { if ( ! file_exists ( $ path ) ) { throw new AuthInfoLoadException ( "File doesn't exist: \"$path\"" ) ; } $ str = Util :: stripUtf8Bom ( file_get_contents ( $ path ) ) ; $ jsonArr = json_decode ( $ str , true , 10 ) ; if ( is_null ( $ jsonArr ) ) { throw new AuthInfoLoadException ( "JSON parse error: \"$path\"" ) ; } return self :: loadFromJson ( $ jsonArr ) ; }
811	private function fixSpaceBelowClassElement ( Tokens $ tokens , $ classEndIndex , $ elementEndIndex ) { for ( $ nextNotWhite = $ elementEndIndex + 1 ; ; ++ $ nextNotWhite ) { if ( ( $ tokens [ $ nextNotWhite ] -> isComment ( ) || $ tokens [ $ nextNotWhite ] -> isWhitespace ( ) ) && false === strpos ( $ tokens [ $ nextNotWhite ] -> getContent ( ) , "\n" ) ) { continue ; } break ; } if ( $ tokens [ $ nextNotWhite ] -> isWhitespace ( ) ) { $ nextNotWhite = $ tokens -> getNextNonWhitespace ( $ nextNotWhite ) ; } $ this -> correctLineBreaks ( $ tokens , $ elementEndIndex , $ nextNotWhite , $ nextNotWhite === $ classEndIndex ? 1 : 2 ) ; }
3414	public function fill ( $ fields ) { if ( ! is_array ( $ fields ) ) { return ; } if ( isset ( $ fields [ 'ID' ] ) ) { $ this -> id = $ fields [ 'ID' ] ; } $ this -> fields = $ fields ; $ this -> fieldsAreFetched = true ; if ( method_exists ( $ this , 'afterFill' ) ) { $ this -> afterFill ( ) ; } $ this -> original = $ this -> fields ; }
798	public function insertAt ( $ index , Token $ token ) { $ this -> setSize ( $ this -> getSize ( ) + 1 ) ; for ( $ i = $ this -> getSize ( ) - 1 ; $ i > $ index ; -- $ i ) { $ this [ $ i ] = isset ( $ this [ $ i - 1 ] ) ? $ this [ $ i - 1 ] : new Token ( ) ; } $ this [ $ index ] = $ token ; }
6238	public function write ( string $ content , bool $ append = false , int $ mode = LOCK_EX ) : self { $ this -> checkFileWritePermissions ( ) ; if ( ! $ this -> storage -> writeFile ( $ content , $ append , $ mode ) ) { throw new AccessDeniedException ( 'unable to write file-content' , 403 ) ; } return $ this ; }
10312	function getRecipientsCount ( $ fromDate = null , $ toDate = null , $ mailingIds = null , $ contactIds = null , $ contactEmails = null , $ contactExternalIds = null , $ excludeDeletedRecipients = false ) { $ params = $ this -> createCountQueryParameters ( $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , $ mailingIds , null ) ; if ( isset ( $ excludeDeletedRecipients ) ) $ params [ 'exclude_deleted_recipients' ] = ( $ excludeDeletedRecipients == true ) ? "true" : "false" ; return $ this -> get ( 'reports/recipients/count' , $ params ) ; }
6024	public function setMetadata ( array $ metadata ) { $ this -> metadata = [ ] ; foreach ( $ metadata as $ item ) { $ this -> addMetaData ( $ item ) ; } return $ this ; }
5979	public function propertysets ( ) { if ( ! $ this -> propertysets instanceof PropertysetsController ) { $ this -> propertysets = new PropertysetsController ( $ this -> getClient ( ) , $ this -> cachePolicy , $ this -> cache ) ; $ this -> propertysets -> setLogger ( $ this -> logger ) ; } return $ this -> propertysets ; }
8570	public function getLastUpdatedTimeForRecommendations ( $ request ) { if ( ! ( $ request instanceof MWSRecommendationsSectionService_Model_GetLastUpdatedTimeForRecommendationsRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/GetLastUpdatedTimeForRecommendationsRequest.php' ) ; $ request = new MWSRecommendationsSectionService_Model_GetLastUpdatedTimeForRecommendationsRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetLastUpdatedTimeForRecommendations' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/GetLastUpdatedTimeForRecommendationsResponse.php' ) ; $ response = MWSRecommendationsSectionService_Model_GetLastUpdatedTimeForRecommendationsResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
2172	private function purgeSymfonyCache ( ) : void { $ filesystem = new Filesystem ( ) ; $ cacheDir = $ this -> getContainerParameter ( 'kernel.cache_dir' ) ; $ ref = new \ ReflectionObject ( $ this -> container ) ; $ containerDir = basename ( \ dirname ( $ ref -> getFileName ( ) ) ) ; $ finder = Finder :: create ( ) -> depth ( 0 ) -> exclude ( $ containerDir ) -> in ( $ cacheDir ) ; foreach ( $ finder as $ file ) { $ filesystem -> remove ( $ file -> getPathname ( ) ) ; } if ( \ function_exists ( 'opcache_reset' ) ) { opcache_reset ( ) ; } if ( \ function_exists ( 'apc_clear_cache' ) && ! ini_get ( 'apc.stat' ) ) { apc_clear_cache ( ) ; } }
2509	protected function findBuilderForMessage ( $ messageName ) { $ builder = null ; if ( array_key_exists ( $ messageName , $ this -> messageBuilders ) && $ this -> messageBuilders [ $ messageName ] instanceof ConvertInterface ) { $ builder = $ this -> messageBuilders [ $ messageName ] ; } else { $ section = substr ( $ messageName , 0 , strpos ( $ messageName , '_' ) ) ; $ message = substr ( $ messageName , strpos ( $ messageName , '_' ) + 1 ) ; $ builderClass = __NAMESPACE__ . '\\Converter\\' . $ section . '\\' . $ message . "Conv" ; if ( class_exists ( $ builderClass ) ) { $ builder = new $ builderClass ( ) ; $ builder -> setParams ( $ this -> params ) ; $ this -> messageBuilders [ $ messageName ] = $ builder ; } } return $ builder ; }
6322	private function parseConfiguration ( array $ config ) { $ this -> currentEnvironment = 'dev' ; foreach ( $ config as $ environment => $ connection ) { if ( isset ( $ connection [ 'dsn' ] ) ) { $ this -> dsn [ $ environment ] = $ connection [ 'dsn' ] ; } else { $ this -> dsn [ $ environment ] = sprintf ( 'pgsql:host=%s; port=%s; dbname=%s;' , $ connection [ 'host' ] , $ connection [ 'port' ] , $ connection [ 'database' ] ) ; } $ this -> username [ $ environment ] = $ connection [ 'username' ] ; $ this -> password [ $ environment ] = $ connection [ 'password' ] ; } }
10868	public function getById ( int $ id ) { return $ this -> getList ( ) -> where ( [ $ this -> tableName [ 0 ] . '.' . self :: COLUMN_ID => $ id ] ) -> fetch ( ) ; }
5648	public function paintMethodEnd ( $ test_name ) { $ numberOfReporters = count ( $ this -> reporters ) ; for ( $ i = 0 ; $ i < $ numberOfReporters ; $ i ++ ) { $ this -> reporters [ $ i ] -> paintMethodEnd ( $ test_name ) ; } }
531	protected function splitChangelog ( $ file , $ version ) { $ lines = explode ( "\n" , file_get_contents ( $ file ) ) ; $ start = [ ] ; $ changelog = [ ] ; $ end = [ ] ; $ state = 'start' ; foreach ( $ lines as $ l => $ line ) { if ( isset ( $ lines [ $ l - 2 ] ) && strpos ( $ lines [ $ l - 2 ] , $ version ) !== false && isset ( $ lines [ $ l - 1 ] ) && strncmp ( $ lines [ $ l - 1 ] , '---' , 3 ) === 0 ) { $ state = 'changelog' ; } if ( $ state === 'changelog' && isset ( $ lines [ $ l + 1 ] ) && strncmp ( $ lines [ $ l + 1 ] , '---' , 3 ) === 0 ) { $ state = 'end' ; } if ( ! empty ( $ { $ state } ) && trim ( $ line ) !== '' && strncmp ( $ line , '- ' , 2 ) !== 0 ) { end ( $ { $ state } ) ; $ { $ state } [ key ( $ { $ state } ) ] .= "\n" . $ line ; } else { $ { $ state } [ ] = $ line ; } } return [ $ start , $ changelog , $ end ] ; }
3816	protected function render ( $ table , $ metaModel , Request $ request ) { $ fields = $ this -> generateForm ( $ table , $ metaModel , $ request ) ; return [ 'action' => '' , 'requestToken' => REQUEST_TOKEN , 'href' => $ this -> getReferer ( $ request , $ table , true ) , 'backBt' => $ this -> translator -> trans ( 'MSC.backBT' , [ ] , 'contao_default' ) , 'add' => $ this -> translator -> trans ( 'MSC.continue' , [ ] , 'contao_default' ) , 'saveNclose' => $ this -> translator -> trans ( 'MSC.saveNclose' , [ ] , 'contao_default' ) , 'activate' => $ this -> translator -> trans ( $ table . '.addAll_activate' , [ ] , 'contao_' . $ table ) , 'headline' => $ this -> translator -> trans ( $ table . '.addall.1' , [ ] , 'contao_' . $ table ) , 'selectAll' => $ this -> translator -> trans ( 'MSC.selectAll' , [ ] , 'contao_default' ) , 'cacheMessage' => '' , 'updateMessage' => '' , 'hasCheckbox' => count ( $ fields ) > 0 , 'fields' => $ fields , ] ; }
3054	public function persistSeenCatItemIds ( $ seenCatItemId ) { $ sessionId = $ this -> getTestSession ( ) -> getSessionId ( ) ; $ items = $ this -> getServiceManager ( ) -> get ( ExtendedStateService :: SERVICE_ID ) -> getCatValue ( $ sessionId , $ this -> getCatSection ( ) -> getSectionId ( ) , 'cat-seen-item-ids' ) ; if ( ! $ items ) { $ items = [ ] ; } else { $ items = json_decode ( $ items ) ; } if ( ! in_array ( $ seenCatItemId , $ items ) ) { $ items [ ] = $ seenCatItemId ; } $ this -> getServiceManager ( ) -> get ( ExtendedStateService :: SERVICE_ID ) -> setCatValue ( $ sessionId , $ this -> getCatSection ( ) -> getSectionId ( ) , 'cat-seen-item-ids' , json_encode ( $ items ) ) ; }
2545	protected function makeDomXpath ( $ response ) { $ domDoc = $ this -> loadDomDocument ( $ response ) ; $ domXpath = new \ DOMXPath ( $ domDoc ) ; $ domXpath -> registerNamespace ( self :: XMLNS_PREFIX , $ domDoc -> documentElement -> lookupNamespaceUri ( null ) ) ; return $ domXpath ; }
7959	public function getPairsNumber ( $ forceReload = false ) { if ( ! $ this -> properties || $ forceReload ) $ this -> getProperties ( ) ; return $ this -> properties -> pairsNumber ; }
9643	public static function getDriver ( MappingDriver $ originalDriver , $ namespace ) { if ( $ originalDriver instanceof MappingDriverChain ) { $ driver = new Driver \ Chain ( ) ; foreach ( $ originalDriver -> getDrivers ( ) as $ nestedNamespace => $ nestedDriver ) { $ driver -> addDriver ( static :: getDriver ( $ nestedDriver , $ namespace ) , $ nestedNamespace ) ; } if ( $ originalDriver -> getDefaultDriver ( ) !== null ) { $ driver -> setDefaultDriver ( static :: getDriver ( $ originalDriver -> getDefaultDriver ( ) , $ namespace ) ) ; } return $ driver ; } preg_match ( '/(?P<type>Xml|Yaml|Annotation)Driver$/' , get_class ( $ originalDriver ) , $ m ) ; $ type = isset ( $ m [ 'type' ] ) ? $ m [ 'type' ] : null ; $ driverClass = sprintf ( '%s\Mapping\Driver\%s' , $ namespace , $ type ) ; if ( ! $ type || ! class_exists ( $ driverClass ) ) { $ driverClass = sprintf ( '%s\Mapping\Driver\Annotation' , $ namespace ) ; if ( ! class_exists ( $ driverClass ) ) { throw new \ RuntimeException ( sprintf ( 'Failed to fallback to annotation driver: (%s), extension driver was not found.' , $ driverClass ) ) ; } } $ driver = new $ driverClass ( ) ; $ driver -> setOriginalDriver ( $ originalDriver ) ; if ( $ driver instanceof Driver \ File ) { $ driver -> setLocator ( $ originalDriver -> getLocator ( ) ) ; } elseif ( $ driver instanceof AnnotationDriverInterface ) { $ reader = static :: getAnnotationReader ( ) ; $ driver -> setAnnotationReader ( $ reader ) ; } return $ driver ; }
318	public function registerCssFile ( $ url , $ options = [ ] , $ key = null ) { $ url = Yii :: getAlias ( $ url ) ; $ key = $ key ? : $ url ; $ depends = ArrayHelper :: remove ( $ options , 'depends' , [ ] ) ; if ( empty ( $ depends ) ) { $ this -> cssFiles [ $ key ] = Html :: cssFile ( $ url , $ options ) ; } else { $ this -> getAssetManager ( ) -> bundles [ $ key ] = Yii :: createObject ( [ 'class' => AssetBundle :: className ( ) , 'baseUrl' => '' , 'css' => [ strncmp ( $ url , '//' , 2 ) === 0 ? $ url : ltrim ( $ url , '/' ) ] , 'cssOptions' => $ options , 'depends' => ( array ) $ depends , ] ) ; $ this -> registerAssetBundle ( $ key ) ; } }
2052	public static function create ( $ file , $ size = null ) { if ( \ is_string ( $ file ) ) { $ file = new File ( rawurldecode ( $ file ) ) ; } $ imageSize = null ; $ picture = new static ( $ file ) ; if ( \ is_array ( $ size ) && ! empty ( $ size [ 2 ] ) && is_numeric ( $ size [ 2 ] ) ) { $ size = ( int ) $ size [ 2 ] ; } $ imageSize = null ; if ( ! \ is_array ( $ size ) ) { $ imageSize = ImageSizeModel :: findByPk ( $ size ) ; if ( $ imageSize === null ) { $ size = array ( ) ; } } if ( \ is_array ( $ size ) ) { $ size += array ( 0 , 0 , 'crop' ) ; $ imageSize = new \ stdClass ( ) ; $ imageSize -> width = $ size [ 0 ] ; $ imageSize -> height = $ size [ 1 ] ; $ imageSize -> resizeMode = $ size [ 2 ] ; $ imageSize -> zoom = 0 ; } $ picture -> setImageSize ( $ imageSize ) ; if ( $ imageSize !== null && ! empty ( $ imageSize -> id ) ) { $ picture -> setImageSizeItems ( ImageSizeItemModel :: findVisibleByPid ( $ imageSize -> id , array ( 'order' => 'sorting ASC' ) ) ) ; } $ fileRecord = FilesModel :: findByPath ( $ file -> path ) ; if ( $ fileRecord !== null && $ fileRecord -> importantPartWidth && $ fileRecord -> importantPartHeight ) { $ picture -> setImportantPart ( array ( 'x' => ( int ) $ fileRecord -> importantPartX , 'y' => ( int ) $ fileRecord -> importantPartY , 'width' => ( int ) $ fileRecord -> importantPartWidth , 'height' => ( int ) $ fileRecord -> importantPartHeight , ) ) ; } return $ picture ; }
12172	public static function getDefaultForCallable ( $ callable , array $ params = array ( ) ) { if ( $ callable instanceof Closure ) { $ factory = new static ( $ callable , 'closure' ) ; $ factory -> addOptionalClassArgument ( '$container' , 'Autarky\Container\ContainerInterface' ) ; return $ factory -> getFactory ( $ params ) ; } return static :: getFromReflection ( $ callable , null ) -> getFactory ( $ params ) ; }
7801	protected function splitTransactions ( $ text ) { $ offset = 0 ; $ length = 0 ; $ position = 0 ; $ transactions = array ( ) ; while ( $ line = $ this -> getLine ( '61' , $ text , $ offset , $ offset , $ length ) ) { $ offset += 4 + $ length + 2 ; $ transaction = array ( $ line ) ; $ description = array ( ) ; while ( $ line = $ this -> getLine ( '86' , $ text , $ offset , $ position , $ length ) ) { if ( $ position == $ offset ) { $ offset += 4 + $ length + 2 ; $ description [ ] = $ line ; } else { break ; } } if ( $ description ) { $ transaction [ ] = implode ( "\r\n" , $ description ) ; } $ transactions [ ] = $ transaction ; } return $ transactions ; }
11727	public function setTaxonomy_id ( $ value ) { if ( ! is_array ( $ value ) ) { $ value = [ $ value ] ; } foreach ( $ value as $ k => $ v ) { if ( is_object ( $ v ) ) { $ value [ $ k ] = $ v -> primaryKey ; } elseif ( is_array ( $ v ) ) { unset ( $ value [ $ k ] ) ; if ( isset ( $ v [ 'systemId' ] ) && isset ( $ v [ 'taxonomyType' ] ) ) { $ taxonomyType = Yii :: $ app -> collectors [ 'taxonomies' ] -> getOne ( $ v [ 'taxonomyType' ] ) ; if ( isset ( $ taxonomyType ) && ( $ taxonomy = $ taxonomyType -> getTaxonomy ( $ v [ 'systemId' ] ) ) ) { $ value [ $ k ] = $ taxonomy -> primaryKey ; } } } } $ this -> _taxonomy_id = $ value ; }
1937	private function convertValueToPath ( string $ value ) : string { $ filesAdapter = $ this -> framework -> getAdapter ( FilesModel :: class ) ; if ( Validator :: isUuid ( $ value ) && ( $ filesModel = $ filesAdapter -> findByUuid ( $ value ) ) instanceof FilesModel ) { return $ filesModel -> path ; } return $ value ; }
8505	public function createInboundShipment ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_CreateInboundShipmentRequest ) ) { $ request = new FBAInboundServiceMWS_Model_CreateInboundShipmentRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'CreateInboundShipment' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_CreateInboundShipmentResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
311	private function applyTableAlias ( $ query , $ conditions , $ alias = null ) { if ( $ alias === null ) { $ alias = array_keys ( $ query -> getTablesUsedInFrom ( ) ) [ 0 ] ; } $ prefixedConditions = [ ] ; foreach ( $ conditions as $ columnName => $ columnValue ) { if ( strpos ( $ columnName , '(' ) === false ) { $ columnName = preg_replace ( '/^' . preg_quote ( $ alias ) . '\.(.*)$/' , '$1' , $ columnName ) ; if ( strpos ( $ columnName , '[[' ) === 0 ) { $ prefixedColumn = "{$alias}.{$columnName}" ; } else { $ prefixedColumn = "{$alias}.[[{$columnName}]]" ; } } else { $ prefixedColumn = $ columnName ; } $ prefixedConditions [ $ prefixedColumn ] = $ columnValue ; } return $ prefixedConditions ; }
4018	protected function initializeWidget ( & $ arrField , $ strRow , $ strKey , $ varValue ) { $ xlabel = $ this -> getHelpWizard ( $ strKey , $ arrField ) ; if ( isset ( $ arrField [ 'input_field_callback' ] ) && is_array ( $ arrField [ 'input_field_callback' ] ) ) { if ( ! is_object ( $ this -> $ arrField [ 'input_field_callback' ] [ 0 ] ) ) { $ this -> import ( $ arrField [ 'input_field_callback' ] [ 0 ] ) ; } return $ this -> { $ arrField [ 'input_field_callback' ] [ 0 ] } -> $ arrField [ 'input_field_callback' ] [ 1 ] ( $ this , $ xlabel ) ; } $ strClass = $ this -> getWidgetClass ( $ arrField ) ; if ( empty ( $ strClass ) ) { return null ; } $ varValue = $ this -> handleLoadCallback ( $ arrField , $ varValue ) ; $ arrField = $ this -> makeMandatory ( $ arrField , $ strRow , $ strKey ) ; $ arrField [ 'name' ] = $ this -> strName . '[' . $ strRow . '][' . $ strKey . ']' ; $ arrField [ 'id' ] = $ this -> strId . '_' . $ strRow . '_' . $ strKey ; $ arrField [ 'value' ] = ( $ varValue !== '' ) ? $ varValue : $ arrField [ 'default' ] ; $ arrField [ 'eval' ] [ 'tableless' ] = true ; $ event = new GetAttributesFromDcaEvent ( $ arrField , $ arrField [ 'name' ] , $ arrField [ 'value' ] , null , $ this -> strTable , $ this -> objDca ) ; $ this -> getEventDispatcher ( ) -> dispatch ( ContaoEvents :: WIDGET_GET_ATTRIBUTES_FROM_DCA , $ event ) ; $ objWidget = new $ strClass ( $ event -> getResult ( ) ) ; $ objWidget -> strId = $ arrField [ 'id' ] ; $ objWidget -> storeValues = true ; $ objWidget -> xlabel = $ xlabel ; return $ objWidget ; }
7751	protected function loadMetadata ( $ className ) { if ( false === isset ( $ this -> loadedMetadata [ $ className ] ) ) { if ( null === ( $ class = $ this -> driver -> loadMetadataForClass ( $ className ) ) ) { throw new \ Exception ( "Can't load metadata for $className" ) ; } $ this -> completeMetadata ( $ class ) ; $ this -> loadedMetadata [ $ className ] = $ class ; } return $ this -> loadedMetadata [ $ className ] ; }
2579	protected function loadCustomerRefs ( $ dkNumber ) { if ( ! is_null ( $ dkNumber ) ) { $ this -> customerRef = new MasterPricer \ CustomerRef ( ) ; $ this -> customerRef -> customerReferences [ ] = new MasterPricer \ CustomerReferences ( $ dkNumber , MasterPricer \ CustomerReferences :: QUAL_AGENCY_GROUPING_ID ) ; } }
6253	protected function normalizeAclPresence ( $ data ) { if ( $ data instanceof AclPresenceInterface ) { $ data = [ $ data ] ; } elseif ( is_array ( $ data ) && ! Arr :: isAssoc ( $ data ) ) { $ presences = [ ] ; foreach ( $ data as $ nestedData ) { if ( is_string ( $ nestedData ) ) { $ presences [ ] = $ nestedData ; } else { $ presences [ ] = new AclPresence ( $ nestedData ) ; } } $ data = $ presences ; } else { $ data = [ new AclPresence ( $ data ) ] ; } return $ data ; }
6212	protected function array2Node ( $ parentNode , $ key , $ params ) { if ( count ( $ params ) == 0 ) { return ; } $ node = $ parentNode -> addChild ( $ key ) ; foreach ( $ params as $ key => $ value ) { if ( is_array ( $ value ) || is_object ( $ value ) ) { $ value = json_encode ( ( array ) $ value ) ; } $ node -> addChild ( 'var' , htmlspecialchars ( $ value ) ) -> addAttribute ( 'key' , $ key ) ; } }
6726	public function get_movie_votes ( $ post_id ) { $ votes = get_post_meta ( $ post_id , 'imdbTotalVotes' , true ) ; if ( ! empty ( $ votes ) ) { return json_decode ( $ votes , true ) ; } return false ; }
1084	private function expectKeyword ( $ value ) { $ token = $ this -> lexer -> token ; if ( $ token -> kind === Token :: NAME && $ token -> value === $ value ) { $ this -> lexer -> advance ( ) ; return $ token ; } throw new SyntaxError ( $ this -> lexer -> source , $ token -> start , 'Expected "' . $ value . '", found ' . $ token -> getDescription ( ) ) ; }
11903	public function getDescriptor ( ) { $ logModel = $ this -> getLogModel ( true ) ; if ( empty ( $ logModel ) || ! isset ( $ logModel -> dataInterface ) ) { return 'Unknown Data Interface' ; } return 'Interface: ' . $ logModel -> dataInterface -> name ; }
9601	public function add ( self $ b ) { $ this -> _checkVectorSpace ( $ b ) ; $ bComponents = $ b -> components ( ) ; $ sum = [ ] ; foreach ( $ this -> components ( ) as $ i => $ component ) { $ sum [ $ i ] = $ component + $ bComponents [ $ i ] ; } return new static ( $ sum ) ; }
7991	public function setSshKey ( $ pp , $ pca , $ key ) { if ( ! $ pp ) throw new BadMethodCallException ( 'Missing parameter $pp (OVH cloud passport).' ) ; if ( ! $ pca ) throw new BadMethodCallException ( 'Missing parameter $pca (PCA ServiceName).' ) ; if ( ! $ key ) throw new BadMethodCallException ( 'Missing parameter $key (Public key for this pca).' ) ; $ payload = array ( 'sshkey' => $ key ) ; try { $ this -> put ( 'cloud/' . $ pp . '/pca/' . $ pca , array ( 'Content-Type' => 'application/json;charset=UTF-8' ) , json_encode ( $ payload ) ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new CloudException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } }
4819	public function getIterator ( IteratorFilter $ itf = null ) { if ( is_null ( $ itf ) ) { return new AnyIterator ( $ this -> collection ) ; } return new AnyIterator ( $ itf -> match ( $ this -> collection ) ) ; }
1139	public function shiftSiblingsForRestore ( ) { if ( is_null ( $ this -> getRight ( ) ) || is_null ( $ this -> getLeft ( ) ) ) return ; $ self = $ this ; $ this -> getConnection ( ) -> transaction ( function ( ) use ( $ self ) { $ lftCol = $ self -> getLeftColumnName ( ) ; $ rgtCol = $ self -> getRightColumnName ( ) ; $ lft = $ self -> getLeft ( ) ; $ rgt = $ self -> getRight ( ) ; $ diff = $ rgt - $ lft + 1 ; $ self -> newNestedSetQuery ( ) -> where ( $ lftCol , '>=' , $ lft ) -> increment ( $ lftCol , $ diff ) ; $ self -> newNestedSetQuery ( ) -> where ( $ rgtCol , '>=' , $ lft ) -> increment ( $ rgtCol , $ diff ) ; } ) ; }
11710	public function actionConfirm ( $ id , $ back = 'index' ) { $ this -> findModel ( $ id ) -> confirm ( ) ; \ Yii :: $ app -> getSession ( ) -> setFlash ( 'success' , \ Yii :: t ( 'user' , 'User has been confirmed' ) ) ; $ url = $ back == 'index' ? [ 'index' ] : [ 'update' , 'id' => $ id ] ; return $ this -> redirect ( $ url ) ; }
9757	function below ( $ value ) : self { $ target = $ this -> hasFlag ( 'length' ) ? $ this -> getLength ( $ this -> target ) : $ this -> target ; return $ this -> expect ( $ target , lessThan ( $ value ) ) ; }
4741	private function createProfilerProbes ( $ name , ContainerBuilder $ container ) { $ key = sprintf ( "socloz_monitoring.profiler.probe.definition.%s" , $ name ) ; if ( $ container -> hasParameter ( $ key ) ) { $ definition = $ container -> getParameter ( $ key ) ; return array ( $ this -> createProbeDefinition ( $ name , Probe :: TRACKER_CALLS | Probe :: TRACKER_TIMING , $ definition , $ container ) ) ; } else { return array ( $ this -> createProbeDefinition ( $ name , Probe :: TRACKER_CALLS , $ container -> getParameter ( $ key . '.calls' ) , $ container ) , $ this -> createProbeDefinition ( $ name , Probe :: TRACKER_TIMING , $ container -> getParameter ( $ key . '.timing' ) , $ container ) , ) ; } }
10113	private function writeSetup ( ) { $ record = 0x00A1 ; $ length = 0x0022 ; $ iPaperSize = $ this -> phpSheet -> getPageSetup ( ) -> getPaperSize ( ) ; $ iScale = $ this -> phpSheet -> getPageSetup ( ) -> getScale ( ) ? $ this -> phpSheet -> getPageSetup ( ) -> getScale ( ) : 100 ; $ iPageStart = 0x01 ; $ iFitWidth = ( int ) $ this -> phpSheet -> getPageSetup ( ) -> getFitToWidth ( ) ; $ iFitHeight = ( int ) $ this -> phpSheet -> getPageSetup ( ) -> getFitToHeight ( ) ; $ grbit = 0x00 ; $ iRes = 0x0258 ; $ iVRes = 0x0258 ; $ numHdr = $ this -> phpSheet -> getPageMargins ( ) -> getHeader ( ) ; $ numFtr = $ this -> phpSheet -> getPageMargins ( ) -> getFooter ( ) ; $ iCopies = 0x01 ; $ fLeftToRight = 0x0 ; $ fLandscape = ( $ this -> phpSheet -> getPageSetup ( ) -> getOrientation ( ) == PageSetup :: ORIENTATION_LANDSCAPE ) ? 0x0 : 0x1 ; $ fNoPls = 0x0 ; $ fNoColor = 0x0 ; $ fDraft = 0x0 ; $ fNotes = 0x0 ; $ fNoOrient = 0x0 ; $ fUsePage = 0x0 ; $ grbit = $ fLeftToRight ; $ grbit |= $ fLandscape << 1 ; $ grbit |= $ fNoPls << 2 ; $ grbit |= $ fNoColor << 3 ; $ grbit |= $ fDraft << 4 ; $ grbit |= $ fNotes << 5 ; $ grbit |= $ fNoOrient << 6 ; $ grbit |= $ fUsePage << 7 ; $ numHdr = pack ( 'd' , $ numHdr ) ; $ numFtr = pack ( 'd' , $ numFtr ) ; if ( self :: getByteOrder ( ) ) { $ numHdr = strrev ( $ numHdr ) ; $ numFtr = strrev ( $ numFtr ) ; } $ header = pack ( 'vv' , $ record , $ length ) ; $ data1 = pack ( 'vvvvvvvv' , $ iPaperSize , $ iScale , $ iPageStart , $ iFitWidth , $ iFitHeight , $ grbit , $ iRes , $ iVRes ) ; $ data2 = $ numHdr . $ numFtr ; $ data3 = pack ( 'v' , $ iCopies ) ; $ this -> append ( $ header . $ data1 . $ data2 . $ data3 ) ; }
144	public function insert ( RuleWatchNode $ node ) { if ( $ node -> getRule ( ) -> isAssertion ( ) ) { return ; } foreach ( array ( $ node -> watch1 , $ node -> watch2 ) as $ literal ) { if ( ! isset ( $ this -> watchChains [ $ literal ] ) ) { $ this -> watchChains [ $ literal ] = new RuleWatchChain ; } $ this -> watchChains [ $ literal ] -> unshift ( $ node ) ; } }
3448	public function getAttribute ( $ key ) { if ( in_array ( $ key , $ this -> multipleHighloadBlockFields ) ) { return unserialize ( $ this -> attributes [ $ key ] ) ; } return parent :: getAttribute ( $ key ) ; }
4112	public function searchFullPath ( $ filename ) { $ paths = explode ( PATH_SEPARATOR , get_include_path ( ) ) ; foreach ( $ paths as $ path ) { $ fullPath = $ path . DIRECTORY_SEPARATOR . $ filename ; if ( file_exists ( $ fullPath ) ) { return $ fullPath ; } } return false ; }
7475	private function configureEmailHelper ( ContainerBuilder $ container ) { if ( ! class_exists ( 'Swift_Mailer' ) ) { $ definition = $ container -> getDefinition ( 'orkestra.application.helper.email' ) ; $ definition -> setClass ( 'Orkestra\Bundle\ApplicationBundle\Helper\EmailHelper\MisconfiguredEmailHelper' ) ; $ definition -> setArguments ( array ( ) ) ; } }
10193	public static function getQueryPreview ( QueryBuilder $ query = null ) { if ( empty ( $ query ) ) { return "" ; } $ sql = str_replace ( '?' , "'%s'" , $ query -> toSql ( ) ) ; $ bindings = $ query -> getBindings ( ) ; return vsprintf ( $ sql , $ bindings ) ; }
12450	static function run_check_templates ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { $ opts = self :: getOpts ( @ $ args [ 0 ] , @ $ args [ 1 ] , $ cliopts ) ; if ( ! SharedLock :: acquire ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ) throw new PakeException ( "Source code locked by another process" ) ; $ destdir = self :: getBuildDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ; $ files = pakeFinder :: type ( 'file' ) -> name ( array ( '*.tpl' ) ) -> maxdepth ( 0 ) -> in ( $ destdir ) ; if ( count ( $ files ) ) { $ php = self :: getTool ( 'php' , $ opts ) ; if ( strpos ( pake_sh ( $ php . " -v" ) , 'PHP' ) === false ) { SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; throw new pakeException ( "$php does not seem to be a valid php executable" ) ; } $ ezp = @ $ opts [ 'ezublish' ] [ 'install_dir_LS' ] ; if ( $ ezp == '' ) { $ ezp = '../..' ; } if ( ! file_exists ( $ ezp . '/bin/php/eztemplatecheck.php' ) ) { SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; throw new pakeException ( "$ezp does not seem to be a valid eZ Publish install" ) ; } $ rootpath = pakeFinder :: type ( 'directory' ) -> name ( $ opts [ 'extension' ] [ 'name' ] ) -> in ( self :: getBuildDir ( $ opts ) ) ; $ rootpath = dirname ( $ rootpath [ 0 ] ) ; $ out = pake_sh ( "cd " . escapeshellarg ( $ ezp ) . " && " . escapeshellarg ( $ php ) . " bin/php/eztemplatecheck.php " . escapeshellarg ( $ rootpath ) ) ; if ( strpos ( $ out , 'Some templates did not validate' ) !== false ) { SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; throw new pakeException ( $ out ) ; } } SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; }
8281	public function onTwigRegistered ( & $ twig ) { $ twig -> getLoader ( ) -> addPath ( $ this -> pluginDir . '/theme' ) ; $ this_instance = $ this ; $ twig -> addFunction ( new \ Twig_SimpleFunction ( 'csrf_token' , function ( $ action = null ) use ( & $ this_instance ) { return $ this_instance -> csrf -> getToken ( $ action ) ; } , array ( 'is_safe' => array ( 'html' ) ) ) ) ; $ twig -> addFunction ( new \ Twig_SimpleFunction ( 'csrf_field' , function ( $ action = null ) use ( & $ this_instance ) { return '<input type="hidden" name="csrf_token" value="' . $ this_instance -> csrf -> getToken ( $ action ) . '">' ; } , array ( 'is_safe' => array ( 'html' ) ) ) ) ; }
2205	public static function findPost ( $ strKey ) { if ( isset ( $ _POST [ $ strKey ] ) ) { return $ _POST [ $ strKey ] ; } $ request = System :: getContainer ( ) -> get ( 'request_stack' ) -> getMasterRequest ( ) ; if ( $ request === null || ! $ request -> hasPreviousSession ( ) ) { return null ; } if ( isset ( $ _SESSION [ 'FORM_DATA' ] [ $ strKey ] ) ) { return ( $ strKey == 'FORM_SUBMIT' ) ? preg_replace ( '/^auto_/i' , '' , $ _SESSION [ 'FORM_DATA' ] [ $ strKey ] ) : $ _SESSION [ 'FORM_DATA' ] [ $ strKey ] ; } return null ; }
2158	public function run292Update ( ) { $ this -> Database -> query ( "ALTER TABLE `tl_calendar_events` CHANGE `startTime` `startTime` int(10) unsigned NULL" ) ; $ this -> Database -> query ( "ALTER TABLE `tl_calendar_events` CHANGE `endTime` `endTime` int(10) unsigned NULL" ) ; $ this -> Database -> query ( "ALTER TABLE `tl_calendar_events` CHANGE `startDate` `startDate` int(10) unsigned NULL" ) ; $ this -> Database -> query ( "ALTER TABLE `tl_calendar_events` CHANGE `endDate` `endDate` int(10) unsigned NULL" ) ; $ this -> Database -> query ( "UPDATE tl_calendar_events SET endDate=null WHERE endDate=0" ) ; }
6283	protected static function buildHttpClient04 ( LoopInterface $ loop , $ dns = null ) { if ( null === $ dns ) { $ dns = static :: buildDnsResolver ( $ loop ) ; } if ( ! $ dns instanceof DnsResolver ) { throw new \ InvalidArgumentException ( 'For react http client v0.4, $dns must be an instance of DnsResolver' ) ; } $ factory = new HttpClientFactory ( ) ; return $ factory -> create ( $ loop , $ dns ) ; }
6648	public function create_tables ( ) { global $ wpdb ; $ charset_collate = $ wpdb -> get_charset_collate ( ) ; $ table_name = $ wpdb -> prefix . 'efg_custom_rating' ; if ( $ wpdb -> get_var ( "SHOW TABLES LIKE '$table_name'" ) != $ table_name ) { $ sql = "CREATE TABLE $table_name ( id mediumint(9) NOT NULL AUTO_INCREMENT, post_id mediumint(9) NOT NULL, ip varchar(45) NOT NULL, vote int(2) NOT NULL, PRIMARY KEY (id) ) $charset_collate;" ; require_once ( ABSPATH . 'wp-admin/includes/upgrade.php' ) ; dbDelta ( $ sql ) ; } }
4920	public function setForm ( $ key , $ spec , $ enabled = true ) { if ( is_object ( $ spec ) ) { if ( ! $ spec instanceof Container ) { throw new \ InvalidArgumentException ( 'Tab container must be of the type \Core\Form\Container' ) ; } if ( ! $ spec -> getLabel ( ) ) { throw new \ InvalidArgumentException ( 'Container instances must have a label.' ) ; } } if ( is_array ( $ spec ) ) { if ( ! isset ( $ spec [ 'type' ] ) ) { $ spec [ 'type' ] = 'Core/Container' ; } if ( ! isset ( $ spec [ 'options' ] [ 'forms' ] ) && isset ( $ spec [ 'forms' ] ) ) { $ spec [ 'options' ] [ 'forms' ] = $ spec [ 'forms' ] ; unset ( $ spec [ 'forms' ] ) ; } } return parent :: setForm ( $ key , $ spec , $ enabled ) ; }
5707	public function getButtonLink ( ) { $ link = Controller :: join_links ( 'customaction' , $ this -> actionName ) ; return $ this -> gridFieldRequest -> Link ( $ link ) ; }
1078	public static function executeQuery ( SchemaType $ schema , $ source , $ rootValue = null , $ context = null , $ variableValues = null , ? string $ operationName = null , ? callable $ fieldResolver = null , ? array $ validationRules = null ) : ExecutionResult { $ promiseAdapter = new SyncPromiseAdapter ( ) ; $ promise = self :: promiseToExecute ( $ promiseAdapter , $ schema , $ source , $ rootValue , $ context , $ variableValues , $ operationName , $ fieldResolver , $ validationRules ) ; return $ promiseAdapter -> wait ( $ promise ) ; }
8163	static public function register ( ) { if ( static :: $ registered === true ) { return true ; } $ kirby = kirby ( ) ; if ( ! class_exists ( 'Kirby\Component\Template' ) ) { throw new Exception ( 'The Kirby Twig plugin requires Kirby 2.3 or higher. Current version: ' . $ kirby -> version ( ) ) ; } if ( ! class_exists ( 'Twig_Environment' ) ) { require_once __DIR__ . '/../lib/Twig/lib/Twig/Autoloader.php' ; \ Twig_Autoloader :: register ( ) ; } $ kirby -> set ( 'component' , 'template' , 'Kirby\Twig\TwigComponent' ) ; if ( is_executable ( 'twig' ) === false ) { require_once __DIR__ . '/helpers.php' ; } return static :: $ registered = true ; }
11605	protected function getHashGeneratorByDescription ( OptionsInterface $ options , $ description ) { if ( $ description === 'predis' ) { return new Hash \ CRC16 ( ) ; } elseif ( $ description === 'phpiredis' ) { return new Hash \ PhpiredisCRC16 ( ) ; } else { throw new \ InvalidArgumentException ( 'String value for the crc16 option must be either `predis` or `phpiredis`' ) ; } }
9184	protected function getRememberKey ( ) { $ backtrace = debug_backtrace ( 4 ) [ 2 ] ; $ args = implode ( '_' , $ backtrace [ 'args' ] ) ; $ key = str_replace ( '\\' , '_' , get_class ( $ this ) . '_' . $ backtrace [ 'function' ] . '_' . $ args ) ; return $ key ; }
11476	public function authenticate ( Zend_Auth_Adapter_Interface $ adapter ) { $ result = $ adapter -> authenticate ( ) ; if ( $ this -> hasIdentity ( ) ) { $ this -> clearIdentity ( ) ; } if ( $ result -> isValid ( ) ) { $ this -> getStorage ( ) -> write ( $ adapter -> getResultRowObject ( ) ) ; } return $ result ; }
11279	public static function applyDataToView ( $ view , $ data ) { if ( ! empty ( $ data ) ) { foreach ( $ data as $ name => $ value ) { if ( is_string ( $ value ) ) { $ view = str_replace ( '{' . $ name . '}' , $ value , $ view ) ; } } } return $ view ; }
9302	public function setScheduleLifetime ( $ time ) { if ( ! is_numeric ( $ time ) ) { throw new \ InvalidArgumentException ( '`scheduleLifetime` expects integer value!' ) ; } $ this -> options [ 'scheduleLifetime' ] = ( int ) $ time ; return $ this ; }
12728	public function expectsOutcome ( IOutcomeRule $ rule , IOutcomeRule $ rule2 = null , IOutcomeRule $ rule3 = null , IOutcomeRule $ rule4 = null , IOutcomeRule $ rule5 = null , IOutcomeRule $ rule6 = null , IOutcomeRule $ rule7 = null , IOutcomeRule $ rule8 = null , IOutcomeRule $ rule9 = null , IOutcomeRule $ rule10 = null ) { foreach ( func_get_args ( ) as $ arg ) { if ( $ arg instanceof IInputRule ) { $ this -> outcomeRules [ ] = $ arg ; } } return $ this ; }
12035	private function createMethodGenerator ( $ methodName , $ body , DocBlockGenerator $ docBlock , $ parameterInfoArray , $ returnType = null ) { $ parameters = [ ] ; foreach ( $ parameterInfoArray as $ parameterInfo ) { $ parameters [ ] = new ParameterGenerator ( $ parameterInfo [ 0 ] , $ parameterInfo [ 1 ] ) ; } $ methodGenerator = new MethodGenerator ( $ methodName ) ; $ methodGenerator -> setParameters ( $ parameters ) ; if ( $ returnType != null ) { if ( is_array ( $ returnType ) ) { $ returnType = implode ( '|' , $ returnType ) ; } $ tags [ ] = new GenericTag ( 'return' , $ returnType ) ; $ docBlock -> setTags ( $ tags ) ; } $ methodGenerator -> setDocBlock ( $ docBlock ) ; $ methodGenerator -> setBody ( $ body ) ; return $ methodGenerator ; }
5143	public static function create ( array $ data ) : \ One \ Model \ Photo { $ url = self :: validateUrl ( ( string ) self :: checkData ( $ data , 'url' , '' ) ) ; $ ratio = self :: validateString ( ( string ) self :: checkData ( $ data , 'ratio' , '' ) ) ; $ description = self :: validateString ( ( string ) self :: checkData ( $ data , 'description' , '' ) ) ; $ information = self :: validateString ( ( string ) self :: checkData ( $ data , 'information' , '' ) ) ; return self :: createPhoto ( $ url , $ ratio , $ description , $ information ) ; }
9544	public static function allExcept ( $ except ) { $ result = [ 'parameter' => [ 'longest' => 9 + $ columnPadding , 'values' => [ ] , 'fetch' => function ( $ parameter ) { return $ parameter -> prefix . $ parameter -> parameterName ; } , ] , 'properties' => [ 'longest' => 10 + $ columnPadding , 'values' => [ ] , 'fetch' => function ( $ parameter ) { return $ parameter -> getPropertiesAsString ( ) ; } , ] , 'aliases' => [ 'longest' => 7 + $ columnPadding , 'values' => [ ] , 'fetch' => function ( $ parameter ) { return $ parameter -> getAliasUsage ( false ) ; } , ] , 'description' => [ 'longest' => 11 + $ columnPadding , 'values' => [ ] , 'fetch' => function ( $ parameter ) { return $ parameter -> description ; } , ] , 'required' => [ 'longest' => 8 + $ columnPadding , 'values' => [ ] , 'fetch' => function ( $ parameter ) { return $ parameter -> required ? 'Yes' : '' ; } , ] , ] ; foreach ( $ except as $ exceptKey ) { unset ( $ result [ $ exceptKey ] ) ; } return $ result ; }
8383	public function fetchAll ( ) { if ( $ this -> statement == null || $ this -> getErrorState ( ) != '00000' ) { return false ; } return $ this -> statement -> fetchAll ( \ PDO :: FETCH_ASSOC ) ; }
3608	public function getResourceOwnerDetailsUrl ( AccessToken $ token ) { $ uri = new Uri ( $ this -> urlResourceOwnerDetails ) ; return ( string ) Uri :: withQueryValue ( $ uri , 'access_token' , ( string ) $ token ) ; }
12543	public function getLink ( ) : string { if ( $ this -> link === null ) { return str_replace ( "?" . $ _SERVER [ "QUERY_STRING" ] , "" , $ _SERVER [ "REQUEST_URI" ] ) ; } else { return $ this -> link ; } }
3546	public function create ( $ request ) { $ data = $ request -> all ( ) ; $ user = $ this -> repository -> create ( $ data ) ; $ event_class = "Acoustep\EntrustGui\Events\\" . ucwords ( $ this -> getModelName ( ) ) . 'CreatedEvent' ; $ event = new $ event_class ; $ this -> dispatcher -> fire ( $ event -> setModel ( $ user ) ) ; return $ user ; }
10069	public function addDecorator ( TagDecoratorInterface $ decorator , $ priority = 0 ) { $ this -> decorators -> add ( $ decorator , $ priority ) ; return $ this ; }
11638	public function getAuthorities ( ) { $ authorities = [ ] ; foreach ( $ this -> getAll ( ) as $ typeItem ) { if ( isset ( $ typeItem -> object ) && $ typeItem -> object -> getBehavior ( 'Authority' ) !== null ) { $ authorities [ $ typeItem -> object -> systemId ] = $ typeItem -> object ; } } return $ authorities ; }
1334	protected function fillRelated ( $ record , ResourceObject $ resource , EncodingParametersInterface $ parameters ) { $ relationships = $ resource -> getRelationships ( ) ; $ changed = false ; foreach ( $ relationships as $ field => $ value ) { if ( $ this -> isNotFillable ( $ field , $ record ) ) { continue ; } if ( ! $ this -> isRelation ( $ field ) ) { continue ; } $ relation = $ this -> getRelated ( $ field ) ; if ( $ this -> requiresPrimaryRecordPersistence ( $ relation ) ) { $ relation -> update ( $ record , $ value , $ parameters ) ; $ changed = true ; } } if ( $ changed ) { $ record -> refresh ( ) ; } }
12817	public function fetchAll ( ) { $ list = [ ] ; foreach ( $ this -> cache as $ domain => $ values ) { foreach ( $ values as $ key => $ value ) $ list [ sprintf ( "%s.%s" , $ domain != '<NULL>' ? $ domain : '' , $ key ) ] = $ value ; } return $ list ; }
1883	public static function find ( array $ arrOptions ) { $ objBase = DcaExtractor :: getInstance ( $ arrOptions [ 'table' ] ) ; if ( ! $ objBase -> hasRelations ( ) ) { $ strQuery = "SELECT * FROM " . $ arrOptions [ 'table' ] ; } else { $ arrJoins = array ( ) ; $ arrFields = array ( $ arrOptions [ 'table' ] . ".*" ) ; $ intCount = 0 ; foreach ( $ objBase -> getRelations ( ) as $ strKey => $ arrConfig ) { if ( $ arrConfig [ 'load' ] == 'eager' || $ arrOptions [ 'eager' ] ) { if ( $ arrConfig [ 'type' ] == 'hasOne' || $ arrConfig [ 'type' ] == 'belongsTo' ) { ++ $ intCount ; $ objRelated = DcaExtractor :: getInstance ( $ arrConfig [ 'table' ] ) ; foreach ( array_keys ( $ objRelated -> getFields ( ) ) as $ strField ) { $ arrFields [ ] = 'j' . $ intCount . '.' . Database :: quoteIdentifier ( $ strField ) . ' AS ' . $ strKey . '__' . $ strField ; } $ arrJoins [ ] = " LEFT JOIN " . $ arrConfig [ 'table' ] . " j$intCount ON " . $ arrOptions [ 'table' ] . "." . Database :: quoteIdentifier ( $ strKey ) . "=j$intCount." . $ arrConfig [ 'field' ] ; } } } $ strQuery = "SELECT " . implode ( ', ' , $ arrFields ) . " FROM " . $ arrOptions [ 'table' ] . implode ( "" , $ arrJoins ) ; } if ( isset ( $ arrOptions [ 'column' ] ) ) { $ strQuery .= " WHERE " . ( \ is_array ( $ arrOptions [ 'column' ] ) ? implode ( " AND " , $ arrOptions [ 'column' ] ) : $ arrOptions [ 'table' ] . '.' . Database :: quoteIdentifier ( $ arrOptions [ 'column' ] ) . "=?" ) ; } if ( isset ( $ arrOptions [ 'group' ] ) ) { $ strQuery .= " GROUP BY " . $ arrOptions [ 'group' ] ; } if ( isset ( $ arrOptions [ 'having' ] ) ) { $ strQuery .= " HAVING " . $ arrOptions [ 'having' ] ; } if ( isset ( $ arrOptions [ 'order' ] ) ) { $ strQuery .= " ORDER BY " . $ arrOptions [ 'order' ] ; } return $ strQuery ; }
9873	private function writeDrawings ( XMLWriter $ objWriter = null , PhpspreadsheetWorksheet $ pSheet = null , $ includeCharts = false ) { $ chartCount = ( $ includeCharts ) ? $ pSheet -> getChartCollection ( ) -> count ( ) : 0 ; if ( ( $ pSheet -> getDrawingCollection ( ) -> count ( ) > 0 ) || ( $ chartCount > 0 ) ) { $ objWriter -> startElement ( 'drawing' ) ; $ objWriter -> writeAttribute ( 'r:id' , 'rId1' ) ; $ objWriter -> endElement ( ) ; } }
7448	function encrypt ( $ data , $ password ) { $ salt = openssl_random_pseudo_bytes ( 16 ) ; $ salted = '' ; $ dx = '' ; while ( strlen ( $ salted ) < 48 ) { $ dx = hash ( 'sha256' , $ dx . $ password . $ salt , true ) ; $ salted .= $ dx ; } $ key = substr ( $ salted , 0 , 32 ) ; $ iv = substr ( $ salted , 32 , 16 ) ; $ encrypted_data = openssl_encrypt ( $ data , 'AES-256-CBC' , $ key , true , $ iv ) ; return base64_encode ( $ salt . $ encrypted_data ) ; }
4470	public function complete ( ? string $ nextq = null , int $ delay = 0 , array $ depends = [ ] ) : string { if ( $ this -> completed || $ this -> failed ) { throw new JobAlreadyFinishedException ( ) ; } $ params = [ $ this -> jid , $ this -> worker , $ this -> queue , json_encode ( $ this -> data , JSON_UNESCAPED_SLASHES ) ? : '{}' ] ; if ( $ nextq ) { $ next = [ 'next' , $ nextq , 'delay' , $ delay , 'depends' , json_encode ( $ depends , JSON_UNESCAPED_SLASHES ) ] ; $ params = array_merge ( $ params , $ next ) ; } $ this -> completed = true ; return call_user_func_array ( [ $ this -> client , 'complete' ] , $ params ) ; }
3614	public function setTargetTemperatures ( $ temp_low , $ temp_high , $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ temp_low = $ this -> temperatureInCelsius ( $ temp_low , $ serial_number ) ; $ temp_high = $ this -> temperatureInCelsius ( $ temp_high , $ serial_number ) ; $ data = json_encode ( array ( 'target_change_pending' => TRUE , 'target_temperature_low' => $ temp_low , 'target_temperature_high' => $ temp_high ) ) ; return $ this -> doPOST ( "/v2/put/shared." . $ serial_number , $ data ) ; }
6643	public static function decodeId ( $ hash , $ salt , $ hashLength = self :: MIN_HASH_LENGTH ) { $ hashIds = new Hashids ( $ salt , $ hashLength ) ; return ArrayHelper :: getValue ( $ hashIds -> decode ( $ hash ) , '0' ) ; }
11285	public function isPlaceholder ( $ attributeName ) { $ def = $ this -> model_attributes [ $ attributeName ] ; if ( isset ( $ def [ 'models' ] ) || ( isset ( $ def [ 'model' ] ) && isset ( $ def [ 'usesRefTable' ] ) ) ) { return true ; } return false ; }
10087	private function createZip ( $ pFilename ) { $ zip = new ZipArchive ( ) ; if ( file_exists ( $ pFilename ) ) { unlink ( $ pFilename ) ; } if ( $ zip -> open ( $ pFilename , ZipArchive :: OVERWRITE ) !== true ) { if ( $ zip -> open ( $ pFilename , ZipArchive :: CREATE ) !== true ) { throw new WriterException ( "Could not open $pFilename for writing." ) ; } } return $ zip ; }
6455	public function textual ( ) { $ this -> restrictElements ( [ 'textarea' => [ ] , 'input' => [ ] , ] ) ; self :: debug ( [ 'Expected: %s' , 'Value: %s' , 'Tag: %s' , ] , [ $ this -> expected , $ this -> value , $ this -> tag , ] ) ; $ this -> assert ( trim ( $ this -> expected ) === $ this -> value ) ; }
10512	private function orderObserversForPriority ( $ a , $ b ) { if ( $ a -> order > $ b -> order ) { return + 1 ; } elseif ( $ a -> order == $ b -> order ) { return 0 ; } return - 1 ; }
8249	protected function needsPasswordRehash ( array $ userData ) { if ( $ this -> config [ "login" ] [ "passwordRehash" ] !== true ) { return false ; } if ( isset ( $ userData [ 'encoder' ] ) && $ userData [ 'encoder' ] !== $ this -> config [ "encoder" ] ) { return true ; } $ encoder = $ this -> getPasswordEncoder ( $ userData ) ; return $ encoder -> needsRehash ( $ userData [ 'pwhash' ] ) ; }
5467	protected function findRealmFromUrl ( $ url ) { if ( ! isset ( $ this -> realms [ $ url -> getHost ( ) ] ) ) { return false ; } foreach ( $ this -> realms [ $ url -> getHost ( ) ] as $ name => $ realm ) { if ( $ realm -> isWithin ( $ url ) ) { return $ realm ; } } return false ; }
4469	public function cancel ( $ dependents = false ) : array { if ( $ dependents && ! empty ( $ this -> rawData [ 'dependents' ] ) ) { return call_user_func_array ( [ $ this -> client , 'cancel' ] , array_merge ( [ $ this -> jid ] , $ this -> rawData [ 'dependents' ] ) ) ; } return $ this -> client -> cancel ( $ this -> jid ) ; }
12186	public function getCompanionNiceId ( $ queryRole ) { $ companionRoleType = $ this -> companionRoleType ( $ queryRole ) ; if ( empty ( $ companionRoleType ) ) { return false ; } return implode ( ':' , [ $ this -> companionRole ( $ queryRole ) , $ companionRoleType -> systemId ] ) ; }
9490	protected function getFileDataValue ( $ obFile ) { if ( empty ( $ obFile ) || ! $ obFile instanceof File ) { return null ; } $ sUploadFolder = Config :: get ( 'cms.storage.uploads.path' , '/storage/app/uploads' ) ; return [ 'full_path' => $ obFile -> getPath ( ) , 'path' => $ sUploadFolder . str_replace ( 'uploads' , '' , $ obFile -> getDiskPath ( ) ) , 'title' => $ obFile -> getAttribute ( 'title' ) , 'alt' => $ obFile -> getAttribute ( 'description' ) , ] ; }
12379	public function handle ( ) : void { $ help = " -----------------------------------------------------------------\n" ; $ help .= " | Command Line Interface\n" ; $ help .= " | See more in https://github.com/senhungwong/command-line-interface\n" ; $ help .= " -------------------------------------------------------------------\n" ; $ commands = CommandEntry :: getCommands ( ) ; if ( $ command = $ this -> getArgument ( 'function-name' ) ) { $ command = new $ commands [ $ command ] ; $ help .= " - " . $ command -> getCommand ( ) . ": " ; $ help .= $ command -> getDescription ( ) . "\n" ; } else { foreach ( $ commands as $ command ) { $ command = new $ command ; $ help .= " - " ; $ help .= $ command -> getCommand ( ) . ": " ; $ help .= $ command -> getDescription ( ) . "\n" ; } } echo $ help ; }
6825	protected function getPaymentAccountNumber ( PaymentMethodInterface $ method , string $ origin ) { foreach ( $ this -> accounts as $ account ) { if ( $ account -> getType ( ) !== AccountingTypes :: TYPE_PAYMENT ) { continue ; } if ( $ account -> getPaymentMethod ( ) !== $ method ) { continue ; } return $ account -> getNumber ( ) ; } throw new LogicException ( sprintf ( "No payment account number configured for payment method '%s' (%s)" , $ method -> getName ( ) , $ origin ) ) ; }
12902	private function addVirtualizationWorker ( $ arguments = array ( ) ) { $ this -> builder -> addWorker ( new VirtualizationWorker ( $ this -> registry , $ this -> virtualProperties , $ this -> deserialization , $ arguments ) ) ; }
4568	public function getParent ( $ permission ) { $ permission = $ this -> cast ( $ permission ) ; foreach ( $ this -> toArray ( ) as $ element ) { if ( Permission :: ENTITY === $ element -> getType ( ) && 0 === strpos ( $ permission -> getValue ( ) , $ element -> getValue ( ) ) ) { return $ element ; } } }
1344	public function isReadResource ( ) : bool { return $ this -> isMethod ( 'get' ) && $ this -> getRoute ( ) -> isResource ( ) && $ this -> getRoute ( ) -> isNotRelationship ( ) ; }
856	public function overrideAt ( $ index , $ token ) { @ trigger_error ( __METHOD__ . ' is deprecated and will be removed in 3.0, use offsetSet instead.' , E_USER_DEPRECATED ) ; self :: $ isLegacyMode = true ; $ this [ $ index ] -> override ( $ token ) ; $ this -> registerFoundToken ( $ token ) ; }
2213	public function first ( ) { $ this -> intIndex = 0 ; $ this -> blnDone = false ; $ this -> arrCache = $ this -> resultSet [ $ this -> intIndex ] ; return $ this ; }
8982	private function filter ( $ configurations , array $ criteria ) { $ result = array ( ) ; foreach ( $ configurations as $ configuration ) { if ( ConfigurationFilterUtil :: matches ( $ configuration , $ criteria ) ) { $ result [ ] = $ configuration ; } } return $ result ; }
1604	public function onException ( ExceptionEvent $ event ) { $ exception = $ event -> exception ; $ craft = \ Craft :: $ app ; if ( ! ( $ exception instanceof HttpException ) || $ exception -> statusCode !== 404 ) return ; $ path = $ craft -> request -> getFullPath ( ) ; $ query = $ craft -> request -> getQueryStringWithoutPath ( ) ; if ( $ query ) $ path .= '?' . $ query ; if ( $ redirect = $ this -> findRedirectByPath ( $ path ) ) { $ event -> handled = true ; $ craft -> response -> redirect ( $ redirect [ 'to' ] , $ redirect [ 'type' ] ) -> send ( ) ; $ craft -> end ( ) ; } }
3270	public function appendToFile ( string $ line ) { $ file = $ this -> openFile ( static :: FILE_APPEND ) ; $ file -> fwrite ( $ line ) ; $ this -> closeFile ( $ file ) ; }
11047	function get_value ( $ parent , $ varname ) { if ( isset ( $ parent -> $ varname ) ) { return $ parent -> $ varname ; } else { $ elements = explode ( '[' , $ varname ) ; if ( count ( $ elements ) == 1 ) { return NULL ; } else { $ vartest = $ parent ; foreach ( $ elements as $ elementid => $ element ) { if ( $ elementid == 0 ) { $ vartest = $ parent -> $ element ; if ( ! isset ( $ vartest ) ) { return NULL ; } } else { $ index = substr ( $ element , 0 , - 1 ) ; if ( $ index == '_first' ) { $ keys = array_keys ( $ vartest ) ; $ index = $ keys [ 0 ] ; } elseif ( $ index == '_last' ) { $ keys = array_keys ( $ vartest ) ; $ index = $ keys [ count ( $ keys ) - 2 ] ; } if ( ! isset ( $ vartest [ $ index ] ) ) { return NULL ; } else { $ vartest = $ vartest [ $ index ] ; } } } } return $ vartest ; } }
8355	private function buildModel ( string $ modelName , array $ modelDefinition ) { $ mapping = Mapping :: get ( $ this -> mapping ) ; $ definition = $ this -> getDefinition ( ) ; $ database = GlobalDatabase :: get ( $ mapping [ 'config' ] [ 'database' ] ) ; $ tableName = null ; if ( isset ( $ modelDefinition [ 'name' ] ) === true ) { $ tableName = $ modelDefinition [ 'name' ] ; } else { $ tableName = Helper :: codifyName ( $ this -> mapping ) . '_' . Helper :: codifyName ( $ modelName ) ; } if ( isset ( $ modelDefinition [ 'fields' ] ) === false ) { throw new InvalidSchemaDefinition ( 'model "' . $ modelName . '" has no field' ) ; } $ statement = Mutation \ AddTable :: statement ( $ database , $ this -> getDefinition ( ) , $ this -> mapping , $ tableName , $ modelName ) ; if ( $ statement -> execute ( ) == false ) { throw new DatabaseError ( 'db/build : ' . print_r ( $ statement -> errorInfo ( ) , true ) ) ; } if ( isset ( $ modelDefinition [ 'indexes' ] ) === true ) { foreach ( $ modelDefinition [ 'indexes' ] as $ indexName => $ indexDefinition ) { $ statement = Mutation \ AddIndex :: statement ( $ database , $ modelName , $ tableName , $ modelDefinition , $ indexName ) ; if ( $ statement -> execute ( ) == false ) { throw new DatabaseError ( 'db/build : ' . print_r ( $ statement -> errorInfo ( ) , true ) ) ; } } } if ( isset ( $ modelDefinition [ 'uniques' ] ) === true ) { foreach ( $ modelDefinition [ 'uniques' ] as $ uniqueName => $ uniqueDefinition ) { $ statement = Mutation \ AddUnique :: statement ( $ database , $ modelName , $ tableName , $ modelDefinition , $ uniqueName ) ; if ( $ statement -> execute ( ) == false ) { throw new DatabaseError ( 'db/build : ' . print_r ( $ statement -> errorInfo ( ) , true ) ) ; } } } echo $ modelName . ' - Done' . PHP_EOL ; }
7435	public function scan ( ) { $ files = $ this -> extensionsFile ( $ this -> files ) ; foreach ( $ files as $ file ) { $ content = file_get_contents ( $ file ) ; if ( str_contains ( $ file , '.php' ) && ! str_contains ( $ file , $ this -> exceptionsValid ) && ! $ this -> checkForValidPhp ( $ content ) ) { $ this -> notValid [ ] = $ file ; } if ( str_contains ( $ content , $ this -> signatures ) ) { $ this -> dangerFiles [ ] = $ file ; } } return $ this ; }
12633	public function close ( $ tradeNo ) { $ params = [ 'out_trade_no' => $ tradeNo , ] ; return $ this -> request ( $ this -> wrapApi ( self :: API_CLOSE ) , $ params ) ; }
8130	public function addSuggestions ( $ name , array $ items ) { if ( ! $ alternatives = self :: computeAlternatives ( $ name , $ items ) ) { return ; } $ this -> appendMessage ( sprintf ( ' Did you mean "%s"?' , implode ( '", "' , $ alternatives ) ) ) ; }
7821	public function update ( $ pipeline , array $ attachments , array $ detachments ) { $ this -> detach ( $ this -> pipelines [ $ pipeline ] , $ detachments ) ; $ this -> attach ( $ this -> pipelines [ $ pipeline ] , $ attachments ) ; $ this -> refreshPipelines ( ) ; }
791	public function addErrors ( array $ items ) { foreach ( $ items as $ attribute => $ errors ) { if ( is_array ( $ errors ) ) { foreach ( $ errors as $ error ) { $ this -> addError ( $ attribute , $ error ) ; } } else { $ this -> addError ( $ attribute , $ errors ) ; } } }
10337	public static function oneAnchor2twoAnchor ( $ sheet , $ coordinates , $ offsetX , $ offsetY , $ width , $ height ) { list ( $ column , $ row ) = Coordinate :: coordinateFromString ( $ coordinates ) ; $ col_start = Coordinate :: columnIndexFromString ( $ column ) ; $ row_start = $ row - 1 ; $ x1 = $ offsetX ; $ y1 = $ offsetY ; $ col_end = $ col_start ; $ row_end = $ row_start ; if ( $ x1 >= self :: sizeCol ( $ sheet , Coordinate :: stringFromColumnIndex ( $ col_start ) ) ) { $ x1 = 0 ; } if ( $ y1 >= self :: sizeRow ( $ sheet , $ row_start + 1 ) ) { $ y1 = 0 ; } $ width = $ width + $ x1 - 1 ; $ height = $ height + $ y1 - 1 ; while ( $ width >= self :: sizeCol ( $ sheet , Coordinate :: stringFromColumnIndex ( $ col_end ) ) ) { $ width -= self :: sizeCol ( $ sheet , Coordinate :: stringFromColumnIndex ( $ col_end ) ) ; ++ $ col_end ; } while ( $ height >= self :: sizeRow ( $ sheet , $ row_end + 1 ) ) { $ height -= self :: sizeRow ( $ sheet , $ row_end + 1 ) ; ++ $ row_end ; } if ( self :: sizeCol ( $ sheet , Coordinate :: stringFromColumnIndex ( $ col_start ) ) == 0 ) { return ; } if ( self :: sizeCol ( $ sheet , Coordinate :: stringFromColumnIndex ( $ col_end ) ) == 0 ) { return ; } if ( self :: sizeRow ( $ sheet , $ row_start + 1 ) == 0 ) { return ; } if ( self :: sizeRow ( $ sheet , $ row_end + 1 ) == 0 ) { return ; } $ x1 = $ x1 / self :: sizeCol ( $ sheet , Coordinate :: stringFromColumnIndex ( $ col_start ) ) * 1024 ; $ y1 = $ y1 / self :: sizeRow ( $ sheet , $ row_start + 1 ) * 256 ; $ x2 = ( $ width + 1 ) / self :: sizeCol ( $ sheet , Coordinate :: stringFromColumnIndex ( $ col_end ) ) * 1024 ; $ y2 = ( $ height + 1 ) / self :: sizeRow ( $ sheet , $ row_end + 1 ) * 256 ; $ startCoordinates = Coordinate :: stringFromColumnIndex ( $ col_start ) . ( $ row_start + 1 ) ; $ endCoordinates = Coordinate :: stringFromColumnIndex ( $ col_end ) . ( $ row_end + 1 ) ; $ twoAnchor = [ 'startCoordinates' => $ startCoordinates , 'startOffsetX' => $ x1 , 'startOffsetY' => $ y1 , 'endCoordinates' => $ endCoordinates , 'endOffsetX' => $ x2 , 'endOffsetY' => $ y2 , ] ; return $ twoAnchor ; }
1727	public function findBy ( $ strColumn , $ varValue ) { $ objResult = $ this -> Database -> prepare ( "SELECT * FROM " . $ this -> strTable . " WHERE " . Database :: quoteIdentifier ( $ strColumn ) . "=?" ) -> limit ( 1 ) -> execute ( $ varValue ) ; if ( $ objResult -> numRows > 0 ) { $ this -> arrData = $ objResult -> row ( ) ; return true ; } return false ; }
5140	public function map ( array $ methods , string $ path , $ handler ) : void { if ( is_string ( $ handler ) ) { $ handler = $ this -> getContainer ( ) -> get ( $ handler ) ; } $ this -> router -> map ( $ methods , $ path , $ handler ) ; }
8549	public function setRetrochargeEventList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'RetrochargeEventList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
457	public function dropUnique ( $ name , $ table ) { return 'ALTER TABLE ' . $ this -> db -> quoteTableName ( $ table ) . ' DROP CONSTRAINT ' . $ this -> db -> quoteColumnName ( $ name ) ; }
6168	protected function writeAssertionFailure ( $ assertionFailure ) { $ this -> writeNewLine ( ) ; foreach ( explode ( "\n" , $ assertionFailure ) as $ line ) { $ this -> writeWithColor ( 'fg-red' , $ line ) ; } }
5185	private function generalAttachment ( Article $ article , array $ attachmentConst , array $ attachmentype , array $ attributes , array $ dataArticle ) : Article { $ numOfAttachments = count ( $ attachmentConst ) ; for ( $ i = 0 ; $ i < $ numOfAttachments ; $ i ++ ) { $ attachments = $ this -> attachment ( $ attachmentype [ $ i ] , $ attributes [ $ i ] , $ dataArticle ) ; for ( $ j = 0 ; $ j < $ attachments [ 'numberOfItems' ] ; $ j ++ ) { $ attachment = $ attachments [ 'attachments' ] [ $ j ] ; $ article -> attach ( $ attachmentConst [ $ i ] , $ attachment ) ; } } return $ article ; }
7187	public function getAssignmentById ( $ id ) { foreach ( $ this -> unit -> getStockAssignments ( ) as & $ assignment ) { if ( $ assignment -> getId ( ) === $ id ) { return $ assignment ; } } return null ; }
8605	public function listRegisteredDestinations ( $ request ) { if ( ! ( $ request instanceof MWSSubscriptionsService_Model_ListRegisteredDestinationsInput ) ) { require_once ( dirname ( __FILE__ ) . '/Model/ListRegisteredDestinationsInput.php' ) ; $ request = new MWSSubscriptionsService_Model_ListRegisteredDestinationsInput ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListRegisteredDestinations' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/ListRegisteredDestinationsResponse.php' ) ; $ response = MWSSubscriptionsService_Model_ListRegisteredDestinationsResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
