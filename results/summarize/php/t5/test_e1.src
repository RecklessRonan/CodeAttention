11160	public function resolve ( $ url , \ GuzzleHttp \ Message \ Response $ data , Event $ event , Queue $ queue ) { $ logger = $ this -> getLogger ( ) ; $ json = json_decode ( $ data -> getBody ( ) ) ; $ logger -> info ( 'resolve' , array ( 'url' => $ url , 'json' => $ json ) ) ; if ( isset ( $ json -> error ) ) { return $ logger -> warning ( 'Query response contained an error' , array ( 'url' => $ url , 'error' => $ json -> error , ) ) ; } $ entries = $ json -> items ; if ( ! is_array ( $ entries ) || ! $ entries ) { return $ logger -> warning ( 'Query returned no results' , array ( 'url' => $ url ) ) ; } $ entry = reset ( $ entries ) ; $ replacements = $ this -> getReplacements ( $ entry ) ; $ message = str_replace ( array_keys ( $ replacements ) , array_values ( $ replacements ) , $ this -> responseFormat ) ; $ queue -> ircPrivmsg ( $ event -> getSource ( ) , $ message ) ; }
3271	public function writeTempToFile ( SplTempFileObject & $ tmpFile ) { $ file = $ this -> openFile ( static :: FILE_WRITE ) ; foreach ( $ tmpFile as $ line ) { $ file -> fwrite ( $ line ) ; } $ this -> closeFile ( $ file ) ; $ tmpFile = null ; }
11505	public function getSlots ( $ first , $ last ) { if ( ! static :: isValidRange ( $ first , $ last ) ) { throw new \ OutOfBoundsException ( "Invalid slot range $first-$last" ) ; } return array_intersect_key ( $ this -> slots , array_fill ( $ first , $ last - $ first + 1 , null ) ) ; }
607	private function tokenizeOperator ( & $ length ) { if ( ! $ this -> isOperator ( $ length , $ content ) ) { return false ; } $ this -> addTokenFromBuffer ( ) ; switch ( $ this -> substring ( $ length ) ) { case '(' : $ this -> _currentToken [ ] = new SqlToken ( [ 'type' => SqlToken :: TYPE_OPERATOR , 'content' => is_string ( $ content ) ? $ content : $ this -> substring ( $ length ) , 'startOffset' => $ this -> offset , 'endOffset' => $ this -> offset + $ length , ] ) ; $ this -> _currentToken [ ] = new SqlToken ( [ 'type' => SqlToken :: TYPE_PARENTHESIS ] ) ; $ this -> _tokenStack -> push ( $ this -> _currentToken [ - 1 ] ) ; $ this -> _currentToken = $ this -> _tokenStack -> top ( ) ; break ; case ')' : $ this -> _tokenStack -> pop ( ) ; $ this -> _currentToken = $ this -> _tokenStack -> top ( ) ; $ this -> _currentToken [ ] = new SqlToken ( [ 'type' => SqlToken :: TYPE_OPERATOR , 'content' => ')' , 'startOffset' => $ this -> offset , 'endOffset' => $ this -> offset + $ length , ] ) ; break ; case ';' : if ( ! $ this -> _currentToken -> getHasChildren ( ) ) { break ; } $ this -> _currentToken [ ] = new SqlToken ( [ 'type' => SqlToken :: TYPE_OPERATOR , 'content' => is_string ( $ content ) ? $ content : $ this -> substring ( $ length ) , 'startOffset' => $ this -> offset , 'endOffset' => $ this -> offset + $ length , ] ) ; $ this -> _tokenStack -> pop ( ) ; $ this -> _currentToken = $ this -> _tokenStack -> top ( ) ; $ this -> _currentToken [ ] = new SqlToken ( [ 'type' => SqlToken :: TYPE_STATEMENT ] ) ; $ this -> _tokenStack -> push ( $ this -> _currentToken [ - 1 ] ) ; $ this -> _currentToken = $ this -> _tokenStack -> top ( ) ; break ; default : $ this -> _currentToken [ ] = new SqlToken ( [ 'type' => SqlToken :: TYPE_OPERATOR , 'content' => is_string ( $ content ) ? $ content : $ this -> substring ( $ length ) , 'startOffset' => $ this -> offset , 'endOffset' => $ this -> offset + $ length , ] ) ; break ; } return true ; }
2372	public static function toXhtml ( $ strString ) { $ arrPregReplace = array ( '/<(br|hr|img)([^>]*)>/i' => '<$1$2 />' , '/ border="[^"]*"/' => '' ) ; $ arrStrReplace = array ( '/ />' => ' />' , '<b>' => '<strong>' , '</b>' => '</strong>' , '<i>' => '<em>' , '</i>' => '</em>' , '<u>' => '<span style="text-decoration:underline">' , '</u>' => '</span>' , ' target="_self"' => '' , ' target="_blank"' => ' onclick="return !window.open(this.href)"' ) ; $ strString = preg_replace ( array_keys ( $ arrPregReplace ) , $ arrPregReplace , $ strString ) ; $ strString = str_ireplace ( array_keys ( $ arrStrReplace ) , $ arrStrReplace , $ strString ) ; return $ strString ; }
6603	public function makeRequestToken ( Response $ response ) { parse_str ( $ response -> content ( ) , $ params ) ; $ this -> validateRequestTokenResponse ( $ params ) ; $ this -> credentials [ 'key' ] = $ params [ 'oauth_token' ] ; $ this -> credentials [ 'secret' ] = $ params [ 'oauth_token_secret' ] ; $ this -> credentials [ 'callback_confirmed' ] = ( isset ( $ params [ 'oauth_callback_confirmed' ] ) ) ? ( boolean ) $ params [ 'oauth_callback_confirmed' ] : null ; return $ this ; }
10590	public static function isTypeOf ( FormInterface $ form , $ typeName ) { $ typeNames = ( array ) $ typeName ; $ type = $ form -> getConfig ( ) -> getType ( ) ; while ( $ type ) { $ actualTypeName = $ type -> getName ( ) ; if ( in_array ( $ actualTypeName , $ typeNames , true ) ) { return true ; } $ type = $ type -> getParent ( ) ; } return false ; }
7664	function AttachAll ( ) { $ mime = array ( ) ; for ( $ i = 0 ; $ i < count ( $ this -> attachment ) ; $ i ++ ) { $ bString = $ this -> attachment [ $ i ] [ 5 ] ; if ( $ bString ) $ string = $ this -> attachment [ $ i ] [ 0 ] ; else $ path = $ this -> attachment [ $ i ] [ 0 ] ; $ filename = $ this -> attachment [ $ i ] [ 1 ] ; $ name = $ this -> attachment [ $ i ] [ 2 ] ; $ encoding = $ this -> attachment [ $ i ] [ 3 ] ; $ type = $ this -> attachment [ $ i ] [ 4 ] ; $ disposition = $ this -> attachment [ $ i ] [ 6 ] ; $ cid = $ this -> attachment [ $ i ] [ 7 ] ; $ mime [ ] = sprintf ( "--%s%s" , $ this -> boundary [ 1 ] , $ this -> LE ) ; $ mime [ ] = sprintf ( "Content-Type: %s; name=\"%s\"%s" , $ type , $ name , $ this -> LE ) ; $ mime [ ] = sprintf ( "Content-Transfer-Encoding: %s%s" , $ encoding , $ this -> LE ) ; if ( $ disposition == "inline" ) $ mime [ ] = sprintf ( "Content-ID: <%s>%s" , $ cid , $ this -> LE ) ; $ mime [ ] = sprintf ( "Content-Disposition: %s; filename=\"%s\"%s" , $ disposition , $ name , $ this -> LE . $ this -> LE ) ; if ( $ bString ) { $ mime [ ] = $ this -> EncodeString ( $ string , $ encoding ) ; if ( $ this -> IsError ( ) ) { return "" ; } $ mime [ ] = $ this -> LE . $ this -> LE ; } else { $ mime [ ] = $ this -> EncodeFile ( $ path , $ encoding ) ; if ( $ this -> IsError ( ) ) { return "" ; } $ mime [ ] = $ this -> LE . $ this -> LE ; } } $ mime [ ] = sprintf ( "--%s--%s" , $ this -> boundary [ 1 ] , $ this -> LE ) ; return join ( "" , $ mime ) ; }
6844	public function callInClass ( $ class_name , $ action , $ params = array ( ) ) { $ ref = new ReflectionMethod ( $ class_name , $ action ) ; if ( ! $ ref -> isPublic ( ) && ! $ ref -> isStatic ( ) ) throw new InjectorException ( "$class_name->$action is not public or static" ) ; $ params_need = $ ref -> getParameters ( ) ; $ args = $ this -> apply ( $ params_need , $ params ) ; $ obj = $ this -> produce ( $ class_name , $ params ) ; return call_user_func_array ( [ $ obj , $ action ] , $ args ) ; }
6548	public function current ( ) { $ sheet = $ this -> iterator -> current ( ) ; return new \ Aimeos \ MW \ Container \ Content \ PHPExcel ( $ sheet , $ sheet -> getTitle ( ) , $ this -> getOptions ( ) ) ; }
68	public function junction ( $ target , $ junction ) { if ( ! Platform :: isWindows ( ) ) { throw new \ LogicException ( sprintf ( 'Function %s is not available on non-Windows platform' , __CLASS__ ) ) ; } if ( ! is_dir ( $ target ) ) { throw new IOException ( sprintf ( 'Cannot junction to "%s" as it is not a directory.' , $ target ) , 0 , null , $ target ) ; } $ cmd = sprintf ( 'mklink /J %s %s' , ProcessExecutor :: escape ( str_replace ( '/' , DIRECTORY_SEPARATOR , $ junction ) ) , ProcessExecutor :: escape ( realpath ( $ target ) ) ) ; if ( $ this -> getProcess ( ) -> execute ( $ cmd , $ output ) !== 0 ) { throw new IOException ( sprintf ( 'Failed to create junction to "%s" at "%s".' , $ target , $ junction ) , 0 , null , $ target ) ; } clearstatcache ( true , $ junction ) ; }
5297	protected function getOptionsFromXML ( ) { $ options = array ( ) ; foreach ( array ( 'id' , 'horiz-adv-x' ) as $ key ) { if ( isset ( $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] [ $ key ] ) ) { $ options [ $ key ] = ( string ) $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] [ $ key ] ; } } foreach ( array ( 'units-per-em' , 'ascent' , 'descent' , 'x-height' , 'cap-height' ) as $ key ) { if ( isset ( $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] -> { 'font-face' } [ 0 ] [ $ key ] ) ) { $ options [ $ key ] = ( string ) $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] -> { 'font-face' } [ 0 ] [ $ key ] ; } } return $ options ; }
6617	protected function mapRequestToArguments ( \ ReflectionMethod $ method , Request $ request ) { $ map = [ ] ; foreach ( $ method -> getParameters ( ) as $ parameter ) { $ value = $ request -> getParameter ( $ parameter -> getName ( ) , $ parameter -> isDefaultValueAvailable ( ) ? $ parameter -> getDefaultValue ( ) : null ) ; if ( $ parameter -> getClass ( ) && $ parameter -> getClass ( ) -> implementsInterface ( Deserializable :: class ) ) { $ value = $ parameter -> getClass ( ) -> newInstanceWithoutConstructor ( ) -> ayeAyeDeserialize ( $ value ) ; $ className = $ parameter -> getClass ( ) -> getName ( ) ; if ( ! is_object ( $ value ) || get_class ( $ value ) !== $ className ) { throw new \ RuntimeException ( "$className::ayeAyeDeserialize did not return an instance of itself" ) ; } } $ map [ $ parameter -> getName ( ) ] = $ value ; } return $ map ; }
5685	protected function getUrlFromLink ( $ link ) { $ url = $ this -> expandUrl ( $ link -> getHref ( ) ) ; if ( $ link -> getAttribute ( 'target' ) ) { $ url -> setTarget ( $ link -> getAttribute ( 'target' ) ) ; } return $ url ; }
5652	public function render ( ) { $ tab_stop = $ this -> longestFlag ( $ this -> flag_sets ) + 4 ; $ text = $ this -> overview . "\n" ; $ numberOfFlags = count ( $ this -> flag_sets ) ; for ( $ i = 0 ; $ i < $ numberOfFlags ; $ i ++ ) { $ text .= $ this -> renderFlagSet ( $ this -> flag_sets [ $ i ] , $ this -> explanations [ $ i ] , $ tab_stop ) ; } return $ this -> noDuplicateNewLines ( $ text ) ; }
5909	public function retrieveUser ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/accounts/users/' . $ id . '' , $ parameters , $ cachePolicy ) ; $ result = new User ( $ result ) ; return $ result ; }
11069	protected function getStatusData ( $ identifier ) { foreach ( $ this -> options [ 'statuses' ] as $ status ) { if ( ( int ) $ status [ 'id' ] === ( int ) $ identifier ) { return $ status ; } } return null ; }
4247	private function logRequestHeaders ( ) { if ( ! $ this -> debug -> getCfg ( 'logEnvInfo.headers' ) ) { return ; } if ( ! empty ( $ _SERVER [ 'argv' ] ) ) { return ; } $ headers = $ this -> debug -> utilities -> getAllHeaders ( ) ; \ ksort ( $ headers , SORT_NATURAL ) ; $ this -> debug -> log ( 'request headers' , $ headers ) ; }
6906	public function addExtraRecipient ( Recipient $ recipient ) { if ( ! $ this -> extraRecipients -> contains ( $ recipient ) ) { $ this -> extraRecipients -> add ( $ recipient ) ; } return $ this ; }
8033	public function loadView ( $ viewName , $ data = array ( ) , $ mergeData = array ( ) ) { $ this -> htmlContent = View :: make ( $ viewName , $ data , $ mergeData ) ; return $ this ; }
5704	public function Field ( $ properties = array ( ) ) { if ( $ this -> isGrouped ( ) ) { $ this -> transformToInput ( ) ; } else { $ this -> transformToButton ( ) ; } return parent :: Field ( $ properties ) ; }
4374	protected function buildChannelTree ( ) { if ( $ this -> channels == array ( $ this -> channelNameRoot ) ) { return array ( ) ; } \ sort ( $ this -> channels ) ; $ rootKey = \ array_search ( $ this -> channelNameRoot , $ this -> channels ) ; if ( $ rootKey !== false ) { unset ( $ this -> channels [ $ rootKey ] ) ; \ array_unshift ( $ this -> channels , $ this -> channelName ) ; } $ tree = array ( ) ; foreach ( $ this -> channels as $ channel ) { $ ref = & $ tree ; $ path = \ explode ( '.' , $ channel ) ; foreach ( $ path as $ k ) { if ( ! isset ( $ ref [ $ k ] ) ) { $ ref [ $ k ] = array ( ) ; } $ ref = & $ ref [ $ k ] ; } } return $ tree ; }
9400	public function export ( ) { foreach ( $ this -> messages as $ message ) { list ( $ msg , $ level , $ catagory , $ timestamp , $ traces ) = $ message ; $ errStr = '' ; $ options = [ 'level' => yii \ log \ Logger :: getLevelName ( $ level ) , 'extra' => [ ] , ] ; $ templateData = null ; if ( is_array ( $ msg ) ) { $ errStr = isset ( $ msg [ 'msg' ] ) ? $ msg [ 'msg' ] : '' ; if ( isset ( $ msg [ 'data' ] ) ) $ options [ 'extra' ] = $ msg [ 'data' ] ; } else { $ errStr = $ msg ; } $ traces = array_map ( function ( $ v ) { return "{$v['file']}" . PHP_EOL . "{$v['class']}::{$v['function']} [{$v['line']}]" ; } , $ traces ) ; if ( ! empty ( $ traces ) ) $ options [ 'extra' ] [ 'traces' ] = $ traces ; $ this -> client -> captureMessage ( $ errStr , array ( ) , $ options , false ) ; } }
10591	protected function findProduct ( int $ id ) : ProductInterface { $ product = $ this -> repository -> find ( $ id ) ; if ( ! $ product instanceof ProductInterface ) { throw new ProductNotFoundException ( $ id ) ; } return $ product ; }
2536	protected function getWsdlIdFor ( $ messageName ) { $ msgAndVer = $ this -> getMessagesAndVersions ( ) ; if ( isset ( $ msgAndVer [ $ messageName ] ) && isset ( $ msgAndVer [ $ messageName ] [ 'wsdl' ] ) ) { return $ msgAndVer [ $ messageName ] [ 'wsdl' ] ; } return null ; }
11184	protected function generateActions ( ) { $ parser = new Parser ( ) ; $ parser -> setPath ( $ this -> getApplicationPath ( ) ) ; $ parser -> setNameSpace ( $ this -> getApplicationNameSpace ( ) ) ; $ list = $ parser -> run ( ) ; return $ list ; }
4022	protected function getHelpForWidget ( $ widget ) { if ( $ GLOBALS [ 'TL_CONFIG' ] [ 'showHelp' ] && $ widget -> description ) { return sprintf ( '<p class="tl_help tl_tip%s">%s</p>' , $ widget -> tl_class , $ widget -> description ) ; } return '' ; }
7620	public function createSignedQueryString ( $ path = '/' , $ queryString = '' , $ resource = 'b' , $ permissions = 'r' , $ start = '' , $ expiry = '' , $ identifier = '' ) { $ parts = array ( ) ; if ( $ start !== '' ) { $ parts [ ] = 'st=' . urlencode ( $ start ) ; } $ parts [ ] = 'se=' . urlencode ( $ expiry ) ; $ parts [ ] = 'sr=' . $ resource ; $ parts [ ] = 'sp=' . $ permissions ; if ( $ identifier !== '' ) { $ parts [ ] = 'si=' . urlencode ( $ identifier ) ; } $ parts [ ] = 'sig=' . urlencode ( $ this -> createSignature ( $ path , $ resource , $ permissions , $ start , $ expiry , $ identifier ) ) ; if ( $ queryString != '' ) { $ queryString .= '&' ; } $ queryString .= implode ( '&' , $ parts ) ; return $ queryString ; }
11217	public static function getMethod ( $ route ) { $ route = Url :: addBackSlash ( $ route ) ; return isset ( self :: $ routes [ $ route ] ) ? self :: $ routes [ $ route ] : null ; }
603	protected function startsWithAnyLongest ( array & $ with , $ caseSensitive , & $ length = null , & $ content = null ) { if ( empty ( $ with ) ) { return false ; } if ( ! is_array ( reset ( $ with ) ) ) { usort ( $ with , function ( $ string1 , $ string2 ) { return mb_strlen ( $ string2 , 'UTF-8' ) - mb_strlen ( $ string1 , 'UTF-8' ) ; } ) ; $ map = [ ] ; foreach ( $ with as $ string ) { $ map [ mb_strlen ( $ string , 'UTF-8' ) ] [ $ caseSensitive ? $ string : mb_strtoupper ( $ string , 'UTF-8' ) ] = true ; } $ with = $ map ; } foreach ( $ with as $ testLength => $ testValues ) { $ content = $ this -> substring ( $ testLength , $ caseSensitive ) ; if ( isset ( $ testValues [ $ content ] ) ) { $ length = $ testLength ; return true ; } } return false ; }
11223	private static function checkRegexRoutes ( ) { $ pos = 0 ; self :: getRegexRoutes ( ) ; $ method = $ _SERVER [ 'REQUEST_METHOD' ] ; $ searches = array_keys ( self :: $ patterns ) ; $ replaces = array_values ( self :: $ patterns ) ; foreach ( self :: $ routes as $ route ) { $ segments = explode ( '/' , str_replace ( $ searches , '' , $ route ) ) ; $ route = str_replace ( $ searches , $ replaces , $ route ) ; $ route = Url :: addBackSlash ( $ route ) ; if ( preg_match ( '#^' . $ route . '$#' , self :: $ uri , $ matched ) ) { $ methodRoute = self :: $ methods [ $ pos ] ; if ( $ methodRoute == $ method || $ methodRoute == 'ANY' ) { $ matched = explode ( '/' , trim ( $ matched [ 0 ] , '/' ) ) ; $ matched = array_diff ( $ matched , $ segments ) ; if ( ! is_object ( self :: $ callbacks [ $ pos ] ) ) { self :: $ response = self :: invokeObject ( self :: $ callbacks [ $ pos ] , $ matched ) ; } else { self :: $ response = call_user_func_array ( self :: $ callbacks [ $ pos ] , $ matched ) ; } if ( ! self :: $ halts ) { return self :: $ response ; } self :: $ halts -- ; } } $ pos ++ ; } return self :: $ response ; }
10834	public function using ( $ column ) { if ( $ this -> active_join === null ) { throw new \ Peyote \ Exception ( "You need to start a join before calling \Peyote\Join::using()" ) ; } list ( $ table , $ type ) = $ this -> active_join ; $ this -> active_join = null ; $ this -> joins [ ] = array ( "USING" , $ table , $ type , $ column ) ; return $ this ; }
3108	public function setCatValue ( $ assessmentSectionId , $ key , $ value ) { $ this -> state [ self :: VAR_CAT ] [ $ assessmentSectionId ] [ $ key ] = $ value ; return $ this ; }
3862	public function getOutputFormat ( ) { if ( isset ( $ this -> strOutputFormat ) ) { return $ this -> strOutputFormat ; } if ( isset ( $ this -> objView ) && $ this -> objView -> get ( 'format' ) ) { return $ this -> objView -> get ( 'format' ) ; } $ page = $ this -> getPage ( ) ; if ( $ page && $ page -> outputFormat ) { return $ page -> outputFormat ; } return 'text' ; }
11927	public function actionRunOne ( ) { $ this -> out ( "Run Interface " . $ this -> dataInterface -> object -> name , Console :: UNDERLINE , Console :: FG_GREEN ) ; $ this -> hr ( ) ; $ this -> dataInterface -> run ( null , new ConsoleAction ( ) ) ; }
9609	protected function _checkVectorSpace ( self $ b ) { if ( ! $ this -> isSameDimension ( $ b ) ) { throw new Exception ( 'The vectors must be of the same dimension' ) ; } if ( ! $ this -> isSameVectorSpace ( $ b ) ) { throw new Exception ( 'The vectors\' components must have the same keys' ) ; } }
6383	public function readFeedbackAttempt ( $ id ) { $ model = $ this -> readObject ( $ id , 'feedback_completed' ) ; $ model -> url = $ this -> cfg -> wwwroot . '/mod/feedback/complete.php?id=' . $ id ; $ model -> name = 'Attempt ' . $ id ; $ model -> responses = $ this -> readStoreRecords ( 'feedback_value' , [ 'completed' => $ id ] ) ; return $ model ; }
11776	public function getHelper ( ) { if ( $ this -> helper === null ) { $ this -> helper = $ this -> command -> getHelper ( 'question' ) ; } return $ this -> helper ; }
12056	public function getLabels ( ) { $ labels = [ ] ; $ labels [ 'delete_object' ] = [ 'short' => 'Delete ' . $ this -> object -> objectType -> title -> getSingular ( true ) , 'long' => 'delete the ' . $ this -> object -> objectType -> title -> getSingular ( false ) . ' <em>' . $ this -> object -> descriptor . '</em>' , 'past' => $ this -> object -> objectType -> title -> getSingular ( false ) . ' <em>' . $ this -> object -> descriptor . '</em> has been deleted' , 'options' => [ 'class' => 'btn-danger' ] , 'response' => 'home' , ] ; $ labels [ 'archive_object' ] = [ 'short' => 'Archive ' . $ this -> object -> objectType -> title -> getSingular ( true ) , 'long' => 'archive the ' . $ this -> object -> objectType -> title -> getSingular ( false ) . ' <em>' . $ this -> object -> descriptor . '</em>' , 'past' => $ this -> object -> objectType -> title -> getSingular ( false ) . ' <em>' . $ this -> object -> descriptor . '</em> has been archived' , 'response' => 'refresh' , ] ; $ labels [ 'unarchive_object' ] = [ 'short' => 'Unarchive ' . $ this -> object -> objectType -> title -> getSingular ( true ) , 'long' => 'unarchive the ' . $ this -> object -> objectType -> title -> getSingular ( false ) . ' <em>' . $ this -> object -> descriptor . '</em>' , 'past' => $ this -> object -> objectType -> title -> getSingular ( false ) . ' <em>' . $ this -> object -> descriptor . '</em> has been unarchived' , 'response' => 'refresh' , ] ; if ( isset ( $ this -> relationshipWith ) ) { $ labels [ 'delete_relationship' ] = [ 'short' => 'Delete Relationship' , 'long' => 'delete the relationship between <em>' . $ this -> object -> descriptor . '</em> and <em>' . $ this -> relationshipWith -> descriptor . '</em>' , 'past' => 'the relationship between <em>' . $ this -> object -> descriptor . '</em> and <em>' . $ this -> relationshipWith -> descriptor . '</em> has been deleted' , 'options' => [ 'class' => 'btn-warning' ] , ] ; $ labels [ 'end_relationship' ] = [ 'short' => 'End Relationship' , 'long' => 'end the relationship between <em>' . $ this -> object -> descriptor . '</em> and <em>' . $ this -> relationshipWith -> descriptor . '</em>' , 'past' => 'the relationship between <em>' . $ this -> object -> descriptor . '</em> and <em>' . $ this -> relationshipWith -> descriptor . '</em> has been ended' , ] ; } return $ labels ; }
6397	private function addEvolution ( $ decoded_taf , $ evolution , $ result , $ entity_name ) { $ new_evolution = clone ( $ evolution ) ; $ new_evolution -> setEntity ( $ result [ $ entity_name ] ) ; if ( $ entity_name == 'visibility' && $ this -> with_cavok == true ) { $ new_evolution -> setCavok ( true ) ; } $ getter_name = 'get' . ucfirst ( $ entity_name ) ; $ setter_name = 'set' . ucfirst ( $ entity_name ) ; $ decoded_entity = $ decoded_taf -> $ getter_name ( ) ; if ( $ decoded_entity == null || $ entity_name == 'clouds' || $ entity_name == 'weatherPhenomenons' ) { $ decoded_entity = $ this -> instantiateEntity ( $ entity_name ) ; } $ decoded_entity -> addEvolution ( $ new_evolution ) ; if ( $ entity_name == 'clouds' ) { $ decoded_taf -> addCloud ( $ decoded_entity ) ; } elseif ( $ entity_name == 'weatherPhenomenons' ) { $ decoded_taf -> addWeatherPhenomenon ( $ decoded_entity ) ; } else { $ decoded_taf -> $ setter_name ( $ decoded_entity ) ; } }
2361	public static function findAllActive ( array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ time = Date :: floorToMinute ( ) ; return static :: findBy ( array ( "$t.disable='' AND ($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "')" ) , null , $ arrOptions ) ; }
9426	public function build ( $ options ) { $ command = $ this -> path ; if ( isset ( $ options [ 'title' ] ) ) { $ command .= " -title {$options['title']}" ; } if ( isset ( $ options [ 'subtitle' ] ) ) { $ command .= " -subtitle {$options['subtitle']}" ; } if ( isset ( $ options [ 'message' ] ) ) { $ command .= " -message {$options['message']}" ; } if ( isset ( $ options [ 'image' ] ) ) { $ command .= " -appIcon {$options['image']}" ; } if ( isset ( $ options [ 'contentImage' ] ) ) { $ command .= " -contentImage {$options['contentImage']}" ; } if ( isset ( $ options [ 'url' ] ) ) { $ command .= " -open {$options['url']}" ; } return $ command ; }
8282	public function onPageRendering ( & $ templateName , array & $ twigVariables ) { $ twigVariables [ 'auth' ] [ 'plugin' ] = $ this ; $ twigVariables [ 'auth' ] [ 'vars' ] = $ this -> output ; if ( ! $ this -> errorOccurred ) { $ twigVariables [ 'auth' ] [ 'user' ] = $ this -> user ; $ old = $ this -> session -> getFlash ( 'old' ) ; if ( count ( $ old ) && isset ( $ old [ 0 ] ) ) { $ twigVariables [ 'auth' ] [ 'old' ] = $ old [ 0 ] ; } } }
1865	public function addSenderPlaceholder ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ dc -> activeRecord && $ dc -> activeRecord -> pid ) { $ objChannel = $ this -> Database -> prepare ( "SELECT sender FROM tl_newsletter_channel WHERE id=?" ) -> execute ( $ dc -> activeRecord -> pid ) ; $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'fields' ] [ $ dc -> field ] [ 'eval' ] [ 'placeholder' ] = $ objChannel -> sender ; } return $ varValue ; }
6339	private function getDocumentStream ( $ xmlDocument ) { foreach ( $ this -> streamAdapters as $ streamAdapter ) { if ( $ streamAdapter -> supports ( $ xmlDocument ) ) { return $ streamAdapter -> convert ( $ xmlDocument ) ; } } throw new RuntimeException ( sprintf ( 'Suitable XML document stream adapter is not registered for XML document of type "%s".' , is_object ( $ xmlDocument ) ? get_class ( $ xmlDocument ) : gettype ( $ xmlDocument ) ) ) ; }
7546	function setNamespace ( $ ns ) { if ( $ this -> getNamespace ( ) !== $ ns ) { $ this -> tag_ns [ 0 ] = $ ns ; $ this -> tag = $ ns . ':' . $ this -> tag_ns [ 1 ] ; } }
3272	public function setConfig ( Config $ config ) { $ this -> config = $ config ; $ this -> getDatabase ( ) -> setConfig ( $ config ) ; }
4570	public function postLoad ( LifecycleEventArgs $ args ) { $ entity = $ args -> getEntity ( ) ; if ( ! $ entity instanceof Encryptable ) { return ; } $ entity -> setEncrypted ( true ) ; $ this -> encryptionService -> decrypt ( $ entity ) ; }
6296	private static function migrateConfig ( array $ config ) : array { if ( isset ( $ config [ 'class' ] ) ) { do_action ( 'inpsyde.assets.debug' , 'The asset config-format with "type" and "class" is deprecated.' , $ config ) ; $ config [ 'location' ] = $ config [ 'type' ] ?? Asset :: FRONTEND ; $ config [ 'type' ] = $ config [ 'class' ] ; unset ( $ config [ 'class' ] ) ; } return $ config ; }
4014	protected function getHelpWizard ( $ key , $ field ) { if ( empty ( $ field [ 'eval' ] [ 'helpwizard' ] ) ) { return '' ; } $ event = new GenerateHtmlEvent ( 'about.svg' , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'helpWizard' ] , 'style="vertical-align:text-bottom;"' ) ; $ this -> getEventDispatcher ( ) -> dispatch ( ContaoEvents :: IMAGE_GET_HTML , $ event ) ; return sprintf ( ' <a href="%shelp.php?table=%s&amp;field=%s_%s" title="%s" rel="lightbox[help 610 80%]">%s</a>' , TL_PATH . 'contao/' , $ this -> strTable , $ this -> strName , $ key , StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'helpWizard' ] ) , $ event -> getHtml ( ) ) ; }
4179	public function hasManagerFile ( ) { if ( app ( 'filesystem' ) -> exists ( $ this -> directory . 'manager.yml' ) ) { return true ; } $ this -> console -> warn ( "No manager.yml file found in {$this->name} package." ) ; return false ; }
6150	public function setJsonBody ( $ data ) { $ this -> addHeader ( "Content-Type: application/json; charset=utf8" ) ; $ this -> setBody ( json_encode ( $ data , JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES ) ) ; return $ this ; }
2400	public function output ( ) { @ trigger_error ( 'Using Template::output() has been deprecated and will no longer work in Contao 5.0. Use Template::getResponse() instead.' , E_USER_DEPRECATED ) ; $ this -> compile ( ) ; header ( 'Content-Type: ' . $ this -> strContentType . '; charset=' . Config :: get ( 'characterSet' ) ) ; echo $ this -> strBuffer ; $ this -> flushAllData ( ) ; }
8489	public static function getCpuArchitecture ( ) { $ wmi = Windows :: getInstance ( ) ; foreach ( $ wmi -> ExecQuery ( "SELECT Architecture FROM Win32_Processor" ) as $ cpu ) { switch ( $ cpu -> Architecture ) { case 0 : return "x86" ; case 1 : return "MIPS" ; case 2 : return "Alpha" ; case 3 : return "PowerPC" ; case 6 : return "Itanium-based systems" ; case 9 : return "x64" ; } } return "Unknown" ; }
11189	public static function json ( $ jsonStr , $ k = null , $ default = null ) { $ json = json_decode ( $ jsonStr , true ) ; if ( $ k && $ json ) { return self :: get ( $ json , $ k , $ default ) ; } return $ json ; }
9781	private function setFlag ( string $ name , bool $ value = true ) : self { $ this -> flags [ $ name ] = $ value ; return $ this ; }
8699	private function factoryElement ( $ type ) { switch ( $ type ) { case \ SVGCreator \ Element :: CIRCLE : return new \ SVGCreator \ Elements \ Circle ( ) ; break ; case \ SVGCreator \ Element :: DEFS : return new \ SVGCreator \ Elements \ Defs ( ) ; break ; case \ SVGCreator \ Element :: GROUP : return new \ SVGCreator \ Elements \ Group ( ) ; break ; case \ SVGCreator \ Element :: LINE : return new \ SVGCreator \ Elements \ Line ( ) ; break ; case \ SVGCreator \ Element :: MARKER : return new \ SVGCreator \ Elements \ Marker ( ) ; break ; case \ SVGCreator \ Element :: PATH : return new \ SVGCreator \ Elements \ Path ( ) ; break ; case \ SVGCreator \ Element :: RECT : return new \ SVGCreator \ Elements \ Rect ( ) ; break ; case \ SVGCreator \ Element :: SVG : return new \ SVGCreator \ Elements \ Svg ( ) ; break ; case \ SVGCreator \ Element :: TEXT : return new \ SVGCreator \ Elements \ Text ( ) ; break ; case \ SVGCreator \ Element :: POLYGON : return new \ SVGCreator \ Elements \ Polygon ( ) ; break ; default : throw new \ SVGCreator \ SVGException ( "The tag " . $ type . " is not implemented yet" , 1 ) ; break ; } }
11785	public function pagination ( $ begin , $ count ) { $ params = [ 'type' => 2 , 'begin' => intval ( $ begin ) , 'count' => intval ( $ count ) , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_SEARCH , $ params ] ) ; }
10925	private function renderRow ( array $ row ) { $ output = [ ] ; $ output [ ] = $ this -> charVertical ; $ columnNumber = 0 ; foreach ( $ row as $ column => $ value ) { $ output [ ] = $ this -> renderCell ( $ columnNumber , $ value , ' ' ) ; $ output [ ] = $ this -> charVertical ; $ columnNumber ++ ; } return implode ( '' , $ output ) ; }
7988	public function deleteSnapshot ( $ domain ) { $ domain = ( string ) $ domain ; if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; try { $ r = $ this -> delete ( 'vps/' . $ domain . '/snapshot' ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new VpsException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r ; }
8679	public function sort ( $ order = SORT_ASC , $ flags = SORT_REGULAR , $ preserveKeys = false ) { $ this -> validateSortArgs ( $ order , $ flags ) ; $ items = $ this -> items ; if ( ! $ preserveKeys ) { if ( $ order === SORT_ASC ) { sort ( $ items , $ flags ) ; } elseif ( $ order === SORT_DESC ) { rsort ( $ items , $ flags ) ; } } else { if ( $ order === SORT_ASC ) { asort ( $ items , $ flags ) ; } elseif ( $ order === SORT_DESC ) { arsort ( $ items , $ flags ) ; } } return $ this -> createFrom ( $ items ) ; }
589	protected function registerBundle ( $ bundles , $ name , & $ registered ) { if ( ! isset ( $ registered [ $ name ] ) ) { $ registered [ $ name ] = false ; $ bundle = $ bundles [ $ name ] ; foreach ( $ bundle -> depends as $ depend ) { $ this -> registerBundle ( $ bundles , $ depend , $ registered ) ; } unset ( $ registered [ $ name ] ) ; $ registered [ $ name ] = $ bundle ; } elseif ( $ registered [ $ name ] === false ) { throw new Exception ( "A circular dependency is detected for target '{$name}': " . $ this -> composeCircularDependencyTrace ( $ name , $ registered ) . '.' ) ; } }
2928	public function getKeys ( $ keys = [ ] ) { $ allKeys = $ this -> reader -> keys ( ) ; return array_filter ( $ allKeys , function ( $ key ) use ( $ keys ) { if ( ! empty ( $ keys ) ) { return in_array ( $ key , $ keys ) ; } return true ; } , ARRAY_FILTER_USE_KEY ) ; }
5267	public function esc_value ( $ value ) { global $ wpdb ; if ( is_int ( $ value ) ) { return $ wpdb -> prepare ( '%d' , $ value ) ; } if ( is_float ( $ value ) ) { return $ wpdb -> prepare ( '%f' , $ value ) ; } if ( is_string ( $ value ) ) { return 'null' === $ value ? $ value : $ wpdb -> prepare ( '%s' , $ value ) ; } return $ value ; }
11814	protected function step1 ( ) { $ this -> view -> addToBlock ( "form" , "import://admin/setup/license" ) ; $ this -> view -> setData ( "step" , "1" ) ; $ this -> view -> setData ( "title" , t ( "Installation | EULA" ) ) ; return ; }
3945	public function onLoadDataContainer ( $ tableName ) { static $ tableExists ; if ( null === $ tableExists ) { $ tableExists = \ System :: getContainer ( ) -> get ( 'database_connection' ) -> getSchemaManager ( ) -> tablesExist ( [ 'tl_metamodel' ] ) ; } if ( false === $ tableExists ) { return ; } $ this -> handleMetaModelTable ( $ tableName ) ; $ this -> handleNonMetaModelTable ( $ tableName ) ; }
6533	protected function getConnectionFactory ( $ type ) { if ( false === isset ( $ this -> connectionFactories [ $ type ] ) ) { throw new \ InvalidArgumentException ( "Missing connection factory \"$type\"" ) ; } return $ this -> connectionFactories [ $ type ] ; }
7987	public function setSnapshotProperties ( $ domain , array $ properties ) { $ domain = ( string ) $ domain ; if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; if ( ! $ properties || ! is_array ( $ properties ) || count ( $ properties ) == 0 ) throw new BadMethodCallException ( 'Parameter $properties must be a non empty array.' ) ; $ qr = '' ; foreach ( $ properties as $ k => $ v ) { $ qr .= $ k . '=' . $ v . '&' ; } $ qr = substr ( $ qr , 0 , strlen ( $ qr ) - 1 ) ; try { $ r = $ this -> put ( 'vps/' . $ domain . '/snapshot/?' . $ qr ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new VpsException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r ; }
8638	public function setOrderFeeAdjustmentList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'OrderFeeAdjustmentList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
12673	public function setSourceFiles ( $ value ) { foreach ( $ value as $ key => $ settings ) { if ( $ settings === false ) { $ this -> _sourceFiles [ $ key ] = false ; continue ; } if ( ! isset ( $ settings [ 'class' ] ) ) { $ settings [ 'class' ] = $ this -> sourceFileClass ; } $ settings [ 'id' ] = $ key ; $ this -> _sourceFiles [ $ key ] = Yii :: createObject ( $ settings ) ; } }
5426	private function forceToExpectation ( $ exception ) { if ( $ exception === false ) { return new AnythingExpectation ( ) ; } if ( ! SimpleExpectation :: isExpectation ( $ exception ) ) { return new ExceptionExpectation ( $ exception ) ; } return $ exception ; }
2600	public function peek ( ) { if ( isset ( $ this -> tokens [ $ this -> position + $ this -> peek ] ) ) { return $ this -> tokens [ $ this -> position + $ this -> peek ++ ] ; } else { return null ; } }
3650	protected function getTemplate ( $ strTemplate , $ strFormat = 'html5' , $ blnFailIfNotFound = false ) { $ strTemplate = basename ( $ strTemplate ) ; $ strCustom = 'templates' ; if ( TL_MODE == 'FE' ) { $ tmpDir = str_replace ( '../' , '' , $ GLOBALS [ 'objPage' ] -> templateGroup ) ; if ( ! empty ( $ tmpDir ) ) { $ strCustom = $ tmpDir ; } } try { return \ TemplateLoader :: getPath ( $ strTemplate , $ strFormat , $ strCustom ) ; } catch ( \ Exception $ exception ) { if ( $ blnFailIfNotFound ) { throw new \ RuntimeException ( sprintf ( 'Could not find template %s.%s' , $ strTemplate , $ strFormat ) , 1 , $ exception ) ; } } return null ; }
9101	private function listen ( ) { if ( ! @ socket_listen ( $ this -> handle , 5 ) ) { $ code = socket_last_error ( $ this -> handle ) ; throw new SocketException ( socket_strerror ( $ code ) , array ( ) , $ code ) ; } }
5396	public function paintSkip ( $ message ) { parent :: paintSkip ( $ message ) ; print $ this -> getIndent ( 1 ) ; print '<' . $ this -> namespace . 'skip>' ; print $ this -> toParsedXml ( $ message ) ; print '</' . $ this -> namespace . "skip>\n" ; }
11054	public static function printts ( $ datatree , $ containers , $ entry = 'main' ) { $ this -> printt ( $ datatree , $ containers , $ entry , _ETS_STRING_READ , '' , '' ) ; }
370	protected function isEmpty ( $ value ) { return $ value === '' || $ value === [ ] || $ value === null || is_string ( $ value ) && trim ( $ value ) === '' ; }
11343	public function addField ( FormField $ field ) { $ this -> fields [ ] = $ field ; if ( $ field -> getName ( ) == null ) { $ field -> setName ( 'name_' . count ( $ this -> fields ) ) ; } if ( $ field -> getId ( ) == null ) { $ field -> setId ( 'id_' . count ( $ this -> fields ) ) ; } if ( $ field instanceof FileField ) { $ this -> formTags [ 'enctype' ] = 'multipart/form-data' ; } }
4722	public function setText ( $ text ) { $ this -> text = $ text ; if ( ! $ this -> text instanceof Text ) { $ this -> text = new Text ( $ this -> text ) ; } return $ this ; }
4271	public function rename ( $ pathFrom , $ pathTo ) { self :: restorePrev ( ) ; $ success = \ rename ( $ pathFrom , $ pathTo ) ; self :: register ( ) ; return $ success ; }
1649	public function getLats ( ) : array { $ lats = [ ] ; foreach ( $ this -> points as $ point ) { $ lats [ ] = $ point -> getLat ( ) ; } return $ lats ; }
11031	protected function ensureFieldIds ( ) { if ( $ this -> submitModelName ) { $ formName = Inflector :: slug ( $ this -> submitModelName , '_' ) ; } else { $ model = new \ ReflectionClass ( $ this -> model ) ; $ formName = $ model -> getShortName ( ) ; } $ parts = [ ] ; preg_match_all ( '/{([^}]+)}/' , $ this -> template , $ parts ) ; $ keys = array_flip ( $ parts [ 1 ] ) ; $ fieldIds = [ ] ; if ( isset ( $ keys [ 'country' ] ) ) { $ fieldIds [ 'country' ] = $ formName . '_country_id' ; } if ( isset ( $ keys [ 'state' ] ) ) { $ fieldIds [ 'state' ] = $ formName . '_state_id' ; } if ( isset ( $ keys [ 'region' ] ) ) { $ fieldIds [ 'region' ] = $ formName . '_region_id' ; } if ( isset ( $ keys [ 'city' ] ) ) { $ fieldIds [ 'city' ] = $ formName . '_city_id' ; } if ( isset ( $ keys [ 'address' ] ) ) { $ fieldIds [ 'address' ] = $ formName . '_address' ; } if ( isset ( $ keys [ 'postalCode' ] ) ) { $ fieldIds [ 'postal_code' ] = $ formName . '_postal_code' ; } if ( isset ( $ keys [ 'geolocation' ] ) ) { $ fieldIds [ 'latitude' ] = $ formName . '_latitude' ; $ fieldIds [ 'longitude' ] = $ formName . '_longitude' ; } $ this -> fieldIds = $ fieldIds ; }
476	public function createTable ( $ table , $ columns , $ options = null ) { $ time = $ this -> beginCommand ( "create table $table" ) ; $ this -> db -> createCommand ( ) -> createTable ( $ table , $ columns , $ options ) -> execute ( ) ; foreach ( $ columns as $ column => $ type ) { if ( $ type instanceof ColumnSchemaBuilder && $ type -> comment !== null ) { $ this -> db -> createCommand ( ) -> addCommentOnColumn ( $ table , $ column , $ type -> comment ) -> execute ( ) ; } } $ this -> endCommand ( $ time ) ; }
3555	protected function castValue ( ) { $ value = $ this -> attributes [ 'meta_value' ] ; $ validTypes = [ 'boolean' , 'integer' , 'float' , 'double' , 'array' , 'object' , 'null' ] ; if ( in_array ( $ this -> attributes [ 'meta_type' ] , $ validTypes ) ) { settype ( $ value , $ this -> attributes [ 'meta_type' ] ) ; } return $ value ; }
11638	public function getAuthorities ( ) { $ authorities = [ ] ; foreach ( $ this -> getAll ( ) as $ typeItem ) { if ( isset ( $ typeItem -> object ) && $ typeItem -> object -> getBehavior ( 'Authority' ) !== null ) { $ authorities [ $ typeItem -> object -> systemId ] = $ typeItem -> object ; } } return $ authorities ; }
1599	protected function authenticate ( ) { if ( empty ( $ this -> guards ) && Auth :: check ( ) ) { return ; } foreach ( $ this -> guards as $ guard ) { if ( Auth :: guard ( $ guard ) -> check ( ) ) { Auth :: shouldUse ( $ guard ) ; return ; } } throw new AuthenticationException ( 'Unauthenticated.' , $ this -> guards ) ; }
5196	public function addSearchResult ( $ index , $ type , array $ documents ) { $ result = [ 'took' => 5 , 'timed_out' => false , '_shards' => [ 'total' => 5 , 'successful' => 5 , 'failed' => 0 ] , 'hits' => [ 'total' => count ( $ documents ) , 'max_score' => 1 , 'hits' => [ ] ] ] ; foreach ( $ documents as $ document ) { $ result [ 'hits' ] [ 'hits' ] [ ] = [ '_index' => $ index , '_type' => $ type , '_id' => $ document [ 'id' ] , '_score' => 1 , '_source' => $ document ] ; } return $ this -> addResult ( 'search' , $ result ) ; }
11568	public function count ( ) { if ( is_null ( $ this -> recordSet ) ) { $ this -> fetchData ( ) ; } if ( is_null ( $ this -> recordcount ) ) { $ this -> recordcount = $ this -> recordSet -> RecordCount ( ) ; } return $ this -> recordcount ; }
8244	public function login ( $ id , $ userData ) { $ this -> abortIfExpired ( $ id , $ userData ) ; $ u = new User ( ) ; $ u -> setAuthenticated ( true ) ; $ u -> setAuthenticator ( $ this -> getName ( ) ) ; $ u -> setId ( $ id ) ; if ( isset ( $ userData [ 'groups' ] ) ) { $ u -> setGroups ( $ userData [ 'groups' ] ) ; } if ( isset ( $ userData [ 'displayName' ] ) ) { $ u -> setDisplayName ( $ userData [ 'displayName' ] ) ; } if ( isset ( $ userData [ 'attributes' ] ) ) { foreach ( $ userData [ 'attributes' ] as $ key => $ value ) { $ u -> setAttribute ( $ key , $ value ) ; } } $ this -> picoAuth -> setUser ( $ u ) ; }
7969	public function getVoiceConsumptions ( $ params = null ) { $ consumptionList = json_decode ( self :: getClient ( ) -> getVoiceConsumptions ( $ this -> service , $ this -> billingAccount , $ params ) ) ; $ consumptions = array ( ) ; foreach ( $ consumptionList as $ consumption ) { $ consumptions [ ] = new VoiceConsumption ( $ consumption , $ this ) ; } return $ consumptions ; }
4898	private static function checkCache ( array $ configuration ) { $ config = $ configuration [ 'module_listener_options' ] ; $ options = new ListenerOptions ( $ config ) ; $ cache = new ClearCacheService ( $ options ) ; $ cache -> checkCache ( ) ; }
188	private function getColumnDefinition ( $ table , $ column ) { $ row = $ this -> db -> createCommand ( 'SHOW CREATE TABLE ' . $ this -> db -> quoteTableName ( $ table ) ) -> queryOne ( ) ; if ( $ row === false ) { throw new Exception ( "Unable to find column '$column' in table '$table'." ) ; } if ( isset ( $ row [ 'Create Table' ] ) ) { $ sql = $ row [ 'Create Table' ] ; } else { $ row = array_values ( $ row ) ; $ sql = $ row [ 1 ] ; } $ sql = preg_replace ( '/^[^(]+\((.*)\).*$/' , '\1' , $ sql ) ; $ sql = str_replace ( ', [' , ",\n[" , $ sql ) ; if ( preg_match_all ( '/^\s*\[(.*?)\]\s+(.*?),?$/m' , $ sql , $ matches ) ) { foreach ( $ matches [ 1 ] as $ i => $ c ) { if ( $ c === $ column ) { return $ matches [ 2 ] [ $ i ] ; } } } return null ; }
7572	public function post ( Array $ postVars , Array $ headers , $ url = null ) { try { $ this -> guzzleResponse = $ this -> _client -> request ( 'POST' , $ url , array ( 'multipart' => $ postVars , 'headers' => $ headers ) ) ; } catch ( RequestException $ e ) { throw new GreenhouseAPIResponseException ( $ e -> getMessage ( ) , 0 , $ e ) ; } return ( string ) $ this -> guzzleResponse -> getBody ( ) ; }
2545	protected function makeDomXpath ( $ response ) { $ domDoc = $ this -> loadDomDocument ( $ response ) ; $ domXpath = new \ DOMXPath ( $ domDoc ) ; $ domXpath -> registerNamespace ( self :: XMLNS_PREFIX , $ domDoc -> documentElement -> lookupNamespaceUri ( null ) ) ; return $ domXpath ; }
8573	public function listRecommendationsByNextToken ( $ request ) { if ( ! ( $ request instanceof MWSRecommendationsSectionService_Model_ListRecommendationsByNextTokenRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/ListRecommendationsByNextTokenRequest.php' ) ; $ request = new MWSRecommendationsSectionService_Model_ListRecommendationsByNextTokenRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListRecommendationsByNextToken' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/ListRecommendationsByNextTokenResponse.php' ) ; $ response = MWSRecommendationsSectionService_Model_ListRecommendationsByNextTokenResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
12251	public function getNode ( $ strName , $ varDefault = false ) { $ varResult = $ this -> $ strName ; if ( ( $ varResult !== false ) && ( ( string ) $ varResult !== '' ) ) { return ( string ) $ varResult ; } else { return $ varDefault ; } }
10531	public function count ( ) { if ( is_array ( $ this -> items ) && $ this -> items !== null ) { return count ( $ this -> items ) ; } return 0 ; }
1271	public function noCandidates ( ) { if ( AddressValidation :: REQUEST_OPTION_ADDRESS_CLASSIFICATION == $ this -> requestAction ) { throw new \ BadMethodCallException ( __METHOD__ . ' should not be called on Address Classification only requests.' ) ; } return isset ( $ this -> response -> NoCandidatesIndicator ) ; }
7110	protected function getTicketFromEvent ( ResourceEventInterface $ event ) { $ ticket = $ event -> getResource ( ) ; if ( ! $ ticket instanceof TicketInterface ) { throw new UnexpectedValueException ( "Expected instance of " . TicketInterface :: class ) ; } return $ ticket ; }
11871	public function buildForm ( FormBuilderInterface $ builder , CustomField $ customField ) { $ options = $ customField -> getOptions ( ) ; $ type = ( $ options [ self :: MAX_LENGTH ] < 256 ) ? 'text' : 'textarea' ; $ attrArray = array ( ) ; if ( array_key_exists ( self :: MULTIPLE_CF_INLINE , $ options ) and $ options [ self :: MULTIPLE_CF_INLINE ] ) { $ attrArray [ 'class' ] = 'multiple-cf-inline' ; } $ builder -> add ( $ customField -> getSlug ( ) , $ type , array ( 'label' => $ this -> translatableStringHelper -> localize ( $ customField -> getName ( ) ) , 'required' => false , 'attr' => $ attrArray ) ) ; }
7787	public function setAccountClass ( $ accountClass ) { if ( ! is_callable ( $ accountClass ) && ! class_exists ( $ accountClass ) ) { throw new \ InvalidArgumentException ( '$accountClass must be a valid classname or a PHP callable' ) ; } $ this -> accountClass = $ accountClass ; return $ this ; }
8995	protected function addActions ( SymfonyController $ controller , Resource $ resource , $ chainName = '' ) { $ actions = array ( ) ; $ chainName = $ chainName . '_' . strtolower ( str_replace ( array ( '{' , '}' ) , '' , $ resource -> getDisplayName ( ) ) ) ; foreach ( $ resource -> getMethods ( ) as $ method ) { $ actionName = strtolower ( $ method -> getType ( ) ) . str_replace ( ' ' , '' , ucwords ( str_replace ( '_' , ' ' , $ chainName ) ) ) . 'Action' ; $ route = new SymfonyRoute ( $ resource -> getUri ( ) , strtolower ( $ method -> getType ( ) . $ chainName ) ) ; $ action = new SymfonyAction ( $ actionName , $ route , $ method -> getType ( ) , $ method -> getDescription ( ) ) ; preg_match_all ( '/\{[a-zA-Z]+\}/' , $ resource -> getUri ( ) , $ parameters ) ; foreach ( $ parameters [ 0 ] as $ parameter ) { $ action -> addParameter ( substr ( $ parameter , 1 , strlen ( $ parameter ) - 2 ) ) ; } if ( $ method -> getResponses ( ) ) { foreach ( $ method -> getResponses ( ) as $ code => $ response ) { $ headers = array ( ) ; foreach ( $ response -> getHeaders ( ) as $ key => $ value ) { if ( isset ( $ value [ 'required' ] ) && $ value [ 'required' ] ) { $ headers [ $ key ] = isset ( $ value [ 'example' ] ) ? $ value [ 'example' ] : '' ; } } $ _response = new SymfonyResponse ( $ code , $ headers ) ; foreach ( $ this -> config [ 'allowed_response_types' ] as $ allowedResponsetype ) { if ( null !== $ example = $ response -> getExampleByType ( $ allowedResponsetype ) ) { $ _response -> addContent ( new SymfonyResponseContent ( $ allowedResponsetype , str_replace ( array ( "\r\n" , "\n" , "\r" , "\t" , " " ) , '' , $ example ) ) ) ; } } $ action -> addResponse ( $ _response ) ; } } $ controller -> addAction ( $ action ) ; } foreach ( $ resource -> getResources ( ) as $ subresource ) { $ this -> addActions ( $ controller , $ subresource , $ chainName ) ; } }
11771	private function retryCommandOnFailure ( CommandInterface $ command , $ method ) { $ retries = 0 ; SENTINEL_RETRY : { try { $ response = $ this -> getConnectionByCommand ( $ command ) -> $ method ( $ command ) ; } catch ( CommunicationException $ exception ) { $ this -> wipeServerList ( ) ; $ exception -> getConnection ( ) -> disconnect ( ) ; if ( $ retries == $ this -> retryLimit ) { throw $ exception ; } usleep ( $ this -> retryWait * 1000 ) ; ++ $ retries ; goto SENTINEL_RETRY ; } } return $ response ; }
7802	protected function statement ( $ text ) { $ text = trim ( $ text ) ; if ( ( $ pos = strpos ( $ text , ':20:' ) ) === false ) { throw new \ RuntimeException ( 'Not an MT940 statement' ) ; } $ this -> statementHeader ( substr ( $ text , 0 , $ pos ) ) ; return $ this -> statementBody ( substr ( $ text , $ pos ) ) ; }
223	protected function normalizeNumericStringValue ( $ value ) { $ powerPosition = strrpos ( $ value , 'E' ) ; if ( $ powerPosition !== false ) { $ valuePart = substr ( $ value , 0 , $ powerPosition ) ; $ powerPart = substr ( $ value , $ powerPosition + 1 ) ; } else { $ powerPart = null ; $ valuePart = $ value ; } $ separatorPosition = strrpos ( $ valuePart , '.' ) ; if ( $ separatorPosition !== false ) { $ integerPart = substr ( $ valuePart , 0 , $ separatorPosition ) ; $ fractionalPart = substr ( $ valuePart , $ separatorPosition + 1 ) ; } else { $ integerPart = $ valuePart ; $ fractionalPart = null ; } $ integerPart = preg_replace ( '/^\+?(-?)0*(\d+)$/' , '$1$2' , $ integerPart ) ; $ integerPart = preg_replace ( '/^\+?(-?)0*$/' , '${1}0' , $ integerPart ) ; if ( $ fractionalPart !== null ) { $ fractionalPart = rtrim ( $ fractionalPart , '0' ) ; if ( empty ( $ fractionalPart ) ) { $ fractionalPart = $ powerPart !== null ? '0' : null ; } } $ normalizedValue = $ integerPart ; if ( $ fractionalPart !== null ) { $ normalizedValue .= '.' . $ fractionalPart ; } elseif ( $ normalizedValue === '-0' ) { $ normalizedValue = '0' ; } if ( $ powerPart !== null ) { $ normalizedValue .= 'E' . $ powerPart ; } return $ normalizedValue ; }
12885	public function getReverseKeyTranslation ( $ localObject ) { $ key = is_object ( $ localObject ) ? $ localObject -> primaryKey : $ localObject ; if ( $ this -> settings [ 'universalKey' ] ) { return KeyTranslation :: find ( ) -> where ( [ 'registry_id' => $ key ] ) -> one ( ) ; } else { return KeyTranslation :: find ( ) -> where ( [ 'registry_id' => $ key , 'data_interface_id' => $ this -> module -> collectorItem -> interfaceObject -> primaryKey ] ) -> one ( ) ; } }
5350	public function setMailBoxPassword ( $ domainName , $ mailBox , $ password ) { return $ this -> call ( self :: SERVICE , 'setMailBoxPassword' , [ $ domainName , $ mailBox , $ password ] ) ; }
5897	public function listVideoTemplates ( CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/templates/videos' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new VideoTemplate ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
4027	protected function getLabelComment ( ModelInterface $ model , TranslatorInterface $ translator ) { if ( $ model -> getProperty ( 'comment' ) ) { return sprintf ( $ translator -> translate ( 'typedesc._comment_' , 'tl_metamodel_filtersetting' ) , StringUtil :: specialchars ( $ model -> getProperty ( 'comment' ) ) ) ; } return '' ; }
10408	public function addDocumentParameter ( $ field , $ value ) { $ this -> documentParamCache [ md5 ( $ value . $ field ) ] = [ $ field , $ value ] ; }
7515	function next_pos ( $ needle , $ callback = true ) { $ this -> token_start = $ this -> pos ; if ( ( $ this -> pos < $ this -> size ) && ( ( $ p = stripos ( $ this -> doc , $ needle , $ this -> pos + 1 ) ) !== false ) ) { $ len = $ p - $ this -> pos - 1 ; if ( $ len > 0 ) { $ str = substr ( $ this -> doc , $ this -> pos + 1 , $ len ) ; if ( ( $ l = strrpos ( $ str , "\n" ) ) !== false ) { ++ $ this -> line_pos [ 0 ] ; $ this -> line_pos [ 1 ] = $ l + $ this -> pos + 1 ; $ len -= $ l ; if ( $ len > 0 ) { $ str = substr ( $ str , 0 , - $ len ) ; $ this -> line_pos [ 0 ] += substr_count ( $ str , "\n" ) ; } } } $ this -> pos = $ p ; if ( $ callback && isset ( $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ) { if ( is_string ( $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ) { return ( $ this -> token = $ this -> { $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] } ( ) ) ; } else { return ( $ this -> token = $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ; } } else { return ( $ this -> token = self :: TOK_UNKNOWN ) ; } } else { $ this -> pos = $ this -> size ; return ( $ this -> token = self :: TOK_NULL ) ; } }
1596	protected function validateAttributes ( ) : bool { if ( ! $ this -> dataHas ( 'attributes' ) ) { return true ; } $ attrs = $ this -> dataGet ( 'attributes' ) ; if ( ! is_object ( $ attrs ) ) { $ this -> memberNotObject ( '/data' , 'attributes' ) ; return false ; } $ disallowed = collect ( [ 'type' , 'id' ] ) -> filter ( function ( $ field ) use ( $ attrs ) { return property_exists ( $ attrs , $ field ) ; } ) ; $ this -> memberFieldsNotAllowed ( '/data' , 'attributes' , $ disallowed ) ; return $ disallowed -> isEmpty ( ) ; }
4013	protected function calculate ( ) { if ( ! $ this -> isDirty ( ) ) { return ; } $ this -> isDirty = false ; $ this -> calculatedOffset = null ; $ this -> calculatedLimit = null ; if ( $ this -> isLimited ( ) ) { if ( $ this -> getLimit ( ) ) { $ this -> calculatedLimit = $ this -> getLimit ( ) ; } if ( $ this -> getOffset ( ) ) { $ this -> calculatedOffset = $ this -> getOffset ( ) ; } } if ( $ this -> getPerPage ( ) > 0 ) { $ this -> calculatePaginated ( ) ; return ; } if ( $ this -> calculatedLimit === null ) { $ this -> calculatedLimit = 0 ; } if ( $ this -> calculatedOffset === null ) { $ this -> calculatedOffset = 0 ; } }
6577	public function getList ( $ sort = null ) { $ countries = $ this -> getCountries ( ) ; $ validSorts = array ( 'name' , 'fullname' , 'iso_3166_2' , 'iso_3166_3' , 'capital' , 'citizenship' , 'currency' , 'currency_code' , 'calling_code' ) ; if ( ! is_null ( $ sort ) && in_array ( $ sort , $ validSorts ) ) { uasort ( $ countries , function ( $ a , $ b ) use ( $ sort ) { if ( ! isset ( $ a [ $ sort ] ) && ! isset ( $ b [ $ sort ] ) ) { return 0 ; } elseif ( ! isset ( $ a [ $ sort ] ) ) { return - 1 ; } elseif ( ! isset ( $ b [ $ sort ] ) ) { return 1 ; } else { return strcasecmp ( $ a [ $ sort ] , $ b [ $ sort ] ) ; } } ) ; } return $ countries ; }
11565	private function getApp ( ) { if ( is_null ( $ this -> app ) ) { $ this -> app = \ Concrete \ Core \ Support \ Facade \ Application :: getFacadeApplication ( ) ; } return $ this -> app ; }
5747	protected function validateWhere ( array $ whereColumnsInfo ) { foreach ( $ whereColumnsInfo as $ columnNameSql => $ columnWhereInfo ) { if ( ! in_array ( $ columnNameSql , static :: SELECT_COLUMNS ) ) { throw new \ Exception ( "Invalid where column $columnNameSql" ) ; } } }
7619	public function setPermissionSet ( $ value = array ( ) ) { foreach ( $ value as $ url ) { if ( strpos ( $ url , $ this -> accountName ) === false ) { throw new Exception ( 'The permission set can only contain URLs for the account name specified in the Credentials_SharedAccessSignature instance.' ) ; } } $ this -> permissionSet = $ value ; }
927	private function getCommentBlock ( Tokens $ tokens , $ index ) { $ commentType = $ this -> getCommentType ( $ tokens [ $ index ] -> getContent ( ) ) ; $ empty = $ this -> isEmptyComment ( $ tokens [ $ index ] -> getContent ( ) ) ; $ start = $ index ; $ count = \ count ( $ tokens ) ; ++ $ index ; for ( ; $ index < $ count ; ++ $ index ) { if ( $ tokens [ $ index ] -> isComment ( ) ) { if ( $ commentType !== $ this -> getCommentType ( $ tokens [ $ index ] -> getContent ( ) ) ) { break ; } if ( $ empty ) { $ empty = $ this -> isEmptyComment ( $ tokens [ $ index ] -> getContent ( ) ) ; } continue ; } if ( ! $ tokens [ $ index ] -> isWhitespace ( ) || $ this -> getLineBreakCount ( $ tokens , $ index , $ index + 1 ) > 1 ) { break ; } } return [ $ start , $ index - 1 , $ empty ] ; }
2197	public function onAuthenticationSuccess ( Request $ request , TokenInterface $ token ) : RedirectResponse { $ this -> user = $ token -> getUser ( ) ; if ( ! $ this -> user instanceof User ) { return $ this -> getRedirectResponse ( $ request ) ; } $ this -> user -> lastLogin = $ this -> user -> currentLogin ; $ this -> user -> currentLogin = time ( ) ; $ this -> user -> save ( ) ; if ( null !== $ this -> logger ) { $ this -> logger -> info ( sprintf ( 'User "%s" has logged in' , $ this -> user -> username ) , [ 'contao' => new ContaoContext ( __METHOD__ , ContaoContext :: ACCESS , $ this -> user -> username ) ] ) ; } $ this -> triggerPostLoginHook ( ) ; return $ this -> getRedirectResponse ( $ request ) ; }
10919	public static function getArray ( $ language ) { $ fileName = __DIR__ . '/stop-words/' . $ language . '.txt' ; if ( file_exists ( $ fileName ) ) { return array_map ( 'trim' , file ( $ fileName ) ) ; } return [ ] ; }
6529	public static function findOneUsingMixin ( $ mixin ) : Schema { $ schemas = self :: findAllUsingMixin ( $ mixin ) ; if ( 1 !== count ( $ schemas ) ) { throw new MoreThanOneMessageForMixin ( $ mixin , $ schemas ) ; } return current ( $ schemas ) ; }
4884	public function addDependencies ( $ name , $ entities = null , array $ options = null ) { return $ this -> dependencyResultCollection -> add ( $ name , $ entities , $ options ) ; }
12711	public function register ( $ alias , $ abstract ) { if ( ! is_string ( $ alias ) || ! is_string ( $ abstract ) ) { throw new \ InvalidArgumentException ( sprintf ( "Parameter 1 and 2 of %s must be a string." , __METHOD__ ) ) ; } if ( ! isset ( $ this -> aliases [ $ alias ] ) ) { $ this -> aliases [ $ alias ] = $ this -> make ( $ abstract ) ; } return $ this ; }
9579	public function setChannel ( $ channel , LoggerInterface $ logger ) { if ( isset ( $ this -> channels [ $ channel ] ) ) { throw new InvalidArgumentException ( "Channel $channel is already defined" ) ; } $ this -> channels [ $ channel ] = $ logger ; }
9794	public function getDataValidation ( ) { if ( ! isset ( $ this -> parent ) ) { throw new Exception ( 'Cannot get data validation for cell that is not bound to a worksheet' ) ; } return $ this -> getWorksheet ( ) -> getDataValidation ( $ this -> getCoordinate ( ) ) ; }
9204	public static function get ( $ item ) { $ item = strtoupper ( $ item ) ; $ config = json_decode ( file_get_contents ( dirname ( __FILE__ ) . "/Config.json" ) , true ) ; if ( ! isset ( $ config [ $ item ] ) ) { throw new InvalidConfigItemException ( "Invalid Endpoint Requested!" ) ; } return $ config [ $ item ] ; }
1040	public function processPsrRequest ( ServerRequestInterface $ request , ResponseInterface $ response , StreamInterface $ writableBodyStream ) { $ result = $ this -> executePsrRequest ( $ request ) ; return $ this -> helper -> toPsrResponse ( $ result , $ response , $ writableBodyStream ) ; }
10546	public function setRequest ( Request $ request ) { $ this -> request = $ request ; $ this -> app = null ; $ this -> vhost = null ; $ this -> route = null ; $ this -> setVariable ( 'request' , $ request ) ; return $ this ; }
12319	public function redirect ( string $ shortURLKey ) { $ record = HCShortURL :: where ( 'short_url_key' , $ shortURLKey ) -> first ( ) ; if ( ! $ record ) abort ( 404 ) ; $ record -> increment ( 'clicks' ) ; return redirect ( $ record -> url ) ; }
2394	public function addString ( $ strData , $ strName , $ intTime = 0 ) { ++ $ this -> intCount ; $ strName = strtr ( $ strName , '\\' , '/' ) ; $ arrFile [ 'file_signature' ] = self :: FILE_SIGNATURE ; $ arrFile [ 'version_needed_to_extract' ] = "\x14\x00" ; $ arrFile [ 'general_purpose_bit_flag' ] = "\x00\x00" ; $ arrFile [ 'compression_method' ] = "\x08\x00" ; $ arrFile [ 'last_mod_file_hex' ] = $ this -> unixToHex ( $ intTime ) ; $ arrFile [ 'crc-32' ] = pack ( 'V' , crc32 ( $ strData ) ) ; $ intUncompressed = \ strlen ( $ strData ) ; $ strData = gzcompress ( $ strData ) ; $ strData = substr ( substr ( $ strData , 0 , - 4 ) , 2 ) ; $ intCompressed = \ strlen ( $ strData ) ; $ arrFile [ 'compressed_size' ] = pack ( 'V' , $ intCompressed ) ; $ arrFile [ 'uncompressed_size' ] = pack ( 'V' , $ intUncompressed ) ; $ arrFile [ 'file_name_length' ] = pack ( 'v' , \ strlen ( $ strName ) ) ; $ arrFile [ 'extra_field_length' ] = "\x00\x00" ; $ arrFile [ 'file_name' ] = $ strName ; $ arrFile [ 'extra_field' ] = '' ; $ intOffset = @ ftell ( $ this -> resFile ) ; fwrite ( $ this -> resFile , implode ( '' , $ arrFile ) ) ; fwrite ( $ this -> resFile , $ strData ) ; $ arrHeader [ 'header_signature' ] = self :: CENTRAL_DIR_START ; $ arrHeader [ 'version_made_by' ] = "\x00\x00" ; $ arrHeader [ 'version_needed_to_extract' ] = $ arrFile [ 'version_needed_to_extract' ] ; $ arrHeader [ 'general_purpose_bit_flag' ] = $ arrFile [ 'general_purpose_bit_flag' ] ; $ arrHeader [ 'compression_method' ] = $ arrFile [ 'compression_method' ] ; $ arrHeader [ 'last_mod_file_hex' ] = $ arrFile [ 'last_mod_file_hex' ] ; $ arrHeader [ 'crc-32' ] = $ arrFile [ 'crc-32' ] ; $ arrHeader [ 'compressed_size' ] = $ arrFile [ 'compressed_size' ] ; $ arrHeader [ 'uncompressed_size' ] = $ arrFile [ 'uncompressed_size' ] ; $ arrHeader [ 'file_name_length' ] = $ arrFile [ 'file_name_length' ] ; $ arrHeader [ 'extra_field_length' ] = $ arrFile [ 'extra_field_length' ] ; $ arrHeader [ 'file_comment_length' ] = "\x00\x00" ; $ arrHeader [ 'disk_number_start' ] = "\x00\x00" ; $ arrHeader [ 'internal_file_attributes' ] = "\x00\x00" ; $ arrHeader [ 'external_file_attributes' ] = pack ( 'V' , 32 ) ; $ arrHeader [ 'offset_of_local_header' ] = pack ( 'V' , $ intOffset ) ; $ arrHeader [ 'file_name' ] = $ arrFile [ 'file_name' ] ; $ arrHeader [ 'extra_field' ] = $ arrFile [ 'extra_field' ] ; $ arrHeader [ 'file_comment' ] = '' ; $ this -> strCentralDir .= implode ( '' , $ arrHeader ) ; }
1749	protected function import ( $ strClass , $ strKey = null , $ blnForce = false ) { $ strKey = $ strKey ? : $ strClass ; if ( \ is_object ( $ strKey ) ) { $ strKey = \ get_class ( $ strClass ) ; } if ( $ blnForce || ! isset ( $ this -> arrObjects [ $ strKey ] ) ) { $ container = static :: getContainer ( ) ; if ( \ is_object ( $ strClass ) ) { $ this -> arrObjects [ $ strKey ] = $ strClass ; } elseif ( $ container -> has ( $ strClass ) && ( strpos ( $ strClass , '\\' ) !== false || ! class_exists ( $ strClass ) ) ) { $ this -> arrObjects [ $ strKey ] = $ container -> get ( $ strClass ) ; } elseif ( $ container instanceof Container && isset ( $ container -> getRemovedIds ( ) [ $ strClass ] ) ) { throw new ServiceNotFoundException ( $ strClass , null , null , array ( ) , sprintf ( 'The "%s" service or alias has been removed or inlined when the container was compiled. You should either make it public, or stop using the container directly and use dependency injection instead.' , $ strClass ) ) ; } elseif ( \ in_array ( 'getInstance' , get_class_methods ( $ strClass ) ) ) { $ this -> arrObjects [ $ strKey ] = \ call_user_func ( array ( $ strClass , 'getInstance' ) ) ; } else { $ this -> arrObjects [ $ strKey ] = new $ strClass ( ) ; } } }
5134	private static function createUri ( string $ scheme , string $ host , ? int $ port , string $ user , string $ password , string $ path , string $ query , string $ fragment ) : \ One \ Uri { return new Uri ( $ scheme , $ host , $ port , $ path , $ query , $ fragment , $ user , $ password ) ; }
10915	protected function findController ( $ object ) { $ urlargs = $ this -> arguments ; $ arg = $ urlargs -> shift ( ) ; $ controller = $ arg ; if ( ( $ pos = strpos ( $ controller , '.' ) ) !== false ) $ controller = substr ( $ controller , 0 , $ pos ) ; if ( ! method_exists ( $ object , $ controller ) ) { if ( method_exists ( $ object , "index" ) ) { if ( $ controller !== null ) $ urlargs -> unshift ( $ arg ) ; $ controller = "index" ; } else throw new HTTPError ( 404 , "Unknown controller: " . $ controller ) ; } return $ controller ; }
11307	public function sendMessage ( $ chatId , $ text , $ disableWebPagePreview = null , $ replyToMessageId = null , $ replyMarkup = null ) { $ response = $ this -> apiRequest ( "sendMessage" , [ "chat_id" => $ chatId , "text" => $ text , "disable_web_page_preview" => $ disableWebPagePreview , "reply_to_message_id" => $ replyToMessageId , "reply_markup" => $ replyMarkup ? $ replyMarkup -> toArray ( ) : null , ] ) ; return $ this -> entityFromBody ( $ response -> getBody ( ) , new Message ( ) ) ; }
743	private function initializeEventHandlers ( ) { $ this -> owner -> on ( Widget :: EVENT_BEFORE_RUN , [ $ this , 'beforeRun' ] ) ; $ this -> owner -> on ( Widget :: EVENT_AFTER_RUN , [ $ this , 'afterRun' ] ) ; }
7676	function TbsQuickLoad ( $ NameLst ) { if ( ! is_array ( $ NameLst ) ) $ NameLst = array ( $ NameLst ) ; $ nbr = 0 ; $ TBS = & $ this -> TBS ; foreach ( $ NameLst as $ FileName ) { $ idx = $ this -> FileGetIdx ( $ FileName ) ; if ( ( ! isset ( $ this -> TbsStoreLst [ $ idx ] ) ) && ( ! isset ( $ this -> TbsNoField [ $ idx ] ) ) ) { $ txt = $ this -> FileRead ( $ idx , true ) ; if ( strpos ( $ txt , $ TBS -> _ChrOpen ) !== false ) { $ nbr ++ ; if ( $ nbr == 1 ) { $ MergeAutoFields = $ this -> TbsMergeAutoFields ( ) ; $ SaveIdx = $ this -> TbsCurrIdx ; $ SaveName = $ TBS -> OtbsCurrFile ; $ this -> TbsSwitchMode ( true ) ; } $ this -> TbsStorePark ( ) ; $ TBS -> Source = $ txt ; unset ( $ txt ) ; $ TBS -> OtbsCurrFile = $ FileName ; $ this -> TbsCurrIdx = $ idx ; if ( $ MergeAutoFields ) $ TBS -> LoadTemplate ( null , '+' ) ; } else { $ this -> TbsNoField [ $ idx ] = true ; } } } if ( $ nbr > 0 ) { $ this -> TbsSwitchMode ( false ) ; $ this -> TbsStorePark ( ) ; $ this -> TbsStoreLoad ( $ SaveIdx , $ SaveName ) ; } return $ nbr ; }
6164	public function setData ( $ data ) { if ( is_array ( $ data ) ) { $ this -> data = $ data ; return $ this ; } $ this -> data = json_decode ( $ data , true ) ; if ( null === $ this -> data ) { $ this -> data = $ data ; } return $ this ; }
10049	private static function toArray ( $ object ) { $ type = gettype ( $ object ) ; if ( $ type == 'array' ) { foreach ( $ object as $ element ) { $ result [ ] = self :: toArray ( $ element ) ; } return $ result ; } else if ( $ type == 'object' ) { if ( is_subclass_of ( $ object , 'AbstractJSONWrapper' ) ) { return $ object -> toArray ( ) ; } else { trigger_error ( "JSONSerializer: Trying to serialize " . get_class ( $ object ) ) ; return $ object ; } } else { return $ object ; } }
5754	protected function setIndexFilter ( Request $ request , Response $ response , $ args , array $ listViewColumns , AdminListView $ view ) { $ this -> setRequestInput ( $ request , [ $ view -> getSessionFilterFieldKey ( ) ] ) ; if ( ! isset ( $ this -> requestInput [ $ view -> getSessionFilterFieldKey ( ) ] ) ) { throw new \ Exception ( "session filter input must be set" ) ; } $ this -> storeFilterFieldValueInSession ( $ view ) ; if ( null !== $ filterColumnsInfo = $ this -> getFilterColumns ( $ view -> getSessionFilterFieldKey ( ) , $ listViewColumns ) ) { $ this -> storeFilterColumnsInfoInSession ( $ filterColumnsInfo , $ view ) ; } }
10128	private function writeBreaks ( ) { $ vbreaks = [ ] ; $ hbreaks = [ ] ; foreach ( $ this -> phpSheet -> getBreaks ( ) as $ cell => $ breakType ) { $ coordinates = Coordinate :: coordinateFromString ( $ cell ) ; switch ( $ breakType ) { case \ PhpOffice \ PhpSpreadsheet \ Worksheet \ Worksheet :: BREAK_COLUMN : $ vbreaks [ ] = Coordinate :: columnIndexFromString ( $ coordinates [ 0 ] ) - 1 ; break ; case \ PhpOffice \ PhpSpreadsheet \ Worksheet \ Worksheet :: BREAK_ROW : $ hbreaks [ ] = $ coordinates [ 1 ] ; break ; case \ PhpOffice \ PhpSpreadsheet \ Worksheet \ Worksheet :: BREAK_NONE : default : break ; } } if ( ! empty ( $ hbreaks ) ) { sort ( $ hbreaks , SORT_NUMERIC ) ; if ( $ hbreaks [ 0 ] == 0 ) { array_shift ( $ hbreaks ) ; } $ record = 0x001b ; $ cbrk = count ( $ hbreaks ) ; $ length = 2 + 6 * $ cbrk ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ cbrk ) ; foreach ( $ hbreaks as $ hbreak ) { $ data .= pack ( 'vvv' , $ hbreak , 0x0000 , 0x00ff ) ; } $ this -> append ( $ header . $ data ) ; } if ( ! empty ( $ vbreaks ) ) { $ vbreaks = array_slice ( $ vbreaks , 0 , 1000 ) ; sort ( $ vbreaks , SORT_NUMERIC ) ; if ( $ vbreaks [ 0 ] == 0 ) { array_shift ( $ vbreaks ) ; } $ record = 0x001a ; $ cbrk = count ( $ vbreaks ) ; $ length = 2 + 6 * $ cbrk ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ cbrk ) ; foreach ( $ vbreaks as $ vbreak ) { $ data .= pack ( 'vvv' , $ vbreak , 0x0000 , 0xffff ) ; } $ this -> append ( $ header . $ data ) ; } }
32	public function addRule ( Rule $ rule ) { $ this -> addReason ( spl_object_hash ( $ rule ) , array ( 'rule' => $ rule , 'job' => $ rule -> getJob ( ) , ) ) ; }
1696	public static function findByIds ( $ arrIds ) { if ( empty ( $ arrIds ) || ! \ is_array ( $ arrIds ) ) { return null ; } $ objDatabase = Database :: getInstance ( ) ; $ arrIds = array_map ( '\intval' , $ arrIds ) ; $ objResult = $ objDatabase -> execute ( "SELECT *, (SELECT tstamp FROM tl_theme WHERE tl_theme.id=tl_style_sheet.pid) AS tstamp3, (SELECT MAX(tstamp) FROM tl_style WHERE tl_style.pid=tl_style_sheet.id) AS tstamp2, (SELECT COUNT(*) FROM tl_style WHERE tl_style.selector='@font-face' AND tl_style.invisible='' AND tl_style.pid=tl_style_sheet.id) AS hasFontFace FROM tl_style_sheet WHERE id IN (" . implode ( ',' , $ arrIds ) . ") ORDER BY " . $ objDatabase -> findInSet ( 'id' , $ arrIds ) ) ; return static :: createCollectionFromDbResult ( $ objResult , 'tl_style_sheet' ) ; }
11625	public function processContent ( Operation $ operation , $ data ) { if ( is_array ( $ data ) ) { $ status = $ this -> contentService -> getSocialMediaScheduleByOperation ( $ operation ) ; if ( ! $ data [ 'locations' ] instanceof ArrayCollection ) { $ locations = $ this -> em -> getRepository ( 'CampaignChainCoreBundle:Location' ) -> findById ( array_values ( $ data [ 'locations' ] ) ) ; $ locations = new ArrayCollection ( $ locations ) ; } else { $ locations = $ data [ 'locations' ] ; } $ status -> setLocations ( $ locations ) ; $ status -> setMessage ( $ data [ 'message' ] ) ; } else { $ status = $ data ; } return $ status ; }
12024	private function addConstructorMethod ( ) { $ requiredParameters = $ this -> operationDefinition -> getRequiredParams ( ) ; $ methodGenerator = new MethodGenerator ( '__construct' ) ; $ defaultParams = $ this -> operationDefinition -> getDefaultParams ( ) ; $ body = '' ; if ( count ( $ defaultParams ) ) { $ body = '$defaultParams = [' . PHP_EOL ; foreach ( $ defaultParams as $ param ) { $ body .= sprintf ( " '%s' => '%s'," , $ param -> getName ( ) , $ param -> getDefault ( ) ) ; $ body .= PHP_EOL ; } $ body .= '];' . PHP_EOL ; $ body .= '$this->setParams($defaultParams);' . PHP_EOL ; } $ constructorParams = [ ] ; $ constructorParams [ ] = new ParameterGenerator ( 'api' , $ this -> apiGenerator -> getFQCN ( ) ) ; $ body .= '$this->api = $api;' . PHP_EOL ; foreach ( $ requiredParameters as $ param ) { $ normalizedParamName = normalizeParamName ( $ param -> getName ( ) ) ; $ constructorParams [ ] = new ParameterGenerator ( $ normalizedParamName , $ param -> getType ( ) ) ; $ body .= sprintf ( "\$this->parameters['%s'] = $%s;" . PHP_EOL , $ param -> getName ( ) , $ normalizedParamName ) ; } $ methodGenerator -> setParameters ( $ constructorParams ) ; $ methodGenerator -> setBody ( $ body ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; }
4216	private function clearErrors ( $ flags ) { $ clearErrors = $ flags & Debug :: CLEAR_LOG_ERRORS || $ flags & Debug :: CLEAR_SUMMARY_ERRORS ; if ( ! $ clearErrors ) { return ; } $ errorsNotCleared = array ( ) ; $ errorsNotCleared = $ this -> clearErrorsHelper ( $ this -> data [ 'log' ] , $ flags & Debug :: CLEAR_LOG_ERRORS ) ; foreach ( \ array_keys ( $ this -> data [ 'logSummary' ] ) as $ priority ) { $ errorsNotCleared = \ array_merge ( $ this -> clearErrorsHelper ( $ this -> data [ 'logSummary' ] [ $ priority ] , $ flags & Debug :: CLEAR_SUMMARY_ERRORS ) ) ; } $ errorsNotCleared = \ array_unique ( $ errorsNotCleared ) ; $ errors = $ this -> debug -> errorHandler -> get ( 'errors' ) ; foreach ( $ errors as $ error ) { if ( ! \ in_array ( $ error [ 'hash' ] , $ errorsNotCleared ) ) { $ error [ 'inConsole' ] = false ; } } }
10322	function getSubscribersCount ( $ fromDate = null , $ toDate = null , $ mailingIds = array ( ) , $ contactIds = array ( ) , $ contactEmails = array ( ) , $ contactExternalIds = array ( ) , $ excludeAnonymousContacts = false ) { $ params = $ this -> createCountQueryParameters ( $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , $ mailingIds , null ) ; if ( isset ( $ excludeAnonymousContacts ) ) $ params [ 'exclude_anonymous_contacts' ] = ( $ excludeAnonymousContacts == true ) ? "true" : "false" ; return $ this -> get ( 'reports/subscribers/count' , $ params ) ; }
4919	public function attachInputFilterDefaults ( InputFilterInterface $ inputFilter , FieldsetInterface $ fieldset ) { parent :: attachInputFilterDefaults ( $ inputFilter , $ fieldset ) ; foreach ( $ inputFilter -> getInputs ( ) as $ name => $ input ) { if ( ! $ input instanceof InputFilterInterface ) { $ required = $ input -> isRequired ( ) ; $ inputExists = $ fieldset -> has ( $ name ) ; if ( ! $ inputExists && $ required ) { $ fieldsetName = '' ; if ( $ fieldset -> hasAttribute ( 'name' ) ) { $ fieldsetName = 'in Fieldset "' . $ fieldset -> getAttribute ( 'name' ) . '" ' ; } throw new \ RuntimeException ( 'input for "' . $ name . '" ' . $ fieldsetName . 'is required but a input-field with this name is not defined' ) ; } } } }
401	public static function processParagraph ( $ markdown , $ flavor = null ) { $ parser = static :: getParser ( $ flavor ) ; return $ parser -> parseParagraph ( $ markdown ) ; }
12797	public function mb_str_pad ( $ input , $ length , $ string = ' ' , $ type = STR_PAD_LEFT ) { return str_pad ( $ input , $ length + strlen ( $ input ) - mb_strlen ( $ input ) , $ string , $ type ) ; }
176	public static function removeValue ( & $ array , $ value ) { $ result = [ ] ; if ( is_array ( $ array ) ) { foreach ( $ array as $ key => $ val ) { if ( $ val === $ value ) { $ result [ $ key ] = $ val ; unset ( $ array [ $ key ] ) ; } } } return $ result ; }
3643	public function except ( $ keys , bool $ trim = true , bool $ clean = true ) { $ values = $ this -> request -> except ( ( array ) $ keys ) ; return $ this -> clean ( $ values , $ trim , $ clean ) ; }
9296	private function update ( $ documents , $ repository , $ commitSize ) { if ( count ( $ documents ) > $ commitSize && $ commitSize > 1 ) { $ esResponse = [ ] ; $ i = 1 ; foreach ( $ documents as $ document ) { $ id = $ document [ '_id' ] ; unset ( $ document [ '_id' ] ) ; $ this -> crud -> update ( $ repository , $ id , $ document ) ; if ( $ i ++ % ( $ commitSize - 1 ) == 0 ) { $ esResponse [ ] = $ this -> crud -> commit ( $ repository ) ; } } } else { foreach ( $ documents as $ document ) { $ id = $ document [ '_id' ] ; unset ( $ document [ '_id' ] ) ; $ this -> crud -> update ( $ repository , $ id , $ document ) ; } $ esResponse = $ this -> crud -> commit ( $ repository ) ; } return json_encode ( $ esResponse ) ; }
4470	public function complete ( ? string $ nextq = null , int $ delay = 0 , array $ depends = [ ] ) : string { if ( $ this -> completed || $ this -> failed ) { throw new JobAlreadyFinishedException ( ) ; } $ params = [ $ this -> jid , $ this -> worker , $ this -> queue , json_encode ( $ this -> data , JSON_UNESCAPED_SLASHES ) ? : '{}' ] ; if ( $ nextq ) { $ next = [ 'next' , $ nextq , 'delay' , $ delay , 'depends' , json_encode ( $ depends , JSON_UNESCAPED_SLASHES ) ] ; $ params = array_merge ( $ params , $ next ) ; } $ this -> completed = true ; return call_user_func_array ( [ $ this -> client , 'complete' ] , $ params ) ; }
10456	protected function setItem ( ItemPipelineEvent $ event ) { $ tempItem = $ event -> getItem ( ) ; if ( ! $ tempItem instanceof $ this -> importItemClass ) { $ this -> log ( "Item provided is not an {$this->importItemClass}" , LogLevel :: ERROR ) ; return false ; } $ this -> importItem = $ tempItem ; return true ; }
12904	public function setAccessToken ( $ token , $ expires = 7200 ) { $ this -> cache -> save ( $ this -> getAccessTokenCacheKey ( ) , $ token , $ expires ) ; return $ this ; }
3637	public function initApp ( ) : void { $ tmpDir = \ Swoft :: getAlias ( '@runtime' ) ; $ names = [ 'logs' , 'uploadfiles' ] ; \ output ( ) -> writeln ( 'Create runtime directories: ' . \ implode ( ',' , $ names ) ) ; foreach ( $ names as $ name ) { DirHelper :: make ( $ tmpDir . '/' . $ name ) ; } \ output ( ) -> writeln ( '<success>OK</success>' ) ; }
816	private function getMeaningfulSequence ( Tokens $ tokens , $ start , $ end ) { $ sequence = [ ] ; $ index = $ start ; while ( $ index < $ end ) { $ index = $ tokens -> getNextMeaningfulToken ( $ index ) ; if ( $ index >= $ end || null === $ index ) { break ; } $ sequence [ ] = $ tokens [ $ index ] ; } return Tokens :: fromArray ( $ sequence ) ; }
1945	public function sections ( $ key = null , $ template = null ) { if ( ! array_filter ( $ this -> sections ) ) { return ; } if ( $ key && ! isset ( $ this -> positions [ $ key ] ) ) { return ; } $ matches = array ( ) ; foreach ( $ this -> positions [ $ key ] as $ id => $ section ) { if ( ! empty ( $ this -> sections [ $ id ] ) ) { $ section [ 'content' ] = $ this -> sections [ $ id ] ; $ matches [ $ id ] = $ section ; } } if ( empty ( $ matches ) ) { return ; } $ this -> matches = $ matches ; if ( $ template === null ) { $ template = 'block_sections' ; } include $ this -> getTemplate ( $ template ) ; }
926	public function getLintErrors ( ) { return array_filter ( $ this -> errors , static function ( Error $ error ) { return Error :: TYPE_LINT === $ error -> getType ( ) ; } ) ; }
3966	public function getInputScreen ( ) { return new InputScreen ( \ System :: getContainer ( ) -> get ( 'cca.legacy_dic' ) -> getService ( 'metamodels-service-container' ) , $ this -> inputScreen [ 'meta' ] , $ this -> inputScreen [ 'properties' ] , $ this -> inputScreen [ 'conditions' ] , $ this -> inputScreen [ 'groupSort' ] ) ; }
1370	protected function bindExceptionParser ( ) { $ this -> app -> singleton ( ExceptionParserInterface :: class , ExceptionParser :: class ) ; $ this -> app -> alias ( ExceptionParserInterface :: class , 'json-api.exceptions' ) ; }
278	private function notifyUnloaded ( $ fixtures ) { $ this -> stdout ( "\nFixtures were successfully unloaded from namespace: " , Console :: FG_YELLOW ) ; $ this -> stdout ( Yii :: getAlias ( $ this -> namespace ) . "\"\n\n" , Console :: FG_GREEN ) ; $ this -> outputList ( $ fixtures ) ; }
3014	public function unlike ( $ postId , $ reblogKey ) { $ options = array ( 'id' => $ postId , 'reblog_key' => $ reblogKey ) ; return $ this -> postRequest ( 'v2/user/unlike' , $ options , false ) ; }
8212	protected function validateFile ( $ filePath , $ message = 'File' , $ allowEmpty = true ) { if ( ! file_exists ( $ filePath ) || ! is_readable ( $ filePath ) ) { throw new \ RuntimeException ( "$message '{$filePath}' doesn't exist or is not readable." ) ; } if ( ! $ allowEmpty && 0 === filesize ( $ filePath ) ) { throw new \ RuntimeException ( "$message '{$filePath}' is empty." ) ; } return realpath ( $ filePath ) ; }
6811	private function getDateFormatter ( ) { if ( $ this -> dateFormatter ) { return $ this -> dateFormatter ; } return $ this -> dateFormatter = IntlDateFormatter :: create ( $ this -> locale , IntlDateFormatter :: SHORT , IntlDateFormatter :: NONE , ini_get ( 'date.timezone' ) , IntlDateFormatter :: GREGORIAN ) ; }
8716	public static function createInLocale ( $ locale , array $ attributes = [ ] , $ translations = [ ] ) { $ model = ( new static ( $ attributes ) ) -> setLocale ( $ locale ) ; if ( $ model -> save ( ) && is_array ( $ translations ) ) { $ model -> saveTranslations ( $ translations ) ; } return $ model ; }
5130	protected function withString ( string $ string , string $ name = 'query' ) : self { $ string = ltrim ( ( string ) $ string , '#' ) ; $ clone = clone $ this ; $ clone -> { $ name } = $ this -> filterQuery ( $ string ) ; return $ clone ; }
2620	public function sendInstalledReq ( ) { $ pageViewParams = [ 'dl' => self :: GA_PAGEVIEW_URL . self :: FASTLY_INSTALLED_FLAG , 'dh' => preg_replace ( '#^https?://#' , '' , rtrim ( self :: GA_PAGEVIEW_URL , '/' ) ) , 'dp' => '/' . self :: FASTLY_INSTALLED_FLAG , 'dt' => ucfirst ( self :: FASTLY_INSTALLED_FLAG ) , 't' => self :: GA_HITTYPE_PAGEVIEW , ] ; $ this -> sendReqToGA ( $ pageViewParams , self :: GA_HITTYPE_PAGEVIEW ) ; $ eventParams = [ 'ec' => self :: GA_FASTLY_SETUP , 'ea' => 'Fastly ' . self :: FASTLY_INSTALLED_FLAG , 'el' => $ this -> getWebsiteName ( ) , 'ev' => 0 , 't' => self :: GA_HITTYPE_EVENT ] ; $ result = $ this -> sendReqToGA ( array_merge ( $ pageViewParams , $ eventParams ) ) ; return $ result ; }
4098	public function config ( $ key , $ value = null ) { if ( is_array ( $ key ) ) $ this -> config = $ key + $ this -> config ; else { if ( $ value !== null ) $ this -> config [ $ key ] = $ value ; if ( ! isset ( $ this -> config [ $ key ] ) ) throw new \ Exception ( "Configuration key `type` is not set" ) ; return $ this -> config [ $ key ] ; } }
1375	private function runCommandsWithParameters ( Collection $ commands , array $ parameters ) { foreach ( $ commands -> keys ( ) as $ command ) { if ( 0 !== $ this -> call ( $ command , $ parameters ) ) { return false ; } } return true ; }
12903	private function createCacheAdapter ( ) { $ extraData = & $ this -> extraData ; return new CallbackAdapter ( function ( Request $ request ) use ( & $ extraData ) { $ poolName = 'default' ; if ( isset ( $ this -> source [ 'cache' ] [ 'pool' ] ) ) { $ poolName = $ this -> source [ 'cache' ] [ 'pool' ] ; } $ adapter = new CacheAdapter ( $ this -> registry -> getCachePool ( $ poolName ) , new HttpApiAdapter ( ) , function ( Request $ request ) { $ data = $ request -> getData ( ) ; return $ this -> registry -> generateCacheItemKey ( sprintf ( '%s.%s.%s' , $ data [ 'service' ] , $ data [ 'group' ] , $ data [ 'action' ] ) , $ data [ 'arguments' ] ) ; } ) ; $ response = $ adapter -> receive ( $ request ) ; $ extraData = $ response -> getHeaders ( ) ; return $ response ; } ) ; }
1834	public static function findByPk ( $ varValue , array $ arrOptions = array ( ) ) { if ( empty ( $ arrOptions ) ) { $ objModel = Registry :: getInstance ( ) -> fetch ( static :: $ strTable , $ varValue ) ; if ( $ objModel !== null ) { return $ objModel ; } } $ arrOptions = array_merge ( array ( 'limit' => 1 , 'column' => static :: $ strPk , 'value' => $ varValue , 'return' => 'Model' ) , $ arrOptions ) ; return static :: find ( $ arrOptions ) ; }
8861	public function canView ( $ member = null ) { if ( ! parent :: canView ( $ member ) ) return false ; if ( $ this -> PublishDate ) { $ publishDate = $ this -> dbObject ( "PublishDate" ) ; if ( $ publishDate -> InFuture ( ) && ! Permission :: checkMember ( $ member , "VIEW_DRAFT_CONTENT" ) ) { return false ; } } return true ; }
5203	public function close ( ) { if ( isset ( $ this -> channel ) ) $ this -> channel -> close ( ) ; if ( isset ( $ this -> AMQPConnection ) ) $ this -> AMQPConnection -> close ( ) ; }
4337	private function getDefaultOutputAs ( ) { $ ret = 'html' ; $ interface = $ this -> debug -> utilities -> getInterface ( ) ; if ( $ interface == 'ajax' ) { $ ret = $ this -> cfg [ 'outputAsDefaultNonHtml' ] ; } elseif ( $ interface == 'http' ) { $ contentType = $ this -> debug -> utilities -> getResponseHeader ( ) ; if ( $ contentType && $ contentType !== 'text/html' ) { $ ret = $ this -> cfg [ 'outputAsDefaultNonHtml' ] ; } } else { $ ret = 'text' ; } return $ ret ; }
8183	public function getMemoryUsage ( ) { return isset ( $ this -> ends [ 'mu' ] ) && isset ( $ this -> starts [ 'mu' ] ) ? $ this -> ends [ 'mu' ] - $ this -> starts [ 'mu' ] : 0 ; }
4518	public function preFlush ( PreFlushEventArgs $ args ) { $ entities = $ args -> getEntityManager ( ) -> getUnitOfWork ( ) -> getScheduledEntityInsertions ( ) ; foreach ( $ entities as $ entity ) { if ( ! $ entity instanceof Parameter ) { continue ; } $ entity -> setValue ( serialize ( $ entity -> getValue ( ) ) ) ; } }
3551	public function parse ( InlineParserContext $ inlineContext ) { $ cursor = $ inlineContext -> getCursor ( ) ; $ previous = $ cursor -> peek ( - 1 ) ; if ( $ previous !== null && $ previous !== ' ' ) { return false ; } $ saved = $ cursor -> saveState ( ) ; $ cursor -> advance ( ) ; $ handle = $ cursor -> match ( '/^[a-z0-9\+\-_]+:/' ) ; if ( ! $ handle ) { $ cursor -> restoreState ( $ saved ) ; return false ; } $ next = $ cursor -> peek ( 0 ) ; if ( $ next !== null && $ next !== ' ' ) { $ cursor -> restoreState ( $ saved ) ; return false ; } $ key = substr ( $ handle , 0 , - 1 ) ; if ( $ this -> map === null ) { $ this -> map = $ this -> repo -> get ( ) ; } if ( ! array_key_exists ( $ key , $ this -> map ) ) { $ cursor -> restoreState ( $ saved ) ; return false ; } $ inline = new Image ( $ this -> map [ $ key ] , $ key ) ; $ inline -> data [ 'attributes' ] = [ 'class' => 'emoji' , 'data-emoji' => $ key ] ; $ inlineContext -> getContainer ( ) -> appendChild ( $ inline ) ; return true ; }
3654	public function purge ( ) { foreach ( $ GLOBALS [ 'TL_PURGE' ] [ 'folders' ] [ 'metamodels_assets' ] [ 'affected' ] as $ folderName ) { $ folder = new \ Folder ( $ folderName ) ; $ folder -> purge ( ) ; } $ dispatcher = $ GLOBALS [ 'container' ] [ 'event-dispatcher' ] ; $ dispatcher -> dispatch ( ContaoEvents :: SYSTEM_LOG , new LogEvent ( 'Purged the MetaModels assets' , __METHOD__ , TL_CRON ) ) ; }
9192	public function init ( ) { if ( $ this -> isInitialized ( ) ) return true ; $ sm = $ this -> getServiceManager ( ) ; $ defaultListeners = $ sm -> get ( 'yimaTheme.Manager.ListenerAggregate' ) ; if ( $ defaultListeners instanceof self ) $ defaultListeners -> manager = $ this ; $ sharedEvents = $ this -> getEventManager ( ) -> getSharedManager ( ) ; $ sharedEvents -> attachAggregate ( $ defaultListeners ) ; $ this -> isInitialized = true ; return $ this ; }
941	public function getPath ( ) { if ( null === $ this -> path ) { $ filesystem = new Filesystem ( ) ; $ cwd = $ this -> cwd ; if ( 1 === \ count ( $ this -> options [ 'path' ] ) && '-' === $ this -> options [ 'path' ] [ 0 ] ) { $ this -> path = $ this -> options [ 'path' ] ; } else { $ this -> path = array_map ( static function ( $ path ) use ( $ cwd , $ filesystem ) { $ absolutePath = $ filesystem -> isAbsolutePath ( $ path ) ? $ path : $ cwd . \ DIRECTORY_SEPARATOR . $ path ; if ( ! file_exists ( $ absolutePath ) ) { throw new InvalidConfigurationException ( sprintf ( 'The path "%s" is not readable.' , $ path ) ) ; } return $ absolutePath ; } , $ this -> options [ 'path' ] ) ; } } return $ this -> path ; }
6235	public function mkdir ( ) : self { if ( ! $ this -> storage -> isDir ( ) ) { if ( ! $ this -> storage -> mkdir ( ) ) { throw new AccessDeniedException ( sprintf ( 'unable to create directory at: "%s"' , $ this -> storage -> path ( ) -> raw ) , 500 ) ; } } return $ this ; }
6268	public function isAcademic ( $ text ) { if ( empty ( $ text ) ) { return false ; } $ domain = $ this -> getDomain ( $ text ) ; if ( $ domain === null ) { return false ; } foreach ( $ this -> getBlacklistedTopLevelDomains ( ) as $ blacklistedDomain ) { $ name = ( string ) $ domain [ 'host' ] ; if ( preg_match ( '/' . preg_quote ( $ blacklistedDomain ) . '$/' , $ name ) ) { return false ; } } if ( in_array ( $ domain [ 'tld' ] , $ this -> getAcademicTopLevelDomains ( ) ) ) { return true ; } if ( $ this -> matchesAcademicDomain ( $ domain ) ) { return true ; } return false ; }
2697	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ activateVcl = $ this -> getRequest ( ) -> getParam ( 'activate_flag' ) ; $ service = $ this -> api -> checkServiceDetails ( ) ; $ enabled = false ; $ this -> vcl -> checkCurrentVersionActive ( $ service -> versions , $ activeVersion ) ; $ currActiveVersion = $ this -> vcl -> getCurrentVersion ( $ service -> versions ) ; $ vclPath = Config :: VCL_AUTH_SNIPPET_PATH ; $ snippets = $ this -> config -> getVclSnippets ( $ vclPath ) ; $ status = true ; foreach ( $ snippets as $ key => $ value ) { $ name = Config :: FASTLY_MAGENTO_MODULE . '_basic_auth_' . $ key ; $ status = $ this -> api -> getSnippet ( $ activeVersion , $ name ) ; if ( ! $ status ) { break ; } } if ( ! $ status ) { $ this -> api -> checkAuthDictionaryPopulation ( $ activeVersion ) ; $ clone = $ this -> api -> cloneVersion ( $ currActiveVersion ) ; foreach ( $ snippets as $ key => $ value ) { $ snippetData = [ 'name' => Config :: FASTLY_MAGENTO_MODULE . '_basic_auth_' . $ key , 'type' => $ key , 'dynamic' => "0" , 'content' => $ value , 'priority' => 10 ] ; $ this -> api -> uploadSnippet ( $ clone -> number , $ snippetData ) ; } $ enabled = true ; } else { $ clone = $ this -> api -> cloneVersion ( $ currActiveVersion ) ; foreach ( $ snippets as $ key => $ value ) { $ name = Config :: FASTLY_MAGENTO_MODULE . '_basic_auth_' . $ key ; $ this -> api -> removeSnippet ( $ clone -> number , $ name ) ; } } $ this -> api -> validateServiceVersion ( $ clone -> number ) ; if ( $ activateVcl === 'true' ) { $ this -> api -> activateVersion ( $ clone -> number ) ; } $ this -> sendWebhook ( $ enabled , $ clone ) ; $ comment = [ 'comment' => 'Magento Module turned ON Basic Authentication' ] ; if ( ! $ enabled ) { $ comment = [ 'comment' => 'Magento Module turned OFF Basic Authentication' ] ; } $ this -> api -> addComment ( $ clone -> number , $ comment ) ; return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
1883	public static function find ( array $ arrOptions ) { $ objBase = DcaExtractor :: getInstance ( $ arrOptions [ 'table' ] ) ; if ( ! $ objBase -> hasRelations ( ) ) { $ strQuery = "SELECT * FROM " . $ arrOptions [ 'table' ] ; } else { $ arrJoins = array ( ) ; $ arrFields = array ( $ arrOptions [ 'table' ] . ".*" ) ; $ intCount = 0 ; foreach ( $ objBase -> getRelations ( ) as $ strKey => $ arrConfig ) { if ( $ arrConfig [ 'load' ] == 'eager' || $ arrOptions [ 'eager' ] ) { if ( $ arrConfig [ 'type' ] == 'hasOne' || $ arrConfig [ 'type' ] == 'belongsTo' ) { ++ $ intCount ; $ objRelated = DcaExtractor :: getInstance ( $ arrConfig [ 'table' ] ) ; foreach ( array_keys ( $ objRelated -> getFields ( ) ) as $ strField ) { $ arrFields [ ] = 'j' . $ intCount . '.' . Database :: quoteIdentifier ( $ strField ) . ' AS ' . $ strKey . '__' . $ strField ; } $ arrJoins [ ] = " LEFT JOIN " . $ arrConfig [ 'table' ] . " j$intCount ON " . $ arrOptions [ 'table' ] . "." . Database :: quoteIdentifier ( $ strKey ) . "=j$intCount." . $ arrConfig [ 'field' ] ; } } } $ strQuery = "SELECT " . implode ( ', ' , $ arrFields ) . " FROM " . $ arrOptions [ 'table' ] . implode ( "" , $ arrJoins ) ; } if ( isset ( $ arrOptions [ 'column' ] ) ) { $ strQuery .= " WHERE " . ( \ is_array ( $ arrOptions [ 'column' ] ) ? implode ( " AND " , $ arrOptions [ 'column' ] ) : $ arrOptions [ 'table' ] . '.' . Database :: quoteIdentifier ( $ arrOptions [ 'column' ] ) . "=?" ) ; } if ( isset ( $ arrOptions [ 'group' ] ) ) { $ strQuery .= " GROUP BY " . $ arrOptions [ 'group' ] ; } if ( isset ( $ arrOptions [ 'having' ] ) ) { $ strQuery .= " HAVING " . $ arrOptions [ 'having' ] ; } if ( isset ( $ arrOptions [ 'order' ] ) ) { $ strQuery .= " ORDER BY " . $ arrOptions [ 'order' ] ; } return $ strQuery ; }
12036	public function addTranslateResponseToExceptionMethod ( ) { $ body = 'return $this->api->translateResponseToException($response);' ; $ docBlock = new DocBlockGenerator ( 'Determine whether the response is an error. Override this method to have a per-operation decision, otherwise the function from the API class will be used.' , null ) ; $ methodGenerator = $ this -> createMethodGenerator ( 'translateResponseToException' , $ body , $ docBlock , [ [ 'response' , 'Amp\Artax\Response' ] ] , [ 'null' , '\ArtaxServiceBuilder\BadResponseException' ] ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; }
6585	protected function perform ( callable $ callback , ... $ params ) { $ result = $ callback ( $ this -> curl , ... $ params ) ; if ( curl_errno ( $ this -> curl ) !== CURLE_OK ) throw new CurlException ( $ this -> curl ) ; if ( $ result === false ) throw new CurlException ( "Unable to perform $callback - unknown error." ) ; return $ result ; }
2347	public function getContent ( ) { $ strContent = file_get_contents ( $ this -> strRootDir . '/' . ( $ this -> strTmp ? : $ this -> strFile ) ) ; if ( strncmp ( $ strContent , "\xEF\xBB\xBF" , 3 ) === 0 ) { $ strContent = substr ( $ strContent , 3 ) ; } elseif ( strncmp ( $ strContent , "\xFF\xFE" , 2 ) === 0 ) { $ strContent = substr ( $ strContent , 2 ) ; } elseif ( strncmp ( $ strContent , "\xFE\xFF" , 2 ) === 0 ) { $ strContent = substr ( $ strContent , 2 ) ; } return $ strContent ; }
9638	public function getAttributes ( ) { $ attributes = array ( 'placeholder' => $ this -> config [ 'defaultparts' ] [ 'scheme' ] . "://example.com" ) ; if ( $ this -> config [ 'html5validation' ] ) { $ attributes += array ( 'type' => 'url' , 'pattern' => 'https?://.+' , ) ; } return array_merge ( parent :: getAttributes ( ) , $ attributes ) ; }
8906	public function count_by ( ) { $ where = func_get_args ( ) ; $ this -> _set_where ( $ where ) ; $ this -> apply_soft_delete_filter ( ) ; return $ this -> _database -> count_all_results ( $ this -> _table ) ; }
4865	public function listing ( array $ options = [ ] ) { $ filter = [ 'queue' => $ this -> getName ( ) ] ; if ( isset ( $ options [ 'status' ] ) ) { $ filter [ 'status' ] = $ options [ 'status' ] ; } $ opt = [ 'sort' => [ 'scheduled' => 1 , 'priority' => 1 ] ] ; if ( isset ( $ options [ 'limit' ] ) ) { $ opt [ 'limit' ] = $ options [ 'limit' ] ; } $ cursor = $ this -> mongoCollection -> find ( $ filter , $ opt ) ; $ jobs = $ cursor -> toArray ( ) ; foreach ( $ jobs as & $ envelope ) { $ envelope [ 'job' ] = $ this -> unserializeJob ( $ envelope [ 'data' ] , [ '__id__' => $ envelope [ '_id' ] ] ) ; } return $ jobs ; }
4973	private function prepareHydrateData ( array $ data ) { $ items = $ data [ 'items' ] ; $ tree = [ '__root__' => array_shift ( $ items ) ] ; foreach ( $ items as $ item ) { $ parent = substr ( $ item [ 'current' ] , 0 , strrpos ( $ item [ 'current' ] , '-' ) ) ; $ tree [ $ parent ] [ ] = $ item ; } $ this -> hydrateData = $ tree ; }
2281	protected static function httpHost ( ) { if ( ! empty ( $ _SERVER [ 'HTTP_HOST' ] ) ) { $ host = $ _SERVER [ 'HTTP_HOST' ] ; } else { $ host = $ _SERVER [ 'SERVER_NAME' ] ; if ( $ _SERVER [ 'SERVER_PORT' ] != 80 ) { $ host .= ':' . $ _SERVER [ 'SERVER_PORT' ] ; } } return preg_replace ( '/[^A-Za-z0-9[\].:-]/' , '' , $ host ) ; }
4490	public function createTopic ( string $ name ) : string { $ res = $ this -> sns -> createTopic ( [ 'Name' => $ name , ] ) ; return $ res [ 'TopicArn' ] ; }
11933	public function render ( $ view , array $ parameters = array ( ) , Response $ response = null ) { $ parameters [ 'base_template' ] = isset ( $ parameters [ 'base_template' ] ) ? $ parameters [ 'base_template' ] : $ this -> getBaseTemplate ( ) ; $ parameters [ 'admin_pool' ] = $ this -> get ( 'sonata.admin.pool' ) ; return parent :: render ( $ view , $ parameters ) ; }
640	public function dropPrimaryKey ( $ name , $ table ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> dropPrimaryKey ( $ name , $ table ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; }
2167	protected static function generateHelperObject ( $ value ) { $ return = new \ stdClass ( ) ; if ( ! \ is_array ( $ value ) ) { $ return -> value = rtrim ( $ value , "\x00" ) ; $ return -> isUuid = ( \ strlen ( $ value ) == 16 && ! is_numeric ( $ return -> value ) && strncmp ( $ return -> value , Config :: get ( 'uploadPath' ) . '/' , \ strlen ( Config :: get ( 'uploadPath' ) ) + 1 ) !== 0 ) ; $ return -> isNumeric = ( is_numeric ( $ return -> value ) && $ return -> value > 0 ) ; } else { $ return -> value = array_map ( function ( $ var ) { return rtrim ( $ var , "\x00" ) ; } , $ value ) ; $ return -> isUuid = ( \ strlen ( $ value [ 0 ] ) == 16 && ! is_numeric ( $ return -> value [ 0 ] ) && strncmp ( $ return -> value [ 0 ] , Config :: get ( 'uploadPath' ) . '/' , \ strlen ( Config :: get ( 'uploadPath' ) ) + 1 ) !== 0 ) ; $ return -> isNumeric = ( is_numeric ( $ return -> value [ 0 ] ) && $ return -> value [ 0 ] > 0 ) ; } return $ return ; }
5734	public function getLeagueMatches ( int $ leagueID , array $ filter = [ 'dateFrom' => '' , 'dateTo' => '' , 'stage' => '' , 'status' => '' , 'matchday' => '' , 'group' => '' ] ) { $ leagueMatches = $ this -> run ( "v2/competitions/{$leagueID}/matches" . "?" . http_build_query ( $ filter ) ) ; return collect ( $ leagueMatches -> matches ) ; }
2106	public function getMaxUploadFileSize ( ) { $ objResult = Database :: getInstance ( ) -> prepare ( "SELECT MAX(maxlength) AS maxlength FROM tl_form_field WHERE pid=? AND invisible='' AND type='upload' AND maxlength>0" ) -> execute ( $ this -> id ) ; if ( $ objResult -> numRows > 0 && $ objResult -> maxlength > 0 ) { return $ objResult -> maxlength ; } else { return Config :: get ( 'maxFileSize' ) ; } }
5729	public function bindGridField ( Form $ form , GridFieldDetailForm_ItemRequest $ request ) { $ this -> setForm ( $ form ) ; $ this -> gridFieldRequest = $ request ; foreach ( $ this -> children as $ child ) { if ( ! $ child instanceof BetterButton && ! $ child instanceof BetterButtonAction ) { throw new Exception ( "DropdownFormAction must be passed instances of BetterButton" ) ; } $ child -> bindGridField ( $ form , $ request ) ; $ child -> setIsGrouped ( true ) ; if ( $ child instanceof FormAction ) { $ child -> setUseButtonTag ( true ) ; } } return $ this ; }
4168	public function handle ( ) { $ packageInfo = $ this -> tokenizePackageInfo ( ) ; $ packages = $ this -> getPackages ( ) ; $ total = $ packages -> count ( ) ; if ( ! $ total ) { $ this -> warn ( ' No package found. Make sure you spell it correct as specified on github or packagist.' ) ; } if ( $ packages -> first ( ) [ 'name' ] !== $ packageInfo [ 'name' ] ) { $ this -> warn ( $ total . ' package' . ( $ total > 1 ? 's' : '' ) . ' found by given name.' ) ; return $ this -> call ( 'add' , [ 'package' => $ this -> prettify ( $ packages ) ] ) ; } $ this -> downloadPackage ( ) -> runConfiguration ( ) ; }
1877	public function delete ( $ source = null ) { if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notDeletable' ] ) { throw new InternalServerErrorException ( 'Table "' . $ this -> strTable . '" is not deletable.' ) ; } $ blnDoNotRedirect = ( $ source !== null ) ; if ( $ source === null ) { $ source = $ this -> intId ; } $ this -> isValid ( $ source ) ; if ( ! file_exists ( $ this -> strRootDir . '/' . $ source ) || ! $ this -> isMounted ( $ source ) ) { throw new AccessDeniedException ( 'File or folder "' . $ source . '" is not mounted or cannot be found.' ) ; } if ( \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'ondelete_callback' ] ) ) { foreach ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'ondelete_callback' ] as $ callback ) { if ( \ is_array ( $ callback ) ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ source , $ this ) ; } elseif ( \ is_callable ( $ callback ) ) { $ callback ( $ source , $ this ) ; } } } $ this -> import ( Files :: class , 'Files' ) ; if ( is_dir ( $ this -> strRootDir . '/' . $ source ) ) { $ this -> Files -> rrdir ( $ source ) ; $ strWebDir = StringUtil :: stripRootDir ( System :: getContainer ( ) -> getParameter ( 'contao.web_dir' ) ) ; if ( is_link ( $ this -> strRootDir . '/' . $ strWebDir . '/' . $ source ) ) { $ this -> Files -> delete ( $ strWebDir . '/' . $ source ) ; } } else { $ this -> Files -> delete ( $ source ) ; } if ( $ this -> blnIsDbAssisted && Dbafs :: shouldBeSynchronized ( $ source ) ) { Dbafs :: deleteResource ( $ source ) ; } $ this -> log ( 'File or folder "' . $ source . '" has been deleted' , __METHOD__ , TL_FILES ) ; if ( ! $ blnDoNotRedirect ) { $ this -> redirect ( $ this -> getReferer ( ) ) ; } }
11696	protected function normaliseSrcInput ( $ input ) : array { $ output = [ ] ; if ( $ input instanceof Finder ) { foreach ( $ input as $ fileInfo ) { $ output [ ] = $ fileInfo -> getRealpath ( ) ; } } else { if ( ! is_array ( $ input ) ) $ input = [ $ input ] ; if ( count ( $ input ) === 0 ) throw new \ UnexpectedValueException ; if ( ! is_string ( $ input [ 0 ] ) ) throw new \ UnexpectedValueException ; $ output = $ input ; } return $ output ; }
1525	protected function doCreate ( StoreInterface $ store , CreateResource $ request ) { if ( $ response = $ this -> beforeCommit ( $ request ) ) { return $ response ; } $ record = $ store -> createRecord ( $ request -> getResourceType ( ) , $ request -> all ( ) , $ request -> getParameters ( ) ) ; return $ this -> afterCommit ( $ request , $ record , false ) ? : $ record ; }
6491	protected function getInstance ( $ selector = '' ) { if ( empty ( $ this -> object ) ) { throw new \ RuntimeException ( 'Editor instance was not set.' ) ; } if ( empty ( $ this -> selector ) && empty ( $ selector ) ) { throw new \ RuntimeException ( 'No such editor was not selected.' ) ; } $ this -> setSelector ( $ selector ) ; if ( empty ( $ this -> instances [ $ this -> selector ] ) ) { $ instanceId = $ this -> context -> element ( 'field' , $ this -> selector ) -> getAttribute ( 'id' ) ; $ instance = sprintf ( $ this -> object , $ instanceId ) ; if ( ! $ this -> context -> executeJs ( "return !!$instance" ) ) { throw new \ Exception ( sprintf ( 'Editor "%s" was not found.' , $ instanceId ) ) ; } $ this -> instances [ $ this -> selector ] = $ instance ; } return $ this -> instances [ $ this -> selector ] ; }
4045	public function decodeValue ( DecodePropertyValueForWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) || ( $ event -> getProperty ( ) !== 'jumpTo' ) ) { return ; } $ propInfo = $ event -> getEnvironment ( ) -> getDataDefinition ( ) -> getPropertiesDefinition ( ) -> getProperty ( 'jumpTo' ) ; $ value = StringUtil :: deserialize ( $ event -> getValue ( ) , true ) ; $ extra = $ propInfo -> getExtra ( ) ; $ newValues = [ ] ; $ languages = $ extra [ 'columnFields' ] [ 'langcode' ] [ 'options' ] ; foreach ( array_keys ( $ languages ) as $ key ) { $ newValue = '' ; $ filter = 0 ; if ( $ value ) { foreach ( $ value as $ arr ) { if ( ! is_array ( $ arr ) ) { break ; } if ( array_search ( $ key , $ arr ) !== false ) { $ newValue = '{{link_url::' . $ arr [ 'value' ] . '}}' ; $ filter = $ arr [ 'filter' ] ; break ; } } } $ newValues [ ] = [ 'langcode' => $ key , 'value' => $ newValue , 'filter' => $ filter ] ; } $ event -> setValue ( $ newValues ) ; }
7582	protected function verifyRequiredData ( ) { $ errors = array ( ) ; foreach ( $ this -> _REQUIRED_DATA as $ property => $ defaultValue ) { if ( ( ! isset ( $ this -> Data [ $ property ] ) ) && empty ( $ defaultValue ) ) { $ errors [ ] = $ property ; } } if ( count ( $ errors ) > 0 ) { throw new RequiredDataException ( get_called_class ( ) , "Missing data for " . implode ( "," , $ errors ) ) ; } return true ; }
11979	public function transformCard ( AbstractMessage $ message ) { $ type = $ message -> getType ( ) ; return [ 'msgtype' => $ type , $ type => [ 'card_id' => $ message -> get ( 'card_id' ) , ] , ] ; }
5758	protected function getFromClause ( ) : string { return "FROM " . self :: TABLE_NAME . " JOIN " . self :: ROLES_JOIN_TABLE_NAME . " ON " . self :: TABLE_NAME . ".id = " . self :: ROLES_JOIN_TABLE_NAME . ".permission_id JOIN " . self :: ROLES_TABLE_NAME . " ON " . self :: ROLES_JOIN_TABLE_NAME . ".role_id=" . self :: ROLES_TABLE_NAME . ".id" ; }
9272	protected function dataToMultipart ( array $ data = [ ] ) { $ multipart = [ ] ; foreach ( $ data as $ name => $ contents ) { array_push ( $ multipart , [ 'name' => $ name , 'contents' => $ contents ] ) ; } return $ multipart ; }
6437	public function getLoginStartUrl ( $ redirecturl ) { $ connection = new TwitterOAuth ( $ this -> options [ 'consumer_key' ] , $ this -> options [ 'consumer_secret' ] ) ; $ connection -> setTimeouts ( 10 , 15 ) ; $ request_token = $ connection -> oauth ( 'oauth/request_token' , array ( 'oauth_callback' => $ redirecturl ) ) ; $ this -> request_token = array ( ) ; $ this -> request_token [ 'oauth_token' ] = $ request_token [ 'oauth_token' ] ; $ this -> request_token [ 'oauth_token_secret' ] = $ request_token [ 'oauth_token_secret' ] ; return $ connection -> url ( 'oauth/authorize' , array ( 'oauth_token' => $ request_token [ 'oauth_token' ] ) ) ; }
3717	public static function withName ( $ columnName , $ tableName , $ code = 0 , $ previous = null ) { return new static ( sprintf ( 'Column "%s" already exists on table "%s' , $ columnName , $ tableName ) , $ code , $ previous ) ; }
9568	protected function invokeConfigurator ( $ configurator ) { if ( is_callable ( $ configurator ) ) { call_user_func ( $ configurator , $ this ) ; return ; } if ( is_string ( $ configurator ) ) { $ configurator = $ this -> container -> resolve ( $ configurator ) ; } if ( $ configurator instanceof ConfiguratorInterface ) { $ configurator -> configure ( ) ; } else { throw new \ UnexpectedValueException ( 'Invalid configurator' ) ; } }
10221	public static function getConversionGroupUnits ( $ group = null ) { $ conversionGroups = [ ] ; foreach ( self :: $ conversionUnits as $ conversionUnit => $ conversionGroup ) { if ( ( $ group === null ) || ( $ conversionGroup [ 'Group' ] == $ group ) ) { $ conversionGroups [ $ conversionGroup [ 'Group' ] ] [ ] = $ conversionUnit ; } } return $ conversionGroups ; }
10839	protected function deleteRaw ( $ Key ) { $ CacheFile = $ this -> getCacheFile ( $ Key ) ; if ( file_exists ( $ CacheFile ) ) { return unlink ( $ CacheFile ) ; } return true ; }
1811	public function addCteType ( $ arrRow ) { $ key = $ arrRow [ 'invisible' ] ? 'unpublished' : 'published' ; $ type = $ GLOBALS [ 'TL_LANG' ] [ 'CTE' ] [ $ arrRow [ 'type' ] ] [ 0 ] ? : '&nbsp;' ; $ class = 'limit_height' ; if ( \ in_array ( $ arrRow [ 'type' ] , $ GLOBALS [ 'TL_WRAPPERS' ] [ 'start' ] ) || \ in_array ( $ arrRow [ 'type' ] , $ GLOBALS [ 'TL_WRAPPERS' ] [ 'separator' ] ) || \ in_array ( $ arrRow [ 'type' ] , $ GLOBALS [ 'TL_WRAPPERS' ] [ 'stop' ] ) ) { $ class = '' ; if ( ( $ group = $ this -> getContentElementGroup ( $ arrRow [ 'type' ] ) ) !== null ) { $ type = $ GLOBALS [ 'TL_LANG' ] [ 'CTE' ] [ $ group ] . ' (' . $ type . ')' ; } } elseif ( \ in_array ( $ arrRow [ 'type' ] , $ GLOBALS [ 'TL_WRAPPERS' ] [ 'single' ] ) ) { if ( ( $ group = $ this -> getContentElementGroup ( $ arrRow [ 'type' ] ) ) !== null ) { $ type = $ GLOBALS [ 'TL_LANG' ] [ 'CTE' ] [ $ group ] . ' (' . $ type . ')' ; } } if ( $ arrRow [ 'type' ] == 'alias' ) { $ type .= ' ID ' . $ arrRow [ 'cteAlias' ] ; } if ( $ arrRow [ 'protected' ] ) { $ type .= ' (' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'protected' ] . ')' ; } elseif ( $ arrRow [ 'guests' ] ) { $ type .= ' (' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'guests' ] . ')' ; } if ( $ arrRow [ 'type' ] == 'headline' ) { if ( \ is_array ( $ headline = Contao \ StringUtil :: deserialize ( $ arrRow [ 'headline' ] ) ) ) { $ type .= ' (' . $ headline [ 'unit' ] . ')' ; } } if ( ! Contao \ Config :: get ( 'doNotCollapse' ) ) { $ class .= ' h40' ; } $ objModel = new Contao \ ContentModel ( ) ; $ objModel -> setRow ( $ arrRow ) ; return '<div class="cte_type ' . $ key . '">' . $ type . '</div><div class="' . trim ( $ class ) . '">' . Contao \ StringUtil :: insertTagToSrc ( $ this -> getContentElement ( $ objModel ) ) . '</div>' . "\n" ; }
4153	public function invalidateBearerToken ( ) { $ url = $ this -> getInvalidateBearerTokenUrl ( ) ; $ bearerToken = $ this -> bearerToken ; if ( $ bearerToken === null ) { $ bearerToken = $ this -> getBearerToken ( ) ; } $ params = array ( 'post' => array ( 'access_token' => $ bearerToken ) , 'headers' => $ this -> buildBearerTokenHeader ( ) , ) ; $ response = $ this -> curl -> send ( $ url , $ params ) ; $ obj = json_decode ( $ response [ 'body' ] ) ; if ( ! $ obj || ! isset ( $ obj -> access_token ) || $ obj -> access_token != $ bearerToken ) { $ this -> findExceptions ( $ response ) ; } unset ( $ url , $ bearerToken , $ params , $ response , $ obj ) ; return true ; }
916	public static function calculateTrailingWhitespaceIndent ( Token $ token ) { if ( ! $ token -> isWhitespace ( ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The given token must be whitespace, got "%s".' , $ token -> getName ( ) ) ) ; } $ str = strrchr ( str_replace ( [ "\r\n" , "\r" ] , "\n" , $ token -> getContent ( ) ) , "\n" ) ; if ( false === $ str ) { return '' ; } return ltrim ( $ str , "\n" ) ; }
6878	private function getRevenueQuery ( ) { if ( null !== $ this -> revenueQuery ) { return $ this -> revenueQuery ; } $ qb = $ this -> createQueryBuilder ( 'o' ) ; $ expr = $ qb -> expr ( ) ; return $ this -> revenueQuery = $ qb -> select ( [ 'o.date' , 'o.revenue' , 'o.details' ] ) -> andWhere ( $ expr -> eq ( 'o.type' , ':type' ) ) -> andWhere ( $ expr -> gte ( 'o.date' , ':from' ) ) -> andWhere ( $ expr -> lte ( 'o.date' , ':to' ) ) -> addOrderBy ( 'o.date' ) -> getQuery ( ) ; }
9065	protected function checkMVC ( ) { $ viewResolver = $ this -> sm -> get ( 'ViewResolver' ) ; $ return = true ; if ( $ viewResolver instanceof ViewResolver \ AggregateResolver ) { if ( $ viewResolver -> count ( ) == 2 ) { $ defResolvers = array ( 'Zend\View\Resolver\TemplateMapResolver' , 'Zend\View\Resolver\TemplatePathStack' ) ; foreach ( $ viewResolver -> getIterator ( ) -> toArray ( ) as $ i => $ ro ) { if ( $ defResolvers [ $ i ] != get_class ( $ ro ) ) { $ return = false ; break ; } } } else { $ return = false ; } } else { $ return = false ; } $ viewTemplatePathStack = $ this -> sm -> get ( 'ViewTemplatePathStack' ) ; if ( ! $ viewTemplatePathStack instanceof ViewResolver \ TemplatePathStack ) { throw new \ Exception ( 'yimaTheme work with PathStack' ) ; } return $ return ; }
6017	public function updateSite ( $ id , DeploymentSite $ deploymentSite ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'deploymentSite' => $ deploymentSite ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/deployment/' . $ id . '' , $ parameters ) ; $ result = new DeploymentSiteResponse ( $ result ) ; return $ result ; }
5809	public function updateSearchForm ( $ form ) { Requirements :: javascript ( FUSION_PATH . '/javascript/fusion.js' ) ; $ form -> Fields ( ) -> insertBefore ( ListboxField :: create ( 'q[Tagging]' , 'Tags' , FusionTag :: get ( ) -> map ( 'Title' , 'Title' ) -> toArray ( ) , ( ( $ filtering = $ this -> owner -> getRequest ( ) -> getVar ( 'q' ) ) && isset ( $ filtering [ 'Tagging' ] ) ) ? $ filtering [ 'Tagging' ] : array ( ) , null , true ) , 'q[Term]' ) ; $ this -> owner -> extend ( 'updateCMSMainTaggingExtensionSearchForm' , $ form ) ; }
9507	public function show ( Log $ log ) { $ this -> authorize ( LogViewerPolicy :: PERMISSION_SHOW ) ; $ levels = $ this -> logViewer -> levelsNames ( ) ; $ entries = $ log -> entries ( $ level = 'all' ) -> paginate ( $ this -> perPage ) ; $ this -> addBreadcrumbRoute ( trans ( 'foundation::log-viewer.titles.logs-list' ) , 'admin::foundation.system.log-viewer.logs.list' ) ; $ this -> setTitle ( $ title = "Log : {$log->date}" ) ; $ this -> addBreadcrumb ( $ title ) ; return $ this -> view ( 'admin.system.log-viewer.show' , compact ( 'log' , 'levels' , 'level' , 'search' , 'entries' ) ) ; }
6426	public function completeLogin ( $ extrainputs = array ( ) ) { if ( $ extrainputs [ 'code' ] == '' && $ extrainputs [ 'error' ] != '' ) { throw new \ Exception ( $ extrainputs [ 'error' ] ) ; } $ client = $ this -> getClient ( ) ; $ client -> authenticate ( $ extrainputs [ 'code' ] ) ; $ this -> access_token = $ client -> getAccessToken ( ) ; return $ this -> getUserProfile ( ) ; }
11967	public function getPidByProgramName ( $ name ) { $ process = new Process ( sprintf ( 'supervisorctl pid %s' , $ name ) ) ; $ process -> run ( ) ; return $ process -> getOutput ( ) ; }
775	public function resetSequence ( $ tableName , $ value = null ) { $ table = $ this -> db -> getTableSchema ( $ tableName ) ; if ( $ table !== null && $ table -> sequenceName !== null ) { $ tableName = $ this -> db -> quoteTableName ( $ tableName ) ; if ( $ value === null ) { $ key = reset ( $ table -> primaryKey ) ; $ value = $ this -> db -> createCommand ( "SELECT MAX(`$key`) FROM $tableName" ) -> queryScalar ( ) + 1 ; } else { $ value = ( int ) $ value ; } return "ALTER TABLE $tableName AUTO_INCREMENT=$value" ; } elseif ( $ table === null ) { throw new InvalidArgumentException ( "Table not found: $tableName" ) ; } throw new InvalidArgumentException ( "There is no sequence associated with table '$tableName'." ) ; }
11497	public static function all ( $ pageNumber = 0 , $ pageSize = 10 , $ order = null ) { return ( new static ( ) ) -> fetchAll ( null , $ order , $ pageSize , $ pageNumber ) ; }
11381	public function render ( FormInterface $ form ) { if ( method_exists ( $ form , 'prepare' ) ) { $ form -> prepare ( ) ; } if ( ! $ form -> getAttribute ( 'role' ) ) { $ form -> setAttribute ( 'role' , 'form' ) ; } $ formContent = '' ; foreach ( $ form as $ element ) { if ( $ element instanceof FieldsetInterface ) { $ formContent .= $ this -> getView ( ) -> formCollection ( $ element ) ; } else { $ element -> setOption ( '_form' , $ form ) ; $ formContent .= $ this -> getView ( ) -> formRow ( $ element ) ; } } return $ this -> openTag ( $ form ) . $ formContent . $ this -> closeTag ( ) ; }
7536	function detach ( $ move_children_up = false ) { if ( ( $ p = $ this -> parent ) !== null ) { $ index = $ this -> index ( ) ; $ this -> parent = null ; if ( $ move_children_up ) { $ this -> moveChildren ( $ p , $ index ) ; } $ p -> deleteChild ( $ this , true ) ; } }
7090	public function removeDefaultHeader ( $ headers = "" ) { foreach ( $ headers as $ header ) foreach ( $ this -> defaultHeaders as $ h => $ v ) if ( $ header === $ h ) unset ( $ this -> defaultHeaders [ $ h ] ) ; return $ this -> defaultHeaders ; }
1716	public function isAllowed ( $ int , $ row ) { if ( $ this -> isAdmin ) { return true ; } if ( ! $ row [ 'includeChmod' ] ) { $ pid = $ row [ 'pid' ] ; $ row [ 'chmod' ] = false ; $ row [ 'cuser' ] = false ; $ row [ 'cgroup' ] = false ; $ objParentPage = PageModel :: findById ( $ pid ) ; while ( $ objParentPage !== null && $ row [ 'chmod' ] === false && $ pid > 0 ) { $ pid = $ objParentPage -> pid ; $ row [ 'chmod' ] = $ objParentPage -> includeChmod ? $ objParentPage -> chmod : false ; $ row [ 'cuser' ] = $ objParentPage -> includeChmod ? $ objParentPage -> cuser : false ; $ row [ 'cgroup' ] = $ objParentPage -> includeChmod ? $ objParentPage -> cgroup : false ; $ objParentPage = PageModel :: findById ( $ pid ) ; } if ( $ row [ 'chmod' ] === false ) { $ row [ 'chmod' ] = Config :: get ( 'defaultChmod' ) ; } if ( $ row [ 'cuser' ] === false ) { $ row [ 'cuser' ] = ( int ) Config :: get ( 'defaultUser' ) ; } if ( $ row [ 'cgroup' ] === false ) { $ row [ 'cgroup' ] = ( int ) Config :: get ( 'defaultGroup' ) ; } } $ chmod = StringUtil :: deserialize ( $ row [ 'chmod' ] ) ; $ chmod = \ is_array ( $ chmod ) ? $ chmod : array ( $ chmod ) ; $ permission = array ( 'w' . $ int ) ; if ( \ in_array ( $ row [ 'cgroup' ] , $ this -> groups ) ) { $ permission [ ] = 'g' . $ int ; } if ( $ row [ 'cuser' ] == $ this -> id ) { $ permission [ ] = 'u' . $ int ; } return \ count ( array_intersect ( $ permission , $ chmod ) ) > 0 ; }
6828	private function getSaleDeliveryAddress ( ShipmentInterface $ shipment ) { if ( null === $ sale = $ shipment -> getSale ( ) ) { throw new LogicException ( "Shipment's sale must be set at this point." ) ; } return $ sale -> isSameAddress ( ) ? $ sale -> getInvoiceAddress ( ) : $ sale -> getDeliveryAddress ( ) ; }
6169	protected function writeException ( $ exception ) { $ this -> writeNewLine ( ) ; do { $ exceptionStack [ ] = $ exception ; } while ( $ exception = $ exception -> getPreviousWrapped ( ) ) ; foreach ( explode ( "\n" , $ exception = array_shift ( $ exceptionStack ) ) as $ line ) { if ( $ exception && false !== $ pos = strpos ( $ line , $ exception -> getClassName ( ) . ': ' ) ) { $ whitespace = str_repeat ( ' ' , ( $ pos += strlen ( $ exception -> getClassName ( ) ) ) + 2 ) ; $ this -> writeWithColor ( 'bg-red,fg-white' , $ whitespace ) ; $ this -> writeWithColor ( 'bg-red,fg-white' , sprintf ( ' %s ' , substr ( $ line , 0 , $ pos ) ) , false ) ; $ this -> writeWithColor ( 'fg-red' , substr ( $ line , $ pos + 1 ) ) ; $ this -> writeWithColor ( 'bg-red,fg-white' , $ whitespace ) ; $ exception = array_shift ( $ exceptionStack ) ; continue ; } $ this -> writeWithColor ( 'fg-red' , $ line ) ; } }
8587	public function setLowestOfferListing ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'LowestOfferListing' ] [ 'FieldValue' ] = $ value ; return $ this ; }
1983	public static function hasMessages ( $ strScope = TL_MODE ) { return static :: hasError ( $ strScope ) || static :: hasConfirmation ( $ strScope ) || static :: hasNew ( $ strScope ) || static :: hasInfo ( $ strScope ) || static :: hasRaw ( $ strScope ) ; }
2345	public function truncate ( ) { if ( \ is_resource ( $ this -> resFile ) ) { ftruncate ( $ this -> resFile , 0 ) ; rewind ( $ this -> resFile ) ; } return $ this -> write ( '' ) ; }
6741	public function to ( $ target ) { if ( is_null ( $ this -> request ) ) { throw new \ LogicException ( 'Missing request instance.' ) ; } $ target = new Uri ( $ target ) ; $ uri = $ this -> request -> getUri ( ) -> withScheme ( $ target -> getScheme ( ) ) -> withHost ( $ target -> getHost ( ) ) ; if ( $ port = $ target -> getPort ( ) ) { $ uri = $ uri -> withPort ( $ port ) ; } if ( $ path = $ target -> getPath ( ) ) { $ uri = $ uri -> withPath ( rtrim ( $ path , '/' ) . '/' . ltrim ( $ uri -> getPath ( ) , '/' ) ) ; } if ( ! empty ( $ this -> request -> getQueryParams ( ) ) ) { $ queryParams = $ this -> request -> getQueryParams ( ) ; if ( count ( $ queryParams ) == 1 && empty ( array_shift ( $ queryParams ) ) ) { $ queryKeys = array_keys ( $ this -> request -> getQueryParams ( ) ) ; $ uri = $ uri -> withQuery ( $ queryKeys [ 0 ] ) ; } else { $ uri = $ uri -> withQuery ( http_build_query ( $ this -> request -> getQueryParams ( ) ) ) ; } } $ request = $ this -> request -> withUri ( $ uri ) ; foreach ( $ request -> getHeaders ( ) as $ headerName => $ headerValue ) { if ( empty ( $ headerValue [ 0 ] ) ) { $ request = $ request -> withoutHeader ( $ headerName ) ; } } return $ this -> client -> send ( $ request ) ; }
4159	function pop ( ) { $ response = $ this -> redis -> blPop ( $ this -> key , 10 ) ; if ( $ response ) { list ( $ list , $ serializedJob ) = $ response ; $ job = unserialize ( $ serializedJob ) ; return $ job ; } }
7655	function AddAddress ( $ address , $ name = "" ) { $ cur = count ( $ this -> to ) ; $ this -> to [ $ cur ] [ 0 ] = trim ( $ address ) ; $ this -> to [ $ cur ] [ 1 ] = $ name ; }
12634	public function reverse ( $ orderNo , $ type = self :: OUT_TRADE_NO ) { $ params = [ $ type => $ orderNo , ] ; return $ this -> safeRequest ( $ this -> wrapApi ( self :: API_REVERSE ) , $ params ) ; }
6586	protected function request ( array $ options ) { $ this -> info = null ; $ this -> setOpt ( $ options ) ; $ result = $ this -> perform ( 'curl_exec' ) ; $ this -> info = $ this -> perform ( 'curl_getinfo' ) ; return $ result ; }
4526	protected function createZoneMemberZoneFromDefinition ( array $ definition ) { $ zone = $ this -> get ( $ definition [ 'zone' ] ) ; $ zoneMember = new ZoneMemberZone ( ) ; $ zoneMember -> setZone ( $ zone ) ; $ setValues = \ Closure :: bind ( function ( $ definition ) { $ this -> id = $ definition [ 'id' ] ; } , $ zoneMember , '\CommerceGuys\Zone\Model\ZoneMemberZone' ) ; $ setValues ( $ definition ) ; return $ zoneMember ; }
8729	protected function updateFolderName ( HTTPRequest $ request ) { if ( ! $ this -> getCanSelectFolder ( ) ) { return ; } $ folderID = $ request -> requestVar ( "{$this->Name}/folder" ) ; $ path = $ this -> folderPathFromID ( $ folderID ) ; if ( $ path !== false ) { $ this -> setFolderName ( $ path ) ; $ this -> selectField -> setValue ( $ folderID ) ; } }
279	private function notifyNotFound ( $ fixtures ) { $ this -> stdout ( "Some fixtures were not found under path:\n" , Console :: BG_RED ) ; $ this -> stdout ( "\t" . $ this -> getFixturePath ( ) . "\n\n" , Console :: FG_GREEN ) ; $ this -> stdout ( "Check that they have correct namespace \"{$this->namespace}\" \n" , Console :: BG_RED ) ; $ this -> outputList ( $ fixtures ) ; $ this -> stdout ( "\n" ) ; }
3623	public function temperatureInCelsius ( $ temperature , $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ temp_scale = $ this -> getDeviceTemperatureScale ( $ serial_number ) ; if ( $ temp_scale == 'F' ) { return ( $ temperature - 32 ) / 1.8 ; } return $ temperature ; }
7710	function UpdateParent ( $ Cascading = false ) { if ( $ this -> Parent ) { $ this -> Parent -> ReplaceSrc ( $ this -> Txt ) ; if ( $ Cascading ) $ this -> Parent -> UpdateParent ( $ Cascading ) ; } }
7058	protected function getStockAdjustmentFromEvent ( ResourceEventInterface $ event ) { $ stockAdjustment = $ event -> getResource ( ) ; if ( ! $ stockAdjustment instanceof StockAdjustmentInterface ) { throw new InvalidArgumentException ( "Expected instance of " . StockAdjustmentInterface :: class ) ; } return $ stockAdjustment ; }
515	public function actionTo ( $ version ) { if ( ( $ namespaceVersion = $ this -> extractNamespaceMigrationVersion ( $ version ) ) !== false ) { $ this -> migrateToVersion ( $ namespaceVersion ) ; } elseif ( ( $ migrationName = $ this -> extractMigrationVersion ( $ version ) ) !== false ) { $ this -> migrateToVersion ( $ migrationName ) ; } elseif ( ( string ) ( int ) $ version == $ version ) { $ this -> migrateToTime ( $ version ) ; } elseif ( ( $ time = strtotime ( $ version ) ) !== false ) { $ this -> migrateToTime ( $ time ) ; } else { throw new Exception ( "The version argument must be either a timestamp (e.g. 101129_185401),\n the full name of a migration (e.g. m101129_185401_create_user_table),\n the full namespaced name of a migration (e.g. app\\migrations\\M101129185401CreateUserTable),\n a UNIX timestamp (e.g. 1392853000), or a datetime string parseable\nby the strtotime() function (e.g. 2014-02-15 13:00:50)." ) ; } }
3971	public function getAttributeOptions ( GetPropertyOptionsEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ result = [ ] ; $ metaModel = $ this -> getMetaModel ( $ event -> getEnvironment ( ) ) ; $ conditionType = $ event -> getModel ( ) -> getProperty ( 'type' ) ; foreach ( $ metaModel -> getAttributes ( ) as $ attribute ) { if ( ! $ this -> conditionFactory -> supportsAttribute ( $ conditionType , $ attribute -> get ( 'type' ) ) ) { continue ; } $ typeName = $ attribute -> get ( 'type' ) ; $ strSelectVal = $ metaModel -> getTableName ( ) . '_' . $ attribute -> getColName ( ) ; $ result [ $ strSelectVal ] = $ attribute -> getName ( ) . ' [' . $ typeName . ']' ; } $ event -> setOptions ( $ result ) ; }
3053	public function getCatEngine ( RouteItem $ routeItem = null ) { $ compiledDirectory = $ this -> getCompilationDirectory ( ) [ 'private' ] ; $ adaptiveSectionMap = $ this -> getServiceManager ( ) -> get ( CatService :: SERVICE_ID ) -> getAdaptiveSectionMap ( $ compiledDirectory ) ; $ routeItem = $ routeItem ? $ routeItem : $ this -> getTestSession ( ) -> getRoute ( ) -> current ( ) ; $ sectionId = $ routeItem -> getAssessmentSection ( ) -> getIdentifier ( ) ; $ catEngine = false ; if ( isset ( $ adaptiveSectionMap [ $ sectionId ] ) ) { $ catEngine = $ this -> getServiceManager ( ) -> get ( CatService :: SERVICE_ID ) -> getEngine ( $ adaptiveSectionMap [ $ sectionId ] [ 'endpoint' ] ) ; } return $ catEngine ; }
96	public function read ( $ url ) { $ xml = $ this -> requestXml ( $ url , "/channel.xml" ) ; $ channelName = ( string ) $ xml -> name ; $ channelAlias = ( string ) $ xml -> suggestedalias ; $ supportedVersions = array_keys ( $ this -> readerMap ) ; $ selectedRestVersion = $ this -> selectRestVersion ( $ xml , $ supportedVersions ) ; if ( ! $ selectedRestVersion ) { throw new \ UnexpectedValueException ( sprintf ( 'PEAR repository %s does not supports any of %s protocols.' , $ url , implode ( ', ' , $ supportedVersions ) ) ) ; } $ reader = $ this -> readerMap [ $ selectedRestVersion [ 'version' ] ] ; $ packageDefinitions = $ reader -> read ( $ selectedRestVersion [ 'baseUrl' ] ) ; return new ChannelInfo ( $ channelName , $ channelAlias , $ packageDefinitions ) ; }
10356	public function lockOut ( ) { $ this -> resetAttempts ( ) ; $ this -> cache -> add ( $ this -> lockOutKey , $ this -> getDelay ( ) + time ( ) , $ this -> getExpiry ( ) ) ; }
394	public static function updateAll ( $ attributes , $ condition = '' , $ params = [ ] ) { $ command = static :: getDb ( ) -> createCommand ( ) ; $ command -> update ( static :: tableName ( ) , $ attributes , $ condition , $ params ) ; return $ command -> execute ( ) ; }
8495	public function getFulfillmentOrder ( $ request ) { if ( ! ( $ request instanceof FBAOutboundServiceMWS_Model_GetFulfillmentOrderRequest ) ) { $ request = new FBAOutboundServiceMWS_Model_GetFulfillmentOrderRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetFulfillmentOrder' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAOutboundServiceMWS_Model_GetFulfillmentOrderResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
3517	public function getShowUnpublished ( ) { if ( ! $ this -> cookiesLoaded ) { $ key = $ this -> cookiePrefix . 'show_unpublished' ; $ queuedCookie = \ Cookie :: queued ( $ key , null ) ; $ showUnpublished = $ queuedCookie != null ? $ queuedCookie -> getValue ( ) : \ Cookie :: get ( $ key , false ) ; $ this -> useDB = $ showUnpublished ? 2 : 1 ; $ this -> cookiesLoaded = true ; } return $ this -> useDB === 2 ; }
5461	protected function acceptPageEnd ( ) { while ( count ( $ this -> open_forms ) ) { $ this -> complete_forms [ ] = array_pop ( $ this -> open_forms ) ; } foreach ( $ this -> left_over_labels as $ label ) { for ( $ i = 0 , $ count = count ( $ this -> complete_forms ) ; $ i < $ count ; $ i ++ ) { $ this -> complete_forms [ $ i ] -> attachLabelBySelector ( new SelectById ( $ label -> getFor ( ) ) , $ label -> getText ( ) ) ; } } $ this -> page -> setForms ( $ this -> complete_forms ) ; $ this -> page -> setFrames ( $ this -> loading_frames ) ; }
12503	public static function beginTransaction ( $ connection ) { $ connection -> query = 'BEGIN_TRANSACTION' ; $ connection -> method = 'POST' ; $ connection -> action = '/_query' ; return self :: sendQuery ( $ connection ) ; }
9020	public function getUniqueWords ( $ string ) { $ words = $ this -> getWords ( $ string ) ; $ analysis = new FrequencyAnalysis ( $ words ) ; $ words = $ analysis -> getKeyValuesByFrequency ( ) ; return array_unique ( array_keys ( $ words ) ) ; }
4559	protected function execute ( LifecycleEventArgs $ args , $ action ) { $ this -> tokenStorage = $ this -> container -> get ( 'security.token_storage' ) ; $ this -> configService = $ this -> container -> get ( 'ds_config.service.config' ) ; $ this -> auditService = $ this -> container -> get ( 'ds_audit.service.audit' ) ; $ entity = $ args -> getEntity ( ) ; if ( $ entity instanceof Audit ) { return ; } if ( ! $ entity instanceof Auditable ) { return ; } $ token = $ this -> tokenStorage -> getToken ( ) ; if ( ! $ token ) { return ; } $ user = $ token -> getUser ( ) ; $ edits = $ args -> getEntityManager ( ) -> getUnitOfWork ( ) -> getEntityChangeSet ( $ entity ) ; $ properties = $ this -> auditService -> getProperties ( $ entity ) ; foreach ( array_keys ( $ edits ) as $ key ) { if ( ! in_array ( $ key , $ properties ) ) { unset ( $ edits [ $ key ] ) ; } } $ audit = $ this -> auditService -> createInstance ( ) ; $ audit -> setOwner ( $ this -> configService -> get ( 'ds_audit.audit.owner' ) ) -> setOwnerUuid ( $ this -> configService -> get ( 'ds_audit.audit.owner_uuid' ) ) -> setUserUuid ( $ user -> getUuid ( ) ) -> setIdentity ( $ user -> getIdentity ( ) -> getType ( ) ) -> setIdentityUuid ( $ user -> getIdentity ( ) -> getUuid ( ) ) -> setAction ( $ action ) -> setData ( [ 'entity' => basename ( str_replace ( '\\' , '/' , get_class ( $ entity ) ) ) , 'entityUuid' => $ entity -> getUuid ( ) , 'edits' => $ edits ] ) ; $ manager = $ this -> auditService -> getManager ( ) ; $ manager -> persist ( $ audit ) ; $ manager -> flush ( ) ; }
1084	private function expectKeyword ( $ value ) { $ token = $ this -> lexer -> token ; if ( $ token -> kind === Token :: NAME && $ token -> value === $ value ) { $ this -> lexer -> advance ( ) ; return $ token ; } throw new SyntaxError ( $ this -> lexer -> source , $ token -> start , 'Expected "' . $ value . '", found ' . $ token -> getDescription ( ) ) ; }
8810	public function destroy ( ) { foreach ( $ _COOKIE as $ key => $ value ) { setcookie ( $ key , null , - 1 , '/' ) ; unset ( $ _COOKIE [ $ key ] ) ; } return ; }
4576	public function get ( $ id , Parameters $ parameters = null ) { if ( null !== $ id ) { $ resource = str_replace ( '{id}' , $ id , static :: RESOURCE_OBJECT ) ; } else { $ key = $ parameters -> getKey ( ) ; $ tenantId = $ parameters -> getTenantId ( ) ; switch ( true ) { case null !== $ key && null !== $ tenantId : $ resource = str_replace ( [ '{key}' , '{tenant-id}' ] , [ $ key , $ tenantId ] , static :: RESOURCE_OBJECT_BY_KEY_AND_TENANT_ID ) ; break ; case null !== $ key : $ resource = str_replace ( '{key}' , $ key , static :: RESOURCE_OBJECT_BY_KEY ) ; break ; default : throw new LogicException ( '"Key" and/or "TenantId" parameters are not defined.' ) ; } } $ options = [ 'headers' => [ 'Accept' => 'application/json' ] ] ; $ object = $ this -> execute ( 'GET' , $ resource , $ options ) ; $ model = static :: toModel ( $ object ) ; return $ model ; }
5253	public static function findOrFail ( $ id , array $ columns = [ '*' ] , $ parent = null ) { $ model = static :: find ( $ id , $ columns , [ 'parent' => $ parent ] ) ; if ( is_null ( $ model ) ) { throw new ModelNotFoundException ( get_called_class ( ) , $ id ) ; } return $ model ; }
11139	protected function getSetItem ( $ dataMember , $ offset , $ quote = true ) { $ item = $ this -> { $ dataMember } [ $ offset ] ; switch ( $ item [ 1 ] ) { case 'varchar' : $ type = 'varchar(255)' ; break ; default : $ type = $ item [ 1 ] ; } $ this -> { $ dataMember } [ $ offset ] [ 1 ] = $ type ; return $ this -> getArrayItem ( $ dataMember , $ offset , $ quote ) ; }
4768	public static function convertPhpObjToDom ( $ arr , $ node , $ dom ) { if ( is_array ( $ arr ) ) { $ arrayParam = array ( ) ; foreach ( $ arr as $ k => $ v ) { if ( is_integer ( $ k ) ) { $ arrayParam [ ] = $ v ; } } if ( 0 < count ( $ arrayParam ) ) { $ node -> appendChild ( $ arrayDom = $ dom -> createElement ( "array" ) ) ; foreach ( $ arrayParam as $ key => $ val ) { $ new = $ arrayDom -> appendChild ( $ dom -> createElement ( 'item' ) ) ; self :: convertPhpObjToDom ( $ val , $ new , $ dom ) ; } } else { foreach ( $ arr as $ key => $ val ) { $ new = $ node -> appendChild ( $ dom -> createElement ( self :: encode ( $ key ) ) ) ; self :: convertPhpObjToDom ( $ val , $ new , $ dom ) ; } } } elseif ( ! is_object ( $ arr ) ) { $ node -> appendChild ( $ dom -> createTextNode ( self :: encode ( $ arr ) ) ) ; } }
11656	public function getShortName ( ) { preg_match ( '/Widget([A-Za-z]+)\\\Module/' , get_class ( $ this ) , $ matches ) ; if ( ! isset ( $ matches [ 1 ] ) ) { throw new Exception ( get_class ( $ this ) . " is not set up correctly!" ) ; } return $ matches [ 1 ] ; }
10440	protected function parseQuery ( ) { if ( empty ( $ this -> lastLine ) || $ this -> lastLineType != self :: LINE_TYPE_QUERY ) { $ this -> getNextLine ( self :: LINE_TYPE_QUERY ) ; if ( empty ( $ this -> lastLine ) ) { return false ; } } $ buffer = $ this -> handleStart ( $ this -> lastLine ) ; $ this -> buffer [ $ this -> key ] [ self :: PARAM_DATE ] = $ this -> lastDateTime ; $ this -> buffer [ $ this -> key ] [ self :: PARAM_POSITION ] = $ this -> lastLogPosition ; $ this -> getNextLine ( self :: LINE_TYPE_QUERY ) ; if ( $ buffer [ 'type' ] == ActionTypes :: DELETE || $ buffer [ 'type' ] === ActionTypes :: UPDATE ) { $ buffer [ 'where' ] = $ this -> handleStatement ( $ this -> lastLine , self :: STATEMENT_TYPE_WHERE ) ; } if ( $ buffer [ 'type' ] == ActionTypes :: CREATE || $ buffer [ 'type' ] === ActionTypes :: UPDATE ) { $ buffer [ 'set' ] = $ this -> handleStatement ( $ this -> lastLine , self :: STATEMENT_TYPE_SET ) ; } return $ buffer ; }
6492	private function getBestMediaTypeFormatterMatch ( string $ type , array $ formatters , array $ mediaTypeHeaders , string $ ioType ) : ? MediaTypeFormatterMatch { if ( count ( $ mediaTypeHeaders ) > 0 && $ mediaTypeHeaders [ 0 ] instanceof IHeaderValueWithQualityScore ) { $ mediaTypeHeaders = $ this -> rankAcceptMediaTypeHeaders ( $ mediaTypeHeaders ) ; } foreach ( $ mediaTypeHeaders as $ mediaTypeHeader ) { [ $ mediaType , $ mediaSubType ] = explode ( '/' , $ mediaTypeHeader -> getMediaType ( ) ) ; foreach ( $ formatters as $ formatter ) { foreach ( $ formatter -> getSupportedMediaTypes ( ) as $ supportedMediaType ) { if ( $ ioType === self :: FORMATTER_TYPE_INPUT && ! $ formatter -> canReadType ( $ type ) ) { continue ; } if ( $ ioType === self :: FORMATTER_TYPE_OUTPUT && ! $ formatter -> canWriteType ( $ type ) ) { continue ; } [ $ supportedType , $ supportedSubType ] = explode ( '/' , $ supportedMediaType ) ; if ( $ mediaType === '*' || ( $ mediaSubType === '*' && $ mediaType === $ supportedType ) || ( $ mediaType === $ supportedType && $ mediaSubType === $ supportedSubType ) ) { return new MediaTypeFormatterMatch ( $ formatter , $ supportedMediaType , $ mediaTypeHeader ) ; } } } } return null ; }
5852	protected function processData ( ) { $ close = GeneralUtility :: _GP ( 'closeDoc' ) ; $ save = GeneralUtility :: _GP ( '_savedok' ) ; $ saveAndClose = GeneralUtility :: _GP ( '_saveandclosedok' ) ; if ( $ save || $ saveAndClose ) { $ table = static :: virtualTable ; $ id = static :: virtualRecordId ; $ field = 'rulesets' ; $ inputData_tmp = GeneralUtility :: _GP ( 'data' ) ; $ data = $ inputData_tmp [ $ table ] [ $ id ] ; if ( count ( $ inputData_tmp [ $ table ] ) > 1 ) { foreach ( $ inputData_tmp [ $ table ] as $ key => $ values ) { if ( $ key === $ id ) continue ; ArrayUtility :: mergeRecursiveWithOverrule ( $ data , $ values ) ; } } $ newConfig = $ this -> config ; ArrayUtility :: mergeRecursiveWithOverrule ( $ newConfig , $ data ) ; $ ffValue = & $ data [ $ field ] ; if ( $ ffValue ) { $ actionCMDs = GeneralUtility :: _GP ( '_ACTION_FLEX_FORMdata' ) ; if ( is_array ( $ actionCMDs [ $ table ] [ $ id ] [ $ field ] [ 'data' ] ) ) { $ dataHandler = new CustomDataHandler ( ) ; $ dataHandler -> _ACTION_FLEX_FORMdata ( $ ffValue [ 'data' ] , $ actionCMDs [ $ table ] [ $ id ] [ $ field ] [ 'data' ] ) ; } $ this -> persistFlexForm ( $ ffValue [ 'data' ] ) ; $ newConfig [ $ field ] = $ ffValue ; } $ localconfConfig = $ newConfig ; $ localconfConfig [ 'conversion_mapping' ] = implode ( ',' , GeneralUtility :: trimExplode ( LF , $ localconfConfig [ 'conversion_mapping' ] , true ) ) ; if ( $ this -> persistConfiguration ( $ localconfConfig ) ) { $ this -> config = $ newConfig ; } } if ( $ close || $ saveAndClose ) { $ closeUrl = BackendUtility :: getModuleUrl ( 'tools_ExtensionmanagerExtensionmanager' ) ; \ TYPO3 \ CMS \ Core \ Utility \ HttpUtility :: redirect ( $ closeUrl ) ; } }
666	public function renderItems ( ) { $ models = $ this -> dataProvider -> getModels ( ) ; $ keys = $ this -> dataProvider -> getKeys ( ) ; $ rows = [ ] ; foreach ( array_values ( $ models ) as $ index => $ model ) { $ key = $ keys [ $ index ] ; if ( ( $ before = $ this -> renderBeforeItem ( $ model , $ key , $ index ) ) !== null ) { $ rows [ ] = $ before ; } $ rows [ ] = $ this -> renderItem ( $ model , $ key , $ index ) ; if ( ( $ after = $ this -> renderAfterItem ( $ model , $ key , $ index ) ) !== null ) { $ rows [ ] = $ after ; } } return implode ( $ this -> separator , $ rows ) ; }
11454	public function autoload ( ) { if ( self :: $ loaded ) { return ; } if ( is_array ( $ this -> load ) ) { foreach ( $ this -> load as $ k => $ load ) { $ this -> load ( $ load ) ; } } if ( is_array ( $ this -> loadUri ) ) { foreach ( $ this -> loadUri as $ k => $ load ) { $ this -> load ( [ $ load => function ( $ query ) { $ query -> select ( 'id' , $ query -> getForeignKey ( ) ) ; } ] ) ; } } self :: $ loaded = true ; }
5282	public function getVar ( ) { $ row = $ this -> one ( \ ARRAY_A ) ; return is_null ( $ row ) ? false : current ( $ row ) ; }
10013	public function getSheetByName ( $ pName ) { $ worksheetCount = count ( $ this -> workSheetCollection ) ; for ( $ i = 0 ; $ i < $ worksheetCount ; ++ $ i ) { if ( $ this -> workSheetCollection [ $ i ] -> getTitle ( ) === $ pName ) { return $ this -> workSheetCollection [ $ i ] ; } } return null ; }
8386	public function having ( $ having ) { $ this -> having = ( $ having instanceof Condition ? $ having : new Condition ( $ having ) ) ; return $ this ; }
2146	protected function generateEmailObject ( Result $ objNewsletter , $ arrAttachments ) { $ objEmail = new Email ( ) ; $ objEmail -> from = $ objNewsletter -> sender ; $ objEmail -> subject = $ objNewsletter -> subject ; if ( $ objNewsletter -> senderName != '' ) { $ objEmail -> fromName = $ objNewsletter -> senderName ; } $ objEmail -> embedImages = ! $ objNewsletter -> externalImages ; $ objEmail -> logFile = TL_NEWSLETTER . '_' . $ objNewsletter -> id ; if ( ! empty ( $ arrAttachments ) && \ is_array ( $ arrAttachments ) ) { $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; foreach ( $ arrAttachments as $ strAttachment ) { $ objEmail -> attachFile ( $ rootDir . '/' . $ strAttachment ) ; } } return $ objEmail ; }
8280	public function onPagesLoaded ( array & $ pages ) { unset ( $ pages [ "403" ] ) ; if ( ! $ this -> config [ "alterPageArray" ] ) { return ; } if ( $ this -> errorOccurred ) { $ pages = array ( ) ; return ; } foreach ( $ pages as $ id => $ page ) { try { $ allowed = $ this -> checkAccess ( $ id ) ; } catch ( \ Exception $ e ) { $ this -> errorHandler ( $ e , $ this -> requestUrl ) ; $ pages = array ( ) ; return ; } if ( ! $ allowed ) { unset ( $ pages [ $ id ] ) ; } } }
339	public function registerClientScript ( ) { $ id = $ this -> options [ 'id' ] ; $ options = Json :: htmlEncode ( $ this -> getClientOptions ( ) ) ; $ attributes = Json :: htmlEncode ( $ this -> attributes ) ; $ view = $ this -> getView ( ) ; ActiveFormAsset :: register ( $ view ) ; $ view -> registerJs ( "jQuery('#$id').yiiActiveForm($attributes, $options);" ) ; }
461	public function buildColumns ( $ columns ) { if ( ! is_array ( $ columns ) ) { if ( strpos ( $ columns , '(' ) !== false ) { return $ columns ; } $ rawColumns = $ columns ; $ columns = preg_split ( '/\s*,\s*/' , $ columns , - 1 , PREG_SPLIT_NO_EMPTY ) ; if ( $ columns === false ) { throw new InvalidArgumentException ( "$rawColumns is not valid columns." ) ; } } foreach ( $ columns as $ i => $ column ) { if ( $ column instanceof ExpressionInterface ) { $ columns [ $ i ] = $ this -> buildExpression ( $ column ) ; } elseif ( strpos ( $ column , '(' ) === false ) { $ columns [ $ i ] = $ this -> db -> quoteColumnName ( $ column ) ; } } return implode ( ', ' , $ columns ) ; }
9762	function empty ( ) : self { if ( is_object ( $ this -> target ) && ! ( $ this -> target instanceof \ Countable ) ) { $ constraint = countOf ( 0 ) ; $ target = get_object_vars ( $ this -> target ) ; } else if ( is_string ( $ this -> target ) ) { $ constraint = equalTo ( 0 ) ; $ target = $ this -> hasFlag ( 'file' ) ? @ filesize ( $ this -> target ) : mb_strlen ( $ this -> target ) ; } else { $ constraint = isEmpty ( ) ; $ target = $ this -> target ; } return $ this -> expect ( $ target , $ constraint ) ; }
9850	public function stringToStream ( string $ input ) : StreamInterface { $ stream = \ fopen ( 'php://temp' , 'w+' ) ; if ( ! \ is_resource ( $ stream ) ) { throw new \ Error ( 'Could not create stream' ) ; } \ fwrite ( $ stream , $ input ) ; \ rewind ( $ stream ) ; return new Stream ( $ stream ) ; }
11835	public function save ( IUser $ user ) : bool { if ( ! $ user instanceof Entity ) { return false ; } return entityManager ( ) -> save ( $ user ) ; }
1898	private function checkIfAccountIsActive ( User $ user ) : void { $ config = $ this -> framework -> getAdapter ( Config :: class ) ; $ start = ( int ) $ user -> start ; $ stop = ( int ) $ user -> stop ; $ time = Date :: floorToMinute ( time ( ) ) ; $ notActiveYet = $ start && $ start > $ time ; $ notActiveAnymore = $ stop && $ stop <= ( $ time + 60 ) ; $ logMessage = '' ; if ( $ notActiveYet ) { $ logMessage = sprintf ( 'The account is not active yet (activation date: %s)' , Date :: parse ( $ config -> get ( 'dateFormat' ) , $ start ) ) ; } if ( $ notActiveAnymore ) { $ logMessage = sprintf ( 'The account is not active anymore (deactivation date: %s)' , Date :: parse ( $ config -> get ( 'dateFormat' ) , $ stop ) ) ; } if ( '' === $ logMessage ) { return ; } $ ex = new DisabledException ( $ logMessage ) ; $ ex -> setUser ( $ user ) ; throw $ ex ; }
1704	public function purgeOldFeeds ( ) { $ arrFeeds = array ( ) ; $ objFeeds = NewsFeedModel :: findAll ( ) ; if ( $ objFeeds !== null ) { while ( $ objFeeds -> next ( ) ) { $ arrFeeds [ ] = $ objFeeds -> alias ? : 'news' . $ objFeeds -> id ; } } return $ arrFeeds ; }
10061	public function create ( $ key , $ value ) { $ exists = $ this -> metaModel :: where ( 'key' , $ key ) -> exists ( ) ; if ( $ exists ) { $ message = "Can't create meta (key: $key). " ; $ message .= "Meta already exists" ; throw new \ Exception ( $ message ) ; } $ meta = new $ this -> metaModel ; $ meta -> key = $ key ; $ meta -> value = $ value ; $ meta -> save ( ) ; }
5721	public function doSaveAndPrev ( $ data , $ form ) { Controller :: curr ( ) -> getResponse ( ) -> addHeader ( "X-Pjax" , "Content" ) ; $ link = $ this -> getEditLink ( $ this -> getPreviousRecordID ( ) ) ; return $ this -> saveAndRedirect ( $ data , $ form , $ link ) ; }
10833	public function on ( $ column1 , $ op , $ column2 ) { if ( $ this -> active_join === null ) { throw new \ Peyote \ Exception ( "You need to start a join before calling \Peyote\Join::on()" ) ; } list ( $ table , $ type ) = $ this -> active_join ; $ this -> active_join = null ; $ this -> joins [ ] = array ( "ON" , $ table , $ type , $ column1 , $ op , $ column2 ) ; return $ this ; }
5184	private function lookUp ( array $ articleConstant ) : array { $ copyListAttributes = $ this -> listAttributes ; return array_map ( function ( $ singleConst ) use ( $ copyListAttributes ) { $ res = $ copyListAttributes [ $ singleConst ] ; return array_map ( function ( $ str ) use ( $ singleConst ) { return $ singleConst . $ str ; } , $ res ) ; } , $ articleConstant ) ; }
10865	protected function setInstProperty ( $ inst , $ propertyName , $ mappingDefinition , $ propertyValue = null ) { if ( $ mappingDefinition === false ) { return false ; } if ( func_num_args ( ) <= 3 ) { $ propertyValue = $ this -> $ propertyName ; } if ( $ mappingDefinition === true || is_string ( $ mappingDefinition ) ) { $ instPropertyName = $ mappingDefinition === true ? $ propertyName : $ mappingDefinition ; $ setInstPropertyMethod = 'setInstProperty' . ucfirst ( $ instPropertyName ) ; if ( method_exists ( $ this , $ setInstPropertyMethod ) ) { $ this -> $ setInstPropertyMethod ( $ propertyValue , $ inst ) ; return ; } else { $ instSetterMethod = 'set' . ucfirst ( $ instPropertyName ) ; if ( method_exists ( $ inst , $ instSetterMethod ) ) { $ inst -> $ instSetterMethod ( $ propertyValue ) ; return ; } else { $ inst -> $ instPropertyName = $ propertyValue ; return ; } } } elseif ( is_array ( $ mappingDefinition ) ) { if ( reset ( $ mappingDefinition ) === null ) { $ mappingDefinition [ 0 ] = $ inst ; call_user_func_array ( $ mappingDefinition , [ $ propertyValue ] ) ; return ; } elseif ( reset ( $ mappingDefinition ) === $ this ) { call_user_func_array ( $ mappingDefinition , [ $ propertyValue , $ inst ] ) ; return ; } } throw new \ yii \ base \ ErrorException ( 'Could not set property ' . $ propertyName . ' in wrapped object' ) ; }
10379	protected static function is_modified_file ( $ filepath ) { $ actual = filemtime ( $ filepath ) ; $ last = isset ( self :: $ files [ $ filepath ] ) ? self :: $ files [ $ filepath ] : 0 ; if ( $ actual !== $ last ) { self :: $ files [ $ filepath ] = $ actual ; self :: $ changes = true ; return self :: $ changes ; } return false ; }
5122	private function setAuthorizationHeader ( string $ accessToken ) : self { $ this -> accessToken = $ accessToken ; $ this -> options -> set ( 'default_headers' , array_merge ( $ this -> options -> get ( 'default_headers' ) , [ 'Authorization' => 'Bearer ' . $ accessToken , ] ) ) ; return $ this ; }
3356	public function getPath ( $ postfix = null ) { $ url = sprintf ( '/%s/' , $ this -> uuid ) ; if ( $ this -> default_effects ) { $ url = sprintf ( '%s-/%s' , $ url , $ this -> default_effects ) ; } if ( $ this -> filename && $ postfix === null ) { $ postfix = $ this -> filename ; } $ operations = array ( ) ; foreach ( $ this -> operations as $ i => $ operation_item ) { $ part = array ( ) ; foreach ( array_keys ( $ operation_item ) as $ operation_type ) { $ operation_params = $ operation_item [ $ operation_type ] ; $ part [ ] = $ operation_type ; switch ( $ operation_type ) { case 'crop' : $ part = $ this -> __addPartSize ( $ part , $ operation_params ) ; $ part = $ this -> __addPartCenter ( $ part , $ operation_params ) ; $ part = $ this -> __addPartFillColor ( $ part , $ operation_params ) ; break ; case 'resize' : $ part = $ this -> __addPartSize ( $ part , $ operation_params ) ; break ; case 'scale_crop' : $ part = $ this -> __addPartSize ( $ part , $ operation_params ) ; $ part = $ this -> __addPartCenter ( $ part , $ operation_params ) ; break ; case 'effect' : $ part = $ this -> __addPartEffect ( $ part , $ operation_params ) ; break ; case 'preview' : $ part = $ this -> __addPartSize ( $ part , $ operation_params ) ; break ; case 'custom' : $ part = array ( $ operation_params ) ; break ; } $ part_str = join ( '/' , $ part ) ; $ operations [ ] = $ part_str ; } } if ( count ( $ operations ) ) { $ operations_part = join ( '/-/' , $ operations ) ; return $ url . '-/' . $ operations_part . '/' . $ postfix ; } else { return $ url . $ postfix ; } }
8385	public function groupBy ( $ groupBy ) { if ( is_array ( $ groupBy ) === true ) { $ this -> groupBy = implode ( ', ' , $ groupBy ) ; } else { $ this -> groupBy = $ groupBy ; } return $ this ; }
5669	public function clipString ( $ string , $ size , $ position = 0 ) { $ utf8 = false ; if ( function_exists ( 'mb_detect_encoding' ) && mb_detect_encoding ( $ string ) == 'UTF-8' ) { $ utf8 = true ; } $ length = ( $ utf8 == true ) ? mb_strlen ( $ string , "UTF-8" ) : strlen ( $ string ) ; if ( $ length <= $ size ) { return $ string ; } $ position = min ( $ position , $ length ) ; $ start = ( $ size / 2 > $ position ? 0 : $ position - $ size / 2 ) ; if ( $ start + $ size > $ length ) { $ start = $ length - $ size ; } $ string = ( $ utf8 == true ) ? mb_substr ( $ string , $ start , $ size ) : substr ( $ string , $ start , $ size ) ; return ( $ start > 0 ? '...' : '' ) . $ string . ( $ start + $ size < $ length ? '...' : '' ) ; }
4406	public function matches ( Request $ request ) { return in_array ( $ request -> attributes -> get ( '_route' ) , array ( FallbackRouter :: ROUTE_NAME , UrlAliasRouter :: URL_ALIAS_ROUTE_NAME ) , true ) ; }
883	private function isUseForLambda ( Tokens $ tokens , $ index ) { $ nextToken = $ tokens [ $ tokens -> getNextMeaningfulToken ( $ index ) ] ; return $ nextToken -> equals ( '(' ) ; }
1960	public static function decode ( $ strDomain ) { if ( $ strDomain == '' ) { return '' ; } $ objPunycode = new Punycode ( ) ; try { return $ objPunycode -> decode ( $ strDomain ) ; } catch ( LabelOutOfBoundsException $ e ) { return '' ; } }
2150	public function activateAccount ( $ objUser ) { $ arrNewsletters = StringUtil :: deserialize ( $ objUser -> newsletter , true ) ; if ( ! \ is_array ( $ arrNewsletters ) ) { return ; } foreach ( $ arrNewsletters as $ intNewsletter ) { $ intNewsletter = ( int ) $ intNewsletter ; if ( $ intNewsletter < 1 ) { continue ; } $ this -> Database -> prepare ( "UPDATE tl_newsletter_recipients SET active='1' WHERE pid=? AND email=?" ) -> execute ( $ intNewsletter , $ objUser -> email ) ; } }
10094	protected function srvGet ( $ domain , $ https = false ) { if ( isset ( $ https ) && $ https === true ) { $ subdomain = '_avatars-sec._tcp.' ; $ fallback = 'seccdn.' ; $ port = 443 ; } else { $ subdomain = '_avatars._tcp.' ; $ fallback = 'cdn.' ; $ port = 80 ; } if ( $ domain === null ) { return $ fallback . 'libravatar.org' ; } $ srv = dns_get_record ( $ subdomain . $ domain , DNS_SRV ) ; if ( count ( $ srv ) == 0 ) { return $ fallback . 'libravatar.org' ; } usort ( $ srv , array ( $ this , 'comparePriority' ) ) ; $ top = $ srv [ 0 ] ; $ sum = 0 ; shuffle ( $ srv ) ; $ srvs = array ( ) ; foreach ( $ srv as $ s ) { if ( $ s [ 'weight' ] == 0 ) { array_unshift ( $ srvs , $ s ) ; } else { array_push ( $ srvs , $ s ) ; } } foreach ( $ srvs as $ s ) { if ( $ s [ 'pri' ] == $ top [ 'pri' ] ) { $ sum += ( int ) $ s [ 'weight' ] ; $ pri [ $ sum ] = $ s ; } } $ random = rand ( 0 , $ sum ) ; foreach ( $ pri as $ k => $ v ) { if ( $ k >= $ random ) { $ target = $ v [ 'target' ] ; if ( $ v [ 'port' ] !== $ port ) { $ target .= ':' . $ v [ 'port' ] ; } return $ target ; } } }
9217	protected function parsePageLinks ( $ headers = false ) { $ pagination = [ ] ; if ( ! $ headers ) { $ headers = $ this -> api -> lastHeader ( 'link' ) ; } if ( preg_match_all ( '%<([^>]*)>\s*;\s*rel="([^"]+)"%' , $ headers , $ links , PREG_SET_ORDER ) ) { foreach ( $ links as $ link ) { $ pagination [ $ link [ 2 ] ] = new CanvasPageLink ( $ link [ 1 ] , $ link [ 2 ] ) ; } } return $ pagination ; }
8967	public static function clean ( $ currencyCode ) { $ clean = trim ( strtoupper ( $ currencyCode ) ) ; if ( ! self :: exists ( $ clean ) ) { throw new UnknownCurrencyCodeException ( sprintf ( 'Unknown currency code "%s".' , $ currencyCode ) ) ; } return $ clean ; }
7195	public function onPrepare ( ResourceEventInterface $ event ) { $ order = $ this -> getSaleFromEvent ( $ event ) ; if ( ! OrderStates :: isStockableState ( $ order -> getState ( ) ) ) { throw new IllegalOperationException ( "Order is not ready for shipment preparation" ) ; } }
12147	public function hasException ( \ Exception $ exception ) { $ class = get_class ( $ exception ) ; $ exceptions = $ this -> getExceptions ( ) ; return isset ( $ exceptions [ $ class ] ) ; }
10227	public function pageFor ( $ model , $ itemId = 0 , ModelConfig $ config = null ) { $ modelName = $ this -> resolveModelName ( $ model ) ; $ item = $ this -> findItem ( $ modelName , $ itemId ) ; $ pageFactory = $ this -> app -> make ( 'Label305\AujaLaravel\Factory\PageFactory' ) ; return $ pageFactory -> create ( $ modelName , $ item , $ config ) ; }
265	public function setLogger ( $ value ) { if ( is_string ( $ value ) || is_array ( $ value ) ) { $ value = Yii :: createObject ( $ value ) ; } $ this -> _logger = $ value ; $ this -> _logger -> dispatcher = $ this ; }
7012	private function formatF ( & $ str ) { if ( strstr ( $ str , '%F' ) ) $ str = str_replace ( '%F' , $ this -> monthName ( true ) , $ str ) ; }
3560	protected function getValueType ( $ value ) { $ type = is_object ( $ value ) ? get_class ( $ value ) : gettype ( $ value ) ; return ( $ type == 'double' ) ? 'float' : $ type ; }
4088	protected function transformDSLSortToString ( $ dslSort ) { $ string = "" ; if ( is_array ( $ dslSort ) ) { foreach ( $ dslSort as $ sort ) { if ( is_array ( $ sort ) ) { $ field = key ( $ sort ) ; $ info = current ( $ sort ) ; } else $ field = $ sort ; $ string .= "&sort=" . $ field ; if ( isset ( $ info ) ) { if ( is_string ( $ info ) && $ info == "desc" ) $ string .= ":reverse" ; elseif ( is_array ( $ info ) && array_key_exists ( "reverse" , $ info ) && $ info [ 'reverse' ] ) $ string .= ":reverse" ; } } } return $ string ; }
7293	public function save_transit_posts ( $ new_status , $ old_status , $ post ) { $ this -> transit_posts [ $ post -> ID ] = array ( 'old_status' => $ old_status , 'new_status' => $ new_status ) ; }
3393	public function register ( Request $ request ) { $ this -> validator ( $ request -> all ( ) ) -> validate ( ) ; event ( new Registered ( $ user = $ this -> create ( $ request -> all ( ) ) ) ) ; $ this -> sendConfirmationToUser ( $ user ) ; return $ this -> registered ( $ request , $ user ) ? : redirect ( $ this -> redirectAfterRegistrationPath ( ) ) -> with ( 'confirmation' , __ ( 'confirmation::confirmation.confirmation_info' ) ) ; }
664	public function useMaster ( callable $ callback ) { if ( $ this -> enableSlaves ) { $ this -> enableSlaves = false ; try { $ result = call_user_func ( $ callback , $ this ) ; } catch ( \ Exception $ e ) { $ this -> enableSlaves = true ; throw $ e ; } catch ( \ Throwable $ e ) { $ this -> enableSlaves = true ; throw $ e ; } $ this -> enableSlaves = true ; } else { $ result = call_user_func ( $ callback , $ this ) ; } return $ result ; }
2805	public function viewAction ( ) { $ token = ( string ) $ this -> getRequest ( ) -> getParam ( 'token' ) ; if ( ! $ token ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 400 ) ; return $ this -> _getRefererUrl ( ) ; } $ requestInfo = Mage :: getModel ( 'sheep_debug/requestInfo' ) -> load ( $ token , 'token' ) ; if ( ! $ requestInfo -> getId ( ) ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 404 ) ; return $ this -> _getRefererUrl ( ) ; } $ section = $ this -> getRequest ( ) -> getParam ( 'panel' , 'request' ) ; if ( ! in_array ( $ section , array ( 'request' , 'performance' , 'events' , 'db' , 'logging' , 'email' , 'layout' , 'config' ) ) ) { $ section = 'request' ; } Mage :: register ( 'sheep_debug_request_info' , $ requestInfo ) ; $ blockName = 'sheep_debug_' . $ section ; $ blockTemplate = "sheep_debug/view/panel/{$section}.phtml" ; $ this -> loadLayout ( ) ; $ layout = $ this -> getLayout ( ) ; $ sectionBlock = $ layout -> createBlock ( 'sheep_debug/view' , $ blockName , array ( 'template' => $ blockTemplate ) ) ; $ layout -> getBlock ( 'sheep_debug_content' ) -> insert ( $ sectionBlock ) ; $ layout -> getBlock ( 'root' ) -> setHeaderTitle ( $ this -> __ ( 'Profile for request %s (%s)' , $ requestInfo -> getRequestPath ( ) , $ requestInfo -> getToken ( ) ) ) ; $ this -> renderLayout ( ) ; }
9832	public function setRevisionsPassword ( $ pValue , $ pAlreadyHashed = false ) { if ( ! $ pAlreadyHashed ) { $ pValue = PasswordHasher :: hashPassword ( $ pValue ) ; } $ this -> revisionsPassword = $ pValue ; return $ this ; }
8008	public static function forStringAndEncodings ( $ string , $ from_encoding , $ to_encoding , $ code = self :: CODE_FOR_STRING_AND_ENCODING_INFO , Exception $ previous = null ) { $ message = self :: DEFAULT_MESSAGE . sprintf ( self :: MESSAGE_EXTENSION_FOR_STRING_FORMAT , $ string ) . sprintf ( self :: MESSAGE_EXTENSION_FOR_ENCODING_INFO_FORMAT , $ from_encoding , $ to_encoding ) ; return new static ( $ message , $ code , $ previous ) ; }
398	public function delete ( ) { if ( ! $ this -> isTransactional ( self :: OP_DELETE ) ) { return $ this -> deleteInternal ( ) ; } $ transaction = static :: getDb ( ) -> beginTransaction ( ) ; try { $ result = $ this -> deleteInternal ( ) ; if ( $ result === false ) { $ transaction -> rollBack ( ) ; } else { $ transaction -> commit ( ) ; } return $ result ; } catch ( \ Exception $ e ) { $ transaction -> rollBack ( ) ; throw $ e ; } catch ( \ Throwable $ e ) { $ transaction -> rollBack ( ) ; throw $ e ; } }
8328	public function getCaptchaResult ( $ captchaId ) { $ response = $ this -> getHttpClient ( ) -> request ( 'GET' , "/res.php?key={$this->apiKey}&action=get&id={$captchaId}&json=1" ) ; $ responseData = json_decode ( $ response -> getBody ( ) -> __toString ( ) , true ) ; if ( JSON_ERROR_NONE !== json_last_error ( ) ) { throw new InvalidArgumentException ( 'json_decode error: ' . json_last_error_msg ( ) ) ; } if ( $ responseData [ 'status' ] === self :: STATUS_CODE_CAPCHA_NOT_READY ) { return false ; } if ( $ responseData [ 'status' ] === self :: STATUS_CODE_OK ) { $ this -> getLogger ( ) -> info ( "Got OK response: `{$responseData['request']}`." ) ; return $ responseData [ 'request' ] ; } throw new ErrorResponseException ( $ this -> getErrorMessage ( $ responseData [ 'request' ] ) ? : $ responseData [ 'request' ] , $ responseData [ 'status' ] ) ; }
7837	public function register ( ) { $ className = studly_case ( strtolower ( config ( 'message.vendor' , 'smsgatewayme' ) ) ) ; $ classPath = '\Yugo\SMSGateway\Vendors\\' . $ className ; if ( ! class_exists ( $ classPath ) ) { abort ( 500 , sprintf ( 'SMS vendor %s is not available.' , $ className ) ) ; } app ( ) -> bind ( SMS :: class , $ classPath ) ; }
5937	public function setFunctionalities ( array $ functionalities ) { $ this -> functionalities = [ ] ; foreach ( $ functionalities as $ item ) { $ this -> addFunctionality ( $ item ) ; } return $ this ; }
2485	public function bulkIndexDocuments ( array $ documents ) { $ documentMap = array ( ) ; $ mainTranslationsEndpoint = $ this -> endpointResolver -> getMainLanguagesEndpoint ( ) ; $ mainTranslationsDocuments = array ( ) ; foreach ( $ documents as $ translationDocuments ) { foreach ( $ translationDocuments as $ document ) { $ documentMap [ $ document -> languageCode ] [ ] = $ document ; if ( $ mainTranslationsEndpoint !== null && $ document -> isMainTranslation ) { $ mainTranslationsDocuments [ ] = $ this -> getMainTranslationDocument ( $ document ) ; } } } foreach ( $ documentMap as $ languageCode => $ translationDocuments ) { $ this -> doBulkIndexDocuments ( $ this -> endpointRegistry -> getEndpoint ( $ this -> endpointResolver -> getIndexingTarget ( $ languageCode ) ) , $ translationDocuments ) ; } if ( ! empty ( $ mainTranslationsDocuments ) ) { $ this -> doBulkIndexDocuments ( $ this -> endpointRegistry -> getEndpoint ( $ mainTranslationsEndpoint ) , $ mainTranslationsDocuments ) ; } }
7425	public function setSource ( $ source = '' ) { if ( ! $ this -> isValid ( $ source ) ) { throw new InvalidSourceExtensionException ( ) ; } $ this -> source = $ source ; return $ this ; }
4445	public function failed ( ) : array { $ results = json_decode ( $ this -> client -> failed ( ) , true ) ; return is_array ( $ results ) ? $ results : [ ] ; }
1115	public function getQualifiedScopedColumns ( ) { if ( ! $ this -> isScoped ( ) ) return $ this -> getScopedColumns ( ) ; $ prefix = $ this -> getTable ( ) . '.' ; return array_map ( function ( $ c ) use ( $ prefix ) { return $ prefix . $ c ; } , $ this -> getScopedColumns ( ) ) ; }
9860	private static function getInt4d ( $ data , $ pos ) { if ( trim ( $ data ) == '' ) { throw new ReaderException ( 'Parameter data is empty.' ) ; } elseif ( $ pos < 0 ) { throw new ReaderException ( 'Parameter pos=' . $ pos . ' is invalid.' ) ; } $ len = strlen ( $ data ) ; if ( $ len < $ pos + 4 ) { $ data .= str_repeat ( "\0" , $ pos + 4 - $ len ) ; } $ _or_24 = ord ( $ data [ $ pos + 3 ] ) ; if ( $ _or_24 >= 128 ) { $ _ord_24 = - abs ( ( 256 - $ _or_24 ) << 24 ) ; } else { $ _ord_24 = ( $ _or_24 & 127 ) << 24 ; } return ord ( $ data [ $ pos ] ) | ( ord ( $ data [ $ pos + 1 ] ) << 8 ) | ( ord ( $ data [ $ pos + 2 ] ) << 16 ) | $ _ord_24 ; }
12870	public function unbind ( ) : bool { if ( $ this -> _bConnected ) { return $ this -> _bConnected = ldap_unbind ( $ this -> _rConnect ) ; } else { return true ; } }
2362	public static function findFirstActiveWithJumpToByIds ( $ arrIds ) { @ trigger_error ( 'Using MemberGroupModel::findFirstActiveWithJumpToByIds() has been deprecated and will no longer work in Contao 5.0. Use PageModel::findFirstActiveByMemberGroups() instead.' , E_USER_DEPRECATED ) ; if ( empty ( $ arrIds ) || ! \ is_array ( $ arrIds ) ) { return null ; } $ time = Date :: floorToMinute ( ) ; $ objDatabase = Database :: getInstance ( ) ; $ arrIds = array_map ( '\intval' , $ arrIds ) ; $ objResult = $ objDatabase -> prepare ( "SELECT p.* FROM tl_member_group g LEFT JOIN tl_page p ON g.jumpTo=p.id WHERE g.id IN(" . implode ( ',' , $ arrIds ) . ") AND g.jumpTo>0 AND g.redirect='1' AND g.disable!='1' AND (g.start='' OR g.start<='$time') AND (g.stop='' OR g.stop>'" . ( $ time + 60 ) . "') AND p.published='1' AND (p.start='' OR p.start<='$time') AND (p.stop='' OR p.stop>'" . ( $ time + 60 ) . "') ORDER BY " . $ objDatabase -> findInSet ( 'g.id' , $ arrIds ) ) -> limit ( 1 ) -> execute ( ) ; if ( $ objResult -> numRows < 1 ) { return null ; } return new static ( $ objResult ) ; }
1278	public static function addLocationInformation ( stdClass $ location , DOMNode $ locationNode ) { self :: appendChild ( $ location , 'CompanyName' , $ locationNode ) ; self :: appendChild ( $ location , 'AttentionName' , $ locationNode ) ; if ( isset ( $ location -> Address ) ) { self :: addAddressNode ( $ location -> Address , $ locationNode ) ; } }
8047	public function send ( $ data ) { $ serialized = serialize ( $ data ) ; $ hdr = pack ( 'N' , strlen ( $ serialized ) ) ; $ buffer = $ hdr . $ serialized ; unset ( $ serialized ) ; unset ( $ hdr ) ; $ total = strlen ( $ buffer ) ; while ( $ total > 0 ) { $ sent = socket_write ( $ this -> socket , $ buffer ) ; if ( $ sent === FALSE ) { throw new SimpleSocketException ( 'Sending failed with: ' . socket_strerror ( socket_last_error ( $ this -> socket ) ) ) ; } $ total -= $ sent ; $ buffer = substr ( $ buffer , $ sent ) ; } }
7412	protected function customChmod ( string $ target , $ mode = 0666 ) { if ( false === @ chmod ( $ target , $ mode & ~ umask ( ) ) ) { throw new FileException ( sprintf ( 'Unable to change mode of the "%s"' , $ target ) ) ; } }
2353	protected function fputs ( $ varData , $ strMode ) { if ( ! \ is_resource ( $ this -> resFile ) ) { $ this -> strTmp = 'system/tmp/' . md5 ( uniqid ( mt_rand ( ) , true ) ) ; if ( strncmp ( $ strMode , 'a' , 1 ) === 0 && file_exists ( $ this -> strRootDir . '/' . $ this -> strFile ) ) { $ this -> Files -> copy ( $ this -> strFile , $ this -> strTmp ) ; } if ( ! $ this -> resFile = $ this -> Files -> fopen ( $ this -> strTmp , $ strMode ) ) { return false ; } } fwrite ( $ this -> resFile , $ varData ) ; return true ; }
7440	protected function reloadModule ( Wrapper $ wrapper , $ module ) { $ moduleStatus = $ wrapper -> ModuleManager -> reload ( $ module ) ; $ module = Inflector :: camelize ( $ module ) ; switch ( $ moduleStatus ) { case 'AU' : $ wrapper -> Channel -> sendMessage ( 'The Module `' . $ module . '` doesn\'t exist and cannot be reloaded.' ) ; break ; case 'AL' : $ wrapper -> Channel -> sendMessage ( 'The Module `' . $ module . '` is already loaded.' ) ; break ; case 'L' : $ wrapper -> Channel -> sendMessage ( 'Module `' . $ module . '` reloaded successfully.' ) ; break ; case 'NF' : $ wrapper -> Channel -> sendMessage ( 'Failed to reload the Module `' . $ module . '`.' ) ; break ; } }
1170	protected function createProtectedCaller ( $ instance ) { $ closure = function ( $ method , $ args ) { $ callable = [ $ this , $ method ] ; return call_user_func_array ( $ callable , $ args ) ; } ; return $ closure -> bindTo ( $ instance , $ instance ) ; }
5925	public function addFilterItem ( $ item ) { if ( ! ( $ item instanceof self ) ) { if ( is_array ( $ item ) ) { try { $ item = new self ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate FilterItem. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "FilterItem"!' , E_USER_WARNING ) ; } } $ this -> filterItems [ ] = $ item ; return $ this ; }
845	public function ensureWhitespaceAtIndex ( $ index , $ indexOffset , $ whitespace ) { $ removeLastCommentLine = static function ( self $ tokens , $ index , $ indexOffset , $ whitespace ) { $ token = $ tokens [ $ index ] ; if ( 1 === $ indexOffset && $ token -> isGivenKind ( T_OPEN_TAG ) ) { if ( 0 === strpos ( $ whitespace , "\r\n" ) ) { $ tokens [ $ index ] = new Token ( [ T_OPEN_TAG , rtrim ( $ token -> getContent ( ) ) . "\r\n" ] ) ; return \ strlen ( $ whitespace ) > 2 ? substr ( $ whitespace , 2 ) : '' ; } $ tokens [ $ index ] = new Token ( [ T_OPEN_TAG , rtrim ( $ token -> getContent ( ) ) . $ whitespace [ 0 ] ] ) ; return \ strlen ( $ whitespace ) > 1 ? substr ( $ whitespace , 1 ) : '' ; } return $ whitespace ; } ; if ( $ this [ $ index ] -> isWhitespace ( ) ) { $ whitespace = $ removeLastCommentLine ( $ this , $ index - 1 , $ indexOffset , $ whitespace ) ; if ( '' === $ whitespace ) { $ this -> clearAt ( $ index ) ; } else { $ this [ $ index ] = new Token ( [ T_WHITESPACE , $ whitespace ] ) ; } return false ; } $ whitespace = $ removeLastCommentLine ( $ this , $ index , $ indexOffset , $ whitespace ) ; if ( '' === $ whitespace ) { return false ; } $ this -> insertAt ( $ index + $ indexOffset , [ new Token ( [ T_WHITESPACE , $ whitespace ] ) , ] ) ; return true ; }
1000	public function getDirective ( $ name ) { foreach ( $ this -> getDirectives ( ) as $ directive ) { if ( $ directive -> name === $ name ) { return $ directive ; } } return null ; }
2780	public function buildOptions ( ) : array { $ options = [ ] ; foreach ( $ this -> options as $ option => $ values ) { foreach ( ( array ) $ values as $ value ) { $ prefix = strlen ( $ option ) !== 1 ? '--' : '-' ; $ options [ ] = $ prefix . $ option ; if ( $ value !== true ) { $ options [ ] = $ value ; } } } return $ options ; }
2002	public static function getVersion ( string $ packageName ) : string { $ version = Versions :: getVersion ( $ packageName ) ; return static :: parseVersion ( $ version ) ; }
12222	private function prepareErrorBody ( Exception $ exception ) { $ body = [ 'errors' => [ ] ] ; if ( ! empty ( $ statusCode = $ exception -> getStatusCode ( ) ) ) { $ body [ 'errors' ] [ 'statusCode' ] = $ statusCode ; } if ( ! empty ( $ description = $ exception -> getDescription ( ) ) ) { $ body [ 'errors' ] [ 'description' ] = $ description ; } if ( ! empty ( $ message = $ exception -> getMessage ( ) ) ) { $ body [ 'errors' ] [ 'message' ] = $ message ; } if ( ! empty ( $ code = $ exception -> getCode ( ) ) ) { $ body [ 'errors' ] [ 'code' ] = $ code ; } if ( ! empty ( $ link = $ exception -> getLink ( ) ) ) { $ body [ 'errors' ] [ 'link' ] = $ link ; } return $ body ; }
1685	public function checkAdminDisable ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ varValue == 1 && $ this -> User -> id == $ dc -> id ) { $ varValue = '' ; } return $ varValue ; }
785	protected function generateEtag ( $ seed ) { $ etag = '"' . rtrim ( base64_encode ( sha1 ( $ seed , true ) ) , '=' ) . '"' ; return $ this -> weakEtag ? 'W/' . $ etag : $ etag ; }
2936	public function getBackups ( ) { $ backups = array_diff ( scandir ( $ this -> backupPath ) , array ( '..' , '.' ) ) ; $ output = [ ] ; foreach ( $ backups as $ backup ) { $ filenamePrefix = preg_quote ( self :: BACKUP_FILENAME_PREFIX , '/' ) ; $ filenameSuffix = preg_quote ( self :: BACKUP_FILENAME_SUFFIX , '/' ) ; $ filenameRegex = '/^' . $ filenamePrefix . '(\d{4})_(\d{2})_(\d{2})_(\d{2})(\d{2})(\d{2})' . $ filenameSuffix . '$/' ; $ datetime = preg_replace ( $ filenameRegex , '$1-$2-$3 $4:$5:$6' , $ backup ) ; $ data = [ 'filename' => $ backup , 'filepath' => $ this -> backupPath . $ backup , 'created_at' => $ datetime , ] ; $ output [ ] = $ data ; } return $ output ; }
6490	public function getDrupalSelector ( $ name ) { $ selectors = $ this -> getDrupalParameter ( 'selectors' ) ; if ( ! isset ( $ selectors [ $ name ] ) ) { throw new \ Exception ( sprintf ( 'No such selector configured: %s' , $ name ) ) ; } return $ selectors [ $ name ] ; }
10393	private function isValidOperation ( $ operationType ) { $ operationType = strtoupper ( $ operationType ) ; return in_array ( $ operationType , [ ActionTypes :: CREATE , ActionTypes :: UPDATE , ActionTypes :: DELETE , ] ) ; }
1902	public function prepare ( $ strQuery ) { if ( $ strQuery == '' ) { throw new \ Exception ( 'Empty query string' ) ; } $ this -> strQuery = trim ( $ strQuery ) ; if ( strncasecmp ( $ this -> strQuery , 'INSERT' , 6 ) === 0 || strncasecmp ( $ this -> strQuery , 'UPDATE' , 6 ) === 0 ) { $ this -> strQuery = str_replace ( '%s' , '%p' , $ this -> strQuery ) ; } $ arrChunks = preg_split ( "/('[^']*')/" , $ this -> strQuery , - 1 , PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY ) ; foreach ( $ arrChunks as $ k => $ v ) { if ( substr ( $ v , 0 , 1 ) == "'" ) { continue ; } $ arrChunks [ $ k ] = str_replace ( '?' , '%s' , $ v ) ; } $ this -> strQuery = implode ( '' , $ arrChunks ) ; return $ this ; }
5946	public function property ( $ systemName , $ preloadNames = false , $ categoryIds = null , $ deploymentSiteIds = null , $ isHierarchical = false , $ ignoreGrouping = false , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'preloadNames' => $ preloadNames , 'categoryIds' => $ categoryIds , 'deploymentSiteIds' => $ deploymentSiteIds , 'isHierarchical' => $ isHierarchical , 'ignoreGrouping' => $ ignoreGrouping ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/filters/property/' . $ systemName . '' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new FilterItem ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
4656	public function create ( Job $ job ) { $ context = new Context ( $ this -> buildPath . DIRECTORY_SEPARATOR . $ job -> getDirectory ( ) ) ; $ buildStream = $ this -> docker -> getImageManager ( ) -> build ( $ context -> toStream ( ) , [ 't' => $ job -> getName ( ) , 'q' => $ this -> quietBuild , 'nocache' => ! $ this -> usecache ] , ImageManager :: FETCH_STREAM ) ; $ buildStream -> onFrame ( $ this -> logger -> getBuildCallback ( ) ) ; $ buildStream -> wait ( ) ; try { return $ this -> docker -> getImageManager ( ) -> find ( $ job -> getName ( ) ) ; } catch ( ClientErrorException $ e ) { if ( $ e -> getResponse ( ) -> getStatusCode ( ) == 404 ) { return false ; } throw $ e ; } }
5181	private function appendToArray ( string $ key , $ value ) : self { $ this -> props [ $ key ] = [ $ this -> props [ $ key ] , $ value ] ; return $ this ; }
7953	public function getSpam ( $ ipblock , $ spamstate ) { if ( ! $ ipblock ) throw new BadMethodCallException ( 'Parameter $ipblock is missing.' ) ; if ( ! $ spamstate ) throw new BadMethodCallException ( 'Parameter $spamstate is missing.' ) ; switch ( $ spamstate ) { case "blockedForSpam" : case "unblocked" : case "unblocking" : break ; default : throw new BadMethodCallException ( 'Parameter $spamstate is invalid.' ) ; } try { $ r = $ this -> get ( 'ip/' . urlencode ( $ ipblock ) . '/spam/?state=' . $ spamstate ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new IpException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
4857	public function getParams ( $ namespace , $ defaults , $ params = null ) { $ session = new Container ( $ namespace ) ; $ sessionParams = $ session -> params ? : array ( ) ; $ params = $ params ? : clone $ this -> getController ( ) -> getRequest ( ) -> getQuery ( ) ; if ( $ params -> get ( 'clear' ) ) { $ sessionParams = array ( ) ; unset ( $ params [ 'clear' ] ) ; } $ changed = false ; foreach ( $ defaults as $ key => $ default ) { if ( is_numeric ( $ key ) ) { $ key = $ default ; $ default = null ; } $ value = $ params -> get ( $ key ) ; if ( null === $ value ) { if ( isset ( $ sessionParams [ $ key ] ) ) { $ params -> set ( $ key , $ sessionParams [ $ key ] ) ; } elseif ( null !== $ default ) { $ params -> set ( $ key , $ default ) ; $ sessionParams [ $ key ] = $ default ; $ changed = true ; } } else { if ( ! isset ( $ sessionParams [ $ key ] ) || $ sessionParams [ $ key ] != $ value ) { $ changed = true ; $ sessionParams [ $ key ] = $ value ; } } } if ( $ changed ) { unset ( $ session -> list ) ; $ session -> params = $ sessionParams ; } return $ params ; }
7799	protected function getLine ( $ id , $ text , $ offset = 0 , & $ position = null , & $ length = null ) { $ pcre = '/(?:^|\r?\n)\:(' . $ id . ')\:' . '(.+)' . '(:?$|\r?\n\:[[:alnum:]]{2,3}\:)' . '/Us' ; if ( preg_match ( $ pcre , substr ( $ text , $ offset ) , $ match , PREG_OFFSET_CAPTURE ) ) { $ position = $ offset + $ match [ 1 ] [ 1 ] - 1 ; $ length = strlen ( $ match [ 2 ] [ 0 ] ) ; return rtrim ( $ match [ 2 ] [ 0 ] ) ; } return '' ; }
7697	function MsPowerpoint_SearchInSlides ( $ str , $ returnFirstFound = true ) { $ this -> MsPowerpoint_InitSlideLst ( ) ; $ files = array ( ) ; foreach ( $ this -> OpenXmlSlideLst as $ i => $ s ) $ files [ $ i + 1 ] = $ s [ 'idx' ] ; $ find = $ this -> TbsSearchInFiles ( $ files , $ str , $ returnFirstFound ) ; return $ find ; }
4862	private function createEnvelope ( JobInterface $ job , array $ options = [ ] ) { $ scheduled = $ this -> parseOptionsToDateTime ( $ options ) ; $ tried = isset ( $ options [ 'tried' ] ) ? ( int ) $ options [ 'tried' ] : null ; $ message = isset ( $ options [ 'message' ] ) ? $ options [ 'message' ] : null ; $ trace = isset ( $ options [ 'trace' ] ) ? $ options [ 'trace' ] : null ; $ envelope = [ 'queue' => $ this -> getName ( ) , 'status' => self :: STATUS_PENDING , 'tried' => $ tried , 'message' => $ message , 'trace' => $ trace , 'created' => $ this -> dateTimeToUTCDateTime ( $ this -> now ) , 'data' => $ this -> serializeJob ( $ job ) , 'scheduled' => $ this -> dateTimeToUTCDateTime ( $ scheduled ) , 'priority' => isset ( $ options [ 'priority' ] ) ? $ options [ 'priority' ] : self :: DEFAULT_PRIORITY , ] ; return $ envelope ; }
11975	private function secondParamValidation ( Event $ event ) { $ params = $ event -> getCustomParams ( ) ; return ( ! isset ( $ params [ 1 ] ) || ( is_numeric ( $ params [ 1 ] ) && $ params [ 1 ] >= 1 && $ params [ 1 ] <= $ this -> maxDieSides ) ) ; }
2310	public function setZoomLevel ( $ zoomLevel ) { $ zoomLevel = ( int ) $ zoomLevel ; if ( $ zoomLevel < 0 || $ zoomLevel > 100 ) { throw new \ InvalidArgumentException ( 'Zoom level must be between 0 and 100!' ) ; } $ this -> zoomLevel = $ zoomLevel ; return $ this ; }
9894	public function add ( $ item ) { if ( $ item instanceof ShippingMethodInterface ) { $ this -> items [ ] = $ item ; } else { $ this -> items [ ] = new Item ( $ item ) ; } }
3351	private function __setRequestType ( $ ch , $ type = 'GET' ) { $ this -> current_method = strtoupper ( $ type ) ; switch ( $ type ) { case 'GET' : break ; case 'POST' : curl_setopt ( $ ch , CURLOPT_POST , true ) ; break ; case 'PUT' : curl_setopt ( $ ch , CURLOPT_CUSTOMREQUEST , 'PUT' ) ; break ; case 'DELETE' : curl_setopt ( $ ch , CURLOPT_CUSTOMREQUEST , 'DELETE' ) ; break ; case 'HEAD' : curl_setopt ( $ ch , CURLOPT_CUSTOMREQUEST , 'HEAD' ) ; curl_setopt ( $ ch , CURLOPT_NOBODY , true ) ; break ; case 'OPTIONS' : curl_setopt ( $ ch , CURLOPT_CUSTOMREQUEST , 'OPTIONS' ) ; break ; default : throw new \ Exception ( 'No request type is provided for request. Use post, put, delete, get or appropriate constants.' ) ; } }
1125	public function isDescendantOf ( $ other ) { return ( $ this -> getLeft ( ) > $ other -> getLeft ( ) && $ this -> getLeft ( ) < $ other -> getRight ( ) && $ this -> inSameScope ( $ other ) ) ; }
2108	public static function findByRelatedTableAndIds ( $ strTable , array $ arrIds , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ objDatabase = Database :: getInstance ( ) ; $ objResult = $ objDatabase -> prepare ( "SELECT * FROM $t WHERE $t.id IN (SELECT pid FROM tl_opt_in_related WHERE relTable=? AND relId IN(" . implode ( ',' , array_map ( '\intval' , $ arrIds ) ) . ")) ORDER BY $t.createdOn DESC" ) -> execute ( $ strTable , $ arrIds ) ; if ( $ objResult -> numRows < 1 ) { return null ; } $ arrModels = array ( ) ; $ objRegistry = Registry :: getInstance ( ) ; while ( $ objResult -> next ( ) ) { if ( $ objOptIn = $ objRegistry -> fetch ( $ t , $ objResult -> id ) ) { $ arrModels [ ] = $ objOptIn ; } else { $ arrModels [ ] = new static ( $ objResult -> row ( ) ) ; } } return static :: createCollection ( $ arrModels , $ t ) ; }
7704	function OpenDoc_MsExcelCompatibility ( & $ Txt ) { $ el_tbl = 'table:table' ; $ el_col = 'table:table-column' ; $ el_row = 'table:table-row' ; $ el_cell = 'table:table-cell' ; $ att_rep_col = 'table:number-columns-repeated' ; $ att_rep_row = 'table:number-rows-repeated' ; $ loop = array ( $ att_rep_col , $ att_rep_row ) ; foreach ( $ loop as $ att_rep ) { $ p = 0 ; while ( $ xml = clsTbsXmlLoc :: FindElementHavingAtt ( $ Txt , $ att_rep , $ p ) ) { $ xml -> FindName ( ) ; $ p = $ xml -> PosEnd ; $ next = clsTbsXmlLoc :: FindStartTagByPrefix ( $ Txt , '' , $ p ) ; $ next_name = $ next -> Name ; if ( $ next_name == '' ) { $ next_name = $ next -> GetSrc ( ) ; $ next_name = substr ( $ next_name , 1 , strlen ( $ next_name ) - 2 ) ; } ; $ z_src = $ next -> GetSrc ( ) ; $ delete = false ; if ( ( $ xml -> Name == $ el_col ) && ( $ xml -> SelfClosing ) ) { if ( ( $ next_name == $ el_row ) || ( $ next_name == '/' . $ el_tbl ) ) { $ delete = true ; } } elseif ( ( $ xml -> Name == $ el_cell ) && ( $ xml -> SelfClosing ) ) { if ( $ next_name == '/' . $ el_row ) { $ delete = true ; } } elseif ( $ xml -> Name == $ el_row ) { if ( $ next_name == '/' . $ el_tbl ) { $ inner_src = '' . $ xml -> GetInnerSrc ( ) ; if ( strpos ( $ inner_src , '<' ) === false ) { $ delete = true ; } } } if ( $ delete ) { $ p = $ xml -> PosBeg ; $ xml -> Delete ( ) ; } } } }
8308	public function assertArrayOfStrings ( $ config , $ key ) { if ( ! array_key_exists ( $ key , $ config ) ) { return $ this ; } if ( ! is_array ( $ config [ $ key ] ) ) { throw new ConfigurationException ( $ key . " section must be an array." ) ; } foreach ( $ config [ $ key ] as $ value ) { if ( ! is_string ( $ value ) ) { throw new ConfigurationException ( "Values in the `{$key}` must be strings" . gettype ( $ value ) . " found." ) ; } elseif ( $ value === "" ) { throw new ConfigurationException ( "Empty string not allowed in `{$key}` array." ) ; } } return $ this ; }
7591	public function render ( $ sBadgeMessage , array $ aBadgeAttributes = null ) { if ( ! is_scalar ( $ sBadgeMessage ) ) { throw new InvalidArgumentException ( sprintf ( 'Badge message expects a scalar value, "%s" given' , is_object ( $ sBadgeMessage ) ? get_class ( $ sBadgeMessage ) : gettype ( $ sBadgeMessage ) ) ) ; } if ( empty ( $ aBadgeAttributes ) ) { $ aBadgeAttributes = array ( 'class' => 'badge' ) ; } else { if ( empty ( $ aBadgeAttributes [ 'class' ] ) ) { $ aBadgeAttributes [ 'class' ] = 'badge' ; } elseif ( ! preg_match ( '/(\s|^)badge(\s|$)/' , $ aBadgeAttributes [ 'class' ] ) ) { $ aBadgeAttributes [ 'class' ] .= ' badge' ; } } if ( null !== ( $ oTranslator = $ this -> getTranslator ( ) ) ) { $ sBadgeMessage = $ oTranslator -> translate ( $ sBadgeMessage , $ this -> getTranslatorTextDomain ( ) ) ; } return sprintf ( static :: $ badgeFormat , $ this -> createAttributesString ( $ aBadgeAttributes ) , $ sBadgeMessage ) ; }
7649	public function stream_flush ( ) { $ result = fflush ( $ this -> temporaryFileHandle ) ; if ( $ this -> writeMode ) { $ containerExists = $ this -> getStorageClient ( $ this -> fileName ) -> containerExists ( $ this -> getContainerName ( $ this -> fileName ) ) ; if ( ! $ containerExists ) { $ this -> getStorageClient ( $ this -> fileName ) -> createContainer ( $ this -> getContainerName ( $ this -> fileName ) ) ; } try { $ this -> getStorageClient ( $ this -> fileName ) -> putBlob ( $ this -> getContainerName ( $ this -> fileName ) , $ this -> getFileName ( $ this -> fileName ) , $ this -> temporaryFileName ) ; } catch ( BlobException $ ex ) { @ unlink ( $ this -> temporaryFileName ) ; unset ( $ this -> storageClient ) ; throw $ ex ; } } return $ result ; }
3464	public function get ( string $ route , callable $ controller ) : void { $ this -> register ( $ controller , Route :: get ( $ route ) ) ; }
12884	public function getKeyTranslation ( Model $ foreignObject , $ key = null ) { if ( isset ( $ key ) ) { return $ this -> internalGetKeyTranslation ( $ foreignObject , $ key ) ; } foreach ( $ this -> keys as $ keyName => $ keyField ) { if ( ! empty ( $ foreignObject -> { $ keyField } ) ) { $ key = $ this -> generateKey ( $ foreignObject , $ keyName , $ foreignObject -> { $ keyField } ) ; $ result = $ this -> internalGetKeyTranslation ( $ foreignObject , $ key ) ; if ( ! empty ( $ result ) ) { return $ result ; } } } return false ; }
11142	public function getAttributes ( $ props ) { $ attr = '' ; if ( isset ( $ props [ 'primaryKey' ] ) ) { $ attr .= 'NOT NULL AUTO_INCREMENT ' ; } if ( isset ( $ props [ 'defaultValue' ] ) ) { $ attr .= "DEFAULT '" . $ props [ 'defaultValue' ] . "'" ; } return $ attr ; }
11394	public static function setKindOfReportLog ( string $ sKindOfReportLog ) { if ( $ sKindOfReportLog === 'screen' || $ sKindOfReportLog === 'all' ) { self :: $ _sKindOfReportLog = $ sKindOfReportLog ; } else { self :: $ _sKindOfReportLog = 'error_log' ; } }
5759	public function buildPermission ( int $ id , string $ title , ? string $ description , bool $ active , \ DateTimeImmutable $ created , array $ roles ) : Permission { return new Permission ( $ id , $ title , $ description , $ active , $ created , $ roles ) ; }
9726	public function logWrite ( IWriter $ writer , $ path , $ callStartTime ) { $ callEndTime = microtime ( true ) ; $ callTime = $ callEndTime - $ callStartTime ; $ reflection = new ReflectionClass ( $ writer ) ; $ format = $ reflection -> getShortName ( ) ; $ message = "Write {$format} format to <code>{$path}</code> in " . sprintf ( '%.4f' , $ callTime ) . ' seconds' ; $ this -> log ( $ message ) ; }
4868	protected function parseOptionsToDateTime ( $ options ) { $ time = microtime ( true ) ; $ micro = sprintf ( "%06d" , ( $ time - floor ( $ time ) ) * 1000000 ) ; $ this -> now = new \ DateTime ( date ( 'Y-m-d H:i:s.' . $ micro , $ time ) , new \ DateTimeZone ( date_default_timezone_get ( ) ) ) ; $ scheduled = isset ( $ options [ 'scheduled' ] ) ? Utils :: createDateTime ( $ options [ 'scheduled' ] ) : clone ( $ this -> now ) ; if ( isset ( $ options [ 'delay' ] ) ) { $ delay = Utils :: createDateInterval ( $ options [ 'delay' ] ) ; $ scheduled -> add ( $ delay ) ; } return $ scheduled ; }
4384	protected function dumpArray ( $ array ) { $ isNested = $ this -> valDepth > 0 ; $ this -> valDepth ++ ; $ array = parent :: dumpArray ( $ array ) ; $ str = \ trim ( \ print_r ( $ array , true ) ) ; $ str = \ preg_replace ( '#^Array\n\(#' , 'array(' , $ str ) ; $ str = \ preg_replace ( '#^array\s*\(\s+\)#' , 'array()' , $ str ) ; if ( $ isNested ) { $ str = \ str_replace ( "\n" , "\n " , $ str ) ; } return $ str ; }
11936	public function getPrimaryKey ( ) { $ pk = $ this -> meta -> schema -> primaryKey ; if ( is_array ( $ pk ) ) { $ ppk = [ ] ; foreach ( $ pk as $ key ) { if ( ! isset ( $ this -> attributes [ $ key ] ) ) { $ ppk [ ] = null ; } else { $ ppk [ ] = $ this -> attributes [ $ key ] ; } } return implode ( '.' , $ ppk ) ; } if ( ! isset ( $ this -> attributes [ $ pk ] ) ) { return ; } return $ this -> attributes [ $ pk ] ; }
10825	public static function choice ( $ question , array $ choices , $ defaultValue = null ) { $ value = '' ; while ( trim ( $ value ) == '' ) { self :: writeln ( '' ) ; self :: write ( ' ' . $ question , 'info' ) ; if ( $ defaultValue !== null ) { self :: write ( ' [' ) ; self :: write ( ( string ) $ defaultValue , 'comment' ) ; self :: write ( ']' ) ; } self :: writeln ( ':' ) ; if ( count ( $ choices ) > 0 ) { foreach ( $ choices as $ index => $ choice ) { self :: write ( ' [' ) ; self :: write ( ( string ) ( $ index + 1 ) , 'comment' ) ; self :: writeln ( '] ' . $ choice ) ; } } if ( self :: $ testValue === null ) { $ value = readline ( ' > ' ) ; } else { $ value = self :: $ testValue ; } if ( trim ( $ value ) == '' ) { $ value = $ defaultValue ; } if ( ! isset ( $ choices [ intval ( $ value ) - 1 ] ) ) { self :: writeln ( '' ) ; self :: block ( '[ERROR] Value "' . $ value . '" is invalid' , 'error' ) ; $ value = '' ; } elseif ( trim ( $ value ) == '' ) { self :: writeln ( '' ) ; self :: block ( '[ERROR] A value is required' , 'error' ) ; } self :: writeln ( '' ) ; } return trim ( $ value ) ; }
7581	protected function verifyData ( ) { if ( isset ( $ this -> _DATA_TYPE ) || ! empty ( $ this -> _DATA_TYPE ) ) { $ this -> verifyDataType ( ) ; } if ( ! empty ( $ this -> _REQUIRED_DATA ) ) { $ this -> verifyRequiredData ( ) ; } return true ; }
11841	private function extractInput ( ) { $ params = $ this -> request -> getParams ( ) ; $ period = $ params [ self :: REQ_PERIOD ] ?? '' ; if ( empty ( $ period ) ) { $ period = $ this -> hlpPeriod -> getPeriodCurrent ( null , 0 , HPeriod :: TYPE_MONTH ) ; } else { $ period = $ this -> hlpPeriod -> normalizePeriod ( $ period , HPeriod :: TYPE_MONTH ) ; } $ dsBegin = $ this -> hlpPeriod -> getPeriodFirstDate ( $ period ) ; $ treeType = $ params [ self :: REQ_TREE_TYPE ] ?? '' ; if ( $ treeType != OptionTreeType :: VAL_PLAIN ) { $ treeType = OptionTreeType :: VAL_COMPRESS ; } return [ $ dsBegin , $ treeType ] ; }
2496	private function getIndexFieldName ( int $ depth ) : string { if ( $ depth === 0 ) { return self :: $ fieldName ; } return sprintf ( self :: $ relatedContentFieldName , $ depth ) ; }
12769	public function getDb ( ) { if ( is_null ( $ this -> _db ) ) { if ( ! isset ( $ this -> dbConfig [ 'class' ] ) ) { $ this -> dbConfig [ 'class' ] = 'cascade\components\dataInterface\connectors\db\Connection' ; } $ this -> _db = Yii :: createObject ( $ this -> dbConfig ) ; $ this -> _db -> open ( ) ; } if ( empty ( $ this -> _db ) || ! $ this -> _db -> isActive ) { throw new Exception ( "Unable to connect to foreign database." ) ; } return $ this -> _db ; }
3968	protected function createAttributeInstance ( ModelInterface $ model = null ) { if ( null === $ model ) { return null ; } return $ this -> attributeFactory -> createAttribute ( $ model -> getPropertiesAsArray ( ) , $ this -> getMetaModelByModelPid ( $ model ) ) ; }
10247	public function getString ( $ type = 'letter' , $ desired_length = null ) { if ( empty ( $ desired_length ) ) { $ desired_length = $ this -> getInteger ( 1 , 50 ) ; } $ result = '' ; while ( strlen ( $ result ) < $ desired_length ) { if ( $ type == 'letter' ) { $ result .= $ this -> getLetter ( ) ; } elseif ( $ type == 'number' ) { $ result .= $ this -> getInteger ( 1 , 10 ) ; } else { $ result .= $ this -> getUniqueHash ( ) ; } } return substr ( $ result , 0 , $ desired_length ) ; }
9182	public function remember ( $ value , $ memoryDuration = null ) { if ( is_null ( $ memoryDuration ) ) { $ memoryDuration = $ this -> memoryDuration ; } $ key = $ this -> getRememberKey ( ) ; if ( Cache :: has ( $ key ) ) { $ value = Cache :: get ( $ key ) ; } else { $ expiresAt = Carbon :: now ( ) -> addMinutes ( $ memoryDuration ) ; if ( is_callable ( $ value ) ) { $ value = $ value ( ) ; } Cache :: put ( $ key , $ value , $ expiresAt ) ; } return $ value ; }
10799	public function renderPageHistoricAction ( ) { $ idPage = $ this -> params ( ) -> fromRoute ( 'idPage' , $ this -> params ( ) -> fromQuery ( 'idPage' , '' ) ) ; $ melisKey = $ this -> params ( ) -> fromRoute ( 'melisKey' , '' ) ; $ view = new ViewModel ( ) ; $ view -> idPage = $ idPage ; $ view -> melisKey = $ melisKey ; return $ view ; }
1448	protected function dataForRelationship ( $ record , string $ field , array $ document ) : array { $ schema = $ this -> container -> getSchema ( $ record ) ; return [ 'type' => $ schema -> getResourceType ( ) , 'id' => $ schema -> getId ( $ record ) , 'relationships' => [ $ field => [ 'data' => $ document [ 'data' ] , ] , ] , ] ; }
3156	public function getOutcomeVariable ( $ variableIdentifier , $ variableValue ) { if ( ! is_string ( $ variableValue ) && ! is_numeric ( $ variableValue ) ) { $ variableValue = json_encode ( $ variableValue ) ; } $ metaVariable = new \ taoResultServer_models_classes_OutcomeVariable ( ) ; $ metaVariable -> setIdentifier ( $ variableIdentifier ) ; $ metaVariable -> setBaseType ( 'string' ) ; $ metaVariable -> setCardinality ( Cardinality :: getNameByConstant ( Cardinality :: SINGLE ) ) ; $ metaVariable -> setValue ( $ variableValue ) ; return $ metaVariable ; }
7568	protected function parse ( ) { $ p = & $ this -> parser ; $ p -> setPos ( 0 ) ; $ this -> result = array ( ) ; if ( ! $ this -> parse_single ( ) ) { return false ; } while ( count ( $ this -> result ) > 0 ) { switch ( $ p -> token ) { case CSSQueryTokenizer :: TOK_CHILD : $ this -> parser -> next_no_whitespace ( ) ; if ( ! $ this -> parse_result ( false , 1 ) ) { return false ; } break ; case CSSQueryTokenizer :: TOK_SIBLING : $ this -> parser -> next_no_whitespace ( ) ; if ( ! $ this -> parse_result ( true , 1 ) ) { return false ; } break ; case CSSQueryTokenizer :: TOK_PLUS : $ this -> parser -> next_no_whitespace ( ) ; if ( ! $ this -> parse_adjacent ( ) ) { return false ; } break ; case CSSQueryTokenizer :: TOK_ALL : case CSSQueryTokenizer :: TOK_IDENTIFIER : case CSSQueryTokenizer :: TOK_STRING : case CSSQueryTokenizer :: TOK_BRACE_OPEN : case CSSQueryTokenizer :: TOK_BRACKET_OPEN : case CSSQueryTokenizer :: TOK_ID : case CSSQueryTokenizer :: TOK_CLASS : case CSSQueryTokenizer :: TOK_COLON : if ( ! $ this -> parse_result ( ) ) { return false ; } break ; case CSSQueryTokenizer :: TOK_NULL : break 2 ; default : $ this -> error ( 'Invalid search pattern(3): No result modifier found!' ) ; return false ; } } return true ; }
9091	protected function normalizeOptions ( array $ options = [ ] ) { $ options = parent :: normalizeOptions ( $ options ) ; if ( isset ( $ options [ 'subLiClassLevel0' ] ) && $ options [ 'subLiClassLevel0' ] !== null ) { $ options [ 'subLiClassLevel0' ] = ( string ) $ options [ 'subLiClassLevel0' ] ; } else { $ options [ 'subLiClassLevel0' ] = $ this -> getSubLiClassLevel0 ( ) ; } return $ options ; }
12920	public function getTotal ( ) { if ( ! $ this -> isReady ( ) ) { return 0 ; } if ( is_null ( $ this -> _countTotal ) ) { $ this -> _countTotal = 0 ; if ( in_array ( $ this -> settings [ 'direction' ] , [ 'to_local' , 'both' ] ) ) { $ this -> _countTotal += count ( $ this -> foreignDataItems ) ; } if ( in_array ( $ this -> settings [ 'direction' ] , [ 'to_foreign' , 'both' ] ) ) { $ this -> _countTotal += count ( $ this -> localDataItems ) ; } } return $ this -> _countTotal ; }
5170	public static function getNameByType ( $ type ) { static $ map = array ( self :: TYPE_BOOL => 'Bool' , self :: TYPE_INT => 'Int' , self :: TYPE_UINT => 'UInt' , self :: TYPE_QCHAR => 'QChar' , self :: TYPE_QVARIANT_MAP => 'QVariantMap' , self :: TYPE_QVARIANT_LIST => 'QVariantList' , self :: TYPE_QSTRING => 'QString' , self :: TYPE_QSTRING_LIST => 'QStringList' , self :: TYPE_QBYTE_ARRAY => 'QByteArray' , self :: TYPE_QTIME => 'QTime' , self :: TYPE_QDATETIME => 'QDateTime' , self :: TYPE_QUSER_TYPE => 'QUserType' , self :: TYPE_SHORT => 'Short' , self :: TYPE_CHAR => 'Char' , self :: TYPE_USHORT => 'UShort' , self :: TYPE_UCHAR => 'UChar' , ) ; if ( ! isset ( $ map [ $ type ] ) ) { throw new \ InvalidArgumentException ( 'Invalid/unknown variant type (' . $ type . ')' ) ; } return $ map [ $ type ] ; }
177	public static function htmlDecode ( $ data , $ valuesOnly = true ) { $ d = [ ] ; foreach ( $ data as $ key => $ value ) { if ( ! $ valuesOnly && is_string ( $ key ) ) { $ key = htmlspecialchars_decode ( $ key , ENT_QUOTES ) ; } if ( is_string ( $ value ) ) { $ d [ $ key ] = htmlspecialchars_decode ( $ value , ENT_QUOTES ) ; } elseif ( is_array ( $ value ) ) { $ d [ $ key ] = static :: htmlDecode ( $ value ) ; } else { $ d [ $ key ] = $ value ; } } return $ d ; }
7881	public function read ( $ date ) { try { return $ this -> files -> get ( $ this -> path ( $ date ) ) ; } catch ( FileNotFoundException $ e ) { throw new FilesystemException ( 'There was an reading the log.' ) ; } }
5520	protected function checkExpectations ( $ method , $ args , $ timing ) { $ test = $ this -> getCurrentTestCase ( ) ; if ( isset ( $ this -> max_counts [ $ method ] ) ) { if ( ! $ this -> max_counts [ $ method ] -> test ( $ timing + 1 ) ) { $ test -> assert ( $ this -> max_counts [ $ method ] , $ timing + 1 ) ; } } if ( isset ( $ this -> expected_args_at [ $ timing ] [ $ method ] ) ) { $ test -> assert ( $ this -> expected_args_at [ $ timing ] [ $ method ] , $ args , "Mock method [$method] at [$timing] -> %s" ) ; } elseif ( isset ( $ this -> expected_args [ $ method ] ) ) { $ test -> assert ( $ this -> expected_args [ $ method ] , $ args , "Mock method [$method] -> %s" ) ; } }
4359	public static function addSpecial ( $ special ) { $ special = ( array ) $ special ; foreach ( $ special as $ char ) { self :: $ special [ ] = $ char ; } }
11501	protected function loadContainer ( array $ config = [ ] , $ environment = null ) { $ containerConfigs = $ this -> provideContainerConfigs ( $ config , $ environment ) ; array_unshift ( $ containerConfigs , new WeaveConfig ( function ( $ pipelineName ) { return $ this -> provideMiddlewarePipeline ( $ pipelineName ) ; } , function ( $ router ) { return $ this -> provideRouteConfiguration ( $ router ) ; } ) ) ; $ this -> container = ( new ContainerBuilder ) -> newConfiguredInstance ( $ containerConfigs , ContainerBuilder :: AUTO_RESOLVE ) ; return $ this -> container -> get ( 'instantiator' ) ; }
9362	public function argument ( ) { if ( $ this -> original ) { return $ this -> original -> theta ; } return atan2 ( $ this -> float_i , $ this -> float_r ) ; }
4928	public function setListener ( $ event , $ service , $ method = null , $ priority = 0 ) { if ( is_int ( $ method ) ) { $ priority = $ method ; $ method = null ; } $ name = uniqid ( ) ; $ this -> listenerSpecs [ $ name ] = [ 'event' => $ event , 'service' => $ service , 'method' => $ method , 'priority' => $ priority , 'instance' => null , ] ; return $ this ; }
8335	public function removeScope ( $ scope ) { if ( $ this -> isValidScope ( $ scope ) && $ this -> hasScope ( $ scope ) ) { unset ( $ this -> scope [ $ scope ] ) ; } return $ this ; }
3834	public function hookAdditionalFormatters ( $ arrBaseFormatted , $ arrRowData , $ strOutputFormat , $ objSettings ) { $ arrResult = $ arrBaseFormatted ; if ( isset ( $ GLOBALS [ 'METAMODEL_HOOKS' ] [ 'parseValue' ] ) && is_array ( $ GLOBALS [ 'METAMODEL_HOOKS' ] [ 'parseValue' ] ) ) { foreach ( $ GLOBALS [ 'METAMODEL_HOOKS' ] [ 'parseValue' ] as $ callback ) { list ( $ strClass , $ strMethod ) = $ callback ; $ objCallback = ( in_array ( 'getInstance' , get_class_methods ( $ strClass ) ) ) ? call_user_func ( array ( $ strClass , 'getInstance' ) ) : new $ strClass ( ) ; $ arrResult = $ objCallback -> $ strMethod ( $ this , $ arrResult , $ arrRowData , $ strOutputFormat , $ objSettings ) ; } } return $ arrResult ; }
1260	protected function createAccess ( ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; $ accessRequest = $ xml -> appendChild ( $ xml -> createElement ( 'AccessRequest' ) ) ; $ accessRequest -> setAttribute ( 'xml:lang' , 'en-US' ) ; $ accessRequest -> appendChild ( $ xml -> createElement ( 'AccessLicenseNumber' , $ this -> accessKey ) ) ; $ accessRequest -> appendChild ( $ xml -> createElement ( 'UserId' , $ this -> userId ) ) ; $ p = $ accessRequest -> appendChild ( $ xml -> createElement ( 'Password' ) ) ; $ p -> appendChild ( $ xml -> createTextNode ( $ this -> password ) ) ; return $ xml -> saveXML ( ) ; }
4442	public function completed ( int $ offset = 0 , int $ count = 25 ) { return $ this -> client -> jobs ( 'complete' , null , $ offset , $ count ) ; }
10738	public function search ( $ query ) { $ results = new ResultCollection ( ) ; foreach ( $ this -> engines as $ eachEngine ) { if ( ! $ eachEngine -> supports ( $ query ) ) { continue ; } if ( $ more = $ eachEngine -> search ( $ query ) ) { if ( ! is_array ( $ more ) and ! $ more instanceof \ Traversable ) { throw new DomainException ( 'The returned result set is not traversable.' ) ; } foreach ( $ more as $ eachResult ) { $ results -> add ( $ eachResult ) ; } } } return $ results ; }
9893	protected function getInputProps ( ) { $ props = ( array ) $ this -> getElement ( ) -> getAttributes ( ) ; $ props [ 'name' ] = $ this -> get ( '_element' ) -> get ( 'name' ) ; $ props [ '_form' ] = $ this -> getForm ( ) ; $ props [ '_element' ] = $ this -> getElement ( ) ; return $ props ; }
3601	private function collectException ( $ httpRequest , $ httpResponse , $ exception ) { if ( $ this -> profiler ) { $ collector = new ExceptionDataCollector ( ) ; $ collector -> collect ( $ httpRequest , $ httpResponse , $ exception ) ; $ this -> profiler -> add ( $ collector ) ; } }
1657	public function get ( $ name ) { foreach ( $ this -> arguments as $ argument ) { if ( $ argument [ 'name' ] == $ name ) { if ( isset ( $ this -> mapArgumentName [ $ name ] ) ) { return $ this -> { $ this -> mapArgumentName [ $ name ] } ( $ argument ) ; } else { return $ argument ; } } } }
6863	protected function registerManager ( ) { $ this -> app -> singleton ( 'notifyme' , function ( $ app ) { $ config = $ app [ 'config' ] ; $ factory = $ app [ 'notifyme.factory' ] ; return new NotifyMeManager ( $ config , $ factory ) ; } ) ; $ this -> app -> alias ( 'notifyme' , NotifyMeManager :: class ) ; $ this -> app -> alias ( 'notifyme' , ManagerInterface :: class ) ; }
6489	private function addHeaderValue ( HttpHeaders $ headers , string $ name , $ value , bool $ append ) : void { $ decodedValue = trim ( ( string ) ( isset ( self :: $ headersToUrlDecode [ $ name ] ) ? urldecode ( $ value ) : $ value ) ) ; if ( isset ( self :: $ specialCaseHeaders [ $ name ] ) ) { $ headers -> add ( $ name , $ decodedValue , $ append ) ; } elseif ( strpos ( $ name , 'HTTP_' ) === 0 ) { $ normalizedName = substr ( $ name , 5 ) ; $ headers -> add ( $ normalizedName , $ decodedValue , $ append ) ; } }
5258	public static function map ( $ query = [ ] , callable $ callback = null , $ limit = - 1 ) { if ( $ query instanceof QueryBuilder ) { $ query = $ query -> build ( ) ; } $ query [ 'from' ] = Arr :: get ( $ query , 'from' , 0 ) ; $ query [ 'size' ] = Arr :: get ( $ query , 'size' , 50 ) ; $ i = 0 ; $ models = static :: search ( $ query ) ; $ total = $ models -> getTotal ( ) ; while ( $ models ) { foreach ( $ models as $ model ) { if ( $ callback ) { $ callback ( $ model ) ; } $ i ++ ; } $ query [ 'from' ] += $ query [ 'size' ] ; if ( $ i >= $ total || ( $ limit > 0 && $ i >= $ limit ) ) { break ; } $ models = static :: search ( $ query ) ; } return $ total ; }
5260	public function setOptions ( $ mode = null , $ logicalOperator = null , array $ linkedFilters = [ ] ) { $ this -> mode = is_null ( $ mode ) ? Filter :: MODE_INCLUDE : $ mode ; $ this -> logicalOperator = is_null ( $ logicalOperator ) ? Filter :: MERGE_OR : $ logicalOperator ; $ this -> linkedFilters = $ linkedFilters ; return $ this ; }
4452	public function stats ( ? int $ date = null ) : array { $ date = $ date ? : time ( ) ; return json_decode ( $ this -> client -> stats ( $ this -> name , $ date ) , true ) ; }
7990	public function getPcaServices ( $ pp ) { if ( ! $ pp ) throw new BadMethodCallException ( 'Missing parameter $pp (passport).' ) ; try { $ r = $ this -> get ( 'cloud/' . $ pp . '/pca' ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new CloudException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
4730	public static function transcode ( $ source , $ fromEncoding , $ toEncoding ) { if ( \ is_string ( $ source ) ) { switch ( ICONV_IMPL ) { case 'glibc' : return @ iconv ( $ fromEncoding , $ toEncoding . '//TRANSLIT,IGNORE' , $ source ) ; case 'libiconv' : default : return iconv ( $ fromEncoding , $ toEncoding . '//IGNORE//TRANSLIT' , $ source ) ; } } }
4482	public function setBacklog ( int $ backlog ) : void { if ( $ this -> client -> call ( 'recur.update' , $ this -> jid , 'backlog' , $ backlog ) ) { $ this -> backlog = $ backlog ; } }
2024	public static function findByAliases ( $ arrAliases , array $ arrOptions = array ( ) ) { if ( empty ( $ arrAliases ) || ! \ is_array ( $ arrAliases ) ) { return null ; } $ arrAliases = array_filter ( array_map ( function ( $ v ) { return preg_match ( '/^[\w\/.-]+$/u' , $ v ) ? $ v : null ; } , $ arrAliases ) ) ; if ( empty ( $ arrAliases ) ) { return null ; } $ t = static :: $ strTable ; $ arrColumns = array ( "$t.alias IN('" . implode ( "','" , array_filter ( $ arrAliases ) ) . "')" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = Database :: getInstance ( ) -> findInSet ( "$t.alias" , $ arrAliases ) ; } return static :: findBy ( $ arrColumns , null , $ arrOptions ) ; }
9259	public function addNamedRoute ( $ name , $ httpMethod , $ routeData , $ handler ) { $ handler = array ( 'name' => $ name , 'handler' => $ handler , ) ; $ this -> addRoute ( $ httpMethod , $ routeData , $ handler ) ; }
6549	public function add ( $ data ) { $ columnNum = 0 ; $ rowNum = $ this -> iterator -> current ( ) -> getRowIndex ( ) ; foreach ( ( array ) $ data as $ value ) { $ this -> sheet -> setCellValueByColumnAndRow ( $ columnNum ++ , $ rowNum , $ value ) ; } $ this -> iterator -> next ( ) ; }
1952	public static function findBySourceParentAndEmail ( $ strSource , $ intParent , $ strEmail , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; return static :: findOneBy ( array ( "$t.source=? AND $t.parent=? AND $t.email=?" ) , array ( $ strSource , $ intParent , $ strEmail ) , $ arrOptions ) ; }
7041	protected function setState ( PaymentSubjectInterface $ subject , $ state ) { if ( $ state !== $ subject -> getPaymentState ( ) ) { $ subject -> setPaymentState ( $ state ) ; return true ; } return false ; }
7088	public function error ( Callable $ action = null ) { if ( $ action ) $ this -> errorAction = $ action ; return $ this -> errorAction ; }
11143	public function run ( ) { $ list = $ this -> getClassList ( ) ; $ directCollection = new DirectCollection ( ) ; foreach ( $ list as $ class ) { $ cl = $ this -> processClass ( $ class ) ; if ( $ cl !== false ) { $ directCollection -> add ( $ cl ) ; } } return $ directCollection ; }
902	public function isAnonymousClass ( $ index ) { $ tokens = $ this -> tokens ; $ token = $ tokens [ $ index ] ; if ( ! $ token -> isClassy ( ) ) { throw new \ LogicException ( sprintf ( 'No classy token at given index %d.' , $ index ) ) ; } if ( ! $ token -> isGivenKind ( T_CLASS ) ) { return false ; } return $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ index ) ] -> isGivenKind ( T_NEW ) ; }
8644	public function getReportRequestCount ( $ request ) { if ( ! $ request instanceof MarketplaceWebService_Model_GetReportRequestCountRequest ) { $ request = new MarketplaceWebService_Model_GetReportRequestCountRequest ( $ request ) ; } $ httpResponse = $ this -> invoke ( $ this -> convertGetReportRequestCount ( $ request ) ) ; $ response = MarketplaceWebService_Model_GetReportRequestCountResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
7313	public function setDate ( $ year , $ month , $ day ) { $ status = IAU :: Cal2jd ( ( int ) $ year , ( int ) $ month , ( int ) $ day , $ djm0 , $ djm ) ; $ this -> checkDate ( $ status ) ; $ this -> jd = $ djm0 + $ djm ; return $ this ; }
9787	public function parseFilteredValue ( ) { list ( $ type , $ filters ) = $ this -> pop ( 'FILTERED_VALUE' ) ; $ value = array_shift ( $ filters ) ; $ opening = '' ; $ closing = '' ; foreach ( $ filters as $ filter ) { if ( function_exists ( $ filter ) ) { $ opening .= $ filter . '(' ; $ closing .= ')' ; } else { $ opening .= '\Katar\Katar::getInstance()->filter(\'' . $ filter . '\', ' ; $ closing .= ')' ; } } return '$output .= ' . $ opening . $ value . $ closing . ";\n" ; }
9663	public static function registerWriter ( $ writerType , $ writerClass ) { if ( ! is_a ( $ writerClass , Writer \ IWriter :: class , true ) ) { throw new Writer \ Exception ( 'Registered writers must implement ' . Writer \ IWriter :: class ) ; } self :: $ writers [ $ writerType ] = $ writerClass ; }
10909	public function inject ( string ... $ methods ) : Binding { if ( $ this -> definition -> injects === null ) { $ this -> definition -> injects = \ array_fill_keys ( $ methods , true ) ; } else { foreach ( $ methods as $ f ) { $ this -> definition -> injects [ $ f ] = true ; } } return $ this ; }
5917	public function updateSetting ( $ key , $ value ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'value' => $ value ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> put ( 'v1/accounts/settings/' . $ key . '' , $ parameters ) ; return $ result ; }
9357	public function withoutHeader ( $ name ) { $ instance = clone $ this ; if ( $ this -> hasHeader ( $ name ) ) { $ static = clone $ this ; unset ( $ static -> headers [ $ name ] ) ; $ instance = $ static ; } return $ instance ; }
6307	public function success ( $ message , $ title = null , $ options = [ ] ) { return $ this -> add ( 'success' , $ message , $ title , $ options ) ; }
12649	public function build ( ) { $ assetManager = new AssetManager ( ) ; $ filterManager = new FilterManager ( ) ; foreach ( $ this -> filters as $ filterName => $ filter ) { $ filterManager -> set ( $ filterName , $ filter ) ; } $ assetsFactory = new AssetFactory ( $ this -> configurationHandler -> webDir ( ) ) ; $ assetsFactory -> setAssetManager ( $ assetManager ) ; $ assetsFactory -> setFilterManager ( $ filterManager ) ; return $ assetsFactory ; }
2812	public function getObservers ( ) { if ( $ this -> observers === null ) { $ this -> observers = array ( ) ; foreach ( $ this -> getTimers ( ) as $ timerName => $ timer ) { if ( strpos ( $ timerName , 'OBSERVER' ) === 0 ) { $ this -> observers [ ] = array ( 'name' => $ timerName , 'count' => $ timer [ 'count' ] , 'sum' => round ( $ timer [ 'sum' ] * 1000 , 2 ) , 'mem_diff' => $ timer [ 'realmem' ] / pow ( 1024 , 2 ) , ) ; } } } return $ this -> observers ; }
4536	public function setTenantIdIn ( array $ tenantIdIn ) { $ this -> tenantIdIn = $ tenantIdIn ; $ this -> _tenantIdIn = null !== $ tenantIdIn ; return $ this ; }
9744	public function setState ( $ state ) { if ( ! $ state ) { return $ this ; } if ( ! ( $ state instanceof State ) ) { $ state = new State ( $ state ) ; } if ( $ state -> isEmpty ( ) ) { $ this -> invalidArguments ( '10002' ) ; } return $ this -> setParameter ( 'state' , $ state ) ; }
654	protected function internalExecute ( $ rawSql ) { $ attempt = 0 ; while ( true ) { try { if ( ++ $ attempt === 1 && $ this -> _isolationLevel !== false && $ this -> db -> getTransaction ( ) === null ) { $ this -> db -> transaction ( function ( ) use ( $ rawSql ) { $ this -> internalExecute ( $ rawSql ) ; } , $ this -> _isolationLevel ) ; } else { $ this -> pdoStatement -> execute ( ) ; } break ; } catch ( \ Exception $ e ) { $ rawSql = $ rawSql ? : $ this -> getRawSql ( ) ; $ e = $ this -> db -> getSchema ( ) -> convertException ( $ e , $ rawSql ) ; if ( $ this -> _retryHandler === null || ! call_user_func ( $ this -> _retryHandler , $ e , $ attempt ) ) { throw $ e ; } } } }
1971	public static function findMultipleByUuids ( $ arrUuids , array $ arrOptions = array ( ) ) { if ( empty ( $ arrUuids ) || ! \ is_array ( $ arrUuids ) ) { return null ; } $ t = static :: $ strTable ; foreach ( $ arrUuids as $ k => $ v ) { if ( Validator :: isStringUuid ( $ v ) ) { $ v = StringUtil :: uuidToBin ( $ v ) ; } $ arrUuids [ $ k ] = "UNHEX('" . bin2hex ( $ v ) . "')" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.uuid!=" . implode ( ", $t.uuid!=" , $ arrUuids ) ; } return static :: findBy ( array ( "$t.uuid IN(" . implode ( "," , $ arrUuids ) . ")" ) , null , $ arrOptions ) ; }
4358	protected function processSubstitutions ( $ args , & $ hasSubs ) { $ subRegex = '/%' . '(?:' . '[coO]|' . '[+-]?' . '(?:[ 0]|\'.{1})?' . '-?' . '\d*' . '(?:\.\d+)?' . '[difs]' . ')' . '/' ; if ( ! \ is_string ( $ args [ 0 ] ) ) { return $ args ; } $ index = 0 ; $ indexes = array ( 'c' => array ( ) , ) ; $ hasSubs = false ; $ args [ 0 ] = \ preg_replace_callback ( $ subRegex , function ( $ matches ) use ( & $ args , & $ hasSubs , & $ index , & $ indexes ) { $ hasSubs = true ; $ index ++ ; $ replacement = $ matches [ 0 ] ; $ type = \ substr ( $ matches [ 0 ] , - 1 ) ; if ( \ strpos ( 'difs' , $ type ) !== false ) { $ format = $ matches [ 0 ] ; $ sub = $ args [ $ index ] ; if ( $ type == 'i' ) { $ format = \ substr_replace ( $ format , 'd' , - 1 , 1 ) ; } elseif ( $ type === 's' ) { $ sub = $ this -> substitutionAsString ( $ sub ) ; } $ replacement = \ sprintf ( $ format , $ sub ) ; } elseif ( $ type === 'c' ) { $ asHtml = \ get_called_class ( ) == __NAMESPACE__ . '\\Html' ; if ( ! $ asHtml ) { return '' ; } $ replacement = '' ; if ( $ indexes [ 'c' ] ) { $ replacement = '</span>' ; } $ replacement .= '<span' . $ this -> debug -> utilities -> buildAttribString ( array ( 'style' => $ args [ $ index ] , ) ) . '>' ; $ indexes [ 'c' ] [ ] = $ index ; } elseif ( \ strpos ( 'oO' , $ type ) !== false ) { $ replacement = $ this -> dump ( $ args [ $ index ] ) ; } return $ replacement ; } , $ args [ 0 ] ) ; if ( $ indexes [ 'c' ] ) { $ args [ 0 ] .= '</span>' ; } if ( $ hasSubs ) { $ args = array ( $ args [ 0 ] ) ; } return $ args ; }
3288	private function readDataFromPendingClient ( $ socket , int $ length , PendingSocketClient $ state ) { $ data = \ fread ( $ socket , $ length ) ; if ( $ data === false || $ data === '' ) { return null ; } $ data = $ state -> receivedDataBuffer . $ data ; if ( \ strlen ( $ data ) < $ length ) { $ state -> receivedDataBuffer = $ data ; return null ; } $ state -> receivedDataBuffer = '' ; Loop :: cancel ( $ state -> readWatcher ) ; return $ data ; }
453	public function delete ( $ table , $ condition , & $ params ) { $ sql = 'DELETE FROM ' . $ this -> db -> quoteTableName ( $ table ) ; $ where = $ this -> buildWhere ( $ condition , $ params ) ; return $ where === '' ? $ sql : $ sql . ' ' . $ where ; }
3028	public function setConsumer ( $ key , $ secret ) { $ this -> consumer = new \ Eher \ OAuth \ Consumer ( $ key , $ secret ) ; }
4600	public function postLoad ( LifecycleEventArgs $ args ) { $ entity = $ args -> getEntity ( ) ; if ( ! $ entity instanceof Translatable ) { return ; } $ this -> translationService -> translate ( $ entity ) ; }
8781	public function save ( $ content = null , $ time = 30 ) { $ fileName = md5 ( $ this -> prefix . http ( ) -> server ( 'REQUEST_URI' ) ) . $ this -> extension ; $ this -> file = cache_path ( 'html' . DIRECTORY_SEPARATOR . $ fileName ) ; $ this -> start ( $ time ) ; return $ this -> finish ( $ content ) ; }
10338	function toXML ( ) { $ xml = new SimpleXMLElement ( "<?xml version=\"1.0\"?><property></property>" ) ; $ xml -> addChild ( "key" , $ this -> key ) ; $ xml -> addChild ( "value" , $ this -> value ) ; return $ xml ; }
1166	protected function parseParameters ( $ parameters ) { $ newParams = [ 'validate_all' => false ] ; if ( isset ( $ parameters [ 0 ] ) ) { $ newParams [ 'validate_all' ] = ( $ parameters [ 0 ] === 'true' ) ? true : false ; } return $ newParams ; }
1690	protected function writeStyleSheet ( $ row ) { if ( $ row [ 'id' ] == '' || $ row [ 'name' ] == '' ) { return ; } $ row [ 'name' ] = basename ( $ row [ 'name' ] ) ; if ( file_exists ( $ this -> strRootDir . '/assets/css/' . $ row [ 'name' ] . '.css' ) && ! $ this -> Files -> is_writeable ( 'assets/css/' . $ row [ 'name' ] . '.css' ) ) { Message :: addError ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'notWriteable' ] , 'assets/css/' . $ row [ 'name' ] . '.css' ) ) ; return ; } $ vars = array ( ) ; $ objTheme = $ this -> Database -> prepare ( "SELECT vars FROM tl_theme WHERE id=?" ) -> limit ( 1 ) -> execute ( $ row [ 'pid' ] ) ; if ( $ objTheme -> vars != '' ) { if ( \ is_array ( ( $ tmp = StringUtil :: deserialize ( $ objTheme -> vars ) ) ) ) { foreach ( $ tmp as $ v ) { $ vars [ $ v [ 'key' ] ] = $ v [ 'value' ] ; } } } if ( $ row [ 'vars' ] != '' ) { if ( \ is_array ( $ tmp = StringUtil :: deserialize ( $ row [ 'vars' ] ) ) ) { foreach ( $ tmp as $ v ) { $ vars [ $ v [ 'key' ] ] = $ v [ 'value' ] ; } } } uksort ( $ vars , 'length_sort_desc' ) ; $ objFile = new File ( 'assets/css/' . $ row [ 'name' ] . '.css' ) ; $ objFile -> write ( '/* ' . $ row [ 'name' ] . ".css */\n" ) ; $ objDefinitions = $ this -> Database -> prepare ( "SELECT * FROM tl_style WHERE pid=? AND invisible!='1' ORDER BY sorting" ) -> execute ( $ row [ 'id' ] ) ; while ( $ objDefinitions -> next ( ) ) { $ objFile -> append ( $ this -> compileDefinition ( $ objDefinitions -> row ( ) , true , $ vars , $ row ) , '' ) ; } $ objFile -> close ( ) ; }
1018	private function arrayMergeDeep ( array $ array1 , array $ array2 ) : array { $ merged = $ array1 ; foreach ( $ array2 as $ key => & $ value ) { if ( is_numeric ( $ key ) ) { if ( ! in_array ( $ value , $ merged , true ) ) { $ merged [ ] = $ value ; } } elseif ( is_array ( $ value ) && isset ( $ merged [ $ key ] ) && is_array ( $ merged [ $ key ] ) ) { $ merged [ $ key ] = $ this -> arrayMergeDeep ( $ merged [ $ key ] , $ value ) ; } else { $ merged [ $ key ] = $ value ; } } return $ merged ; }
161	public function orHaving ( $ condition , $ params = [ ] ) { if ( $ this -> having === null ) { $ this -> having = $ condition ; } else { $ this -> having = [ 'or' , $ this -> having , $ condition ] ; } $ this -> addParams ( $ params ) ; return $ this ; }
2330	public function next ( ) { if ( ! isset ( $ this -> arrModels [ $ this -> intIndex + 1 ] ) ) { return false ; } ++ $ this -> intIndex ; return $ this ; }
8598	public function createSubscription ( $ request ) { if ( ! ( $ request instanceof MWSSubscriptionsService_Model_CreateSubscriptionInput ) ) { require_once ( dirname ( __FILE__ ) . '/Model/CreateSubscriptionInput.php' ) ; $ request = new MWSSubscriptionsService_Model_CreateSubscriptionInput ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'CreateSubscription' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/CreateSubscriptionResponse.php' ) ; $ response = MWSSubscriptionsService_Model_CreateSubscriptionResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
3009	public function fetch ( $ template , array $ data = [ ] ) { if ( isset ( $ data [ 'template' ] ) ) { throw new \ InvalidArgumentException ( "Duplicate template key found" ) ; } if ( ! is_file ( $ this -> templatePath . $ template ) ) { throw new \ RuntimeException ( "View cannot render `$template` because the template does not exist" ) ; } $ data = array_merge ( $ this -> attributes , $ data ) ; try { ob_start ( ) ; $ this -> protectedIncludeScope ( $ this -> templatePath . $ template , $ data ) ; $ output = ob_get_clean ( ) ; if ( $ this -> layout !== null ) { ob_start ( ) ; $ data [ 'content' ] = $ output ; $ this -> protectedIncludeScope ( $ this -> layout , $ data ) ; $ output = ob_get_clean ( ) ; } } catch ( \ Throwable $ e ) { ob_end_clean ( ) ; throw $ e ; } catch ( \ Exception $ e ) { ob_end_clean ( ) ; throw $ e ; } return $ output ; }
442	public function hasEventHandlers ( $ name ) { $ this -> ensureBehaviors ( ) ; foreach ( $ this -> _eventWildcards as $ wildcard => $ handlers ) { if ( ! empty ( $ handlers ) && StringHelper :: matchWildcard ( $ wildcard , $ name ) ) { return true ; } } return ! empty ( $ this -> _events [ $ name ] ) || Event :: hasHandlers ( $ this , $ name ) ; }
8354	private function buildEnum ( string $ enumName , array $ enumDefinition ) { $ mapping = Mapping :: get ( $ this -> mapping ) ; $ definition = $ this -> getDefinition ( ) ; $ database = GlobalDatabase :: get ( $ mapping [ 'config' ] [ 'database' ] ) ; $ enumRealName = null ; if ( isset ( $ enumDefinition [ 'name' ] ) === true ) { $ enumRealName = $ enumDefinition [ 'name' ] ; } else { $ enumRealName = Helper :: codifyName ( $ this -> mapping ) . '_' . Helper :: codifyName ( $ enumName ) ; } if ( isset ( $ enumDefinition [ 'values' ] ) === false ) { throw new InvalidSchemaDefinition ( 'enum "' . $ enumName . '" has no value' ) ; } $ values = array ( ) ; foreach ( $ enumDefinition [ 'values' ] as $ valueName => $ valueAlias ) { $ valueRealName = null ; if ( is_string ( $ valueName ) === true ) { $ valueRealName = $ valueName ; } else { $ valueRealName = Helper :: codifyName ( $ enumName ) . '_' . Helper :: codifyName ( $ valueAlias ) ; } $ values [ ] = $ valueRealName ; } $ statement = Mutation \ AddEnum :: statement ( $ database , $ enumRealName , $ values ) ; if ( $ statement -> execute ( ) == false ) { throw new DatabaseError ( 'db/build : ' . print_r ( $ statement -> errorInfo ( ) , true ) ) ; } echo $ enumName . ' - Done' . PHP_EOL ; }
8842	private function stringToArray ( string $ string ) : array { $ lines = preg_split ( '/\R/' , $ string ) ; if ( 1 === count ( $ lines ) && '' === $ lines [ 0 ] ) { $ lines = [ ] ; } return $ lines ; }
5902	public function retrieveGroup ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/accounts/groups/' . $ id . '' , $ parameters , $ cachePolicy ) ; $ result = new Group ( $ result ) ; return $ result ; }
11820	public function cell_default ( $ item , $ column ) { $ ret = $ this -> val ( $ item , $ column ) ; return is_null ( $ ret ) ? '' : $ ret ; }
1922	public static function fromFile ( File $ file ) { $ extension = strtolower ( $ file -> extension ) ; $ function = null ; if ( $ extension === 'jpg' ) { $ extension = 'jpeg' ; } if ( \ in_array ( $ extension , array ( 'gif' , 'jpeg' , 'png' ) ) ) { $ function = 'imagecreatefrom' . $ extension ; } if ( $ function === null || ! \ is_callable ( $ function ) ) { throw new \ InvalidArgumentException ( 'Image type "' . $ file -> extension . '" cannot be processed by GD' ) ; } $ image = $ function ( System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) . '/' . $ file -> path ) ; if ( $ image === false ) { throw new \ RuntimeException ( 'Image "' . $ file -> path . '" failed to be processed by GD' ) ; } return new static ( $ image ) ; }
6211	protected function cleanBacktrace ( $ backtrace ) { foreach ( $ backtrace as & $ item ) { if ( isset ( $ item [ 'file' ] ) ) { $ item [ 'file' ] = $ this -> cleanFilePath ( $ item [ 'file' ] ) ; } unset ( $ item [ 'args' ] ) ; } return $ backtrace ; }
10990	public function hasExtension ( string $ extension ) : bool { $ test = $ this -> getExtension ( ) ; return ( strcasecmp ( $ extension , $ test ) === 0 ) ; }
3943	public static function prepareLanguageAwareWidget ( EnvironmentInterface $ environment , PropertyInterface $ property , IMetaModel $ metaModel , $ languageLabel , $ valueLabel , $ isTextArea , $ arrValues ) { if ( ! $ metaModel -> isTranslated ( ) ) { $ extra = $ property -> getExtra ( ) ; $ extra [ 'tl_class' ] .= empty ( $ extra [ 'tl_class' ] ) ? 'w50' : ' w50' ; $ property -> setWidgetType ( 'text' ) -> setExtra ( $ extra ) ; return ; } $ fallback = $ metaModel -> getFallbackLanguage ( ) ; $ languages = self :: buildLanguageArray ( $ metaModel , $ environment -> getTranslator ( ) ) ; $ neededKeys = array_keys ( $ languages ) ; if ( array_diff_key ( array_keys ( $ arrValues ) , $ neededKeys ) ) { foreach ( $ neededKeys as $ langCode ) { $ arrValues [ $ langCode ] = '' ; } } $ rowClasses = array ( ) ; foreach ( array_keys ( $ arrValues ) as $ langCode ) { $ rowClasses [ ] = ( $ langCode == $ fallback ) ? 'fallback_language' : 'normal_language' ; } $ extra = $ property -> getExtra ( ) ; $ extra [ 'minCount' ] = $ extra [ 'maxCount' ] = count ( $ languages ) ; $ extra [ 'disableSorting' ] = true ; $ extra [ 'tl_class' ] = 'clr' ; $ extra [ 'columnFields' ] = array ( 'langcode' => array ( 'label' => $ languageLabel , 'exclude' => true , 'inputType' => 'justtextoption' , 'options' => $ languages , 'eval' => array ( 'rowClasses' => $ rowClasses , 'valign' => 'center' , 'style' => 'min-width:75px;display:block;' ) ) , 'value' => array ( 'label' => $ valueLabel , 'exclude' => true , 'inputType' => $ isTextArea ? 'textarea' : 'text' , 'eval' => array ( 'rowClasses' => $ rowClasses , 'style' => 'width:400px;' , 'rows' => 3 ) ) , ) ; $ property -> setWidgetType ( 'multiColumnWizard' ) -> setExtra ( $ extra ) ; }
313	public function setRuntimePath ( $ path ) { $ this -> _runtimePath = Yii :: getAlias ( $ path ) ; Yii :: setAlias ( '@runtime' , $ this -> _runtimePath ) ; }
6682	private function setSecurityHeaders ( ) { $ headers = Yii :: $ app -> response -> headers ; $ headers -> add ( 'X-Frame-Options' , 'DENY' ) ; $ headers -> add ( 'X-XSS-Protection' , '1' ) ; }
8058	public function setWorkerPoolSize ( $ size ) { if ( $ this -> created ) { throw new WorkerPoolException ( 'Cannot set the Worker Pool Size for a created pool.' ) ; } $ size = ( int ) $ size ; if ( $ size <= 0 ) { throw new \ InvalidArgumentException ( '"' . $ size . '" is not an integer greater than 0.' ) ; } $ this -> workerPoolSize = $ size ; return $ this ; }
3219	function getDelta ( $ cursor = null , $ pathPrefix = null ) { Checker :: argStringNonEmptyOrNull ( "cursor" , $ cursor ) ; Path :: checkArgOrNull ( "pathPrefix" , $ pathPrefix ) ; $ response = $ this -> doPost ( $ this -> apiHost , "1/delta" , array ( "cursor" => $ cursor , "path_prefix" => $ pathPrefix ) ) ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; return RequestUtil :: parseResponseJson ( $ response -> body ) ; }
6188	public function render ( $ data , $ type = null ) { if ( empty ( $ type ) or $ type === 'html' ) { return Response :: Create ( $ this -> renderInclude ( $ data ) ) ; } elseif ( $ type === 'jsonp' ) { return $ this -> renderJSONP ( $ data ) ; } else { return $ this -> renderJSON ( $ data ) ; } }
8028	public function registerFreeProcess ( ProcessDetails $ processDetails ) { $ pid = $ processDetails -> getPid ( ) ; if ( $ this -> hasProcess ( $ pid ) === FALSE ) { throw new \ InvalidArgumentException ( sprintf ( 'Could not register free process. Process (%d) not in list.' , $ processDetails -> getPid ( ) ) , 1400761296 ) ; } $ this -> freeProcessIds [ $ pid ] = $ pid ; return $ this ; }
467	public function buildExistsCondition ( $ operator , $ operands , & $ params ) { array_unshift ( $ operands , $ operator ) ; return $ this -> buildCondition ( $ operands , $ params ) ; }
4995	public function getActiveFormNext ( ) { $ key = null ; $ actualKey = $ this -> getActiveFormActual ( ) ; if ( isset ( $ actualKey ) ) { $ forms = array_keys ( $ this -> forms ) ; $ formsFlip = array_flip ( $ forms ) ; $ index = $ formsFlip [ $ actualKey ] ; if ( $ index < count ( $ forms ) - 1 ) { $ key = $ forms [ $ index + 1 ] ; } } return $ key ; }
3568	public function replicate ( ) { return function ( $ next , $ copy , $ args ) { $ metaAttributes = $ args -> get ( 'original' ) -> getMetaAttributes ( ) -> replicate ( $ args -> get ( 'except' ) ) ; $ copy -> setRelation ( 'metaAttributes' , $ metaAttributes ) ; return $ next ( $ copy , $ args ) ; } ; }
443	public function off ( $ name , $ handler = null ) { $ this -> ensureBehaviors ( ) ; if ( empty ( $ this -> _events [ $ name ] ) && empty ( $ this -> _eventWildcards [ $ name ] ) ) { return false ; } if ( $ handler === null ) { unset ( $ this -> _events [ $ name ] , $ this -> _eventWildcards [ $ name ] ) ; return true ; } $ removed = false ; if ( isset ( $ this -> _events [ $ name ] ) ) { foreach ( $ this -> _events [ $ name ] as $ i => $ event ) { if ( $ event [ 0 ] === $ handler ) { unset ( $ this -> _events [ $ name ] [ $ i ] ) ; $ removed = true ; } } if ( $ removed ) { $ this -> _events [ $ name ] = array_values ( $ this -> _events [ $ name ] ) ; return $ removed ; } } if ( isset ( $ this -> _eventWildcards [ $ name ] ) ) { foreach ( $ this -> _eventWildcards [ $ name ] as $ i => $ event ) { if ( $ event [ 0 ] === $ handler ) { unset ( $ this -> _eventWildcards [ $ name ] [ $ i ] ) ; $ removed = true ; } } if ( $ removed ) { $ this -> _eventWildcards [ $ name ] = array_values ( $ this -> _eventWildcards [ $ name ] ) ; if ( empty ( $ this -> _eventWildcards [ $ name ] ) ) { unset ( $ this -> _eventWildcards [ $ name ] ) ; } } } return $ removed ; }
865	private function skipNonArrayElements ( $ index , Tokens $ tokens ) { if ( $ tokens [ $ index ] -> equals ( '}' ) ) { return $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_CURLY_BRACE , $ index ) ; } if ( $ tokens [ $ index ] -> equals ( ')' ) ) { $ startIndex = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ index ) ; $ startIndex = $ tokens -> getPrevMeaningfulToken ( $ startIndex ) ; if ( ! $ tokens [ $ startIndex ] -> isGivenKind ( [ T_ARRAY , CT :: T_ARRAY_SQUARE_BRACE_OPEN ] ) ) { return $ startIndex ; } } return $ index ; }
8697	protected function validateMandatoryAttribs ( ) { foreach ( static :: $ mandatoryFields as $ field ) { if ( ! array_key_exists ( $ field , $ this -> attributes ) ) { throw new \ SVGCreator \ SVGException ( "The field " . $ field . " does not exist for " . static :: TYPE . "." , 1 ) ; } } }
8437	public static function countRows ( array $ conditions , bool $ critical = false ) { $ entity = new static ( ) ; $ selectQuery = new Select ( $ entity -> getDatabaseName ( ) , $ critical ) ; $ selectQuery -> select ( [ 'count' => 'COUNT(*)' ] ) ; $ selectQuery -> from ( $ entity -> getTableName ( ) ) ; if ( count ( $ conditions ) > 0 ) { $ where = array ( ) ; foreach ( $ conditions as $ key => $ value ) { $ realName = constant ( get_called_class ( ) . '::FIELD_' . strtoupper ( Helper :: codifyName ( $ key ) ) ) ; $ where [ $ realName ] = ':where' . ucfirst ( $ key ) ; $ selectQuery -> bind ( 'where' . ucfirst ( $ key ) , $ value ) ; } $ selectQuery -> where ( $ where ) ; } if ( $ selectQuery -> execute ( ) === false ) { return false ; } $ data = $ selectQuery -> fetch ( ) ; if ( $ data === false ) { return false ; } return $ data [ 'count' ] ; }
11233	public function run ( $ argument , Message $ message , ApiClient $ apiClient ) { $ this -> setApiClient ( $ apiClient ) ; $ this -> execute ( $ argument , $ message ) ; }
8149	public function compileSource ( $ source , $ name = null ) { if ( ! $ source instanceof Twig_Source ) { @ trigger_error ( sprintf ( 'Passing a string as the $source argument of %s() is deprecated since version 1.27. Pass a Twig_Source instance instead.' , __METHOD__ ) , E_USER_DEPRECATED ) ; $ source = new Twig_Source ( $ source , $ name ) ; } try { return $ this -> compile ( $ this -> parse ( $ this -> tokenize ( $ source ) ) ) ; } catch ( Twig_Error $ e ) { $ e -> setSourceContext ( $ source ) ; throw $ e ; } catch ( Exception $ e ) { throw new Twig_Error_Syntax ( sprintf ( 'An exception has been thrown during the compilation of a template ("%s").' , $ e -> getMessage ( ) ) , - 1 , $ source , $ e ) ; } }
6861	public function doDefaultValueConversionByType ( $ value , $ type , array $ record ) { switch ( $ type ) { case static :: TYPE_DATETIME : return date ( static :: FORMAT_DATETIME , is_numeric ( $ value ) ? $ value : strtotime ( $ value ) ) ; case static :: TYPE_DATE : return date ( static :: FORMAT_DATE , is_numeric ( $ value ) ? $ value : strtotime ( $ value ) ) ; case static :: TYPE_TIME : return date ( static :: FORMAT_TIME , is_numeric ( $ value ) ? $ value : strtotime ( $ value ) ) ; case static :: TYPE_MULTILINE : return '<pre class="multiline-text">' . $ value . '</pre>' ; case static :: TYPE_JSON : case static :: TYPE_JSONB : if ( ! is_array ( $ value ) && $ value !== null ) { if ( is_string ( $ value ) || is_numeric ( $ value ) || is_bool ( $ value ) ) { $ value = json_decode ( $ value , true ) ; if ( $ value === null && strtolower ( $ value ) !== 'null' ) { $ value = 'Failed to decode JSON: ' . print_r ( $ value , true ) ; } } else { $ value = 'Invalid value for JSON: ' . print_r ( $ value , true ) ; } } return '<pre class="json-text">' . htmlentities ( stripslashes ( json_encode ( $ value , JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE ) ) ) . '</pre>' ; break ; } return $ value ; }
3569	public function __issetHook ( ) { return function ( $ next , $ isset , $ args ) { $ key = $ args -> get ( 'key' ) ; if ( ! $ isset ) { $ isset = ( bool ) $ this -> hasMeta ( $ key ) ; } return $ next ( $ isset , $ args ) ; } ; }
5169	public static function getTypeByValue ( $ value ) { if ( is_int ( $ value ) ) { return self :: TYPE_INT ; } elseif ( is_string ( $ value ) ) { return self :: TYPE_QSTRING ; } elseif ( is_bool ( $ value ) ) { return self :: TYPE_BOOL ; } elseif ( self :: isList ( $ value ) ) { return self :: TYPE_QVARIANT_LIST ; } elseif ( self :: isMap ( $ value ) ) { return self :: TYPE_QVARIANT_MAP ; } elseif ( $ value instanceof \ DateTime ) { return self :: TYPE_QDATETIME ; } else { throw new \ InvalidArgumentException ( 'Can not guess variant type for type "' . gettype ( $ value ) . '"' ) ; } }
1724	public static function generateRandomSecret ( Event $ event ) : void { $ extra = $ event -> getComposer ( ) -> getPackage ( ) -> getExtra ( ) ; if ( ! isset ( $ extra [ 'incenteev-parameters' ] ) || ! self :: canGenerateSecret ( $ extra [ 'incenteev-parameters' ] ) ) { return ; } if ( ! \ function_exists ( 'random_bytes' ) ) { self :: loadRandomCompat ( $ event ) ; } putenv ( static :: RANDOM_SECRET_NAME . '=' . bin2hex ( random_bytes ( 32 ) ) ) ; }
6583	public static function create ( $ b , $ q , $ n = 1 ) { if ( $ n == 1 ) return new static ( $ b , $ q ) ; static :: ensureValid ( $ n , "Amount of elements must be an integer number bigger than zero." ) ; return new static ( $ b * ( 1 - $ q ) / ( 1 - pow ( $ q , $ n ) ) , $ q ) ; }
11599	public function run ( ) : void { if ( ! $ this -> isAppRootSet ( ) ) { throw new Exception ( "The application root wasn't defined." ) ; } if ( ! $ this -> isConfigFileSet ( ) ) { throw new Exception ( "The main config file wasn't defined." ) ; } $ configPath = $ this -> getAppRoot ( ) . $ this -> getConfigFile ( ) ; if ( ! is_readable ( $ configPath ) ) { throw new Exception ( "It's unable to load " . $ configPath . 'as main config file.' ) ; } $ config = require_once $ configPath ; if ( ! is_array ( $ config ) ) { throw new Exception ( 'The main config must be an array.' ) ; } $ this -> configSet = $ config ; }
8067	public function run ( $ input ) { while ( $ this -> workerPoolSize > 0 ) { try { $ processDetailsOfFreeWorker = $ this -> getNextFreeWorker ( ) ; $ processDetailsOfFreeWorker -> getSocket ( ) -> send ( array ( 'cmd' => 'run' , 'data' => $ input ) ) ; return $ processDetailsOfFreeWorker -> getPid ( ) ; } catch ( \ Exception $ e ) { pcntl_signal_dispatch ( ) ; } } throw new WorkerPoolException ( 'Unable to run the task.' ) ; }
3820	private function perform ( $ table , Request $ request , $ metaModel , $ parentId ) { $ activate = ( bool ) $ request -> request -> get ( 'activate' ) ; $ query = $ this -> connection -> createQueryBuilder ( ) -> insert ( $ table ) ; foreach ( $ metaModel -> getAttributes ( ) as $ attribute ) { if ( $ this -> knowsAttribute ( $ attribute ) || ! ( $ this -> accepts ( $ attribute ) && $ this -> isAttributeSubmitted ( $ attribute -> get ( 'id' ) , $ request ) ) ) { continue ; } $ data = [ ] ; foreach ( $ this -> createEmptyDataFor ( $ attribute , $ parentId , $ activate , $ this -> startSort ) as $ key => $ value ) { $ data [ $ key ] = ':' . $ key ; $ query -> setParameter ( $ key , $ value ) ; } $ query -> values ( $ data ) -> execute ( ) ; $ this -> startSort += 128 ; } $ this -> purger -> purge ( ) ; }
5627	public function asString ( ) { $ path = $ this -> path ; $ scheme = $ identity = $ host = $ port = $ encoded = $ fragment = '' ; if ( $ this -> username && $ this -> password ) { $ identity = $ this -> username . ':' . $ this -> password . '@' ; } if ( $ this -> getHost ( ) ) { $ scheme = $ this -> getScheme ( ) ? $ this -> getScheme ( ) : 'http' ; $ scheme .= '://' ; $ host = $ this -> getHost ( ) ; } elseif ( $ this -> getScheme ( ) === 'file' ) { $ scheme = 'file://' ; } if ( $ this -> getPort ( ) && $ this -> getPort ( ) != 80 ) { $ port = ':' . $ this -> getPort ( ) ; } if ( substr ( $ this -> path , 0 , 1 ) == '/' ) { $ path = $ this -> normalisePath ( $ this -> path ) ; } $ encoded = $ this -> getEncodedRequest ( ) ; $ fragment = $ this -> getFragment ( ) ? '#' . $ this -> getFragment ( ) : '' ; $ coords = $ this -> getX ( ) === false ? '' : '?' . $ this -> getX ( ) . ',' . $ this -> getY ( ) ; return "$scheme$identity$host$port$path$encoded$fragment$coords" ; }
954	protected function returnTo ( ) { $ return_to = Session :: get ( 'return_to' ) ; if ( $ return_to ) { Session :: forget ( 'return_to' ) ; return Redirect :: to ( $ return_to ) ; } return Redirect :: route ( 'home' ) ; }
1664	protected function getCountries ( ) { if ( sizeof ( $ this -> countries ) == 0 ) { $ this -> countries = json_decode ( file_get_contents ( __DIR__ . '/Models/countries.json' ) , true ) ; } return $ this -> countries ; }
6981	static public function factory ( $ type = 'html' , array $ params = null ) { if ( ! isset ( $ type ) || ! strcasecmp ( $ type , 'html' ) ) return ( new Html \ Renderer ( $ params ) ) ; throw new \ Exception ( "Unknown Skriv rendering type '$type'." ) ; }
10120	private function writeMarginTop ( ) { $ record = 0x0028 ; $ length = 0x0008 ; $ margin = $ this -> phpSheet -> getPageMargins ( ) -> getTop ( ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'd' , $ margin ) ; if ( self :: getByteOrder ( ) ) { $ data = strrev ( $ data ) ; } $ this -> append ( $ header . $ data ) ; }
4400	protected function saveTransationRef ( \ Aimeos \ MShop \ Order \ Item \ Base \ Iface $ baseItem , $ ref ) { $ type = \ Aimeos \ MShop \ Order \ Item \ Base \ Service \ Base :: TYPE_PAYMENT ; $ serviceItem = $ this -> getBasketService ( $ baseItem , $ type , $ this -> getServiceItem ( ) -> getCode ( ) ) ; $ attr = array ( 'TRANSACTIONID' => $ ref ) ; $ this -> setAttributes ( $ serviceItem , $ attr , 'payment/omnipay' ) ; $ this -> saveOrderBase ( $ baseItem ) ; }
5224	protected function getProviderCreator ( $ provider ) { if ( is_string ( $ provider ) ) { return function ( $ injector , $ name , $ key ) use ( $ provider ) { $ providerInstance = $ injector -> getInstance ( $ provider ) ; if ( ! ( $ providerInstance instanceof InjectionProvider ) ) { throw new BindingException ( 'Configured provider class ' . $ provider . ' for ' . $ name . '[' . $ key . '] is not an instance of stubbles\ioc\InjectionProvider.' ) ; } return $ providerInstance -> get ( ) ; } ; } elseif ( $ provider instanceof InjectionProvider ) { return function ( ) use ( $ provider ) { return $ provider -> get ( ) ; } ; } throw new \ InvalidArgumentException ( 'Given provider must either be a instance of' . ' stubbles\ioc\InjectionProvider or a class name representing' . ' such a provider instance.' ) ; }
11256	private function resolve ( string $ class ) : AbstractSeed { $ instance = $ this -> autowire ( $ class ) ; $ instance -> setDatabase ( $ this -> database ) ; $ instance -> setSeeder ( $ this ) ; if ( ! is_null ( $ this -> container ) ) { $ instance -> setContainer ( $ this -> container ) ; } return $ instance ; }
12476	public function setCurrentTheme ( $ identifier ) { $ theme = $ this -> getTheme ( $ identifier ) ; $ this -> container -> get ( 'session' ) -> set ( '_admin_theme' , $ theme ) ; }
5133	public static function create ( string $ string = '' ) : \ One \ Uri { if ( empty ( $ string ) ) { $ string = '/' ; } return self :: createFromString ( $ string ) ; }
10610	public function checkEmailAction ( ) { $ email = $ this -> get ( 'session' ) -> get ( 'fos_user_send_confirmation_email/email' ) ; $ this -> get ( 'session' ) -> remove ( 'fos_user_send_confirmation_email/email' ) ; $ user = $ this -> get ( 'fos_user.user_manager' ) -> findUserByEmail ( $ email ) ; if ( null === $ user ) { throw new NotFoundHttpException ( sprintf ( 'The user with email "%s" does not exist' , $ email ) ) ; } return $ this -> render ( '@MikyUser/Frontend/Registration/checkEmail.html.twig' , array ( 'user' => $ user , ) ) ; }
3613	public function setTargetTemperature ( $ temperature , $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ temperature = $ this -> temperatureInCelsius ( $ temperature , $ serial_number ) ; $ data = json_encode ( array ( 'target_change_pending' => TRUE , 'target_temperature' => $ temperature ) ) ; return $ this -> doPOST ( "/v2/put/shared." . $ serial_number , $ data ) ; }
6710	protected function parseHeader ( array $ headers = [ ] ) { $ processedHeaders = array ( ) ; foreach ( $ headers as $ key => $ value ) { if ( substr ( $ key , 0 , 5 ) == 'HTTP_' ) { $ name = str_replace ( ' ' , '-' , ucwords ( strtolower ( str_replace ( '_' , ' ' , substr ( $ key , 5 ) ) ) ) ) ; $ processedHeaders [ $ name ] = $ value ; } elseif ( $ key == 'CONTENT_TYPE' ) { $ processedHeaders [ 'Content-Type' ] = $ value ; } elseif ( $ key == 'CONTENT_LENGTH' ) { $ processedHeaders [ 'Content-Length' ] = $ value ; } } return $ processedHeaders ; }
10202	public function setHorizontal ( $ pValue ) { if ( $ pValue == '' ) { $ pValue = self :: HORIZONTAL_GENERAL ; } if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'horizontal' => $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> horizontal = $ pValue ; } return $ this ; }
1908	private function getArgumentName ( Request $ request , ArgumentMetadata $ argument ) : ? string { if ( $ request -> attributes -> has ( $ argument -> getName ( ) ) ) { return $ argument -> getName ( ) ; } $ className = lcfirst ( $ this -> stripNamespace ( $ argument -> getType ( ) ) ) ; if ( $ request -> attributes -> has ( $ className ) ) { return $ className ; } return null ; }
5815	public function onBeforeWrite ( ) { parent :: onBeforeWrite ( ) ; $ types = $ this -> Types ? explode ( ',' , $ this -> Types ) : array ( ) ; if ( is_string ( $ this -> TagTypes ) ) { $ types = array_merge ( $ types , array_keys ( unserialize ( $ this -> TagTypes ) ) ) ; } if ( ! empty ( $ types ) ) { sort ( $ types ) ; $ formatted = array ( ) ; $ existing = $ this -> service -> getFusionTagTypes ( ) ; foreach ( $ types as $ type ) { if ( isset ( $ existing [ $ type ] ) ) { $ formatted [ $ type ] = $ type ; } } $ this -> TagTypes = ! empty ( $ formatted ) ? serialize ( $ formatted ) : null ; $ this -> Types = implode ( ',' , $ formatted ) ; } }
3089	protected function alterTimeoutCallValue ( array $ options ) { $ timeoutValue = null ; if ( $ this -> isInitialCall === true ) { if ( $ this -> hasOption ( self :: OPTION_INITIAL_CALL_TIMEOUT ) ) { $ timeoutValue = $ this -> getOption ( self :: OPTION_INITIAL_CALL_TIMEOUT ) ; } } else { if ( $ this -> hasOption ( self :: OPTION_NEXT_ITEM_CALL_TIMEOUT ) ) { $ timeoutValue = $ this -> getOption ( self :: OPTION_NEXT_ITEM_CALL_TIMEOUT ) ; } } if ( ! is_null ( $ timeoutValue ) ) { $ options [ self :: OPTION_ENGINE_CLIENT ] [ 'options' ] [ 'http_client_options' ] [ 'timeout' ] = $ timeoutValue ; } return $ options ; }
6721	private function handleTokenResponse ( $ response ) { $ params = ( $ response instanceof OAuthToken ) ? $ response -> getParams ( ) : $ response ; $ status = ArrayHelper :: getValue ( $ params , 'status' ) ; if ( ! is_null ( $ status ) && $ status == 'success' ) { $ token = ArrayHelper :: getValue ( $ params , 'data' ) ; if ( is_null ( $ token ) ) { throw new Oauth2ClientException ( self :: CODE_NOT_SET ) ; } return $ token ; } else { $ message = ArrayHelper :: getValue ( $ params , 'message' , self :: DEFAULT_ERROR ) ; throw new Oauth2ClientException ( $ message ) ; } }
10924	private function renderLine ( ) { $ output = [ ] ; $ output [ ] = $ this -> charCross ; if ( count ( $ this -> columns ) > 0 ) { for ( $ columnNumber = 0 ; $ columnNumber < count ( $ this -> columns ) ; $ columnNumber ++ ) { $ output [ ] = $ this -> renderCell ( $ columnNumber , $ this -> charHorizontal , $ this -> charHorizontal ) ; $ output [ ] = $ this -> charCross ; } } return implode ( '' , $ output ) ; }
5304	public function getPath ( $ scale = 1 , $ roundPrecision = null , $ flip = 'none' , $ onlyFilled = true , $ xOffset = 0 , $ yOffset = 0 ) { $ path = $ this -> getPathPart ( $ this -> xmlDocument , $ onlyFilled ) ; if ( $ scale !== 1 || $ roundPrecision !== null || $ flip !== 'none' || $ xOffset !== 0 || $ yOffset !== 0 ) { $ path = $ this -> transformPath ( $ path , $ scale , $ roundPrecision , $ flip , $ xOffset / $ scale , $ yOffset / $ scale ) ; } return trim ( $ path ) ; }
6645	public static function formatPhoneNumberToInternationalFormat ( $ countryCode , $ number , $ numberLength ) { $ actualNumber = substr ( $ number , - ( $ numberLength ) , $ numberLength ) ; if ( ! $ actualNumber ) { return $ number ; } return '+' . $ countryCode . $ actualNumber ; }
6559	public function get_number_type ( $ phone_number = '' , $ region = NULL ) { $ inputParams = array ( 'phone_number' => $ phone_number , 'region' => $ region ) ; $ this -> debug -> info ( __FUNCTION__ , 'Input Params: ' , $ inputParams ) ; if ( empty ( $ phone_number ) ) { $ this -> debug -> warning ( __FUNCTION__ , 'Phone Number input is Empty!' ) ; return NULL ; } $ phone_number = trim ( $ phone_number ) ; try { $ phoneNumberUtil = PhoneNumberUtil :: getInstance ( ) ; $ use_region = NULL !== $ region ? strtoupper ( $ region ) : self :: DEFAULT_REGION ; $ phoneNumberObject = $ phoneNumberUtil -> parse ( trim ( $ phone_number ) , $ use_region ) ; $ result = $ phoneNumberUtil -> getNumberType ( $ phoneNumberObject ) ; $ this -> debug -> debug ( __FUNCTION__ , 'Use REGION: ' . $ use_region ) ; $ this -> debug -> info ( __FUNCTION__ , 'Final Result: ' . $ result ) ; return $ result ; } catch ( \ Exception $ e ) { $ message = 'Error File: ' . $ e -> getFile ( ) . ' - Line: ' . $ e -> getLine ( ) . ' - Code: ' . $ e -> getCode ( ) . ' - Message: ' . $ e -> getMessage ( ) ; $ this -> debug -> error ( __FUNCTION__ , $ message ) ; return NULL ; } }
8398	public static function getSchema ( string $ mapping ) : Schema { $ data = Mapping :: get ( $ mapping ) ; $ class = rtrim ( ucfirst ( $ data [ 'config' ] [ 'provider' ] ) , '\\' ) . '\\Schema' ; return new $ class ( $ mapping ) ; }
7027	public function autoLogin ( EntityInterface $ user ) : ? Response { $ controller = $ this -> getController ( ) ; $ request = $ controller -> request ; $ token = $ request -> getQuery ( 't' ) ; if ( empty ( $ token ) ) { return null ; } $ this -> Auth -> logout ( ) ; $ tokenData = $ user -> validateLoginToken ( $ token , $ user -> getKey ( ) , $ user -> getSalt ( ) ) ; if ( ! is_array ( $ tokenData ) ) { return null ; } if ( ! empty ( $ tokenData [ 'addRememberMeCookie' ] ) && $ tokenData [ 'addRememberMeCookie' ] ) { $ this -> addRememberMeCookie ( ( string ) $ user -> id ) ; } $ userData = $ user -> toArray ( ) ; $ userData [ 'user' ] = $ user ; $ this -> Auth -> setUser ( $ userData ) ; if ( ! empty ( $ tokenData [ 'url' ] ) ) { return $ controller -> redirect ( $ tokenData [ 'url' ] ) ; } return $ controller -> redirect ( $ this -> getConfig ( 'defaultRedirect' ) ) ; }
8972	protected function paginate ( array $ rates , $ criteria ) { if ( ! array_key_exists ( 'offset' , $ criteria ) && ! array_key_exists ( 'limit' , $ criteria ) ) { return $ rates ; } $ range = array ( ) ; $ offset = array_key_exists ( 'offset' , $ criteria ) ? $ criteria [ 'offset' ] : 0 ; $ limit = min ( ( array_key_exists ( 'limit' , $ criteria ) ? $ criteria [ 'limit' ] : count ( $ rates ) ) + $ offset , count ( $ rates ) ) ; for ( $ i = $ offset ; $ i < $ limit ; $ i ++ ) { $ range [ ] = $ rates [ $ i ] ; } return $ range ; }
1022	private static function buildExecutionContext ( Schema $ schema , DocumentNode $ documentNode , $ rootValue , $ contextValue , $ rawVariableValues , $ operationName = null , ? callable $ fieldResolver = null , ? PromiseAdapter $ promiseAdapter = null ) { $ errors = [ ] ; $ fragments = [ ] ; $ operation = null ; $ hasMultipleAssumedOperations = false ; foreach ( $ documentNode -> definitions as $ definition ) { switch ( $ definition -> kind ) { case NodeKind :: OPERATION_DEFINITION : if ( ! $ operationName && $ operation ) { $ hasMultipleAssumedOperations = true ; } if ( ! $ operationName || ( isset ( $ definition -> name ) && $ definition -> name -> value === $ operationName ) ) { $ operation = $ definition ; } break ; case NodeKind :: FRAGMENT_DEFINITION : $ fragments [ $ definition -> name -> value ] = $ definition ; break ; } } if ( $ operation === null ) { if ( $ operationName ) { $ errors [ ] = new Error ( sprintf ( 'Unknown operation named "%s".' , $ operationName ) ) ; } else { $ errors [ ] = new Error ( 'Must provide an operation.' ) ; } } elseif ( $ hasMultipleAssumedOperations ) { $ errors [ ] = new Error ( 'Must provide operation name if query contains multiple operations.' ) ; } $ variableValues = null ; if ( $ operation !== null ) { [ $ coercionErrors , $ coercedVariableValues ] = Values :: getVariableValues ( $ schema , $ operation -> variableDefinitions ? : [ ] , $ rawVariableValues ? : [ ] ) ; if ( empty ( $ coercionErrors ) ) { $ variableValues = $ coercedVariableValues ; } else { $ errors = array_merge ( $ errors , $ coercionErrors ) ; } } if ( ! empty ( $ errors ) ) { return $ errors ; } Utils :: invariant ( $ operation , 'Has operation if no errors.' ) ; Utils :: invariant ( $ variableValues !== null , 'Has variables if no errors.' ) ; return new ExecutionContext ( $ schema , $ fragments , $ rootValue , $ contextValue , $ operation , $ variableValues , $ errors , $ fieldResolver , $ promiseAdapter ) ; }
7422	protected function renderAlertBlock ( ) { $ session = \ Yii :: $ app -> session ; $ flashes = $ session -> getAllFlashes ( ) ; $ alertContainerOptions = [ 'style' => 'max-width:400px' ] ; if ( count ( $ flashes ) === 0 ) { Html :: addCssStyle ( $ alertContainerOptions , 'display:none;' ) ; } $ out = Html :: beginTag ( 'div' , $ alertContainerOptions ) ; foreach ( $ flashes as $ type => $ message ) { if ( is_array ( $ message ) ) { $ message = implode ( '<br>' , $ message ) ; } $ alertWidgetOptions = [ ] ; $ alertWidgetOptions [ 'body' ] = $ message ; $ alertWidgetOptions [ 'options' ] = [ 'class' => [ 'alert' , 'alert-success' ] , 'style' => 'padding-left:10px;padding-right:10px;' ] ; $ out .= "\n" . Alert :: widget ( $ alertWidgetOptions ) ; $ session -> removeFlash ( $ type ) ; } $ out .= "\n</div>" ; return $ this -> alertBlockAddon . $ out ; }
12113	public function getUnmappedForeignKeys ( ) { $ mappedForeign = ArrayHelper :: getColumn ( $ this -> _map , 'foreignKey' ) ; $ u = array_diff ( array_keys ( $ this -> foreignModel -> meta -> schema -> columns ) , $ mappedForeign ) ; unset ( $ u [ $ this -> foreignPrimaryKeyName ] ) ; return $ u ; }
9600	public function length ( ) { $ sumOfSquares = 0 ; foreach ( $ this -> components ( ) as $ component ) { $ sumOfSquares += pow ( $ component , 2 ) ; } return sqrt ( $ sumOfSquares ) ; }
12572	public function previewImage ( $ message , $ to , $ by = self :: PREVIEW_BY_OPENID ) { return $ this -> preview ( self :: MSG_TYPE_IMAGE , $ message , $ to , $ by ) ; }
9298	public function getHome ( ) { $ query = $ this -> createQueryBuilder ( 'c' ) -> join ( 'c.forums' , 'f' ) -> join ( 'f.lastMessage' , 'm' ) -> join ( 'm.user' , 'u' ) -> addSelect ( 'f' ) -> addSelect ( 'm' ) -> addSelect ( 'u' ) -> where ( 'f.status = :status' ) -> setParameter ( 'status' , Forum :: STATUS_PUBLIC ) ; $ query -> orderBy ( 'c.position' , 'ASC' ) -> addOrderBy ( 'f.position' , 'ASC' ) ; return $ query -> getQuery ( ) ; }
10741	protected function buildRecord ( ) { $ res = [ ] ; foreach ( $ this -> clause_records as $ tbl ) { $ res [ ] = $ this -> quote ( $ tbl ) . '.*' ; } if ( ! empty ( $ res ) ) { return [ join ( ', ' , $ res ) ] ; } else { return [ ] ; } }
11119	protected function runUp ( array $ file , int $ batch ) : void { $ this -> notify -> note ( "<comment>Migrating:</comment> {$file['basename']}" ) ; $ this -> runMigration ( $ file ) ; $ this -> repository -> log ( $ this -> getMigrationName ( $ file ) , $ batch ) ; $ this -> notify -> note ( "<info>Migrated:</info> {$file['basename']}" ) ; }
12973	public function setMappings ( $ mappingName , array $ mappingConfig = null ) { if ( is_array ( $ mappingName ) === false ) { $ mappingName = array ( $ mappingName => $ mappingConfig ) ; } \ Arr :: set ( $ this -> config [ 'mappings' ] , $ mappingName ) ; return $ this ; }
9730	public function setMaxParcelDimensions ( $ value = null ) { if ( is_array ( $ value ) ) { $ value = new ParcelDimensions ( $ value ) ; } elseif ( ! ( $ value instanceof ParcelDimensions ) ) { $ value = null ; } return $ this -> setParameter ( 'max_parcel_dimensions' , $ value ) ; }
2484	protected function getAllSearchTargets ( ) { if ( $ this -> endpointResolver instanceof SingleEndpointResolver && ! $ this -> endpointResolver -> hasMultipleEndpoints ( ) ) { return '' ; } $ shards = [ ] ; $ searchTargets = $ this -> endpointResolver -> getEndpoints ( ) ; if ( ! empty ( $ searchTargets ) ) { foreach ( $ searchTargets as $ endpointName ) { $ shards [ ] = $ this -> endpointRegistry -> getEndpoint ( $ endpointName ) -> getIdentifier ( ) ; } } return implode ( ',' , $ shards ) ; }
1787	public function getActiveLayoutSections ( Contao \ DataContainer $ dc ) { if ( $ dc -> activeRecord -> pid ) { $ arrSections = array ( ) ; $ objPage = Contao \ PageModel :: findWithDetails ( $ dc -> activeRecord -> pid ) ; if ( $ objPage -> layout ) { $ objLayout = Contao \ LayoutModel :: findByPk ( $ objPage -> layout ) ; if ( $ objLayout === null ) { return array ( ) ; } $ arrModules = Contao \ StringUtil :: deserialize ( $ objLayout -> modules ) ; if ( empty ( $ arrModules ) || ! \ is_array ( $ arrModules ) ) { return array ( ) ; } foreach ( $ arrModules as $ arrModule ) { if ( $ arrModule [ 'mod' ] == 0 && $ arrModule [ 'enable' ] ) { $ arrSections [ ] = $ arrModule [ 'col' ] ; } } } } else { $ arrSections = array ( 'header' , 'left' , 'right' , 'main' , 'footer' ) ; $ objLayout = $ this -> Database -> query ( "SELECT sections FROM tl_layout WHERE sections!=''" ) ; while ( $ objLayout -> next ( ) ) { $ arrCustom = Contao \ StringUtil :: deserialize ( $ objLayout -> sections ) ; if ( ! empty ( $ arrCustom ) && \ is_array ( $ arrCustom ) ) { foreach ( $ arrCustom as $ v ) { if ( ! empty ( $ v [ 'id' ] ) ) { $ arrSections [ ] = $ v [ 'id' ] ; } } } } } return Contao \ Backend :: convertLayoutSectionIdsToAssociativeArray ( $ arrSections ) ; }
12134	public function index ( QuestionRequest $ request ) { $ view = $ this -> response -> theme -> listView ( ) ; if ( $ this -> response -> typeIs ( 'json' ) ) { $ function = camel_case ( 'get-' . $ view ) ; return $ this -> repository -> setPresenter ( \ Litecms \ Forum \ Repositories \ Presenter \ QuestionPresenter :: class ) -> $ function ( ) ; } $ user_id = user_id ( ) ; $ questions = $ this -> repository -> questions ( $ user_id ) ; return $ this -> response -> title ( trans ( 'forum::question.names' ) ) -> view ( 'forum::question.index' , true ) -> data ( compact ( 'questions' , 'view' ) ) -> output ( ) ; }
6739	public function set_options ( ) { $ slug = Module :: CustomRatingGrifus ( ) -> getOption ( 'slug' ) ; $ options = $ this -> model -> get_options ( ) ; foreach ( $ options as $ option => $ value ) { Module :: CustomRatingGrifus ( ) -> setOption ( $ option , $ value ) ; } }
10150	private function readHeader ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; if ( ! $ this -> readDataOnly ) { if ( $ recordData ) { if ( $ this -> version == self :: XLS_BIFF8 ) { $ string = self :: readUnicodeStringLong ( $ recordData ) ; } else { $ string = $ this -> readByteStringShort ( $ recordData ) ; } $ this -> phpSheet -> getHeaderFooter ( ) -> setOddHeader ( $ string [ 'value' ] ) ; $ this -> phpSheet -> getHeaderFooter ( ) -> setEvenHeader ( $ string [ 'value' ] ) ; } } }
3894	private function getFilteredAttributeNames ( $ metaModelId , $ allowedTypes = array ( ) ) { $ attributeNames = array ( ) ; if ( $ metaModel = $ this -> factory -> getMetaModel ( $ this -> factory -> translateIdToMetaModelName ( $ metaModelId ) ) ) { foreach ( $ metaModel -> getAttributes ( ) as $ attribute ) { if ( empty ( $ allowedTypes ) || in_array ( $ attribute -> get ( 'type' ) , $ allowedTypes ) ) { $ attributeNames [ $ attribute -> getColName ( ) ] = sprintf ( '%s [%s]' , $ attribute -> getName ( ) , $ attribute -> getColName ( ) ) ; } } } return $ attributeNames ; }
3333	public function createGroup ( $ files ) { $ data = array ( 'pub_key' => $ this -> api -> getPublicKey ( ) , ) ; foreach ( $ files as $ i => $ file ) { $ data [ "files[$i]" ] = $ file -> getUrl ( ) ; } $ ch = $ this -> __initRequest ( 'group' ) ; $ this -> __setRequestType ( $ ch ) ; $ this -> __setData ( $ ch , $ data ) ; $ this -> __setHeaders ( $ ch ) ; $ resp = $ this -> __runRequest ( $ ch ) ; $ group = $ this -> api -> getGroup ( $ resp -> id ) ; return $ group ; }
6033	public function getMetadata ( $ section = null , $ key = null ) { if ( null === $ section ) { return $ this -> metadata ; } foreach ( $ this -> metadata as $ md ) { if ( $ section != $ md -> getSection ( ) ) { continue ; } if ( null === $ key ) { return $ md ; } foreach ( $ md -> getData ( ) as $ k => $ data ) { if ( $ key == $ k ) { return $ data ; } } throw new NotFoundException ( 'No metadata with section "' . $ section . '" and key "' . $ key . '" exists.' ) ; } throw new NotFoundException ( 'No metadata with section "' . $ section . '" exists.' ) ; }
12545	public function listen ( $ event , callable $ callback , $ priority = 100 ) { $ this -> event -> on ( $ event , $ callback , $ priority ) ; }
3376	private function createInstance ( $ file , $ w = null , $ h = null ) { $ container = $ this -> container ; $ webDir = $ container -> getParameter ( 'gregwar_image.web_dir' ) ; $ handlerClass = $ this -> handlerClass ; $ image = new $ handlerClass ( $ file , $ w , $ h , $ this -> throwException , $ this -> fallbackImage ) ; $ image -> setCacheDir ( $ this -> cacheDirectory ) ; $ image -> setCacheDirMode ( $ this -> cacheDirMode ) ; $ image -> setActualCacheDir ( $ webDir . '/' . $ this -> cacheDirectory ) ; if ( $ container -> has ( 'templating.helper.assets' ) ) { $ image -> setFileCallback ( function ( $ file ) use ( $ container ) { return $ container -> get ( 'templating.helper.assets' ) -> getUrl ( $ file ) ; } ) ; } else { $ image -> setFileCallback ( function ( $ file ) use ( $ container ) { return $ this -> assetsPackages -> getUrl ( $ file ) ; } ) ; } return $ image ; }
1088	private static function getFieldDefinition ( Schema $ schema , Type $ parentType , FieldNode $ fieldNode ) { $ name = $ fieldNode -> name -> value ; $ schemaMeta = Introspection :: schemaMetaFieldDef ( ) ; if ( $ name === $ schemaMeta -> name && $ schema -> getQueryType ( ) === $ parentType ) { return $ schemaMeta ; } $ typeMeta = Introspection :: typeMetaFieldDef ( ) ; if ( $ name === $ typeMeta -> name && $ schema -> getQueryType ( ) === $ parentType ) { return $ typeMeta ; } $ typeNameMeta = Introspection :: typeNameMetaFieldDef ( ) ; if ( $ name === $ typeNameMeta -> name && $ parentType instanceof CompositeType ) { return $ typeNameMeta ; } if ( $ parentType instanceof ObjectType || $ parentType instanceof InterfaceType ) { $ fields = $ parentType -> getFields ( ) ; return $ fields [ $ name ] ?? null ; } return null ; }
5860	public function getAllFileTypes ( ) { $ fileTypes = [ ] ; foreach ( $ this -> rulesets as $ ruleset ) { if ( is_array ( $ ruleset [ 'file_types' ] ) ) { $ fileTypes = array_merge ( $ fileTypes , $ ruleset [ 'file_types' ] ) ; } } $ fileTypes = array_unique ( $ fileTypes ) ; return $ fileTypes ; }
9740	public function getPrintArea ( $ index = 0 ) { if ( $ index == 0 ) { return $ this -> printArea ; } $ printAreas = explode ( ',' , $ this -> printArea ) ; if ( isset ( $ printAreas [ $ index - 1 ] ) ) { return $ printAreas [ $ index - 1 ] ; } throw new PhpSpreadsheetException ( 'Requested Print Area does not exist' ) ; }
631	public function batchInsert ( $ table , $ columns , $ rows ) { $ table = $ this -> db -> quoteSql ( $ table ) ; $ columns = array_map ( function ( $ column ) { return $ this -> db -> quoteSql ( $ column ) ; } , $ columns ) ; $ params = [ ] ; $ sql = $ this -> db -> getQueryBuilder ( ) -> batchInsert ( $ table , $ columns , $ rows , $ params ) ; $ this -> setRawSql ( $ sql ) ; $ this -> bindValues ( $ params ) ; return $ this ; }
2211	public function fetchEach ( $ strKey ) { $ this -> reset ( ) ; $ arrReturn = array ( ) ; while ( ( $ arrRow = $ this -> fetchAssoc ( ) ) !== false ) { if ( $ strKey != 'id' && isset ( $ arrRow [ 'id' ] ) ) { $ arrReturn [ $ arrRow [ 'id' ] ] = $ arrRow [ $ strKey ] ; } else { $ arrReturn [ ] = $ arrRow [ $ strKey ] ; } } return $ arrReturn ; }
12279	public function moveUsers ( array $ openIds , $ groupId ) { $ params = [ 'openid_list' => $ openIds , 'to_groupid' => $ groupId , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_MEMBER_BATCH_UPDATE , $ params ] ) ; }
11327	public function getLocations ( ) { if ( is_null ( $ this -> _locations ) ) { $ this -> _locations = $ this -> determineLocations ( ) ; } return $ this -> _locations ; }
3831	protected function prepareFrontendFilterWidget ( $ arrWidget , $ arrFilterUrl , $ arrJumpTo , FrontendFilterOptions $ objFrontendFilterOptions ) { $ strClass = $ GLOBALS [ 'TL_FFL' ] [ $ arrWidget [ 'inputType' ] ] ; if ( ! $ strClass ) { return array ( ) ; } $ arrWidget [ 'value' ] = isset ( $ arrFilterUrl [ $ arrWidget [ 'eval' ] [ 'urlparam' ] ] ) ? $ arrFilterUrl [ $ arrWidget [ 'eval' ] [ 'urlparam' ] ] : null ; $ event = new GetAttributesFromDcaEvent ( $ arrWidget , $ arrWidget [ 'eval' ] [ 'urlparam' ] ) ; $ this -> eventDispatcher -> dispatch ( ContaoEvents :: WIDGET_GET_ATTRIBUTES_FROM_DCA , $ event ) ; if ( $ objFrontendFilterOptions -> isAutoSubmit ( ) && TL_MODE == 'FE' ) { $ GLOBALS [ 'TL_JAVASCRIPT' ] [ 'metamodels' ] = 'bundles/metamodelscore/js/metamodels.js' ; } $ objWidget = new $ strClass ( $ event -> getResult ( ) ) ; $ this -> validateWidget ( $ objWidget , $ arrWidget [ 'value' ] ) ; $ strField = $ objWidget -> generateWithError ( ) ; return array ( 'class' => sprintf ( 'mm_%s %s%s%s' , $ arrWidget [ 'inputType' ] , $ arrWidget [ 'eval' ] [ 'urlparam' ] , ( ( $ arrWidget [ 'value' ] !== null ) ? ' used' : ' unused' ) , ( $ objFrontendFilterOptions -> isAutoSubmit ( ) ? ' submitonchange' : '' ) ) , 'label' => $ objWidget -> generateLabel ( ) , 'formfield' => $ strField , 'raw' => $ arrWidget , 'urlparam' => $ arrWidget [ 'eval' ] [ 'urlparam' ] , 'options' => $ this -> prepareFrontendFilterOptions ( $ arrWidget , $ arrFilterUrl , $ arrJumpTo , $ objFrontendFilterOptions -> isAutoSubmit ( ) ) , 'count' => isset ( $ arrWidget [ 'count' ] ) ? $ arrWidget [ 'count' ] : null , 'showCount' => $ objFrontendFilterOptions -> isShowCountValues ( ) , 'autosubmit' => $ objFrontendFilterOptions -> isAutoSubmit ( ) , 'urlvalue' => array_key_exists ( 'urlvalue' , $ arrWidget ) ? $ arrWidget [ 'urlvalue' ] : $ arrWidget [ 'value' ] , 'errors' => $ objWidget -> hasErrors ( ) ? $ objWidget -> getErrors ( ) : array ( ) ) ; }
6632	public function requestAccessToken ( $ code ) { if ( ! $ code || empty ( $ code ) ) { throw new InvalidFacebookCodeException ( ) ; } $ request = [ 'url' => $ this -> settings [ 'token_url' ] , 'params' => [ 'client_id' => $ this -> settings [ 'api_key' ] , 'redirect_uri' => $ this -> settings [ 'redirect_uri' ] , 'client_secret' => $ this -> settings [ 'secret' ] , 'code' => $ code , 'format' => 'json' , ] , ] ; return $ this -> access_token -> make ( $ this -> http -> get ( $ request ) ) ; }
81	public static function call ( $ callable ) { try { self :: suppress ( ) ; $ result = call_user_func_array ( $ callable , array_slice ( func_get_args ( ) , 1 ) ) ; self :: restore ( ) ; return $ result ; } catch ( \ Exception $ e ) { self :: restore ( ) ; throw $ e ; } }
11064	public function upperFirst ( ) { $ this -> value = mb_strtoupper ( mb_substr ( $ this -> value , 0 , 1 , 'UTF-8' ) , 'UTF-8' ) . mb_substr ( $ this -> value , 1 , null , 'UTF-8' ) ; return $ this ; }
9061	private function getTableData ( $ table ) : self { if ( $ table instanceof Table ) { return $ table ; } elseif ( is_subclass_of ( $ table , Mapper :: class ) ) { $ mapper = $ this -> container -> getByType ( $ table ) ; return $ mapper -> getStructure ( ) ; } else { throw new InvalidArgumentException ; } }
3170	protected function hasItemHrefIndexFile ( QtiRunnerServiceContext $ context , $ itemIdentifier ) { if ( $ context -> isAdaptive ( ) ) { return true ; } else { $ indexFile = $ this -> getItemHrefIndexFile ( $ context , $ itemIdentifier ) ; return $ indexFile -> exists ( ) ; } }
9436	public function get ( ) { if ( $ this -> r || $ this -> i ) { if ( ! is_object ( $ this -> i ) ) { return new Complex ( self :: random ( $ this -> r -> min , $ this -> r -> max ) , 0 ) ; } if ( ! is_object ( $ this -> r ) ) { return new Complex ( 0 , self :: random ( $ this -> i -> min , $ this -> i -> max ) ) ; } return new Complex ( self :: random ( $ this -> r -> min , $ this -> r -> max ) , self :: random ( $ this -> i -> min , $ this -> i -> max ) ) ; } if ( $ this -> rho || $ this -> theta ) { if ( ! is_object ( $ this -> theta ) ) { return new Complex ( self :: random ( $ this -> rho -> min , $ this -> rho -> max ) , 0 , Complex :: TRIGONOMETRIC ) ; } if ( ! is_object ( $ this -> rho ) ) { return new Complex ( 0 , self :: random ( $ this -> theta -> min , $ this -> theta -> max ) , Complex :: TRIGONOMETRIC ) ; } return new Complex ( self :: random ( $ this -> rho -> min , $ this -> rho -> max ) , self :: random ( $ this -> theta -> min , $ this -> theta -> max ) , Complex :: TRIGONOMETRIC ) ; } }
824	public function getName ( ) { if ( null === $ this -> name ) { Preg :: matchAll ( '/@[a-zA-Z0-9_-]+(?=\s|$)/' , $ this -> line -> getContent ( ) , $ matches ) ; if ( isset ( $ matches [ 0 ] [ 0 ] ) ) { $ this -> name = ltrim ( $ matches [ 0 ] [ 0 ] , '@' ) ; } else { $ this -> name = 'other' ; } } return $ this -> name ; }
71	protected function filterPackageMap ( array $ packageMap , PackageInterface $ mainPackage ) { $ packages = array ( ) ; $ include = array ( ) ; foreach ( $ packageMap as $ item ) { $ package = $ item [ 0 ] ; $ name = $ package -> getName ( ) ; $ packages [ $ name ] = $ package ; } $ add = function ( PackageInterface $ package ) use ( & $ add , $ packages , & $ include ) { foreach ( $ package -> getRequires ( ) as $ link ) { $ target = $ link -> getTarget ( ) ; if ( ! isset ( $ include [ $ target ] ) ) { $ include [ $ target ] = true ; if ( isset ( $ packages [ $ target ] ) ) { $ add ( $ packages [ $ target ] ) ; } } } } ; $ add ( $ mainPackage ) ; return array_filter ( $ packageMap , function ( $ item ) use ( $ include ) { $ package = $ item [ 0 ] ; foreach ( $ package -> getNames ( ) as $ name ) { if ( isset ( $ include [ $ name ] ) ) { return true ; } } return false ; } ) ; }
6432	public function removeDisplayField ( $ displayField ) { $ key = array_search ( $ displayField , $ this -> displayFields ) ; if ( $ key ) { unset ( $ this -> displayFields [ $ key ] ) ; $ this -> displayFields = array_values ( $ this -> displayFields ) ; } }
4481	public function setInterval ( int $ interval ) : void { if ( $ this -> client -> call ( 'recur.update' , $ this -> jid , 'interval' , $ interval ) ) { $ this -> interval = $ interval ; } }
5955	public function channelPermList ( $ cid , $ permsid = false ) { return $ this -> execute ( "channelpermlist" , array ( "cid" => $ cid , $ permsid ? "-permsid" : null ) ) -> toAssocArray ( $ permsid ? "permsid" : "permid" ) ; }
8029	public function registerFreeProcessId ( $ pid ) { $ processDetails = $ this -> getProcessDetails ( $ pid ) ; if ( $ processDetails !== NULL ) { $ this -> registerFreeProcess ( $ processDetails ) ; } return $ this ; }
10766	private function implodeContent ( ) { ksort ( $ this -> content ) ; $ output = '' ; foreach ( $ this -> content as $ key => $ value ) { $ output .= $ key . self :: KV_DELIMITER . $ value . self :: DELIMITER ; } return rtrim ( $ output , self :: DELIMITER ) ; }
7847	public function info ( int $ id ) : ? array { $ this -> checkConfig ( ) ; $ key = sprintf ( 'smsgatewayme.info.%s' , $ id ) ; if ( $ this -> cache === true and Cache :: has ( $ key ) ) { $ message = [ 'code' => 200 , 'message' => 'OK' , 'data' => Cache :: get ( $ key ) , ] ; } else { $ response = Request :: get ( $ this -> baseUrl . 'message/' . $ id ) ; if ( $ response -> code == 200 ) { Cache :: put ( $ key , $ response -> body , 3600 * 24 ) ; } else { if ( ! empty ( $ response -> body -> message ) ) { Log :: error ( $ response -> body -> message ) ; } } $ message = [ 'code' => $ response -> code , 'message' => ( $ response -> code == 200 ) ? 'OK' : $ response -> body -> message ?? '' , 'data' => $ response -> body , ] ; } return $ message ; }
6855	private function transform ( SaleInterface $ sale ) { $ order = $ this -> newOrder ( ) ; $ this -> saleTransformer -> initialize ( $ sale , $ order ) ; if ( null === $ event = $ this -> saleTransformer -> transform ( ) ) { return $ order ; } return null ; }
545	protected function rotateFiles ( ) { $ file = $ this -> logFile ; for ( $ i = $ this -> maxLogFiles ; $ i >= 0 ; -- $ i ) { $ rotateFile = $ file . ( $ i === 0 ? '' : '.' . $ i ) ; if ( is_file ( $ rotateFile ) ) { if ( $ i === $ this -> maxLogFiles ) { @ unlink ( $ rotateFile ) ; continue ; } $ newFile = $ this -> logFile . '.' . ( $ i + 1 ) ; $ this -> rotateByCopy ? $ this -> rotateByCopy ( $ rotateFile , $ newFile ) : $ this -> rotateByRename ( $ rotateFile , $ newFile ) ; if ( $ i === 0 ) { $ this -> clearLogFile ( $ rotateFile ) ; } } } }
2503	public static function loadMessagesAndVersions ( $ wsdls ) { $ msgAndVer = [ ] ; foreach ( $ wsdls as $ wsdl ) { $ wsdlIdentifier = self :: makeWsdlIdentifier ( $ wsdl ) ; self :: $ wsdlIds [ $ wsdlIdentifier ] = $ wsdl ; self :: loadWsdlXpath ( $ wsdl , $ wsdlIdentifier ) ; $ operations = self :: $ wsdlDomXpath [ $ wsdlIdentifier ] -> query ( self :: XPATH_ALL_OPERATIONS ) ; if ( $ operations -> length === 0 ) { $ imports = self :: $ wsdlDomXpath [ $ wsdlIdentifier ] -> query ( self :: XPATH_IMPORTS ) ; $ operations = [ ] ; foreach ( $ imports as $ import ) { if ( ! empty ( $ import -> value ) ) { $ tmpMsg = self :: getMessagesAndVersionsFromImportedWsdl ( $ import -> value , $ wsdl , $ wsdlIdentifier ) ; foreach ( $ tmpMsg as $ msgName => $ msgInfo ) { $ msgAndVer [ $ msgName ] = $ msgInfo ; } } } } $ msgAndVer = array_merge ( $ msgAndVer , self :: loopOperationsWithQuery ( $ operations , self :: XPATH_VERSION_FOR_OPERATION , $ wsdlIdentifier , self :: $ wsdlDomXpath [ $ wsdlIdentifier ] ) ) ; } return $ msgAndVer ; }
9862	private function writeSheetFormatPr ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { $ objWriter -> startElement ( 'sheetFormatPr' ) ; if ( $ pSheet -> getDefaultRowDimension ( ) -> getRowHeight ( ) >= 0 ) { $ objWriter -> writeAttribute ( 'customHeight' , 'true' ) ; $ objWriter -> writeAttribute ( 'defaultRowHeight' , StringHelper :: formatNumber ( $ pSheet -> getDefaultRowDimension ( ) -> getRowHeight ( ) ) ) ; } else { $ objWriter -> writeAttribute ( 'defaultRowHeight' , '14.4' ) ; } if ( ( string ) $ pSheet -> getDefaultRowDimension ( ) -> getZeroHeight ( ) == '1' || strtolower ( ( string ) $ pSheet -> getDefaultRowDimension ( ) -> getZeroHeight ( ) ) == 'true' ) { $ objWriter -> writeAttribute ( 'zeroHeight' , '1' ) ; } if ( $ pSheet -> getDefaultColumnDimension ( ) -> getWidth ( ) >= 0 ) { $ objWriter -> writeAttribute ( 'defaultColWidth' , StringHelper :: formatNumber ( $ pSheet -> getDefaultColumnDimension ( ) -> getWidth ( ) ) ) ; } $ outlineLevelRow = 0 ; foreach ( $ pSheet -> getRowDimensions ( ) as $ dimension ) { if ( $ dimension -> getOutlineLevel ( ) > $ outlineLevelRow ) { $ outlineLevelRow = $ dimension -> getOutlineLevel ( ) ; } } $ objWriter -> writeAttribute ( 'outlineLevelRow' , ( int ) $ outlineLevelRow ) ; $ outlineLevelCol = 0 ; foreach ( $ pSheet -> getColumnDimensions ( ) as $ dimension ) { if ( $ dimension -> getOutlineLevel ( ) > $ outlineLevelCol ) { $ outlineLevelCol = $ dimension -> getOutlineLevel ( ) ; } } $ objWriter -> writeAttribute ( 'outlineLevelCol' , ( int ) $ outlineLevelCol ) ; $ objWriter -> endElement ( ) ; }
11623	public function close ( ) { if ( $ this -> id == null ) { throw new InternalException ( 'Session not loaded' ) ; } if ( ! $ this -> cli ) { session_write_close ( ) ; } $ this -> id = null ; }
7453	protected function renderLTR ( ) : string { $ trail = '' ; if ( $ this -> before ) { $ trail .= '<span class="before">' . $ this -> before . '</span> ' ; } $ trail .= \ join ( ' <span class="sep delimiter">' . $ this -> delimiter . '</span> ' , $ this -> links ) ; if ( $ this -> after ) { $ trail .= ' <span class="after">' . $ this -> after . '</span>' ; } return $ trail ; }
8409	public static function clear ( ) { $ keys = array_keys ( $ _COOKIE ) ; foreach ( $ keys as $ key ) { setcookie ( $ key , '' , time ( ) - 1 ) ; } }
11956	function addQueue ( $ channel , $ queue , $ weight = 1 ) { $ orig = $ channel ; $ channel = $ this -> _normalizeQueueName ( $ channel ) ; if ( ! $ queue instanceof iQueueDriver ) throw new \ Exception ( sprintf ( 'Queue must be instance of iQueueDriver; given: (%s).' , \ Poirot \ Std \ flatten ( $ queue ) ) ) ; if ( isset ( $ this -> channels_queue [ $ channel ] ) ) throw new \ RuntimeException ( sprintf ( 'Channel (%s) is currently filled with (%s) and is not empty.' , $ orig , get_class ( $ this -> channels_queue [ $ channel ] ) ) ) ; $ this -> channels_queue [ $ channel ] = $ queue ; $ this -> channels_weight [ $ channel ] = $ weight ; return $ this ; }
6301	protected function getMain ( $ name = 'default' ) { $ this -> events -> fire ( 'navigation.main' , [ [ 'name' => $ name ] ] ) ; if ( $ name !== 'default' && ! array_key_exists ( $ name , $ this -> main ) ) { $ name = 'default' ; } if ( ! array_key_exists ( $ name , $ this -> main ) ) { $ this -> main [ $ name ] = [ ] ; } $ nav = $ this -> active ( $ this -> main [ $ name ] ) ; return $ this -> process ( $ nav ) ; }
10301	private function writeLayout ( XMLWriter $ objWriter , Layout $ layout = null ) { $ objWriter -> startElement ( 'c:layout' ) ; if ( $ layout !== null ) { $ objWriter -> startElement ( 'c:manualLayout' ) ; $ layoutTarget = $ layout -> getLayoutTarget ( ) ; if ( $ layoutTarget !== null ) { $ objWriter -> startElement ( 'c:layoutTarget' ) ; $ objWriter -> writeAttribute ( 'val' , $ layoutTarget ) ; $ objWriter -> endElement ( ) ; } $ xMode = $ layout -> getXMode ( ) ; if ( $ xMode !== null ) { $ objWriter -> startElement ( 'c:xMode' ) ; $ objWriter -> writeAttribute ( 'val' , $ xMode ) ; $ objWriter -> endElement ( ) ; } $ yMode = $ layout -> getYMode ( ) ; if ( $ yMode !== null ) { $ objWriter -> startElement ( 'c:yMode' ) ; $ objWriter -> writeAttribute ( 'val' , $ yMode ) ; $ objWriter -> endElement ( ) ; } $ x = $ layout -> getXPosition ( ) ; if ( $ x !== null ) { $ objWriter -> startElement ( 'c:x' ) ; $ objWriter -> writeAttribute ( 'val' , $ x ) ; $ objWriter -> endElement ( ) ; } $ y = $ layout -> getYPosition ( ) ; if ( $ y !== null ) { $ objWriter -> startElement ( 'c:y' ) ; $ objWriter -> writeAttribute ( 'val' , $ y ) ; $ objWriter -> endElement ( ) ; } $ w = $ layout -> getWidth ( ) ; if ( $ w !== null ) { $ objWriter -> startElement ( 'c:w' ) ; $ objWriter -> writeAttribute ( 'val' , $ w ) ; $ objWriter -> endElement ( ) ; } $ h = $ layout -> getHeight ( ) ; if ( $ h !== null ) { $ objWriter -> startElement ( 'c:h' ) ; $ objWriter -> writeAttribute ( 'val' , $ h ) ; $ objWriter -> endElement ( ) ; } $ objWriter -> endElement ( ) ; } $ objWriter -> endElement ( ) ; }
1836	public static function findMultipleByIds ( $ arrIds , array $ arrOptions = array ( ) ) { if ( empty ( $ arrIds ) || ! \ is_array ( $ arrIds ) ) { return null ; } $ arrRegistered = array ( ) ; $ arrUnregistered = array ( ) ; foreach ( $ arrIds as $ intId ) { if ( empty ( $ arrOptions ) ) { $ arrRegistered [ $ intId ] = Registry :: getInstance ( ) -> fetch ( static :: $ strTable , $ intId ) ; } if ( ! isset ( $ arrRegistered [ $ intId ] ) ) { $ arrUnregistered [ ] = $ intId ; } } if ( ! empty ( $ arrUnregistered ) ) { $ t = static :: $ strTable ; $ arrOptions = array_merge ( array ( 'column' => array ( "$t.id IN(" . implode ( ',' , array_map ( '\intval' , $ arrUnregistered ) ) . ")" ) , 'value' => null , 'order' => Database :: getInstance ( ) -> findInSet ( "$t.id" , $ arrIds ) , 'return' => 'Collection' ) , $ arrOptions ) ; $ objMissing = static :: find ( $ arrOptions ) ; if ( $ objMissing !== null ) { while ( $ objMissing -> next ( ) ) { $ intId = $ objMissing -> { static :: $ strPk } ; $ arrRegistered [ $ intId ] = $ objMissing -> current ( ) ; } } } $ arrRegistered = array_filter ( array_values ( $ arrRegistered ) ) ; if ( empty ( $ arrRegistered ) ) { return null ; } return static :: createCollection ( $ arrRegistered , static :: $ strTable ) ; }
10712	public function create ( array $ attributes = [ ] ) { $ model = $ this -> newModel ( ) ; $ model -> fill ( $ attributes ) ; $ this -> save ( $ model ) ; return $ model ; }
192	public function send ( ) { if ( $ this -> isSent ) { return ; } $ this -> trigger ( self :: EVENT_BEFORE_SEND ) ; $ this -> prepare ( ) ; $ this -> trigger ( self :: EVENT_AFTER_PREPARE ) ; $ this -> sendHeaders ( ) ; $ this -> sendContent ( ) ; $ this -> trigger ( self :: EVENT_AFTER_SEND ) ; $ this -> isSent = true ; }
694	public function sendMultiple ( array $ messages ) { $ successCount = 0 ; foreach ( $ messages as $ message ) { if ( $ this -> send ( $ message ) ) { $ successCount ++ ; } } return $ successCount ; }
5803	public function whitelist ( array $ whitelist ) { $ this -> _definitions = array ( ) ; foreach ( $ whitelist as $ definition ) { if ( is_object ( $ definition ) ) { if ( $ definition instanceof Definition \ IDefinition ) $ definitionObject = $ definition ; else throw new \ InvalidArgumentException ( 'Definition objects must implement IDefinition' ) ; } elseif ( preg_match ( '/[a-z:\/]/' , $ definition ) === 0 ) $ definitionObject = new Definition \ IPv4Address ( $ definition ) ; elseif ( preg_match ( '/[a-z:]/' , $ definition ) === 0 ) $ definitionObject = new Definition \ IPv4CIDR ( $ definition ) ; elseif ( preg_match ( '/^[0-9a-f:]+$/' , $ definition ) ) $ definitionObject = new Definition \ IPv6Address ( $ definition ) ; elseif ( preg_match ( '/^[0-9a-f:\/]+$/' , $ definition ) ) $ definitionObject = new Definition \ IPv6CIDR ( $ definition ) ; elseif ( preg_match ( '/^\*\.[\w\.\-]+$/' , $ definition ) ) $ definitionObject = new Definition \ WildcardDomain ( $ definition ) ; elseif ( preg_match ( '/^[\w\.\-]+$/' , $ definition ) ) $ definitionObject = new Definition \ Domain ( $ definition ) ; else throw new \ InvalidArgumentException ( 'Unable to parse definition "' . $ definition . '"' ) ; $ this -> _definitions [ ] = $ definitionObject ; } }
635	public function renameTable ( $ table , $ newName ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> renameTable ( $ table , $ newName ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; }
7636	public function getBlobInstance ( $ containerName = '' , $ blobName = '' , $ snapshotId = null , $ leaseId = null , $ additionalHeaders = array ( ) ) { Assertion :: notEmpty ( $ containerName , 'Container name is not specified' ) ; self :: assertValidContainerName ( $ containerName ) ; Assertion :: notEmpty ( $ blobName , 'Blob name is not specified.' ) ; self :: assertValidRootContainerBlobName ( $ containerName , $ blobName ) ; $ query = array ( ) ; if ( ! is_null ( $ snapshotId ) ) { $ query [ 'snapshot' ] = $ snapshotId ; } $ headers = array ( ) ; if ( ! is_null ( $ leaseId ) ) { $ headers [ 'x-ms-lease-id' ] = $ leaseId ; } foreach ( $ additionalHeaders as $ key => $ value ) { $ headers [ $ key ] = $ value ; } $ resourceName = self :: createResourceName ( $ containerName , $ blobName ) ; $ response = $ this -> performRequest ( $ resourceName , $ query , 'HEAD' , $ headers , false , null , self :: RESOURCE_BLOB , self :: PERMISSION_READ ) ; if ( ! $ response -> isSuccessful ( ) ) { throw new BlobException ( $ this -> getErrorMessage ( $ response , 'Resource could not be accessed.' ) ) ; } $ metadata = $ this -> parseMetadataHeaders ( $ response -> getHeaders ( ) ) ; return new BlobInstance ( $ containerName , $ blobName , $ snapshotId , $ response -> getHeader ( 'Etag' ) , $ response -> getHeader ( 'Last-modified' ) , $ this -> getBaseUrl ( ) . '/' . $ containerName . '/' . $ blobName , $ response -> getHeader ( 'Content-Length' ) , $ response -> getHeader ( 'Content-Type' ) , $ response -> getHeader ( 'Content-Encoding' ) , $ response -> getHeader ( 'Content-Language' ) , $ response -> getHeader ( 'Cache-Control' ) , $ response -> getHeader ( 'x-ms-blob-type' ) , $ response -> getHeader ( 'x-ms-lease-status' ) , false , $ metadata ) ; }
8115	public function advanceReviewDate ( ) { $ nextDateTimestamp = false ; $ options = $ this -> getOptions ( ) ; if ( $ options && $ options -> ReviewPeriodDays ) { $ nextDateTimestamp = strtotime ( ' + ' . $ options -> ReviewPeriodDays . ' days' , DBDatetime :: now ( ) -> getTimestamp ( ) ) ; $ this -> owner -> NextReviewDate = DBDate :: create ( ) -> setValue ( $ nextDateTimestamp ) -> Format ( DBDate :: ISO_DATE ) ; $ this -> owner -> write ( ) ; } return ( bool ) $ nextDateTimestamp ; }
10968	public static function getPath ( ) { $ uri = isset ( $ _SERVER [ 'REQUEST_URI' ] ) ? $ _SERVER [ 'REQUEST_URI' ] : '' ; if ( strpos ( $ uri , '?' ) > 0 ) { $ uri = substr ( $ uri , 0 , strpos ( $ uri , '?' ) ) ; } $ uri = preg_replace ( "/^\\/(.*)$/" , "$1" , $ uri ) ; $ uri = preg_replace ( "/^(.*)\\/$/" , "$1" , $ uri ) ; return $ uri ; }
9585	public function Nice ( ) { if ( $ this -> value && $ parts = parse_url ( $ this -> URL ( ) ) ) { $ remove = array ( 'scheme' , 'user' , 'pass' , 'port' , 'query' , 'fragment' ) ; foreach ( $ remove as $ part ) { unset ( $ parts [ $ part ] ) ; } return rtrim ( http_build_url ( $ parts ) , "/" ) ; } }
11418	public static function createInstance ( $ environment , $ options = null ) { if ( ! self :: $ _instance ) { self :: $ _instance = new static ( $ environment , $ options , false ) ; } return self :: $ _instance ; }
12650	protected function readFileContents ( $ language ) { $ fileName = $ this -> getFileName ( $ language ) ; $ fs = $ this -> env -> getFileSystem ( ) ; if ( ! $ fs -> fileExists ( $ fileName ) ) { return array ( ) ; } $ content = json_decode ( preg_replace ( '/^.*?define\((.*)\);\s*/s' , '$1' , $ fs -> getFile ( $ fileName ) ) , true ) ; if ( $ language === $ this -> baseLang ) { $ content = $ content [ 'root' ] ; } $ outdateInfo = [ ] ; $ fileName = $ this -> getOutdateInfoFileName ( $ language ) ; if ( $ fs -> fileExists ( $ fileName ) ) { $ outdateInfo = json_decode ( $ fs -> getFile ( $ fileName ) , true ) ; } foreach ( $ content as $ id => $ text ) { $ outdated = isset ( $ outdateInfo [ $ id ] ) ? $ outdateInfo [ $ id ] : true ; $ content [ $ id ] = array ( 'id' => $ id , 'name' => $ id , 'content' => $ text , 'outdated' => $ outdated ) ; } return $ content ; }
11901	private function assembleUrl ( ) { $ address = '' ; if ( ! empty ( $ this -> scheme ) ) { $ address .= $ this -> scheme . '://' ; } if ( ! empty ( $ this -> user ) ) { $ address .= $ this -> user ; } if ( ! empty ( $ this -> pass ) ) { $ address .= ':' . $ this -> pass . '@' ; } if ( ! empty ( $ this -> host ) ) { $ address .= $ this -> host ; } if ( ! empty ( $ this -> port ) ) { $ address .= ':' . $ this -> port ; } if ( ! empty ( $ this -> path ) ) { $ address .= $ this -> path ; } if ( count ( $ this -> query ) > 0 ) { $ this -> query_string = http_build_query ( $ this -> query ) ; $ address .= '?' . $ this -> query_string ; } if ( ! empty ( $ this -> fragment ) ) { $ address .= '#' . $ this -> fragment ; } $ this -> full_address = $ address ; }
4689	public function groupBy ( ? string $ expression = null , ... $ args ) : self { $ this -> dirty ( ) ; $ this -> group = $ expression === null ? null : [ $ expression ] ; $ this -> args [ 'group' ] = $ args ; return $ this ; }
10512	private function orderObserversForPriority ( $ a , $ b ) { if ( $ a -> order > $ b -> order ) { return + 1 ; } elseif ( $ a -> order == $ b -> order ) { return 0 ; } return - 1 ; }
8172	private function getSourceExcerpt ( $ source = '' , $ line = 1 , $ plus = 1 , $ format = false ) { $ excerpt = [ ] ; $ twig = Escape :: html ( $ source ) ; $ lines = preg_split ( "/(\r\n|\n|\r)/" , $ twig ) ; $ start = max ( 1 , $ line - $ plus ) ; $ limit = min ( count ( $ lines ) , $ line + $ plus ) ; for ( $ i = $ start - 1 ; $ i < $ limit ; $ i ++ ) { if ( $ format ) { $ attr = 'data-line="' . ( $ i + 1 ) . '"' ; if ( $ i === $ line - 1 ) $ excerpt [ ] = "<mark $attr>$lines[$i]</mark>" ; else $ excerpt [ ] = "<span $attr>$lines[$i]</span>" ; } else { $ excerpt [ ] = $ lines [ $ i ] ; } } return implode ( "\n" , $ excerpt ) ; }
12817	public function fetchAll ( ) { $ list = [ ] ; foreach ( $ this -> cache as $ domain => $ values ) { foreach ( $ values as $ key => $ value ) $ list [ sprintf ( "%s.%s" , $ domain != '<NULL>' ? $ domain : '' , $ key ) ] = $ value ; } return $ list ; }
12160	public function getDetailsWidget ( $ objectModel = null ) { if ( is_null ( $ objectModel ) && isset ( Yii :: $ app -> request -> object ) ) { $ objectModel = Yii :: $ app -> request -> object ; } elseif ( is_null ( $ objectModel ) ) { $ objectModel = $ this -> dummyModel ; } $ detailsSection = $ this -> getDetailsSection ( ) ; if ( $ detailsSection === false ) { return false ; } if ( $ detailsSection === true ) { $ detailsSection = '_self' ; } $ detailsWidgetClass = self :: classNamespace ( ) . '\widgets\\' . 'Details' ; $ widgetClass = $ this -> fallbackDetailsWidgetClass ; @ class_exists ( $ detailsWidgetClass ) ; if ( class_exists ( $ detailsWidgetClass , false ) ) { $ widgetClass = $ detailsWidgetClass ; } $ widget = [ 'class' => $ widgetClass ] ; $ widget [ 'owner' ] = $ this ; $ widgetItem = [ 'widget' => $ widget , 'locations' => [ 'self' ] , 'priority' => 1 ] ; $ widgetItem [ 'section' ] = Yii :: $ app -> collectors [ 'sections' ] -> getOne ( $ detailsSection ) ; return $ widgetItem ; }
4828	public function create_bill ( $ attrs ) { if ( ! isset ( $ attrs [ 'amount' ] ) ) { throw new GoCardless_ArgumentsException ( 'Amount required' ) ; } $ params = array ( 'bill' => array ( 'amount' => $ attrs [ 'amount' ] , 'pre_authorization_id' => $ this -> id ) ) ; if ( isset ( $ attrs [ 'name' ] ) ) { $ params [ 'bill' ] [ 'name' ] = $ attrs [ 'name' ] ; } if ( isset ( $ attrs [ 'description' ] ) ) { $ params [ 'bill' ] [ 'description' ] = $ attrs [ 'description' ] ; } if ( isset ( $ attrs [ 'charge_customer_at' ] ) ) { $ params [ 'bill' ] [ 'charge_customer_at' ] = $ attrs [ 'charge_customer_at' ] ; } $ endpoint = GoCardless_Bill :: $ endpoint ; return new GoCardless_Bill ( $ this -> client , $ this -> client -> request ( 'post' , $ endpoint , $ params ) ) ; }
8007	protected function validateSupportedAlgorithm ( $ algorithm ) { if ( ! in_array ( $ algorithm , $ this -> supported_algorithms , true ) ) { throw new InvalidArgumentException ( sprintf ( 'Algorithm "%s" not supported' , $ algorithm ) ) ; } return $ algorithm ; }
4151	protected function resetCallState ( ) { $ this -> call = null ; $ this -> method = null ; $ this -> withMedia = null ; $ this -> getParams = array ( ) ; $ this -> postParams = array ( ) ; $ this -> headers = null ; }
12891	protected function redirectCorrectDomainSystemParams ( & $ domainParams ) { $ localizationParamName = static :: URL_PARAM_LOCALIZATION ; if ( isset ( $ domainParams [ $ localizationParamName ] ) ) { $ domainParams [ $ localizationParamName ] = $ this -> redirectLocalizationGetUrlValueAndUnsetGet ( $ domainParams [ $ localizationParamName ] ) ; } }
3558	public function setValue ( $ value ) { $ this -> setType ( $ value ) ; if ( $ this -> hasMutator ( $ value , 'setter' ) ) { $ value = $ this -> mutateValue ( $ value , 'setter' ) ; } elseif ( ! $ this -> isStringable ( $ value ) && ! is_null ( $ value ) ) { throw new InvalidTypeException ( "Unsupported meta value type [{$this->getValueType($value)}]." ) ; } $ this -> attributes [ 'meta_value' ] = $ value ; }
166	protected function loadMessagesFromFile ( $ messageFile , $ category ) { if ( is_file ( $ messageFile ) ) { if ( $ this -> useMoFile ) { $ gettextFile = new GettextMoFile ( [ 'useBigEndian' => $ this -> useBigEndian ] ) ; } else { $ gettextFile = new GettextPoFile ( ) ; } $ messages = $ gettextFile -> load ( $ messageFile , $ category ) ; if ( ! is_array ( $ messages ) ) { $ messages = [ ] ; } return $ messages ; } return null ; }
194	public function sendFile ( $ filePath , $ attachmentName = null , $ options = [ ] ) { if ( ! isset ( $ options [ 'mimeType' ] ) ) { $ options [ 'mimeType' ] = FileHelper :: getMimeTypeByExtension ( $ filePath ) ; } if ( $ attachmentName === null ) { $ attachmentName = basename ( $ filePath ) ; } $ handle = fopen ( $ filePath , 'rb' ) ; $ this -> sendStreamAsFile ( $ handle , $ attachmentName , $ options ) ; return $ this ; }
10922	public function setRows ( array $ rows ) { foreach ( $ rows as $ row ) { $ columnNumber = 0 ; if ( ! is_array ( $ row ) ) { $ row = [ $ row ] ; } foreach ( $ row as $ column => $ value ) { $ this -> updateWidth ( $ columnNumber , $ this -> length ( $ column ) ) ; $ this -> updateWidth ( $ columnNumber , $ this -> length ( $ value ) ) ; if ( ! in_array ( $ column , $ this -> columns ) ) { $ this -> columns [ ] = $ column ; } $ columnNumber ++ ; } $ this -> rows [ ] = $ row ; } }
7522	function parse_style ( ) { if ( $ this -> parse_attributes ( ) && ( $ this -> token === self :: TOK_TAG_CLOSE ) && ( $ start = $ this -> pos ) && ( $ this -> next_pos ( '</style>' , false ) === self :: TOK_UNKNOWN ) ) { $ len = $ this -> pos - 1 - $ start ; $ this -> status [ 'text' ] = ( ( $ len > 0 ) ? substr ( $ this -> doc , $ start + 1 , $ len ) : '' ) ; $ this -> pos += 7 ; $ this -> status [ 'last_pos' ] = $ this -> pos ; return true ; } else { $ this -> addError ( 'No end for style tag found' ) ; return false ; } }
7819	public function settle ( ) { $ this -> files -> makeDirectory ( $ this -> path , 0755 , true , true ) ; $ this -> files -> put ( $ this -> getSource ( ) , '' ) ; }
9652	protected function initFormField ( ) { $ options = $ this -> Options ( ) -> map ( 'EscapedTitle' , 'Title' ) ; return new OptionsetField ( $ this -> Name , $ this -> Title , $ options ) ; }
4799	function exec ( $ query ) { $ conn = $ this -> getConn ( ) ; $ sql = $ conn -> quote ( $ query ) ; return $ conn -> exec ( $ sql ) ; }
12325	protected function execute ( InputInterface $ input , OutputInterface $ output ) { try { $ this -> doPreExecute ( $ input , $ output ) ; $ this -> returnCode = $ this -> doExecute ( $ input , $ output ) ; $ this -> doPostExecute ( $ input , $ output ) ; } catch ( Exception $ e ) { $ this -> returnCode = static :: RETURN_ERROR ; throw $ e ; } return $ this -> returnCode ; }
11904	public function getLogModel ( $ refresh = false ) { $ config = $ this -> config ; if ( isset ( $ config [ 'logModel' ] ) ) { if ( ! is_object ( $ config [ 'logModel' ] ) ) { if ( $ refresh ) { return DataInterfaceLog :: find ( ) -> where ( [ 'id' => $ config [ 'logModel' ] ] ) -> one ( ) ; } else { return DataInterfaceLog :: get ( $ config [ 'logModel' ] ) ; } } if ( $ refresh ) { return DataInterfaceLog :: find ( ) -> where ( [ 'id' => $ config [ 'logModel' ] -> primaryKey ] ) -> one ( ) ; } return $ config [ 'logModel' ] ; } return ; }
11402	public function getAppCode ( $ path , $ width = 430 , $ autoColor = false , $ lineColor = [ 'r' => 0 , 'g' => 0 , 'b' => 0 ] ) { $ params = [ 'path' => $ path , 'width' => $ width , 'auto_color' => $ autoColor , 'line_color' => $ lineColor , ] ; return $ this -> getStream ( self :: API_GET_WXACODE , $ params ) ; }
3345	public function __batchProcessFilesChunk ( $ filesUuidArr , $ request_type ) { if ( count ( $ filesUuidArr ) > $ this -> batchFilesChunkSize ) { throw new \ Exception ( 'Files number should not exceed ' . $ this -> batchFilesChunkSize . ' items per request.' ) ; } $ data = $ this -> __preparedRequest ( 'files_storage' , $ request_type , array ( ) , $ filesUuidArr ) ; $ files_raw = ( array ) $ data -> result ; $ result = array ( ) ; foreach ( $ files_raw as $ file_raw ) { $ result [ ] = new File ( $ file_raw -> uuid , $ this , $ file_raw ) ; } return array ( 'status' => ( string ) $ data -> status , 'files' => $ result , 'problems' => $ data -> problems , ) ; }
5376	protected function keysToLowerCase ( $ map ) { $ lower = array ( ) ; foreach ( $ map as $ key => $ value ) { $ lower [ strtolower ( $ key ) ] = $ value ; } return $ lower ; }
7845	public function send ( array $ destinations , string $ text ) : ? array { $ this -> checkConfig ( ) ; $ messages = [ ] ; foreach ( $ destinations as $ destination ) { $ messages [ ] = [ 'phone_number' => $ destination , 'message' => $ text , 'device_id' => $ this -> device , ] ; } $ body = Body :: json ( $ messages ) ; $ response = Request :: post ( $ this -> baseUrl . 'message/send' , [ ] , $ body ) ; if ( $ response -> code == 200 ) { return [ 'code' => $ response -> code , 'message' => 'OK' , 'data' => $ response -> body , ] ; } else { if ( ! empty ( $ response -> body -> message ) ) { Log :: error ( $ response -> body -> message ) ; } return [ 'code' => $ response -> code , 'message' => $ response -> body -> message ?? '' , 'data' => $ response -> body , ] ; } }
8855	public function getArchiveDate ( ) { $ year = $ this -> getArchiveYear ( ) ; $ month = $ this -> getArchiveMonth ( ) ; $ day = $ this -> getArchiveDay ( ) ; if ( $ year ) { if ( $ month ) { $ date = $ year . '-' . $ month . '-01' ; if ( $ day ) { $ date = $ year . '-' . $ month . '-' . $ day ; } } else { $ date = $ year . '-01-01' ; } return DBField :: create_field ( "Date" , $ date ) ; } }
11437	protected function init ( array $ options = null ) { $ this -> boot ( ) ; if ( ! is_null ( $ options ) ) { $ this -> setOptions ( array_merge ( $ this -> getOptions ( ) , $ options ) ) ; } }
12077	public function childStoreWithPivot ( $ idParent , $ request , $ relation ) { $ idParent = $ this -> getRealId ( $ idParent ) ; $ resource = $ this -> repository -> storeChildAndPivot ( $ idParent , $ relation , $ request -> all ( ) ) ; if ( ! $ resource ) { } return $ this -> success ( $ resource ) ; }
3823	public function setPageValue ( string $ name , $ value ) : self { if ( empty ( $ value ) ) { unset ( $ this -> page [ $ name ] ) ; return $ this ; } $ this -> page [ $ name ] = $ value ; return $ this ; }
6057	public function removeMediaFromFolder ( $ folderId , $ mediaId ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> delete ( 'v1/folders/' . $ folderId . '/media/' . $ mediaId . '' , $ parameters ) ; return $ result ; }
10798	public function dateToSqlFormat ( $ dateString ) { $ dateFormatter = new \ IntlDateFormatter ( \ Locale :: getDefault ( ) , \ IntlDateFormatter :: NONE , \ IntlDateFormatter :: NONE , \ date_default_timezone_get ( ) , \ IntlDateFormatter :: GREGORIAN , "dd MMM yyyy" ) ; $ time = $ dateFormatter -> parse ( $ dateString ) ; $ date = new \ DateTime ( ) ; $ date -> setTimestamp ( $ time ) ; return $ date -> format ( 'Y-m-d' ) ; }
1361	public function is ( string ... $ mediaTypes ) : bool { $ mediaTypes = collect ( $ mediaTypes ) -> map ( function ( $ mediaType , $ index ) { return MediaType :: parse ( $ index , $ mediaType ) ; } ) ; return $ this -> any ( ... $ mediaTypes ) ; }
7052	public function logoutCurrentUser ( ) { $ this -> getAuthGuard ( ) -> logout ( ) ; \ Session :: remove ( $ this -> originalUserFromLoginAsActionSessionKey ) ; \ Session :: invalidate ( ) ; $ this -> getCmfConfig ( ) -> resetLocale ( ) ; }
3144	public function finish ( RunnerServiceContext $ context , $ finalState = DeliveryExecution :: STATE_FINISHED ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ executionUri = $ context -> getTestExecutionUri ( ) ; $ userUri = \ common_session_SessionManager :: getSession ( ) -> getUserUri ( ) ; $ executionService = ServiceProxy :: singleton ( ) ; $ deliveryExecution = $ executionService -> getDeliveryExecution ( $ executionUri ) ; if ( $ deliveryExecution -> getUserIdentifier ( ) == $ userUri ) { \ common_Logger :: i ( "Finishing the delivery execution {$executionUri}" ) ; $ result = $ deliveryExecution -> setState ( $ finalState ) ; } else { \ common_Logger :: w ( "Non owner {$userUri} tried to finish deliveryExecution {$executionUri}" ) ; $ result = false ; } $ this -> getServiceManager ( ) -> get ( ExtendedStateService :: SERVICE_ID ) -> clearEvents ( $ executionUri ) ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'finish' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } return $ result ; }
3712	public function generateClearAll ( $ strContent , $ strTemplate ) { if ( substr ( $ strTemplate , 0 , 3 ) === 'fe_' ) { if ( preg_match_all ( '#\[\[\[metamodelfrontendfilterclearall::(ce|mod)::([^\]]*)\]\]\]#' , $ strContent , $ arrMatches , PREG_SET_ORDER ) ) { foreach ( $ arrMatches as $ arrMatch ) { switch ( $ arrMatch [ 1 ] ) { case 'ce' : $ strContent = $ this -> generateContentElement ( $ strContent , $ arrMatch [ 0 ] , $ arrMatch [ 2 ] ) ; break ; case 'mod' : $ strContent = $ this -> generateModule ( $ strContent , $ arrMatch [ 0 ] , $ arrMatch [ 2 ] ) ; break ; default : throw new \ RuntimeException ( 'Unexpected element determinator encountered: ' . $ arrMatch [ 1 ] ) ; } } } } return $ strContent ; }
10448	private function callIfExistsAndEnabled ( $ method , array $ parameters = [ ] ) { if ( ! $ this -> isEnabled ( ) ) return ; if ( method_exists ( $ this , $ method ) && $ this -> { "{$method}IsEnabled" } ( ) ) { $ this -> container -> call ( [ $ this , $ method ] , $ parameters ) ; } }
11667	private function addDefaultFunction ( ) { $ this -> addFunction ( 'app' , function ( ) { return app ( ) ; } ) ; $ this -> addFunction ( 'url' , function ( $ url , $ absolute = false , array $ params = array ( ) ) { if ( $ absolute ) { return Url :: createAbsolute ( $ url , $ params ) ; } else { return Url :: create ( $ url , $ params ) ; } } ) ; $ this -> addFunction ( 'assets' , function ( $ path ) { return Url :: createAbsolute ( $ path ) ; } ) ; }
2133	public static function persist ( $ strKey , $ varValue ) { $ objConfig = static :: getInstance ( ) ; if ( strncmp ( $ strKey , '$GLOBALS' , 8 ) !== 0 ) { $ strKey = "\$GLOBALS['TL_CONFIG']['$strKey']" ; } $ objConfig -> add ( $ strKey , $ varValue ) ; }
12722	protected function turnIntoResolvableClosure ( $ abstract , $ concrete ) { return function ( Container $ container , $ parameters = [ ] ) use ( $ abstract , $ concrete ) { return ( $ abstract == $ concrete ? $ container -> resolve ( $ abstract ) : $ container -> resolve ( $ concrete , $ parameters ) ) ; } ; }
8283	protected function resolveRealUrl ( $ fileName ) { $ fileNameClean = str_replace ( "\0" , '' , $ fileName ) ; $ realPath = realpath ( $ fileNameClean ) ; if ( $ realPath === false ) { return $ this -> requestUrl ; } $ contentPath = realpath ( $ this -> pico -> getConfig ( 'content_dir' ) ) ; $ contentExt = $ this -> pico -> getConfig ( 'content_ext' ) ; if ( strpos ( $ realPath , $ contentPath ) !== 0 ) { throw new \ RuntimeException ( "The plugin cannot be used with " . "symbolic links inside the content directory." ) ; } $ name = substr ( $ realPath , strlen ( $ contentPath ) + 1 , - strlen ( $ contentExt ) ) ; if ( DIRECTORY_SEPARATOR !== '/' ) { $ name = str_replace ( DIRECTORY_SEPARATOR , '/' , $ name ) ; } if ( strlen ( $ name ) >= 5 && 0 === substr_compare ( $ name , "index" , - 5 ) ) { $ name = rtrim ( substr ( $ name , 0 , - 5 ) , '/' ) ; } return $ name ; }
1559	protected function fillAttributes ( $ record , Collection $ attributes ) { $ record -> fill ( $ this -> deserializeAttributes ( $ attributes , $ record ) ) ; }
5965	public function channelGroupPermList ( $ cgid , $ permsid = false ) { return $ this -> execute ( "channelgrouppermlist" , array ( "cgid" => $ cgid , $ permsid ? "-permsid" : null ) ) -> toAssocArray ( $ permsid ? "permsid" : "permid" ) ; }
468	public function buildSimpleCondition ( $ operator , $ operands , & $ params ) { array_unshift ( $ operands , $ operator ) ; return $ this -> buildCondition ( $ operands , $ params ) ; }
9920	private function findSimpleRelations ( Model $ model ) { foreach ( $ model -> getColumns ( ) as $ column ) { if ( ends_with ( $ column -> getName ( ) , self :: ID_SUFFIX ) ) { $ this -> defineRelation ( $ model , $ column -> getName ( ) ) ; } } }
12639	protected function rethrowExceptions ( callable $ callable ) { try { return $ callable ( ) ; } catch ( ImplementationNotFoundException $ ex ) { throw new ImplementationNotFoundException ( $ ex -> getMessage ( ) ) ; } catch ( TypeMismatchException $ ex ) { throw new TypeMismatchException ( $ ex -> getMessage ( ) ) ; } catch ( UnresolveableArgumentException $ ex ) { throw new UnresolveableArgumentException ( $ ex -> getMessage ( ) ) ; } catch ( ValueNotFoundException $ ex ) { throw new ValueNotFoundException ( $ ex -> getMessage ( ) ) ; } catch ( InvalidCallableFormatException $ ex ) { throw new InvalidCallableFormatException ( $ ex -> getMessage ( ) ) ; } catch ( MissingDefinitionIdentifierException $ ex ) { throw new MissingDefinitionIdentifierException ( $ ex -> getMessage ( ) ) ; } catch ( MissingDefinitionValueException $ ex ) { throw new MissingDefinitionValueException ( $ ex -> getMessage ( ) ) ; } catch ( ClassNotFoundException $ ex ) { throw new ClassNotFoundException ( $ ex -> getMessage ( ) ) ; } }
6261	public function getActionMap ( ) { $ actionMap = ( array ) Configure :: read ( 'SimpleRbac.actionMap' ) ; if ( empty ( $ actionMap ) && $ this -> _config [ 'allowEmptyActionMap' ] === false ) { throw new \ RuntimeException ( 'SimpleRbac.actionMap configuration is empty!' ) ; } return $ actionMap ; }
10226	public function noAssociationsMenuFor ( $ model , ModelConfig $ config = null ) { $ modelName = $ this -> resolveModelName ( $ model ) ; $ menuFactory = $ this -> app -> make ( 'Label305\AujaLaravel\Factory\NoAssociationsIndexMenuFactory' ) ; return $ menuFactory -> create ( $ modelName , $ config ) ; }
2816	public function getCollectionsAsArray ( ) { $ data = array ( ) ; foreach ( $ this -> getCollections ( ) as $ collection ) { $ data [ ] = array ( 'type' => $ collection -> getType ( ) , 'class' => $ collection -> getClass ( ) , 'sql' => $ collection -> getQuery ( ) , 'count' => $ collection -> getCount ( ) ) ; } return $ data ; }
2979	public function getExceptionByIdentifier ( $ identifier ) { $ key = strtolower ( $ identifier ) ; if ( ! isset ( $ this -> exceptions [ $ key ] ) ) { return ; } list ( $ identifier , $ name ) = $ this -> exceptions [ $ key ] ; return array ( $ name , 'https://spdx.org/licenses/' . $ identifier . '.html#licenseExceptionText' , ) ; }
5434	protected function isStaticMethod ( $ name ) { $ interface = new ReflectionClass ( $ this -> interface ) ; if ( ! $ interface -> hasMethod ( $ name ) ) { return false ; } return $ interface -> getMethod ( $ name ) -> isStatic ( ) ; }
2427	public function onBuild ( MenuEvent $ event ) : void { if ( null === $ this -> managerPath || ! $ this -> isAdminUser ( ) ) { return ; } $ categoryNode = $ event -> getTree ( ) -> getChild ( 'system' ) ; if ( null === $ categoryNode ) { return ; } $ item = $ event -> getFactory ( ) -> createItem ( 'contao_manager' , [ 'label' => 'Contao Manager' , 'attributes' => [ 'title' => 'Contao Manager' , 'href' => '/' . $ this -> managerPath , 'class' => 'navigation contao_manager' , ] , ] ) ; $ categoryNode -> addChild ( $ item ) ; }
1453	protected function excluded ( string ... $ keys ) : Collection { return collect ( $ keys ) -> mapWithKeys ( function ( $ key ) { return [ $ key => new DisallowedParameter ( $ key ) ] ; } ) ; }
8515	public function putTransportContent ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_PutTransportContentRequest ) ) { $ request = new FBAInboundServiceMWS_Model_PutTransportContentRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'PutTransportContent' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_PutTransportContentResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
10360	public static function fatal ( ) { $ e = error_get_last ( ) ; if ( $ e !== null && ( error_reporting ( ) & $ e [ 'type' ] ) !== 0 ) { ErrorHandler :: exception ( new \ ErrorException ( $ e [ 'message' ] , $ e [ 'type' ] , 0 , $ e [ 'file' ] , $ e [ 'line' ] ) ) ; exit ( 1 ) ; } }
10777	private function total_size ( ) { $ arr = array ( "width" => 0 , "height" => 0 ) ; foreach ( $ this -> images as $ image ) { if ( $ arr [ "width" ] < $ image [ "width" ] ) { $ arr [ "width" ] = $ image [ "width" ] ; } $ arr [ "height" ] += $ image [ "height" ] ; } return $ arr ; }
2846	public function getUrl ( $ path , array $ params = array ( ) ) { $ path = self :: MODULE_ROUTE . $ path ; $ params [ '_store' ] = $ this -> getRouteStoreId ( ) ; $ params [ '_nosid' ] = true ; return $ this -> _getUrl ( $ path , $ params ) ; }
7505	public function assignNamespace ( string $ namespace , $ prepend = false ) { if ( $ prepend ) { array_unshift ( $ this -> namespaces , $ namespace ) ; return ; } array_push ( $ this -> namespaces , $ namespace ) ; }
4259	public function getSubscribers ( $ eventName = null ) { if ( $ eventName !== null ) { if ( ! isset ( $ this -> subscribers [ $ eventName ] ) ) { return array ( ) ; } if ( ! isset ( $ this -> sorted [ $ eventName ] ) ) { $ this -> sortSubscribers ( $ eventName ) ; } return $ this -> sorted [ $ eventName ] ; } foreach ( \ array_keys ( $ this -> subscribers ) as $ eventName ) { if ( ! isset ( $ this -> sorted [ $ eventName ] ) ) { $ this -> sortSubscribers ( $ eventName ) ; } } return \ array_filter ( $ this -> sorted ) ; }
4473	public function heartbeat ( array $ data = [ ] ) : float { try { $ this -> expires = $ this -> client -> heartbeat ( $ this -> jid , $ this -> worker , json_encode ( $ data , JSON_UNESCAPED_SLASHES ) ) ; } catch ( QlessException $ e ) { throw new LostLockException ( $ e -> getMessage ( ) , 'Heartbeat' , $ this -> jid , $ e -> getCode ( ) , $ e ) ; } return $ this -> expires ; }
5906	public function listSettings ( CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/accounts/settings' , $ parameters , $ cachePolicy ) ; return $ result ; }
5492	protected function renderArguments ( $ args ) { $ descriptions = array ( ) ; if ( is_array ( $ args ) ) { foreach ( $ args as $ arg ) { $ dumper = new SimpleDumper ( ) ; $ descriptions [ ] = $ dumper -> describeValue ( $ arg ) ; } } return implode ( ', ' , $ descriptions ) ; }
1221	private function reduce ( $ from , array $ values , array $ types , callable $ reduce ) { $ i = - 1 ; return array_reduce ( $ values , function ( $ carry , $ item ) use ( $ from , $ types , $ reduce , & $ i ) { if ( ++ $ i > 0 ) { $ this -> validateSeq ( $ from , $ types , $ carry , $ item ) ; } return $ reduce ( $ carry , $ item , $ i ) ; } ) ; }
4276	public function stream_metadata ( $ path , $ option , $ value ) { self :: restorePrev ( ) ; switch ( $ option ) { case STREAM_META_TOUCH : if ( ! empty ( $ value ) ) { $ success = \ touch ( $ path , $ value [ 0 ] , $ value [ 1 ] ) ; } else { $ success = \ touch ( $ path ) ; } break ; case STREAM_META_OWNER_NAME : case STREAM_META_OWNER : $ success = \ chown ( $ path , $ value ) ; break ; case STREAM_META_GROUP_NAME : case STREAM_META_GROUP : $ success = \ chgrp ( $ path , $ value ) ; break ; case STREAM_META_ACCESS : $ success = \ chmod ( $ path , $ value ) ; break ; default : $ success = false ; } self :: register ( ) ; return $ success ; }
10887	public function getSession ( $ sessionId ) { return tap ( $ this -> manager -> driver ( ) , function ( $ session ) use ( $ sessionId ) { $ session -> setId ( $ sessionId ) ; } ) ; }
297	public function getDirtyAttributes ( $ names = null ) { if ( $ names === null ) { $ names = $ this -> attributes ( ) ; } $ names = array_flip ( $ names ) ; $ attributes = [ ] ; if ( $ this -> _oldAttributes === null ) { foreach ( $ this -> _attributes as $ name => $ value ) { if ( isset ( $ names [ $ name ] ) ) { $ attributes [ $ name ] = $ value ; } } } else { foreach ( $ this -> _attributes as $ name => $ value ) { if ( isset ( $ names [ $ name ] ) && ( ! array_key_exists ( $ name , $ this -> _oldAttributes ) || $ value !== $ this -> _oldAttributes [ $ name ] ) ) { $ attributes [ $ name ] = $ value ; } } } return $ attributes ; }
10769	public function run ( ) { $ viewName = $ this -> resolveViewName ( ) ; $ this -> controller -> actionParams [ $ this -> viewParam ] = Yii :: $ app -> request -> get ( $ this -> viewParam ) ; $ controllerLayout = null ; if ( $ this -> layout !== null ) { $ controllerLayout = $ this -> controller -> layout ; $ this -> controller -> layout = $ this -> layout ; } try { $ output = $ this -> render ( $ viewName ) ; if ( $ controllerLayout ) { $ this -> controller -> layout = $ controllerLayout ; } } catch ( InvalidParamException $ e ) { if ( $ controllerLayout ) { $ this -> controller -> layout = $ controllerLayout ; } if ( YII_DEBUG ) { throw new NotFoundHttpException ( $ e -> getMessage ( ) ) ; } else { throw new NotFoundHttpException ( Yii :: t ( 'yii' , 'The requested view "{name}" was not found.' , [ 'name' => $ viewName ] ) ) ; } } return $ output ; }
1561	protected function deserializeAttributes ( $ attributes , $ record ) { return collect ( $ attributes ) -> reject ( function ( $ v , $ field ) use ( $ record ) { return $ this -> isNotFillable ( $ field , $ record ) ; } ) -> mapWithKeys ( function ( $ value , $ field ) use ( $ record ) { $ key = $ this -> modelKeyForField ( $ field , $ record ) ; return [ $ key => $ this -> deserializeAttribute ( $ value , $ field , $ record ) ] ; } ) -> all ( ) ; }
11089	public static function isCzechHoliday ( $ date ) { if ( ! $ date instanceof DateTime ) { if ( \ is_int ( $ date ) ) { $ date = new DateTime ( '@' . $ date ) ; } elseif ( \ is_string ( $ date ) ) { $ date = new DateTime ( $ date ) ; } else { throw new RuntimeException ( self :: poorManTranslate ( 'fts-shared' , 'Invalid date format' ) ) ; } } $ holidays = [ '01-01' , '05-01' , '05-08' , '07-05' , '07-06' , '09-28' , '10-28' , '11-17' , '12-24' , '12-25' , '12-26' ] ; if ( \ in_array ( $ date -> format ( 'm-d' ) , $ holidays , true ) ) { return true ; } $ easterDays = easter_days ( $ date -> format ( 'Y' ) ) ; $ easter = new DateTime ( $ date -> format ( 'Y' ) . '-03-21' ) ; $ easter -> add ( new \ DateInterval ( 'P' . $ easterDays . 'D' ) ) ; $ easter -> sub ( new \ DateInterval ( 'P2D' ) ) ; if ( $ date -> format ( 'Y-m-d' ) === $ easter -> format ( 'Y-m-d' ) ) { return true ; } $ easter -> add ( new \ DateInterval ( 'P3D' ) ) ; return ( $ easter -> format ( 'Y-m-d' ) === $ date -> format ( 'Y-m-d' ) ) ; }
9491	public function getFileListData ( $ sFieldName ) { if ( empty ( $ sFieldName ) ) { return [ ] ; } $ obFileList = $ this -> $ sFieldName ; if ( $ obFileList -> isEmpty ( ) ) { return [ ] ; } $ arResult = [ ] ; foreach ( $ obFileList as $ obFile ) { if ( empty ( $ obFile ) || ! $ obFile instanceof File ) { continue ; } $ arResult [ ] = $ this -> getFileDataValue ( $ obFile ) ; } return $ arResult ; }
3309	protected function buildSignatureKey ( ) { $ signatures = [ 'a' => $ this -> appId , 'b' => $ this -> bucket , 'k' => $ this -> secretId , 'e' => time ( ) + 2592000 , 't' => time ( ) , 'r' => rand ( ) , 'u' => '0' , 'f' => '' ] ; return http_build_query ( $ signatures ) ; }
2066	public function getPageTypes ( Contao \ DataContainer $ dc ) { $ arrOptions = array ( ) ; foreach ( array_keys ( $ GLOBALS [ 'TL_PTY' ] ) as $ pty ) { if ( $ pty == 'root' && $ dc -> activeRecord && $ dc -> activeRecord -> pid > 0 ) { continue ; } if ( $ pty == $ dc -> value || $ this -> User -> hasAccess ( $ pty , 'alpty' ) ) { $ arrOptions [ ] = $ pty ; } } return $ arrOptions ; }
8194	public function render ( $ template , $ data = [ ] , $ return = true ) { if ( $ template instanceof Page ) { $ page = $ template ; $ file = $ page -> templateFile ( ) ; $ data = $ this -> data ( $ page , $ data ) ; } else { $ file = $ template ; $ data = $ this -> data ( null , $ data ) ; } if ( ! file_exists ( $ file ) ) { throw new Exception ( 'The template could not be found' ) ; } $ startData = Tpl :: $ data ; Tpl :: $ data = array_merge ( Tpl :: $ data , $ data ) ; if ( pathinfo ( $ file , PATHINFO_EXTENSION ) === 'twig' ) { $ twig = TwigEnv :: instance ( ) ; $ result = $ twig -> renderPath ( $ file , Tpl :: $ data , $ return , true ) ; } else { $ result = Tpl :: load ( $ file , [ ] , $ return ) ; } Tpl :: $ data = $ startData ; return $ result ; }
11246	public function getMigrations ( int $ steps ) : array { $ sql = "select migration from {$this->table} where batch >= 1 order by batch, migration desc limit ?" ; $ stmt = $ this -> pdo -> prepare ( $ sql ) ; $ stmt -> bindParam ( 1 , $ steps , PDO :: PARAM_INT ) ; $ stmt -> execute ( ) ; return $ stmt -> fetchAll ( PDO :: FETCH_COLUMN ) ; }
12348	protected function getConnectionInitializer ( OptionsInterface $ options , $ callable ) { if ( ! is_callable ( $ callable ) ) { $ class = get_called_class ( ) ; throw new \ InvalidArgumentException ( "$class expects a valid callable" ) ; } $ option = $ this ; return function ( $ parameters = null ) use ( $ callable , $ options , $ option ) { $ connection = call_user_func ( $ callable , $ options , $ parameters ) ; if ( ! $ connection instanceof AggregateConnectionInterface ) { $ class = get_class ( $ option ) ; throw new \ InvalidArgumentException ( "$class expects a valid connection type returned by callable initializer" ) ; } return $ connection ; } ; }
5392	public function paintPass ( $ message ) { parent :: paintPass ( $ message ) ; print $ this -> getIndent ( 1 ) ; print '<' . $ this -> namespace . 'pass>' ; print $ this -> toParsedXml ( $ message ) ; print '</' . $ this -> namespace . "pass>\n" ; }
10730	public function getHour ( ) { if ( $ this -> value !== null ) { preg_match ( '/^(?P<year>[0-9]{4,4})-(?P<month>[0-9]{2,2})-(?P<day>[0-9]{2,2}) (?P<hour>[0-9]{2,2}):(?P<minute>[0-9]{2,2}):(?P<second>[0-9]{2,2})$/ui' , $ this -> value , $ m ) ; return ( int ) $ m [ 'hour' ] ; } }
5842	public function getAdditionalFields ( array & $ taskInfo , $ task , \ TYPO3 \ CMS \ Scheduler \ Controller \ SchedulerModuleController $ parentObject ) { $ editCommand = version_compare ( TYPO3_branch , '9.5' , '>=' ) ? $ parentObject -> getCurrentAction ( ) === Action :: EDIT : $ parentObject -> CMD === 'edit' ; if ( ! isset ( $ taskInfo [ 'scheduler_batchResize_directories' ] ) ) { $ taskInfo [ 'scheduler_batchResize_directories' ] = $ this -> defaultDirectories ; if ( $ editCommand ) { $ taskInfo [ 'scheduler_batchResize_directories' ] = $ task -> directories ; } } if ( ! isset ( $ taskInfo [ 'scheduler_batchResize_excludeDirectories' ] ) ) { $ taskInfo [ 'scheduler_batchResize_excludeDirectories' ] = $ this -> defaultExcludeDirectories ; if ( $ editCommand ) { $ taskInfo [ 'scheduler_batchResize_excludeDirectories' ] = $ task -> excludeDirectories ; } } $ additionalFields = [ ] ; $ fieldName = 'tx_scheduler[scheduler_batchResize_directories]' ; $ fieldId = 'scheduler_batchResize_directories' ; $ fieldValue = trim ( $ taskInfo [ 'scheduler_batchResize_directories' ] ) ; $ fieldHtml = '<textarea class="form-control" rows="4" name="' . $ fieldName . '" id="' . $ fieldId . '">' . htmlspecialchars ( $ fieldValue ) . '</textarea>' ; $ additionalFields [ $ fieldId ] = [ 'code' => $ fieldHtml , 'label' => 'LLL:EXT:image_autoresize/Resources/Private/Language/locallang_mod.xlf:label.batchResize.directories' , ] ; $ fieldName = 'tx_scheduler[scheduler_batchResize_excludeDirectories]' ; $ fieldId = 'scheduler_batchResize_excludeDirectories' ; $ fieldValue = trim ( $ taskInfo [ 'scheduler_batchResize_excludeDirectories' ] ) ; $ fieldHtml = '<textarea class="form-control" rows="4" name="' . $ fieldName . '" id="' . $ fieldId . '">' . htmlspecialchars ( $ fieldValue ) . '</textarea>' ; $ additionalFields [ $ fieldId ] = [ 'code' => $ fieldHtml , 'label' => 'LLL:EXT:image_autoresize/Resources/Private/Language/locallang_mod.xlf:label.batchResize.excludeDirectories' , ] ; return $ additionalFields ; }
8144	public function tokenize ( $ source , $ name = null ) { if ( ! $ source instanceof Twig_Source ) { @ trigger_error ( sprintf ( 'Passing a string as the $source argument of %s() is deprecated since version 1.27. Pass a Twig_Source instance instead.' , __METHOD__ ) , E_USER_DEPRECATED ) ; $ source = new Twig_Source ( $ source , $ name ) ; } if ( null === $ this -> lexer ) { $ this -> lexer = new Twig_Lexer ( $ this ) ; } return $ this -> lexer -> tokenize ( $ source ) ; }
979	protected function response ( Request $ request , Closure $ next ) { $ response = $ next ( $ request ) ; if ( Config :: get ( 'shopify-app.esdk_enabled' ) && ( $ request -> ajax ( ) || $ request -> expectsJson ( ) || $ request -> isJson ( ) ) === false ) { if ( ( $ response instanceof BaseResponse ) === false ) { $ response = new Response ( $ response ) ; } $ response -> headers -> set ( 'P3P' , 'CP="Not used"' ) ; $ response -> headers -> remove ( 'X-Frame-Options' ) ; } return $ response ; }
3767	private function getOptions ( $ attribute , $ onlyUsed ) { $ options = [ ] ; foreach ( $ attribute -> getFilterOptions ( null , $ onlyUsed ) as $ key => $ value ) { $ value = trim ( strip_tags ( $ value ) ) ; if ( ! empty ( $ value ) ) { $ options [ $ key ] = $ value ; } } return $ options ; }
4074	protected function resolve ( ) { $ factory = $ this -> container -> getFactory ( ) ; $ names = $ factory -> collectNames ( ) ; foreach ( $ names as $ name ) { $ this -> information [ $ name ] = array ( self :: COMBINATION => null , self :: INPUTSCREEN => null , self :: RENDERSETTING => null , self :: MODELID => null , ) ; } $ found = $ this -> getPaletteCombinationRows ( ) ; if ( ! $ found ) { $ found = array ( ) ; } foreach ( array_keys ( $ this -> information ) as $ tableName ) { if ( empty ( $ this -> information [ $ tableName ] [ self :: COMBINATION ] ) || empty ( $ this -> information [ $ tableName ] [ self :: COMBINATION ] [ 'dca_id' ] ) || empty ( $ this -> information [ $ tableName ] [ self :: COMBINATION ] [ 'view_id' ] ) ) { unset ( $ this -> information [ $ tableName ] ) ; } } $ this -> fetchInputScreenDetails ( ) ; }
408	public function get ( $ name = null , $ defaultValue = null ) { if ( $ name === null ) { return $ this -> getQueryParams ( ) ; } return $ this -> getQueryParam ( $ name , $ defaultValue ) ; }
6125	public function setRoles ( array $ roles ) { $ this -> roles = [ ] ; foreach ( $ roles as $ item ) { $ this -> addRole ( $ item ) ; } return $ this ; }
5435	public function getSignature ( $ name ) { $ interface = new ReflectionClass ( $ this -> interface ) ; $ method = $ interface -> getMethod ( $ name ) ; $ abstract = ( $ method -> isAbstract ( ) && ! $ interface -> isInterface ( ) && ! $ this -> isAbstractMethodInParents ( $ name ) ) ? 'abstract ' : '' ; if ( $ method -> isPublic ( ) ) { $ visibility = 'public' ; } elseif ( $ method -> isProtected ( ) ) { $ visibility = 'protected' ; } else { $ visibility = 'private' ; } $ static = $ method -> isStatic ( ) ? 'static ' : '' ; $ reference = $ method -> returnsReference ( ) ? '&' : '' ; $ params = $ this -> getParameterSignatures ( $ method ) ; $ returnType = $ this -> getReturnType ( $ method ) ; return "{$abstract}$visibility {$static}function $reference$name($params){$returnType}" ; }
7866	protected function drawBorderTop ( $ isCore = false ) { $ crossroads = $ isCore ? static :: CROSSROADS_UP : static :: CROSSROADS ; $ this -> drawBorder ( static :: BORDER_NW , $ crossroads , static :: BORDER_NE ) ; $ this -> geometry -> increaseNesting ( ) ; }
5883	public function beforeFind ( Event $ event , Query $ query , ArrayObject $ options , $ primary ) { $ orders = $ this -> _config [ 'orders' ] ; $ args = [ $ query , $ options , $ primary ] ; foreach ( $ orders as $ config ) { if ( ( ! empty ( $ config [ 'callback' ] ) && call_user_func_array ( $ config [ 'callback' ] , $ args ) ) || ! $ query -> clause ( 'order' ) ) { $ query -> order ( $ config [ 'order' ] ) ; break ; } } }
10384	protected static function set_new_params ( $ type , $ hash , $ url , $ extension ) { $ data = [ 'name' => self :: $ id , 'url' => $ url . $ hash . $ extension , 'deps' => self :: unify_params ( $ type , 'deps' ) , 'version' => self :: unify_params ( $ type , 'version' , '1.0.0' ) , ] ; switch ( $ type ) { case 'style' : $ data [ 'media' ] = self :: unify_params ( $ type , 'media' , 'all' ) ; break ; case 'script' : $ data [ 'params' ] = self :: unify_params ( $ type , 'params' ) ; $ data [ 'footer' ] = self :: unify_params ( $ type , 'footer' , false ) ; $ data [ 'params' ] [ 'nonce' ] = wp_create_nonce ( self :: $ id ) ; break ; default : } self :: $ data [ $ type ] = [ $ data [ 'name' ] => $ data ] ; return true ; }
4648	private function getConfigValue ( $ config , $ language , $ key ) { if ( ! isset ( $ config [ $ key ] ) || empty ( $ config [ $ key ] ) ) { if ( isset ( $ this -> defaults [ $ language ] [ $ key ] ) ) { return $ this -> defaults [ $ language ] [ $ key ] ; } return array ( ) ; } if ( ! is_array ( $ config [ $ key ] ) ) { return array ( $ config [ $ key ] ) ; } return $ config [ $ key ] ; }
9972	public function setCodeName ( $ pValue , $ validate = true ) { if ( $ this -> getCodeName ( ) == $ pValue ) { return $ this ; } if ( $ validate ) { $ pValue = str_replace ( ' ' , '_' , $ pValue ) ; self :: checkSheetCodeName ( $ pValue ) ; if ( $ this -> getParent ( ) ) { if ( $ this -> getParent ( ) -> sheetCodeNameExists ( $ pValue ) ) { if ( Shared \ StringHelper :: countCharacters ( $ pValue ) > 29 ) { $ pValue = Shared \ StringHelper :: substring ( $ pValue , 0 , 29 ) ; } $ i = 1 ; while ( $ this -> getParent ( ) -> sheetCodeNameExists ( $ pValue . '_' . $ i ) ) { ++ $ i ; if ( $ i == 10 ) { if ( Shared \ StringHelper :: countCharacters ( $ pValue ) > 28 ) { $ pValue = Shared \ StringHelper :: substring ( $ pValue , 0 , 28 ) ; } } elseif ( $ i == 100 ) { if ( Shared \ StringHelper :: countCharacters ( $ pValue ) > 27 ) { $ pValue = Shared \ StringHelper :: substring ( $ pValue , 0 , 27 ) ; } } } $ pValue = $ pValue . '_' . $ i ; } } } $ this -> codeName = $ pValue ; return $ this ; }
4158	function run ( ) { $ now = new DateTime ( 'now' ) ; $ sleep = min ( array_map ( function ( $ entry ) use ( $ now ) { list ( $ expression , $ job ) = $ entry ; return $ expression -> getNextRunDate ( $ now ) -> getTimestamp ( ) ; } , $ this -> entries ) ) ; time_sleep_until ( $ sleep ) ; $ scheduled = 0 ; foreach ( $ this -> entries as $ entry ) { list ( $ expression , $ job ) = $ entry ; if ( $ expression -> isDue ( $ now ) ) { $ this -> queue -> push ( $ job ) ; $ scheduled += 1 ; } } $ this -> queue -> flush ( ) ; return $ scheduled ; }
5868	public static function getMetadata ( $ fileName , $ fullExtract = false ) { $ metadata = static :: getBasicMetadata ( $ fileName ) ; if ( $ fullExtract && ! empty ( $ metadata ) ) { $ virtualFileObject = static :: getVirtualFileObject ( $ fileName , $ metadata ) ; $ extractorRegistry = \ TYPO3 \ CMS \ Core \ Resource \ Index \ ExtractorRegistry :: getInstance ( ) ; $ extractionServices = $ extractorRegistry -> getExtractorsWithDriverSupport ( 'Local' ) ; $ newMetadata = [ 0 => $ metadata , ] ; foreach ( $ extractionServices as $ service ) { if ( $ service -> canProcess ( $ virtualFileObject ) ) { $ newMetadata [ $ service -> getPriority ( ) ] = $ service -> extractMetaData ( $ virtualFileObject , $ newMetadata ) ; } } ksort ( $ newMetadata ) ; foreach ( $ newMetadata as $ data ) { $ metadata = array_merge ( $ metadata , $ data ) ; } } return $ metadata ; }
12478	public function connect ( ) { $ this -> loadConnectors ( ) ; $ connector = new \ elFinderConnector ( new \ elFinder ( $ this -> options ) ) ; $ connector -> run ( ) ; }
2117	public function getExcludedFields ( ) { $ processed = array ( ) ; $ files = Contao \ System :: getContainer ( ) -> get ( 'contao.resource_finder' ) -> findIn ( 'dca' ) -> depth ( 0 ) -> files ( ) -> name ( '*.php' ) ; foreach ( $ files as $ file ) { if ( \ in_array ( $ file -> getBasename ( ) , $ processed ) ) { continue ; } $ processed [ ] = $ file -> getBasename ( ) ; $ strTable = $ file -> getBasename ( '.php' ) ; Contao \ System :: loadLanguageFile ( $ strTable ) ; $ this -> loadDataContainer ( $ strTable ) ; } $ arrReturn = array ( ) ; foreach ( $ GLOBALS [ 'TL_DCA' ] as $ k => $ v ) { if ( \ is_array ( $ v [ 'fields' ] ) ) { foreach ( $ v [ 'fields' ] as $ kk => $ vv ) { if ( $ k == 'tl_user' && $ kk == 'admin' && ! $ this -> User -> isAdmin ) { continue ; } if ( $ vv [ 'exclude' ] || $ vv [ 'orig_exclude' ] ) { $ arrReturn [ $ k ] [ Contao \ StringUtil :: specialchars ( $ k . '::' . $ kk ) ] = isset ( $ vv [ 'label' ] [ 0 ] ) ? $ vv [ 'label' ] [ 0 ] . ' <span style="color:#999;padding-left:3px">[' . $ kk . ']</span>' : $ kk ; } } } } ksort ( $ arrReturn ) ; return $ arrReturn ; }
3460	public function find ( string $ method , string $ path ) : Route { $ matcher = new UrlMatcher ( $ this -> routeCollection , new RequestContext ( '/' , $ method ) ) ; try { $ route = $ matcher -> match ( $ path ) ; } catch ( ResourceNotFoundException $ exception ) { throw RouterException :: noRouteMatchesRequestedUri ( $ path , $ method ) ; } catch ( SymfonyMethodNotAllowedException $ exception ) { throw RouterException :: methodNotAllowed ( $ path , $ exception -> getAllowedMethods ( ) ) ; } $ routeName = $ route [ '_route' ] ; unset ( $ route [ '_route' ] ) ; return $ this -> routes [ $ routeName ] -> withAttributes ( $ route ) ; }
5708	public function transformToButton ( ) { parent :: transformToButton ( ) ; if ( $ this -> gridFieldRequest -> recordIsPublished ( ) ) { $ this -> setTitle ( _t ( 'SiteTree.BUTTONPUBLISHED' , 'Published' ) ) ; } if ( $ this -> gridFieldRequest -> record -> stagesDiffer ( 'Stage' , 'Live' ) && $ this -> gridFieldRequest -> recordIsDeletedFromStage ( ) ) { $ this -> addExtraClass ( 'ss-ui-alternate' ) ; } return $ this ; }
2487	protected function search ( array $ parameters ) { $ queryString = $ this -> generateQueryString ( $ parameters ) ; $ response = $ this -> client -> request ( 'POST' , $ this -> endpointRegistry -> getEndpoint ( $ this -> endpointResolver -> getEntryEndpoint ( ) ) , '/select' , new Message ( [ 'Content-Type' => 'application/x-www-form-urlencoded' , ] , $ queryString ) ) ; $ result = json_decode ( $ response -> body ) ; if ( ! isset ( $ result -> response ) ) { throw new RuntimeException ( '->response not set: ' . var_export ( array ( $ result , $ parameters ) , true ) ) ; } return $ result ; }
11974	private function firstParamValidation ( Event $ event ) { $ params = $ event -> getCustomParams ( ) ; return ( is_numeric ( $ params [ 0 ] ) && $ params [ 0 ] > 0 && $ params [ 0 ] <= $ this -> maxDieRolls ) ; }
6838	public function mapDatas ( $ kvs ) { foreach ( $ kvs as $ k => $ v ) { $ this -> mapData ( $ k , $ v ) ; } }
6104	public function wait ( ) { if ( $ this -> getTransport ( ) -> getConfig ( "blocking" ) ) { throw new Ts3Exception ( "only available in non-blocking mode" ) ; } do { $ evt = $ this -> getTransport ( ) -> readLine ( ) ; var_dump ( $ evt ) ; } while ( $ evt instanceof StringHelper && ! $ evt -> section ( TeamSpeak3 :: SEPARATOR_CELL ) -> startsWith ( TeamSpeak3 :: EVENT ) ) ; return new Event ( $ evt , $ this -> getHost ( ) ) ; }
11982	public function acquire ( AcquirerInterface $ acquirer , ResourceInterface $ resource ) { if ( ! $ this -> isAccessible ( $ acquirer , $ resource ) ) { throw new ResourceLockedException ( sprintf ( 'The resource is not accessible. It is locked by "%s".' , $ resource -> getLock ( ) -> getAcquirer ( ) -> getIdentifier ( ) ) ) ; } return $ this -> repository -> acquire ( $ acquirer , $ resource ) ; }
4268	public function dir_opendir ( $ path , $ options = 0 ) { if ( $ this -> handle ) { return false ; } array ( $ options ) ; self :: restorePrev ( ) ; $ this -> handle = \ opendir ( $ path ) ; self :: register ( ) ; return $ this -> handle !== false ; }
10281	public static function absoluteCoordinate ( $ pCoordinateString ) { if ( self :: coordinateIsRange ( $ pCoordinateString ) ) { throw new Exception ( 'Cell coordinate string can not be a range of cells' ) ; } $ worksheet = '' ; $ cellAddress = explode ( '!' , $ pCoordinateString ) ; if ( count ( $ cellAddress ) > 1 ) { list ( $ worksheet , $ pCoordinateString ) = $ cellAddress ; } if ( $ worksheet > '' ) { $ worksheet .= '!' ; } list ( $ column , $ row ) = self :: coordinateFromString ( $ pCoordinateString ) ; $ column = ltrim ( $ column , '$' ) ; $ row = ltrim ( $ row , '$' ) ; return $ worksheet . '$' . $ column . '$' . $ row ; }
4049	public function fetchInputScreens ( $ idList ) : array { $ idList = array_filter ( $ idList ) ; $ builder = $ this -> connection -> createQueryBuilder ( ) ; $ screens = $ builder -> select ( 'd.*' ) -> from ( 'tl_metamodel_dca' , 'd' ) -> leftJoin ( 'd' , 'tl_metamodel' , 'm' , 'm.id=d.pid' ) -> where ( $ builder -> expr ( ) -> in ( 'd.id' , ':idList' ) ) -> setParameter ( 'idList' , $ idList , Connection :: PARAM_STR_ARRAY ) -> orderBy ( 'm.sorting' ) -> execute ( ) -> fetchAll ( \ PDO :: FETCH_ASSOC ) ; $ result = [ ] ; $ keys = array_flip ( $ idList ) ; foreach ( $ screens as $ screen ) { $ metaModelName = $ keys [ $ screen [ 'id' ] ] ; $ result [ $ metaModelName ] = $ this -> prepareInputScreen ( $ metaModelName , $ screen ) ; } return $ result ; }
4503	public function replaceWith ( DOMNode $ replacement ) : void { $ this -> parentNode -> insertBefore ( $ replacement , $ this ) ; $ this -> remove ( ) ; }
11883	public function getTicketCacheKey ( ) { if ( is_null ( $ this -> ticketCacheKey ) ) { return $ this -> ticketCachePrefix . $ this -> getAccessToken ( ) -> getAppId ( ) ; } return $ this -> ticketCacheKey ; }
6114	public function version ( $ ident = null ) { if ( $ this -> version === null ) { $ this -> version = $ this -> request ( "version" ) -> toList ( ) ; } return ( $ ident && array_key_exists ( $ ident , $ this -> version ) ) ? $ this -> version [ $ ident ] : $ this -> version ; }
8920	protected function parseRelator ( & $ node , & $ out , $ default = null ) { $ relterm = $ node -> text ( 'marc:subfield[@code="e"]' ) ; $ relcode = $ node -> text ( 'marc:subfield[@code="4"]' ) ; if ( ! empty ( $ relcode ) ) { $ out [ 'role' ] = $ relcode ; } elseif ( ! empty ( $ relterm ) ) { $ out [ 'role' ] = $ relterm ; } elseif ( ! is_null ( $ default ) ) { $ out [ 'role' ] = $ default ; } }
1735	public function getProvisionUri ( User $ user , Request $ request ) : string { $ issuer = rawurlencode ( $ request -> getSchemeAndHttpHost ( ) ) ; return sprintf ( 'otpauth://totp/%s:%s?secret=%s&issuer=%s' , $ issuer , rawurlencode ( $ user -> getUsername ( ) ) . '@' . $ issuer , $ this -> getUpperUnpaddedSecretForUser ( $ user ) , $ issuer ) ; }
4829	public function cancel ( ) { $ endpoint = self :: $ endpoint . '/' . $ this -> id . '/cancel' ; return new self ( $ this -> client , $ this -> client -> request ( 'put' , $ endpoint ) ) ; }
10642	public function orWhere ( $ column , $ op , $ value , $ isParam = true ) { $ this -> clauses [ ] = array ( "OR" , $ column , $ op , $ value , $ isParam ) ; return $ this ; }
5874	public static function isAnimatedGif ( $ fileName ) { if ( ( $ fh = fopen ( $ fileName , 'rb' ) ) === false ) { throw new \ RuntimeException ( 'Can\'t open ' . $ fileName , 1454678600 ) ; } $ count = 0 ; while ( ! feof ( $ fh ) && $ count < 2 ) { $ chunk = fread ( $ fh , 1024 * 100 ) ; $ count += preg_match_all ( '#\x00\x21\xF9\x04.{4}\x00[\x2C\x21]#s' , $ chunk , $ matches ) ; } fclose ( $ fh ) ; return $ count > 1 ; }
11627	public function lock ( ) { $ lock_file = $ this -> getLockFile ( ) ; if ( file_exists ( $ lock_file ) ) { $ this -> pid = file_get_contents ( $ lock_file ) ; if ( $ this -> isrunning ( ) ) { error_log ( "==" . $ this -> pid . "== Already in progress..." ) ; return false ; } else error_log ( "==" . $ this -> pid . "== Previous job died abruptly..." ) ; } $ this -> pid = getmypid ( ) ; $ s = file_put_contents ( $ lock_file , $ this -> pid ) ; error_log ( "==" . $ this -> pid . "== Lock acquired, processing the job..." ) ; return $ this -> pid ; }
9001	public function column_user ( AbstractLog $ item ) { $ user = $ item -> get_user ( ) ; if ( empty ( $ user ) ) { echo '-' ; } else { echo $ user -> display_name ; } }
9352	public function cofactor ( ) { $ c = new self ( $ this -> size -> rows , $ this -> size -> cols ) ; for ( $ m = 0 ; $ m < $ this -> size -> rows ; $ m ++ ) { $ arr_row = array ( ) ; for ( $ n = 0 ; $ n < $ this -> size -> cols ; $ n ++ ) { if ( $ this -> size -> cols == 2 ) { $ arr_row [ ] = pow ( - 1 , $ m + $ n ) * $ this -> subMatrix ( $ m , $ n ) -> get ( 0 , 0 ) ; } else { $ arr_row [ ] = pow ( - 1 , $ m + $ n ) * $ this -> subMatrix ( $ m , $ n ) -> det ( ) ; } } $ c -> addRow ( $ arr_row ) ; } return $ c ; }
2590	public function setArrivalDate ( \ DateTime $ arrivalDate ) { $ this -> arrivalDate = ( $ arrivalDate -> format ( 'dmy' ) !== '000000' ) ? $ arrivalDate -> format ( 'dmy' ) : null ; $ time = $ arrivalDate -> format ( 'Hi' ) ; if ( $ time !== '0000' ) { $ this -> arrivalTime = $ time ; } }
5972	public function deployment ( ) { if ( ! $ this -> deployment instanceof DeploymentController ) { $ this -> deployment = new DeploymentController ( $ this -> getClient ( ) , $ this -> cachePolicy , $ this -> cache ) ; $ this -> deployment -> setLogger ( $ this -> logger ) ; } return $ this -> deployment ; }
8837	private function hasExceededTimeout ( ) : bool { return - 1 !== $ this -> timeout && ( microtime ( true ) - $ this -> startTime ) * 1000000 > $ this -> timeout ; }
10673	protected function _getCached ( $ key , $ default = null , $ ttl = null ) { try { return $ this -> _get ( $ key ) ; } catch ( NotFoundExceptionInterface $ e ) { if ( is_callable ( $ default ) ) { try { $ args = $ this -> _normalizeArray ( $ this -> _getGeneratorArgs ( $ key , $ default , $ ttl ) ) ; $ default = $ this -> _invokeCallable ( $ default , $ args ) ; } catch ( RootException $ e ) { throw $ this -> _createRuntimeException ( $ this -> __ ( 'Could not generate value' ) , null , $ e ) ; } } $ this -> _set ( $ key , $ default , $ ttl ) ; return $ default ; } }
8694	public static function parse ( $ size , $ fallbackUnits = null ) { preg_match ( '/^(\d+)[.,]?(\d*)\s*(\w*)$/' , $ size , $ matches ) ; if ( empty ( $ matches [ 1 ] ) || ( empty ( $ matches [ 3 ] ) && null === $ fallbackUnits ) ) { throw new \ UnexpectedValueException ( "Unable to parse : '{$size}'" ) ; } $ oSize = $ matches [ 1 ] ; if ( ! empty ( $ matches [ 2 ] ) ) { $ oSize .= '.' . $ matches [ 2 ] ; } $ oSize = ( float ) $ oSize ; $ unit = strtolower ( empty ( $ matches [ 3 ] ) ? $ fallbackUnits : $ matches [ 3 ] ) ; $ byteMultiplier = 1 ; if ( 'b' === substr ( $ unit , - 1 ) ) { $ byteMultiplier = 8 ; $ unit = substr ( $ unit , 0 , - 1 ) . 'o' ; } if ( ! array_key_exists ( $ unit , self :: getBinarySizes ( ) ) ) { throw new \ UnexpectedValueException ( "Unexpected unit {$unit}" ) ; } return ( int ) ( $ oSize * self :: getBinarySizes ( ) [ $ unit ] * $ byteMultiplier ) ; }
10051	private function resolveVisibleFields ( ) { $ result = [ ] ; $ columns = $ this -> model -> getColumns ( ) ; foreach ( $ columns as $ column ) { $ result [ ] = $ column -> getName ( ) ; } return $ result ; }
4433	public function createSubscriber ( array $ channels ) : WatchdogSubscriber { $ redis = clone $ this -> redis ; $ redis -> disconnect ( ) ; $ redis -> connect ( ) ; return new WatchdogSubscriber ( $ redis , $ channels ) ; }
1352	protected function notAllowed ( string $ resourceType , string $ fields ) : Collection { $ fields = collect ( explode ( ',' , $ fields ) ) ; if ( ! $ this -> allowed -> has ( $ resourceType ) ) { return $ fields ; } $ allowed = $ this -> allowed -> get ( $ resourceType ) ; if ( is_null ( $ allowed ) ) { return collect ( ) ; } $ allowed = collect ( ( array ) $ allowed ) ; return $ fields -> reject ( function ( $ value ) use ( $ allowed ) { return $ allowed -> contains ( $ value ) ; } ) ; }
12839	static public function generateFilename ( $ directory , $ extension , $ length = 16 ) { do { $ name = \ Extlib \ Generator :: generate ( $ length ) ; $ filepath = rtrim ( $ directory , DIRECTORY_SEPARATOR ) . DIRECTORY_SEPARATOR . sprintf ( '%s.%s' , $ name , $ extension ) ; } while ( file_exists ( $ filepath ) ) ; return $ name ; }
7200	protected function detachSaleItemRecursively ( SaleItemInterface $ item ) { $ this -> stockAssigner -> detachSaleItem ( $ item ) ; foreach ( $ item -> getChildren ( ) as $ child ) { $ this -> detachSaleItemRecursively ( $ child ) ; } }
11287	protected function _getCustomValue ( $ attributeName , $ query , $ loadMap = false ) { $ def = $ this -> model_attributes [ $ attributeName ] ; $ result = $ this -> _getRelation ( $ attributeName , $ query , $ loadMap ) ; if ( ! $ result ) { $ result = $ query -> fetch ( ) ; } return $ result ; }
12332	public function add ( $ key , $ object ) { if ( $ this -> repository -> containsKey ( $ key ) ) throw new ReferenceExistsException ( ) ; $ this -> repository -> set ( $ key , $ object ) ; }
242	public function run ( ) { $ rows = [ ] ; $ i = 0 ; foreach ( $ this -> attributes as $ attribute ) { $ rows [ ] = $ this -> renderAttribute ( $ attribute , $ i ++ ) ; } $ options = $ this -> options ; $ tag = ArrayHelper :: remove ( $ options , 'tag' , 'table' ) ; echo Html :: tag ( $ tag , implode ( "\n" , $ rows ) , $ options ) ; }
4368	public function & offsetGet ( $ key ) { if ( $ this -> hasValue ( $ key ) ) { return $ this -> values [ $ key ] ; } $ null = null ; return $ null ; }
4786	function offsetGet ( $ key ) { $ this -> access ( $ key ) ; if ( ! array_key_exists ( $ key , $ this -> row ) ) { $ this -> access ( $ key , true ) ; } return $ this -> row [ $ key ] ; }
2800	protected static function generateBeanCreationCode ( string $ padding , string $ beanId , string $ methodParams , BeanPostProcessorsProperty $ postProcessorsProperty ) : string { $ content = $ padding . '$instance = parent::' . $ beanId . '(' . $ methodParams . ');' . PHP_EOL ; $ content .= $ padding . 'if ($instance instanceof \\' . InitializedBean :: class . ') { ' . PHP_EOL ; $ content .= $ padding . ' $instance->postInitialization();' . PHP_EOL ; $ content .= $ padding . '}' . PHP_EOL ; $ content .= PHP_EOL ; $ content .= $ padding . 'foreach ($this->' . $ postProcessorsProperty -> getName ( ) . ' as $postProcessor) { ' . PHP_EOL ; $ content .= $ padding . ' $postProcessor->postProcess($instance, "' . $ beanId . '");' . PHP_EOL ; $ content .= $ padding . '}' . PHP_EOL ; return $ content ; }
6752	public static function getCallable ( Logger $ logger , $ type , $ maxMessageLength ) { return function ( MessageInterface $ message ) use ( $ logger , $ type , $ maxMessageLength ) { $ startMessage = null ; if ( $ message instanceof RequestInterface ) { $ startMessage = sprintf ( 'Proxy %s start: HTTP/%s %s %s' , $ type , $ message -> getProtocolVersion ( ) , $ message -> getMethod ( ) , $ message -> getRequestTarget ( ) ) ; } elseif ( $ message instanceof ResponseInterface ) { $ startMessage = sprintf ( 'Proxy %s start: HTTP/%s %s %s' , $ type , $ message -> getProtocolVersion ( ) , $ message -> getStatusCode ( ) , $ message -> getReasonPhrase ( ) ) ; } if ( ! is_null ( $ startMessage ) ) { $ logger -> log ( Logger :: INFO , $ startMessage ) ; } foreach ( $ message -> getHeaders ( ) as $ name => $ value ) { $ logger -> log ( Logger :: INFO , sprintf ( "Proxy %s header: %s => %s" , $ type , $ name , implode ( ', ' , $ value ) ) ) ; } $ body = $ message -> getBody ( ) ; if ( strlen ( $ body ) > $ maxMessageLength ) { $ body = substr ( $ body , 0 , $ maxMessageLength ) . '[TRUNCATED]' ; } $ logger -> log ( Logger :: INFO , sprintf ( "Proxy %s body: %s" , $ type , $ body ) ) ; if ( ! is_null ( $ message ) && $ message -> getBody ( ) -> isSeekable ( ) ) { $ message -> getBody ( ) -> rewind ( ) ; } return $ message ; } ; }
11063	public function getRealEncoding ( $ encoding ) { if ( static :: isEncodingSupported ( $ encoding ) === false ) { throw new \ Exception ( 'Encoding is not supported: "' . $ encoding . '"' ) ; } return static :: supportedEncodings ( ) [ strtolower ( $ encoding ) ] ; }
3575	public function forget ( $ key ) { if ( $ attribute = $ this -> get ( $ key ) ) { $ attribute -> setValue ( null ) ; } return $ this ; }
6428	protected function getFacebookObject ( ) { if ( is_object ( $ this -> fb ) ) { return $ this -> fb ; } $ fb = new \ Facebook \ Facebook ( [ 'app_id' => $ this -> options [ 'api_key' ] , 'app_secret' => $ this -> options [ 'secret_key' ] , 'default_graph_version' => 'v3.0' , ] ) ; $ this -> fb = $ fb ; return $ fb ; }
9194	public function addChild ( ModelInterface $ child , $ captureTo = null , $ append = null ) { parent :: addChild ( $ child , $ captureTo , $ append ) ; if ( $ child instanceof ThemeDefaultInterface ) { $ child -> parent = $ this ; } return $ this ; }
10848	protected function getTableName ( $ returnAlias = false ) { $ result = '' ; foreach ( $ this -> clause_table as $ k => $ v ) { if ( ! is_int ( $ k ) && $ returnAlias ) { return $ k ; } else { return $ v ; } } return $ result ; }
2466	protected function welcomeScreen ( ) { System :: loadLanguageFile ( 'explain' ) ; $ objTemplate = new BackendTemplate ( 'be_welcome' ) ; $ objTemplate -> messages = Message :: generateUnwrapped ( ) . Backend :: getSystemMessages ( ) ; $ objTemplate -> loginMsg = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'firstLogin' ] ; if ( $ this -> User -> lastLogin > 0 ) { $ formatter = new DateTimeFormatter ( System :: getContainer ( ) -> get ( 'translator' ) ) ; $ diff = $ formatter -> formatDiff ( new \ DateTime ( date ( 'Y-m-d H:i:s' , $ this -> User -> lastLogin ) ) , new \ DateTime ( ) ) ; $ objTemplate -> loginMsg = sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'lastLogin' ] [ 1 ] , '<time title="' . Date :: parse ( Config :: get ( 'datimFormat' ) , $ this -> User -> lastLogin ) . '">' . $ diff . '</time>' ) ; } Versions :: addToTemplate ( $ objTemplate ) ; $ objTemplate -> showDifferences = StringUtil :: specialchars ( str_replace ( "'" , "\\'" , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'showDifferences' ] ) ) ; $ objTemplate -> recordOfTable = StringUtil :: specialchars ( str_replace ( "'" , "\\'" , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'recordOfTable' ] ) ) ; $ objTemplate -> systemMessages = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'systemMessages' ] ; $ objTemplate -> shortcuts = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'shortcuts' ] [ 0 ] ; $ objTemplate -> shortcutsLink = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'shortcuts' ] [ 1 ] ; $ objTemplate -> editElement = StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'editElement' ] ) ; return $ objTemplate -> parse ( ) ; }
5073	private function createController ( ) : void { $ aFields = $ this -> getArguments ( ) ; $ aCreated = [ ] ; try { $ aModels = array_filter ( explode ( ',' , $ aFields [ 'MODEL_NAME' ] ) ) ; foreach ( $ aModels as $ sModel ) { $ aFields [ 'MODEL_NAME' ] = $ sModel ; $ this -> oOutput -> write ( 'Creating controller <comment>' . $ sModel . '</comment>... ' ) ; Factory :: model ( $ sModel , $ aFields [ 'MODEL_PROVIDER' ] ) ; $ sPath = static :: CONTROLLER_PATH . $ sModel . '.php' ; if ( file_exists ( $ sPath ) ) { throw new ControllerExistsException ( 'Controller "' . $ sModel . '" exists already at path "' . $ sPath . '"' ) ; } $ this -> createFile ( $ sPath , $ this -> getResource ( 'template/controller.php' , $ aFields ) ) ; $ aCreated [ ] = $ sPath ; $ this -> oOutput -> writeln ( '<info>done!</info>' ) ; } } catch ( \ Exception $ e ) { $ this -> oOutput -> writeln ( '<error>failed!</error>' ) ; if ( ! empty ( $ aCreated ) ) { $ this -> oOutput -> writeln ( '<error>Cleaning up - removing newly created controllers</error>' ) ; foreach ( $ aCreated as $ sPath ) { @ unlink ( $ sPath ) ; } } throw $ e ; } }
7733	public function onKernelView ( GetResponseForControllerResultEvent $ event ) { $ request = $ event -> getRequest ( ) ; $ result = $ event -> getControllerResult ( ) ; if ( ! $ request -> attributes -> get ( '__hydra_serialize' ) ) { return ; } if ( is_array ( $ result ) || ( $ result instanceof \ ArrayAccess ) || ( $ result instanceof \ Traversable ) ) { $ result = new Collection ( $ request -> getUri ( ) , $ result ) ; } elseif ( null === $ result ) { $ event -> setResponse ( new JsonLdResponse ( '' , 200 ) ) ; return ; } elseif ( ! is_object ( $ result ) ) { throw new \ Exception ( "A Hydra controller must return either an array or an object, got a(n) " . gettype ( $ result ) ) ; } $ serialized = $ this -> serializer -> serialize ( $ result , 'jsonld' ) ; $ event -> setResponse ( new JsonLdResponse ( $ serialized ) ) ; }
6798	public function install ( $ country = 'US' , $ currency = 'USD' ) { $ this -> installCountries ( $ country ) ; $ this -> installCurrencies ( $ currency ) ; $ this -> installTaxes ( $ country ) ; $ this -> installTaxGroups ( $ country ) ; $ this -> installTaxRules ( $ country ) ; $ this -> installCustomerGroups ( ) ; }
12442	public function detach ( $ key ) { if ( isset ( $ this -> instances [ $ key ] ) ) { unset ( $ this -> instances [ $ key ] ) ; } return $ this ; }
8451	public function setProfilePhoto ( $ mediaUri ) { $ processedMedia = $ this -> processMediaUri ( $ mediaUri ) ; if ( ! $ processedMedia ) { return false ; } $ result = $ this -> exec ( 'set_profile_photo ' . $ processedMedia [ 'filepath' ] ) ; $ this -> cleanUpMedia ( $ processedMedia ) ; return $ result ; }
7160	public function buildSaleView ( Model \ SaleInterface $ sale , array $ options = [ ] ) { $ this -> initialize ( $ sale , $ options ) ; $ this -> amountCalculator -> calculateSale ( $ sale ) ; $ grossResult = $ sale -> getGrossResult ( ) ; $ this -> view -> setGross ( new TotalView ( $ this -> formatter -> currency ( $ grossResult -> getGross ( $ this -> view -> isAti ( ) ) ) , $ this -> formatter -> currency ( $ grossResult -> getDiscount ( $ this -> view -> isAti ( ) ) ) , $ this -> formatter -> currency ( $ grossResult -> getBase ( $ this -> view -> isAti ( ) ) ) ) ) ; $ finalResult = $ sale -> getFinalResult ( ) ; $ this -> view -> setFinal ( new TotalView ( $ this -> formatter -> currency ( $ finalResult -> getBase ( ) ) , $ this -> formatter -> currency ( $ finalResult -> getTax ( ) ) , $ this -> formatter -> currency ( $ finalResult -> getTotal ( ) ) ) ) ; if ( $ this -> options [ 'private' ] && null !== $ margin = $ this -> marginCalculator -> calculateSale ( $ sale ) ) { $ prefix = $ margin -> isAverage ( ) ? '~' : '' ; $ this -> view -> setMargin ( new MarginView ( $ prefix . $ this -> formatter -> currency ( $ margin -> getAmount ( ) ) , $ prefix . $ this -> formatter -> percent ( $ margin -> getPercent ( ) ) ) ) ; $ this -> view -> vars [ 'show_margin' ] = true ; } $ this -> buildSaleItemsLinesViews ( $ sale ) ; $ this -> buildSaleDiscountsLinesViews ( $ sale ) ; $ this -> buildShipmentLine ( $ sale ) ; $ this -> buildSaleTaxesViews ( $ sale ) ; foreach ( $ this -> types as $ type ) { $ type -> buildSaleView ( $ sale , $ this -> view , $ this -> options ) ; } $ columnsCount = 6 ; if ( $ this -> view -> vars [ 'show_availability' ] ) { $ columnsCount ++ ; } if ( $ this -> view -> vars [ 'show_discounts' ] = 0 < count ( $ grossResult -> getDiscountAdjustments ( ) ) ) { $ columnsCount += 3 ; } if ( $ this -> view -> vars [ 'show_taxes' ] = 1 < count ( $ finalResult -> getTaxAdjustments ( ) ) ) { $ columnsCount ++ ; } if ( $ this -> view -> vars [ 'show_margin' ] ) { $ columnsCount ++ ; } if ( $ this -> options [ 'editable' ] ) { $ columnsCount ++ ; } $ this -> view -> vars [ 'columns_count' ] = $ columnsCount ; return $ this -> view ; }
6412	public static function all ( IteratorAggregate $ iterable , callable $ predicate ) : bool { return Iterators :: all ( Iterators :: from ( $ iterable -> getIterator ( ) ) , $ predicate ) ; }
2469	public function mapContentBlock ( Content $ content ) { $ contentInfo = $ content -> versionInfo -> contentInfo ; $ locations = $ this -> locationHandler -> loadLocationsByContent ( $ contentInfo -> id ) ; $ blockFields = $ this -> getBlockFields ( $ content ) ; $ contentFields = $ this -> getContentFields ( $ content ) ; $ documents = [ ] ; $ locationFieldsMap = [ ] ; foreach ( $ locations as $ location ) { $ locationFieldsMap [ $ location -> id ] = $ this -> getLocationFields ( $ location ) ; } foreach ( array_keys ( $ content -> versionInfo -> names ) as $ languageCode ) { $ blockTranslationFields = $ this -> getBlockTranslationFields ( $ content , $ languageCode ) ; $ translationLocationDocuments = array ( ) ; foreach ( $ locations as $ location ) { $ translationLocationDocuments [ ] = new Document ( array ( 'id' => $ this -> generateLocationDocumentId ( $ location -> id , $ languageCode ) , 'fields' => array_merge ( $ blockFields , $ locationFieldsMap [ $ location -> id ] , $ blockTranslationFields ) , ) ) ; } $ isMainTranslation = ( $ contentInfo -> mainLanguageCode === $ languageCode ) ; $ alwaysAvailable = ( $ isMainTranslation && $ contentInfo -> alwaysAvailable ) ; $ contentTranslationFields = $ this -> getContentTranslationFields ( $ content , $ languageCode ) ; $ documents [ ] = new Document ( array ( 'id' => $ this -> generateContentDocumentId ( $ contentInfo -> id , $ languageCode ) , 'languageCode' => $ languageCode , 'alwaysAvailable' => $ alwaysAvailable , 'isMainTranslation' => $ isMainTranslation , 'fields' => array_merge ( $ blockFields , $ contentFields , $ blockTranslationFields , $ contentTranslationFields ) , 'documents' => $ translationLocationDocuments , ) ) ; } return $ documents ; }
3890	protected function buildFilterParamsFor ( \ DC_Table $ dataContainer , $ elementName ) { if ( ! $ this -> requestStack -> getCurrentRequest ( ) -> query -> get ( 'act' ) ) { return ; } $ filterId = $ this -> connection -> createQueryBuilder ( ) -> select ( 'c.metamodel_filtering' ) -> from ( static :: $ tableName , 'c' ) -> join ( 'c' , 'tl_metamodel' , 'mm' , 'mm.id=c.metamodel' ) -> where ( 'c.id=:id' ) -> setParameter ( 'id' , $ dataContainer -> id ) -> andWhere ( 'c.type=:type' ) -> setParameter ( 'type' , $ elementName ) -> setMaxResults ( 1 ) -> execute ( ) -> fetch ( \ PDO :: FETCH_COLUMN ) ; if ( ! $ filterId ) { unset ( $ GLOBALS [ 'TL_DCA' ] [ static :: $ tableName ] [ 'fields' ] [ 'metamodel_filterparams' ] ) ; return ; } $ collection = $ this -> filterFactory -> createCollection ( $ filterId ) ; $ dca = $ collection -> getParameterDCA ( ) ; foreach ( $ dca as $ fieldName => $ subField ) { $ options = [ ] ; foreach ( $ subField [ 'options' ] as $ key => $ value ) { $ options [ $ this -> loadCallback ( $ key ) ] = $ value ; } $ dca [ $ fieldName ] [ 'options' ] = $ options ; $ dca [ $ fieldName ] [ 'save_callback' ] [ ] = [ static :: class , 'saveCallback' ] ; $ dca [ $ fieldName ] [ 'load_callback' ] [ ] = [ static :: class , 'loadCallback' ] ; } $ GLOBALS [ 'TL_DCA' ] [ static :: $ tableName ] [ 'fields' ] [ 'metamodel_filterparams' ] [ 'eval' ] [ 'subfields' ] = $ dca ; }
5551	public function getMimeType ( ) { if ( is_integer ( $ this -> focus ) ) { return $ this -> frames [ $ this -> focus ] -> getMimeType ( ) ; } return $ this -> frameset -> getMimeType ( ) ; }
3866	private function getOrCreateBasicDefinition ( IMetaModelDataDefinition $ container ) { if ( $ container -> hasBasicDefinition ( ) ) { return $ container -> getBasicDefinition ( ) ; } $ config = new DefaultBasicDefinition ( ) ; $ container -> setBasicDefinition ( $ config ) ; return $ config ; }
789	public function getFirstError ( $ attribute ) { return isset ( $ this -> _errors [ $ attribute ] ) ? reset ( $ this -> _errors [ $ attribute ] ) : null ; }
9875	private function writeLegacyDrawingHF ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { if ( count ( $ pSheet -> getHeaderFooter ( ) -> getImages ( ) ) > 0 ) { $ objWriter -> startElement ( 'legacyDrawingHF' ) ; $ objWriter -> writeAttribute ( 'r:id' , 'rId_headerfooter_vml1' ) ; $ objWriter -> endElement ( ) ; } }
6142	public function checkPath ( $ path = null ) { if ( $ path === null ) { $ path = $ this -> path ; } if ( strlen ( $ path ) == 0 ) { return true ; } $ pattern = "/^" . $ this -> regex [ "path" ] . "$/" ; $ status = @ preg_match ( $ pattern , $ path ) ; if ( $ status === false ) { throw new Ts3Exception ( "URI path validation failed" ) ; } return ( $ status == 1 ) ; }
1612	private function _setCriteriaIdByType ( $ criteria , Element $ type , $ id ) { switch ( $ type :: className ( ) ) { case 'Entry' : $ criteria -> sectionId = $ id ; break ; case 'Category' : $ criteria -> groupId = $ id ; break ; } }
2040	private function createConfigItem ( $ imageSize ) : PictureConfigurationItem { $ configItem = new PictureConfigurationItem ( ) ; $ resizeConfig = new ResizeConfiguration ( ) ; if ( null !== $ imageSize ) { $ resizeConfig -> setWidth ( $ imageSize -> width ) -> setHeight ( $ imageSize -> height ) -> setMode ( $ imageSize -> resizeMode ) -> setZoomLevel ( $ imageSize -> zoom ) ; $ configItem -> setResizeConfig ( $ resizeConfig ) -> setSizes ( $ imageSize -> sizes ) -> setDensities ( $ imageSize -> densities ) ; if ( isset ( $ imageSize -> media ) ) { $ configItem -> setMedia ( $ imageSize -> media ) ; } } return $ configItem ; }
6449	private function compareAcceptLanguageHeaders ( AcceptLanguageHeaderValue $ a , AcceptLanguageHeaderValue $ b ) : int { $ aQuality = $ a -> getQuality ( ) ; $ bQuality = $ b -> getQuality ( ) ; if ( $ aQuality < $ bQuality ) { return 1 ; } if ( $ aQuality > $ bQuality ) { return - 1 ; } $ aValue = $ a -> getLanguage ( ) ; $ bValue = $ b -> getLanguage ( ) ; if ( $ aValue === '*' ) { if ( $ bValue === '*' ) { return 0 ; } return 1 ; } if ( $ bValue === '*' ) { return - 1 ; } return 0 ; }
8593	public function listOrders ( $ request ) { if ( ! ( $ request instanceof MarketplaceWebServiceOrders_Model_ListOrdersRequest ) ) { $ request = new MarketplaceWebServiceOrders_Model_ListOrdersRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListOrders' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = MarketplaceWebServiceOrders_Model_ListOrdersResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
12033	function addDispatchAsyncMethod ( ) { $ methodGenerator = new MethodGenerator ( 'dispatchAsync' ) ; $ body = 'return $this->api->executeAsync($request, $this, $callable);' ; $ docBlock = $ this -> generateExecuteDocBlock ( 'Dispatch the request for this operation and process the response asynchronously. Allows you to modify the request before it is sent.' ) ; $ requestParameter = new ParameterGenerator ( 'request' , 'Amp\Artax\Request' ) ; $ methodGenerator -> setParameter ( $ requestParameter ) ; $ tag = createParamTag ( $ requestParameter , 'The request to be processed' ) ; $ docBlock -> setTag ( $ tag ) ; $ callableParameter = new ParameterGenerator ( 'callable' , 'callable' ) ; $ methodGenerator -> setParameter ( $ callableParameter ) ; $ callableTag = createParamTag ( $ callableParameter , 'The callable that processes the response' ) ; $ docBlock -> setTag ( $ callableTag ) ; $ methodGenerator -> setDocBlock ( $ docBlock ) ; $ methodGenerator -> setBody ( $ body ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; }
10574	public function remove ( $ key ) { $ this -> open ( ) ; if ( isset ( $ _SESSION [ $ key ] ) ) { $ value = $ _SESSION [ $ key ] ; unset ( $ _SESSION [ $ key ] ) ; return $ value ; } else { return null ; } }
3901	public function createColumn ( ) { if ( $ this -> getColName ( ) ) { $ this -> tableManipulator -> createColumn ( $ this -> getMetaModel ( ) -> getTableName ( ) , $ this -> getColName ( ) , $ this -> getSQLDataType ( ) ) ; } }
1474	public function createResourceValidator ( ResourceObject $ resource , array $ rules , array $ messages = [ ] , array $ customAttributes = [ ] ) { return $ this -> createValidator ( $ resource -> all ( ) , $ rules , $ messages , $ customAttributes , function ( $ key , $ detail , $ failed ) use ( $ resource ) { return $ this -> invalidResource ( $ resource -> pointer ( $ key , '/data' ) , $ detail , $ failed ) ; } ) ; }
5816	public function onAfterWrite ( ) { parent :: onAfterWrite ( ) ; $ types = unserialize ( $ this -> TagTypes ) ; $ changed = $ this -> getChangedFields ( ) ; foreach ( $ this -> service -> getFusionTagTypes ( ) as $ type => $ field ) { if ( isset ( $ types [ $ type ] ) ) { $ newTypes = array ( ) ; if ( isset ( $ changed [ 'TagTypes' ] ) ) { $ before = unserialize ( $ changed [ 'TagTypes' ] [ 'before' ] ) ; $ after = unserialize ( $ changed [ 'TagTypes' ] [ 'after' ] ) ; $ newTypes = is_array ( $ before ) ? array_diff ( $ after , $ before ) : $ after ; } if ( ( isset ( $ changed [ 'ID' ] ) || isset ( $ newTypes [ $ type ] ) ) && ! ( $ type :: get ( ) -> filter ( $ field , $ this -> Title ) -> first ( ) ) ) { $ tag = $ type :: create ( ) ; $ tag -> $ field = $ this -> Title ; $ tag -> FusionTagID = $ this -> ID ; $ tag -> write ( ) ; } else if ( ! isset ( $ changed [ 'ID' ] ) && isset ( $ changed [ 'Title' ] ) && ( $ existing = $ type :: get ( ) -> filter ( $ field , $ changed [ 'Title' ] [ 'before' ] ) ) ) { foreach ( $ existing as $ tag ) { $ tag -> $ field = $ changed [ 'Title' ] [ 'after' ] ; $ tag -> write ( ) ; } } } } if ( ! isset ( $ changed [ 'ID' ] ) && isset ( $ changed [ 'Title' ] ) ) { $ this -> service -> updateTagging ( $ this -> ID ) ; } }
8620	public function parse ( ) { $ handle = fopen ( $ this -> source_file , 'r' ) ; $ currentBlock = null ; while ( ! feof ( $ handle ) ) { $ line = fgets ( $ handle ) ; if ( preg_match ( "/^msgid (.*?)$/us" , $ line , $ match ) ) { $ currentBlock = $ match [ 1 ] == '""' ? new HeaderBlock ( ) : new Block ( ) ; rewind ( $ handle ) ; break ; } } while ( ! feof ( $ handle ) ) { $ line = fgets ( $ handle ) ; if ( trim ( $ line ) == '' ) { if ( $ currentBlock ) { $ this -> addBlock ( $ currentBlock ) ; $ currentBlock = new Block ( ) ; } } else { $ currentBlock -> process ( $ line ) ; } } fclose ( $ handle ) ; if ( $ currentBlock && $ currentBlock -> isInitialized ( ) ) { $ this -> addBlock ( $ currentBlock ) ; } }
731	protected function getUniqueIndexInformation ( $ table ) { $ sql = <<<'SQL'SELECT i.relname as indexname, pg_get_indexdef(idx.indexrelid, k + 1, TRUE) AS columnnameFROM ( SELECT *, generate_subscripts(indkey, 1) AS k FROM pg_index) idxINNER JOIN pg_class i ON i.oid = idx.indexrelidINNER JOIN pg_class c ON c.oid = idx.indrelidINNER JOIN pg_namespace ns ON c.relnamespace = ns.oidWHERE idx.indisprimary = FALSE AND idx.indisunique = TRUEAND c.relname = :tableName AND ns.nspname = :schemaNameORDER BY i.relname, kSQL ; return $ this -> db -> createCommand ( $ sql , [ ':schemaName' => $ table -> schemaName , ':tableName' => $ table -> name , ] ) -> queryAll ( ) ; }
4671	public function addBlockToBody ( $ block ) { $ this -> body = array_merge ( $ this -> body , explode ( PHP_EOL , $ block ) ) ; }
10931	function countRowsWith ( string $ tablename , string $ colName , $ colValue ) : int { $ strSQL = "SELECT COUNT($colName) as count FROM $tablename WHERE $colName=:$colName;" ; return $ this -> getCountOf ( $ strSQL , [ "$colName" => $ colValue ] ) ; }
9365	public function multiply ( $ z ) { if ( is_numeric ( $ z ) ) { $ z = new self ( $ z , 0 ) ; } return new self ( ( $ this -> float_r * $ z -> re ) - ( $ this -> float_i * $ z -> im ) , ( $ this -> float_r * $ z -> im ) + ( $ z -> re * $ this -> float_i ) ) ; }
7940	public function setBackupFTPaccessBlock ( $ domain , $ ipBlock , $ ftp , $ nfs , $ cifs ) { $ domain = ( string ) $ domain ; if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; if ( ! $ ipBlock ) throw new BadMethodCallException ( 'Parameter $ipBlock is missing.' ) ; if ( ! $ ftp ) throw new BadMethodCallException ( 'Parameter $ftp is missing.' ) ; if ( ! $ nfs ) throw new BadMethodCallException ( 'Parameter $nfs is missing.' ) ; if ( ! $ cifs ) throw new BadMethodCallException ( 'Parameter $cifs is missing.' ) ; $ payload = array ( 'ftp' => ( $ ftp == 'on' ) , 'nfs' => ( $ nfs == 'on' ) , 'cifs' => ( $ cifs == 'on' ) ) ; try { $ r = $ this -> put ( 'dedicated/server/' . $ domain . '/features/backupFTP/access/' . urlencode ( $ ipBlock ) , array ( 'Content-Type' => 'application/json;charset=UTF-8' ) , json_encode ( $ payload ) ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new ServerException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
444	public function trigger ( $ name , Event $ event = null ) { $ this -> ensureBehaviors ( ) ; $ eventHandlers = [ ] ; foreach ( $ this -> _eventWildcards as $ wildcard => $ handlers ) { if ( StringHelper :: matchWildcard ( $ wildcard , $ name ) ) { $ eventHandlers = array_merge ( $ eventHandlers , $ handlers ) ; } } if ( ! empty ( $ this -> _events [ $ name ] ) ) { $ eventHandlers = array_merge ( $ eventHandlers , $ this -> _events [ $ name ] ) ; } if ( ! empty ( $ eventHandlers ) ) { if ( $ event === null ) { $ event = new Event ( ) ; } if ( $ event -> sender === null ) { $ event -> sender = $ this ; } $ event -> handled = false ; $ event -> name = $ name ; foreach ( $ eventHandlers as $ handler ) { $ event -> data = $ handler [ 1 ] ; call_user_func ( $ handler [ 0 ] , $ event ) ; if ( $ event -> handled ) { return ; } } } Event :: trigger ( $ this , $ name , $ event ) ; }
9383	public function getClassName ( $ identifier , $ args = [ ] ) { if ( isset ( $ this -> classes [ $ identifier ] ) ) { return $ args ? vsprintf ( $ this -> classes [ $ identifier ] , $ args ) : $ this -> classes [ $ identifier ] ; } }
12068	public function fetchProject ( Project $ project ) { $ response = $ this -> getResponse ( 'get' , sprintf ( 'v2/projects/%s' , $ project -> getProjectKey ( ) ) ) ; return $ this -> hydrator -> hydrate ( $ project , $ response ) ; }
4491	public function registerDeviceOnTopic ( string $ deviceArn , string $ topicArn ) { $ this -> sns -> subscribe ( [ 'TopicArn' => $ topicArn , 'Protocol' => 'application' , 'Endpoint' => $ deviceArn , ] ) ; }
2779	public function git ( string $ commandLine , ? string $ cwd = null ) : string { $ command = new GitCommand ( $ commandLine ) ; $ command -> executeRaw ( is_string ( $ commandLine ) ) ; $ command -> setDirectory ( $ cwd ) ; return $ this -> run ( $ command ) ; }
17	public function getLockedRepository ( $ withDevReqs = false ) { $ lockData = $ this -> getLockData ( ) ; $ packages = new ArrayRepository ( ) ; $ lockedPackages = $ lockData [ 'packages' ] ; if ( $ withDevReqs ) { if ( isset ( $ lockData [ 'packages-dev' ] ) ) { $ lockedPackages = array_merge ( $ lockedPackages , $ lockData [ 'packages-dev' ] ) ; } else { throw new \ RuntimeException ( 'The lock file does not contain require-dev information, run install with the --no-dev option or run update to install those packages.' ) ; } } if ( empty ( $ lockedPackages ) ) { return $ packages ; } if ( isset ( $ lockedPackages [ 0 ] [ 'name' ] ) ) { foreach ( $ lockedPackages as $ info ) { $ packages -> addPackage ( $ this -> loader -> load ( $ info ) ) ; } return $ packages ; } throw new \ RuntimeException ( 'Your composer.lock was created before 2012-09-15, and is not supported anymore. Run "composer update" to generate a new one.' ) ; }
5472	private function getPrivatePropertyNoMatterWhat ( $ name , $ object ) { foreach ( ( array ) $ object as $ mangled_name => $ value ) { if ( $ this -> unmangle ( $ mangled_name ) == $ name ) { return $ value ; } } }
4477	public function untrack ( ) : void { if ( $ this -> client -> call ( 'track' , 'untrack' , $ this -> jid ) ) { $ this -> tracked = false ; } }
5357	protected function createQueryParamStatements ( Operation $ operation ) { $ queryParamDocumentation = [ ] ; $ queryParamVariable = new Expr \ Variable ( 'queryParam' ) ; $ queryParamStatements = [ new Expr \ Assign ( $ queryParamVariable , new Expr \ New_ ( new Name ( 'QueryParam' ) ) ) ] ; if ( $ operation -> getOperation ( ) -> getParameters ( ) ) { foreach ( $ operation -> getOperation ( ) -> getParameters ( ) as $ parameter ) { if ( $ parameter instanceof Reference ) { $ parameter = $ this -> resolveParameter ( $ parameter ) ; } if ( $ parameter instanceof FormDataParameterSubSchema ) { $ queryParamStatements = array_merge ( $ queryParamStatements , $ this -> formDataParameterGenerator -> generateQueryParamStatements ( $ parameter , $ queryParamVariable ) ) ; $ queryParamDocumentation [ ] = $ this -> formDataParameterGenerator -> generateQueryDocParameter ( $ parameter ) ; } if ( $ parameter instanceof HeaderParameterSubSchema ) { $ queryParamStatements = array_merge ( $ queryParamStatements , $ this -> headerParameterGenerator -> generateQueryParamStatements ( $ parameter , $ queryParamVariable ) ) ; $ queryParamDocumentation [ ] = $ this -> headerParameterGenerator -> generateQueryDocParameter ( $ parameter ) ; } if ( $ parameter instanceof QueryParameterSubSchema ) { $ queryParamStatements = array_merge ( $ queryParamStatements , $ this -> queryParameterGenerator -> generateQueryParamStatements ( $ parameter , $ queryParamVariable ) ) ; $ queryParamDocumentation [ ] = $ this -> queryParameterGenerator -> generateQueryDocParameter ( $ parameter ) ; } } } return [ $ queryParamDocumentation , $ queryParamStatements , $ queryParamVariable ] ; }
10771	public function registerMediaType ( $ mediaType ) { if ( $ this -> check ( $ mediaType ) ) { $ this -> mediaTypes [ ( new \ ReflectionClass ( $ mediaType ) ) -> getConstant ( 'NAME' ) ] = $ mediaType ; return $ this ; } else { throw new \ Exception ( 'registered MediaType must implement \MandarinMedien\MMMediaBundle\Model\MediaTypeInterface' ) ; } }
6403	public function isValid ( ) { if ( $ this -> getFromDay ( ) == null || $ this -> getFromHour ( ) == null || $ this -> getToDay ( ) == null || $ this -> getToHour ( ) == null ) { return false ; } if ( $ this -> getFromDay ( ) < 1 || $ this -> getFromDay ( ) > 31 ) { return false ; } if ( $ this -> getToDay ( ) < 1 || $ this -> getToDay ( ) > 31 ) { return false ; } if ( $ this -> getFromHour ( ) > 24 || $ this -> getToHour ( ) > 24 ) { return false ; } if ( $ this -> getFromDay ( ) == $ this -> getToDay ( ) && $ this -> getFromHour ( ) >= $ this -> getToHour ( ) ) { return false ; } return true ; }
11237	public function saveUrl ( $ url = false , $ append = '' ) { if ( $ url == false ) { $ url = '//' . $ this -> config [ 'base_url' ] . $ _SERVER [ 'REQUEST_URI' ] ; } $ this -> saved = $ this -> getRedirect ( $ url ) . $ append ; $ this -> session -> savedUrl = $ this -> saved ; }
2476	private function logWarning ( OutputInterface $ output , ProgressBar $ progress , $ message ) { $ progress -> clear ( ) ; $ this -> logger -> warning ( $ message ) ; $ progress -> display ( ) ; }
10631	public static function avgload ( ) { $ avgload = new \ StdClass ( ) ; if ( false !== ( $ data = @ file ( '/proc/loadavg' ) ) ) { $ data = explode ( " " , implode ( "" , $ data ) ) ; $ data = array_chunk ( $ data , 4 ) ; $ avgload -> min1 = $ data [ 0 ] [ 0 ] ; $ avgload -> min5 = $ data [ 0 ] [ 1 ] ; $ avgload -> min15 = $ data [ 0 ] [ 2 ] ; $ fourth = explode ( '/' , $ data [ 0 ] [ 3 ] ) ; $ avgload -> running = $ fourth [ 0 ] ; $ avgload -> exists = $ fourth [ 1 ] ; $ avgload -> recentPID = $ data [ 1 ] [ 0 ] ; } return $ avgload ; }
4888	public function gotoAction ( Request $ r ) { return $ this -> redirect ( $ this -> get ( 'zicht_url.provider' ) -> url ( $ this -> getPageManager ( ) -> findForView ( $ r -> get ( 'id' ) ) ) ) ; }
11692	private function buildParsedRequests ( ApiParseResult $ parseResult ) : array { $ requests = [ ] ; foreach ( $ parseResult -> getApi ( ) -> getResourceGroups ( ) as $ apiResourceGroup ) { foreach ( $ apiResourceGroup -> getResources ( ) as $ apiResource ) { foreach ( $ apiResource -> getTransitions ( ) as $ apiStateTransition ) { foreach ( $ apiStateTransition -> getHttpTransactions ( ) as $ apiHttpTransaction ) { $ this -> processApiHttpTransactions ( $ apiHttpTransaction , $ apiResourceGroup , $ apiResource , $ apiStateTransition , $ requests ) ; } } } } return $ requests ; }
1928	protected function validator ( $ varInput ) { foreach ( $ varInput as $ k => $ v ) { if ( $ k != 'unit' ) { $ varInput [ $ k ] = parent :: validator ( $ v ) ; } } return $ varInput ; }
2050	public function findBy ( $ strColumn , $ varValue ) { if ( parent :: findBy ( $ strColumn , $ varValue ) === false ) { return false ; } $ this -> arrGroups = $ this -> groups ; return true ; }
9465	public function getSummary ( ) { $ string = "---\n" ; foreach ( $ this -> getWords ( ) as $ k => $ v ) { $ string .= '[' . $ k . ']: Docs:' . $ v [ 'docs' ] . ' | Hits:' . $ v [ 'hits' ] . "\n" ; } return $ string ; }
5519	protected function emulateCall ( $ method , $ args , $ step ) { return $ this -> actions -> respond ( $ step , $ method , $ args ) ; }
3636	public function rpcMiddles ( Request $ request ) : array { $ beanName = 'serviceDispatcher' ; if ( ! \ Swoft :: hasBean ( $ beanName ) ) { return [ ] ; } $ dispatcher = \ bean ( $ beanName ) ; $ middleType = ( int ) $ request -> query ( 'type' ) ; if ( $ middleType === 1 ) { return $ dispatcher -> getMiddlewares ( ) ; } return $ dispatcher -> requestMiddleware ( ) ; }
6385	public function readCourse ( $ id ) { if ( $ id == 0 ) { $ courses = $ this -> store -> get_records ( 'course' , array ( ) ) ; $ id = key ( $ courses ) ; } $ model = $ this -> readObject ( $ id , 'course' ) ; $ model -> url = $ this -> cfg -> wwwroot . ( $ id > 0 ? '/course/view.php?id=' . $ id : '' ) ; return $ model ; }
1154	public function makeReplacements ( $ message , $ attribute , $ rule , $ parameters ) { if ( is_object ( $ rule ) ) { $ rule = get_class ( $ rule ) ; } return $ this -> callValidator ( 'makeReplacements' , [ $ message , $ attribute , $ rule , $ parameters ] ) ; }
7533	function setInnerText ( $ text , $ parser = null ) { $ this -> clear ( ) ; if ( trim ( $ text ) ) { if ( $ parser === null ) { $ parser = new $ this -> parserClass ( ) ; } $ parser -> root = & $ this ; $ parser -> setDoc ( $ text ) ; $ parser -> parse_all ( ) ; } return ( ( $ parser && $ parser -> errors ) ? $ parser -> errors : true ) ; }
8931	private function addRoute ( $ method ) { switch ( $ method ) { case 'index' : $ methodMap = [ 'GET' ] ; $ realRoute = '$route' ; $ controllerCallable = $ this -> controllerLocation . ':indexAction' ; break ; case 'get' : $ methodMap = [ 'GET' ] ; $ realRoute = '$route/{id}' ; $ controllerCallable = $ this -> controllerLocation . ':getAction' ; break ; case 'post' : $ methodMap = [ 'POST' ] ; $ realRoute = '$route' ; $ controllerCallable = $ this -> controllerLocation . ':postAction' ; break ; case 'put' : $ methodMap = [ 'POST' , 'PUT' ] ; $ realRoute = '$route/{id}' ; $ controllerCallable = $ this -> controllerLocation . ':putAction' ; break ; case 'delete' : $ methodMap = [ 'DELETE' ] ; $ realRoute = '$route/{id}' ; $ controllerCallable = $ this -> controllerLocation . ':deleteAction' ; break ; default : throw new \ Exception ( 'Invalid method.' . $ method ) ; break ; } $ methodMap = "['" . implode ( "', '" , $ methodMap ) . "']" ; $ command = strtr ( $ this -> template , [ '$methodMap' => $ methodMap , '$route' => $ realRoute , '$controllerCallable' => $ controllerCallable ] ) ; $ this -> commands [ ] = $ command ; }
2226	private function renderErrorScreenByException ( GetResponseForExceptionEvent $ event ) : void { $ exception = $ event -> getException ( ) ; $ statusCode = $ this -> getStatusCodeForException ( $ exception ) ; $ template = null ; $ this -> logException ( $ exception ) ; do { if ( $ exception instanceof \ Exception ) { $ template = $ this -> getTemplateForException ( $ exception ) ; } } while ( null === $ template && null !== ( $ exception = $ exception -> getPrevious ( ) ) ) ; $ this -> renderTemplate ( $ template ? : 'error' , $ statusCode , $ event ) ; }
9757	function below ( $ value ) : self { $ target = $ this -> hasFlag ( 'length' ) ? $ this -> getLength ( $ this -> target ) : $ this -> target ; return $ this -> expect ( $ target , lessThan ( $ value ) ) ; }
8616	public function setId ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'Id' ] [ 'FieldValue' ] = $ value ; return $ this ; }
793	public function getAttributes ( $ names = null , $ except = [ ] ) { $ values = [ ] ; if ( $ names === null ) { $ names = $ this -> attributes ( ) ; } foreach ( $ names as $ name ) { $ values [ $ name ] = $ this -> $ name ; } foreach ( $ except as $ name ) { unset ( $ values [ $ name ] ) ; } return $ values ; }
4287	public function getSubscriptions ( ) { if ( ! $ this -> isConnected ( ) ) { $ this -> debug -> alert ( 'WAMP publisher not connected to WAMP router' ) ; return array ( ) ; } $ this -> publishMeta ( ) ; $ this -> processExistingData ( ) ; return array ( 'debug.log' => array ( 'onLog' , PHP_INT_MAX * - 1 ) , 'errorHandler.error' => 'onError' , 'php.shutdown' => array ( 'onShutdown' , PHP_INT_MAX * - 1 ) , ) ; }
8285	protected function sessionTimeoutCheck ( $ configKey , $ sessKey , $ clear , $ alwaysUpdate = false ) { if ( $ this -> config [ $ configKey ] !== false ) { $ t = time ( ) ; if ( $ this -> session -> has ( $ sessKey ) ) { if ( $ this -> session -> get ( $ sessKey ) < $ t - $ this -> config [ $ configKey ] ) { if ( $ clear ) { $ this -> session -> invalidate ( ) ; } else { $ this -> session -> migrate ( true ) ; } $ this -> session -> set ( $ sessKey , $ t ) ; } elseif ( $ alwaysUpdate ) { $ this -> session -> set ( $ sessKey , $ t ) ; } } else { $ this -> session -> set ( $ sessKey , $ t ) ; } } }
12138	public function destroy ( QuestionRequest $ request , Question $ question ) { try { $ question -> delete ( ) ; return $ this -> response -> message ( trans ( 'messages.success.deleted' , [ 'Module' => trans ( 'forum::question.name' ) ] ) ) -> code ( 202 ) -> status ( 'success' ) -> url ( guard_url ( 'forum/question' ) ) -> redirect ( ) ; } catch ( Exception $ e ) { return $ this -> response -> message ( $ e -> getMessage ( ) ) -> code ( 400 ) -> status ( 'error' ) -> url ( guard_url ( 'forum/question/' . $ question -> getRouteKey ( ) ) ) -> redirect ( ) ; } }
2913	public function formatMemorySize ( $ size , $ precision = 2 ) { $ sizes = array ( " Bytes" , " KB" , " MB" , " GB" , " TB" , " PB" , " EB" , " ZB" , " YB" ) ; if ( $ size == 0 ) { return $ this -> __ ( 'n/a' ) ; } else { $ value = round ( $ size / pow ( 1000 , ( $ i = floor ( log ( $ size , 1000 ) ) ) ) , $ precision ) ; $ unitIndex = ( int ) $ i ; return $ this -> __ ( '%s%s' , $ this -> formatNumber ( $ value , $ precision ) , $ sizes [ $ unitIndex ] ) ; } }
7593	public function openTag ( FormInterface $ form = null ) { $ this -> setFormClass ( $ form , $ this -> formLayout ) ; return parent :: openTag ( $ form ) ; }
7254	static public function isBetterState ( $ stateA , $ stateB ) { if ( $ stateA === static :: STATE_IN_STOCK ) { return $ stateB !== static :: STATE_IN_STOCK ; } elseif ( $ stateA === static :: STATE_PRE_ORDER ) { return $ stateB === static :: STATE_OUT_OF_STOCK ; } return false ; }
1049	public static function getVariableValues ( Schema $ schema , $ varDefNodes , array $ inputs ) { $ errors = [ ] ; $ coercedValues = [ ] ; foreach ( $ varDefNodes as $ varDefNode ) { $ varName = $ varDefNode -> variable -> name -> value ; $ varType = TypeInfo :: typeFromAST ( $ schema , $ varDefNode -> type ) ; if ( Type :: isInputType ( $ varType ) ) { if ( array_key_exists ( $ varName , $ inputs ) ) { $ value = $ inputs [ $ varName ] ; $ coerced = Value :: coerceValue ( $ value , $ varType , $ varDefNode ) ; $ coercionErrors = $ coerced [ 'errors' ] ; if ( empty ( $ coercionErrors ) ) { $ coercedValues [ $ varName ] = $ coerced [ 'value' ] ; } else { $ messagePrelude = sprintf ( 'Variable "$%s" got invalid value %s; ' , $ varName , Utils :: printSafeJson ( $ value ) ) ; foreach ( $ coercionErrors as $ error ) { $ errors [ ] = new Error ( $ messagePrelude . $ error -> getMessage ( ) , $ error -> getNodes ( ) , $ error -> getSource ( ) , $ error -> getPositions ( ) , $ error -> getPath ( ) , $ error , $ error -> getExtensions ( ) ) ; } } } else { if ( $ varType instanceof NonNull ) { $ errors [ ] = new Error ( sprintf ( 'Variable "$%s" of required type "%s" was not provided.' , $ varName , $ varType ) , [ $ varDefNode ] ) ; } elseif ( $ varDefNode -> defaultValue ) { $ coercedValues [ $ varName ] = AST :: valueFromAST ( $ varDefNode -> defaultValue , $ varType ) ; } } } else { $ errors [ ] = new Error ( sprintf ( 'Variable "$%s" expected value of type "%s" which cannot be used as an input type.' , $ varName , Printer :: doPrint ( $ varDefNode -> type ) ) , [ $ varDefNode -> type ] ) ; } } if ( ! empty ( $ errors ) ) { return [ $ errors , null ] ; } return [ null , $ coercedValues ] ; }
11335	public function getFormValue ( ) { if ( $ this -> format instanceof BaseFormat ) { $ formValue = $ this -> format -> getFormValue ( ) ; } elseif ( is_callable ( $ this -> format ) || ( is_array ( $ this -> format ) && ! empty ( $ this -> format [ 0 ] ) && is_object ( $ this -> format [ 0 ] ) ) ) { $ formValue = $ this -> evaluateExpression ( $ this -> format , [ $ this -> value ] ) ; } else { $ formValue = $ this -> value ; } return $ formValue ; }
8955	public function createRelation ( $ changeset , $ tags , $ members ) { $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = 'relation/create' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ tagList = '' ; if ( ! empty ( $ tags ) ) { foreach ( $ tags as $ key => $ value ) { $ tagList .= '<tag k="' . $ key . '" v="' . $ value . '"/>' ; } } $ memberList = '' ; if ( ! empty ( $ members ) ) { foreach ( $ members as $ member ) { if ( $ member [ 'type' ] == 'node' ) { $ memberList .= '<member type="' . $ member [ 'type' ] . '" role="' . $ member [ 'role' ] . '" ref="' . $ member [ 'ref' ] . '"/>' ; } elseif ( $ member [ 'type' ] == 'way' ) { $ memberList .= '<member type="' . $ member [ 'type' ] . '" ref="' . $ member [ 'ref' ] . '"/>' ; } } } $ xml = '<?xml version="1.0" encoding="UTF-8"?> <osm version="0.6" generator="JoomlaOpenStreetMap"> <relation relation="' . $ changeset . '" >' . $ tagList . $ memberList . '</relation> </osm>' ; $ header [ 'Content-Type' ] = 'text/xml' ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'PUT' , $ parameters , $ xml , $ header ) ; return $ response -> body ; }
12481	public function registerServices ( ServicesFactory $ servicesFactory , array $ entityManagers ) { foreach ( $ entityManagers as $ name => $ entityManager ) { $ emConfig = Setup :: createAnnotationMetadataConfiguration ( ( array ) $ entityManager -> getEntities ( ) , true , null , null , true ) ; $ emConfig -> setNamingStrategy ( new UnderscoreNamingStrategy ( ) ) ; $ em = $ this -> createEntityManager ( $ entityManager -> toArray ( ) , $ emConfig ) ; $ emServiceId = 'doctrine.em.' . Str :: cast ( $ name ) -> lower ( ) ; $ servicesFactory -> registerService ( [ 'id' => $ emServiceId , 'instance' => $ em ] ) ; $ servicesFactory -> registerService ( [ 'id' => 'db.connection.' . $ name , 'instance' => $ em -> getConnection ( ) -> getWrappedConnection ( ) ] ) ; } }
4090	public function delete ( $ id = false , $ index , $ type , array $ options = array ( ) ) { $ params = array ( '_id' => $ id , '_index' => $ index , '_type' => $ type ) ; foreach ( $ options as $ key => $ value ) { $ params [ '_' . $ key ] = $ value ; } $ operation = array ( array ( 'delete' => $ params ) ) ; $ this -> operations [ ] = $ operation ; return $ this ; }
6718	protected function setParameter ( $ name , $ value ) { if ( ! is_scalar ( $ name ) ) { throw new \ Exception ( 'Parameter name must be scalar' ) ; } $ this -> parameters [ $ name ] = $ value ; return $ this ; }
4535	public function prePersist ( LifecycleEventArgs $ args ) { $ entity = $ args -> getEntity ( ) ; if ( ! $ entity instanceof Tenantable ) { return ; } if ( null !== $ entity -> getTenant ( ) ) { return ; } $ tenant = $ this -> container -> get ( TenantService :: class ) -> getContext ( ) ; $ entity -> setTenant ( $ tenant ) ; }
9833	public function setWorkbookPassword ( $ pValue , $ pAlreadyHashed = false ) { if ( ! $ pAlreadyHashed ) { $ pValue = PasswordHasher :: hashPassword ( $ pValue ) ; } $ this -> workbookPassword = $ pValue ; return $ this ; }
7821	public function update ( $ pipeline , array $ attachments , array $ detachments ) { $ this -> detach ( $ this -> pipelines [ $ pipeline ] , $ detachments ) ; $ this -> attach ( $ this -> pipelines [ $ pipeline ] , $ attachments ) ; $ this -> refreshPipelines ( ) ; }
8075	private function handle ( Response $ response ) { $ stream = stream_for ( $ response -> getBody ( ) ) ; $ data = json_decode ( $ stream -> getContents ( ) ) ; return $ data ; }
7463	private static function renderTemplate ( string $ __file__ , array $ data ) : string { ob_start ( ) ; extract ( $ data ) ; include $ __file__ ; return ob_get_clean ( ) ; }
7130	public function getNotifications ( $ type = null ) { if ( null !== $ type ) { NotificationTypes :: isValidType ( $ type ) ; return $ this -> notifications -> filter ( function ( NotificationInterface $ n ) use ( $ type ) { return $ n -> getType ( ) === $ type ; } ) ; } return $ this -> notifications ; }
7650	public function unlink ( $ path ) { $ this -> getStorageClient ( $ path ) -> deleteBlob ( $ this -> getContainerName ( $ path ) , $ this -> getFileName ( $ path ) ) ; clearstatcache ( true , $ path ) ; return true ; }
6853	public function onStatus ( PaymentEvent $ event ) { $ payment = $ event -> getPayment ( ) ; $ sale = $ payment -> getSale ( ) ; if ( $ sale instanceof OrderInterface ) { return ; } if ( $ sale instanceof CartInterface && $ sale -> getState ( ) !== CartStates :: STATE_ACCEPTED ) { return ; } if ( $ sale instanceof QuoteInterface && $ sale -> getState ( ) !== QuoteStates :: STATE_ACCEPTED ) { return ; } $ tokens = $ this -> findPaymentTokens ( $ payment ) ; if ( null === $ order = $ this -> transform ( $ sale ) ) { return ; } $ newPayment = null ; foreach ( $ order -> getPayments ( ) as $ p ) { if ( $ p -> getNumber ( ) === $ payment -> getNumber ( ) ) { $ newPayment = $ p ; break ; } } if ( null === $ newPayment ) { throw new RuntimeException ( "Failed to find the transformed payment." ) ; } $ this -> convertTokens ( $ this -> getPaymentIdentity ( $ newPayment ) , $ tokens ) ; $ event -> setPayment ( $ newPayment ) ; }
383	public function getExceptionName ( $ exception ) { if ( $ exception instanceof \ yii \ base \ Exception || $ exception instanceof \ yii \ base \ InvalidCallException || $ exception instanceof \ yii \ base \ InvalidParamException || $ exception instanceof \ yii \ base \ UnknownMethodException ) { return $ exception -> getName ( ) ; } return null ; }
5778	public function set ( string $ sql , array $ args ) { $ this -> sql = $ sql ; $ this -> args = $ args ; }
195	public function sendContentAsFile ( $ content , $ attachmentName , $ options = [ ] ) { $ headers = $ this -> getHeaders ( ) ; $ contentLength = StringHelper :: byteLength ( $ content ) ; $ range = $ this -> getHttpRange ( $ contentLength ) ; if ( $ range === false ) { $ headers -> set ( 'Content-Range' , "bytes */$contentLength" ) ; throw new RangeNotSatisfiableHttpException ( ) ; } list ( $ begin , $ end ) = $ range ; if ( $ begin != 0 || $ end != $ contentLength - 1 ) { $ this -> setStatusCode ( 206 ) ; $ headers -> set ( 'Content-Range' , "bytes $begin-$end/$contentLength" ) ; $ this -> content = StringHelper :: byteSubstr ( $ content , $ begin , $ end - $ begin + 1 ) ; } else { $ this -> setStatusCode ( 200 ) ; $ this -> content = $ content ; } $ mimeType = isset ( $ options [ 'mimeType' ] ) ? $ options [ 'mimeType' ] : 'application/octet-stream' ; $ this -> setDownloadHeaders ( $ attachmentName , $ mimeType , ! empty ( $ options [ 'inline' ] ) , $ end - $ begin + 1 ) ; $ this -> format = self :: FORMAT_RAW ; return $ this ; }
6731	public function get_posts ( ) { $ total_posts = wp_count_posts ( ) ; $ total_posts = isset ( $ total_posts -> publish ) ? $ total_posts -> publish : 0 ; return get_posts ( [ 'post_type' => 'post' , 'numberposts' => $ total_posts , 'post_status' => 'publish' , ] ) ; }
2793	public function getCacheDirectory ( ) { if ( ! is_null ( $ this -> cacheDirectory ) ) { return $ this -> cacheDirectory ; } if ( defined ( 'PHP_WINDOWS_VERSION_MAJOR' ) ) { if ( ! getenv ( 'APPDATA' ) ) { throw new RuntimeException ( 'The APPDATA environment variable must be set for humbug.' ) ; } $ home = strtr ( getenv ( 'APPDATA' ) , '\\' , '/' ) . '/Humbug' ; } else { if ( ! getenv ( 'HOME' ) ) { throw new RuntimeException ( 'The HOME environment variable must be set for humbug.' ) ; } $ home = rtrim ( getenv ( 'HOME' ) , '/' ) . '/.humbug' ; } $ cache = $ home . '/cache' ; foreach ( [ $ home , $ cache ] as $ dir ) { if ( ! is_dir ( $ dir ) ) { mkdir ( $ dir , 0777 ) ; } } file_put_contents ( $ home . '/.htaccess' , 'Deny from all' ) ; $ this -> cacheDirectory = $ cache ; return $ cache ; }
3709	protected function getFrontendFilterOptions ( ) { $ objFrontendFilterOptions = new FrontendFilterOptions ( ) ; $ objFrontendFilterOptions -> setAutoSubmit ( $ this -> objFilterConfig -> metamodel_fef_autosubmit ? true : false ) ; $ objFrontendFilterOptions -> setHideClearFilter ( $ this -> objFilterConfig -> metamodel_fef_hideclearfilter ? true : false ) ; $ objFrontendFilterOptions -> setShowCountValues ( $ this -> objFilterConfig -> metamodel_available_values ? true : false ) ; return $ objFrontendFilterOptions ; }
471	public function down ( ) { $ transaction = $ this -> db -> beginTransaction ( ) ; try { if ( $ this -> safeDown ( ) === false ) { $ transaction -> rollBack ( ) ; return false ; } $ transaction -> commit ( ) ; } catch ( \ Exception $ e ) { $ this -> printException ( $ e ) ; $ transaction -> rollBack ( ) ; return false ; } catch ( \ Throwable $ e ) { $ this -> printException ( $ e ) ; $ transaction -> rollBack ( ) ; return false ; } return null ; }
3149	public function getItemPublicUrl ( RunnerServiceContext $ context , $ itemRef ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ directoryIds = explode ( '|' , $ itemRef ) ; $ userDataLang = \ common_session_SessionManager :: getSession ( ) -> getDataLanguage ( ) ; $ directory = \ tao_models_classes_service_FileStorage :: singleton ( ) -> getDirectoryById ( $ directoryIds [ 1 ] ) ; if ( $ userDataLang != DEFAULT_LANG && ! $ directory -> has ( $ userDataLang ) && $ directory -> has ( DEFAULT_LANG ) ) { $ userDataLang = DEFAULT_LANG ; } return $ directory -> getPublicAccessUrl ( ) . $ userDataLang . '/' ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'getItemPublicUrl' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } }
1644	public function simplify ( Polyline $ polyline ) : Polyline { $ counterPoints = $ polyline -> getNumberOfPoints ( ) ; if ( $ counterPoints < 3 ) { return clone $ polyline ; } $ result = new Polyline ( ) ; $ bearingCalc = new BearingEllipsoidal ( ) ; $ points = $ polyline -> getPoints ( ) ; $ index = 0 ; $ result -> addPoint ( $ points [ $ index ] ) ; do { $ index ++ ; if ( $ index === ( $ counterPoints - 1 ) ) { $ result -> addPoint ( $ points [ $ index ] ) ; break ; } $ bearing1 = $ bearingCalc -> calculateBearing ( $ points [ $ index - 1 ] , $ points [ $ index ] ) ; $ bearing2 = $ bearingCalc -> calculateBearing ( $ points [ $ index ] , $ points [ $ index + 1 ] ) ; $ bearingDifference = min ( fmod ( $ bearing1 - $ bearing2 + 360 , 360 ) , fmod ( $ bearing2 - $ bearing1 + 360 , 360 ) ) ; if ( $ bearingDifference > $ this -> bearingAngle ) { $ result -> addPoint ( $ points [ $ index ] ) ; } } while ( $ index < $ counterPoints ) ; return $ result ; }
7433	public function export ( Defender $ defender ) { $ content = json_encode ( $ defender -> dangerFiles ) ; $ name = 'defender/defender-' . $ this -> date . '.json' ; if ( $ this -> storage -> exists ( $ name ) ) { $ this -> storage -> delete ( $ name ) ; } $ this -> storage -> put ( $ name , $ content ) ; }
7991	public function setSshKey ( $ pp , $ pca , $ key ) { if ( ! $ pp ) throw new BadMethodCallException ( 'Missing parameter $pp (OVH cloud passport).' ) ; if ( ! $ pca ) throw new BadMethodCallException ( 'Missing parameter $pca (PCA ServiceName).' ) ; if ( ! $ key ) throw new BadMethodCallException ( 'Missing parameter $key (Public key for this pca).' ) ; $ payload = array ( 'sshkey' => $ key ) ; try { $ this -> put ( 'cloud/' . $ pp . '/pca/' . $ pca , array ( 'Content-Type' => 'application/json;charset=UTF-8' ) , json_encode ( $ payload ) ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new CloudException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } }
5006	protected function normalizeListenerOptions ( $ name , $ options ) { $ normalized = [ 'service' => $ name , 'attach' => null , 'priority' => 1 , 'lazy' => false , ] ; if ( is_int ( $ name ) ) { $ normalized [ 'service' ] = $ options ; return $ normalized ; } if ( is_int ( $ options ) ) { $ normalized [ 'priority' ] = $ options ; return $ normalized ; } if ( is_string ( $ options ) ) { $ normalized [ 'attach' ] = [ [ 'event' => $ options , 'method' => null , 'priority' => 1 ] ] ; return $ normalized ; } if ( ArrayUtils :: isHashTable ( $ options ) ) { $ normalized [ 'attach' ] = $ this -> normalizeEventsSpec ( $ options ) ; if ( isset ( $ options [ 'lazy' ] ) ) { $ normalized [ 'lazy' ] = $ options [ 'lazy' ] ; } return $ normalized ; } $ event = $ method = null ; $ priority = 1 ; $ lazy = false ; foreach ( $ options as $ opt ) { if ( is_array ( $ opt ) ) { $ event = $ opt ; } elseif ( is_string ( $ opt ) ) { if ( null === $ event ) { $ event = [ $ opt ] ; } else { $ method = $ opt ; } } elseif ( is_int ( $ opt ) ) { $ priority = $ opt ; } elseif ( is_bool ( $ opt ) ) { $ lazy = $ opt ; } } foreach ( $ event as & $ eventSpec ) { $ eventSpec = [ 'event' => $ eventSpec , 'method' => $ method , 'priority' => $ priority ] ; } $ normalized [ 'attach' ] = $ event ; $ normalized [ 'lazy' ] = $ lazy ; return $ normalized ; }
3038	public function get ( $ userId , $ callId ) { $ key = $ this -> getCacheKey ( $ userId , $ callId ) ; if ( ! isset ( $ this -> cache [ $ key ] ) ) { $ data = $ this -> getStorage ( ) -> get ( $ userId , $ callId ) ; $ state = is_null ( $ data ) ? self :: STATE_NOT_FOUND : self :: STATE_ALIGNED ; $ this -> putInCache ( $ key , $ userId , $ callId , $ data , $ state ) ; } return $ this -> getFromCache ( $ key ) ; }
5026	protected function getCustomizationOptions ( ContainerInterface $ container , $ requestedName , array $ options = null ) { if ( ! static :: OPTIONS_NAME ) { throw new \ RuntimeException ( 'The class constants "OPTIONS_NAME" must be non empty.' ) ; } return $ container -> get ( static :: OPTIONS_NAME ) ; }
6648	public function create_tables ( ) { global $ wpdb ; $ charset_collate = $ wpdb -> get_charset_collate ( ) ; $ table_name = $ wpdb -> prefix . 'efg_custom_rating' ; if ( $ wpdb -> get_var ( "SHOW TABLES LIKE '$table_name'" ) != $ table_name ) { $ sql = "CREATE TABLE $table_name ( id mediumint(9) NOT NULL AUTO_INCREMENT, post_id mediumint(9) NOT NULL, ip varchar(45) NOT NULL, vote int(2) NOT NULL, PRIMARY KEY (id) ) $charset_collate;" ; require_once ( ABSPATH . 'wp-admin/includes/upgrade.php' ) ; dbDelta ( $ sql ) ; } }
3191	public function timeout ( $ timeLimit , $ tags , $ target ) { $ duration = $ this -> compute ( $ tags , $ target ) ; return $ duration >= $ timeLimit ; }
9162	private function adjustNumbytes ( $ numBytes ) : int { if ( isset ( $ this -> headers [ 'Content-Length' ] ) ) { $ numBytes = intval ( $ this -> headers [ 'Content-Length' ] ) ; } return $ numBytes ; }
9044	private function isRotationNeeded ( ) { clearstatcache ( ) ; if ( ! file_exists ( $ this -> file ) ) { return false ; } $ result = false ; $ attributes = stat ( $ this -> file ) ; if ( $ attributes == false || $ attributes [ 'size' ] >= $ this -> maxLogSize * 1024 * 1024 ) { $ result = true ; } return $ result ; }
9501	public function watch ( WatcherInterface $ watcher ) { $ events = $ this -> getEvents ( ) ; $ watcher -> watch ( $ this -> getTrackedPaths ( ) , $ events , [ $ this , 'runPeridot' ] ) ; }
8098	protected function toCollection ( $ data ) { if ( is_array ( $ data ) ) { return new Collection ( $ data ) ; } else { if ( ! ( $ data instanceof Collection ) ) { $ data = new Collection ( ) ; } } return $ data ; }
2806	public function viewLogAction ( ) { $ token = $ this -> getRequest ( ) -> getParam ( 'token' ) ; $ log = $ this -> getRequest ( ) -> getParam ( 'log' ) ; if ( ! $ token || ! $ log ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 400 ) -> setBody ( 'Invalid parameters' ) ; return ; } $ requestProfile = Mage :: getModel ( 'sheep_debug/requestInfo' ) -> load ( $ token , 'token' ) ; if ( ! $ requestProfile -> getId ( ) ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 404 ) -> setBody ( 'Request profile not found' ) ; return ; } try { $ content = $ requestProfile -> getLogging ( ) -> getLoggedContent ( $ log ) ; $ this -> getResponse ( ) -> setHttpResponseCode ( 200 ) -> setBody ( $ content ) ; } catch ( Exception $ e ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 200 ) -> setBody ( 'Unable to retrieve logged content' ) ; } }
2871	public function getModules ( ) { $ items = array ( ) ; $ items [ ] = array ( 'module' => 'Magento' , 'codePool' => 'core' , 'active' => true , 'version' => $ this -> getMagentoVersion ( ) ) ; $ modulesConfig = Mage :: getConfig ( ) -> getModuleConfig ( ) ; foreach ( $ modulesConfig as $ node ) { foreach ( $ node as $ module => $ data ) { $ items [ ] = array ( 'module' => $ module , 'codePool' => ( string ) $ data -> codePool , 'active' => $ data -> active == 'true' , 'version' => ( string ) $ data -> version ) ; } } return $ items ; }
3581	protected function pluckMeta ( Builder $ query , ArgumentBag $ args , $ alias ) { list ( $ column , $ key ) = [ $ args -> get ( 'column' ) , $ args -> get ( 'key' ) ] ; $ query -> select ( "{$alias}.meta_value as {$column}" ) ; if ( ! is_null ( $ key ) ) { $ this -> metaSelectListsKey ( $ query , $ key ) ; } return $ query -> callParent ( 'pluck' , $ args -> all ( ) ) ; }
6668	public function respond ( ) { if ( is_null ( $ this -> preparedResponse ) ) { $ this -> prepareResponse ( ) ; } if ( $ this -> status instanceof Status ) { header ( $ this -> status -> getHttpHeader ( ) ) ; } header ( "Content-Type: {$this->writer->getContentType()}" ) ; echo $ this -> preparedResponse ; return $ this ; }
1752	public static function isInstalledLanguage ( $ strLanguage ) { if ( ! isset ( static :: $ arrLanguages [ $ strLanguage ] ) ) { $ rootDir = self :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( is_dir ( $ rootDir . '/vendor/contao/core-bundle/src/Resources/contao/languages/' . $ strLanguage ) ) { static :: $ arrLanguages [ $ strLanguage ] = true ; } elseif ( is_dir ( static :: getContainer ( ) -> getParameter ( 'kernel.cache_dir' ) . '/contao/languages/' . $ strLanguage ) ) { static :: $ arrLanguages [ $ strLanguage ] = true ; } else { $ files = static :: getContainer ( ) -> get ( 'contao.resource_finder' ) -> findIn ( 'languages' ) -> depth ( 0 ) -> directories ( ) -> name ( $ strLanguage ) ; static :: $ arrLanguages [ $ strLanguage ] = \ count ( $ files ) > 0 ; } } return static :: $ arrLanguages [ $ strLanguage ] ; }
1060	public static function findDangerousChanges ( Schema $ oldSchema , Schema $ newSchema ) { return array_merge ( self :: findArgChanges ( $ oldSchema , $ newSchema ) [ 'dangerousChanges' ] , self :: findValuesAddedToEnums ( $ oldSchema , $ newSchema ) , self :: findInterfacesAddedToObjectTypes ( $ oldSchema , $ newSchema ) , self :: findTypesAddedToUnions ( $ oldSchema , $ newSchema ) , self :: findFieldsThatChangedTypeOnInputObjectTypes ( $ oldSchema , $ newSchema ) [ 'dangerousChanges' ] ) ; }
4762	protected function send ( $ data ) { if ( $ this -> doNotTrack ) { return ; } try { $ fp = fsockopen ( "udp://$this->host" , $ this -> port , $ errno , $ errstr ) ; if ( ! $ fp ) { return ; } fwrite ( $ fp , $ data ) ; fclose ( $ fp ) ; } catch ( \ Exception $ e ) { } }
12151	public function getRelatedType ( $ name ) { list ( $ relationship , $ role ) = $ this -> getRelationship ( $ name ) ; if ( $ relationship ) { return $ relationship -> roleType ( $ role ) ; } return false ; }
10399	protected function start ( InputInterface $ input , OutputInterface $ output , $ serviceClass , $ prefix ) { $ benchmark = new CommandBenchmark ( $ output ) ; $ benchmark -> start ( ) ; $ service = $ this -> getContainer ( ) -> get ( $ serviceClass ) ; $ factory = $ service -> getPipelineFactory ( ) ; $ factory -> setProgressBar ( new ProgressBar ( $ output ) ) ; $ service -> startPipeline ( $ prefix , $ input -> getArgument ( 'target' ) ) ; $ benchmark -> finish ( ) ; }
3499	public function create ( DeviceToken $ deviceToken , bool $ sandbox ) : string { $ uri = 'https://api.push.apple.com/3/device/%s' ; if ( $ sandbox ) { $ uri = 'https://api.development.push.apple.com/3/device/%s' ; } return sprintf ( $ uri , $ deviceToken ) ; }
12042	public function update ( $ usernameId , $ data = array ( ) ) { if ( empty ( $ usernameId ) ) return false ; $ existing = ( array ) $ this -> getPropertyData ( ) ; $ data = empty ( $ data ) ? $ existing : array_merge ( $ data , $ existing ) ; $ profile = $ this -> loadObjectByURI ( $ usernameId , array_keys ( $ this -> getPropertyModel ( ) ) ) ; $ this -> setObjectId ( $ profile -> getObjectId ( ) ) ; $ this -> setObjectURI ( $ profile -> getObjectURI ( ) ) ; $ profileData = $ profile -> getPropertyData ( ) ; $ updatedProfile = array_merge ( $ profileData , $ data ) ; foreach ( $ updatedProfile as $ property => $ value ) : $ this -> setPropertyValue ( $ property , $ value ) ; endforeach ; $ this -> defineValueGroup ( "user" ) ; if ( ! $ this -> saveObject ( $ this -> getPropertyValue ( "user_name_id" ) , "user" , $ this -> getObjectId ( ) ) ) { $ profile -> setError ( "Could not save the profile data" ) ; return false ; } return true ; }
7404	private function convertFileInformation ( $ file ) { if ( $ file instanceof FileUpload ) { return $ file ; } $ file = $ this -> fixPhpFilesArray ( $ file ) ; if ( is_array ( $ file ) ) { $ keys = array_keys ( $ file ) ; sort ( $ keys ) ; if ( $ keys == [ 'error' , 'name' , 'size' , 'tmp_name' , 'type' ] ) { if ( UPLOAD_ERR_NO_FILE == $ file [ 'error' ] ) { $ file = null ; } else { $ file = new FileUpload ( $ file [ 'tmp_name' ] , $ file [ 'name' ] , $ file [ 'size' ] , $ file [ 'type' ] , $ file [ 'error' ] ) ; } } else { $ file = array_map ( [ $ this , 'convertFileInformation' ] , $ file ) ; } } return $ file ; }
2762	public function log ( GitEvent $ gitEvent , string $ message , array $ context = [ ] , ? string $ eventName = null ) : void { if ( $ eventName === null && method_exists ( $ gitEvent , 'getName' ) ) { $ eventName = $ gitEvent -> getName ( ) ; } $ method = $ this -> getLogLevelMapping ( $ eventName ) ; $ context += [ 'command' => $ gitEvent -> getProcess ( ) -> getCommandLine ( ) ] ; $ this -> logger -> { $ method } ( $ message , $ context ) ; }
8735	public function decrement ( $ column , $ amount = 1 , array $ extra = [ ] ) { $ extra = $ this -> addUpdatedAtColumn ( $ extra ) ; return $ this -> noTranslationsQuery ( ) -> decrement ( $ column , $ amount , $ extra ) ; }
9159	protected function redirect ( $ controller = null , $ action = null ) { if ( null === $ controller ) { $ controller = Application :: getInstance ( ) -> getDefaultController ( ) ; } if ( null === $ action ) { $ action = Application :: getInstance ( ) -> getDefaultAction ( ) ; } $ destination = sprintf ( "Location: %s%s/%s" , $ this -> request -> getContextPrefix ( ) , $ controller , $ action ) ; header ( $ destination ) ; exit ( ) ; }
3032	public function getSessionState ( AssessmentTestSession $ session ) { $ deliveryExecution = $ this -> getDeliveryExecution ( $ session ) ; return $ deliveryExecution -> getState ( ) -> getUri ( ) ; }
10350	protected function validate ( ) { $ this -> validateArgSet ( $ this -> args ) ; if ( $ this -> success ) { $ this -> validateArgSet ( $ this -> successArgs ) ; } if ( ! $ this -> success ) { $ this -> validateArgSet ( $ this -> failureArgs ) ; } }
4800	function via ( $ column ) { $ this -> column = $ column ; $ this -> conditions [ 0 ] = "$this->table.$column AND" ; $ this -> where [ 0 ] = "(" . $ this -> whereIn ( "$this->table.$column" , array_keys ( ( array ) $ this -> result -> rows ) ) . ")" ; return $ this ; }
9753	public static function sysGetTempDir ( ) { if ( self :: $ useUploadTempDirectory ) { if ( ini_get ( 'upload_tmp_dir' ) !== false ) { if ( $ temp = ini_get ( 'upload_tmp_dir' ) ) { if ( file_exists ( $ temp ) ) { return realpath ( $ temp ) ; } } } } return realpath ( sys_get_temp_dir ( ) ) ; }
1462	protected function getColumnValue ( $ id ) { $ value = $ this -> getQuery ( ) -> where ( $ this -> key , $ id ) -> value ( $ this -> column ) ; if ( is_null ( $ value ) ) { throw new \ OutOfRangeException ( "Cursor key {$id} does not exist or has a null value." ) ; } return $ value ; }
2681	public function configureImageOptimizationDefaultConfigOptions ( $ params , $ version ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/io_settings' ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: PATCH , $ params ) ; return $ result ; }
6968	protected function calculateGoodLine ( Model \ DocumentLineInterface $ line ) : ? Amount { if ( $ line -> getType ( ) !== Model \ DocumentLineTypes :: TYPE_GOOD ) { throw new LogicException ( sprintf ( "Expected document line with type '%s'." , Model \ DocumentLineTypes :: TYPE_GOOD ) ) ; } if ( null === $ item = $ line -> getSaleItem ( ) ) { throw new LogicException ( "Document can't be recalculated." ) ; } $ result = $ this -> calculator -> calculateSaleItem ( $ item , $ line -> getQuantity ( ) ) ; $ this -> syncLineWithResult ( $ line , $ result ) ; if ( $ item -> isPrivate ( ) ) { return null ; } return $ result ; }
12513	public static function copy ( $ src , $ dest , $ force = false , $ delete = false ) { $ src = Path :: clean ( $ src ) ; $ dest = Path :: clean ( $ dest ) ; $ fs = new Filesystem ( ) ; try { $ fs -> mirror ( $ src , $ dest , null , [ 'override' => $ force , 'delete' => $ delete , 'copy_on_windows' => true ] ) ; } catch ( IOExceptionInterface $ e ) { throw new Exception ( Helper :: getTranslation ( 'CANNOT_FIND_SOURCE' ) . ' ' . $ e -> getPath ( ) ) ; } return true ; }
5807	public function onAfterWrite ( ) { parent :: onAfterWrite ( ) ; $ write = 'Title' ; $ class = $ this -> owner -> ClassName ; foreach ( Config :: inst ( ) -> get ( 'FusionService' , 'custom_tag_types' ) as $ type => $ field ) { if ( $ type === $ class ) { $ write = $ field ; } } $ changed = $ this -> owner -> getChangedFields ( ) ; $ existing = FusionTag :: get ( ) -> filter ( 'Title' , $ this -> owner -> $ write ) -> first ( ) ; if ( is_null ( $ this -> owner -> FusionTagID ) && ! $ existing ) { $ fusion = FusionTag :: create ( ) ; $ fusion -> Title = $ this -> owner -> $ write ; $ fusion -> TagTypes = serialize ( array ( $ class => $ class ) ) ; $ fusion -> write ( ) ; $ this -> owner -> FusionTagID = $ fusion -> ID ; $ this -> owner -> write ( ) ; } else if ( is_null ( $ this -> owner -> FusionTagID ) && $ existing ) { $ types = unserialize ( $ existing -> TagTypes ) ; $ types [ $ class ] = $ class ; $ existing -> TagTypes = serialize ( $ types ) ; $ existing -> write ( ) ; $ this -> owner -> FusionTagID = $ existing -> ID ; $ this -> owner -> write ( ) ; } else if ( isset ( $ changed [ $ write ] ) && ! isset ( $ changed [ 'FusionTagID' ] ) && $ existing && ( $ existing -> ID != $ this -> owner -> FusionTagID ) ) { $ fusion = FusionTag :: get ( ) -> byID ( $ this -> owner -> FusionTagID ) ; $ types = unserialize ( $ fusion -> TagTypes ) ; unset ( $ types [ $ this -> owner -> ClassName ] ) ; $ fusion -> TagTypes = ! empty ( $ types ) ? serialize ( $ types ) : null ; $ fusion -> write ( ) ; $ types = unserialize ( $ existing -> TagTypes ) ; $ types [ $ class ] = $ class ; $ existing -> TagTypes = serialize ( $ types ) ; $ existing -> write ( ) ; $ this -> owner -> FusionTagID = $ existing -> ID ; $ this -> owner -> write ( ) ; } else if ( isset ( $ changed [ $ write ] ) && ! isset ( $ changed [ 'FusionTagID' ] ) && ( $ existing = FusionTag :: get ( ) -> byID ( $ this -> owner -> FusionTagID ) ) ) { $ existing -> Title = $ changed [ $ write ] [ 'after' ] ; $ existing -> write ( ) ; } }
6582	public static function getSession ( ServerRequestInterface $ request ) : SessionDataHolder { $ session = $ request -> getAttribute ( static :: REQ_ATTR ) ; if ( ! $ session instanceof SessionDataHolder ) { throw new SessionMiddlewareException ( "No session object is available in the request attributes" ) ; } return $ session ; }
8862	public function getYearlyArchiveLink ( ) { $ date = $ this -> dbObject ( "PublishDate" ) ; return Controller :: join_links ( $ this -> Parent ( ) -> Link ( "archive" ) , $ date -> format ( "Y" ) ) ; }
12235	public function insertXML ( $ xml , $ mode = 'append' ) { $ tmp = dom_import_simplexml ( $ this ) ; $ fragment = $ tmp -> ownerDocument -> createDocumentFragment ( ) ; $ use_errors = libxml_use_internal_errors ( true ) ; if ( ! $ fragment -> appendXML ( $ xml ) ) { libxml_use_internal_errors ( $ use_errors ) ; throw new InvalidArgumentException ( libxml_get_last_error ( ) -> message ) ; } libxml_use_internal_errors ( $ use_errors ) ; $ this -> insertNode ( $ tmp , $ fragment , $ mode ) ; return $ this ; }
4631	protected function prepareRequestMethod ( ) { switch ( $ this -> command -> getMethod ( ) ) { case "POST" : $ this -> options [ CURLOPT_POST ] = 1 ; break ; case "PUT" : $ this -> options [ CURLOPT_CUSTOMREQUEST ] = 'PUT' ; break ; case "DELETE" : $ this -> options [ CURLOPT_CUSTOMREQUEST ] = 'DELETE' ; break ; case "HEAD" : $ this -> options [ CURLOPT_NOBODY ] = 1 ; break ; default : $ this -> options [ CURLOPT_HTTPGET ] = 1 ; } return $ this ; }
11369	public static function checkPeopleArgs ( ) { $ args = func_get_args ( ) ; if ( empty ( $ args ) ) { return array ( ) ; } if ( count ( $ args ) == 1 && is_string ( $ args [ 0 ] ) && self :: isEmail ( $ args [ 0 ] ) ) { return array ( array ( $ args [ 0 ] ) ) ; } if ( count ( $ args ) == 2 && ( isset ( $ args [ 0 ] ) && true === self :: isEmail ( $ args [ 0 ] ) ) && ( isset ( $ args [ 1 ] ) && false === self :: isEmail ( $ args [ 1 ] ) ) ) { return array ( array ( $ args [ 1 ] => $ args [ 0 ] ) ) ; } if ( count ( $ args ) == 1 ) { $ args = $ args [ 0 ] ; } $ result = array ( ) ; foreach ( $ args as $ name => $ email ) { if ( is_string ( $ name ) && true === self :: isEmail ( $ email ) ) { $ result [ ] = array ( $ name => $ email ) ; } elseif ( is_numeric ( $ name ) && true === self :: isEmail ( $ email ) ) { $ result [ ] = array ( $ email ) ; } } return $ result ; }
9874	private function writeLegacyDrawing ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { if ( count ( $ pSheet -> getComments ( ) ) > 0 ) { $ objWriter -> startElement ( 'legacyDrawing' ) ; $ objWriter -> writeAttribute ( 'r:id' , 'rId_comments_vml1' ) ; $ objWriter -> endElement ( ) ; } }
9428	public function updateCMSFields ( FieldList $ fields ) { $ fields -> insertAfter ( Tab :: create ( 'Icon' , $ this -> owner -> fieldLabel ( 'Icon' ) ) , 'Main' ) ; $ fields -> addFieldsToTab ( 'Root.Icon' , [ FontIconField :: create ( 'FontIcon' , $ this -> owner -> fieldLabel ( 'FontIcon' ) ) , ColorField :: create ( 'FontIconColor' , $ this -> owner -> fieldLabel ( 'FontIconColor' ) ) ] ) ; }
6280	public function nextkey ( ) { if ( $ this -> keyIterPos >= $ this -> keyIterStop ) { return false ; } $ keyLen = $ this -> readInt31 ( $ this -> keyIterPos ) ; $ dataLen = $ this -> readInt31 ( $ this -> keyIterPos + 4 ) ; $ key = $ this -> read ( $ this -> keyIterPos + 8 , $ keyLen ) ; $ this -> keyIterPos += 8 + $ keyLen + $ dataLen ; return $ key ; }
1723	protected function getPreviewImage ( File $ objFile , $ strInfo , $ strClass = 'gimage' ) { if ( ( $ objFile -> isSvgImage || ( $ objFile -> height <= Config :: get ( 'gdMaxImgHeight' ) && $ objFile -> width <= Config :: get ( 'gdMaxImgWidth' ) ) ) && $ objFile -> viewWidth && $ objFile -> viewHeight ) { if ( $ objFile -> height !== null && $ objFile -> height <= 75 && $ objFile -> width !== null && $ objFile -> width <= 100 ) { $ image = $ objFile -> dataUri ; } else { $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; $ image = System :: getContainer ( ) -> get ( 'contao.image.image_factory' ) -> create ( $ rootDir . '/' . $ objFile -> path , array ( 100 , 75 , ResizeConfiguration :: MODE_BOX ) ) -> getUrl ( $ rootDir ) ; } } else { $ image = Image :: getPath ( 'placeholder.svg' ) ; } if ( strncmp ( $ image , 'data:' , 5 ) === 0 ) { return '<img src="' . $ objFile -> dataUri . '" width="' . $ objFile -> width . '" height="' . $ objFile -> height . '" alt="" class="' . $ strClass . '" title="' . StringUtil :: specialchars ( $ strInfo ) . '">' ; } return Image :: getHtml ( $ image , '' , 'class="' . $ strClass . '" title="' . StringUtil :: specialchars ( $ strInfo ) . '"' ) ; }
7813	public static function toGregorianStr ( $ j_date , $ sep = '/' ) { $ arr = explode ( $ sep , $ j_date ) ; if ( count ( $ arr ) < 3 || intval ( $ arr [ 0 ] ) == 0 ) return "" ; else $ g_date = jDateTime :: toGregorian ( $ arr [ 2 ] , $ arr [ 1 ] , $ arr [ 0 ] ) ; return implode ( $ sep , $ g_date ) ; }
2011	public static function findByCalendar ( $ intId , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; return static :: findBy ( array ( "$t.calendars LIKE '%\"" . ( int ) $ intId . "\"%'" ) , null , $ arrOptions ) ; }
11853	protected function redirect ( string $ uri , bool $ isPermanent = false ) : void { $ nCode = $ isPermanent ? 301 : 302 ; Headers :: getInstance ( ) -> addByHttpCode ( $ nCode ) -> add ( 'Location: ' . $ uri ) -> run ( ) ; exit ; }
9523	private function getConfig ( ) { $ yaml = new Parser ( ) ; $ configFile = getenv ( 'TRAVIS_BUILD_DIR' ) . '/.travis.yml' ; $ config = $ yaml -> parse ( file_get_contents ( $ configFile ) ) ; $ config = $ config [ 'travisdeployer' ] ; $ this -> branches = $ config [ 'branches' ] ; if ( count ( $ this -> branches ) === 0 ) { die ( 'No branches are configured to deploy to.' . PHP_EOL ) ; } $ this -> verbose = filter_input ( FILTER_VALIDATE_BOOLEAN , $ config [ 'verbose' ] ) ; }
4673	public function getTemplateFile ( $ template ) { $ file = $ template . $ this -> suffix ; if ( is_file ( $ file ) ) { return $ file ; } foreach ( $ this -> paths as $ path ) { $ file = $ path . "/" . $ template . $ this -> suffix ; if ( is_file ( $ file ) ) { return $ file ; } } throw new Exception ( "Could not find template file '$template'." ) ; }
4077	protected function getPaletteCombinationRows ( ) { $ combinations = $ this -> getCombinationsFromDatabase ( ) ; $ success = array ( ) ; if ( ! $ combinations ) { return array_keys ( $ this -> information ) ; } foreach ( $ combinations as $ combination ) { $ modelId = $ combination -> pid ; $ modelName = $ this -> tableNameFromId ( $ modelId ) ; if ( ! empty ( $ this -> information [ $ modelName ] [ self :: COMBINATION ] ) ) { continue ; } $ this -> information [ $ modelName ] [ self :: MODELID ] = $ modelId ; $ this -> information [ $ modelName ] [ self :: COMBINATION ] = array ( 'dca_id' => $ combination -> dca_id , 'view_id' => $ combination -> view_id ) ; $ this -> setTableMapping ( $ modelId , $ modelName ) ; $ success [ ] = $ modelId ; } return $ success ; }
4815	public function getAsDom ( ) { $ anyDataSet = XmlUtil :: createXmlDocumentFromStr ( "<anydataset></anydataset>" ) ; $ nodeRoot = $ anyDataSet -> getElementsByTagName ( "anydataset" ) -> item ( 0 ) ; foreach ( $ this -> collection as $ sr ) { $ row = $ sr -> getAsDom ( ) ; $ nodeRow = $ row -> getElementsByTagName ( "row" ) -> item ( 0 ) ; $ newRow = XmlUtil :: createChild ( $ nodeRoot , "row" ) ; XmlUtil :: addNodeFromNode ( $ newRow , $ nodeRow ) ; } return $ anyDataSet ; }
7239	protected function getAddressFromEvent ( ResourceEventInterface $ event ) { $ resource = $ event -> getResource ( ) ; if ( ! $ resource instanceof CustomerAddressInterface ) { throw new InvalidArgumentException ( 'Expected instance of ' . CustomerAddressInterface :: class ) ; } return $ resource ; }
11844	private function addAPerson ( array $ person , ObjectManager $ manager ) { $ p = new Person ( ) ; foreach ( $ person as $ key => $ value ) { switch ( $ key ) { case 'CountryOfBirth' : case 'Nationality' : $ value = $ this -> getCountry ( $ value ) ; break ; case 'Birthdate' : $ value = new \ DateTime ( $ value ) ; break ; case 'center' : case 'maritalStatus' : $ value = $ this -> getReference ( $ value ) ; break ; } if ( method_exists ( $ p , 'set' . $ key ) ) { call_user_func ( array ( $ p , 'set' . $ key ) , $ value ) ; } elseif ( method_exists ( $ p , 'add' . $ key ) ) { if ( ! is_array ( $ value ) ) { $ value = array ( $ value ) ; } foreach ( $ value as $ v ) { if ( $ v !== NULL ) { call_user_func ( array ( $ p , 'add' . $ key ) , $ v ) ; } } } } $ manager -> persist ( $ p ) ; echo "add person'" . $ p -> __toString ( ) . "'\n" ; }
10047	protected function copyRecursive ( $ src , $ dst , $ depth , Logger $ logger ) { if ( $ depth == 0 ) { return ; } if ( ! is_file ( $ src ) && ! is_dir ( $ src ) ) { $ logger -> log ( "$src is not a valid source." , Logger :: WARNING ) ; return ; } if ( ! is_readable ( $ src ) ) { $ logger -> log ( "$src is not readable, skipping." , Logger :: WARNING ) ; return ; } if ( is_file ( $ dst ) || is_dir ( $ dst ) ) { $ logger -> log ( "$dst already exists, and cannot be overwritten." , Logger :: WARNING ) ; return ; } if ( is_dir ( $ src ) ) { mkdir ( $ dst ) ; } elseif ( is_file ( $ src ) ) { copy ( $ src , $ dst ) ; return ; } $ dh = opendir ( $ src ) ; while ( ( $ file = readdir ( $ dh ) ) !== false ) { if ( ( $ file === '.' ) || ( $ file === '..' ) ) { continue ; } $ this -> copyRecursive ( $ src . '/' . $ file , $ dst . '/' . $ file , $ depth - 1 , $ logger ) ; } }
9965	public function setSelectedCells ( $ pCoordinate ) { $ pCoordinate = strtoupper ( $ pCoordinate ) ; $ pCoordinate = preg_replace ( '/^([A-Z]+)$/' , '${1}:${1}' , $ pCoordinate ) ; $ pCoordinate = preg_replace ( '/^(\d+)$/' , '${1}:${1}' , $ pCoordinate ) ; $ pCoordinate = preg_replace ( '/^([A-Z]+):([A-Z]+)$/' , '${1}1:${2}1048576' , $ pCoordinate ) ; $ pCoordinate = preg_replace ( '/^(\d+):(\d+)$/' , 'A${1}:XFD${2}' , $ pCoordinate ) ; if ( Coordinate :: coordinateIsRange ( $ pCoordinate ) ) { list ( $ first ) = Coordinate :: splitRange ( $ pCoordinate ) ; $ this -> activeCell = $ first [ 0 ] ; } else { $ this -> activeCell = $ pCoordinate ; } $ this -> selectedCells = $ pCoordinate ; return $ this ; }
9720	public function setEscher ( \ PhpOffice \ PhpSpreadsheet \ Shared \ Escher $ pValue = null ) { $ this -> escher = $ pValue ; }
6082	public function removeComment ( $ mediaId , $ commentId ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> delete ( 'v1/media/' . $ mediaId . '/comments/' . $ commentId . '' , $ parameters ) ; $ result = new Comment ( $ result ) ; return $ result ; }
7950	public function orderBackend ( $ nbBackend , $ duration ) { return json_decode ( self :: getClient ( ) -> orderBackend ( $ this -> sn , $ nbBackend , $ duration ) ) ; }
8496	public function getFulfillmentPreview ( $ request ) { if ( ! ( $ request instanceof FBAOutboundServiceMWS_Model_GetFulfillmentPreviewRequest ) ) { $ request = new FBAOutboundServiceMWS_Model_GetFulfillmentPreviewRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetFulfillmentPreview' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAOutboundServiceMWS_Model_GetFulfillmentPreviewResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
4647	public function copy ( $ originFile , $ targetFile , $ override = false ) { parent :: copy ( $ originFile , $ targetFile , $ override ) ; $ this -> chmod ( $ targetFile , fileperms ( $ originFile ) ) ; }
6401	public function getResource ( $ resource ) : ? string { Preconditions :: checkState ( $ this -> isPsr0Compatible ( ) , "Class '%s' must be PSR-0 compatible!" , $ this -> getName ( ) ) ; $ slashedFileName = $ this -> getSlashedFileName ( ) ; $ filePath = $ resource [ 0 ] == '/' ? str_replace ( "/{$this->getSlashedName()}.php" , '' , $ slashedFileName ) . $ resource : dirname ( $ slashedFileName ) . '/' . $ resource ; return is_file ( $ filePath ) ? $ filePath : null ; }
5494	public function findFirstAction ( $ parameters ) { $ slot = $ this -> findFirstSlot ( $ parameters ) ; if ( isset ( $ slot ) && isset ( $ slot [ 'content' ] ) ) { return $ slot [ 'content' ] ; } return ; }
1220	private function validateSeq ( $ from , array $ types , $ a , $ b ) { $ ta = Utils :: type ( $ a ) ; $ tb = Utils :: type ( $ b ) ; if ( $ ta !== $ tb ) { $ msg = "encountered a type mismatch in sequence: {$ta}, {$tb}" ; $ this -> typeError ( $ from , $ msg ) ; } $ typeMatch = ( $ types && $ types [ 0 ] == 'any' ) || in_array ( $ ta , $ types ) ; if ( ! $ typeMatch ) { $ msg = 'encountered a type error in sequence. The argument must be ' . 'an array of ' . implode ( '|' , $ types ) . ' types. ' . "Found {$ta}, {$tb}." ; $ this -> typeError ( $ from , $ msg ) ; } }
6248	public function getAll ( ) { $ permissions = $ this -> modules -> getAllPermissions ( ) ; $ permissions = array_merge ( $ permissions , $ this -> getCustom ( ) ) ; return array_unique ( $ permissions ) ; }
9538	private function getRealName ( $ param ) { $ parameterClosure = $ this -> getParameterClosure ( $ param ) ; if ( $ parameterClosure -> parent != null ) { return $ parameterClosure -> parent -> parameterName ; } else { return $ parameterClosure -> parameterName ; } }
2209	public function fetchRow ( ) { if ( $ this -> intIndex >= $ this -> count ( ) - 1 ) { return false ; } $ this -> arrCache = array_values ( $ this -> resultSet [ ++ $ this -> intIndex ] ) ; return $ this -> arrCache ; }
12666	public function edit ( $ sourceDir , array $ options , $ username , $ values ) { $ this -> resolveOptions ( $ options ) ; $ this -> init ( $ sourceDir , $ options , $ username ) ; $ this -> createContributorDir ( $ sourceDir , $ options , $ username ) ; $ filename = sprintf ( '%s/blocks/%s.json' , $ this -> getDirInUse ( ) , $ options [ "blockname" ] ) ; $ currentBlock = $ options [ "baseBlock" ] = JsonTools :: jsonDecode ( FilesystemTools :: readFile ( $ filename ) ) ; $ values = $ this -> parseChildren ( $ values ) ; $ block = JsonTools :: join ( $ currentBlock , $ values ) ; $ encodedBlock = json_encode ( $ block ) ; $ blockClass = BlockFactory :: getBlockClass ( $ block [ "type" ] ) ; $ event = Dispatcher :: dispatch ( BlockEvents :: BLOCK_EDITING , new BlockEditingEvent ( $ this -> serializer , $ filename , $ encodedBlock , $ blockClass ) ) ; $ blockContent = $ event -> getFileContent ( ) ; FilesystemTools :: writeFile ( $ filename , $ blockContent ) ; Dispatcher :: dispatch ( BlockEvents :: BLOCK_EDITED , new BlockEditedEvent ( $ this -> serializer , $ filename , $ encodedBlock , $ blockClass ) ) ; DataLogger :: log ( sprintf ( 'Block "%s" has been edited on the "%s" slot on page "%s" for the "%s_%s" language' , $ options [ "blockname" ] , $ options [ "slot" ] , $ options [ "page" ] , $ options [ "language" ] , $ options [ "country" ] ) ) ; }
6722	public function fetchAccessToken ( $ code ) { $ this -> validateTokenParams ( ) ; $ this -> oauth2 -> tokenUrl = $ this -> tokenUrl ; $ this -> oauth2 -> clientId = $ this -> clientId ; $ this -> oauth2 -> clientSecret = $ this -> clientSecret ; try { $ response = $ this -> oauth2 -> fetchAccessToken ( $ code ) ; } catch ( Exception $ ex ) { throw new Oauth2ClientException ( $ ex -> getMessage ( ) ) ; } return $ this -> handleTokenResponse ( $ response ) ; }
4345	public function getCfgLazy ( $ name ) { if ( ! isset ( $ this -> cfgLazy [ $ name ] ) ) { return array ( ) ; } $ return = $ this -> cfgLazy [ $ name ] ; unset ( $ this -> cfgLazy [ $ name ] ) ; return $ return ; }
1640	protected function setupPaths ( Client $ client , $ base , $ path , $ strip , $ project ) { if ( $ strip ) { $ client -> setStripPath ( $ strip ) ; if ( ! $ project ) { $ client -> setProjectRoot ( "{$strip}/app" ) ; } return ; } if ( $ project ) { if ( $ base && substr ( $ project , 0 , strlen ( $ base ) ) === $ base ) { $ client -> setStripPath ( $ base ) ; } $ client -> setProjectRoot ( $ project ) ; return ; } $ client -> setStripPath ( $ base ) ; $ client -> setProjectRoot ( $ path ) ; }
574	public function unmaskToken ( $ maskedToken ) { $ decoded = StringHelper :: base64UrlDecode ( $ maskedToken ) ; $ length = StringHelper :: byteLength ( $ decoded ) / 2 ; if ( ! is_int ( $ length ) ) { return '' ; } return StringHelper :: byteSubstr ( $ decoded , $ length , $ length ) ^ StringHelper :: byteSubstr ( $ decoded , 0 , $ length ) ; }
2452	private function getLocale ( Request $ request ) : string { if ( null !== $ request -> attributes -> get ( '_locale' ) ) { return $ this -> formatLocaleId ( $ request -> attributes -> get ( '_locale' ) ) ; } return $ request -> getPreferredLanguage ( $ this -> availableLocales ) ; }
9448	public function getPackPath ( Container $ app ) { static $ paths = [ ] ; $ me = get_class ( $ this ) ; if ( empty ( $ paths [ $ me ] ) ) { $ paths [ $ me ] = dirname ( $ this -> getReflector ( ) -> getFileName ( ) ) ; } return $ paths [ $ me ] ; }
5249	public function save ( $ child ) { $ children = ! is_array ( $ child ) ? [ $ child ] : $ child ; foreach ( $ children as $ child ) { $ child -> setParent ( $ this -> parent ) ; $ child -> save ( ) ; } }
5950	public function addMediaResponse ( $ item ) { if ( ! ( $ item instanceof MediaResponse ) ) { if ( is_array ( $ item ) ) { try { $ item = new MediaResponse ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate MediaResponse. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } elseif ( ! is_numeric ( $ item ) ) { trigger_error ( 'Array parameter item is not of expected type "MediaResponse"!' , E_USER_WARNING ) ; } } $ this -> results [ ] = $ item ; return $ this ; }
921	private function fixAnnotations ( DocBlock $ doc ) { foreach ( $ doc -> getAnnotations ( ) as $ index => $ annotation ) { $ next = $ doc -> getAnnotation ( $ index + 1 ) ; if ( null === $ next ) { break ; } if ( true === $ next -> getTag ( ) -> valid ( ) ) { if ( TagComparator :: shouldBeTogether ( $ annotation -> getTag ( ) , $ next -> getTag ( ) ) ) { $ this -> ensureAreTogether ( $ doc , $ annotation , $ next ) ; } else { $ this -> ensureAreSeparate ( $ doc , $ annotation , $ next ) ; } } } return $ doc -> getContent ( ) ; }
8366	public static function registerMapping ( array $ config ) { self :: validateConfig ( $ config ) ; if ( isset ( self :: $ mappings [ $ config [ 'name' ] ] ) === false ) { self :: $ mappings [ $ config [ 'name' ] ] = array ( 'config' => $ config ) ; Database :: registerDatabase ( $ config [ 'database' ] ) ; } else { Logger :: get ( ) -> warning ( 'mapping with name "' . $ config [ 'name' ] . '" was already set' ) ; } }
10136	private function writeZoom ( ) { if ( $ this -> phpSheet -> getSheetView ( ) -> getZoomScale ( ) == 100 ) { return ; } $ record = 0x00A0 ; $ length = 0x0004 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vv' , $ this -> phpSheet -> getSheetView ( ) -> getZoomScale ( ) , 100 ) ; $ this -> append ( $ header . $ data ) ; }
4567	public function resolve ( Form $ form ) { switch ( $ form -> getType ( ) ) { case Form :: TYPE_FORMIO : $ components = $ form -> getSchema ( ) ; $ resolverCollection = $ this -> resolverCollection ; $ resolve = function ( & $ component ) use ( & $ resolve , $ resolverCollection ) { switch ( true ) { case property_exists ( $ component , 'components' ) : foreach ( $ component -> components as & $ subComponent ) { $ resolve ( $ subComponent ) ; } break ; case property_exists ( $ component , 'columns' ) : foreach ( $ component -> columns as & $ column ) { foreach ( $ column -> components as & $ subComponent ) { $ resolve ( $ subComponent ) ; } } break ; case property_exists ( $ component , 'defaultValue' ) : if ( null !== $ component -> defaultValue ) { try { $ component -> defaultValue = $ resolverCollection -> resolve ( $ component -> defaultValue ) ; } catch ( UnresolvedException $ exception ) { $ component -> defaultValue = null ; } catch ( UnmatchedException $ exception ) { } } break ; } } ; foreach ( $ components as & $ component ) { $ resolve ( $ component ) ; } $ form -> setSchema ( $ components ) ; break ; case Form :: TYPE_SYMFONY : break ; default : throw new DomainException ( 'Form type does not exist.' ) ; } return $ form ; }
3218	function chunkedUploadFinish ( $ uploadId , $ path , $ writeMode ) { Checker :: argStringNonEmpty ( "uploadId" , $ uploadId ) ; Path :: checkArgNonRoot ( "path" , $ path ) ; WriteMode :: checkArg ( "writeMode" , $ writeMode ) ; $ params = array_merge ( array ( "upload_id" => $ uploadId ) , $ writeMode -> getExtraParams ( ) ) ; $ response = $ this -> doPost ( $ this -> contentHost , $ this -> appendFilePath ( "1/commit_chunked_upload" , $ path ) , $ params ) ; if ( $ response -> statusCode === 404 ) return null ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; return RequestUtil :: parseResponseJson ( $ response -> body ) ; }
3174	private function getTimeConstraint ( TestSession $ session , QtiComponent $ source , $ navigationMode ) { $ constraint = new QtiTimeConstraint ( $ source , $ session -> getTimerDuration ( $ source -> getIdentifier ( ) ) , $ navigationMode , true , true , $ session -> getTimerTarget ( ) ) ; $ constraint -> setTimer ( $ session -> getTimer ( ) ) ; return $ constraint ; }
9440	protected function value ( $ name ) { $ object = isset ( $ this -> instances [ $ name ] ) ? $ this -> get ( $ name ) : null ; $ exists = ! $ object && $ this -> extra -> has ( $ name ) === true ; return $ exists === true ? $ this -> extra -> get ( $ name ) : $ object ; }
5414	public function getRequestLine ( $ method ) { $ url = $ this -> getUrl ( ) ; $ scheme = $ url -> getScheme ( ) ? $ url -> getScheme ( ) : 'http' ; $ port = $ url -> getPort ( ) ? ':' . $ url -> getPort ( ) : '' ; return $ method . ' ' . $ scheme . '://' . $ url -> getHost ( ) . $ port . $ url -> getPath ( ) . $ url -> getEncodedRequest ( ) . ' HTTP/1.0' ; }
11479	protected function send ( RequestInterface $ request ) : ResponseInterface { $ request = $ request -> withHeader ( "Authorization" , sprintf ( "Bearer %s" , $ this -> apiToken ) ) ; $ request = $ request -> withHeader ( "Content-Type" , "application/json" ) ; $ request = $ request -> withHeader ( "Accept" , "application/json" ) ; try { $ response = $ this -> client -> send ( $ request ) ; } catch ( GuzzleException $ e ) { if ( $ e -> getCode ( ) === 401 ) { throw new ClientException ( "Authorization failed. Did you specify the right api token?" , $ request , null , $ e ) ; } throw new ClientException ( sprintf ( "Failed to execute request (code %d): %s" , $ e -> getCode ( ) , $ e -> getMessage ( ) ) , $ request , null , $ e ) ; } return $ response ; }
2604	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ activateVcl = $ this -> getRequest ( ) -> getParam ( 'activate_flag' ) ; $ service = $ this -> api -> checkServiceDetails ( ) ; $ this -> vcl -> checkCurrentVersionActive ( $ service -> versions , $ activeVersion ) ; $ currActiveVersion = $ this -> vcl -> getCurrentVersion ( $ service -> versions ) ; $ clone = $ this -> api -> cloneVersion ( $ currActiveVersion ) ; $ checkIfSettingExists = $ this -> api -> hasSnippet ( $ activeVersion , Config :: WAF_SETTING_NAME ) ; $ snippet = $ this -> config -> getVclSnippets ( Config :: VCL_WAF_PATH , Config :: VCL_WAF_ALLOWLIST_SNIPPET ) ; $ acls = $ this -> prepareAcls ( $ this -> config -> getWafAllowByAcl ( ) ) ; $ allowedItems = $ acls ; $ strippedAllowedItems = substr ( $ allowedItems , 0 , strrpos ( $ allowedItems , '||' , - 1 ) ) ; if ( ! $ checkIfSettingExists ) { foreach ( $ snippet as $ key => $ value ) { if ( $ strippedAllowedItems === '' ) { $ value = '' ; } else { $ value = str_replace ( '####WAF_ALLOWLIST####' , $ strippedAllowedItems , $ value ) ; } $ snippetData = [ 'name' => Config :: FASTLY_MAGENTO_MODULE . '_waf_' . $ key , 'type' => $ key , 'dynamic' => 1 , 'priority' => 10 , 'content' => $ value ] ; $ this -> api -> uploadSnippet ( $ clone -> number , $ snippetData ) ; } } else { foreach ( $ snippet as $ key => $ value ) { $ name = Config :: FASTLY_MAGENTO_MODULE . '_waf_' . $ key ; if ( $ this -> api -> hasSnippet ( $ clone -> number , $ name ) == true ) { $ this -> api -> removeSnippet ( $ clone -> number , $ name ) ; } } } $ this -> api -> validateServiceVersion ( $ clone -> number ) ; if ( $ activateVcl === 'true' ) { $ this -> api -> activateVersion ( $ clone -> number ) ; } $ this -> sendWebhook ( $ checkIfSettingExists , $ clone ) ; $ comment = [ 'comment' => 'Magento Module turned ON WAF ACL Bypass' ] ; if ( $ checkIfSettingExists ) { $ comment = [ 'comment' => 'Magento Module turned OFF WAF ACL Bypass' ] ; } $ this -> api -> addComment ( $ clone -> number , $ comment ) ; return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
2959	public function confFlowControl ( $ mode ) { if ( $ this -> _dState !== SERIAL_DEVICE_SET ) { trigger_error ( "Unable to set flow control mode : the device is " . "either not set or opened" , E_USER_WARNING ) ; return false ; } $ linuxModes = array ( "none" => "clocal -crtscts -ixon -ixoff" , "rts/cts" => "-clocal crtscts -ixon -ixoff" , "xon/xoff" => "-clocal -crtscts ixon ixoff" ) ; $ windowsModes = array ( "none" => "xon=off octs=off rts=on" , "rts/cts" => "xon=off octs=on rts=hs" , "xon/xoff" => "xon=on octs=off rts=on" , ) ; if ( $ mode !== "none" and $ mode !== "rts/cts" and $ mode !== "xon/xoff" ) { trigger_error ( "Invalid flow control mode specified" , E_USER_ERROR ) ; return false ; } if ( $ this -> _os === "linux" ) { $ ret = $ this -> _exec ( "stty -F " . $ this -> _device . " " . $ linuxModes [ $ mode ] , $ out ) ; } elseif ( $ this -> _os === "osx" ) { $ ret = $ this -> _exec ( "stty -f " . $ this -> _device . " " . $ linuxModes [ $ mode ] , $ out ) ; } else { $ ret = $ this -> _exec ( "mode " . $ this -> _winDevice . " " . $ windowsModes [ $ mode ] , $ out ) ; } if ( $ ret === 0 ) { return true ; } else { trigger_error ( "Unable to set flow control : " . $ out [ 1 ] , E_USER_ERROR ) ; return false ; } }
7781	public function get ( $ key ) { if ( array_key_exists ( $ key , $ this -> messages ) ) { return ! empty ( $ this -> messages [ $ key ] ) ? $ this -> messages [ $ key ] : null ; } return null ; }
3265	protected function preserveLines ( $ data , bool $ reverse ) { $ search = [ "\n" , "\r" ] ; $ replace = [ '\\n' , '\\r' ] ; if ( $ reverse ) { $ search = [ '\\n' , '\\r' ] ; $ replace = [ "\n" , "\r" ] ; } if ( is_string ( $ data ) ) { $ data = str_replace ( $ search , $ replace , $ data ) ; } elseif ( is_array ( $ data ) ) { foreach ( $ data as & $ value ) { $ value = $ this -> preserveLines ( $ value , $ reverse ) ; } unset ( $ value ) ; } return $ data ; }
12368	public function set ( string $ name , string $ value = null ) : Headers { if ( $ value !== null ) { header ( $ name . ': ' . $ value ) ; } else { header ( $ name ) ; } return $ this ; }
7917	protected function renderInput ( ) { return $ this -> hasModel ( ) ? Html :: activeRadio ( $ this -> model , $ this -> attribute , $ this -> options ) : Html :: radio ( $ this -> name , $ this -> checked , $ this -> options ) ; }
6760	static public function buildCacheKey ( $ columns = '*' , array $ conditionsAndOptions = [ ] ) { foreach ( $ conditionsAndOptions as & $ value ) { if ( $ value instanceof DbExpr ) { $ value = $ value -> get ( ) ; } else if ( is_object ( $ value ) ) { throw new \ InvalidArgumentException ( '$conditionsAndOptions argument may contain only strings and objects of class \PeskyORM\Core\DbExpr.' . ' Object of class ' . get_class ( $ value ) . ' detected' ) ; } } unset ( $ value ) ; if ( is_array ( $ columns ) ) { foreach ( $ columns as & $ value ) { if ( $ value instanceof DbExpr ) { $ value = $ value -> get ( ) ; } else if ( is_object ( $ value ) ) { throw new \ InvalidArgumentException ( '$columns argument may contain only strings and objects of class \PeskyORM\Core\DbExpr.' . ' Object of class ' . get_class ( $ value ) . ' detected' ) ; } } unset ( $ value ) ; } else if ( $ columns instanceof DbExpr ) { $ columns = $ columns -> get ( ) ; } return hash ( 'sha256' , json_encode ( array ( $ columns , $ conditionsAndOptions ) ) ) ; }
3883	public function getBackendIcon ( $ icon , $ defaultIcon = 'bundles/metamodelscore/images/icons/metamodels.png' ) { $ realIcon = $ this -> convertValueToPath ( $ icon , $ defaultIcon ) ; $ targetPath = $ this -> outputPath . '/' . basename ( $ realIcon ) ; if ( \ file_exists ( $ targetPath ) ) { return $ this -> webPath . '/' . basename ( $ realIcon ) ; } $ this -> imageFactory -> create ( $ realIcon , [ 16 , 16 , 'center_center' ] , $ targetPath ) ; return $ this -> webPath . '/' . basename ( $ realIcon ) ; }
4597	public function setDeserializeValues ( ? bool $ deserializeValues ) { $ this -> deserializeValues = $ deserializeValues ; $ this -> _deserializeValues = null !== $ deserializeValues ; return $ this ; }
6713	public function getParameter ( $ key , $ default = null ) { if ( array_key_exists ( $ key , $ this -> parameters ) ) { return $ this -> parameters [ $ key ] ; } $ flatKey = $ this -> flatten ( $ key ) ; foreach ( $ this -> parameters as $ index => $ value ) { if ( $ flatKey == $ this -> flatten ( $ index ) ) { return $ value ; } } return $ default ; }
12492	public static function orderBy ( $ field , $ order ) { if ( ! $ order ) { $ order = 'DESC' ; } $ order = strtoupper ( $ order ) ; if ( ! ( $ order == 'ASC' || $ order == 'DESC' ) ) { throw new ClusterpointException ( "\"->order()\" function: ordering should be DESC or ASC." , 9002 ) ; } if ( ! ( gettype ( $ field ) == "string" || $ field instanceof Key || $ field instanceof Raw ) ) { throw new ClusterpointException ( "\"->order()\" function: passed field selector is not in valid format." , 9002 ) ; } if ( $ field instanceof Key ) { $ field = self :: field ( "{$field}" ) ; } return "{$field} {$order}" ; }
11132	public function exec ( ) { if ( $ this -> customQuery ) { return $ this -> execCustom ( ) ; } $ this -> last_wheres = $ this -> wheres ; $ this -> last_distinct = $ this -> distinct ; $ this -> last_ins = $ this -> ins ; $ this -> last_groupBys = $ this -> groupBys ; $ this -> last_havings = $ this -> havings ; $ this -> last_joins = $ this -> joins ; $ this -> calculate ( ) ; try { $ result = $ this -> db -> query ( $ this -> query ) ; } catch ( \ PDOException $ e ) { if ( $ this -> config [ 'mode' ] == 'development' ) { echo $ this -> getQuery ( ) ; } $ this -> reset ( ) ; throw $ e ; } $ this -> reset ( ) ; $ dbResult = new Db_MySQLResult ( $ result , $ this -> db ) ; return $ dbResult ; }
5478	protected function setWidget ( $ tag ) { if ( strtolower ( $ tag -> getAttribute ( 'type' ) ) === 'radio' ) { $ this -> addRadioButton ( $ tag ) ; } elseif ( strtolower ( $ tag -> getAttribute ( 'type' ) ) === 'checkbox' ) { $ this -> addCheckbox ( $ tag ) ; } else { $ this -> widgets [ ] = $ tag ; } }
1099	protected function resolveNode ( $ node ) { if ( $ node instanceof \ Baum \ Node ) return $ node -> reload ( ) ; return $ this -> node -> newNestedSetQuery ( ) -> find ( $ node ) ; }
244	public function export ( ) { openlog ( $ this -> identity , $ this -> options , $ this -> facility ) ; foreach ( $ this -> messages as $ message ) { if ( syslog ( $ this -> _syslogLevels [ $ message [ 1 ] ] , $ this -> formatMessage ( $ message ) ) === false ) { throw new LogRuntimeException ( 'Unable to export log through system log!' ) ; } } closelog ( ) ; }
1484	public static function create ( $ mediaType , $ decoder ) : self { if ( is_string ( $ mediaType ) ) { $ mediaType = MediaType :: parse ( 0 , $ mediaType ) ; } if ( ! $ mediaType instanceof MediaTypeInterface ) { throw new \ InvalidArgumentException ( 'Expecting a media type object or string.' ) ; } if ( is_string ( $ decoder ) ) { $ decoder = app ( $ decoder ) ; } if ( ! $ decoder instanceof DecoderInterface ) { throw new \ InvalidArgumentException ( 'Expecting a decoder or decoder service name.' ) ; } return new self ( $ mediaType , $ decoder ) ; }
2564	public static function generateSomewhatRandomString ( $ length = 22 ) { $ chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz" ; srand ( ( double ) microtime ( ) * 1000000 ) ; $ i = 0 ; $ somewhatRandom = '' ; while ( $ i < $ length ) { $ num = rand ( ) % 60 ; $ tmp = substr ( $ chars , $ num , 1 ) ; $ somewhatRandom = $ somewhatRandom . $ tmp ; $ i ++ ; } return $ somewhatRandom ; }
6013	public function listProtocols ( CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/deployment/protocols' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new Protocol ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
4714	public function replaceString ( $ search , $ replace ) { $ this -> text = str_replace ( $ search , $ replace , $ this -> text ) ; return $ this ; }
2352	public function sendToBrowser ( $ filename = '' , $ inline = false ) { $ response = new BinaryFileResponse ( $ this -> strRootDir . '/' . $ this -> strFile ) ; $ response -> setContentDisposition ( $ inline ? ResponseHeaderBag :: DISPOSITION_INLINE : ResponseHeaderBag :: DISPOSITION_ATTACHMENT , $ filename , Utf8 :: toAscii ( $ this -> basename ) ) ; $ response -> headers -> addCacheControlDirective ( 'must-revalidate' ) ; $ response -> headers -> addCacheControlDirective ( 'post-check' , 0 ) ; $ response -> headers -> addCacheControlDirective ( 'pre-check' , 0 ) ; $ response -> headers -> set ( 'Connection' , 'close' ) ; throw new ResponseException ( $ response ) ; }
5566	public function get ( $ url , $ parameters = false ) { if ( ! is_object ( $ url ) ) { $ url = new SimpleUrl ( $ url ) ; } if ( $ this -> getUrl ( ) ) { $ url = $ url -> makeAbsolute ( $ this -> getUrl ( ) ) ; } return $ this -> load ( $ url , new SimpleGetEncoding ( $ parameters ) ) ; }
9709	private function writeCodepage ( ) { $ record = 0x0042 ; $ length = 0x0002 ; $ cv = $ this -> codepage ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ cv ) ; $ this -> append ( $ header . $ data ) ; }
11899	public function getDuration ( ) { $ ended = microtime ( true ) ; if ( $ this -> ended ) { $ ended = strtotime ( $ this -> ended ) ; } $ started = strtotime ( $ this -> started ) ; return Date :: niceDuration ( $ ended - $ started ) ; }
5792	private function setConstraints ( ) { $ q = new QueryBuilder ( "SELECT ccu.column_name, tc.constraint_type FROM INFORMATION_SCHEMA.constraint_column_usage ccu JOIN information_schema.table_constraints tc ON ccu.constraint_name = tc.constraint_name WHERE tc.table_name = ccu.table_name AND ccu.table_name = $1" , $ this -> tableName ) ; $ qResult = $ q -> execute ( ) ; while ( $ qRow = pg_fetch_assoc ( $ qResult ) ) { switch ( $ qRow [ 'constraint_type' ] ) { case 'PRIMARY KEY' : $ this -> primaryKeyColumnName = $ qRow [ 'column_name' ] ; break ; case 'UNIQUE' : $ this -> uniqueColumnNames [ ] = $ qRow [ 'column_name' ] ; } } }
7017	private function formatG ( & $ str ) { if ( strstr ( $ str , '%G' ) ) $ str = str_replace ( '%G' , sprintf ( '%1d' , $ this -> hour ) , $ str ) ; }
1500	public function unless ( bool $ test , $ encodings ) : self { return $ this -> when ( true !== $ test , $ encodings ) ; }
1409	public function memberRequired ( string $ path , string $ member ) : ErrorInterface { return new Error ( null , null , Response :: HTTP_BAD_REQUEST , $ this -> trans ( 'member_required' , 'code' ) , $ this -> trans ( 'member_required' , 'title' ) , $ this -> trans ( 'member_required' , 'detail' , compact ( 'member' ) ) , $ this -> pointer ( $ path ) ) ; }
8412	public function isConnected ( ) : bool { if ( isset ( $ this -> servers [ 'all' ] ) === true ) { return isset ( $ this -> servers [ 'all' ] [ 'link' ] ) ; } return isset ( $ this -> servers [ 'read' ] [ 'link' ] ) && isset ( $ this -> servers [ 'write' ] [ 'link' ] ) ; }
9742	public function addPrintAreaByColumnAndRow ( $ column1 , $ row1 , $ column2 , $ row2 , $ index = - 1 ) { return $ this -> setPrintArea ( Coordinate :: stringFromColumnIndex ( $ column1 ) . $ row1 . ':' . Coordinate :: stringFromColumnIndex ( $ column2 ) . $ row2 , $ index , self :: SETPRINTRANGE_INSERT ) ; }
9088	public function slurp ( ) : string { $ str = "" ; while ( $ this -> ready ( ) ) { $ str .= $ this -> read ( $ this -> count ( ) ) ; } return $ str ; }
12425	public function getAuthorizerToken ( $ appId , $ refreshToken ) { $ params = [ 'component_appid' => $ this -> getAppId ( ) , 'authorizer_appid' => $ appId , 'authorizer_refresh_token' => $ refreshToken , ] ; return $ this -> parseJSON ( 'json' , [ self :: GET_AUTHORIZER_TOKEN , $ params ] ) ; }
93	public function filter ( $ relativePath , $ exclude ) { foreach ( $ this -> excludePatterns as $ patternData ) { list ( $ pattern , $ negate , $ stripLeadingSlash ) = $ patternData ; if ( $ stripLeadingSlash ) { $ path = substr ( $ relativePath , 1 ) ; } else { $ path = $ relativePath ; } if ( preg_match ( $ pattern , $ path ) ) { $ exclude = ! $ negate ; } } return $ exclude ; }
3794	private function checkForAction ( $ clipboard , $ action ) { $ filter = new Filter ( ) ; $ filter -> andActionIs ( $ action ) ; $ items = $ clipboard -> fetch ( $ filter ) ; if ( $ items === null ) { return ; } foreach ( $ items as $ item ) { $ itemProviderName = $ item -> getDataProviderName ( ) ; $ modelId = $ item -> getModelId ( ) ; if ( $ this -> providerName !== $ itemProviderName ) { continue ; } if ( ! $ modelId ) { $ this -> checkEmpty ( $ action ) ; continue ; } $ containedModel = $ this -> getModelById ( $ modelId -> getId ( ) ) ; if ( $ this -> currentModel == null ) { $ this -> checkForRoot ( $ containedModel , $ action ) ; } elseif ( $ containedModel ) { $ this -> checkForModel ( $ containedModel , $ action ) ; } else { $ this -> checkEmpty ( $ action ) ; } } }
7891	protected function triggerDeploy ( $ project ) { if ( ! $ project ) { throw new InvalidArgumentException ( 'Incorrect project hook.' ) ; } file_get_contents ( sprintf ( self :: DEPLOY_URL , $ project ) ) ; $ this -> info ( 'Deployment request successful!' ) ; }
2935	public function backup ( ) { if ( ! is_file ( $ this -> filePath ) ) { throw new FileNotFoundException ( "File does not exist at path {$this->filePath}" ) ; return false ; } copy ( $ this -> filePath , $ this -> backupPath . self :: BACKUP_FILENAME_PREFIX . date ( 'Y_m_d_His' ) . self :: BACKUP_FILENAME_SUFFIX ) ; return $ this ; }
9768	function lengthOf ( int $ value = null ) : self { if ( $ value === null ) return $ this -> setFlag ( 'length' ) ; if ( is_string ( $ this -> target ) ) { $ constraint = equalTo ( $ value ) ; $ target = mb_strlen ( $ this -> target ) ; } else { $ constraint = countOf ( $ value ) ; $ target = $ this -> target ; } return $ this -> expect ( $ target , $ constraint ) ; }
10942	private function reset ( ) { $ time = new \ DateTime ( ) ; $ this -> driver -> set ( self :: LAST_UPDATE_KEY , $ time ) ; return $ time ; }
8778	public function redirect ( $ data = null , int $ statusCode = 301 , $ secure = false ) { if ( substr ( $ data , 0 , 4 ) === 'http' || substr ( $ data , 0 , 5 ) === 'https' ) { header ( 'Location: ' . $ data , true , $ statusCode ) ; } else { $ data = ( ! is_null ( $ data ) ) ? $ this -> url . '/' . $ data : $ this -> url ; header ( 'Location: ' . $ this -> getUrl ( $ data , $ secure ) , true , $ statusCode ) ; } die ( ) ; }
8765	public static function getNextAvailableVariableName ( string $ variable , array $ usedVariables ) : string { $ variable = self :: toVariableName ( $ variable ) ; while ( true ) { if ( ! in_array ( $ variable , $ usedVariables , true ) ) { break ; } $ numbers = '' ; while ( true ) { $ lastCharacter = substr ( $ variable , strlen ( $ variable ) - 1 ) ; if ( $ lastCharacter >= '0' && $ lastCharacter <= '9' ) { $ numbers = $ lastCharacter . $ numbers ; $ variable = substr ( $ variable , 0 , strlen ( $ variable ) - 1 ) ; } else { break ; } } if ( $ numbers === '' ) { $ numbers = 0 ; } else { $ numbers = ( int ) $ numbers ; } ++ $ numbers ; $ variable = $ variable . $ numbers ; } return $ variable ; }
3123	protected function computeRange ( $ range ) { if ( count ( $ range ) % 2 ) { throw new IncompleteRangeException ( ) ; } $ duration = 0 ; $ start = null ; $ end = null ; foreach ( $ range as $ point ) { if ( $ this -> isStartPoint ( $ point ) ) { if ( $ start ) { throw new MalformedRangeException ( 'A time range must be defined by a START and a END TimePoint! Twice START found.' ) ; } $ start = $ point ; } if ( $ this -> isEndPoint ( $ point ) ) { if ( $ end ) { throw new MalformedRangeException ( 'A time range must be defined by a START and a END TimePoint! Twice END found.' ) ; } $ end = $ point ; } if ( $ start && $ end ) { $ duration += $ this -> getRangeDuration ( $ start , $ end ) ; $ start = null ; $ end = null ; } } return $ duration ; }
4053	private function fetchConditions ( $ inputScreenId ) : array { $ builder = $ this -> connection -> createQueryBuilder ( ) ; return $ builder -> select ( 'cond.*' , 'setting.attr_id AS setting_attr_id' ) -> from ( 'tl_metamodel_dcasetting_condition' , 'cond' ) -> leftJoin ( 'cond' , 'tl_metamodel_dcasetting' , 'setting' , 'cond.settingId=setting.id' ) -> leftJoin ( 'setting' , 'tl_metamodel_dca' , 'dca' , 'setting.pid=dca.id' ) -> where ( 'cond.enabled=1' ) -> andWhere ( 'setting.published=1' ) -> andWhere ( 'dca.id=:screenId' ) -> setParameter ( 'screenId' , $ inputScreenId ) -> orderBy ( 'pid' ) -> addOrderBy ( 'sorting' ) -> execute ( ) -> fetchAll ( \ PDO :: FETCH_ASSOC ) ; }
12557	private static function init ( ) : void { static $ inited = false ; if ( ! $ inited ) { if ( ! isset ( $ _SESSION [ 'Booby' ] ) || ! $ _SESSION [ 'Booby' ] ) { $ _SESSION [ 'Booby' ] = [ ] ; } self :: $ store = & $ _SESSION [ 'Booby' ] ; $ inited = true ; } }
5176	public function add ( string $ key , $ value ) : self { if ( ! array_key_exists ( $ key , $ this -> props ) ) { return $ this -> addNew ( $ key , $ value ) ; } if ( is_array ( $ this -> props [ $ key ] ) ) { return $ this -> addArray ( $ key , $ value ) ; } return $ this -> appendToArray ( $ key , $ value ) ; }
1028	private function resolveField ( ObjectType $ parentType , $ source , $ fieldNodes , $ path ) { $ exeContext = $ this -> exeContext ; $ fieldNode = $ fieldNodes [ 0 ] ; $ fieldName = $ fieldNode -> name -> value ; $ fieldDef = $ this -> getFieldDef ( $ exeContext -> schema , $ parentType , $ fieldName ) ; if ( ! $ fieldDef ) { return self :: $ UNDEFINED ; } $ returnType = $ fieldDef -> getType ( ) ; $ info = new ResolveInfo ( $ fieldName , $ fieldNodes , $ returnType , $ parentType , $ path , $ exeContext -> schema , $ exeContext -> fragments , $ exeContext -> rootValue , $ exeContext -> operation , $ exeContext -> variableValues ) ; if ( $ fieldDef -> resolveFn !== null ) { $ resolveFn = $ fieldDef -> resolveFn ; } elseif ( $ parentType -> resolveFieldFn !== null ) { $ resolveFn = $ parentType -> resolveFieldFn ; } else { $ resolveFn = $ this -> exeContext -> fieldResolver ; } $ context = $ exeContext -> contextValue ; $ result = $ this -> resolveOrError ( $ fieldDef , $ fieldNode , $ resolveFn , $ source , $ context , $ info ) ; $ result = $ this -> completeValueCatchingError ( $ returnType , $ fieldNodes , $ info , $ path , $ result ) ; return $ result ; }
7560	protected function parse_gt ( ) { if ( ( ( $ this -> pos + 1 ) < $ this -> size ) && ( $ this -> doc [ $ this -> pos + 1 ] === '=' ) ) { ++ $ this -> pos ; return ( $ this -> token = self :: TOK_COMPARE_BIGGER_THAN ) ; } else { return ( $ this -> token = self :: TOK_CHILD ) ; } }
12289	private function make ( string $ block , array $ vars = null ) : string { $ commonVars = static :: COMMON_NAME . static :: VARS_PROPERTY_SUFFIX ; $ blockVars = $ block . static :: VARS_PROPERTY_SUFFIX ; $ allVars = [ ] ; if ( isset ( $ this -> $ commonVars ) && is_array ( $ this -> $ commonVars ) ) { $ allVars = $ this -> $ commonVars ; } if ( isset ( $ this -> $ blockVars ) && is_array ( $ this -> $ blockVars ) ) { $ allVars += $ this -> $ blockVars ; } if ( isset ( $ vars ) ) { $ allVars += $ vars ; } $ file = $ this -> path . $ this -> { $ block . static :: BLOCK_PROPERTY_SUFFIX } . '.' . static :: FILE_EXTENSION ; $ localScope = function ( $ vars , $ file ) { ob_start ( ) ; extract ( $ vars ) ; try { require $ file ; } catch ( \ Exception $ exception ) { ob_end_clean ( ) ; throw $ exception ; } $ _ = isset ( $ _ ) ? str_pad ( '' , $ _ ) : '' ; return str_replace ( PHP_EOL , PHP_EOL . $ _ , PHP_EOL . ob_get_clean ( ) ) ; } ; return $ localScope ( $ allVars , $ file ) ; }
5969	protected static function sortFileList ( array $ a , array $ b ) { if ( ! array_key_exists ( "src" , $ a ) || ! array_key_exists ( "src" , $ b ) || ! array_key_exists ( "type" , $ a ) || ! array_key_exists ( "type" , $ b ) ) { return 0 ; throw new Ts3Exception ( "invalid parameter" , 0x602 ) ; } if ( $ a [ "type" ] != $ b [ "type" ] ) { return ( $ a [ "type" ] < $ b [ "type" ] ) ? - 1 : 1 ; } return strcmp ( strtolower ( $ a [ "src" ] ) , strtolower ( $ b [ "src" ] ) ) ; }
6705	public function getWriterFactory ( ) { if ( ! $ this -> writerFactory ) { $ xmlFormatter = new Xml ( ) ; $ jsonFormatter = new Json ( ) ; $ this -> writerFactory = new WriterFactory ( [ 'xml' => $ xmlFormatter , 'text/xml' => $ xmlFormatter , 'application/xml' => $ xmlFormatter , 'json' => $ jsonFormatter , 'application/json' => $ jsonFormatter , ] ) ; } return $ this -> writerFactory ; }
8585	public function setProductGroupList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ProductGroupList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
11266	public function library ( $ pathname , & $ caller = false , $ exposeToView = false ) { $ name = $ this -> getName ( $ pathname ) ; $ path = $ this -> getPath ( $ pathname ) ; if ( $ caller ) { if ( $ this -> getPathBackslash ( $ pathname ) == '' ) { $ lib = '\\Cora\\' . $ name ; } else { $ lib = $ pathname ; } $ libObj = new $ lib ( $ caller ) ; $ caller -> $ name = $ libObj ; if ( $ exposeToView ) $ caller -> setData ( $ name , $ libObj ) ; } }
6247	public function dirs ( ? int $ constraints = null ) : \ Generator { foreach ( $ this -> all ( $ constraints ) as $ directory ) { if ( $ directory -> isDir ( ) ) { yield $ directory ; } } }
288	protected function negotiateLanguage ( $ request ) { if ( ! empty ( $ this -> languageParam ) && ( $ language = $ request -> get ( $ this -> languageParam ) ) !== null ) { if ( is_array ( $ language ) ) { return reset ( $ this -> languages ) ; } if ( isset ( $ this -> languages [ $ language ] ) ) { return $ this -> languages [ $ language ] ; } foreach ( $ this -> languages as $ key => $ supported ) { if ( is_int ( $ key ) && $ this -> isLanguageSupported ( $ language , $ supported ) ) { return $ supported ; } } return reset ( $ this -> languages ) ; } foreach ( $ request -> getAcceptableLanguages ( ) as $ language ) { if ( isset ( $ this -> languages [ $ language ] ) ) { return $ this -> languages [ $ language ] ; } foreach ( $ this -> languages as $ key => $ supported ) { if ( is_int ( $ key ) && $ this -> isLanguageSupported ( $ language , $ supported ) ) { return $ supported ; } } } return reset ( $ this -> languages ) ; }
9502	public function runPeridot ( InputInterface $ input , OutputInterface $ output ) { global $ argv ; $ command = $ this -> joinCommand ( $ argv ) ; $ process = new Process ( $ command ) ; $ process -> run ( function ( $ type , $ buffer ) use ( $ output ) { $ buffer = preg_replace ( '/\[([\d]{1,2})m/' , "\033[$1m" , $ buffer ) ; $ output -> write ( $ buffer ) ; } ) ; }
6504	public function serializeParameters ( $ type , array $ parameters ) { $ jobType = $ this -> registry -> get ( $ type ) ; $ indices = $ jobType -> getIndicesOfSerializableParameters ( ) ; if ( count ( $ indices ) < count ( $ parameters ) ) { throw new \ InvalidArgumentException ( sprintf ( 'More parameters provided for serialization than defined for job "%s"' , $ type ) ) ; } $ i = 0 ; $ serializedParameters = array ( ) ; foreach ( $ parameters as $ parameter ) { if ( null == $ parameter ) { $ serializedParameters [ ] = null ; } else { $ serializedParameters [ ] = $ this -> serializer -> serialize ( $ parameter , 'json' , $ this -> getParamSerializationContext ( $ jobType , $ indices [ $ i ] ) ) ; } $ i ++ ; } $ data = json_encode ( $ serializedParameters ) ; if ( false === $ data ) { throw new \ RuntimeException ( sprintf ( 'Serialization failed with error "%s"' , json_last_error_msg ( ) ) ) ; } return $ data ; }
1868	public function maintenanceCheck ( ) { $ this -> import ( BackendUser :: class , 'User' ) ; if ( ! $ this -> User -> hasAccess ( 'maintenance' , 'modules' ) ) { return '' ; } try { if ( System :: getContainer ( ) -> get ( 'lexik_maintenance.driver.factory' ) -> getDriver ( ) -> isExists ( ) ) { return '<p class="tl_error">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'maintenanceEnabled' ] . '</p>' ; } } catch ( \ Exception $ e ) { } return '' ; }
7706	function _ApplyDiffFromStart ( $ Diff ) { $ this -> pST_PosEnd += $ Diff ; $ this -> pST_Src = false ; if ( $ this -> pET_PosBeg !== false ) $ this -> pET_PosBeg += $ Diff ; $ this -> PosEnd += $ Diff ; }
2058	public function makeRedirectPageMandatory ( Contao \ DataContainer $ dc ) { $ objPage = $ this -> Database -> prepare ( "SELECT * FROM " . $ dc -> table . " WHERE id=?" ) -> limit ( 1 ) -> execute ( $ dc -> id ) ; if ( $ objPage -> numRows && $ objPage -> type == 'logout' ) { $ GLOBALS [ 'TL_DCA' ] [ 'tl_page' ] [ 'fields' ] [ 'jumpTo' ] [ 'eval' ] [ 'mandatory' ] = true ; } }
12600	public static function copy ( $ src , $ dest , $ force = true ) { $ src = Path :: clean ( $ src ) ; $ dest = Path :: clean ( $ dest ) ; if ( ! Folder :: exists ( dirname ( $ dest ) ) ) { Folder :: create ( dirname ( $ dest ) ) ; } $ fs = new Filesystem ( ) ; try { $ fs -> copy ( $ src , $ dest , $ force ) ; } catch ( IOExceptionInterface $ e ) { throw new Exception ( Helper :: getTranslation ( 'CANNOT_FIND_SOURCE' ) . ' ' . $ e -> getPath ( ) ) ; } return true ; }
531	protected function splitChangelog ( $ file , $ version ) { $ lines = explode ( "\n" , file_get_contents ( $ file ) ) ; $ start = [ ] ; $ changelog = [ ] ; $ end = [ ] ; $ state = 'start' ; foreach ( $ lines as $ l => $ line ) { if ( isset ( $ lines [ $ l - 2 ] ) && strpos ( $ lines [ $ l - 2 ] , $ version ) !== false && isset ( $ lines [ $ l - 1 ] ) && strncmp ( $ lines [ $ l - 1 ] , '---' , 3 ) === 0 ) { $ state = 'changelog' ; } if ( $ state === 'changelog' && isset ( $ lines [ $ l + 1 ] ) && strncmp ( $ lines [ $ l + 1 ] , '---' , 3 ) === 0 ) { $ state = 'end' ; } if ( ! empty ( $ { $ state } ) && trim ( $ line ) !== '' && strncmp ( $ line , '- ' , 2 ) !== 0 ) { end ( $ { $ state } ) ; $ { $ state } [ key ( $ { $ state } ) ] .= "\n" . $ line ; } else { $ { $ state } [ ] = $ line ; } } return [ $ start , $ changelog , $ end ] ; }
6665	public function parseFb ( $ raw_profile ) { $ profile = $ raw_profile ; $ profile -> avatar = sprintf ( 'http://graph.facebook.com/%s/picture' , $ profile -> id ) ; return ( array ) $ profile ; }
10091	protected function checkOptionsArray ( $ options ) { if ( isset ( $ options [ 's' ] ) ) { $ options [ 'size' ] = $ options [ 's' ] ; unset ( $ options [ 's' ] ) ; } if ( isset ( $ options [ 'd' ] ) ) { $ options [ 'default' ] = $ options [ 'd' ] ; unset ( $ options [ 'd' ] ) ; } $ allowedOptions = array ( 'algorithm' => true , 'default' => true , 'https' => true , 'size' => true , ) ; foreach ( $ options as $ key => $ value ) { if ( ! isset ( $ allowedOptions [ $ key ] ) ) { throw new InvalidArgumentException ( 'Invalid option in array: ' . $ key ) ; } } return $ options ; }
5526	protected function createCodeForSubclass ( $ methods ) { $ code = "" ; if ( ! empty ( $ this -> namespace ) ) { $ code .= 'namespace ' . $ this -> namespace . ";\n" ; } $ code .= 'class ' . $ this -> mock_class . ' extends ' . $ this -> class . " {\n" ; $ code .= " public \$mock;\n" ; $ code .= $ this -> addMethodList ( array_merge ( $ methods , $ this -> reflection -> getMethods ( ) ) ) ; $ code .= "\n" ; $ code .= " function __construct() {\n" ; $ code .= ' $this->mock = new \\' . $ this -> mock_base . "();\n" ; $ code .= " \$this->mock->disableExpectationNameChecks();\n" ; $ code .= " }\n" ; $ code .= $ this -> createCodeForConstructor ( ) ; $ code .= $ this -> chainMockReturns ( ) ; $ code .= $ this -> chainMockExpectations ( ) ; $ code .= $ this -> chainThrowMethods ( ) ; $ code .= $ this -> createCodeForOverridenMethods ( $ this -> reflection -> getMethods ( ) ) ; $ code .= $ this -> createCodeForNewMethod ( $ methods ) ; $ code .= "}\n" ; return $ code ; }
4253	public function processLogEntry ( $ method , $ args = array ( ) , $ meta = array ( ) ) { if ( $ method == 'alert' ) { list ( $ method , $ args ) = $ this -> methodAlert ( $ args , $ meta ) ; } elseif ( $ method == 'assert' ) { \ array_unshift ( $ args , false ) ; } elseif ( \ in_array ( $ method , array ( 'count' , 'time' ) ) ) { $ method = 'log' ; } elseif ( \ in_array ( $ method , array ( 'profileEnd' , 'table' ) ) ) { $ method = 'log' ; if ( \ is_array ( $ args [ 0 ] ) ) { $ method = 'table' ; $ args = array ( $ this -> methodTable ( $ args [ 0 ] , $ meta [ 'columns' ] ) ) ; } elseif ( $ meta [ 'caption' ] ) { \ array_unshift ( $ args , $ meta [ 'caption' ] ) ; } } elseif ( $ method == 'trace' ) { $ method = 'table' ; $ args = array ( $ this -> methodTable ( $ args [ 0 ] , array ( 'function' , 'file' , 'line' ) ) ) ; } elseif ( \ in_array ( $ method , array ( 'error' , 'warn' ) ) ) { if ( isset ( $ meta [ 'file' ] ) ) { $ args [ ] = $ meta [ 'file' ] . ': line ' . $ meta [ 'line' ] ; } } if ( ! \ in_array ( $ method , $ this -> consoleMethods ) ) { $ method = 'log' ; } foreach ( $ args as $ k => $ arg ) { $ args [ $ k ] = \ json_encode ( $ this -> dump ( $ arg ) ) ; } $ str = 'console.' . $ method . '(' . \ implode ( ',' , $ args ) . ');' . "\n" ; $ str = \ str_replace ( \ json_encode ( $ this -> debug -> abstracter -> UNDEFINED ) , 'undefined' , $ str ) ; return $ str ; }
10026	function getContacts ( $ page_index = 1 , $ page_size = 100 , $ standard_fields = array ( ) , $ custom_fields = array ( ) ) { $ queryParameters = array ( 'page_index' => $ page_index , 'page_size' => $ page_size , 'standard_field' => $ standard_fields ) ; $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , 'custom_field' , $ custom_fields ) ; return $ this -> get ( 'contacts' , $ queryParameters ) ; }
2360	public static function findPublishedById ( $ intId , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = array ( "$t.id=?" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.disable=''" ; } return static :: findOneBy ( $ arrColumns , $ intId , $ arrOptions ) ; }
5285	public function page ( $ page , $ size = 25 ) { $ size = \ absint ( $ size ) ; $ offset = $ size * \ absint ( $ page ) ; $ this -> limit ( $ size , $ offset ) ; return $ this ; }
4303	public function profile ( $ name = null ) { if ( ! $ this -> cfg [ 'collect' ] ) { return ; } if ( ! $ this -> cfg [ 'enableProfiling' ] ) { $ callerInfo = $ this -> utilities -> getCallerInfo ( ) ; $ this -> appendLog ( __FUNCTION__ , array ( 'Profile: Unable to start - enableProfiling opt not set. ' . $ callerInfo [ 'file' ] . ' on line ' . $ callerInfo [ 'line' ] . '.' ) ) ; return ; } $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) , array ( 'name' => null ) , array ( 'name' ) ) ; if ( $ meta [ 'name' ] === null ) { $ meta [ 'name' ] = 'Profile ' . $ this -> data [ 'profileAutoInc' ] ; $ this -> data [ 'profileAutoInc' ] ++ ; } $ name = $ meta [ 'name' ] ; $ message = '' ; if ( isset ( $ this -> data [ 'profileInstances' ] [ $ name ] ) ) { $ instance = $ this -> data [ 'profileInstances' ] [ $ name ] ; $ instance -> end ( ) ; $ instance -> start ( ) ; unset ( $ this -> data [ 'profileInstances' ] [ $ name ] ) ; $ this -> data [ 'profileInstances' ] [ $ name ] = $ instance ; $ message = 'Profile \'' . $ name . '\' restarted' ; } else { $ this -> data [ 'profileInstances' ] [ $ name ] = $ this -> methodProfile ; $ message = 'Profile \'' . $ name . '\' started' ; } $ this -> appendLog ( __FUNCTION__ , array ( $ message , ) , $ meta ) ; }
2462	public function generateMarkup ( ) { $ intMaxSize = round ( static :: getMaxUploadSize ( ) / 1024 / 1024 ) ; $ strAccepted = implode ( ',' , array_map ( function ( $ a ) { return '.' . $ a ; } , StringUtil :: trimsplit ( ',' , strtolower ( Config :: get ( 'uploadTypes' ) ) ) ) ) ; $ GLOBALS [ 'TL_CSS' ] [ ] = 'assets/dropzone/css/dropzone.min.css' ; $ GLOBALS [ 'TL_JAVASCRIPT' ] [ ] = 'assets/dropzone/js/dropzone.min.js' ; $ return = ' <input type="hidden" name="action" value="fileupload"> <div class="fallback"> <input type="file" name="' . $ this -> strName . '[]" class="tl_upload_field" onfocus="Backend.getScrollOffset()" multiple> </div> <div class="dropzone"> <div class="dz-default dz-message"> <span>' . $ GLOBALS [ 'TL_LANG' ] [ 'tl_files' ] [ 'dropzone' ] . '</span> </div> <span class="dropzone-previews"></span> </div> <script> Dropzone.autoDiscover = false; window.addEvent("domready", function() { new Dropzone("#tl_files", { paramName: "' . $ this -> strName . '", maxFilesize: ' . $ intMaxSize . ', acceptedFiles: "' . $ strAccepted . '", timeout: 0, previewsContainer: ".dropzone-previews", clickable: ".dropzone", dictFileTooBig: ' . json_encode ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_files' ] [ 'dropzoneFileTooBig' ] ) . ', dictInvalidFileType: ' . json_encode ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_files' ] [ 'dropzoneInvalidType' ] ) . ' }).on("addedfile", function() { $$(".dz-message").setStyle("display", "none"); }).on("success", function(file, message) { if (!message) return; var container = $("tl_message"); if (!container) { container = new Element("div", { "id": "tl_message", "class": "tl_message" }).inject($("tl_buttons"), "before"); } container.appendHTML(message); }); $$("div.tl_formbody_submit").setStyle("display", "none"); }); </script>' ; if ( isset ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_files' ] [ 'fileupload' ] [ 1 ] ) ) { $ return .= ' <p class="tl_help tl_tip">' . sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_files' ] [ 'fileupload' ] [ 1 ] , System :: getReadableSize ( static :: getMaxUploadSize ( ) ) , Config :: get ( 'gdMaxImgWidth' ) . 'x' . Config :: get ( 'gdMaxImgHeight' ) ) . '</p>' ; } return $ return ; }
8272	public function validateUsersSection ( & $ config ) { if ( ! isset ( $ config [ "users" ] ) ) { return ; } $ this -> assertArray ( $ config , "users" ) ; foreach ( $ config [ "users" ] as $ username => $ userData ) { $ this -> assertUsername ( $ username , $ config ) ; try { $ this -> validateUserData ( $ userData ) ; } catch ( ConfigurationException $ e ) { $ e -> addBeforeMessage ( "Invalid userdata for $username:" ) ; throw $ e ; } $ lowercaseName = strtolower ( $ username ) ; if ( $ username !== $ lowercaseName ) { if ( ! isset ( $ config [ "users" ] [ $ lowercaseName ] ) ) { $ config [ "users" ] [ $ lowercaseName ] = $ userData ; unset ( $ config [ "users" ] [ $ username ] ) ; } else { throw new ConfigurationException ( "User $username is defined multiple times." ) ; } } } }
11742	public function add ( Theme $ theme , array $ pageValues ) { $ pageName = $ pageValues [ "name" ] ; $ pageDir = $ this -> pagesDir . '/' . $ pageName ; $ this -> pageExists ( $ pageDir ) ; if ( ! @ mkdir ( $ pageDir ) ) { $ this -> folderNotCreated ( $ pageDir ) ; } $ seoValues = $ pageValues [ "seo" ] ; unset ( $ pageValues [ "seo" ] ) ; $ encodedPage = json_encode ( $ pageValues ) ; $ pageFile = $ pageDir . '/' . $ this -> pageFile ; $ event = Dispatcher :: dispatch ( PageCollectionEvents :: PAGE_COLLECTION_ADDING , new PageCollectionAddingEvent ( $ pageFile , $ encodedPage ) ) ; $ encodedPage = $ event -> getFileContent ( ) ; FilesystemTools :: writeFile ( $ pageFile , $ encodedPage ) ; if ( $ this -> pageFile != 'page.json' ) { FilesystemTools :: writeFile ( $ pageDir . '/page.json' , $ encodedPage ) ; } foreach ( $ seoValues as $ seoValue ) { $ languageName = $ seoValue [ "language" ] ; unset ( $ seoValue [ "language" ] ) ; $ languageDir = $ pageDir . '/' . $ languageName ; @ mkdir ( $ languageDir ) ; FilesystemTools :: writeFile ( $ languageDir . '/' . $ this -> seoFile , json_encode ( $ seoValue ) ) ; $ theme -> addTemplateSlots ( $ pageValues [ "template" ] , $ this -> username ) ; } Dispatcher :: dispatch ( PageCollectionEvents :: PAGE_COLLECTION_ADDED , new PageCollectionAddedEvent ( $ pageFile , $ encodedPage ) ) ; DataLogger :: log ( sprintf ( 'Page "%s" was successfully added to the website' , $ pageName ) ) ; return $ pageValues ; }
11531	public static function slotDir ( $ sourceDir , array $ options ) { $ paths = array ( sprintf ( '%s/pages/pages/%s/%s_%s/%s' , $ sourceDir , $ options [ 'page' ] , $ options [ 'language' ] , $ options [ 'country' ] , $ options [ 'slot' ] ) , sprintf ( '%s/slots/%s/%s_%s' , $ sourceDir , $ options [ 'slot' ] , $ options [ 'language' ] , $ options [ 'country' ] ) , sprintf ( '%s/slots/%s' , $ sourceDir , $ options [ 'slot' ] ) , ) ; return self :: cascade ( $ paths ) ; }
9853	public function expiresAt ( $ expires ) { if ( $ expires instanceof DateTimeInterface ) { $ this -> expires = $ expires ; } else { $ this -> expires = null ; } return $ this ; }
3147	public function check ( RunnerServiceContext $ context ) { $ state = $ context -> getTestSession ( ) -> getState ( ) ; if ( $ state == AssessmentTestSessionState :: CLOSED ) { throw new QtiRunnerClosedException ( ) ; } return true ; }
12541	public static function random ( $ length = 8 , $ allowedChars = 'abcdefghjkmnpqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXY346789' ) { $ return = '' ; $ hashLength = strlen ( $ allowedChars ) - 1 ; for ( ; $ length > 0 ; -- $ length ) { $ return .= $ allowedChars { rand ( 0 , $ hashLength ) } ; } return str_shuffle ( $ return ) ; }
877	private function skipClass ( Tokens $ tokens , $ classIndex , $ classOpenIndex , $ classCloseIndex ) { $ prevToken = $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ classIndex ) ] ; if ( ! $ prevToken -> isGivenKind ( T_FINAL ) ) { return true ; } for ( $ index = $ classIndex ; $ index < $ classOpenIndex ; ++ $ index ) { if ( $ tokens [ $ index ] -> isGivenKind ( T_EXTENDS ) ) { return true ; } } $ useIndex = $ tokens -> getNextTokenOfKind ( $ classIndex , [ [ CT :: T_USE_TRAIT ] ] ) ; return $ useIndex && $ useIndex < $ classCloseIndex ; }
2035	public function onUnregister ( Registry $ registry ) { parent :: onUnregister ( $ registry ) ; if ( $ this -> fallback && $ this -> type == 'root' && $ registry -> isRegisteredAlias ( $ this , 'contao.dns-fallback' , $ this -> dns ) ) { $ registry -> unregisterAlias ( $ this , 'contao.dns-fallback' , $ this -> dns ) ; } }
10182	public function unsetWorksheetCells ( ) { if ( $ this -> currentCell !== null ) { $ this -> currentCell -> detach ( ) ; $ this -> currentCell = null ; $ this -> currentCoordinate = null ; } $ this -> __destruct ( ) ; $ this -> index = [ ] ; $ this -> parent = null ; }
5538	public function getFrameFocus ( ) { if ( $ this -> focus === false ) { return array ( ) ; } return array_merge ( array ( $ this -> getPublicNameFromIndex ( $ this -> focus ) ) , $ this -> frames [ $ this -> focus ] -> getFrameFocus ( ) ) ; }
1497	public function push ( Encoding ... $ encodings ) : self { $ copy = new self ( ) ; $ copy -> stack = collect ( $ this -> stack ) -> merge ( $ encodings ) -> all ( ) ; return $ copy ; }
7745	private function findGetter ( ) { $ reflClass = new \ ReflectionClass ( $ this -> class ) ; $ camelProp = $ this -> camelize ( $ this -> name ) ; $ getter = 'get' . $ camelProp ; $ isser = 'is' . $ camelProp ; $ hasser = 'has' . $ camelProp ; $ classHasProperty = $ reflClass -> hasProperty ( $ this -> name ) ; if ( $ reflClass -> hasMethod ( $ this -> name ) && $ reflClass -> getMethod ( $ this -> name ) -> isPublic ( ) ) { $ this -> getter = $ this -> name ; $ this -> getterType = self :: GETTER_SETTER_METHOD ; } elseif ( $ reflClass -> hasMethod ( $ getter ) && $ reflClass -> getMethod ( $ getter ) -> isPublic ( ) ) { $ this -> getter = $ getter ; $ this -> getterType = self :: GETTER_SETTER_METHOD ; } elseif ( $ reflClass -> hasMethod ( $ isser ) && $ reflClass -> getMethod ( $ isser ) -> isPublic ( ) ) { $ this -> getter = $ isser ; $ this -> getterType = self :: GETTER_SETTER_METHOD ; } elseif ( $ reflClass -> hasMethod ( $ hasser ) && $ reflClass -> getMethod ( $ hasser ) -> isPublic ( ) ) { $ this -> getter = $ hasser ; $ this -> getterType = self :: GETTER_SETTER_METHOD ; } elseif ( ( $ reflClass -> hasMethod ( '__get' ) && $ reflClass -> getMethod ( '__get' ) -> isPublic ( ) ) || ( $ classHasProperty && $ reflClass -> getProperty ( $ this -> name ) -> isPublic ( ) ) ) { $ this -> getter = $ this -> name ; $ this -> getterType = self :: GETTER_SETTER_PROPERTY ; } }
9953	public function mergeCells ( $ pRange ) { $ pRange = strtoupper ( $ pRange ) ; if ( strpos ( $ pRange , ':' ) !== false ) { $ this -> mergeCells [ $ pRange ] = $ pRange ; $ aReferences = Coordinate :: extractAllCellReferencesInRange ( $ pRange ) ; $ upperLeft = $ aReferences [ 0 ] ; if ( ! $ this -> cellExists ( $ upperLeft ) ) { $ this -> getCell ( $ upperLeft ) -> setValueExplicit ( null , DataType :: TYPE_NULL ) ; } $ count = count ( $ aReferences ) ; for ( $ i = 1 ; $ i < $ count ; ++ $ i ) { if ( $ this -> cellExists ( $ aReferences [ $ i ] ) ) { $ this -> getCell ( $ aReferences [ $ i ] ) -> setValueExplicit ( null , DataType :: TYPE_NULL ) ; } } } else { throw new Exception ( 'Merge must be set on a range of cells.' ) ; } return $ this ; }
7352	public function getRemainingAmount ( ) { $ amount = 0 ; $ currency = $ this -> getCurrency ( ) -> getCode ( ) ; $ hasDeposit = 1 === Money :: compare ( $ this -> depositTotal , 0 , $ currency ) ; if ( $ hasDeposit && ( - 1 === Money :: compare ( $ this -> paidTotal , $ this -> depositTotal , $ currency ) ) ) { $ total = $ this -> depositTotal ; } else { $ total = $ this -> grandTotal ; } $ c = Money :: compare ( $ total , $ this -> paidTotal + $ this -> outstandingAccepted + $ this -> pendingTotal , $ currency ) ; if ( 1 === $ c ) { $ amount = $ total - $ this -> paidTotal - $ this -> outstandingAccepted - $ this -> pendingTotal ; } else if ( 0 === $ c && 0 < $ this -> outstandingAccepted ) { $ amount = $ this -> outstandingAccepted ; } if ( 0 < $ amount ) { return $ amount ; } return 0 ; }
8306	public function assertString ( $ config , $ key ) { if ( array_key_exists ( $ key , $ config ) && ! is_string ( $ config [ $ key ] ) ) { throw new ConfigurationException ( $ key . " must be a string." ) ; } return $ this ; }
9932	public function addRule ( Column \ Rule $ pRule ) { $ pRule -> setParent ( $ this ) ; $ this -> ruleset [ ] = $ pRule ; return $ this ; }
617	private function parseArray ( $ value , & $ i = 0 ) { $ result = [ ] ; $ len = strlen ( $ value ) ; for ( ++ $ i ; $ i < $ len ; ++ $ i ) { switch ( $ value [ $ i ] ) { case '{' : $ result [ ] = $ this -> parseArray ( $ value , $ i ) ; break ; case '}' : break 2 ; case $ this -> delimiter : if ( empty ( $ result ) ) { $ result [ ] = null ; } if ( in_array ( $ value [ $ i + 1 ] , [ $ this -> delimiter , '}' ] , true ) ) { $ result [ ] = null ; } break ; default : $ result [ ] = $ this -> parseString ( $ value , $ i ) ; } } return $ result ; }
3868	protected function getConfigs ( ) { if ( ! count ( $ this -> configs ) ) { $ statement = $ this -> connection -> query ( 'SELECT * FROM tl_metamodel_searchable_pages' ) ; $ this -> configs = $ statement -> fetchAll ( \ PDO :: FETCH_ASSOC ) ; } return $ this -> configs ; }
1921	private function getIndexLength ( Table $ table , string $ column ) : ? int { $ col = $ table -> getColumn ( $ column ) ; if ( null === ( $ length = $ col -> getLength ( ) ) ) { return null ; } if ( $ length <= 191 ) { return null ; } if ( $ col -> hasPlatformOption ( 'collation' ) ) { $ collation = $ col -> getPlatformOption ( 'collation' ) ; } else { $ collation = $ table -> getOption ( 'collate' ) ; } $ defaultLength = $ this -> getDefaultIndexLength ( $ table ) ; $ bytes = 0 === strncmp ( $ collation , 'utf8mb4' , 7 ) ? 4 : 3 ; $ indexLength = ( int ) floor ( $ defaultLength / $ bytes ) ; if ( $ length <= $ indexLength ) { return null ; } return $ indexLength ; }
835	protected function find ( $ functionNameToSearch , Tokens $ tokens , $ start = 0 , $ end = null ) { $ end = null === $ end ? $ tokens -> count ( ) : $ end ; $ candidateSequence = [ [ T_STRING , $ functionNameToSearch ] , '(' ] ; $ matches = $ tokens -> findSequence ( $ candidateSequence , $ start , $ end , false ) ; if ( null === $ matches ) { return null ; } list ( $ functionName , $ openParenthesis ) = array_keys ( $ matches ) ; $ functionsAnalyzer = new FunctionsAnalyzer ( ) ; if ( ! $ functionsAnalyzer -> isGlobalFunctionCall ( $ tokens , $ functionName ) ) { return $ this -> find ( $ functionNameToSearch , $ tokens , $ openParenthesis , $ end ) ; } return [ $ functionName , $ openParenthesis , $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ openParenthesis ) ] ; }
8988	public function toStatusLine ( ) : string { return sprintf ( "%s %d %s" , $ this -> proto , $ this -> code , self :: getStatus ( $ this -> code ) ) ; }
6483	private static function filterPath ( ? string $ path ) : ? string { if ( $ path === null ) { return null ; } return preg_replace_callback ( '/(?:[^a-zA-Z0-9_\-\.~:@&=\+\$,\/;%]+|%(?![A-Fa-f0-9]{2}))/' , function ( $ match ) { return rawurlencode ( $ match [ 0 ] ) ; } , $ path ) ; }
7154	protected function match ( $ role , $ action ) : bool { $ roles = $ actions = [ '*' ] ; $ allow = false ; if ( $ role != '*' ) array_unshift ( $ roles , $ role ) ; if ( $ action != '*' ) array_unshift ( $ actions , $ action ) ; foreach ( $ roles as $ _role ) { foreach ( $ actions as $ _action ) { if ( isset ( $ this -> _rules [ $ _role ] [ $ _action ] ) ) { $ allow = $ this -> _rules [ $ _role ] [ $ _action ] ; break 2 ; } } } return $ allow === true ; }
1556	protected function queryRulesWithoutSearch ( ) { return collect ( $ this -> queryRules ( ) ) -> reject ( function ( $ value , $ key ) { return Str :: startsWith ( $ key , [ 'filter.' , 'sort.' , 'page.' ] ) ; } ) -> all ( ) ; }
2561	public function loadSpecificChanges ( $ changeTicketing , $ changeQueueing , $ changeOptQueueEl ) { if ( $ changeTicketing ) { $ this -> specificChanges [ ] = new SpecificChanges ( SpecificChanges :: ACTION_TICKETING_OFFICE ) ; } if ( $ changeQueueing ) { $ this -> specificChanges [ ] = new SpecificChanges ( SpecificChanges :: ACTION_QUEUEING_OFFICE ) ; } if ( $ changeOptQueueEl ) { $ this -> specificChanges [ ] = new SpecificChanges ( SpecificChanges :: ACTION_OPT_QUEUE_ELEMENT ) ; } }
9160	private function adjustHeaders ( $ requestType ) { if ( ! array_key_exists ( 'Accept' , $ this -> headers ) && $ requestType != 'HEAD' ) { $ this -> setHeader ( 'Accept' , 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8' ) ; } if ( ! array_key_exists ( 'Accept-Language' , $ this -> headers ) && $ requestType != 'HEAD' ) { $ this -> setHeader ( 'Accept-Language' , 'en-US;q=0.7,en;q=0.3' ) ; } if ( ! array_key_exists ( 'User-Agent' , $ this -> headers ) && $ requestType != 'HEAD' ) { $ this -> setHeader ( 'User-Agent' , 'phpGenerics 1.0' ) ; } if ( ! array_key_exists ( 'Connection' , $ this -> headers ) || strlen ( $ this -> headers [ 'Connection' ] ) == 0 ) { $ this -> adjustConnectionHeader ( $ requestType ) ; } if ( ! array_key_exists ( 'Accept-Encoding' , $ this -> headers ) ) { if ( function_exists ( 'gzinflate' ) ) { $ encoding = 'gzip, deflate' ; } else { $ encoding = 'identity' ; } $ this -> setHeader ( 'Accept-Encoding' , $ encoding ) ; } }
4522	public function postLoad ( LifecycleEventArgs $ args ) { $ entity = $ args -> getEntity ( ) ; if ( ! $ entity instanceof Config ) { return ; } $ key = $ entity -> getKey ( ) ; $ encrypt = $ this -> configCollection -> get ( $ key ) [ 'encrypt' ] ; $ entity -> setEncrypt ( $ encrypt ) ; }
12853	public function import ( Package $ package , $ id = null ) { $ id = is_null ( $ id ) ? $ package -> id : $ id ; $ this -> symbols = array_merge ( $ package -> symbols , $ this -> symbols ) ; $ this -> macros = array_merge ( $ package -> macros , $ this -> macros ) ; $ this -> packages [ $ id ] = $ package ; }
1171	protected function getProtected ( $ instance , $ property ) { $ closure = function ( $ property ) { return $ this -> $ property ; } ; $ callback = $ closure -> bindTo ( $ instance , $ instance ) ; return $ callback ( $ property ) ; }
11122	public function getEndLocation ( ) { $ lastLocation = $ this -> getLocation ( ) ; $ lastDate = NOW ; foreach ( $ this -> movements as $ v ) { if ( $ v -> getEndTime ( ) > $ lastDate ) { $ lastDate = $ v -> getEndTime ( ) ; $ lastLocation = $ v -> getEndLocation ( ) ; } } return $ lastLocation ; }
994	private function getDescription ( $ node ) { if ( $ node -> description ) { return $ node -> description -> value ; } if ( isset ( $ this -> options [ 'commentDescriptions' ] ) ) { $ rawValue = $ this -> getLeadingCommentBlock ( $ node ) ; if ( $ rawValue !== null ) { return BlockString :: value ( "\n" . $ rawValue ) ; } } return null ; }
5903	public function retrieveCurrentUser ( CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/accounts/me' , $ parameters , $ cachePolicy ) ; $ result = new User ( $ result ) ; return $ result ; }
10829	public static function dir ( string $ path ) : fs \ entity \ DirEntity { return ( new fs \ entity \ DirEntity ( $ path ) ) -> normalize ( ) ; }
8910	private function getCallableFunction ( $ method ) { if ( is_callable ( $ method ) ) { return $ method ; } if ( is_string ( $ method ) && is_callable ( array ( $ this , $ method ) ) ) { return array ( $ this , $ method ) ; } return FALSE ; }
6931	private function feedShipmentInvoice ( Invoice \ InvoiceInterface $ invoice ) { $ changed = false ; $ shipment = $ invoice -> getShipment ( ) ; $ calculator = $ this -> invoiceBuilder -> getInvoiceCalculator ( ) ; foreach ( $ shipment -> getItems ( ) as $ shipmentItem ) { $ saleItem = $ shipmentItem -> getSaleItem ( ) ; $ max = $ shipment -> isReturn ( ) ? $ calculator -> calculateCreditableQuantity ( $ saleItem ) : $ calculator -> calculateInvoiceableQuantity ( $ saleItem ) ; if ( 0 < $ quantity = min ( $ max , $ shipmentItem -> getQuantity ( ) ) ) { $ line = $ this -> invoiceBuilder -> findOrCreateGoodLine ( $ invoice , $ saleItem , $ max ) ; if ( $ line -> getQuantity ( ) !== $ quantity ) { $ line -> setQuantity ( $ quantity ) ; $ changed = true ; } } } if ( $ invoice -> hasLineByType ( Document \ DocumentLineTypes :: TYPE_GOOD ) ) { $ sale = $ invoice -> getSale ( ) ; foreach ( $ sale -> getAdjustments ( Common \ AdjustmentTypes :: TYPE_DISCOUNT ) as $ saleAdjustment ) { foreach ( $ invoice -> getLinesByType ( Document \ DocumentLineTypes :: TYPE_DISCOUNT ) as $ line ) { if ( $ saleAdjustment === $ line -> getSaleAdjustment ( ) ) { continue 2 ; } } $ this -> invoiceBuilder -> buildDiscountLine ( $ saleAdjustment , $ invoice ) ; $ changed = true ; } if ( null !== $ sale -> getShipmentMethod ( ) && ! $ this -> isShipmentAmountInvoiced ( $ invoice ) ) { $ this -> invoiceBuilder -> buildShipmentLine ( $ invoice ) ; } } return $ changed ; }
1059	public static function findValuesRemovedFromEnums ( Schema $ oldSchema , Schema $ newSchema ) { $ oldTypeMap = $ oldSchema -> getTypeMap ( ) ; $ newTypeMap = $ newSchema -> getTypeMap ( ) ; $ valuesRemovedFromEnums = [ ] ; foreach ( $ oldTypeMap as $ typeName => $ oldType ) { $ newType = $ newTypeMap [ $ typeName ] ?? null ; if ( ! ( $ oldType instanceof EnumType ) || ! ( $ newType instanceof EnumType ) ) { continue ; } $ valuesInNewEnum = [ ] ; foreach ( $ newType -> getValues ( ) as $ value ) { $ valuesInNewEnum [ $ value -> name ] = true ; } foreach ( $ oldType -> getValues ( ) as $ value ) { if ( isset ( $ valuesInNewEnum [ $ value -> name ] ) ) { continue ; } $ valuesRemovedFromEnums [ ] = [ 'type' => self :: BREAKING_CHANGE_VALUE_REMOVED_FROM_ENUM , 'description' => sprintf ( '%s was removed from enum type %s.' , $ value -> name , $ typeName ) , ] ; } } return $ valuesRemovedFromEnums ; }
5236	public function get ( $ name = null ) { $ constructor = $ this -> class -> getConstructor ( ) ; if ( null === $ constructor || $ this -> class -> isInternal ( ) ) { return $ this -> class -> newInstance ( ) ; } $ params = $ this -> injectionValuesForMethod ( $ constructor ) ; if ( count ( $ params ) === 0 ) { return $ this -> class -> newInstance ( ) ; } return $ this -> class -> newInstanceArgs ( $ params ) ; }
7180	public function getTypes ( ) { if ( is_string ( $ this -> type ) ) { $ types = array ( $ this -> type ) ; } elseif ( is_array ( $ this -> type ) ) { $ types = $ this -> type ; } else { $ types = array ( ) ; } $ types = array_filter ( $ types , array ( $ this , 'isValidType' ) ) ; return empty ( $ types ) ? array ( self :: ANY ) : $ types ; }
1584	public function withMeta ( $ meta ) : self { $ copy = clone $ this ; $ copy -> meta = collect ( $ meta ) -> all ( ) ; return $ copy ; }
9519	public function getPropertiesAsString ( ) { $ result = '' ; $ rFunction = new ReflectionFunction ( $ this -> parameterClosure ) ; if ( $ rFunction -> isVariadic ( ) ) { $ result .= '<' . $ rFunction -> getParameters ( ) [ 0 ] -> getName ( ) . ', ...>' ; } else { for ( $ i = 0 ; $ i < count ( $ rFunction -> getParameters ( ) ) ; $ i ++ ) { $ result .= ( $ result == '' ? '' : ' ' ) . '<' . $ rFunction -> getParameters ( ) [ $ i ] -> getName ( ) . '>' ; } } return $ result ; }
9996	protected function checkSeparator ( ) { $ line = fgets ( $ this -> fileHandle ) ; if ( $ line === false ) { return ; } if ( ( strlen ( trim ( $ line , "\r\n" ) ) == 5 ) && ( stripos ( $ line , 'sep=' ) === 0 ) ) { $ this -> delimiter = substr ( $ line , 4 , 1 ) ; return ; } return $ this -> skipBOM ( ) ; }
9197	public function getTag ( ) { if ( null !== $ this -> tag ) { return $ this -> tag ; } $ categoryId = $ this -> getEvent ( ) -> getRouteMatch ( ) -> getParam ( 'categoryid' ) ; if ( is_numeric ( $ categoryId ) ) { return $ this -> tag = $ this -> getDiscussService ( ) -> getCategoryById ( $ categoryId ) ; } $ topicId = $ this -> getEvent ( ) -> getRouteMatch ( ) -> getParam ( 'topicid' ) ; if ( is_numeric ( $ topicId ) ) { $ topic = $ this -> getDiscussService ( ) -> getTopicById ( $ topicId ) ; return $ this -> tag = $ this -> getDiscussService ( ) -> getCategoryById ( $ topic -> getforumCategoryId ( ) ) ; } return false ; }
6106	private function getGridClass ( ) { $ class = [ ] ; foreach ( $ this -> grid as $ grid ) { if ( ! isset ( $ grid [ 'type' ] ) || ! isset ( $ grid [ 'size' ] ) ) { throw new InvalidConfigException ( get_called_class ( ) . ' must have type and size.' ) ; } if ( ! isset ( $ grid [ 'positiontype' ] ) ) $ class [ ] = $ grid [ 'type' ] . $ grid [ 'size' ] ; else $ class [ ] = $ grid [ 'type' ] . $ grid [ 'positiontype' ] . '-' . $ grid [ 'size' ] ; } return implode ( ' ' , $ class ) ; }
6938	private function find ( array & $ list , $ oid , StockUnitInterface $ unit ) { if ( ! isset ( $ list [ $ oid ] ) ) { return false ; } if ( null === $ unit -> getId ( ) ) { return array_search ( $ unit , $ list [ $ oid ] , true ) ; } foreach ( $ list [ $ oid ] as $ index => $ u ) { if ( $ u -> getId ( ) == $ unit -> getId ( ) ) { return $ index ; } } return false ; }
2102	protected static function resolveCustomModifiers ( $ strDate ) { if ( strpos ( $ strDate , '::' ) === false ) { return $ strDate ; } System :: loadLanguageFile ( 'default' ) ; if ( ! $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'dayShortLength' ] ) { $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'dayShortLength' ] = 3 ; } if ( ! $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'monthShortLength' ] ) { $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'monthShortLength' ] = 3 ; } $ strReturn = '' ; $ chunks = preg_split ( "/([0-9]{1,2}::[1-4])/" , $ strDate , - 1 , PREG_SPLIT_DELIM_CAPTURE ) ; foreach ( $ chunks as $ chunk ) { list ( $ index , $ flag ) = explode ( '::' , $ chunk ) ; switch ( $ flag ) { case 1 : $ strReturn .= $ GLOBALS [ 'TL_LANG' ] [ 'DAYS' ] [ $ index ] ; break ; case 2 : $ strReturn .= $ GLOBALS [ 'TL_LANG' ] [ 'DAYS_SHORT' ] [ $ index ] ; break ; case 3 : $ strReturn .= $ GLOBALS [ 'TL_LANG' ] [ 'MONTHS' ] [ ( $ index - 1 ) ] ; break ; case 4 : $ strReturn .= $ GLOBALS [ 'TL_LANG' ] [ 'MONTHS_SHORT' ] [ ( $ index - 1 ) ] ; break ; default : $ strReturn .= $ chunk ; break ; } } return $ strReturn ; }
1839	protected static function find ( array $ arrOptions ) { if ( static :: $ strTable == '' ) { return null ; } if ( $ arrOptions [ 'return' ] == 'Model' ) { $ arrColumn = ( array ) $ arrOptions [ 'column' ] ; if ( \ count ( $ arrColumn ) == 1 ) { $ arrColumn [ 0 ] = preg_replace ( '/^' . preg_quote ( static :: getTable ( ) , '/' ) . '\./' , '' , $ arrColumn [ 0 ] ) ; if ( $ arrColumn [ 0 ] == static :: $ strPk || \ in_array ( $ arrColumn [ 0 ] , static :: getUniqueFields ( ) ) ) { $ varKey = \ is_array ( $ arrOptions [ 'value' ] ) ? $ arrOptions [ 'value' ] [ 0 ] : $ arrOptions [ 'value' ] ; $ objModel = Registry :: getInstance ( ) -> fetch ( static :: $ strTable , $ varKey , $ arrColumn [ 0 ] ) ; if ( $ objModel !== null ) { return $ objModel ; } } } } $ arrOptions [ 'table' ] = static :: $ strTable ; $ strQuery = static :: buildFindQuery ( $ arrOptions ) ; $ objStatement = Database :: getInstance ( ) -> prepare ( $ strQuery ) ; if ( ! isset ( $ arrOptions [ 'limit' ] ) ) { $ arrOptions [ 'limit' ] = 0 ; } if ( ! isset ( $ arrOptions [ 'offset' ] ) ) { $ arrOptions [ 'offset' ] = 0 ; } if ( $ arrOptions [ 'limit' ] > 0 || $ arrOptions [ 'offset' ] > 0 ) { $ objStatement -> limit ( $ arrOptions [ 'limit' ] , $ arrOptions [ 'offset' ] ) ; } $ objStatement = static :: preFind ( $ objStatement ) ; $ objResult = $ objStatement -> execute ( $ arrOptions [ 'value' ] ) ; if ( $ objResult -> numRows < 1 ) { return $ arrOptions [ 'return' ] == 'Array' ? array ( ) : null ; } $ objResult = static :: postFind ( $ objResult ) ; if ( $ arrOptions [ 'return' ] == 'Model' ) { $ objModel = Registry :: getInstance ( ) -> fetch ( static :: $ strTable , $ objResult -> { static :: $ strPk } ) ; if ( $ objModel !== null ) { return $ objModel -> mergeRow ( $ objResult -> row ( ) ) ; } return static :: createModelFromDbResult ( $ objResult ) ; } elseif ( $ arrOptions [ 'return' ] == 'Array' ) { return static :: createCollectionFromDbResult ( $ objResult , static :: $ strTable ) -> getModels ( ) ; } else { return static :: createCollectionFromDbResult ( $ objResult , static :: $ strTable ) ; } }
4697	public static function validate ( $ request_data = array ( ) , $ token_name = self :: TOKEN_NAME ) { if ( empty ( $ _SESSION [ $ token_name ] ) ) { static :: generateToken ( $ token_name ) ; return false ; } elseif ( empty ( $ request_data [ $ token_name ] ) ) { return false ; } else { if ( static :: compare ( $ request_data [ $ token_name ] , static :: getToken ( $ token_name ) ) ) { static :: generateToken ( $ token_name ) ; return true ; } else { return false ; } } }
488	public static function getInstances ( $ model , $ attribute ) { $ name = Html :: getInputName ( $ model , $ attribute ) ; return static :: getInstancesByName ( $ name ) ; }
3498	private function createChainVisitor ( ) : HttpProtocolChainVisitor { $ chainVisitors = new HttpProtocolChainVisitor ( ) ; $ visitors = clone $ this -> visitors ; $ priority = 0 ; foreach ( $ visitors as $ visitor ) { $ chainVisitors -> add ( $ visitor , ++ $ priority ) ; } return $ chainVisitors ; }
10059	public function commit ( ) { foreach ( $ this -> deferred as $ item ) { $ this -> save ( $ item ) ; } $ this -> deferred = [ ] ; return true ; }
10989	protected function _setData ( $ key , $ value ) { $ store = $ this -> _getDataStore ( ) ; try { $ this -> _containerSet ( $ store , $ key , $ value ) ; } catch ( InvalidArgumentException $ e ) { throw $ this -> _createOutOfRangeException ( $ this -> __ ( 'Invalid store' ) , null , $ e , $ store ) ; } catch ( OutOfRangeException $ e ) { throw $ this -> _createInvalidArgumentException ( $ this -> __ ( 'Invalid key' ) , null , $ e , $ store ) ; } }
10816	public static function write ( $ messages , $ style = '' , $ length = 0 , $ suffix = '' ) { if ( self :: $ silent ) { return ; } if ( ! is_array ( $ messages ) ) { $ messages = [ ( string ) $ messages ] ; } if ( count ( $ messages ) > 0 ) { foreach ( $ messages as $ message ) { if ( $ length > 0 ) { $ message = str_pad ( $ message , $ length , ' ' , STR_PAD_RIGHT ) ; } print ( Style :: applyStyle ( $ message , $ style ) ) ; if ( $ suffix != '' ) { print ( $ suffix ) ; } } } }
9505	public function index ( ) { $ this -> authorize ( LogViewerPolicy :: PERMISSION_DASHBOARD ) ; $ stats = $ this -> logViewer -> statsTable ( ) ; $ percents = $ this -> calcPercentages ( $ stats -> footer ( ) , $ stats -> header ( ) ) ; $ this -> setTitle ( 'LogViewer Dashboard' ) ; $ this -> addBreadcrumb ( 'Dashboard' ) ; return $ this -> view ( 'admin.system.log-viewer.dashboard' , compact ( 'percents' ) ) ; }
762	private function tokensMatch ( SqlToken $ patternToken , SqlToken $ token , $ offset = 0 , & $ firstMatchIndex = null , & $ lastMatchIndex = null ) { if ( $ patternToken -> getIsCollection ( ) !== $ token -> getIsCollection ( ) || ( ! $ patternToken -> getIsCollection ( ) && $ patternToken -> content !== $ token -> content ) ) { return false ; } if ( $ patternToken -> children === $ token -> children ) { $ firstMatchIndex = $ lastMatchIndex = $ offset ; return true ; } $ firstMatchIndex = $ lastMatchIndex = null ; $ wildcard = false ; for ( $ index = 0 , $ count = count ( $ patternToken -> children ) ; $ index < $ count ; $ index ++ ) { if ( $ patternToken [ $ index ] -> content === 'any' ) { $ wildcard = true ; continue ; } for ( $ limit = $ wildcard ? count ( $ token -> children ) : $ offset + 1 ; $ offset < $ limit ; $ offset ++ ) { if ( ! $ wildcard && ! isset ( $ token [ $ offset ] ) ) { break ; } if ( ! $ this -> tokensMatch ( $ patternToken [ $ index ] , $ token [ $ offset ] ) ) { continue ; } if ( $ firstMatchIndex === null ) { $ firstMatchIndex = $ offset ; $ lastMatchIndex = $ offset ; } else { $ lastMatchIndex = $ offset ; } $ wildcard = false ; $ offset ++ ; continue 2 ; } return false ; } return true ; }
11774	private function getMaxPercentForPersonalBonus ( $ levels ) { $ result = 0 ; foreach ( $ levels as $ percent ) { if ( $ percent > $ result ) { $ result = $ percent ; } } return $ result ; }
1393	protected function prepareJsonApiException ( JsonApiException $ ex ) { $ error = collect ( $ ex -> getErrors ( ) ) -> map ( function ( ErrorInterface $ err ) { return $ err -> getDetail ( ) ? : $ err -> getTitle ( ) ; } ) -> filter ( ) -> first ( ) ; return new HttpException ( $ ex -> getHttpCode ( ) , $ error , $ ex ) ; }
11947	public function getPriority ( ) { if ( isset ( $ this -> object -> singleWidget ) ) { if ( isset ( $ this -> object -> singleWidget ) && isset ( $ this -> object -> singleWidget -> content -> priorityAdjust ) ) { return $ this -> _priority + $ this -> object -> singleWidget -> content -> priorityAdjust ; } } return $ this -> _priority ; }
5177	public function map ( \ Closure $ callback , $ context = [ ] ) : self { $ collection = new static ( ) ; foreach ( $ this -> props as $ key => $ value ) { $ collection -> add ( $ key , $ callback ( $ value , $ key , $ context ) ) ; } return $ collection ; }
11880	protected function getRunner ( ) { if ( null === $ this -> runner ) { $ this -> runner = new ConsoleApplication ( $ this -> name , $ this -> version , $ this -> description , $ this -> alias ) ; } return $ this -> runner ; }
4248	public function onOutput ( Event $ event ) { $ this -> outputEvent = $ event ; $ this -> channelName = $ this -> debug -> getCfg ( 'channel' ) ; $ this -> data = $ this -> debug -> getData ( ) ; $ event [ 'headers' ] [ ] = array ( 'X-Wf-Protocol-1' , 'http://meta.wildfirehq.org/Protocol/JsonStream/0.2' ) ; $ event [ 'headers' ] [ ] = array ( 'X-Wf-1-Plugin-1' , 'http://meta.firephp.org/Wildfire/Plugin/FirePHP/Library-FirePHPCore/' . self :: FIREPHP_PROTO_VER ) ; $ event [ 'headers' ] [ ] = array ( 'X-Wf-1-Structure-1' , 'http://meta.firephp.org/Wildfire/Structure/FirePHP/FirebugConsole/0.1' ) ; $ heading = isset ( $ _SERVER [ 'REQUEST_METHOD' ] ) ? $ _SERVER [ 'REQUEST_METHOD' ] . ' ' . $ _SERVER [ 'REQUEST_URI' ] : '$: ' . \ implode ( ' ' , $ _SERVER [ 'argv' ] ) ; $ this -> processLogEntryWEvent ( 'groupCollapsed' , array ( 'PHP: ' . $ heading ) ) ; $ this -> processAlerts ( ) ; $ this -> processSummary ( ) ; $ this -> processLog ( ) ; $ this -> processLogEntryWEvent ( 'groupEnd' ) ; $ event [ 'headers' ] [ ] = array ( 'X-Wf-1-Index' , $ this -> messageIndex ) ; $ this -> data = array ( ) ; return ; }
4624	public function pickNewNode ( ) { $ this -> getActiveNode ( ) -> setInactive ( true ) ; $ this -> attempts ++ ; $ this -> inactiveNodes [ $ this -> getActiveNodeIndex ( ) ] = $ this -> getActiveNode ( ) ; unset ( $ this -> nodes [ $ this -> getActiveNodeIndex ( ) ] ) ; $ this -> setActiveNodeIndex ( $ this -> pickNode ( ) ) ; return $ this ; }
3590	public function allowsMeta ( $ key ) { $ allowed = $ this -> getAllowedMeta ( ) ; return empty ( $ allowed ) || in_array ( $ key , $ allowed ) ; }
7702	function OpenDoc_GetDraw ( $ Tag , $ Txt , $ Pos , $ Forward , $ LevelStop ) { return $ this -> XML_BlockAlias_Prefix ( 'draw:' , $ Txt , $ Pos , $ Forward , $ LevelStop ) ; }
7312	public static function equinoxAutumn ( $ year ) { $ jd = static :: equinoxSeptember ( ( int ) $ year , false ) ; return AstroDate :: jd ( $ jd , TimeScale :: TT ( ) ) ; }
9476	protected function getStartDate ( ) { $ StartDate = false ; $ objStartDate = \ Database :: getInstance ( ) -> prepare ( "SELECT MIN(`tstamp`) AS YMD FROM `tl_dlstatdets` WHERE 1" ) -> execute ( ) ; if ( $ objStartDate -> YMD !== null ) { $ StartDate = $ this -> parseDate ( $ GLOBALS [ 'TL_CONFIG' ] [ 'dateFormat' ] , $ objStartDate -> YMD ) ; } return $ StartDate ; }
2529	protected function generateGuid ( ) { mt_srand ( ( double ) microtime ( ) * 10000 ) ; $ charId = strtoupper ( md5 ( uniqid ( rand ( ) , true ) ) ) ; $ hyphen = chr ( 45 ) ; $ uuid = substr ( $ charId , 0 , 8 ) . $ hyphen . substr ( $ charId , 8 , 4 ) . $ hyphen . substr ( $ charId , 12 , 4 ) . $ hyphen . substr ( $ charId , 16 , 4 ) . $ hyphen . substr ( $ charId , 20 , 12 ) ; return $ uuid ; }
3087	public function validateAdaptiveAssessmentSection ( SectionPartCollection $ sectionsParts , $ ref , $ testAdminId ) { $ engine = $ this -> getEngine ( $ ref ) ; $ adaptSection = $ engine -> setupSection ( $ testAdminId ) ; if ( method_exists ( $ adaptSection , 'getItemReferences' ) ) { $ itemReferences = $ adaptSection -> getItemReferences ( ) ; $ dependencies = $ sectionsParts -> getKeys ( ) ; if ( $ catDiff = array_diff ( $ dependencies , $ itemReferences ) ) { throw new AdaptiveSectionInjectionException ( 'Missed some CAT service items: ' . implode ( ', ' , $ catDiff ) , $ catDiff ) ; } if ( $ packageDiff = array_diff ( $ dependencies , $ itemReferences ) ) { throw new AdaptiveSectionInjectionException ( 'Missed some package items: ' . implode ( ', ' , $ packageDiff ) , $ packageDiff ) ; } } }
8586	public function setCompetitivePrice ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'CompetitivePrice' ] [ 'FieldValue' ] = $ value ; return $ this ; }
12025	private function generateExecuteFragment ( ) { $ body = '' ; if ( $ this -> operationDefinition -> getNeedsSigning ( ) ) { $ body .= '$request = $this->api->signRequest($request);' . PHP_EOL ; } $ body .= '$response = $this->api->execute($request, $this);' . PHP_EOL ; $ body .= '$this->response = $response;' . PHP_EOL ; return $ body ; }
4915	private function addArray ( array $ result ) { if ( 1 < count ( $ result ) && ! isset ( $ result [ 'name' ] ) && ! is_string ( $ result [ 0 ] ) ) { foreach ( $ result as $ r ) { if ( is_array ( $ r ) ) { $ this -> add ( $ r ) ; } else { return $ this -> addTraversable ( new \ ArrayIterator ( $ result ) ) ; } } return $ this ; } if ( is_string ( $ result [ 0 ] ) ) { $ result = [ 'name' => $ result [ 0 ] , 'entities' => isset ( $ result [ 1 ] ) ? $ result [ 1 ] : null , 'options' => isset ( $ result [ 2 ] ) && is_array ( $ result [ 2 ] ) ? $ result [ 2 ] : [ 'description' => isset ( $ result [ 2 ] ) ? $ result [ 2 ] : null , 'viewScript' => isset ( $ result [ 3 ] ) ? $ result [ 3 ] : null , ] , ] ; } if ( ! isset ( $ result [ 'name' ] ) || ! isset ( $ result [ 'entities' ] ) ) { throw new \ UnexpectedValueException ( 'Array must have the keys "name" and "entities".' ) ; } if ( ! count ( $ result [ 'entities' ] ) ) { throw new \ UnexpectedValueException ( 'Entities must be non-empty.' ) ; } $ result = new DependencyResult ( $ result [ 'name' ] , $ result [ 'entities' ] , isset ( $ result [ 'options' ] ) ? $ result [ 'options' ] : null ) ; return $ this -> addResult ( $ result ) ; }
4459	private function fireQueue ( SplPriorityQueue $ queue , AbstractUserEvent $ event ) { $ eventHappening = $ event :: getHappening ( ) ; $ iterator = clone $ queue ; $ iterator -> top ( ) ; $ arguments = null ; $ status = null ; while ( $ iterator -> valid ( ) ) { $ handler = $ iterator -> current ( ) ; $ iterator -> next ( ) ; if ( is_object ( $ handler ) ) { if ( $ handler instanceof \ Closure ) { $ arguments = $ arguments ? : [ $ event ] ; $ status = call_user_func_array ( $ handler , $ arguments ) ; } else { if ( method_exists ( $ handler , $ eventHappening ) ) { $ status = $ handler -> { $ eventHappening } ( $ event ) ; } } } } return $ status ; }
3905	protected function getPropertyNames ( ) { $ propertyNames = array ( 'id' , 'pid' , 'tstamp' , 'sorting' ) ; if ( $ this -> getItem ( ) -> getMetaModel ( ) -> hasVariants ( ) ) { $ propertyNames [ ] = 'varbase' ; $ propertyNames [ ] = 'vargroup' ; } return array_merge ( $ propertyNames , array_keys ( $ this -> getItem ( ) -> getMetaModel ( ) -> getAttributes ( ) ) ) ; }
3187	public function end ( $ tags , $ timestamp ) { if ( ! is_numeric ( $ timestamp ) || $ timestamp < 0 ) { throw new InvalidDataException ( 'end() needs a valid timestamp!' ) ; } $ range = $ this -> getRange ( $ tags ) ; if ( $ this -> isRangeOpen ( $ range ) ) { $ this -> checkTimestampCoherence ( $ range , $ timestamp ) ; $ point = new TimePoint ( $ tags , $ timestamp , TimePoint :: TYPE_END , TimePoint :: TARGET_SERVER ) ; $ this -> timeLine -> add ( $ point ) ; } else { \ common_Logger :: t ( 'Range already closed, or missing START TimePoint in QtiTimer, continue anyway' ) ; } return $ this ; }
12102	public function setMaxSize ( $ maxSize ) { $ serverMaxSize = $ this -> getServerMaxSize ( ) ; if ( $ maxSize > $ serverMaxSize ) { throw new FileMaxSizeException ( $ serverMaxSize ) ; } $ this -> maxSize = $ maxSize ; if ( $ this -> getValidator ( ) ) { $ this -> getValidator ( ) -> setOption ( 'maxSize' , $ maxSize ) ; } }
12100	public function priceBrutto ( $ netto , $ tax ) { $ tax = round ( ( double ) $ tax / 100.0 , 2 ) ; if ( $ tax < 0.00 ) { throw new Exception ( sprintf ( 'Tax must be greater than or equal to 0, given %s.' , $ tax ) ) ; } if ( $ tax === 0.00 ) { return $ netto ; } $ result = $ netto * ( $ tax + 1 ) ; return round ( $ result , 2 , PHP_ROUND_HALF_UP ) ; }
7743	public function setValue ( $ entity , $ value ) { if ( false === ( $ entity instanceof $ this -> class ) ) { throw new \ Exception ( "Can't set the entity's {$this->name} property as the entity is not an instance of {$this->class}." ) ; } if ( ! is_array ( $ value ) && ! ( $ value instanceof \ Traversable ) ) { if ( ( null !== $ this -> adderRemover ) && ( null !== $ this -> getter ) ) { $ itemsToAdd = is_object ( $ value ) ? iterator_to_array ( $ value ) : $ value ; $ itemToRemove = array ( ) ; $ previousValue = $ this -> getValue ( $ entity ) ; if ( is_array ( $ previousValue ) || $ previousValue instanceof \ Traversable ) { foreach ( $ previousValue as $ previousItem ) { foreach ( $ value as $ key => $ item ) { if ( $ item === $ previousItem ) { unset ( $ itemsToAdd [ $ key ] ) ; continue 2 ; } } $ itemToRemove [ ] = $ previousItem ; } } foreach ( $ itemToRemove as $ item ) { call_user_func ( array ( $ entity , 'remove' . $ this -> adderRemover ) , $ item ) ; } foreach ( $ itemsToAdd as $ item ) { call_user_func ( array ( $ entity , 'add' . $ this -> adderRemover ) , $ item ) ; } return ; } } if ( null === $ this -> setter ) { throw new \ Exception ( "Can't set the entity's {$this->name} property as no setter has been found." ) ; } if ( self :: GETTER_SETTER_METHOD === $ this -> setterType ) { return $ entity -> { $ this -> setter } ( $ value ) ; } else { return $ entity -> { $ this -> setter } = $ value ; } }
8457	protected function injectArguments ( $ command , $ assumeYes ) { $ cmd = $ this -> siteAlias . ' ' . $ command . ( $ assumeYes ? ' -y' : '' ) . $ this -> arguments . $ this -> argumentsForNextCommand ; $ this -> argumentsForNextCommand = '' ; return $ cmd ; }
11440	public function getInfos ( $ echoable = false ) { if ( true === $ echoable ) { return join ( "\n<br />" , $ this -> infos ) ; } else { return $ this -> infos ; } }
3248	public function remove ( $ item , $ quantity = 0 ) { $ cartItem = $ this -> getItem ( is_array ( $ item ) ? $ item [ 'sku' ] : $ item -> sku ) ; if ( ! empty ( $ cartItem ) ) { if ( ! empty ( $ quantity ) ) { $ cartItem -> quantity -= $ quantity ; $ cartItem -> save ( ) ; if ( $ cartItem -> quantity > 0 ) return true ; } $ cartItem -> delete ( ) ; } $ this -> resetCalculations ( ) ; return $ this ; }
9698	public function html ( $ paragraphs = null ) { $ this -> paragraphs = $ paragraphs ; unset ( $ this -> params [ 'plaintext' ] ) ; return $ this -> generate ( ) ; }
1285	private function fetchResourcesForGivenIds ( array $ resourceIds , string $ type , string $ locale = null ) : array { $ resources = [ ] ; $ resourcePoolOptions = [ 'locale' => $ locale ] ; foreach ( $ resourceIds as $ index => $ resourceId ) { if ( $ this -> resourcePool -> has ( $ type , $ resourceId , $ resourcePoolOptions ) ) { $ resources [ ] = $ this -> resourcePool -> get ( $ type , $ resourceId , $ resourcePoolOptions ) ; unset ( $ resourceIds [ $ index ] ) ; } } foreach ( $ this -> createIdChunks ( $ resourceIds ) as $ chunk ) { $ resources += $ this -> fetchCollectionFromApi ( $ chunk , $ type , $ locale ) ; } return $ resources ; }
8557	public function setType ( $ type ) { if ( ! $ this -> isNumericArray ( $ type ) ) { $ type = array ( $ type ) ; } $ this -> fields [ 'Type' ] [ 'FieldValue' ] = $ type ; return $ this ; }
2711	public function execute ( ) { $ result = $ this -> resultJsonFactory -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ dictionaryName = Config :: AUTH_DICTIONARY_NAME ; $ dictionary = $ this -> api -> getSingleDictionary ( $ activeVersion , $ dictionaryName ) ; if ( ( is_array ( $ dictionary ) && empty ( $ dictionary ) ) || $ dictionary == false || ! isset ( $ dictionary -> id ) ) { return $ result -> setData ( [ 'status' => 'empty' , 'msg' => 'Basic Authentication cannot be enabled because there are no users assigned to it.' ] ) ; } else { $ authItems = $ this -> api -> dictionaryItemsList ( $ dictionary -> id ) ; if ( is_array ( $ authItems ) && empty ( $ authItems ) ) { return $ result -> setData ( [ 'status' => 'empty' , 'msg' => 'Basic Authentication cannot be enabled because there are no users assigned to it.' ] ) ; } return $ result -> setData ( [ 'status' => true ] ) ; } } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
2421	public static function copyResource ( $ strSource , $ strDestination ) { $ objDatabase = Database :: getInstance ( ) ; $ objFile = FilesModel :: findByPath ( $ strSource ) ; if ( $ objFile === null ) { $ objFile = static :: addResource ( $ strSource ) ; } $ strFolder = \ dirname ( $ strDestination ) ; $ objNewFile = clone $ objFile -> current ( ) ; if ( $ strFolder == Config :: get ( 'uploadPath' ) ) { $ objNewFile -> pid = null ; } else { $ objFolder = FilesModel :: findByPath ( $ strFolder ) ; if ( $ objFolder === null ) { $ objFolder = static :: addResource ( $ strFolder ) ; } $ objNewFile -> pid = $ objFolder -> uuid ; } $ objNewFile -> tstamp = time ( ) ; $ objNewFile -> uuid = $ objDatabase -> getUuid ( ) ; $ objNewFile -> path = $ strDestination ; $ objNewFile -> name = basename ( $ strDestination ) ; $ objNewFile -> save ( ) ; if ( $ objFile -> type == 'folder' ) { $ objFiles = FilesModel :: findMultipleByBasepath ( $ strSource . '/' ) ; if ( $ objFiles !== null ) { while ( $ objFiles -> next ( ) ) { $ objNew = clone $ objFiles -> current ( ) ; $ objNew -> pid = $ objNewFile -> uuid ; $ objNew -> tstamp = time ( ) ; $ objNew -> uuid = $ objDatabase -> getUuid ( ) ; $ objNew -> path = str_replace ( $ strSource . '/' , $ strDestination . '/' , $ objFiles -> path ) ; $ objNew -> save ( ) ; } } } if ( ( $ strPath = \ dirname ( $ strSource ) ) != Config :: get ( 'uploadPath' ) ) { static :: updateFolderHashes ( $ strPath ) ; } if ( ( $ strPath = \ dirname ( $ strDestination ) ) != Config :: get ( 'uploadPath' ) ) { static :: updateFolderHashes ( $ strPath ) ; } return $ objNewFile ; }
12277	public function update ( $ groupId , $ name ) { $ params = [ 'group' => [ 'id' => $ groupId , 'name' => $ name , ] , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_UPDATE , $ params ] ) ; }
3384	private function findUser ( ) { $ sql = sprintf ( 'SELECT * FROM %s WHERE %s = :identity' , $ this -> getTableName ( ) , $ this -> getIdentityColumn ( ) ) ; $ stmt = $ this -> db -> prepare ( $ sql ) ; $ stmt -> execute ( array ( 'identity' => $ this -> getIdentity ( ) ) ) ; return $ stmt -> fetch ( PDO :: FETCH_ASSOC ) ; }
11989	public function sort ( $ entityName , $ values ) { $ values = json_decode ( $ values ) ; for ( $ i = 0 ; $ i < count ( $ values ) ; $ i ++ ) { $ this -> entityManager -> getRepository ( $ entityName ) -> createQueryBuilder ( 'e' ) -> update ( ) -> set ( 'e.order' , $ i ) -> where ( 'e.id = :id' ) -> setParameter ( 'id' , $ values [ $ i ] -> id ) -> getQuery ( ) -> execute ( ) ; } }
1891	private function hasRequireGranted ( string $ line ) : bool { if ( $ this -> isComment ( $ line ) ) { return false ; } return ( false !== stripos ( $ line , 'Allow from all' ) ) || ( false !== stripos ( $ line , 'Require all granted' ) ) ; }
8788	public function style ( $ url , $ attributes = [ ] , $ secure = null ) { $ defaults = [ 'media' => 'all' , 'type' => 'text/css' , 'rel' => 'stylesheet' ] ; $ attributes = array_merge ( $ attributes , $ defaults ) ; $ attributes [ 'href' ] = $ this -> uri -> assets ( $ url , $ secure ) ; return $ this -> toHtmlString ( '<link' . $ this -> attributes ( $ attributes ) . '>' . PHP_EOL ) ; }
10291	protected function aquireLock ( ) { $ lockfile = $ this -> lockDir . '/lock' ; $ fp = @ fopen ( $ lockfile , 'x' ) ; if ( $ fp === false ) { $ this -> logger -> log ( sprintf ( 'The lockfile %s does already exist.' , $ lockfile ) , Logger :: WARNING ) ; return false ; } fwrite ( $ fp , time ( ) ) ; fclose ( $ fp ) ; $ this -> logger -> log ( 'Aquired lock.' , Logger :: INFO ) ; return true ; }
10614	public function createMigrateRepository ( array $ args ) { $ db = $ this -> app -> db ; $ repo = new Repository ( $ db ) ; $ resolver = $ this -> app -> resolver -> getResolver ( "migrations" ) ; $ mods = [ ] ; foreach ( $ resolver -> getSearchPath ( ) as $ name => $ path ) { $ module = new Module ( $ name , $ path , $ db ) ; if ( $ name === "wedeto.db" ) array_unshift ( $ mods , $ module ) ; else array_push ( $ mods , $ module ) ; } foreach ( $ mods as $ module ) $ repo -> addModule ( $ module ) ; return $ repo ; }
4106	public function commitBulk ( ) { if ( $ this -> bulk && $ this -> bulk -> count ( ) ) { $ result = $ this -> bulk -> commit ( ) ; $ this -> bulk = null ; return $ result ; } }
4188	public function boot ( Factory $ validator ) { $ passwordStrength = app ( 'passwordStrength' ) ; $ translator = app ( 'passwordStrength.translationProvider' ) -> get ( $ validator ) ; foreach ( [ 'letters' , 'numbers' , 'caseDiff' , 'symbols' ] as $ rule ) { $ snakeCasedRule = snake_case ( $ rule ) ; $ validator -> extend ( $ rule , function ( $ _ , $ value , $ __ ) use ( $ passwordStrength , $ rule ) { $ capitalizedRule = ucfirst ( $ rule ) ; return call_user_func ( [ $ passwordStrength , "validate{$capitalizedRule}" ] , $ value ) ; } , $ translator -> get ( "password-strength::validation.{$snakeCasedRule}" ) ) ; } }
11178	public function getApi ( ) { $ api = $ this -> get ( Keys :: EXT_API ) ; if ( is_array ( $ api ) ) { return $ api ; } return false ; }
3714	protected function allowAttributeTypes ( $ initialType1toN = null ) { if ( is_array ( $ initialType1toN ) ) { $ this -> attributeTypes = $ initialType1toN ; } else { $ this -> attributeTypes = func_get_args ( ) ; } return $ this ; }
11047	function get_value ( $ parent , $ varname ) { if ( isset ( $ parent -> $ varname ) ) { return $ parent -> $ varname ; } else { $ elements = explode ( '[' , $ varname ) ; if ( count ( $ elements ) == 1 ) { return NULL ; } else { $ vartest = $ parent ; foreach ( $ elements as $ elementid => $ element ) { if ( $ elementid == 0 ) { $ vartest = $ parent -> $ element ; if ( ! isset ( $ vartest ) ) { return NULL ; } } else { $ index = substr ( $ element , 0 , - 1 ) ; if ( $ index == '_first' ) { $ keys = array_keys ( $ vartest ) ; $ index = $ keys [ 0 ] ; } elseif ( $ index == '_last' ) { $ keys = array_keys ( $ vartest ) ; $ index = $ keys [ count ( $ keys ) - 2 ] ; } if ( ! isset ( $ vartest [ $ index ] ) ) { return NULL ; } else { $ vartest = $ vartest [ $ index ] ; } } } } return $ vartest ; } }
1277	private function createRequest ( ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; $ trackRequest = $ xml -> appendChild ( $ xml -> createElement ( 'TrackRequest' ) ) ; $ trackRequest -> setAttribute ( 'xml:lang' , 'en-US' ) ; $ request = $ trackRequest -> appendChild ( $ xml -> createElement ( 'Request' ) ) ; $ node = $ xml -> importNode ( $ this -> createTransactionNode ( ) , true ) ; $ request -> appendChild ( $ node ) ; $ request -> appendChild ( $ xml -> createElement ( 'RequestAction' , 'Track' ) ) ; if ( null !== $ this -> requestOption ) { $ request -> appendChild ( $ xml -> createElement ( 'RequestOption' , $ this -> requestOption ) ) ; } if ( null !== $ this -> trackingNumber ) { $ trackRequest -> appendChild ( $ xml -> createElement ( 'TrackingNumber' , $ this -> trackingNumber ) ) ; } if ( $ this -> isMailInnovations ( ) ) { $ trackRequest -> appendChild ( $ xml -> createElement ( 'IncludeMailInnovationIndicator' ) ) ; } if ( null !== $ this -> referenceNumber ) { $ trackRequest -> appendChild ( $ xml -> createElement ( 'ReferenceNumber' ) ) -> appendChild ( $ xml -> createElement ( 'Value' , $ this -> referenceNumber ) ) ; } if ( null !== $ this -> shipperNumber ) { $ trackRequest -> appendChild ( $ xml -> createElement ( 'ShipperNumber' , $ this -> shipperNumber ) ) ; } if ( null !== $ this -> beginDate || null !== $ this -> endDate ) { $ DateRange = $ xml -> createElement ( 'PickupDateRange' ) ; if ( null !== $ this -> beginDate ) { $ beginDate = $ this -> beginDate -> format ( 'Ymd' ) ; $ DateRange -> appendChild ( $ xml -> createElement ( 'BeginDate' , $ beginDate ) ) ; } if ( null !== $ this -> endDate ) { $ endDate = $ this -> endDate -> format ( 'Ymd' ) ; $ DateRange -> appendChild ( $ xml -> createElement ( 'EndDate' , $ endDate ) ) ; } $ trackRequest -> appendChild ( $ DateRange ) ; } return $ xml -> saveXML ( ) ; }
6925	private function getFindOneByCountryAndMethodAndWeightQuery ( ) { if ( null === $ this -> findOneByCountryAndMethodAndWeightQuery ) { $ qb = $ this -> getCollectionQueryBuilder ( 'o' ) ; $ qb -> join ( 'o.zone' , 'z' ) -> join ( 'o.method' , 'm' ) -> andWhere ( $ qb -> expr ( ) -> isMemberOf ( ':country' , 'z.countries' ) ) -> andWhere ( $ qb -> expr ( ) -> gte ( 'o.weight' , ':weight' ) ) -> andWhere ( $ qb -> expr ( ) -> eq ( 'o.method' , ':method' ) ) -> addOrderBy ( 'o.weight' , 'ASC' ) -> setMaxResults ( 1 ) ; $ this -> findOneByCountryAndMethodAndWeightQuery = $ qb -> getQuery ( ) ; } return $ this -> findOneByCountryAndMethodAndWeightQuery ; }
415	public function getAcceptableContentTypes ( ) { if ( $ this -> _contentTypes === null ) { if ( $ this -> headers -> get ( 'Accept' ) !== null ) { $ this -> _contentTypes = $ this -> parseAcceptHeader ( $ this -> headers -> get ( 'Accept' ) ) ; } else { $ this -> _contentTypes = [ ] ; } } return $ this -> _contentTypes ; }
7464	public function newAction ( Request $ request , $ hash ) { $ passwordHelper = $ this -> get ( 'orkestra.application.helper.password' ) ; $ hashedEntityHelper = $ this -> get ( 'orkestra.application.helper.hashed_entity' ) ; $ hashedEntity = $ passwordHelper -> lookup ( $ hash ) ; if ( ! $ hashedEntity ) { throw new EntityNotFoundException ( ) ; } $ user = $ hashedEntity -> getReferencedObject ( ) ; $ hashedEntityHelper -> invalidate ( $ hashedEntity ) ; $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ em -> persist ( $ hashedEntity ) ; $ em -> flush ( ) ; if ( $ user ) { $ request -> getSession ( ) -> set ( PasswordSetController :: CURRENT_USER_ID_KEY , $ user -> getId ( ) ) ; $ form = $ this -> getSetPasswordForm ( ) ; return array ( 'form' => $ form -> createView ( ) ) ; } else { throw $ this -> createNotFoundException ( 'No user was found.' ) ; } }
4408	public function onKernelController ( FilterControllerEvent $ event ) { if ( $ event -> getRequestType ( ) !== HttpKernelInterface :: MASTER_REQUEST ) { return ; } if ( ! $ this -> isAdminSiteAccess ) { return ; } $ currentRoute = $ event -> getRequest ( ) -> attributes -> get ( '_route' ) ; foreach ( $ this -> legacyRoutes as $ legacyRoute ) { if ( stripos ( $ currentRoute , $ legacyRoute ) === 0 ) { $ event -> getRequest ( ) -> attributes -> set ( '_controller' , 'ezpublish_legacy.controller:indexAction' ) ; $ event -> setController ( $ this -> controllerResolver -> getController ( $ event -> getRequest ( ) ) ) ; return ; } } }
6765	protected function handleUpdate ( SaleInterface $ sale ) { $ changed = false ; $ changed |= $ this -> updateNumber ( $ sale ) ; $ changed |= $ this -> updateKey ( $ sale ) ; $ changed |= $ this -> updateInformation ( $ sale , true ) ; if ( $ this -> persistenceHelper -> isChanged ( $ sale , 'vatNumber' ) ) { $ changed |= $ this -> pricingUpdater -> updateVatNumberSubject ( $ sale ) ; } if ( $ this -> persistenceHelper -> isChanged ( $ sale , 'customer' ) ) { $ changed |= $ this -> saleUpdater -> updatePaymentTerm ( $ sale ) ; } if ( $ this -> persistenceHelper -> isChanged ( $ sale , [ 'shipmentMethod' , 'customerGroup' ] ) ) { $ changed = $ this -> saleUpdater -> updateShipmentMethodAndAmount ( $ sale ) ; } if ( $ this -> isDiscountUpdateNeeded ( $ sale ) ) { $ changed |= $ this -> saleUpdater -> updateDiscounts ( $ sale , true ) ; } if ( $ this -> isTaxationUpdateNeeded ( $ sale ) ) { $ changed |= $ this -> saleUpdater -> updateTaxation ( $ sale , true ) ; } elseif ( $ this -> isShipmentTaxationUpdateNeeded ( $ sale ) ) { $ changed |= $ this -> saleUpdater -> updateShipmentTaxation ( $ sale , true ) ; } return $ changed ; }
10087	private function createZip ( $ pFilename ) { $ zip = new ZipArchive ( ) ; if ( file_exists ( $ pFilename ) ) { unlink ( $ pFilename ) ; } if ( $ zip -> open ( $ pFilename , ZipArchive :: OVERWRITE ) !== true ) { if ( $ zip -> open ( $ pFilename , ZipArchive :: CREATE ) !== true ) { throw new WriterException ( "Could not open $pFilename for writing." ) ; } } return $ zip ; }
11837	public function getLogo ( $ size = null ) { if ( ! $ this -> logoPath || ! file_exists ( $ this -> logoPath ) ) { return ; } $ cacheLogo = $ this -> sizeImageCache ( $ this -> logoPath , $ size ) ; if ( $ cacheLogo ) { return $ this -> getCacheAssetUrl ( $ cacheLogo ) ; } return false ; }
1807	public function storeDateAdded ( $ dc ) { if ( ! $ dc instanceof Contao \ DataContainer ) { return ; } if ( ! $ dc -> activeRecord || $ dc -> activeRecord -> dateAdded > 0 ) { return ; } if ( $ dc -> activeRecord -> lastLogin > 0 ) { $ time = $ dc -> activeRecord -> lastLogin ; } else { $ time = time ( ) ; } $ this -> Database -> prepare ( "UPDATE tl_member SET dateAdded=? WHERE id=?" ) -> execute ( $ time , $ dc -> id ) ; }
10122	private function writePrintHeaders ( ) { $ record = 0x002a ; $ length = 0x0002 ; $ fPrintRwCol = $ this -> printHeaders ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ fPrintRwCol ) ; $ this -> append ( $ header . $ data ) ; }
10273	function updateCustomProperty ( $ mailingId , $ property ) { $ queryParameters = array ( 'name' => $ property -> key , 'value' => $ property -> value ) ; return $ this -> put ( "mailings/${mailingId}/settings/properties" , "" , $ queryParameters ) ; }
1332	protected function readWithFilters ( $ record , EncodingParametersInterface $ parameters ) { $ query = $ this -> newQuery ( ) -> whereKey ( $ record -> getKey ( ) ) ; $ this -> applyFilters ( $ query , collect ( $ parameters -> getFilteringParameters ( ) ) ) ; return $ query -> exists ( ) ? $ record : null ; }
6914	public function removeShipment ( ShipmentInterface $ shipment ) { if ( $ this -> shipments -> contains ( $ shipment ) ) { $ this -> shipments -> removeElement ( $ shipment ) ; } return $ this ; }
798	public function insertAt ( $ index , Token $ token ) { $ this -> setSize ( $ this -> getSize ( ) + 1 ) ; for ( $ i = $ this -> getSize ( ) - 1 ; $ i > $ index ; -- $ i ) { $ this [ $ i ] = isset ( $ this [ $ i - 1 ] ) ? $ this [ $ i - 1 ] : new Token ( ) ; } $ this [ $ index ] = $ token ; }
4236	public function emailLog ( ) { $ errorStr = $ this -> buildErrorList ( ) ; $ subject = 'Debug Log' ; $ subjectMore = '' ; if ( ! empty ( $ _SERVER [ 'HTTP_HOST' ] ) ) { $ subjectMore .= ' ' . $ _SERVER [ 'HTTP_HOST' ] ; } if ( $ errorStr ) { $ subjectMore .= ' ' . ( $ subjectMore ? '(Error)' : 'Error' ) ; } $ subject = \ rtrim ( $ subject . ':' . $ subjectMore , ':' ) ; $ body = ( ! isset ( $ _SERVER [ 'REQUEST_URI' ] ) && ! empty ( $ _SERVER [ 'argv' ] ) ? 'Command: ' . \ implode ( ' ' , $ _SERVER [ 'argv' ] ) : 'Request: ' . $ _SERVER [ 'REQUEST_METHOD' ] . ' ' . $ _SERVER [ 'REQUEST_URI' ] ) . "\n\n" ; if ( $ errorStr ) { $ body .= 'Error(s):' . "\n" . $ errorStr . "\n" ; } $ data = \ array_intersect_key ( $ this -> debug -> getData ( ) , \ array_flip ( array ( 'alerts' , 'log' , 'logSummary' , 'requestId' , 'runtime' , ) ) ) ; $ data [ 'rootChannel' ] = $ this -> debug -> getCfg ( 'channel' ) ; $ body .= $ this -> debug -> utilities -> serializeLog ( $ data ) ; $ this -> email ( $ this -> debug -> getCfg ( 'emailTo' ) , $ subject , $ body ) ; return ; }
4348	private function getConfigKeys ( ) { if ( isset ( $ this -> configKeys ) ) { return $ this -> configKeys ; } $ this -> configKeys = array ( 'debug' => array ( ) , 'abstracter' => array ( 'cacheMethods' , 'collectConstants' , 'collectMethods' , 'objectsExclude' , 'objectSort' , 'useDebugInfo' , ) , 'errorEmailer' => array ( 'emailBacktraceDumper' , 'emailMask' , 'emailMin' , 'emailThrottledSummary' , 'emailThrottleFile' , 'emailThrottleRead' , 'emailThrottleWrite' , 'emailTraceMask' , ) , 'errorHandler' => \ array_keys ( $ this -> debug -> errorHandler -> getCfg ( ) ) , 'output' => array ( 'addBR' , 'css' , 'displayListKeys' , 'filepathCss' , 'filepathScript' , 'onOutput' , 'outputAs' , 'outputAsDefaultNonHtml' , 'outputConstants' , 'outputCss' , 'outputHeaders' , 'outputMethodDescription' , 'outputMethods' , 'outputScript' , ) , ) ; return $ this -> configKeys ; }
12915	protected function getColumnReference ( $ column , $ tableless ) { if ( $ tableless ) { return $ column ; } if ( count ( explode ( "." , $ column ) ) > 1 ) { return $ column ; } return "`" . $ this -> table . "`.`" . $ column . "`" ; }
9283	private function needsCompilation ( $ lessPath , $ cssPath ) { $ isNewer = function ( $ subject , $ reference ) { return filemtime ( $ subject ) > filemtime ( $ reference ) ; } ; if ( $ this -> forceCompile || ! file_exists ( $ lessPath ) || ! file_exists ( $ cssPath ) || $ isNewer ( $ lessPath , $ cssPath ) ) { return true ; } return $ this -> checkImports ( $ lessPath , $ cssPath , $ isNewer ) ; }
9816	public function writeRawData ( $ text ) { if ( is_array ( $ text ) ) { $ text = implode ( "\n" , $ text ) ; } return $ this -> writeRaw ( htmlspecialchars ( $ text ) ) ; }
2623	public function daysFromInstallation ( ) { $ stat = $ this -> statisticRepository -> getStatByAction ( self :: FASTLY_INSTALLED_FLAG ) ; if ( ! $ stat -> getCreatedAt ( ) ) { return null ; } $ installDate = date_create ( $ stat -> getCreatedAt ( ) ) ; $ currentDate = date_create ( $ this -> dateTime -> gmtDate ( ) ) ; $ dateDiff = date_diff ( $ installDate , $ currentDate ) ; return $ dateDiff -> days ; }
6768	protected function handleContentChange ( SaleInterface $ sale ) { $ changed = $ this -> saleUpdater -> updateShipmentMethodAndAmount ( $ sale ) ; if ( $ this -> isShipmentTaxationUpdateNeeded ( $ sale ) ) { $ changed = $ this -> saleUpdater -> updateShipmentTaxation ( $ sale , true ) ; } $ changed |= $ this -> saleUpdater -> updateTotals ( $ sale ) ; $ changed |= $ this -> updateState ( $ sale ) ; $ changed |= $ this -> saleUpdater -> updateOutstandingDate ( $ sale ) ; return $ changed ; }
3231	static function loadFromJsonFile ( $ path ) { if ( ! file_exists ( $ path ) ) { throw new AuthInfoLoadException ( "File doesn't exist: \"$path\"" ) ; } $ str = Util :: stripUtf8Bom ( file_get_contents ( $ path ) ) ; $ jsonArr = json_decode ( $ str , true , 10 ) ; if ( is_null ( $ jsonArr ) ) { throw new AuthInfoLoadException ( "JSON parse error: \"$path\"" ) ; } return self :: loadFromJson ( $ jsonArr ) ; }
4708	public function initialize ( Text $ text , array $ options = array ( ) ) { $ text -> replace ( '{ ^[ ]{0,' . $ options [ 'tabWidth' ] . '}\[(.+)\]: # id = $1 [ \t]* \n? # maybe *one* newline [ \t]* <?(\S+?)>? # url = $2 [ \t]* \n? # maybe one newline [ \t]* (?: (?<=\s) # lookbehind for whitespace ["\'(] (.+?) # title = $3 ["\')] [ \t]* )? # title is optional (?:\n+|\Z) }xm' , function ( Text $ whole , Text $ id , Text $ url , Text $ title = null ) { $ id -> lower ( ) ; $ this -> markdown -> emit ( 'escape.special_chars' , [ $ url -> replace ( '/(?<!\\\\)_/' , '\\\\_' ) ] ) ; $ this -> markdown -> getUrlRegistry ( ) -> set ( $ id , htmlspecialchars ( $ url , ENT_QUOTES , 'UTF-8' , false ) ) ; if ( $ title ) { $ this -> markdown -> getTitleRegistry ( ) -> set ( $ id , preg_replace ( '/"/' , '&quot;' , $ title ) ) ; } return '' ; } ) ; }
330	public function get ( $ key ) { $ key = $ this -> buildKey ( $ key ) ; $ value = $ this -> getValue ( $ key ) ; if ( $ value === false || $ this -> serializer === false ) { return $ value ; } elseif ( $ this -> serializer === null ) { $ value = unserialize ( $ value ) ; } else { $ value = call_user_func ( $ this -> serializer [ 1 ] , $ value ) ; } if ( is_array ( $ value ) && ! ( $ value [ 1 ] instanceof Dependency && $ value [ 1 ] -> isChanged ( $ this ) ) ) { return $ value [ 0 ] ; } return false ; }
11317	public function note ( string $ message ) : void { $ this -> logger -> log ( $ this -> level , strip_tags ( $ message ) ) ; }
11037	function store_reduce ( & $ elts , $ value ) { switch ( strtoupper ( $ value ) ) { case 'OFF' : case 'NOTHING' : $ elts [ '0reduce' ] = _ETS_REDUCE_OFF ; return TRUE ; case 'SPACE' : case 'SPACES' : $ elts [ '0reduce' ] = _ETS_REDUCE_SPACES ; return TRUE ; case 'CRLF' : case 'ON' : case 'ALL' : $ elts [ '0reduce' ] = _ETS_REDUCE_ALL ; return TRUE ; default : return FALSE ; } }
11746	public function device ( ) { if ( is_null ( $ this -> device ) ) { $ this -> device = new Device ( $ this -> accessToken ) ; } return $ this -> device ; }
7351	public function isPaid ( ) { return 0 <= Money :: compare ( $ this -> paidTotal , $ this -> grandTotal , $ this -> getCurrency ( ) -> getCode ( ) ) ; }
4033	public function push ( $ url , $ table , $ icon ) { $ this -> elements [ ] = [ 'url' => $ url , 'text' => $ this -> getLabel ( $ table ) , 'icon' => $ this -> iconBuilder -> getBackendIcon ( $ icon ) ] ; }
8324	public function getPingbacks ( ) { $ response = $ this -> getHttpClient ( ) -> request ( 'GET' , "/res.php?key={$this->apiKey}&action=get_pingback" ) ; $ responseText = $ response -> getBody ( ) -> __toString ( ) ; if ( strpos ( $ responseText , 'OK|' ) !== false ) { $ data = explode ( '|' , $ responseText ) ; unset ( $ data [ 0 ] ) ; return empty ( $ data [ 1 ] ) ? [ ] : array_values ( $ data ) ; } throw new ErrorResponseException ( $ this -> getErrorMessage ( $ responseText ) ? : $ responseText , $ this -> getErrorCode ( $ responseText ) ? : 0 ) ; }
1608	public function bulk ( $ redirects , $ separator , $ type , $ siteId ) { $ rawRedirects = array_map ( function ( $ line ) use ( $ separator ) { return str_getcsv ( $ line , $ separator ) ; } , explode ( PHP_EOL , $ redirects ) ) ; $ newFormatted = [ ] ; foreach ( $ rawRedirects as $ redirect ) { $ record = new RedirectRecord ( ) ; $ record -> uri = $ redirect [ 0 ] ; $ record -> to = $ redirect [ 1 ] ; $ record -> type = array_key_exists ( 2 , $ redirect ) ? $ redirect [ 2 ] : $ type ; $ record -> siteId = $ siteId ; $ record -> save ( ) ; $ newFormatted [ ] = [ 'id' => $ record -> id , 'uri' => $ record -> uri , 'to' => $ record -> to , 'type' => $ record -> type , 'siteId' => $ record -> siteId , ] ; } return [ $ newFormatted , false ] ; }
718	public function timestamp ( $ precision = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_TIMESTAMP , $ precision ) ; }
2778	public function cloneRepository ( string $ repository , ? string $ directory = null , array $ options = [ ] ) : GitWorkingCopy { if ( $ directory === null ) { $ directory = self :: parseRepositoryName ( $ repository ) ; } $ git = $ this -> workingCopy ( $ directory ) ; $ git -> cloneRepository ( $ repository , $ options ) ; $ git -> setCloned ( true ) ; return $ git ; }
4699	public function errorInfo ( ) { static $ statusStrings = array ( \ ZipArchive :: ER_OK => 'No error' , \ ZipArchive :: ER_MULTIDISK => 'Multi-disk zip archives not supported' , \ ZipArchive :: ER_RENAME => 'Renaming temporary file failed' , \ ZipArchive :: ER_CLOSE => 'Closing zip archive failed' , \ ZipArchive :: ER_SEEK => 'Seek error' , \ ZipArchive :: ER_READ => 'Read error' , \ ZipArchive :: ER_WRITE => 'Write error' , \ ZipArchive :: ER_CRC => 'CRC error' , \ ZipArchive :: ER_ZIPCLOSED => 'Containing zip archive was closed' , \ ZipArchive :: ER_NOENT => 'No such file' , \ ZipArchive :: ER_EXISTS => 'File already exists' , \ ZipArchive :: ER_OPEN => 'Can\'t open file' , \ ZipArchive :: ER_TMPOPEN => 'Failure to create temporary file' , \ ZipArchive :: ER_ZLIB => 'Zlib error' , \ ZipArchive :: ER_MEMORY => 'Malloc failure' , \ ZipArchive :: ER_CHANGED => 'Entry has been changed' , \ ZipArchive :: ER_COMPNOTSUPP => 'Compression method not supported' , \ ZipArchive :: ER_EOF => 'Premature EOF' , \ ZipArchive :: ER_INVAL => 'Invalid argument' , \ ZipArchive :: ER_NOZIP => 'Not a zip archive' , \ ZipArchive :: ER_INTERNAL => 'Internal error' , \ ZipArchive :: ER_INCONS => 'Zip archive inconsistent' , \ ZipArchive :: ER_REMOVE => 'Can\'t remove file' , \ ZipArchive :: ER_DELETED => 'Entry has been deleted' , ) ; if ( isset ( $ statusStrings [ $ this -> ziparchive -> status ] ) ) { $ statusString = $ statusStrings [ $ this -> ziparchive -> status ] ; } else { $ statusString = 'Unknown status' ; } return $ statusString . '(' . $ this -> ziparchive -> status . ')' ; }
3085	public function getAssessmentItemRefsByPlaceholder ( \ tao_models_classes_service_StorageDirectory $ privateCompilationDirectory , AssessmentItemRef $ placeholder ) { $ urlinfo = parse_url ( $ placeholder -> getHref ( ) ) ; $ adaptiveSectionId = ltrim ( $ urlinfo [ 'path' ] , '/' ) ; $ compilationDataService = $ this -> getServiceLocator ( ) -> get ( CompilationDataService :: SERVICE_ID ) ; $ filename = "adaptive-assessment-section-${adaptiveSectionId}" ; $ component = $ compilationDataService -> readPhpCompilationData ( $ privateCompilationDirectory , "${filename}.php" , $ filename ) ; return $ component -> getComponentsByClassName ( 'assessmentItemRef' ) -> getArrayCopy ( ) ; }
4464	public function childPerform ( BaseJob $ job ) : void { $ loggerContext = [ 'job' => $ job -> jid , 'type' => $ this -> who ] ; try { if ( $ this -> jobPerformHandler ) { if ( $ this -> jobPerformHandler instanceof EventsManagerAwareInterface ) { $ this -> jobPerformHandler -> setEventsManager ( $ this -> client -> getEventsManager ( ) ) ; } if ( method_exists ( $ this -> jobPerformHandler , 'setUp' ) ) { $ this -> jobPerformHandler -> setUp ( ) ; } $ this -> getEventsManager ( ) -> fire ( new JobEvent \ BeforePerform ( $ this -> jobPerformHandler , $ job ) ) ; $ this -> jobPerformHandler -> perform ( $ job ) ; $ this -> getEventsManager ( ) -> fire ( new JobEvent \ AfterPerform ( $ this -> jobPerformHandler , $ job ) ) ; if ( method_exists ( $ this -> jobPerformHandler , 'tearDown' ) ) { $ this -> jobPerformHandler -> tearDown ( ) ; } } else { $ job -> perform ( ) ; } $ this -> logger -> notice ( '{type}: job {job} has finished' , $ loggerContext ) ; } catch ( \ Throwable $ e ) { $ loggerContext [ 'stack' ] = $ e -> getMessage ( ) ; $ this -> logger -> critical ( '{type}: job {job} has failed {stack}' , $ loggerContext ) ; $ job -> fail ( 'system:fatal' , sprintf ( '%s: %s in %s on line %d' , get_class ( $ e ) , $ e -> getMessage ( ) , $ e -> getFile ( ) , $ e -> getLine ( ) ) ) ; } }
8022	public function addField ( $ title , $ value , $ short = false ) { $ this -> fields [ ] = [ 'title' => $ title , 'value' => $ value , 'short' => $ short ] ; }
9450	protected function pathExtract ( ) : array { $ regExp = [ ] ; $ path = $ this -> path ; if ( \ is_array ( $ this -> path ) ) { $ regExp = \ array_pop ( $ this -> path ) ; $ path = \ array_pop ( $ this -> path ) ; } return [ $ path , $ regExp ] ; }
8093	public function get ( $ keyPath ) { $ stops = explode ( '.' , $ keyPath ) ; $ value = $ this ; foreach ( $ stops as $ key ) { if ( $ value instanceof Collection ) { $ value = $ value -> $ key ; } else { $ value = null ; break ; } } return $ value ; }
6224	public function removeDir ( ) : bool { if ( ! $ this -> isDir ( ) ) { throw new AccessDeniedException ( sprintf ( 'unable to remove directory for path: "%s"' , $ this -> path -> raw ) , 500 ) ; } try { $ iterator = $ this -> getIterator ( true , \ RecursiveIteratorIterator :: CHILD_FIRST ) ; foreach ( $ iterator as $ splFile ) { if ( ! $ splFile -> isReadable ( ) ) { throw new AccessDeniedException ( sprintf ( 'unable to access file for path: "%s"' , $ splFile -> getPathname ( ) ) , 500 ) ; } switch ( $ splFile -> getType ( ) ) { case 'dir' : rmdir ( $ splFile -> getRealPath ( ) ) ; break ; case 'link' : unlink ( $ splFile -> getPathname ( ) ) ; break ; default : unlink ( $ splFile -> getRealPath ( ) ) ; } } return rmdir ( $ this -> path -> raw ) ; } finally { $ this -> selfdestruct = false ; $ this -> path -> reload ( ) ; } }
9242	private function __next ( ServerRequestInterface $ request , ResponseInterface $ response , $ next ) { $ this -> __loadConfigFiles ( ) ; return $ next ( $ request , $ response ) ; }
9248	public function from ( Contract $ contract , string $ string , callable $ callback = null ) : string { return $ this -> callback ( $ contract -> recipe ( $ string , 'upperCaseFirst' , function ( $ string ) use ( $ contract ) { if ( $ contract instanceof ClassName ) { return lcfirst ( $ string ) ; } return strtolower ( $ string ) ; } ) , $ callback ) ; }
7149	private function calculateAdjustment ( AdjustmentDataInterface $ adjustment , $ base ) { if ( $ adjustment -> getMode ( ) === AdjustmentModes :: MODE_PERCENT ) { return Money :: round ( $ base * $ adjustment -> getAmount ( ) / 100 , $ this -> currency ) ; } if ( $ adjustment -> getMode ( ) === AdjustmentModes :: MODE_FLAT ) { return $ adjustment -> getAmount ( ) ; } throw new InvalidArgumentException ( "Unexpected adjustment mode." ) ; }
8869	public function attach ( Runner $ runner ) { if ( $ this -> runners -> contains ( $ runner ) ) { throw new LogicException ( 'Can\'t attach already attached runner.' ) ; } $ this -> runners -> attach ( $ runner ) ; return $ this ; }
1117	public static function roots ( ) { $ instance = new static ; return $ instance -> newQuery ( ) -> whereNull ( $ instance -> getParentColumnName ( ) ) -> orderBy ( $ instance -> getQualifiedOrderColumnName ( ) ) ; }
5296	public function setOptions ( $ options = array ( ) ) { $ this -> options = array_merge ( $ this -> options , $ options ) ; $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] [ 'id' ] = $ this -> options [ 'id' ] ; $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] [ 'horiz-adv-x' ] = $ this -> options [ 'horiz-adv-x' ] ; $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] -> { 'font-face' } [ 0 ] [ 'units-per-em' ] = $ this -> options [ 'units-per-em' ] ; $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] -> { 'font-face' } [ 0 ] [ 'ascent' ] = $ this -> options [ 'ascent' ] ; $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] -> { 'font-face' } [ 0 ] [ 'descent' ] = $ this -> options [ 'descent' ] ; $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] -> { 'font-face' } [ 0 ] [ 'x-height' ] = $ this -> options [ 'x-height' ] ; $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] -> { 'font-face' } [ 0 ] [ 'cap-height' ] = $ this -> options [ 'cap-height' ] ; $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] -> { 'missing-glyph' } [ 0 ] [ 'horiz-adv-x' ] = $ this -> options [ 'horiz-adv-x' ] ; }
5114	private function conv ( $ str ) { if ( $ this -> supportsExtMbstring ) { return mb_convert_encoding ( $ str , 'UTF-16BE' , 'UTF-8' ) ; } return preg_replace_callback ( '/./su' , function ( $ m ) { if ( ! isset ( $ m [ 0 ] [ 1 ] ) ) { return "\x00" . $ m [ 0 ] ; } if ( isset ( $ m [ 0 ] [ 3 ] ) ) { $ code = ( ( ord ( $ m [ 0 ] [ 0 ] ) & 0x07 ) << 18 ) + ( ( ord ( $ m [ 0 ] [ 1 ] ) & 0x3F ) << 12 ) + ( ( ord ( $ m [ 0 ] [ 2 ] ) & 0x3F ) << 6 ) + ( ord ( $ m [ 0 ] [ 3 ] ) & 0x3F ) ; return pack ( 'nn' , ( $ code - 0x10000 >> 10 ) | 0xD800 , ( $ code & 0x03FF ) | 0xDC00 ) ; } if ( isset ( $ m [ 0 ] [ 2 ] ) ) { $ code = ( ( ord ( $ m [ 0 ] [ 0 ] ) & 0x0F ) << 12 ) + ( ( ord ( $ m [ 0 ] [ 1 ] ) & 0x3F ) << 6 ) + ( ord ( $ m [ 0 ] [ 2 ] ) & 0x3F ) ; } else { $ code = ( ( ord ( $ m [ 0 ] [ 0 ] ) & 0x1F ) << 6 ) + ( ord ( $ m [ 0 ] [ 1 ] ) & 0x3F ) ; } return chr ( $ code >> 8 ) . chr ( $ code & 0xFF ) ; } , $ str ) ; }
8122	public function getReviewContentForm ( $ id ) { $ page = $ this -> findRecord ( [ 'ID' => $ id ] ) ; $ user = Security :: getCurrentUser ( ) ; if ( ! $ page -> canEdit ( ) || ( $ page -> hasMethod ( 'canBeReviewedBy' ) && ! $ page -> canBeReviewedBy ( $ user ) ) ) { $ this -> owner -> httpError ( 403 , _t ( __CLASS__ . '.ErrorItemPermissionDenied' , 'It seems you don\'t have the necessary permissions to review this content' ) ) ; return null ; } $ form = $ this -> getReviewContentHandler ( ) -> Form ( $ page ) ; $ form -> setValidationResponseCallback ( function ( ValidationResult $ errors ) use ( $ form , $ id ) { $ schemaId = $ this -> owner -> join_links ( $ this -> owner -> Link ( 'schema/ReviewContentForm' ) , $ id ) ; return $ this -> getSchemaResponse ( $ schemaId , $ form , $ errors ) ; } ) ; return $ form ; }
9873	private function writeDrawings ( XMLWriter $ objWriter = null , PhpspreadsheetWorksheet $ pSheet = null , $ includeCharts = false ) { $ chartCount = ( $ includeCharts ) ? $ pSheet -> getChartCollection ( ) -> count ( ) : 0 ; if ( ( $ pSheet -> getDrawingCollection ( ) -> count ( ) > 0 ) || ( $ chartCount > 0 ) ) { $ objWriter -> startElement ( 'drawing' ) ; $ objWriter -> writeAttribute ( 'r:id' , 'rId1' ) ; $ objWriter -> endElement ( ) ; } }
1499	public function when ( bool $ test , $ encodings ) : self { if ( ! $ test || is_null ( $ encodings ) ) { return $ this ; } if ( $ encodings instanceof \ Closure ) { return $ encodings ( $ this ) ; } if ( is_string ( $ encodings ) ) { $ encodings = Encoding :: custom ( $ encodings ) ; } $ encodings = $ encodings instanceof Encoding ? [ $ encodings ] : $ encodings ; return $ this -> push ( ... $ encodings ) ; }
9200	public function uploadMedia ( $ filepaths , $ client = null ) { $ maxMediaIds = Config :: get ( 'max_media_ids' ) ; if ( count ( $ filepaths ) > $ maxMediaIds ) { throw new MediaUploadLimitException ( "You cannot upload more than ${maxMediaIds} media files in a tweet!" ) ; } $ mediaIds = array ( ) ; if ( is_null ( $ client ) ) { $ client = $ this -> createGuzzleClient ( Config :: get ( 'base_upload_url' ) ) ; } $ endpoint = $ this -> prependVersionToEndpoint ( "media/upload.json" , Config :: get ( 'api_version' ) ) ; foreach ( $ filepaths as $ filepath ) { $ options = $ this -> constructRequestOptions ( array ( ) , $ client ) ; $ options [ 'body' ] = array ( 'media' => new PostFile ( 'media' , fopen ( $ filepath , 'r' ) ) ) ; $ response = $ client -> post ( $ endpoint , $ options ) ; array_push ( $ mediaIds , $ response -> json ( ) [ 'media_id_string' ] ) ; } return ( implode ( "," , $ mediaIds ) ) ; }
5078	public function getSearch ( $ aData = [ ] ) { $ oInput = Factory :: service ( 'Input' ) ; $ oHttpCodes = Factory :: service ( 'HttpCodes' ) ; $ oItemModel = Factory :: model ( static :: CONFIG_MODEL_NAME , static :: CONFIG_MODEL_PROVIDER ) ; $ sKeywords = $ oInput -> get ( 'search' ) ? : $ oInput -> get ( 'keywords' ) ; $ iPage = ( int ) $ oInput -> get ( 'page' ) ; if ( strlen ( $ sKeywords ) < static :: CONFIG_MIN_SEARCH_LENGTH ) { throw new ApiException ( 'Search term must be ' . static :: CONFIG_MIN_SEARCH_LENGTH . ' characters or longer.' , $ oHttpCodes :: STATUS_BAD_REQUEST ) ; } $ oResult = $ oItemModel -> search ( $ sKeywords , $ iPage , static :: CONFIG_MAX_ITEMS_PER_PAGE , $ aData ) ; $ oResponse = Factory :: factory ( 'ApiResponse' , 'nails/module-api' ) ; $ oResponse -> setData ( array_map ( [ $ this , 'formatObject' ] , $ oResult -> data ) ) ; return $ oResponse ; }
9619	public function checkAnswer ( $ extraParams = array ( ) ) { $ remoteIp = $ _SERVER [ "REMOTE_ADDR" ] ; $ challenge = $ _POST [ "recaptcha_challenge_field" ] ; $ response = $ _POST [ "recaptcha_response_field" ] ; if ( ! $ this -> getPrivateKey ( ) ) { throw new \ Exception ( "To use reCAPTCHA you must get an API key from <a href='https://www.google.com/recaptcha/admin/create'>https://www.google.com/recaptcha/admin/create</a>" ) ; } if ( ! $ remoteIp ) { throw new \ Exception ( "For security reasons, you must pass the remote ip to reCAPTCHA" ) ; } if ( ! $ challenge ) { $ this -> valid = false ; $ this -> error = 'incorrect-captcha-sol' ; } else { $ response = $ this -> httpPost ( self :: RECAPTCHA_VERIFY_SERVER , '/recaptcha/api/verify' , array ( 'privatekey' => $ this -> getPrivateKey ( ) , 'remoteip' => $ remoteIp , 'challenge' => $ challenge , 'response' => $ response , ) + $ extraParams ) ; $ answers = explode ( "\n" , $ response [ 1 ] ) ; if ( trim ( $ answers [ 0 ] ) == 'true' ) { $ this -> valid = true ; } else { $ this -> valid = false ; $ this -> error = $ answers [ 1 ] ; } } return $ this ; }
6410	public static function concatIterables ( IteratorAggregate $ iterables ) : IteratorAggregate { return self :: from ( Iterators :: concatIterators ( FluentIterable :: from ( $ iterables ) -> transform ( function ( Traversable $ element ) { return Iterators :: from ( $ element ) ; } ) -> iterator ( ) ) ) ; }
4505	public function getList ( Parameters $ parameters = null ) : array { $ options = [ ] ; if ( $ parameters ) { $ options [ 'query' ] = ( array ) $ parameters -> toObject ( true ) ; if ( array_key_exists ( 'organizationUuid' , $ options [ 'query' ] ) ) { $ options [ 'query' ] [ 'organization.uuid' ] = $ options [ 'query' ] [ 'organizationUuid' ] ; unset ( $ options [ 'query' ] [ 'organizationUuid' ] ) ; } } $ objects = $ this -> execute ( 'GET' , static :: RESOURCE_LIST , $ options ) ; $ list = [ ] ; foreach ( $ objects as $ object ) { $ model = static :: toModel ( $ object ) ; $ list [ ] = $ model ; } return $ list ; }
10643	public function getParent ( ) { if ( $ this -> path === "/" || ( $ path = dirname ( $ this -> path ) ) === "." ) { return null ; } return new DirEntity ( $ path ) ; }
10086	public function writeDebugLog ( ... $ args ) { if ( $ this -> writeDebugLog ) { $ message = implode ( $ args ) ; $ cellReference = implode ( ' -> ' , $ this -> cellStack -> showStack ( ) ) ; if ( $ this -> echoDebugLog ) { echo $ cellReference , ( $ this -> cellStack -> count ( ) > 0 ? ' => ' : '' ) , $ message , PHP_EOL ; } $ this -> debugLog [ ] = $ cellReference . ( $ this -> cellStack -> count ( ) > 0 ? ' => ' : '' ) . $ message ; } }
90	private static function throwEncodeError ( $ code ) { switch ( $ code ) { case JSON_ERROR_DEPTH : $ msg = 'Maximum stack depth exceeded' ; break ; case JSON_ERROR_STATE_MISMATCH : $ msg = 'Underflow or the modes mismatch' ; break ; case JSON_ERROR_CTRL_CHAR : $ msg = 'Unexpected control character found' ; break ; case JSON_ERROR_UTF8 : $ msg = 'Malformed UTF-8 characters, possibly incorrectly encoded' ; break ; default : $ msg = 'Unknown error' ; } throw new \ RuntimeException ( 'JSON encoding failed: ' . $ msg ) ; }
1897	private function isExistingOptionalFile ( SplFileInfo $ file , string $ webDir ) : bool { $ path = $ file -> getRelativePathname ( ) ; return 'robots.txt' === $ path && $ this -> fs -> exists ( $ webDir . '/' . $ path ) ; }
7358	private function loadPriceMap ( ) { if ( null === $ this -> pricesMap ) { $ this -> pricesMap = $ this -> getPricesMapLoader ( ) -> load ( $ this -> currency ) ; } }
3200	protected function binaryPopCount ( $ value ) { $ value -= ( ( $ value >> 1 ) & 0x55555555 ) ; $ value = ( ( ( $ value >> 2 ) & 0x33333333 ) + ( $ value & 0x33333333 ) ) ; $ value = ( ( ( $ value >> 4 ) + $ value ) & 0x0f0f0f0f ) ; $ value += ( $ value >> 8 ) ; $ value += ( $ value >> 16 ) ; return $ value & 0x0000003f ; }
7267	public function has ( $ forClass , $ forColumn = null ) { $ refTable = static :: tableName ( ) ; $ forTable = $ forClass :: tableName ( ) ; $ refColumn = static :: $ idColumn ; $ forColumn = $ forColumn ? : strtolower ( static :: modelName ( ) ) . "_id" ; $ rows = Db :: query ( " select F.* from $refTable as R, $forTable as F where R.$refColumn = F.$forColumn and R.$refColumn = :id " , [ "id" => $ this -> $ refColumn ] , static :: getDbName ( ) ) ; if ( $ rows === false ) return false ; if ( empty ( $ rows ) ) return null ; $ forModel = new $ forClass ; foreach ( $ rows [ 0 ] as $ col => $ val ) $ forModel -> $ col = $ forModel -> decodeValue ( $ val , $ col ) ; return $ forModel ; }
1411	public function resourceIdNotSupported ( string $ id , string $ path = '/data' ) : ErrorInterface { return new Error ( null , null , Response :: HTTP_CONFLICT , $ this -> trans ( 'resource_id_not_supported' , 'code' ) , $ this -> trans ( 'resource_id_not_supported' , 'title' ) , $ this -> trans ( 'resource_id_not_supported' , 'detail' , compact ( 'id' ) ) , $ this -> pointer ( $ path , 'id' ) ) ; }
3721	public function handleDelete ( PreDeleteModelEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } try { $ this -> tableManipulator -> checkTableExists ( $ tableName = $ event -> getModel ( ) -> getProperty ( 'tableName' ) ) ; } catch ( \ Exception $ exception ) { return ; } $ this -> tableManipulator -> deleteTable ( $ tableName ) ; }
10386	protected function createInitializer ( ) { $ initializer = new Initializer ( ) ; $ initializer -> addTemplate ( 'Common' , new CommonTemplate ( ) ) ; $ initializer -> addTemplate ( 'Laravel' , new LaravelTemplate ( ) ) ; $ initializer -> addTemplate ( 'Symfony' , new SymfonyTemplate ( ) ) ; $ initializer -> addTemplate ( 'Yii' , new YiiTemplate ( ) ) ; $ initializer -> addTemplate ( 'Yii2 Basic App' , new Yii2BasicAppTemplate ( ) ) ; $ initializer -> addTemplate ( 'Yii2 Advanced App' , new Yii2AdvancedAppTemplate ( ) ) ; return $ initializer ; }
3703	protected function getProperty ( $ name , $ legend ) { foreach ( $ legend -> getProperties ( ) as $ property ) { if ( $ property -> getName ( ) === $ name ) { return $ property ; } } $ property = new Property ( $ name ) ; $ legend -> addProperty ( $ property ) ; return $ property ; }
778	public static function checkRequirements ( ) { if ( extension_loaded ( 'imagick' ) ) { $ imagickFormats = ( new \ Imagick ( ) ) -> queryFormats ( 'PNG' ) ; if ( in_array ( 'PNG' , $ imagickFormats , true ) ) { return 'imagick' ; } } if ( extension_loaded ( 'gd' ) ) { $ gdInfo = gd_info ( ) ; if ( ! empty ( $ gdInfo [ 'FreeType Support' ] ) ) { return 'gd' ; } } throw new InvalidConfigException ( 'Either GD PHP extension with FreeType support or ImageMagick PHP extension with PNG support is required.' ) ; }
5977	public function moodboards ( ) { if ( ! $ this -> moodboards instanceof MoodboardsController ) { $ this -> moodboards = new MoodboardsController ( $ this -> getClient ( ) , $ this -> cachePolicy , $ this -> cache ) ; $ this -> moodboards -> setLogger ( $ this -> logger ) ; } return $ this -> moodboards ; }
486	public function addCommentOnTable ( $ table , $ comment ) { $ time = $ this -> beginCommand ( "add comment on table $table" ) ; $ this -> db -> createCommand ( ) -> addCommentOnTable ( $ table , $ comment ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
2907	public function getPartDecodedContent ( Zend_Mime_Part $ mimePart ) { if ( method_exists ( $ mimePart , 'getRawContent' ) ) { return $ mimePart -> getRawContent ( ) ; } $ content = '' ; if ( method_exists ( $ mimePart , 'getContent' ) ) { $ encoding = $ mimePart -> encoding ; $ mimePart -> encoding = 'none' ; $ content = $ mimePart -> getContent ( ) ; $ mimePart -> encoding = $ encoding ; } return $ content ; }
8647	private function configureCurlOptions ( $ action , array $ converted , $ streamHandle = null , $ contentMd5 = null ) { $ curlOptions = $ this -> getDefaultCurlOptions ( ) ; if ( ! is_null ( $ this -> config [ 'ProxyHost' ] ) ) { $ proxy = $ this -> config [ 'ProxyHost' ] ; $ proxy .= ':' . ( $ this -> config [ 'ProxyPort' ] == - 1 ? '80' : $ this -> config [ 'ProxyPort' ] ) ; $ curlOptions [ CURLOPT_PROXY ] = $ proxy ; } if ( array_key_exists ( 'CURLOPT_VERBOSE' , $ this -> config ) && ! is_null ( $ this -> config [ 'CURLOPT_VERBOSE' ] ) ) { $ curlOptions [ CURLOPT_VERBOSE ] = $ this -> config [ 'CURLOPT_VERBOSE' ] ; } $ serviceUrl = $ this -> config [ 'ServiceURL' ] ; if ( ! ( substr ( $ serviceUrl , strlen ( $ serviceUrl ) - 1 ) === '/' ) ) { $ serviceUrl .= '/' ; } $ requestType = MarketplaceWebService_RequestType :: getRequestType ( $ action ) ; if ( $ requestType == MarketplaceWebService_RequestType :: POST_UPLOAD ) { if ( is_null ( $ streamHandle ) || ! is_resource ( $ streamHandle ) ) { throw new MarketplaceWebService_Exception ( array ( 'Message' => 'Missing stream resource.' ) ) ; } $ serviceUrl .= '?' . $ this -> getParametersAsString ( $ converted [ CONVERTED_PARAMETERS_KEY ] ) ; $ curlOptions [ CURLOPT_URL ] = $ serviceUrl ; $ header [ ] = 'Expect: ' ; $ header [ ] = 'Accept: ' ; $ header [ ] = 'Transfer-Encoding: chunked' ; $ header [ ] = 'Content-MD5: ' . $ contentMd5 ; $ curlOptions [ CURLOPT_HTTPHEADER ] = array_merge ( $ header , $ converted [ CONVERTED_HEADERS_KEY ] ) ; rewind ( $ streamHandle ) ; $ curlOptions [ CURLOPT_INFILE ] = $ streamHandle ; $ curlOptions [ CURLOPT_UPLOAD ] = true ; $ curlOptions [ CURLOPT_CUSTOMREQUEST ] = self :: REQUEST_TYPE ; } else if ( ! ( $ requestType === MarketplaceWebService_RequestType :: UNKNOWN ) ) { $ curlOptions [ CURLOPT_URL ] = $ this -> config [ 'ServiceURL' ] ; $ curlOptions [ CURLOPT_POSTFIELDS ] = $ this -> getParametersAsString ( $ converted [ CONVERTED_PARAMETERS_KEY ] ) ; if ( $ requestType == MarketplaceWebService_RequestType :: POST_DOWNLOAD ) { $ this -> responseBodyContents = $ streamHandle ; $ curlOptions [ CURLOPT_WRITEFUNCTION ] = array ( $ this , 'responseCallback' ) ; } } else { throw new InvalidArgumentException ( "$action is not a valid request type." ) ; } return $ curlOptions ; }
4924	public function type ( $ className ) { if ( ! class_exists ( $ className ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Class %s is non-existent or could not be loaded' , $ className ) ) ; } $ this -> matrix [ $ this -> currentRegion ] [ ] = $ className ; return $ this ; }
4387	public function getConfigFE ( \ Aimeos \ MShop \ Order \ Item \ Base \ Iface $ basket ) { $ list = [ ] ; $ feconfig = $ this -> feConfig ; try { $ code = $ this -> getServiceItem ( ) -> getCode ( ) ; $ service = $ basket -> getService ( \ Aimeos \ MShop \ Order \ Item \ Base \ Service \ Base :: TYPE_PAYMENT , $ code ) ; foreach ( $ service -> getAttributeItems ( ) as $ item ) { if ( isset ( $ feconfig [ $ item -> getCode ( ) ] ) ) { $ feconfig [ $ item -> getCode ( ) ] [ 'default' ] = $ item -> getValue ( ) ; } } } catch ( \ Aimeos \ MShop \ Order \ Exception $ e ) { ; } $ addresses = $ basket -> getAddress ( \ Aimeos \ MShop \ Order \ Item \ Base \ Address \ Base :: TYPE_PAYMENT ) ; if ( ( $ address = current ( $ addresses ) ) !== false ) { if ( $ feconfig [ 'novalnetsepa.holder' ] [ 'default' ] == '' && ( $ fn = $ address -> getFirstname ( ) ) !== '' && ( $ ln = $ address -> getLastname ( ) ) !== '' ) { $ feconfig [ 'novalnetsepa.holder' ] [ 'default' ] = $ fn . ' ' . $ ln ; } } foreach ( $ feconfig as $ key => $ config ) { $ list [ $ key ] = new \ Aimeos \ MW \ Criteria \ Attribute \ Standard ( $ config ) ; } return $ list ; }
9840	public function createSymmetricEncryptedJsonResponse ( int $ status , array $ arrayToJsonify , SharedEncryptionKey $ key , array $ headers = [ ] , string $ version = '1.1' ) : ResponseInterface { if ( empty ( $ headers [ 'Content-Type' ] ) ) { $ headers [ 'Content-Type' ] = 'application/json' ; } $ body = \ json_encode ( $ arrayToJsonify , JSON_PRETTY_PRINT ) ; if ( ! \ is_string ( $ body ) ) { throw new InvalidMessageException ( 'Cannot JSON-encode this message.' ) ; } return $ this -> createSymmetricEncryptedResponse ( $ status , $ body , $ key , $ headers , $ version ) ; }
7594	public function render ( $ sLabelMessage , $ aLabelAttributes = 'label-default' ) { if ( ! is_scalar ( $ sLabelMessage ) ) { throw new InvalidArgumentException ( 'Label message expects a scalar value, "' . gettype ( $ sLabelMessage ) . '" given' ) ; } if ( empty ( $ aLabelAttributes ) ) { throw new InvalidArgumentException ( 'Label attributes are empty' ) ; } if ( is_string ( $ aLabelAttributes ) ) { $ aLabelAttributes = array ( 'class' => $ aLabelAttributes ) ; } elseif ( ! is_array ( $ aLabelAttributes ) ) { throw new InvalidArgumentException ( 'Label attributes expects a string or an array, "' . gettype ( $ aLabelAttributes ) . '" given' ) ; } elseif ( empty ( $ aLabelAttributes [ 'class' ] ) ) { throw new \ InvalidArgumentException ( 'Label "class" attribute is empty' ) ; } elseif ( ! is_string ( $ aLabelAttributes [ 'class' ] ) ) { throw new InvalidArgumentException ( 'Label "class" attribute expects string, "' . gettype ( $ aLabelAttributes ) . '" given' ) ; } if ( ! preg_match ( '/(\s|^)label(\s|$)/' , $ aLabelAttributes [ 'class' ] ) ) { $ aLabelAttributes [ 'class' ] .= ' label' ; } if ( null !== ( $ oTranslator = $ this -> getTranslator ( ) ) ) { $ sLabelMessage = $ oTranslator -> translate ( $ sLabelMessage , $ this -> getTranslatorTextDomain ( ) ) ; } return sprintf ( static :: $ labelFormat , isset ( $ aLabelAttributes [ 'tagName' ] ) ? $ aLabelAttributes [ 'tagName' ] : $ this -> tagName , $ this -> createAttributesString ( $ aLabelAttributes ) , $ sLabelMessage ) ; }
495	public function getProfiling ( $ categories = [ ] , $ excludeCategories = [ ] ) { $ timings = $ this -> calculateTimings ( $ this -> messages ) ; if ( empty ( $ categories ) && empty ( $ excludeCategories ) ) { return $ timings ; } foreach ( $ timings as $ i => $ timing ) { $ matched = empty ( $ categories ) ; foreach ( $ categories as $ category ) { $ prefix = rtrim ( $ category , '*' ) ; if ( ( $ timing [ 'category' ] === $ category || $ prefix !== $ category ) && strpos ( $ timing [ 'category' ] , $ prefix ) === 0 ) { $ matched = true ; break ; } } if ( $ matched ) { foreach ( $ excludeCategories as $ category ) { $ prefix = rtrim ( $ category , '*' ) ; foreach ( $ timings as $ i => $ timing ) { if ( ( $ timing [ 'category' ] === $ category || $ prefix !== $ category ) && strpos ( $ timing [ 'category' ] , $ prefix ) === 0 ) { $ matched = false ; break ; } } } } if ( ! $ matched ) { unset ( $ timings [ $ i ] ) ; } } return array_values ( $ timings ) ; }
7974	public function getSender ( $ domain , $ sender ) { if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; if ( ! $ sender ) throw new BadMethodCallException ( 'Parameter $sender is missing.' ) ; $ sender = urlencode ( $ sender ) ; try { $ r = $ this -> get ( 'sms/' . $ domain . '/senders/' . $ sender ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new SmsException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
9469	private function registerLogViewerRoutes ( ) { $ this -> prefix ( 'log-viewer' ) -> name ( 'log-viewer.' ) -> group ( function ( ) { $ this -> get ( '/' , 'LogViewerController@index' ) -> name ( 'index' ) ; $ this -> prefix ( 'logs' ) -> name ( 'logs.' ) -> group ( function ( ) { $ this -> get ( '/' , 'LogViewerController@listLogs' ) -> name ( 'list' ) ; $ this -> prefix ( '{logviewer_log_date}' ) -> group ( function ( ) { $ this -> get ( '/' , 'LogViewerController@show' ) -> name ( 'show' ) ; $ this -> get ( 'download' , 'LogViewerController@download' ) -> name ( 'download' ) ; $ this -> get ( '{level}' , 'LogViewerController@showByLevel' ) -> name ( 'filter' ) ; $ this -> get ( '{level}/search' , 'LogViewerController@search' ) -> name ( 'search' ) ; $ this -> delete ( 'delete' , 'LogViewerController@delete' ) -> middleware ( 'ajax' ) -> name ( 'delete' ) ; } ) ; } ) ; } ) ; }
1903	public function limit ( $ intRows , $ intOffset = 0 ) { if ( $ intRows <= 0 ) { $ intRows = 30 ; } if ( $ intOffset < 0 ) { $ intOffset = 0 ; } if ( strncasecmp ( $ this -> strQuery , 'SELECT' , 6 ) === 0 ) { $ this -> strQuery .= ' LIMIT ' . $ intOffset . ',' . $ intRows ; } else { $ this -> strQuery .= ' LIMIT ' . $ intRows ; } return $ this ; }
12974	protected function autoLoadMappingInfo ( ) { $ mappings = array ( ) ; foreach ( \ Package :: loaded ( ) as $ package => $ path ) { $ mappings [ ] = $ package . '::package' ; } foreach ( \ Module :: loaded ( ) as $ module => $ path ) { $ mappings [ ] = $ module . '::module' ; } $ mappings [ ] = 'app' ; $ mappings = array_fill_keys ( $ mappings , array ( 'is_component' => true ) ) ; $ this -> setMappings ( $ mappings ) ; }
8572	private function _convertListRecommendations ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'ListRecommendations' ; if ( $ request -> isSetMarketplaceId ( ) ) { $ parameters [ 'MarketplaceId' ] = $ request -> getMarketplaceId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } if ( $ request -> isSetSellerId ( ) ) { $ parameters [ 'SellerId' ] = $ request -> getSellerId ( ) ; } if ( $ request -> isSetRecommendationCategory ( ) ) { $ parameters [ 'RecommendationCategory' ] = $ request -> getRecommendationCategory ( ) ; } if ( $ request -> isSetCategoryQueryList ( ) ) { $ parameters [ 'CategoryQueryList' ] = $ request -> getCategoryQueryList ( ) ; } return $ parameters ; }
1948	public function generate ( $ objPage ) { $ this -> redirect ( $ this -> replaceInsertTags ( $ objPage -> url , false ) , $ this -> getRedirectStatusCode ( $ objPage ) ) ; }
12804	private static function buildColumnPropertiesCache ( ) { $ class = self :: getStaticChildClass ( ) ; $ annotations = new AnnotationReader ( $ class ) ; $ properties = $ annotations -> getPropertyAnnotations ( ) ; self :: $ columnPropertiesCache [ $ class ] = [ ] ; foreach ( $ properties as $ property ) { if ( $ property === [ ] ) continue ; if ( array_key_exists ( "ColumnName" , $ property ) ) self :: $ columnPropertiesCache [ $ class ] [ $ property [ "ColumnName" ] ] [ ] = $ property [ "var" ] [ "name" ] ; else self :: $ columnPropertiesCache [ $ class ] [ $ property [ "var" ] [ "name" ] ] [ ] = $ property [ "var" ] [ "name" ] ; } }
6827	public static function isValid ( $ action , $ throw = false ) { if ( in_array ( $ action , static :: getActions ( ) , true ) ) { return true ; } if ( $ throw ) { throw new InvalidArgumentException ( "Unknown gateway action '$action'." ) ; } return false ; }
4513	public function toObject ( ) : stdClass { $ object = new stdClass ; $ object -> timestamp = $ this -> timestamp ; $ object -> collection = $ this -> collection -> toArray ( ) ; foreach ( $ object -> collection as $ alias => $ status ) { $ object -> collection [ $ alias ] = $ status -> toObject ( ) ; } return $ object ; }
1086	private function parseDocument ( ) { $ start = $ this -> lexer -> token ; $ this -> expect ( Token :: SOF ) ; $ definitions = [ ] ; do { $ definitions [ ] = $ this -> parseDefinition ( ) ; } while ( ! $ this -> skip ( Token :: EOF ) ) ; return new DocumentNode ( [ 'definitions' => new NodeList ( $ definitions ) , 'loc' => $ this -> loc ( $ start ) , ] ) ; }
5523	public function generateSubclass ( $ methods ) { if ( ! $ this -> reflection -> classOrInterfaceExists ( ) ) { return false ; } $ mock_class = "" ; if ( ! empty ( $ this -> namespace ) ) { $ mock_class .= $ this -> namespace . '\\' ; } $ mock_class .= $ this -> mock_class ; $ mock_reflection = new SimpleReflection ( $ mock_class ) ; if ( $ mock_reflection -> classExistsWithoutAutoload ( ) ) { return false ; } if ( $ this -> reflection -> isInterface ( ) || $ this -> reflection -> hasFinal ( ) ) { $ code = $ this -> createCodeForClass ( $ methods ? $ methods : array ( ) ) ; return eval ( "$code return \$code;" ) ; } else { $ code = $ this -> createCodeForSubclass ( $ methods ? $ methods : array ( ) ) ; return eval ( "$code return \$code;" ) ; } }
11732	protected function generateBlocks ( array $ blocks , $ blocksDir , $ targetDir ) { $ c = 1 ; $ generatedBlocks = array ( ) ; foreach ( $ blocks as $ block ) { $ blockName = 'block' . $ c ; $ fileName = sprintf ( '%s/%s.json' , $ blocksDir , $ blockName ) ; $ generatedBlocks [ ] = $ blockName ; $ value = $ block ; if ( is_array ( $ value ) ) { $ value = json_encode ( $ block ) ; } FilesystemTools :: writeFile ( $ fileName , $ value ) ; $ c ++ ; } $ slotDefinition = array ( 'next' => $ c , 'blocks' => $ generatedBlocks , 'revision' => 1 , ) ; FilesystemTools :: writeFile ( $ targetDir . '/slot.json' , json_encode ( $ slotDefinition ) ) ; }
11913	public function current ( ) { $ current = current ( $ this -> storage ) ; if ( $ this -> useMapEntries ) { return new MapEntry ( $ current [ 0 ] , $ current [ 1 ] ) ; } return $ current [ 1 ] ; }
774	protected function extractMessages ( $ fileName , $ translator , $ ignoreCategories = [ ] ) { $ this -> stdout ( 'Extracting messages from ' ) ; $ this -> stdout ( $ fileName , Console :: FG_CYAN ) ; $ this -> stdout ( "...\n" ) ; $ subject = file_get_contents ( $ fileName ) ; $ messages = [ ] ; $ tokens = token_get_all ( $ subject ) ; foreach ( ( array ) $ translator as $ currentTranslator ) { $ translatorTokens = token_get_all ( '<?php ' . $ currentTranslator ) ; array_shift ( $ translatorTokens ) ; $ messages = array_merge_recursive ( $ messages , $ this -> extractMessagesFromTokens ( $ tokens , $ translatorTokens , $ ignoreCategories ) ) ; } $ this -> stdout ( "\n" ) ; return $ messages ; }
1127	public function isAncestorOf ( $ other ) { return ( $ this -> getLeft ( ) < $ other -> getLeft ( ) && $ this -> getRight ( ) > $ other -> getLeft ( ) && $ this -> inSameScope ( $ other ) ) ; }
3909	public function addPathById ( $ strId ) { if ( empty ( $ strId ) ) { return $ this ; } if ( ! Validator :: isBinaryUuid ( $ strId ) ) { $ this -> pendingIds [ ] = StringUtil :: uuidToBin ( $ strId ) ; return $ this ; } $ this -> pendingIds [ ] = $ strId ; return $ this ; }
5918	protected function setSecretKey ( $ passphrase ) { $ length = strlen ( $ passphrase ) ; if ( strlen ( $ passphrase ) < 1 || strlen ( $ passphrase ) > 56 ) { throw new Ts3Exception ( "secret passphrase must contain at least one but less than 56 characters" ) ; } $ k = 0 ; $ data = 0 ; $ datal = 0 ; $ datar = 0 ; for ( $ i = 0 ; $ i < 18 ; $ i ++ ) { $ data = 0 ; for ( $ j = 4 ; $ j > 0 ; $ j -- ) { $ data = $ data << 8 | ord ( $ passphrase { $ k } ) ; $ k = ( $ k + 1 ) % $ length ; } $ this -> p [ $ i ] ^= $ data ; } for ( $ i = 0 ; $ i <= 16 ; $ i += 2 ) { $ this -> encipher ( $ datal , $ datar ) ; $ this -> p [ $ i ] = $ datal ; $ this -> p [ $ i + 1 ] = $ datar ; } foreach ( $ this -> s as $ key => $ val ) { for ( $ i = 0 ; $ i < 256 ; $ i += 2 ) { $ this -> encipher ( $ datal , $ datar ) ; $ this -> s [ $ key ] [ $ i ] = $ datal ; $ this -> s [ $ key ] [ $ i + 1 ] = $ datar ; } } }
8710	public function where ( $ column , $ operator = null , $ value = null , $ boolean = 'and' ) { if ( is_array ( $ column ) ) { return $ this -> addArrayOfWheres ( $ column , $ boolean ) ; } if ( in_array ( $ column , $ this -> model -> translatableAttributes ( ) ) ) { return $ this -> whereTranslated ( $ column , $ operator , $ value , $ boolean ) ; } return parent :: where ( $ column , $ operator , $ value , $ boolean ) ; }
4446	public function tagged ( string $ tag , int $ offset = 0 , int $ limit = 25 ) : array { $ response = json_decode ( $ this -> client -> call ( 'tag' , 'get' , $ tag , $ offset , $ limit ) , true ) ; if ( empty ( $ response [ 'jobs' ] ) ) { $ response [ 'jobs' ] = [ ] ; } return $ response [ 'jobs' ] ; }
10209	private function performRequest ( $ curlSession , $ deserializationType = null ) { $ response = curl_exec ( $ curlSession ) ; $ response = $ response ? $ response : null ; try { $ result = new MaileonAPIResult ( $ response , $ curlSession , $ this -> throwException , $ deserializationType ) ; $ this -> printDebugInformation ( $ curlSession , $ result ) ; curl_close ( $ curlSession ) ; return $ result ; } catch ( MaileonAPIException $ e ) { if ( $ this -> debug ) { $ this -> printDebugInformation ( $ curlSession , null , $ this -> throwException ? null : $ e ) ; } curl_close ( $ curlSession ) ; if ( $ this -> throwException ) { throw $ e ; } return null ; } }
8589	public function setReportScheduleList ( $ reportSchedule ) { if ( ! $ this -> _isNumericArray ( $ reportSchedule ) ) { $ reportSchedule = array ( $ reportSchedule ) ; } $ this -> fields [ 'ReportSchedule' ] [ 'FieldValue' ] = $ reportSchedule ; return $ this ; }
11241	public function rule ( $ fieldName , $ checks , $ humanName = false ) { $ checkFailures = 0 ; if ( $ humanName == false ) { $ humanName = ucfirst ( $ fieldName ) ; } $ fieldData = $ this -> getValue ( $ fieldName ) ; if ( ! is_array ( $ checks ) ) { $ checks = explode ( '|' , $ checks ) ; } foreach ( $ checks as $ check ) { $ checkName = $ check ; if ( isset ( $ this -> customChecks -> $ check ) ) { $ customCheckDef = $ this -> customChecks -> $ check ; $ customType = $ customCheckDef [ 0 ] ; $ arguments = array ( $ fieldData , $ customCheckDef [ 1 ] , $ customCheckDef [ 2 ] , $ customCheckDef [ 3 ] , $ customCheckDef [ 4 ] ) ; $ checkResult = call_user_func_array ( array ( $ this , $ customType ) , $ arguments ) ; } else { $ checkArgs = explode ( '[' , $ check , 2 ) ; if ( count ( $ checkArgs ) > 1 ) { $ check = $ checkArgs [ 0 ] ; $ checkName = $ checkArgs [ 0 ] ; $ checkArgs [ 1 ] = '[' . $ checkArgs [ 1 ] ; $ args = array ( ) ; preg_match_all ( "/\[([^\]]*)\]/" , $ checkArgs [ 1 ] , $ args ) ; $ this -> matchedArg = $ args [ 1 ] [ 0 ] ; $ check = '_' . $ checkName ; $ checkResult = $ this -> $ check ( $ fieldData , $ args [ 1 ] ) ; } else { $ check = '_' . $ checkName ; $ checkResult = $ this -> $ check ( $ fieldData ) ; } } if ( $ checkResult == false ) { $ this -> errors [ ] = sprintf ( $ this -> lang -> $ checkName , $ humanName , $ this -> matchedArg ) ; $ this -> matchedArg = false ; $ checkFailures ++ ; } } return $ checkFailures == 0 ? true : false ; }
4329	public static function requestId ( ) { return \ hash ( 'crc32b' , ( isset ( $ _SERVER [ 'REMOTE_ADDR' ] ) ? $ _SERVER [ 'REMOTE_ADDR' ] : 'terminal' ) . ( isset ( $ _SERVER [ 'REQUEST_TIME_FLOAT' ] ) ? $ _SERVER [ 'REQUEST_TIME_FLOAT' ] : $ _SERVER [ 'REQUEST_TIME' ] ) . ( isset ( $ _SERVER [ 'REMOTE_PORT' ] ) ? $ _SERVER [ 'REMOTE_PORT' ] : '' ) ) ; }
4742	public function isReviewOptInValidationRequired ( ) { return ( bool ) \ OxidEsales \ Eshop \ Core \ Registry :: getConfig ( ) -> getConfigParam ( self :: REVIEW_OPTIN_PARAM ) ; }
11848	private function checkReadOnly ( ) { if ( true === $ this -> _readOnly ) { $ this -> _pushError ( '' , self :: ERR_READ_ONLY , 'This row has been marked read-only' ) ; return false ; } return true ; }
786	public function scenarios ( ) { $ scenarios = [ self :: SCENARIO_DEFAULT => [ ] ] ; foreach ( $ this -> getValidators ( ) as $ validator ) { foreach ( $ validator -> on as $ scenario ) { $ scenarios [ $ scenario ] = [ ] ; } foreach ( $ validator -> except as $ scenario ) { $ scenarios [ $ scenario ] = [ ] ; } } $ names = array_keys ( $ scenarios ) ; foreach ( $ this -> getValidators ( ) as $ validator ) { if ( empty ( $ validator -> on ) && empty ( $ validator -> except ) ) { foreach ( $ names as $ name ) { foreach ( $ validator -> attributes as $ attribute ) { $ scenarios [ $ name ] [ $ attribute ] = true ; } } } elseif ( empty ( $ validator -> on ) ) { foreach ( $ names as $ name ) { if ( ! in_array ( $ name , $ validator -> except , true ) ) { foreach ( $ validator -> attributes as $ attribute ) { $ scenarios [ $ name ] [ $ attribute ] = true ; } } } } else { foreach ( $ validator -> on as $ name ) { foreach ( $ validator -> attributes as $ attribute ) { $ scenarios [ $ name ] [ $ attribute ] = true ; } } } } foreach ( $ scenarios as $ scenario => $ attributes ) { if ( ! empty ( $ attributes ) ) { $ scenarios [ $ scenario ] = array_keys ( $ attributes ) ; } } return $ scenarios ; }
6332	public function createResponse ( $ status , $ errorCode , $ errorDescription ) { $ document = new \ DOMDocument ( '1.0' , 'utf-8' ) ; $ document -> formatOutput = false ; $ response = $ document -> appendChild ( $ document -> createElement ( 'SVSPurchaseStatusNotificationResponse' ) ) ; $ result = $ response -> appendChild ( $ document -> createElement ( 'TransactionResult' ) ) ; $ result -> appendChild ( $ document -> createElement ( 'Description' , $ errorDescription ) ) ; $ result -> appendChild ( $ document -> createElement ( 'Code' , $ errorCode ) ) ; $ response -> appendChild ( $ document -> createElement ( 'Status' , $ status ) ) ; $ authentication = $ response -> appendChild ( $ document -> createElement ( 'Authentication' ) ) ; $ checksum = $ authentication -> appendChild ( $ document -> createElement ( 'Checksum' , $ this -> getMerchantPassword ( ) ) ) ; $ checksum -> nodeValue = $ this -> calculateXmlChecksum ( $ document -> saveXML ( ) ) ; return $ document -> saveXML ( ) ; }
4004	public function getMetaModelNameFromId ( GetMetaModelNameFromIdEvent $ event ) { $ metaModelId = $ event -> getMetaModelId ( ) ; if ( array_key_exists ( $ metaModelId , $ this -> instancesById ) ) { $ event -> setMetaModelName ( $ this -> instancesById [ $ metaModelId ] -> getTableName ( ) ) ; return ; } if ( isset ( $ this -> tableNames [ $ metaModelId ] ) ) { $ event -> setMetaModelName ( $ this -> tableNames [ $ metaModelId ] ) ; return ; } if ( ! $ this -> tableNamesCollected ) { $ table = $ this -> database -> createQueryBuilder ( ) -> select ( '*' ) -> from ( 'tl_metamodel' ) -> where ( 'id=:id' ) -> setParameter ( 'id' , $ metaModelId ) -> setMaxResults ( 1 ) -> execute ( ) -> fetch ( \ PDO :: FETCH_ASSOC ) ; if ( $ table ) { $ this -> tableNames [ $ metaModelId ] = $ table [ 'tableName' ] ; $ event -> setMetaModelName ( $ this -> tableNames [ $ metaModelId ] ) ; } } }
903	public function isLambda ( $ index ) { if ( ! $ this -> tokens [ $ index ] -> isGivenKind ( T_FUNCTION ) ) { throw new \ LogicException ( sprintf ( 'No T_FUNCTION at given index %d, got %s.' , $ index , $ this -> tokens [ $ index ] -> getName ( ) ) ) ; } $ startParenthesisIndex = $ this -> tokens -> getNextMeaningfulToken ( $ index ) ; $ startParenthesisToken = $ this -> tokens [ $ startParenthesisIndex ] ; if ( $ startParenthesisToken -> isGivenKind ( CT :: T_RETURN_REF ) ) { $ startParenthesisIndex = $ this -> tokens -> getNextMeaningfulToken ( $ startParenthesisIndex ) ; $ startParenthesisToken = $ this -> tokens [ $ startParenthesisIndex ] ; } return $ startParenthesisToken -> equals ( '(' ) ; }
5274	public function groupBy ( $ columns ) { if ( is_string ( $ columns ) ) { $ columns = $ this -> argument_to_array ( $ columns ) ; } $ this -> statements [ 'groups' ] = $ this -> statements [ 'groups' ] + $ columns ; return $ this ; }
12238	public function innerHTML ( ) { $ dom = dom_import_simplexml ( $ this ) ; $ doc = $ dom -> ownerDocument ; $ html = '' ; foreach ( $ dom -> childNodes as $ child ) { $ html .= ( $ child instanceof DOMText ) ? $ child -> textContent : $ doc -> saveXML ( $ child ) ; } return $ html ; }
5675	protected function describeObjectDifference ( $ first , $ second , $ identical ) { if ( ! is_object ( $ second ) ) { return $ this -> describeGenericDifference ( $ first , $ second ) ; } return $ this -> describeArrayDifference ( $ this -> getMembers ( $ first ) , $ this -> getMembers ( $ second ) , $ identical ) ; }
11960	public function reduce ( Closure $ fn , $ initial = null ) { return array_reduce ( $ this -> elements , $ fn , $ initial ) ; }
10022	public function removeCellStyleXfByIndex ( $ pIndex ) { if ( $ pIndex > count ( $ this -> cellStyleXfCollection ) - 1 ) { throw new Exception ( 'CellStyleXf index is out of bounds.' ) ; } array_splice ( $ this -> cellStyleXfCollection , $ pIndex , 1 ) ; }
8475	public function debug ( $ scope , $ message , $ context = [ ] , $ config = [ ] ) { return $ this -> write ( 'debug' , $ scope , $ message , $ context , $ config ) ; }
12149	public function getReservedCodes ( ) { $ reserved = [ ] ; foreach ( $ this -> factories as $ factoryClass => $ factory ) { $ reserved [ $ factoryClass ] = $ factory -> getReservedDiapason ( ) ; } return $ reserved ; }
5191	private function handleString ( $ str ) : string { return is_string ( $ str ) && strlen ( $ str ) > 0 && $ str !== null ? $ str : '' ; }
12078	public function childAssociate ( $ request , $ idParent , $ idChild , $ relation ) { $ request -> request -> merge ( [ 'url' => $ request -> request -> path ( ) ] ) ; $ idParent = $ this -> getRealId ( $ idParent ) ; $ idChild = $ this -> getRealId ( $ idChild ) ; $ resourceChild = $ this -> repository -> attach ( $ idParent , $ idChild , $ relation , $ request -> all ( ) ) ; if ( ! $ resourceChild ) { } return $ this -> success ( [ $ resourceChild ] ) ; }
9073	protected function getRoutes ( ) { return collect ( $ this -> routes ) -> map ( function ( $ route ) { return $ this -> getRouteInformation ( $ route ) ; } ) -> reject ( function ( $ item ) { return is_null ( $ item ) ; } ) -> sortBy ( 'name' ) -> pluck ( 'name' ) ; }
2512	public function setStatus ( $ newStatus ) { if ( $ this -> isWorseStatus ( $ newStatus , $ this -> status ) ) { $ this -> status = $ newStatus ; } }
6850	public static function years ( $ start = false , $ end = false ) { $ start = ( $ start === false ) ? ( date ( 'Y' ) - 5 ) : ( int ) $ start ; $ end = ( $ end === false ) ? ( date ( 'Y' ) + 5 ) : ( int ) $ end ; $ years = array ( ) ; for ( $ i = $ start ; $ i <= $ end ; $ i ++ ) { $ years [ $ i ] = ( string ) $ i ; } return $ years ; }
357	function checkPhpExtensionVersion ( $ extensionName , $ version , $ compare = '>=' ) { if ( ! extension_loaded ( $ extensionName ) ) { return false ; } $ extensionVersion = phpversion ( $ extensionName ) ; if ( empty ( $ extensionVersion ) ) { return false ; } if ( strncasecmp ( $ extensionVersion , 'PECL-' , 5 ) === 0 ) { $ extensionVersion = substr ( $ extensionVersion , 5 ) ; } return version_compare ( $ extensionVersion , $ version , $ compare ) ; }
3153	public function storeTraceVariable ( RunnerServiceContext $ context , $ itemUri , $ variableIdentifier , $ variableValue ) { $ this -> assertQtiRunnerServiceContext ( $ context ) ; $ metaVariable = $ this -> getTraceVariable ( $ variableIdentifier , $ variableValue ) ; return $ this -> storeVariable ( $ context , $ itemUri , $ metaVariable ) ; }
7390	private function set404 ( ) { $ this -> response -> setStatusCode ( 404 ) ; $ content = '404 Not Found' ; if ( file_exists ( $ this -> packageRoot . '/view/404.html.php' ) ) { $ content = ( new Native ( $ this -> packageRoot ) ) -> getContent ( '404.html.php' ) ; } $ this -> response -> setContent ( $ content ) ; }
9650	public function delete ( ) { $ options = $ this -> Options ( ) ; if ( $ options ) { foreach ( $ options as $ option ) { $ option -> delete ( ) ; } } parent :: delete ( ) ; }
4709	public function initialize ( Text $ text ) { $ text -> replaceString ( "\r\n" , "\n" ) ; $ text -> replaceString ( "\r" , "\n" ) ; $ text -> append ( "\n\n" ) ; $ this -> markdown -> emit ( 'detab' , array ( $ text ) ) ; $ text -> replace ( '/^[ \t]+$/m' , '' ) ; }
3846	protected static function changeSubPalettesToConditions ( ) { $ objDB = self :: DB ( ) ; if ( ! $ objDB -> tableExists ( 'tl_metamodel_dcasetting_condition' ) ) { $ objDB -> execute ( 'CREATE TABLE `tl_metamodel_dcasetting_condition` ( `id` int(10) unsigned NOT NULL auto_increment, `pid` int(10) unsigned NOT NULL default \'0\', `settingId` int(10) unsigned NOT NULL default \'0\', `sorting` int(10) unsigned NOT NULL default \'0\', `tstamp` int(10) unsigned NOT NULL default \'0\', `enabled` char(1) NOT NULL default \'\', `type` varchar(255) NOT NULL default \'\', `attr_id` int(10) unsigned NOT NULL default \'0\', `comment` varchar(255) NOT NULL default \'\', `value` blob NULL, PRIMARY KEY (`id`) )ENGINE=MyISAM DEFAULT CHARSET=utf8;' ) ; } if ( $ objDB -> tableExists ( 'tl_metamodel_dcasetting' , null , true ) && $ objDB -> fieldExists ( 'subpalette' , 'tl_metamodel_dcasetting' , true ) ) { $ subpalettes = $ objDB -> execute ( 'SELECT * FROM tl_metamodel_dcasetting WHERE subpalette!=0' ) ; if ( $ subpalettes -> numRows ) { $ attributes = $ objDB -> execute ( ' SELECT attr_id, colName FROM tl_metamodel_dcasetting AS setting LEFT JOIN tl_metamodel_attribute AS attribute ON (setting.attr_id=attribute.id) WHERE dcatype=\'attribute\' ' ) ; $ attr = array ( ) ; while ( $ attributes -> next ( ) ) { $ attr [ $ attributes -> attr_id ] = $ attributes -> colName ; } $ checkboxes = $ objDB -> execute ( ' SELECT * FROM tl_metamodel_dcasetting WHERE subpalette=0 AND dcatype=\'attribute\' ' ) ; $ check = array ( ) ; while ( $ checkboxes -> next ( ) ) { $ check [ $ checkboxes -> id ] = $ checkboxes -> attr_id ; } while ( $ subpalettes -> next ( ) ) { $ data = array ( 'pid' => 0 , 'settingId' => $ subpalettes -> id , 'sorting' => '128' , 'tstamp' => time ( ) , 'enabled' => '1' , 'type' => 'conditionpropertyvalueis' , 'attr_id' => $ check [ $ subpalettes -> subpalette ] , 'comment' => sprintf ( 'Only show when checkbox "%s" is checked' , $ attr [ $ check [ $ subpalettes -> subpalette ] ] ) , 'value' => '1' , ) ; $ objDB -> prepare ( 'INSERT INTO tl_metamodel_dcasetting_condition %s' ) -> set ( $ data ) -> execute ( ) ; $ objDB -> prepare ( 'UPDATE tl_metamodel_dcasetting SET subpalette=0 WHERE id=?' ) -> execute ( $ subpalettes -> id ) ; $ objDB -> prepare ( 'UPDATE tl_metamodel_dcasetting SET submitOnChange=1 WHERE id=?' ) -> execute ( $ subpalettes -> subpalette ) ; } } TableManipulation :: dropColumn ( 'tl_metamodel_dcasetting' , 'subpalette' , true ) ; } }
11569	public static function search ( $ query , & $ results = array ( ) ) { $ attachments = static :: getInstance ( ) ; if ( ! empty ( $ query ) ) : $ words = explode ( ' ' , $ query ) ; foreach ( $ words as $ word ) { $ _results = $ attachments -> setListLookUpConditions ( "attachment_name" , $ word , 'OR' ) -> setListLookUpConditions ( "attachment_title" , $ word , 'OR' ) -> setListLookUpConditions ( "attachment_description" , $ word , 'OR' ) -> setListLookUpConditions ( "attachment_tags" , $ word , 'OR' ) ; } $ _results = $ attachments -> setListLookUpConditions ( "attachment_owner" , array ( $ attachments -> user -> get ( "user_name_id" ) ) , "AND" , true ) -> setListOrderBy ( "o.object_created_on" , "DESC" ) -> getObjectsList ( "attachment" ) ; $ rows = $ _results -> fetchAll ( ) ; $ browsable = array ( "image/jpg" , "image/jpeg" , "image/png" , "image/gif" ) ; $ documents = array ( "filterid" => "attachments" , "title" => "Documents" , "results" => array ( ) ) ; foreach ( $ rows as $ attachment ) { $ document = array ( "title" => $ attachment [ 'attachment_title' ] , "description" => "" , "type" => $ attachment [ 'object_type' ] , "object_uri" => $ attachment [ 'object_uri' ] ) ; if ( in_array ( $ attachment [ 'attachment_type' ] , $ browsable ) ) : $ document [ 'icon' ] = "/system/object/{$attachment['object_uri']}/resize/170/170" ; $ document [ 'link' ] = "/system/media/photo/view/{$attachment['object_uri']}" ; else : $ document [ 'media_uri' ] = $ attachment [ 'object_uri' ] ; $ document [ 'link' ] = "/system/object/{$attachment['object_uri']}" ; endif ; $ documents [ "results" ] [ ] = $ document ; } if ( ! empty ( $ documents [ "results" ] ) ) $ results [ ] = $ documents ; endif ; return true ; }
11724	protected function prepare ( $ path , Zend_Http_Client $ client ) { $ client -> setUri ( $ this -> uri . '/' . $ path ) ; $ client -> resetParameters ( ) ; }
5680	public function getText ( ) { if ( ! $ this -> text ) { $ this -> text = self :: normalise ( $ this -> raw ) ; } return $ this -> text ; }
4137	protected function processHeaders ( $ headers ) { $ out = array ( ) ; $ headers = explode ( "\r\n" , trim ( $ headers ) ) ; foreach ( $ headers as $ header ) { if ( strpos ( $ header , ':' ) !== false ) { $ tmp = explode ( ':' , $ header ) ; $ out [ reset ( $ tmp ) ] = end ( $ tmp ) ; } else { if ( ! isset ( $ out [ 'http-code' ] ) ) { $ out [ 'http-code' ] = $ header ; } } } unset ( $ headers , $ header , $ tmp ) ; return $ out ; }
356	public function init ( ) { parent :: init ( ) ; if ( $ this -> enableCoreCommands ) { foreach ( $ this -> coreCommands ( ) as $ id => $ command ) { if ( ! isset ( $ this -> controllerMap [ $ id ] ) ) { $ this -> controllerMap [ $ id ] = $ command ; } } } if ( ! isset ( $ this -> controllerMap [ 'help' ] ) ) { $ this -> controllerMap [ 'help' ] = 'yii\console\controllers\HelpController' ; } }
6842	public function produce ( $ key , $ params = array ( ) , $ enable_reflect = true ) { if ( isset ( $ this -> data [ $ key ] ) ) return $ this -> data [ $ key ] ; if ( isset ( $ this -> caches [ $ key ] ) ) return $ this -> caches [ $ key ] ; if ( isset ( $ this -> objects [ $ key ] ) ) { $ obj = $ this -> get ( $ key ) ; $ concrete = $ obj [ self :: INDEX_CONCRETE ] ; } else { if ( $ this -> MUST_REG || ! $ enable_reflect ) { throw new InjectorException ( "$key not registered" ) ; } else { $ concrete = $ key ; $ not_reg = true ; } } $ result = $ this -> build ( $ concrete , $ params ) ; if ( $ not_reg === true || $ obj [ self :: INDEX_CACHED ] === true ) { $ this -> caches [ $ key ] = $ result ; } return $ result ; }
1557	protected function defaultOrder ( $ query ) { if ( $ this -> doesRequireOrdering ( $ query ) ) { $ query -> orderBy ( $ this -> primaryKey ) ; } return $ this ; }
4512	public function kernelView ( GetResponseForControllerResultEvent $ event ) { $ request = $ event -> getRequest ( ) ; if ( ! $ request -> query -> has ( 'locale' ) ) { return ; } $ controllerResult = $ event -> getControllerResult ( ) ; $ locale = $ request -> query -> get ( 'locale' ) ; if ( $ controllerResult instanceof Paginator || is_array ( $ controllerResult ) ) { foreach ( $ controllerResult as $ model ) { if ( $ model instanceof Localizable ) { $ this -> localeService -> localize ( $ model , $ locale ) ; } } } elseif ( $ controllerResult instanceof Localizable ) { $ this -> localeService -> localize ( $ controllerResult , $ locale ) ; } $ event -> setControllerResult ( $ controllerResult ) ; }
6290	public function get ( $ theme = null ) { if ( is_null ( $ theme ) ) { return $ this -> themes [ $ this -> activeTheme ] ; } return $ this -> themes [ $ theme ] ; }
4075	protected function setTableMapping ( $ modelId , $ tableName ) { $ this -> information [ $ tableName ] [ self :: MODELID ] = $ modelId ; $ this -> tableMap [ $ modelId ] = $ tableName ; }
10709	public function getManyPaginated ( $ perPage = null , $ columns = [ '*' ] ) { $ query = $ this -> getQuery ( ) ; $ results = $ query -> paginate ( $ perPage , $ columns ) ; return $ this -> returnResults ( $ results ) ; }
7904	protected function renderSides ( $ sides ) { $ lines = [ ] ; $ lines [ ] = Html :: beginTag ( 'div' , $ this -> sidesOptions ) ; foreach ( $ sides as $ side ) { if ( ! array_key_exists ( 'content' , $ side ) ) { throw new InvalidConfigException ( "The 'content' option is required per sides" ) ; } $ options = ArrayHelper :: getValue ( $ side , 'options' , [ ] ) ; Ui :: addCssClass ( $ options , 'side' ) ; $ active = ArrayHelper :: getValue ( $ side , 'active' , false ) ; if ( $ active === true ) { Ui :: addCssClass ( $ options , 'active' ) ; } $ lines [ ] = Html :: tag ( 'div' , $ side [ 'content' ] , $ options ) ; } $ lines [ ] = Html :: endTag ( 'div' ) ; return implode ( "\n" , $ lines ) ; }
955	public function retrieve ( ) { $ path = null ; switch ( $ this -> type ) { case self :: CHARGE_CREDIT : $ path = 'application_credits' ; break ; case self :: CHARGE_ONETIME : $ path = 'application_charges' ; break ; default : $ path = 'recurring_application_charges' ; break ; } return $ this -> shop -> api ( ) -> rest ( 'GET' , "/admin/{$path}/{$this->charge_id}.json" ) -> body -> { substr ( $ path , 0 , - 1 ) } ; }
4278	public function stream_read ( $ count ) { if ( ! $ this -> handle ) { return false ; } self :: restorePrev ( ) ; $ buffer = \ fread ( $ this -> handle , $ count ) ; $ bufferLen = \ strlen ( $ buffer ) ; $ backtrace = \ debug_backtrace ( DEBUG_BACKTRACE_IGNORE_ARGS , 2 ) ; $ isRequire = ! \ in_array ( $ backtrace [ 1 ] [ 'function' ] , array ( 'file_get_contents' ) ) ; if ( ! $ this -> declaredTicks && $ isRequire ) { foreach ( self :: $ pathsExclude as $ excludePath ) { if ( \ strpos ( $ this -> filepath , $ excludePath . DIRECTORY_SEPARATOR ) === 0 ) { $ this -> declaredTicks = true ; } } } if ( ! $ this -> declaredTicks && $ isRequire ) { $ buffer = \ preg_replace ( '/^(<\?php\s*)$/m' , '$0 declare(ticks=1);' , $ buffer , 1 ) ; $ this -> declaredTicks = true ; self :: $ filesModified [ ] = $ this -> filepath ; } $ buffer = $ this -> bufferPrepend . $ buffer ; $ bufferLenAfter = \ strlen ( $ buffer ) ; $ diff = $ bufferLenAfter - $ bufferLen ; $ this -> bufferPrepend = '' ; if ( $ diff ) { $ this -> bufferPrepend = \ substr ( $ buffer , $ count ) ; $ buffer = \ substr ( $ buffer , 0 , $ count ) ; } self :: register ( ) ; return $ buffer ; }
11735	private function updateOv ( $ dwnl ) { $ entity = new EBonDwnl ( ) ; foreach ( $ dwnl as $ one ) { $ ov = $ one -> getOv ( ) ; $ calcId = $ one -> getCalculationRef ( ) ; $ custId = $ one -> getCustomerRef ( ) ; $ entity -> setOv ( $ ov ) ; $ id = [ EBonDwnl :: A_CALC_REF => $ calcId , EBonDwnl :: A_CUST_REF => $ custId ] ; $ this -> daoBonDwnl -> updateById ( $ id , $ entity ) ; } }
9984	function fromXML ( $ xmlElement ) { if ( isset ( $ xmlElement -> id ) ) $ this -> id = $ xmlElement -> id ; if ( isset ( $ xmlElement -> name ) ) $ this -> name = $ xmlElement -> name ; if ( isset ( $ xmlElement -> entries ) ) { $ this -> entries = array ( ) ; foreach ( $ xmlElement -> entries -> children ( ) as $ entry ) { $ this -> entries [ ] = $ entry ; } } }
1544	public function encodes ( string ... $ mediaTypes ) : bool { $ encoding = $ this -> getEncodingMediaType ( ) ; return collect ( $ mediaTypes ) -> contains ( function ( $ mediaType , $ index ) use ( $ encoding ) { return $ encoding -> equalsTo ( MediaType :: parse ( $ index , $ mediaType ) ) ; } ) ; }
1237	private function set ( $ class , $ name , $ value ) { self :: ensurePropertyExists ( $ class , $ name ) ; self :: ensurePropertyType ( $ class , $ name , $ value ) ; $ this -> setValue ( $ class , $ name , $ value ) ; }
2493	protected function getRange ( $ operator , $ start , $ end ) { $ startBrace = '[' ; $ startValue = '*' ; $ endValue = '*' ; $ endBrace = ']' ; $ start = '"' . $ this -> escapeQuote ( $ this -> toString ( $ start ) , true ) . '"' ; $ end = '"' . $ this -> escapeQuote ( $ this -> toString ( $ end ) , true ) . '"' ; switch ( $ operator ) { case Operator :: GT : $ startBrace = '{' ; $ endBrace = '}' ; case Operator :: GTE : $ startValue = $ start ; break ; case Operator :: LT : $ startBrace = '{' ; $ endBrace = '}' ; case Operator :: LTE : $ endValue = $ end ; break ; case Operator :: BETWEEN : $ startValue = $ start ; $ endValue = $ end ; break ; default : throw new \ RuntimeException ( "Unknown operator: $operator" ) ; } return "$startBrace$startValue TO $endValue$endBrace" ; }
7270	public function save ( $ create = false ) { $ tableName = static :: tableName ( ) ; $ columns = static :: tableColumns ( ) ; $ idColumn = static :: $ idColumn ; $ isModel = false ; $ into = "" ; $ values = "" ; $ updates = "" ; $ condition = "" ; $ params = [ ] ; $ primaries = [ ] ; $ updateCondition = "" ; foreach ( $ columns as $ i => $ column ) { $ name = $ column [ "column_name" ] ; $ key = $ column [ "column_key" ] ; if ( property_exists ( $ this , $ name ) && ! in_array ( $ name , static :: $ autos ) ) { $ into .= "$name, " ; $ values .= ":$name, " ; $ updates .= "$name = :$name, " ; $ condition .= "$name = :$name and " ; $ params [ $ name ] = $ this -> encodeValue ( $ name ) ; } if ( strcasecmp ( $ key , "PRI" ) === 0 ) { $ updateCondition .= "$name = :$name and " ; if ( property_exists ( $ this , $ name ) && ! in_array ( $ name , static :: $ autos ) ) $ primaries [ $ name ] = $ this -> encodeValue ( $ name ) ; if ( $ name === $ idColumn ) $ isModel = true ; } } $ into = substr ( $ into , 0 , - 2 ) ; $ values = substr ( $ values , 0 , - 2 ) ; $ updates = substr ( $ updates , 0 , - 2 ) ; $ condition = substr ( $ condition , 0 , - 5 ) ; $ updateCondition = substr ( $ updateCondition , 0 , - 5 ) ; try { $ status = Db :: query ( " insert into $tableName ($into) values ($values) " , $ params , static :: getDbName ( ) , false ) !== false ; } catch ( PDOException $ e ) { if ( $ create ) throw $ e ; if ( $ e -> getCode ( ) === "23000" && preg_match ( "/.*'PRIMARY'$/" , $ e -> getMessage ( ) ) ) { $ status = Db :: query ( " update $tableName set $updates where $updateCondition " , $ params , static :: getDbName ( ) , false ) !== false ; } else throw $ e ; } if ( $ status ) { $ lastInsertId = Db :: instance ( static :: getDbName ( ) ) -> lastInsertId ( ) ; if ( $ lastInsertId > 0 ) return static :: find ( $ lastInsertId ) ; else return static :: select ( "where $updateCondition" , $ primaries , static :: getDbName ( ) ) -> first ( ) ; } else return false ; }
1138	public function destroyDescendants ( ) { if ( is_null ( $ this -> getRight ( ) ) || is_null ( $ this -> getLeft ( ) ) ) return ; $ self = $ this ; $ this -> getConnection ( ) -> transaction ( function ( ) use ( $ self ) { $ self -> reload ( ) ; $ lftCol = $ self -> getLeftColumnName ( ) ; $ rgtCol = $ self -> getRightColumnName ( ) ; $ lft = $ self -> getLeft ( ) ; $ rgt = $ self -> getRight ( ) ; $ self -> newNestedSetQuery ( ) -> where ( $ lftCol , '>=' , $ lft ) -> select ( $ self -> getKeyName ( ) ) -> lockForUpdate ( ) -> get ( ) ; $ self -> newNestedSetQuery ( ) -> where ( $ lftCol , '>' , $ lft ) -> where ( $ rgtCol , '<' , $ rgt ) -> delete ( ) ; $ diff = $ rgt - $ lft + 1 ; $ self -> newNestedSetQuery ( ) -> where ( $ lftCol , '>' , $ rgt ) -> decrement ( $ lftCol , $ diff ) ; $ self -> newNestedSetQuery ( ) -> where ( $ rgtCol , '>' , $ rgt ) -> decrement ( $ rgtCol , $ diff ) ; } ) ; }
3818	private function generateForm ( $ table , $ metaModel , Request $ request ) { $ fields = [ ] ; foreach ( $ metaModel -> getAttributes ( ) as $ attribute ) { $ attrId = $ attribute -> get ( 'id' ) ; if ( ! $ this -> accepts ( $ attribute ) ) { continue ; } if ( $ this -> knowsAttribute ( $ attribute ) ) { $ fields [ ] = [ 'checkbox' => false , 'text' => $ this -> checkboxCaption ( 'addAll_alreadycontained' , $ table , $ attribute ) , 'class' => 'tl_info' , 'attr_id' => $ attrId , 'name' => 'attribute_' . $ attrId ] ; continue ; } elseif ( $ this -> isAttributeSubmitted ( $ attrId , $ request ) ) { $ fields [ ] = array ( 'checkbox' => false , 'text' => $ this -> checkboxCaption ( 'addAll_addsuccess' , $ table , $ attribute ) , 'class' => 'tl_confirm' , 'attr_id' => $ attrId , 'name' => 'attribute_' . $ attrId ) ; continue ; } $ fields [ ] = [ 'checkbox' => true , 'text' => $ this -> checkboxCaption ( 'addAll_willadd' , $ table , $ attribute ) , 'class' => 'tl_new' , 'attr_id' => $ attrId , 'name' => 'attribute_' . $ attrId ] ; } return $ fields ; }
1390	protected function resourceDoesNotExist ( string $ path ) : void { $ this -> errors -> add ( $ this -> translator -> resourceDoesNotExist ( $ path ) ) ; }
532	protected function resortChangelog ( $ changelog ) { foreach ( $ changelog as $ i => $ line ) { $ changelog [ $ i ] = rtrim ( $ line ) ; } $ changelog = array_filter ( $ changelog ) ; $ i = 0 ; ArrayHelper :: multisort ( $ changelog , function ( $ line ) use ( & $ i ) { if ( preg_match ( '/^- (Chg|Enh|Bug|New)( #\d+(, #\d+)*)?: .+/' , $ line , $ m ) ) { $ o = [ 'Bug' => 'C' , 'Enh' => 'D' , 'Chg' => 'E' , 'New' => 'F' ] ; return $ o [ $ m [ 1 ] ] . ' ' . ( ! empty ( $ m [ 2 ] ) ? $ m [ 2 ] : 'AAAA' . $ i ++ ) ; } return 'B' . $ i ++ ; } , SORT_ASC , SORT_NATURAL ) ; array_unshift ( $ changelog , '' ) ; $ changelog [ ] = '' ; $ changelog [ ] = '' ; return $ changelog ; }
4458	public function fire ( AbstractUserEvent $ event ) { $ status = null ; $ type = $ event :: getEntityName ( ) ; if ( isset ( $ this -> events [ $ type ] ) ) { $ queue = $ this -> events [ $ type ] ; $ status = $ this -> fireQueue ( $ queue , $ event ) ; } $ eventName = $ event -> getName ( ) ; if ( isset ( $ this -> events [ $ eventName ] ) ) { $ queue = $ this -> events [ $ eventName ] ; $ status = $ this -> fireQueue ( $ queue , $ event ) ; } return $ status ; }
11377	public function getAction ( ) { if ( ! preg_match ( '/\/page\/(\w+[\-\w]*)\/text\/(..)(\/(\w+))?$/' , $ this -> name , $ matches ) ) { throw new InvalidParameterException ( "Invalid parameters" ) ; } $ pageName = $ matches [ 1 ] ; $ language = $ matches [ 2 ] ; $ pageTexts = $ this -> getTextModel ( $ pageName ) ; if ( empty ( $ matches [ 4 ] ) ) { $ result = array_values ( $ pageTexts -> getTextsWithBaseTexts ( $ language ) ) ; } else { $ result = $ pageTexts -> getText ( $ matches [ 4 ] , $ language ) ; } $ this -> environment -> sendJSONResult ( $ result ) ; }
3318	public function renderReadableSpec ( $ renderHint = true ) { $ c1 = '' ; if ( $ this -> short && $ this -> long ) { $ c1 = sprintf ( '-%s, --%s' , $ this -> short , $ this -> long ) ; } else if ( $ this -> short ) { $ c1 = sprintf ( '-%s' , $ this -> short ) ; } else if ( $ this -> long ) { $ c1 = sprintf ( '--%s' , $ this -> long ) ; } if ( $ renderHint ) { return $ c1 . $ this -> renderValueHint ( ) ; } return $ c1 ; }
4859	public function getNeighbours ( $ namespace , $ callback , $ id ) { $ list = $ this -> getList ( $ namespace , $ callback ) ; $ list -> setCurrent ( $ id ) ; return [ $ list -> getPrevious ( ) , $ list -> getNext ( ) ] ; }
358	function compareByteSize ( $ a , $ b , $ compare = '>=' ) { $ compareExpression = '(' . $ this -> getByteSize ( $ a ) . $ compare . $ this -> getByteSize ( $ b ) . ')' ; return $ this -> evaluateExpression ( $ compareExpression ) ; }
9163	private function getHeader ( string $ name ) : string { $ result = "" ; if ( Arrays :: hasElement ( $ this -> headers , $ name ) ) { $ result = $ this -> headers [ $ name ] ; } return $ result ; }
7691	function OpenMXL_GarbageCollector ( ) { if ( ( count ( $ this -> IdxToCheck ) == 0 ) && ( count ( $ this -> OtbsSheetSlidesDelete ) == 0 ) ) return ; $ pic_path = $ this -> ExtInfo [ 'pic_path' ] ; $ pic_path_len = strlen ( $ pic_path ) ; $ rels_ext = '.rels' ; $ rels_ext_len = strlen ( $ rels_ext ) ; $ pictures = array ( ) ; $ rels = array ( ) ; foreach ( $ this -> CdFileLst as $ idx => $ f ) { $ n = $ f [ 'v_name' ] ; if ( substr ( $ n , 0 , $ pic_path_len ) == $ pic_path ) { $ short = basename ( $ pic_path ) . '/' . basename ( $ n ) ; $ pictures [ ] = array ( 'name' => $ n , 'idx' => $ idx , 'nbr' => 0 , 'short' => $ short ) ; } elseif ( substr ( $ n , - $ rels_ext_len ) == $ rels_ext ) { if ( $ this -> FileGetState ( $ idx ) != 'd' ) $ rels [ $ n ] = $ idx ; } } foreach ( $ rels as $ n => $ idx ) { $ txt = $ this -> TbsStoreGet ( $ idx , 'GarbageCollector' ) ; foreach ( $ pictures as $ i => $ info ) { if ( strpos ( $ txt , $ info [ 'short' ] . '"' ) !== false ) $ pictures [ $ i ] [ 'nbr' ] ++ ; } } foreach ( $ pictures as $ info ) { if ( $ info [ 'nbr' ] == 0 ) $ this -> FileReplace ( $ info [ 'idx' ] , false ) ; } }
12547	public function getBlockPlugin ( $ name ) { if ( ! array_key_exists ( $ name , $ this -> blocks ) ) { return null ; } return $ this -> blocks [ $ name ] ; }
6152	public function run ( ) { if ( ! empty ( $ this -> _fields ) ) { throw new InvalidCallException ( 'Each beginField() should have a matching endField() call.' ) ; } $ id = $ this -> options [ 'id' ] ; $ options = Json :: encode ( $ this -> getClientOptions ( ) ) ; $ attributes = Json :: encode ( $ this -> attributes ) ; $ view = $ this -> getView ( ) ; AdminUiActiveForm :: register ( $ view ) ; $ view -> registerJs ( "jQuery('#$id').yiiActiveForm($attributes, $options);" ) ; echo Html :: endForm ( ) ; }
11058	protected function _getDataStore ( ) { return $ this -> dataStore === null ? $ this -> dataStore = $ this -> _createDataStore ( ) : $ this -> dataStore ; }
6479	public function getClientIPAddress ( IHttpRequestMessage $ request ) : ? string { $ clientIPAddress = null ; $ request -> getProperties ( ) -> tryGet ( self :: CLIENT_IP_ADDRESS_PROPERTY , $ clientIPAddress ) ; return $ clientIPAddress ; }
6913	public function addShipment ( ShipmentInterface $ shipment ) { if ( ! $ this -> shipments -> contains ( $ shipment ) ) { $ this -> shipments -> add ( $ shipment ) ; } return $ this ; }
596	public function actionCheckGuide ( $ directory = null ) { if ( $ directory === null ) { $ directory = \ dirname ( \ dirname ( __DIR__ ) ) . '/docs' ; } if ( is_file ( $ directory ) ) { $ files = [ $ directory ] ; } else { $ files = FileHelper :: findFiles ( $ directory , [ 'only' => [ '*.md' ] , ] ) ; } foreach ( $ files as $ file ) { $ content = file_get_contents ( $ file ) ; $ chars = preg_split ( '//u' , $ content , null , PREG_SPLIT_NO_EMPTY ) ; $ line = 1 ; $ pos = 0 ; foreach ( $ chars as $ c ) { $ ord = $ this -> unicodeOrd ( $ c ) ; $ pos ++ ; if ( $ ord == 0x000A ) { $ line ++ ; $ pos = 0 ; } if ( $ ord === false ) { $ this -> found ( 'BROKEN UTF8' , $ c , $ line , $ pos , $ file ) ; continue ; } if ( 0x2000 <= $ ord && $ ord <= 0x200F || 0x2028 <= $ ord && $ ord <= 0x202E || 0x205f <= $ ord && $ ord <= 0x206F ) { $ this -> found ( 'UNSUPPORTED SPACE CHARACTER' , $ c , $ line , $ pos , $ file ) ; continue ; } if ( $ ord < 0x0020 && $ ord != 0x000A && $ ord != 0x0009 || 0x0080 <= $ ord && $ ord < 0x009F ) { $ this -> found ( 'CONTROL CHARARCTER' , $ c , $ line , $ pos , $ file ) ; continue ; } } } }
6275	protected function read ( $ start , $ len ) { $ end = $ start + $ len ; if ( $ end <= 2048 ) { return substr ( $ this -> index , $ start , $ len ) ; } $ bytes = '' ; if ( $ this -> buf && $ start >= $ this -> bufStart ) { $ bytes .= substr ( $ this -> buf , $ start - $ this -> bufStart , $ len ) ; $ bytesRead = strlen ( $ bytes ) ; $ len -= $ bytesRead ; $ start += $ bytesRead ; } else { $ bytesRead = 0 ; } if ( ! $ len ) { return $ bytes ; } if ( $ start !== $ this -> filePos ) { if ( fseek ( $ this -> handle , $ start ) === - 1 ) { throw new Exception ( 'Seek failed, file "' . $ this -> fileName . '" may be corrupted.' ) ; } } $ buf = fread ( $ this -> handle , max ( $ len , 1024 ) ) ; if ( $ buf === false ) { $ buf = '' ; } $ bytes .= substr ( $ buf , 0 , $ len ) ; if ( strlen ( $ bytes ) !== $ len + $ bytesRead ) { throw new Exception ( 'Read from CDB file failed, file "' . $ this -> fileName . '" may be corrupted.' ) ; } $ this -> filePos = $ end ; $ this -> bufStart = $ start ; $ this -> buf = $ buf ; return $ bytes ; }
10263	public function getCreditCard ( $ weighted = true ) { if ( $ weighted ) { $ weight [ ] = [ 'American Express' , 1 ] ; $ weight [ ] = [ 'Discover' , 2 ] ; $ weight [ ] = [ 'MasterCard' , 10 ] ; $ weight [ ] = [ 'Visa' , 10 ] ; foreach ( $ weight as $ w ) { $ type = $ w [ 0 ] ; $ count = $ w [ 1 ] ; for ( $ i = 0 ; $ i < $ count ; $ i ++ ) { $ card_types [ ] = $ type ; } } } else { $ card_types = [ 'American Express' , 'Discover' , 'MasterCard' , 'Visa' ] ; } $ cc = new Entities \ CreditCard ; $ cc -> type = $ this -> fromArray ( $ card_types ) ; $ cc -> number = $ this -> getBankNumber ( $ cc -> type ) ; $ cc -> expiration = $ this -> getExpiration ( ) ; return $ cc ; }
6196	public function isActive ( string $ url ) { if ( $ this -> makeUrl ( $ url , true ) === str_replace ( $ this -> uri , '' , $ _SERVER [ 'REQUEST_URI' ] ) ) { return true ; } return false ; }
12028	function addExecuteAsyncMethod ( ) { $ body = $ this -> generateCreateFragment ( ) ; $ body .= 'return $this->dispatchAsync($request, $callable);' ; $ docBlock = new DocBlockGenerator ( 'Execute the operation asynchronously, passing the parsed response to the callback' , null ) ; $ tags [ ] = new GenericTag ( 'return' , '\Amp\Promise' ) ; $ docBlock -> setTags ( $ tags ) ; $ callableParamGenerator = new ParameterGenerator ( 'callable' , 'callable' ) ; $ methodGenerator = new MethodGenerator ( 'executeAsync' ) ; $ methodGenerator -> setBody ( $ body ) ; $ methodGenerator -> setDocBlock ( $ docBlock ) ; $ methodGenerator -> setParameters ( [ $ callableParamGenerator ] ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; }
3975	private function getDataProviderDefinition ( IMetaModelDataDefinition $ container ) { if ( $ container -> hasDataProviderDefinition ( ) ) { return $ container -> getDataProviderDefinition ( ) ; } $ config = new DefaultDataProviderDefinition ( ) ; $ container -> setDataProviderDefinition ( $ config ) ; return $ config ; }
5630	public function getIdentity ( ) { if ( $ this -> username && $ this -> password ) { return $ this -> username . ':' . $ this -> password ; } return false ; }
3522	public static function refresh ( $ refresh_token ) { $ data = FortniteClient :: sendUnrealClientPostRequest ( FortniteClient :: EPIC_OAUTH_TOKEN_ENDPOINT , [ 'grant_type' => 'refresh_token' , 'refresh_token' => $ refresh_token , 'includePerms' => "false" , 'token_type' => 'eg1' , ] , FortniteClient :: FORTNITE_AUTHORIZATION ) ; if ( ! $ data -> access_token ) { throw new \ Exception ( $ data -> errorMessage ) ; } return new self ( $ data -> access_token , $ data -> in_app_id , $ data -> refresh_token , $ data -> account_id , $ data -> expires_in ) ; }
5002	public function removeEmptyGroups ( ) { $ tabs = $ this -> getFormTabs ( ) ; if ( ! is_array ( $ tabs ) ) { return ; } $ groups = $ this -> getFormGroups ( ) ; foreach ( $ tabs as $ tabKey => $ tab ) { foreach ( $ tab [ 'groups' ] as $ tabGroup ) { if ( ! array_key_exists ( $ tabGroup , $ groups ) ) { unset ( $ tabs [ $ tabKey ] ) ; } } } $ this -> setFormTabs ( $ tabs ) ; }
6287	private function buildReactRequest ( RequestInterface $ request ) { $ headers = [ ] ; foreach ( $ request -> getHeaders ( ) as $ name => $ value ) { $ headers [ $ name ] = ( is_array ( $ value ) ? $ value [ 0 ] : $ value ) ; } $ reactRequest = $ this -> client -> request ( $ request -> getMethod ( ) , ( string ) $ request -> getUri ( ) , $ headers , $ request -> getProtocolVersion ( ) ) ; return $ reactRequest ; }
6793	protected function getTagSortSourceColumn ( $ prefix = null ) { $ column = $ this -> get ( 'tag_srcsorting' ) ; if ( ! $ column ) { return null ; } if ( null !== $ prefix ) { return $ prefix . '.' . $ column ; } return $ column ; }
7338	public function createEvent ( Request $ request ) : Event { if ( empty ( $ request -> input ( ) ) ) { return new Unknown ( ) ; } $ update = new Update ( $ request -> input ( ) ) ; $ this -> update = $ update ; if ( $ message = $ update -> message ) { $ chat = new Chat ( ( string ) $ message -> chat -> id , $ message -> chat -> title , $ message -> chat -> type ) ; $ from = new User ( ( string ) $ message -> from -> id , $ message -> from -> first_name , $ message -> from -> username ) ; return new MessageReceived ( $ chat , $ from , $ message -> text , $ message -> location , null , optional ( $ update -> callback_query ) -> data , $ update ) ; } if ( $ callbackQuery = $ update -> callback_query ) { $ message = $ callbackQuery -> message ; $ chat = new Chat ( ( string ) $ message -> chat -> id , $ message -> chat -> title , $ message -> chat -> type ) ; $ from = new User ( ( string ) $ message -> chat -> id , $ message -> from -> first_name , $ message -> from -> username ) ; return new MessageReceived ( $ chat , $ from , $ message -> text , $ message -> location , null , $ callbackQuery -> data , $ update ) ; } return new Unknown ( ) ; }
1218	public function setConfig ( array $ configuration ) { $ this -> config = Functions \ arrayMergeDeep ( $ this -> config , $ this -> resolver -> resolveOptions ( $ configuration ) ) ; }
1999	private function getAcceptedLocales ( ) : array { $ accepted = [ ] ; $ locales = [ ] ; preg_match_all ( '/([a-z]{1,8}(-[a-z]{1,8})?)\s*(;\s*q\s*=\s*(1|0\.\d+))?/i' , $ this -> requestStack -> getCurrentRequest ( ) -> headers -> get ( 'accept-language' ) , $ accepted ) ; foreach ( $ accepted [ 1 ] as $ v ) { $ chunks = explode ( '-' , $ v ) ; if ( isset ( $ chunks [ 1 ] ) ) { $ locale = $ chunks [ 0 ] . '-' . strtoupper ( $ chunks [ 1 ] ) ; if ( preg_match ( '/^[a-z]{2}(\-[A-Z]{2})?$/' , $ locale ) ) { $ locales [ ] = $ locale ; } } if ( preg_match ( '/^[a-z]{2}$/' , $ chunks [ 0 ] ) ) { $ locales [ ] = $ chunks [ 0 ] ; } } return \ array_slice ( array_unique ( $ locales ) , 0 , 8 ) ; }
9041	public function getEnvValue ( array $ expectedEnv , array $ actualEnv ) { $ actualValue = '' ; $ isStarted = false ; foreach ( $ expectedEnv as $ key => $ defaultValue ) { if ( array_key_exists ( $ key , $ actualEnv ) ) { if ( $ this -> option ( 'force' ) ) { $ defaultValue = $ actualEnv [ $ key ] ; } else { $ actualValue .= sprintf ( "%s=%s\n" , $ key , $ actualEnv [ $ key ] ) ; continue ; } } if ( ! $ isStarted ) { $ isStarted = true ; if ( $ this -> option ( 'force' ) ) { $ this -> comment ( 'Update all parameters. Please provide them.' ) ; } else { $ this -> comment ( 'Some parameters are missing. Please provide them.' ) ; } } $ value = $ this -> ask ( $ key , $ defaultValue ) ; $ actualValue .= sprintf ( "%s=%s\n" , $ key , $ value ) ; } return $ actualValue ; }
5140	public function map ( array $ methods , string $ path , $ handler ) : void { if ( is_string ( $ handler ) ) { $ handler = $ this -> getContainer ( ) -> get ( $ handler ) ; } $ this -> router -> map ( $ methods , $ path , $ handler ) ; }
965	public function dispatchScripttags ( ) { $ scripttags = Config :: get ( 'shopify-app.scripttags' ) ; if ( count ( $ scripttags ) > 0 ) { ScripttagInstaller :: dispatch ( $ this -> shop , $ scripttags ) -> onQueue ( Config :: get ( 'shopify-app.job_queues.scripttags' ) ) ; } }
3354	public function copy ( $ target = null ) { Helper :: deprecate ( '2.0.0' , '3.0.0' , 'Use createLocalCopy() or createRemoteCopy() instead' ) ; return $ this -> api -> copyFile ( $ this -> getUrl ( ) , $ target ) ; }
1718	public function onKernelRequest ( GetResponseEvent $ event ) : void { $ token = $ this -> tokenStorage -> getToken ( ) ; if ( ! $ token instanceof TokenInterface ) { return ; } $ user = $ token -> getUser ( ) ; if ( ! $ user instanceof BackendUser || ! $ user -> language ) { return ; } $ request = $ event -> getRequest ( ) ; $ request -> setLocale ( $ user -> language ) ; $ this -> translator -> setLocale ( $ user -> language ) ; $ GLOBALS [ 'TL_LANGUAGE' ] = str_replace ( '_' , '-' , $ user -> language ) ; }
11259	public static function pascal2snake ( string $ pascal ) : string { preg_match_all ( '/((?:^|[A-Z])[a-z]+)/' , $ pascal , $ matches ) ; if ( $ matches !== null && count ( $ matches ) > 1 && count ( $ matches [ 1 ] ) > 1 ) { $ nameParts = $ matches [ 1 ] ; $ nameParts = array_map ( "lcfirst" , $ nameParts ) ; return implode ( "_" , $ nameParts ) ; } else { return lcfirst ( $ pascal ) ; } }
8326	public function sendRecaptchaV2 ( $ googleKey , $ pageUrl , $ extra = [ ] ) { $ this -> getLogger ( ) -> info ( "Try send google key (recaptcha) on {$this->serverBaseUri}/in.php" ) ; if ( $ this -> softId && ! isset ( $ extra [ Extra :: SOFT_ID ] ) ) { $ extra [ Extra :: SOFT_ID ] = $ this -> softId ; } $ response = $ this -> getHttpClient ( ) -> request ( 'POST' , "/in.php" , [ RequestOptions :: QUERY => array_merge ( $ extra , [ 'method' => 'userrecaptcha' , 'key' => $ this -> apiKey , 'googlekey' => $ googleKey , 'pageurl' => $ pageUrl ] ) ] ) ; $ responseText = $ response -> getBody ( ) -> __toString ( ) ; if ( strpos ( $ responseText , 'OK|' ) !== false ) { $ this -> lastCaptchaId = explode ( "|" , $ responseText ) [ 1 ] ; $ this -> getLogger ( ) -> info ( "Sending success. Got captcha id `{$this->lastCaptchaId}`." ) ; return $ this -> lastCaptchaId ; } throw new ErrorResponseException ( $ this -> getErrorMessage ( $ responseText ) ? : "Unknown error: `{$responseText}`." ) ; }
45	public function dispatchPackageEvent ( $ eventName , $ devMode , PolicyInterface $ policy , Pool $ pool , CompositeRepository $ installedRepo , Request $ request , array $ operations , OperationInterface $ operation ) { return $ this -> doDispatch ( new PackageEvent ( $ eventName , $ this -> composer , $ this -> io , $ devMode , $ policy , $ pool , $ installedRepo , $ request , $ operations , $ operation ) ) ; }
6887	private function httpGet ( $ path , array $ query = array ( ) ) { $ url = new Uri ( $ this -> baseUrl . $ path ) ; foreach ( $ query as $ name => $ value ) { $ url = Uri :: withQueryValue ( $ url , $ name , $ value ) ; } $ request = new Request ( 'GET' , $ url , $ this -> buildHeaders ( ) ) ; try { $ response = $ this -> getHttpClient ( ) -> sendRequest ( $ request ) ; } catch ( \ RuntimeException $ e ) { throw new Exception \ PostcodeException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } if ( $ response -> getStatusCode ( ) != 200 ) { throw $ this -> createErrorException ( $ response ) ; } return $ response ; }
5182	private function fillSource ( $ source , $ photo ) : string { if ( ! empty ( $ source ) ) { return $ this -> filterUriInstance ( $ source ) ; } return ( string ) $ photo ; }
6444	protected function getClient ( $ redirecturl = '' ) { if ( is_object ( $ this -> linkedin ) ) { return $ this -> linkedin ; } if ( $ redirecturl == '' ) { $ redirecturl = $ this -> redirecturl ; } else { $ this -> redirecturl = $ redirecturl ; } $ this -> logQ ( 'redirect ' . $ redirecturl , 'linkedin' ) ; $ API_CONFIG = array ( 'api_key' => $ this -> options [ 'api_key' ] , 'api_secret' => $ this -> options [ 'api_secret' ] , 'callback_url' => $ redirecturl ) ; $ this -> linkedin = $ linkedin = new \ LinkedIn \ LinkedIn ( $ API_CONFIG ) ; return $ this -> linkedin ; }
11514	public function getNamedParams ( string $ category = null ) : array { switch ( $ category ) { case 'attribute' : return $ this -> request -> getAttributes ( ) ; case 'query' : return $ this -> request -> getQueryParams ( ) ; case 'uploaded_files' : return $ this -> request -> getUploadedFiles ( ) ; case 'parsed_body' : { $ body = $ this -> request -> getParsedBody ( ) ; if ( ! $ body ) { return [ ] ; } if ( is_array ( $ body ) ) { return $ body ; } if ( is_object ( $ body ) ) { return get_object_vars ( $ body ) ; } } return [ ] ; case 'server' : return $ this -> request -> getServerParams ( ) ; case 'cookie' : return $ this -> request -> getCookieParams ( ) ; } return [ ] ; }
3673	private function getPageIdFromUrlHook ( ? array $ fragments ) : ? array { if ( ! ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getPageIdFromUrl' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getPageIdFromUrl' ] ) ) ) { return $ fragments ; } foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getPageIdFromUrl' ] as $ callback ) { $ fragments = System :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ fragments ) ; } return $ fragments ; }
10993	public function getByteSize ( ) : int { if ( $ this -> test ( \ sndsgd \ Fs :: READABLE ) !== true ) { $ this -> error = "failed to stat filesize; {$this->error}" ; return - 1 ; } $ bytes = @ filesize ( $ this -> path ) ; if ( $ bytes === false ) { $ this -> setError ( "failed to stat filesize for '{$this->path}'" ) ; return - 1 ; } return $ bytes ; }
11056	public function urlFunction ( $ route , array $ params = [ ] ) { return $ this -> container [ 'url_generator' ] -> generate ( $ route , $ params , UrlGeneratorInterface :: ABSOLUTE_URL ) ; }
12535	public function fetchByApplyId ( $ applyId , $ lastSeen , $ count ) { $ params = [ 'type' => 3 , 'apply_id' => intval ( $ applyId ) , 'last_seen' => intval ( $ lastSeen ) , 'count' => intval ( $ count ) , ] ; return $ this -> fetch ( $ params ) ; }
10824	public static function confirm ( $ question , $ allowShort , $ defaultValue = false ) { $ value = $ defaultValue ? 'yes' : 'no' ; $ value = self :: ask ( $ question . ' (yes/no)' , $ value ) ; return $ value == 'yes' || ( $ value == 'y' && $ allowShort ) ; }
2571	public static function isValidFopType ( $ fopType ) { return ( $ fopType == self :: IDENT_CASH || $ fopType == self :: IDENT_CHECK || $ fopType == self :: IDENT_CREDITCARD || $ fopType == self :: IDENT_MISC ) ; }
5205	public function isActiveMatch ( $ string , $ output = "active" ) { if ( strpos ( $ this -> url -> current ( ) , $ string ) !== false ) { return $ output ; } return null ; }
3519	public function getWebUITranslations ( ) { $ TITLE_SAVE_CHANGES = $ this -> get ( $ this -> package . '::messages.title-save-changes' ) ; $ TITLE_CANCEL_CHANGES = $ this -> get ( $ this -> package . '::messages.title-cancel-changes' ) ; $ TITLE_TRANSLATE = $ this -> get ( $ this -> package . '::messages.title-translate' ) ; $ TITLE_CONVERT_KEY = $ this -> get ( $ this -> package . '::messages.title-convert-key' ) ; $ TITLE_GENERATE_PLURALS = $ this -> get ( $ this -> package . '::messages.title-generate-plurals' ) ; $ TITLE_CLEAN_HTML_MARKDOWN = $ this -> get ( $ this -> package . '::messages.title-clean-html-markdown' ) ; $ TITLE_CAPITALIZE = $ this -> get ( $ this -> package . '::messages.title-capitalize' ) ; $ TITLE_LOWERCASE = $ this -> get ( $ this -> package . '::messages.title-lowercase' ) ; $ TITLE_CAPITALIZE_FIRST_WORD = $ this -> get ( $ this -> package . '::messages.title-capitalize-first-word' ) ; $ TITLE_SIMULATED_COPY = $ this -> get ( $ this -> package . '::messages.title-simulated-copy' ) ; $ TITLE_SIMULATED_PASTE = $ this -> get ( $ this -> package . '::messages.title-simulated-paste' ) ; $ TITLE_RESET_EDITOR = $ this -> get ( $ this -> package . '::messages.title-reset-editor' ) ; $ TITLE_LOAD_LAST = $ this -> get ( $ this -> package . '::messages.title-load-last' ) ; return <<<HTML<script>var TITLE_SAVE_CHANGES = "$TITLE_SAVE_CHANGES";var TITLE_CANCEL_CHANGES = "$TITLE_CANCEL_CHANGES";var TITLE_TRANSLATE = "$TITLE_TRANSLATE";var TITLE_CONVERT_KEY = "$TITLE_CONVERT_KEY";var TITLE_GENERATE_PLURALS = "$TITLE_GENERATE_PLURALS";var TITLE_CLEAN_HTML_MARKDOWN = "$TITLE_CLEAN_HTML_MARKDOWN";var TITLE_CAPITALIZE = "$TITLE_CAPITALIZE";var TITLE_LOWERCASE = "$TITLE_LOWERCASE";var TITLE_CAPITALIZE_FIRST_WORD = "$TITLE_CAPITALIZE_FIRST_WORD";var TITLE_SIMULATED_COPY = "$TITLE_SIMULATED_COPY";var TITLE_SIMULATED_PASTE = "$TITLE_SIMULATED_PASTE";var TITLE_RESET_EDITOR = "$TITLE_RESET_EDITOR";var TITLE_LOAD_LAST = "$TITLE_LOAD_LAST";</script>HTML ; }
10000	public function setSoftEdgesSize ( $ size ) { if ( $ size !== null ) { $ this -> activateObject ( ) ; $ softEdges [ 'size' ] = ( string ) $ this -> getExcelPointsWidth ( $ size ) ; } }
355	public function prepare ( $ forcePrepare = false ) { if ( $ forcePrepare || $ this -> _models === null ) { $ this -> _models = $ this -> prepareModels ( ) ; } if ( $ forcePrepare || $ this -> _keys === null ) { $ this -> _keys = $ this -> prepareKeys ( $ this -> _models ) ; } }
11015	public static function sec2time ( $ seconds ) { $ sec = intval ( $ seconds ) ; $ dtF = new \ DateTime ( "@0" ) ; $ dtT = new \ DateTime ( "@$sec" ) ; return $ dtF -> diff ( $ dtT ) -> format ( '%a days, %h hours, %i minutes and %s seconds' ) ; }
3969	protected function deleteConditionSettings ( PreDeleteModelEvent $ event ) { $ environment = $ event -> getEnvironment ( ) ; $ model = $ event -> getModel ( ) ; $ dataProvider = $ environment -> getDataProvider ( 'tl_metamodel_dcasetting_condition' ) ; $ conditions = $ dataProvider -> fetchAll ( $ dataProvider -> getEmptyConfig ( ) -> setFilter ( [ [ 'operation' => '=' , 'property' => 'attr_id' , 'value' => $ model -> getId ( ) ] ] ) ) ; if ( $ conditions -> count ( ) < 1 ) { return ; } $ conditionsGeneral = new \ DC_General ( $ dataProvider -> getEmptyModel ( ) -> getProviderName ( ) ) ; $ conditionsEnvironment = $ conditionsGeneral -> getEnvironment ( ) ; $ conditionsDataDefinition = $ conditionsEnvironment -> getDataDefinition ( ) ; $ conditionsPalettesDefinition = $ conditionsDataDefinition -> getPalettesDefinition ( ) ; $ conditionsIterator = $ conditions -> getIterator ( ) ; while ( $ currentCondition = $ conditionsIterator -> current ( ) ) { $ conditionPalette = $ conditionsPalettesDefinition -> getPaletteByName ( $ currentCondition -> getProperty ( 'type' ) ) ; $ conditionProperties = $ conditionPalette -> getVisibleProperties ( $ currentCondition ) ; foreach ( $ conditionProperties as $ conditionProperty ) { if ( $ conditionProperty -> getName ( ) !== 'attr_id' ) { continue ; } $ dataProvider -> delete ( $ currentCondition ) ; } $ conditionsIterator -> next ( ) ; } }
1251	private function startElement ( $ parser , $ name , array $ attributes ) { $ this -> metaStack -> push ( $ this -> getPhpMeta ( $ this -> normalizeElementName ( $ name ) , $ attributes ) ) ; }
2749	public function getVclFile ( $ vclTemplatePath ) { $ moduleEtcPath = $ this -> reader -> getModuleDir ( Dir :: MODULE_ETC_DIR , 'Fastly_Cdn' ) ; $ configFilePath = $ moduleEtcPath . '/' . $ this -> _scopeConfig -> getValue ( self :: FASTLY_CONFIGURATION_PATH ) ; $ directoryRead = $ this -> readFactory -> create ( $ moduleEtcPath ) ; $ configFilePath = $ directoryRead -> getRelativePath ( $ configFilePath ) ; $ data = $ directoryRead -> readFile ( $ configFilePath ) ; return strtr ( $ data , $ this -> getReplacements ( ) ) ; }
480	public function alterColumn ( $ table , $ column , $ type ) { $ time = $ this -> beginCommand ( "alter column $column in table $table to $type" ) ; $ this -> db -> createCommand ( ) -> alterColumn ( $ table , $ column , $ type ) -> execute ( ) ; if ( $ type instanceof ColumnSchemaBuilder && $ type -> comment !== null ) { $ this -> db -> createCommand ( ) -> addCommentOnColumn ( $ table , $ column , $ type -> comment ) -> execute ( ) ; } $ this -> endCommand ( $ time ) ; }
2433	public function get ( $ strKey ) { if ( \ in_array ( $ strKey , $ this -> mappedKeys ) ) { return $ this -> session -> get ( $ strKey ) ; } return $ this -> sessionBag -> get ( $ strKey ) ; }
3584	protected function metaHasQuery ( Builder $ query , $ method , ArgumentBag $ args ) { $ boolean = $ this -> getMetaBoolean ( $ args ) ; $ operator = $ this -> getMetaOperator ( $ method , $ args ) ; if ( in_array ( $ method , [ 'whereBetween' , 'where' ] ) ) { $ this -> unbindNumerics ( $ args ) ; } return $ query -> has ( 'metaAttributes' , $ operator , 1 , $ boolean , $ this -> getMetaWhereConstraint ( $ method , $ args ) ) -> with ( 'metaAttributes' ) ; }
12704	public function getTitleAttribute ( $ value ) { if ( $ value === null ) { $ value = '' ; } if ( getenv ( "BYPASS_HOOKS" ) != true ) { global $ hooks , $ codes ; return $ hooks -> apply_filters ( "TCT-Core-Main-Model-Page-Title" , $ codes -> do_shortcode ( $ value ) ) ; } else { return $ value ; } }
910	private function findHeaderCommentInsertionIndex ( Tokens $ tokens ) { if ( 'after_open' === $ this -> configuration [ 'location' ] ) { return 1 ; } $ index = $ tokens -> getNextMeaningfulToken ( 0 ) ; if ( null === $ index ) { return 1 ; } if ( ! $ tokens [ $ index ] -> isGivenKind ( T_DECLARE ) ) { return 1 ; } $ next = $ tokens -> getNextMeaningfulToken ( $ index ) ; if ( null === $ next || ! $ tokens [ $ next ] -> equals ( '(' ) ) { return 1 ; } $ next = $ tokens -> getNextMeaningfulToken ( $ next ) ; if ( null === $ next || ! $ tokens [ $ next ] -> equals ( [ T_STRING , 'strict_types' ] , false ) ) { return 1 ; } $ next = $ tokens -> getNextMeaningfulToken ( $ next ) ; if ( null === $ next || ! $ tokens [ $ next ] -> equals ( '=' ) ) { return 1 ; } $ next = $ tokens -> getNextMeaningfulToken ( $ next ) ; if ( null === $ next || ! $ tokens [ $ next ] -> isGivenKind ( T_LNUMBER ) ) { return 1 ; } $ next = $ tokens -> getNextMeaningfulToken ( $ next ) ; if ( null === $ next || ! $ tokens [ $ next ] -> equals ( ')' ) ) { return 1 ; } $ next = $ tokens -> getNextMeaningfulToken ( $ next ) ; if ( null === $ next || ! $ tokens [ $ next ] -> equals ( ';' ) ) { return 1 ; } return $ next + 1 ; }
12326	public function uploadImage ( $ path , $ type = 'icon' ) { if ( ! file_exists ( $ path ) || ! is_readable ( $ path ) ) { throw new InvalidArgumentException ( "File does not exist, or the file is unreadable: '$path'" ) ; } $ type = strtolower ( $ type ) ; return $ this -> parseJSON ( 'upload' , [ self :: API_MATERIAL_ADD , [ 'media' => $ path ] , [ ] , [ 'type' => $ type ] ] ) ; }
4220	private function getLogArgs ( $ cleared ) { $ cleared = \ array_filter ( $ cleared ) ; if ( ! $ cleared ) { return array ( ) ; } $ count = \ count ( $ cleared ) ; $ glue = $ count == 2 ? ' and ' : ', ' ; if ( $ count > 2 ) { $ cleared [ $ count - 1 ] = 'and ' . $ cleared [ $ count - 1 ] ; } $ msg = 'Cleared ' . \ implode ( $ glue , $ cleared ) ; if ( $ this -> channelName ) { return array ( $ msg . ' %c(%s)' , 'background-color:#c0c0c0; padding:0 .33em;' , $ this -> channelName , ) ; } return array ( $ msg ) ; }
1067	private function findConflictsBetweenSubSelectionSets ( ValidationContext $ context , $ areMutuallyExclusive , $ parentType1 , SelectionSetNode $ selectionSet1 , $ parentType2 , SelectionSetNode $ selectionSet2 ) { $ conflicts = [ ] ; [ $ fieldMap1 , $ fragmentNames1 ] = $ this -> getFieldsAndFragmentNames ( $ context , $ parentType1 , $ selectionSet1 ) ; [ $ fieldMap2 , $ fragmentNames2 ] = $ this -> getFieldsAndFragmentNames ( $ context , $ parentType2 , $ selectionSet2 ) ; $ this -> collectConflictsBetween ( $ context , $ conflicts , $ areMutuallyExclusive , $ fieldMap1 , $ fieldMap2 ) ; $ fragmentNames2Length = count ( $ fragmentNames2 ) ; if ( $ fragmentNames2Length !== 0 ) { $ comparedFragments = [ ] ; for ( $ j = 0 ; $ j < $ fragmentNames2Length ; $ j ++ ) { $ this -> collectConflictsBetweenFieldsAndFragment ( $ context , $ conflicts , $ comparedFragments , $ areMutuallyExclusive , $ fieldMap1 , $ fragmentNames2 [ $ j ] ) ; } } $ fragmentNames1Length = count ( $ fragmentNames1 ) ; if ( $ fragmentNames1Length !== 0 ) { $ comparedFragments = [ ] ; for ( $ i = 0 ; $ i < $ fragmentNames1Length ; $ i ++ ) { $ this -> collectConflictsBetweenFieldsAndFragment ( $ context , $ conflicts , $ comparedFragments , $ areMutuallyExclusive , $ fieldMap2 , $ fragmentNames1 [ $ i ] ) ; } } for ( $ i = 0 ; $ i < $ fragmentNames1Length ; $ i ++ ) { for ( $ j = 0 ; $ j < $ fragmentNames2Length ; $ j ++ ) { $ this -> collectConflictsBetweenFragments ( $ context , $ conflicts , $ areMutuallyExclusive , $ fragmentNames1 [ $ i ] , $ fragmentNames2 [ $ j ] ) ; } } return $ conflicts ; }
9889	public static function json ( $ response ) { $ body = self :: toString ( $ response ) ; $ data = json_decode ( $ body , true ) ; if ( JSON_ERROR_NONE !== json_last_error ( ) ) { throw new RuntimeException ( 'Unable to parse response body into JSON: ' . json_last_error ( ) ) ; } return $ data === null ? [ ] : $ data ; }
2754	public static function plainText ( $ value ) { $ element = render ( $ value ) ; $ element = strip_tags ( $ element ) ; $ element = html_entity_decode ( $ element , ENT_QUOTES ) ; return $ element ; }
25	public function getContents ( $ originUrl , $ fileUrl , $ progress = true , $ options = array ( ) ) { return $ this -> get ( $ originUrl , $ fileUrl , $ options , null , $ progress ) ; }
7363	protected function updatePaymentTotal ( SaleInterface $ sale ) { $ changed = false ; $ currency = $ sale -> getCurrency ( ) -> getCode ( ) ; $ paid = $ this -> paymentCalculator -> calculatePaidTotal ( $ sale ) ; if ( 0 != Money :: compare ( $ paid , $ sale -> getPaidTotal ( ) , $ currency ) ) { $ sale -> setPaidTotal ( $ paid ) ; $ changed = true ; } $ pending = $ this -> paymentCalculator -> calculateOfflinePendingTotal ( $ sale ) ; if ( 0 != Money :: compare ( $ pending , $ sale -> getPendingTotal ( ) , $ currency ) ) { $ sale -> setPendingTotal ( $ pending ) ; $ changed = true ; } $ acceptedOutstanding = $ this -> paymentCalculator -> calculateOutstandingAcceptedTotal ( $ sale ) ; if ( 0 != Money :: compare ( $ acceptedOutstanding , $ sale -> getOutstandingAccepted ( ) , $ currency ) ) { $ sale -> setOutstandingAccepted ( $ acceptedOutstanding ) ; $ changed = true ; } $ expiredOutstanding = $ this -> paymentCalculator -> calculateOutstandingExpiredTotal ( $ sale ) ; if ( 0 != Money :: compare ( $ expiredOutstanding , $ sale -> getOutstandingExpired ( ) , $ currency ) ) { $ sale -> setOutstandingExpired ( $ expiredOutstanding ) ; $ changed = true ; } if ( $ changed && $ this -> outstandingReleaser -> releaseFund ( $ sale ) ) { $ sale -> setOutstandingAccepted ( $ this -> paymentCalculator -> calculateOutstandingAcceptedTotal ( $ sale ) ) ; $ sale -> setOutstandingExpired ( $ this -> paymentCalculator -> calculateOutstandingExpiredTotal ( $ sale ) ) ; } return $ changed ; }
8433	public function migrate ( Request $ req ) { if ( count ( $ req -> getArgs ( ) ) != 1 ) { echo 'Wrong arguments.' . PHP_EOL . 'Usage : db/migration/migrate mapping_name' . PHP_EOL ; } else { $ mappingName = $ req -> getArgs ( ) [ 0 ] ; $ mapping = Mapping :: get ( $ mappingName ) ; $ cl = '\\' . ltrim ( rtrim ( $ mapping [ 'config' ] [ 'provider' ] , '\\' ) , '\\' ) . '\\Migration::migrate' ; if ( is_callable ( $ cl ) === false ) { throw new RuntimeException ( 'Migration migrate method is not callable on configured provider!' ) ; } call_user_func ( $ cl , $ mapping ) ; echo 'Migrate - Done' . PHP_EOL ; } }
2918	public function appendSetter ( $ key , $ value = null , $ comment = null , $ export = false ) { $ line = $ this -> formatter -> formatSetterLine ( $ key , $ value , $ comment , $ export ) ; return $ this -> appendLine ( $ line ) ; }
4263	public function unsubscribe ( $ eventName , $ callable ) { if ( ! isset ( $ this -> subscribers [ $ eventName ] ) ) { return ; } if ( $ this -> isClosureFactory ( $ callable ) ) { $ callable [ 0 ] = $ callable [ 0 ] ( ) ; } foreach ( $ this -> subscribers [ $ eventName ] as $ priority => $ subscribers ) { foreach ( $ subscribers as $ k => $ v ) { if ( $ v !== $ callable && $ this -> isClosureFactory ( $ v ) ) { $ v [ 0 ] = $ v [ 0 ] ( ) ; } if ( $ v === $ callable ) { unset ( $ subscribers [ $ k ] , $ this -> sorted [ $ eventName ] ) ; } else { $ subscribers [ $ k ] = $ v ; } } if ( $ subscribers ) { $ this -> subscribers [ $ eventName ] [ $ priority ] = $ subscribers ; } else { unset ( $ this -> subscribers [ $ eventName ] [ $ priority ] ) ; } } }
7801	protected function splitTransactions ( $ text ) { $ offset = 0 ; $ length = 0 ; $ position = 0 ; $ transactions = array ( ) ; while ( $ line = $ this -> getLine ( '61' , $ text , $ offset , $ offset , $ length ) ) { $ offset += 4 + $ length + 2 ; $ transaction = array ( $ line ) ; $ description = array ( ) ; while ( $ line = $ this -> getLine ( '86' , $ text , $ offset , $ position , $ length ) ) { if ( $ position == $ offset ) { $ offset += 4 + $ length + 2 ; $ description [ ] = $ line ; } else { break ; } } if ( $ description ) { $ transaction [ ] = implode ( "\r\n" , $ description ) ; } $ transactions [ ] = $ transaction ; } return $ transactions ; }
7113	public function urlAllowed ( $ user , $ url ) { if ( empty ( $ url ) ) { return false ; } if ( is_array ( $ url ) ) { $ url = Hash :: merge ( [ 'plugin' => null ] , $ url ) ; $ url = Router :: url ( $ url ) ; $ url = Router :: normalize ( $ url ) ; } $ route = Router :: parse ( $ url ) ; if ( empty ( $ route [ 'controller' ] ) || empty ( $ route [ 'action' ] ) ) { return false ; } return $ this -> isAuthorized ( $ user , $ route [ 'plugin' ] , $ route [ 'controller' ] , $ route [ 'action' ] ) ; }
521	protected function migrateDown ( $ class ) { if ( $ class === self :: BASE_MIGRATION ) { return true ; } $ this -> stdout ( "*** reverting $class\n" , Console :: FG_YELLOW ) ; $ start = microtime ( true ) ; $ migration = $ this -> createMigration ( $ class ) ; if ( $ migration -> down ( ) !== false ) { $ this -> removeMigrationHistory ( $ class ) ; $ time = microtime ( true ) - $ start ; $ this -> stdout ( "*** reverted $class (time: " . sprintf ( '%.3f' , $ time ) . "s)\n\n" , Console :: FG_GREEN ) ; return true ; } $ time = microtime ( true ) - $ start ; $ this -> stdout ( "*** failed to revert $class (time: " . sprintf ( '%.3f' , $ time ) . "s)\n\n" , Console :: FG_RED ) ; return false ; }
9679	function fromXML ( $ xmlElement ) { $ this -> contact = new ReportContact ( ) ; $ this -> contact -> fromXML ( $ xmlElement -> contact ) ; if ( isset ( $ xmlElement -> mailing_id ) ) $ this -> mailingId = $ xmlElement -> mailing_id ; if ( isset ( $ xmlElement -> source ) ) $ this -> source = $ xmlElement -> source ; if ( isset ( $ xmlElement -> timestamp ) ) $ this -> timestamp = $ xmlElement -> timestamp ; }
10199	private function writeCellSpan ( XMLWriter $ objWriter , $ curColumn , $ prevColumn ) { $ diff = $ curColumn - $ prevColumn - 1 ; if ( 1 === $ diff ) { $ objWriter -> writeElement ( 'table:table-cell' ) ; } elseif ( $ diff > 1 ) { $ objWriter -> startElement ( 'table:table-cell' ) ; $ objWriter -> writeAttribute ( 'table:number-columns-repeated' , $ diff ) ; $ objWriter -> endElement ( ) ; } }
4598	public function generateIdentity ( Identitiable $ model , bool $ overwrite = false ) { if ( null === $ model -> getIdentity ( ) || $ overwrite ) { $ user = $ this -> tokenStorage -> getToken ( ) -> getUser ( ) ; $ model -> setIdentity ( $ user -> getIdentity ( ) -> getType ( ) ) -> setIdentityUuid ( $ user -> getIdentity ( ) -> getUuid ( ) ) ; } return $ this ; }
5339	public function setMode ( $ mode ) { if ( ! in_array ( $ mode , $ this -> acceptedModes ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Invalid mode: [%s]' , $ mode ) ) ; } $ this -> mode = $ mode ; }
33	protected function addReason ( $ id , $ reason ) { if ( ! isset ( $ this -> reasonSeen [ $ id ] ) ) { $ this -> reasonSeen [ $ id ] = true ; $ this -> reasons [ $ this -> section ] [ ] = $ reason ; } }
7831	public function getSpacedCore ( ) { $ left = $ this -> getSpacesByCore ( ) ; $ right = $ this -> getSpacesByCore ( true ) ; return $ left . $ this -> core . $ right ; }
5601	public function paintPass ( $ message ) { if ( ! $ this -> pass ) { $ this -> message = self :: escapeVal ( $ message ) ; } $ this -> pass = true ; }
2379	public static function deserialize ( $ varValue , $ blnForceArray = false ) { if ( \ is_array ( $ varValue ) ) { return $ varValue ; } if ( $ varValue === null ) { return $ blnForceArray ? array ( ) : null ; } if ( ! \ is_string ( $ varValue ) ) { return $ blnForceArray ? array ( $ varValue ) : $ varValue ; } if ( trim ( $ varValue ) == '' ) { return $ blnForceArray ? array ( ) : '' ; } if ( strncmp ( $ varValue , 'a:' , 2 ) !== 0 ) { return $ blnForceArray ? array ( $ varValue ) : $ varValue ; } if ( preg_match ( '/[OoC]:\+?[0-9]+:"/' , $ varValue ) ) { trigger_error ( 'StringUtil::deserialize() does not allow serialized objects' , E_USER_WARNING ) ; return $ blnForceArray ? array ( $ varValue ) : $ varValue ; } $ varUnserialized = @ unserialize ( $ varValue , array ( 'allowed_classes' => false ) ) ; if ( \ is_array ( $ varUnserialized ) ) { $ varValue = $ varUnserialized ; } elseif ( $ blnForceArray ) { $ varValue = array ( $ varValue ) ; } return $ varValue ; }
997	public function offsetUnset ( $ offset ) { if ( $ offset === true ) { $ this -> trueValue = null ; $ this -> trueValueIsSet = false ; } elseif ( $ offset === false ) { $ this -> falseValue = null ; $ this -> falseValueIsSet = false ; } elseif ( is_int ( $ offset ) || is_string ( $ offset ) ) { unset ( $ this -> standardStore [ $ offset ] ) ; } elseif ( is_float ( $ offset ) ) { unset ( $ this -> floatStore [ ( string ) $ offset ] ) ; } elseif ( is_object ( $ offset ) ) { $ this -> objectStore -> offsetUnset ( $ offset ) ; } elseif ( is_array ( $ offset ) ) { $ index = array_search ( $ offset , $ this -> arrayKeys , true ) ; if ( $ index !== false ) { array_splice ( $ this -> arrayKeys , $ index , 1 ) ; array_splice ( $ this -> arrayValues , $ index , 1 ) ; } } elseif ( $ offset === null ) { $ this -> nullValue = null ; $ this -> nullValueIsSet = false ; } }
6000	public function setImagetemplates ( array $ imagetemplates ) { $ this -> imagetemplates = [ ] ; foreach ( $ imagetemplates as $ item ) { $ this -> addImageTemplate ( $ item ) ; } return $ this ; }
5128	public function readQDateTime ( ) { $ day = $ this -> readUInt ( ) ; $ msec = $ this -> readUInt ( ) ; $ this -> readBool ( ) ; if ( $ day === 0 && $ msec === 0xFFFFFFFF ) { return null ; } $ time = ( $ day - 2440588 ) * 86400 + $ msec / 1000 ; $ dt = \ DateTime :: createFromFormat ( 'U.u' , sprintf ( '%.6F' , $ time ) ) ; $ dt -> setTimezone ( new \ DateTimeZone ( date_default_timezone_get ( ) ) ) ; return $ dt ; }
5826	public function setJson ( $ toggle ) { $ this -> setEncoding ( $ toggle ? Request :: ENCODING_JSON : Request :: ENCODING_QUERY ) ; return $ this ; }
5618	public function paintHeader ( $ test_name ) { $ this -> sendNoCacheHeaders ( ) ; echo sprintf ( SIMPLETEST_WEBUNIT_HEAD , $ test_name , $ this -> path . 'js/' , $ this -> path . 'js/' , $ this -> path . 'css/' , $ this -> _getCss ( ) , $ test_name , $ this -> path . 'img/' ) ; flush ( ) ; }
609	public function convert ( $ asset , $ basePath ) { $ pos = strrpos ( $ asset , '.' ) ; if ( $ pos !== false ) { $ ext = substr ( $ asset , $ pos + 1 ) ; if ( isset ( $ this -> commands [ $ ext ] ) ) { list ( $ ext , $ command ) = $ this -> commands [ $ ext ] ; $ result = substr ( $ asset , 0 , $ pos + 1 ) . $ ext ; if ( $ this -> forceConvert || @ filemtime ( "$basePath/$result" ) < @ filemtime ( "$basePath/$asset" ) ) { $ this -> runCommand ( $ command , $ basePath , $ asset , $ result ) ; } return $ result ; } } return $ asset ; }
1297	private function resolveFieldLinks ( $ field , string $ locale = null ) { if ( null === $ locale ) { $ locale = null === $ this -> sys -> getLocale ( ) ? '*' : $ this -> getLocale ( ) ; } if ( $ field instanceof Link ) { return $ this -> client -> resolveLink ( $ field , $ locale ) ; } if ( \ is_array ( $ field ) && isset ( $ field [ 0 ] ) && $ field [ 0 ] instanceof Link ) { return $ this -> client -> resolveLinkCollection ( $ field , $ locale ) ; } return $ field ; }
2366	public static function censor ( $ strString , $ varWords , $ strReplace = '' ) { foreach ( ( array ) $ varWords as $ strWord ) { $ strString = preg_replace ( '/\b(' . str_replace ( '\*' , '\w*?' , preg_quote ( $ strWord , '/' ) ) . ')\b/i' , $ strReplace , $ strString ) ; } return $ strString ; }
1766	public function onKernelResponse ( FilterResponseEvent $ event ) : void { if ( ! $ this -> scopeMatcher -> isContaoMasterRequest ( $ event ) ) { return ; } $ request = $ event -> getRequest ( ) ; if ( ! $ request -> isMethod ( Request :: METHOD_GET ) ) { return ; } $ response = $ event -> getResponse ( ) ; if ( 200 !== $ response -> getStatusCode ( ) ) { return ; } $ token = $ this -> tokenStorage -> getToken ( ) ; if ( null === $ token || $ this -> authenticationTrustResolver -> isAnonymous ( $ token ) ) { return ; } if ( $ this -> scopeMatcher -> isBackendRequest ( $ request ) ) { $ this -> storeBackendReferer ( $ request ) ; } else { $ this -> storeFrontendReferer ( $ request ) ; } }
8424	public function generate ( Request $ request ) { if ( count ( $ request -> getArgs ( ) ) != 1 ) { echo 'Wrong arguments.' . PHP_EOL . 'Usage : db/generate mapping_name' . PHP_EOL ; } else { $ mapping = $ request -> getArgs ( ) [ 0 ] ; $ schema = Schema :: getSchema ( $ mapping ) ; $ schema -> generateModels ( ) ; } }
1463	private function guessColumn ( ) { if ( $ this -> query instanceof EloquentBuilder || $ this -> query instanceof Relation ) { return $ this -> query -> getModel ( ) -> getCreatedAtColumn ( ) ; } return Model :: CREATED_AT ; }
1485	public function prepend ( Decoding ... $ decodings ) : self { $ copy = clone $ this ; array_unshift ( $ copy -> stack , ... $ decodings ) ; return $ copy ; }
8766	protected function loadConfigFiles ( ) { try { if ( file_exists ( $ this -> cachePath ( 'config.php' ) ) ) { $ this -> config = require $ this -> cachePath ( 'config.php' ) ; } else { $ dotenv = new \ Dotenv \ Dotenv ( $ this -> root ) ; $ dotenv -> load ( ) ; foreach ( glob ( $ this -> root . '/config/*.php' ) as $ file ) { $ keyName = strtolower ( str_replace ( [ $ this -> root . '/config/' , '.php' ] , '' , $ file ) ) ; $ this -> config [ $ keyName ] = require $ file ; } } } catch ( Exception $ e ) { die ( printf ( "Configuration information could not be retrieved properly.\nError Message: %s" , $ e -> getMessage ( ) ) ) ; } }
7494	public function trimRight ( $ characters = null ) { $ this -> string = rtrim ( $ this -> string , $ characters ) ; return $ this ; }
4101	public function map ( $ mapping , array $ config = array ( ) ) { if ( is_array ( $ mapping ) ) $ mapping = new Mapping ( $ mapping ) ; $ mapping -> config ( $ config ) ; try { $ type = $ mapping -> config ( 'type' ) ; } catch ( \ Exception $ e ) { } if ( isset ( $ type ) && ! $ this -> passesTypeConstraint ( $ type ) ) { throw new Exception ( "Cant create mapping due to type constraint mismatch" ) ; } return $ this -> request ( '_mapping' , 'PUT' , $ mapping -> export ( ) , true ) ; }
7362	protected function updateAmountsTotal ( SaleInterface $ sale ) { $ changed = false ; $ currency = $ sale -> getCurrency ( ) -> getCode ( ) ; $ sale -> clearResults ( ) ; $ result = $ this -> amountCalculator -> calculateSale ( $ sale ) ; if ( 0 != Money :: compare ( $ result -> getBase ( ) , $ sale -> getNetTotal ( ) , $ currency ) ) { $ sale -> setNetTotal ( $ result -> getBase ( ) ) ; $ changed = true ; } if ( 0 != Money :: compare ( $ result -> getTotal ( ) , $ sale -> getGrandTotal ( ) , $ currency ) ) { $ sale -> setGrandTotal ( $ result -> getTotal ( ) ) ; $ changed = true ; } return $ changed ; }
10859	protected function cacheMarkers ( string $ marker ) : void { $ this -> marked [ $ marker ] = [ ] ; foreach ( $ this -> definitions as $ definition ) { foreach ( ( array ) $ definition -> markers as $ m ) { if ( $ m instanceof $ marker ) { $ this -> marked [ $ marker ] [ ] = [ $ definition , $ m ] ; } } } }
6709	protected function useActualParameters ( ) { $ this -> setParameters ( $ this -> urlToParameters ( $ this -> getRequestedUri ( ) ) ) ; $ this -> setParameters ( $ _REQUEST ) ; $ this -> setParameters ( $ this -> parseHeader ( $ _SERVER ) ) ; $ this -> setParameters ( $ this -> stringToArray ( $ this -> readBody ( ) ) ) ; return $ this -> getParameters ( ) ; }
123	public function binaryVersion ( ) { if ( ! self :: $ version ) { if ( 0 === $ this -> process -> execute ( 'svn --version' , $ output ) ) { if ( preg_match ( '{(\d+(?:\.\d+)+)}' , $ output , $ match ) ) { self :: $ version = $ match [ 1 ] ; } } } return self :: $ version ; }
2904	public function send ( $ email , $ name = null , array $ variables = array ( ) ) { $ zendMail = $ this -> getMail ( ) ; $ result = $ this -> parentSend ( $ email , $ name , $ variables ) ; try { $ this -> addEmailToProfile ( $ email , $ name , $ variables , $ result , $ zendMail ) ; } catch ( Exception $ e ) { Mage :: logException ( $ e ) ; } return $ result ; }
160	public function andHaving ( $ condition , $ params = [ ] ) { if ( $ this -> having === null ) { $ this -> having = $ condition ; } else { $ this -> having = [ 'and' , $ this -> having , $ condition ] ; } $ this -> addParams ( $ params ) ; return $ this ; }
1421	protected function createBelongsToIdentity ( Model $ model , $ relationshipKey ) { $ relation = $ model -> { $ relationshipKey } ( ) ; if ( ! $ relation instanceof BelongsTo ) { throw new RuntimeException ( sprintf ( 'Expecting %s on %s to be a belongs-to relationship.' , $ relationshipKey , get_class ( $ model ) ) ) ; } $ foreignKey = method_exists ( $ relation , 'getForeignKeyName' ) ? $ relation -> getForeignKeyName ( ) : $ relation -> getForeignKey ( ) ; $ id = $ model -> { $ foreignKey } ; if ( is_null ( $ id ) ) { return null ; } $ ownerKey = method_exists ( $ relation , 'getOwnerKeyName' ) ? $ relation -> getOwnerKeyName ( ) : $ relation -> getOwnerKey ( ) ; $ related = $ relation -> getRelated ( ) -> replicate ( ) ; $ related -> { $ ownerKey } = $ id ; return $ related ; }
9165	public function fields ( $ entity = array ( ) , $ action = 'all' , array $ params = array ( ) ) { $ fieldCollection = array ( ) ; $ entity = $ this -> entityFactory -> build ( $ entity ) ; if ( $ entity instanceof \ ElggEntity ) { $ params [ 'entity' ] = $ entity ; $ fields = ( array ) elgg_trigger_plugin_hook ( 'prototype' , $ action , $ params , array ( ) ) ; $ attribute_names = $ this -> entityFactory -> getAttributeNames ( $ entity ) ; if ( ! $ entity -> guid ) { $ fields [ 'type' ] = array ( 'type' => 'hidden' ) ; $ fields [ 'subtype' ] = array ( 'type' => 'hidden' ) ; $ fields [ 'owner_guid' ] = array ( 'type' => 'hidden' ) ; $ fields [ 'container_guid' ] = array ( 'type' => 'hidden' ) ; } else { $ fields [ 'guid' ] = array ( 'type' => 'hidden' ) ; } foreach ( $ fields as $ shortname => $ field ) { $ field [ 'entity_type' ] = $ entity -> getType ( ) ; $ field [ 'entity_subtype' ] = $ entity -> getSubtype ( ) ; if ( empty ( $ field [ 'shortname' ] ) ) { $ field [ 'shortname' ] = $ shortname ; } if ( in_array ( $ shortname , $ attribute_names ) ) { $ field [ 'data_type' ] = 'attribute' ; $ field [ 'class_name' ] = Elements \ AttributeField :: CLASSNAME ; } $ fieldObj = $ this -> fieldFactory -> build ( $ field ) ; if ( $ fieldObj instanceof Elements \ Field ) { $ fieldCollection [ ] = $ fieldObj ; } } } return new Elements \ FieldCollection ( $ fieldCollection ) ; }
2817	public function addModel ( Mage_Core_Model_Abstract $ model ) { $ modelInfo = Mage :: getModel ( 'sheep_debug/model' ) ; $ modelInfo -> init ( $ model ) ; $ key = $ modelInfo -> getClass ( ) ; if ( ! array_key_exists ( $ key , $ this -> models ) ) { $ this -> models [ $ key ] = $ modelInfo ; } $ this -> models [ $ key ] -> incrementCount ( ) ; }
9908	public function setPosition ( $ position ) { if ( ! in_array ( $ position , self :: $ positionXLref ) ) { return false ; } $ this -> position = $ position ; return true ; }
12153	public function getPossibleRoles ( ) { $ roles = [ ] ; foreach ( Yii :: $ app -> collectors [ 'roles' ] -> getAll ( ) as $ roleItem ) { $ test = true ; switch ( $ roleItem -> systemId ) { case 'owner' : $ test = $ this -> isOwnable ; break ; } if ( $ test ) { $ roles [ ] = $ roleItem -> object -> primaryKey ; } } return $ roles ; }
8901	public function update_batch ( $ data , $ where_key ) { $ _data = array ( ) ; foreach ( $ data as $ key => $ row ) { if ( false !== $ row = $ this -> _do_pre_update ( $ row ) ) { $ _data [ $ key ] = $ row ; } } return $ this -> _database -> update_batch ( $ this -> _table , $ _data , $ where_key ) ; }
9174	private function hierarchyToFlatArray ( $ items ) { $ flatArray = [ ] ; foreach ( $ items as $ item ) { $ flatArray [ ] = $ item -> getId ( ) ; if ( $ items -> getChildren ( ) -> count ( ) > 0 ) { $ flatArray = array_merge ( $ flatArray , $ this -> hierarchyToFlatArray ( $ items -> getChildren ( ) ) ) ; } } return $ flatArray ; }
4918	public function setParam ( $ key , $ value ) { if ( $ this -> has ( $ key ) ) { $ this -> get ( $ key ) -> setValue ( $ value ) ; } else { $ this -> add ( [ 'type' => 'hidden' , 'name' => $ key , 'attributes' => [ 'value' => $ value ] ] ) ; } return $ this ; }
806	private function findReturnAnnotations ( Tokens $ tokens , $ index ) { do { $ index = $ tokens -> getPrevNonWhitespace ( $ index ) ; } while ( $ tokens [ $ index ] -> isGivenKind ( [ T_ABSTRACT , T_FINAL , T_PRIVATE , T_PROTECTED , T_PUBLIC , T_STATIC , ] ) ) ; if ( ! $ tokens [ $ index ] -> isGivenKind ( T_DOC_COMMENT ) ) { return [ ] ; } $ doc = new DocBlock ( $ tokens [ $ index ] -> getContent ( ) ) ; return $ doc -> getAnnotationsOfType ( 'return' ) ; }
1990	protected function jumpToOrReload ( $ intId , $ strParams = null , $ strForceLang = null ) { if ( $ strForceLang !== null ) { @ trigger_error ( 'Using Frontend::jumpToOrReload() with $strForceLang has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; } global $ objPage ; $ blnForceRedirect = ( $ strParams !== null || $ strForceLang !== null ) ; if ( \ is_array ( $ intId ) ) { $ intId = $ intId [ 'id' ] ?? 0 ; } if ( $ intId > 0 && ( $ intId != $ objPage -> id || $ blnForceRedirect ) && ( $ objNextPage = PageModel :: findPublishedById ( $ intId ) ) !== null ) { $ this -> redirect ( $ objNextPage -> getFrontendUrl ( $ strParams , $ strForceLang ) ) ; } $ this -> reload ( ) ; }
6097	protected function get ( $ endpoint , array $ parameters = [ ] , CachePolicy $ cachePolicy = null , $ fireAndForget = false ) { return $ this -> call ( $ endpoint , $ parameters , self :: METHOD_GET , $ cachePolicy , $ fireAndForget ) ; }
7022	private function formatO ( & $ str ) { if ( strstr ( $ str , '%O' ) ) { $ o = $ this -> timezone -> offset ; $ os = $ o >= 0 ? '+' : '-' ; $ oh = sprintf ( '%02d' , abs ( intval ( $ o ) ) ) ; $ om = sprintf ( '%02d' , abs ( $ o - intval ( $ o ) ) * 60 ) ; $ ofs = "{$os}{$oh}{$om}" ; $ str = str_replace ( '%O' , $ ofs , $ str ) ; } }
4770	public function renderWidget ( string $ widgetGroup = '' , array $ widgetId = [ ] ) { $ widgets = $ this -> widgetBuilder -> build ( $ this -> widgets -> getWidgets ( ) , $ widgetGroup , $ widgetId ) ; return $ this -> engine -> render ( $ widgets ) ; }
6681	public function afterAction ( $ action , $ result ) { $ result = parent :: afterAction ( $ action , $ result ) ; $ this -> setSecurityHeaders ( ) ; if ( extension_loaded ( 'newrelic' ) ) { newrelic_name_transaction ( $ action -> controller -> id . '/' . $ action -> id ) ; } return $ result ; }
10185	static function json_decode ( $ jsonString , $ deserializationType = null ) { if ( is_array ( $ deserializationType ) && count ( $ deserializationType ) > 1 ) { $ type = $ deserializationType [ 0 ] ; $ innerType = $ deserializationType [ 1 ] ; } else { $ type = $ deserializationType ; $ innerType = null ; } return self :: fromArray ( json_decode ( $ jsonString ) , $ type , $ innerType ) ; }
6509	public function createHandlers ( JobInterface $ job , $ level , $ bubble ) { $ handlers = [ ] ; foreach ( $ this -> factories as $ factory ) { $ handlers [ ] = $ factory -> createHandler ( $ job , $ level , $ bubble ) ; } return $ handlers ; }
10072	function fromXML ( $ xmlElement ) { $ this -> id = $ xmlElement -> id ; $ this -> name = $ xmlElement -> name ; $ this -> author = $ xmlElement -> author ; $ this -> state = $ xmlElement -> state ; $ this -> type = $ xmlElement -> type ; $ this -> contactFilterName = $ xmlElement -> contact_filter_name ; $ this -> contactFilterId = $ xmlElement -> contact_filter_id ; $ this -> evaluated = $ xmlElement -> evaluated ; $ this -> created = $ xmlElement -> created ; $ this -> updated = $ xmlElement -> updated ; $ this -> countActiveContacts = $ xmlElement -> count_active_contacts ; $ this -> countContacts = $ xmlElement -> count_contacts ; }
99	public function addPsr4 ( $ prefix , $ paths , $ prepend = false ) { if ( ! $ prefix ) { if ( $ prepend ) { $ this -> fallbackDirsPsr4 = array_merge ( ( array ) $ paths , $ this -> fallbackDirsPsr4 ) ; } else { $ this -> fallbackDirsPsr4 = array_merge ( $ this -> fallbackDirsPsr4 , ( array ) $ paths ) ; } } elseif ( ! isset ( $ this -> prefixDirsPsr4 [ $ prefix ] ) ) { $ length = strlen ( $ prefix ) ; if ( '\\' !== $ prefix [ $ length - 1 ] ) { throw new \ InvalidArgumentException ( "A non-empty PSR-4 prefix must end with a namespace separator." ) ; } $ this -> prefixLengthsPsr4 [ $ prefix [ 0 ] ] [ $ prefix ] = $ length ; $ this -> prefixDirsPsr4 [ $ prefix ] = ( array ) $ paths ; } elseif ( $ prepend ) { $ this -> prefixDirsPsr4 [ $ prefix ] = array_merge ( ( array ) $ paths , $ this -> prefixDirsPsr4 [ $ prefix ] ) ; } else { $ this -> prefixDirsPsr4 [ $ prefix ] = array_merge ( $ this -> prefixDirsPsr4 [ $ prefix ] , ( array ) $ paths ) ; } }
2482	protected function generateQueryString ( array $ parameters ) { $ removedArrayCharacters = preg_replace ( '/%5B[0-9]+%5D=/' , '=' , http_build_query ( $ parameters ) ) ; $ removedDuplicatedEscapingForUrlPath = str_replace ( '%5C%5C%2F' , '%5C%2F' , $ removedArrayCharacters ) ; return $ removedDuplicatedEscapingForUrlPath ; }
7032	public function run ( $ prog = "migrate" ) { switch ( trim ( $ prog ) ) { case "migrate" : return $ this -> migrate ( ) ; case "drop" : return $ this -> drop ( ) ; case "reset" : return $ this -> drop ( ) & $ this -> migrate ( ) ; default : error_log ( "\n\e[1;31m!\e[0m program $prog not applicable\n" ) ; return false ; } }
1348	public function allow ( string $ resourceType , array $ fields = null ) : self { $ this -> all = false ; $ this -> allowed [ $ resourceType ] = $ fields ; return $ this ; }
12802	public function getPage ( $ page = null ) { if ( is_null ( $ page ) ) { $ page = $ this -> page ; } list ( $ offset , $ size ) = $ this -> getLimts ( $ page ) ; $ this -> manager -> limit ( $ offset , $ size ) ; return $ this -> manager -> values ( ) ; }
7688	function OpenXML_Rels_ReplaceTarget ( $ RelsPath , $ OldTarget , $ NewTarget ) { $ idx = $ this -> FileGetIdx ( $ RelsPath ) ; if ( $ idx === false ) $ this -> RaiseError ( "Cannot edit target in '$RelsPath' because the file is not found." ) ; $ txt = $ this -> TbsStoreGet ( $ idx , 'Replace target in rels file' ) ; $ att = 'Target="' . $ OldTarget . '"' ; $ loc = clsTbsXmlLoc :: FindStartTagHavingAtt ( $ txt , $ att , 0 ) ; if ( $ loc ) { if ( $ NewTarget === false ) { $ loc -> Delete ( ) ; } else { $ loc -> ReplaceAtt ( 'Target' , $ NewTarget ) ; } $ this -> TbsStorePut ( $ idx , $ txt ) ; return true ; } else { return false ; } }
3305	public function getFixedFormat ( $ images , array $ options = [ ] ) { $ images = is_array ( $ images ) ? $ images [ 0 ] : $ images ; if ( FileConverter :: isUrl ( $ images ) ) { throw new RuntimeException ( "Aliyun ocr not support online picture." ) ; } if ( $ this -> simpleRequestBody ) { return [ 'image' => FileConverter :: toBase64Encode ( $ images ) , 'configure' => json_encode ( $ options , JSON_UNESCAPED_UNICODE ) ] ; } return [ 'inputs' => [ [ 'image' => [ 'dataType' => 50 , 'dataValue' => FileConverter :: toBase64Encode ( $ images ) ] , 'configure' => [ 'dataType' => 50 , 'dataValue' => json_encode ( $ options , JSON_UNESCAPED_UNICODE ) ] ] ] ] ; }
9322	protected function registerMarkdownEnvironment ( ) { $ app = $ this -> app ; $ app -> singleton ( 'commonmark.environment' , function ( $ app ) { $ config = $ app [ 'config' ] [ 'markdown' ] ; $ environment = Environment :: createCommonMarkEnvironment ( ) ; if ( $ config [ 'configurations' ] ) { $ environment -> mergeConfig ( $ config [ 'configurations' ] ) ; } foreach ( $ config [ 'extensions' ] as $ extension ) { if ( class_exists ( $ extension ) ) { $ environment -> addExtension ( new $ extension ( ) ) ; } } return $ environment ; } ) ; $ app -> alias ( 'commonmark.environment' , Environment :: class ) ; }
7765	private function documentClassProperties ( \ ML \ HydraBundle \ Mapping \ ClassMetadata $ class ) { $ result = array ( ) ; $ propertyDomain = $ this -> getTypeReferenceIri ( $ class -> getName ( ) ) ; foreach ( $ class -> getProperties ( ) as $ property ) { if ( 0 === strncmp ( '@' , $ property -> getExposeAs ( ) , 1 ) ) { continue ; } $ result [ ] = array ( 'property' => ( $ property -> isExternalReference ( ) ) ? $ property -> getIri ( ) : array ( '@id' => 'vocab:' . $ property -> getIri ( ) , '@type' => ( $ property -> getRoute ( ) ) ? 'hydra:Link' : 'rdf:Property' , 'label' => $ property -> getTitle ( ) , 'description' => $ property -> getDescription ( ) , 'domain' => $ propertyDomain , 'range' => $ this -> getTypeReferenceIri ( $ property -> getType ( ) ) , 'supportedOperation' => $ this -> documentOperations ( $ property -> getOperations ( ) ) ) , 'hydra:title' => $ property -> getTitle ( ) , 'hydra:description' => $ property -> getDescription ( ) , 'required' => $ property -> getRequired ( ) , 'readonly' => $ property -> isReadOnly ( ) , 'writeonly' => $ property -> isWriteOnly ( ) ) ; } return $ result ; }
6954	private function getGridForCountry ( CountryInterface $ country ) { if ( isset ( $ this -> grids [ $ country -> getId ( ) ] ) ) { return $ this -> grids [ $ country -> getId ( ) ] ; } $ grid = [ ] ; $ prices = $ this -> priceRepository -> findByCountry ( $ country ) ; foreach ( $ prices as $ price ) { $ method = $ price -> getMethod ( ) ; if ( ! isset ( $ grid [ $ method -> getId ( ) ] ) ) { $ gateway = $ this -> gatewayRegistry -> getGateway ( $ method -> getGatewayName ( ) ) ; $ grid [ $ method -> getId ( ) ] = [ 'method' => $ method , 'max_weight' => $ gateway -> getMaxWeight ( ) , 'prices' => [ ] , ] ; } $ grid [ $ method -> getId ( ) ] [ 'prices' ] [ ] = [ 'weight' => $ price -> getWeight ( ) , 'price' => $ price -> getNetPrice ( ) , ] ; } foreach ( $ grid as & $ method ) { usort ( $ method [ 'prices' ] , function ( $ a , $ b ) { if ( 0 === bccomp ( $ a [ 'weight' ] , $ b [ 'weight' ] , 3 ) ) { return 0 ; } return $ a [ 'weight' ] > $ b [ 'weight' ] ? 1 : - 1 ; } ) ; $ max = end ( $ method [ 'prices' ] ) [ 'weight' ] ; if ( 0 == $ method [ 'max_weight' ] || $ method [ 'max_weight' ] > $ max ) { $ method [ 'max_weight' ] = $ max ; } unset ( $ method ) ; } return $ this -> grids [ $ country -> getId ( ) ] = $ grid ; }
8112	public static function merge_owners ( SS_List $ groups , SS_List $ members ) { $ contentReviewOwners = new ArrayList ( ) ; if ( $ groups -> count ( ) ) { $ groupIDs = [ ] ; foreach ( $ groups as $ group ) { $ familyIDs = $ group -> collateFamilyIDs ( ) ; if ( is_array ( $ familyIDs ) ) { $ groupIDs = array_merge ( $ groupIDs , array_values ( $ familyIDs ) ) ; } } array_unique ( $ groupIDs ) ; if ( count ( $ groupIDs ) ) { $ groupMembers = DataObject :: get ( Member :: class ) -> where ( "\"Group\".\"ID\" IN (" . implode ( "," , $ groupIDs ) . ")" ) -> leftJoin ( "Group_Members" , "\"Member\".\"ID\" = \"Group_Members\".\"MemberID\"" ) -> leftJoin ( 'Group' , "\"Group_Members\".\"GroupID\" = \"Group\".\"ID\"" ) ; $ contentReviewOwners -> merge ( $ groupMembers ) ; } } $ contentReviewOwners -> merge ( $ members ) ; $ contentReviewOwners -> removeDuplicates ( ) ; return $ contentReviewOwners ; }
12770	public function authorize ( RecordInterface & $ user , $ remember = false ) { if ( parent :: authorize ( $ user , $ remember ) ) { if ( $ remember ) { $ token = $ user [ $ this -> dbHashEmailField ] . ( time ( ) + ( $ this -> cookieTime ) ) . $ user [ $ this -> dbHashPasswordField ] ; $ user [ $ this -> dbAccessToken ] = $ token ; $ user -> save ( ) ; $ expiry = time ( ) + ( $ this -> cookieTime ) ; $ cookieData = array ( "token" => $ token , "expiry" => $ expiry ) ; setcookie ( '_cookie_accessToken' , serialize ( $ cookieData ) , $ expiry ) ; } } }
1758	public static function getFormattedNumber ( $ varNumber , $ intDecimals = 2 ) { return number_format ( round ( $ varNumber , $ intDecimals ) , $ intDecimals , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'decimalSeparator' ] , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'thousandsSeparator' ] ) ; }
4152	public function getBearerToken ( ) { $ url = $ this -> getBearerTokenUrl ( ) ; $ params = array ( 'post' => array ( 'grant_type' => 'client_credentials' ) , 'headers' => $ this -> buildBearerTokenHeader ( ) , ) ; $ response = $ this -> curl -> send ( $ url , $ params ) ; $ obj = json_decode ( $ response [ 'body' ] ) ; if ( ! $ obj || ! isset ( $ obj -> token_type ) || $ obj -> token_type != 'bearer' ) { $ this -> findExceptions ( $ response ) ; } $ this -> bearerToken = rawurldecode ( $ obj -> access_token ) ; unset ( $ url , $ params , $ response , $ obj ) ; return $ this -> bearerToken ; }
7408	public function merge ( $ ta ) : self { $ this -> _massageBlockInput ( $ in ) ; $ ret = clone $ this ; foreach ( $ ta as $ k => $ v ) { if ( is_int ( $ k ) ) { $ ret [ ] = $ v ; } else { $ ret [ $ k ] = $ v ; } } return $ ret ; }
730	public function run ( ) { if ( $ this -> checkAccess ) { call_user_func ( $ this -> checkAccess , $ this -> id ) ; } $ model = new $ this -> modelClass ( [ 'scenario' => $ this -> scenario , ] ) ; $ model -> load ( Yii :: $ app -> getRequest ( ) -> getBodyParams ( ) , '' ) ; if ( $ model -> save ( ) ) { $ response = Yii :: $ app -> getResponse ( ) ; $ response -> setStatusCode ( 201 ) ; $ id = implode ( ',' , array_values ( $ model -> getPrimaryKey ( true ) ) ) ; $ response -> getHeaders ( ) -> set ( 'Location' , Url :: toRoute ( [ $ this -> viewAction , 'id' => $ id ] , true ) ) ; } elseif ( ! $ model -> hasErrors ( ) ) { throw new ServerErrorHttpException ( 'Failed to create the object for unknown reason.' ) ; } return $ model ; }
5287	public static function request ( $ method , $ params = null ) { $ url = self :: getUrl ( $ method ) ; $ request_method = self :: getRequestMethodName ( ) ; $ response_body = self :: $ request_method ( $ url , $ params ) ; $ response = json_decode ( $ response_body ) ; if ( ! is_object ( $ response ) ) throw new Error ( "Invalid server response: $response_body" ) ; if ( isset ( $ response -> error ) ) throw new Error ( $ response -> error -> message ) ; return $ response ; }
1510	public function getRelatedUrl ( string $ type , $ id , string $ field , array $ params = [ ] ) : string { return $ this -> url ( [ $ type , $ id , $ field ] , $ params ) ; }
3804	private function buildCondition ( $ condition , $ metaModel ) { if ( null === $ condition ) { return null ; } return $ this -> conditionFactory -> createCondition ( $ condition , $ metaModel ) ; }
9636	public function write ( $ path , $ contents , $ blocking = false ) { $ flockFlags = $ blocking ? LOCK_EX : LOCK_EX | LOCK_NB ; $ file = fopen ( $ path , 'c' ) ; if ( ! flock ( $ file , $ flockFlags ) ) { fclose ( $ file ) ; throw new IOException ( "Could not aquire file lock for file: $path" ) ; } ftruncate ( $ file , 0 ) ; fwrite ( $ file , $ contents ) ; fflush ( $ file ) ; flock ( $ file , LOCK_UN | LOCK_NB ) ; fclose ( $ file ) ; }
12618	public function setFileSource ( $ value ) { if ( isset ( $ this -> module -> sourceFiles [ $ value ] ) ) { $ this -> _fileSource = $ this -> module -> sourceFiles [ $ value ] ; } else { $ this -> _fileSource = false ; } }
10714	public function updateById ( $ id , array $ newAttributes ) { $ model = $ this -> getById ( $ id ) ; $ results = $ model -> update ( $ newAttributes ) ; if ( ! $ results ) { throw new UpdateFailedRepositoryException ( ) ; } return $ model ; }
8101	public function getRow ( $ arguments ) { $ sql = 'SELECT * FROM _table_ WHERE _arguments_ LIMIT 1' ; if ( ! $ stmt = $ this -> getStatement ( $ sql , $ arguments ) ) { return false ; } else { return $ stmt -> fetch ( ) ; } }
6503	public function produce ( Message $ message ) { $ type = $ message -> getType ( ) ; $ body = array ( 'ticket' => $ message -> getTicket ( ) ) ; try { $ this -> logger -> debug ( sprintf ( 'Publish message for job %s to sonata backend' , $ message -> getTicket ( ) ) , [ 'type' => $ type , 'body' => $ body ] ) ; $ queue = $ this -> registry -> get ( $ message -> getType ( ) ) -> getQueue ( ) ; $ this -> backendProvider -> getBackend ( $ queue ) -> createAndPublish ( $ type , $ body ) ; } catch ( \ Exception $ e ) { $ this -> logger -> error ( sprintf ( 'Failed to publish message (Error: %s)' , $ e -> getMessage ( ) ) , [ 'exception' => $ e ] ) ; if ( ! $ e instanceof \ RuntimeException ) { $ e = new \ RuntimeException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } throw $ e ; } }
829	private function isStringPartToken ( Token $ token ) { return $ token -> isGivenKind ( T_ENCAPSED_AND_WHITESPACE ) || $ token -> isGivenKind ( T_START_HEREDOC ) || '"' === $ token -> getContent ( ) || 'b"' === strtolower ( $ token -> getContent ( ) ) ; }
6640	private function getContainerRoute ( array $ routes , $ name ) { foreach ( $ routes as $ route => $ names ) { if ( in_array ( $ name , $ names , false ) ) { return $ route ; } } throw new Exception ( "Unknown configuration class name '{$name}'" ) ; }
11651	public function getProduct ( array $ productData ) { foreach ( $ this -> mandatoryFields as $ mandatoryField ) { if ( ! array_key_exists ( $ mandatoryField , $ productData ) ) { throw new ProductException ( "The field '$mandatoryField' is missing in the given product data" ) ; } } try { $ sku = new SKU ( $ productData [ self :: FIELD_SKU ] ) ; $ slug = new Slug ( $ productData [ self :: FIELD_SLUG ] ) ; $ content = $ this -> contentMapper -> getContent ( $ productData ) ; $ product = new Product ( $ sku , $ slug , $ content ) ; return $ product ; } catch ( \ Exception $ productException ) { throw new ProductException ( sprintf ( "Failed to create a product from the given data: %s" , $ productException -> getMessage ( ) ) , $ productException ) ; } }
8830	protected function getSelectedValue ( $ value , $ selected ) { if ( is_array ( $ selected ) ) { return in_array ( $ value , $ selected , true ) ? 'selected' : null ; } return ( ( string ) $ value == ( string ) $ selected ) ? 'selected' : null ; }
8444	public function matchesRequest ( ) { if ( isset ( $ this -> headers [ 'x-twitter-webhooks-signature' ] ) ) { $ signature = $ this -> headers [ 'x-twitter-webhooks-signature' ] [ 0 ] ; $ hash = hash_hmac ( 'sha256' , json_encode ( $ this -> payload -> all ( ) ) , $ this -> config -> get ( 'consumer_secret' ) , true ) ; return $ signature === 'sha256=' . base64_encode ( $ hash ) ; } return false ; }
12485	public function adapterHasBehavior ( Adapter $ adapter , $ behavior ) { if ( $ adapter instanceof KnowsItsBehaviors ) { return in_array ( $ behavior , $ adapter -> getBehaviors ( ) ) ; } return true === is_a ( $ adapter , $ behavior ) ; }
9774	function satisfy ( callable $ predicate ) : self { return $ this -> expect ( call_user_func ( $ predicate , $ this -> target ) , isTrue ( ) ) ; }
5865	protected function reportAdditionalStorageClaimed ( $ bytes ) { $ legacyFileName = PATH_site . 'typo3conf/.tx_imageautoresize' ; $ fileName = PATH_site . 'typo3temp/.tx_imageautoresize' ; if ( file_exists ( $ legacyFileName ) && ! file_exists ( $ fileName ) ) { @ rename ( $ legacyFileName , $ fileName ) ; } $ data = [ ] ; if ( file_exists ( $ fileName ) ) { $ data = json_decode ( file_get_contents ( $ fileName ) , true ) ; if ( ! is_array ( $ data ) ) { $ data = [ ] ; } } $ data [ 'bytes' ] = $ bytes + ( isset ( $ data [ 'bytes' ] ) ? ( int ) $ data [ 'bytes' ] : 0 ) ; $ data [ 'images' ] = 1 + ( isset ( $ data [ 'images' ] ) ? ( int ) $ data [ 'images' ] : 0 ) ; GeneralUtility :: writeFile ( $ fileName , json_encode ( $ data ) ) ; }
11268	public static function new ( string $ type = 'default' , string $ path = Migrate :: DEFAULT_PATH , $ notify = NotifyInterface :: LOGGER ) : Creator { $ fs = new Filesystem ( new Local ( $ path ) ) ; $ note = NotifyFactory :: create ( $ notify ) ; return new static ( CreatorFactory :: create ( $ type , $ note ) , $ fs , $ note ) ; }
11589	public function matrix ( ) { if ( $ this -> _matrix ) { return $ this -> _matrix ; } $ this -> _matrix = new Matrix ( $ this -> tasks ( ) ) ; $ this -> _matrix -> process ( ) ; return $ this -> _matrix ; }
10104	private function writeWindow2 ( ) { $ record = 0x023E ; $ length = 0x0012 ; $ grbit = 0x00B6 ; $ rwTop = 0x0000 ; $ colLeft = 0x0000 ; $ fDspFmla = 0 ; $ fDspGrid = $ this -> phpSheet -> getShowGridlines ( ) ? 1 : 0 ; $ fDspRwCol = $ this -> phpSheet -> getShowRowColHeaders ( ) ? 1 : 0 ; $ fFrozen = $ this -> phpSheet -> getFreezePane ( ) ? 1 : 0 ; $ fDspZeros = 1 ; $ fDefaultHdr = 1 ; $ fArabic = $ this -> phpSheet -> getRightToLeft ( ) ? 1 : 0 ; $ fDspGuts = $ this -> outlineOn ; $ fFrozenNoSplit = 0 ; $ fSelected = ( $ this -> phpSheet === $ this -> phpSheet -> getParent ( ) -> getActiveSheet ( ) ) ? 1 : 0 ; $ fPaged = 1 ; $ fPageBreakPreview = $ this -> phpSheet -> getSheetView ( ) -> getView ( ) === SheetView :: SHEETVIEW_PAGE_BREAK_PREVIEW ; $ grbit = $ fDspFmla ; $ grbit |= $ fDspGrid << 1 ; $ grbit |= $ fDspRwCol << 2 ; $ grbit |= $ fFrozen << 3 ; $ grbit |= $ fDspZeros << 4 ; $ grbit |= $ fDefaultHdr << 5 ; $ grbit |= $ fArabic << 6 ; $ grbit |= $ fDspGuts << 7 ; $ grbit |= $ fFrozenNoSplit << 8 ; $ grbit |= $ fSelected << 9 ; $ grbit |= $ fPaged << 10 ; $ grbit |= $ fPageBreakPreview << 11 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vvv' , $ grbit , $ rwTop , $ colLeft ) ; $ rgbHdr = 0x0040 ; $ zoom_factor_page_break = ( $ fPageBreakPreview ? $ this -> phpSheet -> getSheetView ( ) -> getZoomScale ( ) : 0x0000 ) ; $ zoom_factor_normal = $ this -> phpSheet -> getSheetView ( ) -> getZoomScaleNormal ( ) ; $ data .= pack ( 'vvvvV' , $ rgbHdr , 0x0000 , $ zoom_factor_page_break , $ zoom_factor_normal , 0x00000000 ) ; $ this -> append ( $ header . $ data ) ; }
3124	protected function fixRange ( $ range , $ lastTimestamp = null ) { $ fixedRange = [ ] ; $ last = null ; $ open = false ; foreach ( $ range as $ point ) { if ( $ this -> isStartPoint ( $ point ) ) { if ( $ last && $ open ) { $ fixedRange [ ] = $ this -> cloneTimePoint ( $ point , TimePoint :: TYPE_END ) ; } $ open = true ; } else if ( $ this -> isEndPoint ( $ point ) ) { if ( ! $ open ) { $ fixedRange [ ] = $ this -> cloneTimePoint ( $ last ? $ last : $ point , TimePoint :: TYPE_START ) ; } $ open = false ; } $ fixedRange [ ] = $ point ; $ last = $ point ; } if ( $ last && $ open ) { $ fixedRange [ ] = $ this -> cloneTimePoint ( $ last , TimePoint :: TYPE_END , $ lastTimestamp ) ; } return $ fixedRange ; }
12709	public static function parse ( string $ word ) : array { $ word = ltrim ( rtrim ( trim ( $ word ) , '}' ) , '{' ) ; if ( $ separatorPosition = strpos ( $ word , '=' ) ) { $ key = substr ( $ word , 0 , $ separatorPosition ) ; $ defaultValue = substr ( $ word , $ separatorPosition + 1 ) ; return [ $ key , $ defaultValue ] ; } return [ $ word , null ] ; }
3953	public function get ( $ strAttributeName ) { return array_key_exists ( $ strAttributeName , $ this -> arrData ) ? $ this -> arrData [ $ strAttributeName ] : null ; }
12950	public function beforeDelete ( ) { $ this -> _tagsForDelete = [ ] ; $ relation = $ this -> owner -> getRelation ( 'tagsList' , false ) ; if ( $ relation instanceof ActiveQuery ) { $ this -> _tagsForDelete = ( new Query ( ) ) -> select ( current ( $ relation -> link ) ) -> from ( $ relation -> via -> from [ 0 ] ) -> where ( [ key ( $ relation -> via -> link ) => $ this -> owner -> getPrimaryKey ( ) ] ) -> column ( $ this -> owner -> getDb ( ) ) ; } }
12217	private function register ( ) { ini_set ( 'display_errors' , false ) ; if ( $ this -> displayErrors ) { ini_set ( 'display_errors' , true ) ; } register_shutdown_function ( [ $ this , 'shutdownHandler' ] ) ; set_error_handler ( [ $ this , 'errorHandler' ] ) ; set_exception_handler ( [ $ this , 'exceptionHandler' ] ) ; }
7427	public function renderEmbed ( ) { if ( ! $ this -> isValid ( $ this -> source ) ) { throw new InvalidSourceExtensionException ( ) ; } return sprintf ( $ this -> embedDecorator , $ this -> width , $ this -> height , $ this -> source ) ; }
10351	public function channel ( string $ channel_id ) : EventChannelInterface { if ( isset ( $ this -> channel_adapters [ $ channel_id ] ) ) { return $ this -> channel_adapters [ $ channel_id ] ; } $ adapter = new Stk2kEventChannelAdapter ( $ this -> eventstream -> channel ( $ channel_id , function ( ) { return new SimpleEventSource ( ) ; } , function ( ) { return new WildCardEventEmitter ( ) ; } ) ) ; $ this -> channel_adapters [ $ channel_id ] = $ adapter ; return $ adapter ; }
3571	public function queryHook ( ) { return function ( $ next , $ query , $ bag ) { $ method = $ bag -> get ( 'method' ) ; $ args = $ bag -> get ( 'args' ) ; $ column = $ args -> get ( 'column' ) ; if ( ! $ this -> hasColumn ( $ column ) && $ this -> allowsMeta ( $ column ) && $ this -> isMetaQueryable ( $ method ) ) { return call_user_func_array ( [ $ this , 'metaQuery' ] , [ $ query , $ method , $ args ] ) ; } if ( in_array ( $ method , [ 'select' , 'addSelect' ] ) ) { call_user_func_array ( [ $ this , 'metaSelect' ] , [ $ query , $ args ] ) ; } return $ next ( $ query , $ bag ) ; } ; }
10541	public function getFiltroConfiguration ( $ filtroName ) { if ( ! isset ( $ this -> config [ 'filtros' ] [ $ filtroName ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Filtro "%s" is not managed.' , $ filtroName ) ) ; } return $ this -> config [ 'filtros' ] [ $ filtroName ] ; }
1036	private function completeAbstractValue ( AbstractType $ returnType , $ fieldNodes , ResolveInfo $ info , $ path , & $ result ) { $ exeContext = $ this -> exeContext ; $ runtimeType = $ returnType -> resolveType ( $ result , $ exeContext -> contextValue , $ info ) ; if ( $ runtimeType === null ) { $ runtimeType = self :: defaultTypeResolver ( $ result , $ exeContext -> contextValue , $ info , $ returnType ) ; } $ promise = $ this -> getPromise ( $ runtimeType ) ; if ( $ promise ) { return $ promise -> then ( function ( $ resolvedRuntimeType ) use ( $ returnType , $ fieldNodes , $ info , $ path , & $ result ) { return $ this -> completeObjectValue ( $ this -> ensureValidRuntimeType ( $ resolvedRuntimeType , $ returnType , $ info , $ result ) , $ fieldNodes , $ info , $ path , $ result ) ; } ) ; } return $ this -> completeObjectValue ( $ this -> ensureValidRuntimeType ( $ runtimeType , $ returnType , $ info , $ result ) , $ fieldNodes , $ info , $ path , $ result ) ; }
2989	public function setLogger ( LoggerInterface $ logger ) { if ( $ this -> transport instanceof LoggerAwareInterface ) { $ this -> transport -> setLogger ( $ logger ) ; } }
11127	protected function renderView ( $ view , $ data ) { try { return parent :: renderView ( $ view , $ data ) ; } catch ( \ InvalidArgumentException $ e ) { return static :: applyDataToView ( $ view , $ data ) ; } }
3936	private function setWidgetType ( PropertyInterface $ property , $ propInfo ) { if ( null !== $ property -> getWidgetType ( ) || ! isset ( $ propInfo [ 'inputType' ] ) ) { return ; } $ property -> setWidgetType ( $ propInfo [ 'inputType' ] ) ; }
2923	public function lines ( ) { $ content = [ ] ; $ lines = $ this -> readLinesFromFile ( ) ; foreach ( $ lines as $ row => $ line ) { $ data = [ 'line' => $ row + 1 , 'raw_data' => $ line , 'parsed_data' => $ this -> formatter -> parseLine ( $ line ) ] ; $ content [ ] = $ data ; } return $ content ; }
5060	public static function fromURI ( $ URI ) { $ regex = '/^(([^-]|--)+)-(([^-]|--)+)-(([^-]|--)+)\.(svg|png|gif|jpg)$/' ; $ match = array ( ) ; if ( 1 != preg_match ( $ regex , $ URI , $ match ) && ( 7 != count ( $ match ) ) ) { throw new \ InvalidArgumentException ( 'The URI given is not a valid URI' . $ URI ) ; } $ subject = $ match [ 1 ] ; $ status = $ match [ 3 ] ; $ color = $ match [ 5 ] ; $ format = $ match [ 7 ] ; return new self ( $ subject , $ status , $ color , $ format ) ; }
206	public static function stdin ( $ raw = false ) { return $ raw ? fgets ( \ STDIN ) : rtrim ( fgets ( \ STDIN ) , PHP_EOL ) ; }
8142	public function clearCacheFiles ( ) { @ trigger_error ( sprintf ( 'The %s method is deprecated since version 1.22 and will be removed in Twig 2.0.' , __METHOD__ ) , E_USER_DEPRECATED ) ; if ( is_string ( $ this -> originalCache ) ) { foreach ( new RecursiveIteratorIterator ( new RecursiveDirectoryIterator ( $ this -> originalCache ) , RecursiveIteratorIterator :: LEAVES_ONLY ) as $ file ) { if ( $ file -> isFile ( ) ) { @ unlink ( $ file -> getPathname ( ) ) ; } } } }
4297	public function clear ( $ flags = self :: CLEAR_LOG ) { array ( $ flags ) ; $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) , array ( 'flags' => self :: CLEAR_LOG ) , array ( 'flags' => 'bitmask' ) ) ; $ event = $ this -> methodClear -> onLog ( new Event ( $ this , array ( 'method' => __FUNCTION__ , 'args' => array ( ) , 'meta' => $ meta , ) ) ) ; $ this -> setLogDest ( 'log' ) ; $ collect = $ this -> cfg [ 'collect' ] ; $ this -> cfg [ 'collect' ] = true ; if ( $ event [ 'log' ] ) { $ this -> appendLog ( $ event [ 'method' ] , $ event [ 'args' ] , $ event [ 'meta' ] ) ; } elseif ( $ event [ 'publish' ] ) { $ this -> internal -> publishBubbleEvent ( 'debug.log' , $ event ) ; } $ this -> cfg [ 'collect' ] = $ collect ; $ this -> setLogDest ( 'auto' ) ; }
11169	public static function boot ( ) { parent :: boot ( ) ; static :: addGlobalScope ( 'type' , function ( $ query ) { return $ query -> when ( static :: class !== StripeObject :: class , function ( $ query ) { $ query -> where ( 'type' , class_basename ( ( new static ( ) ) -> objectClass ) ) ; } ) ; } ) ; static :: created ( function ( StripeObject $ object ) { if ( $ object -> relatesWith ) { list ( $ related , $ tag ) = $ object -> relatesWith ; $ object -> relations ( get_class ( $ related ) ) -> attach ( $ related -> id , [ 'tag' => $ tag ] ) ; } } ) ; }
6785	public function buildFormDataString ( $ options ) { $ options = $ this -> resolve ( $ options ) ; $ formOptions = [ ] ; foreach ( $ this -> formParameters as $ key => $ isFormParameter ) { if ( $ isFormParameter && isset ( $ options [ $ key ] ) ) { $ formOptions [ $ key ] = $ options [ $ key ] ; } } return http_build_query ( $ formOptions ) ; }
7559	function select ( $ query = '*' , $ index = false , $ recursive = true , $ check_self = false ) { $ s = new $ this -> selectClass ( $ this , $ query , $ check_self , $ recursive ) ; $ res = $ s -> result ; unset ( $ s ) ; if ( is_array ( $ res ) && ( $ index === true ) && ( count ( $ res ) === 1 ) ) { return $ res [ 0 ] ; } elseif ( is_int ( $ index ) && is_array ( $ res ) ) { if ( $ index < 0 ) { $ index += count ( $ res ) ; } return ( $ index < count ( $ res ) ) ? $ res [ $ index ] : null ; } else { return $ res ; } }
2468	public function getOptions ( ) : array { $ options = [ ] ; foreach ( self :: DEFAULT_OPTIONS as $ option => $ label ) { $ options [ $ option ] = $ this -> translator -> trans ( 'MSC.validCharacters.' . $ label , [ ] , 'contao_default' ) ; } $ event = new SlugValidCharactersEvent ( $ options ) ; $ this -> eventDispatcher -> dispatch ( ContaoCoreEvents :: SLUG_VALID_CHARACTERS , $ event ) ; return $ event -> getOptions ( ) ; }
6936	private function findBySubjectAndStates ( StockSubjectInterface $ subject , array $ states = [ ] ) { $ units = [ ] ; $ oid = spl_object_hash ( $ subject ) ; if ( isset ( $ this -> addedUnits [ $ oid ] ) ) { $ units = $ this -> addedUnits [ $ oid ] ; } if ( ! empty ( $ units ) && ! empty ( $ states ) ) { $ units = array_filter ( $ units , function ( StockUnitInterface $ unit ) use ( $ states ) { return in_array ( $ unit -> getState ( ) , $ states ) ; } ) ; } return $ units ; }
8301	public function handleAccountPage ( Request $ httpRequest ) { if ( ! $ this -> config [ "enabled" ] ) { return ; } $ user = $ this -> picoAuth -> getUser ( ) ; $ this -> picoAuth -> addAllowed ( "account" ) ; $ this -> picoAuth -> setRequestFile ( $ this -> picoAuth -> getPluginPath ( ) . '/content/account.md' ) ; $ post = $ httpRequest -> request ; if ( $ post -> has ( "new_password" ) && $ post -> has ( "new_password_repeat" ) && $ post -> has ( "old_password" ) ) { $ newPassword = new Password ( $ post -> get ( "new_password" ) ) ; $ newPasswordRepeat = new Password ( $ post -> get ( "new_password_repeat" ) ) ; $ oldPassword = new Password ( $ post -> get ( "old_password" ) ) ; $ username = $ user -> getId ( ) ; if ( ! $ this -> picoAuth -> isValidCSRF ( $ post -> get ( "csrf_token" ) ) ) { $ this -> picoAuth -> redirectToPage ( "account" ) ; } if ( $ newPassword -> get ( ) !== $ newPasswordRepeat -> get ( ) ) { $ this -> session -> addFlash ( "error" , "The passwords do not match." ) ; $ this -> picoAuth -> redirectToPage ( "account" ) ; } $ localAuth = $ this -> picoAuth -> getContainer ( ) -> get ( 'LocalAuth' ) ; if ( ! $ localAuth -> loginAttempt ( $ username , $ oldPassword ) ) { $ this -> session -> addFlash ( "error" , "The current password is incorrect" ) ; $ this -> picoAuth -> redirectToPage ( "account" ) ; } if ( ! $ localAuth -> checkPasswordPolicy ( $ newPassword ) ) { $ this -> picoAuth -> redirectToPage ( "account" ) ; } $ userData = $ this -> storage -> getUserByName ( $ username ) ; $ localAuth -> userDataEncodePassword ( $ userData , $ newPassword ) ; $ this -> storage -> saveUser ( $ username , $ userData ) ; $ this -> session -> addFlash ( "success" , "Password changed successfully." ) ; $ this -> picoAuth -> redirectToPage ( "account" ) ; } }
12764	public function add ( string $ header ) : self { foreach ( $ this -> getAll ( ) as $ tmp ) { if ( $ tmp === $ header ) { throw new Exception ( "The '{$header}' header has already been added." ) ; } } $ this -> headerList [ ] = $ header ; return self :: $ instance ; }
7717	function FileGetState ( $ NameOrIdx ) { $ idx = $ this -> FileGetIdx ( $ NameOrIdx ) ; if ( $ idx === false ) { $ idx = $ this -> FileGetIdxAdd ( $ NameOrIdx ) ; if ( $ idx === false ) { return false ; } else { return 'a' ; } } elseif ( isset ( $ this -> ReplInfo [ $ idx ] ) ) { if ( $ this -> ReplInfo [ $ idx ] === false ) { return 'd' ; } else { return 'm' ; } } else { return 'u' ; } }
10814	protected function _setDataStore ( $ dataStore ) { if ( ! is_null ( $ dataStore ) ) { $ dataStore = $ this -> _normalizeContainer ( $ dataStore ) ; } $ this -> dataStore = $ dataStore ; }
748	protected function buildCompleteString ( $ format ) { $ placeholderValues = [ '{type}' => $ this -> type , '{length}' => $ this -> buildLengthString ( ) , '{unsigned}' => $ this -> buildUnsignedString ( ) , '{notnull}' => $ this -> buildNotNullString ( ) , '{unique}' => $ this -> buildUniqueString ( ) , '{default}' => $ this -> buildDefaultString ( ) , '{check}' => $ this -> buildCheckString ( ) , '{comment}' => $ this -> buildCommentString ( ) , '{pos}' => $ this -> isFirst ? $ this -> buildFirstString ( ) : $ this -> buildAfterString ( ) , '{append}' => $ this -> buildAppendString ( ) , ] ; return strtr ( $ format , $ placeholderValues ) ; }
6996	public static function parseApplePriceMatrixAll ( $ file , $ directory = null ) { $ dom = new \ DOMDocument ( ) ; $ dom -> loadHTMLFile ( $ file ) ; $ xpath = new \ DOMXPath ( $ dom ) ; $ currencies = array ( ) ; $ currencyElements = $ xpath -> query ( '//table[1]//tr[2]//td[position() > 1]' ) ; foreach ( $ currencyElements as $ currencyElement ) { $ currency = trim ( $ currencyElement -> textContent ) ; if ( 'Euro' == $ currency ) { $ currency = 'EUR' ; } $ currencies [ ] = $ currency ; } if ( ! count ( $ currencies ) ) { throw new \ RuntimeException ( sprintf ( 'Not found currencies in ApplePriceMatrix in file "%s".' , $ file ) ) ; } $ currencies = array_flip ( $ currencies ) ; foreach ( $ currencies as $ currency => $ null ) { $ currencies [ $ currency ] = static :: parseApplePriceMatrix ( $ dom , $ currency , $ directory ) ; } return $ currencies ; }
10154	private function readPageSetup ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; if ( ! $ this -> readDataOnly ) { $ paperSize = self :: getUInt2d ( $ recordData , 0 ) ; $ scale = self :: getUInt2d ( $ recordData , 2 ) ; $ fitToWidth = self :: getUInt2d ( $ recordData , 6 ) ; $ fitToHeight = self :: getUInt2d ( $ recordData , 8 ) ; $ isPortrait = ( 0x0002 & self :: getUInt2d ( $ recordData , 10 ) ) >> 1 ; $ isNotInit = ( 0x0004 & self :: getUInt2d ( $ recordData , 10 ) ) >> 2 ; if ( ! $ isNotInit ) { $ this -> phpSheet -> getPageSetup ( ) -> setPaperSize ( $ paperSize ) ; switch ( $ isPortrait ) { case 0 : $ this -> phpSheet -> getPageSetup ( ) -> setOrientation ( PageSetup :: ORIENTATION_LANDSCAPE ) ; break ; case 1 : $ this -> phpSheet -> getPageSetup ( ) -> setOrientation ( PageSetup :: ORIENTATION_PORTRAIT ) ; break ; } $ this -> phpSheet -> getPageSetup ( ) -> setScale ( $ scale , false ) ; $ this -> phpSheet -> getPageSetup ( ) -> setFitToPage ( ( bool ) $ this -> isFitToPages ) ; $ this -> phpSheet -> getPageSetup ( ) -> setFitToWidth ( $ fitToWidth , false ) ; $ this -> phpSheet -> getPageSetup ( ) -> setFitToHeight ( $ fitToHeight , false ) ; } $ marginHeader = self :: extractNumber ( substr ( $ recordData , 16 , 8 ) ) ; $ this -> phpSheet -> getPageMargins ( ) -> setHeader ( $ marginHeader ) ; $ marginFooter = self :: extractNumber ( substr ( $ recordData , 24 , 8 ) ) ; $ this -> phpSheet -> getPageMargins ( ) -> setFooter ( $ marginFooter ) ; } }
4850	public function prepare ( $ value ) { $ importer = $ this -> getVariably ( ) -> get ( 'importer' ) ; $ table = $ importer -> getCurrentTable ( ) ; if ( ! isset ( $ this -> counter [ $ table ] ) ) { $ db = $ importer -> getDb ( ) ; $ counter = $ db -> fetchOne ( 'SELECT MAX(DISTINCT counter) AS counter FROM ' . $ table ) ; $ this -> counter [ $ table ] = $ counter [ 'counter' ] + 1 ; } return $ this -> counter [ $ table ] ; }
1794	private function getAutoItems ( array $ parameters ) : array { if ( isset ( $ parameters [ 'auto_item' ] ) ) { return [ $ parameters [ 'auto_item' ] ] ; } if ( isset ( $ GLOBALS [ 'TL_AUTO_ITEM' ] ) && \ is_array ( $ GLOBALS [ 'TL_AUTO_ITEM' ] ) ) { return $ GLOBALS [ 'TL_AUTO_ITEM' ] ; } return [ ] ; }
12014	public static function execute ( ConnectionInterface $ connection , $ forceSimpleUrl = false ) { $ url = $ connection -> host . '/' . $ connection -> accountId . '/' . $ connection -> db . '' . $ connection -> action . ( isset ( $ connection -> transactionId ) ? '?transaction_id=' . $ connection -> transactionId : '' ) ; if ( $ forceSimpleUrl ) { $ url = $ connection -> host . '/' . $ connection -> accountId ; } if ( $ connection -> debug === true ) { echo "URL: " . $ url . "\r\n" ; echo "USER:PWD: " . $ connection -> username . ":" . str_repeat ( 'X' , strlen ( $ connection -> password ) ) . "\r\n" ; echo "METHOD: " . $ connection -> method . "\r\n" ; echo "QUERY: " . ( isset ( $ connection -> query ) ? $ connection -> query : null ) . "\r\n" ; } $ curl = curl_init ( ) ; curl_setopt ( $ curl , CURLOPT_URL , $ url ) ; curl_setopt ( $ curl , CURLOPT_USERPWD , $ connection -> username . ":" . $ connection -> password ) ; curl_setopt ( $ curl , CURLOPT_CUSTOMREQUEST , $ connection -> method ) ; curl_setopt ( $ curl , CURLOPT_POSTFIELDS , isset ( $ connection -> query ) ? $ connection -> query : null ) ; curl_setopt ( $ curl , CURLOPT_HTTPHEADER , array ( 'Content-Type: text/plain' ) ) ; curl_setopt ( $ curl , CURLOPT_RETURNTRANSFER , true ) ; curl_setopt ( $ curl , CURLOPT_SSL_VERIFYPEER , 0 ) ; curl_setopt ( $ curl , CURLOPT_SSL_VERIFYHOST , 0 ) ; $ curlResponse = curl_exec ( $ curl ) ; if ( $ connection -> debug === true ) { if ( curl_error ( $ curl ) ) { echo "cURL error: " . curl_error ( $ curl ) . "\r\n" ; } echo "RESPONSE: " . $ curlResponse . "\r\n\r\n" ; } curl_close ( $ curl ) ; return ( $ connection -> query === 'BEGIN_TRANSACTION' ) ? json_decode ( $ curlResponse ) -> transaction_id : ( ( isset ( $ connection -> multiple ) && $ connection -> multiple ) ? new Batch ( $ curlResponse , $ connection ) : new Single ( $ curlResponse , $ connection ) ) ; }
11346	public function renderFields ( ) { $ html = '' ; foreach ( $ this -> fields as $ field ) { $ html .= $ this -> formatter -> renderField ( $ field ) ; } return $ html ; }
652	public function execute ( ) { $ sql = $ this -> getSql ( ) ; list ( $ profile , $ rawSql ) = $ this -> logQuery ( __METHOD__ ) ; if ( $ sql == '' ) { return 0 ; } $ this -> prepare ( false ) ; try { $ profile and Yii :: beginProfile ( $ rawSql , __METHOD__ ) ; $ this -> internalExecute ( $ rawSql ) ; $ n = $ this -> pdoStatement -> rowCount ( ) ; $ profile and Yii :: endProfile ( $ rawSql , __METHOD__ ) ; $ this -> refreshTableSchema ( ) ; return $ n ; } catch ( Exception $ e ) { $ profile and Yii :: endProfile ( $ rawSql , __METHOD__ ) ; throw $ e ; } }
9407	protected function callback ( $ middleware , ResponseInterface $ response ) { $ middleware = is_string ( $ middleware ) ? new $ middleware : $ middleware ; $ callback = function ( $ request , $ next = null ) use ( $ middleware ) { return $ middleware ( $ request , $ next ) ; } ; if ( $ this -> approach ( $ middleware ) == self :: SINGLE_PASS ) { $ callback = function ( $ request , $ next = null ) use ( $ middleware , $ response ) { return $ middleware ( $ request , $ response , $ next ) ; } ; } return $ callback ; }
11032	protected function supports ( $ attribute , $ subject ) { if ( ! in_array ( $ attribute , array ( self :: MENU , self :: PERMISO ) ) ) { return false ; } if ( $ attribute == self :: MENU && ! is_null ( $ subject ) && ! $ subject instanceof Menu ) { return false ; } return true ; }
2921	public function save ( $ filePath ) { $ this -> ensureFileIsWritable ( $ filePath ) ; file_put_contents ( $ filePath , $ this -> buffer ) ; return $ this ; }
6536	protected function retrieve ( ) { if ( false === $ this -> retrieved ) { $ this -> updatedDatas = $ this -> getArray ( ) ; $ this -> retrieved = true ; } }
3295	protected function getFingers ( Lead $ lead ) { $ fingers = [ ] ; if ( $ lead -> getEmail ( ) ) { $ fingers [ 'email' ] = strtolower ( $ lead -> getEmail ( ) ) ; } if ( $ lead -> getPhone ( ) ) { $ fingers [ 'phone' ] = preg_replace ( '/\D/' , '' , $ lead -> getPhone ( ) ) ; } if ( $ lead -> getMobile ( ) ) { $ fingers [ 'mobile' ] = preg_replace ( '/\D/' , '' , $ lead -> getMobile ( ) ) ; } return $ fingers ; }
1754	public static function getLanguages ( $ blnInstalledOnly = false ) { $ return = array ( ) ; $ languages = array ( ) ; $ arrAux = array ( ) ; $ langsNative = array ( ) ; static :: loadLanguageFile ( 'languages' ) ; include __DIR__ . '/../../config/languages.php' ; foreach ( $ languages as $ strKey => $ strName ) { $ arrAux [ $ strKey ] = isset ( $ GLOBALS [ 'TL_LANG' ] [ 'LNG' ] [ $ strKey ] ) ? Utf8 :: toAscii ( $ GLOBALS [ 'TL_LANG' ] [ 'LNG' ] [ $ strKey ] ) : $ strName ; } asort ( $ arrAux ) ; $ arrBackendLanguages = self :: getContainer ( ) -> getParameter ( 'contao.locales' ) ; foreach ( array_keys ( $ arrAux ) as $ strKey ) { if ( $ blnInstalledOnly && ! \ in_array ( $ strKey , $ arrBackendLanguages ) ) { continue ; } $ return [ $ strKey ] = $ GLOBALS [ 'TL_LANG' ] [ 'LNG' ] [ $ strKey ] ?? $ languages [ $ strKey ] ; if ( isset ( $ langsNative [ $ strKey ] ) && $ langsNative [ $ strKey ] != $ return [ $ strKey ] ) { $ return [ $ strKey ] .= ' - ' . $ langsNative [ $ strKey ] ; } } if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getLanguages' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getLanguages' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getLanguages' ] as $ callback ) { static :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ return , $ languages , $ langsNative , $ blnInstalledOnly ) ; } } return $ return ; }
580	public static function current ( array $ params = [ ] , $ scheme = false ) { $ currentParams = Yii :: $ app -> getRequest ( ) -> getQueryParams ( ) ; $ currentParams [ 0 ] = '/' . Yii :: $ app -> controller -> getRoute ( ) ; $ route = array_replace_recursive ( $ currentParams , $ params ) ; return static :: toRoute ( $ route , $ scheme ) ; }
126	protected function createRemoveRule ( PackageInterface $ package , $ reason , $ job ) { return new GenericRule ( array ( - $ package -> id ) , $ reason , $ job [ 'packageName' ] , $ job ) ; }
10672	private static function addSegmentsToPath ( $ path , $ segments ) { $ segments = Arr :: toArray ( $ segments ) ; if ( count ( $ segments ) > 0 ) { $ path .= '/' . implode ( '/' , $ segments ) ; } return $ path ; }
5328	public function getCpuinfoByLsCpu ( ) { if ( ! $ this -> cpuInfoByLsCpu ) { $ lscpu = shell_exec ( 'lscpu' ) ; $ lscpu = explode ( "\n" , $ lscpu ) ; $ values = [ ] ; foreach ( $ lscpu as $ v ) { $ v = array_map ( 'trim' , explode ( ':' , $ v ) ) ; if ( isset ( $ v [ 0 ] , $ v [ 1 ] ) ) { $ values [ $ v [ 0 ] ] = $ v [ 1 ] ; } } $ this -> cpuInfoByLsCpu = $ values ; } return $ this -> cpuInfoByLsCpu ; }
3214	function disableAccessToken ( ) { $ response = $ this -> doPost ( $ this -> apiHost , "1/disable_access_token" ) ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; }
12876	private function setNamespace ( $ serviceName = null ) { if ( $ serviceName === null ) { $ this -> storage -> getOptions ( ) -> setNamespace ( $ this -> defaultNamespace ) ; } else { $ this -> storage -> getOptions ( ) -> setNamespace ( $ serviceName ) ; } }
746	protected function buildDefaultString ( ) { if ( $ this -> default === null ) { return $ this -> isNotNull === false ? ' DEFAULT NULL' : '' ; } $ string = ' DEFAULT ' ; switch ( gettype ( $ this -> default ) ) { case 'integer' : $ string .= ( string ) $ this -> default ; break ; case 'double' : $ string .= StringHelper :: floatToString ( $ this -> default ) ; break ; case 'boolean' : $ string .= $ this -> default ? 'TRUE' : 'FALSE' ; break ; case 'object' : $ string .= ( string ) $ this -> default ; break ; default : $ string .= "'{$this->default}'" ; } return $ string ; }
10838	protected function setRaw ( $ Key , $ Val , $ expire = 0 ) { $ CacheFile = $ this -> getCacheFile ( $ Key ) ; return file_put_contents ( $ CacheFile , serialize ( $ Val ) ) > 0 ; }
8884	private function buildPackages ( $ number , $ weight , $ measurement = 'LBS' ) { $ packages = array ( ) ; if ( $ number > 1 ) { $ individual_weight = $ weight / $ number ; for ( $ i = 0 ; $ i < $ number ; $ i ++ ) { $ packages [ ] = '<Package> <PackagingType> <Code>02</Code> </PackagingType> <PackageWeight> <UnitOfMeasurement> <Code>' . $ measurement . '</Code> </UnitOfMeasurement> <Weight>' . $ individual_weight . '</Weight> </PackageWeight> </Package>' ; } } else { $ packages [ ] = '<Package> <PackagingType> <Code>02</Code> </PackagingType> <PackageWeight> <UnitOfMeasurement> <Code>' . $ measurement . '</Code> </UnitOfMeasurement> <Weight>' . $ weight . '</Weight> </PackageWeight> </Package>' ; } return implode ( '' , $ packages ) ; }
10819	public static function comment ( $ messages , $ linebreak = true , $ length = 0 ) { $ separator = $ linebreak ? "\n" : '' ; self :: write ( $ messages , 'comment' , $ length , $ separator ) ; }
1111	public function map ( $ nodeList ) { $ self = $ this ; return $ this -> wrapInTransaction ( function ( ) use ( $ self , $ nodeList ) { forward_static_call ( array ( get_class ( $ self -> node ) , 'unguard' ) ) ; $ result = $ self -> mapTree ( $ nodeList ) ; forward_static_call ( array ( get_class ( $ self -> node ) , 'reguard' ) ) ; return $ result ; } ) ; }
6775	protected function updateKey ( SaleInterface $ sale ) { if ( 0 == strlen ( $ sale -> getKey ( ) ) ) { $ this -> keyGenerator -> generate ( $ sale ) ; return true ; } return false ; }
10607	public function checkLoggedInAction ( ) { $ data = array ( 'logged' => 0 , 'data' => null ) ; if ( ! $ this -> zfcUserAuthentication ( ) -> hasIdentity ( ) ) { return new JsonModel ( $ data ) ; } $ identity = $ this -> zfcUserAuthentication ( ) -> getIdentity ( ) ; $ data [ 'logged' ] = 1 ; $ userModel = $ this -> getServiceLocator ( ) -> get ( 'user.model.user' ) ; $ data [ 'data' ] = $ userModel -> init ( $ identity , $ this -> getServiceLocator ( ) ) ; return new JsonModel ( $ data ) ; }
10851	public function executeProcess ( $ command , $ beforeNotice = false , $ afterNotice = false ) : void { $ this -> echo ( 'info' , $ beforeNotice ? ' ' . $ beforeNotice : $ command ) ; $ process = new Process ( $ command , null , null , null , $ this -> option ( 'timeout' ) , null ) ; $ process -> run ( function ( $ type , $ buffer ) { if ( Process :: ERR === $ type ) { $ this -> echo ( 'comment' , $ buffer ) ; } else { $ this -> echo ( 'line' , $ buffer ) ; } } ) ; if ( ! $ process -> isSuccessful ( ) ) { throw new ProcessFailedException ( $ process ) ; } if ( $ this -> progressBar ) { $ this -> progressBar -> advance ( ) ; } if ( $ afterNotice ) { $ this -> echo ( 'info' , $ afterNotice ) ; } }
5834	protected function setCode ( $ code ) { $ this -> code = $ code ; $ this -> statusText = $ code ; list ( $ this -> statusCode , ) = explode ( ' ' , $ code ) ; }
4753	private function getContactFormMethod ( ) { $ method = self :: CONTACT_FORM_METHOD_DEFAULT ; if ( $ configMethod = \ OxidEsales \ Eshop \ Core \ Registry :: getConfig ( ) -> getConfigParam ( 'OeGdprOptinContactFormMethod' ) ) { $ method = $ configMethod ; } return $ method ; }
6581	public function translate ( $ shift , $ y = null , $ z = null ) { if ( $ shift instanceof self ) return new static ( $ this -> gps [ 'x' ] + $ shift -> gps [ 'x' ] , $ this -> gps [ 'y' ] + $ shift -> gps [ 'y' ] , $ this -> gps [ 'z' ] + $ shift -> gps [ 'z' ] ) ; else return new static ( $ this -> gps [ 'x' ] + $ shift , $ this -> gps [ 'y' ] + $ y , $ this -> gps [ 'z' ] + $ z ) ; }
5741	protected static function prefixData ( $ data ) { $ prefixedData = array ( ) ; foreach ( $ data as $ stat => $ value ) { $ prefixedKey = self :: prefix ( $ stat ) ; $ prefixedData [ $ prefixedKey ] = $ value ; } return $ prefixedData ; }
1227	private function parseJson ( array $ token ) { $ value = json_decode ( $ token [ 'value' ] , true ) ; if ( $ error = json_last_error ( ) ) { $ value = json_decode ( '"' . $ token [ 'value' ] . '"' , true ) ; if ( $ error = json_last_error ( ) ) { $ token [ 'type' ] = self :: T_UNKNOWN ; return $ token ; } } $ token [ 'value' ] = $ value ; return $ token ; }
12018	protected function setup ( \ AMQPQueue $ queue ) { $ queue -> declareQueue ( ) ; foreach ( $ this -> binds as $ exchange => $ params ) { $ queue -> bind ( $ exchange , $ params [ 'routing_key' ] , $ params [ 'arguments' ] ) ; } }
7709	function GetInnerSrc ( ) { return ( $ this -> pET_PosBeg === false ) ? false : substr ( $ this -> Txt , $ this -> pST_PosEnd + 1 , $ this -> pET_PosBeg - $ this -> pST_PosEnd - 1 ) ; }
5814	public function validate ( ) { $ result = parent :: validate ( ) ; $ this -> Title = strtolower ( $ this -> Title ) ; if ( $ result -> valid ( ) && ! $ this -> Title ) { $ result -> error ( '"Title" required!' ) ; } else if ( $ result -> valid ( ) && FusionTag :: get_one ( 'FusionTag' , array ( 'ID != ?' => $ this -> ID , 'Title = ?' => $ this -> Title ) ) ) { $ result -> error ( 'Tag already exists!' ) ; } $ this -> extend ( 'validateFusionTag' , $ result ) ; return $ result ; }
9333	public function scaffoldFormField ( $ title = null , $ params = null ) { return FontIconField :: create ( $ this -> name , $ title ) ; }
11509	protected function parseMessageFromRequest ( $ content ) { $ content = strval ( $ content ) ; $ dataSet = json_decode ( $ content , true ) ; if ( $ dataSet && ( JSON_ERROR_NONE === json_last_error ( ) ) ) { $ content = XML :: build ( $ dataSet ) ; } if ( $ this -> isSafeMode ( ) ) { if ( ! $ this -> encryptor ) { throw new RuntimeException ( 'Safe mode Encryptor is necessary, please use Guard::setEncryptor(Encryptor $encryptor) set the encryptor instance.' ) ; } $ message = $ this -> encryptor -> decryptMsg ( $ this -> request -> get ( 'msg_signature' ) , $ this -> request -> get ( 'nonce' ) , $ this -> request -> get ( 'timestamp' ) , $ content ) ; } else { $ message = XML :: parse ( $ content ) ; } return $ message ; }
2472	public function findSingle ( Criterion $ filter , array $ languageFilter = array ( ) ) { $ query = new Query ( ) ; $ query -> filter = $ filter ; $ query -> query = new Criterion \ MatchAll ( ) ; $ query -> offset = 0 ; $ query -> limit = 1 ; $ this -> coreFilter -> apply ( $ query , $ languageFilter , DocumentMapper :: DOCUMENT_TYPE_IDENTIFIER_CONTENT ) ; $ result = $ this -> resultExtractor -> extract ( $ this -> gateway -> findContent ( $ query , $ languageFilter ) ) ; if ( ! $ result -> totalCount ) { throw new NotFoundException ( 'Content' , 'findSingle() found no content for given $filter' ) ; } elseif ( $ result -> totalCount > 1 ) { throw new InvalidArgumentException ( 'totalCount' , 'findSingle() found more then one item for given $filter' ) ; } $ first = reset ( $ result -> searchHits ) ; return $ first -> valueObject ; }
1581	public function withAttributes ( $ attributes ) : self { $ copy = clone $ this ; $ copy -> attributes = collect ( $ attributes ) -> all ( ) ; $ copy -> normalize ( ) ; return $ copy ; }
2938	public function deleteBackups ( $ filePaths = [ ] ) { if ( empty ( $ filePaths ) ) { $ allBackups = $ this -> getBackups ( ) ; foreach ( $ allBackups as $ backup ) { $ filePaths [ ] = $ backup [ 'filepath' ] ; } } foreach ( $ filePaths as $ filePath ) { if ( is_file ( $ filePath ) ) { unlink ( $ filePath ) ; } } return $ this ; }
10315	function getUniqueClicksCount ( $ fromDate = null , $ toDate = null , $ mailingIds = null , $ contactIds = null , $ contactEmails = null , $ contactExternalIds = null , $ excludeAnonymousClicks = false ) { $ params = $ this -> createCountQueryParameters ( $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , $ mailingIds , null ) ; if ( isset ( $ excludeAnonymousClicks ) ) $ params [ 'exclude_anonymous_clicks' ] = ( $ excludeAnonymousClicks == true ) ? "true" : "false" ; return $ this -> get ( 'reports/clicks/unique/count' , $ params ) ; }
5293	protected function execute ( InputInterface $ input , OutputInterface $ output ) { $ directory = $ input -> getArgument ( 'directory' ) ; $ outputFile = $ input -> getArgument ( 'output-file' ) ; $ generator = new IconFontGenerator ; $ output -> writeln ( 'reading files from "' . $ directory . '" ...' ) ; $ generator -> generateFromDir ( $ directory , array ( 'id' => $ input -> getOption ( 'name' ) ? : 'SVGFont' , ) , $ input -> getOption ( 'rename-files' ) ) ; $ output -> writeln ( 'writing font to "' . $ outputFile . '" ...' ) ; file_put_contents ( $ outputFile , $ generator -> getFont ( ) -> getXML ( ) ) ; $ output -> getFormatter ( ) -> setStyle ( 'success' , new OutputFormatterStyle ( null , null , array ( 'bold' , 'reverse' ) ) ) ; $ output -> writeln ( '<success>created ' . $ outputFile . ' successfully</success>' ) ; }
7749	public function getAllMetadata ( ) { $ metadata = array ( ) ; foreach ( $ this -> driver -> getAllClassNames ( ) as $ className ) { $ metadata [ ] = $ this -> getMetadataFor ( $ className ) ; } $ this -> validate ( $ metadata ) ; return $ metadata ; }
3500	public function withApnId ( ApnId $ apnId = null ) : Notification { $ cloned = clone $ this ; $ cloned -> apnId = $ apnId ; return $ cloned ; }
1746	public function addEnclosure ( $ strFile , $ strUrl = null , $ strMedia = 'enclosure' ) { if ( $ strFile == '' || ! file_exists ( System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) . '/' . $ strFile ) ) { return ; } if ( $ strUrl === null ) { $ strUrl = Environment :: get ( 'base' ) ; } $ objFile = new File ( $ strFile ) ; $ this -> arrData [ 'enclosure' ] [ ] = array ( 'media' => $ strMedia , 'url' => $ strUrl . System :: urlEncode ( $ strFile ) , 'length' => $ objFile -> size , 'type' => $ objFile -> mime ) ; }
10529	protected function normalizeProxyHeader ( $ header ) { $ header = strtoupper ( $ header ) ; $ header = str_replace ( '-' , '_' , $ header ) ; if ( 0 !== strpos ( $ header , 'HTTP_' ) ) { $ header = 'HTTP_' . $ header ; } return $ header ; }
9155	private function parseAnnotations ( \ ReflectionMethod $ action ) { if ( $ action -> isConstructor ( ) || $ action -> isDestructor ( ) || $ action -> isStatic ( ) || $ action -> isFinal ( ) ) { return ; } $ rfMethod = new \ ReflectionMethod ( $ this , $ action -> name ) ; $ anno = $ rfMethod -> getDocComment ( ) ; if ( $ anno && preg_match ( '#@webMethod#' , $ anno ) ) { $ this -> actions [ ] = $ action -> name ; return ; } if ( ! $ this -> parseParameters ( $ action ) ) { return ; } $ this -> actions [ ] = $ action -> name ; }
6486	public function createRequestFromSuperglobals ( array $ server ) : IHttpRequestMessage { $ method = $ server [ 'REQUEST_METHOD' ] ?? 'GET' ; if ( $ method === 'POST' && isset ( $ server [ 'X-HTTP-METHOD-OVERRIDE' ] ) ) { $ method = $ server [ 'X-HTTP-METHOD-OVERRIDE' ] ; } $ uri = $ this -> createUriFromSuperglobals ( $ server ) ; $ headers = $ this -> createHeadersFromSuperglobals ( $ server ) ; $ body = new StreamBody ( new Stream ( fopen ( 'php://input' , 'rb' ) ) ) ; $ properties = $ this -> createProperties ( $ server ) ; return new Request ( $ method , $ uri , $ headers , $ body , $ properties ) ; }
2639	public function aroundGetElementByPathParts ( \ Closure $ proceed , array $ pathParts ) { $ result = $ proceed ( $ pathParts ) ; if ( $ this -> isLoaded == true || false ) { return $ result ; } if ( ( $ result instanceof Section ) == false ) { return $ result ; } if ( isset ( $ pathParts [ 0 ] ) == false || $ pathParts [ 0 ] != 'system' ) { return $ result ; } $ this -> isLoaded = true ; $ data = $ result -> getData ( ) ; if ( isset ( $ data [ 'children' ] [ 'full_page_cache' ] [ 'children' ] [ 'fastly_edge_modules' ] [ 'children' ] ) == false ) { return $ result ; } $ original = $ data [ 'children' ] [ 'full_page_cache' ] [ 'children' ] [ 'fastly_edge_modules' ] [ 'children' ] ; $ data [ 'children' ] [ 'full_page_cache' ] [ 'children' ] [ 'fastly_edge_modules' ] [ 'children' ] = array_merge ( $ original , $ this -> loadModlyData ( ) ) ; $ result -> setData ( $ data , $ this -> scopeDefiner -> getScope ( ) ) ; return $ result ; }
7044	private function getMetaModelTableNames ( $ keyTranslated , $ keyUntranslated ) { $ result = [ ] ; foreach ( $ this -> factory -> collectNames ( ) as $ table ) { $ metaModel = $ this -> factory -> getMetaModel ( $ table ) ; if ( null === $ metaModel ) { continue ; } if ( $ metaModel -> isTranslated ( ) ) { $ result [ $ keyTranslated ] [ $ table ] = \ sprintf ( '%s (%s)' , $ metaModel -> get ( 'name' ) , $ table ) ; } else { $ result [ $ keyUntranslated ] [ $ table ] = \ sprintf ( '%s (%s)' , $ metaModel -> get ( 'name' ) , $ table ) ; } } return $ result ; }
11201	public function fetchOffset ( $ num ) { if ( $ this -> contentModified ) { $ this -> generateContent ( ) ; } $ key = $ this -> fetchOffsetKey ( $ num ) ; if ( $ key != null ) { return $ this -> content [ $ key ] ; } return null ; }
6528	public static function registerMap ( array $ map ) { @ trigger_error ( sprintf ( '"%s" is deprecated. Use "registerManifest" instead.' , __CLASS__ ) , E_USER_DEPRECATED ) ; $ nextId = count ( self :: $ curies ) + 30000 ; foreach ( $ map as $ curie => $ class ) { ++ $ nextId ; self :: $ curies [ $ curie ] = $ nextId ; self :: $ classes [ $ nextId ] = $ class ; } }
7448	function encrypt ( $ data , $ password ) { $ salt = openssl_random_pseudo_bytes ( 16 ) ; $ salted = '' ; $ dx = '' ; while ( strlen ( $ salted ) < 48 ) { $ dx = hash ( 'sha256' , $ dx . $ password . $ salt , true ) ; $ salted .= $ dx ; } $ key = substr ( $ salted , 0 , 32 ) ; $ iv = substr ( $ salted , 32 , 16 ) ; $ encrypted_data = openssl_encrypt ( $ data , 'AES-256-CBC' , $ key , true , $ iv ) ; return base64_encode ( $ salt . $ encrypted_data ) ; }
4305	public function table ( ) { if ( ! $ this -> cfg [ 'collect' ] ) { return ; } $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) ) ; $ event = $ this -> methodTable -> onLog ( new Event ( $ this , array ( 'method' => __FUNCTION__ , 'args' => $ args , 'meta' => $ meta , ) ) ) ; $ this -> appendLog ( $ event [ 'method' ] , $ event [ 'args' ] , $ event [ 'meta' ] ) ; }
1808	public function getContentElements ( ) { $ groups = array ( ) ; foreach ( $ GLOBALS [ 'TL_CTE' ] as $ k => $ v ) { foreach ( array_keys ( $ v ) as $ kk ) { $ groups [ $ k ] [ ] = $ kk ; } } return $ groups ; }
9734	public function setRGB ( $ pValue ) { if ( $ pValue == '' ) { $ pValue = '000000' ; } if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'argb' => 'FF' . $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> argb = 'FF' . $ pValue ; } return $ this ; }
4734	public function write_data ( ) { $ option_key = "_wp_session_{$this->session_id}" ; if ( $ this -> dirty ) { if ( false === get_option ( $ option_key ) ) { add_option ( "_wp_session_{$this->session_id}" , $ this -> container , '' , 'no' ) ; add_option ( "_wp_session_expires_{$this->session_id}" , $ this -> expires , '' , 'no' ) ; } else { delete_option ( "_wp_session_{$this->session_id}" ) ; add_option ( "_wp_session_{$this->session_id}" , $ this -> container , '' , 'no' ) ; } } }
6628	public function get ( $ key , $ default = null ) { return ArrayHelper :: getValue ( $ this -> parsedResponse , sprintf ( '%s.%s' , self :: RESPONSE_DATA_PARAM , $ key ) , $ default ) ; }
10667	protected function buildOnDup ( ) { $ result = [ ] ; foreach ( $ this -> clause_ondup as $ col => $ expr ) { $ result [ ] = $ col . ' = ' . $ expr ; } return $ result ; }
2299	public static function addFileMetaInformationToRequest ( $ strUuid , $ strPtable , $ intPid ) { @ trigger_error ( 'Using Backend::addFileMetaInformationToRequest() has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; $ objFile = FilesModel :: findByUuid ( $ strUuid ) ; if ( $ objFile === null ) { return ; } $ arrMeta = StringUtil :: deserialize ( $ objFile -> meta ) ; if ( empty ( $ arrMeta ) ) { return ; } $ objPage = null ; if ( $ strPtable == 'tl_article' ) { $ objPage = PageModel :: findOneBy ( array ( 'tl_page.id=(SELECT pid FROM tl_article WHERE id=?)' ) , $ intPid ) ; } else { if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'addFileMetaInformationToRequest' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'addFileMetaInformationToRequest' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'addFileMetaInformationToRequest' ] as $ callback ) { if ( ( $ val = System :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ strPtable , $ intPid ) ) !== false ) { $ objPage = $ val ; } } if ( $ objPage instanceof Result && $ objPage -> numRows < 1 ) { return ; } if ( \ is_object ( $ objPage ) && ! ( $ objPage instanceof PageModel ) ) { $ objPage = PageModel :: findByPk ( $ objPage -> id ) ; } } } if ( $ objPage === null ) { return ; } $ objPage -> loadDetails ( ) ; $ strLanguage = str_replace ( '-' , '_' , $ objPage -> rootLanguage ) ; if ( isset ( $ arrMeta [ $ strLanguage ] ) ) { if ( ! empty ( $ arrMeta [ $ strLanguage ] [ 'title' ] ) && Input :: post ( 'title' ) == '' ) { Input :: setPost ( 'title' , $ arrMeta [ $ strLanguage ] [ 'title' ] ) ; } if ( ! empty ( $ arrMeta [ $ strLanguage ] [ 'alt' ] ) && Input :: post ( 'alt' ) == '' ) { Input :: setPost ( 'alt' , $ arrMeta [ $ strLanguage ] [ 'alt' ] ) ; } if ( ! empty ( $ arrMeta [ $ strLanguage ] [ 'caption' ] ) && Input :: post ( 'caption' ) == '' ) { Input :: setPost ( 'caption' , $ arrMeta [ $ strLanguage ] [ 'caption' ] ) ; } } }
9358	public function getModulePath ( $ moduleName ) { if ( array_key_exists ( $ moduleName , $ this -> loadedModules ) ) { $ module = $ this -> loadedModules [ $ moduleName ] ; $ moduleConfig = $ module -> getAutoloaderConfig ( ) ; return $ moduleConfig [ self :: STANDARD_AUTOLOLOADER ] [ self :: NAMESPACE_KEY ] [ $ moduleName ] ; } return null ; }
7677	function TbsSearchInFiles ( $ files , $ str , $ returnFirstFound = true ) { $ keys_ok = array ( ) ; $ keys_todo = array ( ) ; $ idx_keys = array ( ) ; foreach ( $ files as $ k => $ f ) { $ idx = $ this -> FileGetIdx ( $ f ) ; if ( $ idx !== false ) { $ keys_todo [ $ k ] = $ idx ; $ idx_keys [ $ idx ] = $ k ; } } if ( ( $ this -> TbsCurrIdx !== false ) && isset ( $ idx_keys [ $ this -> TbsCurrIdx ] ) ) { $ key = $ idx_keys [ $ this -> TbsCurrIdx ] ; $ p = strpos ( $ this -> TBS -> Source , $ str ) ; if ( $ p !== false ) { $ keys_ok [ ] = array ( 'key' => $ key , 'idx' => $ this -> TbsCurrIdx , 'src' => & $ this -> TBS -> Source , 'pos' => $ p , 'curr' => true ) ; if ( $ returnFirstFound ) return $ keys_ok [ 0 ] ; } unset ( $ keys_todo [ $ key ] ) ; } foreach ( $ this -> TbsStoreLst as $ idx => $ s ) { if ( ( $ idx !== $ this -> TbsCurrIdx ) && isset ( $ idx_keys [ $ idx ] ) ) { $ key = $ idx_keys [ $ idx ] ; $ p = strpos ( $ s [ 'src' ] , $ str ) ; if ( $ p !== false ) { $ keys_ok [ ] = array ( 'key' => $ key , 'idx' => $ idx , 'src' => & $ s [ 'src' ] , 'pos' => $ p , 'curr' => false ) ; if ( $ returnFirstFound ) return $ keys_ok [ 0 ] ; } unset ( $ keys_todo [ $ key ] ) ; } } foreach ( $ keys_todo as $ key => $ idx ) { $ txt = $ this -> FileRead ( $ idx ) ; $ p = strpos ( $ txt , $ str ) ; if ( $ p !== false ) { $ keys_ok [ ] = array ( 'key' => $ key , 'idx' => $ idx , 'src' => $ txt , 'pos' => $ p , 'curr' => false ) ; if ( $ returnFirstFound ) return $ keys_ok [ 0 ] ; } } if ( $ returnFirstFound ) { return array ( 'key' => false , 'idx' => false , 'src' => false , 'pos' => false , 'curr' => false ) ; } else { return $ keys_ok ; } }
7245	private function buildSaleItemRemaining ( Common \ SaleItemInterface $ saleItem , Shipment \ RemainingList $ list , array $ shipments ) { if ( ! ( $ saleItem -> isCompound ( ) && ! $ saleItem -> hasPrivateChildren ( ) ) ) { $ quantity = $ saleItem -> getTotalQuantity ( ) ; foreach ( $ shipments as $ shipment ) { foreach ( $ shipment -> getItems ( ) as $ item ) { if ( $ item -> getSaleItem ( ) === $ saleItem ) { $ quantity += $ shipment -> isReturn ( ) ? $ item -> getQuantity ( ) : - $ item -> getQuantity ( ) ; continue 2 ; } } } if ( 0 < $ quantity ) { $ entry = new Shipment \ RemainingEntry ( ) ; $ entry -> setSaleItem ( $ saleItem ) -> setQuantity ( $ quantity ) ; $ list -> addEntry ( $ entry ) ; } } foreach ( $ saleItem -> getChildren ( ) as $ child ) { $ this -> buildSaleItemRemaining ( $ child , $ list , $ shipments ) ; } }
7833	protected function generatePipes ( ) { foreach ( $ this -> getPipesByOption ( 'attach' ) as $ pipe ) { $ this -> currentPipe = $ pipe ; parent :: fire ( ) ; } }
9244	private function __loadConfigFiles ( ) { $ additionalConfigs = $ this -> config ( 'additionalConfigFiles' ) ; foreach ( $ additionalConfigs as $ additionalConfig ) { Configure :: load ( $ additionalConfig ) ; } }
8929	public function stack ( $ icons ) { if ( count ( $ icons ) !== 2 ) { throw new \ InvalidArgumentException ( 'Expecting exactly 2 icons in the stack' ) ; } $ contents = [ ] ; $ index = 2 ; foreach ( $ icons as $ key => $ value ) { $ contents [ ] = $ this -> getStackIconElement ( $ key , $ value , $ index ) ; -- $ index ; } return $ this -> html -> span ( $ contents ) -> addClass ( 'fa-stack' ) ; }
11010	public function addDefaultSrc ( string $ source ) : bool { if ( ! in_array ( $ source , $ this -> tags [ 'default-src' ] ) ) { $ this -> tags [ 'default-src' ] [ ] = $ source ; return true ; } return false ; }
1023	private function executeOperation ( OperationDefinitionNode $ operation , $ rootValue ) { $ type = $ this -> getOperationRootType ( $ this -> exeContext -> schema , $ operation ) ; $ fields = $ this -> collectFields ( $ type , $ operation -> selectionSet , new ArrayObject ( ) , new ArrayObject ( ) ) ; $ path = [ ] ; try { $ result = $ operation -> operation === 'mutation' ? $ this -> executeFieldsSerially ( $ type , $ rootValue , $ path , $ fields ) : $ this -> executeFields ( $ type , $ rootValue , $ path , $ fields ) ; if ( $ this -> isPromise ( $ result ) ) { return $ result -> then ( null , function ( $ error ) { $ this -> exeContext -> addError ( $ error ) ; return $ this -> exeContext -> promises -> createFulfilled ( null ) ; } ) ; } return $ result ; } catch ( Error $ error ) { $ this -> exeContext -> addError ( $ error ) ; return null ; } }
5268	public function esc_like ( $ value , $ start = '%' , $ end = '%' ) { global $ wpdb ; return $ start . $ wpdb -> esc_like ( $ value ) . $ end ; }
5924	public function setFilterItems ( array $ filterItems ) { $ this -> filterItems = [ ] ; foreach ( $ filterItems as $ item ) { $ this -> addFilterItem ( $ item ) ; } return $ this ; }
3338	public static function dateTimeString ( $ datetime ) { if ( $ datetime === null ) { return null ; } if ( is_object ( $ datetime ) && ! ( $ datetime instanceof \ DateTime ) ) { throw new \ Exception ( 'Only \DateTime objects allowed' ) ; } if ( is_string ( $ datetime ) ) { $ datetime = new \ DateTime ( $ datetime ) ; } return $ datetime -> format ( "Y-m-d\TH:i:s.uP" ) ; }
1240	private static function propertyToXml ( $ name , $ value ) { if ( is_subclass_of ( $ value , '\DTS\eBaySDK\Types\BaseType' , false ) ) { return $ value -> toXml ( $ name ) ; } else { return sprintf ( '<%s>%s</%s>' , $ name , self :: encodeValueXml ( $ value ) , $ name ) ; } }
1440	protected function getResourceName ( ) { $ name = ucwords ( $ this -> getResourceInput ( ) ) ; if ( $ this -> isByResource ( ) ) { return str_plural ( $ name ) ; } return $ name ; }
7101	static public function getClasses ( $ type ) { switch ( $ type ) { case static :: TYPE_FORM : return [ CartInterface :: class ] ; case static :: TYPE_QUOTE : return [ QuoteInterface :: class ] ; case static :: TYPE_PROFORMA : return [ QuoteInterface :: class , OrderInterface :: class ] ; case static :: TYPE_CONFIRMATION : return [ OrderInterface :: class ] ; case static :: TYPE_VOUCHER : return [ ] ; default : throw new InvalidArgumentException ( "Unexpected type '$type'." ) ; } }
2428	protected function hasToWait ( ) { $ return = true ; $ time = strtotime ( date ( 'Y-m-d H:i' ) ) ; $ this -> Database -> lockTables ( array ( 'tl_cron' => 'WRITE' ) ) ; $ objCron = $ this -> Database -> prepare ( "SELECT * FROM tl_cron WHERE name='lastrun'" ) -> limit ( 1 ) -> execute ( ) ; if ( $ objCron -> numRows < 1 ) { $ this -> Database -> query ( "INSERT INTO tl_cron (name, value) VALUES ('lastrun', $time)" ) ; $ return = false ; } elseif ( $ objCron -> value <= ( $ time - $ this -> getCronTimeout ( ) ) ) { $ this -> Database -> query ( "UPDATE tl_cron SET value=$time WHERE name='lastrun'" ) ; $ return = false ; } $ this -> Database -> unlockTables ( ) ; return $ return ; }
9216	public function actionDelete ( $ id ) { $ model = $ this -> findModel ( $ id ) ; $ model -> isdel = 1 ; $ model -> save ( ) ; return $ this -> redirect ( [ 'index' ] ) ; }
6295	private function parseThemeInfo ( array $ info ) { $ themeInfo = new ThemeInfo ( ) ; $ required = [ 'name' , 'author' , 'directory' ] ; foreach ( $ required as $ key ) { if ( ! array_key_exists ( $ key , $ info ) ) { throw new ThemeInfoAttributeException ( $ key ) ; } } $ themeInfo -> setName ( $ info [ 'name' ] ) ; $ themeInfo -> setAuthor ( $ info [ 'author' ] ) ; $ themeInfo -> setDirectory ( strtolower ( $ info [ 'directory' ] ) ) ; if ( isset ( $ info [ 'description' ] ) ) { $ themeInfo -> setDescription ( $ info [ 'description' ] ) ; } if ( isset ( $ info [ 'version' ] ) ) { $ themeInfo -> setVersion ( $ info [ 'version' ] ) ; } if ( isset ( $ info [ 'parent' ] ) ) { $ themeInfo -> setParent ( $ info [ 'parent' ] ) ; } $ themeInfo -> setPath ( $ this -> findPath ( $ info [ 'directory' ] ) ) ; return $ themeInfo ; }
1126	public function isSelfOrDescendantOf ( $ other ) { return ( $ this -> getLeft ( ) >= $ other -> getLeft ( ) && $ this -> getLeft ( ) < $ other -> getRight ( ) && $ this -> inSameScope ( $ other ) ) ; }
3657	private function tryDispatch ( $ eventName , MetaModelsBootEvent $ event ) { $ dispatcher = System :: getContainer ( ) -> get ( 'event_dispatcher' ) ; if ( $ dispatcher -> hasListeners ( $ eventName ) ) { @ trigger_error ( 'Event "' . $ eventName . '" has been deprecated - Use registered services.' , E_USER_DEPRECATED ) ; $ dispatcher -> dispatch ( $ eventName , $ event ) ; } }
5556	public function getUrlById ( $ id ) { foreach ( $ this -> frames as $ index => $ frame ) { if ( $ url = $ frame -> getUrlById ( $ id ) ) { if ( ! $ url -> gettarget ( ) ) { $ url -> setTarget ( $ this -> getPublicNameFromIndex ( $ index ) ) ; } return $ url ; } } return false ; }
8152	public function getExtension ( $ class ) { $ class = ltrim ( $ class , '\\' ) ; if ( ! isset ( $ this -> extensionsByClass [ $ class ] ) && class_exists ( $ class , false ) ) { $ class = new ReflectionClass ( $ class ) ; $ class = $ class -> name ; } if ( isset ( $ this -> extensions [ $ class ] ) ) { if ( $ class !== get_class ( $ this -> extensions [ $ class ] ) ) { @ trigger_error ( sprintf ( 'Referencing the "%s" extension by its name (defined by getName()) is deprecated since 1.26 and will be removed in Twig 2.0. Use the Fully Qualified Extension Class Name instead.' , $ class ) , E_USER_DEPRECATED ) ; } return $ this -> extensions [ $ class ] ; } if ( ! isset ( $ this -> extensionsByClass [ $ class ] ) ) { throw new Twig_Error_Runtime ( sprintf ( 'The "%s" extension is not enabled.' , $ class ) ) ; } return $ this -> extensionsByClass [ $ class ] ; }
5038	public function get ( $ key , $ fallback = true ) { foreach ( $ this -> getImages ( ) as $ image ) { if ( $ key == $ image -> getKey ( ) ) { return $ image ; } } return ! $ fallback || self :: ORIGINAL == $ key ? null : $ this -> get ( self :: ORIGINAL ) ; }
11602	public function getComponentRoot ( string $ name ) : ? string { $ rootMap = $ this -> getConfig ( 'componentsRootMap' ) ; return isset ( $ rootMap [ $ name ] ) ? $ this -> getAppRoot ( ) . $ rootMap [ $ name ] : null ; }
132	public function disablePlugins ( ) { foreach ( $ this -> installers as $ i => $ installer ) { if ( ! $ installer instanceof PluginInstaller ) { continue ; } unset ( $ this -> installers [ $ i ] ) ; } }
12335	public function editProfileAction ( ) { if ( ! $ this -> cmsAuthentication ( ) -> hasIdentity ( ) ) { return $ this -> redirect ( ) -> toRoute ( $ this -> getOptions ( ) -> getLoginRoute ( ) ) ; } $ url = $ this -> url ( ) -> fromRoute ( null , [ 'action' => 'edit-profile' ] ) ; $ prg = $ this -> prg ( $ url , true ) ; if ( $ prg instanceof ResponseInterface ) { return $ prg ; } $ post = $ prg ; $ form = $ this -> getUserService ( ) -> getEditProfileForm ( ) ; $ identity = $ this -> cmsAuthentication ( ) -> getIdentity ( ) ; $ form -> bind ( $ identity ) ; $ form -> setAttribute ( 'action' , $ url ) ; if ( $ post && $ form -> setData ( $ post ) -> isValid ( ) ) { $ result = $ this -> getUserService ( ) -> editProfile ( $ identity ) ; if ( $ result instanceof ResponseInterface ) { return $ result ; } elseif ( $ result ) { $ fm = $ this -> flashMessenger ( ) ; $ fm -> setNamespace ( $ form -> getName ( ) . '-' . $ fm :: NAMESPACE_SUCCESS ) -> addMessage ( $ this -> translate ( 'Data has been successfully saved' ) ) ; } } return new ViewModel ( compact ( 'form' ) ) ; }
7577	protected function setFileFieldValue ( $ value ) { if ( version_compare ( PHP_VERSION , '5.5.0' ) >= 0 ) { if ( ! ( $ value instanceof \ CURLFile ) ) { $ value = ltrim ( $ value , "@" ) ; $ value = new \ CURLFile ( $ value ) ; } } else { if ( strpos ( $ value , '@' ) !== 0 ) { $ value = '@' . $ value ; } } return $ value ; }
5716	public function doSaveAndQuit ( $ data , $ form ) { Controller :: curr ( ) -> getResponse ( ) -> addHeader ( "X-Pjax" , "Content" ) ; return $ this -> saveAndRedirect ( $ data , $ form , $ this -> getBackLink ( ) ) ; }
12771	public function authorizeWithEmail ( $ hashedEmail , $ hashedPassword , $ remember = null , & $ user = null ) { $ result = new EmailStatus ( 0 ) ; if ( dbQuery ( $ this -> dbTable ) -> where ( $ this -> dbHashEmailField , $ hashedEmail ) -> first ( $ user ) ) { $ dbTable = $ this -> dbTable ; $ hashPasswordField = $ dbTable :: $ _attributes [ $ this -> dbHashPasswordField ] ; if ( $ user [ $ hashPasswordField ] === $ hashedPassword ) { $ result = new EmailStatus ( EmailStatus :: SUCCESS_EMAIL_AUTHORIZE ) ; $ this -> authorize ( $ user , $ remember ) ; } else { $ result = new EmailStatus ( EmailStatus :: ERROR_EMAIL_AUTHORIZE_WRONGPWD ) ; } } else { $ result = new EmailStatus ( EmailStatus :: ERROR_EMAIL_AUTHORIZE_NOTFOUND ) ; } if ( is_callable ( $ this -> authorizeHandler ) ) { if ( ! call_user_func_array ( $ this -> authorizeHandler , array ( & $ user , & $ result ) ) ) { $ result = new EmailStatus ( EmailStatus :: ERROR_EMAIL_AUTHORIZE_HANDLER ) ; } } return $ result ; }
3556	public function setMetaGroup ( $ group = null ) { if ( ! preg_match ( '/^[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*$/' , $ group ) && $ group !== null ) { throw new InvalidArgumentException ( "Provided group [{$group}] is not valid variable name." ) ; } $ this -> attributes [ 'meta_group' ] = $ group ; }
2074	public function purgeSearchTables ( ) { $ objDatabase = Database :: getInstance ( ) ; $ objDatabase -> execute ( "TRUNCATE TABLE tl_search" ) ; $ objDatabase -> execute ( "TRUNCATE TABLE tl_search_index" ) ; $ strCachePath = StringUtil :: stripRootDir ( System :: getContainer ( ) -> getParameter ( 'kernel.cache_dir' ) ) ; $ objFolder = new Folder ( $ strCachePath . '/contao/search' ) ; $ objFolder -> purge ( ) ; $ this -> log ( 'Purged the search tables' , __METHOD__ , TL_CRON ) ; }
1366	protected function bootResponseMacro ( ) { Response :: macro ( 'jsonApi' , function ( $ api = null ) { return json_api ( $ api ) -> getResponses ( ) -> withEncodingParameters ( app ( EncodingParametersInterface :: class ) ) ; } ) ; }
5926	public function listCategories ( CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/categories' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new CategoryResponse ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
2710	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ domains = $ this -> api -> getAllDomains ( $ activeVersion ) ; $ storeBaseUrl = $ this -> storeManager -> getStore ( ) -> getBaseUrl ( ) ; if ( ! $ domains ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to check Domain details.' ] ) ; } return $ result -> setData ( [ 'status' => true , 'domains' => $ domains , 'store' => $ storeBaseUrl ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
12466	private function createEditForm ( CustomFieldsGroup $ entity ) { $ form = $ this -> createForm ( 'custom_fields_group' , $ entity , array ( 'action' => $ this -> generateUrl ( 'customfieldsgroup_update' , array ( 'id' => $ entity -> getId ( ) ) ) , 'method' => 'PUT' , ) ) ; $ form -> add ( 'submit' , 'submit' , array ( 'label' => 'Update' ) ) ; return $ form ; }
3762	private function getConditionChain ( LegendInterface $ legend , $ propertyName , array & $ conditions ) { if ( isset ( $ conditions [ $ legend -> getName ( ) ] [ $ propertyName ] ) ) { return $ conditions [ $ legend -> getName ( ) ] [ $ propertyName ] ; } $ property = $ this -> getLegendProperty ( $ legend , $ propertyName ) ; $ condition = $ this -> getVisibleCondition ( $ property ) ; $ orCondition = new PropertyConditionChain ( ) ; $ orCondition -> setConjunction ( PropertyConditionChain :: OR_CONJUNCTION ) ; $ conditions [ $ legend -> getName ( ) ] [ $ propertyName ] = $ orCondition ; $ condition -> addCondition ( $ orCondition ) ; return $ orCondition ; }
8321	public function badCaptcha ( $ captchaId ) { $ response = $ this -> getHttpClient ( ) -> request ( 'GET' , "/res.php?key={$this->apiKey}&action=reportbad&id={$captchaId}" ) ; $ responseText = $ response -> getBody ( ) -> __toString ( ) ; if ( $ responseText === self :: STATUS_OK_REPORT_RECORDED ) { return true ; } throw new ErrorResponseException ( $ this -> getErrorMessage ( $ responseText ) ? : $ responseText , $ this -> getErrorCode ( $ responseText ) ? : 0 ) ; }
7510	function addError ( $ error ) { $ this -> errors [ ] = htmlentities ( $ error . ' at ' . ( $ this -> line_pos [ 0 ] + 1 ) . ', ' . ( $ this -> pos - $ this -> line_pos [ 1 ] + 1 ) . '!' ) ; }
9117	public function unregisterView ( $ view , $ order , $ applicationName = 'default' ) { if ( isset ( $ this -> views [ $ applicationName ] [ $ order ] [ $ view ] ) ) { unset ( $ this -> views [ $ applicationName ] [ $ order ] [ $ view ] ) ; } return $ this ; }
6127	public function setExpireDate ( $ expireDate ) { if ( $ expireDate instanceof DateTime ) { $ this -> expireDate = $ expireDate ; } else { try { $ this -> expireDate = new DateTime ( $ expireDate ) ; } catch ( \ Exception $ e ) { $ this -> expireDate = null ; } } return $ this ; }
6561	public static function getRelativePath ( $ path , $ start = null ) { if ( $ start === null ) { $ start = getcwd ( ) ; } if ( substr ( $ path , 0 , 1 ) !== '/' || substr ( $ start , 0 , 1 ) !== '/' ) { return false ; } $ pathParts = self :: splitPath ( $ path ) ; $ countPathParts = count ( $ pathParts ) ; $ startParts = self :: splitPath ( $ start ) ; $ countStartParts = count ( $ startParts ) ; $ commonLength = min ( $ countPathParts , $ countStartParts ) ; for ( $ i = 0 ; $ i < $ commonLength ; $ i ++ ) { if ( $ startParts [ $ i ] !== $ pathParts [ $ i ] ) { break ; } } $ relList = ( $ countStartParts > $ i ) ? array_fill ( 0 , $ countStartParts - $ i , '..' ) : [ ] ; $ relList = array_merge ( $ relList , array_slice ( $ pathParts , $ i ) ) ; return implode ( '/' , $ relList ) ? : '.' ; }
493	private function indexBuckets ( $ buckets , $ indexBy ) { $ result = [ ] ; foreach ( $ buckets as $ key => $ models ) { $ result [ $ key ] = [ ] ; foreach ( $ models as $ model ) { $ index = is_string ( $ indexBy ) ? $ model [ $ indexBy ] : call_user_func ( $ indexBy , $ model ) ; $ result [ $ key ] [ $ index ] = $ model ; } } return $ result ; }
7226	public function info ( $ name = null ) { if ( $ name ) { return $ this -> info ? $ this -> info [ $ name ] : curl_getinfo ( $ this -> curl , "CURLINFO" . strtoupper ( $ name ) ) ; } else { return $ this -> info ? : curl_getinfo ( $ this -> curl ) ; } }
6854	private function findPaymentTokens ( PaymentInterface $ payment ) { $ identity = $ this -> getPaymentIdentity ( $ payment ) ; $ tokens = $ this -> payum -> getTokenStorage ( ) -> findBy ( [ 'details' => $ identity , ] ) ; return $ tokens ; }
4563	public function preUpdate ( PreUpdateEventArgs $ args ) { $ entity = $ args -> getEntity ( ) ; if ( ! $ entity instanceof Parameter ) { return ; } $ entity -> setValue ( serialize ( $ entity -> getValue ( ) ) ) ; }
8577	public function setItemFeeList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ItemFeeList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
4390	protected function getXmlProvider ( ) { $ provider = OPay :: create ( 'Datatrans\Xml' ) ; $ provider -> initialize ( $ this -> getServiceItem ( ) -> getConfig ( ) ) ; return $ provider ; }
12264	public function addSource ( $ sourcePath , $ useStrict = true ) { if ( is_link ( $ sourcePath ) ) { return $ this -> addSource ( realpath ( $ sourcePath ) , $ useStrict ) ; } if ( is_dir ( $ sourcePath ) ) { $ this -> sourceDirs [ ] = $ sourcePath ; } elseif ( true === $ useStrict ) { throw new \ Exception ( sprintf ( 'Path {%s} is not a readable directory' , $ sourcePath ) ) ; } return $ this ; }
3777	protected function getParamName ( ) { if ( $ this -> get ( 'urlparam' ) ) { return $ this -> get ( 'urlparam' ) ; } $ objAttribute = $ this -> getFilteredAttribute ( ) ; if ( $ objAttribute ) { return $ objAttribute -> getColName ( ) ; } return null ; }
9664	public static function registerReader ( $ readerType , $ readerClass ) { if ( ! is_a ( $ readerClass , Reader \ IReader :: class , true ) ) { throw new Reader \ Exception ( 'Registered readers must implement ' . Reader \ IReader :: class ) ; } self :: $ readers [ $ readerType ] = $ readerClass ; }
7320	public function diff ( AstroDate $ b ) { $ prec = 12 ; $ jd1 = $ this -> toJD ( $ prec ) ; $ jd2 = $ b -> toJD ( $ prec ) ; $ days = bcsub ( $ jd1 , $ jd2 , $ prec ) ; return Time :: days ( - 1 * $ days ) ; }
3806	private function isAttributeNameOrTypeChanged ( ModelInterface $ new , ModelInterface $ old ) { return ( $ old -> getProperty ( 'type' ) !== $ new -> getProperty ( 'type' ) ) || ( $ old -> getProperty ( 'colname' ) !== $ new -> getProperty ( 'colname' ) ) ; }
12576	public function previewTextByName ( $ message , $ to ) { return $ this -> preview ( self :: MSG_TYPE_TEXT , $ message , $ to , self :: PREVIEW_BY_NAME ) ; }
6874	private function findOrCreateItem ( ShipmentInterface $ shipment , SaleItemInterface $ saleItem , $ expected , $ available = null ) { $ item = null ; if ( 0 >= $ expected ) { return $ item ; } foreach ( $ shipment -> getItems ( ) as $ i ) { if ( $ i -> getSaleItem ( ) === $ saleItem ) { $ item = $ i ; break ; } } if ( null === $ item ) { $ item = $ this -> factory -> createItemForShipment ( $ shipment ) ; $ item -> setShipment ( $ shipment ) ; $ item -> setSaleItem ( $ saleItem ) ; } $ item -> setExpected ( $ expected ) ; if ( $ shipment -> isReturn ( ) ) { $ item -> setAvailable ( $ expected ) ; } else { if ( null === $ available ) { $ available = $ this -> calculator -> calculateAvailableQuantity ( $ saleItem , $ shipment ) ; } $ item -> setAvailable ( $ available ) ; if ( null === $ shipment -> getId ( ) ) { $ item -> setQuantity ( min ( $ expected , $ available ) ) ; } } return $ item ; }
64	public function size ( $ path ) { if ( ! file_exists ( $ path ) ) { throw new \ RuntimeException ( "$path does not exist." ) ; } if ( is_dir ( $ path ) ) { return $ this -> directorySize ( $ path ) ; } return filesize ( $ path ) ; }
7003	public function match ( $ test ) { $ isArray = [ ] ; $ pattern = preg_replace_callback ( "~/\{(?<arg>\w+)(?<arr>\[\])?\}(?<num>\?|\+|\*|\{[0-9,]+\})?~" , function ( $ matches ) use ( & $ isArray ) { $ name = $ matches [ "arg" ] ; $ num = $ matches [ "num" ] ?? "" ; $ isArray [ $ name ] = ! empty ( $ matches [ 2 ] ) ; return "(?<$name>(?:/[^\\s/?]+)$num)" ; } , $ this -> url ) ; if ( ! $ pattern || empty ( $ pattern ) ) { error_log ( "pattern error: found in route with pattern: {$this->url}" ) ; return false ; } $ pattern = "^$pattern/?(?:\?.*)?$" ; if ( preg_match ( "~$pattern~" , $ test , $ matches ) ) { foreach ( $ matches as $ name => $ val ) { $ val = urldecode ( $ val ) ; if ( is_int ( $ name ) ) { if ( $ name === 0 ) $ this -> args [ $ name ] = $ val ; } else { $ val = ltrim ( $ val , "/" ) ; $ this -> args [ $ name ] = $ isArray [ $ name ] ? explode ( "/" , $ val ) : $ val ; } } return true ; } return false ; }
11180	protected function set ( $ key , $ value ) { $ cache = apc_fetch ( $ this -> getKey ( ) ) ; $ cache [ $ key ] = $ value ; apc_store ( $ this -> getKey ( ) , $ cache ) ; }
8025	public function addFree ( ProcessDetails $ processDetails ) { $ pid = $ processDetails -> getPid ( ) ; $ this -> processDetails [ $ pid ] = $ processDetails ; $ this -> sockets [ $ pid ] = $ processDetails -> getSocket ( ) ; $ this -> registerFreeProcess ( $ processDetails ) ; return $ this ; }
4798	function offsetGet ( $ key ) { if ( $ this -> single && ! isset ( $ this -> data ) ) { $ clone = clone $ this ; if ( is_array ( $ key ) ) { $ clone -> where ( $ key ) -> limit ( 1 ) ; } else { $ clone -> where ( $ this -> primary , $ key ) ; } $ return = $ clone -> fetch ( ) ; if ( $ return ) { return $ return ; } } else { $ this -> execute ( ) ; if ( is_array ( $ key ) ) { foreach ( $ this -> data as $ row ) { foreach ( $ key as $ k => $ v ) { if ( ( isset ( $ v ) && $ row [ $ k ] !== null ? $ row [ $ k ] != $ v : $ row [ $ k ] !== $ v ) ) { continue 2 ; } } return $ row ; } } elseif ( isset ( $ this -> data [ $ key ] ) ) { return $ this -> data [ $ key ] ; } } return NULL ; }
8979	protected function initialize ( ) { if ( $ this -> connection -> getSchemaManager ( ) -> tablesExist ( [ $ this -> tableName ] ) ) { return ; } $ schema = new Schema ( ) ; $ table = $ schema -> createTable ( $ this -> tableName ) ; $ table -> addColumn ( 'source_name' , 'string' , [ 'length' => 255 ] ) ; $ table -> addColumn ( 'rate_value' , 'float' , [ 'precision' => 10 , 'scale' => 4 ] ) ; $ table -> addColumn ( 'currency_code' , 'string' , [ 'length' => 3 ] ) ; $ table -> addColumn ( 'rate_type' , 'string' , [ 'length' => 255 ] ) ; $ table -> addColumn ( 'rate_date' , 'date' , [ ] ) ; $ table -> addColumn ( 'base_currency_code' , 'string' , [ 'length' => 3 ] ) ; $ table -> addColumn ( 'created_at' , 'datetime' , [ ] ) ; $ table -> addColumn ( 'modified_at' , 'datetime' , [ ] ) ; $ table -> setPrimaryKey ( [ 'currency_code' , 'rate_date' , 'rate_type' , 'source_name' ] ) ; $ this -> connection -> exec ( $ schema -> toSql ( $ this -> connection -> getDatabasePlatform ( ) ) [ 0 ] ) ; }
6144	public function hasQueryVar ( $ key ) { if ( ! $ this -> hasQuery ( ) ) { return false ; } parse_str ( $ this -> query , $ queryArray ) ; return array_key_exists ( $ key , $ queryArray ) ? true : false ; }
5023	public function allowSelectMultipleItems ( ) { $ flagOrCallback = $ this -> allowSelectMultipleItems ; return is_callable ( $ flagOrCallback ) ? ( bool ) $ flagOrCallback ( ) : ( bool ) $ flagOrCallback ; }
866	public function isType ( $ types ) { if ( ! \ is_array ( $ types ) ) { $ types = [ $ types ] ; } return \ in_array ( $ this -> getType ( ) , $ types , true ) ; }
2008	private function loadLanguageFile ( string $ name ) : void { $ system = $ this -> framework -> getAdapter ( System :: class ) ; $ system -> loadLanguageFile ( $ name ) ; }
7037	protected static function computeDependencies ( array $ tables ) { $ result = [ ] ; while ( ! empty ( $ tables ) ) { $ num = count ( $ tables ) ; foreach ( $ tables as $ i => $ table ) if ( ! $ table -> dependent ( ) ) { $ result [ ] = $ table ; unset ( $ tables [ $ i ] ) ; foreach ( $ tables as $ t ) $ t -> removeDependency ( $ table -> name ( ) ) ; } if ( count ( $ tables ) === $ num ) return false ; } return $ result ; }
6651	private function appendExtraFields ( array $ extra ) { foreach ( $ this -> extraData as $ key => $ value ) { $ extra [ $ key ] = $ value ; } return $ extra ; }
12844	protected function loadAnswerMatching ( ) { if ( $ this -> input -> hasOption ( 'load-choice-matching' ) ) { $ fs = new Filesystem ( ) ; $ filename = $ this -> input -> getOption ( 'load-choice-matching' ) ; if ( ! $ fs -> exists ( $ filename ) ) { $ this -> logger -> warning ( "The file $filename is not found. Choice matching not loaded" ) ; } else { $ this -> logger -> debug ( "Loading $filename as choice matching" ) ; $ this -> cacheAnswersMapping = \ json_decode ( \ file_get_contents ( $ filename ) , true ) ; } } }
11252	public function repositoryExists ( ) : bool { switch ( $ this -> pdo -> getAttribute ( PDO :: ATTR_DRIVER_NAME ) ) { case 'pgsql' : $ sql = 'select count(*) from information_schema.tables where table_schema = current_schema() and table_name = ?' ; break ; case 'mysql' : $ sql = 'select count(*) from information_schema.tables where table_schema = database() and table_name = ?' ; break ; case 'sqlsrv' : $ sql = "select count(*) from sysobjects where type = 'U' and name = ?" ; break ; case 'sqlite' : $ sql = "select count(*) from sqlite_master where type = 'table' and name = ?" ; break ; default : throw InvalidArgumentException :: forDatabaseNotSupported ( ) ; } $ stmt = $ this -> pdo -> prepare ( $ sql ) ; $ stmt -> bindParam ( 1 , $ this -> table ) ; $ stmt -> execute ( ) ; return $ stmt -> fetch ( PDO :: FETCH_COLUMN ) > 0 ; }
2950	private function failedDispatch ( $ queue , \ Exception $ error ) { foreach ( $ queue as $ index => $ data ) { $ this -> clear ( $ data [ 'key' ] ) ; $ data [ 'reject' ] ( $ error ) ; } }
9471	public function paginate ( $ numTotal , $ page , $ limit = 10 ) { $ this -> setTotalItemCount ( $ numTotal ) ; $ this -> setCurrentPageNumber ( $ page ) ; $ this -> setItemNumberPerPage ( $ limit ) ; }
8985	public function isComparable ( TableNode $ expected , TableNode $ actual , array $ diff_options , $ message = NULL ) { $ this -> doAssert ( 'Failed comparing two tables: ' , $ diff_options , $ expected , $ actual , $ message ) ; }
11618	private function compressPhase2 ( $ calcIdWriteOff , $ calcIdPhase1 , $ calcIdPhase2 , $ scheme ) { $ pv = $ this -> rouGetPv -> exec ( $ calcIdWriteOff ) ; $ dwnlPlain = $ this -> daoBonDwnl -> getByCalcId ( $ calcIdWriteOff ) ; $ dwnlPhase1 = $ this -> daoBonDwnl -> getByCalcId ( $ calcIdPhase1 ) ; $ ctx = new \ Praxigento \ Core \ Data ( ) ; $ ctx -> set ( PCpmrsPhase2 :: IN_CALC_ID_PHASE2 , $ calcIdPhase2 ) ; $ ctx -> set ( PCpmrsPhase2 :: IN_SCHEME , $ scheme ) ; $ ctx -> set ( PCpmrsPhase2 :: IN_DWNL_PLAIN , $ dwnlPlain ) ; $ ctx -> set ( PCpmrsPhase2 :: IN_DWNL_PHASE1 , $ dwnlPhase1 ) ; $ ctx -> set ( PCpmrsPhase2 :: IN_MAP_PV , $ pv ) ; $ out = $ this -> procCmprsPhase2 -> exec ( $ ctx ) ; $ dwnlPhase2 = $ out -> get ( PCpmrsPhase2 :: OUT_DWNL_PHASE2 ) ; $ legs = $ out -> get ( PCpmrsPhase2 :: OUT_LEGS ) ; $ result = [ $ dwnlPhase2 , $ legs ] ; return $ result ; }
9104	protected function parse_user ( ) { if ( ! empty ( $ this -> args [ 'user' ] ) ) { $ this -> args [ 'user__in' ] = array ( $ this -> args [ 'user' ] ) ; } return $ this -> parse_in_or_not_in_query ( 'user' , $ this -> args [ 'user__in' ] , $ this -> args [ 'user__not_in' ] ) ; }
6199	protected function transformParam ( $ param , $ k ) { if ( isset ( $ this -> routeMapParse [ $ k ] [ $ param ] ) and ! is_array ( $ this -> routeMapParse [ $ k ] [ $ param ] ) ) { return $ this -> routeMapParse [ $ k ] [ $ param ] ; } else { return '(.+?)' ; } }
5930	public function removeCategory ( $ id ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> delete ( 'v1/categories/' . $ id . '' , $ parameters ) ; $ result = new CategoryResponse ( $ result ) ; return $ result ; }
3918	private function checkDownloads ( ) { if ( $ this -> getShowImages ( ) ) { return ; } if ( ( $ file = Input :: get ( 'file' ) ) && ( $ key = Input :: get ( 'fileKey' ) ) ) { if ( ! ( array_key_exists ( $ file , $ _SESSION [ 'metaModels_downloads' ] ) && $ _SESSION [ 'metaModels_downloads' ] [ $ file ] === $ key ) ) { $ objHandler = new $ GLOBALS [ 'TL_PTY' ] [ 'error_403' ] ( ) ; $ objHandler -> generate ( $ file ) ; } Controller :: sendFileToBrowser ( $ file ) ; } }
12530	public function apply ( $ quantity , $ reason , $ comment = '' , $ poiId = null ) { $ params = [ 'quantity' => intval ( $ quantity ) , 'apply_reason' => $ reason , ] ; if ( ! empty ( $ comment ) ) { $ params [ 'comment' ] = $ comment ; } if ( ! is_null ( $ poiId ) ) { $ params [ 'poi_id' ] = intval ( $ poiId ) ; } return $ this -> parseJSON ( 'json' , [ self :: API_DEVICE_APPLYID , $ params ] ) ; }
5823	private function resolveOptions ( array $ options = array ( ) ) { $ this -> options [ 'alertPublisher' ] = $ this -> alertPublisher ; return array_merge ( $ this -> options , $ options ) ; }
7774	protected function canSkipRule ( $ ruleToCall , $ value ) { return ( ( is_array ( $ ruleToCall ) && method_exists ( $ ruleToCall [ 0 ] , 'canSkip' ) && $ ruleToCall [ 0 ] -> canSkip ( ) ) || empty ( $ value ) && ! is_array ( $ value ) ) ; }
8278	public function onRequestUrl ( & $ url ) { $ this -> requestUrl = $ url ; try { $ this -> init ( ) ; $ this -> triggerEvent ( 'onPicoRequest' , [ $ url , $ this -> request ] ) ; } catch ( \ Exception $ e ) { $ this -> errorHandler ( $ e , $ url ) ; } if ( ! $ this -> errorOccurred ) { $ this -> authRoutes ( ) ; } }
333	public function add ( $ key , $ value , $ duration = 0 , $ dependency = null ) { if ( $ dependency !== null && $ this -> serializer !== false ) { $ dependency -> evaluateDependency ( $ this ) ; } if ( $ this -> serializer === null ) { $ value = serialize ( [ $ value , $ dependency ] ) ; } elseif ( $ this -> serializer !== false ) { $ value = call_user_func ( $ this -> serializer [ 0 ] , [ $ value , $ dependency ] ) ; } $ key = $ this -> buildKey ( $ key ) ; return $ this -> addValue ( $ key , $ value , $ duration ) ; }
10453	public function assignResetToken ( $ token , $ email ) { $ user = $ this -> user -> whereEmail ( $ email ) -> first ( ) ; $ user -> reset_token = $ token ; $ user -> save ( ) ; }
8310	public function standardizeUrlFormat ( & $ rules , $ pageUrl ) { if ( ! is_string ( $ pageUrl ) || $ pageUrl === "" || ! is_array ( $ rules ) || ! array_key_exists ( $ pageUrl , $ rules ) ) { return ; } $ oldIndex = $ pageUrl ; if ( $ pageUrl [ 0 ] !== '/' ) { $ pageUrl = '/' . $ pageUrl ; } $ len = strlen ( $ pageUrl ) ; if ( $ len > 1 && $ pageUrl [ $ len - 1 ] === '/' ) { $ pageUrl = rtrim ( $ pageUrl , '/' ) ; } if ( $ oldIndex !== $ pageUrl ) { $ rules [ $ pageUrl ] = $ rules [ $ oldIndex ] ; unset ( $ rules [ $ oldIndex ] ) ; } }
2535	public function getMessagesAndVersions ( ) { if ( empty ( $ this -> messagesAndVersions ) ) { $ this -> messagesAndVersions = WsdlAnalyser :: loadMessagesAndVersions ( $ this -> params -> wsdl ) ; } return $ this -> messagesAndVersions ; }
7214	public function debit ( $ account , $ amount , \ DateTime $ date ) { $ data = [ $ this -> date , $ account , $ this -> identity , null , $ amount , $ this -> number , $ date -> format ( 'Y-m-d' ) , ] ; if ( false === fputcsv ( $ this -> handle , $ data , ';' , '"' ) ) { throw new RuntimeException ( "Failed to write line." ) ; } }
10419	public static function parse ( $ path ) { if ( ! file_exists ( $ path ) ) { throw new Exception ( 'The give file ' . $ path . ' doesn\'t exist.' ) ; } return Yaml :: parse ( file_get_contents ( $ path ) ) ; }
4581	private function getProperties ( Encryptable $ model ) : array { $ properties = [ ] ; $ reflection = new ReflectionObject ( $ model ) ; foreach ( $ reflection -> getProperties ( ) as $ property ) { $ annotation = $ this -> annotationReader -> getPropertyAnnotation ( $ property , Encrypt :: class ) ; if ( ! $ annotation ) { continue ; } if ( null !== $ annotation -> applicable && ! $ this -> expressionLanguage -> evaluate ( $ annotation -> applicable , [ 'object' => $ model ] ) ) { continue ; } $ properties [ ] = $ property ; } return $ properties ; }
3408	public function getLockFactory ( ) : Factory { if ( $ this -> lockFactory !== null ) { return $ this -> lockFactory ; } if ( ! is_dir ( $ this -> lockPath ) ) { ( new Filesystem ( ) ) -> mkdir ( $ this -> lockPath ) ; } $ store = new FlockStore ( $ this -> lockPath ) ; return $ this -> setLockStore ( $ store ) ; }
6425	public function getLoginStartUrl ( $ redirecturl ) { $ client = $ this -> getClient ( $ redirecturl ) ; $ authUrl = $ client -> createAuthUrl ( ) ; return $ authUrl ; }
6055	public function addMediaToFolder ( $ folderId , array $ mediaIds ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'mediaIds' => $ mediaIds ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/folders/' . $ folderId . '/media' , $ parameters ) ; return $ result ; }
3496	private function doSend ( Receiver $ receiver , Notification $ notification , bool $ sandbox ) : void { $ payloadEncoded = $ this -> payloadEncoder -> encode ( $ notification -> getPayload ( ) ) ; $ uri = $ this -> uriFactory -> create ( $ receiver -> getToken ( ) , $ sandbox ) ; $ request = new Request ( $ uri , $ payloadEncoded ) ; $ headers = [ 'content-type' => 'application/json' , 'accept' => 'application/json' , 'apns-topic' => $ receiver -> getTopic ( ) , ] ; $ request = $ request -> withHeaders ( $ headers ) ; $ request = $ this -> authenticator -> authenticate ( $ request ) ; $ request = $ this -> visitor -> visit ( $ notification , $ request ) ; $ response = $ this -> httpSender -> send ( $ request ) ; if ( $ response -> getStatusCode ( ) !== 200 ) { throw $ this -> exceptionFactory -> create ( $ response ) ; } }
8980	private function buildRateFromTableRowData ( array $ row ) { return new Rate ( $ row [ 'source_name' ] , ( float ) $ row [ 'rate_value' ] , $ row [ 'currency_code' ] , $ row [ 'rate_type' ] , \ DateTime :: createFromFormat ( 'Y-m-d' , $ row [ 'rate_date' ] ) , $ row [ 'base_currency_code' ] , \ DateTime :: createFromFormat ( 'Y-m-d H:i:s' , $ row [ 'created_at' ] ) , \ DateTime :: createFromFormat ( 'Y-m-d H:i:s' , $ row [ 'modified_at' ] ) ) ; }
11882	private function prepareFieldOptions ( CustomField $ customField , $ type ) { $ options = $ customField -> getOptions ( ) ; $ fieldOptions = array ( ) ; $ fieldOptions [ 'required' ] = False ; $ fieldOptions [ 'label' ] = $ this -> translatableStringHelper -> localize ( $ customField -> getName ( ) ) ; if ( $ options [ self :: MIN ] !== NULL ) { $ fieldOptions [ 'constraints' ] [ ] = new GreaterThanOrEqual ( array ( 'value' => $ options [ self :: MIN ] ) ) ; } if ( $ options [ self :: MAX ] !== NULL ) { $ fieldOptions [ 'constraints' ] [ ] = new LessThanOrEqual ( array ( 'value' => $ options [ self :: MAX ] ) ) ; } if ( $ type === 'number' ) { $ fieldOptions [ 'scale' ] = $ options [ self :: SCALE ] ; } if ( ! empty ( $ options [ self :: POST_TEXT ] ) ) { $ fieldOptions [ 'post_text' ] = $ options [ self :: POST_TEXT ] ; } return $ fieldOptions ; }
5845	public function execute ( ) { $ configuration = ConfigurationController :: readConfiguration ( ) ; $ this -> imageResizer = GeneralUtility :: makeInstance ( \ Causal \ ImageAutoresize \ Service \ ImageResizer :: class ) ; $ this -> imageResizer -> initializeRulesets ( $ configuration ) ; if ( empty ( $ this -> directories ) ) { $ directories = $ this -> imageResizer -> getAllDirectories ( ) ; } else { $ directories = GeneralUtility :: trimExplode ( LF , $ this -> directories , true ) ; } $ processedDirectories = [ ] ; $ expandedDirectories = [ ] ; foreach ( $ directories as $ directory ) { if ( ( $ pos = strpos ( $ directory , '/*' ) ) !== false ) { $ pattern = $ this -> imageResizer -> getDirectoryPattern ( $ directory ) ; $ basePath = substr ( $ directory , 0 , $ pos + 1 ) ; $ objects = new \ RecursiveIteratorIterator ( new \ RecursiveDirectoryIterator ( PATH_site . $ basePath ) , \ RecursiveIteratorIterator :: SELF_FIRST ) ; foreach ( $ objects as $ name => $ object ) { $ relativePath = substr ( $ name , strlen ( PATH_site ) ) ; if ( substr ( $ relativePath , - 2 ) === DIRECTORY_SEPARATOR . '.' ) { if ( preg_match ( $ pattern , $ relativePath ) ) { $ expandedDirectories [ ] = substr ( $ relativePath , 0 , - 1 ) ; } } } } else { $ expandedDirectories [ ] = $ directory ; } } $ directories = $ expandedDirectories ; $ success = true ; foreach ( $ directories as $ directory ) { $ skip = false ; foreach ( $ processedDirectories as $ processedDirectory ) { if ( GeneralUtility :: isFirstPartOfStr ( $ directory , $ processedDirectory ) ) { continue 2 ; } } $ success |= $ this -> batchResizePictures ( $ directory ) ; $ processedDirectories [ ] = $ directory ; } return $ success ; }
11612	protected function _resolveContainer ( BaseContainerInterface $ container ) { $ parent = null ; while ( $ container instanceof ContainerAwareInterface ) { $ parent = $ container -> getContainer ( ) ; if ( ! ( $ parent instanceof BaseContainerInterface ) ) { break ; } $ container = $ parent ; } return $ container ; }
12089	public function destroy ( UserPolicy $ user , Response $ response ) { return $ response -> user_id == user_id ( ) && $ response -> user_type == user_type ( ) ; }
10045	private function createFromType ( Model $ model , Column $ column , $ item ) { $ result = null ; switch ( $ column -> getType ( ) ) { case Type :: TEXT : case Type :: TARRAY : case Type :: SIMPLE_ARRAY : case Type :: JSON_ARRAY : case Type :: OBJECT : case Type :: BLOB : $ result = new TextAreaFormItem ( ) ; break ; case Type :: INTEGER : case Type :: SMALLINT : case Type :: BIGINT : $ result = new IntegerFormItem ( ) ; break ; case Type :: DECIMAL : case Type :: FLOAT : $ result = new NumberFormItem ( ) ; break ; case Type :: BOOLEAN : $ result = new CheckboxFormItem ( ) ; break ; case Type :: DATE : $ result = new DateFormItem ( ) ; break ; case Type :: DATETIME : case Type :: DATETIMETZ : $ result = new DateTimeFormItem ( ) ; break ; case Type :: TIME : $ result = new TimeFormItem ( ) ; break ; case Type :: STRING : case Type :: GUID : default : $ result = new TextFormItem ( ) ; break ; } $ columnName = $ column -> getName ( ) ; $ result -> setName ( $ columnName ) ; $ result -> setLabel ( Lang :: trans ( $ this -> aujaConfigurator -> getColumnDisplayName ( $ model , $ columnName ) ) ) ; if ( $ item != null && isset ( $ item -> $ columnName ) ) { $ result -> setValue ( $ item -> $ columnName ) ; } return $ result ; }
12467	public function renderFormAction ( $ id , Request $ request ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ entity = $ em -> getRepository ( 'ChillCustomFieldsBundle:CustomFieldsGroup' ) -> find ( $ id ) ; if ( ! $ entity ) { throw $ this -> createNotFoundException ( 'Unable to find CustomFieldsGroups entity.' ) ; } $ form = $ this -> createForm ( 'custom_field' , null , array ( 'group' => $ entity ) ) ; $ form -> add ( 'submit_dump' , 'submit' , array ( 'label' => 'POST AND DUMP' ) ) ; $ form -> add ( 'submit_render' , 'submit' , array ( 'label' => 'POST AND RENDER' ) ) ; $ form -> handleRequest ( $ request ) ; $ this -> get ( 'twig.loader' ) -> addPath ( __DIR__ . '/../Tests/Fixtures/App/app/Resources/views/' , $ namespace = 'test' ) ; if ( $ form -> isSubmitted ( ) ) { if ( $ form -> get ( 'submit_render' ) -> isClicked ( ) ) { return $ this -> render ( 'ChillCustomFieldsBundle:CustomFieldsGroup:render_for_test.html.twig' , array ( 'fields' => $ form -> getData ( ) , 'customFieldsGroup' => $ entity ) ) ; } var_dump ( $ form -> getData ( ) ) ; var_dump ( json_enccode ( $ form -> getData ( ) ) ) ; } return $ this -> render ( '@test/CustomField/simple_form_render.html.twig' , array ( 'form' => $ form -> createView ( ) ) ) ; }
10858	public function eachMarked ( callable $ callback , $ result = null ) { $ ref = new \ ReflectionFunction ( $ callback ) ; $ params = $ ref -> getParameters ( ) ; if ( \ count ( $ params ) < 2 ) { throw new \ InvalidArgumentException ( \ sprintf ( 'Callback for marker processing must declare at least 2 arguments (object and marker)' ) ) ; } try { $ markerType = $ params [ 1 ] -> getClass ( ) ; } catch ( \ ReflectionException $ e ) { throw new \ InvalidArgumentException ( \ sprintf ( 'Marker class not found: %s' , $ params [ 1 ] -> getType ( ) ) , 0 , $ e ) ; } if ( $ markerType === null ) { throw new \ InvalidArgumentException ( \ sprintf ( 'Argument #2 of marker callback needs to declare a type-hint for the marker' ) ) ; } $ marker = $ markerType -> getName ( ) ; if ( ! $ markerType -> isSubclassOf ( Marker :: class ) ) { throw new \ InvalidArgumentException ( \ sprintf ( 'Marker implementation %s must extend %s' , $ marker , Marker :: class ) ) ; } if ( ! isset ( $ this -> marked [ $ marker ] ) ) { $ this -> cacheMarkers ( $ marker ) ; } foreach ( $ this -> marked [ $ marker ] as list ( $ definition , $ registration ) ) { $ result = $ callback ( $ this -> shared [ $ definition -> typeName ] ?? $ this -> get ( $ definition -> typeName ) , clone $ registration , $ result ) ; } return $ result ; }
1315	public function get ( $ path , array $ parameters = [ ] ) { return $ this -> http ( 'GET' , self :: API_HOST , $ path , $ parameters , false ) ; }
11301	public function getFieldName ( $ attributeName ) { if ( isset ( $ this -> model_attributes [ $ attributeName ] [ 'field' ] ) ) { return $ this -> model_attributes [ $ attributeName ] [ 'field' ] ; } return $ attributeName ; }
6288	private function buildResponse ( ReactResponse $ response , StreamInterface $ body ) { $ body -> rewind ( ) ; return $ this -> responseFactory -> createResponse ( $ response -> getCode ( ) , $ response -> getReasonPhrase ( ) , $ response -> getHeaders ( ) , $ body , $ response -> getVersion ( ) ) ; }
5306	protected function transformPath ( $ path , $ scale , $ roundPrecision , $ flip , $ xOffset , $ yOffset ) { if ( $ flip === 'horizontal' || $ flip === 'vertical' ) { $ viewBox = $ this -> getViewBox ( ) ; } return preg_replace_callback ( '([m,l,h,v,c,s,q,t,a,z](?:[\\s,]*-?(?=\\.?\\d)\\d*(?:\\.\\d+)?)*)i' , function ( $ maches ) use ( $ scale , $ roundPrecision , $ flip , $ xOffset , $ yOffset , $ viewBox ) { $ command = substr ( $ maches [ 0 ] , 0 , 1 ) ; $ absoluteCommand = strtoupper ( $ command ) === $ command ; $ xyCommand = in_array ( strtolower ( $ command ) , array ( 'm' , 'l' , 'c' , 's' , 'q' , 't' ) ) ; $ xCommand = strtolower ( $ command ) === 'h' ; $ yCommand = strtolower ( $ command ) === 'v' ; if ( strtolower ( $ command ) === 'z' ) { return $ command ; } if ( strtolower ( $ command ) === 'a' ) { throw new \ Exception ( 'Path command "A" is currently not supportet!' ) ; } $ values = $ this -> getValuesFromList ( substr ( $ maches [ 0 ] , 1 ) ) ; foreach ( $ values as $ key => $ value ) { if ( $ flip === 'horizontal' && ( ( ! ( $ key % 2 ) && $ xyCommand ) || $ xCommand ) ) { $ values [ $ key ] *= - 1 ; if ( $ absoluteCommand ) { $ values [ $ key ] += $ viewBox [ 'width' ] ; } } if ( $ flip === 'vertical' && ( ( $ key % 2 && $ xyCommand ) || $ yCommand ) ) { $ values [ $ key ] *= - 1 ; if ( $ absoluteCommand ) { $ values [ $ key ] += $ viewBox [ 'height' ] ; } } if ( $ absoluteCommand && ( ( ! ( $ key % 2 ) && $ xyCommand ) || $ xCommand ) ) { $ values [ $ key ] += $ xOffset ; } if ( $ absoluteCommand && ( ( $ key % 2 && $ xyCommand ) || $ yCommand ) ) { $ values [ $ key ] += $ yOffset ; } $ values [ $ key ] *= $ scale ; if ( $ roundPrecision !== null ) { $ values [ $ key ] = round ( $ values [ $ key ] , $ roundPrecision ) ; } } return $ command . implode ( ' ' , $ values ) ; } , $ path ) ; }
9475	public function stripQuotes ( $ string ) { if ( strlen ( $ string ) < 2 || substr ( $ string , 0 , 1 ) !== '"' || substr ( $ string , - 1 , 1 ) !== '"' ) { return $ string ; } return substr ( $ string , 1 , - 1 ) ; }
12471	protected function setDatabaseFactoryNamespaces ( ) { $ this -> replaceIn ( $ this -> laravel -> databasePath ( ) . '/factories/ModelFactory.php' , $ this -> currentRoot , $ this -> argument ( 'name' ) ) ; }
2267	public function getFieldNames ( $ strTable , $ blnNoCache = false ) { $ arrNames = array ( ) ; $ arrFields = $ this -> listFields ( $ strTable , $ blnNoCache ) ; foreach ( $ arrFields as $ arrField ) { if ( $ arrField [ 'type' ] != 'index' ) { $ arrNames [ ] = $ arrField [ 'name' ] ; } } return $ arrNames ; }
8701	public function getString ( ) { $ this -> validateElement ( ) ; $ elementStringData = '' ; $ elementStringData = '<' . static :: TYPE ; foreach ( $ this -> attributes as $ key => $ data ) { $ elementStringData .= ' ' . $ key . '="' . $ data . '"' ; } $ elementStringData .= '>' ; if ( $ this -> text !== null ) { $ elementStringData .= $ this -> text ; } if ( count ( $ this -> childElements ) > 0 ) { if ( static :: TYPE == 'svg' ) { foreach ( $ this -> childElements as $ childElement ) { $ this -> defs = array_merge ( $ this -> defs , $ childElement -> getDefs ( ) ) ; } if ( count ( $ this -> defs ) > 0 ) { $ defArea = new \ SVGCreator \ Elements \ Defs ( ) ; foreach ( $ this -> defs as $ def ) { $ defArea -> append ( $ def ) ; } $ elementStringData .= $ defArea -> getString ( ) ; } } foreach ( $ this -> childElements as $ childElement ) { $ elementStringData .= $ childElement -> getString ( ) ; } } $ elementStringData .= '</' . static :: TYPE . '>' ; $ this -> elementString = $ elementStringData ; return $ this -> elementString ; }
8645	private function parseHttpHeader ( $ header ) { $ parsedHeader = array ( ) ; foreach ( explode ( "\n" , $ header ) as $ line ) { $ splitLine = preg_split ( '/:\s/' , $ line , 2 , PREG_SPLIT_NO_EMPTY ) ; if ( sizeof ( $ splitLine ) == 2 ) { $ k = strtolower ( trim ( $ splitLine [ 0 ] ) ) ; $ v = trim ( $ splitLine [ 1 ] ) ; if ( array_key_exists ( $ k , $ parsedHeader ) ) { $ parsedHeader [ $ k ] = $ parsedHeader [ $ k ] . "," . $ v ; } else { $ parsedHeader [ $ k ] = $ v ; } } } return $ parsedHeader ; }
6454	private function createNotAcceptableException ( string $ type ) : HttpException { $ headers = new HttpHeaders ( ) ; $ headers -> add ( 'Content-Type' , 'application/json' ) ; $ body = new StringBody ( json_encode ( $ this -> contentNegotiator -> getAcceptableResponseMediaTypes ( $ type ) ) ) ; $ response = new Response ( HttpStatusCodes :: HTTP_NOT_ACCEPTABLE , $ headers , $ body ) ; return new HttpException ( $ response ) ; }
7250	protected function validateDeliveryAddress ( SaleInterface $ sale , Constraint $ constraint ) { if ( ! $ sale -> isSameAddress ( ) && null === $ sale -> getDeliveryAddress ( ) ) { $ this -> context -> buildViolation ( $ constraint -> delivery_address_is_required ) -> atPath ( 'deliveryAddress' ) -> addViolation ( ) ; } elseif ( $ sale -> isSameAddress ( ) && null !== $ sale -> getDeliveryAddress ( ) ) { $ this -> context -> buildViolation ( $ constraint -> delivery_address_should_be_null ) -> atPath ( 'deliveryAddress' ) -> addViolation ( ) ; } }
4781	public function addWidgetConfig ( string $ widgetId , array $ config = [ ] ) { $ this -> config [ $ widgetId ] = array_merge ( $ this -> config [ $ widgetId ] ?? [ ] , $ config ) ; return $ this ; }
6376	public function sorted ( Comparator $ comparator ) : FluentIterable { $ array = $ this -> toArray ( ) ; Arrays :: sort ( $ array , $ comparator ) ; return self :: of ( $ array ) ; }
7844	public function device ( ? int $ id = null ) : ? array { if ( is_null ( $ id ) ) { $ id = $ this -> device ; } $ key = sprintf ( 'smsgatewayme.device.%s' , $ id ) ; $ device = Cache :: remember ( $ key , 3600 * 24 * 7 , function ( ) use ( & $ response , $ id ) { $ response = Request :: get ( $ this -> baseUrl . 'device/' . $ id ) ; if ( $ response -> code != 200 ) { if ( ! empty ( $ response -> body -> message ) ) { Log :: error ( $ response -> body -> message ) ; } } return $ response -> body ; } ) ; return [ 'code' => $ response -> code ?? 200 , 'message' => 'OK' , 'data' => $ device , ] ; }
9548	public function validate ( UploadedFile $ file ) { foreach ( $ this -> constraints as $ constraint ) { if ( ! $ constraint -> validate ( $ file ) ) { throw new ConstraintException ( $ constraint , $ file ) ; } } return true ; }
1764	private function canRunDbQuery ( ) : bool { try { return $ this -> connection -> isConnected ( ) && $ this -> connection -> getSchemaManager ( ) -> tablesExist ( [ 'tl_cron' ] ) ; } catch ( DriverException $ e ) { return false ; } }
10405	public function set ( $ key , $ value ) { $ pair = $ this -> repository -> find ( $ key ) ; if ( $ pair === null ) { $ pair = new Pair ( ) ; $ pair -> setId ( $ key ) ; } $ pair -> setValue ( $ value ) ; $ this -> save ( $ pair ) ; return $ pair ; }
8279	public function onRequestFile ( & $ file ) { if ( $ this -> errorOccurred ) { $ file = $ this -> requestFile ; return ; } try { $ realUrl = ( $ this -> requestFile ) ? $ this -> requestUrl : $ this -> resolveRealUrl ( $ file ) ; if ( ! in_array ( $ realUrl , $ this -> alwaysAllowed , true ) ) { $ this -> triggerEvent ( 'denyAccessIfRestricted' , [ $ realUrl ] ) ; } } catch ( \ Exception $ e ) { $ realUrl = ( isset ( $ realUrl ) ) ? $ realUrl : "" ; $ this -> errorHandler ( $ e , $ realUrl ) ; } if ( $ this -> requestFile ) { $ file = $ this -> requestFile ; } else { switch ( $ this -> requestUrl ) { case 'login' : $ file = $ this -> pluginDir . '/content/login.md' ; break ; case 'logout' : $ file = $ this -> pluginDir . '/content/logout.md' ; break ; } } }
11972	protected function validateParams ( Event $ event ) { return ( $ this -> genericParamValidation ( $ event ) && $ this -> firstParamValidation ( $ event ) && $ this -> secondParamValidation ( $ event ) ) ; }
3481	private static function includeConfigurationFile ( ) { static $ included = false ; if ( $ included ) { return ; } $ file = __DIR__ . '/config.php' ; if ( ! file_exists ( $ file ) ) { print sprintf ( 'The configuration file "%s" was not found.%sPlease copy %s/config.php.dist to %s/config.php and modify new file for set own parameters.%s' , $ file , PHP_EOL , __DIR__ , __DIR__ , PHP_EOL ) ; exit ( 1 ) ; } $ included = true ; include_once $ file ; }
5378	public function wrapIsEnabled ( ) { if ( $ this -> getAttribute ( 'cols' ) ) { $ wrap = $ this -> getAttribute ( 'wrap' ) ; if ( ( $ wrap === 'physical' ) || ( $ wrap === 'hard' ) ) { return true ; } } return false ; }
4573	public function getProperties ( Auditable $ entity ) { $ reflection = new ReflectionObject ( $ entity ) ; $ properties = [ ] ; foreach ( $ reflection -> getProperties ( ) as $ key => $ property ) { if ( ! $ this -> annotationReader -> getPropertyAnnotation ( $ property , AuditAnnotation :: class ) ) { continue ; } $ properties [ ] = $ property -> name ; } return $ properties ; }
7466	public function moveUploadedFile ( ) { $ this -> dateCreated = new DateTime ( ) ; if ( null === $ this -> _uploadedFile ) { return ; } $ this -> _uploadedFile -> move ( dirname ( $ this -> path ) , basename ( $ this -> path ) ) ; $ this -> _uploadedFile = null ; }
9350	public function transpose ( ) { $ out = new self ( $ this -> size -> cols , $ this -> size -> rows ) ; foreach ( $ this -> arr as $ row ) { $ out -> addCol ( $ row ) ; } return $ out ; }
10716	public function deleteMany ( ArrayAccess $ models ) { $ results = [ ] ; foreach ( $ models as $ model ) { $ results [ ] = $ this -> delete ( $ model ) ; } return $ this -> returnResults ( $ results ) ; }
7822	protected function refreshPipelines ( ) { $ yaml = $ this -> parser -> dump ( $ this -> pipelines ) ; $ this -> files -> put ( $ this -> getSource ( ) , $ yaml ) ; }
3505	private function convertApsToArray ( Aps $ aps ) : array { $ data = [ 'alert' => $ this -> convertAlertToArray ( $ aps -> getAlert ( ) ) , ] ; if ( $ aps -> getSound ( ) ) { $ data [ 'sound' ] = $ aps -> getSound ( ) ; } if ( $ aps -> getBadge ( ) !== null ) { $ data [ 'badge' ] = $ aps -> getBadge ( ) ; } if ( $ aps -> getCategory ( ) ) { $ data [ 'category' ] = $ aps -> getCategory ( ) ; } if ( $ aps -> isContentAvailable ( ) ) { $ data [ 'content-available' ] = 1 ; } if ( $ aps -> isMutableContent ( ) ) { $ data [ 'mutable-content' ] = 1 ; } if ( $ aps -> getThreadId ( ) ) { $ data [ 'thread-id' ] = $ aps -> getThreadId ( ) ; } return $ data ; }
6499	public function beforeStep ( Scope \ StepScope $ scope ) { self :: $ pageUrl = $ this -> getCurrentUrl ( ) ; $ _GET [ 'q' ] = ltrim ( parse_url ( static :: $ pageUrl ) [ 'path' ] , '/' ) ; drupal_path_initialize ( ) ; }
1498	public function merge ( EncodingList $ encodings ) : self { $ copy = new self ( ) ; $ copy -> stack = collect ( $ this -> stack ) -> merge ( $ encodings -> stack ) -> all ( ) ; return $ copy ; }
4729	public function isSingular ( $ word ) { $ inflection = $ this -> getCachedPlural ( $ word ) ; if ( $ inflection !== false ) { return true ; } $ pluralWord = $ this -> toPlural ( $ word ) ; if ( $ pluralWord === false ) { return false ; } return $ this -> toSingular ( $ pluralWord ) == $ word ; }
8722	public function translate ( $ locale ) { $ found = $ this -> translations -> where ( $ this -> getLocaleKey ( ) , $ locale ) -> first ( ) ; if ( ! $ found && $ this -> shouldFallback ( $ locale ) ) { return $ this -> translate ( $ this -> getFallbackLocale ( ) ) ; } return $ found ; }
5238	private function methodBindingName ( \ ReflectionMethod $ method ) { $ annotations = annotationsOf ( $ method ) ; if ( $ annotations -> contain ( 'List' ) ) { return $ annotations -> firstNamed ( 'List' ) -> getValue ( ) ; } if ( $ annotations -> contain ( 'Map' ) ) { return $ annotations -> firstNamed ( 'Map' ) -> getValue ( ) ; } if ( $ annotations -> contain ( 'Named' ) ) { return $ annotations -> firstNamed ( 'Named' ) -> getName ( ) ; } if ( $ annotations -> contain ( 'Property' ) ) { return $ annotations -> firstNamed ( 'Property' ) -> getValue ( ) ; } return null ; }
11205	public function merge ( $ data , $ key = false , $ dataKey = false ) { if ( $ data != false && ( is_array ( $ data ) || is_object ( $ data ) ) ) { foreach ( $ data as $ item ) { $ this -> add ( $ item , $ key , $ dataKey , true ) ; } } else { $ this -> add ( $ data , $ key , $ dataKey ) ; } return $ this ; }
10566	protected function formatJsonp ( $ response ) { $ response -> getHeaders ( ) -> set ( 'Content-Type' , 'application/javascript; charset=UTF-8' ) ; if ( is_array ( $ response -> data ) && isset ( $ response -> data [ 'data' ] , $ response -> data [ 'callback' ] ) ) { $ response -> content = sprintf ( '%s(%s);' , $ response -> data [ 'callback' ] , Json :: htmlEncode ( $ response -> data [ 'data' ] ) ) ; } elseif ( $ response -> data !== null ) { $ response -> content = '' ; Yii :: warning ( "The 'jsonp' response requires that the data be an array consisting of both 'data' and 'callback' elements." , __METHOD__ ) ; } }
6030	public function setChildMedias ( array $ childMedias ) { $ this -> childMedias = [ ] ; foreach ( $ childMedias as $ item ) { $ this -> addself ( $ item ) ; } return $ this ; }
1646	public function getLength ( DistanceInterface $ calculator ) : float { $ distance = 0.0 ; if ( count ( $ this -> points ) <= 1 ) { return $ distance ; } foreach ( $ this -> getSegments ( ) as $ segment ) { $ distance += $ segment -> getLength ( $ calculator ) ; } return $ distance ; }
8671	public static function combine ( $ keys , $ values ) { $ keys = Arr :: from ( $ keys ) ; $ values = Arr :: from ( $ values ) ; if ( count ( $ keys ) !== count ( $ values ) ) { throw new InvalidArgumentException ( 'The size of keys and values needs to be the same.' ) ; } if ( count ( $ keys ) === 0 ) { return new static ( ) ; } return new static ( array_combine ( $ keys , $ values ) ) ; }
12	public function setOptimizeAutoloader ( $ optimizeAutoloader = false ) { $ this -> optimizeAutoloader = ( bool ) $ optimizeAutoloader ; if ( ! $ this -> optimizeAutoloader ) { $ this -> setClassMapAuthoritative ( false ) ; } return $ this ; }
4856	public function setParams ( $ namespace , $ params ) { $ session = new Container ( $ namespace ) ; $ session -> params = $ params ; unset ( $ session -> list ) ; return $ this ; }
7269	public function belongsTo ( $ refClass , $ forColumn = null ) { $ refTable = $ refClass :: tableName ( ) ; $ forTable = static :: tableName ( ) ; $ refColumn = $ refClass :: $ idColumn ; $ forColumn = $ forColumn ? : strtolower ( $ refClass :: modelName ( ) ) . "_id" ; $ rows = Db :: query ( " select R.* from $refTable as R, $forTable as F where R.$refColumn = F.$forColumn and F.$forColumn = :id " , [ "id" => $ this -> $ forColumn ] , static :: getDbName ( ) ) ; if ( $ rows === false ) return false ; if ( empty ( $ rows ) ) return null ; $ refModel = new $ refClass ; foreach ( $ rows [ 0 ] as $ col => $ val ) $ refModel -> $ col = $ refModel -> decodeValue ( $ val , $ col ) ; return $ refModel ; }
8895	protected function _initialize_event_listeners ( ) { foreach ( $ this -> event_listeners as $ event_listener => $ e ) { if ( isset ( $ this -> $ event_listener ) && ! empty ( $ this -> $ event_listener ) ) { foreach ( $ this -> $ event_listener as $ event ) { $ this -> subscribe ( $ event_listener , $ event ) ; } } } $ this -> subscribe ( 'before_update' , 'protect_attributes' , TRUE ) ; }
9369	protected function resolve ( ContainerInterface $ container , ServerRequestInterface $ request , ResponseInterface $ response ) { if ( class_exists ( 'Zend\Diactoros\ServerRequestFactory' ) ) { $ response = new ZendResponse ; $ request = ServerRequestFactory :: fromGlobals ( ) ; } $ container -> set ( 'Psr\Http\Message\ServerRequestInterface' , $ request ) ; return $ container -> set ( 'Psr\Http\Message\ResponseInterface' , $ response ) ; }
9583	public function addCachedRoute ( Route $ route ) { $ this -> routes -> attach ( $ route ) ; if ( $ name = $ route -> getName ( ) ) { $ this -> addNamedRoute ( $ name , $ route ) ; } }
7228	protected function parseHeader ( $ curl , $ header ) { if ( preg_match ( "/^([^:\s]+)\:\s+(.*)$/" , $ header , $ matches ) ) { $ matches [ 2 ] = trim ( $ matches [ 2 ] ) ; $ this -> lastHeader [ $ matches [ 1 ] ] = $ matches [ 2 ] ; $ this -> lastResultType = $ matches [ 1 ] === "Content-Type" ? $ matches [ 2 ] : $ this -> lastResultType ; } return strlen ( $ header ) ; }
5165	public function render ( DataBuilder $ data_builder , $ parameters , array $ data = [ ] ) { $ parameters = $ this -> castParameters ( $ parameters ) ; $ tm = new TemplateManager ( ) ; $ result = new Result ( ) ; try { $ bag = new Bag ( $ parameters ) ; $ bag -> set ( 'body' , $ tm -> renderRaw ( 'text/html' , strval ( $ bag -> get ( 'body' ) ) , $ data ) ) ; $ attachments = [ ] ; foreach ( ( array ) Yaml :: parse ( strval ( $ bag -> get ( 'attachments' ) ) ) as $ key => $ attachment ) { $ attachment = ( object ) $ attachment ; $ attachments [ $ key ] [ 'as' ] = strval ( $ tm -> renderRaw ( 'text/plain' , $ attachment -> as , $ data ) ) ; $ attachments [ $ key ] [ 'source' ] = strval ( $ tm -> renderRaw ( 'text/plain' , $ attachment -> source , $ data ) ) ; } $ bag -> set ( 'attachments' , $ attachments ) ; $ bag -> set ( 'recipients' , explode ( ',' , $ tm -> renderRaw ( 'text/plain' , strval ( $ bag -> get ( 'recipients' ) ) , $ data ) ) ) ; $ bag -> set ( 'subject' , $ tm -> renderRaw ( 'text/plain' , strval ( $ bag -> get ( 'subject' ) ) , $ data ) ) ; $ bag -> set ( 'sender' , $ tm -> renderRaw ( 'text/plain' , strval ( $ bag -> get ( 'sender' ) ) , $ data ) ) ; $ result -> setResources ( new Collection ( [ $ bag -> toArray ( ) ] ) ) ; } catch ( \ Twig_Error $ e ) { $ e = new Exceptions \ EmailSenderRenderException ( $ e -> getRawMessage ( ) . ' on line ' . $ e -> getTemplateLine ( ) ) ; $ result -> addErrors ( new Collection ( [ $ e ] ) ) ; } return $ result ; }
12933	protected function generateContent ( $ type , $ id , $ name , $ language ) { $ content = new Content ( ) ; $ content -> setContentId ( $ id ) ; $ content -> setContentType ( $ type ) ; $ content -> setDeleted ( false ) ; $ content -> setName ( $ name ) ; $ content -> setLanguage ( $ language ) ; $ content -> setStatus ( $ this -> getReference ( 'status-published' ) ) ; $ content -> setVersion ( '1' ) ; $ content -> setSiteId ( '2' ) ; $ date = new \ DateTime ( "now" ) ; $ content -> setVersionName ( $ content -> getName ( ) . '_' . $ date -> format ( "Y-m-d_H:i:s" ) ) ; return $ content ; }
10188	function fromXML ( $ xmlElement ) { if ( isset ( $ xmlElement -> id ) ) $ this -> id = $ xmlElement -> id ; if ( isset ( $ xmlElement -> name ) ) $ this -> name = $ xmlElement -> name ; if ( isset ( $ xmlElement -> active ) ) $ this -> active = $ xmlElement -> active ; if ( isset ( $ xmlElement -> anonymizable ) ) $ this -> anonymizable = $ xmlElement -> anonymizable ; if ( isset ( $ xmlElement -> description ) ) $ this -> description = $ xmlElement -> description ; if ( isset ( $ xmlElement -> created ) ) $ this -> created = $ xmlElement -> created ; if ( isset ( $ xmlElement -> updated ) ) $ this -> updated = $ xmlElement -> updated ; if ( isset ( $ xmlElement -> attributes ) ) { $ this -> attributes = array ( ) ; foreach ( $ xmlElement -> attributes -> children ( ) as $ xmlAttribute ) { $ attribute = array ( ) ; if ( isset ( $ xmlAttribute -> name ) ) $ attribute [ 'name' ] = trim ( $ xmlAttribute -> name ) ; if ( isset ( $ xmlAttribute -> datatype ) ) $ attribute [ 'datatype' ] = DataType :: getDataType ( $ xmlAttribute -> datatype ) ; if ( isset ( $ xmlAttribute -> description ) ) $ attribute [ 'description' ] = trim ( $ xmlAttribute -> description ) ; if ( isset ( $ xmlAttribute -> required ) ) $ attribute [ 'required' ] = $ xmlAttribute -> required ; array_push ( $ this -> attributes , $ attribute ) ; } } }
982	public function index ( Plan $ plan ) { if ( is_null ( $ plan ) || ( $ plan && ! $ plan -> exists ) ) { $ plan = Plan :: where ( 'on_install' , true ) -> first ( ) ; } $ bp = new BillingPlan ( ShopifyApp :: shop ( ) , $ plan ) ; $ url = $ bp -> confirmationUrl ( ) ; return View :: make ( 'shopify-app::billing.fullpage_redirect' , compact ( 'url' ) ) ; }
184	public function init ( ) { parent :: init ( ) ; $ this -> cache = $ this -> enabled ? Instance :: ensure ( $ this -> cache , 'yii\caching\CacheInterface' ) : null ; if ( $ this -> cache instanceof CacheInterface && $ this -> getCachedContent ( ) === false ) { $ this -> getView ( ) -> pushDynamicContent ( $ this ) ; ob_start ( ) ; ob_implicit_flush ( false ) ; } }
9522	public function upsertDoc ( string $ collectionName , string $ docId , array $ docOrSubset ) : void { $ doc = $ this -> getDoc ( $ collectionName , $ docId ) ; if ( $ doc ) { $ this -> updateDoc ( $ collectionName , $ docId , $ docOrSubset ) ; } else { $ this -> addDoc ( $ collectionName , $ docId , $ docOrSubset ) ; } }
11466	public static function writeLogLine ( $ log_file , $ input , $ timestamp = null ) { if ( is_null ( self :: $ _error_folder ) ) { return false ; } $ log_file = basename ( $ log_file ) ; $ fp = @ fopen ( self :: $ _error_folder . $ log_file , 'ab' ) ; if ( ! $ fp ) { return false ; } if ( empty ( $ timestamp ) ) { $ timestamp = time ( ) ; } $ line = [ ] ; $ line [ ] = date ( \ DateTime :: ISO8601 , $ timestamp ) ; if ( $ input instanceof \ Throwable ) { $ message = $ input -> getMessage ( ) ; if ( ! ( $ input instanceof BaseException ) ) { $ message = preg_replace ( '/\s+/' , ' ' , $ message ) ; } $ line [ ] = BaseException :: getShortName ( get_class ( $ input ) ) ; $ line [ ] = $ message ; $ line [ ] = $ input -> getFile ( ) ; $ line [ ] = $ input -> getLine ( ) ; $ line_out = vsprintf ( '[%s] %s: %s in %s on line %d' , $ line ) ; } elseif ( is_string ( $ input ) ) { $ line [ ] = $ input ; $ line_out = vsprintf ( '[%s] %s' , $ line ) ; } else { return false ; } if ( flock ( $ fp , LOCK_EX ) ) { fwrite ( $ fp , $ line_out . PHP_EOL ) ; flock ( $ fp , LOCK_UN ) ; fclose ( $ fp ) ; return true ; } else { return false ; } }
4890	public function renderPage ( PageInterface $ page , $ vars = array ( ) ) { return $ this -> render ( $ this -> getPageManager ( ) -> getTemplate ( $ page ) , $ vars + array ( 'page' => $ page , 'id' => $ page -> getId ( ) , ) ) ; }
12943	public function authenticate ( AdapterInterface $ adapter = null ) { $ event = clone $ this -> getEvent ( ) ; $ event -> setName ( AuthenticationEvent :: EVENT_AUTH ) ; if ( ! $ adapter ) { $ adapter = $ this -> getAdapter ( ) ; } if ( $ adapter ) { $ event -> setAdapter ( $ adapter ) ; } $ this -> getEventManager ( ) -> trigger ( $ event ) ; return $ event -> getResult ( ) ; }
8898	public function update ( $ primary_value , $ data ) { $ data = $ this -> _do_pre_update ( $ data ) ; if ( $ data !== FALSE ) { $ result = $ this -> _database -> where ( $ this -> primary_key , $ primary_value ) -> set ( $ data ) -> update ( $ this -> _table ) ; $ this -> trigger ( 'after_update' , array ( $ data , $ result ) ) ; return $ result ; } else { return FALSE ; } }
2470	public function getMaxDepthForContent ( ContentType $ contentType ) : int { if ( isset ( $ this -> contentTypeMap [ $ contentType -> identifier ] ) ) { return $ this -> contentTypeMap [ $ contentType -> identifier ] ; } return $ this -> defaultIndexingDepth ; }
88	public function equals ( Rule $ rule ) { if ( $ rule instanceof self ) { if ( $ this -> literal1 !== $ rule -> literal1 ) { return false ; } if ( $ this -> literal2 !== $ rule -> literal2 ) { return false ; } return true ; } $ literals = $ rule -> getLiterals ( ) ; if ( 2 != count ( $ literals ) ) { return false ; } if ( $ this -> literal1 !== $ literals [ 0 ] ) { return false ; } if ( $ this -> literal2 !== $ literals [ 1 ] ) { return false ; } return true ; }
4486	public function broadcast ( Message $ message , ? string $ platform = null ) { if ( null !== $ platform && ! isset ( $ this -> arns [ $ platform ] ) ) { throw new PlatformNotConfiguredException ( "There is no configured ARN for $platform" ) ; } if ( $ platform ) { $ this -> broadcastToPlatform ( $ message , $ platform ) ; } else { foreach ( $ this -> arns as $ platform => $ arn ) { $ this -> broadcastToPlatform ( $ message , $ platform ) ; } } }
12577	public function previewNewsByName ( $ message , $ to ) { return $ this -> preview ( self :: MSG_TYPE_NEWS , $ message , $ to , self :: PREVIEW_BY_NAME ) ; }
8734	public function increment ( $ column , $ amount = 1 , array $ extra = [ ] ) { $ extra = $ this -> addUpdatedAtColumn ( $ extra ) ; return $ this -> noTranslationsQuery ( ) -> increment ( $ column , $ amount , $ extra ) ; }
6719	private function handleAuthorizeResponse ( $ response ) { $ status = ArrayHelper :: getValue ( $ response , 'status' ) ; if ( ! is_null ( $ status ) && $ status == 'success' ) { $ code = ArrayHelper :: getValue ( $ response , 'data.code' ) ; if ( is_null ( $ code ) ) { throw new Oauth2ClientException ( self :: CODE_NOT_SET ) ; } return $ code ; } else { $ message = ArrayHelper :: getValue ( $ response , 'message' , self :: DEFAULT_ERROR ) ; throw new Oauth2ClientException ( $ message ) ; } }
5554	public function getHeaders ( ) { if ( is_integer ( $ this -> focus ) ) { return $ this -> frames [ $ this -> focus ] -> getHeaders ( ) ; } return $ this -> frameset -> getHeaders ( ) ; }
6361	public function toDateInterval ( float $ duration ) : DateInterval { Preconditions :: checkState ( $ this -> dateIntervalFormat !== null , '[%s] does not support toDateInterval()' , $ this ) ; return new DateInterval ( sprintf ( $ this -> dateIntervalFormat , $ duration ) ) ; }
12312	private function writeToWebDir ( $ file , $ contents ) { if ( ! $ this -> webDir ) { return ; } if ( ! is_writable ( $ this -> webDir ) ) { trigger_error ( sprintf ( 'Directory %s is not writeable' , $ this -> webDir ) ) ; return ; } $ destFile = $ this -> webDir . $ file ; $ destDir = dirname ( $ destFile ) ; if ( ! is_dir ( $ destDir ) ) { mkdir ( $ destDir , 0777 , true ) ; } file_put_contents ( $ destFile , $ contents ) ; }
10451	public function getTtl ( $ key ) { $ getResult = $ this -> getValue ( $ key ) ; $ unserialized = @ unserialize ( $ getResult ) ; if ( ! Util :: hasInternalExpireTime ( $ unserialized ) ) { throw new \ Exception ( 'Cannot retrieve ttl' ) ; } return $ this -> handleTtl ( $ key , $ unserialized [ 'ts' ] , $ unserialized [ 's' ] ) ; }
2929	public function keyExists ( $ key ) { $ allKeys = $ this -> getKeys ( ) ; if ( array_key_exists ( $ key , $ allKeys ) ) { return true ; } return false ; }
7167	private function getOptionsResolver ( ) { if ( null !== $ this -> optionsResolver ) { return $ this -> optionsResolver ; } $ resolver = new OptionsResolver ( ) ; $ resolver -> setDefaults ( [ 'private' => false , 'editable' => false , 'taxes_view' => true , 'ati' => null , 'locale' => \ Locale :: getDefault ( ) , 'template' => function ( Options $ options ) { if ( true === $ options [ 'editable' ] ) { return $ this -> editableTemplate ; } return $ this -> defaultTemplate ; } , ] ) -> setAllowedTypes ( 'private' , 'bool' ) -> setAllowedTypes ( 'editable' , 'bool' ) -> setAllowedTypes ( 'taxes_view' , 'bool' ) -> setAllowedTypes ( 'ati' , [ 'null' , 'bool' ] ) -> setAllowedTypes ( 'locale' , 'string' ) -> setAllowedTypes ( 'template' , [ 'null' , 'string' ] ) ; return $ this -> optionsResolver = $ resolver ; }
4456	protected function fetchQueue ( string $ eventName ) : SplPriorityQueue { if ( isset ( $ this -> events [ $ eventName ] ) == false ) { $ this -> events [ $ eventName ] = $ this -> createQueue ( ) ; } return $ this -> events [ $ eventName ] ; }
5695	public function nestedFormSave ( $ data , $ form , $ request ) { $ formAction = $ this -> getFormActionFromRequest ( $ request ) ; $ actionName = $ formAction -> getButtonName ( ) ; $ this -> record -> $ actionName ( $ data , $ form , $ request ) ; return Controller :: curr ( ) -> redirectBack ( ) ; }
11874	protected function renewAccessToken ( ) { $ token = $ this -> authorizer -> getApi ( ) -> getAuthorizerToken ( $ this -> authorizer -> getAppId ( ) , $ this -> authorizer -> getRefreshToken ( ) ) ; $ this -> authorizer -> setAccessToken ( $ token [ 'authorizer_access_token' ] , $ token [ 'expires_in' ] - 1500 ) ; return $ token [ 'authorizer_access_token' ] ; }
12836	public function makeDirectory ( $ path , $ mode = 0755 , $ recursive = false ) { if ( ! file_exists ( $ path ) ) { return mkdir ( $ path , $ mode , $ recursive ) ; } return true ; }
140	public function markAliasInstalled ( RepositoryInterface $ repo , MarkAliasInstalledOperation $ operation ) { $ package = $ operation -> getPackage ( ) ; if ( ! $ repo -> hasPackage ( $ package ) ) { $ repo -> addPackage ( clone $ package ) ; } }
10507	private function registerFilesystem ( ) { $ this -> app -> singleton ( Contracts \ Utilities \ Filesystem :: class , function ( $ app ) { $ files = $ app [ 'files' ] ; $ filesystem = new Utilities \ Filesystem ( $ files , storage_path ( 'logs' ) ) ; $ filesystem -> setPattern ( Utilities \ Filesystem :: PATTERN_PREFIX , Utilities \ Filesystem :: PATTERN_DATE , Utilities \ Filesystem :: PATTERN_EXTENSION ) ; return $ filesystem ; } ) ; $ this -> app -> singleton ( 'arcanedev.log-viewer.filesystem' , Contracts \ Utilities \ Filesystem :: class ) ; }
7292	public function get_users_by_meta ( $ meta_key , $ meta_value = '' , $ meta_compare = '' , $ include_empty = FALSE ) { if ( $ include_empty ) { if ( in_array ( $ meta_compare , array ( '<>' , '!=' ) ) ) { $ meta_compare = '=' ; } else { $ meta_compare = '!=' ; } $ query = new WP_User_Query ( array ( 'meta_key' => $ meta_key , 'meta_value' => $ meta_value , 'meta_compare' => $ meta_compare , 'fields' => 'ID' ) ) ; $ exclude_users = $ query -> get_results ( ) ; $ query = new WP_User_Query ( array ( 'fields' => 'all_with_meta' , 'exclude' => $ exclude_users ) ) ; return $ query -> get_results ( ) ; } $ query = new WP_User_Query ( array ( 'meta_key' => $ meta_key , 'meta_value' => $ meta_value , 'meta_compare' => $ meta_compare , 'fields' => 'all_with_meta' ) ) ; return $ query -> get_results ( ) ; }
9187	public static function embedCampaigns ( $ html , $ campaign = [ ] , $ additionalCampaigns = [ ] ) { $ pattern = '/<a(\s[^>]*)href="([^"]*)"([^>]*)>/si' ; $ html = preg_replace_callback ( $ pattern , function ( $ matches ) use ( $ campaign , $ additionalCampaigns ) { $ href = GoogleCampaignPlugin :: replaceLink ( $ matches [ 2 ] , $ campaign , $ additionalCampaigns ) ; return "<a{$matches[1]}href=\"{$href}\"{$matches[3]}>" ; } , $ html ) ; return $ html ; }
8772	protected function markAsRegistered ( ServiceProvider $ provider ) { $ this -> serviceProviders [ ] = $ provider ; $ this -> loadedProviders [ get_class ( $ provider ) ] = true ; }
878	public function useRuleSet ( RuleSetInterface $ ruleSet ) { $ fixers = [ ] ; $ fixersByName = [ ] ; $ fixerConflicts = [ ] ; $ fixerNames = array_keys ( $ ruleSet -> getRules ( ) ) ; foreach ( $ fixerNames as $ name ) { if ( ! \ array_key_exists ( $ name , $ this -> fixersByName ) ) { throw new \ UnexpectedValueException ( sprintf ( 'Rule "%s" does not exist.' , $ name ) ) ; } $ fixer = $ this -> fixersByName [ $ name ] ; $ config = $ ruleSet -> getRuleConfiguration ( $ name ) ; if ( null !== $ config ) { if ( $ fixer instanceof ConfigurableFixerInterface ) { if ( ! \ is_array ( $ config ) || ! \ count ( $ config ) ) { throw new InvalidFixerConfigurationException ( $ fixer -> getName ( ) , 'Configuration must be an array and may not be empty.' ) ; } $ fixer -> configure ( $ config ) ; } else { throw new InvalidFixerConfigurationException ( $ fixer -> getName ( ) , 'Is not configurable.' ) ; } } $ fixers [ ] = $ fixer ; $ fixersByName [ $ name ] = $ fixer ; $ conflicts = array_intersect ( $ this -> getFixersConflicts ( $ fixer ) , $ fixerNames ) ; if ( \ count ( $ conflicts ) > 0 ) { $ fixerConflicts [ $ name ] = $ conflicts ; } } if ( \ count ( $ fixerConflicts ) > 0 ) { throw new \ UnexpectedValueException ( $ this -> generateConflictMessage ( $ fixerConflicts ) ) ; } $ this -> fixers = $ fixers ; $ this -> fixersByName = $ fixersByName ; return $ this ; }
2087	public static function getDefaultPath ( $ template , $ format ) { $ file = $ template . '.' . $ format ; $ container = System :: getContainer ( ) ; $ rootDir = $ container -> getParameter ( 'kernel.project_dir' ) ; if ( isset ( self :: $ files [ $ template ] ) ) { return $ rootDir . '/' . self :: $ files [ $ template ] . '/' . $ file ; } $ strPath = null ; try { foreach ( $ container -> get ( 'contao.resource_finder' ) -> findIn ( 'templates' ) -> name ( $ file ) as $ file ) { $ strPath = $ file -> getPathname ( ) ; } } catch ( \ InvalidArgumentException $ e ) { } if ( $ strPath !== null ) { return $ strPath ; } throw new \ Exception ( 'Could not find template "' . $ template . '"' ) ; }
492	public function findFor ( $ name , $ model ) { if ( method_exists ( $ model , 'get' . $ name ) ) { $ method = new \ ReflectionMethod ( $ model , 'get' . $ name ) ; $ realName = lcfirst ( substr ( $ method -> getName ( ) , 3 ) ) ; if ( $ realName !== $ name ) { throw new InvalidArgumentException ( 'Relation names are case sensitive. ' . get_class ( $ model ) . " has a relation named \"$realName\" instead of \"$name\"." ) ; } } return $ this -> multiple ? $ this -> all ( ) : $ this -> one ( ) ; }
214	public function getParams ( ) { if ( $ this -> _params === null ) { if ( isset ( $ _SERVER [ 'argv' ] ) ) { $ this -> _params = $ _SERVER [ 'argv' ] ; array_shift ( $ this -> _params ) ; } else { $ this -> _params = [ ] ; } } return $ this -> _params ; }
8739	private function updateBase ( array $ values , array $ ids ) { $ query = $ this -> model -> newQuery ( ) -> whereIn ( $ this -> model -> getKeyName ( ) , $ ids ) -> getQuery ( ) ; return $ query -> update ( $ values ) ; }
12355	public function setVariables ( array $ data ) : void { foreach ( $ data as $ key => $ value ) { $ this -> $ key = $ value ; } }
1886	public function getItemsAsArray ( ) { $ arrLinks = array ( ) ; $ intNumberOfLinks = floor ( $ this -> intNumberOfLinks / 2 ) ; $ intFirstOffset = $ this -> intPage - $ intNumberOfLinks - 1 ; if ( $ intFirstOffset > 0 ) { $ intFirstOffset = 0 ; } $ intLastOffset = $ this -> intPage + $ intNumberOfLinks - $ this -> intTotalPages ; if ( $ intLastOffset < 0 ) { $ intLastOffset = 0 ; } $ intFirstLink = $ this -> intPage - $ intNumberOfLinks - $ intLastOffset ; if ( $ intFirstLink < 1 ) { $ intFirstLink = 1 ; } $ intLastLink = $ this -> intPage + $ intNumberOfLinks - $ intFirstOffset ; if ( $ intLastLink > $ this -> intTotalPages ) { $ intLastLink = $ this -> intTotalPages ; } for ( $ i = $ intFirstLink ; $ i <= $ intLastLink ; $ i ++ ) { if ( $ i == $ this -> intPage ) { $ arrLinks [ ] = array ( 'page' => $ i , 'href' => null , 'title' => null ) ; } else { $ arrLinks [ ] = array ( 'page' => $ i , 'href' => $ this -> linkToPage ( $ i ) , 'title' => StringUtil :: specialchars ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'goToPage' ] , $ i ) ) ) ; } } return $ arrLinks ; }
2335	public function onKernelRequest ( GetResponseEvent $ event ) : void { if ( ! $ event -> isMasterRequest ( ) ) { return ; } $ this -> tokenStorage -> initialize ( $ this -> getTokensFromCookies ( $ event -> getRequest ( ) -> cookies ) ) ; }
9967	public function getHyperlink ( $ pCellCoordinate ) { if ( isset ( $ this -> hyperlinkCollection [ $ pCellCoordinate ] ) ) { return $ this -> hyperlinkCollection [ $ pCellCoordinate ] ; } $ this -> hyperlinkCollection [ $ pCellCoordinate ] = new Hyperlink ( ) ; return $ this -> hyperlinkCollection [ $ pCellCoordinate ] ; }
3502	private function initializeCurlResource ( ) : void { if ( ! $ this -> resource ) { $ this -> resource = curl_init ( ) ; curl_setopt ( $ this -> resource , CURLOPT_RETURNTRANSFER , 1 ) ; curl_setopt ( $ this -> resource , CURLOPT_POST , 1 ) ; curl_setopt ( $ this -> resource , CURLOPT_HTTP_VERSION , 3 ) ; } }
9231	public function actionIndex ( $ format = false , $ arraymap = false , $ term = false , $ category = false , $ time = false ) { $ searchModel = new PostSearch ( ) ; $ req = Yii :: $ app -> request -> queryParams ; if ( $ term ) { $ req [ basename ( str_replace ( "\\" , "/" , get_class ( $ searchModel ) ) ) ] [ "term" ] = $ term ; } if ( $ category ) { $ req [ basename ( str_replace ( "\\" , "/" , get_class ( $ searchModel ) ) ) ] [ "category" ] = $ category ; } if ( $ time ) { $ req [ basename ( str_replace ( "\\" , "/" , get_class ( $ searchModel ) ) ) ] [ "time" ] = $ time ; } $ dataProvider = $ searchModel -> search ( $ req ) ; $ query = $ dataProvider -> query ; $ query -> andWhere ( [ 'status' => [ 1 ] ] ) ; if ( $ format == 'json' ) { $ model = [ ] ; foreach ( $ dataProvider -> getModels ( ) as $ d ) { $ obj = $ d -> attributes ; if ( $ arraymap ) { $ map = explode ( "," , $ arraymap ) ; if ( count ( $ map ) == 1 ) { $ obj = ( isset ( $ d [ $ arraymap ] ) ? $ d [ $ arraymap ] : null ) ; } else { $ obj = [ ] ; foreach ( $ map as $ a ) { $ k = explode ( ":" , $ a ) ; $ v = ( count ( $ k ) > 1 ? $ k [ 1 ] : $ k [ 0 ] ) ; $ obj [ $ k [ 0 ] ] = ( $ v == "Obj" ? json_encode ( $ d -> attributes ) : ( isset ( $ d -> $ v ) ? $ d -> $ v : null ) ) ; } } } if ( $ term ) { if ( ! in_array ( $ obj , $ model ) ) { array_push ( $ model , $ obj ) ; } } else { array_push ( $ model , $ obj ) ; } } header ( "Access-Control-Allow-Origin: *" ) ; header ( "Access-Control-Expose-Headers: X-Pagination-Per-Page,X-Pagination-Current-Page,X-Pagination-Page-Count,X-Pagination-Total-Count,Content-Type,Location" ) ; return \ yii \ helpers \ Json :: encode ( $ model ) ; } else { return $ this -> render ( 'index' , [ 'searchModel' => $ searchModel , 'dataProvider' => $ dataProvider , ] ) ; } }
2832	public function stacktraceSqlAction ( ) { if ( $ query = $ this -> _initQuery ( ) ) { $ helper = Mage :: helper ( 'sheep_debug' ) ; $ stripZendPath = $ helper -> canStripZendDbTrace ( ) ? 'lib/Zend/Db/Adapter' : '' ; $ trimPath = $ helper -> canTrimMagentoBaseDir ( ) ? Mage :: getBaseDir ( ) . DS : '' ; $ html = '<pre>' . Mage :: helper ( 'sheep_debug' ) -> formatStacktrace ( $ query -> getStackTrace ( ) , $ stripZendPath , $ trimPath ) . '</pre>' ; $ this -> getResponse ( ) -> setBody ( $ html ) ; } }
4273	public function stream_eof ( ) { if ( ! $ this -> handle ) { return false ; } self :: restorePrev ( ) ; $ result = \ feof ( $ this -> handle ) ; self :: register ( ) ; return $ result ; }
3238	private function runCalculations ( ) { if ( ! empty ( $ this -> shopCalculations ) ) return $ this -> shopCalculations ; $ cacheKey = $ this -> calculationsCacheKey ; if ( Config :: get ( 'shop.cache_calculations' ) && Cache :: has ( $ cacheKey ) ) { $ this -> shopCalculations = Cache :: get ( $ cacheKey ) ; return $ this -> shopCalculations ; } $ this -> shopCalculations = DB :: table ( $ this -> table ) -> select ( [ DB :: raw ( 'sum(' . Config :: get ( 'shop.item_table' ) . '.quantity) as itemCount' ) , DB :: raw ( 'sum(' . Config :: get ( 'shop.item_table' ) . '.price * ' . Config :: get ( 'shop.item_table' ) . '.quantity) as totalPrice' ) , DB :: raw ( 'sum(' . Config :: get ( 'shop.item_table' ) . '.tax * ' . Config :: get ( 'shop.item_table' ) . '.quantity) as totalTax' ) , DB :: raw ( 'sum(' . Config :: get ( 'shop.item_table' ) . '.shipping * ' . Config :: get ( 'shop.item_table' ) . '.quantity) as totalShipping' ) ] ) -> join ( Config :: get ( 'shop.item_table' ) , Config :: get ( 'shop.item_table' ) . '.' . ( $ this -> table == Config :: get ( 'shop.order_table' ) ? 'order_id' : $ this -> table . '_id' ) , '=' , $ this -> table . '.id' ) -> where ( $ this -> table . '.id' , $ this -> attributes [ 'id' ] ) -> first ( ) ; if ( Config :: get ( 'shop.cache_calculations' ) ) { Cache :: put ( $ cacheKey , $ this -> shopCalculations , Config :: get ( 'shop.cache_calculations_minutes' ) ) ; } return $ this -> shopCalculations ; }
658	public function cache ( callable $ callable , $ duration = null , $ dependency = null ) { $ this -> _queryCacheInfo [ ] = [ $ duration === null ? $ this -> queryCacheDuration : $ duration , $ dependency ] ; try { $ result = call_user_func ( $ callable , $ this ) ; array_pop ( $ this -> _queryCacheInfo ) ; return $ result ; } catch ( \ Exception $ e ) { array_pop ( $ this -> _queryCacheInfo ) ; throw $ e ; } catch ( \ Throwable $ e ) { array_pop ( $ this -> _queryCacheInfo ) ; throw $ e ; } }
5736	private function getShowParameters ( Request $ request ) { $ showingAll = FALSE ; $ start = - 100 ; $ count = - 1 ; if ( $ request -> query -> has ( 'all' ) ) { $ start = 0 ; $ count = - 1 ; $ showingAll = TRUE ; } return [ $ start , $ count , $ showingAll ] ; }
9569	public function setContainer ( ContainerInterface $ container ) { $ this -> container = $ container ; $ container -> instance ( 'Autarky\Application' , $ this ) ; $ container -> instance ( 'Symfony\Component\HttpFoundation\RequestStack' , $ this -> requests ) ; }
9115	public function setDefaults ( $ defaultController = 'Index' , $ defaultAction = 'index' ) { $ this -> defaultController = $ defaultController ; $ this -> defaultAction = $ defaultAction ; return $ this ; }
6607	public static function getAll ( $ offset = null , $ limit = null ) { $ query = self :: find ( ) ; self :: addPaginationParameters ( $ query , $ offset , $ limit ) ; return $ query -> all ( ) ; }
10100	private function writeRichTextString ( $ row , $ col , $ str , $ xfIndex , $ arrcRun ) { $ record = 0x00FD ; $ length = 0x000A ; $ str = StringHelper :: UTF8toBIFF8UnicodeShort ( $ str , $ arrcRun ) ; if ( ! isset ( $ this -> stringTable [ $ str ] ) ) { $ this -> stringTable [ $ str ] = $ this -> stringUnique ++ ; } ++ $ this -> stringTotal ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vvvV' , $ row , $ col , $ xfIndex , $ this -> stringTable [ $ str ] ) ; $ this -> append ( $ header . $ data ) ; }
2858	public function layoutUpdatesAction ( ) { $ token = $ this -> getRequest ( ) -> getParam ( 'token' ) ; if ( ! $ token ) { return $ this -> getResponse ( ) -> setHttpResponseCode ( 400 ) -> setBody ( 'Invalid parameters' ) ; } $ requestProfile = Mage :: getModel ( 'sheep_debug/requestInfo' ) -> load ( $ token , 'token' ) ; if ( ! $ requestProfile -> getId ( ) ) { return $ this -> getResponse ( ) -> setHttpResponseCode ( 404 ) -> setBody ( 'Request profile not found' ) ; } $ layoutUpdates = $ requestProfile -> getDesign ( ) -> getLayoutUpdates ( ) ; $ this -> renderArray ( $ layoutUpdates , 'No Data' , array ( '#' , 'XML' ) ) ; }
1015	public function setValidationRules ( $ validationRules ) { if ( ! is_callable ( $ validationRules ) && ! is_array ( $ validationRules ) && $ validationRules !== null ) { throw new InvariantViolation ( 'Server config expects array of validation rules or callable returning such array, but got ' . Utils :: printSafe ( $ validationRules ) ) ; } $ this -> validationRules = $ validationRules ; return $ this ; }
3341	public function getFileList ( $ options = array ( ) ) { $ options = array_replace ( array ( 'from' => null , 'to' => null , 'limit' => null , 'request_limit' => null , 'stored' => $ this -> defaultFilters [ 'file' ] [ 'stored' ] , 'removed' => $ this -> defaultFilters [ 'file' ] [ 'removed' ] , 'reversed' => false , ) , $ options ) ; if ( ! empty ( $ options [ 'from' ] ) && ! empty ( $ options [ 'to' ] ) ) { throw new \ Exception ( 'Only one of "from" and "to" arguments is allowed' ) ; } $ options [ 'from' ] = self :: dateTimeString ( $ options [ 'from' ] ) ; $ options [ 'to' ] = self :: dateTimeString ( $ options [ 'to' ] ) ; foreach ( $ this -> defaultFilters [ 'file' ] as $ k => $ v ) { if ( ! is_null ( $ options [ $ k ] ) ) { $ options [ $ k ] = self :: booleanString ( $ options [ $ k ] ) ; } } return new FileIterator ( $ this , $ options ) ; }
1734	public function validateCode ( User $ user , string $ code ) : bool { $ totp = TOTP :: create ( $ this -> getUpperUnpaddedSecretForUser ( $ user ) ) ; return $ totp -> verify ( $ code ) ; }
11889	public function paginate ( ) { $ model = $ this -> model ; if ( property_exists ( $ model , 'order' ) ) { $ paginator = $ model :: orderBy ( $ model :: $ order , $ model :: $ sort ) -> paginate ( $ model :: $ paginate , $ model :: $ index ) ; } else { $ paginator = $ model :: paginate ( $ model :: $ paginate , $ model :: $ index ) ; } if ( ! $ this -> isPageInRange ( $ paginator ) && ! $ this -> isFirstPage ( $ paginator ) ) { throw new NotFoundHttpException ( ) ; } if ( $ paginator -> getTotal ( ) ) { $ this -> paginateLinks = $ paginator -> links ( ) ; } return $ paginator ; }
8887	private function checkDefaults ( $ options ) { if ( ! isset ( $ options [ 'request_option' ] ) ) { $ options [ 'request_option' ] = 'Shop' ; } if ( ! isset ( $ options [ 'from_country' ] ) ) { $ options [ 'from_country' ] = 'US' ; } if ( ! isset ( $ options [ 'to_country' ] ) ) { $ options [ 'to_country' ] = 'US' ; } if ( ! isset ( $ options [ 'service_type' ] ) ) { $ options [ 'service_type' ] = '03' ; } if ( ! isset ( $ options [ 'from_state' ] ) ) { $ options [ 'from_state' ] = '' ; } if ( ! isset ( $ options [ 'to_state' ] ) ) { $ options [ 'to_state' ] = '' ; } $ this -> commercial_rates = ( isset ( $ options [ 'commercial' ] ) && $ options [ 'commercial' ] ) ? true : false ; $ this -> negotiated_rates = ( isset ( $ options [ 'negotiated_rates' ] ) && $ options [ 'negotiated_rates' ] ) ? true : false ; return $ options ; }
6429	public function getLoginStartUrl ( $ redirecturl ) { $ facebook = $ this -> getFacebookObject ( ) ; $ helper = $ facebook -> getRedirectLoginHelper ( ) ; $ permissions = [ 'email' ] ; $ loginUrl = $ helper -> getLoginUrl ( $ redirecturl , $ permissions ) ; return $ loginUrl ; }
4087	protected function transformDSLTermToString ( $ dslTerm ) { $ string = "" ; if ( is_array ( $ dslTerm ) ) { $ key = key ( $ dslTerm ) ; $ value = $ dslTerm [ $ key ] ; if ( is_string ( $ key ) ) $ string .= "$key:" ; } else $ value = $ dslTerm ; if ( strpos ( $ value , " " ) !== false ) $ string .= '"' . $ value . '"' ; else $ string .= $ value ; return $ string ; }
10967	public static function isSsl ( ) { $ isSecure = false ; if ( isset ( $ _SERVER [ 'HTTPS' ] ) && in_array ( $ _SERVER [ 'HTTPS' ] , [ 'on' , '1' ] ) ) { $ isSecure = true ; } elseif ( isset ( $ _SERVER [ 'HTTP_X_FORWARDED_PROTO' ] ) && $ _SERVER [ 'HTTP_X_FORWARDED_PROTO' ] == 'https' ) { $ isSecure = true ; } elseif ( isset ( $ _SERVER [ 'HTTP_X_FORWARDED_SSL' ] ) && $ _SERVER [ 'HTTP_X_FORWARDED_SSL' ] == 'on' ) { $ isSecure = true ; } return $ isSecure ; }
11581	public function bootstrap ( $ rootDir , $ siteName ) { $ this -> app [ "red_kite_cms.root_dir" ] = $ rootDir ; $ this -> siteName = $ siteName ; $ this -> checkPermissions ( $ rootDir ) ; $ this -> initCmsRequiredServices ( ) ; $ this -> registerProviders ( ) ; $ this -> registerServices ( ) ; $ this -> registerListeners ( ) ; $ this -> register ( $ this -> app ) ; $ this -> boot ( ) ; $ this -> addWebsiteRoutes ( ) ; $ this -> app [ "dispatcher" ] -> dispatch ( CmsEvents :: CMS_BOOTED , new CmsBootedEvent ( $ this -> app [ "red_kite_cms.configuration_handler" ] ) ) ; }
4224	public function handleException ( $ exception ) { $ this -> uncaughtException = $ exception ; \ http_response_code ( 500 ) ; $ this -> handleError ( E_ERROR , 'Uncaught exception \'' . \ get_class ( $ exception ) . '\' with message ' . $ exception -> getMessage ( ) , $ exception -> getFile ( ) , $ exception -> getLine ( ) ) ; $ this -> uncaughtException = null ; if ( $ this -> cfg [ 'continueToPrevHandler' ] && $ this -> prevExceptionHandler ) { \ call_user_func ( $ this -> prevErrorHandler , $ exception ) ; } }
11546	public function changeSecurityQuestion ( $ data ) { if ( ! ( $ user = $ this -> hydrate ( $ data , $ this -> getChangeSecurityQuestionForm ( ) ) ) ) { return ; } $ eventManager = $ this -> getEventManager ( ) ; $ eventManager -> trigger ( __METHOD__ , $ this , $ user ) ; $ this -> getMapper ( ) -> update ( $ user ) -> save ( ) ; $ eventManager -> trigger ( __METHOD__ . '.post' , $ this , $ user ) ; return $ user ; }
12496	public static function delete ( $ id = null , $ connection ) { if ( gettype ( $ id ) != "string" && ! is_numeric ( $ id ) ) { throw new ClusterpointException ( "\"->delete()\" function: \"_id\" is not in valid format." , 9002 ) ; } $ connection -> method = 'DELETE' ; $ connection -> action = '[' . urlencode ( $ id ) . ']' ; return self :: sendQuery ( $ connection ) ; }
1878	public function deleteAll ( ) { if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notDeletable' ] ) { throw new InternalServerErrorException ( 'Table "' . $ this -> strTable . '" is not deletable.' ) ; } $ objSession = System :: getContainer ( ) -> get ( 'session' ) ; $ session = $ objSession -> all ( ) ; $ ids = $ session [ 'CURRENT' ] [ 'IDS' ] ; if ( ! empty ( $ ids ) && \ is_array ( $ ids ) ) { $ ids = $ this -> eliminateNestedPaths ( $ ids ) ; foreach ( $ ids as $ id ) { $ this -> delete ( $ id ) ; } } $ this -> redirect ( $ this -> getReferer ( ) ) ; }
10682	public static function quoteWith ( $ o , $ quote = '\'' ) { if ( strlen ( $ quote ) !== 1 ) { throw new InvalidArgumentException ( '2nd parameter must be single character, two or more characters are given' ) ; } if ( is_array ( $ o ) ) { $ len = count ( $ o ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { $ tmp [ $ i ] = $ quote . $ o [ $ i ] . $ quote ; } return $ tmp ; } return $ quote . $ o . $ quote ; }
12873	protected function getElementValidatorChain ( \ Zend \ Form \ Element $ element ) { $ elementName = $ element -> getAttribute ( 'name' ) ; return $ this -> form -> getInputFilter ( ) -> get ( $ elementName ) -> getValidatorChain ( ) ; }
7963	public function ipSetMonitoringNotifications ( $ ip , $ frequency = 'once' , $ email = '' , $ sms = array ( ) ) { return json_decode ( self :: getClient ( ) -> ipSetMonitoringNotifications ( $ this -> id , $ ip , $ frequency , $ email , $ sms ) ) ; }
11533	public static function readFile ( $ file ) { if ( ! file_exists ( $ file ) ) { return null ; } $ handle = fopen ( $ file , 'r' ) ; if ( ! self :: lockFile ( $ handle , LOCK_SH | LOCK_NB ) ) { $ exception = array ( "message" => 'exception_file_cannot_be_locked_for_reading' , "parameters" => array ( "%file%" => basename ( $ file ) , ) ) ; throw new RuntimeException ( json_encode ( $ exception ) ) ; } $ contents = file_get_contents ( $ file ) ; self :: unlockFile ( $ handle ) ; return $ contents ; }
4080	protected function isInputScreenStandalone ( $ metaModel ) { $ information = $ this -> information [ $ metaModel ] ; $ inputScreen = isset ( $ information [ self :: INPUTSCREEN ] ) ? $ information [ self :: INPUTSCREEN ] : null ; if ( ! is_object ( $ inputScreen ) ) { return ( $ inputScreen [ 'row' ] [ 'rendertype' ] == 'standalone' ) ; } return $ inputScreen -> isStandalone ( ) ; }
2222	public static function countPublishedFromToByPids ( $ intFrom , $ intTo , $ arrPids , array $ arrOptions = array ( ) ) { if ( empty ( $ arrPids ) || ! \ is_array ( $ arrPids ) ) { return null ; } $ t = static :: $ strTable ; $ arrColumns = array ( "$t.date>=? AND $t.date<=? AND $t.pid IN(" . implode ( ',' , array_map ( '\intval' , $ arrPids ) ) . ")" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } return static :: countBy ( $ arrColumns , array ( $ intFrom , $ intTo ) , $ arrOptions ) ; }
335	protected function createColumn ( $ column ) { $ c = $ this -> createColumnSchema ( ) ; $ c -> name = $ column [ 'COLUMN_NAME' ] ; $ c -> allowNull = $ column [ 'NULLABLE' ] === 'Y' ; $ c -> comment = $ column [ 'COLUMN_COMMENT' ] === null ? '' : $ column [ 'COLUMN_COMMENT' ] ; $ c -> isPrimaryKey = false ; $ this -> extractColumnType ( $ c , $ column [ 'DATA_TYPE' ] , $ column [ 'DATA_PRECISION' ] , $ column [ 'DATA_SCALE' ] , $ column [ 'DATA_LENGTH' ] ) ; $ this -> extractColumnSize ( $ c , $ column [ 'DATA_TYPE' ] , $ column [ 'DATA_PRECISION' ] , $ column [ 'DATA_SCALE' ] , $ column [ 'DATA_LENGTH' ] ) ; $ c -> phpType = $ this -> getColumnPhpType ( $ c ) ; if ( ! $ c -> isPrimaryKey ) { if ( stripos ( $ column [ 'DATA_DEFAULT' ] , 'timestamp' ) !== false ) { $ c -> defaultValue = null ; } else { $ defaultValue = $ column [ 'DATA_DEFAULT' ] ; if ( $ c -> type === 'timestamp' && $ defaultValue === 'CURRENT_TIMESTAMP' ) { $ c -> defaultValue = new Expression ( 'CURRENT_TIMESTAMP' ) ; } else { if ( $ defaultValue !== null ) { if ( ( $ len = strlen ( $ defaultValue ) ) > 2 && $ defaultValue [ 0 ] === "'" && $ defaultValue [ $ len - 1 ] === "'" ) { $ defaultValue = substr ( $ column [ 'DATA_DEFAULT' ] , 1 , - 1 ) ; } else { $ defaultValue = trim ( $ defaultValue ) ; } } $ c -> defaultValue = $ c -> phpTypecast ( $ defaultValue ) ; } } } return $ c ; }
2451	public function onKernelRequest ( GetResponseEvent $ event ) : void { if ( ! $ this -> scopeMatcher -> isContaoRequest ( $ event -> getRequest ( ) ) ) { return ; } $ request = $ event -> getRequest ( ) ; $ request -> attributes -> set ( '_locale' , $ this -> getLocale ( $ request ) ) ; }
1712	public function getArticleAlias ( Contao \ DataContainer $ dc ) { $ arrPids = array ( ) ; $ arrAlias = array ( ) ; if ( ! $ this -> User -> isAdmin ) { foreach ( $ this -> User -> pagemounts as $ id ) { $ arrPids [ ] = array ( $ id ) ; $ arrPids [ ] = $ this -> Database -> getChildRecords ( $ id , 'tl_page' ) ; } if ( ! empty ( $ arrPids ) ) { $ arrPids = array_merge ( ... $ arrPids ) ; } else { return $ arrAlias ; } $ objAlias = $ this -> Database -> prepare ( "SELECT a.id, a.title, a.inColumn, p.title AS parent FROM tl_article a LEFT JOIN tl_page p ON p.id=a.pid WHERE a.pid IN(" . implode ( ',' , array_map ( '\intval' , array_unique ( $ arrPids ) ) ) . ") ORDER BY parent, a.sorting" ) -> execute ( $ dc -> id ) ; } else { $ objAlias = $ this -> Database -> prepare ( "SELECT a.id, a.title, a.inColumn, p.title AS parent FROM tl_article a LEFT JOIN tl_page p ON p.id=a.pid ORDER BY parent, a.sorting" ) -> execute ( $ dc -> id ) ; } if ( $ objAlias -> numRows ) { Contao \ System :: loadLanguageFile ( 'tl_article' ) ; while ( $ objAlias -> next ( ) ) { $ arrAlias [ $ objAlias -> parent ] [ $ objAlias -> id ] = $ objAlias -> title . ' (' . ( $ GLOBALS [ 'TL_LANG' ] [ 'COLS' ] [ $ objAlias -> inColumn ] ? : $ objAlias -> inColumn ) . ', ID ' . $ objAlias -> id . ')' ; } } return $ arrAlias ; }
11990	public function toggleFiltrable ( $ entityName , $ id ) { $ entity = $ this -> entityManager -> getRepository ( $ entityName ) -> find ( $ id ) ; if ( ! $ entity ) { throw new NotFoundHttpException ( ) ; } $ entity -> toggleFiltrable ( ) ; $ this -> entityManager -> persist ( $ entity ) ; $ this -> entityManager -> flush ( ) ; return $ entity -> isFiltrable ( ) ; }
2867	public function getContent ( $ filePath , $ startPosition , $ endPosition ) { if ( ! file_exists ( $ filePath ) ) { return '' ; } if ( ! $ endPosition ) { return trim ( file_get_contents ( $ filePath , null , null , $ startPosition ) ) ; } if ( $ endPosition <= $ startPosition ) { return '' ; } return trim ( file_get_contents ( $ filePath , null , null , $ startPosition , $ endPosition - $ startPosition ) ) ; }
9593	public function checkboxListFilled ( $ items , $ options = [ ] ) { $ this -> addListInputCssClass ( $ options , $ this -> checkboxFilledCssClass ) ; return self :: checkboxList ( $ items , $ options ) ; }
12512	public function login ( ) { if ( $ this -> validate ( ) ) { return \ Yii :: $ app -> getUser ( ) -> login ( $ this -> user , $ this -> rememberMe ? $ this -> module -> rememberFor : 0 ) ; } else { return false ; } }
5507	public function returnsByValue ( $ method , $ value , $ args = false ) { $ this -> dieOnNoMethod ( $ method , 'set return value' ) ; $ this -> actions -> register ( $ method , $ args , new SimpleByValue ( $ value ) ) ; }
9196	public function config ( ) { if ( ! $ this -> config ) { $ config = array ( ) ; $ configFile = $ this -> getThemesPath ( ) . DIRECTORY_SEPARATOR . $ this -> getName ( ) . DIRECTORY_SEPARATOR . 'theme.config.php' ; if ( file_exists ( $ configFile ) ) { ob_start ( ) ; set_error_handler ( function ( $ errno , $ errstr ) { throw new \ ErrorException ( $ errstr , $ errno ) ; } , E_ALL ) ; $ config = include $ configFile ; restore_error_handler ( ) ; ob_get_clean ( ) ; if ( ! is_array ( $ config ) ) throw new \ Exception ( 'Invalid "' . $ this -> getName ( ) . '" Theme Config File. It must return array.' ) ; } $ this -> config = new Entity ( $ config ) ; } return $ this -> config ; }
1616	public function count ( $ q = '*' , $ db = null ) { if ( $ this -> emulateExecution ) { return 0 ; } if ( $ this -> where === null ) { $ modelClass = $ this -> modelClass ; if ( $ db === null ) { $ db = $ modelClass :: getDb ( ) ; } return $ db -> executeCommand ( 'LLEN' , [ $ modelClass :: keyPrefix ( ) ] ) ; } else { return $ this -> executeScript ( $ db , 'Count' ) ; } }
9470	protected function loadingGroups ( ) : void { foreach ( $ this -> groups as $ group ) { $ this -> addPattern ( $ group -> toArray ( ) ) ; } }
6517	public function setParameterType ( $ method , $ name , $ type ) { if ( ! isset ( $ this -> parameterTypes [ $ method ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'A method with name "%s" is not defined' , $ name , $ method ) ) ; } if ( ! array_key_exists ( $ name , $ this -> parameterTypes [ $ method ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'A parameter with name "%s" for method "%s" is not defined' , $ name , $ method ) ) ; } $ this -> parameterTypes [ $ method ] [ $ name ] = $ type ; }
8341	public static function init ( ) { if ( self :: $ isInit === false ) { self :: $ prettyPageHandler = new PrettyPageHandler ( ) ; self :: $ prettyPageHandler -> setPageTitle ( 'I just broke a string... - strayFw' ) ; $ whoops = new Run ( ) ; $ whoops -> pushHandler ( new JsonResponseHandler ( ) ) ; $ whoops -> pushHandler ( self :: $ prettyPageHandler ) ; $ whoops -> register ( ) ; self :: $ isInit = true ; } }
12064	public function setFlashBag ( $ sName , $ sValue ) { if ( ! isset ( $ _SESSION [ 'flashbag' ] ) ) { $ _SESSION [ 'flashbag' ] = array ( ) ; } $ _SESSION [ 'flashbag' ] [ $ sName ] = $ sValue ; return $ this ; }
3221	function searchFileNames ( $ basePath , $ query , $ limit = null , $ includeDeleted = false ) { Path :: checkArg ( "basePath" , $ basePath ) ; Checker :: argStringNonEmpty ( "query" , $ query ) ; Checker :: argNatOrNull ( "limit" , $ limit ) ; Checker :: argBool ( "includeDeleted" , $ includeDeleted ) ; $ response = $ this -> doPost ( $ this -> apiHost , $ this -> appendFilePath ( "1/search" , $ basePath ) , array ( "query" => $ query , "file_limit" => $ limit , "include_deleted" => $ includeDeleted , ) ) ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; return RequestUtil :: parseResponseJson ( $ response -> body ) ; }
10073	public function allDrawings ( Spreadsheet $ spreadsheet ) { $ aDrawings = [ ] ; $ sheetCount = $ spreadsheet -> getSheetCount ( ) ; for ( $ i = 0 ; $ i < $ sheetCount ; ++ $ i ) { $ iterator = $ spreadsheet -> getSheet ( $ i ) -> getDrawingCollection ( ) -> getIterator ( ) ; while ( $ iterator -> valid ( ) ) { $ aDrawings [ ] = $ iterator -> current ( ) ; $ iterator -> next ( ) ; } } return $ aDrawings ; }
8762	public function upload ( $ input ) { $ validator = \ Validator :: make ( $ input , config ( 'dropzoner.validator' ) , config ( 'dropzoner.validator-messages' ) ) ; if ( $ validator -> fails ( ) ) { return response ( ) -> json ( [ 'error' => true , 'message' => $ validator -> messages ( ) -> first ( ) , 'code' => 400 ] , 400 ) ; } $ photo = $ input [ 'file' ] ; $ original_name = $ photo -> getClientOriginalName ( ) ; $ extension = $ photo -> getClientOriginalExtension ( ) ; $ original_name_without_extension = substr ( $ original_name , 0 , strlen ( $ original_name ) - strlen ( $ extension ) - 1 ) ; $ filename = $ this -> sanitize ( $ original_name_without_extension ) ; $ allowed_filename = $ this -> createUniqueFilename ( $ filename ) ; $ filename_with_extension = $ allowed_filename . '.' . $ extension ; $ manager = new ImageManager ( ) ; $ image = $ manager -> make ( $ photo ) -> save ( config ( 'dropzoner.upload-path' ) . $ filename_with_extension ) ; if ( ! $ image ) { return response ( ) -> json ( [ 'error' => true , 'message' => 'Server error while uploading' , 'code' => 500 ] , 500 ) ; } event ( new ImageWasUploaded ( $ original_name , $ filename_with_extension ) ) ; return response ( ) -> json ( [ 'error' => false , 'code' => 200 , 'filename' => $ filename_with_extension ] , 200 ) ; }
1445	protected function isEloquent ( ) { if ( $ this -> isIndependent ) { return false ; } if ( $ this -> option ( 'no-eloquent' ) ) { return false ; } return $ this -> option ( 'eloquent' ) ? : $ this -> getApi ( ) -> isEloquent ( ) ; }
2124	public function getFileUrls ( ) { $ return = array ( ) ; $ strTarget = substr ( $ this -> strMode , 1 ) ; foreach ( $ this -> arrFiles as $ arrFile ) { if ( $ arrFile [ 'extension' ] == self :: SCSS || $ arrFile [ 'extension' ] == self :: LESS ) { $ strPath = 'assets/' . $ strTarget . '/' . str_replace ( '/' , '_' , $ arrFile [ 'name' ] ) . $ this -> strMode ; if ( Config :: get ( 'debugMode' ) || ! file_exists ( $ this -> strRootDir . '/' . $ strPath ) ) { $ objFile = new File ( $ strPath ) ; $ objFile -> write ( $ this -> handleScssLess ( file_get_contents ( $ this -> strRootDir . '/' . $ arrFile [ 'name' ] ) , $ arrFile ) ) ; $ objFile -> close ( ) ; } $ return [ ] = $ strPath . '|' . $ arrFile [ 'version' ] ; } else { $ name = $ arrFile [ 'name' ] ; if ( strncmp ( $ name , $ this -> strWebDir . '/' , \ strlen ( $ this -> strWebDir ) + 1 ) === 0 ) { $ name = substr ( $ name , \ strlen ( $ this -> strWebDir ) + 1 ) ; } if ( $ this -> strMode == self :: CSS && $ arrFile [ 'media' ] != '' && $ arrFile [ 'media' ] != 'all' && ! $ this -> hasMediaTag ( $ arrFile [ 'name' ] ) ) { $ name .= '|' . $ arrFile [ 'media' ] ; } $ return [ ] = $ name . '|' . $ arrFile [ 'version' ] ; } } return $ return ; }
6944	protected function registerClassInstanceSingleton ( $ singletonName , $ classNameOrInstance = null ) { if ( empty ( $ classNameOrInstance ) ) { $ classNameOrInstance = $ singletonName ; } $ this -> app -> singleton ( $ singletonName , function ( ) use ( $ classNameOrInstance ) { return is_string ( $ classNameOrInstance ) ? $ classNameOrInstance :: getInstance ( ) : $ classNameOrInstance ; } ) ; }
8217	public static function getRefererQueryParam ( $ url , $ key ) { if ( ! $ url ) { return null ; } $ query = [ ] ; parse_str ( parse_url ( $ url , PHP_URL_QUERY ) , $ query ) ; if ( isset ( $ query [ $ key ] ) ) { return $ query [ $ key ] ; } return null ; }
479	public function renameColumn ( $ table , $ name , $ newName ) { $ time = $ this -> beginCommand ( "rename column $name in table $table to $newName" ) ; $ this -> db -> createCommand ( ) -> renameColumn ( $ table , $ name , $ newName ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
9382	public function getTag ( $ classNames , $ color = null ) { return ArrayData :: create ( [ 'ClassNames' => $ classNames , 'Color' => $ color ] ) -> renderWith ( sprintf ( '%s\Tag' , self :: class ) ) ; }
3441	protected function normalizePropertyFormat ( ) { if ( empty ( $ this -> fields [ 'PROPERTIES' ] ) ) { return ; } foreach ( $ this -> fields [ 'PROPERTIES' ] as $ code => $ prop ) { $ this -> fields [ 'PROPERTY_' . $ code . '_VALUE' ] = $ prop [ 'VALUE' ] ; $ this -> fields [ '~PROPERTY_' . $ code . '_VALUE' ] = $ prop [ '~VALUE' ] ; $ this -> fields [ 'PROPERTY_' . $ code . '_DESCRIPTION' ] = $ prop [ 'DESCRIPTION' ] ; $ this -> fields [ '~PROPERTY_' . $ code . '_DESCRIPTION' ] = $ prop [ '~DESCRIPTION' ] ; $ this -> fields [ 'PROPERTY_' . $ code . '_VALUE_ID' ] = $ prop [ 'PROPERTY_VALUE_ID' ] ; } }
11052	public static function sprintt ( $ datatree , $ containers , $ entry = 'main' , $ hsr = _ETS_SOURCE_READ , $ hcr = _ETS_CACHE_READ , $ hcw = _ETS_CACHE_WRITE ) { $ ets = new _ets ( $ containers , $ hsr , $ hcr , $ hcw ) ; return $ ets -> build_all ( $ datatree , $ entry ) ; }
520	protected function migrateUp ( $ class ) { if ( $ class === self :: BASE_MIGRATION ) { return true ; } $ this -> stdout ( "*** applying $class\n" , Console :: FG_YELLOW ) ; $ start = microtime ( true ) ; $ migration = $ this -> createMigration ( $ class ) ; if ( $ migration -> up ( ) !== false ) { $ this -> addMigrationHistory ( $ class ) ; $ time = microtime ( true ) - $ start ; $ this -> stdout ( "*** applied $class (time: " . sprintf ( '%.3f' , $ time ) . "s)\n\n" , Console :: FG_GREEN ) ; return true ; } $ time = microtime ( true ) - $ start ; $ this -> stdout ( "*** failed to apply $class (time: " . sprintf ( '%.3f' , $ time ) . "s)\n\n" , Console :: FG_RED ) ; return false ; }
9788	public function setConditions ( $ pValue ) { if ( ! is_array ( $ pValue ) ) { $ pValue = [ $ pValue ] ; } $ this -> condition = $ pValue ; return $ this ; }
10385	protected static function unify_params ( $ type , $ field , $ default = '' ) { $ data = array_column ( self :: $ data [ $ type ] , $ field ) ; switch ( $ field ) { case 'media' : case 'footer' : case 'version' : foreach ( $ data as $ key => $ value ) { if ( $ data [ 0 ] !== $ value ) { return $ default ; } } return ( isset ( $ data [ 0 ] ) && $ data [ 0 ] ) ? $ data [ 0 ] : $ default ; default : $ params = [ ] ; foreach ( $ data as $ key => $ value ) { $ params = array_merge ( $ params , $ value ) ; } return array_unique ( $ params ) ; } }
7221	protected function createLabel ( $ content , $ type , $ format , $ size ) { $ label = new OrderShipmentLabel ( ) ; $ label -> setContent ( $ content ) -> setType ( $ type ) -> setFormat ( $ format ) -> setSize ( $ size ) ; return $ label ; }
9542	public function runSyncAction ( $ syncActionBaseUrl , $ component , $ action , array $ configData ) { $ uriParts = [ ] ; if ( $ this -> super ) { $ uriParts [ ] = $ this -> super ; } $ uriParts [ ] = $ component ; $ uriParts [ ] = 'action' ; $ uriParts [ ] = $ action ; $ uri = rtrim ( $ syncActionBaseUrl , '/' ) . '/' . implode ( '/' , $ uriParts ) ; $ body = [ 'configData' => $ configData , ] ; try { $ request = new Request ( 'POST' , $ uri , [ ] , json_encode ( $ body ) ) ; $ response = $ this -> guzzle -> send ( $ request ) ; } catch ( RequestException $ e ) { throw new ClientException ( $ e -> getMessage ( ) , 0 , $ e ) ; } return $ this -> decodeResponse ( $ response ) ; }
11251	public function getLastBatchNumber ( ) : int { $ stmt = $ this -> pdo -> query ( "select max(batch) from {$this->table}" ) ; $ stmt -> execute ( ) ; return ( int ) $ stmt -> fetch ( PDO :: FETCH_ASSOC ) [ 'max' ] ; }
11026	protected function country ( ) { $ this -> parts [ '{country}' ] = $ this -> form -> field ( $ this -> model , $ this -> model -> getCountryPropertyName ( ) , [ 'options' => [ 'class' => 'form-group' ] ] ) -> dropDownList ( ArrayHelper :: map ( Country :: find ( ) -> orderBy ( [ 'name' => SORT_ASC ] ) -> all ( ) , 'id' , 'name' ) , [ 'id' => $ this -> fieldIds [ 'country' ] , 'prompt' => Yii :: t ( 'jlorente/location' , 'Select country' ) , 'name' => $ this -> getSubmitModelName ( $ this -> model -> getCountryPropertyName ( ) ) ] ) ; }
956	public function isActiveTrial ( ) { return $ this -> isTrial ( ) && Carbon :: today ( ) -> lte ( Carbon :: parse ( $ this -> trial_ends_on ) ) ; }
9241	public function getUrl ( $ language ) { $ lang = [ 'lang' => $ language ] ; $ query = Hash :: merge ( $ this -> request -> query , $ lang ) ; $ urlArray = Hash :: merge ( $ this -> request -> params [ 'pass' ] , [ '?' => $ query ] ) ; return Router :: url ( $ urlArray ) ; }
12810	private static function getForeignKeys ( string $ table ) : array { if ( self :: $ foreignKeysCache !== null && array_key_exists ( $ table , self :: $ foreignKeysCache ) ) return self :: $ foreignKeysCache [ $ table ] ; $ pdo = Database :: connect ( ) ; $ query = " SELECT tc.constraint_name, tc.table_name, kcu.column_name, ccu.table_name AS foreign_table_name, ccu.column_name AS foreign_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = '$table' " ; self :: $ foreignKeysCache [ $ table ] = [ ] ; $ rows = $ pdo -> query ( $ query ) ; while ( $ row = $ rows -> fetch ( ) ) self :: $ foreignKeysCache [ $ table ] [ $ row [ "column_name" ] ] = $ row ; return self :: $ foreignKeysCache [ $ table ] ; }
7062	protected function updateCustomerBalance ( PaymentInterface $ payment , $ amount = null ) { if ( null === $ customer = $ payment -> getSale ( ) -> getCustomer ( ) ) { return false ; } $ amount = $ amount ? : $ payment -> getAmount ( ) ; if ( $ this -> isAcceptedPayment ( $ payment ) ) { $ amount = - $ amount ; } if ( $ payment -> getMethod ( ) -> isCredit ( ) ) { return $ this -> updateCreditBalance ( $ customer , $ amount , true ) ; } elseif ( $ payment -> getMethod ( ) -> isOutstanding ( ) ) { return $ this -> updateOutstandingBalance ( $ customer , $ amount , true ) ; } return false ; }
1502	public function acceptable ( AcceptHeaderInterface $ accept ) : ? Encoding { foreach ( $ accept -> getMediaTypes ( ) as $ mediaType ) { if ( $ encoding = $ this -> matchesTo ( $ mediaType ) ) { return $ encoding ; } } return null ; }
4050	private function prepareInputScreen ( $ modelName , $ screen ) : array { if ( null === $ metaModel = $ this -> factory -> getMetaModel ( $ modelName ) ) { throw new \ InvalidArgumentException ( 'Could not retrieve MetaModel ' . $ modelName ) ; } $ caption = [ '' => $ metaModel -> getName ( ) ] ; $ description = [ '' => $ metaModel -> getName ( ) ] ; foreach ( StringUtil :: deserialize ( $ screen [ 'backendcaption' ] , true ) as $ languageEntry ) { $ langCode = $ languageEntry [ 'langcode' ] ; $ caption [ $ langCode ] = ! empty ( $ label = $ languageEntry [ 'label' ] ) ? $ label : $ caption [ '' ] ; $ description [ $ langCode ] = ! empty ( $ title = $ languageEntry [ 'description' ] ) ? $ title : $ description [ '' ] ; if ( $ metaModel -> getFallbackLanguage ( ) === $ langCode ) { $ caption [ '' ] = $ label ; $ description [ '' ] = $ title ; } } $ result = [ 'meta' => $ screen , 'properties' => $ this -> fetchPropertiesFor ( $ screen [ 'id' ] , $ metaModel ) , 'conditions' => $ this -> fetchConditions ( $ screen [ 'id' ] ) , 'groupSort' => $ this -> fetchGroupSort ( $ screen [ 'id' ] , $ metaModel ) , 'label' => $ caption , 'description' => $ description ] ; $ bySetting = $ this -> buildConditionTree ( $ result [ 'conditions' ] ) ; $ result [ 'legends' ] = $ this -> convertLegends ( $ result [ 'properties' ] , $ metaModel , $ bySetting ) ; return $ result ; }
8838	private function getStatus ( ) : array { $ status = proc_get_status ( $ this -> process ) ; if ( ! $ status [ 'running' ] && is_null ( $ this -> exitCode ) ) { $ this -> exitCode = $ status [ 'exitcode' ] ; } return $ status ; }
5217	protected static function getBindingsForApp ( $ className ) { $ bindings = method_exists ( $ className , '__bindings' ) ? $ className :: __bindings ( ) : [ ] ; if ( ! Runtime :: initialized ( ) ) { $ bindings [ ] = static :: runtime ( ) ; } return $ bindings ; }
5718	public function doPublishAndClose ( $ data , $ form ) { Controller :: curr ( ) -> getResponse ( ) -> addHeader ( "X-Pjax" , "Content" ) ; return $ this -> publish ( $ data , $ form , $ this -> owner , $ this -> getBackLink ( ) ) ; }
9490	protected function getFileDataValue ( $ obFile ) { if ( empty ( $ obFile ) || ! $ obFile instanceof File ) { return null ; } $ sUploadFolder = Config :: get ( 'cms.storage.uploads.path' , '/storage/app/uploads' ) ; return [ 'full_path' => $ obFile -> getPath ( ) , 'path' => $ sUploadFolder . str_replace ( 'uploads' , '' , $ obFile -> getDiskPath ( ) ) , 'title' => $ obFile -> getAttribute ( 'title' ) , 'alt' => $ obFile -> getAttribute ( 'description' ) , ] ; }
12554	public function createTable ( ) { $ stmt = $ this -> pdoConnection -> prepare ( sprintf ( self :: $ CREATE_TABLE , $ this -> tableName ) ) ; return $ stmt -> execute ( ) ; }
800	private function findStart ( Tokens $ tokens , $ index ) { while ( ! $ tokens [ $ index ] -> equalsAny ( [ '$' , [ T_VARIABLE ] ] ) ) { if ( $ tokens [ $ index ] -> equals ( ']' ) ) { $ index = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_INDEX_SQUARE_BRACE , $ index ) ; } elseif ( $ tokens [ $ index ] -> isGivenKind ( CT :: T_DYNAMIC_PROP_BRACE_CLOSE ) ) { $ index = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_DYNAMIC_PROP_BRACE , $ index ) ; } elseif ( $ tokens [ $ index ] -> isGivenKind ( CT :: T_DYNAMIC_VAR_BRACE_CLOSE ) ) { $ index = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_DYNAMIC_VAR_BRACE , $ index ) ; } elseif ( $ tokens [ $ index ] -> isGivenKind ( CT :: T_ARRAY_INDEX_CURLY_BRACE_CLOSE ) ) { $ index = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_ARRAY_INDEX_CURLY_BRACE , $ index ) ; } else { $ index = $ tokens -> getPrevMeaningfulToken ( $ index ) ; } } while ( $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ index ) ] -> equals ( '$' ) ) { $ index = $ tokens -> getPrevMeaningfulToken ( $ index ) ; } if ( $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ index ) ] -> isGivenKind ( T_OBJECT_OPERATOR ) ) { return $ this -> findStart ( $ tokens , $ tokens -> getPrevMeaningfulToken ( $ index ) ) ; } return $ index ; }
3817	private function fetchExisting ( $ table , $ parentId ) { $ this -> startSort = 0 ; $ this -> knownAttributes = [ ] ; $ alreadyExisting = $ this -> connection -> createQueryBuilder ( ) -> select ( '*' ) -> from ( $ table ) -> where ( 'pid=:pid' ) -> setParameter ( 'pid' , $ parentId ) -> orderBy ( 'sorting' ) -> execute ( ) ; foreach ( $ alreadyExisting -> fetchAll ( \ PDO :: FETCH_ASSOC ) as $ item ) { $ this -> knownAttributes [ $ item [ 'attr_id' ] ] = $ item ; $ this -> startSort = $ item [ 'sorting' ] ; } return $ this -> knownAttributes ; }
12154	public function getRequiredRoles ( ) { $ roles = [ ] ; foreach ( Yii :: $ app -> collectors [ 'roles' ] -> getAll ( ) as $ roleItem ) { $ test = false ; switch ( $ roleItem -> systemId ) { case 'owner' : $ test = $ this -> isOwnable ; break ; } if ( $ test ) { $ roles [ ] = $ roleItem -> object -> primaryKey ; } } return $ roles ; }
8635	public function setShipmentFeeList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ShipmentFeeList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
6973	private function buildFieldValue ( ClassMetadata $ metadata , $ propertyPath , $ value ) { $ type = $ metadata -> getTypeOfField ( $ propertyPath ) ; switch ( $ type ) { case 'smallint' : case 'integer' : case 'bigint' : if ( ! is_int ( $ value ) ) { throw new \ Exception ( 'Expected integer.' ) ; } return intval ( $ value ) ; case 'boolean' : if ( ! is_bool ( $ value ) ) { throw new \ Exception ( 'Expected boolean.' ) ; } return ( bool ) $ value ; case 'float' : case 'double' : case 'decimal' : if ( ! is_numeric ( $ value ) ) { throw new \ Exception ( 'Expected float.' ) ; } return floatval ( $ value ) ; case 'datetime' : return new \ DateTime ( $ value ) ; case 'string' : return ( string ) $ value ; } throw new \ Exception ( "Unsupported field type '$type' for path '$propertyPath'." ) ; }
2239	private function addDefaultServerVersion ( array $ extensionConfigs , ContainerBuilder $ container ) : array { $ params = [ ] ; foreach ( $ extensionConfigs as $ extensionConfig ) { if ( isset ( $ extensionConfig [ 'dbal' ] [ 'connections' ] [ 'default' ] ) ) { $ params [ ] = $ extensionConfig [ 'dbal' ] [ 'connections' ] [ 'default' ] ; } } if ( ! empty ( $ params ) ) { $ params = array_merge ( ... $ params ) ; } $ parameterBag = $ container -> getParameterBag ( ) ; foreach ( $ params as $ key => $ value ) { $ params [ $ key ] = $ parameterBag -> resolveValue ( $ value ) ; } try { $ connection = DriverManager :: getConnection ( $ params ) ; $ connection -> connect ( ) ; $ connection -> close ( ) ; } catch ( DriverException $ e ) { $ extensionConfigs [ ] = [ 'dbal' => [ 'connections' => [ 'default' => [ 'server_version' => '5.5' , ] , ] , ] , ] ; } return $ extensionConfigs ; }
9885	private function writeDefinedNameForNamedRange ( XMLWriter $ objWriter , NamedRange $ pNamedRange ) { $ objWriter -> startElement ( 'definedName' ) ; $ objWriter -> writeAttribute ( 'name' , $ pNamedRange -> getName ( ) ) ; if ( $ pNamedRange -> getLocalOnly ( ) ) { $ objWriter -> writeAttribute ( 'localSheetId' , $ pNamedRange -> getScope ( ) -> getParent ( ) -> getIndex ( $ pNamedRange -> getScope ( ) ) ) ; } $ range = Coordinate :: splitRange ( $ pNamedRange -> getRange ( ) ) ; $ iMax = count ( $ range ) ; for ( $ i = 0 ; $ i < $ iMax ; ++ $ i ) { $ range [ $ i ] [ 0 ] = '\'' . str_replace ( "'" , "''" , $ pNamedRange -> getWorksheet ( ) -> getTitle ( ) ) . '\'!' . Coordinate :: absoluteReference ( $ range [ $ i ] [ 0 ] ) ; if ( isset ( $ range [ $ i ] [ 1 ] ) ) { $ range [ $ i ] [ 1 ] = Coordinate :: absoluteReference ( $ range [ $ i ] [ 1 ] ) ; } } $ range = Coordinate :: buildRange ( $ range ) ; $ objWriter -> writeRawData ( $ range ) ; $ objWriter -> endElement ( ) ; }
10151	private function readFooter ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; if ( ! $ this -> readDataOnly ) { if ( $ recordData ) { if ( $ this -> version == self :: XLS_BIFF8 ) { $ string = self :: readUnicodeStringLong ( $ recordData ) ; } else { $ string = $ this -> readByteStringShort ( $ recordData ) ; } $ this -> phpSheet -> getHeaderFooter ( ) -> setOddFooter ( $ string [ 'value' ] ) ; $ this -> phpSheet -> getHeaderFooter ( ) -> setEvenFooter ( $ string [ 'value' ] ) ; } } }
10759	public function set ( $ col , $ value = ClauseInterface :: NO_VALUE ) { if ( is_array ( $ col ) ) { return $ this -> setWithArrayData ( $ col ) ; } if ( ! isset ( $ this -> clause_set [ $ col ] ) ) { $ this -> clause_set [ $ col ] = true ; } if ( ClauseInterface :: NO_VALUE !== $ value ) { $ this -> clause_data [ $ this -> clause_rownum ] [ $ col ] = $ value ; } return $ this ; }
12942	public function create ( $ className , $ username ) { $ reflectionClass = new \ ReflectionClass ( $ className ) ; $ permalinks = $ this -> pagesParser -> contributor ( $ username ) -> parse ( ) -> permalinksByLanguage ( $ this -> configurationHandler -> language ( ) . '_' . $ this -> configurationHandler -> country ( ) ) ; $ permalinksForSelect = ( ! empty ( $ permalinks ) ) ? array_combine ( $ permalinks , $ permalinks ) : array ( ) ; $ params = array ( $ permalinksForSelect ) ; $ form = $ this -> formFactory -> create ( $ reflectionClass -> newInstanceArgs ( $ params ) ) ; return $ form -> createView ( ) ; }
8833	public function generateFromPattern ( $ pattern , $ amount = 1 , $ safeguard = 100 ) { $ lexer = new \ Gajus \ Paggern \ Lexer ( ) ; $ tokens = $ lexer -> tokenise ( $ pattern , true ) ; $ codes = array_fill ( 0 , $ amount + $ safeguard , '' ) ; foreach ( $ tokens as & $ token ) { if ( $ token [ 'type' ] !== 'literal' ) { $ token [ 'pool' ] = $ this -> generator -> generateString ( $ token [ 'repetition' ] * ( $ amount + $ safeguard ) , $ token [ 'haystack' ] ) ; } unset ( $ token ) ; } foreach ( $ codes as $ i => & $ code ) { foreach ( $ tokens as $ token ) { if ( $ token [ 'type' ] === 'literal' ) { $ code .= $ token [ 'string' ] ; } else { $ code .= mb_substr ( $ token [ 'pool' ] , $ token [ 'repetition' ] * $ i , $ token [ 'repetition' ] ) ; } } unset ( $ code ) ; } $ codes = array_slice ( array_unique ( $ codes ) , 0 , $ amount ) ; if ( count ( $ codes ) < $ amount ) { throw new Exception \ RuntimeException ( 'Unique combination pool exhausted.' ) ; } return $ codes ; }
11354	private function generateProxy ( $ className ) { if ( isset ( $ this -> checkedClasses [ $ className ] ) ) { return $ this -> checkedClasses [ $ className ] ; } $ proxyParameters = array ( 'className' => $ className , 'factory' => get_class ( $ this ) , 'proxyManagerVersion' => Version :: VERSION ) ; $ proxyClassName = $ this -> configuration -> getClassNameInflector ( ) -> getProxyClassName ( $ className , $ proxyParameters ) ; $ this -> generateProxyClass ( $ proxyClassName , $ className , $ proxyParameters ) ; $ this -> configuration -> getSignatureChecker ( ) -> checkSignature ( new ReflectionClass ( $ proxyClassName ) , $ proxyParameters ) ; return $ this -> checkedClasses [ $ className ] = $ proxyClassName ; }
3614	public function setTargetTemperatures ( $ temp_low , $ temp_high , $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ temp_low = $ this -> temperatureInCelsius ( $ temp_low , $ serial_number ) ; $ temp_high = $ this -> temperatureInCelsius ( $ temp_high , $ serial_number ) ; $ data = json_encode ( array ( 'target_change_pending' => TRUE , 'target_temperature_low' => $ temp_low , 'target_temperature_high' => $ temp_high ) ) ; return $ this -> doPOST ( "/v2/put/shared." . $ serial_number , $ data ) ; }
11345	public function render ( ) { $ html = $ this -> formatter -> renderFormBegin ( $ this -> formTags ) ; foreach ( $ this -> fields as $ field ) { $ html .= $ this -> formatter -> renderField ( $ field ) ; } $ html .= $ this -> renderSubmit ( ) ; $ html .= $ this -> renderEnd ( ) ; return $ html ; }
6643	public static function decodeId ( $ hash , $ salt , $ hashLength = self :: MIN_HASH_LENGTH ) { $ hashIds = new Hashids ( $ salt , $ hashLength ) ; return ArrayHelper :: getValue ( $ hashIds -> decode ( $ hash ) , '0' ) ; }
9299	public function postAction ( Request $ request ) { try { $ data = $ this -> get ( 'ongr_api.batch_request_handler' ) -> handleRequest ( $ request , $ repository = $ this -> getRequestRepository ( $ request ) , 'create' ) ; return $ this -> renderRest ( $ request , $ data , Response :: HTTP_OK ) ; } catch ( \ Exception $ e ) { return $ this -> renderError ( $ request , $ e -> getMessage ( ) , Response :: HTTP_BAD_REQUEST ) ; } }
9928	protected function valueIsEmpty ( $ value ) { return ( is_object ( $ value ) && $ value instanceof Parameters && $ value -> isEmpty ( ) ) || ( is_array ( $ value ) && ! count ( $ value ) ) ; }
7928	public function unregisterNamespace ( $ ns ) { list ( $ ns ) = $ this -> fireEvent ( 'namespace.unregister' , [ $ ns ] ) ; unset ( $ this -> namespaces [ $ ns ] ) ; return $ this ; }
1337	protected function getQueryParameters ( EncodingParametersInterface $ parameters ) { return new EncodingParameters ( $ parameters -> getIncludePaths ( ) , $ parameters -> getFieldSets ( ) , $ parameters -> getSortParameters ( ) ? : $ this -> defaultSort ( ) , $ parameters -> getPaginationParameters ( ) ? : $ this -> defaultPagination ( ) , $ parameters -> getFilteringParameters ( ) , $ parameters -> getUnrecognizedParameters ( ) ) ; }
10357	protected static function highlightCode ( string $ file , int $ line , int $ padding = 6 ) : array { if ( ! is_readable ( $ file ) ) { return false ; } $ handle = fopen ( $ file , 'r' ) ; $ lines = array ( ) ; $ currentLine = 0 ; while ( ! feof ( $ handle ) ) { $ currentLine ++ ; $ temp = fgets ( $ handle ) ; if ( $ currentLine > $ line + $ padding ) { break ; } if ( $ currentLine >= ( $ line - $ padding ) && $ currentLine <= ( $ line + $ padding ) ) { $ lines [ ] = array ( 'number' => str_pad ( $ currentLine , 4 , ' ' , STR_PAD_LEFT ) , 'highlighted' => ( $ currentLine === $ line ) , 'code' => ErrorHandler :: highlightString ( $ temp ) , ) ; } } fclose ( $ handle ) ; return $ lines ; }
8317	protected function sendResetMail ( $ userData ) { if ( ! $ this -> mailer ) { $ this -> getLogger ( ) -> critical ( "Sending mail but no mailer is set!" ) ; return ; } $ url = $ this -> createResetToken ( $ userData [ 'name' ] ) ; $ message = $ this -> picoAuth -> getPico ( ) -> substituteFileContent ( $ this -> config [ "emailMessage" ] ) ; $ subject = $ this -> picoAuth -> getPico ( ) -> substituteFileContent ( $ this -> config [ "emailSubject" ] ) ; $ message = str_replace ( "%url%" , $ url , $ message ) ; $ message = str_replace ( "%username%" , $ userData [ 'name' ] , $ message ) ; $ this -> mailer -> setup ( ) ; $ this -> mailer -> setTo ( $ userData [ 'email' ] ) ; $ this -> mailer -> setSubject ( $ subject ) ; $ this -> mailer -> setBody ( $ message ) ; if ( ! $ this -> mailer -> send ( ) ) { $ this -> getLogger ( ) -> critical ( "Mailer error: {e}" , [ "e" => $ this -> mailer -> getError ( ) ] ) ; } else { $ this -> getLogger ( ) -> info ( "PwReset email sent to {email}" , [ "email" => $ userData [ 'email' ] ] ) ; } }
7365	protected function resolveOutstandingDate ( SaleInterface $ sale ) { if ( ! $ sale instanceof InvoiceSubjectInterface ) { return null ; } if ( ! $ sale instanceof ShipmentSubjectInterface ) { return null ; } if ( null === $ term = $ sale -> getPaymentTerm ( ) ) { return null ; } if ( ! $ this -> saleHasOutstandingPayments ( $ sale ) ) { return null ; } $ from = null ; switch ( $ term -> getTrigger ( ) ) { case PaymentTermTriggers :: TRIGGER_SHIPPED : $ from = $ sale -> getShippedAt ( ) ; break ; case PaymentTermTriggers :: TRIGGER_FULLY_SHIPPED : if ( $ sale -> getShipmentState ( ) === ShipmentStates :: STATE_COMPLETED ) { $ from = $ sale -> getShippedAt ( true ) ; } break ; case PaymentTermTriggers :: TRIGGER_INVOICED : $ from = $ sale -> getInvoicedAt ( ) ; break ; case PaymentTermTriggers :: TRIGGER_FULLY_INVOICED : if ( $ sale -> getInvoiceState ( ) === InvoiceStates :: STATE_COMPLETED ) { $ from = $ sale -> getInvoicedAt ( true ) ; } break ; } if ( null === $ from ) { return null ; } $ date = clone $ from ; $ date -> setTime ( 23 , 59 , 59 ) ; $ date -> modify ( sprintf ( '+%s days' , $ term -> getDays ( ) ) ) ; if ( $ term -> getEndOfMonth ( ) ) { $ date -> modify ( 'last day of this month' ) ; } return $ date ; }
4156	function every ( $ interval , Job $ job ) { $ expression = new SimpleExpression ( $ interval ) ; $ this -> add ( $ expression , $ job ) ; return $ this ; }
3120	public function remove ( $ tag , $ target = TimePoint :: TARGET_ALL , $ type = TimePoint :: TYPE_ALL ) { $ tags = is_array ( $ tag ) ? $ tag : [ $ tag ] ; $ removed = 0 ; foreach ( $ this -> points as $ idx => $ point ) { if ( $ point -> match ( $ tags , $ target , $ type ) ) { unset ( $ this -> points [ $ idx ] ) ; $ removed ++ ; } } return $ removed ; }
6309	public function drop ( DatabaseObjectInterface $ databaseObject , $ cascade = false ) { $ command = $ this -> getCommand ( $ databaseObject , false ) ; if ( $ cascade ) { $ command -> cascade ( ) ; } return $ command -> execute ( ) ; }
11658	public static function addEntriesToFile ( $ file , $ entries ) { $ properties = self :: readFromFile ( $ file ) ; foreach ( $ entries as $ key => $ value ) { $ properties [ $ key ] = $ value ; } self :: saveToFile ( $ file , $ properties ) ; }
7431	public static function getInstance ( ) : MimeType { if ( null === self :: $ instance ) { self :: $ instance = new self ( ) ; } return self :: $ instance ; }
7034	protected function saveMigration ( array $ tables ) { try { $ tables = serialize ( $ tables ) ; return Db :: query ( "insert into migrations(host, tables) values(?, ?)" , [ gethostname ( ) , $ tables ] , $ this -> dbName , false ) ; } catch ( PDOException $ e ) { error_log ( $ e -> getMessage ( ) ) ; return false ; } }
12598	public function isCacheable ( $ namespace ) { if ( ! $ this -> cacheOptions -> isEnabled ( ) ) { return false ; } $ namespaces = $ this -> cacheOptions -> getNamespaces ( ) ; if ( empty ( $ namespaces ) ) { return true ; } return in_array ( $ namespace , $ namespaces ) ; }
7079	public static function getTypes ( ) { return [ self :: TYPE_WEBSITE , self :: TYPE_USER , self :: TYPE_ADMINISTRATOR , self :: TYPE_IN_CHARGE , self :: TYPE_CUSTOMER , self :: TYPE_SALESMAN , self :: TYPE_ACCOUNTABLE , self :: TYPE_SUPPLIER , ] ; }
8005	public static function calculatePayloadOffset ( $ negotiate_flags ) { $ offset = 0 ; $ offset += strlen ( static :: SIGNATURE ) ; $ offset += 4 ; $ offset += 4 ; $ offset += 8 ; $ offset += 8 ; return $ offset ; }
2861	public function getRange ( $ logFile ) { if ( ! array_key_exists ( $ logFile , $ this -> ranges ) ) { throw new Exception ( 'Invalid log file' ) ; } return $ this -> ranges [ $ logFile ] ; }
2680	public function checkImageOptimizationStatus ( ) { $ url = $ this -> _getApiServiceUri ( ) . 'dynamic_io_settings' ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: GET ) ; return $ result ; }
12265	public function findInSourceDirs ( Finder $ finder ) { foreach ( $ this -> sourceDirs as $ dir ) { $ finder -> in ( $ dir ) ; } return $ finder ; }
2260	protected static function braceGlob ( $ pattern ) { if ( false === strpos ( $ pattern , '/**/' ) && ( \ defined ( 'GLOB_BRACE' ) || false === strpos ( $ pattern , '{' ) ) ) { return glob ( $ pattern , \ defined ( 'GLOB_BRACE' ) ? GLOB_BRACE : 0 ) ; } $ finder = new Finder ( ) ; $ regex = Glob :: toRegex ( $ pattern ) ; $ filesIterator = $ finder -> files ( ) -> followLinks ( ) -> sortByName ( ) -> in ( \ dirname ( $ pattern ) ) ; $ filesIterator = $ filesIterator -> filter ( function ( \ SplFileInfo $ info ) use ( $ regex ) { $ path = $ info -> getPathname ( ) ; return preg_match ( $ regex , $ path ) && $ info -> isFile ( ) ; } ) ; $ files = iterator_to_array ( $ filesIterator ) ; return array_keys ( $ files ) ; }
11110	private function findExtensionsDirectories ( Container $ app ) { $ directories = $ app [ 'config.finder' ] -> ignoreUnreadableDirs ( ) -> directories ( ) -> name ( '*Extension' ) -> in ( $ app [ 'app.extensions.dir' ] ) -> depth ( '< 3' ) -> sortByName ( ) ; return $ directories ; }
6095	public function permAssign ( $ permid , $ permvalue , $ permskip = false ) { return $ this -> getParent ( ) -> clientPermAssign ( $ this [ "client_database_id" ] , $ permid , $ permvalue , $ permskip ) ; }
5353	public function getSupportedAuthentication ( ) { if ( empty ( $ this -> data -> authentication ) || empty ( $ this -> data -> authentication ) ) { return array ( ) ; } return ( array ) $ this -> data -> authentication ; }
8751	private function addCurrentMessage ( ) { if ( $ this -> currentMessage -> hasTranslation ( ) ) { $ this -> messages [ ] = $ this -> currentMessage ; $ this -> currentMessage = new Message ( ) ; } }
6113	public function sendPluginCmd ( $ plugin , $ data , $ cpw = null , $ subscribed = false ) { if ( $ this -> getId ( ) != $ this -> getParent ( ) -> whoamiGet ( "client_channel_id" ) ) { $ this -> getParent ( ) -> clientMove ( $ this -> getParent ( ) -> whoamiGet ( "client_id" ) , $ this -> getId ( ) , $ cpw ) ; } $ this -> execute ( "plugincmd" , array ( "name" => $ plugin , "data" => $ data , "targetmode" => $ subscribed ? TeamSpeak3 :: PLUGINCMD_CHANNEL_SUBSCRIBED : TeamSpeak3 :: PLUGINCMD_CHANNEL ) ) ; }
7685	function XML_DeleteColumnElements ( & $ Txt , $ Tag , $ SpanAtt , $ ColLst , $ ColMax ) { $ ColNum = 0 ; $ ColPos = 0 ; $ ColQty = 1 ; $ Continue = true ; $ ModifNbr = 0 ; while ( $ Continue && ( $ Loc = clsTbsXmlLoc :: FindElement ( $ Txt , $ Tag , $ ColPos , true ) ) ) { if ( $ SpanAtt !== false ) { $ ColQty = $ Loc -> GetAttLazy ( $ SpanAtt ) ; $ ColQty = ( $ ColQty === false ) ? 1 : intval ( $ ColQty ) ; } $ KeepQty = 0 ; for ( $ i = 1 ; $ i <= $ ColQty ; $ i ++ ) { if ( array_search ( $ ColNum + $ i , $ ColLst ) === false ) $ KeepQty ++ ; } if ( $ KeepQty == 0 ) { $ Loc -> ReplaceSrc ( '' ) ; $ ModifNbr ++ ; } else { if ( $ KeepQty != $ ColQty ) { $ Loc -> ReplaceAtt ( $ SpanAtt , $ KeepQty ) ; $ ModifNbr ++ ; } $ ColPos = $ Loc -> PosEnd + 1 ; } $ ColNum += $ ColQty ; if ( $ ColNum > $ ColMax ) $ Continue = false ; } return $ ModifNbr ; }
8128	public static function findByPasswordResetToken ( $ id , $ code ) { if ( ! static :: isPasswordResetTokenValid ( $ code ) ) { return NULL ; } return static :: findOne ( [ 'id' => $ id , 'password_reset_token' => $ code , 'status' => self :: STATUS_ACTIVE , ] ) ; }
1610	private function _isRedirectRegex ( $ uri ) { if ( preg_match ( '/\/(.*)\/([g|m|i|x|X|s|u|U|A|J|D]+)/m' , $ uri ) === 0 ) { $ i = preg_match_all ( '/(?<!\\\\)\?(?![^(]*\))/' , $ uri , $ matches , PREG_OFFSET_CAPTURE ) ; while ( $ i -- ) { $ x = $ matches [ 0 ] [ $ i ] [ 1 ] ; $ uri = substr_replace ( $ uri , '\?' , $ x , 1 ) ; } $ i = preg_match_all ( '/(?<!\\\\)\/(?![^(]*\))/' , $ uri , $ matches , PREG_OFFSET_CAPTURE ) ; while ( $ i -- ) { $ x = $ matches [ 0 ] [ $ i ] [ 1 ] ; $ uri = substr_replace ( $ uri , '\/' , $ x , 1 ) ; } } if ( @ preg_match ( $ uri , null ) === false ) $ uri = '/^' . $ uri . '$/i' ; if ( @ preg_match ( $ uri , null ) !== false ) return $ uri ; return false ; }
6580	public static function fromPolar ( $ length , $ ap , $ av ) { return new static ( $ length * cos ( $ ap ) * cos ( $ av ) , $ length * sin ( $ ap ) * cos ( $ av ) , $ length * sin ( $ av ) ) ; }
9288	public function truncate ( ) { $ adapter = $ this -> dbAdapter ; $ mapper = new \ CronHelper \ Model \ JobMapper ( $ adapter ) ; $ where = new \ Zend \ Db \ Sql \ Where ( ) ; $ mapper -> deleteByWhere ( $ where ) ; }
7347	static public function calculateDeliveryRemainingQuantity ( $ item ) { if ( $ item instanceof SupplierOrderItemInterface ) { return $ item -> getQuantity ( ) - static :: calculateReceivedQuantity ( $ item ) ; } if ( ! $ item instanceof SupplierDeliveryItemInterface ) { throw new InvalidArgumentException ( "Expected instance of " . SupplierOrderItemInterface :: class . " or " . SupplierDeliveryItemInterface :: class ) ; } $ orderItem = $ item -> getOrderItem ( ) ; $ result = $ orderItem -> getQuantity ( ) - static :: calculateReceivedQuantity ( $ orderItem ) ; if ( 0 < $ item -> getQuantity ( ) ) { $ result += $ item -> getQuantity ( ) ; } return $ result ; }
10723	public function raw ( $ sql , array $ params ) { $ stmt = $ this -> connect ( ) -> prepare ( $ sql ) ; $ stmt -> execute ( $ params ) ; if ( stripos ( $ sql , 'select' ) === 0 ) { return $ stmt -> fetchAll ( PDO :: FETCH_ASSOC ) ; } if ( stripos ( $ sql , 'insert' ) === 0 ) { return $ this -> connect ( ) -> lastInsertId ( ) ; } return $ stmt -> execute ( ) ; }
771	public function actionConfig ( $ filePath ) { $ filePath = Yii :: getAlias ( $ filePath ) ; $ dir = dirname ( $ filePath ) ; if ( file_exists ( $ filePath ) ) { if ( ! $ this -> confirm ( "File '{$filePath}' already exists. Do you wish to overwrite it?" ) ) { return ExitCode :: OK ; } } $ array = VarDumper :: export ( $ this -> getOptionValues ( $ this -> action -> id ) ) ; $ content = <<<EOD<?php/** * Configuration file for 'yii {$this->id}/{$this->defaultAction}' command. * * This file is automatically generated by 'yii {$this->id}/{$this->action->id}' command. * It contains parameters for source code messages extraction. * You may modify this file to suit your needs. * * You can use 'yii {$this->id}/{$this->action->id}-template' command to create * template configuration file with detailed description for each parameter. */return $array;EOD ; if ( FileHelper :: createDirectory ( $ dir ) === false || file_put_contents ( $ filePath , $ content , LOCK_EX ) === false ) { $ this -> stdout ( "Configuration file was NOT created: '{$filePath}'.\n\n" , Console :: FG_RED ) ; return ExitCode :: UNSPECIFIED_ERROR ; } $ this -> stdout ( "Configuration file created: '{$filePath}'.\n\n" , Console :: FG_GREEN ) ; return ExitCode :: OK ; }
11922	public function getAmount ( ) { $ amount = $ this -> getPerUnitAmount ( ) ; $ totalAmount = bcmul ( $ amount , $ this -> getQuantity ( ) , 2 ) ; return floatval ( $ totalAmount ) ; }
5032	public function getLoadedPage ( $ default = null ) { if ( ! $ this -> loadedPage ) { if ( is_callable ( $ default ) ) { $ page = call_user_func ( $ default , $ this ) ; if ( $ page !== null ) { $ this -> setLoadedPage ( $ page ) ; } } if ( ! $ this -> loadedPage ) { throw new NotFoundHttpException ( "There is no page currently loaded, but it was expected" ) ; } } return $ this -> loadedPage ; }
10044	private function createSelectAssociationFormItem ( Model $ model , Column $ column , $ item ) { $ result = new SelectFormItem ( ) ; $ relations = $ this -> aujaConfigurator -> getRelationsForModel ( $ model ) ; $ relatedModel = null ; foreach ( $ relations as $ relation ) { $ rightModel = $ relation -> getRight ( ) ; if ( starts_with ( $ column -> getName ( ) , camel_case ( $ rightModel -> getName ( ) ) ) ) { $ relatedModel = $ rightModel ; } } if ( $ relatedModel != null ) { $ displayName = $ this -> aujaConfigurator -> getDisplayName ( $ relatedModel ) ; $ result -> setName ( $ displayName ) ; $ result -> setValue ( $ item -> id ) ; $ items = call_user_func ( array ( $ relatedModel -> getName ( ) , 'all' ) ) ; $ displayField = $ this -> aujaConfigurator -> getDisplayField ( $ relatedModel ) ; foreach ( $ items as $ item ) { $ label = isset ( $ item -> $ displayField ) ? $ item -> $ displayField : '' ; $ value = $ item -> id ; $ option = new SelectOption ( $ label , $ value ) ; $ result -> addOption ( $ option ) ; } } return $ result ; }
8857	private function _relativeSymlinkWithFallback ( string $ originDir , string $ targetDir ) : string { try { $ this -> _symlink ( $ originDir , $ targetDir , true ) ; $ method = AssetsInstallCommand :: METHOD_RELATIVE_SYMLINK ; } catch ( IOException $ e ) { $ method = $ this -> _absoluteSymlinkWithFallback ( $ originDir , $ targetDir ) ; } return $ method ; }
1161	private function fakeRequiredIfData ( $ data , $ rule , $ parameters ) { if ( $ rule !== 'RequiredIf' ) { return ; } $ newData = $ data ; $ newData [ $ parameters [ 0 ] ] = $ parameters [ 1 ] ; $ this -> validator -> setData ( $ newData ) ; }
7807	protected function closingBalance ( $ text ) { if ( $ line = $ this -> getLine ( '62M' , $ text ) ) { return $ this -> balance ( $ this -> reader -> createClosingBalance ( ) , $ line ) ; } }
10485	protected function getTableMapping ( $ table ) { if ( array_key_exists ( $ table , $ this -> mappings ) ) { return $ this -> mappings [ $ table ] ; } $ mapping = $ this -> retrieveMapping ( $ table ) ; if ( empty ( $ mapping ) ) { throw new \ UnderflowException ( "Table with name {$table} not found." ) ; } $ this -> mappings [ $ table ] = $ mapping ; return $ mapping ; }
2097	public static function getRegexp ( $ strFormat = null ) { if ( $ strFormat === null ) { $ strFormat = static :: getNumericDateFormat ( ) ; } if ( ! static :: isNumericFormat ( $ strFormat ) ) { throw new \ Exception ( sprintf ( 'Invalid date format "%s"' , $ strFormat ) ) ; } return preg_replace_callback ( '/[a-zA-Z]/' , function ( $ matches ) { $ arrRegexp = array ( 'a' => '(?P<a>am|pm)' , 'A' => '(?P<A>AM|PM)' , 'd' => '(?P<d>0[1-9]|[12][0-9]|3[01])' , 'g' => '(?P<g>[1-9]|1[0-2])' , 'G' => '(?P<G>[0-9]|1[0-9]|2[0-3])' , 'h' => '(?P<h>0[1-9]|1[0-2])' , 'H' => '(?P<H>[01][0-9]|2[0-3])' , 'i' => '(?P<i>[0-5][0-9])' , 'j' => '(?P<j>[1-9]|[12][0-9]|3[01])' , 'm' => '(?P<m>0[1-9]|1[0-2])' , 'n' => '(?P<n>[1-9]|1[0-2])' , 's' => '(?P<s>[0-5][0-9])' , 'Y' => '(?P<Y>[0-9]{4})' , 'y' => '(?P<y>[0-9]{2})' , ) ; return $ arrRegexp [ $ matches [ 0 ] ] ?? $ matches [ 0 ] ; } , preg_quote ( $ strFormat ) ) ; }
2278	public function setPagesFlags ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ dc -> activeRecord && $ dc -> activeRecord -> type == 'search' ) { $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'fields' ] [ $ dc -> field ] [ 'eval' ] [ 'mandatory' ] = false ; unset ( $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'fields' ] [ $ dc -> field ] [ 'eval' ] [ 'orderField' ] ) ; } return $ varValue ; }
10483	public static function createSoftBounce ( $ recipientEmailAddress , $ listExternalId , $ recipientExternalId = null , $ ipAddress = '127.0.0.1' ) { if ( $ recipientExternalId == null ) { $ recipientExternalId = rand ( 1 , 99999 ) ; } return ( new Payload ( ) ) -> setIpAddress ( $ ipAddress ) -> setAction ( Type :: SOFT_BOUNCE ) -> setCampaignId ( rand ( 1 , 99999 ) ) -> setListExternalId ( $ listExternalId ) -> setReason ( Type :: REASON_SYSTEM_AUTOMATIC ) -> setRecipientEmailAddress ( $ recipientEmailAddress ) -> setHash ( md5 ( $ recipientEmailAddress ) ) -> setRecipientExternalId ( $ recipientExternalId ) -> setTriggerDate ( new \ DateTime ( ) ) -> setType ( Type :: SOFT_BOUNCE ) ; }
9784	public function parseHTML ( ) { $ token = $ this -> pop ( 'HTML' ) ; $ value = $ this -> stripQuotes ( $ token [ 1 ] ) ; $ this -> currLine += substr_count ( $ value , "\n" ) ; return '$output .= \'' . $ value . "';\n" ; }
1715	public function hasAccess ( $ field , $ array ) { if ( $ this -> isAdmin ) { return true ; } if ( ! \ is_array ( $ field ) ) { $ field = array ( $ field ) ; } if ( \ is_array ( $ this -> $ array ) && array_intersect ( $ field , $ this -> $ array ) ) { return true ; } elseif ( $ array == 'filemounts' ) { foreach ( $ this -> filemounts as $ folder ) { if ( preg_match ( '/^' . preg_quote ( $ folder , '/' ) . '(\/|$)/i' , $ field [ 0 ] ) ) { return true ; } } } return false ; }
11498	public static function locate ( $ column , $ value ) { $ table = new static ( ) ; $ select = $ table -> select ( ) -> where ( "{$table->getAdapter()->quoteIdentifier($column)} = ?" , $ value ) -> limit ( 1 ) ; return $ table -> fetchRow ( $ select ) ; }
6356	public static function convert ( $ style = TS_UNIX , $ ts ) { try { $ ct = new static ( $ ts ) ; return $ ct -> getTimestamp ( $ style ) ; } catch ( TimestampException $ e ) { return false ; } }
7407	public function serialize ( ) : string { return serialize ( [ '_type' => $ this -> _type , '_arrayOptions' => $ this -> _arrayOptions , '_jsonOptions' => $ this -> _jsonOptions , '_container' => $ this -> _container , ] ) ; }
11917	public function newInstanceQuery ( array $ data = [ ] , array $ selectable = [ '*' ] ) { $ tm = new TextGenerator ( ) ; $ r = $ this -> newInstanceRepository ( ) ; $ query = $ r -> newQuery ( ) ; if ( ! empty ( $ this -> filter ) ) { $ filter = new Filter ( $ r -> getTableName ( ) , $ selectable ) ; $ filter -> build ( $ query , $ tm -> generateAndRender ( $ this -> filter , $ data ) ) ; } return $ query ; }
2498	private function getLanguageFilter ( array $ languageCodes ) { $ languageFilters = array ( ) ; foreach ( $ languageCodes as $ languageCode ) { $ condition = new CustomField ( self :: FIELD_LANGUAGE , Operator :: EQ , $ languageCode ) ; $ excluded = $ this -> getExcludedLanguageCodes ( $ languageCodes , $ languageCode ) ; if ( ! empty ( $ excluded ) ) { $ condition = new LogicalAnd ( array ( $ condition , new LogicalNot ( new CustomField ( self :: FIELD_LANGUAGES , Operator :: IN , $ excluded ) ) , ) ) ; } $ languageFilters [ ] = $ condition ; } if ( count ( $ languageFilters ) > 1 ) { $ languageFilters = array ( new LogicalOr ( $ languageFilters ) ) ; } if ( $ this -> hasMainLanguagesEndpoint ) { $ languageFilters [ ] = new LogicalNot ( new CustomField ( self :: FIELD_IS_MAIN_LANGUAGES_INDEX , Operator :: EQ , true ) ) ; } if ( count ( $ languageFilters ) > 1 ) { return new LogicalAnd ( $ languageFilters ) ; } return reset ( $ languageFilters ) ; }
12846	public function runHttpErrorPage ( int $ iError ) { if ( isset ( $ _SERVER ) && isset ( $ _SERVER [ 'HTTP_HOST' ] ) ) { foreach ( Config :: get ( 'route' ) as $ sHost => $ oHost ) { if ( ( ! strstr ( $ sHost , '/' ) && $ sHost == $ _SERVER [ 'HTTP_HOST' ] ) || ( strstr ( $ sHost , '/' ) && strstr ( $ _SERVER [ 'HTTP_HOST' ] . $ _SERVER [ 'REQUEST_URI' ] , $ sHost ) ) ) { $ this -> _oRoutes = $ oHost -> routes ; if ( strstr ( $ sHost , '/' ) && strstr ( $ _SERVER [ 'HTTP_HOST' ] . $ _SERVER [ 'REQUEST_URI' ] , $ sHost ) ) { $ this -> _sBaseUri = preg_replace ( '#^[^/]+#' , '' , $ sHost ) ; } $ sHttpErrorPageName = '_getPage' . iError ; $ this -> $ sHttpErrorPageName ( ) ; } } } }
4160	public function getLoginUrl ( $ scope = array ( ) , $ state = null ) { $ scope = $ this -> mergeScope ( $ scope ) ; $ state = is_string ( $ state ) ? "&state={$state}" : '' ; return self :: API_OAUTH_URL . '?client_id=' . $ this -> getApiKey ( ) . '&redirect_uri=' . urlencode ( $ this -> getApiCallback ( ) ) . '&scope=' . implode ( '+' , $ scope ) . '&response_type=code' . $ state ; }
1571	public function getProcessId ( ) : ? string { if ( is_null ( $ this -> processId ) ) { return $ this -> parameter ( ResourceRegistrar :: PARAM_PROCESS_ID ) ; } return $ this -> processId ? : null ; }
624	public function findWith ( $ with , & $ models ) { $ primaryModel = reset ( $ models ) ; if ( ! $ primaryModel instanceof ActiveRecordInterface ) { $ modelClass = $ this -> modelClass ; $ primaryModel = $ modelClass :: instance ( ) ; } $ relations = $ this -> normalizeRelations ( $ primaryModel , $ with ) ; foreach ( $ relations as $ name => $ relation ) { if ( $ relation -> asArray === null ) { $ relation -> asArray ( $ this -> asArray ) ; } $ relation -> populateRelation ( $ name , $ models ) ; } }
8719	public function fresh ( $ with = [ ] ) { if ( ! $ this -> exists ) { return ; } $ query = static :: newQueryWithoutScopes ( ) -> with ( is_string ( $ with ) ? func_get_args ( ) : $ with ) -> where ( $ this -> getKeyName ( ) , $ this -> getKey ( ) ) ; ( new TranslatableScope ( ) ) -> apply ( $ query , $ this ) ; return $ query -> first ( ) ; }
2447	public function notifyOfReply ( Contao \ DataContainer $ dc ) { if ( ! $ dc -> activeRecord || ! $ dc -> activeRecord -> addReply || $ dc -> activeRecord -> notifyReply ) { return ; } $ objNotify = Contao \ CommentsNotifyModel :: findActiveBySourceAndParent ( $ dc -> activeRecord -> source , $ dc -> activeRecord -> parent ) ; if ( $ objNotify !== null ) { while ( $ objNotify -> next ( ) ) { $ strUrl = Contao \ Idna :: decode ( Contao \ Environment :: get ( 'base' ) ) . $ objNotify -> url ; $ objEmail = new Contao \ Email ( ) ; $ objEmail -> from = $ GLOBALS [ 'TL_ADMIN_EMAIL' ] ; $ objEmail -> fromName = $ GLOBALS [ 'TL_ADMIN_NAME' ] ; $ objEmail -> subject = sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'com_notifyReplySubject' ] , Contao \ Idna :: decode ( Contao \ Environment :: get ( 'host' ) ) ) ; $ objEmail -> text = sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'com_notifyReplyMessage' ] , $ objNotify -> name , $ strUrl . '#c' . $ dc -> id , $ strUrl . '?token=' . $ objNotify -> tokenRemove ) ; $ objEmail -> sendTo ( $ objNotify -> email ) ; } } $ this -> Database -> prepare ( "UPDATE tl_comments SET notifiedReply='1' WHERE id=?" ) -> execute ( $ dc -> id ) ; }
12531	public function getStatus ( $ applyId ) { $ params = [ 'apply_id' => intval ( $ applyId ) , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_DEVICE_APPLYSTATUS , $ params ] ) ; }
382	public function argumentsToString ( $ args ) { $ count = 0 ; $ isAssoc = $ args !== array_values ( $ args ) ; foreach ( $ args as $ key => $ value ) { $ count ++ ; if ( $ count >= 5 ) { if ( $ count > 5 ) { unset ( $ args [ $ key ] ) ; } else { $ args [ $ key ] = '...' ; } continue ; } if ( is_object ( $ value ) ) { $ args [ $ key ] = '<span class="title">' . $ this -> htmlEncode ( get_class ( $ value ) ) . '</span>' ; } elseif ( is_bool ( $ value ) ) { $ args [ $ key ] = '<span class="keyword">' . ( $ value ? 'true' : 'false' ) . '</span>' ; } elseif ( is_string ( $ value ) ) { $ fullValue = $ this -> htmlEncode ( $ value ) ; if ( mb_strlen ( $ value , 'UTF-8' ) > 32 ) { $ displayValue = $ this -> htmlEncode ( mb_substr ( $ value , 0 , 32 , 'UTF-8' ) ) . '...' ; $ args [ $ key ] = "<span class=\"string\" title=\"$fullValue\">'$displayValue'</span>" ; } else { $ args [ $ key ] = "<span class=\"string\">'$fullValue'</span>" ; } } elseif ( is_array ( $ value ) ) { $ args [ $ key ] = '[' . $ this -> argumentsToString ( $ value ) . ']' ; } elseif ( $ value === null ) { $ args [ $ key ] = '<span class="keyword">null</span>' ; } elseif ( is_resource ( $ value ) ) { $ args [ $ key ] = '<span class="keyword">resource</span>' ; } else { $ args [ $ key ] = '<span class="number">' . $ value . '</span>' ; } if ( is_string ( $ key ) ) { $ args [ $ key ] = '<span class="string">\'' . $ this -> htmlEncode ( $ key ) . "'</span> => $args[$key]" ; } elseif ( $ isAssoc ) { $ args [ $ key ] = "<span class=\"number\">$key</span> => $args[$key]" ; } } return implode ( ', ' , $ args ) ; }
7769	public function passes ( ) { foreach ( $ this -> after as $ after ) { call_user_func_array ( $ after , [ $ this ] ) ; } return empty ( $ this -> errors ) ; }
11145	protected function scanDir ( $ dir ) { $ result = array ( ) ; $ list = $ this -> scanDirExec ( $ dir ) ; foreach ( $ list as $ element ) { $ elementPath = $ dir . DIRECTORY_SEPARATOR . $ element ; if ( is_file ( $ elementPath ) ) { $ fileInfo = pathinfo ( $ element ) ; if ( in_array ( $ fileInfo [ 'extension' ] , $ this -> getAllowedFileExtensions ( ) ) ) { $ result [ ] = $ this -> getNameSpace ( ) . "\\" . $ fileInfo [ 'filename' ] ; } } } return $ result ; }
4436	public function get ( string $ name , $ default = null ) { $ res = $ this -> client -> call ( 'config.get' , $ name ) ; return $ res === null ? $ default : $ res ; }
5932	public function setEndDate ( $ endDate ) { if ( $ endDate instanceof DateTime ) { $ this -> endDate = $ endDate ; } else { try { $ this -> endDate = new DateTime ( $ endDate ) ; } catch ( \ Exception $ e ) { $ this -> endDate = null ; } } return $ this ; }
3430	protected function rememberInCache ( $ key , $ minutes , Closure $ callback ) { $ minutes = ( double ) $ minutes ; if ( $ minutes <= 0 ) { return $ callback ( ) ; } $ cache = Cache :: createInstance ( ) ; if ( $ cache -> initCache ( $ minutes * 60 , $ key , '/bitrix-models' ) ) { $ vars = $ cache -> getVars ( ) ; return ! empty ( $ vars [ 'isCollection' ] ) ? new Collection ( $ vars [ 'cache' ] ) : $ vars [ 'cache' ] ; } $ cache -> startDataCache ( ) ; $ result = $ callback ( ) ; $ isCollection = $ result instanceof Collection ; if ( $ isCollection ) { $ result = $ result -> all ( ) ; } $ cache -> endDataCache ( [ 'cache' => $ result , 'isCollection' => $ isCollection ] ) ; return $ isCollection ? new Collection ( $ result ) : $ result ; }
8388	public function addInnerJoin ( $ table , $ on ) { $ this -> innerJoins [ ] = array ( 'table' => $ table , 'on' => ( $ on instanceof Condition ? $ on : new Condition ( $ on ) ) ) ; return $ this ; }
8408	public static function set ( $ name , $ value , $ expire = 0 , $ path = null ) { if ( $ path === null ) { setcookie ( $ name , $ value , $ expire ) ; } else { setcookie ( $ name , $ value , $ expire , $ path ) ; } }
7993	public function getDiskUsage ( $ diskId , $ type ) { return json_decode ( self :: getClient ( ) -> getDiskUsage ( $ this -> getDomain ( ) , $ diskId , $ type ) ) ; }
9855	protected function storeBof ( $ type ) { $ record = 0x0809 ; $ length = 0x0010 ; $ unknown = pack ( 'VV' , 0x000100D1 , 0x00000406 ) ; $ build = 0x0DBB ; $ year = 0x07CC ; $ version = 0x0600 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vvvv' , $ version , $ type , $ build , $ year ) ; $ this -> append ( $ header . $ data . $ unknown ) ; }
6757	public function supportsDenormalization ( $ data , $ type , $ format = null ) { if ( ! \ class_exists ( $ type ) ) { return false ; } $ classAnnotation = $ this -> annotationReader -> getClassAnnotation ( new \ ReflectionClass ( $ type ) , NestedPropertyDenormalizerAnnotation :: class ) ; return $ classAnnotation instanceof NestedPropertyDenormalizerAnnotation ; }
1293	private function getTokenFromResponse ( array $ data ) : string { $ url = $ data [ 'nextSyncUrl' ] ?? $ data [ 'nextPageUrl' ] ; $ queryValues = [ ] ; \ parse_str ( \ parse_url ( $ url , \ PHP_URL_QUERY ) , $ queryValues ) ; return $ queryValues [ 'sync_token' ] ; }
1106	protected function writeMigration ( $ name ) { $ output = pathinfo ( $ this -> migrator -> create ( $ name , $ this -> getMigrationsPath ( ) ) , PATHINFO_FILENAME ) ; $ this -> line ( " <fg=green;options=bold>create</fg=green;options=bold> $output" ) ; }
9284	private function checkImports ( $ lessPath , $ cssPath , $ callback ) { static $ needsRecompile = false ; if ( $ needsRecompile ) return $ needsRecompile ; $ lessContent = file_get_contents ( $ lessPath ) ; preg_match_all ( '/(?<=@import)\s+"([^"]+)/im' , $ lessContent , $ imports ) ; foreach ( $ imports [ 1 ] as $ import ) { $ importPath = realpath ( dirname ( $ lessPath ) . DIRECTORY_SEPARATOR . $ import ) ; if ( file_exists ( $ importPath ) ) { if ( $ callback ( $ importPath , $ cssPath ) ) { $ needsRecompile = true ; break ; } else $ needsRecompile = $ this -> checkImports ( $ importPath , $ cssPath , $ callback ) ; } } return $ needsRecompile ; }
8684	public static function fromRecursive ( $ iterable ) { $ arr = static :: from ( $ iterable ) ; foreach ( $ arr as $ key => $ value ) { if ( $ value instanceof \ stdClass || \ is_iterable ( $ value ) ) { $ value = static :: fromRecursive ( $ value ) ; } $ arr [ $ key ] = $ value ; } return $ arr ; }
10663	public function setParamType ( $ type ) { if ( ! is_string ( $ type ) || ! in_array ( $ type , [ self :: PARAM_MULTIPART , self :: PARAM_FORM ] ) ) { throw new InvalidArgumentException ( sprintf ( "Invalid parameter form type, form type only allowed $1s and $2s" , self :: PARAM_FORM , self :: PARAM_MULTIPART ) , E_USER_ERROR ) ; } $ this -> currentParamType = $ type ; $ reverse_params = $ type == self :: PARAM_FORM ? self :: PARAM_MULTIPART : self :: PARAM_FORM ; $ reverse_params_value = isset ( $ this -> configs [ $ reverse_params ] ) ? $ this -> configs [ $ reverse_params ] : null ; $ params_value = isset ( $ this -> configs [ $ type ] ) ? $ this -> configs [ $ type ] : null ; unset ( $ this -> configs [ self :: PARAM_FORM ] , $ this -> configs [ self :: PARAM_MULTIPART ] ) ; $ this -> configs [ $ type ] = is_array ( $ reverse_params_value ) ? $ reverse_params_value : ( is_array ( $ params_value ) ? $ params_value : [ ] ) ; return $ this -> buildConfigClient ( ) ; }
4363	public static function toUtf8 ( $ str ) { if ( \ extension_loaded ( 'mbstring' ) && \ function_exists ( 'iconv' ) ) { $ encoding = \ mb_detect_encoding ( $ str , \ mb_detect_order ( ) , true ) ; if ( ! $ encoding ) { $ str_conv = false ; if ( \ function_exists ( 'iconv' ) ) { $ str_conv = \ iconv ( 'cp1252' , 'UTF-8' , $ str ) ; } if ( $ str_conv === false ) { $ str_conv = \ htmlentities ( $ str , ENT_COMPAT ) ; $ str_conv = \ html_entity_decode ( $ str_conv , ENT_COMPAT , 'UTF-8' ) ; } $ str = $ str_conv ; } elseif ( ! \ in_array ( $ encoding , array ( 'ASCII' , 'UTF-8' ) ) ) { $ str_new = \ iconv ( $ encoding , 'UTF-8' , $ str ) ; if ( $ str_new !== false ) { $ str = $ str_new ; } } } return $ str ; }
10095	protected function processDefault ( $ url ) { if ( $ url === null ) { return $ url ; } $ url = ( string ) $ url ; switch ( $ url ) { case '404' : case 'mm' : case 'identicon' : case 'monsterid' : case 'wavatar' : case 'retro' : break ; default : $ valid = filter_var ( $ url , FILTER_VALIDATE_URL ) ; if ( ! $ valid ) { throw new InvalidArgumentException ( 'Invalid default avatar URL' ) ; } break ; } return $ url ; }
9792	public function setDataType ( $ pDataType ) { if ( $ pDataType == DataType :: TYPE_STRING2 ) { $ pDataType = DataType :: TYPE_STRING ; } $ this -> dataType = $ pDataType ; return $ this -> updateInCollection ( ) ; }
4808	public function unschedule_specific_event ( $ timestamp = '' ) { if ( empty ( $ timestamp ) ) { $ timestamp = wp_next_scheduled ( $ this -> args [ 'name' ] , $ this -> args [ 'args' ] ) ; } wp_unschedule_event ( $ timestamp , $ this -> args [ 'name' ] , $ this -> args [ 'args' ] ) ; }
2505	public static function loadWsdlXpath ( $ wsdlFilePath , $ wsdlId ) { if ( ! isset ( self :: $ wsdlDomXpath [ $ wsdlId ] ) || is_null ( self :: $ wsdlDomXpath [ $ wsdlId ] ) ) { $ wsdlContent = file_get_contents ( $ wsdlFilePath ) ; if ( $ wsdlContent !== false ) { self :: $ wsdlDomDoc [ $ wsdlId ] = new \ DOMDocument ( '1.0' , 'UTF-8' ) ; self :: $ wsdlDomDoc [ $ wsdlId ] -> loadXML ( $ wsdlContent ) ; self :: $ wsdlDomXpath [ $ wsdlId ] = new \ DOMXPath ( self :: $ wsdlDomDoc [ $ wsdlId ] ) ; self :: $ wsdlDomXpath [ $ wsdlId ] -> registerNamespace ( 'wsdl' , 'http://schemas.xmlsoap.org/wsdl/' ) ; self :: $ wsdlDomXpath [ $ wsdlId ] -> registerNamespace ( 'soap' , 'http://schemas.xmlsoap.org/wsdl/soap/' ) ; } else { throw new InvalidWsdlFileException ( 'WSDL ' . $ wsdlFilePath . ' could not be loaded' ) ; } } }
4772	public function configs ( Request $ request , WidgetInterface $ widget , CacheInterface $ cache , string $ widgetId ) { $ widgets = $ widget -> getWidgets ( ) ; if ( isset ( $ widgets [ $ widgetId ] ) ) { $ widgetConfig = $ this -> getDoctrine ( ) -> getRepository ( 'PdWidgetBundle:WidgetUser' ) -> findOneBy ( [ 'owner' => $ this -> getUser ( ) ] ) ?? ( new WidgetUser ( ) ) -> setOwner ( $ this -> getUser ( ) ) ; if ( $ request -> get ( 'remove' ) ) { $ widgetConfig -> removeWidgetConfig ( $ widgetId , $ widgets [ $ widgetId ] -> getConfigProcess ( $ request ) ?? [ ] ) ; } else { $ widgetConfig -> addWidgetConfig ( $ widgetId , $ widgets [ $ widgetId ] -> getConfigProcess ( $ request ) ?? [ ] ) ; } $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ em -> persist ( $ widgetConfig ) ; $ em -> flush ( ) ; $ cache -> delete ( $ widgetId . $ this -> getUser ( ) -> getId ( ) ) ; } return $ this -> redirect ( $ request -> headers -> get ( 'referer' ) ?? $ this -> generateUrl ( $ this -> getParameter ( 'pd_widget.return_route' ) ) ) ; }
5321	public function remove ( ) { if ( is_resource ( $ this -> mutex ) ) { sem_remove ( $ this -> mutex ) ; } if ( file_exists ( $ this -> file ) ) { unlink ( $ this -> file ) ; } }
874	public function getAnnotationsOfType ( $ types ) { $ annotations = [ ] ; $ types = ( array ) $ types ; foreach ( $ this -> getAnnotations ( ) as $ annotation ) { $ tag = $ annotation -> getTag ( ) -> getName ( ) ; foreach ( $ types as $ type ) { if ( $ type === $ tag ) { $ annotations [ ] = $ annotation ; } } } return $ annotations ; }
8207	protected function putJob ( $ tube , $ body , $ priority , $ delay , $ ttr ) { $ id = $ this -> getPheanstalk ( ) -> putInTube ( $ tube , $ body , $ priority , $ delay , $ ttr ) ; return $ id ; }
803	private function hasVoidReturnAnnotation ( Tokens $ tokens , $ index ) { foreach ( $ this -> findReturnAnnotations ( $ tokens , $ index ) as $ return ) { if ( [ 'void' ] === $ return -> getTypes ( ) ) { return true ; } } return false ; }
11529	public function replaceVariables ( $ string , $ replaces = [ ] ) { $ callback = function ( $ match ) use ( $ replaces ) { $ variable = trim ( $ match [ 0 ] , '{}' ) ; if ( array_key_exists ( $ variable , $ replaces ) ) { return $ replaces [ $ variable ] ; } return $ variable ; } ; return preg_replace_callback ( '/{.*?}/' , $ callback , $ string ) ; }
7114	static public function isBetterMode ( $ modeA , $ modeB ) { if ( $ modeA === static :: MODE_DISABLED ) { return $ modeB !== static :: MODE_DISABLED ; } elseif ( $ modeA === static :: MODE_JUST_IN_TIME ) { return in_array ( $ modeB , [ static :: MODE_MANUAL , static :: MODE_AUTO ] , true ) ; } return false ; }
4371	public function markupClassname ( $ str , $ tagName = 'span' , $ attribs = array ( ) ) { if ( \ preg_match ( '/^(.+)(::|->)(.+)$/' , $ str , $ matches ) ) { $ classname = $ matches [ 1 ] ; $ opMethod = '<span class="t_operator">' . \ htmlspecialchars ( $ matches [ 2 ] ) . '</span>' . '<span class="method-name">' . $ matches [ 3 ] . '</span>' ; } else { $ classname = $ str ; $ opMethod = '' ; } $ idx = \ strrpos ( $ classname , '\\' ) ; if ( $ idx ) { $ classname = '<span class="namespace">' . \ substr ( $ classname , 0 , $ idx + 1 ) . '</span>' . \ substr ( $ classname , $ idx + 1 ) ; } $ attribs = \ array_merge ( array ( 'class' => 't_classname' , ) , $ attribs ) ; return $ this -> debug -> utilities -> buildTag ( $ tagName , $ attribs , $ classname ) . $ opMethod ; }
8492	public static function getTotalMemory ( ) { $ wmi = Windows :: getInstance ( ) ; foreach ( $ wmi -> ExecQuery ( "SELECT TotalPhysicalMemory FROM Win32_ComputerSystem" ) as $ mem ) { return $ mem -> TotalPhysicalMemory ; } return NULL ; }
8594	public function listOrdersByNextToken ( $ request ) { if ( ! ( $ request instanceof MarketplaceWebServiceOrders_Model_ListOrdersByNextTokenRequest ) ) { $ request = new MarketplaceWebServiceOrders_Model_ListOrdersByNextTokenRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListOrdersByNextToken' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = MarketplaceWebServiceOrders_Model_ListOrdersByNextTokenResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
4351	private function setDebugCfg ( $ cfg ) { if ( isset ( $ cfg [ 'key' ] ) ) { $ cfg = \ array_merge ( $ cfg , $ this -> debugKeyValues ( $ cfg [ 'key' ] ) ) ; } if ( isset ( $ cfg [ 'logEnvInfo' ] ) && \ is_bool ( $ cfg [ 'logEnvInfo' ] ) ) { $ keys = \ array_keys ( $ this -> cfg [ 'logEnvInfo' ] ) ; $ cfg [ 'logEnvInfo' ] = \ array_fill_keys ( $ keys , $ cfg [ 'logEnvInfo' ] ) ; } if ( isset ( $ cfg [ 'logServerKeys' ] ) ) { $ this -> cfg [ 'logServerKeys' ] = array ( ) ; } $ this -> cfg = $ this -> debug -> utilities -> arrayMergeDeep ( $ this -> cfg , $ cfg ) ; }
925	public function getExceptionErrors ( ) { return array_filter ( $ this -> errors , static function ( Error $ error ) { return Error :: TYPE_EXCEPTION === $ error -> getType ( ) ; } ) ; }
1837	public static function findOneBy ( $ strColumn , $ varValue , array $ arrOptions = array ( ) ) { $ arrOptions = array_merge ( array ( 'limit' => 1 , 'column' => $ strColumn , 'value' => $ varValue , 'return' => 'Model' ) , $ arrOptions ) ; return static :: find ( $ arrOptions ) ; }
11408	public function onBootstrap ( MvcEvent $ e ) { if ( ! $ e -> getRequest ( ) instanceof HttpRequest ) { return ; } $ app = $ e -> getApplication ( ) ; $ services = $ app -> getServiceManager ( ) ; $ eventManager = $ app -> getEventManager ( ) ; $ sharedEventManager = $ eventManager -> getSharedManager ( ) ; $ sharedEventManager -> attach ( UserService :: class , 'register' , function ( $ e ) use ( $ services ) { $ user = $ e -> getParam ( 'user' ) ; if ( $ user instanceof RoleableInterface && $ services -> has ( AuthorizationModuleOptions :: class ) ) { $ config = $ services -> get ( PermissionsModuleOptions :: class ) ; $ roleClass = $ config -> getRoleEntityClass ( ) ; $ mapper = $ services -> get ( 'MapperManager' ) -> get ( $ roleClass ) ; if ( $ defaultRole = $ mapper -> find ( $ config -> getAuthenticatedRole ( ) ) ) { $ user -> addRole ( $ defaultRole ) ; } } } , 100 ) ; }
2190	public function isRegistered ( Model $ objModel ) { $ intObjectId = spl_object_hash ( $ objModel ) ; return isset ( $ this -> arrIdentities [ $ intObjectId ] ) ; }
6355	public function setTimestamp ( $ ts = false ) { $ m = [ ] ; $ da = [ ] ; $ strtime = '' ; if ( ! $ ts || $ ts === "\0\0\0\0\0\0\0\0\0\0\0\0\0\0" ) { $ uts = self :: time ( ) ; $ strtime = "@$uts" ; } elseif ( preg_match ( '/^(\d{4})\-(\d\d)\-(\d\d) (\d\d):(\d\d):(\d\d)$/D' , $ ts , $ da ) ) { } elseif ( preg_match ( '/^(\d{4}):(\d\d):(\d\d) (\d\d):(\d\d):(\d\d)$/D' , $ ts , $ da ) ) { } elseif ( preg_match ( '/^(\d{4})(\d\d)(\d\d)(\d\d)(\d\d)(\d\d)$/D' , $ ts , $ da ) ) { } elseif ( preg_match ( '/^(-?\d{1,13})$/D' , $ ts , $ m ) ) { $ strtime = "@{$m[1]}" ; } elseif ( preg_match ( '/^(-?\d{1,13})(\.\d+)$/D' , $ ts , $ m ) ) { $ strtime = 'unixmicro' ; } elseif ( preg_match ( '/^\d{2}-\d{2}-\d{4} \d{2}:\d{2}:\d{2}.\d{6}$/' , $ ts ) ) { $ strtime = preg_replace ( '/(\d\d)\.(\d\d)\.(\d\d)(\.(\d+))?/' , "$1:$2:$3" , str_replace ( '+00:00' , 'UTC' , $ ts ) ) ; } elseif ( preg_match ( '/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})(?:\.*\d*)?Z?$/' , $ ts , $ da ) ) { } elseif ( preg_match ( '/^(\d{4})(\d{2})(\d{2})T(\d{2})(\d{2})(\d{2})(?:\.*\d*)?Z?$/' , $ ts , $ da ) ) { } elseif ( preg_match ( '/^(\d{4})\-(\d\d)\-(\d\d) (\d\d):(\d\d):(\d\d)\.*\d*[\+\- ](\d\d)$/' , $ ts , $ da ) ) { } elseif ( preg_match ( '/^(\d{4})\-(\d\d)\-(\d\d) (\d\d):(\d\d):(\d\d)\.*\d* GMT$/' , $ ts , $ da ) ) { } elseif ( preg_match ( '/^[ \t\r\n]*([A-Z][a-z]{2},[ \t\r\n]*)?' . '\d\d?[ \t\r\n]*[A-Z][a-z]{2}[ \t\r\n]*\d{2}(?:\d{2})?' . '[ \t\r\n]*\d\d[ \t\r\n]*:[ \t\r\n]*\d\d[ \t\r\n]*:[ \t\r\n]*\d\d/S' , $ ts ) ) { $ strtime = strtok ( $ ts , ';' ) ; } elseif ( preg_match ( '/^[A-Z][a-z]{5,8}, \d\d-[A-Z][a-z]{2}-\d{2} \d\d:\d\d:\d\d/' , $ ts ) ) { $ strtime = $ ts ; } elseif ( preg_match ( '/^[A-Z][a-z]{2} [A-Z][a-z]{2} +\d{1,2} \d\d:\d\d:\d\d \d{4}/' , $ ts ) ) { $ strtime = $ ts ; } else { throw new TimestampException ( __METHOD__ . ": Invalid timestamp - $ts" ) ; } if ( ! $ strtime ) { $ da = array_map ( 'intval' , $ da ) ; $ da [ 0 ] = "%04d-%02d-%02dT%02d:%02d:%02d.00+00:00" ; $ strtime = call_user_func_array ( "sprintf" , $ da ) ; } try { if ( $ strtime === 'unixmicro' ) { $ final = DateTime :: createFromFormat ( 'U.u' , $ ts , new DateTimeZone ( 'GMT' ) ) ; } else { $ final = new DateTime ( $ strtime , new DateTimeZone ( 'GMT' ) ) ; } } catch ( Exception $ e ) { throw new TimestampException ( __METHOD__ . ': Invalid timestamp format.' , $ e -> getCode ( ) , $ e ) ; } if ( $ final === false ) { throw new TimestampException ( __METHOD__ . ': Invalid timestamp format.' ) ; } $ this -> timestamp = $ final ; }
11481	public function save ( BlockManagerApprover $ approver , array $ options , $ saveCommonSlots = true ) { $ this -> contributorDefined ( ) ; $ filesystem = new Filesystem ( ) ; $ pageDir = $ this -> pagesDir . '/' . $ options [ "page" ] ; $ filesystem -> copy ( $ pageDir . '/' . $ this -> pageFile , $ pageDir . '/page.json' , true ) ; $ pageDir .= '/' . $ options [ "language" ] . '_' . $ options [ "country" ] ; if ( $ this -> seoFile != "seo.json" ) { $ sourceFile = $ pageDir . '/' . $ this -> seoFile ; $ values = json_decode ( file_get_contents ( $ sourceFile ) , true ) ; if ( array_key_exists ( "current_permalink" , $ values ) ) { $ values [ "changed_permalinks" ] [ ] = $ values [ "current_permalink" ] ; unset ( $ values [ "current_permalink" ] ) ; file_put_contents ( $ sourceFile , json_encode ( $ values ) ) ; } $ filesystem -> copy ( $ sourceFile , $ pageDir . '/seo.json' , true ) ; } $ approvedBlocks = $ this -> saveBlocks ( $ approver , $ pageDir , $ options ) ; if ( $ saveCommonSlots ) { $ slotsDir = $ this -> baseDir . '/slots' ; $ approvedCommonBlocks = $ this -> saveBlocks ( $ approver , $ slotsDir , $ options ) ; $ approvedBlocks = array_merge ( $ approvedBlocks , $ approvedCommonBlocks ) ; } Dispatcher :: dispatch ( PageEvents :: PAGE_SAVED , new PageSavedEvent ( $ pageDir , null , $ approvedBlocks ) ) ; DataLogger :: log ( sprintf ( 'Page "%s" was successfully saved in production' , $ options [ "page" ] ) ) ; }
4675	public function addString ( $ content , $ region = "main" , $ sort = 0 ) { $ view = new View ( ) ; $ view -> set ( $ content , [ ] , $ sort , "string" ) ; $ this -> views [ $ region ] [ ] = $ view ; return $ this ; }
378	protected function renderException ( $ exception ) { if ( Yii :: $ app -> has ( 'response' ) ) { $ response = Yii :: $ app -> getResponse ( ) ; $ response -> isSent = false ; $ response -> stream = null ; $ response -> data = null ; $ response -> content = null ; } else { $ response = new Response ( ) ; } $ response -> setStatusCodeByException ( $ exception ) ; $ useErrorView = $ response -> format === Response :: FORMAT_HTML && ( ! YII_DEBUG || $ exception instanceof UserException ) ; if ( $ useErrorView && $ this -> errorAction !== null ) { $ result = Yii :: $ app -> runAction ( $ this -> errorAction ) ; if ( $ result instanceof Response ) { $ response = $ result ; } else { $ response -> data = $ result ; } } elseif ( $ response -> format === Response :: FORMAT_HTML ) { if ( $ this -> shouldRenderSimpleHtml ( ) ) { $ response -> data = '<pre>' . $ this -> htmlEncode ( static :: convertExceptionToString ( $ exception ) ) . '</pre>' ; } else { if ( YII_DEBUG ) { ini_set ( 'display_errors' , 1 ) ; } $ file = $ useErrorView ? $ this -> errorView : $ this -> exceptionView ; $ response -> data = $ this -> renderFile ( $ file , [ 'exception' => $ exception , ] ) ; } } elseif ( $ response -> format === Response :: FORMAT_RAW ) { $ response -> data = static :: convertExceptionToString ( $ exception ) ; } else { $ response -> data = $ this -> convertExceptionToArray ( $ exception ) ; } $ response -> send ( ) ; }
2765	public function isUpToDate ( ) : bool { if ( ! $ this -> isTracking ( ) ) { throw new GitException ( 'Error: HEAD does not have a remote tracking branch. Cannot check if it is up-to-date.' ) ; } $ mergeBase = $ this -> run ( 'merge-base' , [ '@' , '@{u}' ] ) ; $ remoteSha = $ this -> run ( 'rev-parse' , [ '@{u}' ] ) ; return $ mergeBase === $ remoteSha ; }
8981	private static function matchesDateCriteria ( $ key , RateInterface $ rate , array $ criteria ) { $ date = self :: extractDateCriteria ( $ key , $ criteria ) ; if ( $ date === null ) { return true ; } if ( $ key === 'dateFrom' ) { $ rateDate = new \ DateTime ( $ rate -> getDate ( ) -> format ( \ DateTime :: ATOM ) ) ; $ rateDate -> setTime ( 23 , 59 , 59 ) ; return $ date <= $ rateDate ; } if ( $ key === 'dateTo' ) { $ rateDate = new \ DateTime ( $ rate -> getDate ( ) -> format ( \ DateTime :: ATOM ) ) ; $ rateDate -> setTime ( 0 , 0 , 0 ) ; return $ date >= $ rateDate ; } return $ date -> format ( 'Y-m-d' ) === $ rate -> getDate ( ) -> format ( 'Y-m-d' ) ; }
1085	private function parseName ( ) { $ token = $ this -> expect ( Token :: NAME ) ; return new NameNode ( [ 'value' => $ token -> value , 'loc' => $ this -> loc ( $ token ) , ] ) ; }
11090	public static function getGreeting ( $ time = null ) { if ( $ time === null ) { $ time = time ( ) ; } elseif ( \ is_string ( $ time ) ) { $ time = strtotime ( $ time ) ; } switch ( date ( 'G' , $ time ) ) { case 0 : case 1 : case 2 : case 3 : case 4 : case 5 : case 6 : case 7 : return self :: poorManTranslate ( 'fts-shared' , 'Good morning' ) ; case 8 : case 9 : case 10 : case 11 : return trim ( self :: poorManTranslate ( 'fts-shared' , '_Good morning' ) , '_' ) ; case 12 : return self :: poorManTranslate ( 'fts-shared' , 'Good noon' ) ; case 13 : case 14 : case 15 : case 16 : return self :: poorManTranslate ( 'fts-shared' , 'Good afternoon' ) ; case 17 : case 18 : case 19 : return trim ( self :: poorManTranslate ( 'fts-shared' , '_Good afternoon' ) , '_' ) ; case 20 : case 21 : case 22 : case 23 : return self :: poorManTranslate ( 'fts-shared' , 'Good evening' ) ; default : return '' ; } }
8673	private function iterateReverseFromIndex ( $ fromIndex ) { Assert :: nullOrInteger ( $ fromIndex ) ; $ index = count ( $ this -> items ) ; if ( $ index === 0 ) { return ; } if ( $ fromIndex !== null ) { $ index = $ fromIndex < 0 ? max ( $ index + $ fromIndex , 1 ) : min ( $ fromIndex + 1 , $ index ) ; } $ keys = array_keys ( $ this -> items ) ; while ( -- $ index >= 0 ) { $ key = $ keys [ $ index ] ; yield $ key => $ this -> items [ $ key ] ; } }
269	public function formatMessage ( $ message ) { list ( $ text , $ level , $ category , $ timestamp ) = $ message ; $ level = Logger :: getLevelName ( $ level ) ; if ( ! is_string ( $ text ) ) { if ( $ text instanceof \ Throwable || $ text instanceof \ Exception ) { $ text = ( string ) $ text ; } else { $ text = VarDumper :: export ( $ text ) ; } } $ traces = [ ] ; if ( isset ( $ message [ 4 ] ) ) { foreach ( $ message [ 4 ] as $ trace ) { $ traces [ ] = "in {$trace['file']}:{$trace['line']}" ; } } $ prefix = $ this -> getMessagePrefix ( $ message ) ; return $ this -> getTime ( $ timestamp ) . " {$prefix}[$level][$category] $text" . ( empty ( $ traces ) ? '' : "\n " . implode ( "\n " , $ traces ) ) ; }
10449	public function load ( $ config ) { if ( is_string ( $ config ) and file_exists ( $ config ) ) { $ config = include $ config ; } if ( ! is_array ( $ config ) ) { $ msg = 'Failed to load configuration data' ; throw new ConfigurationException ( $ msg ) ; } return new Configuration ( $ config ) ; }
12838	static public function dir ( $ directory , $ date = false ) { if ( $ date ) { $ directory = rtrim ( $ directory , DIRECTORY_SEPARATOR ) . DIRECTORY_SEPARATOR . self :: getDateDirectory ( ) ; } if ( ! is_dir ( $ directory ) ) { $ umask = umask ( 0000 ) ; if ( @ mkdir ( $ directory , 0777 , true ) === false ) { throw new Exception ( sprintf ( 'Directory "%s" cannot be created.' , $ directory ) ) ; } umask ( $ umask ) ; } return $ directory ; }
1583	public function getRelations ( ) : Collection { return $ this -> getRelationships ( ) -> filter ( function ( array $ relation ) { return array_key_exists ( 'data' , $ relation ) ; } ) -> map ( function ( array $ relation ) { return $ relation [ 'data' ] ; } ) ; }
9445	public function getEntityMappings ( Container $ app ) { static $ mappings = [ ] ; $ me = get_class ( $ this ) ; if ( empty ( $ mappings [ $ me ] ) ) { $ subns = $ this -> packOptions [ 'entity_subnamespace' ] ; $ subns = trim ( $ subns , '\\' ) ; $ simple = $ this -> packOptions [ 'entity_use_simple_annotation' ] ; $ ns = $ this -> getReflector ( ) -> getNamespaceName ( ) . '\\' . $ subns ; $ subpath = str_replace ( '\\' , '/' , $ subns ) ; $ path = dirname ( $ this -> getReflector ( ) -> getFileName ( ) ) . '/' . $ subpath ; if ( is_dir ( $ path ) ) { $ mappings [ $ me ] = [ 'type' => 'annotation' , 'namespace' => $ ns , 'path' => $ path , 'use_simple_annotation_reader' => $ simple , ] ; } } if ( empty ( $ mappings [ $ me ] ) ) { return [ ] ; } return [ $ mappings [ $ me ] ] ; }
1433	public static function dasherize ( $ value ) { if ( isset ( self :: $ dasherized [ $ value ] ) ) { return self :: $ dasherized [ $ value ] ; } return self :: $ dasherized [ $ value ] = str_replace ( '_' , '-' , self :: decamelize ( $ value ) ) ; }
11716	public static function entry ( $ argv ) : void { self :: initialize ( ) ; if ( isset ( $ argv [ 1 ] ) ) { $ command = $ argv [ 1 ] ; } else { return ; } if ( ! in_array ( $ command , array_keys ( self :: $ commands ) ) ) { return ; } $ arguments = [ ] ; $ options = [ ] ; for ( $ index = 2 ; $ index < count ( $ argv ) ; $ index ++ ) { list ( $ key , $ value ) = Service :: parse ( $ argv [ $ index ] ) ; if ( Service :: determineTypeOfWord ( $ argv [ $ index ] ) == Service :: OPTION_TYPE ) { if ( ! $ value ) { $ options [ $ key ] = true ; } else { $ options [ $ key ] = $ value ; } } else { $ arguments [ ] = $ key ; } } Service :: runCommand ( self :: $ commands [ $ command ] , $ arguments , $ options ) ; }
6807	public function createFromContext ( ContextInterface $ context ) { return $ this -> create ( $ context -> getLocale ( ) , $ context -> getCurrency ( ) -> getCode ( ) ) ; }
6121	public function permissionGetIdByName ( $ name ) { if ( ! array_key_exists ( ( string ) $ name , $ this -> permissionList ( ) ) ) { throw new Ts3Exception ( "invalid permission ID" , 0xA02 ) ; } return $ this -> permissionList [ ( string ) $ name ] [ "permid" ] ; }
4588	public function setMaxResults ( ? int $ maxResults ) { $ this -> maxResults = $ maxResults ; $ this -> _maxResults = null !== $ maxResults ; return $ this ; }
12617	public function removeAttribute ( string $ attributeName ) { if ( isset ( $ this -> attributes [ $ attributeName ] ) ) unset ( $ this -> attributes [ $ attributeName ] ) ; }
9731	public function canRead ( $ pFilename ) { try { $ this -> openFile ( $ pFilename ) ; } catch ( Exception $ e ) { return false ; } $ data = fread ( $ this -> fileHandle , 2048 ) ; $ delimiterCount = substr_count ( $ data , ';' ) ; $ hasDelimiter = $ delimiterCount > 0 ; $ lines = explode ( "\n" , $ data ) ; $ hasId = substr ( $ lines [ 0 ] , 0 , 4 ) === 'ID;P' ; fclose ( $ this -> fileHandle ) ; return $ hasDelimiter && $ hasId ; }
3616	public function setFanMode ( $ mode , $ serial_number = NULL ) { $ duty_cycle = NULL ; $ timer = NULL ; if ( is_array ( $ mode ) ) { $ modes = $ mode ; $ mode = $ modes [ 0 ] ; if ( count ( $ modes ) > 1 ) { if ( $ mode == FAN_MODE_MINUTES_PER_HOUR ) { $ duty_cycle = ( int ) $ modes [ 1 ] ; } else { $ timer = ( int ) $ modes [ 1 ] ; } } else { throw new Exception ( "setFanMode(array \$mode[, ...]) needs at least a mode and a value in the \$mode array." ) ; } } elseif ( ! is_string ( $ mode ) ) { throw new Exception ( "setFanMode() can only take a string or an array as it's first parameter." ) ; } return $ this -> _setFanMode ( $ mode , $ duty_cycle , $ timer , $ serial_number ) ; }
474	public function update ( $ table , $ columns , $ condition = '' , $ params = [ ] ) { $ time = $ this -> beginCommand ( "update $table" ) ; $ this -> db -> createCommand ( ) -> update ( $ table , $ columns , $ condition , $ params ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
8340	public static function set ( string $ fileName , array $ content ) { try { $ json = Yaml :: dump ( $ content , 2 ) ; if ( file_put_contents ( $ fileName , $ json ) === false ) { throw new FileNotWritable ( 'can\'t write to "' . $ fileName . '"' ) ; } } catch ( DumpException $ e ) { throw new BadUse ( 'Config::set() content parameter can\'t be dump to YAML' ) ; } self :: $ files [ $ fileName ] = $ content ; }
10097	private function writeBIFF8CellRangeAddressFixed ( $ range ) { $ explodes = explode ( ':' , $ range ) ; $ firstCell = $ explodes [ 0 ] ; if ( count ( $ explodes ) == 1 ) { $ lastCell = $ firstCell ; } else { $ lastCell = $ explodes [ 1 ] ; } $ firstCellCoordinates = Coordinate :: coordinateFromString ( $ firstCell ) ; $ lastCellCoordinates = Coordinate :: coordinateFromString ( $ lastCell ) ; return pack ( 'vvvv' , $ firstCellCoordinates [ 1 ] - 1 , $ lastCellCoordinates [ 1 ] - 1 , Coordinate :: columnIndexFromString ( $ firstCellCoordinates [ 0 ] ) - 1 , Coordinate :: columnIndexFromString ( $ lastCellCoordinates [ 0 ] ) - 1 ) ; }
9991	private function writeChartInCell ( Worksheet $ pSheet , $ coordinates ) { $ html = '' ; foreach ( $ pSheet -> getChartCollection ( ) as $ chart ) { if ( $ chart instanceof Chart ) { $ chartCoordinates = $ chart -> getTopLeftPosition ( ) ; if ( $ chartCoordinates [ 'cell' ] == $ coordinates ) { $ chartFileName = File :: sysGetTempDir ( ) . '/' . uniqid ( '' , true ) . '.png' ; if ( ! $ chart -> render ( $ chartFileName ) ) { return ; } $ html .= PHP_EOL ; $ imageDetails = getimagesize ( $ chartFileName ) ; if ( $ fp = fopen ( $ chartFileName , 'rb' , 0 ) ) { $ picture = fread ( $ fp , filesize ( $ chartFileName ) ) ; fclose ( $ fp ) ; $ base64 = chunk_split ( base64_encode ( $ picture ) ) ; $ imageData = 'data:' . $ imageDetails [ 'mime' ] . ';base64,' . $ base64 ; $ html .= '<div style="position: relative;">' ; $ html .= '<img style="position: absolute; z-index: 1; left: ' . $ chartCoordinates [ 'xOffset' ] . 'px; top: ' . $ chartCoordinates [ 'yOffset' ] . 'px; width: ' . $ imageDetails [ 0 ] . 'px; height: ' . $ imageDetails [ 1 ] . 'px;" src="' . $ imageData . '" border="0" />' . PHP_EOL ; $ html .= '</div>' ; unlink ( $ chartFileName ) ; } } } } return $ html ; }
4524	protected function createZoneFromDefinition ( array $ definition ) { $ zone = new Zone ( ) ; $ setValues = \ Closure :: bind ( function ( $ definition ) { $ this -> id = $ definition [ 'id' ] ; $ this -> name = $ definition [ 'name' ] ; if ( isset ( $ definition [ 'scope' ] ) ) { $ this -> scope = $ definition [ 'scope' ] ; } if ( isset ( $ definition [ 'priority' ] ) ) { $ this -> priority = $ definition [ 'priority' ] ; } } , $ zone , '\CommerceGuys\Zone\Model\Zone' ) ; $ setValues ( $ definition ) ; foreach ( $ definition [ 'members' ] as $ memberDefinition ) { if ( $ memberDefinition [ 'type' ] == 'country' ) { $ zoneMember = $ this -> createZoneMemberCountryFromDefinition ( $ memberDefinition ) ; $ zone -> addMember ( $ zoneMember ) ; } elseif ( $ memberDefinition [ 'type' ] == 'zone' ) { $ zoneMember = $ this -> createZoneMemberZoneFromDefinition ( $ memberDefinition ) ; $ zone -> addMember ( $ zoneMember ) ; } } return $ zone ; }
860	public function clearRange ( $ indexStart , $ indexEnd ) { for ( $ i = $ indexStart ; $ i <= $ indexEnd ; ++ $ i ) { $ this -> clearAt ( $ i ) ; } }
3067	public function process ( ) { $ this -> validate ( ) ; $ ref = ( $ this -> getRequestParameter ( 'ref' ) === false ) ? null : $ this -> getRequestParameter ( 'ref' ) ; $ direction = $ this -> getRequestParameter ( 'direction' ) ; $ scope = $ this -> getRequestParameter ( 'scope' ) ; $ start = ( $ this -> getRequestParameter ( 'start' ) !== false ) ; try { $ serviceContext = $ this -> getServiceContext ( ) ; $ this -> saveToolStates ( ) ; if ( ! $ this -> getRunnerService ( ) -> isTerminated ( $ serviceContext ) ) { $ this -> endItemTimer ( $ this -> getTime ( ) ) ; $ this -> saveItemState ( ) ; } $ this -> initServiceContext ( ) ; $ this -> saveItemResponses ( false ) ; if ( $ this -> getRequestParameter ( 'offline' ) === true ) { $ this -> setOffline ( ) ; } $ serviceContext -> getTestSession ( ) -> initItemTimer ( $ this -> getTime ( ) ) ; $ result = $ this -> getRunnerService ( ) -> move ( $ serviceContext , $ direction , $ scope , $ ref ) ; $ response = [ 'success' => $ result , ] ; if ( $ result ) { $ response [ 'testContext' ] = $ this -> getRunnerService ( ) -> getTestContext ( $ serviceContext ) ; if ( $ serviceContext -> containsAdaptive ( ) ) { $ response [ 'testMap' ] = $ this -> getRunnerService ( ) -> getTestMap ( $ serviceContext , true ) ; } } common_Logger :: d ( 'Test session state : ' . $ serviceContext -> getTestSession ( ) -> getState ( ) ) ; if ( $ start === true ) { $ this -> getRunnerService ( ) -> startTimer ( $ serviceContext , $ this -> getTime ( ) ) ; } } catch ( Exception $ e ) { common_Logger :: e ( $ e -> getMessage ( ) ) ; $ response = $ this -> getErrorResponse ( $ e ) ; } return $ response ; }
8180	public function setDefaultStrategy ( $ defaultStrategy ) { if ( true === $ defaultStrategy ) { @ trigger_error ( 'Using "true" as the default strategy is deprecated since version 1.21. Use "html" instead.' , E_USER_DEPRECATED ) ; $ defaultStrategy = 'html' ; } if ( 'filename' === $ defaultStrategy ) { @ trigger_error ( 'Using "filename" as the default strategy is deprecated since version 1.27. Use "name" instead.' , E_USER_DEPRECATED ) ; $ defaultStrategy = 'name' ; } if ( 'name' === $ defaultStrategy ) { $ defaultStrategy = array ( 'Twig_FileExtensionEscapingStrategy' , 'guess' ) ; } $ this -> defaultStrategy = $ defaultStrategy ; }
3166	public function getCurrentAssessmentSession ( RunnerServiceContext $ context ) { if ( $ context -> isAdaptive ( ) ) { return new AssessmentItemSession ( $ context -> getCurrentAssessmentItemRef ( ) , new SessionManager ( ) ) ; } else { return $ context -> getTestSession ( ) ; } }
9979	public function writeComments ( \ PhpOffice \ PhpSpreadsheet \ Worksheet \ Worksheet $ pWorksheet ) { $ objWriter = null ; if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' , 'yes' ) ; $ comments = $ pWorksheet -> getComments ( ) ; $ authors = [ ] ; $ authorId = 0 ; foreach ( $ comments as $ comment ) { if ( ! isset ( $ authors [ $ comment -> getAuthor ( ) ] ) ) { $ authors [ $ comment -> getAuthor ( ) ] = $ authorId ++ ; } } $ objWriter -> startElement ( 'comments' ) ; $ objWriter -> writeAttribute ( 'xmlns' , 'http://schemas.openxmlformats.org/spreadsheetml/2006/main' ) ; $ objWriter -> startElement ( 'authors' ) ; foreach ( $ authors as $ author => $ index ) { $ objWriter -> writeElement ( 'author' , $ author ) ; } $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'commentList' ) ; foreach ( $ comments as $ key => $ value ) { $ this -> writeComment ( $ objWriter , $ key , $ value , $ authors ) ; } $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
1288	private function buildContentTypeCollection ( array $ data ) { $ items = \ array_merge ( $ data [ 'items' ] , $ data [ 'includes' ] [ 'Entry' ] ?? [ ] ) ; $ ids = \ array_map ( function ( array $ item ) { return 'Entry' === $ item [ 'sys' ] [ 'type' ] ? $ item [ 'sys' ] [ 'contentType' ] [ 'sys' ] [ 'id' ] : null ; } , $ items ) ; $ ids = \ array_filter ( \ array_unique ( $ ids ) , function ( $ id ) : bool { return $ id && ! $ this -> resourcePool -> has ( 'ContentType' , $ id ) ; } ) ; if ( $ ids ) { $ query = ( new Query ( ) ) -> where ( 'sys.id[in]' , \ implode ( ',' , $ ids ) ) ; $ this -> client -> getContentTypes ( $ query ) ; } }
5208	public function p ( ) { $ args = func_get_args ( ) ; $ node = $ args [ 0 ] ; if ( null === $ node ) { return ; } $ this -> logger -> trace ( 'p' . $ node -> getType ( ) , $ node , $ this -> getMetadata ( ) -> getFullQualifiedNameClass ( ) ) ; $ class = $ this -> getClass ( 'p' . $ node -> getType ( ) ) ; return call_user_func_array ( array ( $ class , "convert" ) , $ args ) ; }
621	protected function splitCondition ( InCondition $ condition , & $ params ) { $ operator = $ condition -> getOperator ( ) ; $ values = $ condition -> getValues ( ) ; $ column = $ condition -> getColumn ( ) ; if ( $ values instanceof \ Traversable ) { $ values = iterator_to_array ( $ values ) ; } if ( ! is_array ( $ values ) ) { return null ; } $ maxParameters = 1000 ; $ count = count ( $ values ) ; if ( $ count <= $ maxParameters ) { return null ; } $ slices = [ ] ; for ( $ i = 0 ; $ i < $ count ; $ i += $ maxParameters ) { $ slices [ ] = $ this -> queryBuilder -> createConditionFromArray ( [ $ operator , $ column , array_slice ( $ values , $ i , $ maxParameters ) ] ) ; } array_unshift ( $ slices , ( $ operator === 'IN' ) ? 'OR' : 'AND' ) ; return $ this -> queryBuilder -> buildCondition ( $ slices , $ params ) ; }
7420	protected function getNumList ( ) : array { preg_match_all ( '/\/\d+/u' , $ this -> request -> route ( ) , $ numList ) ; $ numList = $ numList [ 0 ] ; $ numList = array_map ( function ( $ val ) { return intval ( ltrim ( $ val , '/' ) ) ; } , $ numList ) ; return $ numList ; }
9225	private function preprocessData ( $ data ) { if ( is_array ( $ data ) && ! array_key_exists ( self :: PARAM_PER_PAGE , $ data ) ) { $ data [ self :: PARAM_PER_PAGE ] = CanvasArray :: MAXIMUM_PER_PAGE ; } return $ data ; }
1076	private static function isMissingVariable ( $ valueNode , $ variables ) { return $ valueNode instanceof VariableNode && ( count ( $ variables ) === 0 || ! array_key_exists ( $ valueNode -> name -> value , $ variables ) ) ; }
3352	public function getUserAgentHeader ( ) { $ userAgentName = $ this -> getUserAgentName ( ) ; if ( $ userAgentName ) { return $ userAgentName ; } $ userAgent = sprintf ( '%s/%s/%s (PHP/%s.%s.%s' , $ this -> getLibraryName ( ) , $ this -> getVersion ( ) , $ this -> getPublicKey ( ) , PHP_MAJOR_VERSION , PHP_MINOR_VERSION , PHP_RELEASE_VERSION ) ; $ framework = $ this -> getFramework ( ) ; if ( $ framework ) { $ userAgent .= '; ' . $ framework ; } $ extension = $ this -> getExtension ( ) ; if ( $ extension ) { $ userAgent .= '; ' . $ extension ; } $ userAgent .= ')' ; return $ userAgent ; }
2	private function buildDependency10Info ( $ depArray ) { static $ dep10toOperatorMap = array ( 'has' => '==' , 'eq' => '==' , 'ge' => '>=' , 'gt' => '>' , 'le' => '<=' , 'lt' => '<' , 'not' => '!=' ) ; $ result = array ( ) ; foreach ( $ depArray as $ depItem ) { if ( empty ( $ depItem [ 'rel' ] ) || ! array_key_exists ( $ depItem [ 'rel' ] , $ dep10toOperatorMap ) ) { continue ; } $ depType = ! empty ( $ depItem [ 'optional' ] ) && 'yes' == $ depItem [ 'optional' ] ? 'optional' : 'required' ; $ depType = 'not' == $ depItem [ 'rel' ] ? 'conflicts' : $ depType ; $ depVersion = ! empty ( $ depItem [ 'version' ] ) ? $ this -> parseVersion ( $ depItem [ 'version' ] ) : '*' ; $ depVersionConstraint = ( 'has' == $ depItem [ 'rel' ] || 'not' == $ depItem [ 'rel' ] ) && '*' == $ depVersion ? '*' : $ dep10toOperatorMap [ $ depItem [ 'rel' ] ] . $ depVersion ; switch ( $ depItem [ 'type' ] ) { case 'php' : $ depChannelName = 'php' ; $ depPackageName = '' ; break ; case 'pkg' : $ depChannelName = ! empty ( $ depItem [ 'channel' ] ) ? $ depItem [ 'channel' ] : 'pear.php.net' ; $ depPackageName = $ depItem [ 'name' ] ; break ; case 'ext' : $ depChannelName = 'ext' ; $ depPackageName = $ depItem [ 'name' ] ; break ; case 'os' : case 'sapi' : $ depChannelName = '' ; $ depPackageName = '' ; break ; default : $ depChannelName = '' ; $ depPackageName = '' ; break ; } if ( '' != $ depChannelName ) { $ result [ ] = new DependencyConstraint ( $ depType , $ depVersionConstraint , $ depChannelName , $ depPackageName ) ; } } return $ result ; }
11473	public function destroy ( ResponseRequest $ request , Response $ response ) { try { $ id = $ response [ 'question_id' ] ; $ question = $ this -> question -> selectquestion ( $ id ) ; $ response -> delete ( ) ; return redirect ( '/discussion/' . $ question [ 'slug' ] ) ; } catch ( Exception $ e ) { return $ this -> response -> message ( $ e -> getMessage ( ) ) -> code ( 400 ) -> status ( 'error' ) -> url ( guard_url ( 'forum/response/' . $ response -> getRouteKey ( ) ) ) -> redirect ( ) ; } }
9783	public function parseExpression ( ) { $ token = $ this -> peek ( ) ; $ type = $ token [ 0 ] ; switch ( $ type ) { case 'IF_OPEN' : return $ this -> parseIf ( ) ; case 'FOR_OPEN' : return $ this -> parseFor ( ) ; case 'FILTERED_VALUE' : return $ this -> parseFilteredValue ( ) ; case 'VALUE' : return $ this -> parseValue ( ) ; case 'HTML' : return $ this -> parseHTML ( ) ; case 'ESCAPE' : return $ this -> parseEscape ( ) ; case 'INCLUDE' : return $ this -> parseInclude ( ) ; default : throw new SyntaxErrorException ( "Could not parse expression, invalid token '$type'" ) ; } }
4804	private function getTemplatePath ( ) { $ tsfe = $ GLOBALS [ 'TSFE' ] ; if ( isset ( $ tsfe -> tmpl -> setup [ 'lib.' ] [ 'plugins.' ] [ 'tx_happyfeet.' ] [ 'view.' ] [ 'template' ] ) ) { $ templateFile = GeneralUtility :: getFileAbsFileName ( $ tsfe -> tmpl -> setup [ 'lib.' ] [ 'plugins.' ] [ 'tx_happyfeet.' ] [ 'view.' ] [ 'template' ] ) ; if ( is_file ( $ templateFile ) ) { return $ tsfe -> tmpl -> setup [ 'lib.' ] [ 'plugins.' ] [ 'tx_happyfeet.' ] [ 'view.' ] [ 'template' ] ; } } return $ this -> getTemplatePathAndFilename ( $ this -> defaultTemplate ) ; }
2207	protected function compileYearlyMenu ( ) { $ arrData = array ( ) ; $ arrAllEvents = $ this -> getAllEvents ( $ this -> cal_calendar , 0 , 2145913200 ) ; foreach ( $ arrAllEvents as $ intDay => $ arrDay ) { foreach ( $ arrDay as $ arrEvents ) { $ arrData [ substr ( $ intDay , 0 , 4 ) ] += \ count ( $ arrEvents ) ; } } ( $ this -> cal_order == 'ascending' ) ? ksort ( $ arrData ) : krsort ( $ arrData ) ; $ arrItems = array ( ) ; $ count = 0 ; $ limit = \ count ( $ arrData ) ; foreach ( $ arrData as $ intYear => $ intCount ) { $ intDate = $ intYear ; $ quantity = sprintf ( ( ( $ intCount < 2 ) ? $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'entry' ] : $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'entries' ] ) , $ intCount ) ; $ arrItems [ $ intYear ] [ 'date' ] = $ intDate ; $ arrItems [ $ intYear ] [ 'link' ] = $ intYear ; $ arrItems [ $ intYear ] [ 'href' ] = $ this -> strLink . '?year=' . $ intDate ; $ arrItems [ $ intYear ] [ 'title' ] = StringUtil :: specialchars ( $ intYear . ' (' . $ quantity . ')' ) ; $ arrItems [ $ intYear ] [ 'class' ] = trim ( ( ( ++ $ count == 1 ) ? 'first ' : '' ) . ( ( $ count == $ limit ) ? 'last' : '' ) ) ; $ arrItems [ $ intYear ] [ 'isActive' ] = ( Input :: get ( 'year' ) == $ intDate ) ; $ arrItems [ $ intYear ] [ 'quantity' ] = $ quantity ; } $ this -> Template -> yearly = true ; $ this -> Template -> items = $ arrItems ; $ this -> Template -> showQuantity = ( $ this -> cal_showQuantity != '' ) ? true : false ; }
5193	public function dispatch ( ServerRequestInterface $ request ) : ServerRequestInterface { $ dispatcher = simpleDispatcher ( [ $ this , 'addRoutes' ] ) ; $ routeInfo = $ dispatcher -> dispatch ( $ request -> getMethod ( ) , $ request -> getUri ( ) -> getPath ( ) ) ; if ( $ routeInfo [ 0 ] === Dispatcher :: METHOD_NOT_ALLOWED ) { throw new MethodNotAllowedException ( $ request -> getMethod ( ) , $ routeInfo [ 1 ] ) ; } if ( $ routeInfo [ 0 ] === Dispatcher :: NOT_FOUND ) { throw new NotFoundHttpException ( sprintf ( "Route '%s' not found." , $ request -> getUri ( ) -> getPath ( ) ) ) ; } foreach ( $ routeInfo [ 2 ] as $ key => $ value ) { $ request = $ request -> withAttribute ( $ key , $ value ) ; } return $ request -> withAttribute ( 'route' , $ this -> routes [ $ routeInfo [ 1 ] ] ) ; }
5942	public function readLine ( $ token = "\n" ) { $ this -> connect ( ) ; $ line = StringHelper :: factory ( "" ) ; while ( ! $ line -> endsWith ( $ token ) ) { $ this -> waitForReadyRead ( ) ; $ data = @ fgets ( $ this -> stream , 4096 ) ; Signal :: getInstance ( ) -> emit ( strtolower ( $ this -> getAdapterType ( ) ) . "DataRead" , $ data ) ; if ( $ data === false ) { if ( $ line -> count ( ) ) { $ line -> append ( $ token ) ; } else { throw new Ts3Exception ( "connection to server '" . $ this -> config [ "host" ] . ":" . $ this -> config [ "port" ] . "' lost" ) ; } } else { $ line -> append ( $ data ) ; } } return $ line -> trim ( ) ; }
12874	public function saveAction ( Request $ request , Application $ app ) { $ options = array ( "configuration_handler" => $ app [ "red_kite_cms.configuration_handler" ] , "plugin_manager" => $ app [ "red_kite_cms.plugin_manager" ] , "theme_deployer" => $ app [ "red_kite_cms.theme_deployer" ] , "page" => clone ( $ app [ "red_kite_cms.page" ] ) , ) ; return parent :: save ( $ options ) ; }
9464	private function registerLogViewerPackage ( ) { $ this -> registerProvider ( LogViewerServiceProvider :: class ) ; $ config = $ this -> config ( ) ; $ config -> set ( 'log-viewer.route.enabled' , false ) ; $ config -> set ( 'log-viewer.menu.filter-route' , $ config -> get ( 'arcanesoft.foundation.log-viewer.filter-route' ) ) ; }
6736	public function instantiate ( $ provider ) { if ( ! $ this -> supported ( $ provider ) ) { throw new ProviderNotSupportedException ( $ provider ) ; } $ class = $ this -> providerClass ( $ provider ) ; switch ( $ provider ) { case 'facebook' : return new $ class ( $ this -> config , $ this -> redirector , $ this -> http , $ this -> store , $ this -> profile , $ this -> access_token ) ; break ; case 'twitter' : return new $ class ( $ this -> config , $ this -> http , $ this -> redirector , $ this -> store , $ this -> profile , $ this -> signature , $ this -> consumer , $ this -> token , $ this -> oauth ) ; break ; } }
10319	function getBlocksCount ( $ fromDate = null , $ toDate = null , $ contactIds = null , $ contactEmails = null , $ contactExternalIds = null , $ reasons = null , $ oldStatus = null , $ newStatus = null , $ excludeAnonymousBlocks = false ) { $ params = $ this -> createCountQueryParameters ( $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , null , null ) ; if ( isset ( $ excludeAnonymousBlocks ) ) $ params [ 'exclude_anonymous_blocks' ] = ( $ excludeAnonymousBlocks == true ) ? "true" : "false" ; $ params = $ this -> appendArrayFields ( $ params , "reasons" , $ reasons ) ; if ( isset ( $ oldStatus ) ) $ params [ 'old_status' ] = $ oldStatus ; if ( isset ( $ newStatus ) ) $ params [ 'new_status' ] = $ newStatus ; return $ this -> get ( 'reports/blocks/count' , $ params ) ; }
12850	private function _checkCache ( \ stdClass $ oCache ) { $ sHearderValidity = false ; $ sHeader = "Cache-Control:" ; if ( isset ( $ oCache -> visibility ) && ( $ oCache -> visibility = 'public' || $ oCache -> visibility = 'private' ) ) { $ sHearderValidity = true ; $ sHeader .= " " . $ oCache -> visibility . "," ; } if ( isset ( $ oCache -> max_age ) ) { $ sHearderValidity = true ; $ sHeader .= " maxage=" . $ oCache -> max_age . "," ; } if ( isset ( $ oCache -> must_revalidate ) && $ oCache -> must_revalidate === true ) { $ sHearderValidity = true ; $ sHeader .= " must-revalidate," ; } if ( $ sHearderValidity === true ) { $ sHeader = substr ( $ sHeader , 0 , - 1 ) ; if ( ! headers_sent ( ) ) { header ( $ sHeader ) ; } } if ( isset ( $ oCache -> ETag ) ) { header ( "ETag: \"" . $ oCache -> ETag . "\"" ) ; } if ( isset ( $ oCache -> max_age ) ) { if ( ! headers_sent ( ) ) { header ( 'Expires: ' . gmdate ( 'D, d M Y H:i:s' , time ( ) + $ oCache -> max_age ) . ' GMT' ) ; } } if ( isset ( $ oCache -> last_modified ) ) { if ( ! headers_sent ( ) ) { header ( 'Last-Modified: ' . gmdate ( 'D, d M Y H:i:s' , time ( ) + $ oCache -> last_modified ) . ' GMT' ) ; } } if ( isset ( $ oCache -> vary ) ) { header ( 'Vary: ' . $ oCache -> vary ) ; } }
1907	protected function escapeParams ( $ arrValues ) { foreach ( $ arrValues as $ k => $ v ) { switch ( \ gettype ( $ v ) ) { case 'string' : $ arrValues [ $ k ] = $ this -> resConnection -> quote ( $ v ) ; break ; case 'boolean' : $ arrValues [ $ k ] = ( $ v === true ) ? 1 : 0 ; break ; case 'object' : $ arrValues [ $ k ] = $ this -> resConnection -> quote ( serialize ( $ v ) ) ; break ; case 'array' : $ arrValues [ $ k ] = $ this -> resConnection -> quote ( serialize ( $ v ) ) ; break ; default : $ arrValues [ $ k ] = $ v ?? 'NULL' ; break ; } } return $ arrValues ; }
1997	public function dump ( ) : void { if ( empty ( $ this -> parameters [ 'parameters' ] [ 'secret' ] ) || 'ThisTokenIsNotSoSecretChangeIt' === $ this -> parameters [ 'parameters' ] [ 'secret' ] ) { $ this -> parameters [ 'parameters' ] [ 'secret' ] = bin2hex ( random_bytes ( 32 ) ) ; } if ( isset ( $ this -> parameters [ 'parameters' ] [ 'database_port' ] ) ) { $ this -> parameters [ 'parameters' ] [ 'database_port' ] = ( int ) $ this -> parameters [ 'parameters' ] [ 'database_port' ] ; } $ this -> filesystem -> dumpFile ( $ this -> rootDir . '/app/config/parameters.yml' , "# This file has been auto-generated during installation\n" . Yaml :: dump ( $ this -> getEscapedValues ( ) ) ) ; }
2423	public static function updateFolderHashes ( $ varResource ) { $ arrPaths = array ( ) ; if ( ! \ is_array ( $ varResource ) ) { $ varResource = array ( $ varResource ) ; } $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; foreach ( $ varResource as $ strResource ) { $ arrChunks = explode ( '/' , $ strResource ) ; $ strPath = array_shift ( $ arrChunks ) ; if ( is_file ( $ rootDir . '/' . $ strResource ) ) { array_pop ( $ arrChunks ) ; } while ( \ count ( $ arrChunks ) ) { $ strPath .= '/' . array_shift ( $ arrChunks ) ; $ arrPaths [ ] = $ strPath ; } unset ( $ arrChunks ) ; } $ arrPaths = array_values ( array_unique ( $ arrPaths ) ) ; foreach ( array_reverse ( $ arrPaths ) as $ strPath ) { $ objModel = FilesModel :: findByPath ( $ strPath ) ; if ( $ objModel === null ) { $ objModel = static :: addResource ( $ strPath , false ) ; } $ objModel -> hash = static :: getFolderHash ( $ strPath ) ; $ objModel -> save ( ) ; } }
1611	private function _createDocument ( $ withUrlSet = true ) { $ document = new \ DOMDocument ( '1.0' , 'utf-8' ) ; if ( \ Craft :: $ app -> config -> general -> devMode ) $ document -> formatOutput = true ; if ( $ withUrlSet ) { $ urlSet = $ document -> createElement ( 'urlset' ) ; $ urlSet -> setAttribute ( 'xmlns' , 'http://www.sitemaps.org/schemas/sitemap/0.9' ) ; $ urlSet -> setAttribute ( 'xmlns:xhtml' , 'http://www.w3.org/1999/xhtml' ) ; $ document -> appendChild ( $ urlSet ) ; $ this -> _urlSet = $ urlSet ; } $ this -> _document = $ document ; }
5914	public function updateLastLogin ( $ id , $ successful = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'successful' => $ successful ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/accounts/users/' . $ id . '/registerloginattempt' , $ parameters ) ; $ result = new User ( $ result ) ; return $ result ; }
3161	protected function getTransmissionId ( QtiRunnerServiceContext $ context , $ itemId = null ) { if ( is_null ( $ itemId ) ) { $ itemId = $ context -> getCurrentAssessmentItemRef ( ) ; } elseif ( $ itemId != $ context -> getCurrentAssessmentItemRef ( ) ) { throw new \ common_exception_NotImplemented ( 'Item variables can be stored only for the current item' ) ; } $ sessionId = $ context -> getTestSession ( ) -> getSessionId ( ) ; $ currentOccurrence = $ context -> getTestSession ( ) -> getCurrentAssessmentItemRefOccurence ( ) ; return $ sessionId . '.' . $ itemId . '.' . $ currentOccurrence ; }
9595	public function makeSessionStorage ( ) { $ storage = $ this -> config -> get ( 'session.storage' ) ; if ( $ storage == 'mock_array' ) { return new MockArraySessionStorage ; } if ( $ storage == 'mock_file' ) { return new MockFileSessionStorage ; } $ handler = $ this -> dic -> resolve ( 'SessionHandlerInterface' ) ; if ( $ storage == 'bridge' ) { return new PhpBridgeSessionStorage ( $ handler ) ; } $ options = $ this -> config -> get ( 'session.storage_options' , [ ] ) ; if ( $ storage == 'native' ) { return new NativeSessionStorage ( $ options , $ handler ) ; } if ( ! is_string ( $ storage ) ) { $ storage = gettype ( $ storage ) ; } throw new \ RuntimeException ( "Unknown session storage driver: $storage" ) ; }
11065	public function icon ( $ level , $ default = null ) { if ( array_key_exists ( $ level , $ this -> icons ) ) { return $ this -> icons [ $ level ] ; } return $ default ; }
3855	public function setMetaTags ( $ strTitleAttribute , $ strDescriptionAttribute ) { $ this -> strDescriptionAttribute = $ strDescriptionAttribute ; $ this -> strTitleAttribute = $ strTitleAttribute ; return $ this ; }
722	public function json ( ) { if ( version_compare ( PHP_VERSION , '5.6' , '<' ) && $ this -> getDb ( ) -> getDriverName ( ) === 'mysql' ) { throw new \ yii \ base \ Exception ( 'JSON column type is not supported in PHP < 5.6' ) ; } return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_JSON ) ; }
10089	function addAttachmentFromBase64Data ( $ filename , $ mimetype , $ contents ) { $ attachment = new Attachment ( $ filename , $ mimetype , $ contents ) ; $ this -> attachments [ ] = $ attachment ; }
1423	protected function with ( $ query , EncodingParametersInterface $ parameters ) { $ query -> with ( $ this -> getRelationshipPaths ( ( array ) $ parameters -> getIncludePaths ( ) ) ) ; }
3466	public function put ( string $ route , callable $ controller ) : void { $ this -> register ( $ controller , Route :: put ( $ route ) ) ; }
6541	public function fetchOne ( $ tableName , array $ identifier , $ shardingKey = null , $ forceFromMaster = true ) { return $ this -> fetch ( $ tableName , $ identifier , $ shardingKey , array ( '*' ) , false , $ forceFromMaster ) ; }
6250	protected function filterNestedEmptyGroups ( AclPresenceInterface $ presence ) { if ( $ presence [ 'type' ] !== AclPresenceType :: GROUP ) { return 1 ; } $ permissions = $ presence -> permissions ( ) ; if ( ! $ permissions ) { return 0 ; } if ( is_string ( $ permissions ) ) { return 1 ; } return count ( $ permissions ) ; }
999	public function getType ( $ name ) { if ( ! isset ( $ this -> resolvedTypes [ $ name ] ) ) { $ type = $ this -> loadType ( $ name ) ; if ( ! $ type ) { return null ; } $ this -> resolvedTypes [ $ name ] = $ type ; } return $ this -> resolvedTypes [ $ name ] ; }
5723	public function unPublish ( ) { $ origStage = Versioned :: get_stage ( ) ; Versioned :: set_stage ( 'Live' ) ; $ clone = clone $ this -> owner -> record ; $ clone -> delete ( ) ; Versioned :: set_stage ( $ origStage ) ; return $ this -> owner -> edit ( Controller :: curr ( ) -> getRequest ( ) ) ; }
8736	public function insert ( array $ values ) { list ( $ values , $ i18nValues ) = $ this -> filterValues ( $ values ) ; if ( $ this -> query -> insert ( $ values ) ) { return $ this -> insertI18n ( $ i18nValues , $ values [ $ this -> model -> getKeyName ( ) ] ) ; } }
7563	protected function parse_not ( ) { if ( ( ( $ this -> pos + 1 ) < $ this -> size ) && ( $ this -> doc [ $ this -> pos + 1 ] === '=' ) ) { ++ $ this -> pos ; return ( $ this -> token = self :: TOK_COMPARE_NOT_EQUAL ) ; } else { return ( $ this -> token = self :: TOK_NOT ) ; } }
10447	public function post ( Payload $ payload , $ endpoint ) { if ( ! Type :: isValidWebhookType ( $ payload -> getAction ( ) ) ) { throw new \ Exception ( sprintf ( 'Webhook "%s" isn\'t valid' , $ payload -> getAction ( ) ) ) ; } $ requestContent = [ 'headers' => [ 'Content-Type' => 'application/json' ] , 'body' => json_encode ( $ payload ) , 'timeout' => self :: DEFAULT_REQUEST_TIMEOUT ] ; return $ this -> guzzleClient -> post ( $ endpoint , $ requestContent ) ; }
12749	private function validateSKU ( string $ sku ) { if ( strlen ( $ sku ) == 0 ) { throw new SKUException ( "A SKU cannot be empty" ) ; } $ containsWhitespace = preg_match ( $ this -> whiteSpacePattern , $ sku ) == 1 ; if ( $ containsWhitespace ) { throw new SKUException ( sprintf ( "A SKU cannot contain white space characters: \"%s\"" , $ sku ) ) ; } $ containsUppercaseCharacters = preg_match ( $ this -> uppercaseCharactersPattern , $ sku ) == 1 ; if ( $ containsUppercaseCharacters ) { throw new SKUException ( sprintf ( "A SKU cannot contain uppercase characters: \"%s\"" , $ sku ) ) ; } $ containsInvalidCharacters = preg_match ( $ this -> invalidCharactersPattern , $ sku ) == 1 ; if ( $ containsInvalidCharacters ) { throw new SKUException ( sprintf ( "The SKU \"%s\" contains invalid characters. A SKU can only contain the following characters: a-z, 0-9 and -" , $ sku ) ) ; } $ prefixMatches = [ ] ; $ prefixContainsInvalidCharacters = preg_match ( $ this -> invalidPrefixCharacters , $ sku , $ prefixMatches ) == 1 ; if ( $ prefixContainsInvalidCharacters ) { throw new SKUException ( sprintf ( "A SKU cannot start with the given characters: \"%s\"" , implode ( "" , $ prefixMatches ) ) ) ; } $ suffixMatches = [ ] ; $ suffixContainsInvalidCharacters = preg_match ( $ this -> invalidSuffixCharacters , $ sku , $ suffixMatches ) == 1 ; if ( $ suffixContainsInvalidCharacters ) { throw new SKUException ( sprintf ( "A SKU cannot end with the given characters: \"%s\"" , implode ( "" , $ suffixMatches ) ) ) ; } if ( strlen ( $ sku ) < $ this -> minLength ) { throw new SKUException ( sprintf ( "The given SKU \"%s\" is too short. The minimum length for a SKU is: %s" , $ sku , $ this -> minLength ) ) ; } if ( strlen ( $ sku ) > $ this -> maxLength ) { throw new SKUException ( sprintf ( "The given SKU \"%s\" is too long (%s character). The maximum length for a SKU is: %s" , strlen ( $ sku ) , $ sku , $ this -> maxLength ) ) ; } }
5150	protected function getEmailRecipients ( $ email ) { $ recipients = $ email -> Headers -> to . ' ' . $ email -> Headers -> cc ; if ( $ email -> Headers -> bcc != NULL ) { $ recipients .= ' ' . $ email -> Headers -> bcc ; } return $ recipients ; }
376	protected function parseDocCommentDetail ( $ reflection ) { $ comment = strtr ( trim ( preg_replace ( '/^\s*\**( |\t)?/m' , '' , trim ( $ reflection -> getDocComment ( ) , '/' ) ) ) , "\r" , '' ) ; if ( preg_match ( '/^\s*@\w+/m' , $ comment , $ matches , PREG_OFFSET_CAPTURE ) ) { $ comment = trim ( substr ( $ comment , 0 , $ matches [ 0 ] [ 1 ] ) ) ; } if ( $ comment !== '' ) { return rtrim ( Console :: renderColoredString ( Console :: markdownToAnsi ( $ comment ) ) ) ; } return '' ; }
12207	public function refresh ( ) { if ( null === $ this -> options || null === $ this -> sourceDir ) { return ; } $ this -> render ( $ this -> sourceDir , $ this -> options , $ this -> username ) ; }
12571	public function previewVoice ( $ message , $ to , $ by = self :: PREVIEW_BY_OPENID ) { return $ this -> preview ( self :: MSG_TYPE_VOICE , $ message , $ to , $ by ) ; }
12549	public function boot ( ) { $ pluginFolders = $ this -> configurationHandler -> pluginFolders ( ) ; $ this -> core = $ this -> findPlugins ( $ this -> configurationHandler -> corePluginsDir ( ) . "/Core" ) ; foreach ( $ pluginFolders as $ pluginFolder ) { $ this -> blocks += $ this -> findPlugins ( $ pluginFolder . "/Block" ) ; $ this -> themes += $ this -> findPlugins ( $ pluginFolder . "/Theme" ) ; } return $ this ; }
1482	public function encoder ( $ options = 0 , $ depth = 512 ) { if ( $ options instanceof Encoding ) { $ options = $ options -> getOptions ( ) ; } if ( ! $ options instanceof EncoderOptions ) { $ options = new EncoderOptions ( $ options , $ this -> getUrl ( ) -> toString ( ) , $ depth ) ; } return $ this -> factory -> createEncoder ( $ this -> getContainer ( ) , $ options ) ; }
7302	static function getAvailableTransitions ( PaymentInterface $ payment , $ admin = false ) { $ transitions = [ ] ; $ method = $ payment -> getMethod ( ) ; $ state = $ payment -> getState ( ) ; if ( $ admin ) { if ( $ method -> isManual ( ) ) { switch ( $ state ) { case PaymentStates :: STATE_PENDING : $ transitions [ ] = static :: TRANSITION_CANCEL ; $ transitions [ ] = static :: TRANSITION_ACCEPT ; break ; case PaymentStates :: STATE_CAPTURED : $ transitions [ ] = static :: TRANSITION_CANCEL ; $ transitions [ ] = static :: TRANSITION_HANG ; $ transitions [ ] = static :: TRANSITION_REFUND ; break ; case PaymentStates :: STATE_REFUNDED : $ transitions [ ] = static :: TRANSITION_CANCEL ; $ transitions [ ] = static :: TRANSITION_HANG ; $ transitions [ ] = static :: TRANSITION_ACCEPT ; break ; case PaymentStates :: STATE_CANCELED : $ transitions [ ] = static :: TRANSITION_HANG ; $ transitions [ ] = static :: TRANSITION_ACCEPT ; break ; } } elseif ( $ method -> isOutstanding ( ) || $ method -> isManual ( ) ) { if ( $ state === PaymentStates :: STATE_CAPTURED ) { $ transitions [ ] = static :: TRANSITION_CANCEL ; } else { $ transitions [ ] = static :: TRANSITION_ACCEPT ; } } else { if ( $ state === PaymentStates :: STATE_CAPTURED ) { $ transitions [ ] = static :: TRANSITION_REFUND ; } if ( $ state === PaymentStates :: STATE_PENDING ) { $ diff = $ payment -> getUpdatedAt ( ) -> diff ( new \ DateTime ( ) ) ; if ( 0 < $ diff -> days && ! $ diff -> invert ) { $ transitions [ ] = static :: TRANSITION_CANCEL ; } } } } else { if ( $ method -> isManual ( ) && $ state === PaymentStates :: STATE_PENDING ) { $ transitions [ ] = static :: TRANSITION_CANCEL ; } } return $ transitions ; }
10276	public static function getTextWidthPixelsApprox ( $ columnText , \ PhpOffice \ PhpSpreadsheet \ Style \ Font $ font , $ rotation = 0 ) { $ fontName = $ font -> getName ( ) ; $ fontSize = $ font -> getSize ( ) ; switch ( $ fontName ) { case 'Calibri' : $ columnWidth = ( int ) ( 8.26 * StringHelper :: countCharacters ( $ columnText ) ) ; $ columnWidth = $ columnWidth * $ fontSize / 11 ; break ; case 'Arial' : $ columnWidth = ( int ) ( 8 * StringHelper :: countCharacters ( $ columnText ) ) ; $ columnWidth = $ columnWidth * $ fontSize / 10 ; break ; case 'Verdana' : $ columnWidth = ( int ) ( 8 * StringHelper :: countCharacters ( $ columnText ) ) ; $ columnWidth = $ columnWidth * $ fontSize / 10 ; break ; default : $ columnWidth = ( int ) ( 8.26 * StringHelper :: countCharacters ( $ columnText ) ) ; $ columnWidth = $ columnWidth * $ fontSize / 11 ; break ; } if ( $ rotation !== 0 ) { if ( $ rotation == - 165 ) { $ columnWidth = 4 ; } else { $ columnWidth = $ columnWidth * cos ( deg2rad ( $ rotation ) ) + $ fontSize * abs ( sin ( deg2rad ( $ rotation ) ) ) / 5 ; } } return ( int ) $ columnWidth ; }
7116	public function watch ( Repository \ PaymentRepositoryInterface $ paymentRepository ) { if ( null === $ term = $ this -> termRepository -> findLongest ( ) ) { return false ; } $ today = new \ DateTime ( ) ; $ today -> setTime ( 0 , 0 , 0 ) ; $ fromDate = clone $ today ; $ fromDate -> modify ( '-1 year' ) ; $ states = [ Model \ PaymentStates :: STATE_AUTHORIZED , Model \ PaymentStates :: STATE_CAPTURED ] ; $ method = $ this -> methodRepository -> findOneBy ( [ 'factoryName' => Constants :: FACTORY_NAME , ] ) ; if ( ! $ method || ! $ method -> isOutstanding ( ) ) { return false ; } $ result = false ; $ payments = $ paymentRepository -> findByMethodAndStates ( $ method , $ states , $ fromDate ) ; foreach ( $ payments as $ payment ) { $ sale = $ payment -> getSale ( ) ; if ( null === $ date = $ sale -> getOutstandingDate ( ) ) { continue ; } $ diff = $ date -> diff ( $ today ) ; if ( 0 < $ diff -> days && ! $ diff -> invert ) { $ payment -> setState ( Model \ PaymentStates :: STATE_EXPIRED ) ; $ this -> persist ( $ payment ) ; $ result = true ; } } return $ result ; }
5798	public function routeIndex ( Request $ request , Response $ response , $ args ) { $ this -> tableName = $ args [ ROUTEARG_DATABASE_TABLE_NAME ] ; $ this -> tableMapper = new TableMapper ( $ this -> tableName ) ; parent :: __construct ( $ this -> container , $ this -> tableMapper , ROUTEPREFIX_ROLES ) ; return $ this -> indexView ( $ response ) ; }
4516	public function setSortOrder ( ? string $ sortOrder ) { $ this -> sortOrder = $ sortOrder ; $ this -> _sortOrder = null !== $ sortOrder ; return $ this ; }
3259	public function placeTransaction ( $ gateway , $ transactionId , $ detail = null , $ token = null ) { return call_user_func ( Config :: get ( 'shop.transaction' ) . '::create' , [ 'order_id' => $ this -> attributes [ 'id' ] , 'gateway' => $ gateway , 'transaction_id' => $ transactionId , 'detail' => $ detail , 'token' => $ token , ] ) ; }
3836	private function setLanguageStrings ( ) { if ( empty ( $ GLOBALS [ 'TL_LANG' ] [ $ this -> getMetaModel ( ) -> getTableName ( ) ] [ $ this -> getColName ( ) ] ) ) { $ GLOBALS [ 'TL_LANG' ] [ $ this -> getMetaModel ( ) -> getTableName ( ) ] [ $ this -> getColName ( ) ] = array ( $ this -> getLangValue ( $ this -> get ( 'name' ) ) , $ this -> getLangValue ( $ this -> get ( 'description' ) ) , ) ; } }
7506	function setDoc ( $ doc , $ pos = 0 ) { $ this -> doc = $ doc ; $ this -> size = strlen ( $ doc ) ; $ this -> setPos ( $ pos ) ; }
1362	public function accept ( AcceptMediaTypeInterface $ mediaType ) : bool { if ( 0 === $ mediaType -> getQuality ( ) ) { return false ; } return $ this -> matchesTo ( $ mediaType ) ; }
10694	protected function startOrRestart ( ) { if ( session_status ( ) == PHP_SESSION_ACTIVE ) return ; if ( $ this -> SessionDir ) { if ( ! file_exists ( $ this -> SessionDir ) ) { mkdir ( $ this -> SessionDir , 0777 , true ) ; } session_save_path ( $ this -> SessionDir ) ; } session_start ( ) ; $ FingerPrint = "" ; if ( $ this -> IpAddress ) { if ( ! $ this -> IpAddress -> isValid ( ) ) { session_unset ( ) ; session_destroy ( ) ; throw new \ Exception ( "Cannot start session. Reason: Invalid IP " . $ this -> IpAddress -> getValue ( ) . " detected" , 403 ) ; } else $ FingerPrint = $ this -> IpAddress -> getValue ( ) ; } if ( $ this -> Browser ) { if ( ! $ this -> Browser -> isKnownBrowser ( ) ) { session_unset ( ) ; session_destroy ( ) ; throw new \ Exception ( "Cannot start session. Reason: Invalid Browser " . $ this -> Browser -> getSignature ( ) . " detected." , 403 ) ; } else $ FingerPrint .= $ this -> Browser -> getSignature ( ) ; } $ currFp = md5 ( $ FingerPrint ) ; $ prevFp = isset ( $ _SESSION [ "FingerPrint" ] ) ? $ _SESSION [ "FingerPrint" ] : null ; if ( $ prevFp ) { if ( $ prevFp != $ currFp ) { session_unset ( ) ; session_destroy ( ) ; throw new \ Exception ( "Cannot start session. Reason: IP changed. Current is $currFp, previous was: $prevFp" , Interfaces \ HttpResponder :: EXIT_CODE_UNAUTHORIZED ) ; } } $ currTime = time ( ) ; $ prevTime = isset ( $ _SESSION [ "LastSessionStart" ] ) ? $ _SESSION [ "LastSessionStart" ] : null ; $ timeOutSecs = isset ( $ _SESSION [ "TimeOutSecs" ] ) ? $ _SESSION [ "TimeOutSecs" ] : null ; if ( $ prevTime && $ timeOutSecs ) { if ( $ prevTime + $ timeOutSecs < $ currTime ) { session_unset ( ) ; session_destroy ( ) ; throw new \ Exception ( "Session timeout" , Interfaces \ HttpResponder :: EXIT_CODE_UNAUTHORIZED ) ; } } $ _SESSION [ "FingerPrint" ] = $ currFp ; $ _SESSION [ "LastSessionStart" ] = $ currTime ; }
11425	public function remark ( $ openId , $ remark ) { $ params = [ 'openid' => $ openId , 'remark' => $ remark , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_REMARK , $ params ] ) ; }
2115	private function getFieldValue ( ? PageModel $ page ) : string { if ( null === $ page ) { return '' ; } return ( string ) $ page -> { $ this -> field } ; }
828	private function isValidVariable ( Tokens $ tokens , $ index ) { if ( ! $ tokens [ $ index ] -> isGivenKind ( T_VARIABLE ) ) { return false ; } $ nextIndex = $ tokens -> getNextMeaningfulToken ( $ index ) ; return $ tokens [ $ nextIndex ] -> equals ( '=' ) ; }
5808	public function onAfterDelete ( ) { parent :: onAfterDelete ( ) ; $ fusion = FusionTag :: get ( ) -> byID ( $ this -> owner -> FusionTagID ) ; $ types = unserialize ( $ fusion -> TagTypes ) ; unset ( $ types [ $ this -> owner -> ClassName ] ) ; $ fusion -> TagTypes = ! empty ( $ types ) ? serialize ( $ types ) : null ; $ fusion -> write ( ) ; }
2435	public function remove ( $ strKey ) { if ( \ in_array ( $ strKey , $ this -> mappedKeys ) ) { $ this -> session -> remove ( $ strKey ) ; } else { $ this -> sessionBag -> remove ( $ strKey ) ; } }
4694	public function addOrderBy ( string $ expression , ... $ args ) : self { $ this -> dirty ( ) ; $ this -> order [ ] = $ expression ; $ this -> pushArgs ( 'order' , $ args ) ; return $ this ; }
2174	private function setUpDatabaseConnection ( ) : Response { $ request = $ this -> container -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; if ( null === $ request ) { throw new \ RuntimeException ( 'The request stack did not contain a request' ) ; } if ( false !== getenv ( 'DATABASE_URL' ) ) { return $ this -> render ( 'misconfigured_database_url.html.twig' ) ; } $ parameters = [ 'parameters' => [ 'database_host' => $ this -> getContainerParameter ( 'database_host' ) , 'database_port' => $ this -> getContainerParameter ( 'database_port' ) , 'database_user' => $ this -> getContainerParameter ( 'database_user' ) , 'database_password' => $ this -> getContainerParameter ( 'database_password' ) , 'database_name' => $ this -> getContainerParameter ( 'database_name' ) , ] , ] ; if ( 'tl_database_login' !== $ request -> request -> get ( 'FORM_SUBMIT' ) ) { return $ this -> render ( 'database.html.twig' , $ parameters ) ; } $ parameters = [ 'parameters' => [ 'database_host' => $ request -> request -> get ( 'dbHost' ) , 'database_port' => $ request -> request -> get ( 'dbPort' ) , 'database_user' => $ request -> request -> get ( 'dbUser' ) , 'database_password' => $ this -> getContainerParameter ( 'database_password' ) , 'database_name' => $ request -> request -> get ( 'dbName' ) , ] , ] ; if ( '*****' !== $ request -> request -> get ( 'dbPassword' ) ) { $ parameters [ 'parameters' ] [ 'database_password' ] = $ request -> request -> get ( 'dbPassword' ) ; } if ( false !== strpos ( $ parameters [ 'parameters' ] [ 'database_name' ] , '.' ) ) { return $ this -> render ( 'database.html.twig' , array_merge ( $ parameters , [ 'database_error' => $ this -> trans ( 'database_dot_in_dbname' ) ] ) ) ; } $ installTool = $ this -> container -> get ( 'contao.install_tool' ) ; $ installTool -> setConnection ( ConnectionFactory :: create ( $ parameters ) ) ; if ( ! $ installTool -> canConnectToDatabase ( $ parameters [ 'parameters' ] [ 'database_name' ] ) ) { return $ this -> render ( 'database.html.twig' , array_merge ( $ parameters , [ 'database_error' => $ this -> trans ( 'database_could_not_connect' ) ] ) ) ; } $ dumper = new ParameterDumper ( $ this -> getContainerParameter ( 'kernel.project_dir' ) ) ; $ dumper -> setParameters ( $ parameters ) ; $ dumper -> dump ( ) ; $ this -> purgeSymfonyCache ( ) ; return $ this -> getRedirectResponse ( ) ; }
3296	protected function domDocumentArray ( $ root ) { $ result = [ ] ; if ( $ root -> hasAttributes ( ) ) { foreach ( $ root -> attributes as $ attribute ) { $ result [ '@attributes' ] [ $ attribute -> name ] = $ attribute -> value ; } } if ( $ root -> hasChildNodes ( ) ) { if ( 1 == $ root -> childNodes -> length ) { $ child = $ root -> childNodes -> item ( 0 ) ; if ( in_array ( $ child -> nodeType , [ XML_TEXT_NODE , XML_CDATA_SECTION_NODE ] ) && ! empty ( $ child -> nodeValue ) ) { $ result [ '_value' ] = $ child -> nodeValue ; return 1 == count ( $ result ) ? $ result [ '_value' ] : $ result ; } } $ groups = [ ] ; foreach ( $ root -> childNodes as $ child ) { if ( ! isset ( $ result [ $ child -> nodeName ] ) ) { $ result [ $ child -> nodeName ] = $ this -> domDocumentArray ( $ child ) ; } else { if ( ! isset ( $ groups [ $ child -> nodeName ] ) ) { $ result [ $ child -> nodeName ] = [ $ result [ $ child -> nodeName ] ] ; $ groups [ $ child -> nodeName ] = 1 ; } $ result [ $ child -> nodeName ] [ ] = $ this -> domDocumentArray ( $ child ) ; } } } return $ result ; }
10071	public function render ( InputFilter $ inputFilter ) { $ inputFilter -> prepare ( ) ; $ props = $ inputFilter -> getAttributes ( ) ; $ treeBuilder = new TreeBuilder ( $ inputFilter ) ; $ props = array_merge ( $ props , $ treeBuilder -> getTree ( ) ) ; return $ this -> make ( 'widget-form' , $ props ) ; }
8331	public function constructPdoDsn ( array $ params ) { if ( PlatformHelper :: isWindows ( ) ) { return $ this -> constructPdoDsnWindows ( $ params ) ; } return $ this -> constructPdoDsnUnix ( $ params ) ; }
7715	static function FindStartTagByPrefix ( & $ Txt , $ TagPrefix , $ PosBeg , $ Forward = true ) { $ x = '<' . $ TagPrefix ; $ xl = strlen ( $ x ) ; if ( $ Forward ) { $ PosBeg = strpos ( $ Txt , $ x , $ PosBeg ) ; } else { $ PosBeg = strrpos ( substr ( $ Txt , 0 , $ PosBeg + 2 ) , $ x ) ; } if ( $ PosBeg === false ) return false ; $ Tag = $ TagPrefix ; $ p = $ PosBeg + $ xl ; do { $ z = substr ( $ Txt , $ p , 1 ) ; if ( ( $ z !== ' ' ) && ( $ z !== "\r" ) && ( $ z !== "\n" ) && ( $ z !== '>' ) && ( $ z !== '/' ) ) { $ Tag .= $ z ; $ p ++ ; } else { $ p = false ; } } while ( $ p !== false ) ; return new clsTbsXmlLoc ( $ Txt , $ Tag , $ PosBeg ) ; }
7663	function AddAttachment ( $ path , $ name = "" , $ encoding = "base64" , $ type = "application/octet-stream" ) { if ( ! @ is_file ( $ path ) ) { $ this -> SetError ( $ this -> Lang ( "file_access" ) . $ path ) ; return false ; } $ filename = basename ( $ path ) ; if ( $ name == "" ) $ name = $ filename ; $ cur = count ( $ this -> attachment ) ; $ this -> attachment [ $ cur ] [ 0 ] = $ path ; $ this -> attachment [ $ cur ] [ 1 ] = $ filename ; $ this -> attachment [ $ cur ] [ 2 ] = $ name ; $ this -> attachment [ $ cur ] [ 3 ] = $ encoding ; $ this -> attachment [ $ cur ] [ 4 ] = $ type ; $ this -> attachment [ $ cur ] [ 5 ] = false ; $ this -> attachment [ $ cur ] [ 6 ] = "attachment" ; $ this -> attachment [ $ cur ] [ 7 ] = 0 ; return true ; }
10118	private function writeMarginLeft ( ) { $ record = 0x0026 ; $ length = 0x0008 ; $ margin = $ this -> phpSheet -> getPageMargins ( ) -> getLeft ( ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'd' , $ margin ) ; if ( self :: getByteOrder ( ) ) { $ data = strrev ( $ data ) ; } $ this -> append ( $ header . $ data ) ; }
11117	protected function rollbackMigrations ( array $ migrations ) : void { $ this -> notify -> note ( '' ) ; foreach ( $ this -> getMigrationFiles ( M :: TYPE_DOWN ) as $ file ) { if ( in_array ( $ name = $ this -> getMigrationName ( $ file ) , $ migrations , true ) ) { $ this -> runDown ( $ file ) ; continue ; } $ this -> notify -> note ( "<fg=red>Migrate not found (in database table):</> {$name}" ) ; } }
9562	protected function matchesTypehint ( $ handler , Exception $ exception ) { if ( $ handler instanceof ErrorHandlerInterface ) { return true ; } if ( is_array ( $ handler ) ) { $ reflection = ( new ReflectionMethod ( $ handler [ 0 ] , $ handler [ 1 ] ) ) ; } else { $ reflection = ( new ReflectionFunction ( $ handler ) ) ; } $ params = $ reflection -> getParameters ( ) ; if ( empty ( $ params ) ) { return true ; } $ handlerHint = $ params [ 0 ] -> getClass ( ) ; if ( ! $ handlerHint ) { return true ; } return $ handlerHint -> isInstance ( $ exception ) ; }
8307	public function assertStringContaining ( $ config , $ key , $ searchedPart ) { $ this -> assertString ( $ config , $ key ) ; if ( array_key_exists ( $ key , $ config ) && strpos ( $ config [ $ key ] , $ searchedPart ) === false ) { throw new ConfigurationException ( $ key . " must contain " . $ searchedPart ) ; } return $ this ; }
567	private function parseDateValueFormat ( $ value , $ format ) { if ( is_array ( $ value ) ) { return false ; } if ( strncmp ( $ format , 'php:' , 4 ) === 0 ) { $ format = substr ( $ format , 4 ) ; } else { if ( extension_loaded ( 'intl' ) ) { return $ this -> parseDateValueIntl ( $ value , $ format ) ; } $ format = FormatConverter :: convertDateIcuToPhp ( $ format , 'date' ) ; } return $ this -> parseDateValuePHP ( $ value , $ format ) ; }
11449	public function fill ( array $ attributes ) { if ( $ this -> getFieldManager ( ) ) { $ attributes = $ this -> getFieldManager ( ) -> transformToResource ( $ attributes ) ; } return parent :: fill ( $ attributes ) ; }
7754	public function deserialize ( $ data , $ type , $ format , array $ context = array ( ) ) { if ( 'jsonld' !== $ format ) { throw new UnexpectedValueException ( 'Deserialization for the format ' . $ format . ' is not supported' ) ; } $ reflectionClass = new \ ReflectionClass ( $ type ) ; if ( null !== ( $ constructor = $ reflectionClass -> getConstructor ( ) ) ) { if ( 0 !== $ constructor -> getNumberOfRequiredParameters ( ) ) { throw new RuntimeException ( 'Cannot create an instance of ' . $ type . ' from serialized data because its constructor has required parameters.' ) ; } } return $ this -> doDeserialize ( $ data , new $ type ) ; }
12085	public function store ( $ objectURI = null ) { $ this -> setPropertyValue ( "media_owner" , $ this -> user -> getPropertyValue ( "user_name_id" ) ) ; if ( ! $ this -> saveObject ( $ objectURI , $ this -> getObjectType ( ) ) ) { return false ; } return true ; }
10361	public static function writeLogs ( string $ message ) : bool { return ( bool ) file_put_contents ( rtrim ( LOGS_PATH , '/' ) . '/' . gmdate ( 'Y_m_d' ) . '.log' , '[' . gmdate ( 'd-M-Y H:i:s' ) . '] ' . $ message . PHP_EOL , FILE_APPEND ) ; }
12220	public function exceptionHandler ( $ exception ) { $ request = ( isset ( $ this -> container [ 'latestRequest' ] ) ? $ this -> container [ 'latestRequest' ] : $ this -> container [ 'request' ] ) ; $ response = ( isset ( $ this -> container [ 'latestResponse' ] ) ? $ this -> container [ 'latestResponse' ] : $ this -> container [ 'response' ] ) ; if ( ! ( $ exception instanceof Exception ) ) { $ exception = new InternalServerError ( $ exception -> getMessage ( ) , $ exception -> getCode ( ) , $ exception -> getPrevious ( ) ) ; } $ this -> logException ( $ exception ) ; $ response = $ response -> withBody ( new Stream ( 'php://memory' , 'w+' ) ) ; $ response = $ response -> withStatus ( $ exception -> getStatusCode ( ) ) ; $ body = $ this -> prepareErrorBody ( $ exception ) ; $ response = $ response -> withUnserializedBody ( $ body ) ; $ this -> container [ 'pipeline' ] -> prepareErrorQueue ( ) ; $ this -> container [ 'pipeline' ] ( $ request , $ response ) ; }
3725	private function buildPickerService ( ContainerBuilder $ container ) { $ pickerService = $ container -> getDefinition ( 'metamodels.controller.picker' ) ; $ configs = $ pickerService -> getArgument ( 2 ) ; $ configs [ 'PALETTE_STYLE_PICKER' ] [ ] = [ 'cssclass' => 'w50' ] ; $ configs [ 'PALETTE_STYLE_PICKER' ] [ ] = [ 'cssclass' => 'w50x' ] ; $ configs [ 'PALETTE_STYLE_PICKER' ] [ ] = [ 'cssclass' => 'clr' ] ; $ configs [ 'PALETTE_STYLE_PICKER' ] [ ] = [ 'cssclass' => 'clx' ] ; $ configs [ 'PALETTE_STYLE_PICKER' ] [ ] = [ 'cssclass' => 'long' ] ; $ configs [ 'PALETTE_STYLE_PICKER' ] [ ] = [ 'cssclass' => 'wizard' ] ; $ configs [ 'PALETTE_STYLE_PICKER' ] [ ] = [ 'cssclass' => 'm12' ] ; $ configs [ 'PALETTE_PANEL_PICKER' ] [ ] = [ 'cssclass' => 'search' ] ; $ configs [ 'PALETTE_PANEL_PICKER' ] [ ] = [ 'cssclass' => 'sort' ] ; $ configs [ 'PALETTE_PANEL_PICKER' ] [ ] = [ 'cssclass' => 'filter' ] ; $ configs [ 'PALETTE_PANEL_PICKER' ] [ ] = [ 'cssclass' => 'limit' ] ; $ pickerService -> setArgument ( 2 , $ configs ) ; }
7050	protected function buildDiscountsLines ( Document \ DocumentInterface $ document ) { $ sale = $ document -> getSale ( ) ; if ( ! $ sale -> hasAdjustments ( Common \ AdjustmentTypes :: TYPE_DISCOUNT ) ) { return ; } $ adjustments = $ sale -> getAdjustments ( ) ; foreach ( $ adjustments as $ adjustment ) { if ( $ adjustment -> getType ( ) === Common \ AdjustmentTypes :: TYPE_DISCOUNT ) { $ this -> buildDiscountLine ( $ adjustment , $ document ) ; } } }
11898	public function getEstimateTimeRemaining ( ) { $ estimatedDuration = $ this -> dataInterface -> estimateDuration ( ) ; if ( $ estimatedDuration ) { $ startedTime = strtotime ( $ this -> started ) ; $ estimatedEndTime = $ startedTime + $ estimatedDuration ; if ( time ( ) > $ estimatedEndTime ) { return false ; } return $ estimatedEndTime - time ( ) ; } return false ; }
10597	protected function getRouteLocalizedRecord ( \ MvcCore \ IRoute & $ route , $ getter ) { $ result = $ route -> $ getter ( $ this -> requestLang ) ; if ( $ result === NULL && $ this -> defaultLang !== NULL ) $ result = $ route -> $ getter ( $ this -> defaultLang ) ; return $ result ; }
6394	public function andFinally ( callable $ finallyBlock ) : TryTo { return TryTo :: run ( $ this -> tryBlock , $ this -> exceptions , $ finallyBlock ) ; }
314	public function getVendorPath ( ) { if ( $ this -> _vendorPath === null ) { $ this -> setVendorPath ( $ this -> getBasePath ( ) . DIRECTORY_SEPARATOR . 'vendor' ) ; } return $ this -> _vendorPath ; }
12930	public function attemptConfirmation ( $ code ) { $ token = $ this -> finder -> findToken ( [ 'user_id' => $ this -> id , 'code' => $ code , 'type' => Token :: TYPE_CONFIRMATION , ] ) -> one ( ) ; if ( $ token === null || $ token -> isExpired ) { \ Yii :: $ app -> session -> setFlash ( 'danger' , \ Yii :: t ( 'user' , 'The confirmation link is invalid or expired. Please try requesting a new one.' ) ) ; } else { $ token -> delete ( ) ; $ this -> confirmed_at = time ( ) ; \ Yii :: $ app -> user -> login ( $ this ) ; \ Yii :: getLogger ( ) -> log ( 'User has been confirmed' , Logger :: LEVEL_INFO ) ; if ( $ this -> save ( false ) ) { \ Yii :: $ app -> session -> setFlash ( 'success' , \ Yii :: t ( 'user' , 'Thank you, registration is now complete.' ) ) ; } else { \ Yii :: $ app -> session -> setFlash ( 'danger' , \ Yii :: t ( 'user' , 'Something went wrong and your account has not been confirmed.' ) ) ; } } }
10278	public function write ( Spreadsheet $ spreadsheet = null ) { $ objWriter = null ; if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' ) ; $ objWriter -> startElement ( 'office:document-styles' ) ; $ objWriter -> writeAttribute ( 'xmlns:office' , 'urn:oasis:names:tc:opendocument:xmlns:office:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:style' , 'urn:oasis:names:tc:opendocument:xmlns:style:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:text' , 'urn:oasis:names:tc:opendocument:xmlns:text:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:table' , 'urn:oasis:names:tc:opendocument:xmlns:table:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:draw' , 'urn:oasis:names:tc:opendocument:xmlns:drawing:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:fo' , 'urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:xlink' , 'http://www.w3.org/1999/xlink' ) ; $ objWriter -> writeAttribute ( 'xmlns:dc' , 'http://purl.org/dc/elements/1.1/' ) ; $ objWriter -> writeAttribute ( 'xmlns:meta' , 'urn:oasis:names:tc:opendocument:xmlns:meta:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:number' , 'urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:presentation' , 'urn:oasis:names:tc:opendocument:xmlns:presentation:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:svg' , 'urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:chart' , 'urn:oasis:names:tc:opendocument:xmlns:chart:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:dr3d' , 'urn:oasis:names:tc:opendocument:xmlns:dr3d:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:math' , 'http://www.w3.org/1998/Math/MathML' ) ; $ objWriter -> writeAttribute ( 'xmlns:form' , 'urn:oasis:names:tc:opendocument:xmlns:form:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:script' , 'urn:oasis:names:tc:opendocument:xmlns:script:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:ooo' , 'http://openoffice.org/2004/office' ) ; $ objWriter -> writeAttribute ( 'xmlns:ooow' , 'http://openoffice.org/2004/writer' ) ; $ objWriter -> writeAttribute ( 'xmlns:oooc' , 'http://openoffice.org/2004/calc' ) ; $ objWriter -> writeAttribute ( 'xmlns:dom' , 'http://www.w3.org/2001/xml-events' ) ; $ objWriter -> writeAttribute ( 'xmlns:rpt' , 'http://openoffice.org/2005/report' ) ; $ objWriter -> writeAttribute ( 'xmlns:of' , 'urn:oasis:names:tc:opendocument:xmlns:of:1.2' ) ; $ objWriter -> writeAttribute ( 'xmlns:xhtml' , 'http://www.w3.org/1999/xhtml' ) ; $ objWriter -> writeAttribute ( 'xmlns:grddl' , 'http://www.w3.org/2003/g/data-view#' ) ; $ objWriter -> writeAttribute ( 'xmlns:tableooo' , 'http://openoffice.org/2009/table' ) ; $ objWriter -> writeAttribute ( 'xmlns:css3t' , 'http://www.w3.org/TR/css3-text/' ) ; $ objWriter -> writeAttribute ( 'office:version' , '1.2' ) ; $ objWriter -> writeElement ( 'office:font-face-decls' ) ; $ objWriter -> writeElement ( 'office:styles' ) ; $ objWriter -> writeElement ( 'office:automatic-styles' ) ; $ objWriter -> writeElement ( 'office:master-styles' ) ; $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
3162	public function assertQtiRunnerServiceContext ( RunnerServiceContext $ context ) { if ( ! $ context instanceof QtiRunnerServiceContext ) { throw new \ common_exception_InvalidArgumentType ( __CLASS__ , __FUNCTION__ , 0 , QtiRunnerServiceContext :: class , $ context ) ; } }
8333	private function getSelectSql ( ) { if ( self :: LOCK_TRANSACTIONAL === $ this -> lockMode ) { $ this -> beginTransaction ( ) ; switch ( $ this -> driver ) { case 'mysql' : case 'oci' : case 'pgsql' : return "SELECT $this->dataCol, $this->lifetimeCol, $this->timeCol FROM $this->table WHERE $this->idCol = :id FOR UPDATE" ; case 'sqlsrv' : return "SELECT $this->dataCol, $this->lifetimeCol, $this->timeCol FROM $this->table WITH (UPDLOCK, ROWLOCK) WHERE $this->idCol = :id" ; case 'sqlite' : break ; default : throw new \ DomainException ( sprintf ( 'Transactional locks are currently not implemented for PDO driver "%s".' , $ this -> driver ) ) ; } } return "SELECT $this->dataCol, $this->lifetimeCol, $this->timeCol FROM $this->table WHERE $this->idCol = :id" ; }
11	private function mockLocalRepositories ( RepositoryManager $ rm ) { $ packages = array ( ) ; foreach ( $ rm -> getLocalRepository ( ) -> getPackages ( ) as $ package ) { $ packages [ ( string ) $ package ] = clone $ package ; } foreach ( $ packages as $ key => $ package ) { if ( $ package instanceof AliasPackage ) { $ alias = ( string ) $ package -> getAliasOf ( ) ; $ packages [ $ key ] = new AliasPackage ( $ packages [ $ alias ] , $ package -> getVersion ( ) , $ package -> getPrettyVersion ( ) ) ; } } $ rm -> setLocalRepository ( new InstalledArrayRepository ( $ packages ) ) ; }
6939	private function push ( array & $ list , $ oid , StockUnitInterface $ unit ) { if ( ! $ this -> has ( $ list , $ oid , $ unit ) ) { $ list [ $ oid ] [ ] = $ unit ; } }
193	public function clear ( ) { $ this -> _headers = null ; $ this -> _cookies = null ; $ this -> _statusCode = 200 ; $ this -> statusText = 'OK' ; $ this -> data = null ; $ this -> stream = null ; $ this -> content = null ; $ this -> isSent = false ; }
12462	private function createCreateForm ( CustomFieldsGroup $ entity ) { $ form = $ this -> createForm ( 'custom_fields_group' , $ entity , array ( 'action' => $ this -> generateUrl ( 'customfieldsgroup_create' ) , 'method' => 'POST' , ) ) ; $ form -> add ( 'submit' , 'submit' , array ( 'label' => 'Create' ) ) ; return $ form ; }
11135	protected function calculateUPDATE ( ) { $ this -> query .= 'UPDATE ' ; $ this -> queryStringFromArray ( 'tables' , '' , ', ' ) ; $ this -> queryStringFromArray ( 'updates' , ' SET ' , ', ' ) ; $ this -> conditionStringFromArray ( 'wheres' , ' WHERE ' , ' AND ' ) ; $ this -> queryStringFromArray ( 'orderBys' , ' ORDER BY ' , ', ' , false ) ; if ( $ this -> limit ) { $ this -> query .= ' LIMIT ' . $ this -> limit ; } }
9659	public static function createReader ( $ readerType ) { if ( ! isset ( self :: $ readers [ $ readerType ] ) ) { throw new Reader \ Exception ( "No reader found for type $readerType" ) ; } $ className = self :: $ readers [ $ readerType ] ; $ reader = new $ className ( ) ; return $ reader ; }
11548	public function getGroup ( $ name ) { if ( array_key_exists ( $ name , $ this -> groups ) ) { return $ this -> groups [ $ name ] ; } throw new KeyNotFoundInSetException ( $ name , array_keys ( $ this -> groups ) , 'groups' ) ; }
3774	public function getTypeNames ( ) { $ names = $ this -> factories -> ids ( ) ; if ( [ ] !== $ fallback = $ this -> fallbackFactory -> getIds ( ) ) { $ names = array_unique ( array_merge ( $ fallback , $ names ) ) ; } return $ names ; }
4692	public function andHaving ( string $ expression , ... $ args ) : self { $ this -> dirty ( ) ; $ this -> having = $ this -> having ? '(' . $ this -> having . ') AND (' . $ expression . ')' : $ expression ; $ this -> pushArgs ( 'having' , $ args ) ; return $ this ; }
3992	public function decodeValue ( DecodePropertyValueForWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ metaModel = $ this -> getMetaModelFromModel ( $ event -> getModel ( ) ) ; $ values = Helper :: decodeLangArray ( $ event -> getValue ( ) , $ metaModel ) ; $ event -> setValue ( unserialize ( $ values ) ) ; }
9529	private function validateRequiredParameters ( ) { $ ret = true ; foreach ( $ this -> parameterCluster -> prefixes as $ prefix => $ parameters ) { foreach ( $ parameters as $ parameterClosure ) { if ( $ parameterClosure -> required ) { if ( ! in_array ( $ parameterClosure -> prefix . $ parameterClosure -> parameterName , $ this -> argv ) ) { $ aliasFound = false ; foreach ( $ parameterClosure -> aliases as $ prefix => $ alias ) { if ( in_array ( $ prefix . $ alias , $ this -> argv ) ) { $ aliasFound = true ; break ; } } if ( ! $ aliasFound ) { $ ret = $ parameterClosure ; break 2 ; } } } } } return $ ret ; }
8440	public function createAction ( string $ production_slug , Request $ request , TokenStorageInterface $ token , AuthorizationCheckerInterface $ auth ) : Response { $ production_repo = $ this -> em -> getRepository ( Production :: class ) ; if ( null === $ production = $ production_repo -> findOneBy ( [ 'slug' => $ production_slug ] ) ) { throw new NotFoundHttpException ( ) ; } if ( ! $ auth -> isGranted ( 'GROUP_ROLE_USER' , $ production ) ) { throw new AccessDeniedException ( ) ; } $ user = $ token -> getToken ( ) -> getUser ( ) ; $ post = new Post ( ) ; $ post -> setActive ( true ) ; $ post -> setPinned ( false ) ; $ post -> setAuthor ( $ user -> getUsername ( ) ) ; $ post -> addGroup ( $ production ) ; if ( $ request -> query -> has ( 'reply-to' ) ) { $ repo = $ this -> em -> getRepository ( Post :: class ) ; if ( null === $ parent = $ repo -> findOneBy ( [ 'id' => $ request -> query -> get ( 'reply-to' ) ] ) ) { throw new NotFoundHttpException ( ) ; } if ( ! $ parent -> getGroups ( ) -> contains ( $ production ) ) { throw new AccessDeniedException ( ) ; } if ( null !== $ parent -> getParent ( ) ) { throw new AccessDeniedException ( ) ; } $ post -> setParent ( $ parent ) ; $ form = $ this -> form -> create ( ReplyType :: class , $ post ) ; } else { $ form = $ this -> form -> create ( PostType :: class , $ post ) ; } $ form -> handleRequest ( $ request ) ; if ( $ form -> isSubmitted ( ) && $ form -> isValid ( ) ) { $ this -> em -> persist ( $ post ) ; $ this -> em -> flush ( ) ; $ this -> session -> getFlashBag ( ) -> add ( 'success' , $ this -> translator -> trans ( 'post.created' , [ ] , BkstgNoticeBoardBundle :: TRANSLATION_DOMAIN ) ) ; return new RedirectResponse ( $ this -> url_generator -> generate ( 'bkstg_board_show' , [ 'production_slug' => $ production -> getSlug ( ) ] ) ) ; } return new Response ( $ this -> templating -> render ( '@BkstgNoticeBoard/Post/create.html.twig' , [ 'form' => $ form -> createView ( ) , 'post' => $ post , 'production' => $ production , ] ) ) ; }
11730	public function validatePassword ( ) { $ user = User :: findByEmail ( $ this -> email ) ; if ( ! $ user || ! $ user -> validatePassword ( $ this -> password ) ) { $ this -> addError ( 'password' , 'Incorrect username or password.' ) ; } }
9080	private static function parseElement ( Request & $ req , $ serverVars , $ elementName , $ paramName ) { if ( isset ( $ serverVars [ $ elementName ] ) ) { $ req -> setParam ( $ paramName , $ serverVars [ $ elementName ] ) ; } }
6817	protected function buildAdjustments ( $ type , Model \ AdjustableInterface $ adjustable , array $ data , $ persistence = false ) { Model \ AdjustmentTypes :: isValidType ( $ type ) ; $ change = false ; $ newAdjustments = [ ] ; foreach ( $ data as $ d ) { $ adjustment = $ this -> saleFactory -> createAdjustmentFor ( $ adjustable ) ; $ adjustment -> setType ( $ type ) -> setMode ( $ d -> getMode ( ) ) -> setDesignation ( $ d -> getDesignation ( ) ) -> setAmount ( $ d -> getAmount ( ) ) -> setImmutable ( $ d -> isImmutable ( ) ) ; $ newAdjustments [ ] = $ adjustment ; } $ oldAdjustments = $ adjustable -> getAdjustments ( $ type ) ; foreach ( $ oldAdjustments as $ oldAdjustment ) { if ( ! $ oldAdjustment -> isImmutable ( ) ) { continue ; } foreach ( $ newAdjustments as $ index => $ newAdjustment ) { if ( $ oldAdjustment -> equals ( $ newAdjustment ) ) { unset ( $ newAdjustments [ $ index ] ) ; continue 2 ; } } $ adjustable -> removeAdjustment ( $ oldAdjustment ) ; if ( $ persistence ) { $ this -> persistenceHelper -> remove ( $ oldAdjustment , true ) ; } $ change = true ; } foreach ( $ newAdjustments as $ newAdjustment ) { $ adjustable -> addAdjustment ( $ newAdjustment ) ; if ( $ persistence ) { $ this -> persistenceHelper -> persistAndRecompute ( $ newAdjustment , true ) ; } $ change = true ; } return $ change ; }
6219	public function getPeriodEnd ( ) { if ( is_null ( $ this -> parsedPeriodEnd ) ) { $ this -> parsedPeriodEnd = strtotime ( $ this -> periodEnd ) ; } return $ this -> parsedPeriodEnd ; }
8338	public function returning ( $ returning ) { if ( is_array ( $ returning ) === true ) { $ this -> returning = implode ( ', ' , $ returning ) ; } else { $ this -> returning = $ returning ; } return $ this ; }
4951	public function getTargetFQCN ( ) { return is_object ( $ this -> target ) ? get_class ( $ this -> target ) : ( string ) $ this -> target ; }
706	public function primaryKey ( $ length = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_PK , $ length ) ; }
12648	public function get ( ) { $ arResult = [ 'status' => $ this -> status ( ) , 'data' => $ this -> data ( ) , 'message' => $ this -> message ( ) , 'code' => $ this -> code ( ) , ] ; return $ arResult ; }
12907	public function store ( FilterRequest $ request ) { $ this -> fieldManager = $ this -> getFieldManager ( ) ; $ this -> validate ( $ request -> request , $ this -> fieldManager -> store ( ) ) ; $ input = $ request -> all ( ) ; $ resource = $ this -> repository -> create ( $ input ) ; if ( ! $ resource ) { } return $ this -> created ( $ resource ) ; }
6157	public function redirectSelf ( ) : object { $ url = $ this -> di -> get ( "request" ) -> getCurrentUrl ( ) ; return parent :: redirect ( $ this -> di -> get ( "url" ) -> create ( $ url ) ) ; }
10308	private function setGlowSize ( $ size ) { if ( $ size !== null ) { $ this -> glowProperties [ 'size' ] = $ this -> getExcelPointsWidth ( $ size ) ; } return $ this ; }
1926	public function countColors ( $ max = null ) { if ( ! imageistruecolor ( $ this -> gdResource ) ) { return imagecolorstotal ( $ this -> gdResource ) ; } $ colors = array ( ) ; $ width = imagesx ( $ this -> gdResource ) ; $ height = imagesy ( $ this -> gdResource ) ; for ( $ x = 0 ; $ x < $ width ; $ x ++ ) { for ( $ y = 0 ; $ y < $ height ; $ y ++ ) { $ colors [ imagecolorat ( $ this -> gdResource , $ x , $ y ) ] = true ; if ( $ max !== null && \ count ( $ colors ) > $ max ) { break 2 ; } } } return \ count ( $ colors ) ; }
10052	private function resolvePath ( $ path_alias , $ file_name ) { $ path = \ Yii :: getAlias ( $ path_alias , false ) ; $ path = $ path ? realpath ( $ path ) : $ path ; $ file_name = ! preg_match ( '/\.php$/i' , $ file_name ) ? $ file_name . '.php' : $ file_name ; if ( ! $ path || ! is_dir ( $ path ) || ! file_exists ( $ path . '/' . $ file_name ) ) { throw new Exception ( "Faker template \"{$path}/{$file_name}\" not found" ) ; } return $ path . '/' . $ file_name ; }
8858	private function _absoluteSymlinkWithFallback ( string $ originDir , string $ targetDir ) : string { try { $ this -> _symlink ( $ originDir , $ targetDir ) ; $ method = AssetsInstallCommand :: METHOD_ABSOLUTE_SYMLINK ; } catch ( IOException $ e ) { $ method = $ this -> _hardCopy ( $ originDir , $ targetDir ) ; } return $ method ; }
752	public function addRateLimitHeaders ( $ response , $ limit , $ remaining , $ reset ) { if ( $ this -> enableRateLimitHeaders ) { $ response -> getHeaders ( ) -> set ( 'X-Rate-Limit-Limit' , $ limit ) -> set ( 'X-Rate-Limit-Remaining' , $ remaining ) -> set ( 'X-Rate-Limit-Reset' , $ reset ) ; } }
4286	public function processLogEntry ( $ method , $ args = array ( ) , $ meta = array ( ) ) { if ( $ method === 'alert' ) { list ( $ method , $ args ) = $ this -> methodAlert ( $ args , $ meta ) ; } elseif ( $ method == 'assert' ) { \ array_unshift ( $ args , false ) ; } elseif ( \ in_array ( $ method , array ( 'count' , 'time' ) ) ) { $ method = 'log' ; } elseif ( \ in_array ( $ method , array ( 'profileEnd' , 'table' ) ) ) { $ method = 'log' ; if ( \ is_array ( $ args [ 0 ] ) ) { $ method = 'table' ; $ args = array ( $ this -> methodTable ( $ args [ 0 ] , $ meta [ 'columns' ] ) ) ; } elseif ( $ meta [ 'caption' ] ) { \ array_unshift ( $ args , $ meta [ 'caption' ] ) ; } } elseif ( $ method === 'trace' ) { $ method = 'table' ; $ args = array ( $ this -> methodTable ( $ args [ 0 ] , array ( 'function' , 'file' , 'line' ) ) ) ; } if ( ! \ in_array ( $ method , $ this -> consoleMethods ) ) { $ method = 'log' ; } foreach ( $ args as $ i => $ arg ) { $ args [ $ i ] = $ this -> dump ( $ arg ) ; } $ this -> json [ 'rows' ] [ ] = array ( $ args , isset ( $ meta [ 'file' ] ) ? $ meta [ 'file' ] . ': ' . $ meta [ 'line' ] : null , $ method === 'log' ? '' : $ method , ) ; }
7209	public static function createFinalFromGross ( Amount $ gross ) : Amount { $ final = new Amount ( $ gross -> getCurrency ( ) , $ gross -> getBase ( ) , $ gross -> getBase ( ) , 0 , $ gross -> getBase ( ) , $ gross -> getTax ( ) , $ gross -> getTotal ( ) ) ; foreach ( $ gross -> getTaxAdjustments ( ) as $ t ) { $ final -> addTaxAdjustment ( $ t ) ; } return $ final ; }
1762	public static function convertXlfToPhp ( $ strName , $ strLanguage , $ blnLoad = false ) { @ trigger_error ( 'Using System::convertXlfToPhp() has been deprecated and will no longer work in Contao 5.0. Use the Contao\CoreBundle\Config\Loader\XliffFileLoader instead.' , E_USER_DEPRECATED ) ; $ rootDir = self :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( strpos ( $ strName , $ rootDir . '/' ) === false ) { $ strName = $ rootDir . '/' . $ strName ; } $ loader = new XliffFileLoader ( static :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) , $ blnLoad ) ; return $ loader -> load ( $ strName , $ strLanguage ) ; }
4019	protected function handleSaveCallback ( $ field , $ widget , $ value ) { $ newValue = $ value ; if ( isset ( $ field [ 'save_callback' ] ) && is_array ( $ field [ 'save_callback' ] ) ) { foreach ( $ field [ 'save_callback' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; try { $ newValue = $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ newValue , $ this ) ; } catch ( Exception $ e ) { $ widget -> addError ( $ e -> getMessage ( ) ) ; $ this -> blnSubmitInput = false ; return $ value ; } } } return $ newValue ; }
8262	protected function isValidCallback ( Request $ httpRequest ) { return $ this -> session -> has ( "provider" ) && $ httpRequest -> query -> has ( "state" ) && $ this -> session -> has ( "oauth2state" ) && is_string ( $ this -> session -> get ( "oauth2state" ) ) && ( strlen ( $ this -> session -> get ( "oauth2state" ) ) > 0 ) ; }
5981	protected function buildBasepath ( $ url ) { if ( ! preg_match ( '#(\w+:)?//#' , $ url ) ) { $ url = '//' . $ url ; } $ urlParts = parse_url ( $ url ) ; if ( false === $ urlParts ) { throw new \ InvalidArgumentException ( 'Could not parse QBank URL.' ) ; } if ( empty ( $ urlParts [ 'scheme' ] ) ) { $ urlParts [ 'scheme' ] = 'http' ; } if ( ( empty ( $ urlParts [ 'path' ] ) || '/' == $ urlParts [ 'path' ] ) && 'qbank.se' == substr ( $ urlParts [ 'host' ] , - strlen ( 'qbank.se' ) ) ) { $ urlParts [ 'path' ] = '/api/' ; } if ( '/' != substr ( $ urlParts [ 'path' ] , - 1 ) ) { $ urlParts [ 'path' ] .= '/' ; } return $ urlParts [ 'scheme' ] . '://' . $ urlParts [ 'host' ] . ( ! empty ( $ urlParts [ 'port' ] ) ? ':' . $ urlParts [ 'port' ] : '' ) . $ urlParts [ 'path' ] ; }
1230	public function resolve ( array $ configuration ) { foreach ( $ this -> definitions as $ key => $ def ) { if ( ! isset ( $ configuration [ $ key ] ) ) { if ( isset ( $ def [ 'default' ] ) ) { $ configuration [ $ key ] = is_callable ( $ def [ 'default' ] ) ? $ def [ 'default' ] ( $ configuration ) : $ def [ 'default' ] ; } elseif ( empty ( $ def [ 'required' ] ) ) { continue ; } else { $ this -> throwRequired ( $ configuration ) ; } } $ this -> checkType ( $ def [ 'valid' ] , $ key , $ configuration [ $ key ] ) ; if ( isset ( $ def [ 'fn' ] ) ) { $ def [ 'fn' ] ( $ configuration [ $ key ] , $ configuration ) ; } } return $ configuration ; }
6546	public function get ( $ name ) { if ( ( $ sheet = $ this -> container -> getSheetByName ( $ name ) ) === null ) { throw new \ Aimeos \ MW \ Container \ Exception ( sprintf ( 'No sheet "%1$s" available' , $ name ) ) ; } return new \ Aimeos \ MW \ Container \ Content \ PHPExcel ( $ sheet , $ sheet -> getTitle ( ) , $ this -> getOptions ( ) ) ; }
4667	public function setRenderView ( $ viewPath , $ params ) { $ this -> setViewEngines ( [ '.volt' => function ( $ view = null ) { $ volt = new Volt ( $ view ) ; $ volt -> setOptions ( [ 'compiledPath' => APP_PATH . '/cache/volt/' , 'compiledSeparator' => '_' , 'compileAlways' => ! $ this -> getDI ( ) -> get ( 'config' ) -> application -> production , ] ) ; return $ volt ; } ] ) ; $ view = $ this -> getView ( ) ; $ content = $ view -> render ( $ viewPath , $ params ) ; return $ content ; }
7274	protected function decodeValue ( $ val , $ column = "" ) { if ( $ column === static :: $ idColumn ) $ val = ( int ) $ val ; else if ( isset ( static :: $ casts [ $ column ] ) ) { switch ( static :: $ casts [ $ column ] ) { case "object" : $ val = from_json ( $ val , false ) ; break ; case "array" : $ val = from_json ( $ val , true ) ; break ; default : settype ( $ val , static :: $ casts [ $ column ] ) ; } } else if ( in_array ( $ column , static :: $ jsons ) && is_string ( $ val ) ) $ val = from_json ( $ val ) ; return $ val ; }
6373	public function filterBy ( string $ className ) : FluentIterable { return self :: from ( Iterables :: filterBy ( $ this , $ className ) ) ; }
6841	public function getCache ( $ key ) { return isset ( $ this -> caches [ $ key ] ) ? $ this -> caches [ $ key ] : null ; }
5343	public function build ( SoapClientBuilderInterface $ builder ) { $ builder -> createWsdl ( $ this -> endpoint ) ; $ builder -> createSoapClient ( ) ; $ builder -> setLogin ( $ this -> login ) ; $ builder -> setMode ( $ this -> mode ) ; $ builder -> setClientVersion ( self :: CLIENT_VERSION ) ; return $ builder -> getSoapClient ( ) ; }
3195	public function setConsumedExtraTime ( $ time ) { $ this -> consumedExtraTime = max ( $ this -> consumedExtraTime , floatval ( $ time ) ) ; return $ this ; }
1412	public function resourceDoesNotSupportClientIds ( string $ type , string $ path = '/data' ) : ErrorInterface { return new Error ( null , null , Response :: HTTP_FORBIDDEN , $ this -> trans ( 'resource_client_ids_not_supported' , 'code' ) , $ this -> trans ( 'resource_client_ids_not_supported' , 'title' ) , $ this -> trans ( 'resource_client_ids_not_supported' , 'detail' , compact ( 'type' ) ) , $ this -> pointer ( $ path , 'id' ) ) ; }
1709	public function renderContaoBackendTemplate ( array $ blocks = [ ] ) : string { $ request = $ this -> requestStack -> getCurrentRequest ( ) ; if ( null === $ request || ! $ this -> scopeMatcher -> isBackendRequest ( $ request ) ) { return '' ; } $ controller = $ this -> framework -> createInstance ( BackendCustom :: class ) ; $ template = $ controller -> getTemplateObject ( ) ; foreach ( $ blocks as $ key => $ content ) { $ template -> { $ key } = $ content ; } $ response = $ controller -> run ( ) ; return $ response -> getContent ( ) ; }
6146	public function setStatusCode ( int $ value = null ) { if ( is_null ( $ value ) ) { return $ this ; } $ this -> statusCode = $ value ; return $ this ; }
4292	public function getCfg ( $ path = null ) { if ( ! \ strlen ( $ path ) ) { return $ this -> cfg ; } if ( isset ( $ this -> cfg [ $ path ] ) ) { return $ this -> cfg [ $ path ] ; } return null ; }
9441	public function get ( ) { if ( $ this -> range -> as_integer ) { return mt_rand ( $ this -> range -> min , $ this -> range -> max ) ; } else { return mt_rand ( 0 , mt_getrandmax ( ) ) / mt_getrandmax ( ) ; } }
3216	function chunkedUploadStart ( $ data ) { Checker :: argString ( "data" , $ data ) ; $ response = $ this -> _chunkedUpload ( array ( ) , $ data ) ; if ( $ response -> statusCode === 404 ) { throw new Exception_BadResponse ( "Got a 404, but we didn't send up an 'upload_id'" ) ; } $ correction = self :: _chunkedUploadCheckForOffsetCorrection ( $ response ) ; if ( $ correction !== null ) throw new Exception_BadResponse ( "Got an offset-correcting 400 response, but we didn't send an offset" ) ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; list ( $ uploadId , $ byteOffset ) = self :: _chunkedUploadParse200Response ( $ response -> body ) ; $ len = strlen ( $ data ) ; if ( $ byteOffset !== $ len ) throw new Exception_BadResponse ( "We sent $len bytes, but server returned an offset of $byteOffset" ) ; return $ uploadId ; }
8339	public static function get ( string $ fileName ) : array { if ( isset ( self :: $ files [ $ fileName ] ) === false ) { if ( ( $ content = file_get_contents ( $ fileName ) ) === false ) { throw new FileNotReadable ( 'file "' . $ fileName . '" can\'t be read' ) ; } $ content = ( string ) $ content ; try { $ content = Yaml :: parse ( $ content ) ; } catch ( ParseException $ e ) { throw new FileNotParsable ( 'file "' . $ fileName . '" can\'t be parsed' ) ; } self :: $ files [ $ fileName ] = $ content ; } return self :: $ files [ $ fileName ] ; }
1835	public static function findByIdOrAlias ( $ varId , array $ arrOptions = array ( ) ) { $ isAlias = ! preg_match ( '/^[1-9]\d*$/' , $ varId ) ; if ( ! $ isAlias && empty ( $ arrOptions ) ) { $ objModel = Registry :: getInstance ( ) -> fetch ( static :: $ strTable , $ varId ) ; if ( $ objModel !== null ) { return $ objModel ; } } $ t = static :: $ strTable ; $ arrOptions = array_merge ( array ( 'limit' => 1 , 'column' => $ isAlias ? array ( "$t.alias=?" ) : array ( "$t.id=?" ) , 'value' => $ varId , 'return' => 'Model' ) , $ arrOptions ) ; return static :: find ( $ arrOptions ) ; }
4807	public function schedule_event ( ) { if ( $ this -> is_scheduled ( $ this -> args [ 'name' ] ) ) { return ; } if ( $ this -> args [ 'run_on_creation' ] ) { call_user_func ( $ this -> args [ 'cb' ] , $ this -> args [ 'args' ] ) ; } if ( $ this -> args [ 'schedule' ] === 'schedule' ) { wp_schedule_event ( $ this -> args [ 'time' ] , $ this -> args [ 'recurrence' ] , $ this -> args [ 'name' ] , $ this -> args [ 'args' ] ) ; } elseif ( $ this -> args [ 'schedule' ] === 'single' ) { wp_schedule_single_event ( $ this -> args [ 'recurrence' ] , $ this -> args [ 'name' ] , $ this -> args [ 'args' ] ) ; } if ( is_multisite ( ) && ! wp_is_large_network ( ) ) { $ sites = ( array ) get_site_option ( $ this -> args [ 'name' ] . '_sites' , array ( ) ) ; $ sites [ ] = get_current_blog_id ( ) ; update_site_option ( $ this -> args [ 'name' ] . '_sites' , $ sites ) ; } return true ; }
2142	private function getSessionBag ( Request $ request ) : SessionBagInterface { if ( ! $ request -> hasSession ( ) || null === ( $ session = $ request -> getSession ( ) ) ) { throw new \ RuntimeException ( 'The request did not contain a session.' ) ; } $ name = 'contao_frontend' ; if ( $ this -> scopeMatcher -> isBackendRequest ( $ request ) ) { $ name = 'contao_backend' ; } return $ session -> getBag ( $ name ) ; }
10134	public function positionImage ( $ col_start , $ row_start , $ x1 , $ y1 , $ width , $ height ) { $ col_end = $ col_start ; $ row_end = $ row_start ; if ( $ x1 >= Xls :: sizeCol ( $ this -> phpSheet , Coordinate :: stringFromColumnIndex ( $ col_start + 1 ) ) ) { $ x1 = 0 ; } if ( $ y1 >= Xls :: sizeRow ( $ this -> phpSheet , $ row_start + 1 ) ) { $ y1 = 0 ; } $ width = $ width + $ x1 - 1 ; $ height = $ height + $ y1 - 1 ; while ( $ width >= Xls :: sizeCol ( $ this -> phpSheet , Coordinate :: stringFromColumnIndex ( $ col_end + 1 ) ) ) { $ width -= Xls :: sizeCol ( $ this -> phpSheet , Coordinate :: stringFromColumnIndex ( $ col_end + 1 ) ) ; ++ $ col_end ; } while ( $ height >= Xls :: sizeRow ( $ this -> phpSheet , $ row_end + 1 ) ) { $ height -= Xls :: sizeRow ( $ this -> phpSheet , $ row_end + 1 ) ; ++ $ row_end ; } if ( Xls :: sizeCol ( $ this -> phpSheet , Coordinate :: stringFromColumnIndex ( $ col_start + 1 ) ) == 0 ) { return ; } if ( Xls :: sizeCol ( $ this -> phpSheet , Coordinate :: stringFromColumnIndex ( $ col_end + 1 ) ) == 0 ) { return ; } if ( Xls :: sizeRow ( $ this -> phpSheet , $ row_start + 1 ) == 0 ) { return ; } if ( Xls :: sizeRow ( $ this -> phpSheet , $ row_end + 1 ) == 0 ) { return ; } $ x1 = $ x1 / Xls :: sizeCol ( $ this -> phpSheet , Coordinate :: stringFromColumnIndex ( $ col_start + 1 ) ) * 1024 ; $ y1 = $ y1 / Xls :: sizeRow ( $ this -> phpSheet , $ row_start + 1 ) * 256 ; $ x2 = $ width / Xls :: sizeCol ( $ this -> phpSheet , Coordinate :: stringFromColumnIndex ( $ col_end + 1 ) ) * 1024 ; $ y2 = $ height / Xls :: sizeRow ( $ this -> phpSheet , $ row_end + 1 ) * 256 ; $ this -> writeObjPicture ( $ col_start , $ x1 , $ row_start , $ y1 , $ col_end , $ x2 , $ row_end , $ y2 ) ; }
8897	public function insert_many ( $ data , $ insert_individual = false ) { if ( $ insert_individual ) { return $ this -> _insert_individual ( $ data ) ; } return $ this -> _insert_batch ( $ data ) ; }
7164	private function buildSaleDiscountsLinesViews ( Model \ SaleInterface $ sale ) { if ( ! $ sale -> hasAdjustments ( Model \ AdjustmentTypes :: TYPE_DISCOUNT ) ) { return ; } foreach ( $ sale -> getAdjustments ( Model \ AdjustmentTypes :: TYPE_DISCOUNT ) as $ adjustment ) { $ this -> view -> addDiscount ( $ this -> buildDiscountLine ( $ adjustment ) ) ; } }
11190	public function getData ( ) { $ reference = new FluidXml ( false ) ; $ reference -> add ( $ this -> getTransactionReference ( ) ) ; return [ 'password' => $ this -> getPassword ( ) , 'userId' => $ this -> getUserId ( ) , 'merchantId' => $ this -> getMerchantId ( ) , 'transactionReference' => $ reference ] ; }
12193	public function onKernelException ( GetResponseForExceptionEvent $ event ) { $ exception = $ event -> getException ( ) ; if ( $ exception instanceof AuthenticationCredentialsNotFoundException ) { return new RedirectResponse ( "/login" ) ; } $ message = $ exception -> getMessage ( ) ; if ( $ exception instanceof NotFoundHttpException || $ exception instanceof PageNotPublishedException ) { $ this -> render404page ( $ event , $ message ) ; return ; } if ( ! $ exception instanceof RedKiteCmsExceptionInterface ) { DataLogger :: log ( $ message , DataLogger :: CRITICAL ) ; if ( $ this -> debug ) { return $ event ; } $ this -> setUpResponse ( $ event , $ message ) ; return ; } $ message = Utils :: translateException ( $ message , $ exception ) ; $ this -> setUpResponse ( $ event , $ message ) ; DataLogger :: log ( $ message , DataLogger :: ERROR ) ; }
914	public static function calculateBitmask ( array $ options ) { $ bitmask = 0 ; foreach ( $ options as $ optionName ) { if ( \ defined ( $ optionName ) ) { $ bitmask |= \ constant ( $ optionName ) ; } } return $ bitmask ; }
8822	public function rules ( Array $ rules ) { foreach ( $ rules as $ key => $ value ) { $ this -> rule ( $ key , $ value [ 'label' ] , $ value [ 'rules' ] , isset ( $ value [ 'text' ] ) && ! empty ( $ value [ 'text' ] ) ? $ value [ 'text' ] : [ ] ) ; } }
5658	private function addWidgetToForm ( $ node , $ form , $ enclosing_label ) { $ widget = $ this -> tags ( ) -> createTag ( $ node -> name , $ this -> attributes ( $ node ) ) ; if ( ! $ widget ) { return ; } $ widget -> setLabel ( $ enclosing_label ) -> addContent ( $ this -> innerHtml ( $ node ) ) ; if ( $ node -> name == 'select' ) { $ widget -> addTags ( $ this -> collectSelectOptions ( $ node ) ) ; } $ form -> addWidget ( $ widget ) ; $ this -> indexWidgetById ( $ widget ) ; }
12342	protected function printInfo ( $ msg , bool $ withTime = true , ? string $ fontColor = self :: FONT_COLOR_MAP [ 'lightGreen' ] , ? string $ bgColor = null ) : void { $ this -> print ( $ this -> getColoredMsg ( $ msg , $ fontColor , $ bgColor ) , $ withTime ) ; }
6326	public static function getClassNameWithoutNamespace ( $ object ) { $ className = get_class ( $ object ) ; if ( preg_match ( '@\\\\([\w]+)$@' , $ className , $ matches ) ) { $ className = $ matches [ 1 ] ; } return $ className ; }
7305	protected function scheduleParentChangeEvents ( CustomerInterface $ customer ) { if ( ! $ customer -> hasChildren ( ) ) { return ; } foreach ( $ customer -> getChildren ( ) as $ child ) { $ this -> persistenceHelper -> scheduleEvent ( CustomerEvents :: PARENT_CHANGE , $ child ) ; } }
12468	public function getStream ( $ mediaId ) { $ response = $ this -> getHttp ( ) -> get ( self :: API_GET , [ 'media_id' => $ mediaId ] ) ; $ response -> getBody ( ) -> rewind ( ) ; $ body = $ response -> getBody ( ) -> getContents ( ) ; $ json = json_decode ( $ body , true ) ; if ( JSON_ERROR_NONE === json_last_error ( ) ) { $ this -> checkAndThrow ( $ json ) ; } return $ body ; }
7368	protected function checkShipmentIntegrity ( SaleItemInterface $ item , SaleItem $ constraint ) { $ sale = $ item -> getSale ( ) ; if ( ! $ sale instanceof Shipment \ ShipmentSubjectInterface ) { return ; } if ( empty ( $ sale -> getShipments ( ) -> toArray ( ) ) ) { return ; } $ min = $ this -> shipmentCalculator -> calculateShippedQuantity ( $ item ) ; if ( 1 === bccomp ( $ min , 0 , 3 ) && 1 === bccomp ( $ min , $ item -> getTotalQuantity ( ) , 3 ) ) { $ this -> context -> buildViolation ( $ constraint -> quantity_is_lower_than_shipped , [ '%min%' => $ min , ] ) -> setInvalidValue ( $ item -> getQuantity ( ) ) -> atPath ( 'quantity' ) -> addViolation ( ) ; throw new ValidationFailedException ( ) ; } }
9076	public function addTag ( $ name , array $ attributes = array ( ) ) { foreach ( $ this -> rules as $ rule ) { $ rule -> addTag ( $ name , $ attributes ) ; } }
5479	protected function addRadioButton ( $ tag ) { if ( ! isset ( $ this -> radios [ $ tag -> getName ( ) ] ) ) { $ this -> widgets [ ] = new SimpleRadioGroup ( ) ; $ this -> radios [ $ tag -> getName ( ) ] = count ( $ this -> widgets ) - 1 ; } $ this -> widgets [ $ this -> radios [ $ tag -> getName ( ) ] ] -> addWidget ( $ tag ) ; }
5555	public function getUrls ( ) { if ( is_integer ( $ this -> focus ) ) { return $ this -> frames [ $ this -> focus ] -> getUrls ( ) ; } $ urls = array ( ) ; foreach ( $ this -> frames as $ frame ) { $ urls = array_merge ( $ urls , $ frame -> getUrls ( ) ) ; } return array_values ( array_unique ( $ urls ) ) ; }
5541	public function setFrameFocus ( $ name ) { if ( is_integer ( $ this -> focus ) ) { if ( $ this -> frames [ $ this -> focus ] -> hasFrames ( ) ) { return $ this -> frames [ $ this -> focus ] -> setFrameFocus ( $ name ) ; } } if ( in_array ( $ name , array_keys ( $ this -> names ) ) ) { $ this -> focus = $ this -> names [ $ name ] ; return true ; } return false ; }
1844	public function generateFeedsByCalendar ( $ intId ) { $ objFeed = CalendarFeedModel :: findByCalendar ( $ intId ) ; if ( $ objFeed !== null ) { while ( $ objFeed -> next ( ) ) { $ objFeed -> feedName = $ objFeed -> alias ? : 'calendar' . $ objFeed -> id ; $ this -> generateFiles ( $ objFeed -> row ( ) ) ; $ this -> log ( 'Generated calendar feed "' . $ objFeed -> feedName . '.xml"' , __METHOD__ , TL_CRON ) ; } } }
7528	static function minify_javascript ( & $ root , $ indent_string = ' ' , $ wrap_comment = true , $ recursive = true ) { include_once ( 'third party/jsminplus.php' ) ; $ errors = array ( ) ; foreach ( $ root -> select ( 'script:not-empty > "~text~"' , false , $ recursive , true ) as $ c ) { try { $ text = $ c -> text ; while ( $ text ) { $ text = trim ( $ text ) ; if ( substr ( $ text , 0 , 4 ) === '<!--' ) { $ text = substr ( $ text , 5 ) ; continue ; } elseif ( strtolower ( substr ( $ text , 0 , 9 ) ) === '<![cdata[' ) { $ text = substr ( $ text , 10 ) ; continue ; } if ( ( $ end = substr ( $ text , - 3 ) ) && ( ( $ end === ' ) || ( $ end === ']]>' ) ) ) { $ text = substr ( $ text , 0 , - 3 ) ; continue ; } break ; } if ( trim ( $ text ) ) { $ text = \ JSMinPlus :: minify ( $ text ) ; if ( $ wrap_comment ) { $ text = "<!--\n" . $ text . "\n// ; } if ( $ indent_string && ( $ wrap_comment || ( strpos ( $ text , "\n" ) !== false ) ) ) { $ text = indent_text ( "\n" . $ text , $ c -> indent ( ) , $ indent_string ) ; } } $ c -> text = $ text ; } catch ( \ Exception $ e ) { $ errors [ ] = array ( $ e , $ c -> parent -> dumpLocation ( ) ) ; } } return ( ( $ errors ) ? $ errors : true ) ; }
10289	protected function executeTasks ( array $ tasks ) { foreach ( $ tasks as $ scheduled => $ taskList ) { foreach ( $ taskList as $ cronjob ) { if ( ( $ task = $ this -> taskFactory -> factory ( $ cronjob -> task , $ scheduled , $ this -> logger ) ) !== false ) { $ this -> logger -> setTask ( $ task -> getId ( ) ) ; $ this -> logger -> log ( 'Start task execution.' ) ; $ status = $ task -> execute ( ) ; switch ( $ status ) { case Executor :: SUCCESS : $ this -> logger -> log ( 'Finished task execution.' ) ; break ; case Executor :: ERROR : $ this -> logger -> log ( 'Error occured during task execution.' , Logger :: WARNING ) ; break ; case Executor :: RESCHEDULE : $ this -> logger -> log ( 'Task will be rescheduled for ' . $ task -> reScheduleTime . ' seconds.' ) ; $ this -> rescheduled [ $ scheduled + $ task -> reScheduleTime ] = $ cronjob ; break ; default : $ this -> logger -> log ( 'Invalid status returned by task.' , Logger :: ERROR ) ; break ; } $ this -> logger -> setTask ( ) ; } } } }
7758	protected function loadMappingInformation ( array $ config , ContainerBuilder $ container ) { $ this -> drivers = array ( ) ; if ( $ config [ 'auto_mapping' ] ) { foreach ( array_keys ( $ container -> getParameter ( 'kernel.bundles' ) ) as $ bundle ) { if ( ! isset ( $ config [ 'mappings' ] [ $ bundle ] ) ) { $ config [ 'mappings' ] [ $ bundle ] = array ( 'mapping' => true , 'is_bundle' => true , ) ; } } } $ container -> setAlias ( 'hydra.naming_strategy' , new Alias ( $ config [ 'naming_strategy' ] , false ) ) ; foreach ( $ config [ 'mappings' ] as $ mappingName => $ mappingConfig ) { if ( null !== $ mappingConfig && false === $ mappingConfig [ 'mapping' ] ) { continue ; } $ mappingConfig = array_replace ( array ( 'dir' => false , 'type' => false , 'prefix' => false , ) , ( array ) $ mappingConfig ) ; $ mappingConfig [ 'dir' ] = $ container -> getParameterBag ( ) -> resolveValue ( $ mappingConfig [ 'dir' ] ) ; if ( ! isset ( $ mappingConfig [ 'is_bundle' ] ) ) { $ mappingConfig [ 'is_bundle' ] = ! is_dir ( $ mappingConfig [ 'dir' ] ) ; } if ( $ mappingConfig [ 'is_bundle' ] ) { $ bundle = null ; foreach ( $ container -> getParameter ( 'kernel.bundles' ) as $ name => $ class ) { if ( $ mappingName === $ name ) { $ bundle = new \ ReflectionClass ( $ class ) ; break ; } } if ( null === $ bundle ) { throw new \ InvalidArgumentException ( sprintf ( 'Bundle "%s" does not exist or it is not enabled.' , $ mappingName ) ) ; } $ mappingConfig = $ this -> getMappingDriverBundleConfigDefaults ( $ mappingConfig , $ bundle , $ container ) ; if ( ! $ mappingConfig ) { continue ; } } $ this -> validateMappingConfiguration ( $ mappingConfig , $ mappingName ) ; $ this -> setMappingDriverConfig ( $ mappingConfig , $ mappingName ) ; } $ this -> registerMappingDrivers ( $ config , $ container ) ; }
1755	public static function getTimeZones ( ) { $ arrReturn = array ( ) ; $ timezones = array ( ) ; require __DIR__ . '/../../config/timezones.php' ; foreach ( $ timezones as $ strGroup => $ arrTimezones ) { foreach ( $ arrTimezones as $ strTimezone ) { $ arrReturn [ $ strGroup ] [ ] = $ strTimezone ; } } return $ arrReturn ; }
11350	public function getData ( ) { $ data = [ ] ; foreach ( $ this -> fields as $ field ) { if ( preg_match ( '/^(.*?)(\[.*\])$/' , $ field -> getName ( ) , $ result ) ) { if ( $ result [ 2 ] == '' ) { } else { if ( ! preg_match_all ( "/\[(.*?)\]/" , $ result [ 2 ] , $ resultDeep ) ) { throw new \ Exception ( 'Invalid field name.' ) ; } $ storage = & $ data [ $ result [ 1 ] ] ; foreach ( $ resultDeep [ 1 ] as $ deep ) { if ( ! isset ( $ storage [ $ deep ] ) ) { $ storage [ $ deep ] = [ ] ; } $ storage = & $ storage [ $ deep ] ; } $ storage = $ field -> getData ( ) ; } } else { $ data [ $ field -> getName ( ) ] = $ field -> getData ( ) ; } } return $ this -> transformer -> decode ( $ data ) ; }
2709	public function beforeSave ( \ Magento \ Config \ Model \ Config $ subject ) { $ data = $ subject -> getData ( ) ; if ( ! empty ( $ data [ 'groups' ] [ 'full_page_cache' ] [ 'fields' ] [ 'caching_application' ] [ 'value' ] ) ) { $ currentCacheConfig = $ data [ 'groups' ] [ 'full_page_cache' ] [ 'fields' ] [ 'caching_application' ] [ 'value' ] ; $ oldCacheConfig = $ this -> scopeConfig -> getValue ( \ Magento \ PageCache \ Model \ Config :: XML_PAGECACHE_TYPE ) ; if ( $ oldCacheConfig == \ Fastly \ Cdn \ Model \ Config :: FASTLY && $ currentCacheConfig != $ oldCacheConfig ) { $ this -> purge = true ; } } }
12855	function goWait ( $ maxExecution = null ) { $ jobExecution = 0 ; $ sleep = 0 ; while ( 1 ) { if ( 0 == $ executed = $ this -> goUntilEmpty ( ) ) { $ sleep += 100000 ; usleep ( $ sleep ) ; if ( $ sleep > 2 * 1000000 ) $ sleep = 100000 ; continue ; } $ jobExecution += $ executed ; if ( $ jobExecution >= $ maxExecution ) break ; if ( $ sleep = $ this -> getSleep ( ) ) usleep ( $ sleep ) ; $ sleep = 0 ; } }
7377	public function fetchFloat ( string $ key , float $ default = 0.0 , int $ precision = 2 ) : float { return round ( floatval ( $ this -> fetch ( $ key , $ default ) ) , $ precision ) ; }
513	public function actionUp ( $ limit = 0 ) { $ migrations = $ this -> getNewMigrations ( ) ; if ( empty ( $ migrations ) ) { $ this -> stdout ( "No new migrations found. Your system is up-to-date.\n" , Console :: FG_GREEN ) ; return ExitCode :: OK ; } $ total = count ( $ migrations ) ; $ limit = ( int ) $ limit ; if ( $ limit > 0 ) { $ migrations = array_slice ( $ migrations , 0 , $ limit ) ; } $ n = count ( $ migrations ) ; if ( $ n === $ total ) { $ this -> stdout ( "Total $n new " . ( $ n === 1 ? 'migration' : 'migrations' ) . " to be applied:\n" , Console :: FG_YELLOW ) ; } else { $ this -> stdout ( "Total $n out of $total new " . ( $ total === 1 ? 'migration' : 'migrations' ) . " to be applied:\n" , Console :: FG_YELLOW ) ; } foreach ( $ migrations as $ migration ) { $ nameLimit = $ this -> getMigrationNameLimit ( ) ; if ( $ nameLimit !== null && strlen ( $ migration ) > $ nameLimit ) { $ this -> stdout ( "\nThe migration name '$migration' is too long. Its not possible to apply this migration.\n" , Console :: FG_RED ) ; return ExitCode :: UNSPECIFIED_ERROR ; } $ this -> stdout ( "\t$migration\n" ) ; } $ this -> stdout ( "\n" ) ; $ applied = 0 ; if ( $ this -> confirm ( 'Apply the above ' . ( $ n === 1 ? 'migration' : 'migrations' ) . '?' ) ) { foreach ( $ migrations as $ migration ) { if ( ! $ this -> migrateUp ( $ migration ) ) { $ this -> stdout ( "\n$applied from $n " . ( $ applied === 1 ? 'migration was' : 'migrations were' ) . " applied.\n" , Console :: FG_RED ) ; $ this -> stdout ( "\nMigration failed. The rest of the migrations are canceled.\n" , Console :: FG_RED ) ; return ExitCode :: UNSPECIFIED_ERROR ; } $ applied ++ ; } $ this -> stdout ( "\n$n " . ( $ n === 1 ? 'migration was' : 'migrations were' ) . " applied.\n" , Console :: FG_GREEN ) ; $ this -> stdout ( "\nMigrated up successfully.\n" , Console :: FG_GREEN ) ; } }
6131	protected function getSuffixIconServer ( ) { $ html = "" ; if ( $ this -> currObj [ "virtualserver_icon_id" ] ) { if ( ! $ this -> currObj -> iconIsLocal ( "virtualserver_icon_id" ) && $ this -> ftclient ) { if ( ! isset ( $ this -> cacheIcon [ $ this -> currObj [ "virtualserver_icon_id" ] ] ) ) { $ download = $ this -> currObj -> transferInitDownload ( rand ( 0x0000 , 0xFFFF ) , 0 , $ this -> currObj -> iconGetName ( "virtualserver_icon_id" ) ) ; if ( $ this -> ftclient == "data:image" ) { $ download = TeamSpeak3 :: factory ( "filetransfer://" . $ download [ "host" ] . ":" . $ download [ "port" ] ) -> download ( $ download [ "ftkey" ] , $ download [ "size" ] ) ; } $ this -> cacheIcon [ $ this -> currObj [ "virtualserver_icon_id" ] ] = $ download ; } else { $ download = $ this -> cacheIcon [ $ this -> currObj [ "virtualserver_icon_id" ] ] ; } if ( $ this -> ftclient == "data:image" ) { $ html .= $ this -> getImage ( "data:" . Convert :: imageMimeType ( $ download ) . ";base64," . base64_encode ( $ download ) , "Server Icon" , null , false ) ; } else { $ html .= $ this -> getImage ( $ this -> ftclient . "?ftdata=" . base64_encode ( serialize ( $ download ) ) , "Server Icon" , null , false ) ; } } elseif ( in_array ( $ this -> currObj [ "virtualserver_icon_id" ] , $ this -> cachedIcons ) ) { $ html .= $ this -> getImage ( "group_icon_" . $ this -> currObj [ "virtualserver_icon_id" ] . ".png" , "Server Icon" ) ; } } return $ html ; }
463	public function buildAndCondition ( $ operator , $ operands , & $ params ) { array_unshift ( $ operands , $ operator ) ; return $ this -> buildCondition ( $ operands , $ params ) ; }
10616	protected function setLifetime ( Response $ response , $ lifetime ) { if ( $ lifetime >= 0 ) { $ date = clone $ response -> getDate ( ) ; $ response -> setMaxAge ( $ lifetime ) -> setExpires ( $ date -> modify ( sprintf ( '+%s seconds' , $ lifetime ) ) ) ; if ( ! $ response -> headers -> hasCacheControlDirective ( 'private' ) ) { $ response -> setPublic ( ) -> setSharedMaxAge ( $ lifetime ) ; } } return $ this ; }
4378	protected function buildTableRow ( $ row , $ keys , $ rowKey ) { $ str = '' ; $ values = $ this -> debug -> methodTable -> keyValues ( $ row , $ keys , $ objInfo ) ; $ parsed = $ this -> debug -> utilities -> parseTag ( $ this -> dump ( $ rowKey ) ) ; $ str .= '<tr>' ; $ str .= $ this -> debug -> utilities -> buildTag ( 'th' , array ( 'class' => 't_key text-right ' . $ parsed [ 'attribs' ] [ 'class' ] , 'scope' => 'row' , ) , $ parsed [ 'innerhtml' ] ) ; if ( $ objInfo [ 'row' ] ) { $ str .= $ this -> markupClassname ( $ objInfo [ 'row' ] [ 'className' ] , 'td' , array ( 'title' => $ objInfo [ 'row' ] [ 'phpDoc' ] [ 'summary' ] ? : null , ) ) ; $ this -> tableInfo [ 'haveObjRow' ] = true ; } else { $ str .= '<td class="t_classname"></td>' ; } foreach ( $ values as $ v ) { $ str .= $ this -> dump ( $ v , true , 'td' ) ; } $ str .= '</tr>' . "\n" ; $ str = \ str_replace ( ' title=""' , '' , $ str ) ; foreach ( \ array_keys ( $ this -> tableInfo [ 'totals' ] ) as $ k ) { $ this -> tableInfo [ 'totals' ] [ $ k ] += $ values [ $ k ] ; } foreach ( $ objInfo [ 'cols' ] as $ k2 => $ classname ) { if ( $ this -> tableInfo [ 'colClasses' ] [ $ k2 ] === false ) { continue ; } if ( $ this -> tableInfo [ 'colClasses' ] [ $ k2 ] === null ) { $ this -> tableInfo [ 'colClasses' ] [ $ k2 ] = $ classname ; } if ( $ this -> tableInfo [ 'colClasses' ] [ $ k2 ] !== $ classname ) { $ this -> tableInfo [ 'colClasses' ] [ $ k2 ] = false ; } } return $ str ; }
8530	private function _convertListFinancialEvents ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'ListFinancialEvents' ; if ( $ request -> isSetSellerId ( ) ) { $ parameters [ 'SellerId' ] = $ request -> getSellerId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } if ( $ request -> isSetMaxResultsPerPage ( ) ) { $ parameters [ 'MaxResultsPerPage' ] = $ request -> getMaxResultsPerPage ( ) ; } if ( $ request -> isSetAmazonOrderId ( ) ) { $ parameters [ 'AmazonOrderId' ] = $ request -> getAmazonOrderId ( ) ; } if ( $ request -> isSetFinancialEventGroupId ( ) ) { $ parameters [ 'FinancialEventGroupId' ] = $ request -> getFinancialEventGroupId ( ) ; } if ( $ request -> isSetPostedAfter ( ) ) { $ parameters [ 'PostedAfter' ] = $ request -> getPostedAfter ( ) ; } if ( $ request -> isSetPostedBefore ( ) ) { $ parameters [ 'PostedBefore' ] = $ request -> getPostedBefore ( ) ; } return $ parameters ; }
2720	public function execute ( ) { $ resultLayout = null ; try { $ resultLayout = $ this -> resultLayoutFactory -> create ( ) ; $ resultLayout -> addDefaultHandle ( ) ; $ countryCode = $ this -> getRequest ( ) -> getParam ( self :: REQUEST_PARAM_COUNTRY ) ; $ storeId = $ this -> config -> getGeoIpMappingForCountry ( $ countryCode ) ; if ( $ storeId !== null ) { $ redirectUrl = null ; $ targetStore = $ this -> storeRepository -> getActiveStoreById ( $ storeId ) ; $ currentStore = $ this -> storeManager -> getStore ( ) ; if ( $ currentStore -> getId ( ) != $ targetStore -> getId ( ) ) { $ this -> url -> setScope ( $ targetStore -> getId ( ) ) ; $ this -> url -> addQueryParams ( [ ' store' => $ targetStore -> getCode ( ) , ' from_store' => $ currentStore -> getCode ( ) ] ) ; $ redirectUrl = $ this -> url -> getUrl ( 'stores/store/switch' ) ; } if ( $ redirectUrl ) { switch ( $ this -> config -> getGeoIpAction ( ) ) { case Config :: GEOIP_ACTION_DIALOG : $ resultLayout -> getLayout ( ) -> getUpdate ( ) -> load ( [ 'geoip_getaction_dialog' ] ) ; $ resultLayout -> getLayout ( ) -> getBlock ( 'geoip_getaction' ) -> setMessage ( $ this -> getMessageInStoreLocale ( $ targetStore ) ) ; break ; case Config :: GEOIP_ACTION_REDIRECT : $ resultLayout -> getLayout ( ) -> getUpdate ( ) -> load ( [ 'geoip_getaction_redirect' ] ) ; break ; } $ resultLayout -> getLayout ( ) -> getBlock ( 'geoip_getaction' ) -> setRedirectUrl ( $ redirectUrl ) ; } } } catch ( \ Exception $ e ) { $ this -> logger -> critical ( $ e -> getMessage ( ) ) ; } $ resultLayout -> setHeader ( "x-esi" , "1" ) ; return $ resultLayout ; }
6778	protected function updateVatDisplayMode ( SaleInterface $ sale ) { if ( $ sale -> hasPayments ( ) ) { return false ; } $ mode = null ; if ( null !== $ group = $ sale -> getCustomerGroup ( ) ) { $ mode = $ group -> getVatDisplayMode ( ) ; } if ( null === $ mode ) { $ mode = $ this -> defaultVatDisplayMode ; } if ( $ mode !== $ sale -> getVatDisplayMode ( ) ) { $ sale -> setVatDisplayMode ( $ mode ) ; return true ; } return false ; }
12763	public function remove ( $ name , $ path = null , $ domain = null , $ secure = false , $ httpOnly = false ) { if ( $ this -> exists ( $ name ) ) { $ expire = time ( ) - ( 3600 * 24 * 365 ) ; $ this -> set ( $ name , '' , $ expire , $ path , $ domain , $ secure , $ httpOnly ) ; } }
1165	protected function parseAttributeName ( $ data ) { parse_str ( $ data , $ attrParts ) ; $ attrParts = is_null ( $ attrParts ) ? [ ] : $ attrParts ; $ newAttr = array_keys ( array_dot ( $ attrParts ) ) ; return array_pop ( $ newAttr ) ; }
8045	public static function select ( array $ readSockets = array ( ) , array $ writeSockets = array ( ) , array $ exceptSockets = array ( ) , $ sec = 0 , $ usec = 0 ) { $ out = array ( ) ; $ out [ 'read' ] = array ( ) ; $ out [ 'write' ] = array ( ) ; $ out [ 'except' ] = array ( ) ; if ( count ( $ readSockets ) === 0 ) { return $ out ; } $ readSocketsResources = array ( ) ; $ writeSocketsResources = array ( ) ; $ exceptSocketsResources = array ( ) ; $ readSockets = self :: createSocketsIndex ( $ readSockets , $ readSocketsResources ) ; $ writeSockets = self :: createSocketsIndex ( $ writeSockets , $ writeSocketsResources ) ; $ exceptSockets = self :: createSocketsIndex ( $ exceptSockets , $ exceptSocketsResources ) ; $ socketsSelected = @ socket_select ( $ readSocketsResources , $ writeSocketsResources , $ exceptSocketsResources , $ sec , $ usec ) ; if ( $ socketsSelected === FALSE ) { $ socketError = socket_last_error ( ) ; if ( $ socketError === SOCKET_EINTR ) { socket_clear_error ( ) ; $ socketsSelected = socket_select ( $ readSocketsResources , $ writeSocketsResources , $ exceptSocketsResources , $ sec , $ usec ) ; if ( $ socketsSelected === FALSE ) { return $ out ; } } else { trigger_error ( sprintf ( 'socket_select(): unable to select [%d]: %s' , $ socketError , socket_strerror ( $ socketError ) ) , E_USER_WARNING ) ; return $ out ; } } foreach ( $ readSocketsResources as $ socketResource ) { $ out [ 'read' ] [ ] = $ readSockets [ intval ( $ socketResource ) ] ; } foreach ( $ writeSocketsResources as $ socketResource ) { $ out [ 'write' ] [ ] = $ writeSockets [ intval ( $ socketResource ) ] ; } foreach ( $ exceptSocketsResources as $ socketResource ) { $ out [ 'except' ] [ ] = $ exceptSockets [ intval ( $ socketResource ) ] ; } return $ out ; }
4529	public function kernelRequest ( GetResponseEvent $ event ) { $ request = $ event -> getRequest ( ) ; $ content = $ request -> getContent ( ) ; if ( '' === $ content ) { return ; } try { $ filters = json_decode ( $ content , true ) ; } catch ( Exception $ exception ) { throw new BadRequestHttpException ( 'Request body should be an object.' , $ exception ) ; } if ( ! is_array ( $ filters ) ) { throw new BadRequestHttpException ( 'Request body should be an object.' ) ; } $ current = $ request -> attributes -> get ( '_api_filters' , [ ] ) ; $ query = $ request -> query -> all ( ) ; $ filters = array_merge ( $ current , $ query , $ filters ) ; $ request -> attributes -> set ( '_api_filters' , $ filters ) ; }
804	private function hasReturnTypeHint ( Tokens $ tokens , $ index ) { $ endFuncIndex = $ tokens -> getPrevTokenOfKind ( $ index , [ ')' ] ) ; $ nextIndex = $ tokens -> getNextMeaningfulToken ( $ endFuncIndex ) ; return $ tokens [ $ nextIndex ] -> isGivenKind ( CT :: T_TYPE_COLON ) ; }
10344	protected function extractStep ( $ definition ) { if ( ( $ position = strpos ( $ definition , '/' ) ) !== false ) { return ( int ) substr ( $ definition , $ position + 1 ) ; } return false ; }
11349	public function setData ( $ data ) { $ data = $ this -> transformer -> encode ( $ data ) ; foreach ( $ this -> fields as $ field ) { if ( isset ( $ data [ $ field -> getName ( ) ] ) ) { $ field -> setData ( $ data [ $ field -> getName ( ) ] ) ; } } }
11181	public function getActions ( ) { $ result = $ this -> get ( Keys :: EXT_ACTION ) ; if ( is_string ( $ result ) ) { return unserialize ( $ result ) ; } return array ( ) ; }
10066	public function actionGenerate ( ) { $ input = $ this -> parseArguments ( func_get_args ( ) ) ; $ container = new Container ( ) ; $ container -> set ( GeneratorInterface :: class , array_merge ( [ 'class' => $ this -> generator_fqn ] , $ input [ 'generator' ] ) ) ; $ container -> set ( DbProviderInterface :: class , array_merge ( [ 'class' => $ this -> dbprovider_fqn ] , $ input [ 'dbprovider' ] ) ) ; $ this -> generator_obj = $ container -> get ( GeneratorInterface :: class ) ; if ( ! $ this -> force && ! $ this -> confirmGeneration ( ) ) { return ; } $ this -> dbprovider_obj = $ container -> get ( DbProviderInterface :: class ) ; Console :: startProgress ( 0 , $ this -> count ) ; foreach ( $ this -> dbprovider_obj -> export ( $ this -> count ) as $ count ) { Console :: updateProgress ( $ this -> count - $ count , $ this -> count ) ; } Console :: endProgress ( true ) ; }
7078	static public function isSaleSupportsDocumentType ( SaleInterface $ sale , $ type ) { if ( ! DocumentTypes :: isValidType ( $ type ) ) { return false ; } if ( empty ( $ classes = DocumentTypes :: getClasses ( $ type ) ) ) { return false ; } foreach ( $ classes as $ class ) { if ( is_subclass_of ( $ sale , $ class ) ) { return true ; } } return false ; }
5123	private function getAttachmentEndPoint ( string $ idArticle , string $ field ) : string { return $ this -> replaceEndPointId ( $ idArticle , $ this -> attachmentUrl [ $ field ] ) ; }
2833	protected function _initQuery ( ) { $ token = $ this -> getRequest ( ) -> getParam ( 'token' ) ; $ index = $ this -> getRequest ( ) -> getParam ( 'index' ) ; if ( $ token === null || $ index === null ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 400 ) -> setBody ( 'Invalid parameters' ) ; return null ; } $ requestProfile = Mage :: getModel ( 'sheep_debug/requestInfo' ) -> load ( $ token , 'token' ) ; if ( ! $ requestProfile -> getId ( ) ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 404 ) -> setBody ( 'Request profile not found' ) ; return null ; } $ queries = $ requestProfile -> getQueries ( ) ; if ( ! $ queries || ! ( $ index < count ( $ queries ) ) ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 404 ) -> setBody ( 'Query not found' ) ; return null ; } return $ queries [ ( int ) $ index ] ; }
1977	public function onPreviewUrlCreate ( PreviewUrlCreateEvent $ event ) : void { if ( ! $ this -> framework -> isInitialized ( ) || 'news' !== $ event -> getKey ( ) ) { return ; } $ request = $ this -> requestStack -> getCurrentRequest ( ) ; if ( null === $ request ) { throw new \ RuntimeException ( 'The request stack did not contain a request' ) ; } if ( 'tl_news' === $ request -> query -> get ( 'table' ) && ! $ request -> query -> has ( 'act' ) ) { return ; } if ( null === ( $ newsModel = $ this -> getNewsModel ( $ this -> getId ( $ event , $ request ) ) ) ) { return ; } $ event -> setQuery ( 'news=' . $ newsModel -> id ) ; }
6788	protected function getCustomerGroupFromEvent ( ResourceEventInterface $ event ) { $ resource = $ event -> getResource ( ) ; if ( ! $ resource instanceof CustomerGroupInterface ) { throw new InvalidArgumentException ( 'Expected instance of ' . CustomerGroupInterface :: class ) ; } return $ resource ; }
2057	public function checkRootType ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ varValue != 'root' && $ dc -> activeRecord -> pid == 0 ) { throw new Exception ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'topLevelRoot' ] ) ; } return $ varValue ; }
2458	public function undo ( ) { $ objRecords = $ this -> Database -> prepare ( "SELECT * FROM " . $ this -> strTable . " WHERE id=?" ) -> limit ( 1 ) -> execute ( $ this -> intId ) ; if ( $ objRecords -> numRows < 1 ) { $ this -> redirect ( $ this -> getReferer ( ) ) ; } $ error = false ; $ query = $ objRecords -> query ; $ data = StringUtil :: deserialize ( $ objRecords -> data ) ; if ( ! \ is_array ( $ data ) ) { $ this -> redirect ( $ this -> getReferer ( ) ) ; } $ arrFields = array ( ) ; foreach ( $ data as $ table => $ fields ) { $ this -> loadDataContainer ( $ table ) ; if ( ! isset ( $ arrFields [ $ table ] ) ) { $ arrFields [ $ table ] = array_flip ( $ this -> Database -> getFieldNames ( $ table ) ) ; } foreach ( $ fields as $ row ) { $ row = array_intersect_key ( $ row , $ arrFields [ $ table ] ) ; $ objInsertStmt = $ this -> Database -> prepare ( "INSERT INTO " . $ table . " %s" ) -> set ( $ row ) -> execute ( ) ; if ( $ objInsertStmt -> affectedRows < 1 ) { $ error = true ; } if ( \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ table ] [ 'config' ] [ 'onundo_callback' ] ) ) { foreach ( $ GLOBALS [ 'TL_DCA' ] [ $ table ] [ 'config' ] [ 'onundo_callback' ] as $ callback ) { if ( \ is_array ( $ callback ) ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ table , $ row , $ this ) ; } elseif ( \ is_callable ( $ callback ) ) { $ callback ( $ table , $ row , $ this ) ; } } } } } if ( ! $ error ) { $ this -> log ( 'Undone ' . $ query , __METHOD__ , TL_GENERAL ) ; $ this -> Database -> prepare ( "DELETE FROM " . $ this -> strTable . " WHERE id=?" ) -> limit ( 1 ) -> execute ( $ this -> intId ) ; } $ this -> redirect ( $ this -> getReferer ( ) ) ; }
8800	public function needsRehash ( $ hashedValue , array $ options = [ ] ) { return password_needs_rehash ( $ hashedValue , PASSWORD_ARGON2I , [ 'memory_cost' => $ this -> memory ( $ options ) , 'time_cost' => $ this -> time ( $ options ) , 'threads' => $ this -> threads ( $ options ) , ] ) ; }
6962	public static function B ( $ year ) { $ jd = static :: B1900 ( ) -> jd + ( $ year - 1900 ) * static :: DaysBesselianYear ; $ epoch = new static ( $ jd ) ; $ epoch -> type = YearType :: Besselian ( ) ; return $ epoch ; }
23	public function removePackage ( PackageInterface $ package ) { $ packageId = $ package -> getUniqueName ( ) ; foreach ( $ this -> getPackages ( ) as $ key => $ repoPackage ) { if ( $ packageId === $ repoPackage -> getUniqueName ( ) ) { array_splice ( $ this -> packages , $ key , 1 ) ; return ; } } }
11965	public static function hash ( $ password ) { return \ Yii :: $ app -> security -> generatePasswordHash ( $ password , \ Yii :: $ app -> getModule ( 'user' ) -> cost ) ; }
7842	public function handle ( $ job , Closure $ next ) { $ this -> callBefore ( $ job ) ; $ handled = $ next ( $ job ) ; $ this -> callAfter ( $ handled , $ job ) ; return $ handled ; }
5532	protected function createCodeForOverridenMethods ( $ methods ) { $ code = '' ; foreach ( $ methods as $ method ) { if ( $ this -> isConstructorOrDeconstructor ( $ method ) ) { continue ; } $ code .= ' ' . $ this -> reflection -> getSignature ( $ method ) . " {\n" ; $ code .= " return \$this->mock->invoke(\"$method\", func_get_args());\n" ; $ code .= " }\n" ; } return $ code ; }
11609	public function actionDisconnect ( $ id ) { $ account = $ this -> finder -> findAccountById ( $ id ) ; if ( $ account === null ) { throw new NotFoundHttpException ; } if ( $ account -> user_id != \ Yii :: $ app -> user -> id ) { throw new ForbiddenHttpException ; } $ account -> delete ( ) ; return $ this -> redirect ( [ 'networks' ] ) ; }
4383	protected function buildArgString ( $ args ) { $ numArgs = \ count ( $ args ) ; if ( $ numArgs == 1 && \ is_string ( $ args [ 0 ] ) ) { $ args [ 0 ] = \ strip_tags ( $ args [ 0 ] ) ; } foreach ( $ args as $ k => $ v ) { if ( $ k > 0 || ! \ is_string ( $ v ) ) { $ args [ $ k ] = $ this -> dump ( $ v ) ; } $ this -> valDepth = 0 ; } $ glue = ', ' ; $ glueAfterFirst = true ; if ( $ numArgs && \ is_string ( $ args [ 0 ] ) ) { if ( \ preg_match ( '/[=:] ?$/' , $ args [ 0 ] ) ) { $ glueAfterFirst = false ; } elseif ( \ count ( $ args ) == 2 ) { $ glue = ' = ' ; } } if ( ! $ glueAfterFirst ) { return $ args [ 0 ] . \ implode ( $ glue , \ array_slice ( $ args , 1 ) ) ; } else { return \ implode ( $ glue , $ args ) ; } }
11541	public function editProfile ( $ data ) { if ( ! ( $ user = $ this -> hydrate ( $ data , $ this -> getEditProfileForm ( ) ) ) ) { return ; } $ eventManager = $ this -> getEventManager ( ) ; $ eventManager -> trigger ( __FUNCTION__ , $ this , compact ( 'user' ) ) ; $ this -> getMapper ( ) -> update ( $ user ) -> save ( ) ; $ eventManager -> trigger ( __FUNCTION__ . '.post' , $ this , compact ( 'user' ) ) ; return $ user ; }
12393	public function onSiteSaved ( SiteSavedEvent $ event ) { $ fs = new Filesystem ( ) ; $ fs -> mirror ( $ this -> configurationHandler -> uploadAssetsDir ( ) , $ this -> configurationHandler -> uploadAssetsDirProduction ( ) ) ; }
12241	public function addClass ( $ class ) { if ( ! $ this -> hasClass ( $ class ) ) { $ current = ( string ) $ this [ 'class' ] ; if ( $ current !== '' && substr ( $ current , - 1 ) !== ' ' ) { $ this [ 'class' ] .= ' ' ; } $ this [ 'class' ] .= $ class ; } return $ this ; }
8322	public function getLoad ( $ paramsList = [ 'waiting' , 'load' , 'minbid' , 'averageRecognitionTime' ] ) { $ parser = $ this -> getLoadXml ( ) ; if ( is_string ( $ paramsList ) ) { return $ parser -> $ paramsList -> __toString ( ) ; } $ statusData = [ ] ; foreach ( $ paramsList as $ item ) { $ statusData [ $ item ] = $ parser -> $ item -> __toString ( ) ; } return $ statusData ; }
6964	protected function getYear ( ) { $ year = 0 ; if ( $ this -> type == YearType :: Besselian ( ) ) $ year = 1900 + ( $ this -> jd - Epoch :: B1900 ( ) -> jd ) / static :: DaysBesselianYear ; else $ year = 2000 + ( $ this -> jd - Epoch :: J2000 ( ) -> jd ) / static :: DaysJulianYear ; return round ( $ year , 6 ) ; }
11687	public function getAccompanyingPeriodsOrdered ( ) { $ periods = $ this -> getAccompanyingPeriods ( ) -> toArray ( ) ; usort ( $ periods , function ( $ a , $ b ) { $ dateA = $ a -> getOpeningDate ( ) ; $ dateB = $ b -> getOpeningDate ( ) ; if ( $ dateA == $ dateB ) { $ dateEA = $ a -> getClosingDate ( ) ; $ dateEB = $ b -> getClosingDate ( ) ; if ( $ dateEA == $ dateEB ) { return 0 ; } if ( $ dateEA < $ dateEB ) { return - 1 ; } else { return + 1 ; } } if ( $ dateA < $ dateB ) { return - 1 ; } else { return 1 ; } } ) ; return $ periods ; }
12712	public function getResolvedConcreteFlag ( $ abstract ) { if ( ! $ this -> hasResolvedConcrete ( $ abstract ) ) { throw Internal \ Exception \ ReflectionExceptionFactory :: invalidArgument ( sprintf ( "Parameter 1 of %s must be an abstract class name which exists in resolved concrete stack." , __METHOD__ ) ) ; } return explode ( '|' , $ this -> resolved [ $ abstract ] [ 'flag' ] ) ; }
2315	protected function prepareImportantPart ( ) { $ importantPart = $ this -> getImportantPart ( ) ; if ( substr_count ( $ this -> resizeMode , '_' ) === 1 ) { $ importantPart = array ( 'x' => 0 , 'y' => 0 , 'width' => $ this -> fileObj -> viewWidth , 'height' => $ this -> fileObj -> viewHeight , ) ; $ mode = explode ( '_' , $ this -> resizeMode ) ; if ( $ mode [ 0 ] === 'left' ) { $ importantPart [ 'width' ] = 1 ; } elseif ( $ mode [ 0 ] === 'right' ) { $ importantPart [ 'x' ] = $ importantPart [ 'width' ] - 1 ; $ importantPart [ 'width' ] = 1 ; } if ( $ mode [ 1 ] === 'top' ) { $ importantPart [ 'height' ] = 1 ; } elseif ( $ mode [ 1 ] === 'bottom' ) { $ importantPart [ 'y' ] = $ importantPart [ 'height' ] - 1 ; $ importantPart [ 'height' ] = 1 ; } } if ( ! $ importantPart [ 'width' ] || ! $ importantPart [ 'height' ] ) { return null ; } return new ImportantPart ( new Point ( $ importantPart [ 'x' ] , $ importantPart [ 'y' ] ) , new Box ( $ importantPart [ 'width' ] , $ importantPart [ 'height' ] ) ) ; }
4721	public function processListItems ( Text $ list , array $ options = array ( ) , $ level = 0 ) { $ list -> replace ( '/\n{2,}\z/' , "\n" ) ; $ list -> replace ( '{ (\n)? # leading line = $1 (^[ \t]*) # leading whitespace = $2 (' . $ this -> getPattern ( ) . ') [ \t]+ # list marker = $3 ((?s:.+?) # list item text = $4 (\n{1,2})) (?= \n* (\z | \2 (' . $ this -> getPattern ( ) . ') [ \t]+)) }mx' , function ( Text $ w , Text $ leadingLine , Text $ ls , Text $ m , Text $ item ) use ( $ options , $ level ) { if ( ( string ) $ leadingLine || $ item -> match ( '/\n{2,}/' ) ) { $ this -> markdown -> emit ( 'outdent' , array ( $ item ) ) ; $ this -> markdown -> emit ( 'block' , array ( $ item ) ) ; } else { $ this -> markdown -> emit ( 'outdent' , array ( $ item ) ) ; $ this -> processList ( $ item , $ options , ++ $ level ) ; $ item -> rtrim ( ) ; $ this -> markdown -> emit ( 'inline' , array ( $ item ) ) ; } return $ this -> getRenderer ( ) -> renderListItem ( $ item ) . "\n" ; } ) ; }
11923	public function getPerUnitAmount ( ) { $ amount = $ this -> getProduct ( ) -> getPrice ( ) ; foreach ( $ this -> getOptions ( ) as $ cartOption ) { $ amount = bcadd ( $ amount , $ cartOption -> getOption ( ) -> getPrice ( ) , 2 ) ; } foreach ( $ this -> getExtras ( ) as $ cartExtra ) { $ amount = bcadd ( $ amount , $ cartExtra -> getExtra ( ) -> getPrice ( ) , 2 ) ; } return floatval ( $ amount ) ; }
143	private static function fixHttpHeaderField ( $ header ) { if ( ! is_array ( $ header ) ) { $ header = explode ( "\r\n" , $ header ) ; } uasort ( $ header , function ( $ el ) { return stripos ( $ el , 'content-type' ) === 0 ? 1 : - 1 ; } ) ; return $ header ; }
755	public function validate ( $ input , $ caseSensitive ) { $ code = $ this -> getVerifyCode ( ) ; $ valid = $ caseSensitive ? ( $ input === $ code ) : strcasecmp ( $ input , $ code ) === 0 ; $ session = Yii :: $ app -> getSession ( ) ; $ session -> open ( ) ; $ name = $ this -> getSessionKey ( ) . 'count' ; $ session [ $ name ] += 1 ; if ( $ valid || $ session [ $ name ] > $ this -> testLimit && $ this -> testLimit > 0 ) { $ this -> getVerifyCode ( true ) ; } return $ valid ; }
8597	public function listMarketplaceParticipationsByNextToken ( $ request ) { if ( ! ( $ request instanceof MarketplaceWebServiceSellers_Model_ListMarketplaceParticipationsByNextTokenRequest ) ) { $ request = new MarketplaceWebServiceSellers_Model_ListMarketplaceParticipationsByNextTokenRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListMarketplaceParticipationsByNextToken' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = MarketplaceWebServiceSellers_Model_ListMarketplaceParticipationsByNextTokenResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
5535	public function divideMapNodes ( $ map , $ aspect ) { $ aspect = ! $ aspect ; $ divisions = $ map -> getSize ( ) ; $ total = $ map -> getTotalSize ( ) ; foreach ( $ map -> getChildren ( ) as $ node ) { if ( ! $ node -> isLeaf ( ) ) { $ dist = $ node -> getTotalSize ( ) / $ total * 100 ; } else { $ dist = 1 / $ total * 100 ; } if ( $ aspect ) { $ horiz = $ dist ; $ vert = 100 ; } else { $ horiz = 100 ; $ vert = $ dist ; } $ this -> paintRectangleStart ( $ node , $ horiz , $ vert ) ; $ this -> divideMapNodes ( $ node , $ aspect ) ; $ this -> paintRectangleEnd ( ) ; } }
2243	public static function getForm ( $ varId , $ strColumn = 'main' , $ blnModule = false ) { if ( \ is_object ( $ varId ) ) { $ objRow = $ varId ; } else { if ( $ varId == '' ) { return '' ; } $ objRow = FormModel :: findByIdOrAlias ( $ varId ) ; if ( $ objRow === null ) { return '' ; } } $ strClass = $ blnModule ? Module :: findClass ( 'form' ) : ContentElement :: findClass ( 'form' ) ; if ( ! class_exists ( $ strClass ) ) { static :: log ( 'Form class "' . $ strClass . '" does not exist' , __METHOD__ , TL_ERROR ) ; return '' ; } $ objRow -> typePrefix = $ blnModule ? 'mod_' : 'ce_' ; $ objRow -> form = $ objRow -> id ; $ objElement = new $ strClass ( $ objRow , $ strColumn ) ; $ strBuffer = $ objElement -> generate ( ) ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getForm' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getForm' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getForm' ] as $ callback ) { $ strBuffer = static :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ objRow , $ strBuffer , $ objElement ) ; } } return $ strBuffer ; }
11937	protected function find ( $ params ) { $ debug = false ; $ q = new Query ( ) ; $ q -> select ( '*' ) ; $ q -> from ( $ this -> _tableName ) ; foreach ( $ params as $ k => $ v ) { if ( $ k === 'join' ) { foreach ( $ v as $ join ) { if ( ! isset ( $ join [ 'type' ] ) ) { $ join [ 'type' ] = 'INNER JOIN' ; } if ( ! isset ( $ join [ 'params' ] ) ) { $ join [ 'params' ] = [ ] ; } $ q -> join ( $ join [ 'type' ] , $ join [ 'table' ] , $ join [ 'on' ] , $ join [ 'params' ] ) ; } $ debug = true ; } elseif ( in_array ( $ k , [ 'where' ] ) ) { $ q -> { $ k } ( $ v ) ; } else { $ q -> { $ k } = $ v ; } } if ( $ debug ) { } return $ q ; }
5571	public function back ( ) { if ( ! $ this -> history -> back ( ) ) { return false ; } $ content = $ this -> retry ( ) ; if ( ! $ content ) { $ this -> history -> forward ( ) ; } return $ content ; }
5740	protected static function logDuration ( Request $ request , Response $ response , $ startTime ) { $ duration = microtime ( true ) - $ startTime ; $ tags = [ "status_code" => $ response -> getStatusCode ( ) ] ; if ( ! config ( 'datadog-helper.middleware_disable_url_tag' , false ) ) { $ tags [ "url" ] = $ request -> getSchemeAndHttpHost ( ) . $ request -> getRequestUri ( ) ; } Datadog :: timing ( 'request_time' , $ duration , 1 , $ tags ) ; }
7038	public function getShipments ( $ filter = null ) { if ( null === $ filter ) { return $ this -> shipments ; } return $ this -> shipments -> filter ( function ( ShipmentInterface $ shipment ) use ( $ filter ) { return $ filter xor $ shipment -> isReturn ( ) ; } ) ; }
5750	public function setRoles ( ) { $ this -> roles = [ ] ; if ( null !== $ records = $ this -> select ( ) ) { foreach ( $ records as $ record ) { $ this -> roles [ ( int ) $ record [ 'id' ] ] = $ record [ 'role' ] ; } } }
5117	public function deleteArticle ( string $ idArticle ) : ? string { $ articleOnRest = $ this -> getArticle ( $ idArticle ) ; if ( ! empty ( $ articleOnRest ) ) { $ articleOnRest = json_decode ( $ articleOnRest , true ) ; if ( isset ( $ articleOnRest [ 'data' ] ) ) { foreach ( Article :: getDeleteableAttachment ( ) as $ field ) { if ( isset ( $ articleOnRest [ 'data' ] [ $ field ] ) ) { foreach ( $ articleOnRest [ 'data' ] [ $ field ] as $ attachment ) { if ( isset ( $ attachment [ $ field . '_order' ] ) ) { $ this -> deleteAttachment ( $ idArticle , $ field , $ attachment [ $ field . '_order' ] ) ; } } } } } return $ this -> delete ( $ this -> getArticleWithIdEndPoint ( $ idArticle ) ) ; } }
9420	public function search ( HTTPRequest $ request ) { if ( ! $ request -> isAjax ( ) ) { return ; } $ data = [ ] ; if ( $ term = $ request -> getVar ( 'term' ) ) { $ groups = [ ] ; foreach ( $ this -> backend -> getGroupedIcons ( ) as $ group => $ icons ) { $ children = [ ] ; foreach ( $ icons as $ id => $ icon ) { if ( stripos ( $ id , $ term ) !== false ) { $ children [ ] = $ this -> getResultData ( $ this -> getIconData ( $ id ) ) ; } } if ( ! empty ( $ children ) ) { $ groups [ ] = [ 'text' => $ group , 'children' => $ children ] ; } } $ data [ 'results' ] = $ groups ; } return $ this -> respond ( $ data ) ; }
9090	function isMultipart ( ) { foreach ( $ this -> fields as $ field ) { if ( ! $ field instanceof Field ) { continue ; } if ( $ field -> getType ( ) == 'file' || $ field -> getValueType ( ) == 'file' || $ field -> getDataType ( ) ) { return true ; } } return false ; }
8690	protected function validateElementValues ( ) { foreach ( self :: $ mandatoryFields as $ field ) { if ( array_key_exists ( $ field , $ this -> attributes ) ) { $ value = ( int ) $ this -> attributes [ $ field ] ; if ( $ value < 0 ) { throw new \ SVGCreator \ SVGException ( "The " . $ field . " value is lesser than 0, in element " . self :: TYPE , 1 ) ; } } } }
12330	public function get_source_to_enqueue ( $ relative_path , $ filename , $ filename_debug = null ) { $ source_file = $ filename ; if ( defined ( 'SCRIPT_DEBUG' ) && true === SCRIPT_DEBUG && ! empty ( $ filename_debug ) ) { $ source_file = $ filename_debug ; } $ path = realpath ( trailingslashit ( $ relative_path ) . $ source_file ) ; return WP_Url_Util :: get_instance ( ) -> convert_absolute_path_to_url ( $ path ) ; }
7083	public function method ( $ method = NULL ) { if ( $ method === NULL ) { return $ this -> _method ; } $ this -> _method = strtoupper ( $ method ) ; return $ this ; }
9828	public function getCreateAssociationName ( $ modelName , $ otherModelName ) { return sprintf ( 'auja.%s.%s.create' , $ this -> toUrlName ( $ modelName ) , $ this -> toUrlName ( $ otherModelName ) ) ; }
3274	public function set ( string $ key , $ data ) { Validation :: validateKey ( $ key ) ; if ( $ this -> get ( $ key ) !== false ) { $ this -> replace ( $ key , $ data ) ; return ; } $ this -> getDatabase ( ) -> appendToFile ( $ this -> getLineString ( $ key , $ data ) ) ; if ( $ cache = $ this -> getConfig ( ) -> getCache ( ) ) { $ cache -> delete ( $ key ) ; } }
9510	public function download ( Log $ log ) { $ this -> authorize ( LogViewerPolicy :: PERMISSION_DOWNLOAD ) ; return $ this -> logViewer -> download ( $ log -> date ) ; }
12177	public function addArgument ( ArgumentInterface $ argument ) { $ this -> argumentPositions [ $ argument -> getPosition ( ) ] = $ argument ; $ this -> argumentNames [ $ argument -> getName ( ) ] = $ argument ; if ( $ argument -> isClass ( ) ) { $ this -> argumentClasses [ $ argument -> getClass ( ) ] = $ argument ; } return $ argument ; }
5587	public function getCookies ( ) { $ lstCookies = $ this -> cookie_jar -> getCookies ( ) ; $ aCookies = [ ] ; foreach ( $ lstCookies as $ oCookies ) { $ aCookies [ ] = [ 'name' => $ oCookies -> getName ( ) , 'value' => $ oCookies -> getValue ( ) , 'host' => $ oCookies -> getHost ( ) , 'path' => $ oCookies -> getPath ( ) , 'expiry' => $ oCookies -> getExpiry ( ) , ] ; } return $ aCookies ; }
4314	private function doGroup ( $ method , $ args ) { $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) ) ; $ this -> rootInstance -> groupStackRef [ ] = array ( 'channel' => $ meta [ 'channel' ] , 'collect' => $ this -> cfg [ 'collect' ] , ) ; if ( ! $ this -> cfg [ 'collect' ] ) { return ; } if ( empty ( $ args ) ) { $ caller = $ this -> utilities -> getCallerInfo ( ) ; if ( isset ( $ caller [ 'class' ] ) ) { $ args [ ] = $ caller [ 'class' ] . $ caller [ 'type' ] . $ caller [ 'function' ] ; $ meta [ 'isMethodName' ] = true ; } elseif ( isset ( $ caller [ 'function' ] ) ) { $ args [ ] = $ caller [ 'function' ] ; } else { $ args [ ] = 'group' ; } } $ this -> appendLog ( $ method , $ args , $ meta ) ; }
1255	private function getValueToAssignToValue ( \ stdClass $ meta ) { if ( is_subclass_of ( $ meta -> phpObject , '\DTS\eBaySDK\Types\Base64BinaryType' , false ) ) { return $ meta -> strData ; } elseif ( is_subclass_of ( $ meta -> phpObject , '\DTS\eBaySDK\Types\BooleanType' , false ) ) { return strtolower ( $ meta -> strData ) === 'true' ; } elseif ( is_subclass_of ( $ meta -> phpObject , '\DTS\eBaySDK\Types\DecimalType' , false ) ) { return is_int ( 0 + $ meta -> strData ) ? ( integer ) $ meta -> strData : ( double ) $ meta -> strData ; } elseif ( is_subclass_of ( $ meta -> phpObject , '\DTS\eBaySDK\Types\DoubleType' , false ) ) { return ( double ) $ meta -> strData ; } elseif ( is_subclass_of ( $ meta -> phpObject , '\DTS\eBaySDK\Types\IntegerType' , false ) ) { return ( integer ) $ meta -> strData ; } elseif ( is_subclass_of ( $ meta -> phpObject , '\DTS\eBaySDK\Types\StringType' , false ) ) { return $ meta -> strData ; } elseif ( is_subclass_of ( $ meta -> phpObject , '\DTS\eBaySDK\Types\TokenType' , false ) ) { return $ meta -> strData ; } elseif ( is_subclass_of ( $ meta -> phpObject , '\DTS\eBaySDK\Types\URIType' , false ) ) { return $ meta -> strData ; } return $ meta -> strData ; }
9552	public function allowMimeTypes ( $ mimeTypes ) { if ( ! is_array ( $ mimeTypes ) ) { $ mimeTypes = [ $ mimeTypes ] ; } $ this -> constraints [ ] = new MimeTypeConstraint ( $ mimeTypes ) ; return $ this ; }
2804	public function searchAction ( ) { $ requests = $ this -> _getFilteredRequests ( ) ; $ this -> loadLayout ( 'sheep_debug' ) ; $ rootBlock = $ this -> getLayout ( ) -> getBlock ( 'root' ) ; $ rootBlock -> setHeaderTitle ( $ this -> __ ( 'Request profiles' ) ) ; $ profileListBlock = $ this -> getLayout ( ) -> getBlock ( 'sheep_debug_list' ) ; $ profileListBlock -> setData ( 'results' , $ requests ) ; $ this -> renderLayout ( ) ; }
2147	protected function sendNewsletter ( Email $ objEmail , Result $ objNewsletter , $ arrRecipient , $ text , $ html , $ css = null ) { $ objEmail -> text = StringUtil :: parseSimpleTokens ( $ text , $ arrRecipient ) ; if ( ! $ objNewsletter -> sendText ) { if ( $ objNewsletter -> template == '' ) { $ objNewsletter -> template = 'mail_default' ; } $ objTemplate = new BackendTemplate ( $ objNewsletter -> template ) ; $ objTemplate -> setData ( $ objNewsletter -> row ( ) ) ; $ objTemplate -> title = $ objNewsletter -> subject ; $ objTemplate -> body = StringUtil :: parseSimpleTokens ( $ html , $ arrRecipient ) ; $ objTemplate -> charset = Config :: get ( 'characterSet' ) ; $ objTemplate -> recipient = $ arrRecipient [ 'email' ] ; $ objTemplate -> css = $ css ; $ objEmail -> html = $ objTemplate -> parse ( ) ; $ objEmail -> imageDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) . '/' ; } try { $ objEmail -> sendTo ( $ arrRecipient [ 'email' ] ) ; } catch ( \ Swift_RfcComplianceException $ e ) { $ _SESSION [ 'REJECTED_RECIPIENTS' ] [ ] = $ arrRecipient [ 'email' ] ; } if ( $ objEmail -> hasFailures ( ) ) { $ _SESSION [ 'REJECTED_RECIPIENTS' ] [ ] = $ arrRecipient [ 'email' ] ; } if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'sendNewsletter' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'sendNewsletter' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'sendNewsletter' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ objEmail , $ objNewsletter , $ arrRecipient , $ text , $ html ) ; } } }
6195	protected function findControllerFiles ( ) { $ result = [ ] ; foreach ( $ this -> controllerDirs as $ dir ) { $ directoryIterator = new \ RecursiveDirectoryIterator ( $ dir ) ; $ iterator = new \ RecursiveIteratorIterator ( $ directoryIterator ) ; $ files = new \ RegexIterator ( $ iterator , '/\.php$/i' , \ RecursiveRegexIterator :: GET_MATCH ) ; foreach ( $ files as $ k => $ v ) { $ result [ $ k ] = filemtime ( $ k ) ; } } return $ result ; }
6532	protected function buildParams ( SmsGatewayMessage $ message , $ to ) { $ optionalFields = array_filter ( [ 'expires_at' => data_get ( $ message , 'expiresAt' ) , 'send_at' => data_get ( $ message , 'sendAt' ) , ] ) ; return array_merge ( [ 'number' => $ to , 'message' => trim ( $ message -> content ) , ] , $ optionalFields ) ; }
12794	public function delete ( $ id ) { try { $ response = $ this -> client -> request -> delete ( $ this -> apiEndpoint . "/droplets/$id" ) ; $ status = $ this -> client -> getStatus ( $ response ) ; if ( 204 != $ status ) { throw new Exception ( 'Digital Ocean responded that it could not delete it.' ) ; } return $ status ; } catch ( Exception $ e ) { echo 'Unable to delete server because ' . $ e -> getMessage ( ) ; } }
12976	public function parseMappingInfo ( ) { $ mappings = array ( ) ; foreach ( $ this -> getMappings ( ) as $ mappingName => $ mappingConfig ) { if ( is_array ( $ mappingConfig ) === false or \ Arr :: get ( $ mappingConfig , 'mapping' , true ) === false ) { continue ; } $ mappingConfig = array_replace ( array ( 'dir' => false , 'type' => false , 'prefix' => false , ) , $ mappingConfig ) ; if ( isset ( $ mappingConfig [ 'is_component' ] ) === false ) { $ mappingConfig [ 'is_component' ] = false ; if ( is_dir ( $ mappingConfig [ 'dir' ] ) === false ) { $ mappingConfig [ 'is_component' ] = ( \ Package :: loaded ( $ mappingName ) or \ Module :: loaded ( $ mappingName ) ) ; } } if ( $ mappingConfig [ 'is_component' ] ) { $ mappingConfig = $ this -> getComponentDefaults ( $ mappingName , $ mappingConfig ) ; } if ( empty ( $ mappingConfig ) ) { continue ; } $ mappings [ $ mappingName ] = $ mappingConfig ; } $ this -> config [ 'mappings' ] = $ mappings ; }
9431	public function routes ( ) { $ routes = array_merge ( $ this -> routes , $ this -> collector -> getData ( ) ) ; return function ( RouteCollector $ collector ) use ( $ routes ) { foreach ( array_filter ( $ routes ) as $ route ) { list ( $ method , $ uri , $ handler ) = ( array ) $ route ; $ collector -> addRoute ( $ method , $ uri , $ handler ) ; } } ; }
8720	protected function initTranslatableAttributes ( ) { if ( property_exists ( $ this , 'translatable' ) ) { $ attributes = $ this -> translatable ; } else { $ attributes = $ this -> getTranslatableAttributesFromSchema ( ) ; } static :: $ i18nAttributes [ $ this -> getTable ( ) ] = $ attributes ; }
5976	public function media ( ) { if ( ! $ this -> media instanceof MediaController ) { $ this -> media = new MediaController ( $ this -> getClient ( ) , $ this -> cachePolicy , $ this -> cache ) ; $ this -> media -> setLogger ( $ this -> logger ) ; } return $ this -> media ; }
9916	public function configure ( array $ modelConfigurations ) { if ( empty ( $ modelConfigurations ) ) { throw new \ LogicException ( 'Supply at least one model or model configuration!' ) ; } foreach ( $ modelConfigurations as $ className ) { $ modelClass = $ className ; if ( is_subclass_of ( $ className , 'Illuminate\Database\Eloquent\Model' ) ) { $ config = new ModelConfig ( ) ; $ config -> setModelClass ( $ modelClass ) ; } else if ( is_subclass_of ( $ className , 'Label305\AujaLaravel\Config\ModelConfig' ) ) { $ config = new $ className ( ) ; $ modelClass = $ config -> getModelClass ( ) ; } else { throw new \ InvalidArgumentException ( "Model configuration should be class name string of either a ModelConfig or Eloquent subclass." ) ; } $ model = new Model ( $ modelClass ) ; $ this -> models [ $ modelClass ] = $ model ; $ this -> relations [ $ modelClass ] = [ ] ; $ configResolver = new ConfigResolver ( $ config , $ model ) ; $ this -> configs [ $ modelClass ] = $ configResolver -> resolve ( ) ; $ this -> findColumns ( $ this -> models [ $ modelClass ] ) ; $ this -> configs [ $ modelClass ] = $ configResolver -> resolve ( ) ; } $ this -> findRelations ( array_values ( $ this -> models ) ) ; }
8993	public function expecting ( ) { $ possibilities = count ( $ this -> samples ) ; $ orderedByOccurance = array_count_values ( $ this -> samples ) ; array_multisort ( $ orderedByOccurance , SORT_DESC ) ; $ probabilities = [ ] ; foreach ( $ orderedByOccurance as $ item => $ value ) { $ probabilities [ $ item ] = $ value / $ possibilities ; } return $ probabilities ; }
3534	public static function createNewUser ( $ username , $ individualGroupAssignmentOptions = null ) { if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: beginProfile ( 'createNewUser' , static :: YII2_PROFILE_NAME . 'createNewUser' ) ; } $ userObjectDb = new static ( ) ; $ userObjectDb -> username = $ username ; $ userObjectDb -> setIndividualGroupAssignmentOptions ( $ individualGroupAssignmentOptions ) ; if ( $ userObjectDb -> queryLdapUserObject ( ) == null ) { $ userObjectDb = null ; } else { $ roles = $ userObjectDb -> updateGroupAssignment ( ) ; if ( count ( $ roles ) > 0 || static :: getGroupAssigmentOptions ( 'LOGIN_POSSIBLE_WITH_ROLE_ASSIGNED_MATCHING_REGEX' , $ userObjectDb -> individualGroupAssignmentOptions ) == null ) { $ userObjectDb -> generateAuthKey ( ) ; $ userObjectDb -> updateAccountStatus ( ) ; $ userObjectDb -> save ( ) ; } else { $ userObjectDb = null ; } } if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: endProfile ( 'createNewUser' , static :: YII2_PROFILE_NAME . 'createNewUser' ) ; } return $ userObjectDb ; }
5888	public function getClass ( $ prefix = "ts3_" ) { if ( $ this instanceof Channel && $ this -> isSpacer ( ) ) { return $ prefix . "spacer" ; } elseif ( $ this instanceof Client && $ this [ "client_type" ] ) { return $ prefix . "query" ; } return $ prefix . StringHelper :: factory ( get_class ( $ this ) ) -> toLower ( ) ; }
688	protected function removeAllItems ( $ type ) { if ( ! $ this -> supportsCascadeUpdate ( ) ) { $ names = ( new Query ( ) ) -> select ( [ 'name' ] ) -> from ( $ this -> itemTable ) -> where ( [ 'type' => $ type ] ) -> column ( $ this -> db ) ; if ( empty ( $ names ) ) { return ; } $ key = $ type == Item :: TYPE_PERMISSION ? 'child' : 'parent' ; $ this -> db -> createCommand ( ) -> delete ( $ this -> itemChildTable , [ $ key => $ names ] ) -> execute ( ) ; $ this -> db -> createCommand ( ) -> delete ( $ this -> assignmentTable , [ 'item_name' => $ names ] ) -> execute ( ) ; } $ this -> db -> createCommand ( ) -> delete ( $ this -> itemTable , [ 'type' => $ type ] ) -> execute ( ) ; $ this -> invalidateCache ( ) ; }
855	public function insertAt ( $ index , $ items ) { $ items = \ is_array ( $ items ) || $ items instanceof self ? $ items : [ $ items ] ; $ itemsCnt = \ count ( $ items ) ; if ( 0 === $ itemsCnt ) { return ; } $ oldSize = \ count ( $ this ) ; $ this -> changed = true ; $ this -> blockEndCache = [ ] ; $ this -> setSize ( $ oldSize + $ itemsCnt ) ; for ( $ i = $ oldSize + $ itemsCnt - 1 ; $ i >= $ index ; -- $ i ) { $ oldItem = parent :: offsetExists ( $ i - $ itemsCnt ) ? parent :: offsetGet ( $ i - $ itemsCnt ) : new Token ( '' ) ; parent :: offsetSet ( $ i , $ oldItem ) ; } for ( $ i = 0 ; $ i < $ itemsCnt ; ++ $ i ) { if ( '' === $ items [ $ i ] -> getContent ( ) ) { throw new \ InvalidArgumentException ( 'Must not add empty token to collection.' ) ; } $ this -> registerFoundToken ( $ items [ $ i ] ) ; parent :: offsetSet ( $ i + $ index , $ items [ $ i ] ) ; } }
9555	public function getHandler ( ) { if ( $ this -> namer === null ) { $ this -> namer = new GenericNamer ( ) ; } if ( $ this -> filesystem === null ) { throw new \ LogicException ( sprintf ( 'You should set a filesystem for the builder.' ) ) ; } $ handler = new UploadHandler ( $ this -> filesystem , $ this -> namer , $ this -> overwrite ) ; $ validator = $ handler -> getValidator ( ) ; foreach ( $ this -> constraints as $ constraint ) { $ validator -> addConstraint ( $ constraint ) ; } return $ handler ; }
12470	protected function setAppConfigNamespaces ( ) { $ search = [ $ this -> currentRoot . '\\Providers' , $ this -> currentRoot . '\\Http\\Controllers\\' ] ; $ replace = [ $ this -> argument ( 'name' ) . '\\Providers' , $ this -> argument ( 'name' ) . '\\Http\\Controllers\\' ] ; }
716	public function decimal ( $ precision = null , $ scale = null ) { $ length = [ ] ; if ( $ precision !== null ) { $ length [ ] = $ precision ; } if ( $ scale !== null ) { $ length [ ] = $ scale ; } return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_DECIMAL , $ length ) ; }
6117	public function serverGetByUid ( $ uid ) { foreach ( $ this -> serverList ( ) as $ server ) { if ( $ server [ "virtualserver_unique_identifier" ] == $ uid ) { return $ server ; } } throw new Ts3Exception ( "invalid serverID" , 0x400 ) ; }
6773	protected function isTaxationUpdateNeeded ( SaleInterface $ sale ) { if ( $ this -> persistenceHelper -> isChanged ( $ sale , [ 'taxExempt' , 'customer' , 'vatValid' ] ) ) { return true ; } return $ this -> didDeliveryCountryChanged ( $ sale ) ; }
11202	public function toArray ( ) { $ collection = $ this -> getIterator ( ) ; $ plainArray = [ ] ; foreach ( $ collection as $ prop => $ result ) { if ( is_object ( $ result ) && method_exists ( $ result , 'toArray' ) ) { $ plainArray [ ] = $ result -> toArray ( ) ; } else { $ plainArray [ ] = $ result ; } } return $ plainArray ; }
11438	public function getDefault ( $ name ) { return isset ( $ this -> options [ 'defaults' ] [ $ name ] ) ? $ this -> options [ 'defaults' ] [ $ name ] : null ; }
9496	public function getCollection ( $ end_point , $ collectionName , $ page = 1 , $ per_page = 100 , $ sort_by = null , $ sort_order = 'asc' ) { $ end_point = strtolower ( $ end_point ) ; if ( strpos ( $ end_point , 'http' ) !== 0 ) { $ end_point = $ this -> api -> getApiUrl ( ) . $ end_point ; } $ request = $ this -> api -> get ( $ end_point ) ; $ query = $ request -> getQuery ( ) -> set ( 'page' , $ page ) -> set ( 'per_page' , $ per_page ) ; if ( $ sort_by ) { $ query -> set ( 'sort_by' , $ sort_by ) -> set ( 'sort_order' , $ sort_order == 'asc' ? 'asc' : 'desc' ) ; } $ response = $ this -> processRequest ( $ request ) ; $ values = $ response -> json ( ) ; $ result = new PaginatedResult ( ) ; $ result -> setClient ( $ this ) ; if ( array_key_exists ( 'count' , $ values ) ) { $ result -> setCount ( $ values [ 'count' ] ) ; } $ result -> setCurrentPage ( $ page ) ; $ result -> setPerPage ( $ per_page ) ; $ result -> setEndPoint ( $ end_point ) ; $ type = $ this -> getType ( ) ; if ( array_key_exists ( $ collectionName , $ values ) && is_array ( $ values [ $ collectionName ] ) ) { foreach ( $ values [ $ collectionName ] as $ value ) { $ entity = new $ type ( ) ; $ this -> manage ( $ entity ) ; $ result [ ] = $ entity -> fromArray ( $ value ) ; } } return $ result ; }
4613	public function withScalarValue ( $ value ) { $ this -> match = $ value ; $ this -> lowerBound = null ; $ this -> upperBound = null ; return $ this ; }
7678	function TbsSheetCheck ( ) { if ( count ( $ this -> OtbsSheetSlidesDelete ) > 0 ) $ this -> RaiseError ( "Unable to delete the following sheets because they are not found in the workbook: " . ( str_replace ( array ( 'i:' , 'n:' ) , '' , implode ( ', ' , $ this -> OtbsSheetSlidesDelete ) ) ) . '.' ) ; if ( count ( $ this -> OtbsSheetSlidesVisible ) > 0 ) $ this -> RaiseError ( "Unable to change visibility of the following sheets because they are not found in the workbook: " . ( str_replace ( array ( 'i:' , 'n:' ) , '' , implode ( ', ' , array_keys ( $ this -> OtbsSheetSlidesVisible ) ) ) ) . '.' ) ; }
11953	public function deleteFromDB ( ) { if ( ! $ this -> isValid ( ) ) { return false ; } if ( count ( $ this -> key_properties ) == 0 ) { return false ; } $ where_part = '' ; foreach ( $ this -> key_properties as $ key ) { if ( $ where_part ) { $ where_part .= ' AND ' ; } if ( $ this -> { $ key } instanceof Web2All_Table_SQLOperation ) { trigger_error ( 'Web2All_Table_SaveObjectTrait->deleteFromDB(): using Web2All_Table_SQLOperation object for key value ' . $ key , E_USER_NOTICE ) ; $ where_part .= $ this -> obj_to_db_trans [ $ key ] . '=' . $ this -> { $ key } -> toSQLString ( ) ; } else if ( $ this -> { $ key } instanceof Web2All_Table_SQLOperationList ) { throw new Exception ( "Web2All_Table_SaveObjectTrait: can't delete using a Web2All_Table_SQLOperationList for key value " . $ key ) ; } else { $ where_part .= $ this -> obj_to_db_trans [ $ key ] . '=' . $ this -> db -> Quote ( $ this -> { $ key } ) ; } } $ this -> db -> Execute ( 'DELETE FROM ' . $ this -> quote ( $ this -> tablename ) . ' WHERE ' . $ where_part . ' ' ) ; return true ; }
7184	private function getFindAvailableByCountryAndWeightQuery ( ) { if ( null === $ this -> findAvailableByCountryAndWeightQuery ) { $ qb = $ this -> getCollectionQueryBuilder ( ) ; $ this -> findAvailableByCountryAndWeightQuery = $ qb -> join ( 'o.prices' , 'p' ) -> join ( 'p.zone' , 'z' ) -> andWhere ( $ qb -> expr ( ) -> isMemberOf ( ':country' , 'z.countries' ) ) -> andWhere ( $ qb -> expr ( ) -> gte ( 'p.weight' , ':weight' ) ) -> andWhere ( $ qb -> expr ( ) -> eq ( 'o.enabled' , ':enabled' ) ) -> andWhere ( $ qb -> expr ( ) -> eq ( 'o.available' , ':available' ) ) -> addOrderBy ( 'o.position' , 'ASC' ) -> getQuery ( ) ; } return $ this -> findAvailableByCountryAndWeightQuery ; }
8737	public function insertGetId ( array $ values , $ sequence = null ) { list ( $ values , $ i18nValues ) = $ this -> filterValues ( $ values ) ; if ( $ id = $ this -> query -> insertGetId ( $ values , $ sequence ) ) { if ( $ this -> insertI18n ( $ i18nValues , $ id ) ) { return $ id ; } } return false ; }
9213	public function getOptionParser ( ) { $ parser = parent :: getOptionParser ( ) ; $ parser -> description ( 'Provides a mechanism for loading data into any of Cake\'s configured databases.' ) -> addSubcommand ( 'init' , [ 'help' => 'Initialize a new, empty seed file. Respects both the --dev and --file options.' , ] ) -> addOption ( 'dev' , [ 'short' => 'd' , 'boolean' => true , 'default' => false , 'help' => 'Use the "dev" seed file instead of the default.' ] ) -> addOption ( 'file' , [ 'short' => 'f' , 'help' => 'Manually specify the file that should be used. When this option is present, its argument will always be used explicitly, overriding the --dev option if it is also present.' ] ) ; return $ parser ; }
11811	protected function loadLocalObject ( ) { if ( $ this -> _isLoadingLocalObject ) { throw new RecursionException ( 'Ran into recursion while loading local object' ) ; } $ this -> _isLoadingLocalObject = true ; if ( isset ( $ this -> foreignObject ) && ! isset ( $ this -> _localObject ) ) { $ keyTranslation = $ this -> dataSource -> getKeyTranslation ( $ this -> foreignObject ) ; if ( ! empty ( $ keyTranslation ) && ( $ localObject = $ keyTranslation -> object ) ) { $ this -> localObject = $ localObject ; } } $ this -> _isLoadingLocalObject = false ; }
4307	public function timeEnd ( $ label = null , $ returnOrTemplate = false , $ precision = 4 ) { $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) , array ( 'label' => null , 'returnOrTemplate' => false , 'precision' => 4 , ) ) ; \ extract ( $ args ) ; if ( \ is_bool ( $ label ) || \ strpos ( $ label , '%time' ) !== false ) { if ( \ is_numeric ( $ returnOrTemplate ) ) { $ precision = $ returnOrTemplate ; } $ returnOrTemplate = $ label ; $ label = null ; } $ ret = $ this -> timeGet ( $ label , true , null ) ; if ( isset ( $ label ) ) { if ( isset ( $ this -> data [ 'timers' ] [ 'labels' ] [ $ label ] ) ) { $ this -> data [ 'timers' ] [ 'labels' ] [ $ label ] = array ( $ ret , null , ) ; } } else { $ label = 'time' ; \ array_pop ( $ this -> data [ 'timers' ] [ 'stack' ] ) ; } if ( \ is_int ( $ precision ) ) { $ ret = \ number_format ( $ ret , $ precision , '.' , '' ) ; } $ this -> doTime ( $ ret , $ returnOrTemplate , $ label , $ meta ) ; return $ ret ; }
4444	public function failedForGroup ( $ group , int $ start = 0 , int $ limit = 25 ) : array { $ results = json_decode ( $ this -> client -> failed ( $ group , $ start , $ limit ) , true ) ; if ( isset ( $ results [ 'jobs' ] ) && ! empty ( $ results [ 'jobs' ] ) ) { $ results [ 'jobs' ] = $ this -> multiget ( $ results [ 'jobs' ] ) ; } return is_array ( $ results ) ? $ results : [ ] ; }
11510	public static function parse ( $ program ) { $ i = 0 ; $ len = strlen ( $ program ) ; $ forms = [ ] ; while ( $ i < $ len ) { if ( strpos ( self :: WHITESPACES , $ program [ $ i ] ) === false ) { try { $ form = self :: parseExpression ( substr ( $ program , $ i ) , $ offset ) ; if ( ! is_null ( $ form ) ) $ forms [ ] = $ form ; } catch ( ParseException $ e ) { throw new ParseException ( $ program , $ e -> offset + $ i ) ; } $ i += $ offset ; } else ++ $ i ; } return $ forms ; }
8708	public function select ( $ columns = [ '*' ] ) { parent :: select ( $ columns ) ; $ this -> columns = $ this -> qualifyColumns ( $ this -> columns ) ; return $ this ; }
3593	public static function setFakeMacAddress ( $ interface , $ mac = null ) { if ( ! self :: validateMacAddress ( $ mac ) ) { $ mac = self :: generateMacAddress ( ) ; } self :: runCommand ( "ifconfig {$interface} down" ) ; self :: runCommand ( "ifconfig {$interface} hw ether {$mac}" ) ; self :: runCommand ( "ifconfig {$interface} up" ) ; self :: runCommand ( "dhclient {$interface}" ) ; if ( self :: getCurrentMacAddress ( $ interface ) == $ mac ) { return true ; } return false ; }
8031	public function getProcessDetails ( $ pid ) { if ( $ this -> hasProcess ( $ pid ) === FALSE ) { return NULL ; } return $ this -> processDetails [ $ pid ] ; }
10612	public function confirmedAction ( ) { $ user = $ this -> getUser ( ) ; if ( ! is_object ( $ user ) || ! $ user instanceof UserInterface ) { throw $ this -> createAccessDeniedException ( 'This user does not have access to this section.' ) ; } return $ this -> render ( "@MikyUser/Frontend/Registration/confirmed.html.twig" , array ( 'user' => $ user , ) ) ; }
2439	public function cloneForCurrent ( string $ current ) : self { return new self ( $ this -> context , $ this -> extras , $ this -> value , $ current ) ; }
680	protected function validateConjunctionCondition ( $ operator , $ condition ) { if ( ! is_array ( $ condition ) || ! ArrayHelper :: isIndexed ( $ condition ) ) { $ this -> addError ( $ this -> filterAttributeName , $ this -> parseErrorMessage ( 'operatorRequireMultipleOperands' , [ 'operator' => $ operator ] ) ) ; return ; } foreach ( $ condition as $ part ) { $ this -> validateCondition ( $ part ) ; } }
9807	private function readBlipJPEG ( ) { $ recInstance = ( 0xFFF0 & Xls :: getUInt2d ( $ this -> data , $ this -> pos ) ) >> 4 ; $ length = Xls :: getInt4d ( $ this -> data , $ this -> pos + 4 ) ; $ recordData = substr ( $ this -> data , $ this -> pos + 8 , $ length ) ; $ this -> pos += 8 + $ length ; $ pos = 0 ; $ rgbUid1 = substr ( $ recordData , 0 , 16 ) ; $ pos += 16 ; if ( in_array ( $ recInstance , [ 0x046B , 0x06E3 ] ) ) { $ rgbUid2 = substr ( $ recordData , 16 , 16 ) ; $ pos += 16 ; } $ tag = ord ( $ recordData [ $ pos ] ) ; $ pos += 1 ; $ data = substr ( $ recordData , $ pos ) ; $ blip = new Blip ( ) ; $ blip -> setData ( $ data ) ; $ this -> object -> setBlip ( $ blip ) ; }
1446	protected function dataForUpdate ( $ record , array $ document ) : array { $ resource = $ document [ 'data' ] ?? [ ] ; if ( $ this -> mustValidateExisting ( $ record , $ document ) ) { $ resource [ 'attributes' ] = $ this -> extractAttributes ( $ record , $ resource [ 'attributes' ] ?? [ ] ) ; $ resource [ 'relationships' ] = $ this -> extractRelationships ( $ record , $ resource [ 'relationships' ] ?? [ ] ) ; } return $ resource ; }
8771	public function registerConfiguredProviders ( ) { $ providers = Collection :: make ( $ this -> config [ 'app.providers' ] ) -> partition ( function ( $ provider ) { return Str :: startsWith ( $ provider , 'Nur\\' ) ; } ) ; $ providers -> splice ( 1 , 0 , [ $ this -> make ( PackageManifest :: class ) -> providers ( ) ] ) ; ( new ProviderRepository ( $ this , new Filesystem , $ this -> getCachedServicesPath ( ) ) ) -> load ( $ providers -> collapse ( ) -> toArray ( ) ) ; }
7976	public function addSecondaryDnsDomains ( $ domain2add , $ ip ) { self :: getClient ( ) -> addSecondaryDnsDomains ( $ this -> getDomain ( ) , $ domain2add , $ ip ) ; return true ; }
1396	public function updated ( $ resource = null , array $ links = [ ] , $ meta = null , array $ headers = [ ] ) { return $ this -> getResourceResponse ( $ resource , $ links , $ meta , $ headers ) ; }
8876	public function send ( ) { if ( ! preg_match ( '/^.+@.+$/' , $ this -> sender ) ) { return false ; } if ( ! preg_match ( '/^.+@.+$/' , $ this -> recipient ) ) { return false ; } if ( ! $ this -> subject || strlen ( $ this -> subject ) > 255 ) { return false ; } $ required_headers = [ ] ; if ( Mail :: $ config [ 'testing_mode' ] ) { if ( empty ( Mail :: $ config [ 'testing_email' ] ) ) { return true ; } $ required_headers [ 'X-Testing-Original-To' ] = $ this -> recipient ; foreach ( $ this -> headers as $ name => $ value ) { switch ( strtolower ( $ name ) ) { case 'cc' : $ this -> headers [ 'X-Testing-Original-Cc' ] = $ value ; $ required_headers [ $ name ] = '' ; break ; case 'bcc' : $ this -> headers [ 'X-Testing-Original-Bcc' ] = $ value ; $ required_headers [ $ name ] = '' ; break ; } } $ to = Mail :: $ config [ 'testing_email' ] ; $ subject = '*Test* ' . $ this -> subject ; } else { $ to = $ this -> recipient ; $ subject = $ this -> subject ; } $ required_headers [ 'From' ] = $ this -> sender ; $ required_headers [ 'Return-Path' ] = $ this -> sender ; $ required_headers [ 'Reply-To' ] = $ this -> sender ; $ required_headers [ 'X-Sender' ] = $ this -> sender ; $ headers = $ this -> buildHeaders ( $ required_headers ) ; $ message = $ this -> buildTextPart ( ) . $ this -> buildAttachmentPart ( ) . "--MIME_BOUNDRY--\n" ; return mail ( $ to , $ subject , $ message , $ headers , Mail :: $ config [ 'additional_parameters' ] ) ; }
8623	public function setOfferListingCount ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'OfferListingCount' ] [ 'FieldValue' ] = $ value ; return $ this ; }
6569	public function unsetData ( ) : void { foreach ( array_keys ( $ this -> data ) as $ var ) { if ( ! in_array ( $ var , self :: ALL_HEADERS ) ) { unset ( $ this -> data [ $ var ] ) ; } } }
4666	protected function configure ( array $ config ) { $ this -> config = $ config ; $ this -> registerSwiftTransport ( ) ; $ this -> registerSwiftMailer ( ) ; $ this -> registerQueue ( ) ; }
3414	public function fill ( $ fields ) { if ( ! is_array ( $ fields ) ) { return ; } if ( isset ( $ fields [ 'ID' ] ) ) { $ this -> id = $ fields [ 'ID' ] ; } $ this -> fields = $ fields ; $ this -> fieldsAreFetched = true ; if ( method_exists ( $ this , 'afterFill' ) ) { $ this -> afterFill ( ) ; } $ this -> original = $ this -> fields ; }
6242	public function reload ( ) : self { if ( $ this -> loaded === false ) { return $ this ; } clearstatcache ( false , $ this -> raw ) ; $ this -> loaded = false ; return $ this ; }
3279	protected function replace ( string $ key , $ data ) { $ tmpFile = $ this -> getDatabase ( ) -> openTempFile ( ) ; $ file = $ this -> getDatabase ( ) -> readFromFile ( ) ; foreach ( $ file as $ line ) { if ( $ line -> getKey ( ) == $ key ) { if ( $ data !== false ) { $ tmpFile -> fwrite ( $ this -> getLineString ( $ key , $ data ) ) ; } } else { $ tmpFile -> fwrite ( $ line -> getLine ( ) . "\n" ) ; } } $ tmpFile -> rewind ( ) ; $ this -> getDatabase ( ) -> writeTempToFile ( $ tmpFile ) ; if ( $ cache = $ this -> getConfig ( ) -> getCache ( ) ) { $ cache -> delete ( $ key ) ; } }
4471	public function requeue ( ? string $ queue = null , array $ opts = [ ] ) : string { $ opts = array_merge ( [ 'delay' => 0 , 'data' => $ this -> data , 'priority' => $ this -> priority , 'retries' => $ this -> retries , 'tags' => $ this -> tags , 'depends' => $ this -> dependencies , ] , $ opts ) ; $ queueName = $ queue ? : $ this -> queue ; $ data = json_encode ( $ opts [ 'data' ] , JSON_UNESCAPED_SLASHES ) ? : '{}' ; return $ this -> client -> requeue ( $ this -> worker , $ queueName , $ this -> jid , $ this -> klass , $ data , $ opts [ 'delay' ] , 'priority' , $ opts [ 'priority' ] , 'tags' , json_encode ( $ opts [ 'tags' ] , JSON_UNESCAPED_SLASHES ) , 'retries' , $ opts [ 'retries' ] , 'depends' , json_encode ( $ opts [ 'depends' ] , JSON_UNESCAPED_SLASHES ) ) ; }
4039	protected function getClassForOption ( $ index ) { $ intSub = ( $ this -> arrConfiguration [ 'includeBlankOption' ] ? - 1 : 1 ) ; $ strClass = $ this -> strName ; if ( $ index == 0 ) { $ strClass .= ' first' ; } elseif ( $ index === ( count ( $ this -> options ) - $ intSub ) ) { $ strClass .= ' last' ; } if ( ( $ index % 2 ) == 1 ) { $ strClass .= ' even' ; } else { $ strClass .= ' odd' ; } return ( ( strlen ( $ this -> strClass ) ) ? ' ' . $ this -> strClass : '' ) . $ strClass ; }
10418	public static function extract ( $ yamlArray , $ key , $ needed = false ) { if ( ! empty ( $ yamlArray ) && array_key_exists ( $ key , $ yamlArray ) ) return $ yamlArray [ $ key ] ; if ( $ needed ) { throw new \ Deployer \ Exception \ Exception ( 'Cannot find the setting: ' . $ key . '. This key needs to be given!' ) ; } return null ; }
6191	public function run ( $ controller = null , $ action = null , $ args = [ ] ) { $ this -> router = $ this -> router -> boot ( $ this ) ; if ( is_null ( $ controller ?? null ) and is_null ( $ action ?? null ) ) { $ this -> router -> parseGets ( ) ; $ controller = $ this -> router -> controller ; $ action = $ this -> router -> action ; $ namespace = $ this -> router -> namespace ; } $ loader = new Loader ( $ this -> baseClass ) ; $ Controller = $ loader -> loadController ( $ controller , $ namespace ?? '\\' ) ; $ response = [ ] ; if ( method_exists ( $ Controller , 'start' ) ) { $ response [ ] = [ 'start' , [ ] ] ; } if ( method_exists ( $ Controller , 'init' ) ) { $ response [ ] = [ 'init' , [ ] ] ; } if ( method_exists ( $ Controller , $ action ) or is_callable ( [ $ Controller , $ action ] ) ) { $ response [ ] = [ $ action , $ args ] ; } if ( method_exists ( $ Controller , 'end' ) ) { $ response [ ] = [ 'end' , [ ] ] ; } foreach ( $ response as $ key => $ data ) { $ run = call_user_func_array ( [ $ Controller , $ data [ 0 ] ] , $ data [ 1 ] ) ; if ( $ run instanceof Response ) { if ( isset ( $ this -> debug ) ) { $ this -> debug -> addHeader ( [ 'X-DF-Debug-Controller' => $ controller ] ) ; $ this -> debug -> addHeader ( [ 'X-DF-Debug-Method' => $ action ] ) ; $ run -> headers ( $ this -> debug -> getHeader ( ) ) ; } return $ run -> display ( ) ; } } return true ; }
12863	protected function getCachedIdentityService ( Cache $ cache , array $ options ) : CachedIdentityService { if ( ! isset ( $ options [ 'authUrl' ] ) ) { throw new \ InvalidArgumentException ( "'authUrl' is a required option" ) ; } $ stack = HandlerStack :: create ( ) ; if ( ! empty ( $ options [ 'debugLog' ] ) && ! empty ( $ options [ 'logger' ] ) && ! empty ( $ options [ 'messageFormatter' ] ) ) { $ stack -> push ( GuzzleMiddleware :: log ( $ options [ 'logger' ] , $ options [ 'messageFormatter' ] ) ) ; } $ clientOptions = [ 'base_uri' => Utils :: normalizeUrl ( $ options [ 'authUrl' ] ) , 'handler' => $ stack , ] ; if ( isset ( $ options [ 'requestOptions' ] ) ) { $ clientOptions = array_merge ( $ options [ 'requestOptions' ] , $ clientOptions ) ; } $ service = CachedIdentityService :: factory ( new Client ( $ clientOptions ) ) ; $ service -> setCache ( $ cache ) ; return $ service ; }
6116	public function serverGetByName ( $ name ) { foreach ( $ this -> serverList ( ) as $ server ) { if ( $ server [ "virtualserver_name" ] == $ name ) { return $ server ; } } throw new Ts3Exception ( "invalid serverID" , 0x400 ) ; }
4057	private function convertAttribute ( array $ property , $ condition , array & $ legend ) { if ( ! isset ( $ property [ 'col_name' ] ) ) { return ; } $ legend [ 'properties' ] [ ] = [ 'name' => $ property [ 'col_name' ] , 'condition' => $ condition ( $ property ) ] ; }
6459	public function fillInWithValueOfFieldOfCurrentUser ( $ field , $ user_field ) { if ( ! empty ( $ this -> user ) && ! $ this -> user -> uid ) { throw new \ Exception ( 'Anonymous user have no fields' ) ; } $ entity = new EntityDrupalWrapper ( 'user' ) ; $ wrapper = $ entity -> wrapper ( $ this -> user -> uid ) ; $ user_field = $ entity -> getFieldNameByLocator ( $ user_field ) ; if ( empty ( $ wrapper -> { $ user_field } ) ) { throw new \ InvalidArgumentException ( sprintf ( 'User entity has no "%s" field.' , $ user_field ) ) ; } $ value = $ wrapper -> { $ user_field } -> value ( ) ; if ( empty ( $ value ) ) { throw new \ UnexpectedValueException ( 'The value of "%s" field is empty.' , $ user_field ) ; } $ this -> fillField ( $ field , $ value ) ; }
4295	public function alert ( $ message , $ class = 'danger' , $ dismissible = false ) { array ( $ class , $ dismissible ) ; $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) , array ( 'message' => null , 'class' => 'danger' , 'dismissible' => false , ) , array ( 'class' , 'dismissible' ) ) ; \ extract ( $ args ) ; $ this -> setLogDest ( 'alerts' ) ; $ this -> appendLog ( 'alert' , array ( $ message ) , $ meta ) ; $ this -> setLogDest ( 'auto' ) ; }
4360	public static function dump ( $ str , $ useHtml = false , $ sanitizeNonBinary = false ) { self :: $ useHtml = $ useHtml ; self :: $ sanitizeNonBinary = $ sanitizeNonBinary ; self :: setStr ( $ str ) ; $ controlCharAs = 'other' ; $ curBlockType = 'utf8' ; $ newBlockType = null ; $ curBlockStart = 0 ; $ strNew = '' ; while ( self :: $ curI < self :: $ stats [ 'strLen' ] ) { $ curI = self :: $ curI ; $ isUtf8 = self :: isOffsetUtf8 ( $ isSpecial , true ) ; if ( $ isUtf8 && $ isSpecial && $ controlCharAs !== 'utf8special' && \ ord ( $ str [ $ curI ] ) < 0x80 ) { if ( $ controlCharAs == 'other' ) { $ isUtf8 = false ; } elseif ( $ controlCharAs == 'utf8' ) { $ isSpecial = false ; } } if ( $ isUtf8 ) { if ( $ isSpecial ) { if ( $ curBlockType !== 'utf8special' ) { $ newBlockType = 'utf8special' ; } } else { if ( $ curBlockType !== 'utf8' ) { $ newBlockType = 'utf8' ; } } } else { if ( $ curBlockType !== 'other' ) { $ newBlockType = 'other' ; } } if ( $ newBlockType ) { $ len = $ curI - $ curBlockStart ; self :: incStat ( $ curBlockType , $ len ) ; $ subStr = \ substr ( self :: $ str , $ curBlockStart , $ len ) ; $ strNew .= self :: dumpBlock ( $ subStr , $ curBlockType ) ; $ curBlockStart = $ curI ; $ curBlockType = $ newBlockType ; $ newBlockType = null ; } } $ len = self :: $ stats [ 'strLen' ] - $ curBlockStart ; self :: incStat ( $ curBlockType , $ len ) ; if ( self :: $ stats [ 'strLen' ] ) { $ percentOther = ( self :: $ stats [ 'bytesOther' ] ) / self :: $ stats [ 'strLen' ] * 100 ; if ( $ percentOther > 33 ) { $ strNew = self :: dumpBlock ( $ str , 'other' , array ( 'prefix' => false ) ) ; } else { $ subStr = \ substr ( self :: $ str , $ curBlockStart , $ len ) ; $ strNew .= self :: dumpBlock ( $ subStr , $ curBlockType ) ; } } return $ strNew ; }
7251	protected function validateIdentity ( SaleInterface $ sale , Constraint $ constraint ) { if ( null === $ sale -> getCustomer ( ) ) { if ( null === $ sale -> getCustomerGroup ( ) ) { $ this -> context -> buildViolation ( $ constraint -> customer_group_is_required_if_no_customer ) -> atPath ( 'customerGroup' ) -> addViolation ( ) ; } if ( 0 == strlen ( $ sale -> getEmail ( ) ) ) { $ this -> context -> buildViolation ( $ constraint -> email_is_required_if_no_customer ) -> atPath ( 'email' ) -> addViolation ( ) ; } IdentityValidator :: validateIdentity ( $ this -> context , $ sale ) ; } }
10261	public function getEmail ( $ person_name = null , $ domain = null ) { $ username = $ this -> getUsername ( $ person_name ) ; $ domains = [ ] ; $ domains [ ] = ! empty ( $ domain ) ? $ domain : $ this -> getDomain ( ) ; $ domains [ ] = 'gmail.com' ; $ domains [ ] = 'yahoo.com' ; $ domains [ ] = 'me.com' ; $ domains [ ] = 'msn.com' ; $ domains [ ] = 'hotmail.com' ; $ domain = $ this -> fromArray ( $ domains ) ; return preg_replace ( '/[^0-9a-z_A-Z.]/' , '' , strtolower ( $ username ) ) . '@' . $ domain ; }
2212	public function fetchField ( $ intOffset = 0 ) { $ arrFields = array_values ( $ this -> resultSet [ $ this -> intIndex ] ) ; return $ arrFields [ $ intOffset ] ; }
3373	public function indexAction ( ) { $ request = $ this -> getRequest ( ) ; $ this -> httpClient -> setMethod ( Request :: METHOD_POST ) ; $ this -> httpClient -> setParameterPost ( [ 'dsl_text' => $ request -> getPost ( 'dsl_text' ) ] ) ; $ response = $ this -> httpClient -> send ( ) ; if ( ! $ response -> isSuccess ( ) ) { throw new \ UnexpectedValueException ( 'HTTP Request failed' ) ; } $ redirect = $ this -> plugin ( 'redirect' ) ; return $ redirect -> toUrl ( 'https://yuml.me/' . $ response -> getBody ( ) ) ; }
11680	public function setPath ( $ path ) { if ( $ path === null ) { throw new PathCanNotBeNull ( ) ; } $ this -> path = rtrim ( $ path , '\\/' ) . '/' ; return $ this ; }
3563	protected function getMutator ( $ value , $ dir = 'setter' , $ type = null ) { $ type = $ type ? : $ this -> getValueType ( $ value ) ; foreach ( $ this -> { "{$dir}Mutators" } as $ mutated => $ mutator ) { if ( $ type == $ mutated || $ value instanceof $ mutated ) { return $ mutator ; } } }
8538	public function setOffer ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'Offer' ] [ 'FieldValue' ] = $ value ; return $ this ; }
12349	public function getTaxonomy ( $ system_id ) { foreach ( $ this -> getTaxonomies ( ) as $ taxonomy ) { if ( $ taxonomy -> system_id === $ system_id ) { return $ taxonomy ; } } return false ; }
9385	public function getGroupedIcons ( ) { if ( $ icons = self :: cache ( ) -> get ( $ this -> getCacheKey ( ) ) ) { return $ icons ; } $ icons = [ ] ; $ data = Yaml :: parse ( $ this -> getSourceData ( ) ) ; if ( isset ( $ data [ 'icons' ] ) ) { foreach ( $ data [ 'icons' ] as $ icon ) { foreach ( $ icon [ 'categories' ] as $ category ) { if ( ! isset ( $ icons [ $ category ] ) ) { $ icons [ $ category ] = [ ] ; } $ icons [ $ category ] [ $ icon [ 'id' ] ] = [ 'name' => $ icon [ 'name' ] , 'unicode' => $ icon [ 'unicode' ] ] ; } } } ksort ( $ icons ) ; foreach ( $ icons as & $ group ) { uasort ( $ group , function ( $ a , $ b ) { return strcasecmp ( $ a [ 'name' ] , $ b [ 'name' ] ) ; } ) ; } self :: cache ( ) -> set ( $ this -> getCacheKey ( ) , $ icons ) ; return $ icons ; }
11832	public function getCache ( ) { if ( ! $ this -> cache ) { $ services = $ this -> getServices ( ) ; $ cache = $ services -> get ( 'Cache' ) ; $ this -> setCache ( $ cache ) ; } return $ this -> cache ; }
7327	private function configureIdentityMapping ( LoadClassMetadataEventArgs $ eventArgs ) { $ metadata = $ eventArgs -> getClassMetadata ( ) ; $ class = $ metadata -> getName ( ) ; if ( ! is_subclass_of ( $ class , IdentityInterface :: class ) ) { return ; } if ( in_array ( $ class , $ this -> identityClassCache ) ) { return ; } $ this -> addMappings ( $ metadata , $ this -> getIdentityMappings ( ) ) ; $ this -> identityClassCache [ ] = $ class ; }
12708	public static function runCommand ( string $ command , array $ arguments = null , array $ options = null ) : void { $ commandObject = new $ command ( $ arguments , $ options ) ; $ commandObject -> update ( $ arguments , $ options ) ; $ commandObject -> handle ( ) ; }
1588	public function getMeta ( ) { $ meta = $ this -> hasMeta ( ) ? $ this -> get ( DocumentInterface :: KEYWORD_META ) : new StandardObject ( ) ; if ( ! is_null ( $ meta ) && ! $ meta instanceof StandardObjectInterface ) { throw new RuntimeException ( 'Data member is not an object.' ) ; } return $ meta ; }
11685	public function getCachePath ( ) { if ( empty ( $ this -> basePath ) ) { return false ; } $ cachePath = $ this -> basePath . DIRECTORY_SEPARATOR . 'cache' ; if ( ! is_dir ( $ cachePath ) ) { @ mkdir ( $ cachePath , 0777 , true ) ; } if ( ! is_dir ( $ cachePath ) ) { return false ; } return $ cachePath ; }
5632	protected function removeTrailingSlash ( $ path ) { if ( substr ( $ path , - 1 ) == DIRECTORY_SEPARATOR ) { return substr ( $ path , 0 , - 1 ) ; } elseif ( substr ( $ path , - 1 ) == '/' ) { return substr ( $ path , 0 , - 1 ) ; } else { return $ path ; } }
8648	private function addRequiredParameters ( array $ parameters ) { $ parameters [ 'AWSAccessKeyId' ] = $ this -> awsAccessKeyId ; $ parameters [ 'Timestamp' ] = $ this -> getFormattedTimestamp ( new DateTime ( 'now' , new DateTimeZone ( 'UTC' ) ) ) ; $ parameters [ 'Version' ] = self :: SERVICE_VERSION ; $ parameters [ 'SignatureVersion' ] = $ this -> config [ 'SignatureVersion' ] ; if ( $ parameters [ 'SignatureVersion' ] > 1 ) { $ parameters [ 'SignatureMethod' ] = $ this -> config [ 'SignatureMethod' ] ; } $ parameters [ 'Signature' ] = $ this -> signParameters ( $ parameters , $ this -> awsSecretAccessKey ) ; return $ parameters ; }
10468	public static function getConversionFactor ( Uom $ from , Uom $ to ) { if ( $ from -> isSameValueAs ( $ to ) ) { return new Fraction ( 1 ) ; } if ( ! isset ( static :: $ conversions ) ) { static :: $ conversions = json_decode ( utf8_encode ( file_get_contents ( __DIR__ . '/conversions.json' ) ) , true ) ; } if ( isset ( static :: $ conversions [ $ from -> getName ( ) ] [ $ to -> getName ( ) ] ) ) { $ numeratorDenominatorPair = static :: $ conversions [ $ from -> getName ( ) ] [ $ to -> getName ( ) ] ; } elseif ( isset ( static :: $ conversions [ $ to -> getName ( ) ] [ $ from -> getName ( ) ] ) ) { $ numeratorDenominatorPair = array_reverse ( static :: $ conversions [ $ to -> getName ( ) ] [ $ from -> getName ( ) ] ) ; } else { throw new ConversionNotSetException ( $ from -> getName ( ) , $ to -> getName ( ) ) ; } if ( count ( $ numeratorDenominatorPair ) == 2 ) { return new Fraction ( $ numeratorDenominatorPair [ 0 ] , $ numeratorDenominatorPair [ 1 ] ) ; } else { throw new BadConversionException ( ) ; } }
7652	public function url_stat ( $ path , $ flags ) { $ stat = array ( ) ; $ stat [ 'dev' ] = 0 ; $ stat [ 'ino' ] = 0 ; $ stat [ 'mode' ] = 0 ; $ stat [ 'nlink' ] = 0 ; $ stat [ 'uid' ] = 0 ; $ stat [ 'gid' ] = 0 ; $ stat [ 'rdev' ] = 0 ; $ stat [ 'size' ] = 0 ; $ stat [ 'atime' ] = 0 ; $ stat [ 'mtime' ] = 0 ; $ stat [ 'ctime' ] = 0 ; $ stat [ 'blksize' ] = 0 ; $ stat [ 'blocks' ] = 0 ; $ info = null ; try { $ info = $ this -> getStorageClient ( $ path ) -> getBlobInstance ( $ this -> getContainerName ( $ path ) , $ this -> getFileName ( $ path ) ) ; $ stat [ 'size' ] = $ info -> Size ; $ lastmodified = strtotime ( $ info -> LastModified ) ; $ stat [ 'mtime' ] = $ lastmodified ; $ stat [ 'ctime' ] = $ lastmodified ; $ stat [ 'mode' ] = 0100000 ; return array_values ( $ stat ) + $ stat ; } catch ( BlobException $ ex ) { return false ; } }
9857	public function isValid ( Cell $ cell ) { if ( ! $ cell -> hasDataValidation ( ) ) { return true ; } $ cellValue = $ cell -> getValue ( ) ; $ dataValidation = $ cell -> getDataValidation ( ) ; if ( ! $ dataValidation -> getAllowBlank ( ) && ( $ cellValue === null || $ cellValue === '' ) ) { return false ; } switch ( $ dataValidation -> getType ( ) ) { case DataValidation :: TYPE_LIST : return $ this -> isValueInList ( $ cell ) ; } return false ; }
10297	private function writeTitle ( XMLWriter $ objWriter , Title $ title = null ) { if ( $ title === null ) { return ; } $ objWriter -> startElement ( 'c:title' ) ; $ objWriter -> startElement ( 'c:tx' ) ; $ objWriter -> startElement ( 'c:rich' ) ; $ objWriter -> startElement ( 'a:bodyPr' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'a:lstStyle' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'a:p' ) ; $ caption = $ title -> getCaption ( ) ; if ( ( is_array ( $ caption ) ) && ( count ( $ caption ) > 0 ) ) { $ caption = $ caption [ 0 ] ; } $ this -> getParentWriter ( ) -> getWriterPart ( 'stringtable' ) -> writeRichTextForCharts ( $ objWriter , $ caption , 'a' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ this -> writeLayout ( $ objWriter , $ title -> getLayout ( ) ) ; $ objWriter -> startElement ( 'c:overlay' ) ; $ objWriter -> writeAttribute ( 'val' , 0 ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; }
4269	public function dir_readdir ( ) { if ( ! $ this -> handle ) { return false ; } self :: restorePrev ( ) ; $ success = \ readdir ( $ this -> handle ) ; self :: register ( ) ; return $ success ; }
11744	public function register ( $ name , $ tel , $ email , $ industryId , array $ certUrls , $ reason = '' ) { $ params = [ 'name' => $ name , 'phone_number' => strval ( $ tel ) , 'email' => $ email , 'industry_id' => $ industryId , 'qualification_cert_urls' => $ certUrls , ] ; if ( $ reason !== '' ) { $ params [ 'apply_reason' ] = $ reason ; } return $ this -> parseJSON ( 'json' , [ self :: API_ACCOUNT_REGISTER , $ params ] ) ; }
8727	public function getDirty ( ) { $ dirty = parent :: getDirty ( ) ; if ( ! $ this -> localeChanged ) { return $ dirty ; } foreach ( $ this -> translatableAttributes ( ) as $ key ) { if ( isset ( $ this -> attributes [ $ key ] ) ) { $ dirty [ $ key ] = $ this -> attributes [ $ key ] ; } } return $ dirty ; }
4706	public function each ( callable $ callable ) { foreach ( $ this -> objects as $ key => $ value ) { if ( false === call_user_func_array ( $ callable , array ( $ value , $ key ) ) ) { break ; } } return $ this ; }
709	public function string ( $ length = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_STRING , $ length ) ; }
8545	public function setGuaranteeClaimEventList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'GuaranteeClaimEventList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
10106	private function writeDefcol ( ) { $ defaultColWidth = 8 ; $ record = 0x0055 ; $ length = 0x0002 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ defaultColWidth ) ; $ this -> append ( $ header . $ data ) ; }
9209	protected function findKey ( Table $ Table , Entity $ entity ) { if ( ! empty ( $ entity -> { $ Table -> primaryKey ( ) } ) ) { $ key = $ entity -> { $ Table -> primaryKey ( ) } ; } else { $ key = 'unknown' ; } return $ key ; }
9145	private static function resetLocaleTo ( $ localeSaved ) { $ localeData = explode ( ';' , $ localeSaved ) ; foreach ( $ localeData as $ identifier ) { if ( ! strchr ( $ identifier , '=' ) ) { continue ; } $ type = $ value = null ; sscanf ( $ identifier , "%s=%s" , $ type , $ value ) ; switch ( $ type ) { case 'LC_ALL' : setlocale ( LC_ALL , $ value ) ; break ; case 'LC_COLLATE' : setlocale ( LC_COLLATE , $ value ) ; break ; case 'LC_CTYPE' : setlocale ( LC_CTYPE , $ value ) ; break ; case 'LC_MONETARY' : setlocale ( LC_MONETARY , $ value ) ; break ; case 'LC_NUMERIC' : setlocale ( LC_NUMERIC , $ value ) ; break ; case 'LC_TIME' : setlocale ( LC_TIME , $ value ) ; break ; case 'LC_MESSAGES' : setlocale ( LC_MESSAGES , $ value ) ; break ; default : ; break ; } } }
5099	public function into ( $ table , array $ fields = null ) { $ this -> setPart ( CmdInsert :: PART_INTO , $ table ) ; if ( ! is_null ( $ fields ) ) { $ this -> placeholder = false ; $ this -> fields = $ fields ; } return $ this ; }
6937	private function has ( array & $ list , $ oid , StockUnitInterface $ unit ) { if ( ! isset ( $ list [ $ oid ] ) ) { return false ; } return false !== $ this -> find ( $ list , $ oid , $ unit ) ; }
2574	protected function loadSessionHandlerParams ( $ params ) { if ( isset ( $ params [ 'sessionHandlerParams' ] ) ) { if ( $ params [ 'sessionHandlerParams' ] instanceof SessionHandlerParams ) { $ this -> sessionHandlerParams = $ params [ 'sessionHandlerParams' ] ; } elseif ( is_array ( $ params [ 'sessionHandlerParams' ] ) ) { $ this -> sessionHandlerParams = new SessionHandlerParams ( $ params [ 'sessionHandlerParams' ] ) ; } } }
11461	public static function enable ( $ state = true , $ enable_assert = false ) { $ state = ( bool ) $ state ; self :: enableAssert ( ( bool ) $ enable_assert ) ; if ( $ state && self :: $ _enabled || ! $ state && ! self :: $ _enabled ) { return ; } if ( $ state ) { set_exception_handler ( __CLASS__ . '::exception' ) ; set_error_handler ( __CLASS__ . '::error' , error_reporting ( ) ) ; assert_options ( ASSERT_CALLBACK , __CLASS__ . '::assert' ) ; self :: $ _enabled = true ; } else { restore_exception_handler ( ) ; restore_error_handler ( ) ; assert_options ( ASSERT_CALLBACK , function ( ) { } ) ; self :: $ _enabled = false ; } }
7057	public function hasData ( $ key = null ) { if ( ! is_null ( $ key ) ) { return isset ( $ this -> data [ $ key ] ) ; } return ! empty ( $ this -> data ) ; }
9728	function fromXML ( $ xmlElement ) { if ( isset ( $ xmlElement -> minutes ) ) $ this -> minutes = $ xmlElement -> minutes ; if ( isset ( $ xmlElement -> hours ) ) $ this -> hours = $ xmlElement -> hours ; if ( isset ( $ xmlElement -> state ) ) $ this -> state = $ xmlElement -> state ; if ( isset ( $ xmlElement -> date ) ) $ this -> date = $ xmlElement -> date ; }
9708	private function writeShortNameBiff8 ( $ name , $ sheetIndex , $ rangeBounds , $ isHidden = false ) { $ record = 0x0018 ; $ options = ( $ isHidden ? 0x21 : 0x00 ) ; $ extra = pack ( 'Cvvvvv' , 0x3B , $ sheetIndex - 1 , $ rangeBounds [ 0 ] [ 1 ] - 1 , $ rangeBounds [ 1 ] [ 1 ] - 1 , $ rangeBounds [ 0 ] [ 0 ] - 1 , $ rangeBounds [ 1 ] [ 0 ] - 1 ) ; $ sz = strlen ( $ extra ) ; $ data = pack ( 'vCCvvvCCCCC' , $ options , 0 , 1 , $ sz , 0 , $ sheetIndex , 0 , 0 , 0 , 0 , 0 ) . $ name . $ extra ; $ length = strlen ( $ data ) ; $ header = pack ( 'vv' , $ record , $ length ) ; return $ header . $ data ; }
4616	protected function validate ( ) { if ( ! $ this -> config -> getHost ( ) || ! $ this -> config -> getPort ( ) ) { throw new Node \ Builder \ Exception ( 'Node host address and port number are required.' ) ; } if ( $ this -> config -> getUser ( ) && $ this -> config -> getCertificate ( ) ) { throw new Node \ Builder \ Exception ( 'Connect with password OR certificate authentication, not both.' ) ; } if ( $ this -> config -> isAuth ( ) && ! $ this -> config -> getCaDirectory ( ) && ! $ this -> config -> getCaFile ( ) ) { throw new Node \ Builder \ Exception ( 'Certificate authority file is required for authentication.' ) ; } }
4322	public static function buildAttribString ( $ attribs ) { if ( \ is_string ( $ attribs ) ) { return \ rtrim ( ' ' . \ trim ( $ attribs ) ) ; } $ attribPairs = array ( ) ; foreach ( $ attribs as $ k => $ v ) { if ( \ is_int ( $ k ) ) { $ k = $ v ; $ v = true ; } $ k = \ strtolower ( $ k ) ; if ( \ strpos ( $ k , 'data-' ) === 0 ) { $ v = \ json_encode ( $ v ) ; $ v = \ trim ( $ v , '"' ) ; } elseif ( \ is_bool ( $ v ) ) { $ v = self :: buildAttribBoolVal ( $ k , $ v ) ; } elseif ( \ is_array ( $ v ) || $ k === 'class' ) { $ v = self :: buildAttribArrayVal ( $ k , $ v ) ; } if ( \ array_filter ( array ( $ v === null , $ v === '' && \ in_array ( $ k , array ( 'class' , 'style' ) ) ) ) ) { continue ; } $ v = \ trim ( $ v ) ; $ attribPairs [ ] = $ k . '="' . \ htmlspecialchars ( $ v ) . '"' ; } \ sort ( $ attribPairs ) ; return \ rtrim ( ' ' . \ implode ( ' ' , $ attribPairs ) ) ; }
11787	public static function getAgeByDate ( string $ sBirthday ) : int { list ( $ iYear , $ iMonth , $ iDay ) = preg_split ( '/[-.]/' , $ sBirthday ) ; $ aToday = array ( ) ; $ aToday [ 'mois' ] = date ( 'n' ) ; $ aToday [ 'jour' ] = date ( 'j' ) ; $ aToday [ 'annee' ] = date ( 'Y' ) ; $ iYears = $ aToday [ 'annee' ] - $ iYear ; if ( $ aToday [ 'mois' ] <= $ iMonth ) { if ( $ iMonth == $ aToday [ 'mois' ] ) { if ( $ iDay > $ aToday [ 'jour' ] ) { $ iYears -- ; } } else { $ iYears -- ; } } return $ iYears ; }
2595	public static function findMessage ( $ code ) { $ message = null ; if ( array_key_exists ( $ code , self :: $ errorList ) ) { $ message = self :: $ errorList [ $ code ] ; } return $ message ; }
10593	public function toArray ( ) { return [ 'level' => $ this -> level , 'datetime' => $ this -> datetime -> format ( 'Y-m-d H:i:s' ) , 'header' => $ this -> header , 'stack' => $ this -> stack , ] ; }
120	protected function hasAuth ( ) { if ( null !== $ this -> hasAuth ) { return $ this -> hasAuth ; } if ( false === $ this -> createAuthFromConfig ( ) ) { $ this -> createAuthFromUrl ( ) ; } return $ this -> hasAuth ; }
12382	public static function lastMonth ( ) { $ hits_count = self :: interval ( Carbon :: now ( ) -> subMonth ( ) -> firstOfMonth ( ) , Carbon :: now ( ) -> subMonth ( ) -> lastOfMonth ( ) ) ; return $ hits_count ; }
4052	private function fetchPropertiesFor ( $ inputScreenId , IMetaModel $ metaModel ) : array { $ builder = $ this -> connection -> createQueryBuilder ( ) ; return array_map ( function ( $ column ) use ( $ inputScreenId , $ metaModel ) { if ( 'attribute' !== $ column [ 'dcatype' ] ) { return $ column ; } if ( ! ( $ attribute = $ metaModel -> getAttributeById ( $ column [ 'attr_id' ] ) ) ) { @ trigger_error ( 'Unknown attribute "' . $ column [ 'attr_id' ] . '" in input screen "' . $ inputScreenId . '"' , E_USER_WARNING ) ; return $ column ; } $ column = array_merge ( $ column , $ attribute -> getFieldDefinition ( $ column ) , [ 'col_name' => $ attribute -> getColName ( ) ] ) ; return $ column ; } , $ builder -> select ( '*' ) -> from ( 'tl_metamodel_dcasetting' ) -> where ( 'pid=:pid' ) -> andWhere ( 'published=:published' ) -> setParameter ( 'pid' , $ inputScreenId ) -> setParameter ( 'published' , 1 ) -> orderBy ( 'sorting' ) -> execute ( ) -> fetchAll ( \ PDO :: FETCH_ASSOC ) ) ; }
5062	public function output ( ) : string { if ( is_null ( $ this -> buffer ) ) { $ this -> exec ( ) ; } curl_close ( $ this -> ch ) ; if ( strlen ( $ this -> buffer ) === 0 ) { throw new NoOutputException ( ) ; } return $ this -> buffer ; }
9060	public function setPrimaryKey ( string ... $ key ) : self { $ this -> primaryKey = new PrimaryKey ( $ this , ... $ key ) ; return $ this ; }
11288	protected function _getRelation ( $ attributeName , $ query = false , $ loadMap = false , $ record = false ) { $ def = $ this -> model_attributes [ $ attributeName ] ; $ result = false ; if ( isset ( $ def [ 'models' ] ) ) { $ result = $ this -> _getModels ( $ attributeName , $ def [ 'models' ] , $ query , $ loadMap , $ record ) ; } else if ( isset ( $ def [ 'model' ] ) ) { $ result = $ this -> _getModel ( $ attributeName , $ def [ 'model' ] , $ query , $ loadMap , $ record ) ; } return $ result ; }
2971	public static function processAttachments ( array $ attachments ) { $ processed = [ ] ; foreach ( $ attachments as $ attachment ) { if ( ! ( $ attachment instanceof Attachment ) ) { throw new \ InvalidArgumentException ( 'Attachments must implement Stampie\\Attachment' ) ; } $ name = $ attachment -> getName ( ) ; if ( isset ( $ processed [ $ name ] ) ) { $ name = static :: findUniqueName ( $ name , array_keys ( $ processed ) ) ; } $ processed [ $ name ] = $ attachment ; } return $ processed ; }
7053	public static function get_instance ( ) { if ( ! self :: $ instance instanceof self ) { $ new = new self ; $ new -> init ( ) ; self :: $ instance = $ new ; } return self :: $ instance ; }
2486	public function commit ( $ flush = false ) { $ payload = $ flush ? '<commit/>' : '<commit softCommit="true"/>' ; foreach ( $ this -> endpointResolver -> getEndpoints ( ) as $ endpointName ) { $ result = $ this -> client -> request ( 'POST' , $ this -> endpointRegistry -> getEndpoint ( $ endpointName ) , '/update' , new Message ( array ( 'Content-Type' => 'text/xml' , ) , $ payload ) ) ; if ( $ result -> headers [ 'status' ] !== 200 ) { throw new RuntimeException ( 'Wrong HTTP status received from Solr: ' . $ result -> headers [ 'status' ] . var_export ( $ result , true ) ) ; } } }
10029	function getContactsByFilterId ( $ filterId , $ page_index = 1 , $ page_size = 100 , $ standard_fields = array ( ) , $ custom_fields = array ( ) ) { $ queryParameters = array ( 'page_index' => $ page_index , 'page_size' => $ page_size , 'standard_field' => $ standard_fields ) ; $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , 'custom_field' , $ custom_fields ) ; return $ this -> get ( 'contacts/filter/' . utf8_encode ( $ filterId ) , $ queryParameters ) ; }
12938	public function setMin ( $ value ) { $ this -> setTag ( 'min' , $ value ) ; if ( $ this -> getValidator ( ) ) { $ this -> getValidator ( ) -> setOption ( 'min' , $ value ) ; } }
711	public function smallInteger ( $ length = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_SMALLINT , $ length ) ; }
5358	protected function createParameters ( Operation $ operation , $ queryParamDocumentation , Context $ context ) { $ documentationParams = [ ] ; $ methodParameters = [ ] ; if ( $ operation -> getOperation ( ) -> getParameters ( ) ) { foreach ( $ operation -> getOperation ( ) -> getParameters ( ) as $ key => $ parameter ) { if ( $ parameter instanceof Reference ) { $ parameter = $ this -> resolveParameter ( $ parameter ) ; } if ( $ parameter instanceof PathParameterSubSchema ) { $ methodParameters [ ] = $ this -> pathParameterGenerator -> generateMethodParameter ( $ parameter , $ context , $ operation -> getReference ( ) . '/parameters/' . $ key ) ; $ documentationParams [ ] = sprintf ( ' * @param %s' , $ this -> pathParameterGenerator -> generateDocParameter ( $ parameter , $ context , $ operation -> getReference ( ) . '/parameters/' . $ key ) ) ; } } foreach ( $ operation -> getOperation ( ) -> getParameters ( ) as $ key => $ parameter ) { if ( $ parameter instanceof Reference ) { $ parameter = $ this -> resolveParameter ( $ parameter ) ; } if ( $ parameter instanceof BodyParameter ) { $ methodParameters [ ] = $ this -> bodyParameterGenerator -> generateMethodParameter ( $ parameter , $ context , $ operation -> getReference ( ) . '/parameters/' . $ key ) ; $ documentationParams [ ] = sprintf ( ' * @param %s' , $ this -> bodyParameterGenerator -> generateDocParameter ( $ parameter , $ context , $ operation -> getReference ( ) . '/parameters/' . $ key ) ) ; } } } if ( ! empty ( $ queryParamDocumentation ) ) { $ documentationParams [ ] = " * @param array \$parameters {" ; $ documentationParams = array_merge ( $ documentationParams , array_map ( function ( $ doc ) { return " * " . $ doc ; } , $ queryParamDocumentation ) ) ; $ documentationParams [ ] = " * }" ; } else { $ documentationParams [ ] = " * @param array \$parameters List of parameters" ; } $ documentationParams [ ] = " * @param string \$fetch Fetch mode (object or response)" ; $ methodParameters [ ] = new Param ( 'parameters' , new Expr \ Array_ ( ) ) ; $ methodParameters [ ] = new Param ( 'fetch' , new Expr \ ConstFetch ( new Name ( 'self::FETCH_OBJECT' ) ) ) ; return [ $ documentationParams , $ methodParameters ] ; }
7720	static function f_Misc_UpdateArray ( & $ array , $ numerical , $ v , $ d ) { if ( ! is_array ( $ v ) ) { if ( is_null ( $ v ) ) { $ array = array ( ) ; return ; } else { $ v = array ( $ v => $ d ) ; } } foreach ( $ v as $ p => $ a ) { if ( $ numerical === true ) { if ( is_string ( $ p ) ) { $ i = array_search ( $ p , $ array , true ) ; if ( $ i === false ) { if ( ! is_null ( $ a ) ) $ array [ ] = $ p ; } else { if ( is_null ( $ a ) ) array_splice ( $ array , $ i , 1 ) ; } } else { $ i = array_search ( $ a , $ array , true ) ; if ( $ i == false ) $ array [ ] = $ a ; } } else { if ( is_null ( $ a ) ) { unset ( $ array [ $ p ] ) ; } elseif ( $ numerical === 'frm' ) { self :: f_Misc_FormatSave ( $ a , $ p ) ; } else { $ array [ $ p ] = $ a ; } } } }
565	public function getScriptFile ( ) { if ( $ this -> _scriptFile === null ) { if ( isset ( $ _SERVER [ 'SCRIPT_FILENAME' ] ) ) { $ this -> setScriptFile ( $ _SERVER [ 'SCRIPT_FILENAME' ] ) ; } else { throw new InvalidConfigException ( 'Unable to determine the entry script file path.' ) ; } } return $ this -> _scriptFile ; }
5018	public function isEnabled ( $ field ) { return ! isset ( $ this -> fields [ $ field ] [ 'enabled' ] ) || ( bool ) $ this -> fields [ $ field ] [ 'enabled' ] ; }
6148	public function setBody ( $ body ) { if ( is_string ( $ body ) ) { $ this -> body = $ body ; } elseif ( is_array ( $ body ) ) { $ this -> setJsonBody ( $ body ) ; } elseif ( is_callable ( $ body ) ) { ob_start ( ) ; $ res1 = call_user_func ( $ body ) ; $ res2 = ob_get_contents ( ) ; $ this -> body = $ res2 . $ res1 ; ob_end_clean ( ) ; } return $ this ; }
7852	protected function dispatchWorkflow ( $ workflow ) { $ job = $ this -> inflector -> getJob ( ) ; $ request = $ this -> resolveRequest ( ) ; $ pipes = $ this -> pipelines -> getPipesByPipeline ( $ workflow ) ; $ parameters = $ this -> container -> make ( 'router' ) -> current ( ) -> parameters ( ) ; return $ this -> dispatcher -> pipeThrough ( $ pipes ) -> dispatchFrom ( $ job , $ request , $ parameters ) ; }
2078	public function purgePageCache ( ) { $ strCacheDir = StringUtil :: stripRootDir ( System :: getContainer ( ) -> getParameter ( 'kernel.cache_dir' ) ) ; $ objFolder = new Folder ( $ strCacheDir . '/http_cache' ) ; $ objFolder -> purge ( ) ; $ this -> log ( 'Purged the page cache' , __METHOD__ , TL_CRON ) ; }
1703	protected function getLink ( $ objItem , $ strUrl , $ strBase = '' ) { switch ( $ objItem -> source ) { case 'external' : return $ objItem -> url ; break ; case 'internal' : if ( ( $ objTarget = $ objItem -> getRelated ( 'jumpTo' ) ) instanceof PageModel ) { return $ objTarget -> getAbsoluteUrl ( ) ; } break ; case 'article' : if ( ( $ objArticle = ArticleModel :: findByPk ( $ objItem -> articleId ) ) instanceof ArticleModel && ( $ objPid = $ objArticle -> getRelated ( 'pid' ) ) instanceof PageModel ) { return ampersand ( $ objPid -> getAbsoluteUrl ( '/articles/' . ( $ objArticle -> alias ? : $ objArticle -> id ) ) ) ; } break ; } if ( $ strBase != '' && ! preg_match ( '#^https?://#' , $ strUrl ) ) { $ strUrl = $ strBase . $ strUrl ; } return sprintf ( preg_replace ( '/%(?!s)/' , '%%' , $ strUrl ) , ( $ objItem -> alias ? : $ objItem -> id ) ) ; }
3346	public function request ( $ method , $ path , $ data = array ( ) , $ headers = array ( ) ) { $ ch = curl_init ( sprintf ( 'https://%s%s' , $ this -> api_host , $ path ) ) ; $ this -> __setRequestType ( $ ch , $ method ) ; $ this -> __setHeaders ( $ ch , $ headers , $ data ) ; $ response = curl_exec ( $ ch ) ; if ( $ response === false ) { throw new \ Exception ( curl_error ( $ ch ) ) ; } $ ch_info = curl_getinfo ( $ ch ) ; $ header_size = curl_getinfo ( $ ch , CURLINFO_HEADER_SIZE ) ; $ header = substr ( $ response , 0 , $ header_size ) ; $ body = substr ( $ response , $ header_size ) ; $ error = false ; if ( $ method == 'DELETE' ) { if ( $ ch_info [ 'http_code' ] != 302 && $ ch_info [ 'http_code' ] != 200 ) { $ error = true ; } } else { if ( ! ( ( $ ch_info [ 'http_code' ] >= 200 ) && ( $ ch_info [ 'http_code' ] < 300 ) ) ) { $ error = true ; } } if ( $ ch_info [ 'http_code' ] == 429 ) { $ exception = new ThrottledRequestException ( ) ; $ response_headers = Helper :: parseHttpHeaders ( $ header ) ; $ exception -> setResponseHeaders ( $ response_headers ) ; throw $ exception ; } if ( $ error ) { $ errorInfo = array_filter ( array ( curl_error ( $ ch ) , $ body ) ) ; throw new \ Exception ( 'Request returned unexpected http code ' . $ ch_info [ 'http_code' ] . '. ' . join ( ', ' , $ errorInfo ) ) ; } curl_close ( $ ch ) ; if ( ! defined ( 'PHPUNIT_UPLOADCARE_TESTSUITE' ) && ( $ this -> public_key == 'demopublic_key' || $ this -> secret_key == 'demoprivatekey' ) ) { trigger_error ( 'You are using the demo account. Please get an Uploadcare account at https://uploadcare.com/accounts/create/' , E_USER_WARNING ) ; } return json_decode ( $ body ) ; }
3350	private function __getPath ( $ type , $ params = array ( ) ) { switch ( $ type ) { case 'root' : return '/' ; case 'account' : return '/account/' ; case 'file_list' : return '/files/' . $ this -> __getQueryString ( $ params , '?' ) ; case 'file_storage' : if ( array_key_exists ( 'uuid' , $ params ) == false ) { throw new \ Exception ( 'Please provide "uuid" param for request' ) ; } return sprintf ( '/files/%s/storage/' , $ params [ 'uuid' ] ) ; case 'file_copy' : return '/files/' ; case 'files_storage' : return '/files/storage/' ; case 'file' : if ( array_key_exists ( 'uuid' , $ params ) == false ) { throw new \ Exception ( 'Please provide "uuid" param for request' ) ; } return sprintf ( '/files/%s/' , $ params [ 'uuid' ] ) ; case 'group_list' : return '/groups/' . $ this -> __getQueryString ( $ params , '?' ) ; case 'group' : if ( array_key_exists ( 'uuid' , $ params ) == false ) { throw new \ Exception ( 'Please provide "uuid" param for request' ) ; } return sprintf ( '/groups/%s/' , $ params [ 'uuid' ] ) ; case 'group_storage' : if ( array_key_exists ( 'uuid' , $ params ) == false ) { throw new \ Exception ( 'Please provide "uuid" param for request' ) ; } return sprintf ( '/groups/%s/storage/' , $ params [ 'uuid' ] ) ; default : throw new \ Exception ( 'No api url type is provided for request "' . $ type . '". Use store, or appropriate constants.' ) ; } }
3449	public function setAttribute ( $ key , $ value ) { if ( in_array ( $ key , $ this -> multipleHighloadBlockFields ) ) { $ this -> attributes [ $ key ] = serialize ( $ value ) ; return $ this ; } parent :: setAttribute ( $ key , $ value ) ; return $ this ; }
995	private function getDeprecationReason ( $ node ) { $ deprecated = Values :: getDirectiveValues ( Directive :: deprecatedDirective ( ) , $ node ) ; return $ deprecated [ 'reason' ] ?? null ; }
4211	public static function getConstants ( $ phpVer = null ) { $ phpVer = $ phpVer ? : PHP_VERSION ; $ phpVer = \ preg_match ( '/^\d+\.\d+$/' , $ phpVer ) ? $ phpVer . '.0' : $ phpVer ; $ constants = array ( 'E_ERROR' => 1 , 'E_WARNING' => 2 , 'E_PARSE' => 4 , 'E_NOTICE' => 8 , 'E_CORE_ERROR' => 16 , 'E_CORE_WARNING' => 32 , 'E_COMPILE_ERROR' => 64 , 'E_COMPILE_WARNING' => 128 , 'E_USER_ERROR' => 256 , 'E_USER_WARNING' => 512 , 'E_USER_NOTICE' => 1024 , 'E_STRICT' => \ version_compare ( $ phpVer , '5.0.0' , '>=' ) ? 2048 : null , 'E_RECOVERABLE_ERROR' => \ version_compare ( $ phpVer , '5.2.0' , '>=' ) ? 4096 : null , 'E_DEPRECATED' => \ version_compare ( $ phpVer , '5.3.0' , '>=' ) ? 8192 : null , 'E_USER_DEPRECATED' => \ version_compare ( $ phpVer , '5.3.0' , '>=' ) ? 16384 : null , 'E_ALL' => null , ) ; $ constants = \ array_filter ( $ constants ) ; $ constants [ 'E_ALL' ] = \ array_sum ( $ constants ) ; if ( isset ( $ constants [ 'E_STRICT' ] ) && \ version_compare ( $ phpVer , '5.4.0' , '<' ) ) { $ constants [ 'E_ALL' ] -= $ constants [ 'E_STRICT' ] ; } return $ constants ; }
8054	public function updateCalendarEvent ( $ id , array $ data ) { $ eventData = $ this -> calendarEventsEngine -> buildEventData ( $ data ) ; $ eventDates = $ this -> calendarEventsEngine -> buildEventDates ( $ data ) ; $ cache = $ this -> cache ; $ calendarEventRepeatDate = clone $ this -> calendarEventRepeatDate ; $ calendarEventRepeatDate -> where ( 'calendar_event_id' , $ id ) -> delete ( ) ; $ this -> calendarEvent -> where ( 'id' , $ id ) -> update ( $ eventData ) ; $ calendarEvent = $ this -> calendarEvent -> where ( 'id' , $ id ) -> firstOrFail ( ) ; $ this -> handleEventLocation ( $ data , $ calendarEvent ) ; foreach ( $ eventDates as $ date ) { $ calendarEventRepeatDate = clone $ this -> calendarEventRepeatDate ; $ calendarEventRepeatDate -> start = $ date [ 'start' ] ; $ calendarEventRepeatDate -> end = $ date [ 'end' ] ; $ calendarEventRepeatDate -> calendarEvent ( ) -> associate ( $ calendarEvent ) ; $ calendarEventRepeatDate -> save ( ) ; unset ( $ calendarEventRepeatDate ) ; } $ cache :: put ( self :: CACHE_KEY . $ calendarEvent -> id , $ calendarEvent , $ this -> cacheTimeToLive ) ; $ allEvents = $ this -> getAllEvents ( ) ; $ allEvents -> put ( $ calendarEvent -> id , $ calendarEvent ) ; $ cache :: put ( self :: ALL_EVENTS_KEY , $ allEvents , $ this -> cacheTimeToLive ) ; return true ; }
12398	public function select ( $ select = null ) { $ this -> scope -> select = Parser :: select ( $ select ) ; return $ this ; }
7158	public function compile ( Database $ db = NULL ) : string { if ( $ db === null ) { $ db = \ Mii :: $ app -> db ; } $ value = $ this -> value ( ) ; if ( ! empty ( $ this -> _parameters ) ) { $ params = array_map ( [ $ db , 'quote' ] , $ this -> _parameters ) ; $ value = strtr ( $ value , $ params ) ; } return $ value ; }
8274	public function assertUsername ( $ username , $ config ) { if ( ! is_string ( $ username ) ) { throw new ConfigurationException ( "Username $username must be a string." ) ; } $ len = strlen ( $ username ) ; $ minLen = $ config [ "registration" ] [ "nameLenMin" ] ; $ maxLen = $ config [ "registration" ] [ "nameLenMax" ] ; if ( $ len < $ minLen || $ len > $ maxLen ) { throw new ConfigurationException ( sprintf ( "Length of a username $username must be between %d-%d characters." , $ minLen , $ maxLen ) ) ; } if ( ! $ this -> checkValidNameFormat ( $ username ) ) { throw new ConfigurationException ( "Username $username contains invalid character/s." ) ; } }
7272	public static function deleteWhere ( $ condition = "" , array $ conditionParams = [ ] ) { $ tableName = static :: tableName ( ) ; if ( empty ( $ condition ) ) return Db :: query ( "delete from $tableName" , [ ] , static :: getDbName ( ) , false ) ; else return Db :: query ( " delete from $tableName where $condition " , $ conditionParams , static :: getDbName ( ) , false ) ; }
7700	function MsWord_InitHeaderFooter ( ) { if ( $ this -> MsWord_HeaderFooter !== false ) return ; $ types_ok = array ( 'default' => true , 'first' => false , 'even' => false ) ; $ idx = $ this -> FileGetIdx ( 'word/settings.xml' ) ; if ( $ idx !== false ) { $ Txt = $ this -> TbsStoreGet ( $ idx , 'GetHeaderFooterFile' ) ; $ types_ok [ 'even' ] = ( strpos ( $ Txt , '<w:evenAndOddHeaders/>' ) !== false ) ; unset ( $ Txt ) ; } $ idx = $ this -> FileGetIdx ( 'word/document.xml' ) ; if ( $ idx === false ) return false ; $ Txt = $ this -> TbsStoreGet ( $ idx , 'GetHeaderFooterFile' ) ; $ types_ok [ 'first' ] = ( strpos ( $ Txt , '<w:titlePg/>' ) !== false ) ; $ places = array ( 'header' , 'footer' ) ; $ files = array ( ) ; $ rels = $ this -> OpenXML_Rels_GetObj ( 'word/document.xml' , '' ) ; foreach ( $ places as $ place ) { $ p = 0 ; $ entity = 'w:' . $ place . 'Reference' ; while ( $ loc = clsTbsXmlLoc :: FindStartTag ( $ Txt , $ entity , $ p ) ) { $ p = $ loc -> PosEnd ; $ type = $ loc -> GetAttLazy ( 'w:type' ) ; if ( isset ( $ types_ok [ $ type ] ) && $ types_ok [ $ type ] ) { $ rid = $ loc -> GetAttLazy ( 'r:id' ) ; if ( isset ( $ rels -> TargetLst [ $ rid ] ) ) { $ target = $ rels -> TargetLst [ $ rid ] ; $ files [ ] = array ( 'file' => ( 'word/' . $ target ) , 'type' => $ type , 'place' => $ place ) ; } } } } $ this -> MsWord_HeaderFooter = $ files ; }
6670	public function get_movie_rating ( $ votes ) { $ votations = [ ] ; foreach ( $ votes as $ key => $ value ) { for ( $ i = 0 ; $ i < $ value ; $ i ++ ) { $ votations [ ] = $ key ; } } if ( count ( $ votations ) ) { $ rating = array_sum ( $ votations ) / count ( $ votations ) ; return round ( $ rating , 1 ) ; } return 'N/A' ; }
3459	public function add ( Route $ route ) : void { if ( $ route instanceof Route ) { $ name = $ route -> getName ( ) ; } else { $ name = Route :: generateNameFromPath ( $ route -> getPath ( ) ) ; } $ baseRoute = new SymfonyRoute ( $ route -> getPath ( ) ) ; $ baseRoute -> setMethods ( $ route -> getMethods ( ) ) ; $ this -> routeCollection -> add ( $ name , $ baseRoute ) ; $ this -> routes [ $ name ] = $ route ; }
6963	public function toDate ( ) { if ( $ this -> dt ) return $ this -> dt ; else return AstroDate :: jd ( $ this -> jd , TimeScale :: TT ( ) ) ; }
11075	public function setArray ( string $ key , $ value , callable $ callback = null , array $ ignoredDefaultValue = null ) { if ( $ value instanceof Traversable ) { $ value = iterator_to_array ( $ value ) ; } if ( is_array ( $ value ) ) { if ( is_callable ( $ callback ) ) { $ value = array_map ( $ callback , $ value ) ; } $ this -> set ( $ key , $ value , $ ignoredDefaultValue ) ; } return $ this ; }
11108	public function logRequest ( APIRequest $ request ) : void { $ item = $ this -> cacheItemPool -> getItem ( $ this -> deriveCacheKey ( $ request ) ) ; if ( $ requestCount = $ item -> get ( ) ) { $ item -> set ( $ requestCount + 1 ) ; } else { $ item -> set ( 1 ) -> expiresAfter ( $ this -> perXSeconds ) ; } $ this -> cacheItemPool -> save ( $ item ) ; }
10747	protected function sendItems ( Response $ response , iterable $ items , ? Pagination $ pagination = null , ? int $ total = null ) : Response { $ items = is_array ( $ items ) ? $ items : ( $ items instanceof \ Traversable ? iterator_to_array ( $ items , false ) : [ ] ) ; $ total = $ total ?? count ( $ items ) ; $ start = $ pagination === null ? 0 : $ pagination -> getOffset ( ) ; $ max = $ pagination === null ? 0 : $ pagination -> getMax ( ) ; $ end = max ( min ( ( PHP_INT_MAX - $ max < $ start ? PHP_INT_MAX : $ start + $ max ) , $ total ) - 1 , 0 ) ; return $ this -> sendJson ( $ response -> withHeader ( 'Content-Range' , "items $start-$end/$total" ) , $ items ) ; }
10952	protected function write ( Response $ response , $ body ) : Response { $ response -> getBody ( ) -> write ( ( string ) $ body ) ; return $ response ; }
7672	function TbsLoadSubFileAsTemplate ( $ SubFileLst ) { if ( ! is_array ( $ SubFileLst ) ) $ SubFileLst = array ( $ SubFileLst ) ; $ ok = true ; $ TBS = false ; foreach ( $ SubFileLst as $ SubFile ) { $ idx = $ this -> FileGetIdx ( $ SubFile ) ; if ( $ idx === false ) { $ ok = $ this -> RaiseError ( 'Cannot load "' . $ SubFile . '". The file is not found in the archive "' . $ this -> ArchFile . '".' ) ; } elseif ( $ idx !== $ this -> TbsCurrIdx ) { $ this -> TbsStorePark ( ) ; if ( ! is_string ( $ SubFile ) ) $ SubFile = $ this -> TbsGetFileName ( $ idx ) ; $ this -> TbsStoreLoad ( $ idx , $ SubFile ) ; if ( $ this -> LastReadNotStored ) { if ( $ TBS === false ) { $ this -> TbsSwitchMode ( true ) ; $ MergeAutoFields = $ this -> TbsMergeAutoFields ( ) ; $ TBS = & $ this -> TBS ; } if ( $ this -> LastReadComp <= 0 ) { if ( $ this -> ExtInfo !== false ) { $ i = $ this -> ExtInfo ; $ e = $ this -> ExtEquiv ; if ( isset ( $ i [ 'rpl_what' ] ) ) { $ TBS -> Source = str_replace ( $ i [ 'rpl_what' ] , $ i [ 'rpl_with' ] , $ TBS -> Source ) ; } if ( ( $ e === 'odt' ) && $ TBS -> OtbsClearWriter ) { $ this -> OpenDoc_CleanRsID ( $ TBS -> Source ) ; } if ( ( $ e === 'ods' ) && $ TBS -> OtbsMsExcelCompatibility ) { $ this -> OpenDoc_MsExcelCompatibility ( $ TBS -> Source ) ; } if ( $ e === 'docx' ) { if ( $ TBS -> OtbsSpacePreserve ) $ this -> MsWord_CleanSpacePreserve ( $ TBS -> Source ) ; if ( $ TBS -> OtbsClearMsWord ) $ this -> MsWord_Clean ( $ TBS -> Source ) ; } if ( ( $ e === 'pptx' ) && $ TBS -> OtbsClearMsPowerpoint ) { $ this -> MsPowerpoint_Clean ( $ TBS -> Source ) ; } if ( ( $ e === 'xlsx' ) && $ TBS -> OtbsMsExcelConsistent ) { $ this -> MsExcel_DeleteFormulaResults ( $ TBS -> Source ) ; $ this -> MsExcel_ConvertToRelative ( $ TBS -> Source ) ; } } if ( $ MergeAutoFields ) $ TBS -> LoadTemplate ( null , '+' ) ; } } } } if ( $ TBS !== false ) $ this -> TbsSwitchMode ( false ) ; return $ ok ; }
3871	protected function getLanguage ( $ singleLanguage , $ metaModels ) { if ( ! empty ( $ singleLanguage ) ) { return array ( $ singleLanguage ) ; } elseif ( $ metaModels -> isTranslated ( ) && $ metaModels -> getAvailableLanguages ( ) ) { return $ metaModels -> getAvailableLanguages ( ) ; } return array ( $ GLOBALS [ 'TL_LANGUAGE' ] ) ; }
11312	public static function buildAuthString ( array $ data ) { $ str = array ( ) ; foreach ( $ data as $ k => $ v ) { $ str [ ] = self :: urlEncode ( $ k ) . '="' . self :: urlEncode ( $ v ) . '"' ; } return implode ( ', ' , $ str ) ; }
5318	public function wait ( ) { $ this -> internalWait ( ) ; $ event = $ this -> isSuccessExit ( ) ? 'success' : 'error' ; $ this -> internalEmit ( 'exit' , $ this -> pid ) ; $ this -> internalEmit ( $ event ) ; return $ this ; }
741	public function beforeRun ( $ event ) { $ cacheKey = $ this -> getCacheKey ( ) ; $ fragmentCacheConfiguration = $ this -> getFragmentCacheConfiguration ( ) ; if ( ! $ this -> owner -> view -> beginCache ( $ cacheKey , $ fragmentCacheConfiguration ) ) { $ event -> isValid = false ; } }
3811	protected function transformCondition ( $ condition ) { $ dispatcher = $ GLOBALS [ 'container' ] [ 'event-dispatcher' ] ; $ event = new CreatePropertyConditionEvent ( $ condition , $ this -> getMetaModel ( ) ) ; $ dispatcher -> dispatch ( CreatePropertyConditionEvent :: NAME , $ event ) ; if ( $ event -> getInstance ( ) === null ) { throw new \ RuntimeException ( sprintf ( 'Condition of type %s could not be transformed to an instance.' , $ condition [ 'type' ] ) ) ; } return $ event -> getInstance ( ) ; }
10920	public static function getString ( $ language , $ separator = ',' ) { $ fileName = __DIR__ . '/stop-words/' . $ language . '.txt' ; if ( file_exists ( $ fileName ) ) { return implode ( $ separator , array_map ( 'trim' , file ( $ fileName ) ) ) ; } return '' ; }
10517	private function getMediaIdentifiers ( $ values ) { $ identifiers = [ ] ; foreach ( $ values as $ key => $ id ) { if ( is_int ( $ key ) ) { $ identifiers [ ] = $ id ; } } return $ identifiers ; }
885	public static function getName ( $ value ) { if ( ! self :: has ( $ value ) ) { throw new \ InvalidArgumentException ( sprintf ( 'No custom token was found for "%s".' , $ value ) ) ; } $ tokens = self :: getMapById ( ) ; return 'CT::' . $ tokens [ $ value ] ; }
234	public function unquoteSimpleTableName ( $ name ) { if ( is_string ( $ this -> tableQuoteCharacter ) ) { $ startingCharacter = $ this -> tableQuoteCharacter ; } else { $ startingCharacter = $ this -> tableQuoteCharacter [ 0 ] ; } return strpos ( $ name , $ startingCharacter ) === false ? $ name : substr ( $ name , 1 , - 1 ) ; }
6566	public function request ( array $ data ) { $ data = array_replace ( $ this -> config , $ data ) ; return $ this -> client -> callRequest ( $ data ) ; }
4632	public function responseHeaderCallback ( $ ch , $ header ) { if ( strpos ( $ header , ':' ) ) { list ( $ key , $ value ) = explode ( ':' , $ header , 2 ) ; $ value = trim ( $ value ) ; if ( ! empty ( $ value ) ) { if ( ! isset ( $ this -> responseHeaders [ $ key ] ) ) { $ this -> responseHeaders [ $ key ] = $ value ; } elseif ( is_array ( $ this -> responseHeaders [ $ key ] ) ) { $ this -> responseHeaders [ $ key ] = array_merge ( $ this -> responseHeaders [ $ key ] , [ $ value ] ) ; } else { $ this -> responseHeaders [ $ key ] = array_merge ( [ $ this -> responseHeaders [ $ key ] ] , [ $ value ] ) ; } } } return strlen ( $ header ) ; }
6553	public function unlock ( ) { try { if ( $ this -> pid === $ this -> getSerial ( ) && is_resource ( $ this -> fh ) ) { $ this -> removeLineFromFile ( $ this -> pid , $ this -> fh ) ; flock ( $ this -> fh , LOCK_UN ) ; fclose ( $ this -> fh ) ; if ( filesize ( $ filename = $ this -> getPidFilename ( ) ) === 0 ) { unlink ( $ filename ) ; } } } catch ( FileNotFoundException $ fnfe ) { $ this -> getSystemLogger ( ) -> notice ( sprintf ( 'PID file %s doesn\'t exist' , $ this -> getPidFilename ( ) ) ) ; } catch ( LineNotFoundException $ lnfe ) { $ this -> getSystemLogger ( ) -> notice ( sprintf ( 'PID %s is can not be found in PID file %s' , $ this -> pid , $ this -> getPidFilename ( ) ) ) ; } catch ( \ Exception $ e ) { throw new \ Exception ( sprintf ( 'Can\'t remove PID %s from PID file %s' , $ this -> pid , $ this -> getPidFilename ( ) ) , null , $ e ) ; } }
11616	public function invite ( $ account , $ wechatId ) { $ params = [ 'kf_account' => $ account , 'invite_wx' => $ wechatId , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_INVITE_BIND , $ params ] ) ; }
5553	public function getRequest ( ) { if ( is_integer ( $ this -> focus ) ) { return $ this -> frames [ $ this -> focus ] -> getRequest ( ) ; } return $ this -> frameset -> getRequest ( ) ; }
3520	public function choice ( $ key , $ number , array $ replace = array ( ) , $ locale = null , $ useDB = null ) { $ inplaceEditMode = $ this -> manager -> config ( 'inplace_edit_mode' ) ; if ( $ this -> inPlaceEditing ( ) && $ inplaceEditMode == 2 ) { if ( ! in_array ( $ key , $ this -> usedKeys ) ) { $ this -> usedKeys [ ] = $ key ; } } if ( ! $ this -> suspendInPlaceEdit && $ this -> inPlaceEditing ( ) && $ inplaceEditMode == 1 ) { return $ this -> get ( $ key , $ replace , $ locale , true , $ useDB ) ; } else { if ( $ useDB !== null ) { $ oldUseDB = $ this -> useDB ; $ this -> useDB = $ useDB ; $ retVal = parent :: choice ( $ key , $ number , $ replace , $ locale ) ; $ this -> useDB = $ oldUseDB ; return $ retVal ; } else { return parent :: choice ( $ key , $ number , $ replace , $ locale ) ; } } }
9218	protected function pageNumberToKey ( $ pageNumber ) { if ( isset ( $ this -> pagination [ CanvasPageLink :: CURRENT ] ) ) { return ( $ pageNumber - 1 ) * $ this -> pagination [ CanvasPageLink :: CURRENT ] -> getPerPage ( ) ; } return false ; }
11934	public function walk ( Callable $ callback ) { $ arrayCopy = $ this -> getArrayCopy ( ) ; $ result = array_walk ( $ arrayCopy , $ callback ) ; $ this -> exchangeArray ( $ arrayCopy ) ; return $ result ; }
4319	protected function interpolate ( $ message , array & $ context = array ( ) ) { \ preg_match_all ( '/\{([a-z0-9_.]+)\}/' , $ message , $ matches ) ; $ placeholders = \ array_unique ( $ matches [ 1 ] ) ; $ replace = array ( ) ; foreach ( $ placeholders as $ key ) { if ( ! isset ( $ context [ $ key ] ) ) { continue ; } $ val = $ context [ $ key ] ; if ( ! \ is_array ( $ val ) && ( ! \ is_object ( $ val ) || \ method_exists ( $ val , '__toString' ) ) ) { $ replace [ '{' . $ key . '}' ] = $ val ; } } $ context = \ array_diff_key ( $ context , \ array_flip ( $ placeholders ) ) ; if ( ! $ context ) { $ context = $ this -> debug -> meta ( ) ; } return \ strtr ( $ message , $ replace ) ; }
2611	public function getActiveVersion ( $ service , $ activeVersion ) { $ currActiveVersion = $ this -> determineVersions ( $ service -> versions ) ; if ( $ currActiveVersion [ 'active_version' ] != $ activeVersion ) { throw new LocalizedException ( __ ( 'Active versions mismatch.' ) ) ; } return $ currActiveVersion ; }
3217	function chunkedUploadContinue ( $ uploadId , $ byteOffset , $ data ) { Checker :: argStringNonEmpty ( "uploadId" , $ uploadId ) ; Checker :: argNat ( "byteOffset" , $ byteOffset ) ; Checker :: argString ( "data" , $ data ) ; $ response = $ this -> _chunkedUpload ( array ( "upload_id" => $ uploadId , "offset" => $ byteOffset ) , $ data ) ; if ( $ response -> statusCode === 404 ) { return false ; } $ correction = self :: _chunkedUploadCheckForOffsetCorrection ( $ response ) ; if ( $ correction !== null ) { list ( $ correctedUploadId , $ correctedByteOffset ) = $ correction ; if ( $ correctedUploadId !== $ uploadId ) throw new Exception_BadResponse ( "Corrective 400 upload_id mismatch: us=" . Util :: q ( $ uploadId ) . " server=" . Util :: q ( $ correctedUploadId ) ) ; if ( $ correctedByteOffset === $ byteOffset ) throw new Exception_BadResponse ( "Corrective 400 offset is the same as ours: $byteOffset" ) ; return $ correctedByteOffset ; } if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; list ( $ retUploadId , $ retByteOffset ) = self :: _chunkedUploadParse200Response ( $ response -> body ) ; $ nextByteOffset = $ byteOffset + strlen ( $ data ) ; if ( $ uploadId !== $ retUploadId ) throw new Exception_BadResponse ( "upload_id mismatch: us=" . Util :: q ( $ uploadId ) . ", server=" . Util :: q ( $ uploadId ) ) ; if ( $ nextByteOffset !== $ retByteOffset ) throw new Exception_BadResponse ( "next-offset mismatch: us=$nextByteOffset, server=$retByteOffset" ) ; return true ; }
724	public function getUniqueId ( ) { return $ this -> module instanceof Application ? $ this -> id : $ this -> module -> getUniqueId ( ) . '/' . $ this -> id ; }
9129	public function setInterceptor ( StreamInterceptor $ interceptor ) { $ this -> interceptor = $ interceptor ; stream_filter_append ( $ this -> stdout , $ interceptor -> getFilterName ( ) ) ; }
1950	public function resendToken ( Contao \ DataContainer $ dc ) { $ model = Contao \ OptInModel :: findByPk ( $ dc -> id ) ; Contao \ System :: getContainer ( ) -> get ( 'contao.opt-in' ) -> find ( $ model -> token ) -> send ( ) ; Contao \ Message :: addConfirmation ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'resendToken' ] , $ model -> email ) ) ; Contao \ Controller :: redirect ( $ this -> getReferer ( ) ) ; }
4076	protected function getMetaModelName ( $ nameOrId ) { return isset ( $ this -> tableMap [ $ nameOrId ] ) ? $ this -> tableMap [ $ nameOrId ] : $ nameOrId ; }
7883	public function getDelete ( $ date ) { try { LogViewer :: delete ( $ date ) ; $ today = Carbon :: today ( ) -> format ( 'Y-m-d' ) ; return Redirect :: to ( 'logviewer/' . $ today . '/all' ) -> with ( 'success' , 'Log deleted successfully!' ) ; } catch ( \ Exception $ e ) { return Redirect :: to ( 'logviewer/' . $ date . '/all' ) -> with ( 'error' , 'There was an error while deleting the log.' ) ; } }
5369	protected function isOnlyAscii ( $ ascii ) { for ( $ i = 0 , $ length = strlen ( $ ascii ) ; $ i < $ length ; $ i ++ ) { if ( ord ( $ ascii [ $ i ] ) > 127 ) { return false ; } } return true ; }
573	public function compareString ( $ expected , $ actual ) { if ( ! is_string ( $ expected ) ) { throw new InvalidArgumentException ( 'Expected expected value to be a string, ' . gettype ( $ expected ) . ' given.' ) ; } if ( ! is_string ( $ actual ) ) { throw new InvalidArgumentException ( 'Expected actual value to be a string, ' . gettype ( $ actual ) . ' given.' ) ; } if ( function_exists ( 'hash_equals' ) ) { return hash_equals ( $ expected , $ actual ) ; } $ expected .= "\0" ; $ actual .= "\0" ; $ expectedLength = StringHelper :: byteLength ( $ expected ) ; $ actualLength = StringHelper :: byteLength ( $ actual ) ; $ diff = $ expectedLength - $ actualLength ; for ( $ i = 0 ; $ i < $ actualLength ; $ i ++ ) { $ diff |= ( ord ( $ actual [ $ i ] ) ^ ord ( $ expected [ $ i % $ expectedLength ] ) ) ; } return $ diff === 0 ; }
12914	protected function getWhereAsArray ( ) { $ filters = [ ] ; if ( ! empty ( $ this -> filters ) ) { $ filters = $ this -> filters ; } if ( ! $ this -> allowDeleted ) { $ filters [ ] = "(`" . $ this -> table . "`.deleted = 0 OR `" . $ this -> table . "`.deleted IS NULL)" ; } if ( ! empty ( $ this -> joins ) ) { foreach ( $ this -> joins as $ join ) { $ manager = $ join [ 'manager' ] ; $ filters = array_merge ( $ filters , $ manager -> getWhereAsArray ( ) ) ; } } return $ filters ; }
11578	public function actionResend ( ) { if ( $ this -> module -> enableConfirmation == false ) { throw new NotFoundHttpException ; } $ model = \ Yii :: createObject ( ResendForm :: className ( ) ) ; $ this -> performAjaxValidation ( $ model ) ; if ( $ model -> load ( \ Yii :: $ app -> request -> post ( ) ) && $ model -> resend ( ) ) { return $ this -> render ( '/message' , [ 'title' => \ Yii :: t ( 'user' , 'A new confirmation link has been sent' ) , 'module' => $ this -> module , ] ) ; } return $ this -> render ( 'resend' , [ 'model' => $ model ] ) ; }
8295	public function open ( ) { if ( $ this -> isOpened ( ) ) { return ; } $ this -> handle = @ fopen ( $ this -> filePath , self :: OPEN_MODE ) ; if ( $ this -> handle === false ) { throw new \ RuntimeException ( "Could not open file for writing: " . $ this -> filePath ) ; } if ( ! $ this -> lock ( LOCK_EX ) ) { $ this -> close ( ) ; throw new \ RuntimeException ( "Could not aquire an exclusive lock for " . $ this -> filePath ) ; } if ( $ this -> options [ "backup" ] ) { $ this -> createBkFile ( ) ; } $ this -> writeErrors = false ; }
2285	protected static function server ( ) { $ strServer = ! empty ( $ _SERVER [ 'SERVER_ADDR' ] ) ? $ _SERVER [ 'SERVER_ADDR' ] : $ _SERVER [ 'LOCAL_ADDR' ] ; if ( empty ( $ strServer ) ) { $ strServer = @ gethostbyname ( $ _SERVER [ 'SERVER_NAME' ] ) ; } return $ strServer ; }
1108	protected function validateDuplicates ( ) { return ( ! $ this -> duplicatesExistForColumn ( $ this -> node -> getQualifiedLeftColumnName ( ) ) && ! $ this -> duplicatesExistForColumn ( $ this -> node -> getQualifiedRightColumnName ( ) ) ) ; }
7071	protected function updateMessage ( TicketMessageInterface $ message ) { $ message -> setUpdatedAt ( new \ DateTime ( ) ) ; $ this -> persistenceHelper -> persistAndRecompute ( $ message , true ) ; }
9844	public function createSignedJsonResponse ( int $ status , array $ arrayToJsonify , SigningSecretKey $ key , array $ headers = [ ] , string $ version = '1.1' ) : ResponseInterface { if ( empty ( $ headers [ 'Content-Type' ] ) ) { $ headers [ 'Content-Type' ] = 'application/json' ; } $ body = \ json_encode ( $ arrayToJsonify , JSON_PRETTY_PRINT ) ; if ( ! \ is_string ( $ body ) ) { throw new InvalidMessageException ( 'Cannot JSON-encode this message.' ) ; } return $ this -> createSignedResponse ( $ status , $ body , $ key , $ headers , $ version ) ; }
8812	public function view ( $ view , array $ data = [ ] ) { if ( function_exists ( 'app' ) ) { $ this -> setContent ( app ( 'load' ) -> view ( $ view , $ data ) ) ; return $ this ; } return ; }
1339	public function add ( ResourceIdentifierInterface $ identifier , $ record ) { if ( ! is_object ( $ record ) && ! is_bool ( $ record ) ) { throw new InvalidArgumentException ( 'Expecting an object or a boolean to add to the identity map.' ) ; } $ existing = $ this -> lookup ( $ identifier ) ; if ( is_object ( $ existing ) && is_bool ( $ record ) ) { throw new InvalidArgumentException ( 'Attempting to push a boolean into the map in place of an object.' ) ; } $ this -> map [ $ identifier -> toString ( ) ] = $ record ; return $ this ; }
8681	public function set ( $ key , $ value ) { Deprecated :: method ( 1.1 , MutableBag :: class ) ; $ this -> items [ $ key ] = $ value ; }
10142	private function readDefault ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ this -> pos += 4 + $ length ; }
6162	public function start ( ) { if ( $ this -> isRunning ( ) ) { return ; } $ this -> data [ "realmem_start" ] = memory_get_usage ( true ) ; $ this -> data [ "emalloc_start" ] = memory_get_usage ( ) ; $ this -> started = microtime ( true ) ; $ this -> running = true ; }
12054	public function remove ( $ name ) { if ( isset ( $ this -> container [ $ name ] ) ) { unset ( $ this -> container [ $ name ] ) ; } return $ this ; }
10882	protected function aggregateTernaryValues ( array $ values ) { if ( in_array ( false , $ values , true ) ) { return false ; } elseif ( in_array ( true , $ values , true ) ) { return true ; } else { return null ; } }
2307	protected function doCreateFileList ( $ strFolder = null , $ level = - 1 , $ strFilter = '' ) { if ( $ strFilter === true ) { @ trigger_error ( 'Passing "true" to Backend::doCreateFileList() has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; $ strFilter = 'gif,jpg,jpeg,png' ; } $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; $ arrPages = scan ( $ rootDir . '/' . $ strFolder ) ; if ( empty ( $ arrPages ) ) { return '' ; } if ( \ in_array ( '.htaccess' , $ arrPages ) ) { return '' ; } ++ $ level ; $ strFolders = '' ; $ strFiles = '' ; foreach ( $ arrPages as $ strFile ) { if ( strncmp ( $ strFile , '.' , 1 ) === 0 ) { continue ; } if ( is_dir ( $ rootDir . '/' . $ strFolder . '/' . $ strFile ) ) { $ strFolders .= $ this -> doCreateFileList ( $ strFolder . '/' . $ strFile , $ level , $ strFilter ) ; } else { if ( $ strFilter != '' && ! preg_match ( '/\.(' . str_replace ( ',' , '|' , $ strFilter ) . ')$/i' , $ strFile ) ) { continue ; } $ strFiles .= sprintf ( '<option value="%s"%s>%s</option>' , $ strFolder . '/' . $ strFile , ( ( $ strFolder . '/' . $ strFile == Input :: get ( 'value' ) ) ? ' selected="selected"' : '' ) , StringUtil :: specialchars ( $ strFile ) ) ; } } if ( \ strlen ( $ strFiles ) ) { return '<optgroup label="' . StringUtil :: specialchars ( $ strFolder ) . '">' . $ strFiles . $ strFolders . '</optgroup>' ; } return $ strFiles . $ strFolders ; }
12171	public static function getDefaultForClass ( $ class , array $ params = array ( ) ) { $ reflectionClass = new ReflectionClass ( $ class ) ; if ( ! $ reflectionClass -> isInstantiable ( ) ) { throw new NotInstantiableException ( "Class $class is not instantiable" ) ; } $ factory = new static ( [ $ reflectionClass , 'newInstance' ] , "$class::__construct" ) ; if ( $ reflectionClass -> hasMethod ( '__construct' ) ) { static :: addReflectionArguments ( $ factory , $ reflectionClass -> getMethod ( '__construct' ) ) ; } return $ factory -> getFactory ( $ params ) ; }
8502	public function setMarketplaceIdList ( $ value ) { $ marketplaceIdList = new MarketplaceWebService_Model_IdList ( ) ; $ marketplaceIdList -> setId ( $ value [ 'Id' ] ) ; $ this -> fields [ 'MarketplaceIdList' ] [ 'FieldValue' ] = $ marketplaceIdList ; return ; }
7490	public function reverse ( ) { $ length = $ this -> length ( ) ; $ reversed = '' ; while ( $ length -- > 0 ) { $ reversed .= mb_substr ( $ this -> string , $ length , 1 , $ this -> encoding ) ; } $ this -> string = $ reversed ; return $ this ; }
8829	protected function option ( $ display , $ value , $ selected , array $ attributes = [ ] ) { $ selected = $ this -> getSelectedValue ( $ value , $ selected ) ; $ options = array_merge ( [ 'value' => $ value , 'selected' => $ selected ] , $ attributes ) ; return $ this -> toHtmlString ( '<option' . $ this -> html -> attributes ( $ options ) . '>' . e ( $ display ) . '</option>' ) ; }
8420	public function renderWidget ( $ config = [ ] ) { $ widgetHtml = $ this -> render ( $ this -> template , [ 'name' => $ this -> getModelName ( ) , 'attribute' => $ this -> attribute , 'label' => $ this -> label , 'texture' => $ this -> getTexture ( ) , 'disabled' => $ this -> disabled ] ) ; if ( $ this -> wrap ) { return Html :: tag ( $ this -> wrapper , $ widgetHtml , $ this -> options ) ; } return $ widgetHtml ; }
639	public function renameColumn ( $ table , $ oldName , $ newName ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> renameColumn ( $ table , $ oldName , $ newName ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; }
9621	protected function qsencode ( array $ data = array ( ) ) { $ req = '' ; if ( $ data ) { foreach ( $ data as $ key => $ value ) { $ req .= $ key . '=' . urlencode ( stripslashes ( $ value ) ) . '&' ; } $ req = substr ( $ req , 0 , strlen ( $ req ) - 1 ) ; } return $ req ; }
9790	public function getFormattedValue ( ) { return ( string ) NumberFormat :: toFormattedString ( $ this -> getCalculatedValue ( ) , $ this -> getStyle ( ) -> getNumberFormat ( ) -> getFormatCode ( ) ) ; }
2027	public static function findPublishedRegularWithoutGuestsByIds ( $ arrIds , array $ arrOptions = array ( ) ) { if ( empty ( $ arrIds ) || ! \ is_array ( $ arrIds ) ) { return null ; } $ t = static :: $ strTable ; $ arrColumns = array ( "$t.id IN(" . implode ( ',' , array_map ( '\intval' , $ arrIds ) ) . ") AND $t.type!='error_401' AND $t.type!='error_403' AND $t.type!='error_404'" ) ; if ( empty ( $ arrOptions [ 'includeRoot' ] ) ) { $ arrColumns [ ] = "$t.type!='root'" ; } if ( FE_USER_LOGGED_IN ) { $ arrColumns [ ] = "$t.guests=''" ; } if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = Database :: getInstance ( ) -> findInSet ( "$t.id" , $ arrIds ) ; } return static :: findBy ( $ arrColumns , null , $ arrOptions ) ; }
1184	protected function wrapValidator ( ) { $ resolver = new Resolver ( $ this -> factory ) ; $ this -> factory -> resolver ( $ resolver -> resolver ( $ this -> field ) ) ; $ this -> factory -> extend ( RemoteValidator :: EXTENSION_NAME , $ resolver -> validatorClosure ( ) ) ; }
363	public function renderItems ( ) { $ caption = $ this -> renderCaption ( ) ; $ columnGroup = $ this -> renderColumnGroup ( ) ; $ tableHeader = $ this -> showHeader ? $ this -> renderTableHeader ( ) : false ; $ tableBody = $ this -> renderTableBody ( ) ; $ tableFooter = false ; $ tableFooterAfterBody = false ; if ( $ this -> showFooter ) { if ( $ this -> placeFooterAfterBody ) { $ tableFooterAfterBody = $ this -> renderTableFooter ( ) ; } else { $ tableFooter = $ this -> renderTableFooter ( ) ; } } $ content = array_filter ( [ $ caption , $ columnGroup , $ tableHeader , $ tableFooter , $ tableBody , $ tableFooterAfterBody , ] ) ; return Html :: tag ( 'table' , implode ( "\n" , $ content ) , $ this -> tableOptions ) ; }
6708	protected function getReaderFactory ( ) { if ( ! $ this -> readerFactory ) { $ this -> readerFactory = new ReaderFactory ( [ new Json ( ) , new Xml ( ) , ] ) ; } return $ this -> readerFactory ; }
9947	public function getRowDimension ( $ pRow , $ create = true ) { $ found = null ; if ( ! isset ( $ this -> rowDimensions [ $ pRow ] ) ) { if ( ! $ create ) { return null ; } $ this -> rowDimensions [ $ pRow ] = new RowDimension ( $ pRow ) ; $ this -> cachedHighestRow = max ( $ this -> cachedHighestRow , $ pRow ) ; } return $ this -> rowDimensions [ $ pRow ] ; }
10180	private function storeCurrentCell ( ) { if ( $ this -> currentCellIsDirty && ! empty ( $ this -> currentCoordinate ) ) { $ this -> currentCell -> detach ( ) ; $ stored = $ this -> cache -> set ( $ this -> cachePrefix . $ this -> currentCoordinate , $ this -> currentCell ) ; if ( ! $ stored ) { $ this -> __destruct ( ) ; throw new PhpSpreadsheetException ( "Failed to store cell {$this->currentCoordinate} in cache" ) ; } $ this -> currentCellIsDirty = false ; } $ this -> currentCoordinate = null ; $ this -> currentCell = null ; }
8787	public function script ( $ url , $ attributes = [ ] , $ secure = null ) { $ attributes [ 'src' ] = $ this -> uri -> assets ( $ url , $ secure ) ; return $ this -> toHtmlString ( '<script' . $ this -> attributes ( $ attributes ) . '></script>' . PHP_EOL ) ; }
8367	public static function get ( string $ name ) : array { if ( isset ( self :: $ mappings [ $ name ] ) === false ) { throw new MappingNotFound ( 'there\'s no registered mapping with name "' . $ name . '"' ) ; } return self :: $ mappings [ $ name ] ; }
11410	public function update ( $ tagId , $ name ) { $ params = [ 'tag' => [ 'id' => $ tagId , 'name' => $ name , ] , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_UPDATE , $ params ] ) ; }
1183	protected function getSessionToken ( ) { $ token = null ; if ( $ session = $ this -> app -> __get ( 'session' ) ) { $ token = $ session -> token ( ) ; } if ( $ encrypter = $ this -> app -> __get ( 'encrypter' ) ) { $ token = $ encrypter -> encrypt ( $ token ) ; } return $ token ; }
3630	protected function validateItems ( array $ items , $ type ) { foreach ( $ items as $ item ) { $ this -> validateItem ( $ item , $ type ) ; } }
808	private function sortAlphabetically ( array $ first , array $ second ) { $ firstNamespace = str_replace ( '\\' , ' ' , $ this -> prepareNamespace ( $ first [ 'namespace' ] ) ) ; $ secondNamespace = str_replace ( '\\' , ' ' , $ this -> prepareNamespace ( $ second [ 'namespace' ] ) ) ; return strcasecmp ( $ firstNamespace , $ secondNamespace ) ; }
5348	public function installOperatingSystem ( $ vpsName , $ operatingSystemName , $ hostname ) { return $ this -> call ( self :: SERVICE , 'installOperatingSystem' , [ $ vpsName , $ operatingSystemName , $ hostname ] ) ; }
6781	protected function updateLocale ( SaleInterface $ sale ) { if ( null !== $ sale -> getLocale ( ) ) { return false ; } $ sale -> setLocale ( $ this -> localeProvider -> getCurrentLocale ( ) ) ; return true ; }
10334	public function setName ( $ pValue ) { if ( $ pValue == '' ) { $ pValue = 'Calibri' ; } if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'name' => $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> name = $ pValue ; } return $ this ; }
9982	private function writeVMLComment ( XMLWriter $ objWriter , $ pCellReference , Comment $ pComment ) { list ( $ column , $ row ) = Coordinate :: coordinateFromString ( $ pCellReference ) ; $ column = Coordinate :: columnIndexFromString ( $ column ) ; $ id = 1024 + $ column + $ row ; $ id = substr ( $ id , 0 , 4 ) ; $ objWriter -> startElement ( 'v:shape' ) ; $ objWriter -> writeAttribute ( 'id' , '_x0000_s' . $ id ) ; $ objWriter -> writeAttribute ( 'type' , '#_x0000_t202' ) ; $ objWriter -> writeAttribute ( 'style' , 'position:absolute;margin-left:' . $ pComment -> getMarginLeft ( ) . ';margin-top:' . $ pComment -> getMarginTop ( ) . ';width:' . $ pComment -> getWidth ( ) . ';height:' . $ pComment -> getHeight ( ) . ';z-index:1;visibility:' . ( $ pComment -> getVisible ( ) ? 'visible' : 'hidden' ) ) ; $ objWriter -> writeAttribute ( 'fillcolor' , '#' . $ pComment -> getFillColor ( ) -> getRGB ( ) ) ; $ objWriter -> writeAttribute ( 'o:insetmode' , 'auto' ) ; $ objWriter -> startElement ( 'v:fill' ) ; $ objWriter -> writeAttribute ( 'color2' , '#' . $ pComment -> getFillColor ( ) -> getRGB ( ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'v:shadow' ) ; $ objWriter -> writeAttribute ( 'on' , 't' ) ; $ objWriter -> writeAttribute ( 'color' , 'black' ) ; $ objWriter -> writeAttribute ( 'obscured' , 't' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'v:path' ) ; $ objWriter -> writeAttribute ( 'o:connecttype' , 'none' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'v:textbox' ) ; $ objWriter -> writeAttribute ( 'style' , 'mso-direction-alt:auto' ) ; $ objWriter -> startElement ( 'div' ) ; $ objWriter -> writeAttribute ( 'style' , 'text-align:left' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'x:ClientData' ) ; $ objWriter -> writeAttribute ( 'ObjectType' , 'Note' ) ; $ objWriter -> writeElement ( 'x:MoveWithCells' , '' ) ; $ objWriter -> writeElement ( 'x:SizeWithCells' , '' ) ; $ objWriter -> writeElement ( 'x:AutoFill' , 'False' ) ; $ objWriter -> writeElement ( 'x:Row' , ( $ row - 1 ) ) ; $ objWriter -> writeElement ( 'x:Column' , ( $ column - 1 ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; }
12777	public function render ( ) { $ sort = 0 ; $ query = $ this -> request -> getQuery ( ) ; if ( isset ( $ query [ 'sort' ] ) && isset ( $ this -> columns [ $ query [ 'sort' ] ] ) ) { $ sort = $ query [ 'sort' ] ; } return $ this -> formatter -> render ( $ this -> columns , $ this -> getRecords ( ) , $ this -> dataManager -> getTotalCount ( ) , $ this -> limit , $ this -> page , $ sort ) ; }
11279	public static function applyDataToView ( $ view , $ data ) { if ( ! empty ( $ data ) ) { foreach ( $ data as $ name => $ value ) { if ( is_string ( $ value ) ) { $ view = str_replace ( '{' . $ name . '}' , $ value , $ view ) ; } } } return $ view ; }
6194	protected function loadControllers ( $ path ) { $ this -> app -> config [ 'controller' ] = array_unique ( array_merge ( $ this -> app -> config [ 'controller' ] ?? [ ] , $ path ) ) ; }
5001	public function removeTab ( $ tabName , FormMapper $ formMapper ) { $ tabs = $ this -> getFormTabs ( ) ; if ( array_key_exists ( $ tabName , $ tabs ) ) { $ groups = $ this -> getFormGroups ( ) ; if ( ! is_array ( $ groups ) ) { return ; } foreach ( $ tabs [ $ tabName ] [ 'groups' ] as $ group ) { if ( isset ( $ groups [ $ group ] ) ) { foreach ( $ groups [ $ group ] [ 'fields' ] as $ field ) { $ formMapper -> remove ( $ field ) ; } } unset ( $ groups [ $ group ] ) ; } $ this -> setFormGroups ( $ groups ) ; $ this -> removeEmptyGroups ( ) ; } }
7840	public function addNumber ( int $ id , string $ number ) : ? array { $ response = Request :: put ( $ this -> baseUrl . sprintf ( 'contact/%d/phone-number/%s' , $ id , $ number ) ) ; if ( $ response -> code != 200 ) { if ( ! empty ( $ response -> body -> message ) ) { Log :: error ( $ response -> body -> message ) ; } } return [ 'code' => $ response -> code , 'message' => ( $ response -> code == 200 ) ? 'OK' : $ response -> body -> message ?? '' , 'data' => $ response -> body , ] ; }
8200	public function look ( $ number = 1 ) { if ( ! isset ( $ this -> tokens [ $ this -> current + $ number ] ) ) { throw new Twig_Error_Syntax ( 'Unexpected end of template.' , $ this -> tokens [ $ this -> current + $ number - 1 ] -> getLine ( ) , $ this -> source ) ; } return $ this -> tokens [ $ this -> current + $ number ] ; }
1930	public function attachFile ( $ strFile , $ strMime = 'application/octet-stream' ) { $ this -> objMessage -> attach ( \ Swift_Attachment :: fromPath ( $ strFile , $ strMime ) -> setFilename ( basename ( $ strFile ) ) ) ; }
4985	public function setParam ( $ key , $ value ) { $ this -> params [ $ key ] = $ value ; foreach ( $ this -> forms as $ form ) { if ( isset ( $ form [ '__instance__' ] ) && is_object ( $ form [ '__instance__' ] ) && method_exists ( $ form [ '__instance__' ] , 'setParam' ) ) { $ form [ '__instance__' ] -> setParam ( $ key , $ value ) ; } } return $ this ; }
5964	public function channelGroupGetById ( $ cgid ) { if ( ! array_key_exists ( ( string ) $ cgid , $ this -> channelGroupList ( ) ) ) { throw new Ts3Exception ( "invalid groupID" , 0xA00 ) ; } return $ this -> cgroupList [ intval ( ( string ) $ cgid ) ] ; }
3927	public function setValueOptionsMultiple ( ManipulateWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } if ( $ event -> getModel ( ) -> getProperty ( 'type' ) !== 'conditionpropertycontainanyof' ) { return ; } $ metaModel = $ this -> getMetaModel ( $ event -> getEnvironment ( ) ) ; $ attribute = $ metaModel -> getAttributeById ( $ event -> getModel ( ) -> getProperty ( 'attr_id' ) ) ; if ( ! ( $ attribute && ( $ attribute -> get ( 'type' ) == 'tags' ) ) ) { return ; } $ event -> getWidget ( ) -> multiple = true ; }
3799	private function checkModelWithoutVariants ( $ containedModel ) { $ parentDefinition = $ this -> environment -> getDataDefinition ( ) -> getBasicDefinition ( ) -> getParentDataProvider ( ) ; $ this -> disablePA = ( $ this -> currentModel -> getId ( ) == $ containedModel -> getId ( ) ) || ( $ parentDefinition && $ this -> currentModel -> getProperty ( 'pid' ) == $ containedModel -> getProperty ( 'pid' ) ) ; $ this -> disablePI = ( $ this -> circularReference ) || ( $ this -> currentModel -> getId ( ) == $ containedModel -> getId ( ) ) || ( $ parentDefinition && $ this -> currentModel -> getProperty ( 'pid' ) == $ containedModel -> getId ( ) ) ; }
9503	public function joinCommand ( array $ parts ) { $ command = 'php ' . implode ( ' ' , $ parts ) ; $ stripped = str_replace ( '--watch' , '' , $ command ) ; return trim ( $ stripped ) ; }
8357	public static function extractDomain ( RawRequest $ rawRequest ) { $ domain = null ; if ( preg_match ( "/(?P<domain>[a-z0-9][a-z0-9\-]{1,63}\.[a-z\.]{2,6})$/i" , $ rawRequest -> getHost ( ) , $ matches ) ) { $ domain = $ matches [ 'domain' ] ; } return $ domain ; }
7430	public function addRegion ( RegionInterface $ region ) { $ region -> setCountry ( $ this ) ; $ this -> regions -> add ( $ region ) ; }
6230	public function module ( $ key ) { if ( ! $ this -> core -> modules ( ) -> has ( $ key ) ) { abort ( 404 , 'Module not loaded' ) ; } return $ this -> core -> api ( ) -> response ( $ this -> makeContainer ( $ this -> core -> modules ( ) -> getModulePermissions ( $ key ) ) ) ; }
3813	protected function transformGroupSort ( $ rows ) { foreach ( $ rows as $ row ) { $ this -> groupSort [ ] = new InputScreenGroupingAndSorting ( $ row , $ this ) ; } }
7617	public function api_request ( $ path , $ options ) { $ data = $ this -> requestHandler -> request ( $ path , $ options ) ; return json_encode ( $ data -> json ) ; }
3015	public function deletePost ( $ blogName , $ postId , $ reblogKey ) { $ options = array ( 'id' => $ postId , 'reblog_key' => $ reblogKey ) ; $ path = $ this -> blogPath ( $ blogName , '/post/delete' ) ; return $ this -> postRequest ( $ path , $ options , false ) ; }
9442	public function getManyWithoutReplacement ( $ n ) { if ( ! is_integer ( $ n ) || $ n < 2 ) { throw new \ InvalidArgumentException ( 'You must take 2 or more items in this case.' ) ; } if ( $ this -> range -> as_integer ) { $ arr_range = range ( $ this -> range -> min , $ this -> range -> max ) ; $ max_takable = count ( $ arr_range ) ; shuffle ( $ arr_range ) ; if ( $ n > $ max_takable ) { throw new \ OutOfRangeException ( sprintf ( 'Cannot take without replacement more than available items into range [%d;%d]' , $ this -> range -> min , $ this -> range -> max ) ) ; } elseif ( $ n == $ max_takable ) { return array_values ( $ arr_range ) ; } else { return array_slice ( $ arr_range , 0 , $ n ) ; } } else { $ arr_out = array ( ) ; while ( count ( $ arr_out ) < $ n ) { $ r = $ this -> get ( ) ; if ( ! in_array ( $ r , $ arr_out ) ) { $ arr_out [ ] = $ r ; } } return $ arr_out ; } }
4687	public function where ( ? string $ expression = null , ... $ args ) : self { $ this -> dirty ( ) ; $ this -> where = $ expression ; $ this -> args [ 'where' ] = $ args ; return $ this ; }
7599	public function render ( $ sAlertMessage , $ aAlertAttributes = null , $ bDismissable = false ) { if ( ! is_scalar ( $ sAlertMessage ) ) { throw new InvalidArgumentException ( 'Alert message expects a scalar value, "' . gettype ( $ sAlertMessage ) . '" given' ) ; } if ( empty ( $ aAlertAttributes ) ) { $ aAlertAttributes = array ( 'class' => 'alert' ) ; } elseif ( is_string ( $ aAlertAttributes ) ) { $ aAlertAttributes = array ( 'class' => $ aAlertAttributes ) ; } elseif ( ! is_array ( $ aAlertAttributes ) ) { throw new InvalidArgumentException ( 'Alert attributes expects a string or an array, "' . gettype ( $ aAlertAttributes ) . '" given' ) ; } elseif ( empty ( $ aAlertAttributes [ 'class' ] ) ) { throw new InvalidArgumentException ( 'Alert "class" attribute is empty' ) ; } elseif ( ! is_string ( $ aAlertAttributes [ 'class' ] ) ) { throw new InvalidArgumentException ( 'Alert "class" attribute expects string, "' . gettype ( $ aAlertAttributes ) . '" given' ) ; } if ( ! preg_match ( '/(\s|^)alert(\s|$)/' , $ aAlertAttributes [ 'class' ] ) ) { $ aAlertAttributes [ 'class' ] .= ' alert' ; } if ( null !== ( $ oTranslator = $ this -> getTranslator ( ) ) ) { $ sAlertMessage = $ oTranslator -> translate ( $ sAlertMessage , $ this -> getTranslatorTextDomain ( ) ) ; } if ( $ bDismissable ) { $ sAlertMessage = static :: $ dismissButtonFormat . $ sAlertMessage ; if ( ! preg_match ( '/(\s|^)alert-dismissable(\s|$)/' , $ aAlertAttributes [ 'class' ] ) ) { $ aAlertAttributes [ 'class' ] .= ' alert-dismissable' ; } } return sprintf ( static :: $ alertFormat , $ this -> createAttributesString ( $ aAlertAttributes ) , $ sAlertMessage ) ; }
4945	public function revoke ( $ resource , $ permission = null , $ build = true ) { if ( self :: PERMISSION_NONE == $ permission || ! $ this -> isAssigned ( $ resource ) ) { return $ this ; } if ( self :: PERMISSION_CHANGE == $ permission ) { return $ this -> grant ( $ resource , self :: PERMISSION_VIEW , $ build ) ; } return $ this -> grant ( $ resource , self :: PERMISSION_NONE , $ build ) ; }
5214	private function findBinding ( $ type , $ name ) { $ bindingName = $ this -> bindingName ( $ name ) ; if ( null !== $ bindingName && isset ( $ this -> index [ $ type . '#' . $ bindingName ] ) ) { return $ this -> index [ $ type . '#' . $ bindingName ] ; } if ( isset ( $ this -> index [ $ type ] ) ) { return $ this -> index [ $ type ] ; } if ( ! in_array ( $ type , [ PropertyBinding :: TYPE , ConstantBinding :: TYPE , ListBinding :: TYPE , MapBinding :: TYPE ] ) ) { $ this -> index [ $ type ] = $ this -> getAnnotatedBinding ( new \ ReflectionClass ( $ type ) ) ; return $ this -> index [ $ type ] ; } return null ; }
11051	function build_all ( $ datatree , $ entry ) { if ( ! isset ( $ this -> masktree [ $ entry ] ) ) { $ this -> error ( 8 , 57 , $ entry ) ; } $ this -> datatree = $ datatree ; if ( is_array ( $ this -> datatree ) ) { $ this -> datatree [ '_parent' ] = NULL ; } elseif ( is_object ( $ this -> datatree ) ) { $ this -> datatree -> _parent = NULL ; } elseif ( isset ( $ this -> datatree ) ) { $ this -> error ( 9 , 58 ) ; $ this -> datatree = NULL ; } $ built = $ this -> build_mask ( $ this -> datatree , $ this -> masktree [ $ entry ] ) ; if ( ! isset ( $ this -> masktree [ '0reduce' ] ) ) { $ this -> masktree [ '0reduce' ] = _ETS_REDUCE_OFF ; } switch ( $ this -> masktree [ '0reduce' ] ) { case _ETS_REDUCE_OFF : break ; case _ETS_REDUCE_SPACES : $ built = preg_replace ( '/(\r\n|\r|\n)+/sm' , "\n" , preg_replace ( '/[ \t]*?(\r\n|\r|\n)+[\t ]*/sm' , "\n" , $ built ) ) ; break ; case _ETS_REDUCE_ALL : $ built = preg_replace ( '/[ \t]*?(\r\n|\r|\n)+[\t ]*/sm' , '' , $ built ) ; break ; } $ built = str_replace ( "\1n\1" , "\n" , $ built ) ; $ built = str_replace ( "\1r\1" , "\r" , $ built ) ; $ built = str_replace ( "\1t\1" , "\t" , $ built ) ; $ built = str_replace ( "\1s\1" , " " , $ built ) ; return $ built ; }
8302	public function assertArray ( $ config , $ key ) { if ( array_key_exists ( $ key , $ config ) && ! is_array ( $ config [ $ key ] ) ) { throw new ConfigurationException ( $ key . " section must be an array." ) ; } return $ this ; }
5847	public function sanitizeFileName ( $ fileName , \ TYPO3 \ CMS \ Core \ Resource \ Folder $ folder ) { $ slotArguments = func_get_args ( ) ; array_pop ( $ slotArguments ) ; $ storageConfiguration = $ folder -> getStorage ( ) -> getConfiguration ( ) ; $ storageRecord = $ folder -> getStorage ( ) -> getStorageRecord ( ) ; if ( $ storageRecord [ 'driver' ] !== 'Local' ) { return ; } $ targetDirectory = $ storageConfiguration [ 'pathType' ] === 'relative' ? PATH_site : '' ; $ targetDirectory .= rtrim ( rtrim ( $ storageConfiguration [ 'basePath' ] , '/' ) . $ folder -> getIdentifier ( ) , '/' ) ; $ processedFileName = static :: $ imageResizer -> getProcessedFileName ( $ targetDirectory . '/' . $ fileName , $ GLOBALS [ 'BE_USER' ] ) ; if ( $ processedFileName !== null ) { static :: $ originalFileName = $ fileName ; $ slotArguments [ 0 ] = PathUtility :: basename ( $ processedFileName ) ; return $ slotArguments ; } }
3403	protected function loadFromYml ( $ file ) { $ this -> parser = new Parser ( $ file ) ; $ this -> parser -> load ( $ this ) ; }
4242	public function onOutput ( ) { if ( $ this -> debug -> parentInstance ) { return ; } $ vals = $ this -> runtimeVals ( ) ; $ this -> debug -> groupSummary ( 1 ) ; $ this -> debug -> info ( 'Built In ' . $ vals [ 'runtime' ] . ' sec' ) ; $ this -> debug -> info ( 'Peak Memory Usage' . ( $ this -> debug -> getCfg ( 'output/outputAs' ) == 'html' ? ' <span title="Includes debug overhead">?&#x20dd;</span>' : '' ) . ': ' . $ this -> debug -> utilities -> getBytes ( $ vals [ 'memoryPeakUsage' ] ) . ' / ' . $ this -> debug -> utilities -> getBytes ( $ vals [ 'memoryLimit' ] ) ) ; $ this -> debug -> groupEnd ( ) ; }
4334	public function getCfg ( $ path = null ) { if ( $ path == 'outputAs' ) { $ ret = $ this -> cfg [ 'outputAs' ] ; if ( ! $ ret ) { $ ret = $ this -> getDefaultOutputAs ( ) ; } } elseif ( $ path == 'css' ) { $ ret = $ this -> getCss ( ) ; } else { $ ret = $ this -> debug -> utilities -> arrayPathGet ( $ this -> cfg , $ path ) ; } return $ ret ; }
4289	public function processLogEntry ( $ method , $ args = array ( ) , $ meta = array ( ) ) { $ meta = \ array_merge ( array ( 'format' => 'raw' , 'requestId' => $ this -> requestId , ) , $ meta ) ; if ( $ meta [ 'channel' ] == $ this -> debug -> getCfg ( 'channel' ) ) { unset ( $ meta [ 'channel' ] ) ; } if ( $ meta [ 'format' ] == 'raw' ) { $ args = $ this -> crateValues ( $ args ) ; } if ( ! empty ( $ meta [ 'backtrace' ] ) ) { $ meta [ 'backtrace' ] = $ this -> crateValues ( $ meta [ 'backtrace' ] ) ; } $ this -> wamp -> publish ( $ this -> topic , array ( $ method , $ args , $ meta ) ) ; }
440	public function canGetProperty ( $ name , $ checkVars = true , $ checkBehaviors = true ) { if ( method_exists ( $ this , 'get' . $ name ) || $ checkVars && property_exists ( $ this , $ name ) ) { return true ; } elseif ( $ checkBehaviors ) { $ this -> ensureBehaviors ( ) ; foreach ( $ this -> _behaviors as $ behavior ) { if ( $ behavior -> canGetProperty ( $ name , $ checkVars ) ) { return true ; } } } return false ; }
8251	protected function isValidUsername ( $ name ) { if ( ! is_string ( $ name ) || ! $ this -> storage -> checkValidName ( $ name ) || strlen ( $ name ) < $ this -> config [ "registration" ] [ "nameLenMin" ] || strlen ( $ name ) > $ this -> config [ "registration" ] [ "nameLenMax" ] ) { return false ; } return true ; }
7705	function _GetAttValPos ( $ Att ) { if ( $ this -> pST_Src === false ) $ this -> pST_Src = substr ( $ this -> Txt , $ this -> PosBeg , $ this -> pST_PosEnd - $ this -> PosBeg + 1 ) ; $ a = ' ' . $ Att . '="' ; $ p0 = strpos ( $ this -> pST_Src , $ a ) ; if ( $ p0 !== false ) { $ p1 = $ p0 + strlen ( $ a ) ; $ p2 = strpos ( $ this -> pST_Src , '"' , $ p1 ) ; if ( $ p2 !== false ) return array ( $ p1 , $ p2 - $ p1 , $ p0 , $ p2 - $ p0 + 1 ) ; } return false ; }
12656	public function modifyTextContainer ( $ oldName , $ newName , $ content , $ language ) { foreach ( $ this -> languages as $ lang ) { $ modified = false ; $ allTexts = $ this -> getPageTexts ( $ lang ) ; if ( ! isset ( $ allTexts [ $ oldName ] ) ) { throw new \ Exception ( "Text container unknown." ) ; } if ( $ oldName !== $ newName ) { if ( isset ( $ allTexts [ $ newName ] ) ) { throw new \ Exception ( "Text container already exists" ) ; } $ this -> contents [ $ lang ] [ $ newName ] = $ this -> contents [ $ lang ] [ $ oldName ] ; $ this -> contents [ $ lang ] [ $ newName ] [ 'id' ] = $ newName ; $ this -> contents [ $ lang ] [ $ newName ] [ 'name' ] = $ newName ; unset ( $ this -> contents [ $ lang ] [ $ oldName ] ) ; $ modified = true ; } if ( $ language === $ lang ) { $ this -> contents [ $ lang ] [ $ newName ] [ 'content' ] = $ content ; $ this -> contents [ $ lang ] [ $ newName ] [ 'outdated' ] = false ; $ modified = true ; } elseif ( $ language === $ this -> baseLang ) { $ this -> contents [ $ lang ] [ $ newName ] [ 'outdated' ] = true ; $ modified = true ; } if ( $ modified ) { $ this -> writeTextsToFile ( $ lang ) ; } } return $ this -> contents [ $ language ] [ $ newName ] ; }
5166	protected function filterUriInstance ( $ uri ) : string { if ( $ uri instanceof UriInterface ) { return ( string ) $ uri ; } if ( is_string ( $ uri ) ) { return ( string ) \ One \ createUriFromString ( $ uri ) ; } return '' ; }
11688	public function setCenter ( \ Chill \ MainBundle \ Entity \ Center $ center ) { $ this -> center = $ center ; return $ this ; }
6891	protected function createAssignmentsForQuantity ( SaleItemInterface $ item , $ quantity ) { if ( 0 >= $ quantity ) { return ; } $ stockUnits = $ this -> sortStockUnits ( $ this -> unitResolver -> findAssignable ( $ item ) ) ; foreach ( $ stockUnits as $ stockUnit ) { $ assignment = $ this -> saleFactory -> createStockAssignmentForItem ( $ item ) ; $ assignment -> setSaleItem ( $ item ) -> setStockUnit ( $ stockUnit ) ; $ quantity -= $ this -> assignmentUpdater -> updateSold ( $ assignment , $ quantity ) ; if ( 0 == $ quantity ) { return ; } } if ( 0 < $ quantity ) { $ stockUnit = $ this -> unitResolver -> createBySubjectRelative ( $ item ) ; $ assignment = $ this -> saleFactory -> createStockAssignmentForItem ( $ item ) ; $ assignment -> setSaleItem ( $ item ) -> setStockUnit ( $ stockUnit ) ; $ quantity -= $ this -> assignmentUpdater -> updateSold ( $ assignment , $ quantity ) ; } if ( 0 < $ quantity ) { throw new StockLogicException ( sprintf ( 'Failed to create assignments for item "%s".' , $ item -> getDesignation ( ) ) ) ; } }
232	public function quoteValue ( $ str ) { if ( ! is_string ( $ str ) ) { return $ str ; } if ( ( $ value = $ this -> db -> getSlavePdo ( ) -> quote ( $ str ) ) !== false ) { return $ value ; } return "'" . addcslashes ( str_replace ( "'" , "''" , $ str ) , "\000\n\r\\\032" ) . "'" ; }
11030	public function getSubmitModelName ( $ attribute ) { return empty ( $ this -> submitModelName ) ? Html :: getInputName ( $ this -> model , $ attribute ) : $ this -> submitModelName . "[$attribute]" ; }
12737	protected function translate ( ) { $ translatorOptions = $ this -> getTranslatorOptions ( ) ; if ( empty ( $ translatorOptions ) && ! array_key_exists ( "fields" , $ translatorOptions ) ) { return ; } $ params = array ( ) ; if ( array_key_exists ( "params" , $ translatorOptions ) ) { $ params = $ translatorOptions [ "params" ] ; } $ domain = "RedKiteCms" ; if ( array_key_exists ( "domain" , $ translatorOptions ) ) { $ domain = $ translatorOptions [ "domain" ] ; } foreach ( $ translatorOptions [ "fields" ] as $ field ) { $ field = ucfirst ( $ field ) ; $ method = 'get' . $ field ; $ value = Translator :: translate ( $ this -> $ method ( ) , $ params , $ domain ) ; $ method = 'set' . $ field ; $ this -> $ method ( $ value ) ; } }
8939	public function closeChangeset ( $ id ) { $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = 'changeset/' . $ id . '/close' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ header [ 'format' ] = 'text/xml' ; $ this -> oauth -> oauthRequest ( $ path , 'PUT' , $ parameters , $ header ) ; }
6206	public function onShutdown ( ) { if ( self :: $ instance == null ) { return ; } self :: $ instance = null ; if ( ! $ error = error_get_last ( ) ) { return ; } if ( ! $ this -> shouldNotifyError ( $ error [ 'type' ] , $ error [ 'message' ] , $ error [ 'file' ] , $ error [ 'line' ] ) ) { return ; } $ backtrace = array ( array ( 'file' => $ error [ 'file' ] , 'line' => $ error [ 'line' ] , 'function' => '' , 'args' => array ( ) , ) ) ; $ this -> airbrakeClient -> notifyOnError ( '[Improper Shutdown] ' . $ error [ 'message' ] , $ backtrace ) ; }
7145	public function add_custom_profile_fields ( $ user ) { $ user_settings = apply_filters ( 'iac_get_user_settings' , array ( ) , $ user -> ID ) ; $ nonce = wp_create_nonce ( 'iac_user_settings' ) ; ?> <h3> <?php _e ( 'Informer?' , $ this -> get_textdomain ( ) ) ; ?> </h3> <table class="form-table"> <tr id="post_subscription"> <th> <label for="post_subscription_checkbox"> <?php _e ( 'Posts subscription' , $ this -> get_textdomain ( ) ) ; ?> </label> </th> <td> <input type="checkbox" id="post_subscription_checkbox" name="post_subscription" value="1" <?php checked ( '1' , $ user_settings [ 'inform_about_posts' ] ) ; ?> /> <span class="description"> <?php _e ( 'Inform about new posts via e-mail, without your own posts.' , $ this -> get_textdomain ( ) ) ; ?> </span> </td> </tr> <tr id="comment_subscription"> <th> <label for="comment_subscription_checkbox"> <?php _e ( 'Comments subscription' , $ this -> get_textdomain ( ) ) ; ?> </label> </th> <td> <input type="checkbox" id="comment_subscription_checkbox" name="comment_subscription" value="1" <?php checked ( '1' , $ user_settings [ 'inform_about_comments' ] ) ; ?> /> <span class="description"> <?php _e ( 'Inform about new comments via e-mail, without your own comments.' , $ this -> get_textdomain ( ) ) ; ?> </span> <input type="hidden" name="iac_nonce" value=" <?php echo $ nonce ; ?> " /> </td> </tr> </table> <?php }
5572	public function authenticate ( $ username , $ password ) { if ( ! $ this -> page -> getRealm ( ) ) { return false ; } $ url = $ this -> page -> getUrl ( ) ; if ( ! $ url ) { return false ; } $ this -> user_agent -> setIdentity ( $ url -> getHost ( ) , $ this -> page -> getRealm ( ) , $ username , $ password ) ; return $ this -> retry ( ) ; }
2479	protected function getSearchFields ( Criterion $ criterion , $ fieldDefinitionIdentifier , $ fieldTypeIdentifier = null , $ name = null ) { return $ this -> fieldNameResolver -> getFieldTypes ( $ criterion , $ fieldDefinitionIdentifier , $ fieldTypeIdentifier , $ name ) ; }
4411	public function process ( ContainerBuilder $ container ) { if ( ! $ container -> has ( 'netgen_admin_ui.menu_plugin.registry' ) ) { return ; } $ menuPluginRegistry = $ container -> findDefinition ( 'netgen_admin_ui.menu_plugin.registry' ) ; $ menuPlugins = $ container -> findTaggedServiceIds ( 'netgen_admin_ui.menu_plugin' ) ; $ flattenedMenuPlugins = array ( ) ; foreach ( $ menuPlugins as $ identifier => $ menuPlugin ) { $ flattenedMenuPlugins [ $ identifier ] = isset ( $ menuPlugin [ 0 ] [ 'priority' ] ) ? $ menuPlugin [ 0 ] [ 'priority' ] : 0 ; } arsort ( $ flattenedMenuPlugins ) ; foreach ( array_keys ( $ flattenedMenuPlugins ) as $ menuPlugin ) { $ menuPluginRegistry -> addMethodCall ( 'addMenuPlugin' , array ( new Reference ( $ menuPlugin ) ) ) ; } }
3537	public function getGroupsAssignedInLdap ( ) { if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: beginProfile ( 'getGroupsAssignedInLdap' , static :: YII2_PROFILE_NAME . 'getGroupsAssignedInLdap' ) ; } $ ldapUser = $ this -> queryLdapUserObject ( ) ; $ ldapGroupsConverted = [ ] ; if ( $ ldapUser != null ) { if ( static :: getGroupAssigmentOptions ( 'SEARCH_NESTED_GROUPS' , $ this -> individualGroupAssignmentOptions ) == true ) { $ ldapGroups = static :: getAdldapProvider ( ) -> search ( ) -> rawFilter ( '(member:1.2.840.113556.1.4.1941:=' . $ ldapUser -> getDn ( ) . ')' ) -> select ( 'cn' ) -> raw ( ) -> get ( ) ; if ( $ ldapGroups == null ) { $ ldapGroups = [ ] ; } foreach ( $ ldapGroups as $ groupDn ) { if ( is_array ( $ groupDn ) && array_key_exists ( 'cn' , $ groupDn ) ) { array_push ( $ ldapGroupsConverted , $ groupDn [ 'cn' ] [ 0 ] ) ; } } } else { $ ldapGroups = $ ldapUser -> getAttribute ( 'memberof' ) ; if ( $ ldapGroups == null ) { $ ldapGroups = [ ] ; } foreach ( $ ldapGroups as $ groupDn ) { $ n = Utilities :: explodeDn ( $ groupDn ) [ 0 ] ; array_push ( $ ldapGroupsConverted , $ n ) ; } } } if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: endProfile ( 'getGroupsAssignedInLdap' , static :: YII2_PROFILE_NAME . 'getGroupsAssignedInLdap' ) ; } return $ ldapGroupsConverted ; }
3506	private function convertAlertToArray ( Alert $ alert ) : array { $ data = [ ] ; if ( $ alert -> getBodyLocalized ( ) -> getKey ( ) ) { $ data [ 'loc-key' ] = $ alert -> getBodyLocalized ( ) -> getKey ( ) ; $ data [ 'loc-args' ] = $ alert -> getBodyLocalized ( ) -> getArgs ( ) ; } else { $ data [ 'body' ] = $ alert -> getBody ( ) ; } if ( $ alert -> getTitleLocalized ( ) -> getKey ( ) ) { $ data [ 'title-loc-key' ] = $ alert -> getTitleLocalized ( ) -> getKey ( ) ; $ data [ 'title-loc-args' ] = $ alert -> getTitleLocalized ( ) -> getArgs ( ) ; } elseif ( $ alert -> getTitle ( ) ) { $ data [ 'title' ] = $ alert -> getTitle ( ) ; } if ( $ alert -> getActionLocalized ( ) -> getKey ( ) ) { $ data [ 'action-loc-key' ] = $ alert -> getActionLocalized ( ) -> getKey ( ) ; } if ( $ alert -> getLaunchImage ( ) ) { $ data [ 'launch-image' ] = $ alert -> getLaunchImage ( ) ; } return $ data ; }
3870	protected function getView ( $ identifier , $ view ) { $ metaModels = $ this -> getMetaModel ( $ identifier , false ) ; return $ metaModels -> getView ( $ view ) ; }
7966	public function getProperties ( $ billingAccount ) { if ( ! $ billingAccount ) throw new BadMethodCallException ( 'Parameter $billingAccount is missing.' ) ; try { $ r = $ this -> get ( 'telephony/' . $ billingAccount ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new TelephonyException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
7923	private function extractFilename ( \ ZipArchive $ zipArchive , $ fileIndex ) { $ entry = $ zipArchive -> statIndex ( $ fileIndex ) ; $ filename = str_replace ( '\\' , '/' , $ entry [ 'name' ] ) ; if ( $ this -> isValidPath ( $ filename ) ) { return $ filename ; } throw new \ Exception ( 'Invalid filename path in zip archive' ) ; }
8023	public function synchronize ( \ Closure $ closure ) { $ this -> acquire ( ) ; call_user_func ( $ closure ) ; $ this -> release ( ) ; return $ this ; }
2026	public static function findPublishedSubpagesWithoutGuestsByPid ( $ intPid , $ blnShowHidden = false , $ blnIsSitemap = false ) { $ time = Date :: floorToMinute ( ) ; $ objSubpages = Database :: getInstance ( ) -> prepare ( "SELECT p1.*, (SELECT COUNT(*) FROM tl_page p2 WHERE p2.pid=p1.id AND p2.type!='root' AND p2.type!='error_401' AND p2.type!='error_403' AND p2.type!='error_404'" . ( ! $ blnShowHidden ? ( $ blnIsSitemap ? " AND (p2.hide='' OR sitemap='map_always')" : " AND p2.hide=''" ) : "" ) . ( FE_USER_LOGGED_IN ? " AND p2.guests=''" : "" ) . ( ! BE_USER_LOGGED_IN ? " AND (p2.start='' OR p2.start<='$time') AND (p2.stop='' OR p2.stop>'" . ( $ time + 60 ) . "') AND p2.published='1'" : "" ) . ") AS subpages FROM tl_page p1 WHERE p1.pid=? AND p1.type!='root' AND p1.type!='error_401' AND p1.type!='error_403' AND p1.type!='error_404'" . ( ! $ blnShowHidden ? ( $ blnIsSitemap ? " AND (p1.hide='' OR sitemap='map_always')" : " AND p1.hide=''" ) : "" ) . ( FE_USER_LOGGED_IN ? " AND p1.guests=''" : "" ) . ( ! BE_USER_LOGGED_IN ? " AND (p1.start='' OR p1.start<='$time') AND (p1.stop='' OR p1.stop>'" . ( $ time + 60 ) . "') AND p1.published='1'" : "" ) . " ORDER BY p1.sorting" ) -> execute ( $ intPid ) ; if ( $ objSubpages -> numRows < 1 ) { return null ; } return static :: createCollectionFromDbResult ( $ objSubpages , 'tl_page' ) ; }
12127	public function getSetting ( $ name , $ default = null ) { return array_key_exists ( $ name , $ this -> settings ) ? $ this -> settings [ $ name ] : $ default ; }
5352	public function getSupportedNamespaces ( ) { if ( empty ( $ this -> data -> namespaces ) || ! is_array ( $ this -> data -> namespaces ) ) { return array ( ) ; } return $ this -> data -> namespaces ; }
1800	protected function combiner ( $ names ) { $ return = array ( '' ) ; $ names = array_values ( $ names ) ; for ( $ i = 0 , $ c = \ count ( $ names ) ; $ i < $ c ; $ i ++ ) { $ buffer = array ( ) ; foreach ( $ return as $ k => $ v ) { $ buffer [ ] = ( $ k % 2 == 0 ) ? $ v : $ v . $ names [ $ i ] ; $ buffer [ ] = ( $ k % 2 == 0 ) ? $ v . $ names [ $ i ] : $ v ; } $ return = $ buffer ; } return array_filter ( $ return ) ; }
7276	protected static function tableColumns ( ) { global $ dbConfig ; $ query = Db :: instance ( static :: getDbName ( ) ) -> prepare ( " select column_name, column_key from information_schema.columns where table_schema = :schema and table_name = :table " ) ; $ query -> bindValue ( ":schema" , $ dbConfig [ static :: getDbName ( ) ] [ "schema" ] ) ; $ query -> bindValue ( ":table" , static :: tableName ( ) ) ; if ( $ query -> execute ( ) ) return $ query -> fetchAll ( PDO :: FETCH_ASSOC ) ; else return false ; }
556	public function setComponents ( $ components ) { foreach ( $ components as $ id => $ component ) { $ this -> set ( $ id , $ component ) ; } }
12019	function addProperties ( ) { $ requiredProperties = [ 'api' => '\\' . $ this -> apiClassname , 'parameters' => 'array' , 'response' => '\Amp\Artax\Response' , 'originalResponse' => '\Amp\Artax\Response' , ] ; foreach ( $ requiredProperties as $ propertyName => $ typehint ) { $ propertyGenerator = new PropertyGenerator ( $ propertyName , null ) ; $ docBlock = new DocBlockGenerator ( '@var ' . $ typehint ) ; $ propertyGenerator -> setDocBlock ( $ docBlock ) ; $ this -> classGenerator -> addPropertyFromGenerator ( $ propertyGenerator ) ; } $ docBlock = new DocBlockGenerator ( 'Get the last response.' ) ; $ body = 'return $this->response;' ; $ methodGenerator = $ this -> createMethodGenerator ( 'getResponse' , $ body , $ docBlock , [ ] , '\Amp\Artax\Response' ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; $ docBlock = new DocBlockGenerator ( 'Set the last response. This should only be used by the API class when the operation has been dispatched. Storing the response is required as some APIs store out-of-bound information in the headers e.g. rate-limit info, pagination that is not really part of the operation.' ) ; $ body = '$this->response = $response;' ; $ methodGenerator = $ this -> createMethodGenerator ( 'setResponse' , $ body , $ docBlock , [ [ 'response' , 'Amp\Artax\Response' ] ] ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; }
3541	public static function getGroupAssigmentOptions ( $ optionName , $ individualGroupAssignmentOptions = null ) { if ( $ individualGroupAssignmentOptions != null && is_array ( $ individualGroupAssignmentOptions ) && array_key_exists ( $ optionName , $ individualGroupAssignmentOptions ) ) { return $ individualGroupAssignmentOptions [ $ optionName ] ; } else if ( isset ( Yii :: $ app -> params [ 'LDAP-Group-Assignment-Options' ] ) && is_array ( Yii :: $ app -> params [ 'LDAP-Group-Assignment-Options' ] ) && array_key_exists ( $ optionName , Yii :: $ app -> params [ 'LDAP-Group-Assignment-Options' ] ) ) { return Yii :: $ app -> params [ 'LDAP-Group-Assignment-Options' ] [ $ optionName ] ; } else if ( array_key_exists ( $ optionName , static :: GROUP_ASSIGNMENT_TOUCH_ONLY_MATCHING_REGEX ) ) { return static :: GROUP_ASSIGNMENT_TOUCH_ONLY_MATCHING_REGEX [ $ optionName ] ; } else { throw new \ yii \ base \ Exception ( 'Group-Option ' . $ optionName . ' not found. Please define settings in the config/params.php of the yii2 framework as described on top of the UserDbLdap.php' ) ; } }
9521	public function addAlias ( $ parameterName , $ prefix = null ) { if ( $ prefix == null ) { $ this -> aliases [ $ this -> prefix ] = $ parameterName ; } else { $ this -> aliases [ $ prefix ] = $ parameterName ; } }
190	private function loadTableColumnsInfo ( $ tableName ) { $ tableColumns = $ this -> db -> createCommand ( 'PRAGMA TABLE_INFO (' . $ this -> quoteValue ( $ tableName ) . ')' ) -> queryAll ( ) ; $ tableColumns = $ this -> normalizePdoRowKeyCase ( $ tableColumns , true ) ; return ArrayHelper :: index ( $ tableColumns , 'cid' ) ; }
7376	public function fetch ( string $ key , $ default = null ) { $ val = $ this -> bag [ $ key ] ?? $ default ; if ( ! is_array ( $ val ) ) { return trim ( $ val ) ; } else { return $ val ; } }
402	public static function process ( $ content , $ config = null ) { $ configInstance = \ HTMLPurifier_Config :: create ( $ config instanceof \ Closure ? null : $ config ) ; $ configInstance -> autoFinalize = false ; $ purifier = \ HTMLPurifier :: instance ( $ configInstance ) ; $ purifier -> config -> set ( 'Cache.SerializerPath' , \ Yii :: $ app -> getRuntimePath ( ) ) ; $ purifier -> config -> set ( 'Cache.SerializerPermissions' , 0775 ) ; static :: configure ( $ configInstance ) ; if ( $ config instanceof \ Closure ) { call_user_func ( $ config , $ configInstance ) ; } return $ purifier -> purify ( $ content ) ; }
3492	public function withHeaders ( array $ headers ) : Request { $ cloned = clone $ this ; foreach ( $ headers as $ name => $ value ) { $ cloned = $ cloned -> withHeader ( $ name , $ value ) ; } return $ cloned ; }
3369	private function getClassString ( ClassMetadata $ class ) { $ this -> visitAssociation ( $ class -> getName ( ) ) ; $ className = $ class -> getName ( ) ; $ classText = '[' . str_replace ( '\\' , '.' , $ className ) ; $ fields = [ ] ; $ parent = $ this -> getParent ( $ class ) ; $ parentFields = $ parent ? $ parent -> getFieldNames ( ) : [ ] ; foreach ( $ class -> getFieldNames ( ) as $ fieldName ) { if ( in_array ( $ fieldName , $ parentFields ) ) { continue ; } if ( $ class -> isIdentifier ( $ fieldName ) ) { $ fields [ ] = '+' . $ fieldName ; } else { $ fields [ ] = $ fieldName ; } } if ( ! empty ( $ fields ) ) { $ classText .= '|' . implode ( ';' , $ fields ) ; } $ classText .= ']' ; return $ classText ; }
6466	private static function createDefaultBoundary ( ) : string { try { $ string = random_bytes ( 16 ) ; $ string [ 6 ] = chr ( ord ( $ string [ 6 ] ) & 0x0f | 0x40 ) ; $ string [ 8 ] = chr ( ord ( $ string [ 8 ] ) & 0x3f | 0x80 ) ; return vsprintf ( '%s%s-%s-%s-%s-%s%s%s' , str_split ( bin2hex ( $ string ) , 4 ) ) ; } catch ( Exception $ ex ) { throw new RuntimeException ( 'Failed to generate random bytes' , 0 , $ ex ) ; } }
12173	protected static function addReflectionArguments ( Definition $ factory , ReflectionFunctionAbstract $ reflectionFunction = null ) { if ( ! $ reflectionFunction ) { $ callable = $ factory -> getCallable ( ) ; if ( is_array ( $ callable ) ) { $ reflectionFunction = new ReflectionMethod ( $ callable [ 0 ] , $ callable [ 1 ] ) ; } else { $ reflectionFunction = new ReflectionFunction ( $ callable ) ; } } foreach ( $ reflectionFunction -> getParameters ( ) as $ arg ) { try { $ name = $ arg -> getName ( ) ; $ required = ! $ arg -> isOptional ( ) ; if ( $ argClass = $ arg -> getClass ( ) ) { $ factory -> addClassArgument ( $ name , $ argClass -> getName ( ) , $ required ) ; } else { $ default = ( $ required ? null : $ arg -> getDefaultValue ( ) ) ; $ factory -> addScalarArgument ( $ name , null , $ required , $ default ) ; } } catch ( ReflectionException $ re ) { throw UnresolvableArgumentException :: fromReflectionParam ( $ arg , $ reflectionFunction , $ re ) ; } } }
2032	public static function findFirstActiveByMemberGroups ( $ arrIds ) { if ( empty ( $ arrIds ) || ! \ is_array ( $ arrIds ) ) { return null ; } $ time = Date :: floorToMinute ( ) ; $ objDatabase = Database :: getInstance ( ) ; $ arrIds = array_map ( '\intval' , $ arrIds ) ; $ objResult = $ objDatabase -> prepare ( "SELECT p.* FROM tl_member_group g LEFT JOIN tl_page p ON g.jumpTo=p.id WHERE g.id IN(" . implode ( ',' , $ arrIds ) . ") AND g.jumpTo>0 AND g.redirect='1' AND g.disable!='1' AND (g.start='' OR g.start<='$time') AND (g.stop='' OR g.stop>'" . ( $ time + 60 ) . "') AND p.published='1' AND (p.start='' OR p.start<='$time') AND (p.stop='' OR p.stop>'" . ( $ time + 60 ) . "') ORDER BY " . $ objDatabase -> findInSet ( 'g.id' , $ arrIds ) ) -> limit ( 1 ) -> execute ( ) ; if ( $ objResult -> numRows < 1 ) { return null ; } $ objRegistry = Registry :: getInstance ( ) ; if ( $ objPage = $ objRegistry -> fetch ( 'tl_page' , $ objResult -> id ) ) { return $ objPage ; } return new static ( $ objResult ) ; }
6110	public function fileList ( $ cpw = "" , $ path = "/" , $ recursive = false ) { return $ this -> getParent ( ) -> channelFileList ( $ this -> getId ( ) , $ cpw , $ path , $ recursive ) ; }
1303	public function get ( string $ path , array $ headers = [ ] , $ cache = true ) : Response { if ( null === $ this -> endpoint ) { return new Response ( [ ] ) ; } $ headers [ ] = 'Package-Session: ' . $ this -> sess ; $ url = $ this -> endpoint . '/' . ltrim ( $ path , '/' ) ; $ cacheKey = $ cache ? ltrim ( $ path , '/' ) : '' ; if ( $ cacheKey && $ contents = $ this -> cache -> read ( $ cacheKey ) ) { $ cachedResponse = Response :: fromJson ( json_decode ( $ contents , true ) ) ; if ( $ lastModified = $ cachedResponse -> getHeader ( 'last-modified' ) ) { $ response = $ this -> fetchFileIfLastModified ( $ url , $ cacheKey , $ lastModified , $ headers ) ; if ( 304 === $ response -> getStatusCode ( ) ) { $ response = new Response ( $ cachedResponse -> getBody ( ) , $ response -> getOrigHeaders ( ) , 304 ) ; } return $ response ; } } return $ this -> fetchFile ( $ url , $ cacheKey , $ headers ) ; }
4068	public function configure ( MetaModelsServiceContainer $ serviceContainer ) { $ serviceContainer -> setEventDispatcher ( function ( ) { return $ this -> container -> get ( 'event_dispatcher' ) ; } ) -> setDatabase ( function ( ) { return $ this -> container -> get ( 'cca.legacy_dic.contao_database_connection' ) ; } ) -> setAttributeFactory ( function ( ) { return $ this -> container -> get ( 'metamodels.attribute_factory' ) ; } ) -> setFactory ( function ( ) { return $ this -> container -> get ( 'metamodels.factory' ) ; } ) -> setFilterFactory ( function ( ) { return $ this -> container -> get ( 'metamodels.filter_setting_factory' ) ; } ) -> setRenderSettingFactory ( function ( ) { return $ this -> container -> get ( 'metamodels.render_setting_factory' ) ; } ) -> setCache ( function ( ) { return $ this -> container -> get ( 'metamodels.cache' ) ; } ) ; return $ serviceContainer ; }
3437	public function refreshFields ( ) { if ( $ this -> id === null ) { $ this -> original = [ ] ; return $ this -> fields = [ ] ; } $ sectionsBackup = isset ( $ this -> fields [ 'IBLOCK_SECTION' ] ) ? $ this -> fields [ 'IBLOCK_SECTION' ] : null ; $ this -> fields = static :: query ( ) -> getById ( $ this -> id ) -> fields ; if ( ! empty ( $ sectionsBackup ) ) { $ this -> fields [ 'IBLOCK_SECTION' ] = $ sectionsBackup ; } $ this -> fieldsAreFetched = true ; $ this -> original = $ this -> fields ; return $ this -> fields ; }
6098	protected function post ( $ endpoint , array $ parameters = [ ] , $ fireAndForget = false ) { return $ this -> call ( $ endpoint , $ parameters , self :: METHOD_POST , null , $ fireAndForget ) ; }
7667	function InlineImageExists ( ) { $ result = false ; for ( $ i = 0 ; $ i < count ( $ this -> attachment ) ; $ i ++ ) { if ( $ this -> attachment [ $ i ] [ 6 ] == "inline" ) { $ result = true ; break ; } } return $ result ; }
7081	public function onPostCopy ( SaleTransformEvent $ event ) { $ source = $ event -> getSource ( ) ; $ target = $ event -> getTarget ( ) ; $ target -> setOriginNumber ( $ source -> getNumber ( ) ) ; if ( $ source instanceof OrderInterface && $ target instanceof OrderInterface ) { $ target -> setSample ( $ source -> isSample ( ) ) ; } if ( null === $ customer = $ source -> getCustomer ( ) ) { return ; } if ( $ target instanceof OrderInterface && $ customer -> hasParent ( ) ) { $ target -> setCustomer ( $ customer -> getParent ( ) ) ; if ( null === $ target -> getOriginCustomer ( ) ) { $ target -> setOriginCustomer ( $ customer ) ; } } }
4389	public function repay ( \ Aimeos \ MShop \ Order \ Item \ Iface $ order ) { $ base = $ this -> getOrderBase ( $ order -> getBaseId ( ) ) ; if ( ( $ cfg = $ this -> getCustomerData ( $ base -> getCustomerId ( ) , 'repay' ) ) === null ) { $ msg = sprintf ( 'No reoccurring payment data available for customer ID "%1$s"' , $ base -> getCustomerId ( ) ) ; throw new \ Aimeos \ MShop \ Service \ Exception ( $ msg ) ; } if ( ! isset ( $ cfg [ 'token' ] ) ) { $ msg = sprintf ( 'No payment token available for customer ID "%1$s"' , $ base -> getCustomerId ( ) ) ; throw new \ Aimeos \ MShop \ Service \ Exception ( $ msg ) ; } $ data = array ( 'transactionId' => $ order -> getId ( ) , 'currency' => $ base -> getPrice ( ) -> getCurrencyId ( ) , 'amount' => $ this -> getAmount ( $ base -> getPrice ( ) ) , 'cardReference' => $ cfg [ 'token' ] , 'paymentPage' => false , ) ; if ( isset ( $ cfg [ 'month' ] ) && isset ( $ cfg [ 'year' ] ) ) { $ data [ 'card' ] = new \ Omnipay \ Common \ CreditCard ( [ 'expiryMonth' => $ cfg [ 'month' ] , 'expiryYear' => $ cfg [ 'year' ] , ] ) ; } $ response = $ this -> getXmlProvider ( ) -> purchase ( $ data ) -> send ( ) ; if ( $ response -> isSuccessful ( ) ) { $ this -> saveTransationRef ( $ base , $ response -> getTransactionReference ( ) ) ; $ order -> setPaymentStatus ( \ Aimeos \ MShop \ Order \ Item \ Base :: PAY_RECEIVED ) ; $ this -> saveOrder ( $ order ) ; } else { $ msg = ( method_exists ( $ response , 'getMessage' ) ? $ response -> getMessage ( ) : '' ) ; throw new \ Aimeos \ MShop \ Service \ Exception ( sprintf ( 'Token based payment failed: %1$s' , $ msg ) ) ; } }
10589	public function buildPayoutFromId ( $ sPayoutId ) { $ oPayout = new Freeagent \ DataWrapper \ PayoutVO ( ) ; $ oPayout -> setId ( $ sPayoutId ) ; try { $ oDets = $ this -> getTxnChargeDetails ( $ sPayoutId ) ; $ oPayout -> setDateArrival ( strtotime ( $ oDets -> PaymentDate ) ) -> setCurrency ( $ oDets -> GrossAmount -> currencyID ) ; $ oPayout -> addCharge ( $ this -> buildChargeFromTransaction ( $ sPayoutId ) ) ; } catch ( \ Exception $ oE ) { } return $ oPayout ; }
6076	public function uploadPreview ( $ fileData , $ id ) { $ parameters = [ 'query' => [ ] , 'multipart' => [ [ 'name' => 'file' , 'contents' => \ GuzzleHttp \ Psr7 \ stream_for ( $ fileData ) , 'filename' => 'preview-file' , ] , ] , 'headers' => null , ] ; $ this -> post ( 'v1/media.json/' . $ id . '/uploadpreview' , $ parameters ) ; }
6279	public function firstkey ( ) { $ this -> keyIterPos = 4 ; if ( ! $ this -> keyIterStop ) { $ pos = INF ; for ( $ i = 0 ; $ i < 2048 ; $ i += 8 ) { $ pos = min ( $ this -> readInt31 ( $ i ) , $ pos ) ; } $ this -> keyIterStop = $ pos ; } $ this -> keyIterPos = 2048 ; return $ this -> nextkey ( ) ; }
10978	protected function setVerificationCode ( $ code = null ) { $ this -> { Config :: get ( 'verifier.store_column' ) } = $ code ; if ( $ code ) { $ this -> { Config :: get ( 'verifier.flag_column' ) } = false ; } else { $ this -> { Config :: get ( 'verifier.flag_column' ) } = true ; } $ this -> save ( ) ; }
4480	public function setData ( $ data ) : void { if ( is_array ( $ data ) == false && is_string ( $ data ) == false && $ data instanceof JobData == false ) { throw new InvalidArgumentException ( sprintf ( "Job's data must be either an array, or a JobData instance, or a JSON string, %s given." , gettype ( $ data ) ) ) ; } if ( is_array ( $ data ) == true ) { $ data = new JobData ( $ data ) ; } elseif ( is_string ( $ data ) == true ) { $ data = new JobData ( json_decode ( $ data , true ) ) ; } $ this -> data = $ data ; }
9891	protected function createHint ( ) { if ( $ this -> getElement ( ) -> getHint ( ) ) { $ this -> hint = $ this -> builder -> make ( 'hint' , $ this -> getElement ( ) -> getHintAttributes ( ) , $ this -> getElement ( ) -> getHint ( ) ) ; } }
5789	protected function setRules ( bool $ skipUniqueForUnchanged = false , array $ record = null ) { $ this -> mapFieldsRules ( $ this -> databaseTableValidation -> getValidationRules ( ) ) ; $ uniqueColumns = $ this -> mapper -> getUniqueColumns ( ) ; if ( count ( $ uniqueColumns ) > 0 ) { $ this -> addUniqueRule ( ) ; foreach ( $ uniqueColumns as $ databaseColumnMapper ) { $ field = $ databaseColumnMapper -> getName ( ) ; if ( ! ( $ skipUniqueForUnchanged && $ this -> inputData [ $ field ] == $ record [ $ field ] ) ) { $ this -> rule ( 'unique' , $ field , $ databaseColumnMapper , $ this ) ; } } } }
2668	public function getAuthDictionary ( $ version ) { $ name = Config :: AUTH_DICTIONARY_NAME ; $ dictionary = $ this -> getSingleDictionary ( $ version , $ name ) ; return $ dictionary ; }
9449	protected function allowed ( $ method ) { if ( in_array ( $ method , $ this -> allowed ) === false ) { $ message = 'Used method is not allowed' ; throw new \ UnexpectedValueException ( $ message ) ; } return true ; }
4496	private function getGcmJson ( ) : string { return json_encode ( [ 'collapse_key' => $ this -> collapseKey , 'time_to_live' => $ this -> ttl , 'delay_while_idle' => $ this -> delayWhileIdle , 'priority' => $ this -> priority , 'data' => $ this -> getTrimmedJson ( [ $ this , 'getGcmJsonInner' ] , static :: GCM_MAX_LENGTH , 'You message for GCM is too long' ) , ] , JSON_UNESCAPED_UNICODE ) ; }
12521	public function renderLabel ( $ customFieldOrClass , $ slug = null , array $ params = array ( ) ) { $ resolvedParams = array_merge ( $ this -> defaultParams , $ params ) ; $ customField = ( $ customFieldOrClass instanceof CustomField ) ? $ customFieldOrClass : $ this -> container -> get ( 'chill.custom_field.provider' ) -> getCustomField ( $ customFieldOrClass , $ slug ) ; return $ this -> container -> get ( 'templating' ) -> render ( $ resolvedParams [ 'label_layout' ] , array ( 'customField' => $ customField ) ) ; }
3741	protected function getLabelParameters ( EnvironmentInterface $ environment , ModelInterface $ model ) { if ( $ model -> getProperty ( 'type' ) == 'simplelookup' ) { return $ this -> getLabelParametersWithAttributeAndUrlParam ( $ environment , $ model ) ; } return $ this -> getLabelParametersNormal ( $ environment , $ model ) ; }
12366	public function getNextVideoToConvert ( ) { $ query = $ this -> createQueryBuilder ( 'v' ) ; $ this -> onlyUploaded ( $ query ) ; return $ query -> getQuery ( ) -> getOneOrNullResult ( ) ; }
9565	public function addBeforeHook ( $ hook ) { if ( ! isset ( $ this -> options [ 'before' ] ) ) { $ this -> options [ 'before' ] = [ ] ; } $ this -> options [ 'before' ] [ ] = $ hook ; }
151	public function createCommand ( $ db = null ) { if ( $ db === null ) { $ db = Yii :: $ app -> getDb ( ) ; } list ( $ sql , $ params ) = $ db -> getQueryBuilder ( ) -> build ( $ this ) ; $ command = $ db -> createCommand ( $ sql , $ params ) ; $ this -> setCommandCache ( $ command ) ; return $ command ; }
4129	public function createQuery ( $ designDocName , $ viewName ) { $ designDoc = $ this -> config -> getDesignDocument ( $ designDocName ) ; if ( $ designDoc ) { $ designDoc = new $ designDoc [ 'className' ] ( $ designDoc [ 'options' ] ) ; } $ query = new ODMQuery ( $ this -> couchDBClient -> getHttpClient ( ) , $ this -> couchDBClient -> getDatabase ( ) , $ designDocName , $ viewName , $ designDoc ) ; $ query -> setDocumentManager ( $ this ) ; return $ query ; }
4824	public function removeValue ( $ fieldName , $ value ) { $ result = $ this -> row [ $ fieldName ] ; if ( ! is_array ( $ result ) ) { if ( $ value == $ result ) { unset ( $ this -> row [ $ fieldName ] ) ; $ this -> informChanges ( ) ; } } else { $ qty = count ( $ result ) ; for ( $ i = 0 ; $ i < $ qty ; $ i ++ ) { if ( $ result [ $ i ] == $ value ) { unset ( $ result [ $ i ] ) ; $ this -> informChanges ( ) ; } } $ this -> row [ $ fieldName ] = array_values ( $ result ) ; } }
10876	public function processApprove ( string $ hash ) : bool { $ decode = $ this -> getDecodeHash ( $ hash ) ; $ id = ( int ) $ decode [ 'id' ] ; $ verifyHash = $ decode [ 'verifyHash' ] ; $ item = $ this -> getById ( $ id ) ; if ( $ item && $ id == $ item [ 'id' ] ) { if ( ! $ item [ 'active' ] ) { if ( $ this -> verifyHash ( $ item [ 'id' ] . $ item [ 'login' ] , $ verifyHash ) ) { return $ this -> update ( $ item [ 'id' ] , [ 'active' => true ] ) ; } else { throw new IdentityException ( 'Invalid hash!' ) ; } } else { throw new IdentityException ( 'User is already approve!' ) ; } } else { throw new IdentityException ( 'User does not exist!' ) ; } }
11337	public function getMigrationClassName ( ) { $ postfix = '_initial_' . $ this -> tableName ; if ( is_dir ( $ this -> migrationDirectory ) ) { $ searchExisting = FileHelper :: findFiles ( $ this -> migrationDirectory , [ 'only' => [ $ postfix . '.php' ] ] ) ; if ( ! empty ( $ searchExisting ) ) { return strstr ( basename ( $ searchExisting [ 0 ] ) , '.php' , true ) ; } } return 'm' . gmdate ( 'ymd_His' , $ this -> migrationTimestamp ) . $ postfix ; }
12215	protected function compileConfiguration ( Traversable $ source , string $ target , CompilerContext $ context ) { $ compiler = new StandardCompiler ( ) ; $ compiler -> setSource ( $ source ) ; $ compiler -> setTarget ( $ target ) ; $ compiler -> compile ( ) ; }
6507	public function deserializeReturnValue ( $ type , $ data ) { $ jobType = $ this -> registry -> get ( $ type ) ; return $ this -> serializer -> deserialize ( $ data , $ jobType -> getReturnType ( ) , 'json' , $ this -> getResponseDeserializationContext ( $ jobType ) ) ; }
6986	protected function createDefaultContext ( ) : ContextInterface { $ context = $ this -> createContext ( ) ; if ( $ this -> customerProvider -> hasCustomer ( ) ) { $ this -> fillFromCustomer ( $ context , $ this -> customerProvider -> getCustomer ( ) ) ; } $ this -> finalize ( $ context ) ; return $ context ; }
3461	public function use ( $ middleware ) : void { if ( ! is_subclass_of ( $ middleware , MiddlewareInterface :: class ) ) { if ( ! is_callable ( $ middleware ) ) { throw new ApplicationException ( sprintf ( 'Middleware must be either class or object that implements `%s`' , MiddlewareInterface :: class ) ) ; } $ middleware = new CallableMiddleware ( $ middleware ) ; } $ this -> middleware [ ] = $ middleware ; }
7216	protected function getTaxGroupFromEvent ( ResourceEventInterface $ event ) { $ resource = $ event -> getResource ( ) ; if ( ! $ resource instanceof TaxGroupInterface ) { throw new InvalidArgumentException ( 'Expected instance of ' . TaxGroupInterface :: class ) ; } return $ resource ; }
9356	public function withUri ( UriInterface $ uri , $ preserve = false ) { $ static = clone $ this ; $ static -> uri = $ uri ; if ( ! $ preserve && $ host = $ uri -> getHost ( ) ) { $ port = $ host . ':' . $ uri -> getPort ( ) ; $ host = $ uri -> getPort ( ) ? $ port : $ host ; $ static -> headers [ 'Host' ] = ( array ) $ host ; } return $ static ; }
3396	public function toMail ( $ notifiable ) { return ( new MailMessage ) -> subject ( __ ( 'confirmation::confirmation.confirmation_subject' ) ) -> line ( __ ( 'confirmation::confirmation.confirmation_subject_title' ) ) -> line ( __ ( 'confirmation::confirmation.confirmation_body' ) ) -> action ( __ ( 'confirmation::confirmation.confirmation_button' ) , url ( "register/confirm/$notifiable->confirmation_code" ) ) ; }
3463	public function handle ( ServerRequestInterface $ request ) : ResponseInterface { $ response = $ this -> getMiddlewarePipe ( ) -> handle ( $ request ) ; return $ response ; }
10826	public static function table ( array $ rows , array $ headers = [ ] ) { $ table = new Table ( ) ; $ table -> setRows ( $ rows ) ; if ( count ( $ headers ) > 0 ) { $ table -> setHeaders ( $ headers ) ; } $ output = $ table -> render ( ) ; self :: writeln ( $ output ) ; }
12413	public function addDevice ( $ groupId , array $ deviceIdentifiers ) { $ params = [ 'group_id' => intval ( $ groupId ) , 'device_identifiers' => $ deviceIdentifiers , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_ADD_DEVICE , $ params ] ) ; }
12243	public function XSLT ( $ filepath , $ use_xslcache = true ) { if ( $ use_xslcache && extension_loaded ( 'xslcache' ) ) { $ xslt = new XSLTCache ; $ xslt -> importStylesheet ( $ filepath ) ; } else { $ xsl = new DOMDocument ; $ xsl -> load ( $ filepath ) ; $ xslt = new XSLTProcessor ; $ xslt -> importStylesheet ( $ xsl ) ; } return $ xslt -> transformToXML ( dom_import_simplexml ( $ this ) ) ; }
9910	function toArray ( ) { $ result = array ( ) ; $ object_vars = get_object_vars ( $ this ) ; foreach ( $ object_vars as $ key => $ value ) { if ( $ value == null ) { continue ; } if ( gettype ( $ value ) == "object" && is_subclass_of ( $ value , 'AbstractJSONWrapper' ) ) { if ( ! $ value -> isEmpty ( ) ) { $ result [ $ key ] = $ value -> toArray ( ) ; } } else { $ result [ $ key ] = $ value ; } } return $ result ; }
4508	public function decoded ( JWTDecodedEvent $ event ) { $ request = $ this -> requestStack -> getCurrentRequest ( ) ; $ payload = $ event -> getPayload ( ) ; $ payload = json_decode ( json_encode ( $ payload ) , true ) ; if ( ! $ this -> accessor -> isReadable ( $ payload , $ this -> property ) ) { $ event -> markAsInvalid ( ) ; } elseif ( $ this -> validate && $ this -> accessor -> getValue ( $ payload , $ this -> property ) !== $ request -> getClientIp ( ) ) { $ event -> markAsInvalid ( ) ; } }
6354	public static function setFakeTime ( $ fakeTime ) { if ( is_string ( $ fakeTime ) ) { $ fakeTime = ( int ) static :: convert ( TS_UNIX , $ fakeTime ) ; } if ( is_int ( $ fakeTime ) ) { $ fakeTime = function ( ) use ( $ fakeTime ) { return $ fakeTime ; } ; } $ old = static :: $ fakeTimeCallback ; static :: $ fakeTimeCallback = $ fakeTime ? $ fakeTime : null ; return $ old ; }
11641	public function getColumns ( ) { if ( is_null ( $ this -> _columns ) ) { $ this -> columns = $ this -> dataProvider -> model -> attributeNames ( ) ; } return $ this -> _columns ; }
11196	public function __isset ( $ name ) { $ value = $ this -> find ( $ name ) ; if ( $ value !== null && ! ( $ value instanceof \ Exception ) ) { return true ; } return false ; }
10961	protected function restoreResponse ( $ response , $ data ) { if ( isset ( $ data [ 'format' ] ) ) { $ response -> format = $ data [ 'format' ] ; } if ( isset ( $ data [ 'version' ] ) ) { $ response -> version = $ data [ 'version' ] ; } if ( isset ( $ data [ 'statusCode' ] ) ) { $ response -> statusCode = $ data [ 'statusCode' ] ; } if ( isset ( $ data [ 'statusText' ] ) ) { $ response -> statusText = $ data [ 'statusText' ] ; } if ( isset ( $ data [ 'headers' ] ) && is_array ( $ data [ 'headers' ] ) ) { $ headers = $ response -> getHeaders ( ) -> toArray ( ) ; $ response -> getHeaders ( ) -> fromArray ( array_merge ( $ data [ 'headers' ] , $ headers ) ) ; } if ( isset ( $ data [ 'cookies' ] ) && is_array ( $ data [ 'cookies' ] ) ) { $ cookies = $ response -> getCookies ( ) -> toArray ( ) ; $ response -> getCookies ( ) -> fromArray ( array_merge ( $ data [ 'cookies' ] , $ cookies ) ) ; } }
1788	public function editArticle ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { $ objPage = Contao \ PageModel :: findById ( $ row [ 'pid' ] ) ; return $ this -> User -> isAllowed ( Contao \ BackendUser :: CAN_EDIT_ARTICLES , $ objPage -> row ( ) ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' ; }
6972	private function buildEntity ( ClassMetadata $ metadata , $ data ) { $ class = $ metadata -> getName ( ) ; $ entity = new $ class ; foreach ( $ data as $ propertyPath => $ value ) { if ( $ metadata -> hasField ( $ propertyPath ) ) { $ builtValue = $ this -> buildFieldValue ( $ metadata , $ propertyPath , $ value ) ; } elseif ( $ metadata -> hasAssociation ( $ propertyPath ) ) { $ builtValue = $ this -> buildAssociationValue ( $ metadata , $ propertyPath , $ value ) ; } else { throw new \ Exception ( "Unexpected property path '$propertyPath' for class '$class'." ) ; } $ this -> accessor -> setValue ( $ entity , $ propertyPath , $ builtValue ) ; } return $ entity ; }
6135	public function search ( Search $ search , $ returnType = self :: RETURN_OBJECTS , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'returnType' => $ returnType ] , 'body' => json_encode ( [ 'search' => $ search ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> call ( 'v1/search' , $ parameters , self :: METHOD_POST , $ cachePolicy ) ; $ result = new SearchResult ( $ result ) ; return $ result ; }
10644	public function getRelativePath ( string $ path ) : string { $ from = $ this -> path ; $ fromParts = explode ( "/" , $ from ) ; $ toParts = explode ( "/" , $ path ) ; $ max = max ( count ( $ fromParts ) , count ( $ toParts ) ) ; for ( $ i = 0 ; $ i < $ max ; $ i ++ ) { if ( ! isset ( $ fromParts [ $ i ] ) || ! isset ( $ toParts [ $ i ] ) || $ fromParts [ $ i ] !== $ toParts [ $ i ] ) { break ; } } $ len = count ( $ fromParts ) - $ i - 1 ; $ path = array_slice ( $ toParts , $ i ) ; if ( $ len < 0 ) { return implode ( "/" , $ path ) ; } return str_repeat ( "../" , $ len ) . implode ( "/" , $ path ) ; }
9528	private function parseSingle ( & $ i , $ parameter , & $ results ) { if ( $ this -> prefixExists ( $ parameter ) ) { $ closure = $ this -> getClosure ( $ parameter ) ; if ( $ closure != null ) { $ prefix = $ this -> getPrefix ( $ parameter ) ; $ closure_arguments = [ ] ; $ rFunction = new ReflectionFunction ( $ closure ) ; if ( $ rFunction -> isVariadic ( ) ) { $ this -> parseVariadicParameter ( $ i , $ results , $ closure , $ closure_arguments , $ prefix , $ parameter ) ; } else { $ this -> parseUniadicParameter ( $ i , $ results , $ closure , $ closure_arguments , $ prefix , $ parameter , $ rFunction ) ; } $ result_key = $ this -> getRealName ( $ parameter ) ; $ result = $ results [ $ result_key ] ; if ( ! $ result instanceof ParameterResult ) { if ( $ result == self :: HALT_PARSE ) { $ this -> haltedBy = $ this -> getParameterClosure ( $ parameter ) ; unset ( $ results [ $ result_key ] ) ; return false ; } } else { if ( $ result -> shouldHalt ( ) ) { $ this -> haltedBy = $ this -> getParameterClosure ( $ parameter ) ; if ( $ result -> isHaltOnly ( ) ) { unset ( $ results [ $ result_key ] ) ; } else { $ results [ $ result_key ] = $ result -> getValue ( ) ; } return false ; } } } else { $ this -> respondDefault ( $ i , $ results , $ parameter ) ; } } else { $ this -> respondDefault ( $ i , $ results , $ parameter ) ; } return true ; }
5895	public function listImageTemplates ( CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/templates/images' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new ImageTemplate ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
11146	public function move ( Neuron_GameServer_Map_MapObject $ object , Neuron_GameServer_Map_Location $ location , Neuron_GameServer_Map_Date $ start , Neuron_GameServer_Map_Date $ end ) { throw new Neuron_Exceptions_NotImplemented ( "The move method is not implemented in this map." ) ; }
2771	public function cloneRepository ( string $ repository , array $ options = [ ] ) : string { $ argsAndOptions = [ $ repository , $ this -> directory , $ options ] ; return $ this -> run ( 'clone' , $ argsAndOptions , false ) ; }
9680	public function getColumnDisplayName ( $ columnName ) { return isset ( $ this -> columnDisplayNames [ $ columnName ] ) ? $ this -> columnDisplayNames [ $ columnName ] : $ columnName ; }
2235	public function onGeneratePage ( PageModel $ pageModel , LayoutModel $ layoutModel ) : void { $ calendarfeeds = StringUtil :: deserialize ( $ layoutModel -> calendarfeeds ) ; if ( empty ( $ calendarfeeds ) || ! \ is_array ( $ calendarfeeds ) ) { return ; } $ this -> framework -> initialize ( ) ; $ adapter = $ this -> framework -> getAdapter ( CalendarFeedModel :: class ) ; if ( ! ( $ feeds = $ adapter -> findByIds ( $ calendarfeeds ) ) instanceof Collection ) { return ; } $ template = $ this -> framework -> getAdapter ( Template :: class ) ; $ environment = $ this -> framework -> getAdapter ( Environment :: class ) ; foreach ( $ feeds as $ feed ) { $ GLOBALS [ 'TL_HEAD' ] [ ] = $ template -> generateFeedTag ( sprintf ( '%sshare/%s.xml' , ( $ feed -> feedBase ? : $ environment -> get ( 'base' ) ) , $ feed -> alias ) , $ feed -> format , $ feed -> title ) ; } }
1686	public function updateCurrentUser ( Contao \ DataContainer $ dc ) { if ( $ this -> User -> id == $ dc -> id ) { $ this -> User -> findBy ( 'id' , $ this -> User -> id ) ; } }
9017	public function getWords ( $ string , $ minLength = null ) { $ tokenizer = new Whitespace ( ) ; $ words = $ tokenizer -> tokenize ( $ string ) ; if ( ! is_null ( $ minLength ) ) { foreach ( $ words as $ key => $ word ) { if ( strlen ( $ word ) <= $ minLength ) { unset ( $ words [ $ key ] ) ; } } } return array_values ( $ words ) ; }
5083	protected function lookUpResource ( $ aData = [ ] , $ iSegment = 4 ) { $ oUri = Factory :: service ( 'Uri' ) ; $ sIdentifier = $ oUri -> segment ( $ iSegment ) ; $ oInput = Factory :: service ( 'Input' ) ; $ aData = array_merge ( static :: CONFIG_LOOKUP_DATA , $ aData ) ; $ aExpansions = array_filter ( ( array ) $ oInput -> get ( 'expand' ) ) ; if ( $ aExpansions ) { if ( ! array_key_exists ( 'expand' , $ aData ) ) { $ aData [ 'expand' ] = [ ] ; } $ aData [ 'expand' ] = array_merge ( $ aData [ 'expand' ] , $ aExpansions ) ; } switch ( static :: CONFIG_LOOKUP_METHOD ) { case 'ID' : return $ this -> oModel -> getById ( $ sIdentifier , $ aData ) ; break ; case 'SLUG' : return $ this -> oModel -> getBySlug ( $ sIdentifier , $ aData ) ; break ; case 'TOKEN' : return $ this -> oModel -> getByToken ( $ sIdentifier , $ aData ) ; break ; } }
129	protected function requestContent ( $ origin , $ path ) { $ url = rtrim ( $ origin , '/' ) . '/' . ltrim ( $ path , '/' ) ; $ content = $ this -> rfs -> getContents ( $ origin , $ url , false ) ; if ( ! $ content ) { throw new \ UnexpectedValueException ( 'The PEAR channel at ' . $ url . ' did not respond.' ) ; } return str_replace ( 'http://pear.php.net/rest/' , 'https://pear.php.net/rest/' , $ content ) ; }
5183	public function article ( string $ singleJsonArticle ) : Article { if ( json_decode ( $ singleJsonArticle , true ) ) { $ dataArticle = json_decode ( $ singleJsonArticle , true ) [ 'data' ] ; $ article = new Article ( $ this -> filterString ( $ this -> getValue ( 'title' , $ dataArticle ) ) , $ this -> filterString ( $ this -> getValue ( 'body' , $ dataArticle ) ) , $ this -> filterString ( $ this -> getValue ( 'source' , $ dataArticle ) ) , $ this -> getValue ( 'unique_id' , $ dataArticle ) , $ this -> filterInteger ( $ this -> getValue ( 'type_id' , $ dataArticle [ 'type' ] ) ) , $ this -> filterInteger ( $ this -> getValue ( 'category_id' , $ dataArticle [ 'category' ] ) ) , $ this -> getValue ( 'reporter' , $ dataArticle ) , $ this -> filterString ( $ this -> getValue ( 'lead' , $ dataArticle ) ) , $ this -> getValue ( 'tag_name' , $ dataArticle [ 'tags' ] ) , $ this -> filterString ( $ this -> getValue ( 'published_at' , $ dataArticle ) ) , ( string ) $ this -> filterInteger ( $ this -> getValue ( 'id' , $ dataArticle ) ) ) ; $ attachmentConstants = [ Article :: ATTACHMENT_FIELD_PHOTO , Article :: ATTACHMENT_FIELD_PAGE , Article :: ATTACHMENT_FIELD_GALLERY , Article :: ATTACHMENT_FIELD_VIDEO , ] ; $ attachmentTypes = [ self :: JSON_PHOTO_FIELD , self :: JSON_PAGE_FIELD , self :: JSON_GALLERY_FIELD , self :: JSON_VIDEO_FIELD , ] ; $ attachmentAttributes = $ this -> lookUp ( $ attachmentConstants ) ; return $ this -> generalAttachment ( $ article , $ attachmentConstants , $ attachmentTypes , $ attachmentAttributes , $ dataArticle ) ; } throw new \ Exception ( 'Empty or invalid JSON Response' , 1 ) ; }
10285	public static function columnIndexFromString ( $ pString ) { static $ indexCache = [ ] ; if ( isset ( $ indexCache [ $ pString ] ) ) { return $ indexCache [ $ pString ] ; } static $ columnLookup = [ 'A' => 1 , 'B' => 2 , 'C' => 3 , 'D' => 4 , 'E' => 5 , 'F' => 6 , 'G' => 7 , 'H' => 8 , 'I' => 9 , 'J' => 10 , 'K' => 11 , 'L' => 12 , 'M' => 13 , 'N' => 14 , 'O' => 15 , 'P' => 16 , 'Q' => 17 , 'R' => 18 , 'S' => 19 , 'T' => 20 , 'U' => 21 , 'V' => 22 , 'W' => 23 , 'X' => 24 , 'Y' => 25 , 'Z' => 26 , 'a' => 1 , 'b' => 2 , 'c' => 3 , 'd' => 4 , 'e' => 5 , 'f' => 6 , 'g' => 7 , 'h' => 8 , 'i' => 9 , 'j' => 10 , 'k' => 11 , 'l' => 12 , 'm' => 13 , 'n' => 14 , 'o' => 15 , 'p' => 16 , 'q' => 17 , 'r' => 18 , 's' => 19 , 't' => 20 , 'u' => 21 , 'v' => 22 , 'w' => 23 , 'x' => 24 , 'y' => 25 , 'z' => 26 , ] ; if ( isset ( $ pString [ 0 ] ) ) { if ( ! isset ( $ pString [ 1 ] ) ) { $ indexCache [ $ pString ] = $ columnLookup [ $ pString ] ; return $ indexCache [ $ pString ] ; } elseif ( ! isset ( $ pString [ 2 ] ) ) { $ indexCache [ $ pString ] = $ columnLookup [ $ pString [ 0 ] ] * 26 + $ columnLookup [ $ pString [ 1 ] ] ; return $ indexCache [ $ pString ] ; } elseif ( ! isset ( $ pString [ 3 ] ) ) { $ indexCache [ $ pString ] = $ columnLookup [ $ pString [ 0 ] ] * 676 + $ columnLookup [ $ pString [ 1 ] ] * 26 + $ columnLookup [ $ pString [ 2 ] ] ; return $ indexCache [ $ pString ] ; } } throw new Exception ( 'Column string index can not be ' . ( ( isset ( $ pString [ 0 ] ) ) ? 'longer than 3 characters' : 'empty' ) ) ; }
6690	public function canAccess ( $ permissionKeys , $ fullAccessKey , $ errorMsg , $ defaultUrl , $ redirect = false ) { if ( $ this -> getUser ( ) -> isGuest ) { return $ this -> getUser ( ) -> loginRequired ( ) ; } if ( $ this -> getPermissionManager ( ) -> canAccess ( $ fullAccessKey ) ) { return true ; } if ( ! is_array ( $ permissionKeys ) ) { $ permissionKeys = [ $ permissionKeys ] ; } foreach ( $ permissionKeys as $ permissionKey ) { if ( $ this -> getPermissionManager ( ) -> canAccess ( $ permissionKey ) ) { return true ; } } if ( $ redirect ) { $ this -> flashError ( $ errorMsg ) ; $ request = $ this -> getRequest ( ) ; $ referrerUrl = $ request -> referrer ; $ redirectUrl = ( $ referrerUrl == $ request -> url || is_null ( $ referrerUrl ) ) ? $ defaultUrl : $ referrerUrl ; $ this -> redirect ( $ redirectUrl ) -> send ( ) ; Yii :: $ app -> end ( ) ; } return false ; }
1430	protected function deserializeSoftDelete ( $ value , $ field , $ record ) { if ( collect ( [ true , false , 1 , 0 , '1' , '0' ] ) -> containsStrict ( $ value ) ) { return $ value ? Carbon :: now ( ) : null ; } return $ this -> deserializeAttribute ( $ value , $ field , $ record ) ; }
9571	public function bootConsole ( ) { $ this -> console = new ConsoleApplication ( 'Autarky' , static :: VERSION ) ; $ this -> console -> setAutarkyApplication ( $ this ) ; $ this -> boot ( ) ; return $ this -> console ; }
7512	function next ( ) { $ this -> token_start = null ; if ( ++ $ this -> pos < $ this -> size ) { if ( isset ( $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ) { if ( is_string ( $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ) { return ( $ this -> token = $ this -> { $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] } ( ) ) ; } else { return ( $ this -> token = $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ; } } else { return ( $ this -> token = self :: TOK_UNKNOWN ) ; } } else { return ( $ this -> token = self :: TOK_NULL ) ; } }
856	public function overrideAt ( $ index , $ token ) { @ trigger_error ( __METHOD__ . ' is deprecated and will be removed in 3.0, use offsetSet instead.' , E_USER_DEPRECATED ) ; self :: $ isLegacyMode = true ; $ this [ $ index ] -> override ( $ token ) ; $ this -> registerFoundToken ( $ token ) ; }
8362	public static function registerTranslations ( $ baseDir , $ localesDir , $ prefix = null ) { if ( self :: $ isInit === true ) { $ dir = $ baseDir . DIRECTORY_SEPARATOR . $ localesDir ; if ( is_dir ( $ dir ) === false ) { throw new InvalidDirectory ( 'directory "' . $ dir . '" can\'t be identified' ) ; } $ language = self :: $ currentLanguage ; if ( ( $ pos = strpos ( $ language , '-' ) ) !== false ) { $ pos = ( int ) $ pos ; $ language = substr ( $ language , 0 , $ pos ) ; } if ( ( $ pos = strpos ( $ language , '_' ) ) !== false ) { $ pos = ( int ) $ pos ; $ language = substr ( $ language , 0 , $ pos ) ; } if ( is_readable ( $ dir . DIRECTORY_SEPARATOR . $ language . '.yml' ) === true ) { $ newOnes = Config :: get ( $ dir . DIRECTORY_SEPARATOR . $ language . '.yml' ) ; if ( is_array ( $ newOnes ) === true ) { if ( $ prefix != null ) { $ newOnes = array ( $ prefix => $ newOnes ) ; } self :: $ translations = array_merge ( self :: $ translations , $ newOnes ) ; } } else { Logger :: get ( ) -> notice ( 'can\'t find language "' . $ language . '" in directory "' . $ dir . '"' ) ; } } }
8996	protected function buildNamespace ( ApiDefinition $ definition , $ namespace ) { if ( $ this -> config [ 'version_in_namespace' ] && $ definition -> getVersion ( ) ) { $ namespace .= '\\' . preg_replace ( array ( '/(^[0-9])/' , '/[^a-zA-Z0-9]/' ) , array ( 'Version\1' , '_' ) , $ definition -> getVersion ( ) ) ; } return $ namespace ; }
12022	function addCheckScopeMethod ( ) { $ scopes = $ this -> operationDefinition -> getScopes ( ) ; if ( count ( $ scopes ) == 0 ) { return ; } $ methodGenerator = new MethodGenerator ( 'checkScopeRequirement' ) ; $ parameterGenerator = new ParameterGenerator ( 'allowedScopes' , 'array' ) ; $ methodGenerator -> setParameter ( $ parameterGenerator ) ; $ body = '//For each of the elements, all of the scopes in that element' . PHP_EOL ; $ body .= '//must be satisfied' . PHP_EOL ; $ body .= '$requiredScopesArray = [' . PHP_EOL ; foreach ( $ scopes as $ scopeList ) { $ body .= ' [' ; $ separator = '' ; foreach ( $ scopeList as $ scope ) { $ body .= sprintf ( "%s'%s'" , $ separator , $ scope ) ; $ separator = ', ' ; } $ body .= ']' . PHP_EOL ; } $ body .= '];' . PHP_EOL . PHP_EOL ; $ body .= <<< 'END'foreach($requiredScopesArray as $requiredScopes) { $requirementMet = true; foreach ($requiredScopes as $requiredScope) { if (in_array($requiredScope, $allowedScopes) == false) { $requirementMet = false; break; } } if ($requirementMet == true) { return true; }}return false;END ; $ methodGenerator -> setBody ( $ body ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; }
12275	private function getTemplatePath ( $ template ) { if ( strpos ( $ template , '@' ) === false && ! empty ( $ this -> defaultNamespace ) ) { $ template .= '@' . $ this -> defaultNamespace ; } $ map = $ this -> buildTemplatesMap ( ) ; if ( ! array_key_exists ( $ template , $ map ) ) { throw new \ RuntimeException ( "A template by the name '$template' does not exist. The following templates are available: " . join ( ', ' , array_keys ( $ map ) ) ) ; } return $ map [ $ template ] ; }
9105	protected function parse_time ( ) { if ( ! empty ( $ this -> args [ 'time' ] ) ) { $ date_query = new \ WP_Date_Query ( $ this -> args [ 'time' ] , 'q.time' ) ; return new Where_Date ( $ date_query ) ; } else { return null ; } }
2587	protected function loadCreatePnr ( PnrCreatePnrOptions $ params ) { $ this -> pnrActions = new AddMultiElements \ PnrActions ( $ params -> actionCode ) ; $ tattooCounter = 0 ; if ( $ params -> travellerGroup !== null ) { $ this -> addTravellerGroup ( $ params -> travellerGroup ) ; } else { $ this -> addTravellers ( $ params -> travellers ) ; } $ this -> addItineraries ( $ params -> itineraries , $ params -> tripSegments , $ tattooCounter ) ; $ this -> addElements ( $ params -> elements , $ tattooCounter , $ params -> autoAddReceivedFrom , $ params -> defaultReceivedFrom , $ params -> receivedFrom ) ; }
12403	public function replace ( $ id , $ document = null ) { return Parser :: replace ( $ id , $ document , $ this -> connection ) ; }
1721	private function getStringRepresentation ( array $ chunks , $ value ) : string { switch ( \ count ( $ chunks ) ) { case 2 : return sprintf ( "\$GLOBALS['TL_LANG']['%s'][%s] = %s;\n" , $ chunks [ 0 ] , $ this -> quoteKey ( $ chunks [ 1 ] ) , $ this -> quoteValue ( $ value ) ) ; case 3 : return sprintf ( "\$GLOBALS['TL_LANG']['%s'][%s][%s] = %s;\n" , $ chunks [ 0 ] , $ this -> quoteKey ( $ chunks [ 1 ] ) , $ this -> quoteKey ( $ chunks [ 2 ] ) , $ this -> quoteValue ( $ value ) ) ; case 4 : return sprintf ( "\$GLOBALS['TL_LANG']['%s'][%s][%s][%s] = %s;\n" , $ chunks [ 0 ] , $ this -> quoteKey ( $ chunks [ 1 ] ) , $ this -> quoteKey ( $ chunks [ 2 ] ) , $ this -> quoteKey ( $ chunks [ 3 ] ) , $ this -> quoteValue ( $ value ) ) ; } throw new \ OutOfBoundsException ( 'Cannot load less than 2 or more than 4 levels in XLIFF language files.' ) ; }
8879	private function isValidHomeDirectory ( string $ path ) : bool { $ valid = false ; if ( '~/' === substr ( $ path , 0 , 2 ) ) { $ valid = $ this -> isValidFullPath ( $ this -> expandHomeDirectory ( $ path ) ) ; } return $ valid ; }
12560	public function fixFileSlashes ( $ file , & $ contents ) { $ changed = false ; foreach ( $ contents as $ lineNumber => $ line ) { if ( preg_match ( '/(psesd|canis|cascade)\\\\\\\/' , $ line ) === 1 ) { $ fixedLine = preg_replace ( '/\\\\\\\/' , '\\' , $ line ) ; if ( $ fixedLine !== $ line ) { $ contents [ $ lineNumber ] = $ fixedLine ; $ changed = true ; } } } return $ changed ; }
5580	public function submitFormById ( $ id , $ additional = false ) { if ( ! ( $ form = $ this -> page -> getFormById ( $ id ) ) ) { return false ; } $ success = $ this -> load ( $ form -> getAction ( ) , $ form -> submit ( $ additional ) ) ; return ( $ success ? $ this -> getContent ( ) : $ success ) ; }
11714	public function getTokenFromServer ( ) { $ params = [ 'appid' => $ this -> appId , 'secret' => $ this -> secret , 'grant_type' => 'client_credential' , ] ; $ http = $ this -> getHttp ( ) ; $ token = $ http -> parseJSON ( $ http -> get ( self :: API_TOKEN_GET , $ params ) ) ; if ( empty ( $ token [ $ this -> tokenJsonKey ] ) ) { throw new HttpException ( 'Request AccessToken fail. response: ' . json_encode ( $ token , JSON_UNESCAPED_UNICODE ) ) ; } return $ token ; }
826	public function isBeforeStructuralElement ( Tokens $ tokens , $ index ) { $ token = $ tokens [ $ index ] ; if ( ! $ token -> isGivenKind ( [ T_COMMENT , T_DOC_COMMENT ] ) ) { throw new \ InvalidArgumentException ( 'Given index must point to a comment.' ) ; } $ nextIndex = $ index ; do { $ nextIndex = $ tokens -> getNextMeaningfulToken ( $ nextIndex ) ; } while ( null !== $ nextIndex && $ tokens [ $ nextIndex ] -> equals ( '(' ) ) ; if ( null === $ nextIndex || $ tokens [ $ nextIndex ] -> equals ( '}' ) ) { return false ; } $ nextToken = $ tokens [ $ nextIndex ] ; if ( $ this -> isStructuralElement ( $ nextToken ) ) { return true ; } if ( $ this -> isValidControl ( $ tokens , $ token , $ nextIndex ) ) { return true ; } if ( $ this -> isValidVariable ( $ tokens , $ nextIndex ) ) { return true ; } if ( $ this -> isValidLanguageConstruct ( $ tokens , $ token , $ nextIndex ) ) { return true ; } return false ; }
758	protected function renderImageByImagick ( $ code ) { $ backColor = $ this -> transparent ? new \ ImagickPixel ( 'transparent' ) : new \ ImagickPixel ( '#' . str_pad ( dechex ( $ this -> backColor ) , 6 , 0 , STR_PAD_LEFT ) ) ; $ foreColor = new \ ImagickPixel ( '#' . str_pad ( dechex ( $ this -> foreColor ) , 6 , 0 , STR_PAD_LEFT ) ) ; $ image = new \ Imagick ( ) ; $ image -> newImage ( $ this -> width , $ this -> height , $ backColor ) ; $ draw = new \ ImagickDraw ( ) ; $ draw -> setFont ( $ this -> fontFile ) ; $ draw -> setFontSize ( 30 ) ; $ fontMetrics = $ image -> queryFontMetrics ( $ draw , $ code ) ; $ length = strlen ( $ code ) ; $ w = ( int ) $ fontMetrics [ 'textWidth' ] - 8 + $ this -> offset * ( $ length - 1 ) ; $ h = ( int ) $ fontMetrics [ 'textHeight' ] - 8 ; $ scale = min ( ( $ this -> width - $ this -> padding * 2 ) / $ w , ( $ this -> height - $ this -> padding * 2 ) / $ h ) ; $ x = 10 ; $ y = round ( $ this -> height * 27 / 40 ) ; for ( $ i = 0 ; $ i < $ length ; ++ $ i ) { $ draw = new \ ImagickDraw ( ) ; $ draw -> setFont ( $ this -> fontFile ) ; $ draw -> setFontSize ( ( int ) ( mt_rand ( 26 , 32 ) * $ scale * 0.8 ) ) ; $ draw -> setFillColor ( $ foreColor ) ; $ image -> annotateImage ( $ draw , $ x , $ y , mt_rand ( - 10 , 10 ) , $ code [ $ i ] ) ; $ fontMetrics = $ image -> queryFontMetrics ( $ draw , $ code [ $ i ] ) ; $ x += ( int ) $ fontMetrics [ 'textWidth' ] + $ this -> offset ; } $ image -> setImageFormat ( 'png' ) ; return $ image -> getImageBlob ( ) ; }
2580	protected function loadWsdl ( $ params ) { if ( isset ( $ params [ 'wsdl' ] ) ) { if ( is_string ( $ params [ 'wsdl' ] ) ) { $ this -> wsdl = [ $ params [ 'wsdl' ] ] ; } elseif ( is_array ( $ params [ 'wsdl' ] ) ) { $ this -> wsdl = $ params [ 'wsdl' ] ; } } }
1629	public function getMonolog ( ) { foreach ( $ this -> loggers as $ logger ) { if ( is_callable ( [ $ logger , 'getMonolog' ] ) ) { $ monolog = $ logger -> getMonolog ( ) ; if ( $ monolog === null ) { continue ; } return $ monolog ; } } }
385	public function getOrders ( $ recalculate = false ) { $ attributeOrders = $ this -> getAttributeOrders ( $ recalculate ) ; $ orders = [ ] ; foreach ( $ attributeOrders as $ attribute => $ direction ) { $ definition = $ this -> attributes [ $ attribute ] ; $ columns = $ definition [ $ direction === SORT_ASC ? 'asc' : 'desc' ] ; if ( is_array ( $ columns ) || $ columns instanceof \ Traversable ) { foreach ( $ columns as $ name => $ dir ) { $ orders [ $ name ] = $ dir ; } } else { $ orders [ ] = $ columns ; } } return $ orders ; }
225	protected function asPercentStringFallback ( $ value , $ decimals = null ) { if ( empty ( $ value ) ) { $ value = 0 ; } if ( $ decimals === null ) { $ decimals = 0 ; } $ value = $ this -> normalizeNumericStringValue ( ( string ) $ value ) ; $ separatorPosition = strrpos ( $ value , '.' ) ; if ( $ separatorPosition !== false ) { $ integerPart = substr ( $ value , 0 , $ separatorPosition ) ; $ fractionalPart = str_pad ( substr ( $ value , $ separatorPosition + 1 ) , 2 , '0' ) ; $ integerPart .= substr ( $ fractionalPart , 0 , 2 ) ; $ fractionalPart = substr ( $ fractionalPart , 2 ) ; if ( $ fractionalPart === '' ) { $ multipliedValue = $ integerPart ; } else { $ multipliedValue = $ integerPart . '.' . $ fractionalPart ; } } else { $ multipliedValue = $ value . '00' ; } return $ this -> asDecimalStringFallback ( $ multipliedValue , $ decimals ) . '%' ; }
307	private function sizeToBytes ( $ sizeStr ) { switch ( substr ( $ sizeStr , - 1 ) ) { case 'M' : case 'm' : return ( int ) $ sizeStr * 1048576 ; case 'K' : case 'k' : return ( int ) $ sizeStr * 1024 ; case 'G' : case 'g' : return ( int ) $ sizeStr * 1073741824 ; default : return ( int ) $ sizeStr ; } }
12176	public function addClassArgument ( $ name , $ class , $ required = true ) { return $ this -> addArgument ( new ClassArgument ( $ this -> argumentPosition ++ , $ name , $ class , $ required ) ) ; }
9812	protected function putRaw ( string $ path , $ body = null , array $ headers = [ ] ) { $ response = $ this -> client -> put ( $ path , $ headers , $ body ) ; return ResponseMediator :: getContent ( $ response ) ; }
10938	private static function populateEntries ( $ heading , $ data , $ key ) { foreach ( LogLevels :: all ( ) as $ level ) { if ( self :: hasLogLevel ( $ heading [ $ key ] , $ level ) ) { self :: $ parsed [ ] = [ 'level' => $ level , 'header' => $ heading [ $ key ] , 'stack' => $ data [ $ key ] , ] ; } } }
6493	private function compareAcceptMediaTypeHeaders ( AcceptMediaTypeHeaderValue $ a , AcceptMediaTypeHeaderValue $ b ) : int { $ aQuality = $ a -> getQuality ( ) ; $ bQuality = $ b -> getQuality ( ) ; if ( $ aQuality < $ bQuality ) { return 1 ; } if ( $ aQuality > $ bQuality ) { return - 1 ; } $ aType = $ a -> getType ( ) ; $ bType = $ b -> getType ( ) ; $ aSubType = $ a -> getSubType ( ) ; $ bSubType = $ b -> getSubType ( ) ; if ( $ aType === '*' ) { if ( $ bType === '*' ) { return 0 ; } return 1 ; } if ( $ aSubType === '*' ) { if ( $ bSubType === '*' ) { return 0 ; } return 1 ; } if ( $ bType === '*' || $ bSubType === '*' ) { return - 1 ; } return 0 ; }
693	public function compose ( $ view = null , array $ params = [ ] ) { $ message = $ this -> createMessage ( ) ; if ( $ view === null ) { return $ message ; } if ( ! array_key_exists ( 'message' , $ params ) ) { $ params [ 'message' ] = $ message ; } $ this -> _message = $ message ; if ( is_array ( $ view ) ) { if ( isset ( $ view [ 'html' ] ) ) { $ html = $ this -> render ( $ view [ 'html' ] , $ params , $ this -> htmlLayout ) ; } if ( isset ( $ view [ 'text' ] ) ) { $ text = $ this -> render ( $ view [ 'text' ] , $ params , $ this -> textLayout ) ; } } else { $ html = $ this -> render ( $ view , $ params , $ this -> htmlLayout ) ; } $ this -> _message = null ; if ( isset ( $ html ) ) { $ message -> setHtmlBody ( $ html ) ; } if ( isset ( $ text ) ) { $ message -> setTextBody ( $ text ) ; } elseif ( isset ( $ html ) ) { if ( preg_match ( '~<body[^>]*>(.*?)</body>~is' , $ html , $ match ) ) { $ html = $ match [ 1 ] ; } $ html = preg_replace ( '~<((style|script))[^>]*>(.*?)</\1>~is' , '' , $ html ) ; $ text = html_entity_decode ( strip_tags ( $ html ) , ENT_QUOTES | ENT_HTML5 , Yii :: $ app ? Yii :: $ app -> charset : 'UTF-8' ) ; $ text = preg_replace ( "~^[ \t]+~m" , '' , trim ( $ text ) ) ; $ text = preg_replace ( '~\R\R+~mu' , "\n\n" , $ text ) ; $ message -> setTextBody ( $ text ) ; } return $ message ; }
9188	public function connect ( ) { if ( ! is_resource ( $ this -> handle ) ) { throw new SocketException ( "Socket is not available" ) ; } if ( ! @ socket_connect ( $ this -> handle , $ this -> endpoint -> getAddress ( ) , $ this -> endpoint -> getPort ( ) ) ) { $ code = socket_last_error ( $ this -> handle ) ; throw new SocketException ( socket_strerror ( $ code ) , array ( ) , $ code ) ; } $ this -> conntected = true ; }
3320	public function getValidValues ( ) { if ( $ this -> validValues ) { if ( is_callable ( $ this -> validValues ) ) { return call_user_func ( $ this -> validValues ) ; } return $ this -> validValues ; } return ; }
8191	public function actionConfirm ( $ id , $ code ) { $ user = UserIdentity :: findByActivationToken ( $ id , $ code ) ; if ( $ user == NULL ) throw new NotFoundHttpException ; if ( ! empty ( $ user ) ) { $ user -> activation_token = NULL ; $ user -> status = User :: STATUS_ACTIVE ; $ user -> save ( FALSE ) ; Yii :: $ app -> session -> setFlash ( 'success' , Yii :: t ( 'user' , 'Account ' . $ user -> email . ' has successfully been activated' ) ) ; } else Yii :: $ app -> session -> setFlash ( 'error' , Yii :: t ( 'user' , 'Account ' . $ user -> email . ' could not been activated. Please contact the Administrator' ) ) ; return $ this -> render ( 'confirm' , [ 'user' => $ user ] ) ; }
11929	public function setDataInterface ( $ value ) { if ( ( $ interfaceItem = Yii :: $ app -> collectors [ 'dataInterfaces' ] -> getOne ( $ value ) ) && ( $ interface = $ interfaceItem -> object ) ) { $ this -> _interface = $ interfaceItem ; } else { throw new Exception ( "Invalid interface!" ) ; } }
5636	public function paintFail ( $ message ) { parent :: paintFail ( $ message ) ; print $ this -> getFailCount ( ) . ") $message\n" ; $ breadcrumb = $ this -> getTestList ( ) ; array_shift ( $ breadcrumb ) ; print "\tin " . implode ( "\n\tin " , array_reverse ( $ breadcrumb ) ) ; print "\n" ; }
2162	public function run35Update ( ) { $ this -> Database -> query ( "ALTER TABLE `tl_member` CHANGE `username` `username` varchar(64) COLLATE utf8_bin NULL" ) ; $ this -> Database -> query ( "UPDATE `tl_member` SET username=NULL WHERE username=''" ) ; $ this -> Database -> query ( "ALTER TABLE `tl_member` DROP INDEX `username`, ADD UNIQUE KEY `username` (`username`)" ) ; }
3235	public function getCountAttribute ( ) { if ( empty ( $ this -> shopCalculations ) ) $ this -> runCalculations ( ) ; return round ( $ this -> shopCalculations -> itemCount , 2 ) ; }
9286	public function create ( ) { $ adapter = $ this -> dbAdapter ; $ ddl = new Ddl \ CreateTable ( ) ; $ ddl -> setTable ( self :: TABLE_NAME ) -> addColumn ( new Column \ Integer ( 'id' , false , null , array ( 'autoincrement' => true ) ) ) -> addColumn ( new Column \ Varchar ( 'code' , 55 ) ) -> addColumn ( new Column \ Varchar ( 'status' , 55 ) ) -> addColumn ( new Column \ Text ( 'error_msg' ) ) -> addColumn ( new Column \ Text ( 'stack_trace' ) ) -> addColumn ( new Column \ Varchar ( 'created' , 255 ) ) -> addColumn ( new Column \ Varchar ( 'scheduled' , 255 ) ) -> addColumn ( new Column \ Varchar ( 'executed' , 255 ) ) -> addColumn ( new Column \ Varchar ( 'finished' , 255 ) ) -> addConstraint ( new Constraint \ PrimaryKey ( 'id' ) ) ; $ sql = ( new Sql ( $ adapter ) ) -> getSqlStringForSqlObject ( $ ddl ) ; $ adapter -> query ( $ sql , $ adapter :: QUERY_MODE_EXECUTE ) ; }
2409	public static function getInstance ( $ strTable ) { if ( ! isset ( static :: $ arrInstances [ $ strTable ] ) ) { static :: $ arrInstances [ $ strTable ] = new static ( $ strTable ) ; } return static :: $ arrInstances [ $ strTable ] ; }
10932	public function hasRowsWith ( string $ tablename , string $ colName , $ colValue ) : bool { return ( $ this -> countRowsWith ( $ tablename , $ colName , $ colValue ) > 0 ) ; }
6060	public function retrieveFileData ( $ id , $ template = null , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'template' => $ template ] , 'body' => json_encode ( [ ] ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/media/' . $ id . '/asset' , $ parameters , $ cachePolicy ) ; return $ result ; }
3491	public function withHeader ( string $ name , string $ value ) : Request { $ cloned = clone $ this ; $ cloned -> headers [ $ name ] = $ value ; return $ cloned ; }
551	public function actionFlush ( ) { $ cachesInput = func_get_args ( ) ; if ( empty ( $ cachesInput ) ) { throw new Exception ( 'You should specify cache components names' ) ; } $ caches = $ this -> findCaches ( $ cachesInput ) ; $ cachesInfo = [ ] ; $ foundCaches = array_keys ( $ caches ) ; $ notFoundCaches = array_diff ( $ cachesInput , array_keys ( $ caches ) ) ; if ( $ notFoundCaches ) { $ this -> notifyNotFoundCaches ( $ notFoundCaches ) ; } if ( ! $ foundCaches ) { $ this -> notifyNoCachesFound ( ) ; return ExitCode :: OK ; } if ( ! $ this -> confirmFlush ( $ foundCaches ) ) { return ExitCode :: OK ; } foreach ( $ caches as $ name => $ class ) { $ cachesInfo [ ] = [ 'name' => $ name , 'class' => $ class , 'is_flushed' => $ this -> canBeFlushed ( $ class ) ? Yii :: $ app -> get ( $ name ) -> flush ( ) : false , ] ; } $ this -> notifyFlushed ( $ cachesInfo ) ; }
10869	public function getByEmail ( string $ email ) { return $ this -> getList ( ) -> where ( [ $ this -> tableName [ 0 ] . '.email' => $ email , $ this -> tableName [ 0 ] . '.active' => true ] ) -> fetch ( ) ; }
6514	public function invoke ( JobInterface $ job , ContextInterface $ context ) { $ jobType = $ this -> registry -> get ( $ job -> getType ( ) ) ; $ callableArray = $ jobType -> getCallable ( ) ; $ parameters = static :: resolveParameters ( $ jobType , $ context , $ job -> getParameters ( ) ) ; if ( is_array ( $ callableArray ) && $ callable = $ callableArray [ 0 ] ) { if ( $ callable instanceof JobAwareInterface ) { $ callable -> setJob ( $ job ) ; } if ( $ callable instanceof ManagerAwareInterface ) { $ callable -> setManager ( $ this -> manager ) ; } if ( $ callable instanceof ControllerAwareInterface ) { $ callable -> setController ( $ this -> controllerFactory -> create ( $ job ) ) ; } if ( $ callable instanceof LoggerAwareInterface && $ context -> has ( 'abc.logger' ) ) { $ callable -> setLogger ( $ context -> get ( 'abc.logger' ) ) ; } } return call_user_func_array ( $ callableArray , $ parameters ) ; }
5031	public function setLoadedPage ( $ loadedPage ) { $ this -> dispatch ( Event \ PageEvents :: PAGE_VIEW , new Event \ PageViewEvent ( $ loadedPage ) ) ; $ this -> loadedPage = $ loadedPage ; }
10036	function getBlockedContacts ( $ standardFields = array ( ) , $ customFields = array ( ) , $ pageIndex = 1 , $ pageSize = 1000 ) { $ queryParameters = array ( 'standard_field' => $ standardFields , 'page_index' => $ pageIndex , 'page_size' => $ pageSize ) ; $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , 'custom_field' , $ customFields ) ; return $ this -> get ( 'contacts/blocked' , $ queryParameters ) ; }
12320	public static function getBundleLocationName ( string $ sName ) : string { $ oConfig = self :: get ( $ sName , null , true ) ; if ( isset ( $ oConfig -> redirect ) ) { return $ oConfig -> redirect ; } else { return PORTAL ; } }
568	private function formatTimestamp ( $ timestamp , $ format ) { if ( strncmp ( $ format , 'php:' , 4 ) === 0 ) { $ format = substr ( $ format , 4 ) ; } else { $ format = FormatConverter :: convertDateIcuToPhp ( $ format , 'date' ) ; } $ date = new DateTime ( ) ; $ date -> setTimestamp ( $ timestamp ) ; $ date -> setTimezone ( new \ DateTimeZone ( $ this -> timestampAttributeTimeZone ) ) ; return $ date -> format ( $ format ) ; }
5382	public function setValue ( $ desired ) { $ achieved = array ( ) ; foreach ( $ desired as $ value ) { $ success = false ; for ( $ i = 0 , $ count = count ( $ this -> options ) ; $ i < $ count ; $ i ++ ) { if ( $ this -> options [ $ i ] -> isValue ( $ value ) ) { $ achieved [ ] = $ this -> options [ $ i ] -> getValue ( ) ; $ success = true ; break ; } } if ( ! $ success ) { return false ; } } $ this -> values = $ achieved ; return true ; }
1464	private function guessKey ( ) { if ( $ this -> query instanceof EloquentBuilder || $ this -> query instanceof Relation ) { return $ this -> query -> getModel ( ) -> getRouteKeyName ( ) ; } return 'id' ; }
526	public function init ( ) { if ( $ this -> sourcePath !== null ) { $ this -> sourcePath = rtrim ( Yii :: getAlias ( $ this -> sourcePath ) , '/\\' ) ; } if ( $ this -> basePath !== null ) { $ this -> basePath = rtrim ( Yii :: getAlias ( $ this -> basePath ) , '/\\' ) ; } if ( $ this -> baseUrl !== null ) { $ this -> baseUrl = rtrim ( Yii :: getAlias ( $ this -> baseUrl ) , '/' ) ; } }
1699	public function getFile ( $ strName ) { foreach ( $ this -> arrFiles as $ k => $ v ) { if ( $ strName == $ v [ 'file_name' ] ) { $ this -> intIndex = $ k ; return true ; } } return false ; }
9483	public function toArray ( $ changedOnly = false , $ extraData = null ) { $ vars = get_object_vars ( $ this ) ; $ object = array ( ) ; if ( ! is_array ( $ this -> _changes ) ) { $ this -> _changes = array ( ) ; } if ( is_array ( $ extraData ) ) { $ vars = array_merge ( $ vars , $ extraData ) ; } foreach ( $ vars as $ k => $ v ) { if ( strpos ( $ k , '_' ) !== 0 && $ v !== null && ( ! $ changedOnly || array_key_exists ( $ k , $ this -> _changes ) || array_key_exists ( $ k , $ extraData ) ) ) { if ( is_array ( $ v ) ) { $ subV = array ( ) ; foreach ( $ v as $ sub ) { if ( is_a ( $ sub , 'Dlin\Zendesk\Entity\BaseEntity' ) ) { $ subV [ ] = $ sub -> toArray ( ) ; } else { $ subV [ ] = $ sub ; } } $ object [ $ k ] = $ subV ; } else if ( is_a ( $ v , 'Dlin\Zendesk\Entity\BaseEntity' ) ) { $ object [ $ k ] = $ v -> toArray ( ) ; } else { $ object [ $ k ] = $ v ; } } } return $ object ; }
10030	function updateContact ( $ contact , $ checksum = "" , $ src = null , $ subscriptionPage = null , $ triggerDoi = FALSE , $ doiMailingKey = null , $ ignoreChecksum = false ) { $ queryParameters = array ( 'id' => $ contact -> id , 'checksum' => $ checksum , 'triggerdoi' => ( $ triggerDoi == TRUE ) ? "true" : "false" , 'ignore_checksum' => $ ignoreChecksum ? "true" : "false" ) ; if ( isset ( $ contact -> permission ) ) $ queryParameters [ 'permission' ] = $ contact -> permission -> getCode ( ) ; if ( isset ( $ src ) ) $ queryParameters [ 'src' ] = $ src ; if ( isset ( $ subscriptionPage ) ) $ queryParameters [ 'page_key' ] = $ subscriptionPage ; $ doiMailingKey = trim ( $ doiMailingKey ) ; if ( ! empty ( $ doiMailingKey ) ) $ queryParameters [ 'doimailing' ] = $ doiMailingKey ; $ contactToSend = new Contact ( null , $ contact -> email , null , $ contact -> external_id , null , $ contact -> standard_fields , $ contact -> custom_fields ) ; return $ this -> put ( "contacts/contact" , $ contactToSend -> toXMLString ( ) , $ queryParameters ) ; }
2279	public static function get ( $ strKey ) { if ( isset ( static :: $ arrCache [ $ strKey ] ) ) { return static :: $ arrCache [ $ strKey ] ; } if ( \ in_array ( $ strKey , get_class_methods ( __CLASS__ ) ) ) { static :: $ arrCache [ $ strKey ] = static :: $ strKey ( ) ; } else { $ arrChunks = preg_split ( '/([A-Z][a-z]*)/' , $ strKey , - 1 , PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY ) ; $ strServerKey = strtoupper ( implode ( '_' , $ arrChunks ) ) ; static :: $ arrCache [ $ strKey ] = $ _SERVER [ $ strServerKey ] ; } return static :: $ arrCache [ $ strKey ] ; }
5502	protected function dieOnNoMethod ( $ method , $ task ) { if ( $ this -> is_strict && ! method_exists ( $ this , $ method ) ) { $ errormsg = sprintf ( 'Cannot %s. Method %s() not in class %s.' , $ task , $ method , get_class ( $ this ) ) ; trigger_error ( $ errormsg , E_USER_ERROR ) ; } }
2941	public static function getUnit ( $ unit ) { if ( ! is_array ( static :: $ unitDefinitions ) ) { static :: $ unitDefinitions = [ ] ; static :: initialize ( ) ; } $ key = static :: buildUnitCacheKey ( $ unit ) ; if ( isset ( self :: $ unitCache [ $ key ] ) ) { return self :: $ unitCache [ $ key ] ; } foreach ( static :: $ unitDefinitions as $ unitOfMeasure ) { if ( $ unit === $ unitOfMeasure -> getName ( ) || $ unitOfMeasure -> isAliasOf ( $ unit ) ) { return self :: $ unitCache [ $ key ] = $ unitOfMeasure ; } } throw new Exception \ UnknownUnitOfMeasure ( [ ':unit' => $ unit ] ) ; }
10622	public static function forThe ( MapsObjectsByIdentity $ mapped , string ... $ allowedClasses ) : MapsObjectsByIdentity { foreach ( $ mapped -> objects ( ) as $ object ) { if ( Whitelist :: doesNotHave ( $ object , $ allowedClasses ) ) { $ mapped = $ mapped -> removeThe ( $ object ) ; } } return new Whitelist ( $ allowedClasses , $ mapped ) ; }
3480	public function withLaunchImage ( string $ launchImage ) : Alert { $ cloned = clone $ this ; $ cloned -> launchImage = $ launchImage ; return $ cloned ; }
4680	public function render ( ContainerInterface $ di = null ) { switch ( $ this -> type ) { case "file" : if ( $ di -> has ( "viewRenderFile" ) ) { $ viewRender = $ di -> get ( "viewRenderFile" ) ; } else { $ viewRender = new ViewRenderFile ( $ di ) ; $ viewRender -> setDI ( $ di ) ; } $ viewRender -> render ( $ this -> template , $ this -> templateData ) ; break ; case "callback" : if ( ! is_callable ( $ this -> template ) ) { throw new Exception ( "View is expecting a valid callback, provided callback seems to not be a callable." ) ; } echo call_user_func ( $ this -> template , $ this -> templateData ) ; break ; case "string" : echo $ this -> template ; break ; case "empty" : break ; default : throw new Exception ( "Not a valid template type: '{$this->type}'." ) ; } }
12506	public static function sendQuery ( ConnectionInterface $ connection ) { $ response = DataLayer :: execute ( $ connection ) ; $ connection -> resetSelf ( ) ; return $ response ; }
5146	public function accessInboxFor ( $ address ) { $ inbox = array ( ) ; $ addressPlusDelimiters = '<' . $ address . '>' ; foreach ( $ this -> fetchedEmails as & $ email ) { $ email -> Headers = $ this -> getHeaders ( $ email -> id ) -> headers ; if ( ! isset ( $ email -> Headers -> bcc ) ) { if ( strpos ( $ email -> Headers -> to , $ addressPlusDelimiters ) || strpos ( $ email -> Headers -> cc , $ addressPlusDelimiters ) ) { array_push ( $ inbox , $ email ) ; } } else if ( strpos ( $ email -> Headers -> bcc , $ addressPlusDelimiters ) ) { array_push ( $ inbox , $ email ) ; } } $ this -> setCurrentInbox ( $ inbox ) ; }
10429	private function initSyncStorageForMysql ( ContainerBuilder $ container , array $ config ) { $ doctrineConnection = sprintf ( 'doctrine.dbal.%s_connection' , $ config [ 'connection' ] ) ; $ definition = $ container -> getDefinition ( 'ongr_connections.sync.storage_manager.mysql_storage_manager' ) ; $ definition -> setArguments ( [ new Reference ( $ doctrineConnection , ContainerInterface :: IGNORE_ON_INVALID_REFERENCE ) , $ config [ 'table_name' ] , ] ) ; $ definition -> addMethodCall ( 'setContainer' , [ new Reference ( 'service_container' ) ] ) ; $ container -> getDefinition ( 'ongr_connections.sync.sync_storage' ) -> setArguments ( [ $ definition ] ) ; }
1467	public static function doesResponseHaveBody ( $ request , $ response ) { if ( 'HEAD' === strtoupper ( $ request -> getMethod ( ) ) ) { return false ; } $ status = $ response -> getStatusCode ( ) ; if ( ( 100 <= $ status && 200 > $ status ) || 204 === $ status || 304 === $ status ) { return false ; } if ( self :: hasHeader ( $ response , 'Transfer-Encoding' ) ) { return true ; } ; if ( ! $ contentLength = self :: getHeader ( $ response , 'Content-Length' ) ) { return false ; } return 0 < $ contentLength [ 0 ] ; }
1186	protected function resolve ( $ translator , $ data , $ rules , $ messages , $ customAttributes , $ field ) { $ validateAll = Arr :: get ( $ data , $ field . '_validate_all' , false ) ; $ validationRule = 'bail|' . Validator :: EXTENSION_NAME . ':' . $ validateAll ; $ rules = [ $ field => $ validationRule ] + $ rules ; $ validator = $ this -> createValidator ( $ translator , $ data , $ rules , $ messages , $ customAttributes ) ; return $ validator ; }
8134	public function renderBlock ( $ name , $ context = array ( ) ) { $ context = $ this -> env -> mergeGlobals ( $ context ) ; $ level = ob_get_level ( ) ; ob_start ( ) ; try { $ this -> template -> displayBlock ( $ name , $ context ) ; } catch ( Exception $ e ) { while ( ob_get_level ( ) > $ level ) { ob_end_clean ( ) ; } throw $ e ; } catch ( Throwable $ e ) { while ( ob_get_level ( ) > $ level ) { ob_end_clean ( ) ; } throw $ e ; } return ob_get_clean ( ) ; }
10442	protected function getNewPipe ( ) { $ cmd = 'mysqlbinlog ' . escapeshellarg ( $ this -> logDir . '/' . $ this -> baseName ) . '.[0-9]*' ; if ( $ this -> from !== null ) { if ( $ this -> startType == self :: START_TYPE_DATE ) { $ cmd .= ' --start-datetime=' . escapeshellarg ( $ this -> from -> format ( 'Y-m-d H:i:s' ) ) ; } elseif ( $ this -> startType == self :: START_TYPE_POSITION ) { $ cmd .= ' --start-position=' . escapeshellarg ( $ this -> from ) ; } } $ cmd .= " --base64-output=DECODE-ROWS -v 2>&1 | grep -E '###|#[0-9]|Errcode|ERROR'" ; $ this -> pipe = popen ( $ cmd , 'r' ) ; if ( empty ( $ this -> pipe ) ) { throw new \ RuntimeException ( 'Error while executing mysqlbinlog' ) ; } }
5503	protected function addCall ( $ method , $ args ) { if ( ! isset ( $ this -> call_counts [ $ method ] ) ) { $ this -> call_counts [ $ method ] = 0 ; } $ this -> call_counts [ $ method ] ++ ; }
3340	public function getFilesChunk ( $ options = array ( ) , $ reverse = false ) { $ data = $ this -> __preparedRequest ( 'file_list' , 'GET' , $ options ) ; $ files_raw = ( array ) $ data -> results ; $ resultArr = array ( ) ; foreach ( $ files_raw as $ file_raw ) { $ resultArr [ ] = new File ( $ file_raw -> uuid , $ this , $ file_raw ) ; } return $ this -> __preparePagedParams ( $ data , $ reverse , $ resultArr ) ; }
12157	public function getObjectTypeModel ( ) { if ( ! isset ( $ this -> _objectTypeModel ) && isset ( Yii :: $ app -> collectors [ 'types' ] -> tableRegistry [ $ this -> systemId ] ) ) { $ this -> _objectTypeModel = Yii :: $ app -> collectors [ 'types' ] -> tableRegistry [ $ this -> systemId ] ; } return $ this -> _objectTypeModel ; }
4782	public function removeWidgetConfig ( string $ widgetId , array $ config = [ ] ) { foreach ( $ config as $ id => $ content ) { if ( isset ( $ this -> config [ $ widgetId ] [ $ id ] ) ) { unset ( $ this -> config [ $ widgetId ] [ $ id ] ) ; } } return $ this ; }
11940	public function getUrl ( string $ sCode , array $ aParams = array ( ) ) : string { if ( isset ( $ _SERVER ) && isset ( $ _SERVER [ 'HTTP_HOST' ] ) ) { foreach ( Config :: get ( 'route' ) as $ sHost => $ oHost ) { if ( ( ! strstr ( $ sHost , '/' ) && $ sHost == $ _SERVER [ 'HTTP_HOST' ] ) || ( strstr ( $ sHost , '/' ) && strstr ( $ _SERVER [ 'HTTP_HOST' ] . $ _SERVER [ 'REQUEST_URI' ] , $ sHost ) ) ) { if ( strstr ( $ sHost , '/' ) && strstr ( $ _SERVER [ 'HTTP_HOST' ] . $ _SERVER [ 'REQUEST_URI' ] , $ sHost ) ) { $ this -> _sBaseUri = preg_replace ( '#^[^/]+#' , '' , $ sHost ) ; } if ( isset ( $ oHost -> routes ) ) { foreach ( $ oHost -> routes as $ sKey => $ oRoute ) { if ( $ sKey === $ sCode ) { $ sRoute = $ this -> _sBaseUri . $ oRoute -> route ; if ( isset ( $ oRoute -> constraints ) ) { foreach ( $ oRoute -> constraints as $ sName => $ sType ) { if ( ! isset ( $ aParams [ $ sName ] ) ) { $ aParams [ $ sName ] = '' ; } if ( preg_match ( '#' . $ sType . '#' , $ aParams [ $ sName ] ) ) { if ( $ aParams [ $ sName ] ) { $ sRoute = str_replace ( '[/:' . $ sName . ']' , '/' . $ aParams [ $ sName ] , $ sRoute ) ; } else { $ sRoute = str_replace ( '[/:' . $ sName . ']' , '' , $ sRoute ) ; } $ sRoute = str_replace ( '[:' . $ sName . ']' , $ aParams [ $ sName ] , $ sRoute ) ; continue ; } else if ( isset ( $ oRoute -> defaults_constraints ) && isset ( $ oRoute -> defaults_constraints -> { $ sName } ) && preg_match ( '#' . $ sType . '#' , $ oRoute -> defaults_constraints -> { $ sName } ) ) { continue ; } throw new \ Exception ( 'For the route ' . $ sCode . ' the parameter ' . $ sName . ' is not good!' ) ; } } return $ sRoute ; } } } } } } }
2534	public function setSessionData ( array $ sessionData ) { if ( isset ( $ sessionData [ 'sessionId' ] , $ sessionData [ 'sequenceNumber' ] , $ sessionData [ 'securityToken' ] ) ) { $ this -> sessionData [ 'sessionId' ] = $ sessionData [ 'sessionId' ] ; $ this -> sessionData [ 'sequenceNumber' ] = $ sessionData [ 'sequenceNumber' ] ; $ this -> sessionData [ 'securityToken' ] = $ sessionData [ 'securityToken' ] ; $ this -> isAuthenticated = true ; } else { $ this -> isAuthenticated = false ; } return $ this -> isAuthenticated ; }
10583	public static function dumpResponse ( ResponseInterface $ response ) { $ statusLine = sprintf ( "HTTP/%s %d %s" , $ response -> getProtocolVersion ( ) , $ response -> getStatusCode ( ) , $ response -> getReasonPhrase ( ) ) ; header ( $ statusLine , true , $ response -> getStatusCode ( ) ) ; foreach ( $ response -> getHeaders ( ) as $ name => $ values ) { foreach ( $ values as $ value ) { header ( sprintf ( '%s: %s' , $ name , $ value ) , false ) ; } } $ body = $ response -> getBody ( ) ; while ( ! $ body -> eof ( ) ) { echo $ body -> read ( 1024 ) ; } }
7403	public static function reload ( $ file , $ rangePath = null ) { if ( ! empty ( $ rangePath ) ) { self :: $ rangePath = $ rangePath ; } if ( PHP_SAPI === 'cli' ) { $ cilpath = realpath ( dirname ( dirname ( dirname ( dirname ( __FILE__ ) ) ) ) ) . '/config/' ; $ file = $ cilpath . $ file . '.' . self :: $ format ; } else { $ file = self :: $ rangePath . $ file . '.' . self :: $ format ; } $ name = strtolower ( $ file ) ; $ type = pathinfo ( $ file , PATHINFO_EXTENSION ) ; if ( self :: $ format == $ type ) return self :: set ( include $ file ) ; }
7729	public function quickReplie ( $ text , $ title , $ postback , $ image = null ) { $ this -> setText ( $ text ) ; $ payload = [ 'title' => $ title , 'payload' => $ postback , ] ; if ( ! empty ( $ image ) ) { $ payload [ 'image' ] = $ image ; } $ this -> setQuickReplies ( $ payload ) ; return $ this ; }
1714	public static function getInstance ( ) { if ( static :: $ objInstance !== null ) { return static :: $ objInstance ; } $ objToken = System :: getContainer ( ) -> get ( 'security.token_storage' ) -> getToken ( ) ; if ( $ objToken !== null && is_a ( $ objToken -> getUser ( ) , static :: class ) ) { return $ objToken -> getUser ( ) ; } $ strUser = System :: getContainer ( ) -> get ( 'contao.security.token_checker' ) -> getBackendUsername ( ) ; if ( $ strUser !== null ) { static :: $ objInstance = static :: loadUserByUsername ( $ strUser ) ; return static :: $ objInstance ; } return parent :: getInstance ( ) ; }
2831	public function selectSqlAction ( ) { if ( $ query = $ this -> _initQuery ( ) ) { $ helper = Mage :: helper ( 'sheep_debug' ) ; $ results = $ helper -> runSql ( $ query -> getQuery ( ) , $ query -> getQueryParams ( ) ) ; $ this -> renderTable ( $ results ) ; } }
12909	public function all ( ) { $ _filters = $ this -> filters ; if ( ! $ this -> allowDeleted ) { $ this -> filters = array ( "`" . $ this -> table . "`.deleted = 0" ) ; } else { $ this -> filters = array ( ) ; } $ values = $ this -> values ( ) ; $ this -> filters = $ _filters ; return $ values ; }
10619	public function send ( ) { $ input = Input :: only ( array ( 'name' , 'email' , 'comment' , 'to_email' , 'to_name' , 'security-code' ) ) ; $ input [ 'security-code' ] = $ this -> quickSanitize ( $ input [ 'security-code' ] ) ; if ( strlen ( $ input [ 'security-code' ] ) < 2 ) { $ message = "Please enter the security code again. Thank you!" ; return view ( 'lasallecmscontact::step_two_form' , [ 'input' => $ input , 'message' => $ message , ] ) ; } $ input [ 'name' ] = $ this -> quickSanitize ( $ input [ 'name' ] ) ; $ input [ 'email' ] = $ this -> quickSanitize ( $ input [ 'email' ] ) ; $ input [ 'comment' ] = $ this -> quickSanitize ( $ input [ 'comment' ] ) ; $ to_email = Config :: get ( 'lasallecmscontact.to_email' ) ; $ to_name = Config :: get ( 'lasallecmscontact.to_name' ) ; if ( $ input [ 'to_email' ] != "" ) { $ to_email = $ input [ 'to_email' ] ; $ to_name = $ input [ 'to_name' ] ; } Mail :: send ( 'lasallecmscontact::email' , $ input , function ( $ message ) use ( $ to_email , $ to_name ) { $ message -> from ( Config :: get ( 'lasallecmscontact.from_email' ) , Config :: get ( 'lasallecmscontact.from_name' ) ) ; $ message -> to ( $ to_email , $ to_name ) -> subject ( Config :: get ( 'lasallecmscontact.subject_email' ) ) ; } ) ; return Redirect :: route ( 'contact-processing.thankyou' ) ; }
12674	public function getForeignModelConfig ( $ sourceFile , $ modelName ) { $ config = [ 'class' => Model :: className ( ) ] ; if ( isset ( $ this -> foreignModelsConfig [ $ modelName ] ) ) { $ config = array_merge ( $ config , $ this -> foreignModelsConfig [ $ modelName ] ) ; } $ config [ 'modelName' ] = $ modelName ; $ config [ 'sourceFile' ] = $ sourceFile ; $ config [ 'interface' ] = $ this ; return $ config ; }
3135	public function getItemState ( RunnerServiceContext $ context , $ itemRef ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ serviceService = $ this -> getServiceManager ( ) -> get ( StorageManager :: SERVICE_ID ) ; $ userUri = \ common_session_SessionManager :: getSession ( ) -> getUserUri ( ) ; $ stateId = $ this -> getStateId ( $ context , $ itemRef ) ; $ state = is_null ( $ userUri ) ? null : $ serviceService -> get ( $ userUri , $ stateId ) ; if ( $ state ) { $ state = json_decode ( $ state , true ) ; if ( is_null ( $ state ) ) { throw new \ common_exception_InconsistentData ( 'Unable to decode the state for the item ' . $ itemRef ) ; } } return $ state ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'getItemState' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } }
6389	public function readFacetofaceSession ( $ id ) { $ model = $ this -> readObject ( $ id , 'facetoface_sessions' ) ; $ model -> dates = $ this -> readStoreRecords ( 'facetoface_sessions_dates' , [ 'sessionid' => $ id ] ) ; $ model -> url = $ this -> cfg -> wwwroot . '/mod/facetoface/signup.php?s=' . $ id ; return $ model ; }
8785	public function fullUrlWithQuery ( array $ query ) { $ question = $ this -> getBaseUrl ( ) . $ this -> getPathInfo ( ) == '/' ? '/?' : '?' ; return count ( $ this -> query ( ) ) > 0 ? $ this -> url ( ) . $ question . http_build_query ( array_merge ( $ this -> query ( ) , $ query ) ) : $ this -> fullUrl ( ) . $ question . http_build_query ( $ query ) ; }
9374	protected function dispatcher ( ResponseInterface $ response , $ stack ) { $ dispatcher = new Dispatcher ( $ stack , $ response ) ; if ( class_exists ( 'Zend\Stratigility\MiddlewarePipe' ) ) { $ pipe = new MiddlewarePipe ; $ dispatcher = new StratigilityDispatcher ( $ pipe , $ stack , $ response ) ; } return $ dispatcher ; }
11124	public static function create ( $ notify ) { switch ( true ) { case $ notify === NotifyInterface :: STDOUT : return new NotifyStdout ( ) ; case $ notify === NotifyInterface :: LOGGER : return new NotifyLogger ( PrettyLogger :: create ( ) ) ; case $ notify === NotifyInterface :: BLACKHOLE : return new NotifyBlackhole ( ) ; case $ notify instanceof Output : return new NotifyConsole ( $ notify ) ; case $ notify instanceof LoggerInterface : return new NotifyLogger ( $ notify ) ; default : throw InvalidArgumentException :: forNotSupportedNotifier ( ) ; } }
8602	public function deregisterDestination ( $ request ) { if ( ! ( $ request instanceof MWSSubscriptionsService_Model_DeregisterDestinationInput ) ) { require_once ( dirname ( __FILE__ ) . '/Model/DeregisterDestinationInput.php' ) ; $ request = new MWSSubscriptionsService_Model_DeregisterDestinationInput ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'DeregisterDestination' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/DeregisterDestinationResponse.php' ) ; $ response = MWSSubscriptionsService_Model_DeregisterDestinationResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
10785	public function runQuery ( \ Peyote \ Query $ query ) { return $ this -> run ( $ query -> compile ( ) , $ query -> getParams ( ) ) ; }
10324	private function createCountQueryParameters ( $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , $ mailingIds , $ source ) { $ queryParameters = array ( ) ; if ( isset ( $ fromDate ) ) $ queryParameters [ 'from_date' ] = $ fromDate ; if ( isset ( $ toDate ) ) $ queryParameters [ 'to_date' ] = $ toDate ; if ( isset ( $ source ) ) $ queryParameters [ 'source' ] = $ source ; $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , "ids" , $ contactIds ) ; $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , "emails" , $ contactEmails ) ; $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , "eids" , $ contactExternalIds ) ; if ( isset ( $ mailingIds ) ) { $ queryParameters [ 'mailing_id' ] = array ( ) ; foreach ( $ mailingIds as $ mailingId ) { $ queryParameters [ 'mailing_id' ] [ ] = $ mailingId ; } } return $ queryParameters ; }
7310	public static function solsticeSummer ( $ year ) { $ jd = static :: solsticeJune ( ( int ) $ year , false ) ; return AstroDate :: jd ( $ jd , TimeScale :: TT ( ) ) ; }
5901	public function listGroups ( $ includeDeleted = false , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'includeDeleted' => $ includeDeleted ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/accounts/groups' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new Group ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
11355	public function getValue ( $ name = null ) { if ( $ this -> has ( $ name ) ) { return $ this -> get ( $ name ) -> getValue ( ) ; } return parent :: getValue ( ) ; }
7495	private static function convertString ( $ string , $ outputEncoding ) { if ( $ string instanceof StringBuilder ) { $ inputEncoding = $ string -> getEncoding ( ) ; } else { $ inputEncoding = mb_detect_encoding ( ( string ) $ string ) ; } $ string = ( string ) $ string ; if ( $ inputEncoding != $ outputEncoding ) { $ string = iconv ( $ inputEncoding , $ outputEncoding , $ string ) ; } return $ string ; }
8353	private function shutdown ( $ signal = 9 ) { foreach ( $ this -> dispatcher -> getProcesses ( ) as $ pid => $ process ) { $ this -> logger -> debug ( 'Sending signal to process' , [ 'signal' => $ signal , 'pid' => $ pid , 'jobId' => $ process [ 'id' ] , 'queue' => $ this -> queue -> getName ( ) ] ) ; \ posix_kill ( $ pid , $ signal ) ; if ( $ signal !== 9 ) { if ( $ this -> config [ 'deadline_timeout' ] !== null ) { Loop :: delay ( ( ( int ) $ this -> config [ 'deadline_timeout' ] * 1000 ) , function ( $ watcherId , $ callback ) use ( $ process , $ pid ) { if ( $ process [ 'process' ] -> isRunning ( ) ) { $ this -> logger -> info ( 'Process has exceeded deadline timeout. Killing' , [ 'pid' => $ pid , 'jobId' => $ process [ 'id' ] , 'queue' => $ this -> queue -> getName ( ) ] ) ; \ posix_kill ( $ pid , SIGKILL ) ; } } ) ; } } } }
6774	protected function didDeliveryCountryChanged ( SaleInterface $ sale ) { $ saleCs = $ this -> persistenceHelper -> getChangeSet ( $ sale ) ; $ oldCountry = $ newCountry = null ; $ oldSameAddress = isset ( $ saleCs [ 'sameAddress' ] ) ? $ saleCs [ 'sameAddress' ] [ 0 ] : $ sale -> isSameAddress ( ) ; if ( $ oldSameAddress ) { $ oldAddress = isset ( $ saleCs [ 'invoiceAddress' ] ) ? $ saleCs [ 'invoiceAddress' ] [ 0 ] : $ sale -> getInvoiceAddress ( ) ; } else { $ oldAddress = isset ( $ saleCs [ 'deliveryAddress' ] ) ? $ saleCs [ 'deliveryAddress' ] [ 0 ] : $ sale -> getDeliveryAddress ( ) ; } if ( null !== $ oldAddress ) { $ oldAddressCs = $ this -> persistenceHelper -> getChangeSet ( $ oldAddress ) ; $ oldCountry = isset ( $ oldAddressCs [ 'country' ] ) ? $ oldAddressCs [ 'country' ] [ 0 ] : $ oldAddress -> getCountry ( ) ; } $ newAddress = $ sale -> isSameAddress ( ) ? $ sale -> getInvoiceAddress ( ) : $ sale -> getDeliveryAddress ( ) ; if ( null !== $ newAddress ) { $ newCountry = $ newAddress -> getCountry ( ) ; } if ( $ oldCountry !== $ newCountry ) { return true ; } return false ; }
4256	protected function buildNotInConsole ( ) { if ( ! $ this -> stats [ 'notInConsole' ] ) { return '' ; } $ errors = $ this -> errorHandler -> get ( 'errors' ) ; $ lis = array ( ) ; foreach ( $ errors as $ err ) { if ( \ array_intersect_assoc ( array ( 'category' => 'fatal' , 'inConsole' => true , 'isSuppressed' => true , ) , $ err -> getValues ( ) ) ) { continue ; } $ lis [ ] = '<li>' . $ err [ 'typeStr' ] . ': ' . $ err [ 'file' ] . ' (line ' . $ err [ 'line' ] . '): ' . ( $ err [ 'isHtml' ] ? $ err [ 'message' ] : \ htmlspecialchars ( $ err [ 'message' ] ) ) . '</li>' ; } if ( ! $ lis ) { return '' ; } $ count = \ count ( $ lis ) ; $ header = \ sprintf ( '%s %s captured while not collecting debug log' , $ this -> stats [ 'inConsole' ] || isset ( $ this -> stats [ 'counts' ] [ 'fatal' ] ) ? 'Additionally, there' : 'There' , $ count === 1 ? 'was 1 error' : 'were ' . $ count . ' errors' ) ; $ html = '<h3>' . $ header . '</h3>' . '<ul class="list-unstyled indent">' . "\n" . \ implode ( "\n" , $ lis ) . "\n" . '</ul>' ; return $ html ; }
12683	public function process ( ) { $ orderedTasks = $ this -> _tasks ; usort ( $ orderedTasks , function ( $ a , $ b ) { return $ a -> duration ( ) > $ b -> duration ( ) ? 1 : - 1 ; } ) ; $ this -> _ranking = $ orderedTasks ; $ matrix = [ ] ; foreach ( $ this -> _ranking as $ task1 ) { $ name1 = $ task1 -> name ( ) ; $ matrix [ $ name1 ] = [ ] ; foreach ( $ this -> _ranking as $ task2 ) { $ name2 = $ task2 -> name ( ) ; $ percent = intval ( round ( $ task1 -> duration ( ) / $ task2 -> duration ( ) * 100 ) ) ; $ matrix [ $ name1 ] [ $ name2 ] = $ percent ; } } $ this -> _matrix = $ matrix ; return $ this ; }
1574	public function defaultApi ( $ apiName = null ) { if ( is_null ( $ apiName ) ) { return LaravelJsonApi :: $ defaultApi ; } LaravelJsonApi :: defaultApi ( $ apiName ) ; return $ apiName ; }
880	private function resolveSubset ( $ setName , $ setValue ) { $ rules = $ this -> getSetDefinition ( $ setName ) ; foreach ( $ rules as $ name => $ value ) { if ( '@' === $ name [ 0 ] ) { $ set = $ this -> resolveSubset ( $ name , $ setValue ) ; unset ( $ rules [ $ name ] ) ; $ rules = array_merge ( $ rules , $ set ) ; } elseif ( ! $ setValue ) { $ rules [ $ name ] = false ; } else { $ rules [ $ name ] = $ value ; } } return $ rules ; }
12075	public function childShow ( FilterRequest $ filters , $ id , $ idChild , $ relation ) { $ id = $ this -> getRealId ( $ id ) ; $ idChild = $ this -> getRealId ( $ idChild ) ; $ resource = $ this -> repository -> getChild ( $ id , $ relation , $ idChild , $ filters ) ; if ( ! $ resource ) { } return $ this -> success ( $ resource ) ; }
11087	public static function getUserPlatform ( ) { $ user_agent = $ _SERVER [ 'HTTP_USER_AGENT' ] ; $ user_platform = 'unknown' ; if ( false !== stripos ( $ user_agent , 'linux' ) ) { $ user_platform = 'Linux' ; } elseif ( preg_match ( '/macintosh|mac os x/i' , $ user_agent ) ) { $ user_platform = 'Mac' ; } elseif ( preg_match ( '/windows|win32/i' , $ user_agent ) ) { $ user_platform = 'Windows' ; } return $ user_platform ; }
10283	public static function buildRange ( array $ pRange ) { if ( empty ( $ pRange ) || ! is_array ( $ pRange [ 0 ] ) ) { throw new Exception ( 'Range does not contain any information' ) ; } $ imploded = [ ] ; $ counter = count ( $ pRange ) ; for ( $ i = 0 ; $ i < $ counter ; ++ $ i ) { $ pRange [ $ i ] = implode ( ':' , $ pRange [ $ i ] ) ; } $ imploded = implode ( ',' , $ pRange ) ; return $ imploded ; }
1904	public function execute ( ) { $ arrParams = \ func_get_args ( ) ; if ( ! empty ( $ arrParams ) && \ is_array ( $ arrParams [ 0 ] ) ) { $ arrParams = array_values ( $ arrParams [ 0 ] ) ; } $ this -> replaceWildcards ( $ arrParams ) ; return $ this -> query ( ) ; }
10963	public static function getUri ( ) { $ parts = [ $ uri = self :: getScheme ( ) , '://' ] ; $ authUsername = self :: getAuthUsername ( ) ; $ authPassword = self :: getAuthPassword ( ) ; if ( $ authUsername !== null && $ authPassword !== null ) { $ parts [ ] = $ authUsername . ':' . $ authPassword . '@' ; } $ parts [ ] = self :: getHost ( ) ; $ port = self :: getPort ( ) ; if ( $ port != self :: getStandardPort ( self :: getScheme ( ) ) ) { $ parts [ ] = ':' . $ port ; } $ path = self :: getPath ( ) ; if ( $ path !== null && $ path != '' ) { $ parts [ ] = '/' . $ path ; } $ query = Input :: getQuery ( ) ; if ( is_array ( $ query ) && count ( $ query ) > 0 ) { $ queryString = [ ] ; foreach ( $ query as $ key => $ value ) { $ queryKeyValue = $ key . '=' ; if ( $ value !== null ) { if ( is_string ( $ value ) ) { $ value = urlencode ( $ value ) ; } $ queryKeyValue .= $ value ; } $ queryString [ ] = $ queryKeyValue ; } if ( count ( $ queryString ) > 0 ) { $ parts [ ] = '?' . implode ( '&' , $ queryString ) ; } } return implode ( '' , $ parts ) ; }
12934	public function move ( $ baseDir , array $ options , $ username ) { $ this -> resolveMoveOptions ( $ options ) ; if ( array_key_exists ( "targetSlot" , $ options ) ) { $ options [ "slot" ] = $ options [ "targetSlot" ] ; $ block = $ this -> moveBlockToAnotherSlot ( $ baseDir , $ options , $ username ) ; return $ block ; } $ options [ "slot" ] = $ options [ "sourceSlot" ] ; $ block = $ this -> moveBlockToSameSlot ( $ baseDir , $ options , $ username ) ; return $ block ; }
9964	public function getComment ( $ pCellCoordinate ) { $ pCellCoordinate = strtoupper ( $ pCellCoordinate ) ; if ( Coordinate :: coordinateIsRange ( $ pCellCoordinate ) ) { throw new Exception ( 'Cell coordinate string can not be a range of cells.' ) ; } elseif ( strpos ( $ pCellCoordinate , '$' ) !== false ) { throw new Exception ( 'Cell coordinate string must not be absolute.' ) ; } elseif ( $ pCellCoordinate == '' ) { throw new Exception ( 'Cell coordinate can not be zero-length string.' ) ; } if ( isset ( $ this -> comments [ $ pCellCoordinate ] ) ) { return $ this -> comments [ $ pCellCoordinate ] ; } $ newComment = new Comment ( ) ; $ this -> comments [ $ pCellCoordinate ] = $ newComment ; return $ newComment ; }
5872	public static function getTransformation ( $ orientation ) { $ transformation = '' ; if ( ( isset ( $ GLOBALS [ 'TYPO3_CONF_VARS' ] [ 'GFX' ] [ 'processor' ] ) && $ GLOBALS [ 'TYPO3_CONF_VARS' ] [ 'GFX' ] [ 'processor' ] === 'ImageMagick' ) || ( isset ( $ GLOBALS [ 'TYPO3_CONF_VARS' ] [ 'GFX' ] [ 'im_version_5' ] ) && $ GLOBALS [ 'TYPO3_CONF_VARS' ] [ 'GFX' ] [ 'im_version_5' ] !== 'gm' ) ) { if ( $ orientation >= 2 && $ orientation <= 8 ) { $ transformation = '-auto-orient' ; } } else { switch ( $ orientation ) { case 2 : $ transformation = '-flip horizontal' ; break ; case 3 : $ transformation = '-rotate 180' ; break ; case 4 : $ transformation = '-flip vertical' ; break ; case 5 : $ transformation = '-transpose' ; break ; case 6 : $ transformation = '-rotate 90' ; break ; case 7 : $ transformation = '-transverse' ; break ; case 8 : $ transformation = '-rotate 270' ; break ; } } return $ transformation ; }
7671	function TbsInitArchive ( ) { $ TBS = & $ this -> TBS ; $ TBS -> OtbsCurrFile = false ; $ this -> TbsStoreLst = array ( ) ; $ this -> TbsCurrIdx = false ; $ this -> TbsNoField = array ( ) ; $ this -> IdxToCheck = array ( ) ; $ this -> PrevVals = array ( ) ; $ this -> ExtEquiv = false ; $ this -> ExtType = false ; $ this -> OtbsSheetSlidesDelete = array ( ) ; $ this -> OtbsSheetSlidesVisible = array ( ) ; $ this -> OpenDocCharts = false ; $ this -> OpenDocManif = false ; $ this -> OpenDoc_SheetSlides = false ; $ this -> OpenDoc_Styles = false ; $ this -> OpenXmlRid = false ; $ this -> OpenXmlCTypes = false ; $ this -> OpenXmlCharts = false ; $ this -> OpenXmlSharedStr = false ; $ this -> OpenXmlSlideLst = false ; $ this -> OpenXmlSlideMasterLst = false ; $ this -> MsExcel_Sheets = false ; $ this -> MsWord_HeaderFooter = false ; $ this -> Ext_PrepareInfo ( ) ; }
7036	protected function dropMigrationTable ( ) { try { return Db :: query ( "drop table if exists migrations" , [ ] , $ this -> dbName , false ) ; } catch ( PDOException $ e ) { error_log ( $ e -> getMessage ( ) ) ; return false ; } }
2576	protected function mergeOptions ( $ existingOptions , $ newOptions ) { if ( ! empty ( $ newOptions ) ) { $ existingOptions = array_merge ( $ existingOptions , $ newOptions ) ; } return $ existingOptions ; }
2316	protected function prepareResizeConfig ( ) { $ resizeConfig = new ResizeConfiguration ( ) ; $ resizeConfig -> setWidth ( $ this -> targetWidth ) ; $ resizeConfig -> setHeight ( $ this -> targetHeight ) ; $ resizeConfig -> setZoomLevel ( $ this -> zoomLevel ) ; if ( substr_count ( $ this -> resizeMode , '_' ) === 1 ) { $ resizeConfig -> setMode ( ResizeConfiguration :: MODE_CROP ) ; $ resizeConfig -> setZoomLevel ( 0 ) ; } else { try { $ resizeConfig -> setMode ( $ this -> resizeMode ) ; } catch ( \ InvalidArgumentException $ exception ) { $ resizeConfig -> setMode ( ResizeConfiguration :: MODE_CROP ) ; } } return $ resizeConfig ; }
5608	public function after ( $ method ) { $ this -> invoker -> after ( $ method ) ; $ output = ob_get_contents ( ) ; ob_end_clean ( ) ; if ( $ output !== '' ) { $ result = $ this -> listener -> write ( '{status:"info",message:"' . EclipseReporter :: escapeVal ( $ output ) . '"}' ) ; } }
12278	public function moveUser ( $ openId , $ groupId ) { $ params = [ 'openid' => $ openId , 'to_groupid' => $ groupId , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_MEMBER_UPDATE , $ params ] ) ; }
359	function checkUploadMaxFileSize ( $ min = null , $ max = null ) { $ postMaxSize = ini_get ( 'post_max_size' ) ; $ uploadMaxFileSize = ini_get ( 'upload_max_filesize' ) ; if ( $ min !== null ) { $ minCheckResult = $ this -> compareByteSize ( $ postMaxSize , $ min , '>=' ) && $ this -> compareByteSize ( $ uploadMaxFileSize , $ min , '>=' ) ; } else { $ minCheckResult = true ; } if ( $ max !== null ) { $ maxCheckResult = $ this -> compareByteSize ( $ postMaxSize , $ max , '<=' ) && $ this -> compareByteSize ( $ uploadMaxFileSize , $ max , '<=' ) ; } else { $ maxCheckResult = true ; } return ( $ minCheckResult && $ maxCheckResult ) ; }
8363	public static function translate ( $ key , array $ args = array ( ) ) { if ( self :: $ isInit === false ) { throw new BadUse ( 'locale doesn\'t seem to have been initialized' ) ; } $ oldKey = $ key ; $ section = self :: $ translations ; while ( isset ( $ section [ $ key ] ) === false && ( $ pos = strpos ( $ key , '.' ) ) !== false ) { if ( ! is_int ( $ pos ) ) { break ; } $ subSection = substr ( $ key , 0 , $ pos ) ; if ( isset ( $ section [ $ subSection ] ) === false ) { break ; } $ section = $ section [ $ subSection ] ; $ key = substr ( $ key , $ pos + 1 ) ; } if ( isset ( $ section [ $ key ] ) === false ) { Logger :: get ( ) -> error ( 'can\'t find translation for key "' . $ oldKey . '"' ) ; return '(null)' ; } return $ section [ $ key ] ; }
6590	public function put ( $ url , $ data = null , $ len = null , $ method = "PUT" ) { return $ this -> request ( [ CURLOPT_PUT => true , CURLOPT_CUSTOMREQUEST => $ method ? : "PUT" , CURLOPT_URL => "$url" , CURLOPT_INFILE => $ data , CURLOPT_INFILESIZE => $ len , ] ) ; }
9030	public function exception ( Request $ request ) { $ ex = $ request -> getException ( ) ; $ this -> response -> setCode ( 500 ) ; printf ( "<h2>%s</h2>" , HttpStatus :: getStatus ( 500 ) ) ; while ( $ ex != null ) { printf ( "<h3>%s</h3><pre>%s</pre>" , $ ex -> getMessage ( ) , $ ex -> getTraceAsString ( ) ) ; $ ex = $ ex -> getPrevious ( ) ; } }
11959	public function splice ( $ offset = 0 , $ length = 0 , $ replacement = [ ] ) { return new static ( array_splice ( $ this -> elements , $ offset , $ length , $ replacement ) ) ; }
4229	protected function errorHash ( $ errorValues ) { $ errMsg = $ errorValues [ 'message' ] ; $ errMsg = \ preg_replace ( '/(\(.*?)\d+(.*?\))/' , '\1x\2' , $ errMsg ) ; $ errMsg = \ preg_replace ( '/\b([a-z]+\d+)+\b/' , 'xxx' , $ errMsg ) ; $ errMsg = \ preg_replace ( '/\b[\d.-]{4,}\b/' , 'xxx' , $ errMsg ) ; $ errMsg = \ preg_replace ( '/\s*##.+$/' , '' , $ errMsg ) ; $ hash = \ md5 ( $ errorValues [ 'file' ] . $ errorValues [ 'line' ] . $ errorValues [ 'type' ] . $ errMsg ) ; return $ hash ; }
5665	private function innerHtml ( $ node ) { $ raw = '' ; if ( $ node -> hasChildren ( ) ) { foreach ( $ node -> child as $ child ) { $ raw .= $ child -> value ; } } return $ this -> stripGuards ( $ raw ) ; }
12309	public function resetPasswordAction ( ) { if ( $ this -> cmsAuthentication ( ) -> hasIdentity ( ) ) { return $ this -> redirect ( ) -> toRoute ( $ this -> getOptions ( ) -> getDefaultUserRoute ( ) ) ; } if ( $ token = $ this -> params ( ) -> fromRoute ( 'token' ) ) { $ identity = $ this -> getUserService ( ) -> confirmPasswordReset ( $ token ) ; if ( $ identity instanceof ResponseInterface ) { return $ identity ; } elseif ( $ identity ) { $ viewModel = new ViewModel ( compact ( 'identity' ) ) ; $ viewModel -> setTemplate ( 'cms-user/authentication/reset-password-success' ) ; return $ viewModel ; } return $ this -> redirect ( ) -> toRoute ( ) ; } $ url = $ this -> url ( ) -> fromRoute ( ) ; $ prg = $ this -> prg ( $ url , true ) ; if ( $ prg instanceof ResponseInterface ) { return $ prg ; } $ post = $ prg ; $ form = $ this -> getUserService ( ) -> getResetPasswordForm ( ) ; $ form -> setAttribute ( 'action' , $ url ) ; if ( $ post && $ form -> setData ( $ post ) -> isValid ( ) ) { $ identity = $ this -> getUserService ( ) -> resetPassword ( $ form -> get ( 'identity' ) -> getValue ( ) ) ; if ( $ identity instanceof ResponseInterface ) { return $ identity ; } elseif ( $ identity ) { $ viewModel = new ViewModel ( compact ( 'identity' ) ) ; $ viewModel -> setTemplate ( 'cms-user/authentication/reset-password-warning' ) ; return $ viewModel ; } } return new ViewModel ( compact ( 'form' ) ) ; }
1380	protected function validateToOne ( $ value , ? string $ field = null ) : bool { if ( is_null ( $ value ) ) { return true ; } $ dataPath = $ field ? "/data/relationships/{$field}" : "/" ; $ identifierPath = $ field ? "/data/relationships/{$field}" : "/data" ; if ( ! $ this -> validateIdentifier ( $ value , $ dataPath ) ) { return false ; } if ( ! $ this -> store -> exists ( new ResourceIdentifier ( $ value ) ) ) { $ this -> resourceDoesNotExist ( $ identifierPath ) ; return false ; } return true ; }
720	public function binary ( $ length = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_BINARY , $ length ) ; }
891	public function setTypes ( array $ types ) { $ pattern = '/' . preg_quote ( $ this -> getTypesContent ( ) , '/' ) . '/' ; $ this -> lines [ 0 ] -> setContent ( Preg :: replace ( $ pattern , implode ( '|' , $ types ) , $ this -> lines [ 0 ] -> getContent ( ) , 1 ) ) ; $ this -> clearCache ( ) ; }
8186	public function displayBlock ( $ name , array $ context , array $ blocks = array ( ) , $ useBlocks = true ) { $ name = ( string ) $ name ; if ( $ useBlocks && isset ( $ blocks [ $ name ] ) ) { $ template = $ blocks [ $ name ] [ 0 ] ; $ block = $ blocks [ $ name ] [ 1 ] ; } elseif ( isset ( $ this -> blocks [ $ name ] ) ) { $ template = $ this -> blocks [ $ name ] [ 0 ] ; $ block = $ this -> blocks [ $ name ] [ 1 ] ; } else { $ template = null ; $ block = null ; } if ( null !== $ template && ! $ template instanceof self ) { throw new LogicException ( 'A block must be a method on a Twig_Template instance.' ) ; } if ( null !== $ template ) { try { $ template -> $ block ( $ context , $ blocks ) ; } catch ( Twig_Error $ e ) { if ( ! $ e -> getSourceContext ( ) ) { $ e -> setSourceContext ( $ template -> getSourceContext ( ) ) ; } if ( false === $ e -> getTemplateLine ( ) ) { $ e -> setTemplateLine ( - 1 ) ; $ e -> guess ( ) ; } throw $ e ; } catch ( Exception $ e ) { throw new Twig_Error_Runtime ( sprintf ( 'An exception has been thrown during the rendering of a template ("%s").' , $ e -> getMessage ( ) ) , - 1 , $ template -> getSourceContext ( ) , $ e ) ; } } elseif ( false !== $ parent = $ this -> getParent ( $ context ) ) { $ parent -> displayBlock ( $ name , $ context , array_merge ( $ this -> blocks , $ blocks ) , false ) ; } else { @ trigger_error ( sprintf ( 'Silent display of undefined block "%s" in template "%s" is deprecated since version 1.29 and will throw an exception in 2.0. Use the "block(\'%s\') is defined" expression to test for block existence.' , $ name , $ this -> getTemplateName ( ) , $ name ) , E_USER_DEPRECATED ) ; } }
8964	private static function matchesArrayCriteria ( $ key , $ object , array $ criteria ) { $ criteria = self :: extractArrayCriteria ( $ key , $ criteria ) ; if ( count ( $ criteria ) === 0 ) { return true ; } $ getter = sprintf ( 'get%s' , ucfirst ( $ key ) ) ; if ( ! method_exists ( $ object , $ getter ) ) { throw new RuntimeException ( sprintf ( 'Object instance of "%s" does not have required getter "%s" to be used for filtering.' , get_class ( $ object ) , $ getter ) ) ; } return in_array ( $ object -> { $ getter } ( ) , $ criteria , true ) ; }
2021	public static function findPublishedByPid ( $ intPid , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = array ( "$t.pid=?" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } return static :: findBy ( $ arrColumns , $ intPid , $ arrOptions ) ; }
542	protected function serializeModels ( array $ models ) { list ( $ fields , $ expand ) = $ this -> getRequestedFields ( ) ; foreach ( $ models as $ i => $ model ) { if ( $ model instanceof Arrayable ) { $ models [ $ i ] = $ model -> toArray ( $ fields , $ expand ) ; } elseif ( is_array ( $ model ) ) { $ models [ $ i ] = ArrayHelper :: toArray ( $ model ) ; } } return $ models ; }
9028	protected function randomizeSamples ( $ referencePrefix , array $ samples , $ limit = 1 ) { $ sample = array_rand ( $ samples , $ limit ) ; if ( 1 === $ limit ) { $ referenceName = sprintf ( '%s_%s' , $ referencePrefix , $ samples [ $ sample ] ) ; return $ this -> getReference ( $ referenceName ) ; } else { $ collection = new ArrayCollection ( ) ; foreach ( $ sample as $ index ) { $ referenceName = sprintf ( '%s_%s' , $ referencePrefix , $ samples [ $ index ] ) ; $ collection -> add ( $ this -> getReference ( $ referenceName ) ) ; } return $ collection ; } }
8397	public function getDefinition ( ) : array { if ( $ this -> definition == null ) { $ data = Mapping :: get ( $ this -> mapping ) ; $ this -> definition = Config :: get ( $ data [ 'config' ] [ 'schema' ] ) ; } return $ this -> definition ; }
4258	public function addSubscriberInterface ( SubscriberInterface $ interface ) { $ subscribers = $ this -> getInterfaceSubscribers ( $ interface ) ; foreach ( $ subscribers as $ row ) { $ this -> subscribe ( $ row [ 0 ] , $ row [ 1 ] , $ row [ 2 ] ) ; } return $ subscribers ; }
1918	public static function findByIds ( $ arrIds , array $ arrOptions = array ( ) ) { if ( empty ( $ arrIds ) || ! \ is_array ( $ arrIds ) ) { return null ; } $ t = static :: $ strTable ; return static :: findBy ( array ( "$t.id IN(" . implode ( ',' , array_map ( '\intval' , $ arrIds ) ) . ")" ) , null , $ arrOptions ) ; }
11669	protected function createAggregateConnection ( $ parameters , $ option ) { $ options = $ this -> getOptions ( ) ; $ initializer = $ options -> $ option ; $ connection = $ initializer ( $ parameters ) ; if ( $ option !== 'aggregate' && ! $ connection instanceof SentinelReplication ) { $ options -> connections -> aggregate ( $ connection , $ parameters ) ; } return $ connection ; }
5818	public function updateTagging ( $ fusionID ) { $ configuration = Config :: inst ( ) ; $ classes = ClassInfo :: subclassesFor ( 'DataObject' ) ; unset ( $ classes [ 'DataObject' ] ) ; foreach ( $ classes as $ class ) { $ extensions = $ configuration -> get ( $ class , 'extensions' , Config :: UNINHERITED ) ; if ( is_array ( $ extensions ) && in_array ( 'TaggingExtension' , $ extensions ) ) { $ mode = Versioned :: get_reading_mode ( ) ; Versioned :: reading_stage ( 'Stage' ) ; $ objects = $ class :: get ( ) -> filter ( 'FusionTags.ID' , $ fusionID ) ; if ( $ class :: has_extension ( $ class , 'Versioned' ) ) { foreach ( $ objects as $ object ) { $ object -> writeWithoutVersion ( ) ; } Versioned :: reading_stage ( 'Live' ) ; $ objects = $ class :: get ( ) -> filter ( 'FusionTags.ID' , $ fusionID ) ; foreach ( $ objects as $ object ) { $ object -> writeWithoutVersion ( ) ; } } else { foreach ( $ objects as $ object ) { $ object -> write ( ) ; } } Versioned :: set_reading_mode ( $ mode ) ; } } }
3711	protected function generateElement ( $ table , $ content , $ replace , $ elementId ) { $ sql = sprintf ( 'SELECT * FROM %s WHERE id=? AND type="metamodels_frontendclearall"' , $ table ) ; $ statement = $ this -> connection -> prepare ( $ sql ) ; $ statement -> bindValue ( 1 , $ elementId ) ; $ statement -> execute ( ) ; $ objDbResult = $ statement -> fetch ( \ PDO :: FETCH_OBJ ) ; if ( $ objDbResult === false ) { return str_replace ( $ replace , '' , $ content ) ; } if ( $ table == 'tl_module' ) { $ objElement = new ModuleFilterClearAll ( $ objDbResult ) ; } elseif ( $ table == 'tl_content' ) { $ objElement = new ContentElementFilterClearAll ( $ objDbResult ) ; } else { return str_replace ( $ replace , '' , $ content ) ; } return str_replace ( $ replace , $ objElement -> generateReal ( ) , $ content ) ; }
10897	public function setScheme ( $ scheme ) { foreach ( $ this -> uris as $ name => $ uri ) { $ this -> add ( $ name , $ uri -> withScheme ( $ scheme ) ) ; } }
10518	protected function getProductPhoto ( MediaInterface $ media , ProductInterface $ modelData , $ values ) { $ mainPhoto = $ this -> isMainPhoto ( $ media , $ values [ 'main' ] ) ; $ productPhoto = new ProductPhoto ( ) ; $ productPhoto -> setPhoto ( $ media ) ; $ productPhoto -> setMainPhoto ( $ mainPhoto ) ; $ productPhoto -> setProduct ( $ modelData ) ; if ( $ mainPhoto ) { $ modelData -> setPhoto ( $ media ) ; } return $ productPhoto ; }
1469	public static function httpErrorStatus ( $ errors , int $ default = SymfonyResponse :: HTTP_BAD_REQUEST ) : int { if ( $ errors instanceof ErrorInterface ) { $ errors = [ $ errors ] ; } $ statuses = collect ( $ errors ) -> reject ( function ( ErrorInterface $ error ) { return is_null ( $ error -> getStatus ( ) ) ; } ) -> map ( function ( ErrorInterface $ error ) { return ( int ) $ error -> getStatus ( ) ; } ) -> unique ( ) ; if ( 2 > count ( $ statuses ) ) { return $ statuses -> first ( ) ? : $ default ; } $ only4xx = $ statuses -> every ( function ( int $ status ) { return 400 <= $ status && 499 >= $ status ; } ) ; return $ only4xx ? SymfonyResponse :: HTTP_BAD_REQUEST : SymfonyResponse :: HTTP_INTERNAL_SERVER_ERROR ; }
10212	function toCsvString ( ) { $ standard_fields = "{" ; if ( isset ( $ this -> standard_fields ) ) { foreach ( $ this -> standard_fields as $ index => $ value ) { $ standard_fields .= $ index . "=" . $ value . "," ; } $ standard_fields = rtrim ( $ standard_fields , ',' ) ; } $ standard_fields .= "}" ; $ customfields = "{" ; if ( isset ( $ this -> custom_fields ) ) { foreach ( $ this -> custom_fields as $ index => $ value ) { $ customfields .= $ index . "=" . $ value . "," ; } $ customfields = rtrim ( $ customfields , ',' ) ; } $ customfields .= "}" ; $ permission = "" ; if ( isset ( $ this -> permission ) ) { $ permission = $ this -> permission -> getCode ( ) ; } return $ this -> id . ";" . $ this -> email . ";" . $ permission . ";" . $ this -> external_id . ";" . ( ( $ this -> anonymous == true ) ? "true" : "false" ) . ";" . $ this -> created . ";" . $ this -> updated . ";\"" . $ standard_fields . "\"" . ";\"" . $ customfields . "\"" ; }
3895	protected function getMetaModel ( $ metaModelId ) { if ( null === $ this -> factory ) { throw new \ RuntimeException ( 'No factory set.' ) ; } $ metaModelName = $ this -> factory -> translateIdToMetaModelName ( $ metaModelId ) ; $ metaModel = $ this -> factory -> getMetaModel ( $ metaModelName ) ; return $ metaModel ; }
11557	protected function detectNamespace ( $ settings ) { foreach ( $ this -> options -> getNamespaces ( ) as $ namespaceOptions ) { $ namespaceEntityClass = $ namespaceOptions -> getEntityClass ( ) ; if ( $ settings instanceof $ namespaceEntityClass ) { return $ namespaceOptions -> getName ( ) ; } } throw new Exception \ InvalidArgumentException ( 'Unknown Settings namespace' ) ; }
6478	protected function encodingIsSupported ( string $ encoding ) : bool { $ lowercaseSupportedEncodings = array_map ( 'strtolower' , $ this -> getSupportedEncodings ( ) ) ; $ lowercaseEncoding = strtolower ( $ encoding ) ; return in_array ( $ lowercaseEncoding , $ lowercaseSupportedEncodings , true ) ; }
12695	static function getVendorDir ( $ vendorPrefix = 'vendor' ) { if ( is_dir ( __DIR__ . '/../../../composer' ) && is_file ( __DIR__ . '/../../../autoload.php' ) ) { return realpath ( __DIR__ . '/../../..' ) ; } if ( is_dir ( __DIR__ . "/../$vendorPrefix/composer" ) && is_file ( __DIR__ . "/../$vendorPrefix/autoload.php" ) ) { return realpath ( __DIR__ . "/../$vendorPrefix" ) ; } return false ; }
4755	public function stopProfiling ( ) { if ( ! $ this -> profiling ) { return false ; } $ this -> profiling = false ; $ xhprof_data = xhprof_disable ( ) ; if ( is_array ( $ xhprof_data ) ) { $ this -> parser -> parse ( $ xhprof_data ) ; } foreach ( $ this -> probes as $ probe ) { $ name = $ probe -> getName ( ) ; if ( $ probe -> isTimingProbe ( ) ) { $ this -> timers [ $ name ] = $ probe -> getTime ( ) ; } if ( $ probe -> isCallsProbe ( ) ) { $ this -> counters [ $ name ] = $ probe -> getCount ( ) ; } } return true ; }
9821	public function shiftColumn ( $ fromColumn , $ toColumn ) { $ fromColumn = strtoupper ( $ fromColumn ) ; $ toColumn = strtoupper ( $ toColumn ) ; if ( ( $ fromColumn !== null ) && ( isset ( $ this -> columns [ $ fromColumn ] ) ) && ( $ toColumn !== null ) ) { $ this -> columns [ $ fromColumn ] -> setParent ( ) ; $ this -> columns [ $ fromColumn ] -> setColumnIndex ( $ toColumn ) ; $ this -> columns [ $ toColumn ] = $ this -> columns [ $ fromColumn ] ; $ this -> columns [ $ toColumn ] -> setParent ( $ this ) ; unset ( $ this -> columns [ $ fromColumn ] ) ; ksort ( $ this -> columns ) ; } return $ this ; }
11992	public function toArray ( ) { $ urls = [ ] ; $ actions = [ ] ; if ( count ( $ this -> items ) < 1 ) { return parent :: toArray ( ) ; } $ entity = $ this -> items [ 0 ] ; if ( is_array ( $ entity -> load ) ) { foreach ( $ entity -> load as $ k => $ load ) { $ this -> load ( $ load ) ; } } $ data = parent :: toArray ( ) ; $ actions = $ entity -> getActions ( ) ; if ( count ( $ actions ) > 0 ) { foreach ( $ data as $ k => $ resource ) { if ( count ( $ resource ) < 2 ) { continue ; } $ data [ $ k ] += [ 'actions' => $ actions ] ; } } $ data = $ this -> normalizeArray ( $ data ) ; return $ data ; }
8893	protected function registerFactory ( $ key , callable $ callable , $ shared = true ) { $ this -> sm -> setFactory ( $ key , new CallbackWrapper ( $ this , $ callable ) ) ; $ this -> sm -> setShared ( $ key , $ shared ) ; }
10237	public static function getInstance ( Spreadsheet $ spreadsheet = null ) { if ( $ spreadsheet !== null ) { $ instance = $ spreadsheet -> getCalculationEngine ( ) ; if ( isset ( $ instance ) ) { return $ instance ; } } if ( ! isset ( self :: $ instance ) || ( self :: $ instance === null ) ) { self :: $ instance = new self ( ) ; } return self :: $ instance ; }
6573	protected static function examine ( $ part , array & $ array , $ path_relative , $ allow_escape = false ) { if ( $ part === '.' ) { return ; } if ( $ part !== '..' ) { $ array [ ] = $ part ; return ; } $ last = end ( $ array ) ; if ( $ last === '..' ) { $ array [ ] = $ part ; return ; } if ( $ last !== false ) { array_pop ( $ array ) ; return ; } if ( ! $ path_relative ) { return ; } if ( ! $ allow_escape ) throw new \ UnexpectedValueException ( 'Attempt to traverse outside the root directory.' ) ; $ array [ ] = $ part ; }
10936	protected function authenticateUser ( CustomerInterface $ user , Response $ response ) { try { $ this -> get ( 'fos_user.security.login_manager' ) -> loginUser ( $ this -> getParameter ( 'fos_user.firewall_name' ) , $ user , $ response ) ; } catch ( AccountStatusException $ ex ) { } }
10697	public function send ( ResponseInterface $ response ) : ResponseInterface { $ response -> getBody ( ) -> write ( json_encode ( $ this -> toArray ( ) ) ) ; return $ response -> withHeader ( 'Content-Type' , self :: MIME_TYPE_JSON ) ; }
4792	function select ( $ columns ) { $ this -> __destruct ( ) ; if ( $ columns != "" ) { foreach ( func_get_args ( ) as $ columns ) { $ this -> select [ ] = $ columns ; } } else { $ this -> select = array ( ) ; } return $ this ; }
4927	public function setListeners ( array $ specs ) { foreach ( $ specs as $ spec ) { if ( ! isset ( $ spec [ 'event' ] ) || ! isset ( $ spec [ 'service' ] ) ) { throw new \ DomainException ( 'Listener specification must be an array with the keys "event" and "service".' ) ; } $ method = isset ( $ spec [ 'method' ] ) ? $ spec [ 'method' ] : null ; $ priority = isset ( $ spec [ 'priority' ] ) ? $ spec [ 'priority' ] : 0 ; $ this -> setListener ( $ spec [ 'event' ] , $ spec [ 'service' ] , $ method , $ priority ) ; } return $ this ; }
888	private function isStrictOrNullableReturnTypeFunction ( Tokens $ tokens , $ returnIndex ) { $ functionIndex = $ returnIndex ; do { $ functionIndex = $ tokens -> getPrevTokenOfKind ( $ functionIndex , [ [ T_FUNCTION ] ] ) ; if ( null === $ functionIndex ) { return false ; } $ openingCurlyBraceIndex = $ tokens -> getNextTokenOfKind ( $ functionIndex , [ '{' ] ) ; $ closingCurlyBraceIndex = $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_CURLY_BRACE , $ openingCurlyBraceIndex ) ; } while ( $ closingCurlyBraceIndex < $ returnIndex ) ; $ possibleVoidIndex = $ tokens -> getPrevMeaningfulToken ( $ openingCurlyBraceIndex ) ; $ isStrictReturnType = $ tokens [ $ possibleVoidIndex ] -> isGivenKind ( T_STRING ) && 'void' !== $ tokens [ $ possibleVoidIndex ] -> getContent ( ) ; $ nullableTypeIndex = $ tokens -> getNextTokenOfKind ( $ functionIndex , [ [ CT :: T_NULLABLE_TYPE ] ] ) ; $ isNullableReturnType = null !== $ nullableTypeIndex && $ nullableTypeIndex < $ openingCurlyBraceIndex ; return $ isStrictReturnType || $ isNullableReturnType ; }
6464	public function isJson ( HttpHeaders $ headers ) : bool { $ contentType = null ; $ headers -> tryGetFirst ( 'Content-Type' , $ contentType ) ; return preg_match ( "/application\/json/i" , $ contentType ) === 1 ; }
10970	public static function getRequest ( $ name , $ defaultValue = null ) { if ( isset ( $ _REQUEST [ $ name ] ) ) { return $ _REQUEST [ $ name ] ; } return $ defaultValue ; }
2890	public function onModelLoad ( Varien_Event_Observer $ observer ) { if ( ! $ this -> canCollect ( ) ) { return ; } $ model = $ observer -> getData ( 'object' ) ; $ this -> getRequestInfo ( ) -> addModel ( $ model ) ; }
9837	public function createSymmetricAuthenticatedJsonRequest ( string $ method , string $ uri , array $ arrayToJsonify , SharedAuthenticationKey $ key , array $ headers = [ ] ) : RequestInterface { if ( empty ( $ headers [ 'Content-Type' ] ) ) { $ headers [ 'Content-Type' ] = 'application/json' ; } $ body = \ json_encode ( $ arrayToJsonify , JSON_PRETTY_PRINT ) ; if ( ! \ is_string ( $ body ) ) { throw new InvalidMessageException ( 'Cannot JSON-encode this message.' ) ; } return $ this -> createSymmetricAuthenticatedRequest ( $ method , $ uri , $ body , $ key , $ headers ) ; }
423	public function hiddenInput ( $ options = [ ] ) { $ options = array_merge ( $ this -> inputOptions , $ options ) ; $ this -> adjustLabelFor ( $ options ) ; $ this -> parts [ '{input}' ] = Html :: activeHiddenInput ( $ this -> model , $ this -> attribute , $ options ) ; return $ this ; }
7187	public function getAssignmentById ( $ id ) { foreach ( $ this -> unit -> getStockAssignments ( ) as & $ assignment ) { if ( $ assignment -> getId ( ) === $ id ) { return $ assignment ; } } return null ; }
9239	private function isInheritanceRelationship ( ForeignKeyConstraint $ fk ) { if ( ! $ fk -> getLocalTable ( ) -> hasPrimaryKey ( ) ) { return false ; } $ fkColumnNames = $ fk -> getLocalColumns ( ) ; $ pkColumnNames = $ fk -> getLocalTable ( ) -> getPrimaryKeyColumns ( ) ; sort ( $ fkColumnNames ) ; sort ( $ pkColumnNames ) ; return $ fkColumnNames == $ pkColumnNames ; }
3888	public function getAttributeNames ( \ DC_Table $ objDc ) { $ attributeNames = [ 'sorting' => $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'metamodels_sorting' ] , 'random' => $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'random' ] , 'id' => $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'id' ] [ 0 ] ] ; $ metaModelName = $ this -> factory -> translateIdToMetaModelName ( $ objDc -> activeRecord -> metamodel ) ; $ metaModel = $ this -> factory -> getMetaModel ( $ metaModelName ) ; if ( $ metaModel ) { foreach ( $ metaModel -> getAttributes ( ) as $ objAttribute ) { $ attributeNames [ $ objAttribute -> getColName ( ) ] = $ objAttribute -> getName ( ) ; } } return $ attributeNames ; }
616	public function setDefinitions ( array $ definitions ) { foreach ( $ definitions as $ class => $ definition ) { if ( is_array ( $ definition ) && count ( $ definition ) === 2 && array_values ( $ definition ) === $ definition ) { $ this -> set ( $ class , $ definition [ 0 ] , $ definition [ 1 ] ) ; continue ; } $ this -> set ( $ class , $ definition ) ; } }
961	public function handle ( $ type ) { $ jobClass = '\\App\\Jobs\\' . str_replace ( '-' , '' , ucwords ( $ type , '-' ) ) . 'Job' ; $ jobClass :: dispatch ( Request :: header ( 'x-shopify-shop-domain' ) , json_decode ( Request :: getContent ( ) ) ) ; return Response :: make ( '' , 201 ) ; }
9948	public function getColumnDimension ( $ pColumn , $ create = true ) { $ pColumn = strtoupper ( $ pColumn ) ; if ( ! isset ( $ this -> columnDimensions [ $ pColumn ] ) ) { if ( ! $ create ) { return null ; } $ this -> columnDimensions [ $ pColumn ] = new ColumnDimension ( $ pColumn ) ; if ( Coordinate :: columnIndexFromString ( $ this -> cachedHighestColumn ) < Coordinate :: columnIndexFromString ( $ pColumn ) ) { $ this -> cachedHighestColumn = $ pColumn ; } } return $ this -> columnDimensions [ $ pColumn ] ; }
8667	public function setMessage ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'Message' ] [ 'FieldValue' ] = $ value ; return $ this ; }
2406	public static function generateStyleTag ( $ href , $ media = null , $ mtime = false ) { if ( $ mtime === null && ! preg_match ( '@^https?://@' , $ href ) ) { $ container = System :: getContainer ( ) ; $ rootDir = $ container -> getParameter ( 'kernel.project_dir' ) ; if ( file_exists ( $ rootDir . '/' . $ href ) ) { $ mtime = filemtime ( $ rootDir . '/' . $ href ) ; } else { $ webDir = StringUtil :: stripRootDir ( $ container -> getParameter ( 'contao.web_dir' ) ) ; if ( file_exists ( $ rootDir . '/' . $ webDir . '/' . $ href ) ) { $ mtime = filemtime ( $ rootDir . '/' . $ webDir . '/' . $ href ) ; } } } if ( $ mtime ) { $ href .= '?v=' . substr ( md5 ( $ mtime ) , 0 , 8 ) ; } return '<link rel="stylesheet" href="' . $ href . '"' . ( ( $ media && $ media != 'all' ) ? ' media="' . $ media . '"' : '' ) . '>' ; }
7838	public function create ( string $ name , array $ numbers ) : ? array { $ body = Body :: json ( [ [ 'name' => $ name , 'phone_numbers' => $ numbers , ] , ] ) ; $ response = Request :: post ( $ this -> baseUrl . 'contact' , [ ] , $ body ) ; if ( $ response -> code != 200 ) { if ( ! empty ( $ response -> body -> message ) ) { Log :: error ( $ response -> body -> message ) ; } } return [ 'code' => $ response -> code , 'message' => ( $ response -> code == 200 ) ? 'OK' : $ response -> body -> message ?? '' , 'data' => $ response -> body , ] ; }
4466	private function normalizeCommandArgs ( string $ command , array $ args ) : array { $ arguments = array_merge ( [ $ command , microtime ( true ) ] , $ args ) ; array_unshift ( $ arguments , 0 ) ; array_unshift ( $ arguments , $ this -> sha ) ; return $ arguments ; }
10977	public static function verify ( $ code ) { if ( ! $ code ) { return null ; } if ( $ user = self :: lookupVerificationCode ( $ code ) ) { $ user -> setVerificationCode ( ) ; } return $ user ; }
4279	public function stream_seek ( $ offset , $ whence = SEEK_SET ) { if ( ! $ this -> handle ) { return false ; } self :: restorePrev ( ) ; $ result = \ fseek ( $ this -> handle , $ offset , $ whence ) ; $ success = $ result !== - 1 ; self :: register ( ) ; return $ success ; }
5766	private function clear ( ) { if ( ! isset ( $ this -> phpMailer ) ) { return ; } $ this -> phpMailer -> clearAddresses ( ) ; $ this -> phpMailer -> clearCCs ( ) ; $ this -> phpMailer -> clearBCCs ( ) ; $ this -> phpMailer -> clearReplyTos ( ) ; $ this -> phpMailer -> clearAllRecipients ( ) ; $ this -> phpMailer -> clearAttachments ( ) ; $ this -> phpMailer -> clearCustomHeaders ( ) ; }
3163	public function startTimer ( RunnerServiceContext $ context , $ timestamp = null ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ session = $ context -> getTestSession ( ) ; if ( $ session -> getState ( ) === AssessmentTestSessionState :: INTERACTING ) { $ session -> startItemTimer ( $ timestamp ) ; } } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'startTimer' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } return true ; }
8137	public function getCacheFilename ( $ name ) { @ trigger_error ( sprintf ( 'The %s method is deprecated since version 1.22 and will be removed in Twig 2.0.' , __METHOD__ ) , E_USER_DEPRECATED ) ; $ key = $ this -> cache -> generateKey ( $ name , $ this -> getTemplateClass ( $ name ) ) ; return ! $ key ? false : $ key ; }
3509	private static function renderToTextFromOpcode ( $ opcode , $ from , $ from_offset , $ from_len ) { if ( $ opcode === 'c' || $ opcode === 'i' ) { echo substr ( $ from , $ from_offset , $ from_len ) ; } }
10818	public static function error ( $ messages , $ linebreak = true , $ length = 0 ) { $ separator = $ linebreak ? "\n" : '' ; self :: write ( $ messages , 'error' , $ length , $ separator ) ; }
8205	protected function getJobStats ( $ job ) { try { return ( array ) $ this -> getPheanstalk ( ) -> statsJob ( $ job ) ; } catch ( ServerException $ e ) { if ( $ this -> isNotFoundException ( $ e ) ) { return ; } throw $ e ; } }
4193	protected function dumpProperties ( $ abs ) { $ label = \ count ( $ abs [ 'properties' ] ) ? 'properties' : 'no properties' ; if ( $ abs [ 'viaDebugInfo' ] ) { $ label .= ' <span class="text-muted">(via __debugInfo)</span>' ; } $ str = '<dt class="properties">' . $ label . '</dt>' . "\n" ; $ magicMethods = \ array_intersect ( array ( '__get' , '__set' ) , \ array_keys ( $ abs [ 'methods' ] ) ) ; $ str .= $ this -> magicMethodInfo ( $ magicMethods ) ; foreach ( $ abs [ 'properties' ] as $ k => $ info ) { $ vis = ( array ) $ info [ 'visibility' ] ; $ isPrivateAncestor = \ in_array ( 'private' , $ vis ) && $ info [ 'inheritedFrom' ] ; $ classes = \ array_keys ( \ array_filter ( array ( 'debuginfo-value' => $ info [ 'valueFrom' ] == 'debugInfo' , 'excluded' => $ info [ 'isExcluded' ] , 'forceShow' => $ info [ 'forceShow' ] , 'debug-value' => $ info [ 'valueFrom' ] == 'debug' , 'private-ancestor' => $ isPrivateAncestor , 'property' => true , \ implode ( ' ' , $ vis ) => $ info [ 'visibility' ] !== 'debug' , ) ) ) ; $ modifiers = $ vis ; if ( $ info [ 'isStatic' ] ) { $ modifiers [ ] = 'static' ; } $ str .= '<dd class="' . \ implode ( ' ' , $ classes ) . '">' . \ implode ( ' ' , \ array_map ( function ( $ modifier ) { return '<span class="t_modifier_' . $ modifier . '">' . $ modifier . '</span>' ; } , $ modifiers ) ) . ( $ isPrivateAncestor ? ' (<i>' . $ info [ 'inheritedFrom' ] . '</i>)' : '' ) . ( $ info [ 'type' ] ? ' <span class="t_type">' . $ info [ 'type' ] . '</span>' : '' ) . ' <span class="property-name"' . ' title="' . \ htmlspecialchars ( $ info [ 'desc' ] ) . '"' . '>' . $ k . '</span>' . ( $ info [ 'value' ] !== $ this -> debug -> abstracter -> UNDEFINED ? ' <span class="t_operator">=</span> ' . $ this -> debug -> output -> html -> dump ( $ info [ 'value' ] ) : '' ) . '</dd>' . "\n" ; } return $ str ; }
9390	public function getSortValBeforeAll ( $ groupingId = null ) { if ( $ groupingId === null && $ this -> grpColumn ) { throw new SortableException ( 'groupingId may be omitted only when grpColumn is not configured.' ) ; } $ query = ( new Query ( ) ) -> select ( [ $ this -> pkColumn , $ this -> srtColumn ] ) -> from ( $ this -> targetTable ) -> where ( [ 'and' , $ this -> grpColumn ? [ '=' , $ this -> grpColumn , $ groupingId ] : [ ] , $ this -> skipRowsClause ( ) ] ) -> orderBy ( [ $ this -> srtColumn => SORT_ASC ] ) -> limit ( 1 ) ; $ result = $ query -> one ( $ this -> db ) ; if ( $ result && $ result [ $ this -> srtColumn ] == 1 ) { $ this -> rebuildSortAfter ( $ result [ $ this -> pkColumn ] , true ) ; $ sortVal = $ this -> getIniSortVal ( ) ; } else if ( $ result ) { $ sortVal = ceil ( $ result [ $ this -> srtColumn ] / 2 ) ; } else $ sortVal = $ this -> getIniSortVal ( ) ; return ( int ) $ sortVal ; }
105	public function watch2OnHighest ( Decisions $ decisions ) { $ literals = $ this -> rule -> getLiterals ( ) ; if ( count ( $ literals ) < 3 ) { return ; } $ watchLevel = 0 ; foreach ( $ literals as $ literal ) { $ level = $ decisions -> decisionLevel ( $ literal ) ; if ( $ level > $ watchLevel ) { $ this -> watch2 = $ literal ; $ watchLevel = $ level ; } } }
7600	public function render ( array $ aButtons , array $ aButtonGroupOptions = null ) { if ( empty ( $ aButtonGroupOptions [ 'attributes' ] ) ) { $ aButtonGroupOptions [ 'attributes' ] = array ( 'class' => 'btn-group' ) ; } else { if ( ! is_array ( $ aButtonGroupOptions [ 'attributes' ] ) ) { throw new LogicException ( '"attributes" option expects an array, "' . gettype ( $ aButtonGroupOptions [ 'attributes' ] ) . '" given' ) ; } if ( empty ( $ aButtonGroupOptions [ 'attributes' ] [ 'class' ] ) ) { $ aButtonGroupOptions [ 'attributes' ] [ 'class' ] = 'btn-group' ; } elseif ( ! preg_match ( '/(\s|^)(?:btn-group|btn-group-vertical)(\s|$)/' , $ aButtonGroupOptions [ 'attributes' ] [ 'class' ] ) ) { $ aButtonGroupOptions [ 'attributes' ] [ 'class' ] .= ' btn-group' ; } } return sprintf ( static :: $ buttonGroupContainerFormat , $ this -> createAttributesString ( $ aButtonGroupOptions [ 'attributes' ] ) , $ this -> renderButtons ( $ aButtons , strpos ( $ aButtonGroupOptions [ 'attributes' ] [ 'class' ] , 'btn-group-justified' ) !== false ) ) ; }
11773	private function findComponentModuleByType ( array $ module_list , string $ find_component_type ) { foreach ( $ module_list as $ m ) { $ component_type = call_user_func ( [ $ m , 'declareComponentType' ] ) ; if ( $ component_type == $ find_component_type ) { return $ m ; } } return null ; }
10874	public function getEncodeHash ( int $ id , string $ slug , string $ linkValidate = null ) : string { return base64_encode ( uniqid ( ( $ linkValidate ? strtotime ( $ linkValidate ) : self :: NO_TIME ) . self :: TIME_SEPARATOR , true ) . self :: PART_SEPARATOR . $ this -> getHash ( $ id . $ slug ) . self :: ID_SEPARATOR . $ id ) ; }
5640	public function paintGroupEnd ( $ test_name ) { array_pop ( $ this -> test_stack ) ; if ( count ( $ this -> test_stack ) == 0 ) { $ this -> paintFooter ( $ test_name ) ; } }
26	protected function getRemoteContents ( $ originUrl , $ fileUrl , $ context , array & $ responseHeaders = null ) { try { $ e = null ; $ result = file_get_contents ( $ fileUrl , false , $ context ) ; } catch ( \ Throwable $ e ) { } catch ( \ Exception $ e ) { } $ responseHeaders = isset ( $ http_response_header ) ? $ http_response_header : array ( ) ; if ( null !== $ e ) { throw $ e ; } return $ result ; }
4735	public function regenerate_id ( $ delete_old = false ) { if ( $ delete_old ) { delete_option ( "_wp_session_{$this->session_id}" ) ; } $ this -> session_id = $ this -> generate_id ( ) ; $ this -> set_cookie ( ) ; }
10680	protected function generateURLSegment ( $ title ) { $ filter = URLSegmentFilter :: create ( ) ; $ t = $ filter -> filter ( $ title ) ; if ( ! $ t || $ t == '-' || $ t == '-1' ) { $ t = "{$this->owner->ClassName}-{$this->owner->ID}" ; } else { $ class = $ this -> owner -> ClassName ; $ obj = $ class :: get ( ) -> filter ( array ( "URLSegment" => $ t ) ) -> exclude ( array ( "ID" => $ this -> owner -> ID ) ) -> first ( ) ; if ( $ obj ) { $ t .= "-{$this->owner->ID}" ; } } return $ t ; }
1736	public function getQrCode ( User $ user , Request $ request ) : string { $ renderer = new ImageRenderer ( new RendererStyle ( 180 , 0 ) , new SvgImageBackEnd ( ) ) ; $ writer = new Writer ( $ renderer ) ; return $ writer -> writeString ( $ this -> getProvisionUri ( $ user , $ request ) ) ; }
5702	public function isCustomActionAllowed ( $ action ) { $ actions = $ this -> owner -> config ( ) -> better_buttons_actions ; if ( $ actions ) { return in_array ( $ action , $ actions ) ; } return false ; }
2773	public function fetchTags ( ) : array { $ output = $ this -> gitWorkingCopy -> tag ( [ 'l' => true ] ) ; $ tags = ( array ) preg_split ( "/\r\n|\n|\r/" , rtrim ( $ output ) ) ; return array_map ( [ $ this , 'trimTags' ] , $ tags ) ; }
10907	public static function get ( array $ server ) : array { $ params = [ ] ; if ( isset ( $ server [ 'QUERY_STRING' ] ) ) { $ query = ltrim ( $ server [ 'QUERY_STRING' ] , '?' ) ; foreach ( explode ( '&' , $ query ) as $ pair ) { if ( $ pair ) { list ( $ name , $ value ) = self :: normalize ( array_map ( 'urldecode' , explode ( '=' , $ pair , 2 ) ) ) ; $ params [ $ name ] [ ] = $ value ; } } } return $ params ? array_map ( function ( $ v ) { return count ( $ v ) === 1 ? $ v [ 0 ] : $ v ; } , $ params ) : $ params ; }
9329	protected function registerMarkdownBladeEngine ( $ resolver ) { $ app = $ this -> app ; $ app -> singleton ( 'markdown.blade.compiler' , function ( $ app ) { $ cache = $ app [ 'config' ] [ 'view.compiled' ] ; return new MarkdownBladeCompiler ( $ app [ 'files' ] , $ cache ) ; } ) ; $ resolver -> register ( 'markdown.blade' , function ( ) use ( $ app ) { return new MarkdownEngine ( $ app [ 'markdown.blade.compiler' ] , $ app [ 'files' ] ) ; } ) ; $ app [ 'view' ] -> addExtension ( 'md.blade.php' , 'markdown.blade' ) ; }
11868	public function destroy ( string $ sessionIdentifier ) : void { if ( ! isset ( self :: $ files [ $ sessionIdentifier ] ) ) { throw new SessionNotFoundException ( ) ; } unset ( self :: $ files [ $ sessionIdentifier ] ) ; }
4677	public function renderBuffered ( $ region = "main" ) { ob_start ( ) ; $ this -> render ( $ region ) ; $ res = ob_get_contents ( ) ; ob_end_clean ( ) ; return $ res ; }
5908	public function listUsers ( $ includeDeleted = false , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'includeDeleted' => $ includeDeleted ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/accounts/users' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new User ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
7389	public function getResponse ( array $ packageList , array $ languageList , array $ customRouteList , string $ url = '' ) : Response { $ request = new Request ( $ languageList , $ packageList , $ url ) ; $ this -> packageRoot .= 'package/' . $ request -> package ( ) . '/' ; try { if ( isset ( $ customRouteList [ $ request -> package ( ) ] ) ) { $ path = $ this -> packageRoot . 'CustomRoute.php' ; if ( file_exists ( $ path ) ) { require $ path ; $ route = $ request -> package ( ) . '\\CustomRoute' ; $ route = new $ route ( ) ; $ this -> response = $ route -> getResponse ( $ this -> packageRoot , $ request ) ; if ( $ this -> response -> is404 ( ) ) { $ this -> set404 ( ) ; } return $ this -> response ; } else { throw new RouteException ( sprintf ( 'The file "%s" does not exist' , $ path ) ) ; } } else { $ this -> response = ( new DefaultRoute ( ) ) -> getResponse ( $ this -> packageRoot , $ request ) ; if ( $ this -> response -> is404 ( ) ) { $ this -> set404 ( ) ; } return $ this -> response ; } } catch ( RouteException $ e ) { if ( Wrap :: isEnabled ( ) ) { throw $ e ; } else { $ this -> response = new Response ( ) ; $ this -> set404 ( ) ; return $ this -> response ; } } }
10478	protected function resolveItemAction ( AbstractDiffItem $ item ) { if ( $ item instanceof CreateDiffItem ) { $ action = ActionTypes :: CREATE ; return $ action ; } elseif ( $ item instanceof DeleteDiffItem ) { $ action = ActionTypes :: DELETE ; return $ action ; } elseif ( $ item instanceof UpdateDiffItem ) { $ action = ActionTypes :: UPDATE ; return $ action ; } else { throw new \ InvalidArgumentException ( 'Unsupported diff item type. Got: ' . get_class ( $ item ) ) ; } }
11629	private function createOperation ( $ trans , $ dsBegin ) { $ datePerformed = $ this -> hlpDate -> getUtcNowForDb ( ) ; $ req = new \ Praxigento \ Accounting \ Api \ Service \ Operation \ Create \ Request ( ) ; $ req -> setOperationTypeCode ( Cfg :: CODE_TYPE_OPER_PV_WRITE_OFF ) ; $ req -> setDatePerformed ( $ datePerformed ) ; $ req -> setTransactions ( $ trans ) ; $ period = substr ( $ dsBegin , 0 , 6 ) ; $ note = "PV Write Off ($period)" ; $ req -> setOperationNote ( $ note ) ; $ resp = $ this -> servOperation -> exec ( $ req ) ; $ result = $ resp -> getOperationId ( ) ; return $ result ; }
4700	protected function handleInput ( InputInterface $ input ) { if ( $ file = $ input -> getArgument ( 'file' ) ) { if ( ! file_exists ( $ file ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The input file "%s" not found' , $ file ) ) ; } return file_get_contents ( $ file ) ; } else { $ contents = '' ; if ( $ stdin = fopen ( 'php://stdin' , 'r' ) ) { if ( stream_set_blocking ( $ stdin , false ) ) { $ contents = stream_get_contents ( $ stdin ) ; } fclose ( $ stdin ) ; } if ( $ contents ) { return $ contents ; } } throw new \ InvalidArgumentException ( 'No input file' ) ; }
4571	public function setAnonymousUuid ( ? string $ anonymousUuid ) { $ this -> anonymousUuid = $ anonymousUuid ; $ this -> _anonymousUuid = true ; return $ this ; }
8358	public static function niceUrl ( string $ url ) { $ nice = null ; if ( ( $ pos = stripos ( $ url , '.' ) ) !== false ) { list ( $ subDomain , $ url ) = explode ( '.' , $ url ) ; $ request = Http :: getRequest ( ) ; $ nice = $ request -> getRawRequest ( ) -> getScheme ( ) . '://' ; if ( $ subDomain != null ) { $ nice .= $ subDomain . '.' ; } $ nice .= self :: extractDomain ( $ request -> getRawRequest ( ) ) ; } return $ nice . '/' . ltrim ( ( string ) preg_replace ( '/\/+/' , '/' , $ url ) , '/' ) ; }
5300	public function getGlyphNames ( ) { $ glyphNames = array ( ) ; foreach ( $ this -> font -> getGlyphs ( ) as $ glyph ) { $ glyphNames [ static :: unicodeToHex ( $ glyph [ 'char' ] ) ] = empty ( $ glyph [ 'name' ] ) ? null : $ glyph [ 'name' ] ; } return $ glyphNames ; }
2034	public function onRegister ( Registry $ registry ) { parent :: onRegister ( $ registry ) ; if ( $ this -> fallback && $ this -> type == 'root' && ! $ registry -> isRegisteredAlias ( $ this , 'contao.dns-fallback' , $ this -> dns ) ) { $ registry -> registerAlias ( $ this , 'contao.dns-fallback' , $ this -> dns ) ; } }
9409	protected function transform ( $ middleware , $ wrappable = true ) { if ( is_a ( $ middleware , Application :: MIDDLEWARE ) === false ) { $ approach = ( boolean ) $ this -> approach ( $ middleware ) ; $ response = $ approach === self :: SINGLE_PASS ? $ this -> response : null ; $ wrapper = new CallableMiddlewareWrapper ( $ middleware , $ response ) ; $ middleware = $ wrappable === true ? $ wrapper : $ middleware ; } return $ middleware ; }
11212	protected function getFromLookup ( $ key ) { if ( $ key === $ this -> cache_key || $ this -> hasInLookup ( $ key ) ) { return $ this -> getFromRegistry ( $ this -> cache_reg , $ key ) ; } return null ; }
12727	public function getValueMappedToTemplate ( ) { if ( $ this -> submitted ) { return $ this -> submittedValue ; } if ( $ this -> mapper ) { return $ this -> mapper -> mapToFrom ( $ this -> getValue ( ) ) ; } return $ this -> getValue ( ) ; }
5302	public static function unicodeToHex ( $ char ) { if ( ! is_string ( $ char ) || mb_strlen ( $ char , 'utf-8' ) !== 1 ) { throw new \ InvalidArgumentException ( '$char must be one single character' ) ; } $ unicode = unpack ( 'N' , mb_convert_encoding ( $ char , 'UCS-4BE' , 'UTF-8' ) ) ; return dechex ( $ unicode [ 1 ] ) ; }
9345	public function getRow ( $ int = 0 ) { if ( ! isset ( $ this -> arr [ $ int ] ) ) { throw new \ OutOfRangeException ( 'There is no line having this index.' ) ; } return $ this -> arr [ $ int ] ; }
9578	protected function registerPlugin ( $ name ) { $ view = $ this -> getView ( ) ; if ( $ this -> materializeAsset ) { MaterializeAsset :: register ( $ view ) ; } if ( $ this -> customAsset ) { MaterializeCustomAsset :: register ( $ view ) ; } $ id = $ this -> options [ 'id' ] ; if ( $ this -> clientOptions !== false ) { $ options = empty ( $ this -> clientOptions ) ? '' : Json :: encode ( $ this -> clientOptions ) ; $ js = "jQuery('#$id').$name($options);" ; $ view -> registerJs ( $ js ) ; } $ this -> registerClientEvents ( ) ; }
2530	protected function makeSoapClientOptions ( ) { $ options = $ this -> soapClientOptions ; $ options [ 'classmap' ] = array_merge ( Classmap :: $ soapheader4map , Classmap :: $ map ) ; if ( ! empty ( $ this -> params -> soapClientOptions ) ) { $ options = array_merge ( $ options , $ this -> params -> soapClientOptions ) ; } return $ options ; }
9462	private function getEventMap ( ) { return [ WatcherInterface :: CREATE_EVENT => FilesystemEvent :: CREATE , WatcherInterface :: MODIFY_EVENT => FilesystemEvent :: MODIFY , WatcherInterface :: DELETE_EVENT => FilesystemEvent :: DELETE , WatcherInterface :: ALL_EVENT => FilesystemEvent :: ALL ] ; }
5890	protected function filterList ( array $ nodes = array ( ) , array $ rules = array ( ) ) { if ( ! empty ( $ rules ) ) { foreach ( $ nodes as $ node ) { if ( ! $ node instanceof AbstractNode ) { continue ; } $ props = $ node -> getInfo ( false ) ; $ props = array_intersect_key ( $ props , $ rules ) ; $ match = true ; foreach ( $ props as $ key => $ val ) { if ( $ val instanceof StringHelper ) { $ match = $ val -> contains ( $ rules [ $ key ] , true ) ; } else { $ match = $ val == $ rules [ $ key ] ; } if ( $ match === false ) { unset ( $ nodes [ $ node -> getId ( ) ] ) ; } } } } return $ nodes ; }
830	private function processException ( $ name , $ e ) { $ this -> dispatchEvent ( FixerFileProcessedEvent :: NAME , new FixerFileProcessedEvent ( FixerFileProcessedEvent :: STATUS_EXCEPTION ) ) ; $ this -> errorsManager -> report ( new Error ( Error :: TYPE_EXCEPTION , $ name , $ e ) ) ; }
1626	public static function buildKey ( $ key ) { if ( is_numeric ( $ key ) ) { return $ key ; } elseif ( is_string ( $ key ) ) { return ctype_alnum ( $ key ) && StringHelper :: byteLength ( $ key ) <= 32 ? $ key : md5 ( $ key ) ; } elseif ( is_array ( $ key ) ) { if ( count ( $ key ) == 1 ) { return self :: buildKey ( reset ( $ key ) ) ; } ksort ( $ key ) ; $ isNumeric = true ; foreach ( $ key as $ value ) { if ( ! is_numeric ( $ value ) ) { $ isNumeric = false ; } } if ( $ isNumeric ) { return implode ( '-' , $ key ) ; } } return md5 ( json_encode ( $ key , JSON_NUMERIC_CHECK ) ) ; }
2405	public function minifyHtml ( $ strHtml ) { if ( Config :: get ( 'debugMode' ) ) { return $ strHtml ; } $ arrChunks = preg_split ( '@(</?pre[^>]*>)|(</?script[^>]*>)|(</?style[^>]*>)|( ?</?textarea[^>]*>)@i' , $ strHtml , - 1 , PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY ) ; $ strHtml = '' ; $ blnPreserveNext = false ; $ blnOptimizeNext = false ; $ strType = null ; $ isJavaScript = function ( $ strChunk ) { $ typeMatch = array ( ) ; if ( preg_match ( '/\stype\s*=\s*(?:(?J)(["\'])\s*(?<type>.*?)\s*\1|(?<type>[^\s>]+))/i' , $ strChunk , $ typeMatch ) && ! \ in_array ( strtolower ( $ typeMatch [ 'type' ] ) , static :: $ validJavaScriptTypes ) ) { return false ; } if ( preg_match ( '/\slanguage\s*=\s*(?:(?J)(["\'])\s*(?<type>.*?)\s*\1|(?<type>[^\s>]+))/i' , $ strChunk , $ typeMatch ) && ! \ in_array ( 'text/' . strtolower ( $ typeMatch [ 'type' ] ) , static :: $ validJavaScriptTypes ) ) { return false ; } return true ; } ; foreach ( $ arrChunks as $ strChunk ) { if ( strncasecmp ( $ strChunk , '<pre' , 4 ) === 0 || strncasecmp ( ltrim ( $ strChunk ) , '<textarea' , 9 ) === 0 ) { $ blnPreserveNext = true ; } elseif ( strncasecmp ( $ strChunk , '<script' , 7 ) === 0 ) { if ( $ isJavaScript ( $ strChunk ) ) { $ blnOptimizeNext = true ; $ strType = 'js' ; } else { $ blnPreserveNext = true ; } } elseif ( strncasecmp ( $ strChunk , '<style' , 6 ) === 0 ) { $ blnOptimizeNext = true ; $ strType = 'css' ; } elseif ( $ blnPreserveNext ) { $ blnPreserveNext = false ; } elseif ( $ blnOptimizeNext ) { $ blnOptimizeNext = false ; if ( $ strType == 'js' ) { $ objMinify = new Minify \ JS ( ) ; $ objMinify -> add ( $ strChunk ) ; $ strChunk = $ objMinify -> minify ( ) ; } elseif ( $ strType == 'css' ) { $ objMinify = new Minify \ CSS ( ) ; $ objMinify -> add ( $ strChunk ) ; $ strChunk = $ objMinify -> minify ( ) ; } } else { $ strChunk = str_replace ( "\r" , '' , $ strChunk ) ; $ strChunk = preg_replace ( array ( '/^[\t ]+/m' , '/[\t ]+$/m' , '/\n\n+/' ) , array ( '' , '' , "\n" ) , $ strChunk ) ; } $ strHtml .= $ strChunk ; } return trim ( $ strHtml ) ; }
9349	public function multiplyAllow ( $ matrix ) { if ( is_numeric ( $ matrix ) ) { return true ; } if ( $ matrix instanceof Complex ) { return true ; } if ( $ matrix instanceof Matrix ) { return $ this -> size -> cols == $ matrix -> rows ; } return false ; }
6358	public function setTimezone ( $ timezone ) { try { $ this -> timestamp -> setTimezone ( new DateTimeZone ( $ timezone ) ) ; } catch ( Exception $ e ) { throw new TimestampException ( __METHOD__ . ': Invalid timezone.' , $ e -> getCode ( ) , $ e ) ; } }
8491	public static function getCpuCores ( ) { $ wmi = Windows :: getInstance ( ) ; $ object = $ wmi -> ExecQuery ( "SELECT NumberOfLogicalProcessors FROM Win32_Processor" ) ; $ cores = 0 ; foreach ( $ object as $ obj ) { $ cores = $ obj -> NumberOfLogicalProcessors ; } return $ cores ; }
6988	protected function finalize ( ContextInterface $ context ) : ContextInterface { if ( null === $ context -> getCustomerGroup ( ) ) { $ context -> setCustomerGroup ( $ this -> customerGroupRepository -> findDefault ( ) ) ; } if ( null === $ context -> getInvoiceCountry ( ) ) { $ context -> setInvoiceCountry ( $ this -> countryProvider -> getCountry ( ) ) ; } if ( null === $ context -> getDeliveryCountry ( ) ) { $ context -> setDeliveryCountry ( $ this -> countryProvider -> getCountry ( ) ) ; } if ( null === $ context -> getCurrency ( ) ) { $ context -> setCurrency ( $ this -> currencyProvider -> getCurrency ( ) ) ; } if ( null === $ context -> getLocale ( ) ) { $ context -> setLocale ( $ this -> localProvider -> getCurrentLocale ( ) ) ; } if ( null === $ context -> getVatDisplayMode ( ) ) { if ( null !== $ mode = $ context -> getCustomerGroup ( ) -> getVatDisplayMode ( ) ) { $ context -> setVatDisplayMode ( $ mode ) ; } else { $ context -> setVatDisplayMode ( $ this -> defaultVatDisplayMode ) ; } } $ this -> eventDispatcher -> dispatch ( ContextEvents :: BUILD , new ContextEvent ( $ context ) ) ; return $ context ; }
11477	public function boot ( Plugin $ theme ) { $ this -> plugin = $ theme ; parent :: boot ( $ theme ) ; $ this -> initTemplates ( ) ; $ this -> initHomepageTemplate ( ) ; return $ this ; }
6864	protected function updateTotals ( InvoiceInterface $ invoice ) { $ changed = $ this -> invoiceCalculator -> calculate ( $ invoice ) ; if ( $ changed ) { foreach ( $ invoice -> getLines ( ) as $ line ) { $ this -> persistenceHelper -> persistAndRecompute ( $ line , false ) ; } } return $ changed ; }
12340	protected function print ( string $ msg , bool $ withTime = true ) : void { $ preMsg = '' ; if ( $ withTime ) { $ preMsg = ( new \ DateTime ( 'now' ) ) -> format ( 'H:i:s' ) . "\t" ; } echo "{$preMsg}{$msg}" . \ PHP_EOL ; }
10729	public function getDay ( ) { if ( $ this -> value !== null ) { preg_match ( '/^(?P<year>[0-9]{4,4})-(?P<month>[0-9]{2,2})-(?P<day>[0-9]{2,2}) (?P<hour>[0-9]{2,2}):(?P<minute>[0-9]{2,2}):(?P<second>[0-9]{2,2})$/ui' , $ this -> value , $ m ) ; return ( int ) $ m [ 'day' ] ; } }
4119	public static function addType ( $ name , $ className ) { if ( isset ( self :: $ _typesMap [ $ name ] ) ) { throw TypeException :: typeExists ( $ name ) ; } self :: $ _typesMap [ $ name ] = $ className ; }
12420	public function dt ( $ domain , $ singular ) { $ singular = ( string ) $ singular ; try { $ locale = $ this -> getLocale ( ) ; foreach ( $ this -> getTranslations ( $ domain ) as $ object ) { if ( ( $ string = $ object -> translate ( $ singular , $ domain , $ locale ) ) != $ singular ) { return $ string ; } } } catch ( \ Exception $ e ) { ; } return ( string ) $ singular ; }
3628	protected static function getCURLCerts ( ) { $ url = 'https://curl.haxx.se/ca/cacert.pem' ; $ certs = @ file_get_contents ( $ url ) ; if ( ! $ certs ) { $ ch = curl_init ( ) ; curl_setopt ( $ ch , CURLOPT_URL , $ url ) ; curl_setopt ( $ ch , CURLOPT_RETURNTRANSFER , TRUE ) ; curl_setopt ( $ ch , CURLOPT_SSL_VERIFYPEER , TRUE ) ; curl_setopt ( $ ch , CURLOPT_SSL_VERIFYHOST , 2 ) ; $ response = curl_exec ( $ ch ) ; $ info = curl_getinfo ( $ ch ) ; curl_close ( $ ch ) ; if ( $ info [ 'http_code' ] == 200 ) { $ certs = $ response ; } } return $ certs ; }
2029	public static function findPublishedFallbackByHostname ( $ strHost , array $ arrOptions = array ( ) ) { if ( empty ( $ arrOptions ) ) { $ objModel = Registry :: getInstance ( ) -> fetch ( static :: $ strTable , $ strHost , 'contao.dns-fallback' ) ; if ( $ objModel !== null ) { return $ objModel ; } } $ t = static :: $ strTable ; $ arrColumns = array ( "$t.dns=? AND $t.fallback='1'" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } return static :: findOneBy ( $ arrColumns , $ strHost , $ arrOptions ) ; }
2877	public function searchGroupClassAction ( ) { if ( ! $ this -> getRequest ( ) -> isPost ( ) ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 405 ) ; return ; } $ uri = ( string ) $ this -> getRequest ( ) -> getPost ( 'uri' ) ; $ groupType = $ this -> getRequest ( ) -> getPost ( 'group' ) ; $ groupTypes = array ( $ groupType ) ; if ( $ groupType == 'all' ) { $ groupTypes = array ( 'model' , 'block' , 'helper' ) ; } $ items = array ( ) ; if ( $ uri ) { foreach ( $ groupTypes as $ type ) { $ items [ $ type ] [ 'class' ] = Mage :: getConfig ( ) -> getGroupedClassName ( $ type , $ uri ) ; $ items [ $ type ] [ 'filepath' ] = mageFindClassFile ( $ items [ $ type ] [ 'class' ] ) ; } $ block = $ this -> getLayout ( ) -> createBlock ( 'sheep_debug/array' ) ; $ block -> setTemplate ( 'sheep_debug/grouped_class_search.phtml' ) ; $ block -> assign ( 'items' , $ items ) ; $ this -> getResponse ( ) -> setBody ( $ block -> toHtml ( ) ) ; } else { $ this -> getResponse ( ) -> setBody ( $ this -> __ ( 'Please fill in a search query' ) ) ; } }
1645	public function getDistance ( Coordinate $ coordinate , DistanceInterface $ calculator ) : float { return $ calculator -> getDistance ( $ this , $ coordinate ) ; }
3572	public function set ( $ key , $ value = null , $ group = null ) { if ( $ key instanceof Attribute ) { return $ this -> setInstance ( $ key ) ; } if ( $ this -> has ( $ key ) ) { $ this -> update ( $ key , $ value , $ group ) ; } else { $ this -> items [ $ key ] = $ this -> newAttribute ( $ key , $ value , $ group ) ; } return $ this ; }
5027	public function getTemplate ( $ page ) { $ bundle = $ this -> getBundleName ( ClassUtils :: getRealClass ( get_class ( $ page ) ) ) ; return sprintf ( '%s:Page:%s.html.twig' , $ bundle , $ page -> getTemplateName ( ) ) ; }
9140	public static function parseFromServerRequest ( $ serverVars , $ defaultController = 'Index' , $ defaultAction = 'index' ) { if ( ! isset ( $ serverVars [ 'REQUEST_URI' ] ) ) { throw new InvalidUrlException ( "No such uri provided" ) ; } return self :: parse ( $ serverVars [ 'REQUEST_URI' ] , $ serverVars , $ defaultController , $ defaultAction ) ; }
7127	public function getDetails ( ) { return [ 'valid' => $ this -> valid , 'country' => $ this -> country , 'number' => $ this -> number , 'name' => $ this -> name , 'address' => $ this -> address , 'date' => $ this -> date , ] ; }
11613	public function create ( $ account , $ nickname ) { $ params = [ 'kf_account' => $ account , 'nickname' => $ nickname , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_CREATE , $ params ] ) ; }
4176	public function getFacades ( ) { return $ this -> facades ? : $ this -> facades = new Facade ( clone $ this -> getFiles ( ) , $ this -> console ) ; }
3685	protected function optimizedFilter ( $ filterRule , $ children , $ operation ) { $ procedure = new FilterBuilderSql ( $ this -> getMetaModel ( ) -> getTableName ( ) , $ operation , $ this -> connection ) ; $ skipped = $ this -> buildNativeSqlProcedure ( $ procedure , $ children ) ; if ( ! $ procedure -> isEmpty ( ) ) { $ filterRule -> addChild ( $ this -> getMetaModel ( ) -> getEmptyFilter ( ) -> addFilterRule ( $ procedure -> build ( ) ) ) ; } return $ skipped ; }
2101	public static function getNumericDatimFormat ( ) { if ( TL_MODE == 'FE' ) { global $ objPage ; if ( $ objPage -> datimFormat != '' && static :: isNumericFormat ( $ objPage -> datimFormat ) ) { return $ objPage -> datimFormat ; } } return Config :: get ( 'datimFormat' ) ; }
1972	public static function findByPath ( $ path , array $ arrOptions = array ( ) ) { $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( strncmp ( $ path , $ rootDir . '/' , \ strlen ( $ rootDir ) + 1 ) === 0 ) { $ path = substr ( $ path , \ strlen ( $ rootDir ) + 1 ) ; } return static :: findOneBy ( 'path' , $ path , $ arrOptions ) ; }
12964	private function getPerMonth ( $ months ) { $ per_month = [ ] ; $ log = $ this -> logger -> perMonth ( $ months ) ; foreach ( $ log as $ date => $ hits ) { array_push ( $ per_month , [ $ date , $ hits ] ) ; } return $ per_month ; }
3745	public function fetch ( ConfigInterface $ objConfig ) { $ backupLanguage = $ this -> setLanguage ( $ this -> getCurrentLanguage ( ) ) ; if ( $ objConfig -> getId ( ) !== null ) { $ modelId = $ objConfig -> getId ( ) ; } else { $ filter = $ this -> prepareFilter ( $ objConfig ) ; $ ids = $ this -> getIdsFromFilter ( $ filter , $ objConfig ) ; $ modelId = reset ( $ ids ) ; } $ objItem = $ modelId ? $ this -> getMetaModel ( ) -> findById ( $ modelId , $ objConfig -> getFields ( ) ? : array ( ) ) : null ; $ this -> setLanguage ( $ backupLanguage ) ; if ( ! $ objItem ) { return null ; } return new Model ( $ objItem ) ; }
8057	public function setParentProcessTitleFormat ( $ string ) { if ( $ this -> created ) { throw new WorkerPoolException ( 'Cannot set the Children\'s Process Title Format for a created pool.' ) ; } $ this -> parentProcessTitleFormat = ProcessDetails :: sanitizeProcessTitleFormat ( $ string ) ; return $ this ; }
10092	protected function identifierHash ( $ identifier , $ hash = 'md5' ) { if ( filter_var ( $ identifier , FILTER_VALIDATE_EMAIL ) || $ identifier === null ) { return hash ( $ hash , $ identifier ) ; } return hash ( 'sha256' , $ identifier ) ; }
8662	private function convertGetFeedSubmissionList ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetFeedSubmissionList' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetFeedSubmissionIdList ( ) ) { $ feedSubmissionIdList = $ request -> getFeedSubmissionIdList ( ) ; foreach ( $ feedSubmissionIdList -> getId ( ) as $ idIndex => $ id ) { $ parameters [ 'FeedSubmissionIdList' . '.' . 'Id' . '.' . ( $ idIndex + 1 ) ] = $ id ; } } if ( $ request -> isSetMaxCount ( ) ) { $ parameters [ 'MaxCount' ] = $ request -> getMaxCount ( ) ; } if ( $ request -> isSetFeedTypeList ( ) ) { $ feedTypeList = $ request -> getFeedTypeList ( ) ; foreach ( $ feedTypeList -> getType ( ) as $ typeIndex => $ type ) { $ parameters [ 'FeedTypeList' . '.' . 'Type' . '.' . ( $ typeIndex + 1 ) ] = $ type ; } } if ( $ request -> isSetFeedProcessingStatusList ( ) ) { $ feedProcessingStatusList = $ request -> getFeedProcessingStatusList ( ) ; foreach ( $ feedProcessingStatusList -> getStatus ( ) as $ statusIndex => $ status ) { $ parameters [ 'FeedProcessingStatusList' . '.' . 'Status' . '.' . ( $ statusIndex + 1 ) ] = $ status ; } } if ( $ request -> isSetSubmittedFromDate ( ) ) { $ parameters [ 'SubmittedFromDate' ] = $ this -> getFormattedTimestamp ( $ request -> getSubmittedFromDate ( ) ) ; } if ( $ request -> isSetSubmittedToDate ( ) ) { $ parameters [ 'SubmittedToDate' ] = $ this -> getFormattedTimestamp ( $ request -> getSubmittedToDate ( ) ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
6677	public static function toRelativeTime ( $ fromTime , $ toTime = 'now' , $ format = 'days' ) { $ startTime = new DateTime ( $ fromTime ) ; $ endTime = new DateTime ( $ toTime ) ; return $ startTime -> diff ( $ endTime ) -> $ format ; }
7122	protected function detectAndApplyLanguage ( ) { if ( $ this -> config ( 'autodetect' , true ) ) { $ detector = $ this -> getLanguageDetector ( ) ; $ language = $ detector -> getLanguageFromCookie ( ) ; if ( ! $ language || strlen ( $ language ) > 5 || ! in_array ( $ language , $ this -> getSupportedLanguages ( ) , true ) ) { $ language = $ detector -> getDriver ( ) -> detect ( ) ; if ( ! $ language || strlen ( $ language ) > 5 ) { $ language = $ this -> request -> getDefaultLocale ( ) ; } } $ this -> applyNewLanguage ( $ language , true ) ; } }
9886	private function writeDefinedNameForAutofilter ( XMLWriter $ objWriter , Worksheet $ pSheet , $ pSheetId = 0 ) { $ autoFilterRange = $ pSheet -> getAutoFilter ( ) -> getRange ( ) ; if ( ! empty ( $ autoFilterRange ) ) { $ objWriter -> startElement ( 'definedName' ) ; $ objWriter -> writeAttribute ( 'name' , '_xlnm._FilterDatabase' ) ; $ objWriter -> writeAttribute ( 'localSheetId' , $ pSheetId ) ; $ objWriter -> writeAttribute ( 'hidden' , '1' ) ; $ range = Coordinate :: splitRange ( $ autoFilterRange ) ; $ range = $ range [ 0 ] ; if ( strpos ( $ range [ 0 ] , '!' ) !== false ) { list ( $ ws , $ range [ 0 ] ) = explode ( '!' , $ range [ 0 ] ) ; } $ range [ 0 ] = Coordinate :: absoluteCoordinate ( $ range [ 0 ] ) ; $ range [ 1 ] = Coordinate :: absoluteCoordinate ( $ range [ 1 ] ) ; $ range = implode ( ':' , $ range ) ; $ objWriter -> writeRawData ( '\'' . str_replace ( "'" , "''" , $ pSheet -> getTitle ( ) ) . '\'!' . $ range ) ; $ objWriter -> endElement ( ) ; } }
5697	public function baseTransform ( ) { parent :: baseTransform ( ) ; $ disabled = ( ! $ this -> gridFieldRequest -> getPreviousRecordID ( ) ) ; return $ this -> setDisabled ( $ disabled ) ; }
4779	public function removeWidget ( string $ widgetId ) { if ( isset ( $ this -> widgets [ $ widgetId ] ) ) { unset ( $ this -> widgets [ $ widgetId ] ) ; } return $ this ; }
3372	private function getFormFactory ( ContainerInterface $ services ) { $ elements = null ; if ( $ services -> has ( 'FormElementManager' ) ) { $ elements = $ services -> get ( 'FormElementManager' ) ; } return new Factory ( $ elements ) ; }
3301	public function request ( $ method , $ url , $ options = [ ] ) { $ method = strtoupper ( $ method ) ; $ options = array_merge ( self :: $ defaults , [ 'headers' => $ this -> headers ] , $ options ) ; return $ this -> getClient ( ) -> request ( $ method , $ url , $ options ) ; }
4130	public function createNativeQuery ( $ designDocName , $ viewName ) { $ designDoc = $ this -> config -> getDesignDocument ( $ designDocName ) ; if ( $ designDoc ) { $ designDoc = new $ designDoc [ 'className' ] ( $ designDoc [ 'options' ] ) ; } $ query = new Query ( $ this -> couchDBClient -> getHttpClient ( ) , $ this -> couchDBClient -> getDatabase ( ) , $ designDocName , $ viewName , $ designDoc ) ; return $ query ; }
7340	public function sendAttachment ( Chat $ chat , User $ recipient , Attachment $ attachment ) : void { $ type = $ attachment -> getType ( ) ; $ request = null ; switch ( $ type ) { case Attachment :: TYPE_FILE : $ request = new SendDocument ( ) ; $ request -> document = new InputFile ( $ attachment -> getPath ( ) ) ; $ request -> caption = $ attachment -> getParameters ( ) -> get ( 'caption' ) ; break ; case Attachment :: TYPE_IMAGE : $ request = new SendPhoto ( ) ; $ request -> caption = $ attachment -> getParameters ( ) -> get ( 'caption' ) ; break ; case Attachment :: TYPE_AUDIO : $ request = new SendAudio ( ) ; $ request -> chat_id = $ chat -> getId ( ) ; $ request -> caption = $ attachment -> getParameters ( ) -> get ( 'caption' ) ; $ request -> duration = $ attachment -> getParameters ( ) -> get ( 'duration' ) ; $ request -> performer = $ attachment -> getParameters ( ) -> get ( 'performer' ) ; $ request -> title = $ attachment -> getParameters ( ) -> get ( 'title' ) ; break ; case Attachment :: TYPE_VIDEO : $ request = new SendVideo ( ) ; $ request -> duration = $ attachment -> getParameters ( ) -> get ( 'duration' ) ; $ request -> width = $ attachment -> getParameters ( ) -> get ( 'width' ) ; $ request -> height = $ attachment -> getParameters ( ) -> get ( 'height' ) ; $ request -> caption = $ attachment -> getParameters ( ) -> get ( 'caption' ) ; break ; } if ( $ request ) { $ request -> chat_id = $ chat -> getId ( ) ; $ request -> disable_notification = $ attachment -> getParameters ( ) -> get ( 'disable_notification' ) ; $ request -> reply_to_message_id = $ attachment -> getParameters ( ) -> get ( 'reply_to_message_id' ) ; $ request -> reply_markup = $ attachment -> getParameters ( ) -> get ( 'reply_markup' ) ; $ this -> client -> performApiRequest ( $ request ) ; $ this -> loop -> run ( ) ; } }
528	public function actionInfo ( ) { $ items = [ 'framework' , 'app-basic' , 'app-advanced' , ] ; $ extensionPath = "{$this->basePath}/extensions" ; foreach ( scandir ( $ extensionPath ) as $ extension ) { if ( ctype_alpha ( $ extension ) && is_dir ( $ extensionPath . '/' . $ extension ) ) { $ items [ ] = $ extension ; } } if ( $ this -> update ) { foreach ( $ items as $ item ) { $ this -> stdout ( "fetching tags for $item..." ) ; if ( $ item === 'framework' ) { $ this -> gitFetchTags ( ( string ) $ this -> basePath ) ; } elseif ( strncmp ( 'app-' , $ item , 4 ) === 0 ) { $ this -> gitFetchTags ( "{$this->basePath}/apps/" . substr ( $ item , 4 ) ) ; } else { $ this -> gitFetchTags ( "{$this->basePath}/extensions/$item" ) ; } $ this -> stdout ( "done.\n" , Console :: FG_GREEN , Console :: BOLD ) ; } } else { $ this -> stdout ( "\nInformation may be outdated, re-run with `--update` to fetch latest tags.\n\n" ) ; } $ versions = $ this -> getCurrentVersions ( $ items ) ; $ nextVersions = $ this -> getNextVersions ( $ versions , self :: PATCH ) ; $ w = $ this -> minWidth ( array_keys ( $ versions ) ) ; $ this -> stdout ( str_repeat ( ' ' , $ w + 2 ) . "Current Version Next Version\n" , Console :: BOLD ) ; foreach ( $ versions as $ ext => $ version ) { $ this -> stdout ( $ ext . str_repeat ( ' ' , $ w + 3 - mb_strlen ( $ ext ) ) . $ version . '' ) ; $ this -> stdout ( str_repeat ( ' ' , 17 - mb_strlen ( $ version ) ) . $ nextVersions [ $ ext ] . "\n" ) ; } }
6740	public function front ( ) { add_action ( 'wp' , function ( ) { App :: setCurrentID ( 'EFG' ) ; if ( App :: main ( ) -> is_single ( ) && ! is_preview ( ) ) { $ this -> add_scripts ( 'customRatingGrifus' ) ; $ this -> add_styles ( ) ; } elseif ( is_home ( ) || is_category ( ) || is_archive ( ) || is_search ( ) ) { $ this -> add_scripts ( 'customRatingGrifusHome' ) ; } } ) ; }
1408	protected function attributeKeys ( Model $ model ) { if ( is_array ( $ this -> attributes ) ) { return $ this -> attributes ; } return $ model -> getVisible ( ) ; }
9765	function exist ( ) : self { if ( $ this -> hasFlag ( 'directory' ) ) $ constraint = directoryExists ( ) ; else if ( $ this -> hasFlag ( 'file' ) ) $ constraint = fileExists ( ) ; else throw new \ BadMethodCallException ( 'This assertion is not a file or directory one.' ) ; return $ this -> expect ( $ this -> target , $ constraint ) ; }
9710	private function writeWindow1 ( ) { $ record = 0x003D ; $ length = 0x0012 ; $ xWn = 0x0000 ; $ yWn = 0x0000 ; $ dxWn = 0x25BC ; $ dyWn = 0x1572 ; $ grbit = 0x0038 ; $ ctabsel = 1 ; $ wTabRatio = 0x0258 ; $ itabFirst = 0 ; $ itabCur = $ this -> spreadsheet -> getActiveSheetIndex ( ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vvvvvvvvv' , $ xWn , $ yWn , $ dxWn , $ dyWn , $ grbit , $ itabCur , $ itabFirst , $ ctabsel , $ wTabRatio ) ; $ this -> append ( $ header . $ data ) ; }
4479	public function tag ( ... $ tags ) : void { $ response = call_user_func_array ( [ $ this -> client , 'call' ] , array_merge ( [ 'tag' , 'add' , $ this -> jid ] , array_values ( func_get_args ( ) ) ) ) ; $ this -> setTags ( json_decode ( $ response , true ) ) ; }
5810	public function updateSearchableFields ( & $ fields ) { $ fields = array_merge ( array ( 'Tagging' => array ( 'title' => 'Tags' , 'field' => ListboxField :: create ( 'Tagging' , 'Tags' , FusionTag :: get ( ) -> map ( 'Title' , 'Title' ) -> toArray ( ) , ( Controller :: has_curr ( ) && ( $ filtering = Controller :: curr ( ) -> getRequest ( ) -> getVar ( 'q' ) ) && isset ( $ filtering [ 'Tagging' ] ) ) ? $ filtering [ 'Tagging' ] : array ( ) , null , true ) , 'filter' => $ this -> owner -> dbObject ( 'Tagging' ) -> stat ( 'default_search_filter_class' ) ) ) , $ fields ) ; $ this -> owner -> extend ( 'updateTaggingExtensionSearchableFields' , $ fields ) ; }
6950	private function getByCountryAndBusinessQuery ( ) { if ( null === $ this -> byCountryAndBusinessQuery ) { $ qb = $ this -> getBaseQueryBuilder ( ) ; $ this -> byCountryAndBusinessQuery = $ qb -> andWhere ( $ qb -> expr ( ) -> eq ( 'r.business' , ':business' ) ) -> getQuery ( ) -> setParameter ( 'business' , true ) -> setMaxResults ( 1 ) ; } return $ this -> byCountryAndBusinessQuery ; }
7142	private function registerActions ( ContainerBuilder $ container ) { if ( class_exists ( 'Ekyna\Component\Payum\Payzen\PayzenGatewayFactory' ) ) { $ definition = new Definition ( 'Ekyna\Component\Commerce\Bridge\Payum\Payzen\Action\ConvertAction' ) ; $ definition -> addTag ( 'payum.action' , [ 'factory' => 'payzen' , 'prepend' => true ] ) ; $ container -> setDefinition ( 'ekyna_commerce.payum.action.payzen.convert_payment' , $ definition ) ; $ definition = new Definition ( 'Ekyna\Component\Commerce\Bridge\Payum\Payzen\Action\FraudLevelAction' ) ; $ definition -> addTag ( 'payum.action' , [ 'factory' => 'payzen' , 'prepend' => true ] ) ; $ container -> setDefinition ( 'ekyna_commerce.payum.action.payzen.fraud_level' , $ definition ) ; } if ( class_exists ( 'Ekyna\Component\Payum\Sips\SipsGatewayFactory' ) ) { $ definition = new Definition ( 'Ekyna\Component\Commerce\Bridge\Payum\Sips\Action\ConvertAction' ) ; $ definition -> addTag ( 'payum.action' , [ 'factory' => 'atos_sips' , 'prepend' => true ] ) ; $ container -> setDefinition ( 'ekyna_commerce.payum.action.sips.convert_payment' , $ definition ) ; } if ( class_exists ( 'Payum\Paypal\ExpressCheckout\Nvp\PaypalExpressCheckoutGatewayFactory' ) ) { $ definition = new Definition ( 'Ekyna\Component\Commerce\Bridge\Payum\Paypal\Action\EcNvpConvertAction' ) ; $ definition -> setArgument ( 0 , new Reference ( 'ekyna_commerce.common.amount_calculator' ) ) ; if ( $ container -> has ( 'ekyna_setting.manager' ) && class_exists ( 'Ekyna\Bundle\AdminBundle\Settings\GeneralSettingsSchema' ) ) { $ definition -> setArgument ( 1 , new Expression ( "service('ekyna_setting.manager').getParameter('general.site_name')" ) ) ; } $ definition -> addTag ( 'payum.action' , [ 'factory' => 'paypal_express_checkout' , 'prepend' => true ] ) ; $ container -> setDefinition ( 'ekyna_commerce.payum.action.paypal_ec_nvp.convert_payment' , $ definition ) ; } $ actions = [ 'capture_payment' => Action \ CaptureAction :: class , 'notify_payment' => Action \ NotifyAction :: class , 'status_payment' => Action \ StatusAction :: class , ] ; foreach ( $ actions as $ name => $ class ) { $ definition = new Definition ( $ class ) ; $ definition -> addTag ( 'payum.action' , [ 'all' => true , 'prepend' => true ] ) ; $ container -> setDefinition ( 'ekyna_commerce.payum.action.' . $ name , $ definition ) ; } }
12146	public function get ( $ name ) { if ( $ this -> exists ( $ name ) ) { $ value = $ this -> settings [ $ name ] ; return $ value ; } return false ; }
12926	public function actionIndex ( $ search ) { $ user = $ this -> finder -> findUserByUsernameOrEmail ( $ search ) ; if ( $ user === null ) { $ this -> stdout ( \ Yii :: t ( 'user' , 'User is not found' ) . "\n" , Console :: FG_RED ) ; } else { if ( $ user -> confirm ( ) ) { $ this -> stdout ( \ Yii :: t ( 'user' , 'User has been confirmed' ) . "\n" , Console :: FG_GREEN ) ; } else { $ this -> stdout ( \ Yii :: t ( 'user' , 'Error occurred while confirming user' ) . "\n" , Console :: FG_RED ) ; } } }
9034	protected function init ( $ key ) { if ( ! isset ( $ this -> files [ $ key ] ) ) { $ this -> files [ $ key ] = fopen ( $ this -> dir . $ key . '.lockfile' , 'w+' ) ; $ this -> owns [ $ key ] = false ; } }
584	protected function loadConfiguration ( $ configFile ) { $ this -> stdout ( "Loading configuration from '{$configFile}'...\n" ) ; $ config = require $ configFile ; foreach ( $ config as $ name => $ value ) { if ( property_exists ( $ this , $ name ) || $ this -> canSetProperty ( $ name ) ) { $ this -> $ name = $ value ; } else { throw new Exception ( "Unknown configuration option: $name" ) ; } } $ this -> getAssetManager ( ) ; }
9479	public function respondWithMessage ( $ message = null ) { $ res [ 'status' ] = $ this -> getStatusText ( ) ; if ( $ this -> getErrorCode ( ) ) { $ res [ 'error' ] = $ this -> getErrorCode ( ) ; if ( is_null ( $ message ) ) $ res [ 'message' ] = $ this -> getErrorMessage ( ) ; else $ res [ 'message' ] = $ message ; } else { $ res [ 'message' ] = $ message ; } return $ this -> respond ( $ res ) ; }
7656	function AddReplyTo ( $ address , $ name = "" ) { $ cur = count ( $ this -> ReplyTo ) ; $ this -> ReplyTo [ $ cur ] [ 0 ] = trim ( $ address ) ; $ this -> ReplyTo [ $ cur ] [ 1 ] = $ name ; }
3388	public function redirectAfterConfirmationPath ( ) { if ( method_exists ( $ this , 'redirectConfirmationTo' ) ) { return $ this -> redirectConfirmationTo ( ) ; } return property_exists ( $ this , 'redirectConfirmationTo' ) ? $ this -> redirectConfirmationTo : route ( 'login' ) ; }
2183	public function create ( ) : ItemInterface { $ tree = $ this -> factory -> createItem ( 'root' ) ; $ this -> eventDispatcher -> dispatch ( ContaoCoreEvents :: BACKEND_MENU_BUILD , new MenuEvent ( $ this -> factory , $ tree ) ) ; return $ tree ; }
2104	public function getTemplates ( ) : array { $ finder = Finder :: create ( ) -> files ( ) -> name ( '*.sql' ) -> in ( $ this -> rootDir . '/templates' ) ; $ templates = [ ] ; foreach ( $ finder as $ file ) { $ templates [ ] = $ file -> getRelativePathname ( ) ; } return $ templates ; }
5923	public function addPropertySet ( $ item ) { if ( ! ( $ item instanceof PropertySet ) ) { if ( is_array ( $ item ) ) { try { $ item = new PropertySet ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate PropertySet. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "PropertySet"!' , E_USER_WARNING ) ; } } $ this -> propertySets [ ] = $ item ; return $ this ; }
1530	public function resource ( string $ resourceType , array $ options = [ ] ) : ResourceRegistration { return new ResourceRegistration ( $ this -> router , $ resourceType , array_merge ( $ this -> options , $ options ) ) ; }
5735	public function getMatchesForTeam ( int $ teamID , array $ filter = [ 'dateFrom' => '' , 'dateTo' => '' , 'status' => '' , 'venue' => '' ] ) { $ matches = $ this -> run ( "v2/teams/{$teamID}/matches" . "?" . http_build_query ( $ filter ) ) ; return collect ( $ matches -> matches ) ; }
10645	public function bindInstance ( object $ object ) : Binding { return $ this -> bind ( \ get_class ( $ object ) ) -> instance ( $ object ) ; }
3955	public function getVariantBase ( ) { if ( $ this -> getMetaModel ( ) -> hasVariants ( ) && ! $ this -> isVariantBase ( ) ) { return $ this -> getMetaModel ( ) -> findById ( $ this -> get ( 'vargroup' ) ) ; } return $ this ; }
942	public function isDryRun ( ) { if ( null === $ this -> isDryRun ) { if ( $ this -> isStdIn ( ) ) { $ this -> isDryRun = true ; } else { $ this -> isDryRun = $ this -> options [ 'dry-run' ] ; } } return $ this -> isDryRun ; }
7476	public function getEntitiesByIds ( $ identifier , array $ values ) { $ accessor = PropertyAccess :: createPropertyAccessor ( ) ; return array_filter ( is_array ( $ this -> entities ) ? $ this -> entities : $ this -> entities -> toArray ( ) , function ( $ entity ) use ( $ identifier , $ values , $ accessor ) { return in_array ( $ accessor -> getValue ( $ entity , $ identifier ) , $ values ) ; } ) ; }
7040	protected function hasDifferentCurrencies ( PaymentSubjectInterface $ subject ) { $ currency = $ subject -> getCurrency ( ) -> getCode ( ) ; foreach ( $ subject -> getPayments ( ) as $ payment ) { if ( $ payment -> getCurrency ( ) -> getCode ( ) !== $ currency ) { return true ; } } return false ; }
2824	public function getExpirationDate ( $ currentDate ) { $ numberOfDays = Mage :: helper ( 'sheep_debug' ) -> getPersistLifetime ( ) ; return date ( self :: DATE_FORMAT , strtotime ( "-{$numberOfDays} days {$currentDate}" ) ) ; }
6967	protected function calculateGoodLines ( Model \ DocumentInterface $ document ) : Amount { $ gross = new Amount ( $ document -> getCurrency ( ) ) ; foreach ( $ document -> getLinesByType ( Model \ DocumentLineTypes :: TYPE_GOOD ) as $ line ) { if ( null !== $ result = $ this -> calculateGoodLine ( $ line ) ) { $ gross -> merge ( $ result ) ; } } $ gross -> copyGrossToUnit ( ) ; return $ gross ; }
4713	public function replace ( $ pattern , $ replacement ) { if ( is_callable ( $ replacement ) ) { $ this -> text = preg_replace_callback ( $ pattern , function ( $ matches ) use ( $ replacement ) { $ args = array_map ( function ( $ item ) { return new Text ( $ item ) ; } , $ matches ) ; return call_user_func_array ( $ replacement , $ args ) ; } , $ this -> text ) ; } else { $ this -> text = preg_replace ( $ pattern , $ replacement , $ this -> text ) ; } return $ this ; }
12896	public function isClosingAfterOpening ( ) { $ diff = $ this -> getOpeningDate ( ) -> diff ( $ this -> getClosingDate ( ) ) ; if ( $ diff -> invert === 0 ) { return true ; } else { return false ; } }
2572	protected function loadSessionHandler ( $ params ) { if ( isset ( $ params [ 'sessionHandler' ] ) && $ params [ 'sessionHandler' ] instanceof Session \ Handler \ HandlerInterface ) { $ this -> sessionHandler = $ params [ 'sessionHandler' ] ; } }
1158	protected function ruleAfter ( $ attribute , array $ parameters ) { if ( ! ( $ date = strtotime ( $ parameters [ 0 ] ) ) ) { $ date = $ this -> getAttributeName ( $ parameters [ 0 ] ) ; } return [ $ attribute , [ $ date ] ] ; }
7461	public function sendPasswordResetEmail ( UserInterface $ user , $ subject = 'Password reset request' ) { $ hashedEntity = $ this -> createHash ( $ user ) ; $ this -> emailHelper -> createAndSendMessageFromTemplate ( 'OrkestraApplicationBundle:Email:setPassword.html.twig' , array ( 'user' => $ user , 'hash' => $ hashedEntity -> getHash ( ) ) , $ subject , $ user -> getEmail ( ) ) ; return $ hashedEntity ; }
2900	public function initFromAction ( $ action ) { if ( ! $ action ) { return ; } $ request = $ action -> getRequest ( ) ; $ this -> httpMethod = $ request -> getMethod ( ) ; $ this -> requestOriginalPath = $ request -> getOriginalPathInfo ( ) ; $ this -> requestPath = $ request -> getPathInfo ( ) ; $ this -> remoteIp = Mage :: helper ( 'core/http' ) -> getRemoteAddr ( ) ; $ this -> routeName = $ request -> getRouteName ( ) ; $ this -> module = $ request -> getControllerModule ( ) ; $ this -> class = get_class ( $ action ) ; $ this -> action = $ action -> getActionMethodName ( $ request -> getActionName ( ) ) ; }
6002	public function setVideotemplates ( array $ videotemplates ) { $ this -> videotemplates = [ ] ; foreach ( $ videotemplates as $ item ) { $ this -> addVideoTemplate ( $ item ) ; } return $ this ; }
4222	public function get ( $ key = null ) { if ( $ key == 'lastError' ) { return isset ( $ this -> data [ 'lastError' ] ) ? $ this -> data [ 'lastError' ] -> getValues ( ) : null ; } if ( isset ( $ this -> data [ $ key ] ) ) { return $ this -> data [ $ key ] ; } if ( isset ( $ this -> { $ key } ) ) { return $ this -> { $ key } ; } return null ; }
1078	public static function executeQuery ( SchemaType $ schema , $ source , $ rootValue = null , $ context = null , $ variableValues = null , ? string $ operationName = null , ? callable $ fieldResolver = null , ? array $ validationRules = null ) : ExecutionResult { $ promiseAdapter = new SyncPromiseAdapter ( ) ; $ promise = self :: promiseToExecute ( $ promiseAdapter , $ schema , $ source , $ rootValue , $ context , $ variableValues , $ operationName , $ fieldResolver , $ validationRules ) ; return $ promiseAdapter -> wait ( $ promise ) ; }
10776	public function fromArray ( array $ array ) { $ root = new Node ( null ) ; $ map = array ( ) ; $ map [ 0 ] = $ root ; foreach ( $ array as $ element ) { if ( 3 !== count ( $ element ) ) { throw new Exception ( 'Each array must have 3 elements.' ) ; } $ map [ $ element [ 0 ] ] = new Node ( $ element [ 2 ] ) ; } foreach ( $ array as $ element ) { if ( empty ( $ element [ 1 ] ) ) { $ element [ 1 ] = 0 ; } $ found = false ; $ i = 0 ; $ keys = array_keys ( $ map ) ; $ cnt = count ( $ keys ) ; while ( ! $ found && $ i < $ cnt ) { if ( $ keys [ $ i ] === $ element [ 1 ] ) { $ map [ $ keys [ $ i ] ] -> addChild ( $ map [ $ element [ 0 ] ] ) ; $ found = true ; } else { $ i ++ ; } } if ( ! $ found ) { throw new Exception ( 'Data structure does not seem to be consistent. ' . 'Key "' . $ element [ 1 ] . '" could not be found.' ) ; } } return $ root ; }
11373	public function createPublicMethodInjection ( \ ReflectionMethod $ method ) : MethodInjection { $ injections = [ ] ; foreach ( $ method -> getParameters ( ) as $ parameter ) { $ injections [ ] = new ParameterInjection ( $ parameter -> getName ( ) , ( string ) $ parameter -> getType ( ) , $ parameter -> isArray ( ) , $ this -> getInjectHint ( $ method , $ parameter ) ) ; } return new MethodInjection ( $ injections , $ method -> getName ( ) ) ; }
11154	public function getArrayKeyByPowers ( array $ powers ) { if ( empty ( $ powers ) ) { throw new InvalidArgumentException ( 'Empty powers set' ) ; } $ powersSum = 0 ; foreach ( $ powers as $ power ) { if ( $ power < 0 ) { throw new InvalidArgumentException ( 'Negative power found' ) ; } $ powersSum += $ power ; } if ( $ powersSum <= 0 ) { throw new InvalidArgumentException ( 'The sum of powers must be positive' ) ; } $ randomValue = $ this -> generator -> getFloat ( 0 , $ powersSum ) ; $ currentSum = 0 ; $ result = null ; foreach ( $ powers as $ key => $ power ) { $ currentSum += $ power ; if ( $ currentSum >= $ randomValue ) { $ result = $ key ; break ; } } return $ key ; }
9703	private function addColor ( $ rgb ) { if ( ! isset ( $ this -> colors [ $ rgb ] ) ) { $ color = [ hexdec ( substr ( $ rgb , 0 , 2 ) ) , hexdec ( substr ( $ rgb , 2 , 2 ) ) , hexdec ( substr ( $ rgb , 4 ) ) , 0 , ] ; $ colorIndex = array_search ( $ color , $ this -> palette ) ; if ( $ colorIndex ) { $ this -> colors [ $ rgb ] = $ colorIndex ; } else { if ( count ( $ this -> colors ) == 0 ) { $ lastColor = 7 ; } else { $ lastColor = end ( $ this -> colors ) ; } if ( $ lastColor < 57 ) { $ colorIndex = $ lastColor + 1 ; $ this -> palette [ $ colorIndex ] = $ color ; $ this -> colors [ $ rgb ] = $ colorIndex ; } else { $ colorIndex = 0 ; } } } else { $ colorIndex = $ this -> colors [ $ rgb ] ; } return $ colorIndex ; }
9136	public function clearTag ( $ name ) { if ( isset ( $ this -> tags [ $ name ] ) ) { unset ( $ this -> tags [ $ name ] ) ; } return $ this ; }
1527	protected function doReplaceRelationship ( StoreInterface $ store , UpdateRelationship $ request ) { $ record = $ request -> getRecord ( ) ; $ name = Str :: classify ( $ field = $ request -> getRelationshipName ( ) ) ; if ( $ result = $ this -> invokeMany ( [ 'replacing' , "replacing{$name}" ] , $ record , $ request ) ) { return $ result ; } $ record = $ store -> replaceRelationship ( $ record , $ field , $ request -> all ( ) , $ request -> getParameters ( ) ) ; return $ this -> invokeMany ( [ "replaced{$name}" , "replaced" ] , $ record , $ request ) ? : $ record ; }
1603	private function _getVariables ( ) { $ variables = $ this -> _overrideObject ; if ( $ this -> _element !== null ) { foreach ( $ this -> _element -> attributes ( ) as $ name ) if ( $ name !== $ this -> _handle ) $ variables [ $ name ] = $ this -> _element -> $ name ; $ variables = array_merge ( $ variables , $ this -> _element -> toArray ( $ this -> _element -> extraFields ( ) ) ) ; } return $ variables ; }
1768	public function listNewsArticles ( $ arrRow ) { return '<div class="tl_content_left">' . $ arrRow [ 'headline' ] . ' <span style="color:#999;padding-left:3px">[' . Contao \ Date :: parse ( Contao \ Config :: get ( 'datimFormat' ) , $ arrRow [ 'date' ] ) . ']</span></div>' ; }
2395	public function close ( ) { $ arrArchive [ 'archive_signature' ] = self :: CENTRAL_DIR_END ; $ arrArchive [ 'number_of_this_disk' ] = "\x00\x00" ; $ arrArchive [ 'number_of_disk_with_cd' ] = "\x00\x00" ; $ arrArchive [ 'total_cd_entries_disk' ] = pack ( 'v' , $ this -> intCount ) ; $ arrArchive [ 'total_cd_entries' ] = pack ( 'v' , $ this -> intCount ) ; $ arrArchive [ 'size_of_cd' ] = pack ( 'V' , \ strlen ( $ this -> strCentralDir ) ) ; $ arrArchive [ 'offset_start_cd' ] = pack ( 'V' , @ ftell ( $ this -> resFile ) ) ; $ arrArchive [ 'zipfile_comment_length' ] = "\x00\x00" ; $ arrArchive [ 'zipfile_comment' ] = '' ; fwrite ( $ this -> resFile , $ this -> strCentralDir ) ; fwrite ( $ this -> resFile , implode ( '' , $ arrArchive ) ) ; fclose ( $ this -> resFile ) ; if ( ! file_exists ( $ this -> strRootDir . '/' . $ this -> strFile ) ) { if ( ( $ strFolder = \ dirname ( $ this -> strFile ) ) == '.' ) { $ strFolder = '' ; } if ( ! is_dir ( $ this -> strRootDir . '/' . $ strFolder ) ) { new Folder ( $ strFolder ) ; } } Files :: getInstance ( ) -> rename ( self :: TEMPORARY_FOLDER . '/' . basename ( $ this -> strTemp ) , $ this -> strFile ) ; }
2060	public function scheduleUpdate ( Contao \ DataContainer $ dc ) { if ( ! $ dc -> activeRecord || ! $ dc -> activeRecord -> id || Contao \ Input :: get ( 'act' ) == 'copy' ) { return ; } $ objSession = Contao \ System :: getContainer ( ) -> get ( 'session' ) ; $ session = $ objSession -> get ( 'sitemap_updater' ) ; $ session [ ] = Contao \ PageModel :: findWithDetails ( $ dc -> activeRecord -> id ) -> rootId ; $ objSession -> set ( 'sitemap_updater' , array_unique ( $ session ) ) ; }
9323	protected function registerMarkdownParser ( ) { $ app = $ this -> app ; $ app -> singleton ( 'commonmark.docparser' , function ( $ app ) { $ environment = $ app [ 'commonmark.environment' ] ; return new DocParser ( $ environment ) ; } ) ; $ app -> alias ( 'commonmark.docparser' , DocParser :: class ) ; }
11706	public function storageValidate ( $ validators , $ storage ) { $ errors = [ ] ; foreach ( $ validators as $ kValidate => $ validate ) { if ( ! isset ( $ storage [ $ kValidate ] ) ) { $ errors [ ] = [ 'field' => $ kValidate , 'message' => 'Value ' . $ kValidate . ' not found.' ] ; continue ; } $ error = $ this -> validate ( $ validate , $ storage [ $ kValidate ] ) ; if ( $ error ) $ errors [ ] = [ 'field' => $ kValidate , 'message' => $ error ] ; } return $ errors ; }
4120	public static function overrideType ( $ name , $ className ) { if ( ! isset ( self :: $ _typesMap [ $ name ] ) ) { throw TypeException :: typeNotFound ( $ name ) ; } self :: $ _typesMap [ $ name ] = $ className ; }
6865	protected function updateCustomerBalance ( InvoiceInterface $ invoice ) { if ( ! InvoiceTypes :: isCredit ( $ invoice ) ) { return ; } $ sale = $ this -> getSaleFromInvoice ( $ invoice ) ; if ( null === $ customer = $ sale -> getCustomer ( ) ) { return ; } $ methodCs = $ this -> persistenceHelper -> getChangeSet ( $ invoice , 'paymentMethod' ) ; $ amountCs = $ this -> persistenceHelper -> getChangeSet ( $ invoice , 'grandTotal' ) ; if ( $ this -> persistenceHelper -> isScheduledForRemove ( $ invoice ) ) { $ method = empty ( $ methodCs ) ? $ invoice -> getPaymentMethod ( ) : $ methodCs [ 0 ] ; $ amount = empty ( $ amountCs ) ? $ invoice -> getGrandTotal ( ) : $ amountCs [ 0 ] ; if ( $ method && $ method -> isCredit ( ) && 0 != Money :: compare ( $ amount , 0 , $ invoice -> getCurrency ( ) ) ) { $ this -> customerUpdater -> updateCreditBalance ( $ customer , - $ amount , true ) ; } return ; } if ( empty ( $ methodCs ) && empty ( $ amountCs ) ) { return ; } if ( ! empty ( $ methodCs ) && null !== $ method = $ methodCs [ 0 ] ) { $ amount = empty ( $ amountCs ) ? $ invoice -> getGrandTotal ( ) : $ amountCs [ 0 ] ; if ( $ method -> isCredit ( ) && 0 != Money :: compare ( $ amount , 0 , $ invoice -> getCurrency ( ) ) ) { $ this -> customerUpdater -> updateCreditBalance ( $ customer , - $ amount , true ) ; } } if ( empty ( $ methodCs ) ) { $ method = $ invoice -> getPaymentMethod ( ) ; $ amount = empty ( $ amountCs ) ? $ invoice -> getGrandTotal ( ) : $ amountCs [ 1 ] - $ amountCs [ 0 ] ; } else { $ method = $ methodCs [ 1 ] ; $ amount = empty ( $ amountCs ) ? $ invoice -> getGrandTotal ( ) : $ amountCs [ 1 ] ; } if ( $ method && $ method -> isCredit ( ) && 0 != Money :: compare ( $ amount , 0 , $ invoice -> getCurrency ( ) ) ) { $ this -> customerUpdater -> updateCreditBalance ( $ customer , $ amount , true ) ; } }
8146	public function parse ( Twig_TokenStream $ stream ) { if ( null === $ this -> parser ) { $ this -> parser = new Twig_Parser ( $ this ) ; } return $ this -> parser -> parse ( $ stream ) ; }
949	public function sanitizeShopDomain ( $ domain ) { if ( empty ( $ domain ) ) { return ; } $ configEndDomain = Config :: get ( 'shopify-app.myshopify_domain' ) ; $ domain = strtolower ( preg_replace ( '/https?:\/\//i' , '' , trim ( $ domain ) ) ) ; if ( strpos ( $ domain , $ configEndDomain ) === false && strpos ( $ domain , '.' ) === false ) { $ domain .= ".{$configEndDomain}" ; } return parse_url ( "http://{$domain}" , PHP_URL_HOST ) ; }
4343	protected function popStack ( ) { $ stackInfo = \ array_pop ( $ this -> funcStack ) ; $ funcPopped = $ stackInfo [ 'function' ] ; $ timeElapsed = \ microtime ( true ) - $ stackInfo [ 'tsStart' ] ; $ this -> data [ $ funcPopped ] [ 'ownTime' ] += $ timeElapsed - $ stackInfo [ 'subTime' ] ; $ this -> data [ $ funcPopped ] [ 'totalTime' ] += $ timeElapsed ; if ( $ this -> data [ $ funcPopped ] [ 'calls' ] === 0 ) { $ this -> data [ $ funcPopped ] [ 'calls' ] ++ ; } if ( $ this -> funcStack ) { $ this -> funcStack [ \ count ( $ this -> funcStack ) - 1 ] [ 'subTime' ] += $ timeElapsed ; } return $ stackInfo [ 'function' ] ; }
3988	public function getChildrenOf ( $ parentTable ) { $ inputScreens = array_filter ( $ this -> getInputScreens ( ) , function ( $ inputScreen ) use ( $ parentTable ) { return ( $ inputScreen [ 'meta' ] [ 'rendertype' ] === 'ctable' ) && ( $ inputScreen [ 'meta' ] [ 'ptable' ] === $ parentTable ) ; } ) ; return $ inputScreens ; }
1407	protected function getModelAttributes ( Model $ model ) { $ attributes = [ ] ; foreach ( $ this -> attributeKeys ( $ model ) as $ modelKey => $ field ) { if ( is_numeric ( $ modelKey ) ) { $ modelKey = $ field ; $ field = $ this -> fieldForAttribute ( $ field ) ; } $ attributes [ $ field ] = $ this -> extractAttribute ( $ model , $ modelKey , $ field ) ; } return $ attributes ; }
1383	protected function dataGet ( $ key , $ default = null ) { if ( ! isset ( $ this -> document -> data ) ) { return $ default ; } return data_get ( $ this -> document -> data , $ key , $ default ) ; }
795	public function load ( $ data , $ formName = null ) { $ scope = $ formName === null ? $ this -> formName ( ) : $ formName ; if ( $ scope === '' && ! empty ( $ data ) ) { $ this -> setAttributes ( $ data ) ; return true ; } elseif ( isset ( $ data [ $ scope ] ) ) { $ this -> setAttributes ( $ data [ $ scope ] ) ; return true ; } return false ; }
6870	protected function buildPaymentList ( PM \ PaymentSubjectInterface $ subject ) { $ payments = array_filter ( $ subject -> getPayments ( ) -> toArray ( ) , function ( PM \ PaymentInterface $ p ) { if ( $ p -> getMethod ( ) -> isOutstanding ( ) ) { return false ; } if ( ! PM \ PaymentStates :: isPaidState ( $ p -> getState ( ) ) ) { return false ; } return true ; } ) ; usort ( $ payments , function ( PM \ PaymentInterface $ a , PM \ PaymentInterface $ b ) { return $ a -> getCompletedAt ( ) -> getTimestamp ( ) - $ b -> getCompletedAt ( ) -> getTimestamp ( ) ; } ) ; return array_map ( function ( PM \ PaymentInterface $ payment ) { return [ 'payment' => $ payment , 'amount' => $ payment -> getAmount ( ) , ] ; } , $ payments ) ; }
4219	private function clearSummary ( $ flags ) { $ return = null ; $ clearErrors = $ flags & Debug :: CLEAR_SUMMARY_ERRORS ; if ( $ flags & Debug :: CLEAR_SUMMARY ) { $ return = 'summary (' . ( $ clearErrors ? 'incl errors' : 'sans errors' ) . ')' ; $ curPriority = \ end ( $ this -> data [ 'groupPriorityStack' ] ) ; foreach ( \ array_keys ( $ this -> data [ 'logSummary' ] ) as $ priority ) { $ entriesKeep = array ( ) ; if ( $ priority === $ curPriority ) { $ curDepth = 0 ; foreach ( $ this -> data [ 'groupStacks' ] [ $ priority ] as $ group ) { $ curDepth += ( int ) $ group [ 'collect' ] ; } $ entriesKeep = $ this -> debug -> internal -> getCurrentGroups ( $ this -> data [ 'logSummary' ] [ $ priority ] , $ curDepth ) ; } else { $ this -> data [ 'groupStacks' ] [ $ priority ] = array ( ) ; } $ this -> clearLogHelper ( $ this -> data [ 'logSummary' ] [ $ priority ] , $ clearErrors , $ entriesKeep ) ; } } elseif ( $ clearErrors ) { $ return = 'summary errors' ; } return $ return ; }
1692	protected function shortenHexColor ( $ color ) { if ( $ color [ 0 ] == $ color [ 1 ] && $ color [ 2 ] == $ color [ 3 ] && $ color [ 4 ] == $ color [ 5 ] ) { return $ color [ 0 ] . $ color [ 2 ] . $ color [ 4 ] ; } return $ color ; }
3610	public function getDeviceSchedule ( $ serial_number = NULL ) { $ this -> prepareForGet ( ) ; $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ schedule_days = $ this -> last_status -> schedule -> { $ serial_number } -> days ; $ schedule = array ( ) ; foreach ( ( array ) $ schedule_days as $ day => $ scheduled_events ) { $ events = array ( ) ; foreach ( $ scheduled_events as $ scheduled_event ) { if ( $ scheduled_event -> entry_type == 'setpoint' ) { $ events [ ( int ) $ scheduled_event -> time ] = ( object ) array ( 'time' => $ scheduled_event -> time / 60 , 'target_temperature' => $ scheduled_event -> type == 'RANGE' ? array ( $ this -> temperatureInUserScale ( ( float ) $ scheduled_event -> { 'temp-min' } ) , $ this -> temperatureInUserScale ( ( float ) $ scheduled_event -> { 'temp-max' } ) ) : $ this -> temperatureInUserScale ( ( float ) $ scheduled_event -> temp ) , 'mode' => $ scheduled_event -> type == 'HEAT' ? TARGET_TEMP_MODE_HEAT : ( $ scheduled_event -> type == 'COOL' ? TARGET_TEMP_MODE_COOL : TARGET_TEMP_MODE_RANGE ) ) ; } } if ( ! empty ( $ events ) ) { ksort ( $ events ) ; $ schedule [ ( int ) $ day ] = array_values ( $ events ) ; } } ksort ( $ schedule ) ; $ sorted_schedule = array ( ) ; foreach ( $ schedule as $ day => $ events ) { $ sorted_schedule [ $ this -> days_maps [ ( int ) $ day ] ] = $ events ; } return $ sorted_schedule ; }
7784	public function addParser ( $ name , $ class , $ before = null ) { if ( $ before === null ) { $ this -> parsers [ $ name ] = $ class ; return $ this ; } if ( ( $ offset = array_search ( $ before , array_keys ( $ this -> parsers ) ) ) !== false ) { $ this -> parsers = array_slice ( $ this -> parsers , 0 , $ offset , true ) + array ( $ name => $ class ) + array_slice ( $ this -> parsers , $ offset , null , true ) ; return $ this ; } throw new \ RuntimeException ( sprintf ( 'Parser "%s" does not exist.' , $ before ) ) ; }
2368	public static function extractEmail ( $ strString , $ strAllowedTags = '' ) { $ arrEmails = array ( ) ; if ( strpos ( $ strString , '@' ) === false ) { return $ arrEmails ; } preg_match_all ( '/mailto:(?:[^\x00-\x20\x22\x40\x7F]{1,64}+|\x22[^\x00-\x1F\x7F]{1,64}?\x22)@(?:\[(?:IPv)?[a-f0-9.:]{1,47}\]|[\w.-]{1,252}\.[a-z]{2,63}\b)/u' , $ strString , $ matches ) ; foreach ( $ matches [ 0 ] as & $ strEmail ) { $ strEmail = str_replace ( 'mailto:' , '' , $ strEmail ) ; if ( Validator :: isEmail ( $ strEmail ) ) { $ arrEmails [ ] = $ strEmail ; } } unset ( $ strEmail ) ; $ strString = preg_replace_callback ( '@</?([^\s<>/]*)@' , function ( $ matches ) use ( $ strAllowedTags ) { if ( $ matches [ 1 ] == '' || stripos ( $ strAllowedTags , '<' . strtolower ( $ matches [ 1 ] ) . '>' ) === false ) { $ matches [ 0 ] = str_replace ( '<' , '&lt;' , $ matches [ 0 ] ) ; } return $ matches [ 0 ] ; } , $ strString ) ; preg_match_all ( '/(?:[^\x00-\x20\x22\x40\x7F]{1,64}|\x22[^\x00-\x1F\x7F]{1,64}?\x22)@(?:\[(?:IPv)?[a-f0-9.:]{1,47}\]|[\w.-]{1,252}\.[a-z]{2,63}\b)/u' , strip_tags ( $ strString ) , $ matches ) ; foreach ( $ matches [ 0 ] as & $ strEmail ) { $ strEmail = str_replace ( '&lt;' , '<' , $ strEmail ) ; if ( Validator :: isEmail ( $ strEmail ) ) { $ arrEmails [ ] = $ strEmail ; } } return array_unique ( $ arrEmails ) ; }
11957	public function add ( $ renderer , $ name = null ) { if ( is_null ( $ name ) ) { $ name = $ renderer ; } $ this -> renderers [ $ name ] = $ renderer ; }
963	public function postProcess ( ) { if ( ! $ this -> shop -> trashed ( ) ) { return ; } $ this -> shop -> restore ( ) ; $ this -> shop -> charges ( ) -> restore ( ) ; $ this -> shop -> save ( ) ; }
8037	public static function revert ( $ input , $ inputFormat = Code :: FORMAT_ALNUM , $ minLength = null ) { $ number = self :: convertBase ( $ input , $ inputFormat , Code :: FORMAT_NUMBER ) ; if ( is_int ( $ minLength ) ) { $ number -= self :: getMinForlength ( $ inputFormat , $ minLength ) ; } return $ number ; }
8925	public function mapJson ( $ json , $ targetClass ) { if ( ! is_array ( $ data = json_decode ( $ json , true ) ) ) { throw new InvalidJsonException ( ) ; } $ result = null ; if ( substr ( $ targetClass , - 2 ) == '[]' ) { $ result = [ ] ; foreach ( $ data as $ key => $ entryData ) { $ result [ ] = $ this -> mapDataToObject ( $ entryData , substr ( $ targetClass , 0 , - 2 ) ) ; } } else { $ result = $ this -> mapDataToObject ( $ data , $ targetClass ) ; } return $ result ; }
5124	private function castToArray ( $ input ) : array { $ result = array ( ) ; foreach ( $ input as $ key => $ value ) { $ result [ $ key ] = $ this -> castValue ( $ value ) ; } return $ result ; }
4756	public function transform ( $ value ) { if ( $ value instanceof \ Traversable || is_array ( $ value ) ) { return $ this -> transformIterable ( $ value ) ; } if ( is_bool ( $ value ) ) { return $ this -> transformBoolean ( $ value ) ; } if ( is_scalar ( $ value ) || ( is_object ( $ value ) && method_exists ( $ value , '__toString' ) ) ) { return $ value ; } if ( $ value instanceof Cache ) { return $ this -> transformCacheAnnotation ( $ value ) ; } if ( $ value instanceof Method ) { return $ this -> transformMethodAnnotation ( $ value ) ; } if ( $ value instanceof ParamConverter ) { return $ this -> transformParamConverter ( $ value ) ; } if ( $ value instanceof Security ) { return $ this -> transformSecurity ( $ value ) ; } if ( $ value instanceof Template ) { return $ this -> transformTemplate ( $ value ) ; } return get_class ( $ value ) ; }
7641	protected function getErrorMessage ( $ response , $ alternativeError = 'Unknown error.' ) { $ xml = $ this -> parseResponse ( $ response ) ; if ( $ xml && $ xml -> Message ) { return "[" . $ response -> getStatusCode ( ) . "] " . ( string ) $ xml -> Message . "\n" . ( string ) $ xml -> AuthenticationErrorDetail ; } else { return $ alternativeError ; } }
1079	public static function enable ( $ enable = true ) { if ( $ enable === true ) { self :: $ enableWarnings = self :: ALL ; } elseif ( $ enable === false ) { self :: $ enableWarnings = 0 ; } else { self :: $ enableWarnings |= $ enable ; } }
5599	public function tally ( ) { while ( list ( $ severity , $ message , $ file , $ line ) = $ this -> extract ( ) ) { $ severity = $ this -> getSeverityAsString ( $ severity ) ; $ this -> test -> error ( $ severity , $ message , $ file , $ line ) ; } while ( list ( $ expected , $ message ) = $ this -> extractExpectation ( ) ) { $ this -> test -> assert ( $ expected , false , '%s -> Expected error not caught' ) ; } }
5862	protected function expandValuesInRuleset ( array $ ruleset ) { $ values = [ ] ; foreach ( $ ruleset as $ key => $ value ) { switch ( $ key ) { case 'usergroup' : $ value = GeneralUtility :: trimExplode ( ',' , $ value , true ) ; break ; case 'directories' : $ values [ 'directories_config' ] = '' ; $ value = GeneralUtility :: trimExplode ( ',' , $ value , true ) ; foreach ( $ value as & $ directory ) { $ directory = rtrim ( $ directory , '/' ) . '/' ; if ( ! empty ( $ values [ 'directories_config' ] ) ) { $ values [ 'directories_config' ] .= ',' ; } $ values [ 'directories_config' ] .= $ directory ; $ directory = $ this -> getDirectoryPattern ( $ directory ) ; } if ( count ( $ value ) == 0 ) { $ value = '' ; } break ; case 'file_types' : $ value = GeneralUtility :: trimExplode ( ',' , $ value , true ) ; if ( count ( $ value ) == 0 ) { $ value = '' ; } break ; case 'threshold' : if ( ! is_numeric ( $ value ) ) { $ unit = strtoupper ( substr ( $ value , - 1 ) ) ; $ factor = 1 * ( $ unit === 'K' ? 1024 : ( $ unit === 'M' ? 1024 * 1024 : 0 ) ) ; $ value = intval ( trim ( substr ( $ value , 0 , strlen ( $ value ) - 1 ) ) ) * $ factor ; } case 'max_width' : case 'max_height' : if ( $ value <= 0 ) { $ value = '' ; } break ; case 'max_size' : if ( ! is_numeric ( $ value ) ) { $ unit = strtoupper ( substr ( $ value , - 1 ) ) ; $ factor = 1 * ( $ unit === 'M' ? 1000000 : 1 ) ; $ value = intval ( trim ( substr ( $ value , 0 , strlen ( $ value ) - 1 ) ) ) * $ factor ; } break ; case 'conversion_mapping' : if ( strpos ( $ value , CRLF ) !== false ) { $ mapping = GeneralUtility :: trimExplode ( CRLF , $ value , true ) ; } else { $ mapping = GeneralUtility :: trimExplode ( ',' , $ value , true ) ; } if ( count ( $ mapping ) > 0 ) { $ value = $ this -> expandConversionMapping ( $ mapping ) ; } else { $ value = '' ; } break ; } $ values [ $ key ] = $ value ; } return $ values ; }
10015	public function setActiveSheetIndexByName ( $ pValue ) { if ( ( $ worksheet = $ this -> getSheetByName ( $ pValue ) ) instanceof Worksheet ) { $ this -> setActiveSheetIndex ( $ this -> getIndex ( $ worksheet ) ) ; return $ worksheet ; } throw new Exception ( 'Workbook does not contain sheet:' . $ pValue ) ; }
12578	public function previewVoiceByName ( $ message , $ to ) { return $ this -> preview ( self :: MSG_TYPE_VOICE , $ message , $ to , self :: PREVIEW_BY_NAME ) ; }
11081	public static function GUIDv4 ( ) { return sprintf ( '%04x%04x-%04x-%04x-%04x-%04x%04x%04x' , mt_rand ( 0 , 0xffff ) , mt_rand ( 0 , 0xffff ) , mt_rand ( 0 , 0xffff ) , mt_rand ( 0 , 0x0fff ) | 0x4000 , mt_rand ( 0 , 0x3fff ) | 0x8000 , mt_rand ( 0 , 0xffff ) , mt_rand ( 0 , 0xffff ) , mt_rand ( 0 , 0xffff ) ) ; }
9377	protected function extract ( $ filepath , array $ data ) { extract ( $ data ) ; ob_start ( ) ; include $ filepath ; $ contents = ob_get_contents ( ) ; ob_end_clean ( ) ; return $ contents ; }
12685	public function removeFromDB ( ) { if ( is_null ( $ this -> result ) ) { $ this -> fetchData ( ) ; } if ( count ( $ this -> result ) > 0 ) { if ( ! $ this -> result [ 0 ] instanceof Web2All_Table_SaveObject ) { throw new Exception ( "Web2All_Table_ObjectList->removeFromDB: Not a saveobject, you can't delete a non saveobject." ) ; } foreach ( $ this -> result as $ row ) { $ row -> deleteFromDB ( ) ; } } }
12798	public function getLines ( $ lazy = true , $ raw = false ) { if ( is_null ( $ this -> _lines ) ) { $ file = $ this -> filePointer ; if ( ! $ file ) { return false ; } rewind ( $ file ) ; $ this -> _lines = [ ] ; $ currentLineNumber = 0 ; while ( ( $ buffer = fgetcsv ( $ this -> filePointer , 0 , $ this -> delimeter ) ) !== false ) { $ currentLineNumber ++ ; if ( $ currentLineNumber <= $ this -> skipLines ) { continue ; } $ line = Yii :: createObject ( [ 'class' => SourceFileLine :: className ( ) , 'sourceFile' => $ this , 'lineNumber' => $ currentLineNumber - 1 , 'content' => $ buffer ] ) ; if ( $ this -> testIgnore ( $ line ) ) { continue ; } $ lineId = $ line -> id ; if ( ! isset ( $ lineId ) ) { continue ; } $ this -> _lines [ $ lineId ] = $ line ; if ( $ lazy ) { $ line -> clean ( ) ; } } } return $ this -> _lines ; }
7159	protected function compileKeyboard ( Keyboard $ keyboard ) { $ firstButton = collect ( $ keyboard -> getButtons ( ) ) -> first ( ) ; if ( $ firstButton instanceof PayloadButton || $ firstButton instanceof UrlButton ) { return $ this -> compileInlineKeyboard ( $ keyboard ) ; } return $ this -> compileReplyKeyboard ( $ keyboard ) ; }
3587	protected function getMetaWhereConstraint ( $ method , ArgumentBag $ args ) { $ column = $ args -> get ( 'column' ) ; $ args -> set ( 'column' , 'meta_value' ) ; if ( $ method === 'whereBetween' ) { return $ this -> getMetaBetweenConstraint ( $ column , $ args -> get ( 'values' ) ) ; } return function ( $ query ) use ( $ column , $ method , $ args ) { $ query -> where ( 'meta_key' , $ column ) ; if ( $ args -> get ( 'value' ) || $ args -> get ( 'values' ) ) { call_user_func_array ( [ $ query , $ method ] , $ args -> all ( ) ) ; } } ; }
3819	private function checkboxCaption ( $ key , $ table , IAttribute $ attribute ) { return $ this -> translator -> trans ( $ table . '.' . $ key , [ $ attribute -> getName ( ) ] , 'contao_' . $ table ) ; }
4474	public function perform ( ) : bool { try { $ instance = $ this -> getInstance ( ) ; if ( method_exists ( $ instance , 'setUp' ) ) { $ instance -> setUp ( ) ; } $ this -> getEventsManager ( ) -> fire ( new JobEvent \ BeforePerform ( $ this , $ this ) ) ; $ performMethod = $ this -> getPerformMethod ( ) ; $ instance -> $ performMethod ( $ this ) ; $ this -> getEventsManager ( ) -> fire ( new JobEvent \ AfterPerform ( $ this , $ this ) ) ; if ( method_exists ( $ instance , 'tearDown' ) ) { $ instance -> tearDown ( ) ; } } catch ( \ Throwable $ e ) { $ this -> fail ( 'system:fatal' , sprintf ( '%s: %s in %s on line %d' , get_class ( $ e ) , $ e -> getMessage ( ) , $ e -> getFile ( ) , $ e -> getLine ( ) ) ) ; return false ; } return true ; }
11643	public function getFormatter ( ) { if ( $ this -> _formatter === null ) { $ this -> _formatter = Yii :: $ app -> format ; } return $ this -> _formatter ; }
1494	public static function fromArray ( iterable $ config , string $ urlPrefix = null ) : self { return new self ( ... collect ( $ config ) -> map ( function ( $ value , $ key ) use ( $ urlPrefix ) { return Encoding :: fromArray ( $ key , $ value , $ urlPrefix ) ; } ) -> values ( ) ) ; }
8379	public function getNested ( $ keyString , $ default = null , $ separator = '.' ) { $ keys = explode ( $ separator , $ keyString ) ; $ data = $ this -> array ; foreach ( $ keys as $ key ) { if ( ! is_array ( $ data ) or ! array_key_exists ( $ key , $ data ) ) { return $ default ; } $ data = $ data [ $ key ] ; } return $ data ; }
11828	public function setUri ( $ uri ) { if ( ! empty ( $ uri ) && ! is_file ( $ uri ) ) { throw new \ Exception ( sprintf ( 'File %s not found.' , $ uri ) ) ; } $ this -> uri = $ uri ; return $ this ; }
12063	public function can_save_post_meta ( $ post_id , $ action , $ nonce ) { $ is_autosave = wp_is_post_autosave ( $ post_id ) ; $ is_revision = wp_is_post_revision ( $ post_id ) ; $ is_valid_nonce = ( isset ( $ _POST [ $ nonce ] ) && wp_verify_nonce ( $ _POST [ $ nonce ] , $ action ) ) ; return ! ( $ is_autosave || $ is_revision ) && $ is_valid_nonce ; }
5518	public function invoke ( $ method , $ args ) { $ method = strtolower ( $ method ) ; $ step = $ this -> getCallCount ( $ method ) ; $ this -> addCall ( $ method , $ args ) ; $ this -> checkExpectations ( $ method , $ args , $ step ) ; $ was = $ this -> disableEStrict ( ) ; try { $ result = $ this -> emulateCall ( $ method , $ args , $ step ) ; } catch ( Exception $ e ) { $ this -> restoreEStrict ( $ was ) ; throw $ e ; } $ this -> restoreEStrict ( $ was ) ; return $ result ; }
4060	public static function compare ( $ expected , $ actual , $ strict = true ) { try { self :: calculateDiff ( $ expected , $ actual , $ strict ) ; } catch ( \ Exception $ exception ) { $ instance = new DifferentValuesException ( $ expected , $ actual , $ strict , 'The values differ.' , 0 , $ exception ) ; throw $ instance ; } }
12813	private static function getNullables ( string $ table ) : array { if ( self :: $ nullablesCache !== null && array_key_exists ( $ table , self :: $ nullablesCache ) ) return self :: $ nullablesCache [ $ table ] ; $ pdo = Database :: connect ( ) ; $ query = " SELECT column_name, data_type, is_nullable, column_default FROM information_schema.columns WHERE table_name = '$table' AND is_nullable = 'YES' " ; self :: $ nullablesCache [ $ table ] = [ ] ; $ rows = $ pdo -> query ( $ query ) ; while ( $ row = $ rows -> fetch ( ) ) self :: $ nullablesCache [ $ table ] [ $ row [ "column_name" ] ] = $ row ; return self :: $ nullablesCache [ $ table ] ; }
4853	public function getCurrentRealRows ( $ table = null ) { $ table = $ table ? : $ this -> getCurrentTable ( ) ; if ( ! isset ( $ this -> currentRealRows [ $ table ] ) || ! $ this -> currentRealRows [ $ table ] ) { $ fields = $ this -> getPreparedFields ( ) [ $ table ] ; $ this -> currentRealRows [ $ table ] = $ this -> getRealRow ( $ fields , $ table ) ; } return $ this -> currentRealRows [ $ table ] ; }
6995	public static function parseApplePriceMatrix ( $ dom , $ currency , $ directory = null ) { if ( is_string ( $ dom ) ) { if ( file_exists ( $ dom ) && is_file ( $ dom ) ) { $ file = $ dom ; $ dom = new \ DOMDocument ( ) ; $ dom -> loadHTMLFile ( $ file ) ; unset ( $ file ) ; } else { $ content = $ dom ; $ dom = new \ DOMDocument ( ) ; $ dom -> loadHTML ( $ content ) ; unset ( $ content ) ; } } if ( ! $ dom instanceof \ DOMDocument ) { throw new \ InvalidArgumentException ( sprintf ( 'The first argument must be a DOMDocument instance or path to ApplePriceMatrix file, "%s" given.' , is_object ( $ dom ) ? get_class ( $ dom ) : gettype ( $ dom ) ) ) ; } $ currency = strtoupper ( $ currency ) ; $ xpath = new \ DOMXPath ( $ dom ) ; $ tierPrimary = static :: parseApplePriceMatrixTier ( $ xpath , 1 , $ currency ) ; $ tierAlternative = static :: parseApplePriceMatrixTier ( $ xpath , 2 , $ currency ) ; $ prices = $ tierPrimary + $ tierAlternative ; ksort ( $ prices ) ; if ( $ directory ) { if ( ! is_writable ( $ directory ) ) { throw new \ RuntimeException ( sprintf ( 'Could not write prices map to directory "%s". Directory is not writable.' , $ directory ) ) ; } $ file = $ directory . '/' . $ currency . '.php' ; file_put_contents ( $ file , '<?php return ' . var_export ( $ prices , 1 ) . ';' ) ; } return $ prices ; }
12684	public function offsetSet ( $ offset , $ value ) { if ( is_null ( $ this -> result ) ) { $ this -> fetchData ( ) ; } if ( ! $ this -> isFetched ( ) ) { trigger_error ( 'Web2All_Table_ObjectList::offsetSet: cannot set value on unitialized list' , E_USER_NOTICE ) ; return false ; } if ( ! $ this -> is_assoc && ! is_numeric ( $ value ) ) { trigger_error ( 'Web2All_Table_ObjectList::offsetSet: can only set numeric keys non assoc lists' , E_USER_NOTICE ) ; return false ; } if ( $ value instanceof $ this -> classname ) { $ this -> result [ $ offset ] = $ value ; } else { trigger_error ( 'Web2All_Table_ObjectList::offsetSet: can only add objects of type ' . $ this -> classname . ' to the list' , E_USER_NOTICE ) ; return false ; } }
1765	public function colorize ( $ row , $ label ) { switch ( $ row [ 'action' ] ) { case 'CONFIGURATION' : case 'REPOSITORY' : $ label = preg_replace ( '@^(.*</span> )(.*)$@U' , '$1 <span class="tl_blue">$2</span>' , $ label ) ; break ; case 'CRON' : $ label = preg_replace ( '@^(.*</span> )(.*)$@U' , '$1 <span class="tl_green">$2</span>' , $ label ) ; break ; case 'ERROR' : $ label = preg_replace ( '@^(.*</span> )(.*)$@U' , '$1 <span class="tl_red">$2</span>' , $ label ) ; break ; default : if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'colorizeLogEntries' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'colorizeLogEntries' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'colorizeLogEntries' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ label = $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ row , $ label ) ; } } break ; } return '<div class="ellipsis">' . $ label . '</div>' ; }
679	protected function validateCondition ( $ condition ) { if ( ! is_array ( $ condition ) ) { $ this -> addError ( $ this -> filterAttributeName , $ this -> parseErrorMessage ( 'invalidFilter' ) ) ; return ; } if ( empty ( $ condition ) ) { return ; } foreach ( $ condition as $ key => $ value ) { $ method = 'validateAttributeCondition' ; if ( isset ( $ this -> filterControls [ $ key ] ) ) { $ controlKey = $ this -> filterControls [ $ key ] ; if ( isset ( $ this -> conditionValidators [ $ controlKey ] ) ) { $ method = $ this -> conditionValidators [ $ controlKey ] ; } } $ this -> $ method ( $ key , $ value ) ; } }
8863	public function getHTMLFragments ( $ gridField ) { $ dataClass = $ gridField -> getList ( ) -> dataClass ( ) ; $ obj = singleton ( $ dataClass ) ; if ( ! $ obj -> canCreate ( ) ) return "" ; $ dbField = $ this -> getDataObjectField ( ) ; $ textField = TextField :: create ( "gridfieldaddbydbfield[" . $ obj -> ClassName . "][" . Convert :: raw2htmlatt ( $ dbField ) . "]" ) -> setAttribute ( "placeholder" , $ obj -> fieldLabel ( $ dbField ) ) -> addExtraClass ( "no-change-track" ) ; $ addAction = new GridField_FormAction ( $ gridField , 'add' , _t ( 'GridFieldAddByDBField.Add' , "Add {name}" , "Add button text" , array ( "name" => $ obj -> i18n_singular_name ( ) ) ) , 'add' , 'add' ) ; $ addAction -> setAttribute ( 'data-icon' , 'add' ) ; $ forTemplate = new ArrayData ( array ( ) ) ; $ forTemplate -> Fields = new ArrayList ( ) ; $ forTemplate -> Fields -> push ( $ textField ) ; $ forTemplate -> Fields -> push ( $ addAction ) ; return array ( $ this -> targetFragment => $ forTemplate -> renderWith ( "GridFieldAddByDBField" ) ) ; }
783	public function actionReport ( $ sourcePath , $ translationPath , $ title = 'Translation report' ) { $ sourcePath = trim ( $ sourcePath , '/\\' ) ; $ translationPath = trim ( $ translationPath , '/\\' ) ; $ results = [ ] ; $ dir = new DirectoryIterator ( $ sourcePath ) ; foreach ( $ dir as $ fileinfo ) { if ( ! $ fileinfo -> isDot ( ) && ! $ fileinfo -> isDir ( ) ) { $ translatedFilePath = $ translationPath . '/' . $ fileinfo -> getFilename ( ) ; $ sourceFilePath = $ sourcePath . '/' . $ fileinfo -> getFilename ( ) ; $ errors = $ this -> checkFiles ( $ translatedFilePath ) ; $ diff = empty ( $ errors ) ? $ this -> getDiff ( $ translatedFilePath , $ sourceFilePath ) : '' ; if ( ! empty ( $ diff ) ) { $ errors [ ] = 'Translation outdated.' ; } $ result = [ 'errors' => $ errors , 'diff' => $ diff , ] ; $ results [ $ fileinfo -> getFilename ( ) ] = $ result ; } } $ dir = new DirectoryIterator ( $ translationPath ) ; foreach ( $ dir as $ fileinfo ) { if ( ! $ fileinfo -> isDot ( ) && ! $ fileinfo -> isDir ( ) ) { $ translatedFilePath = $ translationPath . '/' . $ fileinfo -> getFilename ( ) ; $ errors = $ this -> checkFiles ( null , $ translatedFilePath ) ; if ( ! empty ( $ errors ) ) { $ results [ $ fileinfo -> getFilename ( ) ] [ 'errors' ] = $ errors ; } } } echo $ this -> renderFile ( __DIR__ . '/views/translation/report_html.php' , [ 'results' => $ results , 'sourcePath' => $ sourcePath , 'translationPath' => $ translationPath , 'title' => $ title , ] ) ; }
9514	public function addFacetedQuery ( $ query , $ index , array $ keys ) { $ this -> AddQuery ( $ query , $ index ) ; $ currentOffset = $ this -> _offset ; $ mode = $ this -> _sort ; $ sortby = $ this -> _sortby ; $ limit = $ this -> _limit ; $ this -> _offset = 0 ; $ this -> _sort = 0 ; $ this -> _sortby = '' ; $ this -> SetLimits ( 0 , 999 ) ; foreach ( $ keys as $ key ) { $ this -> setGroupByAttr ( $ key ) ; $ this -> AddQuery ( $ query , $ index ) ; } $ this -> _offset = $ currentOffset ; $ this -> _sort = $ mode ; $ this -> _sortby = $ sortby ; $ this -> SetLimits ( $ currentOffset , $ limit ) ; }
4705	public function slice ( $ offset , $ length = null ) { return new Collection ( array_slice ( $ this -> objects , $ offset , $ length ) ) ; }
11465	public static function assert ( $ file , $ line , $ expression ) { $ Exception = new PHPAssertionFailed ( '' , 0 , null , $ file , $ line , $ expression ) ; if ( assert_options ( ASSERT_BAIL ) ) { self :: exception ( $ Exception ) ; } else { throw $ Exception ; } }
2134	public static function remove ( $ strKey ) { $ objConfig = static :: getInstance ( ) ; if ( strncmp ( $ strKey , '$GLOBALS' , 8 ) !== 0 ) { $ strKey = "\$GLOBALS['TL_CONFIG']['$strKey']" ; } $ objConfig -> delete ( $ strKey ) ; }
205	public static function wrapText ( $ text , $ indent = 0 , $ refresh = false ) { $ size = static :: getScreenSize ( $ refresh ) ; if ( $ size === false || $ size [ 0 ] <= $ indent ) { return $ text ; } $ pad = str_repeat ( ' ' , $ indent ) ; $ lines = explode ( "\n" , wordwrap ( $ text , $ size [ 0 ] - $ indent , "\n" , true ) ) ; $ first = true ; foreach ( $ lines as $ i => $ line ) { if ( $ first ) { $ first = false ; continue ; } $ lines [ $ i ] = $ pad . $ line ; } return implode ( "\n" , $ lines ) ; }
1496	public function prepend ( Encoding ... $ encodings ) : self { $ copy = clone $ this ; array_unshift ( $ copy -> stack , ... $ encodings ) ; return $ copy ; }
10648	private function normalizeRules ( ) { foreach ( $ this -> rules as $ scope => $ rules ) { foreach ( $ rules as $ field => $ rule ) { if ( is_array ( $ rule ) ) { $ this -> rules [ $ scope ] [ $ field ] = implode ( '|' , $ rule ) ; } } } }
9643	public static function getDriver ( MappingDriver $ originalDriver , $ namespace ) { if ( $ originalDriver instanceof MappingDriverChain ) { $ driver = new Driver \ Chain ( ) ; foreach ( $ originalDriver -> getDrivers ( ) as $ nestedNamespace => $ nestedDriver ) { $ driver -> addDriver ( static :: getDriver ( $ nestedDriver , $ namespace ) , $ nestedNamespace ) ; } if ( $ originalDriver -> getDefaultDriver ( ) !== null ) { $ driver -> setDefaultDriver ( static :: getDriver ( $ originalDriver -> getDefaultDriver ( ) , $ namespace ) ) ; } return $ driver ; } preg_match ( '/(?P<type>Xml|Yaml|Annotation)Driver$/' , get_class ( $ originalDriver ) , $ m ) ; $ type = isset ( $ m [ 'type' ] ) ? $ m [ 'type' ] : null ; $ driverClass = sprintf ( '%s\Mapping\Driver\%s' , $ namespace , $ type ) ; if ( ! $ type || ! class_exists ( $ driverClass ) ) { $ driverClass = sprintf ( '%s\Mapping\Driver\Annotation' , $ namespace ) ; if ( ! class_exists ( $ driverClass ) ) { throw new \ RuntimeException ( sprintf ( 'Failed to fallback to annotation driver: (%s), extension driver was not found.' , $ driverClass ) ) ; } } $ driver = new $ driverClass ( ) ; $ driver -> setOriginalDriver ( $ originalDriver ) ; if ( $ driver instanceof Driver \ File ) { $ driver -> setLocator ( $ originalDriver -> getLocator ( ) ) ; } elseif ( $ driver instanceof AnnotationDriverInterface ) { $ reader = static :: getAnnotationReader ( ) ; $ driver -> setAnnotationReader ( $ reader ) ; } return $ driver ; }
2039	private function createConfig ( $ size ) : array { if ( ! \ is_array ( $ size ) ) { $ size = [ 0 , 0 , $ size ] ; } $ config = new PictureConfiguration ( ) ; $ attributes = [ ] ; if ( ! isset ( $ size [ 2 ] ) || ! is_numeric ( $ size [ 2 ] ) ) { $ resizeConfig = new ResizeConfiguration ( ) ; if ( ! empty ( $ size [ 0 ] ) ) { $ resizeConfig -> setWidth ( ( int ) $ size [ 0 ] ) ; } if ( ! empty ( $ size [ 1 ] ) ) { $ resizeConfig -> setHeight ( ( int ) $ size [ 1 ] ) ; } if ( ! empty ( $ size [ 2 ] ) ) { $ resizeConfig -> setMode ( $ size [ 2 ] ) ; } $ configItem = new PictureConfigurationItem ( ) ; $ configItem -> setResizeConfig ( $ resizeConfig ) ; if ( $ this -> defaultDensities ) { $ configItem -> setDensities ( $ this -> defaultDensities ) ; } $ config -> setSize ( $ configItem ) ; return [ $ config , $ attributes ] ; } $ imageSizeModel = $ this -> framework -> getAdapter ( ImageSizeModel :: class ) ; $ imageSizes = $ imageSizeModel -> findByPk ( $ size [ 2 ] ) ; $ config -> setSize ( $ this -> createConfigItem ( $ imageSizes ) ) ; if ( $ imageSizes && $ imageSizes -> cssClass ) { $ attributes [ 'class' ] = $ imageSizes -> cssClass ; } $ imageSizeItemModel = $ this -> framework -> getAdapter ( ImageSizeItemModel :: class ) ; $ imageSizeItems = $ imageSizeItemModel -> findVisibleByPid ( $ size [ 2 ] , [ 'order' => 'sorting ASC' ] ) ; if ( null !== $ imageSizeItems ) { $ configItems = [ ] ; foreach ( $ imageSizeItems as $ imageSizeItem ) { $ configItems [ ] = $ this -> createConfigItem ( $ imageSizeItem ) ; } $ config -> setSizeItems ( $ configItems ) ; } return [ $ config , $ attributes ] ; }
4630	protected function prepareRequestHeaders ( ) { $ curl_headers = [ ] ; foreach ( $ this -> headers as $ key => $ value ) { $ curl_headers [ ] = sprintf ( '%s: %s' , $ key , $ value ) ; } $ object = $ this -> command -> getObject ( ) ; if ( $ object ) { if ( $ object -> getVclock ( ) ) { $ curl_headers [ ] = sprintf ( '%s: %s' , static :: VCLOCK_KEY , $ object -> getVclock ( ) ) ; } if ( $ object -> getContentType ( ) ) { $ charset = '' ; if ( $ object -> getCharset ( ) ) { $ charset = sprintf ( '; charset=%s' , $ object -> getCharset ( ) ) ; } $ curl_headers [ ] = sprintf ( '%s: %s' , static :: CONTENT_TYPE_KEY , $ object -> getContentType ( ) , $ charset ) ; } $ translator = new Api \ Http \ Translator \ SecondaryIndex ( ) ; $ indexHeaders = $ translator -> createHeadersFromIndexes ( $ object -> getIndexes ( ) ) ; foreach ( $ indexHeaders as $ value ) { $ curl_headers [ ] = sprintf ( '%s: %s' , $ value [ 0 ] , $ value [ 1 ] ) ; } foreach ( $ object -> getMetaData ( ) as $ key => $ value ) { $ curl_headers [ ] = sprintf ( '%s%s: %s' , static :: METADATA_PREFIX , $ key , $ value ) ; } } $ this -> options [ CURLOPT_HTTPHEADER ] = $ curl_headers ; $ this -> headers = [ ] ; return $ this ; }
3564	public function castToString ( ) { if ( $ this -> attributes [ 'meta_type' ] == 'array' ) { return $ this -> attributes [ 'meta_value' ] ; } $ value = $ this -> getValue ( ) ; if ( $ this -> isStringable ( $ value ) || is_object ( $ value ) && method_exists ( $ value , '__toString' ) ) { return ( string ) $ value ; } return '' ; }
8277	public function onConfigLoaded ( array & $ config ) { $ config [ self :: PLUGIN_NAME ] = $ this -> loadDefaultConfig ( $ config ) ; $ this -> config = $ config [ self :: PLUGIN_NAME ] ; $ this -> createContainer ( ) ; $ this -> initLogger ( ) ; }
3624	public function temperatureInUserScale ( $ temperature_in_celsius , $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ temp_scale = $ this -> getDeviceTemperatureScale ( $ serial_number ) ; if ( $ temp_scale == 'F' ) { return ( $ temperature_in_celsius * 1.8 ) + 32 ; } return $ temperature_in_celsius ; }
12610	public function getParents ( ) { $ parents = [ ] ; foreach ( $ this -> _parents as $ key => $ parent ) { if ( ! $ parent -> active ) { continue ; } $ parents [ $ key ] = $ parent ; } return $ parents ; }
6698	public function compareTo ( $ version ) { $ major = $ version -> getMajor ( ) ; $ minor = $ version -> getMinor ( ) ; $ patch = $ version -> getPatch ( ) ; $ pre = $ version -> getPreRelease ( ) ; $ build = $ version -> getBuild ( ) ; switch ( true ) { case ( $ this -> major < $ major ) : return 1 ; case ( $ this -> major > $ major ) : return - 1 ; case ( $ this -> minor > $ minor ) : return - 1 ; case ( $ this -> minor < $ minor ) : return 1 ; case ( $ this -> patch > $ patch ) : return - 1 ; case ( $ this -> patch < $ patch ) : return 1 ; } if ( $ pre || $ this -> pre ) { if ( empty ( $ this -> pre ) && $ pre ) { return - 1 ; } if ( $ this -> pre && empty ( $ pre ) ) { return 1 ; } if ( 0 !== ( $ weight = $ this -> precedence ( $ this -> pre , $ pre ) ) ) { return $ weight ; } } if ( $ build || $ this -> build ) { if ( ( null === $ this -> build ) && $ build ) { return 1 ; } if ( $ this -> build && ( null === $ build ) ) { return - 1 ; } return $ this -> precedence ( $ this -> build , $ build ) ; } return 0 ; }
9195	public function setThemesPath ( $ path ) { if ( ! is_dir ( $ path ) ) { throw new \ Exception ( sprintf ( 'Path "%s" not found.' , $ path ) ) ; } $ this -> themesPath = rtrim ( $ path , DS ) ; return $ this ; }
6654	public function getRequestToken ( $ settings , OAuthConsumerInterface $ consumer , OAuthTokenInterface $ token ) { $ url = $ settings [ 'auth_api_url' ] . $ settings [ 'request_token_uri' ] ; $ options = [ 'oauth_callback' => $ settings [ 'callback_url' ] ] ; $ headers = $ this -> headers ( $ settings , 'POST' , $ url , $ consumer , $ token , $ options ) ; $ request = [ 'url' => $ url , 'headers' => $ headers ] ; return $ this -> token -> makeRequestToken ( $ this -> http -> post ( $ request ) ) ; }
3077	public function processOutput ( QtiRunnerServiceContext $ context ) { $ messages = [ ] ; $ channels = $ this -> getOption ( self :: OPTION_CHANNELS ) ; if ( is_array ( $ channels [ self :: CHANNEL_TYPE_OUTPUT ] ) ) { foreach ( $ channels [ self :: CHANNEL_TYPE_OUTPUT ] as $ outputChannelName => $ outputChannelClass ) { $ channel = $ this -> getChannel ( $ outputChannelName , self :: CHANNEL_TYPE_OUTPUT ) ; $ message = $ this -> processChannel ( $ channel , $ context ) ; if ( $ message !== null ) { $ messages [ ] = [ 'channel' => $ channel -> getName ( ) , 'message' => $ message , ] ; } } } return $ messages ; }
6901	public function destroy ( ) : void { if ( $ this -> is_active ( ) ) { session_unset ( ) ; session_destroy ( ) ; $ this -> _data = [ ] ; Cookie :: delete ( $ this -> name ) ; } }
1590	protected function invokeMany ( iterable $ hooks , ... $ arguments ) { foreach ( $ hooks as $ hook ) { $ result = $ this -> invoke ( $ hook , ... $ arguments ) ; if ( ! is_null ( $ result ) ) { return $ result ; } } return null ; }
10739	public function supports ( $ query ) { foreach ( $ this -> engines as $ eachEngine ) { if ( $ eachEngine -> supports ( $ query ) ) { return true ; } } return false ; }
726	public function getAttribute ( $ attribute ) { try { return parent :: getAttribute ( $ attribute ) ; } catch ( \ PDOException $ e ) { switch ( $ attribute ) { case self :: ATTR_SERVER_VERSION : return $ this -> query ( "SELECT CAST(SERVERPROPERTY('productversion') AS VARCHAR)" ) -> fetchColumn ( ) ; default : throw $ e ; } } }
3588	protected function getMetaBetweenConstraint ( $ column , array $ values ) { $ min = $ values [ 0 ] ; $ max = $ values [ 1 ] ; return function ( $ query ) use ( $ column , $ min , $ max ) { $ query -> where ( 'meta_key' , $ column ) -> where ( 'meta_value' , '>=' , $ min ) -> where ( 'meta_value' , '<=' , $ max ) ; } ; }
2407	public static function generateScriptTag ( $ src , $ async = false , $ mtime = false , $ hash = null , $ crossorigin = null ) { if ( $ mtime === null && ! preg_match ( '@^https?://@' , $ src ) ) { $ container = System :: getContainer ( ) ; $ rootDir = $ container -> getParameter ( 'kernel.project_dir' ) ; if ( file_exists ( $ rootDir . '/' . $ src ) ) { $ mtime = filemtime ( $ rootDir . '/' . $ src ) ; } else { $ webDir = StringUtil :: stripRootDir ( $ container -> getParameter ( 'contao.web_dir' ) ) ; if ( file_exists ( $ rootDir . '/' . $ webDir . '/' . $ src ) ) { $ mtime = filemtime ( $ rootDir . '/' . $ webDir . '/' . $ src ) ; } } } if ( $ mtime ) { $ src .= '?v=' . substr ( md5 ( $ mtime ) , 0 , 8 ) ; } return '<script src="' . $ src . '"' . ( $ async ? ' async' : '' ) . ( $ hash ? ' integrity="' . $ hash . '"' : '' ) . ( $ crossorigin ? ' crossorigin="' . $ crossorigin . '"' : '' ) . '></script>' ; }
1614	private function sendCommandInternal ( $ command , $ params ) { $ written = @ fwrite ( $ this -> _socket , $ command ) ; if ( $ written === false ) { throw new SocketException ( "Failed to write to socket.\nRedis command was: " . $ command ) ; } if ( $ written !== ( $ len = mb_strlen ( $ command , '8bit' ) ) ) { throw new SocketException ( "Failed to write to socket. $written of $len bytes written.\nRedis command was: " . $ command ) ; } return $ this -> parseResponse ( implode ( ' ' , $ params ) ) ; }
10062	public function update ( $ key , $ value ) { try { $ meta = $ this -> metaModel :: where ( 'key' , $ key ) -> firstOrFail ( ) ; } catch ( \ Exception $ e ) { $ message = "Can't update meta (key: $key). " ; $ message .= "Meta doesn't exist" ; throw new \ Exception ( $ message ) ; } $ meta -> value = $ value ; $ meta -> save ( ) ; }
5211	public function convert ( Node $ node , $ parentPrecedence , $ parentAssociativity , $ childPosition ) { $ type = $ node -> getType ( ) ; if ( $ this -> dispatcher -> issetPrecedenceMap ( $ type ) === true ) { $ childPrecedences = $ this -> dispatcher -> getPrecedenceMap ( $ type ) ; $ childPrecedence = $ childPrecedences [ 0 ] ; if ( $ childPrecedence > $ parentPrecedence || ( $ parentPrecedence == $ childPrecedence && $ parentAssociativity != $ childPosition ) ) { return '(' . $ this -> dispatcher -> { 'p' . $ type } ( $ node ) . ')' ; } } return $ this -> dispatcher -> { 'p' . $ type } ( $ node ) ; }
6100	protected function delete ( $ endpoint , array $ parameters = [ ] , $ fireAndForget = false ) { return $ this -> call ( $ endpoint , $ parameters , self :: METHOD_DELETE , null , $ fireAndForget ) ; }
10679	private function _sklStd ( $ slovo , $ ii , $ zivotne ) { if ( $ ii < 0 || $ ii > \ count ( $ this -> vzor ) ) { $ this -> astrTvar [ 0 ] = '!!!???' ; } $ count = \ count ( $ this -> v0 ) ; for ( $ jj = 0 ; $ jj < $ count ; $ jj ++ ) { if ( $ this -> _isShoda ( $ this -> v0 [ $ jj ] , $ slovo ) >= 0 ) { return null ; } } $ this -> astrTvar [ 0 ] = $ this -> vzor [ $ ii ] [ 0 ] ; for ( $ jj = 1 ; $ jj < 15 ; $ jj ++ ) { $ this -> astrTvar [ $ jj ] = $ this -> _sklon ( $ jj , $ ii , $ slovo , $ zivotne ) ; } $ count = \ count ( $ this -> v3 ) ; for ( $ jj = 0 ; $ jj < $ count ; $ jj ++ ) { if ( $ this -> _isShoda ( $ this -> v3 [ $ jj ] , $ slovo ) >= 0 ) { return ; } } }
3476	protected function request ( $ verb , $ endpoint , array $ data ) { $ url = rtrim ( $ this -> baseUrl , '/' ) . '/' . ltrim ( $ endpoint , '/' ) ; try { $ response = $ this -> httpClient -> request ( $ verb , $ url , [ 'headers' => [ 'Authorization' => 'Bot ' . $ this -> token , ] , 'json' => $ data , ] ) ; } catch ( RequestException $ exception ) { if ( $ response = $ exception -> getResponse ( ) ) { throw CouldNotSendNotification :: serviceRespondedWithAnHttpError ( $ response ) ; } throw CouldNotSendNotification :: serviceCommunicationError ( $ exception ) ; } catch ( Exception $ exception ) { throw CouldNotSendNotification :: serviceCommunicationError ( $ exception ) ; } $ body = json_decode ( $ response -> getBody ( ) , true ) ; if ( Arr :: get ( $ body , 'code' , 0 ) > 0 ) { throw CouldNotSendNotification :: serviceRespondedWithAnApiError ( $ body ) ; } return $ body ; }
12451	static function run_check_php_files ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { $ opts = self :: getOpts ( @ $ args [ 0 ] , @ $ args [ 1 ] , $ cliopts ) ; if ( ! SharedLock :: acquire ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ) throw new PakeException ( "Source code locked by another process" ) ; $ destdir = self :: getBuildDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ; $ files = pakeFinder :: type ( 'file' ) -> name ( array ( '*.php' ) ) -> in ( $ destdir ) ; if ( count ( $ files ) ) { $ php = self :: getTool ( 'php' , $ opts ) ; if ( strpos ( pake_sh ( $ php . " -v" ) , 'PHP' ) === false ) { SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; throw new pakeException ( "$php does not seem to be a valid php executable" ) ; } foreach ( pakeFinder :: type ( 'file' ) -> name ( array ( '*.php' ) ) -> in ( $ destdir ) as $ file ) { if ( strpos ( pake_sh ( $ php . " -l " . escapeshellarg ( $ file ) ) , 'No syntax errors detected' ) === false ) { SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; throw new pakeException ( "$file does not seem to be a valid php file" ) ; } } } SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; }
4776	public function render ( $ widgets , bool $ base = true ) { if ( ! $ widgets ) { return false ; } $ output = '' ; $ userId = $ this -> tokenStorage -> getToken ( ) -> getUser ( ) -> getId ( ) ; foreach ( $ widgets as $ widget ) { if ( $ widget -> isActive ( ) ) { $ output .= $ this -> getOutput ( $ widget , $ userId ) ; } } if ( $ base ) { $ output = $ this -> engine -> render ( $ this -> baseTemplate , [ 'widgets' => $ output ] ) ; } return $ output ; }
4875	public function getMetaData ( $ key = null , $ default = null ) { if ( null === $ key ) { return $ this -> metaData ; } return $ this -> hasMetaData ( $ key ) ? $ this -> metaData [ $ key ] : $ default ; }
7162	private function buildSaleTaxesViews ( Model \ SaleInterface $ sale ) { if ( ! $ this -> options [ 'taxes_view' ] ) { return ; } $ amounts = $ this -> amountCalculator -> calculateSale ( $ sale ) ; foreach ( $ amounts -> getTaxAdjustments ( ) as $ tax ) { $ this -> view -> addTax ( new TaxView ( $ tax -> getName ( ) , $ this -> formatter -> currency ( $ tax -> getAmount ( ) ) ) ) ; } }
5079	public function postRemap ( ) { $ oUri = Factory :: service ( 'Uri' ) ; $ sMethod = 'post' . ucfirst ( $ oUri -> segment ( 4 ) ) ; if ( method_exists ( $ this , $ sMethod ) ) { return $ this -> $ sMethod ( ) ; } $ oInput = Factory :: service ( 'Input' ) ; $ oHttpCodes = Factory :: service ( 'HttpCodes' ) ; $ oItemModel = Factory :: model ( static :: CONFIG_MODEL_NAME , static :: CONFIG_MODEL_PROVIDER ) ; $ aFields = $ oItemModel -> describeFields ( ) ; $ aValid = [ ] ; $ aInvalid = [ ] ; foreach ( $ aFields as $ oField ) { if ( in_array ( $ oField -> key , static :: CONFIG_POST_IGNORE_FIELDS ) ) { continue ; } $ aValid [ ] = $ oField -> key ; } $ aPost = $ oInput -> post ( ) ; foreach ( $ aPost as $ sKey => $ sValue ) { if ( ! in_array ( $ sKey , $ aValid ) ) { $ aInvalid [ ] = $ sKey ; } } if ( ! empty ( $ aInvalid ) ) { throw new ApiException ( 'The following arguments are invalid: ' . implode ( ', ' , $ aInvalid ) , $ oHttpCodes :: STATUS_BAD_REQUEST ) ; } $ iItemId = ( int ) $ oUri -> segment ( 4 ) ; if ( $ iItemId ) { $ oItem = $ oItemModel -> getById ( $ iItemId ) ; if ( empty ( $ oItem ) ) { throw new ApiException ( 'Item does not exist' , $ oHttpCodes :: STATUS_NOT_FOUND ) ; } elseif ( ! $ oItemModel -> update ( $ iItemId , $ aPost ) ) { throw new ApiException ( 'Failed to update item. ' . $ oItemModel -> lastError ( ) , $ oHttpCodes :: STATUS_INTERNAL_SERVER_ERROR ) ; } elseif ( classUses ( $ oItemModel , 'Nails\Common\Traits\Caching' ) ) { $ oItemModel -> disableCache ( ) ; } $ oItem = $ oItemModel -> getById ( $ iItemId ) ; if ( classUses ( $ oItemModel , 'Nails\Common\Traits\Caching' ) ) { $ oItemModel -> enableCache ( ) ; } } else { $ oItem = $ oItemModel -> create ( $ aPost , true ) ; } $ oResponse = Factory :: factory ( 'ApiResponse' , 'nails/module-api' ) ; $ oResponse -> setData ( $ this -> formatObject ( $ oItem ) ) ; return $ oResponse ; }
7809	public static function toDebugReport ( ) { $ report = 'PHP SDK (zipMoney) Debug Report:' . PHP_EOL ; $ report .= ' OS: ' . php_uname ( ) . PHP_EOL ; $ report .= ' PHP Version: ' . phpversion ( ) . PHP_EOL ; $ report .= ' OpenAPI Spec Version: 2017-03-01' . PHP_EOL ; $ report .= ' Temp Folder Path: ' . self :: getDefaultConfiguration ( ) -> getTempFolderPath ( ) . PHP_EOL ; return $ report ; }
1330	public function queryToMany ( $ relation , EncodingParametersInterface $ parameters ) { return $ this -> queryAllOrOne ( $ relation -> newQuery ( ) , $ this -> getQueryParameters ( $ parameters ) ) ; }
4070	public function getStylesheets ( GetOptionsEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) || ( $ event -> getPropertyName ( ) !== 'additionalCss' ) || ( $ event -> getSubPropertyName ( ) !== 'file' ) ) { return ; } $ event -> setOptions ( $ this -> scanFiles ( 'css' ) ) ; }
1244	public static function memoize ( callable $ provider ) { return function ( ) use ( $ provider ) { static $ result ; static $ isConstant ; if ( $ isConstant ) { return $ result ; } $ isConstant = true ; return $ result = $ provider ( ) ; } ; }
9830	public function getAssociationMenuName ( $ modelName , $ otherModelName ) { return sprintf ( 'auja.%s.%s.menu' , $ this -> toUrlName ( $ modelName ) , $ this -> toUrlName ( $ otherModelName ) ) ; }
819	private function isCommentLastLineToken ( Tokens $ tokens , $ index ) { if ( ! $ tokens [ $ index ] -> isComment ( ) || ! $ tokens [ $ index + 1 ] -> isWhitespace ( ) ) { return false ; } $ content = $ tokens [ $ index + 1 ] -> getContent ( ) ; return $ content !== ltrim ( $ content , "\r\n" ) ; }
9116	public function registerView ( $ view , $ order = null , $ applicationName = 'default' ) { if ( ! class_exists ( $ view ) ) { throw new ViewException ( "No such view class {view} found" , array ( 'view' => $ view ) ) ; } $ v = new $ view ( ) ; if ( ! $ v instanceof View ) { throw new ViewException ( "View {view} is not in application scope" , array ( 'view' => $ view ) ) ; } $ viewOrder = $ v -> getOrder ( ) ; if ( null !== $ order ) { $ viewOrder = intval ( $ order ) ; } $ settings = $ v -> getViewSettings ( ) ; $ this -> views [ $ applicationName ] [ $ viewOrder ] [ $ settings -> getViewSimpleName ( ) ] = $ settings ; return $ this ; }
12866	public function init_locales ( ) { if ( ! empty ( $ this -> textdomain ) && $ this -> locales_initialized !== true ) { load_plugin_textdomain ( $ this -> textdomain , true , $ this -> get_id ( ) ) ; $ this -> locales_initialized = true ; } }
11859	public static function getHandlingObject ( $ a , $ b ) { $ handlingA = $ a -> handlingComparison ; $ handlingB = $ b -> handlingComparison ; if ( ! $ handlingB ) { return $ a ; } if ( $ handlingA !== false && $ handlingB !== false ) { if ( $ handlingA > $ handlingB ) { return $ a ; } else { return $ b ; } } return $ a ; }
477	public function renameTable ( $ table , $ newName ) { $ time = $ this -> beginCommand ( "rename table $table to $newName" ) ; $ this -> db -> createCommand ( ) -> renameTable ( $ table , $ newName ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
7779	protected function extractRules ( array $ data ) { $ rules = [ ] ; foreach ( $ data as $ field => $ fieldData ) { $ rules [ $ field ] = $ fieldData [ 1 ] ; } return $ rules ; }
11580	public function getStatus ( ) { $ message = 'Tracking ' ; $ numRepos = 0 ; if ( isset ( $ this [ 'repositories' ] ) && ( 1 === ( $ numRepos = count ( $ this [ 'repositories' ] ) ) ) ) { $ message .= '1 repository.' ; } else { $ message .= $ numRepos . ' repositories.' ; } return $ message ; }
2549	protected function loadClientParams ( Params $ params , $ receivedFromIdentifier , $ version ) { if ( $ params -> authParams instanceof Params \ AuthParams ) { $ this -> authParams = $ params -> authParams ; if ( isset ( $ params -> sessionHandlerParams ) && $ params -> sessionHandlerParams instanceof Params \ SessionHandlerParams ) { $ params -> sessionHandlerParams -> authParams = $ this -> authParams ; } } elseif ( isset ( $ params -> sessionHandlerParams ) && $ params -> sessionHandlerParams -> authParams instanceof Params \ AuthParams ) { $ this -> authParams = $ params -> sessionHandlerParams -> authParams ; } $ this -> sessionHandler = $ this -> loadSessionHandler ( $ params -> sessionHandler , $ params -> sessionHandlerParams ) ; $ this -> requestCreator = $ this -> loadRequestCreator ( $ params -> requestCreator , $ params -> requestCreatorParams , $ receivedFromIdentifier . "-" . $ version , $ this -> sessionHandler -> getOriginatorOffice ( ) , $ this -> sessionHandler -> getMessagesAndVersions ( ) ) ; $ this -> responseHandler = $ this -> loadResponseHandler ( $ params -> responseHandler ) ; $ this -> returnResultXml = $ params -> returnXml ; }
10235	private function getImageMimeType ( $ pFile ) { if ( File :: fileExists ( $ pFile ) ) { $ image = getimagesize ( $ pFile ) ; return image_type_to_mime_type ( $ image [ 2 ] ) ; } throw new WriterException ( "File $pFile does not exist" ) ; }
2506	public static function exaluateXpathQueryOnWsdl ( $ wsdlId , $ wsdlFilePath , $ xpath ) { WsdlAnalyser :: loadWsdlXpath ( $ wsdlFilePath , $ wsdlId ) ; return self :: $ wsdlDomXpath [ $ wsdlId ] -> evaluate ( $ xpath ) ; }
8472	public function error ( $ scope , $ message , $ context = [ ] , $ config = [ ] ) { return $ this -> write ( 'error' , $ scope , $ message , $ context , $ config ) ; }
5682	public function getFrameset ( ) { if ( ! $ this -> hasFrames ( ) ) { return false ; } $ urls = array ( ) ; for ( $ i = 0 ; $ i < count ( $ this -> frames ) ; $ i ++ ) { $ name = $ this -> frames [ $ i ] -> getAttribute ( 'name' ) ; $ url = new SimpleUrl ( $ this -> frames [ $ i ] -> getAttribute ( 'src' ) ) ; $ key = $ name ? $ name : $ i + 1 ; $ urls [ $ key ] = $ this -> expandUrl ( $ url ) ; } return $ urls ; }
9098	public function initThemeManager ( ModuleEvent $ e ) { $ moduleManager = $ e -> getTarget ( ) ; $ sm = $ moduleManager -> getEvent ( ) -> getParam ( 'ServiceManager' ) ; $ themManager = $ sm -> get ( 'yimaTheme.Manager' ) ; if ( ! $ themManager instanceof ManagerInterface ) { throw new \ Exception ( sprintf ( 'yimaTheme theme manager most instance of "ManagerInterface" but "%s" given.' , get_class ( $ themManager ) ) ) ; } $ themManager -> init ( ) ; }
2880	public function disableTranslateAction ( ) { try { $ this -> getService ( ) -> setTranslateInline ( 0 ) ; $ this -> getService ( ) -> flushCache ( ) ; } catch ( Exception $ e ) { $ message = $ this -> __ ( 'Translate inline cannot be disabled: %s' , $ e -> getMessage ( ) ) ; $ this -> getSession ( ) -> addError ( $ message ) ; } $ this -> _redirectReferer ( ) ; }
2544	protected function analyzeWithErrCodeCategoryMsgNodeName ( SendResult $ response , $ nodeErr , $ nodeCat , $ nodeMsg ) { $ analyzeResponse = new Result ( $ response ) ; $ domDoc = $ this -> loadDomDocument ( $ response -> responseXml ) ; $ errorCodeNode = $ domDoc -> getElementsByTagName ( $ nodeErr ) -> item ( 0 ) ; if ( ! is_null ( $ errorCodeNode ) ) { $ errorCatNode = $ domDoc -> getElementsByTagName ( $ nodeCat ) -> item ( 0 ) ; if ( $ errorCatNode instanceof \ DOMNode ) { $ analyzeResponse -> status = $ this -> makeStatusFromErrorQualifier ( $ errorCatNode -> nodeValue ) ; } else { $ analyzeResponse -> status = Result :: STATUS_ERROR ; } $ errorCode = $ errorCodeNode -> nodeValue ; $ errorTextNodeList = $ domDoc -> getElementsByTagName ( $ nodeMsg ) ; $ analyzeResponse -> messages [ ] = new Result \ NotOk ( $ errorCode , $ this -> makeMessageFromMessagesNodeList ( $ errorTextNodeList ) ) ; } return $ analyzeResponse ; }
7301	static public function getTargetsForSale ( SaleInterface $ sale ) { if ( $ sale instanceof CartInterface ) { return [ static :: TARGET_ORDER , static :: TARGET_QUOTE ] ; } elseif ( $ sale instanceof OrderInterface ) { if ( $ sale -> getState ( ) !== OrderStates :: STATE_NEW ) { return [ ] ; } return [ static :: TARGET_QUOTE ] ; } elseif ( $ sale instanceof QuoteInterface ) { return [ static :: TARGET_ORDER ] ; } throw new InvalidArgumentException ( "Unexpected sale type." ) ; }
11176	public static function rand ( $ length = 10 , $ special = false ) { $ characters = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ' ; $ special && ( $ characters .= '!@#$%^&*()+=>:;*-~`{}[],' ) ; $ charactersLength = strlen ( $ characters ) ; $ randomString = '' ; for ( $ i = 0 ; $ i < $ length ; $ i ++ ) { $ randomString .= $ characters [ rand ( 0 , $ charactersLength - 1 ) ] ; } return $ randomString ; }
7502	private function getOrCreateGroup ( string $ namespace ) : Group { $ group = $ this -> em -> find ( Group :: getClass ( ) , $ namespace ) ; if ( null !== $ group ) { return $ group ; } $ group = new Group ( $ namespace ) ; $ t = $ this -> tm -> createTransaction ( ) ; $ this -> em -> persist ( $ group ) ; $ t -> commit ( ) ; return $ group ; }
6790	protected function merge ( array $ cachedUnits , array $ fetchedUnits ) { $ cachedIds = [ ] ; foreach ( $ cachedUnits as $ unit ) { if ( null !== $ id = $ unit -> getId ( ) ) { $ cachedIds [ ] = $ unit -> getId ( ) ; } } foreach ( $ fetchedUnits as $ unit ) { if ( in_array ( $ unit -> getId ( ) , $ cachedIds ) ) { continue ; } if ( $ this -> unitCache -> isRemoved ( $ unit ) ) { continue ; } if ( $ this -> persistenceHelper -> isScheduledForRemove ( $ unit ) ) { continue ; } $ cachedUnits [ ] = $ unit ; } return $ cachedUnits ; }
4834	public function fetch_access_token ( $ params ) { if ( ! isset ( $ params [ 'redirect_uri' ] ) ) { throw new GoCardless_ArgumentsException ( 'redirect_uri required' ) ; } $ params [ 'http_authorization' ] = $ this -> account_details [ 'app_id' ] . ':' . $ this -> account_details [ 'app_secret' ] ; $ response = $ this -> request ( 'post' , '/oauth/access_token' , $ params ) ; $ merchant = explode ( ':' , $ response [ 'scope' ] ) ; $ merchant_id = isset ( $ merchant [ 1 ] ) ? $ merchant [ 1 ] : null ; $ access_token = $ response [ 'access_token' ] ; return array ( 'merchant_id' => $ merchant_id , 'access_token' => $ access_token ) ; }
3284	public function setFormatter ( $ formatter ) { if ( $ formatter === null ) { $ formatter = new SerializeFormatter ( ) ; } if ( ! $ formatter instanceof FormatterInterface ) { throw new Exception ( 'Formatter must be an instance of Flintstone\Formatter\FormatterInterface' ) ; } $ this -> config [ 'formatter' ] = $ formatter ; }
9808	private function readOPT ( ) { $ recInstance = ( 0xFFF0 & Xls :: getUInt2d ( $ this -> data , $ this -> pos ) ) >> 4 ; $ length = Xls :: getInt4d ( $ this -> data , $ this -> pos + 4 ) ; $ recordData = substr ( $ this -> data , $ this -> pos + 8 , $ length ) ; $ this -> pos += 8 + $ length ; $ this -> readOfficeArtRGFOPTE ( $ recordData , $ recInstance ) ; }
5375	protected function createInputTag ( $ attributes ) { if ( ! isset ( $ attributes [ 'type' ] ) ) { return new SimpleTextTag ( $ attributes ) ; } $ type = strtolower ( trim ( $ attributes [ 'type' ] ) ) ; $ map = array ( 'submit' => 'SimpleSubmitTag' , 'image' => 'SimpleImageSubmitTag' , 'checkbox' => 'SimpleCheckboxTag' , 'radio' => 'SimpleRadioButtonTag' , 'text' => 'SimpleTextTag' , 'hidden' => 'SimpleTextTag' , 'password' => 'SimpleTextTag' , 'file' => 'SimpleUploadTag' ) ; if ( array_key_exists ( $ type , $ map ) ) { $ tag_class = $ map [ $ type ] ; return new $ tag_class ( $ attributes ) ; } return false ; }
3965	protected function authenticateUser ( ) { if ( \ System :: getContainer ( ) -> get ( 'cca.dc-general.scope-matcher' ) -> currentScopeIsUnknown ( ) ) { return false ; } if ( strpos ( Environment :: get ( 'script' ) , 'contao/login' ) !== false ) { return false ; } if ( strpos ( Environment :: get ( 'request' ) , 'install' ) !== false ) { return false ; } if ( strpos ( Environment :: get ( 'script' ) , 'system/bin' ) !== false ) { return false ; } $ authResult = $ this -> getUser ( ) -> authenticate ( ) ; return ( $ authResult === true || $ authResult === null ) ? true : false ; }
8275	public function handleEvent ( $ eventName , array $ params ) { if ( method_exists ( $ this , $ eventName ) ) { call_user_func_array ( array ( $ this , $ eventName ) , $ params ) ; } }
10823	public static function ask ( $ question , $ defaultValue = null , $ secret = false ) { $ value = '' ; while ( trim ( $ value ) == '' ) { self :: writeln ( '' ) ; self :: write ( ' ' . $ question , 'info' ) ; if ( $ defaultValue !== null ) { self :: write ( ' [' ) ; self :: write ( $ defaultValue , 'comment' ) ; self :: write ( ']' ) ; } self :: writeln ( ':' ) ; if ( $ secret ) { self :: write ( ' > ' ) ; if ( self :: $ testValue === null ) { system ( 'stty -echo' ) ; $ value = trim ( fgets ( STDIN ) ) ; system ( 'stty echo' ) ; } else { $ value = self :: $ testValue ; } } else { if ( self :: $ testValue === null ) { $ value = readline ( ' > ' ) ; } else { $ value = self :: $ testValue ; } } if ( trim ( $ value ) == '' ) { $ value = $ defaultValue ; } if ( trim ( $ value ) == '' ) { self :: writeln ( '' ) ; self :: block ( '[ERROR] A value is required' , 'error' ) ; } self :: writeln ( '' ) ; } return trim ( $ value ) ; }
6029	public function addDeploymentFile ( $ item ) { if ( ! ( $ item instanceof DeploymentFile ) ) { if ( is_array ( $ item ) ) { try { $ item = new DeploymentFile ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate DeploymentFile. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "DeploymentFile"!' , E_USER_WARNING ) ; } } $ this -> deployedFiles [ ] = $ item ; return $ this ; }
10388	protected function handleTtl ( $ key , $ expireSetTs , $ expireSec ) { $ ttl = $ expireSetTs + $ expireSec - time ( ) ; if ( $ ttl <= 0 ) { $ this -> getClient ( ) -> delete ( $ key ) ; throw new KeyNotFoundException ( ) ; } return $ ttl ; }
11799	public function setReplyTo ( $ mail = '' , $ name = null ) { if ( strlen ( $ mail ) && Helper :: isEmail ( $ mail ) ) { if ( ! empty ( $ name ) ) { $ _m = Helper :: mailTagger ( $ mail , $ name ) ; } else { $ _m = $ mail ; } $ this -> getMailer ( ) -> setRegistry ( 'Reply-To' , $ _m , 'headers' ) ; } return $ this ; }
7396	public function execute ( ) { $ addresses = $ this -> addressRepository -> createQueryBuilder ( 'a' ) -> where ( 'a.latitude IS NULL' ) -> orWhere ( 'a.longitude IS NULL' ) -> setMaxResults ( 500 ) -> getQuery ( ) -> getResult ( ) ; foreach ( $ addresses as $ address ) { try { $ this -> updateLatLong ( $ address ) ; } catch ( \ RuntimeException $ e ) { echo "Stopping work -- over the API query limit.\n" ; break ; } $ this -> entityManager -> persist ( $ address ) ; usleep ( self :: MILLISECONDS_PAUSE_BETWEEN_QUERIES ) ; } $ this -> entityManager -> flush ( ) ; }
6881	public function reverseTransform ( $ address ) { if ( null === $ address ) { return null ; } if ( ! $ address instanceof ShipmentAddress ) { throw new InvalidArgumentException ( "Expected instance of " . ShipmentAddress :: class ) ; } $ data = [ ] ; foreach ( $ this -> fields as $ field ) { $ value = $ this -> accessor -> getValue ( $ address , $ field ) ; if ( empty ( $ value ) ) { continue ; } if ( $ value instanceof CountryInterface ) { $ value = $ value -> getId ( ) ; } elseif ( $ value instanceof StateInterface ) { $ value = $ value -> getId ( ) ; } elseif ( $ value instanceof PhoneNumber ) { $ value = serialize ( $ value ) ; } $ data [ $ field ] = $ value ; } if ( empty ( $ data ) ) { return null ; } return $ data ; }
9706	private function writeAllNumberFormats ( ) { foreach ( $ this -> numberFormats as $ numberFormatIndex => $ numberFormat ) { $ this -> writeNumberFormat ( $ numberFormat -> getFormatCode ( ) , $ numberFormatIndex ) ; } }
12438	public function get ( $ id ) { if ( isset ( $ this -> children [ $ id ] ) ) { return $ this -> children [ $ id ] ; } throw new FormalException ( "Unknown form field '$id' on form '" . get_called_class ( ) . "'. Available fields are: " . implode ( ', ' , array_keys ( $ this -> children ) ) ) ; }
1149	protected function setDefaults ( $ options ) { $ this -> selector = empty ( $ options [ 'selector' ] ) ? 'form' : $ options [ 'selector' ] ; $ this -> view = empty ( $ options [ 'view' ] ) ? 'jsvalidation::bootstrap' : $ options [ 'view' ] ; $ this -> remote = isset ( $ options [ 'remote' ] ) ? $ options [ 'remote' ] : true ; }
11896	protected function generateIV ( ) { $ sizeIV = $ this -> getSizeIV ( ) ; if ( $ sizeIV === 0 ) { return $ this ; } $ this -> setIV ( mcrypt_create_iv ( $ sizeIV , MCRYPT_RAND ) ) ; return $ this ; }
1190	protected function isRemoteRule ( $ rule ) { return in_array ( $ rule , $ this -> serverRules ) || ! in_array ( $ rule , $ this -> clientRules ) ; }
11093	public static function linkRewrite ( $ str , $ allowUnicodeChars = false ) { if ( ! \ is_string ( $ str ) ) { return false ; } $ str = trim ( $ str ) ; if ( \ function_exists ( 'mb_strtolower' ) ) { $ str = mb_strtolower ( $ str , 'utf-8' ) ; } if ( ! $ allowUnicodeChars ) { $ str = self :: replaceAccentedChars ( $ str ) ; } if ( $ allowUnicodeChars ) { $ str = preg_replace ( '/[^a-zA-Z0-9\s\'\:\/\[\]\-\pL]/u' , '' , $ str ) ; } else { $ str = preg_replace ( '/[^a-zA-Z0-9\s\'\:\/\[\]\-]/' , '' , $ str ) ; } $ str = preg_replace ( '/[\s\'\:\/\[\]\-]+/' , ' ' , $ str ) ; $ str = str_replace ( [ ' ' , '/' ] , '-' , $ str ) ; if ( ! \ function_exists ( 'mb_strtolower' ) ) { $ str = strtolower ( $ str ) ; } return $ str ; }
3473	public function set ( string $ key , $ value ) : void { $ key = explode ( '.' , $ key ) ; $ last = array_pop ( $ key ) ; $ result = & $ this -> config ; foreach ( $ key as $ part ) { if ( ! isset ( $ result [ $ part ] ) || ! is_array ( $ result [ $ part ] ) ) { $ result [ $ part ] = [ ] ; } $ result = & $ result [ $ part ] ; } $ result [ $ last ] = $ value ; }
7175	public static function set_path ( & $ array , $ path , $ value , $ delimiter = null ) : void { if ( ! $ delimiter ) { $ delimiter = static :: $ delimiter ; } $ keys = $ path ; if ( ! is_array ( $ path ) ) { $ keys = explode ( $ delimiter , $ path ) ; } while ( count ( $ keys ) > 1 ) { $ key = array_shift ( $ keys ) ; if ( is_string ( $ key ) && ctype_digit ( $ key ) ) { $ key = ( int ) $ key ; } if ( ! isset ( $ array [ $ key ] ) ) { $ array [ $ key ] = array ( ) ; } $ array = & $ array [ $ key ] ; } $ array [ array_shift ( $ keys ) ] = $ value ; }
2734	public function afterGenerateXml ( \ Magento \ Framework \ View \ Layout $ subject , $ result ) { if ( $ subject -> isCacheable ( ) && $ this -> config -> isEnabled ( ) && $ this -> config -> getType ( ) == Config :: FASTLY && $ this -> config -> getTtl ( ) ) { $ header = $ this -> response -> getHeader ( 'cache-control' ) ; if ( ( $ header instanceof \ Zend \ Http \ Header \ HeaderInterface ) && ( $ value = $ header -> getFieldValue ( ) ) ) { if ( $ ttl = $ this -> config -> getStaleTtl ( ) ) { $ value .= ', stale-while-revalidate=' . $ ttl ; } if ( $ ttl = $ this -> config -> getStaleErrorTtl ( ) ) { $ value .= ', stale-if-error=' . $ ttl ; } $ this -> response -> setHeader ( $ header -> getFieldName ( ) , $ value , true ) ; } } if ( $ subject -> isCacheable ( ) ) { $ this -> response -> setHeader ( "fastly-page-cacheable" , "YES" ) ; } else { $ this -> response -> setHeader ( "fastly-page-cacheable" , "NO" ) ; } return $ result ; }
2200	public static function findPublishedByPidAndColumn ( $ intPid , $ strColumn , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = array ( "$t.pid=? AND $t.inColumn=?" ) ; $ arrValues = array ( $ intPid , $ strColumn ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.sorting" ; } return static :: findBy ( $ arrColumns , $ arrValues , $ arrOptions ) ; }
6606	public function validateAccessTokenResponse ( $ params ) { if ( ! isset ( $ params [ 'oauth_token' ] ) || ! isset ( $ params [ 'oauth_token_secret' ] ) || empty ( $ params [ 'oauth_token' ] ) || empty ( $ params [ 'oauth_token_secret' ] ) ) { throw new InvalidOAuthTokenException ( 'access token' ) ; } return true ; }
11296	public function getAttributeValueExtended ( $ name , $ convertDates = true ) { if ( isset ( $ this -> model_data [ $ name ] ) ) { $ result = $ this -> model_data [ $ name ] ; if ( $ result instanceof \ DateTime && $ convertDates == true ) { $ result = $ result -> format ( 'Y-m-d H:i:s' ) ; } return $ result ; } if ( isset ( $ this -> data -> { $ name } ) ) { return $ this -> data -> { $ name } ; } else if ( isset ( $ this -> model_extends ) && isset ( $ this -> model_attributes [ $ this -> model_extends ] ) ) { $ extendedModel = $ this -> { $ this -> model_extends } ; if ( $ extendedModel && $ result = $ extendedModel -> getAttributeValue ( $ name ) ) { return $ result ; } } return null ; }
1671	public function copyTo ( $ strNewName ) { $ strParent = \ dirname ( $ strNewName ) ; if ( ! is_dir ( $ this -> strRootDir . '/' . $ strParent ) ) { new self ( $ strParent ) ; } $ this -> Files -> rcopy ( $ this -> strFolder , $ strNewName ) ; $ syncSource = Dbafs :: shouldBeSynchronized ( $ this -> strFolder ) ; $ syncTarget = Dbafs :: shouldBeSynchronized ( $ strNewName ) ; if ( $ syncSource && $ syncTarget ) { Dbafs :: copyResource ( $ this -> strFolder , $ strNewName ) ; } elseif ( $ syncTarget ) { Dbafs :: addResource ( $ strNewName ) ; } return true ; }
11632	private function groupPvTrans ( $ transData ) { $ result = [ ] ; foreach ( $ transData as $ one ) { $ debitAccId = $ one -> get ( DTrans :: A_ACC_ID_DEBIT ) ; $ creditAccId = $ one -> get ( DTrans :: A_ACC_ID_CREDIT ) ; $ value = $ one -> get ( DTrans :: A_AMOUNT ) ; if ( isset ( $ result [ $ debitAccId ] ) ) { $ result [ $ debitAccId ] -= $ value ; } else { $ result [ $ debitAccId ] = - $ value ; } if ( isset ( $ result [ $ creditAccId ] ) ) { $ result [ $ creditAccId ] += $ value ; } else { $ result [ $ creditAccId ] = $ value ; } } return $ result ; }
10184	function createContactFilter ( $ newFilterObject , $ createTargetGroup , $ version = 1.0 ) { if ( $ version == 1.0 ) { $ queryParameters = array ( 'createTargetGroup' => ( $ createTargetGroup ) ? "true" : "false" ) ; return $ this -> put ( "contactfilters/contactfilter" , $ newFilterObject -> toXMLString ( ) , $ queryParameters ) ; } else if ( $ version == 2.0 ) { $ queryParameters = array ( 'createTargetGroup' => ( $ createTargetGroup ) ? "true" : "false" ) ; return $ this -> post ( "contactfilters/v2" , $ newFilterObject , $ queryParameters , "application/json" ) ; } }
2478	protected function getRequestHeaders ( Message $ message , Endpoint $ endpoint ) { $ headers = $ message -> headers ; if ( $ endpoint -> user !== null ) { $ headers [ 'Authorization' ] = 'Basic ' . base64_encode ( "{$endpoint->user}:{$endpoint->pass}" ) ; } $ requestHeaders = '' ; foreach ( $ headers as $ name => $ value ) { if ( is_numeric ( $ name ) ) { throw new \ RuntimeException ( "Invalid HTTP header name $name" ) ; } $ requestHeaders .= "$name: $value\r\n" ; } return $ requestHeaders ; }
12477	private function getTransformation ( ) { $ transforms = [ ] ; foreach ( $ this -> fields as $ field => $ extra ) { if ( is_int ( $ field ) ) { $ transforms [ $ extra ] = $ extra ; continue ; } $ transform = ( key_exists ( 'transform' , $ extra ) ) ? $ extra [ 'transform' ] : $ field ; if ( $ transform === false ) { continue ; } $ transforms [ $ field ] = $ transform ; } return $ transforms ; }
2045	public function generate ( ) { if ( TL_MODE == 'BE' ) { $ return = '<pre>' . htmlspecialchars ( $ this -> code ) . '</pre>' ; if ( $ this -> headline != '' ) { $ return = '<' . $ this -> hl . '>' . $ this -> headline . '</' . $ this -> hl . '>' . $ return ; } return $ return ; } return parent :: generate ( ) ; }
11700	public function getCachePool ( $ name ) { if ( array_key_exists ( $ name , $ this -> cachePools ) ) { return $ this -> cachePools [ $ name ] ; } throw new KeyNotFoundInSetException ( $ name , array_keys ( $ this -> cachePools ) , 'cache pools' ) ; }
6070	public function downloadArchive ( array $ ids , $ template = null , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'ids' => $ ids , 'template' => $ template ] , 'body' => json_encode ( [ ] ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/media/download' , $ parameters , $ cachePolicy ) ; return $ result ; }
10169	public function write ( Spreadsheet $ spreadsheet = null ) { $ objWriter = null ; if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' ) ; $ objWriter -> startElement ( 'office:document-settings' ) ; $ objWriter -> writeAttribute ( 'xmlns:office' , 'urn:oasis:names:tc:opendocument:xmlns:office:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:xlink' , 'http://www.w3.org/1999/xlink' ) ; $ objWriter -> writeAttribute ( 'xmlns:config' , 'urn:oasis:names:tc:opendocument:xmlns:config:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:ooo' , 'http://openoffice.org/2004/office' ) ; $ objWriter -> writeAttribute ( 'office:version' , '1.2' ) ; $ objWriter -> startElement ( 'office:settings' ) ; $ objWriter -> startElement ( 'config:config-item-set' ) ; $ objWriter -> writeAttribute ( 'config:name' , 'ooo:view-settings' ) ; $ objWriter -> startElement ( 'config:config-item-map-indexed' ) ; $ objWriter -> writeAttribute ( 'config:name' , 'Views' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'config:config-item-set' ) ; $ objWriter -> writeAttribute ( 'config:name' , 'ooo:configuration-settings' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
5513	public function expectMinimumCallCount ( $ method , $ count , $ message = '%s' ) { $ this -> dieOnNoMethod ( $ method , 'set minimum call count' ) ; $ message .= Mock :: getExpectationLine ( ) ; $ this -> expected_counts [ strtolower ( $ method ) ] = new MinimumCallCountExpectation ( $ method , $ count , $ message ) ; }
5997	public function setMin ( $ min ) { if ( $ min instanceof DateTime ) { $ this -> min = $ min ; } else { try { $ this -> min = new DateTime ( $ min ) ; } catch ( \ Exception $ e ) { $ this -> min = null ; } } return $ this ; }
6024	public function setMetadata ( array $ metadata ) { $ this -> metadata = [ ] ; foreach ( $ metadata as $ item ) { $ this -> addMetaData ( $ item ) ; } return $ this ; }
5127	public function readQTime ( ) { $ msec = $ this -> readUInt ( ) ; $ time = strtotime ( 'midnight' ) + $ msec / 1000 ; $ dt = \ DateTime :: createFromFormat ( 'U.u' , sprintf ( '%.6F' , $ time ) ) ; $ dt -> setTimezone ( new \ DateTimeZone ( date_default_timezone_get ( ) ) ) ; return $ dt ; }
7473	public function editAction ( $ id ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ user = $ em -> getRepository ( 'Orkestra\Bundle\ApplicationBundle\Entity\User' ) -> find ( $ id ) ; if ( ! $ user ) { throw $ this -> createNotFoundException ( 'Unable to locate User' ) ; } $ form = $ this -> createForm ( UserType :: class , $ user , array ( 'include_password' => false ) ) ; return array ( 'user' => $ user , 'form' => $ form -> createView ( ) , ) ; }
6271	protected function throwException ( $ msg ) { if ( $ this -> handle ) { fclose ( $ this -> handle ) ; unlink ( $ this -> tmpFileName ) ; } throw new Exception ( $ msg ) ; }
2875	public function getCategory ( $ timerName ) { $ category = self :: CORE_CATEGORY ; if ( strpos ( $ timerName , 'mage::dispatch' ) === 0 || strpos ( $ timerName , 'column.phtml' ) > 0 ) { $ category = self :: SECTION ; } else if ( strpos ( $ timerName , 'Model_Resource' ) > 0 ) { $ category = self :: DB_CATEGORY ; } else if ( strpos ( $ timerName , 'EAV' ) === 0 || strpos ( $ timerName , '_LOAD_ATTRIBUTE_' ) === 0 || strpos ( $ timerName , '__EAV_' ) === 0 ) { $ category = self :: EAV_CATEGORY ; } else if ( strpos ( $ timerName , 'CORE::create_object_of' ) === 0 ) { $ category = self :: CORE_CATEGORY ; } else if ( strpos ( $ timerName , 'OBSERVER' ) === 0 || strpos ( $ timerName , 'DISPATCH EVENT' ) === 0 ) { $ category = self :: EVENT_CATEGORY ; } else if ( strpos ( $ timerName , 'BLOCK' ) === 0 ) { $ category = self :: LAYOUT_CATEGORY ; } else if ( strpos ( $ timerName , 'init_config' ) === 0 ) { $ category = self :: CONFIG_CATEGORY ; } else if ( strpos ( $ timerName , 'layout/' ) === 0 || strpos ( $ timerName , 'layout_' ) > 0 ) { $ category = self :: LAYOUT_CATEGORY ; } else if ( strpos ( $ timerName , 'Mage_Core_Model_Design' ) === 0 ) { $ category = self :: LAYOUT_CATEGORY ; } else if ( strpos ( $ timerName , '.phtml' ) > 0 ) { $ category = self :: LAYOUT_CATEGORY ; } return $ category ; }
8732	public function challenge ( string $ hydroAddressId ) : ChallengeResponse { try { $ response = $ this -> callHydroApi ( 'post' , 'challenge' , [ 'json' => [ 'hydro_address_id' => $ hydroAddressId ] ] ) ; $ data = \ GuzzleHttp \ json_decode ( $ response -> getBody ( ) -> getContents ( ) , true , 512 , JSON_BIGINT_AS_STRING ) ; } catch ( RuntimeException $ e ) { throw ChallengeFailed :: forHydroAddressId ( $ hydroAddressId , $ e -> getMessage ( ) ) ; } catch ( InvalidArgumentException $ e ) { throw ChallengeFailed :: forHydroAddressId ( $ hydroAddressId , $ e -> getMessage ( ) ) ; } catch ( GuzzleException $ e ) { throw ChallengeFailed :: forHydroAddressId ( $ hydroAddressId , $ e -> getMessage ( ) ) ; } catch ( ApiRequestFailed $ e ) { throw ChallengeFailed :: forHydroAddressId ( $ hydroAddressId , $ e -> getMessage ( ) ) ; } return new ChallengeResponse ( $ data [ 'amount' ] , ( int ) $ data [ 'challenge' ] , ( int ) $ data [ 'partner_id' ] , $ data [ 'transaction_hash' ] ) ; }
1376	protected function validateTypeMember ( $ value , string $ path ) : bool { if ( ! is_string ( $ value ) ) { $ this -> memberNotString ( $ path , 'type' ) ; return false ; } if ( empty ( $ value ) ) { $ this -> memberEmpty ( $ path , 'type' ) ; return false ; } if ( ! $ this -> store -> isType ( $ value ) ) { $ this -> resourceTypeNotRecognised ( $ value , $ path ) ; return false ; } return true ; }
6129	protected function getCorpusTitle ( ) { if ( $ this -> currObj instanceof Server ) { return "ID: " . $ this -> currObj -> getId ( ) . " | Clients: " . $ this -> currObj -> clientCount ( ) . "/" . $ this -> currObj [ "virtualserver_maxclients" ] . " | Uptime: " . Convert :: seconds ( $ this -> currObj [ "virtualserver_uptime" ] ) ; } elseif ( $ this -> currObj instanceof Channel && ! $ this -> currObj -> isSpacer ( ) ) { return "ID: " . $ this -> currObj -> getId ( ) . " | Codec: " . Convert :: codec ( $ this -> currObj [ "channel_codec" ] ) . " | Quality: " . $ this -> currObj [ "channel_codec_quality" ] ; } elseif ( $ this -> currObj instanceof Client ) { return "ID: " . $ this -> currObj -> getId ( ) . " | Version: " . Convert :: versionShort ( $ this -> currObj [ "client_version" ] ) . " | Platform: " . $ this -> currObj [ "client_platform" ] ; } elseif ( $ this -> currObj instanceof Servergroup || $ this -> currObj instanceof Channelgroup ) { return "ID: " . $ this -> currObj -> getId ( ) . " | Type: " . Convert :: groupType ( $ this -> currObj [ "type" ] ) . " (" . ( $ this -> currObj [ "savedb" ] ? "Permanent" : "Temporary" ) . ")" ; } return "" ; }
5841	public function addRole ( $ role ) { if ( is_string ( $ role ) ) { $ role = new Role ( $ role ) ; } elseif ( ! $ role instanceof RoleInterface ) { throw new \ InvalidArgumentException ( sprintf ( 'Role must be a string or RoleInterface instance, but got %s.' , gettype ( $ role ) ) ) ; } if ( ! \ in_array ( $ role , $ this -> roles ) ) { $ this -> roles [ ] = $ role ; } }
7024	protected function getFormatter ( ) { if ( $ this -> formatter ) { return $ this -> formatter ; } if ( ! $ this -> formatterFactory ) { throw new RuntimeException ( "Please call setFormatterFactory() first." ) ; } return $ this -> formatter = $ this -> formatterFactory -> create ( ) ; }
10274	public function setLocked ( $ pValue ) { if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'locked' => $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> locked = $ pValue ; } return $ this ; }
251	public function removeFlash ( $ key ) { $ counters = $ this -> get ( $ this -> flashParam , [ ] ) ; $ value = isset ( $ _SESSION [ $ key ] , $ counters [ $ key ] ) ? $ _SESSION [ $ key ] : null ; unset ( $ counters [ $ key ] , $ _SESSION [ $ key ] ) ; $ _SESSION [ $ this -> flashParam ] = $ counters ; return $ value ; }
12965	public function getIcon ( ) { if ( is_null ( $ this -> _icon ) && isset ( $ this -> object ) ) { $ this -> _icon = [ 'class' => $ this -> object -> objectType -> icon , 'title' => $ this -> objectTypeDescriptor ] ; } return $ this -> _icon ; }
5438	public function match ( $ subject , & $ match ) { if ( count ( $ this -> patterns ) === 0 ) { return false ; } if ( ! preg_match ( $ this -> getCompoundedRegex ( ) , $ subject , $ matches ) ) { $ match = '' ; return false ; } $ match = $ matches [ 0 ] ; for ( $ i = 1 ; $ i < count ( $ matches ) ; $ i ++ ) { if ( $ matches [ $ i ] ) { return $ this -> labels [ $ i - 1 ] ; } } return true ; }
4900	public static function loadDotEnv ( ) { $ dotenv = new Dotenv ( ) ; if ( is_file ( getcwd ( ) . '/.env.dist' ) ) { $ dotenv -> load ( getcwd ( ) . '/.env.dist' ) ; } if ( is_file ( $ file = getcwd ( ) . '/.env' ) ) { $ dotenv -> load ( $ file ) ; } if ( false === getenv ( 'TIMEZONE' ) ) { putenv ( 'TIMEZONE=Europe/Berlin' ) ; } date_default_timezone_set ( getenv ( 'TIMEZONE' ) ) ; }
11778	public function startAction ( Request $ request , Application $ app ) { $ options = array ( "request" => $ request , "configuration_handler" => $ app [ "red_kite_cms.configuration_handler" ] , ) ; return parent :: start ( $ options ) ; }
9654	public function getForPath ( $ path ) { $ extension = $ this -> getExtension ( $ path ) ; if ( ! isset ( $ this -> loaders [ $ extension ] ) ) { $ this -> resolveLoader ( $ extension ) ; } return $ this -> loaders [ $ extension ] ; }
8850	public function rss ( ) { $ rss = new RSSFeed ( $ this -> getBlogPosts ( ) , $ this -> Link ( ) , $ this -> MetaTitle , $ this -> MetaDescription ) ; $ this -> extend ( 'updateRss' , $ rss ) ; return $ rss -> outputToBrowser ( ) ; }
9473	public function deleteFaild ( $ message = null ) { if ( is_null ( $ message ) ) $ message = $ this -> config [ 'fail' ] [ 'delete' ] ; return $ this -> setStatusCode ( 447 ) -> setStatusText ( 'fail' ) -> setErrorCode ( 5447 ) -> respondWithMessage ( $ message ) ; }
12772	public function register ( $ email , $ hashedPassword = null , & $ user = null , $ valid = false ) { $ result = new EmailStatus ( 0 ) ; if ( ! dbQuery ( $ this -> dbTable ) -> cond ( $ this -> dbEmailField , $ email ) -> first ( $ user ) ) { if ( ! isset ( $ user ) ) { $ user = new $ this -> dbTable ( false ) ; } $ user [ $ this -> dbEmailField ] = $ email ; $ user [ $ this -> dbHashEmailField ] = $ this -> hash ( $ email ) ; if ( isset ( $ hashedPassword ) ) { $ user [ $ this -> dbHashPasswordField ] = $ hashedPassword ; } else { $ user [ $ this -> dbHashPasswordField ] = $ this -> generatePassword ( ) ; } if ( ! $ valid ) { $ user [ $ this -> dbConfirmField ] = $ this -> hash ( $ email . time ( ) ) ; } else { $ user [ $ this -> dbConfirmField ] = 1 ; } $ activeField = $ this -> dbActiveField ; $ createdField = $ this -> dbCreatedField ; $ user -> $ activeField = 1 ; $ user -> $ createdField = date ( 'Y-m-d H:i:s' ) ; $ user -> save ( ) ; $ this -> authorize ( $ user ) ; $ result = new EmailStatus ( EmailStatus :: SUCCESS_EMAIL_REGISTERED ) ; } else { $ result = new EmailStatus ( EmailStatus :: ERROR_EMAIL_REGISTER_FOUND ) ; } if ( is_callable ( $ this -> registerHandler ) ) { if ( ! call_user_func_array ( $ this -> registerHandler , array ( & $ user , & $ result ) ) ) { $ result = new EmailStatus ( EmailStatus :: ERROR_EMAIL_REGISTER_HANDLER ) ; } } return $ result ; }
11819	public function addAppDependencies ( ) { $ container = $ this -> getContainer ( ) ; $ container [ 'person' ] = $ container -> protect ( function ( $ name ) { return 'Person name: ' . $ name ; } ) ; return $ this ; }
7716	static function FindElement ( & $ TxtOrObj , $ Tag , $ PosBeg , $ Forward = true ) { $ XmlLoc = clsTbsXmlLoc :: FindStartTag ( $ TxtOrObj , $ Tag , $ PosBeg , $ Forward ) ; if ( $ XmlLoc === false ) return false ; $ XmlLoc -> FindEndTag ( ) ; return $ XmlLoc ; }
2548	private function findHandlerForMessage ( $ messageName ) { $ handler = null ; if ( array_key_exists ( $ messageName , $ this -> responseHandlers ) && $ this -> responseHandlers [ $ messageName ] instanceof MessageResponseHandler ) { $ handler = $ this -> responseHandlers [ $ messageName ] ; } else { $ section = substr ( $ messageName , 0 , strpos ( $ messageName , '_' ) ) ; $ message = substr ( $ messageName , strpos ( $ messageName , '_' ) + 1 ) ; $ handlerClass = __NAMESPACE__ . '\\' . $ section . '\\Handler' . $ message ; if ( class_exists ( $ handlerClass ) ) { $ handler = new $ handlerClass ( ) ; $ this -> responseHandlers [ $ messageName ] = $ handler ; } } return $ handler ; }
7288	public function setColumnForLinksLabels ( $ columnNameOrClosure ) { if ( ! is_string ( $ columnNameOrClosure ) && ! ( $ columnNameOrClosure instanceof DbExpr ) ) { throw new \ InvalidArgumentException ( '$columnNameOrClosure argument must be a string or a closure' ) ; } $ this -> columnForLinksLabels = $ columnNameOrClosure ; return $ this ; }
1050	public static function getDirectiveValues ( Directive $ directiveDef , $ node , $ variableValues = null ) { if ( isset ( $ node -> directives ) && $ node -> directives instanceof NodeList ) { $ directiveNode = Utils :: find ( $ node -> directives , static function ( DirectiveNode $ directive ) use ( $ directiveDef ) { return $ directive -> name -> value === $ directiveDef -> name ; } ) ; if ( $ directiveNode !== null ) { return self :: getArgumentValues ( $ directiveDef , $ directiveNode , $ variableValues ) ; } } return null ; }
6399	public function createEvents ( array $ events ) { $ results = [ ] ; foreach ( $ events as $ index => $ opts ) { $ route = isset ( $ opts [ 'eventname' ] ) ? $ opts [ 'eventname' ] : '' ; if ( isset ( static :: $ routes [ $ route ] ) && ( $ opts [ 'userid' ] > 0 || $ opts [ 'relateduserid' ] > 0 ) ) { try { $ event = '\LogExpander\Events\\' . static :: $ routes [ $ route ] ; array_push ( $ results , ( new $ event ( $ this -> repo ) ) -> read ( $ opts ) ) ; } catch ( \ Exception $ e ) { } } } return $ results ; }
6240	public static function getMimeFor ( string $ extension ) : ? string { $ extensions = static :: getExtensions ( ) ; if ( isset ( $ extensions [ $ extension ] ) ) { return $ extensions [ $ extension ] ; } return null ; }
873	public function getAnnotations ( ) { if ( null === $ this -> annotations ) { $ this -> annotations = [ ] ; $ total = \ count ( $ this -> lines ) ; for ( $ index = 0 ; $ index < $ total ; ++ $ index ) { if ( $ this -> lines [ $ index ] -> containsATag ( ) ) { $ lines = \ array_slice ( $ this -> lines , $ index , $ this -> findAnnotationLength ( $ index ) , true ) ; $ annotation = new Annotation ( $ lines ) ; $ index = $ annotation -> getEnd ( ) ; $ this -> annotations [ ] = $ annotation ; } } } return $ this -> annotations ; }
12981	public function preDispatch ( ) { $ error = null ; $ request = $ this -> getRequest ( ) ; if ( ! $ request -> isGet ( ) && ! $ request -> isHead ( ) ) { $ this -> _input = json_decode ( $ request -> getRawBody ( ) ) ; if ( JSON_ERROR_NONE === json_last_error ( ) ) { return ; } $ this -> getResponse ( ) -> setHttpResponseCode ( 400 ) -> setHeader ( 'Content-Type' , 'text/plain; charset=utf-8' , true ) -> setBody ( json_last_error_msg ( ) ) -> sendResponse ( ) ; exit ( 400 ) ; } }
47	public function addSubscriber ( EventSubscriberInterface $ subscriber ) { foreach ( $ subscriber -> getSubscribedEvents ( ) as $ eventName => $ params ) { if ( is_string ( $ params ) ) { $ this -> addListener ( $ eventName , array ( $ subscriber , $ params ) ) ; } elseif ( is_string ( $ params [ 0 ] ) ) { $ this -> addListener ( $ eventName , array ( $ subscriber , $ params [ 0 ] ) , isset ( $ params [ 1 ] ) ? $ params [ 1 ] : 0 ) ; } else { foreach ( $ params as $ listener ) { $ this -> addListener ( $ eventName , array ( $ subscriber , $ listener [ 0 ] ) , isset ( $ listener [ 1 ] ) ? $ listener [ 1 ] : 0 ) ; } } } }
6928	private function persistInvoice ( Invoice \ InvoiceInterface $ invoice ) { $ this -> persistenceHelper -> persistAndRecompute ( $ invoice , true ) ; foreach ( $ invoice -> getLines ( ) as $ line ) { $ this -> persistenceHelper -> persistAndRecompute ( $ line , true ) ; } $ this -> persistenceHelper -> persistAndRecompute ( $ invoice -> getShipment ( ) , false ) ; }
11606	public function getPHPHint ( $ namespaceContext = NULL ) { if ( ! isset ( $ this -> class ) ) { return '\stdClass' ; } if ( isset ( $ namespaceContext ) && trim ( $ this -> class -> getNamespace ( ) , '\\' ) === trim ( $ namespaceContext , '\\' ) ) { return $ this -> class -> getName ( ) ; } return '\\' . $ this -> class -> getFQN ( ) ; }
3178	public function getItemClasses ( ) { $ itemClass = $ this -> getClass ( self :: ITEM_ROOT_CLASS_URI ) ; return $ this -> getResourceService ( ) -> getAllClasses ( $ itemClass ) ; }
9247	public function from ( Contract $ contract , string $ string , callable $ callback = null ) : string { $ string = ucwords ( $ contract -> recipe ( $ string , 'upperCaseFirst' , function ( $ string ) use ( $ contract ) { if ( $ contract instanceof Camel ) { return $ string ; } return strtolower ( $ string ) ; } ) ) ; return $ this -> callback ( $ string , $ callback ) ; }
10603	public function checkQuery ( $ name ) { $ parts = explode ( '&' , $ this -> _urlParts [ 'query' ] ) ; foreach ( $ parts as $ p ) { $ paramData = explode ( '=' , $ p ) ; if ( $ paramData [ 0 ] === $ name ) { return true ; } } return false ; }
4167	protected function stringify ( $ name ) { $ classes = array_unique ( array_merge ( $ this -> suffixClass ( $ this -> getFromConfig ( $ name ) ) , $ this -> suffixClass ( $ this -> $ name ) ) ) ; $ newLine2Tabs = PHP_EOL . ' ' ; if ( $ name == 'providers' ) { return "'$name' => [$newLine2Tabs" . implode ( ',' . $ newLine2Tabs , $ classes ) . PHP_EOL . ' ],' . PHP_EOL ; } $ template = "'$name' => [$newLine2Tabs" ; foreach ( $ classes as $ fullClassName ) { $ template .= "'{$this->getClassName($fullClassName)}' => $fullClassName,$newLine2Tabs" ; } $ template .= PHP_EOL . ' ],' . PHP_EOL ; return $ template ; }
9775	function startWith ( string $ value ) : self { return $ this -> expect ( $ this -> target , stringStartsWith ( $ value ) ) ; }
10552	public function resolveApp ( ) { $ this -> determineVirtualHost ( ) ; $ path = $ this -> vhost -> getPath ( $ this -> request -> url ) ; $ resolved = $ this -> resolver -> resolve ( "app" , $ path ) ; if ( $ resolved !== null ) { if ( $ resolved [ 'ext' ] ) { $ mime = new FileType ( $ resolved [ 'ext' ] , "" ) ; if ( ! empty ( $ mime ) ) { $ str = $ mime -> getMimeType ( ) . ";q=1.5," . ( string ) $ this -> request -> accept ; $ this -> request -> setAccept ( new Accept ( $ str ) ) ; } $ this -> suffix = $ resolved [ 'ext' ] ; } $ this -> route = $ resolved [ 'route' ] ; $ this -> app = $ resolved [ 'path' ] ; $ this -> arguments = new Dictionary ( $ resolved [ 'remainder' ] ) ; } else { $ this -> route = null ; $ this -> app = null ; $ this -> arguments = new Dictionary ( ) ; } }
6515	public function consumeJob ( PlainMessage $ message ) { $ ticket = $ message -> ticket ; $ type = $ message -> type ; $ this -> logger -> debug ( 'Consume message from bernard backend' , [ 'message' => $ message ] ) ; $ this -> manager -> onMessage ( new Message ( $ type , $ ticket ) ) ; }
8651	private function convertGetReport ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetReport' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetReportId ( ) ) { $ parameters [ 'ReportId' ] = $ request -> getReportId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
11192	public function exists ( $ uri = false , $ httpMethod = false ) { if ( $ uri && $ httpMethod ) { $ this -> routeProcess ( $ uri , $ httpMethod ) ; } if ( ! isset ( $ this -> controllerPath ) ) { return false ; } return true ; }
7439	protected function initializeProductMediaGalleryValue ( array $ attr ) { $ rowId = $ attr [ MemberNames :: ROW_ID ] ; $ valueId = $ attr [ MemberNames :: VALUE_ID ] ; $ storeId = $ attr [ MemberNames :: STORE_ID ] ; if ( $ entity = $ this -> loadProductMediaGalleryValueByValueIdAndStoreIdAndRowId ( $ valueId , $ storeId , $ rowId ) ) { return $ this -> mergeEntity ( $ entity , $ attr ) ; } return $ attr ; }
2408	public function flushAllData ( ) { @ trigger_error ( 'Using Template::flushAllData() has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; if ( \ function_exists ( 'fastcgi_finish_request' ) ) { fastcgi_finish_request ( ) ; } elseif ( PHP_SAPI !== 'cli' ) { $ status = ob_get_status ( true ) ; $ level = \ count ( $ status ) ; while ( $ level -- > 0 && ( ! empty ( $ status [ $ level ] [ 'del' ] ) || ( isset ( $ status [ $ level ] [ 'flags' ] ) && ( $ status [ $ level ] [ 'flags' ] & PHP_OUTPUT_HANDLER_REMOVABLE ) && ( $ status [ $ level ] [ 'flags' ] & PHP_OUTPUT_HANDLER_FLUSHABLE ) ) ) ) { ob_end_flush ( ) ; } flush ( ) ; } }
3565	public function getAttribute ( ) { return function ( $ next , $ value , $ args ) { $ key = $ args -> get ( 'key' ) ; if ( is_null ( $ value ) ) { $ value = $ this -> getMeta ( $ key ) ; } return $ next ( $ value , $ args ) ; } ; }
1979	public static function generate ( $ strScope = TL_MODE ) { $ strMessages = static :: generateUnwrapped ( $ strScope ) ; if ( $ strMessages != '' ) { $ strMessages = '<div class="tl_message">' . $ strMessages . '</div>' ; } return $ strMessages ; }
12807	public static function where ( string $ column , string $ operator , $ value ) : Collection { $ pdo = Database :: connect ( ) ; $ class = self :: getStaticChildClass ( ) ; $ tableName = self :: getTableName ( ) ; $ column = self :: getColumnName ( $ column ) ; if ( $ column === null ) throw new ModelMissingPropertyException ( "Could not find a property '$column' of class '$class'. " . "Are you missing a '@ColumnNameAnnotation' on a property?" ) ; $ sql = "SELECT * FROM \"$tableName\" WHERE \"$column\" $operator " . ( gettype ( $ value ) === "string" ? "'$value'" : "$value" ) ; $ results = $ pdo -> query ( $ sql ) -> fetchAll ( ) ; $ collection = new Collection ( $ class , [ ] ) ; foreach ( $ results as $ result ) { $ object = new $ class ( $ result ) ; $ collection -> push ( $ object ) ; } return $ collection ; }
12047	public function range ( ) { $ arg_num = func_num_args ( ) ; if ( $ arg_num % 2 != 0 ) { throw new \ InvalidArgumentException ( "Number of args must be even" , 1 ) ; } $ value = "[" ; $ arg_list = func_get_args ( ) ; for ( $ i = 0 ; $ i < $ arg_num ; ) { $ value .= self :: sanitize ( $ arg_list [ $ i ++ ] ) . "-" . self :: sanitize ( $ arg_list [ $ i ++ ] ) ; } $ value .= "]" ; return $ this -> add ( $ value ) ; }
1558	protected function doesRequireOrdering ( $ query ) { if ( ! $ this -> primaryKey ) { return false ; } $ query = ( $ query instanceof Relation ) ? $ query -> getBaseQuery ( ) : $ query -> getQuery ( ) ; return ! collect ( $ query -> orders ? : [ ] ) -> contains ( function ( array $ order ) { $ col = $ order [ 'column' ] ?? '' ; return $ this -> primaryKey === $ col ; } ) ; }
9053	private function recursiveMenuItemHandling ( Collection $ menuItems ) { $ data = [ ] ; foreach ( $ menuItems as $ menuItem ) { if ( ! in_array ( $ menuItem -> getId ( ) , $ this -> alreadySetIds ) ) { $ this -> alreadySetIds [ ] = $ menuItem -> getId ( ) ; $ itemNode = [ ] ; $ itemNode [ 'name' ] = $ menuItem -> getTitle ( ) ; $ itemNode [ 'url' ] = $ menuItem -> getTarget ( ) ; $ itemNode [ 'id' ] = $ this -> position ; $ itemNode [ 'persist_id' ] = $ menuItem -> getId ( ) ; if ( null === $ menuItem -> getParent ( ) ) { $ itemNode [ 'owner_type' ] = get_class ( $ this -> currentOwner ) ; $ itemNode [ 'owner_id' ] = $ this -> currentOwner -> getId ( ) ; } $ this -> position ++ ; if ( $ menuItem -> getChildren ( ) -> count ( ) > 0 ) { $ itemNode [ 'children' ] = $ this -> recursiveMenuItemHandling ( $ menuItem -> getChildren ( ) ) ; } $ data [ ] = $ itemNode ; } } return $ data ; }
6791	public function create ( $ type , $ source = null ) { $ notify = new Notify ( ) ; $ notify -> setType ( $ type ) -> setSource ( $ source ) ; return $ notify ; }
4818	public function addField ( $ name , $ value ) { if ( $ this -> currentRow < 0 ) { $ this -> appendRow ( ) ; } $ this -> collection [ $ this -> currentRow ] -> addField ( $ name , $ value ) ; }
6380	public function readAttempt ( $ id ) { $ model = $ this -> readObject ( $ id , 'quiz_attempts' ) ; $ model -> url = $ this -> cfg -> wwwroot . '/mod/quiz/attempt.php?attempt=' . $ id ; $ model -> name = 'Attempt ' . $ id ; return $ model ; }
11886	public function addChild ( $ structureName , $ prefix = '' , $ suffix = '' ) { if ( isset ( $ this -> children [ $ structureName ] ) ) { throw new DefinitionDuplicateException ( sprintf ( 'Child structure with same name "%s" already exists' , $ structureName ) ) ; } $ this -> children [ $ structureName ] = array ( 'name' => $ structureName , 'prefix' => ( string ) $ prefix , 'suffix' => ( string ) $ suffix ) ; }
9040	public function getMax ( string $ column ) : int { return $ this -> connection -> query ( 'SELECT IFNULL(MAX(%column), 0) position FROM %table' , $ column , $ this -> getTableName ( ) ) -> fetch ( ) -> position ; }
757	protected function renderImageByGD ( $ code ) { $ image = imagecreatetruecolor ( $ this -> width , $ this -> height ) ; $ backColor = imagecolorallocate ( $ image , ( int ) ( $ this -> backColor % 0x1000000 / 0x10000 ) , ( int ) ( $ this -> backColor % 0x10000 / 0x100 ) , $ this -> backColor % 0x100 ) ; imagefilledrectangle ( $ image , 0 , 0 , $ this -> width - 1 , $ this -> height - 1 , $ backColor ) ; imagecolordeallocate ( $ image , $ backColor ) ; if ( $ this -> transparent ) { imagecolortransparent ( $ image , $ backColor ) ; } $ foreColor = imagecolorallocate ( $ image , ( int ) ( $ this -> foreColor % 0x1000000 / 0x10000 ) , ( int ) ( $ this -> foreColor % 0x10000 / 0x100 ) , $ this -> foreColor % 0x100 ) ; $ length = strlen ( $ code ) ; $ box = imagettfbbox ( 30 , 0 , $ this -> fontFile , $ code ) ; $ w = $ box [ 4 ] - $ box [ 0 ] + $ this -> offset * ( $ length - 1 ) ; $ h = $ box [ 1 ] - $ box [ 5 ] ; $ scale = min ( ( $ this -> width - $ this -> padding * 2 ) / $ w , ( $ this -> height - $ this -> padding * 2 ) / $ h ) ; $ x = 10 ; $ y = round ( $ this -> height * 27 / 40 ) ; for ( $ i = 0 ; $ i < $ length ; ++ $ i ) { $ fontSize = ( int ) ( mt_rand ( 26 , 32 ) * $ scale * 0.8 ) ; $ angle = mt_rand ( - 10 , 10 ) ; $ letter = $ code [ $ i ] ; $ box = imagettftext ( $ image , $ fontSize , $ angle , $ x , $ y , $ foreColor , $ this -> fontFile , $ letter ) ; $ x = $ box [ 2 ] + $ this -> offset ; } imagecolordeallocate ( $ image , $ foreColor ) ; ob_start ( ) ; imagepng ( $ image ) ; imagedestroy ( $ image ) ; return ob_get_clean ( ) ; }
6122	public function permissionGetNameById ( $ permid ) { foreach ( $ this -> permissionList ( ) as $ name => $ perm ) { if ( $ perm [ "permid" ] == $ permid ) { return new Ts3Exception ( $ name ) ; } } throw new Ts3Exception ( "invalid permission ID" , 0xA02 ) ; }
7722	function meth_Misc_Alert ( $ Src , $ Msg , $ NoErrMsg = false , $ SrcType = false ) { $ this -> ErrCount ++ ; if ( $ this -> NoErr || ( php_sapi_name === 'cli' ) ) { $ t = array ( '' , '' , '' , '' , '' ) ; } else { $ t = array ( '<br /><b>' , '</b>' , '<em>' , '</em>' , '<br />' ) ; $ Msg = htmlentities ( $ Msg ) ; } if ( ! is_string ( $ Src ) ) { if ( $ SrcType === false ) $ SrcType = 'in field' ; if ( isset ( $ Src -> PrmLst [ 'tbstype' ] ) ) { $ Msg = 'Column \'' . $ Src -> SubName . '\' is expected but missing in the current record.' ; $ Src = 'Parameter \'' . $ Src -> PrmLst [ 'tbstype' ] . '=' . $ Src -> SubName . '\'' ; $ NoErrMsg = false ; } else { $ Src = $ SrcType . ' ' . $ this -> _ChrOpen . $ Src -> FullName . '...' . $ this -> _ChrClose ; } } $ x = $ t [ 0 ] . 'TinyButStrong Error' . $ t [ 1 ] . ' ' . $ Src . ': ' . $ Msg ; if ( $ NoErrMsg ) $ x = $ x . ' ' . $ t [ 2 ] . 'This message can be cancelled using parameter \'noerr\'.' . $ t [ 3 ] ; $ x = $ x . $ t [ 4 ] . "\n" ; if ( $ this -> NoErr ) { $ this -> ErrMsg .= $ x ; } else { if ( php_sapi_name !== 'cli' ) { $ x = str_replace ( $ this -> _ChrOpen , $ this -> _ChrProtect , $ x ) ; } echo $ x ; } return false ; }
7300	public static function load_class ( $ class_name = NULL ) { if ( NULL === $ class_name ) { foreach ( glob ( dirname ( __FILE__ ) . '/*.php' ) as $ path ) { require_once $ path ; } } else { if ( 0 !== strpos ( $ class_name , 'Iac_' ) ) return FALSE ; $ path = dirname ( __FILE__ ) . '/class-' . $ class_name . '.php' ; if ( file_exists ( $ path ) ) { require_once $ path ; return TRUE ; } } return FALSE ; }
3236	public function getTotalPriceAttribute ( ) { if ( empty ( $ this -> shopCalculations ) ) $ this -> runCalculations ( ) ; return round ( $ this -> shopCalculations -> totalPrice , 2 ) ; }
12187	public function setDefaultOptions ( ) { foreach ( $ this -> _defaultOptions as $ k => $ v ) { if ( ! array_key_exists ( $ k , $ this -> _options ) ) { $ this -> _options [ $ k ] = $ v ; } } return true ; }
3196	public function getConsumedExtraTime ( $ tags = null , $ maxTime = 0 , $ target = TimePoint :: TARGET_SERVER ) { if ( $ maxTime ) { $ totalConsumed = $ this -> compute ( $ tags , $ target ) ; $ consumedExtraTime = $ totalConsumed - $ maxTime < 0 ? 0 : $ totalConsumed - $ maxTime ; $ this -> setConsumedExtraTime ( $ consumedExtraTime ) -> save ( ) ; } return $ this -> consumedExtraTime ; }
6822	protected function getGoodAccountNumber ( TaxRuleInterface $ rule , float $ rate , string $ origin ) { foreach ( $ this -> accounts as $ account ) { if ( $ account -> getType ( ) !== AccountingTypes :: TYPE_GOOD ) { continue ; } if ( $ account -> getTaxRule ( ) !== $ rule ) { continue ; } if ( is_null ( $ account -> getTax ( ) ) ) { if ( $ rate == 0 ) { return $ account -> getNumber ( ) ; } continue ; } if ( 0 === bccomp ( $ account -> getTax ( ) -> getRate ( ) , $ rate , 5 ) ) { return $ account -> getNumber ( ) ; } } throw new LogicException ( sprintf ( "No goods account number configured for tax rule '%s' and tax rate %s (%s)" , $ rule -> getName ( ) , $ rate , $ origin ) ) ; }
10868	public function getById ( int $ id ) { return $ this -> getList ( ) -> where ( [ $ this -> tableName [ 0 ] . '.' . self :: COLUMN_ID => $ id ] ) -> fetch ( ) ; }
44	public function dispatchScript ( $ eventName , $ devMode = false , $ additionalArgs = array ( ) , $ flags = array ( ) ) { return $ this -> doDispatch ( new Script \ Event ( $ eventName , $ this -> composer , $ this -> io , $ devMode , $ additionalArgs , $ flags ) ) ; }
1925	public function convertToPaletteImage ( ) { if ( ! imageistruecolor ( $ this -> gdResource ) ) { return $ this ; } $ width = imagesx ( $ this -> gdResource ) ; $ height = imagesy ( $ this -> gdResource ) ; $ transparentColor = null ; if ( $ this -> countColors ( 256 ) <= 256 ) { $ paletteImage = imagecreate ( $ width , $ height ) ; $ colors = array ( ) ; $ isTransparent = false ; for ( $ x = 0 ; $ x < $ width ; $ x ++ ) { for ( $ y = 0 ; $ y < $ height ; $ y ++ ) { $ color = imagecolorat ( $ this -> gdResource , $ x , $ y ) ; if ( ( ( $ color >> 24 ) & 0x7F ) === 127 ) { $ isTransparent = true ; } else { $ colors [ $ color & 0xFFFFFF ] = true ; } } } $ colors = array_keys ( $ colors ) ; foreach ( $ colors as $ index => $ color ) { imagecolorset ( $ paletteImage , $ index , ( $ color >> 16 ) & 0xFF , ( $ color >> 8 ) & 0xFF , $ color & 0xFF ) ; } if ( $ isTransparent ) { $ transparentColor = imagecolorallocate ( $ paletteImage , 0 , 0 , 0 ) ; imagecolortransparent ( $ paletteImage , $ transparentColor ) ; } imagecopy ( $ paletteImage , $ this -> gdResource , 0 , 0 , 0 , 0 , $ width , $ height ) ; } else { $ paletteImage = imagecreatetruecolor ( $ width , $ height ) ; imagealphablending ( $ paletteImage , false ) ; imagesavealpha ( $ paletteImage , true ) ; imagecopy ( $ paletteImage , $ this -> gdResource , 0 , 0 , 0 , 0 , $ width , $ height ) ; imagetruecolortopalette ( $ paletteImage , false , 255 ) ; $ transparentColor = imagecolorallocate ( $ paletteImage , 0 , 0 , 0 ) ; imagecolortransparent ( $ paletteImage , $ transparentColor ) ; } if ( $ transparentColor !== null ) { for ( $ x = 0 ; $ x < $ width ; $ x ++ ) { for ( $ y = 0 ; $ y < $ height ; $ y ++ ) { if ( ( ( imagecolorat ( $ this -> gdResource , $ x , $ y ) >> 24 ) & 0x7F ) === 127 ) { imagefilledrectangle ( $ paletteImage , $ x , $ y , $ x , $ y , $ transparentColor ) ; } } } } imagedestroy ( $ this -> gdResource ) ; $ this -> gdResource = $ paletteImage ; return $ this ; }
1810	public function adjustDcaByType ( $ dc ) { $ objCte = Contao \ ContentModel :: findByPk ( $ dc -> id ) ; if ( $ objCte === null ) { return ; } switch ( $ objCte -> type ) { case 'hyperlink' : unset ( $ GLOBALS [ 'TL_DCA' ] [ 'tl_content' ] [ 'fields' ] [ 'imageUrl' ] ) ; break ; case 'image' : $ GLOBALS [ 'TL_DCA' ] [ 'tl_content' ] [ 'fields' ] [ 'imagemargin' ] [ 'eval' ] [ 'tl_class' ] .= ' clr' ; break ; } }
2004	public function addAttributes ( $ arrAttributes ) { parent :: addAttributes ( $ arrAttributes ) ; if ( $ this -> type != 'number' ) { return ; } foreach ( array ( 'minlength' , 'minval' , 'maxlength' , 'maxval' ) as $ name ) { if ( isset ( $ arrAttributes [ $ name ] ) ) { $ this -> $ name = $ arrAttributes [ $ name ] ; } } }
3407	public function setLockStore ( StoreInterface $ store ) : Factory { $ this -> lockFactory = new Factory ( $ store ) ; return $ this -> lockFactory ; }
6733	public function run ( Request $ request ) { $ this -> stopwatch = microtime ( true ) ; $ starttime = $ request -> server -> get ( 'REQUEST_TIME_FLOAT' ) ; $ this -> log ( "Router: ->run() called. Starting clock at REQUEST_TIME+%.2fms" , microtime ( true ) - $ starttime ) ; try { $ response = $ this -> process ( $ request ) ; } catch ( \ Throwable $ e ) { $ this -> log ( "Router: Exception" ) ; $ response = $ this -> handleException ( $ e , $ request ) ; } $ this -> log ( "Router: Preparing to send response" ) ; $ response -> prepare ( $ request ) ; $ response -> send ( ) ; $ this -> log ( "Router: Response sent" ) ; }
10018	public function removeNamedRange ( $ namedRange , Worksheet $ pSheet = null ) { if ( $ pSheet === null ) { if ( isset ( $ this -> namedRanges [ $ namedRange ] ) ) { unset ( $ this -> namedRanges [ $ namedRange ] ) ; } } else { if ( isset ( $ this -> namedRanges [ $ pSheet -> getTitle ( ) . '!' . $ namedRange ] ) ) { unset ( $ this -> namedRanges [ $ pSheet -> getTitle ( ) . '!' . $ namedRange ] ) ; } } return $ this ; }
12507	public static function singleDocument ( $ document ) { if ( gettype ( $ document ) != "array" && gettype ( $ document ) != "object" ) { throw new ClusterpointException ( "\"->insert()\" function: parametr passed " . json_encode ( self :: escape_string ( $ document ) ) . " is not in valid document format." , 9002 ) ; } $ query = "{" ; $ first = true ; foreach ( $ document as $ key => $ value ) { if ( ! $ first ) { $ query .= "," ; } $ query .= '"' . self :: escape_string ( $ key ) . '" : ' . json_encode ( $ value ) ; $ first = false ; } $ query .= '}' ; return $ query ; }
1267	private function createRequest ( $ labelRecoveryRequest ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; $ trackRequest = $ xml -> appendChild ( $ xml -> createElement ( 'LabelRecoveryRequest' ) ) ; $ trackRequest -> setAttribute ( 'xml:lang' , 'en-US' ) ; $ request = $ trackRequest -> appendChild ( $ xml -> createElement ( 'Request' ) ) ; $ node = $ xml -> importNode ( $ this -> createTransactionNode ( ) , true ) ; $ request -> appendChild ( $ node ) ; $ request -> appendChild ( $ xml -> createElement ( 'RequestAction' , 'LabelRecovery' ) ) ; $ labelSpecificationNode = $ trackRequest -> appendChild ( $ xml -> createElement ( 'LabelSpecification' ) ) ; if ( isset ( $ labelRecoveryRequest -> LabelSpecification ) ) { $ labelSpecificationNode -> appendChild ( $ xml -> createElement ( 'HTTPUserAgent' , $ labelRecoveryRequest -> LabelSpecification -> HTTPUserAgent ) ) ; $ labelImageFormatNode = $ labelSpecificationNode -> appendChild ( $ xml -> createElement ( 'LabelImageFormat' ) ) ; $ labelImageFormatNode -> appendChild ( $ xml -> createElement ( 'Code' , $ labelRecoveryRequest -> LabelSpecification -> LabelImageFormat -> Code ) ) ; } if ( isset ( $ labelRecoveryRequest -> Translate ) ) { $ translateNode = $ trackRequest -> appendChild ( $ xml -> createElement ( 'Translate' ) ) ; $ translateNode -> appendChild ( $ xml -> createElement ( 'LanguageCode' , $ labelRecoveryRequest -> Translate -> LanguageCode ) ) ; $ translateNode -> appendChild ( $ xml -> createElement ( 'DialectCode' , $ labelRecoveryRequest -> Translate -> DialectCode ) ) ; $ translateNode -> appendChild ( $ xml -> createElement ( 'Code' , $ labelRecoveryRequest -> Translate -> Code ) ) ; } if ( isset ( $ labelRecoveryRequest -> LabelLinkIndicator ) ) { $ labelLinkIndicatorNode = $ trackRequest -> appendChild ( $ xml -> createElement ( 'LabelLinkIndicator' ) ) ; $ labelLinkIndicatorNode -> appendChild ( $ xml -> createElement ( 'LabelLinkIndicator' ) ) ; } if ( isset ( $ labelRecoveryRequest -> TrackingNumber ) ) { $ trackRequest -> appendChild ( $ xml -> createElement ( 'TrackingNumber' , $ labelRecoveryRequest -> TrackingNumber ) ) ; } if ( isset ( $ labelRecoveryRequest -> ReferenceNumber ) ) { $ referenceNumberNode = $ trackRequest -> appendChild ( $ xml -> createElement ( 'ReferenceNumber' ) ) ; $ referenceNumberNode -> appendChild ( $ xml -> createElement ( 'Value' , $ labelRecoveryRequest -> ReferenceNumber -> getValue ( ) ) ) ; } if ( isset ( $ labelRecoveryRequest -> ShipperNumber ) ) { $ trackRequest -> appendChild ( $ xml -> createElement ( 'ShipperNumber' , $ labelRecoveryRequest -> ShipperNumber ) ) ; } return $ xml -> saveXML ( ) ; }
6747	public function bootstrap ( $ appBootstrap , $ appenv , $ debug ) { $ bootstrap = ( new $ appBootstrap ( ) ) ; $ bootstrap -> initialize ( $ appenv , $ debug ) ; $ kernel = $ bootstrap -> getApplication ( ) ; $ this -> requestHandler = new RequestHandler ( $ kernel ) ; }
6948	private function setDueParameters ( $ query ) { $ query -> setParameter ( 'trigger_invoiced' , Trigger :: TRIGGER_INVOICED ) -> setParameter ( 'state_invoiced' , [ InvoiceStates :: STATE_PARTIAL , InvoiceStates :: STATE_COMPLETED ] ) -> setParameter ( 'trigger_fully_invoiced' , Trigger :: TRIGGER_FULLY_INVOICED ) -> setParameter ( 'state_fully_invoiced' , InvoiceStates :: STATE_COMPLETED ) -> setParameter ( 'trigger_shipped' , Trigger :: TRIGGER_SHIPPED ) -> setParameter ( 'state_shipped' , [ ShipmentStates :: STATE_PARTIAL , ShipmentStates :: STATE_COMPLETED ] ) -> setParameter ( 'trigger_fully_shipped' , Trigger :: TRIGGER_FULLY_SHIPPED ) -> setParameter ( 'state_fully_shipped' , ShipmentStates :: STATE_COMPLETED ) ; }
1096	protected function scopedAttributes ( $ node ) { $ keys = $ this -> node -> getScopedColumns ( ) ; if ( count ( $ keys ) == 0 ) return array ( ) ; $ values = array_map ( function ( $ column ) use ( $ node ) { return $ node -> getAttribute ( $ column ) ; } , $ keys ) ; return array_combine ( $ keys , $ values ) ; }
6461	public function shouldSeeThumbnail ( ) { $ thumb = false ; foreach ( [ '.upload-preview' , '.media-thumbnail img' , '.image-preview img' ] as $ selector ) { if ( $ thumb ) { break ; } $ thumb = $ this -> findByCss ( $ selector ) ; } if ( null === $ thumb ) { throw new \ Exception ( 'An expected image tag was not found.' ) ; } $ file = explode ( '?' , $ thumb -> getAttribute ( 'src' ) ) ; $ file = reset ( $ file ) ; $ curl = new CurlService ( ) ; list ( , $ info ) = $ curl -> execute ( 'GET' , $ file ) ; if ( empty ( $ info ) || strpos ( $ info [ 'content_type' ] , 'image/' ) === false ) { throw new FileNotFoundException ( sprintf ( '%s did not return an image' , $ file ) ) ; } }
4683	public static function stop ( $ key = 'default' ) : void { if ( isset ( self :: $ timers [ $ key ] ) ) { self :: $ timers [ $ key ] -> stop ( ) ; } else { throw new \ LogicException ( 'Stopping timer when the given key timer was not initialized.' ) ; } }
2592	public static function createRequestCreator ( $ params , $ libIdentifier ) { $ params -> receivedFrom = self :: makeReceivedFrom ( $ params -> receivedFrom , $ libIdentifier ) ; $ theRequestCreator = new Base ( $ params ) ; return $ theRequestCreator ; }
3809	protected function applyLegendConditions ( $ attributeId , $ activeLegendId ) { if ( ! isset ( $ this -> conditions [ $ activeLegendId ] ) ) { return ; } if ( ! isset ( $ this -> conditions [ $ attributeId ] ) ) { $ this -> conditions [ $ attributeId ] = new PropertyConditionChain ( ) ; } $ this -> conditions [ $ attributeId ] -> addCondition ( $ this -> conditions [ $ activeLegendId ] ) ; }
10318	function getBlocks ( $ fromDate = null , $ toDate = null , $ contactIds = null , $ contactEmails = null , $ contactExternalIds = null , $ reasons = null , $ oldStatus = null , $ newStatus = null , $ excludeAnonymousBlocks = false , $ standardFields = null , $ customFields = null , $ pageIndex = 1 , $ pageSize = 100 ) { $ params = $ this -> createQueryParameters ( $ pageIndex , $ pageSize , $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , null , null , null ) ; $ params = $ this -> appendArrayFields ( $ params , "standard_field" , $ standardFields ) ; $ params = $ this -> appendArrayFields ( $ params , "custom_field" , $ customFields ) ; if ( isset ( $ embedEmailClientInfos ) ) $ params [ 'embed_email_client_infos' ] = ( $ embedEmailClientInfos == true ) ? "true" : "false" ; if ( isset ( $ excludeAnonymousBlocks ) ) $ params [ 'exclude_anonymous_blocks' ] = ( $ excludeAnonymousBlocks == true ) ? "true" : "false" ; $ params = $ this -> appendArrayFields ( $ params , "reasons" , $ reasons ) ; if ( isset ( $ oldStatus ) ) $ params [ 'old_status' ] = $ oldStatus ; if ( isset ( $ newStatus ) ) $ params [ 'new_status' ] = $ newStatus ; return $ this -> get ( 'reports/blocks' , $ params ) ; }
12004	public static function objectToArray ( $ mObject ) : array { if ( is_object ( $ mObject ) ) { $ mObject = ( array ) $ mObject ; } if ( is_array ( $ mObject ) ) { $ aNew = array ( ) ; foreach ( $ mObject as $ sKey => $ mValues ) { $ sKey = preg_replace ( "/^\\0(.*)\\0/" , "" , $ sKey ) ; $ aNew [ $ sKey ] = self :: objectToArray ( $ mValues ) ; } } else { $ aNew = $ mObject ; } return $ aNew ; }
6945	protected function watch ( OrderPaymentInterface $ payment ) { $ order = $ payment -> getOrder ( ) ; if ( ! $ order -> isAutoNotify ( ) || $ order -> isSample ( ) ) { return ; } if ( ! $ payment -> getMethod ( ) -> isManual ( ) ) { return ; } if ( ! $ this -> didStateChangeTo ( $ payment , PaymentStates :: STATE_CAPTURED ) ) { return ; } foreach ( $ order -> getNotifications ( ) as $ n ) { if ( $ n -> getType ( ) !== NotificationTypes :: PAYMENT_CAPTURED ) { continue ; } if ( $ n -> hasData ( 'payment' ) && $ n -> getData ( 'payment' ) === $ payment -> getNumber ( ) ) { return ; } } $ this -> notify ( NotificationTypes :: PAYMENT_CAPTURED , $ payment ) ; }
134	public function isPackageInstalled ( InstalledRepositoryInterface $ repo , PackageInterface $ package ) { if ( $ package instanceof AliasPackage ) { return $ repo -> hasPackage ( $ package ) && $ this -> isPackageInstalled ( $ repo , $ package -> getAliasOf ( ) ) ; } return $ this -> getInstaller ( $ package -> getType ( ) ) -> isInstalled ( $ repo , $ package ) ; }
10860	protected function createObject ( string $ typeName , ? bool $ nullable = false , ? bool $ checkCycles = true , ? bool $ treatAsNotFound = true ) : ? object { if ( $ checkCycles ) { $ this -> underConstruction [ $ typeName ] = true ; } try { if ( ! isset ( $ this -> typeCache [ $ typeName ] ) ) { if ( \ class_exists ( $ typeName ) || \ interface_exists ( $ typeName , false ) ) { $ this -> typeCache [ $ typeName ] = new \ ReflectionClass ( $ typeName ) ; } else { $ this -> typeCache [ $ typeName ] = false ; } } if ( $ this -> typeCache [ $ typeName ] === false ) { if ( $ nullable ) { return null ; } if ( $ treatAsNotFound ) { throw new NotFoundException ( \ sprintf ( 'Cannot load type: %s' , $ typeName ) ) ; } throw new ContainerException ( \ sprintf ( 'Cannot load type: %s' , $ typeName ) ) ; } if ( ! $ this -> typeCache [ $ typeName ] -> isInstantiable ( ) ) { if ( $ nullable ) { return null ; } throw new NotFoundException ( \ sprintf ( 'Type is not instantiable: %s' , $ typeName ) ) ; } if ( isset ( $ this -> constructorCache [ $ typeName ] ) ) { $ con = $ this -> constructorCache [ $ typeName ] ; } else { $ con = $ this -> constructorCache [ $ typeName ] = $ this -> typeCache [ $ typeName ] -> getConstructor ( ) ? : false ; } return ( $ con === false ) ? new $ typeName ( ) : new $ typeName ( ... $ this -> populateArguments ( $ con , null , $ typeName ) ) ; } finally { if ( $ checkCycles ) { unset ( $ this -> underConstruction [ $ typeName ] ) ; } } }
1091	public function aggregate ( $ function , $ columns = array ( '*' ) ) { if ( ! isset ( $ this -> groups ) ) $ this -> reOrderBy ( null ) ; return parent :: aggregate ( $ function , $ columns ) ; }
2727	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ service = $ this -> api -> checkServiceDetails ( ) ; $ currActiveVersion = $ this -> vcl -> determineVersions ( $ service -> versions ) ; $ snippet = $ this -> config -> getVclSnippets ( Config :: VCL_WAF_PATH , Config :: VCL_WAF_ALLOWLIST_SNIPPET ) ; $ acls = $ this -> prepareAcls ( $ this -> request -> getParam ( 'acls' ) ) ; $ allowedItems = $ acls ; $ strippedAllowedItems = substr ( $ allowedItems , 0 , strrpos ( $ allowedItems , '||' , - 1 ) ) ; foreach ( $ snippet as $ key => $ value ) { if ( $ strippedAllowedItems === '' ) { $ value = '' ; } else { $ value = str_replace ( '####WAF_ALLOWLIST####' , $ strippedAllowedItems , $ value ) ; } $ snippetName = Config :: FASTLY_MAGENTO_MODULE . '_waf_' . $ key ; $ snippetId = $ this -> api -> getSnippet ( $ currActiveVersion [ 'active_version' ] , $ snippetName ) -> id ; $ params = [ 'name' => $ snippetId , 'content' => $ value ] ; $ this -> api -> updateSnippet ( $ params ) ; } $ this -> cacheTypeList -> cleanType ( 'config' ) ; $ this -> systemConfig -> clean ( ) ; return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
12131	public function handle ( ) { $ view = $ this -> application -> createInstance ( "view" , [ $ this -> application -> response , $ this -> application -> createInstance ( "viewengine" , [ $ this -> application -> response ] ) , $ this -> application ] ) ; $ view -> setData ( "title" , "An Error Occured" ) ; $ this -> application -> response -> send ( $ view -> render ( "errors/error" ) ) ; return Handler :: LAST_HANDLER ; }
5552	public function getResponseCode ( ) { if ( is_integer ( $ this -> focus ) ) { return $ this -> frames [ $ this -> focus ] -> getResponseCode ( ) ; } return $ this -> frameset -> getResponseCode ( ) ; }
11550	private function preencherLista ( $ pagamentos ) { $ resultado = array ( ) ; foreach ( $ pagamentos as $ pagamento ) { $ resultado [ ] = $ pagamento -> setAutenticacao ( $ this -> getAutenticacaoManager ( ) -> obterAutenticacaoBasica ( $ pagamento -> getAutenticacaoId ( ) ) ) ; } return $ resultado ; }
9022	public function getStopWords ( $ string , $ language = 'english' ) { $ words = $ this -> getWords ( $ string ) ; $ filter = new StopWordsFilter ( $ language ) ; $ stopWords = [ ] ; foreach ( $ words as $ word ) { if ( ! is_null ( $ filter -> filter ( $ word ) ) ) { $ stopWords [ ] = $ word ; } } return $ stopWords ; }
4629	protected function prepareRequestParameters ( ) { if ( $ this -> command -> hasParameters ( ) ) { $ this -> query = http_build_query ( $ this -> command -> getParameters ( ) , '' , '&' , PHP_QUERY_RFC3986 ) ; } return $ this ; }
3434	public function refreshGroups ( ) { if ( $ this -> id === null ) { return [ ] ; } global $ USER ; $ this -> fields [ 'GROUP_ID' ] = $ this -> isCurrent ( ) ? $ USER -> getUserGroupArray ( ) : static :: $ bxObject -> getUserGroup ( $ this -> id ) ; $ this -> groupsAreFetched = true ; return $ this -> fields [ 'GROUP_ID' ] ; }
6046	protected function registerPlugin ( $ name ) { $ view = $ this -> getView ( ) ; AdminUiAsset :: register ( $ view ) ; $ id = $ this -> options [ 'id' ] ; if ( $ this -> clientOptions !== false ) { $ options = empty ( $ this -> clientOptions ) ? '' : Json :: encode ( $ this -> clientOptions ) ; $ js = "jQuery('#$id').$name($options);" ; $ view -> registerJs ( $ js ) ; } if ( ! empty ( $ this -> clientEvents ) ) { $ js = [ ] ; foreach ( $ this -> clientEvents as $ event => $ handler ) { $ js [ ] = "jQuery('#$id').on('$event', $handler);" ; } $ view -> registerJs ( implode ( "\n" , $ js ) ) ; } }
1509	public function getResourceUrl ( string $ type , $ id , array $ params = [ ] ) : string { return $ this -> url ( [ $ type , $ id ] , $ params ) ; }
6480	private function getSetCookieHeaderValue ( Cookie $ cookie ) : string { $ headerValue = "{$cookie->getName()}=" . urlencode ( $ cookie -> getValue ( ) ) ; if ( ( $ expiration = $ cookie -> getExpiration ( ) ) !== null ) { $ headerValue .= '; Expires=' . $ expiration -> format ( self :: EXPIRATION_DATE_FORMAT ) ; } if ( ( $ maxAge = $ cookie -> getMaxAge ( ) ) !== null ) { $ headerValue .= "; Max-Age=$maxAge" ; } if ( ( $ domain = $ cookie -> getDomain ( ) ) !== null ) { $ headerValue .= '; Domain=' . urlencode ( $ domain ) ; } if ( ( $ path = $ cookie -> getPath ( ) ) !== null ) { $ headerValue .= '; Path=' . urlencode ( $ path ) ; } if ( $ cookie -> isSecure ( ) ) { $ headerValue .= '; Secure' ; } if ( $ cookie -> isHttpOnly ( ) ) { $ headerValue .= '; HttpOnly' ; } if ( ( $ sameSite = $ cookie -> getSameSite ( ) ) !== null ) { $ headerValue .= '; SameSite=' . urlencode ( $ sameSite ) ; } return $ headerValue ; }
12801	public function createItem ( $ name , array $ options = array ( ) ) { if ( ! empty ( $ options [ 'admin' ] ) ) { $ admin = $ options [ 'admin' ] ; if ( ! $ options [ 'admin' ] instanceof AdminInterface ) { $ admin = $ this -> container -> get ( 'sonata.admin.pool' ) -> getAdminByAdminCode ( $ admin ) ; } $ action = isset ( $ options [ 'admin_action' ] ) ? $ options [ 'admin_action' ] : 'list' ; $ options [ 'uri' ] = $ admin -> generateUrl ( $ action ) ; $ options [ 'translationDomain' ] = $ admin -> getTranslationDomain ( ) ; } if ( ! empty ( $ options [ 'route' ] ) ) { $ params = isset ( $ options [ 'routeParameters' ] ) ? $ options [ 'routeParameters' ] : array ( ) ; $ absolute = isset ( $ options [ 'routeAbsolute' ] ) ? $ options [ 'routeAbsolute' ] : false ; $ options [ 'uri' ] = $ this -> generator -> generate ( $ options [ 'route' ] , $ params , $ absolute ) ; } $ item = new MenuItem ( $ name , $ this ) ; $ options = array_merge ( array ( 'uri' => null , 'label' => null , 'attributes' => array ( ) , 'linkAttributes' => array ( ) , 'childrenAttributes' => array ( ) , 'labelAttributes' => array ( ) , 'extras' => array ( ) , 'display' => true , 'displayChildren' => true , 'translationDomain' => 'messages' , 'displayLink' => true , 'displayLabel' => true , ) , $ options ) ; $ item -> setUri ( $ options [ 'uri' ] ) -> setLabel ( $ options [ 'label' ] ) -> setAttributes ( $ options [ 'attributes' ] ) -> setLinkAttributes ( $ options [ 'linkAttributes' ] ) -> setChildrenAttributes ( $ options [ 'childrenAttributes' ] ) -> setLabelAttributes ( $ options [ 'labelAttributes' ] ) -> setExtras ( $ options [ 'extras' ] ) -> setDisplay ( $ options [ 'display' ] ) -> setDisplayChildren ( $ options [ 'displayChildren' ] ) -> setTranslationDomain ( $ options [ 'translationDomain' ] ) -> setDisplayLink ( $ options [ 'displayLink' ] ) -> setDisplayLabel ( $ options [ 'displayLabel' ] ) ; return $ item ; return parent :: createItem ( $ name , $ options ) ; }
11782	protected function generateSourceFromChildren ( ) { $ i = 1 ; $ children = array ( ) ; foreach ( $ this -> children as $ child ) { $ childValue = Yaml :: parse ( $ child -> getSource ( ) ) ; if ( is_array ( $ childValue ) && array_key_exists ( "type" , $ childValue ) ) { $ childValue [ "type" ] = $ child -> getType ( ) ; } $ children [ 'item' . $ i ] = $ childValue ; $ i ++ ; } $ source = array ( "children" => $ children , ) ; if ( ! empty ( $ this -> tags ) ) { $ source [ "tags" ] = $ this -> tags ; } $ source [ "type" ] = $ this -> type ; return $ source ; }
11367	public static function getMimeType ( $ filename = '' ) { $ ext = strtolower ( substr ( $ filename , strrpos ( $ filename , '.' ) ) ) ; switch ( $ ext ) { case '.jpeg' : case '.jpg' : $ mimetype = 'image/jpeg' ; break ; case '.gif' : $ mimetype = 'image/gif' ; break ; case '.png' : $ mimetype = 'image/png' ; break ; case '.txt' : $ mimetype = 'text/plain' ; break ; case '.html' : case '.htm' : $ mimetype = 'text/html' ; break ; case '.zip' : $ mimetype = 'application/x-zip-compressed' ; break ; default : $ mimetype = 'application/octet-stream' ; } return $ mimetype ; }
10774	protected function loginByCookie ( ) { $ value = Yii :: $ app -> getRequest ( ) -> getCookies ( ) -> getValue ( $ this -> identityCookie [ 'name' ] ) ; if ( $ value === null ) { return ; } $ data = json_decode ( $ value , true ) ; if ( count ( $ data ) !== 3 || ! isset ( $ data [ 0 ] , $ data [ 1 ] , $ data [ 2 ] ) ) { return ; } list ( $ id , $ authKey , $ duration ) = $ data ; $ class = $ this -> identityClass ; $ identity = $ class :: findIdentity ( $ id ) ; if ( $ identity === null ) { return ; } elseif ( ! $ identity instanceof IdentityInterface ) { throw new InvalidValueException ( "$class::findIdentity() must return an object implementing IdentityInterface." ) ; } if ( $ identity -> validateAuthKey ( $ authKey ) ) { if ( $ this -> beforeLogin ( $ identity , true , $ duration ) ) { $ this -> switchIdentity ( $ identity , $ this -> autoRenewCookie ? $ duration : 0 ) ; $ ip = Yii :: $ app -> getRequest ( ) -> getUserIP ( ) ; Yii :: info ( "User '$id' logged in from $ip via cookie." , __METHOD__ ) ; $ this -> afterLogin ( $ identity , true , $ duration ) ; } } else { Yii :: warning ( "Invalid auth key attempted for user '$id': $authKey" , __METHOD__ ) ; } }
987	public function chargeParams ( ) { $ chargeDetails = [ 'name' => $ this -> plan -> name , 'price' => $ this -> plan -> price , 'test' => $ this -> plan -> isTest ( ) , 'trial_days' => $ this -> plan -> hasTrial ( ) ? $ this -> plan -> trial_days : 0 , 'return_url' => URL :: secure ( Config :: get ( 'shopify-app.billing_redirect' ) , [ 'plan_id' => $ this -> plan -> id ] ) , ] ; if ( isset ( $ this -> plan -> capped_amount ) && $ this -> plan -> capped_amount > 0 ) { $ chargeDetails [ 'capped_amount' ] = $ this -> plan -> capped_amount ; $ chargeDetails [ 'terms' ] = $ this -> plan -> terms ; } return $ chargeDetails ; }
7929	public function setDefaultGroup ( $ defaultGroup ) { list ( $ defaultGroup ) = $ this -> fireEvent ( 'default-group.set' , [ $ defaultGroup ] ) ; $ this -> defaultGroup = $ defaultGroup ; return $ this ; }
773	public function actionExtract ( $ configFile = null ) { $ this -> initConfig ( $ configFile ) ; $ files = FileHelper :: findFiles ( realpath ( $ this -> config [ 'sourcePath' ] ) , $ this -> config ) ; $ messages = [ ] ; foreach ( $ files as $ file ) { $ messages = array_merge_recursive ( $ messages , $ this -> extractMessages ( $ file , $ this -> config [ 'translator' ] , $ this -> config [ 'ignoreCategories' ] ) ) ; } $ catalog = isset ( $ this -> config [ 'catalog' ] ) ? $ this -> config [ 'catalog' ] : 'messages' ; if ( in_array ( $ this -> config [ 'format' ] , [ 'php' , 'po' ] ) ) { foreach ( $ this -> config [ 'languages' ] as $ language ) { $ dir = $ this -> config [ 'messagePath' ] . DIRECTORY_SEPARATOR . $ language ; if ( ! is_dir ( $ dir ) && ! @ mkdir ( $ dir ) ) { throw new Exception ( "Directory '{$dir}' can not be created." ) ; } if ( $ this -> config [ 'format' ] === 'po' ) { $ this -> saveMessagesToPO ( $ messages , $ dir , $ this -> config [ 'overwrite' ] , $ this -> config [ 'removeUnused' ] , $ this -> config [ 'sort' ] , $ catalog , $ this -> config [ 'markUnused' ] ) ; } else { $ this -> saveMessagesToPHP ( $ messages , $ dir , $ this -> config [ 'overwrite' ] , $ this -> config [ 'removeUnused' ] , $ this -> config [ 'sort' ] , $ this -> config [ 'markUnused' ] ) ; } } } elseif ( $ this -> config [ 'format' ] === 'db' ) { $ db = Instance :: ensure ( $ this -> config [ 'db' ] , Connection :: className ( ) ) ; $ sourceMessageTable = isset ( $ this -> config [ 'sourceMessageTable' ] ) ? $ this -> config [ 'sourceMessageTable' ] : '{{%source_message}}' ; $ messageTable = isset ( $ this -> config [ 'messageTable' ] ) ? $ this -> config [ 'messageTable' ] : '{{%message}}' ; $ this -> saveMessagesToDb ( $ messages , $ db , $ sourceMessageTable , $ messageTable , $ this -> config [ 'removeUnused' ] , $ this -> config [ 'languages' ] , $ this -> config [ 'markUnused' ] ) ; } elseif ( $ this -> config [ 'format' ] === 'pot' ) { $ this -> saveMessagesToPOT ( $ messages , $ this -> config [ 'messagePath' ] , $ catalog ) ; } }
8197	public function collect ( Traversable $ iterator ) { $ this -> deprecations = array ( ) ; set_error_handler ( array ( $ this , 'errorHandler' ) ) ; foreach ( $ iterator as $ name => $ contents ) { try { $ this -> twig -> parse ( $ this -> twig -> tokenize ( new Twig_Source ( $ contents , $ name ) ) ) ; } catch ( Twig_Error_Syntax $ e ) { } } restore_error_handler ( ) ; $ deprecations = $ this -> deprecations ; $ this -> deprecations = array ( ) ; return $ deprecations ; }
3474	public function handle ( ) { if ( ! $ this -> token ) { $ this -> error ( 'You must paste your Discord token (App Bot User token) into your `services.php` config file.' ) ; $ this -> error ( 'View the README for more info: https://github.com/laravel-notification-channels/discord#installation' ) ; return - 1 ; } if ( ! $ this -> confirm ( 'Is the bot already added to your server?' ) ) { $ clientId = $ this -> ask ( 'What is your Discord app client ID?' ) ; $ this -> warn ( 'Add the bot to your server by visiting this link: https://discordapp.com/oauth2/authorize?&client_id=' . $ clientId . '&scope=bot&permissions=0' ) ; if ( ! $ this -> confirm ( 'Continue?' , true ) ) { return - 1 ; } } $ this -> warn ( "Attempting to identify the bot with Discord's websocket gateway..." ) ; $ this -> gateway = $ this -> getGateway ( ) ; $ this -> warn ( "Connecting to '$this->gateway'..." ) ; $ client = $ this -> getSocket ( $ this -> gateway ) ; $ client -> send ( json_encode ( [ 'op' => 2 , 'd' => [ 'token' => $ this -> token , 'v' => 3 , 'compress' => false , 'properties' => [ '$os' => PHP_OS , '$browser' => 'laravel-notification-channels-discord' , '$device' => 'laravel-notification-channels-discord' , '$referrer' => '' , '$referring_domain' => '' , ] , ] , ] ) ) ; $ response = $ client -> receive ( ) ; $ identified = Arr :: get ( json_decode ( $ response , true ) , 'op' ) === 10 ; if ( ! $ identified ) { $ this -> error ( "Discord responded with an error while trying to identify the bot: $response" ) ; return - 1 ; } $ this -> info ( 'Your bot has been identified by Discord and can now send API requests!' ) ; }
11601	private static function getBaseUrl ( ) : ? string { $ serverName = filter_input ( \ INPUT_SERVER , 'SERVER_NAME' , \ FILTER_SANITIZE_STRING ) ; if ( ! empty ( $ serverName ) ) { $ https = filter_input ( \ INPUT_SERVER , 'HTTPS' , \ FILTER_SANITIZE_STRING ) ; $ protocol = ! empty ( $ https ) && strtolower ( $ https ) === 'on' ? 'https' : 'http' ; return $ protocol . '://' . $ serverName ; } return null ; }
7367	protected function checkInvoiceIntegrity ( SaleItemInterface $ item , SaleItem $ constraint ) { $ sale = $ item -> getSale ( ) ; if ( ! $ sale instanceof Invoice \ InvoiceSubjectInterface ) { return ; } if ( empty ( $ sale -> getInvoices ( ) -> toArray ( ) ) ) { return ; } $ min = $ this -> invoiceCalculator -> calculateInvoicedQuantity ( $ item ) ; $ qty = $ item -> getTotalQuantity ( ) ; if ( 1 === bccomp ( $ min , 0 , 3 ) && 1 === bccomp ( $ min , $ qty , 3 ) ) { $ this -> context -> buildViolation ( $ constraint -> quantity_is_lower_than_invoiced , [ '%min%' => $ min , ] ) -> atPath ( 'quantity' ) -> addViolation ( ) ; throw new ValidationFailedException ( ) ; } }
2172	private function purgeSymfonyCache ( ) : void { $ filesystem = new Filesystem ( ) ; $ cacheDir = $ this -> getContainerParameter ( 'kernel.cache_dir' ) ; $ ref = new \ ReflectionObject ( $ this -> container ) ; $ containerDir = basename ( \ dirname ( $ ref -> getFileName ( ) ) ) ; $ finder = Finder :: create ( ) -> depth ( 0 ) -> exclude ( $ containerDir ) -> in ( $ cacheDir ) ; foreach ( $ finder as $ file ) { $ filesystem -> remove ( $ file -> getPathname ( ) ) ; } if ( \ function_exists ( 'opcache_reset' ) ) { opcache_reset ( ) ; } if ( \ function_exists ( 'apc_clear_cache' ) && ! ini_get ( 'apc.stat' ) ) { apc_clear_cache ( ) ; } }
12742	public function removeById ( $ connectionID ) { if ( isset ( $ this -> pool [ $ connectionID ] ) ) { $ this -> slotmap -> reset ( ) ; $ this -> slots = array_diff ( $ this -> slots , array ( $ connectionID ) ) ; unset ( $ this -> pool [ $ connectionID ] ) ; return true ; } return false ; }
419	private function validateCsrfTokenInternal ( $ clientSuppliedToken , $ trueToken ) { if ( ! is_string ( $ clientSuppliedToken ) ) { return false ; } $ security = Yii :: $ app -> security ; return $ security -> compareString ( $ security -> unmaskToken ( $ clientSuppliedToken ) , $ security -> unmaskToken ( $ trueToken ) ) ; }
12785	protected function generateIntersection ( $ combinationMask ) { $ combination = [ ] ; foreach ( str_split ( $ combinationMask ) as $ key => $ indicator ) { if ( $ indicator ) { $ combination [ ] = $ this -> arrays [ $ this -> arrayKeys [ $ key ] ] ; } } $ intersection = call_user_func_array ( 'array_intersect_assoc' , $ combination ) ; if ( count ( $ intersection ) >= $ this -> threshold ) { $ this -> intersections [ ] = $ intersection ; return ; } $ this -> noResultMasks [ ] = $ combinationMask ; }
4419	protected function checkPermissions ( ) { if ( $ this -> isGranted ( 'ROLE_NGBM_EDITOR' ) ) { return ; } if ( $ this -> isGranted ( 'nglayouts:ui:access' ) ) { return ; } $ exception = $ this -> createAccessDeniedException ( ) ; $ exception -> setAttributes ( 'nglayouts:ui:access' ) ; throw $ exception ; }
4455	public function attach ( string $ eventName , $ handler , int $ priority = 100 ) : void { if ( is_object ( $ handler ) == false && is_callable ( $ handler ) == false ) { throw new InvalidArgumentException ( sprintf ( 'Event handler must be either an object or a callable %s given.' , gettype ( $ handler ) ) ) ; } $ priorityQueue = $ this -> fetchQueue ( $ eventName ) ; $ priorityQueue -> insert ( $ handler , $ priority ) ; }
5067	public function setOpt ( int $ option , $ value ) : bool { return curl_setopt ( $ this -> ch , $ option , $ value ) ; }
5329	final public function push ( string $ data ) { if ( $ this -> generator === null ) { throw new \ Error ( "The parser is no longer writable" ) ; } $ this -> buffer .= $ data ; $ end = false ; try { while ( $ this -> buffer !== "" ) { if ( \ is_int ( $ this -> delimiter ) ) { if ( \ strlen ( $ this -> buffer ) < $ this -> delimiter ) { break ; } $ send = \ substr ( $ this -> buffer , 0 , $ this -> delimiter ) ; $ this -> buffer = \ substr ( $ this -> buffer , $ this -> delimiter ) ; } elseif ( \ is_string ( $ this -> delimiter ) ) { if ( ( $ position = \ strpos ( $ this -> buffer , $ this -> delimiter ) ) === false ) { break ; } $ send = \ substr ( $ this -> buffer , 0 , $ position ) ; $ this -> buffer = \ substr ( $ this -> buffer , $ position + \ strlen ( $ this -> delimiter ) ) ; } else { $ send = $ this -> buffer ; $ this -> buffer = "" ; } $ this -> delimiter = $ this -> generator -> send ( $ send ) ; if ( ! $ this -> generator -> valid ( ) ) { $ end = true ; break ; } if ( $ this -> delimiter !== null && ( ! \ is_int ( $ this -> delimiter ) || $ this -> delimiter <= 0 ) && ( ! \ is_string ( $ this -> delimiter ) || ! \ strlen ( $ this -> delimiter ) ) ) { throw new InvalidDelimiterError ( $ this -> generator , \ sprintf ( "Invalid value yielded: Expected NULL, an int greater than 0, or a non-empty string; %s given" , \ is_object ( $ this -> delimiter ) ? \ sprintf ( "instance of %s" , \ get_class ( $ this -> delimiter ) ) : \ gettype ( $ this -> delimiter ) ) ) ; } } } catch ( \ Throwable $ exception ) { $ end = true ; throw $ exception ; } finally { if ( $ end ) { $ this -> generator = null ; } } }
10064	public function all ( ) { $ meta = $ this -> metaModel :: get ( [ 'key' , 'value' , 'type' ] ) ; $ data = [ ] ; foreach ( $ meta as $ m ) { $ data [ $ m -> key ] = $ m -> value ; } return $ data ; }
10240	public function calculateCellValue ( Cell $ pCell = null , $ resetLog = true ) { if ( $ pCell === null ) { return null ; } $ returnArrayAsType = self :: $ returnArrayAsType ; if ( $ resetLog ) { $ this -> formulaError = null ; $ this -> debugLog -> clearLog ( ) ; $ this -> cyclicReferenceStack -> clear ( ) ; $ this -> cyclicFormulaCounter = 1 ; self :: $ returnArrayAsType = self :: RETURN_ARRAY_AS_ARRAY ; } $ this -> cellStack [ ] = [ 'sheet' => $ pCell -> getWorksheet ( ) -> getTitle ( ) , 'cell' => $ pCell -> getCoordinate ( ) , ] ; try { $ result = self :: unwrapResult ( $ this -> _calculateFormulaValue ( $ pCell -> getValue ( ) , $ pCell -> getCoordinate ( ) , $ pCell ) ) ; $ cellAddress = array_pop ( $ this -> cellStack ) ; $ this -> spreadsheet -> getSheetByName ( $ cellAddress [ 'sheet' ] ) -> getCell ( $ cellAddress [ 'cell' ] ) ; } catch ( \ Exception $ e ) { $ cellAddress = array_pop ( $ this -> cellStack ) ; $ this -> spreadsheet -> getSheetByName ( $ cellAddress [ 'sheet' ] ) -> getCell ( $ cellAddress [ 'cell' ] ) ; throw new Exception ( $ e -> getMessage ( ) ) ; } if ( ( is_array ( $ result ) ) && ( self :: $ returnArrayAsType != self :: RETURN_ARRAY_AS_ARRAY ) ) { self :: $ returnArrayAsType = $ returnArrayAsType ; $ testResult = Functions :: flattenArray ( $ result ) ; if ( self :: $ returnArrayAsType == self :: RETURN_ARRAY_AS_ERROR ) { return Functions :: VALUE ( ) ; } if ( count ( $ testResult ) != 1 ) { $ r = array_keys ( $ result ) ; $ r = array_shift ( $ r ) ; if ( ! is_numeric ( $ r ) ) { return Functions :: VALUE ( ) ; } if ( is_array ( $ result [ $ r ] ) ) { $ c = array_keys ( $ result [ $ r ] ) ; $ c = array_shift ( $ c ) ; if ( ! is_numeric ( $ c ) ) { return Functions :: VALUE ( ) ; } } } $ result = array_shift ( $ testResult ) ; } self :: $ returnArrayAsType = $ returnArrayAsType ; if ( $ result === null ) { return 0 ; } elseif ( ( is_float ( $ result ) ) && ( ( is_nan ( $ result ) ) || ( is_infinite ( $ result ) ) ) ) { return Functions :: NAN ( ) ; } return $ result ; }
4154	protected function getBearerTokenCredentials ( ) { $ signingKey = rawurlencode ( $ this -> getConsumerKey ( ) ) . ':' . rawurlencode ( $ this -> getConsumerSecret ( ) ) ; return base64_encode ( $ signingKey ) ; }
11034	private function loadFromFile ( ) { if ( is_file ( $ this -> _file ) ) { $ this -> _params = require ( $ this -> _file ) ; } else { $ this -> _params = [ 'users' => [ ] ] ; } }
4555	protected function addJoinTranslation ( QueryBuilder $ queryBuilder , string $ resourceClass ) { $ rootAlias = $ queryBuilder -> getRootAliases ( ) [ 0 ] ; $ translationAlias = $ rootAlias . '_t' ; $ translationClass = call_user_func ( $ resourceClass . '::getTranslationEntityClass' ) ; $ parts = $ queryBuilder -> getDQLParts ( ) [ 'join' ] ; foreach ( $ parts as $ joins ) { foreach ( $ joins as $ join ) { if ( $ translationAlias === $ join -> getAlias ( ) ) { return $ translationAlias ; } } } $ queryBuilder -> leftJoin ( $ translationClass , $ translationAlias , Join :: WITH , $ rootAlias . '.id = ' . $ translationAlias . '.translatable' ) ; return $ translationAlias ; }
11485	protected function resolveClassArg ( ReflectionClass $ class , ReflectionParameter $ param , array $ params ) { $ name = '$' . $ param -> getName ( ) ; $ class = $ class -> getName ( ) ; while ( $ name !== null ) { if ( $ params && array_key_exists ( $ name , $ params ) ) { $ class = $ params [ $ name ] ; } if ( $ class instanceof Factory \ FactoryInterface ) { return $ class -> invoke ( $ this ) ; } if ( is_object ( $ class ) ) { return $ class ; } $ name = ( $ name != $ class ) ? $ class : null ; } try { return $ this -> resolve ( $ class ) ; } catch ( ReflectionException $ exception ) { if ( $ param -> isOptional ( ) ) { return null ; } throw $ exception ; } }
10432	protected function createServices ( ContainerBuilder $ container , $ classes , $ config , $ tag , $ method ) { if ( ! is_array ( $ tag ) ) { $ tag = [ $ tag ] ; } foreach ( $ classes as $ class ) { $ methods = $ this -> getMethods ( $ class ) ; $ definition = new Definition ( $ class ) ; $ this -> setProperties ( $ definition , $ config , $ methods ) ; $ this -> setTags ( $ definition , $ tag , $ method ) ; $ container -> setDefinition ( $ this -> getServiceName ( $ tag [ 0 ] ) , $ definition ) ; } }
2643	private function _purge ( $ uri , $ type , $ method = \ Zend_Http_Client :: POST , $ payload = null ) { if ( $ method == 'PURGE' ) { $ expiration = time ( ) + self :: PURGE_TOKEN_LIFETIME ; $ zendUri = \ Zend_Uri :: factory ( $ uri ) ; $ path = $ zendUri -> getPath ( ) ; $ stringToSign = $ path . $ expiration ; $ signature = hash_hmac ( 'sha1' , $ stringToSign , $ this -> config -> getServiceId ( ) ) ; $ token = $ expiration . '_' . urlencode ( $ signature ) ; $ headers = [ self :: FASTLY_HEADER_TOKEN . ': ' . $ token ] ; } else { $ headers = [ self :: FASTLY_HEADER_AUTH . ': ' . $ this -> config -> getApiKey ( ) ] ; } if ( $ this -> config -> canUseSoftPurge ( ) ) { array_push ( $ headers , self :: FASTLY_HEADER_SOFT_PURGE . ': 1' ) ; } $ result [ 'status' ] = true ; try { $ client = $ this -> curlFactory -> create ( ) ; $ client -> setConfig ( [ 'timeout' => self :: PURGE_TIMEOUT ] ) ; if ( $ method == 'PURGE' ) { $ client -> addOption ( CURLOPT_CUSTOMREQUEST , 'PURGE' ) ; } $ client -> write ( $ method , $ uri , '1.1' , $ headers , $ payload ) ; $ responseBody = $ client -> read ( ) ; $ responseCode = \ Zend_Http_Response :: extractCode ( $ responseBody ) ; $ responseMessage = \ Zend_Http_Response :: extractMessage ( $ responseBody ) ; $ client -> close ( ) ; if ( $ responseCode == '429' ) { throw new LocalizedException ( __ ( $ responseMessage ) ) ; } elseif ( $ responseCode != '200' ) { throw new LocalizedException ( __ ( $ responseCode . ': ' . $ responseMessage ) ) ; } } catch ( \ Exception $ e ) { $ this -> logger -> critical ( $ e -> getMessage ( ) , $ uri ) ; $ result [ 'status' ] = false ; $ result [ 'msg' ] = $ e -> getMessage ( ) ; } if ( empty ( $ type ) ) { return $ result ; } if ( $ this -> config -> areWebHooksEnabled ( ) && $ this -> config -> canPublishPurgeChanges ( ) ) { $ this -> sendWebHook ( '*initiated ' . $ type . '*' ) ; if ( $ this -> config -> canPublishPurgeDebugBacktrace ( ) == false ) { return $ result ; } $ this -> stackTrace ( $ type ) ; } return $ result ; }
6079	public function combineSlides ( array $ structure ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'structure' => $ structure ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/media/slides/combine' , $ parameters ) ; return $ result ; }
9674	public function allConditionalStyles ( Spreadsheet $ spreadsheet ) { $ aStyles = [ ] ; $ sheetCount = $ spreadsheet -> getSheetCount ( ) ; for ( $ i = 0 ; $ i < $ sheetCount ; ++ $ i ) { foreach ( $ spreadsheet -> getSheet ( $ i ) -> getConditionalStylesCollection ( ) as $ conditionalStyles ) { foreach ( $ conditionalStyles as $ conditionalStyle ) { $ aStyles [ ] = $ conditionalStyle ; } } } return $ aStyles ; }
3787	protected function getMetaModelById ( $ modelId ) { $ services = $ this -> getServiceContainer ( ) ; $ modelFactory = $ services -> getFactory ( ) ; $ name = $ modelFactory -> translateIdToMetaModelName ( $ modelId ) ; return $ modelFactory -> getMetaModel ( $ name ) ; }
5030	public function findPageBy ( $ repository , $ conditions ) { $ ret = $ this -> em -> getRepository ( $ repository ) -> findOneBy ( $ conditions ) ; if ( ! $ ret ) { throw new NotFoundHttpException ; } return $ ret ; }
12520	protected function getWhereFromParameter ( ParameterInterface $ parameter ) { if ( $ parameter instanceof IdAwareParameterInterface && $ parameter -> getId ( ) ) { return [ 'id' => $ parameter -> getId ( ) ] ; } else { return [ 'namespace' => $ parameter -> getNamespace ( ) , 'name' => $ parameter -> getName ( ) ] ; } }
2692	public function getFastlyUrl ( ) { $ baseFile = $ this -> getBaseFile ( ) ; $ url = $ this -> getBaseFileUrl ( $ baseFile ) ; $ imageQuality = $ this -> _scopeConfig -> getValue ( Config :: XML_FASTLY_IMAGE_OPTIMIZATION_IMAGE_QUALITY ) ; $ this -> setQuality ( $ imageQuality ) ; $ this -> fastlyParameters [ 'quality' ] = $ this -> _quality ; if ( $ this -> _scopeConfig -> isSetFlag ( Config :: XML_FASTLY_IMAGE_OPTIMIZATION_BG_COLOR ) == true ) { $ this -> fastlyParameters [ 'bg-color' ] = implode ( ',' , $ this -> _backgroundColor ) ; } if ( $ this -> _keepAspectRatio == true ) { $ this -> fastlyParameters [ 'fit' ] = 'bounds' ; } $ this -> fastlyUrl = $ url . '?' . $ this -> compileFastlyParameters ( ) ; }
12694	public function addOption ( $ name , $ shortcut = null , $ mode = null , $ description = '' , $ default = null ) : self { $ this -> cmd -> addOption ( $ name , $ shortcut , $ mode , $ description , $ default ) ; return $ this ; }
12820	public function execute ( callable $ callback , array $ vars ) : Response { $ arguments = $ this -> resolveDependencies ( $ callback , $ vars ) ; return call_user_func_array ( $ callback , $ arguments ) ; }
318	public function registerCssFile ( $ url , $ options = [ ] , $ key = null ) { $ url = Yii :: getAlias ( $ url ) ; $ key = $ key ? : $ url ; $ depends = ArrayHelper :: remove ( $ options , 'depends' , [ ] ) ; if ( empty ( $ depends ) ) { $ this -> cssFiles [ $ key ] = Html :: cssFile ( $ url , $ options ) ; } else { $ this -> getAssetManager ( ) -> bundles [ $ key ] = Yii :: createObject ( [ 'class' => AssetBundle :: className ( ) , 'baseUrl' => '' , 'css' => [ strncmp ( $ url , '//' , 2 ) === 0 ? $ url : ltrim ( $ url , '/' ) ] , 'cssOptions' => $ options , 'depends' => ( array ) $ depends , ] ) ; $ this -> registerAssetBundle ( $ key ) ; } }
12362	public function database ( $ db ) { $ connection = $ this -> connection ; $ connection -> db = $ db ; $ this -> constructConnections = $ connection ; $ connection = class_exists ( "Clusterpoint\Connection" ) ? new Connection ( $ this -> constructConnections ) : new StandartConnection ( $ this -> constructConnections ) ; return new Service ( $ connection ) ; }
6556	public function log ( $ msg , $ logLevel = null ) { $ helper = new FormatterHelper ( ) ; $ style = $ this -> mapLogLevelToStyle ( $ logLevel ) ; $ this -> getOutput ( ) -> writeln ( $ logLevel ? $ helper -> formatBlock ( $ msg , $ style ) : $ msg ) ; if ( $ logLevel && $ systemLogger = $ this -> getSystemLogger ( ) ) { $ systemLogger -> log ( $ logLevel , $ msg ) ; } }
1962	public static function decodeEmail ( $ strEmail ) { if ( $ strEmail == '' ) { return '' ; } if ( strpos ( $ strEmail , '@' ) === false ) { return $ strEmail ; } $ arrChunks = explode ( '@' , $ strEmail ) ; $ strHost = static :: decode ( array_pop ( $ arrChunks ) ) ; if ( $ strHost == '' ) { return '' ; } return implode ( '@' , $ arrChunks ) . '@' . $ strHost ; }
10395	protected function getShopIds ( ) { $ shopIds = [ ] ; try { $ shops = $ this -> container -> getParameter ( 'ongr_connections.shops' ) ; } catch ( InvalidArgumentException $ e ) { $ shops = [ ] ; } foreach ( $ shops as $ shop ) { $ shopIds [ ] = $ shop [ 'shop_id' ] ; } return $ shopIds ; }
4952	protected function checkRatingValue ( $ rating , $ throwException = true ) { if ( ! is_int ( $ rating ) || static :: RATING_EXCELLENT < $ rating || static :: RATING_NONE > $ rating ) { if ( $ throwException ) { throw new \ InvalidArgumentException ( sprintf ( '%s is not a valid rating value.' , $ rating ) ) ; } return false ; } return true ; }
9376	protected function check ( array $ files , $ path , $ source , $ template ) { $ file = null ; foreach ( ( array ) $ files as $ key => $ value ) { $ filepath = ( string ) str_replace ( $ path , $ source , $ value ) ; $ filepath = str_replace ( '\\' , '/' , ( string ) $ filepath ) ; $ filepath = ( string ) preg_replace ( '/^\d\//i' , '' , $ filepath ) ; $ exists = ( string ) $ filepath === $ template ; $ lowercase = strtolower ( $ filepath ) === $ template ; ( $ exists || $ lowercase ) && $ file = $ value ; } return $ file ; }
727	public static function on ( $ class , $ name , $ handler , $ data = null , $ append = true ) { $ class = ltrim ( $ class , '\\' ) ; if ( strpos ( $ class , '*' ) !== false || strpos ( $ name , '*' ) !== false ) { if ( $ append || empty ( self :: $ _eventWildcards [ $ name ] [ $ class ] ) ) { self :: $ _eventWildcards [ $ name ] [ $ class ] [ ] = [ $ handler , $ data ] ; } else { array_unshift ( self :: $ _eventWildcards [ $ name ] [ $ class ] , [ $ handler , $ data ] ) ; } return ; } if ( $ append || empty ( self :: $ _events [ $ name ] [ $ class ] ) ) { self :: $ _events [ $ name ] [ $ class ] [ ] = [ $ handler , $ data ] ; } else { array_unshift ( self :: $ _events [ $ name ] [ $ class ] , [ $ handler , $ data ] ) ; } }
10505	private function registerStyler ( ) { $ this -> app -> singleton ( Contracts \ Utilities \ LogStyler :: class , Utilities \ LogStyler :: class ) ; $ this -> app -> singleton ( 'arcanedev.log-viewer.styler' , Contracts \ Utilities \ LogStyler :: class ) ; }
691	protected function isActive ( $ action ) { $ id = $ this -> getActionId ( $ action ) ; if ( empty ( $ this -> only ) ) { $ onlyMatch = true ; } else { $ onlyMatch = false ; foreach ( $ this -> only as $ pattern ) { if ( StringHelper :: matchWildcard ( $ pattern , $ id ) ) { $ onlyMatch = true ; break ; } } } $ exceptMatch = false ; foreach ( $ this -> except as $ pattern ) { if ( StringHelper :: matchWildcard ( $ pattern , $ id ) ) { $ exceptMatch = true ; break ; } } return ! $ exceptMatch && $ onlyMatch ; }
5829	public function newRawRequest ( $ method , $ url , $ data = '' ) { return $ this -> newRequest ( $ method , $ url , $ data , Request :: ENCODING_RAW ) ; }
6059	public function retrieveMedia ( $ id , $ includeChildren = false , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'includeChildren' => $ includeChildren ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/media/' . $ id . '' , $ parameters , $ cachePolicy ) ; $ result = new MediaResponse ( $ result ) ; return $ result ; }
8108	public function getReviewFrom ( ) { $ from = $ this -> owner -> getField ( 'ReviewFrom' ) ; if ( $ from ) { return $ from ; } return Config :: inst ( ) -> get ( Email :: class , 'admin_email' ) ; }
7459	private function color ( string $ color ) : Font { $ this -> color = $ color ; if ( $ this -> background ) { $ this -> turnToBackground ( ) ; } return $ this ; }
2112	public function generate ( ) { global $ objPage ; $ obj404 = $ this -> prepare ( ) ; $ objPage = $ obj404 -> loadDetails ( ) ; $ objHandler = new $ GLOBALS [ 'TL_PTY' ] [ 'regular' ] ( ) ; header ( 'HTTP/1.1 404 Not Found' ) ; $ objHandler -> generate ( $ objPage ) ; }
5722	public function save ( $ data , $ form ) { $ origStage = Versioned :: get_stage ( ) ; Versioned :: set_stage ( 'Stage' ) ; $ action = $ this -> owner -> doSave ( $ data , $ form ) ; Versioned :: set_stage ( $ origStage ) ; return $ action ; }
1814	public function listImportWizard ( ) { return ' <a href="' . $ this -> addToUrl ( 'key=list' ) . '" title="' . Contao \ StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'lw_import' ] [ 1 ] ) . '" onclick="Backend.getScrollOffset()">' . Contao \ Image :: getHtml ( 'tablewizard.svg' , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'tw_import' ] [ 0 ] ) . '</a>' ; }
3086	public function getAdaptiveAssessmentSectionInfo ( AssessmentTest $ test , \ tao_models_classes_service_StorageDirectory $ compilationDirectory , $ basePath , $ qtiAssessmentSectionIdentifier ) { $ info = CatUtils :: getCatInfo ( $ test ) ; $ adaptiveInfo = [ 'qtiSectionIdentifier' => $ qtiAssessmentSectionIdentifier , 'adaptiveSectionIdentifier' => false , 'adaptiveEngineRef' => false ] ; if ( isset ( $ info [ $ qtiAssessmentSectionIdentifier ] ) ) { if ( isset ( $ info [ $ qtiAssessmentSectionIdentifier ] [ 'adaptiveEngineRef' ] ) ) { $ adaptiveInfo [ 'adaptiveEngineRef' ] = $ info [ $ qtiAssessmentSectionIdentifier ] [ 'adaptiveEngineRef' ] ; } if ( isset ( $ info [ $ qtiAssessmentSectionIdentifier ] [ 'adaptiveSettingsRef' ] ) ) { $ adaptiveInfo [ 'adaptiveSectionIdentifier' ] = trim ( $ compilationDirectory -> read ( "./${basePath}/" . $ info [ $ qtiAssessmentSectionIdentifier ] [ 'adaptiveSettingsRef' ] ) ) ; } } return ( ! isset ( $ info [ $ qtiAssessmentSectionIdentifier ] [ 'adaptiveEngineRef' ] ) || ! isset ( $ info [ $ qtiAssessmentSectionIdentifier ] [ 'adaptiveSettingsRef' ] ) ) ? false : $ adaptiveInfo ; }
3401	public function getValue ( ApistMethod $ method , Crawler $ rootNode = null ) { if ( is_null ( $ rootNode ) ) { $ rootNode = $ method -> getCrawler ( ) ; } $ result = $ rootNode -> filter ( $ this -> selector ) ; return $ this -> applyResultCallbackChain ( $ result , $ method ) ; }
1287	private function fetchCollectionFromApi ( array $ resourceIds , string $ type , string $ locale = null ) : array { $ query = ( new Query ( ) ) -> where ( 'sys.id[in]' , $ resourceIds ) ; if ( 'Asset' === $ type || 'Entry' === $ type ) { $ query -> setLocale ( $ locale ) ; } switch ( $ type ) { case 'Asset' : return $ this -> client -> getAssets ( $ query ) -> getItems ( ) ; case 'ContentType' : return $ this -> client -> getContentTypes ( $ query ) -> getItems ( ) ; case 'Entry' : return $ this -> client -> getEntries ( $ query ) -> getItems ( ) ; case 'Environment' : return [ $ this -> client -> getEnvironment ( ) ] ; case 'Space' : return [ $ this -> client -> getSpace ( ) ] ; default : throw new \ InvalidArgumentException ( \ sprintf ( 'Trying to resolve link for unknown type "%s".' , $ type ) ) ; } }
9049	private function renderButtons ( $ rendered , $ buttons ) { foreach ( $ buttons as $ button ) { if ( ! isset ( $ button [ 'name' ] ) ) { throw new ControlException ( "Button must have at least a name!" ) ; } $ buttonType = isset ( $ button [ 'type' ] ) ? $ button [ 'type' ] : "submit" ; $ id = isset ( $ button [ 'id' ] ) ? $ button [ 'id' ] : $ button [ 'name' ] ; $ class = isset ( $ button [ 'class' ] ) ? $ button [ 'class' ] : $ button [ 'name' ] ; $ label = isset ( $ button [ 'label' ] ) ? $ button [ 'label' ] : $ button [ 'name' ] ; $ rendered .= sprintf ( '<button type="%s" id="%s" class="%s" name="%s">%s</button>' , $ buttonType , $ id , $ class , $ button [ 'name' ] , $ label ) ; } return $ rendered ; }
5915	public function sendPasswordReset ( $ id , $ link = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'link' => $ link ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/accounts/users/' . $ id . '/resetpassword' , $ parameters ) ; return $ result ; }
2382	public static function findPublishedByParentAndIdOrAlias ( $ varId , $ arrPids , array $ arrOptions = array ( ) ) { if ( empty ( $ arrPids ) || ! \ is_array ( $ arrPids ) ) { return null ; } $ t = static :: $ strTable ; $ arrColumns = ! preg_match ( '/^[1-9]\d*$/' , $ varId ) ? array ( "$t.alias=?" ) : array ( "$t.id=?" ) ; $ arrColumns [ ] = "$t.pid IN(" . implode ( ',' , array_map ( '\intval' , $ arrPids ) ) . ")" ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ arrColumns [ ] = "$t.published='1'" ; } return static :: findOneBy ( $ arrColumns , $ varId , $ arrOptions ) ; }
2527	protected function getEndpointFromWsdl ( $ wsdlFilePath , $ messageName ) { $ wsdlId = $ this -> getWsdlIdFor ( $ messageName ) ; return WsdlAnalyser :: exaluateXpathQueryOnWsdl ( $ wsdlId , $ wsdlFilePath , self :: XPATH_ENDPOINT ) ; }
7468	protected function colorize ( $ str , $ attrs ) { $ start = $ this -> start ( $ attrs ) ; return $ start . $ str . $ this -> end ( ) ; }
10880	public function renderPreviousExceptions ( $ exception ) { if ( ( $ previous = $ exception -> getPrevious ( ) ) !== null ) { return $ this -> renderFile ( $ this -> previousExceptionView , [ 'exception' => $ previous ] ) ; } else { return '' ; } }
5161	public function attach ( string $ field , Model $ item ) : self { $ this -> attachment [ $ field ] [ ] = $ item ; return $ this ; }
10905	public function getList ( $ asStrings = false ) { $ list = scandir ( $ this -> path ) ; if ( $ asStrings === true ) { return array_diff ( $ list , [ "." , ".." ] ) ; } $ ret = [ ] ; foreach ( $ list as $ name ) { if ( $ name === "." || $ name === ".." ) { continue ; } $ path = $ this -> path . DIRECTORY_SEPARATOR . $ name ; $ ret [ ] = ( is_dir ( $ path ) ) ? new static ( $ path ) : new FileEntity ( $ path ) ; } return $ ret ; }
8832	public function tokenise ( $ pattern , $ expand = false ) { preg_match_all ( ' / (?<class_U_explicit>\\\U) \{ (?<class_U_repetition>[0-9]+) \} | (?<class_U_implicit>\\\U) | \[ (?<range_token_explicit>[^]]+) \] \{ (?<range_repetition>[0-9]+) \} | \[ (?<range_token_implicit>[^]]+) \] | (?<literal_string>[^\\\[]+) /x ' , $ pattern , $ matches , \ PREG_SET_ORDER ) ; $ tokens = [ ] ; foreach ( $ matches as $ match ) { if ( ! empty ( $ match [ 'class_U_explicit' ] ) ) { $ token = [ 'type' => 'class' , 'class' => static :: CLASS_UPPERCASE_UNAMBIGUOUS , 'repetition' => ( int ) $ match [ 'class_U_repetition' ] ] ; if ( $ expand ) { $ token [ 'haystack' ] = 'ABCDEFGHKMNOPRSTUVWXYZ23456789' ; } $ tokens [ ] = $ token ; } else if ( ! empty ( $ match [ 'class_U_implicit' ] ) ) { $ token = [ 'type' => 'class' , 'class' => static :: CLASS_UPPERCASE_UNAMBIGUOUS , 'repetition' => 1 ] ; if ( $ expand ) { $ token [ 'haystack' ] = 'ABCDEFGHKMNOPRSTUVWXYZ23456789' ; } $ tokens [ ] = $ token ; } else if ( ! empty ( $ match [ 'range_token_explicit' ] ) ) { $ token = [ 'type' => 'range' , 'token' => $ match [ 'range_token_explicit' ] , 'repetition' => ( int ) $ match [ 'range_repetition' ] ] ; if ( $ expand ) { $ token [ 'haystack' ] = static :: expandRange ( $ match [ 'range_token_explicit' ] ) ; } $ tokens [ ] = $ token ; } else if ( ! empty ( $ match [ 'range_token_implicit' ] ) ) { $ token = [ 'type' => 'range' , 'token' => $ match [ 'range_token_implicit' ] , 'repetition' => 1 ] ; if ( $ expand ) { $ token [ 'haystack' ] = static :: expandRange ( $ match [ 'range_token_implicit' ] ) ; } $ tokens [ ] = $ token ; } else if ( ! empty ( $ match [ 'literal_string' ] ) ) { $ tokens [ ] = [ 'type' => 'literal' , 'string' => $ match [ 'literal_string' ] ] ; } } return $ tokens ; }
10658	private function _uxsortmRec ( ArrayObject $ a , array $ sortFuncs , $ depth = 0 , $ sortMode = '' ) { $ goOn = ( count ( $ sortFuncs ) > $ depth + 1 ) ; $ it = $ a -> getIterator ( ) ; while ( $ it -> valid ( ) ) { if ( null !== $ sortFuncs [ $ depth ] ) { if ( $ sortMode == 'a' ) { $ it -> current ( ) -> uasort ( $ sortFuncs [ $ depth ] ) ; } else if ( $ sortMode == 'k' ) { $ it -> current ( ) -> uksort ( $ sortFuncs [ $ depth ] ) ; } else { $ it -> current ( ) -> usort ( $ sortFuncs [ $ depth ] ) ; } } if ( $ goOn ) { $ this -> _uxsortmRec ( $ it -> current ( ) , $ sortFuncs , $ depth + 1 , $ sortMode ) ; } $ it -> next ( ) ; } }
11414	public function decryptData ( $ sessionKey , $ iv , $ encrypted ) { try { $ decrypted = openssl_decrypt ( base64_decode ( $ encrypted , true ) , 'aes-128-cbc' , base64_decode ( $ sessionKey , true ) , OPENSSL_RAW_DATA | OPENSSL_NO_PADDING , base64_decode ( $ iv , true ) ) ; } catch ( Exception $ e ) { throw new EncryptionException ( $ e -> getMessage ( ) , EncryptionException :: ERROR_DECRYPT_AES ) ; } if ( is_null ( $ result = json_decode ( $ this -> decode ( $ decrypted ) , true ) ) ) { throw new EncryptionException ( 'ILLEGAL_BUFFER' , EncryptionException :: ILLEGAL_BUFFER ) ; } return $ result ; }
10490	public function neg ( ) { if ( $ this -> value === null ) { return new FloatType ( $ this -> value ) ; } return new FloatType ( $ this -> value * - 1 ) ; }
11662	public static function saveToString ( $ properties ) { $ xn = new \ SimpleXMLElement ( self :: XML_ROOT_OPEN . self :: XML_ROOT_CLOSE , LIBXML_NOXMLDECL ) ; foreach ( $ properties as $ key => $ value ) { $ xn -> addChild ( "entry" , htmlspecialchars ( $ value , ENT_XML1 ) ) -> addAttribute ( "key" , htmlspecialchars ( $ key , ENT_XML1 ) ) ; } return preg_replace ( '/\<\?.*\?\>/' , self :: XML_PRELUDE , $ xn -> asXML ( ) ) ; }
4284	public function url_stat ( $ path , $ flags ) { self :: restorePrev ( ) ; if ( ! \ file_exists ( $ path ) ) { $ info = false ; } elseif ( $ flags & STREAM_URL_STAT_LINK ) { $ info = $ flags & STREAM_URL_STAT_QUIET ? @ \ lstat ( $ path ) : \ lstat ( $ path ) ; } else { $ info = $ flags & STREAM_URL_STAT_QUIET ? @ \ stat ( $ path ) : \ stat ( $ path ) ; } self :: register ( ) ; return $ info ; }
7642	public function getBaseUrl ( ) { if ( $ this -> credentials -> usePathStyleUri ( ) ) { return $ this -> host . '/' . $ this -> accountName ; } return $ this -> host ; }
6767	protected function handleAddressChange ( SaleInterface $ sale ) { $ changed = false ; if ( $ this -> didDeliveryCountryChanged ( $ sale ) ) { $ changed |= $ this -> saleUpdater -> updateShipmentMethodAndAmount ( $ sale ) ; } if ( $ this -> isDiscountUpdateNeeded ( $ sale ) ) { $ changed |= $ this -> saleUpdater -> updateDiscounts ( $ sale , true ) ; } if ( $ this -> isTaxationUpdateNeeded ( $ sale ) ) { $ changed |= $ this -> saleUpdater -> updateTaxation ( $ sale , true ) ; } elseif ( $ this -> isShipmentTaxationUpdateNeeded ( $ sale ) ) { $ changed |= $ this -> saleUpdater -> updateShipmentTaxation ( $ sale , true ) ; } return $ changed ; }
784	protected function validateCache ( $ lastModified , $ etag ) { if ( Yii :: $ app -> request -> headers -> has ( 'If-None-Match' ) ) { return $ etag !== null && in_array ( $ etag , Yii :: $ app -> request -> getETags ( ) , true ) ; } elseif ( Yii :: $ app -> request -> headers -> has ( 'If-Modified-Since' ) ) { return $ lastModified !== null && @ strtotime ( Yii :: $ app -> request -> headers -> get ( 'If-Modified-Since' ) ) >= $ lastModified ; } return false ; }
11726	public function render ( $ filter = null ) : string { if ( empty ( $ this -> output ) ) { extract ( array_merge ( $ this -> vars , View :: $ global_vars ) , EXTR_REFS ) ; ob_start ( ) ; include ( $ this -> view_file ) ; $ this -> output = ob_get_clean ( ) ; } if ( $ filter !== null ) { $ this -> output = call_user_func ( $ filter , $ this -> output ) ; } return $ this -> output ; }
10203	public function setVertical ( $ pValue ) { if ( $ pValue == '' ) { $ pValue = self :: VERTICAL_BOTTOM ; } if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'vertical' => $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> vertical = $ pValue ; } return $ this ; }
6346	public static function concat ( Iterator $ a , Iterator $ b ) : Iterator { return self :: concatIterators ( new ArrayIterator ( [ $ a , $ b ] ) ) ; }
11655	private function _parseDsn ( $ dsn ) { $ dsn = parse_url ( $ dsn ) ; $ cfg = [ ] ; if ( isset ( $ dsn [ 'port' ] ) ) { $ cfg [ 'port' ] = $ dsn [ 'port' ] ; } return $ cfg + [ 'dbname' => isset ( $ dsn [ 'path' ] ) ? trim ( $ dsn [ 'path' ] , '/' ) : null , 'host' => isset ( $ dsn [ 'host' ] ) ? $ dsn [ 'host' ] : null , 'password' => isset ( $ dsn [ 'pass' ] ) ? $ dsn [ 'pass' ] : null , 'username' => isset ( $ dsn [ 'user' ] ) ? $ dsn [ 'user' ] : null , ] ; }
10098	public function setOutline ( $ visible = true , $ symbols_below = true , $ symbols_right = true , $ auto_style = false ) { $ this -> outlineOn = $ visible ; $ this -> outlineBelow = $ symbols_below ; $ this -> outlineRight = $ symbols_right ; $ this -> outlineStyle = $ auto_style ; if ( $ this -> outlineOn ) { $ this -> outlineOn = 1 ; } }
10701	public static function isBirthNumber ( $ no ) { if ( ! preg_match ( '#^\s*(\d\d)(\d\d)(\d\d)[ /]*(\d\d\d)(\d?)\s*$#' , $ no , $ matches ) ) { return false ; } list ( , $ year , $ month , $ day , $ ext , $ c ) = $ matches ; if ( $ c === '' ) { $ year += $ year < 54 ? 1900 : 1800 ; } else { $ mod = ( $ year . $ month . $ day . $ ext ) % 11 ; if ( $ mod === 10 ) { $ mod = 0 ; } if ( $ mod !== ( int ) $ c ) { return false ; } $ year += $ year < 54 ? 2000 : 1900 ; } if ( $ year > 2003 ) { if ( $ month > 70 ) { $ month -= 70 ; } if ( $ month > 20 && $ month < 50 ) { $ month -= 20 ; } } if ( $ month > 50 ) { $ month -= 50 ; } return checkdate ( $ month , $ day , $ year ) ; }
1934	protected function getDateString ( ) { return 'Locale.define("en-US","Date",{' . 'months:["' . implode ( '","' , $ GLOBALS [ 'TL_LANG' ] [ 'MONTHS' ] ) . '"],' . 'days:["' . implode ( '","' , $ GLOBALS [ 'TL_LANG' ] [ 'DAYS' ] ) . '"],' . 'months_abbr:["' . implode ( '","' , $ GLOBALS [ 'TL_LANG' ] [ 'MONTHS_SHORT' ] ) . '"],' . 'days_abbr:["' . implode ( '","' , $ GLOBALS [ 'TL_LANG' ] [ 'DAYS_SHORT' ] ) . '"]' . '});' . 'Locale.define("en-US","DatePicker",{' . 'select_a_time:"' . $ GLOBALS [ 'TL_LANG' ] [ 'DP' ] [ 'select_a_time' ] . '",' . 'use_mouse_wheel:"' . $ GLOBALS [ 'TL_LANG' ] [ 'DP' ] [ 'use_mouse_wheel' ] . '",' . 'time_confirm_button:"' . $ GLOBALS [ 'TL_LANG' ] [ 'DP' ] [ 'time_confirm_button' ] . '",' . 'apply_range:"' . $ GLOBALS [ 'TL_LANG' ] [ 'DP' ] [ 'apply_range' ] . '",' . 'cancel:"' . $ GLOBALS [ 'TL_LANG' ] [ 'DP' ] [ 'cancel' ] . '",' . 'week:"' . $ GLOBALS [ 'TL_LANG' ] [ 'DP' ] [ 'week' ] . '"' . '});' ; }
2661	public function deleteRequest ( $ version , $ name ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/request_settings/' . $ name ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: DELETE ) ; if ( ! $ result ) { throw new LocalizedException ( __ ( 'Failed to delete the REQUEST object.' ) ) ; } }
8020	public function set ( string $ content ) { $ parsed = $ this -> parseContent ( $ content ) ; $ this -> id = $ parsed -> id ; $ this -> infoUri = $ parsed -> infoUri ; $ this -> partialCancelUri = $ parsed -> partialCancelUri ?? null ; $ this -> nextUri = $ parsed -> nextUri ?? null ; $ this -> columns = [ ] ; if ( isset ( $ parsed -> columns ) ) { $ this -> columnTransfer ( $ parsed -> columns ) ; } $ this -> data = $ parsed -> data ?? [ ] ; $ this -> stats = isset ( $ parsed -> stats ) ? $ this -> statsTransfer ( $ parsed -> stats ) : null ; $ this -> error = isset ( $ parsed -> error ) ? $ this -> errorTransfer ( $ parsed -> error ) : null ; }
12107	public function getPage ( $ name ) { if ( ! isset ( $ this -> pages [ $ name ] ) ) { throw new InvalidParameterException ( "Page not found" ) ; } return $ this -> pages [ $ name ] ; }
1466	public static function doesRequestHaveBody ( $ request ) { if ( self :: hasHeader ( $ request , 'Transfer-Encoding' ) ) { return true ; } ; if ( 1 > self :: getHeader ( $ request , 'Content-Length' ) ) { return false ; } return true ; }
7684	function XML_DeleteElements ( & $ Txt , $ TagLst , $ OnlyInner = false ) { $ nbr_del = 0 ; foreach ( $ TagLst as $ tag ) { $ t_open = '<' . $ tag ; $ t_close = '</' . $ tag ; $ p1 = 0 ; while ( ( $ p1 = $ this -> XML_FoundTagStart ( $ Txt , $ t_open , $ p1 ) ) !== false ) { $ pe1 = strpos ( $ Txt , '>' , $ p1 ) ; if ( $ pe1 === false ) return false ; $ p2 = false ; if ( substr ( $ Txt , $ pe1 - 1 , 1 ) == '/' ) { $ pe2 = $ pe1 ; } else { $ p2 = $ this -> XML_FoundTagStart ( $ Txt , $ t_close , $ pe1 ) ; if ( $ p2 === false ) return false ; $ pe2 = strpos ( $ Txt , '>' , $ p2 ) ; } if ( $ pe2 === false ) return false ; if ( $ OnlyInner ) { if ( $ p2 !== false ) $ Txt = substr_replace ( $ Txt , '' , $ pe1 + 1 , $ p2 - $ pe1 - 1 ) ; $ p1 = $ pe1 ; } else { $ Txt = substr_replace ( $ Txt , '' , $ p1 , $ pe2 - $ p1 + 1 ) ; } } } return $ nbr_del ; }
9147	private function open ( ) { $ this -> handle = @ socket_create ( AF_INET , SOCK_STREAM , SOL_TCP ) ; if ( ! is_resource ( $ this -> handle ) ) { $ code = socket_last_error ( ) ; throw new SocketException ( socket_strerror ( $ code ) , array ( ) , $ code ) ; } }
9287	public function drop ( ) { $ adapter = $ this -> dbAdapter ; $ ddl = new Ddl \ DropTable ( self :: TABLE_NAME ) ; $ sql = ( new Sql ( $ adapter ) ) -> getSqlStringForSqlObject ( $ ddl ) ; $ adapter -> query ( $ sql , $ adapter :: QUERY_MODE_EXECUTE ) ; }
10808	public static function isRender ( $ request ) { return true ; $ accept = $ request -> header ( 'accept' ) ?? '' ; if ( static :: isHas ( $ accept , 'json' ) || static :: isHas ( $ accept , 'api' ) ) { return true ; } else if ( static :: isHas ( $ accept , 'html' ) || static :: isHas ( $ accept , 'xml' ) || static :: isHas ( $ accept , 'text' ) ) { return false ; } else if ( $ request -> header ( 'x-ddv-restful-api' ) ) { return true ; } else if ( $ request -> header ( 'authorization' ) ) { foreach ( $ request -> headers -> keys ( ) as $ value ) { if ( static :: isHas ( $ accept , 'x-ddv-' ) ) { return true ; } } } return false ; }
8750	public static function dumpValue ( $ value , $ containerVariable , array $ usedVariables ) : InlineEntryInterface { if ( is_array ( $ value ) ) { return self :: dumpArray ( $ value , $ containerVariable , $ usedVariables ) ; } elseif ( $ value instanceof ReferenceInterface ) { return self :: dumpReference ( $ value , $ containerVariable , $ usedVariables ) ; } elseif ( $ value instanceof DumpableInterface ) { return self :: dumpDefinition ( $ value , $ containerVariable , $ usedVariables ) ; } elseif ( is_object ( $ value ) || is_resource ( $ value ) ) { throw new \ RuntimeException ( 'Unable to dump a container if a parameter is an object or a resource.' ) ; } else { return new InlineEntry ( var_export ( $ value , true ) , null , $ usedVariables , false ) ; } }
3367	protected function prepareEvent ( EventInterface $ event ) { foreach ( [ 'elementSpec' , 'inputSpec' ] as $ type ) { if ( ! $ event -> getParam ( $ type ) ) { $ event -> setParam ( $ type , new ArrayObject ( ) ) ; } } $ elementSpec = $ event -> getParam ( 'elementSpec' ) ; $ inputSpec = $ event -> getParam ( 'inputSpec' ) ; if ( ! isset ( $ elementSpec [ 'spec' ] ) ) { $ elementSpec [ 'spec' ] = [ ] ; } if ( ! isset ( $ inputSpec [ 'filters' ] ) ) { $ inputSpec [ 'filters' ] = [ ] ; } if ( ! isset ( $ inputSpec [ 'validators' ] ) ) { $ inputSpec [ 'validators' ] = [ ] ; } }
4296	public function assert ( $ assertion , $ msg = null ) { array ( $ msg ) ; $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args ) ; $ assertion = \ array_shift ( $ args ) ; if ( ! $ assertion ) { if ( ! $ args ) { $ callerInfo = $ this -> utilities -> getCallerInfo ( ) ; $ args [ ] = 'Assertion failed in ' . $ callerInfo [ 'file' ] . ' on line ' . $ callerInfo [ 'line' ] ; } $ this -> appendLog ( 'assert' , $ args , $ meta ) ; } }
12580	public function previewVideoByName ( $ message , $ to ) { return $ this -> preview ( self :: MSG_TYPE_VIDEO , $ message , $ to , self :: PREVIEW_BY_NAME ) ; }
10082	protected function registerConfigurator ( ) { $ this -> app -> singleton ( 'auja.database' , function ( $ app ) { $ config = $ app [ 'config' ] [ 'auja-laravel' ] ? : $ app [ 'config' ] [ 'auja-laravel::config' ] ; switch ( $ config [ 'database' ] ) { case 'mysql' : return new MySQLDatabaseHelper ( ) ; break ; default : throw new NoDatabaseHelperException ( 'No Auja database helper for ' . $ config [ 'database' ] ) ; break ; } } ) ; $ this -> app -> bind ( 'Label305\AujaLaravel\Database\DatabaseHelper' , 'auja.database' ) ; $ this -> app -> singleton ( 'auja.configurator' , function ( $ app ) { return new AujaConfigurator ( $ app , $ app [ 'auja.database' ] ) ; } ) ; $ this -> app -> bind ( 'Label305\AujaLaravel\Config\AujaConfigurator' , 'auja.configurator' ) ; }
12569	public function previewText ( $ message , $ to , $ by = self :: PREVIEW_BY_OPENID ) { return $ this -> preview ( self :: MSG_TYPE_TEXT , $ message , $ to , $ by ) ; }
9167	public function setFieldValidationStatus ( $ action = '' , $ shortname = '' , Elements \ ValidationStatus $ validation = null ) { if ( ! isset ( $ _SESSION [ 'prototyper_validation' ] [ $ action ] ) ) { $ _SESSION [ 'prototyper_validation' ] [ $ action ] = array ( ) ; } $ _SESSION [ 'prototyper_validation' ] [ $ action ] [ $ shortname ] = array ( 'status' => $ validation -> getStatus ( ) , 'messages' => $ validation -> getMessages ( ) ) ; }
9697	function findTransactionTypeByName ( $ type_name ) { $ types = $ this -> getTransactionTypes ( 1 , 1000 ) -> getResult ( ) ; $ type_name = mb_strtolower ( $ type_name ) ; foreach ( $ types as $ type ) { if ( strcmp ( mb_strtolower ( $ type -> name ) , $ type_name ) == 0 ) { return ( int ) $ type -> id ; } } return null ; }
3045	protected function getAssessmentsFromDelivery ( \ core_kernel_classes_Resource $ compiledDelivery ) { $ unionAssignmentService = $ this -> getServiceLocator ( ) -> get ( UnionAssignmentService :: SERVICE_ID ) ; $ runtime = $ unionAssignmentService -> getRuntime ( $ compiledDelivery ) ; $ inputParameters = \ tao_models_classes_service_ServiceCallHelper :: getInputValues ( $ runtime , [ ] ) ; $ testDefinition = \ taoQtiTest_helpers_Utils :: getTestDefinition ( $ inputParameters [ 'QtiTestCompilation' ] ) ; $ assessmentItemRefs = $ testDefinition -> getComponentsByClassName ( 'assessmentItemRef' ) ; $ this -> report -> add ( new Report ( Report :: TYPE_INFO , "Starting to recompile items for delivery {$compiledDelivery->getLabel()} with identifier {$compiledDelivery->getUri()}:" ) ) ; $ count = 0 ; foreach ( $ assessmentItemRefs as $ assessmentItemRef ) { $ directoryIds = explode ( '|' , $ assessmentItemRef -> getHref ( ) ) ; $ item = $ this -> getResource ( $ directoryIds [ 0 ] ) ; $ properties = [ ] ; foreach ( $ item -> getRdfTriples ( ) as $ triple ) { $ properties [ $ triple -> predicate ] = $ triple -> object ; } if ( $ properties ) { $ directory = \ tao_models_classes_service_FileStorage :: singleton ( ) -> getDirectoryById ( $ directoryIds [ 2 ] ) ; $ languages = $ item -> getUsedLanguages ( $ this -> getProperty ( \ taoItems_models_classes_ItemsService :: PROPERTY_ITEM_CONTENT ) ) ; foreach ( $ languages as $ lang ) { $ path = $ lang . DIRECTORY_SEPARATOR . QtiJsonItemCompiler :: METADATA_FILE_NAME ; if ( ! $ directory -> has ( $ path ) ) { $ this -> writeMetadata ( $ item , $ directory , $ path , $ properties ) ; $ count ++ ; } } } } $ this -> report -> add ( new Report ( Report :: TYPE_INFO , "Was updated {$count} items." ) ) ; }
8265	protected function onOauthResourceError ( IdentityProviderException $ e ) { $ this -> logger -> critical ( "OAuth2 IdentityProviderException: {e}, provider {provider}" , array ( "e" => $ e -> getMessage ( ) , "provider" => get_class ( $ this -> provider ) , ) ) ; $ this -> session -> addFlash ( "error" , "Failed to get an access token or user details." ) ; $ this -> picoAuth -> redirectToLogin ( ) ; }
3677	private function fieldExists ( $ strTableName , $ strColumnName ) { $ columns = $ this -> connection -> getSchemaManager ( ) -> listTableColumns ( $ strTableName ) ; return isset ( $ columns [ $ strColumnName ] ) ; }
2363	public static function decodeEntities ( $ strString , $ strQuoteStyle = ENT_COMPAT , $ strCharset = null ) { if ( $ strString == '' ) { return '' ; } if ( $ strCharset === null ) { $ strCharset = Config :: get ( 'characterSet' ) ; } $ strString = preg_replace ( '/(&#*\w+)[\x00-\x20]+;/i' , '$1;' , $ strString ) ; $ strString = preg_replace ( '/(&#x*)([0-9a-f]+);/i' , '$1$2;' , $ strString ) ; return html_entity_decode ( $ strString , $ strQuoteStyle , $ strCharset ) ; }
3602	public function isDebug ( ) { if ( null !== $ this -> container && $ this -> container -> has ( 'kernel' ) ) { return $ this -> container -> get ( 'kernel' ) -> isDebug ( ) ; } return true ; }
892	public function getNormalizedTypes ( ) { $ normalized = array_map ( static function ( $ type ) { return strtolower ( $ type ) ; } , $ this -> getTypes ( ) ) ; sort ( $ normalized ) ; return $ normalized ; }
7423	protected function registerWidget ( $ name = null , $ id = null ) { if ( $ name === null ) { $ name = $ this -> getDefaultJsWidgetName ( ) ; } $ this -> _registerBundle ( ) ; if ( ! $ this -> isAjaxCrud && $ this -> getUpdateUrl ( ) ) { if ( $ id === null ) { $ id = $ this -> options [ 'id' ] ; } $ options = empty ( $ this -> clientOptions ) ? '' : Json :: htmlEncode ( [ 'updateUrl' => Url :: to ( $ this -> getUpdateUrl ( ) ) ] ) ; $ js = "jQuery('#$id').$name($options);" ; $ this -> getView ( ) -> registerJs ( $ js ) ; } }
4564	public function kernelException ( GetResponseForExceptionEvent $ event ) { $ exception = $ event -> getException ( ) ; if ( ! $ exception instanceof NoPermissionsException ) { return ; } $ response = new JsonResponse ( [ ] ) ; $ event -> setResponse ( $ response ) ; }
6621	public function set_submenu ( ) { $ submenu = Module :: CustomRatingGrifus ( ) -> getOption ( 'submenu' ) ; WP_Menu :: add ( 'submenu' , $ submenu [ 'custom-rating-grifus' ] , [ $ this , 'render' ] , [ $ this , 'add_scripts' ] , [ $ this , 'add_styles' ] ) ; }
6960	public static function dt ( AstroDate $ dt ) { $ epoch = new static ( $ dt -> toTT ( ) -> toJD ( ) ) ; $ epoch -> dt = $ dt -> copy ( ) ; return $ epoch ; }
3057	public function isAdaptive ( AssessmentItemRef $ currentAssessmentItemRef = null ) { return $ this -> getServiceManager ( ) -> get ( CatService :: SERVICE_ID ) -> isAdaptive ( $ this -> getTestSession ( ) , $ currentAssessmentItemRef ) ; }
6408	public static function filterBy ( IteratorAggregate $ unfiltered , string $ className ) : IteratorAggregate { return self :: from ( Iterators :: filterBy ( Iterators :: from ( $ unfiltered -> getIterator ( ) ) , $ className ) ) ; }
6550	public function current ( ) { if ( $ this -> iterator -> valid ( ) === false ) { return null ; } $ iterator = $ this -> iterator -> current ( ) -> getCellIterator ( ) ; $ iterator -> setIterateOnlyExistingCells ( false ) ; $ result = [ ] ; foreach ( $ iterator as $ cell ) { $ result [ ] = $ cell -> getValue ( ) ; } return $ result ; }
1208	public function moveChildToPosition ( ItemInterface $ item , ItemInterface $ child , $ position ) { $ name = $ child -> getName ( ) ; $ order = array_keys ( $ item -> getChildren ( ) ) ; $ oldPosition = array_search ( $ name , $ order ) ; unset ( $ order [ $ oldPosition ] ) ; $ order = array_values ( $ order ) ; array_splice ( $ order , $ position , 0 , $ name ) ; $ item -> reorderChildren ( $ order ) ; }
1725	private static function canGenerateSecret ( array $ config ) : bool { if ( isset ( $ config [ 'file' ] ) ) { return ! is_file ( $ config [ 'file' ] ) ; } foreach ( $ config as $ v ) { if ( \ is_array ( $ v ) && isset ( $ v [ 'file' ] ) && is_file ( $ v [ 'file' ] ) ) { return false ; } } return ! empty ( $ config ) ; }
1560	protected function modelKeyForField ( $ field , $ model ) { if ( isset ( $ this -> attributes [ $ field ] ) ) { return $ this -> attributes [ $ field ] ; } $ key = $ model :: $ snakeAttributes ? Str :: underscore ( $ field ) : Str :: camelize ( $ field ) ; return $ this -> attributes [ $ field ] = $ key ; }
11955	public function generate ( RouterInterface $ router ) { $ routes = $ router -> getRouteCollection ( ) ; $ pagesDir = $ this -> configurationHandler -> pagesDir ( ) ; $ homepageValues = array ( '_locale' => $ this -> configurationHandler -> language ( ) , 'country' => $ this -> configurationHandler -> country ( ) , 'page' => $ this -> configurationHandler -> homepage ( ) , ) ; $ homeRouteName = '_home_' . $ homepageValues [ "_locale" ] . '_' . $ homepageValues [ "country" ] . '_' . $ homepageValues [ "page" ] ; $ this -> routes [ "homepage" ] = $ homeRouteName ; if ( $ this -> explicitHomepageRoute ) { $ values = array_merge ( $ homepageValues , array ( '_controller' => $ this -> frontController , ) ) ; $ routes -> add ( $ homeRouteName , new Route ( $ this -> pattern , $ values ) ) ; } $ seoFileName = 'seo.json' ; if ( null !== $ this -> contributor ) { $ seoFileName = $ this -> contributor . '.json' ; } $ finder = new Finder ( ) ; $ pages = $ finder -> directories ( ) -> depth ( 0 ) -> in ( $ pagesDir ) ; foreach ( $ pages as $ page ) { $ this -> generateLanguagesRoutes ( $ routes , $ page , $ seoFileName ) ; } }
110	public function loadInstalledPlugins ( ) { if ( $ this -> disablePlugins ) { return ; } $ repo = $ this -> composer -> getRepositoryManager ( ) -> getLocalRepository ( ) ; $ globalRepo = $ this -> globalComposer ? $ this -> globalComposer -> getRepositoryManager ( ) -> getLocalRepository ( ) : null ; if ( $ repo ) { $ this -> loadRepository ( $ repo ) ; } if ( $ globalRepo ) { $ this -> loadRepository ( $ globalRepo ) ; } }
9516	public function settings ( $ name = null , $ value = null ) { switch ( func_num_args ( ) ) { case 0 : return $ this -> info ( 'settings' ) ; break ; case 1 : return $ this -> info ( 'settings' , func_get_arg ( 0 ) ) ; break ; case 2 : $ update = false ; list ( $ name , $ value ) = func_get_args ( ) ; $ current = $ this -> info ( 'settings' , $ name ) ; if ( is_null ( $ value ) ) { if ( ! is_null ( $ current ) ) { unset ( $ this -> info [ 'settings' ] [ $ name ] ) ; $ update = true ; } } elseif ( $ current !== $ value ) { $ this -> info [ 'settings' ] [ $ name ] = $ value ; $ update = true ; } if ( $ update ) { $ this -> exec ( 'UPDATE config SET settings = ?' , serialize ( $ this -> info [ 'settings' ] ) ) ; } break ; } }
1344	public function isReadResource ( ) : bool { return $ this -> isMethod ( 'get' ) && $ this -> getRoute ( ) -> isResource ( ) && $ this -> getRoute ( ) -> isNotRelationship ( ) ; }
10641	public function andWhere ( $ column , $ op , $ value , $ isParam = true ) { $ this -> clauses [ ] = array ( "AND" , $ column , $ op , $ value , $ isParam ) ; return $ this ; }
6369	public static function compose ( callable $ g , callable $ f ) : callable { return function ( $ input ) use ( $ g , $ f ) { return Functions :: call ( $ g , Functions :: call ( $ f , $ input ) ) ; } ; }
12048	public function render ( ElementInterface $ element ) { $ renderer = $ this -> getView ( ) ; if ( $ element instanceof CkEditor ) { $ plugin = $ renderer -> plugin ( 'form_ckeditor' ) ; return $ plugin ( $ element ) ; } return parent :: render ( $ element ) ; }
5356	public function parseSchema ( $ openApiSpec ) { $ openApiSpecContents = file_get_contents ( $ openApiSpec ) ; $ schemaClass = self :: OPEN_API_MODEL ; $ schema = null ; $ jsonException = null ; $ yamlException = null ; try { return $ this -> serializer -> deserialize ( $ openApiSpecContents , $ schemaClass , self :: CONTENT_TYPE_JSON , [ 'document-origin' => $ openApiSpec ] ) ; } catch ( \ Exception $ exception ) { $ jsonException = $ exception ; } $ content = Yaml :: parse ( $ openApiSpecContents , Yaml :: PARSE_OBJECT | Yaml :: PARSE_OBJECT_FOR_MAP | Yaml :: PARSE_DATETIME | Yaml :: PARSE_EXCEPTION_ON_INVALID_TYPE ) ; $ openApiSpecContents = json_encode ( $ content ) ; return $ this -> serializer -> deserialize ( $ openApiSpecContents , $ schemaClass , self :: CONTENT_TYPE_JSON , [ 'document-origin' => $ openApiSpec ] ) ; }
8948	public function downloadTraceMetadetails ( $ id , $ username , $ password ) { $ base = 'gpx/' . $ id . '/details' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; return $ this -> sendRequest ( $ path , 'GET' , array ( 'Authorization' => 'Basic ' . base64_encode ( $ username . ':' . $ password ) ) ) ; }
8804	public function getFlash ( $ key = null ) { if ( ! is_null ( $ key ) ) { $ value = null ; if ( $ this -> hasFlash ( $ key ) ) { $ value = $ this -> get ( '_nur_flash' ) [ $ key ] ; unset ( $ _SESSION [ '_nur_flash' ] [ $ key ] ) ; } return $ value ; } return $ key ; }
8661	private function convertGetFeedSubmissionResult ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetFeedSubmissionResult' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetFeedSubmissionId ( ) ) { $ parameters [ 'FeedSubmissionId' ] = $ request -> getFeedSubmissionId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
7829	public function getLeftBordersWith ( $ border ) { $ border = str_repeat ( $ border , static :: BORDER_WIDTH ) ; $ space = str_repeat ( ' ' , static :: MIN_SPACE_FROM_BORDER_X ) ; return str_repeat ( "{$border}{$space}" , $ this -> nesting ) ; }
1698	private function loadFrontendUser ( string $ username , BackendUser $ backendUser ) : ? FrontendUser { try { $ frontendUser = $ this -> userProvider -> loadUserByUsername ( $ username ) ; if ( ! $ frontendUser instanceof FrontendUser ) { throw new UsernameNotFoundException ( 'User is not a front end user' ) ; } } catch ( UsernameNotFoundException $ e ) { if ( null !== $ this -> logger ) { $ this -> logger -> info ( sprintf ( 'Could not find a front end user with the username "%s"' , $ username ) , [ 'contao' => new ContaoContext ( __METHOD__ , ContaoContext :: ACCESS , '' ) ] ) ; } return null ; } $ allowedGroups = StringUtil :: deserialize ( $ backendUser -> amg , true ) ; $ frontendGroups = StringUtil :: deserialize ( $ frontendUser -> groups , true ) ; if ( ! $ backendUser -> isAdmin && ! \ count ( array_intersect ( $ frontendGroups , $ allowedGroups ) ) ) { return null ; } return $ frontendUser ; }
12210	private function saveTransLogs ( $ orders , $ transIds ) { $ bySaleId = [ ] ; foreach ( $ orders as $ custId => $ order ) { $ saleId = $ order [ QGetOrders :: A_SALE_ID ] ; $ bySaleId [ $ saleId ] = $ order ; } foreach ( $ transIds as $ tranId => $ one ) { $ pref = substr ( $ one , 0 , 2 ) ; $ orderId = str_replace ( $ pref , '' , $ one ) ; if ( $ pref == self :: PREFIX_PV ) { $ custId = $ bySaleId [ $ orderId ] [ QGetOrders :: A_CUST_ID ] ; $ this -> daoLogCust -> create ( [ LogCust :: A_TRANS_ID => $ tranId , LogCust :: A_CUSTOMER_ID => $ custId ] ) ; $ this -> daoLogSale -> create ( [ LogSales :: A_TRANS_ID => $ tranId , LogSales :: A_SALE_ORDER_ID => $ orderId ] ) ; } elseif ( $ pref == self :: PREFIX_BONUS_FATHER ) { $ custId = $ bySaleId [ $ orderId ] [ QGetOrders :: A_PARENT_ID ] ; $ this -> daoLogCust -> create ( [ LogCust :: A_TRANS_ID => $ tranId , LogCust :: A_CUSTOMER_ID => $ custId ] ) ; } else { $ custId = $ bySaleId [ $ orderId ] [ QGetOrders :: A_PARENT_GRAND_ID ] ; $ this -> daoLogCust -> create ( [ LogCust :: A_TRANS_ID => $ tranId , LogCust :: A_CUSTOMER_ID => $ custId ] ) ; } } }
1565	public function getResource ( ) { if ( ! $ this -> resource_type || ! $ this -> resource_id ) { return null ; } return $ this -> getApi ( ) -> getStore ( ) -> find ( ResourceIdentifier :: create ( $ this -> resource_type , ( string ) $ this -> resource_id ) ) ; }
10935	public function checkEmailAction ( ) { $ session = $ this -> get ( 'session' ) ; $ email = $ session -> get ( static :: SESSION_EMAIL ) ; $ session -> remove ( static :: SESSION_EMAIL ) ; if ( empty ( $ email ) ) { return new RedirectResponse ( $ this -> get ( 'router' ) -> generate ( 'miky_app_customer_resetting_request' ) ) ; } return $ this -> render ( 'MikyUserBundle:Frontend/Resetting:checkEmail.html.twig' , array ( 'email' => $ email , ) ) ; }
4162	public function searchMedia ( $ lat , $ lng , $ distance = 1000 , $ minTimestamp = NULL , $ maxTimestamp = NULL ) { return $ this -> _makeCall ( 'media/search' , array ( 'lat' => $ lat , 'lng' => $ lng , 'distance' => $ distance , 'min_timestamp' => $ minTimestamp , 'max_timestamp' => $ maxTimestamp ) ) ; }
11728	private function _fetch ( $ attrName , $ default = NULL ) { return $ this -> hasAttribute ( $ attrName ) ? $ this -> getAttribute ( $ attrName ) -> getValue ( ) : $ default ; }
7066	public function getUserRights ( ) { if ( ! $ this -> _UserRights ) { if ( Configure :: load ( 'user_rights' ) === false ) { trigger_error ( 'UserRights: Could not load config/user_rights.php' , E_USER_WARNING ) ; } $ rightsConfig = Configure :: read ( 'user_rights' ) ; if ( ! is_array ( $ rightsConfig ) ) { $ rightsConfig = [ ] ; } $ this -> _UserRights = new UserRights ( $ rightsConfig ) ; } return $ this -> _UserRights ; }
8566	public function getShipment ( $ request ) { if ( ! ( $ request instanceof MWSMerchantFulfillmentService_Model_GetShipmentRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/GetShipmentRequest.php' ) ; $ request = new MWSMerchantFulfillmentService_Model_GetShipmentRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetShipment' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/GetShipmentResponse.php' ) ; $ response = MWSMerchantFulfillmentService_Model_GetShipmentResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
1118	public static function allLeaves ( ) { $ instance = new static ; $ grammar = $ instance -> getConnection ( ) -> getQueryGrammar ( ) ; $ rgtCol = $ grammar -> wrap ( $ instance -> getQualifiedRightColumnName ( ) ) ; $ lftCol = $ grammar -> wrap ( $ instance -> getQualifiedLeftColumnName ( ) ) ; return $ instance -> newQuery ( ) -> whereRaw ( $ rgtCol . ' - ' . $ lftCol . ' = 1' ) -> orderBy ( $ instance -> getQualifiedOrderColumnName ( ) ) ; }
3798	private function checkModelWithVariants ( $ containedModel ) { $ isVarbase = ( bool ) $ containedModel -> getProperty ( 'varbase' ) ; $ vargroup = $ containedModel -> getProperty ( 'vargroup' ) ; $ isCurrentVarbase = ( bool ) $ this -> currentModel -> getProperty ( 'varbase' ) ; $ currentVargroup = $ this -> currentModel -> getProperty ( 'vargroup' ) ; if ( $ isVarbase && ! $ this -> circularReference && $ isCurrentVarbase ) { $ this -> disablePA = false ; } elseif ( ! $ isVarbase && ! $ isCurrentVarbase && $ vargroup == $ currentVargroup ) { $ this -> disablePA = false ; } $ this -> disablePI = ! $ isCurrentVarbase || $ isVarbase ; }
6331	private function registerPostProcessor ( string $ type , string $ class ) : void { if ( \ class_exists ( $ class ) ) { $ interfaces = \ class_implements ( $ class ) ; if ( \ in_array ( PostProcessor :: class , $ interfaces , true ) ) { $ this -> postProcessorsMap [ $ type ] = $ class ; } else { throw new ConfigException ( "Class {$class} don't implement interface " . PostProcessor :: class ) ; } } else { throw new ConfigException ( "Class {$class} not found" ) ; } }
11875	final public function getModuleDir ( ) { if ( ! $ this -> moduleDir ) { $ reflection = new ReflectionClass ( static :: class ) ; $ this -> moduleDir = dirname ( $ reflection -> getFileName ( ) ) ; } return $ this -> moduleDir ; }
2322	public static function getPixelValue ( $ size ) { @ trigger_error ( 'Using Image::getPixelValue() has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; $ value = preg_replace ( '/[^0-9.-]+/' , '' , $ size ) ; $ unit = preg_replace ( '/[^acehimnprtvwx%]/' , '' , $ size ) ; switch ( $ unit ) { case '' : case 'px' : return ( int ) round ( $ value ) ; break ; case 'em' : return ( int ) round ( $ value * 16 ) ; break ; case 'ex' : return ( int ) round ( $ value * 16 / 2 ) ; break ; case 'pt' : return ( int ) round ( $ value * 16 / 12 ) ; break ; case 'pc' : return ( int ) round ( $ value * 16 ) ; break ; case 'in' : return ( int ) round ( $ value * 16 * 6 ) ; break ; case 'cm' : return ( int ) round ( $ value * 16 / ( 2.54 / 6 ) ) ; break ; case 'mm' : return ( int ) round ( $ value * 16 / ( 25.4 / 6 ) ) ; break ; case '%' : return ( int ) round ( $ value * 16 / 100 ) ; break ; } return 0 ; }
311	private function applyTableAlias ( $ query , $ conditions , $ alias = null ) { if ( $ alias === null ) { $ alias = array_keys ( $ query -> getTablesUsedInFrom ( ) ) [ 0 ] ; } $ prefixedConditions = [ ] ; foreach ( $ conditions as $ columnName => $ columnValue ) { if ( strpos ( $ columnName , '(' ) === false ) { $ columnName = preg_replace ( '/^' . preg_quote ( $ alias ) . '\.(.*)$/' , '$1' , $ columnName ) ; if ( strpos ( $ columnName , '[[' ) === 0 ) { $ prefixedColumn = "{$alias}.{$columnName}" ; } else { $ prefixedColumn = "{$alias}.[[{$columnName}]]" ; } } else { $ prefixedColumn = $ columnName ; } $ prefixedConditions [ $ prefixedColumn ] = $ columnValue ; } return $ prefixedConditions ; }
8059	public function setSemaphore ( Semaphore $ semaphore ) { if ( $ this -> created ) { throw new WorkerPoolException ( 'Cannot set the Worker Pool Size for a created pool.' ) ; } if ( ! $ semaphore -> isCreated ( ) ) { throw new \ InvalidArgumentException ( 'The Semaphore hasn\'t yet been created.' ) ; } $ this -> semaphore = $ semaphore ; return $ this ; }
165	public static function serialize ( array $ links ) { foreach ( $ links as $ rel => $ link ) { if ( is_array ( $ link ) ) { foreach ( $ link as $ i => $ l ) { $ link [ $ i ] = $ l instanceof self ? array_filter ( ( array ) $ l ) : [ 'href' => $ l ] ; } $ links [ $ rel ] = $ link ; } elseif ( ! $ link instanceof self ) { $ links [ $ rel ] = [ 'href' => $ link ] ; } } return $ links ; }
483	public function createIndex ( $ name , $ table , $ columns , $ unique = false ) { $ time = $ this -> beginCommand ( 'create' . ( $ unique ? ' unique' : '' ) . " index $name on $table (" . implode ( ',' , ( array ) $ columns ) . ')' ) ; $ this -> db -> createCommand ( ) -> createIndex ( $ name , $ table , $ columns , $ unique ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
6511	public function onPreDeserialize ( PreDeserializeEvent $ event ) { $ type = $ event -> getType ( ) ; if ( isset ( $ type [ 'name' ] ) && ( $ type [ 'name' ] == Job :: class || is_subclass_of ( $ type [ 'name' ] , Job :: class ) ) ) { $ data = $ event -> getData ( ) ; if ( isset ( $ data [ 'type' ] ) && isset ( $ data [ 'parameters' ] ) && is_array ( $ data [ 'parameters' ] ) && count ( $ data [ 'parameters' ] ) > 0 ) { array_push ( $ data [ 'parameters' ] , [ 'abc.job.type' => $ data [ 'type' ] ] ) ; $ event -> setData ( $ data ) ; } } }
4241	public function onError ( Event $ error ) { if ( $ this -> debug -> getCfg ( 'collect' ) ) { $ this -> error = $ error ; $ errInfo = $ error [ 'typeStr' ] . ': ' . $ error [ 'file' ] . ' (line ' . $ error [ 'line' ] . ')' ; $ errMsg = $ error [ 'message' ] ; if ( $ error [ 'type' ] & $ this -> debug -> getCfg ( 'errorMask' ) ) { $ this -> debug -> error ( $ errInfo . ': ' , $ errMsg ) ; } else { $ this -> debug -> warn ( $ errInfo . ': ' , $ errMsg ) ; } $ error [ 'continueToNormal' ] = false ; $ error [ 'inConsole' ] = true ; $ error [ 'email' ] = false ; $ this -> error = null ; } elseif ( $ this -> debug -> getCfg ( 'output' ) ) { $ error [ 'email' ] = false ; $ error [ 'inConsole' ] = false ; } else { $ error [ 'inConsole' ] = false ; } }
9766	function instanceOf ( string $ className ) : self { return $ this -> expect ( $ this -> target , isInstanceOf ( $ className ) ) ; }
10003	protected function removeRecursive ( $ path , $ pattern , Logger $ logger ) { if ( ! is_file ( $ path ) && ! is_dir ( $ path ) ) { $ logger -> log ( "$path is not a valid source." , Logger :: WARNING ) ; return ; } if ( ! is_readable ( $ path ) ) { $ logger -> log ( "$path is not readable, skipping." , Logger :: WARNING ) ; return ; } if ( ! is_writeable ( $ parent = dirname ( $ path ) ) ) { $ logger -> log ( "$parent is not writable, skipping." , Logger :: WARNING ) ; return ; } $ matchesPattern = ( ( $ pattern === null ) || ( preg_match ( $ pattern , basename ( $ path ) ) ) ) ; if ( is_file ( $ path ) ) { if ( $ matchesPattern ) { unlink ( $ path ) ; } return ; } $ dh = opendir ( $ path ) ; while ( ( $ file = readdir ( $ dh ) ) !== false ) { if ( ( $ file === '.' ) || ( $ file === '..' ) ) { continue ; } $ this -> removeRecursive ( $ path . '/' . $ file , ( $ matchesPattern ? null : $ pattern ) , $ logger ) ; } if ( $ matchesPattern ) { rmdir ( $ path ) ; } }
2221	public static function findPublishedFromToByPids ( $ intFrom , $ intTo , $ arrPids , $ intLimit = 0 , $ intOffset = 0 , array $ arrOptions = array ( ) ) { if ( empty ( $ arrPids ) || ! \ is_array ( $ arrPids ) ) { return null ; } $ t = static :: $ strTable ; $ arrColumns = array ( "$t.date>=? AND $t.date<=? AND $t.pid IN(" . implode ( ',' , array_map ( '\intval' , $ arrPids ) ) . ")" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.date DESC" ; } $ arrOptions [ 'limit' ] = $ intLimit ; $ arrOptions [ 'offset' ] = $ intOffset ; return static :: findBy ( $ arrColumns , array ( $ intFrom , $ intTo ) , $ arrOptions ) ; }
8160	public function confirm ( ) { $ this -> status = User :: STATUS_ACTIVE ; if ( $ this -> save ( FALSE ) ) return TRUE ; return FALSE ; }
9111	protected function getConfig ( ) { $ config = $ this -> getServiceLocator ( ) -> get ( 'config' ) ; if ( isset ( $ config [ 'yima-theme' ] ) && is_array ( $ config [ 'yima-theme' ] ) ) { $ config = $ config [ 'yima-theme' ] ; } else { $ config = array ( ) ; } return $ config ; }
1650	public function getLngs ( ) : array { $ lngs = [ ] ; foreach ( $ this -> points as $ point ) { $ lngs [ ] = $ point -> getLng ( ) ; } return $ lngs ; }
11761	public static function set ( $ property , $ value = NULL ) { $ object = new \ ReflectionClass ( Collection :: class ) ; $ object -> setStaticPropertyValue ( $ property , $ value ) ; return true ; }
11900	public function getIsMostRecent ( ) { return ! empty ( $ this -> dataInterface ) && $ this -> dataInterface -> lastDataInterfaceLog && $ this -> dataInterface -> lastDataInterfaceLog -> primaryKey === $ this -> primaryKey ; }
7322	public function sidereal ( $ mode = 'a' , Angle $ lon = null ) { $ ut = $ this -> copy ( ) -> toUT1 ( ) ; $ uta = $ ut -> jd ; $ utb = $ ut -> dayFrac ; $ ut = null ; $ tt = $ this -> copy ( ) -> toTT ( ) ; $ tta = $ tt -> jd ; $ ttb = $ tt -> dayFrac ; $ tt = null ; $ st ; if ( $ mode == 'a' ) { $ strad = IAU :: Gst06a ( $ uta , $ utb , $ tta , $ ttb ) ; } else { $ strad = IAU :: Gmst06 ( $ uta , $ utb , $ tta , $ ttb ) ; } if ( $ lon ) { $ st = Angle :: rad ( $ strad ) -> add ( $ lon ) -> norm ( ) -> toTime ( ) ; } else { $ st = Angle :: rad ( $ strad ) -> toTime ( ) ; } return $ st ; }
8974	public function setOutputFormat ( $ format ) { $ output = array ( 'xml' , 'html' , 'text' , 'text-main' ) ; if ( ! in_array ( $ format , $ output ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Available output format: %s' , implode ( ', ' , $ output ) ) ) ; } $ this -> outputFormat = $ format ; return $ this ; }
9869	private function writePageMargins ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { $ objWriter -> startElement ( 'pageMargins' ) ; $ objWriter -> writeAttribute ( 'left' , StringHelper :: formatNumber ( $ pSheet -> getPageMargins ( ) -> getLeft ( ) ) ) ; $ objWriter -> writeAttribute ( 'right' , StringHelper :: formatNumber ( $ pSheet -> getPageMargins ( ) -> getRight ( ) ) ) ; $ objWriter -> writeAttribute ( 'top' , StringHelper :: formatNumber ( $ pSheet -> getPageMargins ( ) -> getTop ( ) ) ) ; $ objWriter -> writeAttribute ( 'bottom' , StringHelper :: formatNumber ( $ pSheet -> getPageMargins ( ) -> getBottom ( ) ) ) ; $ objWriter -> writeAttribute ( 'header' , StringHelper :: formatNumber ( $ pSheet -> getPageMargins ( ) -> getHeader ( ) ) ) ; $ objWriter -> writeAttribute ( 'footer' , StringHelper :: formatNumber ( $ pSheet -> getPageMargins ( ) -> getFooter ( ) ) ) ; $ objWriter -> endElement ( ) ; }
9677	public function allBorders ( Spreadsheet $ spreadsheet ) { $ aBorders = [ ] ; $ aStyles = $ this -> allStyles ( $ spreadsheet ) ; foreach ( $ aStyles as $ style ) { if ( ! isset ( $ aBorders [ $ style -> getBorders ( ) -> getHashCode ( ) ] ) ) { $ aBorders [ $ style -> getBorders ( ) -> getHashCode ( ) ] = $ style -> getBorders ( ) ; } } return $ aBorders ; }
7588	public function setFileName ( $ fileName ) { $ fileName = preg_replace ( "([^\w\s\d\-_~,;\[\]\(\).])" , '' , $ fileName ) ; $ fileName = preg_replace ( "([\.]{2,})" , '' , $ fileName ) ; $ this -> fileName = $ fileName ; return $ this ; }
7911	protected function registerPlugin ( $ name ) { $ view = $ this -> getView ( ) ; SemanticUiPluginAsset :: register ( $ view ) ; $ selector = $ this -> selector ? : '#' . $ this -> options [ 'id' ] ; if ( $ this -> clientOptions !== false ) { $ options = empty ( $ this -> clientOptions ) ? '' : Json :: encode ( $ this -> clientOptions ) ; $ js = "jQuery('$selector').$name($options);" ; $ view -> registerJs ( $ js ) ; } if ( ! empty ( $ this -> clientEvents ) ) { $ js = [ ] ; foreach ( $ this -> clientEvents as $ event => $ handler ) { $ handler = $ handler instanceof JsExpression ? $ handler : new JsExpression ( $ handler ) ; $ js [ ] = "jQuery('$selector').$name('setting', '$event', $handler);" ; } $ view -> registerJs ( implode ( "\n" , $ js ) ) ; } }
6974	private function buildAssociationValue ( ClassMetadata $ metadata , $ propertyPath , $ value ) { $ childMetadata = $ this -> manager -> getClassMetadata ( $ metadata -> getAssociationTargetClass ( $ propertyPath ) ) ; if ( $ metadata -> isSingleValuedAssociation ( $ propertyPath ) ) { if ( is_string ( $ value ) && '#' === substr ( $ value , 0 , 1 ) ) { return $ this -> getReference ( substr ( $ value , 1 ) ) ; } elseif ( is_array ( $ value ) ) { return $ this -> buildEntity ( $ childMetadata , $ value ) ; } throw new \ Exception ( "Unexpected value for single association '$propertyPath'." ) ; } elseif ( $ metadata -> isCollectionValuedAssociation ( $ propertyPath ) ) { if ( ! is_array ( $ value ) ) { throw new \ Exception ( 'Expected array.' ) ; } $ builtValue = [ ] ; foreach ( $ value as $ childData ) { if ( is_string ( $ childData ) && '#' === substr ( $ childData , 0 , 1 ) ) { array_push ( $ builtValue , $ this -> getReference ( substr ( $ childData , 1 ) ) ) ; } elseif ( is_array ( $ value ) ) { array_push ( $ builtValue , $ this -> buildEntity ( $ childMetadata , $ childData ) ) ; } else { throw new \ Exception ( "Unexpected value for association '$propertyPath'." ) ; } } return $ builtValue ; } throw new \ Exception ( "Unexpected association path '$propertyPath'." ) ; }
11482	public function saveAllPages ( BlockManagerApprover $ approver , array $ languages , $ saveCommonSlots = true ) { $ this -> contributorDefined ( ) ; $ finder = new Finder ( ) ; $ pages = $ finder -> directories ( ) -> depth ( 0 ) -> in ( $ this -> pagesDir ) ; foreach ( $ pages as $ page ) { $ page = ( string ) $ page ; $ pageName = basename ( $ page ) ; foreach ( $ languages as $ language ) { $ tokens = explode ( "_" , $ language ) ; $ options = array ( 'page' => $ pageName , 'language' => $ tokens [ 0 ] , 'country' => $ tokens [ 1 ] , ) ; $ this -> save ( $ approver , $ options , $ saveCommonSlots ) ; } $ saveCommonSlots = false ; } Dispatcher :: dispatch ( PageCollectionEvents :: SITE_SAVED , new SiteSavedEvent ( ) ) ; DataLogger :: log ( 'The whole website\'s pages were successfully saved in production' ) ; }
2369	public static function splitFriendlyEmail ( $ strEmail ) { if ( strpos ( $ strEmail , '<' ) !== false ) { return array_map ( 'trim' , explode ( ' <' , str_replace ( '>' , '' , $ strEmail ) ) ) ; } elseif ( strpos ( $ strEmail , '[' ) !== false ) { return array_map ( 'trim' , explode ( ' [' , str_replace ( ']' , '' , $ strEmail ) ) ) ; } else { return array ( '' , $ strEmail ) ; } }
9596	public function makeSession ( ) { $ session = new Session ( $ this -> dic -> resolve ( 'Symfony\Component\HttpFoundation\Session\Storage\SessionStorageInterface' ) , $ this -> dic -> resolve ( 'Symfony\Component\HttpFoundation\Session\Attribute\AttributeBagInterface' ) , $ this -> dic -> resolve ( 'Symfony\Component\HttpFoundation\Session\Flash\FlashBagInterface' ) ) ; $ session -> setName ( $ this -> config -> get ( 'session.cookie.name' , 'autarky_session' ) ) ; return $ session ; }
9758	function closeTo ( $ value , float $ delta ) : self { return $ this -> expect ( $ this -> target , equalTo ( $ value , $ delta ) ) ; }
428	public function init ( ) { if ( $ this -> controllerNamespace === null ) { $ class = get_class ( $ this ) ; if ( ( $ pos = strrpos ( $ class , '\\' ) ) !== false ) { $ this -> controllerNamespace = substr ( $ class , 0 , $ pos ) . '\\controllers' ; } } }
554	private function notifyCachesCanBeFlushed ( $ caches ) { $ this -> stdout ( "The following caches were found in the system:\n\n" , Console :: FG_YELLOW ) ; foreach ( $ caches as $ name => $ class ) { if ( $ this -> canBeFlushed ( $ class ) ) { $ this -> stdout ( "\t* $name ($class)\n" , Console :: FG_GREEN ) ; } else { $ this -> stdout ( "\t* $name ($class) - can not be flushed via console\n" , Console :: FG_YELLOW ) ; } } $ this -> stdout ( "\n" ) ; }
5094	public function executeIterator ( ) { $ result = $ this -> execute ( ) ; if ( ! $ result ) throw new MySqlException ( 'Could not execute multiset query!' ) ; while ( true ) { yield new StatementResult ( $ result ) ; if ( ! $ result -> nextRowset ( ) ) { $ this -> checkForError ( $ result ) ; break ; } } }
10225	public function itemsFor ( $ model , $ items = null , $ targetUrl = null , $ nextPageUrl = null , $ offset = - 1 , ModelConfig $ config = null ) { $ modelName = $ this -> resolveModelName ( $ model ) ; if ( $ items == null ) { $ items = call_user_func ( array ( $ modelName , 'simplePaginate' ) , 10 ) ; } $ factory = $ this -> app -> make ( 'Label305\AujaLaravel\Factory\ResourceItemsFactory' ) ; return $ factory -> create ( $ modelName , $ items , $ targetUrl , $ nextPageUrl , $ offset , $ config ) ; }
4572	public function setIdentityUuid ( ? string $ identityUuid ) { if ( null !== $ identityUuid ) { if ( ! preg_match ( '/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i' , $ identityUuid ) ) { throw new InvalidArgumentException ( 'Identity uuid is not valid.' ) ; } } $ this -> identityUuid = $ identityUuid ; return $ this ; }
1204	protected function renderChildren ( ItemInterface $ item , array $ options ) { if ( null !== $ options [ 'depth' ] ) { $ options [ 'depth' ] = $ options [ 'depth' ] - 1 ; } if ( null !== $ options [ 'matchingDepth' ] && $ options [ 'matchingDepth' ] > 0 ) { $ options [ 'matchingDepth' ] = $ options [ 'matchingDepth' ] - 1 ; } $ html = '' ; foreach ( $ item -> getChildren ( ) as $ child ) { $ html .= $ this -> renderItem ( $ child , $ options ) ; } return $ html ; }
2627	public function renderCellTemplate ( $ columnName ) { if ( $ columnName == 'store_id' && isset ( $ this -> _columns [ $ columnName ] ) ) { $ options = $ this -> getOptions ( __ ( '-- Select Store --' ) ) ; $ element = $ this -> elementFactory -> create ( 'select' ) ; $ element -> setForm ( $ this -> getForm ( ) ) -> setName ( $ this -> _getCellInputElementName ( $ columnName ) ) -> setHtmlId ( $ this -> _getCellInputElementId ( '<%- _id %>' , $ columnName ) ) -> setValues ( $ options ) ; return str_replace ( "\n" , '' , $ element -> getElementHtml ( ) ) ; } return parent :: renderCellTemplate ( $ columnName ) ; }
6941	private function getPurchaseCost ( Model \ SaleItemInterface $ item ) { if ( null === $ subject = $ this -> subjectHelper -> resolve ( $ item ) ) { return null ; } $ currency = $ item -> getSale ( ) -> getCurrency ( ) -> getCode ( ) ; if ( null !== $ cost = $ this -> purchaseCostGuesser -> guess ( $ subject , $ currency ) ) { return $ cost ; } return null ; }
11538	public function setItems ( $ items ) { $ this -> _items = $ items ; if ( isset ( $ this -> _items [ 0 ] ) && is_array ( $ this -> _items [ 0 ] ) ) { $ this -> _items = $ this -> _items [ 0 ] ; } foreach ( $ this -> _items as $ item ) { $ item -> owner = $ this ; if ( ! $ item -> isValid ) { $ this -> isValid = false ; } } }
2947	public function grant ( $ permission ) { if ( $ this -> hasPermission ( $ permission ) ) { return true ; } if ( ! array_key_exists ( $ permission , Gate :: abilities ( ) ) ) { abort ( 403 , 'Unknown permission' ) ; } return Permission :: create ( [ 'role_id' => $ this -> id , 'permission_slug' => $ permission , ] ) ; return false ; }
12500	public static function update ( $ id , $ document , $ connection ) { $ from = $ connection -> db ; if ( strpos ( $ from , '.' ) !== false ) { $ tmp = explode ( '.' , $ connection -> db ) ; $ from = end ( $ tmp ) ; } $ connection -> method = 'PATCH' ; $ connection -> action = '[' . urlencode ( $ id ) . ']' ; switch ( gettype ( $ document ) ) { case "string" : $ connection -> query = $ document ; break ; case "array" : case "object" : $ connection -> method = 'POST' ; $ connection -> action = '/_query' ; $ connection -> query = 'UPDATE ' . $ from . '["' . $ id . '"] SET ' . self :: updateRecursion ( $ document ) ; break ; default : throw new ClusterpointException ( "\"->update()\" function: parametr passed " . json_encode ( self :: escape_string ( $ document ) ) . " is not in valid format." , 9002 ) ; break ; } return self :: sendQuery ( $ connection ) ; }
8107	protected function getTemplateVariables ( $ recipient , $ config , $ pages ) { return [ 'Subject' => $ config -> ReviewSubject , 'PagesCount' => $ pages -> count ( ) , 'FromEmail' => $ config -> ReviewFrom , 'ToFirstName' => $ recipient -> FirstName , 'ToSurname' => $ recipient -> Surname , 'ToEmail' => $ recipient -> Email , ] ; }
10548	public function setTemplate ( Template $ template ) { $ this -> template = $ template ; $ this -> setVariable ( 'template' , $ template ) ; $ this -> setVariable ( 'tpl' , $ template ) ; return $ this ; }
9966	public function fromArray ( array $ source , $ nullValue = null , $ startCell = 'A1' , $ strictNullComparison = false ) { if ( ! is_array ( end ( $ source ) ) ) { $ source = [ $ source ] ; } list ( $ startColumn , $ startRow ) = Coordinate :: coordinateFromString ( $ startCell ) ; foreach ( $ source as $ rowData ) { $ currentColumn = $ startColumn ; foreach ( $ rowData as $ cellValue ) { if ( $ strictNullComparison ) { if ( $ cellValue !== $ nullValue ) { $ this -> getCell ( $ currentColumn . $ startRow ) -> setValue ( $ cellValue ) ; } } else { if ( $ cellValue != $ nullValue ) { $ this -> getCell ( $ currentColumn . $ startRow ) -> setValue ( $ cellValue ) ; } } ++ $ currentColumn ; } ++ $ startRow ; } return $ this ; }
10511	public function notify ( ) { $ observersToNotify = array ( ) ; foreach ( $ this -> _observers as $ observer ) { if ( $ this -> checkIfObserverMustBeUpdate ( $ observer ) ) { $ observersToNotify [ ] = $ observer ; } } usort ( $ observersToNotify , array ( $ this , 'orderObserversForPriority' ) ) ; foreach ( $ observersToNotify as $ observer ) { try { $ this -> updateObserverState ( $ observer ) ; } catch ( \ Exception $ e ) { if ( ( int ) $ e -> getCode ( ) === 600 ) { break 1 ; } } } }
7252	protected function validatePaymentTermAndOutstandingLimit ( SaleInterface $ sale , Constraint $ constraint ) { if ( 0 >= $ sale -> getOutstandingLimit ( ) ) { return ; } if ( null === $ term = $ sale -> getPaymentTerm ( ) ) { if ( null !== $ customer = $ sale -> getCustomer ( ) ) { if ( $ customer -> hasParent ( ) ) { $ term = $ customer -> getParent ( ) -> getPaymentTerm ( ) ; } else { $ term = $ customer -> getPaymentTerm ( ) ; } } } if ( null === $ term ) { $ this -> context -> buildViolation ( $ constraint -> outstanding_limit_require_term ) -> atPath ( 'outstandingLimit' ) -> addViolation ( ) ; } }
518	private function generateClassName ( $ name ) { $ namespace = null ; $ name = trim ( $ name , '\\' ) ; if ( strpos ( $ name , '\\' ) !== false ) { $ namespace = substr ( $ name , 0 , strrpos ( $ name , '\\' ) ) ; $ name = substr ( $ name , strrpos ( $ name , '\\' ) + 1 ) ; } else { if ( $ this -> migrationPath === null ) { $ migrationNamespaces = $ this -> migrationNamespaces ; $ namespace = array_shift ( $ migrationNamespaces ) ; } } if ( $ namespace === null ) { $ class = 'm' . gmdate ( 'ymd_His' ) . '_' . $ name ; } else { $ class = 'M' . gmdate ( 'ymdHis' ) . ucfirst ( $ name ) ; } return [ $ namespace , $ class ] ; }
8460	public function exec ( $ command ) { fwrite ( $ this -> _fp , str_replace ( "\n" , '\n' , $ command ) . PHP_EOL ) ; $ answer = fgets ( $ this -> _fp ) ; if ( is_string ( $ answer ) ) { if ( substr ( $ answer , 0 , 7 ) === 'ANSWER ' ) { $ bytes = ( int ) substr ( $ answer , 7 ) ; if ( $ bytes > 0 ) { $ jsonObj = json_decode ( trim ( fread ( $ this -> _fp , $ bytes + 1 ) ) ) ; if ( is_null ( $ jsonObj ) ) { return 'You must enable the json flag on the telegram daemon to get proper response messages here.' ; } return $ jsonObj ; } } else { return $ answer ; } } return false ; }
7958	public function isIpv6Enabled ( $ forceReload = false ) { if ( ! $ this -> properties || $ forceReload ) $ this -> getProperties ( ) ; return $ this -> properties -> ipv6Enabled ; }
3693	public function createAttribute ( $ information , $ metaModel ) { $ event = new CreateAttributeEvent ( $ information , $ metaModel ) ; $ this -> eventDispatcher -> dispatch ( CreateAttributeEvent :: NAME , $ event ) ; if ( $ event -> getAttribute ( ) ) { return $ event -> getAttribute ( ) ; } $ factory = $ this -> getTypeFactory ( $ information [ 'type' ] ) ; if ( ! $ factory ) { return null ; } return $ factory -> createInstance ( $ information , $ metaModel ) ; }
8229	public static function readFile ( $ fileName , $ options = [ ] ) { $ reader = new File \ FileReader ( $ fileName , $ options ) ; $ success = true ; $ contents = null ; try { $ reader -> open ( ) ; $ contents = $ reader -> read ( ) ; } catch ( \ RuntimeException $ e ) { self :: $ lastError = $ e -> getMessage ( ) ; $ success = false ; } try { $ reader -> close ( ) ; } catch ( \ RuntimeException $ e ) { self :: $ lastError = $ e -> getMessage ( ) ; $ success = false ; } return ( $ success ) ? $ contents : false ; }
3753	public function save ( ModelInterface $ objItem , $ timestamp = null ) { if ( null === $ timestamp ) { @ \ trigger_error ( 'Not passing a timestamp has been deprecated and will cause an error in MetaModels 3' , E_USER_DEPRECATED ) ; } if ( $ objItem instanceof Model ) { $ backupLanguage = $ this -> setLanguage ( $ this -> getCurrentLanguage ( ) ) ; $ objItem -> getItem ( ) -> save ( $ timestamp ) ; $ this -> setLanguage ( $ backupLanguage ) ; return $ objItem ; } throw new \ RuntimeException ( 'ERROR: incompatible object passed to GeneralDataMetaModel::save()' ) ; }
8539	public function setGetMyPriceForASINResult ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'GetMyPriceForASINResult' ] [ 'FieldValue' ] = $ value ; return $ this ; }
5373	public function getValue ( $ key ) { $ values = array ( ) ; foreach ( $ this -> request as $ pair ) { if ( $ pair -> isKey ( $ key ) ) { $ values [ ] = $ pair -> getValue ( ) ; } } if ( count ( $ values ) == 0 ) { return false ; } elseif ( count ( $ values ) == 1 ) { return $ values [ 0 ] ; } else { return $ values ; } }
8827	public function token ( ) { $ token = ! empty ( $ this -> csrfToken ) ? $ this -> csrfToken : csrfToken ( ) ; return $ this -> hidden ( '_token' , $ token ) ; }
12341	protected function printError ( \ Throwable $ error , bool $ withTime = true , ? string $ fontColor = null , ? string $ bgColor = self :: BG_COLOR_MAP [ 'red' ] ) : void { $ shift = $ withTime ? "\t\t" : '' ; $ this -> print ( $ this -> getColoredMsg ( 'Error: ' . $ error -> getMessage ( ) , $ fontColor , $ bgColor ) . \ PHP_EOL . $ shift . $ this -> getColoredMsg ( 'File: ' . $ error -> getFile ( ) , $ fontColor , $ bgColor ) . \ PHP_EOL . $ shift . $ this -> getColoredMsg ( 'Line: ' . $ error -> getLine ( ) , $ fontColor , $ bgColor ) , $ withTime ) ; }
4091	public function createPayload ( ) { $ payloads = array ( ) ; foreach ( $ this -> operations as $ operation ) { foreach ( $ operation as $ partial ) { $ payloads [ ] = json_encode ( $ partial ) ; } } return join ( "\n" , $ payloads ) . "\n" ; }
11515	public function getNamedParam ( string $ category , string $ key ) { $ params = $ this -> getNamedParams ( $ category ) ; return $ params [ $ key ] ?? '' ; }
12489	protected static function setPath ( $ writePath ) { if ( is_file ( $ writePath ) ) { self :: $ logFilePath = $ writePath ; return true ; } throw new \ Exception ( 'Impossible de modifier la destination des logs : le fichier ' . $ writePath . ' n\'existe pas.' ) ; return false ; }
11306	public static function getDataFromId ( $ id ) { $ db = Neuron_Core_Database :: __getInstance ( ) ; $ id = intval ( $ id ) ; $ r = $ db -> getDataFromQuery ( $ db -> customQuery ( " SELECT * FROM n_players WHERE n_players.plid = '" . $ id . "' " ) ) ; if ( count ( $ r ) == 1 ) { return $ r [ 0 ] ; } return null ; }
11162	protected function getKey ( array $ config ) { if ( ! isset ( $ config [ 'key' ] ) || ! is_string ( $ config [ 'key' ] ) ) { throw new \ DomainException ( 'key must reference a string' , self :: ERR_INVALID_KEY ) ; } return $ config [ 'key' ] ; }
1622	private function addColumn ( $ column , & $ columns ) { if ( isset ( $ columns [ $ column ] ) ) { return $ columns [ $ column ] ; } $ name = 'c' . preg_replace ( "/[^a-z]+/i" , "" , $ column ) . count ( $ columns ) ; return $ columns [ $ column ] = $ name ; }
930	public function transform ( Tokens $ tokens ) { foreach ( $ this -> items as $ transformer ) { foreach ( $ tokens as $ index => $ token ) { $ transformer -> process ( $ tokens , $ token , $ index ) ; } } }
9881	private function writeCalcPr ( XMLWriter $ objWriter , $ recalcRequired = true ) { $ objWriter -> startElement ( 'calcPr' ) ; $ objWriter -> writeAttribute ( 'calcId' , '999999' ) ; $ objWriter -> writeAttribute ( 'calcMode' , 'auto' ) ; $ objWriter -> writeAttribute ( 'calcCompleted' , ( $ recalcRequired ) ? 1 : 0 ) ; $ objWriter -> writeAttribute ( 'fullCalcOnLoad' , ( $ recalcRequired ) ? 0 : 1 ) ; $ objWriter -> endElement ( ) ; }
8436	public static function fetchArray ( array $ conditions , array $ orderBy = null , bool $ critical = false ) { $ entity = new static ( ) ; $ selectQuery = new Select ( $ entity -> getDatabaseName ( ) , $ critical ) ; $ selectQuery -> select ( $ entity -> getAllFieldsRealNames ( ) ) ; $ selectQuery -> from ( $ entity -> getTableName ( ) ) ; if ( count ( $ conditions ) > 0 ) { $ where = array ( ) ; foreach ( $ conditions as $ key => $ value ) { $ realName = constant ( get_called_class ( ) . '::FIELD_' . strtoupper ( Helper :: codifyName ( $ key ) ) ) ; $ where [ $ realName ] = ':where' . ucfirst ( $ key ) ; $ selectQuery -> bind ( 'where' . ucfirst ( $ key ) , $ value ) ; } $ selectQuery -> where ( $ where ) ; } if ( is_array ( $ orderBy ) && count ( $ orderBy ) > 0 ) { $ orders = array ( ) ; foreach ( $ orderBy as $ key => $ value ) { $ realName = constant ( get_called_class ( ) . '::FIELD_' . strtoupper ( Helper :: codifyName ( $ key ) ) ) ; $ orders [ $ realName ] = strtoupper ( ucfirst ( $ value ) ) ; } $ selectQuery -> orderBy ( $ orders ) ; } $ selectQuery -> limit ( 1 ) ; if ( $ selectQuery -> execute ( ) === false ) { return false ; } $ data = $ selectQuery -> fetch ( ) ; if ( is_array ( $ data ) === false ) { return false ; } return $ data ; }
5781	private function getSectionForAdministrator ( array $ section , string $ sectionName ) : array { if ( isset ( $ section [ 'authorization' ] ) && ! $ this -> container -> authorization -> isAuthorized ( $ section [ 'authorization' ] ) ) { return [ ] ; } $ updatedSection = [ ] ; foreach ( $ section as $ key => $ value ) { if ( $ key != 'subSections' ) { $ updatedSection [ $ key ] = $ value ; } } $ updatedSubSections = [ ] ; if ( isset ( $ section [ 'subSections' ] ) ) { foreach ( $ section [ 'subSections' ] as $ subSectionName => $ subSection ) { $ updatedSubSection = $ this -> getSectionForAdministrator ( $ subSection , $ subSectionName ) ; if ( count ( $ updatedSubSection ) > 0 ) { $ updatedSubSections [ $ subSectionName ] = $ updatedSubSection ; } } } if ( count ( $ updatedSubSections ) > 0 ) { $ updatedSection [ 'subSections' ] = $ updatedSubSections ; } return $ updatedSection ; }
12212	public function getSnippet ( string $ snptName = '' ) { if ( empty ( $ snptName ) ) { return $ this -> snippets ; } else { return isset ( $ this -> snippets [ $ snptName ] ) ? $ this -> snippets [ $ snptName ] : null ; } }
8297	protected function createBkFile ( ) { if ( ! is_writable ( dirname ( $ this -> filePath ) ) ) { return ; } $ this -> bkFilePath = $ this -> filePath . '.' . date ( "y-m-d-H-i-s" ) . '.bak' ; $ bkHandle = @ fopen ( $ this -> bkFilePath , 'x+' ) ; if ( $ bkHandle === false ) { $ this -> close ( ) ; throw new \ RuntimeException ( "Could not create a temporary file " . $ this -> bkFilePath ) ; } $ stat = fstat ( $ this -> handle ) ; if ( stream_copy_to_stream ( $ this -> handle , $ bkHandle ) !== $ stat [ 'size' ] ) { $ this -> close ( ) ; throw new \ RuntimeException ( "Could not create a copy of " . $ this -> filePath ) ; } if ( ! fclose ( $ bkHandle ) ) { throw new \ RuntimeException ( "Could not close a backup file " . $ this -> bkFilePath ) ; } fseek ( $ this -> handle , 0 ) ; }
5131	protected function filterPort ( ? int $ port ) : ? int { if ( ( integer ) $ port >= 0 && ( integer ) $ port <= 65535 ) { return $ port ; } throw new InvalidArgumentException ( 'Uri port must be null or an integer between 1 and 65535 (inclusive)' ) ; }
6424	protected function getClient ( $ redirecturl = '' ) { if ( is_object ( $ this -> google ) ) { return $ this -> google ; } if ( $ redirecturl == '' ) { $ redirecturl = $ this -> redirecturl ; } else { $ this -> redirecturl = $ redirecturl ; } $ client = new \ Google_Client ( ) ; $ client -> setApplicationName ( $ this -> options [ 'application_name' ] ) ; $ client -> setClientId ( $ this -> options [ 'client_id' ] ) ; $ client -> setClientSecret ( $ this -> options [ 'client_secret' ] ) ; $ client -> setRedirectUri ( $ redirecturl ) ; $ client -> setDeveloperKey ( $ this -> options [ 'api_key' ] ) ; $ client -> setScopes ( array ( 'https://www.googleapis.com/auth/userinfo.profile' , 'https://www.googleapis.com/auth/userinfo.email' ) ) ; $ this -> google = $ client ; return $ client ; }
5707	public function getButtonLink ( ) { $ link = Controller :: join_links ( 'customaction' , $ this -> actionName ) ; return $ this -> gridFieldRequest -> Link ( $ link ) ; }
7106	protected function calculateTotalByState ( PaymentSubjectInterface $ subject , $ state ) { PaymentStates :: isValidState ( $ state , true ) ; $ currency = $ subject -> getCurrency ( ) -> getCode ( ) ; $ total = 0 ; foreach ( $ subject -> getPayments ( ) as $ payment ) { if ( $ payment -> getState ( ) === $ state ) { $ total += $ this -> convertPaymentAmount ( $ payment , $ currency ) ; } } return $ total ; }
4215	private static function keys ( $ val ) { if ( Abstracter :: isAbstraction ( $ val ) ) { if ( $ val [ 'type' ] == 'object' ) { if ( $ val [ 'traverseValues' ] ) { $ val = $ val [ 'traverseValues' ] ; } elseif ( $ val [ 'stringified' ] ) { $ val = null ; } elseif ( isset ( $ val [ 'methods' ] [ '__toString' ] [ 'returnValue' ] ) ) { $ val = null ; } else { $ val = \ array_filter ( $ val [ 'properties' ] , function ( $ prop ) { return $ prop [ 'visibility' ] === 'public' ; } ) ; \ ksort ( $ val , SORT_NATURAL | SORT_FLAG_CASE ) ; } } else { $ val = null ; } } return \ is_array ( $ val ) ? \ array_keys ( $ val ) : array ( self :: SCALAR ) ; }
2242	public static function getContentElement ( $ intId , $ strColumn = 'main' ) { if ( \ is_object ( $ intId ) ) { $ objRow = $ intId ; } else { if ( ! \ strlen ( $ intId ) || $ intId < 1 ) { return '' ; } $ objRow = ContentModel :: findByPk ( $ intId ) ; if ( $ objRow === null ) { return '' ; } } if ( ! static :: isVisibleElement ( $ objRow ) ) { return '' ; } $ strClass = ContentElement :: findClass ( $ objRow -> type ) ; if ( ! class_exists ( $ strClass ) ) { static :: log ( 'Content element class "' . $ strClass . '" (content element "' . $ objRow -> type . '") does not exist' , __METHOD__ , TL_ERROR ) ; return '' ; } $ objRow -> typePrefix = 'ce_' ; $ objElement = new $ strClass ( $ objRow , $ strColumn ) ; $ strBuffer = $ objElement -> generate ( ) ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getContentElement' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getContentElement' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getContentElement' ] as $ callback ) { $ strBuffer = static :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ objRow , $ strBuffer , $ objElement ) ; } } if ( $ objElement -> protected && ! preg_match ( '/^\s*<!-- indexer::stop/' , $ strBuffer ) ) { $ strBuffer = "\n<!-- indexer::stop . $ strBuffer . "<!-- indexer::continue ; } return $ strBuffer ; }
4863	public function retry ( JobInterface $ job , array $ options = [ ] ) { $ tried = $ job -> getMetadata ( 'mongoqueue.tries' , 0 ) + 1 ; $ job -> setMetaData ( 'mongoqueue.tries' , $ tried ) ; $ options [ 'tried' ] = $ tried ; $ envelope = $ this -> createEnvelope ( $ job , $ options ) ; unset ( $ envelope [ 'created' ] ) ; $ this -> mongoCollection -> findOneAndUpdate ( [ '_id' => new \ MongoDB \ BSON \ ObjectID ( $ job -> getId ( ) ) ] , [ '$set' => $ envelope ] ) ; }
7486	public function indexOf ( $ string , $ offset = null ) { $ string = static :: convertString ( $ string , $ this -> encoding ) ; $ offset = $ offset !== null ? ( int ) $ offset : null ; if ( $ offset !== null && ( $ offset < 0 || $ offset >= $ this -> length ( ) ) ) { throw new \ OutOfBoundsException ( ) ; } return mb_strpos ( $ this -> string , $ string , $ offset , $ this -> encoding ) ; }
7735	private function documentRouteAndOperations ( $ metadata , Reflector $ element ) { if ( ( null !== ( $ annotation = $ this -> getAnnotation ( $ element , 'ML\HydraBundle\Mapping\Id' ) ) ) || ( null !== ( $ annotation = $ this -> getAnnotation ( $ element , 'ML\HydraBundle\Mapping\Route' ) ) ) ) { $ metadata -> setRoute ( $ this -> getRouteMetadata ( $ annotation -> route ) ) ; } $ annotation = $ this -> getAnnotation ( $ element , 'ML\HydraBundle\Mapping\Operations' ) ; if ( null !== $ annotation ) { $ operations = array_unique ( $ annotation -> operations ) ; $ operationsMetadata = array_map ( array ( $ this , 'getRouteMetadata' ) , $ operations ) ; $ metadata -> setOperations ( $ operationsMetadata ) ; } if ( null !== ( $ route = $ metadata -> getRoute ( ) ) ) { $ metadata -> addOperation ( $ this -> getRouteMetadata ( $ route -> getName ( ) ) ) ; } elseif ( null !== $ annotation ) { $ metadata -> setRoute ( $ this -> getRouteMetadata ( reset ( $ annotation -> operations ) ) ) ; } if ( ( $ metadata instanceof PropertyDefinition ) && ( count ( $ operations = $ metadata -> getOperations ( ) ) > 0 ) ) { foreach ( $ operations as $ operation ) { if ( ( 'GET' === $ operation -> getMethod ( ) ) && ( null !== $ operation -> getReturns ( ) ) ) { $ metadata -> setType ( $ operation -> getReturns ( ) ) ; return ; } } $ metadata -> setType ( 'ML\HydraBundle\Entity\Resource' ) ; } }
12145	public function set ( $ name , $ value = null ) { if ( $ value == null ) { return false ; } $ this -> settings [ $ name ] = $ value ; }
660	public function createCommand ( $ sql = null , $ params = [ ] ) { $ driver = $ this -> getDriverName ( ) ; $ config = [ 'class' => 'yii\db\Command' ] ; if ( $ this -> commandClass !== $ config [ 'class' ] ) { $ config [ 'class' ] = $ this -> commandClass ; } elseif ( isset ( $ this -> commandMap [ $ driver ] ) ) { $ config = ! is_array ( $ this -> commandMap [ $ driver ] ) ? [ 'class' => $ this -> commandMap [ $ driver ] ] : $ this -> commandMap [ $ driver ] ; } $ config [ 'db' ] = $ this ; $ config [ 'sql' ] = $ sql ; $ command = Yii :: createObject ( $ config ) ; return $ command -> bindValues ( $ params ) ; }
9176	public function getPlugins ( ) { foreach ( $ this -> getOperations ( ) as $ operation ) { if ( $ this -> getOperation ( ) -> equals ( $ operation ) ) { return $ operation -> getPlugins ( ) ; } } throw new \ Exception ( sprintf ( 'Can\'t find any plugins for operation %s' , $ this -> getOperation ( ) ) ) ; }
8575	public function setItemChargeList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ItemChargeList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
3521	public static function login ( $ email , $ password , $ challenge = '' , $ code = '' ) { $ requestParams = [ 'includePerms' => 'false' , 'token_type' => 'eg1' ] ; if ( empty ( $ challenge ) && empty ( $ code ) ) { $ requestParams = array_merge ( $ requestParams , [ 'grant_type' => 'password' , 'username' => $ email , 'password' => $ password , ] ) ; } else { $ requestParams = array_merge ( $ requestParams , [ 'grant_type' => 'otp' , 'otp' => $ code , 'challenge' => $ challenge , ] ) ; } $ data = FortniteClient :: sendUnrealClientPostRequest ( FortniteClient :: EPIC_OAUTH_TOKEN_ENDPOINT , $ requestParams ) ; if ( ! isset ( $ data -> access_token ) ) { if ( $ data -> errorCode === 'errors.com.epicgames.common.two_factor_authentication.required' ) { throw new TwoFactorAuthRequiredException ( $ data -> challenge ) ; } throw new \ Exception ( $ data -> errorMessage ) ; } $ data = FortniteClient :: sendUnrealClientGetRequest ( FortniteClient :: EPIC_OAUTH_EXCHANGE_ENDPOINT , $ data -> access_token , true ) ; if ( ! isset ( $ data -> code ) ) { throw new \ Exception ( $ data -> errorMessage ) ; } $ data = FortniteClient :: sendUnrealClientPostRequest ( FortniteClient :: EPIC_OAUTH_TOKEN_ENDPOINT , [ 'grant_type' => 'exchange_code' , 'exchange_code' => $ data -> code , 'includePerms' => false , 'token_type' => 'eg1' ] , FortniteClient :: FORTNITE_AUTHORIZATION ) ; if ( ! isset ( $ data -> access_token ) ) { throw new \ Exception ( $ data -> errorMessage ) ; } return new self ( $ data -> access_token , $ data -> in_app_id , $ data -> refresh_token , $ data -> account_id , $ data -> expires_in ) ; }
2229	public function dragFile ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { return '<button type="button" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '" ' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</button> ' ; }
11084	public static function deleteDirectory ( $ dirName , $ deleteSelf = true ) { $ dirName = rtrim ( $ dirName , '/' ) . '/' ; if ( file_exists ( $ dirName ) && $ files = scandir ( $ dirName , SCANDIR_SORT_NONE ) ) { foreach ( $ files as $ file ) { if ( $ file !== '.' && $ file !== '..' && $ file !== '.svn' ) { if ( is_dir ( $ dirName . $ file ) ) { self :: deleteDirectory ( $ dirName . $ file , true ) ; } elseif ( file_exists ( $ dirName . $ file ) ) { @ chmod ( $ dirName . $ file , 0777 ) ; unlink ( $ dirName . $ file ) ; } } } if ( $ deleteSelf && ! rmdir ( $ dirName ) ) { @ chmod ( $ dirName , 0777 ) ; return false ; } return true ; } return false ; }
7511	protected function parse_linebreak ( ) { if ( $ this -> doc [ $ this -> pos ] === "\r" ) { ++ $ this -> line_pos [ 0 ] ; if ( ( ( $ this -> pos + 1 ) < $ this -> size ) && ( $ this -> doc [ $ this -> pos + 1 ] === "\n" ) ) { ++ $ this -> pos ; } $ this -> line_pos [ 1 ] = $ this -> pos ; } elseif ( $ this -> doc [ $ this -> pos ] === "\n" ) { ++ $ this -> line_pos [ 0 ] ; $ this -> line_pos [ 1 ] = $ this -> pos ; } }
10638	protected function processUploadedFiles ( FileBag $ filebag ) { $ adapter = new LocalAdapter ( $ this -> get ( 'kernel' ) -> getRootDir ( ) . '/../web/media' ) ; $ filesystem = new Filesystem ( $ adapter ) ; $ processed = array ( ) ; if ( $ filebag -> get ( 'files' ) ) { foreach ( $ filebag -> get ( 'files' ) as $ file ) { $ dest = $ this -> createUniquePath ( $ file ) ; if ( $ filesystem -> write ( $ dest [ 'path' ] , file_get_contents ( $ file -> getPathname ( ) ) ) ) { $ processed [ ] = $ dest [ 'path' ] ; } ; } } return $ processed ; }
2402	public function previewRoute ( $ strName , $ arrParams = array ( ) ) { $ objRouter = System :: getContainer ( ) -> get ( 'router' ) ; $ objContext = $ objRouter -> getContext ( ) ; $ objPreviewContext = clone $ objContext ; $ objPreviewContext -> setBaseUrl ( '/preview.php' ) ; $ objRouter -> setContext ( $ objPreviewContext ) ; $ strUrl = $ objRouter -> generate ( $ strName , $ arrParams ) ; $ strUrl = substr ( $ strUrl , \ strlen ( Environment :: get ( 'path' ) ) + 1 ) ; $ objRouter -> setContext ( $ objContext ) ; return ampersand ( $ strUrl ) ; }
5791	public function isDeletable ( ) : bool { if ( in_array ( $ this -> title , self :: UNDELETABLE ) ) { return false ; } return ( PermissionsTableMapper :: getInstance ( ) ) -> isDeletable ( ) ; }
6477	public function readAsMultipart ( ? IHttpBody $ body , string $ boundary ) : ? MultipartBody { if ( $ body === null ) { return null ; } $ rawBodyParts = explode ( "--$boundary" , $ body -> readAsString ( ) ) ; array_shift ( $ rawBodyParts ) ; array_pop ( $ rawBodyParts ) ; $ parsedBodyParts = [ ] ; foreach ( $ rawBodyParts as $ rawBodyPart ) { $ headerStartIndex = strlen ( "\r\n" ) ; $ headerEndIndex = strpos ( $ rawBodyPart , "\r\n\r\n" ) ; $ bodyStartIndex = $ headerEndIndex + strlen ( "\r\n\r\n" ) ; $ bodyEndIndex = strlen ( $ rawBodyPart ) - strlen ( "\r\n" ) ; $ rawHeaders = explode ( "\r\n" , substr ( $ rawBodyPart , $ headerStartIndex , $ headerEndIndex - $ headerStartIndex ) ) ; $ parsedHeaders = new HttpHeaders ( ) ; foreach ( $ rawHeaders as $ headerLine ) { [ $ headerName , $ headerValue ] = explode ( ':' , $ headerLine , 2 ) ; $ parsedHeaders -> add ( trim ( $ headerName ) , trim ( $ headerValue ) ) ; } $ body = new StringBody ( substr ( $ rawBodyPart , $ bodyStartIndex , $ bodyEndIndex - $ bodyStartIndex ) ) ; $ parsedBodyParts [ ] = new MultipartBodyPart ( $ parsedHeaders , $ body ) ; } return new MultipartBody ( $ parsedBodyParts , $ boundary ) ; }
2051	public function save ( ) { $ groups = $ this -> groups ; $ this -> arrData [ 'groups' ] = $ this -> arrGroups ; parent :: save ( ) ; $ this -> groups = $ groups ; }
5105	public function limit ( $ from , $ count ) : IWithLimit { return $ this -> setPart ( CmdUpdate :: PART_LIMIT , true , ( $ from ? array ( $ from , $ count ) : $ count ) ) ; }
5780	private function setNav ( ) { $ this -> nav = [ 'System' => [ 'subSections' => [ 'Administrators' => [ 'route' => ROUTE_ADMINISTRATORS , 'authorization' => ADMINISTRATORS_VIEW_RESOURCE , 'subSections' => [ 'Insert' => [ 'route' => ROUTE_ADMINISTRATORS_INSERT , 'authorization' => ADMINISTRATORS_INSERT_RESOURCE , ] , ] ] , 'Roles' => [ 'route' => ROUTE_ADMINISTRATORS_ROLES , 'authorization' => ROLES_VIEW_RESOURCE , 'subSections' => [ 'Insert' => [ 'route' => ROUTE_ADMINISTRATORS_ROLES_INSERT , 'authorization' => ROLES_INSERT_RESOURCE , ] , ] , ] , 'Permissions' => [ 'route' => ROUTE_ADMINISTRATORS_PERMISSIONS , 'authorization' => PERMISSIONS_VIEW_RESOURCE , 'subSections' => [ 'Insert' => [ 'route' => ROUTE_ADMINISTRATORS_PERMISSIONS_INSERT , 'authorization' => PERMISSIONS_INSERT_RESOURCE , ] , ] ] , 'Events' => [ 'route' => ROUTE_EVENTS , 'authorization' => EVENTS_VIEW_RESOURCE , 'subSections' => [ 'Types' => [ 'route' => ROUTE_DATABASE_TABLES , 'args' => [ ROUTEARG_DATABASE_TABLE_NAME => 'event_types' ] , 'authorization' => EVENTS_VIEW_RESOURCE , ] , ] ] , 'Database' => [ 'authorization' => DATABASE_TABLES_VIEW_RESOURCE , 'subSections' => $ this -> getDatabaseTablesSection ( ) ] , ] ] , 'Logout' => [ 'route' => ROUTE_LOGOUT , ] , ] ; if ( isset ( $ this -> container [ 'settings' ] [ 'adminNav' ] ) ) { if ( ! is_array ( $ this -> container [ 'settings' ] [ 'adminNav' ] ) ) { throw new \ Exception ( "adminNav config must be array" ) ; } $ this -> nav = array_merge ( $ this -> container [ 'settings' ] [ 'adminNav' ] , $ this -> nav ) ; } }
12242	public function asPrettyXML ( $ filepath = null ) { $ xml = dom_import_simplexml ( new SimpleXMLElement ( $ this -> asXML ( ) ) ) ; $ xsl = new DOMDocument ; $ xsl -> loadXML ( '<?xml version="1.0" encoding="utf-8"?><xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"> <xsl:output method="xml" indent="yes" /> <xsl:template match="text()"> <!-- remove everything that contains only whitespace, with at least one LF ) ; $ xslt = new XSLTProcessor ; $ xslt -> importStylesheet ( $ xsl ) ; $ result = trim ( $ xslt -> transformToXML ( $ xml ) ) ; if ( isset ( $ filepath ) ) { return ( bool ) file_put_contents ( $ filepath , $ result ) ; } return $ result ; }
928	public function delete ( $ path ) { if ( isset ( $ this -> files [ $ path ] ) ) { unset ( $ this -> files [ $ path ] ) ; } $ this -> unlink ( $ path ) ; }
867	private function getPreviousBlock ( Tokens $ tokens , $ index ) { $ close = $ previous = $ tokens -> getPrevMeaningfulToken ( $ index ) ; if ( $ tokens [ $ close ] -> equals ( '}' ) ) { $ previous = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_CURLY_BRACE , $ close ) ; } $ open = $ tokens -> getPrevTokenOfKind ( $ previous , [ [ T_IF ] , [ T_ELSE ] , [ T_ELSEIF ] ] ) ; if ( $ tokens [ $ open ] -> isGivenKind ( T_IF ) ) { $ elseCandidate = $ tokens -> getPrevMeaningfulToken ( $ open ) ; if ( $ tokens [ $ elseCandidate ] -> isGivenKind ( T_ELSE ) ) { $ open = $ elseCandidate ; } } return [ $ open , $ close ] ; }
1551	protected function requiresInverseAdapter ( $ record , EncodingParametersInterface $ parameters ) { return ! empty ( $ parameters -> getFilteringParameters ( ) ) || ! empty ( $ parameters -> getSortParameters ( ) ) || ! empty ( $ parameters -> getPaginationParameters ( ) ) || ! empty ( $ parameters -> getIncludePaths ( ) ) ; }
11293	protected function _getAttributeData ( $ name , $ query = false , $ loadMap = false , $ record = false ) { if ( isset ( $ this -> model_data [ $ name ] ) ) { return $ this -> _getAttributeDataWhenSet ( $ name , $ query , $ loadMap , $ record ) ; } if ( isset ( $ this -> model_attributes [ $ name ] ) && ! isset ( $ this -> model_dynamicOff ) ) { return $ this -> _getAttributeDataWhenUnset ( $ name , $ query , $ loadMap , $ record ) ; } if ( isset ( $ this -> data -> { $ name } ) ) { $ this -> beforeGet ( $ name ) ; $ returnValue = $ this -> data -> { $ name } ; $ this -> afterGet ( $ name , $ returnValue ) ; return $ returnValue ; } $ class = get_class ( $ this ) ; if ( property_exists ( $ class , $ name ) ) { $ this -> beforeGet ( $ name ) ; $ returnValue = $ this -> { $ name } ; $ this -> afterGet ( $ name , $ returnValue ) ; return $ returnValue ; } if ( $ name == 'id' && property_exists ( $ class , 'id_name' ) ) { $ this -> beforeGet ( $ this -> id_name ) ; if ( isset ( $ this -> model_data [ $ this -> id_name ] ) ) { $ returnValue = $ this -> model_data [ $ this -> id_name ] ; } else { $ returnValue = $ this -> { $ this -> id_name } ; } $ this -> afterGet ( $ this -> id_name , $ returnValue ) ; return $ returnValue ; } if ( substr ( $ name , 0 , 6 ) != "model_" && $ this -> issetExtended ( $ name ) ) { $ this -> beforeGet ( $ name ) ; $ returnValue = $ this -> getExtendedAttribute ( $ name ) ; $ this -> afterGet ( $ name , $ returnValue ) ; return $ returnValue ; } $ this -> beforeGet ( $ name ) ; if ( isset ( $ this -> { $ name } ) ) { $ returnValue = $ this -> { $ name } ; } else { $ returnValue = null ; } $ this -> afterGet ( $ name , $ returnValue ) ; return $ returnValue ; }
10934	protected function is_php ( $ version ) { static $ _is_php ; $ version = ( string ) $ version ; if ( ! isset ( $ _is_php [ $ version ] ) ) { $ _is_php [ $ version ] = version_compare ( PHP_VERSION , $ version , '>=' ) ; } return $ _is_php [ $ version ] ; }
899	public function getImportUseIndexes ( $ perNamespace = false ) { $ tokens = $ this -> tokens ; $ tokens -> rewind ( ) ; $ uses = [ ] ; $ namespaceIndex = 0 ; for ( $ index = 0 , $ limit = $ tokens -> count ( ) ; $ index < $ limit ; ++ $ index ) { $ token = $ tokens [ $ index ] ; if ( $ token -> isGivenKind ( T_NAMESPACE ) ) { $ nextTokenIndex = $ tokens -> getNextTokenOfKind ( $ index , [ ';' , '{' ] ) ; $ nextToken = $ tokens [ $ nextTokenIndex ] ; if ( $ nextToken -> equals ( '{' ) ) { $ index = $ nextTokenIndex ; } if ( $ perNamespace ) { ++ $ namespaceIndex ; } continue ; } if ( $ token -> isGivenKind ( T_USE ) ) { $ uses [ $ namespaceIndex ] [ ] = $ index ; } } if ( ! $ perNamespace && isset ( $ uses [ $ namespaceIndex ] ) ) { return $ uses [ $ namespaceIndex ] ; } return $ uses ; }
4008	public function collectMetaModelTableNames ( CollectMetaModelTableNamesEvent $ event ) { if ( $ this -> tableNamesCollected ) { $ event -> addMetaModelNames ( $ this -> tableNames ) ; return ; } $ tables = $ this -> database -> createQueryBuilder ( ) -> select ( '*' ) -> from ( 'tl_metamodel' ) -> orderBy ( 'sorting' ) -> execute ( ) -> fetchAll ( \ PDO :: FETCH_ASSOC ) ; foreach ( $ tables as $ table ) { $ this -> tableNames [ $ table [ 'id' ] ] = $ table [ 'tableName' ] ; } $ event -> addMetaModelNames ( $ this -> tableNames ) ; $ this -> tableNamesCollected = true ; }
3696	protected function extractIdFrom ( EnvironmentInterface $ environment , $ parameterName = 'pid' ) { $ parameter = $ environment -> getInputProvider ( ) -> getParameter ( $ parameterName ) ; return ModelId :: fromSerialized ( $ parameter ) -> getId ( ) ; }
3381	public function hasRole ( $ role ) { if ( is_string ( $ role ) ) { return $ this -> roles -> contains ( 'name' , $ role ) ; } return ! ! $ role -> intersect ( $ this -> roles ) -> count ( ) ; }
5185	private function generalAttachment ( Article $ article , array $ attachmentConst , array $ attachmentype , array $ attributes , array $ dataArticle ) : Article { $ numOfAttachments = count ( $ attachmentConst ) ; for ( $ i = 0 ; $ i < $ numOfAttachments ; $ i ++ ) { $ attachments = $ this -> attachment ( $ attachmentype [ $ i ] , $ attributes [ $ i ] , $ dataArticle ) ; for ( $ j = 0 ; $ j < $ attachments [ 'numberOfItems' ] ; $ j ++ ) { $ attachment = $ attachments [ 'attachments' ] [ $ j ] ; $ article -> attach ( $ attachmentConst [ $ i ] , $ attachment ) ; } } return $ article ; }
10547	public function setResolver ( Resolver $ resolver ) { $ this -> resolver = $ resolver ; $ this -> setVariable ( 'resolver' , $ resolver ) ; return $ this ; }
6626	public function processRequest ( Request $ request , Controller $ controller , array $ requestChain = null ) { $ reflectionController = $ this -> getControllerReflector ( ) -> reflectController ( $ controller ) ; if ( is_null ( $ requestChain ) ) { $ requestChain = $ request -> getRequestChain ( ) ; } $ nextLink = array_shift ( $ requestChain ) ; if ( $ nextLink ) { if ( $ reflectionController -> hasChildController ( $ nextLink ) ) { return $ this -> processRequest ( $ request , $ reflectionController -> getChildController ( $ nextLink ) , $ requestChain ) ; } if ( $ reflectionController -> hasEndpoint ( $ request -> getMethod ( ) , $ nextLink ) ) { $ data = $ reflectionController -> getEndpointResult ( $ request -> getMethod ( ) , $ nextLink , $ request ) ; $ this -> setStatus ( $ reflectionController -> getStatus ( ) ) ; return $ data ; } $ message = "Could not find controller or endpoint matching '$nextLink'" ; throw new Exception ( $ message , 404 ) ; } if ( $ reflectionController -> hasEndpoint ( $ request -> getMethod ( ) , 'index' ) ) { $ data = $ reflectionController -> getEndpointResult ( $ request -> getMethod ( ) , 'index' , $ request ) ; $ this -> setStatus ( $ reflectionController -> getStatus ( ) ) ; return $ data ; } return $ reflectionController -> getDocumentation ( ) ; }
11163	protected function getResponseFormat ( array $ config ) { if ( isset ( $ config [ 'responseFormat' ] ) ) { if ( ! is_string ( $ config [ 'responseFormat' ] ) ) { throw new \ DomainException ( 'responseFormat must reference a string' , self :: ERR_INVALID_RESPONSEFORMAT ) ; } return $ config [ 'responseFormat' ] ; } return '[ %link% ] "%title%" by %author%' . '; Length %duration%' . '; Published %published%' . '; Views %views%' . '; Likes %likes%' ; }
9273	public function filter ( $ text ) { $ text = str_replace ( "\r" , '' , $ text ) ; $ text = str_replace ( ' ' , ' &nbsp;' , $ text ) ; $ this -> _parseBbcodeNobbcode ( $ text ) ; $ this -> _parseBbcodeCode ( $ text ) ; $ this -> _parseBbcodeQuote ( $ text ) ; $ this -> _parseBbcodeList ( $ text ) ; $ this -> _parseSimpleBbcode ( 'i' , '<em>$1</em>' , $ text ) ; $ this -> _parseSimpleBbcode ( 'u' , '<u>$1</u>' , $ text ) ; $ this -> _parseSimpleBbcode ( 'b' , '<strong>$1</strong>' , $ text ) ; $ this -> _parseSimpleBbcode ( 'del' , '<del>$1</del>' , $ text ) ; $ this -> _parseSimpleBbcode ( 'strike' , '<del>$1</del>' , $ text ) ; $ this -> _parseParamBbcode ( 'color' , '([a-zA-Z]*|\#?[0-9a-fA-F]{6})' , '<span style="color: $1">$2</span>' , $ text ) ; $ this -> _parseParamBbcode ( 'bgcolor' , '([a-zA-Z]*|\#?[0-9a-fA-F]{6})' , '<span style="background-color: $1">$2</span>' , $ text ) ; $ this -> _parseParamBbcode ( 'align' , '(center|left|right|justify){1}' , '<div style="text-alignement: $1">$2</div>' , $ text ) ; $ this -> _parseParamBbcode ( 'size' , '([0-9].*)' , '<span style="font-size: $1">$2</span>' , $ text ) ; $ this -> _parseBbcodeEmail ( $ text ) ; $ this -> _parseBbcodeUrl ( $ text ) ; $ this -> _parseBbcodeImg ( $ text ) ; $ this -> _parseBbcodeSpoiler ( $ text ) ; $ this -> _parseScriptTags ( $ text ) ; $ this -> _parseSmiley ( $ text ) ; $ this -> _parseBbcodeBr ( $ text ) ; return $ text ; }
12768	public function get ( string $ key = '' ) { if ( empty ( $ key ) ) { return $ this -> store ; } else { return $ this -> store [ $ key ] ?? null ; } }
12657	public function deleteTextContainer ( $ name ) { foreach ( $ this -> languages as $ lang ) { $ this -> getPageTexts ( $ lang ) ; unset ( $ this -> contents [ $ lang ] [ $ name ] ) ; $ this -> writeTextsToFile ( $ lang ) ; } }
245	public function getColumn ( $ name ) { return isset ( $ this -> columns [ $ name ] ) ? $ this -> columns [ $ name ] : null ; }
7734	private function isHydraOperation ( \ ReflectionMethod $ method ) { $ annotation = $ this -> annotationReader -> getMethodAnnotation ( $ method , 'ML\HydraBundle\Mapping\Operation' ) ; return null !== $ annotation ; }
1476	public function createQueryValidator ( array $ data , array $ rules , array $ messages = [ ] , array $ customAttributes = [ ] ) { return $ this -> createValidator ( $ data , $ rules , $ messages , $ customAttributes , function ( $ key , $ detail , $ failed ) { return $ this -> invalidQueryParameter ( $ key , $ detail , $ failed ) ; } ) ; }
10908	public function instance ( object $ object ) : Binding { if ( ! $ object instanceof $ this -> definition -> typeName ) { throw new \ InvalidArgumentException ( \ sprintf ( '%s is not an instance of %s' , \ get_class ( $ object ) , $ this -> definition -> typeName ) ) ; } $ this -> definition -> instantiator = new Instance ( $ object ) ; return $ this ; }
7132	protected function updateExchangeRate ( SupplierOrderInterface $ order ) { if ( null !== $ order -> getExchangeRate ( ) ) { return false ; } if ( ! SupplierOrderStates :: isStockableState ( $ order -> getState ( ) ) ) { return false ; } $ date = new \ DateTime ( ) ; $ rate = $ this -> currencyConverter -> getRate ( $ this -> currencyConverter -> getDefaultCurrency ( ) , $ order -> getCurrency ( ) -> getCode ( ) , $ date ) ; $ order -> setExchangeRate ( $ rate ) -> setExchangeDate ( $ date ) ; return true ; }
3199	protected function getRange ( $ tags ) { $ range = $ this -> timeLine -> find ( $ tags , TimePoint :: TARGET_SERVER ) ; TimePoint :: sort ( $ range ) ; return $ range ; }
777	private function defaultTimeTypeMap ( ) { $ map = [ Schema :: TYPE_DATETIME => 'datetime' , Schema :: TYPE_TIMESTAMP => 'timestamp' , Schema :: TYPE_TIME => 'time' , ] ; if ( $ this -> supportsFractionalSeconds ( ) ) { $ map = [ Schema :: TYPE_DATETIME => 'datetime(0)' , Schema :: TYPE_TIMESTAMP => 'timestamp(0)' , Schema :: TYPE_TIME => 'time(0)' , ] ; } return $ map ; }
8051	public function getAllEvents ( ) : array { $ calendarEvents = null ; $ cache = $ this -> cache ; if ( $ cache :: has ( self :: ALL_EVENTS_KEY ) ) { return $ cache :: get ( self :: ALL_EVENTS_KEY ) ; } $ allEvents = $ this -> calendarEvent -> with ( [ 'calendarEventRepeatDates' ] ) -> get ( ) ; $ calendarEvents = $ allEvents -> keyBy ( 'id' ) -> toArray ( ) ; $ cache :: put ( self :: ALL_EVENTS_KEY , $ calendarEvents , $ this -> cacheTimeToLive ) ; return $ calendarEvents ; }
2872	public function init ( Mage_Core_Model_Abstract $ model ) { $ this -> class = get_class ( $ model ) ; $ this -> resource = $ model -> getResourceName ( ) ; $ this -> count = 0 ; }
3469	public function options ( string $ route , callable $ controller ) : void { $ this -> register ( $ controller , Route :: options ( $ route ) ) ; }
155	public function scalar ( $ db = null ) { if ( $ this -> emulateExecution ) { return null ; } return $ this -> createCommand ( $ db ) -> queryScalar ( ) ; }
4264	protected function doPublish ( $ eventName , $ subscribers , Event $ event ) { foreach ( $ subscribers as $ callable ) { if ( $ event -> isPropagationStopped ( ) ) { break ; } \ call_user_func ( $ callable , $ event , $ eventName , $ this ) ; } }
6663	public function post ( $ url , $ params ) { if ( is_array ( $ params ) ) { $ params = $ this -> filterParams ( $ params ) ; } $ this -> lastRequestParams = $ params ; $ this -> lastRequestUrl = $ this -> buildUrl ( $ url ) ; return $ this -> curlAgent -> setOption ( CURLOPT_POSTFIELDS , $ params ) -> post ( $ this -> lastRequestUrl , $ this -> rawResponse ) ; }
1489	public function unless ( bool $ test , $ decodings ) : self { return $ this -> when ( true !== $ test , $ decodings ) ; }
1710	public function onReplaceInsertTags ( string $ tag , bool $ useCache , $ cacheValue , array $ flags ) { static $ supportedTags = [ 'faq' , 'faq_open' , 'faq_url' , 'faq_title' , ] ; $ elements = explode ( '::' , $ tag ) ; $ key = strtolower ( $ elements [ 0 ] ) ; if ( ! \ in_array ( $ key , $ supportedTags , true ) ) { return false ; } $ this -> framework -> initialize ( ) ; $ adapter = $ this -> framework -> getAdapter ( FaqModel :: class ) ; $ faq = $ adapter -> findByIdOrAlias ( $ elements [ 1 ] ) ; if ( null === $ faq || false === ( $ url = $ this -> generateUrl ( $ faq , \ in_array ( 'absolute' , $ flags , true ) ) ) ) { return '' ; } return $ this -> generateReplacement ( $ faq , $ key , $ url ) ; }
11846	final public function reset ( $ column ) { if ( $ this -> isDirty ( $ column ) ) { $ this -> _data [ $ column ] = $ this -> _cleanData [ $ column ] ; unset ( $ this -> _modifiedFields [ $ column ] ) ; } }
6911	public function removeExtraCopy ( Recipient $ copy ) { if ( $ this -> extraCopies -> contains ( $ copy ) ) { $ this -> extraCopies -> removeElement ( $ copy ) ; } return $ this ; }
8840	public function setExitCode ( $ exitCode ) { \ Assert \ that ( $ exitCode ) -> integer ( ) -> min ( 0 ) ; $ this -> exitCode = $ exitCode ; return $ this ; }
12163	public function getFormSegment ( $ primaryModel = null , $ settings = [ ] ) { if ( empty ( $ primaryModel ) ) { return false ; } return $ primaryModel -> form ( $ settings ) ; }
2244	protected function getSpellcheckerString ( ) { System :: loadLanguageFile ( 'languages' ) ; $ return = array ( ) ; $ langs = scan ( __DIR__ . '/../../languages' ) ; array_unshift ( $ langs , $ GLOBALS [ 'TL_LANGUAGE' ] ) ; foreach ( $ langs as $ lang ) { $ lang = substr ( $ lang , 0 , 2 ) ; if ( isset ( $ GLOBALS [ 'TL_LANG' ] [ 'LNG' ] [ $ lang ] ) ) { $ return [ $ lang ] = $ GLOBALS [ 'TL_LANG' ] [ 'LNG' ] [ $ lang ] . '=' . $ lang ; } } return '+' . implode ( ',' , array_unique ( $ return ) ) ; }
4475	public function fail ( string $ group , string $ message ) { if ( $ this -> completed || $ this -> failed ) { throw new JobAlreadyFinishedException ( ) ; } $ jsonData = json_encode ( $ this -> data , JSON_UNESCAPED_SLASHES ) ? : '{}' ; $ this -> getEventsManager ( ) -> fire ( new JobEvent \ OnFailure ( $ this , $ this , $ group , $ message ) ) ; $ this -> failed = true ; return $ this -> client -> fail ( $ this -> jid , $ this -> worker , $ group , $ message , $ jsonData ) ; }
11721	public function getCarouselItemsBlog ( $ entity ) { $ em = $ this -> container -> get ( 'doctrine' ) -> getManager ( ) ; if ( $ entity instanceof Category ) { $ qb = $ em -> getRepository ( 'BlogBundle:Post' ) -> createQueryBuilder ( 'p' ) -> join ( 'p.categories' , 'c' ) -> join ( 'p.translations' , 't' ) -> where ( 'c.id = :category' ) -> andWhere ( 'p.highlighted = true' ) -> setParameter ( 'category' , $ entity -> getId ( ) ) -> setMaxResults ( 3 ) -> orderBy ( 'p.published' , 'DESC' ) ; } elseif ( $ entity instanceof Tag ) { $ qb = $ em -> getRepository ( 'BlogBundle:Post' ) -> createQueryBuilder ( 'p' ) -> join ( 'p.tags' , 'tag' ) -> join ( 'p.translations' , 't' ) -> where ( 't.id = :tag' ) -> andWhere ( 'p.highlighted = true' ) -> setParameter ( 'tag' , $ entity -> getId ( ) ) -> setMaxResults ( 3 ) -> orderBy ( 'p.published' , 'DESC' ) ; } $ entities = $ qb -> getQuery ( ) -> getResult ( ) ; return $ entities ; }
213	public function registerClientScript ( ) { $ js = '' ; $ view = $ this -> getView ( ) ; $ this -> initClientOptions ( ) ; if ( ! empty ( $ this -> mask ) ) { $ this -> clientOptions [ 'mask' ] = $ this -> mask ; } $ this -> hashPluginOptions ( $ view ) ; if ( is_array ( $ this -> definitions ) && ! empty ( $ this -> definitions ) ) { $ js .= ucfirst ( self :: PLUGIN_NAME ) . '.extendDefinitions(' . Json :: htmlEncode ( $ this -> definitions ) . ');' ; } if ( is_array ( $ this -> aliases ) && ! empty ( $ this -> aliases ) ) { $ js .= ucfirst ( self :: PLUGIN_NAME ) . '.extendAliases(' . Json :: htmlEncode ( $ this -> aliases ) . ');' ; } $ id = $ this -> options [ 'id' ] ; $ js .= 'jQuery("#' . $ id . '").' . self :: PLUGIN_NAME . '(' . $ this -> _hashVar . ');' ; MaskedInputAsset :: register ( $ view ) ; $ view -> registerJs ( $ js ) ; }
3328	private function getPriceConfigurations ( ) { static $ priceConfigurations ; if ( null === $ priceConfigurations ) { $ priceConfigurations = $ this -> itemsSalesPricesApi -> findAll ( ) ; $ shopIdentities = $ this -> identityService -> findBy ( [ 'adapterName' => PlentymarketsAdapter :: NAME , 'objectType' => Shop :: TYPE , ] ) ; $ shopIdentities = array_filter ( $ shopIdentities , function ( Identity $ identity ) { $ isMappedIdentity = $ this -> identityService -> isMappedIdentity ( $ identity -> getObjectIdentifier ( ) , $ identity -> getObjectType ( ) , $ identity -> getAdapterName ( ) ) ; if ( ! $ isMappedIdentity ) { return false ; } return true ; } ) ; if ( empty ( $ shopIdentities ) ) { $ priceConfigurations = [ ] ; return $ priceConfigurations ; } $ priceConfigurations = array_filter ( $ priceConfigurations , function ( $ priceConfiguration ) use ( $ shopIdentities ) { foreach ( $ shopIdentities as $ identity ) { foreach ( ( array ) $ priceConfiguration [ 'clients' ] as $ client ) { if ( $ client [ 'plentyId' ] === - 1 || $ identity -> getAdapterIdentifier ( ) === ( string ) $ client [ 'plentyId' ] ) { return true ; } } } return false ; } ) ; if ( empty ( $ priceConfigurations ) ) { $ this -> logger -> notice ( 'no valid price configuration found' ) ; } } return $ priceConfigurations ; }
10940	public function getResponse ( $ params = [ ] , $ lifetime = - 1 , Response $ response = null ) { if ( ! $ response ) { $ response = new Response ( ) ; } if ( ! $ this -> enable ) { return $ response ; } return $ this -> configurator -> configure ( $ response , $ this -> getMax ( $ params ) , $ lifetime ) ; }
2042	public static function validateSymlink ( string $ target , string $ link , string $ rootDir ) : void { if ( '' === $ target ) { throw new \ InvalidArgumentException ( 'The symlink target must not be empty.' ) ; } if ( '' === $ link ) { throw new \ InvalidArgumentException ( 'The symlink path must not be empty.' ) ; } if ( false !== strpos ( $ link , '../' ) ) { throw new \ InvalidArgumentException ( 'The symlink path must not be relative.' ) ; } $ fs = new Filesystem ( ) ; if ( $ fs -> exists ( $ rootDir . '/' . $ link ) && ! is_link ( $ rootDir . '/' . $ link ) ) { throw new \ LogicException ( sprintf ( 'The path "%s" exists and is not a symlink.' , $ link ) ) ; } }
3718	protected function getMetaModelFromModel ( ModelInterface $ model ) { if ( ! ( ( $ model -> getProviderName ( ) == 'tl_metamodel_dca_sortgroup' ) && $ model -> getProperty ( 'pid' ) ) ) { throw new DcGeneralInvalidArgumentException ( sprintf ( 'Model must originate from tl_metamodel_dca_sortgroup and be saved, this one originates from %s ' . 'and has pid %s' , $ model -> getProviderName ( ) , $ model -> getProperty ( 'pid' ) ) ) ; } $ metaModelId = $ this -> connection -> createQueryBuilder ( ) -> select ( 'pid' ) -> from ( 'tl_metamodel_dca' ) -> where ( 'id=:id' ) -> setParameter ( 'id' , $ model -> getProperty ( 'pid' ) ) -> execute ( ) -> fetchColumn ( ) ; $ tableName = $ this -> factory -> translateIdToMetaModelName ( $ metaModelId ) ; return $ this -> factory -> getMetaModel ( $ tableName ) ; }
6664	public function instantiate ( $ profile , $ provider ) { $ this -> provider = $ provider ; switch ( $ provider ) { case 'facebook' : $ this -> info = $ this -> parseFb ( $ profile ) ; break ; case 'twitter' : $ this -> info = $ this -> parseTwt ( $ profile ) ; break ; } return $ this ; }
12883	public function getUnmappedLocalKeys ( ) { $ u = array_diff ( array_keys ( $ this -> localModel -> getMetaData ( ) -> columns ) , array_keys ( $ this -> _map ) ) ; unset ( $ u [ $ this -> localPrimaryKeyName ] ) ; return $ u ; }
8364	public static function setCurrentLanguage ( $ language ) { self :: $ currentLanguage = $ language ; Session :: set ( '_stray_language' , self :: $ currentLanguage ) ; setlocale ( LC_ALL , $ language ) ; }
8249	protected function needsPasswordRehash ( array $ userData ) { if ( $ this -> config [ "login" ] [ "passwordRehash" ] !== true ) { return false ; } if ( isset ( $ userData [ 'encoder' ] ) && $ userData [ 'encoder' ] !== $ this -> config [ "encoder" ] ) { return true ; } $ encoder = $ this -> getPasswordEncoder ( $ userData ) ; return $ encoder -> needsRehash ( $ userData [ 'pwhash' ] ) ; }
3121	public function filter ( $ tag = null , $ target = TimePoint :: TARGET_ALL , $ type = TimePoint :: TYPE_ALL ) { $ tags = null ; if ( isset ( $ tag ) ) { $ tags = is_array ( $ tag ) ? $ tag : [ $ tag ] ; } $ subset = new static ( ) ; foreach ( $ this -> points as $ idx => $ point ) { if ( $ point -> match ( $ tags , $ target , $ type ) ) { $ subset -> add ( $ point ) ; } } return $ subset ; }
9368	protected function globals ( Configuration $ config ) { $ cookies = $ config -> get ( 'app.http.cookies' , array ( ) ) ; $ files = $ config -> get ( 'app.http.files' , array ( ) ) ; $ get = $ config -> get ( 'app.http.get' , array ( ) ) ; $ post = $ config -> get ( 'app.http.post' , array ( ) ) ; $ server = $ config -> get ( 'app.http.server' , $ this -> server ( ) ) ; return array ( $ server , $ cookies , $ get , $ files , $ post ) ; }
414	public function setSecurePort ( $ value ) { if ( $ value != $ this -> _securePort ) { $ this -> _securePort = ( int ) $ value ; $ this -> _hostInfo = null ; } }
10533	public function last ( ) { if ( is_array ( $ this -> items ) && count ( $ this -> items ) > 0 ) { return end ( $ this -> items ) ; } return null ; }
2810	public function initLogging ( ) { $ helper = Mage :: helper ( 'sheep_debug' ) ; $ this -> logging = Mage :: getModel ( 'sheep_debug/logging' ) ; $ this -> logging -> addFile ( $ helper -> getLogFilename ( $ this -> getStoreId ( ) ) ) ; $ this -> logging -> addFile ( $ helper -> getExceptionLogFilename ( $ this -> getStoreId ( ) ) ) ; Mage :: dispatchEvent ( 'sheep_debug_init_logging' , array ( 'logging' => $ this -> logging ) ) ; $ this -> logging -> startRequest ( ) ; }
1580	public function withId ( ? string $ id ) : self { $ copy = clone $ this ; $ copy -> id = $ id ? : null ; $ copy -> normalize ( ) ; return $ copy ; }
7330	private function configureSubjectRelativeMapping ( LoadClassMetadataEventArgs $ eventArgs ) { $ metadata = $ eventArgs -> getClassMetadata ( ) ; $ class = $ metadata -> getName ( ) ; if ( ! is_subclass_of ( $ class , SubjectRelativeInterface :: class ) ) { return ; } if ( in_array ( $ class , $ this -> relativeClassCache ) ) { return ; } $ this -> getSubjectIdentityMapper ( $ eventArgs -> getEntityManager ( ) ) -> processClassMetadata ( $ metadata , 'subjectIdentity' , 'subject_' ) ; $ this -> relativeClassCache [ ] = $ class ; }
12831	private function onTokenFound ( $ token ) { if ( is_array ( $ token ) ) $ token = array_pop ( $ token ) ; $ token = trim ( $ token ) ; $ tokenParts = explode ( ' ' , $ token ) ; $ tag = array_shift ( $ tokenParts ) ; $ params = implode ( ' ' , $ tokenParts ) ; if ( $ this -> _blocks -> has ( $ tag ) ) { if ( $ this -> _blocks -> getDeepValue ( $ tag . '/runtime' ) ) { $ res = '<?php $this->_compiler->invokeBlock(\'' . $ tag . '\', ' . $ this -> compileExpression ( $ params ) . '); ?>' ; } else { $ res = $ this -> onBlockTagOpen ( $ tag , $ params ) ; } } elseif ( substr ( $ tag , 0 , strlen ( $ this -> _config [ 'blockClose' ] ) ) == $ this -> _config [ 'blockClose' ] ) { $ tag = substr ( $ tag , strlen ( $ this -> _config [ 'blockClose' ] ) ) ; $ res = $ this -> onBlockTagClose ( $ tag , $ params ) ; } else { $ res = $ this -> onVarEchoToken ( $ token , $ params ) ; } return $ res ; }
3986	public function getCombinations ( ) { $ user = $ this -> getUser ( ) ; switch ( true ) { case ( $ user instanceof BackendUser ) : $ mode = 'be' ; $ groups = $ user -> groups ; if ( $ user -> admin ) { $ groups [ ] = - 1 ; } break ; case ( $ user instanceof FrontendUser ) : $ mode = 'fe' ; $ groups = $ user -> groups ; if ( ! $ this -> getUser ( ) -> id ) { $ groups = [ - 1 ] ; } break ; default : $ mode = 'fe' ; $ groups = [ - 1 ] ; } $ groups = array_filter ( $ groups ) ; if ( $ this -> cache -> contains ( $ cacheKey = 'combinations_' . $ mode . '_' . implode ( ',' , $ groups ) ) ) { return $ this -> cache -> fetch ( $ cacheKey ) ; } $ combinations = $ this -> builder -> getCombinationsForUser ( $ groups , $ mode ) ; $ this -> cache -> save ( $ cacheKey , $ combinations ) ; return $ combinations ; }
1233	private function ensurePropertyType ( $ value ) { $ actualType = gettype ( $ value ) ; if ( 'object' === $ actualType ) { $ actualType = get_class ( $ value ) ; } $ valid = explode ( '|' , $ this -> expectedType ) ; $ isValid = false ; foreach ( $ valid as $ check ) { if ( $ check !== 'any' && \ DTS \ eBaySDK \ checkPropertyType ( $ check ) ) { if ( $ check === $ actualType ) { return ; } $ isValid = false ; } else { $ isValid = true ; } } if ( ! $ isValid ) { throw new Exceptions \ InvalidPropertyTypeException ( $ this -> property , $ this -> expectedType , $ actualType ) ; } }
8445	public function getUser ( IncomingMessage $ matchingMessage ) { $ sender_id = $ matchingMessage -> getRecipient ( ) ; $ user = Collection :: make ( $ this -> payload -> get ( 'users' ) ) -> first ( function ( $ user ) use ( $ sender_id ) { return $ user [ 'id' ] === $ sender_id ; } ) ; return new User ( $ user [ 'id' ] , null , null , $ user [ 'name' ] , $ user ) ; }
10005	public function setRibbonXMLData ( $ target , $ xmlData ) { if ( $ target !== null && $ xmlData !== null ) { $ this -> ribbonXMLData = [ 'target' => $ target , 'data' => $ xmlData ] ; } else { $ this -> ribbonXMLData = null ; } }
5045	public function paginator ( $ paginatorName , $ defaultParams = [ ] , $ as = 'paginator' ) { if ( is_string ( $ defaultParams ) ) { $ as = $ defaultParams ; $ defaultParams = [ ] ; } $ this -> stack [ 'paginator' ] = [ 'as' => $ as , $ paginatorName , $ defaultParams ] ; return $ this ; }
10412	public function loadUrlsFromDocument ( $ type , SeoAwareInterface $ document ) { if ( $ this -> invalidateSeoUrls ) { $ urls = $ document -> getUrls ( ) ; if ( is_array ( $ urls ) || $ urls instanceof \ Traversable ) { foreach ( $ urls as $ url ) { $ this -> addUrl ( $ url -> getUrl ( ) ) ; } } } foreach ( $ this -> urlCollectors as $ collector ) { $ this -> addUrls ( $ collector -> getDocumentUrls ( $ type , $ document , $ this -> router ) ) ; $ this -> addMultipleDocumentParameters ( $ collector -> getDocumentParameters ( $ type , $ document ) ) ; } }
305	private function setRelationDependencies ( $ name , $ relation , $ viaRelationName = null ) { if ( empty ( $ relation -> via ) && $ relation -> link ) { foreach ( $ relation -> link as $ attribute ) { $ this -> _relationsDependencies [ $ attribute ] [ $ name ] = $ name ; if ( $ viaRelationName !== null ) { $ this -> _relationsDependencies [ $ attribute ] [ ] = $ viaRelationName ; } } } elseif ( $ relation -> via instanceof ActiveQueryInterface ) { $ this -> setRelationDependencies ( $ name , $ relation -> via ) ; } elseif ( is_array ( $ relation -> via ) ) { list ( $ viaRelationName , $ viaQuery ) = $ relation -> via ; $ this -> setRelationDependencies ( $ name , $ viaQuery , $ viaRelationName ) ; } }
4874	public function setFormId ( $ formId ) { $ this -> formId = $ formId . '-' ; foreach ( $ this as $ button ) { $ button -> setAttribute ( 'id' , $ this -> formId . $ button -> getAttribute ( 'id' ) ) ; } return $ this ; }
285	public function setDefault ( $ name , $ value ) { $ name = strtolower ( $ name ) ; if ( empty ( $ this -> _headers [ $ name ] ) ) { $ this -> _headers [ $ name ] [ ] = $ value ; } return $ this ; }
12738	public function addClass ( $ name ) { $ classParts = explode ( ' ' , $ this -> tags [ 'class' ] ) ; foreach ( $ classParts as $ part ) { if ( $ name == $ part ) return ; } $ this -> tags [ 'class' ] .= ' ' . $ name ; $ this -> tags [ 'class' ] = trim ( $ this -> tags [ 'class' ] ) ; }
2631	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ read = $ this -> filesystem -> getDirectoryRead ( DirectoryList :: VAR_DIR ) ; $ snippetPath = $ read -> getRelativePath ( 'vcl_snippets_custom' ) ; $ customSnippets = $ read -> read ( $ snippetPath ) ; if ( ! $ customSnippets ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'No snippets found.' ] ) ; } $ snippets = [ ] ; foreach ( $ customSnippets as $ snippet ) { $ snippets [ ] = explode ( '/' , $ snippet ) [ 1 ] ; } return $ result -> setData ( [ 'status' => true , 'snippets' => $ snippets ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
84	public static function expandPath ( $ path ) { if ( preg_match ( '#^~[\\/]#' , $ path ) ) { return self :: getUserDirectory ( ) . substr ( $ path , 1 ) ; } return preg_replace_callback ( '#^(\$|(?P<percent>%))(?P<var>\w++)(?(percent)%)(?P<path>.*)#' , function ( $ matches ) { if ( Platform :: isWindows ( ) && $ matches [ 'var' ] == 'HOME' ) { return ( getenv ( 'HOME' ) ? : getenv ( 'USERPROFILE' ) ) . $ matches [ 'path' ] ; } return getenv ( $ matches [ 'var' ] ) . $ matches [ 'path' ] ; } , $ path ) ; }
12505	public static function commitTransaction ( $ connection ) { $ connection -> query = 'COMMIT' ; $ connection -> method = 'POST' ; $ connection -> action = '/_query' ; return self :: sendQuery ( $ connection ) ; }
362	protected function getClientOptions ( ) { $ filterUrl = isset ( $ this -> filterUrl ) ? $ this -> filterUrl : Yii :: $ app -> request -> url ; $ id = $ this -> filterRowOptions [ 'id' ] ; $ filterSelector = "#$id input, #$id select" ; if ( isset ( $ this -> filterSelector ) ) { $ filterSelector .= ', ' . $ this -> filterSelector ; } return [ 'filterUrl' => Url :: to ( $ filterUrl ) , 'filterSelector' => $ filterSelector , ] ; }
4186	public function search ( ) { $ url = self :: PACKAGIST_URL . 'search.json?q=' . $ this -> getPackageName ( ) ; $ response = $ this -> client -> get ( $ url ) -> getBody ( ) -> getContents ( ) ; $ this -> rawPackages = collect ( json_decode ( $ response , true ) ) ; return collect ( $ this -> rawPackages -> get ( 'results' ) ) ; }
8946	public function changePreference ( $ key , $ preference ) { $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = 'user/preferences/' . $ key ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'PUT' , $ parameters , $ preference ) ; return $ response -> body ; }
12449	static function run_check_gnu_files ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { $ opts = self :: getOpts ( @ $ args [ 0 ] , @ $ args [ 1 ] , $ cliopts ) ; if ( ! SharedLock :: acquire ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ) throw new PakeException ( "Source code locked by another process" ) ; $ destdir = self :: getBuildDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ; if ( $ opts [ 'files' ] [ 'gnu_dir' ] ) { $ destdir .= '/' . $ opts [ 'files' ] [ 'gnu_dir' ] ; } $ files = pakeFinder :: type ( 'file' ) -> name ( array ( 'README' , 'LICENSE' ) ) -> maxdepth ( 0 ) -> in ( $ destdir ) ; if ( count ( $ files ) != 2 ) { SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; throw new pakeException ( "README and/or LICENSE files missing. Please fix" ) ; } SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; }
8581	public function setPrepInstruction ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'PrepInstruction' ] [ 'FieldValue' ] = $ value ; return $ this ; }
10705	public function getEntityManager ( ) { if ( null === $ this -> em ) { $ mainService = $ this -> getServiceLocator ( ) -> get ( 'neobazaar.service.main' ) ; $ this -> em = $ mainService -> getEntityManager ( ) ; } return $ this -> em ; }
5049	public function __isset ( $ property ) { trigger_error ( sprintf ( 'Using isset() with entity properties is deprecated. Use %s::notEmpty("%s") instead.' , get_class ( $ this ) , $ property ) , E_USER_DEPRECATED ) ; return $ this -> notEmpty ( $ property ) ; }
530	public function actionSortChangelog ( array $ what ) { if ( \ count ( $ what ) > 1 ) { $ this -> stdout ( "Currently only one simultaneous release is supported.\n" ) ; return 1 ; } $ this -> validateWhat ( $ what , [ 'framework' , 'ext' ] , false ) ; $ version = $ this -> version ? : array_values ( $ this -> getNextVersions ( $ this -> getCurrentVersions ( $ what ) , self :: PATCH ) ) [ 0 ] ; $ this -> stdout ( 'sorting CHANGELOG of ' ) ; $ this -> stdout ( reset ( $ what ) , Console :: BOLD ) ; $ this -> stdout ( ' for version ' ) ; $ this -> stdout ( $ version , Console :: BOLD ) ; $ this -> stdout ( '...' ) ; $ this -> resortChangelogs ( $ what , $ version ) ; $ this -> stdout ( "done.\n" , Console :: BOLD , Console :: FG_GREEN ) ; }
7013	private function format_m ( & $ str ) { if ( strstr ( $ str , '%m' ) ) $ str = str_replace ( '%m' , sprintf ( '%02d' , $ this -> month ) , $ str ) ; }
4870	private function entityToString ( EntityInterface $ entity ) { if ( method_exists ( $ entity , '__toString' ) ) { return $ entity -> __toString ( ) ; } $ str = get_class ( $ entity ) ; if ( $ entity instanceof \ Core \ Entity \ IdentifiableEntityInterface ) { $ str .= '( ' . $ entity -> getId ( ) . ' )' ; } return $ str ; }
6471	public function parseContentTypeHeader ( HttpHeaders $ headers ) : ? ContentTypeHeaderValue { if ( ! $ headers -> containsKey ( 'Content-Type' ) ) { return null ; } $ contentTypeHeaderParameters = $ this -> parseParameters ( $ headers , 'Content-Type' ) ; $ contentType = $ contentTypeHeaderParameters -> getKeys ( ) [ 0 ] ; return new ContentTypeHeaderValue ( $ contentType , $ contentTypeHeaderParameters ) ; }
897	private function fixTokensCompare ( Tokens $ tokens , $ startLeft , $ endLeft , $ compareOperatorIndex , $ startRight , $ endRight ) { $ type = $ tokens [ $ compareOperatorIndex ] -> getId ( ) ; $ content = $ tokens [ $ compareOperatorIndex ] -> getContent ( ) ; if ( \ array_key_exists ( $ type , $ this -> candidatesMap ) ) { $ tokens [ $ compareOperatorIndex ] = clone $ this -> candidatesMap [ $ type ] ; } elseif ( \ array_key_exists ( $ content , $ this -> candidatesMap ) ) { $ tokens [ $ compareOperatorIndex ] = clone $ this -> candidatesMap [ $ content ] ; } $ right = $ this -> fixTokensComparePart ( $ tokens , $ startRight , $ endRight ) ; $ left = $ this -> fixTokensComparePart ( $ tokens , $ startLeft , $ endLeft ) ; for ( $ i = $ startRight ; $ i <= $ endRight ; ++ $ i ) { $ tokens -> clearAt ( $ i ) ; } for ( $ i = $ startLeft ; $ i <= $ endLeft ; ++ $ i ) { $ tokens -> clearAt ( $ i ) ; } $ tokens -> insertAt ( $ startRight , $ left ) ; $ tokens -> insertAt ( $ startLeft , $ right ) ; return $ startLeft ; }
10479	protected function inlineContext ( $ selectQuery , $ itemRow ) { $ selectQuery = str_replace ( [ 'OLD.' , 'NEW.' ] , '__ctx__' , $ selectQuery ) ; $ prefixedKeys = array_map ( function ( $ key ) { return '__ctx__' . $ key ; } , array_keys ( $ itemRow ) ) ; $ connection = $ this -> getConnection ( ) ; $ escapedValues = array_map ( function ( $ value ) use ( $ connection ) { return $ connection -> quote ( $ value ) ; } , array_values ( $ itemRow ) ) ; $ sql = str_replace ( $ prefixedKeys , $ escapedValues , $ selectQuery ) ; return $ sql ; }
9205	public function init ( ) { $ path = $ this -> absolutePath ( $ this -> getFile ( ) ) ; $ this -> quiet ( 'Initializing seed file: ' . $ this -> shortPath ( $ path ) ) ; $ this -> existsOrCreate ( $ path ) ; }
913	private function moveReturnAnnotations ( $ content ) { $ doc = new DocBlock ( $ content ) ; $ returns = $ doc -> getAnnotationsOfType ( 'return' ) ; if ( empty ( $ returns ) ) { return $ content ; } $ others = $ doc -> getAnnotationsOfType ( [ 'param' , 'throws' ] ) ; if ( empty ( $ others ) ) { return $ content ; } $ start = $ returns [ 0 ] -> getStart ( ) ; $ line = $ doc -> getLine ( $ start ) ; foreach ( array_reverse ( $ others ) as $ other ) { if ( $ other -> getEnd ( ) > $ start ) { $ line -> setContent ( $ other -> getContent ( ) . $ line -> getContent ( ) ) ; $ other -> remove ( ) ; } } return $ doc -> getContent ( ) ; }
5643	public function makeDry ( $ is_dry = true ) { $ numberOfReporters = count ( $ this -> reporters ) ; for ( $ i = 0 ; $ i < $ numberOfReporters ; $ i ++ ) { $ this -> reporters [ $ i ] -> makeDry ( $ is_dry ) ; } }
11203	public function max ( $ key = false ) { $ collection = $ this -> getIterator ( ) ; $ max = 0 ; $ valueToReturn = 0 ; foreach ( $ collection as $ result ) { if ( $ key && isset ( $ result -> $ key ) ) { if ( $ result -> $ key > $ max ) { $ max = $ result -> $ key ; $ valueToReturn = $ result ; } } else if ( $ key && isset ( $ result [ $ key ] ) ) { if ( $ result [ $ key ] > $ max ) { $ max = $ result [ $ key ] ; $ valueToReturn = $ result ; } } else { if ( $ result > $ max ) { $ max = $ result ; $ valueToReturn = $ result ; } } } return $ valueToReturn ; }
10251	public function getFirstName ( $ gender = null ) { if ( empty ( $ gender ) ) { $ gender = $ this -> getGender ( ) ; } return FirstName :: where ( 'gender' , $ gender ) -> where ( 'rank' , '<=' , 250 ) -> orderByRaw ( Database :: random ( ) ) -> first ( ) -> name ; }
4489	public function registerDevice ( string $ deviceId , string $ platform , ? string $ userData = null ) : string { if ( ! isset ( $ this -> arns [ $ platform ] ) ) { throw new PlatformNotConfiguredException ( "There is no configured ARN for $platform" ) ; } try { $ args = [ 'PlatformApplicationArn' => $ this -> arns [ $ platform ] , 'Token' => $ deviceId , 'Attributes' => [ 'Enabled' => 'true' , ] , ] ; if ( $ userData ) { $ args [ 'CustomUserData' ] = $ userData ; } $ res = $ this -> sns -> createPlatformEndpoint ( $ args ) ; } catch ( SnsException $ e ) { preg_match ( '/Endpoint (.+?) already/' , $ e -> getMessage ( ) , $ matches ) ; if ( isset ( $ matches [ 1 ] ) ) { $ this -> sns -> setEndpointAttributes ( [ 'EndpointArn' => $ matches [ 1 ] , 'Attributes' => [ 'Enabled' => 'true' , ] , ] ) ; return $ matches [ 1 ] ; } else { throw $ e ; } } return $ res [ 'EndpointArn' ] ; }
11679	protected function log ( $ message , $ priority = Logger :: DEBUG , array $ extra = [ ] ) { if ( $ this -> getLogger ( ) === null ) { return $ this ; } $ this -> getLogger ( ) -> log ( $ priority , $ message , $ extra ) ; return $ this ; }
7543	function getSibling ( $ offset = 1 ) { $ index = $ this -> index ( ) + $ offset ; if ( ( $ index >= 0 ) && ( $ index < $ this -> parent -> childCount ( ) ) ) { return $ this -> parent -> getChild ( $ index ) ; } else { return null ; } }
2214	public function prev ( ) { if ( $ this -> intIndex < 1 ) { return false ; } $ this -> blnDone = false ; $ this -> arrCache = $ this -> resultSet [ -- $ this -> intIndex ] ; return $ this ; }
6475	public function readAsFormInput ( ? IHttpBody $ body ) : IDictionary { if ( $ body === null ) { return new HashTable ( ) ; } $ parsedFormInputCacheKey = spl_object_hash ( $ body ) ; if ( isset ( $ this -> parsedFormInputCache [ $ parsedFormInputCacheKey ] ) ) { return $ this -> parsedFormInputCache [ $ parsedFormInputCacheKey ] ; } $ formInputArray = [ ] ; parse_str ( $ body -> readAsString ( ) , $ formInputArray ) ; $ kvps = [ ] ; foreach ( $ formInputArray as $ key => $ value ) { $ kvps [ ] = new KeyValuePair ( $ key , $ value ) ; } $ formInputs = new HashTable ( $ kvps ) ; $ this -> parsedFormInputCache [ $ parsedFormInputCacheKey ] = $ formInputs ; return $ formInputs ; }
1394	public function withMediaType ( string $ mediaType ) : self { if ( ! $ encoding = $ this -> api -> getEncodings ( ) -> find ( $ mediaType ) ) { throw new \ InvalidArgumentException ( "Media type {$mediaType} is not valid for API {$this->api->getName()}." ) ; } $ codec = $ this -> factory -> createCodec ( $ this -> api -> getContainer ( ) , $ encoding , null ) ; return $ this -> withCodec ( $ codec ) ; }
2061	public function generateAlias ( $ varValue , Contao \ DataContainer $ dc ) { $ objPage = Contao \ PageModel :: findWithDetails ( $ dc -> id ) ; $ aliasExists = function ( string $ alias ) use ( $ dc , $ objPage ) : bool { $ objAliasIds = $ this -> Database -> prepare ( "SELECT id FROM tl_page WHERE alias=? AND id!=?" ) -> execute ( $ alias , $ dc -> id ) ; if ( ! $ objAliasIds -> numRows ) { return false ; } $ strCurrentDomain = $ objPage -> domain ; $ strCurrentLanguage = $ objPage -> rootLanguage ; if ( $ objPage -> type == 'root' ) { $ strCurrentDomain = Contao \ Input :: post ( 'dns' ) ; $ strCurrentLanguage = Contao \ Input :: post ( 'language' ) ; } while ( $ objAliasIds -> next ( ) ) { $ objAliasPage = Contao \ PageModel :: findWithDetails ( $ objAliasIds -> id ) ; if ( $ objAliasPage -> domain != $ strCurrentDomain ) { continue ; } if ( Contao \ Config :: get ( 'addLanguageToUrl' ) && $ objAliasPage -> rootLanguage != $ strCurrentLanguage ) { continue ; } return true ; } return false ; } ; if ( $ varValue == '' ) { $ varValue = Contao \ System :: getContainer ( ) -> get ( 'contao.slug' ) -> generate ( $ dc -> activeRecord -> title , $ dc -> activeRecord -> id , function ( $ alias ) use ( $ objPage , $ aliasExists ) { return $ aliasExists ( ( Contao \ Config :: get ( 'folderUrl' ) ? $ objPage -> folderUrl : '' ) . $ alias ) ; } ) ; if ( Contao \ Config :: get ( 'folderUrl' ) && $ objPage -> folderUrl != '' ) { $ varValue = $ objPage -> folderUrl . $ varValue ; } } elseif ( $ aliasExists ( $ varValue ) ) { throw new Exception ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'aliasExists' ] , $ varValue ) ) ; } return $ varValue ; }
12782	public function getAll ( ) { if ( is_null ( $ this -> intersections ) ) { $ this -> intersections = [ ] ; if ( $ this -> arraysSize >= 2 ) { $ this -> createIntersections ( ) ; } } return $ this -> intersections ; }
8849	public function category ( ) { $ category = $ this -> getCurrentCategory ( ) ; if ( $ category ) { $ this -> blogPosts = $ category -> BlogPosts ( ) ; return $ this -> render ( ) ; } return $ this -> httpError ( 404 , "Not Found" ) ; }
9695	private function applyInlineStyle ( & $ sheet , $ row , $ column , $ attributeArray ) { if ( ! isset ( $ attributeArray [ 'style' ] ) ) { return ; } $ supported_styles = [ 'background-color' , 'color' ] ; $ styles = explode ( ';' , $ attributeArray [ 'style' ] ) ; foreach ( $ styles as $ st ) { $ value = explode ( ':' , $ st ) ; if ( empty ( trim ( $ value [ 0 ] ) ) || ! in_array ( trim ( $ value [ 0 ] ) , $ supported_styles ) ) { continue ; } if ( substr ( trim ( $ value [ 1 ] ) , 0 , 1 ) == '#' ) { $ style_color = substr ( trim ( $ value [ 1 ] ) , 1 ) ; } if ( empty ( $ style_color ) ) { continue ; } switch ( trim ( $ value [ 0 ] ) ) { case 'background-color' : $ sheet -> getStyle ( $ column . $ row ) -> applyFromArray ( [ 'fill' => [ 'fillType' => Fill :: FILL_SOLID , 'color' => [ 'rgb' => "{$style_color}" ] ] ] ) ; break ; case 'color' : $ sheet -> getStyle ( $ column . $ row ) -> applyFromArray ( [ 'font' => [ 'color' => [ 'rgb' => "$style_color}" ] ] ] ) ; break ; } } }
10415	public function updateTable ( $ connection = null ) { $ connection = $ connection ? : $ this -> connection ; $ schemaManager = $ connection -> getSchemaManager ( ) ; if ( ! $ schemaManager -> tablesExist ( [ $ this -> tableName ] ) ) { return false ; } $ table = new Table ( $ this -> tableName ) ; $ this -> buildTable ( $ table ) ; $ oldTable = $ schemaManager -> listTableDetails ( $ this -> tableName ) ; $ comparator = new Comparator ( ) ; $ diff = $ comparator -> diffTable ( $ oldTable , $ table ) ; if ( ! $ diff ) { return null ; } $ schemaManager -> alterTable ( $ diff ) ; return true ; }
5899	public function listFunctionalities ( $ includeDeleted = false , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'includeDeleted' => $ includeDeleted ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/accounts/functionalities' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new Functionality ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
3532	public static function sendFortnitePostRequest ( $ endpoint , $ access_token , $ params = null ) { $ client = new Client ( ) ; try { $ response = $ client -> post ( $ endpoint , [ 'json' => $ params , 'headers' => [ 'User-Agent' => self :: FORTNITE_USER_AGENT , 'Authorization' => 'bearer ' . $ access_token ] ] ) ; return json_decode ( $ response -> getBody ( ) -> getContents ( ) ) ; } catch ( GuzzleException $ e ) { throw $ e ; } }
4324	public static function getBytes ( $ size ) { if ( \ is_string ( $ size ) && \ preg_match ( '/^([\d,.]+)\s?([kmgtp])b?$/i' , $ size , $ matches ) ) { $ size = \ str_replace ( ',' , '' , $ matches [ 1 ] ) ; switch ( \ strtolower ( $ matches [ 2 ] ) ) { case 'p' : $ size *= 1024 ; case 't' : $ size *= 1024 ; case 'g' : $ size *= 1024 ; case 'm' : $ size *= 1024 ; case 'k' : $ size *= 1024 ; } } $ units = array ( 'B' , 'kB' , 'MB' , 'GB' , 'TB' , 'PB' ) ; $ pow = \ pow ( 1024 , ( $ i = \ floor ( \ log ( $ size , 1024 ) ) ) ) ; $ size = $ pow == 0 ? '0 B' : \ round ( $ size / $ pow , 2 ) . ' ' . $ units [ $ i ] ; return $ size ; }
10055	public function push ( $ type , $ value , $ reference = null ) { $ this -> stack [ $ this -> count ++ ] = [ 'type' => $ type , 'value' => $ value , 'reference' => $ reference , ] ; if ( $ type == 'Function' ) { $ localeFunction = Calculation :: localeFunc ( $ value ) ; if ( $ localeFunction != $ value ) { $ this -> stack [ ( $ this -> count - 1 ) ] [ 'localeValue' ] = $ localeFunction ; } } }
6322	private function parseConfiguration ( array $ config ) { $ this -> currentEnvironment = 'dev' ; foreach ( $ config as $ environment => $ connection ) { if ( isset ( $ connection [ 'dsn' ] ) ) { $ this -> dsn [ $ environment ] = $ connection [ 'dsn' ] ; } else { $ this -> dsn [ $ environment ] = sprintf ( 'pgsql:host=%s; port=%s; dbname=%s;' , $ connection [ 'host' ] , $ connection [ 'port' ] , $ connection [ 'database' ] ) ; } $ this -> username [ $ environment ] = $ connection [ 'username' ] ; $ this -> password [ $ environment ] = $ connection [ 'password' ] ; } }
6357	public function getTimestamp ( $ style = TS_UNIX ) { if ( ! isset ( self :: $ formats [ $ style ] ) ) { throw new TimestampException ( __METHOD__ . ': Illegal timestamp output type.' ) ; } $ output = $ this -> timestamp -> format ( self :: $ formats [ $ style ] ) ; if ( $ style == TS_RFC2822 ) { $ output .= ' GMT' ; } if ( $ style == TS_MW && strlen ( $ output ) !== 14 ) { throw new TimestampException ( __METHOD__ . ': The timestamp cannot be represented in ' . 'the specified format' ) ; } return $ output ; }
1890	public function grantsAccess ( ) : bool { $ content = array_filter ( file ( ( string ) $ this -> file ) ) ; foreach ( $ content as $ line ) { if ( $ this -> hasRequireGranted ( $ line ) ) { return true ; } } return false ; }
1457	protected function next ( Cursor $ cursor , $ columns ) { if ( $ cursor -> isAfter ( ) ) { $ this -> whereId ( $ cursor -> getAfter ( ) , $ this -> descending ? '<' : '>' ) ; } $ items = $ this -> orderForNext ( ) -> get ( $ cursor -> getLimit ( ) + 1 , $ columns ) ; $ more = $ items -> count ( ) > $ cursor -> getLimit ( ) ; return new CursorPaginator ( $ items -> slice ( 0 , $ cursor -> getLimit ( ) ) , $ more , $ cursor , $ this -> key ) ; }
9632	public function getSetting ( $ setting ) { $ settings = $ this -> getSettings ( ) ; if ( isset ( $ settings ) && count ( $ settings ) > 0 ) { if ( isset ( $ settings [ $ setting ] ) ) { return $ settings [ $ setting ] ; } } return '' ; }
9304	public function setFailureLogLifetime ( $ time ) { if ( ! is_numeric ( $ time ) ) { throw new \ InvalidArgumentException ( '`failureLogLifetime` expects integer value!' ) ; } $ this -> options [ 'failureLogLifetime' ] = ( int ) $ time ; return $ this ; }
864	private function registerFoundToken ( $ token ) { $ tokenKind = $ token instanceof Token ? ( $ token -> isArray ( ) ? $ token -> getId ( ) : $ token -> getContent ( ) ) : ( \ is_array ( $ token ) ? $ token [ 0 ] : $ token ) ; if ( ! isset ( $ this -> foundTokenKinds [ $ tokenKind ] ) ) { $ this -> foundTokenKinds [ $ tokenKind ] = 0 ; } ++ $ this -> foundTokenKinds [ $ tokenKind ] ; }
2626	protected function _construct ( ) { $ this -> addColumn ( 'backend_name' , [ 'label' => __ ( 'Name' ) ] ) ; $ this -> _addAfter = false ; $ this -> _template = 'Fastly_Cdn::system/config/form/field/acl.phtml' ; parent :: _construct ( ) ; }
11634	public function bindPage ( array $ deviceIdentifier , array $ pageIds ) { $ params = [ 'device_identifier' => $ deviceIdentifier , 'page_ids' => $ pageIds , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_DEVICE_BINDPAGE , $ params ] ) ; }
344	public static function mailto ( $ text , $ email = null , $ options = [ ] ) { $ options [ 'href' ] = 'mailto:' . ( $ email === null ? $ text : $ email ) ; return static :: tag ( 'a' , $ text , $ options ) ; }
12759	public static function parse ( & $ string ) { $ media = array ( "objects" => array ( ) , "hashes" => array ( ) , "links" => array ( ) , ) ; preg_match_all ( '#@([\\d\\w]+)#' , $ string , $ mentions ) ; preg_match_all ( '/#([\\d\\w]+)/' , $ string , $ hashTags ) ; preg_match_all ( '/((http|https|ftp|ftps)\:\/\/)([a-z0-9+!*(),;?&=\$_.-]+(\:[a-z0-9+!*(),;?&=\$_.-]+)?@)?([a-zA-Z0-9\-\.]+)\.([a-zA-Z]{2,3})(\:[0-9]{2,5})?(\/([a-z0-9+\$_-]\.?)+)*\/?/' , $ data , $ openLinks ) ; return $ media ; }
5276	public function orderBy ( $ columns , $ direction = 'asc' ) { if ( is_string ( $ columns ) ) { $ columns = $ this -> argument_to_array ( $ columns ) ; } foreach ( $ columns as $ key => $ column ) { if ( is_numeric ( $ key ) ) { $ this -> statements [ 'orders' ] [ $ column ] = $ direction ; } else { $ this -> statements [ 'orders' ] [ $ key ] = $ column ; } } return $ this ; }
6895	protected function compareStockUnitByEda ( StockUnitInterface $ u1 , StockUnitInterface $ u2 ) { $ u1HasEda = null !== $ u1 -> getEstimatedDateOfArrival ( ) ; $ u2HasEda = null !== $ u2 -> getEstimatedDateOfArrival ( ) ; if ( ! $ u1HasEda && $ u2HasEda ) { return 1 ; } if ( $ u1HasEda && ! $ u2HasEda ) { return - 1 ; } if ( $ u1 -> getEstimatedDateOfArrival ( ) != $ u2 -> getEstimatedDateOfArrival ( ) ) { return $ u1 -> getEstimatedDateOfArrival ( ) > $ u2 -> getEstimatedDateOfArrival ( ) ? 1 : - 1 ; } return 0 ; }
12716	protected function getConcreteFromInterface ( $ interface ) { if ( ! $ this -> isAbstractExists ( $ interface ) ) { throw Internal \ Exception \ ReflectionExceptionFactory :: runtime ( sprintf ( "%s has no concrete implementation in the class binding stack." , $ interface ) ) ; } try { return $ this -> getResolvedSingleton ( $ interface ) ; } catch ( \ Exception $ e ) { } $ concrete = $ this -> bindings [ $ interface ] [ 'concrete' ] ; $ object = $ concrete instanceof \ Closure ? $ concrete ( $ this ) : $ this -> build ( $ concrete ) ; if ( $ this -> isShared ( $ interface ) ) { $ this -> markAsResolved ( $ interface , $ object , 'singleton' ) ; } else { $ this -> markAsResolved ( $ interface , $ object ) ; } return $ object ; }
9796	public function hasHyperlink ( ) { if ( ! isset ( $ this -> parent ) ) { throw new Exception ( 'Cannot check for hyperlink when cell is not bound to a worksheet' ) ; } return $ this -> getWorksheet ( ) -> hyperlinkExists ( $ this -> getCoordinate ( ) ) ; }
5635	public function paintException ( $ exception ) { parent :: paintException ( $ exception ) ; print '<span class="fail">Exception</span>: ' ; $ breadcrumb = $ this -> getTestList ( ) ; array_shift ( $ breadcrumb ) ; print implode ( ' -&gt; ' , $ breadcrumb ) ; $ message = 'Unexpected exception of type [' . get_class ( $ exception ) . '] with message [' . $ exception -> getMessage ( ) . '] in [' . $ exception -> getFile ( ) . ' line ' . $ exception -> getLine ( ) . ']' ; print ' -&gt; <strong>' . $ this -> htmlEntities ( $ message ) . "</strong><br />\n" ; }
1042	private function printBlockString ( $ value , $ isDescription ) { $ escaped = str_replace ( '"""' , '\\"""' , $ value ) ; return ( $ value [ 0 ] === ' ' || $ value [ 0 ] === "\t" ) && strpos ( $ value , "\n" ) === false ? ( '"""' . preg_replace ( '/"$/' , "\"\n" , $ escaped ) . '"""' ) : ( '"""' . "\n" . ( $ isDescription ? $ escaped : $ this -> indent ( $ escaped ) ) . "\n" . '"""' ) ; }
8984	public function isEqual ( TableNode $ expected , TableNode $ actual , $ message = NULL ) { $ this -> doAssert ( 'Failed asserting that two tables were equivalent: ' , [ 'ignoreColumnSequence' => TRUE ] , $ expected , $ actual , $ message ) ; }
2991	private function encodeRecord ( $ record , $ childName , & $ xml ) { foreach ( $ record as $ key => $ value ) { if ( $ value instanceof \ DateTime ) { if ( $ value -> format ( 'His' ) === '000000' ) { $ value = $ value -> format ( 'm/d/Y' ) ; } else { $ value = $ value -> format ( 'Y-m-d H:i:s' ) ; } } $ keyValue = $ xml -> addChild ( $ childName ) ; $ keyValue -> addAttribute ( 'val' , $ key ) ; if ( is_array ( $ value ) ) { $ this -> parseNestedValues ( $ value , $ keyValue ) ; } else { $ keyValue [ 0 ] = $ value ; } } }
8987	public static function parseStatus ( $ statusLine ) : HttpStatus { list ( $ proto , $ code ) = sscanf ( $ statusLine , "%s %d %s" ) ; return new HttpStatus ( $ code , $ proto ) ; }
7123	protected function updateTicket ( TicketMessageInterface $ message ) { $ ticket = $ message -> getTicket ( ) -> setUpdatedAt ( new \ DateTime ( ) ) ; if ( $ message -> isLatest ( ) && ( $ ticket -> getState ( ) !== TicketStates :: STATE_CLOSED ) ) { if ( $ message -> isCustomer ( ) ) { if ( $ ticket -> getState ( ) === TicketStates :: STATE_PENDING ) { $ ticket -> setState ( TicketStates :: STATE_OPENED ) ; } } elseif ( $ ticket -> getState ( ) === TicketStates :: STATE_OPENED ) { $ ticket -> setState ( TicketStates :: STATE_PENDING ) ; } } $ this -> persistenceHelper -> persistAndRecompute ( $ ticket , false ) ; }
8252	protected function logInvalidLoginAttempt ( $ name ) { $ max = $ this -> config [ "registration" ] [ "nameLenMax" ] ; if ( strlen ( $ name ) > $ max ) { $ max = substr ( $ name , 0 , $ max ) . " (trimmed)" ; } $ this -> getLogger ( ) -> notice ( "Invalid login attempt for {name} by {addr}" , array ( "name" => $ name , "addr" => $ _SERVER [ 'REMOTE_ADDR' ] , ) ) ; }
10457	public function to ( Uom $ uom ) { $ conversionFactor = Uom :: getConversionFactor ( $ this -> getUom ( ) , $ uom ) ; return new static ( $ this -> getAmount ( ) -> multiply ( $ conversionFactor ) , $ uom ) ; }
2444	public static function decrypt ( $ varValue , $ strKey = null ) { if ( \ is_array ( $ varValue ) ) { foreach ( $ varValue as $ k => $ v ) { $ varValue [ $ k ] = static :: decrypt ( $ v ) ; } return $ varValue ; } elseif ( $ varValue == '' ) { return '' ; } if ( static :: $ resTd === null ) { static :: initialize ( ) ; } $ varValue = base64_decode ( $ varValue ) ; $ ivsize = mcrypt_enc_get_iv_size ( static :: $ resTd ) ; $ iv = substr ( $ varValue , 0 , $ ivsize ) ; $ varValue = substr ( $ varValue , $ ivsize ) ; if ( $ varValue == '' ) { return '' ; } if ( ! $ strKey ) { $ strKey = System :: getContainer ( ) -> getParameter ( 'contao.encryption_key' ) ; } mcrypt_generic_init ( static :: $ resTd , md5 ( $ strKey ) , $ iv ) ; $ strDecrypted = mdecrypt_generic ( static :: $ resTd , $ varValue ) ; mcrypt_generic_deinit ( static :: $ resTd ) ; return $ strDecrypted ; }
1112	public function mapTree ( $ nodeList ) { $ tree = $ nodeList instanceof ArrayableInterface ? $ nodeList -> toArray ( ) : $ nodeList ; $ affectedKeys = array ( ) ; $ result = $ this -> mapTreeRecursive ( $ tree , $ this -> node -> getKey ( ) , $ affectedKeys ) ; if ( $ result && count ( $ affectedKeys ) > 0 ) $ this -> deleteUnaffected ( $ affectedKeys ) ; return $ result ; }
3747	protected function extractSorting ( $ config ) { $ sorting = $ config -> getSorting ( ) ; $ sortBy = key ( $ sorting ) ; $ sortDir = current ( $ sorting ) ? : DCGE :: MODEL_SORTING_ASC ; return array ( $ sortBy , $ sortDir ) ; }
11869	public function clearOld ( int $ maxLife ) : void { $ limit = microtime ( true ) - $ maxLife / 1000000 ; foreach ( self :: $ files as & $ file ) { if ( $ file [ 'time' ] <= $ limit ) { $ file = null ; } } self :: $ files = array_filter ( self :: $ files ) ; }
455	public function dropColumn ( $ table , $ column ) { return 'ALTER TABLE ' . $ this -> db -> quoteTableName ( $ table ) . ' DROP COLUMN ' . $ this -> db -> quoteColumnName ( $ column ) ; }
7846	public function cancel ( array $ identifiers = [ ] ) : ? array { $ this -> checkConfig ( ) ; if ( empty ( $ identifiers ) ) { return null ; } $ messages = [ ] ; foreach ( $ identifiers as $ id ) { $ messages [ ] = [ 'id' => ( int ) $ id ] ; } $ body = Body :: json ( $ messages ) ; $ response = Request :: post ( $ this -> baseUrl . 'message/cancel' , [ ] , $ body ) ; if ( $ response -> code == 200 ) { return [ 'code' => $ response -> code , 'message' => 'OK' , 'data' => $ response -> body , ] ; } else { if ( ! empty ( $ response -> body -> message ) ) { Log :: error ( $ response -> body -> message ) ; } return [ 'code' => $ response -> code , 'message' => $ response -> body -> message ?? '' , 'data' => $ response -> body , ] ; } }
8652	private function convertGetReportScheduleCount ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetReportScheduleCount' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetReportTypeList ( ) ) { $ reportTypeList = $ request -> getReportTypeList ( ) ; foreach ( $ reportTypeList -> getType ( ) as $ typeIndex => $ type ) { $ parameters [ 'ReportTypeList' . '.' . 'Type' . '.' . ( $ typeIndex + 1 ) ] = $ type ; } } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
8686	public static function remove ( & $ data , $ path , $ default = null ) { if ( ! static :: $ unsetMarker ) { static :: $ unsetMarker = new \ stdClass ( ) ; } $ value = static :: get ( $ data , $ path , static :: $ unsetMarker ) ; if ( $ value === static :: $ unsetMarker ) { return $ default ; } static :: set ( $ data , $ path , static :: $ unsetMarker ) ; return $ value ; }
2308	public function setImportantPart ( array $ importantPart = null ) { if ( $ importantPart !== null ) { if ( ! isset ( $ importantPart [ 'x' ] ) || ! isset ( $ importantPart [ 'y' ] ) || ! isset ( $ importantPart [ 'width' ] ) || ! isset ( $ importantPart [ 'height' ] ) ) { throw new \ InvalidArgumentException ( 'Malformed array for setting the important part!' ) ; } $ this -> importantPart = array ( 'x' => max ( 0 , min ( $ this -> fileObj -> viewWidth - 1 , ( int ) $ importantPart [ 'x' ] ) ) , 'y' => max ( 0 , min ( $ this -> fileObj -> viewHeight - 1 , ( int ) $ importantPart [ 'y' ] ) ) , ) ; $ this -> importantPart [ 'width' ] = max ( 1 , min ( $ this -> fileObj -> viewWidth - $ this -> importantPart [ 'x' ] , ( int ) $ importantPart [ 'width' ] ) ) ; $ this -> importantPart [ 'height' ] = max ( 1 , min ( $ this -> fileObj -> viewHeight - $ this -> importantPart [ 'y' ] , ( int ) $ importantPart [ 'height' ] ) ) ; } else { $ this -> importantPart = null ; } return $ this ; }
9424	public function write ( $ string ) { if ( ! $ this -> isWritable ( ) ) { $ message = 'Stream is not writable' ; throw new \ RuntimeException ( $ message ) ; } $ this -> size = null ; return fwrite ( $ this -> stream , $ string ) ; }
5514	public function expectOnce ( $ method , $ args = false , $ message = '%s' ) { $ this -> expectCallCount ( $ method , 1 , $ message ) ; if ( $ args !== false ) { $ this -> expect ( $ method , $ args , $ message ) ; } }
6630	public function callback ( $ input ) { if ( isset ( $ input [ 'error' ] ) ) { throw new AuthenticationException ( $ input [ 'error' ] . ':' . $ input [ 'error_description' ] ) ; } if ( ! isset ( $ input [ 'code' ] ) || empty ( $ input [ 'code' ] ) ) { throw new AuthenticationException ( 'invalid code' ) ; } if ( ! isset ( $ input [ 'state' ] ) || empty ( $ input [ 'state' ] ) ) { throw new AuthenticationException ( 'invalid state' ) ; } if ( ! $ this -> store -> has ( $ input [ 'state' ] ) ) { throw new AuthenticationException ( 'state expired' ) ; } $ access_token = $ this -> requestAccessToken ( $ input [ 'code' ] ) ; return $ this -> requestProfile ( $ access_token ) ; }
1424	protected function load ( $ record , EncodingParametersInterface $ parameters ) { $ relationshipPaths = $ this -> getRelationshipPaths ( $ parameters -> getIncludePaths ( ) ) ; $ record -> loadMissing ( $ relationshipPaths ) ; }
3937	private function setOptions ( PropertyInterface $ property , $ propInfo ) { if ( null !== $ property -> getOptions ( ) || ! isset ( $ propInfo [ 'options' ] ) ) { return ; } $ property -> setOptions ( $ propInfo [ 'options' ] ) ; }
5207	public function areActiveURLs ( array $ urls , $ output = "active" ) { foreach ( $ urls as $ url ) { if ( $ this -> isActiveURL ( $ url , true ) ) { return $ output ; } } return null ; }
2794	public function setTempDirectory ( $ dir ) { $ dir = rtrim ( $ dir , ' \\/' ) ; if ( ! is_dir ( $ dir ) || ! is_readable ( $ dir ) ) { throw new InvalidArgumentException ( 'Invalid cache directory: "' . $ dir . '"' ) ; } $ this -> tempDirectory = $ dir ; return $ this ; }
2096	public function getWeekBegin ( $ intStartDay = 0 ) { $ intOffset = date ( 'w' , $ this -> strDate ) - $ intStartDay ; if ( $ intOffset < 0 ) { $ intOffset += 7 ; } return strtotime ( '-' . $ intOffset . ' days' , $ this -> strDate ) ; }
2189	public function unregister ( Model $ objModel ) { $ intObjectId = spl_object_hash ( $ objModel ) ; if ( ! isset ( $ this -> arrIdentities [ $ intObjectId ] ) ) { return ; } $ strTable = $ objModel -> getTable ( ) ; $ strPk = $ objModel -> getPk ( ) ; $ intPk = $ objModel -> $ strPk ; unset ( $ this -> arrIdentities [ $ intObjectId ] ) ; unset ( $ this -> arrRegistry [ $ strTable ] [ $ intPk ] ) ; $ objModel -> onUnregister ( $ this ) ; }
9704	public function writeWorkbook ( array $ pWorksheetSizes ) { $ this -> worksheetSizes = $ pWorksheetSizes ; $ total_worksheets = $ this -> spreadsheet -> getSheetCount ( ) ; $ this -> storeBof ( 0x0005 ) ; $ this -> writeCodepage ( ) ; $ this -> writeWindow1 ( ) ; $ this -> writeDateMode ( ) ; $ this -> writeAllFonts ( ) ; $ this -> writeAllNumberFormats ( ) ; $ this -> writeAllXfs ( ) ; $ this -> writeAllStyles ( ) ; $ this -> writePalette ( ) ; $ part3 = '' ; if ( $ this -> countryCode != - 1 ) { $ part3 .= $ this -> writeCountry ( ) ; } $ part3 .= $ this -> writeRecalcId ( ) ; $ part3 .= $ this -> writeSupbookInternal ( ) ; $ part3 .= $ this -> writeExternalsheetBiff8 ( ) ; $ part3 .= $ this -> writeAllDefinedNamesBiff8 ( ) ; $ part3 .= $ this -> writeMsoDrawingGroup ( ) ; $ part3 .= $ this -> writeSharedStringsTable ( ) ; $ part3 .= $ this -> writeEof ( ) ; $ this -> calcSheetOffsets ( ) ; for ( $ i = 0 ; $ i < $ total_worksheets ; ++ $ i ) { $ this -> writeBoundSheet ( $ this -> spreadsheet -> getSheet ( $ i ) , $ this -> worksheetOffsets [ $ i ] ) ; } $ this -> _data .= $ part3 ; return $ this -> _data ; }
4549	public function get ( string $ alias ) { $ stat = $ this -> statCollection -> filter ( function ( $ element ) use ( $ alias ) { return $ element -> getAlias ( ) === $ alias ; } ) -> first ( ) ; if ( ! $ stat ) { throw new InvalidAliasException ( 'Stat alias "' . $ alias . '" does not exist.' ) ; } $ datum = $ stat -> get ( ) ; return $ datum ; }
8549	public function setRetrochargeEventList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'RetrochargeEventList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
5406	protected function findFirstMatch ( $ cookie ) { for ( $ i = 0 ; $ i < count ( $ this -> cookies ) ; $ i ++ ) { $ is_match = $ this -> isMatch ( $ cookie , $ this -> cookies [ $ i ] -> getHost ( ) , $ this -> cookies [ $ i ] -> getPath ( ) , $ this -> cookies [ $ i ] -> getName ( ) ) ; if ( $ is_match ) { return $ i ; } } return count ( $ this -> cookies ) ; }
3956	public function getSiblings ( $ objFilter ) { if ( ! $ this -> getMetaModel ( ) -> hasVariants ( ) ) { return null ; } return $ this -> getMetaModel ( ) -> findVariantsWithBase ( array ( $ this -> get ( 'id' ) ) , $ objFilter ) ; }
4086	public function handle ( BuildWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) || ( $ event -> getProperty ( ) -> getName ( ) !== 'filterparams' ) ) { return ; } $ model = $ event -> getModel ( ) ; $ objFilterSettings = $ this -> settingFactory -> createCollection ( $ model -> getProperty ( 'filter' ) ) ; $ extra = $ event -> getProperty ( ) -> getExtra ( ) ; $ extra [ 'subfields' ] = $ objFilterSettings -> getParameterDCA ( ) ; $ event -> getProperty ( ) -> setExtra ( $ extra ) ; }
9118	private function getViewBestMatch ( Request $ request , $ applicationName ) { $ best = null ; if ( count ( $ this -> views [ $ applicationName ] ) > 0 ) { foreach ( $ this -> views [ $ applicationName ] as $ orderLevel => $ views ) { foreach ( $ views as $ view ) { assert ( $ view instanceof View ) ; if ( $ view -> matchBoth ( $ request -> getController ( ) , $ request -> getAction ( ) ) ) { $ best [ $ orderLevel ] = $ view ; continue 2 ; } } } } if ( null == $ best ) { throw new ViewException ( "No view found for request" ) ; } if ( count ( $ best ) > 1 ) { krsort ( $ best ) ; } return reset ( $ best ) ; }
6627	public function getData ( $ defaultValue = null ) { return ArrayHelper :: getValue ( $ this -> parsedResponse , self :: RESPONSE_DATA_PARAM , $ defaultValue ) ; }
5454	protected function hasNamedTagOnOpenTagStack ( $ name ) { return isset ( $ this -> tags [ $ name ] ) && ( count ( $ this -> tags [ $ name ] ) > 0 ) ; }
8775	public function admin ( $ data = null , $ secure = false ) { $ data = ( ! is_null ( $ data ) ) ? $ this -> url . '/' . ADMIN_FOLDER . '/' . $ data : $ this -> url . '/' . ADMIN_FOLDER . '/' ; return $ this -> getUrl ( $ data , $ secure ) ; }
4109	public function toOptionArray ( ) { $ options = array ( ) ; $ options [ ] = array ( 'value' => 'aoe_templatehints/renderer_comment' , 'label' => Mage :: helper ( 'aoe_templatehints' ) -> __ ( 'Comments' ) ) ; $ options [ ] = array ( 'value' => 'aoe_templatehints/renderer_opentip' , 'label' => Mage :: helper ( 'aoe_templatehints' ) -> __ ( 'Popups' ) ) ; $ options [ ] = array ( 'value' => 'aoe_templatehints/renderer_tipOnly' , 'label' => Mage :: helper ( 'aoe_templatehints' ) -> __ ( 'Popups (border initially invisible)' ) ) ; Mage :: dispatchEvent ( 'aoetemplatehints_hintrenderer_options' , array ( 'options' => & $ options ) ) ; return $ options ; }
4848	public function destinationsFor ( string $ filePath ) : array { $ filePath = Path :: canonicalize ( $ filePath ) ; $ source = $ this -> matchingSource ( $ filePath ) ; return $ this -> resolveDestinations ( $ filePath , $ source ) ; }
6567	public function getLink ( $ phone_number = '' , $ body = '' ) { if ( ! empty ( $ body ) ) { $ body = "?body=" . $ body ; } $ sms = 'sms:' . trim ( $ phone_number . $ body ) ; return $ sms ; }
12638	public static function select ( string $ table , array $ columns = [ ] , string $ orderBy = "" ) : array { $ pdo = self :: connect ( ) ; $ sql = "SELECT " . ( $ columns === [ ] ? "*" : "\"" . implode ( "\", \"" , $ columns ) . "\"" ) . " FROM \"$table\"" . ( $ orderBy !== "" ? " ORDER BY $orderBy" : "" ) ; $ results = $ pdo -> query ( $ sql ) -> fetchAll ( ) ; return $ results ; }
9897	private function convertString ( $ string ) { $ string = substr ( $ string , 1 , - 1 ) ; if ( strlen ( $ string ) > 255 ) { throw new WriterException ( 'String is too long' ) ; } return pack ( 'C' , $ this -> ptg [ 'ptgStr' ] ) . StringHelper :: UTF8toBIFF8UnicodeShort ( $ string ) ; }
10161	private function readPane ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; if ( ! $ this -> readDataOnly ) { $ px = self :: getUInt2d ( $ recordData , 0 ) ; $ py = self :: getUInt2d ( $ recordData , 2 ) ; $ rwTop = self :: getUInt2d ( $ recordData , 4 ) ; $ colLeft = self :: getUInt2d ( $ recordData , 6 ) ; if ( $ this -> frozen ) { $ cell = Coordinate :: stringFromColumnIndex ( $ px + 1 ) . ( $ py + 1 ) ; $ topLeftCell = Coordinate :: stringFromColumnIndex ( $ colLeft + 1 ) . ( $ rwTop + 1 ) ; $ this -> phpSheet -> freezePane ( $ cell , $ topLeftCell ) ; } } }
2136	protected static function loadParameters ( ) { $ container = System :: getContainer ( ) ; if ( $ container === null ) { return ; } if ( $ container -> hasParameter ( 'contao.localconfig' ) && \ is_array ( $ params = $ container -> getParameter ( 'contao.localconfig' ) ) ) { foreach ( $ params as $ key => $ value ) { $ GLOBALS [ 'TL_CONFIG' ] [ $ key ] = $ value ; } } $ arrMap = array ( 'dbHost' => 'database_host' , 'dbPort' => 'database_port' , 'dbUser' => 'database_user' , 'dbPass' => 'database_password' , 'dbDatabase' => 'database_name' , 'smtpHost' => 'mailer_host' , 'smtpUser' => 'mailer_user' , 'smtpPass' => 'mailer_password' , 'smtpPort' => 'mailer_port' , 'smtpEnc' => 'mailer_encryption' , 'addLanguageToUrl' => 'contao.prepend_locale' , 'encryptionKey' => 'contao.encryption_key' , 'urlSuffix' => 'contao.url_suffix' , 'uploadPath' => 'contao.upload_path' , 'debugMode' => 'kernel.debug' , ) ; foreach ( $ arrMap as $ strKey => $ strParam ) { if ( $ container -> hasParameter ( $ strParam ) ) { $ GLOBALS [ 'TL_CONFIG' ] [ $ strKey ] = $ container -> getParameter ( $ strParam ) ; } } if ( $ container -> hasParameter ( 'contao.image.valid_extensions' ) ) { $ GLOBALS [ 'TL_CONFIG' ] [ 'validImageTypes' ] = implode ( ',' , $ container -> getParameter ( 'contao.image.valid_extensions' ) ) ; } if ( $ container -> hasParameter ( 'contao.image.imagine_options' ) ) { $ GLOBALS [ 'TL_CONFIG' ] [ 'jpgQuality' ] = $ container -> getParameter ( 'contao.image.imagine_options' ) [ 'jpeg_quality' ] ; } }
695	public function beforeSend ( $ message ) { $ event = new MailEvent ( [ 'message' => $ message ] ) ; $ this -> trigger ( self :: EVENT_BEFORE_SEND , $ event ) ; return $ event -> isValid ; }
908	private function isShortArray ( Tokens $ tokens , $ index ) { if ( ! $ tokens [ $ index ] -> equals ( '[' ) ) { return false ; } static $ disallowedPrevTokens = [ ')' , ']' , '}' , '"' , [ T_CONSTANT_ENCAPSED_STRING ] , [ T_STRING ] , [ T_STRING_VARNAME ] , [ T_VARIABLE ] , [ CT :: T_ARRAY_SQUARE_BRACE_CLOSE ] , [ CT :: T_DYNAMIC_PROP_BRACE_CLOSE ] , [ CT :: T_DYNAMIC_VAR_BRACE_CLOSE ] , [ CT :: T_ARRAY_INDEX_CURLY_BRACE_CLOSE ] , ] ; $ prevToken = $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ index ) ] ; if ( $ prevToken -> equalsAny ( $ disallowedPrevTokens ) ) { return false ; } $ nextToken = $ tokens [ $ tokens -> getNextMeaningfulToken ( $ index ) ] ; if ( $ nextToken -> equals ( ']' ) ) { return true ; } return ! $ this -> isArrayDestructing ( $ tokens , $ index ) ; }
3122	public function find ( $ tag = null , $ target = TimePoint :: TARGET_ALL , $ type = TimePoint :: TYPE_ALL ) { $ tags = null ; if ( isset ( $ tag ) ) { $ tags = is_array ( $ tag ) ? $ tag : [ $ tag ] ; } $ points = [ ] ; foreach ( $ this -> points as $ point ) { if ( $ point -> match ( $ tags , $ target , $ type ) ) { $ points [ ] = $ point ; } } return $ points ; }
3485	public static function resolve ( ) : SignatureGeneratorInterface { self :: addDefaultResolvers ( ) ; foreach ( self :: $ resolvers as $ resolver ) { if ( $ generator = $ resolver ( ) ) { return $ generator ; } } throw new \ LogicException ( 'Cannot resolve available JWT Signature Generator.' ) ; }
10763	public function setPaymentType ( $ paymentType ) { if ( self :: PAYMENT_PEER_TO_PEER !== $ paymentType ) { throw new RuntimeException ( Tools :: poorManTranslate ( 'fts-shared' , 'Invalid payment type.' ) ) ; } return $ this -> add ( 'PT' , $ paymentType ) ; }
3287	public function plugin ( $ name , array $ options = null ) { $ helper = $ this -> getTwigHelpers ( ) -> setRenderer ( $ this ) ; if ( $ helper -> has ( $ name ) ) { return $ helper -> get ( $ name , $ options ) ; } return $ this -> getHelperPluginManager ( ) -> get ( $ name , $ options ) ; }
7578	protected function configureData ( $ data ) { if ( ! empty ( $ this -> _REQUIRED_DATA ) && is_array ( $ data ) ) { $ data = $ this -> configureDefaultData ( $ data ) ; } $ this -> setData ( $ data ) ; }
12308	public function showAction ( Request $ request , Application $ app ) { $ options = $ this -> options ( $ request , $ app ) ; return parent :: show ( $ options ) ; }
3782	public function modelToLabel ( ModelToLabelEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ model = $ event -> getModel ( ) ; $ type = $ model -> getProperty ( 'type' ) ; $ image = '<img src="' . $ this -> attributeFactory -> getIconForType ( $ type ) . '" />' ; $ metaModel = $ this -> getMetaModelByModelPid ( $ model ) ; $ attribute = $ this -> attributeFactory -> createAttribute ( $ model -> getPropertiesAsArray ( ) , $ metaModel ) ; if ( ! $ attribute ) { $ translator = $ event -> getEnvironment ( ) -> getTranslator ( ) ; $ event -> setLabel ( '<div class="field_heading cte_type"><strong>%s</strong> <em>[%s]</em></div> <div class="field_type block"> <strong>%s</strong><br /> </div>' ) -> setArgs ( array ( $ translator -> translate ( 'error_unknown_attribute.0' , 'tl_metamodel_attribute' ) , $ type , $ translator -> translate ( 'error_unknown_attribute.1' , 'tl_metamodel_attribute' , array ( $ type ) ) , ) ) ; return ; } $ colName = $ attribute -> getColName ( ) ; $ name = $ attribute -> getName ( ) ; $ arrDescription = StringUtil :: deserialize ( $ attribute -> get ( 'description' ) ) ; if ( is_array ( $ arrDescription ) ) { $ description = $ arrDescription [ $ attribute -> getMetaModel ( ) -> getActiveLanguage ( ) ] ; if ( ! $ description ) { $ description = $ arrDescription [ $ attribute -> getMetaModel ( ) -> getFallbackLanguage ( ) ] ; } } else { $ description = $ arrDescription ? : $ attribute -> getName ( ) ; } $ event -> setLabel ( '<div class="field_heading cte_type"><strong>%s</strong> <em>[%s]</em></div> <div class="field_type block"> %s<strong>%s</strong> - %s </div>' ) -> setArgs ( array ( $ colName , $ type , $ image , $ name , $ description ) ) ; }
3223	function createTemporaryDirectLink ( $ path ) { Path :: checkArgNonRoot ( "path" , $ path ) ; $ response = $ this -> doPost ( $ this -> apiHost , $ this -> appendFilePath ( "1/media" , $ path ) ) ; if ( $ response -> statusCode === 404 ) return null ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; $ j = RequestUtil :: parseResponseJson ( $ response -> body ) ; $ url = self :: getField ( $ j , "url" ) ; $ expires = self :: parseDateTime ( self :: getField ( $ j , "expires" ) ) ; return array ( $ url , $ expires ) ; }
1444	protected function getStubFor ( $ implementationType ) { return sprintf ( '%s/%s/%s.stub' , $ this -> stubsDirectory , $ implementationType , Str :: dasherize ( $ this -> type ) ) ; }
9359	protected function finalize ( $ function ) { $ response = $ this -> container -> get ( self :: RESPONSE ) ; if ( is_string ( $ function ) === true ) { $ stream = $ response -> getBody ( ) ; $ stream -> write ( ( string ) $ function ) ; } $ instanceof = $ function instanceof ResponseInterface ; return $ instanceof ? $ function : $ response ; }
11397	public static function parseFault ( \ SimpleXMLElement $ fault ) { $ faultData = static :: parseStruct ( $ fault -> value -> struct ) ; return new \ Devedge \ XmlRpc \ Client \ RemoteException ( $ faultData [ 'faultString' ] , $ faultData [ 'faultCode' ] ) ; }
6952	private function isSaleItemCovered ( Common \ SaleItemInterface $ saleItem , array $ coveredIds ) { if ( $ saleItem -> isCompound ( ) && ! $ saleItem -> hasPrivateChildren ( ) ) { return true ; } if ( ! in_array ( $ saleItem -> getId ( ) , $ coveredIds , true ) ) { return false ; } foreach ( $ saleItem -> getChildren ( ) as $ child ) { if ( ! $ this -> isSaleItemCovered ( $ child , $ coveredIds ) ) { return false ; } } return true ; }
12414	public function removeDevice ( $ groupId , array $ deviceIdentifiers ) { $ params = [ 'group_id' => intval ( $ groupId ) , 'device_identifiers' => $ deviceIdentifiers , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_DELETE_DEVICE , $ params ] ) ; }
2129	protected function initialize ( ) { if ( static :: $ blnHasLcf === null ) { static :: preload ( ) ; } $ strCacheDir = System :: getContainer ( ) -> getParameter ( 'kernel.cache_dir' ) ; if ( file_exists ( $ strCacheDir . '/contao/config/config.php' ) ) { include $ strCacheDir . '/contao/config/config.php' ; } else { try { $ files = System :: getContainer ( ) -> get ( 'contao.resource_locator' ) -> locate ( 'config/config.php' , null , false ) ; } catch ( \ InvalidArgumentException $ e ) { $ files = array ( ) ; } foreach ( $ files as $ file ) { include $ file ; } } if ( static :: $ blnHasLcf ) { include $ this -> strRootDir . '/system/config/localconfig.php' ; } static :: loadParameters ( ) ; }
3996	protected function jumpTo ( $ mixMetaModel , $ mixDataId , $ intIdRenderSetting , $ strParam = 'url' ) { if ( empty ( $ strParam ) ) { $ strParam = 'url' ; } $ objMetaModel = $ this -> loadMetaModel ( $ mixMetaModel ) ; if ( $ objMetaModel == null ) { return false ; } $ objRenderSettings = $ this -> getServiceContainer ( ) -> getRenderSettingFactory ( ) -> createCollection ( $ objMetaModel , $ intIdRenderSetting ) ; if ( $ objRenderSettings == null ) { return false ; } $ objItem = $ objMetaModel -> findById ( $ mixDataId ) ; if ( $ objItem == null ) { return false ; } $ arrRenderedItem = $ objItem -> parseValue ( 'text' , $ objRenderSettings ) ; if ( ! isset ( $ arrRenderedItem [ 'jumpTo' ] ) ) { return false ; } if ( stripos ( $ strParam , 'params.' ) !== false ) { $ mixAttName = StringUtil :: trimsplit ( '.' , $ strParam ) ; $ mixAttName = array_pop ( $ mixAttName ) ; if ( isset ( $ arrRenderedItem [ 'jumpTo' ] [ 'params' ] [ $ mixAttName ] ) ) { return $ arrRenderedItem [ 'jumpTo' ] [ 'params' ] [ $ mixAttName ] ; } } elseif ( isset ( $ arrRenderedItem [ 'jumpTo' ] [ $ strParam ] ) ) { return $ arrRenderedItem [ 'jumpTo' ] [ $ strParam ] ; } return false ; }
12932	protected function generateContentAttribute ( $ name , $ value , $ type = 'text' ) { $ attribute = new ContentAttribute ( ) ; $ attribute -> setName ( $ name ) ; $ attribute -> setValue ( $ value ) ; if ( is_array ( $ value ) ) { $ value = '' ; } $ attribute -> setStringValue ( $ value ) ; $ attribute -> setType ( $ type ) ; return $ attribute ; }
10704	public function getModel ( ) { if ( null === $ this -> model ) { $ mainService = $ this -> getServiceLocator ( ) -> get ( 'neobazaar.service.main' ) ; $ this -> model = $ mainService -> getUserEntityRepository ( ) ; } return $ this -> model ; }
10806	protected function getConfig ( ) { $ config = array_replace ( $ this -> config , $ this -> dialect_config ) ; ksort ( $ config ) ; return $ config ; }
5198	public function save ( ) { try { $ connection = new Connection ( $ this -> buildConnectionOptions ( ) ) ; $ connection -> open ( ) ; $ msg = new AMQPMessage ( $ this -> message , array ( 'content_type' => $ this -> content_type , 'delivery_mode' => 2 ) ) ; $ connection -> channel -> basic_publish ( $ msg , $ this -> exchange , $ this -> queue_name ) ; $ connection -> close ( ) ; } catch ( Exception $ e ) { $ connection -> close ( ) ; throw new Exception ( $ e ) ; } }
3640	public function all ( bool $ trim = true , bool $ clean = true ) { $ values = $ this -> request -> all ( ) ; return $ this -> clean ( $ values , $ trim , $ clean ) ; }
3036	protected function persistCacheEntry ( $ key ) { $ success = true ; if ( isset ( $ this -> cache [ $ key ] ) ) { $ cache = $ this -> cache [ $ key ] ; switch ( $ cache [ 'state' ] ) { case self :: STATE_PENDING_WRITE : $ success = $ this -> getStorage ( ) -> set ( $ cache [ 'userId' ] , $ cache [ 'callId' ] , $ cache [ 'data' ] ) ; if ( ! $ success ) { throw new \ common_exception_Error ( 'Can\'t write into test runner state storage at ' . static :: class ) ; } $ this -> cache [ $ key ] [ 'state' ] = self :: STATE_ALIGNED ; break ; case self :: STATE_PENDING_DELETE : $ success = $ this -> getStorage ( ) -> del ( $ cache [ 'userId' ] , $ cache [ 'callId' ] ) ; if ( $ success ) { unset ( $ this -> cache [ $ key ] ) ; } break ; } } return $ success ; }
6531	protected function applyAnalyzer ( array $ mapping , Field $ field , \ stdClass $ rootObject , $ path = null ) { if ( null === $ this -> defaultAnalyzer ) { return $ mapping ; } if ( ! isset ( $ mapping [ 'type' ] ) || 'text' !== $ mapping [ 'type' ] ) { return $ mapping ; } if ( isset ( $ mapping [ 'index' ] ) && false === $ mapping [ 'index' ] ) { return $ mapping ; } if ( isset ( $ mapping [ 'analyzer' ] ) ) { return $ mapping ; } $ mapping [ 'analyzer' ] = $ this -> defaultAnalyzer ; return $ mapping ; }
1933	protected function getLocaleString ( ) { $ container = System :: getContainer ( ) ; return 'var Contao={' . 'theme:"' . Backend :: getTheme ( ) . '",' . 'lang:{' . 'close:"' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'close' ] . '",' . 'collapse:"' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'collapseNode' ] . '",' . 'expand:"' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'expandNode' ] . '",' . 'loading:"' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'loadingData' ] . '",' . 'apply:"' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'apply' ] . '"' . '},' . 'script_url:"' . $ container -> get ( 'contao.assets.assets_context' ) -> getStaticUrl ( ) . '",' . 'path:"' . Environment :: get ( 'path' ) . '",' . 'request_token:"' . REQUEST_TOKEN . '",' . 'referer_id:"' . $ container -> get ( 'request_stack' ) -> getCurrentRequest ( ) -> attributes -> get ( '_contao_referer_id' ) . '"' . '};' ; }
4172	public function run ( ) { if ( $ this -> search ( ) ) { $ this -> registered = true ; return $ this -> console -> call ( 'migrate' ) ; } return false ; }
10011	public function removeSheetByIndex ( $ pIndex ) { $ numSheets = count ( $ this -> workSheetCollection ) ; if ( $ pIndex > $ numSheets - 1 ) { throw new Exception ( "You tried to remove a sheet by the out of bounds index: {$pIndex}. The actual number of sheets is {$numSheets}." ) ; } array_splice ( $ this -> workSheetCollection , $ pIndex , 1 ) ; if ( ( $ this -> activeSheetIndex >= $ pIndex ) && ( $ pIndex > count ( $ this -> workSheetCollection ) - 1 ) ) { -- $ this -> activeSheetIndex ; } }
9990	private function writeImageInCell ( Worksheet $ pSheet , $ coordinates ) { $ html = '' ; foreach ( $ pSheet -> getDrawingCollection ( ) as $ drawing ) { if ( $ drawing instanceof Drawing ) { if ( $ drawing -> getCoordinates ( ) == $ coordinates ) { $ filename = $ drawing -> getPath ( ) ; if ( substr ( $ filename , 0 , 1 ) == '.' ) { $ filename = substr ( $ filename , 1 ) ; } $ filename = $ this -> getImagesRoot ( ) . $ filename ; if ( substr ( $ filename , 0 , 1 ) == '.' && substr ( $ filename , 0 , 2 ) != './' ) { $ filename = substr ( $ filename , 1 ) ; } $ filename = htmlspecialchars ( $ filename ) ; $ html .= PHP_EOL ; if ( ( ! $ this -> embedImages ) || ( $ this -> isPdf ) ) { $ imageData = $ filename ; } else { $ imageDetails = getimagesize ( $ filename ) ; if ( $ fp = fopen ( $ filename , 'rb' , 0 ) ) { $ picture = fread ( $ fp , filesize ( $ filename ) ) ; fclose ( $ fp ) ; $ base64 = chunk_split ( base64_encode ( $ picture ) ) ; $ imageData = 'data:' . $ imageDetails [ 'mime' ] . ';base64,' . $ base64 ; } else { $ imageData = $ filename ; } } $ html .= '<div style="position: relative;">' ; $ html .= '<img style="position: absolute; z-index: 1; left: ' . $ drawing -> getOffsetX ( ) . 'px; top: ' . $ drawing -> getOffsetY ( ) . 'px; width: ' . $ drawing -> getWidth ( ) . 'px; height: ' . $ drawing -> getHeight ( ) . 'px;" src="' . $ imageData . '" border="0" />' ; $ html .= '</div>' ; } } elseif ( $ drawing instanceof MemoryDrawing ) { if ( $ drawing -> getCoordinates ( ) != $ coordinates ) { continue ; } ob_start ( ) ; imagepng ( $ drawing -> getImageResource ( ) ) ; $ contents = ob_get_contents ( ) ; ob_end_clean ( ) ; $ dataUri = 'data:image/jpeg;base64,' . base64_encode ( $ contents ) ; $ html .= '<img src="' . $ dataUri . '" style="max-width:100%;width:' . $ drawing -> getWidth ( ) . 'px;" />' ; } } return $ html ; }
6598	protected function getParameters ( array $ lines ) { $ comment = implode ( "\n" , $ lines ) ; preg_match_all ( '/@param\s([\s\S]+?(?=@))/' , $ comment , $ paramsDoc ) ; $ params = [ ] ; if ( isset ( $ paramsDoc [ 1 ] ) ) { foreach ( $ paramsDoc [ 1 ] as $ paramDoc ) { $ documentation = [ ] ; preg_match ( '/([^$]+)?\$(\w+)(.+)?/s' , $ paramDoc , $ documentation ) ; list ( , $ type , $ name , $ description ) = $ documentation ; $ lines = preg_split ( "/((\r?\n)|(\r\n?))/" , $ description ) ; foreach ( $ lines as $ key => $ value ) { $ value = preg_replace ( '/\r/' , '' , $ value ) ; $ value = preg_replace ( '/^\s+\*/' , '' , $ value ) ; $ value = trim ( $ value ) ; $ lines [ $ key ] = $ value ; } $ description = implode ( "\n" , $ lines ) ; $ params [ $ name ] = [ 'type' => trim ( $ type ) , 'description' => trim ( $ description ) , ] ; } } return $ params ; }
7481	public function setContent ( $ content ) { Argument :: i ( ) -> test ( 1 , 'string' ) ; try { $ this -> absolute ( ) ; } catch ( \ Eden \ Path \ Exception $ e ) { $ this -> touch ( ) ; } file_put_contents ( $ this -> data , $ content ) ; return $ this ; }
102	public function findFile ( $ class ) { if ( isset ( $ this -> classMap [ $ class ] ) ) { return $ this -> classMap [ $ class ] ; } if ( $ this -> classMapAuthoritative || isset ( $ this -> missingClasses [ $ class ] ) ) { return false ; } if ( null !== $ this -> apcuPrefix ) { $ file = apcu_fetch ( $ this -> apcuPrefix . $ class , $ hit ) ; if ( $ hit ) { return $ file ; } } $ file = $ this -> findFileWithExtension ( $ class , '.php' ) ; if ( false === $ file && defined ( 'HHVM_VERSION' ) ) { $ file = $ this -> findFileWithExtension ( $ class , '.hh' ) ; } if ( null !== $ this -> apcuPrefix ) { apcu_add ( $ this -> apcuPrefix . $ class , $ file ) ; } if ( false === $ file ) { $ this -> missingClasses [ $ class ] = true ; } return $ file ; }
11920	public function onPageRemoved ( PageCollectionRemovedEvent $ event ) { $ pageName = basename ( $ event -> getFilePath ( ) ) ; $ page = $ this -> pagesParser -> contributor ( $ event -> getUsername ( ) ) -> parse ( ) -> page ( $ pageName ) ; if ( null === $ page ) { return ; } foreach ( $ page [ "seo" ] as $ seo ) { $ permalink = $ seo [ "permalink" ] ; $ this -> permalinkManager -> remove ( $ permalink ) ; } $ this -> permalinkManager -> save ( ) ; }
5228	public static function createInjector ( callable ... $ applyBindings ) { $ self = new self ( ) ; foreach ( $ applyBindings as $ applyBinding ) { $ applyBinding ( $ self ) ; } return $ self -> getInjector ( ) ; }
8235	protected function ivalidateToken ( $ index , array & $ tokenStorage ) { unset ( $ tokenStorage [ $ index ] ) ; $ this -> session -> set ( self :: SESSION_KEY , $ tokenStorage ) ; }
3872	protected function getJumpTosFor ( $ metaModels , $ filter , $ view , $ rootPage = null ) { $ entries = array ( ) ; $ items = $ metaModels -> findByFilter ( $ filter ) ; foreach ( $ items as $ item ) { $ jumpTo = $ item -> buildJumpToLink ( $ view ) ; $ event = new GetPageDetailsEvent ( $ jumpTo [ 'page' ] ) ; $ this -> getEventDispatcher ( ) -> dispatch ( ContaoEvents :: CONTROLLER_GET_PAGE_DETAILS , $ event ) ; $ pageDetails = $ event -> getPageDetails ( ) ; if ( $ pageDetails === null || ( $ rootPage !== null && $ pageDetails [ 'rootId' ] != $ rootPage ) ) { continue ; } $ url = $ this -> getBaseUrl ( $ pageDetails , $ jumpTo [ 'url' ] ) ; $ entries [ ] = $ url -> getUrl ( ) ; } return $ entries ; }
8239	public function setAuthenticated ( $ v ) { if ( ! $ v ) { $ this -> authenticator = null ; } $ this -> authenticated = $ v ; return $ this ; }
6470	public function parseAcceptLanguageHeader ( HttpHeaders $ headers ) : array { $ headerValues = [ ] ; if ( ! $ headers -> tryGet ( 'Accept-Language' , $ headerValues ) ) { return [ ] ; } $ parsedHeaderValues = [ ] ; $ numHeaderValues = count ( $ headerValues ) ; for ( $ i = 0 ; $ i < $ numHeaderValues ; $ i ++ ) { $ parsedHeaderParameters = $ this -> parseParameters ( $ headers , 'Accept-Language' , $ i ) ; $ language = $ parsedHeaderParameters -> getKeys ( ) [ 0 ] ; $ parsedHeaderValues [ ] = new AcceptLanguageHeaderValue ( $ language , $ parsedHeaderParameters ) ; } return $ parsedHeaderValues ; }
1417	public function failedValidator ( ValidatorContract $ validator , \ Closure $ closure = null ) : ErrorCollection { $ failed = $ this -> doesIncludeFailed ( ) ? $ validator -> failed ( ) : [ ] ; $ errors = new ErrorCollection ( ) ; foreach ( $ validator -> errors ( ) -> messages ( ) as $ key => $ messages ) { $ failures = $ this -> createValidationFailures ( $ failed [ $ key ] ?? [ ] ) ; foreach ( $ messages as $ detail ) { $ failed = $ failures -> shift ( ) ? : [ ] ; if ( $ closure ) { $ errors -> add ( $ this -> call ( $ closure , $ key , $ detail , $ failed ) ) ; continue ; } $ errors -> add ( new Error ( null , null , Response :: HTTP_UNPROCESSABLE_ENTITY , $ this -> trans ( 'failed_validator' , 'code' ) , $ this -> trans ( 'failed_validator' , 'title' ) , $ detail ? : $ this -> trans ( 'failed_validator' , 'detail' ) ) ) ; } } return $ errors ; }
7773	protected function validateAgainstRule ( $ field , $ value , $ rule , array $ args ) { $ ruleToCall = $ this -> getRuleToCall ( $ rule ) ; $ passed = call_user_func_array ( $ ruleToCall , [ $ value , $ this -> input , $ args ] ) ; if ( ! $ passed ) { $ this -> handleError ( $ field , $ value , $ rule , $ args ) ; return $ this -> canSkipRule ( $ ruleToCall , $ value ) ; } return true ; }
1472	public function createRelationshipDocumentValidator ( $ document ) { return new Validation \ Spec \ RelationValidator ( $ this -> container -> make ( StoreInterface :: class ) , $ this -> createErrorTranslator ( ) , $ document ) ; }
6712	protected function stringToArray ( $ string ) { if ( ! $ string || ! is_string ( $ string ) ) { return [ ] ; } $ result = $ this -> getReaderFactory ( ) -> read ( $ string ) ; if ( $ result ) { return $ result ; } $ array = [ ] ; $ array [ 'text' ] = $ string ; return $ array ; }
4837	public function confirm_resource ( $ params ) { $ endpoint = '/confirm' ; $ required_params = array ( 'resource_id' , 'resource_type' ) ; foreach ( $ required_params as $ key => $ value ) { if ( ! isset ( $ params [ $ value ] ) ) { throw new GoCardless_ArgumentsException ( "$value missing" ) ; } $ data [ $ value ] = $ params [ $ value ] ; } if ( isset ( $ params [ 'state' ] ) ) { $ data [ 'state' ] = $ params [ 'state' ] ; } if ( isset ( $ params [ 'resource_uri' ] ) ) { $ data [ 'resource_uri' ] = $ params [ 'resource_uri' ] ; } $ sig_validation_data = array ( 'data' => $ data , 'secret' => $ this -> account_details [ 'app_secret' ] , 'signature' => $ params [ 'signature' ] ) ; if ( $ this -> validate_signature ( $ sig_validation_data ) == false ) { throw new GoCardless_SignatureException ( ) ; } $ confirm_params = array ( 'resource_id' => $ params [ 'resource_id' ] , 'resource_type' => $ params [ 'resource_type' ] ) ; $ confirm_params [ 'http_authorization' ] = $ this -> account_details [ 'app_id' ] . ':' . $ this -> account_details [ 'app_secret' ] ; if ( ! isset ( $ params [ 'redirect_uri' ] ) && isset ( $ this -> redirect_uri ) ) { $ confirm_params [ 'redirect_uri' ] = $ this -> redirect_uri ; } $ response = $ this -> request ( 'post' , $ endpoint , $ confirm_params ) ; if ( $ response [ 'success' ] == true ) { $ endpoint = '/' . $ params [ 'resource_type' ] . 's/' . $ params [ 'resource_id' ] ; $ class_name = 'GoCardless_' . GoCardless_Utils :: camelize ( $ params [ 'resource_type' ] ) ; return new $ class_name ( $ this , $ this -> request ( 'get' , $ endpoint ) ) ; } else { throw new GoCardless_ClientException ( 'Failed to fetch the confirmed resource.' ) ; } }
799	private function removeSpaceAroundToken ( Tokens $ tokens , $ index ) { $ token = $ tokens [ $ index ] ; if ( $ token -> isWhitespace ( ) && false === strpos ( $ token -> getContent ( ) , "\n" ) ) { $ tokens -> clearAt ( $ index ) ; } }
7144	public static function remove_author_meta_values ( ) { global $ blog_id ; if ( isset ( $ blog_id ) && ! empty ( $ blog_id ) ) { $ blogusers = get_users ( array ( 'blog_id' => $ blog_id ) ) ; foreach ( $ blogusers as $ user_object ) { delete_user_meta ( $ user_object -> ID , 'post_subscription' ) ; delete_user_meta ( $ user_object -> ID , 'comment_subscription' ) ; } } }
6697	public function isMethodHidden ( $ methodName ) { if ( ! method_exists ( $ this , $ methodName ) ) { throw new Exception ( 500 , "The method '$methodName' does not exist in " . get_called_class ( ) ) ; } return isset ( $ this -> hiddenMethods [ $ methodName ] ) ; }
10249	public function getDate ( $ params = [ ] , $ format = 'Y-m-d' ) { foreach ( $ params as $ k => $ v ) { $ $ k = $ v ; } if ( ! isset ( $ min_year ) ) { $ min_year = date ( 'Y' ) - 2 ; } if ( ! isset ( $ max_year ) ) { $ max_year = date ( 'Y' ) ; } if ( ! isset ( $ min_month ) ) { $ min_month = 1 ; } if ( ! isset ( $ max_month ) ) { $ max_month = 12 ; } $ rand_year = rand ( $ min_year , $ max_year ) ; $ rand_month = rand ( $ min_month , $ max_month ) ; $ date = DateTime :: createFromFormat ( 'Y-m-d' , join ( '-' , [ $ rand_year , $ rand_month , '01' ] ) ) ; $ days_in_month = $ date -> format ( 't' ) ; $ rand_day = rand ( 1 , $ days_in_month ) ; return DateTime :: createFromFormat ( 'Y-m-d' , join ( '-' , [ $ rand_year , $ rand_month , $ rand_day ] ) ) -> format ( $ format ) ; }
1799	public function help ( $ strClass = '' ) { $ return = $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ this -> strField ] [ 'label' ] [ 1 ] ; if ( ! Config :: get ( 'showHelp' ) || $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ this -> strField ] [ 'inputType' ] == 'password' || $ return == '' ) { return '' ; } return ' <p class="tl_help tl_tip' . $ strClass . '">' . $ return . '</p>' ; }
9848	public function createSignedRequest ( string $ method , string $ uri , string $ body , SigningSecretKey $ key , array $ headers = [ ] ) : RequestInterface { $ signature = \ ParagonIE_Sodium_Compat :: crypto_sign_detached ( $ body , $ key -> getString ( true ) ) ; if ( isset ( $ headers [ Sapient :: HEADER_SIGNATURE_NAME ] ) ) { $ headers [ Sapient :: HEADER_SIGNATURE_NAME ] [ ] = Base64UrlSafe :: encode ( $ signature ) ; } else { $ headers [ Sapient :: HEADER_SIGNATURE_NAME ] = Base64UrlSafe :: encode ( $ signature ) ; } return new Request ( $ method , Uri :: createFromString ( $ uri ) , new Headers ( $ headers ) , [ ] , [ ] , $ this -> stringToStream ( $ body ) , [ ] ) ; }
342	public static function validateMultiple ( $ models , $ attributes = null ) { $ result = [ ] ; foreach ( $ models as $ i => $ model ) { $ model -> validate ( $ attributes ) ; foreach ( $ model -> getErrors ( ) as $ attribute => $ errors ) { $ result [ Html :: getInputId ( $ model , "[$i]" . $ attribute ) ] = $ errors ; } } return $ result ; }
3186	public function start ( $ tags , $ timestamp ) { if ( ! is_numeric ( $ timestamp ) || $ timestamp < 0 ) { throw new InvalidDataException ( 'start() needs a valid timestamp!' ) ; } $ range = $ this -> getRange ( $ tags ) ; if ( $ this -> isRangeOpen ( $ range ) ) { \ common_Logger :: t ( 'Missing END TimePoint in QtiTimer, auto add an arbitrary value' ) ; $ point = new TimePoint ( $ tags , $ timestamp - ( 1 / TimePoint :: PRECISION ) , TimePoint :: TYPE_END , TimePoint :: TARGET_SERVER ) ; $ this -> timeLine -> add ( $ point ) ; $ range [ ] = $ point ; } $ this -> checkTimestampCoherence ( $ range , $ timestamp ) ; $ point = new TimePoint ( $ tags , $ timestamp , TimePoint :: TYPE_START , TimePoint :: TARGET_SERVER ) ; $ this -> timeLine -> add ( $ point ) ; return $ this ; }
3150	public function comment ( RunnerServiceContext $ context , $ comment ) { $ testSession = $ context -> getTestSession ( ) ; $ item = $ testSession -> getCurrentAssessmentItemRef ( ) -> getIdentifier ( ) ; $ occurrence = $ testSession -> getCurrentAssessmentItemRefOccurence ( ) ; $ sessionId = $ testSession -> getSessionId ( ) ; $ transmissionId = "${sessionId}.${item}.${occurrence}" ; $ deliveryServerService = $ this -> getServiceManager ( ) -> get ( DeliveryServerService :: SERVICE_ID ) ; $ resultStore = $ deliveryServerService -> getResultStoreWrapper ( $ sessionId ) ; $ transmitter = new \ taoQtiCommon_helpers_ResultTransmitter ( $ resultStore ) ; $ itemUri = TestRunnerUtils :: getCurrentItemUri ( $ testSession ) ; $ testUri = $ testSession -> getTest ( ) -> getUri ( ) ; $ variable = new ResponseVariable ( 'comment' , Cardinality :: SINGLE , BaseType :: STRING , new QtismString ( $ comment ) ) ; $ transmitter -> transmitItemVariable ( $ variable , $ transmissionId , $ itemUri , $ testUri ) ; return true ; }
2337	private function setLegacyOptions ( Table $ table ) : void { if ( ! $ table -> hasOption ( 'engine' ) ) { $ table -> addOption ( 'engine' , 'MyISAM' ) ; } if ( ! $ table -> hasOption ( 'charset' ) ) { $ table -> addOption ( 'charset' , 'utf8' ) ; } if ( ! $ table -> hasOption ( 'collate' ) ) { $ table -> addOption ( 'collate' , 'utf8_general_ci' ) ; } }
8231	public static function getItemByUrl ( $ items , $ url ) { if ( ! isset ( $ items ) ) { return null ; } if ( array_key_exists ( "/" . $ url , $ items ) ) { return $ items [ "/" . $ url ] ; } $ urlParts = explode ( "/" , trim ( $ url , "/" ) ) ; $ urlPartsLen = count ( $ urlParts ) ; while ( $ urlPartsLen > 0 ) { unset ( $ urlParts [ -- $ urlPartsLen ] ) ; $ subUrl = "/" . join ( "/" , $ urlParts ) ; if ( array_key_exists ( $ subUrl , $ items ) && ( ! isset ( $ items [ $ subUrl ] [ "recursive" ] ) || $ items [ $ subUrl ] [ "recursive" ] === true ) ) { return $ items [ $ subUrl ] ; } } return null ; }
11890	final protected function addRequiredAttributeToFields ( array $ specifications ) { foreach ( $ specifications as $ field => $ data ) { if ( ! $ this -> has ( $ field ) ) { continue ; } $ validators = ArrayUtils :: get ( $ data , 'validators' , [ ] ) ; $ isRequired = ( bool ) ArrayUtils :: get ( $ data , 'required' , ArrayUtils :: get ( $ validators , NotEmpty :: class , ArrayUtils :: get ( $ validators , 'NotEmpty' ) ) ) ; if ( $ isRequired ) { $ this -> get ( $ field ) -> setAttribute ( 'required' , 'required' ) ; } } return $ this ; }
641	public function addForeignKey ( $ name , $ table , $ columns , $ refTable , $ refColumns , $ delete = null , $ update = null ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> addForeignKey ( $ name , $ table , $ columns , $ refTable , $ refColumns , $ delete , $ update ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; }
3910	protected function getDownloadLink ( $ strFile ) { if ( ! isset ( $ _SESSION [ 'metaModels_downloads' ] [ $ strFile ] ) ) { $ _SESSION [ 'metaModels_downloads' ] [ $ strFile ] = md5 ( uniqid ( ) ) ; } return UrlBuilder :: fromUrl ( Environment :: get ( 'request' ) ) -> setQueryParameter ( 'file' , urlencode ( $ strFile ) ) -> setQueryParameter ( 'fileKey' , $ _SESSION [ 'metaModels_downloads' ] [ $ strFile ] ) -> getUrl ( ) ; }
12629	public function sendToDevice ( $ deviceId , $ openId , $ content ) { $ params = [ 'device_type' => $ this -> deviceType , 'device_id' => $ deviceId , 'open_id' => $ openId , 'content' => base64_encode ( $ content ) , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_TRANS_MSG , $ params ] ) ; }
6742	public function apply ( Request $ request , ParamConverter $ configuration ) { $ param = $ this -> getRequestAttributeName ( $ request , $ configuration ) ; if ( ! $ request -> attributes -> has ( $ param ) ) { return false ; } $ value = $ request -> attributes -> get ( $ param ) ; if ( ! $ value && $ configuration -> isOptional ( ) ) { return false ; } $ convertedValue = $ this -> convertValue ( $ value , $ configuration ) ; if ( null === $ convertedValue && false === $ configuration -> isOptional ( ) ) { throw new NotFoundHttpException ( "Unable to find '{$configuration->getClass()}' with identifier '{$value}' not found" ) ; } $ request -> attributes -> set ( $ configuration -> getName ( ) , $ convertedValue ) ; return true ; }
12744	public function askSlotMap ( NodeConnectionInterface $ connection = null ) { if ( ! $ connection && ! $ connection = $ this -> getRandomConnection ( ) ) { return ; } $ this -> slotmap -> reset ( ) ; $ response = $ this -> queryClusterNodeForSlotMap ( $ connection ) ; foreach ( $ response as $ slots ) { list ( $ start , $ end , $ master ) = $ slots ; if ( $ master [ 0 ] === '' ) { $ this -> slotmap -> setSlots ( $ start , $ end , ( string ) $ connection ) ; } else { $ this -> slotmap -> setSlots ( $ start , $ end , "{$master[0]}:{$master[1]}" ) ; } } }
814	private function getNewLineIndex ( $ index , Tokens $ tokens ) { $ lineEnding = $ this -> whitespacesConfig -> getLineEnding ( ) ; for ( $ index , $ count = \ count ( $ tokens ) ; $ index < $ count ; ++ $ index ) { if ( false !== strstr ( $ tokens [ $ index ] -> getContent ( ) , $ lineEnding ) ) { return $ index ; } } return $ index ; }
1481	public function getDefaultCodec ( ) : Codec { return $ this -> factory -> createCodec ( $ this -> getContainer ( ) , $ this -> encodings -> find ( MediaTypeInterface :: JSON_API_MEDIA_TYPE ) ? : Encoding :: jsonApi ( ) , $ this -> decodings -> find ( MediaTypeInterface :: JSON_API_MEDIA_TYPE ) ) ; }
6608	public static function getAllProvider ( $ relatedRecords = [ ] , $ sort = [ ] , $ limit = null ) { $ query = self :: find ( ) -> with ( $ relatedRecords ) -> orderBy ( $ sort ) ; return self :: convertToProvider ( $ query , [ ] , $ limit ) ; }
417	public function getETags ( ) { if ( $ this -> headers -> has ( 'If-None-Match' ) ) { return preg_split ( '/[\s,]+/' , str_replace ( '-gzip' , '' , $ this -> headers -> get ( 'If-None-Match' ) ) , - 1 , PREG_SPLIT_NO_EMPTY ) ; } return [ ] ; }
5837	public function transform ( $ orig , $ transformation = null , $ overrides = array ( ) ) { return $ this -> transformer -> transform ( $ orig , $ transformation , $ overrides ) ; }
8481	public static function getNameById ( $ id , $ attributeName = 'name' ) { $ model = static :: loadModel ( $ id ) ; return empty ( $ model [ $ attributeName ] ) === false ? $ model [ $ attributeName ] : \ Yii :: t ( 'app' , 'Unknown' ) ; }
12753	public function sendRecoveryMessage ( User $ user , Token $ token ) { return $ this -> sendMessage ( $ user -> email , $ this -> recoverySubject , 'recovery' , [ 'user' => $ user , 'token' => $ token ] ) ; }
9867	private function writeMergeCells ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { if ( count ( $ pSheet -> getMergeCells ( ) ) > 0 ) { $ objWriter -> startElement ( 'mergeCells' ) ; foreach ( $ pSheet -> getMergeCells ( ) as $ mergeCell ) { $ objWriter -> startElement ( 'mergeCell' ) ; $ objWriter -> writeAttribute ( 'ref' , $ mergeCell ) ; $ objWriter -> endElement ( ) ; } $ objWriter -> endElement ( ) ; } }
5770	public function getLoggedInAdministrator ( ) : Administrator { if ( ! isset ( $ _SESSION [ SlimPostgres :: SESSION_KEY_ADMINISTRATOR_ID ] ) ) { throw new \ Exception ( "No one is logged in" ) ; } if ( null === $ administrator = ( AdministratorsEntityMapper :: getInstance ( ) ) -> getObjectById ( $ _SESSION [ SlimPostgres :: SESSION_KEY_ADMINISTRATOR_ID ] ) ) { unset ( $ _SESSION [ SlimPostgres :: SESSION_KEY_ADMINISTRATOR_ID ] ) ; throw new \ Exception ( "Invalid administrator id " . $ _SESSION [ SlimPostgres :: SESSION_KEY_ADMINISTRATOR_ID ] . " in session" ) ; } return $ administrator ; }
2282	protected static function ssl ( ) { $ request = System :: getContainer ( ) -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; if ( $ request === null ) { return false ; } return $ request -> isSecure ( ) ; }
9123	private function retrieveAndParseResponse ( $ requestType ) { $ this -> payload = new MemoryStream ( ) ; $ this -> headers = array ( ) ; $ delimiterFound = false ; $ tmp = "" ; $ numBytes = 1 ; $ start = time ( ) ; while ( true ) { if ( ! $ this -> checkConnection ( $ start ) ) { continue ; } $ c = $ this -> read ( $ numBytes ) ; if ( $ c == null ) { break ; } $ start = time ( ) ; $ tmp .= $ c ; if ( ! $ delimiterFound ) { $ this -> handleHeader ( $ delimiterFound , $ numBytes , $ tmp ) ; } if ( $ delimiterFound ) { if ( $ requestType == 'HEAD' ) { break ; } $ this -> payload -> write ( $ tmp ) ; $ tmp = "" ; if ( $ this -> checkContentLengthExceeded ( ) ) { break ; } } } $ size = $ this -> payload -> count ( ) ; if ( $ size == 0 ) { return ; } $ this -> payload -> reset ( ) ; $ mayCompressed = $ this -> payload -> read ( $ size ) ; switch ( $ this -> getContentEncoding ( ) ) { case 'gzip' : $ uncompressed = gzdecode ( strstr ( $ mayCompressed , "\x1f\x8b" ) ) ; $ this -> payload -> flush ( ) ; $ this -> payload -> write ( $ uncompressed ) ; break ; case 'deflate' : $ uncompressed = gzuncompress ( $ mayCompressed ) ; $ this -> payload -> flush ( ) ; $ this -> payload -> write ( $ uncompressed ) ; break ; default : break ; } $ this -> payload -> reset ( ) ; }
6824	protected function getTaxAccountNumber ( float $ rate , string $ origin ) { foreach ( $ this -> accounts as $ account ) { if ( $ account -> getType ( ) !== AccountingTypes :: TYPE_TAX ) { continue ; } if ( 0 !== bccomp ( $ account -> getTax ( ) -> getRate ( ) , $ rate , 5 ) ) { continue ; } return $ account -> getNumber ( ) ; } throw new LogicException ( sprintf ( "No tax account number configured for tax rate '%s' (%s)" , $ rate , $ origin ) ) ; }
3334	private function __initRequest ( $ type , $ data = null ) { $ url = sprintf ( 'https://%s/%s/' , $ this -> host , $ type ) ; if ( is_array ( $ data ) ) { $ url = sprintf ( '%s?%s' , $ url , http_build_query ( $ data ) ) ; } $ ch = curl_init ( $ url ) ; return $ ch ; }
2463	public static function findSentByPid ( $ intPid , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = array ( "$t.pid=?" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ arrColumns [ ] = "$t.sent=1" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.date DESC" ; } return static :: findBy ( $ arrColumns , $ intPid , $ arrOptions ) ; }
7752	protected function completeMetadata ( ClassMetadata $ class ) { $ className = $ class -> getName ( ) ; if ( null === $ class -> getIri ( ) ) { $ class -> setIri ( $ this -> namingStrategy -> classIriFragment ( $ className ) ) ; } if ( null === $ class -> getExposeAs ( ) ) { $ class -> setExposeAs ( $ this -> namingStrategy -> classShortName ( $ className ) ) ; } if ( null === $ class -> getTitle ( ) ) { $ class -> setTitle ( $ this -> namingStrategy -> classShortName ( $ className ) ) ; } foreach ( $ class -> getProperties ( ) as $ property ) { $ propertyName = $ property -> getName ( ) ; if ( null === $ property -> getIri ( ) ) { $ property -> setIri ( $ this -> namingStrategy -> propertyIriFragment ( $ className , $ propertyName ) ) ; } if ( null === $ property -> getExposeAs ( ) ) { $ property -> setExposeAs ( $ this -> namingStrategy -> propertyShortName ( $ className , $ propertyName ) ) ; } if ( null === $ property -> getTitle ( ) ) { $ property -> setTitle ( $ this -> namingStrategy -> propertyShortName ( $ className , $ propertyName ) ) ; } } }
4246	private function logRequest ( ) { $ this -> logRequestHeaders ( ) ; if ( $ this -> debug -> getCfg ( 'logEnvInfo.cookies' ) ) { $ cookieVals = $ _COOKIE ; \ ksort ( $ cookieVals , SORT_NATURAL ) ; $ this -> debug -> log ( '$_COOKIE' , $ cookieVals ) ; } $ noBody = ! isset ( $ _SERVER [ 'REQUEST_METHOD' ] ) || \ in_array ( $ _SERVER [ 'REQUEST_METHOD' ] , array ( 'CONNECT' , 'GET' , 'HEAD' , 'OPTIONS' , 'TRACE' ) ) ; if ( $ this -> debug -> getCfg ( 'logEnvInfo.post' ) && ! $ noBody ) { if ( $ _POST ) { $ this -> debug -> log ( '$_POST' , $ _POST ) ; } else { $ input = \ file_get_contents ( 'php://input' ) ; if ( $ input ) { $ this -> debug -> log ( 'php://input' , $ input ) ; } elseif ( isset ( $ _SERVER [ 'REQUEST_METHOD' ] ) && empty ( $ _FILES ) ) { $ this -> debug -> warn ( $ _SERVER [ 'REQUEST_METHOD' ] . ' request with no body' ) ; } } if ( ! empty ( $ _FILES ) ) { $ this -> debug -> log ( '$_FILES' , $ _FILES ) ; } } }
5242	public function getAutoloads ( ) : array { if ( empty ( $ this -> autoloads ) ) { $ this -> autoloads = $ this -> configCollection -> getAutoloads ( ) ; } return $ this -> autoloads ; }
8741	protected function i18nDeleteQuery ( $ withGlobalScopes = true ) { $ subQuery = $ withGlobalScopes ? $ this -> toBase ( ) : $ this -> getQuery ( ) ; $ subQuery -> select ( $ this -> model -> getQualifiedKeyName ( ) ) ; return $ this -> i18nQuery ( ) -> whereIn ( $ this -> model -> getForeignKey ( ) , $ subQuery -> pluck ( $ this -> model -> getKeyName ( ) ) ) ; }
1879	public function protect ( ) { @ trigger_error ( 'Using DC_Folder::protect() has been deprecated and will no longer work in Contao 5.0. Use Contao\Folder::protect() and Contao\Folder::unprotect() instead.' , E_USER_DEPRECATED ) ; if ( ! is_dir ( $ this -> strRootDir . '/' . $ this -> intId ) ) { throw new InternalServerErrorException ( 'Resource "' . $ this -> intId . '" is not a directory.' ) ; } if ( file_exists ( $ this -> strRootDir . '/' . $ this -> intId . '/.public' ) ) { $ objFolder = new Folder ( $ this -> intId ) ; $ objFolder -> protect ( ) ; $ this -> import ( Automator :: class , 'Automator' ) ; $ this -> Automator -> generateSymlinks ( ) ; $ this -> log ( 'Folder "' . $ this -> intId . '" has been protected' , __METHOD__ , TL_FILES ) ; } else { $ objFolder = new Folder ( $ this -> intId ) ; $ objFolder -> unprotect ( ) ; $ this -> import ( Automator :: class , 'Automator' ) ; $ this -> Automator -> generateSymlinks ( ) ; $ this -> log ( 'The protection from folder "' . $ this -> intId . '" has been removed' , __METHOD__ , TL_FILES ) ; } $ this -> redirect ( $ this -> getReferer ( ) ) ; }
6932	private function isShipmentAmountInvoiced ( Invoice \ InvoiceInterface $ invoice ) { $ sale = $ invoice -> getSale ( ) ; foreach ( $ sale -> getInvoices ( ) as $ i ) { if ( $ i === $ invoice ) { continue ; } if ( $ i -> hasLineByType ( Document \ DocumentLineTypes :: TYPE_SHIPMENT ) ) { return true ; } } return false ; }
10431	protected function getShopId ( ContainerBuilder $ container , $ shop , $ name ) { $ shops = $ container -> getParameter ( 'ongr_connections.shops' ) ; if ( ! isset ( $ shops [ $ shop ] ) ) { throw new \ InvalidArgumentException ( 'Non existing shop provided for pipeline ' . $ name ) ; } return $ shops [ $ shop ] [ 'shop_id' ] ; }
9110	protected function attainPathName ( ) { $ path = false ; $ config = $ this -> getConfig ( ) ; if ( isset ( $ config [ 'theme_locator' ] [ 'themes_default_path' ] ) ) { $ path = $ config [ 'theme_locator' ] [ 'themes_default_path' ] ; } $ themeName = $ this -> attainThemeName ( ) ; if ( isset ( $ config [ 'themes' ] ) && is_array ( $ config [ 'themes' ] ) && isset ( $ config [ 'themes' ] [ $ themeName ] ) ) { if ( array_key_exists ( 'dir_path' , $ config [ 'themes' ] [ $ themeName ] ) ) { $ path = $ config [ 'themes' ] [ $ themeName ] [ 'dir_path' ] ; } } return $ path ; }
9687	public function jsonSerialize ( ) { return array_map ( function ( $ value ) { if ( $ value instanceof JsonSerializable ) { return $ value -> jsonSerialize ( ) ; } elseif ( $ value instanceof JsonableInterface ) { return json_decode ( $ value -> toJson ( ) , true ) ; } elseif ( $ value instanceof ArrayableInterface ) { return $ value -> toArray ( ) ; } else { return $ value ; } } , $ this -> items ) ; }
1175	protected function jsConvertRules ( $ attribute , $ rules , $ includeRemote ) { $ jsRules = [ ] ; foreach ( $ rules as $ rawRule ) { list ( $ rule , $ parameters ) = $ this -> validator -> parseRule ( $ rawRule ) ; list ( $ jsAttribute , $ jsRule , $ jsParams ) = $ this -> rules -> getRule ( $ attribute , $ rule , $ parameters , $ rawRule ) ; if ( $ this -> isValidatable ( $ jsRule , $ includeRemote ) ) { $ jsRules [ $ jsAttribute ] [ $ jsRule ] [ ] = [ $ rule , $ jsParams , $ this -> messages -> getMessage ( $ attribute , $ rule , $ parameters ) , $ this -> validator -> isImplicit ( $ rule ) , ] ; } } return $ jsRules ; }
1817	public function deleteElement ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { $ objElement = $ this -> Database -> prepare ( "SELECT id FROM tl_content WHERE cteAlias=? AND type='alias'" ) -> limit ( 1 ) -> execute ( $ row [ 'id' ] ) ; return $ objElement -> numRows ? Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' : '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' ; }
12133	public function createService ( ServiceLocatorInterface $ serviceLocator ) { $ options = $ serviceLocator -> get ( 'HtSettingsModule\Options\ModuleOptions' ) ; $ settingsService = new SettingsService ( $ options , $ serviceLocator -> get ( 'HtSettingsModule_SettingsMapper' ) , $ serviceLocator -> get ( 'HtSettingsModule\Service\NamespaceHydratorProvider' ) ) ; if ( $ options -> getCacheOptions ( ) -> isEnabled ( ) ) { $ settingsService -> setCacheManager ( $ serviceLocator -> get ( 'HtSettingsModule\Service\CacheManager' ) ) ; } return $ settingsService ; }
1129	public function getLeftSibling ( ) { return $ this -> siblings ( ) -> where ( $ this -> getLeftColumnName ( ) , '<' , $ this -> getLeft ( ) ) -> orderBy ( $ this -> getOrderColumnName ( ) , 'desc' ) -> get ( ) -> last ( ) ; }
5738	public function setDefaultSuffix ( $ defaultSuffix ) { $ this -> defaultSuffix = ( string ) $ defaultSuffix ; $ this -> defaultSuffix = ltrim ( $ this -> defaultSuffix , '.' ) ; return $ this ; }
12922	public function getForeignDataItems ( ) { if ( ! isset ( $ this -> _foreignDataItems ) ) { $ this -> _foreignDataItems = [ ] ; $ this -> trigger ( self :: EVENT_LOAD_FOREIGN_DATA_ITEMS ) ; } return $ this -> _foreignDataItems ; }
2138	public function onKernelRequest ( GetResponseEvent $ event ) : void { $ request = $ event -> getRequest ( ) ; if ( \ in_array ( $ request -> getClientIp ( ) , [ '127.0.0.1' , 'fe80::1' , '::1' ] , true ) ) { return ; } if ( '' === $ request -> getBasePath ( ) ) { return ; } throw new InsecureInstallationException ( 'Your installation is not secure. Please set the document root to the /web subfolder.' ) ; }
10962	private function isInvalidLogDate ( $ file ) { $ pattern = '/laravel-(\d){4}-(\d){2}-(\d){2}.log/' ; if ( ( bool ) preg_match ( $ pattern , $ file , $ matches ) === false ) { return true ; } return false ; }
1542	protected function query ( $ query ) { return new CursorBuilder ( $ query , $ this -> column , $ this -> identifier , $ this -> descending ) ; }
3198	protected function checkTimestampCoherence ( $ points , $ timestamp ) { foreach ( $ points as $ point ) { if ( $ point -> getTimestamp ( ) > $ timestamp ) { throw new InconsistentRangeException ( 'A new TimePoint cannot be set before an existing one!' ) ; } } }
8273	public function validateUserData ( $ userData ) { $ this -> assertRequired ( $ userData , "pwhash" ) ; $ this -> assertString ( $ userData , "pwhash" ) ; $ this -> assertString ( $ userData , "email" ) ; $ this -> assertArray ( $ userData , "attributes" ) ; $ this -> assertString ( $ userData , "encoder" ) ; $ this -> assertBool ( $ userData , "pwreset" ) ; $ this -> assertArrayOfStrings ( $ userData , "groups" ) ; $ this -> assertString ( $ userData , "displayName" ) ; }
2079	public function purgeInternalCache ( ) { $ container = System :: getContainer ( ) ; $ clearer = $ container -> get ( 'contao.cache.clear_internal' ) ; $ clearer -> clear ( $ container -> getParameter ( 'kernel.cache_dir' ) ) ; $ this -> log ( 'Purged the internal cache' , __METHOD__ , TL_CRON ) ; }
7395	protected function _getByName ( $ propName ) { if ( array_key_exists ( $ propName , $ this -> _map ) ) { $ propName = $ this -> _map [ $ propName ] ; } if ( $ this -> { $ propName } instanceof AtomicInterface ) { return $ this -> { $ propName } -> get ( ) ; } $ getter = '_get_' . $ propName ; if ( method_exists ( $ this -> _calledClass , $ getter ) ) { return $ this -> { $ getter } ( ) ; } return $ this -> { $ propName } ; }
12317	public function load ( $ name ) { foreach ( $ this -> sourceDirs as $ dir ) { if ( 0 === strpos ( $ name , DIRECTORY_SEPARATOR ) ) { $ yamlFile = $ name ; } else { $ yamlFile = $ dir . '/' . $ name ; } if ( false === strstr ( $ yamlFile , self :: EXT_YML ) ) { $ yamlFile .= self :: EXT_YML ; } if ( is_file ( $ yamlFile ) ) { return new ArrayCollection ( Yaml :: parse ( $ yamlFile ) ) ; } } throw new \ Exception ( sprintf ( 'No Yaml file found for {%s}' , $ name ) ) ; }
1314	public function url ( $ path , array $ parameters ) { $ this -> resetLastResponse ( ) ; $ this -> response -> setApiPath ( $ path ) ; $ query = http_build_query ( $ parameters ) ; return sprintf ( '%s/%s?%s' , self :: API_HOST , $ path , $ query ) ; }
8555	public function setAdjustmentEventList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'AdjustmentEventList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
10794	public function passwordRecovery ( array $ data ) { $ main = $ this -> getServiceLocator ( ) -> get ( 'neobazaar.service.main' ) ; $ userRepository = $ main -> getUserEntityRepository ( ) ; $ form = $ this -> getServiceLocator ( ) -> get ( 'user.form.passwordrecovery' ) ; $ form -> setData ( $ data ) ; if ( ! $ form -> isValid ( ) ) { throw new \ Exception ( serialize ( $ form -> getMessages ( ) ) ) ; } $ data = $ form -> getData ( ) ; $ email = isset ( $ data [ 'email' ] ) ? $ data [ 'email' ] : null ; $ user = $ userRepository -> findOneBy ( array ( 'email' => $ email ) ) ; if ( null === $ user ) { throw new \ Exception ( 'No user found' ) ; } $ userModel = $ this -> getServiceLocator ( ) -> get ( 'user.model.user' ) ; $ userModel -> init ( $ user , $ this -> getServiceLocator ( ) ) ; $ hash = $ userModel -> hashId . sha1 ( $ user -> getPassword ( ) ) ; $ url = $ this -> getServiceLocator ( ) -> get ( 'ControllerPluginManager' ) -> get ( 'Url' ) ; $ event = new PasswordRecoveryEvent ( __FUNCTION__ , null , array ( 'user' => $ user , 'form' => $ form , 'hash' => $ hash , 'email' => $ email , 'siteurl' => $ url -> fromRoute ( 'home' , array ( ) , array ( 'force_canonical' => true ) ) ) ) ; $ this -> getEventManager ( ) -> trigger ( __FUNCTION__ . '.pre' , $ this , $ event ) ; $ this -> getEventManager ( ) -> trigger ( __FUNCTION__ . '.post' , $ this , $ event ) ; return $ user ; }
4399	protected function saveRepayData ( \ Omnipay \ Common \ Message \ ResponseInterface $ response , $ customerId ) { $ data = [ ] ; if ( method_exists ( $ response , 'getCardReference' ) ) { $ data [ 'token' ] = $ response -> getCardReference ( ) ; } if ( method_exists ( $ response , 'getExpiryMonth' ) ) { $ data [ 'month' ] = $ response -> getExpiryMonth ( ) ; } if ( method_exists ( $ response , 'getExpiryYear' ) ) { $ data [ 'year' ] = $ response -> getExpiryYear ( ) ; } if ( ! empty ( $ data ) ) { $ this -> setCustomerData ( $ customerId , 'repay' , $ data ) ; } }
4810	private function is_scheduled ( $ name ) { $ crons = _get_cron_array ( ) ; if ( empty ( $ crons ) ) { return false ; } foreach ( $ crons as $ cron ) { if ( isset ( $ cron [ $ name ] ) ) { return true ; } } return false ; }
12773	public function __async_authorize ( $ hashEmail = null , $ hashPassword = null ) { $ result = array ( 'status' => '0' ) ; if ( ! isset ( $ hashEmail ) ) { if ( isset ( $ _POST ) && isset ( $ _POST [ $ this -> dbHashEmailField ] ) ) { $ hashEmail = $ _POST [ $ this -> dbHashEmailField ] ; } elseif ( isset ( $ _GET ) && isset ( $ _GET [ $ this -> dbHashEmailField ] ) ) { $ hashEmail = $ _GET [ $ this -> dbHashEmailField ] ; } else { $ result [ 'email_error' ] = "\n" . '[' . $ this -> dbHashEmailField . '] field is not passed' ; } } if ( ! isset ( $ hashPassword ) ) { if ( isset ( $ _POST ) && isset ( $ _POST [ $ this -> dbHashPasswordField ] ) ) { $ hashPassword = $ _POST [ $ this -> dbHashPasswordField ] ; } elseif ( isset ( $ _GET ) && isset ( $ _GET [ $ this -> dbHashPasswordField ] ) ) { $ hashPassword = $ _GET [ $ this -> dbHashPasswordField ] ; } else { $ result [ 'email_error' ] = "\n" . '[' . $ this -> dbHashPasswordField . '] field is not passed' ; } } if ( isset ( $ hashEmail ) && isset ( $ hashPassword ) ) { $ hashEmail = $ this -> hash ( $ hashEmail ) ; $ hashPassword = $ this -> hash ( $ hashPassword ) ; $ authorizeResult = $ this -> authorizeWithEmail ( $ hashEmail , $ hashPassword ) ; if ( $ authorizeResult -> code == EmailStatus :: SUCCESS_EMAIL_AUTHORIZE ) { $ result [ 'status' ] = '1' ; } $ result [ self :: RESPONSE_STATUS_TEXTFIELD ] = $ authorizeResult -> text ; $ result [ self :: RESPONSE_STATUS_FIELD ] = $ authorizeResult -> code ; $ result = array_merge ( $ result , $ authorizeResult -> response ) ; } return $ result ; }
11274	public function install ( ) : Migrate { Whois :: print ( $ this -> getNotify ( ) ) ; $ this -> exists ( ) || $ this -> migrationRepository -> createRepository ( ) ; return $ this ; }
11044	function masktree_merge ( $ masktree1 , $ masktree2 , $ maskname ) { $ merged = array_merge ( $ masktree1 , $ masktree2 ) ; if ( count ( $ merged ) < count ( $ masktree1 ) + count ( $ masktree2 ) ) { $ keys1 = array_keys ( $ masktree1 ) ; $ keys2 = array_keys ( $ masktree2 ) ; $ keysm = array_merge ( $ keys1 , $ keys2 ) ; $ keysc = array_count_values ( $ keysm ) ; foreach ( $ keysc as $ keyn => $ keyc ) { if ( $ keyc > 1 ) { if ( $ keyn == '0reduce' ) { $ this -> error ( 6 , 49 , 'reduce element already used' ) ; } elseif ( $ keyn != '0include' ) { $ this -> error ( 16 , 60 , "template $keyn already defined in <b>$maskname</b>" ) ; } } } } return $ merged ; }
1515	public function delete ( StoreInterface $ store , DeleteResource $ request ) { $ result = $ this -> transaction ( function ( ) use ( $ store , $ request ) { return $ this -> doDelete ( $ store , $ request ) ; } ) ; if ( $ this -> isResponse ( $ result ) ) { return $ result ; } return $ this -> reply ( ) -> deleted ( $ result ) ; }
11292	protected function _getAttributeDataWhenUnset ( $ attributeName , $ query = false , $ loadMap = false , $ record = false ) { if ( $ attributeName != $ this -> getPrimaryKey ( ) ) { if ( $ this -> _isRelation ( $ attributeName ) && ! isset ( $ this -> model_dynamicOff ) ) { $ this -> $ attributeName = $ this -> _getRelation ( $ attributeName , $ query , $ loadMap , $ record ) ; } else { $ this -> $ attributeName = $ this -> _fetchData ( $ attributeName ) ; } } else { $ this -> $ attributeName = null ; } $ this -> beforeGet ( $ attributeName ) ; $ returnValue = $ this -> model_data [ $ attributeName ] ; $ this -> afterGet ( $ attributeName , $ returnValue ) ; return $ returnValue ; }
5971	public function categories ( ) { if ( ! $ this -> categories instanceof CategoriesController ) { $ this -> categories = new CategoriesController ( $ this -> getClient ( ) , $ this -> cachePolicy , $ this -> cache ) ; $ this -> categories -> setLogger ( $ this -> logger ) ; } return $ this -> categories ; }
3419	protected static function instantiateServiceContainer ( ) { $ container = Container :: getInstance ( ) ; if ( ! $ container ) { $ container = new Container ( ) ; Container :: setInstance ( $ container ) ; } return $ container ; }
2886	public function onActionPreDispatch ( Varien_Event_Observer $ observer ) { if ( ! $ this -> canCollect ( ) ) { return ; } $ action = $ observer -> getData ( 'controller_action' ) ; $ this -> getRequestInfo ( ) -> initController ( $ action ) ; }
5010	public function getPermissions ( ) { if ( ! $ this -> permissions ) { $ type = property_exists ( $ this , 'permissionsType' ) ? $ this -> permissionsType : str_replace ( '\\Entity\\' , '/' , static :: class ) ; $ permissions = new Permissions ( $ type ) ; if ( method_exists ( $ this , 'setupPermissions' ) ) { $ this -> setupPermissions ( $ permissions ) ; } $ this -> setPermissions ( $ permissions ) ; } return $ this -> permissions ; }
10267	public function setEndColor ( Color $ pValue ) { $ color = $ pValue -> getIsSupervisor ( ) ? $ pValue -> getSharedComponent ( ) : $ pValue ; if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getEndColor ( ) -> getStyleArray ( [ 'argb' => $ color -> getARGB ( ) ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> endColor = $ color ; } return $ this ; }
3357	public function getImgTag ( $ postfix = null , $ attributes = array ( ) ) { $ to_compile = array ( ) ; foreach ( $ attributes as $ key => $ value ) { $ to_compile [ ] = sprintf ( '%s="%s"' , $ key , $ value ) ; } return sprintf ( '<img src="%s" %s />' , $ this -> getUrl ( ) , join ( ' ' , $ to_compile ) ) ; }
10731	public function getMinute ( ) { if ( $ this -> value !== null ) { preg_match ( '/^(?P<year>[0-9]{4,4})-(?P<month>[0-9]{2,2})-(?P<day>[0-9]{2,2}) (?P<hour>[0-9]{2,2}):(?P<minute>[0-9]{2,2}):(?P<second>[0-9]{2,2})$/ui' , $ this -> value , $ m ) ; return ( int ) $ m [ 'minute' ] ; } }
380	public function renderCallStack ( $ exception ) { $ out = '<ul>' ; $ out .= $ this -> renderCallStackItem ( $ exception -> getFile ( ) , $ exception -> getLine ( ) , null , null , [ ] , 1 ) ; for ( $ i = 0 , $ trace = $ exception -> getTrace ( ) , $ length = count ( $ trace ) ; $ i < $ length ; ++ $ i ) { $ file = ! empty ( $ trace [ $ i ] [ 'file' ] ) ? $ trace [ $ i ] [ 'file' ] : null ; $ line = ! empty ( $ trace [ $ i ] [ 'line' ] ) ? $ trace [ $ i ] [ 'line' ] : null ; $ class = ! empty ( $ trace [ $ i ] [ 'class' ] ) ? $ trace [ $ i ] [ 'class' ] : null ; $ function = null ; if ( ! empty ( $ trace [ $ i ] [ 'function' ] ) && $ trace [ $ i ] [ 'function' ] !== 'unknown' ) { $ function = $ trace [ $ i ] [ 'function' ] ; } $ args = ! empty ( $ trace [ $ i ] [ 'args' ] ) ? $ trace [ $ i ] [ 'args' ] : [ ] ; $ out .= $ this -> renderCallStackItem ( $ file , $ line , $ class , $ function , $ args , $ i + 2 ) ; } $ out .= '</ul>' ; return $ out ; }
8434	private function write ( array $ mapping , string $ mappingName , string $ name , array $ up = [ ] , array $ down = [ ] , array $ import = [ ] ) { $ path = rtrim ( $ mapping [ 'config' ] [ 'migrations' ] [ 'path' ] , DIRECTORY_SEPARATOR ) . DIRECTORY_SEPARATOR ; $ path .= $ name . DIRECTORY_SEPARATOR ; if ( file_exists ( $ path . $ name . '.php' ) === true ) { echo 'A migration with this name already exists. Do you want to overwrite it ? [y/n] : ' ; if ( fgetc ( STDIN ) != 'y' ) { return false ; } } if ( is_dir ( $ path ) === false ) { if ( mkdir ( $ path ) === false ) { throw new FileNotWritable ( 'can\'t mkdir "' . $ path . '"' ) ; } } $ path .= $ name . '.php' ; $ file = fopen ( $ path , 'w+' ) ; if ( $ file === false ) { throw new FileNotWritable ( 'can\'t open "' . $ path . '" with write permission' ) ; } $ content = "<?php\n\nnamespace " . ltrim ( rtrim ( $ mapping [ 'config' ] [ 'migrations' ] [ 'namespace' ] , '\\' ) , '\\' ) . '\\' . $ name . ";\n\nuse " . ltrim ( rtrim ( $ mapping [ 'config' ] [ 'provider' ] , '\\' ) , '\\' ) . '\\Migration;' . PHP_EOL ; if ( count ( $ import ) >= 1 ) { $ content .= 'use ' . ltrim ( rtrim ( $ mapping [ 'config' ] [ 'provider' ] , '\\' ) , '\\' ) . '\\Mutation\\{' ; $ content .= implode ( ', ' , $ import ) . "};\n" ; } $ up = implode ( '' , array_map ( function ( string $ a ) { return ' ' . $ a . '->execute();' . PHP_EOL ; } , $ up ) ) ; $ down = implode ( '' , array_map ( function ( string $ a ) { return ' ' . $ a . '->execute();' . PHP_EOL ; } , $ down ) ) ; var_dump ( $ up ) ; $ content .= "\nclass " . $ name . " extends Migration\n{\n" ; $ content .= ' const NAME = \'' . $ name . "';\n\n" ; $ content .= " public function getMappingName() : string\n {\n return '" . $ mappingName . "';\n }\n\n" ; $ content .= " public function up()\n {\n" . $ up . " }\n\n" ; $ content .= " public function down()\n {\n" . $ down . " }\n" ; $ content .= "}" ; if ( fwrite ( $ file , $ content ) === false ) { throw new FileNotWritable ( 'can\'t write in "' . $ path . '"' ) ; } fclose ( $ file ) ; return true ; }
8891	public function singleton ( $ key , $ value ) { if ( is_callable ( $ value ) ) { $ this -> registerFactory ( $ key , $ value ) ; } else { $ this -> sm -> setService ( $ key , $ value ) ; } }
5400	protected function truncateHost ( $ host ) { $ tlds = SimpleUrl :: getAllTopLevelDomains ( ) ; if ( preg_match ( '/[a-z\-]+\.(' . $ tlds . ')$/i' , $ host , $ matches ) ) { return $ matches [ 0 ] ; } elseif ( preg_match ( '/[a-z\-]+\.[a-z\-]+\.[a-z\-]+$/i' , $ host , $ matches ) ) { return $ matches [ 0 ] ; } return false ; }
10245	function fromXML ( $ xmlElement ) { $ this -> contact = new ReportContact ( ) ; $ this -> contact -> fromXML ( $ xmlElement -> contact ) ; if ( isset ( $ xmlElement -> mailing_id ) ) $ this -> mailingId = $ xmlElement -> mailing_id ; if ( isset ( $ xmlElement -> timestamp ) ) $ this -> timestamp = $ xmlElement -> timestamp ; if ( isset ( $ xmlElement -> last_type ) ) $ this -> lastType = $ xmlElement -> last_type ; if ( isset ( $ xmlElement -> count ) ) $ this -> count = $ xmlElement -> count ; if ( isset ( $ xmlElement -> count_hard ) ) $ this -> countHard = $ xmlElement -> count_hard ; if ( isset ( $ xmlElement -> count_soft ) ) $ this -> countSoft = $ xmlElement -> count_soft ; }
985	public function getCharge ( ) { if ( ! $ this -> chargeId ) { throw new Exception ( 'Can not get charge information without charge ID.' ) ; } return $ this -> api -> rest ( 'GET' , "/admin/{$this->plan->typeAsString(true)}/{$this->chargeId}.json" ) -> body -> { $ this -> plan -> typeAsString ( ) } ; }
10946	public function post ( $ name = null , $ defaultValue = null ) { if ( $ name === null ) { return $ this -> getBodyParams ( ) ; } else { return $ this -> getBodyParam ( $ name , $ defaultValue ) ; } }
65	public function normalizePath ( $ path ) { $ parts = array ( ) ; $ path = strtr ( $ path , '\\' , '/' ) ; $ prefix = '' ; $ absolute = false ; if ( preg_match ( '{^( [0-9a-z]{2,}+: (?: // (?: [a-z]: )? )? | [a-z]: )}ix' , $ path , $ match ) ) { $ prefix = $ match [ 1 ] ; $ path = substr ( $ path , strlen ( $ prefix ) ) ; } if ( substr ( $ path , 0 , 1 ) === '/' ) { $ absolute = true ; $ path = substr ( $ path , 1 ) ; } $ up = false ; foreach ( explode ( '/' , $ path ) as $ chunk ) { if ( '..' === $ chunk && ( $ absolute || $ up ) ) { array_pop ( $ parts ) ; $ up = ! ( empty ( $ parts ) || '..' === end ( $ parts ) ) ; } elseif ( '.' !== $ chunk && '' !== $ chunk ) { $ parts [ ] = $ chunk ; $ up = '..' !== $ chunk ; } } return $ prefix . ( $ absolute ? '/' : '' ) . implode ( '/' , $ parts ) ; }
4141	protected function getSignatureBaseString ( ) { $ method = strtoupper ( $ this -> method ) ; $ url = rawurlencode ( $ this -> getUrl ( ) ) ; return $ method . '&' . $ url . '&' . $ this -> getRequestString ( ) ; }
10883	public function reportException ( \ Exception $ ex ) { $ report = new ErrorStreamReport ( ) ; $ report -> error_group = $ ex -> getMessage ( ) . ':' . $ ex -> getLine ( ) ; $ report -> line_number = $ ex -> getLine ( ) ; $ report -> file_name = $ ex -> getFile ( ) ; $ report -> message = $ ex -> getMessage ( ) ; $ report -> stack_trace = $ ex -> getTraceAsString ( ) ; $ report -> severity = 3 ; return $ this -> report ( $ report ) ; }
11748	public function page ( ) { if ( is_null ( $ this -> page ) ) { $ this -> page = new Page ( $ this -> accessToken ) ; } return $ this -> page ; }
273	public function asXml ( $ data ) { $ response = Yii :: $ app -> getResponse ( ) ; $ response -> format = Response :: FORMAT_XML ; $ response -> data = $ data ; return $ response ; }
8935	public function add ( $ name , $ template ) { if ( array_key_exists ( $ name , $ this -> templates ) ) { throw new \ InvalidArgumentException ( 'Template already exists.' ) ; } $ this -> templates [ $ name ] = $ template ; }
4321	public static function arrayPathGet ( $ array , $ path ) { if ( ! \ is_array ( $ path ) ) { $ path = \ array_filter ( \ preg_split ( '#[\./]#' , $ path ) , 'strlen' ) ; } $ path = \ array_reverse ( $ path ) ; while ( $ path ) { $ key = \ array_pop ( $ path ) ; $ arrayAccess = \ is_array ( $ array ) || $ array instanceof \ ArrayAccess ; if ( ! $ arrayAccess ) { return null ; } elseif ( isset ( $ array [ $ key ] ) ) { $ array = $ array [ $ key ] ; } elseif ( $ key == '__count__' ) { return \ count ( $ array ) ; } elseif ( $ key == '__end__' ) { \ end ( $ array ) ; $ path [ ] = \ key ( $ array ) ; } elseif ( $ key == '__reset__' ) { \ reset ( $ array ) ; $ path [ ] = \ key ( $ array ) ; } else { return null ; } } return $ array ; }
4260	public function hasSubscribers ( $ eventName = null ) { if ( $ eventName !== null ) { return ! empty ( $ this -> subscribers [ $ eventName ] ) ; } foreach ( $ this -> subscribers as $ subscribers ) { if ( $ subscribers ) { return true ; } } return false ; }
1202	public function buildItem ( ItemInterface $ item , array $ options ) { $ item -> setUri ( $ options [ 'uri' ] ) -> setLabel ( $ options [ 'label' ] ) -> setAttributes ( $ options [ 'attributes' ] ) -> setLinkAttributes ( $ options [ 'linkAttributes' ] ) -> setChildrenAttributes ( $ options [ 'childrenAttributes' ] ) -> setLabelAttributes ( $ options [ 'labelAttributes' ] ) -> setCurrent ( $ options [ 'current' ] ) -> setDisplay ( $ options [ 'display' ] ) -> setDisplayChildren ( $ options [ 'displayChildren' ] ) ; $ this -> buildExtras ( $ item , $ options ) ; }
12514	public static function create ( $ path = '' , $ mode = 0777 ) { $ path = Path :: clean ( $ path ) ; $ fs = new Filesystem ( ) ; try { $ fs -> mkdir ( $ path ) ; } catch ( IOExceptionInterface $ e ) { throw new Exception ( Helper :: getTranslation ( 'FAILED_CREATING' ) . ' ' . $ e -> getPath ( ) ) ; } return true ; }
9558	public function getUsage ( $ showRequiredFirst = true , $ customBinary = null , $ customScript = null ) { $ fullUsage = '' ; if ( $ customBinary == null ) { $ fullUsage = 'php ' ; } else { $ fullUsage = $ customBinary . ' ' ; } if ( $ customScript == null ) { $ fullUsage .= basename ( $ _SERVER [ 'SCRIPT_NAME' ] ) . ' ' ; } else { $ fullUsage .= $ customScript . ' ' ; } foreach ( $ this -> prefixes as $ prefix => $ parameters ) { if ( $ showRequiredFirst ) { usort ( $ parameters , function ( $ p1 , $ p2 ) { if ( $ p1 -> required && $ p2 -> required ) { return 0 ; } if ( $ p1 -> required && ! $ p2 -> required ) { return - 1 ; } if ( $ p2 -> required && ! $ p1 -> required ) { return 1 ; } } ) ; } foreach ( $ parameters as $ parameter ) { if ( $ parameter -> parent == null ) { $ fullUsage .= $ parameter -> getUsage ( ) . ' ' ; } } } return $ fullUsage ; }
11302	public function loadAll ( ) { $ this -> data -> id = $ this -> id ; foreach ( $ this -> model_attributes as $ key => $ value ) { $ temp = $ this -> $ key ; } }
3159	public function storeVariables ( QtiRunnerServiceContext $ context , $ itemUri , $ metaVariables , $ itemId = null ) { $ sessionId = $ context -> getTestSession ( ) -> getSessionId ( ) ; $ deliveryServerService = $ this -> getServiceManager ( ) -> get ( DeliveryServerService :: SERVICE_ID ) ; $ resultStore = $ deliveryServerService -> getResultStoreWrapper ( $ sessionId ) ; $ testUri = $ context -> getTestDefinitionUri ( ) ; if ( ! is_null ( $ itemUri ) ) { $ resultStore -> storeItemVariables ( $ testUri , $ itemUri , $ metaVariables , $ this -> getTransmissionId ( $ context , $ itemId ) ) ; } else { $ resultStore -> storeTestVariables ( $ testUri , $ metaVariables , $ sessionId ) ; } return true ; }
9381	public function set ( $ id , $ concrete , $ share = false ) { return $ this -> add ( $ id , $ concrete , $ share ) ; }
9232	public function actionView ( $ id , $ format = false ) { $ model = $ this -> findModel ( $ id ) ; if ( $ format == 'json' ) { return \ yii \ helpers \ Json :: encode ( $ model ) ; } else { return $ this -> render ( 'view' , [ 'model' => $ model , ] ) ; } }
7030	public function toArray ( ) { return [ 'o_msg' => $ this -> overflowMessage , 'min_qty' => $ this -> minimumQuantity , 'min_msg' => $ this -> minimumMessage , 'max_qty' => INF === $ this -> maximumQuantity ? 'INF' : $ this -> maximumQuantity , 'max_msg' => $ this -> maximumMessage , 'a_qty' => INF === $ this -> availableQuantity ? 'INF' : $ this -> availableQuantity , 'a_msg' => $ this -> availableMessage , 'r_qty' => $ this -> resupplyQuantity , 'r_msg' => $ this -> resupplyMessage , ] ; }
1609	public function delete ( $ id ) { $ redirect = RedirectRecord :: findOne ( compact ( 'id' ) ) -> delete ( ) ; if ( $ redirect === false ) return 'Unable find redirect with ID: ' . $ id ; return false ; }
5817	public function getFusionTagTypes ( ) { $ types = array ( ) ; $ configuration = Config :: inst ( ) ; $ exclusions = $ configuration -> get ( 'FusionService' , 'tag_type_exclusions' ) ; $ classes = ClassInfo :: subclassesFor ( 'DataObject' ) ; unset ( $ classes [ 'FusionTag' ] ) ; foreach ( $ classes as $ class ) { if ( ( strpos ( strrev ( $ class ) , strrev ( 'Tag' ) ) === 0 ) && ! in_array ( $ class , $ exclusions ) && ! ClassInfo :: classImplements ( $ class , 'TestOnly' ) ) { $ types [ $ class ] = 'Title' ; } } foreach ( $ configuration -> get ( 'FusionService' , 'custom_tag_types' ) as $ type => $ field ) { if ( in_array ( $ type , $ classes ) && ! in_array ( $ type , $ exclusions ) ) { $ types [ $ type ] = $ field ; } } return $ types ; }
9046	public function registerType ( $ type , $ classname , $ options = array ( ) ) { if ( ! class_exists ( $ classname ) || ! is_callable ( array ( $ classname , 'getDataType' ) ) ) { return ; } $ data_type = call_user_func ( array ( $ classname , 'getDataType' ) ) ; $ options = ( array ) $ options ; $ options [ 'type' ] = $ type ; $ options [ 'class_name' ] = $ classname ; $ options [ 'data_type' ] = $ data_type ; $ this -> types [ $ data_type ] [ $ type ] = $ options ; }
191	public function setStatusCodeByException ( $ e ) { if ( $ e instanceof HttpException ) { $ this -> setStatusCode ( $ e -> statusCode ) ; } else { $ this -> setStatusCode ( 500 ) ; } return $ this ; }
10414	public function createTable ( $ connection = null ) { $ connection = $ connection ? : $ this -> connection ; $ schemaManager = $ connection -> getSchemaManager ( ) ; if ( $ schemaManager -> tablesExist ( [ $ this -> tableName ] ) ) { return null ; } $ table = new Table ( $ this -> tableName ) ; $ this -> buildTable ( $ table ) ; $ schemaManager -> createTable ( $ table ) ; return true ; }
4560	public function translate ( Translatable $ model ) { $ properties = $ this -> getProperties ( $ model ) ; foreach ( $ properties as $ property ) { $ get = 'get' . $ property -> getName ( ) ; $ set = 'set' . $ property -> getName ( ) ; $ values = [ ] ; foreach ( $ model -> getTranslations ( ) as $ translation ) { $ values [ $ translation -> getLocale ( ) ] = $ translation -> $ get ( ) ; } $ model -> $ set ( $ values ) ; } }
2494	protected function escapeExpressions ( $ string , $ allowWildcard = false ) { if ( $ allowWildcard ) { $ reservedCharacters = preg_quote ( '+-&|!(){}[]^"~?:\\ ' ) ; } else { $ reservedCharacters = preg_quote ( '+-&|!(){}[]^"~*?:\\ ' ) ; } return preg_replace_callback ( '/([' . $ reservedCharacters . '])/' , function ( $ matches ) { return '\\' . $ matches [ 0 ] ; } , $ string ) ; }
1147	protected function isConditionalRule ( $ attribute , $ rule ) { return isset ( $ this -> conditional [ $ attribute ] ) && in_array ( $ rule , $ this -> conditional [ $ attribute ] ) ; }
9534	private function parseQuote ( & $ argv , $ argument , $ quoteType ) { if ( substr ( $ argument , strlen ( $ argument ) - 1 , 1 ) !== $ quoteType ) { $ this -> argv [ ] = substr ( $ argument , 1 ) ; while ( ( $ argument_part = array_shift ( $ argv ) ) != null && substr ( $ argument_part , strlen ( $ argument_part ) - 1 , 1 ) !== $ quoteType ) { $ this -> argv [ count ( $ this -> argv ) - 1 ] .= ' ' . $ argument_part ; } $ this -> argv [ count ( $ this -> argv ) - 1 ] .= ' ' . substr ( $ argument_part , 0 , strlen ( $ argument_part ) - 1 ) ; } else { $ this -> argv [ ] = substr ( substr ( $ argument , 1 ) , 0 , strlen ( $ argument ) - 2 ) ; } }
2873	public function getRequestFilters ( Mage_Core_Controller_Request_Http $ request ) { if ( ! $ this -> requestFilterValues ) { $ filters = $ this -> getFilterParams ( ) ; $ this -> requestFilterValues = array ( ) ; foreach ( $ filters as $ filter ) { $ param = $ request -> getParam ( $ filter , null ) ; if ( $ param !== null ) { $ this -> requestFilterValues [ $ filter ] = $ param ; } } } return $ this -> requestFilterValues ; }
2617	public function getCountry ( ) { $ countryCode = $ this -> scopeConfig -> getValue ( 'general/country/default' ) ; if ( ! $ countryCode ) { return null ; } $ country = $ this -> countryFactory -> create ( ) -> loadByCode ( $ countryCode ) ; return $ country -> getName ( ) ; }
2621	public function sendValidationRequest ( $ validatedFlag , $ serviceId = null ) { if ( $ serviceId != null ) { $ this -> validationServiceId = $ serviceId ; } if ( $ validatedFlag ) { $ validationState = self :: FASTLY_VALIDATED_FLAG ; } else { $ validationState = self :: FASTLY_NON_VALIDATED_FLAG ; } $ pageViewParams = [ 'dl' => self :: GA_PAGEVIEW_URL . $ validationState , 'dh' => preg_replace ( '#^https?://#' , '' , rtrim ( self :: GA_PAGEVIEW_URL , '/' ) ) , 'dp' => '/' . $ validationState , 'dt' => ucfirst ( $ validationState ) , 't' => self :: GA_HITTYPE_PAGEVIEW , ] ; $ this -> sendReqToGA ( $ pageViewParams ) ; $ eventParams = [ 'ec' => self :: GA_FASTLY_SETUP , 'ea' => 'Fastly ' . $ validationState , 'el' => $ this -> getWebsiteName ( ) , 'ev' => $ this -> daysFromInstallation ( ) , 't' => self :: GA_HITTYPE_EVENT ] ; $ result = $ this -> sendReqToGA ( array_merge ( $ pageViewParams , $ eventParams ) ) ; return $ result ; }
4332	private static function buildAttribArrayVal ( $ key , $ value = array ( ) ) { if ( $ key == 'class' ) { if ( ! \ is_array ( $ value ) ) { $ value = \ explode ( ' ' , $ value ) ; } $ value = \ array_filter ( \ array_unique ( $ value ) ) ; \ sort ( $ value ) ; $ value = \ implode ( ' ' , $ value ) ; } elseif ( $ key == 'style' ) { $ keyValues = array ( ) ; foreach ( $ value as $ k => $ v ) { $ keyValues [ ] = $ k . ':' . $ v . ';' ; } \ sort ( $ keyValues ) ; $ value = \ implode ( '' , $ keyValues ) ; } else { $ value = null ; } return $ value ; }
4194	private function magicMethodInfo ( $ methods ) { if ( ! $ methods ) { return '' ; } foreach ( $ methods as $ i => $ method ) { $ methods [ $ i ] = '<code>' . $ method . '</code>' ; } $ methods = $ i == 0 ? 'a ' . $ methods [ 0 ] . ' method' : \ implode ( ' and ' , $ methods ) . ' methods' ; return '<dd class="magic info">This object has ' . $ methods . '</dd>' . "\n" ; }
12258	public function getOrganizedCompilers ( ) { if ( NULL === $ this -> orderedCompilers ) { $ depCollection = new DependencyCollection ( false ) ; $ depCollection -> setAcceptsDuplicates ( false ) ; foreach ( $ this -> compilers as $ compiler ) { if ( $ compiler instanceof CompilerInterface ) { $ id = $ compiler -> getCompilerID ( ) ; $ deps = $ compiler -> getDependsOnCompilerIDs ( ) ; if ( $ deps ) $ depCollection -> add ( $ id , $ compiler , $ deps ) ; else $ depCollection -> add ( $ id , $ compiler ) ; } elseif ( $ compiler instanceof CompilerFactoryInterface ) { $ compiler -> registerCompilerInstances ( $ depCollection , $ this ) ; } } $ this -> orderedCompilers = $ depCollection -> getOrderedElements ( ) ; } return $ this -> orderedCompilers ; }
2924	public function formatSetterLine ( $ key , $ value = null , $ comment = null , $ export = false ) { $ forceQuotes = ( strlen ( $ comment ) > 0 && strlen ( trim ( $ value ) ) == 0 ) ; $ value = $ this -> formatValue ( $ value , $ forceQuotes ) ; $ key = $ this -> formatKey ( $ key ) ; $ comment = $ this -> formatComment ( $ comment ) ; $ export = $ export ? 'export ' : '' ; $ line = "{$export}{$key}={$value}{$comment}" ; return $ line ; }
1968	public static function findByPid ( $ intPid , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; if ( Validator :: isStringUuid ( $ intPid ) ) { $ intPid = StringUtil :: uuidToBin ( $ intPid ) ; } return static :: findBy ( array ( "$t.pid=UNHEX(?)" ) , bin2hex ( $ intPid ) , $ arrOptions ) ; }
8779	public function segment ( $ num = null ) { if ( is_null ( http ( ) -> server ( 'REQUEST_URI' ) ) || is_null ( http ( ) -> server ( 'SCRIPT_NAME' ) ) ) { return null ; } if ( ! is_null ( $ num ) ) { $ uri = $ this -> replace ( str_replace ( $ this -> base , '' , http ( ) -> server ( 'REQUEST_URI' ) ) ) ; $ uriA = explode ( '/' , $ uri ) ; return ( isset ( $ uriA [ $ num ] ) ? reset ( explode ( '?' , $ uriA [ $ num ] ) ) : null ) ; } return null ; }
8213	protected function renderJob ( $ job ) { $ stats = $ this -> getJobStats ( $ job ) ; $ format = '<info>id</info>: %u, <info>length</info>: %u, <info>priority</info>: %u, <info>delay</info>: %u, <info>age</info>: %u, <info>ttr</info>: %u' ; $ line = sprintf ( $ format , $ job -> getId ( ) , strlen ( $ job -> getData ( ) ) , $ stats [ 'pri' ] , $ stats [ 'delay' ] , $ stats [ 'age' ] , $ stats [ 'ttr' ] ) ; $ this -> output -> writeln ( $ line ) ; $ format = '<comment>reserves</comment>: %u, <comment>releases</comment>: %u, <comment>buries</comment>: %u, <comment>kicks</comment>: %u, <comment>timeouts</comment>: %u' ; $ line = sprintf ( $ format , $ stats [ 'reserves' ] , $ stats [ 'releases' ] , $ stats [ 'buries' ] , $ stats [ 'kicks' ] , $ stats [ 'timeouts' ] ) ; $ this -> output -> writeln ( $ line ) ; $ this -> output -> writeln ( '<comment>body:</comment>' ) ; $ data = $ job -> getData ( ) ; $ this -> output -> writeln ( "\"$data\"" ) ; }
10904	public function isEmpty ( ) { if ( $ this -> test ( \ sndsgd \ Fs :: EXISTS | \ sndsgd \ Fs :: READABLE ) === false ) { throw new \ RuntimeException ( "failed to determine if a directory is empty; " . $ this -> getError ( ) ) ; } return count ( scandir ( $ this -> path ) ) === 2 ; }
3094	public function getAvailableActions ( ) { return is_array ( $ this -> getOption ( self :: ACTIONS_OPTION ) ) ? $ this -> getOption ( self :: ACTIONS_OPTION ) : [ ] ; }
10425	private function headers ( ResponseInterface $ response ) : void { if ( ! headers_sent ( ) ) { foreach ( $ response -> getHeaders ( ) as $ name => $ values ) { $ cookie = stripos ( $ name , 'Set-Cookie' ) === 0 ? false : true ; foreach ( $ values as $ value ) { header ( sprintf ( '%s: %s' , $ name , $ value ) , $ cookie ) ; $ cookie = false ; } } header ( sprintf ( 'HTTP/%s %s %s' , $ response -> getProtocolVersion ( ) , $ response -> getStatusCode ( ) , $ response -> getReasonPhrase ( ) ) , true , $ response -> getStatusCode ( ) ) ; } }
12654	public function getText ( $ name , $ language ) { $ allTexts = $ this -> getPageTexts ( $ language ) ; if ( isset ( $ allTexts [ $ name ] ) ) { return $ allTexts [ $ name ] ; } else { return null ; } }
7708	function ReplaceSrc ( $ new ) { $ len = $ this -> GetLen ( ) ; $ this -> Txt = substr_replace ( $ this -> Txt , $ new , $ this -> PosBeg , $ len ) ; $ diff = strlen ( $ new ) - $ len ; $ this -> PosEnd += $ diff ; $ this -> pST_Src = false ; if ( $ new === '' ) { $ this -> pST_PosBeg = false ; $ this -> pST_PosEnd = false ; $ this -> pET_PosBeg = false ; } else { $ this -> pST_PosEnd += $ diff ; if ( $ this -> pET_PosBeg !== false ) $ this -> pET_PosBeg += $ diff ; } }
9297	public function update ( array $ data = [ ] ) { $ this -> setActionUri ( __FUNCTION__ ) ; $ response = $ this -> client -> post ( $ this -> uri , [ 'multipart' => $ this -> dataToMultipart ( $ data ) , ] ) ; return $ this -> responseToJson ( $ response ) ; }
7275	protected function encodeValue ( $ column ) { $ val = in_array ( $ column , static :: $ jsons ) ? to_json ( $ this -> $ column ) : $ this -> $ column ; if ( isset ( static :: $ casts [ $ column ] ) && ( static :: $ casts [ $ column ] === "object" || static :: $ casts [ $ column ] === "array" ) ) $ val = to_json ( $ this -> $ column ) ; if ( is_bool ( $ val ) ) $ val = ( int ) $ val ; return $ val ; }
2517	public function pnrAddMultiElements ( RequestOptions \ PnrAddMultiElementsOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'PNR_AddMultiElements' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; }
5368	public function asMime ( ) { $ part = 'Content-Disposition: form-data; ' ; $ part .= 'name="' . $ this -> key . '"; ' ; $ part .= 'filename="' . $ this -> filename . '"' ; $ part .= "\r\nContent-Type: " . $ this -> deduceMimeType ( ) ; $ part .= "\r\n\r\n" . $ this -> content ; return $ part ; }
12864	public function postDispatch ( Zend_Controller_Request_Abstract $ request ) { $ methods = implode ( ', ' , array_unique ( $ this -> _methods ) ) ; $ headers = implode ( ', ' , array_unique ( $ this -> _headers ) ) ; if ( $ this -> _credentials ) { header ( 'Access-Control-Allow-Credentials: true' , true ) ; } header ( "Access-Control-Allow-Origin: {$this->_origin}" , true ) ; header ( "Access-Control-Allow-Methods: {$methods}" , true ) ; header ( "Access-Control-Allow-Headers: {$headers}" , true ) ; header ( "Access-Control-Max-Age: {$this->_maxAge}" , true ) ; header ( 'X-XSS-Protection: 1; mode=block' , true ) ; header ( 'X-Frame-Options: SAMEORIGIN' , true ) ; }
1967	public static function findById ( $ intId , array $ arrOptions = array ( ) ) { if ( Validator :: isUuid ( $ intId ) ) { return static :: findByUuid ( $ intId , $ arrOptions ) ; } return static :: findOneBy ( 'id' , $ intId , $ arrOptions ) ; }
2309	public function getImportantPart ( ) { if ( $ this -> importantPart ) { return $ this -> importantPart ; } return array ( 'x' => 0 , 'y' => 0 , 'width' => $ this -> fileObj -> viewWidth , 'height' => $ this -> fileObj -> viewHeight ) ; }
2703	public function canShowBlock ( ) { if ( $ this -> config -> getType ( ) == Config :: FASTLY && $ this -> config -> isEnabled ( ) ) { return true ; } return false ; }
10004	static function getStringFromHTTPStatusCode ( $ httpStatusCode ) { if ( array_key_exists ( $ httpStatusCode , HTTPResponseCodes :: $ codes ) === true ) { return HTTPResponseCodes :: $ codes [ $ httpStatusCode ] ; } else { return "unknown error code: " . $ httpStatusCode ; } }
504	protected function renderHtmlResponse ( ) { return $ this -> controller -> render ( $ this -> view ? : $ this -> id , $ this -> getViewRenderParams ( ) ) ; }
6753	public static function installWebServer ( ) { $ appPath = __DIR__ . '/../../../..' ; self :: createFolderIfNotExists ( "$appPath/web" ) ; self :: createCopy ( __DIR__ , 'app.php' , "$appPath/web" , 'app.php' ) ; self :: createCopy ( __DIR__ , 'app_dev.php' , "$appPath/web" , 'app_dev.php' ) ; }
1041	public function wait ( Promise $ promise ) { $ this -> beforeWait ( $ promise ) ; $ dfdQueue = Deferred :: getQueue ( ) ; $ promiseQueue = SyncPromise :: getQueue ( ) ; while ( $ promise -> adoptedPromise -> state === SyncPromise :: PENDING && ! ( $ dfdQueue -> isEmpty ( ) && $ promiseQueue -> isEmpty ( ) ) ) { Deferred :: runQueue ( ) ; SyncPromise :: runQueue ( ) ; $ this -> onWait ( $ promise ) ; } $ syncPromise = $ promise -> adoptedPromise ; if ( $ syncPromise -> state === SyncPromise :: FULFILLED ) { return $ syncPromise -> result ; } if ( $ syncPromise -> state === SyncPromise :: REJECTED ) { throw $ syncPromise -> result ; } throw new InvariantViolation ( 'Could not resolve promise' ) ; }
5154	public function configure ( ) { $ configuration = $ this -> getConfiguration ( ) ; if ( $ configuration instanceof ConfigurationInterface ) { $ this -> configuration -> configure ( $ this ) ; } }
10262	public function getInternet ( $ person_name = null , $ company = null ) { if ( empty ( $ person_name ) ) { $ person_name = $ this -> getFullName ( ) ; } $ internet = new Entities \ Internet ( ) ; $ internet -> domain = $ this -> getDomain ( $ company ) ; $ internet -> username = $ this -> getUserName ( $ person_name ) ; $ internet -> email = $ this -> getEmail ( $ person_name , $ internet -> domain ) ; $ internet -> url = $ this -> getUrl ( $ internet -> domain ) ; $ internet -> ip = $ this -> getIp ( ) ; return $ internet ; }
1217	public static function slice ( $ value , $ start = null , $ stop = null , $ step = 1 ) { if ( ! Utils :: isArray ( $ value ) && ! is_string ( $ value ) ) { throw new \ InvalidArgumentException ( 'Expects string or array' ) ; } return self :: sliceIndices ( $ value , $ start , $ stop , $ step ) ; }
6655	public function normalizeHeaders ( $ params ) { $ out = '' ; foreach ( $ params as $ key => $ param ) { $ out .= $ key . '="' . rawurlencode ( trim ( $ param ) ) . '",' ; } return rtrim ( $ out , ',' ) ; }
7244	public function load_options ( ) { $ options = get_option ( self :: OPTION_KEY , '' ) ; if ( ! is_array ( $ options ) ) { $ options = self :: $ default_options ; update_option ( self :: OPTION_KEY , $ options ) ; } else { foreach ( self :: $ default_options as $ key => $ value ) { if ( ! isset ( $ options [ $ key ] ) ) $ options [ $ key ] = $ value ; } } $ this -> options = $ options ; }
466	public function buildInCondition ( $ operator , $ operands , & $ params ) { array_unshift ( $ operands , $ operator ) ; return $ this -> buildCondition ( $ operands , $ params ) ; }
2792	public function get ( $ option ) { if ( ! array_key_exists ( $ option , $ this -> inputOptions ) ) { throw new \ InvalidArgumentException ( 'Option "' . $ option . ' not exists' ) ; } return $ this -> inputOptions [ $ option ] ; }
5879	protected static function createIndex ( $ fileName , $ width , $ height ) { $ relativePath = substr ( PathUtility :: dirname ( $ fileName ) , strlen ( PATH_site ) ) ; $ resourceFactory = \ TYPO3 \ CMS \ Core \ Resource \ ResourceFactory :: getInstance ( ) ; $ targetFolder = $ resourceFactory -> retrieveFileOrFolderObject ( $ relativePath ) ; $ targetFilename = PathUtility :: basename ( $ fileName ) ; $ storageConfiguration = $ targetFolder -> getStorage ( ) -> getConfiguration ( ) ; if ( ! isset ( $ storageConfiguration [ 'basePath' ] ) ) { return ; } $ basePath = rtrim ( $ storageConfiguration [ 'basePath' ] , '/' ) . '/' ; $ basePath = GeneralUtility :: getFileAbsFileName ( $ basePath ) ; $ identifier = substr ( $ fileName , strlen ( $ basePath ) - 1 ) ; $ driver = static :: accessProtectedProperty ( $ targetFolder -> getStorage ( ) , 'driver' ) ; $ fileInfo = $ driver -> getFileInfoByIdentifier ( $ identifier ) ; $ file = $ resourceFactory -> createFileObject ( $ fileInfo ) ; $ fileRepository = GeneralUtility :: makeInstance ( \ TYPO3 \ CMS \ Core \ Resource \ FileRepository :: class ) ; $ fileRepository -> addToIndex ( $ file ) ; }
9637	public function handle ( GetResponseEvent $ event ) { $ apiKey = $ this -> getApiKeyFromQueryOrHeader ( $ event -> getRequest ( ) ) ; if ( false === $ apiKey ) { return ; } try { $ token = $ this -> authenticationManager -> authenticate ( new ApiKeyToken ( $ apiKey ) ) ; $ this -> tokenStorage -> setToken ( $ token ) ; } catch ( AuthenticationException $ failed ) { $ this -> tokenStorage -> setToken ( null ) ; $ this -> doFailureResponse ( $ event ) ; } }
8405	public static function run ( ) { if ( self :: $ isInit === false ) { throw new BadUse ( 'bootstrap doesn\'t seem to have been initialized' ) ; } foreach ( self :: $ namespaces as $ name => $ path ) { if ( is_readable ( $ path . DIRECTORY_SEPARATOR . 'init.php' ) === true ) { require $ path . DIRECTORY_SEPARATOR . 'init.php' ; } elseif ( stripos ( $ path , 'vendor' ) === false || stripos ( $ path , 'vendor' ) == strlen ( $ path ) - strlen ( 'vendor' ) ) { Logger :: get ( ) -> error ( 'namespace "' . $ name . '" doesn\'t have an init.php' ) ; } } if ( defined ( 'STRAY_IS_CLI' ) === true && constant ( 'STRAY_IS_CLI' ) === true ) { Console :: run ( ) ; } elseif ( defined ( 'STRAY_IS_HTTP' ) === true && constant ( 'STRAY_IS_HTTP' ) === true ) { if ( count ( self :: $ applications ) == 0 ) { throw new BadUse ( 'no application has been registered' ) ; } Http :: run ( ) ; } else { throw new BadUse ( 'unknown mode, not CLI_IS_CLI nor STRAY_IS_HTTP' ) ; } }
682	protected function validateOperatorCondition ( $ operator , $ condition , $ attribute = null ) { if ( $ attribute === null ) { $ this -> addError ( $ this -> filterAttributeName , $ this -> parseErrorMessage ( 'operatorRequireAttribute' , [ 'operator' => $ operator ] ) ) ; return ; } $ internalOperator = $ this -> filterControls [ $ operator ] ; $ operatorTypes = $ this -> operatorTypes [ $ internalOperator ] ; if ( $ operatorTypes !== '*' ) { $ attributeTypes = $ this -> getSearchAttributeTypes ( ) ; $ attributeType = $ attributeTypes [ $ attribute ] ; if ( ! in_array ( $ attributeType , $ operatorTypes , true ) ) { $ this -> addError ( $ this -> filterAttributeName , $ this -> parseErrorMessage ( 'unsupportedOperatorType' , [ 'attribute' => $ attribute , 'operator' => $ operator ] ) ) ; return ; } } if ( in_array ( $ internalOperator , $ this -> multiValueOperators , true ) ) { if ( ! is_array ( $ condition ) ) { $ this -> addError ( $ this -> filterAttributeName , $ this -> parseErrorMessage ( 'operatorRequireMultipleOperands' , [ 'operator' => $ operator ] ) ) ; } else { foreach ( $ condition as $ v ) { $ this -> validateAttributeValue ( $ attribute , $ v ) ; } } } else { $ this -> validateAttributeValue ( $ attribute , $ condition ) ; } }
12593	public function setOperator ( $ operator ) { $ this -> checkParams ( $ this -> operation , $ operator ) ; $ this -> operator = $ operator ; }
9083	private static function parseGetPostSessionCookie ( Request & $ request ) { foreach ( $ _GET as $ name => $ value ) { $ request -> params [ $ name ] = $ value ; } foreach ( $ _POST as $ name => $ value ) { $ request -> params [ $ name ] = $ value ; } foreach ( $ _COOKIE as $ name => $ value ) { $ request -> params [ $ name ] = $ value ; } foreach ( $ _FILES as $ name => $ value ) { $ request -> params [ $ name ] = $ value ; } if ( isset ( $ _SESSION ) ) { foreach ( $ _SESSION as $ name => $ value ) { $ request -> params [ $ name ] = $ value ; } } }
969	public function getType ( ) { $ config = Config :: get ( 'shopify-app.api_grant_mode' ) ; if ( $ config === self :: GRANT_PERUSER ) { return self :: GRANT_PERUSER ; } return self :: GRANT_OFFLINE ; }
7550	function wrapInner ( $ node , $ start = 0 , $ end = - 1 , $ wrap_index = - 1 , $ node_index = null ) { if ( $ end < 0 ) { $ end += count ( $ this -> children ) ; } if ( $ node_index === null ) { $ node_index = $ end + 1 ; } if ( ! is_object ( $ node ) ) { $ node = $ this -> addChild ( $ node , $ node_index ) ; } elseif ( $ node -> parent !== $ this ) { $ node -> changeParent ( $ this -> parent , $ node_index ) ; } $ this -> moveChildren ( $ node , $ wrap_index , $ start , $ end ) ; return $ node ; }
1793	private function getHostAndPort ( string $ domain ) : array { if ( false !== strpos ( $ domain , ':' ) ) { return explode ( ':' , $ domain , 2 ) ; } return [ $ domain , null ] ; }
4851	protected function applyId ( & $ row , $ id , $ identifierField ) { $ ids = ( array ) $ id ; $ findId = function ( $ row ) use ( $ ids , $ identifierField ) { foreach ( $ ids as $ id ) { $ bool = true ; $ identifierField = $ this -> flatten ( $ identifierField ) ; foreach ( $ identifierField as $ identifier ) { $ bool = $ bool && ( mb_strtolower ( $ id [ $ identifier ] ) === mb_strtolower ( $ row [ $ identifier ] ) ) ; } if ( $ bool ) { return $ id [ 'id' ] ; } } return 0 ; } ; $ isDeep = $ this -> isDeep ( $ row ) ; if ( $ isDeep ) { foreach ( $ row as $ i => & $ r ) { $ r [ 'id' ] = $ findId ( $ r ) ; } } else { $ row [ 'id' ] = $ findId ( $ row ) ; } }
5793	protected function addColumnConstraint ( ColumnMapper $ column , string $ constraint , $ context = true ) { $ column -> addConstraint ( $ constraint , $ context ) ; }
3210	function disableOAuth1AccessToken ( $ oauth1AccessToken ) { OAuth1AccessToken :: checkArg ( "oauth1AccessToken" , $ oauth1AccessToken ) ; $ response = self :: doPost ( $ oauth1AccessToken , "1/disable_access_token" ) ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; }
7977	public function deleteSecondaryDnsDomains ( $ domain2delete ) { json_decode ( self :: getClient ( ) -> deleteSecondaryDnsDomains ( $ this -> getDomain ( ) , $ domain2delete ) ) ; return true ; }
12523	public function update ( array $ arguments = null , array $ options = null ) : void { if ( $ arguments ) { $ keys = array_keys ( $ this -> arguments ) ; for ( $ index = 0 ; $ index < count ( $ keys ) ; $ index ++ ) { $ this -> arguments [ $ keys [ $ index ] ] = $ arguments [ $ index ] ; } } if ( $ options ) { foreach ( $ options as $ option => $ value ) { $ this -> options [ $ option ] = $ value ; } } }
4979	public function get ( $ form , $ options = null , $ params = null ) { if ( ! is_object ( $ form ) ) { $ form = $ this -> formElementManager -> get ( $ form , $ options ) ; } $ params = $ params ? : clone $ this -> getController ( ) -> getRequest ( ) -> getQuery ( ) ; $ hydrator = $ form -> getHydrator ( ) ; $ data = $ hydrator -> extract ( $ params ) ; $ form -> setData ( $ data ) ; $ hydrator -> hydrate ( $ data , $ params ) ; return $ form ; }
2915	public function getLayoutUpdatesFiles ( $ storeId , $ designArea ) { $ updatesRoot = $ this -> getConfig ( ) -> getNode ( $ designArea . '/layout/updates' ) ; $ updateFiles = array ( ) ; foreach ( $ updatesRoot -> children ( ) as $ updateNode ) { if ( $ updateNode -> file ) { $ module = $ updateNode -> getAttribute ( 'module' ) ; if ( $ module && Mage :: getStoreConfigFlag ( 'advanced/modules_disable_output/' . $ module , $ storeId ) ) { continue ; } $ updateFiles [ ] = ( string ) $ updateNode -> file ; } } $ updateFiles [ ] = 'local.xml' ; return $ updateFiles ; }
7627	public function createContainerIfNotExists ( $ containerName = '' , $ metadata = array ( ) ) { if ( ! $ this -> containerExists ( $ containerName ) ) { $ this -> createContainer ( $ containerName , $ metadata ) ; } }
931	public function clear ( ) { @ trigger_error ( __METHOD__ . ' is deprecated and will be removed in 3.0.' , E_USER_DEPRECATED ) ; Tokens :: setLegacyMode ( true ) ; $ this -> content = '' ; $ this -> id = null ; $ this -> isArray = false ; }
5719	public function cancel ( ) { Controller :: curr ( ) -> getResponse ( ) -> addHeader ( "X-Pjax" , "Content" ) ; return Controller :: curr ( ) -> redirect ( $ this -> getBackLink ( ) ) ; }
4145	protected function validateCredentials ( $ credentials ) { $ credentials = array_filter ( $ credentials ) ; $ keys = array_keys ( $ credentials ) ; $ diff = array_diff ( $ this -> requiredCredentials , $ keys ) ; if ( ! empty ( $ diff ) ) { throw new MissingCredentialsException ( 'Missing Credentials: ' . implode ( $ diff , ', ' ) ) ; } unset ( $ credentials , $ keys , $ diff ) ; }
1434	public static function decamelize ( $ value ) { if ( isset ( self :: $ decamelized [ $ value ] ) ) { return self :: $ decamelized [ $ value ] ; } return self :: $ decamelized [ $ value ] = strtolower ( preg_replace ( '/(.)(?=[A-Z])/u' , '$1_' , $ value ) ) ; }
10866	protected function createNewInst ( ) { $ classReflection = new \ ReflectionClass ( $ this -> instClass ) ; if ( $ this -> constructorArgs === null ) { return $ classReflection -> newInstance ( ) ; } else { return $ classReflection -> newInstanceArgs ( $ this -> concstructorArgs ) ; } }
11158	protected function getVideoId ( $ url ) { $ logger = $ this -> getLogger ( ) ; $ parsed = parse_url ( $ url ) ; $ logger -> debug ( 'getVideoId' , array ( 'url' => $ url , 'parsed' => $ parsed ) ) ; switch ( $ parsed [ 'host' ] ) { case 'youtu.be' : return ltrim ( $ parsed [ 'path' ] , '/' ) ; case 'www.youtube.com' : case 'youtube.com' : if ( ! empty ( $ parsed [ 'query' ] ) ) { parse_str ( $ parsed [ 'query' ] , $ query ) ; $ logger -> debug ( 'getVideoId' , array ( 'url' => $ url , 'query' => $ query ) ) ; if ( ! empty ( $ query [ 'v' ] ) ) { return $ query [ 'v' ] ; } } elseif ( isset ( $ parsed [ 'path' ] ) && substr ( $ parsed [ 'path' ] , 0 , 7 ) == '/embed/' ) { $ logger -> debug ( 'getVideoId' , array ( 'url' => $ url , 'path' => $ parsed [ 'path' ] ) ) ; $ vId = substr ( $ parsed [ 'path' ] , 7 ) ; if ( ! empty ( $ vId ) ) { return $ vId ; } } } return null ; }
3486	private static function addDefaultResolvers ( ) : void { static $ added = false ; if ( $ added ) { return ; } $ added = true ; self :: addResolver ( [ __CLASS__ , 'tryResolveByWebTokenJwtSystem' ] ) ; self :: addResolver ( [ __CLASS__ , 'tryResolveBySpomkyLabsJoseSystem' ] ) ; }
5245	private function replace ( string $ pattern , string $ replacement , string $ targetFile ) { $ this -> filesystem -> put ( $ targetFile , preg_replace ( $ pattern , $ replacement , $ this -> filesystem -> get ( $ targetFile ) ) ) ; }
5379	protected function wrap ( $ text ) { $ text = str_replace ( "\r\r\n" , "\r\n" , str_replace ( "\n" , "\r\n" , $ text ) ) ; $ text = str_replace ( "\r\n\n" , "\r\n" , str_replace ( "\r" , "\r\n" , $ text ) ) ; if ( strncmp ( $ text , "\r\n" , strlen ( "\r\n" ) ) == 0 ) { $ text = substr ( $ text , strlen ( "\r\n" ) ) ; } if ( $ this -> wrapIsEnabled ( ) ) { return wordwrap ( $ text , ( integer ) $ this -> getAttribute ( 'cols' ) , "\r\n" ) ; } return $ text ; }
75	public function seek ( $ offset ) { $ this -> rewind ( ) ; for ( $ i = 0 ; $ i < $ offset ; $ i ++ , $ this -> next ( ) ) ; }
89	public function write ( array $ hash , $ options = 448 ) { $ dir = dirname ( $ this -> path ) ; if ( ! is_dir ( $ dir ) ) { if ( file_exists ( $ dir ) ) { throw new \ UnexpectedValueException ( $ dir . ' exists and is not a directory.' ) ; } if ( ! @ mkdir ( $ dir , 0777 , true ) ) { throw new \ UnexpectedValueException ( $ dir . ' does not exist and could not be created.' ) ; } } $ retries = 3 ; while ( $ retries -- ) { try { file_put_contents ( $ this -> path , static :: encode ( $ hash , $ options ) . ( $ options & self :: JSON_PRETTY_PRINT ? "\n" : '' ) ) ; break ; } catch ( \ Exception $ e ) { if ( $ retries ) { usleep ( 500000 ) ; continue ; } throw $ e ; } } }
9291	public function addGrid16CSS ( \ PageModel $ objPage , \ LayoutModel $ objLayout , \ PageRegular $ objPageRegular ) { $ arrFrameworkGrid16 = \ StringUtil :: deserialize ( $ objLayout -> frameworkGrid16 ) ; if ( is_array ( $ arrFrameworkGrid16 ) ) { foreach ( $ arrFrameworkGrid16 as $ strFile ) { if ( $ objLayout -> loadingOrderGrid16 == 'before_framework' ) { $ GLOBALS [ 'TL_CSS' ] [ ] = 'bundles/bugbustergrid16/' . basename ( $ strFile , '.css' ) . '.min.css' ; } else { $ GLOBALS [ 'TL_HEAD' ] [ ] = '<link rel="stylesheet" href="bundles/bugbustergrid16/' . basename ( $ strFile , '.css' ) . '.min.css">' ; } } } return ; }
181	public function getConverter ( ) { if ( $ this -> _converter === null ) { $ this -> _converter = Yii :: createObject ( AssetConverter :: className ( ) ) ; } elseif ( is_array ( $ this -> _converter ) || is_string ( $ this -> _converter ) ) { if ( is_array ( $ this -> _converter ) && ! isset ( $ this -> _converter [ 'class' ] ) ) { $ this -> _converter [ 'class' ] = AssetConverter :: className ( ) ; } $ this -> _converter = Yii :: createObject ( $ this -> _converter ) ; } return $ this -> _converter ; }
763	private function updateCollectionOffsets ( ) { if ( ! empty ( $ this -> _children ) ) { $ this -> startOffset = reset ( $ this -> _children ) -> startOffset ; $ this -> endOffset = end ( $ this -> _children ) -> endOffset ; } if ( $ this -> parent !== null ) { $ this -> parent -> updateCollectionOffsets ( ) ; } }
8334	public function addScope ( $ scope ) { if ( $ this -> isValidScope ( $ scope ) ) { $ this -> scope [ $ scope ] = $ scope ; } return $ this ; }
1213	public static function type ( $ arg ) { $ type = gettype ( $ arg ) ; if ( isset ( self :: $ typeMap [ $ type ] ) ) { return self :: $ typeMap [ $ type ] ; } elseif ( $ type === 'array' ) { if ( empty ( $ arg ) ) { return 'array' ; } reset ( $ arg ) ; return key ( $ arg ) === 0 ? 'array' : 'object' ; } elseif ( $ arg instanceof \ stdClass ) { return 'object' ; } elseif ( $ arg instanceof JmesPathableObjectInterface ) { return 'object' ; } elseif ( $ arg instanceof \ Closure ) { return 'expression' ; } elseif ( $ arg instanceof \ ArrayAccess && $ arg instanceof \ Countable ) { return count ( $ arg ) == 0 || $ arg -> offsetExists ( 0 ) ? 'array' : 'object' ; } elseif ( method_exists ( $ arg , '__toString' ) ) { return 'string' ; } throw new \ InvalidArgumentException ( 'Unable to determine JMESPath type from ' . get_class ( $ arg ) ) ; }
11916	public function response ( array $ data , $ http_code ) { if ( config ( 'odin.queryRequest' ) ) { $ data [ 'queries' ] = $ this -> getQueries ( ) ; } return response ( ) -> json ( $ data , $ http_code ) ; }
7455	protected function getTaxonomies ( string $ post_type ) : array { $ return = [ ] ; $ taxes = \ get_object_taxonomies ( $ post_type , 'objects' ) ; foreach ( $ taxes as $ tax_slug => $ tax_object ) { if ( \ is_taxonomy_hierarchical ( $ tax_slug ) ) { $ return [ ] = $ tax_slug ; } } return $ return ; }
9685	public function setStorage ( $ storage , $ options = null ) { if ( ! $ storage instanceof Storage \ StorageInterface ) { $ storage = $ this -> getStoragePluginManager ( ) -> get ( $ storage , $ options ) ; } $ this -> storage = $ storage ; return $ this ; }
1320	private function curlOptions ( ) { $ options = [ CURLOPT_CONNECTTIMEOUT => $ this -> connectionTimeout , CURLOPT_HEADER => true , CURLOPT_RETURNTRANSFER => true , CURLOPT_SSL_VERIFYHOST => 2 , CURLOPT_SSL_VERIFYPEER => true , CURLOPT_TIMEOUT => $ this -> timeout , CURLOPT_USERAGENT => $ this -> userAgent , ] ; if ( $ this -> useCAFile ( ) ) { $ options [ CURLOPT_CAINFO ] = __DIR__ . DIRECTORY_SEPARATOR . 'cacert.pem' ; } if ( $ this -> gzipEncoding ) { $ options [ CURLOPT_ENCODING ] = 'gzip' ; } if ( ! empty ( $ this -> proxy ) ) { $ options [ CURLOPT_PROXY ] = $ this -> proxy [ 'CURLOPT_PROXY' ] ; $ options [ CURLOPT_PROXYUSERPWD ] = $ this -> proxy [ 'CURLOPT_PROXYUSERPWD' ] ; $ options [ CURLOPT_PROXYPORT ] = $ this -> proxy [ 'CURLOPT_PROXYPORT' ] ; $ options [ CURLOPT_PROXYAUTH ] = CURLAUTH_BASIC ; $ options [ CURLOPT_PROXYTYPE ] = CURLPROXY_HTTP ; } return $ options ; }
8907	public function get_next_id ( ) { return ( int ) $ this -> _database -> select ( 'AUTO_INCREMENT' ) -> from ( 'information_schema.TABLES' ) -> where ( 'TABLE_NAME' , $ this -> _database -> dbprefix ( $ this -> get_table ( ) ) ) -> where ( 'TABLE_SCHEMA' , $ this -> _database -> database ) -> get ( ) -> row ( ) -> AUTO_INCREMENT ; }
7927	public function registerNamespace ( $ ns , $ def ) { list ( $ ns , $ def ) = $ this -> fireEvent ( 'namespace.register' , [ $ ns , $ def ] ) ; $ this -> namespaces [ $ ns ] = $ def ; return $ this ; }
1524	protected function doRead ( StoreInterface $ store , FetchResource $ request ) { $ record = $ request -> getRecord ( ) ; if ( $ result = $ this -> invoke ( 'reading' , $ record , $ request ) ) { return $ result ; } $ record = $ store -> readRecord ( $ record , $ request -> getParameters ( ) ) ; if ( $ result = $ this -> invoke ( 'didRead' , $ record , $ request ) ) { return $ result ; } return $ record ; }
8655	private function convertGetReportCount ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetReportCount' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetReportTypeList ( ) ) { $ reportTypeList = $ request -> getReportTypeList ( ) ; foreach ( $ reportTypeList -> getType ( ) as $ typeIndex => $ type ) { $ parameters [ 'ReportTypeList' . '.' . 'Type' . '.' . ( $ typeIndex + 1 ) ] = $ type ; } } if ( $ request -> isSetAcknowledged ( ) ) { $ parameters [ 'Acknowledged' ] = $ request -> getAcknowledged ( ) ? "true" : "false" ; } if ( $ request -> isSetAvailableFromDate ( ) ) { $ parameters [ 'AvailableFromDate' ] = $ this -> getFormattedTimestamp ( $ request -> getAvailableFromDate ( ) ) ; } if ( $ request -> isSetAvailableToDate ( ) ) { $ parameters [ 'AvailableToDate' ] = $ this -> getFormattedTimestamp ( $ request -> getAvailableToDate ( ) ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
6894	protected function compareStockUnitByPrice ( StockUnitInterface $ u1 , StockUnitInterface $ u2 ) { $ u1HasPrice = 0 < $ u1 -> getNetPrice ( ) ; $ u2HasPrice = 0 < $ u2 -> getNetPrice ( ) ; if ( ! $ u1HasPrice && $ u2HasPrice ) { return 1 ; } if ( $ u1HasPrice && ! $ u2HasPrice ) { return - 1 ; } if ( $ u1 -> getNetPrice ( ) != $ u2 -> getNetPrice ( ) ) { return $ u1 -> getNetPrice ( ) > $ u2 -> getNetPrice ( ) ? 1 : - 1 ; } return 0 ; }
1655	public function handleConnectedSocks ( ConnectionInterface $ stream , $ host , $ port , Deferred $ deferred , $ uri ) { $ reader = new StreamReader ( ) ; $ stream -> on ( 'data' , array ( $ reader , 'write' ) ) ; $ stream -> on ( 'error' , $ onError = function ( Exception $ e ) use ( $ deferred , $ uri ) { $ deferred -> reject ( new RuntimeException ( 'Connection to ' . $ uri . ' failed because connection to proxy caused a stream error (EIO)' , defined ( 'SOCKET_EIO' ) ? SOCKET_EIO : 5 , $ e ) ) ; } ) ; $ stream -> on ( 'close' , $ onClose = function ( ) use ( $ deferred , $ uri ) { $ deferred -> reject ( new RuntimeException ( 'Connection to ' . $ uri . ' failed because connection to proxy was lost while waiting for response from proxy (ECONNRESET)' , defined ( 'SOCKET_ECONNRESET' ) ? SOCKET_ECONNRESET : 104 ) ) ; } ) ; if ( $ this -> protocolVersion === 5 ) { $ promise = $ this -> handleSocks5 ( $ stream , $ host , $ port , $ reader , $ uri ) ; } else { $ promise = $ this -> handleSocks4 ( $ stream , $ host , $ port , $ reader , $ uri ) ; } $ promise -> then ( function ( ) use ( $ deferred , $ stream , $ reader , $ onError , $ onClose ) { $ stream -> removeListener ( 'data' , array ( $ reader , 'write' ) ) ; $ stream -> removeListener ( 'error' , $ onError ) ; $ stream -> removeListener ( 'close' , $ onClose ) ; $ deferred -> resolve ( $ stream ) ; } , function ( Exception $ error ) use ( $ deferred , $ stream , $ uri ) { if ( ! $ error instanceof RuntimeException ) { $ error = new RuntimeException ( 'Connection to ' . $ uri . ' failed because proxy returned invalid response (EBADMSG)' , defined ( 'SOCKET_EBADMSG' ) ? SOCKET_EBADMSG : 71 , $ error ) ; } $ deferred -> reject ( $ error ) ; $ stream -> close ( ) ; } ) ; }
2006	protected function removeRecipient ( $ strEmail , $ arrRemove ) { if ( ( $ objRemove = NewsletterRecipientsModel :: findByEmailAndPids ( $ strEmail , $ arrRemove ) ) !== null ) { while ( $ objRemove -> next ( ) ) { $ strHash = md5 ( $ objRemove -> email ) ; if ( ( $ objBlacklist = NewsletterBlacklistModel :: findByHashAndPid ( $ strHash , $ objRemove -> pid ) ) === null ) { $ objBlacklist = new NewsletterBlacklistModel ( ) ; $ objBlacklist -> pid = $ objRemove -> pid ; $ objBlacklist -> hash = $ strHash ; $ objBlacklist -> save ( ) ; } $ objRemove -> delete ( ) ; } } $ objChannels = NewsletterChannelModel :: findByIds ( $ arrRemove ) ; $ arrChannels = $ objChannels -> fetchEach ( 'title' ) ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'removeRecipient' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'removeRecipient' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'removeRecipient' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ strEmail , $ arrRemove ) ; } } $ arrData = array ( ) ; $ arrData [ 'domain' ] = Idna :: decode ( Environment :: get ( 'host' ) ) ; $ arrData [ 'channel' ] = $ arrData [ 'channels' ] = implode ( "\n" , $ arrChannels ) ; $ objEmail = new Email ( ) ; $ objEmail -> from = $ GLOBALS [ 'TL_ADMIN_EMAIL' ] ; $ objEmail -> fromName = $ GLOBALS [ 'TL_ADMIN_NAME' ] ; $ objEmail -> subject = sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'nl_subject' ] , Idna :: decode ( Environment :: get ( 'host' ) ) ) ; $ objEmail -> text = StringUtil :: parseSimpleTokens ( $ this -> nl_unsubscribe , $ arrData ) ; $ objEmail -> sendTo ( $ strEmail ) ; if ( ( $ objTarget = $ this -> objModel -> getRelated ( 'jumpTo' ) ) instanceof PageModel ) { $ this -> redirect ( $ objTarget -> getFrontendUrl ( ) ) ; } System :: getContainer ( ) -> get ( 'session' ) -> getFlashBag ( ) -> set ( 'nl_removed' , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'nl_removed' ] ) ; $ this -> reload ( ) ; }
321	public function normalizePathInfo ( $ pathInfo , $ suffix , & $ normalized = false ) { if ( empty ( $ pathInfo ) ) { return $ pathInfo ; } $ sourcePathInfo = $ pathInfo ; if ( $ this -> collapseSlashes ) { $ pathInfo = $ this -> collapseSlashes ( $ pathInfo ) ; } if ( $ this -> normalizeTrailingSlash === true ) { $ pathInfo = $ this -> normalizeTrailingSlash ( $ pathInfo , $ suffix ) ; } $ normalized = $ sourcePathInfo !== $ pathInfo ; return $ pathInfo ; }
6284	protected static function buildHttpClient05 ( LoopInterface $ loop , $ connector = null ) { if ( $ connector instanceof DnsResolver ) { @ trigger_error ( sprintf ( 'Passing a %s to buildHttpClient is deprecated since version 2.1.0 and will be removed in 3.0. If you need no specific behaviour, omit the $dns argument, otherwise pass a %s' , DnsResolver :: class , ConnectorInterface :: class ) , E_USER_DEPRECATED ) ; $ connector = static :: buildConnector ( $ loop , $ connector ) ; } if ( null !== $ connector && ! $ connector instanceof ConnectorInterface ) { throw new \ InvalidArgumentException ( '$connector must be an instance of DnsResolver or ConnectorInterface' ) ; } return new HttpClient ( $ loop , $ connector ) ; }
10863	protected function createIterator ( ) { $ options = \ RecursiveDirectoryIterator :: SKIP_DOTS ; $ iterator = new \ RecursiveDirectoryIterator ( $ this -> dir , $ options ) ; $ options = \ RecursiveIteratorIterator :: SELF_FIRST ; return new \ RecursiveIteratorIterator ( $ iterator , $ options ) ; }
6723	protected function validateAuthParams ( ) { if ( empty ( $ this -> authUrl ) || filter_var ( $ this -> authUrl , FILTER_VALIDATE_URL ) === false ) { throw new Oauth2ClientException ( sprintf ( self :: INVALID_AUTH_URL , $ this -> authUrl ) ) ; } if ( empty ( $ this -> clientId ) ) { throw new Oauth2ClientException ( self :: INVALID_CLIENT_ID ) ; } if ( empty ( $ this -> clientSecret ) ) { throw new Oauth2ClientException ( self :: INVALID_CLIENT_SECRET ) ; } return true ; }
851	public function getTokenNotOfKindSibling ( $ index , $ direction , array $ tokens = [ ] ) { while ( true ) { $ index += $ direction ; if ( ! $ this -> offsetExists ( $ index ) ) { return null ; } if ( $ this -> isEmptyAt ( $ index ) ) { continue ; } if ( $ this [ $ index ] -> equalsAny ( $ tokens ) ) { continue ; } return $ index ; } }
11378	public function postAction ( ) { if ( ! preg_match ( '/\/page\/(\w+[\-\w]*)\/text\/(..)$/' , $ this -> name , $ matches ) ) { throw new InvalidParameterException ( "Invalid parameters" ) ; } list ( $ dummy , $ pageName , $ language ) = $ matches ; $ request = $ this -> environment -> getRequestHelper ( ) ; $ name = $ request -> getIdentifierParam ( 'name' ) ; $ content = $ request -> getParam ( 'content' , '' ) ; try { $ pageTexts = $ this -> getTextModel ( $ pageName ) ; $ text = $ pageTexts -> addTextContainer ( $ name , $ this -> filter ( $ content ) , $ language ) ; $ this -> environment -> sendJSONResult ( $ text ) ; } catch ( \ Exception $ e ) { throw new InvalidParameterException ( $ e -> getMessage ( ) ) ; } }
6382	public function readQuestions ( $ quizId ) { $ quizSlots = $ this -> readStoreRecords ( 'quiz_slots' , [ 'quizid' => $ quizId ] ) ; $ questions = [ ] ; foreach ( $ quizSlots as $ index => $ quizSlot ) { try { $ question = $ this -> readStoreRecord ( 'question' , [ 'id' => $ quizSlot -> questionid ] ) ; $ question -> answers = $ this -> readStoreRecords ( 'question_answers' , [ 'question' => $ question -> id ] ) ; $ question -> url = $ this -> cfg -> wwwroot . '/mod/question/question.php?id=' . $ question -> id ; if ( $ question -> qtype == 'numerical' ) { $ question -> numerical = ( object ) [ 'answers' => $ this -> readStoreRecords ( 'question_numerical' , [ 'question' => $ question -> id ] ) , 'options' => $ this -> readStoreRecord ( 'question_numerical_options' , [ 'question' => $ question -> id ] ) , 'units' => $ this -> readStoreRecords ( 'question_numerical_units' , [ 'question' => $ question -> id ] ) ] ; } else if ( $ question -> qtype == 'match' ) { $ question -> match = ( object ) [ 'options' => $ this -> readStoreRecord ( 'qtype_match_options' , [ 'questionid' => $ question -> id ] ) , 'subquestions' => $ this -> readStoreRecords ( 'qtype_match_subquestions' , [ 'questionid' => $ question -> id ] ) ] ; } else if ( strpos ( $ question -> qtype , 'calculated' ) === 0 ) { $ question -> calculated = ( object ) [ 'answers' => $ this -> readStoreRecords ( 'question_calculated' , [ 'question' => $ question -> id ] ) , 'options' => $ this -> readStoreRecord ( 'question_calculated_options' , [ 'question' => $ question -> id ] ) ] ; } else if ( $ question -> qtype == 'shortanswer' ) { $ question -> shortanswer = ( object ) [ 'options' => $ this -> readStoreRecord ( 'qtype_shortanswer_options' , [ 'questionid' => $ question -> id ] ) ] ; } $ questions [ $ question -> id ] = $ question ; } catch ( \ Exception $ e ) { } } return $ questions ; }
8634	public function setOrderChargeAdjustmentList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'OrderChargeAdjustmentList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
6260	public function getControllerNameAndAction ( Request $ request ) { $ controller = $ this -> _registry -> getController ( ) ; $ name = $ controller -> name ; $ action = $ request -> action ; if ( ! empty ( $ request -> params [ 'plugin' ] ) ) { $ name = Inflector :: camelize ( $ request -> params [ 'plugin' ] ) . '.' . $ name ; } return compact ( 'name' , 'action' ) ; }
1226	private function inside ( array & $ chars , $ delim , $ type ) { $ position = key ( $ chars ) ; $ current = next ( $ chars ) ; $ buffer = '' ; while ( $ current !== $ delim ) { if ( $ current === '\\' ) { $ buffer .= '\\' ; $ current = next ( $ chars ) ; } if ( $ current === false ) { return [ 'type' => self :: T_UNKNOWN , 'value' => $ buffer , 'pos' => $ position ] ; } $ buffer .= $ current ; $ current = next ( $ chars ) ; } next ( $ chars ) ; return [ 'type' => $ type , 'value' => $ buffer , 'pos' => $ position ] ; }
3730	protected function getMatchingIds ( $ objFilter ) { if ( $ objFilter ) { $ arrFilteredIds = $ objFilter -> getMatchingIds ( ) ; if ( $ arrFilteredIds !== null ) { return $ arrFilteredIds ; } } return $ this -> getConnection ( ) -> createQueryBuilder ( ) -> select ( 'id' ) -> from ( $ this -> getTableName ( ) ) -> execute ( ) -> fetchAll ( \ PDO :: FETCH_COLUMN ) ; }
4791	function delete ( ) { if ( $ this -> notORM -> freeze ) { return false ; } $ where = $ this -> whereString ( ) ; if ( empty ( $ where ) ) { throw new Exception ( 'sorry, you can not delete the whole table --dogstar' ) ; } $ return = $ this -> query ( "DELETE" . $ this -> topString ( $ this -> limit ) . " FROM $this->table" . $ where , $ this -> parameters ) ; if ( ! $ return ) { return false ; } return $ return -> rowCount ( ) ; }
7611	public function actionCreate ( ) { $ model = new User ; if ( $ model -> load ( $ _POST ) && $ model -> save ( ) ) { return $ this -> redirect ( [ 'view' , 'id' => $ model -> id ] ) ; } else { return $ this -> render ( 'create' , [ 'model' => $ model , ] ) ; } }
11315	public static function getNormalizedParameters ( array $ data ) { $ params = array ( ) ; $ keys = array_map ( 'PSX\Oauth\Consumer::urlEncode' , array_keys ( $ data ) ) ; $ values = array_map ( 'PSX\Oauth\Consumer::urlEncode' , array_values ( $ data ) ) ; $ data = array_combine ( $ keys , $ values ) ; uksort ( $ data , 'strnatcmp' ) ; foreach ( $ data as $ k => $ v ) { if ( $ k != 'oauth_signature' ) { $ params [ ] = $ k . '=' . $ v ; } } return implode ( '&' , $ params ) ; }
9675	public function allFills ( Spreadsheet $ spreadsheet ) { $ aFills = [ ] ; $ fill0 = new Fill ( ) ; $ fill0 -> setFillType ( Fill :: FILL_NONE ) ; $ aFills [ ] = $ fill0 ; $ fill1 = new Fill ( ) ; $ fill1 -> setFillType ( Fill :: FILL_PATTERN_GRAY125 ) ; $ aFills [ ] = $ fill1 ; $ aStyles = $ this -> allStyles ( $ spreadsheet ) ; foreach ( $ aStyles as $ style ) { if ( ! isset ( $ aFills [ $ style -> getFill ( ) -> getHashCode ( ) ] ) ) { $ aFills [ $ style -> getFill ( ) -> getHashCode ( ) ] = $ style -> getFill ( ) ; } } return $ aFills ; }
7174	public static function path ( $ array , $ path , $ default = null , $ delimiter = null ) { if ( ! static :: is_array ( $ array ) ) { return $ default ; } if ( is_array ( $ path ) ) { $ keys = $ path ; } else { if ( array_key_exists ( $ path , $ array ) ) { return $ array [ $ path ] ; } if ( ! $ delimiter ) { $ delimiter = static :: $ delimiter ; } $ path = trim ( $ path , "{$delimiter} " ) ; $ keys = explode ( $ delimiter , $ path ) ; } do { $ key = array_shift ( $ keys ) ; if ( ctype_digit ( $ key ) ) { $ key = ( int ) $ key ; } if ( isset ( $ array [ $ key ] ) ) { if ( ! $ keys ) { return $ array [ $ key ] ; } if ( ! static :: is_array ( $ array [ $ key ] ) ) { break ; } $ array = $ array [ $ key ] ; } else { break ; } } while ( $ keys ) ; return $ default ; }
1761	protected static function readPhpFileWithoutTags ( $ strName ) { @ trigger_error ( 'Using System::readPhpFileWithoutTags() has been deprecated and will no longer work in Contao 5.0. Use the Contao\CoreBundle\Config\Loader\PhpFileLoader instead.' , E_USER_DEPRECATED ) ; $ rootDir = self :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( strpos ( $ strName , $ rootDir . '/' ) === false ) { $ strName = $ rootDir . '/' . $ strName ; } $ loader = new PhpFileLoader ( ) ; return $ loader -> load ( $ strName ) ; }
4161	public function modifyRelationship ( $ action , $ user ) { if ( true === in_array ( $ action , $ this -> _actions ) && isset ( $ user ) ) { return $ this -> _makeCall ( 'users/' . $ user . '/relationship' , array ( 'action' => $ action ) , 'POST' ) ; } throw new InvalidParameterException ( 'Error: modifyRelationship() - This method requires an action command and the target user id.' ) ; }
4435	public static function fromErrorMessage ( string $ error ) : QlessException { $ area = null ; $ message = $ error ; if ( preg_match ( self :: ERROR_MESSAGE_RE , $ error , $ matches ) > 0 ) { $ area = $ matches [ 'area' ] ; $ message = $ matches [ 'message' ] ; } switch ( true ) { case ( $ area === 'Requeue' && stripos ( $ message , 'does not exist' ) !== false ) : case ( stripos ( $ message , 'Job does not exist' ) !== false ) : return new InvalidJobException ( $ message , $ area ) ; case ( stripos ( $ message , 'Job given out to another worker' ) !== false ) : return new JobLostException ( $ message , $ area ) ; case ( stripos ( $ message , 'Job not currently running' ) !== false ) : default : return new QlessException ( $ message , $ area ) ; } }
3071	protected function saveItemResponses ( $ emptyAllowed = true ) { if ( $ this -> getRequestParameter ( 'itemDefinition' ) && $ this -> getRequestParameter ( 'itemResponse' ) ) { $ itemDefinition = $ this -> getRequestParameter ( 'itemDefinition' ) ; $ serviceContext = $ this -> getServiceContext ( ) ; $ itemResponse = $ this -> getRequestParameter ( 'itemResponse' ) ? json_decode ( $ this -> getRequestParameter ( 'itemResponse' ) , true ) : null ; if ( ! is_null ( $ itemResponse ) && ! empty ( $ itemDefinition ) ) { $ responses = $ this -> getRunnerService ( ) -> parsesItemResponse ( $ serviceContext , $ itemDefinition , $ itemResponse ) ; if ( ! $ emptyAllowed && $ this -> getRunnerService ( ) -> getTestConfig ( ) -> getConfigValue ( 'enableAllowSkipping' ) && ! TestRunnerUtils :: doesAllowSkipping ( $ serviceContext -> getTestSession ( ) ) ) { if ( $ this -> getRunnerService ( ) -> emptyResponse ( $ serviceContext , $ responses ) ) { throw new QtiRunnerEmptyResponsesException ( ) ; } } return $ this -> getRunnerService ( ) -> storeItemResponse ( $ serviceContext , $ itemDefinition , $ responses ) ; } } return false ; }
6558	public function slug ( Entity $ entity ) { $ config = $ this -> config ( ) ; $ value = $ entity -> get ( $ config [ 'field' ] ) ; $ entity -> set ( $ config [ 'slug' ] , strtolower ( Inflector :: slug ( $ value , $ config [ 'replacement' ] ) ) ) ; }
4107	public function showHints ( ) { if ( is_null ( $ this -> showHints ) ) { $ this -> showHints = false ; if ( Mage :: helper ( 'core' ) -> isDevAllowed ( ) ) { if ( Mage :: getSingleton ( 'core/cookie' ) -> get ( 'ath' ) || Mage :: app ( ) -> getRequest ( ) -> get ( 'ath' ) ) { $ this -> showHints = true ; } } } return $ this -> showHints ; }
11861	public function getCompanionId ( ) { if ( $ this -> isForeign && isset ( $ this -> foreignPrimaryKey ) ) { return $ this -> foreignPrimaryKey ; } elseif ( ! $ this -> isForeign && isset ( $ this -> localPrimaryKey ) ) { return $ this -> localPrimaryKey ; } if ( isset ( $ this -> companionObject ) ) { return $ this -> companionObject -> primaryKey ; } return ; }
2437	public function setData ( $ arrData ) { if ( ! \ is_array ( $ arrData ) ) { throw new \ Exception ( 'Array required to set session data' ) ; } foreach ( $ this -> mappedKeys as $ strKey ) { if ( isset ( $ arrData [ $ strKey ] ) ) { $ this -> session -> set ( $ strKey , $ arrData [ $ strKey ] ) ; unset ( $ arrData [ $ strKey ] ) ; } } $ this -> sessionBag -> replace ( $ arrData ) ; }
4695	public function limitBy ( ? int $ limit , int $ offset = null ) : self { $ this -> dirty ( ) ; $ this -> limit = $ limit || $ offset ? [ $ limit , $ offset ] : null ; return $ this ; }
1653	public function getArea ( ) : float { $ area = 0 ; if ( $ this -> getNumberOfPoints ( ) <= 2 ) { return $ area ; } $ referencePoint = $ this -> points [ 0 ] ; $ radius = $ referencePoint -> getEllipsoid ( ) -> getArithmeticMeanRadius ( ) ; $ segments = $ this -> getSegments ( ) ; foreach ( $ segments as $ segment ) { $ point1 = $ segment -> getPoint1 ( ) ; $ point2 = $ segment -> getPoint2 ( ) ; $ x1 = deg2rad ( $ point1 -> getLng ( ) - $ referencePoint -> getLng ( ) ) * cos ( deg2rad ( $ point1 -> getLat ( ) ) ) ; $ y1 = deg2rad ( $ point1 -> getLat ( ) - $ referencePoint -> getLat ( ) ) ; $ x2 = deg2rad ( $ point2 -> getLng ( ) - $ referencePoint -> getLng ( ) ) * cos ( deg2rad ( $ point2 -> getLat ( ) ) ) ; $ y2 = deg2rad ( $ point2 -> getLat ( ) - $ referencePoint -> getLat ( ) ) ; $ area += ( $ x2 * $ y1 - $ x1 * $ y2 ) ; } $ area *= 0.5 * $ radius ** 2 ; return ( float ) abs ( $ area ) ; }
1110	protected function keyForScope ( $ node ) { return implode ( '-' , array_map ( function ( $ column ) use ( $ node ) { $ value = $ node -> getAttribute ( $ column ) ; if ( is_null ( $ value ) ) return 'NULL' ; return $ value ; } , $ node -> getScopedColumns ( ) ) ) ; }
2420	public static function moveResource ( $ strSource , $ strDestination ) { $ objFile = FilesModel :: findByPath ( $ strSource ) ; if ( $ objFile === null ) { $ objFile = static :: addResource ( $ strDestination ) ; } $ strFolder = \ dirname ( $ strDestination ) ; if ( $ strFolder == Config :: get ( 'uploadPath' ) ) { $ objFile -> pid = null ; } else { $ objFolder = FilesModel :: findByPath ( $ strFolder ) ; if ( $ objFolder === null ) { $ objFolder = static :: addResource ( $ strFolder ) ; } $ objFile -> pid = $ objFolder -> uuid ; } $ objFile -> path = $ strDestination ; $ objFile -> name = basename ( $ strDestination ) ; $ objFile -> save ( ) ; if ( $ objFile -> type == 'folder' ) { $ objFiles = FilesModel :: findMultipleByBasepath ( $ strSource . '/' ) ; if ( $ objFiles !== null ) { while ( $ objFiles -> next ( ) ) { $ objFiles -> path = preg_replace ( '@^' . preg_quote ( $ strSource , '@' ) . '/@' , $ strDestination . '/' , $ objFiles -> path ) ; $ objFiles -> save ( ) ; } } } if ( ( $ strPath = \ dirname ( $ strSource ) ) != Config :: get ( 'uploadPath' ) ) { static :: updateFolderHashes ( $ strPath ) ; } if ( ( $ strPath = \ dirname ( $ strDestination ) ) != Config :: get ( 'uploadPath' ) ) { static :: updateFolderHashes ( $ strPath ) ; } return $ objFile ; }
4449	public function pop ( ? string $ worker = null , ? int $ numJobs = null ) { $ workerName = $ worker ? : $ this -> client -> getWorkerName ( ) ; $ jids = json_decode ( $ this -> client -> pop ( $ this -> name , $ workerName , $ numJobs ? : 1 ) , true ) ; $ jobs = [ ] ; array_map ( function ( array $ data ) use ( & $ jobs ) { $ job = new BaseJob ( $ this -> client , $ data ) ; $ job -> setEventsManager ( $ this -> getEventsManager ( ) ) ; $ jobs [ ] = $ job ; } , $ jids ? : [ ] ) ; return $ numJobs === null ? array_shift ( $ jobs ) : $ jobs ; }
9985	private function mapVAlign ( $ vAlign ) { switch ( $ vAlign ) { case Alignment :: VERTICAL_BOTTOM : return 'bottom' ; case Alignment :: VERTICAL_TOP : return 'top' ; case Alignment :: VERTICAL_CENTER : case Alignment :: VERTICAL_JUSTIFY : return 'middle' ; default : return 'baseline' ; } }
3102	public function getStorage ( ) { if ( ! $ this -> storage ) { $ this -> storage = $ this -> getServiceLocator ( ) -> get ( StorageManager :: SERVICE_ID ) ; } return $ this -> storage ; }
8110	public static function start ( ) { $ compatibility = [ self :: SUBSITES => null , ] ; if ( ClassInfo :: exists ( Subsite :: class ) ) { $ compatibility [ self :: SUBSITES ] = Subsite :: $ disable_subsite_filter ; Subsite :: disable_subsite_filter ( true ) ; } return $ compatibility ; }
9261	public function map ( $ route , $ name , $ handler , array $ methods = array ( 'GET' ) ) { foreach ( $ methods as $ method ) { if ( null === $ name ) { $ this -> addRoute ( $ method , $ route , $ handler ) ; } else { $ this -> addNamedRoute ( $ name , $ method , $ route , $ handler ) ; } } }
7193	private function copy ( $ source , $ target , array $ properties ) { $ properties = ( array ) $ properties ; foreach ( $ properties as $ property ) { $ this -> accessor -> setValue ( $ target , $ property , $ this -> accessor -> getValue ( $ source , $ property ) ) ; } }
7775	protected function handleError ( $ field , $ value , $ rule , array $ args ) { $ this -> errors [ $ rule ] [ ] = [ 'field' => $ field , 'value' => $ value , 'args' => $ args , ] ; }
6796	protected function getValues ( $ valueIds , $ language ) { $ queryBuilder = $ this -> getConnection ( ) -> createQueryBuilder ( ) ; $ where = $ this -> getWhereColumn ( ) ? '(' . $ this -> getWhereColumn ( ) . ')' : null ; $ statement = $ this -> getConnection ( ) -> createQueryBuilder ( ) -> select ( 'source.*' ) -> from ( $ this -> getTagSource ( ) , 'source' ) -> where ( $ queryBuilder -> expr ( ) -> in ( 'source.' . $ this -> getIdColumn ( ) , $ valueIds ) ) -> andWhere ( $ queryBuilder -> expr ( ) -> andX ( ) -> add ( 'source.' . $ this -> getTagLangColumn ( ) . '=:lang' ) -> add ( $ where ) ) -> setParameter ( 'lang' , $ language ) -> groupBy ( 'source.' . $ this -> getIdColumn ( ) ) ; if ( $ this -> getTagSortSourceTable ( ) ) { $ statement -> addSelect ( $ this -> getTagSortSourceTable ( ) . '.*' ) ; $ statement -> join ( 's' , $ this -> getTagSortSourceTable ( ) , 'sort' , $ queryBuilder -> expr ( ) -> eq ( 'source.' . $ this -> getIdColumn ( ) , 'sort.id' ) ) ; if ( $ this -> getTagSortSourceColumn ( ) ) { $ statement -> orderBy ( $ this -> getTagSortSourceColumn ( 'sort' ) ) ; } } $ statement -> addOrderBy ( 'source.' . $ this -> getSortingColumn ( ) ) ; return $ statement -> execute ( ) ; }
10358	public static function error ( int $ code , string $ message , string $ file , int $ line ) : bool { if ( ( error_reporting ( ) & $ code ) !== 0 ) { if ( DEVELOPMENT == false && $ code == 8 ) { $ error [ 'code' ] = $ code ; $ error [ 'message' ] = $ message ; $ error [ 'file' ] = $ file ; $ error [ 'line' ] = $ line ; $ error [ 'type' ] = 'ErrorException: ' ; $ codes = array ( E_USER_NOTICE => 'Notice' , ) ; $ error [ 'type' ] .= in_array ( $ error [ 'code' ] , array_keys ( $ codes ) ) ? $ codes [ $ error [ 'code' ] ] : 'Unknown Error' ; ErrorHandler :: writeLogs ( "{$error['type']}: {$error['message']} in {$error['file']} at line {$error['line']}" ) ; } else { throw new \ ErrorException ( $ message , $ code , 0 , $ file , $ line ) ; } } return true ; }
11285	public function isPlaceholder ( $ attributeName ) { $ def = $ this -> model_attributes [ $ attributeName ] ; if ( isset ( $ def [ 'models' ] ) || ( isset ( $ def [ 'model' ] ) && isset ( $ def [ 'usesRefTable' ] ) ) ) { return true ; } return false ; }
1975	public static function findMultipleFilesByFolder ( $ strPath , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ strPath = str_replace ( array ( '\\' , '%' , '_' ) , array ( '\\\\' , '\\%' , '\\_' ) , $ strPath ) ; return static :: findBy ( array ( "$t.type='file' AND $t.path LIKE ? AND $t.path NOT LIKE ?" ) , array ( $ strPath . '/%' , $ strPath . '/%/%' ) , $ arrOptions ) ; }
2071	private function getDateAndTime ( CalendarEventsModel $ objEvent , PageModel $ objPage , $ intStartTime , $ intEndTime , $ span ) { $ strDate = Date :: parse ( $ objPage -> dateFormat , $ intStartTime ) ; if ( $ span > 0 ) { $ strDate = Date :: parse ( $ objPage -> dateFormat , $ intStartTime ) . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'cal_timeSeparator' ] . Date :: parse ( $ objPage -> dateFormat , $ intEndTime ) ; } $ strTime = '' ; if ( $ objEvent -> addTime ) { if ( $ span > 0 ) { $ strDate = Date :: parse ( $ objPage -> datimFormat , $ intStartTime ) . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'cal_timeSeparator' ] . Date :: parse ( $ objPage -> datimFormat , $ intEndTime ) ; } elseif ( $ intStartTime == $ intEndTime ) { $ strTime = Date :: parse ( $ objPage -> timeFormat , $ intStartTime ) ; } else { $ strTime = Date :: parse ( $ objPage -> timeFormat , $ intStartTime ) . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'cal_timeSeparator' ] . Date :: parse ( $ objPage -> timeFormat , $ intEndTime ) ; } } return array ( $ strDate , $ strTime ) ; }
8921	protected function parseRelationship ( $ node ) { $ rel = array ( ) ; $ x = preg_replace ( '/\(.*?\)/' , '' , $ node -> text ( 'marc:subfield[@code="w"]' ) ) ; if ( ! empty ( $ x ) ) { $ rel [ 'id' ] = $ x ; } $ x = $ node -> text ( 'marc:subfield[@code="t"]' ) ; if ( ! empty ( $ x ) ) { $ rel [ 'title' ] = $ x ; } $ x = $ node -> text ( 'marc:subfield[@code="g"]' ) ; if ( ! empty ( $ x ) ) { $ rel [ 'parts' ] = $ x ; } $ x = $ node -> text ( 'marc:subfield[@code="x"]' ) ; if ( ! empty ( $ x ) ) { $ rel [ 'issn' ] = $ x ; } $ x = $ node -> text ( 'marc:subfield[@code="z"]' ) ; if ( ! empty ( $ x ) ) { $ rel [ 'isbn' ] = $ x ; } return $ rel ; }
6384	public function readFeedbackQuestions ( $ id ) { $ questions = $ this -> readStoreRecords ( 'feedback_item' , [ 'feedback' => $ id ] ) ; $ expandedQuestions = [ ] ; foreach ( $ questions as $ index => $ question ) { $ expandedQuestion = $ question ; $ expandedQuestion -> template = $ this -> readStoreRecord ( 'feedback_template' , [ 'id' => $ question -> template ] ) ; $ expandedQuestion -> url = $ this -> cfg -> wwwroot . '/mod/feedback/edit_item.php?id=' . $ question -> id ; $ expandedQuestions [ $ index ] = $ expandedQuestion ; } return $ expandedQuestions ; }
9713	private function writeExternalsheetBiff8 ( ) { $ totalReferences = count ( $ this -> parser -> references ) ; $ record = 0x0017 ; $ length = 2 + 6 * $ totalReferences ; $ supbook_index = 0 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ totalReferences ) ; for ( $ i = 0 ; $ i < $ totalReferences ; ++ $ i ) { $ data .= $ this -> parser -> references [ $ i ] ; } return $ this -> writeData ( $ header . $ data ) ; }
3060	public function getCurrentAssessmentItemRef ( ) { if ( $ this -> isAdaptive ( ) ) { return $ this -> getServiceManager ( ) -> get ( CatService :: SERVICE_ID ) -> getAssessmentItemRefByIdentifier ( $ this -> getCompilationDirectory ( ) [ 'private' ] , $ this -> getCurrentCatItemId ( ) ) ; } else { return $ this -> getTestSession ( ) -> getCurrentAssessmentItemRef ( ) ; } }
12306	protected function __apiUpdateStrict ( string $ id ) { HCLanguages :: where ( 'id' , $ id ) -> update ( $ this -> getStrictRequestParameters ( ) ) ; return $ this -> apiShow ( $ id ) ; }
6977	protected function createAndRegisterGateway ( $ platformName , $ name , array $ config ) { $ platform = $ this -> registry -> getPlatform ( $ platformName ) ; $ gateway = $ platform -> createGateway ( $ name , $ config ) ; if ( $ gateway instanceof Shipment \ AddressResolverAwareInterface ) { $ gateway -> setAddressResolver ( $ this -> registry -> getAddressResolver ( ) ) ; } if ( $ gateway instanceof Shipment \ WeightCalculatorAwareInterface ) { $ gateway -> setWeightCalculator ( $ this -> registry -> getWeightCalculator ( ) ) ; } if ( $ gateway instanceof PersisterAwareInterface ) { $ gateway -> setPersister ( $ this -> registry -> getPersister ( ) ) ; } $ this -> gateways [ $ name ] = $ gateway ; }
5288	protected static function getRequestMethodName ( ) { $ request_engine = self :: $ requestEngine ; if ( $ request_engine == 'curl' && ! function_exists ( 'curl_init' ) ) { trigger_error ( "DetectLanguage::Client - CURL not found, switching to stream" ) ; $ request_engine = self :: $ requestEngine = 'stream' ; } switch ( $ request_engine ) { case 'curl' : return 'requestCurl' ; case 'stream' : return 'requestStream' ; default : throw new Error ( "Invalid request engine: " . $ request_engine ) ; } }
850	public function getTokenOfKindSibling ( $ index , $ direction , array $ tokens = [ ] , $ caseSensitive = true ) { if ( ! self :: isLegacyMode ( ) ) { $ tokens = array_filter ( $ tokens , function ( $ token ) { return $ this -> isTokenKindFound ( $ this -> extractTokenKind ( $ token ) ) ; } ) ; } if ( ! \ count ( $ tokens ) ) { return null ; } while ( true ) { $ index += $ direction ; if ( ! $ this -> offsetExists ( $ index ) ) { return null ; } $ token = $ this [ $ index ] ; if ( $ token -> equalsAny ( $ tokens , $ caseSensitive ) ) { return $ index ; } } }
12057	public function getTarget ( ) { if ( is_null ( $ this -> _target ) && ! empty ( $ this -> possibleTargets ) ) { $ this -> _target = $ this -> possibleTargets [ 0 ] ; } return $ this -> _target ; }
6034	public function setMimeType ( $ mimeType ) { if ( $ mimeType instanceof MimeType ) { $ this -> mimeType = $ mimeType ; } elseif ( is_array ( $ mimeType ) ) { $ this -> mimeType = new MimeType ( $ mimeType ) ; } else { $ this -> mimeType = null ; trigger_error ( 'Argument must be an object of class MimeType. Data loss!' , E_USER_WARNING ) ; } return $ this ; }
9550	public function getPdo ( ) { if ( empty ( $ this -> pdo ) ) { $ this -> pdo = new PDO ( sprintf ( "mysql:host=%s;port=%d" , $ this -> host , $ this -> port ) ) ; $ this -> pdo -> setAttribute ( PDO :: ATTR_DEFAULT_FETCH_MODE , PDO :: FETCH_ASSOC ) ; } return $ this -> pdo ; }
3497	public function addDefaultVisitors ( ) : Http20Builder { if ( $ this -> addedDefaultVisitors ) { return $ this ; } $ this -> addedDefaultVisitors = true ; $ this -> addVisitor ( new AddExpirationHeaderVisitor ( ) ) ; $ this -> addVisitor ( new AddPriorityHeaderVisitor ( ) ) ; $ this -> addVisitor ( new AddApnIdHeaderVisitor ( ) ) ; $ this -> addVisitor ( new AddCollapseIdHeaderVisitor ( ) ) ; return $ this ; }
4913	public function add ( $ name , $ entities = null , array $ options = null ) { if ( $ name instanceof DependencyResult ) { return $ this -> addResult ( $ name ) ; } if ( $ name instanceof \ Traversable ) { return $ this -> addTraversable ( $ name ) ; } if ( is_array ( $ name ) ) { return $ this -> addArray ( $ name ) ; } if ( null === $ entities ) { throw new \ UnexpectedValueException ( '$entities must not be null.' ) ; } return $ this -> addArray ( [ 'name' => $ name , 'entities' => $ entities , 'options' => $ options , ] ) ; }
4533	public function getList ( $ task , Parameters $ parameters = null ) { $ resource = str_replace ( '{id}' , $ task , static :: VARIABLE_LIST ) ; $ options = [ 'headers' => [ 'Accept' => 'application/json' ] , 'query' => ( array ) $ parameters -> toObject ( true ) ] ; $ objects = $ this -> execute ( 'GET' , $ resource , $ options ) ; $ list = [ ] ; foreach ( $ objects as $ name => $ object ) { $ object -> name = $ name ; $ model = static :: toModel ( $ object ) ; $ list [ $ name ] = $ model ; } return $ list ; }
3577	protected function metaQuery ( Builder $ query , $ method , ArgumentBag $ args ) { if ( in_array ( $ method , [ 'pluck' , 'value' , 'aggregate' , 'orderBy' , 'lists' ] ) ) { return $ this -> metaJoinQuery ( $ query , $ method , $ args ) ; } return $ this -> metaHasQuery ( $ query , $ method , $ args ) ; }
1518	public function replaceRelationship ( StoreInterface $ store , UpdateRelationship $ request ) { $ result = $ this -> transaction ( function ( ) use ( $ store , $ request ) { return $ this -> doReplaceRelationship ( $ store , $ request ) ; } ) ; if ( $ this -> isResponse ( $ result ) ) { return $ result ; } return $ this -> reply ( ) -> noContent ( ) ; }
11329	public function getHuman ( ) { if ( is_null ( $ this -> _human ) ) { $ this -> _human = HumanFieldDetector :: test ( $ this -> fieldSchema ) ; } return $ this -> _human ; }
10140	private function readRecordData ( $ data , $ pos , $ len ) { $ data = substr ( $ data , $ pos , $ len ) ; if ( $ this -> encryption == self :: MS_BIFF_CRYPTO_NONE || $ pos < $ this -> encryptionStartPos ) { return $ data ; } $ recordData = '' ; if ( $ this -> encryption == self :: MS_BIFF_CRYPTO_RC4 ) { $ oldBlock = floor ( $ this -> rc4Pos / self :: REKEY_BLOCK ) ; $ block = floor ( $ pos / self :: REKEY_BLOCK ) ; $ endBlock = floor ( ( $ pos + $ len ) / self :: REKEY_BLOCK ) ; if ( $ block != $ oldBlock || $ pos < $ this -> rc4Pos || ! $ this -> rc4Key ) { $ this -> rc4Key = $ this -> makeKey ( $ block , $ this -> md5Ctxt ) ; $ step = $ pos % self :: REKEY_BLOCK ; } else { $ step = $ pos - $ this -> rc4Pos ; } $ this -> rc4Key -> RC4 ( str_repeat ( "\0" , $ step ) ) ; while ( $ block != $ endBlock ) { $ step = self :: REKEY_BLOCK - ( $ pos % self :: REKEY_BLOCK ) ; $ recordData .= $ this -> rc4Key -> RC4 ( substr ( $ data , 0 , $ step ) ) ; $ data = substr ( $ data , $ step ) ; $ pos += $ step ; $ len -= $ step ; ++ $ block ; $ this -> rc4Key = $ this -> makeKey ( $ block , $ this -> md5Ctxt ) ; } $ recordData .= $ this -> rc4Key -> RC4 ( substr ( $ data , 0 , $ len ) ) ; $ this -> rc4Pos = $ pos + $ len ; } elseif ( $ this -> encryption == self :: MS_BIFF_CRYPTO_XOR ) { throw new Exception ( 'XOr encryption not supported' ) ; } return $ recordData ; }
7998	private function getOpenSslEncryptionOptions ( ) { $ options = self :: DEFAULT_OPENSSL_OPTIONS ; if ( $ this -> zero_pad ) { $ options = $ options | OPENSSL_ZERO_PADDING ; } return $ options ; }
7401	private function getErrors ( Form $ form ) { $ errors = array ( ) ; if ( $ form -> isSubmitted ( ) && $ form -> isValid ( ) ) { return $ errors ; } $ id = $ form -> createView ( ) -> vars [ 'id' ] ; foreach ( $ form -> getErrors ( ) as $ error ) { if ( ! isset ( $ errors [ $ id ] ) ) { $ errors [ $ id ] = array ( ) ; } $ errors [ $ id ] [ ] = $ error -> getMessage ( ) ; } foreach ( $ form -> all ( ) as $ child ) { $ errors = array_merge ( $ this -> getErrors ( $ child ) , $ errors ) ; } return $ errors ; }
12097	public function checkSignCode ( array $ params , $ secret ) { if ( false === isset ( $ params [ self :: SIGN_NAMESPACE ] ) ) { return false ; } return $ params [ self :: SIGN_NAMESPACE ] === $ this -> generateSignCode ( $ params , $ secret ) ; }
2563	protected function loadBusinessId ( PointOfRefSearchOptions $ params ) { if ( $ this -> checkAnyNotEmpty ( $ params -> businessCategory , $ params -> businessForeignKey ) ) { $ this -> porFndQryParams -> businessId = new BusinessId ( $ params -> businessCategory , $ params -> businessForeignKey ) ; } }
7937	public function createBackupFTPAccess ( $ domain , $ ipBlock ) { if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; if ( ! $ ipBlock ) throw new BadMethodCallException ( 'Parameter $ipBlock is missing.' ) ; $ payload = array ( 'ftp' => ( 1 == 1 ) , 'ipBlock' => $ ipBlock , 'nfs' => ( 1 == 0 ) , 'cifs' => ( 1 == 0 ) ) ; try { $ r = $ this -> post ( 'dedicated/server/' . $ domain . '/features/backupFTP/access' , array ( 'Content-Type' => 'application/json;charset=UTF-8' ) , json_encode ( $ payload ) ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new ServerException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
1985	public function getOptionsForUser ( BackendUser $ user ) : array { $ this -> loadOptions ( ) ; if ( $ user -> isAdmin ) { $ event = new ImageSizesEvent ( $ this -> options , $ user ) ; } else { $ options = array_map ( static function ( $ val ) { return is_numeric ( $ val ) ? ( int ) $ val : $ val ; } , StringUtil :: deserialize ( $ user -> imageSizes , true ) ) ; $ event = new ImageSizesEvent ( $ this -> filterOptions ( $ options ) , $ user ) ; } $ this -> eventDispatcher -> dispatch ( ContaoCoreEvents :: IMAGE_SIZES_USER , $ event ) ; return $ event -> getImageSizes ( ) ; }
6825	protected function getPaymentAccountNumber ( PaymentMethodInterface $ method , string $ origin ) { foreach ( $ this -> accounts as $ account ) { if ( $ account -> getType ( ) !== AccountingTypes :: TYPE_PAYMENT ) { continue ; } if ( $ account -> getPaymentMethod ( ) !== $ method ) { continue ; } return $ account -> getNumber ( ) ; } throw new LogicException ( sprintf ( "No payment account number configured for payment method '%s' (%s)" , $ method -> getName ( ) , $ origin ) ) ; }
1103	protected function fireMoveEvent ( $ event , $ halt = true ) { if ( ! isset ( static :: $ dispatcher ) ) return true ; $ event = "eloquent.{$event}: " . get_class ( $ this -> node ) ; $ method = $ halt ? 'until' : 'fire' ; return static :: $ dispatcher -> $ method ( $ event , $ this -> node ) ; }
4149	protected function buildMultipart ( $ mimeBoundary , $ filename ) { $ binary = $ this -> getBinaryFile ( $ filename ) ; $ details = pathinfo ( $ filename ) ; $ type = $ this -> supportedMimes ( $ details [ 'extension' ] ) ; $ data = '--' . $ mimeBoundary . static :: EOL ; $ data .= 'Content-Disposition: form-data; name="media"; filename="' . $ details [ 'basename' ] . '"' . static :: EOL ; $ data .= 'Content-Type: application/octet-stream' . static :: EOL . static :: EOL ; $ data .= $ binary . static :: EOL ; $ data .= '--' . $ mimeBoundary . '--' . static :: EOL . static :: EOL ; unset ( $ mimeBoundary , $ filename , $ binary , $ details , $ type ) ; return $ data ; }
12524	public function deserializeJSON ( $ jsonString ) { $ data = json_decode ( $ jsonString ) ; $ this -> setContent ( $ data -> content ) ; $ this -> setContext ( $ data -> context ) ; }
8591	public function setStatus ( $ status ) { if ( ! $ this -> isNumericArray ( $ status ) ) { $ status = array ( $ status ) ; } $ this -> fields [ 'Status' ] [ 'FieldValue' ] = $ status ; return $ this ; }
9485	public function checkCreatable ( ) { if ( property_exists ( $ this , 'id' ) && $ this -> id > 0 ) { throw new \ Exception ( get_class ( $ this ) . " has ID:" . $ this -> id ( ) . " thus not creatable." ) ; } }
9130	public static function create ( $ name , SymfonyRoute $ route , $ method , $ description = '' ) { return new static ( $ name , $ route , $ method , $ description ) ; }
3530	public static function sendUnrealClientPostRequest ( $ endpoint , $ params = null , $ authorization = self :: EPIC_LAUNCHER_AUTHORIZATION , $ oauth = false ) { $ client = new Client ( [ 'http_errors' => false ] ) ; try { $ response = $ client -> post ( $ endpoint , [ 'form_params' => $ params , 'headers' => [ 'User-Agent' => self :: UNREAL_CLIENT_USER_AGENT , 'Authorization' => ( ! $ oauth ) ? 'basic ' . $ authorization : 'bearer ' . $ authorization , 'X-Epic-Device-ID' => self :: generateDeviceId ( ) ] ] ) ; return json_decode ( $ response -> getBody ( ) -> getContents ( ) ) ; } catch ( GuzzleException $ e ) { throw $ e ; } }
1371	protected function make ( array $ data ) { $ validator = $ this -> validatorFactory -> make ( $ data , $ this -> getRules ( ) , $ this -> getMessages ( ) , $ this -> getAttributes ( ) ) ; $ this -> configureValidator ( $ validator ) ; return $ validator ; }
6159	public function createUrl ( $ action , $ model , $ key , $ index ) { if ( $ this -> urlCreator instanceof Closure ) { return call_user_func ( $ this -> urlCreator , $ action , $ model , $ key , $ index ) ; } else { $ params [ 0 ] = $ this -> controller ? $ this -> controller . '/' . $ action : $ action ; return Url :: toRoute ( $ params ) ; } }
11596	public function exec ( $ dwnlBonus ) { $ result = [ ] ; $ mapById = $ this -> hlpDwnlTree -> mapById ( $ dwnlBonus , EBonDwnl :: A_CUST_REF ) ; $ mapTeams = $ this -> hlpDwnlTree -> mapByTeams ( $ dwnlBonus , EBonDwnl :: A_CUST_REF , EBonDwnl :: A_PARENT_REF ) ; foreach ( $ dwnlBonus as $ one ) { $ custId = $ one -> getCustomerRef ( ) ; $ cust = $ mapById [ $ custId ] ; $ tv = $ cust -> getPv ( ) ; if ( isset ( $ mapTeams [ $ custId ] ) ) { $ frontTeam = $ mapTeams [ $ custId ] ; foreach ( $ frontTeam as $ teamMemberId ) { $ member = $ mapById [ $ teamMemberId ] ; $ memberPv = $ member -> getPv ( ) ; $ tv += $ memberPv ; } } $ cust -> setTv ( $ tv ) ; $ result [ $ custId ] = $ cust ; } return $ result ; }
5459	protected function acceptTag ( $ tag ) { if ( $ tag -> getTagName ( ) === 'a' ) { $ this -> page -> addLink ( $ tag ) ; } elseif ( $ tag -> getTagName ( ) === 'base' ) { $ this -> page -> setBase ( $ tag -> getAttribute ( 'href' ) ) ; } elseif ( $ tag -> getTagName ( ) === 'title' ) { $ this -> page -> setTitle ( $ tag ) ; } elseif ( $ this -> isFormElement ( $ tag -> getTagName ( ) ) ) { for ( $ i = 0 ; $ i < count ( $ this -> open_forms ) ; $ i ++ ) { $ this -> open_forms [ $ i ] -> addWidget ( $ tag ) ; } $ this -> last_widget = $ tag ; } }
3256	public function map ( Router $ router ) { $ router -> group ( [ 'namespace' => 'Amsgames\LaravelShop\Http\Controllers' ] , function ( $ router ) { $ router -> group ( [ 'prefix' => 'shop' ] , function ( $ router ) { $ router -> get ( 'callback/payment/{status}/{id}/{shoptoken}' , [ 'as' => 'shop.callback' , 'uses' => 'Shop\CallbackController@process' ] ) ; $ router -> post ( 'callback/payment/{status}/{id}/{shoptoken}' , [ 'as' => 'shop.callback' , 'uses' => 'Shop\CallbackController@process' ] ) ; } ) ; } ) ; }
11932	protected function generateOption ( $ key , $ value ) { $ option = new FieldOption ( ) ; $ option -> setKey ( $ key ) ; $ option -> setValue ( $ value ) ; return $ option ; }
3359	public function preview ( $ width , $ height ) { if ( ! $ width || ! $ height ) { throw new \ Exception ( 'Please, provide both width and height for preview' ) ; } $ result = clone $ this ; $ result -> operations [ ] [ 'preview' ] = array ( 'width' => $ width , 'height' => $ height , ) ; return $ result ; }
3361	private function exists ( $ offset = null ) { return isset ( $ this -> container [ $ offset !== null ? $ offset : $ this -> position ] ) ; }
1173	public function setDelegatedValidator ( DelegatedValidator $ validator ) { $ this -> validator = $ validator ; $ this -> rules -> setDelegatedValidator ( $ validator ) ; $ this -> messages -> setDelegatedValidator ( $ validator ) ; }
4661	public function send ( ) { $ eventManager = $ this -> getManager ( ) -> getEventsManager ( ) ; if ( $ eventManager ) { $ result = $ eventManager -> fire ( 'mailer:beforeSend' , $ this ) ; } else { $ result = true ; } if ( $ result === false ) { return false ; } $ this -> failedRecipients = [ ] ; $ queue = $ this -> getManager ( ) -> getQueue ( ) ; if ( $ this -> auth ) { $ queue -> putInTube ( $ this -> queueName , [ 'message' => $ this -> getMessage ( ) , 'auth' => $ this -> smtp , ] ) ; } else { $ queue -> putInTube ( $ this -> queueName , $ this -> getMessage ( ) ) ; } }
8963	private static function extractDateCriteria ( $ key , array $ criteria ) { $ date = ( ! empty ( $ criteria [ $ key ] ) ) ? $ criteria [ $ key ] : null ; if ( is_string ( $ date ) ) { $ date = \ DateTime :: createFromFormat ( 'Y-m-d' , $ date ) ; } if ( false === $ date ) { throw new InvalidArgumentException ( sprintf ( 'Invalid date/time format provided "%s", expected "%s", or instance of \DateTime class.' , $ criteria [ $ key ] , 'Y-m-d' ) ) ; } return $ date ; }
12705	public function getContentAttribute ( $ value ) { if ( $ value === null ) { $ value = '' ; } if ( getenv ( "BYPASS_HOOKS" ) != true ) { global $ hooks , $ codes ; return markdown_interpreter ( $ hooks -> apply_filters ( "TCT-Core-Main-Model-Page-Content" , $ codes -> do_shortcode ( $ value ) ) ) ; } else { return $ value ; } }
2555	protected static function loadCorpNegoFare ( $ corporateNegoFare ) { $ opt = [ ] ; if ( $ corporateNegoFare !== null ) { $ po = new PricingOptionGroup ( PricingOptionKey :: OPTION_CORPORATE_NEGOTIATED_FARES ) ; $ po -> optionDetail = new OptionDetail ( $ corporateNegoFare ) ; $ opt [ ] = $ po ; } return $ opt ; }
8721	protected function getTranslatableAttributesFromSchema ( ) { if ( ( ! $ con = $ this -> getConnection ( ) ) || ( ! $ builder = $ con -> getSchemaBuilder ( ) ) ) { return [ ] ; } if ( $ columns = TranslatableConfig :: cacheGet ( $ this -> getI18nTable ( ) ) ) { return $ columns ; } $ columns = $ builder -> getColumnListing ( $ this -> getI18nTable ( ) ) ; unset ( $ columns [ array_search ( $ this -> getForeignKey ( ) , $ columns ) ] ) ; TranslatableConfig :: cacheSet ( $ this -> getI18nTable ( ) , $ columns ) ; return $ columns ; }
1540	public function withQualifiedColumn ( $ column ) { $ parts = explode ( '.' , $ column ) ; if ( ! isset ( $ parts [ 1 ] ) ) { throw new \ InvalidArgumentException ( 'Expecting a valid qualified column name.' ) ; } $ this -> withColumn ( $ parts [ 1 ] ) ; return $ this ; }
10976	public function sendVerification ( ) { $ this -> setVerificationCode ( $ this -> createVerificationCode ( ) ) ; $ user = & $ this ; return Mail :: queue ( Config :: get ( 'verifier.template' ) , [ 'user' => $ this ] , function ( $ message ) use ( $ user ) { $ message -> to ( $ user -> email , $ user -> getVerificationEmailName ( ) ) -> subject ( $ user -> getVerificationEmailSubject ( ) ) ; } ) ; }
8576	public function setItemChargeAdjustmentList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ItemChargeAdjustmentList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
11458	public function batchPageSummary ( $ timestamp , $ pageIndex ) { $ params = [ 'date' => $ timestamp , 'page_index' => $ pageIndex , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_PAGE_LIST , $ params ] ) ; }
8260	protected function saveLoginInfo ( $ resourceOwner ) { $ u = new User ( ) ; $ u -> setAuthenticated ( true ) ; $ u -> setAuthenticator ( $ this -> getName ( ) ) ; $ attrMap = $ this -> providerConfig [ 'attributeMap' ] ; $ userIdAttr = $ attrMap [ 'userId' ] ; $ userId = $ this -> getResourceAttribute ( $ userIdAttr , $ resourceOwner ) ; $ u -> setId ( $ userId ) ; unset ( $ attrMap [ 'userId' ] ) ; if ( isset ( $ attrMap [ 'displayName' ] ) ) { $ name = $ this -> getResourceAttribute ( $ attrMap [ 'displayName' ] , $ resourceOwner ) ; $ u -> setDisplayName ( $ name ) ; unset ( $ attrMap [ 'displayName' ] ) ; } foreach ( $ attrMap as $ mapKey => $ mapValue ) { $ value = $ this -> getResourceAttribute ( $ mapValue , $ resourceOwner ) ; $ u -> setAttribute ( $ mapKey , $ value ) ; } $ u -> setGroups ( $ this -> providerConfig [ 'default' ] [ 'groups' ] ) ; foreach ( $ this -> providerConfig [ 'default' ] [ 'attributes' ] as $ key => $ value ) { if ( null === $ u -> getAttribute ( $ key ) ) { $ u -> setAttribute ( $ key , $ value ) ; } } $ this -> picoAuth -> setUser ( $ u ) ; $ this -> picoAuth -> afterLogin ( ) ; }
7095	private function throwIllegalOperationIfItemIsImmutable ( ResourceEventInterface $ event ) { if ( $ event -> getHard ( ) ) { return ; } $ item = $ this -> getSaleItemFromEvent ( $ event ) ; if ( $ item -> isImmutable ( ) ) { throw new IllegalOperationException ( 'ekyna_commerce.sale.message.immutable_element' ) ; } }
7547	function getEncoding ( ) { $ root = $ this -> getRoot ( ) ; if ( $ root !== null ) { if ( $ enc = $ root -> select ( 'meta[charset]' , 0 , true , true ) ) { return $ enc -> getAttribute ( "charset" ) ; } elseif ( $ enc = $ root -> select ( '"?xml"[encoding]' , 0 , true , true ) ) { return $ enc -> getAttribute ( "encoding" ) ; } elseif ( $ enc = $ root -> select ( 'meta[content*="charset="]' , 0 , true , true ) ) { $ enc = $ enc -> getAttribute ( "content" ) ; return substr ( $ enc , strpos ( $ enc , "charset=" ) + 8 ) ; } } return false ; }
2388	private function implode ( array $ config ) : string { $ palette = '' ; foreach ( $ config as $ legend => $ group ) { if ( \ count ( $ group [ 'fields' ] ) < 1 ) { continue ; } if ( '' !== $ palette ) { $ palette .= ';' ; } if ( ! \ is_int ( $ legend ) ) { $ palette .= sprintf ( '{%s%s},' , $ legend , ( $ group [ 'hide' ] ? ':hide' : '' ) ) ; } $ palette .= implode ( ',' , $ group [ 'fields' ] ) ; } return $ palette ; }
11693	public function run ( ) : Robo \ Result { $ result = $ this -> collectionBuilder ( ) -> taskFilesystemStack ( ) -> mkdir ( $ this -> destination -> getPath ( ) ) -> touch ( $ this -> destination -> getPathname ( ) ) -> run ( ) -> wasSuccessful ( ) ; if ( ! $ result ) { throw new RuntimeException ( 'We can not write to the destination file: ' . $ this -> destination -> getPathname ( ) ) ; } $ asset_contents = '' ; foreach ( $ this -> source as $ file ) { $ this -> printTaskInfo ( 'Compiling - <info>' . $ file . '</info>' ) ; $ asset_contents .= $ this -> getCompiler ( new SplFileInfo ( $ file ) ) -> compile ( ) ; } if ( $ this -> cachebust === true ) { $ this -> bustCacheBalls ( $ asset_contents ) ; } $ this -> writeAsset ( $ asset_contents ) ; return \ Robo \ Result :: success ( $ this ) ; }
1670	public function renameTo ( $ strNewName ) { $ strParent = \ dirname ( $ strNewName ) ; if ( ! is_dir ( $ this -> strRootDir . '/' . $ strParent ) ) { new self ( $ strParent ) ; } $ return = $ this -> Files -> rename ( $ this -> strFolder , $ strNewName ) ; $ syncSource = Dbafs :: shouldBeSynchronized ( $ this -> strFolder ) ; $ syncTarget = Dbafs :: shouldBeSynchronized ( $ strNewName ) ; if ( $ syncSource && $ syncTarget ) { $ this -> objModel = Dbafs :: moveResource ( $ this -> strFolder , $ strNewName ) ; } elseif ( $ syncSource ) { $ this -> objModel = Dbafs :: deleteResource ( $ this -> strFolder ) ; } elseif ( $ syncTarget ) { $ this -> objModel = Dbafs :: addResource ( $ strNewName ) ; } if ( $ return != false ) { $ this -> strFolder = $ strNewName ; } return $ return ; }
6330	private function registerEffect ( string $ type , string $ class ) : void { if ( \ class_exists ( $ class ) ) { $ interfaces = \ class_implements ( $ class ) ; if ( \ in_array ( Effect :: class , $ interfaces , true ) ) { $ this -> effectsMap [ $ type ] = $ class ; } else { throw new ConfigException ( "Class {$class} don't implement interface " . Effect :: class ) ; } } else { throw new ConfigException ( "Class {$class} not found" ) ; } }
9767	function least ( $ value ) : self { $ target = $ this -> hasFlag ( 'length' ) ? $ this -> getLength ( $ this -> target ) : $ this -> target ; return $ this -> expect ( $ target , greaterThanOrEqual ( $ value ) ) ; }
8682	public function setPath ( $ path , $ value ) { Deprecated :: method ( 1.1 , MutableBag :: class ) ; Arr :: set ( $ this -> items , $ path , $ value ) ; }
10702	public static function getPasswordComplexity ( $ password , $ minLength ) { $ group = [ 'upper' => '/[A-Z]/' , 'lower' => '/[a-z]/' , 'number' => '/[0-9]/' , 'special' => '/[^A-Za-z0-9]/' , ] ; $ score = 0 ; $ length = \ strlen ( $ password ) ; if ( $ length < $ minLength ) { return 0 ; } foreach ( $ group as $ pattern ) { if ( preg_match ( $ pattern , $ password ) ) { $ score ++ ; } } if ( $ score < 3 ) { $ score -- ; } if ( $ length > $ minLength ) { $ score += ( int ) floor ( ( $ length - $ minLength ) / 2 ) ; } return $ score ; }
12233	public function moveTo ( SimpleXMLElement $ dst ) { return simplexml_import_dom ( dom_import_simplexml ( $ dst ) , get_class ( $ this ) ) -> appendChild ( $ this -> removeSelf ( ) ) ; }
12298	public function onlyFillablePivot ( $ pivotRelation , $ data ) { $ fillable = $ this -> getPivotFields ( $ pivotRelation , 'pivotColumns' ) ; return array_only ( $ data , $ fillable ) ; }
290	public function __isset ( $ name ) { try { return $ this -> __get ( $ name ) !== null ; } catch ( \ Throwable $ t ) { return false ; } catch ( \ Exception $ e ) { return false ; } }
450	public static function encode ( $ value , $ options = 320 ) { $ expressions = [ ] ; $ value = static :: processData ( $ value , $ expressions , uniqid ( '' , true ) ) ; set_error_handler ( function ( ) { static :: handleJsonError ( JSON_ERROR_SYNTAX ) ; } , E_WARNING ) ; $ json = json_encode ( $ value , $ options ) ; restore_error_handler ( ) ; static :: handleJsonError ( json_last_error ( ) ) ; return $ expressions === [ ] ? $ json : strtr ( $ json , $ expressions ) ; }
10929	public function getCountOf ( string $ strSQL , ? array $ parans = null ) : int { $ r = $ this -> getDataColumn ( $ strSQL , $ parans , "int" ) ; return ( ( $ r === null ) ? 0 : $ r ) ; }
8365	public function createPostTimelineEntry ( EntityPublishedEvent $ event ) : void { $ post = $ event -> getObject ( ) ; if ( ! $ post instanceof Post ) { return ; } $ author = $ this -> user_provider -> loadUserByUsername ( $ post -> getAuthor ( ) ) ; $ post_component = $ this -> action_manager -> findOrCreateComponent ( $ post ) ; $ author_component = $ this -> action_manager -> findOrCreateComponent ( $ author ) ; foreach ( $ post -> getGroups ( ) as $ group ) { $ group_component = $ this -> action_manager -> findOrCreateComponent ( $ group ) ; if ( null === $ post -> getParent ( ) ) { $ verb = 'post' ; } else { $ verb = 'reply' ; } $ action = $ this -> action_manager -> create ( $ author_component , $ verb , [ 'directComplement' => $ post_component , 'indirectComplement' => $ group_component , ] ) ; $ this -> action_manager -> updateAction ( $ action ) ; } }
11174	public static function hash ( $ string , $ algorithm = 'blowfish' ) { switch ( strtolower ( $ algorithm ) ) : case ( 'md5' ) : $ salt = '$1$' . ( static :: rand ( 12 ) ) . '$' ; break ; case ( 'sha256' ) : $ salt = '$5$rounds=5000$' . ( static :: rand ( 16 ) ) . '$' ; break ; case ( 'sha512' ) : $ salt = '$6$rounds=5000$' . ( static :: rand ( 16 ) ) . '$' ; break ; case ( 'blowfish' ) : default : $ salt = '$2a$09$' . ( static :: rand ( 22 ) ) . '$' ; break ; endswitch ; return base64_encode ( crypt ( $ string , $ salt ) ) ; }
8937	public function readChangeset ( $ id ) { $ base = 'changeset/' . $ id ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ xmlString = $ this -> sendRequest ( $ path ) ; return $ xmlString -> changeset ; }
9606	public function multiplyByScalar ( $ scalar ) { $ result = [ ] ; foreach ( $ this -> components ( ) as $ i => $ component ) { $ result [ $ i ] = $ component * $ scalar ; } return new static ( $ result ) ; }
10454	public function resetPassword ( $ user , $ password ) { $ user -> password = $ password ; $ user -> reset_token = null ; $ user -> save ( ) ; }
9238	private function getTextualPath ( array $ path , Vertex $ startVertex ) { $ currentVertex = $ startVertex ; $ currentTable = $ currentVertex -> getId ( ) ; $ textPath = $ currentTable ; foreach ( $ path as $ edge ) { if ( $ fk = $ edge -> getAttribute ( 'fk' ) ) { if ( $ fk -> getForeignTableName ( ) == $ currentTable ) { $ currentTable = $ fk -> getLocalTable ( ) -> getName ( ) ; $ isForward = false ; } else { $ currentTable = $ fk -> getForeignTableName ( ) ; $ isForward = true ; } $ columns = implode ( ',' , $ fk -> getLocalColumns ( ) ) ; $ textPath .= ' ' . ( ! $ isForward ? '<' : '' ) ; $ textPath .= '--(' . $ columns . ')--' ; $ textPath .= ( $ isForward ? '>' : '' ) . ' ' ; $ textPath .= $ currentTable ; } elseif ( $ junctionTable = $ edge -> getAttribute ( 'junction' ) ) { $ junctionFks = array_values ( $ junctionTable -> getForeignKeys ( ) ) ; $ fk = $ junctionFks [ 0 ] ; if ( $ fk -> getForeignTableName ( ) == $ currentTable ) { $ currentTable = $ junctionFks [ 1 ] -> getForeignTableName ( ) ; } else { $ currentTable = $ fk -> getForeignTableName ( ) ; } $ textPath .= ' <=(' . $ junctionTable -> getName ( ) . ')=> ' . $ currentTable ; } else { throw new SchemaAnalyzerException ( 'Unexpected edge. We should have a fk or a junction attribute.' ) ; } } return $ textPath ; }
12579	public function previewImageByName ( $ message , $ to ) { return $ this -> preview ( self :: MSG_TYPE_IMAGE , $ message , $ to , self :: PREVIEW_BY_NAME ) ; }
10445	protected function handleParam ( ) { if ( preg_match ( '/^@([0-9]+)=(.*)$/' , $ this -> getNextLine ( self :: LINE_TYPE_ANY ) , $ part ) ) { $ paramValue = trim ( $ part [ 2 ] , "'" ) ; return [ $ part [ 1 ] => $ paramValue ] ; } return null ; }
11842	private function getBind ( ) { [ $ dsBegin , $ treeType ] = $ this -> extractInput ( ) ; $ calcId = $ this -> getCalcId ( $ dsBegin , $ treeType ) ; $ bind = [ QGrid :: BND_CALC_ID => $ calcId ] ; return $ bind ; }
1627	public function useFiles ( $ path , $ level = 'debug' ) { foreach ( $ this -> loggers as $ logger ) { if ( $ logger instanceof Log ) { $ logger -> useFiles ( $ path , $ level ) ; } } }
7299	public static function sender_to_message ( $ message , $ options , $ id ) { $ author = NULL ; $ commenter = NULL ; $ parts = array ( ) ; if ( 'iac_post_message' == current_filter ( ) ) { $ post = get_post ( $ id ) ; $ author = get_userdata ( $ post -> post_author ) ; if ( ! is_a ( $ author , 'WP_User' ) ) { return $ message ; } $ parts = array ( '' , implode ( ' ' , array ( $ options [ 'static_options' ] [ 'mail_string_by' ] , $ author -> data -> display_name ) ) , implode ( ': ' , array ( $ options [ 'static_options' ] [ 'mail_string_url' ] , get_permalink ( $ post ) ) ) ) ; } elseif ( 'iac_comment_message' == current_filter ( ) ) { $ comment = get_comment ( $ id ) ; $ post = get_post ( $ comment -> comment_post_ID ) ; $ commenter = array ( 'name' => 'Annonymous' ) ; if ( 0 != $ comment -> user_id ) { $ author = get_userdata ( $ comment -> user_id ) ; $ commenter [ 'name' ] = $ author -> data -> display_name ; } else { if ( ! empty ( $ comment -> comment_author ) ) { $ commenter [ 'name' ] = $ comment -> comment_author ; } } $ parts = array ( '' , implode ( ' ' , array ( $ options [ 'static_options' ] [ 'mail_string_by' ] , $ commenter [ 'name' ] , $ options [ 'static_options' ] [ 'mail_string_to' ] , get_the_title ( $ post -> ID ) , ) ) , implode ( ': ' , array ( $ options [ 'static_options' ] [ 'mail_string_url' ] , get_permalink ( $ post ) ) ) ) ; } if ( ! empty ( $ parts ) ) { $ message .= implode ( PHP_EOL , $ parts ) ; } return $ message ; }
2007	public function onKernelException ( GetResponseForExceptionEvent $ event ) : void { $ exception = $ event -> getException ( ) ; if ( $ exception -> getPrevious ( ) instanceof ResourceNotFoundException && ! $ this -> hasRootPages ( ) ) { $ exception = new NoRootPageFoundException ( 'No root page found' , 0 , $ exception ) ; } $ class = $ this -> getTargetClass ( $ exception ) ; if ( null === $ class ) { return ; } if ( null !== ( $ httpException = $ this -> convertToHttpException ( $ exception , $ class ) ) ) { $ event -> setException ( $ httpException ) ; } }
6327	private function getConstraintsSql ( ) { $ sql = '' ; foreach ( $ this -> table -> getConstraints ( ) as $ constraint ) { $ sql .= ',' ; if ( $ constraint instanceof PrimaryKey ) { $ sql .= ( string ) $ constraint ; } elseif ( $ constraint instanceof ForeignKey ) { $ sql .= sprintf ( 'CONSTRAINT %s FOREIGN KEY (%s) REFERENCES %s (%s) MATCH SIMPLE ON UPDATE %s ON DELETE %s' , $ constraint -> getName ( ) , implode ( ',' , $ constraint -> getColumns ( ) ) , $ constraint -> getReferencedTable ( ) -> getQualifiedName ( ) , implode ( ',' , $ constraint -> getReferencedColumns ( ) ) , $ constraint -> getUpdateAction ( ) , $ constraint -> getDeleteAction ( ) ) ; } elseif ( $ constraint instanceof Unique ) { $ sql .= sprintf ( 'CONSTRAINT %s UNIQUE (%s)' , $ constraint -> getName ( ) , implode ( ',' , $ constraint -> getColumns ( ) ) ) ; } } return rtrim ( $ sql , ',' ) ; }
5344	public function make ( $ wsdl , array $ classMap = [ ] ) { return new SoapClient ( $ wsdl , [ 'trace' => true , 'exceptions' => true , 'encoding' => 'utf-8' , 'features' => SOAP_SINGLE_ELEMENT_ARRAYS , 'classmap' => $ classMap , 'cache_wsdl' => WSDL_CACHE_MEMORY , ] ) ; }
10779	private function addSessionCookie ( ResponseInterface $ response ) : ResponseInterface { $ params = session_get_cookie_params ( ) ; $ cookie = new SetCookie ( session_name ( ) , session_id ( ) , time ( ) + $ params [ "lifetime" ] , $ params [ "path" ] , $ params [ "domain" ] , $ params [ "secure" ] , $ params [ "httponly" ] ) ; return $ cookie -> addToResponse ( $ response ) ; }
5596	public function invoke ( $ method ) { $ queue = $ this -> createErrorQueue ( ) ; set_error_handler ( 'SimpleTestErrorHandler' ) ; parent :: invoke ( $ method ) ; restore_error_handler ( ) ; $ queue -> tally ( ) ; }
9024	public function hasDenial ( $ string ) { $ result = false ; $ words = $ this -> getWords ( $ string ) ; foreach ( $ words as $ word ) { if ( in_array ( $ word , $ this -> denialWords ) ) { $ result = true ; } } return $ result ; }
1195	private function getExtensions ( ) { if ( null === $ this -> sorted ) { krsort ( $ this -> extensions ) ; $ this -> sorted = ! empty ( $ this -> extensions ) ? call_user_func_array ( 'array_merge' , $ this -> extensions ) : array ( ) ; } return $ this -> sorted ; }
3835	protected function prepareTemplate ( Template $ objTemplate , $ arrRowData , $ objSettings ) { $ objTemplate -> setData ( array ( 'attribute' => $ this , 'settings' => $ objSettings , 'row' => $ arrRowData , 'raw' => $ arrRowData [ $ this -> getColName ( ) ] , 'additional_class' => $ objSettings -> get ( 'additional_class' ) ? ' ' . $ objSettings -> get ( 'additional_class' ) : '' ) ) ; }
12803	public function getADORecordSet ( ) { if ( ! $ this -> sql ) { throw new Exception ( 'Web2All_Table_Collection_SimpleDataProvider::getADORecordSet: no SQL query set' ) ; } return $ this -> db -> SelectLimit ( $ this -> sql , $ this -> limit , $ this -> offset , $ this -> params ) ; }
4986	public function executeAction ( $ name , array $ data = [ ] ) { if ( false !== strpos ( $ name , '.' ) ) { list ( $ name , $ childKey ) = explode ( '.' , $ name , 2 ) ; $ container = $ this -> getForm ( $ name ) ; return $ container -> executeAction ( $ childKey , $ data ) ; } return [ ] ; }
2159	public function run210Update ( ) { $ this -> Database -> query ( "ALTER TABLE `tl_style` ADD `positioning` char(1) NOT NULL default ''" ) ; $ this -> Database -> query ( "UPDATE `tl_style` SET `positioning`=`size`" ) ; $ this -> Database -> query ( "UPDATE `tl_module` SET `guests`=1 WHERE `type`='lostPassword' OR `type`='registration'" ) ; $ this -> Database -> query ( "UPDATE `tl_news` SET `teaser`=CONCAT('<p>', teaser, '</p>') WHERE `teaser`!='' AND `teaser` NOT LIKE '<p>%'" ) ; }
7177	public static function pluck ( $ array , $ key ) { $ values = array ( ) ; foreach ( $ array as $ row ) { if ( isset ( $ row [ $ key ] ) ) { $ values [ ] = $ row [ $ key ] ; } } return $ values ; }
8044	public static function setProcessTitle ( $ title , array $ replacements = array ( ) ) { if ( trim ( $ title ) == '' || PHP_OS == 'Darwin' ) { return ; } $ title = preg_replace_callback ( '/\%([a-z0-9]+)\%/i' , function ( $ match ) use ( $ replacements ) { if ( isset ( $ replacements [ $ match [ 1 ] ] ) ) { return $ replacements [ $ match [ 1 ] ] ; } return $ match [ 0 ] ; } , $ title ) ; $ title = preg_replace ( '/[^a-z0-9-_.: \\\\\\]\\[]/i' , '' , $ title ) ; if ( function_exists ( 'cli_set_process_title' ) ) { cli_set_process_title ( $ title ) ; } elseif ( function_exists ( 'setproctitle' ) ) { setproctitle ( $ title ) ; } }
12555	public function showAction ( Tag $ tag ) { $ deleteForm = $ this -> createDeleteForm ( $ tag ) ; return array ( 'entity' => $ tag , 'delete_form' => $ deleteForm -> createView ( ) , ) ; }
312	public function run ( ) { try { $ this -> state = self :: STATE_BEFORE_REQUEST ; $ this -> trigger ( self :: EVENT_BEFORE_REQUEST ) ; $ this -> state = self :: STATE_HANDLING_REQUEST ; $ response = $ this -> handleRequest ( $ this -> getRequest ( ) ) ; $ this -> state = self :: STATE_AFTER_REQUEST ; $ this -> trigger ( self :: EVENT_AFTER_REQUEST ) ; $ this -> state = self :: STATE_SENDING_RESPONSE ; $ response -> send ( ) ; $ this -> state = self :: STATE_END ; return $ response -> exitStatus ; } catch ( ExitException $ e ) { $ this -> end ( $ e -> statusCode , isset ( $ response ) ? $ response : null ) ; return $ e -> statusCode ; } }
3034	public function getItems ( \ core_kernel_classes_Class $ itemClass , array $ propertyFilters = [ ] , $ offset = 0 , $ limit = 30 ) { $ data = $ this -> getTreeResourceLookupService ( ) -> getResources ( $ itemClass , [ ] , $ propertyFilters , $ offset , $ limit ) ; return $ this -> formatTreeData ( $ data ) ; }
5197	protected function version ( ) { $ version = explode ( '(' , $ this -> app -> version ( ) ) ; if ( isset ( $ version [ 1 ] ) ) { return substr ( $ version [ 1 ] , 0 , 3 ) ; } return null ; }
2076	public function purgeImageCache ( ) { $ container = System :: getContainer ( ) ; $ strTargetPath = StringUtil :: stripRootDir ( $ container -> getParameter ( 'contao.image.target_dir' ) ) ; $ strRootDir = $ container -> getParameter ( 'kernel.project_dir' ) ; foreach ( scan ( $ strRootDir . '/' . $ strTargetPath ) as $ dir ) { if ( strncmp ( $ dir , '.' , 1 ) !== 0 ) { $ objFolder = new Folder ( $ strTargetPath . '/' . $ dir ) ; $ objFolder -> purge ( ) ; } } $ this -> purgePageCache ( ) ; $ this -> log ( 'Purged the image cache' , __METHOD__ , TL_CRON ) ; }
9037	protected function update ( $ entity , $ where = null , $ tableName = null , HydratorInterface $ hydrator = null ) { if ( ! $ where ) { $ where = 'id = ' . $ entity -> getId ( ) ; } return parent :: update ( $ entity , $ where , $ tableName , $ hydrator ) ; }
9682	function fromXML ( $ xmlElement ) { $ this -> contact = new ReportContact ( ) ; $ this -> contact -> fromXML ( $ xmlElement -> contact ) ; if ( isset ( $ xmlElement -> mailing_id ) ) $ this -> mailingId = $ xmlElement -> mailing_id ; if ( isset ( $ xmlElement -> timestamp ) ) $ this -> timestamp = $ xmlElement -> timestamp ; if ( isset ( $ xmlElement -> link_id ) ) $ this -> linkId = $ xmlElement -> link_id ; if ( isset ( $ xmlElement -> link_url ) ) $ this -> linkUrl = $ xmlElement -> link_url ; if ( isset ( $ xmlElement -> link_tags ) ) { $ this -> linkTags = array ( ) ; foreach ( $ xmlElement -> link_tags -> children ( ) as $ field ) { array_push ( $ this -> linkTags , $ field [ 0 ] ) ; } } }
5402	public function isExpired ( $ now ) { if ( ! $ this -> expiry ) { return true ; } if ( is_string ( $ now ) ) { $ now = strtotime ( $ now ) ; } return ( $ this -> expiry < $ now ) ; }
11987	private function isEndOfLine ( $ i ) { $ ch = $ this -> data [ $ i ] ; if ( $ this -> getLineEndingModeCrlf ( ) ) { if ( $ ch == "\r" ) { $ more_ch = $ i + 1 < strlen ( $ this -> data ) ; if ( $ more_ch ) { $ next_n = $ this -> data [ $ i + 1 ] == "\n" ; if ( $ next_n ) return true ; } } } else { if ( $ ch == "\n" ) return true ; } return false ; }
240	private function saveTableMetadataToCache ( $ cache , $ name ) { if ( $ cache === null ) { return ; } $ metadata = $ this -> _tableMetadata [ $ name ] ; $ metadata [ 'cacheVersion' ] = static :: SCHEMA_CACHE_VERSION ; $ cache -> set ( $ this -> getCacheKey ( $ name ) , $ metadata , $ this -> db -> schemaCacheDuration , new TagDependency ( [ 'tags' => $ this -> getCacheTag ( ) ] ) ) ; }
1731	public static function triggerImportUserHook ( $ username , $ password , $ strTable ) { $ self = new static ( ) ; if ( empty ( $ GLOBALS [ 'TL_HOOKS' ] [ 'importUser' ] ) || ! \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'importUser' ] ) ) { return false ; } @ trigger_error ( 'Using the "importUser" hook has been deprecated and will no longer work in Contao 5.0. Use the contao.import_user event instead.' , E_USER_DEPRECATED ) ; foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'importUser' ] as $ callback ) { $ self -> import ( $ callback [ 0 ] , 'objImport' , true ) ; $ blnLoaded = $ self -> objImport -> { $ callback [ 1 ] } ( $ username , $ password , $ strTable ) ; if ( $ blnLoaded === true ) { return true ; } } return false ; }
10217	public function add ( IComparable $ pSource ) { $ hash = $ pSource -> getHashCode ( ) ; if ( ! isset ( $ this -> items [ $ hash ] ) ) { $ this -> items [ $ hash ] = $ pSource ; $ this -> keyMap [ count ( $ this -> items ) - 1 ] = $ hash ; } }
10116	private function writeHcenter ( ) { $ record = 0x0083 ; $ length = 0x0002 ; $ fHCenter = $ this -> phpSheet -> getPageSetup ( ) -> getHorizontalCentered ( ) ? 1 : 0 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ fHCenter ) ; $ this -> append ( $ header . $ data ) ; }
405	public function addCorsHeaders ( $ response , $ headers ) { if ( empty ( $ headers ) === false ) { $ responseHeaders = $ response -> getHeaders ( ) ; foreach ( $ headers as $ field => $ value ) { $ responseHeaders -> set ( $ field , $ value ) ; } } }
8945	public function replacePreferences ( $ preferences ) { $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = 'user/preferences' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ preferenceList = '' ; if ( ! empty ( $ preferences ) ) { foreach ( $ preferences as $ key => $ value ) { $ preferenceList .= '<preference k="' . $ key . '" v="' . $ value . '"/>' ; } } $ xml = '<?xml version="1.0" encoding="UTF-8"?> <osm version="0.6" generator="JoomlaOpenStreetMap"> <preferences>' . $ preferenceList . '</preferences> </osm>' ; $ header [ 'Content-Type' ] = 'text/xml' ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'PUT' , $ parameters , $ xml , $ header ) ; return $ response -> body ; }
2562	protected function loadGeoCode ( PointOfRefSearchOptions $ params ) { if ( $ this -> checkAllNotEmpty ( $ params -> latitude , $ params -> longitude ) ) { $ this -> porFndQryParams -> geoCode = new GeoCode ( $ params -> longitude , $ params -> latitude ) ; } }
2813	public function initController ( $ controllerAction = null ) { $ controller = Mage :: getModel ( 'sheep_debug/controller' ) ; $ controller -> init ( $ controllerAction ) ; $ this -> action = $ controller ; }
8150	public function initRuntime ( ) { $ this -> runtimeInitialized = true ; foreach ( $ this -> getExtensions ( ) as $ name => $ extension ) { if ( ! $ extension instanceof Twig_Extension_InitRuntimeInterface ) { $ m = new ReflectionMethod ( $ extension , 'initRuntime' ) ; if ( 'Twig_Extension' !== $ m -> getDeclaringClass ( ) -> getName ( ) ) { @ trigger_error ( sprintf ( 'Defining the initRuntime() method in the "%s" extension is deprecated since version 1.23. Use the `needs_environment` option to get the Twig_Environment instance in filters, functions, or tests; or explicitly implement Twig_Extension_InitRuntimeInterface if needed (not recommended).' , $ name ) , E_USER_DEPRECATED ) ; } } $ extension -> initRuntime ( $ this ) ; } }
1432	public function allow ( string ... $ params ) : self { $ this -> all = false ; foreach ( $ params as $ param ) { $ this -> allowed -> put ( $ param , $ param ) ; } return $ this ; }
10007	public function getRibbonBinObjects ( $ what = 'all' ) { $ ReturnData = null ; $ what = strtolower ( $ what ) ; switch ( $ what ) { case 'all' : return $ this -> ribbonBinObjects ; break ; case 'names' : case 'data' : if ( is_array ( $ this -> ribbonBinObjects ) && isset ( $ this -> ribbonBinObjects [ $ what ] ) ) { $ ReturnData = $ this -> ribbonBinObjects [ $ what ] ; } break ; case 'types' : if ( is_array ( $ this -> ribbonBinObjects ) && isset ( $ this -> ribbonBinObjects [ 'data' ] ) && is_array ( $ this -> ribbonBinObjects [ 'data' ] ) ) { $ tmpTypes = array_keys ( $ this -> ribbonBinObjects [ 'data' ] ) ; $ ReturnData = array_unique ( array_map ( [ $ this , 'getExtensionOnly' ] , $ tmpTypes ) ) ; } else { $ ReturnData = [ ] ; } break ; } return $ ReturnData ; }
11436	private function _removeDirectory ( $ sName ) { if ( $ rDirectory = opendir ( $ sName ) ) { while ( ( $ sFile = readdir ( $ rDirectory ) ) !== false ) { if ( $ sFile > '0' && filetype ( $ sName . $ sFile ) == "file" ) { unlink ( $ sName . $ sFile ) ; } elseif ( $ sFile > '0' && filetype ( $ sName . $ sFile ) == "dir" ) { remove_dir ( $ sName . $ sFile . "\\" ) ; } } closedir ( $ rDirectory ) ; rmdir ( $ sName ) ; } }
2414	protected function addTableTlModule ( \ DOMDocument $ xml , \ DOMNode $ tables , Result $ objTheme ) { $ table = $ xml -> createElement ( 'table' ) ; $ table -> setAttribute ( 'name' , 'tl_module' ) ; $ table = $ tables -> appendChild ( $ table ) ; $ this -> loadDataContainer ( 'tl_module' ) ; $ objDcaExtractor = DcaExtractor :: getInstance ( 'tl_module' ) ; $ arrOrder = $ objDcaExtractor -> getOrderFields ( ) ; $ objModule = $ this -> Database -> prepare ( "SELECT * FROM tl_module WHERE pid=? ORDER BY name" ) -> execute ( $ objTheme -> id ) ; while ( $ objModule -> next ( ) ) { $ this -> addDataRow ( $ xml , $ table , $ objModule -> row ( ) , $ arrOrder ) ; } }
4064	private static function calculateDiff ( $ expected , $ actual , $ strict ) { if ( $ expected === $ actual ) { return ; } if ( gettype ( $ expected ) !== gettype ( $ actual ) ) { if ( ! $ strict && self :: isEmptyArrayEquivalent ( $ expected , $ actual ) ) { return ; } throw new \ LogicException ( sprintf ( 'Encountered type %s expected %s (Found %s, expected %s)' , gettype ( $ actual ) , gettype ( $ expected ) , var_export ( $ actual , true ) , var_export ( $ expected , true ) ) , self :: TYPE_MISMATCH ) ; } if ( is_array ( $ expected ) ) { self :: calculateArrayDiff ( $ expected , $ actual , $ strict ) ; } throw new \ LogicException ( sprintf ( 'Found %s expected %s' , var_export ( $ actual , true ) , var_export ( $ expected , true ) ) , self :: VALUE_MISMATCH ) ; }
10363	public function __isset ( $ childName ) { foreach ( $ this -> nodes as $ node ) { if ( isset ( $ node -> $ childName ) ) { return true ; } } return false ; }
8923	public function generate ( $ sourceDocument , $ targetDocument ) { if ( $ sourceDocument === null || $ targetDocument === null ) { return $ targetDocument ; } if ( $ sourceDocument == new \ stdClass ( ) ) { return null ; } if ( is_array ( $ sourceDocument ) ) { if ( $ sourceDocument !== $ targetDocument ) { return $ targetDocument ; } return null ; } $ patchDocument = new \ stdClass ( ) ; $ sourceDocumentVars = get_object_vars ( $ sourceDocument ) ; $ targetDocumentVars = get_object_vars ( $ targetDocument ) ; foreach ( $ targetDocumentVars as $ var => $ value ) { if ( ! in_array ( $ var , array_keys ( $ sourceDocumentVars ) ) || ! in_array ( $ value , array_values ( $ sourceDocumentVars ) ) ) { $ patchDocument -> $ var = $ value ; } } foreach ( $ sourceDocumentVars as $ var => $ value ) { if ( $ targetDocumentVars === [ ] ) { $ patchDocument -> $ var = null ; break ; } if ( is_object ( $ value ) ) { if ( $ sourceDocument -> $ var !== null && is_object ( $ sourceDocument -> $ var ) ) { $ subPatch = $ this -> generate ( $ sourceDocument -> $ var , $ targetDocument -> $ var ) ; if ( $ subPatch !== null ) { $ patchDocument -> $ var = $ subPatch ; } } } elseif ( ! in_array ( $ var , array_keys ( $ targetDocumentVars ) ) || ! in_array ( $ value , array_values ( $ targetDocumentVars ) ) ) { $ sourceDocument -> $ var = null ; if ( ! in_array ( $ var , array_keys ( $ targetDocumentVars ) ) ) { $ patchDocument -> $ var = null ; } } } if ( count ( get_object_vars ( $ patchDocument ) ) > 0 ) { return $ patchDocument ; } return null ; }
400	public static function process ( $ markdown , $ flavor = null ) { $ parser = static :: getParser ( $ flavor ) ; return $ parser -> parse ( $ markdown ) ; }
5476	protected function encode ( ) { $ class = $ this -> encoding ; $ encoding = new $ class ( ) ; for ( $ i = 0 , $ count = count ( $ this -> widgets ) ; $ i < $ count ; $ i ++ ) { $ this -> widgets [ $ i ] -> write ( $ encoding ) ; } return $ encoding ; }
2178	private function addDefaultsToContext ( array $ context ) : array { $ context = array_merge ( $ this -> context , $ context ) ; if ( ! isset ( $ context [ 'request_token' ] ) ) { $ context [ 'request_token' ] = $ this -> getRequestToken ( ) ; } if ( ! isset ( $ context [ 'language' ] ) ) { $ context [ 'language' ] = $ this -> container -> get ( 'translator' ) -> getLocale ( ) ; } if ( ! isset ( $ context [ 'ua' ] ) ) { $ context [ 'ua' ] = $ this -> getUserAgentString ( ) ; } if ( ! isset ( $ context [ 'path' ] ) ) { $ request = $ this -> container -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; if ( null === $ request ) { throw new \ RuntimeException ( 'The request stack did not contain a request' ) ; } $ context [ 'host' ] = $ request -> getHost ( ) ; $ context [ 'path' ] = $ request -> getBasePath ( ) ; } return $ context ; }
10751	public function init ( UserEntity $ user , ServiceManager $ sm ) { $ main = $ sm -> get ( 'neobazaar.service.main' ) ; $ userRepository = $ main -> getUserEntityRepository ( ) ; $ this -> hashId = $ userRepository -> getEncryptedId ( $ user -> getUserId ( ) ) ; $ this -> name = $ user -> getName ( ) ; $ this -> surname = $ user -> getSurname ( ) ; $ this -> email = $ user -> getEmail ( ) ; $ this -> gender = $ user -> getGender ( ) ; $ this -> dateBorn = $ this -> getDateBorn ( $ user , $ sm ) ; $ this -> nicename = $ user -> getNicename ( ) ; $ this -> mobile = $ this -> getMobile ( $ user ) ; $ this -> isAdmin = 'god' == $ user -> getRole ( ) ; $ this -> fullname = $ this -> getFullname ( $ user ) ; $ this -> role = $ user -> getRole ( ) ; $ this -> state = $ user -> getState ( ) ; $ this -> stateFormatted = $ this -> getStateFormatted ( $ user ) ; $ this -> editAddress = '/#/edituseerrr' ; $ this -> isActive = $ user -> getState ( ) == UserEntity :: USER_STATE_ACTIVE ; $ this -> isDeactive = $ user -> getState ( ) == UserEntity :: USER_STATE_DEACTIVE ; $ this -> isDeleted = $ user -> getState ( ) == UserEntity :: USER_STATE_DELETED ; $ this -> isBanned = $ user -> getState ( ) == UserEntity :: USER_STATE_BANNED ; $ this -> count = 'disabled' ; return $ this ; }
4822	public function set ( $ name , $ value ) { if ( ! array_key_exists ( $ name , $ this -> row ) ) { $ this -> addField ( $ name , $ value ) ; } else { $ this -> row [ $ name ] = $ value ; } $ this -> informChanges ( ) ; }
7100	private function equalComparison ( UnitCandidate $ a , UnitCandidate $ b , $ property , $ quantity ) { if ( $ a -> { $ property } == $ quantity && $ b -> { $ property } != $ quantity ) { return - 1 ; } if ( $ a -> { $ property } != $ quantity && $ b -> { $ property } == $ quantity ) { return 1 ; } return false ; }
9786	public function parseEscape ( ) { $ token = $ this -> pop ( 'ESCAPE' ) ; $ value = $ this -> stripQuotes ( $ token [ 1 ] ) ; $ this -> currLine += substr_count ( $ value , "\n" ) ; return '$output .= \'' . $ value . "';\n" ; }
11231	public function post ( $ section , $ body = null , array $ headers = [ ] ) { if ( is_array ( $ body ) ) { $ body = array_merge ( $ this -> parameters , $ body , $ this -> defaultParameters ) ; $ body = http_build_query ( $ body ) ; } return $ this -> client -> post ( $ this -> getUrl ( $ section ) , $ headers , $ body ) ; }
6576	public function stop ( ) : void { if ( $ this -> isStarted ( ) ) { $ this -> getHandler ( ) -> destroy ( $ this -> getDataHolder ( ) -> getId ( ) ) ; $ this -> dataHolder = null ; } }
12538	public function setRelations ( $ value ) { if ( $ this -> companionObject ) { $ baseObject = $ this -> companionObject ; } else { $ baseObject = $ this -> owner ; } $ fields = $ baseObject -> getFields ( ) ; foreach ( $ value as $ tabId => $ relation ) { if ( ! isset ( $ relation [ '_moduleHandler' ] ) ) { \ d ( "boom" ) ; exit ; continue ; } if ( ! isset ( $ fields [ $ relation [ '_moduleHandler' ] ] ) ) { \ d ( $ relation [ '_moduleHandler' ] ) ; \ d ( array_keys ( $ fields ) ) ; exit ; continue ; } $ baseAttributes = [ ] ; $ model = $ fields [ $ relation [ '_moduleHandler' ] ] -> model ; if ( empty ( $ model ) ) { $ model = $ fields [ $ relation [ '_moduleHandler' ] ] -> resetModel ( ) ; } $ model -> attributes = $ relation ; $ model -> _moduleHandler = $ relation [ '_moduleHandler' ] ; $ model -> tabularId = $ relation [ '_moduleHandler' ] ; list ( $ relationship , $ role ) = $ baseObject -> objectType -> getRelationship ( $ model -> _moduleHandler ) ; $ relatedHandler = $ baseObject -> objectType -> getRelatedType ( $ model -> _moduleHandler ) ; if ( ! $ relatedHandler ) { continue ; } if ( ! $ this -> owner -> tabularId && ! $ this -> owner -> isNewRecord && empty ( $ model -> parent_object_id ) && empty ( $ model -> child_object_id ) ) { continue ; } $ this -> _relations [ $ tabId ] = $ model ; } }
8866	private function runTask ( TaskInterface $ task , PayloadInterface $ payload ) { $ this -> logTask ( $ task , LogLevel :: INFO , 'Starting execution.' ) ; try { if ( ! $ task -> unless ( ) ) { $ this -> dispatch ( 'runner.task.unless' , $ task , $ payload ) ; $ this -> logTask ( $ task , LogLevel :: INFO , 'Skipping because unless() returned boolean false.' ) ; return ; } $ this -> dispatch ( 'runner.task.start' , $ task , $ payload ) ; $ task -> setUp ( ) ; $ exitCode = ( int ) $ task -> run ( $ payload ) ? : 0 ; $ task -> tearDown ( ) ; if ( $ task -> isFailOnError ( ) && $ exitCode !== 0 ) { throw new FailException ( sprintf ( 'Task: %s failed with exit code %s' , get_class ( $ task ) , $ exitCode ) ) ; } $ message = sprintf ( 'Task exited with status code %s' , $ exitCode ) ; if ( $ exitCode === 0 ) { $ this -> logTask ( $ task , LogLevel :: INFO , $ message ) ; } else { $ this -> logTask ( $ task , LogLevel :: WARNING , $ message ) ; } $ this -> dispatch ( 'runner.task.success' , $ task , $ payload , $ exitCode ) ; $ task -> markAsSuccessfullyExecuted ( ) ; } catch ( SkipException $ e ) { $ this -> logTask ( $ task , LogLevel :: INFO , 'Skipping.' ) ; $ this -> dispatch ( 'runner.task.skip' , $ task , $ payload ) ; } catch ( RetryException $ e ) { $ this -> logTask ( $ task , LogLevel :: NOTICE , 'Retry thrown. Starting again.' ) ; $ this -> dispatch ( 'runner.task.retry' , $ task , $ payload ) ; if ( ! $ task -> getMaxRetries ( ) ) { throw new LogicException ( 'A retry exception was thrown, but no retries instance was set.' ) ; } $ task -> getMaxRetries ( ) -> increase ( ) ; $ this -> runTask ( $ task , $ payload ) ; return ; } catch ( FailException $ e ) { $ this -> logTask ( $ task , LogLevel :: WARNING , sprintf ( 'Failure thrown. Given message: %s' , $ e -> getMessage ( ) ) ) ; $ exitCode = $ e -> getCode ( ) ; if ( is_int ( $ exitCode ) ) { $ this -> dispatch ( 'runner.task.failure' , $ task , $ payload , $ exitCode ) ; } else { $ this -> dispatch ( 'runner.task.failure' , $ task , $ payload ) ; } throw $ e ; } $ this -> logTask ( $ task , LogLevel :: INFO , 'Execution successful.' ) ; }
7762	public function getContext ( $ exposedClassName ) { $ classes = $ this -> metadata -> getAllMetadata ( ) ; $ metadata = null ; foreach ( $ classes as $ class ) { if ( $ class -> getExposeAs ( ) === $ exposedClassName ) { $ metadata = $ class ; break ; } } if ( null === $ metadata ) { return null ; } $ context = array ( 'hydra' => 'http://www.w3.org/ns/hydra/core#' , 'vocab' => $ this -> vocabUrl . '#' ) ; $ context [ $ exposedClassName ] = ( $ metadata -> isExternalReference ( ) ) ? $ metadata -> getIri ( ) : 'vocab:' . $ metadata -> getIri ( ) ; foreach ( $ metadata -> getProperties ( ) as $ property ) { if ( 0 === strncmp ( $ property -> getExposeAs ( ) , '@' , 1 ) ) { continue ; } $ termDefinition = ( $ property -> isExternalReference ( ) ) ? $ property -> getIri ( ) : 'vocab:' . $ property -> getIri ( ) ; if ( $ property -> getRoute ( ) ) { $ termDefinition = array ( '@id' => $ termDefinition , '@type' => '@id' ) ; } elseif ( $ this -> hasNormalizer ( $ property -> getType ( ) ) ) { $ normalizer = $ this -> getNormalizer ( $ property -> getType ( ) ) ; $ termDefinition = array ( '@id' => $ termDefinition , '@type' => $ normalizer -> getTypeIri ( ) ) ; } $ context [ $ property -> getExposeAs ( ) ] = $ termDefinition ; } return array ( '@context' => $ context ) ; }
12069	public function updateProject ( Project $ project , $ composerJson ) { $ response = $ this -> getResponse ( 'post' , sprintf ( 'v2/projects/%s' , $ project -> getProjectKey ( ) ) , array ( ) , array ( 'project_file' => $ composerJson ) ) ; return $ this -> hydrator -> hydrate ( $ project , $ response ) ; }
3158	public function getResponseVariable ( $ variableIdentifier , $ variableValue ) { if ( ! is_string ( $ variableValue ) && ! is_numeric ( $ variableValue ) ) { $ variableValue = json_encode ( $ variableValue ) ; } $ metaVariable = new \ taoResultServer_models_classes_ResponseVariable ( ) ; $ metaVariable -> setIdentifier ( $ variableIdentifier ) ; $ metaVariable -> setBaseType ( 'string' ) ; $ metaVariable -> setCardinality ( Cardinality :: getNameByConstant ( Cardinality :: SINGLE ) ) ; $ metaVariable -> setValue ( $ variableValue ) ; return $ metaVariable ; }
2730	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ dictionary = $ this -> api -> getSingleDictionary ( $ activeVersion , Config :: AUTH_DICTIONARY_NAME ) ; $ vclPath = Config :: VCL_AUTH_SNIPPET_PATH ; $ snippets = $ this -> config -> getVclSnippets ( $ vclPath ) ; $ status = true ; foreach ( $ snippets as $ key => $ value ) { $ name = Config :: FASTLY_MAGENTO_MODULE . '_basic_auth_' . $ key ; $ status = $ this -> api -> getSnippet ( $ activeVersion , $ name ) ; if ( ! $ status ) { break ; } } if ( ( is_array ( $ dictionary ) && empty ( $ dictionary ) ) || ! isset ( $ dictionary -> id ) ) { return $ result -> setData ( [ 'status' => 'empty' , 'msg' => 'Authentication dictionary does not exist.' ] ) ; } $ authItems = $ this -> api -> dictionaryItemsList ( $ dictionary -> id ) ; if ( ( $ status == true && is_array ( $ authItems ) && count ( $ authItems ) < 2 ) || $ authItems == false ) { return $ result -> setData ( [ 'status' => 'empty' , 'msg' => 'While Basic Authentication is enabled, at least one user must exist.' , ] ) ; } $ itemKey = $ this -> getRequest ( ) -> getParam ( 'item_key_id' ) ; $ deleteItem = $ this -> api -> deleteDictionaryItem ( $ dictionary -> id , $ itemKey ) ; if ( ! $ deleteItem ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to create Dictionary item.' ] ) ; } return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
10259	public function getPhone ( $ state_code = null , $ zip = null , $ include_toll_free = false ) { if ( ! empty ( $ zip ) ) { $ areacodes = Zipcode :: where ( 'zip' , $ zip ) -> orderByRaw ( Database :: random ( ) ) -> first ( ) -> area_codes ; } else { $ state_code = ! empty ( $ state_code ) ? $ state_code : $ this -> getState ( ) -> code ; $ areacodes = Zipcode :: where ( 'state_code' , $ state_code ) -> orderByRaw ( Database :: random ( ) ) -> first ( ) -> area_codes ; } $ code_list = explode ( ',' , $ areacodes ) ; if ( $ include_toll_free === true ) { $ code_list [ ] = 800 ; $ code_list [ ] = 888 ; $ code_list [ ] = 877 ; $ code_list [ ] = 866 ; $ code_list [ ] = 855 ; } $ areacode = $ this -> fromArray ( $ code_list ) ; $ prefix = rand ( 100 , 999 ) ; $ number = rand ( 1 , 9999 ) ; return $ areacode . '-' . $ prefix . '-' . str_pad ( $ number , 4 , '0' , STR_PAD_LEFT ) ; }
4731	public static function unicode_to_utf16 ( $ str ) { if ( \ extension_loaded ( 'mbstring' ) ) { return preg_replace_callback ( '/\\\\u([0-9a-fA-F]{4})/' , function ( $ match ) { return mb_convert_encoding ( pack ( 'H*' , $ match [ 1 ] ) , 'UTF-8' , 'UTF-16BE' ) ; } , $ str ) ; } return $ str ; }
12908	public function update ( FilterRequest $ request , $ id ) { $ this -> fieldManager = $ this -> getFieldManager ( ) ; $ this -> validate ( $ request -> request , $ this -> fieldManager -> update ( ) ) ; $ id = $ this -> getRealId ( $ id ) ; $ resource = $ this -> repository -> update ( $ request -> all ( ) , $ id ) ; if ( ! $ resource ) { } return $ this -> success ( $ resource ) ; }
12917	public function sumValor ( ) { $ tableGateway = new TableGateway ( $ this -> tableName , $ this -> dbAdapter ) ; $ sql = $ tableGateway -> getSql ( ) ; $ select = $ sql -> select ( ) -> columns ( array ( 'sum' => new Expression ( 'SUM(valor)' ) ) ) ; return $ tableGateway -> selectWith ( $ select ) -> current ( ) ; }
4071	public function getJavascripts ( GetOptionsEvent $ event ) { if ( ( $ event -> getEnvironment ( ) -> getDataDefinition ( ) -> getName ( ) !== 'tl_metamodel_rendersettings' ) || ( $ event -> getPropertyName ( ) !== 'additionalJs' ) || ( $ event -> getSubPropertyName ( ) !== 'file' ) ) { return ; } $ event -> setOptions ( $ this -> scanFiles ( 'js' ) ) ; }
5761	public function delete ( int $ id ) : string { if ( null === $ permission = $ this -> getObjectById ( $ id ) ) { throw new Exceptions \ QueryResultsNotFoundException ( ) ; } $ this -> doDeleteTransaction ( $ id ) ; $ title = $ permission -> getTitle ( ) ; unset ( $ permission ) ; return $ title ; }
7069	static function isValid ( $ unit , $ throw = false ) { if ( in_array ( $ unit , static :: getUnits ( ) , true ) ) { return true ; } if ( $ throw ) { throw new InvalidArgumentException ( "Invalid unit '$unit'." ) ; } return false ; }
2293	public static function getThemes ( ) { $ arrReturn = array ( ) ; $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; $ arrThemes = scan ( $ rootDir . '/system/themes' ) ; foreach ( $ arrThemes as $ strTheme ) { if ( strncmp ( $ strTheme , '.' , 1 ) === 0 || ! is_dir ( $ rootDir . '/system/themes/' . $ strTheme ) ) { continue ; } $ arrReturn [ $ strTheme ] = $ strTheme ; } return $ arrReturn ; }
2296	public static function addToUrl ( $ strRequest , $ blnAddRef = true , $ arrUnset = array ( ) ) { $ arrUnset [ ] = 'nb' ; return parent :: addToUrl ( $ strRequest . ( ( $ strRequest != '' ) ? '&amp;' : '' ) . 'rt=' . REQUEST_TOKEN , $ blnAddRef , $ arrUnset ) ; }
4971	public static function convert ( ContentItemInterface $ from , ContentItemInterface $ to ) { $ reflectionFrom = new \ ReflectionClass ( $ from ) ; $ reflectionTo = new \ ReflectionClass ( $ to ) ; foreach ( $ reflectionFrom -> getProperties ( ) as $ property ) { $ property -> setAccessible ( true ) ; $ method = 'set' . ucfirst ( $ property -> getName ( ) ) ; if ( $ reflectionTo -> hasMethod ( $ method ) ) { $ to -> $ method ( $ property -> getValue ( $ from ) ) ; } } return $ to ; }
3428	public function paginate ( $ perPage = 15 , $ pageName = 'page' ) { $ page = Paginator :: resolveCurrentPage ( $ pageName ) ; $ total = $ this -> count ( ) ; $ results = $ this -> forPage ( $ page , $ perPage ) -> getList ( ) ; return new LengthAwarePaginator ( $ results , $ total , $ perPage , $ page , [ 'path' => Paginator :: resolveCurrentPath ( ) , 'pageName' => $ pageName , ] ) ; }
12835	private function generateFactoryCreatorMethod ( FactoredService $ service ) : string { $ factoryMethod = $ service -> getFactoryMethod ( ) ; $ taggedAs = implode ( ', ' , $ service -> getTags ( ) ) ; $ classNormalized = $ this -> normalizeFqcn ( $ service -> getClass ( ) ) ; $ optional = $ service -> getFactoryMethod ( ) -> isOptional ( ) ? '?' : '' ; if ( $ service -> isSingleton ( ) ) { return <<<PHP /** * Get the factored service "{$service->getId()}" (Singleton) * * It is tagged as: {$taggedAs} * * @return {$this->normalizeFqcn($service->getClass())} */ public function {$this->mapIdToServiceGetter($service->getId())} () : {$optional}{$classNormalized} { if (isset(\$this->singletons['{$service->getId()}'])) { return \$this->singletons['{$service->getId()}']; } /** @noinspection OneTimeUseVariablesInspection */ \$service = \$this->singletons['{$service->getId()}'] = {$this->generateCreatorByServiceId($factoryMethod->getFactoryId())}->{$factoryMethod->getMethodName()}({$this->buildInjectionParameters($this->container, $factoryMethod->getInjection())} );{$this->generateSetterInjectionsCode($service)} return \$service; }PHP ; } return <<<PHP /** * Get a fresh instance of service "{$service->getId()}" (Prototype) * * It is tagged as: {$taggedAs} * * @return {$this->normalizeFqcn($service->getClass())} */ public function {$this->mapIdToServiceGetter($service->getId())} () : $classNormalized { \$this->prototypes['{$service->getId()}'] = (\$this->prototypes['{$service->getId()}'] ?? 0) + 1; /** @noinspection OneTimeUseVariablesInspection */ \$service = {$this->generateCreatorByServiceId($factoryMethod->getFactoryId())}->{$factoryMethod->getMethodName()}({$this->buildInjectionParameters($this->container, $factoryMethod->getInjection())} );{$this->generateSetterInjectionsCode($service)} return \$service; }PHP ; }
5448	public function acceptStartToken ( $ token , $ event ) { if ( $ event == LEXER_ENTER ) { $ this -> tag = strtolower ( substr ( $ token , 1 ) ) ; return true ; } if ( $ event == LEXER_EXIT ) { $ success = $ this -> listener -> startElement ( $ this -> tag , $ this -> attributes ) ; $ this -> tag = '' ; $ this -> attributes = array ( ) ; return $ success ; } if ( $ token !== '=' ) { $ this -> current_attribute = strtolower ( html_entity_decode ( $ token , ENT_QUOTES ) ) ; $ this -> attributes [ $ this -> current_attribute ] = '' ; } return true ; }
8458	public function updateDb ( ) { $ this -> printTaskInfo ( 'Do database updates' ) ; $ this -> drush ( 'updb' ) ; $ drushVersion = $ this -> getVersion ( ) ; if ( - 1 === version_compare ( $ drushVersion , '6.0' ) ) { $ this -> printTaskInfo ( 'Will clear cache after db updates for drush ' . $ drushVersion ) ; $ this -> clearCache ( ) ; } else { $ this -> printTaskInfo ( 'Will not clear cache after db updates, since drush ' . $ drushVersion . ' should do it automatically' ) ; } return $ this ; }
3251	public function scopeFindByUser ( $ query , $ userId ) { if ( empty ( $ userId ) ) return ; $ cart = $ query -> whereUser ( $ userId ) -> first ( ) ; if ( empty ( $ cart ) ) { $ cart = call_user_func ( Config :: get ( 'shop.cart' ) . '::create' , [ 'user_id' => $ userId ] ) ; } return $ cart ; }
12346	private function createDeleteForm ( Post $ post ) { return $ this -> createFormBuilder ( ) -> setAction ( $ this -> generateUrl ( 'blog_category_delete' , array ( 'id' => $ post -> getId ( ) ) ) ) -> setMethod ( 'DELETE' ) -> getForm ( ) ; }
8957	public function redaction ( $ element , $ id , $ version , $ redactionId ) { if ( $ element != 'node' && $ element != 'way' && $ element != 'relation' ) { throw new \ DomainException ( 'Element should be a node, a way or a relation' ) ; } $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = $ element . '/' . $ id . '/' . $ version . '/redact?redaction=' . $ redactionId ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'PUT' , $ parameters ) ; return simplexml_load_string ( $ response -> body ) ; }
810	private function toComparableNames ( array $ types , array $ symbolShortNames ) { $ normalized = array_map ( function ( $ type ) use ( $ symbolShortNames ) { $ type = strtolower ( $ type ) ; if ( isset ( $ symbolShortNames [ $ type ] ) ) { return $ symbolShortNames [ $ type ] ; } return $ type ; } , $ types ) ; sort ( $ normalized ) ; return $ normalized ; }
2820	public function getSerializedInfo ( ) { return serialize ( array ( 'logging' => $ this -> getLogging ( ) , 'action' => $ this -> getController ( ) , 'design' => $ this -> getDesign ( ) , 'blocks' => $ this -> getBlocks ( ) , 'models' => $ this -> getModels ( ) , 'collections' => $ this -> getCollections ( ) , 'queries' => $ this -> getQueries ( ) , 'timers' => $ this -> getTimers ( ) , 'emails' => $ this -> getEmails ( ) ) ) ; }
4325	public static function getCallerInfo ( $ offset = 0 ) { $ return = array ( 'file' => null , 'line' => null , 'function' => null , 'class' => null , 'type' => null , ) ; $ backtrace = \ debug_backtrace ( DEBUG_BACKTRACE_IGNORE_ARGS | DEBUG_BACKTRACE_PROVIDE_OBJECT , 8 ) ; $ numFrames = \ count ( $ backtrace ) ; $ regexInternal = '/^' . \ preg_quote ( __NAMESPACE__ ) . '\b/' ; if ( isset ( $ backtrace [ 1 ] [ 'class' ] ) && \ preg_match ( $ regexInternal , $ backtrace [ 1 ] [ 'class' ] ) ) { for ( $ i = $ numFrames - 1 ; $ i >= 0 ; $ i -- ) { if ( isset ( $ backtrace [ $ i ] [ 'class' ] ) && \ preg_match ( $ regexInternal , $ backtrace [ $ i ] [ 'class' ] ) ) { break ; } } } else { $ i = 1 ; } $ i += $ offset ; $ iLine = $ i ; $ iFunc = $ i + 1 ; if ( isset ( $ backtrace [ $ iFunc ] ) && \ in_array ( $ backtrace [ $ iFunc ] [ 'function' ] , array ( 'call_user_func' , 'call_user_func_array' ) ) ) { $ iLine ++ ; $ iFunc ++ ; } elseif ( isset ( $ backtrace [ $ iFunc ] [ 'class' ] ) && $ backtrace [ $ iFunc ] [ 'class' ] == 'ReflectionMethod' && $ backtrace [ $ iFunc ] [ 'function' ] == 'invoke' ) { $ iLine ++ ; $ iFunc -- ; } if ( isset ( $ backtrace [ $ iFunc ] ) ) { $ return = \ array_merge ( $ return , \ array_intersect_key ( $ backtrace [ $ iFunc ] , $ return ) ) ; if ( $ return [ 'type' ] == '->' ) { $ return [ 'class' ] = \ get_class ( $ backtrace [ $ iFunc ] [ 'object' ] ) ; } } if ( isset ( $ backtrace [ $ iLine ] ) ) { $ return [ 'file' ] = $ backtrace [ $ iLine ] [ 'file' ] ; $ return [ 'line' ] = $ backtrace [ $ iLine ] [ 'line' ] ; } else { $ return [ 'file' ] = $ backtrace [ $ numFrames - 1 ] [ 'file' ] ; $ return [ 'line' ] = 0 ; } return $ return ; }
7538	function getRoot ( ) { $ r = $ this -> parent ; $ n = ( $ r === null ) ? null : $ r -> parent ; while ( $ n !== null ) { $ r = $ n ; $ n = $ r -> parent ; } return $ r ; }
4832	public function payout ( ) { if ( ! $ this -> payout_id ) { throw new GoCardless_ClientException ( "Cannot fetch payout for a bill that has not been paid out" ) ; } return GoCardless_Payout :: find_with_client ( $ this -> client , $ this -> payout_id ) ; }
4887	public function createAttachedEntity ( $ entityClass , $ values = [ ] , $ key = null ) { if ( is_string ( $ values ) ) { $ key = $ values ; $ values = [ ] ; } $ entity = $ this -> repositories -> getRepository ( $ entityClass ) -> create ( $ values ) ; $ this -> addAttachedEntity ( $ entity , $ key ) ; return $ entity ; }
10805	protected function build ( ) { $ settings = $ this -> getSettings ( ) ; $ this -> beforeBuild ( ) ; $ configs = $ this -> getConfig ( ) ; $ result = [ $ this -> getType ( ) ] ; $ sp = $ settings [ 'seperator' ] ; $ in = $ settings [ 'indent' ] ; $ si = $ sp . $ in ; foreach ( $ configs as $ pos => $ part ) { if ( isset ( $ this -> before [ $ pos ] ) ) { $ result [ ] = join ( $ sp , $ this -> before [ $ pos ] ) ; } $ built = call_user_func ( [ $ this , $ part [ 'func' ] ] ) ; if ( ! empty ( $ built ) ) { $ prefix = $ part [ 'prefix' ] . ( empty ( $ part [ 'prefix' ] ) ? ( $ part [ 'indent' ] ? $ in : '' ) : $ si ) ; $ result [ ] = $ prefix . join ( $ part [ 'join' ] . $ si , $ built ) ; } if ( isset ( $ this -> after [ $ pos ] ) ) { $ result [ ] = join ( $ sp , $ this -> after [ $ pos ] ) ; } } return join ( $ sp , $ result ) ; }
3829	protected function buildFilterUrl ( $ fragments , $ searchKey ) { @ trigger_error ( sprintf ( '"%1$s" has been deprecated in favor of the "FilterUrlBuilder"' , __METHOD__ ) , E_USER_DEPRECATED ) ; $ url = '' ; $ found = false ; foreach ( $ fragments as $ key => $ value ) { if ( ( $ key == 'language' ) && $ GLOBALS [ 'TL_CONFIG' ] [ 'addLanguageToUrl' ] ) { continue ; } if ( $ key == $ searchKey ) { if ( $ key !== 'auto_item' ) { $ url .= '%s' ; } else { $ url = '%s' . $ url ; } $ found = true ; } else { $ url = $ this -> addUrlParameter ( $ url , $ key , $ value ) ; } } if ( ! $ found ) { if ( $ searchKey !== 'auto_item' ) { $ url .= '%s' ; } else { $ url = '%s' . $ url ; } } return $ url ; }
3664	private function getValueFromSource ( $ source , $ valueName , $ arguments ) { switch ( strtolower ( $ source ) ) { case 'get' : return $ this -> container -> get ( Input :: class ) -> get ( $ valueName ) ; case 'post' : return $ this -> container -> get ( Input :: class ) -> post ( $ valueName ) ; case 'cookie' : return $ this -> container -> get ( Input :: class ) -> cookie ( $ valueName ) ; case 'session' : return $ this -> container -> get ( Session :: class ) -> get ( $ valueName ) ; case 'filter' : if ( is_array ( $ this -> filterParameters ) ) { if ( array_key_exists ( $ valueName , $ this -> filterParameters ) ) { return $ this -> filterParameters [ $ valueName ] ; } return null ; } break ; case 'container' : @ trigger_error ( 'Getting filter values from the service container is deprecated, the container will get removed.' , E_USER_DEPRECATED ) ; return $ this -> getValueFromServiceContainer ( $ valueName , $ arguments ) ; default : } return null ; }
7273	public static function tableName ( ) { $ cc = static :: modelName ( ) ; $ cc [ 0 ] = strtolower ( $ cc [ 0 ] ) ; return preg_replace_callback ( "/[A-Z]/" , function ( $ uppercase ) { return "_" . strtolower ( $ uppercase [ 0 ] ) ; } , $ cc ) . "s" ; }
11469	public function show ( ResponseRequest $ request , Response $ response ) { if ( $ response -> exists ) { $ view = 'forum::response.show' ; } else { $ view = 'forum::response.new' ; } return $ this -> response -> title ( trans ( 'app.view' ) . ' ' . trans ( 'forum::response.name' ) ) -> data ( compact ( 'response' ) ) -> view ( $ view , true ) -> output ( ) ; }
12707	public static function parseSignature ( string $ signature ) : array { $ signature = explode ( ' ' , trim ( $ signature ) ) ; $ command = trim ( $ signature [ 0 ] ) ; $ arguments = [ ] ; $ options = [ ] ; foreach ( $ signature as $ word ) { $ type = self :: determineTypeOfWord ( $ word ) ; if ( $ type == self :: OPTION_TYPE ) { list ( $ key , $ defaultValue ) = self :: parse ( $ word ) ; $ options [ $ key ] = $ defaultValue ; } elseif ( $ type == self :: ARGUMENT_TYPE ) { list ( $ key , $ defaultValue ) = self :: parse ( $ word ) ; $ arguments [ $ key ] = $ defaultValue ; } } return [ $ command , $ arguments , $ options ] ; }
2782	public function renderShadowMark ( $ count , $ current , $ eolInterval = 60 ) { $ this -> progressCount ++ ; $ this -> write ( '<fg=blue;options=bold>S</fg=blue;options=bold>' , false ) ; if ( ( $ this -> progressCount % $ eolInterval ) == 0 ) { $ counter = str_pad ( $ this -> progressCount , 5 , ' ' , STR_PAD_LEFT ) ; $ this -> write ( ' |' . $ counter . ' (' . str_pad ( $ current , strlen ( $ count ) , ' ' , STR_PAD_LEFT ) . '/' . $ count . ')' . PHP_EOL , false ) ; } }
12623	public function fire ( $ eventName , $ infoClass = null ) { if ( isset ( $ this -> events [ $ eventName ] ) ) { foreach ( $ this -> events [ $ eventName ] as $ bind => $ data ) { call_user_func_array ( [ $ data [ 'object' ] , $ data [ 'methodName' ] ] , [ $ infoClass ] ) ; } } }
12652	public function getPageTexts ( $ language ) { if ( ! isset ( $ this -> contents [ $ language ] ) ) { $ this -> contents [ $ language ] = $ this -> readFileContents ( $ language ) ; } return $ this -> contents [ $ language ] ; }
1767	private function getRelativeRequestUri ( Request $ request ) : string { return ( string ) substr ( $ request -> getRequestUri ( ) , \ strlen ( $ request -> getBasePath ( ) ) + 1 ) ; }
8536	public function setRentalChargeList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'RentalChargeList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
4377	protected function buildTableHeader ( $ keys ) { $ headers = array ( ) ; foreach ( $ keys as $ key ) { $ headers [ $ key ] = $ key === MethodTable :: SCALAR ? 'value' : \ htmlspecialchars ( $ key ) ; if ( $ this -> tableInfo [ 'colClasses' ] [ $ key ] ) { $ headers [ $ key ] .= ' ' . $ this -> markupClassname ( $ this -> tableInfo [ 'colClasses' ] [ $ key ] ) ; } } return '<thead>' . "\n" . '<tr><th>&nbsp;</th>' . ( $ this -> tableInfo [ 'haveObjRow' ] ? '<th>&nbsp;</th>' : '' ) . '<th>' . \ implode ( '</th><th scope="col">' , $ headers ) . '</th>' . '</tr>' . "\n" . '</thead>' . "\n" ; }
536	protected function cleanDocComment ( $ doc ) { $ lines = explode ( "\n" , $ doc ) ; $ n = \ count ( $ lines ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ lines [ $ i ] = rtrim ( $ lines [ $ i ] ) ; if ( trim ( $ lines [ $ i ] ) == '*' && trim ( $ lines [ $ i + 1 ] ) == '*' ) { unset ( $ lines [ $ i ] ) ; } } return implode ( "\n" , $ lines ) ; }
2276	public function getActivationDefault ( $ varValue ) { if ( ! trim ( $ varValue ) ) { $ varValue = ( \ is_array ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_module' ] [ 'emailText' ] ) ? $ GLOBALS [ 'TL_LANG' ] [ 'tl_module' ] [ 'emailText' ] [ 1 ] : $ GLOBALS [ 'TL_LANG' ] [ 'tl_module' ] [ 'emailText' ] ) ; } return $ varValue ; }
7148	public function getTotal ( $ discounted = true ) { $ base = $ this -> base ; if ( $ discounted && $ this -> hasDiscounts ( ) ) { foreach ( $ this -> discounts as $ discount ) { $ base -= $ this -> calculateAdjustment ( $ discount , $ base ) ; } } $ total = $ base ; if ( ! empty ( $ this -> taxes ) && $ this -> mode === VatDisplayModes :: MODE_ATI ) { foreach ( $ this -> taxes as $ tax ) { $ total += $ this -> calculateAdjustment ( $ tax , $ base ) ; } } return $ total ; }
8687	public static function replaceRecursive ( $ iterable1 , $ iterable2 ) { Assert :: allIsIterable ( [ $ iterable1 , $ iterable2 ] ) ; if ( $ iterable1 instanceof Traversable ) { $ iterable1 = iterator_to_array ( $ iterable1 ) ; } if ( $ iterable2 instanceof Traversable ) { $ iterable2 = iterator_to_array ( $ iterable2 ) ; } $ merged = $ iterable1 ; foreach ( $ iterable2 as $ key => $ value ) { if ( $ value instanceof Traversable ) { $ value = iterator_to_array ( $ value ) ; } if ( is_array ( $ value ) && static :: isAssociative ( $ value ) && isset ( $ merged [ $ key ] ) && \ is_iterable ( $ merged [ $ key ] ) ) { $ merged [ $ key ] = static :: replaceRecursive ( $ merged [ $ key ] , $ value ) ; } elseif ( $ value === null && isset ( $ merged [ $ key ] ) && \ is_iterable ( $ merged [ $ key ] ) ) { if ( $ merged [ $ key ] instanceof Traversable ) { $ merged [ $ key ] = iterator_to_array ( $ merged [ $ key ] ) ; } continue ; } else { $ merged [ $ key ] = $ value ; } } return $ merged ; }
1101	protected function parentId ( ) { switch ( $ this -> position ) { case 'root' : return NULL ; case 'child' : return $ this -> target -> getKey ( ) ; default : return $ this -> target -> getParentId ( ) ; } }
2286	protected static function agent ( ) { $ ua = static :: get ( 'httpUserAgent' ) ; $ return = new \ stdClass ( ) ; $ return -> string = $ ua ; $ os = 'unknown' ; $ mobile = false ; $ browser = 'other' ; $ shorty = '' ; $ version = '' ; $ engine = '' ; foreach ( Config :: get ( 'os' ) as $ k => $ v ) { if ( stripos ( $ ua , $ k ) !== false ) { $ os = $ v [ 'os' ] ; $ mobile = $ v [ 'mobile' ] ; break ; } } $ return -> os = $ os ; foreach ( Config :: get ( 'browser' ) as $ k => $ v ) { if ( stripos ( $ ua , $ k ) !== false ) { $ browser = $ v [ 'browser' ] ; $ shorty = $ v [ 'shorty' ] ; $ version = preg_replace ( $ v [ 'version' ] , '$1' , $ ua ) ; $ engine = $ v [ 'engine' ] ; break ; } } $ versions = explode ( '.' , $ version ) ; $ version = $ versions [ 0 ] ; $ return -> class = $ os . ' ' . $ browser . ' ' . $ engine ; if ( $ version != '' ) { $ return -> class .= ' ' . $ shorty . $ version ; } if ( $ os == 'android' && $ engine != 'presto' && stripos ( $ ua , 'mobile' ) === false ) { $ mobile = false ; } if ( $ mobile ) { $ return -> class .= ' mobile' ; } $ return -> browser = $ browser ; $ return -> shorty = $ shorty ; $ return -> version = $ version ; $ return -> engine = $ engine ; $ return -> versions = $ versions ; $ return -> mobile = $ mobile ; return $ return ; }
3939	private function setEval ( $ property , $ propInfo , $ isTranslated ) { $ extra = isset ( $ propInfo [ 'eval' ] ) ? $ propInfo [ 'eval' ] : [ ] ; if ( $ isTranslated ) { $ extra [ 'tl_class' ] = 'translat-attr' . ( ! empty ( $ extra [ 'tl_class' ] ) ? ' ' . $ extra [ 'tl_class' ] : '' ) ; } $ property -> setExtra ( array_merge ( ( array ) $ property -> getExtra ( ) , $ extra ) ) ; }
12180	public function getTaxonomyPackage ( ) { if ( empty ( $ this -> taxonomy ) ) { return false ; } $ taxonomySettings = $ this -> taxonomy ; if ( ! is_array ( $ taxonomySettings ) ) { $ taxonomySettings = [ 'id' => $ taxonomySettings ] ; } $ taxonomy = Yii :: $ app -> collectors [ 'taxonomies' ] -> getOne ( $ taxonomySettings [ 'id' ] ) ; if ( empty ( $ taxonomy ) || empty ( $ taxonomy -> object ) ) { return false ; } return $ taxonomy -> package ( $ taxonomySettings ) ; }
906	public function isBinaryOperator ( $ index ) { static $ nonArrayOperators = [ '=' => true , '*' => true , '/' => true , '%' => true , '<' => true , '>' => true , '|' => true , '^' => true , '.' => true , ] ; static $ potentialUnaryNonArrayOperators = [ '+' => true , '-' => true , '&' => true , ] ; static $ arrayOperators ; if ( null === $ arrayOperators ) { $ arrayOperators = [ T_AND_EQUAL => true , T_BOOLEAN_AND => true , T_BOOLEAN_OR => true , T_CONCAT_EQUAL => true , T_DIV_EQUAL => true , T_DOUBLE_ARROW => true , T_IS_EQUAL => true , T_IS_GREATER_OR_EQUAL => true , T_IS_IDENTICAL => true , T_IS_NOT_EQUAL => true , T_IS_NOT_IDENTICAL => true , T_IS_SMALLER_OR_EQUAL => true , T_LOGICAL_AND => true , T_LOGICAL_OR => true , T_LOGICAL_XOR => true , T_MINUS_EQUAL => true , T_MOD_EQUAL => true , T_MUL_EQUAL => true , T_OR_EQUAL => true , T_PLUS_EQUAL => true , T_POW => true , T_POW_EQUAL => true , T_SL => true , T_SL_EQUAL => true , T_SR => true , T_SR_EQUAL => true , T_XOR_EQUAL => true , CT :: T_TYPE_ALTERNATION => true , ] ; if ( \ defined ( 'T_SPACESHIP' ) ) { $ arrayOperators [ T_SPACESHIP ] = true ; } if ( \ defined ( 'T_COALESCE' ) ) { $ arrayOperators [ T_COALESCE ] = true ; } } $ tokens = $ this -> tokens ; $ token = $ tokens [ $ index ] ; if ( $ token -> isArray ( ) ) { return isset ( $ arrayOperators [ $ token -> getId ( ) ] ) ; } if ( isset ( $ nonArrayOperators [ $ token -> getContent ( ) ] ) ) { return true ; } if ( isset ( $ potentialUnaryNonArrayOperators [ $ token -> getContent ( ) ] ) ) { return ! $ this -> isUnaryPredecessorOperator ( $ index ) ; } return false ; }
10056	public function getItem ( $ key ) { if ( $ this -> hasItem ( $ key ) !== true ) { $ this -> data [ $ key ] = new CacheItem ( $ key , null , false ) ; } return $ this -> data [ $ key ] ; }
8375	public function where ( $ where ) { $ this -> where = ( $ where instanceof Condition ? $ where : new Condition ( $ where ) ) ; return $ this ; }
10953	protected function ifModSince ( Request $ request , Response $ response , int $ timestamp ) : Response { $ ifModSince = $ request -> getHeaderLine ( 'If-Modified-Since' ) ; if ( $ ifModSince && $ timestamp <= strtotime ( $ ifModSince ) ) { return $ response -> withStatus ( 304 , "Not Modified" ) ; } return $ response ; }
9541	private function decodeResponse ( Response $ response ) { $ data = json_decode ( $ response -> getBody ( ) -> read ( $ response -> getBody ( ) -> getSize ( ) ) , true ) ; if ( json_last_error ( ) !== JSON_ERROR_NONE ) { throw new ClientException ( 'Unable to parse response body into JSON: ' . json_last_error ( ) ) ; } return $ data === null ? array ( ) : $ data ; }
12760	public static function dispatch ( $ eventName , Event $ event ) { if ( null === self :: $ dispatcher ) { return $ event ; } self :: $ dispatcher -> dispatch ( $ eventName , $ event ) ; DataLogger :: log ( sprintf ( 'The "%s" event was dispatched' , $ eventName ) ) ; if ( $ event -> getAbort ( ) ) { DataLogger :: log ( sprintf ( 'The "%s" event was aborted' , $ eventName ) , DataLogger :: ERROR ) ; throw new EventAbortedException ( $ event -> getAbortMessage ( ) ) ; } return $ event ; }
7701	function OpenDoc_GetPage ( $ Tag , $ Txt , $ Pos , $ Forward , $ LevelStop ) { $ this -> OpenDoc_StylesInit ( ) ; $ p = $ Pos ; while ( ( $ loc = clsTbsXmlLoc :: FindStartTagHavingAtt ( $ Txt , 'text:style-name' , $ p , $ Forward ) ) !== false ) { $ style = $ loc -> GetAttLazy ( 'text:style-name' ) ; if ( ( $ style !== false ) && isset ( $ this -> OpenDoc_Styles [ $ style ] ) ) { $ pbreak = $ this -> OpenDoc_Styles [ $ style ] -> pbreak ; if ( $ pbreak !== false ) { if ( $ Forward ) { if ( $ pbreak === 'before' ) { return $ loc -> PosBeg - 1 ; } else { $ loc -> FindEndTag ( ) ; return $ loc -> PosEnd ; } } else { if ( $ pbreak === 'before' ) { return $ loc -> PosBeg ; } else { $ loc -> FindEndTag ( ) ; return $ loc -> PosEnd + 1 ; } } } } $ p = ( $ Forward ) ? $ loc -> PosEnd : $ loc -> PosBeg ; } if ( $ Forward ) { $ p = strpos ( $ Txt , '</office:text' ) ; if ( $ p === false ) return false ; return $ p - 1 ; } else { $ loc = clsTbsXmlLoc :: FindStartTag ( $ Txt , 'office:text' , $ Pos , false ) ; if ( $ loc === false ) return false ; return $ loc -> PosEnd + 1 ; } }
10434	protected function prepareTypeServiceConfigs ( $ serviceConfig , $ typeConfig , $ type ) { return array_merge ( $ serviceConfig , $ typeConfig [ 'config' ] , [ 'entity_class' => $ typeConfig [ 'entity_class' ] , 'document_class' => $ typeConfig [ 'document_class' ] , 'document_type' => $ type , ] ) ; }
5539	protected function getPublicNameFromIndex ( $ subject ) { foreach ( $ this -> names as $ name => $ index ) { if ( $ subject == $ index ) { return $ name ; } } return $ subject + 1 ; }
2815	public function addCollection ( Varien_Data_Collection_Db $ collection ) { $ info = Mage :: getModel ( 'sheep_debug/collection' ) ; $ info -> init ( $ collection ) ; $ key = $ info -> getClass ( ) ; if ( ! array_key_exists ( $ key , $ this -> collections ) ) { $ this -> collections [ $ key ] = $ info ; } $ this -> collections [ $ key ] -> incrementCount ( ) ; }
4231	public static function findInheritedDoc ( \ Reflector $ reflector ) { $ name = $ reflector -> getName ( ) ; $ reflectionClass = $ reflector -> getDeclaringClass ( ) ; $ interfaces = $ reflectionClass -> getInterfaceNames ( ) ; foreach ( $ interfaces as $ className ) { $ reflectionClass2 = new \ ReflectionClass ( $ className ) ; if ( $ reflectionClass2 -> hasMethod ( $ name ) ) { return self :: getParsed ( $ reflectionClass2 -> getMethod ( $ name ) ) ; } } $ reflectionClass = $ reflectionClass -> getParentClass ( ) ; if ( $ reflectionClass && $ reflectionClass -> hasMethod ( $ name ) ) { return self :: getParsed ( $ reflectionClass -> getMethod ( $ name ) ) ; } }
2693	private function compileFastlyParameters ( ) { if ( isset ( $ this -> fastlyParameters [ 'width' ] ) == false ) { $ this -> fastlyParameters [ 'height' ] = $ this -> _height ; $ this -> fastlyParameters [ 'width' ] = $ this -> _width ; } $ params = [ ] ; foreach ( $ this -> fastlyParameters as $ key => $ value ) { $ params [ ] = $ key . '=' . $ value ; } return implode ( '&' , $ params ) ; }
5769	public function setSql ( ) { $ this -> args [ ] = $ this -> updateOnColumnValue ; $ lastArgNum = count ( $ this -> args ) ; $ this -> sql = "UPDATE $this->dbTable SET $this->setColumnsValues WHERE $this->updateOnColumnName = $" . $ lastArgNum ; }
3337	public function getInputTag ( $ name , $ attributes = array ( ) ) { $ to_compile = array ( ) ; foreach ( $ attributes as $ key => $ value ) { $ to_compile [ ] = sprintf ( '%s="%s"' , $ key , $ value ) ; } return sprintf ( '<input type="hidden" role="uploadcare-uploader" name="%s" data-upload-url-base="" data-integration="%s" %s />' , $ name , $ this -> getIntegrationData ( ) , join ( ' ' , $ to_compile ) ) ; }
9733	public function setARGB ( $ pValue ) { if ( $ pValue == '' ) { $ pValue = self :: COLOR_BLACK ; } if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'argb' => $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> argb = $ pValue ; } return $ this ; }
9419	public function samples ( $ amount ) { if ( ! is_numeric ( $ amount ) || $ amount < 1 ) { throw new \ InvalidArgumentException ( 'Amount of samples must be greater or equal to one' ) ; } $ arr = array ( ) ; for ( $ i = 1 ; $ i <= $ amount ; $ i ++ ) { $ r = new Random ( ) ; $ float_u = $ r -> get ( ) ; $ float_v = $ r -> get ( ) ; $ double_x = $ this -> float_sigma * sqrt ( - 2 * log ( $ float_u ) ) * cos ( 2 * pi ( ) * $ float_v ) + $ this -> float_mu ; if ( $ this -> int_precision ) { $ arr [ ] = round ( $ double_x , $ this -> int_precision ) ; } else { $ arr [ ] = $ double_x ; } } return $ arr ; }
2179	private function generateSymlinks ( ) : void { $ fs = new Filesystem ( ) ; $ fs -> remove ( $ this -> rootDir . '/' . $ this -> webDir . '/' . $ this -> uploadPath ) ; $ fs -> remove ( $ this -> rootDir . '/' . $ this -> webDir . '/system/modules' ) ; $ fs -> remove ( $ this -> rootDir . '/' . $ this -> webDir . '/vendor' ) ; $ this -> symlinkFiles ( $ this -> uploadPath ) ; $ this -> symlinkModules ( ) ; $ this -> symlinkThemes ( ) ; $ this -> symlink ( 'assets' , $ this -> webDir . '/assets' ) ; $ this -> symlink ( 'system/themes' , $ this -> webDir . '/system/themes' ) ; $ this -> symlink ( $ this -> getRelativePath ( $ this -> logsDir ) , 'system/logs' ) ; $ this -> triggerSymlinkEvent ( ) ; }
3175	private function getItemLabel ( RunnerServiceContext $ context , $ itemUri , $ useTitle = false ) { $ label = '' ; if ( $ useTitle ) { $ label = $ context -> getItemIndexValue ( $ itemUri , 'title' ) ; } if ( ! $ label ) { $ label = $ context -> getItemIndexValue ( $ itemUri , 'label' ) ; } if ( ! $ label ) { $ item = new \ core_kernel_classes_Resource ( $ itemUri ) ; $ label = $ item -> getLabel ( ) ; } return $ label ; }
2321	public static function get ( $ image , $ width , $ height , $ mode = '' , $ target = null , $ force = false ) { @ trigger_error ( 'Using Image::get() has been deprecated and will no longer work in Contao 5.0. Use the contao.image.image_factory service instead.' , E_USER_DEPRECATED ) ; if ( $ image == '' ) { return null ; } try { $ imageObj = static :: create ( $ image , array ( $ width , $ height , $ mode ) ) ; $ imageObj -> setTargetPath ( $ target ) ; $ imageObj -> setForceOverride ( $ force ) ; if ( $ path = $ imageObj -> executeResize ( ) -> getResizedPath ( ) ) { return $ path ; } } catch ( \ Exception $ e ) { System :: log ( 'Image "' . $ image . '" could not be processed: ' . $ e -> getMessage ( ) , __METHOD__ , 'ERROR' ) ; } return null ; }
9951	public function duplicateConditionalStyle ( array $ pCellStyle , $ pRange = '' ) { foreach ( $ pCellStyle as $ cellStyle ) { if ( ! ( $ cellStyle instanceof Conditional ) ) { throw new Exception ( 'Style is not a conditional style' ) ; } } list ( $ rangeStart , $ rangeEnd ) = Coordinate :: rangeBoundaries ( $ pRange . ':' . $ pRange ) ; if ( $ rangeStart [ 0 ] > $ rangeEnd [ 0 ] && $ rangeStart [ 1 ] > $ rangeEnd [ 1 ] ) { $ tmp = $ rangeStart ; $ rangeStart = $ rangeEnd ; $ rangeEnd = $ tmp ; } for ( $ col = $ rangeStart [ 0 ] ; $ col <= $ rangeEnd [ 0 ] ; ++ $ col ) { for ( $ row = $ rangeStart [ 1 ] ; $ row <= $ rangeEnd [ 1 ] ; ++ $ row ) { $ this -> setConditionalStyles ( Coordinate :: stringFromColumnIndex ( $ col ) . $ row , $ pCellStyle ) ; } } return $ this ; }
3562	protected function hasMutator ( $ value , $ dir = 'setter' , $ type = null ) { return ( bool ) $ this -> getMutator ( $ value , $ dir , $ type ) ; }
7409	public function & offsetGet ( $ offset ) { if ( ! $ this -> offsetExists ( $ offset ) ) { $ this -> offsetSet ( $ offset , null ) ; if ( null === $ offset ) { end ( $ this -> _container ) ; $ offset = key ( $ this -> _container ) ; } } return $ this -> _container [ $ offset ] ; }
3025	public function postRequest ( $ path , $ options , $ addApiKey ) { if ( isset ( $ options [ 'source' ] ) && is_array ( $ options [ 'source' ] ) ) { $ sources = $ options [ 'source' ] ; unset ( $ options [ 'source' ] ) ; foreach ( $ sources as $ i => $ source ) { $ options [ "source[$i]" ] = $ source ; } } $ response = $ this -> makeRequest ( 'POST' , $ path , $ options , $ addApiKey ) ; return $ this -> parseResponse ( $ response ) ; }
2184	protected function getAllEvents ( $ arrCalendars , $ intStart , $ intEnd ) { if ( ! \ is_array ( $ arrCalendars ) ) { return array ( ) ; } $ this -> arrEvents = array ( ) ; foreach ( $ arrCalendars as $ id ) { $ objEvents = CalendarEventsModel :: findCurrentByPid ( $ id , $ intStart , $ intEnd ) ; if ( $ objEvents === null ) { continue ; } while ( $ objEvents -> next ( ) ) { $ this -> addEvent ( $ objEvents , $ objEvents -> startTime , $ objEvents -> endTime , $ intStart , $ intEnd , $ id ) ; if ( $ objEvents -> recurring ) { $ arrRepeat = StringUtil :: deserialize ( $ objEvents -> repeatEach ) ; if ( ! \ is_array ( $ arrRepeat ) || ! isset ( $ arrRepeat [ 'unit' ] ) || ! isset ( $ arrRepeat [ 'value' ] ) || $ arrRepeat [ 'value' ] < 1 ) { continue ; } $ count = 0 ; $ intStartTime = $ objEvents -> startTime ; $ intEndTime = $ objEvents -> endTime ; $ strtotime = '+ ' . $ arrRepeat [ 'value' ] . ' ' . $ arrRepeat [ 'unit' ] ; while ( $ intEndTime < $ intEnd ) { if ( $ objEvents -> recurrences > 0 && $ count ++ >= $ objEvents -> recurrences ) { break ; } $ intStartTime = strtotime ( $ strtotime , $ intStartTime ) ; $ intEndTime = strtotime ( $ strtotime , $ intEndTime ) ; if ( $ intStartTime === false || $ intEndTime === false ) { break ; } if ( $ intEndTime < $ intStart || $ intStartTime > $ intEnd ) { continue ; } $ this -> addEvent ( $ objEvents , $ intStartTime , $ intEndTime , $ intStart , $ intEnd , $ id ) ; } } } } foreach ( array_keys ( $ this -> arrEvents ) as $ key ) { ksort ( $ this -> arrEvents [ $ key ] ) ; } if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getAllEvents' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getAllEvents' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getAllEvents' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> arrEvents = $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ this -> arrEvents , $ arrCalendars , $ intStart , $ intEnd , $ this ) ; } } return $ this -> arrEvents ; }
8654	private function convertSubmitFeed ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'SubmitFeed' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetMarketplaceIdList ( ) ) { $ marketplaceIdList = $ request -> getMarketplaceIdList ( ) ; foreach ( $ marketplaceIdList -> getId ( ) as $ idIndex => $ id ) { $ parameters [ 'MarketplaceIdList.Id.' . ( $ idIndex + 1 ) ] = $ id ; } } if ( $ request -> isSetFeedType ( ) ) { $ parameters [ 'FeedType' ] = $ request -> getFeedType ( ) ; } if ( $ request -> isSetPurgeAndReplace ( ) ) { $ parameters [ 'PurgeAndReplace' ] = $ request -> getPurgeAndReplace ( ) ? "true" : "false" ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } $ headers = array ( ) ; array_push ( $ headers , "Content-Type: " . $ request -> getContentType ( ) -> toString ( ) ) ; return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ headers ) ; }
615	protected function resolveDependencies ( $ dependencies , $ reflection = null ) { foreach ( $ dependencies as $ index => $ dependency ) { if ( $ dependency instanceof Instance ) { if ( $ dependency -> id !== null ) { $ dependencies [ $ index ] = $ this -> get ( $ dependency -> id ) ; } elseif ( $ reflection !== null ) { $ name = $ reflection -> getConstructor ( ) -> getParameters ( ) [ $ index ] -> getName ( ) ; $ class = $ reflection -> getName ( ) ; throw new InvalidConfigException ( "Missing required parameter \"$name\" when instantiating \"$class\"." ) ; } } } return $ dependencies ; }
1783	protected function countItems ( $ newsArchives , $ blnFeatured ) { if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'newsListCountItems' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'newsListCountItems' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'newsListCountItems' ] as $ callback ) { if ( ( $ intResult = System :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ newsArchives , $ blnFeatured , $ this ) ) === false ) { continue ; } if ( \ is_int ( $ intResult ) ) { return $ intResult ; } } } return NewsModel :: countPublishedByPids ( $ newsArchives , $ blnFeatured ) ; }
8582	public function setAny ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'Any' ] [ 'FieldValue' ] = $ value ; return $ this ; }
12739	public function removeClass ( $ name ) { $ classParts = explode ( ' ' , $ this -> tags [ 'class' ] ) ; $ className = '' ; foreach ( $ classParts as $ part ) { if ( $ name != $ part ) { $ className .= ' ' . $ part ; } } $ this -> tags [ 'class' ] = trim ( $ className ) ; }
11104	protected function registerClientScript ( ) { $ view = $ this -> getView ( ) ; DateTimePickerAssets :: register ( $ view ) ; $ id = $ this -> options [ 'id' ] ; $ options = Json :: encode ( $ this -> clientOptions ) ; $ view -> registerJs ( "jQuery('#$id').datetimepicker($options);" ) ; }
9031	public function execute ( Closure $ callback ) { foreach ( $ this -> getServices ( ) as $ service ) { try { return $ callback ( $ this -> container -> make ( $ service ) ) ; } catch ( Exception $ e ) { } } throw new RuntimeException ( 'Could not execute any service.' ) ; }
1300	private function getLocaleForCacheKey ( string $ locale = null ) : string { if ( $ locale ) { return $ locale ; } return $ this -> getEnvironment ( ) -> getDefaultLocale ( ) -> getCode ( ) ; }
7217	public function getDocumentationClassesList ( ) : array { $ classNames = $ this -> getCmfConfig ( ) -> config ( 'api_documentation.classes' , [ ] ) ; if ( empty ( $ classNames ) ) { $ classNames = $ this -> loadClassesFromFileSystem ( ) ; } return $ classNames ; }
4904	protected function createValueOptions ( NodeInterface $ node , $ allowSelectNodes = false , $ isRoot = true ) { $ key = $ isRoot ? $ node -> getValue ( ) : $ node -> getValueWithParents ( ) ; $ name = $ node -> getName ( ) ; if ( $ node -> hasChildren ( ) ) { $ leafOptions = [ ] ; if ( $ allowSelectNodes && ! $ isRoot ) { $ leafOptions [ $ key ] = $ name ; $ key = "$key-group" ; } foreach ( $ node -> getChildren ( ) as $ child ) { $ leafOptions += $ this -> createValueOptions ( $ child , $ allowSelectNodes , false ) ; } $ value = [ 'label' => $ name , 'options' => $ leafOptions ] ; } else { $ value = $ name ; } return [ $ key => $ value ] ; }
7584	protected function extractResponse ( $ curlResponse ) { $ this -> headers = substr ( $ curlResponse , 0 , $ this -> info [ 'header_size' ] ) ; $ this -> body = substr ( $ curlResponse , $ this -> info [ 'header_size' ] ) ; }
3292	public function twitter ( ) { if ( is_null ( $ this -> title ) ) { $ this -> title = config ( 'laravel-share.services.twitter.text' ) ; } $ base = config ( 'laravel-share.services.twitter.uri' ) ; $ url = $ base . '?text=' . urlencode ( $ this -> title ) . '&url=' . $ this -> url ; $ this -> buildLink ( 'twitter' , $ url ) ; return $ this ; }
2983	protected function makePathRelative ( $ absolutePath ) { $ projectRootDir = dirname ( $ this -> getContainer ( ) -> getParameter ( 'kernel.root_dir' ) ) ; return str_replace ( $ projectRootDir . '/' , '' , realpath ( $ absolutePath ) ? : $ absolutePath ) ; }
1672	public function protect ( ) { if ( ! $ this -> isUnprotected ( ) ) { return ; } if ( ! file_exists ( $ this -> strRootDir . '/' . $ this -> strFolder . '/.public' ) ) { throw new \ RuntimeException ( sprintf ( 'Cannot protect folder "%s" because one of its parent folders is public' , $ this -> strFolder ) ) ; } ( new File ( $ this -> strFolder . '/.public' ) ) -> delete ( ) ; }
5484	public function hasSubmit ( SelectorInterface $ selector ) { foreach ( $ this -> buttons as $ button ) { if ( $ selector -> isMatch ( $ button ) ) { return true ; } } return false ; }
10222	public function authenticationForm ( $ title , $ target ) { $ formFactory = $ this -> app -> make ( 'Label305\AujaLaravel\Factory\AuthenticationFormFactory' ) ; return $ formFactory -> create ( $ title , $ target ) ; }
11282	public function _populate ( $ record = null , $ db = false , $ loadMap = false ) { $ this -> model_hydrating = true ; if ( $ db ) { $ this -> model_db = $ db ; } if ( $ record ) { $ this -> _populateAttributes ( $ record ) ; $ this -> _populateNonModelData ( $ record ) ; } if ( $ this -> model_loadMapsEnabled ) { $ this -> _populateLoadMap ( $ record , $ loadMap ) ; } $ this -> onLoad ( ) ; if ( $ loadMap instanceof \ Cora \ Adm \ LoadMap && $ func = $ loadMap -> getOnLoadFunction ( ) ) { $ args = $ loadMap -> getOnLoadArgs ( ) ; array_unshift ( $ args , $ this ) ; call_user_func_array ( $ func , $ args ) ; } $ this -> model_hydrating = false ; return $ this ; }
3304	public function appendSignature ( array $ params = [ ] , $ timestamp = '' , $ noncestr = '' ) { $ params += [ 'app_id' => $ this -> appId , 'time_stamp' => $ timestamp ? : time ( ) , 'nonce_str' => $ noncestr ? : md5 ( uniqid ( ) ) ] ; if ( isset ( $ params [ 'app_key' ] ) ) { unset ( $ params [ 'app_key' ] ) ; } ksort ( $ params ) ; $ params [ 'sign' ] = strtoupper ( md5 ( http_build_query ( $ params + [ 'app_key' => $ this -> appKey ] ) ) ) ; return $ params ; }
5974	public function filters ( ) { if ( ! $ this -> filters instanceof FiltersController ) { $ this -> filters = new FiltersController ( $ this -> getClient ( ) , $ this -> cachePolicy , $ this -> cache ) ; $ this -> filters -> setLogger ( $ this -> logger ) ; } return $ this -> filters ; }
12365	public function init ( ) { $ config = new Zend_Config_Ini ( $ this -> config_path == null ? APPLICATION_PATH . DS . "configs" . DS . "secret.ini" : $ config_path , APPLICATION_ENV ) ; $ this -> setConsumer ( new Zend_Oauth_Consumer ( array ( 'callbackUrl' => $ config -> oauth -> callback , 'siteUrl' => $ config -> oauth -> siteurl , 'consumerKey' => $ config -> oauth -> consumerkey , 'consumerSecret' => $ config -> oauth -> consumersecret ) ) ) ; }
9998	public function setShadowProperties ( $ sh_presets , $ sh_color_value = null , $ sh_color_type = null , $ sh_color_alpha = null , $ sh_blur = null , $ sh_angle = null , $ sh_distance = null ) { $ this -> activateObject ( ) -> setShadowPresetsProperties ( ( int ) $ sh_presets ) -> setShadowColor ( $ sh_color_value === null ? $ this -> shadowProperties [ 'color' ] [ 'value' ] : $ sh_color_value , $ sh_color_alpha === null ? ( int ) $ this -> shadowProperties [ 'color' ] [ 'alpha' ] : $ this -> getTrueAlpha ( $ sh_color_alpha ) , $ sh_color_type === null ? $ this -> shadowProperties [ 'color' ] [ 'type' ] : $ sh_color_type ) -> setShadowBlur ( $ sh_blur ) -> setShadowAngle ( $ sh_angle ) -> setShadowDistance ( $ sh_distance ) ; }
4773	public function order ( Request $ request , WidgetInterface $ widget , string $ widgetId , int $ order ) { $ widgets = $ widget -> getWidgets ( ) ; if ( isset ( $ widgets [ $ widgetId ] ) ) { $ widgetConfig = $ this -> getDoctrine ( ) -> getRepository ( 'PdWidgetBundle:WidgetUser' ) -> findOneBy ( [ 'owner' => $ this -> getUser ( ) ] ) ?? ( new WidgetUser ( ) ) -> setOwner ( $ this -> getUser ( ) ) ; $ widgetConfig -> addWidgetConfig ( $ widgetId , [ 'order' => $ order ] ) ; $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ em -> persist ( $ widgetConfig ) ; $ em -> flush ( ) ; } return $ this -> json ( [ 'result' => 'success' , ] ) ; }
5483	public function attachLabelBySelector ( SelectorInterface $ selector , $ label ) { for ( $ i = 0 , $ count = count ( $ this -> widgets ) ; $ i < $ count ; $ i ++ ) { if ( $ selector -> isMatch ( $ this -> widgets [ $ i ] ) ) { if ( method_exists ( $ this -> widgets [ $ i ] , 'setLabel' ) ) { $ this -> widgets [ $ i ] -> setLabel ( $ label ) ; return ; } } } }
8666	public function setInvalidASIN ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'InvalidASIN' ] [ 'FieldValue' ] = $ value ; return $ this ; }
41	public static function checkCertificateHost ( $ certificate , $ hostname , & $ cn = null ) { $ names = self :: getCertificateNames ( $ certificate ) ; if ( empty ( $ names ) ) { return false ; } $ combinedNames = array_merge ( $ names [ 'san' ] , array ( $ names [ 'cn' ] ) ) ; $ hostname = strtolower ( $ hostname ) ; foreach ( $ combinedNames as $ certName ) { $ matcher = self :: certNameMatcher ( $ certName ) ; if ( $ matcher && $ matcher ( $ hostname ) ) { $ cn = $ names [ 'cn' ] ; return true ; } } return false ; }
10951	private function validateCsrfTokenInternal ( $ token , $ trueToken ) { $ token = base64_decode ( str_replace ( '.' , '+' , $ token ) ) ; $ n = StringHelper :: byteLength ( $ token ) ; if ( $ n <= static :: CSRF_MASK_LENGTH ) { return false ; } $ mask = StringHelper :: byteSubstr ( $ token , 0 , static :: CSRF_MASK_LENGTH ) ; $ token = StringHelper :: byteSubstr ( $ token , static :: CSRF_MASK_LENGTH , $ n - static :: CSRF_MASK_LENGTH ) ; $ token = $ this -> xorTokens ( $ mask , $ token ) ; return $ token === $ trueToken ; }
1033	private function getPromise ( $ value ) { if ( $ value === null || $ value instanceof Promise ) { return $ value ; } if ( $ this -> exeContext -> promises -> isThenable ( $ value ) ) { $ promise = $ this -> exeContext -> promises -> convertThenable ( $ value ) ; if ( ! $ promise instanceof Promise ) { throw new InvariantViolation ( sprintf ( '%s::convertThenable is expected to return instance of GraphQL\Executor\Promise\Promise, got: %s' , get_class ( $ this -> exeContext -> promises ) , Utils :: printSafe ( $ promise ) ) ) ; } return $ promise ; } return null ; }
2912	public function formatNumber ( $ number , $ precision = 2 ) { $ locale = Mage :: app ( ) -> getLocale ( ) -> getLocale ( ) ; return Zend_Locale_Format :: toNumber ( $ number , array ( 'locale' => $ locale , 'precision' => $ precision ) ) ; }
5294	protected function execute ( InputInterface $ input , OutputInterface $ output ) { $ fontFile = realpath ( $ input -> getArgument ( 'font-file' ) ) ; if ( $ fontFile === false || ! file_exists ( $ fontFile ) ) { throw new \ InvalidArgumentException ( '"' . $ input -> getArgument ( 'font-file' ) . '" does not exist' ) ; } $ outputFile = $ input -> getArgument ( 'output-file' ) ; $ generator = new IconFontGenerator ; $ output -> writeln ( 'reading font file from "' . $ fontFile . '" ...' ) ; $ generator -> generateFromFont ( new Font ( array ( ) , file_get_contents ( $ fontFile ) ) ) ; $ output -> writeln ( 'writing CSS file to "' . $ outputFile . '" ...' ) ; file_put_contents ( $ outputFile , $ generator -> getCss ( ) ) ; $ output -> getFormatter ( ) -> setStyle ( 'success' , new OutputFormatterStyle ( null , null , array ( 'bold' , 'reverse' ) ) ) ; $ output -> writeln ( '<success>created CSS file successfully</success>' ) ; }
8505	public function createInboundShipment ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_CreateInboundShipmentRequest ) ) { $ request = new FBAInboundServiceMWS_Model_CreateInboundShipmentRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'CreateInboundShipment' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_CreateInboundShipmentResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
5490	public static function addItemAsArray ( & $ array , $ key , $ item ) { $ array_key = $ key . '[]' ; if ( array_key_exists ( $ array_key , $ array ) ) { $ array [ $ array_key ] [ ] = $ item ; } else { $ array [ $ array_key ] = array ( $ item ) ; } }
5516	public function errorOn ( $ method , $ error = 'A mock error' , $ args = false , $ severity = E_USER_ERROR ) { $ this -> dieOnNoMethod ( $ method , 'error on' ) ; $ this -> actions -> register ( $ method , $ args , new SimpleErrorThrower ( $ error , $ severity ) ) ; }
10881	public function checkPaths ( ) { if ( $ this -> path_checked ) return true ; foreach ( array ( 'root' , 'webroot' ) as $ type ) { $ path = $ this -> $ type ; if ( ! file_exists ( $ path ) || ! is_dir ( $ path ) ) throw new IOException ( "Path '$type' does not exist: " . $ path ) ; if ( ! is_readable ( $ path ) ) throw new PermissionError ( $ path , "Path '$type' cannot be read" ) ; } if ( ! is_dir ( $ this -> config ) || is_readable ( $ this -> config ) ) $ this -> config = null ; foreach ( array ( 'var' , 'cache' , 'log' , 'uploads' ) as $ write_dir ) { $ path = $ this -> $ write_dir ; if ( ! is_dir ( $ path ) ) { $ dn = dirname ( $ path ) ; if ( ! file_exists ( $ path ) && $ dn === $ this -> var ) { Path :: mkdir ( $ path ) ; } else { if ( file_exists ( $ path ) ) throw new IOException ( "Path '$write_dir' exists but is not a directory: " . $ path ) ; $ this -> $ write_dir = null ; continue ; } } if ( ! is_writable ( $ path ) ) { try { Path :: makeWritable ( $ path ) ; } catch ( PermissionError $ e ) { $ this -> $ write_dir = null ; if ( $ this -> cli ) WF :: debug ( "Failed to get write access to: %s" , $ e -> getMessage ( ) ) ; } } } $ this -> path_checked = true ; return true ; }
12780	public function setState ( $ key , $ value ) { return Yii :: $ app -> webState -> set ( $ this -> stateKeyName ( $ key ) , $ value ) ; }
12002	static public function generate ( $ length = 16 , $ algorithm = 'sha256' ) { if ( ! in_array ( $ algorithm , self :: $ allowedAlgorithm ) ) { throw new Exception ( "Hash algorithm $algorithm doesn't exists!" ) ; } $ salt = hash ( $ algorithm , time ( ) ) ; return substr ( hash ( $ algorithm , ( mt_rand ( self :: RAND_MIN , self :: RAND_MAX ) % $ length ) . $ salt . mt_rand ( self :: RAND_MIN , self :: RAND_MAX ) ) , self :: CUT_LEN , $ length ) ; }
3699	private function parseListing ( ) { $ listing = $ this -> definition -> getListingConfig ( ) ; if ( null === $ listing -> getRootLabel ( ) ) { $ listing -> setRootLabel ( $ this -> metaModel -> get ( 'name' ) ) ; } if ( null === $ listing -> getRootIcon ( ) ) { $ listing -> setRootIcon ( $ this -> iconBuilder -> getBackendIcon ( $ this -> inputScreen [ 'meta' ] [ 'backendicon' ] ) ) ; } $ this -> parseListSorting ( $ listing ) ; $ this -> parseListLabel ( $ listing ) ; $ listing -> setShowColumns ( ( bool ) $ this -> inputScreen [ 'meta' ] [ 'showColumns' ] ) ; }
5141	public function run ( ) : void { $ request = $ request = ServerRequestFactory :: fromGlobals ( ) ; $ response = $ this -> process ( $ request ) ; $ emitter = $ this -> getContainer ( ) -> has ( EmitterInterface :: class ) ? $ this -> getContainer ( ) -> get ( EmitterInterface :: class ) : new SapiEmitter ( ) ; $ emitter -> emit ( $ response ) ; }
3042	protected function packTimeLine ( & $ timeLine ) { $ epoch = $ this -> getEpoch ( ) ; $ data = [ self :: STORAGE_KEY_TIMELINE_INDEX => [ ] , self :: STORAGE_KEY_TIMELINE_TAGS => [ ] , self :: STORAGE_KEY_TIMELINE_POINTS => [ ] , self :: STORAGE_KEY_TIMELINE_EPOCH => $ epoch , ] ; $ index = 0 ; foreach ( $ timeLine -> getPoints ( ) as & $ point ) { $ data [ self :: STORAGE_KEY_TIMELINE_POINTS ] [ $ index ] = [ $ point -> getTarget ( ) , $ point -> getType ( ) , round ( $ point -> getTimestamp ( ) - $ epoch , 6 ) ] ; foreach ( $ point -> getTags ( ) as & $ tag ) { $ data [ self :: STORAGE_KEY_TIMELINE_INDEX ] [ $ tag ] [ ] = $ index ; } $ index ++ ; } if ( $ index ) { foreach ( $ data [ self :: STORAGE_KEY_TIMELINE_INDEX ] as $ tag => & $ list ) { if ( count ( $ list ) == $ index ) { unset ( $ data [ self :: STORAGE_KEY_TIMELINE_INDEX ] [ $ tag ] ) ; $ data [ self :: STORAGE_KEY_TIMELINE_TAGS ] [ ] = $ tag ; } } } else { $ data = [ ] ; } return $ data ; }
10280	public static function absoluteReference ( $ pCoordinateString ) { if ( self :: coordinateIsRange ( $ pCoordinateString ) ) { throw new Exception ( 'Cell coordinate string can not be a range of cells' ) ; } $ worksheet = '' ; $ cellAddress = explode ( '!' , $ pCoordinateString ) ; if ( count ( $ cellAddress ) > 1 ) { list ( $ worksheet , $ pCoordinateString ) = $ cellAddress ; } if ( $ worksheet > '' ) { $ worksheet .= '!' ; } if ( ctype_digit ( $ pCoordinateString ) ) { return $ worksheet . '$' . $ pCoordinateString ; } elseif ( ctype_alpha ( $ pCoordinateString ) ) { return $ worksheet . '$' . strtoupper ( $ pCoordinateString ) ; } return $ worksheet . self :: absoluteCoordinate ( $ pCoordinateString ) ; }
4437	public function set ( string $ name , $ value ) : void { $ this -> client -> call ( 'config.set' , $ name , $ value ) ; }
9777	function within ( $ start , $ finish ) : self { $ target = $ this -> hasFlag ( 'length' ) ? $ this -> getLength ( $ this -> target ) : $ this -> target ; return $ this -> expect ( $ target , logicalAnd ( greaterThanOrEqual ( $ start ) , lessThanOrEqual ( $ finish ) ) ) ; }
343	protected function renderSortLinks ( ) { $ attributes = empty ( $ this -> attributes ) ? array_keys ( $ this -> sort -> attributes ) : $ this -> attributes ; $ links = [ ] ; foreach ( $ attributes as $ name ) { $ links [ ] = $ this -> sort -> link ( $ name , $ this -> linkOptions ) ; } return Html :: ul ( $ links , array_merge ( $ this -> options , [ 'encode' => false ] ) ) ; }
4645	public function setDimension ( $ name , array $ values ) { if ( empty ( $ values ) ) { $ values = array ( null ) ; } $ this -> dimensions [ $ name ] = $ values ; }
2801	protected static function generateNonLazyBeanCode ( string $ padding , string $ beanId , string $ beanType , Bean $ beanMetadata , string $ methodParams , ForceLazyInitProperty $ forceLazyInitProperty , SessionBeansProperty $ sessionBeansProperty , BeanPostProcessorsProperty $ postProcessorsProperty , WrapBeanAsLazy $ wrapBeanAsLazy ) : string { $ content = $ padding . '$backupForceLazyInit = $this->' . $ forceLazyInitProperty -> getName ( ) . ';' . PHP_EOL ; if ( $ beanMetadata -> isSession ( ) ) { $ content .= $ padding . 'if($this->' . $ sessionBeansProperty -> getName ( ) . '->has("' . $ beanId . '")) {' . PHP_EOL ; if ( $ beanMetadata -> isSingleton ( ) ) { $ content .= $ padding . ' $sessionInstance = clone $this->' . $ sessionBeansProperty -> getName ( ) . '->get("' . $ beanId . '");' . PHP_EOL ; } else { $ content .= $ padding . ' $sessionInstance = $this->' . $ sessionBeansProperty -> getName ( ) . '->get("' . $ beanId . '");' . PHP_EOL ; } $ content .= $ padding . ' return ($backupForceLazyInit) ? $this->' . $ wrapBeanAsLazy -> getName ( ) . '("' . $ beanId . '", "' . $ beanType . '", $sessionInstance) : $sessionInstance;' . PHP_EOL ; $ content .= $ padding . '}' . PHP_EOL ; } if ( $ beanMetadata -> isSingleton ( ) ) { $ content .= $ padding . 'static $instance = null;' . PHP_EOL ; $ content .= $ padding . 'if ($instance !== null) {' . PHP_EOL ; $ content .= $ padding . ' return ($backupForceLazyInit) ? $this->' . $ wrapBeanAsLazy -> getName ( ) . '("' . $ beanId . '", "' . $ beanType . '", $instance) : $instance;' . PHP_EOL ; $ content .= $ padding . '}' . PHP_EOL ; } if ( $ beanMetadata -> isSession ( ) ) { $ content .= $ padding . '$this->' . $ forceLazyInitProperty -> getName ( ) . ' = true;' . PHP_EOL ; } $ content .= self :: generateBeanCreationCode ( $ padding , $ beanId , $ methodParams , $ postProcessorsProperty ) ; if ( $ beanMetadata -> isSession ( ) ) { $ content .= $ padding . '$this->' . $ forceLazyInitProperty -> getName ( ) . ' = $backupForceLazyInit;' . PHP_EOL ; $ content .= $ padding . '$this->' . $ sessionBeansProperty -> getName ( ) . '->add("' . $ beanId . '", $instance);' . PHP_EOL ; } $ content .= $ padding . 'return ($backupForceLazyInit) ? $this->' . $ wrapBeanAsLazy -> getName ( ) . '("' . $ beanId . '", "' . $ beanType . '", $instance) : $instance;' . PHP_EOL ; return $ content ; }
9467	protected function initializer ( string $ key , array $ storage ) : void { $ this -> _name = $ key ; $ this -> attached ( $ storage ) ; }
5510	public function expectAt ( $ timing , $ method , $ args , $ message = '%s' ) { $ this -> dieOnNoMethod ( $ method , 'set expected arguments at time' ) ; $ this -> checkArgumentsIsArray ( $ args , 'set expected arguments at time' ) ; $ args = $ this -> replaceWildcards ( $ args ) ; if ( ! isset ( $ this -> expected_args_at [ $ timing ] ) ) { $ this -> expected_args_at [ $ timing ] = array ( ) ; } $ method = strtolower ( $ method ) ; $ message .= Mock :: getExpectationLine ( ) ; $ this -> expected_args_at [ $ timing ] [ $ method ] = new ParametersExpectation ( $ args , $ message ) ; }
7880	protected function registerLogViewerController ( ) { $ this -> app -> bind ( LogViewerController :: class , function ( $ app ) { $ perPage = $ app [ 'config' ] [ 'logviewer.per_page' ] ; $ middleware = $ app [ 'config' ] [ 'logviewer.middleware' ] ; return new LogViewerController ( $ perPage , $ middleware ) ; } ) ; }
9057	public function addPrimaryKey ( string $ name ) : Column { $ column = $ this -> addColumn ( $ name ) ; $ this -> setPrimaryKey ( $ name ) ; return $ column ; }
2070	public function deletePage ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { $ root = func_get_arg ( 7 ) ; return ( $ this -> User -> hasAccess ( $ row [ 'type' ] , 'alpty' ) && $ this -> User -> isAllowed ( Contao \ BackendUser :: CAN_DELETE_PAGE , $ row ) && ( $ this -> User -> isAdmin || ! \ in_array ( $ row [ 'id' ] , $ root ) ) ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' ; }
11790	public function clear ( $ name = null ) { if ( ! is_null ( $ name ) ) { $ name = strtolower ( $ name ) ; if ( array_key_exists ( $ name , self :: $ clearings ) ) { $ this -> { $ name } = self :: $ clearings [ $ self :: $ clearings ] ; } } else { foreach ( self :: $ clearings as $ n => $ v ) { $ this -> { $ n } = $ v ; } } return $ this ; }
10058	public function save ( CacheItemInterface $ item ) { $ item -> setIsHit ( true ) ; $ this -> data [ $ item -> getKey ( ) ] = $ item ; return true ; }
3952	protected function isArrayEmpty ( $ arrArray ) { if ( empty ( $ arrArray ) ) { return true ; } if ( is_array ( $ arrArray ) && array_key_exists ( 'value' , $ arrArray ) ) { return $ this -> isArrayEmpty ( $ arrArray [ 'value' ] ) ; } if ( is_array ( $ arrArray ) ) { foreach ( $ arrArray as $ value ) { if ( is_array ( $ value ) ) { return $ this -> isArrayEmpty ( $ value ) ; } elseif ( ! empty ( $ value ) ) { return false ; } } } return false ; }
9513	public function setMatchModeByModeName ( $ modeName ) { $ modes = [ 'all' => 0 , 'any' => 1 , 'phrase' => 2 , 'boolean' => 3 , 'extended' => 4 , 'fullscan' => 5 , ] ; if ( array_key_exists ( $ modeName , $ modes ) ) { $ mode = $ modes [ $ modeName ] ; $ this -> SetMatchMode ( $ mode ) ; } else { throw new \ LogicException ( 'Wrong Mode' ) ; } }
4975	private function findOrCreateChild ( $ tree , $ id ) { foreach ( $ tree -> getChildren ( ) as $ node ) { if ( $ id && $ node -> getId ( ) == $ id ) { return $ node ; } } $ nodeClass = get_class ( $ tree ) ; $ node = new $ nodeClass ( ) ; $ tree -> addChild ( $ node ) ; return $ node ; }
11431	protected function get ( $ path , array $ parameters = array ( ) , $ requestHeaders = array ( ) ) { if ( array_key_exists ( 'ref' , $ parameters ) && is_null ( $ parameters [ 'ref' ] ) ) { unset ( $ parameters [ 'ref' ] ) ; } $ response = $ this -> client -> getHttpClient ( ) -> get ( $ path , $ parameters , $ requestHeaders ) ; return ResponseMediator :: getContent ( $ response ) ; }
11050	function protect_spaces ( $ data ) { $ data = str_replace ( "\n" , "\1n\1" , $ data ) ; $ data = str_replace ( "\r" , "\1r\1" , $ data ) ; $ data = str_replace ( "\t" , "\1t\1" , $ data ) ; return str_replace ( " " , "\1s\1" , $ data ) ; }
754	public function run ( ) { if ( Yii :: $ app -> request -> getQueryParam ( self :: REFRESH_GET_VAR ) !== null ) { $ code = $ this -> getVerifyCode ( true ) ; Yii :: $ app -> response -> format = Response :: FORMAT_JSON ; return [ 'hash1' => $ this -> generateValidationHash ( $ code ) , 'hash2' => $ this -> generateValidationHash ( strtolower ( $ code ) ) , 'url' => Url :: to ( [ $ this -> id , 'v' => uniqid ( '' , true ) ] ) , ] ; } $ this -> setHttpHeaders ( ) ; Yii :: $ app -> response -> format = Response :: FORMAT_RAW ; return $ this -> renderImage ( $ this -> getVerifyCode ( ) ) ; }
9263	private function addNamedRoute ( $ name , $ httpMethod , $ route , $ handler ) { if ( ! ( $ this -> dataGenerator instanceof NamedDataGeneratorInterface ) ) { throw new \ RuntimeException ( 'The injected generator does not support named routes' ) ; } $ routeData = $ this -> routeParser -> parse ( $ route ) ; foreach ( $ routeData as $ routeDatum ) { $ this -> dataGenerator -> addNamedRoute ( $ name , $ httpMethod , $ routeDatum , $ handler ) ; } }
12143	public static function user ( ) { if ( ! static :: $ user and static :: $ factory ) { $ id = static :: provider ( ) -> get ( 'id' ) ; static :: $ user = call_user_func ( static :: $ factory , $ id ) ; } return static :: $ user ; }
10651	public function validateCreate ( ) { $ validator = $ this -> getValidator ( 'create' ) ; if ( $ validator -> fails ( ) ) { $ this -> errors = $ validator -> messages ( ) ; return false ; } return true ; }
5840	protected function crop ( Builder $ url , $ args ) { $ url -> crop ( $ args [ 'top_left_x' ] , $ args [ 'top_left_y' ] , $ args [ 'bottom_right_x' ] , $ args [ 'bottom_right_y' ] ) ; }
11849	protected function getSettingsFromRealSource ( $ namespace ) { $ arraySettings = $ this -> getSettingsArray ( $ namespace ) ; $ namespaceOptions = $ this -> options -> getNamespaceOptions ( $ namespace ) ; $ entity = clone ( $ namespaceOptions -> getEntityPrototype ( ) ) ; if ( ! empty ( $ arraySettings ) ) { $ hydrator = $ this -> namespaceHydratorProvider -> getHydrator ( $ namespace ) ; $ entity = $ hydrator -> hydrate ( $ arraySettings , $ entity ) ; } return $ entity ; }
3325	public function renderOption ( Option $ opt ) { $ c1 = '' ; if ( $ opt -> short && $ opt -> long ) { $ c1 = sprintf ( '-%s, --%s' , $ opt -> short , $ opt -> long ) ; } else if ( $ opt -> short ) { $ c1 = sprintf ( '-%s' , $ opt -> short ) ; } else if ( $ opt -> long ) { $ c1 = sprintf ( '--%s' , $ opt -> long ) ; } $ c1 .= $ opt -> renderValueHint ( ) ; return $ c1 ; }
8463	public static function getProtocol ( $ url = false ) { if ( $ url ) { return ( preg_match ( '/^https/' , $ url ) ) ? 'https' : 'http' ; } $ protocol = strtolower ( $ _SERVER [ 'SERVER_PROTOCOL' ] ) ; $ protocol = substr ( $ protocol , 0 , strpos ( $ protocol , '/' ) ) ; $ ssl = ( isset ( $ _SERVER [ 'HTTPS' ] ) && $ _SERVER [ 'HTTPS' ] == 'on' ) ; return ( $ ssl ) ? $ protocol . 's' : $ protocol ; }
6998	protected function prepareRelatedRecord ( $ relationName , array $ relationRecordData , $ index = null ) { $ recordWithBackup = $ relationRecordData ; $ valueViewers = $ this -> getViewersForRelations ( ) ; foreach ( $ relationRecordData as $ columnName => $ value ) { $ viewerName = $ relationName . '.' . ( $ index === null ? '' : $ index . '.' ) . $ columnName ; if ( array_key_exists ( $ viewerName , $ valueViewers ) && $ valueViewers [ $ viewerName ] -> getRelation ( ) -> getName ( ) === $ relationName ) { $ recordWithBackup [ $ columnName ] = $ recordWithBackup [ '__' . $ columnName ] = $ value ; $ valueViewer = $ valueViewers [ $ viewerName ] ; if ( is_object ( $ valueViewer ) && method_exists ( $ valueViewer , 'convertValue' ) && ( ! method_exists ( $ valueViewer , 'isVisible' ) || $ valueViewer -> isVisible ( ) ) ) { $ recordWithBackup [ $ columnName ] = $ valueViewer -> convertValue ( $ recordWithBackup [ $ columnName ] , $ relationRecordData ) ; } } } return $ recordWithBackup ; }
7595	protected function renderLabel ( ElementInterface $ oElement ) { if ( ( $ sLabel = $ oElement -> getLabel ( ) ) && ( $ oTranslator = $ this -> getTranslator ( ) ) ) { $ sLabel = $ oTranslator -> translate ( $ sLabel , $ this -> getTranslatorTextDomain ( ) ) ; } return $ sLabel ; }
7874	private function checkConfig ( ) : void { if ( empty ( $ this -> userkey ) ) { Log :: warning ( 'Config "message.zenziva.userkey" is not defined.' ) ; } if ( empty ( $ this -> passkey ) ) { Log :: warning ( 'Config "message.zenziva.passkey" is not defined.' ) ; } }
114	private function openBrowser ( $ url ) { $ url = ProcessExecutor :: escape ( $ url ) ; $ process = new ProcessExecutor ( $ this -> getIO ( ) ) ; if ( Platform :: isWindows ( ) ) { return $ process -> execute ( 'start "web" explorer "' . $ url . '"' , $ output ) ; } $ linux = $ process -> execute ( 'which xdg-open' , $ output ) ; $ osx = $ process -> execute ( 'which open' , $ output ) ; if ( 0 === $ linux ) { $ process -> execute ( 'xdg-open ' . $ url , $ output ) ; } elseif ( 0 === $ osx ) { $ process -> execute ( 'open ' . $ url , $ output ) ; } else { $ this -> getIO ( ) -> writeError ( 'No suitable browser opening command found, open yourself: ' . $ url ) ; } }
12745	protected function move ( NodeConnectionInterface $ connection , $ slot ) { $ this -> pool [ ( string ) $ connection ] = $ connection ; $ this -> slots [ ( int ) $ slot ] = $ connection ; $ this -> slotmap [ ( int ) $ slot ] = $ connection ; }
5960	public function clientGetByDbid ( $ dbid ) { foreach ( $ this -> clientList ( ) as $ client ) { if ( $ client [ "client_database_id" ] == $ dbid ) { return $ client ; } } throw new Ts3Exception ( "invalid clientID" , 0x200 ) ; }
19	protected function getRepoData ( ) { $ resource = sprintf ( 'https://api.bitbucket.org/2.0/repositories/%s/%s?%s' , $ this -> owner , $ this -> repository , http_build_query ( array ( 'fields' => '-project,-owner' ) , null , '&' ) ) ; $ repoData = JsonFile :: parseJson ( $ this -> getContentsWithOAuthCredentials ( $ resource , true ) , $ resource ) ; if ( $ this -> fallbackDriver ) { return false ; } $ this -> parseCloneUrls ( $ repoData [ 'links' ] [ 'clone' ] ) ; $ this -> hasIssues = ! empty ( $ repoData [ 'has_issues' ] ) ; $ this -> branchesUrl = $ repoData [ 'links' ] [ 'branches' ] [ 'href' ] ; $ this -> tagsUrl = $ repoData [ 'links' ] [ 'tags' ] [ 'href' ] ; $ this -> homeUrl = $ repoData [ 'links' ] [ 'html' ] [ 'href' ] ; $ this -> website = $ repoData [ 'website' ] ; $ this -> vcsType = $ repoData [ 'scm' ] ; return true ; }
12894	public function close ( $ account , $ openId ) { $ params = [ 'kf_account' => $ account , 'openid' => $ openId , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_CLOSE , $ params ] ) ; }
5822	public function renderFlashAlerts ( array $ options = array ( ) ) { $ options = $ this -> resolveOptions ( $ options ) ; return $ this -> templating -> render ( $ options [ 'template' ] , $ options ) ; }
360	function normalizeRequirement ( $ requirement , $ requirementKey = 0 ) { if ( ! is_array ( $ requirement ) ) { $ this -> usageError ( 'Requirement must be an array!' ) ; } if ( ! array_key_exists ( 'condition' , $ requirement ) ) { $ this -> usageError ( "Requirement '{$requirementKey}' has no condition!" ) ; } else { $ evalPrefix = 'eval:' ; if ( is_string ( $ requirement [ 'condition' ] ) && strpos ( $ requirement [ 'condition' ] , $ evalPrefix ) === 0 ) { $ expression = substr ( $ requirement [ 'condition' ] , strlen ( $ evalPrefix ) ) ; $ requirement [ 'condition' ] = $ this -> evaluateExpression ( $ expression ) ; } } if ( ! array_key_exists ( 'name' , $ requirement ) ) { $ requirement [ 'name' ] = is_numeric ( $ requirementKey ) ? 'Requirement #' . $ requirementKey : $ requirementKey ; } if ( ! array_key_exists ( 'mandatory' , $ requirement ) ) { if ( array_key_exists ( 'required' , $ requirement ) ) { $ requirement [ 'mandatory' ] = $ requirement [ 'required' ] ; } else { $ requirement [ 'mandatory' ] = false ; } } if ( ! array_key_exists ( 'by' , $ requirement ) ) { $ requirement [ 'by' ] = 'Unknown' ; } if ( ! array_key_exists ( 'memo' , $ requirement ) ) { $ requirement [ 'memo' ] = '' ; } return $ requirement ; }
9817	public function setView ( $ pValue ) { if ( $ pValue === null ) { $ pValue = self :: SHEETVIEW_NORMAL ; } if ( in_array ( $ pValue , self :: $ sheetViewTypes ) ) { $ this -> sheetviewType = $ pValue ; } else { throw new PhpSpreadsheetException ( 'Invalid sheetview layout type.' ) ; } return $ this ; }
7777	protected function extractFieldAliases ( array $ data ) { foreach ( $ data as $ field => $ fieldRules ) { $ extraction = explode ( '|' , $ field ) ; if ( isset ( $ extraction [ 1 ] ) ) { $ updatedField = $ extraction [ 0 ] ; $ alias = $ extraction [ 1 ] ; $ this -> fieldAliases [ $ updatedField ] = $ alias ; $ data [ $ updatedField ] = $ data [ $ field ] ; unset ( $ data [ $ field ] ) ; } } return $ data ; }
7992	public function setPassword ( $ pp , $ pca , $ passwd ) { if ( ! $ pp ) throw new BadMethodCallException ( 'Missing parameter $pp (OVH cloud passport).' ) ; if ( ! $ pca ) throw new BadMethodCallException ( 'Missing parameter $pca (PCA ServiceName).' ) ; if ( ! $ passwd ) throw new BadMethodCallException ( 'Missing parameter $passwd (Password for this pca).' ) ; $ payload = array ( 'password' => $ passwd ) ; try { $ this -> put ( 'cloud/' . $ pp . '/pca/' . $ pca , array ( 'Content-Type' => 'application/json;charset=UTF-8' ) , json_encode ( $ payload ) ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new CloudException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } }
8799	public function make ( $ value , array $ options = [ ] ) { $ hash = password_hash ( $ value , PASSWORD_ARGON2I , [ 'memory_cost' => $ this -> memory ( $ options ) , 'time_cost' => $ this -> time ( $ options ) , 'threads' => $ this -> threads ( $ options ) , ] ) ; if ( $ hash === false ) { throw new RuntimeException ( 'Argon2 hashing not supported.' ) ; } return $ hash ; }
7934	public function alreadyLoaded ( $ name ) { foreach ( $ this -> loaded as $ item ) { if ( $ item [ 'name' ] === $ name ) { return true ; } } return false ; }
1912	public function pickerAction ( Request $ request ) : RedirectResponse { $ extras = [ ] ; if ( $ request -> query -> has ( 'extras' ) ) { $ extras = $ request -> query -> get ( 'extras' ) ; if ( ! \ is_array ( $ extras ) ) { throw new BadRequestHttpException ( 'Invalid picker extras' ) ; } } $ config = new PickerConfig ( $ request -> query -> get ( 'context' ) , $ extras , $ request -> query -> get ( 'value' ) ) ; $ picker = $ this -> get ( 'contao.picker.builder' ) -> create ( $ config ) ; if ( null === $ picker ) { throw new BadRequestHttpException ( 'Unsupported picker context' ) ; } return new RedirectResponse ( $ picker -> getCurrentUrl ( ) ) ; }
9976	public static function builtInFormatCode ( $ pIndex ) { $ pIndex = ( int ) $ pIndex ; self :: fillBuiltInFormatCodes ( ) ; if ( isset ( self :: $ builtInFormats [ $ pIndex ] ) ) { return self :: $ builtInFormats [ $ pIndex ] ; } return '' ; }
1702	public function getSearchablePages ( $ arrPages , $ intRoot = 0 , $ blnIsSitemap = false ) { $ arrRoot = array ( ) ; if ( $ intRoot > 0 ) { $ arrRoot = $ this -> Database -> getChildRecords ( $ intRoot , 'tl_page' ) ; } $ arrProcessed = array ( ) ; $ time = Date :: floorToMinute ( ) ; $ objArchive = NewsArchiveModel :: findByProtected ( '' ) ; if ( $ objArchive !== null ) { while ( $ objArchive -> next ( ) ) { if ( ! $ objArchive -> jumpTo ) { continue ; } if ( ! empty ( $ arrRoot ) && ! \ in_array ( $ objArchive -> jumpTo , $ arrRoot ) ) { continue ; } if ( ! isset ( $ arrProcessed [ $ objArchive -> jumpTo ] ) ) { $ objParent = PageModel :: findWithDetails ( $ objArchive -> jumpTo ) ; if ( $ objParent === null ) { continue ; } if ( ! $ objParent -> published || ( $ objParent -> start != '' && $ objParent -> start > $ time ) || ( $ objParent -> stop != '' && $ objParent -> stop <= ( $ time + 60 ) ) ) { continue ; } if ( $ blnIsSitemap ) { if ( $ objParent -> protected ) { continue ; } if ( $ objParent -> sitemap == 'map_never' ) { continue ; } } $ arrProcessed [ $ objArchive -> jumpTo ] = $ objParent -> getAbsoluteUrl ( Config :: get ( 'useAutoItem' ) ? '/%s' : '/items/%s' ) ; } $ strUrl = $ arrProcessed [ $ objArchive -> jumpTo ] ; $ objArticle = NewsModel :: findPublishedDefaultByPid ( $ objArchive -> id ) ; if ( $ objArticle !== null ) { while ( $ objArticle -> next ( ) ) { $ arrPages [ ] = $ this -> getLink ( $ objArticle , $ strUrl ) ; } } } } return $ arrPages ; }
12645	public function render ( ElementInterface $ element ) { $ label = $ element -> getLabel ( ) ; if ( isset ( $ label ) && '' !== $ label ) { if ( null !== ( $ translator = $ this -> getTranslator ( ) ) ) { $ label = $ translator -> translate ( $ label , $ this -> getTranslatorTextDomain ( ) ) ; $ element -> setLabel ( $ label ) ; } } return parent :: render ( $ element ) ; }
9914	public function create ( $ modelName , ModelConfig $ config = null ) { $ menu = new Menu ( ) ; $ addMenuItem = new LinkMenuItem ( ) ; $ addMenuItem -> setText ( Lang :: trans ( 'Add' ) ) ; $ addMenuItem -> setIcon ( Icons :: ion_plus ) ; $ addMenuItem -> setTarget ( URL :: route ( $ this -> aujaRouter -> getCreateName ( $ modelName ) ) ) ; $ menu -> addMenuItem ( $ addMenuItem ) ; $ spacerMenuItem = new SpacerMenuItem ( ) ; $ spacerMenuItem -> setText ( Lang :: trans ( $ modelName ) ) ; $ menu -> addMenuItem ( $ spacerMenuItem ) ; $ resourceMenuItem = new ResourceMenuItem ( ) ; $ resourceMenuItem -> setTarget ( URL :: route ( $ this -> aujaRouter -> getIndexName ( $ modelName ) ) ) ; $ model = $ this -> aujaConfigurator -> getModel ( $ modelName ) ; if ( $ this -> aujaConfigurator -> isSearchable ( $ model , $ config ) ) { $ target = urldecode ( URL :: route ( $ this -> aujaRouter -> getIndexName ( $ modelName ) , [ 'q' => '%s' ] ) ) ; $ property = new Searchable ( $ target ) ; $ resourceMenuItem -> addProperty ( $ property ) ; } $ menu -> addMenuItem ( $ resourceMenuItem ) ; return $ menu ; }
12196	public static function current ( ) { if ( defined ( 'PHPUNIT_RUNNING' ) ) { return 'http://localhost' ; } $ protocol = 'http://' ; if ( ! empty ( $ _SERVER [ 'HTTPS' ] ) || ( ! empty ( $ _SERVER [ 'HTTP_X_FORWARDED_PROTO' ] ) && $ _SERVER [ 'HTTP_X_FORWARDED_PROTO' ] === 'https' ) ) { $ protocol = 'https://' ; } return $ protocol . request ( ) -> server ( 'HTTP_HOST' ) . request ( ) -> server ( 'REQUEST_URI' ) ; }
7382	public static function toInsert ( $ input , array $ include = [ ] ) { if ( is_object ( $ input ) ) { if ( method_exists ( $ input , 'toArray' ) ) { $ input = $ input -> toArray ( ) ; } elseif ( $ input instanceof \ Traversable ) { $ input = iterator_to_array ( $ input ) ; } else { $ input = ( array ) $ input ; } } elseif ( ! is_array ( $ input ) ) { throw new InvalidArgumentException ( 'input must be an associative array or traversable object' ) ; } if ( count ( $ include ) ) { $ arr = [ ] ; foreach ( $ include as $ i ) { if ( isset ( $ input [ $ i ] ) ) { $ arr [ $ i ] &= $ input [ $ i ] ; } } } else { $ arr = & $ input ; } $ sqlStrs = [ ] ; foreach ( $ arr as $ k => & $ v ) { $ kEq = '`' . $ k . '` = ' ; switch ( gettype ( $ v ) ) { case 'bool' : case 'boolean' : $ sqlStrs [ ] = $ kEq . ( $ v ? '1' : '0' ) ; break ; case 'int' : case 'integer' : case 'float' : case 'double' : $ sqlStrs [ ] = $ kEq . $ v ; break ; case 'string' : if ( $ v === 'NULL' ) { $ sqlStrs [ ] = $ kEq . 'NULL' ; } else { $ sqlStrs [ ] = $ kEq . '"' . addslashes ( $ v ) . '"' ; } break ; case 'null' : case 'NULL' : $ sqlStrs [ ] = $ kEq . 'NULL' ; break ; case 'object' : if ( $ v instanceof DateTime ) { $ sqlStrs [ ] = $ kEq . '"' . $ v . '"' ; break ; } case 'array' : $ sqlStrs [ ] = $ kEq . '"' . addslashes ( json_encode ( $ v ) ) . '"' ; $ jsonLastErr = json_last_error ( ) ; if ( $ jsonLastErr !== JSON_ERROR_NONE ) { throw new UnexpectedValueException ( json_last_error_msg ( ) , $ jsonLastErr ) ; } break ; default : break ; } } return implode ( ",\n" , $ sqlStrs ) ; }
11165	protected function getDurationFormat ( array $ config ) { if ( isset ( $ config [ 'durationFormat' ] ) ) { if ( ! is_string ( $ config [ 'durationFormat' ] ) ) { throw new \ DomainException ( 'durationFormat must reference a string' , self :: ERR_INVALID_DURATIONFORMAT ) ; } return $ config [ 'durationFormat' ] ; } return '%im%ss' ; }
7956	public function getBillingAccountServices ( ) { $ serviceList = json_decode ( self :: getClient ( ) -> getBillingAccountServices ( $ this -> billingAccount ) ) ; $ services = array ( ) ; foreach ( $ serviceList as $ service ) { $ services [ ] = new TelephonyAccountService ( $ service , $ this ) ; } return $ services ; }
6554	public function removeLineFromFile ( $ line , $ fh ) { $ lines = array ( ) ; $ found = false ; rewind ( $ fh ) ; while ( ( $ buffer = fgets ( $ fh , 4096 ) ) !== false ) { $ buffer = trim ( $ buffer ) ; if ( $ line === $ buffer ) { $ found = true ; continue ; } $ lines [ ] = $ buffer ; } if ( ! $ found ) { throw new LineNotFoundException ( sprintf ( 'Line %s can not be found' , $ line ) ) ; } ftruncate ( $ fh , 0 ) ; rewind ( $ fh ) ; foreach ( $ lines as $ ln ) { if ( fwrite ( $ fh , $ ln . PHP_EOL ) === false ) { throw new \ Exception ( sprintf ( 'Can\'t write %s to file' , $ ln ) ) ; } } }
11858	public function getHandler ( ) { if ( $ this -> pairedDataItem ) { if ( ! isset ( $ this -> primaryObject ) ) { return $ this -> pairedDataItem ; } elseif ( isset ( $ this -> companionObject ) ) { return static :: getHandlingObject ( $ this , $ this -> pairedDataItem ) ; } } return $ this ; }
9183	protected function forgetByKey ( $ key ) { $ result = false ; if ( Cache :: has ( $ key ) ) { $ result = Cache :: forget ( $ key ) ; } return $ result ; }
932	public function clearChanged ( ) { @ trigger_error ( __METHOD__ . ' is deprecated and will be removed in 3.0.' , E_USER_DEPRECATED ) ; Tokens :: setLegacyMode ( true ) ; $ this -> changed = false ; }
7772	protected function replaceMessageFormat ( $ message , array $ item ) { $ keys = array_keys ( $ item ) ; if ( ! empty ( $ item [ 'args' ] ) ) { $ args = $ item [ 'args' ] ; $ argReplace = array_map ( function ( $ i ) { return "{\${$i}}" ; } , array_keys ( $ args ) ) ; $ args [ ] = count ( $ item [ 'args' ] ) ; $ argReplace [ ] = '{$#}' ; $ args [ ] = implode ( ', ' , $ item [ 'args' ] ) ; $ argReplace [ ] = '{$*}' ; $ message = str_replace ( $ argReplace , $ args , $ message ) ; } $ message = str_replace ( [ '{field}' , '{value}' ] , [ $ item [ 'field' ] , $ item [ 'value' ] ] , $ message ) ; return $ message ; }
12732	public function handle ( $ signal ) { if ( isset ( $ this -> _bySignal [ $ signal ] ) ) { foreach ( $ this -> _bySignal [ $ signal ] as $ reg ) { $ reg -> interrupt = $ signal ; } } else { return SIG_DFL ; } }
5638	public function shouldInvoke ( $ test_case , $ method ) { if ( $ this -> shouldRunTest ( $ test_case , $ method ) ) { return $ this -> reporter -> shouldInvoke ( $ test_case , $ method ) ; } return false ; }
8466	public static function setUrlParams ( $ url = false ) { $ url = $ url !== false ? $ url : self :: getCurrentPage ( ) ; if ( strpos ( $ url , '?' ) == false && strpos ( $ url , '&' ) != false ) { $ url = preg_replace ( '/&/' , '?' , $ url , 1 ) ; $ parts = parse_url ( $ url ) ; $ query = isset ( $ parts [ 'query' ] ) ? $ parts [ 'query' ] : '' ; parse_str ( $ query , $ query ) ; } foreach ( isset ( $ query ) ? $ query : [ ] as $ key => $ value ) { $ _GET [ $ key ] = $ value ; } return explode ( '?' , $ url ) [ 0 ] ; }
7265	public static function select ( $ queryString = "" , array $ queryParams = [ ] ) { $ tableName = static :: tableName ( ) ; $ rows = Db :: query ( " select $tableName.* from $tableName $queryString " , $ queryParams , static :: getDbName ( ) ) ; if ( $ rows === false ) return false ; if ( empty ( $ rows ) ) return new Collection ( [ ] ) ; $ collection = [ ] ; foreach ( $ rows as $ row ) { $ model = new static ; foreach ( $ row as $ column => $ val ) $ model -> $ column = $ model -> decodeValue ( $ val , $ column ) ; $ collection [ ] = $ model ; } return new Collection ( $ collection ) ; }
12828	protected function registerCustomFunctions ( ) { $ functionList = $ this -> functionGenerator -> getFunctionList ( ) ; foreach ( $ functionList as $ function ) { if ( isset ( $ function [ 'name' ] ) && isset ( $ function [ 'callable' ] ) ) { $ twigFunction = new Twig_SimpleFunction ( $ function [ 'name' ] , $ function [ 'callable' ] ) ; $ this -> engine -> addFunction ( $ twigFunction ) ; } } }
4085	public function createStore ( ) { $ request = $ this -> requestStack -> getCurrentRequest ( ) ; return new BreadcrumbStore ( $ this -> iconBuilder , $ this -> translator , $ request ? $ request -> getUri ( ) : '' ) ; }
933	public function equals ( $ other , $ caseSensitive = true ) { if ( $ other instanceof self ) { if ( ! $ other -> isArray ) { $ otherPrototype = $ other -> content ; } else { $ otherPrototype = [ $ other -> id , $ other -> content , ] ; } } else { $ otherPrototype = $ other ; } if ( $ this -> isArray !== \ is_array ( $ otherPrototype ) ) { return false ; } if ( ! $ this -> isArray ) { return $ this -> content === $ otherPrototype ; } if ( $ this -> id !== $ otherPrototype [ 0 ] ) { return false ; } if ( isset ( $ otherPrototype [ 1 ] ) ) { if ( $ caseSensitive ) { if ( $ this -> content !== $ otherPrototype [ 1 ] ) { return false ; } } elseif ( 0 !== strcasecmp ( $ this -> content , $ otherPrototype [ 1 ] ) ) { return false ; } } unset ( $ otherPrototype [ 0 ] , $ otherPrototype [ 1 ] ) ; return empty ( $ otherPrototype ) ; }
11113	public function runPending ( array $ migrations , array $ options = [ ] ) { if ( count ( $ migrations ) === 0 ) { $ this -> notify -> note ( '<info>Nothing to migrate.</info>' ) ; return ; } $ batch = $ this -> repository -> getNextBatchNumber ( ) ; $ step = $ options [ 'step' ] ?? false ; $ this -> notify -> note ( '' ) ; foreach ( $ migrations as $ file ) { $ this -> runUp ( $ file , $ batch ) ; if ( $ step ) { $ batch ++ ; } } }
6804	public function installCustomerGroups ( ) { $ groups = ( array ) $ this -> customerGroupRepository -> findBy ( [ ] , [ ] , 1 ) -> getIterator ( ) ; if ( ! empty ( $ groups ) ) { call_user_func ( $ this -> log , 'All' , 'skipped' ) ; return ; } $ groups = [ 'Particuliers' => [ 'default' => true , 'business' => false , 'registration' => true , ] , 'Entreprise' => [ 'default' => false , 'business' => true , 'registration' => true , ] , ] ; foreach ( $ groups as $ name => $ config ) { $ result = 'already exists' ; if ( null === $ this -> customerGroupRepository -> findOneBy ( [ 'name' => $ name ] ) ) { $ customerGroup = $ this -> customerGroupRepository -> createNew ( ) ; $ customerGroup -> setName ( $ name ) -> setDefault ( $ config [ 'default' ] ) -> setBusiness ( $ config [ 'business' ] ) -> setRegistration ( $ config [ 'registration' ] ) -> translate ( ) -> setTitle ( $ name ) ; $ this -> manager -> persist ( $ customerGroup ) ; $ result = 'done' ; } call_user_func ( $ this -> log , $ name , $ result ) ; } $ this -> manager -> flush ( ) ; }
4255	protected function buildFatal ( ) { $ haveFatal = isset ( $ this -> stats [ 'counts' ] [ 'fatal' ] ) ; if ( ! $ haveFatal ) { return '' ; } $ lastError = $ this -> errorHandler -> get ( 'lastError' ) ; $ isHtml = $ lastError [ 'isHtml' ] ; $ backtrace = $ lastError [ 'backtrace' ] ; $ html = '<h3>Fatal Error</h3>' ; $ html .= '<ul class="list-unstyled indent">' ; if ( \ count ( $ backtrace ) > 1 ) { $ table = $ this -> outputHtml -> buildTable ( $ backtrace , array ( 'attribs' => 'trace table-bordered' , 'caption' => 'trace' , 'columns' => array ( 'file' , 'line' , 'function' ) , ) ) ; $ html .= '<li>' . $ lastError [ 'message' ] . '</li>' ; $ html .= '<li>' . $ table . '</li>' ; if ( ! $ isHtml ) { $ html = \ str_replace ( $ lastError [ 'message' ] , \ htmlspecialchars ( $ lastError [ 'message' ] ) , $ html ) ; } } else { $ keysKeep = array ( 'typeStr' , 'message' , 'file' , 'line' ) ; $ lastError = \ array_intersect_key ( $ lastError , \ array_flip ( $ keysKeep ) ) ; $ html .= '<li>' . $ this -> outputHtml -> dump ( $ lastError ) . '</li>' ; if ( $ isHtml ) { $ html = \ str_replace ( \ htmlspecialchars ( $ lastError [ 'message' ] ) , $ lastError [ 'message' ] , $ html ) ; } } if ( ! \ extension_loaded ( 'xdebug' ) ) { $ html .= '<li>Want to see a backtrace here? Install <a target="_blank" href="https://xdebug.org/docs/install">xdebug</a> PHP extension.</li>' ; } $ html .= '</ul>' ; return $ html ; }
8080	public function & getReports ( $ channel = null ) { $ channel = $ this -> namespaceChannel ( $ channel ) ; if ( ! isset ( $ this -> console [ 'reports' ] [ $ channel ] ) ) { $ this -> console [ 'reports' ] [ $ channel ] = array ( ) ; } return $ this -> console [ 'reports' ] [ $ channel ] ; }
2119	public function getFromDca ( ) { $ return = array ( ) ; $ processed = array ( ) ; $ files = System :: getContainer ( ) -> get ( 'contao.resource_finder' ) -> findIn ( 'dca' ) -> depth ( 0 ) -> files ( ) -> name ( '*.php' ) ; foreach ( $ files as $ file ) { if ( \ in_array ( $ file -> getBasename ( ) , $ processed ) ) { continue ; } $ processed [ ] = $ file -> getBasename ( ) ; $ strTable = $ file -> getBasename ( '.php' ) ; $ objExtract = DcaExtractor :: getInstance ( $ strTable ) ; if ( $ objExtract -> isDbTable ( ) ) { $ return [ $ strTable ] = $ objExtract -> getDbInstallerArray ( ) ; } } ksort ( $ return ) ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'sqlGetFromDca' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'sqlGetFromDca' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'sqlGetFromDca' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ return = $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ return ) ; } } return $ return ; }
1674	public function synchronize ( ) { if ( ! $ this -> isUnsynchronized ( ) ) { return ; } if ( ! file_exists ( $ this -> strRootDir . '/' . $ this -> strFolder . '/.nosync' ) ) { throw new \ RuntimeException ( sprintf ( 'Cannot synchronize the folder "%s" because one of its parent folders is unsynchronized' , $ this -> strFolder ) ) ; } ( new File ( $ this -> strFolder . '/.nosync' ) ) -> delete ( ) ; }
665	protected function openFromPoolSequentially ( array $ pool , array $ sharedConfig ) { if ( empty ( $ pool ) ) { return null ; } if ( ! isset ( $ sharedConfig [ 'class' ] ) ) { $ sharedConfig [ 'class' ] = get_class ( $ this ) ; } $ cache = is_string ( $ this -> serverStatusCache ) ? Yii :: $ app -> get ( $ this -> serverStatusCache , false ) : $ this -> serverStatusCache ; foreach ( $ pool as $ config ) { $ config = array_merge ( $ sharedConfig , $ config ) ; if ( empty ( $ config [ 'dsn' ] ) ) { throw new InvalidConfigException ( 'The "dsn" option must be specified.' ) ; } $ key = [ __METHOD__ , $ config [ 'dsn' ] ] ; if ( $ cache instanceof CacheInterface && $ cache -> get ( $ key ) ) { continue ; } $ db = Yii :: createObject ( $ config ) ; try { $ db -> open ( ) ; return $ db ; } catch ( \ Exception $ e ) { Yii :: warning ( "Connection ({$config['dsn']}) failed: " . $ e -> getMessage ( ) , __METHOD__ ) ; if ( $ cache instanceof CacheInterface ) { $ cache -> set ( $ key , 1 , $ this -> serverRetryInterval ) ; } } } return null ; }
8628	public static function fromXML ( $ xml ) { $ dom = new DOMDocument ( ) ; $ dom -> loadXML ( $ xml ) ; $ xpath = new DOMXPath ( $ dom ) ; $ response = $ xpath -> query ( "//*[local-name()='GetCompetitivePricingForSKUResponse']" ) ; if ( $ response -> length == 1 ) { return new MarketplaceWebServiceProducts_Model_GetCompetitivePricingForSKUResponse ( ( $ response -> item ( 0 ) ) ) ; } else { throw new Exception ( "Unable to construct MarketplaceWebServiceProducts_Model_GetCompetitivePricingForSKUResponse from provided XML. Make sure that GetCompetitivePricingForSKUResponse is a root element" ) ; } }
3378	private function showLink ( $ link ) { if ( ! $ link [ 'show_menu' ] ) return false ; $ user = \ Auth :: guard ( 'panel' ) -> user ( ) ; return $ user -> hasRole ( 'super' ) || $ user -> hasPermission ( '/' . $ link [ 'url' ] . '/all' ) ; }
1174	protected function generateJavascriptValidations ( ) { $ jsValidations = [ ] ; foreach ( $ this -> validator -> getRules ( ) as $ attribute => $ rules ) { if ( ! $ this -> jsValidationEnabled ( $ attribute ) ) { continue ; } $ newRules = $ this -> jsConvertRules ( $ attribute , $ rules , $ this -> remote ) ; $ jsValidations = array_merge ( $ jsValidations , $ newRules ) ; } return $ jsValidations ; }
6176	public static function arrayUniqueMultidimensional ( array $ input ) { $ serialized = array_map ( 'serialize' , $ input ) ; $ unique = array_unique ( $ serialized ) ; $ output = array_intersect_key ( $ input , $ unique ) ; return array_values ( $ output ) ; }
2646	public function cloneVersion ( $ curVersion ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ curVersion . '/clone' ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: PUT ) ; if ( ! $ result ) { throw new LocalizedException ( __ ( 'Failed to clone active version.' ) ) ; } return $ result ; }
10878	public function processForgotten ( string $ hash , string $ password ) : bool { $ decode = $ this -> getDecodeHash ( $ hash ) ; $ id = ( int ) $ decode [ 'id' ] ; $ verifyHash = $ decode [ 'verifyHash' ] ; $ item = $ this -> getById ( $ id ) ; if ( $ item && $ id == $ item [ 'id' ] ) { $ values [ 'hash' ] = $ this -> getHash ( $ password ) ; if ( $ this -> verifyHash ( $ item [ 'id' ] . $ item [ 'login' ] , $ verifyHash ) ) { return $ this -> update ( $ item [ 'id' ] , $ values ) ; } else { throw new IdentityException ( 'Invalid hash!' ) ; } } else { throw new IdentityException ( 'User does not exist!' ) ; } }
1132	public function insideSubtree ( $ node ) { return ( $ this -> getLeft ( ) >= $ node -> getLeft ( ) && $ this -> getLeft ( ) <= $ node -> getRight ( ) && $ this -> getRight ( ) >= $ node -> getLeft ( ) && $ this -> getRight ( ) <= $ node -> getRight ( ) ) ; }
377	private function getByteSize ( $ verboseSize ) { if ( empty ( $ verboseSize ) ) { return 0 ; } if ( is_numeric ( $ verboseSize ) ) { return ( int ) $ verboseSize ; } $ sizeUnit = trim ( $ verboseSize , '0123456789' ) ; $ size = trim ( str_replace ( $ sizeUnit , '' , $ verboseSize ) ) ; if ( ! is_numeric ( $ size ) ) { return 0 ; } switch ( strtolower ( $ sizeUnit ) ) { case 'kb' : case 'k' : return $ size * 1024 ; case 'mb' : case 'm' : return $ size * 1024 * 1024 ; case 'gb' : case 'g' : return $ size * 1024 * 1024 * 1024 ; default : return 0 ; } }
7359	public static function getDefaultPriceMapLoader ( ) { if ( null === self :: $ defaultPriceMapLoader ) { $ currencyDir = realpath ( __DIR__ . '/../../../data/prices' ) ; self :: $ defaultPriceMapLoader = new PhpFileLoader ( array ( $ currencyDir ) ) ; } return self :: $ defaultPriceMapLoader ; }
8965	public function rewriteCountQuery ( $ query ) { if ( \ preg_match ( '/^\s*SELECT\s+\bDISTINCT\b/is' , $ query ) || \ preg_match ( '/\s+GROUP\s+BY\s+/is' , $ query ) ) { return '' ; } $ openParenthesis = '(?:\()' ; $ closeParenthesis = '(?:\))' ; $ subQueryInSelect = $ openParenthesis . '.*\bFROM\b.*' . $ closeParenthesis ; $ pattern = '/(?:.*' . $ subQueryInSelect . '.*)\bFROM\b\s+/Uims' ; if ( \ preg_match ( $ pattern , $ query ) ) { return '' ; } $ subQueryWithLimitOrder = $ openParenthesis . '.*\b(LIMIT|ORDER)\b.*' . $ closeParenthesis ; $ pattern = '/.*\bFROM\b.*(?:.*' . $ subQueryWithLimitOrder . '.*).*/Uims' ; if ( \ preg_match ( $ pattern , $ query ) ) { return '' ; } $ queryCount = \ preg_replace ( '/(?:.*)\bFROM\b\s+/Uims' , 'SELECT COUNT(*) FROM ' , $ query , 1 ) ; list ( $ queryCount ) = \ preg_split ( '/\s+ORDER\s+BY\s+/is' , $ queryCount ) ; list ( $ queryCount ) = \ preg_split ( '/\bLIMIT\b/is' , $ queryCount ) ; return \ trim ( $ queryCount ) ; }
7411	public function combine ( array $ keys ) : self { if ( count ( $ keys ) !== count ( $ this -> _container ) ) { throw new LengthException ( 'array counts do not match' ) ; } $ this -> _container = array_combine ( $ keys , $ this -> _container ) ; return $ this ; }
10450	public function delete ( $ key ) { try { $ this -> get ( $ key ) ; } catch ( KeyNotFoundException $ e ) { return false ; } return $ this -> getClient ( ) -> delete ( $ key ) ; }
8831	protected function getCheckboxCheckedState ( $ name , $ value , $ checked ) { $ posted = $ this -> getValueAttribute ( $ name , $ checked ) ; if ( is_array ( $ posted ) ) { return in_array ( $ value , $ posted ) ; } else { return ( bool ) $ posted ; } }
592	public function combineJsFiles ( $ inputFiles , $ outputFile ) { $ content = '' ; foreach ( $ inputFiles as $ file ) { $ fileContent = rtrim ( file_get_contents ( $ file ) ) ; if ( substr ( $ fileContent , - 1 ) !== ';' ) { $ fileContent .= "\n;" ; } $ content .= "/*** BEGIN FILE: $file ***/\n" . $ fileContent . "\n" . "/*** END FILE: $file ***/\n" ; } if ( ! file_put_contents ( $ outputFile , $ content ) ) { throw new Exception ( "Unable to write output JavaScript file '{$outputFile}'." ) ; } }
1881	protected function isValid ( $ strFile ) { $ strFolder = Input :: get ( 'pid' , true ) ; if ( Validator :: isInsecurePath ( $ strFile ) ) { throw new AccessDeniedException ( 'Invalid file name "' . $ strFile . '" (hacking attempt).' ) ; } elseif ( Validator :: isInsecurePath ( $ strFolder ) ) { throw new AccessDeniedException ( 'Invalid folder name "' . $ strFolder . '" (hacking attempt).' ) ; } if ( ! empty ( $ this -> arrValidFileTypes ) && is_file ( $ this -> strRootDir . '/' . $ strFile ) ) { $ fileinfo = preg_replace ( '/.*\.(.*)$/u' , '$1' , $ strFile ) ; if ( ! \ in_array ( strtolower ( $ fileinfo ) , $ this -> arrValidFileTypes ) ) { throw new AccessDeniedException ( 'File "' . $ strFile . '" is not an allowed file type.' ) ; } } if ( ! preg_match ( '/^' . preg_quote ( Config :: get ( 'uploadPath' ) , '/' ) . '/i' , $ strFile ) ) { throw new AccessDeniedException ( 'File or folder "' . $ strFile . '" is not within the files directory.' ) ; } if ( $ strFolder && ! preg_match ( '/^' . preg_quote ( Config :: get ( 'uploadPath' ) , '/' ) . '/i' , $ strFolder ) ) { throw new AccessDeniedException ( 'Parent folder "' . $ strFolder . '" is not within the files directory.' ) ; } if ( Input :: get ( 'act' ) == 'edit' || Input :: get ( 'act' ) == 'paste' || Input :: get ( 'act' ) == 'delete' ) { $ this -> import ( BackendUser :: class , 'User' ) ; if ( ! $ this -> User -> isAdmin && \ in_array ( $ strFile , $ this -> User -> filemounts ) ) { throw new AccessDeniedException ( 'Attempt to edit, copy, move or delete the root folder "' . $ strFile . '".' ) ; } } return true ; }
7825	protected function getTotalWidth ( ) { $ borders = ( static :: BORDER_WIDTH + static :: MIN_SPACE_FROM_BORDER_X ) * 2 ; if ( empty ( $ this -> pipes ) ) { return $ borders + $ this -> getCoreLength ( ) ; } $ borders *= count ( $ this -> pipes ) ; $ name = ( $ this -> getLongestPipeLength ( ) + static :: SPACE_FROM_ARROW ) * 2 ; return $ borders + $ name + static :: ARROW_WIDTH ; }
6978	protected function normalizeAttachment ( AttachmentInterface $ attachment ) { $ formatter = $ this -> getFormatter ( ) ; return [ 'id' => $ attachment -> getId ( ) , 'title' => $ attachment -> getTitle ( ) , 'type' => $ attachment -> getType ( ) , 'size' => $ attachment -> getSize ( ) , 'internal' => $ attachment -> isInternal ( ) , 'file' => pathinfo ( $ attachment -> getPath ( ) , PATHINFO_BASENAME ) , 'created_at' => ( $ date = $ attachment -> getCreatedAt ( ) ) ? $ date -> format ( 'Y-m-d H:i:s' ) : null , 'f_created_at' => ( $ date = $ attachment -> getCreatedAt ( ) ) ? $ formatter -> dateTime ( $ date ) : null , 'updated_at' => ( $ date = $ attachment -> getUpdatedAt ( ) ) ? $ date -> format ( 'Y-m-d H:i:s' ) : null , 'f_updated_at' => ( $ date = $ attachment -> getUpdatedAt ( ) ) ? $ formatter -> dateTime ( $ date ) : null , ] ; }
12837	public function build ( ) { $ this -> appDir = $ this -> rootDir . '/app' ; $ siteDir = $ this -> appDir . '/data/' . $ this -> siteName ; $ siteConfigDir = $ siteDir . '/config' ; $ pagesDir = $ siteDir . '/pages/pages' ; $ rolesDir = $ siteDir . '/roles' ; $ slotsDir = $ siteDir . '/slots' ; $ usersDir = $ siteDir . '/users' ; $ folders = array ( $ siteConfigDir , $ pagesDir , $ rolesDir , $ slotsDir , $ usersDir , ) ; $ this -> filesystem -> mkdir ( $ folders ) ; $ this -> createConfiguration ( $ siteDir ) ; $ this -> createSite ( $ siteDir ) ; $ this -> createRoles ( $ rolesDir ) ; $ this -> createUsers ( $ usersDir ) ; $ this -> filesystem -> touch ( $ siteDir . '/incomplete.json' ) ; return $ this ; }
3234	static function stringEquals ( $ a , $ b ) { if ( func_num_args ( ) !== 2 ) { throw new \ InvalidArgumentException ( "Expecting 2 args, got " . func_num_args ( ) . "." ) ; } Checker :: argString ( "a" , $ a ) ; Checker :: argString ( "b" , $ b ) ; $ len = strlen ( $ a ) ; if ( strlen ( $ b ) !== $ len ) return false ; $ result = 0 ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { $ result |= ord ( $ a [ $ i ] ) ^ ord ( $ b [ $ i ] ) ; } return $ result === 0 ; }
6445	public function getLoginStartUrl ( $ redirecturl ) { $ linkedin = $ this -> getClient ( $ redirecturl ) ; $ url = $ linkedin -> getLoginUrl ( array ( \ LinkedIn \ LinkedIn :: SCOPE_BASIC_PROFILE , \ LinkedIn \ LinkedIn :: SCOPE_EMAIL_ADDRESS ) ) ; return $ url ; }
8418	public static function registerDatabase ( string $ alias ) { if ( isset ( self :: $ databases [ $ alias ] ) === false ) { self :: $ databases [ $ alias ] = new static ( $ alias ) ; } }
9531	private function respondDefault ( & $ i , & $ results , $ parameter ) { $ defaultResult = $ this -> parameterCluster -> default -> call ( $ this , $ parameter ) ; if ( $ defaultResult === - 1 ) { $ this -> valid = false ; } $ results [ $ parameter ] = $ defaultResult ; $ i ++ ; }
12225	protected function retryMiddleware ( ) { return Middleware :: retry ( function ( $ retries , RequestInterface $ request , ResponseInterface $ response = null ) { if ( $ retries <= self :: $ maxRetries && $ response && $ body = $ response -> getBody ( ) ) { if ( stripos ( $ body , 'errcode' ) && ( stripos ( $ body , '40001' ) || stripos ( $ body , '42001' ) ) ) { $ field = $ this -> accessToken -> getQueryName ( ) ; $ token = $ this -> accessToken -> getToken ( true ) ; $ request = $ request -> withUri ( $ newUri = Uri :: withQueryValue ( $ request -> getUri ( ) , $ field , $ token ) ) ; Log :: debug ( "Retry with Request Token: {$token}" ) ; Log :: debug ( "Retry with Request Uri: {$newUri}" ) ; return true ; } } return false ; } ) ; }
5726	public function recordIsPublished ( ) { if ( ! $ this -> owner -> record -> checkVersioned ( ) ) { return false ; } if ( ! $ this -> owner -> record -> isInDB ( ) ) { return false ; } $ baseClass = DataObject :: getSchema ( ) -> baseDataClass ( $ this -> owner -> record ) ; $ stageTable = DataObject :: getSchema ( ) -> tableName ( $ baseClass ) . '_Live' ; return ( bool ) DB :: query ( "SELECT \"ID\" FROM \"{$stageTable}\" WHERE \"ID\" = {$this->owner->record->ID}" ) -> value ( ) ; }
4205	private function getParams ( \ ReflectionMethod $ reflectionMethod , $ phpDoc = array ( ) ) { $ paramArray = array ( ) ; $ params = $ reflectionMethod -> getParameters ( ) ; if ( empty ( $ phpDoc ) ) { $ phpDoc = $ this -> phpDoc -> getParsed ( $ reflectionMethod ) ; } foreach ( $ params as $ i => $ reflectionParameter ) { $ nameNoPrefix = $ reflectionParameter -> getName ( ) ; $ name = '$' . $ nameNoPrefix ; if ( \ method_exists ( $ reflectionParameter , 'isVariadic' ) && $ reflectionParameter -> isVariadic ( ) ) { $ name = '...' . $ name ; } if ( $ reflectionParameter -> isPassedByReference ( ) ) { $ name = '&' . $ name ; } $ constantName = null ; $ defaultValue = $ this -> abstracter -> UNDEFINED ; if ( $ reflectionParameter -> isDefaultValueAvailable ( ) ) { $ defaultValue = $ reflectionParameter -> getDefaultValue ( ) ; if ( \ version_compare ( PHP_VERSION , '5.4.6' , '>=' ) && $ reflectionParameter -> isDefaultValueConstant ( ) ) { $ constantName = $ reflectionParameter -> getDefaultValueConstantName ( ) ; } } $ paramInfo = array ( 'constantName' => $ constantName , 'defaultValue' => $ defaultValue , 'desc' => null , 'isOptional' => $ reflectionParameter -> isOptional ( ) , 'name' => $ name , 'type' => $ this -> getParamTypeHint ( $ reflectionParameter ) , ) ; if ( isset ( $ phpDoc [ 'param' ] [ $ i ] ) ) { $ paramInfo [ 'desc' ] = $ phpDoc [ 'param' ] [ $ i ] [ 'desc' ] ; if ( ! isset ( $ paramInfo [ 'type' ] ) ) { $ paramInfo [ 'type' ] = $ phpDoc [ 'param' ] [ $ i ] [ 'type' ] ; } } $ paramArray [ $ nameNoPrefix ] = $ paramInfo ; } return $ paramArray ; }
8954	public function createWay ( $ changeset , $ tags , $ nds ) { $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = 'way/create' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ tagList = '' ; if ( ! empty ( $ tags ) ) { foreach ( $ tags as $ key => $ value ) { $ tagList .= '<tag k="' . $ key . '" v="' . $ value . '"/>' ; } } $ ndList = '' ; if ( ! empty ( $ nds ) ) { foreach ( $ nds as $ value ) { $ ndList .= '<nd ref="' . $ value . '"/>' ; } } $ xml = '<?xml version="1.0" encoding="UTF-8"?> <osm version="0.6" generator="JoomlaOpenStreetMap"> <way changeset="' . $ changeset . '">' . $ tagList . $ ndList . '</way> </osm>' ; $ header [ 'Content-Type' ] = 'text/xml' ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'PUT' , $ parameters , $ xml , $ header ) ; return $ response -> body ; }
9180	final public function getViewSettings ( ) { $ rf = new \ ReflectionClass ( $ this ) ; $ this -> viewName = str_replace ( 'View' , '' , $ rf -> getShortName ( ) ) ; $ matches = array ( ) ; if ( preg_match ( "#@applyTo\((.*)\)#" , $ rf -> getDocComment ( ) , $ matches ) ) { $ params = array ( ) ; parse_str ( str_replace ( ',' , '&' , $ matches [ 1 ] ) , $ params ) ; if ( is_array ( $ params ) ) { foreach ( $ params as $ param => $ value ) { if ( $ param == 'controller' ) { $ this -> controllers = explode ( '|' , $ value ) ; } if ( $ param == 'action' ) { $ this -> actions = explode ( '|' , $ value ) ; } } } } return $ this ; }
12055	public function get ( $ name ) { if ( ! isset ( $ this -> container [ $ name ] ) ) { throw new RuntimeException ( sprintf ( 'Module "%s" is not found' , $ name ) ) ; } return $ this -> container [ $ name ] ; }
10655	public function groupBy ( $ func ) { $ ret = array ( ) ; $ it = $ this -> getIterator ( ) ; while ( $ it -> valid ( ) ) { if ( is_object ( $ it -> current ( ) ) ) { $ key = call_user_func ( $ func , $ it -> current ( ) ) ; } else { $ value = $ it -> current ( ) ; $ key = call_user_func_array ( $ func , array ( & $ value ) ) ; $ it -> offsetSet ( $ it -> key ( ) , $ value ) ; unset ( $ value ) ; } if ( is_array ( $ key ) ) { $ ref = & $ ret ; foreach ( $ key as $ subkey ) { if ( ! array_key_exists ( $ subkey , $ ref ) ) { $ ref [ $ subkey ] = array ( ) ; } $ ref = & $ ref [ $ subkey ] ; } $ ref [ ] = $ it -> current ( ) ; } else { $ ret [ $ key ] [ ] = $ it -> current ( ) ; } $ it -> next ( ) ; } unset ( $ ref ) ; $ ret = new self ( $ ret ) ; $ this -> exchangeArray ( $ ret -> getArrayCopy ( ) ) ; return $ this ; }
7323	protected function checkDate ( $ status ) { switch ( $ status ) { case 3 : case 2 : throw new Exception ( 'time is after end of day' ) ; case - 1 : throw new Exception ( 'bad year' ) ; case - 2 : throw new Exception ( 'bad month' ) ; case - 3 : throw new Exception ( 'bad day' ) ; case - 4 : throw new Exception ( 'bad hour' ) ; case - 5 : throw new Exception ( 'bad minute' ) ; case - 6 : throw new Exception ( 'bad second' ) ; default : return ; } }
4968	public function fromQuery ( $ param = null , $ default = null ) { if ( $ param === null ) { return $ this -> event -> getRequest ( ) -> getQuery ( $ param , $ default ) -> toArray ( ) ; } return $ this -> event -> getRequest ( ) -> getQuery ( $ param , $ default ) ; }
2144	public function onBadCredentials ( User $ user , AuthenticationException $ exception ) : AuthenticationException { -- $ user -> loginCount ; if ( $ user -> loginCount > 0 ) { $ user -> save ( ) ; return new BadCredentialsException ( sprintf ( 'Invalid password submitted for username "%s"' , $ user -> username ) , $ exception -> getCode ( ) , $ exception ) ; } $ user -> locked = time ( ) + $ this -> options [ 'lock_period' ] ; $ user -> loginCount = $ this -> options [ 'login_attempts' ] ; $ user -> save ( ) ; $ lockedSeconds = $ user -> locked - time ( ) ; $ lockedMinutes = ( int ) ceil ( $ lockedSeconds / 60 ) ; $ exception = new LockedException ( $ lockedSeconds , sprintf ( 'User "%s" has been locked for %s minutes' , $ user -> username , $ lockedMinutes ) , 0 , $ exception ) ; $ exception -> setUser ( $ user ) ; return $ exception ; }
11039	function store_node ( & $ elts , $ ptype , & $ i , & $ line , $ cname , $ cvalue , $ ncontent , $ content , $ code = FALSE ) { $ isabsolute = FALSE ; if ( $ cname { 0 } == '/' && $ cname { 1 } == '/' ) { $ isabsolute = TRUE ; $ cname = substr ( $ cname , 2 ) ; } $ elements = explode ( '/' , $ cname ) ; if ( count ( $ elements ) == 1 && ! $ isabsolute ) { $ elts [ $ ptype . ':' . $ i . ':' . $ cname . ':' . $ cvalue ] = $ this -> parse ( $ code ? _ETS_CODE : $ ptype , $ i , $ line , $ ncontent , $ content ) ; } else { if ( $ isabsolute ) { $ elts [ _ETS_TEMPLATE . ':' . $ i . '.1://' ] = $ this -> node_path_walk ( $ elements , 2 , $ ptype , $ i , $ line , $ cvalue , $ ncontent , $ content , $ code ) ; } else { $ element1 = array_shift ( $ elements ) ; $ masktype = ( $ ptype == _ETS_MIS || $ ptype == _ETS_MISVAL ) ? _ETS_MIS_TEMPLATE : _ETS_TEMPLATE ; $ elts [ $ masktype . ':' . $ i . '.1:' . $ element1 ] = $ this -> node_path_walk ( $ elements , 2 , $ ptype , $ i , $ line , $ cvalue , $ ncontent , $ content , $ code ) ; } } }
11042	function store_text ( & $ elts , & $ i , $ ptype , $ ntext , $ ctext ) { if ( $ ntext == 1 && $ ptype != _ETS_ROOT ) { $ elts [ _ETS_TEXT . ':' . $ i ] = $ ctext ; } }
1388	protected function resourceDoesNotSupportClientIds ( string $ type , string $ path = '/data' ) : void { $ this -> errors -> add ( $ this -> translator -> resourceDoesNotSupportClientIds ( $ type , $ path ) ) ; }
8220	protected function getSubnet ( $ ip , $ netmask ) { $ binString = @ inet_pton ( $ ip ) ; if ( $ binString === false ) { throw new \ InvalidArgumentException ( "Not a valid IP address." ) ; } $ byteLen = mb_strlen ( $ binString , "8bit" ) ; if ( ! is_int ( $ netmask ) || $ netmask < 0 || $ netmask > $ byteLen * 8 ) { throw new \ InvalidArgumentException ( "Not a valid netmask." ) ; } for ( $ byte = $ byteLen - 1 ; ( $ byte + 1 ) * 8 > $ netmask ; -- $ byte ) { $ maskLen = min ( 8 , ( $ byte + 1 ) * 8 - $ netmask ) ; $ mask = ( ~ ( ( 1 << $ maskLen ) - 1 ) ) & 0xff ; $ maskedByte = $ mask & unpack ( 'C' , $ binString [ $ byte ] ) [ 1 ] ; $ binString [ $ byte ] = pack ( 'C' , $ maskedByte ) ; } return inet_ntop ( $ binString ) . '/' . $ netmask ; }
5363	public function generate ( Registry $ registry ) { $ context = $ this -> createContext ( $ registry , 'Client' ) ; $ files = [ ] ; foreach ( $ registry -> getSchemas ( ) as $ schema ) { $ context -> setCurrentSchema ( $ schema ) ; $ files = array_merge ( $ files , $ this -> modelGenerator -> generate ( $ schema , $ schema -> getRootName ( ) , $ context ) ) ; $ files = array_merge ( $ files , $ this -> normalizerGenerator -> generate ( $ schema , $ schema -> getRootName ( ) , $ context ) ) ; $ clients = $ this -> clientGenerator -> generate ( $ schema -> getParsed ( ) , $ schema -> getNamespace ( ) , $ context , $ schema -> getOrigin ( ) . '#' ) ; foreach ( $ clients as $ node ) { $ files [ ] = new File ( $ schema -> getDirectory ( ) . DIRECTORY_SEPARATOR . 'Resource' . DIRECTORY_SEPARATOR . $ node -> stmts [ 2 ] -> name . '.php' , $ node , '' ) ; } } return $ files ; }
138	public function update ( RepositoryInterface $ repo , UpdateOperation $ operation ) { $ initial = $ operation -> getInitialPackage ( ) ; $ target = $ operation -> getTargetPackage ( ) ; $ initialType = $ initial -> getType ( ) ; $ targetType = $ target -> getType ( ) ; if ( $ initialType === $ targetType ) { $ installer = $ this -> getInstaller ( $ initialType ) ; $ installer -> update ( $ repo , $ initial , $ target ) ; $ this -> markForNotification ( $ target ) ; } else { $ this -> getInstaller ( $ initialType ) -> uninstall ( $ repo , $ initial ) ; $ this -> getInstaller ( $ targetType ) -> install ( $ repo , $ target ) ; } }
11018	public function loadView ( $ data = [ ] , $ return = FALSE ) { $ retVal = NULL ; $ extra = [ 'route' => $ this -> _getRoute ( ) , ] ; extract ( $ extra , EXTR_OVERWRITE ) ; extract ( $ data , EXTR_OVERWRITE ) ; $ level = error_reporting ( ) ; error_reporting ( 0 ) ; ob_start ( ) ; if ( isset ( $ view ) ) { $ viewsDirEvent = new GetViewsDirEvent ( ) ; $ this -> dispatcher -> fire ( Events :: EVENT_GET_VIEWS_DIR , $ viewsDirEvent ) ; $ viewDir = $ viewsDirEvent -> getViewsDir ( ) ; if ( NULL === $ viewDir ) { throw new RawException ( 'The views directory has not been set.' ) ; } if ( FALSE !== strstr ( $ view , '.php' ) ) { include $ viewDir . $ view ; } else { include $ viewDir . $ view . '.php' ; } $ newView = ob_get_clean ( ) ; if ( $ return ) { $ retVal = $ newView ; } else { $ this -> pageView .= $ newView ; } } else { $ retVal = '' ; } error_reporting ( $ level ) ; return $ retVal ; }
9754	public static function assertFile ( $ filename ) { if ( ! is_file ( $ filename ) ) { throw new InvalidArgumentException ( 'File "' . $ filename . '" does not exist.' ) ; } if ( ! is_readable ( $ filename ) ) { throw new InvalidArgumentException ( 'Could not open "' . $ filename . '" for reading.' ) ; } }
5162	public function attachGallery ( Gallery $ gallery ) : self { return $ this -> attach ( self :: ATTACHMENT_FIELD_GALLERY , $ this -> ensureOrder ( $ gallery , self :: ATTACHMENT_FIELD_GALLERY ) ) ; }
12379	public function handle ( ) : void { $ help = " -----------------------------------------------------------------\n" ; $ help .= " | Command Line Interface\n" ; $ help .= " | See more in https://github.com/senhungwong/command-line-interface\n" ; $ help .= " -------------------------------------------------------------------\n" ; $ commands = CommandEntry :: getCommands ( ) ; if ( $ command = $ this -> getArgument ( 'function-name' ) ) { $ command = new $ commands [ $ command ] ; $ help .= " - " . $ command -> getCommand ( ) . ": " ; $ help .= $ command -> getDescription ( ) . "\n" ; } else { foreach ( $ commands as $ command ) { $ command = new $ command ; $ help .= " - " ; $ help .= $ command -> getCommand ( ) . ": " ; $ help .= $ command -> getDescription ( ) . "\n" ; } } echo $ help ; }
9506	public function listLogs ( Request $ request ) { $ this -> authorize ( LogViewerPolicy :: PERMISSION_LIST ) ; $ stats = $ this -> logViewer -> statsTable ( ) ; $ headers = $ stats -> header ( ) ; $ page = $ request -> get ( 'page' , 1 ) ; $ offset = ( $ page * $ this -> perPage ) - $ this -> perPage ; $ rows = new LengthAwarePaginator ( array_slice ( $ stats -> rows ( ) , $ offset , $ this -> perPage , true ) , count ( $ stats -> rows ( ) ) , $ this -> perPage , $ page ) ; $ rows -> setPath ( $ request -> url ( ) ) ; $ this -> setTitle ( $ title = trans ( 'foundation::log-viewer.titles.logs-list' ) ) ; $ this -> addBreadcrumb ( $ title ) ; return $ this -> view ( 'admin.system.log-viewer.list' , compact ( 'headers' , 'rows' , 'footer' ) ) ; }
12493	public static function groupBy ( $ field ) { if ( ! ( gettype ( $ field ) == "string" || $ field instanceof Key || $ field instanceof Raw ) ) { throw new ClusterpointException ( "\"->group()\" function: passed field selector is not in valid format." , 9002 ) ; } if ( $ field instanceof Key ) { $ field = self :: field ( "{$field}" ) ; } return "{$field}" ; }
5700	protected function getDefaultButtonList ( $ config ) { $ new = ( $ this -> owner -> ID == 0 ) ; $ list = $ new ? Config :: inst ( ) -> get ( $ config , $ this -> checkVersioned ( ) ? "versioned_create" : "create" ) : Config :: inst ( ) -> get ( $ config , $ this -> checkVersioned ( ) ? "versioned_edit" : "edit" ) ; return $ list ? : array ( ) ; }
11226	final public static function getShortName ( $ className = '' ) { $ base = strrchr ( static :: getRealClassName ( $ className ) , '\\' ) ; return $ base ? substr ( $ base , 1 ) : $ className ; }
55	public function download ( PackageInterface $ package , $ targetDir , $ preferSource = null ) { $ preferSource = null !== $ preferSource ? $ preferSource : $ this -> preferSource ; $ sourceType = $ package -> getSourceType ( ) ; $ distType = $ package -> getDistType ( ) ; $ sources = array ( ) ; if ( $ sourceType ) { $ sources [ ] = 'source' ; } if ( $ distType ) { $ sources [ ] = 'dist' ; } if ( empty ( $ sources ) ) { throw new \ InvalidArgumentException ( 'Package ' . $ package . ' must have a source or dist specified' ) ; } if ( ! $ preferSource && ( $ this -> preferDist || 'dist' === $ this -> resolvePackageInstallPreference ( $ package ) ) ) { $ sources = array_reverse ( $ sources ) ; } $ this -> filesystem -> ensureDirectoryExists ( $ targetDir ) ; foreach ( $ sources as $ i => $ source ) { if ( isset ( $ e ) ) { $ this -> io -> writeError ( ' <warning>Now trying to download from ' . $ source . '</warning>' ) ; } $ package -> setInstallationSource ( $ source ) ; try { $ downloader = $ this -> getDownloaderForInstalledPackage ( $ package ) ; if ( $ downloader ) { $ downloader -> download ( $ package , $ targetDir ) ; } break ; } catch ( \ RuntimeException $ e ) { if ( $ i === count ( $ sources ) - 1 ) { throw $ e ; } $ this -> io -> writeError ( ' <warning>Failed to download ' . $ package -> getPrettyName ( ) . ' from ' . $ source . ': ' . $ e -> getMessage ( ) . '</warning>' ) ; } } }
4778	public function addWidget ( ItemInterface $ item ) { if ( $ this -> checkRole ) { if ( $ item -> getRole ( ) && ! $ this -> security -> isGranted ( $ item -> getRole ( ) ) ) { return $ this ; } } $ this -> widgets [ $ item -> getId ( ) ] = $ item ; return $ this ; }
2686	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ req = $ this -> api -> checkImageOptimizationStatus ( ) ; if ( ! $ req ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to check image optimization status.' ] ) ; } return $ result -> setData ( [ 'status' => true , 'req_setting' => $ req ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
12223	public function get ( $ keys = [ ] ) { $ this -> buildIfNotBuilded ( ) ; $ keys = $ keys == [ ] ? $ this -> keys ( ) : $ keys ; if ( ! $ keys ) { return $ this -> builder -> get ( ) ; } return $ this -> builder -> withColumns ( $ keys ) -> get ( $ keys ) ; }
8177	public static function sendWelcomeMessage ( User $ user ) { return Mailer :: sendMail ( $ user -> email , 'Welcome to ' . Yii :: $ app -> name , 'welcome' , [ 'user' => $ user ] ) ; }
2666	public function dictionaryItemsList ( $ dictionaryId ) { $ url = $ this -> _getApiServiceUri ( ) . 'dictionary/' . $ dictionaryId . '/items' ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: GET ) ; return $ result ; }
11448	public function actionOne ( $ option = null ) { $ fixtures = Yii :: createObject ( Fixtures :: className ( ) ) ; $ option = Question :: displayWithQuit ( 'Select operation' , [ 'Export' , 'Import' ] , $ option ) ; if ( $ option == 'e' ) { $ table = Enter :: display ( 'Enter table name for export' ) ; $ tables = $ fixtures -> export ( [ $ table ] ) ; Output :: items ( $ tables , 'Exported tables' ) ; } elseif ( $ option == 'i' ) { $ table = Enter :: display ( 'Enter table name for import' ) ; $ tables = $ fixtures -> import ( [ $ table ] ) ; Output :: items ( $ tables , 'Imported tables' ) ; } }
12494	public static function find ( $ id = null , $ connection ) { if ( gettype ( $ id ) != "string" && ! is_numeric ( $ id ) ) { throw new ClusterpointException ( "\"->find()\" function: \"_id\" is not in valid format." , 9002 ) ; } $ connection -> method = 'GET' ; $ connection -> action = '[' . urlencode ( $ id ) . ']' ; $ connection -> multiple = false ; return self :: sendQuery ( $ connection ) ; }
1222	private function wrapExpression ( $ from , callable $ expr , array $ types ) { list ( $ fn , $ pos ) = explode ( ':' , $ from ) ; $ from = "The expression return value of argument {$pos} of {$fn}" ; return function ( $ value ) use ( $ from , $ expr , $ types ) { $ value = $ expr ( $ value ) ; $ this -> validateType ( $ from , $ value , $ types ) ; return $ value ; } ; }
11996	static public function doctrine ( $ tableName , $ field , $ length = 16 ) { do { $ generate = self :: generate ( $ length ) ; } while ( self :: doctrineQuery ( $ tableName , $ field , $ generate ) ) ; return $ generate ; }
12211	public function addSnippet ( string $ snptName ) : void { $ this -> snippets [ $ snptName ] = ViewFactory :: createSnippet ( $ snptName ) ; }
7061	private function setClasses ( array $ classes ) { if ( ! empty ( $ classes ) ) { $ this -> vars [ 'attr' ] [ 'class' ] = ' ' . trim ( implode ( ' ' , $ classes ) ) ; } else { unset ( $ this -> vars [ 'attr' ] [ 'class' ] ) ; } }
7803	protected function statementBody ( $ text ) { $ accountNumber = $ this -> accountNumber ( $ text ) ; $ account = $ this -> reader -> createAccount ( $ accountNumber ) ; if ( ! ( $ account instanceof AccountInterface ) ) { return null ; } $ account -> setNumber ( $ accountNumber ) ; $ number = $ this -> statementNumber ( $ text ) ; $ statement = $ this -> reader -> createStatement ( $ account , $ number ) ; if ( ! ( $ statement instanceof StatementInterface ) ) { return null ; } $ statement -> setAccount ( $ account ) -> setNumber ( $ this -> statementNumber ( $ text ) ) -> setOpeningBalance ( $ this -> openingBalance ( $ text ) ) -> setClosingBalance ( $ this -> closingBalance ( $ text ) ) ; foreach ( $ this -> splitTransactions ( $ text ) as $ chunk ) { $ statement -> addTransaction ( $ this -> transaction ( $ chunk ) ) ; } return $ statement ; }
848	public function getNonWhitespaceSibling ( $ index , $ direction , $ whitespaces = null ) { while ( true ) { $ index += $ direction ; if ( ! $ this -> offsetExists ( $ index ) ) { return null ; } $ token = $ this [ $ index ] ; if ( ! $ token -> isWhitespace ( $ whitespaces ) ) { return $ index ; } } }
9412	public function getAuthority ( ) { $ authority = $ this -> host ; if ( $ this -> host !== '' && $ this -> user !== null ) { $ authority = $ this -> user . '@' . $ authority ; $ authority = $ authority . ':' . $ this -> port ; } return $ authority ; }
1852	protected function getNextPage ( $ rootPageId ) { $ objNextPage = PageModel :: findFirstPublishedByPid ( $ rootPageId ) ; if ( null === $ objNextPage ) { $ this -> log ( 'No active page found under root page "' . $ rootPageId . '")' , __METHOD__ , TL_ERROR ) ; throw new NoActivePageFoundException ( 'No active page found under root page.' ) ; } return $ objNextPage ; }
2664	public function sendWebHook ( $ message ) { $ url = $ this -> config -> getIncomingWebhookURL ( ) ; $ messagePrefix = $ this -> config -> getWebhookMessagePrefix ( ) ; $ currentUsername = 'System' ; try { if ( $ this -> state -> getAreaCode ( ) == 'adminhtml' ) { $ getUser = $ this -> authSession -> getUser ( ) ; if ( ! empty ( $ getUser ) ) { $ currentUsername = $ getUser -> getUserName ( ) ; } } } catch ( \ Exception $ e ) { $ this -> log -> log ( 100 , 'Failed to retrieve Area Code' ) ; } $ storeName = $ this -> helper -> getStoreName ( ) ; $ storeUrl = $ this -> helper -> getStoreUrl ( ) ; $ text = $ messagePrefix . ' user=' . $ currentUsername . ' ' . $ message . ' on <' . $ storeUrl . '|Store> | ' . $ storeName ; $ headers = [ 'Content-type: application/json' ] ; $ body = json_encode ( [ "text" => $ text , "username" => "fastly-magento-bot" , "icon_emoji" => ":airplane:" ] ) ; $ client = $ this -> curlFactory -> create ( ) ; $ client -> addOption ( CURLOPT_CONNECTTIMEOUT , 2 ) ; $ client -> addOption ( CURLOPT_TIMEOUT , 3 ) ; $ client -> write ( \ Zend_Http_Client :: POST , $ url , '1.1' , $ headers , $ body ) ; $ response = $ client -> read ( ) ; $ responseCode = \ Zend_Http_Response :: extractCode ( $ response ) ; if ( $ responseCode != 200 ) { $ this -> log -> log ( 100 , 'Failed to send message to the following Webhook: ' . $ url ) ; } $ client -> close ( ) ; }
5	private function buildDepPackageConstraints ( $ depItem , $ depType ) { if ( $ this -> isHash ( $ depItem ) ) { $ depItem = array ( $ depItem ) ; } $ result = array ( ) ; foreach ( $ depItem as $ subDepItem ) { if ( ! array_key_exists ( 'channel' , $ subDepItem ) ) { $ subDepItem [ 'channel' ] = $ subDepItem [ 'uri' ] ; } $ depChannelName = $ subDepItem [ 'channel' ] ; $ depPackageName = $ subDepItem [ 'name' ] ; $ depVersionConstraint = $ this -> parse20VersionConstraint ( $ subDepItem ) ; if ( isset ( $ subDepItem [ 'conflicts' ] ) ) { $ depType = 'conflicts' ; } $ result [ ] = new DependencyConstraint ( $ depType , $ depVersionConstraint , $ depChannelName , $ depPackageName ) ; } return $ result ; }
12875	public static function getJSON ( $ src ) { $ src = file_get_contents ( $ src ) ; $ out = json_decode ( $ src , true ) ; return $ out ; }
7629	public function setContainerAcl ( $ containerName = '' , $ acl = self :: ACL_PRIVATE , $ signedIdentifiers = array ( ) ) { Assertion :: notEmpty ( $ containerName , 'Container name is not specified' ) ; self :: assertValidContainerName ( $ containerName ) ; $ headers = array ( ) ; if ( $ acl != self :: ACL_PRIVATE && ! is_null ( $ acl ) && $ acl != '' ) { $ headers [ Storage :: PREFIX_STORAGE_HEADER . 'blob-public-access' ] = $ acl ; } $ policies = null ; if ( is_array ( $ signedIdentifiers ) && count ( $ signedIdentifiers ) > 0 ) { $ policies = '' ; $ policies .= '<?xml version="1.0" encoding="utf-8"?>' . "\r\n" ; $ policies .= '<SignedIdentifiers>' . "\r\n" ; foreach ( $ signedIdentifiers as $ signedIdentifier ) { $ policies .= ' <SignedIdentifier>' . "\r\n" ; $ policies .= ' <Id>' . $ signedIdentifier -> Id . '</Id>' . "\r\n" ; $ policies .= ' <AccessPolicy>' . "\r\n" ; if ( $ signedIdentifier -> Start != '' ) $ policies .= ' <Start>' . $ signedIdentifier -> Start . '</Start>' . "\r\n" ; if ( $ signedIdentifier -> Expiry != '' ) $ policies .= ' <Expiry>' . $ signedIdentifier -> Expiry . '</Expiry>' . "\r\n" ; if ( $ signedIdentifier -> Permissions != '' ) $ policies .= ' <Permission>' . $ signedIdentifier -> Permissions . '</Permission>' . "\r\n" ; $ policies .= ' </AccessPolicy>' . "\r\n" ; $ policies .= ' </SignedIdentifier>' . "\r\n" ; } $ policies .= '</SignedIdentifiers>' . "\r\n" ; } $ response = $ this -> performRequest ( $ containerName , array ( 'restype' => 'container' , 'comp' => 'acl' ) , 'PUT' , $ headers , false , $ policies , self :: RESOURCE_CONTAINER , self :: PERMISSION_WRITE ) ; if ( ! $ response -> isSuccessful ( ) ) { throw new BlobException ( $ this -> getErrorMessage ( $ response , 'Resource could not be accessed.' ) ) ; } }
11328	public function setFormField ( $ value ) { if ( is_array ( $ value ) ) { if ( is_null ( $ this -> formFieldClass ) ) { throw new Exception ( "DB Field incorrectly set up. What is the form class?" ) ; } if ( is_null ( $ this -> _formField ) ) { $ config = $ value ; $ config [ 'class' ] = $ this -> formFieldClass ; $ config [ 'modelField' ] = $ this ; $ value = Yii :: createObject ( $ config ) ; } else { $ settings = $ value ; $ value = $ this -> _formField ; unset ( $ settings [ 'class' ] ) ; Yii :: configure ( $ value , $ settings ) ; } } $ this -> _formField = $ value ; return true ; }
5411	public function write ( $ message ) { if ( $ this -> isError ( ) || ! $ this -> isOpen ( ) ) { return false ; } $ count = fwrite ( $ this -> handle , $ message ) ; if ( ! $ count ) { if ( $ count === false ) { $ this -> setError ( 'Cannot write to socket' ) ; $ this -> close ( ) ; } return false ; } fflush ( $ this -> handle ) ; $ this -> sent .= $ message ; return true ; }
7818	public function create ( ) : ? array { $ body = Body :: json ( [ 'name' => $ this -> name , 'event' => $ this -> event , 'device_id' => $ this -> device , 'filter_type' => '' , 'filter' => '' , 'method' => 'http' , 'action' => $ this -> url , 'secret' => $ this -> secret , ] ) ; $ response = Request :: post ( $ this -> baseUrl . 'callback' , [ ] , $ body ) ; if ( $ response -> code != 200 ) { if ( ! empty ( $ response -> body -> message ) ) { Log :: error ( $ response -> body -> message ) ; } } return [ 'code' => $ response -> code , 'message' => ( $ response -> code == 200 ) ? 'OK' : $ response -> body -> message ?? '' , 'data' => $ response -> body , ] ; }
10193	public static function getQueryPreview ( QueryBuilder $ query = null ) { if ( empty ( $ query ) ) { return "" ; } $ sql = str_replace ( '?' , "'%s'" , $ query -> toSql ( ) ) ; $ bindings = $ query -> getBindings ( ) ; return vsprintf ( $ sql , $ bindings ) ; }
8187	public function hasBlock ( $ name , array $ context = null , array $ blocks = array ( ) ) { if ( null === $ context ) { @ trigger_error ( 'The ' . __METHOD__ . ' method is internal and should never be called; calling it directly is deprecated since version 1.28 and won\'t be possible anymore in 2.0.' , E_USER_DEPRECATED ) ; return isset ( $ this -> blocks [ ( string ) $ name ] ) ; } if ( isset ( $ blocks [ $ name ] ) ) { return $ blocks [ $ name ] [ 0 ] instanceof self ; } if ( isset ( $ this -> blocks [ $ name ] ) ) { return true ; } if ( false !== $ parent = $ this -> getParent ( $ context ) ) { return $ parent -> hasBlock ( $ name , $ context ) ; } return false ; }
6386	public function readUser ( $ id ) { $ model = $ this -> readObject ( $ id , 'user' ) ; $ model -> url = $ this -> cfg -> wwwroot ; $ model -> fullname = $ this -> fullname ( $ model ) ; if ( isset ( $ model -> password ) ) { unset ( $ model -> password ) ; } if ( isset ( $ model -> secret ) ) { unset ( $ model -> secret ) ; } if ( isset ( $ model -> lastip ) ) { unset ( $ model -> lastip ) ; } return $ model ; }
266	protected function loadMessages ( $ category , $ language ) { if ( $ this -> enableCaching ) { $ key = [ __CLASS__ , $ category , $ language , ] ; $ messages = $ this -> cache -> get ( $ key ) ; if ( $ messages === false ) { $ messages = $ this -> loadMessagesFromDb ( $ category , $ language ) ; $ this -> cache -> set ( $ key , $ messages , $ this -> cachingDuration ) ; } return $ messages ; } return $ this -> loadMessagesFromDb ( $ category , $ language ) ; }
3858	public function setFilterSettings ( $ intFilter ) { $ this -> intFilter = $ intFilter ; $ this -> objFilterSettings = $ this -> getFilterFactory ( ) -> createCollection ( $ this -> intFilter ) ; if ( ! $ this -> objFilterSettings ) { throw new \ RuntimeException ( 'Error: no filter object defined.' ) ; } return $ this ; }
6661	protected function getControllerMethod ( $ methodName ) { $ reflectionMethod = $ this -> reflectedController -> getMethod ( $ methodName ) ; $ reflectionMethod -> setAccessible ( true ) ; return function ( ) use ( $ reflectionMethod ) { return $ reflectionMethod -> invokeArgs ( $ this -> controller , func_get_args ( ) ) ; } ; }
8978	protected function getRateKey ( $ currencyCode , $ date , $ rateType , $ sourceName ) { return str_replace ( [ '%currency_code%' , '%date%' , '%rate_type%' , '%source_name%' ] , [ $ currencyCode , $ date -> format ( 'Y-m-d' ) , $ rateType , $ sourceName ] , '%currency_code%_%date%_%rate_type%_%source_name%' ) ; }
6868	protected function buildInvoicePayments ( SaleInterface $ sale ) { $ currency = $ sale -> getCurrency ( ) -> getCode ( ) ; $ payments = $ this -> buildPaymentList ( $ sale ) ; $ invoices = $ this -> buildInvoiceList ( $ sale ) ; foreach ( $ invoices as $ x => & $ i ) { $ oid = spl_object_id ( $ i [ 'invoice' ] ) ; $ this -> cache [ $ oid ] = [ ] ; foreach ( $ payments as $ y => & $ p ) { $ r = new IM \ InvoicePayment ( ) ; $ r -> setPayment ( $ p [ 'payment' ] ) ; $ c = Money :: compare ( $ i [ 'total' ] , $ p [ 'amount' ] , $ currency ) ; if ( 0 === $ c ) { $ r -> setAmount ( $ p [ 'amount' ] ) ; $ i [ 'total' ] = 0 ; $ p [ 'amount' ] = 0 ; unset ( $ payments [ $ y ] ) ; } elseif ( 1 === $ c ) { $ r -> setAmount ( $ p [ 'amount' ] ) ; $ i [ 'total' ] -= $ p [ 'amount' ] ; $ p [ 'amount' ] = 0 ; unset ( $ payments [ $ y ] ) ; } else { $ r -> setAmount ( $ i [ 'total' ] ) ; $ p [ 'amount' ] -= $ i [ 'total' ] ; $ i [ 'total' ] = 0 ; } $ this -> cache [ $ oid ] [ ] = $ r ; unset ( $ p ) ; } unset ( $ i ) ; } }
3475	public function getGateway ( ) { $ gateway = $ this -> gateway ; try { $ response = $ this -> guzzle -> get ( 'https://discordapp.com/api/gateway' , [ 'headers' => [ 'Authorization' => 'Bot ' . $ this -> token , ] , ] ) ; $ gateway = Arr :: get ( json_decode ( $ response -> getBody ( ) , true ) , 'url' , $ gateway ) ; } catch ( Exception $ e ) { $ this -> warn ( "Could not get a websocket gateway address, defaulting to '{$gateway}'." ) ; } return $ gateway ; }
8178	protected function sendMail ( $ to , $ subject , $ view , $ params = [ ] ) { $ mailer = Yii :: $ app -> mailer ; $ mailer -> viewPath = '@abhimanyu/user/views/mail' ; return $ mailer -> compose ( [ 'html' => $ view , 'text' => 'text/' . $ view ] , $ params ) -> setTo ( $ to ) -> setFrom ( Yii :: $ app -> config -> get ( 'mail.username' ) , 'no@reply.com' ) -> setSubject ( $ subject ) -> send ( ) ; }
9152	public function view ( $ vars = array ( ) ) { $ output = '' ; $ vars [ 'entity' ] = $ this -> entity ; foreach ( $ this -> fields as $ field ) { if ( ! $ field instanceof Field ) { continue ; } if ( $ field -> getOutputView ( ) === false ) { continue ; } if ( $ field -> getType ( ) == 'hidden' || $ field -> getValueType ( ) == 'hidden' ) { continue ; } if ( $ field -> isHiddenOnProfile ( ) ) { continue ; } $ field_view = $ field -> viewOutput ( $ vars ) ; if ( $ field_view ) { $ output .= elgg_format_element ( 'div' , array ( 'class' => 'prototyper-output' , ) , $ field_view ) ; } } return $ output ; }
9825	public function writeDrawingRelationships ( \ PhpOffice \ PhpSpreadsheet \ Worksheet \ Worksheet $ pWorksheet , & $ chartRef , $ includeCharts = false ) { $ objWriter = null ; if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' , 'yes' ) ; $ objWriter -> startElement ( 'Relationships' ) ; $ objWriter -> writeAttribute ( 'xmlns' , 'http://schemas.openxmlformats.org/package/2006/relationships' ) ; $ i = 1 ; $ iterator = $ pWorksheet -> getDrawingCollection ( ) -> getIterator ( ) ; while ( $ iterator -> valid ( ) ) { if ( $ iterator -> current ( ) instanceof \ PhpOffice \ PhpSpreadsheet \ Worksheet \ Drawing || $ iterator -> current ( ) instanceof MemoryDrawing ) { $ this -> writeRelationship ( $ objWriter , $ i , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/image' , '../media/' . str_replace ( ' ' , '' , $ iterator -> current ( ) -> getIndexedFilename ( ) ) ) ; } $ iterator -> next ( ) ; ++ $ i ; } if ( $ includeCharts ) { $ chartCount = $ pWorksheet -> getChartCount ( ) ; if ( $ chartCount > 0 ) { for ( $ c = 0 ; $ c < $ chartCount ; ++ $ c ) { $ this -> writeRelationship ( $ objWriter , $ i ++ , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/chart' , '../charts/chart' . ++ $ chartRef . '.xml' ) ; } } } $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
10733	public static function checkLeapYear ( $ year ) { $ year = Cast :: _Int ( $ year ) ; if ( $ year % 4 !== 0 ) { return false ; } elseif ( $ year % 100 !== 0 ) { return true ; } elseif ( $ year % 400 !== 0 ) { return false ; } elseif ( $ year === 0 ) { return false ; } return true ; }
3617	public function setFanModeMinutesPerHour ( $ mode , $ serial_number = NULL ) { $ modes = explode ( ',' , $ mode ) ; $ mode = $ modes [ 0 ] ; $ duty_cycle = $ modes [ 1 ] ; return $ this -> _setFanMode ( $ mode , $ duty_cycle , NULL , $ serial_number ) ; }
5795	public function insert ( array $ columnValues , bool $ addBooleanColumnFalse = false ) { if ( $ addBooleanColumnFalse ) { $ columnValues = $ this -> addBooleanColumnFalse ( $ columnValues ) ; } $ ib = new InsertBuilder ( $ this -> tableName ) ; if ( $ this -> getPrimaryKeyColumnName ( ) !== null ) { $ ib -> setPrimaryKeyName ( $ this -> getPrimaryKeyColumnName ( ) ) ; } $ this -> addColumnsToBuilder ( $ ib , $ columnValues ) ; return $ ib -> runExecute ( ) ; }
8201	protected function exportJob ( $ job ) { $ stats = $ this -> getJobStats ( $ job ) ; $ contents = $ this -> renderForExport ( $ job , $ stats ) ; $ filename = trim ( $ this -> path , '/' ) . '/' . $ this -> buildJobFileName ( $ job , $ stats ) ; if ( file_exists ( $ filename ) ) { throw new \ RuntimeException ( 'File already exists.' ) ; } if ( ! file_put_contents ( $ filename , $ contents ) ) { throw new \ RuntimeException ( 'Error saving the file.' ) ; } }
1973	public static function findMultipleByPaths ( $ arrPaths , array $ arrOptions = array ( ) ) { if ( empty ( $ arrPaths ) || ! \ is_array ( $ arrPaths ) ) { return null ; } $ t = static :: $ strTable ; if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = Database :: getInstance ( ) -> findInSet ( "$t.path" , $ arrPaths ) ; } return static :: findBy ( array ( "$t.path IN(" . implode ( ',' , array_fill ( 0 , \ count ( $ arrPaths ) , '?' ) ) . ")" ) , $ arrPaths , $ arrOptions ) ; }
9725	public function getTemporaryFilename ( $ extension = 'xlsx' ) { $ temporaryFilename = tempnam ( $ this -> getTemporaryFolder ( ) , 'phpspreadsheet-' ) ; unlink ( $ temporaryFilename ) ; return $ temporaryFilename . '.' . $ extension ; }
2411	public function exportTheme ( DataContainer $ dc ) { $ objTheme = $ this -> Database -> prepare ( "SELECT * FROM tl_theme WHERE id=?" ) -> limit ( 1 ) -> execute ( $ dc -> id ) ; if ( $ objTheme -> numRows < 1 ) { return ; } $ strName = Utf8 :: toAscii ( $ objTheme -> name ) ; $ strName = strtolower ( str_replace ( ' ' , '_' , $ strName ) ) ; $ strName = preg_replace ( '/[^A-Za-z0-9._-]/' , '' , $ strName ) ; $ strName = basename ( $ strName ) ; $ xml = new \ DOMDocument ( '1.0' , 'UTF-8' ) ; $ xml -> formatOutput = true ; $ tables = $ xml -> createElement ( 'tables' ) ; $ tables = $ xml -> appendChild ( $ tables ) ; $ this -> addTableTlTheme ( $ xml , $ tables , $ objTheme ) ; $ this -> addTableTlStyleSheet ( $ xml , $ tables , $ objTheme ) ; $ this -> addTableTlImageSize ( $ xml , $ tables , $ objTheme ) ; $ this -> addTableTlModule ( $ xml , $ tables , $ objTheme ) ; $ this -> addTableTlLayout ( $ xml , $ tables , $ objTheme ) ; $ strTmp = md5 ( uniqid ( mt_rand ( ) , true ) ) ; $ objArchive = new ZipWriter ( 'system/tmp/' . $ strTmp ) ; $ this -> addTableTlFiles ( $ xml , $ tables , $ objTheme , $ objArchive ) ; $ this -> addTemplatesToArchive ( $ objArchive , $ objTheme -> templates ) ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'exportTheme' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'exportTheme' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'exportTheme' ] as $ callback ) { System :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ xml , $ objArchive , $ objTheme -> id ) ; } } $ objArchive -> addString ( $ xml -> saveXML ( ) , 'theme.xml' ) ; $ objArchive -> close ( ) ; $ objFile = new File ( 'system/tmp/' . $ strTmp ) ; $ objFile -> sendToBrowser ( $ strName . '.cto' ) ; }
1262	protected function compileEndpointUrl ( $ segment ) { $ base = ( $ this -> useIntegration ? $ this -> integrationBaseUrl : $ this -> productionBaseUrl ) ; return $ base . $ segment ; }
1871	public function generateAjax ( $ strFolder , $ strField , $ level , $ mount = false ) { if ( ! Environment :: get ( 'isAjaxRequest' ) ) { return '' ; } $ this -> strField = $ strField ; $ this -> loadDataContainer ( $ this -> strTable ) ; switch ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'dataContainer' ] ) { case 'File' : if ( Config :: get ( $ this -> strField ) != '' ) { $ this -> varValue = Config :: get ( $ this -> strField ) ; } break ; case 'Table' : $ this -> import ( Database :: class , 'Database' ) ; if ( ! $ this -> Database -> fieldExists ( $ this -> strField , $ this -> strTable ) ) { break ; } $ objField = $ this -> Database -> prepare ( "SELECT " . Database :: quoteIdentifier ( $ this -> strField ) . " FROM " . $ this -> strTable . " WHERE id=?" ) -> limit ( 1 ) -> execute ( $ this -> strId ) ; if ( $ objField -> numRows ) { $ this -> varValue = StringUtil :: deserialize ( $ objField -> { $ this -> strField } ) ; } break ; } $ this -> convertValuesToPaths ( ) ; if ( $ this -> extensions != '' ) { $ this -> arrValidFileTypes = StringUtil :: trimsplit ( ',' , $ this -> extensions ) ; } return $ this -> renderFiletree ( System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) . '/' . $ strFolder , ( $ level * 20 ) , $ mount , $ this -> isProtectedPath ( $ strFolder ) ) ; }
2326	public static function createFromDbResult ( Result $ objResult , $ strTable ) { $ arrModels = array ( ) ; $ strClass = Model :: getClassFromTable ( $ strTable ) ; while ( $ objResult -> next ( ) ) { $ objModel = Registry :: getInstance ( ) -> fetch ( $ strTable , $ objResult -> { $ strClass :: getPk ( ) } ) ; if ( $ objModel !== null ) { $ objModel -> mergeRow ( $ objResult -> row ( ) ) ; $ arrModels [ ] = $ objModel ; } else { $ arrModels [ ] = new $ strClass ( $ objResult ) ; } } return new static ( $ arrModels , $ strTable ) ; }
5056	public function attachEvents ( EventManagerInterface $ events , array $ eventsSpec = null ) { if ( null === $ eventsSpec ) { $ eventsSpec = $ this -> eventsProvider ( ) ; } foreach ( $ eventsSpec as $ spec ) { if ( ! is_array ( $ spec ) || 2 > count ( $ spec ) ) { throw new \ UnexpectedValueException ( 'Event specification must be an array with at least two entries: event name and method name.' ) ; } $ event = $ spec [ 0 ] ; $ method = $ spec [ 1 ] ; $ priority = isset ( $ spec [ 2 ] ) ? $ spec [ 2 ] : 0 ; $ this -> listeners [ ] = $ events -> attach ( $ event , [ $ this , $ method ] , $ priority ) ; } return $ this ; }
5040	public function setPermissions ( PermissionsInterface $ permissions ) { foreach ( $ this -> getImages ( ) as $ file ) { $ filePermissions = $ file -> getPermissions ( ) ; $ filePermissions -> clear ( ) ; $ filePermissions -> inherit ( $ permissions ) ; } return $ this ; }
4066	public function handle ( BuildWidgetEvent $ event ) { $ environment = $ event -> getEnvironment ( ) ; if ( ( $ environment -> getDataDefinition ( ) -> getName ( ) !== 'tl_metamodel_dcasetting' ) || ( $ event -> getProperty ( ) -> getName ( ) !== 'mandatory' ) || ( null === $ event -> getModel ( ) -> getId ( ) ) ) { return ; } $ model = $ event -> getModel ( ) ; $ metaModel = $ this -> getMetaModelFromModel ( $ model ) ; $ attribute = $ metaModel -> getAttributeById ( $ model -> getProperty ( 'attr_id' ) ) ; if ( null === $ attribute ) { return ; } if ( $ attribute -> get ( 'isunique' ) ) { Message :: addInfo ( $ this -> translator -> trans ( 'tl_metamodel_dcasetting.mandatory_for_unique_attr' , [ ] , 'contao_tl_metamodel_dcasetting' ) ) ; $ extra = $ event -> getProperty ( ) -> getExtra ( ) ; $ extra [ 'disabled' ] = true ; $ event -> getProperty ( ) -> setExtra ( $ extra ) ; $ model -> setProperty ( 'mandatory' , true ) ; } }
852	public function getMeaningfulTokenSibling ( $ index , $ direction ) { return $ this -> getTokenNotOfKindSibling ( $ index , $ direction , [ [ T_WHITESPACE ] , [ T_COMMENT ] , [ T_DOC_COMMENT ] ] ) ; }
9815	public function setWorksheet ( Worksheet $ value = null ) { if ( $ value !== null ) { $ this -> worksheet = $ value ; } return $ this ; }
9500	public function supportsEvent ( $ eventId ) { $ supportedEvents = [ WatcherInterface :: CREATE_EVENT , WatcherInterface :: MODIFY_EVENT , WatcherInterface :: DELETE_EVENT , WatcherInterface :: ALL_EVENT ] ; return array_search ( $ eventId , $ supportedEvents , true ) !== false ; }
7417	protected function setView ( string $ name = '' , array $ data = [ ] ) { if ( ! empty ( $ data ) ) { $ this -> data = array_replace ( $ this -> data , $ data ) ; } $ content = ( new Native ( $ this -> packageRoot , $ this -> request -> language ( ) , ! Wrap :: isEnabled ( ) ) ) -> getContent ( $ name , $ this -> data ) ; $ this -> response -> setContent ( $ content ) ; }
3700	private function handleSorting ( $ information , GroupAndSortingDefinitionInterface $ definition ) { if ( $ information [ 'ismanualsort' ] ) { $ definition -> add ( ) -> setManualSorting ( ) -> setProperty ( 'sorting' ) -> setSortingMode ( GroupAndSortingInformationInterface :: SORT_ASC ) ; return ; } if ( $ information [ 'col_name' ] ) { $ definition -> add ( ) -> setProperty ( $ information [ 'col_name' ] ) -> setSortingMode ( $ information [ 'rendersort' ] ) ; } }
8918	public function messages ( $ options ) { $ params = [ 'query' => [ 'apikey' => $ this -> apikey , 'limit' => 100 , 'page' => 1 ] ] ; if ( array_key_exists ( 'limit' , $ options ) ) { $ params [ 'query' ] [ 'limit' ] = $ options [ 'limit' ] ; } if ( array_key_exists ( 'page' , $ options ) ) { $ params [ 'query' ] [ 'page' ] = $ options [ 'page' ] ; } if ( array_key_exists ( 'startDate' , $ options ) ) { $ params [ 'query' ] [ 'startDate' ] = $ options [ 'startDate' ] ; } if ( array_key_exists ( 'endDate' , $ options ) ) { $ params [ 'query' ] [ 'endDate' ] = $ options [ 'endDate' ] ; } if ( array_key_exists ( 'status' , $ options ) ) { $ params [ 'query' ] [ 'status' ] = $ options [ 'status' ] ; } if ( array_key_exists ( 'network' , $ options ) ) { $ params [ 'query' ] [ 'network' ] = $ options [ 'network' ] ; } if ( array_key_exists ( 'sendername' , $ options ) ) { $ params [ 'query' ] [ 'sendername' ] = $ options [ 'sendername' ] ; } $ response = $ this -> client -> get ( 'messages' , $ params ) ; return $ response -> getBody ( ) ; }
2010	public function indexAction ( ) : InitializeControllerResponse { @ trigger_error ( 'Custom entry points are deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; $ masterRequest = $ this -> get ( 'request_stack' ) -> getMasterRequest ( ) ; if ( null === $ masterRequest ) { throw new \ RuntimeException ( 'The request stack did not contain a master request.' ) ; } $ realRequest = Request :: createFromGlobals ( ) ; foreach ( [ 'REQUEST_URI' , 'SCRIPT_NAME' , 'SCRIPT_FILENAME' , 'PHP_SELF' ] as $ name ) { $ realRequest -> server -> set ( $ name , str_replace ( TL_SCRIPT , 'index.php' , $ realRequest -> server -> get ( $ name ) ) ) ; } $ realRequest -> attributes -> replace ( $ masterRequest -> attributes -> all ( ) ) ; $ this -> get ( 'request_stack' ) -> push ( $ realRequest ) ; $ this -> get ( 'contao.framework' ) -> initialize ( ) ; $ this -> get ( 'request_stack' ) -> push ( $ masterRequest ) ; return new InitializeControllerResponse ( '' , 204 ) ; }
10668	public static function build ( $ input , array $ options = [ ] ) { if ( ! \ is_array ( $ options ) ) { $ options = [ 'return' => ( string ) $ options ] ; } $ defaults = [ 'return' => 'simplexml' , ] ; $ options = array_merge ( $ defaults , $ options ) ; if ( is_array ( $ input ) || is_object ( $ input ) ) { return self :: fromArray ( ( array ) $ input , $ options ) ; } if ( strpos ( $ input , '<' ) !== false ) { if ( $ options [ 'return' ] === 'simplexml' || $ options [ 'return' ] === 'simplexmlelement' ) { return new \ SimpleXMLElement ( $ input , LIBXML_NOCDATA ) ; } $ dom = new \ DOMDocument ( ) ; $ dom -> loadXML ( $ input ) ; return $ dom ; } if ( file_exists ( $ input ) || strpos ( $ input , 'http://' ) === 0 || strpos ( $ input , 'https://' ) === 0 ) { if ( $ options [ 'return' ] === 'simplexml' || $ options [ 'return' ] === 'simplexmlelement' ) { return new \ SimpleXMLElement ( $ input , LIBXML_NOCDATA , true ) ; } $ dom = new \ DOMDocument ( ) ; $ dom -> load ( $ input ) ; return $ dom ; } if ( ! \ is_string ( $ input ) ) { throw new \ RuntimeException ( Tools :: poorManTranslate ( 'fts-shared' , 'Invalid input.' ) ) ; } throw new \ RuntimeException ( Tools :: poorManTranslate ( 'fts-shared' , 'XML cannot be read.' ) ) ; }
10791	public function register ( SilexApp $ app ) { $ app [ 'twig' ] = $ app -> share ( $ app -> extend ( 'twig' , function ( \ Twig_Environment $ twig , SilexApp $ app ) { $ class = $ this -> getServiceConfig ( ) -> getProviderClass ( ) ; $ twig -> addExtension ( new $ class ) ; return $ twig ; } ) ) ; }
172	private static function matchPathname ( $ path , $ basePath , $ pattern , $ firstWildcard , $ flags ) { if ( isset ( $ pattern [ 0 ] ) && $ pattern [ 0 ] === '/' ) { $ pattern = StringHelper :: byteSubstr ( $ pattern , 1 , StringHelper :: byteLength ( $ pattern ) ) ; if ( $ firstWildcard !== false && $ firstWildcard !== 0 ) { $ firstWildcard -- ; } } $ namelen = StringHelper :: byteLength ( $ path ) - ( empty ( $ basePath ) ? 0 : StringHelper :: byteLength ( $ basePath ) + 1 ) ; $ name = StringHelper :: byteSubstr ( $ path , - $ namelen , $ namelen ) ; if ( $ firstWildcard !== 0 ) { if ( $ firstWildcard === false ) { $ firstWildcard = StringHelper :: byteLength ( $ pattern ) ; } if ( $ firstWildcard > $ namelen ) { return false ; } if ( strncmp ( $ pattern , $ name , $ firstWildcard ) ) { return false ; } $ pattern = StringHelper :: byteSubstr ( $ pattern , $ firstWildcard , StringHelper :: byteLength ( $ pattern ) ) ; $ name = StringHelper :: byteSubstr ( $ name , $ firstWildcard , $ namelen ) ; if ( empty ( $ pattern ) && empty ( $ name ) ) { return true ; } } $ matchOptions = [ 'filePath' => true ] ; if ( $ flags & self :: PATTERN_CASE_INSENSITIVE ) { $ matchOptions [ 'caseSensitive' ] = false ; } return StringHelper :: matchWildcard ( $ pattern , $ name , $ matchOptions ) ; }
10078	public static function convertEncoding ( $ value , $ to , $ from ) { if ( self :: getIsIconvEnabled ( ) ) { $ result = iconv ( $ from , $ to . '//IGNORE//TRANSLIT' , $ value ) ; if ( false !== $ result ) { return $ result ; } } return mb_convert_encoding ( $ value , $ to , $ from ) ; }
3698	private function getOrCreateDefinition ( ) { if ( $ this -> container -> hasDefinition ( Contao2BackendViewDefinitionInterface :: NAME ) ) { $ view = $ this -> container -> getDefinition ( Contao2BackendViewDefinitionInterface :: NAME ) ; if ( ! $ view instanceof Contao2BackendViewDefinitionInterface ) { throw new DcGeneralInvalidArgumentException ( 'Configured BackendViewDefinition does not implement Contao2BackendViewDefinitionInterface.' ) ; } return $ view ; } $ this -> container -> setDefinition ( Contao2BackendViewDefinitionInterface :: NAME , $ view = new Contao2BackendViewDefinition ( ) ) ; return $ view ; }
6707	public function afterFind ( $ event ) { if ( is_array ( $ this -> fields ) ) { foreach ( $ this -> fields as $ field ) { if ( $ event -> sender -> { $ field } ) { $ event -> sender -> { $ field } = explode ( ';' , $ event -> sender -> { $ field } ) ; } } } }
5315	protected function generateBlocks ( ) { $ blocks = [ ] ; foreach ( range ( 1 , $ this -> getBlocks ( ) ) as $ counter ) { $ blocks [ ] = $ this -> generateChars ( ) ; } return implode ( $ this -> blockSeparator , $ blocks ) ; }
9537	private function getPrefix ( $ parameter ) { $ prefix = null ; foreach ( array_keys ( $ this -> parameterCluster -> prefixes ) as $ _prefix ) { if ( substr ( $ parameter , 0 , strlen ( $ _prefix ) ) == $ _prefix ) { $ prefix = $ _prefix ; } } return $ prefix ; }
2997	public function setFrom ( $ email , $ title = null ) { $ this -> set ( 'From' , $ this -> buildMail ( $ email , $ title ) ) ; }
10693	protected function fixTable ( $ table , $ tableAlias = '' ) { if ( empty ( $ table ) ) { $ table = [ ] ; } else { if ( ! is_array ( $ table ) ) { $ table = empty ( $ tableAlias ) ? [ $ table ] : [ $ table => $ tableAlias ] ; } } return $ table ; }
5092	public function assemble ( ) { $ command = 'CREATE ' . $ this -> getPartIfSet ( self :: PART_TEMP ) . 'TABLE ' . $ this -> getPartIfSet ( self :: PART_IF_NOT_EXIST ) . $ this -> parts [ self :: PART_DB ] . $ this -> parts [ self :: PART_NAME ] ; if ( $ this -> parts [ self :: PART_LIKE ] ) { return $ command . ' ' . $ this -> parts [ self :: PART_LIKE ] ; } if ( ! $ this -> columnsList -> isEmpty ( ) ) { $ command .= '(' ; $ columns = $ this -> columnsList -> assemble ( ) ; $ keys = $ this -> indexes -> assemble ( ) ; $ combined = array_merge ( $ columns , $ keys ) ; $ command .= implode ( ',' , $ combined ) ; $ command .= ') ' . $ this -> getPartIfSet ( self :: PART_ENGINE , 'ENGINE=' ) . $ this -> getPartIfSet ( self :: PART_CHARSET , 'CHARSET=' ) . $ this -> getPartIfSet ( self :: PART_CHARSET , 'AUTO_INCREMENT=' ) . $ this -> getPartIfSet ( self :: PART_COMMENT , 'COMMENT=' ) ; } if ( $ this -> parts [ self :: PART_AS ] ) { $ command .= " {$this->getAsExpression()}" ; } return $ command ; }
10123	private function writePrintGridlines ( ) { $ record = 0x002b ; $ length = 0x0002 ; $ fPrintGrid = $ this -> phpSheet -> getPrintGridlines ( ) ? 1 : 0 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ fPrintGrid ) ; $ this -> append ( $ header . $ data ) ; }
1662	public function reply ( $ message ) { if ( is_string ( $ message ) ) { $ this -> messages [ ] = Text :: create ( ) -> text ( $ message ) -> setAgentVersion ( $ this -> agentVersion ) -> setRequestSource ( $ this -> requestSource ) ; if ( ! $ this -> doesSupportRichMessage ( ) ) { $ this -> text = $ message ; } } elseif ( $ message instanceof RichMessage ) { if ( ! $ this -> doesSupportRichMessage ( ) ) { $ this -> text = $ message -> getFallbackText ( ) ; } $ message -> setAgentVersion ( $ this -> agentVersion ) -> setRequestSource ( $ this -> requestSource ) ; $ this -> messages [ ] = $ message ; } elseif ( $ message instanceof Conversation ) { $ this -> messages [ ] = Payload :: create ( $ message -> render ( ) ) -> setAgentVersion ( $ this -> agentVersion ) -> setRequestSource ( $ this -> requestSource ) ; } return $ this ; }
5660	private function collectSelectOptions ( $ node ) { $ options = array ( ) ; if ( $ node -> name === 'option' ) { $ options [ ] = $ this -> tags ( ) -> createTag ( $ node -> name , $ this -> attributes ( $ node ) ) -> addContent ( $ this -> innerHtml ( $ node ) ) ; } if ( $ node -> hasChildren ( ) ) { foreach ( $ node -> child as $ child ) { $ options = array_merge ( $ options , $ this -> collectSelectOptions ( $ child ) ) ; } } return $ options ; }
2641	public function cleanBySurrogateKey ( $ keys ) { $ type = 'clean by key on ' ; $ uri = $ this -> _getApiServiceUri ( ) . 'purge' ; $ num = count ( $ keys ) ; $ result = false ; if ( $ num >= self :: FASTLY_MAX_HEADER_KEY_SIZE ) { $ parts = $ num / self :: FASTLY_MAX_HEADER_KEY_SIZE ; $ additional = ( $ parts > ( int ) $ parts ) ? 1 : 0 ; $ parts = ( int ) $ parts + ( int ) $ additional ; $ chunks = ceil ( $ num / $ parts ) ; $ collection = array_chunk ( $ keys , $ chunks ) ; } else { $ collection = [ $ keys ] ; } foreach ( $ collection as $ keys ) { $ payload = json_encode ( [ 'surrogate_keys' => $ keys ] ) ; $ result = $ this -> _purge ( $ uri , null , \ Zend_Http_Client :: POST , $ payload ) ; if ( $ result [ 'status' ] ) { foreach ( $ keys as $ key ) { $ this -> logger -> execute ( 'surrogate key: ' . $ key ) ; } } $ canPublishKeyUrlChanges = $ this -> config -> canPublishKeyUrlChanges ( ) ; $ canPublishPurgeChanges = $ this -> config -> canPublishPurgeChanges ( ) ; if ( $ this -> config -> areWebHooksEnabled ( ) && ( $ canPublishKeyUrlChanges || $ canPublishPurgeChanges ) ) { $ status = $ result [ 'status' ] ? '' : 'FAILED ' ; $ this -> sendWebHook ( $ status . '*clean by key on ' . join ( " " , $ keys ) . '*' ) ; $ canPublishPurgeByKeyDebugBacktrace = $ this -> config -> canPublishPurgeByKeyDebugBacktrace ( ) ; $ canPublishPurgeDebugBacktrace = $ this -> config -> canPublishPurgeDebugBacktrace ( ) ; if ( $ canPublishPurgeByKeyDebugBacktrace == false && $ canPublishPurgeDebugBacktrace == false ) { return $ result [ 'status' ] ; } $ this -> stackTrace ( $ type . join ( " " , $ keys ) ) ; } } return $ result [ 'status' ] ; }
653	protected function getCacheKey ( $ method , $ fetchMode , $ rawSql ) { return [ __CLASS__ , $ method , $ fetchMode , $ this -> db -> dsn , $ this -> db -> username , $ rawSql , ] ; }
9771	function most ( $ value ) : self { $ target = $ this -> hasFlag ( 'length' ) ? $ this -> getLength ( $ this -> target ) : $ this -> target ; return $ this -> expect ( $ target , lessThanOrEqual ( $ value ) ) ; }
10107	private function writeColinfo ( $ col_array ) { if ( isset ( $ col_array [ 0 ] ) ) { $ colFirst = $ col_array [ 0 ] ; } if ( isset ( $ col_array [ 1 ] ) ) { $ colLast = $ col_array [ 1 ] ; } if ( isset ( $ col_array [ 2 ] ) ) { $ coldx = $ col_array [ 2 ] ; } else { $ coldx = 8.43 ; } if ( isset ( $ col_array [ 3 ] ) ) { $ xfIndex = $ col_array [ 3 ] ; } else { $ xfIndex = 15 ; } if ( isset ( $ col_array [ 4 ] ) ) { $ grbit = $ col_array [ 4 ] ; } else { $ grbit = 0 ; } if ( isset ( $ col_array [ 5 ] ) ) { $ level = $ col_array [ 5 ] ; } else { $ level = 0 ; } $ record = 0x007D ; $ length = 0x000C ; $ coldx *= 256 ; $ ixfe = $ xfIndex ; $ reserved = 0x0000 ; $ level = max ( 0 , min ( $ level , 7 ) ) ; $ grbit |= $ level << 8 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vvvvvv' , $ colFirst , $ colLast , $ coldx , $ ixfe , $ grbit , $ reserved ) ; $ this -> append ( $ header . $ data ) ; }
5698	public function baseTransform ( ) { parent :: baseTransform ( ) ; $ disabled = ( ! $ this -> gridFieldRequest -> getNextRecordID ( ) ) ; return $ this -> setDisabled ( $ disabled ) ; }
9149	public function markAsUnread ( $ uid ) { if ( ! $ object = $ this -> model -> find ( $ uid ) ) { abort ( 404 ) ; } $ this -> authorize ( 'update' , $ object ) ; if ( ! is_null ( $ object -> read_at ) ) { $ object -> forceFill ( [ 'read_at' => null ] ) -> save ( ) ; } \ Cache :: tags ( 'response' ) -> flush ( ) ; return $ this -> successJsonResponse ( ) ; }
7314	public function setTime ( $ hour , $ min , $ sec ) { $ status = IAU :: Tf2d ( '+' , ( int ) $ hour , ( int ) $ min , ( float ) $ sec , $ days ) ; $ this -> checkTime ( $ status ) ; $ this -> dayFrac = $ days ; return $ this ; }
4412	public function getLegacyPreference ( $ name ) { $ legacyKernel = $ this -> legacyKernel ; return $ legacyKernel ( ) -> runCallback ( function ( ) use ( $ name ) { return eZPreferences :: value ( $ name ) ; } ) ; }
4288	public function onError ( Event $ event ) { if ( $ event [ 'inConsole' ] || ! $ event [ 'isFirstOccur' ] ) { return ; } $ this -> processLogEntry ( 'errorNotConsoled' , array ( $ event [ 'typeStr' ] . ': ' . $ event [ 'file' ] . ' (line ' . $ event [ 'line' ] . '): ' . $ event [ 'message' ] ) , array ( 'channel' => 'phpError' , 'class' => $ event [ 'type' ] & $ this -> debug -> getCfg ( 'errorMask' ) ? 'danger' : 'warning' , ) ) ; }
51	public function addRepository ( RepositoryInterface $ repository ) { if ( $ repository instanceof self ) { foreach ( $ repository -> getRepositories ( ) as $ repo ) { $ this -> addRepository ( $ repo ) ; } } else { $ this -> repositories [ ] = $ repository ; } }
12190	public function getActive ( ) { return ( isset ( $ this -> _child ) and $ this -> _child -> active ) and ( isset ( $ this -> _parent ) and $ this -> _parent -> active ) ; }
822	private function fixSemicolonAfterCurlyBraceClose ( Tokens $ tokens , $ index , $ curlyCloseIndex ) { static $ beforeCurlyOpeningKinds = null ; if ( null === $ beforeCurlyOpeningKinds ) { $ beforeCurlyOpeningKinds = [ T_ELSE , T_FINALLY , T_NAMESPACE , T_OPEN_TAG ] ; } $ curlyOpeningIndex = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_CURLY_BRACE , $ curlyCloseIndex ) ; $ beforeCurlyOpening = $ tokens -> getPrevMeaningfulToken ( $ curlyOpeningIndex ) ; if ( $ tokens [ $ beforeCurlyOpening ] -> isGivenKind ( $ beforeCurlyOpeningKinds ) || $ tokens [ $ beforeCurlyOpening ] -> equalsAny ( [ ';' , '{' , '}' ] ) ) { $ tokens -> clearTokenAndMergeSurroundingWhitespace ( $ index ) ; return ; } if ( $ tokens [ $ beforeCurlyOpening ] -> isGivenKind ( T_STRING ) ) { $ classyTest = $ tokens -> getPrevMeaningfulToken ( $ beforeCurlyOpening ) ; while ( $ tokens [ $ classyTest ] -> equals ( ',' ) || $ tokens [ $ classyTest ] -> isGivenKind ( [ T_STRING , T_NS_SEPARATOR , T_EXTENDS , T_IMPLEMENTS ] ) ) { $ classyTest = $ tokens -> getPrevMeaningfulToken ( $ classyTest ) ; } $ tokensAnalyzer = new TokensAnalyzer ( $ tokens ) ; if ( $ tokens [ $ classyTest ] -> isGivenKind ( T_NAMESPACE ) || ( $ tokens [ $ classyTest ] -> isClassy ( ) && ! $ tokensAnalyzer -> isAnonymousClass ( $ classyTest ) ) ) { $ tokens -> clearTokenAndMergeSurroundingWhitespace ( $ index ) ; } return ; } if ( ! $ tokens [ $ beforeCurlyOpening ] -> equals ( ')' ) ) { return ; } $ openingBrace = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ beforeCurlyOpening ) ; $ beforeOpeningBrace = $ tokens -> getPrevMeaningfulToken ( $ openingBrace ) ; if ( $ tokens [ $ beforeOpeningBrace ] -> isGivenKind ( [ T_IF , T_ELSEIF , T_FOR , T_FOREACH , T_WHILE , T_SWITCH , T_CATCH , T_DECLARE ] ) ) { $ tokens -> clearTokenAndMergeSurroundingWhitespace ( $ index ) ; return ; } if ( $ tokens [ $ beforeOpeningBrace ] -> isGivenKind ( T_STRING ) ) { $ beforeString = $ tokens -> getPrevMeaningfulToken ( $ beforeOpeningBrace ) ; if ( $ tokens [ $ beforeString ] -> isGivenKind ( T_FUNCTION ) ) { $ tokens -> clearTokenAndMergeSurroundingWhitespace ( $ index ) ; } } }
5570	public function retry ( ) { $ frames = $ this -> page -> getFrameFocus ( ) ; if ( count ( $ frames ) > 0 ) { $ this -> loadFrame ( $ frames , $ this -> page -> getUrl ( ) , $ this -> page -> getRequestData ( ) ) ; return $ this -> page -> getRaw ( ) ; } if ( $ url = $ this -> history -> getUrl ( ) ) { $ this -> page = $ this -> fetch ( $ url , $ this -> history -> getParameters ( ) ) ; return $ this -> page -> getRaw ( ) ; } return false ; }
237	protected function setTableMetadata ( $ name , $ type , $ data ) { $ this -> _tableMetadata [ $ this -> getRawTableName ( $ name ) ] [ $ type ] = $ data ; }
12553	public function save ( $ path , $ name = null ) { if ( ! file_exists ( $ path ) ) { mkdir ( $ path , 0777 , true ) ; } $ destinationPath = rtrim ( $ path , '/' ) ; if ( $ name ) { $ destinationPath .= '/' . $ name ; } else { $ destinationPath .= '/' . $ this -> name ; } if ( ! copy ( $ this -> tmpName , $ destinationPath ) ) { $ reason = 'Unknown' ; if ( ! file_exists ( $ path ) ) { $ reason = 'Path "' . $ path . '" not exists.' ; } else if ( ! is_writeable ( $ path ) ) $ reason = 'Path "' . $ path . '" required permission to write.' ; throw new FileFailSavedException ( $ reason ) ; } }
5962	public function serverGroupPermList ( $ sgid , $ permsid = false ) { return $ this -> execute ( "servergrouppermlist" , array ( "sgid" => $ sgid , $ permsid ? "-permsid" : null ) ) -> toAssocArray ( $ permsid ? "permsid" : "permid" ) ; }
7074	private function addSaleDetails ( array & $ details , Model \ SaleInterface $ sale ) { if ( $ sale -> getCurrency ( ) -> getCode ( ) !== $ this -> currency ) { return ; } if ( 0 !== Money :: compare ( $ sale -> getGrandTotal ( ) , $ details [ 'PAYMENTREQUEST_0_AMT' ] , $ this -> currency ) ) { return ; } $ this -> calculator -> calculateSale ( $ sale ) ; $ this -> line = 0 ; $ lineTotals = 0 ; foreach ( $ sale -> getItems ( ) as $ item ) { $ lineTotals += $ this -> addItemDetails ( $ details , $ item ) ; } foreach ( $ sale -> getAdjustments ( Model \ AdjustmentTypes :: TYPE_DISCOUNT ) as $ discount ) { $ lineTotals += $ this -> addDiscountDetails ( $ details , $ discount ) ; } $ details [ 'PAYMENTREQUEST_0_ITEMAMT' ] = $ this -> format ( $ lineTotals ) ; $ details [ 'PAYMENTREQUEST_0_SHIPPINGAMT' ] = $ this -> format ( $ sale -> getShipmentResult ( ) -> getTotal ( ) ) ; }
10186	private static function fromArray ( $ object , $ type = null , $ innerType = null ) { if ( $ type == 'array' ) { foreach ( $ object as $ element ) { $ result [ ] = self :: fromArray ( $ element , $ innerType ) ; } return $ result ; } else if ( class_exists ( $ type ) ) { $ class = new $ type ( ) ; if ( is_subclass_of ( $ class , 'AbstractJSONWrapper' ) ) { $ class -> fromArray ( $ object ) ; return $ class ; } else { trigger_error ( __CLASS__ . ": Trying to deserialize " . get_class ( $ class ) ) ; return $ object ; } } else { return $ object ; } }
12150	public function checkReservedCodes ( ) { $ reserved = $ this -> getReservedCodes ( ) ; foreach ( $ reserved as $ factoryClass => $ reservedForFactory ) { foreach ( $ reserved as $ checkInFactory => $ reservedInCheckFactory ) { if ( $ checkInFactory == $ factoryClass ) { continue ; } if ( $ reservedInCheckFactory [ 0 ] >= $ reservedForFactory [ 0 ] && $ reservedInCheckFactory [ 0 ] <= $ reservedForFactory [ 1 ] ) { throw new \ RuntimeException ( sprintf ( 'The reserved codes for factory "%s" [%d - %d] superimposed on "%s" factory [%d - %d].' , $ checkInFactory , $ reservedInCheckFactory [ 0 ] , $ reservedInCheckFactory [ 1 ] , $ factoryClass , $ reservedForFactory [ 0 ] , $ reservedForFactory [ 1 ] ) ) ; } if ( $ reservedInCheckFactory [ 1 ] >= $ reservedForFactory [ 0 ] && $ reservedInCheckFactory [ 1 ] <= $ reservedForFactory [ 1 ] ) { throw new \ RuntimeException ( sprintf ( 'The reserved codes for factory "%s" [%d - %d] superimposed on "%s" factory [%d - %d].' , $ checkInFactory , $ reservedInCheckFactory [ 0 ] , $ reservedInCheckFactory [ 1 ] , $ factoryClass , $ reservedForFactory [ 0 ] , $ reservedForFactory [ 1 ] ) ) ; } } } }
12453	static function run_generate_sample_package_xml ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { pake_copy ( self :: getResourceDir ( ) . '/package_master.xml' , 'package.xml' ) ; $ tokens = array ( '$summary' => '[Summary]' , '$description' => '[Description]' , '$vendor' => '' , '$maintainers' => '' , '$documents' => '' , '$changelog' => '' , '$simple-files' => '' , '$state' => '[State]' , '$requires' => '' ) ; pake_replace_tokens ( 'package.xml' , '.' , '{' , '}' , $ tokens ) ; pake_echo ( "File package.xml generated. Please replace all tokens in square brackets in it (but do not replace values in curly brackets) then commit it to sources in the top dir of the extension" ) ; }
9746	public function setQuarter ( $ quarter ) { if ( ! $ quarter ) { return $ this ; } if ( ! ( $ quarter instanceof Quarter ) ) { $ quarter = new Quarter ( $ quarter ) ; } if ( $ quarter -> isEmpty ( ) ) { $ this -> invalidArguments ( '10005' ) ; } return $ this -> setParameter ( 'quarter' , $ quarter ) ; }
12767	public function set ( string $ key , $ value ) : self { $ this -> store [ $ key ] = $ value ; return self :: $ instance ; }
5034	public function hydrate ( $ value ) { if ( ! is_array ( $ value ) ) { return null ; } $ entity = $ this -> getTargetEntity ( ) ; foreach ( $ value as $ key => $ v ) { $ entity -> { "set$key" } ( $ v ) ; } return $ entity ; }
8404	public static function registerApp ( string $ namespace , string $ path = null ) { $ namespace = rtrim ( $ namespace , '\\' ) ; if ( $ path == null ) { $ path = constant ( 'STRAY_PATH_APPS' ) . str_replace ( '_' , DIRECTORY_SEPARATOR , str_replace ( '\\' , DIRECTORY_SEPARATOR , $ namespace ) ) ; } self :: $ namespaces [ $ namespace ] = $ path ; self :: $ applications [ ] = $ namespace ; }
5728	public function Field ( $ properties = array ( ) ) { Requirements :: css ( BETTER_BUTTONS_DIR . '/css/dropdown_form_action.css' ) ; Requirements :: javascript ( BETTER_BUTTONS_DIR . '/javascript/dropdown_form_action.js' ) ; $ this -> setAttribute ( 'data-form-action-dropdown' , '#' . $ this -> DropdownID ( ) ) ; return parent :: Field ( ) ; }
5281	public function selectFunc ( $ func , $ field , $ alias = null ) { $ field = "$func({$field})" ; if ( ! is_null ( $ alias ) ) { $ field .= " as {$alias}" ; } $ this -> statements [ 'select' ] [ ] = $ field ; return $ this ; }
11222	private static function checkRoutes ( ) { $ method = $ _SERVER [ 'REQUEST_METHOD' ] ; $ route_pos = array_keys ( self :: $ routes , self :: $ uri , true ) ; foreach ( $ route_pos as $ route ) { $ methodRoute = self :: $ methods [ $ route ] ; if ( $ methodRoute == $ method || $ methodRoute == 'ANY' ) { if ( ! is_object ( $ callback = self :: $ callbacks [ $ route ] ) ) { self :: $ response = self :: invokeObject ( $ callback ) ; } else { self :: $ response = call_user_func ( $ callback ) ; } if ( ! self :: $ halts ) { return self :: $ response ; } self :: $ halts -- ; } } return self :: $ response ; }
12459	public function indexAction ( ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ cfGroups = $ em -> getRepository ( 'ChillCustomFieldsBundle:CustomFieldsGroup' ) -> findAll ( ) ; $ defaultGroups = $ this -> getDefaultGroupsId ( ) ; $ makeDefaultFormViews = array ( ) ; foreach ( $ cfGroups as $ group ) { if ( ! in_array ( $ group -> getId ( ) , $ defaultGroups ) ) { $ makeDefaultFormViews [ $ group -> getId ( ) ] = $ this -> createMakeDefaultForm ( $ group ) -> createView ( ) ; } } return $ this -> render ( 'ChillCustomFieldsBundle:CustomFieldsGroup:index.html.twig' , array ( 'entities' => $ cfGroups , 'default_groups' => $ defaultGroups , 'make_default_forms' => $ makeDefaultFormViews ) ) ; }
12497	public static function deleteMany ( array $ ids = array ( ) , $ connection ) { if ( ! is_array ( $ ids ) ) { throw new ClusterpointException ( "\"->deleteMany()\" function: \"_id\" is not in valid format." , 9002 ) ; } $ connection -> method = 'DELETE' ; $ connection -> action = '' ; foreach ( $ ids as & $ id ) { $ id = ( string ) $ id ; } $ connection -> query = json_encode ( $ ids ) ; return self :: sendQuery ( $ connection ) ; }
10821	public static function title ( $ messages , $ linebreak = true , $ length = 0 ) { $ separator = $ linebreak ? "\n" : '' ; self :: write ( $ messages , 'title' , $ length , $ separator ) ; }
136	public function execute ( RepositoryInterface $ repo , OperationInterface $ operation ) { $ method = $ operation -> getJobType ( ) ; $ this -> $ method ( $ repo , $ operation ) ; }
7740	public function validate ( $ entity ) { if ( ! $ this -> container -> has ( 'validator' ) ) { throw new \ LogicException ( 'The validator service is not available.' ) ; } $ errors = $ this -> container -> get ( 'validator' ) -> validate ( $ entity ) ; if ( count ( $ errors ) === 0 ) { return false ; } return new JsonLdResponse ( '{ "error": "Validation error" }' , 400 ) ; }
555	private function notifyNotFoundCaches ( $ cachesNames ) { $ this -> stdout ( "The following cache components were NOT found:\n\n" , Console :: FG_RED ) ; foreach ( $ cachesNames as $ name ) { $ this -> stdout ( "\t* $name \n" , Console :: FG_GREEN ) ; } $ this -> stdout ( "\n" ) ; }
6153	public function setPropertyType ( $ propertyType ) { if ( $ propertyType instanceof PropertyType ) { $ this -> propertyType = $ propertyType ; } elseif ( is_array ( $ propertyType ) ) { $ this -> propertyType = new PropertyType ( $ propertyType ) ; } else { $ this -> propertyType = null ; trigger_error ( 'Argument must be an object of class PropertyType. Data loss!' , E_USER_WARNING ) ; } return $ this ; }
11313	public static function buildBasestring ( $ method , Url $ url , array $ data ) { $ base = array ( ) ; $ base [ ] = self :: urlEncode ( self :: getNormalizedMethod ( $ method ) ) ; $ base [ ] = self :: urlEncode ( self :: getNormalizedUrl ( $ url ) ) ; $ base [ ] = self :: urlEncode ( self :: getNormalizedParameters ( $ data ) ) ; return implode ( '&' , $ base ) ; }
7870	protected function drawBorderBottom ( $ isCore = false ) { $ this -> geometry -> decreaseNesting ( ) ; $ crossroads = $ isCore ? static :: CROSSROADS_DOWN : static :: CROSSROADS ; $ this -> drawBorder ( static :: BORDER_SW , $ crossroads , static :: BORDER_SE ) ; }
4301	public function groupSummary ( $ priority = 0 ) { array ( $ priority ) ; $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) , array ( 'priority' => 0 ) , array ( 'priority' ) ) ; $ this -> data [ 'groupPriorityStack' ] [ ] = $ meta [ 'priority' ] ; $ this -> setLogDest ( 'summary' ) ; $ this -> internal -> publishBubbleEvent ( 'debug.log' , $ this , array ( 'method' => __FUNCTION__ , 'args' => array ( ) , 'meta' => $ meta , ) ) ; }
12980	protected function configureBehavior ( $ behavior , EventSubscriber $ es ) { switch ( $ behavior ) { case 'translatable' : $ es -> setTranslatableLocale ( \ Config :: get ( 'language' , 'en' ) ) ; $ es -> setDefaultLocale ( \ Config :: get ( 'language_fallback' , 'en' ) ) ; break ; } }
1051	public static function getArgumentValues ( $ def , $ node , $ variableValues = null ) { if ( empty ( $ def -> args ) ) { return [ ] ; } $ argumentNodes = $ node -> arguments ; if ( empty ( $ argumentNodes ) ) { return [ ] ; } $ argumentValueMap = [ ] ; foreach ( $ argumentNodes as $ argumentNode ) { $ argumentValueMap [ $ argumentNode -> name -> value ] = $ argumentNode -> value ; } return static :: getArgumentValuesForMap ( $ def , $ argumentValueMap , $ variableValues , $ node ) ; }
2917	protected function ensureFileIsWritable ( $ filePath ) { if ( ( is_file ( $ filePath ) && ! is_writable ( $ filePath ) ) || ( ! is_file ( $ filePath ) && ! is_writable ( dirname ( $ filePath ) ) ) ) { throw new UnableWriteToFileException ( sprintf ( 'Unable to write to the file at %s.' , $ filePath ) ) ; } }
4988	public function setForms ( array $ forms , $ enabled = true ) { foreach ( $ forms as $ key => $ spec ) { if ( is_array ( $ spec ) && isset ( $ spec [ 'enabled' ] ) ) { $ currentEnabled = $ spec [ 'enabled' ] ; unset ( $ spec [ 'enabled' ] ) ; } else { $ currentEnabled = $ enabled ; } $ this -> setForm ( $ key , $ spec , $ currentEnabled ) ; } return $ this ; }
5351	public function setDatabasePassword ( $ domainName , $ database , $ password ) { return $ this -> call ( self :: SERVICE , 'setDatabasePassword' , [ $ domainName , $ database , $ password ] ) ; }
3007	public function setLayout ( $ layout ) { if ( $ layout === "" || $ layout === null ) { $ this -> layout = null ; } else { $ layoutPath = $ this -> templatePath . $ layout ; if ( ! is_file ( $ layoutPath ) ) { throw new \ RuntimeException ( "Layout template `$layout` does not exist" ) ; } $ this -> layout = $ layoutPath ; } }
6318	public function query ( $ sql ) { $ rows = array ( ) ; foreach ( $ this -> getConnection ( ) -> query ( $ sql ) as $ row ) { $ rows [ ] = $ row ; } return $ rows ; }
2677	public function deleteAclItem ( $ aclId , $ aclItemId ) { $ url = $ this -> _getApiServiceUri ( ) . 'acl/' . $ aclId . '/entry/' . $ aclItemId ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: DELETE ) ; return $ result ; }
7271	public function delete ( ) { $ tableName = static :: tableName ( ) ; $ columns = static :: tableColumns ( ) ; $ idColumn = static :: $ idColumn ; if ( isset ( $ this -> $ idColumn ) ) { $ status = Db :: query ( " delete from $tableName where $idColumn = :id " , [ "id" => $ this -> $ idColumn ] , static :: getDbName ( ) , false ) ; } else { $ condition = "" ; $ params = [ ] ; foreach ( $ columns as $ column ) { $ name = $ column [ "column_name" ] ; $ key = $ column [ "column_key" ] ; if ( isset ( $ this -> $ name ) ) { $ condition .= "$name = :$name and " ; $ params [ $ name ] = $ this -> encodeValue ( $ name ) ; } } $ condition = substr ( $ condition , 0 , - 5 ) ; var_dump ( " delete from $tableName where $condition " ) ; var_dump ( $ params ) ; $ status = Db :: query ( " delete from $tableName where $condition " , $ params , static :: getDbName ( ) , false ) ; } return $ status !== false && $ status > 0 ; }
6147	public function sendHeaders ( ) { if ( php_sapi_name ( ) !== "cli" && headers_sent ( $ file , $ line ) ) { throw new Exception ( "Try to send headers but headers already sent, output started at $file line $line." ) ; } http_response_code ( $ this -> statusCode ) ; foreach ( $ this -> headers as $ header ) { if ( php_sapi_name ( ) !== "cli" ) { header ( $ header ) ; } } return $ this ; }
7628	public function getContainerAcl ( $ containerName = '' , $ signedIdentifiers = false ) { Assertion :: notEmpty ( $ containerName , 'Container name is not specified' ) ; self :: assertValidContainerName ( $ containerName ) ; $ response = $ this -> performRequest ( $ containerName , array ( 'restype' => 'container' , 'comp' => 'acl' ) , 'GET' , array ( ) , false , null , self :: RESOURCE_CONTAINER , self :: PERMISSION_READ ) ; if ( ! $ response -> isSuccessful ( ) ) { throw new BlobException ( $ this -> getErrorMessage ( $ response , 'Resource could not be accessed.' ) ) ; } if ( $ signedIdentifiers == false ) { $ accessType = $ response -> getHeader ( Storage :: PREFIX_STORAGE_HEADER . 'blob-public-access' ) ; if ( strtolower ( $ accessType ) == 'true' ) { $ accessType = self :: ACL_PUBLIC_CONTAINER ; } return $ accessType ; } $ result = $ this -> parseResponse ( $ response ) ; if ( ! $ result ) { return array ( ) ; } $ entries = null ; if ( $ result -> SignedIdentifier ) { if ( count ( $ result -> SignedIdentifier ) > 1 ) { $ entries = $ result -> SignedIdentifier ; } else { $ entries = array ( $ result -> SignedIdentifier ) ; } } $ returnValue = array ( ) ; foreach ( $ entries as $ entry ) { $ returnValue [ ] = new SignedIdentifier ( $ entry -> Id , $ entry -> AccessPolicy ? $ entry -> AccessPolicy -> Start ? $ entry -> AccessPolicy -> Start : '' : '' , $ entry -> AccessPolicy ? $ entry -> AccessPolicy -> Expiry ? $ entry -> AccessPolicy -> Expiry : '' : '' , $ entry -> AccessPolicy ? $ entry -> AccessPolicy -> Permission ? $ entry -> AccessPolicy -> Permission : '' : '' ) ; } return $ returnValue ; }
11427	public function toObject ( ) { $ groups = $ this -> groups ; foreach ( $ groups as & $ group ) { $ group = $ group -> toObject ( ) ; } $ items = $ this -> items ; foreach ( $ items as & $ item ) { $ item = $ item -> toObject ( ) ; } return ( object ) [ 'type' => $ this -> type , 'value' => $ this -> value , 'text' => $ this -> text , 'groups' => $ groups , 'items' => $ items , ] ; }
643	public function addUnique ( $ name , $ table , $ columns ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> addUnique ( $ name , $ table , $ columns ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; }
2350	public function copyTo ( $ strNewName ) { $ strParent = \ dirname ( $ strNewName ) ; if ( ! is_dir ( $ this -> strRootDir . '/' . $ strParent ) ) { new Folder ( $ strParent ) ; } $ return = $ this -> Files -> copy ( $ this -> strFile , $ strNewName ) ; $ syncSource = Dbafs :: shouldBeSynchronized ( $ this -> strFile ) ; $ syncTarget = Dbafs :: shouldBeSynchronized ( $ strNewName ) ; if ( $ syncSource && $ syncTarget ) { Dbafs :: copyResource ( $ this -> strFile , $ strNewName ) ; } elseif ( $ syncTarget ) { Dbafs :: addResource ( $ strNewName ) ; } return $ return ; }
6090	public function addMediaToMoodboard ( $ moodboardId , array $ mediaIds ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'mediaIds' => $ mediaIds ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/moodboards/' . $ moodboardId . '/media' , $ parameters ) ; return $ result ; }
7759	protected function getMappingDriverBundleConfigDefaults ( array $ bundleConfig , \ ReflectionClass $ bundle , ContainerBuilder $ container ) { $ bundleDir = dirname ( $ bundle -> getFilename ( ) ) ; if ( ! $ bundleConfig [ 'type' ] ) { $ bundleConfig [ 'type' ] = $ this -> detectMetadataDriver ( $ bundleDir , $ container ) ; } if ( ! $ bundleConfig [ 'type' ] ) { return false ; } if ( ! $ bundleConfig [ 'dir' ] ) { if ( in_array ( $ bundleConfig [ 'type' ] , array ( 'annotation' , 'staticphp' ) ) ) { $ bundleConfig [ 'dir' ] = $ bundleDir . '/' . $ this -> getMappingObjectDefaultName ( ) ; } else { $ bundleConfig [ 'dir' ] = $ bundleDir . '/' . $ this -> getMappingResourceConfigDirectory ( ) ; } } else { $ bundleConfig [ 'dir' ] = $ bundleDir . '/' . $ bundleConfig [ 'dir' ] ; } if ( ! $ bundleConfig [ 'prefix' ] ) { $ bundleConfig [ 'prefix' ] = $ bundle -> getNamespaceName ( ) . '\\' . $ this -> getMappingObjectDefaultName ( ) ; } return $ bundleConfig ; }
5397	public function paintMessage ( $ message ) { parent :: paintMessage ( $ message ) ; print $ this -> getIndent ( 1 ) ; print '<' . $ this -> namespace . 'message>' ; print $ this -> toParsedXml ( $ message ) ; print '</' . $ this -> namespace . "message>\n" ; }
6086	public function listTemplates ( CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/moodboards/templates' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new MoodboardTemplateResponse ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
5147	protected function getOpenedEmail ( $ fetchNextUnread = FALSE ) { if ( $ fetchNextUnread || $ this -> openedEmail == NULL ) { $ this -> openNextUnreadEmail ( ) ; } return $ this -> openedEmail ; }
5387	public function setValue ( $ values ) { $ values = $ this -> makeArray ( $ values ) ; if ( ! $ this -> valuesArePossible ( $ values ) ) { return false ; } $ widgets = $ this -> getWidgets ( ) ; for ( $ i = 0 , $ count = count ( $ widgets ) ; $ i < $ count ; $ i ++ ) { $ possible = $ widgets [ $ i ] -> getAttribute ( 'value' ) ; if ( in_array ( $ widgets [ $ i ] -> getAttribute ( 'value' ) , $ values ) ) { $ widgets [ $ i ] -> setValue ( $ possible ) ; } else { $ widgets [ $ i ] -> setValue ( false ) ; } } return true ; }
11924	public function onPermalinkChanged ( PermalinkChangedEvent $ event ) { $ previousPermalink = $ event -> getOriginalText ( ) ; $ newPermalink = $ event -> getChangedText ( ) ; $ this -> updatePermalinkOnBlocks ( $ previousPermalink , $ newPermalink ) ; $ this -> updateHomepagePermalink ( $ previousPermalink , $ newPermalink ) ; }
8450	public function contactRename ( $ contact , $ firstName , $ lastName ) { $ contact = $ this -> escapePeer ( $ contact ) ; $ firstName = $ this -> escapeStringArgument ( $ firstName ) ; $ lastName = $ this -> escapeStringArgument ( $ lastName ) ; return $ this -> exec ( 'rename_contact ' . $ contact . ' ' . $ firstName . ' ' . $ lastName ) ; }
10602	public function addQuery ( $ name , $ value ) { $ part = $ name . '=' . $ value ; $ this -> _urlParts [ 'query' ] .= empty ( $ this -> _urlParts [ 'query' ] ) ? $ part : '&' . $ part ; return $ this ; }
5645	public function shouldInvoke ( $ test_case_name , $ method ) { $ numberOfReporters = count ( $ this -> reporters ) ; for ( $ i = 0 ; $ i < $ numberOfReporters ; $ i ++ ) { if ( ! $ this -> reporters [ $ i ] -> shouldInvoke ( $ test_case_name , $ method ) ) { return false ; } } return true ; }
4030	protected function getLabelPattern ( EnvironmentInterface $ environment , ModelInterface $ model ) { $ translator = $ environment -> getTranslator ( ) ; $ type = $ model -> getProperty ( 'type' ) ; $ combined = 'typedesc.' . $ type ; if ( ( $ resultPattern = $ translator -> translate ( $ combined , 'tl_metamodel_filtersetting' ) ) == $ combined ) { $ resultPattern = $ translator -> translate ( 'typedesc._default_' , 'tl_metamodel_filtersetting' ) ; } return $ resultPattern ; }
5036	public function indexAction ( ) { $ events = $ this -> adminControllerEvents ; $ event = $ events -> getEvent ( AdminControllerEvent :: EVENT_DASHBOARD , $ this ) ; $ events -> trigger ( $ event , $ this ) ; $ model = new ViewModel ( ) ; $ widgets = [ ] ; foreach ( $ event -> getViewModels ( ) as $ name => $ child ) { $ model -> addChild ( $ child , $ name ) ; $ widgets [ ] = $ name ; } $ model -> setVariable ( 'widgets' , $ widgets ) ; return $ model ; }
9164	protected function parseNode ( RuleCollection $ collection , \ DOMElement $ node , $ path , $ file ) { if ( self :: NAMESPACE_URI !== $ node -> namespaceURI ) { return ; } switch ( $ node -> localName ) { case 'rule' : $ this -> parseRule ( $ collection , $ node , $ path ) ; break ; case 'import' : $ this -> parseImport ( $ collection , $ node , $ path , $ file ) ; break ; default : throw new \ InvalidArgumentException ( sprintf ( 'Unknown tag "%s" used in file "%s". Expected "rule" or "import".' , $ node -> localName , $ path ) ) ; } }
2633	public function execute ( ) { $ output = $ this -> layoutFactory -> create ( ) -> createBlock ( 'Fastly\Cdn\Block\Dashboard\Tab\Stats\Historic' ) -> toHtml ( ) ; $ resultRaw = $ this -> resultRawFactory -> create ( ) ; return $ resultRaw -> setContents ( $ output ) ; }
11865	public function get ( string $ sessionIdentifier ) : string { if ( ! $ this -> sessionExists ( $ sessionIdentifier ) ) { throw new SessionNotFoundException ( ) ; } return self :: $ files [ $ sessionIdentifier ] [ 'data' ] ; }
875	private function convertToNowdoc ( Token $ token ) { return new Token ( [ $ token -> getId ( ) , Preg :: replace ( '/^([Bb]?<<<)([ \t]*)"?([^\s"]+)"?/' , '$1$2\'$3\'' , $ token -> getContent ( ) ) , ] ) ; }
5633	public function collect ( & $ test , $ path ) { $ path = $ this -> removeTrailingSlash ( $ path ) ; if ( $ handle = opendir ( $ path ) ) { while ( ( $ entry = readdir ( $ handle ) ) !== false ) { if ( $ this -> isHidden ( $ entry ) ) { continue ; } $ this -> handle ( $ test , $ path . DIRECTORY_SEPARATOR . $ entry ) ; } closedir ( $ handle ) ; } }
8782	protected function finish ( $ output = null ) { if ( ! is_null ( $ output ) ) { $ file = fopen ( $ this -> file , 'w+' ) ; fwrite ( $ file , $ output ) ; fclose ( $ file ) ; return $ output ; } return false ; }
1098	public function updateStructure ( ) { list ( $ a , $ b , $ c , $ d ) = $ this -> boundaries ( ) ; $ this -> applyLockBetween ( $ a , $ d ) ; $ connection = $ this -> node -> getConnection ( ) ; $ grammar = $ connection -> getQueryGrammar ( ) ; $ currentId = $ this -> quoteIdentifier ( $ this -> node -> getKey ( ) ) ; $ parentId = $ this -> quoteIdentifier ( $ this -> parentId ( ) ) ; $ leftColumn = $ this -> node -> getLeftColumnName ( ) ; $ rightColumn = $ this -> node -> getRightColumnName ( ) ; $ parentColumn = $ this -> node -> getParentColumnName ( ) ; $ wrappedLeft = $ grammar -> wrap ( $ leftColumn ) ; $ wrappedRight = $ grammar -> wrap ( $ rightColumn ) ; $ wrappedParent = $ grammar -> wrap ( $ parentColumn ) ; $ wrappedId = $ grammar -> wrap ( $ this -> node -> getKeyName ( ) ) ; $ lftSql = "CASE WHEN $wrappedLeft BETWEEN $a AND $b THEN $wrappedLeft + $d - $b WHEN $wrappedLeft BETWEEN $c AND $d THEN $wrappedLeft + $a - $c ELSE $wrappedLeft END" ; $ rgtSql = "CASE WHEN $wrappedRight BETWEEN $a AND $b THEN $wrappedRight + $d - $b WHEN $wrappedRight BETWEEN $c AND $d THEN $wrappedRight + $a - $c ELSE $wrappedRight END" ; $ parentSql = "CASE WHEN $wrappedId = $currentId THEN $parentId ELSE $wrappedParent END" ; $ updateConditions = array ( $ leftColumn => $ connection -> raw ( $ lftSql ) , $ rightColumn => $ connection -> raw ( $ rgtSql ) , $ parentColumn => $ connection -> raw ( $ parentSql ) ) ; if ( $ this -> node -> timestamps ) $ updateConditions [ $ this -> node -> getUpdatedAtColumn ( ) ] = $ this -> node -> freshTimestamp ( ) ; return $ this -> node -> newNestedSetQuery ( ) -> where ( function ( $ query ) use ( $ leftColumn , $ rightColumn , $ a , $ d ) { $ query -> whereBetween ( $ leftColumn , array ( $ a , $ d ) ) -> orWhereBetween ( $ rightColumn , array ( $ a , $ d ) ) ; } ) -> update ( $ updateConditions ) ; }
7337	public function createClient ( ) : TgLog { $ this -> loop = Factory :: create ( ) ; $ handler = new HttpClientRequestHandler ( $ this -> loop ) ; return new TgLog ( $ this -> token , $ handler ) ; }
5624	public function setCoordinates ( $ x = false , $ y = false ) { if ( ( $ x === false ) || ( $ y === false ) ) { $ this -> x = $ this -> y = false ; return ; } $ this -> x = ( integer ) $ x ; $ this -> y = ( integer ) $ y ; }
4717	public function emit ( $ event , $ parameters ) { if ( ! isset ( $ this -> callbacks [ $ event ] ) ) { return ; } if ( ! $ this -> callbacks [ $ event ] [ 0 ] ) { usort ( $ this -> callbacks [ $ event ] [ 1 ] , function ( $ A , $ B ) { if ( $ A [ 0 ] == $ B [ 0 ] ) { return 0 ; } return ( $ A [ 0 ] > $ B [ 0 ] ) ? 1 : - 1 ; } ) ; $ this -> callbacks [ $ event ] [ 0 ] = true ; } foreach ( $ this -> callbacks [ $ event ] [ 1 ] as $ item ) { call_user_func_array ( $ item [ 1 ] , $ this -> buildParameters ( $ parameters ) ) ; } }
11855	public function getUrlPath ( ) : ? string { $ uri = $ this -> getServerParam ( 'REQUEST_URI' , \ FILTER_SANITIZE_URL ) ; if ( ! is_null ( $ uri ) ) { return parse_url ( $ uri , \ PHP_URL_PATH ) ; } return null ; }
3727	private function sanitizeConnection ( $ connection ) { if ( $ connection instanceof Connection ) { return $ connection ; } if ( $ connection instanceof Database ) { @ trigger_error ( '"' . __METHOD__ . '" now accepts doctrine instances - ' . 'passing Contao database instances is deprecated.' , E_USER_DEPRECATED ) ; $ reflection = new \ ReflectionProperty ( Database :: class , 'resConnection' ) ; $ reflection -> setAccessible ( true ) ; return $ reflection -> getValue ( $ connection ) ; } if ( null === $ connection ) { @ trigger_error ( 'You should pass a doctrine database connection to "' . __METHOD__ . '".' , E_USER_DEPRECATED ) ; $ connection = System :: getContainer ( ) -> get ( 'database_connection' ) ; } if ( ! ( $ connection instanceof Connection ) ) { throw new \ RuntimeException ( 'Could not obtain doctrine connection.' ) ; } return $ connection ; }
4933	public function loadEntities ( $ entity , $ id = null ) { $ params = $ this -> options ; $ params [ 'id' ] = $ id ; $ params [ 'repositories' ] = $ this -> repositories ; $ event = $ this -> loadEntitiesEvents -> getEvent ( $ entity , $ this , $ params ) ; $ responses = $ this -> loadEntitiesEvents -> triggerEventUntil ( function ( $ response ) { return ( is_array ( $ response ) || $ response instanceof \ Traversable ) && count ( $ response ) ; } , $ event ) ; $ entities = $ responses -> last ( ) ; return $ entities ; }
5990	public function addPropertyCriteria ( $ item ) { if ( ! ( $ item instanceof PropertyCriteria ) ) { if ( is_array ( $ item ) ) { try { $ item = new PropertyCriteria ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate PropertyCriteria. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "PropertyCriteria"!' , E_USER_WARNING ) ; } } $ this -> properties [ ] = $ item ; return $ this ; }
10501	public function autoComplete ( $ data ) { static $ counter = 0 ; $ this -> inputOptions [ 'class' ] .= ' typeahead typeahead-' . ( ++ $ counter ) ; foreach ( $ data as & $ item ) { $ item = [ 'word' => $ item ] ; } $ this -> form -> getView ( ) -> registerJs ( "yii.gii.autocomplete($counter, " . Json :: htmlEncode ( $ data ) . ");" ) ; return $ this ; }
2520	public function queuePlacePnr ( RequestOptions \ QueuePlacePnrOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'Queue_PlacePNR' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; }
10009	public function createSheet ( $ sheetIndex = null ) { $ newSheet = new Worksheet ( $ this ) ; $ this -> addSheet ( $ newSheet , $ sheetIndex ) ; return $ newSheet ; }
5143	public static function create ( array $ data ) : \ One \ Model \ Photo { $ url = self :: validateUrl ( ( string ) self :: checkData ( $ data , 'url' , '' ) ) ; $ ratio = self :: validateString ( ( string ) self :: checkData ( $ data , 'ratio' , '' ) ) ; $ description = self :: validateString ( ( string ) self :: checkData ( $ data , 'description' , '' ) ) ; $ information = self :: validateString ( ( string ) self :: checkData ( $ data , 'information' , '' ) ) ; return self :: createPhoto ( $ url , $ ratio , $ description , $ information ) ; }
8113	public function getReviewDate ( SiteTree $ page = null ) { if ( $ page === null ) { $ page = $ this -> owner ; } if ( $ page -> obj ( 'NextReviewDate' ) -> exists ( ) ) { return $ page -> obj ( 'NextReviewDate' ) ; } $ options = $ this -> owner -> getOptions ( ) ; if ( ! $ options ) { return false ; } if ( ! $ options -> ReviewPeriodDays ) { return false ; } $ nextReviewUnixSec = strtotime ( ' + ' . $ options -> ReviewPeriodDays . ' days' , DBDatetime :: now ( ) -> getTimestamp ( ) ) ; $ date = DBDate :: create ( 'NextReviewDate' ) ; $ date -> setValue ( $ nextReviewUnixSec ) ; return $ date ; }
5586	public function restart ( $ date = false ) { $ this -> cookie_jar -> restartSession ( $ date ) ; $ this -> authenticator -> restartSession ( ) ; $ this -> http_referer = null ; }
3452	public function getAggregateRoot ( string $ aggregateId ) { if ( ! $ this -> disableIdentityMap && isset ( $ this -> identityMap [ $ aggregateId ] ) ) { return $ this -> identityMap [ $ aggregateId ] ; } if ( $ this -> snapshotStore ) { $ eventSourcedAggregateRoot = $ this -> loadFromSnapshotStore ( $ aggregateId ) ; if ( $ eventSourcedAggregateRoot && ! $ this -> disableIdentityMap ) { $ this -> identityMap [ $ aggregateId ] = $ eventSourcedAggregateRoot ; } return $ eventSourcedAggregateRoot ; } $ streamName = $ this -> determineStreamName ( $ aggregateId ) ; if ( $ this -> oneStreamPerAggregate ) { try { $ streamEvents = $ this -> eventStore -> load ( $ streamName , 1 ) ; } catch ( StreamNotFound $ e ) { return null ; } } else { $ metadataMatcher = new MetadataMatcher ( ) ; $ metadataMatcher = $ metadataMatcher -> withMetadataMatch ( '_aggregate_type' , Operator :: EQUALS ( ) , $ this -> aggregateType -> toString ( ) ) ; $ metadataMatcher = $ metadataMatcher -> withMetadataMatch ( '_aggregate_id' , Operator :: EQUALS ( ) , $ aggregateId ) ; try { $ streamEvents = $ this -> eventStore -> load ( $ streamName , 1 , null , $ metadataMatcher ) ; } catch ( StreamNotFound $ e ) { return null ; } } if ( ! $ streamEvents -> valid ( ) ) { return null ; } $ eventSourcedAggregateRoot = $ this -> aggregateTranslator -> reconstituteAggregateFromHistory ( $ this -> aggregateType , $ streamEvents ) ; if ( ! $ this -> disableIdentityMap ) { $ this -> identityMap [ $ aggregateId ] = $ eventSourcedAggregateRoot ; } return $ eventSourcedAggregateRoot ; }
6947	private function getOutstandingExpiredDueQueryBuilder ( ) { $ qb = $ this -> createQueryBuilder ( 'o' ) ; $ ex = $ qb -> expr ( ) ; $ qb -> join ( 'o.paymentTerm' , 't' ) -> where ( $ ex -> andX ( $ ex -> eq ( 'o.sample' , ':not_sample' ) , $ ex -> lt ( 'o.paidTotal' , 'o.grandTotal' ) , $ ex -> notIn ( 'o.invoiceState' , ':canceled_or_refunded' ) , $ qb -> expr ( ) -> lte ( 'o.outstandingDate' , ':today' ) , $ this -> getDueClauses ( ) ) ) -> addOrderBy ( 'o.outstandingDate' , 'ASC' ) -> setParameter ( 'not_sample' , false ) -> setParameter ( 'today' , ( new \ DateTime ( ) ) -> setTime ( 23 , 59 , 59 ) , Type :: DATETIME ) -> setParameter ( 'canceled_or_refunded' , [ InvoiceStates :: STATE_CANCELED , InvoiceStates :: STATE_CREDITED ] ) ; $ this -> setDueParameters ( $ qb ) ; return $ qb ; }
104	public function isRateLimited ( array $ headers ) { foreach ( $ headers as $ header ) { if ( preg_match ( '{^X-RateLimit-Remaining: *0$}i' , trim ( $ header ) ) ) { return true ; } } return false ; }
2882	protected function _initEmail ( ) { $ token = $ this -> getRequest ( ) -> getParam ( 'token' ) ; $ index = $ this -> getRequest ( ) -> getParam ( 'index' ) ; if ( $ token === null || $ index === null ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 400 ) -> setBody ( 'Invalid parameters' ) ; return null ; } $ requestProfile = Mage :: getModel ( 'sheep_debug/requestInfo' ) -> load ( $ token , 'token' ) ; if ( ! $ requestProfile -> getId ( ) ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 404 ) -> setBody ( 'Request profile not found' ) ; return null ; } $ emails = $ requestProfile -> getEmails ( ) ; if ( ! $ emails || ! ( $ index < count ( $ emails ) ) ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 404 ) -> setBody ( 'E-mail not found' ) ; return null ; } return $ emails [ ( int ) $ index ] ; }
3201	public function getItems ( \ core_kernel_classes_Class $ itemClass , array $ propertyFilters = [ ] , $ offset = 0 , $ limit = 30 ) { $ result = $ this -> getListResourceLookupService ( ) -> getResources ( $ itemClass , [ ] , $ propertyFilters , $ offset , $ limit ) ; array_map ( function ( $ item ) { return array_merge ( $ item , [ 'categories' => $ this -> getCategoryService ( ) -> getItemCategories ( $ this -> getResource ( $ item [ 'uri' ] ) ) ] ) ; } , $ result [ 'nodes' ] ) ; return $ result ; }
9069	public function purge ( $ days_older_than = 60 , \ wpdb $ wpdb ) { $ days_older_than = absint ( $ days_older_than ) ; $ tn = $ this -> table -> get_table_name ( $ wpdb ) ; $ sql = "DELETE FROM {$tn} WHERE time < DATE_SUB(NOW(), INTERVAL $days_older_than DAY)" ; $ wpdb -> query ( $ sql ) ; }
6317	public function execute ( $ sql ) { $ this -> dispatcher -> dispatch ( 'rentgen.sql_executed' , new SqlEvent ( $ sql ) ) ; return $ this -> getConnection ( ) -> exec ( $ sql ) ; }
3237	public function getTotalAttribute ( ) { if ( empty ( $ this -> shopCalculations ) ) $ this -> runCalculations ( ) ; return $ this -> totalPrice + $ this -> totalTax + $ this -> totalShipping ; }
519	private function findMigrationPath ( $ namespace ) { if ( empty ( $ namespace ) ) { return is_array ( $ this -> migrationPath ) ? reset ( $ this -> migrationPath ) : $ this -> migrationPath ; } if ( ! in_array ( $ namespace , $ this -> migrationNamespaces , true ) ) { throw new Exception ( "Namespace '{$namespace}' not found in `migrationNamespaces`" ) ; } return $ this -> getNamespacePath ( $ namespace ) ; }
10957	public function iLikeToMoveItMoveItBack ( ) { $ moveCommand = $ this -> popCommandFromList ( ) ; $ moveCommand -> reverseFromToDirs ( ) ; $ this -> direction = self :: DIRECTION_BACK ; $ this -> init ( $ moveCommand ) ; $ this -> processFiles ( ) ; }
3915	protected function sortByDate ( $ blnAscending = true ) { $ arrFiles = $ this -> foundFiles ; $ arrDates = $ this -> modifiedTime ; if ( ! $ arrFiles ) { return array ( 'files' => array ( ) , 'source' => array ( ) ) ; } if ( $ blnAscending ) { array_multisort ( $ arrFiles , SORT_NUMERIC , $ arrDates , SORT_ASC ) ; } else { array_multisort ( $ arrFiles , SORT_NUMERIC , $ arrDates , SORT_DESC ) ; } return $ this -> remapSorting ( $ arrFiles , $ this -> outputBuffer ) ; }
8049	public function createCalendarEvent ( array $ data ) { $ eventData = $ this -> calendarEventsEngine -> buildEventData ( $ data ) ; $ eventDates = $ this -> calendarEventsEngine -> buildEventDates ( $ data ) ; $ cache = $ this -> cache ; $ calendarEvent = $ this -> calendarEvent -> create ( $ eventData ) ; $ this -> handleEventLocation ( $ data , $ calendarEvent ) ; foreach ( $ eventDates as $ date ) { $ calendarEventRepeatDate = clone $ this -> calendarEventRepeatDate ; $ calendarEventRepeatDate -> start = $ date [ 'start' ] ; $ calendarEventRepeatDate -> end = $ date [ 'end' ] ; $ calendarEventRepeatDate -> calendarEvent ( ) -> associate ( $ calendarEvent ) ; $ calendarEventRepeatDate -> save ( ) ; unset ( $ calendarEventRepeatDate ) ; } $ cache :: put ( self :: CACHE_KEY . $ calendarEvent -> id , $ calendarEvent , $ this -> cacheTimeToLive ) ; $ allEvents = $ this -> getAllEvents ( ) ; $ allEvents [ $ calendarEvent -> id ] = $ calendarEvent ; $ cache :: put ( self :: ALL_EVENTS_KEY , $ allEvents , $ this -> cacheTimeToLive ) ; return true ; }
5820	protected function transformFiles ( $ files ) { $ result = [ ] ; foreach ( $ files as $ file ) { $ result [ ] = [ 'type' => $ file [ 'content_type' ] === 'application/directory' ? 'dir' : 'file' , 'path' => $ file [ 'name' ] , 'size' => intval ( $ file [ 'bytes' ] ) , 'timestamp' => strtotime ( $ file [ 'last_modified' ] ) , 'mimetype' => $ file [ 'content_type' ] , ] ; } return $ result ; }
4527	public function prePersist ( LifecycleEventArgs $ args ) { $ entity = $ args -> getEntity ( ) ; if ( ! $ entity instanceof Identitiable ) { return ; } $ this -> identityService -> generateIdentity ( $ entity ) ; }
10750	protected function sendVerb ( string $ verb , Response $ response , string $ type , array $ ids , array $ extra = [ ] ) : Response { $ send = array_merge ( [ ] , $ extra ) ; $ send [ 'success' ] = true ; $ send [ 'message' ] = "Objects $verb successfully" ; $ send [ 'objects' ] = array_map ( function ( $ id ) use ( $ type ) { return [ 'type' => $ type , 'id' => $ id ] ; } , $ ids ) ; return $ this -> sendJson ( $ response , $ send ) ; }
4328	public static function parseAttribString ( $ str , $ dataDecode = true ) { $ attribs = array ( ) ; $ regexAttribs = '/\b([\w\-]+)\b(?: \s*=\s*(["\'])(.*?)\\2 | \s*=\s*(\S+) )?/xs' ; \ preg_match_all ( $ regexAttribs , $ str , $ matches ) ; $ keys = \ array_map ( 'strtolower' , $ matches [ 1 ] ) ; $ values = \ array_replace ( $ matches [ 3 ] , \ array_filter ( $ matches [ 4 ] , 'strlen' ) ) ; foreach ( $ keys as $ i => $ k ) { $ attribs [ $ k ] = $ values [ $ i ] ; if ( \ in_array ( $ k , self :: $ htmlBoolAttr ) ) { $ attribs [ $ k ] = true ; } } \ ksort ( $ attribs ) ; foreach ( $ attribs as $ k => $ v ) { if ( \ is_string ( $ v ) ) { $ attribs [ $ k ] = \ htmlspecialchars_decode ( $ v ) ; } $ isDataAttrib = \ strpos ( $ k , 'data-' ) === 0 ; if ( $ isDataAttrib && $ dataDecode ) { $ val = $ attribs [ $ k ] ; $ attribs [ $ k ] = \ json_decode ( $ attribs [ $ k ] , true ) ; if ( $ attribs [ $ k ] === null && $ val !== 'null' ) { $ attribs [ $ k ] = \ json_decode ( '"' . $ val . '"' , true ) ; } } } return $ attribs ; }
12818	public function transformCommandToMessage ( $ command ) { if ( ! is_object ( $ command ) ) { throw CommandTransformationException :: expectedObject ( $ command ) ; } if ( ! isset ( $ this -> commands [ get_class ( $ command ) ] ) ) { throw CommandTransformationException :: unknownCommand ( $ command , array_keys ( $ this -> commands ) ) ; } if ( $ this -> serializer instanceof EncoderInterface && ! $ this -> serializer -> supportsEncoding ( $ this -> format ) ) { throw CommandTransformationException :: unsupportedFormat ( $ command , $ this -> format ) ; } $ info = $ this -> commands [ get_class ( $ command ) ] ; return new CommandMessage ( $ info -> getVhost ( ) , $ info -> getExchange ( ) , $ this -> serializer -> serialize ( $ command , $ this -> format ) , $ info -> getRoutingKey ( ) , $ info -> getFlags ( ) , $ this -> resolveMessageAttributes ( $ command , $ info ) ) ; }
9793	public function hasDataValidation ( ) { if ( ! isset ( $ this -> parent ) ) { throw new Exception ( 'Cannot check for data validation when cell is not bound to a worksheet' ) ; } return $ this -> getWorksheet ( ) -> dataValidationExists ( $ this -> getCoordinate ( ) ) ; }
473	public function batchInsert ( $ table , $ columns , $ rows ) { $ time = $ this -> beginCommand ( "insert into $table" ) ; $ this -> db -> createCommand ( ) -> batchInsert ( $ table , $ columns , $ rows ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
10105	private function writeDefaultRowHeight ( ) { $ defaultRowHeight = $ this -> phpSheet -> getDefaultRowDimension ( ) -> getRowHeight ( ) ; if ( $ defaultRowHeight < 0 ) { return ; } $ defaultRowHeight = ( int ) 20 * $ defaultRowHeight ; $ record = 0x0225 ; $ length = 0x0004 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vv' , 1 , $ defaultRowHeight ) ; $ this -> append ( $ header . $ data ) ; }
2504	protected static function getMessagesAndVersionsFromImportedWsdl ( $ import , $ wsdlPath , $ wsdlIdentifier ) { $ msgAndVer = [ ] ; $ domXpath = null ; $ importPath = realpath ( dirname ( $ wsdlPath ) ) . DIRECTORY_SEPARATOR . $ import ; $ wsdlContent = file_get_contents ( $ importPath ) ; if ( $ wsdlContent !== false ) { $ domDoc = new \ DOMDocument ( '1.0' , 'UTF-8' ) ; $ ok = $ domDoc -> loadXML ( $ wsdlContent ) ; if ( $ ok === true ) { $ domXpath = new \ DOMXPath ( $ domDoc ) ; $ domXpath -> registerNamespace ( 'wsdl' , 'http://schemas.xmlsoap.org/wsdl/' ) ; $ domXpath -> registerNamespace ( 'soap' , 'http://schemas.xmlsoap.org/wsdl/soap/' ) ; } } else { throw new InvalidWsdlFileException ( 'WSDL ' . $ importPath . ' import could not be loaded' ) ; } if ( $ domXpath instanceof \ DOMXPath ) { $ nodeList = $ domXpath -> query ( self :: XPATH_ALL_OPERATIONS ) ; $ msgAndVer = array_merge ( $ msgAndVer , self :: loopOperationsWithQuery ( $ nodeList , self :: XPATH_ALT_VERSION_FOR_OPERATION , $ wsdlIdentifier , $ domXpath ) ) ; } return $ msgAndVer ; }
5299	public function getGlyphs ( ) { if ( ! isset ( $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] -> glyph ) || ! count ( $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] -> glyph ) ) { return array ( ) ; } $ glyphs = array ( ) ; foreach ( $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] -> glyph as $ xmlGlyph ) { if ( isset ( $ xmlGlyph [ 'unicode' ] ) && isset ( $ xmlGlyph [ 'd' ] ) ) { $ glyph = array ( 'char' => ( string ) $ xmlGlyph [ 'unicode' ] , 'path' => ( string ) $ xmlGlyph [ 'd' ] , ) ; if ( isset ( $ xmlGlyph [ 'glyph-name' ] ) ) { $ glyph [ 'name' ] = ( string ) $ xmlGlyph [ 'glyph-name' ] ; } if ( isset ( $ xmlGlyph [ 'horiz-adv-x' ] ) ) { $ glyph [ 'width' ] = ( string ) $ xmlGlyph [ 'horiz-adv-x' ] ; } $ glyphs [ ] = $ glyph ; } } return $ glyphs ; }
5656	private function walkChildren ( $ node ) { if ( $ node -> hasChildren ( ) ) { foreach ( $ node -> child as $ child ) { $ this -> walkTree ( $ child ) ; } } }
2073	public function getAllTables ( ) { $ arrTables = $ this -> Database -> listTables ( ) ; $ arrViews = Contao \ System :: getContainer ( ) -> get ( 'database_connection' ) -> getSchemaManager ( ) -> listViews ( ) ; if ( ! empty ( $ arrViews ) ) { $ arrTables = array_merge ( $ arrTables , array_keys ( $ arrViews ) ) ; natsort ( $ arrTables ) ; } return array_values ( $ arrTables ) ; }
5246	public function get ( string $ path ) : string { if ( ! $ this -> isFile ( $ path ) ) { throw new RuntimeException ( 'File does not exist at path ' . $ path ) ; } return file_get_contents ( $ path ) ; }
2557	protected function loadMopDetails ( MopInfo $ options ) { $ this -> mopDetails = new MopDetails ( ) ; if ( $ this -> checkAnyNotEmpty ( $ options -> fopCode , $ options -> fopStatus ) ) { $ this -> mopDetails -> fopPNRDetails = new FopPNRDetails ( $ options -> fopCode , $ options -> fopStatus ) ; } if ( ! empty ( $ options -> freeFlowText ) ) { $ this -> mopDetails -> oldFopFreeflow = new OldFopFreeflow ( $ options -> freeFlowText , $ options -> freeFlowEncoding ) ; } if ( ! empty ( $ options -> supplementaryData ) ) { $ this -> mopDetails -> pnrSupplementaryData [ ] = new PnrSupplementaryData ( DataAndSwitchMap :: TYPE_DATA_INFORMATION , $ options -> supplementaryData ) ; } if ( ! empty ( $ options -> supplementarySwitches ) ) { $ this -> mopDetails -> pnrSupplementaryData [ ] = new PnrSupplementaryData ( DataAndSwitchMap :: TYPE_SWITCH_INFORMATION , $ options -> supplementarySwitches ) ; } }
1966	public static function findByPk ( $ varValue , array $ arrOptions = array ( ) ) { if ( static :: $ strPk == 'id' ) { return static :: findById ( $ varValue , $ arrOptions ) ; } return parent :: findByPk ( $ varValue , $ arrOptions ) ; }
11407	public function actionTriggerEvents ( ) { Yii :: $ app -> response -> format = Response :: FORMAT_JSON ; $ result = ( $ post = Yii :: $ app -> request -> post ( 'depdrop_parents' ) ) ? Item :: eventList ( $ post [ 0 ] ) : [ ] ; $ output = [ ] ; foreach ( $ result as $ id => $ name ) { $ output [ ] = compact ( 'id' , 'name' ) ; } echo Json :: encode ( [ 'output' => $ output , 'selected' => '' ] ) ; }
7939	public function deleteBackupFTPaccessBlock ( $ domain , $ ipBlock ) { $ domain = ( string ) $ domain ; if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; if ( ! $ ipBlock ) throw new BadMethodCallException ( 'Parameter $ipBlock is missing.' ) ; try { $ r = $ this -> delete ( 'dedicated/server/' . $ domain . '/features/backupFTP/access/' . urlencode ( $ ipBlock ) ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new ServerException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
2638	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ aclId = $ this -> getRequest ( ) -> getParam ( 'acl_id' ) ; $ aclItems = $ this -> api -> aclItemsList ( $ aclId ) ; if ( is_array ( $ aclItems ) && empty ( $ aclItems ) ) { return $ result -> setData ( [ 'status' => 'empty' , 'aclItems' => [ ] ] ) ; } if ( ! $ aclItems ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to fetch acl items.' ] ) ; } return $ result -> setData ( [ 'status' => true , 'aclItems' => $ aclItems ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
7624	protected function performRequest ( $ path = '/' , $ query = array ( ) , $ httpVerb = 'GET' , $ headers = array ( ) , $ forTableStorage = false , $ rawData = null , $ resourceType = self :: RESOURCE_UNKNOWN , $ requiredPermission = self :: PERMISSION_READ ) { if ( strpos ( $ path , '/' ) !== 0 ) { $ path = '/' . $ path ; } if ( ! isset ( $ headers [ 'Content-Type' ] ) ) { $ headers [ 'Content-Type' ] = '' ; } if ( ! isset ( $ headers [ 'content-length' ] ) && ( $ rawData !== null || $ httpVerb == "PUT" ) ) { $ headers [ 'Content-Length' ] = strlen ( ( string ) $ rawData ) ; } $ headers [ 'Expect' ] = '' ; $ headers [ 'x-ms-version' ] = $ this -> apiVersion ; $ path = str_replace ( ' ' , '%20' , $ path ) ; $ requestUrl = $ this -> getBaseUrl ( ) . $ path ; if ( count ( $ query ) > 0 ) { $ queryString = '' ; foreach ( $ query as $ key => $ value ) { $ queryString .= ( $ queryString ? '&' : '?' ) . rawurlencode ( $ key ) . '=' . rawurlencode ( $ value ) ; } $ requestUrl .= $ queryString ; } $ requestUrl = $ this -> credentials -> signRequestUrl ( $ requestUrl , $ resourceType , $ requiredPermission ) ; $ headers = $ this -> credentials -> signRequestHeaders ( $ httpVerb , $ path , $ query , $ headers , $ forTableStorage , $ resourceType , $ requiredPermission , $ rawData ) ; return $ this -> httpClient -> request ( $ httpVerb , $ requestUrl , $ rawData , $ headers ) ; }
3756	public function createVariant ( ConfigInterface $ objConfig ) { $ objItem = $ this -> getMetaModel ( ) -> findById ( $ objConfig -> getId ( ) ) -> varCopy ( ) ; if ( ! $ objItem ) { return null ; } $ model = new Model ( $ objItem ) ; $ model -> setMeta ( $ model :: IS_CHANGED , true ) ; return $ model ; }
210	protected function getValidXmlElementName ( $ name ) { if ( empty ( $ name ) || is_int ( $ name ) || ! $ this -> isValidXmlName ( $ name ) ) { return $ this -> itemTag ; } return $ name ; }
12856	function performPayload ( iPayloadQueued $ processPayload ) { $ triesCount = 0 ; if ( $ processPayload instanceof FailedPayload ) { if ( $ processPayload -> getCountRetries ( ) > $ this -> getMaxTries ( ) ) throw new exPayloadMaxTriesExceed ( $ processPayload , sprintf ( 'Max Tries Exceeds After %s Tries.' , $ processPayload -> getCountRetries ( ) ) , null ) ; } $ payLoadData = $ processPayload -> getData ( ) ; try { if ( ob_get_level ( ) ) ob_end_clean ( ) ; ob_start ( ) ; $ this -> event ( ) -> trigger ( EventHeapOfWorker :: EVENT_PAYLOAD_RECEIVED , [ 'payload' => $ processPayload , 'data' => $ payLoadData , 'worker' => $ this ] ) ; ob_end_flush ( ) ; flush ( ) ; } catch ( \ LogicException $ e ) { throw $ e ; } catch ( \ Exception $ e ) { if ( ! $ processPayload instanceof FailedPayload ) $ failedPayload = new FailedPayload ( $ processPayload , $ triesCount ) ; else $ failedPayload = $ processPayload ; throw new exPayloadPerformFailed ( $ failedPayload , $ e ) ; } }
1150	public function render ( $ view = null , $ selector = null ) { $ this -> view ( $ view ) ; $ this -> selector ( $ selector ) ; return View :: make ( $ this -> view , [ 'validator' => $ this -> getViewData ( ) ] ) -> render ( ) ; }
391	protected static function filterValidAliases ( Query $ query ) { $ tables = $ query -> getTablesUsedInFrom ( ) ; $ aliases = array_diff ( array_keys ( $ tables ) , $ tables ) ; return array_map ( function ( $ alias ) { return preg_replace ( '/{{([\w]+)}}/' , '$1' , $ alias ) ; } , array_values ( $ aliases ) ) ; }
7848	private function checkConfig ( ) : void { if ( empty ( $ this -> device ) ) { Log :: warning ( 'Config "message.smsgatewayme.device" is not defined.' ) ; } if ( empty ( $ this -> token ) ) { Log :: warning ( 'Config "message.smsgatewayme.token" is not defined.' ) ; } }
5998	public function setMax ( $ max ) { if ( $ max instanceof DateTime ) { $ this -> max = $ max ; } else { try { $ this -> max = new DateTime ( $ max ) ; } catch ( \ Exception $ e ) { $ this -> max = null ; } } return $ this ; }
1770	public function getErrorsAsString ( $ strSeparator = null ) { if ( $ strSeparator === null ) { $ strSeparator = '<br' . $ this -> strTagEnding . "\n" ; } return $ this -> hasErrors ( ) ? implode ( $ strSeparator , $ this -> arrErrors ) : '' ; }
1064	private function collectConflictsWithin ( ValidationContext $ context , array & $ conflicts , array $ fieldMap ) { foreach ( $ fieldMap as $ responseName => $ fields ) { $ fieldsLength = count ( $ fields ) ; if ( $ fieldsLength <= 1 ) { continue ; } for ( $ i = 0 ; $ i < $ fieldsLength ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ fieldsLength ; $ j ++ ) { $ conflict = $ this -> findConflict ( $ context , false , $ responseName , $ fields [ $ i ] , $ fields [ $ j ] ) ; if ( ! $ conflict ) { continue ; } $ conflicts [ ] = $ conflict ; } } } }
12397	public function orWhere ( $ field , $ operator = null , $ value = null ) { return $ this -> where ( $ field , $ operator , $ value , '||' ) ; }
9004	protected function months_dropdown ( $ post_type ) { global $ wpdb , $ wp_locale ; $ tn = $ this -> table -> get_table_name ( $ wpdb ) ; $ months = $ wpdb -> get_results ( " SELECT DISTINCT YEAR( time ) AS year, MONTH( time ) AS month FROM $tn ORDER BY time DESC " ) ; $ month_count = count ( $ months ) ; if ( ! $ month_count || ( 1 == $ month_count && 0 == $ months [ 0 ] -> month ) ) { return ; } $ m = isset ( $ _GET [ 'm' ] ) ? ( int ) $ _GET [ 'm' ] : 0 ; ?> <label for="filter-by-date" class="screen-reader-text"> <?php _e ( 'Filter by date' ) ; ?> </label> <select name="m" id="filter-by-date"> <option <?php selected ( $ m , 0 ) ; ?> value="0"> <?php _e ( 'All dates' ) ; ?> </option> <?php foreach ( $ months as $ arc_row ) { if ( 0 == $ arc_row -> year ) { continue ; } $ month = zeroise ( $ arc_row -> month , 2 ) ; $ year = $ arc_row -> year ; printf ( "<option %s value='%s'>%s</option>\n" , selected ( $ m , $ year . $ month , false ) , esc_attr ( $ arc_row -> year . $ month ) , sprintf ( __ ( '%1$s %2$d' ) , $ wp_locale -> get_month ( $ month ) , $ year ) ) ; } ?> </select> <?php }
3193	public function load ( ) { if ( ! $ this -> storage ) { throw new InvalidStorageException ( 'A storage must be defined in order to store the data!' ) ; } $ data = $ this -> storage -> load ( ) ; if ( isset ( $ data ) ) { if ( ! is_array ( $ data ) ) { $ data = [ self :: STORAGE_KEY_TIME_LINE => $ data , ] ; } if ( isset ( $ data [ self :: STORAGE_KEY_TIME_LINE ] ) ) { $ this -> timeLine = $ this -> unserializeTimeLine ( $ data [ self :: STORAGE_KEY_TIME_LINE ] ) ; } else { $ this -> timeLine = new QtiTimeLine ( ) ; } if ( isset ( $ data [ self :: STORAGE_KEY_EXTRA_TIME ] ) ) { $ this -> extraTime = $ data [ self :: STORAGE_KEY_EXTRA_TIME ] ; } else { $ this -> extraTime = 0 ; } if ( isset ( $ data [ self :: STORAGE_KEY_EXTENDED_TIME ] ) ) { $ this -> extendedTime = $ data [ self :: STORAGE_KEY_EXTENDED_TIME ] ; } else { $ this -> extendedTime = 0 ; } if ( isset ( $ data [ self :: STORAGE_KEY_CONSUMED_EXTRA_TIME ] ) ) { $ this -> consumedExtraTime = $ data [ self :: STORAGE_KEY_CONSUMED_EXTRA_TIME ] ; } else { $ this -> consumedExtraTime = 0 ; } if ( ! $ this -> timeLine instanceof TimeLine ) { throw new InvalidDataException ( 'The storage did not provide acceptable data when loading!' ) ; } } return $ this ; }
619	public static function validateData ( array $ data , $ rules = [ ] ) { $ model = new static ( $ data ) ; if ( ! empty ( $ rules ) ) { $ validators = $ model -> getValidators ( ) ; foreach ( $ rules as $ rule ) { if ( $ rule instanceof Validator ) { $ validators -> append ( $ rule ) ; } elseif ( is_array ( $ rule ) && isset ( $ rule [ 0 ] , $ rule [ 1 ] ) ) { $ validator = Validator :: createValidator ( $ rule [ 1 ] , $ model , ( array ) $ rule [ 0 ] , array_slice ( $ rule , 2 ) ) ; $ validators -> append ( $ validator ) ; } else { throw new InvalidConfigException ( 'Invalid validation rule: a rule must specify both attribute names and validator type.' ) ; } } } $ model -> validate ( ) ; return $ model ; }
2878	public function enableFPCDebugAction ( ) { try { $ this -> getService ( ) -> setFPCDebug ( 1 ) ; $ this -> getService ( ) -> flushCache ( ) ; $ message = $ this -> __ ( 'FPC debug was enabled' ) ; $ this -> getSession ( ) -> addSuccess ( $ message ) ; } catch ( Exception $ e ) { $ message = $ this -> __ ( 'FPC debug cannot be enabled: %s' , $ e -> getMessage ( ) ) ; $ this -> getSession ( ) -> addError ( $ message ) ; } $ this -> _redirectReferer ( ) ; }
3531	public static function sendFortniteGetRequest ( $ endpoint , $ access_token , $ extra_headers = array ( ) ) { $ client = new Client ( ) ; $ headers = [ 'User-Agent' => self :: FORTNITE_USER_AGENT , 'Authorization' => 'bearer ' . $ access_token ] ; $ headers = array_merge ( $ headers , $ extra_headers ) ; try { $ response = $ client -> get ( $ endpoint , [ 'headers' => $ headers ] ) ; return json_decode ( $ response -> getBody ( ) -> getContents ( ) ) ; } catch ( GuzzleException $ e ) { throw $ e ; } }
11980	protected function query ( $ api , $ from , $ to ) { $ params = [ 'begin_date' => $ from , 'end_date' => $ to , ] ; return $ this -> parseJSON ( 'json' , [ $ api , $ params ] ) ; }
5743	protected function parseContentType ( $ contentType ) { if ( false === stripos ( $ contentType , ';' ) ) { throw new ParserException ( 'ContentType does not contain a \';\'' ) ; } list ( $ mime , $ boundary ) = explode ( ';' , $ contentType , 2 ) ; list ( $ key , $ boundaryValue ) = explode ( '=' , trim ( $ boundary ) , 2 ) ; if ( 'boundary' != $ key ) { throw new ParserException ( 'Boundary does not start with \'boundary=\'' ) ; } return [ strtolower ( trim ( $ mime ) ) , $ boundaryValue ] ; }
12626	public function post ( $ url , $ data = array ( ) ) { $ client = $ this -> getClient ( ) ; return $ client -> request ( 'POST' , $ url , array ( 'form_params' => $ data ) ) ; }
2357	public function getFrontendUsername ( ) : ? string { $ token = $ this -> getToken ( FrontendUser :: SECURITY_SESSION_KEY ) ; if ( null === $ token || ! $ token -> getUser ( ) instanceof FrontendUser ) { return null ; } return $ token -> getUser ( ) -> getUsername ( ) ; }
1711	public function setEmptyEndTime ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ varValue === null ) { $ varValue = $ dc -> activeRecord -> startTime ; } return $ varValue ; }
4100	public function setType ( $ type ) { if ( is_array ( $ type ) ) $ type = implode ( "," , array_filter ( $ type ) ) ; $ this -> type = $ type ; $ this -> transport -> setType ( $ type ) ; return $ this ; }
1606	public function findRedirectByPath ( $ path ) { $ redirects = $ this -> findAllRedirects ( true ) ; foreach ( $ redirects as $ redirect ) { $ to = false ; if ( trim ( $ redirect [ 'uri' ] , '/' ) == $ path ) $ to = $ redirect [ 'to' ] ; elseif ( $ uri = $ this -> _isRedirectRegex ( $ redirect [ 'uri' ] ) ) if ( preg_match ( $ uri , $ path ) ) $ to = preg_replace ( $ uri , $ redirect [ 'to' ] , $ path ) ; if ( $ to ) { return [ 'to' => strpos ( $ to , '://' ) !== false ? $ to : UrlHelper :: siteUrl ( $ to ) , 'type' => $ redirect [ 'type' ] , ] ; } } return false ; }
8061	protected function runWorkerProcess ( WorkerInterface $ worker , SimpleSocket $ simpleSocket , $ i ) { $ replacements = array ( 'basename' => basename ( $ _SERVER [ 'PHP_SELF' ] ) , 'fullname' => $ _SERVER [ 'PHP_SELF' ] , 'class' => get_class ( $ worker ) , 'i' => $ i , 'state' => 'free' ) ; ProcessDetails :: setProcessTitle ( $ this -> childProcessTitleFormat , $ replacements ) ; $ this -> worker -> onProcessCreate ( $ this -> semaphore ) ; while ( TRUE ) { $ output = array ( 'pid' => getmypid ( ) ) ; try { $ replacements [ 'state' ] = 'free' ; ProcessDetails :: setProcessTitle ( $ this -> childProcessTitleFormat , $ replacements ) ; $ cmd = $ simpleSocket -> receive ( ) ; if ( ! isset ( $ cmd [ 'cmd' ] ) ) { break ; } $ replacements [ 'state' ] = 'busy' ; ProcessDetails :: setProcessTitle ( $ this -> childProcessTitleFormat , $ replacements ) ; if ( $ cmd [ 'cmd' ] == 'run' ) { try { $ output [ 'data' ] = $ this -> worker -> run ( $ cmd [ 'data' ] ) ; } catch ( \ Exception $ e ) { $ output [ 'workerException' ] = array ( 'class' => get_class ( $ e ) , 'message' => $ e -> getMessage ( ) , 'trace' => $ e -> getTraceAsString ( ) ) ; } $ simpleSocket -> send ( $ output ) ; } elseif ( $ cmd [ 'cmd' ] == 'exit' ) { break ; } } catch ( SimpleSocketException $ e ) { break ; } catch ( \ Exception $ e ) { $ output [ 'poolException' ] = array ( 'class' => get_class ( $ e ) , 'message' => $ e -> getMessage ( ) , 'trace' => $ e -> getTraceAsString ( ) ) ; $ simpleSocket -> send ( $ output ) ; } } $ this -> worker -> onProcessDestroy ( ) ; $ this -> exitPhp ( 0 ) ; }
10734	public function setLower ( $ lower ) : self { if ( ! is_numeric ( $ lower ) ) { throw new InvalidArgumentException ( __METHOD__ . "() expects parameter one, lower, to be a number" ) ; } $ this -> lower = + $ lower ; return $ this ; }
4987	public function setForm ( $ key , $ spec , $ enabled = true ) { if ( is_object ( $ spec ) ) { if ( $ spec instanceof FormParentInterface ) { $ spec -> setParent ( $ this ) ; } $ spec = [ '__instance__' => $ spec , 'name' => $ key , 'entity' => '*' ] ; } if ( ! is_array ( $ spec ) ) { $ spec = array ( 'type' => $ spec , 'name' => $ key ) ; } if ( ! isset ( $ spec [ 'name' ] ) ) { $ spec [ 'name' ] = $ key ; } if ( ! isset ( $ spec [ 'entity' ] ) ) { $ spec [ 'entity' ] = '*' ; } $ this -> forms [ $ key ] = $ spec ; if ( $ enabled ) { $ this -> enableForm ( $ key ) ; } elseif ( true === $ this -> activeForms ) { $ this -> activeForms = false ; } return $ this ; }
3513	public function getPublish ( $ group ) { if ( $ group && $ group != '*' ) { $ this -> manager -> exportTranslations ( $ group ) ; } else { $ this -> manager -> exportAllTranslations ( ) ; } $ errors = $ this -> manager -> errors ( ) ; event ( new TranslationsPublished ( $ group , $ errors ) ) ; return Response :: json ( array ( 'status' => $ errors ? 'errors' : 'ok' , 'errors' => $ errors ) ) ; }
2588	protected function addItineraries ( $ itineraries , $ legacySegments , & $ tattooCounter ) { if ( ! empty ( $ legacySegments ) ) { $ this -> addSegments ( $ legacySegments , $ tattooCounter ) ; } foreach ( $ itineraries as $ itinerary ) { $ this -> addSegments ( $ itinerary -> segments , $ tattooCounter , $ itinerary -> origin , $ itinerary -> destination ) ; } }
3962	private function createOrGetDefinition ( IMetaModelDataDefinition $ container ) { if ( $ container -> hasMetaModelDefinition ( ) ) { return $ container -> getMetaModelDefinition ( ) ; } $ container -> setMetaModelDefinition ( $ definition = new MetaModelDefinition ( ) ) ; return $ definition ; }
701	protected function cleanupVendorDir ( $ dir ) { if ( is_link ( $ link = "$dir/vendor/yiisoft/yii2" ) ) { $ this -> stdout ( "Removing symlink $link.\n" ) ; FileHelper :: unlink ( $ link ) ; } $ extensions = $ this -> findDirs ( "$dir/vendor/yiisoft" ) ; foreach ( $ extensions as $ ext ) { if ( is_link ( $ link = "$dir/vendor/yiisoft/yii2-$ext" ) ) { $ this -> stdout ( "Removing symlink $link.\n" ) ; FileHelper :: unlink ( $ link ) ; } } }
4794	function group ( $ columns , $ having = "" ) { $ this -> __destruct ( ) ; $ this -> group = $ columns ; $ this -> having = $ having ; return $ this ; }
11800	public function substitution ( $ search , $ replace ) { $ this -> body = str_replace ( $ search , $ replace , $ this -> body ) ; return $ this -> body ; }
10353	private function fireEventOn ( $ action , $ payload ) { $ event = $ this -> getEventName ( ) ; $ this -> dispatcher -> fire ( "auth.{$event}.{$action}" , $ payload ) ; }
9314	public function storageClearAction ( ) { if ( ! $ this -> isConsoleRequest ( ) ) { throw new \ RuntimeException ( 'You can only use this action from a console!' ) ; } $ dbAdapter = $ this -> getDbAdapter ( ) ; $ console = $ this -> getConsole ( ) ; $ this -> printConsoleBanner ( $ console ) ; try { $ table = new JobTable ( $ dbAdapter ) ; $ table -> truncate ( ) ; } catch ( \ Exception $ exception ) { $ console -> writeLine ( 'Truncating database table failed!' , ConsoleColor :: LIGHT_RED ) ; return ; } $ console -> writeLine ( 'Storage was successfully cleared!' , ConsoleColor :: LIGHT_GREEN ) ; }
9736	public function setWorksheet ( Worksheet $ pValue = null , $ pOverrideOld = false ) { if ( $ this -> worksheet === null ) { $ this -> worksheet = $ pValue ; $ this -> worksheet -> getCell ( $ this -> coordinates ) ; $ this -> worksheet -> getDrawingCollection ( ) -> append ( $ this ) ; } else { if ( $ pOverrideOld ) { $ iterator = $ this -> worksheet -> getDrawingCollection ( ) -> getIterator ( ) ; while ( $ iterator -> valid ( ) ) { if ( $ iterator -> current ( ) -> getHashCode ( ) == $ this -> getHashCode ( ) ) { $ this -> worksheet -> getDrawingCollection ( ) -> offsetUnset ( $ iterator -> key ( ) ) ; $ this -> worksheet = null ; break ; } } $ this -> setWorksheet ( $ pValue ) ; } else { throw new PhpSpreadsheetException ( 'A Worksheet has already been assigned. Drawings can only exist on one \\PhpOffice\\PhpSpreadsheet\\Worksheet.' ) ; } } return $ this ; }
9084	public function add ( string $ id , $ concrete = null , bool $ shared = null ) : DefinitionInterface { if ( is_string ( $ concrete ) && class_exists ( $ concrete ) ) { $ this -> alias ( $ concrete , $ id ) ; } $ concrete = $ concrete ?? $ id ; $ shared = $ shared ?? $ this -> defaultToShared ; if ( ! $ concrete instanceof DefinitionInterface ) { $ concrete = new Definition ( $ id , $ concrete ) ; } $ this -> definitions [ $ id ] = $ concrete -> setAlias ( $ id ) -> setShared ( $ shared ) ; return $ concrete ; }
2640	public function cleanUrl ( $ url ) { $ result = $ this -> _purge ( $ url , 'PURGE' , 'PURGE' ) ; if ( $ result [ 'status' ] ) { $ this -> logger -> execute ( $ url ) ; } if ( $ this -> config -> areWebHooksEnabled ( ) && $ this -> config -> canPublishKeyUrlChanges ( ) ) { $ this -> sendWebHook ( '*clean by URL for* ' . $ url ) ; } return $ result ; }
10554	public static function handleUnknownHost ( URL $ webroot , URL $ request , array $ sites , Dictionary $ cfg ) { $ on_unknown = strtoupper ( $ cfg -> dget ( 'unknown_host_policy' , "IGNORE" ) ) ; $ best_matching = self :: findBestMatching ( $ webroot , $ sites ) ; if ( $ on_unknown === "ERROR" || ( $ best_matching === null && $ on_unknown === "REDIRECT" ) ) return null ; if ( $ on_unknown === "REDIRECT" ) { $ redir = $ best_matching -> URL ( $ request -> path ) ; return $ redir ; } $ url = new URL ( $ webroot ) ; $ url -> fragment = null ; $ url -> query = null ; $ lang = $ cfg -> dget ( 'default_language' , 'en' ) ; $ vhost = new VirtualHost ( $ url , $ lang ) ; if ( $ best_matching === null ) { $ site = new Site ( ) ; $ site -> addVirtualHost ( $ vhost ) ; } else $ best_matching -> getSite ( ) -> addVirtualHost ( $ vhost ) ; return $ vhost ; }
6328	private function getColumnsSql ( ) { $ columnTypeMapper = new ColumnTypeMapper ( ) ; foreach ( $ this -> table -> getConstraints ( ) as $ constraint ) { if ( $ constraint instanceof PrimaryKey ) { $ primaryKey = $ constraint ; } } if ( ! isset ( $ primaryKey ) ) { $ primaryKey = new PrimaryKey ( ) ; $ primaryKey -> setTable ( $ this -> table ) ; $ this -> table -> addConstraint ( $ primaryKey ) ; } $ sql = '' ; if ( ! $ primaryKey -> isMulti ( ) && $ primaryKey -> isAutoCreateColumn ( ) ) { $ sql = sprintf ( '%s %s NOT NULL,' , $ primaryKey -> getColumns ( ) , $ primaryKey -> isAutoIncrement ( ) ? 'serial' : 'integer' ) ; } foreach ( $ this -> table -> getColumns ( ) as $ column ) { if ( $ column instanceof CustomColumn ) { $ columnType = $ column -> getType ( ) ; } else { $ columnType = $ columnTypeMapper -> getNative ( $ column -> getType ( ) ) ; } $ sql .= sprintf ( '%s %s%s %s %s,' , $ column -> getName ( ) , $ columnType , $ this -> getTypeConstraints ( $ column ) , $ column -> isNotNull ( ) ? 'NOT NULL' : '' , null === $ column -> getDefault ( ) ? '' : 'DEFAULT' . ' ' . $ this -> addQuotesIfNeeded ( $ column , $ column -> getDefault ( ) ) ) ; } return rtrim ( $ sql , ',' ) ; }
171	public static function createDirectory ( $ path , $ mode = 0775 , $ recursive = true ) { if ( is_dir ( $ path ) ) { return true ; } $ parentDir = dirname ( $ path ) ; if ( $ recursive && ! is_dir ( $ parentDir ) && $ parentDir !== $ path ) { static :: createDirectory ( $ parentDir , $ mode , true ) ; } try { if ( ! mkdir ( $ path , $ mode ) ) { return false ; } } catch ( \ Exception $ e ) { if ( ! is_dir ( $ path ) ) { throw new \ yii \ base \ Exception ( "Failed to create directory \"$path\": " . $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } } try { return chmod ( $ path , $ mode ) ; } catch ( \ Exception $ e ) { throw new \ yii \ base \ Exception ( "Failed to change permissions for directory \"$path\": " . $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } }
4285	public function onOutput ( Event $ event ) { $ this -> channelName = $ this -> debug -> getCfg ( 'channel' ) ; $ this -> data = $ this -> debug -> getData ( ) ; $ this -> processAlerts ( ) ; $ this -> processSummary ( ) ; $ this -> processLog ( ) ; if ( $ this -> json [ 'rows' ] ) { \ array_unshift ( $ this -> json [ 'rows' ] , array ( array ( 'PHP' , isset ( $ _SERVER [ 'REQUEST_METHOD' ] ) ? $ _SERVER [ 'REQUEST_METHOD' ] . ' ' . $ _SERVER [ 'REQUEST_URI' ] : '$: ' . \ implode ( ' ' , $ _SERVER [ 'argv' ] ) ) , null , 'groupCollapsed' , ) ) ; \ array_push ( $ this -> json [ 'rows' ] , array ( array ( ) , null , 'groupEnd' , ) ) ; $ encoded = $ this -> encode ( $ this -> json ) ; if ( \ strlen ( $ encoded ) > 250000 ) { $ this -> debug -> warn ( 'chromeLogger: output limit exceeded' ) ; } else { $ event [ 'headers' ] [ ] = array ( self :: HEADER_NAME , $ encoded ) ; } } $ this -> data = array ( ) ; $ this -> json [ 'rows' ] = array ( ) ; }
5602	public function paintFail ( $ message ) { if ( ! $ this -> fail && ! $ this -> error ) { $ this -> fail = true ; $ this -> message = self :: escapeVal ( $ message ) ; $ this -> listener -> write ( '{status:"fail",message:"' . $ this -> message . '",group:"' . $ this -> group . '",case:"' . $ this -> case . '",method:"' . $ this -> method . '"}' ) ; } }
9458	private function mapAdminRoutes ( ) { $ this -> adminGroup ( function ( ) { $ this -> name ( 'foundation.' ) -> group ( function ( ) { Routes \ Admin \ DashboardRoute :: register ( ) ; Routes \ Admin \ SettingsRoutes :: register ( ) ; Routes \ Admin \ SystemRoutes :: register ( ) ; } ) ; } ) ; }
1057	public static function findTypesThatChangedKind ( Schema $ schemaA , Schema $ schemaB ) : iterable { $ schemaATypeMap = $ schemaA -> getTypeMap ( ) ; $ schemaBTypeMap = $ schemaB -> getTypeMap ( ) ; $ breakingChanges = [ ] ; foreach ( $ schemaATypeMap as $ typeName => $ schemaAType ) { if ( ! isset ( $ schemaBTypeMap [ $ typeName ] ) ) { continue ; } $ schemaBType = $ schemaBTypeMap [ $ typeName ] ; if ( $ schemaAType instanceof $ schemaBType ) { continue ; } if ( $ schemaBType instanceof $ schemaAType ) { continue ; } $ schemaATypeKindName = self :: typeKindName ( $ schemaAType ) ; $ schemaBTypeKindName = self :: typeKindName ( $ schemaBType ) ; $ breakingChanges [ ] = [ 'type' => self :: BREAKING_CHANGE_TYPE_CHANGED_KIND , 'description' => "${typeName} changed from ${schemaATypeKindName} to ${schemaBTypeKindName}." , ] ; } return $ breakingChanges ; }
1209	public function slice ( ItemInterface $ item , $ offset , $ length = null ) { $ names = array_keys ( $ item -> getChildren ( ) ) ; if ( $ offset instanceof ItemInterface ) { $ offset = $ offset -> getName ( ) ; } if ( ! is_numeric ( $ offset ) ) { $ offset = array_search ( $ offset , $ names ) ; } if ( null !== $ length ) { if ( $ length instanceof ItemInterface ) { $ length = $ length -> getName ( ) ; } if ( ! is_numeric ( $ length ) ) { $ index = array_search ( $ length , $ names ) ; $ length = ( $ index < $ offset ) ? 0 : $ index - $ offset ; } } $ slicedItem = $ item -> copy ( ) ; $ children = array_slice ( $ slicedItem -> getChildren ( ) , $ offset , $ length ) ; $ slicedItem -> setChildren ( $ children ) ; return $ slicedItem ; }
811	private function fixSpaceBelowClassElement ( Tokens $ tokens , $ classEndIndex , $ elementEndIndex ) { for ( $ nextNotWhite = $ elementEndIndex + 1 ; ; ++ $ nextNotWhite ) { if ( ( $ tokens [ $ nextNotWhite ] -> isComment ( ) || $ tokens [ $ nextNotWhite ] -> isWhitespace ( ) ) && false === strpos ( $ tokens [ $ nextNotWhite ] -> getContent ( ) , "\n" ) ) { continue ; } break ; } if ( $ tokens [ $ nextNotWhite ] -> isWhitespace ( ) ) { $ nextNotWhite = $ tokens -> getNextNonWhitespace ( $ nextNotWhite ) ; } $ this -> correctLineBreaks ( $ tokens , $ elementEndIndex , $ nextNotWhite , $ nextNotWhite === $ classEndIndex ? 1 : 2 ) ; }
10265	public function getPerson ( $ state_code = null ) { $ state_code = ! empty ( $ state_code ) ? $ state_code : $ this -> getState ( ) -> code ; $ person = new Entities \ Person ; $ person -> guid = $ this -> getGuid ( ) ; $ person -> unique_hash = $ this -> getUniqueHash ( ) ; $ person -> name = $ this -> getFullName ( ) ; if ( rand ( 1 , 100 ) % 5 == 0 ) { $ person -> company = $ this -> getCompanyName ( $ person -> name -> last ) ; } else { $ person -> company = $ this -> getCompanyName ( ) ; } $ person -> address = $ this -> getAddress ( $ state_code ) ; $ person -> address2 = $ this -> getAddress ( $ state_code , $ person -> address -> zip ) ; $ person -> internet = $ this -> getInternet ( $ person -> name , $ person -> company ) ; $ person -> phone = new stdclass ( ) ; $ person -> phone -> home = $ this -> getPhone ( $ state_code , $ person -> address -> zip ) ; $ person -> phone -> mobile = $ this -> getPhone ( $ state_code , $ person -> address -> zip ) ; $ person -> phone -> work = $ this -> getPhone ( $ state_code , $ person -> address -> zip ) ; $ person -> ssn = $ this -> getSsn ( $ state_code ) ; $ person -> dln = $ this -> getDln ( $ state_code ) ; $ person -> dob = $ this -> getBirthDate ( ) ; $ person -> credit_card = $ this -> getCreditCard ( ) ; $ person -> bank_account = $ this -> getBank ( ) ; return $ person ; }
5825	public function encodeData ( ) { switch ( $ this -> encoding ) { case Request :: ENCODING_JSON : return json_encode ( $ this -> data ) ; break ; case Request :: ENCODING_RAW : return ( string ) $ this -> data ; break ; case Request :: ENCODING_QUERY : return http_build_query ( $ this -> data ) ; break ; default : throw new \ UnexpectedValueException ( "Encoding [$encoding] not a known Request::ENCODING_* constant" ) ; } }
4376	protected function buildTableFooter ( $ keys ) { $ haveTotal = false ; $ cells = array ( ) ; foreach ( $ keys as $ key ) { $ colHasTotal = isset ( $ this -> tableInfo [ 'totals' ] [ $ key ] ) ; $ cells [ ] = $ colHasTotal ? $ this -> dump ( \ round ( $ this -> tableInfo [ 'totals' ] [ $ key ] , 6 ) , true , 'td' ) : '<td></td>' ; $ haveTotal = $ haveTotal || $ colHasTotal ; } if ( ! $ haveTotal ) { return '' ; } return '<tfoot>' . "\n" . '<tr><td>&nbsp;</td>' . ( $ this -> tableInfo [ 'haveObjRow' ] ? '<td>&nbsp;</td>' : '' ) . \ implode ( '' , $ cells ) . '</tr>' . "\n" . '</tfoot>' . "\n" ; }
7197	protected function setIsFirst ( OrderInterface $ order ) { if ( null !== $ customer = $ order -> getCustomer ( ) ) { if ( $ customer -> hasParent ( ) ) { $ customer = $ customer -> getParent ( ) ; } $ first = ! $ this -> orderRepository -> existsForCustomer ( $ customer ) ; } else { $ first = ! $ this -> orderRepository -> existsForEmail ( $ order -> getEmail ( ) ) ; } if ( $ first != $ order -> isFirst ( ) ) { $ order -> setFirst ( $ first ) ; return true ; } return false ; }
1727	public function findBy ( $ strColumn , $ varValue ) { $ objResult = $ this -> Database -> prepare ( "SELECT * FROM " . $ this -> strTable . " WHERE " . Database :: quoteIdentifier ( $ strColumn ) . "=?" ) -> limit ( 1 ) -> execute ( $ varValue ) ; if ( $ objResult -> numRows > 0 ) { $ this -> arrData = $ objResult -> row ( ) ; return true ; } return false ; }
10691	public function shutdown ( ) { if ( ! $ this -> is_shutdown ) { $ this -> is_shutdown = true ; if ( ! empty ( $ this -> autoloader ) ) spl_autoload_unregister ( array ( $ this -> autoloader , 'autoload' ) ) ; ErrorInterceptor :: unregisterErrorHandler ( ) ; restore_exception_handler ( ) ; } }
11446	public function getSpooler ( ) { if ( empty ( $ this -> spooler ) ) { $ spool_class = $ this -> getDefault ( 'spooler' ) ; if ( class_exists ( $ spool_class ) ) { $ this -> setSpooler ( new $ spool_class ) ; } else { throw new \ Exception ( sprintf ( 'Default spool class "%s" not found!' , $ spool_class ) ) ; } } return $ this -> spooler ; }
12221	private function logException ( Exception $ exception ) { if ( in_array ( $ exception -> getStatusCode ( ) , $ this -> doNotLog ) ) { return ; } $ message = sprintf ( 'Uncaught exception of type %s thrown in file %s at line %s%s.' , get_class ( $ exception ) , $ exception -> getFile ( ) , $ exception -> getLine ( ) , $ exception -> getMessage ( ) ? sprintf ( ' with message "%s"' , $ exception -> getMessage ( ) ) : '' ) ; $ this -> container [ 'log' ] -> error ( $ message , array ( 'exception' => $ exception , 'Exception message' => $ message , 'Exception line' => $ exception -> getLine ( ) , 'Exception trace' => $ exception -> getTraceAsString ( ) , ) ) ; }
6734	protected function handleException ( \ Throwable $ e , Request $ request ) : Response { if ( ! $ e instanceof Exception \ Exception ) { $ e = new Exception \ UncaughtException ( $ e ) ; } $ code = $ e -> getStatusCode ( ) ; if ( $ this -> exceptionHandlers [ $ code ] instanceof ExceptionHandler ) { return $ this -> exceptionHandlers [ $ code ] -> handle ( $ e , $ request ) ; } elseif ( $ this -> defaultExceptionHandler instanceof ExceptionHandler ) { return $ this -> defaultExceptionHandler -> handle ( $ e , $ request ) ; } else { return ( new \ Circuit \ ExceptionHandler \ DefaultHandler ) -> handle ( $ e , $ request ) ; } }
11502	public function showAction ( Comment $ comment ) { $ deleteForm = $ this -> createDeleteForm ( $ comment ) ; return array ( 'entity' => $ comment , 'delete_form' => $ deleteForm -> createView ( ) , ) ; }
2774	public function setPrivateKey ( string $ privateKey , int $ port = 22 , ? string $ wrapper = null ) : void { if ( $ wrapper === null ) { $ wrapper = __DIR__ . '/../bin/git-ssh-wrapper.sh' ; } if ( ! $ wrapperPath = realpath ( $ wrapper ) ) { throw new GitException ( 'Path to GIT_SSH wrapper script could not be resolved: ' . $ wrapper ) ; } if ( ! $ privateKeyPath = realpath ( $ privateKey ) ) { throw new GitException ( 'Path private key could not be resolved: ' . $ privateKey ) ; } $ this -> setEnvVar ( 'GIT_SSH' , $ wrapperPath ) ; $ this -> setEnvVar ( 'GIT_SSH_KEY' , $ privateKeyPath ) ; $ this -> setEnvVar ( 'GIT_SSH_PORT' , $ port ) ; }
1503	public function handle ( $ request , Closure $ next , string $ namespace ) { $ api = $ this -> bindApi ( $ namespace , $ request -> getSchemeAndHttpHost ( ) . $ request -> getBaseUrl ( ) ) ; $ this -> substituteBindings ( $ api ) ; $ this -> bindPageResolver ( ) ; return $ next ( $ request ) ; }
4418	protected function createRequest ( Content $ content , Location $ location ) { $ request = Request :: create ( '' ) ; $ request -> attributes -> set ( 'content' , $ content ) ; $ request -> attributes -> set ( 'location' , $ location ) ; if ( interface_exists ( 'eZ\Publish\Core\MVC\Symfony\View\ContentValueView' ) ) { $ contentView = new ContentView ( ) ; $ contentView -> setLocation ( $ location ) ; $ contentView -> setContent ( $ content ) ; $ request -> attributes -> set ( 'view' , $ contentView ) ; } return $ request ; }
7491	public function setLength ( $ newLength , $ padding = ' ' ) { $ newLength = ( int ) $ newLength ; $ currentLength = $ this -> length ( ) ; if ( $ newLength != $ currentLength ) { while ( $ newLength > $ this -> length ( ) ) { $ this -> string .= $ padding ; } if ( $ newLength < $ this -> length ( ) ) { $ this -> string = mb_substr ( $ this -> string , 0 , $ newLength , $ this -> encoding ) ; } } return $ this ; }
9747	public function setTimeZone ( $ timezone ) { if ( ! $ timezone ) { return $ this ; } try { Carbon :: now ( $ timezone ) ; } catch ( \ Exception $ e ) { $ this -> invalidArguments ( '10004' , sprintf ( 'Invalid timezone set "%s"' , $ timezone ) ) ; } return $ this -> setParameter ( 'timezone' , $ timezone ) ; }
6058	public function removeFolder ( $ id ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> delete ( 'v1/folders/' . $ id . '' , $ parameters ) ; $ result = new FolderResponse ( $ result ) ; return $ result ; }
1077	public static function typeFromAST ( Schema $ schema , $ inputTypeNode ) { if ( $ inputTypeNode instanceof ListTypeNode ) { $ innerType = self :: typeFromAST ( $ schema , $ inputTypeNode -> type ) ; return $ innerType ? new ListOfType ( $ innerType ) : null ; } if ( $ inputTypeNode instanceof NonNullTypeNode ) { $ innerType = self :: typeFromAST ( $ schema , $ inputTypeNode -> type ) ; return $ innerType ? new NonNull ( $ innerType ) : null ; } if ( $ inputTypeNode instanceof NamedTypeNode ) { return $ schema -> getType ( $ inputTypeNode -> name -> value ) ; } throw new Error ( 'Unexpected type kind: ' . $ inputTypeNode -> kind . '.' ) ; }
8271	protected function getKeyEncoder ( $ lockData ) { if ( isset ( $ lockData [ 'encoder' ] ) && is_string ( $ lockData [ 'encoder' ] ) ) { $ name = $ lockData [ 'encoder' ] ; } else { $ name = $ this -> config [ "encoder" ] ; } try { $ instance = $ this -> picoAuth -> getContainer ( ) -> get ( $ name ) ; } catch ( \ Exception $ e ) { throw new \ RuntimeException ( "Specified PageLock encoder not resolvable." ) ; } return $ instance ; }
1410	public function resourceTypeNotRecognised ( string $ type , string $ path = '/data' ) : ErrorInterface { return new Error ( null , null , Response :: HTTP_BAD_REQUEST , $ this -> trans ( 'resource_type_not_recognised' , 'code' ) , $ this -> trans ( 'resource_type_not_recognised' , 'title' ) , $ this -> trans ( 'resource_type_not_recognised' , 'detail' , compact ( 'type' ) ) , $ this -> pointer ( $ path , 'type' ) ) ; }
8747	public function select ( ) { $ read = [ $ this -> stream ] ; $ write = null ; $ except = null ; $ this -> selected = @ stream_select ( $ read , $ write , $ except , 0 , $ this -> timeout ) ; return $ this ; }
10211	function fromXML ( $ xmlElement ) { if ( isset ( $ xmlElement -> id ) ) $ this -> id = $ xmlElement -> id ; $ this -> email = ( string ) $ xmlElement -> email ; if ( isset ( $ xmlElement -> permission ) ) $ this -> permission = Permission :: getPermission ( ( string ) $ xmlElement -> permission ) ; if ( isset ( $ xmlElement -> external_id ) ) ( string ) $ this -> external_id = $ xmlElement -> external_id ; if ( isset ( $ xmlElement -> anonymous ) ) ( string ) $ this -> anonymous = $ xmlElement -> anonymous ; if ( isset ( $ xmlElement [ 'anonymous' ] ) ) $ this -> anonymous = $ xmlElement [ 'anonymous' ] ; if ( isset ( $ xmlElement -> created ) ) $ this -> created = $ xmlElement -> created ; if ( isset ( $ xmlElement -> updated ) ) $ this -> updated = $ xmlElement -> updated ; if ( isset ( $ xmlElement -> standard_fields ) ) { $ this -> standard_fields = array ( ) ; foreach ( $ xmlElement -> standard_fields -> children ( ) as $ field ) { $ this -> standard_fields [ trim ( $ field -> name ) ] = ( string ) $ field -> value ; } } if ( isset ( $ xmlElement -> custom_fields ) ) { foreach ( $ xmlElement -> custom_fields -> children ( ) as $ field ) { $ this -> custom_fields [ trim ( $ field -> name ) ] = ( string ) $ field -> value ; } } }
2744	public function execute ( \ Magento \ Framework \ Event \ Observer $ observer ) { if ( $ this -> config -> getType ( ) == Config :: FASTLY && $ this -> config -> isEnabled ( ) ) { $ this -> purgeCache -> sendPurgeRequest ( ) ; } }
1508	public static function fromArray ( array $ url ) : self { return new self ( isset ( $ url [ 'host' ] ) ? $ url [ 'host' ] : '' , isset ( $ url [ 'namespace' ] ) ? $ url [ 'namespace' ] : '' , isset ( $ url [ 'name' ] ) ? $ url [ 'name' ] : '' ) ; }
1139	public function shiftSiblingsForRestore ( ) { if ( is_null ( $ this -> getRight ( ) ) || is_null ( $ this -> getLeft ( ) ) ) return ; $ self = $ this ; $ this -> getConnection ( ) -> transaction ( function ( ) use ( $ self ) { $ lftCol = $ self -> getLeftColumnName ( ) ; $ rgtCol = $ self -> getRightColumnName ( ) ; $ lft = $ self -> getLeft ( ) ; $ rgt = $ self -> getRight ( ) ; $ diff = $ rgt - $ lft + 1 ; $ self -> newNestedSetQuery ( ) -> where ( $ lftCol , '>=' , $ lft ) -> increment ( $ lftCol , $ diff ) ; $ self -> newNestedSetQuery ( ) -> where ( $ rgtCol , '>=' , $ lft ) -> increment ( $ rgtCol , $ diff ) ; } ) ; }
4002	protected function getCountFor ( $ intMetaModelId , $ intFilterId ) { $ metaModel = $ this -> loadMetaModel ( $ intMetaModelId ) ; if ( $ metaModel == null ) { return false ; } $ objFilter = $ metaModel -> getEmptyFilter ( ) ; if ( $ intFilterId ) { $ collection = $ this -> getServiceContainer ( ) -> getFilterFactory ( ) -> createCollection ( $ intFilterId ) ; $ values = [ ] ; foreach ( $ collection -> getParameters ( ) as $ key ) { $ values [ $ key ] = Input :: get ( $ key ) ; } $ collection -> addRules ( $ objFilter , $ values ) ; } return $ metaModel -> getCount ( $ objFilter ) ; }
6460	public function radioAction ( $ customized , $ selector ) { $ field = $ this -> getWorkingElement ( ) -> findField ( $ selector ) ; $ customized = ( bool ) $ customized ; if ( $ field !== null && ! $ customized ) { $ field -> selectOption ( $ field -> getAttribute ( 'value' ) ) ; return ; } foreach ( $ this -> findLabels ( $ selector ) as $ label ) { if ( $ customized && ! $ label -> isVisible ( ) ) { continue ; } $ label -> click ( ) ; return ; } $ this -> throwNoSuchElementException ( $ selector , $ field ) ; }
4115	public function getRemoteCallUrlTemplate ( ) { if ( is_null ( $ this -> remoteCallUrlTemplate ) ) { $ this -> remoteCallUrlTemplate = Mage :: getStoreConfig ( 'dev/aoe_templatehints/remoteCallUrlTemplate' ) ; } return $ this -> remoteCallUrlTemplate ; }
5866	protected function getIndexer ( \ TYPO3 \ CMS \ Core \ Resource \ ResourceStorage $ storage ) { return GeneralUtility :: makeInstance ( Indexer :: class , $ storage ) ; }
4580	public function encrypt ( Encryptable $ model ) : EncryptionService { if ( $ model -> getEncrypted ( ) ) { return $ this ; } $ properties = $ this -> getProperties ( $ model ) ; foreach ( $ properties as $ property ) { $ property -> setAccessible ( true ) ; $ property -> setValue ( $ model , $ this -> cipherService -> encrypt ( $ property -> getValue ( $ model ) ) ) ; } $ model -> setEncrypted ( true ) ; return $ this ; }
4976	public static function factory ( ContainerInterface $ container ) { $ manager = $ container -> get ( 'ModuleManager' ) ; $ modules = $ manager -> getLoadedModules ( ) ; return new static ( $ modules ) ; }
4243	public function onShutdown ( ) { $ this -> runtimeVals ( ) ; if ( $ this -> testEmailLog ( ) ) { $ this -> emailLog ( ) ; } if ( ! $ this -> debug -> getData ( 'outputSent' ) ) { echo $ this -> debug -> output ( ) ; } return ; }
4669	protected function beforeGeneration ( ) { $ this -> config -> getLogger ( ) -> startBreak ( 'XSD Parsing' ) ; $ this -> XSDMap = XSDMapGenerator :: buildXSDMap ( $ this -> config ) ; $ this -> config -> getLogger ( ) -> endBreak ( 'XSD Parsing' ) ; $ this -> config -> getLogger ( ) -> startBreak ( 'Generator Class Initialization' ) ; self :: _initializeClasses ( $ this -> config ) ; $ this -> autoloadMap = new AutoloaderTemplate ( $ this -> config ) ; $ this -> mapTemplate = new ParserMapTemplate ( $ this -> config ) ; $ this -> autoloadMap -> addEntry ( $ this -> mapTemplate -> getClassName ( ) , $ this -> mapTemplate -> getClassPath ( ) ) ; $ helperTemplate = new HelperTemplate ( $ this -> config ) ; $ helperTemplate -> writeToFile ( ) ; $ this -> autoloadMap -> addEntry ( $ helperTemplate -> getClassName ( ) , $ helperTemplate -> getClassPath ( ) ) ; $ this -> config -> getLogger ( ) -> endBreak ( 'Generator Class Initialization' ) ; }
4079	protected function buildInputScreen ( $ metaModel ) { $ metaModelName = $ this -> getMetaModelName ( $ metaModel ) ; $ inputScreen = $ this -> information [ $ metaModelName ] [ self :: INPUTSCREEN ] ; if ( ! is_object ( $ inputScreen ) ) { $ inputScreen = $ this -> information [ $ metaModelName ] [ self :: INPUTSCREEN ] = new InputScreen ( $ this -> container , $ inputScreen [ 'row' ] , $ inputScreen [ 'properties' ] , $ inputScreen [ 'conditions' ] , $ inputScreen [ 'groupSort' ] ) ; } return $ inputScreen ; }
962	public function buildAuthUrl ( $ mode = null ) { return $ this -> api -> getAuthUrl ( Config :: get ( 'shopify-app.api_scopes' ) , URL :: secure ( Config :: get ( 'shopify-app.api_redirect' ) ) , $ mode ?? 'offline' ) ; }
4361	public static function isUtf8 ( $ str , & $ special = false ) { self :: setStr ( $ str ) ; $ special = false ; while ( self :: $ curI < self :: $ stats [ 'strLen' ] ) { $ isUtf8 = self :: isOffsetUtf8 ( $ isSpecial ) ; if ( ! $ isUtf8 ) { return false ; } if ( $ isSpecial ) { $ special = true ; } } $ special = $ special || self :: hasSpecial ( $ str ) ; return true ; }
5584	public function click ( $ label ) { $ raw = $ this -> clickSubmit ( $ label ) ; if ( ! $ raw ) { $ raw = $ this -> clickLink ( $ label ) ; } if ( ! $ raw ) { $ raw = $ this -> clickImage ( $ label ) ; } return $ raw ; }
10671	public static function toArray ( $ obj ) { if ( $ obj instanceof \ DOMNode ) { $ obj = simplexml_import_dom ( $ obj ) ; } if ( ! ( $ obj instanceof \ SimpleXMLElement ) ) { throw new \ RuntimeException ( Tools :: poorManTranslate ( 'fts-shared' , 'The input is not instance of SimpleXMLElement, DOMDocument or DOMNode.' ) ) ; } $ result = [ ] ; $ namespaces = array_merge ( [ '' => '' ] , $ obj -> getNamespaces ( true ) ) ; self :: _toArray ( $ obj , $ result , '' , array_keys ( $ namespaces ) ) ; return $ result ; }
5512	public function expectMaximumCallCount ( $ method , $ count , $ message = '%s' ) { $ this -> dieOnNoMethod ( $ method , 'set maximum call count' ) ; $ message .= Mock :: getExpectationLine ( ) ; $ this -> max_counts [ strtolower ( $ method ) ] = new MaximumCallCountExpectation ( $ method , $ count , $ message ) ; }
4441	public function fromSubscriptions ( string $ topic ) : array { $ response = [ ] ; if ( empty ( $ topic ) ) { return $ response ; } $ subscriptions = $ this -> client -> call ( 'subscription' , 'default' , 'all' , $ topic ) ; $ subscriptions = json_decode ( $ subscriptions , true ) ? : [ ] ; foreach ( $ subscriptions as $ subscription => $ queues ) { $ topicPattern = str_replace ( [ '.' , '*' , '#' ] , [ '\.' , '[a-zA-z0-9^.]{1,}' , '.*' ] , $ subscription ) ; if ( preg_match ( "/^$topicPattern$/" , $ topic ) ) { $ response = array_merge ( $ response , $ queues ) ; } } return array_unique ( $ response ) ; }
12322	public function run ( InputInterface $ input , OutputInterface $ output ) { $ this -> doPreRun ( $ input , $ output ) ; $ code = parent :: run ( $ input , $ output ) ; $ this -> doPostRun ( $ input , $ output , $ code ) ; return $ code ; }
1738	public function generate ( ) { if ( $ this -> singleSRC == '' ) { return '' ; } $ objFile = FilesModel :: findByUuid ( $ this -> singleSRC ) ; if ( $ objFile === null ) { return '' ; } $ allowedDownload = StringUtil :: trimsplit ( ',' , strtolower ( Config :: get ( 'allowedDownload' ) ) ) ; if ( ! \ in_array ( $ objFile -> extension , $ allowedDownload ) ) { return '' ; } $ file = Input :: get ( 'file' , true ) ; if ( $ file && ( ! isset ( $ _GET [ 'cid' ] ) || Input :: get ( 'cid' ) == $ this -> id ) ) { if ( $ file == $ objFile -> path ) { Controller :: sendFileToBrowser ( $ file , ( bool ) $ this -> inline ) ; } if ( isset ( $ _GET [ 'cid' ] ) ) { throw new PageNotFoundException ( 'Invalid file name' ) ; } } $ this -> objFile = $ objFile ; $ this -> singleSRC = $ objFile -> path ; return parent :: generate ( ) ; }
9841	public function createSealedJsonRequest ( string $ method , string $ uri , array $ arrayToJsonify , SealingPublicKey $ key , array $ headers = [ ] ) : RequestInterface { if ( empty ( $ headers [ 'Content-Type' ] ) ) { $ headers [ 'Content-Type' ] = 'application/json' ; } $ body = \ json_encode ( $ arrayToJsonify , JSON_PRETTY_PRINT ) ; if ( ! \ is_string ( $ body ) ) { throw new InvalidMessageException ( 'Cannot JSON-encode this message.' ) ; } return $ this -> createSealedRequest ( $ method , $ uri , $ body , $ key , $ headers ) ; }
4515	public static function parseFile ( string $ file , array $ data = [ ] ) : array { $ string = file_get_contents ( $ file ) ; return static :: parse ( $ string , $ data ) ; }
11847	final public function save ( ) { $ this -> checkReadOnly ( ) ; $ this -> _save ( ) ; if ( count ( $ this -> _errors ) ) { throw new Zend_Db_Table_Row_Exception ( 'This row contain errors.' ) ; } foreach ( $ this -> _data as $ column => & $ value ) { if ( $ value instanceof DateTime ) { if ( ! ( $ value instanceof Benri_Util_DateTime ) ) { $ value = new Benri_Util_DateTime ( $ value -> format ( 'U' ) ) ; } $ value -> setFormat ( 'Y-m-d H:i:s' ) ; } } if ( $ this -> isNewRecord ( ) ) { if ( $ this -> offsetExists ( 'created_at' ) ) { $ this -> created_at = new Benri_Util_DateTime ( ) ; $ this -> created_at -> setFormat ( 'Y-m-d H:i:s' ) ; } } if ( $ this -> offsetExists ( 'updated_at' ) ) { $ this -> updated_at = new Benri_Util_DateTime ( ) ; $ this -> updated_at -> setFormat ( 'Y-m-d H:i:s' ) ; } parent :: save ( ) ; $ this -> _postSave ( ) ; return $ this ; }
7091	protected function match ( Request $ request ) { foreach ( $ this -> routes as $ route ) { if ( $ route -> method ( ) === $ request -> method ( ) && $ route -> match ( $ request -> url ( ) ) ) { if ( $ action = $ route -> action ( ) ) { try { $ response = $ action ( $ request , $ route -> args ( ) ) ; if ( $ response !== false ) return $ response ; } catch ( AbortRouteException $ abort ) { return $ abort -> response ( ) ; } } else return null ; } } return false ; }
4523	protected function loadDefinition ( $ id ) { $ filename = $ this -> definitionPath . $ id . '.json' ; $ definition = @ file_get_contents ( $ filename ) ; if ( empty ( $ definition ) ) { throw new UnknownZoneException ( $ id ) ; } $ definition = json_decode ( $ definition , true ) ; $ definition [ 'id' ] = $ id ; return $ definition ; }
12588	protected function createTokenTable ( $ db , $ tableName ) { $ driver = $ db -> getDriverName ( ) ; $ file = dirname ( __DIR__ ) . '/migrations/' . $ this -> tokenTableName . '.' . $ db -> getDriverName ( ) ; $ pdo = $ this -> getDbConnection ( ) -> pdoInstance ; $ sql = file_get_contents ( $ file ) ; $ sql = rtrim ( $ sql ) ; $ sqls = preg_replace_callback ( "/\((.*)\)/" , create_function ( '$matches' , 'return str_replace(";"," $$$ ",$matches[0]);' ) , $ sql ) ; $ sqls = explode ( ";" , $ sqls ) ; foreach ( $ sqls as $ sql ) { if ( ! empty ( $ sql ) ) { $ sql = str_replace ( " $$$ " , ";" , $ sql ) . ";" ; $ pdo -> exec ( $ sql ) ; } } }
1164	protected function throwValidationException ( $ result , $ validator ) { $ response = new JsonResponse ( $ result , 200 ) ; if ( $ result !== true && class_exists ( ValidationException :: class ) ) { throw new ValidationException ( $ validator , $ response ) ; } throw new HttpResponseException ( $ response ) ; }
5188	private function createPage ( string $ title , string $ body , string $ source , int $ order , string $ cover , string $ lead ) : \ One \ Model \ Page { return new Page ( $ title , $ body , $ source , $ order , $ cover , $ lead ) ; }
9672	private function writeBorderPr ( XMLWriter $ objWriter , $ pName , Border $ pBorder ) { if ( $ pBorder -> getBorderStyle ( ) != Border :: BORDER_NONE ) { $ objWriter -> startElement ( $ pName ) ; $ objWriter -> writeAttribute ( 'style' , $ pBorder -> getBorderStyle ( ) ) ; $ objWriter -> startElement ( 'color' ) ; $ objWriter -> writeAttribute ( 'rgb' , $ pBorder -> getColor ( ) -> getARGB ( ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; } }
10424	public function parseXml ( $ xml ) { if ( is_null ( $ xml ) ) { return null ; } $ xml = new QuiteSimpleXMLElement ( $ xml ) ; $ xml -> registerXPathNamespaces ( $ this -> namespaces ) ; return $ xml ; }
1779	public function getEmptyStringOrNull ( ) { if ( ! isset ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ this -> strField ] [ 'sql' ] ) ) { return '' ; } return static :: getEmptyStringOrNullByFieldType ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ this -> strField ] [ 'sql' ] ) ; }
8537	public function setRentalFeeList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'RentalFeeList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
3266	public function getPath ( ) : string { return $ this -> config -> getDir ( ) . $ this -> getName ( ) . $ this -> config -> getExt ( ) ; }
4136	public function getParams ( array $ params ) { $ r = '' ; ksort ( $ params ) ; foreach ( $ params as $ key => $ value ) { $ r .= '&' . $ key . '=' . rawurlencode ( $ value ) ; } unset ( $ params , $ key , $ value ) ; return trim ( $ r , '&' ) ; }
5731	public function getLeagues ( array $ filter = [ 'areas' => '' ] ) { $ leagues = $ this -> run ( "v2/competitions" . "?" . http_build_query ( $ filter ) ) ; return collect ( $ leagues -> competitions ) ; }
8319	public function matches ( $ regexp , $ message ) { if ( ! is_string ( $ regexp ) || ! is_string ( $ message ) ) { throw new \ InvalidArgumentException ( "Both arguments must be string." ) ; } $ this -> constraints [ ] = ( function ( Password $ str ) use ( $ regexp , $ message ) { if ( ! preg_match ( $ regexp , $ str ) ) { return $ message ; } else { return true ; } } ) ; return $ this ; }
6080	public function updateProperties ( $ id , array $ properties ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'properties' => $ properties ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> put ( 'v1/media/' . $ id . '/properties' , $ parameters ) ; $ result = new MediaResponse ( $ result ) ; return $ result ; }
1319	private function cleanUpParameters ( array $ parameters ) { foreach ( $ parameters as $ key => $ value ) { if ( is_bool ( $ value ) ) { $ parameters [ $ key ] = var_export ( $ value , true ) ; } } return $ parameters ; }
7501	public function clearCache ( string $ namespace = null ) { if ( null !== $ namespace ) { $ this -> cacheStore -> remove ( self :: APP_CACHE_PREFIX . $ namespace , array ( ) ) ; return ; } $ this -> cacheStore -> clear ( ) ; }
1168	protected function setRemoteValidation ( $ attribute , $ validateAll = false ) { $ validator = $ this -> validator ; $ rules = $ validator -> getRules ( ) ; $ rules = isset ( $ rules [ $ attribute ] ) ? $ rules [ $ attribute ] : [ ] ; if ( in_array ( 'no_js_validation' , $ rules ) ) { $ validator -> setRules ( [ $ attribute => [ ] ] ) ; return ; } if ( ! $ validateAll ) { $ rules = $ this -> purgeNonRemoteRules ( $ rules , $ validator ) ; } $ validator -> setRules ( [ $ attribute => $ rules ] ) ; }
4608	public function createStatus ( string $ status , array $ options = null ) : array { $ url = '/statuses' ; if ( empty ( $ options ) ) { $ options = [ ] ; } $ params = array_merge ( [ 'status' => $ status , ] , $ options ) ; return $ this -> post ( $ url , $ params ) ; }
2789	public static function reconstructFromTokens ( array & $ tokens ) { $ str = '' ; foreach ( $ tokens as $ token ) { if ( is_string ( $ token ) ) { $ str .= $ token ; } else { $ str .= $ token [ 1 ] ; } } return $ str ; }
332	public function madd ( $ items , $ duration = 0 , $ dependency = null ) { return $ this -> multiAdd ( $ items , $ duration , $ dependency ) ; }
4774	public function build ( $ widgets , string $ widgetGroup = '' , array $ widgetId = [ ] ) { if ( ! $ widgets ) { return $ widgets ; } $ this -> loadUserConfig ( ) ; $ outputWidget = [ ] ; if ( $ widgetId ) { foreach ( $ widgetId as $ id ) { if ( isset ( $ widgets [ $ id ] ) ) { $ widgets [ $ id ] -> setActive ( $ this -> widgetConfig [ $ widget -> getId ( ) ] [ 'status' ] ?? false ) ; $ widgets [ $ id ] -> setConfig ( $ this -> widgetConfig [ $ widget -> getId ( ) ] ?? [ ] ) ; $ outputWidget [ ] = $ widgets [ $ id ] ; } } return $ outputWidget ; } foreach ( $ widgets as $ widget ) { if ( '' !== $ widgetGroup && $ widget -> getGroup ( ) !== $ widgetGroup ) { continue ; } if ( isset ( $ this -> widgetConfig [ $ widget -> getId ( ) ] [ 'order' ] ) ) { $ widget -> setOrder ( $ this -> widgetConfig [ $ widget -> getId ( ) ] [ 'order' ] ) ; } if ( null !== $ widget -> getOrder ( ) ) { while ( isset ( $ outputWidget [ $ widget -> getOrder ( ) ] ) ) { $ widget -> setOrder ( $ widget -> getOrder ( ) + 1 ) ; } $ outputWidget [ $ widget -> getOrder ( ) ] = $ widget ; } else { $ outputWidget [ ] = $ widget ; } $ widget -> setActive ( $ this -> widgetConfig [ $ widget -> getId ( ) ] [ 'status' ] ?? false ) ; $ widget -> setConfig ( $ this -> widgetConfig [ $ widget -> getId ( ) ] ?? [ ] ) ; } ksort ( $ outputWidget ) ; return $ outputWidget ; }
11239	public function run ( ) { if ( count ( $ this -> errors ) == 0 ) { return true ; } else { $ this -> controller -> setData ( 'errors' , $ this -> errors ) ; return false ; } }
8836	public function setMaxRetries ( $ retries ) { switch ( gettype ( $ retries ) ) { case 'integer' : $ this -> maxRetries = new Retries ( $ retries ) ; break ; case 'object' : $ this -> maxRetries = $ retries ; break ; default : throw new InvalidArgumentException ( 'Invalid type for max retries given.' ) ; break ; } }
5313	protected function getHTMLListFromGenerator ( IconFontGenerator $ generator , $ fontFile ) { $ fontOptions = $ generator -> getFont ( ) -> getOptions ( ) ; $ html = '<ul>' ; $ glyphNames = $ generator -> getGlyphNames ( ) ; asort ( $ glyphNames ) ; foreach ( $ glyphNames as $ unicode => $ glyph ) { $ html .= "\n\t" . '<li data-icon="&#x' . $ unicode . ';" title="' . htmlspecialchars ( $ glyph ) . '">' . htmlspecialchars ( $ glyph ) . '</li>' ; } $ html .= "\n" . '</ul>' . "\n" ; return $ html ; }
3876	private function getMetaModelsPages ( $ config , $ rootPage = null , $ language = null ) { $ metaModelsIdentifier = $ config [ 'pid' ] ; $ filterIdentifier = $ config [ 'filter' ] ; $ presetParams = StringUtil :: deserialize ( $ config [ 'filterparams' ] , true ) ; $ renderSettingId = $ config [ 'rendersetting' ] ; $ metaModels = $ this -> getMetaModel ( $ metaModelsIdentifier , false ) ; $ availableLanguages = $ this -> getLanguage ( $ language , $ metaModels ) ; $ currentLanguage = $ GLOBALS [ 'TL_LANGUAGE' ] ; foreach ( $ availableLanguages as $ newLanguage ) { $ GLOBALS [ 'TL_LANGUAGE' ] = $ newLanguage ; $ view = $ this -> getView ( $ metaModelsIdentifier , $ renderSettingId ) ; $ jumpTos = $ view -> get ( 'jumpTo' ) ; $ processed = $ this -> setFilterParameters ( $ filterIdentifier , $ presetParams , array ( ) ) ; $ filter = $ metaModels -> getEmptyFilter ( ) ; $ filterSetting = $ this -> getFilterSettings ( $ filterIdentifier ) ; $ filterSetting -> addRules ( $ filter , $ processed ) ; $ newEntries = $ this -> getJumpTosFor ( $ metaModels , $ filter , $ view , $ rootPage ) ; $ this -> removeEmptyDetailPages ( $ jumpTos ) ; $ GLOBALS [ 'TL_LANGUAGE' ] = $ currentLanguage ; $ this -> foundPages = array_merge ( $ this -> foundPages , $ newEntries ) ; } $ GLOBALS [ 'TL_LANGUAGE' ] = $ currentLanguage ; }
12391	public function setHydrator ( $ hydrator ) { if ( ! is_string ( $ hydrator ) && ! $ hydrator instanceof HydratorInterface ) { throw new Exception \ InvalidArgumentException ( sprintf ( '%s expects parameter 1 to be an object of instance Zend\Stdlib\Hydrator\HydratorInterface or string, %s provided instead' , __METHOD__ , is_object ( $ hydrator ) ? get_class ( $ hydrator ) : gettype ( $ hydrator ) ) ) ; } $ this -> hydrator = $ hydrator ; return $ this ; }
570	public function validateData ( $ data , $ key , $ rawHash = false ) { $ test = @ hash_hmac ( $ this -> macHash , '' , '' , $ rawHash ) ; if ( ! $ test ) { throw new InvalidConfigException ( 'Failed to generate HMAC with hash algorithm: ' . $ this -> macHash ) ; } $ hashLength = StringHelper :: byteLength ( $ test ) ; if ( StringHelper :: byteLength ( $ data ) >= $ hashLength ) { $ hash = StringHelper :: byteSubstr ( $ data , 0 , $ hashLength ) ; $ pureData = StringHelper :: byteSubstr ( $ data , $ hashLength , null ) ; $ calculatedHash = hash_hmac ( $ this -> macHash , $ pureData , $ key , $ rawHash ) ; if ( $ this -> compareString ( $ hash , $ calculatedHash ) ) { return $ pureData ; } } return false ; }
597	public function one ( $ db = null ) { $ row = parent :: one ( $ db ) ; if ( $ row !== false ) { $ models = $ this -> populate ( [ $ row ] ) ; return reset ( $ models ) ? : null ; } return null ; }
1302	public function getDefaultLocale ( ) : Locale { foreach ( $ this -> locales as $ locale ) { if ( $ locale -> isDefault ( ) ) { return $ locale ; } } throw new \ RuntimeException ( 'No locale marked as default exists in this environment.' ) ; }
3849	public function handle ( EncodePropertyValueFromWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) || ( $ event -> getProperty ( ) !== 'tableName' ) ) { return ; } $ tableName = strtolower ( $ event -> getValue ( ) ) ; if ( ! strlen ( $ tableName ) ) { throw new \ RuntimeException ( 'Table name not given' ) ; } if ( substr ( $ tableName , 0 , 3 ) !== 'mm_' ) { $ tableName = 'mm_' . $ tableName ; } $ dataProvider = $ event -> getEnvironment ( ) -> getDataProvider ( 'tl_metamodel' ) ; try { if ( ! $ event -> getModel ( ) -> getId ( ) ) { $ this -> tableManipulator -> checkTableDoesNotExist ( $ tableName ) ; } else { $ oldVersion = $ dataProvider -> fetch ( $ dataProvider -> getEmptyConfig ( ) -> setId ( $ event -> getModel ( ) -> getId ( ) ) ) ; if ( $ oldVersion -> getProperty ( 'tableName' ) !== $ event -> getModel ( ) -> getProperty ( 'tableName' ) ) { $ this -> tableManipulator -> checkTableDoesNotExist ( $ tableName ) ; } } } catch ( \ Exception $ exception ) { throw new \ RuntimeException ( $ exception -> getMessage ( ) , $ exception -> getCode ( ) , $ exception ) ; } $ event -> setValue ( $ tableName ) ; }
1201	public function isCurrent ( ItemInterface $ item ) { if ( null === $ this -> matcher ) { throw new \ BadMethodCallException ( 'The matcher must be set to get the breadcrumbs array' ) ; } return $ this -> matcher -> isCurrent ( $ item ) ; }
306	public function getSizeLimit ( ) { $ limit = $ this -> sizeToBytes ( ini_get ( 'upload_max_filesize' ) ) ; $ postLimit = $ this -> sizeToBytes ( ini_get ( 'post_max_size' ) ) ; if ( $ postLimit > 0 && $ postLimit < $ limit ) { Yii :: warning ( 'PHP.ini\'s \'post_max_size\' is less than \'upload_max_filesize\'.' , __METHOD__ ) ; $ limit = $ postLimit ; } if ( $ this -> maxSize !== null && $ limit > 0 && $ this -> maxSize < $ limit ) { $ limit = $ this -> maxSize ; } if ( isset ( $ _POST [ 'MAX_FILE_SIZE' ] ) && $ _POST [ 'MAX_FILE_SIZE' ] > 0 && $ _POST [ 'MAX_FILE_SIZE' ] < $ limit ) { $ limit = ( int ) $ _POST [ 'MAX_FILE_SIZE' ] ; } return $ limit ; }
10342	protected function isValidDate ( $ year , $ month , $ day ) { if ( $ month <= 0 || $ month > 12 || $ day <= 0 || $ day > 31 ) { return false ; } if ( ( $ month == 4 || $ month == 6 || $ month == 9 || $ month == 11 ) && ( $ day == 31 ) ) { return false ; } if ( $ month == 2 ) { if ( $ day > 29 ) { return false ; } $ leap = date ( 'L' , strtotime ( $ year . '-01-01' ) ) ; if ( $ leap === '0' && $ day > 28 ) { return false ; } } return true ; }
4394	public function capture ( \ Aimeos \ MShop \ Order \ Item \ Iface $ order ) { $ provider = $ this -> getProvider ( ) ; if ( ! $ provider -> supportsCapture ( ) ) { return ; } $ base = $ this -> getOrderBase ( $ order -> getBaseId ( ) ) ; $ data = array ( 'transactionReference' => $ this -> getTransactionReference ( $ base ) , 'currency' => $ base -> getPrice ( ) -> getCurrencyId ( ) , 'amount' => $ this -> getAmount ( $ base -> getPrice ( ) ) , 'transactionId' => $ order -> getId ( ) , ) ; $ response = $ provider -> capture ( $ data ) -> send ( ) ; if ( $ response -> isSuccessful ( ) ) { $ status = \ Aimeos \ MShop \ Order \ Item \ Base :: PAY_RECEIVED ; $ order -> setPaymentStatus ( $ status ) ; } }
10692	protected function getDialectStatement ( $ method , $ setTable = true ) { $ dialect = $ this -> getDialect ( ) ; if ( ! method_exists ( $ dialect , $ method ) ) { throw new BadMethodCallException ( Message :: get ( Message :: BUILDER_UNKNOWN_METHOD , $ method ) , Message :: BUILDER_UNKNOWN_METHOD ) ; } $ statement = call_user_func ( [ $ dialect , $ method ] , $ this ) ; if ( $ this -> hasPrevious ( ) ) { $ statement -> setPrevious ( $ this -> getPrevious ( ) ) ; $ this -> setPrevious ( null ) ; } elseif ( $ setTable && count ( $ this -> tables ) ) { if ( method_exists ( $ statement , 'from' ) ) { $ statement -> from ( $ this -> tables ) ; } else { $ statement -> into ( $ this -> tables [ array_keys ( $ this -> tables ) [ 0 ] ] ) ; } } return $ statement ; }
3314	protected function request ( $ url , $ images , array $ options = [ ] , $ requestType = false ) { $ http = ( new Http ) -> setHeaders ( [ 'Authorization' => $ this -> authorization -> getAuthorization ( ) ] ) ; $ image = is_array ( $ images ) ? $ images [ 0 ] : $ images ; $ urlName = $ requestType ? 'url_list' : 'url' ; if ( FileConverter :: isUrl ( $ image ) ) { $ isurl = true ; } else { $ isurl = false ; $ multiparts [ 'image' ] [ ] = $ image ; } $ options = $ this -> appendAppIdAndBucketIfEmpty ( $ options ) ; try { if ( $ isurl ) { $ response = $ http -> json ( $ url , array_merge ( $ options , [ $ urlName => $ image ] ) ) ; } else { $ response = $ http -> upload ( $ url , $ multiparts , $ options ) ; } } catch ( \ GuzzleHttp \ Exception \ ClientException $ e ) { if ( $ e -> hasResponse ( ) ) { $ response = $ e -> getResponse ( ) ; } } return $ http -> parseJson ( $ response ) ; }
6992	static protected function getCacheKeyForOptimizedUiTemplatesBasedOnUserId ( $ group ) : string { if ( static :: getAuthModule ( ) -> getAccessPolicyClassName ( ) === CmfAccessPolicy :: class ) { $ userId = 'any' ; } else { $ user = static :: getUser ( ) ; $ userId = $ user ? $ user -> getAuthIdentifier ( ) : 'not_authenticated' ; } return static :: url_prefix ( ) . '_templates_' . static :: getShortLocale ( ) . '_' . $ group . '_user_' . $ userId ; }
7499	protected function renderStringTemplate ( $ template , $ parameters = array ( ) ) { $ template = $ this -> environment -> createTemplate ( $ template ) ; return $ template -> render ( $ parameters ) ; }
5301	public function getCss ( ) { $ css = '' ; foreach ( $ this -> getGlyphNames ( ) as $ unicode => $ name ) { $ css .= ".icon-" . $ name . ":before {" . "\n" ; $ css .= "\tcontent: \"\\" . $ unicode . "\";\n" ; $ css .= "}\n" ; } return $ css ; }
2430	public function listStyleSheet ( $ row ) { $ cc = '' ; $ media = Contao \ StringUtil :: deserialize ( $ row [ 'media' ] ) ; if ( $ row [ 'cc' ] != '' ) { $ cc = ' &lt;!--[' . $ row [ 'cc' ] . ']&gt;' ; } if ( $ row [ 'mediaQuery' ] != '' ) { return '<div class="tl_content_left">' . $ row [ 'name' ] . ' <span style="color:#999;padding-left:3px">@media ' . $ row [ 'mediaQuery' ] . $ cc . '</span>' . "</div>\n" ; } elseif ( ! empty ( $ media ) && \ is_array ( $ media ) ) { return '<div class="tl_content_left">' . $ row [ 'name' ] . ' <span style="color:#999;padding-left:3px">@media ' . implode ( ', ' , $ media ) . $ cc . '</span>' . "</div>\n" ; } else { return '<div class="tl_content_left">' . $ row [ 'name' ] . $ cc . "</div>\n" ; } }
11519	protected function GenerateAndroidPinicon ( SiteConfig $ config , SiteTree $ owner , & $ metadata ) { $ metadata .= $ owner -> MarkupComment ( 'Android Pinned Icon' ) ; if ( $ config -> fetchAndroidPiniconThemeColor ( ) ) { $ metadata .= $ owner -> MarkupMeta ( 'theme-color' , $ config -> fetchAndroidPiniconThemeColor ( ) ) ; } $ metadata .= $ owner -> MarkupLink ( 'manifest' , '/manifest.json' ) ; }
491	public function via ( $ relationName , callable $ callable = null ) { $ relation = $ this -> primaryModel -> getRelation ( $ relationName ) ; $ callableUsed = $ callable !== null ; $ this -> via = [ $ relationName , $ relation , $ callableUsed ] ; if ( $ callable !== null ) { call_user_func ( $ callable , $ relation ) ; } return $ this ; }
5787	public function routeGetLogout ( Request $ request , Response $ response ) { $ this -> events -> setAdministratorId ( $ this -> authentication -> getAdministratorId ( ) ) ; if ( null === $ username = $ this -> authentication -> getAdministratorUsername ( ) ) { $ this -> events -> insertWarning ( EVENT_LOGOUT_FAULT ) ; } else { $ this -> events -> insertInfo ( EVENT_LOGOUT ) ; $ this -> authentication -> logout ( ) ; } return $ response -> withRedirect ( $ this -> router -> pathFor ( ROUTE_HOME ) ) ; }
7211	public function validateLoginToken ( string $ token ) : ? array { $ token = base64_decode ( $ token ) ; $ serializedData = Security :: decrypt ( $ token , $ this -> getKey ( ) , $ this -> getSalt ( ) ) ; if ( $ serializedData === false ) { return null ; } $ data = unserialize ( $ serializedData ) ; if ( ! empty ( $ data [ 'expireInterval' ] ) && ! empty ( $ data [ 'timestamp' ] ) ) { $ tokenCreated = new Time ( $ data [ 'timestamp' ] ) ; if ( ! $ tokenCreated -> wasWithinLast ( $ data [ 'expireInterval' ] ) ) { return null ; } } return $ data ; }
5138	public static function handleException ( \ Throwable $ e ) { if ( php_sapi_name ( ) == 'cli' ) { $ handler = new ConsoleHandler ( self :: $ output ) ; } else { $ handler = new HtmlHandler ( HtmlHandler :: INVERTED ) ; } fwrite ( self :: $ output , $ handler -> renderException ( $ e , AbstractHandler :: VERBOSITY_VERBOSE ) ) ; }
11326	public static function removeSuffix ( $ string , $ suffix ) { if ( static :: hasSuffix ( $ string , $ suffix ) ) { return substr ( $ string , 0 , - strlen ( $ suffix ) ) ; } return $ string ; }
2016	public function generateMarkup ( ) { $ return = ' <div> <input type="file" name="' . $ this -> strName . '[]" class="tl_upload_field" onfocus="Backend.getScrollOffset()" multiple required> </div>' ; if ( isset ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_files' ] [ 'fileupload' ] [ 1 ] ) ) { $ return .= ' <p class="tl_help tl_tip">' . sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_files' ] [ 'fileupload' ] [ 1 ] , System :: getReadableSize ( static :: getMaxUploadSize ( ) ) , Config :: get ( 'gdMaxImgWidth' ) . 'x' . Config :: get ( 'gdMaxImgHeight' ) ) . '</p>' ; } return $ return ; }
6496	public function getCurrentId ( ) { $ args = arg ( ) ; return count ( $ args ) > 1 && $ this -> entityType ( ) === $ args [ 0 ] && $ args [ 1 ] > 0 ? ( int ) $ args [ 1 ] : 0 ; }
10109	private function writeMergedCells ( ) { $ mergeCells = $ this -> phpSheet -> getMergeCells ( ) ; $ countMergeCells = count ( $ mergeCells ) ; if ( $ countMergeCells == 0 ) { return ; } $ maxCountMergeCellsPerRecord = 1027 ; $ record = 0x00E5 ; $ i = 0 ; $ j = 0 ; $ recordData = '' ; foreach ( $ mergeCells as $ mergeCell ) { ++ $ i ; ++ $ j ; $ range = Coordinate :: splitRange ( $ mergeCell ) ; list ( $ first , $ last ) = $ range [ 0 ] ; list ( $ firstColumn , $ firstRow ) = Coordinate :: coordinateFromString ( $ first ) ; list ( $ lastColumn , $ lastRow ) = Coordinate :: coordinateFromString ( $ last ) ; $ recordData .= pack ( 'vvvv' , $ firstRow - 1 , $ lastRow - 1 , Coordinate :: columnIndexFromString ( $ firstColumn ) - 1 , Coordinate :: columnIndexFromString ( $ lastColumn ) - 1 ) ; if ( $ j == $ maxCountMergeCellsPerRecord or $ i == $ countMergeCells ) { $ recordData = pack ( 'v' , $ j ) . $ recordData ; $ length = strlen ( $ recordData ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ this -> append ( $ header . $ recordData ) ; $ recordData = '' ; $ j = 0 ; } } }
6618	protected function parseEndpointName ( $ method , $ endpoint ) { $ endpoint = str_replace ( ' ' , '' , ucwords ( str_replace ( [ '-' , '+' , '%20' ] , ' ' , $ endpoint ) ) ) ; $ method = strtolower ( $ method ) ; return $ method . $ endpoint . 'Endpoint' ; }
4641	private function buildCallback ( BuildInfo $ output ) { $ message = "" ; if ( $ output -> getError ( ) ) { $ this -> logger -> error ( sprintf ( "Error when creating job: %s\n" , $ output -> getError ( ) ) , array ( 'static' => false , 'static-id' => null ) ) ; return ; } if ( $ output -> getStream ( ) ) { $ message = $ output -> getStream ( ) ; } if ( $ output -> getStatus ( ) ) { $ message = $ output -> getStatus ( ) ; if ( $ output -> getProgress ( ) ) { $ message .= " " . $ output -> getProgress ( ) ; } } if ( ! $ output -> getId ( ) && ! preg_match ( '#\n#' , $ message ) ) { $ message .= "\n" ; } $ this -> logger -> debug ( $ message , array ( 'static' => $ output -> getId ( ) !== null , 'static-id' => $ output -> getId ( ) , ) ) ; }
7856	private function publishConfig ( ) { $ config = __DIR__ . '/config/workflow.php' ; $ this -> publishes ( [ $ config => config_path ( 'workflow.php' ) ] ) ; $ this -> mergeConfigFrom ( $ config , 'workflow' ) ; }
4942	public function fileCountValidationCallback ( ) { if ( $ this -> form && ( $ object = $ this -> form -> getObject ( ) ) ) { if ( $ this -> getMaxFileCount ( ) - 1 < count ( $ object ) ) { return false ; } } return true ; }
1720	private function getChunksFromUnit ( \ DOMElement $ unit ) : array { $ chunks = explode ( '.' , $ unit -> getAttribute ( 'id' ) ) ; if ( preg_match ( '/tl_layout\.[a-z]+\.css\./' , $ unit -> getAttribute ( 'id' ) ) ) { $ chunks = [ $ chunks [ 0 ] , $ chunks [ 1 ] . '.' . $ chunks [ 2 ] , $ chunks [ 3 ] ] ; } return $ chunks ; }
10377	protected static function prepare_files ( $ type ) { $ params [ 'type' ] = $ type ; $ params [ 'routes' ] = self :: get_routes_to_folder ( $ type ) ; self :: get_processed_files ( ) ; foreach ( self :: $ data [ $ type ] as $ id => $ file ) { $ path = self :: get_path_from_url ( $ file [ 'url' ] ) ; $ params [ 'files' ] [ $ id ] = basename ( $ file [ 'url' ] ) ; $ params [ 'urls' ] [ $ id ] = $ file [ 'url' ] ; $ params [ 'paths' ] [ $ id ] = $ path ; if ( is_file ( $ path ) && self :: is_modified_file ( $ path ) ) { unset ( $ params [ 'urls' ] [ $ id ] ) ; continue ; } $ path = $ params [ 'routes' ] [ 'path' ] . $ params [ 'files' ] [ $ id ] ; if ( is_file ( $ path ) ) { if ( self :: is_modified_hash ( $ file [ 'url' ] , $ path ) ) { continue ; } $ params [ 'paths' ] [ $ id ] = $ path ; } elseif ( self :: is_external_url ( $ file [ 'url' ] ) ) { continue ; } unset ( $ params [ 'urls' ] [ $ id ] ) ; } return $ params ; }
6899	public function regenerate ( $ delete_old = false ) { if ( $ this -> is_active ( ) ) { @ session_regenerate_id ( $ delete_old ) ; } else { $ this -> open ( ) ; } return session_id ( ) ; }
6720	public function authorize ( ) { $ this -> validateAuthParams ( ) ; try { $ response = $ this -> curl -> setOption ( CURLOPT_POSTFIELDS , http_build_query ( array ( 'grant_type' => self :: GRANT_TYPE_AUTHORIZATION_CODE , 'client_id' => $ this -> clientId , 'client_secret' => $ this -> clientSecret , 'response_type' => self :: RESPONSE_TYPE_CODE , 'state' => self :: STATE_ALIVE ) ) ) -> post ( $ this -> authUrl , false ) ; } catch ( InvalidParamException $ invalidParamException ) { throw new Oauth2ClientException ( $ invalidParamException -> getMessage ( ) ) ; } return $ this -> handleAuthorizeResponse ( $ response ) ; }
12582	public function setTranslator ( $ translator , $ translatorDomain = null , $ translatorLocale = null ) { $ this -> translator = $ translator ; $ this -> setTranslatorDomain ( $ translatorDomain ) ; $ this -> setTranslatorLocale ( $ translatorLocale ) ; $ this -> setCaption ( $ this -> translate ( $ this -> getCaption ( ) ) ) ; }
8715	public function getAccessToken ( ) : ApiAccessToken { try { $ accessToken = $ this -> tokenStorage -> getAccessToken ( ) ; } catch ( UnableToAcquireAccessToken $ e ) { $ accessToken = null ; } if ( $ accessToken && $ accessToken -> isExpired ( ) ) { $ this -> tokenStorage -> unsetAccessToken ( ) ; $ accessToken = null ; } return $ accessToken ? : $ this -> refreshToken ( ) ; }
10844	protected function calculateAttributePrice ( VariantInterface $ variant , $ amount ) { $ modifierType = $ variant -> getModifierType ( ) ; $ modifierValue = $ variant -> getModifierValue ( ) ; switch ( $ modifierType ) { case '+' : $ amount = $ amount + $ modifierValue ; break ; case '-' : $ amount = $ amount - $ modifierValue ; break ; case '%' : $ amount = $ amount * ( $ modifierValue / 100 ) ; break ; } return round ( $ amount , 2 ) ; }
5562	protected function parse ( $ response , $ depth = 0 ) { $ page = $ this -> buildPage ( $ response ) ; if ( $ this -> ignore_frames || ! $ page -> hasFrames ( ) || ( $ depth > $ this -> maximum_nested_frames ) ) { return $ page ; } $ frameset = new SimpleFrameset ( $ page ) ; foreach ( $ page -> getFrameset ( ) as $ key => $ url ) { $ frame = $ this -> fetch ( $ url , new SimpleGetEncoding ( ) , $ depth + 1 ) ; $ frameset -> addFrame ( $ frame , $ key ) ; } return $ frameset ; }
3897	public function pagePicker ( ManipulateWidgetEvent $ event ) { if ( ! $ this -> scopeDeterminator -> currentScopeIsBackend ( ) || ! ( 'tl_metamodel_rendersettings' === $ event -> getEnvironment ( ) -> getDataDefinition ( ) -> getName ( ) ) || ! ( ( 0 === strpos ( $ event -> getProperty ( ) -> getName ( ) , 'jumpTo' ) ) && ( '[value]' === substr ( $ event -> getProperty ( ) -> getName ( ) , - \ strlen ( '[value]' ) ) ) ) ) { return ; } $ environment = $ event -> getEnvironment ( ) ; $ pickerUrl = $ this -> pickerBuilder -> getUrl ( 'cca_link' ) ; $ urlEvent = new GenerateHtmlEvent ( 'pickpage.svg' , $ environment -> getTranslator ( ) -> translate ( 'MSC.pagepicker' ) , 'style="vertical-middle:top;cursor:pointer"' ) ; $ environment -> getEventDispatcher ( ) -> dispatch ( ContaoEvents :: IMAGE_GET_HTML , $ urlEvent ) ; $ template = new ContaoBackendViewTemplate ( 'dc_general_wizard_link_url_picker' ) ; $ template -> set ( 'name' , $ event -> getWidget ( ) -> name ) -> set ( 'popupUrl' , $ pickerUrl ) -> set ( 'html' , ' ' . $ urlEvent -> getHtml ( ) ) -> set ( 'label' , $ event -> getProperty ( ) -> getLabel ( ) [ 1 ] ) -> set ( 'id' , $ event -> getWidget ( ) -> id ) ; $ event -> getWidget ( ) -> wizard = $ template -> parse ( ) ; }
4191	protected function dumpMethodParams ( $ params ) { $ paramStr = '' ; foreach ( $ params as $ info ) { $ paramStr .= '<span class="parameter">' ; if ( ! empty ( $ info [ 'type' ] ) ) { $ paramStr .= '<span class="t_type">' . $ info [ 'type' ] . '</span> ' ; } $ paramStr .= '<span class="t_parameter-name"' . ' title="' . \ htmlspecialchars ( $ info [ 'desc' ] ) . '"' . '>' . \ htmlspecialchars ( $ info [ 'name' ] ) . '</span>' ; if ( $ info [ 'defaultValue' ] !== $ this -> debug -> abstracter -> UNDEFINED ) { $ defaultValue = $ info [ 'defaultValue' ] ; $ paramStr .= ' <span class="t_operator">=</span> ' ; if ( $ info [ 'constantName' ] ) { $ title = '' ; $ type = $ this -> debug -> abstracter -> getType ( $ defaultValue ) ; if ( ! \ in_array ( $ type , array ( 'array' , 'resource' ) ) ) { $ title = $ this -> debug -> output -> text -> dump ( $ defaultValue ) ; $ title = \ htmlspecialchars ( 'value: ' . $ title ) ; } $ paramStr .= '<span class="t_parameter-default t_const"' . ' title="' . $ title . '"' . '>' . $ info [ 'constantName' ] . '</span>' ; } else { if ( \ is_string ( $ defaultValue ) ) { $ defaultValue = \ str_replace ( "\n" , ' ' , $ defaultValue ) ; } $ parsed = $ this -> debug -> utilities -> parseTag ( $ this -> debug -> output -> html -> dump ( $ defaultValue ) ) ; $ class = \ trim ( 't_parameter-default ' . $ parsed [ 'attribs' ] [ 'class' ] ) ; $ paramStr .= '<span class="' . $ class . '">' . $ parsed [ 'innerhtml' ] . '</span>' ; } } $ paramStr .= '</span>, ' ; } $ paramStr = \ trim ( $ paramStr , ', ' ) ; return $ paramStr ; }
12246	static public function sort ( array & $ nodes ) { $ args = func_get_args ( ) ; unset ( $ args [ 0 ] ) ; $ sort = array ( ) ; $ tmp = array ( ) ; foreach ( $ args as $ k => $ arg ) { if ( is_string ( $ arg ) ) { $ tmp [ $ k ] = array ( ) ; if ( preg_match ( '#^@?[a-z_0-9]+$#Di' , $ arg ) ) { if ( $ arg [ 0 ] === '@' ) { $ name = substr ( $ arg , 1 ) ; foreach ( $ nodes as $ node ) { $ tmp [ $ k ] [ ] = ( string ) $ node [ $ name ] ; } } else { foreach ( $ nodes as $ node ) { $ tmp [ $ k ] [ ] = ( string ) $ node -> $ arg ; } } } elseif ( preg_match ( '#^current\\(\\)|text\\(\\)|\\.$#i' , $ arg ) ) { foreach ( $ nodes as $ node ) { $ tmp [ $ k ] [ ] = dom_import_simplexml ( $ node ) -> textContent ; } } else { foreach ( $ nodes as $ node ) { $ _nodes = $ node -> xpath ( $ arg ) ; $ tmp [ $ k ] [ ] = ( empty ( $ _nodes ) ) ? '' : ( string ) $ _nodes [ 0 ] ; } } } else { $ tmp [ $ k ] = $ arg ; } $ sort [ ] = & $ tmp [ $ k ] ; } $ sort [ ] = & $ nodes ; call_user_func_array ( 'array_multisort' , $ sort ) ; }
4617	public function buildLocalhost ( array $ ports = [ 8087 ] ) { $ nodes = [ ] ; $ this -> atHost ( 'localhost' ) ; foreach ( $ ports as $ port ) { $ nodes [ ] = $ this -> onPort ( $ port ) -> build ( ) ; } return $ nodes ; }
5428	public function getInterfaceMethods ( ) { $ methods = array ( ) ; $ interfaces = $ this -> getInterfaces ( ) ; foreach ( $ interfaces as $ interface ) { $ methods = array_merge ( $ methods , get_class_methods ( $ interface ) ) ; } return array_unique ( $ methods ) ; }
5613	public function paintFail ( $ message ) { parent :: paintFail ( $ message ) ; $ node = new TreemapNode ( 'Assertion' , $ message , false ) ; $ current = $ this -> _stack -> peek ( ) ; $ current -> putChild ( $ node ) ; $ current -> fail ( ) ; }
8571	public function listRecommendations ( $ request ) { if ( ! ( $ request instanceof MWSRecommendationsSectionService_Model_ListRecommendationsRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/ListRecommendationsRequest.php' ) ; $ request = new MWSRecommendationsSectionService_Model_ListRecommendationsRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListRecommendations' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/ListRecommendationsResponse.php' ) ; $ response = MWSRecommendationsSectionService_Model_ListRecommendationsResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
12721	public function isShared ( $ abstract ) { if ( ! isset ( $ this -> bindings [ $ abstract ] ) ) { throw Internal \ Exception \ ReflectionExceptionFactory :: invalidArgument ( sprintf ( "Parameter 1 of %s must be valid keys in binding container stack." , __METHOD__ ) ) ; } return ( $ this -> bindings [ $ abstract ] [ 'shared' ] ? true : false ) ; }
7043	public function handleSrcTableNames ( GetPropertyOptionsEvent $ event ) { if ( ( $ event -> getPropertyName ( ) !== 'tag_srctable' ) || ( $ event -> getEnvironment ( ) -> getDataDefinition ( ) -> getName ( ) !== 'tl_metamodel_attribute' ) ) { return ; } $ sqlTable = $ this -> translator -> trans ( 'tl_metamodel_attribute.tag_table_type.sql-table' , [ ] , 'contao_tl_metamodel_attribute' ) ; $ translated = $ this -> translator -> trans ( 'tl_metamodel_attribute.tag_table_type.translated' , [ ] , 'contao_tl_metamodel_attribute' ) ; $ untranslated = $ this -> translator -> trans ( 'tl_metamodel_attribute.tag_table_type.untranslated' , [ ] , 'contao_tl_metamodel_attribute' ) ; $ result = $ this -> getMetaModelTableNames ( $ translated , $ untranslated ) ; foreach ( $ this -> connection -> getSchemaManager ( ) -> listTableNames ( ) as $ table ) { if ( 0 !== \ strpos ( $ table , 'mm_' ) ) { $ result [ $ sqlTable ] [ $ table ] = $ table ; } } if ( \ is_array ( $ result [ $ translated ] ) ) { \ asort ( $ result [ $ translated ] ) ; } if ( \ is_array ( $ result [ $ untranslated ] ) ) { \ asort ( $ result [ $ untranslated ] ) ; } if ( \ is_array ( $ result [ $ sqlTable ] ) ) { \ asort ( $ result [ $ sqlTable ] ) ; } $ event -> setOptions ( $ result ) ; }
972	public function forget ( ) { $ keys = [ self :: DOMAIN , self :: USER , self :: TOKEN ] ; foreach ( $ keys as $ key ) { Session :: forget ( $ key ) ; } }
9300	public function setOptions ( array $ options ) { if ( ! array_key_exists ( 'options' , $ options ) ) { $ options [ 'options' ] = array ( ) ; } $ this -> options = array_merge ( $ this -> getDefaultOptions ( ) , $ options [ 'options' ] ) ; return $ this ; }
12605	public static function getName ( $ file ) { $ file = str_replace ( '\\' , '/' , $ file ) ; $ slash = strrpos ( $ file , '/' ) ; if ( $ slash !== false ) { return substr ( $ file , $ slash + 1 ) ; } return $ file ; }
2679	public function queryHistoricStats ( array $ parameters ) { $ uri = $ this -> _getHistoricalEndpoint ( ) . '?region=' . $ parameters [ 'region' ] . '&from=' . $ parameters [ 'from' ] . '&to=' . $ parameters [ 'to' ] . '&by=' . $ parameters [ 'sample_rate' ] ; $ result = $ this -> _fetch ( $ uri ) ; return $ result ; }
6584	public function sum ( $ n , $ m = 0 ) { if ( $ m > 0 ) return $ this -> sum ( $ n + $ m ) - $ this -> sum ( $ m ) ; static :: ensureValid ( $ n ) ; return $ this -> b * ( 1 - pow ( $ this -> q , $ n ) ) / ( 1 - $ this -> q ) ; }
8215	protected function getServerStats ( $ pattern = '' ) { $ stats = ( array ) $ this -> getPheanstalk ( ) -> stats ( ) ; if ( ! empty ( $ pattern ) ) { $ stats = array_filter ( $ stats , function ( $ key ) use ( $ pattern ) { return 1 === preg_match ( "/$pattern/i" , $ key ) ; } , ARRAY_FILTER_USE_KEY ) ; } ksort ( $ stats ) ; return $ stats ; }
10852	public function echo ( $ type , $ content ) { if ( $ this -> option ( 'debug' ) == false ) { return ; } if ( trim ( $ content ) ) { $ this -> { $ type } ( $ content ) ; } }
5657	private function createEmptyForm ( $ node ) { return new SimpleForm ( $ this -> tags ( ) -> createTag ( $ node -> name , ( array ) $ node -> attribute ) , $ this -> page ) ; }
4601	public function kernelRequest ( GetResponseEvent $ event ) { $ request = $ event -> getRequest ( ) ; if ( ! $ request -> isMethod ( Request :: METHOD_PUT ) ) { return ; } if ( ! $ request -> attributes -> has ( 'data' ) ) { return ; } $ data = $ request -> attributes -> get ( 'data' ) ; if ( ! $ data instanceof Access ) { return ; } $ access = $ data ; $ manager = $ this -> accessService -> getManager ( ) ; foreach ( $ access -> getPermissions ( ) as $ permission ) { $ manager -> remove ( $ permission ) ; } $ manager -> flush ( ) ; }
1604	public function onException ( ExceptionEvent $ event ) { $ exception = $ event -> exception ; $ craft = \ Craft :: $ app ; if ( ! ( $ exception instanceof HttpException ) || $ exception -> statusCode !== 404 ) return ; $ path = $ craft -> request -> getFullPath ( ) ; $ query = $ craft -> request -> getQueryStringWithoutPath ( ) ; if ( $ query ) $ path .= '?' . $ query ; if ( $ redirect = $ this -> findRedirectByPath ( $ path ) ) { $ event -> handled = true ; $ craft -> response -> redirect ( $ redirect [ 'to' ] , $ redirect [ 'type' ] ) -> send ( ) ; $ craft -> end ( ) ; } }
2864	public function getLastFilePosition ( $ filePath ) { if ( ! file_exists ( $ filePath ) ) { return 0 ; } $ f = fopen ( $ filePath , 'r' ) ; fseek ( $ f , - 1 , SEEK_END ) ; return ftell ( $ f ) ; }
4678	public function render ( string $ file , array $ data ) : void { if ( ! is_readable ( $ file ) ) { throw new Exception ( "Could not find template file: " . $ this -> template ) ; } $ di = $ this -> di ; $ app = null ; if ( $ di -> has ( "app" ) ) { $ app = $ di -> get ( "app" ) ; } extract ( $ data ) ; require $ file ; }
4817	public function insertRowBefore ( $ rowNumber , $ row = null ) { if ( $ rowNumber > count ( $ this -> collection ) ) { $ this -> appendRow ( $ row ) ; } else { $ singleRow = $ row ; if ( ! ( $ row instanceof Row ) ) { $ singleRow = new Row ( $ row ) ; } array_splice ( $ this -> collection , $ rowNumber , 0 , '' ) ; $ this -> collection [ $ rowNumber ] = $ singleRow ; } }
8024	public function destroy ( ) { if ( ! is_resource ( $ this -> semaphore ) ) { throw new SemaphoreException ( 'Semaphore hasn\'t yet been created.' ) ; } if ( ! sem_remove ( $ this -> semaphore ) ) { throw new SemaphoreException ( 'Cannot remove the semaphore.' ) ; } $ this -> semaphore = NULL ; $ this -> semKey = NULL ; return $ this ; }
124	protected function getErrorMessage ( $ retval , $ file ) { switch ( $ retval ) { case ZipArchive :: ER_EXISTS : return sprintf ( "File '%s' already exists." , $ file ) ; case ZipArchive :: ER_INCONS : return sprintf ( "Zip archive '%s' is inconsistent." , $ file ) ; case ZipArchive :: ER_INVAL : return sprintf ( "Invalid argument (%s)" , $ file ) ; case ZipArchive :: ER_MEMORY : return sprintf ( "Malloc failure (%s)" , $ file ) ; case ZipArchive :: ER_NOENT : return sprintf ( "No such zip file: '%s'" , $ file ) ; case ZipArchive :: ER_NOZIP : return sprintf ( "'%s' is not a zip archive." , $ file ) ; case ZipArchive :: ER_OPEN : return sprintf ( "Can't open zip file: %s" , $ file ) ; case ZipArchive :: ER_READ : return sprintf ( "Zip read error (%s)" , $ file ) ; case ZipArchive :: ER_SEEK : return sprintf ( "Zip seek error (%s)" , $ file ) ; default : return sprintf ( "'%s' is not a valid zip archive, got error code: %s" , $ file , $ retval ) ; } }
3064	protected function storeResult ( array $ results ) { $ runnerService = $ this -> getServiceLocator ( ) -> get ( QtiRunnerService :: SERVICE_ID ) ; $ success = true ; try { foreach ( $ results as $ result ) { if ( ! $ result instanceof AbstractResult ) { throw new \ common_Exception ( __FUNCTION__ . ' requires a CAT result to store it.' ) ; } $ variables = $ this -> convertCatVariables ( $ result -> getVariables ( ) ) ; if ( empty ( $ variables ) ) { \ common_Logger :: t ( 'No Cat result variables to store.' ) ; continue ; } if ( $ result instanceof ItemResult ) { $ itemId = $ result -> getItemRefId ( ) ; $ itemUri = $ this -> getItemUriFromRefId ( $ itemId ) ; } else { $ itemUri = $ itemId = null ; $ sectionId = $ this -> getTestSession ( ) -> getRoute ( ) -> current ( ) -> getAssessmentSection ( ) -> getIdentifier ( ) ; foreach ( $ variables as $ variable ) { $ variable -> setIdentifier ( $ sectionId . '-' . $ variable -> getIdentifier ( ) ) ; } } if ( ! $ runnerService -> storeVariables ( $ this , $ itemUri , $ variables , $ itemId ) ) { $ success = false ; } } } catch ( \ Exception $ e ) { \ common_Logger :: w ( 'An error has occurred during CAT result storing: ' . $ e -> getMessage ( ) ) ; $ success = false ; } return $ success ; }
780	public function getValue ( $ name , $ defaultValue = null ) { return isset ( $ this -> _cookies [ $ name ] ) ? $ this -> _cookies [ $ name ] -> value : $ defaultValue ; }
2977	public function unserialize ( $ serialized ) { $ this -> data = unserialize ( $ serialized ) ; $ this -> closure = __reconstruct_closure ( $ this -> data ) ; if ( ! $ this -> closure instanceof Closure ) { throw new ClosureUnserializationException ( 'The closure is corrupted and cannot be unserialized.' ) ; } if ( $ this -> data [ 'binding' ] || $ this -> data [ 'isStatic' ] ) { $ this -> closure = $ this -> closure -> bindTo ( $ this -> data [ 'binding' ] , $ this -> data [ 'scope' ] ) ; } }
8423	public function mappings ( Request $ request ) { $ table = new \ cli \ Table ( ) ; $ table -> setHeaders ( [ 'Mapping' , 'Database' , 'Models path' ] ) ; $ rows = [ ] ; $ mappings = Mapping :: getMappings ( ) ; usort ( $ mappings , function ( array $ a , array $ b ) { return strcmp ( $ a [ 'config' ] [ 'name' ] , $ b [ 'config' ] [ 'name' ] ) ; } ) ; foreach ( $ mappings as $ mapping ) { $ rows [ ] = [ $ mapping [ 'config' ] [ 'name' ] , $ mapping [ 'config' ] [ 'database' ] , $ mapping [ 'config' ] [ 'models' ] [ 'path' ] , ] ; } $ table -> setRows ( $ rows ) ; $ table -> display ( ) ; }
12302	public function getChild ( $ id , $ relation , $ idChild , $ filters = null ) { $ parent = $ this -> model -> find ( $ id ) ; if ( ! $ parent ) { return null ; } if ( count ( $ filters -> request -> all ( ) ) > 0 ) { $ child = $ parent -> $ relation ( ) -> getRelated ( ) ; $ search = new Search ( $ child , $ filters , $ parent -> $ relation ( ) ) ; $ this -> builder = $ search -> getBuilder ( ) ; $ this -> builder -> select ( "{$child->getTable()}.*" ) ; if ( $ parent -> $ relation ( ) instanceof \ Illuminate \ Database \ Eloquent \ Relations \ BelongsToMany ) { $ this -> builder -> where ( $ parent -> $ relation ( ) -> getOtherKey ( ) , $ idChild ) ; } $ resource = $ this -> builder -> get ( ) ; } else { $ resource = $ parent -> $ relation ( ) -> find ( $ idChild ) ; } return $ resource ; }
4724	public function render ( ) { $ html = new Text ( ) ; $ html -> append ( '<' ) -> append ( $ this -> getName ( ) ) ; foreach ( $ this -> attributes as $ name => $ value ) { $ html -> append ( ' ' ) -> append ( $ name ) -> append ( '=' ) -> append ( '"' ) -> append ( $ value ) -> append ( '"' ) ; } if ( $ this -> text -> isEmpty ( ) ) { if ( $ this -> type == self :: TYPE_BLOCK ) { return ( string ) $ html -> append ( '>' ) -> append ( '</' ) -> append ( $ this -> getName ( ) ) -> append ( '>' ) ; } else { return ( string ) $ html -> append ( $ this -> emptyTagSuffix ) ; } } return ( string ) $ html -> append ( '>' ) -> append ( $ this -> text ) -> append ( '</' ) -> append ( $ this -> getName ( ) ) -> append ( '>' ) ; }
9909	public function setPositionXL ( $ positionXL ) { if ( ! isset ( self :: $ positionXLref [ $ positionXL ] ) ) { return false ; } $ this -> position = self :: $ positionXLref [ $ positionXL ] ; return true ; }
9237	private function getAmbiguityExceptionMessage ( array $ paths , Vertex $ startVertex , Vertex $ endVertex ) { $ textPaths = [ ] ; $ i = 1 ; foreach ( $ paths as $ path ) { $ textPaths [ ] = 'Path ' . $ i . ': ' . $ this -> getTextualPath ( $ path , $ startVertex ) ; ++ $ i ; } $ msg = sprintf ( "There are many possible shortest paths between table '%s' and table '%s'\n\n" , $ startVertex -> getId ( ) , $ endVertex -> getId ( ) ) ; $ msg .= implode ( "\n\n" , $ textPaths ) ; return $ msg ; }
10147	private function readPalette ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; if ( ! $ this -> readDataOnly ) { $ nm = self :: getUInt2d ( $ recordData , 0 ) ; for ( $ i = 0 ; $ i < $ nm ; ++ $ i ) { $ rgb = substr ( $ recordData , 2 + 4 * $ i , 4 ) ; $ this -> palette [ ] = self :: readRGB ( $ rgb ) ; } } }
8014	protected function prepareCommand ( $ filename , $ saveToFile , $ pdfIsTemp = false ) { $ resultIsTemp = false ; $ command = new Command ( ) ; $ command -> setPdfFile ( $ filename , $ pdfIsTemp ) ; if ( $ saveToFile === null ) { $ saveToFile = tempnam ( sys_get_temp_dir ( ) , 'pdfbox' ) ; $ resultIsTemp = true ; } $ command -> setTextFile ( $ saveToFile , $ resultIsTemp ) ; return $ command ; }
2708	public function afterSave ( \ Magento \ Config \ Model \ Config $ subject ) { if ( $ this -> purge ) { $ this -> api -> cleanBySurrogateKey ( [ 'text' ] ) ; } }
10075	public static function controlCharacterOOXML2PHP ( $ value ) { self :: buildCharacterSets ( ) ; return str_replace ( array_keys ( self :: $ controlCharacters ) , array_values ( self :: $ controlCharacters ) , $ value ) ; }
5087	public function commit ( ) : bool { if ( ! $ this -> isInTransaction ) throw new NotInTransactionException ( ) ; $ this -> isInTransaction = false ; return $ this -> executeDirect ( 'COMMIT' ) ; }
5444	protected function reduce ( $ raw ) { if ( $ action = $ this -> regexes [ $ this -> mode -> getCurrent ( ) ] -> match ( $ raw , $ match ) ) { $ unparsed_character_count = strpos ( $ raw , $ match ) ; $ unparsed = substr ( $ raw , 0 , $ unparsed_character_count ) ; $ raw = substr ( $ raw , $ unparsed_character_count + strlen ( $ match ) ) ; return array ( $ raw , $ unparsed , $ match , $ action ) ; } return true ; }
7604	protected function renderAddOn ( $ aAddOnOptions ) { if ( empty ( $ aAddOnOptions ) ) { throw new InvalidArgumentException ( 'Addon options are empty' ) ; } if ( $ aAddOnOptions instanceof ElementInterface ) { $ aAddOnOptions = array ( 'element' => $ aAddOnOptions ) ; } elseif ( is_scalar ( $ aAddOnOptions ) ) { $ aAddOnOptions = array ( 'text' => $ aAddOnOptions ) ; } elseif ( ! is_array ( $ aAddOnOptions ) ) { throw new InvalidArgumentException ( sprintf ( 'Addon options expects an array or a scalar value, "%s" given' , is_object ( $ aAddOnOptions ) ? get_class ( $ aAddOnOptions ) : gettype ( $ aAddOnOptions ) ) ) ; } $ sMarkup = '' ; $ sAddonTagName = 'span' ; $ sAddonClass = '' ; if ( ! empty ( $ aAddOnOptions [ 'text' ] ) ) { if ( ! is_scalar ( $ aAddOnOptions [ 'text' ] ) ) { throw new InvalidArgumentException ( sprintf ( '"text" option expects a scalar value, "%s" given' , is_object ( $ aAddOnOptions [ 'text' ] ) ? get_class ( $ aAddOnOptions [ 'text' ] ) : gettype ( $ aAddOnOptions [ 'text' ] ) ) ) ; } elseif ( ( $ oTranslator = $ this -> getTranslator ( ) ) ) { $ sMarkup .= $ oTranslator -> translate ( $ aAddOnOptions [ 'text' ] , $ this -> getTranslatorTextDomain ( ) ) ; } else { $ sMarkup .= $ aAddOnOptions [ 'text' ] ; } $ sAddonClass .= ' input-group-addon' ; } elseif ( ! empty ( $ aAddOnOptions [ 'element' ] ) ) { if ( is_array ( $ aAddOnOptions [ 'element' ] ) || ( $ aAddOnOptions [ 'element' ] instanceof Traversable && ! ( $ aAddOnOptions [ 'element' ] instanceof ElementInterface ) ) ) { $ oFactory = new Factory ( ) ; $ aAddOnOptions [ 'element' ] = $ oFactory -> create ( $ aAddOnOptions [ 'element' ] ) ; } elseif ( ! ( $ aAddOnOptions [ 'element' ] instanceof ElementInterface ) ) { throw new LogicException ( sprintf ( '"element" option expects an instanceof Zend\Form\ElementInterface, "%s" given' , is_object ( $ aAddOnOptions [ 'element' ] ) ? get_class ( $ aAddOnOptions [ 'element' ] ) : gettype ( $ aAddOnOptions [ 'element' ] ) ) ) ; } $ aAddOnOptions [ 'element' ] -> setOptions ( array_merge ( $ aAddOnOptions [ 'element' ] -> getOptions ( ) , array ( 'disable-twb' => true ) ) ) ; $ sMarkup .= $ this -> render ( $ aAddOnOptions [ 'element' ] ) ; if ( $ aAddOnOptions [ 'element' ] instanceof Button ) { $ sAddonClass .= ' input-group-btn' ; $ sAddonTagName = 'div' ; } else { $ sAddonClass .= ' input-group-addon' ; } } return sprintf ( static :: $ addonFormat , $ sAddonTagName , trim ( $ sAddonClass ) , $ sMarkup , $ sAddonTagName ) ; }
1197	private function htmlAttributesCallback ( $ name , $ value ) { if ( false === $ value || null === $ value ) { return '' ; } return ' ' . $ this -> renderHtmlAttribute ( $ name , $ value ) ; }
8053	public function deleteCalendarEvent ( $ id ) { $ cache = $ this -> cache ; $ this -> calendarEvent -> destroy ( $ id ) ; $ allEvents = $ this -> getAllEvents ( ) ; unset ( $ allEvents [ $ id ] ) ; $ cache :: put ( self :: ALL_EVENTS_KEY , $ allEvents , $ this -> cacheTimeToLive ) ; return true ; }
5712	public function addnew ( HTTPRequest $ r ) { return Controller :: curr ( ) -> redirect ( Controller :: join_links ( $ this -> owner -> gridField -> Link ( "item" ) , "new" ) ) ; }
5578	public function clickImageByName ( $ name , $ x = 1 , $ y = 1 , $ additional = false ) { if ( ! ( $ form = $ this -> page -> getFormByImage ( new SelectByName ( $ name ) ) ) ) { return false ; } $ success = $ this -> load ( $ form -> getAction ( ) , $ form -> submitImage ( new SelectByName ( $ name ) , $ x , $ y , $ additional ) ) ; return ( $ success ? $ this -> getContent ( ) : $ success ) ; }
7994	public function getDedicatedServerList ( ) { $ request = $ this -> get ( 'dedicated/server' ) ; $ response = $ request -> send ( ) ; return $ response -> getBody ( true ) ; }
3046	protected function saveToolStates ( ) { $ toolStateParameter = 'toolStates' ; if ( $ this -> hasRequestParameter ( $ toolStateParameter ) ) { $ param = $ this -> getRawRequestParameter ( $ toolStateParameter ) ; if ( $ param ) { $ toolStates = json_decode ( $ param , true ) ; if ( count ( $ toolStates ) > 0 ) { array_walk ( $ toolStates , function ( & $ toolState ) { $ toolState = json_encode ( $ toolState ) ; } ) ; $ this -> getRunnerService ( ) -> setToolsStates ( $ this -> getServiceContext ( ) , $ toolStates ) ; return true ; } } } return false ; }
12585	static function run_convert_configuration ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { self :: setConfigDir ( $ cliopts ) ; $ extname = @ $ args [ 0 ] ; if ( $ extname == '' ) { $ extname = dirname ( __FILE__ ) ; } while ( ! is_file ( "ant/$extname.properties" ) ) { $ extname = pake_input ( 'What is the name of the current extension?' ) ; if ( ! is_file ( "ant/$extname.properties" ) ) { pake_echo ( "File ant/$extname.properties not found" ) ; } } self :: convertPropertyFileToYamlFile ( "ant/$extname.properties" , self :: getConfigDir ( ) . "/options-$extname.yaml" , array ( $ extname => '' , 'external' => 'dependencies' , 'dependency' => 'extensions' , 'repository' => array ( 'svn' , 'url' ) ) , "extension:\n name: $extname\n\n" ) ; foreach ( array ( 'files.to.parse.txt' => 'to_parse' , 'files.to.exclude.txt' => 'to_exclude' ) as $ file => $ option ) { $ src = "ant/$file" ; if ( file_exists ( $ src ) ) { if ( count ( $ in = file ( $ src , FILE_SKIP_EMPTY_LINES | FILE_IGNORE_NEW_LINES ) ) ) { $ in = "\n\nfiles:\n $option: [" . implode ( ', ' , $ in ) . "]\n" ; file_put_contents ( self :: getConfigDir ( ) . "options-$extname.yaml" , $ in , FILE_APPEND ) ; } } } }
12921	public function getRemaining ( ) { if ( is_null ( $ this -> _countRemaining ) ) { $ this -> _countRemaining = $ this -> total ; } return $ this -> _countRemaining ; }
6048	public function retrieveObjectType ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/objecttypes/' . $ id . '' , $ parameters , $ cachePolicy ) ; $ result = new ObjectType ( $ result ) ; return $ result ; }
6482	public function assertNoErrorMessages ( ) { foreach ( $ this -> getMessagesContainers ( 'error' ) as $ element ) { $ text = trim ( $ element -> getText ( ) ) ; if ( '' !== $ text ) { throw new \ RuntimeException ( sprintf ( 'The page "%s" contains following error messages: "%s".' , self :: $ pageUrl , $ text ) ) ; } } foreach ( $ this -> getSession ( ) -> getPage ( ) -> findAll ( 'css' , 'input, select, textarea' ) as $ formElement ) { if ( $ formElement -> hasClass ( 'error' ) ) { throw new \ Exception ( sprintf ( 'Element "#%s" has an error class.' , $ formElement -> getAttribute ( 'id' ) ) ) ; } } }
11363	public static function mailListTagger ( array $ list ) { $ str = '' ; foreach ( $ list as $ name => $ mail ) { if ( is_string ( $ mail ) ) { $ str .= self :: mailTagger ( $ mail , $ name ) . Mailer :: $ ADDERSSES_SEPARATOR ; } elseif ( is_array ( $ mail ) ) { foreach ( $ mail as $ subname => $ submail ) { $ str .= self :: mailTagger ( $ submail , $ subname ) . Mailer :: $ ADDERSSES_SEPARATOR ; } } } return $ str ; }
12201	public function mediaAction ( Request $ request , Application $ app ) { $ options = array ( "connector" => $ app [ "red_kite_cms.elfinder_media_connector" ] , ) ; return parent :: show ( $ options ) ; }
7736	private function documentProperties ( ClassMetadata $ metadata , ReflectionClass $ class ) { $ properties = array ( ) ; $ elements = array_merge ( $ class -> getProperties ( ) , $ class -> getMethods ( ) ) ; foreach ( $ elements as $ element ) { $ annotation = $ this -> getAnnotation ( $ element , 'ML\HydraBundle\Mapping\Expose' ) ; if ( null === $ annotation ) { continue ; } $ property = new PropertyDefinition ( $ class -> name , $ element -> name ) ; $ property -> setExposeAs ( $ annotation -> as ) ; $ property -> setIri ( $ annotation -> getIri ( ) ) ; if ( null !== $ annotation -> required ) { $ property -> setRequired ( $ annotation -> required ) ; } if ( null !== $ annotation -> readonly ) { $ property -> setReadOnly ( $ annotation -> readonly ) ; } if ( null !== $ annotation -> writeonly ) { $ property -> setWriteOnly ( $ annotation -> writeonly ) ; } $ tmp = $ this -> getDocBlockText ( $ element ) ; $ property -> setTitle ( $ tmp [ 'title' ] ) ; $ property -> setDescription ( $ tmp [ 'description' ] ) ; $ tmp = $ this -> getType ( $ element ) ; $ property -> setType ( $ tmp [ 'type' ] ) ; $ this -> documentRouteAndOperations ( $ property , $ element ) ; if ( null !== ( $ annotation = $ this -> getAnnotation ( $ element , 'ML\HydraBundle\Mapping\Collection' ) ) ) { $ property -> setRoute ( $ this -> getRouteMetadata ( $ annotation -> route ) ) ; if ( false === $ property -> supportsOperation ( $ annotation -> route ) ) { $ property -> addOperation ( $ this -> getRouteMetadata ( $ annotation -> route ) ) ; } $ property -> setType ( 'ML\HydraBundle\Entity\Collection' ) ; $ property -> setReadOnly ( true ) ; } $ properties [ ] = $ property ; } $ metadata -> setProperties ( $ properties ) ; }
1543	protected function cursor ( EncodingParametersInterface $ parameters ) { return Cursor :: create ( ( array ) $ parameters -> getPaginationParameters ( ) , $ this -> before , $ this -> after , $ this -> limit ) ; }
4350	private function setCopyValues ( $ values ) { if ( isset ( $ values [ 'debug' ] [ 'emailLog' ] ) && $ values [ 'debug' ] [ 'emailLog' ] === true ) { $ values [ 'debug' ] [ 'emailLog' ] = 'onError' ; } foreach ( array ( 'emailFrom' , 'emailFunc' , 'emailTo' ) as $ key ) { if ( isset ( $ values [ 'debug' ] [ $ key ] ) && ! isset ( $ values [ 'errorEmailer' ] [ $ key ] ) ) { $ values [ 'errorEmailer' ] [ $ key ] = $ values [ 'debug' ] [ $ key ] ; } } return $ values ; }
3429	protected function propsMustBeSelected ( ) { return in_array ( 'PROPS' , $ this -> select ) || in_array ( 'PROPERTIES' , $ this -> select ) || in_array ( 'PROPERTY_VALUES' , $ this -> select ) ; }
4750	public function filterPlans ( array $ plans , array $ filters ) : array { foreach ( $ filters as $ key => $ filter ) { if ( array_key_exists ( $ key , current ( $ plans ) ) ) { $ plans = array_filter ( $ plans , function ( $ element ) use ( $ key , $ filter ) { return $ element [ $ key ] == $ filter ; } ) ; } } return $ plans ; }
11400	public function fromData ( $ data ) { $ this -> fromdata = $ data ; $ resource = fopen ( 'php://memory' , 'r+' ) ; fwrite ( $ resource , $ data ) ; rewind ( $ resource ) ; $ this -> setResource ( $ resource ) ; return $ this ; }
4909	public function renderForm ( SummaryFormInterface $ form , $ layout = Form :: LAYOUT_HORIZONTAL , $ parameter = array ( ) ) { $ renderer = $ this -> getView ( ) ; $ formHelper = $ renderer -> plugin ( 'form' ) ; $ fieldset = $ form -> getBaseFieldset ( ) ; $ resetPartial = false ; if ( $ fieldset instanceof ViewPartialProviderInterface ) { $ origPartial = $ fieldset -> getViewPartial ( ) ; $ partial = "$origPartial.form" ; if ( $ renderer -> resolver ( $ partial ) ) { $ fieldset -> setViewPartial ( $ partial ) ; $ resetPartial = true ; } } $ markup = $ formHelper -> renderBare ( $ form , $ layout , $ parameter ) ; if ( $ resetPartial ) { $ fieldset -> setViewPartial ( $ origPartial ) ; } return $ markup ; }
953	public function authenticate ( AuthShop $ request ) { $ validated = $ request -> validated ( ) ; $ shopDomain = ShopifyApp :: sanitizeShopDomain ( $ validated [ 'shop' ] ) ; $ shop = ShopifyApp :: shop ( $ shopDomain ) ; $ auth = new AuthShopHandler ( $ shop ) ; $ session = new ShopSession ( $ shop ) ; if ( ! $ request -> has ( 'code' ) ) { $ authUrl = $ auth -> buildAuthUrl ( $ shop -> hasOfflineAccess ( ) ? Config :: get ( 'shopify-app.api_grant_mode' ) : ShopSession :: GRANT_OFFLINE ) ; return View :: make ( 'shopify-app::auth.fullpage_redirect' , compact ( 'authUrl' , 'shopDomain' ) ) ; } $ access = $ auth -> getAccess ( $ validated [ 'code' ] ) ; $ session -> setDomain ( $ shopDomain ) ; $ session -> setAccess ( $ access ) ; $ auth -> postProcess ( ) ; $ auth -> dispatchJobs ( $ session ) ; return $ this -> returnTo ( ) ; }
11188	public static function set ( array $ arr , $ k , $ v ) { $ nested = ! is_array ( $ k ) ? explode ( '.' , $ k ) : $ k ; $ count = count ( $ nested ) ; if ( $ count == 1 ) { return $ arr [ $ k ] = $ v ; } elseif ( $ count > 1 ) { $ prev = '' ; $ loop = 1 ; $ unshift = $ nested ; foreach ( $ nested as $ part ) { if ( isset ( $ arr [ $ part ] ) && $ count > $ loop ) { $ prev = $ part ; array_shift ( $ unshift ) ; $ loop ++ ; continue ; } else { if ( $ loop > 1 && $ loop < $ count ) { if ( ! isset ( $ arr [ $ prev ] [ $ part ] ) ) $ arr [ $ prev ] [ $ part ] = [ ] ; $ arr [ $ prev ] = static :: set ( $ arr [ $ prev ] , $ unshift , $ v ) ; $ loop ++ ; break ; } elseif ( $ loop >= 1 && $ loop == $ count ) { if ( ! is_array ( $ arr [ $ prev ] ) ) $ arr [ $ prev ] = [ ] ; if ( $ part == '' ) $ arr [ $ prev ] [ ] = $ v ; else $ arr [ $ prev ] [ $ part ] = $ v ; } else { $ arr [ $ part ] = [ ] ; $ prev = $ part ; array_shift ( $ unshift ) ; $ loop ++ ; } } } } return $ arr ; }
10605	public function addHeaders ( array $ headers ) : void { foreach ( $ headers as $ name => $ value ) { $ this -> addHeader ( ( string ) $ name , $ value ) ; } }
6525	public function createMessage ( array $ data = [ ] ) { $ className = $ this -> className ; if ( empty ( $ data ) ) { return $ className :: create ( ) ; } return $ className :: fromArray ( $ data ) ; }
4393	public function cancel ( \ Aimeos \ MShop \ Order \ Item \ Iface $ order ) { $ provider = $ this -> getProvider ( ) ; if ( ! $ provider -> supportsVoid ( ) ) { return ; } $ base = $ this -> getOrderBase ( $ order -> getBaseId ( ) ) ; $ data = array ( 'transactionReference' => $ this -> getTransactionReference ( $ base ) , 'currency' => $ base -> getPrice ( ) -> getCurrencyId ( ) , 'amount' => $ this -> getAmount ( $ base -> getPrice ( ) ) , 'transactionId' => $ order -> getId ( ) , ) ; $ response = $ provider -> void ( $ data ) -> send ( ) ; if ( $ response -> isSuccessful ( ) ) { $ status = \ Aimeos \ MShop \ Order \ Item \ Base :: PAY_CANCELED ; $ order -> setPaymentStatus ( $ status ) ; $ this -> saveOrder ( $ order ) ; } }
12058	public function getPossibleTargets ( ) { if ( is_null ( $ this -> _possibleTargets ) ) { $ this -> _possibleTargets = [ ] ; if ( $ this -> canEndRelation ( ) ) { $ this -> _possibleTargets [ ] = 'end_relationship' ; } if ( $ this -> canDeleteRelation ( ) ) { $ this -> _possibleTargets [ ] = 'delete_relationship' ; } if ( $ this -> canArchiveObject ( ) ) { if ( $ this -> object -> archived ) { $ this -> _possibleTargets [ ] = 'unarchive_object' ; } else { $ this -> _possibleTargets [ ] = 'archive_object' ; } } if ( $ this -> canDeleteObject ( ) ) { $ this -> _possibleTargets [ ] = 'delete_object' ; } } return $ this -> _possibleTargets ; }
2603	public function execute ( ) { $ result = $ this -> resultJsonFactory -> create ( ) ; try { $ service = $ this -> api -> checkServiceDetails ( ) ; $ currActiveVersion = $ this -> vcl -> getCurrentVersion ( $ service -> versions ) ; $ dictionaryName = Config :: CONFIG_DICTIONARY_NAME ; $ dictionary = $ this -> api -> getSingleDictionary ( $ currActiveVersion , $ dictionaryName ) ; if ( ! $ dictionary ) { return $ result -> setData ( [ 'status' => false ] ) ; } $ dictionaryItems = $ this -> api -> dictionaryItemsList ( $ dictionary -> id ) ; foreach ( $ dictionaryItems as $ item ) { if ( $ item -> item_key == Config :: CONFIG_DICTIONARY_KEY && $ item -> item_value == 1 ) { return $ result -> setData ( [ 'status' => true ] ) ; } } return $ result -> setData ( [ 'status' => false ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
2130	protected function markModified ( ) { if ( $ this -> blnIsModified === true ) { return ; } $ this -> blnIsModified = true ; $ this -> strTop = '' ; $ this -> strBottom = '' ; $ this -> Files = Files :: getInstance ( ) ; if ( static :: $ blnHasLcf ) { $ strMode = 'top' ; $ resFile = fopen ( $ this -> strRootDir . '/system/config/localconfig.php' , 'rb' ) ; while ( ! feof ( $ resFile ) ) { $ strLine = fgets ( $ resFile ) ; $ strTrim = trim ( $ strLine ) ; if ( $ strTrim == '?>' ) { continue ; } if ( $ strTrim == '### INSTALL SCRIPT START ###' ) { $ strMode = 'data' ; continue ; } if ( $ strTrim == '### INSTALL SCRIPT STOP ###' ) { $ strMode = 'bottom' ; continue ; } if ( $ strMode == 'top' ) { $ this -> strTop .= $ strLine ; } elseif ( $ strMode == 'bottom' ) { $ this -> strBottom .= $ strLine ; } elseif ( $ strTrim != '' ) { $ arrChunks = array_map ( 'trim' , explode ( '=' , $ strLine , 2 ) ) ; $ this -> arrData [ $ arrChunks [ 0 ] ] = $ arrChunks [ 1 ] ; } } fclose ( $ resFile ) ; } }
11545	public function changeEmail ( $ data ) { if ( ! ( $ user = $ this -> hydrate ( $ data , $ this -> getChangeEmailForm ( ) ) ) ) { return ; } $ eventManager = $ this -> getEventManager ( ) ; $ eventManager -> trigger ( __METHOD__ , $ this , $ user ) ; $ user -> setEmailConfirmed ( false ) ; $ viewModel = new ViewModel ( compact ( 'user' ) ) ; $ viewModel -> setTemplate ( 'mail-message/user-confirm-email' ) ; $ mailService = $ this -> getMailService ( ) ; $ message = $ mailService -> getMessage ( ) ; $ message -> setTo ( $ user -> getEmail ( ) , $ user -> getDisplayName ( ) ) ; $ subject = 'Please, confirm your email!' ; if ( $ this -> getTranslator ( ) && $ this -> isTranslatorEnabled ( ) ) { $ subject = $ this -> getTranslator ( ) -> translate ( $ subject , $ this -> getTranslatorTextDomain ( ) ) ; } $ message -> setSubject ( $ subject ) ; $ mailService -> setBody ( $ viewModel ) -> sendMessage ( ) ; $ this -> getMapper ( ) -> update ( $ user ) -> save ( ) ; $ eventManager -> trigger ( __METHOD__ . '.post' , $ this , $ user ) ; return $ user ; }
3062	public function canMoveBackward ( ) { $ moveBack = false ; $ session = $ this -> getTestSession ( ) ; if ( $ this -> isAdaptive ( ) ) { $ positionInCatSession = array_search ( $ this -> getCurrentCatItemId ( ) , $ this -> getShadowTest ( ) ) ; if ( $ positionInCatSession === 0 ) { if ( $ session -> getRoute ( ) -> getPosition ( ) !== 0 ) { $ moveBack = $ session -> getPreviousRouteItem ( ) -> getTestPart ( ) -> getNavigationMode ( ) === NavigationMode :: NONLINEAR ; } } else { $ moveBack = $ session -> getRoute ( ) -> current ( ) -> getTestPart ( ) -> getNavigationMode ( ) === NavigationMode :: NONLINEAR ; } } else { $ moveBack = $ session -> canMoveBackward ( ) ; if ( $ moveBack ) { $ moveBack = $ this -> getServiceManager ( ) -> get ( SectionPauseService :: SERVICE_ID ) -> canMoveBackward ( $ session ) ; } } return $ moveBack ; }
8547	public function setPayWithAmazonEventList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'PayWithAmazonEventList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
12130	public function clear ( ) { $ this -> _repeat = 1 ; $ this -> _startTime = 0 ; $ this -> _duration = 0 ; $ this -> _average = 0 ; $ this -> _rate = 0 ; $ this -> _startMem = 0 ; $ this -> _memory = 0 ; }
3840	private function parsePanelRow ( $ fields , PanelRowInterface $ panelRow ) { foreach ( $ fields as $ field ) { switch ( $ field ) { case 'sort' : $ this -> parsePanelSort ( $ panelRow ) ; break ; case 'limit' : $ this -> parsePanelLimit ( $ panelRow ) ; break ; case 'filter' : $ this -> parsePanelFilter ( $ panelRow ) ; break ; case 'search' : $ this -> parsePanelSearch ( $ panelRow ) ; break ; case 'submit' : $ this -> parsePanelSubmit ( $ panelRow ) ; break ; default : break ; } } }
9027	public function isQuestion ( $ string ) { $ probability = 0 ; if ( strpos ( $ string , '?' ) ) { $ probability += 1 ; } $ words = $ this -> getWords ( $ string ) ; foreach ( $ this -> inquiryWords as $ queryWord ) { if ( ! strncmp ( strtolower ( $ string ) , $ queryWord , strlen ( $ queryWord ) ) ) { $ probability += 1 ; } elseif ( stristr ( strtolower ( $ string ) , $ queryWord ) ) { $ probability += 0.5 ; } } if ( $ probability >= 2 ) { return true ; } return false ; }
5481	public function getValue ( SelectorInterface $ selector ) { for ( $ i = 0 , $ count = count ( $ this -> widgets ) ; $ i < $ count ; $ i ++ ) { if ( $ selector -> isMatch ( $ this -> widgets [ $ i ] ) ) { return $ this -> widgets [ $ i ] -> getValue ( ) ; } } foreach ( $ this -> buttons as $ button ) { if ( $ selector -> isMatch ( $ button ) ) { return $ button -> getValue ( ) ; } } return ; }
11444	public function setTransporter ( TransportInterface $ transporter ) { if ( $ transporter -> validate ( ) ) { $ this -> transporter = $ transporter ; } else { throw new \ Exception ( sprintf ( 'Transporter "%s" is not valid for current environment!' , get_class ( $ transporter ) ) ) ; } return $ this ; }
12257	public function getProjectSearchPaths ( string $ name ) : array { $ srcPaths = $ this -> getProject ( ) -> getAttribute ( AttributeInterface :: SEARCH_PATHS_ATTR_NAME ) ; if ( $ srcPaths instanceof SearchPathCollection ) { return $ srcPaths -> getSearchPaths ( $ name ) ?? [ ] ; } return [ ] ; }
2297	public static function handleRunOnce ( ) { try { $ files = System :: getContainer ( ) -> get ( 'contao.resource_locator' ) -> locate ( 'config/runonce.php' , null , false ) ; } catch ( \ InvalidArgumentException $ e ) { return ; } foreach ( $ files as $ file ) { try { include $ file ; } catch ( \ Exception $ e ) { } $ strRelpath = StringUtil :: stripRootDir ( $ file ) ; if ( ! unlink ( $ file ) ) { throw new \ Exception ( "The file $strRelpath cannot be deleted. Please remove the file manually and correct the file permission settings on your server." ) ; } System :: log ( "File $strRelpath ran once and has then been removed successfully" , __METHOD__ , TL_GENERAL ) ; } }
4809	public function deactivate ( ) { $ this -> clear_schedule ( ) ; if ( ! is_multisite ( ) || wp_is_large_network ( ) ) { return ; } $ sites = ( array ) get_site_option ( $ this -> args [ 'name' ] . '_sites' , array ( ) ) ; $ sites and $ sites = array_diff ( $ sites , [ get_current_blog_id ( ) ] ) ; foreach ( $ sites as $ site ) { switch_to_blog ( $ site ) ; $ this -> clear_schedule ( ) ; } restore_current_blog ( ) ; delete_site_option ( $ this -> args [ 'name' ] . '_sites' ) ; }
4855	public function log ( $ level , $ message , array $ context = [ ] ) { static $ counter = [ ] ; ! $ this -> logger || $ this -> logger -> log ( $ level , $ message , $ context ) ; $ message = is_object ( $ message ) ? $ message -> __toString ( ) : $ message ; if ( isset ( $ this -> messages [ $ level ] [ $ hash = md5 ( $ message ) ] ) ) { $ this -> messages [ $ level ] [ $ hash ] = '(' . ++ $ counter [ $ hash ] . ') ' . $ message ; } else { $ counter [ $ hash ] = 1 ; $ this -> messages [ $ level ] [ $ hash ] = $ message ; } }
10288	protected function getJobsSince ( $ time ) { $ now = time ( ) ; $ jobs = array ( ) ; foreach ( $ this -> rescheduled as $ scheduled => $ cronjob ) { if ( $ scheduled <= $ now ) { $ jobs [ $ scheduled ] [ ] = $ cronjob ; unset ( $ this -> rescheduled [ $ scheduled ] ) ; } } foreach ( $ this -> crontab as $ cronjob ) { $ cronjob -> iterator -> startTime = $ time ; if ( ( $ scheduled = $ cronjob -> iterator -> current ( ) ) < $ now ) { $ jobs [ $ scheduled ] [ ] = $ cronjob ; } } ksort ( $ jobs ) ; return $ jobs ; }
8660	private function convertGetReportList ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetReportList' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetMaxCount ( ) ) { $ parameters [ 'MaxCount' ] = $ request -> getMaxCount ( ) ; } if ( $ request -> isSetReportTypeList ( ) ) { $ reportTypeList = $ request -> getReportTypeList ( ) ; foreach ( $ reportTypeList -> getType ( ) as $ typeIndex => $ type ) { $ parameters [ 'ReportTypeList' . '.' . 'Type' . '.' . ( $ typeIndex + 1 ) ] = $ type ; } } if ( $ request -> isSetAcknowledged ( ) ) { $ parameters [ 'Acknowledged' ] = $ request -> getAcknowledged ( ) ? "true" : "false" ; } if ( $ request -> isSetAvailableFromDate ( ) ) { $ parameters [ 'AvailableFromDate' ] = $ this -> getFormattedTimestamp ( $ request -> getAvailableFromDate ( ) ) ; } if ( $ request -> isSetAvailableToDate ( ) ) { $ parameters [ 'AvailableToDate' ] = $ this -> getFormattedTimestamp ( $ request -> getAvailableToDate ( ) ) ; } if ( $ request -> isSetReportRequestIdList ( ) ) { $ reportRequestIdList = $ request -> getReportRequestIdList ( ) ; foreach ( $ reportRequestIdList -> getId ( ) as $ idIndex => $ id ) { $ parameters [ 'ReportRequestIdList' . '.' . 'Id' . '.' . ( $ idIndex + 1 ) ] = $ id ; } } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
7304	protected function updateFromParent ( CustomerInterface $ customer ) { if ( ! $ customer -> hasParent ( ) ) { if ( null === $ customer -> getDefaultInvoiceAddress ( ) ) { if ( false !== $ address = $ customer -> getAddresses ( ) -> first ( ) ) { $ address -> setInvoiceDefault ( true ) ; $ this -> persistenceHelper -> persistAndRecompute ( $ address , false ) ; } } if ( null === $ customer -> getDefaultDeliveryAddress ( ) ) { if ( false !== $ address = $ customer -> getAddresses ( ) -> first ( ) ) { $ address -> setDeliveryDefault ( true ) ; $ this -> persistenceHelper -> persistAndRecompute ( $ address , false ) ; } } return false ; } $ parent = $ customer -> getParent ( ) ; $ changed = false ; if ( empty ( $ customer -> getCompany ( ) ) ) { $ company = $ parent -> getCompany ( ) ; if ( $ company != $ customer -> getCompany ( ) ) { $ customer -> setCompany ( $ company ) ; $ changed = true ; } } $ group = $ parent -> getCustomerGroup ( ) ; if ( $ group !== $ customer -> getCustomerGroup ( ) ) { $ customer -> setCustomerGroup ( $ group ) ; $ changed = true ; } if ( ! empty ( $ customer -> getVatNumber ( ) ) ) { $ customer -> setVatNumber ( null ) ; $ changed = true ; } if ( ! empty ( $ customer -> getVatDetails ( ) ) ) { $ customer -> setVatDetails ( [ ] ) ; $ changed = true ; } if ( $ customer -> isVatValid ( ) ) { $ customer -> setVatValid ( false ) ; $ changed = true ; } if ( null !== $ customer -> getPaymentTerm ( ) ) { $ customer -> setPaymentTerm ( null ) ; $ changed = true ; } if ( 0 !== $ customer -> getOutstandingLimit ( ) ) { $ customer -> setOutstandingLimit ( 0 ) ; $ changed = true ; } return $ changed ; }
8695	public static function format ( $ size , $ decimals = 2 , $ decPoint = '.' , $ thousandsSep = '' , $ unitSep = '' ) { $ output = $ unit = null ; foreach ( self :: getBinarySizes ( ) as $ unit => $ divider ) { $ output = $ size / $ divider ; if ( $ output < 1000 ) { break ; } } if ( null === $ output ) { throw new \ UnexpectedValueException ( "Unable to parse value: '{$size}'" ) ; } $ unit = $ unit === 'o' ? 'o' : ucfirst ( $ unit ) ; $ trimmed = rtrim ( rtrim ( number_format ( $ output , $ decimals , $ decPoint , $ thousandsSep ) , '0' ) , $ decPoint ) ; $ formatted = $ trimmed . $ unitSep . $ unit ; return str_replace ( ' ' , utf8_encode ( chr ( 160 ) ) , $ formatted ) ; }
3250	public function scopeWhereCurrent ( $ query ) { if ( Auth :: guest ( ) ) return $ query ; return $ query -> whereUser ( Auth :: user ( ) -> shopId ) ; }
8526	public function listFinancialEventGroups ( $ request ) { if ( ! ( $ request instanceof MWSFinancesService_Model_ListFinancialEventGroupsRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/ListFinancialEventGroupsRequest.php' ) ; $ request = new MWSFinancesService_Model_ListFinancialEventGroupsRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListFinancialEventGroups' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/ListFinancialEventGroupsResponse.php' ) ; $ response = MWSFinancesService_Model_ListFinancialEventGroupsResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
5957	public function channelGetByName ( $ name ) { foreach ( $ this -> channelList ( ) as $ channel ) { if ( $ channel [ "channel_name" ] == $ name ) { return $ channel ; } } throw new Ts3Exception ( "invalid channelID" , 0x300 ) ; }
5470	protected function describePatternMatch ( $ pattern , $ subject ) { preg_match ( $ pattern , $ subject , $ matches ) ; $ position = strpos ( $ subject , $ matches [ 0 ] ) ; $ dumper = $ this -> getDumper ( ) ; return "Pattern [$pattern] detected at character [$position] in [" . $ dumper -> describeValue ( $ subject ) . '] as [' . $ matches [ 0 ] . '] in region [' . $ dumper -> clipString ( $ subject , 100 , $ position ) . ']' ; }
2949	private function dispatchQueue ( ) { $ queue = $ this -> queue ; $ this -> queue = [ ] ; $ queueLength = count ( $ queue ) ; $ maxBatchSize = $ this -> options -> getMaxBatchSize ( ) ; if ( $ maxBatchSize && $ maxBatchSize > 0 && $ maxBatchSize < $ queueLength ) { for ( $ i = 0 ; $ i < $ queueLength / $ maxBatchSize ; $ i ++ ) { $ offset = $ i * $ maxBatchSize ; $ length = ( $ i + 1 ) * $ maxBatchSize - $ offset ; $ this -> dispatchQueueBatch ( array_slice ( $ queue , $ offset , $ length ) ) ; } } else { $ this -> dispatchQueueBatch ( $ queue ) ; } }
158	public function andFilterCompare ( $ name , $ value , $ defaultOperator = '=' ) { if ( preg_match ( '/^(<>|>=|>|<=|<|=)/' , $ value , $ matches ) ) { $ operator = $ matches [ 1 ] ; $ value = substr ( $ value , strlen ( $ operator ) ) ; } else { $ operator = $ defaultOperator ; } return $ this -> andFilterWhere ( [ $ operator , $ name , $ value ] ) ; }
3740	public function getCombinationsForUser ( $ userGroups , $ userType ) { $ userType = strtolower ( $ userType ) ; if ( 'fe' !== $ userType && 'be' !== $ userType ) { throw new \ InvalidArgumentException ( 'Unknown user type: ' . $ userType ) ; } return $ this -> getCombinationsFromDatabase ( $ userGroups , $ userType ) ; }
1635	protected function setupEvents ( Dispatcher $ events , array $ config ) { if ( isset ( $ config [ 'auto_capture_sessions' ] ) && $ config [ 'auto_capture_sessions' ] ) { $ events -> listen ( RouteMatched :: class , function ( $ event ) { $ this -> app -> bugsnag -> getSessionTracker ( ) -> startSession ( ) ; } ) ; } if ( isset ( $ config [ 'query' ] ) && ! $ config [ 'query' ] ) { return ; } $ show = isset ( $ config [ 'bindings' ] ) && $ config [ 'bindings' ] ; if ( class_exists ( QueryExecuted :: class ) ) { $ events -> listen ( QueryExecuted :: class , function ( QueryExecuted $ query ) use ( $ show ) { $ this -> app -> bugsnag -> leaveBreadcrumb ( 'Query executed' , Breadcrumb :: PROCESS_TYPE , $ this -> formatQuery ( $ query -> sql , $ show ? $ query -> bindings : [ ] , $ query -> time , $ query -> connectionName ) ) ; } ) ; } else { $ events -> listen ( 'illuminate.query' , function ( $ sql , array $ bindings , $ time , $ connection ) use ( $ show ) { $ this -> app -> bugsnag -> leaveBreadcrumb ( 'Query executed' , Breadcrumb :: PROCESS_TYPE , $ this -> formatQuery ( $ sql , $ show ? $ bindings : [ ] , $ time , $ connection ) ) ; } ) ; } }
7025	public function addRememberMeCookie ( $ userId , $ options = [ ] ) { $ options = Hash :: merge ( [ 'expires' => '+14 days' , 'httpOnly' => true , 'secure' => false ] , $ options ) ; $ this -> Cookie -> config ( $ options ) ; $ this -> Cookie -> write ( 'User.id' , $ userId ) ; }
6814	private function getCurrencyFormatter ( ) { if ( $ this -> currencyFormatter ) { return $ this -> currencyFormatter ; } return $ this -> currencyFormatter = NumberFormatter :: create ( $ this -> locale , NumberFormatter :: CURRENCY ) ; }
384	protected function validateImage ( $ image ) { if ( false === ( $ imageInfo = getimagesize ( $ image -> tempName ) ) ) { return [ $ this -> notImage , [ 'file' => $ image -> name ] ] ; } list ( $ width , $ height ) = $ imageInfo ; if ( $ width == 0 || $ height == 0 ) { return [ $ this -> notImage , [ 'file' => $ image -> name ] ] ; } if ( $ this -> minWidth !== null && $ width < $ this -> minWidth ) { return [ $ this -> underWidth , [ 'file' => $ image -> name , 'limit' => $ this -> minWidth ] ] ; } if ( $ this -> minHeight !== null && $ height < $ this -> minHeight ) { return [ $ this -> underHeight , [ 'file' => $ image -> name , 'limit' => $ this -> minHeight ] ] ; } if ( $ this -> maxWidth !== null && $ width > $ this -> maxWidth ) { return [ $ this -> overWidth , [ 'file' => $ image -> name , 'limit' => $ this -> maxWidth ] ] ; } if ( $ this -> maxHeight !== null && $ height > $ this -> maxHeight ) { return [ $ this -> overHeight , [ 'file' => $ image -> name , 'limit' => $ this -> maxHeight ] ] ; } return null ; }
12091	public function client ( ) { if ( empty ( $ this -> authToken ) ) { throw new NotFoundTokenException ( 'Token not found' ) ; } $ this -> client = new Client ( [ 'base_uri' => $ this -> microService , 'timeout' => $ this -> timeout , 'headers' => [ 'Auth-Token' => $ this -> authToken ] ] ) ; return $ this -> client ; }
11647	function parseAndAddServiceFromFile ( $ serviceFilename ) { $ service = require $ serviceFilename ; if ( $ service == false ) { throw new APIBuilderException ( "Failed to open service file `$serviceFilename`." ) ; } if ( is_array ( $ service ) == false ) { throw new APIBuilderException ( "File `$serviceFilename` did not return a service array. Cannot build API from it." ) ; } $ this -> parseAndAddService ( $ service ) ; }
6409	public static function concat ( IteratorAggregate $ a , IteratorAggregate $ b ) : IteratorAggregate { return self :: from ( Iterators :: concat ( Iterators :: from ( $ a -> getIterator ( ) ) , Iterators :: from ( $ b -> getIterator ( ) ) ) ) ; }
10232	private function writeLine ( $ pFileHandle , array $ pValues ) { $ writeDelimiter = false ; $ line = '' ; foreach ( $ pValues as $ element ) { $ element = str_replace ( $ this -> enclosure , $ this -> enclosure . $ this -> enclosure , $ element ) ; if ( $ writeDelimiter ) { $ line .= $ this -> delimiter ; } else { $ writeDelimiter = true ; } $ line .= $ this -> enclosure . $ element . $ this -> enclosure ; } $ line .= $ this -> lineEnding ; fwrite ( $ pFileHandle , $ line ) ; }
2467	private function setImpersonatedLogout ( ) { $ token = System :: getContainer ( ) -> get ( 'security.token_storage' ) -> getToken ( ) ; if ( ! $ token instanceof TokenInterface ) { return ; } $ impersonatorUser = null ; foreach ( $ token -> getRoles ( ) as $ role ) { if ( $ role instanceof SwitchUserRole ) { $ impersonatorUser = $ role -> getSource ( ) -> getUsername ( ) ; break ; } } if ( ! $ impersonatorUser ) { return ; } $ request = System :: getContainer ( ) -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; if ( $ request === null ) { throw new \ RuntimeException ( 'The request stack did not contain a request' ) ; } $ firewallMap = System :: getContainer ( ) -> get ( 'security.firewall.map' ) ; if ( ( $ firewallConfig = $ firewallMap -> getFirewallConfig ( $ request ) ) === null || ( $ switchUserConfig = $ firewallConfig -> getSwitchUser ( ) ) === null ) { return ; } $ arrParams = array ( 'do' => 'user' , urlencode ( $ switchUserConfig [ 'parameter' ] ) => SwitchUserListener :: EXIT_VALUE ) ; $ this -> Template -> logout = sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'switchBT' ] , $ impersonatorUser ) ; $ this -> Template -> logoutLink = System :: getContainer ( ) -> get ( 'router' ) -> generate ( 'contao_backend' , $ arrParams ) ; }
10945	public function onPrerenderPost ( PrerenderEvent $ events ) { $ cache = $ this -> getServiceLocator ( ) -> get ( $ this -> moduleOptions -> getCacheKey ( ) ) ; $ response = $ events -> getResponse ( ) ; $ key = $ this -> getCacheEntryKey ( $ events -> getRequest ( ) ) ; $ cache -> setItem ( $ key , $ events -> getResponse ( ) ) ; return $ this ; }
6252	protected function createUngroupedGroupPresence ( $ id = null ) { $ id = $ id ? : 'automatic-ungrouped-permissions' ; return new AclPresence ( [ 'type' => AclPresenceType :: GROUP , 'id' => $ id , 'label' => 'acl.ungrouped-permissions' , 'translated' => true , ] ) ; }
858	public function setCode ( $ code ) { if ( $ code === $ this -> generateCode ( ) ) { return ; } $ this -> setSize ( 0 ) ; $ tokens = \ defined ( 'TOKEN_PARSE' ) ? token_get_all ( $ code , TOKEN_PARSE ) : token_get_all ( $ code ) ; $ this -> setSize ( \ count ( $ tokens ) ) ; foreach ( $ tokens as $ index => $ token ) { $ this [ $ index ] = new Token ( $ token ) ; } $ transformers = Transformers :: create ( ) ; $ transformers -> transform ( $ this ) ; $ this -> foundTokenKinds = [ ] ; foreach ( $ this as $ token ) { $ this -> registerFoundToken ( $ token ) ; } $ this -> rewind ( ) ; $ this -> changeCodeHash ( self :: calculateCodeHash ( $ code ) ) ; $ this -> changed = true ; }
12090	public function then ( callable $ success = null , callable $ fail = null ) { if ( $ this -> success && is_callable ( $ success ) ) { return $ success ( $ this -> request , $ this -> request -> getStatusCode ( ) ) ; } elseif ( is_callable ( $ fail ) ) { return $ fail ( $ this -> error ) ; } }
7289	protected function watch ( OrderInterface $ order ) { if ( ! $ order -> isAutoNotify ( ) || $ order -> isSample ( ) ) { return ; } if ( $ order -> hasNotifications ( NotificationTypes :: ORDER_ACCEPTED ) ) { return ; } if ( ! $ this -> didStateChangeTo ( $ order , OrderStates :: STATE_ACCEPTED ) ) { return ; } $ this -> notify ( NotificationTypes :: ORDER_ACCEPTED , $ order ) ; }
5730	public function getButtonHTML ( ) { $ html = '<div class="btn-group" role="group">' ; $ params = array ( 'q' => ( array ) $ this -> gridFieldRequest -> getRequest ( ) -> getVar ( 'q' ) ) ; $ searchVars = ( bool ) $ params ? '?' . http_build_query ( $ params ) : '' ; $ previousRecordID = $ this -> gridFieldRequest -> getPreviousRecordID ( ) ; $ cssClass = $ previousRecordID ? "cms-panel-link" : "disabled" ; $ prevLink = $ previousRecordID ? Controller :: join_links ( $ this -> gridFieldRequest -> gridField -> Link ( ) , "item" , $ previousRecordID . $ searchVars ) : "javascript:void(0);" ; $ linkTitle = $ previousRecordID ? _t ( 'GridFieldBetterButtons.PREVIOUSRECORD' , 'Go to the previous record' ) : "" ; $ linkText = $ previousRecordID ? _t ( 'GridFieldBetterButtons.PREVIOUS' , 'Previous' ) : "" ; $ html .= sprintf ( "<a class='ss-ui-button btn btn-default gridfield-better-buttons-prevnext gridfield-better-buttons-prev %s' href='%s' title='%s'><img src='" . BETTER_BUTTONS_DIR . "/images/prev.png' alt='previous' /> %s</a>" , $ cssClass , $ prevLink , $ linkTitle , $ linkText ) ; $ nextRecordID = $ this -> gridFieldRequest -> getNextRecordID ( ) ; $ cssClass = $ nextRecordID ? "cms-panel-link" : "disabled" ; $ nextLink = $ nextRecordID ? Controller :: join_links ( $ this -> gridFieldRequest -> gridField -> Link ( ) , "item" , $ nextRecordID . $ searchVars ) : "javascript:void(0);" ; $ linkTitle = $ nextRecordID ? _t ( 'GridFieldBetterButtons.NEXTRECORD' , 'Go to the next record' ) : "" ; $ linkText = $ nextRecordID ? _t ( 'GridFieldBetterButtons.NEXT' , 'Next' ) : "" ; $ html .= sprintf ( "<a class='ss-ui-button btn btn-default gridfield-better-buttons-prevnext gridfield-better-buttons-next %s' href='%s' title='%s'>%s <img src='" . BETTER_BUTTONS_DIR . "/images/next.png' alt='next' /></a>" , $ cssClass , $ nextLink , $ linkTitle , $ linkText ) ; $ html .= '</div>' ; return $ html ; }
2739	private function uploadVcl ( $ activate ) { try { $ service = $ this -> api -> checkServiceDetails ( ) ; $ currActiveVersion = $ this -> vcl -> getCurrentVersion ( $ service -> versions ) ; $ clone = $ this -> api -> cloneVersion ( $ currActiveVersion ) ; $ snippets = $ this -> config -> getVclSnippets ( ) ; foreach ( $ snippets as $ key => $ value ) { $ snippetData = [ 'name' => Config :: FASTLY_MAGENTO_MODULE . '_' . $ key , 'type' => $ key , 'dynamic' => "0" , 'priority' => 50 , 'content' => $ value ] ; $ this -> api -> uploadSnippet ( $ clone -> number , $ snippetData ) ; } $ condition = [ 'name' => Config :: FASTLY_MAGENTO_MODULE . '_pass' , 'statement' => 'req.http.x-pass' , 'type' => 'REQUEST' , 'priority' => 90 ] ; $ createCondition = $ this -> api -> createCondition ( $ clone -> number , $ condition ) ; $ request = [ 'action' => 'pass' , 'max_stale_age' => 3600 , 'name' => Config :: FASTLY_MAGENTO_MODULE . '_request' , 'request_condition' => $ createCondition -> name , 'service_id' => $ service -> id , 'version' => $ currActiveVersion ] ; $ this -> api -> createRequest ( $ clone -> number , $ request ) ; $ this -> api -> validateServiceVersion ( $ clone -> number ) ; $ msg = 'Successfully uploaded VCL. ' ; if ( $ activate ) { $ this -> api -> activateVersion ( $ clone -> number ) ; $ msg .= 'Activated Version ' . $ clone -> number ; } if ( $ this -> config -> areWebHooksEnabled ( ) && $ this -> config -> canPublishConfigChanges ( ) ) { $ this -> api -> sendWebHook ( '*Upload VCL has been initiated and activated in version ' . $ clone -> number . '*' ) ; } $ this -> output -> writeln ( '<info>' . $ msg . '</info>' , OutputInterface :: OUTPUT_NORMAL ) ; } catch ( \ Exception $ e ) { $ msg = $ e -> getMessage ( ) ; $ this -> output -> writeln ( "<error>$msg</error>" , OutputInterface :: OUTPUT_NORMAL ) ; return ; } }
1301	public function parseJson ( string $ json ) { return $ this -> builder -> build ( $ this -> scopedJsonDecoder -> decode ( $ json ) ) ; }
3413	public function refreshFields ( ) { if ( $ this -> id === null ) { $ this -> original = [ ] ; return $ this -> fields = [ ] ; } $ this -> fields = static :: query ( ) -> getById ( $ this -> id ) -> fields ; $ this -> original = $ this -> fields ; $ this -> fieldsAreFetched = true ; return $ this -> fields ; }
8510	public function getTransportContent ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_GetTransportContentRequest ) ) { $ request = new FBAInboundServiceMWS_Model_GetTransportContentRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetTransportContent' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_GetTransportContentResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
10973	public static function getAuthPassword ( ) { $ result = null ; if ( isset ( $ _SERVER [ 'PHP_AUTH_PW' ] ) ) { $ result = $ _SERVER [ 'PHP_AUTH_PW' ] ; } if ( trim ( $ result ) == '' ) { $ result = null ; } return $ result ; }
3208	public static function encode ( $ string ) { if ( strlen ( $ string ) == 0 ) { return '' ; } $ binaryString = '' ; foreach ( str_split ( $ string ) as $ s ) { $ binaryString .= sprintf ( '%08b' , ord ( $ s ) ) ; } $ binaryArray = self :: chunk ( $ binaryString , 5 ) ; while ( count ( $ binaryArray ) % 8 !== 0 ) { $ binaryArray [ ] = null ; } $ base32String = '' ; foreach ( $ binaryArray as $ bin ) { $ char = 32 ; if ( ! is_null ( $ bin ) ) { $ bin = str_pad ( $ bin , 5 , 0 , STR_PAD_RIGHT ) ; $ char = bindec ( $ bin ) ; } $ base32String .= self :: $ alphabet [ $ char ] ; } return $ base32String ; }
7640	public static function isValidContainerName ( $ containerName = '' ) { if ( $ containerName == '$root' ) { return true ; } if ( preg_match ( "/^[a-z0-9][a-z0-9-]*$/" , $ containerName ) === 0 ) { return false ; } if ( strpos ( $ containerName , '--' ) !== false ) { return false ; } if ( strtolower ( $ containerName ) != $ containerName ) { return false ; } if ( strlen ( $ containerName ) < 3 || strlen ( $ containerName ) > 63 ) { return false ; } if ( substr ( $ containerName , - 1 ) == '-' ) { return false ; } return true ; }
1021	public function toSerializableArray ( ) { $ arr = [ 'message' => $ this -> getMessage ( ) , ] ; $ locations = Utils :: map ( $ this -> getLocations ( ) , static function ( SourceLocation $ loc ) { return $ loc -> toSerializableArray ( ) ; } ) ; if ( ! empty ( $ locations ) ) { $ arr [ 'locations' ] = $ locations ; } if ( ! empty ( $ this -> path ) ) { $ arr [ 'path' ] = $ this -> path ; } if ( ! empty ( $ this -> extensions ) ) { $ arr [ 'extensions' ] = $ this -> extensions ; } return $ arr ; }
6423	public function isConfigured ( ) { if ( empty ( $ this -> options [ 'application_name' ] ) || empty ( $ this -> options [ 'client_id' ] ) || empty ( $ this -> options [ 'client_secret' ] ) ) { return false ; } return true ; }
1455	protected function validateHasOne ( RelationshipInterface $ relationship , $ record = null , $ key = null , ResourceObjectInterface $ resource = null ) { if ( ! $ relationship -> isHasOne ( ) ) { $ this -> addError ( $ this -> errorFactory -> relationshipHasOneExpected ( $ key ) ) ; return false ; } $ identifier = $ relationship -> getData ( ) ; if ( ! $ identifier ) { return true ; } if ( ! $ this -> validateIdentifier ( $ identifier , $ key ) ) { return false ; } if ( ! $ this -> validateExists ( $ identifier , $ key ) ) { return false ; } if ( ! $ this -> validateAcceptable ( $ identifier , $ record , $ key , $ resource ) ) { return false ; } return true ; }
9943	public function setCellValueExplicit ( $ pCoordinate , $ pValue , $ pDataType ) { $ this -> getCell ( $ pCoordinate ) -> setValueExplicit ( $ pValue , $ pDataType ) ; return $ this ; }
48	protected function getListeners ( Event $ event ) { $ scriptListeners = $ this -> getScriptListeners ( $ event ) ; if ( ! isset ( $ this -> listeners [ $ event -> getName ( ) ] [ 0 ] ) ) { $ this -> listeners [ $ event -> getName ( ) ] [ 0 ] = array ( ) ; } krsort ( $ this -> listeners [ $ event -> getName ( ) ] ) ; $ listeners = $ this -> listeners ; $ listeners [ $ event -> getName ( ) ] [ 0 ] = array_merge ( $ listeners [ $ event -> getName ( ) ] [ 0 ] , $ scriptListeners ) ; return call_user_func_array ( 'array_merge' , $ listeners [ $ event -> getName ( ) ] ) ; }
9950	public function duplicateStyle ( Style $ pCellStyle , $ pRange ) { $ workbook = $ this -> parent ; if ( $ existingStyle = $ this -> parent -> getCellXfByHashCode ( $ pCellStyle -> getHashCode ( ) ) ) { $ xfIndex = $ existingStyle -> getIndex ( ) ; } else { $ workbook -> addCellXf ( $ pCellStyle ) ; $ xfIndex = $ pCellStyle -> getIndex ( ) ; } list ( $ rangeStart , $ rangeEnd ) = Coordinate :: rangeBoundaries ( $ pRange . ':' . $ pRange ) ; if ( $ rangeStart [ 0 ] > $ rangeEnd [ 0 ] && $ rangeStart [ 1 ] > $ rangeEnd [ 1 ] ) { $ tmp = $ rangeStart ; $ rangeStart = $ rangeEnd ; $ rangeEnd = $ tmp ; } for ( $ col = $ rangeStart [ 0 ] ; $ col <= $ rangeEnd [ 0 ] ; ++ $ col ) { for ( $ row = $ rangeStart [ 1 ] ; $ row <= $ rangeEnd [ 1 ] ; ++ $ row ) { $ this -> getCell ( Coordinate :: stringFromColumnIndex ( $ col ) . $ row ) -> setXfIndex ( $ xfIndex ) ; } } return $ this ; }
12516	public static function delete ( $ path ) { if ( ! Folder :: exists ( $ path ) ) { return true ; } $ path = Path :: clean ( $ path ) ; if ( trim ( $ path ) === '' ) { throw new Exception ( Helper :: getTranslation ( 'FAILED_DELETING' ) . ' : Cannot delete root path' ) ; } $ fs = new Filesystem ( ) ; try { $ fs -> remove ( $ path ) ; } catch ( IOExceptionInterface $ e ) { throw new Exception ( Helper :: getTranslation ( 'FAILED_DELETING' ) . ' - (' . $ e -> getMessage ( ) . ')' ) ; } return true ; }
3512	public function getInsertTranslationsElement ( $ translation , $ timeStamp ) { return '(' . self :: dbValue ( $ translation -> status , Translation :: STATUS_SAVED ) . ',' . self :: dbValue ( $ translation -> locale ) . ',' . self :: dbValue ( $ translation -> group ) . ',' . self :: dbValue ( $ translation -> key ) . ',' . self :: dbValue ( $ translation -> value ) . ',' . self :: dbValue ( $ translation -> created_at , $ timeStamp ) . ',' . self :: dbValue ( $ translation -> updated_at , $ timeStamp ) . ',' . self :: dbValue ( $ translation -> source ) . ',' . self :: dbValue ( $ translation -> saved_value ) . ',' . self :: dbValue ( $ translation -> is_deleted , 0 ) . ',' . self :: dbValue ( $ translation -> was_used , 0 ) . ')' ; }
11409	public function showAction ( Request $ request , Application $ app ) { $ options = array ( 'twig' => $ app [ "twig" ] , 'template_assets' => $ app [ "red_kite_cms.template_assets" ] , "configuration_handler" => $ app [ "red_kite_cms.configuration_handler" ] , "plugin_manager" => $ app [ "red_kite_cms.plugin_manager" ] , ) ; return parent :: show ( $ options ) ; }
9081	private static function parseParameters ( Request & $ req , $ serverVars ) { self :: parseElement ( $ req , $ serverVars , 'HTTP_ACCEPT' , 'Accept' ) ; self :: parseElement ( $ req , $ serverVars , 'HTTP_ACCEPT_LANGUAGE' , 'Accept-Language' ) ; self :: parseElement ( $ req , $ serverVars , 'HTTP_ACCEPT_ENCODING' , 'Accept-Encoding' ) ; self :: parseElement ( $ req , $ serverVars , 'HTTP_UA_CPU' , 'User-Agent-CPU' ) ; self :: parseElement ( $ req , $ serverVars , 'HTTP_USER_AGENT' , 'User-Agent' ) ; self :: parseElement ( $ req , $ serverVars , 'HTTP_HOST' , 'Host' ) ; self :: parseElement ( $ req , $ serverVars , 'HTTP_CACHE_COTROL' , 'Cache-Control' ) ; self :: parseElement ( $ req , $ serverVars , 'HTTP_CONNECTION' , 'Connection' ) ; self :: parseElement ( $ req , $ serverVars , 'HTTP_X_FORWARDED_FOR' , 'X-Forwarded-For' ) ; if ( isset ( $ req -> params [ 'Accept-Language' ] ) ) { $ accepted = explode ( ',' , $ req -> params [ 'Accept-Language' ] ) ; $ req -> params [ 'Accept-Language-Best' ] = $ accepted [ 0 ] ; foreach ( $ accepted as $ acceptedLang ) { $ matches = array ( ) ; if ( preg_match ( "/^((?i)[a-z]{2}[-_](?:[a-z]{2}){1,2}(?:_[a-z]{2})?).*/" , $ acceptedLang , $ matches ) ) { $ req -> params [ 'Accept-Language-Best' ] = $ matches [ 1 ] ; break ; } } } }
8859	private function _hardCopy ( string $ originDir , string $ targetDir ) : string { $ this -> filesystem -> mkdir ( $ targetDir , 0777 ) ; $ this -> filesystem -> mirror ( $ originDir , $ targetDir , Finder :: create ( ) -> ignoreDotFiles ( false ) -> in ( $ originDir ) ) ; return AssetsInstallCommand :: METHOD_COPY ; }
1148	protected function getAttributeName ( $ attribute ) { $ attributeArray = explode ( '.' , $ attribute ) ; if ( count ( $ attributeArray ) > 1 ) { return $ attributeArray [ 0 ] . '[' . implode ( '][' , array_slice ( $ attributeArray , 1 ) ) . ']' ; } return $ attribute ; }
5600	public static function getSeverityAsString ( $ severity ) { static $ map = array ( E_ERROR => 'E_ERROR' , E_WARNING => 'E_WARNING' , E_PARSE => 'E_PARSE' , E_NOTICE => 'E_NOTICE' , E_CORE_ERROR => 'E_CORE_ERROR' , E_CORE_WARNING => 'E_CORE_WARNING' , E_COMPILE_ERROR => 'E_COMPILE_ERROR' , E_COMPILE_WARNING => 'E_COMPILE_WARNING' , E_USER_ERROR => 'E_USER_ERROR' , E_USER_WARNING => 'E_USER_WARNING' , E_USER_NOTICE => 'E_USER_NOTICE' , E_STRICT => 'E_STRICT' , E_RECOVERABLE_ERROR => 'E_RECOVERABLE_ERROR' , E_DEPRECATED => 'E_DEPRECATED' , E_USER_DEPRECATED => 'E_USER_DEPRECATED' , E_ALL => 'E_ALL' ) ; return $ map [ $ severity ] ; }
3375	public function open ( $ file ) { if ( strlen ( $ file ) >= 1 && $ file [ 0 ] == '@' ) { try { if ( $ this -> fileLocator instanceof FileLocatorInterface ) { $ file = $ this -> fileLocator -> locate ( $ file ) ; } else { $ this -> fileLocator -> locateResource ( $ file ) ; } } catch ( \ InvalidArgumentException $ exception ) { if ( $ this -> throwException || false == $ this -> fallbackImage ) { throw $ exception ; } $ file = $ this -> fallbackImage ; } } return $ this -> createInstance ( $ file ) ; }
10666	public function setReportUri ( string $ reportUri ) : void { if ( ! $ this -> enableProtection ) { throw new MiddlewareException ( $ this , "You can't set the report URI because the XSS protection is disabled" ) ; } if ( $ this -> blockMode ) { throw new MiddlewareException ( $ this , sprintf ( "You can't set the report URI because the block mode is already enabled (see %s)" , 'https://developer.mozilla.org/docs/Web/HTTP/Headers/X-XSS-Protection' ) ) ; } $ this -> reportUri = $ reportUri ; }
3507	private function doDiff ( $ from_text , $ to_text ) { $ this -> last_edit = false ; $ this -> stackpointer = 0 ; $ this -> from_text = $ from_text ; $ this -> from_offset = 0 ; if ( empty ( $ this -> granularityStack ) ) { return ; } $ this -> _processGranularity ( $ from_text , $ to_text ) ; }
9370	public function handle ( ServerRequestInterface $ request ) { $ callback = new CallbackHandler ( self :: $ container ) ; if ( static :: $ container -> has ( self :: MIDDLEWARE ) ) { $ middleware = static :: $ container -> get ( self :: MIDDLEWARE ) ; $ delegate = new Delegate ( $ callback ) ; $ result = $ middleware -> process ( $ request , $ delegate ) ; } return isset ( $ result ) ? $ result : $ callback ( $ request ) ; }
3483	public function withMutableContent ( bool $ mutableContent ) : Aps { $ cloned = clone $ this ; $ cloned -> mutableContent = $ mutableContent ; return $ cloned ; }
3424	protected function normalizeFilter ( ) { $ this -> substituteField ( $ this -> filter , 'GROUPS' , 'GROUPS_ID' ) ; $ this -> substituteField ( $ this -> filter , 'GROUP_ID' , 'GROUPS_ID' ) ; return $ this -> filter ; }
133	public function getInstaller ( $ type ) { $ type = strtolower ( $ type ) ; if ( isset ( $ this -> cache [ $ type ] ) ) { return $ this -> cache [ $ type ] ; } foreach ( $ this -> installers as $ installer ) { if ( $ installer -> supports ( $ type ) ) { return $ this -> cache [ $ type ] = $ installer ; } } throw new \ InvalidArgumentException ( 'Unknown installer type: ' . $ type ) ; }
8330	public function connect ( array $ params , $ username = null , $ password = null , array $ driverOptions = [ ] ) { if ( PlatformHelper :: isWindows ( ) ) { return $ this -> connectWindows ( $ params , $ username , $ password , $ driverOptions ) ; } return $ this -> connectUnix ( $ params , $ username , $ password , $ driverOptions ) ; }
2185	public function onInitialize ( InitializeApplicationEvent $ event ) : void { $ this -> installAssets ( $ event ) ; $ this -> installContao ( $ event ) ; $ this -> createSymlinks ( $ event ) ; }
12161	public function getIsChildless ( ) { if ( empty ( $ this -> collectorItem ) || empty ( $ this -> collectorItem -> children ) ) { return true ; } return false ; }
1095	public function children ( $ node ) { $ query = $ this -> node -> newQuery ( ) ; $ query -> where ( $ this -> node -> getQualifiedParentColumnName ( ) , '=' , $ node -> getKey ( ) ) ; foreach ( $ this -> scopedAttributes ( $ node ) as $ fld => $ value ) $ query -> where ( $ this -> qualify ( $ fld ) , '=' , $ value ) ; $ query -> orderBy ( $ this -> node -> getQualifiedLeftColumnName ( ) ) ; $ query -> orderBy ( $ this -> node -> getQualifiedRightColumnName ( ) ) ; $ query -> orderBy ( $ this -> node -> getQualifiedKeyName ( ) ) ; return $ query -> get ( ) ; }
5501	protected function checkArgumentsIsArray ( $ args , $ task ) { if ( ! is_array ( $ args ) ) { $ errormsg = sprintf ( 'Cannot %s. Parameter %s is not an array.' , $ task , $ args ) ; trigger_error ( $ errormsg , E_USER_ERROR ) ; } }
4703	protected function lint ( OutputInterface $ output , Ciconia $ ciconia , $ content ) { try { $ ciconia -> render ( $ content , array ( 'strict' => true ) ) ; $ output -> writeln ( 'No syntax errors detected.' ) ; return 0 ; } catch ( SyntaxError $ e ) { $ output -> writeln ( '<error>' . $ e -> getMessage ( ) . '</error>' ) ; return 1 ; } }
5577	public function clickImage ( $ label , $ x = 1 , $ y = 1 , $ additional = false ) { if ( ! ( $ form = $ this -> page -> getFormByImage ( new SelectByLabel ( $ label ) ) ) ) { return false ; } $ success = $ this -> load ( $ form -> getAction ( ) , $ form -> submitImage ( new SelectByLabel ( $ label ) , $ x , $ y , $ additional ) ) ; return ( $ success ? $ this -> getContent ( ) : $ success ) ; }
2237	public function generatePdf ( ) { $ this -> headline = $ this -> title ; $ this -> printable = false ; $ strArticle = $ this -> replaceInsertTags ( $ this -> generate ( ) , false ) ; $ strArticle = html_entity_decode ( $ strArticle , ENT_QUOTES , Config :: get ( 'characterSet' ) ) ; $ strArticle = $ this -> convertRelativeUrls ( $ strArticle , '' , true ) ; $ arrSearch = array ( '@<form.*</form>@Us' , '@<a [^>]*href="[^"]*javascript:[^>]+>.*</a>@Us' ) ; $ strArticle = preg_replace ( $ arrSearch , '' , $ strArticle ) ; if ( empty ( $ GLOBALS [ 'TL_HOOKS' ] [ 'printArticleAsPdf' ] ) ) { throw new \ Exception ( 'No PDF extension found. Did you forget to install contao/tcpdf-bundle?' ) ; } if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'printArticleAsPdf' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'printArticleAsPdf' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'printArticleAsPdf' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ strArticle , $ this ) ; } } }
3138	public function emptyResponse ( RunnerServiceContext $ context , $ responses ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ similar = 0 ; foreach ( $ responses as $ responseVariable ) { $ value = $ responseVariable -> getValue ( ) ; $ default = $ responseVariable -> getDefaultValue ( ) ; if ( TestRunnerUtils :: isQtiValueNull ( $ value ) === true ) { if ( TestRunnerUtils :: isQtiValueNull ( $ default ) === true ) { $ similar ++ ; } } elseif ( $ value -> equals ( $ default ) === true ) { $ similar ++ ; } } $ respCount = count ( $ responses ) ; return $ respCount > 0 && $ similar == $ respCount ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'storeItemResponse' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } }
9463	public function compose ( View $ view ) { $ this -> sidebar -> loadItemsFromConfig ( 'arcanesoft.foundation.sidebar.items' ) ; $ this -> sidebar -> setCurrent ( Arr :: get ( $ view -> getData ( ) , 'current_page' , '' ) ) ; }
8659	private function convertGetFeedSubmissionCount ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetFeedSubmissionCount' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetFeedTypeList ( ) ) { $ feedTypeList = $ request -> getFeedTypeList ( ) ; foreach ( $ feedTypeList -> getType ( ) as $ typeIndex => $ type ) { $ parameters [ 'FeedTypeList' . '.' . 'Type' . '.' . ( $ typeIndex + 1 ) ] = $ type ; } } if ( $ request -> isSetFeedProcessingStatusList ( ) ) { $ feedProcessingStatusList = $ request -> getFeedProcessingStatusList ( ) ; foreach ( $ feedProcessingStatusList -> getStatus ( ) as $ statusIndex => $ status ) { $ parameters [ 'FeedProcessingStatusList' . '.' . 'Status' . '.' . ( $ statusIndex + 1 ) ] = $ status ; } } if ( $ request -> isSetSubmittedFromDate ( ) ) { $ parameters [ 'SubmittedFromDate' ] = $ this -> getFormattedTimestamp ( $ request -> getSubmittedFromDate ( ) ) ; } if ( $ request -> isSetSubmittedToDate ( ) ) { $ parameters [ 'SubmittedToDate' ] = $ this -> getFormattedTimestamp ( $ request -> getSubmittedToDate ( ) ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
12563	public function sendNews ( $ message , $ to = null ) { return $ this -> send ( self :: MSG_TYPE_NEWS , $ message , $ to ) ; }
3663	private function getValueFromServiceContainer ( $ valueName , $ arguments ) { if ( ! empty ( $ arguments [ 'service' ] ) ) { $ serviceName = $ arguments [ 'service' ] ; } else { $ serviceName = $ valueName ; } $ service = $ this -> container -> get ( IMetaModelsServiceContainer :: class ) -> getService ( $ serviceName ) ; if ( is_callable ( $ service ) ) { return call_user_func ( $ service , $ valueName , $ arguments ) ; } return 'NULL' ; }
1102	protected function hasChange ( ) { return ! ( $ this -> bound1 ( ) == $ this -> node -> getRight ( ) || $ this -> bound1 ( ) == $ this -> node -> getLeft ( ) ) ; }
8752	public function addDefinition ( $ identifier , DefinitionInterface $ definition ) { $ this -> definitions [ $ identifier ] = $ definition ; unset ( $ this -> dumpableDefinitions [ $ identifier ] ) ; }
11284	protected function _populateNonModelData ( $ record ) { $ nonObjectData = array_diff_key ( $ record , $ this -> model_attributes ) ; if ( count ( $ nonObjectData ) > 0 ) { foreach ( $ nonObjectData as $ key => $ value ) { $ this -> $ key = $ value ; } } }
4147	protected function getResponse ( ) { $ url = $ this -> getUrl ( ) ; $ params = array ( 'get' => $ this -> getParams , 'post' => $ this -> postParams , 'headers' => $ this -> buildRequestHeader ( ) , ) ; return $ this -> curl -> send ( $ url , $ params ) ; }
7303	public function onParentChange ( ResourceEventInterface $ event ) { $ customer = $ this -> getCustomerFromEvent ( $ event ) ; if ( $ this -> updateFromParent ( $ customer ) ) { $ this -> persistenceHelper -> persistAndRecompute ( $ customer , true ) ; } }
10411	public function invalidate ( ) { $ script = escapeshellcmd ( $ this -> rootDir . "/../{$this->cacheScript}" ) ; $ urlsFile = escapeshellarg ( $ this -> createUrlsTempFile ( ) ) ; $ curlTimeout = escapeshellarg ( $ this -> curlTimeout ) ; $ process = new Process ( sprintf ( '%s %s %s' , $ script , $ urlsFile , $ curlTimeout ) ) ; $ process -> start ( ) ; $ this -> resetCache ( ) ; return $ urlsFile ; }
9317	public function perform ( $ src , $ dst ) { $ inClusterHandler = eZClusterFileHandler :: instance ( $ src ) ; $ inClusterHandler -> fetch ( ) ; try { $ this -> converter -> transform ( 'transformation' , $ src , $ dst ) ; } catch ( Exception $ e ) { $ inClusterHandler -> deleteLocal ( ) ; throw $ e ; } $ outClusterHandler = eZClusterFileHandler :: instance ( ) ; $ outClusterHandler -> fileStore ( $ dst , 'image' ) ; eZImageHandler :: changeFilePermissions ( $ dst ) ; }
1996	protected function adjustPublicationDate ( ) { if ( ! empty ( $ this -> arrItems ) && $ this -> arrItems [ 0 ] -> published > $ this -> published ) { $ this -> published = $ this -> arrItems [ 0 ] -> published ; } }
4451	public function recur ( string $ className , array $ data , ? int $ interval = null , ? int $ offset = null , ? string $ jid = null , ? int $ retries = null , ? int $ priority = null , ? int $ backlog = null , ? array $ tags = null ) { try { $ jid = $ jid ? : Uuid :: uuid4 ( ) -> toString ( ) ; } catch ( \ Exception $ e ) { throw new RuntimeException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } $ data = json_encode ( $ data , JSON_UNESCAPED_SLASHES ) ; if ( empty ( $ data ) ) { throw new RuntimeException ( sprintf ( 'Unable to encode payload to make a recurring job "%s" for the "%s" queue.' , $ jid , $ this -> name ) ) ; } return $ this -> client -> recur ( $ this -> name , $ jid , $ className , $ data , 'interval' , is_null ( $ interval ) ? 60 : $ interval , is_null ( $ offset ) ? 0 : $ offset , 'priority' , is_null ( $ priority ) ? 0 : $ priority , 'tags' , json_encode ( $ tags ? : [ ] , JSON_UNESCAPED_SLASHES ) , 'retries' , is_null ( $ retries ) ? 5 : $ retries , 'backlog' , is_null ( $ backlog ) ? 0 : $ backlog ) ; }
12596	protected function doWeNeedToMinify ( SplFileInfo $ file ) : bool { return ( ! $ this -> debug && ! Str :: s ( $ file -> getFilename ( ) ) -> contains ( '.min.' ) ) ; }
3005	static public function ping ( \ Base $ f3 , $ params ) { $ hash = $ params [ 'hash' ] ; if ( $ f3 -> exists ( 'mailer.on.ping' , $ ping_handler ) ) $ f3 -> call ( $ ping_handler , array ( $ hash ) ) ; $ img = new \ Image ( ) ; $ img -> load ( base64_decode ( 'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMA' . 'AAAl21bKAAAABGdBTUEAALGPC/xhBQAAAANQTFRFAAAAp3o92gAAAAF0U' . 'k5TAEDm2GYAAAAKSURBVAjXY2AAAAACAAHiIbwzAAAAAElFTkSuQmCC' ) ) ; $ img -> render ( ) ; }
9511	public function delete ( Log $ log ) { $ this -> authorize ( LogViewerPolicy :: PERMISSION_DELETE ) ; $ date = $ log -> date ; if ( $ this -> logViewer -> delete ( $ date ) ) { $ this -> notifySuccess ( $ message = trans ( 'foundation::log-viewer.messages.deleted.message' , compact ( 'date' ) ) , trans ( 'foundation::log-viewer.messages.deleted.title' ) ) ; return $ this -> jsonResponseSuccess ( compact ( 'message' ) ) ; } return $ this -> jsonResponseError ( [ 'message' => "An error occurred while deleting the log [$date]" ] ) ; }
1141	public function setValue ( $ value ) { if ( \ is_bool ( $ value ) ) { if ( 'checkbox' !== $ this -> type ) { throw new \ InvalidArgumentException ( \ sprintf ( 'Invalid argument of type "%s"' , \ gettype ( $ value ) ) ) ; } if ( $ value ) { if ( ! $ this -> element -> isSelected ( ) ) { $ this -> element -> click ( ) ; } } elseif ( $ this -> element -> isSelected ( ) ) { $ this -> element -> click ( ) ; } return ; } foreach ( ( array ) $ value as $ v ) { $ this -> selector -> selectByValue ( $ v ) ; } }
5057	private function getClassName ( $ requestedName ) { $ exp = explode ( '/' , $ requestedName ) ; $ className = array_shift ( $ exp ) . '\\Controller\\' . implode ( '\\' , $ exp ) . 'Controller' ; if ( ! class_exists ( $ className ) ) { throw new ServiceNotCreatedException ( sprintf ( 'Can\'t find correct controller class for "%s"' , $ requestedName ) ) ; } return $ className ; }
8030	public function takeFreeProcess ( ) { if ( $ this -> getFreeProcessesCount ( ) === 0 ) { return NULL ; } $ freePid = array_shift ( $ this -> freeProcessIds ) ; if ( $ freePid === NULL ) { return NULL ; } return $ this -> getProcessDetails ( $ freePid ) ; }
3645	public function old ( string $ key , $ default = null , bool $ trim = true , bool $ clean = true ) { $ value = $ this -> request -> old ( $ key , $ default ) ; return $ this -> clean ( $ value , $ trim , $ clean ) ; }
1119	public function scopeLimitDepth ( $ query , $ limit ) { $ depth = $ this -> exists ? $ this -> getDepth ( ) : $ this -> getLevel ( ) ; $ max = $ depth + $ limit ; $ scopes = array ( $ depth , $ max ) ; return $ query -> whereBetween ( $ this -> getDepthColumnName ( ) , array ( min ( $ scopes ) , max ( $ scopes ) ) ) ; }
5415	public function fetch ( $ timeout ) { $ socket = $ this -> route -> createConnection ( $ this -> encoding -> getMethod ( ) , $ timeout ) ; if ( ! $ socket -> isError ( ) ) { $ this -> dispatchRequest ( $ socket , $ this -> encoding ) ; } return $ this -> createResponse ( $ socket ) ; }
12236	public function insertPI ( $ target , $ data = null , $ mode = 'before' ) { $ tmp = dom_import_simplexml ( $ this ) ; $ doc = $ tmp -> ownerDocument ; if ( isset ( $ data ) ) { if ( is_array ( $ data ) ) { $ str = '' ; foreach ( $ data as $ k => $ v ) { $ str .= $ k . '="' . htmlspecialchars ( $ v ) . '" ' ; } $ data = substr ( $ str , 0 , - 1 ) ; } else { $ data = ( string ) $ data ; } $ pi = $ doc -> createProcessingInstruction ( $ target , $ data ) ; } else { $ pi = $ doc -> createProcessingInstruction ( $ target ) ; } if ( $ pi !== false ) { $ this -> insertNode ( $ tmp , $ pi , $ mode ) ; } return $ this ; }
12027	function addExecuteMethod ( ) { $ body = $ this -> generateCreateFragment ( ) ; $ body .= 'return $this->dispatch($request);' ; $ docBlock = $ this -> generateExecuteDocBlock ( 'Execute the operation, returning the parsed response' ) ; $ methodGenerator = new MethodGenerator ( 'execute' ) ; $ methodGenerator -> setBody ( $ body ) ; $ methodGenerator -> setDocBlock ( $ docBlock ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; }
2843	public function getBlockTreeHtml ( ) { $ content = '' ; $ rootNodes = $ this -> getBlocksAsTree ( ) ; foreach ( $ rootNodes as $ rootNode ) { $ content .= $ this -> renderTreeNode ( $ rootNode ) ; } return $ content ; }
6078	public function createComment ( $ mediaId , Comment $ comment ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'comment' => $ comment ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/media/' . $ mediaId . '/comments' , $ parameters ) ; $ result = new CommentResponse ( $ result ) ; return $ result ; }
9492	private function getApplicationSize ( ) { $ size = cache ( ) -> remember ( 'foundation.app.size' , 5 , function ( ) { return $ this -> getFolderSize ( base_path ( ) ) ; } ) ; return $ this -> formatSize ( $ size ) ; }
10885	protected function makeRequest ( $ data ) { $ url = 'https://www.errorstream.com/api/1.0/errors/create?' . http_build_query ( [ 'api_token' => $ this -> api_token , 'project_token' => $ this -> project_token ] ) ; try { $ ch = curl_init ( ) ; curl_setopt ( $ ch , CURLOPT_URL , $ url ) ; curl_setopt ( $ ch , CURLOPT_POST , true ) ; curl_setopt ( $ ch , CURLOPT_POSTFIELDS , json_encode ( $ data ) ) ; curl_setopt ( $ ch , CURLOPT_HTTPHEADER , array ( 'Content-Type:application/json' ) ) ; curl_setopt ( $ ch , CURLOPT_RETURNTRANSFER , true ) ; $ result = curl_exec ( $ ch ) ; curl_close ( $ ch ) ; return $ result ; } catch ( \ Exception $ ex ) { return $ ex -> getMessage ( ) ; } }
10329	public function set_images ( $ post_id , $ post , $ update ) { App :: setCurrentID ( 'EFG' ) ; if ( Module :: CustomImagesGrifus ( ) -> getOption ( 'replace-when-add' ) ) { $ is_insert_post = App :: main ( ) -> is_after_insert_post ( $ post , $ update ) ; $ is_update_post = App :: main ( ) -> is_after_update_post ( $ post , $ update ) ; if ( $ is_insert_post || $ is_update_post ) { $ this -> model -> set_images ( $ post_id ) ; } } }
5003	protected function getConfig ( $ services , $ name ) { $ defaults = [ 'service' => 'EventManager' , 'configure' => true , 'identifiers' => [ $ name ] , 'event' => '\Zend\EventManager\Event' , 'listeners' => [ ] , ] ; $ config = $ services -> get ( 'Config' ) ; $ config = isset ( $ config [ 'event_manager' ] [ $ name ] ) ? $ config [ 'event_manager' ] [ $ name ] : [ ] ; $ config = array_replace_recursive ( $ defaults , $ config ) ; return $ config ; }
12276	private function buildTemplatesMap ( ) { if ( ! empty ( $ this -> templatesMap ) ) { return $ this -> templatesMap ; } $ this -> templatesMap = [ ] ; foreach ( $ this -> templatesPaths as $ templatesPath => $ templatesNamespace ) { if ( ! is_readable ( $ templatesPath ) ) { throw new \ RuntimeException ( "Templates path '$templatesPath' does not exist or is not readable." ) ; } foreach ( glob ( $ templatesPath . '/*.phtml' ) as $ templatePath ) { $ template = pathinfo ( $ templatePath , PATHINFO_FILENAME ) ; if ( $ templatesNamespace !== null ) { $ template .= '@' . $ templatesNamespace ; } if ( array_key_exists ( $ template , $ this -> templatesMap ) ) { throw new \ OverflowException ( "Can't import template '$template' from '$templatePath' as a template with the same name already exists at '{$this->templatesMap[$template]}'. You may want to use namespaces." ) ; } $ this -> templatesMap [ $ template ] = $ templatePath ; } } return $ this -> templatesMap ; }
12321	protected function prepareData ( InputInterface $ input ) { $ return = [ ] ; foreach ( $ this -> validators as $ validator ) { $ result = $ validator -> validate ( $ input ) ; if ( isset ( $ result ) && is_array ( $ result ) ) { $ return = NestedArray :: mergeDeep ( $ return , $ result ) ; } elseif ( isset ( $ result ) ) { $ return [ ] = $ result ; } } return $ return ; }
11022	public function listTasks ( $ ostr = STDOUT ) { $ this -> findTasks ( ) ; if ( count ( $ this -> task_list ) === 0 ) { fprintf ( $ ostr , "No tasks available\n" ) ; } else { fprintf ( $ ostr , "Listing available tasks: \n" ) ; foreach ( $ this -> task_list as $ task => $ desc ) { $ task = str_replace ( '\\' , ':' , $ task ) ; fprintf ( $ ostr , "- %-30s" , $ task ) ; CLI :: formatText ( 32 , CLI :: MAX_LINE_LENGTH , ' ' . $ desc , $ ostr ) ; } printf ( "\n" ) ; } }
8567	private function _convertGetShipment ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetShipment' ; if ( $ request -> isSetSellerId ( ) ) { $ parameters [ 'SellerId' ] = $ request -> getSellerId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } if ( $ request -> isSetShipmentId ( ) ) { $ parameters [ 'ShipmentId' ] = $ request -> getShipmentId ( ) ; } return $ parameters ; }
9240	public function renderLanguageSwitcher ( ) { return $ this -> _View -> element ( $ this -> config ( 'element' ) , [ 'availableLanguages' => $ this -> config ( 'availableLanguages' ) , 'displayNames' => $ this -> config ( 'displayNames' ) , 'imageMapping' => $ this -> config ( 'imageMapping' ) , 'renderToggleButtonDisplayName' => $ this -> config ( 'renderToggleButtonDisplayName' ) ] ) ; }
10722	public function count ( $ col , $ alias , $ distinct = false ) { $ this -> counts [ ] = [ $ col , $ alias , $ distinct ] ; return $ this ; }
2118	public function generateSqlForm ( ) { @ trigger_error ( 'Using the Installer::generateSqlForm() method has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; $ count = 0 ; $ return = '' ; $ sql_command = $ this -> compileCommands ( ) ; if ( empty ( $ sql_command ) ) { return '' ; } $ _SESSION [ 'sql_commands' ] = array ( ) ; $ arrOperations = array ( 'CREATE' => $ GLOBALS [ 'TL_LANG' ] [ 'tl_install' ] [ 'CREATE' ] , 'ALTER_ADD' => $ GLOBALS [ 'TL_LANG' ] [ 'tl_install' ] [ 'ALTER_ADD' ] , 'ALTER_CHANGE' => $ GLOBALS [ 'TL_LANG' ] [ 'tl_install' ] [ 'ALTER_CHANGE' ] , 'ALTER_DROP' => $ GLOBALS [ 'TL_LANG' ] [ 'tl_install' ] [ 'ALTER_DROP' ] , 'DROP' => $ GLOBALS [ 'TL_LANG' ] [ 'tl_install' ] [ 'DROP' ] ) ; foreach ( $ arrOperations as $ command => $ label ) { if ( \ is_array ( $ sql_command [ $ command ] ) ) { $ return .= ' <tr> <td colspan="2" class="tl_col_0">' . $ label . '</td> </tr>' ; $ return .= ' <tr> <td class="tl_col_1"><input type="checkbox" id="check_all_' . $ count . '" class="tl_checkbox" onclick="Backend.toggleCheckboxElements(this, \'' . strtolower ( $ command ) . '\')"></td> <td class="tl_col_2"><label for="check_all_' . $ count . '" style="color:#a6a6a6"><em>' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'selectAll' ] . '</em></label></td> </tr>' ; foreach ( $ sql_command [ $ command ] as $ vv ) { $ key = md5 ( $ vv ) ; $ _SESSION [ 'sql_commands' ] [ $ key ] = $ vv ; $ return .= ' <tr> <td class="tl_col_1"><input type="checkbox" name="sql[]" id="sql_' . $ count . '" class="tl_checkbox ' . strtolower ( $ command ) . '" value="' . $ key . '"' . ( ( stripos ( $ command , 'DROP' ) === false ) ? ' checked="checked"' : '' ) . '></td> <td class="tl_col_2"><pre><label for="sql_' . $ count ++ . '">' . $ vv . '</label></pre></td> </tr>' ; } } } return '<div id="sql_wrapper"> <table id="sql_table">' . $ return . ' </table></div>' ; }
10801	public function renderPageHistoricContentFiltersActionsAction ( ) { $ melisPageHistoricTable = $ this -> getServiceLocator ( ) -> get ( 'MelisPagehistoricTable' ) ; $ actions = $ melisPageHistoricTable -> getPageHistoricListOfActions ( ) -> toArray ( ) ; $ translator = $ this -> getServiceLocator ( ) -> get ( 'translator' ) ; $ options = '<option value="">' . $ translator -> translate ( 'tr_melispagehistoric_filter_action_select' ) . '</option>' ; foreach ( $ actions as $ action ) { $ options .= '<option value="' . $ action [ 'action' ] . '">' . $ action [ 'action' ] . '</option>' ; } $ view = new ViewModel ( ) ; $ view -> options = $ options ; return $ view ; }
3494	public function withCertificatePassPhrase ( string $ passPhrase ) : Request { $ cloned = clone $ this ; $ cloned -> certificatePassPhrase = $ passPhrase ; return $ cloned ; }
511	protected function formatOptionHelp ( $ name , $ required , $ type , $ defaultValue , $ comment ) { $ comment = trim ( $ comment ) ; $ type = trim ( $ type ) ; if ( strncmp ( $ type , 'bool' , 4 ) === 0 ) { $ type = 'boolean, 0 or 1' ; } if ( $ defaultValue !== null && ! is_array ( $ defaultValue ) ) { if ( $ type === null ) { $ type = gettype ( $ defaultValue ) ; } if ( is_bool ( $ defaultValue ) ) { $ defaultValue = ( int ) $ defaultValue ; } if ( is_string ( $ defaultValue ) ) { $ defaultValue = "'" . $ defaultValue . "'" ; } else { $ defaultValue = var_export ( $ defaultValue , true ) ; } $ doc = "$type (defaults to $defaultValue)" ; } else { $ doc = $ type ; } if ( $ doc === '' ) { $ doc = $ comment ; } elseif ( $ comment !== '' ) { $ doc .= "\n" . preg_replace ( '/^/m' , ' ' , $ comment ) ; } $ name = $ required ? "$name (required)" : $ name ; return $ doc === '' ? $ name : "$name: $doc" ; }
3395	protected function attemptLogin ( Request $ request ) { if ( $ this -> guard ( ) -> validate ( $ this -> credentials ( $ request ) ) ) { $ user = $ this -> guard ( ) -> getLastAttempted ( ) ; if ( ! is_null ( $ user -> confirmed_at ) ) { return $ this -> baseAttemptLogin ( $ request ) ; } session ( [ 'confirmation_user_id' => $ user -> getKey ( ) ] ) ; throw ValidationException :: withMessages ( [ 'confirmation' => [ __ ( 'confirmation::confirmation.not_confirmed' , [ 'resend_link' => route ( 'auth.resend_confirmation' ) ] ) ] ] ) ; } return false ; }
1666	protected function enableTwoFactor ( BackendUser $ user , $ return ) { if ( $ user -> useTwoFactor ) { return ; } $ container = System :: getContainer ( ) ; $ verifyHelp = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'twoFactorVerificationHelp' ] ; $ authenticator = $ container -> get ( 'contao.security.two_factor.authenticator' ) ; if ( Input :: post ( 'FORM_SUBMIT' ) == 'tl_two_factor' ) { if ( $ authenticator -> validateCode ( $ user , Input :: post ( 'verify' ) ) ) { $ user -> useTwoFactor = '1' ; $ user -> save ( ) ; throw new RedirectResponseException ( $ return ) ; } $ this -> Template -> error = true ; $ verifyHelp = $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'invalidTwoFactor' ] ; } if ( ! $ user -> secret ) { $ user -> secret = random_bytes ( 128 ) ; $ user -> save ( ) ; } $ request = $ container -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; $ this -> Template -> enable = true ; $ this -> Template -> secret = Base32 :: encodeUpperUnpadded ( $ user -> secret ) ; $ this -> Template -> textCode = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'twoFactorTextCode' ] ; $ this -> Template -> qrCode = base64_encode ( $ authenticator -> getQrCode ( $ user , $ request ) ) ; $ this -> Template -> scan = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'twoFactorScan' ] ; $ this -> Template -> verify = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'twoFactorVerification' ] ; $ this -> Template -> verifyHelp = $ verifyHelp ; }
10654	public function __isset ( $ propertyName ) { $ methodName = 'get' . $ propertyName ; if ( method_exists ( $ this , $ methodName ) ) { return ( $ this -> $ methodName ( ) !== null ) ; } else { return false ; } }
11897	public function getStatusLog ( $ checkRecent = false ) { if ( ! isset ( $ this -> _statusLog ) ) { $ this -> _statusLog = Cacher :: get ( [ get_called_class ( ) , $ this -> primaryKey , $ this -> created ] ) ; if ( empty ( $ this -> _statusLog ) ) { if ( is_null ( $ this -> message ) ) { $ this -> _statusLog = $ this -> _startStatus ( ) ; } else { $ this -> _statusLog = unserialize ( $ this -> message ) ; } } elseif ( $ checkRecent ) { $ testStatusLog = unserialize ( $ this -> message ) ; if ( $ testStatusLog && $ testStatusLog -> lastUpdate > $ this -> _statusLog -> lastUpdate ) { $ this -> _statusLog = $ testStatusLog ; } } if ( empty ( $ this -> _statusLog ) ) { $ this -> _statusLog = new Status ( ) ; } } $ this -> _statusLog -> log = $ this ; return $ this -> _statusLog ; }
9954	public function mergeCellsByColumnAndRow ( $ columnIndex1 , $ row1 , $ columnIndex2 , $ row2 ) { $ cellRange = Coordinate :: stringFromColumnIndex ( $ columnIndex1 ) . $ row1 . ':' . Coordinate :: stringFromColumnIndex ( $ columnIndex2 ) . $ row2 ; return $ this -> mergeCells ( $ cellRange ) ; }
3606	public function get ( $ name ) { if ( ! isset ( $ this -> httpHandlers [ $ name ] ) ) { throw new \ Exception ( "HttpHandler {$name} not found" ) ; } return $ this -> httpHandlers [ $ name ] ; }
316	public function renderAjax ( $ view , $ params = [ ] , $ context = null ) { $ viewFile = $ this -> findViewFile ( $ view , $ context ) ; ob_start ( ) ; ob_implicit_flush ( false ) ; $ this -> beginPage ( ) ; $ this -> head ( ) ; $ this -> beginBody ( ) ; echo $ this -> renderFile ( $ viewFile , $ params , $ context ) ; $ this -> endBody ( ) ; $ this -> endPage ( true ) ; return ob_get_clean ( ) ; }
8796	public function helper ( $ name , $ directory = 'Helpers' ) { $ file = app_path ( $ directory . DIRECTORY_SEPARATOR . $ name . '.php' ) ; if ( file_exists ( $ file ) ) { return require $ file ; } throw new ExceptionHandler ( 'Oppss! File not found.' , 'Helper::' . $ name . ' not found.' ) ; }
6786	public function buildHeaders ( $ options ) { $ options = $ this -> resolve ( $ options ) ; $ headerOptions = [ ] ; foreach ( $ this -> headerParameters as $ key => $ isHeaderParameter ) { if ( $ isHeaderParameter && isset ( $ options [ $ key ] ) ) { $ headerOptions [ $ key ] = $ options [ $ key ] ; } } return $ headerOptions ; }
8448	public function broadcastMsg ( array $ peers , $ msg ) { $ peerList = $ this -> formatPeers ( $ peers ) ; return $ this -> exec ( 'broadcast ' . $ peerList . ' ' . $ msg ) ; }
1980	public static function generateUnwrapped ( $ strScope = TL_MODE , $ blnRaw = false ) { $ session = System :: getContainer ( ) -> get ( 'session' ) ; if ( ! $ session -> isStarted ( ) ) { return '' ; } $ strMessages = '' ; $ flashBag = $ session -> getFlashBag ( ) ; foreach ( static :: getTypes ( ) as $ strType ) { $ strClass = strtolower ( $ strType ) ; $ arrMessages = $ flashBag -> get ( static :: getFlashBagKey ( $ strType , $ strScope ) ) ; foreach ( array_unique ( $ arrMessages ) as $ strMessage ) { if ( $ strType == 'TL_RAW' || $ blnRaw ) { $ strMessages .= $ strMessage ; } else { $ strMessages .= '<p class="' . $ strClass . '">' . $ strMessage . '</p>' ; } } } return trim ( $ strMessages ) ; }
2234	public function showDeletedRecords ( $ data , $ row ) { $ arrData = Contao \ StringUtil :: deserialize ( $ row [ 'data' ] ) ; foreach ( $ arrData as $ strTable => $ arrTableData ) { Contao \ System :: loadLanguageFile ( $ strTable ) ; Contao \ Controller :: loadDataContainer ( $ strTable ) ; foreach ( $ arrTableData as $ arrRow ) { $ arrBuffer = array ( ) ; foreach ( $ arrRow as $ i => $ v ) { if ( \ is_array ( Contao \ StringUtil :: deserialize ( $ v ) ) ) { continue ; } if ( isset ( $ GLOBALS [ 'TL_DCA' ] [ $ strTable ] [ 'fields' ] [ $ i ] [ 'label' ] ) ) { $ label = \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ strTable ] [ 'fields' ] [ $ i ] [ 'label' ] ) ? $ GLOBALS [ 'TL_DCA' ] [ $ strTable ] [ 'fields' ] [ $ i ] [ 'label' ] [ 0 ] : $ GLOBALS [ 'TL_DCA' ] [ $ strTable ] [ 'fields' ] [ $ i ] [ 'label' ] ; } else { $ label = \ is_array ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ i ] ) ? $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ i ] [ 0 ] : $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ i ] ; } if ( ! $ label ) { $ label = $ i ; } $ arrBuffer [ $ label ] = $ v ; } $ data [ $ strTable ] [ ] = $ arrBuffer ; } } return $ data ; }
6751	private function createQualifiedTransformerClass ( ) { $ reflection = new ReflectionClass ( __CLASS__ ) ; $ name = $ reflection -> getName ( ) ; $ qualifiedTransformerClass = $ name . "Transformer" ; $ this -> setTransformer ( $ qualifiedTransformerClass ) ; }
6276	protected function readInt31 ( $ pos = 0 ) { $ uint31 = $ this -> readInt32 ( $ pos ) ; if ( $ uint31 > 0x7fffffff ) { throw new Exception ( 'Error in CDB file "' . $ this -> fileName . '", integer too big.' ) ; } return $ uint31 ; }
9126	private function requestImpl ( string $ requestType ) { if ( $ requestType == 'HEAD' ) { $ this -> setTimeout ( 1 ) ; } $ ms = $ this -> prepareRequest ( $ requestType ) ; $ ms = $ this -> appendPayloadToRequest ( $ ms ) ; if ( ! $ this -> isConnected ( ) ) { $ this -> connect ( ) ; } while ( $ ms -> ready ( ) ) { $ this -> write ( $ ms -> read ( 1024 ) ) ; } $ this -> retrieveAndParseResponse ( $ requestType ) ; if ( $ this -> getHeader ( 'Connection' ) == 'close' ) { $ this -> disconnect ( ) ; } }
3665	private function convertParameterAggregate ( $ var , $ arguments ) { $ var = ( array ) $ var ; if ( ! empty ( $ arguments [ 'recursive' ] ) ) { $ var = iterator_to_array ( new \ RecursiveIteratorIterator ( new \ RecursiveArrayIterator ( $ var ) ) ) ; } if ( ! $ var ) { return 'NULL' ; } if ( ! empty ( $ arguments [ 'key' ] ) ) { $ var = array_keys ( $ var ) ; } else { $ var = array_values ( $ var ) ; } if ( $ arguments [ 'aggregate' ] == 'set' ) { $ this -> addParameter ( implode ( ',' , $ var ) ) ; return '?' ; } $ this -> addParameters ( $ var ) ; return rtrim ( str_repeat ( '?,' , count ( $ var ) ) , ',' ) ; }
7755	private function doDeserialize ( $ data , $ entity ) { $ metadata = $ this -> hydraApi -> getMetadataFor ( get_class ( $ entity ) ) ; if ( null === $ metadata ) { throw new \ Exception ( sprintf ( '"%s" cannot be serialized as it is not documented.' , get_class ( $ data ) ) ) ; } $ vocabPrefix = $ this -> router -> generate ( 'hydra_vocab' , array ( ) , true ) . '#' ; $ typeIri = ( $ metadata -> isExternalReference ( ) ) ? $ metadata -> getIri ( ) : $ vocabPrefix . $ metadata -> getIri ( ) ; $ graph = JsonLD :: getDocument ( $ data ) -> getGraph ( ) ; $ node = $ graph -> getNodesByType ( $ typeIri ) ; if ( 1 !== count ( $ node ) ) { throw new RuntimeException ( 'The passed data contains ' . count ( $ node ) . ' nodes of the type ' . $ typeIri . '; expected 1.' ) ; } $ node = reset ( $ node ) ; foreach ( $ metadata -> getProperties ( ) as $ property ) { if ( $ property -> isReadOnly ( ) ) { continue ; } if ( null !== ( $ route = $ property -> getRoute ( ) ) ) { continue ; } $ propertyIri = ( $ property -> isExternalReference ( ) ) ? $ property -> getIri ( ) : $ vocabPrefix . $ property -> getIri ( ) ; $ value = $ node -> getProperty ( $ propertyIri ) ; if ( $ value instanceof \ ML \ JsonLD \ Value ) { $ value = $ value -> getValue ( ) ; } if ( ! is_null ( $ value ) && $ this -> hydraApi -> hasNormalizer ( $ property -> getType ( ) ) ) { $ normalizer = $ this -> hydraApi -> getNormalizer ( $ property -> getType ( ) ) ; $ value = $ normalizer -> denormalize ( $ value , $ property -> getType ( ) ) ; } $ property -> setValue ( $ entity , $ value ) ; } return $ entity ; }
7949	public function updateDomainProperties ( $ domain , $ properties ) { self :: getClient ( ) -> updateDomainProperties ( $ this -> sn , $ domain , $ properties ) ; }
8488	public static function getLoad ( ) { $ wmi = Windows :: getInstance ( ) ; $ load = [ ] ; foreach ( $ wmi -> ExecQuery ( "SELECT LoadPercentage FROM Win32_Processor" ) as $ cpu ) { $ load [ ] = $ cpu -> LoadPercentage ; } return round ( array_sum ( $ load ) / count ( $ load ) , 2 ) . "%" ; }
8238	protected function outputModulesConfiguration ( ParameterBag $ post ) { $ modulesClasses = array ( ) ; $ modulesNames = array ( ) ; foreach ( $ this -> modules as $ key => $ value ) { if ( $ post -> has ( $ key ) ) { $ modulesClasses [ ] = $ value ; $ modulesNames [ ] = $ key ; } } $ config = array ( self :: CONFIG_PLUGIN_KEY => array ( self :: CONFIG_MODULES_KEY => $ modulesClasses ) ) ; $ yaml = \ Symfony \ Component \ Yaml \ Yaml :: dump ( $ config , 2 , 4 ) ; $ this -> picoAuth -> addOutput ( "installer_modules_config" , $ yaml ) ; $ this -> picoAuth -> addOutput ( "installer_modules_names" , $ modulesNames ) ; }
7387	public static final function generateThumbnailsFrom ( $ files , array $ size ) { foreach ( $ files as $ file ) { self :: generateThumbnail ( $ file -> getRecord ( ) , $ size ) ; } }
8969	protected function initialize ( ) { if ( ! file_exists ( dirname ( $ this -> pathToFile ) ) && ! mkdir ( dirname ( $ this -> pathToFile ) , 0777 , true ) ) { throw new RuntimeException ( sprintf ( 'Could not create storage file on path "%s".' , $ this -> pathToFile ) ) ; } if ( ! file_exists ( $ this -> pathToFile ) && ! ( touch ( $ this -> pathToFile ) && chmod ( $ this -> pathToFile , 0777 ) ) ) { throw new RuntimeException ( sprintf ( 'Could not create storage file on path "%s".' , $ this -> pathToFile ) ) ; } if ( ! is_readable ( $ this -> pathToFile ) ) { throw new RuntimeException ( sprintf ( 'File on path "%s" for storing rates must be readable.' , $ this -> pathToFile ) ) ; } if ( ! is_writable ( $ this -> pathToFile ) ) { throw new RuntimeException ( sprintf ( 'File on path "%s" for storing rates must be writeable.' , $ this -> pathToFile ) ) ; } }
5952	public function setTransition ( $ transition ) { if ( $ transition instanceof SlideTransition ) { $ this -> transition = $ transition ; } elseif ( is_array ( $ transition ) ) { $ this -> transition = new SlideTransition ( $ transition ) ; } else { $ this -> transition = null ; trigger_error ( 'Argument must be an object of class SlideTransition. Data loss!' , E_USER_WARNING ) ; } return $ this ; }
2881	public function getBodyAction ( ) { if ( $ email = $ this -> _initEmail ( ) ) { $ this -> getResponse ( ) -> setHeader ( 'Content-Type' , $ email -> getIsPlain ( ) ? 'text/plain' : 'text/html' ) ; $ this -> getResponse ( ) -> setBody ( $ email -> getBody ( ) ) ; } }
7690	function OpenXML_ChartGetInfoFromFile ( $ idx , $ Txt = false ) { if ( $ idx === false ) return false ; $ file = $ this -> CdFileLst [ $ idx ] [ 'v_name' ] ; $ relative = ( substr_count ( $ file , '/' ) == 1 ) ? '' : '../' ; $ o = $ this -> OpenXML_Rels_GetObj ( $ file , $ relative . 'charts/' ) ; if ( $ o -> ChartLst === false ) { if ( $ Txt === false ) $ Txt = $ this -> TbsStoreGet ( $ idx , 'OpenXML_ChartGetInfoFromFile' ) ; $ o -> ChartLst = array ( ) ; $ p = 0 ; while ( $ t = clsTbsXmlLoc :: FindStartTag ( $ Txt , 'c:chart' , $ p ) ) { $ rid = $ t -> GetAttLazy ( 'r:id' ) ; $ name = false ; $ title = false ; $ descr = false ; $ parent = clsTbsXmlLoc :: FindStartTag ( $ Txt , 'wp:inline' , $ t -> PosBeg , false ) ; if ( $ parent === false ) $ parent = clsTbsXmlLoc :: FindStartTag ( $ Txt , 'p:nvGraphicFramePr' , $ t -> PosBeg , false ) ; if ( $ parent !== false ) { $ parent -> FindEndTag ( ) ; $ src = $ parent -> GetInnerSrc ( ) ; $ el = clsTbsXmlLoc :: FindStartTagHavingAtt ( $ src , 'title' , 0 ) ; if ( $ el !== false ) $ title = $ el -> GetAttLazy ( 'title' ) ; $ el = clsTbsXmlLoc :: FindStartTagHavingAtt ( $ src , 'descr' , 0 ) ; if ( $ el !== false ) $ descr = $ el -> GetAttLazy ( 'descr' ) ; } if ( isset ( $ o -> TargetLst [ $ rid ] ) ) { $ name = basename ( $ o -> TargetLst [ $ rid ] ) ; if ( substr ( $ name , - 4 ) === '.xml' ) $ name = substr ( $ name , 0 , strlen ( $ name ) - 4 ) ; } $ o -> ChartLst [ ] = array ( 'rid' => $ rid , 'title' => $ title , 'descr' => $ descr , 'name' => $ name ) ; $ p = $ t -> PosEnd ; } } return $ o -> ChartLst ; }
11079	public static function getMonthName ( $ month ) { if ( $ month < 1 || $ month > 12 ) { return '' ; } $ monthNames = [ 1 => self :: poorManTranslate ( 'fts-shared' , 'January' ) , 2 => self :: poorManTranslate ( 'fts-shared' , 'February' ) , 3 => self :: poorManTranslate ( 'fts-shared' , 'March' ) , 4 => self :: poorManTranslate ( 'fts-shared' , 'April' ) , 5 => self :: poorManTranslate ( 'fts-shared' , 'May' ) , 6 => self :: poorManTranslate ( 'fts-shared' , 'June' ) , 7 => self :: poorManTranslate ( 'fts-shared' , 'July' ) , 8 => self :: poorManTranslate ( 'fts-shared' , 'August' ) , 9 => self :: poorManTranslate ( 'fts-shared' , 'September' ) , 10 => self :: poorManTranslate ( 'fts-shared' , 'October' ) , 11 => self :: poorManTranslate ( 'fts-shared' , 'November' ) , 12 => self :: poorManTranslate ( 'fts-shared' , 'December' ) , ] ; return $ monthNames [ $ month ] ; }
4885	public function setExcludeMethods ( $ methods ) { if ( is_string ( $ methods ) ) { $ methods = array ( $ methods ) ; } foreach ( $ methods as $ method ) { $ this -> addFilter ( $ method , new MethodMatchFilter ( $ method ) , FilterComposite :: CONDITION_AND ) ; } }
3984	private function addMenu ( & $ modules , $ section , $ name , $ module , Request $ request ) { if ( ! isset ( $ modules [ $ section ] ) ) { $ modules [ $ section ] = $ this -> buildBackendMenuSection ( $ section , $ request ) ; } $ active = $ this -> isActive ( $ module [ 'route' ] , $ module [ 'param' ] , $ request ) ; $ class = 'navigation ' . $ name ; if ( isset ( $ module [ 'class' ] ) ) { $ class .= ' ' . $ module [ 'class' ] ; } if ( $ active ) { $ class .= ' active' ; } if ( $ request -> query -> has ( 'ref' ) ) { $ module [ 'param' ] [ 'ref' ] = $ request -> query -> get ( 'ref' ) ; } $ modules [ $ section ] [ 'modules' ] [ $ name ] = [ 'label' => $ module [ 'label' ] , 'title' => $ module [ 'title' ] , 'class' => $ class , 'isActive' => $ active , 'href' => $ this -> urlGenerator -> generate ( $ module [ 'route' ] , $ module [ 'param' ] ) , ] ; }
1579	public function withType ( string $ type ) : self { if ( empty ( $ type ) ) { throw new \ InvalidArgumentException ( 'Expecting a non-empty string.' ) ; } $ copy = clone $ this ; $ copy -> type = $ type ; $ copy -> normalize ( ) ; return $ copy ; }
620	protected function generateDependencyData ( $ cache ) { $ db = $ this -> db ; if ( $ db !== null ) { $ db = Instance :: ensure ( $ db ) ; } if ( ! $ this -> query instanceof QueryInterface ) { throw new InvalidConfigException ( '"' . get_class ( $ this ) . '::$query" should be an instance of "yii\db\QueryInterface".' ) ; } if ( ! empty ( $ db -> enableQueryCache ) ) { $ originEnableQueryCache = $ db -> enableQueryCache ; $ db -> enableQueryCache = false ; $ result = $ this -> executeQuery ( $ this -> query , $ db ) ; $ db -> enableQueryCache = $ originEnableQueryCache ; } else { $ result = $ this -> executeQuery ( $ this -> query , $ db ) ; } return $ result ; }
2944	public function assignRole ( $ role ) { if ( is_string ( $ role ) ) { return $ this -> roles ( ) -> attach ( Role :: where ( 'slug' , $ role ) -> first ( ) ) ; } return $ this -> roles ( ) -> attach ( $ role ) ; }
4849	protected function createDriver ( $ driverClass ) : Driver \ DriverInterface { return isset ( $ this -> container ) ? $ this -> container -> get ( $ driverClass ) : new $ driverClass ( ) ; }
2868	public function preDispatch ( ) { parent :: preDispatch ( ) ; if ( ! Mage :: helper ( 'sheep_debug' ) -> isAllowed ( ) ) { $ this -> setFlag ( '' , 'no-dispatch' , true ) ; $ this -> getResponse ( ) -> setHttpResponseCode ( 404 ) ; } }
9007	public function sort ( ) { $ this -> uasort ( function ( $ a , $ b ) { $ priority_a = ( int ) $ a -> get ( 'priority' ) ? : 500 ; $ priority_b = ( int ) $ b -> get ( 'priority' ) ? : 500 ; if ( $ priority_a == $ priority_b ) { return 0 ; } return ( $ priority_a < $ priority_b ) ? - 1 : 1 ; } ) ; return $ this ; }
5061	public function calculateWidth ( $ text , $ size = self :: TEXT_SIZE ) { $ size = $ this -> convertToPt ( $ size ) ; $ box = imagettfbbox ( $ size , 0 , $ this -> fontPath , $ text ) ; return round ( abs ( $ box [ 2 ] - $ box [ 0 ] ) + self :: SHIELD_PADDING_EXTERNAL + self :: SHIELD_PADDING_INTERNAL , 1 ) ; }
11148	public function getMultipleDisplayObjects ( $ areas ) { $ out = array ( ) ; foreach ( $ areas as $ v ) { if ( ! ( $ v instanceof Neuron_GameServer_Map_Area ) ) { throw new Neuron_Exceptions_InvalidParameter ( "Parameters must be an array of area objects." ) ; } foreach ( $ this -> getDisplayObjects ( $ v ) as $ v ) { if ( ! $ v instanceof Neuron_GameServer_Map_MapObject ) { throw new Neuron_Core_Error ( "All map objects MUST implement Neuron_GameServer_Map_MapObject" ) ; } $ out [ ] = $ v ; } } return $ out ; }
10618	public function steptwo ( ) { $ input = Input :: only ( array ( 'name' , 'email' , 'comment' , 'to_email' , 'to_name' ) ) ; $ input [ 'name' ] = $ this -> quickSanitize ( $ input [ 'name' ] ) ; $ input [ 'email' ] = $ this -> quickSanitize ( $ input [ 'email' ] ) ; $ input [ 'comment' ] = $ this -> quickSanitize ( $ input [ 'comment' ] ) ; return view ( 'lasallecmscontact::step_two_form' , [ 'input' => $ input , 'message' => false , ] ) ; }
12543	public function getLink ( ) : string { if ( $ this -> link === null ) { return str_replace ( "?" . $ _SERVER [ "QUERY_STRING" ] , "" , $ _SERVER [ "REQUEST_URI" ] ) ; } else { return $ this -> link ; } }
8468	public static function getActiveHandlersList ( ) { $ cacheKey = 'DevGroup/EventsSystem:activeHandlersList' ; $ handlers = Yii :: $ app -> cache -> get ( $ cacheKey ) ; if ( $ handlers === false ) { $ eventEventHandlers = EventEventHandler :: find ( ) -> where ( [ 'is_active' => 1 ] ) -> orderBy ( [ 'sort_order' => SORT_ASC ] ) -> asArray ( true ) -> all ( ) ; $ events = Event :: find ( ) -> where ( [ 'id' => array_column ( $ eventEventHandlers , 'event_id' , 'event_id' ) ] ) -> indexBy ( 'id' ) -> asArray ( true ) -> all ( ) ; $ eventGroups = EventGroup :: find ( ) -> where ( [ 'id' => array_column ( $ events , 'event_group_id' , 'event_group_id' ) ] ) -> indexBy ( 'id' ) -> asArray ( true ) -> all ( ) ; $ eventHandlers = EventHandler :: find ( ) -> where ( [ 'id' => array_column ( $ eventEventHandlers , 'event_handler_id' , 'event_handler_id' ) ] ) -> indexBy ( 'id' ) -> asArray ( true ) -> all ( ) ; $ handlers = [ ] ; foreach ( $ eventEventHandlers as $ eventEventHandler ) { if ( isset ( $ eventHandlers [ $ eventEventHandler [ 'event_handler_id' ] ] , $ events [ $ eventEventHandler [ 'event_id' ] ] , $ eventGroups [ $ events [ $ eventEventHandler [ 'event_id' ] ] [ 'event_group_id' ] ] ) === false ) { continue ; } try { $ data = Json :: decode ( $ eventEventHandler [ 'packed_json_params' ] ) ; } catch ( \ Exception $ e ) { $ data = [ ] ; } $ handlers [ ] = [ 'class' => $ eventGroups [ $ events [ $ eventEventHandler [ 'event_id' ] ] [ 'event_group_id' ] ] [ 'owner_class_name' ] , 'name' => $ events [ $ eventEventHandler [ 'event_id' ] ] [ 'execution_point' ] , 'callable' => [ $ eventHandlers [ $ eventEventHandler [ 'event_handler_id' ] ] [ 'class_name' ] , $ eventEventHandler [ 'method' ] , ] , 'data' => $ data , ] ; } Yii :: $ app -> cache -> set ( $ cacheKey , $ handlers , 86400 , new TagDependency ( [ 'tags' => [ NamingHelper :: getCommonTag ( EventGroup :: className ( ) ) , NamingHelper :: getCommonTag ( Event :: className ( ) ) , NamingHelper :: getCommonTag ( EventHandler :: className ( ) ) , NamingHelper :: getCommonTag ( EventEventHandler :: className ( ) ) , ] , ] ) ) ; } return $ handlers ; }
10530	public function toJson ( $ prettyPrint = false ) { $ options = 0 ; if ( $ prettyPrint ) { $ options += JSON_PRETTY_PRINT ; } return json_encode ( $ this -> items , $ options ) ; }
11577	public function actionConfirm ( $ id , $ code ) { $ user = $ this -> finder -> findUserById ( $ id ) ; if ( $ user === null || $ this -> module -> enableConfirmation == false ) { throw new NotFoundHttpException ; } $ user -> attemptConfirmation ( $ code ) ; return $ this -> render ( '/message' , [ 'title' => \ Yii :: t ( 'user' , 'Account confirmation' ) , 'module' => $ this -> module , ] ) ; }
9154	private function parseParameters ( \ ReflectionMethod $ action ) { $ params = $ action -> getParameters ( ) ; if ( count ( $ params ) < 1 ) { return false ; } $ param = $ params [ 0 ] ; assert ( $ param instanceof \ ReflectionParameter ) ; if ( ! ( $ class = $ param -> getClass ( ) ) || $ class -> getName ( ) != 'Nkey\Caribu\Mvc\Controller\Request' ) { return false ; } return true ; }
12354	public function setFilePath ( string $ viewFilePath ) : void { if ( ! is_readable ( $ viewFilePath ) ) { throw new Exception ( "The View file {$viewFilePath} isn't readable." ) ; } $ this -> filePath = $ viewFilePath ; }
12743	public function buildSlotMap ( ) { $ this -> slotmap -> reset ( ) ; foreach ( $ this -> pool as $ connectionID => $ connection ) { $ parameters = $ connection -> getParameters ( ) ; if ( ! isset ( $ parameters -> slots ) ) { continue ; } foreach ( explode ( ',' , $ parameters -> slots ) as $ slotRange ) { $ slots = explode ( '-' , $ slotRange , 2 ) ; if ( ! isset ( $ slots [ 1 ] ) ) { $ slots [ 1 ] = $ slots [ 0 ] ; } $ this -> slotmap -> setSlots ( $ slots [ 0 ] , $ slots [ 1 ] , $ connectionID ) ; } } }
8320	public function getCaptchaResultBulk ( array $ captchaIds ) { $ response = $ this -> getHttpClient ( ) -> request ( 'GET' , '/res.php?' . http_build_query ( [ 'key' => $ this -> apiKey , 'action' => 'get' , 'ids' => join ( ',' , $ captchaIds ) ] ) ) ; $ captchaTexts = $ response -> getBody ( ) -> __toString ( ) ; $ this -> getLogger ( ) -> info ( "Got bulk response: `{$captchaTexts}`." ) ; $ captchaTexts = explode ( "|" , $ captchaTexts ) ; $ result = [ ] ; foreach ( $ captchaTexts as $ index => $ captchaText ) { $ captchaText = html_entity_decode ( trim ( $ captchaText ) ) ; $ result [ $ captchaIds [ $ index ] ] = ( $ captchaText == self :: STATUS_CAPTCHA_NOT_READY ) ? false : $ captchaText ; } return $ result ; }
2132	public function add ( $ strKey , $ varValue ) { $ this -> markModified ( ) ; $ this -> arrData [ $ strKey ] = $ this -> escape ( $ varValue ) . ';' ; }
7294	public function inform_about_posts ( $ post_id = FALSE ) { if ( ! $ post_id ) { return $ post_id ; } if ( ! isset ( $ this -> transit_posts [ $ post_id ] ) ) { return $ post_id ; } $ transit = $ this -> transit_posts [ $ post_id ] ; if ( 'publish' != $ transit [ 'new_status' ] || 'publish' == $ transit [ 'old_status' ] ) { return $ post_id ; } $ post_data = get_post ( $ post_id ) ; $ user = get_userdata ( $ post_data -> post_author ) ; $ to = $ this -> get_members ( $ user -> data -> user_email , 'post' ) ; if ( empty ( $ to ) ) { return $ post_id ; } $ subject = get_option ( 'blogname' ) . ': ' . get_the_title ( $ post_data -> ID ) ; $ message = $ post_data -> post_content ; $ headers = array ( ) ; $ headers [ 'From' ] = get_the_author_meta ( 'display_name' , $ user -> ID ) . ' (' . get_bloginfo ( 'name' ) . ')' . ' <' . $ user -> data -> user_email . '>' ; if ( $ this -> options [ 'send_by_bcc' ] ) { $ bcc = $ to ; $ to = empty ( $ this -> options [ 'bcc_to_recipient' ] ) ? get_bloginfo ( 'admin_email' ) : $ this -> options [ 'bcc_to_recipient' ] ; $ headers [ 'Bcc' ] = $ bcc ; } $ to = apply_filters ( 'iac_post_to' , $ to , $ this -> options , $ post_id ) ; $ subject = apply_filters ( 'iac_post_subject' , $ subject , $ this -> options , $ post_id ) ; $ message = apply_filters ( 'iac_post_message' , $ message , $ this -> options , $ post_id ) ; $ headers = apply_filters ( 'iac_post_headers' , $ headers , $ this -> options , $ post_id ) ; $ attachments = apply_filters ( 'iac_post_attachments' , array ( ) , $ this -> options , $ post_id ) ; $ signature = apply_filters ( 'iac_post_signature' , '' , $ this -> options , $ post_id ) ; $ this -> options [ 'static_options' ] [ 'object' ] = array ( 'id' => $ post_id , 'type' => 'post' ) ; $ this -> send_mail ( $ to , $ subject , $ this -> append_signature ( $ message , $ signature ) , $ headers , $ attachments ) ; return $ post_id ; }
2314	protected function prepareImage ( ) { if ( $ this -> fileObj -> isSvgImage ) { $ imagine = System :: getContainer ( ) -> get ( 'contao.image.imagine_svg' ) ; } else { $ imagine = System :: getContainer ( ) -> get ( 'contao.image.imagine' ) ; } $ image = new NewImage ( $ this -> strRootDir . '/' . $ this -> fileObj -> path , $ imagine , System :: getContainer ( ) -> get ( 'filesystem' ) ) ; $ image -> setImportantPart ( $ this -> prepareImportantPart ( ) ) ; return $ image ; }
4131	public function createLuceneQuery ( $ designDocName , $ viewName ) { $ luceneHandlerName = $ this -> config -> getLuceneHandlerName ( ) ; $ designDoc = $ this -> config -> getDesignDocument ( $ designDocName ) ; if ( $ designDoc ) { $ designDoc = new $ designDoc [ 'className' ] ( $ designDoc [ 'options' ] ) ; } $ query = new ODMLuceneQuery ( $ this -> couchDBClient -> getHttpClient ( ) , $ this -> couchDBClient -> getDatabase ( ) , $ luceneHandlerName , $ designDocName , $ viewName , $ designDoc ) ; $ query -> setDocumentManager ( $ this ) ; return $ query ; }
9018	public function getActionWords ( $ string , $ language = 'english' ) { $ words = $ this -> getWords ( $ string ) ; $ filter = new ActionWordsFilter ( $ language ) ; $ actionWords = [ ] ; foreach ( $ words as $ word ) { $ word = $ this -> removePunctuation ( $ word ) ; if ( ! is_null ( $ filter -> filter ( $ word ) ) ) { $ actionWords [ ] = $ word ; } } return $ actionWords ; }
10422	public function addToInsertList ( $ key , $ value , $ isString = true ) { $ this -> sqlInsertList [ $ key ] = [ 'value' => $ value , 'string' => $ isString , ] ; }
5797	public static function getRouteName ( bool $ isAdmin = true , string $ routePrefix = null , string $ routeType = null , string $ requestMethod = null ) : string { $ routeName = '' ; if ( $ isAdmin ) { $ routeName .= ROUTEPREFIX_ADMIN ; } if ( $ routePrefix !== null ) { $ routeName .= '.' . $ routePrefix ; } if ( $ requestMethod !== null ) { $ validActionMethods = [ 'put' , 'post' ] ; if ( ! in_array ( $ requestMethod , $ validActionMethods ) ) { throw new \ Exception ( "Invalid request method $requestMethod. Only post and put accepted in route names." ) ; } $ routeName .= '.' . $ requestMethod ; } if ( $ routeType !== null ) { if ( ! in_array ( $ routeType , self :: VALID_ROUTE_TYPES ) ) { throw new \ Exception ( "Invalid route type $routeType" ) ; } $ routeName .= '.' . $ routeType ; } return $ routeName ; }
9692	private function compileString ( $ str ) { $ result = null ; try { $ result = $ this -> parser -> compile ( $ str ) ; } catch ( \ Exception $ e ) { throw new SyntaxErrorException ( "Syntax error in $this->currFile: " . $ e -> getMessage ( ) ) ; } return $ result ; }
4790	function insert_update ( array $ unique , array $ insert , array $ update = array ( ) ) { if ( ! $ update ) { $ update = $ insert ; } $ insert = $ unique + $ insert ; $ values = "(" . implode ( ", " , array_keys ( $ insert ) ) . ") VALUES " . $ this -> quote ( $ insert ) ; if ( $ this -> notORM -> driver == "mysql" ) { $ set = array ( ) ; if ( ! $ update ) { $ update = $ unique ; } $ quoteChar = $ this -> getQuoteChar ( ) ; foreach ( $ update as $ key => $ val ) { $ set [ ] = "{$quoteChar}{$key}{$quoteChar} = " . $ this -> quote ( $ val ) ; } return $ this -> insert ( "$values ON DUPLICATE KEY UPDATE " . implode ( ", " , $ set ) ) ; } else { $ connection = $ this -> notORM -> connection ; $ errorMode = $ connection -> getAttribute ( PDO :: ATTR_ERRMODE ) ; $ connection -> setAttribute ( PDO :: ATTR_ERRMODE , PDO :: ERRMODE_EXCEPTION ) ; try { $ return = $ this -> insert ( $ values ) ; $ connection -> setAttribute ( PDO :: ATTR_ERRMODE , $ errorMode ) ; return $ return ; } catch ( PDOException $ e ) { $ connection -> setAttribute ( PDO :: ATTR_ERRMODE , $ errorMode ) ; if ( $ e -> getCode ( ) == "23000" || $ e -> getCode ( ) == "23505" ) { if ( ! $ update ) { return 0 ; } $ clone = clone $ this ; $ return = $ clone -> where ( $ unique ) -> update ( $ update ) ; return ( $ return ? $ return + 1 : $ return ) ; } if ( $ errorMode == PDO :: ERRMODE_EXCEPTION ) { throw $ e ; } elseif ( $ errorMode == PDO :: ERRMODE_WARNING ) { trigger_error ( "PDOStatement::execute(): " . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } } return 0 ; }
4754	public function startProfiling ( ) { if ( PHP_SAPI == 'cli' ) { $ _SERVER [ 'REMOTE_ADDR' ] = null ; $ _SERVER [ 'REQUEST_URI' ] = $ _SERVER [ 'SCRIPT_NAME' ] ; } if ( function_exists ( 'xhprof_enable' ) && count ( $ this -> probes ) > 0 ) { $ this -> profiling = true ; xhprof_enable ( $ this -> memory ? XHPROF_FLAGS_MEMORY : null ) ; } }
9520	public function getAliasUsage ( $ withEncapsulation = true ) { $ aliases = '' ; foreach ( $ this -> aliases as $ prefix => $ alias ) { if ( $ withEncapsulation ) { $ aliases = ( $ aliases == '' ) ? ' (' : $ aliases ; $ aliases .= ' ' . $ prefix . $ alias ; } else { $ aliases = ( $ aliases == '' ) ? $ prefix . $ alias : $ aliases . ', ' . $ prefix . $ alias ; } } if ( $ withEncapsulation ) { $ aliases .= ( $ aliases == '' ) ? '' : ' )' ; } return $ aliases ; }
1427	protected function modelRelationForField ( $ field ) { return $ this -> camelCaseRelations ? Str :: camelize ( $ field ) : Str :: underscore ( $ field ) ; }
8314	protected function finishPasswordReset ( array $ resetData ) { if ( time ( ) > $ resetData [ 'validity' ] ) { $ this -> session -> remove ( "pwreset" ) ; $ this -> session -> addFlash ( "error" , "Page validity expired, please try again." ) ; $ this -> picoAuth -> redirectToLogin ( ) ; } $ this -> picoAuth -> addOutput ( "isReset" , true ) ; $ this -> picoAuth -> setRequestFile ( $ this -> picoAuth -> getPluginPath ( ) . '/content/pwreset.md' ) ; $ post = $ this -> httpRequest -> request ; if ( $ post -> has ( "new_password" ) && $ post -> has ( "new_password_repeat" ) ) { $ newPassword = new Password ( $ post -> get ( "new_password" ) ) ; $ newPasswordRepeat = new Password ( $ post -> get ( "new_password_repeat" ) ) ; $ username = $ resetData [ 'user' ] ; if ( ! $ this -> picoAuth -> isValidCSRF ( $ post -> get ( "csrf_token" ) ) ) { $ this -> picoAuth -> redirectToPage ( "password_reset" ) ; } if ( $ newPassword -> get ( ) !== $ newPasswordRepeat -> get ( ) ) { $ this -> session -> addFlash ( "error" , "The passwords do not match." ) ; $ this -> picoAuth -> redirectToPage ( "password_reset" ) ; } $ localAuth = $ this -> picoAuth -> getContainer ( ) -> get ( 'LocalAuth' ) ; if ( ! $ localAuth -> checkPasswordPolicy ( $ newPassword ) ) { $ this -> picoAuth -> redirectToPage ( "password_reset" ) ; } $ this -> session -> remove ( "pwreset" ) ; $ userData = $ this -> storage -> getUserByName ( $ username ) ; $ localAuth -> userDataEncodePassword ( $ userData , $ newPassword ) ; $ this -> storage -> saveUser ( $ username , $ userData ) ; $ this -> logPasswordReset ( $ username ) ; $ localAuth -> login ( $ username , $ userData ) ; $ this -> picoAuth -> afterLogin ( ) ; } }
9635	public function read ( $ path , $ blocking = false ) { $ size = filesize ( $ path ) ; if ( $ size === 0 ) { return '' ; } $ flockFlags = $ blocking ? LOCK_SH : LOCK_SH | LOCK_NB ; $ file = fopen ( $ path , 'r' ) ; if ( ! flock ( $ file , $ flockFlags ) ) { fclose ( $ file ) ; throw new IOException ( "Could not aquire file lock for file: $path" ) ; } $ contents = fread ( $ file , $ size ) ; flock ( $ file , LOCK_UN | LOCK_NB ) ; fclose ( $ file ) ; return $ contents ; }
2091	public function generate ( ) { if ( TL_MODE == 'BE' ) { $ objTemplate = new BackendTemplate ( 'be_wildcard' ) ; $ objTemplate -> wildcard = '### ' . Utf8 :: strtoupper ( $ GLOBALS [ 'TL_LANG' ] [ 'CTE' ] [ 'form' ] [ 0 ] ) . ' ###' ; $ objTemplate -> id = $ this -> id ; $ objTemplate -> link = $ this -> title ; $ objTemplate -> href = 'contao/main.php?do=form&amp;table=tl_form_field&amp;id=' . $ this -> id ; return $ objTemplate -> parse ( ) ; } if ( $ this -> customTpl != '' && TL_MODE == 'FE' ) { $ this -> strTemplate = $ this -> customTpl ; } return parent :: generate ( ) ; }
12266	public function renderCmsBlocks ( array $ blocks , $ username , array $ options = array ( ) ) { $ tmp = array ( ) ; foreach ( $ blocks as $ block ) { $ tmp [ ] = $ this -> renderCmsBlock ( $ block , $ username , $ options ) ; } return implode ( "\n" , $ tmp ) ; }
6225	public function cd ( array $ path ) : void { array_unshift ( $ path , $ this -> path ) ; $ this -> path = new Path ( $ path ) ; }
1813	public function setRteSyntax ( $ varValue , Contao \ DataContainer $ dc ) { switch ( $ dc -> activeRecord -> highlight ) { case 'C' : case 'CSharp' : $ syntax = 'c_cpp' ; break ; case 'CSS' : case 'Diff' : case 'Groovy' : case 'HTML' : case 'Java' : case 'JavaScript' : case 'Perl' : case 'PHP' : case 'PowerShell' : case 'Python' : case 'Ruby' : case 'Scala' : case 'SQL' : case 'Text' : case 'YAML' : $ syntax = strtolower ( $ dc -> activeRecord -> highlight ) ; break ; case 'VB' : $ syntax = 'vbscript' ; break ; case 'XML' : case 'XHTML' : $ syntax = 'xml' ; break ; default : $ syntax = 'text' ; break ; } if ( $ dc -> activeRecord -> type == 'markdown' ) { $ syntax = 'markdown' ; } $ GLOBALS [ 'TL_DCA' ] [ 'tl_content' ] [ 'fields' ] [ 'code' ] [ 'eval' ] [ 'rte' ] = 'ace|' . $ syntax ; return $ varValue ; }
12460	private function getDefaultGroupsId ( ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ customFieldsGroupIds = $ em -> createQuery ( 'SELECT g.id FROM ' . 'ChillCustomFieldsBundle:CustomFieldsDefaultGroup d ' . 'JOIN d.customFieldsGroup g' ) -> getResult ( Query :: HYDRATE_SCALAR ) ; $ result = array ( ) ; foreach ( $ customFieldsGroupIds as $ row ) { $ result [ ] = $ row [ 'id' ] ; } return $ result ; }
1605	public function findAllRedirects ( $ currentSiteOnly = false ) { if ( $ currentSiteOnly ) return RedirectRecord :: find ( ) -> where ( '[[siteId]] IS NULL OR [[siteId]] = ' . \ Craft :: $ app -> sites -> currentSite -> id ) -> orderBy ( 'siteId asc' ) -> all ( ) ; return array_reduce ( RedirectRecord :: find ( ) -> all ( ) , function ( $ a , RedirectRecord $ record ) { $ a [ $ record -> siteId ?? 'null' ] [ ] = $ record ; return $ a ; } , array_reduce ( \ Craft :: $ app -> sites -> allSiteIds , function ( $ a , $ id ) { $ a [ $ id ] = [ ] ; return $ a ; } , [ ] ) ) ; }
6732	protected function processMessage ( & $ message ) { if ( ! $ message instanceof \ Closure ) { return ; } $ callback = $ message ; $ message = $ callback ( $ this -> model ) ; }
7637	public function getBlobProperties ( $ containerName = '' , $ blobName = '' , $ snapshotId = null , $ leaseId = null ) { Assertion :: notEmpty ( $ containerName , 'Container name is not specified' ) ; self :: assertValidContainerName ( $ containerName ) ; Assertion :: notEmpty ( $ blobName , 'Blob name is not specified.' ) ; self :: assertValidRootContainerBlobName ( $ containerName , $ blobName ) ; return $ this -> getBlobInstance ( $ containerName , $ blobName , $ snapshotId , $ leaseId ) ; }
11756	public function unmarkElect ( $ msgId , $ index , $ commentId ) { $ params = [ 'msg_data_id' => $ msgId , 'index' => $ index , 'user_comment_id' => $ commentId , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_UNMARK_ELECT , $ params ] ) ; }
6601	protected function buildUrl ( $ url , $ params = [ ] ) { if ( $ this -> useOauth ) { $ params [ 'access_token' ] = $ this -> getAccessToken ( ) ; } $ params = http_build_query ( $ params ) ; return $ this -> baseUrl . $ url . '?' . $ params ; }
7905	public function renderToggleButton ( ) { if ( $ this -> toggleButton !== false ) { $ tag = ArrayHelper :: remove ( $ this -> toggleButton , 'tag' , 'div' ) ; $ label = ArrayHelper :: remove ( $ this -> toggleButton , 'label' , Html :: tag ( 'i' , '' , [ 'class' => 'content icon' ] ) ) ; Html :: addCssClass ( $ this -> toggleButton , 'ui' ) ; Html :: addCssClass ( $ this -> toggleButton , 'launch-sidebar icon' ) ; Html :: addCssClass ( $ this -> toggleButton , 'button' ) ; Html :: addCssClass ( $ this -> toggleButton , 'fixed' ) ; Html :: addCssClass ( $ this -> toggleButton , 'attached' ) ; if ( $ this -> position === static :: POS_LEFT ) { $ position = static :: POS_RIGHT ; } else { $ position = static :: POS_LEFT ; } Html :: addCssClass ( $ this -> toggleButton , $ position ) ; $ view = $ this -> getView ( ) ; DosAmigosAsset :: register ( $ view ) ; $ view -> registerJs ( 'dosamigos.semantic.init();' ) ; return Html :: tag ( $ tag , $ label , $ this -> toggleButton ) ; } else { return null ; } }
10700	public static function isMobilePhoneNumber ( $ phone ) { $ phoneNumber = substr ( Tools :: removeSpace ( $ phone ) , - 9 , 1 ) ; return ( ! self :: isCzechPhoneNumber ( $ phoneNumber ) || ( $ phoneNumber === '6' || $ phoneNumber === '7' ) ) ; }
6896	public function set ( $ key , $ value ) { $ this -> open ( ) ; $ this -> _data [ $ key ] = $ value ; return $ this ; }
2356	public function hasBackendUser ( ) : bool { $ token = $ this -> getToken ( BackendUser :: SECURITY_SESSION_KEY ) ; return null !== $ token && $ token -> getUser ( ) instanceof BackendUser ; }
3983	private function buildBackendMenuSection ( $ groupName , Request $ request ) { $ strRefererId = $ request -> attributes -> get ( '_contao_referer_id' ) ; $ label = $ this -> translator -> trans ( 'MOD.' . $ groupName , [ ] , 'contao_modules' ) ; if ( \ is_array ( $ label ) ) { $ label = $ label [ 0 ] ; } return [ 'class' => ' node-expanded' , 'title' => StringUtil :: specialchars ( $ this -> translator -> trans ( 'MSC.collapseNode' , [ ] , 'contao_modules' ) ) , 'label' => $ label , 'href' => $ this -> urlGenerator -> generate ( 'contao_backend' , [ 'do' => $ request -> get ( 'do' ) , 'mtg' => $ groupName , 'ref' => $ strRefererId ] ) , 'ajaxUrl' => $ this -> urlGenerator -> generate ( 'contao_backend' ) , 'icon' => 'modPlus.gif' , 'modules' => [ ] , ] ; }
1701	protected function decToUnix ( $ intTime , $ intDate ) { return mktime ( ( $ intTime & 0xf800 ) >> 11 , ( $ intTime & 0x07e0 ) >> 5 , ( $ intTime & 0x001f ) << 1 , ( $ intDate & 0x01e0 ) >> 5 , ( $ intDate & 0x001f ) , ( ( $ intDate & 0xfe00 ) >> 9 ) + 1980 ) ; }
1795	private function addFrontendRoute ( RouteCollection $ routes , array $ defaults ) : void { $ route = new Route ( '/{alias}' . $ this -> urlSuffix , $ defaults , [ 'alias' => '.+' ] ) ; $ this -> addLocaleToRoute ( $ route ) ; $ routes -> add ( 'contao_frontend' , $ route ) ; }
1274	private function createRequestLandedCost ( LandedCostRequest $ landedCostRequest ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; $ tradeabilityRequest = $ xml -> appendChild ( $ xml -> createElement ( 'LandedCostRequest' ) ) ; $ tradeabilityRequest -> setAttribute ( 'xml:lang' , 'en-US' ) ; $ request = $ tradeabilityRequest -> appendChild ( $ xml -> createElement ( 'Request' ) ) ; $ node = $ xml -> importNode ( $ this -> createTransactionNode ( ) , true ) ; $ request -> appendChild ( $ node ) ; $ request -> appendChild ( $ xml -> createElement ( 'RequestAction' , 'LandedCost' ) ) ; if ( $ landedCostRequest -> getQueryRequest ( ) !== null ) { $ tradeabilityRequest -> appendChild ( $ landedCostRequest -> getQueryRequest ( ) -> toNode ( $ xml ) ) ; } return $ xml -> saveXML ( ) ; }
5072	public function getHtmlMenu ( $ markup , $ topLevel = 1 , $ depth = 6 , RendererInterface $ renderer = null ) { if ( ! $ renderer ) { $ renderer = new ListRenderer ( new Matcher ( ) , [ 'currentClass' => 'active' , 'ancestorClass' => 'active_ancestor' ] ) ; } return $ renderer -> render ( $ this -> getMenu ( $ markup , $ topLevel , $ depth ) ) ; }
3778	protected function getLabel ( ) { if ( null === ( $ attribute = $ this -> getFilteredAttribute ( ) ) ) { return null ; } if ( $ label = $ this -> get ( 'label' ) ) { return $ label ; } return $ attribute -> getName ( ) ; }
29	private function filterRequiredPackages ( RepositoryInterface $ repo , PackageInterface $ package , $ bucket = array ( ) ) { $ requires = array_keys ( $ package -> getRequires ( ) ) ; $ packageListNames = array_keys ( $ bucket ) ; $ packages = array_filter ( $ repo -> getPackages ( ) , function ( $ package ) use ( $ requires , $ packageListNames ) { return in_array ( $ package -> getName ( ) , $ requires ) && ! in_array ( $ package -> getName ( ) , $ packageListNames ) ; } ) ; $ bucket = $ this -> appendPackages ( $ packages , $ bucket ) ; foreach ( $ packages as $ package ) { $ bucket = $ this -> filterRequiredPackages ( $ repo , $ package , $ bucket ) ; } return $ bucket ; }
10594	public function getViewData ( ) { if ( $ this -> view !== NULL ) return $ this -> view ; $ this -> view = new \ stdClass ; try { $ this -> initMainApplicationProperties ( ) ; if ( $ this -> router === NULL ) return $ this -> view ; $ this -> initViewPanelTitle ( ) ; $ this -> initViewPanelTableData ( ) ; $ this -> initViewPanelRequestedUrlData ( ) ; } catch ( \ Exception $ e ) { $ this -> _debug ( $ e ) ; $ this -> _debug ( $ e -> getTrace ( ) ) ; } $ this -> view -> _debugCode = $ this -> _debugCode ; return $ this -> view ; }
2280	protected static function httpAcceptLanguage ( ) { $ arrAccepted = array ( ) ; $ arrLanguages = array ( ) ; preg_match_all ( '/([a-z]{1,8}(-[a-z]{1,8})?)\s*(;\s*q\s*=\s*(1|0\.[0-9]+))?/i' , $ _SERVER [ 'HTTP_ACCEPT_LANGUAGE' ] , $ arrAccepted ) ; foreach ( $ arrAccepted [ 1 ] as $ v ) { $ chunks = explode ( '-' , $ v ) ; if ( isset ( $ chunks [ 1 ] ) ) { $ locale = $ chunks [ 0 ] . '-' . strtoupper ( $ chunks [ 1 ] ) ; if ( preg_match ( '/^[a-z]{2}(-[A-Z]{2})?$/' , $ locale ) ) { $ arrLanguages [ ] = $ locale ; } } $ locale = $ chunks [ 0 ] ; if ( preg_match ( '/^[a-z]{2}$/' , $ locale ) ) { $ arrLanguages [ ] = $ locale ; } } return \ array_slice ( array_unique ( $ arrLanguages ) , 0 , 8 ) ; }
3140	public function hasFeedbacks ( RunnerServiceContext $ context , $ itemRef ) { $ hasFeedbacks = false ; $ displayFeedbacks = $ this -> displayFeedbacks ( $ context ) ; if ( $ displayFeedbacks ) { $ feedbacks = $ this -> getFeedbacks ( $ context , $ itemRef ) ; foreach ( $ feedbacks as $ entry ) { if ( isset ( $ entry [ 'feedbackRules' ] ) ) { if ( count ( $ entry [ 'feedbackRules' ] ) > 0 ) { $ hasFeedbacks = true ; } break ; } } } return $ hasFeedbacks ; }
10592	public function display ( $ level = 0 ) { $ value = $ this -> getContent ( ) ; if ( null === $ value ) { $ value = 'null' ; } elseif ( is_object ( $ value ) ) { $ value = get_class ( $ value ) ; } elseif ( is_array ( $ value ) ) { $ value = 'Array' ; } $ ret = str_repeat ( ' ' , $ level * 4 ) . $ value . "\n" ; $ children = $ this -> getChildren ( ) ; foreach ( $ children as $ child ) { $ ret .= $ child -> display ( $ level + 1 ) ; } return $ ret ; }
421	public function init ( ) { parent :: init ( ) ; if ( strncmp ( $ this -> db -> driverName , 'oci' , 3 ) !== 0 && strncmp ( $ this -> db -> driverName , 'odbc' , 4 ) !== 0 ) { throw new InvalidConfigException ( 'In order to use OracleMutex connection must be configured to use Oracle database.' ) ; } }
6220	public function authorize ( $ appId , $ appKey = null , $ credentials_or_service_id , $ usage = null ) { $ url = $ this -> getHost ( ) . "/transactions/authorize.xml" ; $ params = array ( 'app_id' => $ appId ) ; if ( $ credentials_or_service_id instanceof ThreeScaleClientCredentials ) { $ params [ 'service_token' ] = $ credentials_or_service_id -> service_token ; $ params [ 'service_id' ] = $ credentials_or_service_id -> service_id ; } else { $ params [ 'provider_key' ] = $ this -> getProviderKey ( ) ; $ params [ 'service_id' ] = $ credentials_or_service_id ; } if ( $ appKey ) { $ params [ 'app_key' ] = $ appKey ; } if ( $ usage ) { $ params [ 'usage' ] = $ usage ; } $ httpResponse = $ this -> httpClient -> get ( $ url , $ params ) ; if ( self :: isHttpSuccess ( $ httpResponse ) ) { return $ this -> buildAuthorizeResponse ( $ httpResponse -> body ) ; } else { return $ this -> processError ( $ httpResponse ) ; } }
10896	public function setHost ( $ host ) { foreach ( $ this -> uris as $ name => $ uri ) { $ this -> add ( $ name , $ uri -> withHost ( $ host ) ) ; } }
759	public function setChildren ( $ children ) { $ this -> _children = [ ] ; foreach ( $ children as $ child ) { $ child -> parent = $ this ; $ this -> _children [ ] = $ child ; } $ this -> updateCollectionOffsets ( ) ; }
8076	public function post ( $ endpoint , $ data , $ query = [ ] ) { $ endpoint = $ this -> buildUri ( $ endpoint , $ query ) ; $ headers = $ this -> buildHeaders ( ) ; $ data = $ this -> prepareData ( $ data ) ; $ this -> response = $ this -> client -> post ( $ endpoint , $ data , $ headers ) ; return $ this -> response ; }
3553	protected function set ( $ key , $ value , $ group = 'default' ) { $ this -> setMetaKey ( $ key ) ; $ this -> setValue ( $ value ) ; $ this -> setMetaGroup ( $ group ) ; }
7540	function index ( $ count_all = true ) { if ( ! $ this -> parent ) { return - 1 ; } elseif ( $ count_all ) { return $ this -> parent -> findChild ( $ this ) ; } else { $ index = - 1 ; foreach ( array_keys ( $ this -> parent -> children ) as $ k ) { if ( ! $ this -> parent -> children [ $ k ] -> isTextOrComment ( ) ) { ++ $ index ; } if ( $ this -> parent -> children [ $ k ] === $ this ) { return $ index ; } } return - 1 ; } }
1185	public function resolver ( $ field ) { return function ( $ translator , $ data , $ rules , $ messages , $ customAttributes ) use ( $ field ) { return $ this -> resolve ( $ translator , $ data , $ rules , $ messages , $ customAttributes , $ field ) ; } ; }
1792	private function addHostToContext ( RequestContext $ context , array $ parameters , int & $ referenceType ) : void { [ $ host , $ port ] = $ this -> getHostAndPort ( $ parameters [ '_domain' ] ) ; if ( $ context -> getHost ( ) === $ host ) { return ; } $ context -> setHost ( $ host ) ; $ referenceType = UrlGeneratorInterface :: ABSOLUTE_URL ; if ( ! $ port ) { return ; } if ( isset ( $ parameters [ '_ssl' ] ) && true === $ parameters [ '_ssl' ] ) { $ context -> setHttpsPort ( $ port ) ; } else { $ context -> setHttpPort ( $ port ) ; } }
11971	public function handleCommand ( Event $ event , Queue $ queue ) { if ( $ this -> validateParams ( $ event ) ) { $ params = $ event -> getCustomParams ( ) ; $ results = array ( ) ; $ total = 0 ; $ count = $ params [ 0 ] ; $ sides = ( isset ( $ params [ 1 ] ) ) ? $ params [ 1 ] : $ this -> defaultDieSides ; for ( $ roll = 1 ; $ roll <= $ count ; $ roll ++ ) { $ rollResult = $ this -> doRoll ( $ sides ) ; $ results [ ] = $ rollResult ; $ total += $ rollResult ; } $ response = $ this -> generateResponse ( $ event , $ total , $ results ) ; $ this -> sendIrcResponseLine ( $ event , $ queue , $ response ) ; } else { $ this -> handleCommandHelp ( $ event , $ queue ) ; } }
2985	protected function generateIndexView ( $ dir ) { $ this -> renderFile ( 'crud/views/index.html.twig.twig' , $ dir . '/index.html.twig' , array ( 'bundle' => $ this -> bundle -> getName ( ) , 'entity' => $ this -> entity , 'entity_pluralized' => $ this -> entityPluralized , 'entity_singularized' => $ this -> entitySingularized , 'identifier' => $ this -> metadata -> identifier [ 0 ] , 'fields' => $ this -> metadata -> fieldMappings , 'actions' => $ this -> actions , 'record_actions' => $ this -> getRecordActions ( ) , 'route_prefix' => $ this -> routePrefix , 'route_name_prefix' => $ this -> routeNamePrefix , ) ) ; }
4110	protected function arrayToTabList ( array $ array , array $ skipKeys = array ( ) , $ indentationLevel = 1 ) { $ output = '' ; foreach ( $ array as $ key => $ value ) { if ( in_array ( $ key , $ skipKeys , true ) ) { continue ; } $ output .= $ this -> tabsForIndentation ( $ indentationLevel ) ; if ( ! is_array ( $ value ) ) { if ( ! is_int ( $ key ) ) { $ output .= ucfirst ( $ key ) . ":\n" ; $ output .= $ this -> tabsForIndentation ( $ indentationLevel + 1 ) ; } $ output .= $ value . "\n" ; } else { $ output .= ucfirst ( $ key ) . ":\n" ; $ output .= $ this -> arrayToTabList ( $ value , $ skipKeys , $ indentationLevel + 1 ) ; } } return $ output ; }
4715	public function split ( $ pattern , $ flags = PREG_SPLIT_DELIM_CAPTURE ) { return new Collection ( array_map ( function ( $ item ) { return new static ( $ item ) ; } , preg_split ( $ pattern , $ this -> text , - 1 , $ flags ) ) ) ; }
10464	private function deductionForDeletion ( $ connection , $ tableName , $ documentType , $ documentId , $ shopId ) { $ sql = sprintf ( "SELECT `id` FROM {$tableName} WHERE `type` != 'D' AND `document_type` = :documentType AND `document_id` = :documentId AND `status` = :status AND `id` < :id" ) ; $ statement = $ connection -> prepare ( $ sql ) ; $ statement -> execute ( [ 'documentType' => $ documentType , 'documentId' => $ documentId , 'status' => self :: STATUS_NEW , 'id' => $ connection -> lastInsertId ( ) , ] ) ; $ entries = $ statement -> fetchAll ( ) ; foreach ( $ entries as $ entry ) { $ this -> removeRecord ( $ entry [ 'id' ] , [ $ shopId ] ) ; } }
5751	public function deleteByPrimaryKey ( $ primaryKeyValue , ? string $ returnField = null ) : ? string { if ( null === $ role = $ this -> getObjectById ( ( int ) $ primaryKeyValue ) ) { throw new Exceptions \ QueryResultsNotFoundException ( "Role not found: id $primaryKeyValue" ) ; } if ( ! $ role -> isDeletable ( ( int ) $ primaryKeyValue ) ) { throw new Exceptions \ UnallowedActionException ( "Role in use: id $primaryKeyValue" ) ; } return parent :: deleteByPrimaryKey ( $ primaryKeyValue , $ returnField ) ; }
11555	private function getBonusTotals ( $ dsBegin , $ dsEnd ) { $ query = $ this -> qbGetBonusTotals -> build ( ) ; $ conn = $ query -> getConnection ( ) ; $ bind = [ QBGetTotals :: BND_PERIOD_BEGIN => $ dsBegin , QBGetTotals :: BND_PERIOD_END => $ dsEnd ] ; $ rs = $ conn -> fetchAll ( $ query , $ bind ) ; $ result = [ ] ; foreach ( $ rs as $ one ) { $ accId = $ one [ QBGetTotals :: A_ACC_ID ] ; $ custId = $ one [ QBGetTotals :: A_CUST_ID ] ; $ total = $ one [ QBGetTotals :: A_TOTAL ] ; if ( $ custId ) { $ item = new DTotal ( ) ; $ item -> accountId = $ accId ; $ item -> customerId = $ custId ; $ item -> total = $ total ; $ result [ $ custId ] = $ item ; } } return $ result ; }
1592	protected function validateResource ( ) : bool { $ identifier = $ this -> validateTypeAndId ( ) ; $ attributes = $ this -> validateAttributes ( ) ; $ relationships = $ this -> validateRelationships ( ) ; if ( $ attributes && $ relationships ) { return $ this -> validateAllFields ( ) && $ identifier ; } return $ identifier && $ attributes && $ relationships ; }
9015	function getRoot ( ) { $ sm = $ this -> sl -> getServiceLocator ( ) ; $ event = $ sm -> get ( 'Application' ) -> getMvcEvent ( ) ; return $ event -> getViewModel ( ) ; }
3639	public function check ( Output $ output ) : void { [ $ code , $ return , ] = Sys :: run ( 'php --ri swoole' ) ; $ asyncRdsEnabled = $ code === 0 ? \ strpos ( $ return , 'redis client => enabled' ) : false ; $ list = [ "<bold>Runtime environment check</bold>\n" , 'PHP version is greater than 7.1?' => self :: wrap ( \ PHP_VERSION_ID > 70100 , 'current is ' . \ PHP_VERSION ) , 'Swoole extension is installed?' => self :: wrap ( \ extension_loaded ( 'swoole' ) ) , 'Swoole version is greater than 4.3?' => self :: wrap ( \ version_compare ( \ SWOOLE_VERSION , '4.3.0' , '>=' ) , 'current is ' . \ SWOOLE_VERSION ) , 'Swoole async redis is enabled?' => self :: wrap ( $ asyncRdsEnabled ) , 'Swoole coroutine is enabled?' => self :: wrap ( \ class_exists ( 'Swoole\Coroutine' , false ) ) , "\n<bold>Extensions that conflict with 'swoole'</bold>\n" , ' - zend' => self :: wrap ( ! \ extension_loaded ( 'zend' ) , 'Please disabled it, otherwise swoole will be affected!' , true ) , ' - xdebug' => self :: wrap ( ! \ extension_loaded ( 'xdebug' ) , 'Please disabled it, otherwise swoole will be affected!' , true ) , ' - xhprof' => self :: wrap ( ! \ extension_loaded ( 'xhprof' ) , 'Please disabled it, otherwise swoole will be affected!' , true ) , ' - blackfire' => self :: wrap ( ! \ extension_loaded ( 'blackfire' ) , 'Please disabled it, otherwise swoole will be affected!' , true ) , ] ; $ buffer = [ ] ; $ pass = $ total = 0 ; foreach ( $ list as $ question => $ value ) { if ( \ is_int ( $ question ) ) { $ buffer [ ] = $ value ; continue ; } $ total ++ ; if ( $ value [ 0 ] ) { $ pass ++ ; } $ question = \ str_pad ( $ question , 45 ) ; $ buffer [ ] = \ sprintf ( ' <comment>%s</comment> %s' , $ question , $ value [ 1 ] ) ; } $ buffer [ ] = "\nCheck total: <bold>$total</bold>, Pass the check: <success>$pass</success>" ; $ output -> writeln ( $ buffer ) ; }
11991	private function validateSlug ( string $ sku ) { if ( strlen ( $ sku ) == 0 ) { throw new SlugException ( "A Slug cannot be empty" ) ; } $ containsWhitespace = preg_match ( $ this -> whiteSpacePattern , $ sku ) == 1 ; if ( $ containsWhitespace ) { throw new SlugException ( sprintf ( "A Slug cannot contain white space characters: \"%s\"" , $ sku ) ) ; } $ containsInvalidCharacters = preg_match ( $ this -> invalidCharactersPattern , $ sku ) == 1 ; if ( $ containsInvalidCharacters ) { throw new SlugException ( sprintf ( "The Slug \"%s\" contains invalid characters. A Slug can only contain the following characters: a-z, 0-9 and -" , $ sku ) ) ; } if ( strlen ( $ sku ) < $ this -> minLength ) { throw new SlugException ( sprintf ( "The given Slug \"%s\" is too short. The minimum length for a Slug is: %s" , $ sku , $ this -> minLength ) ) ; } if ( strlen ( $ sku ) > $ this -> maxLength ) { throw new SlugException ( sprintf ( "The given Slug \"%s\" is too long (%s character). The maximum length for a Slug is: %s" , strlen ( $ sku ) , $ sku , $ this -> maxLength ) ) ; } }
309	public function export ( ) { if ( empty ( $ this -> message [ 'subject' ] ) ) { $ this -> message [ 'subject' ] = 'Application Log' ; } $ messages = array_map ( [ $ this , 'formatMessage' ] , $ this -> messages ) ; $ body = wordwrap ( implode ( "\n" , $ messages ) , 70 ) ; $ message = $ this -> composeMessage ( $ body ) ; if ( ! $ message -> send ( $ this -> mailer ) ) { throw new LogRuntimeException ( 'Unable to export log through email!' ) ; } }
7227	public function url ( $ url = null ) { if ( $ url ) { $ this -> url = $ url ; $ this -> option ( [ CURLOPT_URL => $ url ] ) ; } return $ this -> url ; }
9334	public function deg ( ) { if ( $ this -> original -> type == self :: TYPE_DEG ) { return $ this -> original -> value ; } return rad2deg ( $ this -> float_rad ) ; }
4565	public function created ( JWTCreatedEvent $ event ) { $ data = $ event -> getData ( ) ; $ user = $ event -> getUser ( ) ; $ roles = [ ] ; if ( $ user instanceof User ) { $ roles = $ user -> getIdentity ( ) -> getRoles ( ) ; } else { if ( null !== $ user -> getIdentityUuid ( ) ) { switch ( $ user -> getIdentity ( ) ) { case Identity :: ANONYMOUS : $ identity = $ this -> api -> get ( 'identities.anonymous' ) -> get ( $ user -> getIdentityUuid ( ) ) ; break ; case Identity :: INDIVIDUAL : $ identity = $ this -> api -> get ( 'identities.individual' ) -> get ( $ user -> getIdentityUuid ( ) ) ; break ; case Identity :: ORGANIZATION : $ identity = $ this -> api -> get ( 'identities.organization' ) -> get ( $ user -> getIdentityUuid ( ) ) ; break ; case Identity :: STAFF : $ identity = $ this -> api -> get ( 'identities.staff' ) -> get ( $ user -> getIdentityUuid ( ) ) ; break ; case Identity :: SYSTEM : $ identity = $ this -> api -> get ( 'identities.system' ) -> get ( $ user -> getIdentityUuid ( ) ) ; break ; default : throw new DomainException ( 'User identity is not valid.' ) ; } foreach ( $ identity -> getRoles ( ) as $ role ) { $ roles [ ] = substr ( $ role , - 36 ) ; } } } $ this -> accessor -> setValue ( $ data , $ this -> property , $ roles ) ; $ event -> setData ( $ data ) ; }
9270	public function load ( ContainerBuilder $ container ) { $ loader = $ this -> getContainerLoader ( $ container ) ; $ loader -> load ( $ this -> configFile ) ; }
7632	public function putBlobData ( $ containerName = '' , $ blobName = '' , $ data = '' , $ metadata = array ( ) , $ leaseId = null , $ additionalHeaders = array ( ) ) { Assertion :: notEmpty ( $ containerName , 'Container name is not specified' ) ; self :: assertValidContainerName ( $ containerName ) ; Assertion :: notEmpty ( $ blobName , 'Blob name is not specified.' ) ; self :: assertValidRootContainerBlobName ( $ containerName , $ blobName ) ; $ headers = array ( ) ; if ( ! is_null ( $ leaseId ) ) { $ headers [ 'x-ms-lease-id' ] = $ leaseId ; } $ headers = array_merge ( $ headers , $ this -> generateMetadataHeaders ( $ metadata ) ) ; foreach ( $ additionalHeaders as $ key => $ value ) { $ headers [ $ key ] = $ value ; } $ headers [ Storage :: PREFIX_STORAGE_HEADER . 'blob-type' ] = self :: BLOBTYPE_BLOCK ; $ resourceName = self :: createResourceName ( $ containerName , $ blobName ) ; $ response = $ this -> performRequest ( $ resourceName , array ( ) , 'PUT' , $ headers , false , $ data , self :: RESOURCE_BLOB , self :: PERMISSION_WRITE ) ; if ( ! $ response -> isSuccessful ( ) ) { throw new BlobException ( $ this -> getErrorMessage ( $ response , 'Resource could not be accessed.' ) ) ; } return new BlobInstance ( $ containerName , $ blobName , null , $ response -> getHeader ( 'Etag' ) , $ response -> getHeader ( 'Last-modified' ) , $ this -> getBaseUrl ( ) . '/' . $ containerName . '/' . $ blobName , strlen ( $ data ) , '' , '' , '' , false , $ metadata ) ; }
2086	public static function getPath ( $ template , $ format , $ custom = 'templates' ) { $ file = $ template . '.' . $ format ; $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( file_exists ( $ rootDir . '/' . $ custom . '/' . $ file ) ) { return $ rootDir . '/' . $ custom . '/' . $ file ; } if ( $ custom != 'templates' ) { if ( file_exists ( $ rootDir . '/templates/' . $ file ) ) { return $ rootDir . '/templates/' . $ file ; } } return static :: getDefaultPath ( $ template , $ format ) ; }
5801	protected function getDeleteCell ( bool $ showDeleteLink , ? string $ primaryKeyValue ) : string { if ( $ showDeleteLink && $ this -> deleteRoute == null ) { throw new \ Exception ( "Must have deleteRoute" ) ; } if ( $ showDeleteLink && $ primaryKeyValue === null ) { throw new \ Exception ( "Must have primaryKeyValue to delete" ) ; } $ cellValue = ( $ showDeleteLink ) ? '<a href="' . $ this -> router -> pathFor ( $ this -> deleteRoute , [ "primaryKey" => $ primaryKeyValue ] ) . '" title="delete" onclick="return confirm(\'Are you sure you want to delete ' . $ primaryKeyValue . '?\');">X</a>' : '&nbsp;' ; return '<td>' . $ cellValue . '</td>' ; }
9223	public function unserialize ( $ data ) { $ _data = unserialize ( $ data ) ; $ this -> page = $ _data [ 'page' ] ; $ this -> key = $ _data [ 'key' ] ; $ this -> data = $ _data [ 'data' ] ; $ this -> api = null ; $ this -> endpoint = null ; $ this -> pagination = array ( ) ; }
2342	protected function getUserId ( ) { if ( $ this -> intUserId !== null ) { return $ this -> intUserId ; } $ this -> import ( BackendUser :: class , 'User' ) ; return $ this -> User -> id ; }
3049	protected function initCompilationDirectory ( ) { $ fileStorage = \ tao_models_classes_service_FileStorage :: singleton ( ) ; $ directoryIds = explode ( '|' , $ this -> getTestCompilationUri ( ) ) ; $ directories = array ( 'private' => $ fileStorage -> getDirectoryById ( $ directoryIds [ 0 ] ) , 'public' => $ fileStorage -> getDirectoryById ( $ directoryIds [ 1 ] ) ) ; $ this -> compilationDirectory = $ directories ; }
12949	public function afterSave ( ) { if ( $ this -> _tagsList === null ) { return ; } $ relation = $ this -> owner -> getRelation ( 'tagsList' , false ) ; if ( ! ( $ relation instanceof ActiveQuery ) ) { return ; } if ( ! $ this -> owner -> getIsNewRecord ( ) ) { $ this -> beforeDelete ( ) ; $ this -> afterDelete ( ) ; } $ relationClass = $ relation -> modelClass ; $ ownerTagsList = [ ] ; foreach ( $ this -> _tagsList as $ tagText ) { $ tag = $ relationClass :: findOne ( [ 'text' => $ tagText ] ) ; if ( $ tag === null ) { $ tag = new $ relationClass ( ) ; $ tag -> setAttribute ( 'text' , $ tagText ) ; } $ tag -> setAttribute ( 'count' , $ tag -> getAttribute ( 'count' ) + 1 ) ; if ( $ tag -> save ( ) ) { $ ownerTagsList [ ] = [ $ this -> owner -> getPrimaryKey ( ) , $ tag -> getPrimaryKey ( ) ] ; } } if ( ! empty ( $ ownerTagsList ) ) { $ this -> owner -> getDb ( ) -> createCommand ( ) -> batchInsert ( $ relation -> via -> from [ 0 ] , [ key ( $ relation -> via -> link ) , current ( $ relation -> link ) ] , $ ownerTagsList ) -> execute ( ) ; } }
11359	public function update ( $ previousPermalink , $ newPermalink ) { $ blocks = $ this -> permalinks [ $ previousPermalink ] ; $ this -> remove ( $ previousPermalink ) ; $ this -> permalinks [ $ newPermalink ] = $ blocks ; return $ this ; }
645	public function resetSequence ( $ table , $ value = null ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> resetSequence ( $ table , $ value ) ; return $ this -> setSql ( $ sql ) ; }
2558	protected function loadPaymentModule ( MopInfo $ options ) { if ( $ this -> checkAnyNotEmpty ( $ options -> fopType , $ options -> payMerchant , $ options -> payments , $ options -> installmentsInfo , $ options -> mopPaymentType , $ options -> creditCardInfo , $ options -> fraudScreening , $ options -> payIds , $ options -> paySupData ) ) { if ( $ this instanceof MopDescription14 ) { $ this -> paymentModule = new PaymentModule14 ( $ options -> fopType ) ; } else { $ this -> paymentModule = new PaymentModule ( $ options -> fopType ) ; } $ this -> paymentModule -> loadPaymentData ( $ options ) ; $ this -> loadMopInformation ( $ options ) ; $ this -> loadPaymentSupplementaryData ( $ options ) ; } }
7748	private function isAccessible ( \ ReflectionClass $ class , $ methodName , $ parameters ) { if ( $ class -> hasMethod ( $ methodName ) ) { $ method = $ class -> getMethod ( $ methodName ) ; if ( $ method -> isPublic ( ) && $ method -> getNumberOfRequiredParameters ( ) === $ parameters ) { return true ; } } return false ; }
10034	function unsubscribeContactById ( $ id , $ mailingId = "" , $ reasons = null ) { $ queryParameters = array ( 'id' => $ id ) ; if ( ! empty ( $ mailingId ) ) { $ queryParameters [ 'mailingId' ] = $ mailingId ; } if ( ! empty ( $ reasons ) ) { if ( is_array ( $ reasons ) ) { $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , 'reason' , $ reasons ) ; } else { $ queryParameters [ 'reason' ] = urlencode ( $ reasons ) ; } } return $ this -> delete ( "contacts/contact/unsubscribe" , $ queryParameters ) ; }
12357	public function updateEntryName ( ContentfulEntry $ entry ) { $ displayField = $ this -> getDisplayField ( ) ; $ values = array_values ( ( array ) $ entry -> { $ displayField } ) ; $ entry -> setName ( isset ( $ values [ 0 ] ) ? $ values [ 0 ] : 'Untitled' ) ; }
3815	protected function process ( $ table , $ metaModelName , $ parentId , Request $ request ) { $ this -> knownAttributes = $ this -> fetchExisting ( $ table , $ parentId ) ; $ metaModel = $ this -> factory -> getMetaModel ( $ metaModelName ) ; if ( ! $ metaModel ) { throw new \ RuntimeException ( 'Could not retrieve MetaModel ' . $ metaModelName ) ; } if ( $ request -> request -> has ( 'add' ) || $ request -> request -> has ( 'saveNclose' ) ) { $ this -> perform ( $ table , $ request , $ metaModel , $ parentId ) ; if ( $ request -> request -> has ( 'saveNclose' ) ) { return new RedirectResponse ( $ this -> getReferer ( $ request , $ table , false ) ) ; } } return new Response ( $ this -> templating -> render ( 'MetaModelsCoreBundle::Backend/add-all.html.twig' , $ this -> render ( $ table , $ metaModel , $ request ) ) ) ; }
5317	public function run ( ) { $ signalHandler = $ this -> getSignalHandler ( ) ; $ signalHandler -> registerHandler ( SIGTERM , function ( ) { $ this -> shouldShutdown = true ; } ) ; $ this -> sharedMemory [ self :: STARTED_MARKER ] = true ; $ callable = $ this -> callable ; $ callable ( $ this ) ; }
8299	public function addRule ( $ url , $ rule ) { if ( ! is_string ( $ url ) || ! is_array ( $ rule ) ) { throw new \ InvalidArgumentException ( "addRule() expects a string and an array." ) ; } $ this -> runtimeRules [ $ url ] = $ rule ; }
8065	protected function getNextFreeWorker ( ) { $ sec = 0 ; while ( TRUE ) { $ this -> collectWorkerResults ( $ sec ) ; $ freeProcess = $ this -> workerProcesses -> takeFreeProcess ( ) ; if ( $ freeProcess !== NULL ) { return $ freeProcess ; } $ sec = $ this -> child_timeout_sec ; if ( $ this -> workerPoolSize <= 0 ) { throw new WorkerPoolException ( 'All workers were gone.' ) ; } } return NULL ; }
4787	function offsetSet ( $ key , $ value ) { $ this -> row [ $ key ] = $ value ; $ this -> modified [ $ key ] = $ value ; }
8456	public function drush ( $ command , $ assumeYes = true ) { if ( is_array ( $ command ) ) { $ command = implode ( ' ' , array_filter ( $ command ) ) ; } return $ this -> exec ( $ this -> injectArguments ( $ command , $ assumeYes ) ) ; }
9962	public function insertNewRowBefore ( $ pBefore , $ pNumRows = 1 ) { if ( $ pBefore >= 1 ) { $ objReferenceHelper = ReferenceHelper :: getInstance ( ) ; $ objReferenceHelper -> insertNewBefore ( 'A' . $ pBefore , 0 , $ pNumRows , $ this ) ; } else { throw new Exception ( 'Rows can only be inserted before at least row 1.' ) ; } return $ this ; }
2251	public static function convertRelativeUrls ( $ strContent , $ strBase = '' , $ blnHrefOnly = false ) { if ( $ strBase == '' ) { $ strBase = Environment :: get ( 'base' ) ; } $ search = $ blnHrefOnly ? 'href' : 'href|src' ; $ arrUrls = preg_split ( '/((' . $ search . ')="([^"]+)")/i' , $ strContent , - 1 , PREG_SPLIT_DELIM_CAPTURE ) ; $ strContent = '' ; for ( $ i = 0 , $ c = \ count ( $ arrUrls ) ; $ i < $ c ; $ i += 4 ) { $ strContent .= $ arrUrls [ $ i ] ; if ( ! isset ( $ arrUrls [ $ i + 2 ] ) ) { continue ; } $ strAttribute = $ arrUrls [ $ i + 2 ] ; $ strUrl = $ arrUrls [ $ i + 3 ] ; if ( ! preg_match ( '@^(?:[a-z0-9]+:|#)@i' , $ strUrl ) ) { $ strUrl = $ strBase . ( ( $ strUrl != '/' ) ? $ strUrl : '' ) ; } $ strContent .= $ strAttribute . '="' . $ strUrl . '"' ; } return $ strContent ; }
1206	protected function renderLink ( ItemInterface $ item , array $ options = array ( ) ) { if ( $ item -> getUri ( ) && ( ! $ item -> isCurrent ( ) || $ options [ 'currentAsLink' ] ) ) { $ text = $ this -> renderLinkElement ( $ item , $ options ) ; } else { $ text = $ this -> renderSpanElement ( $ item , $ options ) ; } return $ this -> format ( $ text , 'link' , $ item -> getLevel ( ) , $ options ) ; }
7648	public function stream_close ( ) { @ fclose ( $ this -> temporaryFileHandle ) ; if ( $ this -> writeMode ) { $ containerExists = $ this -> getStorageClient ( $ this -> fileName ) -> containerExists ( $ this -> getContainerName ( $ this -> fileName ) ) ; if ( ! $ containerExists ) { $ this -> getStorageClient ( $ this -> fileName ) -> createContainer ( $ this -> getContainerName ( $ this -> fileName ) ) ; } try { $ this -> getStorageClient ( $ this -> fileName ) -> putBlob ( $ this -> getContainerName ( $ this -> fileName ) , $ this -> getFileName ( $ this -> fileName ) , $ this -> temporaryFileName ) ; } catch ( BlobException $ ex ) { @ unlink ( $ this -> temporaryFileName ) ; unset ( $ this -> storageClient ) ; throw $ ex ; } } @ unlink ( $ this -> temporaryFileName ) ; unset ( $ this -> storageClient ) ; }
6001	public function addImageTemplate ( $ item ) { if ( ! ( $ item instanceof ImageTemplate ) ) { if ( is_array ( $ item ) ) { try { $ item = new ImageTemplate ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate ImageTemplate. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "ImageTemplate"!' , E_USER_WARNING ) ; } } $ this -> imagetemplates [ ] = $ item ; return $ this ; }
11495	public function showAction ( Request $ request , Application $ app ) { $ options = array ( "request" => $ request , "configuration_handler" => $ app [ "red_kite_cms.configuration_handler" ] , "page_collection_manager" => $ app [ "red_kite_cms.page_collection_manager" ] , 'form_factory' => $ app [ "form.factory" ] , "pages_collection_parser" => $ app [ "red_kite_cms.pages_collection_parser" ] , "username" => $ this -> fetchUsername ( $ app [ "security" ] , $ app [ "red_kite_cms.configuration_handler" ] ) , 'theme' => $ app [ "red_kite_cms.theme" ] , 'template_assets' => $ app [ "red_kite_cms.template_assets" ] , 'twig' => $ app [ "twig" ] , ) ; return parent :: show ( $ options ) ; }
1263	private function createAcceptRequest ( $ shipmentDigest ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; $ container = $ xml -> appendChild ( $ xml -> createElement ( 'ShipmentAcceptRequest' ) ) ; $ request = $ container -> appendChild ( $ xml -> createElement ( 'Request' ) ) ; $ node = $ xml -> importNode ( $ this -> createTransactionNode ( ) , true ) ; $ request -> appendChild ( $ node ) ; $ request -> appendChild ( $ xml -> createElement ( 'RequestAction' , 'ShipAccept' ) ) ; $ container -> appendChild ( $ xml -> createElement ( 'ShipmentDigest' , $ shipmentDigest ) ) ; return $ xml -> saveXML ( ) ; }
3073	public function process ( ) { $ this -> validate ( ) ; $ ref = $ this -> getRequestParameter ( 'ref' ) ? : null ; $ scope = $ this -> getRequestParameter ( 'scope' ) ; $ start = ( $ this -> getRequestParameter ( 'start' ) !== false ) ; try { $ serviceContext = $ this -> getServiceContext ( ) ; $ this -> saveToolStates ( ) ; if ( ! $ this -> getRunnerService ( ) -> isTerminated ( $ serviceContext ) ) { $ this -> endItemTimer ( $ this -> getTime ( ) ) ; $ this -> saveItemState ( ) ; } $ this -> initServiceContext ( ) ; $ this -> saveItemResponses ( ) ; if ( $ this -> getRequestParameter ( 'offline' ) === true ) { $ this -> setOffline ( ) ; } $ result = $ this -> getRunnerService ( ) -> timeout ( $ serviceContext , $ scope , $ ref ) ; $ response = [ 'success' => $ result , ] ; if ( $ result ) { $ response [ 'testContext' ] = $ this -> getRunnerService ( ) -> getTestContext ( $ serviceContext ) ; if ( $ serviceContext -> containsAdaptive ( ) ) { $ response [ 'testMap' ] = $ this -> getRunnerService ( ) -> getTestMap ( $ serviceContext , true ) ; } } if ( $ start == true ) { $ this -> getRunnerService ( ) -> startTimer ( $ serviceContext , $ this -> getTime ( ) ) ; } } catch ( Exception $ e ) { $ response = $ this -> getErrorResponse ( $ e ) ; } return $ response ; }
10604	public function setQueryParam ( $ name , $ value ) { if ( $ this -> checkQuery ( $ name ) ) { $ this -> editQuery ( $ name , $ value ) ; } else { $ this -> addQuery ( $ name , $ value ) ; } return $ this ; }
2965	public function buildRequest ( $ method , $ path , array $ params = [ ] ) { $ body = ArrayUtils :: get ( $ params , 'body' , null ) ; $ query = ArrayUtils :: get ( $ params , 'query' , null ) ; $ options = [ ] ; if ( in_array ( $ method , [ 'POST' , 'PUT' , 'PATCH' ] ) && $ body ) { $ options [ 'body' ] = $ body ; } if ( $ query ) { $ options [ 'query' ] = $ query ; } return $ this -> createRequest ( $ method , $ path , $ options ) ; }
1885	public function getItemsAsString ( $ strSeparator = ' ' ) { $ arrLinks = array ( ) ; foreach ( $ this -> getItemsAsArray ( ) as $ arrItem ) { if ( $ arrItem [ 'href' ] === null ) { $ arrLinks [ ] = sprintf ( '<li><strong class="active">%s</strong></li>' , $ arrItem [ 'page' ] ) ; } else { $ arrLinks [ ] = sprintf ( '<li><a href="%s" class="link" title="%s">%s</a></li>' , $ arrItem [ 'href' ] , $ arrItem [ 'title' ] , $ arrItem [ 'page' ] ) ; } } return implode ( $ strSeparator , $ arrLinks ) ; }
9425	public function f ( ) { if ( is_null ( $ this -> arr_f ) ) { $ arr = $ this -> frequency ( ) ; array_walk ( $ arr , function ( & $ v , $ k , $ n ) { $ v = $ v / $ n ; } , count ( $ this ) ) ; $ this -> arr_f = $ arr ; } return $ this -> arr_f ; }
12565	public function sendImage ( $ message , $ to = null ) { return $ this -> send ( self :: MSG_TYPE_IMAGE , $ message , $ to ) ; }
614	protected function getDependencies ( $ class ) { if ( isset ( $ this -> _reflections [ $ class ] ) ) { return [ $ this -> _reflections [ $ class ] , $ this -> _dependencies [ $ class ] ] ; } $ dependencies = [ ] ; try { $ reflection = new ReflectionClass ( $ class ) ; } catch ( \ ReflectionException $ e ) { throw new InvalidConfigException ( 'Failed to instantiate component or class "' . $ class . '".' , 0 , $ e ) ; } $ constructor = $ reflection -> getConstructor ( ) ; if ( $ constructor !== null ) { foreach ( $ constructor -> getParameters ( ) as $ param ) { if ( version_compare ( PHP_VERSION , '5.6.0' , '>=' ) && $ param -> isVariadic ( ) ) { break ; } elseif ( $ param -> isDefaultValueAvailable ( ) ) { $ dependencies [ ] = $ param -> getDefaultValue ( ) ; } else { $ c = $ param -> getClass ( ) ; $ dependencies [ ] = Instance :: of ( $ c === null ? null : $ c -> getName ( ) ) ; } } } $ this -> _reflections [ $ class ] = $ reflection ; $ this -> _dependencies [ $ class ] = $ dependencies ; return [ $ reflection , $ dependencies ] ; }
4723	public function setAttribute ( $ attribute , $ value = null ) { $ this -> attributes -> set ( $ attribute , $ value ) ; return $ this ; }
3853	public function overrideOutputFormat ( $ strOutputFormat = null ) { $ strOutputFormat = strval ( $ strOutputFormat ) ; if ( strlen ( $ strOutputFormat ) ) { $ this -> strOutputFormat = $ strOutputFormat ; } else { unset ( $ this -> strOutputFormat ) ; } return $ this ; }
1526	protected function doUpdate ( StoreInterface $ store , UpdateResource $ request ) { if ( $ response = $ this -> beforeCommit ( $ request ) ) { return $ response ; } $ record = $ store -> updateRecord ( $ request -> getRecord ( ) , $ request -> all ( ) , $ request -> getParameters ( ) ) ; return $ this -> afterCommit ( $ request , $ record , true ) ? : $ record ; }
9859	public function getStream ( $ stream ) { if ( $ stream === null ) { return null ; } $ streamData = '' ; if ( $ this -> props [ $ stream ] [ 'size' ] < self :: SMALL_BLOCK_THRESHOLD ) { $ rootdata = $ this -> _readData ( $ this -> props [ $ this -> rootentry ] [ 'startBlock' ] ) ; $ block = $ this -> props [ $ stream ] [ 'startBlock' ] ; while ( $ block != - 2 ) { $ pos = $ block * self :: SMALL_BLOCK_SIZE ; $ streamData .= substr ( $ rootdata , $ pos , self :: SMALL_BLOCK_SIZE ) ; $ block = self :: getInt4d ( $ this -> smallBlockChain , $ block * 4 ) ; } return $ streamData ; } $ numBlocks = $ this -> props [ $ stream ] [ 'size' ] / self :: BIG_BLOCK_SIZE ; if ( $ this -> props [ $ stream ] [ 'size' ] % self :: BIG_BLOCK_SIZE != 0 ) { ++ $ numBlocks ; } if ( $ numBlocks == 0 ) { return '' ; } $ block = $ this -> props [ $ stream ] [ 'startBlock' ] ; while ( $ block != - 2 ) { $ pos = ( $ block + 1 ) * self :: BIG_BLOCK_SIZE ; $ streamData .= substr ( $ this -> data , $ pos , self :: BIG_BLOCK_SIZE ) ; $ block = self :: getInt4d ( $ this -> bigBlockChain , $ block * 4 ) ; } return $ streamData ; }
162	public function addParams ( $ params ) { if ( ! empty ( $ params ) ) { if ( empty ( $ this -> params ) ) { $ this -> params = $ params ; } else { foreach ( $ params as $ name => $ value ) { if ( is_int ( $ name ) ) { $ this -> params [ ] = $ value ; } else { $ this -> params [ $ name ] = $ value ; } } } } return $ this ; }
10391	protected static function getSysTempDir ( ) { if ( function_exists ( 'sys_get_temp_dir' ) ) { return sys_get_temp_dir ( ) ; } else if ( $ tmp = getenv ( 'TMP' ) ) { return $ tmp ; } else if ( $ tmp = getenv ( 'TEMP' ) ) { return $ tmp ; } else if ( $ tmp = getenv ( 'TMPDIR' ) ) { return $ tmp ; } return '/tmp' ; }
5839	protected function trim ( Builder $ url , $ args ) { $ args = ( is_string ( $ args ) ) ? $ args : null ; $ url -> trim ( $ args ) ; }
1253	private function newPhpObject ( \ stdClass $ meta ) { $ phpTypes = explode ( '|' , $ meta -> phpType ) ; foreach ( $ phpTypes as $ phpType ) { switch ( $ phpType ) { case 'integer' : case 'string' : case 'double' : case 'boolean' : case 'DateTime' : continue ; default : return $ meta -> phpType !== '' ? new $ phpType ( ) : null ; } } return null ; }
3970	protected function attributeIdToName ( IMetaModel $ metaModel , $ attributeId ) { if ( null === $ attribute = $ metaModel -> getAttributeById ( $ attributeId ) ) { throw new \ RuntimeException ( sprintf ( 'Could not retrieve attribute %s from MetaModel %s.' , $ attributeId , $ metaModel -> getTableName ( ) ) ) ; } return $ attribute -> getColName ( ) ; }
1597	protected function validateRelationships ( ) : bool { if ( ! $ this -> dataHas ( 'relationships' ) ) { return true ; } $ relationships = $ this -> dataGet ( 'relationships' ) ; if ( ! is_object ( $ relationships ) ) { $ this -> memberNotObject ( '/data' , 'relationships' ) ; return false ; } $ disallowed = collect ( [ 'type' , 'id' ] ) -> filter ( function ( $ field ) use ( $ relationships ) { return property_exists ( $ relationships , $ field ) ; } ) ; $ valid = $ disallowed -> isEmpty ( ) ; $ this -> memberFieldsNotAllowed ( '/data' , 'relationships' , $ disallowed ) ; foreach ( $ relationships as $ field => $ relation ) { if ( ! $ this -> validateRelationship ( $ relation , $ field ) ) { $ valid = false ; } } return $ valid ; }
7201	public function getUnit ( bool $ ati = false ) : float { return $ ati ? $ this -> ati ( $ this -> unit ) : $ this -> unit ; }
3203	protected function validate_css_property_value ( $ value , $ compare_type , $ compare_value ) { switch ( $ compare_type ) { case '!=' : return $ value !== $ compare_value ; case '>' : return $ value > $ compare_value ; default : return false ; } }
11534	public static function writeFile ( $ file , $ content ) { $ handle = fopen ( $ file , 'w' ) ; if ( ! self :: lockFile ( $ handle , LOCK_EX | LOCK_NB ) ) { $ exception = array ( "message" => 'exception_file_cannot_be_locked_for_writing' , "parameters" => array ( "%file%" => basename ( $ file ) , ) ) ; throw new RuntimeException ( json_encode ( $ exception ) ) ; } if ( fwrite ( $ handle , $ content ) === false ) { $ exception = array ( "message" => 'exception_file_cannot_be_written' , "parameters" => array ( "%file%" => basename ( $ file ) , ) ) ; throw new RuntimeException ( json_encode ( $ exception ) ) ; } self :: unlockFile ( $ handle ) ; }
4396	public function refund ( \ Aimeos \ MShop \ Order \ Item \ Iface $ order ) { $ provider = $ this -> getProvider ( ) ; if ( ! $ provider -> supportsRefund ( ) ) { return ; } $ base = $ this -> getOrderBase ( $ order -> getBaseId ( ) ) ; $ type = \ Aimeos \ MShop \ Order \ Item \ Base \ Service \ Base :: TYPE_PAYMENT ; $ service = $ this -> getBasketService ( $ base , $ type , $ this -> getServiceItem ( ) -> getCode ( ) ) ; $ data = array ( 'transactionReference' => $ this -> getTransactionReference ( $ base ) , 'currency' => $ base -> getPrice ( ) -> getCurrencyId ( ) , 'amount' => $ this -> getAmount ( $ base -> getPrice ( ) ) , 'transactionId' => $ order -> getId ( ) , ) ; $ response = $ provider -> refund ( $ data ) -> send ( ) ; if ( $ response -> isSuccessful ( ) ) { $ attr = array ( 'REFUNDID' => $ response -> getTransactionReference ( ) ) ; $ this -> setAttributes ( $ service , $ attr , 'payment/omnipay' ) ; $ this -> saveOrderBase ( $ base ) ; $ status = \ Aimeos \ MShop \ Order \ Item \ Base :: PAY_REFUND ; $ order -> setPaymentStatus ( $ status ) ; $ this -> saveOrder ( $ order ) ; } }
10416	protected function addStatusField ( Table $ table ) { if ( empty ( $ this -> shops ) ) { $ table -> addColumn ( 'status' , 'boolean' , [ 'default' => 0 ] ) -> setComment ( '0-new,1-done' ) ; $ table -> addIndex ( [ 'status' ] ) ; } else { foreach ( $ this -> shops as $ shop ) { $ fieldName = "status_{$shop}" ; $ table -> addColumn ( $ fieldName , 'boolean' , [ 'default' => 0 ] ) -> setComment ( '0-new,1-done' ) ; $ table -> addIndex ( [ $ fieldName ] ) ; } } }
11253	public function transaction ( callable $ callback ) : void { $ this -> pdo -> beginTransaction ( ) ; $ callback ( $ this ) ; $ this -> pdo -> commit ( ) ; }
12961	public function getDb ( ) { if ( is_null ( $ this -> db ) ) { if ( $ this -> getAccessType ( ) == 'mysqli' && function_exists ( 'mysqli_select_db' ) ) { $ this -> db = new Db \ Mysqli ( ) ; } else { if ( $ this -> getAccessType ( ) == 'pdo' && class_exists ( 'PDO' ) ) { $ this -> db = new Db \ Pdo ( ) ; } } if ( is_null ( $ this -> db ) ) { if ( class_exists ( 'PDO' ) ) { $ this -> db = new Db \ Pdo ( ) ; } elseif ( function_exists ( 'mysqli_select_db' ) ) { $ this -> db = new Db \ Mysqli ( ) ; } else { throw new DbException ( 'Database engine not available! Must be either PDO or mysqli' ) ; } } $ this -> db -> setCredentials ( $ this -> credentials ) ; } return $ this -> db ; }
3230	static function loadFromJson ( $ jsonObj ) { $ authHost = null ; if ( array_key_exists ( 'auth_host' , $ jsonObj ) ) { $ authHost = $ jsonObj [ "auth_host" ] ; if ( ! is_string ( $ authHost ) ) { throw new HostLoadException ( "Optional field \"auth_host\" must be a string" ) ; } } $ hostSuffix = null ; if ( array_key_exists ( 'host_suffix' , $ jsonObj ) ) { $ hostSuffix = $ jsonObj [ "host_suffix" ] ; if ( ! is_string ( $ hostSuffix ) ) { throw new HostLoadException ( "Optional field \"host_suffix\" must be a string" ) ; } } if ( $ authHost === null && $ hostSuffix === null ) return null ; if ( $ authHost === null ) { throw new HostLoadException ( "Can't provide \"host_suffix\" without providing \"auth_host\"." ) ; } if ( $ hostSuffix === null ) { throw new HostLoadException ( "Can't provide \"auth_host\" without providing \"host_suffix\"." ) ; } $ api = "api" . $ hostSuffix ; $ content = "content" . $ hostSuffix ; $ web = $ authHost ; return new Host ( $ api , $ content , $ web ) ; }
669	protected function generateDependencyData ( $ cache ) { $ db = Instance :: ensure ( $ this -> db , Connection :: className ( ) ) ; if ( $ this -> sql === null ) { throw new InvalidConfigException ( 'DbDependency::sql must be set.' ) ; } if ( $ db -> enableQueryCache ) { $ db -> enableQueryCache = false ; $ result = $ db -> createCommand ( $ this -> sql , $ this -> params ) -> queryOne ( ) ; $ db -> enableQueryCache = true ; } else { $ result = $ db -> createCommand ( $ this -> sql , $ this -> params ) -> queryOne ( ) ; } return $ result ; }
1769	public function __isset ( $ strKey ) { switch ( $ strKey ) { case 'id' : return isset ( $ this -> strId ) ; break ; case 'name' : return isset ( $ this -> strName ) ; break ; case 'label' : return isset ( $ this -> strLabel ) ; break ; case 'value' : return isset ( $ this -> varValue ) ; break ; case 'class' : return isset ( $ this -> strClass ) ; break ; case 'template' : return isset ( $ this -> strTemplate ) ; break ; case 'wizard' : return isset ( $ this -> strWizard ) ; break ; case 'required' : return isset ( $ this -> arrConfiguration [ $ strKey ] ) ; break ; case 'forAttribute' : return isset ( $ this -> blnForAttribute ) ; break ; case 'dataContainer' : return isset ( $ this -> objDca ) ; break ; case 'activeRecord' : return isset ( $ this -> objDca -> activeRecord ) ; break ; default : return isset ( $ this -> arrAttributes [ $ strKey ] ) || isset ( $ this -> arrConfiguration [ $ strKey ] ) ; break ; } }
277	public function notifyNothingToUnload ( $ foundFixtures , $ except ) { $ this -> stdout ( "Fixtures to unload could not be found according to given conditions:\n\n" , Console :: FG_RED ) ; $ this -> stdout ( "Fixtures namespace is: \n" , Console :: FG_YELLOW ) ; $ this -> stdout ( "\t" . $ this -> namespace . "\n" , Console :: FG_GREEN ) ; if ( count ( $ foundFixtures ) ) { $ this -> stdout ( "\nFixtures found under the namespace:\n\n" , Console :: FG_YELLOW ) ; $ this -> outputList ( $ foundFixtures ) ; } if ( count ( $ except ) ) { $ this -> stdout ( "\nFixtures that will NOT be unloaded: \n\n" , Console :: FG_YELLOW ) ; $ this -> outputList ( $ except ) ; } }
8904	public function delete_many ( $ primary_values , $ time = 'NOW()' ) { $ this -> _database -> where_in ( $ this -> primary_key , $ primary_values ) ; return $ this -> _delete ( $ primary_values , $ time ) ; }
11255	public function call ( string $ class ) : void { $ files = $ this -> all ( $ class ) ; if ( count ( $ files ) < 1 ) { throw InvalidArgumentException :: forNotFoundSeeder ( ) ; } foreach ( $ files as [ $ file , $ content ] ) { $ this -> load ( $ content ) ; $ this -> resolve ( $ file [ 'filename' ] ) -> run ( ) ; } }
12724	public function resetSelf ( ) { $ this -> where = '' ; $ this -> select = '*' ; $ this -> limit = 20 ; $ this -> offset = 0 ; $ this -> orderBy = array ( ) ; $ this -> groupBy = array ( ) ; $ this -> prepend = '' ; $ this -> listWordsField = null ; $ this -> alternativesField = null ; $ this -> join = null ; }
859	public function isAllTokenKindsFound ( array $ tokenKinds ) { foreach ( $ tokenKinds as $ tokenKind ) { if ( empty ( $ this -> foundTokenKinds [ $ tokenKind ] ) ) { return false ; } } return true ; }
7738	public function serialize ( $ entity ) { if ( ! $ this -> container -> has ( 'hydra.serializer' ) ) { throw new \ LogicException ( 'The HydraBundle is not registered in your application.' ) ; } return $ this -> container -> get ( 'hydra.serializer' ) -> serialize ( $ entity , self :: FORMAT ) ; }
8104	public function query ( $ sql , $ arguments = false ) { if ( ! $ stmt = $ this -> getStatement ( $ sql , $ arguments ) ) { return false ; } else { return $ stmt ; } }
10572	protected function sendCacheControlHeader ( ) { if ( $ this -> sessionCacheLimiter !== null ) { if ( $ this -> sessionCacheLimiter === '' && ! headers_sent ( ) && Yii :: $ app -> getSession ( ) -> getIsActive ( ) ) { header_remove ( 'Expires' ) ; header_remove ( 'Cache-Control' ) ; header_remove ( 'Last-Modified' ) ; header_remove ( 'Pragma' ) ; } session_cache_limiter ( $ this -> sessionCacheLimiter ) ; } $ headers = Yii :: $ app -> getResponse ( ) -> getHeaders ( ) ; $ headers -> set ( 'Pragma' ) ; if ( $ this -> cacheControlHeader !== null ) { $ headers -> set ( 'Cache-Control' , $ this -> cacheControlHeader ) ; } }
3605	private function isCacheSupport ( JsonRequest $ jsonRequest ) { try { return $ jsonRequest -> getId ( ) && null !== $ this -> getMethod ( $ jsonRequest ) -> getCache ( ) && ! $ this -> isDebug ( ) && $ this -> getCache ( ) ; } catch ( \ Exception $ e ) { return false ; } }
4280	public function stream_stat ( ) { if ( ! $ this -> handle ) { return false ; } self :: restorePrev ( ) ; $ array = \ fstat ( $ this -> handle ) ; self :: register ( ) ; return $ array ; }
2908	public function decodeSubject ( $ subject ) { if ( $ this -> hasQueue ( ) && $ queue = $ this -> getQueue ( ) ) { return $ queue -> getMessageParameters ( 'subject' ) ; } return base64_decode ( substr ( $ subject , strlen ( '=?utf-8?B?' ) , - 1 * strlen ( '?=' ) ) ) ; }
12185	public function getNiceId ( $ queryRole ) { $ roleType = $ this -> roleType ( $ queryRole ) ; if ( empty ( $ roleType ) ) { return false ; } return implode ( ':' , [ $ this -> role ( $ queryRole ) , $ roleType -> systemId ] ) ; }
5892	public static function logEntry ( $ entry ) { $ parts = explode ( "|" , $ entry , 5 ) ; $ array = array ( ) ; if ( count ( $ parts ) != 5 ) { $ array [ "timestamp" ] = 0 ; $ array [ "level" ] = TeamSpeak3 :: LOGLEVEL_ERROR ; $ array [ "channel" ] = "ParamParser" ; $ array [ "server_id" ] = "" ; $ array [ "msg" ] = StringHelper :: factory ( "convert error (" . trim ( $ entry ) . ")" ) ; $ array [ "msg_plain" ] = $ entry ; $ array [ "malformed" ] = true ; } else { $ array [ "timestamp" ] = strtotime ( trim ( $ parts [ 0 ] ) ) ; $ array [ "level" ] = self :: logLevel ( trim ( $ parts [ 1 ] ) ) ; $ array [ "channel" ] = trim ( $ parts [ 2 ] ) ; $ array [ "server_id" ] = trim ( $ parts [ 3 ] ) ; $ array [ "msg" ] = StringHelper :: factory ( trim ( $ parts [ 4 ] ) ) ; $ array [ "msg_plain" ] = $ entry ; $ array [ "malformed" ] = false ; } return $ array ; }
2441	public static function urlDecode ( string $ data ) : self { $ decoded = base64_decode ( strtr ( $ data , '-_,' , '+/=' ) , true ) ; if ( \ function_exists ( 'gzdecode' ) && false !== ( $ uncompressed = @ gzdecode ( $ decoded ) ) ) { $ decoded = $ uncompressed ; } $ json = @ json_decode ( $ decoded , true ) ; if ( null === $ json ) { throw new \ InvalidArgumentException ( 'Invalid JSON data' ) ; } return new self ( $ json [ 'context' ] , $ json [ 'extras' ] , $ json [ 'value' ] , $ json [ 'current' ] ) ; }
9804	public function setModified ( $ time ) { if ( $ time === null ) { $ time = time ( ) ; } elseif ( is_string ( $ time ) ) { if ( is_numeric ( $ time ) ) { $ time = ( int ) $ time ; } else { $ time = strtotime ( $ time ) ; } } $ this -> modified = $ time ; return $ this ; }
10884	public function report ( ErrorStreamReport $ report ) { $ report -> tags = $ this -> tags ; $ report -> context = $ this -> context ; return $ this -> makeRequest ( $ report ) ; }
3247	public function add ( $ item , $ quantity = 1 , $ quantityReset = false ) { if ( ! is_array ( $ item ) && ! $ item -> isShoppable ) return ; $ cartItem = $ this -> getItem ( is_array ( $ item ) ? $ item [ 'sku' ] : $ item -> sku ) ; if ( empty ( $ cartItem ) ) { $ reflection = null ; if ( is_object ( $ item ) ) { $ reflection = new \ ReflectionClass ( $ item ) ; } $ cartItem = call_user_func ( Config :: get ( 'shop.item' ) . '::create' , [ 'user_id' => $ this -> user -> shopId , 'cart_id' => $ this -> attributes [ 'id' ] , 'sku' => is_array ( $ item ) ? $ item [ 'sku' ] : $ item -> sku , 'price' => is_array ( $ item ) ? $ item [ 'price' ] : $ item -> price , 'tax' => is_array ( $ item ) ? ( array_key_exists ( 'tax' , $ item ) ? $ item [ 'tax' ] : 0 ) : ( isset ( $ item -> tax ) && ! empty ( $ item -> tax ) ? $ item -> tax : 0 ) , 'shipping' => is_array ( $ item ) ? ( array_key_exists ( 'shipping' , $ item ) ? $ item [ 'shipping' ] : 0 ) : ( isset ( $ item -> shipping ) && ! empty ( $ item -> shipping ) ? $ item -> shipping : 0 ) , 'currency' => Config :: get ( 'shop.currency' ) , 'quantity' => $ quantity , 'class' => is_array ( $ item ) ? null : $ reflection -> getName ( ) , 'reference_id' => is_array ( $ item ) ? null : $ item -> shopId , ] ) ; } else { $ cartItem -> quantity = $ quantityReset ? $ quantity : $ cartItem -> quantity + $ quantity ; $ cartItem -> save ( ) ; } $ this -> resetCalculations ( ) ; return $ this ; }
5961	public function serverGroupGetByName ( $ name , $ type = TeamSpeak3 :: GROUP_DBTYPE_REGULAR ) { foreach ( $ this -> serverGroupList ( ) as $ group ) { if ( $ group [ "name" ] == $ name && $ group [ "type" ] == $ type ) { return $ group ; } } throw new Ts3Exception ( "invalid groupID" , 0xA00 ) ; }
3619	public function cancelFanModeOnWithTimer ( $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ data = json_encode ( array ( 'fan_timer_timeout' => 0 ) ) ; return $ this -> doPOST ( "/v2/put/device." . $ serial_number , $ data ) ; }
8770	protected function bindPathsInContainer ( ) { $ this -> instance ( 'path' , $ this -> path ( ) ) ; $ this -> instance ( 'path.base' , $ this -> basePath ( ) ) ; $ this -> instance ( 'path.lang' , $ this -> langPath ( ) ) ; $ this -> instance ( 'path.config' , $ this -> configPath ( ) ) ; $ this -> instance ( 'path.storage' , $ this -> storagePath ( ) ) ; $ this -> instance ( 'path.database' , $ this -> databasePath ( ) ) ; $ this -> instance ( 'path.cache' , $ this -> cachePath ( ) ) ; $ this -> instance ( 'path.public' , $ this -> publicPath ( ) ) ; }
7544	function getNextSibling ( $ skip_text_comments = true ) { $ offset = 1 ; while ( ( $ n = $ this -> getSibling ( $ offset ) ) !== null ) { if ( $ skip_text_comments && ( $ n -> tag [ 0 ] === '~' ) ) { ++ $ offset ; } else { break ; } } return $ n ; }
6014	public function retrieveProtocol ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/deployment/protocols/' . $ id . '' , $ parameters , $ cachePolicy ) ; $ result = new Protocol ( $ result ) ; return $ result ; }
7488	public function append ( $ string ) { $ string = static :: convertString ( $ string , $ this -> encoding ) ; $ this -> string .= $ string ; return $ this ; }
5668	public function describeDifference ( $ first , $ second , $ identical = false ) { if ( $ identical ) { if ( ! $ this -> isTypeMatch ( $ first , $ second ) ) { return sprintf ( 'with type mismatch as [%s] does not match [%s]' , $ this -> describeValue ( $ first ) , $ this -> describeValue ( $ second ) ) ; } } $ type = $ this -> getType ( $ first ) ; if ( $ type === 'Unknown' ) { return 'with unknown type' ; } $ method = 'describe' . $ type . 'Difference' ; return $ this -> $ method ( $ first , $ second , $ identical ) ; }
4317	private static function getMethodDefaultArgs ( $ methodName ) { $ defaultArgs = array ( ) ; if ( isset ( self :: $ methodDefaultArgs [ $ methodName ] ) ) { $ defaultArgs = self :: $ methodDefaultArgs [ $ methodName ] ; } elseif ( \ method_exists ( self :: $ instance , $ methodName ) ) { $ reflectionMethod = new ReflectionMethod ( self :: $ instance , $ methodName ) ; $ params = $ reflectionMethod -> getParameters ( ) ; foreach ( $ params as $ reflectionParameter ) { $ defaultArgs [ ] = $ reflectionParameter -> isOptional ( ) ? $ reflectionParameter -> getDefaultValue ( ) : null ; } self :: $ methodDefaultArgs [ $ methodName ] = $ defaultArgs ; } return $ defaultArgs ; }
12702	public function get ( $ id ) { if ( isset ( $ this -> singletons [ $ id ] ) ) { return $ this -> singletons [ $ id ] ; } $ methodName = 'get' . Util :: mapIdToCamelCase ( $ id ) ; if ( method_exists ( $ this , $ methodName ) ) { return $ this -> $ methodName ( ) ; } throw new \ InvalidArgumentException ( "Unknown service '$id' in container '" . get_called_class ( ) . "'" ) ; }
2797	public function getAdapter ( ) { if ( is_null ( $ this -> adapter ) ) { $ name = ucfirst ( strtolower ( $ this -> get ( 'adapter' ) ) ) ; $ class = '\\Humbug\\Adapter\\' . $ name ; $ this -> adapter = new $ class ; } return $ this -> adapter ; }
7526	public static function parseFile ( $ path , $ context = null ) { $ html_str = file_get_contents ( $ path , false , $ context ) ; return static :: parseStr ( $ html_str ) ; }
3615	public function setEcoTemperatures ( $ temp_low , $ temp_high , $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ temp_low = $ this -> temperatureInCelsius ( $ temp_low , $ serial_number ) ; $ temp_high = $ this -> temperatureInCelsius ( $ temp_high , $ serial_number ) ; $ data = array ( ) ; if ( $ temp_low === FALSE ) { $ data [ 'away_temperature_low_enabled' ] = FALSE ; } elseif ( $ temp_low != NULL ) { $ data [ 'away_temperature_low_enabled' ] = TRUE ; $ data [ 'away_temperature_low' ] = $ temp_low ; } if ( $ temp_high === FALSE ) { $ data [ 'away_temperature_high_enabled' ] = FALSE ; } elseif ( $ temp_high != NULL ) { $ data [ 'away_temperature_high_enabled' ] = TRUE ; $ data [ 'away_temperature_high' ] = $ temp_high ; } $ data = json_encode ( $ data ) ; return $ this -> doPOST ( "/v2/put/device." . $ serial_number , $ data ) ; }
3662	private function parseTable ( ) { $ this -> queryString = str_replace ( '{{table}}' , $ this -> collection -> getMetaModel ( ) -> getTableName ( ) , $ this -> queryString ) ; }
510	public function actionList ( ) { foreach ( $ this -> getCommandDescriptions ( ) as $ command => $ description ) { $ result = Yii :: $ app -> createController ( $ command ) ; if ( $ result === false || ! ( $ result [ 0 ] instanceof Controller ) ) { continue ; } list ( $ controller , $ actionID ) = $ result ; $ actions = $ this -> getActions ( $ controller ) ; if ( ! empty ( $ actions ) ) { $ prefix = $ controller -> getUniqueId ( ) ; $ this -> stdout ( "$prefix\n" ) ; foreach ( $ actions as $ action ) { $ this -> stdout ( "$prefix/$action\n" ) ; } } } }
6321	public function addConstraint ( ConstraintInterface $ constraint ) { $ constraint -> setTable ( $ this ) ; $ this -> constraints [ ] = $ constraint ; return $ this ; }
3850	public function getServiceContainer ( ) { if ( ! $ this -> serviceContainer ) { $ this -> useDefaultServiceContainer ( ) ; } if ( is_callable ( $ this -> serviceContainer ) ) { return $ this -> serviceContainer = $ this -> serviceContainer -> __invoke ( ) ; } return $ this -> serviceContainer ; }
5614	public function paintMethodEnd ( $ message ) { parent :: paintCaseEnd ( $ message ) ; $ node = $ this -> _stack -> pop ( ) ; $ current = $ this -> _stack -> peek ( ) ; if ( $ node -> isFailed ( ) ) { $ current -> fail ( ) ; } $ current -> putChild ( $ node ) ; }
8865	public function run ( PayloadInterface $ payload ) { $ tasks = $ this -> getTaskCollection ( ) -> getTasks ( ) ; $ tasksCount = $ tasks -> count ( ) ; if ( 0 === $ tasksCount ) { throw new LogicException ( 'Can\'t invoke task run. Empty task collection set.' ) ; } $ this -> log ( LogLevel :: INFO , sprintf ( 'Starting runner with %s tasks ready for execution.' , $ tasksCount ) ) ; $ this -> dispatch ( 'runner.start' , null , $ payload ) ; foreach ( $ tasks as $ task ) { try { $ task -> setPayload ( $ payload ) ; $ this -> runTask ( $ task , $ payload ) ; } catch ( \ Exception $ e ) { $ this -> logTask ( $ task , LogLevel :: ERROR , sprintf ( 'An exception was thrown. Message: %s' , $ e -> getMessage ( ) ) ) ; $ this -> dispatch ( 'runner.failure' , null , null , null , $ e ) ; throw new RunFailedException ( 'Complete run failed: ' . $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } } $ this -> log ( LogLevel :: INFO , 'All tasks were processed.' ) ; $ this -> log ( LogLevel :: INFO , 'Calling attached runners.' ) ; $ this -> notify ( $ payload ) ; $ this -> log ( LogLevel :: INFO , 'Execution successful.' ) ; $ this -> dispatch ( 'runner.success' , null , $ payload ) ; return $ payload ; }
280	private function confirmLoad ( $ fixtures , $ except ) { $ this -> stdout ( "Fixtures namespace is: \n" , Console :: FG_YELLOW ) ; $ this -> stdout ( "\t" . $ this -> namespace . "\n\n" , Console :: FG_GREEN ) ; if ( count ( $ this -> globalFixtures ) ) { $ this -> stdout ( "Global fixtures will be used:\n\n" , Console :: FG_YELLOW ) ; $ this -> outputList ( $ this -> globalFixtures ) ; } if ( count ( $ fixtures ) ) { $ this -> stdout ( "\nFixtures below will be loaded:\n\n" , Console :: FG_YELLOW ) ; $ this -> outputList ( $ fixtures ) ; } if ( count ( $ except ) ) { $ this -> stdout ( "\nFixtures that will NOT be loaded: \n\n" , Console :: FG_YELLOW ) ; $ this -> outputList ( $ except ) ; } $ this -> stdout ( "\nBe aware that:\n" , Console :: BOLD ) ; $ this -> stdout ( "Applying leads to purging of certain data in the database!\n" , Console :: FG_RED ) ; return $ this -> confirm ( "\nLoad above fixtures?" ) ; }
4728	private function setCache ( $ singular , $ plural = null ) { $ singular = StringHelper :: strtolower ( $ singular ) ; if ( $ plural === null ) { $ plural = $ singular ; } else { $ plural = StringHelper :: strtolower ( $ plural ) ; } $ this -> cache [ $ singular ] = $ plural ; }
9166	public function getValidationStatus ( $ action = '' ) { $ validation_status = null ; if ( isset ( $ _SESSION [ 'prototyper_validation' ] [ $ action ] ) ) { $ validation_status = $ _SESSION [ 'prototyper_validation' ] [ $ action ] ; } return $ validation_status ; }
220	private function formatNumber ( $ value , $ decimals , $ maxPosition , $ formatBase , $ options , $ textOptions ) { $ value = $ this -> normalizeNumericValue ( $ value ) ; $ position = 0 ; if ( is_array ( $ formatBase ) ) { $ maxPosition = count ( $ formatBase ) - 1 ; } do { if ( is_array ( $ formatBase ) ) { if ( ! isset ( $ formatBase [ $ position + 1 ] ) ) { break ; } if ( abs ( $ value ) < $ formatBase [ $ position + 1 ] ) { break ; } } else { if ( abs ( $ value ) < $ formatBase ) { break ; } $ value /= $ formatBase ; } $ position ++ ; } while ( $ position < $ maxPosition + 1 ) ; if ( is_array ( $ formatBase ) && $ position !== 0 ) { $ value /= $ formatBase [ $ position ] ; } if ( $ position === 0 ) { $ decimals = 0 ; } elseif ( $ decimals !== null ) { $ value = round ( $ value , $ decimals ) ; } $ oldThousandSeparator = $ this -> thousandSeparator ; $ this -> thousandSeparator = '' ; if ( $ this -> _intlLoaded && ! isset ( $ options [ NumberFormatter :: GROUPING_USED ] ) ) { $ options [ NumberFormatter :: GROUPING_USED ] = false ; } $ params = [ 'n' => abs ( $ value ) , 'nFormatted' => $ this -> asDecimal ( $ value , $ decimals , $ options , $ textOptions ) , ] ; $ this -> thousandSeparator = $ oldThousandSeparator ; return [ $ params , $ position ] ; }
4469	public function cancel ( $ dependents = false ) : array { if ( $ dependents && ! empty ( $ this -> rawData [ 'dependents' ] ) ) { return call_user_func_array ( [ $ this -> client , 'cancel' ] , array_merge ( [ $ this -> jid ] , $ this -> rawData [ 'dependents' ] ) ) ; } return $ this -> client -> cancel ( $ this -> jid ) ; }
9254	public function handle ( Request $ request , $ type = self :: MASTER_REQUEST , $ catch = true ) { if ( ! $ this -> booted ) { $ this -> boot ( ) ; } $ request -> attributes -> set ( 'app' , $ this ) ; return $ this -> kernel -> handle ( $ request , $ type , $ catch ) ; }
2628	protected function getOptions ( $ label = false ) { $ options = [ ] ; foreach ( $ this -> _storeManager -> getStores ( ) as $ store ) { $ options [ ] = [ 'value' => $ store -> getId ( ) , 'label' => $ store -> getName ( ) ] ; } if ( $ label ) { array_unshift ( $ options , [ 'value' => '' , 'label' => $ label ] ) ; } return $ options ; }
11592	public function getFullPath ( $ file = '' ) { $ this -> name = ( $ file ) ? $ file : $ this -> name ; return config ( 'odin.assetsUrl' ) . $ this -> getPath ( ) . $ this -> name ; }
566	public function setScriptFile ( $ value ) { $ scriptFile = realpath ( Yii :: getAlias ( $ value ) ) ; if ( $ scriptFile !== false && is_file ( $ scriptFile ) ) { $ this -> _scriptFile = $ scriptFile ; } else { throw new InvalidConfigException ( 'Unable to determine the entry script file path.' ) ; } }
5993	public function addSearchSort ( $ item ) { if ( ! ( $ item instanceof SearchSort ) ) { if ( is_array ( $ item ) ) { try { $ item = new SearchSort ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate SearchSort. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "SearchSort"!' , E_USER_WARNING ) ; } } $ this -> sortFields [ ] = $ item ; return $ this ; }
3869	protected function getMetaModel ( $ identifier , $ ignoreError ) { $ factory = $ this -> getMetaModelsFactory ( ) ; if ( is_numeric ( $ identifier ) ) { $ identifier = $ factory -> translateIdToMetaModelName ( $ identifier ) ; } $ metaModels = $ factory -> getMetaModel ( $ identifier ) ; if ( ! $ ignoreError && $ metaModels == null ) { throw new \ RuntimeException ( 'Could not find the MetaModels with the name ' . $ identifier ) ; } return $ metaModels ; }
12736	public function mapModelToLangName ( $ modelName , $ langName ) { $ modelName = $ this -> getClassName ( $ modelName ) ; $ this -> modelToLangName [ $ modelName ] = $ langName ; }
5533	public function paintRectangleStart ( $ node , $ horiz , $ vert ) { $ name = $ node -> getName ( ) ; $ description = $ node -> getDescription ( ) ; $ status = $ node -> getStatus ( ) ; echo "<div title=\"$name: $description\" class=\"$status\" style=\"width:{$horiz}%;height:{$vert}%\">" ; }
1200	public function get ( $ menu , array $ path = array ( ) , array $ options = array ( ) ) { if ( ! $ menu instanceof ItemInterface ) { if ( null === $ this -> menuProvider ) { throw new \ BadMethodCallException ( 'A menu provider must be set to retrieve a menu' ) ; } $ menuName = $ menu ; $ menu = $ this -> menuProvider -> get ( $ menuName , $ options ) ; if ( ! $ menu instanceof ItemInterface ) { throw new \ LogicException ( sprintf ( 'The menu "%s" exists, but is not a valid menu item object. Check where you created the menu to be sure it returns an ItemInterface object.' , $ menuName ) ) ; } } foreach ( $ path as $ child ) { $ menu = $ menu -> getChild ( $ child ) ; if ( null === $ menu ) { throw new \ InvalidArgumentException ( sprintf ( 'The menu has no child named "%s"' , $ child ) ) ; } } return $ menu ; }
6946	private function getRegularDueQueryBuilder ( ) { $ qb = $ this -> createQueryBuilder ( 'o' ) ; $ ex = $ qb -> expr ( ) ; return $ qb -> where ( $ ex -> andX ( $ ex -> eq ( 'o.sample' , ':not_sample' ) , $ ex -> lt ( 'o.paidTotal' , 'o.grandTotal' ) , $ ex -> notIn ( 'o.invoiceState' , ':canceled_or_refunded' ) , $ ex -> eq ( 'o.shipmentState' , ':shipped' ) , $ ex -> isNull ( 'o.paymentTerm' ) ) ) -> addOrderBy ( 'o.createdAt' , 'ASC' ) -> setParameter ( 'not_sample' , false ) -> setParameter ( 'shipped' , ShipmentStates :: STATE_COMPLETED ) -> setParameter ( 'canceled_or_refunded' , [ InvoiceStates :: STATE_CANCELED , InvoiceStates :: STATE_CREDITED ] ) ; }
12008	public function getMessages ( $ domain = 'default' , $ locale = null ) { if ( $ locale === null ) { $ locale = $ this -> getLocale ( ) ; } if ( ! isset ( $ this -> messages [ $ domain ] [ $ locale ] ) ) { $ this -> loadMessages ( $ domain , $ locale ) ; } return $ this -> messages [ $ domain ] [ $ locale ] ; }
9879	private function writeBookViews ( XMLWriter $ objWriter , Spreadsheet $ spreadsheet ) { $ objWriter -> startElement ( 'bookViews' ) ; $ objWriter -> startElement ( 'workbookView' ) ; $ objWriter -> writeAttribute ( 'activeTab' , $ spreadsheet -> getActiveSheetIndex ( ) ) ; $ objWriter -> writeAttribute ( 'autoFilterDateGrouping' , '1' ) ; $ objWriter -> writeAttribute ( 'firstSheet' , '0' ) ; $ objWriter -> writeAttribute ( 'minimized' , '0' ) ; $ objWriter -> writeAttribute ( 'showHorizontalScroll' , '1' ) ; $ objWriter -> writeAttribute ( 'showSheetTabs' , '1' ) ; $ objWriter -> writeAttribute ( 'showVerticalScroll' , '1' ) ; $ objWriter -> writeAttribute ( 'tabRatio' , '600' ) ; $ objWriter -> writeAttribute ( 'visibility' , 'visible' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; }
7168	public function updateTab ( $ tabLabel , array $ formInputs ) { $ tabExists = false ; foreach ( $ this -> getTabs ( ) as $ tabIndex => $ tabInfo ) { if ( array_get ( $ tabInfo , 'label' ) === $ tabLabel ) { $ this -> currentTab = $ tabIndex ; $ this -> currentInputsGroup = null ; if ( count ( ( array ) array_get ( $ tabInfo , 'groups' , [ ] ) ) === 1 && is_int ( array_keys ( $ tabInfo [ 'groups' ] ) [ 0 ] ) ) { $ this -> currentInputsGroup = array_keys ( $ tabInfo [ 'groups' ] ) [ 0 ] ; } $ tabExists = true ; break ; } } if ( ! $ tabExists ) { $ this -> newTab ( $ tabLabel ) ; } $ this -> setFormInputs ( $ formInputs ) ; $ this -> currentTab = null ; $ this -> currentInputsGroup = null ; return $ this ; }
2355	public function hasFrontendUser ( ) : bool { $ token = $ this -> getToken ( FrontendUser :: SECURITY_SESSION_KEY ) ; return null !== $ token && $ token -> getUser ( ) instanceof FrontendUser ; }
9814	public function addEntriesToBlacklist ( $ id , $ entries , $ importName = null ) { if ( $ importName == null ) { $ importName = "phpclient_import_" . uniqid ( ) ; } $ action = new AddEntriesAction ( ) ; $ action -> importName = $ importName ; $ action -> entries = $ entries ; return $ this -> post ( "blacklists/" . $ id . "/actions" , $ action -> toXMLString ( ) ) ; }
8668	public function setSelf ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'Self' ] [ 'FieldValue' ] = $ value ; return $ this ; }
846	public function generatePartialCode ( $ start , $ end ) { $ code = '' ; for ( $ i = $ start ; $ i <= $ end ; ++ $ i ) { $ code .= $ this [ $ i ] -> getContent ( ) ; } return $ code ; }
6338	public static function factory ( $ streamClass = 'GuzzleHttp\\Psr7\\Stream' ) { return new static ( [ new ResourceAdapter ( $ streamClass ) , new DomDocumentAdapter ( $ streamClass ) , new SimpleXmlAdapter ( $ streamClass ) , new StringAdapter ( $ streamClass ) , ] ) ; }
10207	public function get ( $ resourcePath , $ queryParameters = array ( ) , $ mimeType = 'application/vnd.maileon.api+xml' , $ deserializationType = null ) { $ curlSession = $ this -> prepareSession ( $ resourcePath , $ queryParameters , $ mimeType ) ; return $ this -> performRequest ( $ curlSession , $ deserializationType ) ; }
11833	public function doRestore ( ModulesEvent $ event ) { $ cache = $ this -> getCache ( ) ; $ data = $ cache -> get ( 'config' ) ; if ( $ data ) { $ services = $ this -> getServices ( ) ; $ services -> set ( 'Config' , $ data ) ; $ event -> stopPropagation ( true ) ; } }
8237	protected function configGenerationAction ( ParameterBag $ post ) { if ( ! $ this -> picoAuth -> isValidCSRF ( $ post -> get ( "csrf_token" ) ) ) { $ this -> picoAuth -> addOutput ( "installer_step" , 1 ) ; return ; } $ this -> picoAuth -> addOutput ( "installer_step" , 2 ) ; $ this -> outputModulesConfiguration ( $ post ) ; }
7564	protected function parse_compare ( ) { if ( ( ( $ this -> pos + 1 ) < $ this -> size ) && ( $ this -> doc [ $ this -> pos + 1 ] === '=' ) ) { switch ( $ this -> doc [ $ this -> pos ++ ] ) { case '$' : return ( $ this -> token = self :: TOK_COMPARE_ENDS ) ; case '%' : return ( $ this -> token = self :: TOK_COMPARE_REGEX ) ; case '^' : return ( $ this -> token = self :: TOK_COMPARE_STARTS ) ; case '<' : return ( $ this -> token = self :: TOK_COMPARE_SMALLER_THAN ) ; } } return false ; }
844	public function clearEmptyTokens ( ) { $ limit = $ this -> count ( ) ; $ index = 0 ; for ( ; $ index < $ limit ; ++ $ index ) { if ( $ this -> isEmptyAt ( $ index ) ) { break ; } } if ( $ limit === $ index ) { return ; } for ( $ count = $ index ; $ index < $ limit ; ++ $ index ) { if ( ! $ this -> isEmptyAt ( $ index ) ) { $ this [ $ count ++ ] = $ this [ $ index ] ; } } $ this -> setSize ( $ count ) ; }
12274	public static function createFromFormat ( $ format , $ time , $ object = null ) { if ( empty ( $ object ) ) { $ object = new DateTimeZone ( 'America/Sao_Paulo' ) ; } return self :: cast ( parent :: createFromFormat ( $ format , $ time , $ object ) ) ; }
5833	protected function headerToArray ( $ header ) { $ tmp = explode ( "\r\n" , $ header ) ; $ headers = array ( ) ; foreach ( $ tmp as $ singleHeader ) { $ delimiter = strpos ( $ singleHeader , ': ' ) ; if ( $ delimiter !== false ) { $ key = substr ( $ singleHeader , 0 , $ delimiter ) ; $ val = substr ( $ singleHeader , $ delimiter + 2 ) ; $ headers [ $ key ] = $ val ; } else { $ delimiter = strpos ( $ singleHeader , ' ' ) ; if ( $ delimiter !== false ) { $ key = substr ( $ singleHeader , 0 , $ delimiter ) ; $ val = substr ( $ singleHeader , $ delimiter + 1 ) ; $ headers [ $ key ] = $ val ; } } } return $ headers ; }
11966	public function renderSlots ( Page $ page , array $ slots , array $ options = array ( ) ) { $ renderedSlots = array ( ) ; $ slots = $ this -> dispatchSlotsEvent ( RenderEvents :: SLOTS_RENDERING , $ page , $ slots ) ; foreach ( $ slots as $ slotName => $ slot ) { if ( is_string ( $ slot ) ) { $ renderedSlots [ $ slotName ] = $ slot ; continue ; } if ( ! $ slot instanceof Slot ) { continue ; } $ renderedSlots [ $ slotName ] = implode ( "" , $ this -> renderSlot ( $ slot ) ) ; } $ this -> mediaFiles = array_unique ( $ this -> mediaFiles ) ; return $ this -> dispatchSlotsEvent ( RenderEvents :: SLOTS_RENDERED , $ page , $ renderedSlots ) ; }
1683	public function getModules ( ) { $ arrModules = array ( ) ; foreach ( $ GLOBALS [ 'BE_MOD' ] as $ k => $ v ) { if ( ! empty ( $ v ) ) { if ( $ k == 'accounts' ) { unset ( $ v [ 'login' ] ) ; } if ( $ k == 'system' ) { unset ( $ v [ 'undo' ] ) ; } $ arrModules [ $ k ] = array_keys ( $ v ) ; } } return $ arrModules ; }
9373	public function display ( ) { $ handler = new PrettyPageHandler ; error_reporting ( E_ALL ) ; $ this -> __call ( 'pushHandler' , array ( $ handler ) ) ; return $ this -> whoops -> register ( ) ; }
11424	public function lists ( $ nextOpenId = null ) { $ params = [ 'next_openid' => $ nextOpenId ] ; return $ this -> parseJSON ( 'get' , [ self :: API_LIST , $ params ] ) ; }
11273	public function sendRequest ( RequestInterface $ request ) { $ this -> lastOperation = new Operation ( $ request ) ; $ response = parent :: sendRequest ( $ request ) ; $ this -> lastOperation -> setResponse ( $ response ) ; return $ response ; }
2662	public function getBackends ( $ version ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/backend' ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: GET ) ; return $ result ; }
12877	public function generateAndroidManifest ( ) { $ pinicon = $ this -> owner -> AndroidPinicon ( ) ; if ( $ pinicon -> exists ( ) ) { $ manifest = new stdClass ( ) ; $ manifest -> name = $ this -> owner -> PiniconTitle ; $ manifest -> icons = array ( ) ; array_push ( $ manifest -> icons , array ( 'src' => $ pinicon -> Fill ( 36 , 36 ) -> getAbsoluteURL ( ) , 'sizes' => '36x36' , 'type' => 'image/png' , 'density' => 0.75 ) ) ; array_push ( $ manifest -> icons , array ( 'src' => $ pinicon -> Fill ( 48 , 48 ) -> getAbsoluteURL ( ) , 'sizes' => '48x48' , 'type' => 'image/png' , 'density' => 1 ) ) ; array_push ( $ manifest -> icons , array ( 'src' => $ pinicon -> Fill ( 72 , 72 ) -> getAbsoluteURL ( ) , 'sizes' => '72x72' , 'type' => 'image/png' , 'density' => 1.5 ) ) ; array_push ( $ manifest -> icons , array ( 'src' => $ pinicon -> Fill ( 96 , 96 ) -> getAbsoluteURL ( ) , 'sizes' => '96x96' , 'type' => 'image/png' , 'density' => 2 ) ) ; array_push ( $ manifest -> icons , array ( 'src' => $ pinicon -> Fill ( 144 , 144 ) -> getAbsoluteURL ( ) , 'sizes' => '144x144' , 'type' => 'image/png' , 'density' => 3 ) ) ; array_push ( $ manifest -> icons , array ( 'src' => $ pinicon -> Fill ( 192 , 192 ) -> getAbsoluteURL ( ) , 'sizes' => '192x192' , 'type' => 'image/png' , 'density' => 4 ) ) ; $ bytes = file_put_contents ( Director :: baseFolder ( ) . '/manifest.json' , json_encode ( $ manifest ) ) ; if ( $ bytes !== false ) { return true ; } } return false ; }
9309	public function show ( $ id , $ params = [ ] ) { $ data = [ 'id' => $ id ] + $ params ; return $ this -> query ( __FUNCTION__ , $ data ) ; }
8089	static protected function encode ( $ number ) { $ k = self :: $ encoder ; preg_match_all ( "/[1-9][0-9]|[0-9]/" , $ number , $ a ) ; $ n = '' ; $ o = count ( $ k ) ; foreach ( $ a [ 0 ] as $ i ) { if ( $ i < $ o ) { $ n .= $ k [ $ i ] ; } else { $ n .= '1' . $ k [ $ i - $ o ] ; } } return $ n ; }
12156	public function getOwner ( ) { if ( ! $ this -> isOwnable ) { return ; } $ ownerObject = $ this -> getOwnerObject ( ) ; if ( is_object ( $ ownerObject ) ) { return $ ownerObject -> primaryKey ; } return $ ownerObject ; }
2258	protected function prepareForWidget ( $ arrData , $ strName , $ varValue = null , $ strField = '' , $ strTable = '' ) { @ trigger_error ( 'Using Controller::prepareForWidget() has been deprecated and will no longer work in Contao 5.0. Use Widget::getAttributesFromDca() instead.' , E_USER_DEPRECATED ) ; return Widget :: getAttributesFromDca ( $ arrData , $ strName , $ varValue , $ strField , $ strTable ) ; }
8291	protected function logout ( ) { $ oldUser = $ this -> user ; $ this -> user = new User ( ) ; $ this -> session -> invalidate ( ) ; $ this -> triggerEvent ( "afterLogout" , [ $ oldUser ] ) ; $ this -> redirectToPage ( $ this -> config [ "afterLogout" ] ) ; }
4847	public static function unregister ( ) { if ( isset ( self :: $ autoloadFn ) ) { spl_autoload_unregister ( self :: $ autoloadFn ) ; self :: $ autoloadFn = null ; } self :: $ aliases = [ ] ; }
12766	public function run ( ) : void { $ this -> isRan = true ; foreach ( $ this -> getAll ( ) as $ header ) { header ( $ header ) ; } }
3734	protected function saveSimpleColumn ( $ strColumn , $ arrIds , $ varData ) { if ( is_array ( $ varData ) ) { $ varData = serialize ( $ varData ) ; } $ builder = $ this -> getConnection ( ) -> createQueryBuilder ( ) ; $ builder -> update ( $ this -> getTableName ( ) , 'v2' ) -> set ( 'v2.' . $ strColumn , is_array ( $ varData ) ? serialize ( $ varData ) : $ varData ) -> where ( $ builder -> expr ( ) -> in ( 'v2.id' , ':ids' ) ) -> setParameter ( 'ids' , $ arrIds , Connection :: PARAM_STR_ARRAY ) -> execute ( ) ; }
331	public function mset ( $ items , $ duration = 0 , $ dependency = null ) { return $ this -> multiSet ( $ items , $ duration , $ dependency ) ; }
6667	public function prepareResponse ( ) { if ( ! $ this -> writer ) { $ this -> writer = $ this -> writerFactory -> getWriterFor ( $ this -> request -> getFormats ( ) ) ; } $ this -> preparedResponse = $ this -> writer -> format ( $ this -> getBody ( ) , $ this -> responseName ) ; return $ this ; }
3012	public function unfollow ( $ blogName ) { $ options = array ( 'url' => $ this -> blogUrl ( $ blogName ) ) ; return $ this -> postRequest ( 'v2/user/unfollow' , $ options , false ) ; }
7416	public function getMaxFileSize ( ) : int { $ iniMax = strtolower ( ini_get ( 'upload_max_filesize' ) ) ; if ( '' === $ iniMax ) { return PHP_INT_MAX ; } $ max = ltrim ( $ iniMax , '+' ) ; if ( 0 === strpos ( $ max , '0x' ) ) { $ max = intval ( $ max , 16 ) ; } elseif ( 0 === strpos ( $ max , '0' ) ) { $ max = intval ( $ max , 8 ) ; } else { $ max = ( int ) $ max ; } switch ( substr ( $ iniMax , - 1 ) ) { case 't' : $ max *= 1024 ; case 'g' : $ max *= 1024 ; case 'm' : $ max *= 1024 ; case 'k' : $ max *= 1024 ; } return $ max ; }
1576	public function register ( $ apiName , $ options = [ ] , Closure $ routes = null ) : ApiRegistration { $ registrar = $ this -> container -> make ( 'json-api.registrar' ) ; return $ registrar -> api ( $ apiName , $ options , $ routes ) ; }
5021	public function getFieldInputSpecification ( $ field ) { if ( ! $ this -> hasField ( $ field ) ) { return [ ] ; } if ( ! isset ( $ this -> fields [ $ field ] [ '__filter__' ] ) ) { $ this -> fields [ $ field ] [ '__filter__' ] = $ this -> copyArrayValues ( $ this -> fields [ $ field ] , [ 'input_filter' => [ ] , 'required' , ] ) ; } return $ this -> fields [ $ field ] [ '__filter__' ] ; }
937	public static function getKeywords ( ) { static $ keywords = null ; if ( null === $ keywords ) { $ keywords = self :: getTokenKindsForNames ( [ 'T_ABSTRACT' , 'T_ARRAY' , 'T_AS' , 'T_BREAK' , 'T_CALLABLE' , 'T_CASE' , 'T_CATCH' , 'T_CLASS' , 'T_CLONE' , 'T_CONST' , 'T_CONTINUE' , 'T_DECLARE' , 'T_DEFAULT' , 'T_DO' , 'T_ECHO' , 'T_ELSE' , 'T_ELSEIF' , 'T_EMPTY' , 'T_ENDDECLARE' , 'T_ENDFOR' , 'T_ENDFOREACH' , 'T_ENDIF' , 'T_ENDSWITCH' , 'T_ENDWHILE' , 'T_EVAL' , 'T_EXIT' , 'T_EXTENDS' , 'T_FINAL' , 'T_FINALLY' , 'T_FOR' , 'T_FOREACH' , 'T_FUNCTION' , 'T_GLOBAL' , 'T_GOTO' , 'T_HALT_COMPILER' , 'T_IF' , 'T_IMPLEMENTS' , 'T_INCLUDE' , 'T_INCLUDE_ONCE' , 'T_INSTANCEOF' , 'T_INSTEADOF' , 'T_INTERFACE' , 'T_ISSET' , 'T_LIST' , 'T_LOGICAL_AND' , 'T_LOGICAL_OR' , 'T_LOGICAL_XOR' , 'T_NAMESPACE' , 'T_NEW' , 'T_PRINT' , 'T_PRIVATE' , 'T_PROTECTED' , 'T_PUBLIC' , 'T_REQUIRE' , 'T_REQUIRE_ONCE' , 'T_RETURN' , 'T_STATIC' , 'T_SWITCH' , 'T_THROW' , 'T_TRAIT' , 'T_TRY' , 'T_UNSET' , 'T_USE' , 'T_VAR' , 'T_WHILE' , 'T_YIELD' , 'T_YIELD_FROM' , ] ) + [ CT :: T_ARRAY_TYPEHINT => CT :: T_ARRAY_TYPEHINT , CT :: T_CLASS_CONSTANT => CT :: T_CLASS_CONSTANT , CT :: T_CONST_IMPORT => CT :: T_CONST_IMPORT , CT :: T_FUNCTION_IMPORT => CT :: T_FUNCTION_IMPORT , CT :: T_NAMESPACE_OPERATOR => CT :: T_NAMESPACE_OPERATOR , CT :: T_USE_TRAIT => CT :: T_USE_TRAIT , CT :: T_USE_LAMBDA => CT :: T_USE_LAMBDA , ] ; } return $ keywords ; }
2181	private function filterNestedPaths ( Finder $ finder , string $ prepend ) : array { $ parents = [ ] ; $ files = iterator_to_array ( $ finder ) ; foreach ( $ files as $ key => $ file ) { $ path = rtrim ( strtr ( $ prepend . '/' . $ file -> getRelativePath ( ) , '\\' , '/' ) , '/' ) ; if ( ! empty ( $ parents ) ) { $ parent = \ dirname ( $ path ) ; while ( false !== strpos ( $ parent , '/' ) ) { if ( \ in_array ( $ parent , $ parents , true ) ) { $ this -> rows [ ] = [ sprintf ( '<fg=yellow;options=bold>%s</>' , '\\' === \ DIRECTORY_SEPARATOR ? 'WARNING' : '!' ) , $ this -> webDir . '/' . $ path , sprintf ( '<comment>Skipped because %s will be symlinked.</comment>' , $ parent ) , ] ; unset ( $ files [ $ key ] ) ; break ; } $ parent = \ dirname ( $ parent ) ; } } $ parents [ ] = $ path ; } return array_values ( $ files ) ; }
7204	public function getDiscount ( bool $ ati = false ) : float { return $ ati ? $ this -> ati ( $ this -> discount ) : $ this -> discount ; }
1258	private function makeVar ( $ prefix ) { if ( ! isset ( $ this -> vars [ $ prefix ] ) ) { $ this -> vars [ $ prefix ] = 0 ; return '$' . $ prefix ; } return '$' . $ prefix . ++ $ this -> vars [ $ prefix ] ; }
1140	protected function computeLevel ( ) { list ( $ node , $ nesting ) = $ this -> determineDepth ( $ this ) ; if ( $ node -> equals ( $ this ) ) return $ this -> ancestors ( ) -> count ( ) ; return $ node -> getLevel ( ) + $ nesting ; }
5187	private function createPhoto ( string $ url , string $ ratio , string $ desc , string $ info ) : \ One \ Model \ Photo { return new Photo ( $ url , $ ratio , $ this -> handleString ( $ desc ) , $ this -> handleString ( $ info ) ) ; }
10576	public static function applyStyle ( $ text , $ style ) { $ foreground = self :: getForeground ( $ style ) ; $ background = self :: getBackground ( $ style ) ; return self :: apply ( $ text , $ foreground , $ background ) ; }
11149	protected function process ( array $ requestParams ) { $ request = new ExtDirectRequest ( $ this -> useCache ( ) , $ this -> getApplicationPath ( ) , $ this -> getApplicationNameSpace ( ) ) ; $ response = new ExtDirectResponse ( ) ; $ requestParameters = new Parameters ( ) ; try { $ request -> setApplicationPath ( $ this -> getApplicationPath ( ) ) ; $ requestParameters -> setParameters ( $ requestParams ) ; $ request -> injectParameters ( $ requestParameters ) ; $ response -> injectParameters ( $ requestParameters ) ; $ request -> injectResponse ( $ response ) ; $ request -> setParamMethod ( $ this -> getParamMethod ( ) ) ; $ request -> setMethodCalls ( $ this -> getMethodsToCall ( ) ) ; $ request -> run ( ) ; } catch ( ExtDirectApplicationException $ e ) { $ result = $ e -> getResponse ( ) ; if ( ! empty ( $ result ) ) { $ response -> setResult ( array ( "success" => false , "message" => $ e -> getMessage ( ) , "actions" => $ result ) ) ; } else { $ response -> setResult ( array ( "success" => false , "message" => $ e -> getMessage ( ) ) ) ; } } catch ( \ Exception $ e ) { $ response -> setResult ( array ( "success" => false , "message" => $ e -> getMessage ( ) ) ) ; } return $ response ; }
10074	static function init ( ) { if ( self :: $ initialized == false ) { self :: $ UPDATE = new SynchronizationMode ( 1 ) ; self :: $ IGNORE = new SynchronizationMode ( 2 ) ; self :: $ initialized = true ; } }
742	public function afterRun ( $ event ) { echo $ event -> result ; $ event -> result = null ; $ this -> owner -> view -> endCache ( ) ; }
4541	public function set ( string $ key , $ value ) { $ config = $ this -> repository -> findOneBy ( [ 'key' => $ key ] ) ; if ( ! $ config ) { throw new OutOfRangeException ( 'Config "' . $ key . '" does not exist.' ) ; } $ config -> setKey ( $ key ) -> setValue ( $ value ) ; $ this -> manager -> persist ( $ config ) ; $ this -> manager -> flush ( ) ; $ this -> manager -> detach ( $ config ) ; }
12248	public function xpathSingle ( $ strXpathQuery ) { $ arrResults = $ this -> xpath ( $ strXpathQuery ) ; if ( $ arrResults === false ) { return null ; } if ( is_array ( $ arrResults ) && count ( $ arrResults ) == 0 ) { return null ; } else { if ( count ( $ arrResults ) > 1 ) { throw new Exception ( 'xpathSingle expects a single element as result, got ' . count ( $ arrResults ) . ' elements instead.' ) ; } else { return current ( $ arrResults ) ; } } }
12407	public function set ( $ key , $ value ) { try { $ filenameCache = $ this -> location . DS . $ key ; file_put_contents ( $ filenameCache , $ value ) ; } catch ( \ Exception $ e ) { return false ; } return true ; }
8755	public function buildTracker ( $ numItems = Tracker :: UNKNOWN , array $ extraSubscribers = [ ] ) { $ tracker = new Tracker ( $ numItems ) ; foreach ( array_merge ( $ this -> defaultSubscribers , $ extraSubscribers ) as $ listener ) { $ tracker -> getDispatcher ( ) -> addSubscriber ( $ listener ) ; } return $ tracker ; }
4640	private function createHelperPluginManager ( ContainerInterface $ container ) : HelperPluginManager { $ factory = new ViewHelperManagerFactory ( ) ; $ helperManager = $ factory ( $ container , ViewHelperManagerFactory :: PLUGIN_MANAGER_CLASS ) ; $ config = new Config ( $ this -> getSpecificConfig ( $ container , 'view_helpers' ) ) ; $ config -> configureServiceManager ( $ helperManager ) ; return $ helperManager ; }
4704	public function get ( $ name ) { if ( ! $ this -> exists ( $ name ) ) { throw new \ OutOfBoundsException ( sprintf ( 'Undefined offset "%s"' , $ name ) ) ; } return $ this -> objects [ ( string ) $ name ] ; }
9902	private static function cellAddressInDeleteRange ( $ cellAddress , $ beforeRow , $ pNumRows , $ beforeColumnIndex , $ pNumCols ) { list ( $ cellColumn , $ cellRow ) = Coordinate :: coordinateFromString ( $ cellAddress ) ; $ cellColumnIndex = Coordinate :: columnIndexFromString ( $ cellColumn ) ; if ( $ pNumRows < 0 && ( $ cellRow >= ( $ beforeRow + $ pNumRows ) ) && ( $ cellRow < $ beforeRow ) ) { return true ; } elseif ( $ pNumCols < 0 && ( $ cellColumnIndex >= ( $ beforeColumnIndex + $ pNumCols ) ) && ( $ cellColumnIndex < $ beforeColumnIndex ) ) { return true ; } return false ; }
3692	protected function breadcrumb ( EnvironmentInterface $ environment ) { $ event = new GetBreadcrumbEvent ( $ environment ) ; $ environment -> getEventDispatcher ( ) -> dispatch ( $ event :: NAME , $ event ) ; $ arrReturn = $ event -> getElements ( ) ; if ( ! is_array ( $ arrReturn ) || count ( $ arrReturn ) == 0 ) { return null ; } $ GLOBALS [ 'TL_CSS' ] [ ] = 'bundles/ccadcgeneral/css/generalBreadcrumb.css' ; $ objTemplate = new ContaoBackendViewTemplate ( 'dcbe_general_breadcrumb' ) ; $ objTemplate -> elements = $ arrReturn ; return $ objTemplate -> parse ( ) ; }
2657	public function createResponse ( $ version , array $ response ) { $ checkIfExists = $ this -> getResponse ( $ version , $ response [ 'name' ] ) ; $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/response_object' ; if ( ! $ checkIfExists ) { $ verb = \ Zend_Http_Client :: POST ; } else { $ verb = \ Zend_Http_Client :: PUT ; $ url .= '/' . $ response [ 'name' ] ; } $ result = $ this -> _fetch ( $ url , $ verb , $ response ) ; return $ result ; }
10773	public static function with ( array $ theseObjects ) : MapsObjectsByIdentity { $ objects = [ ] ; $ entityIds = [ ] ; foreach ( $ theseObjects as $ id => $ object ) { $ objects = IdentityMap :: addTo ( $ objects , ( string ) $ id , $ object ) ; $ entityIds [ theInstanceIdOf ( $ object ) ] = ( string ) $ id ; } return new self ( $ objects , $ entityIds ) ; }
3877	public function build ( ) { if ( ! $ this -> isEmpty ( ) ) { return new SimpleQuery ( sprintf ( 'SELECT id FROM %s WHERE %s' , $ this -> tableName , $ this -> getProcedure ( ) ) , $ this -> getParameters ( ) , 'id' , $ this -> connection ) ; } return null ; }
12776	protected function write ( $ namespace , array $ data ) { $ file = $ this -> adapter -> getFileName ( $ namespace ) ; $ contents = $ this -> adapter -> prepareForWriting ( $ data ) ; if ( ! $ this -> fileSystem -> has ( $ file ) ) { $ this -> fileSystem -> write ( $ file , $ contents ) ; } $ this -> fileSystem -> update ( $ file , $ contents ) ; }
9927	private function cleanUnwanted ( Parameters $ params , $ permitted ) { foreach ( $ params -> toArray ( ) as $ key => $ value ) { if ( is_array ( $ value ) && ! is_int ( $ key ) ) { if ( ! array_key_exists ( $ key , $ permitted ) ) { $ this -> handleUnpermittedParam ( $ key , $ params ) ; } } elseif ( ! is_int ( $ key ) && ! in_array ( $ key , $ permitted ) && ! array_key_exists ( $ key , $ permitted ) ) { $ this -> handleUnpermittedParam ( $ key , $ params ) ; } } }
9100	private function bind ( ) { if ( ! @ socket_bind ( $ this -> handle , $ this -> endpoint -> getAddress ( ) , $ this -> endpoint -> getPort ( ) ) ) { $ code = socket_last_error ( $ this -> handle ) ; throw new SocketException ( socket_strerror ( $ code ) , array ( ) , $ code ) ; } }
11088	public static function getUserBrowser ( ) { $ user_agent = $ _SERVER [ 'HTTP_USER_AGENT' ] ; $ user_browser = 'unknown' ; if ( false !== stripos ( $ user_agent , 'MSIE' ) && false === stripos ( $ user_agent , 'Opera' ) ) { $ user_browser = 'Internet Explorer' ; } elseif ( false !== stripos ( $ user_agent , 'Firefox' ) ) { $ user_browser = 'Mozilla Firefox' ; } elseif ( false !== stripos ( $ user_agent , 'Chrome' ) ) { $ user_browser = 'Google Chrome' ; } elseif ( false !== stripos ( $ user_agent , 'Safari' ) ) { $ user_browser = 'Apple Safari' ; } elseif ( false !== stripos ( $ user_agent , 'Opera' ) ) { $ user_browser = 'Opera' ; } elseif ( false !== stripos ( $ user_agent , 'Netscape' ) ) { $ user_browser = 'Netscape' ; } return $ user_browser ; }
3743	protected function setLanguage ( $ language = '' ) { $ previousLanguage = $ GLOBALS [ 'TL_LANGUAGE' ] ; if ( ! empty ( $ language ) && ( $ GLOBALS [ 'TL_LANGUAGE' ] !== $ language ) ) { $ GLOBALS [ 'TL_LANGUAGE' ] = $ language ; } return $ previousLanguage ; }
2705	public function execute ( ) { $ result = $ this -> resultJsonFactory -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ snippets = $ this -> config -> getVclSnippets ( Config :: VCL_AUTH_SNIPPET_PATH ) ; foreach ( $ snippets as $ key => $ value ) { $ name = Config :: FASTLY_MAGENTO_MODULE . '_basic_auth_' . $ key ; $ status = $ this -> api -> hasSnippet ( $ activeVersion , $ name ) ; if ( $ status == false ) { return $ result -> setData ( [ 'status' => false ] ) ; } } return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
10820	public static function warning ( $ messages , $ linebreak = true , $ length = 0 ) { $ separator = $ linebreak ? "\n" : '' ; self :: write ( $ messages , 'warning' , $ length , $ separator ) ; }
6570	public function getMessage ( ) { return '[' . $ this -> prefix . ( $ this -> context === null ? '' : ( ' - ' . get_class ( $ this -> context ) ) ) . '] ' . $ this -> msg ; }
8225	public function handleRegistration ( Request $ httpRequest ) { if ( ! $ this -> config [ "enabled" ] ) { return ; } $ user = $ this -> picoAuth -> getUser ( ) ; if ( $ user -> getAuthenticated ( ) ) { $ this -> picoAuth -> redirectToPage ( "index" ) ; } $ this -> picoAuth -> addAllowed ( "register" ) ; $ this -> picoAuth -> setRequestFile ( $ this -> picoAuth -> getPluginPath ( ) . '/content/register.md' ) ; $ post = $ httpRequest -> request ; if ( $ post -> has ( "username" ) && $ post -> has ( "email" ) && $ post -> has ( "password" ) && $ post -> has ( "password_repeat" ) ) { if ( ! $ this -> picoAuth -> isValidCSRF ( $ post -> get ( "csrf_token" ) , self :: REGISTER_CSRF_ACTION ) ) { $ this -> picoAuth -> redirectToPage ( "register" ) ; } $ this -> assertLimits ( ) ; $ reg = array ( "username" => strtolower ( trim ( $ post -> get ( "username" ) ) ) , "email" => trim ( $ post -> get ( "email" ) ) , "password" => new Password ( $ post -> get ( "password" ) ) , "passwordRepeat" => new Password ( $ post -> get ( "password_repeat" ) ) , ) ; $ isValid = $ this -> validateRegistration ( $ reg ) ; if ( $ isValid ) { if ( ! $ this -> limit -> action ( "registration" ) ) { $ this -> session -> addFlash ( "error" , $ this -> limit -> getError ( ) ) ; $ this -> picoAuth -> redirectToPage ( "register" ) ; } $ this -> logSuccessfulRegistration ( $ reg ) ; $ userData = array ( 'email' => $ reg [ "email" ] ) ; $ localAuth = $ this -> picoAuth -> getContainer ( ) -> get ( 'LocalAuth' ) ; $ localAuth -> userDataEncodePassword ( $ userData , $ reg [ "password" ] ) ; $ this -> storage -> saveUser ( $ reg [ "username" ] , $ userData ) ; $ this -> session -> addFlash ( "success" , "Registration completed successfully, you can now log in." ) ; $ this -> picoAuth -> redirectToLogin ( ) ; } else { $ this -> session -> addFlash ( "old" , array ( 'username' => $ reg [ "username" ] , 'email' => $ reg [ "email" ] ) ) ; $ this -> picoAuth -> redirectToPage ( "register" ) ; } } }
10649	private function buildUniqueRules ( ) { $ rulescopes = $ this -> rules ; foreach ( $ rulescopes as $ scope => & $ rules ) { foreach ( $ rules as $ field => & $ ruleset ) { $ ruleset = ( is_string ( $ ruleset ) ) ? explode ( '|' , $ ruleset ) : $ ruleset ; foreach ( $ ruleset as & $ rule ) { if ( str_contains ( $ rule , 'unique' ) && str_contains ( $ rule , '{id}' ) == false ) { $ params = explode ( ',' , $ rule ) ; $ uniqueRules = array ( ) ; $ table = explode ( ':' , $ params [ 0 ] ) ; if ( count ( $ table ) == 1 ) $ uniqueRules [ 1 ] = $ this -> table ; else $ uniqueRules [ 1 ] = $ table [ 1 ] ; if ( count ( $ params ) == 1 ) $ uniqueRules [ 2 ] = $ field ; else $ uniqueRules [ 2 ] = $ params [ 1 ] ; $ uniqueRules [ 3 ] = $ this -> getKey ( ) ; $ uniqueRules [ 4 ] = $ this -> getKeyName ( ) ; $ rule = 'unique:' . implode ( ',' , $ uniqueRules ) ; } elseif ( str_contains ( $ rule , 'unique' ) && str_contains ( $ rule , '{id}' ) ) { $ rule = str_replace ( '{id}' , $ this -> getKey ( ) , $ rule ) ; } } } } $ this -> rules = $ rulescopes ; }
6693	public static function sort ( $ a , $ b ) { if ( ! isset ( $ a [ 'position' ] ) ) { return 0 ; } if ( ! isset ( $ b [ 'position' ] ) ) { return 0 ; } if ( $ a [ 'position' ] === $ b [ 'position' ] ) { return 0 ; } return ( $ a [ 'position' ] < $ b [ 'position' ] ) ? - 1 : 1 ; }
4213	public static function colKeys ( $ rows ) { if ( ! \ is_array ( $ rows ) ) { return array ( ) ; } if ( Abstracter :: isAbstraction ( $ rows ) && $ rows [ 'traverseValues' ] ) { $ rows = $ rows [ 'traverseValues' ] ; } $ lastKeys = array ( ) ; $ newKeys = array ( ) ; $ curKeys = array ( ) ; foreach ( $ rows as $ row ) { $ curKeys = self :: keys ( $ row ) ; if ( empty ( $ lastKeys ) ) { $ lastKeys = $ curKeys ; } elseif ( $ curKeys != $ lastKeys ) { $ newKeys = array ( ) ; $ count = \ count ( $ curKeys ) ; for ( $ i = 0 ; $ i < $ count ; $ i ++ ) { $ curKey = $ curKeys [ $ i ] ; if ( $ lastKeys && $ curKey === $ lastKeys [ 0 ] ) { \ array_push ( $ newKeys , $ curKey ) ; \ array_shift ( $ lastKeys ) ; } elseif ( false !== $ position = \ array_search ( $ curKey , $ lastKeys , true ) ) { $ segment = \ array_splice ( $ lastKeys , 0 , $ position + 1 ) ; \ array_splice ( $ newKeys , \ count ( $ newKeys ) , 0 , $ segment ) ; } elseif ( ! \ in_array ( $ curKey , $ newKeys , true ) ) { \ array_push ( $ newKeys , $ curKey ) ; } } \ array_splice ( $ newKeys , \ count ( $ newKeys ) , 0 , $ lastKeys ) ; $ lastKeys = \ array_unique ( $ newKeys ) ; } } return $ lastKeys ; }
2069	public function cutPage ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { return ( $ this -> User -> hasAccess ( $ row [ 'type' ] , 'alpty' ) && $ this -> User -> isAllowed ( Contao \ BackendUser :: CAN_EDIT_PAGE_HIERARCHY , $ row ) ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' ; }
7446	public function updateAction ( $ id ) { $ em = $ this -> getDoctrine ( ) -> getEntityManager ( ) ; $ group = $ em -> getRepository ( 'Orkestra\Bundle\ApplicationBundle\Entity\Group' ) -> find ( $ id ) ; if ( ! $ group ) { throw $ this -> createNotFoundException ( 'Unable to locate Group' ) ; } $ form = $ this -> createForm ( GroupType :: class , $ group ) ; $ form -> bindRequest ( $ this -> getRequest ( ) ) ; if ( $ form -> isValid ( ) ) { $ em -> persist ( $ group ) ; $ em -> flush ( ) ; $ this -> get ( 'session' ) -> getFlashBag ( ) -> set ( 'success' , 'Your changes have been saved.' ) ; return $ this -> redirect ( $ this -> generateUrl ( 'orkestra_group_show' , array ( 'id' => $ id ) ) ) ; } return array ( 'group' => $ group , 'form' => $ form -> createView ( ) , ) ; }
7465	public static function createFromUploadedFile ( UploadedFile $ upload , $ uploadPath , $ filename = null ) { if ( ! $ upload -> isValid ( ) ) { throw new UploadException ( sprintf ( 'An error occurred during file upload. Error code: %s' , $ upload -> getError ( ) ) ) ; } elseif ( ( $ uploadPath = realpath ( $ uploadPath . '/' ) ) === false ) { throw new UploadException ( 'An error occurred during file upload. The specified upload path is invalid.' ) ; } if ( ! $ filename ) { $ fullPath = sprintf ( '%s%s%s.%s' , rtrim ( $ uploadPath , DIRECTORY_SEPARATOR ) , DIRECTORY_SEPARATOR , uniqid ( ) , ( $ upload -> getExtension ( ) ? : ( $ upload -> guessExtension ( ) ? : 'file' ) ) ) ; } else { $ fullPath = rtrim ( $ uploadPath , DIRECTORY_SEPARATOR ) . DIRECTORY_SEPARATOR . $ filename ; } $ file = new self ( $ fullPath , $ upload -> getClientOriginalName ( ) , $ upload -> getMimeType ( ) , $ upload -> getClientSize ( ) , md5_file ( $ upload -> getRealPath ( ) ) ) ; $ file -> _uploadedFile = $ upload ; return $ file ; }
2981	private function findLastImportedPath ( $ yamlContents ) { $ data = Yaml :: parse ( $ yamlContents ) ; if ( ! isset ( $ data [ 'imports' ] ) ) { return false ; } $ lastImport = end ( $ data [ 'imports' ] ) ; if ( ! isset ( $ lastImport [ 'resource' ] ) ) { return false ; } return $ lastImport [ 'resource' ] ; }
12542	public function get ( ) : \ TheCMSThread \ Core \ Main \ View { if ( $ this -> getLink ( ) == '/' ) { $ this -> details = Model \ Page :: find ( 1 ) ; } else { $ this -> details = Model \ Page :: where ( 'link' , $ this -> getLink ( ) ) ; if ( $ this -> auth -> allow ( [ "min" => 3 , "max" => 1 ] ) === false ) { $ this -> details -> where ( 'status' , true ) ; } $ this -> details = $ this -> details -> first ( ) ; } if ( $ this -> details === null ) { $ this -> details = false ; } return $ this ; }
1923	public static function fromDimensions ( $ width , $ height ) { $ image = imagecreatetruecolor ( $ width , $ height ) ; $ arrGdInfo = gd_info ( ) ; $ strGdVersion = preg_replace ( '/[^0-9.]+/' , '' , $ arrGdInfo [ 'GD Version' ] ) ; if ( version_compare ( $ strGdVersion , '2.0' , '>=' ) ) { imagealphablending ( $ image , false ) ; imagefill ( $ image , 0 , 0 , imagecolorallocatealpha ( $ image , 0 , 0 , 0 , 127 ) ) ; imagesavealpha ( $ image , true ) ; } return new static ( $ image ) ; }
9089	public function viewBody ( ) { $ sticky_values = hypePrototyper ( ) -> prototype -> getStickyValues ( $ this -> action ) ; hypePrototyper ( ) -> prototype -> clearStickyValues ( $ this -> action ) ; $ validation_status = hypePrototyper ( ) -> prototype -> getValidationStatus ( $ this -> action ) ; hypePrototyper ( ) -> prototype -> clearValidationStatus ( $ this -> action ) ; $ i = 0 ; foreach ( $ this -> fields as $ field ) { if ( ! $ field instanceof Field ) { continue ; } if ( $ field -> getInputView ( ) === false ) { continue ; } $ shortname = $ field -> getShortname ( ) ; if ( isset ( $ sticky_values [ $ shortname ] ) ) { $ field -> setStickyValue ( $ sticky_values [ $ shortname ] ) ; } if ( isset ( $ validation_status [ $ shortname ] ) ) { $ field -> setValidation ( $ validation_status [ $ shortname ] [ 'status' ] , $ validation_status [ $ shortname ] [ 'messages' ] ) ; } $ output .= $ field -> viewInput ( array ( 'index' => $ i , 'entity' => $ this -> entity , ) ) ; $ i ++ ; } $ submit = elgg_view ( 'prototyper/input/submit' , array ( 'entity' => $ this -> entity , 'action' => $ this -> action , ) ) ; $ output .= elgg_format_element ( 'div' , array ( 'class' => 'elgg-foot' , ) , $ submit ) ; return $ output ; }
31	public function parseHgIgnoreLine ( $ line ) { if ( preg_match ( '#^syntax\s*:\s*(glob|regexp)$#' , $ line , $ matches ) ) { if ( $ matches [ 1 ] === 'glob' ) { $ this -> patternMode = self :: HG_IGNORE_GLOB ; } else { $ this -> patternMode = self :: HG_IGNORE_REGEX ; } return null ; } if ( $ this -> patternMode == self :: HG_IGNORE_GLOB ) { return $ this -> patternFromGlob ( $ line ) ; } return $ this -> patternFromRegex ( $ line ) ; }
12294	public function delete ( $ id ) { $ resource = $ this -> model -> find ( $ id ) ; if ( ! $ resource ) { return '' ; } return $ resource -> delete ( ) ; }
6083	public function uploadFile ( $ pathname , $ name , $ categoryId , $ progress = null , $ chunkSize = 10485760 ) { $ chunk = 0 ; $ chunksTotal = ceil ( filesize ( $ pathname ) / $ chunkSize ) ; $ fileId = sha1 ( uniqid ( 'upload' , true ) ) ; $ fp = fopen ( $ pathname , 'rb' ) ; if ( false === $ fp ) { throw new UploadException ( 'Could not open file "' . $ pathname . '" for reading.' ) ; } if ( $ chunkSize > 10485760 ) { $ this -> logger -> warning ( 'Using a chunk size larger then 10MB is not recommended. Uploading is not guaranteed to work properly.' ) ; } while ( $ chunkData = fread ( $ fp , $ chunkSize ) ) { $ result = $ this -> uploadFileChunked ( $ chunkData , $ name , $ chunk , $ chunksTotal , $ fileId , $ categoryId ) ; if ( is_callable ( $ progress ) ) { try { call_user_func ( $ progress , $ chunk + 1 , $ chunksTotal ) ; } catch ( \ Exception $ e ) { $ this -> logger -> warning ( 'Could not report progress due to callback error.' , [ 'message' => $ e -> getMessage ( ) ] ) ; } } $ this -> logger -> info ( 'Upload progress!' , [ 'part' => $ chunk + 1 , 'total' => $ chunksTotal ] ) ; if ( isset ( $ result [ 'mediaId' ] ) ) { return new MediaResponse ( $ result ) ; } if ( isset ( $ result [ 'success' ] ) && false == $ result [ 'success' ] ) { throw new UploadException ( $ result [ 'error' ] [ 'message' ] , $ result [ 'error' ] [ 'code' ] ) ; } if ( isset ( $ result [ 'fileId' ] ) ) { $ fileId = $ result [ 'fileId' ] ; } ++ $ chunk ; } if ( $ chunk == $ chunksTotal - 1 ) { throw new UploadException ( 'Uploaded all chunks, but something went wrong.' ) ; } if ( false === $ chunkData ) { throw new UploadException ( 'Could not read chunk ' . $ chunk . ' from file "' . $ pathname . '".' ) ; } throw new UploadException ( 'Unknown upload error!' ) ; }
5762	public function indexView ( Response $ response , ? array $ displayItems = null ) { if ( $ displayItems === null ) { $ displayItems = $ this -> getDisplayItems ( ) ; } $ filterErrorMessage = FormHelper :: getFieldError ( $ this -> sessionFilterFieldKey ) ; FormHelper :: unsetSessionFormErrors ( ) ; return $ this -> view -> render ( $ response , $ this -> template , [ 'title' => $ this -> mapper -> getListViewTitle ( ) , 'insertLinkInfo' => $ this -> insertLinkInfo , 'filterOpsList' => QueryBuilder :: getWhereOperatorsText ( ) , 'filterValue' => $ this -> getFilterFieldValue ( ) , 'filterErrorMessage' => $ filterErrorMessage , 'filterFormActionRoute' => $ this -> indexRoute , 'filterFieldName' => $ this -> sessionFilterFieldKey , 'isFiltered' => $ this -> getFilterFieldValue ( ) != '' , 'resetFilterRoute' => $ this -> filterResetRoute , 'updatesPermitted' => $ this -> updatesPermitted , 'updateColumn' => $ this -> updateColumn , 'updateRoute' => $ this -> updateRoute , 'deletesPermitted' => $ this -> deletesPermitted , 'deleteRoute' => $ this -> deleteRoute , 'displayItems' => $ displayItems , 'columnCount' => $ this -> mapper -> getCountSelectColumns ( ) , 'sortColumn' => $ this -> mapper -> getListViewSortColumn ( ) , 'sortAscending' => $ this -> mapper -> getListViewSortAscending ( ) , 'navigationItems' => $ this -> navigationItems ] ) ; }
4407	public function getCurrentMenuPlugin ( ) { $ currentRequest = $ this -> requestStack -> getCurrentRequest ( ) ; if ( ! $ currentRequest instanceof Request ) { return false ; } foreach ( $ this -> menuPluginRegistry -> getMenuPlugins ( ) as $ identifier => $ menuPlugin ) { if ( $ menuPlugin -> matches ( $ currentRequest ) ) { return $ identifier ; } } return false ; }
8442	public function render ( array $ args , bool $ prettyPrint = null ) { header ( 'Content-type: application/json' ) ; if ( ( constant ( 'STRAY_ENV' ) === 'development' && $ prettyPrint !== false ) || $ prettyPrint === true ) { return ( string ) json_encode ( $ args , JSON_PRETTY_PRINT ) ; } return ( string ) json_encode ( $ args ) ; }
739	protected function saveAssignments ( ) { $ assignmentData = [ ] ; foreach ( $ this -> assignments as $ userId => $ assignments ) { foreach ( $ assignments as $ name => $ assignment ) { $ assignmentData [ $ userId ] [ ] = $ assignment -> roleName ; } } $ this -> saveToFile ( $ assignmentData , $ this -> assignmentFile ) ; }
11441	public function setRegistry ( $ var = null , $ val = null , $ section = false ) { if ( is_null ( $ var ) ) { return ; } if ( $ section ) { if ( ! isset ( $ this -> registry [ $ section ] ) ) { $ this -> registry [ $ section ] = array ( ) ; } $ this -> registry [ $ section ] [ $ var ] = $ val ; } else { $ this -> registry [ $ var ] = $ val ; } return $ this ; }
10314	function getClicksCount ( $ fromDate = null , $ toDate = null , $ mailingIds = null , $ contactIds = null , $ contactEmails = null , $ contactExternalIds = null , $ formatFilter = null , $ linkIdFilter = null , $ linkUrlFilter = null , $ linkTagFilter = null , $ socialNetworkFilter = null , $ deviceTypeFilter = null , $ excludeAnonymousClicks = false ) { $ params = $ this -> createCountQueryParameters ( $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , $ mailingIds , null ) ; if ( isset ( $ excludeAnonymousClicks ) ) $ params [ 'exclude_anonymous_clicks' ] = ( $ excludeAnonymousClicks == true ) ? "true" : "false" ; if ( isset ( $ formatFilter ) ) $ params [ 'format' ] = $ formatFilter ; $ params = $ this -> appendArrayFields ( $ params , "link_id" , $ linkIdFilter ) ; if ( isset ( $ linkUrlFilter ) ) $ params [ 'link_url' ] = $ linkUrlFilter ; $ params = $ this -> appendArrayFields ( $ params , "link_tag" , $ linkTagFilter ) ; $ params = $ this -> appendArrayFields ( $ params , "social_network" , $ socialNetworkFilter ) ; $ params = $ this -> appendArrayFields ( $ params , "device_type" , $ deviceTypeFilter ) ; return $ this -> get ( 'reports/clicks/count' , $ params ) ; }
12886	public function setRawPhoto ( $ photo ) { if ( empty ( $ photo ) ) { return true ; } if ( ! ( $ photo instanceof FileInterface ) ) { $ photo = RawFile :: createRawInstance ( $ photo ) ; } return $ this -> setStorage ( $ photo ) ; }
2996	public function set ( $ key , $ val ) { $ this -> smtp -> set ( $ key , $ this -> encode ( $ val ) ) ; }
2622	public function sendConfigurationRequest ( $ configuredFlag ) { if ( $ configuredFlag ) { $ configuredState = self :: FASTLY_CONFIGURED_FLAG ; } else { $ configuredState = self :: FASTLY_NOT_CONFIGURED_FLAG ; } $ pageViewParams = [ 'dl' => self :: GA_PAGEVIEW_URL . $ configuredState , 'dh' => preg_replace ( '#^https?://#' , '' , rtrim ( self :: GA_PAGEVIEW_URL , '/' ) ) , 'dp' => '/' . $ configuredState , 'dt' => ucfirst ( $ configuredState ) , 't' => self :: GA_HITTYPE_PAGEVIEW , ] ; $ this -> sendReqToGA ( $ pageViewParams ) ; $ eventParams = [ 'ec' => self :: GA_FASTLY_SETUP , 'ea' => 'Fastly ' . $ configuredState , 'el' => $ this -> getWebsiteName ( ) , 'ev' => $ this -> daysFromInstallation ( ) , 't' => self :: GA_HITTYPE_EVENT ] ; $ result = $ this -> sendReqToGA ( array_merge ( $ pageViewParams , $ eventParams ) ) ; return $ result ; }
2609	public function getNextVersion ( array $ versions ) { if ( isset ( end ( $ versions ) -> number ) ) { return ( int ) end ( $ versions ) -> number + 1 ; } throw new LocalizedException ( __ ( 'Error fetching next version.' ) ) ; }
6305	public function getDistance ( Point $ point , DistanceInterface $ calculator = null ) { $ calculator = $ calculator ? : static :: getCalculator ( ) ; return $ calculator -> getDistance ( new Coordinate ( $ this -> latitude , $ this -> longitude ) , new Coordinate ( $ point -> latitude , $ point -> longitude ) ) ; }
12009	public function setTitle ( string $ title ) : void { $ this -> title = $ this -> translator !== null ? $ this -> translator -> translate ( $ title ) : $ title ; }
11080	public static function getDayName ( $ day ) { if ( $ day < self :: DOW_MONDAY || $ day > self :: DOW_SUNDAY ) { return '' ; } $ dayNames = [ self :: DOW_MONDAY => self :: poorManTranslate ( 'fts-shared' , 'Monday' ) , self :: DOW_TUESDAY => self :: poorManTranslate ( 'fts-shared' , 'Tuesday' ) , self :: DOW_WEDNESDAY => self :: poorManTranslate ( 'fts-shared' , 'Wednesday' ) , self :: DOW_THURSDAY => self :: poorManTranslate ( 'fts-shared' , 'Thursday' ) , self :: DOW_FRIDAY => self :: poorManTranslate ( 'fts-shared' , 'Friday' ) , self :: DOW_SATURDAY => self :: poorManTranslate ( 'fts-shared' , 'Saturday' ) , self :: DOW_SUNDAY => self :: poorManTranslate ( 'fts-shared' , 'Sunday' ) , ] ; return $ dayNames [ $ day ] ; }
7225	public function content ( $ decodeJson = false ) { return $ decodeJson && preg_match ( "~^application/json.*~" , $ this -> lastResultType ) && $ this -> lastResult ? from_json ( $ this -> lastResult ) : $ this -> lastResult ; }
2966	public function createRequest ( $ method , $ path , $ options ) { if ( $ this -> isPsr7Version ( ) ) { $ headers = [ 'Content-Type' => 'application/json' , 'Authorization' => 'Bearer ' . $ this -> getAccessToken ( ) , ] ; $ body = ArrayUtils :: get ( $ options , 'body' , null ) ; $ uri = UriResolver :: resolve ( new Uri ( $ this -> getBaseEndpoint ( ) . '/' ) , new Uri ( $ path ) ) ; if ( $ body ) { $ body = json_encode ( $ body ) ; } if ( ArrayUtils :: has ( $ options , 'query' ) ) { $ query = $ options [ 'query' ] ; if ( is_array ( $ query ) ) { $ query = http_build_query ( $ query , null , '&' , PHP_QUERY_RFC3986 ) ; } if ( ! is_string ( $ query ) ) { throw new \ InvalidArgumentException ( 'query must be a string or array' ) ; } $ uri = $ uri -> withQuery ( $ query ) ; } $ request = new Request ( $ method , $ uri , $ headers , $ body ) ; } else { $ options [ 'auth' ] = [ $ this -> accessToken , '' ] ; $ request = $ this -> httpClient -> createRequest ( $ method , $ path , $ options ) ; $ query = ArrayUtils :: get ( $ options , 'query' ) ; if ( $ query ) { $ q = $ request -> getQuery ( ) ; foreach ( $ query as $ key => $ value ) { $ q -> set ( $ key , $ value ) ; } } } return $ request ; }
3668	public function generate ( FilterUrl $ filterUrl ) { $ jumpTo = $ filterUrl -> getPage ( ) ; if ( empty ( $ jumpTo [ 'alias' ] ) ) { $ this -> addFromCurrentRequest ( $ filterUrl = $ filterUrl -> clone ( ) , [ ] ) ; $ jumpTo = $ filterUrl -> getPage ( ) ; } $ alias = $ jumpTo [ 'alias' ] ; $ parameters = $ filterUrl -> getGetParameters ( ) ; $ url = $ alias ; if ( $ filterUrl -> hasSlug ( 'auto_item' ) ) { $ url .= '/' . $ this -> encodeForAllowEncodedSlashes ( $ filterUrl -> getSlug ( 'auto_item' ) ) ; } if ( ! empty ( $ jumpTo [ 'domain' ] ) ) { $ parameters [ '_domain' ] = $ jumpTo [ 'domain' ] ; } if ( ! empty ( $ jumpTo [ 'rootUseSSL' ] ) ) { $ parameters [ '_ssl' ] = ( bool ) $ jumpTo [ 'rootUseSSL' ] ; } if ( $ filterUrl -> hasSlug ( 'language' ) ) { $ parameters [ '_locale' ] = $ filterUrl -> getSlug ( 'language' ) ; } foreach ( $ filterUrl -> getSlugParameters ( ) as $ name => $ value ) { if ( in_array ( $ name , [ 'language' , 'auto_item' ] ) ) { continue ; } $ url .= '/' . $ this -> encodeForAllowEncodedSlashes ( $ name ) . '/' . $ this -> encodeForAllowEncodedSlashes ( $ value ) ; } return $ this -> urlGenerator -> generate ( $ url , $ parameters ) ; }
11864	public function save ( string $ sessionIdentifier , string $ sessionData ) : void { self :: $ files [ $ sessionIdentifier ] = [ 'data' => $ sessionData , 'time' => microtime ( true ) ] ; }
1776	protected function isSelected ( $ arrOption ) { if ( empty ( $ this -> varValue ) && empty ( $ _POST ) && $ arrOption [ 'default' ] ) { return static :: optionSelected ( 1 , 1 ) ; } return static :: optionSelected ( $ arrOption [ 'value' ] , $ this -> varValue ) ; }
8470	public function alert ( $ scope , $ message , $ context = [ ] , $ config = [ ] ) { return $ this -> write ( 'alert' , $ scope , $ message , $ context , $ config ) ; }
9064	public function attachShared ( SharedEventManagerInterface $ events ) { $ events -> attach ( 'Zend\Mvc\Application' , MvcEvent :: EVENT_BOOTSTRAP , array ( $ this , 'onMvcBootstrapLast' ) , - 100000 ) ; $ events -> attach ( 'Zend\Mvc\Application' , MvcEvent :: EVENT_RENDER , array ( $ this , 'onRenderAddPathStacks' ) , - 900 ) ; $ events -> attach ( 'Zend\Mvc\Application' , MvcEvent :: EVENT_RENDER , array ( $ this , 'onRenderSpecLayout' ) , - 1000 ) ; }
8509	public function getPrepInstructionsForSKU ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_GetPrepInstructionsForSKURequest ) ) { $ request = new FBAInboundServiceMWS_Model_GetPrepInstructionsForSKURequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetPrepInstructionsForSKU' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_GetPrepInstructionsForSKUResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
74	public function requestToken ( $ originUrl , $ consumerKey , $ consumerSecret ) { if ( ! empty ( $ this -> token ) || $ this -> getTokenFromConfig ( $ originUrl ) ) { return $ this -> token [ 'access_token' ] ; } $ this -> io -> setAuthentication ( $ originUrl , $ consumerKey , $ consumerSecret ) ; if ( ! $ this -> requestAccessToken ( $ originUrl ) ) { return '' ; } $ this -> storeInAuthConfig ( $ originUrl , $ consumerKey , $ consumerSecret ) ; return $ this -> token [ 'access_token' ] ; }
5076	public function getIndex ( $ aData = [ ] , $ iPage = null , $ iPerPage = null ) { $ oInput = Factory :: service ( 'Input' ) ; $ oItemModel = Factory :: model ( static :: CONFIG_MODEL_NAME , static :: CONFIG_MODEL_PROVIDER ) ; if ( is_null ( $ iPage ) ) { $ iPage = ( int ) $ oInput -> get ( 'page' ) ? : 1 ; } if ( is_null ( $ iPerPage ) ) { $ iPerPage = static :: CONFIG_MAX_ITEMS_PER_PAGE ; } $ aResults = $ oItemModel -> getAll ( $ iPage , $ iPerPage , $ aData ) ; $ oResponse = Factory :: factory ( 'ApiResponse' , 'nails/module-api' ) ; $ oResponse -> setData ( array_map ( [ $ this , 'formatObject' ] , $ aResults ) ) ; return $ oResponse ; }
7138	protected function getConstraintsForStep ( $ step ) { $ constraints = [ new Valid ( ) ] ; if ( $ step === static :: SHIPMENT_STEP ) { $ constraints [ ] = new Constraints \ SaleShipmentStep ( ) ; } if ( $ step === static :: PAYMENT_STEP ) { $ constraints [ ] = new Constraints \ SaleShipmentStep ( ) ; $ constraints [ ] = new Constraints \ RelayPoint ( ) ; $ constraints [ ] = new Constraints \ SalePaymentStep ( ) ; } return $ constraints ; }
2303	public function addCustomLayoutSectionReferences ( ) { $ objLayout = $ this -> Database -> getInstance ( ) -> query ( "SELECT sections FROM tl_layout WHERE sections!=''" ) ; while ( $ objLayout -> next ( ) ) { $ arrCustom = StringUtil :: deserialize ( $ objLayout -> sections ) ; if ( ! empty ( $ arrCustom ) && \ is_array ( $ arrCustom ) ) { foreach ( $ arrCustom as $ v ) { if ( ! empty ( $ v [ 'id' ] ) ) { $ GLOBALS [ 'TL_LANG' ] [ 'COLS' ] [ $ v [ 'id' ] ] = $ v [ 'title' ] ; } } } } }
1420	protected function pointer ( string $ path , ? string $ member = null ) : array { $ withoutMember = is_null ( $ member ) || '' === $ member ; $ pointer = ! $ withoutMember ? sprintf ( '%s/%s' , rtrim ( $ path , '/' ) , $ member ) : $ path ; return [ Error :: SOURCE_POINTER => $ pointer ] ; }
917	public static function stableSort ( array $ elements , callable $ getComparedValue , callable $ compareValues ) { array_walk ( $ elements , static function ( & $ element , $ index ) use ( $ getComparedValue ) { $ element = [ $ element , $ index , $ getComparedValue ( $ element ) ] ; } ) ; usort ( $ elements , static function ( $ a , $ b ) use ( $ compareValues ) { $ comparison = $ compareValues ( $ a [ 2 ] , $ b [ 2 ] ) ; if ( 0 !== $ comparison ) { return $ comparison ; } return self :: cmpInt ( $ a [ 1 ] , $ b [ 1 ] ) ; } ) ; return array_map ( static function ( array $ item ) { return $ item [ 0 ] ; } , $ elements ) ; }
2698	public function upgrade ( ModuleDataSetupInterface $ setup , ModuleContextInterface $ context ) { $ version = $ context -> getVersion ( ) ; if ( ! $ version ) { return ; } $ oldConfigPaths = [ 'stale_ttl' => 'system/full_page_cache/fastly/stale_ttl' , 'stale_error_ttl' => 'system/full_page_cache/fastly/stale_error_ttl' , 'purge_catalog_category' => 'system/full_page_cache/fastly/purge_catalog_category' , 'purge_catalog_product' => 'system/full_page_cache/fastly/purge_catalog_product' , 'purge_cms_page' => 'system/full_page_cache/fastly/purge_cms_page' , 'soft_purge' => 'system/full_page_cache/fastly/soft_purge' , 'enable_geoip' => 'system/full_page_cache/fastly/enable_geoip' , 'geoip_action' => 'system/full_page_cache/fastly/geoip_action' , 'geoip_country_mapping' => 'system/full_page_cache/fastly/geoip_country_mapping' , ] ; $ newConfigPaths = [ 'stale_ttl' => 'system/full_page_cache/fastly/fastly_advanced_configuration/stale_ttl' , 'stale_error_ttl' => 'system/full_page_cache/fastly/fastly_advanced_configuration/stale_error_ttl' , 'purge_catalog_category' => 'system/full_page_cache/fastly/fastly_advanced_configuration/purge_catalog_category' , 'purge_catalog_product' => 'system/full_page_cache/fastly/fastly_advanced_configuration/purge_catalog_product' , 'purge_cms_page' => 'system/full_page_cache/fastly/fastly_advanced_configuration/purge_cms_page' , 'soft_purge' => 'system/full_page_cache/fastly/fastly_advanced_configuration/soft_purge' , 'enable_geoip' => 'system/full_page_cache/fastly/fastly_advanced_configuration/enable_geoip' , 'geoip_action' => 'system/full_page_cache/fastly/fastly_advanced_configuration/geoip_action' , 'geoip_country_mapping' => 'system/full_page_cache/fastly/fastly_advanced_configuration/geoip_country_mapping' ] ; $ setup -> startSetup ( ) ; if ( version_compare ( $ version , '1.0.8' , '<=' ) ) { $ this -> upgrade108 ( $ oldConfigPaths , $ newConfigPaths ) ; } if ( version_compare ( $ version , '1.0.9' , '<=' ) ) { $ this -> upgrade109 ( $ setup ) ; } $ magVer = $ this -> productMetadata -> getVersion ( ) ; if ( version_compare ( $ version , '1.0.10' , '<=' ) && version_compare ( $ magVer , '2.2' , '>=' ) ) { $ this -> upgrade1010 ( $ newConfigPaths ) ; $ setup -> endSetup ( ) ; } elseif ( version_compare ( $ magVer , '2.2' , '<' ) ) { $ setup -> endSetup ( ) ; } }
10125	private function writeAutoFilterInfo ( ) { $ record = 0x009D ; $ length = 0x0002 ; $ rangeBounds = Coordinate :: rangeBoundaries ( $ this -> phpSheet -> getAutoFilter ( ) -> getRange ( ) ) ; $ iNumFilters = 1 + $ rangeBounds [ 1 ] [ 0 ] - $ rangeBounds [ 0 ] [ 0 ] ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ iNumFilters ) ; $ this -> append ( $ header . $ data ) ; }
10914	public function execute ( ) { try { $ this -> output_buffer_level = ob_get_level ( ) ; ob_start ( ) ; $ response = $ this -> doExecute ( ) ; if ( ( is_object ( $ response ) && ! ( $ response instanceof Response ) ) || ( is_string ( $ response ) && class_exists ( $ response ) ) ) { $ response = $ this -> reflect ( $ response ) ; } if ( $ response instanceof Response ) throw $ response ; throw new HTTPError ( 500 , "App did not produce any response" ) ; } catch ( Response $ response ) { self :: $ logger -> debug ( "Response type {0} returned from controller: {1}" , [ get_class ( $ response ) , $ this -> app ] ) ; throw $ response ; } catch ( Throwable $ e ) { self :: $ logger -> debug ( "While executing controller: {0}" , [ $ this -> app ] ) ; self :: $ logger -> notice ( "Unexpected exception of type {0} thrown while processing request: {1}" , [ get_class ( $ e ) , $ e ] ) ; throw $ e ; } finally { $ this -> logScriptOutput ( ) ; } }
2116	public function addTemplateWarning ( ) { if ( Contao \ Input :: get ( 'act' ) && Contao \ Input :: get ( 'act' ) != 'select' ) { return ; } $ objResult = $ this -> Database -> query ( "SELECT COUNT(*) AS cnt FROM tl_user_group WHERE modules LIKE '%\"tpl_editor\"%'" ) ; if ( $ objResult -> cnt > 0 ) { Contao \ Message :: addInfo ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'groupTemplateEditor' ] ) ; } }
8369	public function archiveAction ( string $ production_slug , AuthorizationCheckerInterface $ auth , PaginatorInterface $ paginator , Request $ request ) : Response { $ production_repo = $ this -> em -> getRepository ( Production :: class ) ; if ( null === $ production = $ production_repo -> findOneBy ( [ 'slug' => $ production_slug ] ) ) { throw new NotFoundHttpException ( ) ; } if ( ! $ auth -> isGranted ( 'GROUP_ROLE_EDITOR' , $ production ) ) { throw new AccessDeniedException ( ) ; } $ query = $ this -> em -> getRepository ( Post :: class ) -> getAllInactiveQuery ( $ production ) ; $ posts = $ paginator -> paginate ( $ query , $ request -> query -> getInt ( 'page' , 1 ) ) ; return new Response ( $ this -> templating -> render ( '@BkstgNoticeBoard/Board/archive.html.twig' , [ 'production' => $ production , 'posts' => $ posts , ] ) ) ; }
10674	private function _cmpFrm ( $ txt ) { $ CmpFrmRV = '' ; $ length = mb_strlen ( $ txt , 'UTF-8' ) ; for ( $ CmpFrmI = 0 ; $ CmpFrmI < $ length ; $ CmpFrmI ++ ) { if ( mb_substr ( $ txt , $ CmpFrmI , 1 , 'UTF-8' ) === '0' ) { $ CmpFrmRV .= $ this -> aCmpReg [ 0 ] ; } elseif ( mb_substr ( $ txt , $ CmpFrmI , 1 , 'UTF-8' ) === '1' ) { $ CmpFrmRV .= $ this -> aCmpReg [ 1 ] ; } elseif ( mb_substr ( $ txt , $ CmpFrmI , 1 , 'UTF-8' ) === '2' ) { $ CmpFrmRV .= $ this -> aCmpReg [ 2 ] ; } else { $ CmpFrmRV .= mb_substr ( $ txt , $ CmpFrmI , 1 , 'UTF-8' ) ; } } return $ CmpFrmRV ; }
5050	public function trigger ( $ eventName , $ target = null , $ argv = [ ] ) { $ event = $ eventName instanceof EventInterface ? $ eventName : $ this -> getEvent ( $ eventName , $ target , $ argv ) ; return $ this -> triggerListeners ( $ event ) ; }
12589	protected function sendEmails ( ContactInquiry $ inquiry ) { $ recipients = $ this -> container -> getParameter ( 'c33s_contact_form.email.recipients' ) ; if ( $ this -> container -> getParameter ( 'c33s_contact_form.email.send_copy_to_user' ) && $ inquiry -> hasSenderEmail ( ) ) { $ recipients [ ] = $ inquiry -> getSenderEmail ( ) ; } if ( empty ( $ recipients ) ) { return ; } $ translator = $ this -> get ( 'translator' ) ; $ subject = $ this -> container -> getParameter ( 'c33s_contact_form.email.subject' ) ; $ message = \ Swift_Message :: newInstance ( ) -> setSubject ( $ translator -> trans ( $ subject , array ( ) , 'C33sContactForm' ) ) -> setFrom ( $ this -> container -> getParameter ( 'c33s_contact_form.email.sender_email' ) ) -> setTo ( $ recipients ) -> setBody ( $ this -> renderView ( 'C33sContactFormBundle:ContactForm:email.txt.twig' , array ( 'inquiry' => $ inquiry ) ) ) ; $ this -> get ( 'mailer' ) -> send ( $ message ) ; }
9907	public function setBlocSize ( $ size ) { if ( null !== $ this -> memory ) { throw new Exception \ RuntimeException ( 'You can not change the segment size because memory is already allocated.' . ' Use realloc() function to create new memory segment.' ) ; } $ this -> blocSize = ( integer ) $ size ; return $ this ; }
9936	public function setGrouping ( $ pGrouping ) { if ( ( $ pGrouping !== null ) && ( ! in_array ( $ pGrouping , self :: $ dateTimeGroups ) ) && ( ! in_array ( $ pGrouping , self :: $ dynamicTypes ) ) && ( ! in_array ( $ pGrouping , self :: $ topTenType ) ) ) { throw new PhpSpreadsheetException ( 'Invalid rule type for column AutoFilter Rule.' ) ; } $ this -> grouping = $ pGrouping ; return $ this ; }
1365	protected function bootMiddleware ( Router $ router ) { $ router -> aliasMiddleware ( 'json-api' , BootJsonApi :: class ) ; $ router -> aliasMiddleware ( 'json-api.content' , NegotiateContent :: class ) ; $ router -> aliasMiddleware ( 'json-api.auth' , Authorize :: class ) ; }
12287	public function insetIf ( bool $ condition , string $ block , array $ vars = null ) : string { return $ condition ? trim ( $ this -> make ( $ block , $ vars ) ) . PHP_EOL : PHP_EOL ; }
5569	public function delete ( $ url , $ parameters = false ) { if ( ! is_object ( $ url ) ) { $ url = new SimpleUrl ( $ url ) ; } return $ this -> load ( $ url , new SimpleDeleteEncoding ( $ parameters ) ) ; }
2380	public static function trimsplit ( $ strPattern , $ strString ) { if ( \ strlen ( $ strPattern ) == 1 ) { $ arrFragments = array_map ( 'trim' , explode ( $ strPattern , $ strString ) ) ; } else { $ arrFragments = array_map ( 'trim' , preg_split ( '/' . $ strPattern . '/ui' , $ strString ) ) ; } if ( \ count ( $ arrFragments ) < 2 && ! \ strlen ( $ arrFragments [ 0 ] ) ) { $ arrFragments = array ( ) ; } return $ arrFragments ; }
10458	public function validate ( string $ answer ) : string { if ( trim ( ( string ) $ answer ) === '' ) { throw new \ RuntimeException ( sprintf ( '%s Given value: "%s"' , $ this -> getErrorMessage ( ) , $ answer ) ) ; } return $ answer ; }
710	public function tinyInteger ( $ length = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_TINYINT , $ length ) ; }
9590	public function radioWithGap ( $ options = [ ] , $ enclosedByLabel = true ) { Html :: addCssClass ( $ options , $ this -> radioGapCssClass ) ; return self :: radio ( $ options , $ enclosedByLabel ) ; }
6852	static public function isValidTrigger ( $ trigger , $ throwException = true ) { if ( in_array ( $ trigger , static :: getTriggers ( ) , true ) ) { return true ; } if ( $ throwException ) { throw new InvalidArgumentException ( "Invalid payment term trigger '$trigger'." ) ; } return false ; }
4911	protected function injectComponents ( array $ pages , $ routeMatch = null , $ router = null , $ request = null ) { if ( $ routeMatch ) { $ routeName = $ routeMatch -> getMatchedRouteName ( ) ; foreach ( $ pages as & $ page ) { if ( isset ( $ page [ 'active_on' ] ) && in_array ( $ routeName , ( array ) $ page [ 'active_on' ] ) ) { $ page [ 'active' ] = true ; } } } return parent :: injectComponents ( $ pages , $ routeMatch , $ router , $ request ) ; }
7936	public function getSeeOffers ( $ countryDestination , $ countryCurrencyPrice , $ quantity ) { return json_decode ( self :: getClient ( ) -> getSeeOffers ( $ this -> domain , $ countryDestination , $ countryCurrencyPrice , $ quantity ) ) ; }
10752	protected function getStateFormatted ( UserEntity $ user ) { switch ( $ user -> getState ( ) ) { case UserEntity :: USER_STATE_ACTIVE : $ this -> stateClass = 'success' ; return 'Attivo' ; break ; case UserEntity :: USER_STATE_BANNED : $ this -> stateClass = 'danger' ; return 'Bannato' ; break ; case UserEntity :: USER_STATE_DEACTIVE : $ this -> stateClass = 'warning' ; return 'Disattivo' ; break ; case UserEntity :: USER_STATE_DELETED : $ this -> stateClass = 'danger' ; return 'Eliminato' ; break ; } $ this -> stateClass = 'danger' ; return 'Error with user state' ; }
5275	public function having ( $ column , $ param1 = null , $ param2 = null ) { $ this -> statements [ 'having' ] = $ this -> generateWhere ( $ column , $ param1 , $ param2 , 'having' ) ; return $ this ; }
3370	private function getClassByName ( $ className ) { if ( ! isset ( $ this -> classByNames [ $ className ] ) ) { foreach ( $ this -> metadata as $ class ) { if ( $ class -> getName ( ) === $ className ) { $ this -> classByNames [ $ className ] = $ class ; break ; } } } return $ this -> classByNames [ $ className ] ?? null ; }
8493	public function setFeeList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'FeeList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
10753	protected function getMobile ( UserEntity $ user ) { $ metadata = $ user -> getMetadata ( ) ; foreach ( $ metadata as $ meta ) { if ( 'cellulare' == $ meta -> getKey ( ) ) { return $ meta -> getValue ( ) ; } } return null ; }
9392	protected function skipRowsClause ( ) { $ skipClause = [ ] ; foreach ( $ this -> skipRows as $ cl => $ val ) { $ skipClause [ ] = [ '<>' , $ cl , $ val ] ; } if ( count ( $ skipClause ) > 1 ) array_unshift ( $ skipClause , 'and' ) ; return $ skipClause ; }
11356	public function getInputFilter ( ) { if ( $ this -> filter ) { return $ this -> filter ; } $ specifications = [ ] ; if ( $ this -> object && $ this -> object instanceof InputFilterProviderInterface ) { $ specifications = $ this -> object -> getInputFilterSpecification ( ) ; } if ( $ this instanceof InputFilterProviderInterface ) { $ specifications = ArrayUtils :: merge ( $ specifications , $ this -> getInputFilterSpecification ( ) ) ; } $ this -> addRequiredAttributeToFields ( $ specifications ) ; if ( ! empty ( $ specifications ) && null === $ this -> baseFieldset ) { $ formFactory = $ this -> getFormFactory ( ) ; $ inputFactory = $ formFactory -> getInputFilterFactory ( ) ; if ( ! ( $ this -> filter instanceof InputFilterInterface ) ) { $ this -> filter = new InputFilter ( ) ; $ this -> filter -> setFactory ( $ inputFactory ) ; } foreach ( $ specifications as $ name => $ specification ) { $ input = $ inputFactory -> createInput ( $ specification ) ; $ this -> filter -> add ( $ input , $ name ) ; } } return parent :: getInputFilter ( ) ; }
4878	public function setUser ( UserInterface $ user ) { if ( $ this -> user ) { $ this -> getPermissions ( ) -> revoke ( $ this -> user , Permissions :: PERMISSION_ALL , false ) ; } $ this -> user = $ user ; $ this -> getPermissions ( ) -> grant ( $ user , Permissions :: PERMISSION_ALL ) ; return $ this ; }
7020	private function format_i ( & $ str ) { if ( strstr ( $ str , '%i' ) ) $ str = str_replace ( '%i' , sprintf ( '%02d' , $ this -> min ) , $ str ) ; }
3050	protected function initStorage ( ) { $ deliveryServerService = $ this -> getServiceManager ( ) -> get ( DeliveryServerService :: SERVICE_ID ) ; $ resultStore = $ deliveryServerService -> getResultStoreWrapper ( $ this -> getTestExecutionUri ( ) ) ; $ testResource = new \ core_kernel_classes_Resource ( $ this -> getTestDefinitionUri ( ) ) ; $ sessionManager = new \ taoQtiTest_helpers_SessionManager ( $ resultStore , $ testResource ) ; $ seeker = new BinaryAssessmentTestSeeker ( $ this -> getTestDefinition ( ) ) ; $ userUri = $ this -> getUserUri ( ) ; $ config = \ common_ext_ExtensionsManager :: singleton ( ) -> getExtensionById ( 'taoQtiTest' ) -> getConfig ( 'testRunner' ) ; $ storageClassName = $ config [ 'test-session-storage' ] ; $ this -> storage = new $ storageClassName ( $ sessionManager , $ seeker , $ userUri ) ; $ this -> sessionManager = $ sessionManager ; }
11249	public function log ( string $ file , int $ batch ) : void { $ stmt = $ this -> pdo -> prepare ( "insert into {$this->table} (migration, batch) values (?, ?)" ) ; $ stmt -> bindParam ( 1 , $ file ) ; $ stmt -> bindParam ( 2 , $ batch , PDO :: PARAM_INT ) ; $ stmt -> execute ( ) ; }
3997	protected function getItem ( $ metaModelIdOrName , $ mixDataId , $ intIdRenderSetting , $ strOutput = null ) { $ objMetaModel = $ this -> loadMetaModel ( $ metaModelIdOrName ) ; if ( $ objMetaModel == null ) { return false ; } if ( empty ( $ strOutput ) ) { $ strOutput = 'html5' ; } $ objMetaModelList = new ItemList ( ) ; $ objMetaModelList -> setServiceContainer ( $ this -> getServiceContainer ( ) ) -> setMetaModel ( $ objMetaModel -> get ( 'id' ) , $ intIdRenderSetting ) -> overrideOutputFormat ( $ strOutput ) ; $ arrIds = StringUtil :: trimsplit ( ',' , $ mixDataId ) ; foreach ( $ arrIds as $ intKey => $ intId ) { if ( ! $ this -> isPublishedItem ( $ objMetaModel , $ intId ) ) { unset ( $ arrIds [ $ intKey ] ) ; } } if ( count ( $ arrIds ) < 1 ) { return '' ; } $ objMetaModelList -> addFilterRule ( new StaticIdList ( $ arrIds ) ) ; return $ objMetaModelList -> render ( false , $ this ) ; }
1163	public function validate ( $ field , $ parameters = [ ] ) { $ attribute = $ this -> parseAttributeName ( $ field ) ; $ validationParams = $ this -> parseParameters ( $ parameters ) ; $ validationResult = $ this -> validateJsRemoteRequest ( $ attribute , $ validationParams ) ; $ this -> throwValidationException ( $ validationResult , $ this -> validator ) ; }
12066	public function invokeRpcCall ( $ method , $ arguments = [ ] ) { if ( ! is_null ( $ this -> namespace ) ) { $ method = $ this -> namespace . '.' . $ method ; } $ body = XmlRpcBuilder :: createRequest ( $ method , $ arguments ) ; $ guzzle = new \ GuzzleHttp \ Client ( ) ; $ this -> getLogger ( ) -> info ( "sending request for $method to {$this->url}" ) ; $ this -> getLogger ( ) -> debug ( "sending request for $method to {$this->url}, with parameters: " . print_r ( $ arguments , true ) ) ; $ response = $ guzzle -> post ( $ this -> url , [ 'body' => $ body , 'headers' => [ 'User-Agent' => 'Devedge\XmlRpc\Client/' . self :: $ version , 'Content-Type' => 'text/xml' ] ] ) ; if ( $ response -> xml ( ) -> fault -> count ( ) > 0 ) { $ this -> logger -> warning ( "serverside error occured, details: " . $ response -> getBody ( ) ) ; throw XmlRpcParser :: parseFault ( $ response -> xml ( ) -> fault ) ; } return array_shift ( XmlRpcParser :: parseParams ( $ response -> xml ( ) -> params ) ) ; }
2374	public static function srcToInsertTag ( $ data ) { $ return = '' ; $ paths = preg_split ( '/((src|href)="([^"]+)")/i' , $ data , - 1 , PREG_SPLIT_DELIM_CAPTURE ) ; for ( $ i = 0 , $ c = \ count ( $ paths ) ; $ i < $ c ; $ i += 4 ) { $ return .= $ paths [ $ i ] ; if ( ! isset ( $ paths [ $ i + 1 ] ) ) { continue ; } $ file = FilesModel :: findByPath ( $ paths [ $ i + 3 ] ) ; if ( $ file !== null ) { $ return .= $ paths [ $ i + 2 ] . '="{{file::' . static :: binToUuid ( $ file -> uuid ) . '}}"' ; } else { $ return .= $ paths [ $ i + 2 ] . '="' . $ paths [ $ i + 3 ] . '"' ; } } return $ return ; }
6273	public static function haveExtension ( ) { if ( ! function_exists ( 'dba_handlers' ) ) { return false ; } $ handlers = dba_handlers ( ) ; if ( ! in_array ( 'cdb' , $ handlers ) || ! in_array ( 'cdb_make' , $ handlers ) ) { return false ; } return true ; }
2490	protected function processConnectionConfiguration ( ContainerBuilder $ container , array $ config ) { $ alias = $ this -> getAlias ( ) ; if ( isset ( $ config [ 'default_connection' ] ) ) { $ container -> setParameter ( "{$alias}.default_connection" , $ config [ 'default_connection' ] ) ; } elseif ( ! empty ( $ config [ 'connections' ] ) ) { reset ( $ config [ 'connections' ] ) ; $ container -> setParameter ( "{$alias}.default_connection" , key ( $ config [ 'connections' ] ) ) ; } foreach ( $ config [ 'connections' ] as $ name => $ params ) { $ this -> configureSearchServices ( $ container , $ name , $ params ) ; $ this -> configureBoostMap ( $ container , $ name , $ params ) ; $ this -> configureIndexingDepth ( $ container , $ name , $ params ) ; $ container -> setParameter ( "$alias.connection.$name" , $ params ) ; } foreach ( $ config [ 'endpoints' ] as $ name => $ params ) { $ this -> defineEndpoint ( $ container , $ name , $ params ) ; } $ searchEngineDef = $ container -> findDefinition ( self :: ENGINE_ID ) ; $ searchEngineDef -> setFactory ( [ new Reference ( 'ezpublish.solr.engine_factory' ) , 'buildEngine' ] ) ; $ boostFactorProviderDef = $ container -> findDefinition ( self :: BOOST_FACTOR_PROVIDER_ID ) ; $ boostFactorProviderDef -> setFactory ( [ new Reference ( 'ezpublish.solr.boost_factor_provider_factory' ) , 'buildService' ] ) ; }
1741	public function checkFilename ( $ varValue , Contao \ DataContainer $ dc ) { $ varValue = str_replace ( '"' , '' , $ varValue ) ; if ( strpos ( $ varValue , '/' ) !== false || preg_match ( '/\.$/' , $ varValue ) ) { throw new Exception ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'invalidName' ] ) ; } if ( $ dc -> activeRecord && $ varValue != '' ) { $ intMaxlength = $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'fields' ] [ $ dc -> field ] [ 'eval' ] [ 'maxlength' ] ; if ( $ dc -> activeRecord -> type == 'file' ) { $ intMaxlength -= ( \ strlen ( $ dc -> activeRecord -> extension ) + 1 ) ; } if ( $ intMaxlength && Patchwork \ Utf8 :: strlen ( $ varValue ) > $ intMaxlength ) { throw new Exception ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'maxlength' ] , $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'fields' ] [ $ dc -> field ] [ 'label' ] [ 0 ] , $ intMaxlength ) ) ; } } return $ varValue ; }
7554	protected function match_filters ( $ conditions , $ custom_filters = array ( ) ) { foreach ( $ conditions as $ c ) { $ c [ 'filter' ] = strtolower ( $ c [ 'filter' ] ) ; if ( isset ( $ this -> filter_map [ $ c [ 'filter' ] ] ) ) { if ( ! $ this -> { $ this -> filter_map [ $ c [ 'filter' ] ] } ( $ c [ 'params' ] ) ) { return false ; } } elseif ( isset ( $ custom_filters [ $ c [ 'filter' ] ] ) ) { if ( ! call_user_func ( $ custom_filters [ $ c [ 'filter' ] ] , $ this , $ c [ 'params' ] ) ) { return false ; } } else { trigger_error ( 'Unknown filter "' . $ c [ 'filter' ] . '"!' ) ; return false ; } } return true ; }
1306	public function destroy ( $ id , Request $ request ) { $ post = Models :: post ( ) -> with ( 'discussion' ) -> findOrFail ( $ id ) ; if ( $ request -> user ( ) -> id !== ( int ) $ post -> user_id ) { return redirect ( '/' . config ( 'chatter.routes.home' ) ) -> with ( [ 'chatter_alert_type' => 'danger' , 'chatter_alert' => trans ( 'chatter::alert.danger.reason.destroy_post' ) , ] ) ; } if ( $ post -> discussion -> posts ( ) -> oldest ( ) -> first ( ) -> id === $ post -> id ) { if ( config ( 'chatter.soft_deletes' ) ) { $ post -> discussion -> posts ( ) -> delete ( ) ; $ post -> discussion ( ) -> delete ( ) ; } else { $ post -> discussion -> posts ( ) -> forceDelete ( ) ; $ post -> discussion ( ) -> forceDelete ( ) ; } return redirect ( '/' . config ( 'chatter.routes.home' ) ) -> with ( [ 'chatter_alert_type' => 'success' , 'chatter_alert' => trans ( 'chatter::alert.success.reason.destroy_post' ) , ] ) ; } $ post -> delete ( ) ; $ url = '/' . config ( 'chatter.routes.home' ) . '/' . config ( 'chatter.routes.discussion' ) . '/' . $ post -> discussion -> category -> slug . '/' . $ post -> discussion -> slug ; return redirect ( $ url ) -> with ( [ 'chatter_alert_type' => 'success' , 'chatter_alert' => trans ( 'chatter::alert.success.reason.destroy_from_discussion' ) , ] ) ; }
4372	public function onOutput ( Event $ event ) { $ this -> data = $ this -> debug -> getData ( ) ; $ this -> channels = array ( ) ; $ str = '<div' . $ this -> debug -> utilities -> buildAttribString ( array ( 'class' => 'debug' , 'data-channels' => '{{channels}}' , 'data-channel-root' => $ this -> channelNameRoot , ) ) . ">\n" ; if ( $ this -> debug -> getCfg ( 'output.outputCss' ) ) { $ str .= '<style type="text/css">' . "\n" . $ this -> debug -> output -> getCss ( ) . "\n" . '</style>' . "\n" ; } if ( $ this -> debug -> getCfg ( 'output.outputScript' ) ) { $ str .= '<script type="text/javascript">' . \ file_get_contents ( $ this -> debug -> getCfg ( 'filepathScript' ) ) . '</script>' . "\n" ; } $ str .= '<div class="debug-bar"><h3>Debug Log</h3></div>' . "\n" ; $ str .= $ this -> processAlerts ( ) ; if ( $ this -> debug -> getCfg ( 'output.outputScript' ) ) { $ str .= '<div class="loading">Loading <i class="fa fa-spinner fa-pulse fa-2x fa-fw" aria-hidden="true"></i></div>' . "\n" ; } $ str .= '<div class="debug-header m_group"' . ( $ this -> debug -> getCfg ( 'outputScript' ) ? ' style="display:none;"' : '' ) . '>' . "\n" ; $ str .= $ this -> processSummary ( ) ; $ str .= '</div>' . "\n" ; $ str .= '<div class="debug-content m_group"' . ( $ this -> debug -> getCfg ( 'outputScript' ) ? ' style="display:none;"' : '' ) . '>' . "\n" ; $ str .= $ this -> processLog ( ) ; $ str .= '</div>' . "\n" ; $ str .= '</div>' . "\n" ; $ str = \ strtr ( $ str , array ( '{{channels}}' => \ htmlspecialchars ( \ json_encode ( $ this -> buildChannelTree ( ) , JSON_FORCE_OBJECT ) ) , ) ) ; $ this -> data = array ( ) ; $ event [ 'return' ] .= $ str ; }
2300	public static function getSystemMessages ( ) { $ strMessages = '' ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getSystemMessages' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getSystemMessages' ] ) ) { $ arrMessages = array ( ) ; foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getSystemMessages' ] as $ callback ) { $ strBuffer = System :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( ) ; if ( $ strBuffer != '' ) { $ arrMessages [ ] = $ strBuffer ; } } if ( ! empty ( $ arrMessages ) ) { $ strMessages .= implode ( "\n" , $ arrMessages ) ; } } return $ strMessages ; }
3540	public static function getSyncOptions ( $ optionName , $ individualSyncOptions = null ) { if ( $ individualSyncOptions != null && is_array ( $ individualSyncOptions ) && array_key_exists ( $ optionName , $ individualSyncOptions ) ) { return $ individualSyncOptions [ $ optionName ] ; } else if ( isset ( Yii :: $ app -> params [ 'LDAP-User-Sync-Options' ] ) && is_array ( Yii :: $ app -> params [ 'LDAP-User-Sync-Options' ] ) && array_key_exists ( $ optionName , Yii :: $ app -> params [ 'LDAP-User-Sync-Options' ] ) ) { return Yii :: $ app -> params [ 'LDAP-User-Sync-Options' ] [ $ optionName ] ; } else if ( array_key_exists ( $ optionName , static :: SYNC_OPTIONS_TEMPLATE_WITHOUT_BACKEND_TASK ) ) { return static :: SYNC_OPTIONS_TEMPLATE_WITHOUT_BACKEND_TASK [ $ optionName ] ; } else { throw new \ yii \ base \ Exception ( 'Sync-option ' . $ optionName . ' not found. Please define settings in the config/params.php of the yii2 framework as described on top of the UserDbLdap.php' ) ; } }
9097	public function onLoadModulesPostAddServices ( ModuleEvent $ e ) { $ moduleManager = $ e -> getTarget ( ) ; $ sm = $ moduleManager -> getEvent ( ) -> getParam ( 'ServiceManager' ) ; $ sm -> setInvokableClass ( 'yimaTheme.ThemeObject' , 'yimaTheme\Theme\Theme' , false ) ; }
12784	protected function isNoResultMask ( $ mask ) { foreach ( $ this -> noResultMasks as $ noresultMask ) { if ( $ mask === $ noresultMask ) { return TRUE ; } if ( ( $ mask & $ noresultMask ) === $ noresultMask ) { $ this -> noResultMasks [ ] = $ mask ; return TRUE ; } } return FALSE ; }
9150	public function fetchAll ( $ columns = null , \ Closure $ Closure = null ) { $ select = $ this -> getSelect ( ) ; if ( $ columns ) { $ select -> columns ( $ columns ) ; } if ( $ Closure ) { $ Closure ( $ select ) ; } return $ this -> select ( $ select ) ; }
9452	public function query ( $ index , array $ filters = null , array $ queries = null , array $ fieldWeights = null , $ limit = 20 , $ offset = 0 ) { $ sphinxClient = $ this -> getSphinxClient ( ) ; $ sphinxClient -> SetLimits ( $ offset , $ limit ) ; if ( null !== $ filters ) { foreach ( $ filters as $ filter ) { if ( ! isset ( $ filter [ 'key' ] ) ) { } if ( array_key_exists ( 'min' , $ filter ) && array_key_exists ( 'max' , $ filter ) ) { $ sphinxClient -> SetFilterRange ( $ filter [ 'key' ] , ( integer ) $ filter [ 'min' ] , ( integer ) $ filter [ 'max' ] ) ; } else { if ( ! isset ( $ filter [ 'values' ] ) || ! is_array ( $ filter [ 'values' ] ) ) { } $ sphinxClient -> SetFilter ( $ filter [ 'key' ] , $ filter [ 'values' ] ) ; } } } if ( null !== $ queries ) { foreach ( $ queries as $ key => $ queryInfo ) { $ query = $ this -> implodeQueryValues ( $ queryInfo ) ; if ( array_key_exists ( 'countableAttributes' , $ queryInfo ) ) { $ array = $ queryInfo [ 'countableAttributes' ] ; if ( ! is_array ( $ array ) ) { $ array = [ $ array ] ; } $ sphinxClient -> addFacetedQuery ( $ query , $ index , $ array ) ; } else { $ sphinxClient -> AddQuery ( $ query , $ index ) ; } } } if ( null !== $ fieldWeights ) { $ sphinxClient -> SetFieldWeights ( $ fieldWeights ) ; } $ result = $ this -> getResult ( $ sphinxClient ) ; return $ result ; }
8934	public function fetch ( $ name ) { $ template = false ; if ( array_key_exists ( $ name , $ this -> templates ) ) { $ template = $ this -> templates [ $ name ] ; } return $ template ; }
10129	private function writeProtect ( ) { if ( ! $ this -> phpSheet -> getProtection ( ) -> getSheet ( ) ) { return ; } $ record = 0x0012 ; $ length = 0x0002 ; $ fLock = 1 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ fLock ) ; $ this -> append ( $ header . $ data ) ; }
2699	private function upgrade108 ( $ oldConfigPaths , $ newConfigPaths ) { foreach ( $ oldConfigPaths as $ key => $ value ) { $ oldValue = $ this -> scopeConfig -> getValue ( $ value ) ; if ( $ oldValue != null ) { $ this -> configWriter -> save ( $ newConfigPaths [ $ key ] , $ oldValue ) ; } } }
4842	public static function generate_query_string ( $ params , & $ pairs = array ( ) , $ namespace = null ) { if ( is_array ( $ params ) ) { foreach ( $ params as $ k => $ v ) { if ( is_int ( $ k ) ) { GoCardless_Utils :: generate_query_string ( $ v , $ pairs , $ namespace . '[]' ) ; } else { GoCardless_Utils :: generate_query_string ( $ v , $ pairs , $ namespace !== null ? $ namespace . "[$k]" : $ k ) ; } } if ( $ namespace !== null ) { return $ pairs ; } if ( empty ( $ pairs ) ) { return '' ; } usort ( $ pairs , array ( __CLASS__ , 'sortPairs' ) ) ; $ strs = array ( ) ; foreach ( $ pairs as $ pair ) { $ strs [ ] = $ pair [ 0 ] . '=' . $ pair [ 1 ] ; } return implode ( '&' , $ strs ) ; } else { $ pairs [ ] = array ( rawurlencode ( $ namespace ) , rawurlencode ( $ params ) ) ; } }
291	public function populateRelation ( $ name , $ records ) { foreach ( $ this -> _relationsDependencies as & $ relationNames ) { unset ( $ relationNames [ $ name ] ) ; } $ this -> _related [ $ name ] = $ records ; }
6387	public function readDiscussion ( $ id ) { $ model = $ this -> readObject ( $ id , 'forum_discussions' ) ; $ model -> url = $ this -> cfg -> wwwroot . '/mod/forum/discuss.php?d=' . $ id ; return $ model ; }
4514	public static function parse ( string $ string , array $ data = [ ] ) : array { if ( $ data ) { $ string = Parameters :: replace ( $ string , $ data ) ; } $ data = Yaml :: parse ( $ string , Yaml :: PARSE_OBJECT_FOR_MAP ) ; if ( ! property_exists ( $ data , 'objects' ) ) { throw new LogicException ( 'Property "objects" does not exist.' ) ; } if ( ! is_array ( $ data -> objects ) ) { throw new LogicException ( 'Property "objects" is not an array.' ) ; } $ prototype = [ ] ; if ( property_exists ( $ data , 'prototype' ) ) { if ( ! is_object ( $ data -> prototype ) ) { throw new LogicException ( 'Property "prototype" is not an object.' ) ; } $ prototype = $ data -> prototype ; } $ objects = [ ] ; foreach ( $ data -> objects as $ object ) { $ objects [ ] = ( object ) array_merge ( ( array ) $ prototype , ( array ) $ object ) ; } return $ objects ; }
1273	public function isAmbiguous ( ) { if ( AddressValidation :: REQUEST_OPTION_ADDRESS_CLASSIFICATION == $ this -> requestAction ) { throw new \ BadMethodCallException ( __METHOD__ . ' should not be called on Address Classification only requests.' ) ; } return isset ( $ this -> response -> AmbiguousAddressIndicator ) ; }
8069	public function bind ( $ username , $ password ) { if ( $ this -> tls ) { if ( ! ldap_start_tls ( $ this -> connection ) ) { throw new ConnectionException ( 'Unable to Connect to LDAP using TLS.' ) ; } } try { $ this -> bound = ldap_bind ( $ this -> connection , $ username , $ password ) ; } catch ( ErrorException $ e ) { $ this -> bound = false ; } return $ this -> bound ; }
11694	protected function getCompiler ( SplFileInfo $ file ) : Compiler { $ source_type = $ this -> getSourceType ( $ file ) ; $ compiler_type = '\Gears\Asset\Compilers\\' ; $ compiler_type .= ucfirst ( $ source_type ) ; if ( ! class_exists ( $ compiler_type ) ) { throw new RuntimeException ( 'The source file type is not supported! - (' . $ file . ')' ) ; } return new $ compiler_type ( $ file , $ this -> destination , $ this -> debug , $ this -> autoprefix ) ; }
12525	static function release ( $ token , $ mode , $ opts = array ( ) ) { clearstatcache ( ) ; $ lockDir = self :: lockDir ( $ opts ) ; if ( $ mode == LOCK_EX ) { $ wLockFile = "$lockDir/{$token}_W.lock" ; if ( is_file ( $ wLockFile ) && ! unlink ( $ wLockFile ) ) { pake_echo_error ( "Could not remove W lock file '$wLockFile'" ) ; } return ; } $ rLockFile = "$lockDir/{$token}_R/" . getmypid ( ) . ".lock" ; if ( is_file ( $ rLockFile ) && ! unlink ( $ rLockFile ) ) { pake_echo_error ( "Could not remove R lock file '$rLockFile'" ) ; } }
2103	public function hasOldDatabase ( ) : bool { if ( ! $ this -> hasTable ( 'tl_layout' ) ) { return false ; } $ sql = $ this -> connection -> getDatabasePlatform ( ) -> getListTableColumnsSQL ( 'tl_layout' , $ this -> connection -> getDatabase ( ) ) ; $ columns = $ this -> connection -> fetchAll ( $ sql ) ; foreach ( $ columns as $ column ) { if ( 'sections' === $ column [ 'Field' ] ) { return ! \ in_array ( $ column [ 'Type' ] , [ 'varchar(1022)' , 'blob' ] , true ) ; } } return false ; }
2624	private function sendReqToGA ( $ body = '' , $ method = \ Zend_Http_Client :: POST , $ uri = self :: GA_API_ENDPOINT ) { $ reqGAData = ( array ) $ this -> getGAReqData ( ) ; if ( $ body != '' && is_array ( $ body ) && ! empty ( $ body ) ) { $ body = array_merge ( $ reqGAData , $ body ) ; } try { $ client = $ this -> curlFactory -> create ( ) ; $ client -> addOption ( CURLOPT_TIMEOUT , 10 ) ; $ client -> write ( $ method , $ uri , '1.1' , null , http_build_query ( $ body ) ) ; $ response = $ client -> read ( ) ; $ responseCode = \ Zend_Http_Response :: extractCode ( $ response ) ; $ client -> close ( ) ; if ( $ responseCode != '200' ) { throw new LocalizedException ( __ ( 'Return status ' . $ responseCode ) ) ; } return true ; } catch ( \ Exception $ e ) { return false ; } }
11731	protected function generateSlot ( $ path , $ blocks = array ( ) , $ username = null ) { if ( is_dir ( $ path ) && ! $ this -> override ) { return ; } $ folders = array ( ) ; $ activeDir = $ path . '/active' ; $ contributorsDir = $ path . '/contributors' ; $ folders [ ] = $ activeDir . '/blocks' ; $ folders [ ] = $ activeDir . '/archive' ; $ folders [ ] = $ contributorsDir ; $ targetDir = $ activeDir ; $ blocksDir = $ activeDir . '/blocks' ; if ( null !== $ username ) { $ targetDir = $ contributorsDir . '/' . $ username ; $ blocksDir = $ targetDir . '/blocks' ; $ folders [ ] = $ targetDir ; $ folders [ ] = $ targetDir . '/archive' ; $ folders [ ] = $ blocksDir ; } $ this -> filesystem -> mkdir ( $ folders ) ; $ this -> generateBlocks ( $ blocks , $ blocksDir , $ targetDir ) ; }
3828	protected function addUrlParameter ( $ url , $ name , $ value ) { @ trigger_error ( sprintf ( '"%1$s" has been deprecated in favor of the "FilterUrlBuilder"' , __METHOD__ ) , E_USER_DEPRECATED ) ; if ( is_array ( $ value ) ) { $ value = implode ( ',' , array_filter ( $ value ) ) ; } $ value = str_replace ( '%' , '%%' , urlencode ( $ value ) ) ; if ( empty ( $ value ) ) { return $ url ; } if ( $ name !== 'auto_item' ) { $ url .= '/' . $ name . '/' . $ value ; } else { $ url = '/' . $ value . $ url ; } return $ url ; }
296	public function isAttributeChanged ( $ name , $ identical = true ) { if ( isset ( $ this -> _attributes [ $ name ] , $ this -> _oldAttributes [ $ name ] ) ) { if ( $ identical ) { return $ this -> _attributes [ $ name ] !== $ this -> _oldAttributes [ $ name ] ; } return $ this -> _attributes [ $ name ] != $ this -> _oldAttributes [ $ name ] ; } return isset ( $ this -> _attributes [ $ name ] ) || isset ( $ this -> _oldAttributes [ $ name ] ) ; }
8086	private function cleanConsole ( ) { $ channel = $ this -> namespaceChannel ( $ this -> currentChannel ) ; if ( empty ( $ this -> console [ 'errors' ] [ $ channel ] ) ) { unset ( $ this -> console [ 'errors' ] [ $ channel ] ) ; } if ( empty ( $ this -> console [ 'form' ] [ $ channel ] ) ) { unset ( $ this -> console [ 'form' ] [ $ channel ] ) ; } if ( empty ( $ this -> console [ 'reports' ] [ $ channel ] ) ) { unset ( $ this -> console [ 'reports' ] [ $ channel ] ) ; } }
1748	protected function listSingleRecord ( $ id ) { if ( ! \ strlen ( $ this -> list_info_layout ) ) { $ this -> list_info_layout = 'info_default' ; } $ this -> Template = new FrontendTemplate ( $ this -> list_info_layout ) ; $ this -> Template -> record = array ( ) ; $ this -> Template -> referer = 'javascript:history.go(-1)' ; $ this -> Template -> back = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'goBack' ] ; $ this -> list_info = StringUtil :: deserialize ( $ this -> list_info ) ; $ this -> list_info_where = $ this -> replaceInsertTags ( $ this -> list_info_where , false ) ; $ objRecord = $ this -> Database -> prepare ( "SELECT " . implode ( ', ' , array_map ( 'Database::quoteIdentifier' , trimsplit ( ',' , $ this -> list_info ) ) ) . " FROM " . $ this -> list_table . " WHERE " . ( ( $ this -> list_info_where != '' ) ? "(" . $ this -> list_info_where . ") AND " : "" ) . Database :: quoteIdentifier ( $ this -> strPk ) . "=?" ) -> limit ( 1 ) -> execute ( $ id ) ; if ( $ objRecord -> numRows < 1 ) { return ; } $ arrFields = array ( ) ; $ arrRow = $ objRecord -> row ( ) ; $ limit = \ count ( $ arrRow ) ; $ count = - 1 ; foreach ( $ arrRow as $ k => $ v ) { if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> list_table ] [ 'fields' ] [ $ k ] [ 'inputType' ] == 'password' ) { -- $ limit ; continue ; } $ class = 'row_' . ++ $ count . ( ( $ count == 0 ) ? ' row_first' : '' ) . ( ( $ count >= ( $ limit - 1 ) ) ? ' row_last' : '' ) . ( ( ( $ count % 2 ) == 0 ) ? ' even' : ' odd' ) ; $ arrFields [ $ k ] = array ( 'raw' => $ v , 'label' => ( \ strlen ( $ label = $ GLOBALS [ 'TL_DCA' ] [ $ this -> list_table ] [ 'fields' ] [ $ k ] [ 'label' ] [ 0 ] ) ? $ label : $ k ) , 'content' => $ this -> formatValue ( $ k , $ v , true ) , 'class' => $ class ) ; } $ this -> Template -> record = $ arrFields ; }
9079	private static function parseUri ( Request & $ request , $ uri , $ defaultController , $ defaultAction ) { $ contextUri = $ uri ; if ( null != $ request -> getContextPrefix ( ) && '/' != $ request -> getContextPrefix ( ) ) { $ contextUri = str_replace ( $ request -> getContextPrefix ( ) , '' , $ uri ) ; } $ parts = array ( ) ; if ( $ contextUri != '' ) { while ( isset ( $ contextUri [ 0 ] ) && $ contextUri [ 0 ] == '/' ) { $ contextUri = substr ( $ contextUri , 1 ) ; } $ parts = explode ( '/' , $ contextUri ) ; } if ( count ( $ parts ) > 0 ) { $ request -> setController ( ucfirst ( trim ( $ parts [ 0 ] ) ) ) ; array_shift ( $ parts ) ; if ( ! $ request -> getController ( ) ) { $ request -> setController ( $ defaultController ) ; } } if ( count ( $ parts ) > 0 ) { $ request -> setAction ( trim ( $ parts [ 0 ] ) ) ; array_shift ( $ parts ) ; if ( ! $ request -> getAction ( ) ) { $ request -> setAction ( $ defaultAction ) ; } } return $ parts ; }
10902	public function loadRelation ( string $ name ) { if ( ! isset ( $ this -> relationObjects [ $ name ] ) || empty ( $ this -> relationObjects [ $ name ] ) ) { $ relation = $ this -> getRelations ( ) [ $ name ] ; if ( ! $ relation || ! $ relation [ 'entity' ] || ! $ this -> get ( $ relation [ 'key' ] ?? 'id' ) ) { return null ; } $ entity = $ this -> entity ( $ relation [ 'entity' ] ) ; $ type = $ relation [ 'type' ] ?? 'has_one' ; $ key = $ relation [ 'key' ] ?? ( 'has_one' === $ type ? $ this -> __getEntityName ( ) . '_id' : 'id' ) ; $ foreignKey = $ relation [ 'foreign_key' ] ?? ( 'has_one' === $ type ? 'id' : $ this -> __getEntityName ( ) . '_id' ) ; $ assoc = $ relation [ 'assoc' ] ?? false ; $ this -> relationObjects [ $ name ] = ( 'has_one' === $ type ) ? $ entity -> load ( $ this -> get ( $ key ) , $ foreignKey ) : $ entity -> loadAll ( [ $ foreignKey => $ this -> get ( $ key ) ] , $ assoc ) ; } return $ this -> relationObjects [ $ name ] ?? null ; }
12105	public function exception ( Exception $ exception ) { if ( $ this -> stopPropagation ) { return false ; } $ this -> fireHandlers ( $ exception ) ; $ this -> stopPropagation = true ; return false ; }
5715	public function doSaveAndAdd ( $ data , $ form ) { return $ this -> saveAndRedirect ( $ data , $ form , $ this -> owner -> Link ( "addnew" ) ) ; }
2062	public function generateArticle ( Contao \ DataContainer $ dc ) { if ( ! $ dc -> activeRecord ) { return ; } if ( $ dc -> activeRecord -> title == '' || ! \ in_array ( $ dc -> activeRecord -> type , array ( 'regular' , 'error_401' , 'error_403' , 'error_404' ) ) ) { return ; } $ objSessionBag = Contao \ System :: getContainer ( ) -> get ( 'session' ) -> getBag ( 'contao_backend' ) ; $ new_records = $ objSessionBag -> get ( 'new_records' ) ; if ( ! $ new_records || ! \ is_array ( $ new_records [ $ dc -> table ] ) || ! \ in_array ( $ dc -> id , $ new_records [ $ dc -> table ] ) ) { return ; } $ objTotal = $ this -> Database -> prepare ( "SELECT COUNT(*) AS count FROM tl_article WHERE pid=?" ) -> execute ( $ dc -> id ) ; if ( $ objTotal -> count > 0 ) { return ; } $ arrSet [ 'pid' ] = $ dc -> id ; $ arrSet [ 'sorting' ] = 128 ; $ arrSet [ 'tstamp' ] = time ( ) ; $ arrSet [ 'author' ] = $ this -> User -> id ; $ arrSet [ 'inColumn' ] = 'main' ; $ arrSet [ 'title' ] = $ dc -> activeRecord -> title ; $ arrSet [ 'alias' ] = str_replace ( '/' , '-' , $ dc -> activeRecord -> alias ) ; $ arrSet [ 'published' ] = $ dc -> activeRecord -> published ; $ this -> Database -> prepare ( "INSERT INTO tl_article %s" ) -> set ( $ arrSet ) -> execute ( ) ; }
7525	function select ( $ query = '*' , $ index = false , $ recursive = true , $ check_self = false ) { return $ this -> root -> select ( $ query , $ index , $ recursive , $ check_self ) ; }
9959	public function unprotectCellsByColumnAndRow ( $ columnIndex1 , $ row1 , $ columnIndex2 , $ row2 ) { $ cellRange = Coordinate :: stringFromColumnIndex ( $ columnIndex1 ) . $ row1 . ':' . Coordinate :: stringFromColumnIndex ( $ columnIndex2 ) . $ row2 ; return $ this -> unprotectCells ( $ cellRange ) ; }
9335	public function rad ( ) { if ( $ this -> original -> type == self :: TYPE_RAD ) { return $ this -> original -> value ; } return $ this -> float_rad ; }
4950	public function createDraft ( array $ data = null , $ persist = false ) { $ data [ 'isDraft' ] = true ; return $ this -> create ( $ data , $ persist ) ; }
7854	protected function deleteIfForced ( array $ files ) { if ( ! $ this -> option ( 'force' ) ) return ; foreach ( $ files as $ file ) { if ( $ this -> files -> exists ( $ path = $ this -> getPath ( $ file ) ) ) { $ this -> files -> delete ( $ path ) ; } } }
10656	public function usort ( $ cmp_function ) { $ tmp = $ this -> getArrayCopy ( ) ; $ ret = usort ( $ tmp , $ cmp_function ) ; $ tmp = new self ( $ tmp ) ; $ this -> exchangeArray ( $ tmp -> getArrayCopy ( ) ) ; return $ ret ; }
6872	private function initializeRelayPoint ( ShipmentInterface $ shipment ) { if ( null === $ method = $ shipment -> getMethod ( ) ) { if ( null !== $ shipment -> getRelayPoint ( ) ) { $ shipment -> setRelayPoint ( null ) ; } return ; } $ gateway = $ this -> registry -> getGateway ( $ method -> getGatewayName ( ) ) ; if ( ! $ gateway -> supports ( GatewayInterface :: CAPABILITY_RELAY ) ) { if ( null !== $ shipment -> getRelayPoint ( ) ) { $ shipment -> setRelayPoint ( null ) ; } return ; } if ( null !== $ relayPoint = $ shipment -> getSale ( ) -> getRelayPoint ( ) ) { $ shipment -> setRelayPoint ( $ relayPoint ) ; } }
10376	protected static function look_if_process_files ( $ type ) { if ( is_string ( self :: $ unify ) || isset ( self :: $ unify [ "{$type}s" ] ) ) { return self :: unify_files ( self :: prepare_files ( $ type ) ) ; } }
7747	private function findAdderAndRemover ( ) { $ reflClass = new \ ReflectionClass ( $ this -> class ) ; $ singulars = ( array ) StringUtil :: singularify ( $ this -> camelize ( $ this -> name ) ) ; foreach ( $ singulars as $ singular ) { $ addMethod = 'add' . $ singular ; $ removeMethod = 'remove' . $ singular ; $ addMethodFound = $ this -> isAccessible ( $ reflClass , $ addMethod , 1 ) ; $ removeMethodFound = $ this -> isAccessible ( $ reflClass , $ removeMethod , 1 ) ; if ( $ addMethodFound && $ removeMethodFound ) { $ this -> adderRemover = $ singular ; return ; } } }
12259	public function compile ( callable $ validator = NULL ) { if ( ! ( $ project = $ this -> getProject ( ) ) ) { $ project = CC :: get ( $ this -> getConfiguration ( ) , CC :: COMPILER_PROJECT ) ; if ( ! $ project ) throw new CompilerException ( "Compilation without project settings is not possible" ) ; } $ this -> project = $ project ; try { set_error_handler ( function ( $ code , $ msg , $ file , $ line ) { switch ( AbstractErrorHandlerService :: detectErrorLevel ( $ code ) ) { case AbstractErrorHandlerService :: NOTICE_ERROR_LEVEL : return $ this -> getLogger ( ) -> logNotice ( $ msg , [ $ file , $ line ] ) ; case AbstractErrorHandlerService :: DEPRECATED_ERROR_LEVEL : case AbstractErrorHandlerService :: WARNING_ERROR_LEVEL : return $ this -> getLogger ( ) -> logWarning ( $ msg , [ $ file , $ line ] ) ; default : return $ this -> getLogger ( ) -> logError ( $ msg , [ $ file , $ line ] ) ; } } ) ; foreach ( $ this -> getOrganizedCompilers ( ) as $ compiler ) { if ( ! $ validator || $ validator ( $ compiler ) ) $ compiler -> compile ( $ this ) ; } } catch ( Throwable $ throwable ) { $ this -> getLogger ( ) -> logException ( $ throwable ) ; } finally { restore_error_handler ( ) ; } }
5806	public function validate ( ValidationResult $ result ) { $ validate = 'Title' ; $ class = $ this -> owner -> ClassName ; foreach ( Config :: inst ( ) -> get ( 'FusionService' , 'custom_tag_types' ) as $ type => $ field ) { if ( $ type === $ class ) { $ validate = $ field ; } } if ( $ result -> valid ( ) && ! $ this -> owner -> $ validate ) { $ result -> error ( "\"{$validate}\" required!" ) ; } $ this -> owner -> extend ( 'validateFusionExtension' , $ result ) ; return $ result ; }
5944	public function categories ( $ categoryIds , $ deploymentSiteIds = null , $ ignoreGrouping = false , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'deploymentSiteIds' => $ deploymentSiteIds , 'ignoreGrouping' => $ ignoreGrouping ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/filters/categories/' . $ categoryIds . '' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new FilterItem ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
1546	public function document ( $ request ) : ? \ stdClass { if ( $ this -> cannotDecodeJsonApi ( ) ) { return null ; } return $ this -> decoding -> getJsonApiDecoder ( ) -> document ( $ request ) ; }
11791	public function setFrom ( $ mail = '' , $ name = null , $ reply = true ) { $ mail = trim ( $ mail ) ; if ( strlen ( $ mail ) && Helper :: isEmail ( $ mail ) ) { $ this -> from = ! empty ( $ name ) ? array ( $ name => $ mail ) : array ( $ mail ) ; $ this -> getMailer ( ) -> setRegistry ( 'Return-Path' , '<' . $ mail . '>' , 'headers' ) ; $ this -> getMailer ( ) -> setRegistry ( 'X-Sender' , $ mail , 'headers' ) ; if ( $ reply ) { $ this -> setReplyTo ( $ mail , $ name ) ; } } return $ this ; }
9269	public function setPhase ( $ value ) { $ value = ( int ) $ value ; if ( $ value ) $ this -> phase = $ value ; else $ this -> phase = null ; return $ this ; }
6571	private function getIdPath ( string $ id ) : string { if ( ! preg_match ( "/^[a-z0-9]$/ui" , $ id ) ) { throw new HandlerException ( sprintf ( "The session id %s is invalid" , $ id ) , $ this ) ; } return $ this -> savePath . "/$id.session" ; }
10609	public function classifiedAnswerAction ( ) { $ request = $ this -> getRequest ( ) ; $ response = $ this -> getResponse ( ) ; if ( ! $ request -> isPost ( ) ) { $ response -> setStatusCode ( Response :: STATUS_CODE_500 ) ; return new JsonModel ( array ( 'status' => 'danger' , 'message' => 'Invalid method call' ) ) ; } $ userService = $ this -> getServiceLocator ( ) -> get ( 'user.service.user' ) ; $ data = array_merge_recursive ( $ this -> params ( ) -> fromPost ( ) , Json :: decode ( $ request -> getContent ( ) , Json :: TYPE_ARRAY ) ) ; try { $ response -> setStatusCode ( Response :: STATUS_CODE_200 ) ; $ userService -> classifiedAnswer ( $ data ) ; $ returnData = array ( 'status' => 'success' , 'message' => 'La tua risposta  stata inviata!' ) ; } catch ( \ Exception $ e ) { $ response -> setStatusCode ( Response :: STATUS_CODE_500 ) ; $ returnData = @ unserialize ( $ e -> getMessage ( ) ) ; if ( ! is_array ( $ returnData ) ) { $ returnData = array ( 'status' => 'danger' , 'message' => $ e -> getMessage ( ) ) ; } } return new JsonModel ( $ returnData ) ; }
3957	public function save ( $ timestamp = null ) { if ( null === $ timestamp ) { @ \ trigger_error ( 'Not passing a timestamp has been deprecated and will cause an error in MetaModels 3' , E_USER_DEPRECATED ) ; } $ objMetaModel = $ this -> getMetaModel ( ) ; $ objMetaModel -> saveItem ( $ this , $ timestamp ) ; }
1123	public function descendantsAndSelf ( ) { return $ this -> newNestedSetQuery ( ) -> where ( $ this -> getLeftColumnName ( ) , '>=' , $ this -> getLeft ( ) ) -> where ( $ this -> getLeftColumnName ( ) , '<' , $ this -> getRight ( ) ) ; }
1178	protected function getValidatorInstance ( array $ rules , array $ messages = [ ] , array $ customAttributes = [ ] ) { $ factory = $ this -> app -> make ( ValidationFactory :: class ) ; $ data = $ this -> getValidationData ( $ rules , $ customAttributes ) ; $ validator = $ factory -> make ( $ data , $ rules , $ messages , $ customAttributes ) ; $ validator -> addCustomAttributes ( $ customAttributes ) ; return $ validator ; }
2208	public function __isset ( $ strKey ) { if ( empty ( $ this -> arrCache ) ) { $ this -> next ( ) ; } return isset ( $ this -> arrCache [ $ strKey ] ) ; }
1295	public function has ( string $ name , string $ locale = null , bool $ checkLinksAreResolved = true ) : bool { $ field = $ this -> sys -> getContentType ( ) -> getField ( $ name , true ) ; if ( ! $ field ) { return false ; } if ( ! \ array_key_exists ( $ field -> getId ( ) , $ this -> fields ) ) { return false ; } try { $ result = $ this -> getUnresolvedField ( $ field , $ locale ) ; if ( $ checkLinksAreResolved ) { $ this -> resolveFieldLinks ( $ result , $ locale ) ; } } catch ( \ Exception $ exception ) { return false ; } return true ; }
2931	public function setKeys ( $ data ) { foreach ( $ data as $ setter ) { if ( array_key_exists ( 'key' , $ setter ) ) { $ key = $ this -> formatter -> formatKey ( $ setter [ 'key' ] ) ; $ value = array_key_exists ( 'value' , $ setter ) ? $ setter [ 'value' ] : null ; $ comment = array_key_exists ( 'comment' , $ setter ) ? $ setter [ 'comment' ] : null ; $ export = array_key_exists ( 'export' , $ setter ) ? $ setter [ 'export' ] : false ; if ( ! is_file ( $ this -> filePath ) || ! $ this -> keyExists ( $ key ) ) { $ this -> writer -> appendSetter ( $ key , $ value , $ comment , $ export ) ; } else { $ oldInfo = $ this -> getKeys ( [ $ key ] ) ; $ comment = is_null ( $ comment ) ? $ oldInfo [ $ key ] [ 'comment' ] : $ comment ; $ this -> writer -> updateSetter ( $ key , $ value , $ comment , $ export ) ; } } } return $ this ; }
6953	private function resolvePrice ( array $ entry , $ weight ) { $ price = $ count = 0 ; if ( $ weight > $ entry [ 'max_weight' ] ) { $ count = floor ( $ weight / $ entry [ 'max_weight' ] ) ; $ weight = round ( fmod ( $ weight , $ count ) , 3 ) ; } if ( 0 < $ count ) { $ max = end ( $ entry [ 'prices' ] ) [ 'price' ] ; $ price = $ count * $ max ; } foreach ( $ entry [ 'prices' ] as $ p ) { if ( 1 === bccomp ( $ p [ 'weight' ] , $ weight , 3 ) ) { $ price += $ p [ 'price' ] ; break ; } } return $ price ; }
10228	private function resolveModelName ( $ model ) { if ( $ model instanceof Controller ) { $ exploded = explode ( '\\' , get_class ( $ model ) ) ; $ controllerName = array_pop ( $ exploded ) ; return str_singular ( str_replace ( 'Controller' , '' , $ controllerName ) ) ; } else if ( $ model instanceof Eloquent ) { return get_class ( $ model ) ; } else { return $ model ; } }
10660	public function withHeaders ( array $ headers ) { $ object = clone $ this ; $ object -> configs [ 'headers' ] = [ ] ; $ object -> inProcessingLoop = true ; $ object -> replaceHeaders ( $ headers ) ; $ object -> inProcessingLoop = true ; return $ object -> buildConfigClient ( ) ; }
4302	public function groupUncollapse ( ) { if ( ! $ this -> cfg [ 'collect' ] ) { return ; } $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) ) ; $ curDepth = 0 ; foreach ( $ this -> rootInstance -> groupStackRef as $ group ) { $ curDepth += ( int ) $ group [ 'collect' ] ; } $ entryKeys = \ array_keys ( $ this -> internal -> getCurrentGroups ( $ this -> rootInstance -> logRef , $ curDepth ) ) ; foreach ( $ entryKeys as $ key ) { $ this -> rootInstance -> logRef [ $ key ] [ 0 ] = 'group' ; } $ this -> internal -> publishBubbleEvent ( 'debug.log' , $ this , array ( 'method' => __FUNCTION__ , 'args' => array ( ) , 'meta' => $ meta , ) ) ; }
11003	public function URL ( $ path = '' , $ current_url = null ) { $ url = new URL ( $ this -> url ) ; $ path = ltrim ( $ path , '/' ) ; $ url -> set ( 'path' , $ url -> path . $ path ) ; if ( $ current_url instanceof URL ) { if ( $ url -> host === $ current_url -> host && $ url -> scheme === $ current_url -> scheme && $ url -> port === $ current_url -> port ) { $ url -> host = null ; $ url -> scheme = null ; } } return $ url ; }
12868	public function resetPassword ( Token $ token ) { if ( ! $ this -> validate ( ) || $ token -> user === null ) { return false ; } if ( $ token -> user -> resetPassword ( $ this -> password ) ) { \ Yii :: $ app -> session -> setFlash ( 'success' , \ Yii :: t ( 'user' , 'Your password has been changed successfully.' ) ) ; $ token -> delete ( ) ; } else { \ Yii :: $ app -> session -> setFlash ( 'danger' , \ Yii :: t ( 'user' , 'An error occurred and your password has not been changed. Please try again later.' ) ) ; } return true ; }
7933	public function loadFromArray ( array $ data ) { list ( $ data ) = $ this -> fireEvent ( 'load-from-array' , [ $ data ] ) ; $ files = [ ] ; if ( isset ( $ data [ 'files' ] [ 'js' ] ) && is_array ( $ data [ 'files' ] [ 'js' ] ) ) $ files [ 'js' ] = $ this -> resolveFilesList ( $ data [ 'files' ] [ 'js' ] , isset ( $ data [ 'revision' ] ) ? $ data [ 'revision' ] : null ) ; if ( isset ( $ data [ 'files' ] [ 'css' ] ) && is_array ( $ data [ 'files' ] [ 'css' ] ) ) $ files [ 'css' ] = $ this -> resolveFilesList ( $ data [ 'files' ] [ 'css' ] , isset ( $ data [ 'revision' ] ) ? $ data [ 'revision' ] : null ) ; $ item = [ 'order' => isset ( $ data [ 'order' ] ) ? $ data [ 'order' ] : 0 , 'name' => isset ( $ data [ 'name' ] ) ? $ data [ 'name' ] : uniqid ( ) , 'files' => $ files , 'group' => isset ( $ data [ 'group' ] ) ? $ data [ 'group' ] : $ this -> defaultGroup , 'require' => isset ( $ data [ 'require' ] ) ? $ data [ 'require' ] : [ ] ] ; if ( isset ( $ item [ 'files' ] [ 'js' ] ) && is_array ( $ item [ 'files' ] [ 'js' ] ) ) $ item [ 'files' ] [ 'js' ] = $ this -> applyNamespaces ( $ item [ 'files' ] [ 'js' ] ) ; if ( isset ( $ item [ 'files' ] [ 'css' ] ) && is_array ( $ item [ 'files' ] [ 'css' ] ) ) $ item [ 'files' ] [ 'css' ] = $ this -> applyNamespaces ( $ item [ 'files' ] [ 'css' ] ) ; $ this -> loaded [ ] = $ item ; if ( isset ( $ item [ 'require' ] ) && is_array ( $ item [ 'require' ] ) ) { foreach ( $ item [ 'require' ] as $ name ) { $ this -> loadFromCollection ( $ name ) ; } } return $ this ; }
9032	public function loadClassMetadata ( LoadClassMetadataEventArgs $ eventArgs ) { $ this -> classMetadata = $ eventArgs -> getClassMetadata ( ) ; $ reflectionClass = $ this -> classMetadata -> getReflectionClass ( ) ; if ( null === $ reflectionClass ) { return ; } if ( $ this -> hasMethod ( $ reflectionClass , 'updateTimestamps' ) ) { $ this -> addLifecycleCallbacks ( ) ; $ this -> mapFields ( ) ; } }
10006	public function getRibbonXMLData ( $ what = 'all' ) { $ returnData = null ; $ what = strtolower ( $ what ) ; switch ( $ what ) { case 'all' : $ returnData = $ this -> ribbonXMLData ; break ; case 'target' : case 'data' : if ( is_array ( $ this -> ribbonXMLData ) && isset ( $ this -> ribbonXMLData [ $ what ] ) ) { $ returnData = $ this -> ribbonXMLData [ $ what ] ; } break ; } return $ returnData ; }
8705	public function extend ( EloquentBuilder $ builder ) { $ builder -> macro ( 'onlyTranslated' , function ( EloquentBuilder $ builder , $ locale = null ) { $ builder -> getModel ( ) -> setOnlyTranslated ( true ) ; if ( $ locale ) { $ builder -> getModel ( ) -> setLocale ( $ locale ) ; } return $ builder ; } ) ; $ builder -> macro ( 'withUntranslated' , function ( EloquentBuilder $ builder ) { $ builder -> getModel ( ) -> setOnlyTranslated ( false ) ; return $ builder ; } ) ; $ builder -> macro ( 'withFallback' , function ( EloquentBuilder $ builder , $ fallbackLocale = null ) { $ builder -> getModel ( ) -> setWithFallback ( true ) ; if ( $ fallbackLocale ) { $ builder -> getModel ( ) -> setFallbackLocale ( $ fallbackLocale ) ; } return $ builder ; } ) ; $ builder -> macro ( 'withoutFallback' , function ( EloquentBuilder $ builder ) { $ builder -> getModel ( ) -> setWithFallback ( false ) ; return $ builder ; } ) ; $ builder -> macro ( 'translateInto' , function ( EloquentBuilder $ builder , $ locale ) { if ( $ locale ) { $ builder -> getModel ( ) -> setLocale ( $ locale ) ; } return $ builder ; } ) ; $ builder -> macro ( 'withoutTranslations' , function ( EloquentBuilder $ builder ) { $ builder -> withoutGlobalScope ( static :: class ) ; return $ builder ; } ) ; $ builder -> macro ( 'withAllTranslations' , function ( EloquentBuilder $ builder ) { $ builder -> withoutGlobalScope ( static :: class ) -> with ( 'translations' ) ; return $ builder ; } ) ; }
3033	public function getSessionDescription ( \ taoQtiTest_helpers_TestSession $ session ) { if ( $ session -> isRunning ( ) ) { $ config = \ common_ext_ExtensionsManager :: singleton ( ) -> getExtensionById ( 'taoQtiTest' ) -> getConfig ( 'testRunner' ) ; $ progressScope = isset ( $ config [ 'progress-indicator-scope' ] ) ? $ config [ 'progress-indicator-scope' ] : 'test' ; $ progress = $ this -> getSessionProgress ( $ session ) ; $ itemPosition = $ progress [ $ progressScope ] ; $ itemCount = $ progress [ $ progressScope . 'Length' ] ; $ format = $ this -> hasOption ( self :: OPTION_STATE_FORMAT ) ? $ this -> getOption ( self :: OPTION_STATE_FORMAT ) : __ ( '%s - item %p/%c' ) ; $ map = array ( '%s' => $ session -> getCurrentAssessmentSection ( ) -> getTitle ( ) , '%p' => $ itemPosition , '%c' => $ itemCount ) ; return strtr ( $ format , $ map ) ; } else { return __ ( 'finished' ) ; } }
3655	private function getLabelText ( $ type ) { $ label = $ this -> translator -> trans ( 'tl_metamodel_dcasetting_condition.typedesc.' . $ type , [ ] , 'contao_tl_metamodel_dcasetting_condition' ) ; if ( $ label === 'tl_metamodel_dcasetting_condition.typedesc.' . $ type ) { $ label = $ this -> translator -> trans ( 'tl_metamodel_dcasetting_condition.typedesc._default_' , [ ] , 'contao_tl_metamodel_dcasetting_condition' ) ; if ( $ label === 'tl_metamodel_dcasetting_condition.typedesc._default_' ) { return $ type ; } } return $ label ; }
5772	public function getRolesString ( ) : string { $ rolesString = "" ; foreach ( $ this -> roleNames as $ role ) { $ rolesString .= "$role, " ; } return Functions :: removeLastCharsFromString ( $ rolesString , 2 ) ; }
6908	public function addCopy ( Recipient $ copy ) { if ( ! $ this -> copies -> contains ( $ copy ) ) { $ this -> copies -> add ( $ copy ) ; } return $ this ; }
11029	protected function geolocation ( ) { $ this -> parts [ '{geolocation}' ] = $ this -> form -> field ( $ this -> model , 'latitude' ) -> textInput ( [ 'name' => $ this -> getSubmitModelName ( 'latitude' ) , 'id' => $ this -> fieldIds [ 'latitude' ] ] ) . "\n" . $ this -> form -> field ( $ this -> model , 'longitude' ) -> textInput ( [ 'name' => $ this -> getSubmitModelName ( 'longitude' ) , 'id' => $ this -> fieldIds [ 'longitude' ] ] ) ; }
11793	public function setCc ( $ mail = '' , $ name = null ) { $ this -> cc = Helper :: deduplicate ( array_merge ( $ this -> cc , call_user_func_array ( array ( '\MimeMailer\Helper' , 'checkPeopleArgs' ) , func_get_args ( ) ) ) ) ; return $ this ; }
6364	public function nullsFirst ( ) : Ordering { return Ordering :: from ( Collections :: comparatorFrom ( function ( $ object1 , $ object2 ) { return $ object1 === null ? - 1 : ( $ object2 === null ? 1 : $ this -> compare ( $ object1 , $ object2 ) ) ; } ) ) ; }
3276	public function flush ( ) { $ this -> getDatabase ( ) -> flushFile ( ) ; if ( $ cache = $ this -> getConfig ( ) -> getCache ( ) ) { $ cache -> flush ( ) ; } }
876	private function isCommentWithFixableIndentation ( Tokens $ tokens , $ index ) { if ( ! $ tokens [ $ index ] -> isComment ( ) ) { return false ; } if ( 0 === strpos ( $ tokens [ $ index ] -> getContent ( ) , '/*' ) ) { return true ; } $ firstCommentIndex = $ index ; while ( true ) { $ i = $ this -> getSiblingContinuousSingleLineComment ( $ tokens , $ firstCommentIndex , false ) ; if ( null === $ i ) { break ; } $ firstCommentIndex = $ i ; } $ lastCommentIndex = $ index ; while ( true ) { $ i = $ this -> getSiblingContinuousSingleLineComment ( $ tokens , $ lastCommentIndex , true ) ; if ( null === $ i ) { break ; } $ lastCommentIndex = $ i ; } if ( $ firstCommentIndex === $ lastCommentIndex ) { return true ; } for ( $ i = $ firstCommentIndex + 1 ; $ i < $ lastCommentIndex ; ++ $ i ) { if ( ! $ tokens [ $ i ] -> isWhitespace ( ) && ! $ tokens [ $ i ] -> isComment ( ) ) { return false ; } } return true ; }
10939	public function get ( $ key ) { if ( ! ( $ time = $ this -> driver -> get ( $ key ) ) ) { if ( $ key == self :: LAST_UPDATE_KEY ) { $ time = $ this -> reset ( ) ; } else { $ time = $ this -> get ( self :: LAST_UPDATE_KEY ) ; } } return $ time ; }
9215	public function actionUpdate ( $ id ) { $ model = $ this -> findModel ( $ id ) ; $ model -> tags = ! empty ( $ model -> tags ) ? explode ( "," , $ model -> tags ) : [ ] ; $ post = Yii :: $ app -> request -> post ( ) ; if ( isset ( $ post [ 'StaticPage' ] [ 'tags' ] ) ) { if ( is_array ( $ post [ 'StaticPage' ] [ 'tags' ] ) ) { $ post [ 'StaticPage' ] [ 'tags' ] = implode ( "," , $ post [ 'StaticPage' ] [ 'tags' ] ) ; } } if ( $ model -> load ( $ post ) && $ model -> save ( ) ) { return $ this -> redirect ( [ 'view' , 'id' => $ model -> id ] ) ; } else { return $ this -> render ( 'update' , [ 'model' => $ model , ] ) ; } }
8760	public function setLinePrefixMap ( array $ prefixMap ) { foreach ( $ prefixMap as $ status => $ prefix ) { $ this -> setLinePrefix ( $ status , $ prefix ) ; } }
7163	private function buildSaleItemsLinesViews ( Model \ SaleInterface $ sale ) { if ( ! $ sale -> hasItems ( ) ) { return ; } foreach ( $ sale -> getItems ( ) as $ item ) { $ this -> view -> addItem ( $ this -> buildSaleItemLineView ( $ item ) ) ; } }
4592	public function submit ( $ id , array $ variables ) { foreach ( $ variables as $ variable ) { if ( ! $ variable instanceof Variable ) { throw new InvalidArgumentException ( 'Array of variables is not valid.' ) ; } } $ resource = str_replace ( '{id}' , $ id , static :: RESOURCE_SUBMIT ) ; $ options = [ 'headers' => [ 'Accept' => 'application/json' , 'Content-Type' => 'application/json' ] ] ; foreach ( $ variables as $ variable ) { $ options [ 'json' ] [ 'variables' ] [ $ variable -> getName ( ) ] = [ 'value' => Variable :: TYPE_JSON === $ variable -> getType ( ) ? json_encode ( $ variable -> getValue ( ) ) : $ variable -> getValue ( ) , 'type' => $ variable -> getType ( ) ] ; } $ this -> execute ( 'POST' , $ resource , $ options ) ; }
5967	public function tempPasswordList ( $ resolve = false ) { $ passwords = $ this -> request ( "servertemppasswordlist" ) -> toAssocArray ( "pw_clear" ) ; if ( $ resolve ) { foreach ( $ passwords as $ password => $ array ) { try { $ channel = $ this -> channelGetById ( $ array [ "tcid" ] ) ; $ passwords [ $ password ] [ "tcname" ] = $ channel -> toString ( ) ; $ passwords [ $ password ] [ "tcpath" ] = $ channel -> getPathway ( ) ; } catch ( Ts3Exception $ e ) { if ( $ e -> getCode ( ) != 0xA00 ) { throw $ e ; } } } } return $ passwords ; }
1235	public function elementMeta ( $ elementName ) { $ class = get_class ( $ this ) ; if ( array_key_exists ( $ elementName , self :: $ properties [ $ class ] ) ) { $ info = self :: $ properties [ $ class ] [ $ elementName ] ; $ nameKey = $ info [ 'attribute' ] ? 'attributeName' : 'elementName' ; if ( array_key_exists ( $ nameKey , $ info ) ) { if ( $ info [ $ nameKey ] === $ elementName ) { $ meta = new \ stdClass ( ) ; $ meta -> propertyName = $ elementName ; $ meta -> phpType = $ info [ 'type' ] ; $ meta -> repeatable = $ info [ 'repeatable' ] ; $ meta -> attribute = $ info [ 'attribute' ] ; $ meta -> elementName = $ info [ $ nameKey ] ; $ meta -> strData = '' ; return $ meta ; } } } return null ; }
2001	private function getFiles ( FileUpload $ uploader ) : array { $ files = $ uploader -> uploadTo ( 'system/tmp' ) ; if ( \ count ( $ files ) < 1 ) { throw new \ RuntimeException ( $ this -> translator -> trans ( 'ERR.all_fields' , [ ] , 'contao_default' ) ) ; } foreach ( $ files as & $ file ) { $ extension = pathinfo ( $ file , PATHINFO_EXTENSION ) ; if ( 'csv' !== $ extension ) { throw new \ RuntimeException ( sprintf ( $ this -> translator -> trans ( 'ERR.filetype' , [ ] , 'contao_default' ) , $ extension ) ) ; } $ file = $ this -> projectDir . '/' . $ file ; } return $ files ; }
8131	protected function removeNodeFilter ( Twig_Node $ node ) { if ( $ node instanceof Twig_Node_Expression_Filter ) { return $ this -> removeNodeFilter ( $ node -> getNode ( 'node' ) ) ; } return $ node ; }
4	private function buildDepExtensionConstraints ( $ depItem , $ depType ) { if ( $ this -> isHash ( $ depItem ) ) { $ depItem = array ( $ depItem ) ; } $ result = array ( ) ; foreach ( $ depItem as $ subDepItem ) { $ depChannelName = 'ext' ; $ depPackageName = $ subDepItem [ 'name' ] ; $ depVersionConstraint = $ this -> parse20VersionConstraint ( $ subDepItem ) ; $ result [ ] = new DependencyConstraint ( $ depType , $ depVersionConstraint , $ depChannelName , $ depPackageName ) ; } return $ result ; }
5199	public function validateOptions ( array $ options ) { foreach ( $ options as $ option => $ value ) { if ( ! in_array ( $ option , $ this -> allowedOptions ) ) throw new InvalidOptionException ( "Option [$option] is not valid" ) ; } return $ this ; }
12285	public function end ( ) : string { $ property = static :: END_ASSETS_NAME . static :: BLOCK_PROPERTY_SUFFIX ; return isset ( $ this -> $ property ) ? trim ( $ this -> make ( static :: END_ASSETS_NAME ) ) . PHP_EOL : PHP_EOL ; }
4385	protected function dumpObject ( $ abs ) { $ isNested = $ this -> valueDepth > 0 ; $ this -> valueDepth ++ ; if ( $ abs [ 'isRecursion' ] ) { $ str = '(object) ' . $ abs [ 'className' ] . ' *RECURSION*' ; } elseif ( $ abs [ 'isExcluded' ] ) { $ str = '(object) ' . $ abs [ 'className' ] . ' (not inspected)' ; } else { $ str = '(object) ' . $ abs [ 'className' ] . "\n" ; $ str .= $ this -> dumpProperties ( $ abs ) ; if ( $ abs [ 'collectMethods' ] && $ this -> debug -> output -> getCfg ( 'outputMethods' ) ) { $ str .= $ this -> dumpMethods ( $ abs [ 'methods' ] ) ; } } $ str = \ trim ( $ str ) ; if ( $ isNested ) { $ str = \ str_replace ( "\n" , "\n " , $ str ) ; } return $ str ; }
10200	private function writeXfStyles ( XMLWriter $ writer , Spreadsheet $ spreadsheet ) { foreach ( $ spreadsheet -> getCellXfCollection ( ) as $ style ) { $ writer -> startElement ( 'style:style' ) ; $ writer -> writeAttribute ( 'style:name' , self :: CELL_STYLE_PREFIX . $ style -> getIndex ( ) ) ; $ writer -> writeAttribute ( 'style:family' , 'table-cell' ) ; $ writer -> writeAttribute ( 'style:parent-style-name' , 'Default' ) ; $ writer -> startElement ( 'style:text-properties' ) ; $ font = $ style -> getFont ( ) ; if ( $ font -> getBold ( ) ) { $ writer -> writeAttribute ( 'fo:font-weight' , 'bold' ) ; $ writer -> writeAttribute ( 'style:font-weight-complex' , 'bold' ) ; $ writer -> writeAttribute ( 'style:font-weight-asian' , 'bold' ) ; } if ( $ font -> getItalic ( ) ) { $ writer -> writeAttribute ( 'fo:font-style' , 'italic' ) ; } if ( $ color = $ font -> getColor ( ) ) { $ writer -> writeAttribute ( 'fo:color' , sprintf ( '#%s' , $ color -> getRGB ( ) ) ) ; } if ( $ family = $ font -> getName ( ) ) { $ writer -> writeAttribute ( 'fo:font-family' , $ family ) ; } if ( $ size = $ font -> getSize ( ) ) { $ writer -> writeAttribute ( 'fo:font-size' , sprintf ( '%.1fpt' , $ size ) ) ; } if ( $ font -> getUnderline ( ) && $ font -> getUnderline ( ) != Font :: UNDERLINE_NONE ) { $ writer -> writeAttribute ( 'style:text-underline-style' , 'solid' ) ; $ writer -> writeAttribute ( 'style:text-underline-width' , 'auto' ) ; $ writer -> writeAttribute ( 'style:text-underline-color' , 'font-color' ) ; switch ( $ font -> getUnderline ( ) ) { case Font :: UNDERLINE_DOUBLE : $ writer -> writeAttribute ( 'style:text-underline-type' , 'double' ) ; break ; case Font :: UNDERLINE_SINGLE : $ writer -> writeAttribute ( 'style:text-underline-type' , 'single' ) ; break ; } } $ writer -> endElement ( ) ; $ writer -> startElement ( 'style:table-cell-properties' ) ; $ writer -> writeAttribute ( 'style:rotation-align' , 'none' ) ; if ( $ fill = $ style -> getFill ( ) ) { switch ( $ fill -> getFillType ( ) ) { case Fill :: FILL_SOLID : $ writer -> writeAttribute ( 'fo:background-color' , sprintf ( '#%s' , strtolower ( $ fill -> getStartColor ( ) -> getRGB ( ) ) ) ) ; break ; case Fill :: FILL_GRADIENT_LINEAR : case Fill :: FILL_GRADIENT_PATH : break ; case Fill :: FILL_NONE : default : } } $ writer -> endElement ( ) ; $ writer -> endElement ( ) ; } }
9992	public function generateStyles ( $ generateSurroundingHTML = true ) { if ( $ this -> spreadsheet === null ) { throw new WriterException ( 'Internal Spreadsheet object not set to an instance of an object.' ) ; } $ css = $ this -> buildCSS ( $ generateSurroundingHTML ) ; $ html = '' ; if ( $ generateSurroundingHTML ) { $ html .= ' <style type="text/css">' . PHP_EOL ; $ html .= ' html { ' . $ this -> assembleCSS ( $ css [ 'html' ] ) . ' }' . PHP_EOL ; } foreach ( $ css as $ styleName => $ styleDefinition ) { if ( $ styleName != 'html' ) { $ html .= ' ' . $ styleName . ' { ' . $ this -> assembleCSS ( $ styleDefinition ) . ' }' . PHP_EOL ; } } if ( $ generateSurroundingHTML ) { $ html .= ' </style>' . PHP_EOL ; } return $ html ; }
10407	private function save ( Pair $ pair ) { $ this -> manager -> persist ( $ pair ) ; $ this -> manager -> commit ( ) ; $ this -> manager -> refresh ( ) ; }
10900	public function validate ( string $ method = 'save' ) : array { $ errors = [ ] ; foreach ( $ this -> getValidators ( ) [ $ method ] ?? [ ] as $ field => $ validator ) { try { $ validator -> setName ( $ field ) -> assert ( $ this -> get ( $ field ) ) ; } catch ( NestedValidationException $ e ) { $ errors [ $ field ] = $ e -> getMessages ( ) ; } } return $ errors ; }
1506	protected function buildParams ( EncodingParametersInterface $ parameters ) { return array_filter ( [ QueryParametersParserInterface :: PARAM_FILTER => $ parameters -> getFilteringParameters ( ) , QueryParametersParserInterface :: PARAM_SORT => $ this -> buildSortParams ( ( array ) $ parameters -> getSortParameters ( ) ) ] ) ; }
8026	public function remove ( ProcessDetails $ processDetails ) { $ pid = $ processDetails -> getPid ( ) ; if ( $ this -> hasProcess ( $ pid ) === FALSE ) { throw new \ InvalidArgumentException ( sprintf ( 'Could not remove process. Process (%d) not in list.' , $ processDetails -> getPid ( ) ) , 1400761297 ) ; } if ( isset ( $ this -> freeProcessIds [ $ pid ] ) ) { unset ( $ this -> freeProcessIds [ $ pid ] ) ; } if ( isset ( $ this -> sockets [ $ pid ] ) ) { unset ( $ this -> sockets [ $ pid ] ) ; } unset ( $ this -> processDetails [ $ pid ] ) ; return $ this ; }
10048	public function getColourByIndex ( $ index ) { if ( isset ( $ this -> colourMap [ $ index ] ) ) { return $ this -> colourMap [ $ index ] ; } return null ; }
4239	public function onBootstrap ( ) { if ( $ this -> debug -> parentInstance ) { return ; } $ collectWas = $ this -> debug -> setCfg ( 'collect' , true ) ; $ this -> debug -> groupSummary ( ) ; $ this -> debug -> group ( 'environment' , $ this -> debug -> meta ( array ( 'hideIfEmpty' => true , 'level' => 'info' , ) ) ) ; $ this -> logPhpInfo ( ) ; $ this -> logServerVals ( ) ; $ this -> logRequest ( ) ; $ this -> debug -> groupEnd ( ) ; $ this -> debug -> groupEnd ( ) ; $ this -> debug -> setCfg ( 'collect' , $ collectWas ) ; }
2508	public function createRequest ( $ messageName , RequestOptionsInterface $ params ) { $ this -> checkMessageIsInWsdl ( $ messageName ) ; $ builder = $ this -> findBuilderForMessage ( $ messageName ) ; if ( $ builder instanceof ConvertInterface ) { return $ builder -> convert ( $ params , $ this -> getActiveVersionFor ( $ messageName ) ) ; } else { throw new \ RuntimeException ( 'No builder found for message ' . $ messageName ) ; } }
6866	protected function preventForbiddenChange ( InvoiceInterface $ invoice ) { if ( $ this -> persistenceHelper -> isChanged ( $ invoice , 'type' ) ) { list ( $ old , $ new ) = $ this -> persistenceHelper -> getChangeSet ( $ invoice , 'type' ) ; if ( $ old != $ new ) { throw new Exception \ IllegalOperationException ( "Changing the invoice type is not yet supported." ) ; } } }
10113	private function writeSetup ( ) { $ record = 0x00A1 ; $ length = 0x0022 ; $ iPaperSize = $ this -> phpSheet -> getPageSetup ( ) -> getPaperSize ( ) ; $ iScale = $ this -> phpSheet -> getPageSetup ( ) -> getScale ( ) ? $ this -> phpSheet -> getPageSetup ( ) -> getScale ( ) : 100 ; $ iPageStart = 0x01 ; $ iFitWidth = ( int ) $ this -> phpSheet -> getPageSetup ( ) -> getFitToWidth ( ) ; $ iFitHeight = ( int ) $ this -> phpSheet -> getPageSetup ( ) -> getFitToHeight ( ) ; $ grbit = 0x00 ; $ iRes = 0x0258 ; $ iVRes = 0x0258 ; $ numHdr = $ this -> phpSheet -> getPageMargins ( ) -> getHeader ( ) ; $ numFtr = $ this -> phpSheet -> getPageMargins ( ) -> getFooter ( ) ; $ iCopies = 0x01 ; $ fLeftToRight = 0x0 ; $ fLandscape = ( $ this -> phpSheet -> getPageSetup ( ) -> getOrientation ( ) == PageSetup :: ORIENTATION_LANDSCAPE ) ? 0x0 : 0x1 ; $ fNoPls = 0x0 ; $ fNoColor = 0x0 ; $ fDraft = 0x0 ; $ fNotes = 0x0 ; $ fNoOrient = 0x0 ; $ fUsePage = 0x0 ; $ grbit = $ fLeftToRight ; $ grbit |= $ fLandscape << 1 ; $ grbit |= $ fNoPls << 2 ; $ grbit |= $ fNoColor << 3 ; $ grbit |= $ fDraft << 4 ; $ grbit |= $ fNotes << 5 ; $ grbit |= $ fNoOrient << 6 ; $ grbit |= $ fUsePage << 7 ; $ numHdr = pack ( 'd' , $ numHdr ) ; $ numFtr = pack ( 'd' , $ numFtr ) ; if ( self :: getByteOrder ( ) ) { $ numHdr = strrev ( $ numHdr ) ; $ numFtr = strrev ( $ numFtr ) ; } $ header = pack ( 'vv' , $ record , $ length ) ; $ data1 = pack ( 'vvvvvvvv' , $ iPaperSize , $ iScale , $ iPageStart , $ iFitWidth , $ iFitHeight , $ grbit , $ iRes , $ iVRes ) ; $ data2 = $ numHdr . $ numFtr ; $ data3 = pack ( 'v' , $ iCopies ) ; $ this -> append ( $ header . $ data1 . $ data2 . $ data3 ) ; }
3612	public function setTargetTemperatureMode ( $ mode , $ temperature = NULL , $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; if ( $ temperature !== NULL ) { if ( $ mode == TARGET_TEMP_MODE_RANGE ) { if ( ! is_array ( $ temperature ) || count ( $ temperature ) != 2 || ! is_numeric ( $ temperature [ 0 ] ) || ! is_numeric ( $ temperature [ 1 ] ) ) { echo "Error: when using TARGET_TEMP_MODE_RANGE, you need to set the target temperatures (second argument of setTargetTemperatureMode) using an array of two numeric values.\n" ; return FALSE ; } $ temp_low = $ this -> temperatureInCelsius ( $ temperature [ 0 ] , $ serial_number ) ; $ temp_high = $ this -> temperatureInCelsius ( $ temperature [ 1 ] , $ serial_number ) ; $ data = json_encode ( array ( 'target_change_pending' => TRUE , 'target_temperature_low' => $ temp_low , 'target_temperature_high' => $ temp_high ) ) ; $ set_temp_result = $ this -> doPOST ( "/v2/put/shared." . $ serial_number , $ data ) ; } elseif ( $ mode != TARGET_TEMP_MODE_OFF ) { if ( ! is_numeric ( $ temperature ) ) { echo "Error: when using TARGET_TEMP_MODE_HEAT or TARGET_TEMP_MODE_COLD, you need to set the target temperature (second argument of setTargetTemperatureMode) using an numeric value.\n" ; return FALSE ; } $ temperature = $ this -> temperatureInCelsius ( $ temperature , $ serial_number ) ; $ data = json_encode ( array ( 'target_change_pending' => TRUE , 'target_temperature' => $ temperature ) ) ; $ set_temp_result = $ this -> doPOST ( "/v2/put/shared." . $ serial_number , $ data ) ; } } $ data = json_encode ( array ( 'target_change_pending' => TRUE , 'target_temperature_type' => $ mode ) ) ; return $ this -> doPOST ( "/v2/put/shared." . $ serial_number , $ data ) ; }
2269	public function lockTables ( $ arrTables ) { $ arrLocks = array ( ) ; foreach ( $ arrTables as $ table => $ mode ) { $ arrLocks [ ] = $ this -> resConnection -> quoteIdentifier ( $ table ) . ' ' . $ mode ; } $ this -> resConnection -> exec ( 'LOCK TABLES ' . implode ( ', ' , $ arrLocks ) . ';' ) ; }
8473	public function warning ( $ scope , $ message , $ context = [ ] , $ config = [ ] ) { return $ this -> write ( 'warning' , $ scope , $ message , $ context , $ config ) ; }
7290	static public function isValidMode ( $ mode , $ throw = true ) { if ( in_array ( $ mode , static :: getModes ( ) , true ) ) { return true ; } if ( $ throw ) { throw new InvalidArgumentException ( 'Invalid adjustment mode.' ) ; } return false ; }
9801	public static function setLibXmlLoaderOptions ( $ options ) { if ( $ options === null && defined ( 'LIBXML_DTDLOAD' ) ) { $ options = LIBXML_DTDLOAD | LIBXML_DTDATTR ; } self :: $ libXmlLoaderOptions = $ options ; }
3171	public function getMap ( RunnerServiceContext $ context , RunnerConfig $ config ) { return $ this -> getScopedMap ( $ context , $ config , RunnerMap :: SCOPE_TEST ) ; }
10659	protected function normalizeHeaderName ( $ keyName ) { if ( ! is_string ( $ keyName ) ) { return null ; } return ucwords ( trim ( strtolower ( $ keyName ) ) , '-' ) ? : null ; }
1958	private function getTaskFromInput ( InputInterface $ input , OutputInterface $ output ) : string { $ commands = $ this -> getCommands ( ) ; $ task = $ input -> getArgument ( 'task' ) ; if ( null !== $ task ) { if ( ! \ in_array ( $ task , $ commands , true ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Invalid task "%s"' , $ task ) ) ; } return $ task ; } $ question = new ChoiceQuestion ( 'Please select a task:' , $ commands ) ; $ question -> setMaxAttempts ( 1 ) ; $ helper = $ this -> getHelper ( 'question' ) ; return $ helper -> ask ( $ input , $ output , $ question ) ; }
11826	public function remove ( $ encoding ) { $ str = file_get_contents ( $ this -> uri ) ; return file_put_contents ( $ this -> uri , substr ( $ str , ( strlen ( $ this -> getBom ( $ encoding ) ) ) ) ) ; }
10514	private function updateObserverState ( \ StdClass $ observer ) { $ this -> event -> function = $ observer -> function ; $ observerObject = $ observer -> observer ; $ observerObject -> update ( $ this ) ; }
2125	protected function getDebugMarkup ( ) { $ return = $ this -> getFileUrls ( ) ; foreach ( $ return as $ k => $ v ) { $ options = StringUtil :: resolveFlaggedUrl ( $ v ) ; $ return [ $ k ] = $ v ; if ( $ options -> mtime ) { $ return [ $ k ] .= '?v=' . substr ( md5 ( $ options -> mtime ) , 0 , 8 ) ; } if ( $ options -> media ) { $ return [ $ k ] .= '" media="' . $ options -> media ; } } if ( $ this -> strMode == self :: JS ) { return implode ( '"></script><script src="' , $ return ) ; } return implode ( '"><link rel="stylesheet" href="' , $ return ) ; }
7068	static function getUnits ( ) { return [ static :: PIECE , static :: METER , static :: CENTIMETER , static :: MILLIMETER , static :: INCH , static :: FOOT , static :: KILOGRAM , static :: GRAM , static :: CUBIC_METER , static :: LITER , static :: MILLILITER , static :: DAY , static :: HOUR , static :: MINUTE , static :: SECOND , ] ; }
8374	public function set ( $ set ) { if ( is_array ( $ set ) === true ) { $ this -> set = '' ; foreach ( $ set as $ name => $ value ) { $ pos = stripos ( $ name , '.' ) ; if ( $ pos !== false ) { $ this -> set .= substr ( $ name , $ pos + 1 ) ; } else { $ this -> set .= $ name ; } $ this -> set .= ' = ' . $ value . ', ' ; } $ this -> set = substr ( $ this -> set , 0 , - 2 ) ; } else { $ this -> set = $ set ; } return $ this ; }
6051	public function listFolders ( $ root = 0 , $ depth = 0 , $ includeProperties = true , $ includeObjectCounts = false , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'root' => $ root , 'depth' => $ depth , 'includeProperties' => $ includeProperties , 'includeObjectCounts' => $ includeObjectCounts ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/folders' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new FolderResponse ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
11374	private function getInjectHint ( \ ReflectionMethod $ method , \ ReflectionParameter $ parameter ) { $ hint = Psi :: it ( $ this -> reader -> getMethodAnnotations ( $ method ) ) -> filter ( new IsInstanceOf ( Di \ DiInjectHintAnnotation :: class ) ) -> filter ( function ( Di \ DiInjectHintAnnotation $ i ) use ( $ parameter ) { return $ i -> getParameter ( ) === $ parameter -> getName ( ) ; } ) -> getFirst ( ) ; if ( $ hint !== null ) { return $ hint ; } try { if ( $ parameter -> getClass ( ) === null ) { throw new \ InvalidArgumentException ( "Cannot inject constructor-param '{$parameter->getName()}' into {$method->getDeclaringClass()->getName()}. " . 'The parameter does not have a an @Inject hint and it has no type-hint.' ) ; } } catch ( \ ReflectionException $ e ) { } return Di \ Inject \ ByType :: create ( $ parameter -> getName ( ) , Util :: normalizeFqcn ( ( string ) $ parameter -> getType ( ) ) ) ; }
2301	public static function convertLayoutSectionIdsToAssociativeArray ( $ arrSections ) { $ arrSections = array_flip ( array_values ( array_unique ( $ arrSections ) ) ) ; foreach ( array_keys ( $ arrSections ) as $ k ) { $ arrSections [ $ k ] = $ GLOBALS [ 'TL_LANG' ] [ 'COLS' ] [ $ k ] ; } asort ( $ arrSections ) ; return $ arrSections ; }
4761	public function flush ( ) { if ( $ this -> doNotTrack ) { return ; } if ( empty ( $ this -> queue ) ) { return ; } if ( $ this -> mergePackets ) { $ this -> send ( implode ( "\n" , $ this -> queue ) ) ; } else { foreach ( $ this -> queue as $ data ) { $ this -> send ( $ data ) ; } } $ this -> queue = array ( ) ; $ this -> queueSize = 0 ; }
7895	public function extend ( $ provider , Closure $ callback ) { if ( $ this -> isProviderAliasExists ( $ provider ) ) { throw new InvalidArgumentException ( "Alias provider is already reserved [{$provider}]" ) ; } $ this -> customProviders [ $ provider ] = $ callback ; return $ this ; }
5153	public function addConfiguration ( $ configuration , $ configure = true ) { if ( ! $ configuration instanceof ConfigurationInterface ) { $ configuration = new Configuration ( $ configuration ) ; } $ config = $ this -> getConfiguration ( ) ; if ( $ config instanceof ConfigurationInterface ) { $ config -> merge ( $ configuration ) ; } if ( $ config === null ) { $ config = $ configuration ; } $ this -> setConfiguration ( $ config , $ configure ) ; }
10782	public function andHaving ( $ column , $ op , $ value , $ isParam = true ) { $ this -> clauses [ ] = array ( "AND" , $ column , $ op , $ value , $ isParam ) ; return $ this ; }
5308	protected function getPathFromRect ( SimpleXMLElement $ rect ) { if ( empty ( $ rect [ 'width' ] ) || $ rect [ 'width' ] < 0 || empty ( $ rect [ 'height' ] ) || $ rect [ 'height' ] < 0 ) { return '' ; } if ( empty ( $ rect [ 'x' ] ) ) { $ rect [ 'x' ] = 0 ; } if ( empty ( $ rect [ 'y' ] ) ) { $ rect [ 'y' ] = 0 ; } return 'M' . $ rect [ 'x' ] . ' ' . $ rect [ 'y' ] . 'l' . $ rect [ 'width' ] . ' 0l0 ' . $ rect [ 'height' ] . 'l' . ( - $ rect [ 'width' ] ) . ' 0Z' ; }
12088	public function view ( UserPolicy $ user , Response $ response ) { if ( $ user -> canDo ( 'forum.response.view' ) && $ user -> isAdmin ( ) ) { return true ; } return $ response -> user_id == user_id ( ) && $ response -> user_type == user_type ( ) ; }
3339	public function getGroupsChunk ( $ options = array ( ) , $ reverse = false ) { $ data = $ this -> __preparedRequest ( 'group_list' , 'GET' , $ options ) ; $ groups_raw = ( array ) $ data -> results ; $ resultArr = array ( ) ; foreach ( $ groups_raw as $ group_raw ) { $ resultArr [ ] = new Group ( $ group_raw -> id , $ this ) ; } return $ this -> __preparePagedParams ( $ data , $ reverse , $ resultArr ) ; }
9591	public function radioListWithGap ( $ items , $ options = [ ] ) { $ this -> addListInputCssClass ( $ options , $ this -> radioGapCssClass ) ; return self :: radioList ( $ items , $ options ) ; }
890	public function getTypes ( ) { if ( null === $ this -> types ) { $ this -> types = [ ] ; $ content = $ this -> getTypesContent ( ) ; while ( '' !== $ content && false !== $ content ) { Preg :: match ( '{^' . self :: REGEX_TYPES . '$}x' , $ content , $ matches ) ; $ this -> types [ ] = $ matches [ 'type' ] ; $ content = substr ( $ content , \ strlen ( $ matches [ 'type' ] ) + 1 ) ; } } return $ this -> types ; }
8309	public function assertIntOrFalse ( $ config , $ key , $ lowest = null , $ highest = null ) { try { $ this -> assertInteger ( $ config , $ key , $ lowest , $ highest ) ; } catch ( ConfigurationException $ e ) { if ( $ config [ $ key ] !== false ) { throw new ConfigurationException ( "Key `{$key}` can be either false or a non-negative integer." ) ; } } return $ this ; }
5303	protected static function hexToUnicode ( $ char ) { if ( ! is_string ( $ char ) || ! preg_match ( '(^[0-9a-f]{2,6}$)i' , $ char ) ) { throw new \ InvalidArgumentException ( '$char must be one single unicode character as hex string' ) ; } return mb_convert_encoding ( '&#x' . strtolower ( $ char ) . ';' , 'UTF-8' , 'HTML-ENTITIES' ) ; }
976	public function deleteWebhooks ( ) { $ shopWebhooks = $ this -> shopWebhooks ( ) ; $ deleted = [ ] ; foreach ( $ shopWebhooks as $ webhook ) { $ this -> api -> rest ( 'DELETE' , "/admin/webhooks/{$webhook->id}.json" ) ; $ deleted [ ] = $ webhook ; } $ this -> shopWebhooks = null ; return $ deleted ; }
2195	protected function resendActivationMail ( MemberModel $ objMember ) { if ( $ objMember -> disable == '' ) { return ; } $ this -> strTemplate = 'mod_message' ; $ this -> Template = new FrontendTemplate ( $ this -> strTemplate ) ; $ optIn = System :: getContainer ( ) -> get ( 'contao.opt-in' ) ; $ optInToken = null ; $ models = OptInModel :: findByRelatedTableAndIds ( 'tl_member' , array ( $ objMember -> id ) ) ; foreach ( $ models as $ model ) { if ( ( $ token = $ optIn -> find ( $ model -> token ) ) && $ token -> isValid ( ) && ! $ token -> isConfirmed ( ) ) { $ optInToken = $ token ; break ; } } if ( $ optInToken === null ) { return ; } $ optInToken -> send ( ) ; $ this -> Template -> type = 'confirm' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'resendActivation' ] ; }
12754	protected function prepareRequest ( ) { if ( $ this -> method === static :: GET && ! empty ( $ this -> data ) ) { $ url = trim ( $ this -> url , '/' ) . '?' ; $ url .= http_build_query ( $ this -> data ) ; } else { $ url = $ this -> url ; } $ options = array ( CURLOPT_URL => $ url , CURLOPT_POST => $ this -> method === static :: POST , CURLOPT_HEADER => true , CURLOPT_NOBODY => $ this -> method === static :: HEAD , CURLOPT_RETURNTRANSFER => true , CURLOPT_USERAGENT => $ this -> userAgent , CURLOPT_SSL_VERIFYPEER => false ) ; if ( ! in_array ( $ this -> method , [ static :: GET , static :: HEAD , static :: POST ] ) ) { $ options [ CURLOPT_CUSTOMREQUEST ] = $ this -> method ; } if ( ! empty ( $ this -> data ) && $ this -> method !== static :: GET ) { $ options [ CURLOPT_POSTFIELDS ] = http_build_query ( $ this -> data ) ; } if ( ! empty ( $ this -> headers ) ) { $ headersToSend = [ ] ; foreach ( $ this -> headers as $ key => $ value ) { $ headersToSend [ ] = "{$key}: {$value}" ; } $ options [ CURLOPT_HTTPHEADER ] = $ headersToSend ; } if ( ! empty ( $ this -> cookies ) ) { $ cookiesToSend = [ ] ; foreach ( $ this -> cookies as $ key => $ value ) { $ cookiesToSend [ ] = "{$key}={$value}" ; } $ options [ CURLOPT_COOKIE ] = implode ( '; ' , $ cookiesToSend ) ; } curl_setopt_array ( $ this -> resource , $ options ) ; }
1841	public static function parse ( $ file ) { if ( ! file_exists ( $ file ) ) { throw new \ InvalidArgumentException ( 'Invalid file ' . $ file ) ; } $ table = '' ; $ return = array ( ) ; $ data = file ( $ file ) ; foreach ( $ data as $ k => $ v ) { $ key_name = array ( ) ; $ subpatterns = array ( ) ; if ( preg_match ( '/^[#-]+/' , $ v ) || ! \ strlen ( trim ( $ v ) ) ) { unset ( $ data [ $ k ] ) ; continue ; } if ( preg_match ( '/^CREATE TABLE `([^`]+)`/i' , $ v , $ subpatterns ) ) { $ table = $ subpatterns [ 1 ] ; } elseif ( $ table != '' && preg_match ( '/^\)([^;]+);/' , $ v , $ subpatterns ) ) { $ return [ $ table ] [ 'TABLE_OPTIONS' ] = $ subpatterns [ 1 ] ; $ table = '' ; } elseif ( $ table != '' ) { preg_match ( '/^[^`]*`([^`]+)`/' , trim ( $ v ) , $ key_name ) ; $ first = preg_replace ( '/\s[^\n\r]+/' , '' , $ key_name [ 0 ] ) ; $ key = $ key_name [ 1 ] ; if ( \ in_array ( $ first , array ( 'KEY' , 'PRIMARY' , 'PRIMARY KEY' , 'FOREIGN' , 'FOREIGN KEY' , 'INDEX' , 'UNIQUE' , 'FULLTEXT' , 'CHECK' ) ) ) { if ( strncmp ( $ first , 'PRIMARY' , 7 ) === 0 ) { $ key = 'PRIMARY' ; } $ return [ $ table ] [ 'TABLE_CREATE_DEFINITIONS' ] [ $ key ] = preg_replace ( '/,$/' , '' , trim ( $ v ) ) ; } else { $ return [ $ table ] [ 'TABLE_FIELDS' ] [ $ key ] = preg_replace ( '/,$/' , '' , trim ( $ v ) ) ; } } } foreach ( array_keys ( $ return ) as $ table ) { if ( ! isset ( $ return [ $ table ] [ 'TABLE_CREATE_DEFINITIONS' ] [ 'PRIMARY' ] ) ) { unset ( $ return [ $ table ] [ 'TABLE_OPTIONS' ] ) ; } } return $ return ; }
10637	public function uploadAction ( Request $ request ) { $ rawMedias = array_merge ( $ this -> processUploadedFiles ( $ request -> files ) , $ this -> processUrls ( $ request ) ) ; $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ mtm = $ this -> get ( 'mm_media.mediatype.manager' ) ; $ returnData = array ( ) ; foreach ( $ rawMedias as $ rawmedia ) { if ( null != ( $ mt = $ mtm -> getMediaTypeMatch ( $ rawmedia ) ) ) { $ ms = $ mt -> getEntity ( ) ; $ em -> persist ( $ ms ) ; $ em -> flush ( ) ; $ returnData [ ] = array ( 'id' => $ ms -> getId ( ) , 'path' => $ rawmedia , 'mediatype' => ( string ) $ ms -> getMediaType ( ) , ) ; } } return new JsonResponse ( array ( 'success' => true , 'data' => $ returnData , ) ) ; }
12437	public function addFormField ( IFormField $ field , $ isExtra = false ) { $ fieldId = $ field -> getId ( ) ; if ( empty ( $ fieldId ) ) { throw new \ LogicException ( 'The access path of a form field must not be empty' ) ; } $ field -> setParent ( $ this ) ; $ this -> children [ $ fieldId ] = $ field ; if ( $ isExtra === false ) { $ mappingContext = new MappingContext ( $ this , $ field , $ this -> accessorChain ) ; $ this -> mappingContexts [ $ fieldId ] = $ mappingContext ; } return $ field ; }
5606	public function paintGroupStart ( $ group , $ size ) { $ this -> group = self :: escapeVal ( $ group ) ; if ( $ this -> cc ) { if ( extension_loaded ( 'xdebug' ) ) { xdebug_start_code_coverage ( XDEBUG_CC_UNUSED | XDEBUG_CC_DEAD_CODE ) ; } } }
10986	public static function getMaxUploadSize ( $ max_size = 0 ) { $ post_max_size = Tools :: unformatBytes ( ini_get ( 'post_max_size' ) ) ; $ upload_max_filesize = Tools :: unformatBytes ( ini_get ( 'upload_max_filesize' ) ) ; if ( $ max_size > 0 ) { $ result = min ( $ post_max_size , $ upload_max_filesize , $ max_size ) ; } else { $ result = min ( $ post_max_size , $ upload_max_filesize ) ; } return $ result ; }
10010	public function addSheet ( Worksheet $ pSheet , $ iSheetIndex = null ) { if ( $ this -> sheetNameExists ( $ pSheet -> getTitle ( ) ) ) { throw new Exception ( "Workbook already contains a worksheet named '{$pSheet->getTitle()}'. Rename this worksheet first." ) ; } if ( $ iSheetIndex === null ) { if ( $ this -> activeSheetIndex < 0 ) { $ this -> activeSheetIndex = 0 ; } $ this -> workSheetCollection [ ] = $ pSheet ; } else { array_splice ( $ this -> workSheetCollection , $ iSheetIndex , 0 , [ $ pSheet ] ) ; if ( $ this -> activeSheetIndex >= $ iSheetIndex ) { ++ $ this -> activeSheetIndex ; } } if ( $ pSheet -> getParent ( ) === null ) { $ pSheet -> rebindParent ( $ this ) ; } return $ pSheet ; }
8908	public function created_at ( $ row ) { if ( is_object ( $ row ) ) { $ row -> { $ this -> created_at_key } = date ( 'Y-m-d H:i:s' ) ; } else { $ row [ $ this -> created_at_key ] = date ( 'Y-m-d H:i:s' ) ; } return $ row ; }
7109	static public function getRoundingIncrement ( $ currency ) { if ( isset ( static :: $ increments [ $ currency ] ) ) { return static :: $ increments [ $ currency ] ; } return static :: $ increments [ $ currency ] = static :: getCurrencyBundle ( ) -> getRoundingIncrement ( $ currency ) ; }
8917	public function message ( $ messageId ) { $ params = [ 'query' => [ 'apikey' => $ this -> apikey , ] ] ; $ response = $ this -> client -> get ( 'messages/' . $ messageId , $ params ) ; return $ response -> getBody ( ) ; }
3143	public function timeout ( RunnerServiceContext $ context , $ scope , $ ref , $ late = false ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ session = $ context -> getTestSession ( ) ; if ( $ context -> isAdaptive ( ) ) { \ common_Logger :: t ( "Select next item before timeout" ) ; $ context -> selectAdaptiveNextItem ( ) ; } try { $ session -> closeTimer ( $ ref , $ scope ) ; if ( $ late ) { if ( $ scope == 'assessmentTest' ) { $ code = AssessmentTestSessionException :: ASSESSMENT_TEST_DURATION_OVERFLOW ; } else if ( $ scope == 'testPart' ) { $ code = AssessmentTestSessionException :: TEST_PART_DURATION_OVERFLOW ; } else if ( $ scope == 'assessmentSection' ) { $ code = AssessmentTestSessionException :: ASSESSMENT_SECTION_DURATION_OVERFLOW ; } else { $ code = AssessmentTestSessionException :: ASSESSMENT_ITEM_DURATION_OVERFLOW ; } throw new AssessmentTestSessionException ( "Maximum duration of ${scope} '${ref}' not respected." , $ code ) ; } else { $ session -> checkTimeLimits ( false , true , false ) ; } } catch ( AssessmentTestSessionException $ e ) { $ this -> onTimeout ( $ context , $ e ) ; } } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'timeout' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } return true ; }
12417	static function run_copy_paste_report ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { $ opts = self :: getOpts ( @ $ args [ 0 ] , @ $ args [ 1 ] , $ cliopts ) ; if ( ! SharedLock :: acquire ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ) throw new PakeException ( "Source code locked by another process" ) ; $ destdir = self :: getReportDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ; $ phpcpd = self :: getTool ( 'phpcpd' , $ opts , true ) ; try { $ out = pake_sh ( "$phpcpd " . escapeshellarg ( self :: getBuildDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ) ) ; } catch ( pakeException $ e ) { $ out = preg_replace ( '/^Problem executing command/' , '' , $ e -> getMessage ( ) ) ; } pake_mkdirs ( $ destdir ) ; pake_write_file ( $ destdir . '/phpcpd.txt' , $ out , true ) ; SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; }
9124	private function appendPayloadToRequest ( MemoryStream $ ms ) : MemoryStream { $ this -> payload -> reset ( ) ; while ( $ this -> payload -> ready ( ) ) { $ ms -> write ( $ this -> payload -> read ( 1024 ) ) ; } $ ms -> reset ( ) ; return $ ms ; }
10242	public static function getMatrixDimensions ( array & $ matrix ) { $ matrixRows = count ( $ matrix ) ; $ matrixColumns = 0 ; foreach ( $ matrix as $ rowKey => $ rowValue ) { if ( ! is_array ( $ rowValue ) ) { $ matrix [ $ rowKey ] = [ $ rowValue ] ; $ matrixColumns = max ( 1 , $ matrixColumns ) ; } else { $ matrix [ $ rowKey ] = array_values ( $ rowValue ) ; $ matrixColumns = max ( count ( $ rowValue ) , $ matrixColumns ) ; } } $ matrix = array_values ( $ matrix ) ; return [ $ matrixRows , $ matrixColumns ] ; }
7999	public function identifyTargetName ( $ username , $ nt_domain , ServerChallenge $ server_challenge ) { $ target_name = $ nt_domain ? : $ server_challenge -> getTargetName ( ) ; if ( false !== strpos ( $ username , static :: USER_PRINCIPAL_NAME_SEPARATOR ) ) { $ target_name = '' ; } return $ target_name ; }
7565	protected function parse_callback ( $ conditions , $ recursive = true , $ check_root = false ) { return ( $ this -> result = $ this -> root -> getChildrenByMatch ( $ conditions , $ recursive , $ check_root , $ this -> custom_filter_map ) ) ; }
7198	protected function fixCustomers ( OrderInterface $ order ) { $ changed = false ; $ originCustomer = $ order -> getOriginCustomer ( ) ; $ customer = $ order -> getCustomer ( ) ; if ( is_null ( $ customer ) ) { if ( $ originCustomer && $ originCustomer -> hasParent ( ) ) { $ order -> setCustomer ( $ originCustomer -> getParent ( ) ) ; $ changed = true ; } } elseif ( $ customer -> hasParent ( ) ) { $ order -> setCustomer ( $ customer -> getParent ( ) ) ; if ( null === $ order -> getOriginCustomer ( ) ) { $ order -> setOriginCustomer ( $ customer ) ; } $ changed = true ; } if ( $ changed ) { $ this -> persistenceHelper -> persistAndRecompute ( $ order , false ) ; } return $ changed ; }
3155	public function storeOutcomeVariable ( RunnerServiceContext $ context , $ itemUri , $ variableIdentifier , $ variableValue ) { $ this -> assertQtiRunnerServiceContext ( $ context ) ; $ metaVariable = $ this -> getOutcomeVariable ( $ variableIdentifier , $ variableValue ) ; return $ this -> storeVariable ( $ context , $ itemUri , $ metaVariable ) ; }
8	public function fix ( $ packageName , ConstraintInterface $ constraint = null ) { $ this -> addJob ( $ packageName , 'install' , $ constraint , true ) ; }
8072	public function validateCredentials ( Authenticatable $ user , array $ credentials ) { return $ this -> ldap -> auth ( $ user -> dn , $ credentials [ 'password' ] ) ; }
6342	final public static function valueOf ( $ name ) : self { $ className = static :: class ; Preconditions :: checkArgument ( array_key_exists ( $ className , self :: $ cache ) && array_key_exists ( $ name , self :: $ cache [ $ className ] ) , "The enum '%s' type has no constant with name '%s'" , $ className , $ name ) ; return self :: $ cache [ $ className ] [ $ name ] ; }
7841	public function removeNumber ( int $ id , string $ number ) : ? array { $ response = Request :: delete ( $ this -> baseUrl . sprintf ( 'contact/%d/phone-number/%s' , $ id , $ number ) ) ; if ( $ response -> code != 200 ) { if ( ! empty ( $ response -> body -> message ) ) { Log :: error ( $ response -> body -> message ) ; } } return [ 'code' => $ response -> code , 'message' => ( $ response -> code == 200 ) ? 'OK' : $ response -> body -> message ?? '' , 'data' => $ response -> body , ] ; }
507	public function getMessageSource ( $ category ) { if ( isset ( $ this -> translations [ $ category ] ) ) { $ source = $ this -> translations [ $ category ] ; if ( $ source instanceof MessageSource ) { return $ source ; } return $ this -> translations [ $ category ] = Yii :: createObject ( $ source ) ; } foreach ( $ this -> translations as $ pattern => $ source ) { if ( strpos ( $ pattern , '*' ) > 0 && strpos ( $ category , rtrim ( $ pattern , '*' ) ) === 0 ) { if ( $ source instanceof MessageSource ) { return $ source ; } return $ this -> translations [ $ category ] = $ this -> translations [ $ pattern ] = Yii :: createObject ( $ source ) ; } } if ( isset ( $ this -> translations [ '*' ] ) ) { $ source = $ this -> translations [ '*' ] ; if ( $ source instanceof MessageSource ) { return $ source ; } return $ this -> translations [ $ category ] = $ this -> translations [ '*' ] = Yii :: createObject ( $ source ) ; } throw new InvalidConfigException ( "Unable to locate message source for category '$category'." ) ; }
7989	public function getTemplateProperties ( $ domain , $ templateId ) { $ domain = ( string ) $ domain ; if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; $ templateId = ( string ) $ templateId ; if ( ! $ templateId ) throw new BadMethodCallException ( "Parameter $templateId is missing" ) ; try { $ r = $ this -> get ( 'vps/' . $ domain . '/templates/' . $ templateId ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new VpsException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( ) ; }
4797	function fetch ( $ column = '' ) { $ this -> execute ( ) ; $ return = current ( $ this -> data ) ; next ( $ this -> data ) ; if ( $ return && $ column != '' ) { return $ return [ $ column ] ; } return $ return ; }
4901	public static function loadConfig ( $ configuration = [ ] ) { $ configDir = static :: getConfigDir ( ) ; if ( empty ( $ configuration ) ) { $ configFile = $ configDir . '/config.php' ; if ( ! is_file ( $ configFile ) ) { throw new InvalidArgumentException ( sprintf ( 'Can not load config file "%s". Please be sure that this file exists and readable' , $ configFile ) ) ; } $ configuration = include $ configFile ; } $ isCli = php_sapi_name ( ) === 'cli' ; $ modules = $ configuration [ 'modules' ] ; $ modules = static :: generateModuleConfiguration ( $ modules ) ; $ yawikConfig = $ configDir . '/autoload/yawik.config.global.php' ; $ installMode = false ; if ( ! $ isCli && ! file_exists ( $ yawikConfig ) ) { $ modules = static :: generateModuleConfiguration ( [ 'Install' ] ) ; $ installMode = true ; } elseif ( in_array ( 'Install' , $ modules ) ) { $ modules = array_diff ( $ modules , [ 'Install' ] ) ; } static :: $ env = $ env = getenv ( 'APPLICATION_ENV' ) ? : 'production' ; $ defaults = [ 'module_listener_options' => [ 'module_paths' => [ './module' , './vendor' , './modules' ] , 'config_glob_paths' => [ sprintf ( $ configDir . '/autoload/{,*.}{global,%s,local}.php' , $ env ) ] , 'config_cache_enabled' => ( $ env == 'production' ) , 'module_map_cache_enabled' => ( $ env == 'production' ) , 'module_map_cache_key' => 'module_map' , 'check_dependencies' => ( $ env != 'production' ) , 'cache_dir' => getcwd ( ) . "/var/cache" , ] , ] ; $ envConfig = [ ] ; $ envConfigFile = $ configDir . '/config.' . $ env . '.php' ; if ( file_exists ( $ envConfigFile ) ) { if ( is_readable ( $ envConfigFile ) ) { $ envConfig = include $ envConfigFile ; } else { \ trigger_error ( sprintf ( 'Environment config file "%s" is not readable.' , $ envConfigFile ) , E_USER_NOTICE ) ; } } $ configuration = ArrayUtils :: merge ( $ defaults , $ configuration ) ; $ configuration = ArrayUtils :: merge ( $ configuration , $ envConfig ) ; $ configuration [ 'modules' ] = $ modules ; if ( $ installMode ) { $ configuration [ 'module_listener_options' ] [ 'config_cache_enabled' ] = false ; $ configuration [ 'module_listener_options' ] [ 'module_map_cache_enabled' ] = false ; } if ( getenv ( 'DOCKER_ENV' ) == 'yes' ) { $ configuration = ArrayUtils :: merge ( $ configuration , static :: getDockerEnv ( $ configuration ) ) ; } return $ configuration ; }
11429	public function run ( Request $ request ) { $ dispatcher = $ this -> router -> getDispatcher ( ) ; $ routeInfo = $ dispatcher -> dispatch ( $ request -> server ( 'REQUEST_METHOD' ) , $ request -> server ( 'REQUEST_URI_PATH' ) ) ; switch ( $ routeInfo [ 0 ] ) { case Dispatcher :: NOT_FOUND : $ routeInfo = $ this -> getNotFoundRoute ( $ dispatcher ) ; break ; case Dispatcher :: METHOD_NOT_ALLOWED : $ routeInfo = $ this -> runMethodNotAllowed ( $ dispatcher ) ; break ; case Dispatcher :: FOUND : break ; } $ response = $ this -> runRoute ( $ routeInfo ) ; $ response -> send ( ) ; }
4914	private function addTraversable ( \ Traversable $ result ) { foreach ( $ result as $ item ) { break ; } if ( ! $ item instanceof EntityInterface ) { throw new \ InvalidArgumentException ( 'Traversable objects must be a non-empty collection of Entity instances.' ) ; } $ name = get_class ( $ item ) ; return $ this -> addArray ( [ 'name' => $ name , 'entities' => $ result , ] ) ; }
12746	protected function onMovedResponse ( CommandInterface $ command , $ details ) { list ( $ slot , $ connectionID ) = explode ( ' ' , $ details , 2 ) ; if ( ! $ connection = $ this -> getConnectionById ( $ connectionID ) ) { $ connection = $ this -> createConnection ( $ connectionID ) ; } if ( $ this -> useClusterSlots ) { $ this -> askSlotMap ( $ connection ) ; } $ this -> move ( $ connection , $ slot ) ; $ response = $ this -> executeCommand ( $ command ) ; return $ response ; }
7344	protected function preventForbiddenChange ( ShipmentInterface $ shipment ) { if ( $ this -> persistenceHelper -> isChanged ( $ shipment , 'return' ) ) { list ( $ old , $ new ) = $ this -> persistenceHelper -> getChangeSet ( $ shipment , 'return' ) ; if ( $ old != $ new ) { throw new RuntimeException ( "Changing the shipment type is not yet supported." ) ; } } }
12062	protected function migrate ( Module $ module ) { $ path = str_replace ( base_path ( ) , '' , ( new Migrator ( $ module ) ) -> getPath ( ) ) ; if ( $ this -> option ( 'subpath' ) ) { $ path = $ path . "/" . $ this -> option ( "subpath" ) ; } $ this -> call ( 'migrate' , [ '--path' => $ path , '--database' => $ this -> option ( 'database' ) , '--pretend' => $ this -> option ( 'pretend' ) , '--force' => $ this -> option ( 'force' ) , ] ) ; if ( $ this -> option ( 'seed' ) ) { $ this -> call ( 'component:seed' , [ 'module' => $ module -> getName ( ) ] ) ; } }
2017	protected function resizeUploadedImage ( $ strImage ) { if ( Config :: get ( 'imageWidth' ) < 1 && Config :: get ( 'imageHeight' ) < 1 ) { return false ; } $ objFile = new File ( $ strImage ) ; if ( ! $ objFile -> isSvgImage && ! $ objFile -> isGdImage ) { return false ; } $ arrImageSize = $ objFile -> imageSize ; if ( $ objFile -> isGdImage && ( $ arrImageSize [ 0 ] > Config :: get ( 'gdMaxImgWidth' ) || $ arrImageSize [ 1 ] > Config :: get ( 'gdMaxImgHeight' ) ) ) { Message :: addInfo ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'fileExceeds' ] , $ objFile -> basename ) ) ; $ this -> log ( 'File "' . $ strImage . '" is too big to be resized automatically' , __METHOD__ , TL_FILES ) ; return false ; } $ blnResize = false ; if ( $ arrImageSize [ 0 ] > Config :: get ( 'imageWidth' ) ) { $ blnResize = true ; $ intWidth = Config :: get ( 'imageWidth' ) ; $ intHeight = round ( Config :: get ( 'imageWidth' ) * $ arrImageSize [ 1 ] / $ arrImageSize [ 0 ] ) ; $ arrImageSize = array ( $ intWidth , $ intHeight ) ; } if ( $ arrImageSize [ 1 ] > Config :: get ( 'imageHeight' ) ) { $ blnResize = true ; $ intWidth = round ( Config :: get ( 'imageHeight' ) * $ arrImageSize [ 0 ] / $ arrImageSize [ 1 ] ) ; $ intHeight = Config :: get ( 'imageHeight' ) ; $ arrImageSize = array ( $ intWidth , $ intHeight ) ; } if ( $ blnResize ) { $ container = System :: getContainer ( ) ; $ rootDir = $ container -> getParameter ( 'kernel.project_dir' ) ; $ container -> get ( 'contao.image.image_factory' ) -> create ( $ rootDir . '/' . $ strImage , array ( $ arrImageSize [ 0 ] , $ arrImageSize [ 1 ] ) , $ rootDir . '/' . $ strImage ) ; Message :: addInfo ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'fileResized' ] , $ objFile -> basename ) ) ; $ this -> log ( 'File "' . $ strImage . '" was scaled down to the maximum dimensions' , __METHOD__ , TL_FILES ) ; $ this -> blnHasResized = true ; return true ; } return false ; }
6246	public function files ( ? int $ constraints = null ) : \ Generator { foreach ( $ this -> all ( $ constraints ) as $ file ) { if ( ! $ file -> isDir ( ) ) { yield $ file ; } } }
5291	public static function simpleDetect ( $ text ) { $ detections = self :: detect ( $ text ) ; if ( count ( $ detections ) > 0 ) return $ detections [ 0 ] -> language ; else return null ; }
4823	public function removeField ( $ fieldName ) { if ( array_key_exists ( $ fieldName , $ this -> row ) ) { unset ( $ this -> row [ $ fieldName ] ) ; $ this -> informChanges ( ) ; } }
6223	public function getMenuPresence ( ) { return [ 'id' => 'simple-acl' , 'type' => MenuPresenceType :: GROUP , 'label' => 'Access Control' , 'children' => [ [ 'id' => 'simple-acl-users' , 'type' => MenuPresenceType :: ACTION , 'label' => 'Users' , 'permissions' => 'acl.users.show' , 'action' => $ this -> core -> prefixRoute ( 'acl.users.index' ) , 'parameters' => [ ] , ] , [ 'id' => 'simple-acl-create-user' , 'type' => MenuPresenceType :: ACTION , 'label' => 'New User' , 'permissions' => 'acl.users.create' , 'action' => $ this -> core -> prefixRoute ( 'acl.users.create' ) , 'parameters' => [ ] , ] , [ 'id' => 'simple-acl-roles' , 'type' => MenuPresenceType :: ACTION , 'label' => 'Roles' , 'permissions' => 'acl.roles.show' , 'action' => $ this -> core -> prefixRoute ( 'acl.roles.index' ) , 'parameters' => [ ] , ] , ] ] ; }
2306	public function createFileList ( $ strFilter = '' , $ filemount = false ) { if ( $ strFilter === true ) { @ trigger_error ( 'Passing "true" to Backend::createFileList() has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; $ strFilter = 'gif,jpg,jpeg,png' ; } $ this -> import ( BackendUser :: class , 'User' ) ; if ( $ this -> User -> isAdmin ) { return $ this -> doCreateFileList ( Config :: get ( 'uploadPath' ) , - 1 , $ strFilter ) ; } $ return = '' ; $ processed = array ( ) ; if ( $ filemount ) { $ this -> User -> filemounts = array ( $ filemount ) ; } foreach ( $ this -> eliminateNestedPaths ( $ this -> User -> filemounts ) as $ path ) { if ( \ in_array ( $ path , $ processed ) ) { continue ; } $ processed [ ] = $ path ; $ return .= $ this -> doCreateFileList ( $ path , - 1 , $ strFilter ) ; } return $ return ; }
3329	public function status ( $ token ) { $ data = array ( 'token' => $ token , ) ; $ ch = $ this -> __initRequest ( 'from_url/status' , $ data ) ; $ this -> __setHeaders ( $ ch ) ; $ data = $ this -> __runRequest ( $ ch ) ; return $ data ; }
668	public static function normalizeNumber ( $ value ) { $ value = ( string ) $ value ; $ localeInfo = localeconv ( ) ; $ decimalSeparator = isset ( $ localeInfo [ 'decimal_point' ] ) ? $ localeInfo [ 'decimal_point' ] : null ; if ( $ decimalSeparator !== null && $ decimalSeparator !== '.' ) { $ value = str_replace ( $ decimalSeparator , '.' , $ value ) ; } return $ value ; }
12789	protected function loadForeignObject ( ) { if ( $ this -> _isLoadingForeignObject ) { throw new RecursionException ( 'Ran into recursion while loading foreign object' ) ; } $ this -> _isLoadingForeignObject = true ; if ( isset ( $ this -> foreignPrimaryKey ) ) { $ foreignObject = $ this -> dataSource -> getForeignDataModel ( $ this -> foreignPrimaryKey ) ; if ( $ foreignObject ) { $ this -> foreignObject = $ foreignObject ; } } if ( empty ( $ this -> _foreignObject ) ) { \ d ( $ this -> foreignPrimaryKey ) ; \ d ( $ this -> dataSource -> name ) ; throw new MissingItemException ( 'Foreign item could not be found: ' . $ this -> foreignPrimaryKey ) ; } $ this -> _isLoadingForeignObject = false ; }
3912	protected function remapSorting ( $ arrFiles , $ arrSource ) { $ files = array ( ) ; $ source = array ( ) ; foreach ( array_keys ( $ arrFiles ) as $ k ) { $ files [ ] = $ arrFiles [ $ k ] ; $ source [ ] = $ arrSource [ $ k ] ; } $ this -> addClasses ( $ source ) ; return array ( 'files' => $ files , 'source' => $ source ) ; }
11380	public function deleteAction ( ) { if ( ! preg_match ( '/\/page\/(\w+[\-\w]*)\/text\/..\/(\w+)$/' , $ this -> name , $ matches ) ) { throw new InvalidParameterException ( "Invalid parameters" ) ; } list ( $ dummy , $ pageName , $ containerName ) = $ matches ; $ pageTexts = $ this -> getTextModel ( $ pageName ) ; $ pageTexts -> deleteTextContainer ( $ containerName ) ; $ this -> environment -> sendJSONResult ( 'ok' ) ; }
2099	public static function getNumericDateFormat ( ) { if ( TL_MODE == 'FE' ) { global $ objPage ; if ( $ objPage -> dateFormat != '' && static :: isNumericFormat ( $ objPage -> dateFormat ) ) { return $ objPage -> dateFormat ; } } return Config :: get ( 'dateFormat' ) ; }
2746	public function isImageOptimizationPixelRatioEnabled ( ) { if ( $ this -> isImageOptimizationEnabled ( ) !== true ) { return false ; } return $ this -> _scopeConfig -> isSetFlag ( self :: XML_FASTLY_IMAGE_OPTIMIZATIONS_PIXEL_RATIO ) ; }
11290	protected function _getModels ( $ attributeName , $ relatedObjName = false , $ query = false , $ loadMap = false ) { $ def = $ this -> model_attributes [ $ attributeName ] ; $ result = [ ] ; if ( $ relatedObjName ) { if ( isset ( $ def [ 'via' ] ) ) { $ result = $ this -> _getModelsFromTableColumn ( $ attributeName , $ relatedObjName , $ def [ 'via' ] , $ query , $ loadMap ) ; } else if ( isset ( $ def [ 'using' ] ) ) { $ result = $ this -> getModelsFromCustomRelationship ( $ attributeName , $ relatedObjName , $ query , $ loadMap ) ; } else { $ result = $ this -> _getModelsFromRelationTable ( $ attributeName , $ relatedObjName , $ query , $ loadMap ) ; } } if ( $ result == null ) { $ this -> $ attributeName = new \ Cora \ Collection ( ) ; $ result = $ this -> model_data [ $ attributeName ] ; } return $ result ; }
3268	protected function closeFile ( SplFileObject & $ file ) { if ( ! $ this -> getConfig ( ) -> useGzip ( ) && ! $ file -> flock ( LOCK_UN ) ) { $ file = null ; throw new Exception ( 'Could not unlock file' ) ; } $ file = null ; }
10430	protected function createPipelines ( ContainerBuilder $ container , array $ config ) { foreach ( $ config [ 'pipelines' ] as $ pipelineName => $ pipelineConfig ) { if ( ! isset ( $ pipelineConfig [ 'shop' ] ) ) { $ pipelineConfig [ 'shop' ] = $ container -> getParameter ( 'ongr_connections.active_shop' ) ; } $ serviceConfig = $ this -> prepareServiceConfigs ( $ container , $ pipelineConfig , $ pipelineName ) ; $ this -> createServices ( $ container , $ pipelineConfig [ 'provide_sources' ] , $ serviceConfig , "data_sync.{$pipelineName}.source" , 'onSource' ) ; $ this -> createServices ( $ container , $ pipelineConfig [ 'provide_consumers' ] , $ serviceConfig , "data_sync.{$pipelineName}.consume" , 'onConsume' ) ; foreach ( $ pipelineConfig [ 'types' ] as $ type => $ typeConfig ) { $ typeServiceConfig = $ this -> prepareTypeServiceConfigs ( $ serviceConfig , $ typeConfig , $ type ) ; $ serviceList = $ this -> getServiceList ( $ pipelineName , $ type ) ; foreach ( $ serviceList as $ name => $ service ) { $ this -> createServices ( $ container , array_merge ( $ pipelineConfig [ $ name ] , $ typeConfig [ $ name ] ) , $ typeServiceConfig , $ service [ 'tag' ] , $ service [ 'method' ] ) ; } } } }
4684	public function setValueNormalization ( bool $ enabled = false ) { if ( $ enabled === true ) { $ this -> initColumnConversions ( ) ; } else { $ this -> toIntColumns = [ ] ; $ this -> toFloatColumns = [ ] ; $ this -> toStringColumns = [ ] ; $ this -> toBoolColumns = [ ] ; $ this -> toDateTimeColumns = [ ] ; $ this -> toDriverColumns = [ ] ; } }
10171	function fromXML ( $ xmlElement ) { foreach ( $ xmlElement -> children ( ) as $ field ) { $ this -> custom_fields [ trim ( $ field -> name ) ] = $ field -> type ; } }
12227	public function deleteSelf ( ) { $ tmp = dom_import_simplexml ( $ this ) ; if ( $ tmp -> isSameNode ( $ tmp -> ownerDocument -> documentElement ) ) { throw new BadMethodCallException ( 'deleteSelf() cannot be used to delete the root node' ) ; } $ tmp -> parentNode -> removeChild ( $ tmp ) ; }
11698	public function getService ( $ name ) { if ( array_key_exists ( $ name , $ this -> services ) ) { return $ this -> services [ $ name ] ; } throw new KeyNotFoundInSetException ( $ name , array_keys ( $ this -> services ) , 'services' ) ; }
4142	protected function getOauthString ( ) { $ oauth = array_merge ( $ this -> getOauthParameters ( ) , array ( 'oauth_signature' => $ this -> calculateSignature ( ) ) ) ; ksort ( $ oauth ) ; $ values = array ( ) ; foreach ( $ oauth as $ key => $ value ) { $ values [ ] = $ key . '="' . rawurlencode ( $ value ) . '"' ; } $ oauth = implode ( ', ' , $ values ) ; unset ( $ values , $ key , $ value ) ; return $ oauth ; }
10664	public function withRequest ( RequestInterface $ request ) { $ object = clone $ this ; $ object -> request = $ request ; $ object -> method = $ request -> getMethod ( ) ; return $ object ; }
7824	public function getHalfWidth ( $ up = false ) { $ number = $ this -> getTotalWidth ( ) ; return $ this -> roundHalf ( $ number , $ up ) ; }
4972	private function flattenTree ( $ tree , & $ data , $ curId = '1' ) { $ data [ ] = new \ ArrayObject ( [ 'id' => $ tree -> getId ( ) , 'current' => $ curId , 'name' => $ tree -> getName ( ) , 'value' => $ tree -> getValue ( ) , 'priority' => $ tree -> getPriority ( ) , 'do' => 'nothing' , ] ) ; if ( $ tree -> hasChildren ( ) ) { foreach ( $ tree -> getChildren ( ) as $ i => $ child ) { $ this -> flattenTree ( $ child , $ data , $ curId . '-' . ( $ i + 1 ) ) ; } } }
3389	public function redirectAfterRegistrationPath ( ) { if ( method_exists ( $ this , 'redirectAfterRegistrationTo' ) ) { return $ this -> redirectAfterRegistrationTo ( ) ; } return property_exists ( $ this , 'redirectAfterRegistrationTo' ) ? $ this -> redirectAfterRegistrationTo : route ( 'login' ) ; }
5316	public function toCollection ( ) { if ( function_exists ( $ this -> collectionFunction ) ) { return call_user_func ( $ this -> collectionFunction , $ this -> toArray ( ) ) ; } throw new \ Exception ( "Function {$this->collectionFunction}() was not found. " . "You probably need to install a suggested package?" ) ; }
5856	public function initializeRulesets ( array $ configuration ) { $ general = $ configuration ; $ general [ 'usergroup' ] = '' ; unset ( $ general [ 'rulesets' ] ) ; $ general = $ this -> expandValuesInRuleset ( $ general ) ; if ( $ general [ 'conversion_mapping' ] === '' ) { $ general [ 'conversion_mapping' ] = [ ] ; } if ( isset ( $ configuration [ 'rulesets' ] ) ) { $ rulesets = $ this -> compileRuleSets ( $ configuration [ 'rulesets' ] ) ; } else { $ rulesets = [ ] ; } foreach ( $ rulesets as $ k => & $ ruleset ) { foreach ( $ general as $ key => $ value ) { if ( ! isset ( $ ruleset [ $ key ] ) ) { $ ruleset [ $ key ] = $ value ; } elseif ( $ ruleset [ $ key ] === '' ) { $ ruleset [ $ key ] = $ value ; } } if ( count ( $ ruleset [ 'usergroup' ] ) == 0 ) { $ ruleset [ 'directories' ] = array_diff ( $ ruleset [ 'directories' ] , $ general [ 'directories' ] ) ; if ( count ( $ ruleset [ 'directories' ] ) == 0 ) { unset ( $ rulesets [ $ k ] ) ; } } } $ rulesets [ ] = $ general ; $ this -> rulesets = $ rulesets ; }
7489	public function insert ( $ offset , $ string ) { $ offset = ( int ) $ offset ; $ string = static :: convertString ( $ string , $ this -> encoding ) ; if ( $ offset < 0 || $ offset >= $ this -> length ( ) ) { throw new \ OutOfBoundsException ( ) ; } $ this -> string = mb_substr ( $ this -> string , 0 , $ offset , $ this -> encoding ) . $ string . mb_substr ( $ this -> string , $ offset , $ this -> length ( ) , $ this -> encoding ) ; return $ this ; }
5978	public function objecttypes ( ) { if ( ! $ this -> objecttypes instanceof ObjecttypesController ) { $ this -> objecttypes = new ObjecttypesController ( $ this -> getClient ( ) , $ this -> cachePolicy , $ this -> cache ) ; $ this -> objecttypes -> setLogger ( $ this -> logger ) ; } return $ this -> objecttypes ; }
868	private function isInConditionWithoutBraces ( Tokens $ tokens , $ index , $ lowerLimitIndex ) { do { if ( $ tokens [ $ index ] -> isComment ( ) || $ tokens [ $ index ] -> isWhitespace ( ) ) { $ index = $ tokens -> getPrevMeaningfulToken ( $ index ) ; } $ token = $ tokens [ $ index ] ; if ( $ token -> isGivenKind ( [ T_IF , T_ELSEIF , T_ELSE ] ) ) { return true ; } if ( $ token -> equals ( ';' , '}' ) ) { return false ; } if ( $ token -> equals ( '{' ) ) { $ index = $ tokens -> getPrevMeaningfulToken ( $ index ) ; if ( $ tokens [ $ index ] -> isGivenKind ( T_DO ) ) { -- $ index ; continue ; } if ( ! $ tokens [ $ index ] -> equals ( ')' ) ) { return false ; } $ index = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ index ) ; $ index = $ tokens -> getPrevMeaningfulToken ( $ index ) ; if ( $ tokens [ $ index ] -> isGivenKind ( [ T_IF , T_ELSEIF ] ) ) { return false ; } } elseif ( $ token -> equals ( ')' ) ) { $ type = Tokens :: detectBlockType ( $ token ) ; $ index = $ tokens -> findBlockStart ( $ type [ 'type' ] , $ index ) ; $ index = $ tokens -> getPrevMeaningfulToken ( $ index ) ; } else { -- $ index ; } } while ( $ index > $ lowerLimitIndex ) ; return false ; }
3837	private function getBaseDefinition ( ) { $ this -> setLanguageStrings ( ) ; $ tableName = $ this -> getMetaModel ( ) -> getTableName ( ) ; $ definition = array ( ) ; if ( isset ( $ GLOBALS [ 'TL_DCA' ] [ $ tableName ] [ 'fields' ] [ $ this -> getColName ( ) ] ) ) { $ definition = $ GLOBALS [ 'TL_DCA' ] [ $ tableName ] [ 'fields' ] [ $ this -> getColName ( ) ] ; } return array_replace_recursive ( array ( 'label' => & $ GLOBALS [ 'TL_LANG' ] [ $ tableName ] [ $ this -> getColName ( ) ] , 'eval' => array ( ) ) , $ definition ) ; }
3253	public function clear ( ) { DB :: table ( Config :: get ( 'shop.item_table' ) ) -> where ( 'cart_id' , $ this -> attributes [ 'id' ] ) -> delete ( ) ; $ this -> resetCalculations ( ) ; return $ this ; }
12479	private function generateOptions ( $ folder , $ rootAlias ) { $ assetsPath = $ this -> configurationHandler -> uploadAssetsDir ( ) . '/' . $ folder ; if ( ! is_dir ( $ assetsPath ) ) { @ mkdir ( $ assetsPath ) ; } $ options = array ( 'locale' => '' , 'roots' => array ( array ( 'driver' => 'LocalFileSystem' , 'path' => $ assetsPath , 'URL' => $ this -> configurationHandler -> absoluteUploadAssetsDir ( ) . '/' . $ folder , 'accessControl' => 'access' , 'rootAlias' => $ rootAlias ) ) ) ; return $ options ; }
1215	public static function isEqual ( $ a , $ b ) { if ( $ a === $ b ) { return true ; } elseif ( $ a instanceof \ stdClass ) { return self :: isEqual ( ( array ) $ a , $ b ) ; } elseif ( $ b instanceof \ stdClass ) { return self :: isEqual ( $ a , ( array ) $ b ) ; } elseif ( $ a instanceof JmesPathableArrayInterface ) { return Utils :: isEqual ( iterator_to_array ( $ a ) , $ b ) ; } elseif ( $ b instanceof JmesPathableArrayInterface ) { return Utils :: isEqual ( $ a , iterator_to_array ( $ b ) ) ; } elseif ( $ a instanceof JmesPathableObjectInterface ) { return Utils :: isEqual ( $ a -> toArray ( ) , $ b ) ; } elseif ( $ b instanceof JmesPathableObjectInterface ) { return Utils :: isEqual ( $ a , $ b -> toArray ( ) ) ; } else { return false ; } }
3923	protected function getConnection ( ) { if ( null === $ this -> connection ) { @ trigger_error ( 'Connection is missing in class ' . static :: class . '. The automatic fallback will be dropped in MetaModels 3.0. Please use dependency injection' , E_USER_DEPRECATED ) ; return $ this -> connection = System :: getContainer ( ) -> get ( 'database_connection' ) ; } return $ this -> connection ; }
1321	private function request ( $ url , $ method , $ authorization , array $ postfields , $ json = false ) { $ options = $ this -> curlOptions ( ) ; $ options [ CURLOPT_URL ] = $ url ; $ options [ CURLOPT_HTTPHEADER ] = [ 'Accept: application/json' , $ authorization , 'Expect:' ] ; switch ( $ method ) { case 'GET' : break ; case 'POST' : $ options [ CURLOPT_POST ] = true ; if ( $ json ) { $ options [ CURLOPT_HTTPHEADER ] [ ] = 'Content-type: application/json' ; $ options [ CURLOPT_POSTFIELDS ] = json_encode ( $ postfields ) ; } else { $ options [ CURLOPT_POSTFIELDS ] = Util :: buildHttpQuery ( $ postfields ) ; } break ; case 'DELETE' : $ options [ CURLOPT_CUSTOMREQUEST ] = 'DELETE' ; break ; case 'PUT' : $ options [ CURLOPT_CUSTOMREQUEST ] = 'PUT' ; break ; } if ( in_array ( $ method , [ 'GET' , 'PUT' , 'DELETE' ] ) && ! empty ( $ postfields ) ) { $ options [ CURLOPT_URL ] .= '?' . Util :: buildHttpQuery ( $ postfields ) ; } $ curlHandle = curl_init ( ) ; curl_setopt_array ( $ curlHandle , $ options ) ; $ response = curl_exec ( $ curlHandle ) ; if ( curl_errno ( $ curlHandle ) > 0 ) { throw new TwitterOAuthException ( curl_error ( $ curlHandle ) , curl_errno ( $ curlHandle ) ) ; } $ this -> response -> setHttpCode ( curl_getinfo ( $ curlHandle , CURLINFO_HTTP_CODE ) ) ; $ parts = explode ( "\r\n\r\n" , $ response ) ; $ responseBody = array_pop ( $ parts ) ; $ responseHeader = array_pop ( $ parts ) ; $ this -> response -> setHeaders ( $ this -> parseHeaders ( $ responseHeader ) ) ; curl_close ( $ curlHandle ) ; return $ responseBody ; }
5354	public function getAuthenticationData ( $ method ) { if ( ! $ this -> supportsAuthentication ( $ method ) ) { return null ; } $ authentication = $ this -> getSupportedAuthentication ( ) ; return $ authentication [ $ method ] ; }
3574	protected function update ( $ key , $ value = null , $ group = null ) { if ( $ key instanceof Attribute ) { $ value = $ key -> getValue ( ) ; $ group = $ key -> getMetaGroup ( ) ; $ key = $ key -> getMetaKey ( ) ; } $ this -> get ( $ key ) -> setValue ( $ value ) ; $ this -> get ( $ key ) -> setMetaGroup ( $ group ) ; return $ this ; }
1805	public function getActiveGroups ( ) { $ arrGroups = array ( ) ; $ objGroup = Contao \ MemberGroupModel :: findAllActive ( ) ; if ( $ objGroup !== null ) { while ( $ objGroup -> next ( ) ) { $ arrGroups [ $ objGroup -> id ] = $ objGroup -> name ; } } return $ arrGroups ; }
9460	public function deleteTickets ( array $ tickets ) { $ ids = array ( ) ; foreach ( $ tickets as $ ticket ) { $ ids [ ] = $ ticket -> getId ( ) ; } return parent :: deleteByIds ( $ ids , 'tickets/destroy_many.json' ) ; }
9662	private static function getReaderTypeFromExtension ( $ filename ) { $ pathinfo = pathinfo ( $ filename ) ; if ( ! isset ( $ pathinfo [ 'extension' ] ) ) { return null ; } switch ( strtolower ( $ pathinfo [ 'extension' ] ) ) { case 'xlsx' : case 'xlsm' : case 'xltx' : case 'xltm' : return 'Xlsx' ; case 'xls' : case 'xlt' : return 'Xls' ; case 'ods' : case 'ots' : return 'Ods' ; case 'slk' : return 'Slk' ; case 'xml' : return 'Xml' ; case 'gnumeric' : return 'Gnumeric' ; case 'htm' : case 'html' : return 'Html' ; case 'csv' : return null ; default : return null ; } }
9498	public function saveEntity ( BaseEntity $ entity , $ endPoint = '' , $ extraData = null ) { $ end_point = strtolower ( $ endPoint ) ; if ( strpos ( $ end_point , 'http' ) !== 0 ) { $ end_point = $ this -> api -> getApiUrl ( ) . $ end_point ; } $ type = $ this -> getType ( ) ; $ className = explode ( '\\' , $ type ) ; $ baseName = strtolower ( end ( $ className ) ) ; $ method = $ entity -> getId ( ) ? 'put' : 'post' ; if ( $ method == 'post' ) { $ entity -> checkCreatable ( ) ; } $ changes = $ entity -> toArray ( true , $ extraData ) ; if ( empty ( $ changes ) ) { return null ; } $ request = $ this -> api -> $ method ( $ end_point , null , json_encode ( array ( $ baseName => $ changes ) ) ) ; $ response = $ this -> processRequest ( $ request ) ; $ result = $ response -> json ( ) ; if ( $ result && isset ( $ result [ $ baseName ] ) ) { $ changeResult = new ChangeResult ( ) ; $ t = new $ type ( ) ; $ this -> manage ( $ t ) ; $ t -> fromArray ( $ result [ $ baseName ] ) ; $ changeResult -> setItem ( $ t ) ; if ( isset ( $ result [ 'audit' ] ) ) { $ audit = new TicketAudit ( ) ; $ audit -> fromArray ( $ result [ 'audit' ] ) ; $ changeResult -> setAudit ( $ audit ) ; } return $ changeResult ; } return null ; }
2785	private function extractFail ( $ output ) { if ( preg_match ( '%##teamcity\[testFailed.*\]%' , $ output , $ matches ) ) { preg_match ( "/##teamcity\\[testFailed.*name='(.*)' message='(.*)' details='\\s*(.*)' flowId=.*/" , $ output , $ matches ) ; $ matches = $ this -> replaceEscapedChars ( $ matches ) ; $ fail = sprintf ( 'Test Name: %s' . PHP_EOL . 'Failure Message: %s' . PHP_EOL . 'Trace:' . PHP_EOL . '%s' , $ matches [ 1 ] , $ matches [ 2 ] , $ matches [ 3 ] ) ; return $ fail ; } return 'No failure output was detected by Humbug, but a failure was reported by PHPUnit.' ; }
2956	public function deviceClose ( ) { if ( $ this -> _dState !== SERIAL_DEVICE_OPENED ) { return true ; } if ( fclose ( $ this -> _dHandle ) ) { $ this -> _dHandle = null ; $ this -> _dState = SERIAL_DEVICE_SET ; return true ; } trigger_error ( "Unable to close the device" , E_USER_ERROR ) ; return false ; }
6202	public function methodFail ( $ errors = null ) { if ( $ errors === null ) { return $ this -> methodResult ( false ) ; } if ( ! is_array ( $ errors ) ) { $ errors = [ $ errors ] ; } return $ this -> methodResult ( false , [ 'errors' => $ errors ] ) ; }
2540	protected function makeSegmentNameForRequestElement ( $ elementType , $ element ) { $ elementName = '' ; $ sourceArray = [ 'Contact' => ElementManagementData :: SEGNAME_CONTACT_ELEMENT , 'FormOfPayment' => ElementManagementData :: SEGNAME_FORM_OF_PAYMENT , 'MiscellaneousRemark' => ElementManagementData :: SEGNAME_GENERAL_REMARK , 'ReceivedFrom' => ElementManagementData :: SEGNAME_RECEIVE_FROM , 'ServiceRequest' => ElementManagementData :: SEGNAME_SPECIAL_SERVICE_REQUEST , 'Ticketing' => ElementManagementData :: SEGNAME_TICKETING_ELEMENT , 'AccountingInfo' => ElementManagementData :: SEGNAME_ACCOUNTING_INFORMATION , 'Address' => null , 'FrequentFlyer' => ElementManagementData :: SEGNAME_SPECIAL_SERVICE_REQUEST , 'OtherServiceInfo' => ElementManagementData :: SEGNAME_OTHER_SERVICE_INFORMATION , 'ManualCommission' => ElementManagementData :: SEGNAME_COMMISSION , 'SeatRequest' => ElementManagementData :: SEGNAME_SEAT_REQUEST , 'TourCode' => ElementManagementData :: SEGNAME_TOUR_CODE , 'ManualIssuedTicket' => ElementManagementData :: SEGNAME_MANUAL_DOCUMENT_REGISTRATION_WITH_ET_NUMBER ] ; if ( array_key_exists ( $ elementType , $ sourceArray ) ) { $ elementName = $ sourceArray [ $ elementType ] ; if ( $ elementType === 'Address' ) { $ elementName = $ element -> type ; } } return $ elementName ; }
10509	public function attach ( \ SplObserver $ observer , $ eventName = Null , $ function = Null , $ order = Null ) { $ newEventAttach = new \ stdClass ( ) ; $ newEventAttach -> observer = $ observer ; $ newEventAttach -> function = $ function ; $ newEventAttach -> eventName = $ eventName ; $ newEventAttach -> order = $ order ; $ this -> _observers -> attach ( $ newEventAttach ) ; }
4751	public function getPriceByPlanCode ( string $ planCode ) : float { $ plan = $ this -> getPlan ( $ planCode ) ; return ( array_key_exists ( 'recurring_price' , $ plan ) ) ? $ plan [ 'recurring_price' ] : 0 ; }
7131	protected function updateTotals ( SupplierOrderInterface $ order ) { $ changed = false ; $ tax = $ this -> calculator -> calculatePaymentTax ( $ order ) ; if ( $ tax != $ order -> getTaxTotal ( ) ) { $ order -> setTaxTotal ( $ tax ) ; $ changed = true ; } $ payment = $ this -> calculator -> calculatePaymentTotal ( $ order ) ; if ( $ payment != $ order -> getPaymentTotal ( ) ) { $ order -> setPaymentTotal ( $ payment ) ; $ changed = true ; } if ( null !== $ order -> getCarrier ( ) ) { $ forwarder = $ this -> calculator -> calculateForwarderTotal ( $ order ) ; if ( $ forwarder != $ order -> getForwarderTotal ( ) ) { $ order -> setForwarderTotal ( $ forwarder ) ; $ changed = true ; } } else { if ( 0 != $ order -> getForwarderFee ( ) ) { $ order -> setForwarderFee ( 0 ) ; $ changed = true ; } if ( 0 != $ order -> getCustomsTax ( ) ) { $ order -> setCustomsTax ( 0 ) ; $ changed = true ; } if ( 0 != $ order -> getCustomsVat ( ) ) { $ order -> setCustomsVat ( 0 ) ; $ changed = true ; } if ( 0 != $ order -> getForwarderTotal ( ) ) { $ order -> setForwarderTotal ( 0 ) ; $ changed = true ; } if ( null !== $ order -> getForwarderDate ( ) ) { $ order -> setForwarderDate ( null ) ; $ changed = true ; } if ( null !== $ order -> getForwarderDueDate ( ) ) { $ order -> setForwarderDueDate ( null ) ; $ changed = true ; } } return $ changed ; }
9896	private function convertNumber ( $ num ) { if ( ( preg_match ( '/^\\d+$/' , $ num ) ) and ( $ num <= 65535 ) ) { return pack ( 'Cv' , $ this -> ptg [ 'ptgInt' ] , $ num ) ; } if ( BIFFwriter :: getByteOrder ( ) ) { $ num = strrev ( $ num ) ; } return pack ( 'Cd' , $ this -> ptg [ 'ptgNum' ] , $ num ) ; }
7361	protected function updateWeightTotal ( SaleInterface $ sale ) { $ weightTotal = $ this -> weightCalculator -> calculateSale ( $ sale ) ; if ( $ sale -> getWeightTotal ( ) != $ weightTotal ) { $ sale -> setWeightTotal ( $ weightTotal ) ; return true ; } return false ; }
4820	public function addField ( $ name , $ value ) { if ( ! array_key_exists ( $ name , $ this -> row ) ) { $ this -> row [ $ name ] = $ value ; } elseif ( is_array ( $ this -> row [ $ name ] ) ) { $ this -> row [ $ name ] [ ] = $ value ; } else { $ this -> row [ $ name ] = array ( $ this -> row [ $ name ] , $ value ) ; } $ this -> informChanges ( ) ; }
9002	public function column_time ( AbstractLog $ item ) { $ time = $ item -> get_time ( ) ; if ( empty ( $ time ) ) { echo '-' ; } else { echo $ time -> format ( get_option ( 'date_format' ) . ' ' . get_option ( 'time_format' ) ) ; } }
3925	public function decodeValue ( DecodePropertyValueForWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } if ( is_array ( $ event -> getValue ( ) ) ) { $ values = [ ] ; foreach ( $ event -> getValue ( ) as $ value ) { $ values [ ] = 'value_' . $ value ; } $ event -> setValue ( $ values ) ; } else { $ event -> setValue ( 'value_' . $ event -> getValue ( ) ) ; } }
