5973	public function events ( ) { if ( ! $ this -> events instanceof EventsController ) { $ this -> events = new EventsController ( $ this -> getClient ( ) , $ this -> cachePolicy , $ this -> cache ) ; $ this -> events -> setLogger ( $ this -> logger ) ; } return $ this -> events ; }
11349	public function setData ( $ data ) { $ data = $ this -> transformer -> encode ( $ data ) ; foreach ( $ this -> fields as $ field ) { if ( isset ( $ data [ $ field -> getName ( ) ] ) ) { $ field -> setData ( $ data [ $ field -> getName ( ) ] ) ; } } }
6195	protected function findControllerFiles ( ) { $ result = [ ] ; foreach ( $ this -> controllerDirs as $ dir ) { $ directoryIterator = new \ RecursiveDirectoryIterator ( $ dir ) ; $ iterator = new \ RecursiveIteratorIterator ( $ directoryIterator ) ; $ files = new \ RegexIterator ( $ iterator , '/\.php$/i' , \ RecursiveRegexIterator :: GET_MATCH ) ; foreach ( $ files as $ k => $ v ) { $ result [ $ k ] = filemtime ( $ k ) ; } } return $ result ; }
12084	public function getObject ( Entity $ subject ) { $ object = NULL ; $ mediaObjectURI = $ subject -> getObjectURI ( ) ; if ( ! empty ( $ mediaObjectURI ) ) : $ mediaSubject = new Object ( ) ; $ mediaObjectType = $ subject -> getObjectType ( ) ; if ( is_object ( $ mediaSubject ) && method_exists ( $ mediaSubject , "getArray" ) ) : $ object = $ mediaSubject :: getArray ( ) ; endif ; else : endif ; return $ object ; }
2240	public static function getTemplateGroup ( $ strPrefix ) { $ arrTemplates = array ( ) ; foreach ( TemplateLoader :: getPrefixedFiles ( $ strPrefix ) as $ strTemplate ) { $ arrTemplates [ $ strTemplate ] [ ] = 'root' ; } $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; $ arrCustomized = self :: braceGlob ( $ rootDir . '/templates/' . $ strPrefix . '*.html5' ) ; if ( \ is_array ( $ arrCustomized ) ) { foreach ( $ arrCustomized as $ strFile ) { $ strTemplate = basename ( $ strFile , strrchr ( $ strFile , '.' ) ) ; $ arrTemplates [ $ strTemplate ] [ ] = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'global' ] ; } } if ( $ strPrefix != 'be_' && $ strPrefix != 'mail_' ) { try { $ objTheme = ThemeModel :: findAll ( array ( 'order' => 'name' ) ) ; } catch ( \ Exception $ e ) { $ objTheme = null ; } if ( $ objTheme !== null ) { while ( $ objTheme -> next ( ) ) { if ( $ objTheme -> templates != '' ) { $ arrThemeTemplates = self :: braceGlob ( $ rootDir . '/' . $ objTheme -> templates . '/' . $ strPrefix . '*.html5' ) ; if ( \ is_array ( $ arrThemeTemplates ) ) { foreach ( $ arrThemeTemplates as $ strFile ) { $ strTemplate = basename ( $ strFile , strrchr ( $ strFile , '.' ) ) ; $ arrTemplates [ $ strTemplate ] [ ] = $ objTheme -> name ; } } } } } } foreach ( $ arrTemplates as $ k => $ v ) { $ v = array_filter ( $ v , function ( $ a ) { return $ a != 'root' ; } ) ; if ( empty ( $ v ) ) { $ arrTemplates [ $ k ] = $ k ; } else { $ arrTemplates [ $ k ] = $ k . ' (' . implode ( ', ' , $ v ) . ')' ; } } ksort ( $ arrTemplates ) ; return $ arrTemplates ; }
7110	protected function getTicketFromEvent ( ResourceEventInterface $ event ) { $ ticket = $ event -> getResource ( ) ; if ( ! $ ticket instanceof TicketInterface ) { throw new UnexpectedValueException ( "Expected instance of " . TicketInterface :: class ) ; } return $ ticket ; }
6704	public function baseURL ( $ httpverb , $ url , $ params ) { uksort ( $ params , 'strcmp' ) ; return strtoupper ( $ httpverb ) . '&' . rawurlencode ( $ url ) . '&' . rawurlencode ( http_build_query ( $ params ) ) ; }
1276	private function isMailInnovations ( ) { $ patterns = [ '/^MI\d{6}\d{1,22}$/' , '/^94071\d{17}$/' , '/^7\d{19}$/' , '/^93033\d{17}$/' , '/^M\d{9}$/' , '/^82\d{10}$/' , '/^EC\d{9}US$/' , '/^927\d{23}$/' , '/^927\d{19}$/' , '/^EA\d{9}US$/' , '/^CP\d{9}US$/' , '/^92055\d{17}$/' , '/^14\d{18}$/' , '/^92088\d{17}$/' , '/^RA\d{9}US$/' , '/^9202\d{16}US$/' , '/^23\d{16}US$/' , '/^94\d{20}$/' , '/^03\d{18}$/' ] ; foreach ( $ patterns as $ pattern ) { if ( preg_match ( $ pattern , $ this -> trackingNumber ) ) { return true ; } } return false ; }
12511	private function buildGroup ( $ group ) { if ( is_null ( $ group ) ) { $ group = [ 'filter' => [ 'is_to_all' => true , ] , ] ; } elseif ( is_array ( $ group ) ) { $ group = [ 'touser' => $ group , ] ; } else { $ group = [ 'filter' => [ 'is_to_all' => false , 'group_id' => $ group , ] , ] ; } return $ group ; }
7176	public static function extract ( $ array , array $ paths , $ default = null ) { $ found = array ( ) ; foreach ( $ paths as $ path ) { static :: set_path ( $ found , $ path , static :: path ( $ array , $ path , $ default ) ) ; } return $ found ; }
6013	public function listProtocols ( CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/deployment/protocols' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new Protocol ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
9072	private function runQuery ( array $ query , int $ limit ) : Result { $ query [ 'Limit' ] = $ limit + 1 ; $ result = $ this -> dynamoDbClient -> query ( $ query ) ; $ result [ 'Items' ] = array_slice ( $ result [ 'Items' ] , 0 , $ limit ) ; return $ result ; }
3305	public function getFixedFormat ( $ images , array $ options = [ ] ) { $ images = is_array ( $ images ) ? $ images [ 0 ] : $ images ; if ( FileConverter :: isUrl ( $ images ) ) { throw new RuntimeException ( "Aliyun ocr not support online picture." ) ; } if ( $ this -> simpleRequestBody ) { return [ 'image' => FileConverter :: toBase64Encode ( $ images ) , 'configure' => json_encode ( $ options , JSON_UNESCAPED_UNICODE ) ] ; } return [ 'inputs' => [ [ 'image' => [ 'dataType' => 50 , 'dataValue' => FileConverter :: toBase64Encode ( $ images ) ] , 'configure' => [ 'dataType' => 50 , 'dataValue' => json_encode ( $ options , JSON_UNESCAPED_UNICODE ) ] ] ] ] ; }
7787	public function setAccountClass ( $ accountClass ) { if ( ! is_callable ( $ accountClass ) && ! class_exists ( $ accountClass ) ) { throw new \ InvalidArgumentException ( '$accountClass must be a valid classname or a PHP callable' ) ; } $ this -> accountClass = $ accountClass ; return $ this ; }
11882	private function prepareFieldOptions ( CustomField $ customField , $ type ) { $ options = $ customField -> getOptions ( ) ; $ fieldOptions = array ( ) ; $ fieldOptions [ 'required' ] = False ; $ fieldOptions [ 'label' ] = $ this -> translatableStringHelper -> localize ( $ customField -> getName ( ) ) ; if ( $ options [ self :: MIN ] !== NULL ) { $ fieldOptions [ 'constraints' ] [ ] = new GreaterThanOrEqual ( array ( 'value' => $ options [ self :: MIN ] ) ) ; } if ( $ options [ self :: MAX ] !== NULL ) { $ fieldOptions [ 'constraints' ] [ ] = new LessThanOrEqual ( array ( 'value' => $ options [ self :: MAX ] ) ) ; } if ( $ type === 'number' ) { $ fieldOptions [ 'scale' ] = $ options [ self :: SCALE ] ; } if ( ! empty ( $ options [ self :: POST_TEXT ] ) ) { $ fieldOptions [ 'post_text' ] = $ options [ self :: POST_TEXT ] ; } return $ fieldOptions ; }
9405	public function push ( $ middleware ) { if ( is_array ( $ middleware ) ) { $ this -> stack = array_merge ( $ this -> stack , $ middleware ) ; return $ this ; } $ this -> stack [ ] = $ middleware ; return $ this ; }
10614	public function createMigrateRepository ( array $ args ) { $ db = $ this -> app -> db ; $ repo = new Repository ( $ db ) ; $ resolver = $ this -> app -> resolver -> getResolver ( "migrations" ) ; $ mods = [ ] ; foreach ( $ resolver -> getSearchPath ( ) as $ name => $ path ) { $ module = new Module ( $ name , $ path , $ db ) ; if ( $ name === "wedeto.db" ) array_unshift ( $ mods , $ module ) ; else array_push ( $ mods , $ module ) ; } foreach ( $ mods as $ module ) $ repo -> addModule ( $ module ) ; return $ repo ; }
3870	protected function getView ( $ identifier , $ view ) { $ metaModels = $ this -> getMetaModel ( $ identifier , false ) ; return $ metaModels -> getView ( $ view ) ; }
12275	private function getTemplatePath ( $ template ) { if ( strpos ( $ template , '@' ) === false && ! empty ( $ this -> defaultNamespace ) ) { $ template .= '@' . $ this -> defaultNamespace ; } $ map = $ this -> buildTemplatesMap ( ) ; if ( ! array_key_exists ( $ template , $ map ) ) { throw new \ RuntimeException ( "A template by the name '$template' does not exist. The following templates are available: " . join ( ', ' , array_keys ( $ map ) ) ) ; } return $ map [ $ template ] ; }
3527	private function fetch ( ) { $ data = FortniteClient :: sendFortnitePostRequest ( FortniteClient :: FORTNITE_API . 'game/v2/profile/' . $ this -> account_id . '/client/QueryProfile?profileId=athena&rvn=-1' , $ this -> access_token , new \ StdClass ( ) ) ; return $ data -> profileChanges [ 0 ] -> profile ; }
3638	public function env ( Output $ output ) : void { $ info = [ 'OS' => \ PHP_OS , 'Php version' => \ PHP_VERSION , 'Swoole version' => \ SWOOLE_VERSION , 'Swoft version' => \ Swoft :: VERSION , 'App Name' => \ config ( 'name' , 'unknown' ) , 'Base Path' => \ BASE_PATH , ] ; Show :: aList ( $ info , 'System Environment Info' ) ; }
9798	public function setHyperlink ( Hyperlink $ pHyperlink = null ) { if ( ! isset ( $ this -> parent ) ) { throw new Exception ( 'Cannot set hyperlink for cell that is not bound to a worksheet' ) ; } $ this -> getWorksheet ( ) -> setHyperlink ( $ this -> getCoordinate ( ) , $ pHyperlink ) ; return $ this -> updateInCollection ( ) ; }
4408	public function onKernelController ( FilterControllerEvent $ event ) { if ( $ event -> getRequestType ( ) !== HttpKernelInterface :: MASTER_REQUEST ) { return ; } if ( ! $ this -> isAdminSiteAccess ) { return ; } $ currentRoute = $ event -> getRequest ( ) -> attributes -> get ( '_route' ) ; foreach ( $ this -> legacyRoutes as $ legacyRoute ) { if ( stripos ( $ currentRoute , $ legacyRoute ) === 0 ) { $ event -> getRequest ( ) -> attributes -> set ( '_controller' , 'ezpublish_legacy.controller:indexAction' ) ; $ event -> setController ( $ this -> controllerResolver -> getController ( $ event -> getRequest ( ) ) ) ; return ; } } }
11524	public function parseBotUA ( $ botName ) { $ dom = $ this -> getDom ( 'https://udger.com/resources/ua-list/bot-detail?bot=' . $ botName ) ; if ( false === $ dom ) { echo "Can not parse DOM" . PHP_EOL ; return false ; } $ this -> currentBotName = $ botName ; $ crawlerBot = new Crawler ( ) ; $ crawlerBot -> addContent ( $ dom ) ; $ crawlerBot -> filter ( 'body #container table tr td > a' ) -> each ( function ( $ el , $ i ) { if ( strpos ( $ el -> attr ( 'href' ) , '/resources/online-parser' ) !== false ) { $ botUA = $ el -> text ( ) ; $ this -> addBotUA ( $ botUA ) ; } } ) ; return true ; }
774	protected function extractMessages ( $ fileName , $ translator , $ ignoreCategories = [ ] ) { $ this -> stdout ( 'Extracting messages from ' ) ; $ this -> stdout ( $ fileName , Console :: FG_CYAN ) ; $ this -> stdout ( "...\n" ) ; $ subject = file_get_contents ( $ fileName ) ; $ messages = [ ] ; $ tokens = token_get_all ( $ subject ) ; foreach ( ( array ) $ translator as $ currentTranslator ) { $ translatorTokens = token_get_all ( '<?php ' . $ currentTranslator ) ; array_shift ( $ translatorTokens ) ; $ messages = array_merge_recursive ( $ messages , $ this -> extractMessagesFromTokens ( $ tokens , $ translatorTokens , $ ignoreCategories ) ) ; } $ this -> stdout ( "\n" ) ; return $ messages ; }
1957	public function generate ( ) { if ( $ this -> vimeo == '' ) { return '' ; } if ( TL_MODE == 'BE' ) { $ return = '<p><a href="https://vimeo.com/' . $ this -> vimeo . '" target="_blank" rel="noreferrer noopener">vimeo.com/' . $ this -> vimeo . '</a></p>' ; if ( $ this -> headline != '' ) { $ return = '<' . $ this -> hl . '>' . $ this -> headline . '</' . $ this -> hl . '>' . $ return ; } return $ return ; } return parent :: generate ( ) ; }
8927	public function fetch ( $ name ) { $ generator = false ; if ( array_key_exists ( $ name , $ this -> generators ) ) { $ generator = $ this -> generators [ $ name ] ; } return $ generator ; }
6459	public function fillInWithValueOfFieldOfCurrentUser ( $ field , $ user_field ) { if ( ! empty ( $ this -> user ) && ! $ this -> user -> uid ) { throw new \ Exception ( 'Anonymous user have no fields' ) ; } $ entity = new EntityDrupalWrapper ( 'user' ) ; $ wrapper = $ entity -> wrapper ( $ this -> user -> uid ) ; $ user_field = $ entity -> getFieldNameByLocator ( $ user_field ) ; if ( empty ( $ wrapper -> { $ user_field } ) ) { throw new \ InvalidArgumentException ( sprintf ( 'User entity has no "%s" field.' , $ user_field ) ) ; } $ value = $ wrapper -> { $ user_field } -> value ( ) ; if ( empty ( $ value ) ) { throw new \ UnexpectedValueException ( 'The value of "%s" field is empty.' , $ user_field ) ; } $ this -> fillField ( $ field , $ value ) ; }
11362	public static function mailTagger ( $ mail = '' , $ name = null ) { return ( ( ! is_int ( $ name ) ? "\"" . $ name . "\" <" : '' ) . $ mail . ( ! is_int ( $ name ) ? ">" : '' ) ) ; }
3473	public function set ( string $ key , $ value ) : void { $ key = explode ( '.' , $ key ) ; $ last = array_pop ( $ key ) ; $ result = & $ this -> config ; foreach ( $ key as $ part ) { if ( ! isset ( $ result [ $ part ] ) || ! is_array ( $ result [ $ part ] ) ) { $ result [ $ part ] = [ ] ; } $ result = & $ result [ $ part ] ; } $ result [ $ last ] = $ value ; }
6196	public function isActive ( string $ url ) { if ( $ this -> makeUrl ( $ url , true ) === str_replace ( $ this -> uri , '' , $ _SERVER [ 'REQUEST_URI' ] ) ) { return true ; } return false ; }
9450	protected function pathExtract ( ) : array { $ regExp = [ ] ; $ path = $ this -> path ; if ( \ is_array ( $ this -> path ) ) { $ regExp = \ array_pop ( $ this -> path ) ; $ path = \ array_pop ( $ this -> path ) ; } return [ $ path , $ regExp ] ; }
12548	public function getThemePlugin ( $ name ) { if ( ! array_key_exists ( $ name , $ this -> themes ) ) { return null ; } return $ this -> themes [ $ name ] ; }
10377	protected static function prepare_files ( $ type ) { $ params [ 'type' ] = $ type ; $ params [ 'routes' ] = self :: get_routes_to_folder ( $ type ) ; self :: get_processed_files ( ) ; foreach ( self :: $ data [ $ type ] as $ id => $ file ) { $ path = self :: get_path_from_url ( $ file [ 'url' ] ) ; $ params [ 'files' ] [ $ id ] = basename ( $ file [ 'url' ] ) ; $ params [ 'urls' ] [ $ id ] = $ file [ 'url' ] ; $ params [ 'paths' ] [ $ id ] = $ path ; if ( is_file ( $ path ) && self :: is_modified_file ( $ path ) ) { unset ( $ params [ 'urls' ] [ $ id ] ) ; continue ; } $ path = $ params [ 'routes' ] [ 'path' ] . $ params [ 'files' ] [ $ id ] ; if ( is_file ( $ path ) ) { if ( self :: is_modified_hash ( $ file [ 'url' ] , $ path ) ) { continue ; } $ params [ 'paths' ] [ $ id ] = $ path ; } elseif ( self :: is_external_url ( $ file [ 'url' ] ) ) { continue ; } unset ( $ params [ 'urls' ] [ $ id ] ) ; } return $ params ; }
4490	public function createTopic ( string $ name ) : string { $ res = $ this -> sns -> createTopic ( [ 'Name' => $ name , ] ) ; return $ res [ 'TopicArn' ] ; }
4718	public function processStandardUrl ( Text $ text ) { $ hashes = array ( ) ; $ text -> replace ( '{<code>.*?</code>}m' , function ( Text $ w ) use ( & $ hashes ) { $ md5 = md5 ( $ w ) ; $ hashes [ $ md5 ] = $ w ; return "{gfm-extraction-$md5}" ; } ) ; $ text -> replace ( '{(?<!]\(|"|<|\[)((?:https?|ftp)://[^\'">\s]+)(?!>|\"|\])}' , '<\1>' ) ; $ text -> replace ( '/\{gfm-extraction-([0-9a-f]{32})\}/m' , function ( Text $ w , Text $ md5 ) use ( & $ hashes ) { return $ hashes [ ( string ) $ md5 ] ; } ) ; }
2804	public function searchAction ( ) { $ requests = $ this -> _getFilteredRequests ( ) ; $ this -> loadLayout ( 'sheep_debug' ) ; $ rootBlock = $ this -> getLayout ( ) -> getBlock ( 'root' ) ; $ rootBlock -> setHeaderTitle ( $ this -> __ ( 'Request profiles' ) ) ; $ profileListBlock = $ this -> getLayout ( ) -> getBlock ( 'sheep_debug_list' ) ; $ profileListBlock -> setData ( 'results' , $ requests ) ; $ this -> renderLayout ( ) ; }
5552	public function getResponseCode ( ) { if ( is_integer ( $ this -> focus ) ) { return $ this -> frames [ $ this -> focus ] -> getResponseCode ( ) ; } return $ this -> frameset -> getResponseCode ( ) ; }
8569	public function setSKUPrepInstructions ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'SKUPrepInstructions' ] [ 'FieldValue' ] = $ value ; return $ this ; }
2996	public function set ( $ key , $ val ) { $ this -> smtp -> set ( $ key , $ this -> encode ( $ val ) ) ; }
6123	public function login ( $ username , $ password ) { $ this -> execute ( "login" , array ( "client_login_name" => $ username , "client_login_password" => $ password ) ) ; $ this -> whoamiReset ( ) ; $ crypt = new Crypt ( $ username ) ; $ this -> setStorage ( "_login_user" , $ username ) ; $ this -> setStorage ( "_login_pass" , $ crypt -> encrypt ( $ password ) ) ; Signal :: getInstance ( ) -> emit ( "notifyLogin" , $ this ) ; }
8860	public function onBeforePublish ( ) { if ( $ this -> dbObject ( 'PublishDate' ) -> InPast ( ) && ! $ this -> isPublished ( ) ) { $ this -> setCastedField ( "PublishDate" , time ( ) ) ; $ this -> write ( ) ; } }
6713	public function getParameter ( $ key , $ default = null ) { if ( array_key_exists ( $ key , $ this -> parameters ) ) { return $ this -> parameters [ $ key ] ; } $ flatKey = $ this -> flatten ( $ key ) ; foreach ( $ this -> parameters as $ index => $ value ) { if ( $ flatKey == $ this -> flatten ( $ index ) ) { return $ value ; } } return $ default ; }
11764	protected function handleStage ( & $ stages , $ stage ) { if ( $ stage instanceof Pipeline ) { $ stages = array_merge ( $ stages , $ stage -> stages ( ) ) ; } elseif ( $ stage instanceof MiddlewareInterface ) { $ stages [ ] = $ stage ; } elseif ( $ stage instanceof RequestHandlerInterface ) { $ stages [ ] = new RequestHandler ( $ stage ) ; } elseif ( is_callable ( $ stage ) ) { $ stages [ ] = new Lambda ( $ stage ) ; } else { throw new InvalidMiddlewareArgument ( is_string ( $ stage ) ? $ stage : get_class ( $ stage ) ) ; } }
1474	public function createResourceValidator ( ResourceObject $ resource , array $ rules , array $ messages = [ ] , array $ customAttributes = [ ] ) { return $ this -> createValidator ( $ resource -> all ( ) , $ rules , $ messages , $ customAttributes , function ( $ key , $ detail , $ failed ) use ( $ resource ) { return $ this -> invalidResource ( $ resource -> pointer ( $ key , '/data' ) , $ detail , $ failed ) ; } ) ; }
12095	public function shortText ( $ text , $ length ) { $ text = trim ( $ text ) ; $ charset = mb_detect_encoding ( $ text ) ; if ( mb_strlen ( $ text , $ charset ) > $ length ) { $ text = mb_substr ( $ text , 0 , $ length , $ charset ) . '...' ; } else { $ text = $ text ; } return $ text ; }
8974	public function setOutputFormat ( $ format ) { $ output = array ( 'xml' , 'html' , 'text' , 'text-main' ) ; if ( ! in_array ( $ format , $ output ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Available output format: %s' , implode ( ', ' , $ output ) ) ) ; } $ this -> outputFormat = $ format ; return $ this ; }
5924	public function setFilterItems ( array $ filterItems ) { $ this -> filterItems = [ ] ; foreach ( $ filterItems as $ item ) { $ this -> addFilterItem ( $ item ) ; } return $ this ; }
6375	public function first ( ) : Optional { try { return Optional :: ofNullable ( $ this -> get ( 0 ) ) ; } catch ( OutOfBoundsException $ e ) { return Optional :: absent ( ) ; } }
1794	private function getAutoItems ( array $ parameters ) : array { if ( isset ( $ parameters [ 'auto_item' ] ) ) { return [ $ parameters [ 'auto_item' ] ] ; } if ( isset ( $ GLOBALS [ 'TL_AUTO_ITEM' ] ) && \ is_array ( $ GLOBALS [ 'TL_AUTO_ITEM' ] ) ) { return $ GLOBALS [ 'TL_AUTO_ITEM' ] ; } return [ ] ; }
2364	public static function generateAlias ( $ strString ) { $ strString = static :: decodeEntities ( $ strString ) ; $ strString = static :: restoreBasicEntities ( $ strString ) ; $ strString = static :: standardize ( strip_tags ( $ strString ) ) ; if ( strncmp ( $ strString , 'id-' , 3 ) === 0 && ! is_numeric ( $ strSubstr = substr ( $ strString , 3 ) ) ) { $ strString = $ strSubstr ; } return $ strString ; }
825	public function setName ( $ name ) { $ current = $ this -> getName ( ) ; if ( 'other' === $ current ) { throw new \ RuntimeException ( 'Cannot set name on unknown tag.' ) ; } $ this -> line -> setContent ( Preg :: replace ( "/@{$current}/" , "@{$name}" , $ this -> line -> getContent ( ) , 1 ) ) ; $ this -> name = $ name ; }
8630	public function setGetLowestOfferListingsForASINResult ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'GetLowestOfferListingsForASINResult' ] [ 'FieldValue' ] = $ value ; return $ this ; }
12052	public function getRelationModelField ( ) { $ field = $ this -> model -> tabularPrefix ; if ( $ this -> modelField -> relationship -> companionRole ( $ this -> modelField -> modelRole ) === 'child' ) { $ field .= 'child_object_id' ; } else { $ field .= 'parent_object_id' ; } return $ field ; }
8134	public function renderBlock ( $ name , $ context = array ( ) ) { $ context = $ this -> env -> mergeGlobals ( $ context ) ; $ level = ob_get_level ( ) ; ob_start ( ) ; try { $ this -> template -> displayBlock ( $ name , $ context ) ; } catch ( Exception $ e ) { while ( ob_get_level ( ) > $ level ) { ob_end_clean ( ) ; } throw $ e ; } catch ( Throwable $ e ) { while ( ob_get_level ( ) > $ level ) { ob_end_clean ( ) ; } throw $ e ; } return ob_get_clean ( ) ; }
7508	function setWhitespace ( $ ws ) { if ( is_array ( $ ws ) ) { $ this -> whitespace = array_fill_keys ( array_values ( $ ws ) , true ) ; $ this -> buildCharMap ( ) ; } else { $ this -> setWhiteSpace ( str_split ( $ ws ) ) ; } }
12208	public function getSingleWidget ( ) { if ( is_null ( $ this -> _singleWidget ) ) { $ this -> _singleWidget = false ; $ widgets = $ this -> collectorItem -> getAll ( ) ; if ( ! empty ( $ widgets ) ) { $ widget = array_shift ( $ widgets ) ; $ this -> _singleWidget = Yii :: $ app -> collectors [ 'widgets' ] -> build ( $ this , $ widget -> object ) ; } } return $ this -> _singleWidget ; }
7234	protected function assertItemClass ( Common \ SaleItemInterface $ child ) { if ( ! $ child instanceof Model \ CartItemInterface ) { throw new InvalidArgumentException ( "Expected instance of " . Model \ CartItemInterface :: class ) ; } }
6994	public function prePersist ( UploadableInterface $ uploadable ) { if ( ! $ this -> enabled ) { return ; } $ uploadable -> setCreatedAt ( new \ DateTime ( ) ) -> setUpdatedAt ( new \ DateTime ( ) ) ; $ this -> uploader -> prepare ( $ uploadable ) ; }
5083	protected function lookUpResource ( $ aData = [ ] , $ iSegment = 4 ) { $ oUri = Factory :: service ( 'Uri' ) ; $ sIdentifier = $ oUri -> segment ( $ iSegment ) ; $ oInput = Factory :: service ( 'Input' ) ; $ aData = array_merge ( static :: CONFIG_LOOKUP_DATA , $ aData ) ; $ aExpansions = array_filter ( ( array ) $ oInput -> get ( 'expand' ) ) ; if ( $ aExpansions ) { if ( ! array_key_exists ( 'expand' , $ aData ) ) { $ aData [ 'expand' ] = [ ] ; } $ aData [ 'expand' ] = array_merge ( $ aData [ 'expand' ] , $ aExpansions ) ; } switch ( static :: CONFIG_LOOKUP_METHOD ) { case 'ID' : return $ this -> oModel -> getById ( $ sIdentifier , $ aData ) ; break ; case 'SLUG' : return $ this -> oModel -> getBySlug ( $ sIdentifier , $ aData ) ; break ; case 'TOKEN' : return $ this -> oModel -> getByToken ( $ sIdentifier , $ aData ) ; break ; } }
12327	protected function getParam ( $ param ) { if ( isset ( $ _POST [ $ param ] ) ) { return $ _POST [ $ param ] ; } elseif ( isset ( $ _GET [ $ param ] ) ) { return $ _GET [ $ param ] ; } return ; }
2719	private function isHostInDomainList ( $ host ) { $ urlTypes = [ UrlInterface :: URL_TYPE_LINK , UrlInterface :: URL_TYPE_DIRECT_LINK , UrlInterface :: URL_TYPE_WEB , UrlInterface :: URL_TYPE_MEDIA , UrlInterface :: URL_TYPE_STATIC ] ; $ secureScheme = [ true , false ] ; foreach ( $ this -> storeManager -> getStores ( ) as $ store ) { foreach ( $ urlTypes as $ urlType ) { foreach ( $ secureScheme as $ scheme ) { $ shopHost = \ Zend_Uri :: factory ( $ store -> getBaseUrl ( $ urlType , $ scheme ) ) -> getHost ( ) ; if ( $ host === $ shopHost ) { return true ; } } } } return false ; }
11937	protected function find ( $ params ) { $ debug = false ; $ q = new Query ( ) ; $ q -> select ( '*' ) ; $ q -> from ( $ this -> _tableName ) ; foreach ( $ params as $ k => $ v ) { if ( $ k === 'join' ) { foreach ( $ v as $ join ) { if ( ! isset ( $ join [ 'type' ] ) ) { $ join [ 'type' ] = 'INNER JOIN' ; } if ( ! isset ( $ join [ 'params' ] ) ) { $ join [ 'params' ] = [ ] ; } $ q -> join ( $ join [ 'type' ] , $ join [ 'table' ] , $ join [ 'on' ] , $ join [ 'params' ] ) ; } $ debug = true ; } elseif ( in_array ( $ k , [ 'where' ] ) ) { $ q -> { $ k } ( $ v ) ; } else { $ q -> { $ k } = $ v ; } } if ( $ debug ) { } return $ q ; }
7094	private function loadItem ( Model \ SaleItemInterface $ item ) { $ item -> getAdjustments ( ) -> toArray ( ) ; $ children = $ item -> getChildren ( ) -> toArray ( ) ; foreach ( $ children as $ child ) { $ this -> loadItem ( $ child ) ; } }
9540	private function getParameterClosure ( $ parameter ) { $ parameterClosure = null ; foreach ( array_keys ( $ this -> parameterCluster -> prefixes ) as $ prefix ) { if ( substr ( $ parameter , 0 , strlen ( $ prefix ) ) == $ prefix ) { @ $ parameterClosure = $ this -> parameterCluster -> prefixes [ $ prefix ] [ substr ( $ parameter , strlen ( $ prefix ) , strlen ( $ parameter ) - strlen ( $ prefix ) ) ] ; } } return $ parameterClosure ; }
1894	public function generate ( ) { if ( $ this -> singleSRC == '' ) { return '' ; } $ objFile = FilesModel :: findByUuid ( $ this -> singleSRC ) ; if ( $ objFile === null || ! is_file ( System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) . '/' . $ objFile -> path ) ) { return '' ; } $ this -> singleSRC = $ objFile -> path ; $ this -> objFilesModel = $ objFile ; return parent :: generate ( ) ; }
6672	public function restart_all_ratings ( ) { $ nonce = isset ( $ _POST [ 'nonce' ] ) ? $ _POST [ 'nonce' ] : '' ; if ( ! wp_verify_nonce ( $ nonce , 'eliasis' ) && ! wp_verify_nonce ( $ nonce , 'customRatingGrifusAdmin' ) ) { die ( 'Busted!' ) ; } $ response [ 'ratings_restarted' ] = 0 ; $ posts = $ this -> model -> get_posts ( ) ; foreach ( $ posts as $ post ) { if ( isset ( $ post -> ID ) && ! $ this -> model -> get_movie_votes ( $ post -> ID ) ) { $ this -> set_rating_and_votes ( $ post -> ID , $ this -> get_default_votes ( $ post -> ID ) ) ; $ response [ 'ratings_restarted' ] ++ ; } } echo json_encode ( $ response ) ; die ( ) ; }
7066	public function getUserRights ( ) { if ( ! $ this -> _UserRights ) { if ( Configure :: load ( 'user_rights' ) === false ) { trigger_error ( 'UserRights: Could not load config/user_rights.php' , E_USER_WARNING ) ; } $ rightsConfig = Configure :: read ( 'user_rights' ) ; if ( ! is_array ( $ rightsConfig ) ) { $ rightsConfig = [ ] ; } $ this -> _UserRights = new UserRights ( $ rightsConfig ) ; } return $ this -> _UserRights ; }
6532	protected function buildParams ( SmsGatewayMessage $ message , $ to ) { $ optionalFields = array_filter ( [ 'expires_at' => data_get ( $ message , 'expiresAt' ) , 'send_at' => data_get ( $ message , 'sendAt' ) , ] ) ; return array_merge ( [ 'number' => $ to , 'message' => trim ( $ message -> content ) , ] , $ optionalFields ) ; }
388	public function getAttributeOrder ( $ attribute ) { $ orders = $ this -> getAttributeOrders ( ) ; return isset ( $ orders [ $ attribute ] ) ? $ orders [ $ attribute ] : null ; }
5931	public function setDefinition ( $ definition ) { if ( is_array ( $ definition ) ) { $ this -> definition = $ definition ; return $ this ; } $ this -> definition = json_decode ( $ definition , true ) ; if ( null === $ this -> definition ) { $ this -> definition = $ definition ; } return $ this ; }
2060	public function scheduleUpdate ( Contao \ DataContainer $ dc ) { if ( ! $ dc -> activeRecord || ! $ dc -> activeRecord -> id || Contao \ Input :: get ( 'act' ) == 'copy' ) { return ; } $ objSession = Contao \ System :: getContainer ( ) -> get ( 'session' ) ; $ session = $ objSession -> get ( 'sitemap_updater' ) ; $ session [ ] = Contao \ PageModel :: findWithDetails ( $ dc -> activeRecord -> id ) -> rootId ; $ objSession -> set ( 'sitemap_updater' , array_unique ( $ session ) ) ; }
11007	public function requireSriFor ( bool $ script , bool $ style ) : void { if ( $ script && $ style ) { $ this -> tags [ 'require-sri-for' ] = [ 'script' , 'style' ] ; } else if ( $ script ) { $ this -> tags [ 'require-sri-for' ] = [ 'script' ] ; } else if ( $ style ) { $ this -> tags [ 'require-sri-for' ] = [ 'style' ] ; } }
6918	public function hasAdjustments ( $ type = null ) { if ( null !== $ type ) { AdjustmentTypes :: isValidType ( $ type ) ; return $ this -> getAdjustments ( $ type ) -> count ( ) ; } return 0 < $ this -> adjustments -> count ( ) ; }
1573	public function getProcessIdentifier ( ) : ? ResourceIdentifierInterface { if ( ! $ id = $ this -> getProcessId ( ) ) { return null ; } return ResourceIdentifier :: create ( $ this -> getProcessType ( ) , $ id ) ; }
815	private function fixAnnotation ( DocBlock $ doc , Annotation $ annotation ) { $ types = $ annotation -> getNormalizedTypes ( ) ; if ( 1 === \ count ( $ types ) && ( 'null' === $ types [ 0 ] || 'void' === $ types [ 0 ] ) ) { $ annotation -> remove ( ) ; } }
1112	public function mapTree ( $ nodeList ) { $ tree = $ nodeList instanceof ArrayableInterface ? $ nodeList -> toArray ( ) : $ nodeList ; $ affectedKeys = array ( ) ; $ result = $ this -> mapTreeRecursive ( $ tree , $ this -> node -> getKey ( ) , $ affectedKeys ) ; if ( $ result && count ( $ affectedKeys ) > 0 ) $ this -> deleteUnaffected ( $ affectedKeys ) ; return $ result ; }
3179	public function getQtiItems ( \ core_kernel_classes_Class $ itemClass , $ format = 'list' , $ search = '' , $ offset = 0 , $ limit = 30 ) { $ propertyFilters = [ ] ; if ( $ this -> hasOption ( self :: ITEM_MODEL_SEARCH_OPTION ) && $ this -> getOption ( self :: ITEM_MODEL_SEARCH_OPTION ) !== false ) { $ propertyFilters [ self :: PROPERTY_ITEM_MODEL_URI ] = $ this -> getOption ( self :: ITEM_MODEL_SEARCH_OPTION ) ; } if ( $ this -> hasOption ( self :: ITEM_CONTENT_SEARCH_OPTION ) && $ this -> getOption ( self :: ITEM_MODEL_SEARCH_OPTION ) !== false ) { $ propertyFilters [ self :: PROPERTY_ITEM_CONTENT_URI ] = '*' ; } if ( is_string ( $ search ) && strlen ( trim ( $ search ) ) > 0 ) { $ propertyFilters [ self :: LABEL_URI ] = $ search ; } if ( is_array ( $ search ) ) { foreach ( $ search as $ uri => $ value ) { if ( is_string ( $ uri ) && ( is_string ( $ value ) && strlen ( trim ( $ value ) ) > 0 ) || ( is_array ( $ value ) && count ( $ value ) > 0 ) ) { $ propertyFilters [ $ uri ] = $ value ; } } } $ result = [ ] ; if ( in_array ( $ format , self :: $ formats ) ) { $ itemLookup = $ this -> getServiceLocator ( ) -> get ( self :: SERVICE_ID . '/' . $ format ) ; if ( ! is_null ( $ itemLookup ) && $ itemLookup instanceof ItemLookup ) { $ result = $ itemLookup -> getItems ( $ itemClass , $ propertyFilters , $ offset , $ limit ) ; } } return $ result ; }
8274	public function assertUsername ( $ username , $ config ) { if ( ! is_string ( $ username ) ) { throw new ConfigurationException ( "Username $username must be a string." ) ; } $ len = strlen ( $ username ) ; $ minLen = $ config [ "registration" ] [ "nameLenMin" ] ; $ maxLen = $ config [ "registration" ] [ "nameLenMax" ] ; if ( $ len < $ minLen || $ len > $ maxLen ) { throw new ConfigurationException ( sprintf ( "Length of a username $username must be between %d-%d characters." , $ minLen , $ maxLen ) ) ; } if ( ! $ this -> checkValidNameFormat ( $ username ) ) { throw new ConfigurationException ( "Username $username contains invalid character/s." ) ; } }
12205	public function generate ( $ date = 'global' , Response $ response = null ) { if ( ! $ response ) $ response = new Response ; if ( $ this -> maxAge ) $ response -> setMaxAge ( $ this -> maxAge ) ; if ( $ this -> sharedMaxAge ) $ response -> setSharedMaxAge ( $ this -> sharedMaxAge ) ; if ( $ date instanceof \ DateTime ) { $ response -> setLastModified ( $ date ) ; } else { $ response -> setLastModified ( $ this -> manager -> getLastUpdate ( $ date ) ) ; } return $ response ; }
7365	protected function resolveOutstandingDate ( SaleInterface $ sale ) { if ( ! $ sale instanceof InvoiceSubjectInterface ) { return null ; } if ( ! $ sale instanceof ShipmentSubjectInterface ) { return null ; } if ( null === $ term = $ sale -> getPaymentTerm ( ) ) { return null ; } if ( ! $ this -> saleHasOutstandingPayments ( $ sale ) ) { return null ; } $ from = null ; switch ( $ term -> getTrigger ( ) ) { case PaymentTermTriggers :: TRIGGER_SHIPPED : $ from = $ sale -> getShippedAt ( ) ; break ; case PaymentTermTriggers :: TRIGGER_FULLY_SHIPPED : if ( $ sale -> getShipmentState ( ) === ShipmentStates :: STATE_COMPLETED ) { $ from = $ sale -> getShippedAt ( true ) ; } break ; case PaymentTermTriggers :: TRIGGER_INVOICED : $ from = $ sale -> getInvoicedAt ( ) ; break ; case PaymentTermTriggers :: TRIGGER_FULLY_INVOICED : if ( $ sale -> getInvoiceState ( ) === InvoiceStates :: STATE_COMPLETED ) { $ from = $ sale -> getInvoicedAt ( true ) ; } break ; } if ( null === $ from ) { return null ; } $ date = clone $ from ; $ date -> setTime ( 23 , 59 , 59 ) ; $ date -> modify ( sprintf ( '+%s days' , $ term -> getDays ( ) ) ) ; if ( $ term -> getEndOfMonth ( ) ) { $ date -> modify ( 'last day of this month' ) ; } return $ date ; }
11893	private function createEditForm ( CustomField $ entity , $ type ) { $ form = $ this -> createForm ( 'custom_field_choice' , $ entity , array ( 'action' => $ this -> generateUrl ( 'customfield_update' , array ( 'id' => $ entity -> getId ( ) ) ) , 'method' => 'PUT' , 'type' => $ type , 'group_widget' => 'hidden' ) ) ; $ form -> add ( 'submit' , 'submit' , array ( 'label' => 'Update' ) ) ; return $ form ; }
11431	protected function get ( $ path , array $ parameters = array ( ) , $ requestHeaders = array ( ) ) { if ( array_key_exists ( 'ref' , $ parameters ) && is_null ( $ parameters [ 'ref' ] ) ) { unset ( $ parameters [ 'ref' ] ) ; } $ response = $ this -> client -> getHttpClient ( ) -> get ( $ path , $ parameters , $ requestHeaders ) ; return ResponseMediator :: getContent ( $ response ) ; }
549	public static function dumpAsString ( $ var , $ depth = 10 , $ highlight = false ) { self :: $ _output = '' ; self :: $ _objects = [ ] ; self :: $ _depth = $ depth ; self :: dumpInternal ( $ var , 0 ) ; if ( $ highlight ) { $ result = highlight_string ( "<?php\n" . self :: $ _output , true ) ; self :: $ _output = preg_replace ( '/&lt;\\?php<br \\/>/' , '' , $ result , 1 ) ; } return self :: $ _output ; }
6638	protected function initContainer ( $ module ) { $ map = [ ] ; $ defaultClassMap = [ 'AddPermissionForm' => AddPermissionForm :: class , 'AssignRoleForm' => AssignRoleForm :: class , 'LoginForm' => LoginForm :: class , 'RequestPasswordResetForm' => RequestPasswordResetForm :: class , 'ResetPasswordForm' => ResetPasswordForm :: class , 'AuthAssignment' => AuthAssignment :: class , 'AuthItem' => AuthItem :: class , 'AuthItemChild' => AuthItemChild :: class , 'AuthRule' => AuthRule :: class , 'Message' => Message :: class , 'SourceMessage' => SourceMessage :: class , 'User' => User :: class , 'MessageQuery' => MessageQuery :: class , 'SourceMessageQuery' => SourceMessageQuery :: class , 'UserQuery' => UserQuery :: class , 'SourceMessageSearch' => SourceMessageSearch :: class , 'UserSearch' => UserSearch :: class , ] ; $ routes = [ 'mrstroz\\wavecms\\forms' => [ 'AddPermissionForm' , 'AssignRoleForm' , 'LoginForm' , 'RequestPasswordResetForm' , 'ResetPasswordForm' , ] , 'mrstroz\\wavecms\\models' => [ 'AuthAssignment' , 'AuthItem' , 'AuthItemChild' , 'AuthRule' , 'Message' , 'SourceMessage' , 'User' , ] , 'mrstroz\\wavecms\\models\\query' => [ 'MessageQuery' , 'SourceMessageQuery' , 'UserQuery' , ] , 'mrstroz\\wavecms\\models\\search' => [ 'SourceMessageSearch' , 'UserSearch' , ] ] ; $ mapping = array_merge ( $ defaultClassMap , $ module -> classMap ) ; foreach ( $ mapping as $ name => $ definition ) { $ map [ $ this -> getContainerRoute ( $ routes , $ name ) . "\\$name" ] = $ definition ; } $ di = Yii :: $ container ; foreach ( $ map as $ class => $ definition ) { if ( ! $ di -> has ( $ class ) ) { $ di -> set ( $ class , $ definition ) ; } } }
5078	public function getSearch ( $ aData = [ ] ) { $ oInput = Factory :: service ( 'Input' ) ; $ oHttpCodes = Factory :: service ( 'HttpCodes' ) ; $ oItemModel = Factory :: model ( static :: CONFIG_MODEL_NAME , static :: CONFIG_MODEL_PROVIDER ) ; $ sKeywords = $ oInput -> get ( 'search' ) ? : $ oInput -> get ( 'keywords' ) ; $ iPage = ( int ) $ oInput -> get ( 'page' ) ; if ( strlen ( $ sKeywords ) < static :: CONFIG_MIN_SEARCH_LENGTH ) { throw new ApiException ( 'Search term must be ' . static :: CONFIG_MIN_SEARCH_LENGTH . ' characters or longer.' , $ oHttpCodes :: STATUS_BAD_REQUEST ) ; } $ oResult = $ oItemModel -> search ( $ sKeywords , $ iPage , static :: CONFIG_MAX_ITEMS_PER_PAGE , $ aData ) ; $ oResponse = Factory :: factory ( 'ApiResponse' , 'nails/module-api' ) ; $ oResponse -> setData ( array_map ( [ $ this , 'formatObject' ] , $ oResult -> data ) ) ; return $ oResponse ; }
5019	public function getFieldOptions ( $ field ) { if ( ! $ this -> hasField ( $ field ) ) { return [ ] ; } if ( ! isset ( $ this -> fields [ $ field ] [ '__options__' ] ) ) { $ this -> fields [ $ field ] [ '__options__' ] = $ this -> copyArrayValues ( $ this -> fields [ $ field ] , [ 'attributes' , 'options' , 'label' => 'options' , 'required' => [ 'key' => [ 'attributes' , '*' ] , 'value' => 'required' , 'if' => true ] , 'type' , ] ) ; } return $ this -> fields [ $ field ] [ '__options__' ] ; }
11448	public function actionOne ( $ option = null ) { $ fixtures = Yii :: createObject ( Fixtures :: className ( ) ) ; $ option = Question :: displayWithQuit ( 'Select operation' , [ 'Export' , 'Import' ] , $ option ) ; if ( $ option == 'e' ) { $ table = Enter :: display ( 'Enter table name for export' ) ; $ tables = $ fixtures -> export ( [ $ table ] ) ; Output :: items ( $ tables , 'Exported tables' ) ; } elseif ( $ option == 'i' ) { $ table = Enter :: display ( 'Enter table name for import' ) ; $ tables = $ fixtures -> import ( [ $ table ] ) ; Output :: items ( $ tables , 'Imported tables' ) ; } }
4827	public static function find ( $ id ) { $ endpoint = self :: $ endpoint . '/' . $ id ; return new self ( GoCardless :: $ client , GoCardless :: $ client -> request ( 'get' , $ endpoint ) ) ; }
872	private static function wordwrap ( $ string , $ width ) { $ result = [ ] ; $ currentLine = 0 ; $ lineLength = 0 ; foreach ( explode ( ' ' , $ string ) as $ word ) { $ wordLength = \ strlen ( Preg :: replace ( '~</?(\w+)>~' , '' , $ word ) ) ; if ( 0 !== $ lineLength ) { ++ $ wordLength ; } if ( $ lineLength + $ wordLength > $ width ) { ++ $ currentLine ; $ lineLength = 0 ; } $ result [ $ currentLine ] [ ] = $ word ; $ lineLength += $ wordLength ; } return array_map ( static function ( $ line ) { return implode ( ' ' , $ line ) ; } , $ result ) ; }
151	public function createCommand ( $ db = null ) { if ( $ db === null ) { $ db = Yii :: $ app -> getDb ( ) ; } list ( $ sql , $ params ) = $ db -> getQueryBuilder ( ) -> build ( $ this ) ; $ command = $ db -> createCommand ( $ sql , $ params ) ; $ this -> setCommandCache ( $ command ) ; return $ command ; }
4593	public static function replace ( string $ string , array $ data = [ ] ) : string { $ expressionLanguage = new ExpressionLanguage ; preg_match_all ( '/\%([a-z0-9_\[\]\"\.]+)\%/i' , $ string , $ matches ) ; $ placeholders = array_unique ( $ matches [ 1 ] ) ; $ translations = [ ] ; foreach ( $ placeholders as $ placeholder ) { $ translations [ '%' . $ placeholder . '%' ] = $ expressionLanguage -> evaluate ( $ placeholder , $ data ) ; } $ string = strtr ( $ string , $ translations ) ; return $ string ; }
8528	public function listFinancialEventGroupsByNextToken ( $ request ) { if ( ! ( $ request instanceof MWSFinancesService_Model_ListFinancialEventGroupsByNextTokenRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/ListFinancialEventGroupsByNextTokenRequest.php' ) ; $ request = new MWSFinancesService_Model_ListFinancialEventGroupsByNextTokenRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListFinancialEventGroupsByNextToken' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/ListFinancialEventGroupsByNextTokenResponse.php' ) ; $ response = MWSFinancesService_Model_ListFinancialEventGroupsByNextTokenResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
2853	public function purgeAllProfiles ( ) { $ table = Mage :: getResourceModel ( 'sheep_debug/requestInfo' ) -> getMainTable ( ) ; $ deleteSql = "DELETE FROM {$table}" ; $ connection = Mage :: getSingleton ( 'core/resource' ) -> getConnection ( 'core_write' ) ; $ result = $ connection -> query ( $ deleteSql ) ; return $ result -> rowCount ( ) ; }
9144	public static function generate ( $ length = 8 , $ allowed = RandomString :: ASCII , $ repeatable = true ) : string { $ allowedChars = array ( ) ; $ currentLocale = setlocale ( LC_ALL , "0" ) ; if ( $ allowed == RandomString :: ASCII ) { setlocale ( LC_ALL , "C" ) ; } for ( $ i = 32 ; $ i < 256 ; $ i ++ ) { if ( ( $ allowed == RandomString :: ASCII && ! ctype_alnum ( chr ( $ i ) ) ) || ( ! ctype_print ( chr ( $ i ) ) ) ) { continue ; } $ allowedChars [ ] = $ i ; } self :: resetLocaleTo ( $ currentLocale ) ; $ used = array ( ) ; $ string = "" ; $ i = $ length ; while ( $ i > 0 ) { $ index = mt_rand ( 0 , count ( $ allowedChars ) - 1 ) ; if ( ! $ repeatable && in_array ( $ index , $ used ) ) { continue ; } $ string .= chr ( $ allowedChars [ $ index ] ) ; $ used [ ] = $ i ; $ i -- ; } return $ string ; }
3539	public static function getAdldapProvider ( ) { if ( static :: getExtensionOptions ( 'adldap-providername' ) != '__USE_DEFAULT_PROVIDER__' ) { $ provider = Yii :: $ app -> ad -> getProvider ( static :: getExtensionOptions ( 'adldap-providername' ) ) ; } else { $ provider = Yii :: $ app -> ad -> getDefaultProvider ( ) ; } return $ provider ; }
1807	public function storeDateAdded ( $ dc ) { if ( ! $ dc instanceof Contao \ DataContainer ) { return ; } if ( ! $ dc -> activeRecord || $ dc -> activeRecord -> dateAdded > 0 ) { return ; } if ( $ dc -> activeRecord -> lastLogin > 0 ) { $ time = $ dc -> activeRecord -> lastLogin ; } else { $ time = time ( ) ; } $ this -> Database -> prepare ( "UPDATE tl_member SET dateAdded=? WHERE id=?" ) -> execute ( $ time , $ dc -> id ) ; }
4289	public function processLogEntry ( $ method , $ args = array ( ) , $ meta = array ( ) ) { $ meta = \ array_merge ( array ( 'format' => 'raw' , 'requestId' => $ this -> requestId , ) , $ meta ) ; if ( $ meta [ 'channel' ] == $ this -> debug -> getCfg ( 'channel' ) ) { unset ( $ meta [ 'channel' ] ) ; } if ( $ meta [ 'format' ] == 'raw' ) { $ args = $ this -> crateValues ( $ args ) ; } if ( ! empty ( $ meta [ 'backtrace' ] ) ) { $ meta [ 'backtrace' ] = $ this -> crateValues ( $ meta [ 'backtrace' ] ) ; } $ this -> wamp -> publish ( $ this -> topic , array ( $ method , $ args , $ meta ) ) ; }
8299	public function addRule ( $ url , $ rule ) { if ( ! is_string ( $ url ) || ! is_array ( $ rule ) ) { throw new \ InvalidArgumentException ( "addRule() expects a string and an array." ) ; } $ this -> runtimeRules [ $ url ] = $ rule ; }
2278	public function setPagesFlags ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ dc -> activeRecord && $ dc -> activeRecord -> type == 'search' ) { $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'fields' ] [ $ dc -> field ] [ 'eval' ] [ 'mandatory' ] = false ; unset ( $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'fields' ] [ $ dc -> field ] [ 'eval' ] [ 'orderField' ] ) ; } return $ varValue ; }
2008	private function loadLanguageFile ( string $ name ) : void { $ system = $ this -> framework -> getAdapter ( System :: class ) ; $ system -> loadLanguageFile ( $ name ) ; }
515	public function actionTo ( $ version ) { if ( ( $ namespaceVersion = $ this -> extractNamespaceMigrationVersion ( $ version ) ) !== false ) { $ this -> migrateToVersion ( $ namespaceVersion ) ; } elseif ( ( $ migrationName = $ this -> extractMigrationVersion ( $ version ) ) !== false ) { $ this -> migrateToVersion ( $ migrationName ) ; } elseif ( ( string ) ( int ) $ version == $ version ) { $ this -> migrateToTime ( $ version ) ; } elseif ( ( $ time = strtotime ( $ version ) ) !== false ) { $ this -> migrateToTime ( $ time ) ; } else { throw new Exception ( "The version argument must be either a timestamp (e.g. 101129_185401),\n the full name of a migration (e.g. m101129_185401_create_user_table),\n the full namespaced name of a migration (e.g. app\\migrations\\M101129185401CreateUserTable),\n a UNIX timestamp (e.g. 1392853000), or a datetime string parseable\nby the strtotime() function (e.g. 2014-02-15 13:00:50)." ) ; } }
2140	private function fetchHttpHeaders ( ) : void { $ this -> headers = array_merge ( $ this -> headers , $ this -> headerStorage -> all ( ) ) ; $ this -> headerStorage -> clear ( ) ; }
12794	public function delete ( $ id ) { try { $ response = $ this -> client -> request -> delete ( $ this -> apiEndpoint . "/droplets/$id" ) ; $ status = $ this -> client -> getStatus ( $ response ) ; if ( 204 != $ status ) { throw new Exception ( 'Digital Ocean responded that it could not delete it.' ) ; } return $ status ; } catch ( Exception $ e ) { echo 'Unable to delete server because ' . $ e -> getMessage ( ) ; } }
2265	public function fieldExists ( $ strField , $ strTable , $ blnNoCache = false ) { if ( $ strField == '' || $ strTable == '' ) { return false ; } foreach ( $ this -> listFields ( $ strTable , $ blnNoCache ) as $ arrField ) { if ( $ arrField [ 'name' ] == $ strField && $ arrField [ 'type' ] != 'index' ) { return true ; } } return false ; }
11828	public function setUri ( $ uri ) { if ( ! empty ( $ uri ) && ! is_file ( $ uri ) ) { throw new \ Exception ( sprintf ( 'File %s not found.' , $ uri ) ) ; } $ this -> uri = $ uri ; return $ this ; }
10797	public function getCryptedPassword ( $ password ) { $ bcrypt = new Bcrypt ; $ bcrypt -> setCost ( $ this -> getOptions ( ) -> getPasswordCost ( ) ) ; return $ bcrypt -> create ( $ password ) ; }
9439	public function alias ( $ id , $ original ) { $ this -> instances [ $ id ] = $ this -> get ( $ original ) ; return $ this ; }
8637	public function setOrderFeeList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'OrderFeeList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
7035	protected function createMigrationTable ( ) { $ migrations = new Table ( "migrations" , true ) ; $ migrations -> string ( "host" ) -> notNullable ( ) -> primaryComposite ( ) ; $ migrations -> timestamp ( "created_at" ) -> notNullable ( ) -> primaryComposite ( true ) ; $ migrations -> blob ( "tables" ) ; try { return $ migrations -> create ( $ this -> dbName ) ; } catch ( PDOException $ e ) { error_log ( $ e -> getMessage ( ) ) ; return false ; } }
2365	public static function prepareSlug ( $ strSlug ) { $ strSlug = static :: stripInsertTags ( $ strSlug ) ; $ strSlug = static :: restoreBasicEntities ( $ strSlug ) ; $ strSlug = static :: decodeEntities ( $ strSlug ) ; return $ strSlug ; }
4372	public function onOutput ( Event $ event ) { $ this -> data = $ this -> debug -> getData ( ) ; $ this -> channels = array ( ) ; $ str = '<div' . $ this -> debug -> utilities -> buildAttribString ( array ( 'class' => 'debug' , 'data-channels' => '{{channels}}' , 'data-channel-root' => $ this -> channelNameRoot , ) ) . ">\n" ; if ( $ this -> debug -> getCfg ( 'output.outputCss' ) ) { $ str .= '<style type="text/css">' . "\n" . $ this -> debug -> output -> getCss ( ) . "\n" . '</style>' . "\n" ; } if ( $ this -> debug -> getCfg ( 'output.outputScript' ) ) { $ str .= '<script type="text/javascript">' . \ file_get_contents ( $ this -> debug -> getCfg ( 'filepathScript' ) ) . '</script>' . "\n" ; } $ str .= '<div class="debug-bar"><h3>Debug Log</h3></div>' . "\n" ; $ str .= $ this -> processAlerts ( ) ; if ( $ this -> debug -> getCfg ( 'output.outputScript' ) ) { $ str .= '<div class="loading">Loading <i class="fa fa-spinner fa-pulse fa-2x fa-fw" aria-hidden="true"></i></div>' . "\n" ; } $ str .= '<div class="debug-header m_group"' . ( $ this -> debug -> getCfg ( 'outputScript' ) ? ' style="display:none;"' : '' ) . '>' . "\n" ; $ str .= $ this -> processSummary ( ) ; $ str .= '</div>' . "\n" ; $ str .= '<div class="debug-content m_group"' . ( $ this -> debug -> getCfg ( 'outputScript' ) ? ' style="display:none;"' : '' ) . '>' . "\n" ; $ str .= $ this -> processLog ( ) ; $ str .= '</div>' . "\n" ; $ str .= '</div>' . "\n" ; $ str = \ strtr ( $ str , array ( '{{channels}}' => \ htmlspecialchars ( \ json_encode ( $ this -> buildChannelTree ( ) , JSON_FORCE_OBJECT ) ) , ) ) ; $ this -> data = array ( ) ; $ event [ 'return' ] .= $ str ; }
6570	public function getMessage ( ) { return '[' . $ this -> prefix . ( $ this -> context === null ? '' : ( ' - ' . get_class ( $ this -> context ) ) ) . '] ' . $ this -> msg ; }
8724	public function translations ( ) { $ localKey = $ this -> getKeyName ( ) ; $ foreignKey = $ this -> getForeignKey ( ) ; $ instance = $ this -> translationModel ( ) ; return new HasMany ( $ instance -> newQuery ( ) , $ this , $ instance -> getTable ( ) . '.' . $ foreignKey , $ localKey ) ; }
5609	public function paintGroupStart ( $ message , $ size ) { parent :: paintGroupStart ( $ message , $ size ) ; $ node = new TreemapNode ( 'Group' , $ message ) ; $ this -> _stack -> push ( $ node ) ; }
8666	public function setInvalidASIN ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'InvalidASIN' ] [ 'FieldValue' ] = $ value ; return $ this ; }
8636	public function setShipmentFeeAdjustmentList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ShipmentFeeAdjustmentList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
2186	public function fetch ( $ strTable , $ varKey , $ strAlias = null ) { $ strClass = Model :: getClassFromTable ( $ strTable ) ; $ strPk = $ strClass :: getPk ( ) ; if ( $ strAlias === null || $ strAlias == $ strPk ) { if ( isset ( $ this -> arrRegistry [ $ strTable ] [ $ varKey ] ) ) { return $ this -> arrRegistry [ $ strTable ] [ $ varKey ] ; } return null ; } return $ this -> fetchByAlias ( $ strTable , $ strAlias , $ varKey ) ; }
10750	protected function sendVerb ( string $ verb , Response $ response , string $ type , array $ ids , array $ extra = [ ] ) : Response { $ send = array_merge ( [ ] , $ extra ) ; $ send [ 'success' ] = true ; $ send [ 'message' ] = "Objects $verb successfully" ; $ send [ 'objects' ] = array_map ( function ( $ id ) use ( $ type ) { return [ 'type' => $ type , 'id' => $ id ] ; } , $ ids ) ; return $ this -> sendJson ( $ response , $ send ) ; }
3598	public function parserHttpRequest ( HttpRequest $ httpRequest ) { $ json = \ json_decode ( $ httpRequest -> getContent ( ) , true ) ; if ( JSON_ERROR_NONE !== \ json_last_error ( ) ) { throw new Exceptions \ ParseException ( ) ; } $ createJsonRequest = function ( $ json ) use ( $ httpRequest ) { $ id = null ; $ method = null ; $ params = [ ] ; if ( \ is_array ( $ json ) ) { $ id = \ array_key_exists ( 'id' , $ json ) ? $ json [ 'id' ] : null ; $ method = \ array_key_exists ( 'method' , $ json ) ? $ json [ 'method' ] : null ; $ params = \ array_key_exists ( 'params' , $ json ) ? $ json [ 'params' ] : [ ] ; } $ request = new JsonRequest ( $ method , $ params , $ id ) ; $ request -> headers ( ) -> add ( $ httpRequest -> headers -> all ( ) ) ; return $ request ; } ; if ( \ array_keys ( $ json ) === \ range ( 0 , \ count ( $ json ) - 1 ) ) { $ requests = [ ] ; foreach ( $ json as $ part ) { $ requests [ ] = $ createJsonRequest ( $ part ) ; } } else { $ requests = $ createJsonRequest ( $ json ) ; } return $ requests ; }
4955	public function listenToRenderer ( ) { if ( $ this -> ListenersUnaware ) { $ this -> ListenersUnaware = false ; $ view = $ this -> serviceManager -> get ( 'View' ) ; $ viewEvents = $ view -> getEventManager ( ) ; $ viewEvents -> attach ( ViewEvent :: EVENT_RESPONSE , array ( $ this , 'anounceAttachedFiles' ) , 1000 ) ; } }
9343	public function addRow ( array $ arr_row ) { if ( count ( $ this -> arr ) == $ this -> size -> rows ) { throw new \ OutOfRangeException ( sprintf ( 'You cannot add another row! Max number of rows is %d' , $ this -> size -> rows ) ) ; } if ( count ( $ arr_row ) != $ this -> size -> cols ) { throw new \ InvalidArgumentException ( 'New row must have same amout of columns than defined into the size matrix' ) ; } $ this -> arr [ ] = $ arr_row ; return $ this ; }
8015	protected function execute ( Command $ command ) { $ command -> setJar ( $ this -> getPathToPdfBox ( ) ) ; $ command -> setOptions ( $ this -> _options ) ; exec ( ( string ) $ command . ' 2>&1' , $ stdErr , $ exitCode ) ; if ( $ command -> getPdfFileIsTemp ( ) ) { unlink ( $ command -> getPdfFile ( ) ) ; } if ( $ exitCode > 0 ) { throw new \ RuntimeException ( join ( "\n" , $ stdErr ) , $ exitCode ) ; } $ resultFile = $ command -> getTextFile ( ) ; $ result = file_get_contents ( $ resultFile ) ; if ( $ command -> getTextFileIsTemp ( ) ) { unlink ( $ resultFile ) ; } return $ result ; }
9086	public function getName ( ) { if ( 0 === count ( $ this -> queue ) ) { return false ; } foreach ( $ this -> queue as $ detector ) { $ name = $ detector -> getName ( ) ; if ( empty ( $ name ) && $ name !== '0' ) { continue ; } $ this -> lastStrategyFound = $ detector ; return $ name ; } return false ; }
5145	public function _after ( \ Codeception \ TestCase $ test ) { if ( isset ( $ this -> config [ 'deleteEmailsAfterScenario' ] ) && $ this -> config [ 'deleteEmailsAfterScenario' ] ) { $ this -> deleteAllEmails ( ) ; } }
7928	public function unregisterNamespace ( $ ns ) { list ( $ ns ) = $ this -> fireEvent ( 'namespace.unregister' , [ $ ns ] ) ; unset ( $ this -> namespaces [ $ ns ] ) ; return $ this ; }
4586	protected function getSignature ( ) : string { $ request = $ this -> requestStack -> getCurrentRequest ( ) ; $ signature = substr ( md5 ( $ request -> server -> get ( 'HTTP_USER_AGENT' ) ) , 0 , $ this -> length ) ; return $ signature ; }
688	protected function removeAllItems ( $ type ) { if ( ! $ this -> supportsCascadeUpdate ( ) ) { $ names = ( new Query ( ) ) -> select ( [ 'name' ] ) -> from ( $ this -> itemTable ) -> where ( [ 'type' => $ type ] ) -> column ( $ this -> db ) ; if ( empty ( $ names ) ) { return ; } $ key = $ type == Item :: TYPE_PERMISSION ? 'child' : 'parent' ; $ this -> db -> createCommand ( ) -> delete ( $ this -> itemChildTable , [ $ key => $ names ] ) -> execute ( ) ; $ this -> db -> createCommand ( ) -> delete ( $ this -> assignmentTable , [ 'item_name' => $ names ] ) -> execute ( ) ; } $ this -> db -> createCommand ( ) -> delete ( $ this -> itemTable , [ 'type' => $ type ] ) -> execute ( ) ; $ this -> invalidateCache ( ) ; }
2702	public function beforeSave ( ) { $ value = $ this -> getValue ( ) ; $ file = $ this -> getFileData ( ) ; if ( ! empty ( $ file ) ) { $ uploadDir = $ this -> _getUploadDir ( ) ; try { $ uploader = $ this -> _uploaderFactory -> create ( [ 'fileId' => $ file ] ) ; $ uploader -> setAllowedExtensions ( $ this -> getAllowedExtensions ( ) ) ; $ uploader -> setAllowRenameFiles ( true ) ; $ uploader -> addValidateCallback ( 'size' , $ this , 'validateMaxSize' ) ; $ result = $ uploader -> save ( $ uploadDir ) ; } catch ( \ Exception $ e ) { throw new \ Magento \ Framework \ Exception \ LocalizedException ( __ ( '%1' , $ e -> getMessage ( ) ) ) ; } $ filename = $ result [ 'file' ] ; if ( $ filename ) { if ( $ this -> _addWhetherScopeInfo ( ) ) { $ filename = $ this -> _prependScopeInfo ( $ filename ) ; } $ this -> setValue ( $ filename ) ; } } else { if ( is_array ( $ value ) && ! empty ( $ value [ 'delete' ] ) ) { $ this -> setValue ( '' ) ; } elseif ( is_array ( $ value ) && ! empty ( $ value [ 'value' ] ) ) { $ this -> setValue ( $ value [ 'value' ] ) ; } else { $ this -> unsValue ( ) ; } } return $ this ; }
5819	private function createAlertsForType ( $ type , array $ messages ) { $ alerts = array ( ) ; foreach ( $ messages as $ msg ) { $ alerts [ ] = new Alert ( $ type , $ msg ) ; } return $ alerts ; }
921	private function fixAnnotations ( DocBlock $ doc ) { foreach ( $ doc -> getAnnotations ( ) as $ index => $ annotation ) { $ next = $ doc -> getAnnotation ( $ index + 1 ) ; if ( null === $ next ) { break ; } if ( true === $ next -> getTag ( ) -> valid ( ) ) { if ( TagComparator :: shouldBeTogether ( $ annotation -> getTag ( ) , $ next -> getTag ( ) ) ) { $ this -> ensureAreTogether ( $ doc , $ annotation , $ next ) ; } else { $ this -> ensureAreSeparate ( $ doc , $ annotation , $ next ) ; } } } return $ doc -> getContent ( ) ; }
1042	private function printBlockString ( $ value , $ isDescription ) { $ escaped = str_replace ( '"""' , '\\"""' , $ value ) ; return ( $ value [ 0 ] === ' ' || $ value [ 0 ] === "\t" ) && strpos ( $ value , "\n" ) === false ? ( '"""' . preg_replace ( '/"$/' , "\"\n" , $ escaped ) . '"""' ) : ( '"""' . "\n" . ( $ isDescription ? $ escaped : $ this -> indent ( $ escaped ) ) . "\n" . '"""' ) ; }
6547	public function close ( ) { $ writer = \ PHPExcel_IOFactory :: createWriter ( $ this -> container , $ this -> format ) ; $ writer -> save ( $ this -> resourcepath ) ; }
4563	public function preUpdate ( PreUpdateEventArgs $ args ) { $ entity = $ args -> getEntity ( ) ; if ( ! $ entity instanceof Parameter ) { return ; } $ entity -> setValue ( serialize ( $ entity -> getValue ( ) ) ) ; }
12461	private function createMakeDefaultForm ( CustomFieldsGroup $ group = null ) { return $ this -> createFormBuilder ( $ group , array ( 'method' => 'POST' , 'action' => $ this -> generateUrl ( 'customfieldsgroup_makedefault' ) ) ) -> add ( 'id' , 'hidden' ) -> add ( 'submit' , 'submit' , array ( 'label' => 'Make default' ) ) -> getForm ( ) ; }
9620	protected function httpPost ( $ host , $ path , array $ data , $ port = 80 ) { $ req = $ this -> qsencode ( $ data ) ; $ http_request = "POST {$path} HTTP/1.0\r\n" ; $ http_request .= "Host: {$host}\r\n" ; $ http_request .= "Content-Type: application/x-www-form-urlencoded;\r\n" ; $ http_request .= "Content-Length: " . strlen ( $ req ) . "\r\n" ; $ http_request .= "User-Agent: reCAPTCHA/PHP\r\n" ; $ http_request .= "\r\n" ; $ http_request .= $ req ; $ response = '' ; if ( false == ( $ fs = @ fsockopen ( $ host , ( int ) $ port , $ errno , $ errstr , 10 ) ) ) { throw new \ Exception ( 'Could not open socket' ) ; } fwrite ( $ fs , $ http_request ) ; while ( ! feof ( $ fs ) ) { $ response .= fgets ( $ fs , 1160 ) ; } fclose ( $ fs ) ; $ response = explode ( "\r\n\r\n" , $ response , 2 ) ; return $ response ; }
12949	public function afterSave ( ) { if ( $ this -> _tagsList === null ) { return ; } $ relation = $ this -> owner -> getRelation ( 'tagsList' , false ) ; if ( ! ( $ relation instanceof ActiveQuery ) ) { return ; } if ( ! $ this -> owner -> getIsNewRecord ( ) ) { $ this -> beforeDelete ( ) ; $ this -> afterDelete ( ) ; } $ relationClass = $ relation -> modelClass ; $ ownerTagsList = [ ] ; foreach ( $ this -> _tagsList as $ tagText ) { $ tag = $ relationClass :: findOne ( [ 'text' => $ tagText ] ) ; if ( $ tag === null ) { $ tag = new $ relationClass ( ) ; $ tag -> setAttribute ( 'text' , $ tagText ) ; } $ tag -> setAttribute ( 'count' , $ tag -> getAttribute ( 'count' ) + 1 ) ; if ( $ tag -> save ( ) ) { $ ownerTagsList [ ] = [ $ this -> owner -> getPrimaryKey ( ) , $ tag -> getPrimaryKey ( ) ] ; } } if ( ! empty ( $ ownerTagsList ) ) { $ this -> owner -> getDb ( ) -> createCommand ( ) -> batchInsert ( $ relation -> via -> from [ 0 ] , [ key ( $ relation -> via -> link ) , current ( $ relation -> link ) ] , $ ownerTagsList ) -> execute ( ) ; } }
7518	function parse_comment ( ) { $ this -> pos += 3 ; if ( $ this -> next_pos ( ' , false ) !== self :: TOK_UNKNOWN ) { $ this -> status [ 'comment' ] = $ this -> getTokenString ( 1 , - 1 ) ; -- $ this -> pos ; } else { $ this -> status [ 'comment' ] = $ this -> getTokenString ( 1 , - 1 ) ; $ this -> pos += 2 ; } $ this -> status [ 'last_pos' ] = $ this -> pos ; return true ; }
1297	private function resolveFieldLinks ( $ field , string $ locale = null ) { if ( null === $ locale ) { $ locale = null === $ this -> sys -> getLocale ( ) ? '*' : $ this -> getLocale ( ) ; } if ( $ field instanceof Link ) { return $ this -> client -> resolveLink ( $ field , $ locale ) ; } if ( \ is_array ( $ field ) && isset ( $ field [ 0 ] ) && $ field [ 0 ] instanceof Link ) { return $ this -> client -> resolveLinkCollection ( $ field , $ locale ) ; } return $ field ; }
7702	function OpenDoc_GetDraw ( $ Tag , $ Txt , $ Pos , $ Forward , $ LevelStop ) { return $ this -> XML_BlockAlias_Prefix ( 'draw:' , $ Txt , $ Pos , $ Forward , $ LevelStop ) ; }
6026	public function setMimetype ( $ mimetype ) { if ( $ mimetype instanceof MimeType ) { $ this -> mimetype = $ mimetype ; } elseif ( is_array ( $ mimetype ) ) { $ this -> mimetype = new MimeType ( $ mimetype ) ; } else { $ this -> mimetype = null ; trigger_error ( 'Argument must be an object of class MimeType. Data loss!' , E_USER_WARNING ) ; } return $ this ; }
8830	protected function getSelectedValue ( $ value , $ selected ) { if ( is_array ( $ selected ) ) { return in_array ( $ value , $ selected , true ) ? 'selected' : null ; } return ( ( string ) $ value == ( string ) $ selected ) ? 'selected' : null ; }
6972	private function buildEntity ( ClassMetadata $ metadata , $ data ) { $ class = $ metadata -> getName ( ) ; $ entity = new $ class ; foreach ( $ data as $ propertyPath => $ value ) { if ( $ metadata -> hasField ( $ propertyPath ) ) { $ builtValue = $ this -> buildFieldValue ( $ metadata , $ propertyPath , $ value ) ; } elseif ( $ metadata -> hasAssociation ( $ propertyPath ) ) { $ builtValue = $ this -> buildAssociationValue ( $ metadata , $ propertyPath , $ value ) ; } else { throw new \ Exception ( "Unexpected property path '$propertyPath' for class '$class'." ) ; } $ this -> accessor -> setValue ( $ entity , $ propertyPath , $ builtValue ) ; } return $ entity ; }
6269	private function nameFromAcademicDomain ( $ domain ) { $ path = $ this -> getPath ( $ domain ) ; if ( ! file_exists ( $ path ) ) { return null ; } return trim ( file_get_contents ( $ path ) ) ; }
12396	public function where ( $ field , $ operator = null , $ value = null , $ logical = '&&' ) { if ( $ field instanceof Closure ) { $ this -> scope -> where .= $ this -> scope -> where == '' ? ' (' : $ logical . ' (' ; call_user_func ( $ field , $ this ) ; $ this -> scope -> where .= ') ' ; } else { $ logical = ( strlen ( $ this -> scope -> where ) <= 1 || substr ( $ this -> scope -> where , - 1 ) == '(' ) ? '' : $ logical ; $ this -> scope -> where .= Parser :: where ( $ field , $ operator , $ value , $ logical ) ; } return $ this ; }
1825	public function setRow ( array $ arrData ) { foreach ( $ arrData as $ k => $ v ) { if ( strpos ( $ k , '__' ) !== false ) { unset ( $ arrData [ $ k ] ) ; } } $ this -> arrData = $ arrData ; return $ this ; }
7092	protected function add ( $ url , $ method , Callable $ action ) { $ url = $ this -> base !== "" && $ url === "/" ? $ this -> base : $ this -> base . $ url ; $ route = new Route ( $ url , $ method , $ action ) ; $ this -> routes [ ] = $ route ; return $ route ; }
3375	public function open ( $ file ) { if ( strlen ( $ file ) >= 1 && $ file [ 0 ] == '@' ) { try { if ( $ this -> fileLocator instanceof FileLocatorInterface ) { $ file = $ this -> fileLocator -> locate ( $ file ) ; } else { $ this -> fileLocator -> locateResource ( $ file ) ; } } catch ( \ InvalidArgumentException $ exception ) { if ( $ this -> throwException || false == $ this -> fallbackImage ) { throw $ exception ; } $ file = $ this -> fallbackImage ; } } return $ this -> createInstance ( $ file ) ; }
3911	protected function fetchAdditionalData ( ) { $ this -> modifiedTime = array ( ) ; $ this -> outputBuffer = array ( ) ; if ( ! $ this -> foundFiles ) { return ; } foreach ( $ this -> foundFiles as $ strFile ) { $ this -> processFile ( $ strFile ) ; } }
4790	function insert_update ( array $ unique , array $ insert , array $ update = array ( ) ) { if ( ! $ update ) { $ update = $ insert ; } $ insert = $ unique + $ insert ; $ values = "(" . implode ( ", " , array_keys ( $ insert ) ) . ") VALUES " . $ this -> quote ( $ insert ) ; if ( $ this -> notORM -> driver == "mysql" ) { $ set = array ( ) ; if ( ! $ update ) { $ update = $ unique ; } $ quoteChar = $ this -> getQuoteChar ( ) ; foreach ( $ update as $ key => $ val ) { $ set [ ] = "{$quoteChar}{$key}{$quoteChar} = " . $ this -> quote ( $ val ) ; } return $ this -> insert ( "$values ON DUPLICATE KEY UPDATE " . implode ( ", " , $ set ) ) ; } else { $ connection = $ this -> notORM -> connection ; $ errorMode = $ connection -> getAttribute ( PDO :: ATTR_ERRMODE ) ; $ connection -> setAttribute ( PDO :: ATTR_ERRMODE , PDO :: ERRMODE_EXCEPTION ) ; try { $ return = $ this -> insert ( $ values ) ; $ connection -> setAttribute ( PDO :: ATTR_ERRMODE , $ errorMode ) ; return $ return ; } catch ( PDOException $ e ) { $ connection -> setAttribute ( PDO :: ATTR_ERRMODE , $ errorMode ) ; if ( $ e -> getCode ( ) == "23000" || $ e -> getCode ( ) == "23505" ) { if ( ! $ update ) { return 0 ; } $ clone = clone $ this ; $ return = $ clone -> where ( $ unique ) -> update ( $ update ) ; return ( $ return ? $ return + 1 : $ return ) ; } if ( $ errorMode == PDO :: ERRMODE_EXCEPTION ) { throw $ e ; } elseif ( $ errorMode == PDO :: ERRMODE_WARNING ) { trigger_error ( "PDOStatement::execute(): " . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } } return 0 ; }
6537	public function registerAssetFiles ( $ view ) { if ( \ Yii :: $ app -> request -> isPjax ) { return parent :: registerAssetFiles ( $ view ) ; } parent :: registerAssetFiles ( $ view ) ; }
9304	public function setFailureLogLifetime ( $ time ) { if ( ! is_numeric ( $ time ) ) { throw new \ InvalidArgumentException ( '`failureLogLifetime` expects integer value!' ) ; } $ this -> options [ 'failureLogLifetime' ] = ( int ) $ time ; return $ this ; }
2944	public function assignRole ( $ role ) { if ( is_string ( $ role ) ) { return $ this -> roles ( ) -> attach ( Role :: where ( 'slug' , $ role ) -> first ( ) ) ; } return $ this -> roles ( ) -> attach ( $ role ) ; }
7420	protected function getNumList ( ) : array { preg_match_all ( '/\/\d+/u' , $ this -> request -> route ( ) , $ numList ) ; $ numList = $ numList [ 0 ] ; $ numList = array_map ( function ( $ val ) { return intval ( ltrim ( $ val , '/' ) ) ; } , $ numList ) ; return $ numList ; }
7951	public function orderCacheRule ( $ nbCacheRule , $ duration ) { return json_decode ( self :: getClient ( ) -> orderCacheRule ( $ this -> sn , $ nbCacheRule , $ duration ) ) ; }
7218	public function create ( $ argv ) { $ custom_name = false ; if ( $ argv && count ( $ argv ) ) { $ custom_name = mb_strtolower ( $ argv [ 0 ] , 'utf-8' ) ; } DB :: begin ( ) ; try { $ name = 'm' . gmdate ( 'ymd_His' ) ; if ( $ custom_name ) $ name = $ name . '_' . $ custom_name ; $ file = '<?php// ' . strftime ( '%F %T' ) . 'use mii\db\Migration;use mii\db\DB;class ' . $ name . ' extends Migration { public function up() { } public function down() { return false; } public function safe_up() { } public function safe_down() { return false; }}' ; reset ( $ this -> migrations_paths ) ; file_put_contents ( current ( $ this -> migrations_paths ) . '/' . $ name . '.php' , $ file ) ; DB :: commit ( ) ; $ this -> info ( 'migration :name created' , [ ':name' => $ name ] ) ; } catch ( \ Exception $ e ) { DB :: rollback ( ) ; throw $ e ; } }
1124	public function getDescendants ( $ columns = array ( '*' ) ) { if ( is_array ( $ columns ) ) return $ this -> descendants ( ) -> get ( $ columns ) ; $ arguments = func_get_args ( ) ; $ limit = intval ( array_shift ( $ arguments ) ) ; $ columns = array_shift ( $ arguments ) ? : array ( '*' ) ; return $ this -> descendants ( ) -> limitDepth ( $ limit ) -> get ( $ columns ) ; }
9466	private function getServerModules ( array $ requirements ) { if ( ! function_exists ( 'apache_get_modules' ) ) { return collect ( [ ] ) ; } $ modules = apache_get_modules ( ) ; $ requirements = array_combine ( $ requirements , $ requirements ) ; return collect ( $ requirements ) -> transform ( function ( $ requirement ) use ( $ modules ) { return in_array ( $ requirement , $ modules ) ; } ) ; }
11103	public function filter ( ScopeInterface $ scope ) { $ filtered = new self ; foreach ( $ this as $ eachResult ) { if ( $ eachResult -> getScope ( ) -> isEqualTo ( $ scope ) ) { $ filtered -> add ( $ eachResult ) ; } } return $ filtered ; }
2360	public static function findPublishedById ( $ intId , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = array ( "$t.id=?" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.disable=''" ; } return static :: findOneBy ( $ arrColumns , $ intId , $ arrOptions ) ; }
2469	public function mapContentBlock ( Content $ content ) { $ contentInfo = $ content -> versionInfo -> contentInfo ; $ locations = $ this -> locationHandler -> loadLocationsByContent ( $ contentInfo -> id ) ; $ blockFields = $ this -> getBlockFields ( $ content ) ; $ contentFields = $ this -> getContentFields ( $ content ) ; $ documents = [ ] ; $ locationFieldsMap = [ ] ; foreach ( $ locations as $ location ) { $ locationFieldsMap [ $ location -> id ] = $ this -> getLocationFields ( $ location ) ; } foreach ( array_keys ( $ content -> versionInfo -> names ) as $ languageCode ) { $ blockTranslationFields = $ this -> getBlockTranslationFields ( $ content , $ languageCode ) ; $ translationLocationDocuments = array ( ) ; foreach ( $ locations as $ location ) { $ translationLocationDocuments [ ] = new Document ( array ( 'id' => $ this -> generateLocationDocumentId ( $ location -> id , $ languageCode ) , 'fields' => array_merge ( $ blockFields , $ locationFieldsMap [ $ location -> id ] , $ blockTranslationFields ) , ) ) ; } $ isMainTranslation = ( $ contentInfo -> mainLanguageCode === $ languageCode ) ; $ alwaysAvailable = ( $ isMainTranslation && $ contentInfo -> alwaysAvailable ) ; $ contentTranslationFields = $ this -> getContentTranslationFields ( $ content , $ languageCode ) ; $ documents [ ] = new Document ( array ( 'id' => $ this -> generateContentDocumentId ( $ contentInfo -> id , $ languageCode ) , 'languageCode' => $ languageCode , 'alwaysAvailable' => $ alwaysAvailable , 'isMainTranslation' => $ isMainTranslation , 'fields' => array_merge ( $ blockFields , $ contentFields , $ blockTranslationFields , $ contentTranslationFields ) , 'documents' => $ translationLocationDocuments , ) ) ; } return $ documents ; }
1974	public static function findMultipleByUuidsAndExtensions ( $ arrUuids , $ arrExtensions , array $ arrOptions = array ( ) ) { if ( empty ( $ arrUuids ) || empty ( $ arrExtensions ) || ! \ is_array ( $ arrUuids ) || ! \ is_array ( $ arrExtensions ) ) { return null ; } foreach ( $ arrExtensions as $ k => $ v ) { if ( ! preg_match ( '/^[a-z0-9]{2,5}$/i' , $ v ) ) { unset ( $ arrExtensions [ $ k ] ) ; } } $ t = static :: $ strTable ; foreach ( $ arrUuids as $ k => $ v ) { if ( Validator :: isStringUuid ( $ v ) ) { $ v = StringUtil :: uuidToBin ( $ v ) ; } $ arrUuids [ $ k ] = "UNHEX('" . bin2hex ( $ v ) . "')" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.uuid!=" . implode ( ", $t.uuid!=" , $ arrUuids ) ; } return static :: findBy ( array ( "$t.uuid IN(" . implode ( "," , $ arrUuids ) . ") AND $t.extension IN('" . implode ( "','" , $ arrExtensions ) . "')" ) , null , $ arrOptions ) ; }
12255	public function removeCompiler ( $ compiler ) { if ( ( $ idx = array_search ( $ compiler , $ this -> compilers ) ) !== false ) { unset ( $ this -> compilers [ $ idx ] ) ; $ this -> orderedCompilers = NULL ; } }
11910	public function getDefaultParams ( ) { $ defaultParams = [ ] ; foreach ( $ this -> parameters as $ parameter ) { if ( $ parameter -> hasDefault ( ) ) { if ( $ parameter -> getIsAPIParameter ( ) == false ) { $ defaultParams [ ] = $ parameter ; } } } return $ defaultParams ; }
5164	public function send ( EmailSender $ email , array $ data = [ ] ) { $ result = ( new DataBuilderManager ( ) ) -> validateRaw ( $ email -> data_builder , $ data ) ; dispatch ( new SendEmail ( $ email , $ data , $ this -> getAgent ( ) ) ) ; return $ result ; }
1687	public function loginAction ( ) : Response { $ this -> get ( 'contao.framework' ) -> initialize ( ) ; if ( ! isset ( $ GLOBALS [ 'TL_PTY' ] [ 'error_401' ] ) || ! class_exists ( $ GLOBALS [ 'TL_PTY' ] [ 'error_401' ] ) ) { throw new UnauthorizedHttpException ( '' , 'Not authorized' ) ; } $ pageHandler = new $ GLOBALS [ 'TL_PTY' ] [ 'error_401' ] ( ) ; try { return $ pageHandler -> getResponse ( ) ; } catch ( ResponseException $ e ) { return $ e -> getResponse ( ) ; } catch ( InsufficientAuthenticationException $ e ) { throw new UnauthorizedHttpException ( '' , $ e -> getMessage ( ) ) ; } }
5950	public function addMediaResponse ( $ item ) { if ( ! ( $ item instanceof MediaResponse ) ) { if ( is_array ( $ item ) ) { try { $ item = new MediaResponse ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate MediaResponse. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } elseif ( ! is_numeric ( $ item ) ) { trigger_error ( 'Array parameter item is not of expected type "MediaResponse"!' , E_USER_WARNING ) ; } } $ this -> results [ ] = $ item ; return $ this ; }
12234	public function firstOf ( $ xpath ) { $ nodes = $ this -> xpath ( $ xpath ) ; return ( isset ( $ nodes [ 0 ] ) ) ? $ nodes [ 0 ] : null ; }
8525	public function setSellerSKU ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'SellerSKU' ] [ 'FieldValue' ] = $ value ; return $ this ; }
8936	public function createChangeset ( $ changesets = array ( ) ) { $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , 'oauth_token_secret' => $ token [ 'secret' ] , ) ; $ base = 'changeset/create' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ xml = '<?xml version="1.0" encoding="UTF-8"?> <osm version="0.6" generator="JoomlaOpenStreetMap">' ; if ( ! empty ( $ changesets ) ) { foreach ( $ changesets as $ tags ) { $ xml .= '<changeset>' ; if ( ! empty ( $ tags ) ) { foreach ( $ tags as $ key => $ value ) { $ xml .= '<tag k="' . $ key . '" v="' . $ value . '"/>' ; } } $ xml .= '</changeset>' ; } } $ xml .= '</osm>' ; $ header [ 'Content-Type' ] = 'text/xml' ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'PUT' , $ parameters , $ xml , $ header ) ; return $ response -> body ; }
12610	public function getParents ( ) { $ parents = [ ] ; foreach ( $ this -> _parents as $ key => $ parent ) { if ( ! $ parent -> active ) { continue ; } $ parents [ $ key ] = $ parent ; } return $ parents ; }
3726	public static function createFromQueryBuilder ( QueryBuilder $ builder , $ columnName = 'id' ) { return new self ( $ builder -> getSQL ( ) , $ builder -> getParameters ( ) , $ columnName , $ builder -> getConnection ( ) , $ builder -> getParameterTypes ( ) ) ; }
3021	public function getBlogAvatar ( $ blogName , $ size = null ) { $ path = $ this -> blogPath ( $ blogName , '/avatar' ) ; if ( $ size ) { $ path .= "/$size" ; } return $ this -> getRedirect ( $ path , null , true ) ; }
1271	public function noCandidates ( ) { if ( AddressValidation :: REQUEST_OPTION_ADDRESS_CLASSIFICATION == $ this -> requestAction ) { throw new \ BadMethodCallException ( __METHOD__ . ' should not be called on Address Classification only requests.' ) ; } return isset ( $ this -> response -> NoCandidatesIndicator ) ; }
10358	public static function error ( int $ code , string $ message , string $ file , int $ line ) : bool { if ( ( error_reporting ( ) & $ code ) !== 0 ) { if ( DEVELOPMENT == false && $ code == 8 ) { $ error [ 'code' ] = $ code ; $ error [ 'message' ] = $ message ; $ error [ 'file' ] = $ file ; $ error [ 'line' ] = $ line ; $ error [ 'type' ] = 'ErrorException: ' ; $ codes = array ( E_USER_NOTICE => 'Notice' , ) ; $ error [ 'type' ] .= in_array ( $ error [ 'code' ] , array_keys ( $ codes ) ) ? $ codes [ $ error [ 'code' ] ] : 'Unknown Error' ; ErrorHandler :: writeLogs ( "{$error['type']}: {$error['message']} in {$error['file']} at line {$error['line']}" ) ; } else { throw new \ ErrorException ( $ message , $ code , 0 , $ file , $ line ) ; } } return true ; }
12329	public function enqueue_style ( WP_Enqueue_Options $ options ) { if ( ! $ options -> have_required_properties ( ) ) { trigger_error ( 'Trying to enqueue style, but required properties are missing.' ) ; return ; } $ handle = $ options -> get_handle ( ) ; $ relative_path = $ options -> get_relative_path ( ) ; $ filename = $ options -> get_filename ( ) ; $ filename_debug = $ options -> get_filename_debug ( ) ; $ dependencies = $ options -> get_dependencies ( ) ; $ version = $ options -> get_version ( ) ; $ media = $ options -> get_media ( ) ; $ source = $ this -> get_source_to_enqueue ( $ relative_path , $ filename , $ filename_debug ) ; wp_enqueue_style ( $ handle , $ source , $ dependencies , $ version , $ media ) ; }
9459	public function getByIds ( array $ ids , $ page = 1 , $ per_page = 100 ) { return $ this -> getCollection ( 'tickets/show_many.json?ids=' . implode ( ',' , $ ids ) , 'tickets' , $ page , $ per_page ) ; }
10578	public function multipleToAPIResponseData ( ? array $ resources ) : APIResponseData { if ( is_null ( $ resources ) ) { return $ this -> toAPIResponseData ( null ) ; } return new APIResponseData ( array_map ( function ( Resource $ resource ) { return $ this -> toAPIResponseData ( $ resource ) -> getData ( ) ; } , $ resources ) ) ; }
9139	public static function parse ( $ uri , $ serverVars = array ( ) , $ defaultController = 'Index' , $ defaultAction = 'index' ) { $ req = new self ( $ defaultController , $ defaultAction ) ; $ req -> origin = $ uri ; self :: parseRemoteHost ( $ req , $ serverVars ) ; self :: parseGetPostSessionCookie ( $ req ) ; $ savedRequestParams = array ( ) ; if ( strpos ( $ uri , '?' ) ) { parse_str ( substr ( $ uri , strpos ( $ uri , '?' ) + 1 ) , $ savedRequestParams ) ; $ uri = substr ( $ uri , 0 , strpos ( $ uri , '?' ) ) ; } self :: parseContextPrefix ( $ req , $ serverVars ) ; $ parts = self :: parseUri ( $ req , $ uri , $ defaultController , $ defaultAction ) ; $ numParts = count ( $ parts ) ; for ( $ i = 0 ; $ i < $ numParts ; $ i = $ i + 2 ) { $ paramName = trim ( $ parts [ $ i ] ) ; $ paramValue = isset ( $ parts [ $ i + 1 ] ) ? trim ( $ parts [ $ i + 1 ] ) : '' ; if ( $ paramName && $ paramValue ) { $ req -> params [ $ paramName ] = $ paramValue ; } } $ req -> params = array_merge ( $ req -> params , $ savedRequestParams ) ; self :: parseParameters ( $ req , $ serverVars ) ; return $ req ; }
1797	private function addLocaleToRoute ( Route $ route ) : void { if ( ! $ this -> prependLocale ) { return ; } $ route -> setPath ( '/{_locale}' . $ route -> getPath ( ) ) ; $ route -> addRequirements ( [ '_locale' => '[a-z]{2}(\-[A-Z]{2})?' ] ) ; }
5834	protected function setCode ( $ code ) { $ this -> code = $ code ; $ this -> statusText = $ code ; list ( $ this -> statusCode , ) = explode ( ' ' , $ code ) ; }
9251	public function addCompilerPass ( CompilerPassInterface $ pass , $ type = PassConfig :: TYPE_BEFORE_OPTIMIZATION ) { $ this -> compilerPasses [ ] = array ( $ pass , $ type ) ; }
10367	public function register ( RegisterRequest $ request ) { $ this -> bus -> pipeThrough ( $ this -> pipesOf ( 'register' ) ) -> dispatchFrom ( RegisterJob :: class , $ request ) ; return redirect ( ) -> route ( config ( '_auth.register.redirect' ) ) -> withSuccess ( trans ( 'auth::register.success' ) ) ; }
10547	public function setResolver ( Resolver $ resolver ) { $ this -> resolver = $ resolver ; $ this -> setVariable ( 'resolver' , $ resolver ) ; return $ this ; }
1454	protected function validateRelationship ( RelationshipInterface $ relationship , $ key = null ) { if ( ! $ relationship -> has ( RelationshipInterface :: DATA ) ) { $ this -> addError ( $ this -> errorFactory -> memberRequired ( RelationshipInterface :: DATA , $ key ? P :: relationship ( $ key ) : P :: data ( ) ) ) ; return false ; } if ( ! $ relationship -> isHasOne ( ) && ! $ relationship -> isHasMany ( ) ) { $ this -> addError ( $ this -> errorFactory -> memberRelationshipExpected ( RelationshipInterface :: DATA , $ key ? P :: relationship ( $ key ) : P :: data ( ) ) ) ; return false ; } if ( ! $ this -> validateEmpty ( $ relationship , $ key ) ) { return false ; } return true ; }
1679	public function checkPermission ( ) { if ( $ this -> User -> isAdmin ) { return ; } switch ( Contao \ Input :: get ( 'act' ) ) { case 'create' : case 'select' : case 'show' : break ; case 'delete' : if ( Contao \ Input :: get ( 'id' ) == $ this -> User -> id ) { throw new Contao \ CoreBundle \ Exception \ AccessDeniedException ( 'Attempt to delete own account ID ' . Contao \ Input :: get ( 'id' ) . '.' ) ; } case 'edit' : case 'copy' : case 'toggle' : default : $ objUser = $ this -> Database -> prepare ( "SELECT `admin` FROM tl_user WHERE id=?" ) -> limit ( 1 ) -> execute ( Contao \ Input :: get ( 'id' ) ) ; if ( $ objUser -> admin && Contao \ Input :: get ( 'act' ) != '' ) { throw new Contao \ CoreBundle \ Exception \ AccessDeniedException ( 'Not enough permissions to ' . Contao \ Input :: get ( 'act' ) . ' administrator account ID ' . Contao \ Input :: get ( 'id' ) . '.' ) ; } break ; case 'editAll' : case 'deleteAll' : case 'overrideAll' : $ objSession = Contao \ System :: getContainer ( ) -> get ( 'session' ) ; $ session = $ objSession -> all ( ) ; $ objUser = $ this -> Database -> execute ( "SELECT id FROM tl_user WHERE `admin`=1" ) ; $ session [ 'CURRENT' ] [ 'IDS' ] = array_diff ( $ session [ 'CURRENT' ] [ 'IDS' ] , $ objUser -> fetchEach ( 'id' ) ) ; $ objSession -> replace ( $ session ) ; break ; } }
6504	public function serializeParameters ( $ type , array $ parameters ) { $ jobType = $ this -> registry -> get ( $ type ) ; $ indices = $ jobType -> getIndicesOfSerializableParameters ( ) ; if ( count ( $ indices ) < count ( $ parameters ) ) { throw new \ InvalidArgumentException ( sprintf ( 'More parameters provided for serialization than defined for job "%s"' , $ type ) ) ; } $ i = 0 ; $ serializedParameters = array ( ) ; foreach ( $ parameters as $ parameter ) { if ( null == $ parameter ) { $ serializedParameters [ ] = null ; } else { $ serializedParameters [ ] = $ this -> serializer -> serialize ( $ parameter , 'json' , $ this -> getParamSerializationContext ( $ jobType , $ indices [ $ i ] ) ) ; } $ i ++ ; } $ data = json_encode ( $ serializedParameters ) ; if ( false === $ data ) { throw new \ RuntimeException ( sprintf ( 'Serialization failed with error "%s"' , json_last_error_msg ( ) ) ) ; } return $ data ; }
1228	public function parse ( $ expression ) { $ this -> expression = $ expression ; $ this -> tokens = $ this -> lexer -> tokenize ( $ expression ) ; $ this -> tpos = - 1 ; $ this -> next ( ) ; $ result = $ this -> expr ( ) ; if ( $ this -> token [ 'type' ] === T :: T_EOF ) { return $ result ; } throw $ this -> syntax ( 'Did not reach the end of the token stream' ) ; }
1448	protected function dataForRelationship ( $ record , string $ field , array $ document ) : array { $ schema = $ this -> container -> getSchema ( $ record ) ; return [ 'type' => $ schema -> getResourceType ( ) , 'id' => $ schema -> getId ( $ record ) , 'relationships' => [ $ field => [ 'data' => $ document [ 'data' ] , ] , ] , ] ; }
12797	public function mb_str_pad ( $ input , $ length , $ string = ' ' , $ type = STR_PAD_LEFT ) { return str_pad ( $ input , $ length + strlen ( $ input ) - mb_strlen ( $ input ) , $ string , $ type ) ; }
2658	public function getResponse ( $ version , $ name ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/response_object/' . $ name ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: GET ) ; return $ result ; }
7863	protected function drawCenteredChar ( $ character ) { $ spaces = str_repeat ( ' ' , $ this -> geometry -> getHalfWidth ( ) ) ; $ this -> drawRow ( $ spaces . $ character ) ; }
11470	public function store ( ResponseRequest $ request ) { try { $ request = $ request -> all ( ) ; $ slug = $ request [ 'slug' ] ; $ attributes [ 'comment' ] = $ request [ 'comment' ] ; $ attributes [ 'question_id' ] = $ request [ 'question_id' ] ; $ attributes [ 'user_id' ] = user_id ( ) ; $ attributes [ 'user_type' ] = user_type ( ) ; $ response = $ this -> repository -> create ( $ attributes ) ; return $ this -> response -> message ( trans ( 'messages.success.created' , [ 'Module' => trans ( 'forum::response.name' ) ] ) ) -> code ( 204 ) -> status ( 'success' ) -> url ( trans_url ( '/discussion/' . $ slug ) ) -> redirect ( ) ; } catch ( Exception $ e ) { return $ this -> response -> message ( $ e -> getMessage ( ) ) -> code ( 400 ) -> status ( 'error' ) -> url ( trans_url ( '/question/' . $ slug ) ) -> redirect ( ) ; } }
58	protected function resolvePackageInstallPreference ( PackageInterface $ package ) { foreach ( $ this -> packagePreferences as $ pattern => $ preference ) { $ pattern = '{^' . str_replace ( '\\*' , '.*' , preg_quote ( $ pattern ) ) . '$}i' ; if ( preg_match ( $ pattern , $ package -> getName ( ) ) ) { if ( 'dist' === $ preference || ( ! $ package -> isDev ( ) && 'auto' === $ preference ) ) { return 'dist' ; } return 'source' ; } } return $ package -> isDev ( ) ? 'source' : 'dist' ; }
5665	private function innerHtml ( $ node ) { $ raw = '' ; if ( $ node -> hasChildren ( ) ) { foreach ( $ node -> child as $ child ) { $ raw .= $ child -> value ; } } return $ this -> stripGuards ( $ raw ) ; }
11932	protected function generateOption ( $ key , $ value ) { $ option = new FieldOption ( ) ; $ option -> setKey ( $ key ) ; $ option -> setValue ( $ value ) ; return $ option ; }
9847	public function createSealedResponse ( int $ status , string $ body , SealingPublicKey $ key , array $ headers = [ ] , string $ version = '1.1' ) : ResponseInterface { return new Response ( $ status , new Headers ( $ headers ) , $ this -> stringToStream ( Base64UrlSafe :: encode ( Simple :: seal ( $ body , $ key ) ) ) ) ; }
11084	public static function deleteDirectory ( $ dirName , $ deleteSelf = true ) { $ dirName = rtrim ( $ dirName , '/' ) . '/' ; if ( file_exists ( $ dirName ) && $ files = scandir ( $ dirName , SCANDIR_SORT_NONE ) ) { foreach ( $ files as $ file ) { if ( $ file !== '.' && $ file !== '..' && $ file !== '.svn' ) { if ( is_dir ( $ dirName . $ file ) ) { self :: deleteDirectory ( $ dirName . $ file , true ) ; } elseif ( file_exists ( $ dirName . $ file ) ) { @ chmod ( $ dirName . $ file , 0777 ) ; unlink ( $ dirName . $ file ) ; } } } if ( $ deleteSelf && ! rmdir ( $ dirName ) ) { @ chmod ( $ dirName , 0777 ) ; return false ; } return true ; } return false ; }
560	protected function buildOperatorCondition ( $ operator , $ condition , $ attribute ) { if ( isset ( $ this -> queryOperatorMap [ $ operator ] ) ) { $ operator = $ this -> queryOperatorMap [ $ operator ] ; } return [ $ operator , $ attribute , $ this -> filterAttributeValue ( $ attribute , $ condition ) ] ; }
4159	function pop ( ) { $ response = $ this -> redis -> blPop ( $ this -> key , 10 ) ; if ( $ response ) { list ( $ list , $ serializedJob ) = $ response ; $ job = unserialize ( $ serializedJob ) ; return $ job ; } }
5776	public function add ( string $ sql ) { $ args = func_get_args ( ) ; array_shift ( $ args ) ; $ this -> sql .= $ sql ; $ this -> args = array_merge ( $ this -> args , $ args ) ; return $ this ; }
974	public function handle ( Request $ request , Closure $ next ) { $ hmac = $ request -> header ( 'x-shopify-hmac-sha256' ) ? : '' ; $ shop = $ request -> header ( 'x-shopify-shop-domain' ) ; $ data = $ request -> getContent ( ) ; $ hmacLocal = ShopifyApp :: createHmac ( [ 'data' => $ data , 'raw' => true , 'encode' => true ] ) ; if ( ! hash_equals ( $ hmac , $ hmacLocal ) || empty ( $ shop ) ) { return Response :: make ( 'Invalid webhook signature.' , 401 ) ; } return $ next ( $ request ) ; }
6734	protected function handleException ( \ Throwable $ e , Request $ request ) : Response { if ( ! $ e instanceof Exception \ Exception ) { $ e = new Exception \ UncaughtException ( $ e ) ; } $ code = $ e -> getStatusCode ( ) ; if ( $ this -> exceptionHandlers [ $ code ] instanceof ExceptionHandler ) { return $ this -> exceptionHandlers [ $ code ] -> handle ( $ e , $ request ) ; } elseif ( $ this -> defaultExceptionHandler instanceof ExceptionHandler ) { return $ this -> defaultExceptionHandler -> handle ( $ e , $ request ) ; } else { return ( new \ Circuit \ ExceptionHandler \ DefaultHandler ) -> handle ( $ e , $ request ) ; } }
8780	protected function scheme ( ) { if ( $ this -> cachedHttps === true ) { $ this -> https = true ; } return "http" . ( $ this -> https === true ? 's' : '' ) . "://" ; }
4574	public function getProperties ( Localizable $ model ) : array { $ class = get_class ( $ model ) ; if ( substr ( $ class , 0 , 15 ) === 'Proxies\\__CG__\\' ) { $ class = substr ( $ class , 15 ) ; } $ properties = [ ] ; $ reflection = new ReflectionClass ( $ class ) ; foreach ( $ reflection -> getProperties ( ) as $ property ) { $ annotation = $ this -> annotationReader -> getPropertyAnnotation ( $ property , Locale :: class ) ; if ( ! $ annotation ) { continue ; } $ properties [ ] = $ property ; } return $ properties ; }
1600	public function serialize ( $ record , $ meta = null , array $ links = [ ] ) { $ serializer = clone $ this -> serializer ; $ serializer -> withMeta ( $ meta ) -> withLinks ( $ links ) ; $ serialized = $ serializer -> serializeData ( $ record , $ this -> createEncodingParameters ( ) ) ; $ resourceLinks = null ; if ( empty ( $ serialized [ 'data' ] [ 'id' ] ) ) { unset ( $ serialized [ 'data' ] [ 'id' ] ) ; $ resourceLinks = false ; } $ resource = $ this -> parsePrimaryResource ( $ serialized [ 'data' ] , $ resourceLinks ) ; $ document = [ 'data' => $ resource ] ; if ( isset ( $ serialized [ 'included' ] ) && $ this -> doesSerializeCompoundDocuments ( ) ) { $ document [ 'included' ] = $ this -> parseIncludedResources ( $ serialized [ 'included' ] ) ; } return $ document ; }
1485	public function prepend ( Decoding ... $ decodings ) : self { $ copy = clone $ this ; array_unshift ( $ copy -> stack , ... $ decodings ) ; return $ copy ; }
2044	public static function create ( array $ parameters ) : ? Connection { $ params = [ 'driver' => 'pdo_mysql' , 'host' => $ parameters [ 'parameters' ] [ 'database_host' ] , 'port' => $ parameters [ 'parameters' ] [ 'database_port' ] , 'user' => $ parameters [ 'parameters' ] [ 'database_user' ] , 'password' => $ parameters [ 'parameters' ] [ 'database_password' ] , 'dbname' => $ parameters [ 'parameters' ] [ 'database_name' ] , ] ; try { return DriverManager :: getConnection ( $ params ) ; } catch ( DBALException $ e ) { } return null ; }
10731	public function getMinute ( ) { if ( $ this -> value !== null ) { preg_match ( '/^(?P<year>[0-9]{4,4})-(?P<month>[0-9]{2,2})-(?P<day>[0-9]{2,2}) (?P<hour>[0-9]{2,2}):(?P<minute>[0-9]{2,2}):(?P<second>[0-9]{2,2})$/ui' , $ this -> value , $ m ) ; return ( int ) $ m [ 'minute' ] ; } }
7720	static function f_Misc_UpdateArray ( & $ array , $ numerical , $ v , $ d ) { if ( ! is_array ( $ v ) ) { if ( is_null ( $ v ) ) { $ array = array ( ) ; return ; } else { $ v = array ( $ v => $ d ) ; } } foreach ( $ v as $ p => $ a ) { if ( $ numerical === true ) { if ( is_string ( $ p ) ) { $ i = array_search ( $ p , $ array , true ) ; if ( $ i === false ) { if ( ! is_null ( $ a ) ) $ array [ ] = $ p ; } else { if ( is_null ( $ a ) ) array_splice ( $ array , $ i , 1 ) ; } } else { $ i = array_search ( $ a , $ array , true ) ; if ( $ i == false ) $ array [ ] = $ a ; } } else { if ( is_null ( $ a ) ) { unset ( $ array [ $ p ] ) ; } elseif ( $ numerical === 'frm' ) { self :: f_Misc_FormatSave ( $ a , $ p ) ; } else { $ array [ $ p ] = $ a ; } } } }
8697	protected function validateMandatoryAttribs ( ) { foreach ( static :: $ mandatoryFields as $ field ) { if ( ! array_key_exists ( $ field , $ this -> attributes ) ) { throw new \ SVGCreator \ SVGException ( "The field " . $ field . " does not exist for " . static :: TYPE . "." , 1 ) ; } } }
5070	protected function determineHeaderTags ( $ topLevel , $ depth ) { $ desired = range ( ( int ) $ topLevel , ( int ) $ topLevel + ( ( int ) $ depth - 1 ) ) ; $ allowed = [ 1 , 2 , 3 , 4 , 5 , 6 ] ; return array_map ( function ( $ val ) { return 'h' . $ val ; } , array_intersect ( $ desired , $ allowed ) ) ; }
4474	public function perform ( ) : bool { try { $ instance = $ this -> getInstance ( ) ; if ( method_exists ( $ instance , 'setUp' ) ) { $ instance -> setUp ( ) ; } $ this -> getEventsManager ( ) -> fire ( new JobEvent \ BeforePerform ( $ this , $ this ) ) ; $ performMethod = $ this -> getPerformMethod ( ) ; $ instance -> $ performMethod ( $ this ) ; $ this -> getEventsManager ( ) -> fire ( new JobEvent \ AfterPerform ( $ this , $ this ) ) ; if ( method_exists ( $ instance , 'tearDown' ) ) { $ instance -> tearDown ( ) ; } } catch ( \ Throwable $ e ) { $ this -> fail ( 'system:fatal' , sprintf ( '%s: %s in %s on line %d' , get_class ( $ e ) , $ e -> getMessage ( ) , $ e -> getFile ( ) , $ e -> getLine ( ) ) ) ; return false ; } return true ; }
2654	public function hasSnippet ( $ version , $ name ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/snippet/' . $ name ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: GET , '' , false , null , false ) ; if ( $ result == false ) { return false ; } return true ; }
5438	public function match ( $ subject , & $ match ) { if ( count ( $ this -> patterns ) === 0 ) { return false ; } if ( ! preg_match ( $ this -> getCompoundedRegex ( ) , $ subject , $ matches ) ) { $ match = '' ; return false ; } $ match = $ matches [ 0 ] ; for ( $ i = 1 ; $ i < count ( $ matches ) ; $ i ++ ) { if ( $ matches [ $ i ] ) { return $ this -> labels [ $ i - 1 ] ; } } return true ; }
11500	protected function _setupDatabaseAdapter ( ) { if ( Zend_Registry :: isRegistered ( 'multidb' ) ) { return $ this -> _setAdapter ( Zend_Registry :: get ( 'multidb' ) -> getDb ( $ this -> _connection ) ) ; } return parent :: _setupDatabaseAdapter ( ) ; }
8688	private static function canReturnArraysByReference ( ArrayAccess $ obj , $ key , & $ value , & $ ex ) { static $ supportedClasses = [ Bag :: class => true , MutableBag :: class => true , \ ArrayObject :: class => true , \ ArrayIterator :: class => true , \ RecursiveArrayIterator :: class => true , ] ; static $ noErrors = [ ] ; $ class = get_class ( $ obj ) ; if ( ! isset ( $ supportedClasses [ $ class ] ) ) { $ supportedClasses [ $ class ] = ( new \ ReflectionMethod ( $ obj , 'offsetGet' ) ) -> returnsReference ( ) ? null : false ; } if ( $ supportedClasses [ $ class ] !== null ) { return $ supportedClasses [ $ class ] ; } if ( isset ( $ noErrors [ $ class ] ) ) { $ value1 = & $ obj [ $ key ] ; } else { Thrower :: set ( ) ; try { $ value1 = & $ obj [ $ key ] ; } catch ( \ ErrorException $ e ) { $ msg = $ e -> getMessage ( ) ; if ( $ msg === 'Only variable references should be returned by reference' || strpos ( $ msg , 'Indirect modification of overloaded element' ) === 0 ) { $ ex = $ e ; return $ supportedClasses [ $ class ] = false ; } throw $ e ; } finally { restore_error_handler ( ) ; } $ noErrors [ $ class ] = true ; } if ( ! is_array ( $ value1 ) ) { $ value = $ value1 ; return true ; } $ value2 = & $ obj [ $ key ] ; $ testKey = uniqid ( '__reference_test_' ) ; $ value1 [ $ testKey ] = 'test' ; $ supportedClasses [ $ class ] = isset ( $ value2 [ $ testKey ] ) ; unset ( $ value1 [ $ testKey ] ) ; return $ supportedClasses [ $ class ] ; }
10815	public function authenticate ( $ authMethod , $ options ) { $ sm = $ this -> getServiceManager ( ) ; $ authListener = $ sm -> get ( $ authMethod ) ; $ authListener -> setOptions ( $ options ) ; $ this -> getHttpClient ( ) -> getEventManager ( ) -> attachAggregate ( $ authListener ) ; }
3625	public function getDevices ( $ type = DEVICE_TYPE_THERMOSTAT ) { $ this -> prepareForGet ( ) ; if ( $ type == DEVICE_TYPE_PROTECT ) { $ protects = array ( ) ; $ topaz = isset ( $ this -> last_status -> topaz ) ? $ this -> last_status -> topaz : array ( ) ; foreach ( $ topaz as $ protect ) { $ protects [ ] = $ protect -> serial_number ; } return $ protects ; } $ devices_serials = array ( ) ; foreach ( $ this -> last_status -> user -> { $ this -> userid } -> structures as $ structure ) { list ( , $ structure_id ) = explode ( '.' , $ structure ) ; foreach ( $ this -> last_status -> structure -> { $ structure_id } -> devices as $ device ) { list ( , $ device_serial ) = explode ( '.' , $ device ) ; $ devices_serials [ ] = $ device_serial ; } } return $ devices_serials ; }
3893	private function renderEditButton ( $ caption , $ title , UrlBuilder $ url ) { $ icon = $ this -> iconBuilder -> getBackendIconImageTag ( 'system/themes/flexible/icons/alias.svg' , $ caption , 'style="vertical-align:top"' ) ; return sprintf ( '<a href="%s" title="%s" style="padding-left:3px">%s</a>' , $ url -> getUrl ( ) , $ title , $ icon ) ; }
6201	public function addRoute ( $ newRoute ) { $ this -> routeMap [ 'routes' ] = array_merge ( $ this -> routeMap [ 'routes' ] , $ newRoute ) ; $ this -> routeMapParse = array_merge ( $ this -> routeMapParse , $ newRoute ) ; }
6169	protected function writeException ( $ exception ) { $ this -> writeNewLine ( ) ; do { $ exceptionStack [ ] = $ exception ; } while ( $ exception = $ exception -> getPreviousWrapped ( ) ) ; foreach ( explode ( "\n" , $ exception = array_shift ( $ exceptionStack ) ) as $ line ) { if ( $ exception && false !== $ pos = strpos ( $ line , $ exception -> getClassName ( ) . ': ' ) ) { $ whitespace = str_repeat ( ' ' , ( $ pos += strlen ( $ exception -> getClassName ( ) ) ) + 2 ) ; $ this -> writeWithColor ( 'bg-red,fg-white' , $ whitespace ) ; $ this -> writeWithColor ( 'bg-red,fg-white' , sprintf ( ' %s ' , substr ( $ line , 0 , $ pos ) ) , false ) ; $ this -> writeWithColor ( 'fg-red' , substr ( $ line , $ pos + 1 ) ) ; $ this -> writeWithColor ( 'bg-red,fg-white' , $ whitespace ) ; $ exception = array_shift ( $ exceptionStack ) ; continue ; } $ this -> writeWithColor ( 'fg-red' , $ line ) ; } }
578	public static function to ( $ url = '' , $ scheme = false ) { if ( is_array ( $ url ) ) { return static :: toRoute ( $ url , $ scheme ) ; } $ url = Yii :: getAlias ( $ url ) ; if ( $ url === '' ) { $ url = Yii :: $ app -> getRequest ( ) -> getUrl ( ) ; } if ( $ scheme === false ) { return $ url ; } if ( static :: isRelative ( $ url ) ) { $ url = static :: getUrlManager ( ) -> getHostInfo ( ) . '/' . ltrim ( $ url , '/' ) ; } return static :: ensureScheme ( $ url , $ scheme ) ; }
7351	public function isPaid ( ) { return 0 <= Money :: compare ( $ this -> paidTotal , $ this -> grandTotal , $ this -> getCurrency ( ) -> getCode ( ) ) ; }
7392	public function serialize ( ) : string { $ toSerialize = [ '_arrayOptions' => $ this -> _arrayOptions , '_jsonOptions' => $ this -> _jsonOptions , ] ; foreach ( $ this -> _publicNames as $ k ) { $ toSerialize [ $ k ] = $ this -> { $ k } ; } return serialize ( $ toSerialize ) ; }
6828	private function getSaleDeliveryAddress ( ShipmentInterface $ shipment ) { if ( null === $ sale = $ shipment -> getSale ( ) ) { throw new LogicException ( "Shipment's sale must be set at this point." ) ; } return $ sale -> isSameAddress ( ) ? $ sale -> getInvoiceAddress ( ) : $ sale -> getDeliveryAddress ( ) ; }
11040	function leaf_path_walk ( $ elements , $ rank , $ ptype , & $ i , $ cvalue ) { if ( count ( $ elements ) == 1 ) { $ elt [ $ ptype . ':' . $ i . ':' . $ elements [ 0 ] . ':' . $ cvalue ] = '' ; } else { $ element1 = array_shift ( $ elements ) ; $ elt [ _ETS_TEMPLATE . ':' . $ i . '.' . $ rank . ':' . $ element1 ] = $ this -> leaf_path_walk ( $ elements , $ rank + 1 , $ ptype , $ i , $ cvalue ) ; } return $ elt ; }
11799	public function setReplyTo ( $ mail = '' , $ name = null ) { if ( strlen ( $ mail ) && Helper :: isEmail ( $ mail ) ) { if ( ! empty ( $ name ) ) { $ _m = Helper :: mailTagger ( $ mail , $ name ) ; } else { $ _m = $ mail ; } $ this -> getMailer ( ) -> setRegistry ( 'Reply-To' , $ _m , 'headers' ) ; } return $ this ; }
12920	public function getTotal ( ) { if ( ! $ this -> isReady ( ) ) { return 0 ; } if ( is_null ( $ this -> _countTotal ) ) { $ this -> _countTotal = 0 ; if ( in_array ( $ this -> settings [ 'direction' ] , [ 'to_local' , 'both' ] ) ) { $ this -> _countTotal += count ( $ this -> foreignDataItems ) ; } if ( in_array ( $ this -> settings [ 'direction' ] , [ 'to_foreign' , 'both' ] ) ) { $ this -> _countTotal += count ( $ this -> localDataItems ) ; } } return $ this -> _countTotal ; }
7711	function Delete ( $ Contents = true ) { $ this -> FindEndTag ( ) ; if ( $ Contents || $ this -> SelfClosing ) { $ this -> ReplaceSrc ( '' ) ; } else { $ inner = $ this -> GetInnerSrc ( ) ; $ this -> ReplaceSrc ( $ inner ) ; } }
724	public function getUniqueId ( ) { return $ this -> module instanceof Application ? $ this -> id : $ this -> module -> getUniqueId ( ) . '/' . $ this -> id ; }
4845	protected static function call ( $ method , $ url , $ params = array ( ) ) { $ ch = curl_init ( ) ; $ curl_options = array ( CURLOPT_CONNECTTIMEOUT => 10 , CURLOPT_RETURNTRANSFER => true , CURLOPT_TIMEOUT => 60 , CURLOPT_USERAGENT => 'gocardless-php/v' . GoCardless :: VERSION , ) ; if ( isset ( $ params [ 'ua_tag' ] ) ) { $ curl_options [ CURLOPT_USERAGENT ] .= ' ' . $ params [ 'ua_tag' ] ; unset ( $ params [ 'ua_tag' ] ) ; } $ curl_options [ CURLOPT_HTTPHEADER ] [ ] = 'Accept: application/json' ; $ curl_options [ CURLOPT_SSL_VERIFYPEER ] = true ; if ( isset ( $ params [ 'http_authorization' ] ) ) { $ curl_options [ CURLOPT_USERPWD ] = $ params [ 'http_authorization' ] ; unset ( $ params [ 'http_authorization' ] ) ; } else { if ( ! isset ( $ params [ 'http_bearer' ] ) ) { throw new GoCardless_ClientException ( 'Access token missing' ) ; } $ curl_options [ CURLOPT_HTTPHEADER ] [ ] = 'Authorization: Bearer ' . $ params [ 'http_bearer' ] ; unset ( $ params [ 'http_bearer' ] ) ; } if ( $ method == 'post' ) { $ curl_options [ CURLOPT_POST ] = 1 ; if ( ! empty ( $ params ) ) { $ curl_options [ CURLOPT_POSTFIELDS ] = http_build_query ( $ params , null , '&' ) ; } } elseif ( $ method == 'get' ) { $ curl_options [ CURLOPT_HTTPGET ] = 1 ; if ( ! empty ( $ params ) ) { $ url .= '?' . http_build_query ( $ params , null , '&' ) ; } } elseif ( $ method == 'put' ) { $ curl_options [ CURLOPT_PUT ] = 1 ; $ fh = fopen ( 'php://memory' , 'rw+' ) ; $ curl_options [ CURLOPT_INFILE ] = $ fh ; $ curl_options [ CURLOPT_INFILESIZE ] = 0 ; } curl_setopt ( $ ch , CURLOPT_URL , $ url ) ; curl_setopt_array ( $ ch , $ curl_options ) ; $ result = curl_exec ( $ ch ) ; $ error = curl_errno ( $ ch ) ; if ( $ error == CURLE_SSL_PEER_CERTIFICATE || $ error == CURLE_SSL_CACERT || $ error == 77 ) { curl_setopt ( $ ch , CURLOPT_CAINFO , dirname ( __FILE__ ) . '/cert-bundle.crt' ) ; $ result = curl_exec ( $ ch ) ; } $ http_response_code = curl_getinfo ( $ ch , CURLINFO_HTTP_CODE ) ; if ( $ http_response_code < 200 || $ http_response_code > 300 ) { $ message = print_r ( json_decode ( $ result , true ) , true ) ; throw new GoCardless_ApiException ( $ message , $ http_response_code , $ result ) ; } curl_close ( $ ch ) ; if ( isset ( $ fh ) ) { fclose ( $ fh ) ; } return json_decode ( $ result , true ) ; }
2036	public function getAbsoluteUrl ( $ strParams = null ) { $ this -> loadDetails ( ) ; $ objUrlGenerator = System :: getContainer ( ) -> get ( 'contao.routing.url_generator' ) ; $ strUrl = $ objUrlGenerator -> generate ( ( $ this -> alias ? : $ this -> id ) . $ strParams , array ( '_locale' => $ this -> rootLanguage , '_domain' => $ this -> domain , '_ssl' => ( bool ) $ this -> rootUseSSL , ) , UrlGeneratorInterface :: ABSOLUTE_URL ) ; $ strUrl = $ this -> applyLegacyLogic ( $ strUrl , $ strParams ) ; return $ strUrl ; }
361	public function renderErrors ( ) { if ( $ this -> filterModel instanceof Model && $ this -> filterModel -> hasErrors ( ) ) { return Html :: errorSummary ( $ this -> filterModel , $ this -> filterErrorSummaryOptions ) ; } return '' ; }
12107	public function getPage ( $ name ) { if ( ! isset ( $ this -> pages [ $ name ] ) ) { throw new InvalidParameterException ( "Page not found" ) ; } return $ this -> pages [ $ name ] ; }
2965	public function buildRequest ( $ method , $ path , array $ params = [ ] ) { $ body = ArrayUtils :: get ( $ params , 'body' , null ) ; $ query = ArrayUtils :: get ( $ params , 'query' , null ) ; $ options = [ ] ; if ( in_array ( $ method , [ 'POST' , 'PUT' , 'PATCH' ] ) && $ body ) { $ options [ 'body' ] = $ body ; } if ( $ query ) { $ options [ 'query' ] = $ query ; } return $ this -> createRequest ( $ method , $ path , $ options ) ; }
9632	public function getSetting ( $ setting ) { $ settings = $ this -> getSettings ( ) ; if ( isset ( $ settings ) && count ( $ settings ) > 0 ) { if ( isset ( $ settings [ $ setting ] ) ) { return $ settings [ $ setting ] ; } } return '' ; }
12463	public function newAction ( ) { $ entity = new CustomFieldsGroup ( ) ; $ form = $ this -> createCreateForm ( $ entity ) ; return $ this -> render ( 'ChillCustomFieldsBundle:CustomFieldsGroup:new.html.twig' , array ( 'entity' => $ entity , 'form' => $ form -> createView ( ) , ) ) ; }
6586	protected function request ( array $ options ) { $ this -> info = null ; $ this -> setOpt ( $ options ) ; $ result = $ this -> perform ( 'curl_exec' ) ; $ this -> info = $ this -> perform ( 'curl_getinfo' ) ; return $ result ; }
5641	public function paintCaseStart ( $ test_name ) { if ( ! isset ( $ this -> size ) ) { $ this -> size = 1 ; } if ( count ( $ this -> test_stack ) == 0 ) { $ this -> paintHeader ( $ test_name ) ; } $ this -> test_stack [ ] = $ test_name ; }
4361	public static function isUtf8 ( $ str , & $ special = false ) { self :: setStr ( $ str ) ; $ special = false ; while ( self :: $ curI < self :: $ stats [ 'strLen' ] ) { $ isUtf8 = self :: isOffsetUtf8 ( $ isSpecial ) ; if ( ! $ isUtf8 ) { return false ; } if ( $ isSpecial ) { $ special = true ; } } $ special = $ special || self :: hasSpecial ( $ str ) ; return true ; }
3381	public function hasRole ( $ role ) { if ( is_string ( $ role ) ) { return $ this -> roles -> contains ( 'name' , $ role ) ; } return ! ! $ role -> intersect ( $ this -> roles ) -> count ( ) ; }
10237	public static function getInstance ( Spreadsheet $ spreadsheet = null ) { if ( $ spreadsheet !== null ) { $ instance = $ spreadsheet -> getCalculationEngine ( ) ; if ( isset ( $ instance ) ) { return $ instance ; } } if ( ! isset ( self :: $ instance ) || ( self :: $ instance === null ) ) { self :: $ instance = new self ( ) ; } return self :: $ instance ; }
9358	public function getModulePath ( $ moduleName ) { if ( array_key_exists ( $ moduleName , $ this -> loadedModules ) ) { $ module = $ this -> loadedModules [ $ moduleName ] ; $ moduleConfig = $ module -> getAutoloaderConfig ( ) ; return $ moduleConfig [ self :: STANDARD_AUTOLOLOADER ] [ self :: NAMESPACE_KEY ] [ $ moduleName ] ; } return null ; }
2078	public function purgePageCache ( ) { $ strCacheDir = StringUtil :: stripRootDir ( System :: getContainer ( ) -> getParameter ( 'kernel.cache_dir' ) ) ; $ objFolder = new Folder ( $ strCacheDir . '/http_cache' ) ; $ objFolder -> purge ( ) ; $ this -> log ( 'Purged the page cache' , __METHOD__ , TL_CRON ) ; }
8495	public function getFulfillmentOrder ( $ request ) { if ( ! ( $ request instanceof FBAOutboundServiceMWS_Model_GetFulfillmentOrderRequest ) ) { $ request = new FBAOutboundServiceMWS_Model_GetFulfillmentOrderRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetFulfillmentOrder' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAOutboundServiceMWS_Model_GetFulfillmentOrderResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
4219	private function clearSummary ( $ flags ) { $ return = null ; $ clearErrors = $ flags & Debug :: CLEAR_SUMMARY_ERRORS ; if ( $ flags & Debug :: CLEAR_SUMMARY ) { $ return = 'summary (' . ( $ clearErrors ? 'incl errors' : 'sans errors' ) . ')' ; $ curPriority = \ end ( $ this -> data [ 'groupPriorityStack' ] ) ; foreach ( \ array_keys ( $ this -> data [ 'logSummary' ] ) as $ priority ) { $ entriesKeep = array ( ) ; if ( $ priority === $ curPriority ) { $ curDepth = 0 ; foreach ( $ this -> data [ 'groupStacks' ] [ $ priority ] as $ group ) { $ curDepth += ( int ) $ group [ 'collect' ] ; } $ entriesKeep = $ this -> debug -> internal -> getCurrentGroups ( $ this -> data [ 'logSummary' ] [ $ priority ] , $ curDepth ) ; } else { $ this -> data [ 'groupStacks' ] [ $ priority ] = array ( ) ; } $ this -> clearLogHelper ( $ this -> data [ 'logSummary' ] [ $ priority ] , $ clearErrors , $ entriesKeep ) ; } } elseif ( $ clearErrors ) { $ return = 'summary errors' ; } return $ return ; }
7459	private function color ( string $ color ) : Font { $ this -> color = $ color ; if ( $ this -> background ) { $ this -> turnToBackground ( ) ; } return $ this ; }
7416	public function getMaxFileSize ( ) : int { $ iniMax = strtolower ( ini_get ( 'upload_max_filesize' ) ) ; if ( '' === $ iniMax ) { return PHP_INT_MAX ; } $ max = ltrim ( $ iniMax , '+' ) ; if ( 0 === strpos ( $ max , '0x' ) ) { $ max = intval ( $ max , 16 ) ; } elseif ( 0 === strpos ( $ max , '0' ) ) { $ max = intval ( $ max , 8 ) ; } else { $ max = ( int ) $ max ; } switch ( substr ( $ iniMax , - 1 ) ) { case 't' : $ max *= 1024 ; case 'g' : $ max *= 1024 ; case 'm' : $ max *= 1024 ; case 'k' : $ max *= 1024 ; } return $ max ; }
11428	public function toSelect ( array & $ optgroups = [ ] , $ level = 1 , $ root = true ) { $ options = [ ] ; foreach ( $ this -> items as $ item ) { $ options [ ] = $ item -> toSelect ( ) ; } if ( $ root === true ) { $ text = $ this -> text ; } else { $ text = '|' . str_repeat ( '-' , $ level ) . ' ' . $ this -> text ; } $ optgroups [ ] = [ 'text' => $ text , 'options' => $ options , ] ; foreach ( $ this -> groups as $ group ) { $ group -> toSelect ( $ optgroups , $ level + 1 , false ) ; } }
10808	public static function isRender ( $ request ) { return true ; $ accept = $ request -> header ( 'accept' ) ?? '' ; if ( static :: isHas ( $ accept , 'json' ) || static :: isHas ( $ accept , 'api' ) ) { return true ; } else if ( static :: isHas ( $ accept , 'html' ) || static :: isHas ( $ accept , 'xml' ) || static :: isHas ( $ accept , 'text' ) ) { return false ; } else if ( $ request -> header ( 'x-ddv-restful-api' ) ) { return true ; } else if ( $ request -> header ( 'authorization' ) ) { foreach ( $ request -> headers -> keys ( ) as $ value ) { if ( static :: isHas ( $ accept , 'x-ddv-' ) ) { return true ; } } } return false ; }
6515	public function consumeJob ( PlainMessage $ message ) { $ ticket = $ message -> ticket ; $ type = $ message -> type ; $ this -> logger -> debug ( 'Consume message from bernard backend' , [ 'message' => $ message ] ) ; $ this -> manager -> onMessage ( new Message ( $ type , $ ticket ) ) ; }
11485	protected function resolveClassArg ( ReflectionClass $ class , ReflectionParameter $ param , array $ params ) { $ name = '$' . $ param -> getName ( ) ; $ class = $ class -> getName ( ) ; while ( $ name !== null ) { if ( $ params && array_key_exists ( $ name , $ params ) ) { $ class = $ params [ $ name ] ; } if ( $ class instanceof Factory \ FactoryInterface ) { return $ class -> invoke ( $ this ) ; } if ( is_object ( $ class ) ) { return $ class ; } $ name = ( $ name != $ class ) ? $ class : null ; } try { return $ this -> resolve ( $ class ) ; } catch ( ReflectionException $ exception ) { if ( $ param -> isOptional ( ) ) { return null ; } throw $ exception ; } }
12083	public function getAllMedia ( $ objectType = 'media' , $ objectURI = NULL , $ objectId = NULL ) { $ objects = $ this -> getMediaObjectsList ( $ objectType , $ objectURI , $ objectId ) -> fetchAll ( ) ; $ items = array ( ) ; foreach ( $ objects as $ i => $ object ) { $ object = $ this -> getOwner ( $ object , $ object [ 'media_owner' ] ) ; if ( $ object [ 'object_type' ] === "attachment" ) : $ object [ 'media_object' ] = $ object [ 'object_uri' ] ; if ( empty ( $ object [ 'media_title' ] ) ) : $ object [ 'media_title' ] = $ object [ 'attachment_name' ] ; endif ; endif ; $ object [ 'media_comment_target' ] = $ object [ 'object_uri' ] ; $ object [ 'media_published' ] = $ object [ 'object_created_on' ] ; $ items [ ] = $ object ; } $ mediacollections = new Collection ( ) ; $ mediacollections :: set ( "items" , $ items ) ; $ mediacollections :: set ( "totalItems" , count ( $ items ) ) ; $ collection = $ mediacollections :: getArray ( ) ; return $ collection ; }
1971	public static function findMultipleByUuids ( $ arrUuids , array $ arrOptions = array ( ) ) { if ( empty ( $ arrUuids ) || ! \ is_array ( $ arrUuids ) ) { return null ; } $ t = static :: $ strTable ; foreach ( $ arrUuids as $ k => $ v ) { if ( Validator :: isStringUuid ( $ v ) ) { $ v = StringUtil :: uuidToBin ( $ v ) ; } $ arrUuids [ $ k ] = "UNHEX('" . bin2hex ( $ v ) . "')" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.uuid!=" . implode ( ", $t.uuid!=" , $ arrUuids ) ; } return static :: findBy ( array ( "$t.uuid IN(" . implode ( "," , $ arrUuids ) . ")" ) , null , $ arrOptions ) ; }
5631	public function paintFooter ( $ test_name ) { ob_start ( ) ; parent :: paintFooter ( $ test_name ) ; $ output = trim ( ob_get_clean ( ) ) ; if ( $ output ) { if ( ( $ this -> getFailCount ( ) + $ this -> getExceptionCount ( ) ) == 0 ) { $ color = $ this -> _passColor ; } else { $ color = $ this -> _failColor ; } $ this -> _setColor ( $ color ) ; echo $ output ; $ this -> _resetColor ( ) ; } }
7700	function MsWord_InitHeaderFooter ( ) { if ( $ this -> MsWord_HeaderFooter !== false ) return ; $ types_ok = array ( 'default' => true , 'first' => false , 'even' => false ) ; $ idx = $ this -> FileGetIdx ( 'word/settings.xml' ) ; if ( $ idx !== false ) { $ Txt = $ this -> TbsStoreGet ( $ idx , 'GetHeaderFooterFile' ) ; $ types_ok [ 'even' ] = ( strpos ( $ Txt , '<w:evenAndOddHeaders/>' ) !== false ) ; unset ( $ Txt ) ; } $ idx = $ this -> FileGetIdx ( 'word/document.xml' ) ; if ( $ idx === false ) return false ; $ Txt = $ this -> TbsStoreGet ( $ idx , 'GetHeaderFooterFile' ) ; $ types_ok [ 'first' ] = ( strpos ( $ Txt , '<w:titlePg/>' ) !== false ) ; $ places = array ( 'header' , 'footer' ) ; $ files = array ( ) ; $ rels = $ this -> OpenXML_Rels_GetObj ( 'word/document.xml' , '' ) ; foreach ( $ places as $ place ) { $ p = 0 ; $ entity = 'w:' . $ place . 'Reference' ; while ( $ loc = clsTbsXmlLoc :: FindStartTag ( $ Txt , $ entity , $ p ) ) { $ p = $ loc -> PosEnd ; $ type = $ loc -> GetAttLazy ( 'w:type' ) ; if ( isset ( $ types_ok [ $ type ] ) && $ types_ok [ $ type ] ) { $ rid = $ loc -> GetAttLazy ( 'r:id' ) ; if ( isset ( $ rels -> TargetLst [ $ rid ] ) ) { $ target = $ rels -> TargetLst [ $ rid ] ; $ files [ ] = array ( 'file' => ( 'word/' . $ target ) , 'type' => $ type , 'place' => $ place ) ; } } } } $ this -> MsWord_HeaderFooter = $ files ; }
2341	protected function getUsername ( ) { if ( $ this -> strUsername !== null ) { return $ this -> strUsername ; } $ this -> import ( BackendUser :: class , 'User' ) ; return $ this -> User -> username ; }
12354	public function setFilePath ( string $ viewFilePath ) : void { if ( ! is_readable ( $ viewFilePath ) ) { throw new Exception ( "The View file {$viewFilePath} isn't readable." ) ; } $ this -> filePath = $ viewFilePath ; }
11702	public function add ( $ sName , $ mType , $ sLabel = null , $ mValue = null , $ mOptions = null ) { if ( $ mType instanceof Container ) { $ this -> _aElement [ $ sName ] = $ mType ; } else if ( $ mType === 'text' || $ mType === 'submit' || $ mType === 'password' || $ mType === 'file' || $ mType === 'tel' || $ mType === 'url' || $ mType === 'email' || $ mType === 'search' || $ mType === 'date' || $ mType === 'time' || $ mType === 'datetime' || $ mType === 'month' || $ mType === 'week' || $ mType === 'number' || $ mType === 'range' || $ mType === 'color' || $ mType === 'hidden' ) { $ this -> _aElement [ $ sName ] = new Input ( $ sName , $ mType , $ sLabel , $ mValue ) ; } elseif ( $ mType === 'textarea' ) { $ this -> _aElement [ $ sName ] = new Textarea ( $ sName , $ sLabel , $ mValue ) ; } else if ( $ mType === 'select' ) { $ this -> _aElement [ $ sName ] = new Select ( $ sName , $ mOptions , $ sLabel , $ mValue ) ; } else if ( $ mType === 'label' ) { $ this -> _aElement [ $ sName ] = new Label ( $ sName ) ; } else if ( $ mType === 'list_checkbox' ) { $ i = 0 ; $ this -> _aElement [ $ sName . '_' . $ i ++ ] = new Label ( $ sLabel ) ; foreach ( $ mValue as $ mKey => $ sValue ) { $ this -> _aElement [ $ sName . '_' . $ i ++ ] = new Checkbox ( $ sName , $ sValue , $ mKey , $ mOptions ) ; } } else if ( $ mType === 'checkbox' ) { $ this -> _aElement [ $ sName ] = new Checkbox ( $ sName , $ sLabel , $ mValue , $ mOptions ) ; } else if ( $ mType === 'radio' ) { $ this -> _aElement [ $ sName . rand ( 100000 , 999999 ) ] = new Radio ( $ sName , $ sLabel , $ mValue , $ mOptions ) ; } return $ this ; }
1596	protected function validateAttributes ( ) : bool { if ( ! $ this -> dataHas ( 'attributes' ) ) { return true ; } $ attrs = $ this -> dataGet ( 'attributes' ) ; if ( ! is_object ( $ attrs ) ) { $ this -> memberNotObject ( '/data' , 'attributes' ) ; return false ; } $ disallowed = collect ( [ 'type' , 'id' ] ) -> filter ( function ( $ field ) use ( $ attrs ) { return property_exists ( $ attrs , $ field ) ; } ) ; $ this -> memberFieldsNotAllowed ( '/data' , 'attributes' , $ disallowed ) ; return $ disallowed -> isEmpty ( ) ; }
4043	public function addAdditionalParentHeaderFields ( GetParentHeaderEvent $ event ) { $ parentModel = $ event -> getModel ( ) ; if ( ! $ parentModel instanceof Model ) { return ; } $ environment = $ event -> getEnvironment ( ) ; $ definition = $ environment -> getDataDefinition ( ) ; $ item = $ parentModel -> getItem ( ) ; $ metaModel = $ item -> getMetaModel ( ) ; $ renderSetting = $ this -> renderSettingFactory -> createCollection ( $ metaModel , $ definition -> getMetaModelDefinition ( ) -> getActiveRenderSetting ( ) ) ; $ additional = array ( ) ; foreach ( $ renderSetting -> getSettingNames ( ) as $ name ) { $ parsed = $ item -> parseAttribute ( $ name , 'text' , $ renderSetting ) ; $ name = $ item -> getAttribute ( $ name ) -> getName ( ) ; $ additional [ $ name ] = $ parsed [ 'text' ] ; } $ additional = array_merge ( $ additional , $ event -> getAdditional ( ) ) ; $ event -> setAdditional ( $ additional ) ; }
5667	public function getType ( $ value ) { if ( ! isset ( $ value ) ) { return 'Null' ; } elseif ( is_bool ( $ value ) ) { return 'Boolean' ; } elseif ( is_string ( $ value ) ) { return 'String' ; } elseif ( is_integer ( $ value ) ) { return 'Integer' ; } elseif ( is_float ( $ value ) ) { return 'Float' ; } elseif ( is_array ( $ value ) ) { return 'Array' ; } elseif ( is_resource ( $ value ) ) { return 'Resource' ; } elseif ( is_object ( $ value ) ) { return 'Object' ; } return 'Unknown' ; }
4176	public function getFacades ( ) { return $ this -> facades ? : $ this -> facades = new Facade ( clone $ this -> getFiles ( ) , $ this -> console ) ; }
8714	public function whereSubQuery ( $ column , $ query , $ boolean = 'and' ) { list ( $ type , $ operator ) = [ 'Sub' , 'in' ] ; $ this -> wheres [ ] = compact ( 'type' , 'column' , 'operator' , 'query' , 'boolean' ) ; $ this -> addBinding ( $ query -> getBindings ( ) , 'where' ) ; return $ this ; }
4360	public static function dump ( $ str , $ useHtml = false , $ sanitizeNonBinary = false ) { self :: $ useHtml = $ useHtml ; self :: $ sanitizeNonBinary = $ sanitizeNonBinary ; self :: setStr ( $ str ) ; $ controlCharAs = 'other' ; $ curBlockType = 'utf8' ; $ newBlockType = null ; $ curBlockStart = 0 ; $ strNew = '' ; while ( self :: $ curI < self :: $ stats [ 'strLen' ] ) { $ curI = self :: $ curI ; $ isUtf8 = self :: isOffsetUtf8 ( $ isSpecial , true ) ; if ( $ isUtf8 && $ isSpecial && $ controlCharAs !== 'utf8special' && \ ord ( $ str [ $ curI ] ) < 0x80 ) { if ( $ controlCharAs == 'other' ) { $ isUtf8 = false ; } elseif ( $ controlCharAs == 'utf8' ) { $ isSpecial = false ; } } if ( $ isUtf8 ) { if ( $ isSpecial ) { if ( $ curBlockType !== 'utf8special' ) { $ newBlockType = 'utf8special' ; } } else { if ( $ curBlockType !== 'utf8' ) { $ newBlockType = 'utf8' ; } } } else { if ( $ curBlockType !== 'other' ) { $ newBlockType = 'other' ; } } if ( $ newBlockType ) { $ len = $ curI - $ curBlockStart ; self :: incStat ( $ curBlockType , $ len ) ; $ subStr = \ substr ( self :: $ str , $ curBlockStart , $ len ) ; $ strNew .= self :: dumpBlock ( $ subStr , $ curBlockType ) ; $ curBlockStart = $ curI ; $ curBlockType = $ newBlockType ; $ newBlockType = null ; } } $ len = self :: $ stats [ 'strLen' ] - $ curBlockStart ; self :: incStat ( $ curBlockType , $ len ) ; if ( self :: $ stats [ 'strLen' ] ) { $ percentOther = ( self :: $ stats [ 'bytesOther' ] ) / self :: $ stats [ 'strLen' ] * 100 ; if ( $ percentOther > 33 ) { $ strNew = self :: dumpBlock ( $ str , 'other' , array ( 'prefix' => false ) ) ; } else { $ subStr = \ substr ( self :: $ str , $ curBlockStart , $ len ) ; $ strNew .= self :: dumpBlock ( $ subStr , $ curBlockType ) ; } } return $ strNew ; }
11691	public function getData ( $ origin ) { return array_reduce ( $ this -> structure -> getChildren ( ) , function ( $ acc , $ childDef ) { return array_merge ( $ acc , array ( $ childDef [ 'name' ] => $ childDef [ 'name' ] ) ) ; } , $ this -> getMetadataValues ( ) ) ; }
5433	public function isAbstractMethodInParents ( $ name ) { $ interface = new ReflectionClass ( $ this -> interface ) ; $ parent = $ interface -> getParentClass ( ) ; while ( $ parent ) { if ( ! $ parent -> hasMethod ( $ name ) ) { return false ; } if ( $ parent -> getMethod ( $ name ) -> isAbstract ( ) ) { return true ; } $ parent = $ parent -> getParentClass ( ) ; } return false ; }
1985	public function getOptionsForUser ( BackendUser $ user ) : array { $ this -> loadOptions ( ) ; if ( $ user -> isAdmin ) { $ event = new ImageSizesEvent ( $ this -> options , $ user ) ; } else { $ options = array_map ( static function ( $ val ) { return is_numeric ( $ val ) ? ( int ) $ val : $ val ; } , StringUtil :: deserialize ( $ user -> imageSizes , true ) ) ; $ event = new ImageSizesEvent ( $ this -> filterOptions ( $ options ) , $ user ) ; } $ this -> eventDispatcher -> dispatch ( ContaoCoreEvents :: IMAGE_SIZES_USER , $ event ) ; return $ event -> getImageSizes ( ) ; }
5901	public function listGroups ( $ includeDeleted = false , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'includeDeleted' => $ includeDeleted ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/accounts/groups' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new Group ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
1812	public function getForms ( ) { if ( ! $ this -> User -> isAdmin && ! \ is_array ( $ this -> User -> forms ) ) { return array ( ) ; } $ arrForms = array ( ) ; $ objForms = $ this -> Database -> execute ( "SELECT id, title FROM tl_form ORDER BY title" ) ; while ( $ objForms -> next ( ) ) { if ( $ this -> User -> hasAccess ( $ objForms -> id , 'forms' ) ) { $ arrForms [ $ objForms -> id ] = $ objForms -> title . ' (ID ' . $ objForms -> id . ')' ; } } return $ arrForms ; }
138	public function update ( RepositoryInterface $ repo , UpdateOperation $ operation ) { $ initial = $ operation -> getInitialPackage ( ) ; $ target = $ operation -> getTargetPackage ( ) ; $ initialType = $ initial -> getType ( ) ; $ targetType = $ target -> getType ( ) ; if ( $ initialType === $ targetType ) { $ installer = $ this -> getInstaller ( $ initialType ) ; $ installer -> update ( $ repo , $ initial , $ target ) ; $ this -> markForNotification ( $ target ) ; } else { $ this -> getInstaller ( $ initialType ) -> uninstall ( $ repo , $ initial ) ; $ this -> getInstaller ( $ targetType ) -> install ( $ repo , $ target ) ; } }
8587	public function setLowestOfferListing ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'LowestOfferListing' ] [ 'FieldValue' ] = $ value ; return $ this ; }
9421	public function getContents ( ) { if ( is_null ( $ this -> stream ) || ! $ this -> isReadable ( ) ) { $ message = 'Could not get contents of stream' ; throw new \ RuntimeException ( $ message ) ; } return stream_get_contents ( $ this -> stream ) ; }
1789	public function pasteArticle ( Contao \ DataContainer $ dc , $ row , $ table , $ cr , $ arrClipboard = null ) { $ imagePasteAfter = Contao \ Image :: getHtml ( 'pasteafter.svg' , sprintf ( $ GLOBALS [ 'TL_LANG' ] [ $ dc -> table ] [ 'pasteafter' ] [ 1 ] , $ row [ 'id' ] ) ) ; $ imagePasteInto = Contao \ Image :: getHtml ( 'pasteinto.svg' , sprintf ( $ GLOBALS [ 'TL_LANG' ] [ $ dc -> table ] [ 'pasteinto' ] [ 1 ] , $ row [ 'id' ] ) ) ; if ( $ table == $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'config' ] [ 'ptable' ] ) { return ( $ row [ 'type' ] == 'root' || ! $ this -> User -> isAllowed ( Contao \ BackendUser :: CAN_EDIT_ARTICLE_HIERARCHY , $ row ) || $ cr ) ? Contao \ Image :: getHtml ( 'pasteinto_.svg' ) . ' ' : '<a href="' . $ this -> addToUrl ( 'act=' . $ arrClipboard [ 'mode' ] . '&amp;mode=2&amp;pid=' . $ row [ 'id' ] . ( ! \ is_array ( $ arrClipboard [ 'id' ] ) ? '&amp;id=' . $ arrClipboard [ 'id' ] : '' ) ) . '" title="' . Contao \ StringUtil :: specialchars ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ $ dc -> table ] [ 'pasteinto' ] [ 1 ] , $ row [ 'id' ] ) ) . '" onclick="Backend.getScrollOffset()">' . $ imagePasteInto . '</a> ' ; } $ objPage = Contao \ PageModel :: findById ( $ row [ 'pid' ] ) ; return ( ( $ arrClipboard [ 'mode' ] == 'cut' && $ arrClipboard [ 'id' ] == $ row [ 'id' ] ) || ( $ arrClipboard [ 'mode' ] == 'cutAll' && \ in_array ( $ row [ 'id' ] , $ arrClipboard [ 'id' ] ) ) || ! $ this -> User -> isAllowed ( Contao \ BackendUser :: CAN_EDIT_ARTICLE_HIERARCHY , $ objPage -> row ( ) ) || $ cr ) ? Contao \ Image :: getHtml ( 'pasteafter_.svg' ) . ' ' : '<a href="' . $ this -> addToUrl ( 'act=' . $ arrClipboard [ 'mode' ] . '&amp;mode=1&amp;pid=' . $ row [ 'id' ] . ( ! \ is_array ( $ arrClipboard [ 'id' ] ) ? '&amp;id=' . $ arrClipboard [ 'id' ] : '' ) ) . '" title="' . Contao \ StringUtil :: specialchars ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ $ dc -> table ] [ 'pasteafter' ] [ 1 ] , $ row [ 'id' ] ) ) . '" onclick="Backend.getScrollOffset()">' . $ imagePasteAfter . '</a> ' ; }
5607	public function paintGroupEnd ( $ group ) { $ this -> group = '' ; $ cc = '' ; if ( $ this -> cc ) { if ( extension_loaded ( 'xdebug' ) ) { $ arrfiles = xdebug_get_code_coverage ( ) ; xdebug_stop_code_coverage ( ) ; $ thisdir = dirname ( __FILE__ ) ; $ thisdirlen = strlen ( $ thisdir ) ; foreach ( $ arrfiles as $ index => $ file ) { if ( substr ( $ index , 0 , $ thisdirlen ) === $ thisdir ) { continue ; } $ lcnt = 0 ; $ ccnt = 0 ; foreach ( $ file as $ line ) { if ( $ line == - 2 ) { continue ; } $ lcnt ++ ; if ( $ line == 1 ) { $ ccnt ++ ; } } if ( $ lcnt > 0 ) { $ cc .= round ( ( $ ccnt / $ lcnt ) * 100 , 2 ) . '%' ; } else { $ cc .= '0.00%' ; } $ cc .= "\t" . $ index . "\n" ; } } } $ this -> listener -> write ( '{status:"coverage",message:"' . self :: escapeVal ( $ cc ) . '"}' ) ; }
10906	public function remove ( ) : bool { if ( $ this -> test ( \ sndsgd \ Fs :: EXISTS | \ sndsgd \ Fs :: READABLE | \ sndsgd \ Fs :: WRITABLE ) === false ) { $ this -> error = "failed to remove directory; {$this->error}" ; return false ; } foreach ( $ this -> getList ( ) as $ entity ) { if ( $ entity -> remove ( ) === false ) { $ this -> error = $ entity -> getError ( ) ; return false ; } } if ( @ rmdir ( $ this -> path ) === false ) { $ this -> setError ( "failed to remove directory '{$this->path}'" ) ; return false ; } return true ; }
9916	public function configure ( array $ modelConfigurations ) { if ( empty ( $ modelConfigurations ) ) { throw new \ LogicException ( 'Supply at least one model or model configuration!' ) ; } foreach ( $ modelConfigurations as $ className ) { $ modelClass = $ className ; if ( is_subclass_of ( $ className , 'Illuminate\Database\Eloquent\Model' ) ) { $ config = new ModelConfig ( ) ; $ config -> setModelClass ( $ modelClass ) ; } else if ( is_subclass_of ( $ className , 'Label305\AujaLaravel\Config\ModelConfig' ) ) { $ config = new $ className ( ) ; $ modelClass = $ config -> getModelClass ( ) ; } else { throw new \ InvalidArgumentException ( "Model configuration should be class name string of either a ModelConfig or Eloquent subclass." ) ; } $ model = new Model ( $ modelClass ) ; $ this -> models [ $ modelClass ] = $ model ; $ this -> relations [ $ modelClass ] = [ ] ; $ configResolver = new ConfigResolver ( $ config , $ model ) ; $ this -> configs [ $ modelClass ] = $ configResolver -> resolve ( ) ; $ this -> findColumns ( $ this -> models [ $ modelClass ] ) ; $ this -> configs [ $ modelClass ] = $ configResolver -> resolve ( ) ; } $ this -> findRelations ( array_values ( $ this -> models ) ) ; }
7486	public function indexOf ( $ string , $ offset = null ) { $ string = static :: convertString ( $ string , $ this -> encoding ) ; $ offset = $ offset !== null ? ( int ) $ offset : null ; if ( $ offset !== null && ( $ offset < 0 || $ offset >= $ this -> length ( ) ) ) { throw new \ OutOfBoundsException ( ) ; } return mb_strpos ( $ this -> string , $ string , $ offset , $ this -> encoding ) ; }
5679	protected function noResponse ( ) { $ this -> transport_error = 'No page fetched yet' ; $ this -> raw = false ; $ this -> sent = false ; $ this -> headers = false ; $ this -> method = 'GET' ; $ this -> url = false ; $ this -> request_data = false ; }
11986	function read ( $ length ) { $ l = $ this -> pos + $ length < strlen ( $ this -> data ) ? $ length : strlen ( $ this -> data ) - $ this -> pos ; $ result = substr ( $ this -> data , $ this -> pos , $ l ) ; $ this -> pos += $ l ; return $ result ; }
10200	private function writeXfStyles ( XMLWriter $ writer , Spreadsheet $ spreadsheet ) { foreach ( $ spreadsheet -> getCellXfCollection ( ) as $ style ) { $ writer -> startElement ( 'style:style' ) ; $ writer -> writeAttribute ( 'style:name' , self :: CELL_STYLE_PREFIX . $ style -> getIndex ( ) ) ; $ writer -> writeAttribute ( 'style:family' , 'table-cell' ) ; $ writer -> writeAttribute ( 'style:parent-style-name' , 'Default' ) ; $ writer -> startElement ( 'style:text-properties' ) ; $ font = $ style -> getFont ( ) ; if ( $ font -> getBold ( ) ) { $ writer -> writeAttribute ( 'fo:font-weight' , 'bold' ) ; $ writer -> writeAttribute ( 'style:font-weight-complex' , 'bold' ) ; $ writer -> writeAttribute ( 'style:font-weight-asian' , 'bold' ) ; } if ( $ font -> getItalic ( ) ) { $ writer -> writeAttribute ( 'fo:font-style' , 'italic' ) ; } if ( $ color = $ font -> getColor ( ) ) { $ writer -> writeAttribute ( 'fo:color' , sprintf ( '#%s' , $ color -> getRGB ( ) ) ) ; } if ( $ family = $ font -> getName ( ) ) { $ writer -> writeAttribute ( 'fo:font-family' , $ family ) ; } if ( $ size = $ font -> getSize ( ) ) { $ writer -> writeAttribute ( 'fo:font-size' , sprintf ( '%.1fpt' , $ size ) ) ; } if ( $ font -> getUnderline ( ) && $ font -> getUnderline ( ) != Font :: UNDERLINE_NONE ) { $ writer -> writeAttribute ( 'style:text-underline-style' , 'solid' ) ; $ writer -> writeAttribute ( 'style:text-underline-width' , 'auto' ) ; $ writer -> writeAttribute ( 'style:text-underline-color' , 'font-color' ) ; switch ( $ font -> getUnderline ( ) ) { case Font :: UNDERLINE_DOUBLE : $ writer -> writeAttribute ( 'style:text-underline-type' , 'double' ) ; break ; case Font :: UNDERLINE_SINGLE : $ writer -> writeAttribute ( 'style:text-underline-type' , 'single' ) ; break ; } } $ writer -> endElement ( ) ; $ writer -> startElement ( 'style:table-cell-properties' ) ; $ writer -> writeAttribute ( 'style:rotation-align' , 'none' ) ; if ( $ fill = $ style -> getFill ( ) ) { switch ( $ fill -> getFillType ( ) ) { case Fill :: FILL_SOLID : $ writer -> writeAttribute ( 'fo:background-color' , sprintf ( '#%s' , strtolower ( $ fill -> getStartColor ( ) -> getRGB ( ) ) ) ) ; break ; case Fill :: FILL_GRADIENT_LINEAR : case Fill :: FILL_GRADIENT_PATH : break ; case Fill :: FILL_NONE : default : } } $ writer -> endElement ( ) ; $ writer -> endElement ( ) ; } }
2227	public function editHeader ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { return $ this -> User -> canEditFieldsOf ( 'tl_faq_category' ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' ; }
9760	function containOnly ( string $ type ) : self { return $ this -> expect ( $ this -> target , containsOnly ( $ type ) ) ; }
5809	public function updateSearchForm ( $ form ) { Requirements :: javascript ( FUSION_PATH . '/javascript/fusion.js' ) ; $ form -> Fields ( ) -> insertBefore ( ListboxField :: create ( 'q[Tagging]' , 'Tags' , FusionTag :: get ( ) -> map ( 'Title' , 'Title' ) -> toArray ( ) , ( ( $ filtering = $ this -> owner -> getRequest ( ) -> getVar ( 'q' ) ) && isset ( $ filtering [ 'Tagging' ] ) ) ? $ filtering [ 'Tagging' ] : array ( ) , null , true ) , 'q[Term]' ) ; $ this -> owner -> extend ( 'updateCMSMainTaggingExtensionSearchForm' , $ form ) ; }
7166	private function buildShipmentLine ( Model \ SaleInterface $ sale ) { if ( null === $ sale -> getShipmentMethod ( ) && ! $ this -> options [ 'private' ] ) { return ; } $ lineNumber = $ this -> lineNumber ++ ; $ view = new LineView ( 'shipment' , 'shipment' , $ lineNumber , 0 ) ; $ designation = 'Shipping cost' ; if ( null !== $ method = $ sale -> getShipmentMethod ( ) ) { $ designation = $ method -> getTitle ( ) ; } $ designation .= ' (' . $ this -> formatter -> number ( $ sale -> getWeightTotal ( ) ) . ' kg)' ; $ result = $ sale -> getShipmentResult ( ) ; $ view -> setDesignation ( $ designation ) -> setBase ( $ this -> formatter -> currency ( $ result -> getBase ( ) ) ) -> setTaxRates ( $ this -> formatter -> rates ( ... $ result -> getTaxAdjustments ( ) ) ) -> setTaxAmount ( $ this -> formatter -> currency ( $ result -> getTax ( ) ) ) -> setTotal ( $ this -> formatter -> currency ( $ result -> getTotal ( ) ) ) ; foreach ( $ this -> types as $ type ) { $ type -> buildShipmentView ( $ sale , $ view , $ this -> options ) ; } $ this -> view -> setShipment ( $ view ) ; }
6519	private function unFreeze ( ) { $ this -> isFrozen = false ; $ this -> isReplay = null ; foreach ( static :: schema ( ) -> getFields ( ) as $ field ) { if ( $ field -> getType ( ) -> isMessage ( ) ) { $ value = $ this -> get ( $ field -> getName ( ) ) ; if ( empty ( $ value ) ) { continue ; } if ( $ value instanceof Message ) { $ value -> unFreeze ( ) ; continue ; } foreach ( $ value as $ v ) { $ v -> unFreeze ( ) ; } } } }
1572	public function getProcess ( ) : ? AsynchronousProcess { $ process = $ this -> parameter ( ResourceRegistrar :: PARAM_PROCESS_ID ) ; return ( $ process instanceof AsynchronousProcess ) ? $ process : null ; }
3218	function chunkedUploadFinish ( $ uploadId , $ path , $ writeMode ) { Checker :: argStringNonEmpty ( "uploadId" , $ uploadId ) ; Path :: checkArgNonRoot ( "path" , $ path ) ; WriteMode :: checkArg ( "writeMode" , $ writeMode ) ; $ params = array_merge ( array ( "upload_id" => $ uploadId ) , $ writeMode -> getExtraParams ( ) ) ; $ response = $ this -> doPost ( $ this -> contentHost , $ this -> appendFilePath ( "1/commit_chunked_upload" , $ path ) , $ params ) ; if ( $ response -> statusCode === 404 ) return null ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; return RequestUtil :: parseResponseJson ( $ response -> body ) ; }
8258	protected function finishAuthentication ( Request $ httpRequest ) { $ sessionCode = $ this -> session -> get ( "oauth2state" ) ; $ this -> session -> remove ( "oauth2state" ) ; if ( $ httpRequest -> query -> get ( "state" ) !== $ sessionCode ) { $ this -> onStateMismatch ( ) ; } if ( $ httpRequest -> query -> has ( "error" ) ) { $ this -> onOAuthError ( $ httpRequest -> query -> get ( "error" ) ) ; } if ( ! $ httpRequest -> query -> has ( "code" ) ) { $ this -> onOAuthError ( "no_code" ) ; } try { $ accessToken = $ this -> provider -> getAccessToken ( 'authorization_code' , [ 'code' => $ httpRequest -> query -> get ( "code" ) , ] ) ; $ resourceOwner = $ this -> provider -> getResourceOwner ( $ accessToken ) ; $ this -> saveLoginInfo ( $ resourceOwner ) ; } catch ( IdentityProviderException $ e ) { $ this -> onOauthResourceError ( $ e ) ; } }
8752	public function addDefinition ( $ identifier , DefinitionInterface $ definition ) { $ this -> definitions [ $ identifier ] = $ definition ; unset ( $ this -> dumpableDefinitions [ $ identifier ] ) ; }
8762	public function upload ( $ input ) { $ validator = \ Validator :: make ( $ input , config ( 'dropzoner.validator' ) , config ( 'dropzoner.validator-messages' ) ) ; if ( $ validator -> fails ( ) ) { return response ( ) -> json ( [ 'error' => true , 'message' => $ validator -> messages ( ) -> first ( ) , 'code' => 400 ] , 400 ) ; } $ photo = $ input [ 'file' ] ; $ original_name = $ photo -> getClientOriginalName ( ) ; $ extension = $ photo -> getClientOriginalExtension ( ) ; $ original_name_without_extension = substr ( $ original_name , 0 , strlen ( $ original_name ) - strlen ( $ extension ) - 1 ) ; $ filename = $ this -> sanitize ( $ original_name_without_extension ) ; $ allowed_filename = $ this -> createUniqueFilename ( $ filename ) ; $ filename_with_extension = $ allowed_filename . '.' . $ extension ; $ manager = new ImageManager ( ) ; $ image = $ manager -> make ( $ photo ) -> save ( config ( 'dropzoner.upload-path' ) . $ filename_with_extension ) ; if ( ! $ image ) { return response ( ) -> json ( [ 'error' => true , 'message' => 'Server error while uploading' , 'code' => 500 ] , 500 ) ; } event ( new ImageWasUploaded ( $ original_name , $ filename_with_extension ) ) ; return response ( ) -> json ( [ 'error' => false , 'code' => 200 , 'filename' => $ filename_with_extension ] , 200 ) ; }
6043	public function addUsage ( $ sessionId , MediaUsage $ mediaUsage ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'sessionId' => $ sessionId , 'mediaUsage' => $ mediaUsage ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/events/usage' , $ parameters ) ; $ result = new MediaUsageResponse ( $ result ) ; return $ result ; }
6609	public static function getIdByField ( $ field , $ value ) { $ result = self :: find ( ) -> where ( [ $ field => $ value ] ) -> limit ( 1 ) -> one ( ) ; return ( $ result ) ? $ result -> id : null ; }
3525	public function lookup ( $ username ) { try { $ data = FortniteClient :: sendFortniteGetRequest ( FortniteClient :: FORTNITE_PERSONA_API . 'public/account/lookup?q=' . urlencode ( $ username ) , $ this -> access_token ) ; return new self ( $ this -> access_token , $ data -> id ) ; } catch ( GuzzleException $ e ) { if ( $ e -> getResponse ( ) -> getStatusCode ( ) == 404 ) throw new UserNotFoundException ( 'User ' . $ username . ' was not found.' ) ; throw $ e ; } }
2410	public function getDbInstallerArray ( ) { $ return = array ( ) ; foreach ( $ this -> arrFields as $ k => $ v ) { if ( \ is_array ( $ v ) ) { if ( ! isset ( $ v [ 'name' ] ) ) { $ v [ 'name' ] = $ k ; } $ return [ 'SCHEMA_FIELDS' ] [ $ k ] = $ v ; } else { $ return [ 'TABLE_FIELDS' ] [ $ k ] = '`' . $ k . '` ' . $ v ; } } $ quote = function ( $ item ) { return '`' . $ item . '`' ; } ; foreach ( $ this -> arrKeys as $ k => $ v ) { if ( strpos ( $ k , ',' ) !== false ) { $ f = array_map ( $ quote , StringUtil :: trimsplit ( ',' , $ k ) ) ; $ k = str_replace ( ',' , '_' , $ k ) ; } else { $ f = array ( $ quote ( $ k ) ) ; } if ( $ v == 'primary' ) { $ k = 'PRIMARY' ; $ v = 'PRIMARY KEY (' . implode ( ', ' , $ f ) . ')' ; } elseif ( $ v == 'index' ) { $ v = 'KEY `' . $ k . '` (' . implode ( ', ' , $ f ) . ')' ; } else { $ v = strtoupper ( $ v ) . ' KEY `' . $ k . '` (' . implode ( ', ' , $ f ) . ')' ; } $ return [ 'TABLE_CREATE_DEFINITIONS' ] [ $ k ] = $ v ; } $ return [ 'TABLE_OPTIONS' ] = '' ; foreach ( $ this -> arrMeta as $ k => $ v ) { if ( $ k == 'engine' ) { $ return [ 'TABLE_OPTIONS' ] .= ' ENGINE=' . $ v ; } elseif ( $ k == 'charset' ) { $ return [ 'TABLE_OPTIONS' ] .= ' DEFAULT CHARSET=' . $ v ; } elseif ( $ k == 'collate' ) { $ return [ 'TABLE_OPTIONS' ] .= ' COLLATE ' . $ v ; } } return $ return ; }
1445	protected function isEloquent ( ) { if ( $ this -> isIndependent ) { return false ; } if ( $ this -> option ( 'no-eloquent' ) ) { return false ; } return $ this -> option ( 'eloquent' ) ? : $ this -> getApi ( ) -> isEloquent ( ) ; }
1293	private function getTokenFromResponse ( array $ data ) : string { $ url = $ data [ 'nextSyncUrl' ] ?? $ data [ 'nextPageUrl' ] ; $ queryValues = [ ] ; \ parse_str ( \ parse_url ( $ url , \ PHP_URL_QUERY ) , $ queryValues ) ; return $ queryValues [ 'sync_token' ] ; }
9403	public static function get ( ContainerInterface $ container , array $ components = array ( ) , & $ globals = null ) { $ configuration = new Configuration ; $ collection = new Collection ; foreach ( ( array ) $ components as $ component ) { $ instance = self :: prepare ( $ collection , $ component ) ; $ container = $ instance -> define ( $ container , $ configuration ) ; } $ collection -> setContainer ( $ container ) ; $ globals === null || $ globals [ 'container' ] = $ container ; return $ collection ; }
4119	public static function addType ( $ name , $ className ) { if ( isset ( self :: $ _typesMap [ $ name ] ) ) { throw TypeException :: typeExists ( $ name ) ; } self :: $ _typesMap [ $ name ] = $ className ; }
1147	protected function isConditionalRule ( $ attribute , $ rule ) { return isset ( $ this -> conditional [ $ attribute ] ) && in_array ( $ rule , $ this -> conditional [ $ attribute ] ) ; }
8419	public static function get ( string $ alias ) { if ( isset ( self :: $ databases [ $ alias ] ) === false ) { throw new DatabaseNotFound ( 'database "' . $ alias . '" doesn\'t seem to be registered' ) ; } return self :: $ databases [ $ alias ] ; }
10376	protected static function look_if_process_files ( $ type ) { if ( is_string ( self :: $ unify ) || isset ( self :: $ unify [ "{$type}s" ] ) ) { return self :: unify_files ( self :: prepare_files ( $ type ) ) ; } }
11849	protected function getSettingsFromRealSource ( $ namespace ) { $ arraySettings = $ this -> getSettingsArray ( $ namespace ) ; $ namespaceOptions = $ this -> options -> getNamespaceOptions ( $ namespace ) ; $ entity = clone ( $ namespaceOptions -> getEntityPrototype ( ) ) ; if ( ! empty ( $ arraySettings ) ) { $ hydrator = $ this -> namespaceHydratorProvider -> getHydrator ( $ namespace ) ; $ entity = $ hydrator -> hydrate ( $ arraySettings , $ entity ) ; } return $ entity ; }
5012	public function injectLogger ( bool $ flag = null ) : bool { if ( null === $ flag ) { return $ this -> injectLogger ; } $ this -> injectLogger = $ flag ; return $ flag ; }
10372	public static function add_styles ( ) { self :: look_if_process_files ( 'style' ) ; foreach ( self :: $ data [ 'style' ] as $ data ) { wp_register_style ( $ data [ 'name' ] , $ data [ 'url' ] , $ data [ 'deps' ] , $ data [ 'version' ] , $ data [ 'media' ] ) ; wp_enqueue_style ( $ data [ 'name' ] ) ; } }
4703	protected function lint ( OutputInterface $ output , Ciconia $ ciconia , $ content ) { try { $ ciconia -> render ( $ content , array ( 'strict' => true ) ) ; $ output -> writeln ( 'No syntax errors detected.' ) ; return 0 ; } catch ( SyntaxError $ e ) { $ output -> writeln ( '<error>' . $ e -> getMessage ( ) . '</error>' ) ; return 1 ; } }
2838	public function getRequestInfo ( ) { if ( $ this -> requestInfo === null ) { $ this -> requestInfo = Mage :: registry ( 'sheep_debug_request_info' ) ; } return $ this -> requestInfo ; }
9053	private function recursiveMenuItemHandling ( Collection $ menuItems ) { $ data = [ ] ; foreach ( $ menuItems as $ menuItem ) { if ( ! in_array ( $ menuItem -> getId ( ) , $ this -> alreadySetIds ) ) { $ this -> alreadySetIds [ ] = $ menuItem -> getId ( ) ; $ itemNode = [ ] ; $ itemNode [ 'name' ] = $ menuItem -> getTitle ( ) ; $ itemNode [ 'url' ] = $ menuItem -> getTarget ( ) ; $ itemNode [ 'id' ] = $ this -> position ; $ itemNode [ 'persist_id' ] = $ menuItem -> getId ( ) ; if ( null === $ menuItem -> getParent ( ) ) { $ itemNode [ 'owner_type' ] = get_class ( $ this -> currentOwner ) ; $ itemNode [ 'owner_id' ] = $ this -> currentOwner -> getId ( ) ; } $ this -> position ++ ; if ( $ menuItem -> getChildren ( ) -> count ( ) > 0 ) { $ itemNode [ 'children' ] = $ this -> recursiveMenuItemHandling ( $ menuItem -> getChildren ( ) ) ; } $ data [ ] = $ itemNode ; } } return $ data ; }
10466	public function onModify ( ItemPipelineEvent $ event ) { $ item = $ event -> getItem ( ) ; if ( $ item instanceof ImportItem ) { $ this -> modify ( $ item , $ event ) ; } elseif ( $ item instanceof SyncExecuteItem ) { $ syncStorageData = $ item -> getSyncStorageData ( ) ; if ( $ syncStorageData [ 'type' ] !== ActionTypes :: DELETE ) { $ this -> modify ( $ item , $ event ) ; } else { ItemSkipper :: skip ( $ event , 'Delete item with id = ' . $ syncStorageData [ 'id' ] ) ; } } else { $ this -> log ( 'The type of provided item is not ImportItem or SyncExecuteItem.' , LogLevel :: ERROR ) ; } }
5132	protected function hasStandardPort ( ) : bool { return ( $ this -> scheme === 'http' && $ this -> port === 80 ) || ( $ this -> scheme === 'https' && $ this -> port === 443 ) ; }
10901	public function loadAll ( array $ where = [ ] , bool $ assoc = false , array $ fields = null ) : Collection { $ allData = $ this -> medoo -> select ( $ this -> getTable ( ) , $ fields ? $ fields : '*' , $ where ) ; $ this -> sentry -> breadcrumbs -> record ( [ 'message' => 'Entity ' . $ this -> __getEntityName ( ) . '::loadAll(' . \ print_r ( $ where , true ) . ', ' . $ assoc . ', ' . \ print_r ( $ fields , true ) . ')' , 'data' => [ 'query' => $ this -> medoo -> last ( ) ] , 'category' => 'Database' , 'level' => 'info' , ] ) ; $ items = [ ] ; foreach ( $ allData as $ data ) { $ items [ ] = ( $ assoc ) ? $ data : $ this -> container [ 'entity' ] ( $ this -> __getEntityName ( ) ) -> setData ( $ data ) ; } return new Collection ( $ items ) ; }
12568	public function preview ( $ msgType , $ message , $ to , $ by = self :: PREVIEW_BY_OPENID ) { $ message = ( new MessageBuilder ( ) ) -> msgType ( $ msgType ) -> message ( $ message ) -> to ( $ to ) -> buildPreview ( $ by ) ; return $ this -> post ( self :: API_PREVIEW , $ message ) ; }
7811	private static function filterArray ( $ needle , $ heystack , $ always = array ( ) ) { foreach ( $ heystack as $ k => $ v ) { if ( ! in_array ( $ v , $ needle ) && ! in_array ( $ v , $ always ) ) unset ( $ heystack [ $ k ] ) ; } return $ heystack ; }
6617	protected function mapRequestToArguments ( \ ReflectionMethod $ method , Request $ request ) { $ map = [ ] ; foreach ( $ method -> getParameters ( ) as $ parameter ) { $ value = $ request -> getParameter ( $ parameter -> getName ( ) , $ parameter -> isDefaultValueAvailable ( ) ? $ parameter -> getDefaultValue ( ) : null ) ; if ( $ parameter -> getClass ( ) && $ parameter -> getClass ( ) -> implementsInterface ( Deserializable :: class ) ) { $ value = $ parameter -> getClass ( ) -> newInstanceWithoutConstructor ( ) -> ayeAyeDeserialize ( $ value ) ; $ className = $ parameter -> getClass ( ) -> getName ( ) ; if ( ! is_object ( $ value ) || get_class ( $ value ) !== $ className ) { throw new \ RuntimeException ( "$className::ayeAyeDeserialize did not return an instance of itself" ) ; } } $ map [ $ parameter -> getName ( ) ] = $ value ; } return $ map ; }
10414	public function createTable ( $ connection = null ) { $ connection = $ connection ? : $ this -> connection ; $ schemaManager = $ connection -> getSchemaManager ( ) ; if ( $ schemaManager -> tablesExist ( [ $ this -> tableName ] ) ) { return null ; } $ table = new Table ( $ this -> tableName ) ; $ this -> buildTable ( $ table ) ; $ schemaManager -> createTable ( $ table ) ; return true ; }
9899	private function convertError ( $ errorCode ) { switch ( $ errorCode ) { case '#NULL!' : return pack ( 'C' , 0x00 ) ; case '#DIV/0!' : return pack ( 'C' , 0x07 ) ; case '#VALUE!' : return pack ( 'C' , 0x0F ) ; case '#REF!' : return pack ( 'C' , 0x17 ) ; case '#NAME?' : return pack ( 'C' , 0x1D ) ; case '#NUM!' : return pack ( 'C' , 0x24 ) ; case '#N/A' : return pack ( 'C' , 0x2A ) ; } return pack ( 'C' , 0xFF ) ; }
4665	public function createMessage ( ) { $ eventsManager = $ this -> getEventsManager ( ) ; if ( $ eventsManager ) { $ eventsManager -> fire ( 'mailer:beforeCreateMessage' , $ this ) ; } $ message = $ this -> getDI ( ) -> get ( '\Baka\Mail\Message' , [ $ this ] ) ; if ( ( $ from = $ this -> getConfig ( 'from' ) ) ) { $ message -> from ( $ from [ 'email' ] , isset ( $ from [ 'name' ] ) ? $ from [ 'name' ] : null ) ; } if ( $ eventsManager ) { $ eventsManager -> fire ( 'mailer:afterCreateMessage' , $ this , $ message ) ; } return $ message ; }
12001	static protected function doctrine2Query ( \ Doctrine \ ORM \ EntityManager $ entityManager , $ entityName , $ field , $ generate ) { $ result = $ entityManager -> createQueryBuilder ( ) -> select ( "entity.$field" ) -> from ( $ entityName , 'entity' ) -> where ( "entity.$field = :$field" ) -> setParameter ( "$field" , $ generate ) -> getQuery ( ) -> getResult ( ) ; return ! empty ( $ result ) ; }
9846	public function createSealedRequest ( string $ method , string $ uri , string $ body , SealingPublicKey $ key , array $ headers = [ ] ) : RequestInterface { return new Request ( $ method , Uri :: createFromString ( $ uri ) , new Headers ( $ headers ) , [ ] , [ ] , $ this -> stringToStream ( Base64UrlSafe :: encode ( Simple :: seal ( $ body , $ key ) ) ) , [ ] ) ; }
9427	public function render ( $ template , array $ data = array ( ) , $ extension = 'twig' ) { $ file = $ template . '.' . $ extension ; return $ this -> twig -> render ( $ file , $ data ) ; }
1163	public function validate ( $ field , $ parameters = [ ] ) { $ attribute = $ this -> parseAttributeName ( $ field ) ; $ validationParams = $ this -> parseParameters ( $ parameters ) ; $ validationResult = $ this -> validateJsRemoteRequest ( $ attribute , $ validationParams ) ; $ this -> throwValidationException ( $ validationResult , $ this -> validator ) ; }
8398	public static function getSchema ( string $ mapping ) : Schema { $ data = Mapping :: get ( $ mapping ) ; $ class = rtrim ( ucfirst ( $ data [ 'config' ] [ 'provider' ] ) , '\\' ) . '\\Schema' ; return new $ class ( $ mapping ) ; }
111	public function addPlugin ( PluginInterface $ plugin ) { $ this -> io -> writeError ( 'Loading plugin ' . get_class ( $ plugin ) , true , IOInterface :: DEBUG ) ; $ this -> plugins [ ] = $ plugin ; $ plugin -> activate ( $ this -> composer , $ this -> io ) ; if ( $ plugin instanceof EventSubscriberInterface ) { $ this -> composer -> getEventDispatcher ( ) -> addSubscriber ( $ plugin ) ; } }
9357	public function withoutHeader ( $ name ) { $ instance = clone $ this ; if ( $ this -> hasHeader ( $ name ) ) { $ static = clone $ this ; unset ( $ static -> headers [ $ name ] ) ; $ instance = $ static ; } return $ instance ; }
9755	function a ( string $ type = '' ) : self { return mb_strlen ( $ type ) ? $ this -> expect ( $ this -> target , isType ( $ type ) ) : $ this ; }
2854	public function getFileUpdatesWithHandle ( $ handle , $ storeId , $ area ) { $ updateFiles = Mage :: helper ( 'sheep_debug' ) -> getLayoutUpdatesFiles ( $ storeId , $ area ) ; $ designPackage = Mage :: getModel ( 'core/design_package' ) ; $ designPackage -> setStore ( $ storeId ) ; $ designPackage -> setArea ( $ area ) ; $ designPackageName = $ designPackage -> getPackageName ( ) ; $ layoutTheme = $ designPackage -> getTheme ( 'layout' ) ; $ handleFiles = array ( ) ; foreach ( $ updateFiles as $ file ) { $ filename = $ designPackage -> getLayoutFilename ( $ file , array ( '_area' => $ area , '_package' => $ designPackageName , '_theme' => $ layoutTheme ) ) ; if ( ! is_readable ( $ filename ) ) { continue ; } $ fileXml = $ this -> loadXmlFile ( $ filename ) ; if ( $ fileXml === false ) { continue ; } $ relativeFilename = str_replace ( $ this -> getBaseDir ( ) , '' , $ filename ) ; $ results = $ fileXml -> xpath ( "/layout/{$handle}" ) ; if ( $ results ) { $ handleFiles [ $ relativeFilename ] = array ( ) ; foreach ( $ results as $ result ) { $ handleFiles [ $ relativeFilename ] [ ] = $ result -> asXML ( ) ; } } } return $ handleFiles ; }
760	public function getIsCollection ( ) { return in_array ( $ this -> type , [ self :: TYPE_CODE , self :: TYPE_STATEMENT , self :: TYPE_PARENTHESIS , ] , true ) ; }
2905	public function addEmailToProfile ( $ email , $ name , $ variables , $ result , Zend_Mail $ mail ) { $ emailCapture = Mage :: getModel ( 'sheep_debug/email' ) ; $ subject = $ this -> decodeSubject ( $ mail -> getSubject ( ) ) ; $ body = $ this -> getContent ( $ mail ) ; $ emailCapture -> setFromName ( $ this -> getSenderName ( ) ) ; $ emailCapture -> setFromEmail ( $ this -> getSenderEmail ( ) ) ; $ emailCapture -> setToEmail ( $ email ) ; $ emailCapture -> setToName ( $ name ) ; $ emailCapture -> setSubject ( $ subject ) ; $ emailCapture -> setIsPlain ( $ this -> isPlain ( ) ) ; $ emailCapture -> setBody ( $ body ) ; $ emailCapture -> setIsAccepted ( $ result ) ; $ emailCapture -> setVariables ( $ variables ) ; $ emailCapture -> setIsSmtpDisabled ( ( bool ) Mage :: getStoreConfigFlag ( 'system/smtp/disable' ) ) ; Mage :: getSingleton ( 'sheep_debug/observer' ) -> getRequestInfo ( ) -> addEmail ( $ emailCapture ) ; }
11267	public function view ( $ pathname = '' , $ data = false , $ return = false ) { if ( is_array ( $ data ) || is_object ( $ data ) ) { foreach ( $ data as $ key => $ value ) { $ $ key = $ value ; } } if ( $ pathname == '' ) { $ pathname = $ this -> config [ 'template' ] ; } $ fullPath = $ this -> config [ 'pathToViews' ] . $ this -> getPath ( $ pathname ) ; $ path = $ this -> getPath ( $ pathname ) ; $ this -> debug ( 'Full Path: ' . $ fullPath ) ; $ fileName = $ this -> config [ 'viewsPrefix' ] . $ this -> getName ( $ pathname ) . $ this -> config [ 'viewsPostfix' ] . '.php' ; $ filePath = $ this -> _getFilePath ( $ pathname , $ fileName ) ; $ this -> debug ( '' ) ; $ this -> debug ( 'Searching for View: ' ) ; $ this -> debug ( 'View Name: ' . $ this -> getName ( $ pathname ) ) ; $ this -> debug ( 'View Path: ' . $ this -> getPath ( $ pathname ) ) ; $ this -> debug ( 'File Path: ' . $ filePath ) ; $ this -> debug ( '' ) ; if ( $ return || $ this -> neverOutput ) { ob_start ( ) ; $ inc = include ( $ filePath ) ; if ( $ inc == false && $ this -> config [ 'mode' ] == 'development' ) { throw new \ Exception ( "Can't find file '$fileName' using path '$filePath'" ) ; } return ob_get_clean ( ) ; } else { $ inc = include ( $ filePath ) ; if ( $ inc == false && $ this -> config [ 'mode' ] == 'development' ) { throw new \ Exception ( "Can't find file '$fileName' using path '$filePath'" ) ; } } }
3280	protected function normalizeConfig ( array $ config ) : array { $ defaultConfig = [ 'dir' => getcwd ( ) , 'ext' => '.dat' , 'gzip' => false , 'cache' => true , 'formatter' => null , 'swap_memory_limit' => 2097152 , ] ; return array_replace ( $ defaultConfig , $ config ) ; }
2256	public static function setStaticUrls ( ) { if ( \ defined ( 'TL_FILES_URL' ) ) { return ; } if ( \ func_num_args ( ) > 0 ) { @ trigger_error ( 'Using Controller::setStaticUrls() has been deprecated and will no longer work in Contao 5.0. Use the asset contexts instead.' , E_USER_DEPRECATED ) ; if ( ! isset ( $ GLOBALS [ 'objPage' ] ) ) { $ GLOBALS [ 'objPage' ] = func_get_arg ( 0 ) ; } } \ define ( 'TL_ASSETS_URL' , System :: getContainer ( ) -> get ( 'contao.assets.assets_context' ) -> getStaticUrl ( ) ) ; \ define ( 'TL_FILES_URL' , System :: getContainer ( ) -> get ( 'contao.assets.files_context' ) -> getStaticUrl ( ) ) ; \ define ( 'TL_SCRIPT_URL' , TL_ASSETS_URL ) ; \ define ( 'TL_PLUGINS_URL' , TL_ASSETS_URL ) ; }
1146	public function addConditionalRules ( $ attribute , $ rules = [ ] ) { foreach ( ( array ) $ attribute as $ key ) { $ current = isset ( $ this -> conditional [ $ key ] ) ? $ this -> conditional [ $ key ] : [ ] ; $ merge = head ( $ this -> validator -> explodeRules ( ( array ) $ rules ) ) ; $ this -> conditional [ $ key ] = array_merge ( $ current , $ merge ) ; } }
7791	public function setClosingBalanceClass ( $ closingBalanceClass ) { if ( ! is_callable ( $ closingBalanceClass ) && ! class_exists ( $ closingBalanceClass ) ) { throw new \ InvalidArgumentException ( '$closingBalanceClass must be a valid classname or a PHP callable' ) ; } $ this -> closingBalanceClass = $ closingBalanceClass ; return $ this ; }
2730	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ dictionary = $ this -> api -> getSingleDictionary ( $ activeVersion , Config :: AUTH_DICTIONARY_NAME ) ; $ vclPath = Config :: VCL_AUTH_SNIPPET_PATH ; $ snippets = $ this -> config -> getVclSnippets ( $ vclPath ) ; $ status = true ; foreach ( $ snippets as $ key => $ value ) { $ name = Config :: FASTLY_MAGENTO_MODULE . '_basic_auth_' . $ key ; $ status = $ this -> api -> getSnippet ( $ activeVersion , $ name ) ; if ( ! $ status ) { break ; } } if ( ( is_array ( $ dictionary ) && empty ( $ dictionary ) ) || ! isset ( $ dictionary -> id ) ) { return $ result -> setData ( [ 'status' => 'empty' , 'msg' => 'Authentication dictionary does not exist.' ] ) ; } $ authItems = $ this -> api -> dictionaryItemsList ( $ dictionary -> id ) ; if ( ( $ status == true && is_array ( $ authItems ) && count ( $ authItems ) < 2 ) || $ authItems == false ) { return $ result -> setData ( [ 'status' => 'empty' , 'msg' => 'While Basic Authentication is enabled, at least one user must exist.' , ] ) ; } $ itemKey = $ this -> getRequest ( ) -> getParam ( 'item_key_id' ) ; $ deleteItem = $ this -> api -> deleteDictionaryItem ( $ dictionary -> id , $ itemKey ) ; if ( ! $ deleteItem ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to create Dictionary item.' ] ) ; } return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
5624	public function setCoordinates ( $ x = false , $ y = false ) { if ( ( $ x === false ) || ( $ y === false ) ) { $ this -> x = $ this -> y = false ; return ; } $ this -> x = ( integer ) $ x ; $ this -> y = ( integer ) $ y ; }
5781	private function getSectionForAdministrator ( array $ section , string $ sectionName ) : array { if ( isset ( $ section [ 'authorization' ] ) && ! $ this -> container -> authorization -> isAuthorized ( $ section [ 'authorization' ] ) ) { return [ ] ; } $ updatedSection = [ ] ; foreach ( $ section as $ key => $ value ) { if ( $ key != 'subSections' ) { $ updatedSection [ $ key ] = $ value ; } } $ updatedSubSections = [ ] ; if ( isset ( $ section [ 'subSections' ] ) ) { foreach ( $ section [ 'subSections' ] as $ subSectionName => $ subSection ) { $ updatedSubSection = $ this -> getSectionForAdministrator ( $ subSection , $ subSectionName ) ; if ( count ( $ updatedSubSection ) > 0 ) { $ updatedSubSections [ $ subSectionName ] = $ updatedSubSection ; } } } if ( count ( $ updatedSubSections ) > 0 ) { $ updatedSection [ 'subSections' ] = $ updatedSubSections ; } return $ updatedSection ; }
4063	private static function calculateArrayDiff ( $ expected , $ actual , $ strict ) { if ( count ( $ expected ) !== count ( $ actual ) ) { throw new \ LogicException ( sprintf ( 'Array element count mismatch. Found %s, expected %s.' , count ( $ actual ) , count ( $ expected ) ) , self :: ARRAY_COUNT_MISMATCH ) ; } reset ( $ actual ) ; foreach ( $ expected as $ key => $ value ) { if ( $ key !== key ( $ actual ) ) { throw new \ LogicException ( sprintf ( 'Array key mismatch. Found %s, expected %s.' , key ( $ actual ) , $ key ) , self :: ARRAY_KEY_MISMATCH ) ; } try { self :: calculateDiff ( $ value , current ( $ actual ) , $ strict ) ; } catch ( \ Exception $ exception ) { throw new \ LogicException ( sprintf ( 'Array value mismatch for key %s.' , key ( $ actual ) ) , self :: ARRAY_VALUE_MISMATCH , $ exception ) ; } next ( $ actual ) ; } }
12188	public function getRelatedObject ( $ baseObject , $ baseRole , $ primaryRelation = null ) { $ companionRole = $ this -> companionRole ( $ baseRole ) ; $ companionType = $ this -> companionRoleType ( $ baseRole ) ; $ companionModel = $ companionType -> primaryModel ; if ( ! isset ( $ primaryRelation ) || is_array ( $ primaryRelation ) ) { if ( ! is_array ( $ primaryRelation ) ) { $ primaryRelation = [ ] ; } $ primaryRelation = $ this -> getPrimaryRelation ( $ baseObject , $ baseRole , $ primaryRelation ) ; } if ( ! empty ( $ primaryRelation ) ) { if ( $ companionRole === 'child' ) { return $ primaryRelation -> childObject ; } else { return $ primaryRelation -> parentObject ; } } return false ; }
1736	public function getQrCode ( User $ user , Request $ request ) : string { $ renderer = new ImageRenderer ( new RendererStyle ( 180 , 0 ) , new SvgImageBackEnd ( ) ) ; $ writer = new Writer ( $ renderer ) ; return $ writer -> writeString ( $ this -> getProvisionUri ( $ user , $ request ) ) ; }
5967	public function tempPasswordList ( $ resolve = false ) { $ passwords = $ this -> request ( "servertemppasswordlist" ) -> toAssocArray ( "pw_clear" ) ; if ( $ resolve ) { foreach ( $ passwords as $ password => $ array ) { try { $ channel = $ this -> channelGetById ( $ array [ "tcid" ] ) ; $ passwords [ $ password ] [ "tcname" ] = $ channel -> toString ( ) ; $ passwords [ $ password ] [ "tcpath" ] = $ channel -> getPathway ( ) ; } catch ( Ts3Exception $ e ) { if ( $ e -> getCode ( ) != 0xA00 ) { throw $ e ; } } } } return $ passwords ; }
5237	private function injectionValuesForMethod ( \ ReflectionMethod $ method ) { $ paramValues = [ ] ; $ defaultName = $ this -> methodBindingName ( $ method ) ; foreach ( $ method -> getParameters ( ) as $ param ) { $ type = $ this -> paramType ( $ method , $ param ) ; $ name = $ this -> detectBindingName ( $ param , $ defaultName ) ; $ hasExplicitBinding = $ this -> injector -> hasExplicitBinding ( $ type , $ name ) ; if ( ! $ hasExplicitBinding && $ param -> isDefaultValueAvailable ( ) ) { $ paramValues [ ] = $ param -> getDefaultValue ( ) ; continue ; } if ( ! $ this -> injector -> hasBinding ( $ type , $ name ) ) { $ typeMsg = $ this -> createTypeMessage ( $ type , $ name ) ; throw new BindingException ( 'Can not inject into ' . $ this -> class -> getName ( ) . '::' . $ method -> getName ( ) . '(' . $ this -> createParamString ( $ param , $ type ) . '). No binding for type ' . $ typeMsg . ' specified. Injection stack: ' . "\n" . join ( "\n" , $ this -> injector -> stack ( ) ) ) ; } $ paramValues [ ] = $ this -> injector -> getInstance ( $ type , $ name ) ; } return $ paramValues ; }
992	public static function visitUsingRules ( Schema $ schema , TypeInfo $ typeInfo , DocumentNode $ documentNode , array $ rules ) { $ context = new ValidationContext ( $ schema , $ documentNode , $ typeInfo ) ; $ visitors = [ ] ; foreach ( $ rules as $ rule ) { $ visitors [ ] = $ rule -> getVisitor ( $ context ) ; } Visitor :: visit ( $ documentNode , Visitor :: visitWithTypeInfo ( $ typeInfo , Visitor :: visitInParallel ( $ visitors ) ) ) ; return $ context -> getErrors ( ) ; }
5215	private function getAnnotatedBinding ( \ ReflectionClass $ class ) { $ annotations = annotationsOf ( $ class ) ; if ( $ class -> isInterface ( ) && $ annotations -> contain ( 'ImplementedBy' ) ) { return $ this -> bind ( $ class -> getName ( ) ) -> to ( $ this -> findImplementation ( $ annotations , $ class -> getName ( ) ) ) ; } elseif ( $ annotations -> contain ( 'ProvidedBy' ) ) { return $ this -> bind ( $ class -> getName ( ) ) -> toProviderClass ( $ annotations -> firstNamed ( 'ProvidedBy' ) -> getProviderClass ( ) ) ; } return $ this -> getImplicitBinding ( $ class ) ; }
4963	public function addViewTemplate ( $ name , $ template , $ vars = [ ] , $ priority = 0 ) { if ( is_int ( $ vars ) ) { $ priority = $ vars ; $ vars = [ ] ; } $ model = new ViewModel ( $ vars ) ; $ model -> setTemplate ( $ template ) ; return $ this -> addViewModel ( $ name , $ model , $ priority ) ; }
6105	public function getHost ( ) { if ( $ this -> host === null ) { $ this -> host = new Host ( $ this ) ; } return $ this -> host ; }
1260	protected function createAccess ( ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; $ accessRequest = $ xml -> appendChild ( $ xml -> createElement ( 'AccessRequest' ) ) ; $ accessRequest -> setAttribute ( 'xml:lang' , 'en-US' ) ; $ accessRequest -> appendChild ( $ xml -> createElement ( 'AccessLicenseNumber' , $ this -> accessKey ) ) ; $ accessRequest -> appendChild ( $ xml -> createElement ( 'UserId' , $ this -> userId ) ) ; $ p = $ accessRequest -> appendChild ( $ xml -> createElement ( 'Password' ) ) ; $ p -> appendChild ( $ xml -> createTextNode ( $ this -> password ) ) ; return $ xml -> saveXML ( ) ; }
8932	public function loadDependencies ( ) { $ config = ConfigService :: fetch ( dirname ( __DIR__ ) ) ; $ config = array_merge ( $ config , ConfigService :: fetch ( ) ) ; $ moduleService = new ModuleService ; if ( ! array_key_exists ( 'slim-api' , $ config ) ) { $ config [ 'slim-api' ] = [ 'modules' => [ 'SlimApi\Phinx' , 'SlimApi\Mvc' ] ] ; } else { require 'vendor/autoload.php' ; } foreach ( $ config [ 'slim-api' ] [ 'modules' ] as $ moduleNamespace ) { $ config = array_merge ( $ config , $ moduleService -> load ( $ moduleNamespace ) ) ; } return $ config ; }
9174	private function hierarchyToFlatArray ( $ items ) { $ flatArray = [ ] ; foreach ( $ items as $ item ) { $ flatArray [ ] = $ item -> getId ( ) ; if ( $ items -> getChildren ( ) -> count ( ) > 0 ) { $ flatArray = array_merge ( $ flatArray , $ this -> hierarchyToFlatArray ( $ items -> getChildren ( ) ) ) ; } } return $ flatArray ; }
4808	public function unschedule_specific_event ( $ timestamp = '' ) { if ( empty ( $ timestamp ) ) { $ timestamp = wp_next_scheduled ( $ this -> args [ 'name' ] , $ this -> args [ 'args' ] ) ; } wp_unschedule_event ( $ timestamp , $ this -> args [ 'name' ] , $ this -> args [ 'args' ] ) ; }
9338	public function isSupplementary ( Angle $ angle ) { $ out = new self ( $ this -> float_rad + $ angle -> rad ) ; return $ out -> isStraight ( ) ; }
10081	protected function registerManager ( ) { $ this -> app -> singleton ( 'auja' , function ( $ app ) { $ config = $ app [ 'config' ] [ 'auja-laravel' ] ? : $ app [ 'config' ] [ 'auja-laravel::config' ] ; return new Auja ( $ app , $ app [ 'auja.configurator' ] , $ config [ 'models' ] ) ; } ) ; $ this -> app -> bind ( 'Label305\AujaLaravel\Auja' , 'auja' ) ; }
10103	private function writeDimensions ( ) { $ record = 0x0200 ; $ length = 0x000E ; $ data = pack ( 'VVvvv' , $ this -> firstRowIndex , $ this -> lastRowIndex + 1 , $ this -> firstColumnIndex , $ this -> lastColumnIndex + 1 , 0x0000 ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ this -> append ( $ header . $ data ) ; }
6084	public function uploadNewVersion ( $ id , $ pathname , $ revisionComment , $ filename = null , $ progress = null , $ chunkSize = 10485760 ) { $ chunk = 0 ; $ chunksTotal = ceil ( filesize ( $ pathname ) / $ chunkSize ) ; $ fileId = sha1 ( uniqid ( 'uploadVersion' , true ) ) ; $ filename = $ filename ? : pathinfo ( $ filename , PATHINFO_BASENAME ) ; $ fp = fopen ( $ pathname , 'r' ) ; if ( false === $ fp ) { throw new UploadException ( 'Could not open file "' . $ pathname . '" for reading.' ) ; } if ( $ chunkSize > 10485760 ) { $ this -> logger -> warning ( 'Using a chunk size larger then 10MB is not recommended. Uploading is not guaranteed to work properly.' ) ; } while ( $ chunkData = fread ( $ fp , $ chunkSize ) ) { $ result = $ this -> uploadNewVersionChunked ( $ chunkData , $ id , $ revisionComment , $ filename , $ chunk , $ chunksTotal , $ fileId ) ; if ( is_callable ( $ progress ) ) { try { call_user_func ( $ progress , $ chunk + 1 , $ chunksTotal ) ; } catch ( \ Exception $ e ) { $ this -> logger -> warning ( 'Could not report progress due to callback error.' , [ 'message' => $ e -> getMessage ( ) ] ) ; } } $ this -> logger -> info ( 'Upload progress!' , [ 'part' => $ chunk + 1 , 'total' => $ chunksTotal ] ) ; if ( isset ( $ result [ 'mediaId' ] ) ) { return new MediaResponse ( $ result ) ; } if ( isset ( $ result [ 'success' ] ) && false == $ result [ 'success' ] ) { throw new UploadException ( $ result [ 'error' ] [ 'message' ] , $ result [ 'error' ] [ 'code' ] ) ; } $ fileId = $ result [ 'fileId' ] ; ++ $ chunk ; } if ( $ chunk == $ chunksTotal - 1 ) { throw new UploadException ( 'Uploaded all chunks, but something went wrong.' ) ; } if ( false === $ chunkData ) { throw new UploadException ( 'Could not read chunk ' . $ chunk . ' from file "' . $ pathname . '".' ) ; } throw new UploadException ( 'Unknown upload error!' ) ; }
12345	public function editAction ( Request $ request , Post $ post ) { if ( is_object ( $ post -> getPublished ( ) ) && $ post -> getPublished ( ) -> format ( 'dmY' ) == '3011-0001' ) { $ post -> setPublished ( null ) ; } $ deleteForm = $ this -> createDeleteForm ( $ post ) ; $ editForm = $ this -> createForm ( 'BlogBundle\Form\PostType' , $ post , array ( 'translator' => $ this -> get ( 'translator' ) ) ) ; $ editForm -> handleRequest ( $ request ) ; if ( $ editForm -> isSubmitted ( ) && $ editForm -> isValid ( ) ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ em -> persist ( $ post ) ; $ em -> flush ( ) ; $ this -> get ( 'session' ) -> getFlashBag ( ) -> add ( 'success' , 'post.edited' ) ; return $ this -> redirectToRoute ( 'blog_post_index' ) ; } return array ( 'entity' => $ post , 'edit_form' => $ editForm -> createView ( ) , 'delete_form' => $ deleteForm -> createView ( ) , ) ; }
6301	protected function getMain ( $ name = 'default' ) { $ this -> events -> fire ( 'navigation.main' , [ [ 'name' => $ name ] ] ) ; if ( $ name !== 'default' && ! array_key_exists ( $ name , $ this -> main ) ) { $ name = 'default' ; } if ( ! array_key_exists ( $ name , $ this -> main ) ) { $ this -> main [ $ name ] = [ ] ; } $ nav = $ this -> active ( $ this -> main [ $ name ] ) ; return $ this -> process ( $ nav ) ; }
7509	function setIdentifiers ( $ ident ) { if ( is_array ( $ ident ) ) { $ this -> identifiers = array_fill_keys ( array_values ( $ ident ) , true ) ; $ this -> buildCharMap ( ) ; } else { $ this -> setIdentifiers ( str_split ( $ ident ) ) ; } }
5907	public function retrieveSetting ( $ key , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/accounts/settings/' . $ key . '' , $ parameters , $ cachePolicy ) ; return $ result ; }
10479	protected function inlineContext ( $ selectQuery , $ itemRow ) { $ selectQuery = str_replace ( [ 'OLD.' , 'NEW.' ] , '__ctx__' , $ selectQuery ) ; $ prefixedKeys = array_map ( function ( $ key ) { return '__ctx__' . $ key ; } , array_keys ( $ itemRow ) ) ; $ connection = $ this -> getConnection ( ) ; $ escapedValues = array_map ( function ( $ value ) use ( $ connection ) { return $ connection -> quote ( $ value ) ; } , array_values ( $ itemRow ) ) ; $ sql = str_replace ( $ prefixedKeys , $ escapedValues , $ selectQuery ) ; return $ sql ; }
8284	protected function init ( ) { $ this -> loadModules ( ) ; $ this -> session = $ this -> container -> get ( 'session' ) ; $ this -> csrf = new CSRF ( $ this -> session ) ; $ this -> user = $ this -> getUserFromSession ( ) ; $ this -> request = Request :: createFromGlobals ( ) ; $ this -> sessionTimeoutCheck ( "sessionInterval" , "_migT" , false ) ; $ this -> sessionTimeoutCheck ( "sessionTimeout" , "_start" , true ) ; $ this -> sessionTimeoutCheck ( "sessionIdle" , "_idle" , true , true ) ; }
10160	private function readMsoDrawing ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ splicedRecordData = $ this -> getSplicedRecordData ( ) ; $ recordData = $ splicedRecordData [ 'recordData' ] ; $ this -> drawingData .= $ recordData ; }
12523	public function update ( array $ arguments = null , array $ options = null ) : void { if ( $ arguments ) { $ keys = array_keys ( $ this -> arguments ) ; for ( $ index = 0 ; $ index < count ( $ keys ) ; $ index ++ ) { $ this -> arguments [ $ keys [ $ index ] ] = $ arguments [ $ index ] ; } } if ( $ options ) { foreach ( $ options as $ option => $ value ) { $ this -> options [ $ option ] = $ value ; } } }
295	public function getOldAttribute ( $ name ) { return isset ( $ this -> _oldAttributes [ $ name ] ) ? $ this -> _oldAttributes [ $ name ] : null ; }
9324	protected function registerMarkdownHtmlRenderer ( ) { $ app = $ this -> app ; $ app -> singleton ( 'commonmark.htmlrenderer' , function ( $ app ) { $ environment = $ app [ 'commonmark.environment' ] ; return new HtmlRenderer ( $ environment ) ; } ) ; $ app -> alias ( 'commonmark.htmlrenderer' , HtmlRenderer :: class ) ; }
10148	private function readMsoDrawingGroup ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ splicedRecordData = $ this -> getSplicedRecordData ( ) ; $ recordData = $ splicedRecordData [ 'recordData' ] ; $ this -> drawingGroupData .= $ recordData ; }
8363	public static function translate ( $ key , array $ args = array ( ) ) { if ( self :: $ isInit === false ) { throw new BadUse ( 'locale doesn\'t seem to have been initialized' ) ; } $ oldKey = $ key ; $ section = self :: $ translations ; while ( isset ( $ section [ $ key ] ) === false && ( $ pos = strpos ( $ key , '.' ) ) !== false ) { if ( ! is_int ( $ pos ) ) { break ; } $ subSection = substr ( $ key , 0 , $ pos ) ; if ( isset ( $ section [ $ subSection ] ) === false ) { break ; } $ section = $ section [ $ subSection ] ; $ key = substr ( $ key , $ pos + 1 ) ; } if ( isset ( $ section [ $ key ] ) === false ) { Logger :: get ( ) -> error ( 'can\'t find translation for key "' . $ oldKey . '"' ) ; return '(null)' ; } return $ section [ $ key ] ; }
6469	public function parseAcceptHeader ( HttpHeaders $ headers ) : array { $ headerValues = [ ] ; if ( ! $ headers -> tryGet ( 'Accept' , $ headerValues ) ) { return [ ] ; } $ parsedHeaderValues = [ ] ; $ numHeaderValues = count ( $ headerValues ) ; for ( $ i = 0 ; $ i < $ numHeaderValues ; $ i ++ ) { $ parsedHeaderParameters = $ this -> parseParameters ( $ headers , 'Accept' , $ i ) ; $ mediaType = $ parsedHeaderParameters -> getKeys ( ) [ 0 ] ; $ parsedHeaderValues [ ] = new AcceptMediaTypeHeaderValue ( $ mediaType , $ parsedHeaderParameters ) ; } return $ parsedHeaderValues ; }
9040	public function getMax ( string $ column ) : int { return $ this -> connection -> query ( 'SELECT IFNULL(MAX(%column), 0) position FROM %table' , $ column , $ this -> getTableName ( ) ) -> fetch ( ) -> position ; }
10917	private function isCmsActive ( ) { $ melisCms = 'MelisCms' ; $ moduleSvc = $ this -> getServiceLocator ( ) -> get ( 'ModulesService' ) ; $ modules = $ moduleSvc -> getActiveModules ( ) ; if ( in_array ( $ melisCms , $ modules ) ) { return true ; } return false ; }
6047	public function listObjectTypes ( CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/objecttypes' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new ObjectType ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
4271	public function rename ( $ pathFrom , $ pathTo ) { self :: restorePrev ( ) ; $ success = \ rename ( $ pathFrom , $ pathTo ) ; self :: register ( ) ; return $ success ; }
4428	protected function getQuestion ( $ questionName , $ defaultValue = null , $ validator = null ) { $ questionName = $ defaultValue ? '<info>' . $ questionName . '</info> [<comment>' . $ defaultValue . '</comment>]: ' : '<info>' . $ questionName . '</info>: ' ; $ question = new Question ( $ questionName , $ defaultValue ) ; if ( $ validator !== null ) { $ question -> setValidator ( $ validator ) ; } return $ question ; }
7756	public function setPropertyValue ( $ entity , $ property , $ value ) { $ this -> reflFields [ $ property ] -> setValue ( $ entity , $ value ) ; }
1482	public function encoder ( $ options = 0 , $ depth = 512 ) { if ( $ options instanceof Encoding ) { $ options = $ options -> getOptions ( ) ; } if ( ! $ options instanceof EncoderOptions ) { $ options = new EncoderOptions ( $ options , $ this -> getUrl ( ) -> toString ( ) , $ depth ) ; } return $ this -> factory -> createEncoder ( $ this -> getContainer ( ) , $ options ) ; }
6149	public function sendJson ( $ data , $ statusCode = null ) { return $ this -> setStatusCode ( $ statusCode ) -> setJsonBody ( $ data ) -> send ( ) ; }
3949	private function buildCaption ( $ metaModel , $ inputScreen ) : array { $ caption = [ sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'metamodel_edit_as_child' ] [ 'label' ] , $ metaModel -> getName ( ) ) , '' ] ; foreach ( $ inputScreen [ 'label' ] as $ langCode => $ label ) { if ( $ label !== '' && $ langCode === $ GLOBALS [ 'TL_LANGUAGE' ] ) { $ caption = [ $ label , $ inputScreen [ 'description' ] [ $ langCode ] ] ; } } return $ caption ; }
10124	private function writeGridset ( ) { $ record = 0x0082 ; $ length = 0x0002 ; $ fGridSet = ! $ this -> phpSheet -> getPrintGridlines ( ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ fGridSet ) ; $ this -> append ( $ header . $ data ) ; }
5854	protected function persistFlexForm ( array & $ valueArray ) { foreach ( $ valueArray as $ key => $ value ) { if ( $ key === 'el' ) { foreach ( $ value as $ idx => $ v ) { if ( $ v && substr ( $ idx , 0 , 3 ) === 'ID-' ) { $ valueArray [ $ key ] [ substr ( $ idx , 3 ) ] = $ v ; unset ( $ valueArray [ $ key ] [ $ idx ] ) ; } } } elseif ( isset ( $ valueArray [ $ key ] ) ) { $ this -> persistFlexForm ( $ valueArray [ $ key ] ) ; } } }
7892	public function set ( $ property_name , $ value ) { $ this -> validateProperty ( $ property_name , $ value ) ; $ this -> data [ $ property_name ] = $ value ; return $ this ; }
4209	private function methodInfo ( $ obj , \ ReflectionMethod $ reflectionMethod ) { $ declaringClassName = $ reflectionMethod -> getDeclaringClass ( ) -> getName ( ) ; $ phpDoc = $ this -> phpDoc -> getParsed ( $ reflectionMethod ) ; $ vis = 'public' ; if ( $ reflectionMethod -> isPrivate ( ) ) { $ vis = 'private' ; } elseif ( $ reflectionMethod -> isProtected ( ) ) { $ vis = 'protected' ; } $ info = array ( 'implements' => null , 'inheritedFrom' => $ declaringClassName != \ get_class ( $ obj ) ? $ declaringClassName : null , 'isAbstract' => $ reflectionMethod -> isAbstract ( ) , 'isDeprecated' => $ reflectionMethod -> isDeprecated ( ) || isset ( $ phpDoc [ 'deprecated' ] ) , 'isFinal' => $ reflectionMethod -> isFinal ( ) , 'isStatic' => $ reflectionMethod -> isStatic ( ) , 'params' => $ this -> getParams ( $ reflectionMethod , $ phpDoc ) , 'phpDoc' => $ phpDoc , 'visibility' => $ vis , ) ; unset ( $ info [ 'phpDoc' ] [ 'param' ] ) ; return $ info ; }
8473	public function warning ( $ scope , $ message , $ context = [ ] , $ config = [ ] ) { return $ this -> write ( 'warning' , $ scope , $ message , $ context , $ config ) ; }
4811	public function create ( ) { $ language = new ExpressionLanguage ( ) ; foreach ( $ this -> providers as $ provider ) { $ language -> registerProvider ( $ provider ) ; } return $ language ; }
8090	static public function generate ( $ uid = 0 , $ hash = false ) { if ( $ uid ) { $ e_uid = self :: encode ( $ uid ) ; $ e_uid_length = strlen ( $ e_uid ) ; $ e_uid_length = str_pad ( $ e_uid_length , 2 , 0 , STR_PAD_LEFT ) ; $ e_uid_pos = rand ( 10 , 32 - $ e_uid_length - 1 ) ; if ( ! $ hash ) { $ hash = sha1 ( uniqid ( rand ( ) , true ) ) ; } $ code = $ e_uid_pos . $ e_uid_length ; $ code .= substr ( $ hash , 0 , $ e_uid_pos - strlen ( $ code ) ) ; $ code .= $ e_uid ; $ code .= substr ( $ hash , strlen ( $ code ) ) ; return $ code ; } else { return sha1 ( uniqid ( rand ( ) , true ) ) ; } }
7661	function SetWordWrap ( ) { if ( $ this -> WordWrap < 1 ) return ; switch ( $ this -> message_type ) { case "alt" : case "alt_attachments" : $ this -> AltBody = $ this -> WrapText ( $ this -> AltBody , $ this -> WordWrap ) ; break ; default : $ this -> Body = $ this -> WrapText ( $ this -> Body , $ this -> WordWrap ) ; break ; } }
4297	public function clear ( $ flags = self :: CLEAR_LOG ) { array ( $ flags ) ; $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) , array ( 'flags' => self :: CLEAR_LOG ) , array ( 'flags' => 'bitmask' ) ) ; $ event = $ this -> methodClear -> onLog ( new Event ( $ this , array ( 'method' => __FUNCTION__ , 'args' => array ( ) , 'meta' => $ meta , ) ) ) ; $ this -> setLogDest ( 'log' ) ; $ collect = $ this -> cfg [ 'collect' ] ; $ this -> cfg [ 'collect' ] = true ; if ( $ event [ 'log' ] ) { $ this -> appendLog ( $ event [ 'method' ] , $ event [ 'args' ] , $ event [ 'meta' ] ) ; } elseif ( $ event [ 'publish' ] ) { $ this -> internal -> publishBubbleEvent ( 'debug.log' , $ event ) ; } $ this -> cfg [ 'collect' ] = $ collect ; $ this -> setLogDest ( 'auto' ) ; }
8013	protected function getBasicOptions ( ) { $ options = array ( ) ; $ options [ ] = '-encoding UTF-8' ; if ( $ this -> _asHtml ) { $ options [ ] = '-html' ; } if ( $ this -> _toConsole ) { $ options [ ] = '-console' ; } return join ( ' ' , $ options ) ; }
8393	public static function run ( ) { if ( self :: $ isInit === true ) { self :: $ request = new Request ( self :: $ routes ) ; self :: $ controllers = array ( ) ; try { $ before = self :: $ request -> getBefore ( ) ; foreach ( $ before as $ b ) { $ controller = Controllers :: get ( $ b [ 'class' ] ) ; $ action = $ b [ 'action' ] ; $ controller -> $ action ( self :: $ request ) ; } if ( self :: $ request -> hasEnded ( ) === false ) { $ controller = Controllers :: get ( self :: $ request -> getClass ( ) ) ; $ action = self :: $ request -> getAction ( ) ; $ controller -> $ action ( self :: $ request ) ; if ( self :: $ request -> hasEnded ( ) === false ) { $ after = self :: $ request -> getAfter ( ) ; foreach ( $ after as $ a ) { $ controller = Controllers :: get ( $ a [ 'class' ] ) ; $ action = $ a [ 'action' ] ; $ controller -> $ action ( self :: $ request ) ; } } } } catch ( \ Exception $ e ) { echo 'Exception: ' . $ e -> getMessage ( ) . PHP_EOL ; echo $ e -> getTraceAsString ( ) ; } } }
8584	public function setASIN ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ASIN' ] [ 'FieldValue' ] = $ value ; return $ this ; }
4724	public function render ( ) { $ html = new Text ( ) ; $ html -> append ( '<' ) -> append ( $ this -> getName ( ) ) ; foreach ( $ this -> attributes as $ name => $ value ) { $ html -> append ( ' ' ) -> append ( $ name ) -> append ( '=' ) -> append ( '"' ) -> append ( $ value ) -> append ( '"' ) ; } if ( $ this -> text -> isEmpty ( ) ) { if ( $ this -> type == self :: TYPE_BLOCK ) { return ( string ) $ html -> append ( '>' ) -> append ( '</' ) -> append ( $ this -> getName ( ) ) -> append ( '>' ) ; } else { return ( string ) $ html -> append ( $ this -> emptyTagSuffix ) ; } } return ( string ) $ html -> append ( '>' ) -> append ( $ this -> text ) -> append ( '</' ) -> append ( $ this -> getName ( ) ) -> append ( '>' ) ; }
171	public static function createDirectory ( $ path , $ mode = 0775 , $ recursive = true ) { if ( is_dir ( $ path ) ) { return true ; } $ parentDir = dirname ( $ path ) ; if ( $ recursive && ! is_dir ( $ parentDir ) && $ parentDir !== $ path ) { static :: createDirectory ( $ parentDir , $ mode , true ) ; } try { if ( ! mkdir ( $ path , $ mode ) ) { return false ; } } catch ( \ Exception $ e ) { if ( ! is_dir ( $ path ) ) { throw new \ yii \ base \ Exception ( "Failed to create directory \"$path\": " . $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } } try { return chmod ( $ path , $ mode ) ; } catch ( \ Exception $ e ) { throw new \ yii \ base \ Exception ( "Failed to change permissions for directory \"$path\": " . $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } }
596	public function actionCheckGuide ( $ directory = null ) { if ( $ directory === null ) { $ directory = \ dirname ( \ dirname ( __DIR__ ) ) . '/docs' ; } if ( is_file ( $ directory ) ) { $ files = [ $ directory ] ; } else { $ files = FileHelper :: findFiles ( $ directory , [ 'only' => [ '*.md' ] , ] ) ; } foreach ( $ files as $ file ) { $ content = file_get_contents ( $ file ) ; $ chars = preg_split ( '//u' , $ content , null , PREG_SPLIT_NO_EMPTY ) ; $ line = 1 ; $ pos = 0 ; foreach ( $ chars as $ c ) { $ ord = $ this -> unicodeOrd ( $ c ) ; $ pos ++ ; if ( $ ord == 0x000A ) { $ line ++ ; $ pos = 0 ; } if ( $ ord === false ) { $ this -> found ( 'BROKEN UTF8' , $ c , $ line , $ pos , $ file ) ; continue ; } if ( 0x2000 <= $ ord && $ ord <= 0x200F || 0x2028 <= $ ord && $ ord <= 0x202E || 0x205f <= $ ord && $ ord <= 0x206F ) { $ this -> found ( 'UNSUPPORTED SPACE CHARACTER' , $ c , $ line , $ pos , $ file ) ; continue ; } if ( $ ord < 0x0020 && $ ord != 0x000A && $ ord != 0x0009 || 0x0080 <= $ ord && $ ord < 0x009F ) { $ this -> found ( 'CONTROL CHARARCTER' , $ c , $ line , $ pos , $ file ) ; continue ; } } } }
8069	public function bind ( $ username , $ password ) { if ( $ this -> tls ) { if ( ! ldap_start_tls ( $ this -> connection ) ) { throw new ConnectionException ( 'Unable to Connect to LDAP using TLS.' ) ; } } try { $ this -> bound = ldap_bind ( $ this -> connection , $ username , $ password ) ; } catch ( ErrorException $ e ) { $ this -> bound = false ; } return $ this -> bound ; }
725	public function render ( $ view , $ params = [ ] ) { $ content = $ this -> getView ( ) -> render ( $ view , $ params , $ this ) ; return $ this -> renderContent ( $ content ) ; }
8305	public function assertGreaterThan ( $ config , $ keyGreater , $ keyLower ) { if ( ! isset ( $ config [ $ keyLower ] ) || ! isset ( $ config [ $ keyGreater ] ) || $ config [ $ keyLower ] >= $ config [ $ keyGreater ] ) { throw new ConfigurationException ( $ keyGreater . " must be greater than " . $ keyLower ) ; } return $ this ; }
9435	public function theta ( $ float_min , $ float_max ) { self :: checkOrder ( $ float_min , $ float_max ) ; if ( $ this -> r || $ this -> i ) { throw new \ RuntimeException ( 'You cannot set theta value, because algebraic form is in use.' ) ; } $ this -> theta = new \ stdClass ( ) ; $ this -> theta -> min = $ float_min ; $ this -> theta -> max = $ float_max ; return $ this ; }
4964	public function addViewVariables ( $ name , $ data = [ ] , $ priority = 0 ) { if ( is_array ( $ name ) ) { if ( ! isset ( $ name [ 'name' ] ) ) { throw new \ DomainException ( 'Key "name" must be specified, if array is passed as first parameter.' ) ; } if ( is_int ( $ data ) ) { $ priority = $ data ; } $ data = $ name ; $ name = $ data [ 'name' ] ; } elseif ( is_int ( $ data ) ) { $ priority = $ data ; $ data = [ ] ; } if ( ! isset ( $ data [ 'name' ] ) ) { $ data [ 'name' ] = $ name ; } return $ this -> addViewTemplate ( $ name , "core/admin/dashboard-widget" , $ data , $ priority ) ; }
3140	public function hasFeedbacks ( RunnerServiceContext $ context , $ itemRef ) { $ hasFeedbacks = false ; $ displayFeedbacks = $ this -> displayFeedbacks ( $ context ) ; if ( $ displayFeedbacks ) { $ feedbacks = $ this -> getFeedbacks ( $ context , $ itemRef ) ; foreach ( $ feedbacks as $ entry ) { if ( isset ( $ entry [ 'feedbackRules' ] ) ) { if ( count ( $ entry [ 'feedbackRules' ] ) > 0 ) { $ hasFeedbacks = true ; } break ; } } } return $ hasFeedbacks ; }
5732	public function getLeague ( int $ leagueID , array $ filter = [ 'areas' => '' ] ) { $ league = $ this -> run ( "v2/competitions/{$leagueID}" . "?" . http_build_query ( $ filter ) ) ; return collect ( $ league ) ; }
1211	public function callRecursively ( ItemInterface $ item , $ method , $ arguments = array ( ) ) { call_user_func_array ( array ( $ item , $ method ) , $ arguments ) ; foreach ( $ item -> getChildren ( ) as $ child ) { $ this -> callRecursively ( $ child , $ method , $ arguments ) ; } }
9132	protected function validate ( $ config , $ name , $ path ) { if ( ! is_array ( $ config ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The definition of "%s" in "%s" must be a YAML array.' , $ name , $ path ) ) ; } if ( $ extraKeys = array_diff ( array_keys ( $ config ) , self :: $ availableKeys ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The routing file "%s" contains unsupported keys for "%s": "%s". Expected one of: "%s".' , $ path , $ name , implode ( '", "' , $ extraKeys ) , implode ( '", "' , self :: $ availableKeys ) ) ) ; } if ( isset ( $ config [ 'resource' ] ) && isset ( $ config [ 'expression' ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The business rule file "%s" must not specify both the "resource" key and the "expression" key for "%s". Choose between an import and a rule definition.' , $ path , $ name ) ) ; } if ( ! isset ( $ config [ 'resource' ] ) && isset ( $ config [ 'type' ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The "type" key for the rule definition "%s" in "%s" is unsupported. It is only available for imports in combination with the "resource" key.' , $ name , $ path ) ) ; } if ( ! isset ( $ config [ 'resource' ] ) && ! isset ( $ config [ 'expression' ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'You must define an "expression" for the rule "%s" in file "%s".' , $ name , $ path ) ) ; } if ( isset ( $ config [ 'tags' ] ) && ! is_array ( $ config [ 'tags' ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The "tags" key for the rule definition "%s" in "%s" contains unsupported data. Each tag defined must be an array with at least the "name" element set to a string.' , $ name , $ path ) ) ; } elseif ( isset ( $ config [ 'tags' ] ) ) { foreach ( $ config [ 'tags' ] as $ tag ) { if ( ! isset ( $ tag [ 'name' ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The "tags" key for the rule definition "%s" in "%s" contains unsupported data. Each tag defined must be an array with at least the "name" element set to a string.' , $ name , $ path ) ) ; } } } }
7449	public function exec ( string $ execfile , array $ args ) : bool { return $ this -> process -> exec ( $ execfile , $ args ) ; }
394	public static function updateAll ( $ attributes , $ condition = '' , $ params = [ ] ) { $ command = static :: getDb ( ) -> createCommand ( ) ; $ command -> update ( static :: tableName ( ) , $ attributes , $ condition , $ params ) ; return $ command -> execute ( ) ; }
9131	public function load ( $ file , $ type = null ) { $ path = $ this -> locator -> locate ( $ file ) ; if ( ! stream_is_local ( $ path ) ) { throw new \ InvalidArgumentException ( sprintf ( 'This is not a local file "%s".' , $ path ) ) ; } if ( ! file_exists ( $ path ) ) { throw new \ InvalidArgumentException ( sprintf ( 'File "%s" not found.' , $ path ) ) ; } if ( null === $ this -> yamlParser ) { $ this -> yamlParser = new YamlParser ( ) ; } $ config = $ this -> yamlParser -> parse ( file_get_contents ( $ path ) ) ; $ collection = new RuleCollection ( ) ; $ collection -> addResource ( new FileResource ( $ path ) ) ; if ( null === $ config ) { return $ collection ; } if ( ! is_array ( $ config ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The file "%s" must contain a YAML array.' , $ path ) ) ; } foreach ( $ config as $ name => $ subConfig ) { $ this -> validate ( $ subConfig , $ name , $ path ) ; if ( isset ( $ subConfig [ 'resource' ] ) ) { $ this -> parseImport ( $ collection , $ subConfig , $ path , $ file ) ; } else { $ this -> parseRule ( $ collection , $ name , $ subConfig , $ path ) ; } } return $ collection ; }
8368	private static function validateConfig ( array $ config ) { if ( isset ( $ config [ 'name' ] ) === false ) { throw new BadUse ( 'there\'s no name in mapping configuration' ) ; } if ( isset ( $ config [ 'schema' ] ) === false ) { throw new BadUse ( 'there\'s no schema in mapping configuration' ) ; } if ( isset ( $ config [ 'provider' ] ) === false ) { throw new BadUse ( 'there\'s no provider in mapping configuration' ) ; } if ( isset ( $ config [ 'models' ] ) === false ) { throw new BadUse ( 'there\'s no models in mapping configuration' ) ; } if ( isset ( $ config [ 'models' ] [ 'path' ] ) === false ) { throw new BadUse ( 'there\'s no models.path in mapping configuration' ) ; } if ( isset ( $ config [ 'models' ] [ 'namespace' ] ) === false ) { throw new BadUse ( 'there\'s no models.namespace in mapping configuration' ) ; } }
11418	public static function createInstance ( $ environment , $ options = null ) { if ( ! self :: $ _instance ) { self :: $ _instance = new static ( $ environment , $ options , false ) ; } return self :: $ _instance ; }
6984	protected function extractInputFromRules ( $ data , array $ rules ) { $ keys = collect ( $ rules ) -> keys ( ) -> map ( function ( $ rule ) { return explode ( '.' , $ rule ) [ 0 ] ; } ) -> unique ( ) -> toArray ( ) ; if ( ! ( $ data instanceof Request ) ) { $ data = collect ( $ data ) ; } return $ data -> only ( $ keys ) ; }
1117	public static function roots ( ) { $ instance = new static ; return $ instance -> newQuery ( ) -> whereNull ( $ instance -> getParentColumnName ( ) ) -> orderBy ( $ instance -> getQualifiedOrderColumnName ( ) ) ; }
12290	public function countTotal ( $ categoryId = null ) { $ qb = $ this -> getQueryBuilder ( ) -> select ( 'COUNT(p)' ) ; if ( ! is_null ( $ categoryId ) ) { $ qb -> join ( 'p.categories' , 'c' ) -> where ( 'c.id = :categoryId' ) -> setParameter ( 'categoryId' , $ categoryId ) ; } return $ qb -> getQuery ( ) -> getSingleScalarResult ( ) ; }
2317	public function computeResize ( ) { $ resizeCoordinates = System :: getContainer ( ) -> get ( 'contao.image.resize_calculator' ) -> calculate ( $ this -> prepareResizeConfig ( ) , new ImageDimensions ( new Box ( $ this -> fileObj -> viewWidth , $ this -> fileObj -> viewHeight ) , $ this -> fileObj -> viewWidth !== $ this -> fileObj -> width ) , $ this -> prepareImportantPart ( ) ) ; return array ( 'width' => $ resizeCoordinates -> getCropSize ( ) -> getWidth ( ) , 'height' => $ resizeCoordinates -> getCropSize ( ) -> getHeight ( ) , 'target_x' => - $ resizeCoordinates -> getCropStart ( ) -> getX ( ) , 'target_y' => - $ resizeCoordinates -> getCropStart ( ) -> getY ( ) , 'target_width' => $ resizeCoordinates -> getSize ( ) -> getWidth ( ) , 'target_height' => $ resizeCoordinates -> getSize ( ) -> getHeight ( ) , ) ; }
784	protected function validateCache ( $ lastModified , $ etag ) { if ( Yii :: $ app -> request -> headers -> has ( 'If-None-Match' ) ) { return $ etag !== null && in_array ( $ etag , Yii :: $ app -> request -> getETags ( ) , true ) ; } elseif ( Yii :: $ app -> request -> headers -> has ( 'If-Modified-Since' ) ) { return $ lastModified !== null && @ strtotime ( Yii :: $ app -> request -> headers -> get ( 'If-Modified-Since' ) ) >= $ lastModified ; } return false ; }
6470	public function parseAcceptLanguageHeader ( HttpHeaders $ headers ) : array { $ headerValues = [ ] ; if ( ! $ headers -> tryGet ( 'Accept-Language' , $ headerValues ) ) { return [ ] ; } $ parsedHeaderValues = [ ] ; $ numHeaderValues = count ( $ headerValues ) ; for ( $ i = 0 ; $ i < $ numHeaderValues ; $ i ++ ) { $ parsedHeaderParameters = $ this -> parseParameters ( $ headers , 'Accept-Language' , $ i ) ; $ language = $ parsedHeaderParameters -> getKeys ( ) [ 0 ] ; $ parsedHeaderValues [ ] = new AcceptLanguageHeaderValue ( $ language , $ parsedHeaderParameters ) ; } return $ parsedHeaderValues ; }
1761	protected static function readPhpFileWithoutTags ( $ strName ) { @ trigger_error ( 'Using System::readPhpFileWithoutTags() has been deprecated and will no longer work in Contao 5.0. Use the Contao\CoreBundle\Config\Loader\PhpFileLoader instead.' , E_USER_DEPRECATED ) ; $ rootDir = self :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( strpos ( $ strName , $ rootDir . '/' ) === false ) { $ strName = $ rootDir . '/' . $ strName ; } $ loader = new PhpFileLoader ( ) ; return $ loader -> load ( $ strName ) ; }
6305	public function getDistance ( Point $ point , DistanceInterface $ calculator = null ) { $ calculator = $ calculator ? : static :: getCalculator ( ) ; return $ calculator -> getDistance ( new Coordinate ( $ this -> latitude , $ this -> longitude ) , new Coordinate ( $ point -> latitude , $ point -> longitude ) ) ; }
7229	public static function create ( $ method , $ url , $ data = "" , array $ headers = [ ] , array $ options = [ ] , $ initOnly = false ) { $ curl = null ; if ( ! strcasecmp ( $ method , "GET" ) ) $ curl = new static ( $ url , $ options + [ CURLOPT_CUSTOMREQUEST => "GET" , CURLOPT_RETURNTRANSFER => true ] , $ headers , $ initOnly ) ; else if ( ! strcasecmp ( $ method , "POST" ) ) $ curl = new static ( $ url , $ options + [ CURLOPT_CUSTOMREQUEST => "POST" , CURLOPT_POSTFIELDS => $ data , CURLOPT_RETURNTRANSFER => true ] , $ headers , $ initOnly ) ; else if ( ! strcasecmp ( $ method , "PUT" ) ) $ curl = new static ( $ url , $ options + [ CURLOPT_CUSTOMREQUEST => "PUT" , CURLOPT_POSTFIELDS => $ data , CURLOPT_RETURNTRANSFER => true ] , $ headers , $ initOnly ) ; else if ( ! strcasecmp ( $ method , "DELETE" ) ) $ curl = new static ( $ url , $ options + [ CURLOPT_CUSTOMREQUEST => "DELETE" , CURLOPT_RETURNTRANSFER => true ] , $ headers , $ initOnly ) ; return $ curl ; }
12151	public function getRelatedType ( $ name ) { list ( $ relationship , $ role ) = $ this -> getRelationship ( $ name ) ; if ( $ relationship ) { return $ relationship -> roleType ( $ role ) ; } return false ; }
7240	private function resolveClassAndCreateObject ( $ type , $ subject ) { foreach ( $ this -> classes [ $ type ] as $ source => $ target ) { if ( $ subject instanceof $ source ) { return new $ target ; } } throw new InvalidArgumentException ( 'Unsupported object class.' ) ; }
9548	public function validate ( UploadedFile $ file ) { foreach ( $ this -> constraints as $ constraint ) { if ( ! $ constraint -> validate ( $ file ) ) { throw new ConstraintException ( $ constraint , $ file ) ; } } return true ; }
341	public static function validate ( $ model , $ attributes = null ) { $ result = [ ] ; if ( $ attributes instanceof Model ) { $ models = func_get_args ( ) ; $ attributes = null ; } else { $ models = [ $ model ] ; } foreach ( $ models as $ model ) { $ model -> validate ( $ attributes ) ; foreach ( $ model -> getErrors ( ) as $ attribute => $ errors ) { $ result [ Html :: getInputId ( $ model , $ attribute ) ] = $ errors ; } } return $ result ; }
5229	public static function forName ( $ name ) { $ enum = new \ ReflectionClass ( get_called_class ( ) ) ; try { return $ enum -> getStaticPropertyValue ( $ name ) ; } catch ( \ ReflectionException $ re ) { throw new \ InvalidArgumentException ( $ re -> getMessage ( ) ) ; } }
5323	public function registerHandler ( $ signal , $ handler ) { if ( ! is_callable ( $ handler ) ) { throw new \ InvalidArgumentException ( 'The handler is not callable' ) ; } if ( ! isset ( $ this -> handlers [ $ signal ] ) ) { $ this -> handlers [ $ signal ] = [ ] ; if ( ! pcntl_signal ( $ signal , [ $ this , 'handleSignal' ] ) ) { throw new \ RuntimeException ( sprintf ( 'Could not register signal %d with pcntl_signal' , $ signal ) ) ; } ; } ; $ this -> handlers [ $ signal ] [ ] = $ handler ; return $ this ; }
4109	public function toOptionArray ( ) { $ options = array ( ) ; $ options [ ] = array ( 'value' => 'aoe_templatehints/renderer_comment' , 'label' => Mage :: helper ( 'aoe_templatehints' ) -> __ ( 'Comments' ) ) ; $ options [ ] = array ( 'value' => 'aoe_templatehints/renderer_opentip' , 'label' => Mage :: helper ( 'aoe_templatehints' ) -> __ ( 'Popups' ) ) ; $ options [ ] = array ( 'value' => 'aoe_templatehints/renderer_tipOnly' , 'label' => Mage :: helper ( 'aoe_templatehints' ) -> __ ( 'Popups (border initially invisible)' ) ) ; Mage :: dispatchEvent ( 'aoetemplatehints_hintrenderer_options' , array ( 'options' => & $ options ) ) ; return $ options ; }
4110	protected function arrayToTabList ( array $ array , array $ skipKeys = array ( ) , $ indentationLevel = 1 ) { $ output = '' ; foreach ( $ array as $ key => $ value ) { if ( in_array ( $ key , $ skipKeys , true ) ) { continue ; } $ output .= $ this -> tabsForIndentation ( $ indentationLevel ) ; if ( ! is_array ( $ value ) ) { if ( ! is_int ( $ key ) ) { $ output .= ucfirst ( $ key ) . ":\n" ; $ output .= $ this -> tabsForIndentation ( $ indentationLevel + 1 ) ; } $ output .= $ value . "\n" ; } else { $ output .= ucfirst ( $ key ) . ":\n" ; $ output .= $ this -> arrayToTabList ( $ value , $ skipKeys , $ indentationLevel + 1 ) ; } } return $ output ; }
3425	public function getById ( $ id ) { if ( ! $ id || $ this -> queryShouldBeStopped ) { return false ; } $ this -> sort = [ ] ; $ this -> filter [ 'ID' ] = $ id ; return $ this -> getList ( ) -> first ( null , false ) ; }
4059	private function drawLegend ( ModelToLabelEvent $ event ) { $ model = $ event -> getModel ( ) ; $ metaModel = $ this -> getMetaModelFromModel ( $ model ) ; if ( is_array ( $ legend = StringUtil :: deserialize ( $ model -> getProperty ( 'legendtitle' ) ) ) ) { foreach ( [ $ metaModel -> getActiveLanguage ( ) , $ metaModel -> getFallbackLanguage ( ) ] as $ language ) { if ( array_key_exists ( $ language , $ legend ) && ! empty ( $ legend [ $ language ] ) ) { $ legend = $ legend [ $ language ] ; break ; } } } if ( empty ( $ legend ) ) { $ legend = 'legend' ; } $ event -> setLabel ( '<div class="field_heading cte_type %s"><strong>%s</strong></div> <div class="dca_palette">%s%s</div>' ) -> setArgs ( [ $ model -> getProperty ( 'published' ) ? 'published' : 'unpublished' , $ this -> trans ( 'dcatypes.legend' ) , $ legend , $ model -> getProperty ( 'legendhide' ) ? ':hide' : '' ] ) ; }
8302	public function assertArray ( $ config , $ key ) { if ( array_key_exists ( $ key , $ config ) && ! is_array ( $ config [ $ key ] ) ) { throw new ConfigurationException ( $ key . " section must be an array." ) ; } return $ this ; }
2998	public function setReply ( $ email , $ title = null ) { $ this -> set ( 'Reply-To' , $ this -> buildMail ( $ email , $ title ) ) ; }
7815	public static function uploadImgFile ( $ path ) { try { if ( Request :: hasFile ( 'image' ) ) { $ pic = Request :: file ( 'image' ) ; if ( $ pic -> isValid ( ) ) { $ newName = md5 ( rand ( 1 , 1000 ) . $ pic -> getClientOriginalName ( ) ) . "." . $ pic -> getClientOriginalExtension ( ) ; $ pic -> move ( $ path , $ newName ) ; $ url = asset ( $ path . '/' . $ newName ) ; } else { self :: addError ( 'The file is invalid' ) ; } } else { self :: addError ( 'Not File' ) ; } } catch ( \ Exception $ e ) { self :: addError ( $ e -> getMessage ( ) ) ; } $ data = array ( 'status' => empty ( $ message ) ? 0 : 1 , 'message' => self :: getLastError ( ) , 'url' => ! empty ( $ url ) ? $ url : '' ) ; return $ data ; }
1456	protected function validateHasMany ( RelationshipInterface $ relationship , $ record = null , $ key = null , ResourceObjectInterface $ resource = null ) { if ( ! $ relationship -> isHasMany ( ) ) { $ this -> addError ( $ this -> errorFactory -> relationshipHasManyExpected ( $ key ) ) ; return false ; } $ identifiers = $ relationship -> getIdentifiers ( ) ; if ( ! $ this -> validateIdentifiers ( $ identifiers , $ record , $ key , $ resource ) ) { return false ; } return true ; }
6883	static public function getTypes ( ) { return [ static :: MANUAL , static :: CART_REMIND , static :: ORDER_ACCEPTED , static :: QUOTE_REMIND , static :: PAYMENT_CAPTURED , static :: PAYMENT_EXPIRED , static :: SHIPMENT_SHIPPED , static :: SHIPMENT_PARTIAL , static :: RETURN_PENDING , static :: RETURN_RECEIVED , ] ; }
6698	public function compareTo ( $ version ) { $ major = $ version -> getMajor ( ) ; $ minor = $ version -> getMinor ( ) ; $ patch = $ version -> getPatch ( ) ; $ pre = $ version -> getPreRelease ( ) ; $ build = $ version -> getBuild ( ) ; switch ( true ) { case ( $ this -> major < $ major ) : return 1 ; case ( $ this -> major > $ major ) : return - 1 ; case ( $ this -> minor > $ minor ) : return - 1 ; case ( $ this -> minor < $ minor ) : return 1 ; case ( $ this -> patch > $ patch ) : return - 1 ; case ( $ this -> patch < $ patch ) : return 1 ; } if ( $ pre || $ this -> pre ) { if ( empty ( $ this -> pre ) && $ pre ) { return - 1 ; } if ( $ this -> pre && empty ( $ pre ) ) { return 1 ; } if ( 0 !== ( $ weight = $ this -> precedence ( $ this -> pre , $ pre ) ) ) { return $ weight ; } } if ( $ build || $ this -> build ) { if ( ( null === $ this -> build ) && $ build ) { return 1 ; } if ( $ this -> build && ( null === $ build ) ) { return - 1 ; } return $ this -> precedence ( $ this -> build , $ build ) ; } return 0 ; }
11958	public function remove ( $ element ) { if ( ! $ this -> contains ( $ element ) ) { return false ; } $ this -> offsetUnset ( $ this -> indexOf ( $ element ) ) ; return true ; }
10558	public function createI18n ( array $ args ) { $ i18n = new I18n ; I18nShortcut :: setInstance ( $ i18n ) ; $ modules = $ this -> app -> resolver -> getResolver ( "language" ) ; $ log = \ Wedeto \ Log \ Logger :: getLogger ( I18nPlugin :: class ) ; $ search_path = $ modules -> getSearchPath ( ) ; foreach ( $ search_path as $ name => $ path ) { $ i18n -> registerTextDomain ( $ name , $ path ) ; } $ site_language = $ this -> app -> config -> dget ( 'site' , 'default_language' , 'en' ) ; $ locale = $ args [ 'locale' ] ?? $ site_language ; $ i18n -> setLocale ( $ locale ) ; $ this -> setupTranslateLog ( ) ; return $ i18n ; }
4826	public function getAsDom ( ) { if ( is_null ( $ this -> node ) ) { $ this -> node = XmlUtil :: createXmlDocumentFromStr ( "<row></row>" ) ; $ root = $ this -> node -> getElementsByTagName ( "row" ) -> item ( 0 ) ; foreach ( $ this -> row as $ key => $ value ) { if ( ! is_array ( $ value ) ) { $ field = XmlUtil :: createChild ( $ root , "field" , $ value ) ; XmlUtil :: addAttribute ( $ field , "name" , $ key ) ; } else { foreach ( $ value as $ valueItem ) { $ field = XmlUtil :: createChild ( $ root , "field" , $ valueItem ) ; XmlUtil :: addAttribute ( $ field , "name" , $ key ) ; } } } } return $ this -> node ; }
7658	function SmtpClose ( ) { if ( $ this -> smtp != NULL ) { if ( $ this -> smtp -> Connected ( ) ) { $ this -> smtp -> Quit ( ) ; $ this -> smtp -> Close ( ) ; } } }
10586	protected static function registerEntity ( entity \ EntityInterface $ entity ) { if ( count ( self :: $ entities ) === 0 ) { register_shutdown_function ( "sndsgd\\fs\\Temp::cleanup" ) ; } self :: $ entities [ $ entity -> getPath ( ) ] = $ entity ; }
5823	private function resolveOptions ( array $ options = array ( ) ) { $ this -> options [ 'alertPublisher' ] = $ this -> alertPublisher ; return array_merge ( $ this -> options , $ options ) ; }
10223	public function menuFor ( $ model , $ modelId = 0 , ModelConfig $ config = null ) { if ( is_null ( $ this -> aujaConfigurator ) ) { throw new \ LogicException ( 'Auja not initialized. Call Auja::init first.' ) ; } $ modelName = $ this -> resolveModelName ( $ model ) ; if ( $ modelId == 0 ) { $ menu = $ this -> noAssociationsMenuFor ( $ modelName , $ config ) ; } else { $ menu = $ this -> buildComplexIndexMenu ( $ modelName , $ modelId , $ config ) ; } return $ menu ; }
2088	public static function initialize ( ) { $ objFilesystem = new Filesystem ( ) ; $ container = System :: getContainer ( ) ; $ strCacheDir = $ container -> getParameter ( 'kernel.cache_dir' ) ; if ( file_exists ( $ strCacheDir . '/contao/config/templates.php' ) ) { self :: addFiles ( include $ strCacheDir . '/contao/config/templates.php' ) ; } else { try { foreach ( System :: getContainer ( ) -> get ( 'contao.resource_finder' ) -> findIn ( 'templates' ) -> name ( '*.html5' ) as $ file ) { self :: addFile ( $ file -> getBasename ( '.html5' ) , rtrim ( $ objFilesystem -> makePathRelative ( $ file -> getPath ( ) , $ container -> getParameter ( 'kernel.project_dir' ) ) , '/' ) ) ; } } catch ( \ InvalidArgumentException $ e ) { } } }
1759	public static function getSessionHash ( $ strCookie ) { @ trigger_error ( 'Using System::getSessionHash() has been deprecated and will no longer work in Contao 5.0. Use Symfony authentication instead.' , E_USER_DEPRECATED ) ; $ session = static :: getContainer ( ) -> get ( 'session' ) ; if ( ! $ session -> isStarted ( ) ) { $ session -> start ( ) ; } return sha1 ( $ session -> getId ( ) . $ strCookie ) ; }
11855	public function getUrlPath ( ) : ? string { $ uri = $ this -> getServerParam ( 'REQUEST_URI' , \ FILTER_SANITIZE_URL ) ; if ( ! is_null ( $ uri ) ) { return parse_url ( $ uri , \ PHP_URL_PATH ) ; } return null ; }
2425	public static function shouldBeSynchronized ( $ strPath ) { if ( ! isset ( static :: $ arrShouldBeSynchronized [ $ strPath ] ) || ! \ is_bool ( static :: $ arrShouldBeSynchronized [ $ strPath ] ) ) { static :: $ arrShouldBeSynchronized [ $ strPath ] = ! static :: isFileSyncExclude ( $ strPath ) ; } return static :: $ arrShouldBeSynchronized [ $ strPath ] ; }
2903	public function downloadAsText ( Mage_Core_Model_Config_Element $ configNode ) { $ items = array ( ) ; Mage :: helper ( 'sheep_debug' ) -> xml2array ( $ configNode , $ items ) ; $ content = '' ; foreach ( $ items as $ key => $ value ) { $ content .= "$key = $value\n" ; } $ this -> _prepareDownloadResponse ( 'config.txt' , $ content , 'text/plain' ) ; }
583	public function actionCompress ( $ configFile , $ bundleFile ) { $ this -> loadConfiguration ( $ configFile ) ; $ bundles = $ this -> loadBundles ( $ this -> bundles ) ; $ targets = $ this -> loadTargets ( $ this -> targets , $ bundles ) ; foreach ( $ targets as $ name => $ target ) { $ this -> stdout ( "Creating output bundle '{$name}':\n" ) ; if ( ! empty ( $ target -> js ) ) { $ this -> buildTarget ( $ target , 'js' , $ bundles ) ; } if ( ! empty ( $ target -> css ) ) { $ this -> buildTarget ( $ target , 'css' , $ bundles ) ; } $ this -> stdout ( "\n" ) ; } $ targets = $ this -> adjustDependency ( $ targets , $ bundles ) ; $ this -> saveTargets ( $ targets , $ bundleFile ) ; if ( $ this -> deleteSource ) { $ this -> deletePublishedAssets ( $ bundles ) ; } }
5406	protected function findFirstMatch ( $ cookie ) { for ( $ i = 0 ; $ i < count ( $ this -> cookies ) ; $ i ++ ) { $ is_match = $ this -> isMatch ( $ cookie , $ this -> cookies [ $ i ] -> getHost ( ) , $ this -> cookies [ $ i ] -> getPath ( ) , $ this -> cookies [ $ i ] -> getName ( ) ) ; if ( $ is_match ) { return $ i ; } } return count ( $ this -> cookies ) ; }
4061	public function getLongMessage ( $ glue = ' ' ) { $ messages = array ( ) ; $ exception = $ this ; do { $ messages [ ] = $ exception -> getMessage ( ) ; } while ( null !== ( $ exception = $ exception -> getPrevious ( ) ) ) ; return implode ( $ glue , $ messages ) ; }
8712	public function whereTranslated ( $ column , $ operator = null , $ value = null , $ boolean = 'and' ) { if ( func_num_args ( ) == 2 ) { list ( $ value , $ operator ) = [ $ operator , '=' ] ; } elseif ( $ this -> invalidOperatorAndValue ( $ operator , $ value ) ) { throw new InvalidArgumentException ( 'Illegal operator and value combination.' ) ; } if ( ! in_array ( strtolower ( $ operator ) , $ this -> operators , true ) ) { list ( $ value , $ operator ) = [ $ operator , '=' ] ; } $ fallbackColumn = $ this -> qualifyTranslationColumn ( $ column , true ) ; $ column = $ this -> qualifyTranslationColumn ( $ column ) ; if ( ! $ this -> model -> shouldFallback ( ) || $ column instanceof Closure ) { return $ this -> where ( $ column , $ operator , $ value , $ boolean ) ; } $ condition = $ this -> compileIfNull ( $ column , $ fallbackColumn ) ; return $ this -> whereRaw ( "$condition $operator ?" , [ $ value ] , $ boolean ) ; }
12334	private function _checkPasswordIsGood ( ) : bool { $ sLogin = self :: $ _sLogin ; $ sPassword = Config :: get ( 'security' ) -> users -> $ sLogin -> password ; if ( $ sPassword == self :: $ _sPassword ) { return true ; } else if ( $ sPassword == md5 ( self :: $ _sPassword ) ) { return true ; } else { return false ; } }
885	public static function getName ( $ value ) { if ( ! self :: has ( $ value ) ) { throw new \ InvalidArgumentException ( sprintf ( 'No custom token was found for "%s".' , $ value ) ) ; } $ tokens = self :: getMapById ( ) ; return 'CT::' . $ tokens [ $ value ] ; }
12792	public static function createSnippet ( string $ snptName ) : ? Snippet { $ snptRoot = AppHelper :: getInstance ( ) -> getComponentRoot ( 'snippets' ) ; $ snptFile = $ snptRoot . \ DIRECTORY_SEPARATOR . strtolower ( $ snptName ) . '.php' ; if ( is_readable ( $ snptFile ) ) { return new Snippet ( $ snptFile ) ; } return null ; }
2566	protected function checkAnyNotEmpty ( ) { $ foundNotEmpty = false ; $ args = func_get_args ( ) ; foreach ( $ args as $ arg ) { if ( ! empty ( $ arg ) ) { $ foundNotEmpty = true ; break ; } } return $ foundNotEmpty ; }
8601	private function _convertDeleteSubscription ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'DeleteSubscription' ; if ( $ request -> isSetSellerId ( ) ) { $ parameters [ 'SellerId' ] = $ request -> getSellerId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } if ( $ request -> isSetMarketplaceId ( ) ) { $ parameters [ 'MarketplaceId' ] = $ request -> getMarketplaceId ( ) ; } if ( $ request -> isSetNotificationType ( ) ) { $ parameters [ 'NotificationType' ] = $ request -> getNotificationType ( ) ; } if ( $ request -> isSetDestination ( ) ) { $ DestinationDeleteSubscriptionInput = $ request -> getDestination ( ) ; foreach ( $ DestinationDeleteSubscriptionInput -> getDeliveryChannel ( ) as $ DeliveryChannelDestinationIndex => $ DeliveryChannelDestination ) { $ parameters [ 'Destination' . '.' . 'DeliveryChannel' . '.' . ( $ DeliveryChannelDestinationIndex + 1 ) ] = $ DeliveryChannelDestination ; } } return $ parameters ; }
2483	protected function getSearchTargets ( $ languageSettings ) { if ( $ this -> endpointResolver instanceof SingleEndpointResolver && ! $ this -> endpointResolver -> hasMultipleEndpoints ( ) ) { return '' ; } $ shards = array ( ) ; $ endpoints = $ this -> endpointResolver -> getSearchTargets ( $ languageSettings ) ; if ( ! empty ( $ endpoints ) ) { foreach ( $ endpoints as $ endpoint ) { $ shards [ ] = $ this -> endpointRegistry -> getEndpoint ( $ endpoint ) -> getIdentifier ( ) ; } } return implode ( ',' , $ shards ) ; }
11293	protected function _getAttributeData ( $ name , $ query = false , $ loadMap = false , $ record = false ) { if ( isset ( $ this -> model_data [ $ name ] ) ) { return $ this -> _getAttributeDataWhenSet ( $ name , $ query , $ loadMap , $ record ) ; } if ( isset ( $ this -> model_attributes [ $ name ] ) && ! isset ( $ this -> model_dynamicOff ) ) { return $ this -> _getAttributeDataWhenUnset ( $ name , $ query , $ loadMap , $ record ) ; } if ( isset ( $ this -> data -> { $ name } ) ) { $ this -> beforeGet ( $ name ) ; $ returnValue = $ this -> data -> { $ name } ; $ this -> afterGet ( $ name , $ returnValue ) ; return $ returnValue ; } $ class = get_class ( $ this ) ; if ( property_exists ( $ class , $ name ) ) { $ this -> beforeGet ( $ name ) ; $ returnValue = $ this -> { $ name } ; $ this -> afterGet ( $ name , $ returnValue ) ; return $ returnValue ; } if ( $ name == 'id' && property_exists ( $ class , 'id_name' ) ) { $ this -> beforeGet ( $ this -> id_name ) ; if ( isset ( $ this -> model_data [ $ this -> id_name ] ) ) { $ returnValue = $ this -> model_data [ $ this -> id_name ] ; } else { $ returnValue = $ this -> { $ this -> id_name } ; } $ this -> afterGet ( $ this -> id_name , $ returnValue ) ; return $ returnValue ; } if ( substr ( $ name , 0 , 6 ) != "model_" && $ this -> issetExtended ( $ name ) ) { $ this -> beforeGet ( $ name ) ; $ returnValue = $ this -> getExtendedAttribute ( $ name ) ; $ this -> afterGet ( $ name , $ returnValue ) ; return $ returnValue ; } $ this -> beforeGet ( $ name ) ; if ( isset ( $ this -> { $ name } ) ) { $ returnValue = $ this -> { $ name } ; } else { $ returnValue = null ; } $ this -> afterGet ( $ name , $ returnValue ) ; return $ returnValue ; }
1710	public function onReplaceInsertTags ( string $ tag , bool $ useCache , $ cacheValue , array $ flags ) { static $ supportedTags = [ 'faq' , 'faq_open' , 'faq_url' , 'faq_title' , ] ; $ elements = explode ( '::' , $ tag ) ; $ key = strtolower ( $ elements [ 0 ] ) ; if ( ! \ in_array ( $ key , $ supportedTags , true ) ) { return false ; } $ this -> framework -> initialize ( ) ; $ adapter = $ this -> framework -> getAdapter ( FaqModel :: class ) ; $ faq = $ adapter -> findByIdOrAlias ( $ elements [ 1 ] ) ; if ( null === $ faq || false === ( $ url = $ this -> generateUrl ( $ faq , \ in_array ( 'absolute' , $ flags , true ) ) ) ) { return '' ; } return $ this -> generateReplacement ( $ faq , $ key , $ url ) ; }
947	protected function scripttagExists ( array $ shopScripttags , array $ scripttag ) { foreach ( $ shopScripttags as $ shopScripttag ) { if ( $ shopScripttag -> src === $ scripttag [ 'src' ] ) { return true ; } } return false ; }
4115	public function getRemoteCallUrlTemplate ( ) { if ( is_null ( $ this -> remoteCallUrlTemplate ) ) { $ this -> remoteCallUrlTemplate = Mage :: getStoreConfig ( 'dev/aoe_templatehints/remoteCallUrlTemplate' ) ; } return $ this -> remoteCallUrlTemplate ; }
9483	public function toArray ( $ changedOnly = false , $ extraData = null ) { $ vars = get_object_vars ( $ this ) ; $ object = array ( ) ; if ( ! is_array ( $ this -> _changes ) ) { $ this -> _changes = array ( ) ; } if ( is_array ( $ extraData ) ) { $ vars = array_merge ( $ vars , $ extraData ) ; } foreach ( $ vars as $ k => $ v ) { if ( strpos ( $ k , '_' ) !== 0 && $ v !== null && ( ! $ changedOnly || array_key_exists ( $ k , $ this -> _changes ) || array_key_exists ( $ k , $ extraData ) ) ) { if ( is_array ( $ v ) ) { $ subV = array ( ) ; foreach ( $ v as $ sub ) { if ( is_a ( $ sub , 'Dlin\Zendesk\Entity\BaseEntity' ) ) { $ subV [ ] = $ sub -> toArray ( ) ; } else { $ subV [ ] = $ sub ; } } $ object [ $ k ] = $ subV ; } else if ( is_a ( $ v , 'Dlin\Zendesk\Entity\BaseEntity' ) ) { $ object [ $ k ] = $ v -> toArray ( ) ; } else { $ object [ $ k ] = $ v ; } } } return $ object ; }
9067	public static function bootUuidForKey ( ) { static :: creating ( function ( $ model ) { $ model -> incrementing = false ; $ model -> attributes [ $ model -> getKeyName ( ) ] = ( string ) Str :: orderedUuid ( ) ; } ) ; }
12754	protected function prepareRequest ( ) { if ( $ this -> method === static :: GET && ! empty ( $ this -> data ) ) { $ url = trim ( $ this -> url , '/' ) . '?' ; $ url .= http_build_query ( $ this -> data ) ; } else { $ url = $ this -> url ; } $ options = array ( CURLOPT_URL => $ url , CURLOPT_POST => $ this -> method === static :: POST , CURLOPT_HEADER => true , CURLOPT_NOBODY => $ this -> method === static :: HEAD , CURLOPT_RETURNTRANSFER => true , CURLOPT_USERAGENT => $ this -> userAgent , CURLOPT_SSL_VERIFYPEER => false ) ; if ( ! in_array ( $ this -> method , [ static :: GET , static :: HEAD , static :: POST ] ) ) { $ options [ CURLOPT_CUSTOMREQUEST ] = $ this -> method ; } if ( ! empty ( $ this -> data ) && $ this -> method !== static :: GET ) { $ options [ CURLOPT_POSTFIELDS ] = http_build_query ( $ this -> data ) ; } if ( ! empty ( $ this -> headers ) ) { $ headersToSend = [ ] ; foreach ( $ this -> headers as $ key => $ value ) { $ headersToSend [ ] = "{$key}: {$value}" ; } $ options [ CURLOPT_HTTPHEADER ] = $ headersToSend ; } if ( ! empty ( $ this -> cookies ) ) { $ cookiesToSend = [ ] ; foreach ( $ this -> cookies as $ key => $ value ) { $ cookiesToSend [ ] = "{$key}={$value}" ; } $ options [ CURLOPT_COOKIE ] = implode ( '; ' , $ cookiesToSend ) ; } curl_setopt_array ( $ this -> resource , $ options ) ; }
11	private function mockLocalRepositories ( RepositoryManager $ rm ) { $ packages = array ( ) ; foreach ( $ rm -> getLocalRepository ( ) -> getPackages ( ) as $ package ) { $ packages [ ( string ) $ package ] = clone $ package ; } foreach ( $ packages as $ key => $ package ) { if ( $ package instanceof AliasPackage ) { $ alias = ( string ) $ package -> getAliasOf ( ) ; $ packages [ $ key ] = new AliasPackage ( $ packages [ $ alias ] , $ package -> getVersion ( ) , $ package -> getPrettyVersion ( ) ) ; } } $ rm -> setLocalRepository ( new InstalledArrayRepository ( $ packages ) ) ; }
8480	public function run ( $ eventGroupId = null ) { $ eventGroups = EventGroup :: find ( ) -> asArray ( true ) -> all ( ) ; if ( count ( $ eventGroups ) === 0 ) { throw new Exception ( 'Event groups not found' ) ; } if ( $ eventGroupId === null ) { $ first = reset ( $ eventGroups ) ; $ eventGroupId = $ first [ 'id' ] ; } $ tabs = [ ] ; foreach ( $ eventGroups as $ eventGroup ) { $ tabs [ ] = [ 'label' => $ eventGroup [ 'name' ] , 'url' => [ 'index' , 'eventGroupId' => $ eventGroup [ 'id' ] ] , 'active' => $ eventGroupId == $ eventGroup [ 'id' ] , ] ; } $ model = new EventEventHandler ( [ 'scenario' => 'search' ] ) ; $ eventsList = Event :: find ( ) -> select ( [ 'name' , 'id' ] ) -> where ( [ 'event_group_id' => $ eventGroupId ] ) -> indexBy ( 'id' ) -> column ( ) ; return $ this -> controller -> render ( 'index' , [ 'dataProvider' => $ model -> search ( \ Yii :: $ app -> request -> get ( ) , array_keys ( $ eventsList ) ) , 'eventGroupId' => $ eventGroupId , 'eventsList' => $ eventsList , 'model' => $ model , 'tabs' => $ tabs , ] ) ; }
6756	public static function createApp ( string $ appPath , string $ environment , bool $ debug ) : BaseKernel { $ envPath = $ appPath . '/.env' ; if ( file_exists ( $ envPath ) ) { $ dotenv = new Dotenv ( ) ; $ dotenv -> load ( $ envPath ) ; } $ oneBundleAppConfig = new \ OneBundleApp \ App \ OneBundleAppConfig ( $ appPath , $ environment ) ; \ Symfony \ Component \ Debug \ ErrorHandler :: register ( ) ; \ Symfony \ Component \ Debug \ ExceptionHandler :: register ( ) ; return new \ Mmoreram \ BaseBundle \ Kernel \ BaseKernel ( $ oneBundleAppConfig -> getBundles ( ) , $ oneBundleAppConfig -> getConfig ( ) , $ oneBundleAppConfig -> getRoutes ( ) , $ environment , $ debug , $ appPath . '/var' ) ; }
7664	function AttachAll ( ) { $ mime = array ( ) ; for ( $ i = 0 ; $ i < count ( $ this -> attachment ) ; $ i ++ ) { $ bString = $ this -> attachment [ $ i ] [ 5 ] ; if ( $ bString ) $ string = $ this -> attachment [ $ i ] [ 0 ] ; else $ path = $ this -> attachment [ $ i ] [ 0 ] ; $ filename = $ this -> attachment [ $ i ] [ 1 ] ; $ name = $ this -> attachment [ $ i ] [ 2 ] ; $ encoding = $ this -> attachment [ $ i ] [ 3 ] ; $ type = $ this -> attachment [ $ i ] [ 4 ] ; $ disposition = $ this -> attachment [ $ i ] [ 6 ] ; $ cid = $ this -> attachment [ $ i ] [ 7 ] ; $ mime [ ] = sprintf ( "--%s%s" , $ this -> boundary [ 1 ] , $ this -> LE ) ; $ mime [ ] = sprintf ( "Content-Type: %s; name=\"%s\"%s" , $ type , $ name , $ this -> LE ) ; $ mime [ ] = sprintf ( "Content-Transfer-Encoding: %s%s" , $ encoding , $ this -> LE ) ; if ( $ disposition == "inline" ) $ mime [ ] = sprintf ( "Content-ID: <%s>%s" , $ cid , $ this -> LE ) ; $ mime [ ] = sprintf ( "Content-Disposition: %s; filename=\"%s\"%s" , $ disposition , $ name , $ this -> LE . $ this -> LE ) ; if ( $ bString ) { $ mime [ ] = $ this -> EncodeString ( $ string , $ encoding ) ; if ( $ this -> IsError ( ) ) { return "" ; } $ mime [ ] = $ this -> LE . $ this -> LE ; } else { $ mime [ ] = $ this -> EncodeFile ( $ path , $ encoding ) ; if ( $ this -> IsError ( ) ) { return "" ; } $ mime [ ] = $ this -> LE . $ this -> LE ; } } $ mime [ ] = sprintf ( "--%s--%s" , $ this -> boundary [ 1 ] , $ this -> LE ) ; return join ( "" , $ mime ) ; }
9314	public function storageClearAction ( ) { if ( ! $ this -> isConsoleRequest ( ) ) { throw new \ RuntimeException ( 'You can only use this action from a console!' ) ; } $ dbAdapter = $ this -> getDbAdapter ( ) ; $ console = $ this -> getConsole ( ) ; $ this -> printConsoleBanner ( $ console ) ; try { $ table = new JobTable ( $ dbAdapter ) ; $ table -> truncate ( ) ; } catch ( \ Exception $ exception ) { $ console -> writeLine ( 'Truncating database table failed!' , ConsoleColor :: LIGHT_RED ) ; return ; } $ console -> writeLine ( 'Storage was successfully cleared!' , ConsoleColor :: LIGHT_GREEN ) ; }
7757	public function processData ( $ data = array ( ) ) { if ( is_array ( $ data ) && 0 === count ( $ data ) ) { $ data = new \ stdClass ( ) ; } if ( ! is_string ( $ data ) ) { $ options = 0 ; if ( PHP_VERSION_ID >= 50400 ) { $ options |= JSON_UNESCAPED_SLASHES | JSON_UNESCAPED_UNICODE ; if ( self :: $ pretty ) { $ options |= JSON_PRETTY_PRINT ; } $ data = json_encode ( $ data , $ options ) ; } else { $ data = json_encode ( $ data ) ; $ data = str_replace ( '\\/' , '/' , $ data ) ; $ data = preg_replace_callback ( '/\\\\u([a-f0-9]{4})/' , function ( $ match ) { return iconv ( 'UCS-4LE' , 'UTF-8' , pack ( 'V' , hexdec ( $ match [ 1 ] ) ) ) ; } , $ data ) ; } } return $ this -> setContent ( $ data ) ; }
592	public function combineJsFiles ( $ inputFiles , $ outputFile ) { $ content = '' ; foreach ( $ inputFiles as $ file ) { $ fileContent = rtrim ( file_get_contents ( $ file ) ) ; if ( substr ( $ fileContent , - 1 ) !== ';' ) { $ fileContent .= "\n;" ; } $ content .= "/*** BEGIN FILE: $file ***/\n" . $ fileContent . "\n" . "/*** END FILE: $file ***/\n" ; } if ( ! file_put_contents ( $ outputFile , $ content ) ) { throw new Exception ( "Unable to write output JavaScript file '{$outputFile}'." ) ; } }
7488	public function append ( $ string ) { $ string = static :: convertString ( $ string , $ this -> encoding ) ; $ this -> string .= $ string ; return $ this ; }
2430	public function listStyleSheet ( $ row ) { $ cc = '' ; $ media = Contao \ StringUtil :: deserialize ( $ row [ 'media' ] ) ; if ( $ row [ 'cc' ] != '' ) { $ cc = ' &lt;!--[' . $ row [ 'cc' ] . ']&gt;' ; } if ( $ row [ 'mediaQuery' ] != '' ) { return '<div class="tl_content_left">' . $ row [ 'name' ] . ' <span style="color:#999;padding-left:3px">@media ' . $ row [ 'mediaQuery' ] . $ cc . '</span>' . "</div>\n" ; } elseif ( ! empty ( $ media ) && \ is_array ( $ media ) ) { return '<div class="tl_content_left">' . $ row [ 'name' ] . ' <span style="color:#999;padding-left:3px">@media ' . implode ( ', ' , $ media ) . $ cc . '</span>' . "</div>\n" ; } else { return '<div class="tl_content_left">' . $ row [ 'name' ] . $ cc . "</div>\n" ; } }
6592	protected function checkAndGetBusters ( ) { if ( $ this -> fileSystem -> fileExists ( $ this -> config [ 'bustersJsonPath' ] ) === false ) { throw new LengthException ( 'busters json not found.' ) ; } $ bustersJson = $ this -> fileSystem -> getFile ( $ this -> config [ 'bustersJsonPath' ] ) ; if ( $ bustersJson == '' ) { throw new UnderflowException ( 'busters json is empty.' ) ; } $ busters = json_decode ( $ bustersJson ) ; if ( json_last_error ( ) !== JSON_ERROR_NONE ) { throw new UnexpectedValueException ( 'bustersJson is invalid JSON.' ) ; } return $ busters ; }
2228	public function addBreadcrumb ( ) { $ objSessionBag = Contao \ System :: getContainer ( ) -> get ( 'session' ) -> getBag ( 'contao_backend' ) ; if ( isset ( $ _GET [ 'fn' ] ) ) { if ( Contao \ Validator :: isInsecurePath ( Contao \ Input :: get ( 'fn' , true ) ) ) { throw new RuntimeException ( 'Insecure path ' . Contao \ Input :: get ( 'fn' , true ) ) ; } $ objSessionBag -> set ( 'tl_templates_node' , Contao \ Input :: get ( 'fn' , true ) ) ; $ this -> redirect ( preg_replace ( '/(&|\?)fn=[^&]*/' , '' , Contao \ Environment :: get ( 'request' ) ) ) ; } $ strNode = $ objSessionBag -> get ( 'tl_templates_node' ) ; if ( $ strNode == '' ) { return ; } if ( Contao \ Validator :: isInsecurePath ( $ strNode ) ) { throw new RuntimeException ( 'Insecure path ' . $ strNode ) ; } $ rootDir = Contao \ System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( ! is_dir ( $ rootDir . '/' . $ strNode ) ) { $ objSessionBag -> set ( 'tl_templates_node' , '' ) ; return ; } $ strPath = 'templates' ; $ arrNodes = explode ( '/' , preg_replace ( '/^templates\//' , '' , $ strNode ) ) ; $ arrLinks = array ( ) ; $ arrLinks [ ] = Contao \ Image :: getHtml ( 'filemounts.svg' ) . ' <a href="' . $ this -> addToUrl ( 'fn=' ) . '" title="' . Contao \ StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'selectAllNodes' ] ) . '">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'filterAll' ] . '</a>' ; foreach ( $ arrNodes as $ strFolder ) { $ strPath .= '/' . $ strFolder ; if ( $ strFolder == basename ( $ strNode ) ) { $ arrLinks [ ] = Contao \ Image :: getHtml ( 'folderC.svg' ) . ' ' . $ strFolder ; } else { $ arrLinks [ ] = Contao \ Image :: getHtml ( 'folderC.svg' ) . ' <a href="' . $ this -> addToUrl ( 'fn=' . $ strPath ) . '" title="' . Contao \ StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'selectNode' ] ) . '">' . $ strFolder . '</a>' ; } } $ GLOBALS [ 'TL_DCA' ] [ 'tl_templates' ] [ 'list' ] [ 'sorting' ] [ 'root' ] = array ( $ strNode ) ; $ GLOBALS [ 'TL_DCA' ] [ 'tl_templates' ] [ 'list' ] [ 'sorting' ] [ 'breadcrumb' ] .= '<nav aria-label="' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'breadcrumbMenu' ] . '"> <ul id="tl_breadcrumb"> <li>' . implode ( '  </li><li>', $ r rLinks) . ' /li> </ul></nav>' ; }
302	public function getAttributeLabel ( $ attribute ) { $ labels = $ this -> attributeLabels ( ) ; if ( isset ( $ labels [ $ attribute ] ) ) { return $ labels [ $ attribute ] ; } elseif ( strpos ( $ attribute , '.' ) ) { $ attributeParts = explode ( '.' , $ attribute ) ; $ neededAttribute = array_pop ( $ attributeParts ) ; $ relatedModel = $ this ; foreach ( $ attributeParts as $ relationName ) { if ( $ relatedModel -> isRelationPopulated ( $ relationName ) && $ relatedModel -> $ relationName instanceof self ) { $ relatedModel = $ relatedModel -> $ relationName ; } else { try { $ relation = $ relatedModel -> getRelation ( $ relationName ) ; } catch ( InvalidParamException $ e ) { return $ this -> generateAttributeLabel ( $ attribute ) ; } $ modelClass = $ relation -> modelClass ; $ relatedModel = $ modelClass :: instance ( ) ; } } $ labels = $ relatedModel -> attributeLabels ( ) ; if ( isset ( $ labels [ $ neededAttribute ] ) ) { return $ labels [ $ neededAttribute ] ; } } return $ this -> generateAttributeLabel ( $ attribute ) ; }
11018	public function loadView ( $ data = [ ] , $ return = FALSE ) { $ retVal = NULL ; $ extra = [ 'route' => $ this -> _getRoute ( ) , ] ; extract ( $ extra , EXTR_OVERWRITE ) ; extract ( $ data , EXTR_OVERWRITE ) ; $ level = error_reporting ( ) ; error_reporting ( 0 ) ; ob_start ( ) ; if ( isset ( $ view ) ) { $ viewsDirEvent = new GetViewsDirEvent ( ) ; $ this -> dispatcher -> fire ( Events :: EVENT_GET_VIEWS_DIR , $ viewsDirEvent ) ; $ viewDir = $ viewsDirEvent -> getViewsDir ( ) ; if ( NULL === $ viewDir ) { throw new RawException ( 'The views directory has not been set.' ) ; } if ( FALSE !== strstr ( $ view , '.php' ) ) { include $ viewDir . $ view ; } else { include $ viewDir . $ view . '.php' ; } $ newView = ob_get_clean ( ) ; if ( $ return ) { $ retVal = $ newView ; } else { $ this -> pageView .= $ newView ; } } else { $ retVal = '' ; } error_reporting ( $ level ) ; return $ retVal ; }
4559	protected function execute ( LifecycleEventArgs $ args , $ action ) { $ this -> tokenStorage = $ this -> container -> get ( 'security.token_storage' ) ; $ this -> configService = $ this -> container -> get ( 'ds_config.service.config' ) ; $ this -> auditService = $ this -> container -> get ( 'ds_audit.service.audit' ) ; $ entity = $ args -> getEntity ( ) ; if ( $ entity instanceof Audit ) { return ; } if ( ! $ entity instanceof Auditable ) { return ; } $ token = $ this -> tokenStorage -> getToken ( ) ; if ( ! $ token ) { return ; } $ user = $ token -> getUser ( ) ; $ edits = $ args -> getEntityManager ( ) -> getUnitOfWork ( ) -> getEntityChangeSet ( $ entity ) ; $ properties = $ this -> auditService -> getProperties ( $ entity ) ; foreach ( array_keys ( $ edits ) as $ key ) { if ( ! in_array ( $ key , $ properties ) ) { unset ( $ edits [ $ key ] ) ; } } $ audit = $ this -> auditService -> createInstance ( ) ; $ audit -> setOwner ( $ this -> configService -> get ( 'ds_audit.audit.owner' ) ) -> setOwnerUuid ( $ this -> configService -> get ( 'ds_audit.audit.owner_uuid' ) ) -> setUserUuid ( $ user -> getUuid ( ) ) -> setIdentity ( $ user -> getIdentity ( ) -> getType ( ) ) -> setIdentityUuid ( $ user -> getIdentity ( ) -> getUuid ( ) ) -> setAction ( $ action ) -> setData ( [ 'entity' => basename ( str_replace ( '\\' , '/' , get_class ( $ entity ) ) ) , 'entityUuid' => $ entity -> getUuid ( ) , 'edits' => $ edits ] ) ; $ manager = $ this -> auditService -> getManager ( ) ; $ manager -> persist ( $ audit ) ; $ manager -> flush ( ) ; }
3000	public function reset ( $ key = null ) { if ( $ key ) { $ key = ucfirst ( $ key ) ; $ this -> smtp -> clear ( $ key ) ; if ( isset ( $ this -> recipients [ $ key ] ) ) unset ( $ this -> recipients [ $ key ] ) ; } else { $ this -> recipients = array ( ) ; $ this -> initSMTP ( ) ; } }
4952	protected function checkRatingValue ( $ rating , $ throwException = true ) { if ( ! is_int ( $ rating ) || static :: RATING_EXCELLENT < $ rating || static :: RATING_NONE > $ rating ) { if ( $ throwException ) { throw new \ InvalidArgumentException ( sprintf ( '%s is not a valid rating value.' , $ rating ) ) ; } return false ; } return true ; }
4304	public function profileEnd ( $ name = null ) { $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) , array ( 'name' => null ) , array ( 'name' ) ) ; if ( $ meta [ 'name' ] === null ) { \ end ( $ this -> data [ 'profileInstances' ] ) ; $ meta [ 'name' ] = \ key ( $ this -> data [ 'profileInstances' ] ) ; } $ name = $ meta [ 'name' ] ; if ( isset ( $ this -> data [ 'profileInstances' ] [ $ name ] ) ) { $ instance = $ this -> data [ 'profileInstances' ] [ $ name ] ; $ data = $ instance -> end ( ) ; $ caption = 'Profile \'' . $ name . '\' Results' ; if ( $ data ) { $ args = array ( $ data ) ; $ meta [ 'sortable' ] = true ; $ meta [ 'caption' ] = $ caption ; $ meta [ 'totalCols' ] = array ( 'ownTime' ) ; $ meta [ 'columns' ] = array ( ) ; } else { $ args = array ( $ caption , 'no data' ) ; } unset ( $ this -> data [ 'profileInstances' ] [ $ name ] ) ; } else { $ args = array ( $ name !== null ? 'profileEnd: No such Profile: ' . $ name : 'profileEnd: Not currently profiling' ) ; } $ this -> appendLog ( __FUNCTION__ , $ args , $ meta ) ; }
10036	function getBlockedContacts ( $ standardFields = array ( ) , $ customFields = array ( ) , $ pageIndex = 1 , $ pageSize = 1000 ) { $ queryParameters = array ( 'standard_field' => $ standardFields , 'page_index' => $ pageIndex , 'page_size' => $ pageSize ) ; $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , 'custom_field' , $ customFields ) ; return $ this -> get ( 'contacts/blocked' , $ queryParameters ) ; }
7897	protected function createProviderInstance ( $ provider ) { if ( ! $ this -> isProviderAliasExists ( $ provider ) ) { throw new InvalidArgumentException ( "File provider [{$provider}] is invalid." ) ; } if ( ! isset ( $ this -> resolvedProviders [ $ provider ] ) ) { $ this -> resolvedProviders [ $ provider ] = isset ( $ this -> customProviders [ $ provider ] ) ? $ this -> callCustomProvider ( $ provider ) : $ this -> app -> make ( $ this -> providers [ $ provider ] ) ; } return $ this -> resolvedProviders [ $ provider ] ; }
7748	private function isAccessible ( \ ReflectionClass $ class , $ methodName , $ parameters ) { if ( $ class -> hasMethod ( $ methodName ) ) { $ method = $ class -> getMethod ( $ methodName ) ; if ( $ method -> isPublic ( ) && $ method -> getNumberOfRequiredParameters ( ) === $ parameters ) { return true ; } } return false ; }
12181	public function getPrimaryObject ( $ primaryObject , $ relatedObject , $ role ) { if ( ! $ this -> handlePrimary ) { return false ; } if ( $ role === 'child' ) { $ primaryField = 'primary_child' ; if ( ! $ relatedObject -> objectType -> getPrimaryAsChild ( $ this -> parent ) ) { return false ; } $ primaryParent = $ primaryObject ; } else { $ primaryField = 'primary_parent' ; if ( ! $ relatedObject -> objectType -> getPrimaryAsParent ( $ this -> child ) ) { return false ; } $ primaryParent = $ relatedObject ; } $ key = json_encode ( [ __FUNCTION__ , $ this -> systemId , $ primaryObject -> primaryKey ] ) ; if ( ! isset ( self :: $ _cache [ $ key ] ) ) { self :: $ _cache [ $ key ] = null ; $ relationClass = Yii :: $ app -> classes [ 'Relation' ] ; $ childClass = $ this -> child -> primaryModel ; $ relation = $ relationClass :: find ( ) ; $ alias = $ relationClass :: tableName ( ) ; $ relation -> andWhere ( [ '`' . $ alias . '`.`parent_object_id`' => $ primaryParent -> primaryKey , '`' . $ alias . '`.`' . $ primaryField . '`' => 1 ] ) ; $ relation -> andWhere ( [ 'or' , '`' . $ alias . '`.`child_object_id` LIKE :prefix' ] ) ; $ relation -> params [ ':prefix' ] = $ childClass :: modelPrefix ( ) . '-%' ; $ primaryObject -> addActiveConditions ( $ relation , $ alias ) ; $ relation = $ relation -> one ( ) ; if ( ! empty ( $ relation ) ) { self :: $ _cache [ $ key ] = $ relation ; } } return self :: $ _cache [ $ key ] ; }
2593	protected function loadFeeIds ( $ feeIds ) { if ( is_null ( $ this -> feeIdDescription ) ) { $ this -> feeIdDescription = new FeeIdDescription ( ) ; } foreach ( $ feeIds as $ feeId ) { $ this -> feeIdDescription -> feeId [ ] = new FeeId ( $ feeId -> type , $ feeId -> number ) ; } }
6364	public function nullsFirst ( ) : Ordering { return Ordering :: from ( Collections :: comparatorFrom ( function ( $ object1 , $ object2 ) { return $ object1 === null ? - 1 : ( $ object2 === null ? 1 : $ this -> compare ( $ object1 , $ object2 ) ) ; } ) ) ; }
3833	protected function getLangValue ( $ arrValues , $ strLangCode = null ) { if ( ! ( $ this -> getMetaModel ( ) -> isTranslated ( ) && is_array ( $ arrValues ) ) ) { return $ arrValues ; } if ( $ strLangCode === null ) { return $ this -> getLangValue ( $ arrValues , $ this -> getMetaModel ( ) -> getActiveLanguage ( ) ) ; } if ( array_key_exists ( $ strLangCode , $ arrValues ) ) { return $ arrValues [ $ strLangCode ] ; } return $ arrValues [ $ this -> getMetaModel ( ) -> getFallbackLanguage ( ) ] ; }
8908	public function created_at ( $ row ) { if ( is_object ( $ row ) ) { $ row -> { $ this -> created_at_key } = date ( 'Y-m-d H:i:s' ) ; } else { $ row [ $ this -> created_at_key ] = date ( 'Y-m-d H:i:s' ) ; } return $ row ; }
11119	protected function runUp ( array $ file , int $ batch ) : void { $ this -> notify -> note ( "<comment>Migrating:</comment> {$file['basename']}" ) ; $ this -> runMigration ( $ file ) ; $ this -> repository -> log ( $ this -> getMigrationName ( $ file ) , $ batch ) ; $ this -> notify -> note ( "<info>Migrated:</info> {$file['basename']}" ) ; }
2163	public function run40Update ( ) { $ this -> Database -> query ( "ALTER TABLE `tl_layout` ADD `scripts` text NULL" ) ; $ objLayout = $ this -> Database -> query ( "SELECT id, addJQuery, jquery, addMooTools, mootools FROM tl_layout WHERE framework!=''" ) ; while ( $ objLayout -> next ( ) ) { $ arrScripts = array ( ) ; if ( $ objLayout -> addJQuery ) { $ jquery = StringUtil :: deserialize ( $ objLayout -> jquery ) ; if ( ! empty ( $ jquery ) && \ is_array ( $ jquery ) ) { if ( ( $ key = array_search ( 'j_slider' , $ jquery ) ) !== false ) { $ arrScripts [ ] = 'js_slider' ; unset ( $ jquery [ $ key ] ) ; $ this -> Database -> prepare ( "UPDATE tl_layout SET jquery=? WHERE id=?" ) -> execute ( serialize ( array_values ( $ jquery ) ) , $ objLayout -> id ) ; } } } if ( $ objLayout -> addMooTools ) { $ mootools = StringUtil :: deserialize ( $ objLayout -> mootools ) ; if ( ! empty ( $ mootools ) && \ is_array ( $ mootools ) ) { if ( ( $ key = array_search ( 'moo_slider' , $ mootools ) ) !== false ) { $ arrScripts [ ] = 'js_slider' ; unset ( $ mootools [ $ key ] ) ; $ this -> Database -> prepare ( "UPDATE tl_layout SET mootools=? WHERE id=?" ) -> execute ( serialize ( array_values ( $ mootools ) ) , $ objLayout -> id ) ; } } } if ( ! empty ( $ arrScripts ) ) { $ this -> Database -> prepare ( "UPDATE tl_layout SET scripts=? WHERE id=?" ) -> execute ( serialize ( array_values ( array_unique ( $ arrScripts ) ) ) , $ objLayout -> id ) ; } } }
3247	public function add ( $ item , $ quantity = 1 , $ quantityReset = false ) { if ( ! is_array ( $ item ) && ! $ item -> isShoppable ) return ; $ cartItem = $ this -> getItem ( is_array ( $ item ) ? $ item [ 'sku' ] : $ item -> sku ) ; if ( empty ( $ cartItem ) ) { $ reflection = null ; if ( is_object ( $ item ) ) { $ reflection = new \ ReflectionClass ( $ item ) ; } $ cartItem = call_user_func ( Config :: get ( 'shop.item' ) . '::create' , [ 'user_id' => $ this -> user -> shopId , 'cart_id' => $ this -> attributes [ 'id' ] , 'sku' => is_array ( $ item ) ? $ item [ 'sku' ] : $ item -> sku , 'price' => is_array ( $ item ) ? $ item [ 'price' ] : $ item -> price , 'tax' => is_array ( $ item ) ? ( array_key_exists ( 'tax' , $ item ) ? $ item [ 'tax' ] : 0 ) : ( isset ( $ item -> tax ) && ! empty ( $ item -> tax ) ? $ item -> tax : 0 ) , 'shipping' => is_array ( $ item ) ? ( array_key_exists ( 'shipping' , $ item ) ? $ item [ 'shipping' ] : 0 ) : ( isset ( $ item -> shipping ) && ! empty ( $ item -> shipping ) ? $ item -> shipping : 0 ) , 'currency' => Config :: get ( 'shop.currency' ) , 'quantity' => $ quantity , 'class' => is_array ( $ item ) ? null : $ reflection -> getName ( ) , 'reference_id' => is_array ( $ item ) ? null : $ item -> shopId , ] ) ; } else { $ cartItem -> quantity = $ quantityReset ? $ quantity : $ cartItem -> quantity + $ quantity ; $ cartItem -> save ( ) ; } $ this -> resetCalculations ( ) ; return $ this ; }
1341	public function find ( ResourceIdentifierInterface $ identifier ) { $ record = $ this -> lookup ( $ identifier ) ; if ( false === $ record ) { return false ; } return is_object ( $ record ) ? $ record : null ; }
4644	public function stop ( Job $ job , $ timeout = 10 ) { foreach ( $ job -> getServices ( ) as $ service ) { if ( $ service -> getContainer ( ) ) { try { $ this -> docker -> getContainerManager ( ) -> stop ( $ service -> getContainer ( ) , [ 't' => $ timeout ] ) ; } catch ( ClientErrorException $ e ) { if ( $ e -> getResponse ( ) -> getStatusCode ( ) != 304 ) { throw $ e ; } } $ this -> docker -> getContainerManager ( ) -> remove ( $ service -> getContainer ( ) , [ 'v' => true , 'force' => true ] ) ; $ service -> setContainer ( null ) ; } } }
11397	public static function parseFault ( \ SimpleXMLElement $ fault ) { $ faultData = static :: parseStruct ( $ fault -> value -> struct ) ; return new \ Devedge \ XmlRpc \ Client \ RemoteException ( $ faultData [ 'faultString' ] , $ faultData [ 'faultCode' ] ) ; }
12303	protected function generateSiteMap ( ) { $ urls = array ( ) ; $ siteName = $ this -> configurationHandler -> siteName ( ) ; foreach ( $ this -> pagesCollectionParser -> pages ( ) as $ page ) { foreach ( $ page [ "seo" ] as $ seo ) { $ urls [ ] = array ( 'href' => $ siteName . '/' . $ seo [ "permalink" ] , 'frequency' => $ seo [ "sitemap_frequency" ] , 'priority' => $ seo [ "sitemap_priority" ] , ) ; } } return $ this -> twig -> render ( 'RedKiteCms/Resources/views/Sitemap/sitemap.html.twig' , array ( 'urls' => $ urls ) ) ; }
12366	public function getNextVideoToConvert ( ) { $ query = $ this -> createQueryBuilder ( 'v' ) ; $ this -> onlyUploaded ( $ query ) ; return $ query -> getQuery ( ) -> getOneOrNullResult ( ) ; }
5171	private function getAvailableRatios ( ) : array { return [ self :: RATIO_SQUARE , self :: RATIO_RECTANGLE , self :: RATIO_HEADLINE , self :: RATIO_VERTICAL , self :: RATIO_COVER , ] ; }
10696	public function toArray ( ) : array { if ( empty ( $ this -> output ) ) { $ problem = [ 'type' => $ this -> type ? ( string ) $ this -> type : 'about:blank' ] ; if ( $ this -> title ) { $ problem [ 'title' ] = $ this -> title ; } if ( $ this -> status ) { $ problem [ 'status' ] = $ this -> status ; } if ( $ this -> detail ) { $ problem [ 'detail' ] = $ this -> detail ; } if ( $ this -> instance ) { $ problem [ 'instance' ] = ( string ) $ this -> instance ; } $ this -> output = array_merge ( $ problem , $ this -> extensions ) ; } return $ this -> output ; }
2728	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ name = $ this -> getRequest ( ) -> getParam ( 'name' ) ; $ type = $ this -> getRequest ( ) -> getParam ( 'type' ) ; $ priority = $ this -> getRequest ( ) -> getParam ( 'priority' ) ; $ vcl = $ this -> getRequest ( ) -> getParam ( 'vcl' ) ; $ validation = $ this -> config -> validateCustomSnippet ( $ name , $ type , $ priority ) ; $ error = $ validation [ 'error' ] ; if ( $ error != null ) { throw new LocalizedException ( __ ( $ error ) ) ; } $ snippetName = $ validation [ 'snippet_name' ] ; $ fileName = $ type . '_' . $ priority . '_' . $ snippetName . '.vcl' ; $ write = $ this -> filesystem -> getDirectoryWrite ( DirectoryList :: VAR_DIR ) ; $ snippetPath = $ write -> getRelativePath ( Config :: CUSTOM_SNIPPET_PATH . $ fileName ) ; $ write -> writeFile ( $ snippetPath , $ vcl ) ; return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
698	public function actionRun ( $ command ) { $ command = implode ( ' ' , \ func_get_args ( ) ) ; $ base = \ dirname ( \ dirname ( __DIR__ ) ) ; $ dirs = $ this -> listSubDirs ( "$base/extensions" ) ; $ dirs = array_merge ( $ dirs , $ this -> listSubDirs ( "$base/apps" ) ) ; asort ( $ dirs ) ; $ oldcwd = getcwd ( ) ; foreach ( $ dirs as $ dir ) { $ displayDir = substr ( $ dir , \ strlen ( $ base ) ) ; $ this -> stdout ( "Running '$command' in $displayDir...\n" , Console :: BOLD ) ; chdir ( $ dir ) ; passthru ( $ command ) ; $ this -> stdout ( "done.\n" , Console :: BOLD , Console :: FG_GREEN ) ; } chdir ( $ oldcwd ) ; }
9252	protected function initializeContainer ( ) { $ this -> registerDefaultExtensions ( ) ; $ initializer = $ this -> getContainerInitializer ( ) ; $ this -> container = $ initializer -> initializeContainer ( $ this , $ this -> extensions , $ this -> compilerPasses ) ; $ this -> container -> set ( 'app' , $ this ) ; return $ this -> container ; }
8476	public function info ( $ scope , $ message , $ context = [ ] , $ config = [ ] ) { return $ this -> write ( 'info' , $ scope , $ message , $ context , $ config ) ; }
12331	public function get ( $ key ) { if ( ! $ this -> repository -> containsKey ( $ key ) ) throw new ReferenceDoesNotExistException ( ) ; return $ this -> repository -> get ( $ key ) ; }
4683	public static function stop ( $ key = 'default' ) : void { if ( isset ( self :: $ timers [ $ key ] ) ) { self :: $ timers [ $ key ] -> stop ( ) ; } else { throw new \ LogicException ( 'Stopping timer when the given key timer was not initialized.' ) ; } }
1484	public static function create ( $ mediaType , $ decoder ) : self { if ( is_string ( $ mediaType ) ) { $ mediaType = MediaType :: parse ( 0 , $ mediaType ) ; } if ( ! $ mediaType instanceof MediaTypeInterface ) { throw new \ InvalidArgumentException ( 'Expecting a media type object or string.' ) ; } if ( is_string ( $ decoder ) ) { $ decoder = app ( $ decoder ) ; } if ( ! $ decoder instanceof DecoderInterface ) { throw new \ InvalidArgumentException ( 'Expecting a decoder or decoder service name.' ) ; } return new self ( $ mediaType , $ decoder ) ; }
4895	public function render ( $ type = null , $ content = true , array $ options = array ( ) ) { if ( is_array ( $ type ) ) { $ options = $ type ; $ type = self :: TYPE_INFO ; $ content = true ; } elseif ( is_array ( $ content ) ) { $ options = $ content ; $ content = true ; } if ( true === $ content ) { return $ this -> start ( $ type , $ options ) ; } $ id = isset ( $ options [ 'id' ] ) ? ' id="' . $ options [ 'id' ] . '"' : '' ; $ class = isset ( $ options [ 'class' ] ) ? ' ' . $ options [ 'class' ] : '' ; if ( ( isset ( $ options [ 'dismissable' ] ) && $ options [ 'dismissable' ] ) || ! isset ( $ options [ 'dismissable' ] ) ) { $ class .= ' alert-dismissable' ; $ content = '<button type="button" class="close" data-dismiss="alert">&times;</button>' . '<span class="notification-content">' . $ content . '</span>' ; } $ target = array_key_exists ( 'target' , $ options ) ? ' target="' . $ options [ 'target' ] . '"' : '' ; $ markup = '<div ' . $ id . ' class="alert alert-' . $ type . $ class . '" ' . $ target . '>' . $ content . '</div>' . PHP_EOL ; return $ markup ; }
11606	public function getPHPHint ( $ namespaceContext = NULL ) { if ( ! isset ( $ this -> class ) ) { return '\stdClass' ; } if ( isset ( $ namespaceContext ) && trim ( $ this -> class -> getNamespace ( ) , '\\' ) === trim ( $ namespaceContext , '\\' ) ) { return $ this -> class -> getName ( ) ; } return '\\' . $ this -> class -> getFQN ( ) ; }
1488	public function when ( bool $ test , $ decodings ) : self { if ( ! $ test ) { return $ this ; } if ( $ decodings instanceof \ Closure ) { return $ decodings ( $ this ) ; } $ decodings = $ decodings instanceof Decoding ? [ $ decodings ] : $ decodings ; return $ this -> push ( ... $ decodings ) ; }
5954	public function channelCreate ( array $ properties ) { $ cid = $ this -> execute ( "channelcreate" , $ properties ) -> toList ( ) ; $ this -> channelListReset ( ) ; if ( ! isset ( $ properties [ "client_flag_permanent" ] ) && ! isset ( $ properties [ "client_flag_semi_permanent" ] ) ) { $ this -> getParent ( ) -> whoamiSet ( "client_channel_id" , $ cid [ "cid" ] ) ; } return $ cid [ "cid" ] ; }
8443	public function exit ( $ id , $ pid , $ code , $ forceRetry = false , $ queueBackoffTime = null ) { $ this -> logger -> info ( 'Job ended' , [ 'exitCode' => $ code , 'pid' => $ pid , 'jobId' => $ id , 'queue' => $ this -> queue -> getName ( ) ] ) ; $ hash = explode ( ':' , $ id ) ; $ jobId = $ hash [ count ( $ hash ) - 1 ] ; try { $ job = $ this -> queue -> getJob ( $ jobId ) ; } catch ( JobNotFoundException $ e ) { $ this -> logger -> info ( 'Unable to process job exit code or retry status. Job data unavailable' , [ 'exitCode' => $ code , 'pid' => $ pid , 'jobId' => $ job -> getId ( ) , 'queue' => $ this -> queue -> getName ( ) ] ) ; return true ; } if ( $ code === 0 ) { $ this -> logger -> info ( 'Job succeeded and is now complete' , [ 'exitCode' => $ code , 'pid' => $ pid , 'jobId' => $ job -> getId ( ) , 'queue' => $ this -> queue -> getName ( ) ] ) ; return $ job -> end ( ) ; } else { $ retry = $ job -> getRetry ( ) ; if ( $ forceRetry === true ) { $ retry = true ; } if ( $ retry === true || $ retry > 0 ) { $ this -> logger -> info ( 'Rescheduling job' , [ 'exitCode' => $ code , 'pid' => $ pid , 'jobId' => $ job -> getId ( ) , 'queue' => $ this -> queue -> getName ( ) , 'time' => \ time ( ) + $ queueBackoffTime ?? 0 ] ) ; return $ job -> retry ( $ queueBackoffTime ) ; } else { $ this -> logger -> info ( 'Job failed' , [ 'exitCode' => $ code , 'pid' => $ pid , 'jobId' => $ job -> getId ( ) , 'queue' => $ this -> queue -> getName ( ) ] ) ; return $ job -> fail ( ) ; } } return ; }
1136	public function setDepth ( ) { $ self = $ this ; $ this -> getConnection ( ) -> transaction ( function ( ) use ( $ self ) { $ self -> reload ( ) ; $ level = $ self -> getLevel ( ) ; $ self -> newNestedSetQuery ( ) -> where ( $ self -> getKeyName ( ) , '=' , $ self -> getKey ( ) ) -> update ( array ( $ self -> getDepthColumnName ( ) => $ level ) ) ; $ self -> setAttribute ( $ self -> getDepthColumnName ( ) , $ level ) ; } ) ; return $ this ; }
5919	public function setCreated ( $ created ) { if ( $ created instanceof DateTime ) { $ this -> created = $ created ; } else { try { $ this -> created = new DateTime ( $ created ) ; } catch ( \ Exception $ e ) { $ this -> created = null ; } } return $ this ; }
11141	public function getType ( $ props ) { $ result = '' ; if ( isset ( $ props [ 'type' ] ) ) { if ( $ props [ 'type' ] == 'varchar' || $ props [ 'type' ] == 'string' ) { if ( isset ( $ props [ 'size' ] ) ) { $ result = 'varchar(' . $ props [ 'size' ] . ')' ; } else { $ result = 'varchar(255)' ; } } else if ( $ props [ 'type' ] == 'int' || $ props [ 'type' ] == 'integer' ) { if ( isset ( $ props [ 'size' ] ) ) { $ result = 'int(' . $ props [ 'size' ] . ')' ; } else { $ result = 'int' ; } } else if ( $ props [ 'type' ] == 'float' || $ props [ 'type' ] == 'double' ) { if ( isset ( $ props [ 'size' ] ) && isset ( $ props [ 'precision' ] ) ) { $ result = 'float(' . $ props [ 'size' ] . ', ' . $ props [ 'precision' ] . ')' ; } else { $ result = 'float' ; } } else if ( $ props [ 'type' ] == 'date' ) { $ result = 'date' ; } else if ( $ props [ 'type' ] == 'datetime' ) { $ result = 'datetime' ; } else if ( $ props [ 'type' ] == 'enum' ) { if ( isset ( $ props [ 'enum' ] ) ) { $ result = 'ENUM(' . $ props [ 'enum' ] . ')' ; } else { $ result = "ENUM('default')" ; } } else { if ( isset ( $ props [ 'size' ] ) ) { $ result = $ props [ 'type' ] . '(' . $ props [ 'size' ] . ')' ; } else { $ result = $ props [ 'type' ] ; } } } else { return 'varchar(255)' ; } return $ result ; }
6150	public function setJsonBody ( $ data ) { $ this -> addHeader ( "Content-Type: application/json; charset=utf8" ) ; $ this -> setBody ( json_encode ( $ data , JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES ) ) ; return $ this ; }
10249	public function getDate ( $ params = [ ] , $ format = 'Y-m-d' ) { foreach ( $ params as $ k => $ v ) { $ $ k = $ v ; } if ( ! isset ( $ min_year ) ) { $ min_year = date ( 'Y' ) - 2 ; } if ( ! isset ( $ max_year ) ) { $ max_year = date ( 'Y' ) ; } if ( ! isset ( $ min_month ) ) { $ min_month = 1 ; } if ( ! isset ( $ max_month ) ) { $ max_month = 12 ; } $ rand_year = rand ( $ min_year , $ max_year ) ; $ rand_month = rand ( $ min_month , $ max_month ) ; $ date = DateTime :: createFromFormat ( 'Y-m-d' , join ( '-' , [ $ rand_year , $ rand_month , '01' ] ) ) ; $ days_in_month = $ date -> format ( 't' ) ; $ rand_day = rand ( 1 , $ days_in_month ) ; return DateTime :: createFromFormat ( 'Y-m-d' , join ( '-' , [ $ rand_year , $ rand_month , $ rand_day ] ) ) -> format ( $ format ) ; }
3402	protected function applyResultCallbackChain ( Crawler $ node , ApistMethod $ method ) { if ( empty ( $ this -> resultMethodChain ) ) { $ this -> addCallback ( 'text' ) ; } $ traceStack = [ ] ; foreach ( $ this -> resultMethodChain as $ resultCallback ) { try { $ traceStack [ ] = $ resultCallback ; $ node = $ resultCallback -> apply ( $ node , $ method ) ; } catch ( InvalidArgumentException $ e ) { if ( $ method -> getResource ( ) -> isSuppressExceptions ( ) ) { return null ; } $ message = $ this -> createExceptionMessage ( $ e , $ traceStack ) ; throw new InvalidArgumentException ( $ message , 0 , $ e ) ; } } return $ node ; }
6503	public function produce ( Message $ message ) { $ type = $ message -> getType ( ) ; $ body = array ( 'ticket' => $ message -> getTicket ( ) ) ; try { $ this -> logger -> debug ( sprintf ( 'Publish message for job %s to sonata backend' , $ message -> getTicket ( ) ) , [ 'type' => $ type , 'body' => $ body ] ) ; $ queue = $ this -> registry -> get ( $ message -> getType ( ) ) -> getQueue ( ) ; $ this -> backendProvider -> getBackend ( $ queue ) -> createAndPublish ( $ type , $ body ) ; } catch ( \ Exception $ e ) { $ this -> logger -> error ( sprintf ( 'Failed to publish message (Error: %s)' , $ e -> getMessage ( ) ) , [ 'exception' => $ e ] ) ; if ( ! $ e instanceof \ RuntimeException ) { $ e = new \ RuntimeException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } throw $ e ; } }
2444	public static function decrypt ( $ varValue , $ strKey = null ) { if ( \ is_array ( $ varValue ) ) { foreach ( $ varValue as $ k => $ v ) { $ varValue [ $ k ] = static :: decrypt ( $ v ) ; } return $ varValue ; } elseif ( $ varValue == '' ) { return '' ; } if ( static :: $ resTd === null ) { static :: initialize ( ) ; } $ varValue = base64_decode ( $ varValue ) ; $ ivsize = mcrypt_enc_get_iv_size ( static :: $ resTd ) ; $ iv = substr ( $ varValue , 0 , $ ivsize ) ; $ varValue = substr ( $ varValue , $ ivsize ) ; if ( $ varValue == '' ) { return '' ; } if ( ! $ strKey ) { $ strKey = System :: getContainer ( ) -> getParameter ( 'contao.encryption_key' ) ; } mcrypt_generic_init ( static :: $ resTd , md5 ( $ strKey ) , $ iv ) ; $ strDecrypted = mdecrypt_generic ( static :: $ resTd , $ varValue ) ; mcrypt_generic_deinit ( static :: $ resTd ) ; return $ strDecrypted ; }
4409	protected function render ( $ template , $ parameters ) { $ twig = new Twig_Environment ( new Twig_Loader_Filesystem ( $ this -> skeletonDirs ) , array ( 'debug' => true , 'cache' => false , 'strict_variables' => true , 'autoescape' => false , ) ) ; return $ twig -> render ( $ template , $ parameters ) ; }
9257	public function get ( $ id , $ invalidBehavior = ContainerInterface :: EXCEPTION_ON_INVALID_REFERENCE ) { if ( ! $ this -> booted ) { $ this -> boot ( ) ; } return $ this -> container -> get ( $ id , $ invalidBehavior ) ; }
6691	public function addRoute ( $ httpMethod , $ route , $ handler , array $ middleware = [ ] ) { if ( ! $ handler instanceof HandlerContainer ) { $ handler = new HandlerContainer ( $ handler , array_merge ( $ this -> middlewareStack , $ middleware ) ) ; } else { $ handler -> addMiddleware ( array_merge ( $ this -> middlewareStack , $ middleware ) ) ; } $ handler = serialize ( $ handler ) ; $ route = $ this -> currentGroupPrefix . $ route ; $ routeDatas = $ this -> routeParser -> parse ( $ route ) ; foreach ( ( array ) $ httpMethod as $ method ) { foreach ( $ routeDatas as $ routeData ) { $ this -> dataGenerator -> addRoute ( $ method , $ routeData , $ handler ) ; } } }
221	protected function normalizeNumericValue ( $ value ) { if ( empty ( $ value ) ) { return 0 ; } if ( is_string ( $ value ) && is_numeric ( $ value ) ) { $ value = ( float ) $ value ; } if ( ! is_numeric ( $ value ) ) { throw new InvalidArgumentException ( "'$value' is not a numeric value." ) ; } return $ value ; }
3491	public function withHeader ( string $ name , string $ value ) : Request { $ cloned = clone $ this ; $ cloned -> headers [ $ name ] = $ value ; return $ cloned ; }
5774	public function isDeletable ( ) : bool { if ( is_null ( $ this -> authorization ) ) { throw new \ Exception ( "Authorization must be set" ) ; } $ id = $ this -> getId ( ) ; if ( $ this -> isLoggedIn ( ) ) { $ this -> notDeletableReason = "Administrator cannot delete own account: id $id" ; return false ; } if ( ! $ this -> getAuthorization ( ) -> hasTopRole ( ) && $ this -> hasTopRole ( ) ) { $ this -> notDeletableReason = "Not authorized to delete administrator: id $id" ; return false ; } if ( ( EventsTableMapper :: getInstance ( ) ) -> existForAdministrator ( $ id ) ) { $ this -> notDeletableReason = "Events exist for administrator: id $id" ; return false ; } return true ; }
4187	public function publish ( $ provider ) { $ class = last ( explode ( '\\' , $ provider ) ) ; $ this -> console -> info ( "Searching {$provider} to publish vendor file." ) ; if ( ! $ this -> finder -> contains ( $ class ) -> contains ( '/\$this->publishes/i' ) -> count ( ) ) { $ this -> console -> warn ( 'Nothing to publish.' ) ; return true ; } $ tag = $ this -> console -> ask ( "If the \"{$this->console->tokenizePackageInfo()['name']}\" has specify vendor publish tag in installation guide then please add it here or press enter to skip adding tag." , false ) ; $ this -> console -> call ( 'vendor:publish' , [ '--provider' => $ provider , '--tag' => $ tag , ] ) ; return $ this -> registered = true ; }
7207	public function finalize ( ) : void { $ this -> round ( ) ; $ old = $ this -> taxes ; usort ( $ old , function ( Adjustment $ a , Adjustment $ b ) : int { if ( $ a -> getAmount ( ) == $ b -> getAmount ( ) ) { return 0 ; } return $ a -> getAmount ( ) > $ b -> getAmount ( ) ? 1 : - 1 ; } ) ; $ new = [ ] ; $ total = 0 ; foreach ( $ old as $ tax ) { $ amount = Money :: round ( $ tax -> getAmount ( ) , $ this -> currency ) ; if ( $ total + $ amount > $ this -> tax ) { $ amount = $ this -> tax - $ total ; } $ total += $ amount ; $ new [ ] = new Adjustment ( $ tax -> getName ( ) , $ amount , $ tax -> getRate ( ) ) ; } usort ( $ new , function ( Adjustment $ a , Adjustment $ b ) : int { return $ a -> getRate ( ) > $ b -> getRate ( ) ? 1 : - 1 ; } ) ; $ this -> taxes = $ new ; }
7010	private function formatN ( & $ str ) { if ( strstr ( $ str , '%N' ) ) { $ wdn = $ this -> weekDayNum ( ) ; $ str = str_replace ( '%N' , $ wdn == 0 ? 7 : $ wdn , $ str ) ; } }
10080	public static function getCurrencyCode ( ) { if ( ! empty ( self :: $ currencyCode ) ) { return self :: $ currencyCode ; } self :: $ currencyCode = '$' ; $ localeconv = localeconv ( ) ; if ( ! empty ( $ localeconv [ 'currency_symbol' ] ) ) { self :: $ currencyCode = $ localeconv [ 'currency_symbol' ] ; return self :: $ currencyCode ; } if ( ! empty ( $ localeconv [ 'int_curr_symbol' ] ) ) { self :: $ currencyCode = $ localeconv [ 'int_curr_symbol' ] ; return self :: $ currencyCode ; } return self :: $ currencyCode ; }
9835	public static function imagecreatefrombmp ( $ p_sFile ) { $ file = fopen ( $ p_sFile , 'rb' ) ; $ read = fread ( $ file , 10 ) ; while ( ! feof ( $ file ) && ( $ read != '' ) ) { $ read .= fread ( $ file , 1024 ) ; } $ temp = unpack ( 'H*' , $ read ) ; $ hex = $ temp [ 1 ] ; $ header = substr ( $ hex , 0 , 108 ) ; if ( substr ( $ header , 0 , 4 ) == '424d' ) { $ header_parts = str_split ( $ header , 2 ) ; $ width = hexdec ( $ header_parts [ 19 ] . $ header_parts [ 18 ] ) ; $ height = hexdec ( $ header_parts [ 23 ] . $ header_parts [ 22 ] ) ; unset ( $ header_parts ) ; } $ x = 0 ; $ y = 1 ; $ image = imagecreatetruecolor ( $ width , $ height ) ; $ body = substr ( $ hex , 108 ) ; $ body_size = ( strlen ( $ body ) / 2 ) ; $ header_size = ( $ width * $ height ) ; $ usePadding = ( $ body_size > ( $ header_size * 3 ) + 4 ) ; for ( $ i = 0 ; $ i < $ body_size ; $ i += 3 ) { if ( $ x >= $ width ) { if ( $ usePadding ) { $ i += $ width % 4 ; } $ x = 0 ; ++ $ y ; if ( $ y > $ height ) { break ; } } $ i_pos = $ i * 2 ; $ r = hexdec ( $ body [ $ i_pos + 4 ] . $ body [ $ i_pos + 5 ] ) ; $ g = hexdec ( $ body [ $ i_pos + 2 ] . $ body [ $ i_pos + 3 ] ) ; $ b = hexdec ( $ body [ $ i_pos ] . $ body [ $ i_pos + 1 ] ) ; $ color = imagecolorallocate ( $ image , $ r , $ g , $ b ) ; imagesetpixel ( $ image , $ x , $ height - $ y , $ color ) ; ++ $ x ; } unset ( $ body ) ; return $ image ; }
11733	public function publish ( $ pageName , $ languageName ) { $ this -> contributorDefined ( ) ; $ baseDir = $ this -> pagesDir . '/' . $ pageName ; $ pageCollectionSourceFile = $ baseDir . '/' . $ this -> username . '.json' ; $ pageCollectionTargetFile = $ baseDir . '/page.json' ; $ pageDir = $ baseDir . '/' . $ languageName ; $ pageSourceFile = $ pageDir . '/' . $ this -> username . '.json' ; $ pageTargetFile = $ pageDir . '/seo.json' ; Dispatcher :: dispatch ( PageEvents :: PAGE_PUBLISHING , new PagePublishingEvent ( ) ) ; copy ( $ pageCollectionSourceFile , $ pageCollectionTargetFile ) ; copy ( $ pageSourceFile , $ pageTargetFile ) ; Dispatcher :: dispatch ( PageEvents :: PAGE_PUBLISHED , new PagePublishedEvent ( ) ) ; DataLogger :: log ( sprintf ( 'Page "%s" for language "%s" was published in production' , $ pageName , $ languageName ) ) ; }
10017	public function addNamedRange ( NamedRange $ namedRange ) { if ( $ namedRange -> getScope ( ) == null ) { $ this -> namedRanges [ $ namedRange -> getName ( ) ] = $ namedRange ; } else { $ this -> namedRanges [ $ namedRange -> getScope ( ) -> getTitle ( ) . '!' . $ namedRange -> getName ( ) ] = $ namedRange ; } return true ; }
1289	public function setType ( string $ type = null ) { $ validTypes = [ 'all' , 'Asset' , 'Entry' , 'Deletion' , 'DeletedAsset' , 'DeletedEntry' ] ; if ( ! \ in_array ( $ type , $ validTypes , true ) ) { throw new \ InvalidArgumentException ( \ sprintf ( 'Unexpected type "%s".' , $ type ) ) ; } $ this -> type = $ type ; return $ this ; }
9678	public function allNumberFormats ( Spreadsheet $ spreadsheet ) { $ aNumFmts = [ ] ; $ aStyles = $ this -> allStyles ( $ spreadsheet ) ; foreach ( $ aStyles as $ style ) { if ( $ style -> getNumberFormat ( ) -> getBuiltInFormatCode ( ) === false && ! isset ( $ aNumFmts [ $ style -> getNumberFormat ( ) -> getHashCode ( ) ] ) ) { $ aNumFmts [ $ style -> getNumberFormat ( ) -> getHashCode ( ) ] = $ style -> getNumberFormat ( ) ; } } return $ aNumFmts ; }
43	private function parsePackage ( $ packageInfo ) { $ packageInfo -> registerXPathNamespace ( 'ns' , self :: CATEGORY_PACKAGES_INFO_NS ) ; $ channelName = ( string ) $ packageInfo -> p -> c ; $ packageName = ( string ) $ packageInfo -> p -> n ; $ license = ( string ) $ packageInfo -> p -> l ; $ shortDescription = ( string ) $ packageInfo -> p -> s ; $ description = ( string ) $ packageInfo -> p -> d ; $ dependencies = array ( ) ; foreach ( $ packageInfo -> xpath ( 'ns:deps' ) as $ node ) { $ dependencyVersion = ( string ) $ node -> v ; $ dependencyArray = unserialize ( ( string ) $ node -> d ) ; $ dependencyInfo = $ this -> dependencyReader -> buildDependencyInfo ( $ dependencyArray ) ; $ dependencies [ $ dependencyVersion ] = $ dependencyInfo ; } $ releases = array ( ) ; $ releasesInfo = $ packageInfo -> xpath ( 'ns:a/ns:r' ) ; if ( $ releasesInfo ) { foreach ( $ releasesInfo as $ node ) { $ releaseVersion = ( string ) $ node -> v ; $ releaseStability = ( string ) $ node -> s ; $ releases [ $ releaseVersion ] = new ReleaseInfo ( $ releaseStability , isset ( $ dependencies [ $ releaseVersion ] ) ? $ dependencies [ $ releaseVersion ] : new DependencyInfo ( array ( ) , array ( ) ) ) ; } } return new PackageInfo ( $ channelName , $ packageName , $ license , $ shortDescription , $ description , $ releases ) ; }
9658	public static function createWriter ( Spreadsheet $ spreadsheet , $ writerType ) { if ( ! isset ( self :: $ writers [ $ writerType ] ) ) { throw new Writer \ Exception ( "No writer found for type $writerType" ) ; } $ className = self :: $ writers [ $ writerType ] ; $ writer = new $ className ( $ spreadsheet ) ; return $ writer ; }
3309	protected function buildSignatureKey ( ) { $ signatures = [ 'a' => $ this -> appId , 'b' => $ this -> bucket , 'k' => $ this -> secretId , 'e' => time ( ) + 2592000 , 't' => time ( ) , 'r' => rand ( ) , 'u' => '0' , 'f' => '' ] ; return http_build_query ( $ signatures ) ; }
6261	public function getActionMap ( ) { $ actionMap = ( array ) Configure :: read ( 'SimpleRbac.actionMap' ) ; if ( empty ( $ actionMap ) && $ this -> _config [ 'allowEmptyActionMap' ] === false ) { throw new \ RuntimeException ( 'SimpleRbac.actionMap configuration is empty!' ) ; } return $ actionMap ; }
2258	protected function prepareForWidget ( $ arrData , $ strName , $ varValue = null , $ strField = '' , $ strTable = '' ) { @ trigger_error ( 'Using Controller::prepareForWidget() has been deprecated and will no longer work in Contao 5.0. Use Widget::getAttributesFromDca() instead.' , E_USER_DEPRECATED ) ; return Widget :: getAttributesFromDca ( $ arrData , $ strName , $ varValue , $ strField , $ strTable ) ; }
11333	public function setFormat ( $ value ) { if ( is_array ( $ value ) ) { if ( ! isset ( $ value [ 'class' ] ) ) { $ value [ 'class' ] = $ this -> determineFormatClass ( ) ; } $ value [ 'field' ] = $ this ; $ value = Yii :: createObject ( $ value ) ; } $ this -> _format = $ value ; }
8076	public function post ( $ endpoint , $ data , $ query = [ ] ) { $ endpoint = $ this -> buildUri ( $ endpoint , $ query ) ; $ headers = $ this -> buildHeaders ( ) ; $ data = $ this -> prepareData ( $ data ) ; $ this -> response = $ this -> client -> post ( $ endpoint , $ data , $ headers ) ; return $ this -> response ; }
11339	public function getModuleSetModules ( ) { if ( empty ( $ this -> moduleSet ) || ! isset ( Yii :: $ app -> extensions [ $ this -> moduleSet ] ) ) { return '' ; } $ bsClass = Yii :: $ app -> extensions [ $ this -> moduleSet ] [ 'bootstrap' ] ; $ p = [ ] ; $ bs = new $ bsClass ( ) ; $ modules = $ bs -> getModules ( ) ; $ modules [ $ this -> moduleID ] = [ 'class' => $ this -> moduleClass ] ; foreach ( $ modules as $ id => $ module ) { $ e = '$m[\'' . $ id . '\'] = [' ; if ( ! is_array ( $ module ) ) { $ module = [ 'class' => $ module ] ; } $ n = 0 ; foreach ( $ module as $ k => $ v ) { $ e .= "\n\t\t\t'{$k}' => " ; if ( is_string ( $ v ) ) { $ e .= "'" . addslashes ( $ v ) . "'" ; } elseif ( is_numeric ( $ v ) ) { $ e .= $ v ; } $ n ++ ; if ( $ n !== count ( $ module ) ) { $ e .= ',' ; } } $ e .= "\n\t\t];" ; $ p [ ] = $ e ; } return implode ( "\n\t\t" , $ p ) ; }
2363	public static function decodeEntities ( $ strString , $ strQuoteStyle = ENT_COMPAT , $ strCharset = null ) { if ( $ strString == '' ) { return '' ; } if ( $ strCharset === null ) { $ strCharset = Config :: get ( 'characterSet' ) ; } $ strString = preg_replace ( '/(&#*\w+)[\x00-\x20]+;/i' , '$1;' , $ strString ) ; $ strString = preg_replace ( '/(&#x*)([0-9a-f]+);/i' , '$1$2;' , $ strString ) ; return html_entity_decode ( $ strString , $ strQuoteStyle , $ strCharset ) ; }
10962	private function isInvalidLogDate ( $ file ) { $ pattern = '/laravel-(\d){4}-(\d){2}-(\d){2}.log/' ; if ( ( bool ) preg_match ( $ pattern , $ file , $ matches ) === false ) { return true ; } return false ; }
3283	public function setCache ( $ cache ) { if ( ! is_bool ( $ cache ) && ! $ cache instanceof CacheInterface ) { throw new Exception ( 'Cache must be a boolean or an instance of Flintstone\Cache\CacheInterface' ) ; } if ( $ cache === true ) { $ cache = new ArrayCache ( ) ; } $ this -> config [ 'cache' ] = $ cache ; }
3984	private function addMenu ( & $ modules , $ section , $ name , $ module , Request $ request ) { if ( ! isset ( $ modules [ $ section ] ) ) { $ modules [ $ section ] = $ this -> buildBackendMenuSection ( $ section , $ request ) ; } $ active = $ this -> isActive ( $ module [ 'route' ] , $ module [ 'param' ] , $ request ) ; $ class = 'navigation ' . $ name ; if ( isset ( $ module [ 'class' ] ) ) { $ class .= ' ' . $ module [ 'class' ] ; } if ( $ active ) { $ class .= ' active' ; } if ( $ request -> query -> has ( 'ref' ) ) { $ module [ 'param' ] [ 'ref' ] = $ request -> query -> get ( 'ref' ) ; } $ modules [ $ section ] [ 'modules' ] [ $ name ] = [ 'label' => $ module [ 'label' ] , 'title' => $ module [ 'title' ] , 'class' => $ class , 'isActive' => $ active , 'href' => $ this -> urlGenerator -> generate ( $ module [ 'route' ] , $ module [ 'param' ] ) , ] ; }
1752	public static function isInstalledLanguage ( $ strLanguage ) { if ( ! isset ( static :: $ arrLanguages [ $ strLanguage ] ) ) { $ rootDir = self :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( is_dir ( $ rootDir . '/vendor/contao/core-bundle/src/Resources/contao/languages/' . $ strLanguage ) ) { static :: $ arrLanguages [ $ strLanguage ] = true ; } elseif ( is_dir ( static :: getContainer ( ) -> getParameter ( 'kernel.cache_dir' ) . '/contao/languages/' . $ strLanguage ) ) { static :: $ arrLanguages [ $ strLanguage ] = true ; } else { $ files = static :: getContainer ( ) -> get ( 'contao.resource_finder' ) -> findIn ( 'languages' ) -> depth ( 0 ) -> directories ( ) -> name ( $ strLanguage ) ; static :: $ arrLanguages [ $ strLanguage ] = \ count ( $ files ) > 0 ; } } return static :: $ arrLanguages [ $ strLanguage ] ; }
9922	private function defineManyToManyRelation ( Model $ model1 , Model $ model2 ) { $ this -> relations [ $ model1 -> getName ( ) ] [ ] = new Relation ( $ model1 , $ model2 , Relation :: HAS_AND_BELONGS_TO ) ; $ this -> relations [ $ model2 -> getName ( ) ] [ ] = new Relation ( $ model2 , $ model1 , Relation :: HAS_AND_BELONGS_TO ) ; }
12416	static function run_coding_style_report ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { $ opts = self :: getOpts ( @ $ args [ 0 ] , @ $ args [ 1 ] , $ cliopts ) ; if ( ! SharedLock :: acquire ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ) throw new PakeException ( "Source code locked by another process" ) ; $ destdir = self :: getReportDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ; $ phpcs = self :: getTool ( 'phpcs' , $ opts , true ) ; $ rulesDir = self :: getVendorDir ( ) . '/squizlabs/php_codesniffer/Codesniffer/Standards/' . $ opts [ 'tools' ] [ 'phpcs' ] [ 'rules' ] ; if ( ! is_dir ( $ rulesDir ) ) { if ( $ opts [ 'tools' ] [ 'phpcs' ] [ 'rules' ] == 'ezcs' ) { $ sourceDir = self :: getVendorDir ( ) . '/ezsystems/ezcs/php/ezcs' ; if ( is_dir ( $ sourceDir ) ) { pake_symlink ( $ sourceDir , $ rulesDir ) ; } } } try { $ out = pake_sh ( "$phpcs --standard=" . escapeshellarg ( $ opts [ 'tools' ] [ 'phpcs' ] [ 'rules' ] ) . " " . "--report=" . escapeshellarg ( $ opts [ 'tools' ] [ 'phpcs' ] [ 'format' ] ) . " " . "--extensions=php " . escapeshellarg ( self :: getBuildDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ) ) ; } catch ( pakeException $ e ) { $ out = preg_replace ( '/^Problem executing command/' , '' , $ e -> getMessage ( ) ) ; } pake_mkdirs ( $ destdir ) ; pake_write_file ( $ destdir . '/phpcs.txt' , $ out , true ) ; SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; }
1708	public static function removeEntry ( $ strUrl ) { $ objDatabase = Database :: getInstance ( ) ; $ objResult = $ objDatabase -> prepare ( "SELECT id FROM tl_search WHERE url=?" ) -> execute ( $ strUrl ) ; while ( $ objResult -> next ( ) ) { $ objDatabase -> prepare ( "DELETE FROM tl_search WHERE id=?" ) -> execute ( $ objResult -> id ) ; $ objDatabase -> prepare ( "DELETE FROM tl_search_index WHERE pid=?" ) -> execute ( $ objResult -> id ) ; } }
10014	public function getIndex ( Worksheet $ pSheet ) { foreach ( $ this -> workSheetCollection as $ key => $ value ) { if ( $ value -> getHashCode ( ) == $ pSheet -> getHashCode ( ) ) { return $ key ; } } throw new Exception ( 'Sheet does not exist.' ) ; }
8423	public function mappings ( Request $ request ) { $ table = new \ cli \ Table ( ) ; $ table -> setHeaders ( [ 'Mapping' , 'Database' , 'Models path' ] ) ; $ rows = [ ] ; $ mappings = Mapping :: getMappings ( ) ; usort ( $ mappings , function ( array $ a , array $ b ) { return strcmp ( $ a [ 'config' ] [ 'name' ] , $ b [ 'config' ] [ 'name' ] ) ; } ) ; foreach ( $ mappings as $ mapping ) { $ rows [ ] = [ $ mapping [ 'config' ] [ 'name' ] , $ mapping [ 'config' ] [ 'database' ] , $ mapping [ 'config' ] [ 'models' ] [ 'path' ] , ] ; } $ table -> setRows ( $ rows ) ; $ table -> display ( ) ; }
12080	public function updateChild ( $ idParent , FilterRequest $ filters , $ idChild , $ relation ) { $ idParent = $ this -> getRealId ( $ idParent ) ; $ idChild = $ this -> getRealId ( $ idChild ) ; $ resource = $ this -> repository -> updateChild ( $ idParent , $ relation , $ idChild , $ filters -> all ( ) ) ; if ( ! $ resource ) { } return $ this -> success ( $ resource ) ; }
8444	public function matchesRequest ( ) { if ( isset ( $ this -> headers [ 'x-twitter-webhooks-signature' ] ) ) { $ signature = $ this -> headers [ 'x-twitter-webhooks-signature' ] [ 0 ] ; $ hash = hash_hmac ( 'sha256' , json_encode ( $ this -> payload -> all ( ) ) , $ this -> config -> get ( 'consumer_secret' ) , true ) ; return $ signature === 'sha256=' . base64_encode ( $ hash ) ; } return false ; }
2861	public function getRange ( $ logFile ) { if ( ! array_key_exists ( $ logFile , $ this -> ranges ) ) { throw new Exception ( 'Invalid log file' ) ; } return $ this -> ranges [ $ logFile ] ; }
7775	protected function handleError ( $ field , $ value , $ rule , array $ args ) { $ this -> errors [ $ rule ] [ ] = [ 'field' => $ field , 'value' => $ value , 'args' => $ args , ] ; }
5125	public function serve ( ) { foreach ( $ this -> dispatchers as $ dispatcher ) { if ( $ dispatcher -> canServe ( ) ) { ContainerScope :: runScope ( $ this -> container , [ $ dispatcher , 'serve' ] ) ; return ; } } throw new BootException ( "Unable to locate active dispatcher." ) ; }
149	public function isActive ( $ scenario ) { return ! in_array ( $ scenario , $ this -> except , true ) && ( empty ( $ this -> on ) || in_array ( $ scenario , $ this -> on , true ) ) ; }
5477	public function addWidget ( $ tag ) { if ( strtolower ( $ tag -> getAttribute ( 'type' ) ) === 'submit' ) { $ this -> buttons [ ] = $ tag ; } elseif ( strtolower ( $ tag -> getAttribute ( 'type' ) ) === 'image' ) { $ this -> images [ ] = $ tag ; } elseif ( $ tag -> getName ( ) ) { $ this -> setWidget ( $ tag ) ; } }
2288	public static function findUnactivatedByEmail ( $ strEmail , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ objDatabase = Database :: getInstance ( ) ; $ objResult = $ objDatabase -> prepare ( "SELECT * FROM $t WHERE email=? AND disable='1' AND EXISTS (SELECT * FROM tl_opt_in_related r LEFT JOIN tl_opt_in o ON r.pid=o.id WHERE r.relTable='$t' AND r.relId=$t.id AND o.createdOn>? AND o.confirmedOn=0)" ) -> limit ( 1 ) -> execute ( $ strEmail , strtotime ( '-24 hours' ) ) ; if ( $ objResult -> numRows < 1 ) { return null ; } $ objRegistry = Registry :: getInstance ( ) ; if ( $ objMember = $ objRegistry -> fetch ( $ t , $ objResult -> id ) ) { return $ objMember ; } return new static ( $ objResult ) ; }
6982	public function validate ( $ dataOrRequest , array $ rules , array $ messages = [ ] , array $ customAttributes = [ ] ) { $ errors = $ this -> validateAndReturnErrors ( $ dataOrRequest , $ rules , $ messages , $ customAttributes ) ; if ( ! empty ( $ errors ) ) { $ this -> throwValidationErrorsResponse ( $ errors ) ; } return $ this -> extractInputFromRules ( $ dataOrRequest , $ rules ) ; }
6171	protected function onAddFailure ( $ e ) { $ this -> writeProgressWithColor ( 'fg-red,bold' , 'F' ) ; $ this -> failure = $ e ; $ this -> lastTestFailed = true ; $ this -> flawless = false ; }
5079	public function postRemap ( ) { $ oUri = Factory :: service ( 'Uri' ) ; $ sMethod = 'post' . ucfirst ( $ oUri -> segment ( 4 ) ) ; if ( method_exists ( $ this , $ sMethod ) ) { return $ this -> $ sMethod ( ) ; } $ oInput = Factory :: service ( 'Input' ) ; $ oHttpCodes = Factory :: service ( 'HttpCodes' ) ; $ oItemModel = Factory :: model ( static :: CONFIG_MODEL_NAME , static :: CONFIG_MODEL_PROVIDER ) ; $ aFields = $ oItemModel -> describeFields ( ) ; $ aValid = [ ] ; $ aInvalid = [ ] ; foreach ( $ aFields as $ oField ) { if ( in_array ( $ oField -> key , static :: CONFIG_POST_IGNORE_FIELDS ) ) { continue ; } $ aValid [ ] = $ oField -> key ; } $ aPost = $ oInput -> post ( ) ; foreach ( $ aPost as $ sKey => $ sValue ) { if ( ! in_array ( $ sKey , $ aValid ) ) { $ aInvalid [ ] = $ sKey ; } } if ( ! empty ( $ aInvalid ) ) { throw new ApiException ( 'The following arguments are invalid: ' . implode ( ', ' , $ aInvalid ) , $ oHttpCodes :: STATUS_BAD_REQUEST ) ; } $ iItemId = ( int ) $ oUri -> segment ( 4 ) ; if ( $ iItemId ) { $ oItem = $ oItemModel -> getById ( $ iItemId ) ; if ( empty ( $ oItem ) ) { throw new ApiException ( 'Item does not exist' , $ oHttpCodes :: STATUS_NOT_FOUND ) ; } elseif ( ! $ oItemModel -> update ( $ iItemId , $ aPost ) ) { throw new ApiException ( 'Failed to update item. ' . $ oItemModel -> lastError ( ) , $ oHttpCodes :: STATUS_INTERNAL_SERVER_ERROR ) ; } elseif ( classUses ( $ oItemModel , 'Nails\Common\Traits\Caching' ) ) { $ oItemModel -> disableCache ( ) ; } $ oItem = $ oItemModel -> getById ( $ iItemId ) ; if ( classUses ( $ oItemModel , 'Nails\Common\Traits\Caching' ) ) { $ oItemModel -> enableCache ( ) ; } } else { $ oItem = $ oItemModel -> create ( $ aPost , true ) ; } $ oResponse = Factory :: factory ( 'ApiResponse' , 'nails/module-api' ) ; $ oResponse -> setData ( $ this -> formatObject ( $ oItem ) ) ; return $ oResponse ; }
3924	public function getValueOptions ( GetPropertyOptionsEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ model = $ event -> getModel ( ) ; $ metaModel = $ this -> getMetaModel ( $ event -> getEnvironment ( ) ) ; $ attribute = $ metaModel -> getAttributeById ( $ model -> getProperty ( 'attr_id' ) ) ; if ( $ attribute ) { $ options = $ this -> getOptionsViaDcGeneral ( $ metaModel , $ event -> getEnvironment ( ) , $ attribute ) ; $ mangled = [ ] ; foreach ( ( array ) $ options as $ key => $ option ) { $ mangled [ 'value_' . $ key ] = $ option ; } $ event -> setOptions ( $ mangled ) ; } }
5802	public function indexViewObjects ( Response $ response , bool $ resetFilter = false ) { if ( $ resetFilter ) { return $ this -> resetFilter ( $ response , $ this -> indexRoute ) ; } try { $ permissions = $ this -> permissionsEntityMapper -> getObjects ( $ this -> getFilterColumnsInfo ( ) ) ; } catch ( QueryFailureException $ e ) { $ permissions = [ ] ; SlimPostgres :: setAdminNotice ( 'Query Failed' , 'failure' ) ; } return $ this -> indexView ( $ response , $ permissions ) ; }
11356	public function getInputFilter ( ) { if ( $ this -> filter ) { return $ this -> filter ; } $ specifications = [ ] ; if ( $ this -> object && $ this -> object instanceof InputFilterProviderInterface ) { $ specifications = $ this -> object -> getInputFilterSpecification ( ) ; } if ( $ this instanceof InputFilterProviderInterface ) { $ specifications = ArrayUtils :: merge ( $ specifications , $ this -> getInputFilterSpecification ( ) ) ; } $ this -> addRequiredAttributeToFields ( $ specifications ) ; if ( ! empty ( $ specifications ) && null === $ this -> baseFieldset ) { $ formFactory = $ this -> getFormFactory ( ) ; $ inputFactory = $ formFactory -> getInputFilterFactory ( ) ; if ( ! ( $ this -> filter instanceof InputFilterInterface ) ) { $ this -> filter = new InputFilter ( ) ; $ this -> filter -> setFactory ( $ inputFactory ) ; } foreach ( $ specifications as $ name => $ specification ) { $ input = $ inputFactory -> createInput ( $ specification ) ; $ this -> filter -> add ( $ input , $ name ) ; } } return parent :: getInputFilter ( ) ; }
8745	protected function resetListener ( ) { $ this -> currentKey = null ; $ this -> escapePressedAt = null ; $ this -> charSequenceEnabled = false ; $ this -> isListening = true ; return $ this ; }
644	public function addDefaultValue ( $ name , $ table , $ column , $ value ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> addDefaultValue ( $ name , $ table , $ column , $ value ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; }
5322	public function lockExecute ( callable $ callable ) { $ this -> isAcquired = $ this -> acquire ( ) ; $ result = $ callable ( ) ; $ this -> isAcquired = $ this -> release ( ) ; return $ result ; }
11055	public function getBundle ( $ name , $ publish = true ) { if ( $ this -> bundles === false ) { return $ this -> loadDummyBundle ( $ name ) ; } elseif ( ! isset ( $ this -> bundles [ $ name ] ) ) { return $ this -> bundles [ $ name ] = $ this -> loadBundle ( $ name , [ ] , $ publish ) ; } elseif ( $ this -> bundles [ $ name ] instanceof AssetBundle ) { return $ this -> bundles [ $ name ] ; } elseif ( is_array ( $ this -> bundles [ $ name ] ) ) { return $ this -> bundles [ $ name ] = $ this -> loadBundle ( $ name , $ this -> bundles [ $ name ] , $ publish ) ; } elseif ( $ this -> bundles [ $ name ] === false ) { return $ this -> loadDummyBundle ( $ name ) ; } else { throw new InvalidConfigException ( "Invalid asset bundle configuration: $name" ) ; } }
12835	private function generateFactoryCreatorMethod ( FactoredService $ service ) : string { $ factoryMethod = $ service -> getFactoryMethod ( ) ; $ taggedAs = implode ( ', ' , $ service -> getTags ( ) ) ; $ classNormalized = $ this -> normalizeFqcn ( $ service -> getClass ( ) ) ; $ optional = $ service -> getFactoryMethod ( ) -> isOptional ( ) ? '?' : '' ; if ( $ service -> isSingleton ( ) ) { return <<<PHP /** * Get the factored service "{$service->getId()}" (Singleton) * * It is tagged as: {$taggedAs} * * @return {$this->normalizeFqcn($service->getClass())} */ public function {$this->mapIdToServiceGetter($service->getId())} () : {$optional}{$classNormalized} { if (isset(\$this->singletons['{$service->getId()}'])) { return \$this->singletons['{$service->getId()}']; } /** @noinspection OneTimeUseVariablesInspection */ \$service = \$this->singletons['{$service->getId()}'] = {$this->generateCreatorByServiceId($factoryMethod->getFactoryId())}->{$factoryMethod->getMethodName()}({$this->buildInjectionParameters($this->container, $factoryMethod->getInjection())} );{$this->generateSetterInjectionsCode($service)} return \$service; }PHP ; } return <<<PHP /** * Get a fresh instance of service "{$service->getId()}" (Prototype) * * It is tagged as: {$taggedAs} * * @return {$this->normalizeFqcn($service->getClass())} */ public function {$this->mapIdToServiceGetter($service->getId())} () : $classNormalized { \$this->prototypes['{$service->getId()}'] = (\$this->prototypes['{$service->getId()}'] ?? 0) + 1; /** @noinspection OneTimeUseVariablesInspection */ \$service = {$this->generateCreatorByServiceId($factoryMethod->getFactoryId())}->{$factoryMethod->getMethodName()}({$this->buildInjectionParameters($this->container, $factoryMethod->getInjection())} );{$this->generateSetterInjectionsCode($service)} return \$service; }PHP ; }
350	public static function getAttributeValue ( $ model , $ attribute ) { if ( ! preg_match ( static :: $ attributeRegex , $ attribute , $ matches ) ) { throw new InvalidArgumentException ( 'Attribute name must contain word characters only.' ) ; } $ attribute = $ matches [ 2 ] ; $ value = $ model -> $ attribute ; if ( $ matches [ 3 ] !== '' ) { foreach ( explode ( '][' , trim ( $ matches [ 3 ] , '[]' ) ) as $ id ) { if ( ( is_array ( $ value ) || $ value instanceof \ ArrayAccess ) && isset ( $ value [ $ id ] ) ) { $ value = $ value [ $ id ] ; } else { return null ; } } } if ( is_array ( $ value ) ) { foreach ( $ value as $ i => $ v ) { if ( $ v instanceof ActiveRecordInterface ) { $ v = $ v -> getPrimaryKey ( false ) ; $ value [ $ i ] = is_array ( $ v ) ? json_encode ( $ v ) : $ v ; } } } elseif ( $ value instanceof ActiveRecordInterface ) { $ value = $ value -> getPrimaryKey ( false ) ; return is_array ( $ value ) ? json_encode ( $ value ) : $ value ; } return $ value ; }
12535	public function fetchByApplyId ( $ applyId , $ lastSeen , $ count ) { $ params = [ 'type' => 3 , 'apply_id' => intval ( $ applyId ) , 'last_seen' => intval ( $ lastSeen ) , 'count' => intval ( $ count ) , ] ; return $ this -> fetch ( $ params ) ; }
1090	public function reOrderBy ( $ column , $ direction = 'asc' ) { $ this -> orders = null ; if ( ! is_null ( $ column ) ) return $ this -> orderBy ( $ column , $ direction ) ; return $ this ; }
4926	public function getRegions ( $ type = null ) { if ( null === $ type ) { return array_keys ( $ this -> matrix ) ; } $ regions = [ ] ; foreach ( $ this -> matrix as $ region => $ types ) { if ( in_array ( $ type , $ types ) ) { $ regions [ ] = $ region ; } } return $ regions ; }
8715	public function getAccessToken ( ) : ApiAccessToken { try { $ accessToken = $ this -> tokenStorage -> getAccessToken ( ) ; } catch ( UnableToAcquireAccessToken $ e ) { $ accessToken = null ; } if ( $ accessToken && $ accessToken -> isExpired ( ) ) { $ this -> tokenStorage -> unsetAccessToken ( ) ; $ accessToken = null ; } return $ accessToken ? : $ this -> refreshToken ( ) ; }
10346	protected function getNextFutureTimestamp ( ) { if ( $ this -> yearOffset === 0 ) { $ currentHour = ( int ) date ( 'H' , $ this -> getCurrentTime ( ) ) ; $ currentMinute = ( int ) date ( 'i' , $ this -> getCurrentTime ( ) ) ; $ currentDay = ( int ) date ( 'd' , $ this -> getCurrentTime ( ) ) ; $ currentMonth = ( int ) date ( 'm' , $ this -> getCurrentTime ( ) ) ; } do { $ minute = current ( $ this -> minutes ) ; $ hour = current ( $ this -> hours ) ; $ monthAndDay = current ( $ this -> monthAndDays ) ; $ minute = next ( $ this -> minutes ) ; if ( $ minute === false ) { $ minute = reset ( $ this -> minutes ) ; $ hour = next ( $ this -> hours ) ; if ( $ hour === false ) { $ hour = reset ( $ this -> hours ) ; $ monthAndDay = next ( $ this -> monthAndDays ) ; if ( $ monthAndDay === false ) { $ this -> generateTimetable ( $ this -> yearOffset + 1 ) ; $ minute = reset ( $ this -> minutes ) ; $ hour = reset ( $ this -> hours ) ; $ monthAndDay = reset ( $ this -> monthAndDays ) ; } } } if ( $ this -> yearOffset === 0 ) { if ( ( $ month = ( int ) substr ( $ monthAndDay , 0 , 2 ) ) === $ currentMonth ) { if ( ( $ day = ( int ) substr ( $ monthAndDay , 3 , 2 ) ) < $ currentDay ) { continue ; } if ( $ day === $ currentDay ) { if ( $ hour < $ currentHour ) { continue ; } if ( $ hour === $ currentHour ) { if ( $ minute < $ currentMinute ) { continue ; } } } } } $ nextElement = strtotime ( sprintf ( '%d-%s %02d:%02d:00' , $ this -> year + $ this -> yearOffset , $ monthAndDay , $ hour , $ minute ) ) ; break ; } while ( true ) ; return $ nextElement ; }
3198	protected function checkTimestampCoherence ( $ points , $ timestamp ) { foreach ( $ points as $ point ) { if ( $ point -> getTimestamp ( ) > $ timestamp ) { throw new InconsistentRangeException ( 'A new TimePoint cannot be set before an existing one!' ) ; } } }
5364	protected function fix ( $ directory ) { if ( ! class_exists ( 'PhpCsFixer\Config' ) ) { return ; } $ fixerConfig = $ this -> fixerConfig ; if ( null === $ fixerConfig ) { $ fixerConfig = Config :: create ( ) -> setRiskyAllowed ( true ) -> setRules ( array ( '@Symfony' => true , 'array_syntax' => array ( 'syntax' => 'short' ) , 'simplified_null_return' => false , 'ordered_imports' => true , 'phpdoc_order' => true , 'binary_operator_spaces' => array ( 'align_equals' => true ) , 'concat_space' => false , 'yoda_style' => false , 'header_comment' => [ 'header' => <<<EOHThis file has been auto generated by Jane,Do no edit it directly.EOH , ] ) ) ; } $ resolverOptions = array ( 'allow-risky' => true ) ; $ resolver = new ConfigurationResolver ( $ fixerConfig , $ resolverOptions , $ directory , new ToolInfo ( ) ) ; $ finder = new Finder ( ) ; $ finder -> in ( $ directory ) ; $ fixerConfig -> setFinder ( $ finder ) ; $ runner = new Runner ( $ resolver -> getConfig ( ) -> getFinder ( ) , $ resolver -> getFixers ( ) , new NullDiffer ( ) , null , new ErrorsManager ( ) , new Linter ( ) , false , new NullCacheManager ( ) ) ; return $ runner -> fix ( ) ; }
11058	protected function _getDataStore ( ) { return $ this -> dataStore === null ? $ this -> dataStore = $ this -> _createDataStore ( ) : $ this -> dataStore ; }
2331	public function fetchEach ( $ strKey ) { $ this -> reset ( ) ; $ return = array ( ) ; while ( $ this -> next ( ) ) { $ strPk = $ this -> current ( ) -> getPk ( ) ; if ( $ strKey != 'id' && isset ( $ this -> $ strPk ) ) { $ return [ $ this -> $ strPk ] = $ this -> $ strKey ; } else { $ return [ ] = $ this -> $ strKey ; } } return $ return ; }
6593	protected function parseTags ( array $ bustersOfThisType , $ type ) { $ busterStrings = array ( ) ; foreach ( $ bustersOfThisType as $ fileName => $ hash ) { $ template = $ this -> config [ $ type . 'Template' ] ; $ rootPath = $ this -> config [ 'rootPath' ] ; $ pathInfo = pathInfo ( $ fileName ) ; $ fileBasePath = $ pathInfo [ 'dirname' ] ; $ fileBaseName = $ pathInfo [ 'filename' ] ; $ template = str_replace ( '{{ROOT_PATH}}' , $ rootPath , $ template ) ; $ template = str_replace ( '{{HASH}}' , $ hash , $ template ) ; $ template = str_replace ( '{{FILE_PATH}}' , $ fileBasePath , $ template ) ; $ template = str_replace ( '{{FILE_NAME}}' , $ fileBaseName , $ template ) ; $ busterStrings [ ] = $ template ; } return $ busterStrings ; }
6111	public function fileDelete ( $ cpw = "" , $ name = "/" ) { return $ this -> getParent ( ) -> channelFileDelete ( $ this -> getId ( ) , $ cpw , $ name ) ; }
12661	public function createAuthorizerApplication ( $ appId , $ refreshToken ) { $ this -> fetch ( 'authorizer' , function ( $ authorizer ) use ( $ appId , $ refreshToken ) { $ authorizer -> setAppId ( $ appId ) ; $ authorizer -> setRefreshToken ( $ refreshToken ) ; } ) ; return $ this -> fetch ( 'app' , function ( $ app ) { $ app [ 'access_token' ] = $ this -> fetch ( 'authorizer_access_token' ) ; $ app [ 'oauth' ] = $ this -> fetch ( 'oauth' ) ; $ app [ 'server' ] = $ this -> fetch ( 'server' ) ; } ) ; }
11034	private function loadFromFile ( ) { if ( is_file ( $ this -> _file ) ) { $ this -> _params = require ( $ this -> _file ) ; } else { $ this -> _params = [ 'users' => [ ] ] ; } }
10233	public function edit ( $ id ) { $ user = User :: findOrFail ( $ id ) ; $ roles = Role :: lists ( 'name' , 'id' ) ; return view ( 'intothesource.usersmanager.users.edit' , compact ( 'user' , 'roles' ) ) ; }
2687	protected function execute ( InputInterface $ input , OutputInterface $ output ) { $ configPaths = [ 'geoip_country_mapping' => \ Fastly \ Cdn \ Model \ Config :: XML_FASTLY_GEOIP_COUNTRY_MAPPING ] ; foreach ( $ configPaths as $ path ) { $ magVer = $ this -> productMetadata -> getVersion ( ) ; if ( version_compare ( $ magVer , '2.2' , '<' ) ) { $ output -> writeln ( 'Warning : This function is used for converting serialized data to JSON' . ' (recommended for Magento versions above 2.2)' ) ; } $ oldData = $ this -> scopeConfig -> getValue ( $ path ) ; try { $ oldData = unserialize ( $ oldData ) ; } catch ( \ Exception $ e ) { $ oldData = false ; } if ( $ oldData === false ) { $ output -> writeln ( 'Invalid serialization format, unable to unserialize config data : ' . $ path ) ; return ; } $ oldData = ( is_array ( $ oldData ) ) ? $ oldData : [ ] ; $ newData = json_encode ( $ oldData ) ; if ( false === $ newData ) { throw new \ InvalidArgumentException ( 'Unable to encode data.' ) ; } $ this -> configWriter -> save ( $ path , $ newData ) ; $ this -> cacheManager -> clean ( [ \ Magento \ Framework \ App \ Cache \ Type \ Config :: TYPE_IDENTIFIER ] ) ; $ output -> writeln ( 'Config Cache Flushed' ) ; } }
7386	public static final function moveFile ( $ file ) { try { if ( $ file -> is_temp ) { rename ( $ file -> temp_destination . '/' . $ file -> temp_name , $ file -> original_destination . '/' . $ file -> temp_name ) ; if ( ! file_exists ( $ file -> original_destination . '/' . $ file -> temp_name ) ) { throw new CannotSaveFileInHardDriveException ( ) ; } $ file -> is_temp = false ; $ file -> expire = null ; $ file -> save ( ) ; } } catch ( \ Exception $ exception ) { throw new FileException ( $ exception -> getMessage ( ) ) ; } }
3101	private function getSubIdentifiersRecursively ( $ array , $ identifiers ) { $ identifier = array_shift ( $ identifiers ) ; if ( count ( $ identifiers ) > 0 ) { $ result = [ ] ; foreach ( $ array [ $ identifier ] as $ key => $ value ) { $ result [ ] = $ this -> getSubIdentifiersRecursively ( $ array [ $ identifier ] [ $ key ] , $ identifiers ) ; } return array_merge ( ... $ result ) ; } return array_keys ( $ array [ $ identifier ] ) ; }
5436	protected function getParameterSignatures ( $ method ) { $ signatures = [ ] ; $ parameters = $ method -> getParameters ( ) ; foreach ( $ parameters as $ parameter ) { $ signature = '' ; $ signature .= $ this -> getParameterTypeHint ( $ parameter ) ; if ( $ parameter -> isPassedByReference ( ) ) { $ signature .= '&' ; } $ isVariadic = ( PHP_VERSION_ID >= 50600 ) && $ parameter -> isVariadic ( ) ; if ( $ isVariadic ) { $ signature .= '...' ; } $ signature .= '$' . $ parameter -> getName ( ) ; if ( ! $ isVariadic ) { if ( $ parameter -> isDefaultValueAvailable ( ) ) { $ signature .= ' = ' . var_export ( $ parameter -> getDefaultValue ( ) , true ) ; } elseif ( $ parameter -> isOptional ( ) ) { $ signature .= ' = null' ; } } $ signatures [ ] = $ signature ; } return implode ( ', ' , $ signatures ) ; }
7345	public function modifySubmitedValueBeforeValidation ( $ value , array $ data ) { if ( $ this -> hasSubmittedValueModifier ( ) ) { return call_user_func ( $ this -> getSubmittedValueModifier ( ) , $ value , $ data ) ; } else { return $ value ; } }
12940	private function assertClient ( ClientInterface $ client ) { if ( $ client -> getConnection ( ) instanceof AggregateConnectionInterface ) { throw new NotSupportedException ( 'Cannot initialize a monitor consumer over aggregate connections.' ) ; } if ( $ client -> getCommandFactory ( ) -> supportsCommand ( 'MONITOR' ) === false ) { throw new NotSupportedException ( "'MONITOR' is not supported by the current command factory." ) ; } }
12474	public function getTheme ( $ identifier ) { $ themes = $ this -> getAvailableThemes ( ) ; if ( ! isset ( $ themes [ $ identifier ] ) ) { $ themeIds = array ( ) ; foreach ( $ themes as $ key => $ value ) { $ themeIds [ ] = $ key ; } throw new \ Exception ( sprintf ( 'Theme "%s" does not exist. Possible values are [%s]' , $ identifier , implode ( ', ' , $ themeIds ) ) , 1 ) ; } return $ themes [ $ identifier ] ; }
7311	public static function solsticeWinter ( $ year ) { $ jd = static :: solsticeDecember ( ( int ) $ year , false ) ; return AstroDate :: jd ( $ jd , TimeScale :: TT ( ) ) ; }
2755	public function onImport ( ImportEvent $ event ) { $ uuids = [ '0bd5c257-2231-450f-b4c2-ab156af7b78d' , '36b2e2b2-3df0-43eb-a282-d792b0999c07' , '94ad928b-3ec8-4bcb-b617-ab1607bf69cb' , 'bbb1ee17-15f8-46bd-9df5-21c58040d741' , ] ; foreach ( $ event -> getImportedEntities ( ) as $ entity ) { if ( in_array ( $ entity -> uuid ( ) , $ uuids ) ) { $ entity -> moderation_state -> value = 'published' ; $ entity -> save ( ) ; } } }
1176	public function sometimes ( $ attribute , $ rules = [ ] ) { $ callback = function ( ) { return true ; } ; $ this -> validator -> sometimes ( $ attribute , $ rules , $ callback ) ; $ this -> rules -> addConditionalRules ( $ attribute , ( array ) $ rules ) ; }
3017	public function editPost ( $ blogName , $ postId , $ data ) { $ data [ 'id' ] = $ postId ; $ path = $ this -> blogPath ( $ blogName , '/post/edit' ) ; return $ this -> postRequest ( $ path , $ data , false ) ; }
2995	protected function encodeHeader ( $ str ) { if ( extension_loaded ( 'iconv' ) ) { $ out = iconv_mime_encode ( 'Subject' , $ str , [ 'input-charset' => 'UTF-8' , 'output-charset' => $ this -> charset ] ) ; $ out = substr ( $ out , strlen ( 'Subject: ' ) ) ; } elseif ( extension_loaded ( 'mbstring' ) ) { mb_internal_encoding ( 'UTF-8' ) ; $ out = mb_encode_mimeheader ( $ str , $ this -> charset , 'B' , static :: $ EOL , strlen ( 'Subject: ' ) ) ; } else $ out = wordwrap ( $ str , 65 , static :: $ EOL ) ; return $ out ; }
9828	public function getCreateAssociationName ( $ modelName , $ otherModelName ) { return sprintf ( 'auja.%s.%s.create' , $ this -> toUrlName ( $ modelName ) , $ this -> toUrlName ( $ otherModelName ) ) ; }
4197	public function onStart ( Event $ event ) { $ obj = $ event -> getSubject ( ) ; if ( $ obj instanceof \ DateTime || $ obj instanceof \ DateTimeImmutable ) { $ event [ 'stringified' ] = $ obj -> format ( \ DateTime :: ISO8601 ) ; } elseif ( $ obj instanceof \ mysqli && ( $ obj -> connect_errno || ! $ obj -> stat ) ) { $ event [ 'collectPropertyValues' ] = false ; } }
9711	private function writeBoundSheet ( $ sheet , $ offset ) { $ sheetname = $ sheet -> getTitle ( ) ; $ record = 0x0085 ; switch ( $ sheet -> getSheetState ( ) ) { case \ PhpOffice \ PhpSpreadsheet \ Worksheet \ Worksheet :: SHEETSTATE_VISIBLE : $ ss = 0x00 ; break ; case \ PhpOffice \ PhpSpreadsheet \ Worksheet \ Worksheet :: SHEETSTATE_HIDDEN : $ ss = 0x01 ; break ; case \ PhpOffice \ PhpSpreadsheet \ Worksheet \ Worksheet :: SHEETSTATE_VERYHIDDEN : $ ss = 0x02 ; break ; default : $ ss = 0x00 ; break ; } $ st = 0x00 ; $ grbit = 0x0000 ; $ data = pack ( 'VCC' , $ offset , $ ss , $ st ) ; $ data .= StringHelper :: UTF8toBIFF8UnicodeShort ( $ sheetname ) ; $ length = strlen ( $ data ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ this -> append ( $ header . $ data ) ; }
1400	public function exception ( \ Exception $ ex ) { if ( $ this -> getCodec ( ) -> willNotEncode ( ) ) { $ this -> codec = $ this -> api -> getDefaultCodec ( ) ; } return $ this -> getErrorResponse ( $ this -> exceptions -> parse ( $ ex ) ) ; }
194	public function sendFile ( $ filePath , $ attachmentName = null , $ options = [ ] ) { if ( ! isset ( $ options [ 'mimeType' ] ) ) { $ options [ 'mimeType' ] = FileHelper :: getMimeTypeByExtension ( $ filePath ) ; } if ( $ attachmentName === null ) { $ attachmentName = basename ( $ filePath ) ; } $ handle = fopen ( $ filePath , 'rb' ) ; $ this -> sendStreamAsFile ( $ handle , $ attachmentName , $ options ) ; return $ this ; }
6424	protected function getClient ( $ redirecturl = '' ) { if ( is_object ( $ this -> google ) ) { return $ this -> google ; } if ( $ redirecturl == '' ) { $ redirecturl = $ this -> redirecturl ; } else { $ this -> redirecturl = $ redirecturl ; } $ client = new \ Google_Client ( ) ; $ client -> setApplicationName ( $ this -> options [ 'application_name' ] ) ; $ client -> setClientId ( $ this -> options [ 'client_id' ] ) ; $ client -> setClientSecret ( $ this -> options [ 'client_secret' ] ) ; $ client -> setRedirectUri ( $ redirecturl ) ; $ client -> setDeveloperKey ( $ this -> options [ 'api_key' ] ) ; $ client -> setScopes ( array ( 'https://www.googleapis.com/auth/userinfo.profile' , 'https://www.googleapis.com/auth/userinfo.email' ) ) ; $ this -> google = $ client ; return $ client ; }
937	public static function getKeywords ( ) { static $ keywords = null ; if ( null === $ keywords ) { $ keywords = self :: getTokenKindsForNames ( [ 'T_ABSTRACT' , 'T_ARRAY' , 'T_AS' , 'T_BREAK' , 'T_CALLABLE' , 'T_CASE' , 'T_CATCH' , 'T_CLASS' , 'T_CLONE' , 'T_CONST' , 'T_CONTINUE' , 'T_DECLARE' , 'T_DEFAULT' , 'T_DO' , 'T_ECHO' , 'T_ELSE' , 'T_ELSEIF' , 'T_EMPTY' , 'T_ENDDECLARE' , 'T_ENDFOR' , 'T_ENDFOREACH' , 'T_ENDIF' , 'T_ENDSWITCH' , 'T_ENDWHILE' , 'T_EVAL' , 'T_EXIT' , 'T_EXTENDS' , 'T_FINAL' , 'T_FINALLY' , 'T_FOR' , 'T_FOREACH' , 'T_FUNCTION' , 'T_GLOBAL' , 'T_GOTO' , 'T_HALT_COMPILER' , 'T_IF' , 'T_IMPLEMENTS' , 'T_INCLUDE' , 'T_INCLUDE_ONCE' , 'T_INSTANCEOF' , 'T_INSTEADOF' , 'T_INTERFACE' , 'T_ISSET' , 'T_LIST' , 'T_LOGICAL_AND' , 'T_LOGICAL_OR' , 'T_LOGICAL_XOR' , 'T_NAMESPACE' , 'T_NEW' , 'T_PRINT' , 'T_PRIVATE' , 'T_PROTECTED' , 'T_PUBLIC' , 'T_REQUIRE' , 'T_REQUIRE_ONCE' , 'T_RETURN' , 'T_STATIC' , 'T_SWITCH' , 'T_THROW' , 'T_TRAIT' , 'T_TRY' , 'T_UNSET' , 'T_USE' , 'T_VAR' , 'T_WHILE' , 'T_YIELD' , 'T_YIELD_FROM' , ] ) + [ CT :: T_ARRAY_TYPEHINT => CT :: T_ARRAY_TYPEHINT , CT :: T_CLASS_CONSTANT => CT :: T_CLASS_CONSTANT , CT :: T_CONST_IMPORT => CT :: T_CONST_IMPORT , CT :: T_FUNCTION_IMPORT => CT :: T_FUNCTION_IMPORT , CT :: T_NAMESPACE_OPERATOR => CT :: T_NAMESPACE_OPERATOR , CT :: T_USE_TRAIT => CT :: T_USE_TRAIT , CT :: T_USE_LAMBDA => CT :: T_USE_LAMBDA , ] ; } return $ keywords ; }
7627	public function createContainerIfNotExists ( $ containerName = '' , $ metadata = array ( ) ) { if ( ! $ this -> containerExists ( $ containerName ) ) { $ this -> createContainer ( $ containerName , $ metadata ) ; } }
4794	function group ( $ columns , $ having = "" ) { $ this -> __destruct ( ) ; $ this -> group = $ columns ; $ this -> having = $ having ; return $ this ; }
7383	public static function toValues ( $ input , array $ include = [ ] ) { if ( ! is_array ( $ input ) && ! is_object ( $ input ) ) { throw new InvalidArgumentException ( 'input must be an associative array or traversable object' ) ; } $ sqlStrs = [ ] ; if ( count ( $ include ) ) { foreach ( $ include as $ i ) { if ( array_key_exists ( $ i , $ input ) ) { $ sqlStrs [ ] = '`' . $ i . '` = VALUES(`' . $ i . '`)' ; } } } else { foreach ( $ input as $ k => & $ v ) { $ sqlStrs [ ] = '`' . $ k . '` = VALUES(`' . $ k . '`)' ; } } return implode ( ",\n" , $ sqlStrs ) ; }
859	public function isAllTokenKindsFound ( array $ tokenKinds ) { foreach ( $ tokenKinds as $ tokenKind ) { if ( empty ( $ this -> foundTokenKinds [ $ tokenKind ] ) ) { return false ; } } return true ; }
2093	protected function validator ( $ varInput ) { $ this -> blnSubmitInput = false ; if ( ! \ strlen ( $ varInput ) && ( \ strlen ( $ this -> varValue ) || ! $ this -> mandatory ) ) { return '' ; } $ intLength = $ this -> minlength ? : Config :: get ( 'minPasswordLength' ) ; if ( Utf8 :: strlen ( $ varInput ) < $ intLength ) { $ this -> addError ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'passwordLength' ] , $ intLength ) ) ; } if ( $ varInput != $ this -> getPost ( $ this -> strName . '_confirm' ) ) { $ this -> addError ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'passwordMatch' ] ) ; } $ varInput = parent :: validator ( $ varInput ) ; if ( ! $ this -> hasErrors ( ) ) { $ this -> blnSubmitInput = true ; return password_hash ( $ varInput , PASSWORD_DEFAULT ) ; } return '' ; }
3668	public function generate ( FilterUrl $ filterUrl ) { $ jumpTo = $ filterUrl -> getPage ( ) ; if ( empty ( $ jumpTo [ 'alias' ] ) ) { $ this -> addFromCurrentRequest ( $ filterUrl = $ filterUrl -> clone ( ) , [ ] ) ; $ jumpTo = $ filterUrl -> getPage ( ) ; } $ alias = $ jumpTo [ 'alias' ] ; $ parameters = $ filterUrl -> getGetParameters ( ) ; $ url = $ alias ; if ( $ filterUrl -> hasSlug ( 'auto_item' ) ) { $ url .= '/' . $ this -> encodeForAllowEncodedSlashes ( $ filterUrl -> getSlug ( 'auto_item' ) ) ; } if ( ! empty ( $ jumpTo [ 'domain' ] ) ) { $ parameters [ '_domain' ] = $ jumpTo [ 'domain' ] ; } if ( ! empty ( $ jumpTo [ 'rootUseSSL' ] ) ) { $ parameters [ '_ssl' ] = ( bool ) $ jumpTo [ 'rootUseSSL' ] ; } if ( $ filterUrl -> hasSlug ( 'language' ) ) { $ parameters [ '_locale' ] = $ filterUrl -> getSlug ( 'language' ) ; } foreach ( $ filterUrl -> getSlugParameters ( ) as $ name => $ value ) { if ( in_array ( $ name , [ 'language' , 'auto_item' ] ) ) { continue ; } $ url .= '/' . $ this -> encodeForAllowEncodedSlashes ( $ name ) . '/' . $ this -> encodeForAllowEncodedSlashes ( $ value ) ; } return $ this -> urlGenerator -> generate ( $ url , $ parameters ) ; }
6502	public function parseQueryString ( Uri $ uri ) : IImmutableDictionary { if ( ( $ queryString = $ uri -> getQueryString ( ) ) === null ) { return new ImmutableHashTable ( [ ] ) ; } if ( ! isset ( $ this -> parsedQueryStringCache [ $ queryString ] ) ) { $ parsedQueryString = [ ] ; parse_str ( $ queryString , $ parsedQueryString ) ; $ kvps = [ ] ; foreach ( $ parsedQueryString as $ key => $ value ) { $ kvps [ ] = new KeyValuePair ( $ key , $ value ) ; } $ this -> parsedQueryStringCache [ $ queryString ] = new ImmutableHashTable ( $ kvps ) ; } return $ this -> parsedQueryStringCache [ $ queryString ] ; }
4993	public function getActiveFormActual ( $ setDefault = true ) { $ key = null ; if ( ! empty ( $ this -> activeForms ) ) { $ key = $ this -> activeForms [ 0 ] ; } if ( ! isset ( $ key ) && $ setDefault ) { $ formsAvailable = array_keys ( $ this -> forms ) ; $ key = array_shift ( $ formsAvailable ) ; } return $ key ; }
6942	protected function scheduleSubjectStockUnitChangeEvent ( StockUnitInterface $ stockUnit ) { $ this -> persistenceHelper -> scheduleEvent ( $ this -> getSubjectStockUnitChangeEventName ( ) , new SubjectStockUnitEvent ( $ stockUnit ) ) ; }
454	public function dropPrimaryKey ( $ name , $ table ) { return 'ALTER TABLE ' . $ this -> db -> quoteTableName ( $ table ) . ' DROP CONSTRAINT ' . $ this -> db -> quoteColumnName ( $ name ) ; }
4070	public function getStylesheets ( GetOptionsEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) || ( $ event -> getPropertyName ( ) !== 'additionalCss' ) || ( $ event -> getSubPropertyName ( ) !== 'file' ) ) { return ; } $ event -> setOptions ( $ this -> scanFiles ( 'css' ) ) ; }
761	public function getSql ( ) { $ code = $ this ; while ( $ code -> parent !== null ) { $ code = $ code -> parent ; } return mb_substr ( $ code -> content , $ this -> startOffset , $ this -> endOffset - $ this -> startOffset , 'UTF-8' ) ; }
2548	private function findHandlerForMessage ( $ messageName ) { $ handler = null ; if ( array_key_exists ( $ messageName , $ this -> responseHandlers ) && $ this -> responseHandlers [ $ messageName ] instanceof MessageResponseHandler ) { $ handler = $ this -> responseHandlers [ $ messageName ] ; } else { $ section = substr ( $ messageName , 0 , strpos ( $ messageName , '_' ) ) ; $ message = substr ( $ messageName , strpos ( $ messageName , '_' ) + 1 ) ; $ handlerClass = __NAMESPACE__ . '\\' . $ section . '\\Handler' . $ message ; if ( class_exists ( $ handlerClass ) ) { $ handler = new $ handlerClass ( ) ; $ this -> responseHandlers [ $ messageName ] = $ handler ; } } return $ handler ; }
4445	public function failed ( ) : array { $ results = json_decode ( $ this -> client -> failed ( ) , true ) ; return is_array ( $ results ) ? $ results : [ ] ; }
3393	public function register ( Request $ request ) { $ this -> validator ( $ request -> all ( ) ) -> validate ( ) ; event ( new Registered ( $ user = $ this -> create ( $ request -> all ( ) ) ) ) ; $ this -> sendConfirmationToUser ( $ user ) ; return $ this -> registered ( $ request , $ user ) ? : redirect ( $ this -> redirectAfterRegistrationPath ( ) ) -> with ( 'confirmation' , __ ( 'confirmation::confirmation.confirmation_info' ) ) ; }
10449	public function load ( $ config ) { if ( is_string ( $ config ) and file_exists ( $ config ) ) { $ config = include $ config ; } if ( ! is_array ( $ config ) ) { $ msg = 'Failed to load configuration data' ; throw new ConfigurationException ( $ msg ) ; } return new Configuration ( $ config ) ; }
2834	public function startRendering ( Mage_Core_Block_Abstract $ block ) { if ( $ this -> isRendering ) { $ this -> renderedCount ++ ; Mage :: log ( "Recursive block rendering {$this->getName()}" , Zend_Log :: DEBUG ) ; return ; } $ this -> init ( $ block ) ; $ this -> isRendering = true ; $ this -> renderedCount ++ ; $ this -> renderedAt = microtime ( true ) ; if ( self :: $ startRenderingTime === null ) { self :: $ startRenderingTime = $ this -> renderedAt ; } }
9811	protected function pureGet ( string $ path , array $ params = [ ] , array $ headers = [ ] ) { if ( $ params ) { $ path .= '?' . http_build_query ( $ params ) ; } return $ this -> client -> get ( $ path , $ headers ) ; }
5321	public function remove ( ) { if ( is_resource ( $ this -> mutex ) ) { sem_remove ( $ this -> mutex ) ; } if ( file_exists ( $ this -> file ) ) { unlink ( $ this -> file ) ; } }
12251	public function getNode ( $ strName , $ varDefault = false ) { $ varResult = $ this -> $ strName ; if ( ( $ varResult !== false ) && ( ( string ) $ varResult !== '' ) ) { return ( string ) $ varResult ; } else { return $ varDefault ; } }
1540	public function withQualifiedColumn ( $ column ) { $ parts = explode ( '.' , $ column ) ; if ( ! isset ( $ parts [ 1 ] ) ) { throw new \ InvalidArgumentException ( 'Expecting a valid qualified column name.' ) ; } $ this -> withColumn ( $ parts [ 1 ] ) ; return $ this ; }
82	public function extractTo ( $ target , array $ roles = array ( 'php' => '/' , 'script' => '/bin' ) , $ vars = array ( ) ) { $ extractionPath = $ target . '/tarball' ; try { $ archive = new \ PharData ( $ this -> file ) ; $ archive -> extractTo ( $ extractionPath , null , true ) ; if ( ! is_file ( $ this -> combine ( $ extractionPath , '/package.xml' ) ) ) { throw new \ RuntimeException ( 'Invalid PEAR package. It must contain package.xml file.' ) ; } $ fileCopyActions = $ this -> buildCopyActions ( $ extractionPath , $ roles , $ vars ) ; $ this -> copyFiles ( $ fileCopyActions , $ extractionPath , $ target , $ roles , $ vars ) ; $ this -> filesystem -> removeDirectory ( $ extractionPath ) ; } catch ( \ Exception $ exception ) { throw new \ UnexpectedValueException ( sprintf ( 'Failed to extract PEAR package %s to %s. Reason: %s' , $ this -> file , $ target , $ exception -> getMessage ( ) ) , 0 , $ exception ) ; } }
4458	public function fire ( AbstractUserEvent $ event ) { $ status = null ; $ type = $ event :: getEntityName ( ) ; if ( isset ( $ this -> events [ $ type ] ) ) { $ queue = $ this -> events [ $ type ] ; $ status = $ this -> fireQueue ( $ queue , $ event ) ; } $ eventName = $ event -> getName ( ) ; if ( isset ( $ this -> events [ $ eventName ] ) ) { $ queue = $ this -> events [ $ eventName ] ; $ status = $ this -> fireQueue ( $ queue , $ event ) ; } return $ status ; }
4037	private function getTemplatesForBaseFrom ( $ base , $ folder , $ themeName ) { if ( ! is_dir ( $ folder ) ) { return [ ] ; } $ themeName = trim ( $ themeName ) ; $ foundTemplates = Finder :: create ( ) -> in ( $ folder ) -> name ( $ base . '*' ) ; $ templates = [ ] ; foreach ( $ foundTemplates as $ template ) { $ templates [ $ template -> getBasename ( '.' . $ template -> getExtension ( ) ) ] = [ $ themeName => $ themeName ] ; } return $ templates ; }
11062	public static function isEncodingSupported ( $ encoding ) { $ encoding = strtolower ( $ encoding ) ; if ( isset ( static :: supportedEncodings ( ) [ $ encoding ] ) ) { return true ; } return false ; }
3049	protected function initCompilationDirectory ( ) { $ fileStorage = \ tao_models_classes_service_FileStorage :: singleton ( ) ; $ directoryIds = explode ( '|' , $ this -> getTestCompilationUri ( ) ) ; $ directories = array ( 'private' => $ fileStorage -> getDirectoryById ( $ directoryIds [ 0 ] ) , 'public' => $ fileStorage -> getDirectoryById ( $ directoryIds [ 1 ] ) ) ; $ this -> compilationDirectory = $ directories ; }
9965	public function setSelectedCells ( $ pCoordinate ) { $ pCoordinate = strtoupper ( $ pCoordinate ) ; $ pCoordinate = preg_replace ( '/^([A-Z]+)$/' , '${1}:${1}' , $ pCoordinate ) ; $ pCoordinate = preg_replace ( '/^(\d+)$/' , '${1}:${1}' , $ pCoordinate ) ; $ pCoordinate = preg_replace ( '/^([A-Z]+):([A-Z]+)$/' , '${1}1:${2}1048576' , $ pCoordinate ) ; $ pCoordinate = preg_replace ( '/^(\d+):(\d+)$/' , 'A${1}:XFD${2}' , $ pCoordinate ) ; if ( Coordinate :: coordinateIsRange ( $ pCoordinate ) ) { list ( $ first ) = Coordinate :: splitRange ( $ pCoordinate ) ; $ this -> activeCell = $ first [ 0 ] ; } else { $ this -> activeCell = $ pCoordinate ; } $ this -> selectedCells = $ pCoordinate ; return $ this ; }
1606	public function findRedirectByPath ( $ path ) { $ redirects = $ this -> findAllRedirects ( true ) ; foreach ( $ redirects as $ redirect ) { $ to = false ; if ( trim ( $ redirect [ 'uri' ] , '/' ) == $ path ) $ to = $ redirect [ 'to' ] ; elseif ( $ uri = $ this -> _isRedirectRegex ( $ redirect [ 'uri' ] ) ) if ( preg_match ( $ uri , $ path ) ) $ to = preg_replace ( $ uri , $ redirect [ 'to' ] , $ path ) ; if ( $ to ) { return [ 'to' => strpos ( $ to , '://' ) !== false ? $ to : UrlHelper :: siteUrl ( $ to ) , 'type' => $ redirect [ 'type' ] , ] ; } } return false ; }
1158	protected function ruleAfter ( $ attribute , array $ parameters ) { if ( ! ( $ date = strtotime ( $ parameters [ 0 ] ) ) ) { $ date = $ this -> getAttributeName ( $ parameters [ 0 ] ) ; } return [ $ attribute , [ $ date ] ] ; }
3069	protected function endItemTimer ( $ timestamp = null ) { if ( $ this -> getRequestParameter ( 'itemDuration' ) ) { $ serviceContext = $ this -> getServiceContext ( ) ; $ itemDuration = $ this -> getRequestParameter ( 'itemDuration' ) ; return $ this -> getRunnerService ( ) -> endTimer ( $ serviceContext , $ itemDuration , $ timestamp ) ; } return false ; }
6794	public function getTagCount ( $ ids ) { $ tableName = $ this -> getTagSource ( ) ; $ colNameId = $ this -> getIdColumn ( ) ; $ return = [ ] ; if ( $ tableName && $ colNameId ) { $ statement = $ this -> getConnection ( ) -> createQueryBuilder ( ) -> select ( 'item_id' , 'count(*) as count' ) -> from ( 'tl_metamodel_tag_relation' ) -> where ( 'att_id=:att' ) -> andWhere ( 'item_id IN (:items)' ) -> groupBy ( 'item_id' ) -> setParameter ( 'att' , $ this -> get ( 'id' ) ) -> setParameter ( 'items' , $ ids , Connection :: PARAM_INT_ARRAY ) -> execute ( ) ; while ( $ row = $ statement -> fetch ( \ PDO :: FETCH_OBJ ) ) { $ itemId = $ row -> item_id ; $ return [ $ itemId ] = ( int ) $ row -> count ; } } return $ return ; }
10777	private function total_size ( ) { $ arr = array ( "width" => 0 , "height" => 0 ) ; foreach ( $ this -> images as $ image ) { if ( $ arr [ "width" ] < $ image [ "width" ] ) { $ arr [ "width" ] = $ image [ "width" ] ; } $ arr [ "height" ] += $ image [ "height" ] ; } return $ arr ; }
3796	private function checkForRoot ( $ containedModel , $ action ) { if ( $ this -> hasVariants ( ) && $ action == 'cut' && $ containedModel -> getProperty ( 'varbase' ) == 0 ) { $ this -> disablePI = true ; } }
2289	protected function activateRecipient ( ) { $ this -> Template = new FrontendTemplate ( 'mod_newsletter' ) ; $ optIn = System :: getContainer ( ) -> get ( 'contao.opt-in' ) ; if ( ( ! $ optInToken = $ optIn -> find ( Input :: get ( 'token' ) ) ) || ! $ optInToken -> isValid ( ) || \ count ( $ arrRelated = $ optInToken -> getRelatedRecords ( ) ) < 1 || key ( $ arrRelated ) != 'tl_newsletter_recipients' || \ count ( $ arrIds = current ( $ arrRelated ) ) < 1 ) { $ this -> Template -> type = 'error' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'invalidToken' ] ; return ; } if ( $ optInToken -> isConfirmed ( ) ) { $ this -> Template -> type = 'error' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'tokenConfirmed' ] ; return ; } $ arrRecipients = array ( ) ; foreach ( $ arrIds as $ intId ) { if ( ! $ objRecipient = NewsletterRecipientsModel :: findByPk ( $ intId ) ) { $ this -> Template -> type = 'error' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'invalidToken' ] ; return ; } if ( $ optInToken -> getEmail ( ) != $ objRecipient -> email ) { $ this -> Template -> type = 'error' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'tokenEmailMismatch' ] ; return ; } $ arrRecipients [ ] = $ objRecipient ; } $ time = time ( ) ; $ arrAdd = array ( ) ; $ arrCids = array ( ) ; foreach ( $ arrRecipients as $ objRecipient ) { $ arrAdd [ ] = $ objRecipient -> id ; $ arrCids [ ] = $ objRecipient -> pid ; $ objRecipient -> tstamp = $ time ; $ objRecipient -> active = '1' ; $ objRecipient -> save ( ) ; } $ optInToken -> confirm ( ) ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'activateRecipient' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'activateRecipient' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'activateRecipient' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ optInToken -> getEmail ( ) , $ arrAdd , $ arrCids ) ; } } $ this -> Template -> mclass = 'confirm' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'nl_activate' ] ; }
8135	public function displayBlock ( $ name , $ context = array ( ) ) { $ this -> template -> displayBlock ( $ name , $ this -> env -> mergeGlobals ( $ context ) ) ; }
6631	public function authURL ( $ state ) { $ url = $ this -> settings [ 'authentication_url' ] ; $ params = [ 'client_id' => $ this -> settings ( 'api_key' ) , 'redirect_uri' => $ this -> settings ( 'redirect_uri' ) , 'scope' => $ this -> settings ( 'permissions' ) , 'state' => $ state , ] ; return $ url . '?' . http_build_query ( $ params ) ; }
10819	public static function comment ( $ messages , $ linebreak = true , $ length = 0 ) { $ separator = $ linebreak ? "\n" : '' ; self :: write ( $ messages , 'comment' , $ length , $ separator ) ; }
5846	public function syslog ( $ message , $ severity = \ TYPO3 \ CMS \ Core \ Messaging \ FlashMessage :: OK ) { switch ( $ severity ) { case \ TYPO3 \ CMS \ Core \ Messaging \ FlashMessage :: NOTICE : $ severity = GeneralUtility :: SYSLOG_SEVERITY_NOTICE ; break ; case \ TYPO3 \ CMS \ Core \ Messaging \ FlashMessage :: INFO : $ severity = GeneralUtility :: SYSLOG_SEVERITY_INFO ; break ; case \ TYPO3 \ CMS \ Core \ Messaging \ FlashMessage :: OK : $ severity = GeneralUtility :: SYSLOG_SEVERITY_INFO ; break ; case \ TYPO3 \ CMS \ Core \ Messaging \ FlashMessage :: WARNING : $ severity = GeneralUtility :: SYSLOG_SEVERITY_WARNING ; break ; case \ TYPO3 \ CMS \ Core \ Messaging \ FlashMessage :: ERROR : $ severity = GeneralUtility :: SYSLOG_SEVERITY_ERROR ; break ; } GeneralUtility :: sysLog ( $ message , 'image_autoresize' , $ severity ) ; }
6444	protected function getClient ( $ redirecturl = '' ) { if ( is_object ( $ this -> linkedin ) ) { return $ this -> linkedin ; } if ( $ redirecturl == '' ) { $ redirecturl = $ this -> redirecturl ; } else { $ this -> redirecturl = $ redirecturl ; } $ this -> logQ ( 'redirect ' . $ redirecturl , 'linkedin' ) ; $ API_CONFIG = array ( 'api_key' => $ this -> options [ 'api_key' ] , 'api_secret' => $ this -> options [ 'api_secret' ] , 'callback_url' => $ redirecturl ) ; $ this -> linkedin = $ linkedin = new \ LinkedIn \ LinkedIn ( $ API_CONFIG ) ; return $ this -> linkedin ; }
4039	protected function getClassForOption ( $ index ) { $ intSub = ( $ this -> arrConfiguration [ 'includeBlankOption' ] ? - 1 : 1 ) ; $ strClass = $ this -> strName ; if ( $ index == 0 ) { $ strClass .= ' first' ; } elseif ( $ index === ( count ( $ this -> options ) - $ intSub ) ) { $ strClass .= ' last' ; } if ( ( $ index % 2 ) == 1 ) { $ strClass .= ' even' ; } else { $ strClass .= ' odd' ; } return ( ( strlen ( $ this -> strClass ) ) ? ' ' . $ this -> strClass : '' ) . $ strClass ; }
2244	protected function getSpellcheckerString ( ) { System :: loadLanguageFile ( 'languages' ) ; $ return = array ( ) ; $ langs = scan ( __DIR__ . '/../../languages' ) ; array_unshift ( $ langs , $ GLOBALS [ 'TL_LANGUAGE' ] ) ; foreach ( $ langs as $ lang ) { $ lang = substr ( $ lang , 0 , 2 ) ; if ( isset ( $ GLOBALS [ 'TL_LANG' ] [ 'LNG' ] [ $ lang ] ) ) { $ return [ $ lang ] = $ GLOBALS [ 'TL_LANG' ] [ 'LNG' ] [ $ lang ] . '=' . $ lang ; } } return '+' . implode ( ',' , array_unique ( $ return ) ) ; }
1404	public function add ( $ record , array $ relationship , EncodingParametersInterface $ parameters ) { $ related = $ this -> findRelated ( $ record , $ relationship ) ; $ relation = $ this -> getRelation ( $ record , $ this -> key ) ; $ existing = $ relation -> getQuery ( ) -> whereKey ( $ related -> modelKeys ( ) ) -> get ( ) ; $ relation -> saveMany ( $ related -> diff ( $ existing ) ) ; $ record -> refresh ( ) ; return $ record ; }
2901	public function addResponseInfo ( Mage_Core_Controller_Response_Http $ httpResponse ) { $ this -> responseCode = $ httpResponse -> getHttpResponseCode ( ) ; $ this -> responseHeaders = array ( ) ; $ headers = $ httpResponse -> getHeaders ( ) ; foreach ( $ headers as $ header ) { $ this -> responseHeaders [ $ header [ 'name' ] ] = $ header [ 'value' ] ; } }
6381	public function readQuestionAttempts ( $ id ) { $ questionAttempts = $ this -> readStoreRecords ( 'question_attempts' , [ 'questionusageid' => $ id ] ) ; foreach ( $ questionAttempts as $ questionIndex => $ questionAttempt ) { $ questionAttemptSteps = $ this -> readStoreRecords ( 'question_attempt_steps' , [ 'questionattemptid' => $ questionAttempt -> id ] ) ; foreach ( $ questionAttemptSteps as $ stepIndex => $ questionAttemptStep ) { $ questionAttemptStep -> data = $ this -> readStoreRecords ( 'question_attempt_step_data' , [ 'attemptstepid' => $ questionAttemptStep -> id ] ) ; } $ questionAttempt -> steps = $ questionAttemptSteps ; } return $ questionAttempts ; }
7472	public function resetPasswordAction ( Request $ request , $ id ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ user = $ em -> getRepository ( 'Orkestra\Bundle\ApplicationBundle\Entity\User' ) -> find ( $ id ) ; if ( ! $ user ) { throw $ this -> createNotFoundException ( 'Unable to locate User' ) ; } $ form = $ this -> createForm ( ChangePasswordType :: class , null , array ( 'require_current' => false ) ) ; if ( $ request -> isMethod ( 'POST' ) ) { $ form -> bind ( $ request ) ; if ( $ form -> isValid ( ) ) { $ data = $ form -> getData ( ) ; $ factory = $ this -> get ( 'security.encoder_factory' ) ; $ encoder = $ factory -> getEncoder ( $ user ) ; $ user -> setPassword ( $ encoder -> encodePassword ( $ data [ 'password' ] , $ user -> getSalt ( ) ) ) ; $ em -> persist ( $ user ) ; $ em -> flush ( ) ; $ this -> get ( 'session' ) -> getFlashBag ( ) -> set ( 'success' , 'The password has been changed.' ) ; return $ this -> redirect ( $ this -> generateUrl ( 'orkestra_user_show' , array ( 'id' => $ id ) ) ) ; } } return array ( 'user' => $ user , 'form' => $ form -> createView ( ) , ) ; }
1122	public function leaves ( ) { $ grammar = $ this -> getConnection ( ) -> getQueryGrammar ( ) ; $ rgtCol = $ grammar -> wrap ( $ this -> getQualifiedRightColumnName ( ) ) ; $ lftCol = $ grammar -> wrap ( $ this -> getQualifiedLeftColumnName ( ) ) ; return $ this -> descendants ( ) -> whereRaw ( $ rgtCol . ' - ' . $ lftCol . ' = 1' ) ; }
6764	protected function handleInsert ( SaleInterface $ sale ) { $ changed = false ; $ changed |= $ this -> updateNumber ( $ sale ) ; $ changed |= $ this -> updateKey ( $ sale ) ; $ changed |= $ this -> updateInformation ( $ sale , true ) ; $ changed |= $ this -> pricingUpdater -> updateVatNumberSubject ( $ sale ) ; $ changed |= $ this -> saleUpdater -> updatePaymentTerm ( $ sale ) ; $ changed |= $ this -> saleUpdater -> updateDiscounts ( $ sale , true ) ; $ changed |= $ this -> saleUpdater -> updateTaxation ( $ sale , true ) ; $ changed |= $ this -> saleUpdater -> updateTotals ( $ sale ) ; $ changed |= $ this -> updateState ( $ sale ) ; return $ changed ; }
10191	public function validate ( ) { foreach ( func_get_args ( ) as $ key ) { $ value = $ this -> parameters -> get ( $ key ) ; if ( ! isset ( $ value ) ) { throw new InvalidRequestException ( "The $key parameter is required" ) ; } } }
6242	public function reload ( ) : self { if ( $ this -> loaded === false ) { return $ this ; } clearstatcache ( false , $ this -> raw ) ; $ this -> loaded = false ; return $ this ; }
11502	public function showAction ( Comment $ comment ) { $ deleteForm = $ this -> createDeleteForm ( $ comment ) ; return array ( 'entity' => $ comment , 'delete_form' => $ deleteForm -> createView ( ) , ) ; }
4324	public static function getBytes ( $ size ) { if ( \ is_string ( $ size ) && \ preg_match ( '/^([\d,.]+)\s?([kmgtp])b?$/i' , $ size , $ matches ) ) { $ size = \ str_replace ( ',' , '' , $ matches [ 1 ] ) ; switch ( \ strtolower ( $ matches [ 2 ] ) ) { case 'p' : $ size *= 1024 ; case 't' : $ size *= 1024 ; case 'g' : $ size *= 1024 ; case 'm' : $ size *= 1024 ; case 'k' : $ size *= 1024 ; } } $ units = array ( 'B' , 'kB' , 'MB' , 'GB' , 'TB' , 'PB' ) ; $ pow = \ pow ( 1024 , ( $ i = \ floor ( \ log ( $ size , 1024 ) ) ) ) ; $ size = $ pow == 0 ? '0 B' : \ round ( $ size / $ pow , 2 ) . ' ' . $ units [ $ i ] ; return $ size ; }
8389	public function addLeftOuterJoin ( $ table , $ on ) { $ this -> leftOuterJoins [ ] = array ( 'table' => $ table , 'on' => ( $ on instanceof Condition ? $ on : new Condition ( $ on ) ) ) ; return $ this ; }
4326	public static function getInterface ( ) { $ return = 'http' ; $ isCliOrCron = \ count ( \ array_filter ( array ( \ defined ( 'STDIN' ) , isset ( $ _SERVER [ 'argv' ] ) , ! \ array_key_exists ( 'REQUEST_METHOD' , $ _SERVER ) , ) ) ) > 0 ; if ( $ isCliOrCron ) { $ return = isset ( $ _SERVER [ 'TERM' ] ) || \ array_key_exists ( 'PATH' , $ _SERVER ) ? 'cli' : 'cron' ; } elseif ( isset ( $ _SERVER [ 'HTTP_X_REQUESTED_WITH' ] ) && $ _SERVER [ 'HTTP_X_REQUESTED_WITH' ] == 'XMLHttpRequest' ) { $ return = 'ajax' ; } return $ return ; }
8116	public function canBeReviewedBy ( Member $ member = null ) { if ( ! $ this -> owner -> obj ( "NextReviewDate" ) -> exists ( ) ) { return false ; } if ( $ this -> owner -> obj ( "NextReviewDate" ) -> InFuture ( ) ) { return false ; } $ options = $ this -> getOptions ( ) ; if ( ! $ options ) { return false ; } if ( ! $ options || ( ! $ options -> hasExtension ( __CLASS__ ) && ! $ options -> hasExtension ( ContentReviewDefaultSettings :: class ) ) ) { return false ; } if ( $ options -> OwnerGroups ( ) -> count ( ) == 0 && $ options -> OwnerUsers ( ) -> count ( ) == 0 ) { return false ; } if ( ! $ member ) { return true ; } if ( $ member -> inGroups ( $ options -> OwnerGroups ( ) ) ) { return true ; } if ( $ options -> OwnerUsers ( ) -> find ( "ID" , $ member -> ID ) ) { return true ; } return false ; }
9323	protected function registerMarkdownParser ( ) { $ app = $ this -> app ; $ app -> singleton ( 'commonmark.docparser' , function ( $ app ) { $ environment = $ app [ 'commonmark.environment' ] ; return new DocParser ( $ environment ) ; } ) ; $ app -> alias ( 'commonmark.docparser' , DocParser :: class ) ; }
5106	public function _set ( $ exp , $ bind = false ) { return $ this -> appendPart ( CmdUpdate :: PART_SET , $ exp , $ bind ) ; }
11886	public function addChild ( $ structureName , $ prefix = '' , $ suffix = '' ) { if ( isset ( $ this -> children [ $ structureName ] ) ) { throw new DefinitionDuplicateException ( sprintf ( 'Child structure with same name "%s" already exists' , $ structureName ) ) ; } $ this -> children [ $ structureName ] = array ( 'name' => $ structureName , 'prefix' => ( string ) $ prefix , 'suffix' => ( string ) $ suffix ) ; }
377	private function getByteSize ( $ verboseSize ) { if ( empty ( $ verboseSize ) ) { return 0 ; } if ( is_numeric ( $ verboseSize ) ) { return ( int ) $ verboseSize ; } $ sizeUnit = trim ( $ verboseSize , '0123456789' ) ; $ size = trim ( str_replace ( $ sizeUnit , '' , $ verboseSize ) ) ; if ( ! is_numeric ( $ size ) ) { return 0 ; } switch ( strtolower ( $ sizeUnit ) ) { case 'kb' : case 'k' : return $ size * 1024 ; case 'mb' : case 'm' : return $ size * 1024 * 1024 ; case 'gb' : case 'g' : return $ size * 1024 * 1024 * 1024 ; default : return 0 ; } }
12158	public function getObjectLevel ( ) { if ( $ this -> isPrimaryType ) { return 1 ; } $ parents = $ this -> collectorItem -> parents ; if ( ! empty ( $ parents ) ) { $ maxLevel = 1 ; foreach ( $ parents as $ rel ) { if ( get_class ( $ rel -> parent ) === get_class ( $ this ) ) { continue ; } $ newLevel = $ rel -> parent -> objectLevel + 1 ; if ( $ newLevel > $ maxLevel ) { $ maxLevel = $ newLevel ; } } return $ maxLevel ; } return 1 ; }
8755	public function buildTracker ( $ numItems = Tracker :: UNKNOWN , array $ extraSubscribers = [ ] ) { $ tracker = new Tracker ( $ numItems ) ; foreach ( array_merge ( $ this -> defaultSubscribers , $ extraSubscribers ) as $ listener ) { $ tracker -> getDispatcher ( ) -> addSubscriber ( $ listener ) ; } return $ tracker ; }
1705	public function addResponseCookie ( Response $ response , array $ payload = [ ] ) : void { if ( $ this -> hasCookie ( $ response ) ) { return ; } $ payload [ 'iat' ] = time ( ) ; $ payload [ 'exp' ] = strtotime ( '+30 minutes' ) ; if ( method_exists ( Cookie :: class , 'create' ) ) { $ cookie = Cookie :: create ( self :: COOKIE_NAME , JWT :: encode ( $ payload , $ this -> secret ) ) ; } else { $ cookie = new Cookie ( self :: COOKIE_NAME , JWT :: encode ( $ payload , $ this -> secret ) ) ; } $ response -> headers -> setCookie ( $ cookie ) ; }
5915	public function sendPasswordReset ( $ id , $ link = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'link' => $ link ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/accounts/users/' . $ id . '/resetpassword' , $ parameters ) ; return $ result ; }
9210	protected function printValidationErrors ( $ table , $ id , $ errors ) { foreach ( $ errors as $ field => $ messages ) { foreach ( ( array ) $ messages as $ message ) { $ this -> quiet ( "<warning>{$table} ({$id}): {$field}: {$message}</warning>" ) ; } } }
12321	protected function prepareData ( InputInterface $ input ) { $ return = [ ] ; foreach ( $ this -> validators as $ validator ) { $ result = $ validator -> validate ( $ input ) ; if ( isset ( $ result ) && is_array ( $ result ) ) { $ return = NestedArray :: mergeDeep ( $ return , $ result ) ; } elseif ( isset ( $ result ) ) { $ return [ ] = $ result ; } } return $ return ; }
6768	protected function handleContentChange ( SaleInterface $ sale ) { $ changed = $ this -> saleUpdater -> updateShipmentMethodAndAmount ( $ sale ) ; if ( $ this -> isShipmentTaxationUpdateNeeded ( $ sale ) ) { $ changed = $ this -> saleUpdater -> updateShipmentTaxation ( $ sale , true ) ; } $ changed |= $ this -> saleUpdater -> updateTotals ( $ sale ) ; $ changed |= $ this -> updateState ( $ sale ) ; $ changed |= $ this -> saleUpdater -> updateOutstandingDate ( $ sale ) ; return $ changed ; }
2408	public function flushAllData ( ) { @ trigger_error ( 'Using Template::flushAllData() has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; if ( \ function_exists ( 'fastcgi_finish_request' ) ) { fastcgi_finish_request ( ) ; } elseif ( PHP_SAPI !== 'cli' ) { $ status = ob_get_status ( true ) ; $ level = \ count ( $ status ) ; while ( $ level -- > 0 && ( ! empty ( $ status [ $ level ] [ 'del' ] ) || ( isset ( $ status [ $ level ] [ 'flags' ] ) && ( $ status [ $ level ] [ 'flags' ] & PHP_OUTPUT_HANDLER_REMOVABLE ) && ( $ status [ $ level ] [ 'flags' ] & PHP_OUTPUT_HANDLER_FLUSHABLE ) ) ) ) { ob_end_flush ( ) ; } flush ( ) ; } }
5341	protected function call ( $ service , $ method , array $ parameters = [ ] ) { return $ this -> getSoapClient ( $ service , $ method , $ parameters ) -> __call ( $ method , $ parameters ) ; }
1399	public function errors ( $ errors , $ defaultStatusCode = null , array $ headers = [ ] ) { if ( $ errors instanceof ErrorResponseInterface ) { return $ this -> getErrorResponse ( $ errors ) ; } if ( is_array ( $ errors ) ) { $ errors = $ this -> api -> getErrors ( ) -> errors ( ... $ errors ) ; } return $ this -> errors ( $ this -> factory -> createErrorResponse ( $ errors , $ defaultStatusCode , $ headers ) ) ; }
417	public function getETags ( ) { if ( $ this -> headers -> has ( 'If-None-Match' ) ) { return preg_split ( '/[\s,]+/' , str_replace ( '-gzip' , '' , $ this -> headers -> get ( 'If-None-Match' ) ) , - 1 , PREG_SPLIT_NO_EMPTY ) ; } return [ ] ; }
5305	protected function getPathPart ( SimpleXMLElement $ xmlElement , $ onlyFilled ) { $ path = '' ; if ( $ xmlElement === null ) { $ xmlElement = $ this -> xmlDocument ; } foreach ( $ xmlElement -> children ( ) as $ child ) { $ childName = $ child -> getName ( ) ; if ( ! empty ( $ child [ 'transform' ] ) ) { throw new \ Exception ( 'Transforms are currently not supported!' ) ; } if ( $ childName === 'g' ) { $ path .= ' ' . $ this -> getPathPart ( $ child , $ onlyFilled ) ; } else { if ( $ onlyFilled && ( string ) $ child [ 'fill' ] === 'none' ) { continue ; } if ( $ childName === 'polygon' ) { $ path .= ' ' . $ this -> getPathFromPolygon ( $ child ) ; } elseif ( $ childName === 'rect' ) { $ path .= ' ' . $ this -> getPathFromRect ( $ child ) ; } elseif ( $ childName === 'circle' ) { $ path .= ' ' . $ this -> getPathFromCircle ( $ child ) ; } elseif ( $ childName === 'ellipse' ) { $ path .= ' ' . $ this -> getPathFromEllipse ( $ child ) ; } elseif ( $ childName === 'path' ) { $ pathPart = trim ( $ child [ 'd' ] ) ; if ( substr ( $ pathPart , 0 , 1 ) === 'm' ) { $ pathPart = 'M' . substr ( $ pathPart , 1 ) ; } $ path .= ' ' . $ pathPart ; } } } return trim ( $ path ) ; }
11582	private function getPublicRequireDefinition ( ContainerBuilder $ container , $ id , $ type ) { $ serviceDefinition = $ container -> getDefinition ( $ id ) ; if ( ! $ serviceDefinition -> isPublic ( ) ) { throw new InvalidArgumentException ( sprintf ( 'The service "%s" must be public as block %s are lazy-loaded.' , $ id , $ type ) ) ; } return $ serviceDefinition ; }
6031	public function addself ( $ item ) { if ( ! ( $ item instanceof self ) ) { if ( is_array ( $ item ) ) { try { $ item = new self ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate self. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "self"!' , E_USER_WARNING ) ; } } $ this -> childMedias [ ] = $ item ; return $ this ; }
11704	public function getFormInObject ( ) { $ sExKey = null ; if ( $ this -> _iIdEntity > 0 && $ this -> _sSynchronizeEntity !== null && count ( $ _POST ) < 1 ) { $ sModelName = str_replace ( 'Entity' , 'Model' , $ this -> _sSynchronizeEntity ) ; $ oModel = new $ sModelName ; $ oEntity = new $ this -> _sSynchronizeEntity ; $ sPrimaryKey = LibEntity :: getPrimaryKeyNameWithoutMapping ( $ oEntity ) ; $ sMethodName = 'findOneBy' . $ sPrimaryKey ; $ oCompleteEntity = call_user_func_array ( array ( & $ oModel , $ sMethodName ) , array ( $ this -> _iIdEntity ) ) ; if ( is_object ( $ oCompleteEntity ) ) { foreach ( $ this -> _aElement as $ sKey => $ sValue ) { if ( $ sValue instanceof \ Venus \ lib \ Form \ Input && $ sValue -> getType ( ) == 'submit' ) { continue ; } if ( $ sValue instanceof \ Venus \ lib \ Form \ Radio ) { $ sExKey = $ sKey ; $ sKey = substr ( $ sKey , 0 , - 6 ) ; } if ( $ sValue instanceof Form ) { ; } else { $ sMethodNameInEntity = 'get_' . $ sKey ; if ( method_exists ( $ oCompleteEntity , $ sMethodNameInEntity ) ) { $ mValue = $ oCompleteEntity -> $ sMethodNameInEntity ( ) ; } if ( $ sValue instanceof \ Venus \ lib \ Form \ Radio && method_exists ( $ this -> _aElement [ $ sExKey ] , 'setValueChecked' ) ) { $ this -> _aElement [ $ sExKey ] -> setValueChecked ( $ mValue ) ; } else if ( isset ( $ mValue ) && method_exists ( $ this -> _aElement [ $ sKey ] , 'setValue' ) ) { $ this -> _aElement [ $ sKey ] -> setValue ( $ mValue ) ; } } } } } $ oForm = new \ StdClass ( ) ; $ oForm -> start = '<form name="form' . $ this -> _iFormNumber . '" method="post" enctype="multipart/form-data"><input type="hidden" value="1" name="validform' . $ this -> _iFormNumber . '">' ; $ oForm -> form = array ( ) ; foreach ( $ this -> _aElement as $ sKey => $ sValue ) { if ( $ sValue instanceof Container ) { $ oForm -> form [ $ sKey ] = $ sValue ; } else { $ oForm -> form [ $ sKey ] = $ sValue -> fetch ( ) ; } } $ oForm -> end = '</form>' ; return $ oForm ; }
5337	public function api ( $ name ) { switch ( $ name ) { case 'domain' : case 'domain_service' : case 'domainService' : return new Api \ Domain ( $ this ) ; case 'colocation' : case 'colocation_service' : case 'colocationService' : return new Api \ Colocation ( $ this ) ; case 'forward' : case 'forward_service' : case 'forwardService' : return new Api \ Forward ( $ this ) ; case 'vps' : case 'vps_service' : case 'vpsService' : return new Api \ Vps ( $ this ) ; case 'hosting' : case 'web_hosting' : case 'webHosting' : case 'web_hosting_service' : case 'webHostingService' : return new Api \ WebHosting ( $ this ) ; case 'haip' : case 'ha_ip' : case 'ha_ip_service' : case 'haip_service' : case 'haipService' : return new Api \ Haip ( $ this ) ; default : throw new \ InvalidArgumentException ( sprintf ( 'Undefined api instance called: [%s]' , $ name ) ) ; } }
6147	public function sendHeaders ( ) { if ( php_sapi_name ( ) !== "cli" && headers_sent ( $ file , $ line ) ) { throw new Exception ( "Try to send headers but headers already sent, output started at $file line $line." ) ; } http_response_code ( $ this -> statusCode ) ; foreach ( $ this -> headers as $ header ) { if ( php_sapi_name ( ) !== "cli" ) { header ( $ header ) ; } } return $ this ; }
12838	static public function dir ( $ directory , $ date = false ) { if ( $ date ) { $ directory = rtrim ( $ directory , DIRECTORY_SEPARATOR ) . DIRECTORY_SEPARATOR . self :: getDateDirectory ( ) ; } if ( ! is_dir ( $ directory ) ) { $ umask = umask ( 0000 ) ; if ( @ mkdir ( $ directory , 0777 , true ) === false ) { throw new Exception ( sprintf ( 'Directory "%s" cannot be created.' , $ directory ) ) ; } umask ( $ umask ) ; } return $ directory ; }
9981	public function writeVMLComments ( \ PhpOffice \ PhpSpreadsheet \ Worksheet \ Worksheet $ pWorksheet ) { $ objWriter = null ; if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' , 'yes' ) ; $ comments = $ pWorksheet -> getComments ( ) ; $ objWriter -> startElement ( 'xml' ) ; $ objWriter -> writeAttribute ( 'xmlns:v' , 'urn:schemas-microsoft-com:vml' ) ; $ objWriter -> writeAttribute ( 'xmlns:o' , 'urn:schemas-microsoft-com:office:office' ) ; $ objWriter -> writeAttribute ( 'xmlns:x' , 'urn:schemas-microsoft-com:office:excel' ) ; $ objWriter -> startElement ( 'o:shapelayout' ) ; $ objWriter -> writeAttribute ( 'v:ext' , 'edit' ) ; $ objWriter -> startElement ( 'o:idmap' ) ; $ objWriter -> writeAttribute ( 'v:ext' , 'edit' ) ; $ objWriter -> writeAttribute ( 'data' , '1' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'v:shapetype' ) ; $ objWriter -> writeAttribute ( 'id' , '_x0000_t202' ) ; $ objWriter -> writeAttribute ( 'coordsize' , '21600,21600' ) ; $ objWriter -> writeAttribute ( 'o:spt' , '202' ) ; $ objWriter -> writeAttribute ( 'path' , 'm,l,21600r21600,l21600,xe' ) ; $ objWriter -> startElement ( 'v:stroke' ) ; $ objWriter -> writeAttribute ( 'joinstyle' , 'miter' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'v:path' ) ; $ objWriter -> writeAttribute ( 'gradientshapeok' , 't' ) ; $ objWriter -> writeAttribute ( 'o:connecttype' , 'rect' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; foreach ( $ comments as $ key => $ value ) { $ this -> writeVMLComment ( $ objWriter , $ key , $ value ) ; } $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
11930	public function getActiveCustomFields ( ) { if ( $ this -> activeCustomFields === null ) { $ this -> activeCustomFields = array ( ) ; foreach ( $ this -> customFields as $ cf ) { if ( $ cf -> isActive ( ) ) { array_push ( $ this -> activeCustomFields , $ cf ) ; } } } return $ this -> activeCustomFields ; }
2882	protected function _initEmail ( ) { $ token = $ this -> getRequest ( ) -> getParam ( 'token' ) ; $ index = $ this -> getRequest ( ) -> getParam ( 'index' ) ; if ( $ token === null || $ index === null ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 400 ) -> setBody ( 'Invalid parameters' ) ; return null ; } $ requestProfile = Mage :: getModel ( 'sheep_debug/requestInfo' ) -> load ( $ token , 'token' ) ; if ( ! $ requestProfile -> getId ( ) ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 404 ) -> setBody ( 'Request profile not found' ) ; return null ; } $ emails = $ requestProfile -> getEmails ( ) ; if ( ! $ emails || ! ( $ index < count ( $ emails ) ) ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 404 ) -> setBody ( 'E-mail not found' ) ; return null ; } return $ emails [ ( int ) $ index ] ; }
7996	protected function validateHashContext ( $ context ) { if ( ! ( $ context instanceof HashContext ) && ( false === $ context || ! is_resource ( $ context ) || ( is_resource ( $ context ) && static :: HASH_CONTEXT_RESOURCE_TYPE !== get_resource_type ( $ context ) ) ) ) { throw new InvalidArgumentException ( 'Unable to initialize hashing context. Your system might not support the supplied algorithm.' ) ; } return $ context ; }
6062	public function download ( $ id , $ template = null , $ templateType = 'image' , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'template' => $ template , 'templateType' => $ templateType ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/media/' . $ id . '/download' , $ parameters , $ cachePolicy ) ; $ tmpFile = tmpfile ( ) ; if ( false === fwrite ( $ tmpFile , $ result ) ) { throw new \ RuntimeException ( 'Could not write download data to temporary file!' ) ; } if ( false === fseek ( $ tmpFile , 0 ) ) { throw new \ RuntimeException ( 'Could not reset file pointer of temporary file!' ) ; } $ result = $ tmpFile ; return $ result ; }
3392	public function resendConfirmation ( Request $ request ) { $ model = $ this -> guard ( ) -> getProvider ( ) -> createModel ( ) ; $ user = $ model -> findOrFail ( $ request -> session ( ) -> pull ( 'confirmation_user_id' ) ) ; $ this -> sendConfirmationToUser ( $ user ) ; return redirect ( $ this -> redirectAfterResendConfirmationPath ( ) ) -> with ( 'confirmation' , __ ( 'confirmation::confirmation.confirmation_resent' ) ) ; }
6156	public function redirect ( string $ url ) : object { return parent :: redirect ( $ this -> di -> get ( "url" ) -> create ( $ url ) ) ; }
8222	protected function getLimitFor ( $ actionName , $ blockType , $ entityId ) { $ limit = $ this -> storage -> getLimitFor ( $ actionName , $ blockType , $ entityId ) ; if ( $ limit === null ) { $ limit = array ( "ts" => 0 , "cnt" => 0 ) ; } return $ limit ; }
8293	protected function errorHandler ( \ Exception $ e , $ url = "" ) { $ this -> errorOccurred = true ; $ this -> requestFile = $ this -> pluginDir . '/content/error.md' ; if ( $ this -> config [ "debug" ] === true ) { $ this -> addOutput ( "_exception" , ( string ) $ e ) ; } $ this -> logger -> critical ( "Exception on url '{url}': {e}" , array ( "url" => $ url , "e" => $ e ) ) ; header ( $ _SERVER [ 'SERVER_PROTOCOL' ] . ' 500 Internal Server Error' , true , 500 ) ; $ this -> requestUrl = "500" ; }
6232	public function setPickupPoint ( $ pickup_point_id ) { $ service = new AdditionalService ( ) ; $ service -> setServiceCode ( 2106 ) ; $ service -> addSpecifier ( 'pickup_point_id' , $ pickup_point_id ) ; $ this -> addAdditionalService ( $ service ) ; }
9552	public function allowMimeTypes ( $ mimeTypes ) { if ( ! is_array ( $ mimeTypes ) ) { $ mimeTypes = [ $ mimeTypes ] ; } $ this -> constraints [ ] = new MimeTypeConstraint ( $ mimeTypes ) ; return $ this ; }
11801	public function hookTemplateRender ( $ templates , $ data , $ rendered , $ controller ) { $ template = reset ( $ templates ) ; if ( strpos ( $ template , '/modules/ga_report/templates/panels/' ) !== false && isset ( $ data [ 'content' ] [ 'data' ] [ 'report' ] [ 'data' ] ) && isset ( $ data [ 'content' ] [ 'data' ] [ 'handler' ] [ 'id' ] ) ) { $ handler_id = $ data [ 'content' ] [ 'data' ] [ 'handler' ] [ 'id' ] ; $ controller -> setJsSettings ( "ga_chart_$handler_id" , $ data [ 'content' ] [ 'data' ] [ 'report' ] [ 'data' ] ) ; $ controller -> setJs ( __DIR__ . "/js/handlers/$handler_id.js" ) ; $ controller -> setJs ( __DIR__ . "/js/common.js" ) ; } }
3213	static function checkArgOrNull ( $ argName , $ argValue ) { if ( $ argValue === null ) return ; if ( ! ( $ argValue instanceof self ) ) Checker :: throwError ( $ argName , $ argValue , __CLASS__ ) ; }
1094	public function roots ( ) { return $ this -> node -> newQuery ( ) -> whereNull ( $ this -> node -> getQualifiedParentColumnName ( ) ) -> orderBy ( $ this -> node -> getQualifiedLeftColumnName ( ) ) -> orderBy ( $ this -> node -> getQualifiedRightColumnName ( ) ) -> orderBy ( $ this -> node -> getQualifiedKeyName ( ) ) -> get ( ) ; }
3317	public function pushValue ( $ value ) { $ value = $ this -> _preprocessValue ( $ value ) ; $ this -> value [ ] = $ value ; $ this -> callTrigger ( ) ; }
4501	public function getElementsByClassName ( string $ names ) : HTMLCollection { $ namesArray = explode ( " " , $ names ) ; $ dots = "." . implode ( "." , $ namesArray ) ; return $ this -> css ( $ dots ) ; }
7980	public function getSessionFiles ( $ sessId ) { return json_decode ( self :: getClient ( ) -> getPcaSessionFiles ( $ this -> pp , $ this -> sn , $ sessId ) ) ; }
10940	public function getResponse ( $ params = [ ] , $ lifetime = - 1 , Response $ response = null ) { if ( ! $ response ) { $ response = new Response ( ) ; } if ( ! $ this -> enable ) { return $ response ; } return $ this -> configurator -> configure ( $ response , $ this -> getMax ( $ params ) , $ lifetime ) ; }
12757	public function routeStartup ( Zend_Controller_Request_Abstract $ request ) { if ( ! $ request -> getHeader ( 'User-Agent' ) ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 403 ) -> setHeader ( 'Content-Type' , 'text/plain; charset=utf-8' ) -> setBody ( implode ( "\n" , self :: $ _errMessage ) ) -> sendResponse ( ) ; exit ( 403 ) ; } }
710	public function tinyInteger ( $ length = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_TINYINT , $ length ) ; }
12284	public function head ( ) : string { $ property = static :: HEAD_ASSETS_NAME . static :: BLOCK_PROPERTY_SUFFIX ; return isset ( $ this -> $ property ) ? trim ( $ this -> make ( static :: HEAD_ASSETS_NAME ) ) . PHP_EOL : PHP_EOL ; }
8639	public function setDirectPaymentList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'DirectPaymentList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
897	private function fixTokensCompare ( Tokens $ tokens , $ startLeft , $ endLeft , $ compareOperatorIndex , $ startRight , $ endRight ) { $ type = $ tokens [ $ compareOperatorIndex ] -> getId ( ) ; $ content = $ tokens [ $ compareOperatorIndex ] -> getContent ( ) ; if ( \ array_key_exists ( $ type , $ this -> candidatesMap ) ) { $ tokens [ $ compareOperatorIndex ] = clone $ this -> candidatesMap [ $ type ] ; } elseif ( \ array_key_exists ( $ content , $ this -> candidatesMap ) ) { $ tokens [ $ compareOperatorIndex ] = clone $ this -> candidatesMap [ $ content ] ; } $ right = $ this -> fixTokensComparePart ( $ tokens , $ startRight , $ endRight ) ; $ left = $ this -> fixTokensComparePart ( $ tokens , $ startLeft , $ endLeft ) ; for ( $ i = $ startRight ; $ i <= $ endRight ; ++ $ i ) { $ tokens -> clearAt ( $ i ) ; } for ( $ i = $ startLeft ; $ i <= $ endLeft ; ++ $ i ) { $ tokens -> clearAt ( $ i ) ; } $ tokens -> insertAt ( $ startRight , $ left ) ; $ tokens -> insertAt ( $ startLeft , $ right ) ; return $ startLeft ; }
9612	public function getRootUrl ( ) { $ request = $ this -> requests -> getCurrentRequest ( ) ; $ host = $ request -> getHttpHost ( ) ; $ base = $ request -> getBaseUrl ( ) ; return rtrim ( "//$host/$base" , '/' ) ; }
12551	public function isSerialized ( ) { if ( ! is_string ( $ this -> serialized ) ) { return false ; } $ this -> serialized = trim ( $ this -> serialized ) ; if ( 'N;' == $ this -> serialized ) { return true ; } $ length = strlen ( $ this -> serialized ) ; if ( $ length < 4 ) { return false ; } if ( ':' !== $ this -> serialized [ 1 ] ) { return false ; } $ lastc = $ this -> serialized [ $ length - 1 ] ; if ( ';' !== $ lastc && '}' !== $ lastc ) { return false ; } $ token = $ this -> serialized [ 0 ] ; switch ( $ token ) { case 's' : if ( '"' !== $ this -> serialized [ $ length - 2 ] ) { return false ; } case 'a' : case 'O' : return ( bool ) preg_match ( "/^{$token}:[0-9]+:/s" , $ this -> serialized ) ; case 'b' : case 'i' : case 'd' : return ( bool ) preg_match ( "/^{$token}:[0-9.E-]+;\$/" , $ this -> serialized ) ; } return false ; }
10227	public function pageFor ( $ model , $ itemId = 0 , ModelConfig $ config = null ) { $ modelName = $ this -> resolveModelName ( $ model ) ; $ item = $ this -> findItem ( $ modelName , $ itemId ) ; $ pageFactory = $ this -> app -> make ( 'Label305\AujaLaravel\Factory\PageFactory' ) ; return $ pageFactory -> create ( $ modelName , $ item , $ config ) ; }
9038	protected function execute ( QueryBuilder $ builder ) : ? Result { return $ this -> connection -> queryArgs ( $ builder -> getQuerySql ( ) , $ builder -> getQueryParameters ( ) ) ; }
10306	public function setLineStyleProperties ( $ line_width = null , $ compound_type = null , $ dash_type = null , $ cap_type = null , $ join_type = null , $ head_arrow_type = null , $ head_arrow_size = null , $ end_arrow_type = null , $ end_arrow_size = null ) { ( $ line_width !== null ) ? $ this -> lineStyleProperties [ 'width' ] = $ this -> getExcelPointsWidth ( ( float ) $ line_width ) : null ; ( $ compound_type !== null ) ? $ this -> lineStyleProperties [ 'compound' ] = ( string ) $ compound_type : null ; ( $ dash_type !== null ) ? $ this -> lineStyleProperties [ 'dash' ] = ( string ) $ dash_type : null ; ( $ cap_type !== null ) ? $ this -> lineStyleProperties [ 'cap' ] = ( string ) $ cap_type : null ; ( $ join_type !== null ) ? $ this -> lineStyleProperties [ 'join' ] = ( string ) $ join_type : null ; ( $ head_arrow_type !== null ) ? $ this -> lineStyleProperties [ 'arrow' ] [ 'head' ] [ 'type' ] = ( string ) $ head_arrow_type : null ; ( $ head_arrow_size !== null ) ? $ this -> lineStyleProperties [ 'arrow' ] [ 'head' ] [ 'size' ] = ( string ) $ head_arrow_size : null ; ( $ end_arrow_type !== null ) ? $ this -> lineStyleProperties [ 'arrow' ] [ 'end' ] [ 'type' ] = ( string ) $ end_arrow_type : null ; ( $ end_arrow_size !== null ) ? $ this -> lineStyleProperties [ 'arrow' ] [ 'end' ] [ 'size' ] = ( string ) $ end_arrow_size : null ; }
2510	public function analyze ( SendResult $ response ) { $ analyzeResponse = new Result ( $ response ) ; $ domXpath = $ this -> makeDomXpath ( $ response -> responseXml ) ; $ errorCodeNodeList = $ domXpath -> query ( self :: Q_G_ERR ) ; if ( $ errorCodeNodeList -> length > 0 ) { $ errorCatNode = $ domXpath -> query ( self :: Q_G_CAT ) -> item ( 0 ) ; $ analyzeResponse -> setStatus ( $ this -> makeStatusForPotentiallyNonExistent ( $ errorCatNode ) ) ; $ code = $ errorCodeNodeList -> item ( 0 ) -> nodeValue ; $ errorTextNodeList = $ domXpath -> query ( self :: Q_G_MSG ) ; $ message = $ this -> makeMessageFromMessagesNodeList ( $ errorTextNodeList ) ; $ analyzeResponse -> messages [ ] = new Result \ NotOk ( $ code , trim ( $ message ) , 'general' ) ; } $ errorCodeNodeList = $ domXpath -> query ( self :: Q_D_ERR ) ; if ( $ errorCodeNodeList -> length > 0 ) { $ errorCatNode = $ domXpath -> query ( self :: Q_D_CAT ) -> item ( 0 ) ; $ analyzeResponse -> setStatus ( $ this -> makeStatusForPotentiallyNonExistent ( $ errorCatNode ) ) ; $ code = $ errorCodeNodeList -> item ( 0 ) -> nodeValue ; $ errorTextNodeList = $ domXpath -> query ( self :: Q_D_MSG ) ; $ message = $ this -> makeMessageFromMessagesNodeList ( $ errorTextNodeList ) ; $ analyzeResponse -> messages [ ] = new Result \ NotOk ( $ code , trim ( $ message ) , 'deficient_fop' ) ; } return $ analyzeResponse ; }
11695	protected function bustCacheBalls ( string $ asset_contents ) { $ asset_ext = $ this -> destination -> getExtension ( ) ; $ asset_name = $ this -> destination -> getBasename ( '.' . $ asset_ext ) ; $ asset_name_quoted = preg_quote ( $ asset_name , '/' ) ; $ search_for = '/' . $ asset_name_quoted . '\..*?\.' . $ asset_ext . '|' . $ asset_name_quoted . '\..*?\.min\.' . $ asset_ext . '|' . $ asset_name_quoted . '\.min\.' . $ asset_ext . '|' . $ asset_name_quoted . '\.' . $ asset_ext . '/' ; $ replace_with = $ asset_name . '.' . md5 ( $ asset_contents ) . '.' . $ asset_ext ; foreach ( $ this -> template as $ templateFile ) { $ this -> printTaskInfo ( 'Updating template file - <info>' . $ templateFile . '</info>' ) ; $ this -> collectionBuilder ( ) -> taskReplaceInFile ( $ templateFile ) -> regex ( $ search_for ) -> to ( $ replace_with ) -> run ( ) ; } $ asset_base_dir = $ this -> destination -> getPath ( ) ; $ this -> destination = new SplFileInfo ( $ asset_base_dir . '/' . $ replace_with ) ; $ files_to_delete = new Finder ( ) ; $ files_to_delete -> files ( ) ; $ files_to_delete -> name ( $ asset_name . '.' . $ asset_ext ) ; $ files_to_delete -> name ( $ asset_name . '.*.' . $ asset_ext ) ; $ files_to_delete -> name ( $ asset_name . '.*.' . $ asset_ext . '.gz' ) ; $ files_to_delete -> in ( $ asset_base_dir ) ; $ files_to_delete -> depth ( '== 0' ) ; foreach ( $ files_to_delete as $ file_to_delete ) { unlink ( $ file_to_delete -> getPathname ( ) ) ; } }
10996	public function prepend ( string $ contents , int $ maxMemory = 8096 ) : bool { $ test = \ sndsgd \ Fs :: EXISTS | \ sndsgd \ Fs :: READABLE | \ sndsgd \ Fs :: WRITABLE ; if ( $ this -> test ( $ test ) === false ) { $ this -> error = "failed to prepend file; {$this->error}" ; return false ; } $ len = strlen ( $ contents ) ; $ size = filesize ( $ this -> path ) ; $ endsize = $ len + $ size ; if ( $ endsize > $ maxMemory ) { return $ this -> prependFileInPlace ( $ contents , $ len , $ endsize ) ; } if ( ( $ tmp = $ this -> readFile ( 0 ) ) === false ) { return false ; } if ( $ this -> writeFile ( $ contents . $ tmp , 0 ) === false ) { return false ; } return true ; }
10835	private function compileOn ( array $ join ) { $ sql = array ( ) ; list ( $ on , $ table , $ type , $ c1 , $ op , $ c2 ) = $ join ; if ( $ type !== null ) { $ sql [ ] = $ type ; } array_push ( $ sql , "JOIN" , $ table , "ON" , $ c1 , $ op , $ c2 ) ; return join ( ' ' , $ sql ) ; }
6056	public function updateFolder ( $ id , Folder $ folder ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'folder' => $ folder ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/folders/' . $ id . '' , $ parameters ) ; $ result = new FolderResponse ( $ result ) ; return $ result ; }
5941	public function connect ( ) { if ( $ this -> stream !== null ) { return ; } $ host = strval ( $ this -> config [ "host" ] ) ; $ port = strval ( $ this -> config [ "port" ] ) ; $ address = "tcp://" . $ host . ":" . $ port ; $ timeout = intval ( $ this -> config [ "timeout" ] ) ; $ this -> stream = @ stream_socket_client ( $ address , $ errno , $ errstr , $ timeout ) ; if ( $ this -> stream === false ) { throw new Ts3Exception ( StringHelper :: factory ( $ errstr ) -> toUtf8 ( ) -> toString ( ) , $ errno ) ; } @ stream_set_timeout ( $ this -> stream , $ timeout ) ; @ stream_set_blocking ( $ this -> stream , $ this -> config [ "blocking" ] ? 1 : 0 ) ; }
12239	public function innerXML ( ) { $ xml = $ this -> outerXML ( ) ; $ pos = 1 + strpos ( $ xml , '>' ) ; $ len = strrpos ( $ xml , '<' ) - $ pos ; return substr ( $ xml , $ pos , $ len ) ; }
6880	public function transform ( $ data ) { $ address = new ShipmentAddress ( ) ; if ( ! is_array ( $ data ) || empty ( $ data ) ) { return $ address ; } foreach ( $ this -> fields as $ field ) { if ( isset ( $ data [ $ field ] ) ) { $ value = $ data [ $ field ] ; if ( $ field === 'country' ) { if ( 0 >= $ value ) { throw new InvalidArgumentException ( "Invalid country id." ) ; } $ value = $ this -> countryRepository -> find ( $ value ) ; if ( null === $ value ) { throw new InvalidArgumentException ( "Country not found." ) ; } } elseif ( $ field === 'phone' || $ field === 'mobile' ) { $ value = unserialize ( $ value ) ; if ( ! $ value instanceof PhoneNumber ) { throw new InvalidArgumentException ( "Invalid phone number." ) ; } } $ this -> accessor -> setValue ( $ address , $ field , $ value ) ; } } return $ address ; }
2865	public function getLoggedContent ( $ logFile ) { if ( ! array_key_exists ( $ logFile , $ this -> ranges ) ) { throw new Exception ( 'Invalid log file' ) ; } return $ this -> getContent ( $ this -> getLogFilePath ( $ logFile ) , $ this -> ranges [ $ logFile ] [ 'start' ] , $ this -> ranges [ $ logFile ] [ 'end' ] ) ; }
3485	public static function resolve ( ) : SignatureGeneratorInterface { self :: addDefaultResolvers ( ) ; foreach ( self :: $ resolvers as $ resolver ) { if ( $ generator = $ resolver ( ) ) { return $ generator ; } } throw new \ LogicException ( 'Cannot resolve available JWT Signature Generator.' ) ; }
9001	public function column_user ( AbstractLog $ item ) { $ user = $ item -> get_user ( ) ; if ( empty ( $ user ) ) { echo '-' ; } else { echo $ user -> display_name ; } }
11172	public static function encrypt ( $ data , $ key , $ cipher = MCRYPT_RIJNDAEL_128 , $ mode = MCRYPT_MODE_CBC ) { $ data = serialize ( $ data ) ; $ key = hash ( 'sha256' , $ key , true ) ; $ iv_size = mcrypt_get_iv_size ( $ cipher , $ mode ) ; $ iv = mcrypt_create_iv ( $ iv_size , MCRYPT_RAND ) ; return base64_encode ( serialize ( array ( $ iv , mcrypt_encrypt ( $ cipher , $ key , $ data , $ mode , $ iv ) ) ) ) ; }
7699	function MsWord_Clean ( & $ Txt ) { $ Txt = str_replace ( '<w:lastRenderedPageBreak/>' , '' , $ Txt ) ; $ this -> XML_DeleteElements ( $ Txt , array ( 'w:proofErr' , 'w:noProof' , 'w:lang' , 'w:lastRenderedPageBreak' ) ) ; $ this -> MsWord_CleanSystemBookmarks ( $ Txt ) ; $ this -> MsWord_CleanRsID ( $ Txt ) ; $ this -> MsWord_CleanDuplicatedLayout ( $ Txt ) ; }
3175	private function getItemLabel ( RunnerServiceContext $ context , $ itemUri , $ useTitle = false ) { $ label = '' ; if ( $ useTitle ) { $ label = $ context -> getItemIndexValue ( $ itemUri , 'title' ) ; } if ( ! $ label ) { $ label = $ context -> getItemIndexValue ( $ itemUri , 'label' ) ; } if ( ! $ label ) { $ item = new \ core_kernel_classes_Resource ( $ itemUri ) ; $ label = $ item -> getLabel ( ) ; } return $ label ; }
3447	public function toArray ( ) { $ array = $ this -> fields ; foreach ( $ this -> appends as $ accessor ) { if ( isset ( $ this [ $ accessor ] ) ) { $ array [ $ accessor ] = $ this [ $ accessor ] ; } } foreach ( $ this -> related as $ key => $ value ) { if ( is_object ( $ value ) && method_exists ( $ value , 'toArray' ) ) { $ array [ $ key ] = $ value -> toArray ( ) ; } elseif ( is_null ( $ value ) || $ value === false ) { $ array [ $ key ] = $ value ; } } if ( count ( $ this -> getVisible ( ) ) > 0 ) { $ array = array_intersect_key ( $ array , array_flip ( $ this -> getVisible ( ) ) ) ; } if ( count ( $ this -> getHidden ( ) ) > 0 ) { $ array = array_diff_key ( $ array , array_flip ( $ this -> getHidden ( ) ) ) ; } return $ array ; }
10961	protected function restoreResponse ( $ response , $ data ) { if ( isset ( $ data [ 'format' ] ) ) { $ response -> format = $ data [ 'format' ] ; } if ( isset ( $ data [ 'version' ] ) ) { $ response -> version = $ data [ 'version' ] ; } if ( isset ( $ data [ 'statusCode' ] ) ) { $ response -> statusCode = $ data [ 'statusCode' ] ; } if ( isset ( $ data [ 'statusText' ] ) ) { $ response -> statusText = $ data [ 'statusText' ] ; } if ( isset ( $ data [ 'headers' ] ) && is_array ( $ data [ 'headers' ] ) ) { $ headers = $ response -> getHeaders ( ) -> toArray ( ) ; $ response -> getHeaders ( ) -> fromArray ( array_merge ( $ data [ 'headers' ] , $ headers ) ) ; } if ( isset ( $ data [ 'cookies' ] ) && is_array ( $ data [ 'cookies' ] ) ) { $ cookies = $ response -> getCookies ( ) -> toArray ( ) ; $ response -> getCookies ( ) -> fromArray ( array_merge ( $ data [ 'cookies' ] , $ cookies ) ) ; } }
11858	public function getHandler ( ) { if ( $ this -> pairedDataItem ) { if ( ! isset ( $ this -> primaryObject ) ) { return $ this -> pairedDataItem ; } elseif ( isset ( $ this -> companionObject ) ) { return static :: getHandlingObject ( $ this , $ this -> pairedDataItem ) ; } } return $ this ; }
12977	protected function getComponentDefaults ( $ mappingName , array $ mappingConfig ) { if ( strpos ( $ mappingName , '::' ) ) { list ( $ componentName , $ componentType ) = explode ( '::' , $ mappingName ) ; } else { $ componentName = $ mappingName ; $ componentType = $ this -> detectComponentType ( $ componentName ) ; if ( $ componentType === false and $ componentName === 'app' ) { $ componentType = 'app' ; } } if ( ( $ componentPath = $ this -> getComponentPath ( $ componentName , $ componentType ) ) === false ) { return false ; } $ configPath = $ mappingConfig [ 'dir' ] ; if ( $ configPath === false ) { $ configPath = $ this -> getConfigPath ( ) ; } if ( $ mappingConfig [ 'type' ] === false ) { $ mappingConfig [ 'type' ] = $ this -> detectMetadataDriver ( $ componentPath , $ configPath ) ; } if ( $ mappingConfig [ 'type' ] === false ) { return false ; } if ( $ mappingConfig [ 'dir' ] === false ) { if ( in_array ( $ mappingConfig [ 'type' ] , array ( 'annotation' , 'staticphp' ) ) ) { $ mappingConfig [ 'dir' ] = $ this -> getClassPath ( ) . $ this -> getObjectName ( ) ; } else { $ mappingConfig [ 'dir' ] = $ configPath ; } } if ( is_array ( $ mappingConfig [ 'dir' ] ) ) { foreach ( $ mappingConfig [ 'dir' ] as & $ path ) { $ path = $ componentPath . $ path ; } } else { $ mappingConfig [ 'dir' ] = $ componentPath . $ mappingConfig [ 'dir' ] ; } if ( $ mappingConfig [ 'prefix' ] === false ) { $ mappingConfig [ 'prefix' ] = $ this -> detectComponentNamespace ( $ componentName , $ componentType ) ; } $ mappingConfig [ 'is_component' ] = false ; return $ mappingConfig ; }
420	public function run ( ) { $ block = ob_get_clean ( ) ; if ( $ this -> renderInPlace ) { echo $ block ; } $ this -> view -> blocks [ $ this -> getId ( ) ] = $ block ; }
6387	public function readDiscussion ( $ id ) { $ model = $ this -> readObject ( $ id , 'forum_discussions' ) ; $ model -> url = $ this -> cfg -> wwwroot . '/mod/forum/discuss.php?d=' . $ id ; return $ model ; }
11710	public function actionConfirm ( $ id , $ back = 'index' ) { $ this -> findModel ( $ id ) -> confirm ( ) ; \ Yii :: $ app -> getSession ( ) -> setFlash ( 'success' , \ Yii :: t ( 'user' , 'User has been confirmed' ) ) ; $ url = $ back == 'index' ? [ 'index' ] : [ 'update' , 'id' => $ id ] ; return $ this -> redirect ( $ url ) ; }
3517	public function getShowUnpublished ( ) { if ( ! $ this -> cookiesLoaded ) { $ key = $ this -> cookiePrefix . 'show_unpublished' ; $ queuedCookie = \ Cookie :: queued ( $ key , null ) ; $ showUnpublished = $ queuedCookie != null ? $ queuedCookie -> getValue ( ) : \ Cookie :: get ( $ key , false ) ; $ this -> useDB = $ showUnpublished ? 2 : 1 ; $ this -> cookiesLoaded = true ; } return $ this -> useDB === 2 ; }
9733	public function setARGB ( $ pValue ) { if ( $ pValue == '' ) { $ pValue = self :: COLOR_BLACK ; } if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'argb' => $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> argb = $ pValue ; } return $ this ; }
2352	public function sendToBrowser ( $ filename = '' , $ inline = false ) { $ response = new BinaryFileResponse ( $ this -> strRootDir . '/' . $ this -> strFile ) ; $ response -> setContentDisposition ( $ inline ? ResponseHeaderBag :: DISPOSITION_INLINE : ResponseHeaderBag :: DISPOSITION_ATTACHMENT , $ filename , Utf8 :: toAscii ( $ this -> basename ) ) ; $ response -> headers -> addCacheControlDirective ( 'must-revalidate' ) ; $ response -> headers -> addCacheControlDirective ( 'post-check' , 0 ) ; $ response -> headers -> addCacheControlDirective ( 'pre-check' , 0 ) ; $ response -> headers -> set ( 'Connection' , 'close' ) ; throw new ResponseException ( $ response ) ; }
3493	public function withCertificate ( string $ certificate ) : Request { $ cloned = clone $ this ; $ cloned -> certificate = $ certificate ; return $ cloned ; }
3269	public function readFromFile ( ) : \ Generator { $ file = $ this -> openFile ( static :: FILE_READ ) ; try { foreach ( $ file as $ line ) { yield new Line ( $ line ) ; } } finally { $ this -> closeFile ( $ file ) ; } }
352	public static function getInputId ( $ model , $ attribute ) { $ charset = Yii :: $ app ? Yii :: $ app -> charset : 'UTF-8' ; $ name = mb_strtolower ( static :: getInputName ( $ model , $ attribute ) , $ charset ) ; return str_replace ( [ '[]' , '][' , '[' , ']' , ' ' , '.' ] , [ '' , '-' , '-' , '' , '-' , '-' ] , $ name ) ; }
8839	private function readStreams ( \ Closure $ callback = null ) : void { $ stdOut = $ this -> readOutput ( self :: STDOUT ) ; $ stdErr = $ this -> readOutput ( self :: STDERR ) ; $ this -> fullStdOut .= $ stdOut ; $ this -> fullStdErr .= $ stdErr ; if ( ! is_null ( $ callback ) ) { $ callback ( $ stdOut , $ stdErr ) ; } $ this -> observer -> stdOutRead ( $ this -> pid , $ stdOut ) ; $ this -> observer -> stdErrRead ( $ this -> pid , $ stdErr ) ; }
6464	public function isJson ( HttpHeaders $ headers ) : bool { $ contentType = null ; $ headers -> tryGetFirst ( 'Content-Type' , $ contentType ) ; return preg_match ( "/application\/json/i" , $ contentType ) === 1 ; }
5639	public function paintGroupStart ( $ test_name , $ size ) { if ( ! isset ( $ this -> size ) ) { $ this -> size = $ size ; } if ( count ( $ this -> test_stack ) == 0 ) { $ this -> paintHeader ( $ test_name ) ; } $ this -> test_stack [ ] = $ test_name ; }
11609	public function actionDisconnect ( $ id ) { $ account = $ this -> finder -> findAccountById ( $ id ) ; if ( $ account === null ) { throw new NotFoundHttpException ; } if ( $ account -> user_id != \ Yii :: $ app -> user -> id ) { throw new ForbiddenHttpException ; } $ account -> delete ( ) ; return $ this -> redirect ( [ 'networks' ] ) ; }
6913	public function addShipment ( ShipmentInterface $ shipment ) { if ( ! $ this -> shipments -> contains ( $ shipment ) ) { $ this -> shipments -> add ( $ shipment ) ; } return $ this ; }
12979	protected function registerBehaviors ( EventManager $ evm , Configuration $ config ) { $ reader = new AnnotationReader ; if ( $ cache = $ config -> getMetadataCacheImpl ( ) ) { $ reader = new CachedReader ( $ reader , $ cache ) ; } foreach ( $ this -> getConfig ( 'behaviors' , array ( ) ) as $ behavior ) { if ( $ class = DiC :: resolve ( 'doctrine.behavior.' . $ behavior ) ) { $ class -> setAnnotationReader ( $ reader ) ; $ this -> configureBehavior ( $ behavior , $ class ) ; $ evm -> addEventSubscriber ( $ class ) ; } } if ( $ mapping = $ config -> getMetadataDriverImpl ( ) ) { $ type = 'registerMappingIntoDriverChainORM' ; if ( $ this -> getConfig ( 'behavior.superclass' , false ) ) { $ type = 'registerAbstractMappingIntoDriverChainORM' ; } DoctrineExtensions :: $ type ( $ mapping , $ reader ) ; } }
10028	function getContactsByExternalId ( $ externalId , $ standard_fields = array ( ) , $ custom_fields = array ( ) ) { $ queryParameters = array ( 'standard_field' => $ standard_fields ) ; $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , 'custom_field' , $ custom_fields ) ; return $ this -> get ( 'contacts/externalid/' . utf8_encode ( $ externalId ) , $ queryParameters ) ; }
6219	public function getPeriodEnd ( ) { if ( is_null ( $ this -> parsedPeriodEnd ) ) { $ this -> parsedPeriodEnd = strtotime ( $ this -> periodEnd ) ; } return $ this -> parsedPeriodEnd ; }
1162	private function fakeFileData ( $ data , $ attribute ) { if ( ! $ this -> validator -> hasRule ( $ attribute , [ 'Mimes' , 'Image' ] ) ) { return ; } $ newFiles = $ data ; $ newFiles [ $ attribute ] = $ this -> createUploadedFile ( ) ; $ this -> validator -> setData ( $ newFiles ) ; }
10214	public function setColor ( Color $ pValue ) { $ color = $ pValue -> getIsSupervisor ( ) ? $ pValue -> getSharedComponent ( ) : $ pValue ; if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getColor ( ) -> getStyleArray ( [ 'argb' => $ color -> getARGB ( ) ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> color = $ color ; } return $ this ; }
12271	public function getRoute ( ) : string { $ uri = $ _SERVER [ 'REQUEST_URI' ] ; if ( $ this -> uriBase != '/' ) { $ uri = str_replace ( $ this -> uriBase , '/' , $ uri ) ; } $ pos = strpos ( $ uri , '?' ) ; if ( $ pos !== false ) { $ uri = substr ( $ uri , 0 , $ pos ) ; } return $ uri ; }
6198	public function parseGets ( ) { $ request = preg_replace ( '!' . $ this -> uri . '(.*)$!i' , '$1' , $ _SERVER [ 'REQUEST_URI' ] ) ; if ( defined ( 'MOD_REWRITE' ) and MOD_REWRITE === true ) { if ( substr ( $ request , - 1 ) != '/' ) { $ request .= '/' ; } $ parseUrl = $ this -> parseUrl ( $ request ) ; $ this -> namespace = $ parseUrl [ 'v' ] [ 'namespace' ] ?? '' ; parse_str ( $ parseUrl [ 'sVars' ] , $ gets ) ; $ this -> controller = ! empty ( $ gets [ 'task' ] ) ? $ gets [ 'task' ] : $ this -> routeMap [ 'NAME_CONTROLLER' ] ; unset ( $ gets [ 'task' ] ) ; $ this -> action = ! empty ( $ gets [ 'action' ] ) ? $ gets [ 'action' ] : $ this -> routeMap [ 'NAME_METHOD' ] ; unset ( $ gets [ 'action' ] ) ; $ _GET = array_merge ( $ _GET , $ gets ) ; } else { $ this -> controller = ! empty ( $ _GET [ 'task' ] ) ? $ _GET [ 'task' ] : $ this -> routeMap [ 'NAME_CONTROLLER' ] ; $ this -> action = ! empty ( $ _GET [ 'action' ] ) ? $ _GET [ 'action' ] : $ this -> routeMap [ 'NAME_METHOD' ] ; } $ _GET [ 'task' ] = $ this -> controller ; $ _GET [ 'action' ] = $ this -> action ; }
1178	protected function getValidatorInstance ( array $ rules , array $ messages = [ ] , array $ customAttributes = [ ] ) { $ factory = $ this -> app -> make ( ValidationFactory :: class ) ; $ data = $ this -> getValidationData ( $ rules , $ customAttributes ) ; $ validator = $ factory -> make ( $ data , $ rules , $ messages , $ customAttributes ) ; $ validator -> addCustomAttributes ( $ customAttributes ) ; return $ validator ; }
197	public function setDownloadHeaders ( $ attachmentName , $ mimeType = null , $ inline = false , $ contentLength = null ) { $ headers = $ this -> getHeaders ( ) ; $ disposition = $ inline ? 'inline' : 'attachment' ; $ headers -> setDefault ( 'Pragma' , 'public' ) -> setDefault ( 'Accept-Ranges' , 'bytes' ) -> setDefault ( 'Expires' , '0' ) -> setDefault ( 'Cache-Control' , 'must-revalidate, post-check=0, pre-check=0' ) -> setDefault ( 'Content-Disposition' , $ this -> getDispositionHeaderValue ( $ disposition , $ attachmentName ) ) ; if ( $ mimeType !== null ) { $ headers -> setDefault ( 'Content-Type' , $ mimeType ) ; } if ( $ contentLength !== null ) { $ headers -> setDefault ( 'Content-Length' , $ contentLength ) ; } return $ this ; }
5521	public static function generate ( $ class , $ mock_class = false , $ methods = false ) { $ generator = new MockGenerator ( $ class , $ mock_class ) ; return $ generator -> generateSubclass ( $ methods ) ; }
1868	public function maintenanceCheck ( ) { $ this -> import ( BackendUser :: class , 'User' ) ; if ( ! $ this -> User -> hasAccess ( 'maintenance' , 'modules' ) ) { return '' ; } try { if ( System :: getContainer ( ) -> get ( 'lexik_maintenance.driver.factory' ) -> getDriver ( ) -> isExists ( ) ) { return '<p class="tl_error">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'maintenanceEnabled' ] . '</p>' ; } } catch ( \ Exception $ e ) { } return '' ; }
7261	protected function assertAdjustmentType ( Model \ AdjustmentInterface $ adjustment , string $ expected ) : void { if ( $ expected !== $ type = $ adjustment -> getType ( ) ) { throw new Exception \ InvalidArgumentException ( "Unexpected adjustment type '$type'." ) ; } }
9535	private function parseVariadicParameter ( & $ i , & $ results , $ closure , & $ closure_arguments , $ prefix , $ parameter ) { $ i ++ ; while ( isset ( $ this -> argv [ $ i ] ) && ( $ argument = $ this -> argv [ $ i ] ) != null && ! $ this -> prefixExists ( $ argument ) ) { $ closure_arguments [ ] = $ argument ; $ i ++ ; } $ parameterClosure = $ this -> getParameterClosure ( $ parameter ) ; if ( $ parameterClosure -> parent != null ) { if ( count ( $ closure_arguments ) > 0 ) { $ results [ $ parameterClosure -> parent -> parameterName ] = $ closure ( ... $ closure_arguments ) ; } else { $ this -> valid = false ; if ( $ this -> errorHandler != null ) { $ this -> errorHandler -> call ( $ this , $ parameterClosure , 'Missing argument for parameter closure.' ) ; } } } else { if ( count ( $ closure_arguments ) > 0 ) { $ results [ substr ( $ parameter , strlen ( $ prefix ) , strlen ( $ parameter ) - strlen ( $ prefix ) ) ] = $ closure ( ... $ closure_arguments ) ; } else { $ this -> valid = false ; if ( $ this -> errorHandler != null ) { $ this -> errorHandler -> call ( $ this , $ parameterClosure , 'Missing argument for parameter closure.' ) ; } } } }
12545	public function listen ( $ event , callable $ callback , $ priority = 100 ) { $ this -> event -> on ( $ event , $ callback , $ priority ) ; }
1501	public function matchesTo ( MediaTypeInterface $ mediaType ) : ? Encoding { return collect ( $ this -> stack ) -> first ( function ( Encoding $ encoding ) use ( $ mediaType ) { return $ encoding -> matchesTo ( $ mediaType ) ; } ) ; }
5611	public function paintMethodStart ( $ message ) { parent :: paintMethodStart ( $ message ) ; $ node = new TreemapNode ( 'Method' , $ message ) ; $ this -> _stack -> push ( $ node ) ; }
860	public function clearRange ( $ indexStart , $ indexEnd ) { for ( $ i = $ indexStart ; $ i <= $ indexEnd ; ++ $ i ) { $ this -> clearAt ( $ i ) ; } }
5202	public function open ( ) { try { $ additionalConnectionOptions = array ( ) ; foreach ( array ( 'connection_timeout' , 'read_write_timeout' , 'keepalive' , 'heartbeat' ) as $ option ) { if ( isset ( $ this -> $ option ) ) { $ additionalConnectionOptions [ $ option ] = $ this -> $ option ; } } $ this -> AMQPConnection = new AMQPSSLConnection ( $ this -> host , $ this -> port , $ this -> username , $ this -> password , $ this -> vhost , $ this -> ssl_context_options , $ additionalConnectionOptions ) ; $ this -> channel = $ this -> AMQPConnection -> channel ( ) ; $ this -> channel -> queue_declare ( $ this -> queue_name , false , false , false , false ) ; $ this -> channel -> exchange_declare ( $ this -> exchange , $ this -> exchange_type , false , true , false ) ; $ this -> channel -> queue_bind ( $ this -> queue_name , $ this -> exchange ) ; } catch ( Exception $ e ) { throw new Exception ( $ e ) ; } }
8595	public function getServiceStatus ( $ request ) { if ( ! ( $ request instanceof MarketplaceWebServiceSellers_Model_GetServiceStatusRequest ) ) { $ request = new MarketplaceWebServiceSellers_Model_GetServiceStatusRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetServiceStatus' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = MarketplaceWebServiceSellers_Model_GetServiceStatusResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
10299	private function writeDataLabels ( XMLWriter $ objWriter , Layout $ chartLayout = null ) { $ objWriter -> startElement ( 'c:dLbls' ) ; $ objWriter -> startElement ( 'c:showLegendKey' ) ; $ showLegendKey = ( empty ( $ chartLayout ) ) ? 0 : $ chartLayout -> getShowLegendKey ( ) ; $ objWriter -> writeAttribute ( 'val' , ( ( empty ( $ showLegendKey ) ) ? 0 : 1 ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:showVal' ) ; $ showVal = ( empty ( $ chartLayout ) ) ? 0 : $ chartLayout -> getShowVal ( ) ; $ objWriter -> writeAttribute ( 'val' , ( ( empty ( $ showVal ) ) ? 0 : 1 ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:showCatName' ) ; $ showCatName = ( empty ( $ chartLayout ) ) ? 0 : $ chartLayout -> getShowCatName ( ) ; $ objWriter -> writeAttribute ( 'val' , ( ( empty ( $ showCatName ) ) ? 0 : 1 ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:showSerName' ) ; $ showSerName = ( empty ( $ chartLayout ) ) ? 0 : $ chartLayout -> getShowSerName ( ) ; $ objWriter -> writeAttribute ( 'val' , ( ( empty ( $ showSerName ) ) ? 0 : 1 ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:showPercent' ) ; $ showPercent = ( empty ( $ chartLayout ) ) ? 0 : $ chartLayout -> getShowPercent ( ) ; $ objWriter -> writeAttribute ( 'val' , ( ( empty ( $ showPercent ) ) ? 0 : 1 ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:showBubbleSize' ) ; $ showBubbleSize = ( empty ( $ chartLayout ) ) ? 0 : $ chartLayout -> getShowBubbleSize ( ) ; $ objWriter -> writeAttribute ( 'val' , ( ( empty ( $ showBubbleSize ) ) ? 0 : 1 ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:showLeaderLines' ) ; $ showLeaderLines = ( empty ( $ chartLayout ) ) ? 1 : $ chartLayout -> getShowLeaderLines ( ) ; $ objWriter -> writeAttribute ( 'val' , ( ( empty ( $ showLeaderLines ) ) ? 0 : 1 ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; }
9766	function instanceOf ( string $ className ) : self { return $ this -> expect ( $ this -> target , isInstanceOf ( $ className ) ) ; }
8148	public function compile ( Twig_NodeInterface $ node ) { if ( null === $ this -> compiler ) { $ this -> compiler = new Twig_Compiler ( $ this ) ; } return $ this -> compiler -> compile ( $ node ) -> getSource ( ) ; }
829	private function isStringPartToken ( Token $ token ) { return $ token -> isGivenKind ( T_ENCAPSED_AND_WHITESPACE ) || $ token -> isGivenKind ( T_START_HEREDOC ) || '"' === $ token -> getContent ( ) || 'b"' === strtolower ( $ token -> getContent ( ) ) ; }
8898	public function update ( $ primary_value , $ data ) { $ data = $ this -> _do_pre_update ( $ data ) ; if ( $ data !== FALSE ) { $ result = $ this -> _database -> where ( $ this -> primary_key , $ primary_value ) -> set ( $ data ) -> update ( $ this -> _table ) ; $ this -> trigger ( 'after_update' , array ( $ data , $ result ) ) ; return $ result ; } else { return FALSE ; } }
775	public function resetSequence ( $ tableName , $ value = null ) { $ table = $ this -> db -> getTableSchema ( $ tableName ) ; if ( $ table !== null && $ table -> sequenceName !== null ) { $ tableName = $ this -> db -> quoteTableName ( $ tableName ) ; if ( $ value === null ) { $ key = reset ( $ table -> primaryKey ) ; $ value = $ this -> db -> createCommand ( "SELECT MAX(`$key`) FROM $tableName" ) -> queryScalar ( ) + 1 ; } else { $ value = ( int ) $ value ; } return "ALTER TABLE $tableName AUTO_INCREMENT=$value" ; } elseif ( $ table === null ) { throw new InvalidArgumentException ( "Table not found: $tableName" ) ; } throw new InvalidArgumentException ( "There is no sequence associated with table '$tableName'." ) ; }
8813	public function blade ( $ view , array $ data = [ ] , array $ mergeData = [ ] ) { if ( function_exists ( 'app' ) ) { $ this -> setContent ( app ( 'view' ) -> make ( $ view , $ data , $ mergeData ) -> render ( ) ) ; return $ this ; } return ; }
6514	public function invoke ( JobInterface $ job , ContextInterface $ context ) { $ jobType = $ this -> registry -> get ( $ job -> getType ( ) ) ; $ callableArray = $ jobType -> getCallable ( ) ; $ parameters = static :: resolveParameters ( $ jobType , $ context , $ job -> getParameters ( ) ) ; if ( is_array ( $ callableArray ) && $ callable = $ callableArray [ 0 ] ) { if ( $ callable instanceof JobAwareInterface ) { $ callable -> setJob ( $ job ) ; } if ( $ callable instanceof ManagerAwareInterface ) { $ callable -> setManager ( $ this -> manager ) ; } if ( $ callable instanceof ControllerAwareInterface ) { $ callable -> setController ( $ this -> controllerFactory -> create ( $ job ) ) ; } if ( $ callable instanceof LoggerAwareInterface && $ context -> has ( 'abc.logger' ) ) { $ callable -> setLogger ( $ context -> get ( 'abc.logger' ) ) ; } } return call_user_func_array ( $ callableArray , $ parameters ) ; }
12221	private function logException ( Exception $ exception ) { if ( in_array ( $ exception -> getStatusCode ( ) , $ this -> doNotLog ) ) { return ; } $ message = sprintf ( 'Uncaught exception of type %s thrown in file %s at line %s%s.' , get_class ( $ exception ) , $ exception -> getFile ( ) , $ exception -> getLine ( ) , $ exception -> getMessage ( ) ? sprintf ( ' with message "%s"' , $ exception -> getMessage ( ) ) : '' ) ; $ this -> container [ 'log' ] -> error ( $ message , array ( 'exception' => $ exception , 'Exception message' => $ message , 'Exception line' => $ exception -> getLine ( ) , 'Exception trace' => $ exception -> getTraceAsString ( ) , ) ) ; }
7230	public function getMarginPercent ( ) { if ( 0 < $ this -> margin && 0 < $ this -> revenue ) { return round ( $ this -> margin * 100 / $ this -> revenue , 1 ) ; } return 0 ; }
10253	public function getFullName ( $ gender = null ) { if ( empty ( $ gender ) ) { $ gender = $ this -> getGender ( ) ; } $ person_name = new Entities \ FullName ; $ person_name -> first = $ this -> getFirstName ( $ gender ) ; $ person_name -> middle = $ this -> getMiddleName ( $ gender ) ; $ person_name -> last = $ this -> getLastName ( ) ; $ person_name -> gender = $ gender ; return $ person_name ; }
9474	public function readOne ( ) { if ( $ this -> pos <= $ this -> max ) { $ value = $ this -> string [ $ this -> pos ] ; $ this -> pos += 1 ; } else { $ value = null ; } return $ value ; }
7679	function TbsMergeVarFields ( $ PrmVal , $ FldVal ) { $ this -> TBS -> meth_Merge_AutoVar ( $ PrmVal , true ) ; $ PrmVal = str_replace ( $ this -> TBS -> _ChrVal , $ FldVal , $ PrmVal ) ; return $ PrmVal ; }
6554	public function removeLineFromFile ( $ line , $ fh ) { $ lines = array ( ) ; $ found = false ; rewind ( $ fh ) ; while ( ( $ buffer = fgets ( $ fh , 4096 ) ) !== false ) { $ buffer = trim ( $ buffer ) ; if ( $ line === $ buffer ) { $ found = true ; continue ; } $ lines [ ] = $ buffer ; } if ( ! $ found ) { throw new LineNotFoundException ( sprintf ( 'Line %s can not be found' , $ line ) ) ; } ftruncate ( $ fh , 0 ) ; rewind ( $ fh ) ; foreach ( $ lines as $ ln ) { if ( fwrite ( $ fh , $ ln . PHP_EOL ) === false ) { throw new \ Exception ( sprintf ( 'Can\'t write %s to file' , $ ln ) ) ; } } }
1080	public static function parse ( $ source , array $ options = [ ] ) { $ sourceObj = $ source instanceof Source ? $ source : new Source ( $ source ) ; $ parser = new self ( $ sourceObj , $ options ) ; return $ parser -> parseDocument ( ) ; }
2776	public static function parseRepositoryName ( string $ repositoryUrl ) : string { $ scheme = parse_url ( $ repositoryUrl , PHP_URL_SCHEME ) ; if ( $ scheme === null ) { $ parts = explode ( '/' , $ repositoryUrl ) ; $ path = end ( $ parts ) ; } else { $ strpos = strpos ( $ repositoryUrl , ':' ) ; $ path = substr ( $ repositoryUrl , $ strpos + 1 ) ; } return basename ( $ path , '.git' ) ; }
5006	protected function normalizeListenerOptions ( $ name , $ options ) { $ normalized = [ 'service' => $ name , 'attach' => null , 'priority' => 1 , 'lazy' => false , ] ; if ( is_int ( $ name ) ) { $ normalized [ 'service' ] = $ options ; return $ normalized ; } if ( is_int ( $ options ) ) { $ normalized [ 'priority' ] = $ options ; return $ normalized ; } if ( is_string ( $ options ) ) { $ normalized [ 'attach' ] = [ [ 'event' => $ options , 'method' => null , 'priority' => 1 ] ] ; return $ normalized ; } if ( ArrayUtils :: isHashTable ( $ options ) ) { $ normalized [ 'attach' ] = $ this -> normalizeEventsSpec ( $ options ) ; if ( isset ( $ options [ 'lazy' ] ) ) { $ normalized [ 'lazy' ] = $ options [ 'lazy' ] ; } return $ normalized ; } $ event = $ method = null ; $ priority = 1 ; $ lazy = false ; foreach ( $ options as $ opt ) { if ( is_array ( $ opt ) ) { $ event = $ opt ; } elseif ( is_string ( $ opt ) ) { if ( null === $ event ) { $ event = [ $ opt ] ; } else { $ method = $ opt ; } } elseif ( is_int ( $ opt ) ) { $ priority = $ opt ; } elseif ( is_bool ( $ opt ) ) { $ lazy = $ opt ; } } foreach ( $ event as & $ eventSpec ) { $ eventSpec = [ 'event' => $ eventSpec , 'method' => $ method , 'priority' => $ priority ] ; } $ normalized [ 'attach' ] = $ event ; $ normalized [ 'lazy' ] = $ lazy ; return $ normalized ; }
11041	function store_leaf ( & $ elts , $ ptype , & $ i , $ cname , $ cvalue = NULL ) { $ isabsolute = FALSE ; if ( $ cname { 0 } == '/' && $ cname { 1 } == '/' ) { $ isabsolute = TRUE ; $ cname = substr ( $ cname , 2 ) ; } $ elements = explode ( '/' , $ cname ) ; if ( count ( $ elements ) == 1 && ! $ isabsolute ) { $ elts [ $ ptype . ':' . $ i . ':' . $ cname . ':' . $ cvalue ] = '' ; } else { if ( $ isabsolute ) { $ elts [ _ETS_TEMPLATE . ':' . $ i . '.1://' ] = $ this -> leaf_path_walk ( $ elements , 2 , $ ptype , $ i , $ cvalue ) ; } else { $ element1 = array_shift ( $ elements ) ; $ elts [ _ETS_TEMPLATE . ':' . $ i . '.1:' . $ element1 ] = $ this -> leaf_path_walk ( $ elements , 2 , $ ptype , $ i , $ cvalue ) ; } } }
6496	public function getCurrentId ( ) { $ args = arg ( ) ; return count ( $ args ) > 1 && $ this -> entityType ( ) === $ args [ 0 ] && $ args [ 1 ] > 0 ? ( int ) $ args [ 1 ] : 0 ; }
10331	public function load ( $ url ) { if ( ! is_string ( $ url ) ) { throw new \ InvalidArgumentException ( 'The url argument must be of type string' ) ; } $ this -> url = $ url ; set_error_handler ( function ( ) { throw new \ Exception ( func_get_arg ( 1 ) ) ; } ) ; $ errorReason = '' ; try { $ urlData = parse_url ( $ this -> url ) ; if ( isset ( $ urlData [ 'host' ] ) ) { $ hostname = $ urlData [ 'host' ] ; if ( substr ( $ hostname , 0 , 4 ) === 'www.' ) { $ hostname = substr ( $ hostname , 4 ) ; } foreach ( self :: $ providers as $ name => $ domains ) { $ done = false ; foreach ( $ domains as $ domain ) { if ( preg_match ( '/^' . str_replace ( [ '.' , '*' ] , [ '\.' , '.*' ] , $ domain ) . '$/' , $ hostname ) ) { include_once __DIR__ . DIRECTORY_SEPARATOR . 'VideoEmbed' . DIRECTORY_SEPARATOR . 'Internal' . DIRECTORY_SEPARATOR . 'Providers' . DIRECTORY_SEPARATOR . $ name . '.php' ; call_user_func ( [ '\IvoPetkov\VideoEmbed\Internal\Providers\\' . $ name , 'load' ] , $ this -> url , $ this ) ; $ done = true ; break ; } } if ( $ done ) { break ; } } } } catch ( \ Exception $ e ) { $ errorReason = $ e -> getMessage ( ) ; } restore_error_handler ( ) ; if ( $ this -> html === null ) { throw new \ Exception ( 'Cannot retrieve information about ' . $ this -> url . ' (reason: ' . ( isset ( $ errorReason { 0 } ) ? $ errorReason : 'unknown' ) . ')' ) ; } }
5455	public function addContent ( $ text ) { if ( isset ( $ this -> private_content_tag ) ) { $ this -> private_content_tag -> addContent ( $ text ) ; } else { $ this -> addContentToAllOpenTags ( $ text ) ; } return true ; }
4970	public function process ( array $ event ) { $ event = parent :: process ( $ event ) ; $ event [ 'uniqueId' ] = substr ( $ event [ 'extra' ] [ 'requestId' ] , 0 , 7 ) ; unset ( $ event [ 'extra' ] [ 'requestId' ] ) ; return $ event ; }
7481	public function setContent ( $ content ) { Argument :: i ( ) -> test ( 1 , 'string' ) ; try { $ this -> absolute ( ) ; } catch ( \ Eden \ Path \ Exception $ e ) { $ this -> touch ( ) ; } file_put_contents ( $ this -> data , $ content ) ; return $ this ; }
11315	public static function getNormalizedParameters ( array $ data ) { $ params = array ( ) ; $ keys = array_map ( 'PSX\Oauth\Consumer::urlEncode' , array_keys ( $ data ) ) ; $ values = array_map ( 'PSX\Oauth\Consumer::urlEncode' , array_values ( $ data ) ) ; $ data = array_combine ( $ keys , $ values ) ; uksort ( $ data , 'strnatcmp' ) ; foreach ( $ data as $ k => $ v ) { if ( $ k != 'oauth_signature' ) { $ params [ ] = $ k . '=' . $ v ; } } return implode ( '&' , $ params ) ; }
10461	public function initialize ( $ filePath , $ params ) { copy ( __DIR__ . '/../../../recipe/releaz.php' , $ filePath ) ; $ exampleFile = $ this -> getExamplePath ( ) ; $ projectFile = dirname ( $ filePath ) . '/' . $ this -> getExample ( ) ; copy ( $ exampleFile , $ projectFile ) ; $ this -> setParamsInExample ( $ projectFile , $ params ) ; }
2991	private function encodeRecord ( $ record , $ childName , & $ xml ) { foreach ( $ record as $ key => $ value ) { if ( $ value instanceof \ DateTime ) { if ( $ value -> format ( 'His' ) === '000000' ) { $ value = $ value -> format ( 'm/d/Y' ) ; } else { $ value = $ value -> format ( 'Y-m-d H:i:s' ) ; } } $ keyValue = $ xml -> addChild ( $ childName ) ; $ keyValue -> addAttribute ( 'val' , $ key ) ; if ( is_array ( $ value ) ) { $ this -> parseNestedValues ( $ value , $ keyValue ) ; } else { $ keyValue [ 0 ] = $ value ; } } }
5556	public function getUrlById ( $ id ) { foreach ( $ this -> frames as $ index => $ frame ) { if ( $ url = $ frame -> getUrlById ( $ id ) ) { if ( ! $ url -> gettarget ( ) ) { $ url -> setTarget ( $ this -> getPublicNameFromIndex ( $ index ) ) ; } return $ url ; } } return false ; }
7427	public function renderEmbed ( ) { if ( ! $ this -> isValid ( $ this -> source ) ) { throw new InvalidSourceExtensionException ( ) ; } return sprintf ( $ this -> embedDecorator , $ this -> width , $ this -> height , $ this -> source ) ; }
7061	private function setClasses ( array $ classes ) { if ( ! empty ( $ classes ) ) { $ this -> vars [ 'attr' ] [ 'class' ] = ' ' . trim ( implode ( ' ' , $ classes ) ) ; } else { unset ( $ this -> vars [ 'attr' ] [ 'class' ] ) ; } }
3736	protected function updateVariants ( $ item , $ activeLanguage , $ allIds , $ baseAttributes = false ) { foreach ( $ this -> getAttributes ( ) as $ strAttributeId => $ objAttribute ) { if ( ! $ item -> isAttributeSet ( $ objAttribute -> getColName ( ) ) ) { continue ; } if ( ! $ baseAttributes && $ item -> isVariant ( ) && ! ( $ objAttribute -> get ( 'isvariant' ) ) ) { continue ; } if ( $ item -> isVariantBase ( ) && ! ( $ objAttribute -> get ( 'isvariant' ) ) ) { $ arrIds = $ allIds ; } else { $ arrIds = array ( $ item -> get ( 'id' ) ) ; } $ this -> saveAttribute ( $ objAttribute , $ arrIds , $ item -> get ( $ strAttributeId ) , $ activeLanguage ) ; } }
5454	protected function hasNamedTagOnOpenTagStack ( $ name ) { return isset ( $ this -> tags [ $ name ] ) && ( count ( $ this -> tags [ $ name ] ) > 0 ) ; }
6626	public function processRequest ( Request $ request , Controller $ controller , array $ requestChain = null ) { $ reflectionController = $ this -> getControllerReflector ( ) -> reflectController ( $ controller ) ; if ( is_null ( $ requestChain ) ) { $ requestChain = $ request -> getRequestChain ( ) ; } $ nextLink = array_shift ( $ requestChain ) ; if ( $ nextLink ) { if ( $ reflectionController -> hasChildController ( $ nextLink ) ) { return $ this -> processRequest ( $ request , $ reflectionController -> getChildController ( $ nextLink ) , $ requestChain ) ; } if ( $ reflectionController -> hasEndpoint ( $ request -> getMethod ( ) , $ nextLink ) ) { $ data = $ reflectionController -> getEndpointResult ( $ request -> getMethod ( ) , $ nextLink , $ request ) ; $ this -> setStatus ( $ reflectionController -> getStatus ( ) ) ; return $ data ; } $ message = "Could not find controller or endpoint matching '$nextLink'" ; throw new Exception ( $ message , 404 ) ; } if ( $ reflectionController -> hasEndpoint ( $ request -> getMethod ( ) , 'index' ) ) { $ data = $ reflectionController -> getEndpointResult ( $ request -> getMethod ( ) , 'index' , $ request ) ; $ this -> setStatus ( $ reflectionController -> getStatus ( ) ) ; return $ data ; } return $ reflectionController -> getDocumentation ( ) ; }
11032	protected function supports ( $ attribute , $ subject ) { if ( ! in_array ( $ attribute , array ( self :: MENU , self :: PERMISO ) ) ) { return false ; } if ( $ attribute == self :: MENU && ! is_null ( $ subject ) && ! $ subject instanceof Menu ) { return false ; } return true ; }
8370	public function perform ( array $ args = [ ] ) : int { $ this -> args = $ args ; unset ( $ this -> args [ 'messages' ] ) ; $ transport = new Swift_SmtpTransport ( $ args [ 'smtp' ] [ 'host' ] , $ args [ 'smtp' ] [ 'port' ] ) ; $ transport -> setUsername ( $ args [ 'smtp' ] [ 'username' ] ) ; $ transport -> setPassword ( $ args [ 'smtp' ] [ 'password' ] ) ; $ this -> messages = $ args [ 'messages' ] ; foreach ( $ messages as & $ message ) { if ( $ shutdown ) { break ; } $ mailer = new Swift_Mailer ( $ transport ) ; $ m = ( new Swift_Message ( $ message [ 'subject' ] ) ) -> setFrom ( [ $ message [ 'from' ] [ 'email' ] => $ message [ 'from' ] [ 'email' ] ] ) -> setTo ( [ $ message [ 'to' ] [ 'email' ] => $ message [ 'to' ] [ 'name' ] ] ) -> setBody ( $ message [ 'message' ] ) ; $ message [ 'sent' ] = ( $ mailer -> send ( $ m ) === 1 ) ; } return 0 ; }
864	private function registerFoundToken ( $ token ) { $ tokenKind = $ token instanceof Token ? ( $ token -> isArray ( ) ? $ token -> getId ( ) : $ token -> getContent ( ) ) : ( \ is_array ( $ token ) ? $ token [ 0 ] : $ token ) ; if ( ! isset ( $ this -> foundTokenKinds [ $ tokenKind ] ) ) { $ this -> foundTokenKinds [ $ tokenKind ] = 0 ; } ++ $ this -> foundTokenKinds [ $ tokenKind ] ; }
1331	public function queryToOne ( $ relation , EncodingParametersInterface $ parameters ) { return $ this -> queryOne ( $ relation -> newQuery ( ) , $ this -> getQueryParameters ( $ parameters ) ) ; }
11454	public function autoload ( ) { if ( self :: $ loaded ) { return ; } if ( is_array ( $ this -> load ) ) { foreach ( $ this -> load as $ k => $ load ) { $ this -> load ( $ load ) ; } } if ( is_array ( $ this -> loadUri ) ) { foreach ( $ this -> loadUri as $ k => $ load ) { $ this -> load ( [ $ load => function ( $ query ) { $ query -> select ( 'id' , $ query -> getForeignKey ( ) ) ; } ] ) ; } } self :: $ loaded = true ; }
2222	public static function countPublishedFromToByPids ( $ intFrom , $ intTo , $ arrPids , array $ arrOptions = array ( ) ) { if ( empty ( $ arrPids ) || ! \ is_array ( $ arrPids ) ) { return null ; } $ t = static :: $ strTable ; $ arrColumns = array ( "$t.date>=? AND $t.date<=? AND $t.pid IN(" . implode ( ',' , array_map ( '\intval' , $ arrPids ) ) . ")" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } return static :: countBy ( $ arrColumns , array ( $ intFrom , $ intTo ) , $ arrOptions ) ; }
1334	protected function fillRelated ( $ record , ResourceObject $ resource , EncodingParametersInterface $ parameters ) { $ relationships = $ resource -> getRelationships ( ) ; $ changed = false ; foreach ( $ relationships as $ field => $ value ) { if ( $ this -> isNotFillable ( $ field , $ record ) ) { continue ; } if ( ! $ this -> isRelation ( $ field ) ) { continue ; } $ relation = $ this -> getRelated ( $ field ) ; if ( $ this -> requiresPrimaryRecordPersistence ( $ relation ) ) { $ relation -> update ( $ record , $ value , $ parameters ) ; $ changed = true ; } } if ( $ changed ) { $ record -> refresh ( ) ; } }
6020	public function removeMediaFromDeploymentSite ( $ id , $ mediaIds ) { $ parameters = [ 'query' => [ 'mediaIds' => $ mediaIds ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> delete ( 'v1/deployment/' . $ id . '/media' , $ parameters ) ; return $ result ; }
104	public function isRateLimited ( array $ headers ) { foreach ( $ headers as $ header ) { if ( preg_match ( '{^X-RateLimit-Remaining: *0$}i' , trim ( $ header ) ) ) { return true ; } } return false ; }
1890	public function grantsAccess ( ) : bool { $ content = array_filter ( file ( ( string ) $ this -> file ) ) ; foreach ( $ content as $ line ) { if ( $ this -> hasRequireGranted ( $ line ) ) { return true ; } } return false ; }
1346	public function isDeleteResource ( ) : bool { return $ this -> isMethod ( 'delete' ) && $ this -> getRoute ( ) -> isResource ( ) && $ this -> getRoute ( ) -> isNotRelationship ( ) ; }
923	private function ensureAreSeparate ( DocBlock $ doc , Annotation $ first , Annotation $ second ) { $ pos = $ first -> getEnd ( ) ; $ final = $ second -> getStart ( ) - 1 ; if ( $ pos === $ final ) { $ doc -> getLine ( $ pos ) -> addBlank ( ) ; return ; } for ( $ pos = $ pos + 1 ; $ pos < $ final ; ++ $ pos ) { $ doc -> getLine ( $ pos ) -> remove ( ) ; } }
9339	public function get ( $ key , $ default = null ) { $ keys = array_filter ( explode ( '.' , $ key ) ) ; $ length = count ( $ keys ) ; $ data = $ this -> data ; for ( $ i = 0 ; $ i < $ length ; $ i ++ ) { $ index = $ keys [ $ i ] ; $ data = & $ data [ $ index ] ; } return $ data !== null ? $ data : $ default ; }
4779	public function removeWidget ( string $ widgetId ) { if ( isset ( $ this -> widgets [ $ widgetId ] ) ) { unset ( $ this -> widgets [ $ widgetId ] ) ; } return $ this ; }
9488	public function getPages ( ) { if ( $ this -> getPageRange ( ) > $ this -> getPagesCount ( ) ) { $ this -> setPageRange ( $ this -> getPagesCount ( ) ) ; } $ delta = ceil ( $ this -> getPageRange ( ) / 2 ) ; if ( $ this -> getCurrentPageNumber ( ) - $ delta > $ this -> getPagesCount ( ) - $ this -> getPageRange ( ) ) { $ pages = range ( $ this -> getPagesCount ( ) - $ this -> getPageRange ( ) + 1 , $ this -> getPagesCount ( ) ) ; } else { if ( $ this -> getCurrentPageNumber ( ) - $ delta < 0 ) { $ delta = $ this -> getCurrentPageNumber ( ) ; } $ offset = $ this -> getCurrentPageNumber ( ) - $ delta ; $ pages = range ( $ offset + 1 , $ offset + $ this -> getPageRange ( ) ) ; } return $ pages ; }
7974	public function getSender ( $ domain , $ sender ) { if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; if ( ! $ sender ) throw new BadMethodCallException ( 'Parameter $sender is missing.' ) ; $ sender = urlencode ( $ sender ) ; try { $ r = $ this -> get ( 'sms/' . $ domain . '/senders/' . $ sender ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new SmsException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
6573	protected static function examine ( $ part , array & $ array , $ path_relative , $ allow_escape = false ) { if ( $ part === '.' ) { return ; } if ( $ part !== '..' ) { $ array [ ] = $ part ; return ; } $ last = end ( $ array ) ; if ( $ last === '..' ) { $ array [ ] = $ part ; return ; } if ( $ last !== false ) { array_pop ( $ array ) ; return ; } if ( ! $ path_relative ) { return ; } if ( ! $ allow_escape ) throw new \ UnexpectedValueException ( 'Attempt to traverse outside the root directory.' ) ; $ array [ ] = $ part ; }
2628	protected function getOptions ( $ label = false ) { $ options = [ ] ; foreach ( $ this -> _storeManager -> getStores ( ) as $ store ) { $ options [ ] = [ 'value' => $ store -> getId ( ) , 'label' => $ store -> getName ( ) ] ; } if ( $ label ) { array_unshift ( $ options , [ 'value' => '' , 'label' => $ label ] ) ; } return $ options ; }
3118	public function removeCatValue ( $ testSessionId , $ assessmentSectionId , $ key ) { $ extendedState = $ this -> getExtendedState ( $ testSessionId ) ; $ extendedState -> removeCatValue ( $ assessmentSectionId , $ key ) ; $ extendedState -> save ( ) ; }
10480	private function isTrackedFieldModified ( AbstractDiffItem $ item , ExtractionDescriptorInterface $ relation ) { if ( ! $ item instanceof UpdateDiffItem ) { throw new \ InvalidArgumentException ( 'Wrong diff item type. Got: ' . get_class ( $ item ) ) ; } $ trackedFields = $ relation -> getUpdateFields ( ) ; if ( empty ( $ trackedFields ) ) { return true ; } $ itemRow = $ item -> getItem ( ) ; $ oldItemRow = $ item -> getOldItem ( ) ; foreach ( array_keys ( $ trackedFields ) as $ key ) { if ( array_key_exists ( $ key , $ itemRow ) && $ itemRow [ $ key ] !== $ oldItemRow [ $ key ] ) { return true ; } } return false ; }
1619	public function buildAll ( $ query ) { $ modelClass = $ query -> modelClass ; $ key = $ this -> quoteValue ( $ modelClass :: keyPrefix ( ) . ':a:' ) ; return $ this -> build ( $ query , "n=n+1 pks[n]=redis.call('HGETALL',$key .. pk)" , 'pks' ) ; }
3230	static function loadFromJson ( $ jsonObj ) { $ authHost = null ; if ( array_key_exists ( 'auth_host' , $ jsonObj ) ) { $ authHost = $ jsonObj [ "auth_host" ] ; if ( ! is_string ( $ authHost ) ) { throw new HostLoadException ( "Optional field \"auth_host\" must be a string" ) ; } } $ hostSuffix = null ; if ( array_key_exists ( 'host_suffix' , $ jsonObj ) ) { $ hostSuffix = $ jsonObj [ "host_suffix" ] ; if ( ! is_string ( $ hostSuffix ) ) { throw new HostLoadException ( "Optional field \"host_suffix\" must be a string" ) ; } } if ( $ authHost === null && $ hostSuffix === null ) return null ; if ( $ authHost === null ) { throw new HostLoadException ( "Can't provide \"host_suffix\" without providing \"auth_host\"." ) ; } if ( $ hostSuffix === null ) { throw new HostLoadException ( "Can't provide \"auth_host\" without providing \"host_suffix\"." ) ; } $ api = "api" . $ hostSuffix ; $ content = "content" . $ hostSuffix ; $ web = $ authHost ; return new Host ( $ api , $ content , $ web ) ; }
5895	public function listImageTemplates ( CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/templates/images' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new ImageTemplate ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
8065	protected function getNextFreeWorker ( ) { $ sec = 0 ; while ( TRUE ) { $ this -> collectWorkerResults ( $ sec ) ; $ freeProcess = $ this -> workerProcesses -> takeFreeProcess ( ) ; if ( $ freeProcess !== NULL ) { return $ freeProcess ; } $ sec = $ this -> child_timeout_sec ; if ( $ this -> workerPoolSize <= 0 ) { throw new WorkerPoolException ( 'All workers were gone.' ) ; } } return NULL ; }
4742	public function isReviewOptInValidationRequired ( ) { return ( bool ) \ OxidEsales \ Eshop \ Core \ Registry :: getConfig ( ) -> getConfigParam ( self :: REVIEW_OPTIN_PARAM ) ; }
2073	public function getAllTables ( ) { $ arrTables = $ this -> Database -> listTables ( ) ; $ arrViews = Contao \ System :: getContainer ( ) -> get ( 'database_connection' ) -> getSchemaManager ( ) -> listViews ( ) ; if ( ! empty ( $ arrViews ) ) { $ arrTables = array_merge ( $ arrTables , array_keys ( $ arrViews ) ) ; natsort ( $ arrTables ) ; } return array_values ( $ arrTables ) ; }
10138	private function writePageLayoutView ( ) { $ record = 0x088B ; $ length = 0x0010 ; $ rt = 0x088B ; $ grbitFrt = 0x0000 ; $ reserved = 0x0000000000000000 ; $ wScalvePLV = $ this -> phpSheet -> getSheetView ( ) -> getZoomScale ( ) ; if ( $ this -> phpSheet -> getSheetView ( ) -> getView ( ) == SheetView :: SHEETVIEW_PAGE_LAYOUT ) { $ fPageLayoutView = 1 ; } else { $ fPageLayoutView = 0 ; } $ fRulerVisible = 0 ; $ fWhitespaceHidden = 0 ; $ grbit = $ fPageLayoutView ; $ grbit |= $ fRulerVisible << 1 ; $ grbit |= $ fWhitespaceHidden << 3 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vvVVvv' , $ rt , $ grbitFrt , 0x00000000 , 0x00000000 , $ wScalvePLV , $ grbit ) ; $ this -> append ( $ header . $ data ) ; }
9047	public function getType ( $ data_type = 'metadata' , $ type = 'text' ) { if ( isset ( $ this -> types [ $ data_type ] [ $ type ] ) ) { return $ this -> types [ $ data_type ] [ $ type ] ; } return false ; }
10315	function getUniqueClicksCount ( $ fromDate = null , $ toDate = null , $ mailingIds = null , $ contactIds = null , $ contactEmails = null , $ contactExternalIds = null , $ excludeAnonymousClicks = false ) { $ params = $ this -> createCountQueryParameters ( $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , $ mailingIds , null ) ; if ( isset ( $ excludeAnonymousClicks ) ) $ params [ 'exclude_anonymous_clicks' ] = ( $ excludeAnonymousClicks == true ) ? "true" : "false" ; return $ this -> get ( 'reports/clicks/unique/count' , $ params ) ; }
4599	public function kernelRequest ( GetResponseEvent $ event ) { $ request = $ event -> getRequest ( ) ; $ entity = $ request -> attributes -> get ( '_api_resource_class' ) ; if ( null === $ entity ) { return ; } if ( ! in_array ( Translatable :: class , class_implements ( $ entity ) , true ) ) { return ; } $ model = $ request -> attributes -> get ( 'data' ) ; if ( 'post' === $ request -> attributes -> get ( '_api_collection_operation_name' ) ) { $ this -> translationService -> transfer ( $ model ) ; } else if ( 'put' === $ request -> attributes -> get ( '_api_item_operation_name' ) ) { $ this -> translationService -> transfer ( $ model ) ; $ this -> translationService -> translate ( $ model ) ; } }
9319	public function markdown ( $ contents ) { $ contents = app ( 'markdown' ) -> convertToHtml ( $ contents ) ; if ( ! is_null ( $ this -> cachePath ) ) { $ this -> files -> put ( $ this -> getCompiledPath ( $ this -> getPath ( ) ) , $ contents ) ; } return $ contents ; }
5039	public function set ( $ key , ImageInterface $ image , $ check = true ) { $ images = $ this -> getImages ( ) ; if ( $ check && ( $ img = $ this -> get ( $ key ) ) ) { $ images -> removeElement ( $ img ) ; } $ image -> setBelongsTo ( $ this -> id ) ; $ image -> setKey ( $ key ) ; $ images -> add ( $ image ) ; return $ this ; }
6658	public function jsonSerialize ( ) { $ serialized = [ 'message' => $ this -> getPublicMessage ( ) , 'code' => $ this -> getCode ( ) , ] ; if ( $ this -> getPrevious ( ) instanceof $ this ) { $ previous = $ this -> getPrevious ( ) ; $ serialized [ 'previous' ] = $ previous -> jsonSerialize ( ) ; } return $ serialized ; }
2349	public function renameTo ( $ strNewName ) { $ strParent = \ dirname ( $ strNewName ) ; if ( ! is_dir ( $ this -> strRootDir . '/' . $ strParent ) ) { new Folder ( $ strParent ) ; } $ return = $ this -> Files -> rename ( $ this -> strFile , $ strNewName ) ; $ syncSource = Dbafs :: shouldBeSynchronized ( $ this -> strFile ) ; $ syncTarget = Dbafs :: shouldBeSynchronized ( $ strNewName ) ; if ( $ syncSource && $ syncTarget ) { $ this -> objModel = Dbafs :: moveResource ( $ this -> strFile , $ strNewName ) ; } elseif ( $ syncSource ) { $ this -> objModel = Dbafs :: deleteResource ( $ this -> strFile ) ; } elseif ( $ syncTarget ) { $ this -> objModel = Dbafs :: addResource ( $ strNewName ) ; } if ( $ return != false ) { $ this -> strFile = $ strNewName ; $ this -> arrImageSize = array ( ) ; $ this -> arrPathinfo = array ( ) ; } return $ return ; }
12628	public function register ( Application $ app ) { if ( is_null ( $ this -> filename ) ) { throw new \ RuntimeException ( 'You must provide a valid config filename' ) ; } if ( ! file_exists ( $ this -> filename ) ) { throw new \ RuntimeException ( sprintf ( 'Config path \'%s\' is not valid' , $ this -> filename ) ) ; } if ( ! is_readable ( $ this -> filename ) ) { throw new \ RuntimeException ( sprintf ( 'Config path \'%s\' is not readable' , $ this -> filename ) ) ; } $ parser = new YamlParser ( ) ; $ config = $ parser -> parse ( file_get_contents ( $ this -> filename ) ) ; if ( is_array ( $ config ) && ! empty ( $ config ) ) { if ( isset ( $ app [ 'config' ] ) && is_array ( $ app [ 'config' ] ) ) { $ config = array_replace_recursive ( $ app [ 'config' ] , $ config ) ; } $ app [ 'config' ] = $ config ; } }
10585	public static function createFile ( string $ name , int $ maxAttempts = 10 ) : entity \ FileEntity { $ tmpdir = static :: getDir ( ) ; $ name = \ sndsgd \ Fs :: sanitizeName ( $ name ) ; $ pos = strrpos ( $ name , "." ) ; if ( $ pos === false ) { $ extension = "" ; } else { $ extension = substr ( $ name , $ pos ) ; $ name = substr ( $ name , 0 , $ pos ) ; } $ attempts = 1 ; do { if ( $ attempts > $ maxAttempts ) { throw new \ RuntimeException ( "failed to create temp file; " . "reached max number ($maxAttempts) of attempts" ) ; } $ rand = \ sndsgd \ Str :: random ( 10 ) ; $ path = "$tmpdir/$name-$rand$extension" ; $ attempts ++ ; } while ( file_exists ( $ path ) ) ; touch ( $ path ) ; $ file = new entity \ FileEntity ( $ path ) ; static :: registerEntity ( $ file ) ; return $ file ; }
2020	public function getSearchablePages ( $ arrPages , $ intRoot = 0 , $ blnIsSitemap = false ) { $ arrRoot = array ( ) ; if ( $ intRoot > 0 ) { $ arrRoot = $ this -> Database -> getChildRecords ( $ intRoot , 'tl_page' ) ; } $ arrProcessed = array ( ) ; $ time = Date :: floorToMinute ( ) ; $ objFaq = FaqCategoryModel :: findAll ( ) ; if ( $ objFaq !== null ) { while ( $ objFaq -> next ( ) ) { if ( ! $ objFaq -> jumpTo ) { continue ; } if ( ! empty ( $ arrRoot ) && ! \ in_array ( $ objFaq -> jumpTo , $ arrRoot ) ) { continue ; } if ( ! isset ( $ arrProcessed [ $ objFaq -> jumpTo ] ) ) { $ objParent = PageModel :: findWithDetails ( $ objFaq -> jumpTo ) ; if ( $ objParent === null ) { continue ; } if ( ! $ objParent -> published || ( $ objParent -> start != '' && $ objParent -> start > $ time ) || ( $ objParent -> stop != '' && $ objParent -> stop <= ( $ time + 60 ) ) ) { continue ; } if ( $ blnIsSitemap ) { if ( $ objParent -> protected ) { continue ; } if ( $ objParent -> sitemap == 'map_never' ) { continue ; } } $ arrProcessed [ $ objFaq -> jumpTo ] = $ objParent -> getAbsoluteUrl ( Config :: get ( 'useAutoItem' ) ? '/%s' : '/items/%s' ) ; } $ strUrl = $ arrProcessed [ $ objFaq -> jumpTo ] ; $ objItems = FaqModel :: findPublishedByPid ( $ objFaq -> id ) ; if ( $ objItems !== null ) { while ( $ objItems -> next ( ) ) { $ arrPages [ ] = sprintf ( preg_replace ( '/%(?!s)/' , '%%' , $ strUrl ) , ( $ objItems -> alias ? : $ objItems -> id ) ) ; } } } } return $ arrPages ; }
634	public function createTable ( $ table , $ columns , $ options = null ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> createTable ( $ table , $ columns , $ options ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; }
11547	public function addGroup ( Group $ group ) { $ group -> setService ( $ this ) ; $ this -> groups [ $ group -> getName ( ) ] = $ group ; }
8580	public function setPromotionAdjustmentList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'PromotionAdjustmentList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
4149	protected function buildMultipart ( $ mimeBoundary , $ filename ) { $ binary = $ this -> getBinaryFile ( $ filename ) ; $ details = pathinfo ( $ filename ) ; $ type = $ this -> supportedMimes ( $ details [ 'extension' ] ) ; $ data = '--' . $ mimeBoundary . static :: EOL ; $ data .= 'Content-Disposition: form-data; name="media"; filename="' . $ details [ 'basename' ] . '"' . static :: EOL ; $ data .= 'Content-Type: application/octet-stream' . static :: EOL . static :: EOL ; $ data .= $ binary . static :: EOL ; $ data .= '--' . $ mimeBoundary . '--' . static :: EOL . static :: EOL ; unset ( $ mimeBoundary , $ filename , $ binary , $ details , $ type ) ; return $ data ; }
4273	public function stream_eof ( ) { if ( ! $ this -> handle ) { return false ; } self :: restorePrev ( ) ; $ result = \ feof ( $ this -> handle ) ; self :: register ( ) ; return $ result ; }
9518	public function getUsage ( $ withEncapsulation = true , $ withAliases = true ) { $ usage = '' ; if ( $ withEncapsulation ) { $ usage = ( $ this -> required ? '' : '[' ) ; } $ aliases = ( $ withAliases ? $ this -> getAliasUsage ( ) : '' ) ; $ usage .= $ this -> prefix . $ this -> parameterName . $ aliases . ' ' ; $ usage .= $ this -> getPropertiesAsString ( ) ; return $ usage . ( $ withEncapsulation ? ( $ this -> required ? '' : ']' ) : '' ) ; }
8574	public function setGetMyPriceForSKUResult ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'GetMyPriceForSKUResult' ] [ 'FieldValue' ] = $ value ; return $ this ; }
3600	public function createHttpResponseFromException ( \ Exception $ exception ) { $ httpResponse = HttpResponse :: create ( ) ; $ json = [ ] ; $ json [ 'jsonrpc' ] = '2.0' ; $ json [ 'error' ] = [ ] ; if ( $ exception instanceof Exceptions \ ErrorException ) { $ json [ 'error' ] [ 'code' ] = $ exception -> getCode ( ) ; $ json [ 'error' ] [ 'message' ] = $ exception -> getMessage ( ) ; if ( $ exception -> getData ( ) ) { $ json [ 'error' ] [ 'data' ] = $ exception -> getData ( ) ; } $ json [ 'id' ] = $ exception -> getId ( ) ; } else { $ json [ 'error' ] [ 'code' ] = - 32603 ; $ json [ 'error' ] [ 'message' ] = 'Internal error' ; $ json [ 'id' ] = null ; } $ httpResponse -> headers -> set ( 'Content-Type' , 'application/json' ) ; $ httpResponse -> setContent ( \ json_encode ( $ json ) ) ; $ httpResponse -> setStatusCode ( $ this -> errorCode ) ; $ this -> dispatch ( Event \ HttpResponseEvent :: EVENT , new Event \ HttpResponseEvent ( $ httpResponse ) ) ; return $ httpResponse ; }
2811	public function getEvents ( ) { if ( $ this -> events === null ) { $ this -> events = array ( ) ; foreach ( $ this -> getTimers ( ) as $ timerName => $ timer ) { if ( strpos ( $ timerName , 'DISPATCH EVENT:' ) === 0 ) { $ this -> events [ str_replace ( 'DISPATCH EVENT:' , '' , $ timerName ) ] = array ( 'name' => str_replace ( 'DISPATCH EVENT:' , '' , $ timerName ) , 'count' => $ timer [ 'count' ] , 'sum' => round ( $ timer [ 'sum' ] * 1000 , 2 ) , 'mem_diff' => $ timer [ 'realmem' ] / pow ( 1024 , 2 ) , ) ; } } } return $ this -> events ; }
2406	public static function generateStyleTag ( $ href , $ media = null , $ mtime = false ) { if ( $ mtime === null && ! preg_match ( '@^https?://@' , $ href ) ) { $ container = System :: getContainer ( ) ; $ rootDir = $ container -> getParameter ( 'kernel.project_dir' ) ; if ( file_exists ( $ rootDir . '/' . $ href ) ) { $ mtime = filemtime ( $ rootDir . '/' . $ href ) ; } else { $ webDir = StringUtil :: stripRootDir ( $ container -> getParameter ( 'contao.web_dir' ) ) ; if ( file_exists ( $ rootDir . '/' . $ webDir . '/' . $ href ) ) { $ mtime = filemtime ( $ rootDir . '/' . $ webDir . '/' . $ href ) ; } } } if ( $ mtime ) { $ href .= '?v=' . substr ( md5 ( $ mtime ) , 0 , 8 ) ; } return '<link rel="stylesheet" href="' . $ href . '"' . ( ( $ media && $ media != 'all' ) ? ' media="' . $ media . '"' : '' ) . '>' ; }
6131	protected function getSuffixIconServer ( ) { $ html = "" ; if ( $ this -> currObj [ "virtualserver_icon_id" ] ) { if ( ! $ this -> currObj -> iconIsLocal ( "virtualserver_icon_id" ) && $ this -> ftclient ) { if ( ! isset ( $ this -> cacheIcon [ $ this -> currObj [ "virtualserver_icon_id" ] ] ) ) { $ download = $ this -> currObj -> transferInitDownload ( rand ( 0x0000 , 0xFFFF ) , 0 , $ this -> currObj -> iconGetName ( "virtualserver_icon_id" ) ) ; if ( $ this -> ftclient == "data:image" ) { $ download = TeamSpeak3 :: factory ( "filetransfer://" . $ download [ "host" ] . ":" . $ download [ "port" ] ) -> download ( $ download [ "ftkey" ] , $ download [ "size" ] ) ; } $ this -> cacheIcon [ $ this -> currObj [ "virtualserver_icon_id" ] ] = $ download ; } else { $ download = $ this -> cacheIcon [ $ this -> currObj [ "virtualserver_icon_id" ] ] ; } if ( $ this -> ftclient == "data:image" ) { $ html .= $ this -> getImage ( "data:" . Convert :: imageMimeType ( $ download ) . ";base64," . base64_encode ( $ download ) , "Server Icon" , null , false ) ; } else { $ html .= $ this -> getImage ( $ this -> ftclient . "?ftdata=" . base64_encode ( serialize ( $ download ) ) , "Server Icon" , null , false ) ; } } elseif ( in_array ( $ this -> currObj [ "virtualserver_icon_id" ] , $ this -> cachedIcons ) ) { $ html .= $ this -> getImage ( "group_icon_" . $ this -> currObj [ "virtualserver_icon_id" ] . ".png" , "Server Icon" ) ; } } return $ html ; }
8982	private function filter ( $ configurations , array $ criteria ) { $ result = array ( ) ; foreach ( $ configurations as $ configuration ) { if ( ConfigurationFilterUtil :: matches ( $ configuration , $ criteria ) ) { $ result [ ] = $ configuration ; } } return $ result ; }
2662	public function getBackends ( $ version ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/backend' ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: GET ) ; return $ result ; }
814	private function getNewLineIndex ( $ index , Tokens $ tokens ) { $ lineEnding = $ this -> whitespacesConfig -> getLineEnding ( ) ; for ( $ index , $ count = \ count ( $ tokens ) ; $ index < $ count ; ++ $ index ) { if ( false !== strstr ( $ tokens [ $ index ] -> getContent ( ) , $ lineEnding ) ) { return $ index ; } } return $ index ; }
3147	public function check ( RunnerServiceContext $ context ) { $ state = $ context -> getTestSession ( ) -> getState ( ) ; if ( $ state == AssessmentTestSessionState :: CLOSED ) { throw new QtiRunnerClosedException ( ) ; } return true ; }
11926	public function setAutoloadDir ( $ dir ) { if ( ! is_string ( $ dir ) || empty ( $ dir ) ) { throw new InvalidArgumentException ( sprintf ( 'Invalid directory for autoload of configuration provided; ' . 'must be a non-empty string, "%s" received.' , is_object ( $ dir ) ? get_class ( $ dir ) : gettype ( $ dir ) ) ) ; } $ dir = Normalizer :: path ( $ dir ) ; if ( ! file_exists ( $ dir ) || ! is_dir ( $ dir ) ) { throw new InvalidArgumentException ( sprintf ( 'The directory "%s", specified for autoload of configurations, ' . 'does not exists.' , $ dir ) ) ; } $ this -> autoloadDir = $ dir ; }
5917	public function updateSetting ( $ key , $ value ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'value' => $ value ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> put ( 'v1/accounts/settings/' . $ key . '' , $ parameters ) ; return $ result ; }
11025	public function __isset ( $ name ) : bool { if ( strrpos ( $ name , 'facet_' , - strlen ( $ name ) ) !== false ) { return true ; } return false ; }
8594	public function listOrdersByNextToken ( $ request ) { if ( ! ( $ request instanceof MarketplaceWebServiceOrders_Model_ListOrdersByNextTokenRequest ) ) { $ request = new MarketplaceWebServiceOrders_Model_ListOrdersByNextTokenRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListOrdersByNextToken' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = MarketplaceWebServiceOrders_Model_ListOrdersByNextTokenResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
12493	public static function groupBy ( $ field ) { if ( ! ( gettype ( $ field ) == "string" || $ field instanceof Key || $ field instanceof Raw ) ) { throw new ClusterpointException ( "\"->group()\" function: passed field selector is not in valid format." , 9002 ) ; } if ( $ field instanceof Key ) { $ field = self :: field ( "{$field}" ) ; } return "{$field}" ; }
6681	public function afterAction ( $ action , $ result ) { $ result = parent :: afterAction ( $ action , $ result ) ; $ this -> setSecurityHeaders ( ) ; if ( extension_loaded ( 'newrelic' ) ) { newrelic_name_transaction ( $ action -> controller -> id . '/' . $ action -> id ) ; } return $ result ; }
9362	public function argument ( ) { if ( $ this -> original ) { return $ this -> original -> theta ; } return atan2 ( $ this -> float_i , $ this -> float_r ) ; }
11619	public function site ( ) : \ TheCMSThread \ Core \ Main \ Site { static $ site ; if ( $ site === null ) { $ site = $ this -> container -> get ( "TheCMSThread\\Core\\Main\\Site" ) ; } return $ site ; }
4725	private function addRule ( $ data , $ ruleType ) { if ( \ is_string ( $ data ) ) { $ data = array ( $ data ) ; } elseif ( ! \ is_array ( $ data ) ) { throw new InvalidArgumentException ( 'Invalid inflector rule data.' ) ; } foreach ( $ data as $ rule ) { array_push ( $ this -> rules [ $ ruleType ] , ( string ) $ rule ) ; } }
3853	public function overrideOutputFormat ( $ strOutputFormat = null ) { $ strOutputFormat = strval ( $ strOutputFormat ) ; if ( strlen ( $ strOutputFormat ) ) { $ this -> strOutputFormat = $ strOutputFormat ; } else { unset ( $ this -> strOutputFormat ) ; } return $ this ; }
8703	protected function registerViewComposers ( ) { $ core = $ this -> getCore ( ) ; view ( ) -> composer ( $ core -> config ( 'views.menu' ) , MenuComposer :: class ) ; view ( ) -> composer ( $ core -> config ( 'views.top' ) , TopComposer :: class ) ; return $ this ; }
6717	protected function setParameters ( $ newParameters ) { if ( is_scalar ( $ newParameters ) ) { if ( ! is_string ( $ newParameters ) ) { throw new \ Exception ( 'newParameters can not be scalar' ) ; } $ newParameters = $ this -> stringToArray ( $ newParameters ) ; } foreach ( $ newParameters as $ field => $ value ) { $ this -> setParameter ( $ field , $ value ) ; } return $ this ; }
10876	public function processApprove ( string $ hash ) : bool { $ decode = $ this -> getDecodeHash ( $ hash ) ; $ id = ( int ) $ decode [ 'id' ] ; $ verifyHash = $ decode [ 'verifyHash' ] ; $ item = $ this -> getById ( $ id ) ; if ( $ item && $ id == $ item [ 'id' ] ) { if ( ! $ item [ 'active' ] ) { if ( $ this -> verifyHash ( $ item [ 'id' ] . $ item [ 'login' ] , $ verifyHash ) ) { return $ this -> update ( $ item [ 'id' ] , [ 'active' => true ] ) ; } else { throw new IdentityException ( 'Invalid hash!' ) ; } } else { throw new IdentityException ( 'User is already approve!' ) ; } } else { throw new IdentityException ( 'User does not exist!' ) ; } }
12269	protected function generateEventNames ( $ baseEventName , Page $ page ) { $ pageName = $ page -> getPageName ( ) ; $ language = $ page -> getCurrentLanguage ( ) ; return array ( $ baseEventName , $ baseEventName . '.' . $ language , $ baseEventName . '.' . $ pageName , $ baseEventName . '.' . $ language . '.' . $ pageName , ) ; }
2224	public function editCss ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { return $ this -> User -> hasAccess ( 'css' , 'themes' ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' ; }
4764	protected function validateDeliveryAddressOptIn ( ) { $ return = true ; $ optin = ( int ) $ this -> getRequestParameter ( 'oegdproptin_deliveryaddress' ) ; $ changeExistigAddress = ( int ) $ this -> getRequestParameter ( 'oegdproptin_changeDelAddress' ) ; $ addressId = $ this -> getRequestParameter ( 'oxaddressid' ) ; $ deliveryAddressData = $ this -> _getDelAddressData ( ) ; if ( \ OxidEsales \ Eshop \ Core \ Registry :: getConfig ( ) -> getConfigParam ( 'blOeGdprOptinDeliveryAddress' ) && ( ( null == $ addressId ) || ( '-1' == $ addressId ) || ( 1 == $ changeExistigAddress ) ) && ! empty ( $ deliveryAddressData ) && ( 1 !== $ optin ) ) { $ return = false ; } return $ return ; }
7666	function EncodeQP ( $ str ) { $ encoded = $ this -> FixEOL ( $ str ) ; if ( substr ( $ encoded , - ( strlen ( $ this -> LE ) ) ) != $ this -> LE ) $ encoded .= $ this -> LE ; $ encoded = preg_replace ( '/([\000-\010\013\014\016-\037\075\177-\377])/e' , "'='.sprintf('%02X', ord('\\1'))" , $ encoded ) ; $ encoded = preg_replace ( "/([\011\040])" . $ this -> LE . "/e" , "'='.sprintf('%02X', ord('\\1')).'" . $ this -> LE . "'" , $ encoded ) ; $ encoded = $ this -> WrapText ( $ encoded , 74 , true ) ; return $ encoded ; }
8396	public static function ensureTable ( array $ mapping ) : bool { $ database = Database :: get ( $ mapping [ 'config' ] [ 'database' ] ) ; $ statement = 'CREATE TABLE IF NOT EXISTS _stray_migration (' ; $ statement .= 'date TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL, ' ; $ statement .= 'migration VARCHAR(255)' ; $ statement .= ')' ; $ statement = $ database -> getMasterLink ( ) -> prepare ( $ statement ) ; if ( $ statement -> execute ( ) === false ) { echo 'Can\'t create _stray_migration (' . $ statement -> errorInfo ( ) [ 2 ] . ')' . PHP_EOL ; return false ; } $ select = new Select ( $ mapping [ 'config' ] [ 'database' ] , true ) ; $ select -> select ( 'COUNT(*) as count' ) -> from ( '_stray_migration' ) ; if ( $ select -> execute ( ) === false ) { echo 'Can\'t fetch from _stray_migration (' . $ select -> getErrorMessage ( ) . ')' . PHP_EOL ; return false ; } if ( $ select -> fetch ( ) [ 'count' ] == 0 ) { $ insert = new Insert ( $ mapping [ 'config' ] [ 'database' ] ) ; $ insert -> into ( '_stray_migration' ) ; if ( $ insert -> execute ( ) === false ) { echo 'Can\'t insert into _stray_migration (' . $ insert -> getErrorMessage ( ) . ')' . PHP_EOL ; return false ; } } return true ; }
1429	protected function fillSoftDelete ( Model $ record , $ field , $ value ) { $ value = $ this -> deserializeSoftDelete ( $ value , $ field , $ record ) ; $ record -> forceFill ( [ $ this -> getSoftDeleteKey ( $ record ) => $ value , ] ) ; }
8331	public function constructPdoDsn ( array $ params ) { if ( PlatformHelper :: isWindows ( ) ) { return $ this -> constructPdoDsnWindows ( $ params ) ; } return $ this -> constructPdoDsnUnix ( $ params ) ; }
895	private function findComparisonEnd ( Tokens $ tokens , $ index ) { ++ $ index ; $ count = \ count ( $ tokens ) ; while ( $ index < $ count ) { $ token = $ tokens [ $ index ] ; if ( $ token -> isGivenKind ( [ T_WHITESPACE , T_COMMENT , T_DOC_COMMENT ] ) ) { ++ $ index ; continue ; } if ( $ this -> isOfLowerPrecedence ( $ token ) ) { break ; } $ block = Tokens :: detectBlockType ( $ token ) ; if ( null === $ block ) { ++ $ index ; continue ; } if ( ! $ block [ 'isStart' ] ) { break ; } $ index = $ tokens -> findBlockEnd ( $ block [ 'type' ] , $ index ) + 1 ; } $ prev = $ tokens -> getPrevMeaningfulToken ( $ index ) ; return $ tokens [ $ prev ] -> isGivenKind ( T_CLOSE_TAG ) ? $ tokens -> getPrevMeaningfulToken ( $ prev ) : $ prev ; }
11274	public function install ( ) : Migrate { Whois :: print ( $ this -> getNotify ( ) ) ; $ this -> exists ( ) || $ this -> migrationRepository -> createRepository ( ) ; return $ this ; }
5859	public function getAllDirectories ( ) { $ directories = [ ] ; foreach ( $ this -> rulesets as $ ruleset ) { $ dirs = GeneralUtility :: trimExplode ( ',' , $ ruleset [ 'directories_config' ] , true ) ; $ directories = array_merge ( $ directories , $ dirs ) ; } $ directories = array_unique ( $ directories ) ; asort ( $ directories ) ; return $ directories ; }
4722	public function setText ( $ text ) { $ this -> text = $ text ; if ( ! $ this -> text instanceof Text ) { $ this -> text = new Text ( $ this -> text ) ; } return $ this ; }
6998	protected function prepareRelatedRecord ( $ relationName , array $ relationRecordData , $ index = null ) { $ recordWithBackup = $ relationRecordData ; $ valueViewers = $ this -> getViewersForRelations ( ) ; foreach ( $ relationRecordData as $ columnName => $ value ) { $ viewerName = $ relationName . '.' . ( $ index === null ? '' : $ index . '.' ) . $ columnName ; if ( array_key_exists ( $ viewerName , $ valueViewers ) && $ valueViewers [ $ viewerName ] -> getRelation ( ) -> getName ( ) === $ relationName ) { $ recordWithBackup [ $ columnName ] = $ recordWithBackup [ '__' . $ columnName ] = $ value ; $ valueViewer = $ valueViewers [ $ viewerName ] ; if ( is_object ( $ valueViewer ) && method_exists ( $ valueViewer , 'convertValue' ) && ( ! method_exists ( $ valueViewer , 'isVisible' ) || $ valueViewer -> isVisible ( ) ) ) { $ recordWithBackup [ $ columnName ] = $ valueViewer -> convertValue ( $ recordWithBackup [ $ columnName ] , $ relationRecordData ) ; } } } return $ recordWithBackup ; }
12507	public static function singleDocument ( $ document ) { if ( gettype ( $ document ) != "array" && gettype ( $ document ) != "object" ) { throw new ClusterpointException ( "\"->insert()\" function: parametr passed " . json_encode ( self :: escape_string ( $ document ) ) . " is not in valid document format." , 9002 ) ; } $ query = "{" ; $ first = true ; foreach ( $ document as $ key => $ value ) { if ( ! $ first ) { $ query .= "," ; } $ query .= '"' . self :: escape_string ( $ key ) . '" : ' . json_encode ( $ value ) ; $ first = false ; } $ query .= '}' ; return $ query ; }
4065	public function getReferencedAttributes ( ) { $ arrAttributes = array ( ) ; foreach ( $ this -> arrChildren as $ objSetting ) { $ arrAttributes = array_merge ( $ arrAttributes , $ objSetting -> getReferencedAttributes ( ) ) ; } return $ arrAttributes ; }
11251	public function getLastBatchNumber ( ) : int { $ stmt = $ this -> pdo -> query ( "select max(batch) from {$this->table}" ) ; $ stmt -> execute ( ) ; return ( int ) $ stmt -> fetch ( PDO :: FETCH_ASSOC ) [ 'max' ] ; }
7816	public function event ( string $ event ) : self { $ events = [ 'MESSAGE_RECEIVED' , 'MESSAGE_SENT' , 'MESSAGE_FAILED' , ] ; if ( ! in_array ( $ event , $ events ) ) { abort ( 500 , sprintf ( 'Event %s not available.' , $ event ) ) ; } $ this -> event = $ event ; return $ this ; }
6680	public static function getDateTime ( $ format , $ timestamp = 'now' ) { $ date = strtotime ( $ timestamp ) ; if ( ! $ date ) { return $ timestamp ; } return date ( $ format , $ date ) ; }
3654	public function purge ( ) { foreach ( $ GLOBALS [ 'TL_PURGE' ] [ 'folders' ] [ 'metamodels_assets' ] [ 'affected' ] as $ folderName ) { $ folder = new \ Folder ( $ folderName ) ; $ folder -> purge ( ) ; } $ dispatcher = $ GLOBALS [ 'container' ] [ 'event-dispatcher' ] ; $ dispatcher -> dispatch ( ContaoEvents :: SYSTEM_LOG , new LogEvent ( 'Purged the MetaModels assets' , __METHOD__ , TL_CRON ) ) ; }
8554	public function setLoanServicingEventList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'LoanServicingEventList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
2206	public function generate ( ) { if ( TL_MODE == 'BE' ) { $ objTemplate = new BackendTemplate ( 'be_wildcard' ) ; $ objTemplate -> wildcard = '### ' . Utf8 :: strtoupper ( $ GLOBALS [ 'TL_LANG' ] [ 'FMD' ] [ 'logout' ] [ 0 ] ) . ' ###' ; $ objTemplate -> title = $ this -> headline ; $ objTemplate -> id = $ this -> id ; $ objTemplate -> link = $ this -> name ; $ objTemplate -> href = 'contao/main.php?do=themes&amp;table=tl_module&amp;act=edit&amp;id=' . $ this -> id ; return $ objTemplate -> parse ( ) ; } if ( $ this -> redirectBack ) { $ _SESSION [ 'LAST_PAGE_VISITED' ] = $ this -> getReferer ( ) ; } $ strLogoutUrl = System :: getContainer ( ) -> get ( 'security.logout_url_generator' ) -> getLogoutUrl ( ) ; $ strRedirect = Environment :: get ( 'base' ) ; if ( $ this -> redirectBack && ! empty ( $ _SESSION [ 'LAST_PAGE_VISITED' ] ) ) { $ strRedirect = $ _SESSION [ 'LAST_PAGE_VISITED' ] ; } elseif ( ( $ objTarget = $ this -> objModel -> getRelated ( 'jumpTo' ) ) instanceof PageModel ) { $ strRedirect = $ objTarget -> getAbsoluteUrl ( ) ; } $ uri = Http :: createFromString ( $ strLogoutUrl ) ; $ query = new Query ( $ uri -> getQuery ( ) ) ; $ query = $ query -> merge ( 'redirect=' . $ strRedirect ) ; $ this -> redirect ( ( string ) $ uri -> withQuery ( ( string ) $ query ) ) ; return '' ; }
1904	public function execute ( ) { $ arrParams = \ func_get_args ( ) ; if ( ! empty ( $ arrParams ) && \ is_array ( $ arrParams [ 0 ] ) ) { $ arrParams = array_values ( $ arrParams [ 0 ] ) ; } $ this -> replaceWildcards ( $ arrParams ) ; return $ this -> query ( ) ; }
10636	protected function resolvePaths ( array $ fixPaths ) { $ this -> rootDir = \ realpath ( isset ( $ fixPaths [ 'rootDir' ] ) ? $ fixPaths [ 'rootDir' ] : __DIR__ . '/../../../../' ) ; $ this -> packageDir = \ realpath ( isset ( $ fixPaths [ 'packageDir' ] ) ? $ fixPaths [ 'packageDir' ] : __DIR__ . '/../' ) ; $ this -> configPath = Utils :: fixPath ( isset ( $ fixPaths [ 'configPath' ] ) ? $ fixPaths [ 'configPath' ] : '/app/' ) ; if ( $ this -> rootDir === false || $ this -> packageDir === false ) throw new \ InvalidArgumentException ( 'Bootstrap directories do not exists or are not accessible' ) ; if ( $ this [ 'minion.usePropel' ] ) { $ this -> propelConfigPath = \ realpath ( isset ( $ fixPaths [ 'propelConfigPath' ] ) ? $ fixPaths [ 'propelConfigPath' ] : Utils :: fixPath ( $ this -> packageDir . '/propel.php' ) ) ; if ( $ this -> propelConfigPath === false ) throw new \ InvalidArgumentException ( 'Propel configuration file in vendor Minion not found' ) ; } }
1219	private function debugRequest ( $ url , array $ headers , $ body ) { $ str = $ url . PHP_EOL ; $ str .= array_reduce ( array_keys ( $ headers ) , function ( $ str , $ key ) use ( $ headers ) { $ str .= $ key . ': ' . $ headers [ $ key ] . PHP_EOL ; return $ str ; } , '' ) ; $ str .= $ body ; $ this -> debug ( $ str ) ; }
4001	protected function getMetaModelDataFrom ( $ strTable , $ intID ) { if ( ! $ this -> connection -> getSchemaManager ( ) -> tablesExist ( [ $ strTable ] ) ) { return null ; } $ statement = $ this -> connection -> prepare ( 'SELECT metamodel, metamodel_filtering FROM ' . $ strTable . ' WHERE id=? LIMIT 0,1' ) ; $ statement -> bindValue ( 1 , $ intID ) ; $ statement -> execute ( ) ; if ( $ statement -> rowCount ( ) < 1 ) { return null ; } return $ statement -> fetch ( \ PDO :: FETCH_OBJ ) ; }
8793	protected function setKeyInEnvironmentFile ( $ key , $ input , $ output ) { $ currentKey = config ( 'app.key' ) ; $ helper = $ this -> getHelper ( 'question' ) ; $ question = new ConfirmationQuestion ( 'Application key will re-generate. Are you sure?: ' , false ) ; if ( strlen ( $ currentKey ) !== 0 && ( ! $ helper -> ask ( $ input , $ output , $ question ) ) ) { return false ; } $ this -> writeNewEnvironmentFileWith ( $ key ) ; return true ; }
4655	protected function getJobFromImage ( ImageItem $ image , $ imageName , $ strategy , $ project ) { $ tag = explode ( ':' , $ imageName ) [ 1 ] ; list ( $ uniq , $ timestamp ) = explode ( '-' , $ tag ) ; return new Job ( $ project , $ strategy , $ uniq , array ( 'image' => $ image ) , "" , \ DateTime :: createFromFormat ( 'U' , $ timestamp ) ) ; }
11208	protected function getValue ( $ data , $ key = false ) { $ returnValue = $ data ; if ( $ key && is_object ( $ data ) ) { $ returnValue = $ data -> $ key ; } else if ( $ key && is_array ( $ data ) ) { $ returnValue = $ data [ $ key ] ; } return $ returnValue ; }
6388	public function readSite ( ) { $ model = $ this -> readCourse ( 1 ) ; $ model -> url = $ this -> cfg -> wwwroot ; $ model -> type = "site" ; return $ model ; }
467	public function buildExistsCondition ( $ operator , $ operands , & $ params ) { array_unshift ( $ operands , $ operator ) ; return $ this -> buildCondition ( $ operands , $ params ) ; }
12313	public function toArray ( ) { $ data = [ "uuid" => $ this -> uuid , "code" => $ this -> code , "modules" => $ this -> modules , "vars" => $ this -> vars , ] ; foreach ( [ 'modules' , 'vars' ] as $ key ) { if ( ! array_key_exists ( $ key , $ data ) ) { continue ; } if ( empty ( $ data [ $ key ] ) ) { $ data [ $ key ] = new \ stdClass ( ) ; } } return $ data ; }
9010	public function char ( int $ size = 36 , string $ charset = null ) : self { $ this -> type = 'char(' . $ size . ')' . $ this -> stringOptions ( $ charset ) ; return $ this ; }
3606	public function get ( $ name ) { if ( ! isset ( $ this -> httpHandlers [ $ name ] ) ) { throw new \ Exception ( "HttpHandler {$name} not found" ) ; } return $ this -> httpHandlers [ $ name ] ; }
4485	public function watchdog ( string $ jid , string $ worker , ? int $ pid = null ) { if ( empty ( $ this -> channels ) || $ pid === null ) { return ; } ini_set ( 'default_socket_timeout' , self :: UNLIMITED ) ; $ pubsub = $ this -> redis -> pubSubLoop ( ) ; $ callable = [ $ pubsub , 'subscribe' ] ; if ( ! is_callable ( $ callable ) ) { return ; } call_user_func_array ( $ callable , $ this -> channels ) ; foreach ( $ pubsub as $ message ) { if ( $ message -> kind !== 'message' || empty ( $ message -> payload ) ) { continue ; } $ payload = json_decode ( $ message -> payload , true ) ; if ( empty ( $ payload ) ) { continue ; } if ( empty ( $ payload [ 'event' ] ) || ! is_array ( $ payload ) ) { continue ; } if ( ! in_array ( $ payload [ 'event' ] , self :: WATCHDOG_EVENTS , true ) || empty ( $ payload [ 'jid' ] ) ) { continue ; } if ( $ payload [ 'jid' ] !== $ jid ) { continue ; } $ who = 'watchdog:' . $ worker ; switch ( $ payload [ 'event' ] ) { case self :: LOCK_LOST : if ( ! empty ( $ payload [ 'worker' ] ) && $ payload [ 'worker' ] === $ worker ) { $ this -> logger -> info ( "{type}: sending SIGKILL to child {$pid}; job {jid} handed out to another worker" , [ 'type' => $ who , 'jid' => $ jid ] ) ; $ this -> system -> posixKill ( $ pid , SIGKILL ) ; $ pubsub -> stop ( ) ; } break ; case self :: CANCELED : if ( ! empty ( $ payload [ 'worker' ] ) && $ payload [ 'worker' ] === $ worker ) { $ this -> logger -> info ( "{type}: sending SIGKILL to child {$pid}; job {jid} canceled" , [ 'type' => $ who , 'jid' => $ jid ] ) ; $ this -> system -> posixKill ( $ pid , SIGKILL ) ; $ pubsub -> stop ( ) ; } break ; case self :: COMPLETED : case self :: FAILED : $ pubsub -> stop ( ) ; break ; } } unset ( $ pubsub ) ; ini_set ( 'default_socket_timeout' , $ this -> defaultSocketTimeout ) ; }
3289	public function start ( ) : Promise { if ( $ this -> handle ) { throw new StatusError ( "Process has already been started." ) ; } return call ( function ( ) { $ this -> handle = $ this -> processRunner -> start ( $ this -> command , $ this -> cwd , $ this -> env , $ this -> options ) ; return $ this -> pid = yield $ this -> handle -> pidDeferred -> promise ( ) ; } ) ; }
4500	public function matches ( string $ selectors ) : bool { $ matches = $ this -> getRootDocument ( ) -> querySelectorAll ( $ selectors ) ; $ i = $ matches -> length ; while ( -- $ i >= 0 && $ matches -> item ( $ i ) !== $ this ) { ; } return ( $ i >= 0 ) ; }
4210	private function phpDocParam ( $ param , $ className ) { $ constantName = null ; $ defaultValue = $ this -> abstracter -> UNDEFINED ; if ( \ array_key_exists ( 'defaultValue' , $ param ) ) { $ defaultValue = $ param [ 'defaultValue' ] ; if ( \ in_array ( $ defaultValue , array ( 'true' , 'false' , 'null' ) ) ) { $ defaultValue = \ json_decode ( $ defaultValue ) ; } elseif ( \ is_numeric ( $ defaultValue ) ) { $ defaultValue = $ defaultValue * 1 ; } elseif ( \ preg_match ( '/^array\(\s*\)|\[\s*\]$/i' , $ defaultValue ) ) { $ defaultValue = array ( ) ; } elseif ( \ preg_match ( '/^(self::)?([^\(\)\[\]]+)$/i' , $ defaultValue , $ matches ) ) { if ( $ matches [ 1 ] ) { if ( \ defined ( $ className . '::' . $ matches [ 2 ] ) ) { $ constantName = $ matches [ 0 ] ; $ defaultValue = \ constant ( $ className . '::' . $ matches [ 2 ] ) ; } } elseif ( \ defined ( $ defaultValue ) ) { $ constantName = $ defaultValue ; $ defaultValue = \ constant ( $ defaultValue ) ; } } else { $ defaultValue = \ trim ( $ defaultValue , '\'"' ) ; } } return array ( 'constantName' => $ constantName , 'defaultValue' => $ defaultValue , ) ; }
7697	function MsPowerpoint_SearchInSlides ( $ str , $ returnFirstFound = true ) { $ this -> MsPowerpoint_InitSlideLst ( ) ; $ files = array ( ) ; foreach ( $ this -> OpenXmlSlideLst as $ i => $ s ) $ files [ $ i + 1 ] = $ s [ 'idx' ] ; $ find = $ this -> TbsSearchInFiles ( $ files , $ str , $ returnFirstFound ) ; return $ find ; }
2321	public static function get ( $ image , $ width , $ height , $ mode = '' , $ target = null , $ force = false ) { @ trigger_error ( 'Using Image::get() has been deprecated and will no longer work in Contao 5.0. Use the contao.image.image_factory service instead.' , E_USER_DEPRECATED ) ; if ( $ image == '' ) { return null ; } try { $ imageObj = static :: create ( $ image , array ( $ width , $ height , $ mode ) ) ; $ imageObj -> setTargetPath ( $ target ) ; $ imageObj -> setForceOverride ( $ force ) ; if ( $ path = $ imageObj -> executeResize ( ) -> getResizedPath ( ) ) { return $ path ; } } catch ( \ Exception $ e ) { System :: log ( 'Image "' . $ image . '" could not be processed: ' . $ e -> getMessage ( ) , __METHOD__ , 'ERROR' ) ; } return null ; }
11283	protected function _populateAttributes ( $ record ) { foreach ( $ this -> model_attributes as $ key => $ def ) { if ( isset ( $ record [ $ this -> getFieldName ( $ key ) ] ) ) { $ fieldName = $ this -> getFieldName ( $ key ) ; if ( \ Cora \ Gateway :: is_serialized ( $ record [ $ fieldName ] ) ) { $ value = unserialize ( $ record [ $ fieldName ] ) ; } else if ( isset ( $ def [ 'type' ] ) && ( $ def [ 'type' ] == 'date' || $ def [ 'type' ] == 'datetime' ) ) { $ value = new \ DateTime ( $ record [ $ fieldName ] ) ; } else { $ value = $ record [ $ fieldName ] ; } $ this -> beforeSet ( $ key , $ value ) ; $ this -> model_data [ $ key ] = $ value ; $ this -> afterSet ( $ key , $ value ) ; } else if ( isset ( $ def [ 'models' ] ) || ( isset ( $ def [ 'model' ] ) && isset ( $ def [ 'usesRefTable' ] ) ) ) { if ( ! isset ( $ this -> model_data [ $ key ] ) ) $ this -> model_data [ $ key ] = 1 ; } } }
10133	public function insertBitmap ( $ row , $ col , $ bitmap , $ x = 0 , $ y = 0 , $ scale_x = 1 , $ scale_y = 1 ) { $ bitmap_array = ( is_resource ( $ bitmap ) ? $ this -> processBitmapGd ( $ bitmap ) : $ this -> processBitmap ( $ bitmap ) ) ; list ( $ width , $ height , $ size , $ data ) = $ bitmap_array ; $ width *= $ scale_x ; $ height *= $ scale_y ; $ this -> positionImage ( $ col , $ row , $ x , $ y , $ width , $ height ) ; $ record = 0x007f ; $ length = 8 + $ size ; $ cf = 0x09 ; $ env = 0x01 ; $ lcb = $ size ; $ header = pack ( 'vvvvV' , $ record , $ length , $ cf , $ env , $ lcb ) ; $ this -> append ( $ header . $ data ) ; }
8132	public function getSourceContext ( ) { return $ this -> filename ? new Twig_Source ( $ this -> sourceCode , $ this -> filename , $ this -> sourcePath ) : null ; }
11002	public function setRedirect ( $ hostname ) { if ( ! empty ( $ hostname ) ) { $ this -> redirect = new URL ( $ hostname ) ; $ this -> redirect -> set ( 'path' , rtrim ( $ this -> redirect -> path , '/' ) ) ; } else $ this -> redirect = false ; return $ this ; }
4262	public function subscribe ( $ eventName , $ callable , $ priority = 0 ) { unset ( $ this -> sorted [ $ eventName ] ) ; $ this -> subscribers [ $ eventName ] [ $ priority ] [ ] = $ callable ; }
12464	public function showAction ( $ id ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ entity = $ em -> getRepository ( 'ChillCustomFieldsBundle:CustomFieldsGroup' ) -> find ( $ id ) ; if ( ! $ entity ) { throw $ this -> createNotFoundException ( 'Unable to find CustomFieldsGroup entity.' ) ; } $ options = $ this -> getOptionsAvailable ( $ entity -> getEntity ( ) ) ; return $ this -> render ( 'ChillCustomFieldsBundle:CustomFieldsGroup:show.html.twig' , array ( 'entity' => $ entity , 'create_field_form' => $ this -> createCreateFieldForm ( $ entity ) -> createView ( ) , 'options' => $ options ) ) ; }
10057	public function hasItem ( $ key ) { if ( isset ( $ this -> data [ $ key ] ) ) { $ item = $ this -> data [ $ key ] ; if ( $ item -> isHit ( ) === true && ( $ item -> getExpires ( ) === null || $ item -> getExpires ( ) > new DateTime ( ) ) ) { return true ; } } return false ; }
5574	public function clickSubmit ( $ label = 'Submit' , $ additional = false ) { if ( ! ( $ form = $ this -> page -> getFormBySubmit ( new SelectByLabel ( $ label ) ) ) ) { return false ; } $ success = $ this -> load ( $ form -> getAction ( ) , $ form -> submitButton ( new SelectByLabel ( $ label ) , $ additional ) ) ; return ( $ success ? $ this -> getContent ( ) : $ success ) ; }
8563	private function _convertCreateShipment ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'CreateShipment' ; if ( $ request -> isSetSellerId ( ) ) { $ parameters [ 'SellerId' ] = $ request -> getSellerId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } if ( $ request -> isSetShipmentRequestDetails ( ) ) { $ ShipmentRequestDetailsCreateShipmentRequest = $ request -> getShipmentRequestDetails ( ) ; foreach ( $ ShipmentRequestDetailsCreateShipmentRequest -> getAmazonOrderId ( ) as $ AmazonOrderIdShipmentRequestDetailsIndex => $ AmazonOrderIdShipmentRequestDetails ) { $ parameters [ 'ShipmentRequestDetails' . '.' . 'AmazonOrderId' . '.' . ( $ AmazonOrderIdShipmentRequestDetailsIndex + 1 ) ] = $ AmazonOrderIdShipmentRequestDetails ; } } if ( $ request -> isSetShippingServiceId ( ) ) { $ parameters [ 'ShippingServiceId' ] = $ request -> getShippingServiceId ( ) ; } if ( $ request -> isSetShippingServiceOfferId ( ) ) { $ parameters [ 'ShippingServiceOfferId' ] = $ request -> getShippingServiceOfferId ( ) ; } return $ parameters ; }
1029	private function resolveOrError ( $ fieldDef , $ fieldNode , $ resolveFn , $ source , $ context , $ info ) { try { $ args = Values :: getArgumentValues ( $ fieldDef , $ fieldNode , $ this -> exeContext -> variableValues ) ; return $ resolveFn ( $ source , $ args , $ context , $ info ) ; } catch ( Exception $ error ) { return $ error ; } catch ( Throwable $ error ) { return $ error ; } }
11182	public function cacheActions ( DirectCollection $ collection ) { $ serializedCollection = serialize ( $ collection ) ; $ this -> set ( Keys :: EXT_ACTION , $ serializedCollection ) ; }
12161	public function getIsChildless ( ) { if ( empty ( $ this -> collectorItem ) || empty ( $ this -> collectorItem -> children ) ) { return true ; } return false ; }
7628	public function getContainerAcl ( $ containerName = '' , $ signedIdentifiers = false ) { Assertion :: notEmpty ( $ containerName , 'Container name is not specified' ) ; self :: assertValidContainerName ( $ containerName ) ; $ response = $ this -> performRequest ( $ containerName , array ( 'restype' => 'container' , 'comp' => 'acl' ) , 'GET' , array ( ) , false , null , self :: RESOURCE_CONTAINER , self :: PERMISSION_READ ) ; if ( ! $ response -> isSuccessful ( ) ) { throw new BlobException ( $ this -> getErrorMessage ( $ response , 'Resource could not be accessed.' ) ) ; } if ( $ signedIdentifiers == false ) { $ accessType = $ response -> getHeader ( Storage :: PREFIX_STORAGE_HEADER . 'blob-public-access' ) ; if ( strtolower ( $ accessType ) == 'true' ) { $ accessType = self :: ACL_PUBLIC_CONTAINER ; } return $ accessType ; } $ result = $ this -> parseResponse ( $ response ) ; if ( ! $ result ) { return array ( ) ; } $ entries = null ; if ( $ result -> SignedIdentifier ) { if ( count ( $ result -> SignedIdentifier ) > 1 ) { $ entries = $ result -> SignedIdentifier ; } else { $ entries = array ( $ result -> SignedIdentifier ) ; } } $ returnValue = array ( ) ; foreach ( $ entries as $ entry ) { $ returnValue [ ] = new SignedIdentifier ( $ entry -> Id , $ entry -> AccessPolicy ? $ entry -> AccessPolicy -> Start ? $ entry -> AccessPolicy -> Start : '' : '' , $ entry -> AccessPolicy ? $ entry -> AccessPolicy -> Expiry ? $ entry -> AccessPolicy -> Expiry : '' : '' , $ entry -> AccessPolicy ? $ entry -> AccessPolicy -> Permission ? $ entry -> AccessPolicy -> Permission : '' : '' ) ; } return $ returnValue ; }
2324	public static function validate ( $ strToken ) { if ( Config :: get ( 'disableRefererCheck' ) || \ defined ( 'BYPASS_TOKEN_CHECK' ) ) { return true ; } if ( Config :: get ( 'requestTokenWhitelist' ) ) { $ strHostname = gethostbyaddr ( $ _SERVER [ 'REMOTE_ADDR' ] ) ; foreach ( Config :: get ( 'requestTokenWhitelist' ) as $ strDomain ) { if ( $ strDomain == $ strHostname || preg_match ( '/\.' . preg_quote ( $ strDomain , '/' ) . '$/' , $ strHostname ) ) { return true ; } } } $ container = System :: getContainer ( ) ; return $ container -> get ( 'contao.csrf.token_manager' ) -> isTokenValid ( new CsrfToken ( $ container -> getParameter ( 'contao.csrf_token_name' ) , $ strToken ) ) ; }
498	public function applyTo ( $ path ) { $ pathMap = $ this -> pathMap ; if ( empty ( $ pathMap ) ) { if ( ( $ basePath = $ this -> getBasePath ( ) ) === null ) { throw new InvalidConfigException ( 'The "basePath" property must be set.' ) ; } $ pathMap = [ Yii :: $ app -> getBasePath ( ) => [ $ basePath ] ] ; } $ path = FileHelper :: normalizePath ( $ path ) ; foreach ( $ pathMap as $ from => $ tos ) { $ from = FileHelper :: normalizePath ( Yii :: getAlias ( $ from ) ) . DIRECTORY_SEPARATOR ; if ( strpos ( $ path , $ from ) === 0 ) { $ n = strlen ( $ from ) ; foreach ( ( array ) $ tos as $ to ) { $ to = FileHelper :: normalizePath ( Yii :: getAlias ( $ to ) ) . DIRECTORY_SEPARATOR ; $ file = $ to . substr ( $ path , $ n ) ; if ( is_file ( $ file ) ) { return $ file ; } } } } return $ path ; }
2293	public static function getThemes ( ) { $ arrReturn = array ( ) ; $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; $ arrThemes = scan ( $ rootDir . '/system/themes' ) ; foreach ( $ arrThemes as $ strTheme ) { if ( strncmp ( $ strTheme , '.' , 1 ) === 0 || ! is_dir ( $ rootDir . '/system/themes/' . $ strTheme ) ) { continue ; } $ arrReturn [ $ strTheme ] = $ strTheme ; } return $ arrReturn ; }
5928	public function createCategory ( Category $ category ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'category' => $ category ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/categories' , $ parameters ) ; $ result = new CategoryResponse ( $ result ) ; return $ result ; }
4499	private function arrayMergeDeep ( array $ array1 , array $ array2 ) : array { $ result = [ ] ; foreach ( \ func_get_args ( ) as $ array ) { foreach ( $ array as $ key => $ value ) { if ( \ is_int ( $ key ) ) { $ result [ ] = $ value ; } elseif ( isset ( $ result [ $ key ] ) && \ is_array ( $ result [ $ key ] ) && \ is_array ( $ value ) ) { $ result [ $ key ] = $ this -> arrayMergeDeep ( $ result [ $ key ] , $ value ) ; } else { $ result [ $ key ] = $ value ; } } } return $ result ; }
2987	public function addResource ( $ bundle , $ format , $ prefix = '/' , $ path = 'routing' ) { $ current = '' ; $ code = sprintf ( "%s:\n" , $ this -> getImportedResourceYamlKey ( $ bundle , $ prefix ) ) ; if ( file_exists ( $ this -> file ) ) { $ current = file_get_contents ( $ this -> file ) ; if ( false !== strpos ( $ current , '@' . $ bundle ) ) { throw new \ RuntimeException ( sprintf ( 'Bundle "%s" is already imported.' , $ bundle ) ) ; } } elseif ( ! is_dir ( $ dir = dirname ( $ this -> file ) ) ) { Generator :: mkdir ( $ dir ) ; } if ( 'annotation' == $ format ) { $ code .= sprintf ( " resource: \"@%s/Controller/\"\n type: annotation\n" , $ bundle ) ; } else { $ code .= sprintf ( " resource: \"@%s/Resources/config/%s.%s\"\n" , $ bundle , $ path , $ format ) ; } $ code .= sprintf ( " prefix: %s\n" , $ prefix ) ; $ code .= "\n" ; $ code .= $ current ; if ( false === Generator :: dump ( $ this -> file , $ code ) ) { return false ; } return true ; }
820	private function fixBackticks ( Tokens $ tokens , array $ backtickTokens ) { ksort ( $ backtickTokens ) ; $ openingBacktickIndex = key ( $ backtickTokens ) ; end ( $ backtickTokens ) ; $ closingBacktickIndex = key ( $ backtickTokens ) ; array_shift ( $ backtickTokens ) ; array_pop ( $ backtickTokens ) ; $ count = \ count ( $ backtickTokens ) ; $ newTokens = [ new Token ( [ T_STRING , 'shell_exec' ] ) , new Token ( '(' ) , ] ; if ( 1 !== $ count ) { $ newTokens [ ] = new Token ( '"' ) ; } foreach ( $ backtickTokens as $ token ) { if ( ! $ token -> isGivenKind ( T_ENCAPSED_AND_WHITESPACE ) ) { $ newTokens [ ] = $ token ; continue ; } $ content = $ token -> getContent ( ) ; if ( Preg :: match ( '/[`"\']/u' , $ content ) ) { return ; } $ kind = T_ENCAPSED_AND_WHITESPACE ; if ( 1 === $ count ) { $ content = '"' . $ content . '"' ; $ kind = T_CONSTANT_ENCAPSED_STRING ; } $ newTokens [ ] = new Token ( [ $ kind , $ content ] ) ; } if ( 1 !== $ count ) { $ newTokens [ ] = new Token ( '"' ) ; } $ newTokens [ ] = new Token ( ')' ) ; $ tokens -> overrideRange ( $ openingBacktickIndex , $ closingBacktickIndex , $ newTokens ) ; }
9785	public function parseFor ( ) { $ for_open_token = $ this -> pop ( 'FOR_OPEN' ) ; $ this -> currLine ++ ; $ output = '$for_index = 0; foreach(' . $ for_open_token [ 1 ] [ 1 ] . ' as ' . $ for_open_token [ 1 ] [ 0 ] . ') {' . "\n" ; while ( true ) { list ( $ type , $ value ) = $ this -> peek ( ) ; if ( $ type == 'FOR_CLOSE' ) { $ this -> pop ( ) ; $ output .= '$for_index++; }' . "\n" ; $ this -> currLine ++ ; break ; } else { $ output .= $ this -> parseExpression ( ) ; } } return $ output ; }
9783	public function parseExpression ( ) { $ token = $ this -> peek ( ) ; $ type = $ token [ 0 ] ; switch ( $ type ) { case 'IF_OPEN' : return $ this -> parseIf ( ) ; case 'FOR_OPEN' : return $ this -> parseFor ( ) ; case 'FILTERED_VALUE' : return $ this -> parseFilteredValue ( ) ; case 'VALUE' : return $ this -> parseValue ( ) ; case 'HTML' : return $ this -> parseHTML ( ) ; case 'ESCAPE' : return $ this -> parseEscape ( ) ; case 'INCLUDE' : return $ this -> parseInclude ( ) ; default : throw new SyntaxErrorException ( "Could not parse expression, invalid token '$type'" ) ; } }
4142	protected function getOauthString ( ) { $ oauth = array_merge ( $ this -> getOauthParameters ( ) , array ( 'oauth_signature' => $ this -> calculateSignature ( ) ) ) ; ksort ( $ oauth ) ; $ values = array ( ) ; foreach ( $ oauth as $ key => $ value ) { $ values [ ] = $ key . '="' . rawurlencode ( $ value ) . '"' ; } $ oauth = implode ( ', ' , $ values ) ; unset ( $ values , $ key , $ value ) ; return $ oauth ; }
1543	protected function cursor ( EncodingParametersInterface $ parameters ) { return Cursor :: create ( ( array ) $ parameters -> getPaginationParameters ( ) , $ this -> before , $ this -> after , $ this -> limit ) ; }
656	public function init ( ) { if ( $ this -> autoRelease ) { $ locks = & $ this -> _locks ; register_shutdown_function ( function ( ) use ( & $ locks ) { foreach ( $ locks as $ lock ) { $ this -> release ( $ lock ) ; } } ) ; } }
5978	public function objecttypes ( ) { if ( ! $ this -> objecttypes instanceof ObjecttypesController ) { $ this -> objecttypes = new ObjecttypesController ( $ this -> getClient ( ) , $ this -> cachePolicy , $ this -> cache ) ; $ this -> objecttypes -> setLogger ( $ this -> logger ) ; } return $ this -> objecttypes ; }
12086	public function save ( ) { $ this -> checkPermission ( "special" , "/admin" ) ; $ referer = $ this -> application -> input -> getReferer ( ) ; if ( ! $ this -> application -> input -> methodIs ( "post" ) ) { $ this -> response -> addAlert ( "No configuration data recieved" , 'error' ) ; } else { if ( ( $ data = $ this -> application -> input -> getArray ( "options" , array ( ) , "post" ) ) == FALSE ) { $ this -> response -> addAlert ( "No input data recieved, Something went wrong" , 'error' ) ; } else { $ namespace = $ this -> application -> input -> getString ( "options_namespace" , "" , "post" ) ; $ this -> application -> config -> mergeParams ( $ namespace , $ data ) ; if ( ! $ this -> application -> config -> saveParams ( ) ) { $ this -> response -> addAlert ( 'Something went wrong, Did not save the parameters' , 'error' ) ; } else { $ this -> response -> addAlert ( "Your configuration settings have now been saved" , "success" ) ; } } } $ this -> application -> dispatcher -> redirect ( $ referer , HTTP_FOUND , null , $ this -> response -> getAlerts ( ) ) ; return true ; }
6910	public function addExtraCopy ( Recipient $ copy ) { if ( ! $ this -> extraCopies -> contains ( $ copy ) ) { $ this -> extraCopies -> add ( $ copy ) ; } return $ this ; }
5861	protected function compileRulesets ( array $ rulesets ) { $ out = [ ] ; $ elements = $ rulesets [ 'data' ] [ 'sDEF' ] [ 'lDEF' ] [ 'ruleset' ] [ 'el' ] ; foreach ( $ elements as $ container ) { if ( isset ( $ container [ 'container' ] [ 'el' ] ) ) { $ values = [ ] ; foreach ( $ container [ 'container' ] [ 'el' ] as $ key => $ value ) { if ( $ key === 'title' ) { continue ; } $ values [ $ key ] = $ value [ 'vDEF' ] ; } $ out [ ] = $ this -> expandValuesInRuleset ( $ values ) ; } } return $ out ; }
5232	public function equals ( $ compare ) { if ( $ compare instanceof self ) { return ( get_class ( $ compare ) === get_class ( $ this ) && $ compare -> name ( ) === $ this -> name ) ; } return false ; }
7099	private function ceilComparison ( UnitCandidate $ a , UnitCandidate $ b , $ property , $ quantity ) { if ( $ a -> { $ property } >= $ quantity && $ b -> { $ property } < $ quantity ) { return - 1 ; } if ( $ a -> { $ property } < $ quantity && $ b -> { $ property } >= $ quantity ) { return 1 ; } return false ; }
12127	public function getSetting ( $ name , $ default = null ) { return array_key_exists ( $ name , $ this -> settings ) ? $ this -> settings [ $ name ] : $ default ; }
4031	private function updateImageWithDisabled ( ModelInterface $ model , $ image ) { $ this -> preCreateInverseImage ( $ model , $ image ) ; if ( $ model -> getProperty ( 'enabled' ) ) { return $ image ; } if ( false === $ intPos = strrpos ( $ image , '.' ) ) { return $ image ; } return substr_replace ( $ image , '_1' , $ intPos , 0 ) ; }
8244	public function login ( $ id , $ userData ) { $ this -> abortIfExpired ( $ id , $ userData ) ; $ u = new User ( ) ; $ u -> setAuthenticated ( true ) ; $ u -> setAuthenticator ( $ this -> getName ( ) ) ; $ u -> setId ( $ id ) ; if ( isset ( $ userData [ 'groups' ] ) ) { $ u -> setGroups ( $ userData [ 'groups' ] ) ; } if ( isset ( $ userData [ 'displayName' ] ) ) { $ u -> setDisplayName ( $ userData [ 'displayName' ] ) ; } if ( isset ( $ userData [ 'attributes' ] ) ) { foreach ( $ userData [ 'attributes' ] as $ key => $ value ) { $ u -> setAttribute ( $ key , $ value ) ; } } $ this -> picoAuth -> setUser ( $ u ) ; }
126	protected function createRemoveRule ( PackageInterface $ package , $ reason , $ job ) { return new GenericRule ( array ( - $ package -> id ) , $ reason , $ job [ 'packageName' ] , $ job ) ; }
4242	public function onOutput ( ) { if ( $ this -> debug -> parentInstance ) { return ; } $ vals = $ this -> runtimeVals ( ) ; $ this -> debug -> groupSummary ( 1 ) ; $ this -> debug -> info ( 'Built In ' . $ vals [ 'runtime' ] . ' sec' ) ; $ this -> debug -> info ( 'Peak Memory Usage' . ( $ this -> debug -> getCfg ( 'output/outputAs' ) == 'html' ? ' <span title="Includes debug overhead">?&#x20dd;</span>' : '' ) . ': ' . $ this -> debug -> utilities -> getBytes ( $ vals [ 'memoryPeakUsage' ] ) . ' / ' . $ this -> debug -> utilities -> getBytes ( $ vals [ 'memoryLimit' ] ) ) ; $ this -> debug -> groupEnd ( ) ; }
1108	protected function validateDuplicates ( ) { return ( ! $ this -> duplicatesExistForColumn ( $ this -> node -> getQualifiedLeftColumnName ( ) ) && ! $ this -> duplicatesExistForColumn ( $ this -> node -> getQualifiedRightColumnName ( ) ) ) ; }
3877	public function build ( ) { if ( ! $ this -> isEmpty ( ) ) { return new SimpleQuery ( sprintf ( 'SELECT id FROM %s WHERE %s' , $ this -> tableName , $ this -> getProcedure ( ) ) , $ this -> getParameters ( ) , 'id' , $ this -> connection ) ; } return null ; }
5126	public static function init ( array $ directories , EnvironmentInterface $ environment = null , bool $ handleErrors = true ) : ? self { if ( $ handleErrors ) { ExceptionHandler :: register ( ) ; } $ core = new static ( new Container ( ) , $ directories ) ; $ core -> container -> bindSingleton ( EnvironmentInterface :: class , $ environment ?? new Environment ( ) ) ; try { ContainerScope :: runScope ( $ core -> container , function ( ) use ( $ core ) { $ core -> bootload ( ) ; $ core -> bootstrap ( ) ; } ) ; } catch ( \ Throwable $ e ) { ExceptionHandler :: handleException ( $ e ) ; return null ; } return $ core ; }
11790	public function clear ( $ name = null ) { if ( ! is_null ( $ name ) ) { $ name = strtolower ( $ name ) ; if ( array_key_exists ( $ name , self :: $ clearings ) ) { $ this -> { $ name } = self :: $ clearings [ $ self :: $ clearings ] ; } } else { foreach ( self :: $ clearings as $ n => $ v ) { $ this -> { $ n } = $ v ; } } return $ this ; }
5314	protected function generate ( ) { $ this -> reset ( ) ; foreach ( range ( 1 , $ this -> getCount ( ) ) as $ counter ) { $ this -> codes [ ] = $ this -> generateBlocks ( ) ; } return $ this -> codes ; }
12746	protected function onMovedResponse ( CommandInterface $ command , $ details ) { list ( $ slot , $ connectionID ) = explode ( ' ' , $ details , 2 ) ; if ( ! $ connection = $ this -> getConnectionById ( $ connectionID ) ) { $ connection = $ this -> createConnection ( $ connectionID ) ; } if ( $ this -> useClusterSlots ) { $ this -> askSlotMap ( $ connection ) ; } $ this -> move ( $ connection , $ slot ) ; $ response = $ this -> executeCommand ( $ command ) ; return $ response ; }
6384	public function readFeedbackQuestions ( $ id ) { $ questions = $ this -> readStoreRecords ( 'feedback_item' , [ 'feedback' => $ id ] ) ; $ expandedQuestions = [ ] ; foreach ( $ questions as $ index => $ question ) { $ expandedQuestion = $ question ; $ expandedQuestion -> template = $ this -> readStoreRecord ( 'feedback_template' , [ 'id' => $ question -> template ] ) ; $ expandedQuestion -> url = $ this -> cfg -> wwwroot . '/mod/feedback/edit_item.php?id=' . $ question -> id ; $ expandedQuestions [ $ index ] = $ expandedQuestion ; } return $ expandedQuestions ; }
3089	protected function alterTimeoutCallValue ( array $ options ) { $ timeoutValue = null ; if ( $ this -> isInitialCall === true ) { if ( $ this -> hasOption ( self :: OPTION_INITIAL_CALL_TIMEOUT ) ) { $ timeoutValue = $ this -> getOption ( self :: OPTION_INITIAL_CALL_TIMEOUT ) ; } } else { if ( $ this -> hasOption ( self :: OPTION_NEXT_ITEM_CALL_TIMEOUT ) ) { $ timeoutValue = $ this -> getOption ( self :: OPTION_NEXT_ITEM_CALL_TIMEOUT ) ; } } if ( ! is_null ( $ timeoutValue ) ) { $ options [ self :: OPTION_ENGINE_CLIENT ] [ 'options' ] [ 'http_client_options' ] [ 'timeout' ] = $ timeoutValue ; } return $ options ; }
12673	public function setSourceFiles ( $ value ) { foreach ( $ value as $ key => $ settings ) { if ( $ settings === false ) { $ this -> _sourceFiles [ $ key ] = false ; continue ; } if ( ! isset ( $ settings [ 'class' ] ) ) { $ settings [ 'class' ] = $ this -> sourceFileClass ; } $ settings [ 'id' ] = $ key ; $ this -> _sourceFiles [ $ key ] = Yii :: createObject ( $ settings ) ; } }
7990	public function getPcaServices ( $ pp ) { if ( ! $ pp ) throw new BadMethodCallException ( 'Missing parameter $pp (passport).' ) ; try { $ r = $ this -> get ( 'cloud/' . $ pp . '/pca' ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new CloudException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
8114	public function addReviewNote ( Member $ reviewer , $ message ) { $ reviewLog = ContentReviewLog :: create ( ) ; $ reviewLog -> Note = $ message ; $ reviewLog -> ReviewerID = $ reviewer -> ID ; $ this -> owner -> ReviewLogs ( ) -> add ( $ reviewLog ) ; }
12367	protected function getOption ( $ name ) { if ( ! isset ( $ this -> options [ $ name ] ) ) { throw new ValueNotFoundException ( $ name ) ; } return $ this -> options [ $ name ] ; }
3355	public function getUrl ( $ postfix = null ) { $ url = sprintf ( '%s%s' , $ this -> api -> getCdnUri ( ) , $ this -> getPath ( $ postfix ) ) ; return $ url ; }
12036	public function addTranslateResponseToExceptionMethod ( ) { $ body = 'return $this->api->translateResponseToException($response);' ; $ docBlock = new DocBlockGenerator ( 'Determine whether the response is an error. Override this method to have a per-operation decision, otherwise the function from the API class will be used.' , null ) ; $ methodGenerator = $ this -> createMethodGenerator ( 'translateResponseToException' , $ body , $ docBlock , [ [ 'response' , 'Amp\Artax\Response' ] ] , [ 'null' , '\ArtaxServiceBuilder\BadResponseException' ] ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; }
8285	protected function sessionTimeoutCheck ( $ configKey , $ sessKey , $ clear , $ alwaysUpdate = false ) { if ( $ this -> config [ $ configKey ] !== false ) { $ t = time ( ) ; if ( $ this -> session -> has ( $ sessKey ) ) { if ( $ this -> session -> get ( $ sessKey ) < $ t - $ this -> config [ $ configKey ] ) { if ( $ clear ) { $ this -> session -> invalidate ( ) ; } else { $ this -> session -> migrate ( true ) ; } $ this -> session -> set ( $ sessKey , $ t ) ; } elseif ( $ alwaysUpdate ) { $ this -> session -> set ( $ sessKey , $ t ) ; } } else { $ this -> session -> set ( $ sessKey , $ t ) ; } } }
6251	protected function createGroupPresence ( $ id , $ label , array $ children = [ ] ) { return new AclPresence ( [ 'type' => AclPresenceType :: GROUP , 'id' => $ id , 'label' => $ label , 'children' => $ children , ] ) ; }
7785	public function setStatementClass ( $ statementClass ) { if ( ! is_callable ( $ statementClass ) && ! class_exists ( $ statementClass ) ) { throw new \ InvalidArgumentException ( '$statementClass must be a valid classname or a PHP callable' ) ; } $ this -> statementClass = $ statementClass ; return $ this ; }
199	public function redirect ( $ url , $ statusCode = 302 , $ checkAjax = true ) { if ( is_array ( $ url ) && isset ( $ url [ 0 ] ) ) { $ url [ 0 ] = '/' . ltrim ( $ url [ 0 ] , '/' ) ; } $ url = Url :: to ( $ url ) ; if ( strncmp ( $ url , '/' , 1 ) === 0 && strncmp ( $ url , '//' , 2 ) !== 0 ) { $ url = Yii :: $ app -> getRequest ( ) -> getHostInfo ( ) . $ url ; } if ( $ checkAjax ) { if ( Yii :: $ app -> getRequest ( ) -> getIsAjax ( ) ) { if ( Yii :: $ app -> getRequest ( ) -> getHeaders ( ) -> get ( 'X-Ie-Redirect-Compatibility' ) !== null && $ statusCode === 302 ) { $ statusCode = 200 ; } if ( Yii :: $ app -> getRequest ( ) -> getIsPjax ( ) ) { $ this -> getHeaders ( ) -> set ( 'X-Pjax-Url' , $ url ) ; } else { $ this -> getHeaders ( ) -> set ( 'X-Redirect' , $ url ) ; } } else { $ this -> getHeaders ( ) -> set ( 'Location' , $ url ) ; } } else { $ this -> getHeaders ( ) -> set ( 'Location' , $ url ) ; } $ this -> setStatusCode ( $ statusCode ) ; return $ this ; }
9242	private function __next ( ServerRequestInterface $ request , ResponseInterface $ response , $ next ) { $ this -> __loadConfigFiles ( ) ; return $ next ( $ request , $ response ) ; }
7669	function ServerVar ( $ varName ) { global $ HTTP_SERVER_VARS ; global $ HTTP_ENV_VARS ; if ( ! isset ( $ _SERVER ) ) { $ _SERVER = $ HTTP_SERVER_VARS ; if ( ! isset ( $ _SERVER [ "REMOTE_ADDR" ] ) ) $ _SERVER = $ HTTP_ENV_VARS ; } if ( isset ( $ _SERVER [ $ varName ] ) ) return $ _SERVER [ $ varName ] ; else return "" ; }
5570	public function retry ( ) { $ frames = $ this -> page -> getFrameFocus ( ) ; if ( count ( $ frames ) > 0 ) { $ this -> loadFrame ( $ frames , $ this -> page -> getUrl ( ) , $ this -> page -> getRequestData ( ) ) ; return $ this -> page -> getRaw ( ) ; } if ( $ url = $ this -> history -> getUrl ( ) ) { $ this -> page = $ this -> fetch ( $ url , $ this -> history -> getParameters ( ) ) ; return $ this -> page -> getRaw ( ) ; } return false ; }
7511	protected function parse_linebreak ( ) { if ( $ this -> doc [ $ this -> pos ] === "\r" ) { ++ $ this -> line_pos [ 0 ] ; if ( ( ( $ this -> pos + 1 ) < $ this -> size ) && ( $ this -> doc [ $ this -> pos + 1 ] === "\n" ) ) { ++ $ this -> pos ; } $ this -> line_pos [ 1 ] = $ this -> pos ; } elseif ( $ this -> doc [ $ this -> pos ] === "\n" ) { ++ $ this -> line_pos [ 0 ] ; $ this -> line_pos [ 1 ] = $ this -> pos ; } }
3263	public static function format ( $ value ) { return preg_replace ( [ '/:symbol/' , '/:price/' , '/:currency/' ] , [ Config :: get ( 'shop.currency_symbol' ) , $ value , Config :: get ( 'shop.currency' ) ] , Config :: get ( 'shop.display_price_format' ) ) ; }
7451	public function boot ( \ Neos \ Flow \ Core \ Bootstrap $ bootstrap ) { $ dispatcher = $ bootstrap -> getSignalSlotDispatcher ( ) ; $ dispatcher -> connect ( 'Neos\Flow\Configuration\ConfigurationManager' , 'configurationManagerReady' , function ( $ configurationManager ) { $ configurationManager -> registerConfigurationType ( 'Menus' ) ; } ) ; }
2277	public function getPasswordDefault ( $ varValue ) { if ( ! trim ( $ varValue ) ) { $ varValue = ( \ is_array ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_module' ] [ 'passwordText' ] ) ? $ GLOBALS [ 'TL_LANG' ] [ 'tl_module' ] [ 'passwordText' ] [ 1 ] : $ GLOBALS [ 'TL_LANG' ] [ 'tl_module' ] [ 'passwordText' ] ) ; } return $ varValue ; }
9411	protected function exceptions ( \ Exception $ exception , $ uri ) { $ interface = 'Phroute\Phroute\Exception\HttpRouteNotFoundException' ; $ message = ( string ) $ exception -> getMessage ( ) ; is_a ( $ exception , $ interface ) && $ message = 'Route "' . $ uri . '" not found' ; throw new \ UnexpectedValueException ( ( string ) $ message ) ; }
8900	public function update_by ( ) { $ args = func_get_args ( ) ; $ data = array_pop ( $ args ) ; $ data = $ this -> _do_pre_update ( $ data ) ; if ( $ data !== FALSE ) { $ this -> _set_where ( $ args ) ; return $ this -> _update ( $ data ) ; } return FALSE ; }
11517	protected function GenerateIOSPinicon ( SiteConfig $ config , SiteTree $ owner , & $ metadata , Image $ IOSPinicon ) { $ metadata .= $ this -> owner -> MarkupComment ( 'iOS Pinned Icon' ) ; if ( $ config -> fetchPiniconTitle ( ) ) { $ metadata .= $ owner -> MarkupMeta ( 'apple-mobile-web-app-title' , $ config -> fetchPiniconTitle ( ) ) ; } $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 57 , 57 ) -> getAbsoluteURL ( ) , 'image/png' ) ; $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 60 , 60 ) -> getAbsoluteURL ( ) , 'image/png' , '60x60' ) ; $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 72 , 72 ) -> getAbsoluteURL ( ) , 'image/png' , '72x72' ) ; $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 76 , 76 ) -> getAbsoluteURL ( ) , 'image/png' , '76x76' ) ; $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 114 , 114 ) -> getAbsoluteURL ( ) , 'image/png' , '114x114' ) ; $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 120 , 120 ) -> getAbsoluteURL ( ) , 'image/png' , '120x120' ) ; $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 144 , 144 ) -> getAbsoluteURL ( ) , 'image/png' , '144x144' ) ; $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 152 , 152 ) -> getAbsoluteURL ( ) , 'image/png' , '152x152' ) ; $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 180 , 180 ) -> getAbsoluteURL ( ) , 'image/png' , '180x180' ) ; }
3299	public function setHeaders ( array $ headers = [ ] ) { $ originHeaders = empty ( $ this -> headers ) ? [ ] : $ this -> headers ; $ this -> headers = array_merge ( $ originHeaders , $ headers ) ; return $ this ; }
2387	private function explode ( string $ palette ) : array { if ( '' === $ palette ) { return [ ] ; } $ legendCount = 0 ; $ legendMap = [ ] ; $ groups = StringUtil :: trimsplit ( ';' , $ palette ) ; foreach ( $ groups as $ group ) { if ( '' === $ group ) { continue ; } $ hide = false ; $ fields = StringUtil :: trimsplit ( ',' , $ group ) ; if ( preg_match ( '#\{(.+?)(:hide)?\}#' , $ fields [ 0 ] , $ matches ) ) { $ legend = $ matches [ 1 ] ; $ hide = \ count ( $ matches ) > 2 && ':hide' === $ matches [ 2 ] ; array_shift ( $ fields ) ; } else { $ legend = $ legendCount ++ ; } $ legendMap [ $ legend ] = compact ( 'fields' , 'hide' ) ; } return $ legendMap ; }
11632	private function groupPvTrans ( $ transData ) { $ result = [ ] ; foreach ( $ transData as $ one ) { $ debitAccId = $ one -> get ( DTrans :: A_ACC_ID_DEBIT ) ; $ creditAccId = $ one -> get ( DTrans :: A_ACC_ID_CREDIT ) ; $ value = $ one -> get ( DTrans :: A_AMOUNT ) ; if ( isset ( $ result [ $ debitAccId ] ) ) { $ result [ $ debitAccId ] -= $ value ; } else { $ result [ $ debitAccId ] = - $ value ; } if ( isset ( $ result [ $ creditAccId ] ) ) { $ result [ $ creditAccId ] += $ value ; } else { $ result [ $ creditAccId ] = $ value ; } } return $ result ; }
5748	public static function removeLastCharsFromString ( string $ input , int $ numChars = 1 ) : string { if ( $ numChars > strlen ( $ input ) ) { throw new \ InvalidArgumentException ( "Cannot remove $numChars from $input" ) ; } return substr ( $ input , 0 , strlen ( $ input ) - $ numChars ) ; }
10591	protected function findProduct ( int $ id ) : ProductInterface { $ product = $ this -> repository -> find ( $ id ) ; if ( ! $ product instanceof ProductInterface ) { throw new ProductNotFoundException ( $ id ) ; } return $ product ; }
11078	public static function formatPhoneNumber ( $ phoneNumber , $ formatType = Tools :: PHONE_NUMBER_FORMAT_NUMBER ) { $ formatType = ( int ) $ formatType ; if ( $ formatType !== self :: PHONE_NUMBER_FORMAT_INTERNATIONAL && $ formatType !== self :: PHONE_NUMBER_FORMAT_INTERNATIONAL_NICE && $ formatType !== self :: PHONE_NUMBER_FORMAT_NUMBER && $ formatType !== self :: PHONE_NUMBER_FORMAT_NICE && $ formatType !== self :: PHONE_NUMBER_FORMAT_SMSTOOLS ) { return false ; } if ( ! Validate :: isPhoneNumber ( $ phoneNumber ) ) { return false ; } $ phoneNumber = self :: removeSpace ( $ phoneNumber ) ; $ phoneLen = \ strlen ( $ phoneNumber ) ; if ( $ phoneLen > 9 && 0 !== strpos ( $ phoneNumber , '+' ) ) { $ phoneNumber = '+' . $ phoneNumber ; $ phoneLen ++ ; } if ( $ phoneLen !== 9 && ! ( $ phoneLen >= 11 && $ phoneLen <= 13 && 0 === strpos ( $ phoneNumber , '+' ) ) ) { return false ; } $ international = ( $ phoneLen !== 9 ) ; switch ( $ formatType ) { case self :: PHONE_NUMBER_FORMAT_INTERNATIONAL_NICE : $ formattedPhone = preg_replace ( '/^(\+\d{1,3})(\d{3})(\d{3})(\d{3})$/' , '$1 $2 $3 $4' , $ international ? $ phoneNumber : '+420' . $ phoneNumber ) ; break ; case self :: PHONE_NUMBER_FORMAT_INTERNATIONAL : $ formattedPhone = $ international ? $ phoneNumber : '+420' . $ phoneNumber ; break ; case self :: PHONE_NUMBER_FORMAT_NICE : $ formattedPhone = preg_replace ( '/^(\+\d{1,3})(\d{3})(\d{3})(\d{3})$/' , '$2 $3 $4' , $ international ? $ phoneNumber : '+420' . $ phoneNumber ) ; break ; case self :: PHONE_NUMBER_FORMAT_NUMBER : $ formattedPhone = $ international ? substr ( $ phoneNumber , - 9 ) : $ phoneNumber ; break ; case self :: PHONE_NUMBER_FORMAT_SMSTOOLS : $ formattedPhone = $ international ? trim ( $ phoneNumber , '+' ) : '420' . $ phoneNumber ; break ; default : $ formattedPhone = false ; } return $ formattedPhone ; }
8054	public function updateCalendarEvent ( $ id , array $ data ) { $ eventData = $ this -> calendarEventsEngine -> buildEventData ( $ data ) ; $ eventDates = $ this -> calendarEventsEngine -> buildEventDates ( $ data ) ; $ cache = $ this -> cache ; $ calendarEventRepeatDate = clone $ this -> calendarEventRepeatDate ; $ calendarEventRepeatDate -> where ( 'calendar_event_id' , $ id ) -> delete ( ) ; $ this -> calendarEvent -> where ( 'id' , $ id ) -> update ( $ eventData ) ; $ calendarEvent = $ this -> calendarEvent -> where ( 'id' , $ id ) -> firstOrFail ( ) ; $ this -> handleEventLocation ( $ data , $ calendarEvent ) ; foreach ( $ eventDates as $ date ) { $ calendarEventRepeatDate = clone $ this -> calendarEventRepeatDate ; $ calendarEventRepeatDate -> start = $ date [ 'start' ] ; $ calendarEventRepeatDate -> end = $ date [ 'end' ] ; $ calendarEventRepeatDate -> calendarEvent ( ) -> associate ( $ calendarEvent ) ; $ calendarEventRepeatDate -> save ( ) ; unset ( $ calendarEventRepeatDate ) ; } $ cache :: put ( self :: CACHE_KEY . $ calendarEvent -> id , $ calendarEvent , $ this -> cacheTimeToLive ) ; $ allEvents = $ this -> getAllEvents ( ) ; $ allEvents -> put ( $ calendarEvent -> id , $ calendarEvent ) ; $ cache :: put ( self :: ALL_EVENTS_KEY , $ allEvents , $ this -> cacheTimeToLive ) ; return true ; }
4542	public function postFlush ( PostFlushEventArgs $ args ) { $ maps = $ args -> getEntityManager ( ) -> getUnitOfWork ( ) -> getIdentityMap ( ) ; foreach ( $ maps as $ entities ) { foreach ( $ entities as $ entity ) { if ( ! $ entity instanceof Parameter ) { continue ; } $ entity -> setValue ( unserialize ( $ entity -> getValue ( ) ) ) ; } } }
9166	public function getValidationStatus ( $ action = '' ) { $ validation_status = null ; if ( isset ( $ _SESSION [ 'prototyper_validation' ] [ $ action ] ) ) { $ validation_status = $ _SESSION [ 'prototyper_validation' ] [ $ action ] ; } return $ validation_status ; }
2151	public function onToggleVisibility ( $ blnDisabled , DataContainer $ dc ) { if ( ! $ dc -> id ) { return $ blnDisabled ; } $ objUser = $ this -> Database -> prepare ( "SELECT email FROM tl_member WHERE id=?" ) -> limit ( 1 ) -> execute ( $ dc -> id ) ; if ( $ objUser -> numRows ) { $ this -> Database -> prepare ( "UPDATE tl_newsletter_recipients SET tstamp=?, active=? WHERE email=?" ) -> execute ( time ( ) , ( $ blnDisabled ? '' : '1' ) , $ objUser -> email ) ; } return $ blnDisabled ; }
5927	public function retrieveCategory ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/categories/' . $ id . '' , $ parameters , $ cachePolicy ) ; $ result = new CategoryResponse ( $ result ) ; return $ result ; }
8416	public function commit ( ) : bool { if ( $ this -> isConnected ( ) === false ) { $ this -> connect ( ) ; } if ( $ this -> transactionLevel > 0 ) { -- $ this -> transactionLevel ; if ( $ this -> transactionLevel == 0 ) { return $ this -> providerDatabase -> commit ( $ this -> GetMasterLink ( ) ) ; } return $ this -> providerDatabase -> releaseSavePoint ( $ this -> GetMasterLink ( ) , 'LEVEL' . $ this -> transactionLevel ) ; } return false ; }
11393	public static function activateError ( $ iLevel ) { if ( self :: $ _bFirstActivation === true ) { self :: _setFileNameInErrorFile ( ) ; self :: $ _bFirstActivation = false ; } self :: _initLogFile ( ) ; self :: $ _bActivateError = true ; error_reporting ( $ iLevel ) ; set_error_handler ( function ( $ iErrNo , $ sErrStr , $ sErrFile , $ iErrLine ) { $ aContext = array ( 'file' => $ sErrFile , 'line' => $ iErrLine ) ; $ sType = self :: getTranslateErrorCode ( $ iErrNo ) ; self :: getInstance ( ) -> $ sType ( $ sErrStr , $ aContext ) ; return true ; } , $ iLevel ) ; register_shutdown_function ( function ( ) { if ( null !== ( $ aLastError = error_get_last ( ) ) ) { $ aContext = array ( 'file' => $ aLastError [ 'file' ] , 'line' => $ aLastError [ 'line' ] ) ; $ sType = self :: getTranslateErrorCode ( $ aLastError [ 'type' ] ) ; self :: getInstance ( ) -> $ sType ( $ aLastError [ 'message' ] , $ aContext ) ; } } ) ; }
10016	public function addExternalSheet ( Worksheet $ pSheet , $ iSheetIndex = null ) { if ( $ this -> sheetNameExists ( $ pSheet -> getTitle ( ) ) ) { throw new Exception ( "Workbook already contains a worksheet named '{$pSheet->getTitle()}'. Rename the external sheet first." ) ; } $ countCellXfs = count ( $ this -> cellXfCollection ) ; foreach ( $ pSheet -> getParent ( ) -> getCellXfCollection ( ) as $ cellXf ) { $ this -> addCellXf ( clone $ cellXf ) ; } $ pSheet -> rebindParent ( $ this ) ; foreach ( $ pSheet -> getCoordinates ( false ) as $ coordinate ) { $ cell = $ pSheet -> getCell ( $ coordinate ) ; $ cell -> setXfIndex ( $ cell -> getXfIndex ( ) + $ countCellXfs ) ; } return $ this -> addSheet ( $ pSheet , $ iSheetIndex ) ; }
10297	private function writeTitle ( XMLWriter $ objWriter , Title $ title = null ) { if ( $ title === null ) { return ; } $ objWriter -> startElement ( 'c:title' ) ; $ objWriter -> startElement ( 'c:tx' ) ; $ objWriter -> startElement ( 'c:rich' ) ; $ objWriter -> startElement ( 'a:bodyPr' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'a:lstStyle' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'a:p' ) ; $ caption = $ title -> getCaption ( ) ; if ( ( is_array ( $ caption ) ) && ( count ( $ caption ) > 0 ) ) { $ caption = $ caption [ 0 ] ; } $ this -> getParentWriter ( ) -> getWriterPart ( 'stringtable' ) -> writeRichTextForCharts ( $ objWriter , $ caption , 'a' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ this -> writeLayout ( $ objWriter , $ title -> getLayout ( ) ) ; $ objWriter -> startElement ( 'c:overlay' ) ; $ objWriter -> writeAttribute ( 'val' , 0 ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; }
1764	private function canRunDbQuery ( ) : bool { try { return $ this -> connection -> isConnected ( ) && $ this -> connection -> getSchemaManager ( ) -> tablesExist ( [ 'tl_cron' ] ) ; } catch ( DriverException $ e ) { return false ; } }
5036	public function indexAction ( ) { $ events = $ this -> adminControllerEvents ; $ event = $ events -> getEvent ( AdminControllerEvent :: EVENT_DASHBOARD , $ this ) ; $ events -> trigger ( $ event , $ this ) ; $ model = new ViewModel ( ) ; $ widgets = [ ] ; foreach ( $ event -> getViewModels ( ) as $ name => $ child ) { $ model -> addChild ( $ child , $ name ) ; $ widgets [ ] = $ name ; } $ model -> setVariable ( 'widgets' , $ widgets ) ; return $ model ; }
11574	public function openTag ( $ attributesOrElement = null ) { if ( null === $ attributesOrElement ) { return '<button>' ; } if ( is_array ( $ attributesOrElement ) ) { $ attributes = $ this -> createAttributesString ( $ attributesOrElement ) ; return sprintf ( '<button %s>' , $ attributes ) ; } if ( ! $ attributesOrElement instanceof ElementInterface ) { throw new Exception \ InvalidArgumentException ( sprintf ( '%s expects an array or Zend\Form\ElementInterface instance; received "%s"' , __METHOD__ , ( is_object ( $ attributesOrElement ) ? get_class ( $ attributesOrElement ) : gettype ( $ attributesOrElement ) ) ) ) ; } $ element = $ attributesOrElement ; $ attributes = $ element -> getAttributes ( ) ; $ name = $ element -> getName ( ) ; if ( $ name ) { $ attributes [ 'name' ] = $ name ; } $ attributes [ 'type' ] = $ this -> getType ( $ element ) ; $ classList = [ 'btn' , 'btn-white' ] ; if ( isset ( $ attributes [ 'class' ] ) ) { $ attributes [ 'class' ] = implode ( ' ' , array_unique ( array_merge ( explode ( ' ' , $ attributes [ 'class' ] ) , $ classList ) ) ) ; } else { $ attributes [ 'class' ] = implode ( ' ' , $ classList ) ; } return sprintf ( '<button %s>' , $ this -> createAttributesString ( $ attributes ) ) ; }
1166	protected function parseParameters ( $ parameters ) { $ newParams = [ 'validate_all' => false ] ; if ( isset ( $ parameters [ 0 ] ) ) { $ newParams [ 'validate_all' ] = ( $ parameters [ 0 ] === 'true' ) ? true : false ; } return $ newParams ; }
2072	public function getAllowedArchives ( ) { if ( $ this -> User -> isAdmin ) { $ objArchive = Contao \ NewsArchiveModel :: findAll ( ) ; } else { $ objArchive = Contao \ NewsArchiveModel :: findMultipleByIds ( $ this -> User -> news ) ; } $ return = array ( ) ; if ( $ objArchive !== null ) { while ( $ objArchive -> next ( ) ) { $ return [ $ objArchive -> id ] = $ objArchive -> title ; } } return $ return ; }
10284	public static function getRangeBoundaries ( $ pRange ) { if ( empty ( $ pRange ) ) { $ pRange = self :: DEFAULT_RANGE ; } $ pRange = strtoupper ( $ pRange ) ; if ( strpos ( $ pRange , ':' ) === false ) { $ rangeA = $ rangeB = $ pRange ; } else { list ( $ rangeA , $ rangeB ) = explode ( ':' , $ pRange ) ; } return [ self :: coordinateFromString ( $ rangeA ) , self :: coordinateFromString ( $ rangeB ) ] ; }
11555	private function getBonusTotals ( $ dsBegin , $ dsEnd ) { $ query = $ this -> qbGetBonusTotals -> build ( ) ; $ conn = $ query -> getConnection ( ) ; $ bind = [ QBGetTotals :: BND_PERIOD_BEGIN => $ dsBegin , QBGetTotals :: BND_PERIOD_END => $ dsEnd ] ; $ rs = $ conn -> fetchAll ( $ query , $ bind ) ; $ result = [ ] ; foreach ( $ rs as $ one ) { $ accId = $ one [ QBGetTotals :: A_ACC_ID ] ; $ custId = $ one [ QBGetTotals :: A_CUST_ID ] ; $ total = $ one [ QBGetTotals :: A_TOTAL ] ; if ( $ custId ) { $ item = new DTotal ( ) ; $ item -> accountId = $ accId ; $ item -> customerId = $ custId ; $ item -> total = $ total ; $ result [ $ custId ] = $ item ; } } return $ result ; }
3886	public function collectRules ( $ filterSettings ) { $ information = $ this -> database -> createQueryBuilder ( ) -> select ( '*' ) -> from ( 'tl_metamodel_filtersetting' ) -> where ( 'fid=:fid' ) -> andWhere ( 'pid=0' ) -> andWhere ( 'enabled=1' ) -> orderBy ( 'sorting' , 'ASC' ) -> setParameter ( 'fid' , $ filterSettings -> get ( 'id' ) ) -> execute ( ) ; foreach ( $ information -> fetchAll ( \ PDO :: FETCH_ASSOC ) as $ item ) { $ newSetting = $ this -> createSetting ( $ item , $ filterSettings ) ; if ( $ newSetting ) { $ filterSettings -> addSetting ( $ newSetting ) ; } } }
8740	public function i18nQuery ( ) { $ query = $ this -> getModel ( ) -> newQueryWithoutScopes ( ) -> getQuery ( ) ; $ query -> from ( $ this -> model -> getI18nTable ( ) ) ; return $ query ; }
7813	public static function toGregorianStr ( $ j_date , $ sep = '/' ) { $ arr = explode ( $ sep , $ j_date ) ; if ( count ( $ arr ) < 3 || intval ( $ arr [ 0 ] ) == 0 ) return "" ; else $ g_date = jDateTime :: toGregorian ( $ arr [ 2 ] , $ arr [ 1 ] , $ arr [ 0 ] ) ; return implode ( $ sep , $ g_date ) ; }
2047	public function onSchemaIndexDefinition ( SchemaIndexDefinitionEventArgs $ event ) : void { if ( method_exists ( AbstractPlatform :: class , 'supportsColumnLengthIndexes' ) ) { return ; } $ connection = $ event -> getConnection ( ) ; if ( ! $ connection -> getDatabasePlatform ( ) instanceof MySqlPlatform ) { return ; } $ data = $ event -> getTableIndex ( ) ; if ( 'PRIMARY' === $ data [ 'name' ] ) { return ; } $ columns = [ ] ; $ query = sprintf ( "SHOW INDEX FROM %s WHERE Key_name='%s'" , $ event -> getTable ( ) , $ data [ 'name' ] ) ; $ result = $ connection -> executeQuery ( $ query ) ; while ( $ row = $ result -> fetch ( ) ) { if ( null !== $ row [ 'Sub_part' ] ) { $ columns [ ] = sprintf ( '%s(%s)' , $ row [ 'Column_name' ] , $ row [ 'Sub_part' ] ) ; } else { $ columns [ ] = $ row [ 'Column_name' ] ; } } $ event -> setIndex ( new Index ( $ data [ 'name' ] , $ columns , $ data [ 'unique' ] , $ data [ 'primary' ] , $ data [ 'flags' ] , $ data [ 'options' ] ) ) ; $ event -> preventDefault ( ) ; }
9234	public function actionUpdate ( $ id ) { $ model = $ this -> findModel ( $ id ) ; $ model -> tags = ! empty ( $ model -> tags ) ? explode ( "," , $ model -> tags ) : [ ] ; if ( Yii :: $ app -> request -> post ( ) ) { $ post = Yii :: $ app -> request -> post ( ) ; $ category = [ ] ; if ( isset ( $ post [ 'Post' ] [ 'category' ] ) ) { $ category = $ post [ 'Post' ] [ 'category' ] ; } if ( is_array ( $ post [ 'Post' ] [ 'tags' ] ) ) { $ post [ 'Post' ] [ 'tags' ] = implode ( "," , $ post [ 'Post' ] [ 'tags' ] ) ; } $ model -> load ( $ post ) ; $ transaction = Yii :: $ app -> db -> beginTransaction ( ) ; try { if ( $ model -> save ( ) ) { $ cs = BlogCatPos :: deleteAll ( "post_id = :id" , [ "id" => $ model -> id ] ) ; foreach ( $ category as $ d ) { $ c = new BlogCatPos ( ) ; $ c -> post_id = $ model -> id ; $ c -> category_id = $ d ; $ c -> isdel = 0 ; $ c -> save ( ) ; } $ transaction -> commit ( ) ; return $ this -> redirect ( [ 'view' , 'id' => $ model -> id ] ) ; } else { $ transaction -> rollBack ( ) ; } } catch ( Exception $ e ) { $ transaction -> rollBack ( ) ; } } return $ this -> render ( 'update' , [ 'model' => $ model , ] ) ; }
9458	private function mapAdminRoutes ( ) { $ this -> adminGroup ( function ( ) { $ this -> name ( 'foundation.' ) -> group ( function ( ) { Routes \ Admin \ DashboardRoute :: register ( ) ; Routes \ Admin \ SettingsRoutes :: register ( ) ; Routes \ Admin \ SystemRoutes :: register ( ) ; } ) ; } ) ; }
2003	public static function getNormalizedVersion ( string $ packageName ) : string { $ chunks = explode ( '.' , static :: getVersion ( $ packageName ) ) ; $ chunks += [ 0 , 0 , 0 ] ; if ( \ count ( $ chunks ) > 3 ) { $ chunks = \ array_slice ( $ chunks , 0 , 3 ) ; } return implode ( '.' , $ chunks ) ; }
6126	public function addRole ( $ item ) { if ( ! ( $ item instanceof Role ) ) { if ( is_array ( $ item ) ) { try { $ item = new Role ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate Role. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "Role"!' , E_USER_WARNING ) ; } } $ this -> roles [ ] = $ item ; return $ this ; }
3611	public function getNextScheduledEvent ( $ serial_number = NULL ) { $ schedule = $ this -> getDeviceSchedule ( $ serial_number ) ; $ next_event = FALSE ; $ time = date ( 'H' ) * 60 + date ( 'i' ) ; for ( $ i = 0 , $ day = date ( 'D' ) ; $ i ++ < 7 ; $ day = date ( 'D' , strtotime ( "+ $i days" ) ) ) { if ( isset ( $ schedule [ $ day ] ) ) { foreach ( $ schedule [ $ day ] as $ event ) { if ( $ event -> time > $ time ) { return $ event ; } } } $ time = 0 ; } return $ next_event ; }
5380	public function setValue ( $ value ) { for ( $ i = 0 , $ count = count ( $ this -> options ) ; $ i < $ count ; $ i ++ ) { if ( $ this -> options [ $ i ] -> isValue ( $ value ) ) { $ this -> choice = $ i ; return true ; } } return false ; }
10628	public static function cpuPercentages ( $ cpuCoreInfo1 , $ cpuCoreInfo2 ) { $ cpus = array ( ) ; foreach ( $ cpuCoreInfo1 as $ idx => $ core ) { $ dif = array ( ) ; $ cpu = array ( ) ; $ dif [ 'user' ] = $ cpuCoreInfo2 [ $ idx ] [ 'user' ] - $ cpuCoreInfo1 [ $ idx ] [ 'user' ] ; $ dif [ 'nice' ] = $ cpuCoreInfo2 [ $ idx ] [ 'nice' ] - $ cpuCoreInfo1 [ $ idx ] [ 'nice' ] ; $ dif [ 'sys' ] = $ cpuCoreInfo2 [ $ idx ] [ 'sys' ] - $ cpuCoreInfo1 [ $ idx ] [ 'sys' ] ; $ dif [ 'idle' ] = $ cpuCoreInfo2 [ $ idx ] [ 'idle' ] - $ cpuCoreInfo1 [ $ idx ] [ 'idle' ] ; $ dif [ 'iowait' ] = $ cpuCoreInfo2 [ $ idx ] [ 'iowait' ] - $ cpuCoreInfo1 [ $ idx ] [ 'iowait' ] ; $ dif [ 'irq' ] = $ cpuCoreInfo2 [ $ idx ] [ 'irq' ] - $ cpuCoreInfo1 [ $ idx ] [ 'irq' ] ; $ dif [ 'softirq' ] = $ cpuCoreInfo2 [ $ idx ] [ 'softirq' ] - $ cpuCoreInfo1 [ $ idx ] [ 'softirq' ] ; $ total = array_sum ( $ dif ) ; foreach ( $ dif as $ x => $ y ) { $ cpu [ $ x ] = round ( $ y / $ total * 100 , 2 ) ; } $ cpus [ 'cpu' . $ idx ] = $ cpu ; } return $ cpus ; }
7571	public function get ( $ url = "" ) { try { $ this -> guzzleResponse = $ this -> _client -> request ( 'GET' , $ url ) ; $ this -> _setLinks ( ) ; } catch ( RequestException $ e ) { throw new GreenhouseAPIResponseException ( $ e -> getMessage ( ) , 0 , $ e ) ; } return ( string ) $ this -> guzzleResponse -> getBody ( ) ; }
3842	private function parsePanelSort ( PanelRowInterface $ row ) { if ( ! $ row -> hasElement ( 'sort' ) ) { $ element = new DefaultSortElementInformation ( ) ; $ row -> addElement ( $ element ) ; } }
6297	protected function registerNavigation ( ) { $ this -> app -> singleton ( 'navigation' , function ( $ app ) { $ request = $ app [ 'request' ] ; $ events = $ app [ 'events' ] ; $ url = $ app [ 'url' ] ; $ view = $ app [ 'view' ] ; $ name = 'navigation::bootstrap' ; $ navigation = new Navigation ( $ request , $ events , $ url , $ view , $ name ) ; $ app -> refresh ( 'request' , $ navigation , 'setRequest' ) ; return $ navigation ; } ) ; $ this -> app -> alias ( 'navigation' , Navigation :: class ) ; }
12557	private static function init ( ) : void { static $ inited = false ; if ( ! $ inited ) { if ( ! isset ( $ _SESSION [ 'Booby' ] ) || ! $ _SESSION [ 'Booby' ] ) { $ _SESSION [ 'Booby' ] = [ ] ; } self :: $ store = & $ _SESSION [ 'Booby' ] ; $ inited = true ; } }
4029	protected function getLabelText ( TranslatorInterface $ translator , ModelInterface $ model ) { $ type = $ model -> getProperty ( 'type' ) ; $ label = $ translator -> translate ( 'typenames.' . $ type , 'tl_metamodel_filtersetting' ) ; if ( $ label == 'typenames.' . $ type ) { return $ type ; } return $ label ; }
2603	public function execute ( ) { $ result = $ this -> resultJsonFactory -> create ( ) ; try { $ service = $ this -> api -> checkServiceDetails ( ) ; $ currActiveVersion = $ this -> vcl -> getCurrentVersion ( $ service -> versions ) ; $ dictionaryName = Config :: CONFIG_DICTIONARY_NAME ; $ dictionary = $ this -> api -> getSingleDictionary ( $ currActiveVersion , $ dictionaryName ) ; if ( ! $ dictionary ) { return $ result -> setData ( [ 'status' => false ] ) ; } $ dictionaryItems = $ this -> api -> dictionaryItemsList ( $ dictionary -> id ) ; foreach ( $ dictionaryItems as $ item ) { if ( $ item -> item_key == Config :: CONFIG_DICTIONARY_KEY && $ item -> item_value == 1 ) { return $ result -> setData ( [ 'status' => true ] ) ; } } return $ result -> setData ( [ 'status' => false ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
414	public function setSecurePort ( $ value ) { if ( $ value != $ this -> _securePort ) { $ this -> _securePort = ( int ) $ value ; $ this -> _hostInfo = null ; } }
5751	public function deleteByPrimaryKey ( $ primaryKeyValue , ? string $ returnField = null ) : ? string { if ( null === $ role = $ this -> getObjectById ( ( int ) $ primaryKeyValue ) ) { throw new Exceptions \ QueryResultsNotFoundException ( "Role not found: id $primaryKeyValue" ) ; } if ( ! $ role -> isDeletable ( ( int ) $ primaryKeyValue ) ) { throw new Exceptions \ UnallowedActionException ( "Role in use: id $primaryKeyValue" ) ; } return parent :: deleteByPrimaryKey ( $ primaryKeyValue , $ returnField ) ; }
11939	public function findOne ( $ params = [ ] ) { return $ this -> populateRecord ( $ this -> find ( $ params ) -> one ( $ this -> interface -> db ) ) ; }
4380	protected function visualWhiteSpace ( $ str ) { $ str = \ preg_replace_callback ( '/(\r\n|\r|\n)/' , array ( $ this , 'visualWhiteSpaceCallback' ) , $ str ) ; $ str = \ preg_replace ( '#(<br />)?\n$#' , '' , $ str ) ; $ str = \ str_replace ( "\t" , '<span class="ws_t">' . "\t" . '</span>' , $ str ) ; return $ str ; }
121	private function createAuthFromConfig ( ) { if ( ! $ this -> config -> has ( 'http-basic' ) ) { return $ this -> hasAuth = false ; } $ authConfig = $ this -> config -> get ( 'http-basic' ) ; $ host = parse_url ( $ this -> url , PHP_URL_HOST ) ; if ( isset ( $ authConfig [ $ host ] ) ) { $ this -> credentials [ 'username' ] = $ authConfig [ $ host ] [ 'username' ] ; $ this -> credentials [ 'password' ] = $ authConfig [ $ host ] [ 'password' ] ; return $ this -> hasAuth = true ; } return $ this -> hasAuth = false ; }
4298	public function count ( $ label = null , $ flags = 0 ) { $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) ) ; if ( \ count ( $ args ) == 1 && \ is_int ( $ args [ 0 ] ) ) { $ label = null ; $ flags = $ args [ 0 ] ; } else { $ args = \ array_combine ( array ( 'label' , 'flags' ) , \ array_replace ( array ( null , 0 ) , $ args ) ) ; \ extract ( $ args ) ; } if ( isset ( $ label ) ) { $ dataLabel = ( string ) $ label ; } else { $ callerInfo = $ this -> utilities -> getCallerInfo ( ) ; $ meta = \ array_merge ( array ( 'file' => $ callerInfo [ 'file' ] , 'line' => $ callerInfo [ 'line' ] , ) , $ meta ) ; $ label = 'count' ; $ dataLabel = $ meta [ 'file' ] . ': ' . $ meta [ 'line' ] ; } if ( ! isset ( $ this -> data [ 'counts' ] [ $ dataLabel ] ) ) { $ this -> data [ 'counts' ] [ $ dataLabel ] = 0 ; } if ( ! ( $ flags & self :: COUNT_NO_INC ) ) { $ this -> data [ 'counts' ] [ $ dataLabel ] ++ ; } $ count = $ this -> data [ 'counts' ] [ $ dataLabel ] ; if ( ! ( $ flags & self :: COUNT_NO_OUT ) ) { $ this -> appendLog ( 'count' , array ( ( string ) $ label , $ count , ) , $ meta ) ; } return $ count ; }
5361	protected function createHeaderStatements ( Operation $ operation , $ queryParamVariable ) { $ headerVariable = new Expr \ Variable ( 'headers' ) ; $ headers = [ new Expr \ ArrayItem ( new Scalar \ String_ ( $ operation -> getHost ( ) ) , new Scalar \ String_ ( 'Host' ) ) , ] ; $ produces = $ operation -> getOperation ( ) -> getProduces ( ) ; if ( $ produces && in_array ( "application/json" , $ produces ) ) { $ headers [ ] = new Expr \ ArrayItem ( new Expr \ Array_ ( [ new Expr \ ArrayItem ( new Scalar \ String_ ( "application/json" ) ) , ] ) , new Scalar \ String_ ( 'Accept' ) ) ; } $ consumes = $ operation -> getOperation ( ) -> getProduces ( ) ; if ( $ operation -> getOperation ( ) -> getParameters ( ) && $ consumes ) { $ bodyParameters = array_filter ( $ operation -> getOperation ( ) -> getParameters ( ) , function ( $ parameter ) { return $ parameter instanceof BodyParameter ; } ) ; if ( count ( $ bodyParameters ) > 0 && in_array ( "application/json" , $ consumes ) ) { $ headers [ ] = new Expr \ ArrayItem ( new Scalar \ String_ ( "application/json" ) , new Scalar \ String_ ( 'Content-Type' ) ) ; } } return [ [ new Expr \ Assign ( $ headerVariable , new Expr \ FuncCall ( new Name ( 'array_merge' ) , [ new Arg ( new Expr \ Array_ ( $ headers ) ) , new Arg ( new Expr \ MethodCall ( $ queryParamVariable , 'buildHeaders' , [ new Arg ( new Expr \ Variable ( 'parameters' ) ) ] ) ) ] ) ) ] , $ headerVariable ] ; }
12160	public function getDetailsWidget ( $ objectModel = null ) { if ( is_null ( $ objectModel ) && isset ( Yii :: $ app -> request -> object ) ) { $ objectModel = Yii :: $ app -> request -> object ; } elseif ( is_null ( $ objectModel ) ) { $ objectModel = $ this -> dummyModel ; } $ detailsSection = $ this -> getDetailsSection ( ) ; if ( $ detailsSection === false ) { return false ; } if ( $ detailsSection === true ) { $ detailsSection = '_self' ; } $ detailsWidgetClass = self :: classNamespace ( ) . '\widgets\\' . 'Details' ; $ widgetClass = $ this -> fallbackDetailsWidgetClass ; @ class_exists ( $ detailsWidgetClass ) ; if ( class_exists ( $ detailsWidgetClass , false ) ) { $ widgetClass = $ detailsWidgetClass ; } $ widget = [ 'class' => $ widgetClass ] ; $ widget [ 'owner' ] = $ this ; $ widgetItem = [ 'widget' => $ widget , 'locations' => [ 'self' ] , 'priority' => 1 ] ; $ widgetItem [ 'section' ] = Yii :: $ app -> collectors [ 'sections' ] -> getOne ( $ detailsSection ) ; return $ widgetItem ; }
4633	protected function getHeader ( $ key ) { return isset ( $ this -> headers [ $ key ] ) ? $ this -> headers [ $ key ] : NULL ; }
6976	protected function scheduleSaleContentChangeEvent ( Model \ AdjustmentInterface $ adjustment ) { if ( $ adjustment instanceof Model \ SaleAdjustmentInterface ) { if ( null === $ sale = $ this -> getSaleFromAdjustment ( $ adjustment ) ) { return ; } } elseif ( $ adjustment instanceof Model \ SaleItemAdjustmentInterface ) { if ( null === $ item = $ this -> getItemFromAdjustment ( $ adjustment ) ) { return ; } if ( null === $ sale = $ this -> getSaleFromItem ( $ item ) ) { return ; } } else { throw new InvalidArgumentException ( "Unexpected adjustment type." ) ; } $ this -> persistenceHelper -> scheduleEvent ( $ this -> getSaleChangeEvent ( ) , $ sale ) ; }
3335	private function __runRequest ( $ ch ) { $ data = curl_exec ( $ ch ) ; $ ch_info = curl_getinfo ( $ ch ) ; if ( $ data === false ) { throw new \ Exception ( curl_error ( $ ch ) ) ; } elseif ( $ ch_info [ 'http_code' ] != 200 ) { throw new \ Exception ( 'Unexpected HTTP status code ' . $ ch_info [ 'http_code' ] . '.' . curl_error ( $ ch ) ) ; } curl_close ( $ ch ) ; return json_decode ( $ data ) ; }
5736	private function getShowParameters ( Request $ request ) { $ showingAll = FALSE ; $ start = - 100 ; $ count = - 1 ; if ( $ request -> query -> has ( 'all' ) ) { $ start = 0 ; $ count = - 1 ; $ showingAll = TRUE ; } return [ $ start , $ count , $ showingAll ] ; }
242	public function run ( ) { $ rows = [ ] ; $ i = 0 ; foreach ( $ this -> attributes as $ attribute ) { $ rows [ ] = $ this -> renderAttribute ( $ attribute , $ i ++ ) ; } $ options = $ this -> options ; $ tag = ArrayHelper :: remove ( $ options , 'tag' , 'table' ) ; echo Html :: tag ( $ tag , implode ( "\n" , $ rows ) , $ options ) ; }
5473	public function isMatch ( $ widget ) { if ( method_exists ( $ widget , 'isLabel' ) ) { if ( $ widget -> isLabel ( $ this -> label ) ) { return true ; } } return ( $ widget -> getName ( ) == $ this -> label ) ; }
9064	public function attachShared ( SharedEventManagerInterface $ events ) { $ events -> attach ( 'Zend\Mvc\Application' , MvcEvent :: EVENT_BOOTSTRAP , array ( $ this , 'onMvcBootstrapLast' ) , - 100000 ) ; $ events -> attach ( 'Zend\Mvc\Application' , MvcEvent :: EVENT_RENDER , array ( $ this , 'onRenderAddPathStacks' ) , - 900 ) ; $ events -> attach ( 'Zend\Mvc\Application' , MvcEvent :: EVENT_RENDER , array ( $ this , 'onRenderSpecLayout' ) , - 1000 ) ; }
2378	public static function specialchars ( $ strString , $ blnStripInsertTags = false , $ blnDoubleEncode = false ) { if ( $ blnStripInsertTags ) { $ strString = static :: stripInsertTags ( $ strString ) ; } return htmlspecialchars ( $ strString , ENT_COMPAT , Config :: get ( 'characterSet' ) , $ blnDoubleEncode ) ; }
2684	private function _fetch ( $ uri , $ method = \ Zend_Http_Client :: GET , $ body = '' , $ test = false , $ testApiKey = null , $ logError = true ) { $ apiKey = ( $ test == true ) ? $ testApiKey : $ this -> config -> getApiKey ( ) ; if ( is_array ( $ body ) == true ) { $ body = http_build_query ( $ body ) ; } $ headers = [ self :: FASTLY_HEADER_AUTH . ': ' . $ apiKey , 'Accept: application/json' ] ; $ options = [ ] ; switch ( $ method ) { case \ Zend_Http_Client :: DELETE : $ options [ CURLOPT_CUSTOMREQUEST ] = \ Zend_Http_Client :: DELETE ; break ; case \ Zend_Http_Client :: PUT : $ headers [ ] = 'Content-Type: application/x-www-form-urlencoded' ; $ options [ CURLOPT_CUSTOMREQUEST ] = \ Zend_Http_Client :: PUT ; if ( $ body != '' ) { $ options [ CURLOPT_POSTFIELDS ] = $ body ; } break ; case \ Zend_Http_Client :: PATCH : $ options [ CURLOPT_CUSTOMREQUEST ] = \ Zend_Http_Client :: PATCH ; $ headers [ ] = 'Content-Type: text/json' ; if ( $ body != '' ) { $ options [ CURLOPT_POSTFIELDS ] = $ body ; } break ; } $ client = $ this -> curlFactory -> create ( ) ; $ client -> setOptions ( $ options ) ; $ client -> write ( $ method , $ uri , '1.1' , $ headers , $ body ) ; $ response = $ client -> read ( ) ; $ client -> close ( ) ; $ responseBody = \ Zend_Http_Response :: extractBody ( $ response ) ; $ responseCode = \ Zend_Http_Response :: extractCode ( $ response ) ; $ responseMessage = \ Zend_Http_Response :: extractMessage ( $ response ) ; if ( $ responseCode == '429' ) { throw new LocalizedException ( __ ( $ responseMessage ) ) ; } elseif ( $ responseCode != '200' ) { if ( $ logError == true ) { $ this -> logger -> critical ( 'Return status ' . $ responseCode , $ uri ) ; } return false ; } return json_decode ( $ responseBody ) ; }
1623	public function buildCondition ( $ condition , & $ columns ) { static $ builders = [ 'not' => 'buildNotCondition' , 'and' => 'buildAndCondition' , 'or' => 'buildAndCondition' , 'between' => 'buildBetweenCondition' , 'not between' => 'buildBetweenCondition' , 'in' => 'buildInCondition' , 'not in' => 'buildInCondition' , 'like' => 'buildLikeCondition' , 'not like' => 'buildLikeCondition' , 'or like' => 'buildLikeCondition' , 'or not like' => 'buildLikeCondition' , '>' => 'buildCompareCondition' , '>=' => 'buildCompareCondition' , '<' => 'buildCompareCondition' , '<=' => 'buildCompareCondition' , ] ; if ( ! is_array ( $ condition ) ) { throw new NotSupportedException ( 'Where condition must be an array in redis ActiveRecord.' ) ; } if ( isset ( $ condition [ 0 ] ) ) { $ operator = strtolower ( $ condition [ 0 ] ) ; if ( isset ( $ builders [ $ operator ] ) ) { $ method = $ builders [ $ operator ] ; array_shift ( $ condition ) ; return $ this -> $ method ( $ operator , $ condition , $ columns ) ; } else { throw new Exception ( 'Found unknown operator in query: ' . $ operator ) ; } } else { return $ this -> buildHashCondition ( $ condition , $ columns ) ; } }
9994	public function formatColor ( $ pValue , $ pFormat ) { $ color = null ; $ matches = [ ] ; $ color_regex = '/^\\[[a-zA-Z]+\\]/' ; if ( preg_match ( $ color_regex , $ pFormat , $ matches ) ) { $ color = str_replace ( [ '[' , ']' ] , '' , $ matches [ 0 ] ) ; $ color = strtolower ( $ color ) ; } $ value = htmlspecialchars ( $ pValue ) ; if ( $ color !== null ) { $ value = '<span style="color:' . $ color . '">' . $ value . '</span>' ; } return $ value ; }
2127	protected function fixPaths ( $ content , $ arrFile ) { $ strName = $ arrFile [ 'name' ] ; if ( strpos ( $ strName , $ this -> strWebDir . '/' ) === 0 ) { $ strName = substr ( $ strName , \ strlen ( $ this -> strWebDir ) + 1 ) ; } $ strDirname = \ dirname ( $ strName ) ; $ strGlue = ( $ strDirname != '.' ) ? $ strDirname . '/' : '' ; return preg_replace_callback ( '/url\(("[^"\n]+"|\'[^\'\n]+\'|[^"\'\s()]+)\)/' , function ( $ matches ) use ( $ strDirname , $ strGlue ) { $ strData = $ matches [ 1 ] ; if ( $ strData [ 0 ] == '"' || $ strData [ 0 ] == "'" ) { $ strData = substr ( $ strData , 1 , - 1 ) ; } if ( strncmp ( $ strData , 'data:' , 5 ) === 0 || strncmp ( $ strData , 'http://' , 7 ) === 0 || strncmp ( $ strData , 'https://' , 8 ) === 0 || strncmp ( $ strData , '/' , 1 ) === 0 || strncmp ( $ strData , 'assets/css3pie/' , 15 ) === 0 ) { return $ matches [ 0 ] ; } if ( strncmp ( $ strData , '../' , 3 ) !== 0 ) { $ strData = '../../' . $ strGlue . $ strData ; } else { $ dir = $ strDirname ; while ( strncmp ( $ strData , '../' , 3 ) === 0 ) { $ dir = \ dirname ( $ dir ) ; $ strData = substr ( $ strData , 3 ) ; } $ glue = ( $ dir != '.' ) ? $ dir . '/' : '' ; $ strData = '../../' . $ glue . $ strData ; } $ strQuote = '' ; if ( $ matches [ 1 ] [ 0 ] == "'" || $ matches [ 1 ] [ 0 ] == '"' ) { $ strQuote = $ matches [ 1 ] [ 0 ] ; } if ( preg_match ( '/[(),\s"\']/' , $ strData ) ) { if ( $ matches [ 1 ] [ 0 ] == "'" ) { $ strData = str_replace ( "'" , "\\'" , $ strData ) ; } else { $ strQuote = '"' ; $ strData = str_replace ( '"' , '\"' , $ strData ) ; } } return 'url(' . $ strQuote . $ strData . $ strQuote . ')' ; } , $ content ) ; }
4604	protected function parse ( $ path ) : array { $ fixtures = array_key_exists ( 'FIXTURES' , $ _ENV ) ? $ _ENV [ 'FIXTURES' ] : 'dev' ; $ files = glob ( str_replace ( '{fixtures}' , $ fixtures , $ path ) ) ; if ( ! $ files ) { throw new LogicException ( 'Fixtures path "' . $ path . '" yields no files.' ) ; } $ objects = [ ] ; foreach ( $ files as $ file ) { foreach ( Objects :: parseFile ( $ file ) as $ object ) { $ objects [ ] = $ object ; } } return $ objects ; }
4331	public static function unserializeLog ( $ str ) { $ strStart = 'START DEBUG' ; $ strEnd = 'END DEBUG' ; if ( \ preg_match ( '/' . $ strStart . '[\r\n]+(.+)[\r\n]+' . $ strEnd . '/s' , $ str , $ matches ) ) { $ str = $ matches [ 1 ] ; } $ str = self :: isBase64Encoded ( $ str ) ? \ base64_decode ( $ str ) : false ; if ( $ str && \ function_exists ( 'gzinflate' ) ) { $ strInflated = \ gzinflate ( $ str ) ; if ( $ strInflated ) { $ str = $ strInflated ; } } $ data = \ unserialize ( $ str ) ; return $ data ; }
7462	public function getContent ( string $ name , array $ data = [ ] ) : string { $ cacheName = $ name ; if ( '' == $ name ) { $ this -> isRouteView = true ; $ stack = debug_backtrace ( ) ; foreach ( $ stack as $ item ) { if ( false !== stripos ( $ item [ 'file' ] , DIRECTORY_SEPARATOR . 'Route' . DIRECTORY_SEPARATOR ) ) { $ cacheName = pathinfo ( $ item [ 'file' ] , PATHINFO_DIRNAME ) . '/' . $ name ; $ cacheName = explode ( 'Route' . DIRECTORY_SEPARATOR , $ cacheName ) [ 1 ] ; $ cacheName = 'route_' . str_replace ( [ '/' , '\\' ] , '_' , $ cacheName ) ; break ; } } } $ cacheName .= '_' . $ this -> language . '.html.php' ; $ path = $ this -> packageRoot . '/view/_cache/' . str_replace ( '/' , '_' , $ cacheName ) ; $ exist = file_exists ( $ path ) ; if ( ! $ this -> cache || ! $ exist ) { $ code = $ this -> compile ( $ name . '/view.html.php' , true , true , true ) ; $ code = preg_replace ( [ '/\>[^\S ]+/s' , '/[^\S ]+\</s' , '/(\s)+/s' ] , [ '>' , '<' , '\\1' ] , $ code ) ; if ( $ exist ) { $ fh = fopen ( $ path , 'r+b' ) ; } else { $ fh = fopen ( $ path , 'wb' ) ; } if ( flock ( $ fh , LOCK_EX ) ) { ftruncate ( $ fh , 0 ) ; fwrite ( $ fh , $ code ) ; flock ( $ fh , LOCK_UN ) ; } fclose ( $ fh ) ; } $ fh = fopen ( $ path , 'rb' ) ; if ( flock ( $ fh , LOCK_SH ) ) { $ html = self :: renderTemplate ( $ path , $ data ) ; flock ( $ fh , LOCK_UN ) ; fclose ( $ fh ) ; return $ html ; } throw new \ RuntimeException ( 'Can\'t render template' ) ; }
5401	public function isValidPath ( $ path ) { return ( strncmp ( $ this -> fixPath ( $ path ) , $ this -> getPath ( ) , strlen ( $ this -> getPath ( ) ) ) == 0 ) ; }
11680	public function setPath ( $ path ) { if ( $ path === null ) { throw new PathCanNotBeNull ( ) ; } $ this -> path = rtrim ( $ path , '\\/' ) . '/' ; return $ this ; }
7447	function decrypt ( $ data , $ password ) { $ data = base64_decode ( $ data ) ; $ salt = substr ( $ data , 0 , 16 ) ; $ ct = substr ( $ data , 16 ) ; $ rounds = 3 ; $ data00 = $ password . $ salt ; $ hash = array ( ) ; $ hash [ 0 ] = hash ( 'sha256' , $ data00 , true ) ; $ result = $ hash [ 0 ] ; for ( $ i = 1 ; $ i < $ rounds ; $ i ++ ) { $ hash [ $ i ] = hash ( 'sha256' , $ hash [ $ i - 1 ] . $ data00 , true ) ; $ result .= $ hash [ $ i ] ; } $ key = substr ( $ result , 0 , 32 ) ; $ iv = substr ( $ result , 32 , 16 ) ; return openssl_decrypt ( $ ct , 'AES-256-CBC' , $ key , true , $ iv ) ; }
12884	public function getKeyTranslation ( Model $ foreignObject , $ key = null ) { if ( isset ( $ key ) ) { return $ this -> internalGetKeyTranslation ( $ foreignObject , $ key ) ; } foreach ( $ this -> keys as $ keyName => $ keyField ) { if ( ! empty ( $ foreignObject -> { $ keyField } ) ) { $ key = $ this -> generateKey ( $ foreignObject , $ keyName , $ foreignObject -> { $ keyField } ) ; $ result = $ this -> internalGetKeyTranslation ( $ foreignObject , $ key ) ; if ( ! empty ( $ result ) ) { return $ result ; } } } return false ; }
3376	private function createInstance ( $ file , $ w = null , $ h = null ) { $ container = $ this -> container ; $ webDir = $ container -> getParameter ( 'gregwar_image.web_dir' ) ; $ handlerClass = $ this -> handlerClass ; $ image = new $ handlerClass ( $ file , $ w , $ h , $ this -> throwException , $ this -> fallbackImage ) ; $ image -> setCacheDir ( $ this -> cacheDirectory ) ; $ image -> setCacheDirMode ( $ this -> cacheDirMode ) ; $ image -> setActualCacheDir ( $ webDir . '/' . $ this -> cacheDirectory ) ; if ( $ container -> has ( 'templating.helper.assets' ) ) { $ image -> setFileCallback ( function ( $ file ) use ( $ container ) { return $ container -> get ( 'templating.helper.assets' ) -> getUrl ( $ file ) ; } ) ; } else { $ image -> setFileCallback ( function ( $ file ) use ( $ container ) { return $ this -> assetsPackages -> getUrl ( $ file ) ; } ) ; } return $ image ; }
357	function checkPhpExtensionVersion ( $ extensionName , $ version , $ compare = '>=' ) { if ( ! extension_loaded ( $ extensionName ) ) { return false ; } $ extensionVersion = phpversion ( $ extensionName ) ; if ( empty ( $ extensionVersion ) ) { return false ; } if ( strncasecmp ( $ extensionVersion , 'PECL-' , 5 ) === 0 ) { $ extensionVersion = substr ( $ extensionVersion , 5 ) ; } return version_compare ( $ extensionVersion , $ version , $ compare ) ; }
6842	public function produce ( $ key , $ params = array ( ) , $ enable_reflect = true ) { if ( isset ( $ this -> data [ $ key ] ) ) return $ this -> data [ $ key ] ; if ( isset ( $ this -> caches [ $ key ] ) ) return $ this -> caches [ $ key ] ; if ( isset ( $ this -> objects [ $ key ] ) ) { $ obj = $ this -> get ( $ key ) ; $ concrete = $ obj [ self :: INDEX_CONCRETE ] ; } else { if ( $ this -> MUST_REG || ! $ enable_reflect ) { throw new InjectorException ( "$key not registered" ) ; } else { $ concrete = $ key ; $ not_reg = true ; } } $ result = $ this -> build ( $ concrete , $ params ) ; if ( $ not_reg === true || $ obj [ self :: INDEX_CACHED ] === true ) { $ this -> caches [ $ key ] = $ result ; } return $ result ; }
18	private function getPackageTime ( PackageInterface $ package ) { if ( ! function_exists ( 'proc_open' ) ) { return null ; } $ path = realpath ( $ this -> installationManager -> getInstallPath ( $ package ) ) ; $ sourceType = $ package -> getSourceType ( ) ; $ datetime = null ; if ( $ path && in_array ( $ sourceType , array ( 'git' , 'hg' ) ) ) { $ sourceRef = $ package -> getSourceReference ( ) ? : $ package -> getDistReference ( ) ; switch ( $ sourceType ) { case 'git' : GitUtil :: cleanEnv ( ) ; if ( 0 === $ this -> process -> execute ( 'git log -n1 --pretty=%ct ' . ProcessExecutor :: escape ( $ sourceRef ) , $ output , $ path ) && preg_match ( '{^\s*\d+\s*$}' , $ output ) ) { $ datetime = new \ DateTime ( '@' . trim ( $ output ) , new \ DateTimeZone ( 'UTC' ) ) ; } break ; case 'hg' : if ( 0 === $ this -> process -> execute ( 'hg log --template "{date|hgdate}" -r ' . ProcessExecutor :: escape ( $ sourceRef ) , $ output , $ path ) && preg_match ( '{^\s*(\d+)\s*}' , $ output , $ match ) ) { $ datetime = new \ DateTime ( '@' . $ match [ 1 ] , new \ DateTimeZone ( 'UTC' ) ) ; } break ; } } return $ datetime ? $ datetime -> format ( DATE_RFC3339 ) : null ; }
11429	public function run ( Request $ request ) { $ dispatcher = $ this -> router -> getDispatcher ( ) ; $ routeInfo = $ dispatcher -> dispatch ( $ request -> server ( 'REQUEST_METHOD' ) , $ request -> server ( 'REQUEST_URI_PATH' ) ) ; switch ( $ routeInfo [ 0 ] ) { case Dispatcher :: NOT_FOUND : $ routeInfo = $ this -> getNotFoundRoute ( $ dispatcher ) ; break ; case Dispatcher :: METHOD_NOT_ALLOWED : $ routeInfo = $ this -> runMethodNotAllowed ( $ dispatcher ) ; break ; case Dispatcher :: FOUND : break ; } $ response = $ this -> runRoute ( $ routeInfo ) ; $ response -> send ( ) ; }
5535	public function divideMapNodes ( $ map , $ aspect ) { $ aspect = ! $ aspect ; $ divisions = $ map -> getSize ( ) ; $ total = $ map -> getTotalSize ( ) ; foreach ( $ map -> getChildren ( ) as $ node ) { if ( ! $ node -> isLeaf ( ) ) { $ dist = $ node -> getTotalSize ( ) / $ total * 100 ; } else { $ dist = 1 / $ total * 100 ; } if ( $ aspect ) { $ horiz = $ dist ; $ vert = 100 ; } else { $ horiz = 100 ; $ vert = $ dist ; } $ this -> paintRectangleStart ( $ node , $ horiz , $ vert ) ; $ this -> divideMapNodes ( $ node , $ aspect ) ; $ this -> paintRectangleEnd ( ) ; } }
551	public function actionFlush ( ) { $ cachesInput = func_get_args ( ) ; if ( empty ( $ cachesInput ) ) { throw new Exception ( 'You should specify cache components names' ) ; } $ caches = $ this -> findCaches ( $ cachesInput ) ; $ cachesInfo = [ ] ; $ foundCaches = array_keys ( $ caches ) ; $ notFoundCaches = array_diff ( $ cachesInput , array_keys ( $ caches ) ) ; if ( $ notFoundCaches ) { $ this -> notifyNotFoundCaches ( $ notFoundCaches ) ; } if ( ! $ foundCaches ) { $ this -> notifyNoCachesFound ( ) ; return ExitCode :: OK ; } if ( ! $ this -> confirmFlush ( $ foundCaches ) ) { return ExitCode :: OK ; } foreach ( $ caches as $ name => $ class ) { $ cachesInfo [ ] = [ 'name' => $ name , 'class' => $ class , 'is_flushed' => $ this -> canBeFlushed ( $ class ) ? Yii :: $ app -> get ( $ name ) -> flush ( ) : false , ] ; } $ this -> notifyFlushed ( $ cachesInfo ) ; }
1328	public function get ( $ key , $ default = null ) { if ( $ option = self :: where ( 'key' , $ key ) -> first ( ) ) { return $ option -> value ; } return $ default ; }
3395	protected function attemptLogin ( Request $ request ) { if ( $ this -> guard ( ) -> validate ( $ this -> credentials ( $ request ) ) ) { $ user = $ this -> guard ( ) -> getLastAttempted ( ) ; if ( ! is_null ( $ user -> confirmed_at ) ) { return $ this -> baseAttemptLogin ( $ request ) ; } session ( [ 'confirmation_user_id' => $ user -> getKey ( ) ] ) ; throw ValidationException :: withMessages ( [ 'confirmation' => [ __ ( 'confirmation::confirmation.not_confirmed' , [ 'resend_link' => route ( 'auth.resend_confirmation' ) ] ) ] ] ) ; } return false ; }
9207	public function importTable ( Table $ Table , $ records , array $ options = [ ] ) { $ defaultOptions = [ 'checkRules' => true , 'checkExisting' => true , ] ; $ options = $ options + $ defaultOptions ; foreach ( $ records as $ record ) { $ action = ( $ record -> isNew ( ) ? 'Create' : 'Update' ) ; $ result = $ Table -> save ( $ record , $ options ) ; $ key = $ this -> findKey ( $ Table , $ record ) ; if ( $ result ) { $ this -> verbose ( "<success>{$Table->alias()} ({$key}): {$action} successful.</success>" ) ; } else { $ this -> quiet ( "<warning>{$Table->alias()} ({$key}): {$action} failed.</warning>" ) ; $ this -> printValidationErrors ( $ Table -> alias ( ) , $ this -> findKey ( $ Table , $ record ) , $ record -> errors ( ) ) ; } } }
5147	protected function getOpenedEmail ( $ fetchNextUnread = FALSE ) { if ( $ fetchNextUnread || $ this -> openedEmail == NULL ) { $ this -> openNextUnreadEmail ( ) ; } return $ this -> openedEmail ; }
10894	public function get ( $ name ) { return isset ( $ this -> uris [ $ name ] ) ? $ this -> uris [ $ name ] : null ; }
11678	protected function load ( $ locale , $ fileName ) { if ( $ this -> isFileLoaded ( $ locale , $ fileName ) === true ) { return true ; } $ startTime = microtime ( true ) ; $ file = $ this -> getPath ( ) . '/' . $ locale . '/' . $ fileName . '.php' ; if ( file_exists ( $ file ) === false ) { throw new FileNotFound ( $ this -> getPath ( ) , $ locale , $ fileName ) ; } $ translationKeys = include $ file ; if ( $ translationKeys === null || is_array ( $ translationKeys ) === false ) { throw new InvalidTranslationFile ( $ this -> getPath ( ) , $ locale , $ fileName ) ; } if ( array_key_exists ( $ locale , $ this -> translations ) === false ) { $ this -> translations [ $ locale ] = [ ] ; } $ this -> translations [ $ locale ] [ $ fileName ] = $ translationKeys ; $ this -> log ( 'Language loaded: ' . $ locale . '/' . $ fileName . ' (' . number_format ( microtime ( true ) - $ startTime , 2 , ',' , '.' ) . ')' ) ; return true ; }
11052	public static function sprintt ( $ datatree , $ containers , $ entry = 'main' , $ hsr = _ETS_SOURCE_READ , $ hcr = _ETS_CACHE_READ , $ hcw = _ETS_CACHE_WRITE ) { $ ets = new _ets ( $ containers , $ hsr , $ hcr , $ hcw ) ; return $ ets -> build_all ( $ datatree , $ entry ) ; }
4608	public function createStatus ( string $ status , array $ options = null ) : array { $ url = '/statuses' ; if ( empty ( $ options ) ) { $ options = [ ] ; } $ params = array_merge ( [ 'status' => $ status , ] , $ options ) ; return $ this -> post ( $ url , $ params ) ; }
12110	public function deletePage ( $ id ) { $ this -> getPage ( $ id ) ; unset ( $ this -> pages [ $ id ] ) ; $ this -> persist ( ) ; }
9265	public function setProviders ( ) { $ services = $ this -> container [ 'services' ] ?? null ; if ( is_array ( $ services ) ) { foreach ( $ services as $ service ) { $ service :: register ( $ this -> container ) ; $ service :: boot ( $ this -> container ) ; } } }
5442	protected function dispatchTokens ( $ unmatched , $ matched , $ mode = false ) { if ( ! $ this -> invokeParser ( $ unmatched , LEXER_UNMATCHED ) ) { return false ; } if ( is_bool ( $ mode ) ) { return $ this -> invokeParser ( $ matched , LEXER_MATCHED ) ; } if ( $ this -> isModeEnd ( $ mode ) ) { if ( ! $ this -> invokeParser ( $ matched , LEXER_EXIT ) ) { return false ; } return $ this -> mode -> leave ( ) ; } if ( $ this -> isSpecialMode ( $ mode ) ) { $ this -> mode -> enter ( $ this -> decodeSpecial ( $ mode ) ) ; if ( ! $ this -> invokeParser ( $ matched , LEXER_SPECIAL ) ) { return false ; } return $ this -> mode -> leave ( ) ; } $ this -> mode -> enter ( $ mode ) ; return $ this -> invokeParser ( $ matched , LEXER_ENTER ) ; }
11366	public static function formatText ( $ txt = '' , $ type = 'plain' , $ spaces = false ) { switch ( $ type ) { case 'ascii' : $ _txt = '' ; if ( $ spaces == true ) { $ txt = str_replace ( ' ' , '_' , $ txt ) ; } for ( $ i = 0 ; $ i < strlen ( $ txt ) ; $ i ++ ) { $ _txt .= self :: charAscii ( $ txt [ $ i ] ) ; } $ txt = $ _txt ; break ; default : break ; } $ mailer = Mailer :: getInstance ( ) ; $ limit = $ mailer -> getOption ( 'wordwrap_limit' ) ; $ formated = '' ; foreach ( explode ( "\n" , $ txt ) as $ _line ) { $ _line = trim ( $ _line ) ; if ( strlen ( $ _line ) > $ limit ) { $ _line = wordwrap ( $ _line , $ limit , Mailer :: $ LINE_ENDING ) ; } if ( strlen ( $ _line ) ) { $ formated .= $ _line . Mailer :: $ LINE_ENDING ; } } return $ formated ; }
672	public function upgrade ( ) { $ owner = $ this -> owner ; if ( $ owner -> getIsNewRecord ( ) ) { throw new InvalidCallException ( 'Upgrading the model version is not possible on a new record.' ) ; } $ lock = $ this -> getLockAttribute ( ) ; $ version = $ owner -> $ lock ? : 0 ; $ owner -> updateAttributes ( [ $ lock => $ version + 1 ] ) ; }
10536	public function extractHeaders ( ) { $ headers = [ ] ; $ requestHeaders = array_keys ( $ this -> cors ) ; foreach ( $ requestHeaders as $ headerField ) { $ serverField = $ this -> headerizeToPhp ( $ headerField ) ; $ headerData = isset ( $ _SERVER [ $ serverField ] ) ? $ _SERVER [ $ serverField ] : null ; if ( $ headerData !== null ) { $ headers [ $ headerField ] = $ headerData ; } } return $ headers ; }
263	public function close ( ) { if ( $ this -> getIsActive ( ) ) { $ this -> fields = $ this -> composeFields ( ) ; YII_DEBUG ? session_write_close ( ) : @ session_write_close ( ) ; } }
9889	public static function json ( $ response ) { $ body = self :: toString ( $ response ) ; $ data = json_decode ( $ body , true ) ; if ( JSON_ERROR_NONE !== json_last_error ( ) ) { throw new RuntimeException ( 'Unable to parse response body into JSON: ' . json_last_error ( ) ) ; } return $ data === null ? [ ] : $ data ; }
8831	protected function getCheckboxCheckedState ( $ name , $ value , $ checked ) { $ posted = $ this -> getValueAttribute ( $ name , $ checked ) ; if ( is_array ( $ posted ) ) { return in_array ( $ value , $ posted ) ; } else { return ( bool ) $ posted ; } }
7677	function TbsSearchInFiles ( $ files , $ str , $ returnFirstFound = true ) { $ keys_ok = array ( ) ; $ keys_todo = array ( ) ; $ idx_keys = array ( ) ; foreach ( $ files as $ k => $ f ) { $ idx = $ this -> FileGetIdx ( $ f ) ; if ( $ idx !== false ) { $ keys_todo [ $ k ] = $ idx ; $ idx_keys [ $ idx ] = $ k ; } } if ( ( $ this -> TbsCurrIdx !== false ) && isset ( $ idx_keys [ $ this -> TbsCurrIdx ] ) ) { $ key = $ idx_keys [ $ this -> TbsCurrIdx ] ; $ p = strpos ( $ this -> TBS -> Source , $ str ) ; if ( $ p !== false ) { $ keys_ok [ ] = array ( 'key' => $ key , 'idx' => $ this -> TbsCurrIdx , 'src' => & $ this -> TBS -> Source , 'pos' => $ p , 'curr' => true ) ; if ( $ returnFirstFound ) return $ keys_ok [ 0 ] ; } unset ( $ keys_todo [ $ key ] ) ; } foreach ( $ this -> TbsStoreLst as $ idx => $ s ) { if ( ( $ idx !== $ this -> TbsCurrIdx ) && isset ( $ idx_keys [ $ idx ] ) ) { $ key = $ idx_keys [ $ idx ] ; $ p = strpos ( $ s [ 'src' ] , $ str ) ; if ( $ p !== false ) { $ keys_ok [ ] = array ( 'key' => $ key , 'idx' => $ idx , 'src' => & $ s [ 'src' ] , 'pos' => $ p , 'curr' => false ) ; if ( $ returnFirstFound ) return $ keys_ok [ 0 ] ; } unset ( $ keys_todo [ $ key ] ) ; } } foreach ( $ keys_todo as $ key => $ idx ) { $ txt = $ this -> FileRead ( $ idx ) ; $ p = strpos ( $ txt , $ str ) ; if ( $ p !== false ) { $ keys_ok [ ] = array ( 'key' => $ key , 'idx' => $ idx , 'src' => $ txt , 'pos' => $ p , 'curr' => false ) ; if ( $ returnFirstFound ) return $ keys_ok [ 0 ] ; } } if ( $ returnFirstFound ) { return array ( 'key' => false , 'idx' => false , 'src' => false , 'pos' => false , 'curr' => false ) ; } else { return $ keys_ok ; } }
7492	public function trim ( $ characters = null ) { $ this -> string = trim ( $ this -> string , $ characters ) ; return $ this ; }
2346	public function close ( ) { if ( \ is_resource ( $ this -> resFile ) ) { $ this -> Files -> fclose ( $ this -> resFile ) ; } if ( ! file_exists ( $ this -> strRootDir . '/' . $ this -> strFile ) ) { if ( ( $ strFolder = \ dirname ( $ this -> strFile ) ) == '.' ) { $ strFolder = '' ; } if ( ! is_dir ( $ this -> strRootDir . '/' . $ strFolder ) ) { new Folder ( $ strFolder ) ; } } $ return = $ this -> Files -> rename ( $ this -> strTmp , $ this -> strFile ) ; $ this -> strTmp = null ; if ( Dbafs :: shouldBeSynchronized ( $ this -> strFile ) ) { $ this -> objModel = Dbafs :: addResource ( $ this -> strFile ) ; } return $ return ; }
10539	protected function _setMany ( $ data ) { $ data = $ this -> _normalizeIterable ( $ data ) ; $ store = $ this -> _getDataStore ( ) ; try { $ this -> _containerSetMany ( $ store , $ data ) ; } catch ( InvalidArgumentException $ e ) { throw $ this -> _createOutOfRangeException ( $ this -> __ ( 'Invalid store' ) , null , $ e , $ store ) ; } }
8725	public function translationModel ( ) { $ translation = new TranslationModel ( ) ; $ translation -> setConnection ( $ this -> getI18nConnection ( ) ) ; $ translation -> setTable ( $ this -> getI18nTable ( ) ) ; $ translation -> setKeyName ( $ this -> getForeignKey ( ) ) ; $ translation -> setLocaleKey ( $ this -> getLocaleKey ( ) ) ; if ( $ attributes = $ this -> translatableAttributes ( ) ) { $ translation -> fillable ( array_intersect ( $ attributes , $ this -> getFillable ( ) ) ) ; } return $ translation ; }
6826	protected function getUnpaidAccountNumber ( CustomerGroupInterface $ group , string $ origin ) { foreach ( $ this -> accounts as $ account ) { if ( $ account -> getType ( ) !== AccountingTypes :: TYPE_UNPAID ) { continue ; } foreach ( $ account -> getCustomerGroups ( ) as $ g ) { if ( $ g -> getId ( ) === $ group -> getId ( ) ) { return $ account -> getNumber ( ) ; } } } foreach ( $ this -> accounts as $ account ) { if ( $ account -> getType ( ) !== AccountingTypes :: TYPE_UNPAID ) { continue ; } if ( 0 < $ account -> getCustomerGroups ( ) -> count ( ) ) { continue ; } return $ account -> getNumber ( ) ; } throw new LogicException ( sprintf ( "No unpaid account number configured for customer group '%s' (%s)" , $ group -> getName ( ) , $ origin ) ) ; }
10612	public function confirmedAction ( ) { $ user = $ this -> getUser ( ) ; if ( ! is_object ( $ user ) || ! $ user instanceof UserInterface ) { throw $ this -> createAccessDeniedException ( 'This user does not have access to this section.' ) ; } return $ this -> render ( "@MikyUser/Frontend/Registration/confirmed.html.twig" , array ( 'user' => $ user , ) ) ; }
3822	public function purge ( ) { $ fileSystem = new Filesystem ( ) ; $ fileSystem -> remove ( $ this -> cacheDir ) ; $ this -> logger -> log ( LogLevel :: INFO , 'Purged the MetaModels cache' , [ 'contao' => new ContaoContext ( __METHOD__ , TL_CRON ) ] ) ; }
5239	private function paramType ( \ ReflectionMethod $ method , \ ReflectionParameter $ param ) { $ methodAnnotations = annotationsOf ( $ method ) ; $ paramAnnotations = annotationsOf ( $ param ) ; $ paramClass = $ param -> getClass ( ) ; if ( null !== $ paramClass ) { if ( $ methodAnnotations -> contain ( 'Property' ) || $ paramAnnotations -> contain ( 'Property' ) ) { return PropertyBinding :: TYPE ; } return $ paramClass -> getName ( ) ; } if ( $ methodAnnotations -> contain ( 'List' ) || $ paramAnnotations -> contain ( 'List' ) ) { return ListBinding :: TYPE ; } if ( $ methodAnnotations -> contain ( 'Map' ) || $ paramAnnotations -> contain ( 'Map' ) ) { return MapBinding :: TYPE ; } if ( $ methodAnnotations -> contain ( 'Property' ) || $ paramAnnotations -> contain ( 'Property' ) ) { return PropertyBinding :: TYPE ; } return ConstantBinding :: TYPE ; }
3810	protected function translateRows ( $ rows ) { $ metaModel = $ this -> getMetaModel ( ) ; $ activeLegend = $ this -> translateLegend ( array ( 'legendtitle' => $ metaModel -> getName ( ) , 'legendhide' => false ) , $ metaModel ) ; $ activeLegendId = null ; $ columnNames = array ( ) ; foreach ( $ rows as $ row ) { if ( $ row [ 'dcatype' ] != 'attribute' ) { continue ; } $ attribute = $ metaModel -> getAttributeById ( $ row [ 'attr_id' ] ) ; if ( $ attribute ) { $ columnNames [ $ row [ 'id' ] ] = $ attribute -> getColName ( ) ; } } $ this -> propertyMap = $ columnNames ; $ this -> propertyMap2 = array_flip ( $ columnNames ) ; foreach ( $ rows as $ row ) { switch ( $ row [ 'dcatype' ] ) { case 'legend' : $ activeLegend = $ this -> translateLegend ( $ row , $ metaModel ) ; $ activeLegendId = $ row [ 'id' ] ; break ; case 'attribute' : $ exists = $ this -> translateProperty ( $ row , $ metaModel , $ activeLegend ) ; if ( $ exists && $ activeLegendId ) { $ this -> applyLegendConditions ( $ row [ 'id' ] , $ activeLegendId ) ; } break ; default : throw new \ RuntimeException ( 'Unknown palette rendering mode ' . $ row [ 'dcatype' ] ) ; } } }
51	public function addRepository ( RepositoryInterface $ repository ) { if ( $ repository instanceof self ) { foreach ( $ repository -> getRepositories ( ) as $ repo ) { $ this -> addRepository ( $ repo ) ; } } else { $ this -> repositories [ ] = $ repository ; } }
11330	public function getMultiline ( ) { if ( is_null ( $ this -> _multiline ) ) { $ this -> _multiline = MultilineDetector :: test ( $ this -> fieldSchema ) ; } return $ this -> _multiline ; }
4702	protected function runHelp ( InputInterface $ input , OutputInterface $ output ) { $ help = $ this -> getApplication ( ) -> find ( 'help' ) ; $ help -> setCommand ( $ this ) ; $ help -> run ( $ input , $ output ) ; }
11384	protected function resolve ( ) { if ( $ this -> resolved ) { return ; } $ this -> resolved = [ ] ; foreach ( $ this -> stages as $ stage ) { $ this -> resolved [ ] = $ this -> build ( $ stage ) ; } }
6312	public function getTables ( $ schemaName = null ) { $ getTablesCommand = $ this -> container -> get ( 'rentgen.get_tables' ) ; if ( null !== $ schemaName ) { $ getTablesCommand -> setSchemaName ( $ schemaName ) ; } return $ getTablesCommand -> execute ( ) ; }
1360	public static function custom ( $ mediaType ) : self { if ( ! $ mediaType instanceof MediaTypeInterface ) { $ mediaType = MediaType :: parse ( 0 , $ mediaType ) ; } return new self ( $ mediaType , null ) ; }
4148	protected function findExceptions ( $ response ) { $ response = $ response [ 'body' ] ; $ data = json_decode ( $ response , true ) ; if ( isset ( $ response [ 0 ] ) && $ response [ 0 ] !== '{' && $ response [ 0 ] !== '[' && ! $ data ) { if ( strpos ( $ response , 'oauth_token=' ) !== false ) { parse_str ( $ response , $ data ) ; } if ( empty ( $ data ) || ! is_array ( $ data ) ) { throw new TwitterException ( $ response , 0 ) ; } return json_encode ( $ data ) ; } if ( ! empty ( $ data [ 'errors' ] ) || ! empty ( $ data [ 'error' ] ) ) { if ( ! empty ( $ data [ 'errors' ] ) ) { $ data = current ( $ data [ 'errors' ] ) ; } if ( empty ( $ data [ 'message' ] ) && ! empty ( $ data [ 'error' ] ) ) { $ data [ 'message' ] = $ data [ 'error' ] ; } if ( ! isset ( $ data [ 'code' ] ) || empty ( $ data [ 'code' ] ) ) { $ data [ 'code' ] = 0 ; } throw new TwitterException ( $ data [ 'message' ] , $ data [ 'code' ] ) ; } unset ( $ data ) ; return $ response ; }
10934	protected function is_php ( $ version ) { static $ _is_php ; $ version = ( string ) $ version ; if ( ! isset ( $ _is_php [ $ version ] ) ) { $ _is_php [ $ version ] = version_compare ( PHP_VERSION , $ version , '>=' ) ; } return $ _is_php [ $ version ] ; }
5335	protected function sha512Asn1 ( $ data ) { $ digest = hash ( 'sha512' , $ data , true ) ; $ asn1 = chr ( 0x30 ) . chr ( 0x51 ) ; $ asn1 .= chr ( 0x30 ) . chr ( 0x0d ) ; $ asn1 .= chr ( 0x06 ) . chr ( 0x09 ) ; $ asn1 .= chr ( 0x60 ) . chr ( 0x86 ) . chr ( 0x48 ) . chr ( 0x01 ) . chr ( 0x65 ) ; $ asn1 .= chr ( 0x03 ) . chr ( 0x04 ) ; $ asn1 .= chr ( 0x02 ) . chr ( 0x03 ) ; $ asn1 .= chr ( 0x05 ) . chr ( 0x00 ) ; $ asn1 .= chr ( 0x04 ) . chr ( 0x40 ) ; $ asn1 .= $ digest ; return $ asn1 ; }
12703	public function publishAction ( Request $ request , Application $ app ) { $ options = array ( "request" => $ request , "page_manager" => $ app [ "red_kite_cms.page_manager" ] , "username" => $ this -> fetchUsername ( $ app [ "security" ] , $ app [ "red_kite_cms.configuration_handler" ] ) , ) ; return parent :: publish ( $ options ) ; }
32	public function addRule ( Rule $ rule ) { $ this -> addReason ( spl_object_hash ( $ rule ) , array ( 'rule' => $ rule , 'job' => $ rule -> getJob ( ) , ) ) ; }
7650	public function unlink ( $ path ) { $ this -> getStorageClient ( $ path ) -> deleteBlob ( $ this -> getContainerName ( $ path ) , $ this -> getFileName ( $ path ) ) ; clearstatcache ( true , $ path ) ; return true ; }
12015	private function assertClient ( ClientInterface $ client ) { if ( $ client -> getConnection ( ) instanceof AggregateConnectionInterface ) { throw new NotSupportedException ( 'Cannot initialize a MULTI/EXEC transaction over aggregate connections.' ) ; } if ( ! $ client -> getCommandFactory ( ) -> supportsCommands ( array ( 'MULTI' , 'EXEC' , 'DISCARD' ) ) ) { throw new NotSupportedException ( 'MULTI, EXEC and DISCARD are not supported by the current command factory.' ) ; } }
6057	public function removeMediaFromFolder ( $ folderId , $ mediaId ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> delete ( 'v1/folders/' . $ folderId . '/media/' . $ mediaId . '' , $ parameters ) ; return $ result ; }
8062	public function destroy ( $ maxWaitSecs = null ) { if ( $ maxWaitSecs === null ) { $ maxWaitSecs = $ this -> child_timeout_sec ; } if ( ! $ this -> created ) { throw new WorkerPoolException ( 'The pool hasn\'t yet been created.' ) ; } $ this -> created = FALSE ; if ( $ this -> parentPid === getmypid ( ) ) { $ maxWaitSecs = ( ( int ) $ maxWaitSecs ) * 2 ; if ( $ maxWaitSecs <= 1 ) { $ maxWaitSecs = 2 ; } foreach ( $ this -> workerProcesses as $ processDetails ) { try { $ processDetails -> getSocket ( ) -> send ( array ( 'cmd' => 'exit' ) ) ; } catch ( \ Exception $ e ) { } } for ( $ i = 0 ; $ i < $ maxWaitSecs ; $ i ++ ) { usleep ( 500000 ) ; pcntl_signal_dispatch ( ) ; if ( $ this -> workerPoolSize == 0 ) { break ; } } foreach ( $ this -> signals as $ signo ) { pcntl_signal ( $ signo , SIG_DFL ) ; } $ this -> workerProcesses -> killAllProcesses ( ) ; usleep ( 500000 ) ; $ this -> reaper ( ) ; $ this -> semaphore -> destroy ( ) ; unset ( $ this -> workerProcesses ) ; } return $ this ; }
70	public function createLoader ( array $ autoloads ) { $ loader = new ClassLoader ( ) ; if ( isset ( $ autoloads [ 'psr-0' ] ) ) { foreach ( $ autoloads [ 'psr-0' ] as $ namespace => $ path ) { $ loader -> add ( $ namespace , $ path ) ; } } if ( isset ( $ autoloads [ 'psr-4' ] ) ) { foreach ( $ autoloads [ 'psr-4' ] as $ namespace => $ path ) { $ loader -> addPsr4 ( $ namespace , $ path ) ; } } if ( isset ( $ autoloads [ 'classmap' ] ) ) { $ blacklist = null ; if ( ! empty ( $ autoloads [ 'exclude-from-classmap' ] ) ) { $ blacklist = '{(' . implode ( '|' , $ autoloads [ 'exclude-from-classmap' ] ) . ')}' ; } foreach ( $ autoloads [ 'classmap' ] as $ dir ) { try { $ loader -> addClassMap ( $ this -> generateClassMap ( $ dir , $ blacklist , null , false ) ) ; } catch ( \ RuntimeException $ e ) { $ this -> io -> writeError ( '<warning>' . $ e -> getMessage ( ) . '</warning>' ) ; } } } return $ loader ; }
12035	private function createMethodGenerator ( $ methodName , $ body , DocBlockGenerator $ docBlock , $ parameterInfoArray , $ returnType = null ) { $ parameters = [ ] ; foreach ( $ parameterInfoArray as $ parameterInfo ) { $ parameters [ ] = new ParameterGenerator ( $ parameterInfo [ 0 ] , $ parameterInfo [ 1 ] ) ; } $ methodGenerator = new MethodGenerator ( $ methodName ) ; $ methodGenerator -> setParameters ( $ parameters ) ; if ( $ returnType != null ) { if ( is_array ( $ returnType ) ) { $ returnType = implode ( '|' , $ returnType ) ; } $ tags [ ] = new GenericTag ( 'return' , $ returnType ) ; $ docBlock -> setTags ( $ tags ) ; } $ methodGenerator -> setDocBlock ( $ docBlock ) ; $ methodGenerator -> setBody ( $ body ) ; return $ methodGenerator ; }
4182	public static function instance ( ) { switch ( func_num_args ( ) ) { case func_num_args ( ) == 0 : return new static ( ) ; case func_num_args ( ) == 1 : return new static ( func_get_arg ( 0 ) ) ; case func_num_args ( ) == 2 : return new static ( func_get_arg ( 0 ) , func_get_arg ( 1 ) ) ; case func_num_args ( ) == 3 : return new static ( func_get_arg ( 0 ) , func_get_arg ( 1 ) , func_get_arg ( 2 ) ) ; case func_num_args ( ) == 4 : return new static ( func_get_arg ( 0 ) , func_get_arg ( 1 ) , func_get_arg ( 2 ) , func_get_arg ( 3 ) ) ; case func_num_args ( ) == 5 : return new static ( func_get_arg ( 0 ) , func_get_arg ( 1 ) , func_get_arg ( 2 ) , func_get_arg ( 3 ) , func_get_arg ( 4 ) ) ; default : throw new Exception ( 'Unable to instantiate class with given arguments' ) ; } }
5827	public function buildUrl ( $ url , array $ query ) { if ( ! empty ( $ query ) ) { $ queryString = http_build_query ( $ query ) ; $ url .= '?' . $ queryString ; } return $ url ; }
7127	public function getDetails ( ) { return [ 'valid' => $ this -> valid , 'country' => $ this -> country , 'number' => $ this -> number , 'name' => $ this -> name , 'address' => $ this -> address , 'date' => $ this -> date , ] ; }
2490	protected function processConnectionConfiguration ( ContainerBuilder $ container , array $ config ) { $ alias = $ this -> getAlias ( ) ; if ( isset ( $ config [ 'default_connection' ] ) ) { $ container -> setParameter ( "{$alias}.default_connection" , $ config [ 'default_connection' ] ) ; } elseif ( ! empty ( $ config [ 'connections' ] ) ) { reset ( $ config [ 'connections' ] ) ; $ container -> setParameter ( "{$alias}.default_connection" , key ( $ config [ 'connections' ] ) ) ; } foreach ( $ config [ 'connections' ] as $ name => $ params ) { $ this -> configureSearchServices ( $ container , $ name , $ params ) ; $ this -> configureBoostMap ( $ container , $ name , $ params ) ; $ this -> configureIndexingDepth ( $ container , $ name , $ params ) ; $ container -> setParameter ( "$alias.connection.$name" , $ params ) ; } foreach ( $ config [ 'endpoints' ] as $ name => $ params ) { $ this -> defineEndpoint ( $ container , $ name , $ params ) ; } $ searchEngineDef = $ container -> findDefinition ( self :: ENGINE_ID ) ; $ searchEngineDef -> setFactory ( [ new Reference ( 'ezpublish.solr.engine_factory' ) , 'buildEngine' ] ) ; $ boostFactorProviderDef = $ container -> findDefinition ( self :: BOOST_FACTOR_PROVIDER_ID ) ; $ boostFactorProviderDef -> setFactory ( [ new Reference ( 'ezpublish.solr.boost_factor_provider_factory' ) , 'buildService' ] ) ; }
7279	public function file ( $ name = null ) { return ! $ name ? $ this -> files : ( $ this -> files [ $ name ] ?? null ) ; }
9914	public function create ( $ modelName , ModelConfig $ config = null ) { $ menu = new Menu ( ) ; $ addMenuItem = new LinkMenuItem ( ) ; $ addMenuItem -> setText ( Lang :: trans ( 'Add' ) ) ; $ addMenuItem -> setIcon ( Icons :: ion_plus ) ; $ addMenuItem -> setTarget ( URL :: route ( $ this -> aujaRouter -> getCreateName ( $ modelName ) ) ) ; $ menu -> addMenuItem ( $ addMenuItem ) ; $ spacerMenuItem = new SpacerMenuItem ( ) ; $ spacerMenuItem -> setText ( Lang :: trans ( $ modelName ) ) ; $ menu -> addMenuItem ( $ spacerMenuItem ) ; $ resourceMenuItem = new ResourceMenuItem ( ) ; $ resourceMenuItem -> setTarget ( URL :: route ( $ this -> aujaRouter -> getIndexName ( $ modelName ) ) ) ; $ model = $ this -> aujaConfigurator -> getModel ( $ modelName ) ; if ( $ this -> aujaConfigurator -> isSearchable ( $ model , $ config ) ) { $ target = urldecode ( URL :: route ( $ this -> aujaRouter -> getIndexName ( $ modelName ) , [ 'q' => '%s' ] ) ) ; $ property = new Searchable ( $ target ) ; $ resourceMenuItem -> addProperty ( $ property ) ; } $ menu -> addMenuItem ( $ resourceMenuItem ) ; return $ menu ; }
10500	public function lte ( $ value ) { $ value = Cast :: Float ( $ value ) ; if ( $ this -> value !== null && $ this -> value <= $ value ) { return true ; } return false ; }
14	public function copyTo ( $ file , $ target ) { if ( $ this -> enabled ) { $ file = preg_replace ( '{[^' . $ this -> whitelist . ']}i' , '-' , $ file ) ; if ( file_exists ( $ this -> root . $ file ) ) { try { touch ( $ this -> root . $ file , filemtime ( $ this -> root . $ file ) , time ( ) ) ; } catch ( \ ErrorException $ e ) { Silencer :: call ( 'touch' , $ this -> root . $ file ) ; } $ this -> io -> writeError ( 'Reading ' . $ this -> root . $ file . ' from cache' , true , IOInterface :: DEBUG ) ; return copy ( $ this -> root . $ file , $ target ) ; } } return false ; }
6507	public function deserializeReturnValue ( $ type , $ data ) { $ jobType = $ this -> registry -> get ( $ type ) ; return $ this -> serializer -> deserialize ( $ data , $ jobType -> getReturnType ( ) , 'json' , $ this -> getResponseDeserializationContext ( $ jobType ) ) ; }
2618	public function getSiteLocation ( ) { $ countryId = $ this -> scopeConfig -> getValue ( 'general/store_information/country_id' ) ; if ( $ countryId ) { $ country = $ this -> countryFactory -> create ( ) -> loadByCode ( $ countryId ) ; $ countryName = $ country -> getName ( ) ; } else { $ countryName = 'Unknown country' ; } $ regionId = $ this -> scopeConfig -> getValue ( 'general/store_information/region_id' ) ; $ regionName = 'Unknown region' ; if ( $ regionId ) { $ region = $ this -> regionFactory -> create ( ) ; $ region = $ region -> load ( $ regionId ) ; if ( $ region -> getId ( ) ) { $ regionName = $ region -> getName ( ) ; } } $ postCode = $ this -> scopeConfig -> getValue ( 'general/store_information/postcode' ) ; if ( ! $ postCode ) { $ postCode = 'Unknown zip code' ; } return $ countryName . ' | ' . $ regionName . ' | ' . $ postCode ; }
8202	protected function registerCommand ( $ command ) { $ abstract = "command.artisan.beans.$command" ; $ commandClass = "\\Pvm\\ArtisanBeans\\Console\\{$command}Command" ; $ this -> app -> singleton ( $ abstract , function ( $ app ) use ( $ commandClass ) { return new $ commandClass ( ) ; } ) ; $ this -> commands ( $ abstract ) ; }
3320	public function getValidValues ( ) { if ( $ this -> validValues ) { if ( is_callable ( $ this -> validValues ) ) { return call_user_func ( $ this -> validValues ) ; } return $ this -> validValues ; } return ; }
2585	protected function loadReferences ( $ params ) { if ( $ this -> checkAnyNotEmpty ( $ params -> passengers , $ params -> segments ) ) { $ this -> psaInformation = new PsaInformation ( ) ; foreach ( $ params -> passengers as $ passenger ) { $ this -> psaInformation -> refDetails [ ] = new RefDetails ( $ passenger , RefDetails :: QUAL_PASSENGER ) ; } foreach ( $ params -> segments as $ segment ) { $ this -> psaInformation -> refDetails [ ] = new RefDetails ( $ segment , RefDetails :: QUAL_SEGMENT_REFERENCE ) ; } } }
255	public function beforeRun ( ) { $ event = new WidgetEvent ( ) ; $ this -> trigger ( self :: EVENT_BEFORE_RUN , $ event ) ; return $ event -> isValid ; }
2777	public function init ( string $ directory , array $ options = [ ] ) : GitWorkingCopy { $ git = $ this -> workingCopy ( $ directory ) ; $ git -> init ( $ options ) ; $ git -> setCloned ( true ) ; return $ git ; }
874	public function getAnnotationsOfType ( $ types ) { $ annotations = [ ] ; $ types = ( array ) $ types ; foreach ( $ this -> getAnnotations ( ) as $ annotation ) { $ tag = $ annotation -> getTag ( ) -> getName ( ) ; foreach ( $ types as $ type ) { if ( $ type === $ tag ) { $ annotations [ ] = $ annotation ; } } } return $ annotations ; }
193	public function clear ( ) { $ this -> _headers = null ; $ this -> _cookies = null ; $ this -> _statusCode = 200 ; $ this -> statusText = 'OK' ; $ this -> data = null ; $ this -> stream = null ; $ this -> content = null ; $ this -> isSent = false ; }
10658	private function _uxsortmRec ( ArrayObject $ a , array $ sortFuncs , $ depth = 0 , $ sortMode = '' ) { $ goOn = ( count ( $ sortFuncs ) > $ depth + 1 ) ; $ it = $ a -> getIterator ( ) ; while ( $ it -> valid ( ) ) { if ( null !== $ sortFuncs [ $ depth ] ) { if ( $ sortMode == 'a' ) { $ it -> current ( ) -> uasort ( $ sortFuncs [ $ depth ] ) ; } else if ( $ sortMode == 'k' ) { $ it -> current ( ) -> uksort ( $ sortFuncs [ $ depth ] ) ; } else { $ it -> current ( ) -> usort ( $ sortFuncs [ $ depth ] ) ; } } if ( $ goOn ) { $ this -> _uxsortmRec ( $ it -> current ( ) , $ sortFuncs , $ depth + 1 , $ sortMode ) ; } $ it -> next ( ) ; } }
603	protected function startsWithAnyLongest ( array & $ with , $ caseSensitive , & $ length = null , & $ content = null ) { if ( empty ( $ with ) ) { return false ; } if ( ! is_array ( reset ( $ with ) ) ) { usort ( $ with , function ( $ string1 , $ string2 ) { return mb_strlen ( $ string2 , 'UTF-8' ) - mb_strlen ( $ string1 , 'UTF-8' ) ; } ) ; $ map = [ ] ; foreach ( $ with as $ string ) { $ map [ mb_strlen ( $ string , 'UTF-8' ) ] [ $ caseSensitive ? $ string : mb_strtoupper ( $ string , 'UTF-8' ) ] = true ; } $ with = $ map ; } foreach ( $ with as $ testLength => $ testValues ) { $ content = $ this -> substring ( $ testLength , $ caseSensitive ) ; if ( isset ( $ testValues [ $ content ] ) ) { $ length = $ testLength ; return true ; } } return false ; }
10258	public function getCompanyName ( $ base_name = null ) { $ suffixes = [ 'Corporation' , 'Company' , 'Company, Limited' , 'Computer Repair' , 'Incorporated' , 'and Sons' , 'Group' , 'Group, PLC' , 'Furniture' , 'Flowers' , 'Sales' , 'Systems' , 'Tire' , 'Auto' , 'Plumbing' , 'Roofing' , 'Realty' , 'Foods' , 'Books' ] ; if ( empty ( $ base_name ) ) { $ base_name = $ this -> getLastName ( ) ; } return $ base_name . ' ' . $ this -> fromArray ( $ suffixes ) ; }
866	public function isType ( $ types ) { if ( ! \ is_array ( $ types ) ) { $ types = [ $ types ] ; } return \ in_array ( $ this -> getType ( ) , $ types , true ) ; }
8486	public static function getCpuVendor ( ) { $ wmi = Windows :: getInstance ( ) ; $ object = $ wmi -> ExecQuery ( "SELECT Manufacturer FROM Win32_Processor" ) ; foreach ( $ object as $ cpu ) { return $ cpu -> Manufacturer ; } return 'Unknown' ; }
109	public function getVersion ( ) { if ( isset ( self :: $ version ) ) { return self :: $ version ; } if ( 0 !== $ this -> process -> execute ( 'git --version' , $ output ) ) { return ; } if ( preg_match ( '/^git version (\d+(?:\.\d+)+)/m' , $ output , $ matches ) ) { return self :: $ version = $ matches [ 1 ] ; } }
1068	private function collectConflictsBetween ( ValidationContext $ context , array & $ conflicts , $ parentFieldsAreMutuallyExclusive , array $ fieldMap1 , array $ fieldMap2 ) { foreach ( $ fieldMap1 as $ responseName => $ fields1 ) { if ( ! isset ( $ fieldMap2 [ $ responseName ] ) ) { continue ; } $ fields2 = $ fieldMap2 [ $ responseName ] ; $ fields1Length = count ( $ fields1 ) ; $ fields2Length = count ( $ fields2 ) ; for ( $ i = 0 ; $ i < $ fields1Length ; $ i ++ ) { for ( $ j = 0 ; $ j < $ fields2Length ; $ j ++ ) { $ conflict = $ this -> findConflict ( $ context , $ parentFieldsAreMutuallyExclusive , $ responseName , $ fields1 [ $ i ] , $ fields2 [ $ j ] ) ; if ( ! $ conflict ) { continue ; } $ conflicts [ ] = $ conflict ; } } } }
10506	private function registerLogMenu ( ) { $ this -> app -> singleton ( Contracts \ Utilities \ LogMenu :: class , Utilities \ LogMenu :: class ) ; $ this -> app -> singleton ( 'arcanedev.log-viewer.menu' , Contracts \ Utilities \ LogMenu :: class ) ; }
652	public function execute ( ) { $ sql = $ this -> getSql ( ) ; list ( $ profile , $ rawSql ) = $ this -> logQuery ( __METHOD__ ) ; if ( $ sql == '' ) { return 0 ; } $ this -> prepare ( false ) ; try { $ profile and Yii :: beginProfile ( $ rawSql , __METHOD__ ) ; $ this -> internalExecute ( $ rawSql ) ; $ n = $ this -> pdoStatement -> rowCount ( ) ; $ profile and Yii :: endProfile ( $ rawSql , __METHOD__ ) ; $ this -> refreshTableSchema ( ) ; return $ n ; } catch ( Exception $ e ) { $ profile and Yii :: endProfile ( $ rawSql , __METHOD__ ) ; throw $ e ; } }
12596	protected function doWeNeedToMinify ( SplFileInfo $ file ) : bool { return ( ! $ this -> debug && ! Str :: s ( $ file -> getFilename ( ) ) -> contains ( '.min.' ) ) ; }
1520	public function removeFromRelationship ( StoreInterface $ store , UpdateRelationship $ request ) { $ result = $ this -> transaction ( function ( ) use ( $ store , $ request ) { return $ this -> doRemoveFromRelationship ( $ store , $ request ) ; } ) ; if ( $ this -> isResponse ( $ result ) ) { return $ result ; } return $ this -> reply ( ) -> noContent ( ) ; }
11207	public function getIterator ( ) { if ( ! $ this -> content || $ this -> contentModified ) { $ this -> generateContent ( ) ; } return new \ ArrayIterator ( $ this -> content ) ; }
6093	public function section ( $ separator , $ first = 0 , $ last = 0 ) { $ sections = explode ( $ separator , $ this -> string ) ; $ total = count ( $ sections ) ; $ first = intval ( $ first ) ; $ last = intval ( $ last ) ; if ( $ first > $ total ) { return null ; } if ( $ first > $ last ) { $ last = $ first ; } for ( $ i = 0 ; $ i < $ total ; $ i ++ ) { if ( $ i < $ first || $ i > $ last ) { unset ( $ sections [ $ i ] ) ; } } $ string = implode ( $ separator , $ sections ) ; return new self ( $ string ) ; }
7763	public function getDocumentation ( ) { $ metadata = $ this -> metadata -> getAllMetadata ( ) ; $ docu = array ( '@context' => array ( 'vocab' => $ this -> vocabUrl . '#' , 'hydra' => 'http://www.w3.org/ns/hydra/core#' , 'ApiDocumentation' => 'hydra:ApiDocumentation' , 'property' => array ( '@id' => 'hydra:property' , '@type' => '@id' ) , 'readonly' => 'hydra:readonly' , 'writeonly' => 'hydra:writeonly' , 'supportedClass' => 'hydra:supportedClass' , 'supportedProperty' => 'hydra:supportedProperty' , 'supportedOperation' => 'hydra:supportedOperation' , 'method' => 'hydra:method' , 'expects' => array ( '@id' => 'hydra:expects' , '@type' => '@id' ) , 'returns' => array ( '@id' => 'hydra:returns' , '@type' => '@id' ) , 'statusCodes' => 'hydra:statusCodes' , 'code' => 'hydra:statusCode' , 'rdf' => 'http://www.w3.org/1999/02/22-rdf-syntax-ns#' , 'rdfs' => 'http://www.w3.org/2000/01/rdf-schema#' , 'label' => 'rdfs:label' , 'description' => 'rdfs:comment' , 'domain' => array ( '@id' => 'rdfs:domain' , '@type' => '@id' ) , 'range' => array ( '@id' => 'rdfs:range' , '@type' => '@id' ) , 'subClassOf' => array ( '@id' => 'rdfs:subClassOf' , '@type' => '@id' ) , ) , '@id' => $ this -> vocabUrl , '@type' => 'ApiDocumentation' , 'supportedClass' => array ( ) ) ; foreach ( $ metadata as $ class ) { if ( $ class -> isExternalReference ( ) ) { $ docu [ 'supportedClass' ] [ ] = array ( '@id' => $ class -> getIri ( ) , '@type' => 'hydra:Class' , 'hydra:title' => $ class -> getTitle ( ) , 'hydra:description' => $ class -> getDescription ( ) , 'supportedOperation' => $ this -> documentOperations ( $ class -> getOperations ( ) ) , 'supportedProperty' => $ this -> documentClassProperties ( $ class ) , ) ; } else { if ( false !== ( $ superclass = get_parent_class ( $ class -> getName ( ) ) ) ) { try { $ superclass = $ this -> metadata -> getMetadataFor ( $ superclass ) ; $ superclass = $ superclass -> isExternalReference ( ) ? $ superclass -> getIri ( ) : 'vocab:' . $ superclass -> getIri ( ) ; } catch ( \ Exception $ e ) { $ superclass = null ; } } else { $ superclass = null ; } $ docu [ 'supportedClass' ] [ ] = array ( '@id' => 'vocab:' . $ class -> getIri ( ) , '@type' => 'hydra:Class' , 'subClassOf' => $ superclass , 'label' => $ class -> getTitle ( ) , 'description' => $ class -> getDescription ( ) , 'supportedOperation' => $ this -> documentOperations ( $ class -> getOperations ( ) ) , 'supportedProperty' => $ this -> documentClassProperties ( $ class ) , ) ; } } return $ docu ; }
7256	public function user ( $ key = null ) { if ( $ this -> sessionKey && $ this -> request -> session ( ) -> check ( $ this -> sessionKey ) ) { $ user = $ this -> request -> session ( ) -> read ( $ this -> sessionKey ) ; } else { return null ; } if ( $ key === null ) { return $ user ; } return Hash :: get ( $ user , $ key ) ; }
4055	private function convertLegends ( array $ properties , IMetaModel $ metaModel , array $ conditions ) : array { $ result = [ ] ; $ label = [ ] ; if ( $ trans = $ metaModel -> isTranslated ( ) ) { foreach ( $ metaModel -> getAvailableLanguages ( ) as $ availableLanguage ) { $ label [ $ availableLanguage ] = $ metaModel -> getName ( ) ; } } else { $ label [ $ metaModel -> getActiveLanguage ( ) ] = $ metaModel -> getName ( ) ; } $ legend = [ 'label' => $ label , 'hide' => false , 'properties' => [ ] ] ; $ condition = function ( $ property ) use ( $ conditions ) { if ( ! isset ( $ conditions [ $ property [ 'id' ] ] ) ) { return null ; } return [ 'type' => 'conditionand' , 'children' => $ conditions [ $ property [ 'id' ] ] ] ; } ; foreach ( $ properties as $ property ) { switch ( $ property [ 'dcatype' ] ) { case 'legend' : $ this -> convertLegend ( $ property , $ trans , $ condition , $ legend , $ result ) ; break ; case 'attribute' : $ this -> convertAttribute ( $ property , $ condition , $ legend ) ; break ; default : break ; } } if ( ! empty ( $ legend [ 'properties' ] ) ) { $ result [ 'legend' . ( \ count ( $ result ) + 1 ) ] = $ legend ; } return $ result ; }
1640	protected function setupPaths ( Client $ client , $ base , $ path , $ strip , $ project ) { if ( $ strip ) { $ client -> setStripPath ( $ strip ) ; if ( ! $ project ) { $ client -> setProjectRoot ( "{$strip}/app" ) ; } return ; } if ( $ project ) { if ( $ base && substr ( $ project , 0 , strlen ( $ base ) ) === $ base ) { $ client -> setStripPath ( $ base ) ; } $ client -> setProjectRoot ( $ project ) ; return ; } $ client -> setStripPath ( $ base ) ; $ client -> setProjectRoot ( $ path ) ; }
4310	public function getChannels ( $ allDescendants = false ) { if ( $ allDescendants ) { $ channels = array ( ) ; foreach ( $ this -> channels as $ channel ) { $ channels = \ array_merge ( $ channels , array ( $ channel -> getCfg ( 'channel' ) => $ channel ) , $ channel -> getChannels ( true ) ) ; } return $ channels ; } return $ this -> channels ; }
8929	public function stack ( $ icons ) { if ( count ( $ icons ) !== 2 ) { throw new \ InvalidArgumentException ( 'Expecting exactly 2 icons in the stack' ) ; } $ contents = [ ] ; $ index = 2 ; foreach ( $ icons as $ key => $ value ) { $ contents [ ] = $ this -> getStackIconElement ( $ key , $ value , $ index ) ; -- $ index ; } return $ this -> html -> span ( $ contents ) -> addClass ( 'fa-stack' ) ; }
3235	public function getCountAttribute ( ) { if ( empty ( $ this -> shopCalculations ) ) $ this -> runCalculations ( ) ; return round ( $ this -> shopCalculations -> itemCount , 2 ) ; }
8691	public static function symlinkJQueryFileUpload ( Event $ event ) { $ IO = $ event -> getIO ( ) ; $ composer = $ event -> getComposer ( ) ; $ cmanager = new ComposerPathFinder ( $ composer ) ; $ ds = DIRECTORY_SEPARATOR ; $ options = [ 'targetSuffix' => self :: getTargetSuffix ( 'jquery-file-upload' ) , 'sourcePrefix' => "..{$ds}..{$ds}..{$ds}" , ] ; list ( $ symlinkTarget , $ symlinkName ) = $ cmanager -> getSymlinkFromComposer ( 'sidus/file-upload-bundle' , 'blueimp/jquery-file-upload' , $ options ) ; $ IO -> write ( 'Checking Symlink' , false ) ; if ( false === self :: checkSymlink ( $ symlinkTarget , $ symlinkName , true ) ) { $ IO -> write ( 'Creating Symlink: ' . $ symlinkName , false ) ; self :: createSymlink ( $ symlinkTarget , $ symlinkName ) ; } $ IO -> write ( '<info>OK</info>' ) ; }
9516	public function settings ( $ name = null , $ value = null ) { switch ( func_num_args ( ) ) { case 0 : return $ this -> info ( 'settings' ) ; break ; case 1 : return $ this -> info ( 'settings' , func_get_arg ( 0 ) ) ; break ; case 2 : $ update = false ; list ( $ name , $ value ) = func_get_args ( ) ; $ current = $ this -> info ( 'settings' , $ name ) ; if ( is_null ( $ value ) ) { if ( ! is_null ( $ current ) ) { unset ( $ this -> info [ 'settings' ] [ $ name ] ) ; $ update = true ; } } elseif ( $ current !== $ value ) { $ this -> info [ 'settings' ] [ $ name ] = $ value ; $ update = true ; } if ( $ update ) { $ this -> exec ( 'UPDATE config SET settings = ?' , serialize ( $ this -> info [ 'settings' ] ) ) ; } break ; } }
9309	public function show ( $ id , $ params = [ ] ) { $ data = [ 'id' => $ id ] + $ params ; return $ this -> query ( __FUNCTION__ , $ data ) ; }
7759	protected function getMappingDriverBundleConfigDefaults ( array $ bundleConfig , \ ReflectionClass $ bundle , ContainerBuilder $ container ) { $ bundleDir = dirname ( $ bundle -> getFilename ( ) ) ; if ( ! $ bundleConfig [ 'type' ] ) { $ bundleConfig [ 'type' ] = $ this -> detectMetadataDriver ( $ bundleDir , $ container ) ; } if ( ! $ bundleConfig [ 'type' ] ) { return false ; } if ( ! $ bundleConfig [ 'dir' ] ) { if ( in_array ( $ bundleConfig [ 'type' ] , array ( 'annotation' , 'staticphp' ) ) ) { $ bundleConfig [ 'dir' ] = $ bundleDir . '/' . $ this -> getMappingObjectDefaultName ( ) ; } else { $ bundleConfig [ 'dir' ] = $ bundleDir . '/' . $ this -> getMappingResourceConfigDirectory ( ) ; } } else { $ bundleConfig [ 'dir' ] = $ bundleDir . '/' . $ bundleConfig [ 'dir' ] ; } if ( ! $ bundleConfig [ 'prefix' ] ) { $ bundleConfig [ 'prefix' ] = $ bundle -> getNamespaceName ( ) . '\\' . $ this -> getMappingObjectDefaultName ( ) ; } return $ bundleConfig ; }
7106	protected function calculateTotalByState ( PaymentSubjectInterface $ subject , $ state ) { PaymentStates :: isValidState ( $ state , true ) ; $ currency = $ subject -> getCurrency ( ) -> getCode ( ) ; $ total = 0 ; foreach ( $ subject -> getPayments ( ) as $ payment ) { if ( $ payment -> getState ( ) === $ state ) { $ total += $ this -> convertPaymentAmount ( $ payment , $ currency ) ; } } return $ total ; }
1192	private function addCustomAttributes ( array $ attributes , HTMLPurifier_HTMLDefinition $ definition ) { foreach ( $ attributes as $ attribute ) { $ required = ! empty ( $ attribute [ 3 ] ) ? true : false ; $ onElement = $ attribute [ 0 ] ; $ attrName = $ required ? $ attribute [ 1 ] . '*' : $ attribute [ 1 ] ; $ validValues = $ attribute [ 2 ] ; $ definition -> addAttribute ( $ onElement , $ attrName , $ validValues ) ; } return $ definition ; }
312	public function run ( ) { try { $ this -> state = self :: STATE_BEFORE_REQUEST ; $ this -> trigger ( self :: EVENT_BEFORE_REQUEST ) ; $ this -> state = self :: STATE_HANDLING_REQUEST ; $ response = $ this -> handleRequest ( $ this -> getRequest ( ) ) ; $ this -> state = self :: STATE_AFTER_REQUEST ; $ this -> trigger ( self :: EVENT_AFTER_REQUEST ) ; $ this -> state = self :: STATE_SENDING_RESPONSE ; $ response -> send ( ) ; $ this -> state = self :: STATE_END ; return $ response -> exitStatus ; } catch ( ExitException $ e ) { $ this -> end ( $ e -> statusCode , isset ( $ response ) ? $ response : null ) ; return $ e -> statusCode ; } }
8842	private function stringToArray ( string $ string ) : array { $ lines = preg_split ( '/\R/' , $ string ) ; if ( 1 === count ( $ lines ) && '' === $ lines [ 0 ] ) { $ lines = [ ] ; } return $ lines ; }
8576	public function setItemChargeAdjustmentList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ItemChargeAdjustmentList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
834	private function getFunctionyTokenKinds ( ) { static $ tokens = [ T_ARRAY , T_ECHO , T_EMPTY , T_EVAL , T_EXIT , T_INCLUDE , T_INCLUDE_ONCE , T_ISSET , T_LIST , T_PRINT , T_REQUIRE , T_REQUIRE_ONCE , T_UNSET , T_VARIABLE , ] ; return $ tokens ; }
1476	public function createQueryValidator ( array $ data , array $ rules , array $ messages = [ ] , array $ customAttributes = [ ] ) { return $ this -> createValidator ( $ data , $ rules , $ messages , $ customAttributes , function ( $ key , $ detail , $ failed ) { return $ this -> invalidQueryParameter ( $ key , $ detail , $ failed ) ; } ) ; }
1995	public function generateRss ( ) { $ this -> adjustPublicationDate ( ) ; $ xml = '<?xml version="1.0" encoding="' . Config :: get ( 'characterSet' ) . '"?>' ; $ xml .= '<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/" xmlns:atom="http://www.w3.org/2005/Atom">' ; $ xml .= '<channel>' ; $ xml .= '<title>' . StringUtil :: specialchars ( $ this -> title ) . '</title>' ; $ xml .= '<description>' . StringUtil :: specialchars ( $ this -> description ) . '</description>' ; $ xml .= '<link>' . StringUtil :: specialchars ( $ this -> link ) . '</link>' ; $ xml .= '<language>' . $ this -> language . '</language>' ; $ xml .= '<pubDate>' . date ( 'r' , $ this -> published ) . '</pubDate>' ; $ xml .= '<generator>Contao Open Source CMS</generator>' ; $ xml .= '<atom:link href="' . StringUtil :: specialchars ( Environment :: get ( 'base' ) . 'share/' . $ this -> strName ) . '.xml" rel="self" type="application/rss+xml" />' ; foreach ( $ this -> arrItems as $ objItem ) { $ xml .= '<item>' ; $ xml .= '<title>' . StringUtil :: specialchars ( strip_tags ( StringUtil :: stripInsertTags ( $ objItem -> title ) ) ) . '</title>' ; $ xml .= '<description><![CDATA[' . preg_replace ( '/[\n\r]+/' , ' ' , $ objItem -> description ) . ']]></description>' ; $ xml .= '<link>' . StringUtil :: specialchars ( $ objItem -> link ) . '</link>' ; $ xml .= '<pubDate>' . date ( 'r' , $ objItem -> published ) . '</pubDate>' ; if ( $ objItem -> guid ) { if ( strncmp ( $ objItem -> guid , 'http://' , 7 ) !== 0 && strncmp ( $ objItem -> guid , 'https://' , 8 ) !== 0 ) { $ xml .= '<guid isPermaLink="false">' . $ objItem -> guid . '</guid>' ; } else { $ xml .= '<guid>' . $ objItem -> guid . '</guid>' ; } } else { $ xml .= '<guid>' . StringUtil :: specialchars ( $ objItem -> link ) . '</guid>' ; } if ( \ is_array ( $ objItem -> enclosure ) ) { foreach ( $ objItem -> enclosure as $ arrEnclosure ) { if ( ! empty ( $ arrEnclosure [ 'media' ] ) && $ arrEnclosure [ 'media' ] == 'media:content' ) { $ xml .= '<media:content url="' . $ arrEnclosure [ 'url' ] . '" type="' . $ arrEnclosure [ 'type' ] . '" />' ; } else { $ xml .= '<enclosure url="' . $ arrEnclosure [ 'url' ] . '" length="' . $ arrEnclosure [ 'length' ] . '" type="' . $ arrEnclosure [ 'type' ] . '" />' ; } } } $ xml .= '</item>' ; } $ xml .= '</channel>' ; $ xml .= '</rss>' ; return $ xml ; }
100	public function set ( $ prefix , $ paths ) { if ( ! $ prefix ) { $ this -> fallbackDirsPsr0 = ( array ) $ paths ; } else { $ this -> prefixesPsr0 [ $ prefix [ 0 ] ] [ $ prefix ] = ( array ) $ paths ; } }
10397	protected function processDiscriminatorMap ( ClassMetadataInfo $ metadata ) { $ newMap = [ ] ; foreach ( $ metadata -> discriminatorMap as $ mapId => $ mappedEntityName ) { $ newKey = $ this -> doReplacement ( $ mapId ) ; $ newMap [ $ newKey ] = $ mappedEntityName ; } $ metadata -> discriminatorMap = $ newMap ; }
12629	public function sendToDevice ( $ deviceId , $ openId , $ content ) { $ params = [ 'device_type' => $ this -> deviceType , 'device_id' => $ deviceId , 'open_id' => $ openId , 'content' => base64_encode ( $ content ) , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_TRANS_MSG , $ params ] ) ; }
6588	public function get ( $ url , $ method = "GET" ) { return $ this -> request ( [ CURLOPT_HTTPGET => true , CURLOPT_CUSTOMREQUEST => $ method ? : "GET" , CURLOPT_URL => "$url" , ] ) ; }
6531	protected function applyAnalyzer ( array $ mapping , Field $ field , \ stdClass $ rootObject , $ path = null ) { if ( null === $ this -> defaultAnalyzer ) { return $ mapping ; } if ( ! isset ( $ mapping [ 'type' ] ) || 'text' !== $ mapping [ 'type' ] ) { return $ mapping ; } if ( isset ( $ mapping [ 'index' ] ) && false === $ mapping [ 'index' ] ) { return $ mapping ; } if ( isset ( $ mapping [ 'analyzer' ] ) ) { return $ mapping ; } $ mapping [ 'analyzer' ] = $ this -> defaultAnalyzer ; return $ mapping ; }
7867	protected function drawBorder ( $ left , $ middle , $ right ) { $ width = $ this -> geometry -> getWidthButBorders ( ) ; $ border = str_repeat ( static :: BORDER_Y , $ width ) ; $ this -> replaceUtf8 ( $ border , $ left , 0 ) ; $ this -> replaceUtf8 ( $ border , $ middle , floor ( $ width / 2 ) ) ; $ this -> replaceUtf8 ( $ border , $ right , $ width - 1 ) ; $ this -> drawBordered ( $ border ) ; }
1412	public function resourceDoesNotSupportClientIds ( string $ type , string $ path = '/data' ) : ErrorInterface { return new Error ( null , null , Response :: HTTP_FORBIDDEN , $ this -> trans ( 'resource_client_ids_not_supported' , 'code' ) , $ this -> trans ( 'resource_client_ids_not_supported' , 'title' ) , $ this -> trans ( 'resource_client_ids_not_supported' , 'detail' , compact ( 'type' ) ) , $ this -> pointer ( $ path , 'id' ) ) ; }
2533	protected function loadInventory ( $ inventory ) { if ( is_array ( $ inventory ) && count ( $ inventory ) > 0 ) { $ this -> inventory = new Inventory ( ) ; foreach ( $ inventory as $ bookingClass => $ availabilityAmount ) { $ this -> inventory -> bookingClassDetails [ ] = new BookingClassDetails ( $ bookingClass , $ availabilityAmount ) ; } } }
3	private function buildDependency20Info ( $ depArray ) { $ result = array ( ) ; $ optionals = array ( ) ; $ defaultOptionals = array ( ) ; foreach ( $ depArray as $ depType => $ depTypeGroup ) { if ( ! is_array ( $ depTypeGroup ) ) { continue ; } if ( 'required' == $ depType || 'optional' == $ depType ) { foreach ( $ depTypeGroup as $ depItemType => $ depItem ) { switch ( $ depItemType ) { case 'php' : $ result [ ] = new DependencyConstraint ( $ depType , $ this -> parse20VersionConstraint ( $ depItem ) , 'php' , '' ) ; break ; case 'package' : $ deps = $ this -> buildDepPackageConstraints ( $ depItem , $ depType ) ; $ result = array_merge ( $ result , $ deps ) ; break ; case 'extension' : $ deps = $ this -> buildDepExtensionConstraints ( $ depItem , $ depType ) ; $ result = array_merge ( $ result , $ deps ) ; break ; case 'subpackage' : $ deps = $ this -> buildDepPackageConstraints ( $ depItem , 'replaces' ) ; $ defaultOptionals += $ deps ; break ; case 'os' : case 'pearinstaller' : break ; default : break ; } } } elseif ( 'group' == $ depType ) { if ( $ this -> isHash ( $ depTypeGroup ) ) { $ depTypeGroup = array ( $ depTypeGroup ) ; } foreach ( $ depTypeGroup as $ depItem ) { $ groupName = $ depItem [ 'attribs' ] [ 'name' ] ; if ( ! isset ( $ optionals [ $ groupName ] ) ) { $ optionals [ $ groupName ] = array ( ) ; } if ( isset ( $ depItem [ 'subpackage' ] ) ) { $ optionals [ $ groupName ] += $ this -> buildDepPackageConstraints ( $ depItem [ 'subpackage' ] , 'replaces' ) ; } else { $ result += $ this -> buildDepPackageConstraints ( $ depItem [ 'package' ] , 'optional' ) ; } } } } if ( count ( $ defaultOptionals ) > 0 ) { $ optionals [ '*' ] = $ defaultOptionals ; } return new DependencyInfo ( $ result , $ optionals ) ; }
2195	protected function resendActivationMail ( MemberModel $ objMember ) { if ( $ objMember -> disable == '' ) { return ; } $ this -> strTemplate = 'mod_message' ; $ this -> Template = new FrontendTemplate ( $ this -> strTemplate ) ; $ optIn = System :: getContainer ( ) -> get ( 'contao.opt-in' ) ; $ optInToken = null ; $ models = OptInModel :: findByRelatedTableAndIds ( 'tl_member' , array ( $ objMember -> id ) ) ; foreach ( $ models as $ model ) { if ( ( $ token = $ optIn -> find ( $ model -> token ) ) && $ token -> isValid ( ) && ! $ token -> isConfirmed ( ) ) { $ optInToken = $ token ; break ; } } if ( $ optInToken === null ) { return ; } $ optInToken -> send ( ) ; $ this -> Template -> type = 'confirm' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'resendActivation' ] ; }
11479	protected function send ( RequestInterface $ request ) : ResponseInterface { $ request = $ request -> withHeader ( "Authorization" , sprintf ( "Bearer %s" , $ this -> apiToken ) ) ; $ request = $ request -> withHeader ( "Content-Type" , "application/json" ) ; $ request = $ request -> withHeader ( "Accept" , "application/json" ) ; try { $ response = $ this -> client -> send ( $ request ) ; } catch ( GuzzleException $ e ) { if ( $ e -> getCode ( ) === 401 ) { throw new ClientException ( "Authorization failed. Did you specify the right api token?" , $ request , null , $ e ) ; } throw new ClientException ( sprintf ( "Failed to execute request (code %d): %s" , $ e -> getCode ( ) , $ e -> getMessage ( ) ) , $ request , null , $ e ) ; } return $ response ; }
1929	public function generate ( ) { if ( TL_MODE == 'BE' ) { $ return = '<pre>' . StringUtil :: specialchars ( $ this -> code ) . '</pre>' ; if ( $ this -> headline != '' ) { $ return = '<' . $ this -> hl . '>' . $ this -> headline . '</' . $ this -> hl . '>' . $ return ; } return $ return ; } return parent :: generate ( ) ; }
2649	public function setVclAsMain ( $ version , $ name ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/vcl/' . $ name . '/main' ; $ result = $ this -> _fetch ( $ url , 'PUT' ) ; return $ result ; }
4910	public function renderSummary ( SummaryFormInterface $ form ) { $ form -> prepare ( ) ; $ baseFieldset = $ form -> getBaseFieldset ( ) ; if ( ! isset ( $ baseFieldset ) ) { throw new \ InvalidArgumentException ( 'For the Form ' . get_class ( $ form ) . ' there is no Basefieldset' ) ; } $ dataAttributesMarkup = '' ; foreach ( $ form -> getAttributes ( ) as $ dataKey => $ dataValue ) { if ( preg_match ( '/^data-/' , $ dataKey ) ) { $ dataAttributesMarkup .= sprintf ( ' %s="%s"' , $ dataKey , $ dataValue ) ; } } $ markup = '<div class="panel panel-default" style="min-height: 100px;"' . $ dataAttributesMarkup . '> <div class="panel-body"><div class="sf-controls">%s</div>%s</div></div>' ; $ view = $ this -> getView ( ) ; $ buttonMarkup = false === $ form -> getOption ( 'editable' ) ? '' : '<button type="button" class="btn btn-default btn-xs sf-edit">' . '<span class="yk-icon yk-icon-edit"></span> ' . $ view -> translate ( 'Edit' ) . '</button>' ; if ( ( $ controlButtons = $ form -> getOption ( 'control_buttons' ) ) !== null ) { $ buttonMarkup .= PHP_EOL . implode ( PHP_EOL , array_map ( function ( array $ buttonSpec ) use ( $ view ) { return '<button type="button" class="btn btn-default btn-xs' . ( isset ( $ buttonSpec [ 'class' ] ) ? ' ' . $ buttonSpec [ 'class' ] : '' ) . '">' . ( isset ( $ buttonSpec [ 'icon' ] ) ? '<span class="yk-icon yk-icon-' . $ buttonSpec [ 'icon' ] . '"></span> ' : '' ) . $ view -> translate ( $ buttonSpec [ 'label' ] ) . '</button>' ; } , $ controlButtons ) ) ; } $ elementMarkup = $ this -> renderSummaryElement ( $ baseFieldset ) ; return sprintf ( $ markup , $ buttonMarkup , $ elementMarkup ) ; }
10453	public function assignResetToken ( $ token , $ email ) { $ user = $ this -> user -> whereEmail ( $ email ) -> first ( ) ; $ user -> reset_token = $ token ; $ user -> save ( ) ; }
12522	public function renderWidget ( array $ fields , $ customFieldOrClass , $ documentType = 'html' , $ slug = null ) { return $ this -> container -> get ( 'chill.custom_field.helper' ) -> renderCustomField ( $ fields , $ customFieldOrClass , $ documentType , $ slug ) ; }
1688	public function updateStyleSheet ( $ intId ) { $ objStyleSheet = $ this -> Database -> prepare ( "SELECT * FROM tl_style_sheet WHERE id=?" ) -> limit ( 1 ) -> execute ( $ intId ) ; if ( $ objStyleSheet -> numRows < 1 ) { return ; } if ( Input :: get ( 'act' ) == 'delete' ) { $ this -> import ( Files :: class , 'Files' ) ; $ this -> Files -> delete ( 'assets/css/' . $ objStyleSheet -> name . '.css' ) ; } else { $ this -> writeStyleSheet ( $ objStyleSheet -> row ( ) ) ; $ this -> log ( 'Generated style sheet "' . $ objStyleSheet -> name . '.css"' , __METHOD__ , TL_CRON ) ; } }
6523	public function isCompatibleForOverride ( Field $ other ) { if ( ! $ this -> overridable ) { return false ; } if ( $ this -> name !== $ other -> name ) { return false ; } if ( $ this -> type !== $ other -> type ) { return false ; } if ( $ this -> rule !== $ other -> rule ) { return false ; } if ( $ this -> required !== $ other -> required ) { return false ; } return true ; }
12363	public function initialize ( ) { parent :: initialize ( ) ; $ this -> addClauses ( [ self :: DEFERRABLE => 'DEFERRABLE %s' , self :: EITHER => 'OR %s' , self :: MATCH => 'MATCH %s' , self :: NOT_DEFERRABLE => 'NOT DEFERRABLE %s' , self :: UNIQUE_KEY => 'UNIQUE (%2$s)' ] ) ; $ this -> addKeywords ( [ self :: ABORT => 'ABORT' , self :: BINARY => 'BINARY' , self :: AUTO_INCREMENT => 'AUTOINCREMENT' , self :: FAIL => 'FAIL' , self :: IGNORE => 'IGNORE' , self :: INIT_DEFERRED => 'INITIALLY DEFERRED' , self :: INIT_IMMEDIATE => 'INITIALLY IMMEDIATE' , self :: NOCASE => 'NOCASE' , self :: PRIMARY_KEY => 'PRIMARY KEY' , self :: REPLACE => 'REPLACE' , self :: ROLLBACK => 'ROLLBACK' , self :: RTRIM => 'RTRIM' , self :: UNIQUE => 'UNIQUE' ] ) ; $ this -> addStatements ( [ Query :: INSERT => new Statement ( 'INSERT {or} INTO {table} {fields} VALUES {values}' ) , Query :: SELECT => new Statement ( 'SELECT {distinct} {fields} FROM {table} {joins} {where} {groupBy} {having} {compounds} {orderBy} {limit}' ) , Query :: UPDATE => new Statement ( 'UPDATE {or} {table} SET {fields} {where}' ) , Query :: DELETE => new Statement ( 'DELETE FROM {table} {where}' ) , Query :: CREATE_TABLE => new Statement ( "CREATE {temporary} TABLE IF NOT EXISTS {table} (\n{columns}{keys}\n)" ) , Query :: CREATE_INDEX => new Statement ( 'CREATE {type} INDEX IF NOT EXISTS {index} ON {table} ({fields})' ) , Query :: DROP_TABLE => new Statement ( 'DROP TABLE IF EXISTS {table}' ) , Query :: DROP_INDEX => new Statement ( 'DROP INDEX IF EXISTS {index}' ) ] ) ; unset ( $ this -> _statements [ Query :: TRUNCATE ] ) ; }
2795	public function getTempDirectory ( ) { if ( is_null ( $ this -> tempDirectory ) ) { $ root = sys_get_temp_dir ( ) ; if ( ! is_dir ( $ root . '/humbug' ) ) { mkdir ( $ root . '/humbug' , 0777 , true ) ; } $ this -> tempDirectory = $ root . '/humbug' ; } return $ this -> tempDirectory ; }
3252	public function placeOrder ( $ statusCode = null ) { if ( empty ( $ statusCode ) ) $ statusCode = Config :: get ( 'shop.order_status_placement' ) ; $ order = call_user_func ( Config :: get ( 'shop.order' ) . '::create' , [ 'user_id' => $ this -> user_id , 'statusCode' => $ statusCode ] ) ; for ( $ i = count ( $ this -> items ) - 1 ; $ i >= 0 ; -- $ i ) { $ this -> items [ $ i ] -> order_id = $ order -> id ; $ this -> items [ $ i ] -> cart_id = null ; $ this -> items [ $ i ] -> save ( ) ; } $ this -> resetCalculations ( ) ; return $ order ; }
11075	public function setArray ( string $ key , $ value , callable $ callback = null , array $ ignoredDefaultValue = null ) { if ( $ value instanceof Traversable ) { $ value = iterator_to_array ( $ value ) ; } if ( is_array ( $ value ) ) { if ( is_callable ( $ callback ) ) { $ value = array_map ( $ callback , $ value ) ; } $ this -> set ( $ key , $ value , $ ignoredDefaultValue ) ; } return $ this ; }
4461	private function handleChildErrors ( & $ socket ) : Closure { $ reserved = str_repeat ( '*' , 32 * 1024 ) ; return function ( ) use ( & $ reserved , & $ socket ) : void { unset ( $ reserved ) ; $ error = error_get_last ( ) ; if ( $ error === null ) { unset ( $ reserved ) ; return ; } $ handler = new ErrorFormatter ( ) ; if ( $ handler -> constant ( $ error [ 'type' ] ) === null ) { $ this -> logger -> warning ( '{type}: Unable to recognize error type. Skip sending error to master: {message}' , $ this -> logContext + [ 'message' => $ error [ 'message' ] ] ) ; return ; } if ( is_resource ( $ socket ) == false ) { $ this -> logger -> warning ( '{type}: supplied resource is not a valid socket resource. Skip sending error to master: {message}' , $ this -> logContext + [ 'message' => $ error [ 'message' ] ] ) ; return ; } $ this -> logger -> debug ( '{type}: sending error to master' , $ this -> logContext ) ; $ data = serialize ( $ error ) ; do { $ len = socket_write ( $ socket , $ data ) ; if ( $ len === false || $ len === 0 ) { break ; } $ data = substr ( $ data , $ len ) ; } while ( is_numeric ( $ len ) && $ len > 0 && is_resource ( $ socket ) ) ; } ; }
9106	public function getPreparedThemeObject ( ) { $ name = $ this -> attainThemeName ( ) ; $ path = $ this -> attainPathName ( ) ; $ return = false ; if ( $ name && $ path ) { $ return = $ this -> getThemeObject ( ) ; $ return -> setName ( $ name ) ; $ return -> setThemesPath ( $ path ) ; } return $ return ; }
11746	public function device ( ) { if ( is_null ( $ this -> device ) ) { $ this -> device = new Device ( $ this -> accessToken ) ; } return $ this -> device ; }
3242	public function getDisplayNameAttribute ( ) { if ( $ this -> hasObject ) return $ this -> object -> displayName ; return isset ( $ this -> itemName ) ? $ this -> attributes [ $ this -> itemName ] : ( array_key_exists ( 'name' , $ this -> attributes ) ? $ this -> attributes [ 'name' ] : '' ) ; }
1012	private function readDigits ( ) { [ $ char , $ code ] = $ this -> readChar ( ) ; if ( $ code >= 48 && $ code <= 57 ) { $ value = '' ; do { $ value .= $ char ; [ $ char , $ code ] = $ this -> moveStringCursor ( 1 , 1 ) -> readChar ( ) ; } while ( $ code >= 48 && $ code <= 57 ) ; return $ value ; } if ( $ this -> position > $ this -> source -> length - 1 ) { $ code = null ; } throw new SyntaxError ( $ this -> source , $ this -> position , 'Invalid number, expected digit but got: ' . Utils :: printCharCode ( $ code ) ) ; }
10473	public function renewItem ( $ user_id , $ item_id ) { $ request = new RenewRequest ( $ user_id , $ item_id ) ; $ this -> emit ( 'request.renew' , array ( $ user_id , $ item_id ) ) ; $ response = $ this -> post ( $ request ) ; return new RenewResponse ( $ response ) ; }
8166	public function write ( ) { $ strings = func_get_args ( ) ; foreach ( $ strings as $ string ) { $ this -> source .= str_repeat ( ' ' , $ this -> indentation * 4 ) . $ string ; } return $ this ; }
9780	private function getLength ( $ value ) : int { if ( is_array ( $ value ) || $ value instanceof \ Countable ) return count ( $ value ) ; if ( $ value instanceof \ Traversable ) return iterator_count ( $ value ) ; if ( is_string ( $ value ) ) return mb_strlen ( $ value ) ; throw new \ InvalidArgumentException ( "The specified value is not iterable: $value" ) ; }
9924	public function filter ( Parameters $ params , array $ permitted = array ( ) ) { $ this -> cleanUnwanted ( $ params , $ permitted ) ; $ this -> handleArrays ( $ params , $ permitted ) ; $ this -> handleCollections ( $ params , $ permitted ) ; }
2650	public function validateServiceVersion ( $ version ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/validate' ; $ result = $ this -> _fetch ( $ url , 'GET' ) ; if ( $ result -> status == 'error' ) { throw new LocalizedException ( __ ( 'Failed to validate service version: ' . $ result -> msg ) ) ; } }
10770	protected function resolveViewName ( ) { $ viewName = Yii :: $ app -> request -> get ( $ this -> viewParam , $ this -> defaultView ) ; if ( ! is_string ( $ viewName ) || ! preg_match ( '~^\w(?:(?!\/\.{0,2}\/)[\w\/\-\.])*$~' , $ viewName ) ) { if ( YII_DEBUG ) { throw new NotFoundHttpException ( "The requested view \"$viewName\" must start with a word character, must not contain /../ or /./, can contain only word characters, forward slashes, dots and dashes." ) ; } else { throw new NotFoundHttpException ( Yii :: t ( 'yii' , 'The requested view "{name}" was not found.' , [ 'name' => $ viewName ] ) ) ; } } return empty ( $ this -> viewPrefix ) ? $ viewName : $ this -> viewPrefix . '/' . $ viewName ; }
1296	private function getUnresolvedField ( Field $ field , string $ locale = null ) { if ( ! isset ( $ this -> fields [ $ field -> getId ( ) ] ) ) { return 'Array' === $ field -> getType ( ) ? [ ] : null ; } $ value = $ this -> fields [ $ field -> getId ( ) ] ; $ locale = $ this -> getLocaleFromInput ( $ locale ) ; if ( \ array_key_exists ( $ locale , $ value ) ) { return $ value [ $ locale ] ; } if ( ! $ field -> isLocalized ( ) ) { throw new \ InvalidArgumentException ( \ sprintf ( 'Trying to access the non-localized field "%s" on content type "%s" using the non-default locale "%s".' , $ field -> getName ( ) , $ this -> sys -> getContentType ( ) -> getName ( ) , $ locale ) ) ; } $ locale = $ this -> walkFallbackChain ( $ value , $ locale , $ this -> sys -> getEnvironment ( ) ) ; if ( $ locale ) { return $ value [ $ locale ] ; } return 'Array' === $ field -> getType ( ) ? [ ] : null ; }
9349	public function multiplyAllow ( $ matrix ) { if ( is_numeric ( $ matrix ) ) { return true ; } if ( $ matrix instanceof Complex ) { return true ; } if ( $ matrix instanceof Matrix ) { return $ this -> size -> cols == $ matrix -> rows ; } return false ; }
9737	public function setWidth ( $ pValue ) { if ( $ this -> resizeProportional && $ pValue != 0 ) { $ ratio = $ this -> height / ( $ this -> width != 0 ? $ this -> width : 1 ) ; $ this -> height = round ( $ ratio * $ pValue ) ; } $ this -> width = $ pValue ; return $ this ; }
7159	protected function compileKeyboard ( Keyboard $ keyboard ) { $ firstButton = collect ( $ keyboard -> getButtons ( ) ) -> first ( ) ; if ( $ firstButton instanceof PayloadButton || $ firstButton instanceof UrlButton ) { return $ this -> compileInlineKeyboard ( $ keyboard ) ; } return $ this -> compileReplyKeyboard ( $ keyboard ) ; }
536	protected function cleanDocComment ( $ doc ) { $ lines = explode ( "\n" , $ doc ) ; $ n = \ count ( $ lines ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ lines [ $ i ] = rtrim ( $ lines [ $ i ] ) ; if ( trim ( $ lines [ $ i ] ) == '*' && trim ( $ lines [ $ i + 1 ] ) == '*' ) { unset ( $ lines [ $ i ] ) ; } } return implode ( "\n" , $ lines ) ; }
11657	public function make ( ) { if ( count ( $ this -> headers ) > 0 ) { if ( ! $ this -> session -> exists ( 'headersInRedirect' , 'redirect' ) || ! $ this -> session -> get ( 'headersInRedirect' , 'redirect' ) ) { $ this -> session -> set ( 'redirectPath' , $ this -> path , 'redirect' ) ; $ this -> session -> set ( 'headersInRedirect' , $ this -> headers , 'redirect' ) ; } } header ( "Location: $this->path" ) ; exit ( ) ; }
12737	protected function translate ( ) { $ translatorOptions = $ this -> getTranslatorOptions ( ) ; if ( empty ( $ translatorOptions ) && ! array_key_exists ( "fields" , $ translatorOptions ) ) { return ; } $ params = array ( ) ; if ( array_key_exists ( "params" , $ translatorOptions ) ) { $ params = $ translatorOptions [ "params" ] ; } $ domain = "RedKiteCms" ; if ( array_key_exists ( "domain" , $ translatorOptions ) ) { $ domain = $ translatorOptions [ "domain" ] ; } foreach ( $ translatorOptions [ "fields" ] as $ field ) { $ field = ucfirst ( $ field ) ; $ method = 'get' . $ field ; $ value = Translator :: translate ( $ this -> $ method ( ) , $ params , $ domain ) ; $ method = 'set' . $ field ; $ this -> $ method ( $ value ) ; } }
44	public function dispatchScript ( $ eventName , $ devMode = false , $ additionalArgs = array ( ) , $ flags = array ( ) ) { return $ this -> doDispatch ( new Script \ Event ( $ eventName , $ this -> composer , $ this -> io , $ devMode , $ additionalArgs , $ flags ) ) ; }
492	public function findFor ( $ name , $ model ) { if ( method_exists ( $ model , 'get' . $ name ) ) { $ method = new \ ReflectionMethod ( $ model , 'get' . $ name ) ; $ realName = lcfirst ( substr ( $ method -> getName ( ) , 3 ) ) ; if ( $ realName !== $ name ) { throw new InvalidArgumentException ( 'Relation names are case sensitive. ' . get_class ( $ model ) . " has a relation named \"$realName\" instead of \"$name\"." ) ; } } return $ this -> multiple ? $ this -> all ( ) : $ this -> one ( ) ; }
9928	protected function valueIsEmpty ( $ value ) { return ( is_object ( $ value ) && $ value instanceof Parameters && $ value -> isEmpty ( ) ) || ( is_array ( $ value ) && ! count ( $ value ) ) ; }
3626	protected function getDefaultSerial ( $ serial_number ) { if ( empty ( $ serial_number ) ) { $ devices_serials = $ this -> getDevices ( ) ; if ( count ( $ devices_serials ) == 0 ) { $ devices_serials = $ this -> getDevices ( DEVICE_TYPE_PROTECT ) ; } $ serial_number = $ devices_serials [ 0 ] ; } return $ serial_number ; }
3059	public function selectAdaptiveNextItem ( ) { $ lastItemId = $ this -> getCurrentCatItemId ( ) ; $ lastOutput = $ this -> getLastCatItemOutput ( ) ; $ catSession = $ this -> getCatSession ( ) ; $ preSelection = $ catSession -> getTestMap ( ) ; try { if ( ! $ this -> syncingMode ) { $ selection = $ catSession -> getTestMap ( array_values ( $ lastOutput ) ) ; if ( ! $ this -> saveAdaptiveResults ( $ catSession ) ) { \ common_Logger :: w ( 'Unable to save CatService results.' ) ; } $ isShadowItem = false ; } else { $ selection = $ catSession -> getTestMap ( ) ; $ isShadowItem = true ; } } catch ( CatEngineException $ e ) { \ common_Logger :: e ( 'Error during CatEngine processing. ' . $ e -> getMessage ( ) ) ; $ selection = $ catSession -> getTestMap ( ) ; $ isShadowItem = true ; } $ event = new SelectAdaptiveNextItemEvent ( $ this -> getTestSession ( ) , $ lastItemId , $ preSelection , $ selection , $ isShadowItem ) ; $ this -> getServiceManager ( ) -> get ( EventManager :: SERVICE_ID ) -> trigger ( $ event ) ; $ this -> persistCatSession ( $ catSession ) ; if ( is_array ( $ selection ) && count ( $ selection ) > 0 ) { \ common_Logger :: d ( "New CAT item selection is '" . implode ( ', ' , $ selection ) . "'." ) ; return $ selection [ 0 ] ; } else { \ common_Logger :: d ( 'No new CAT item selection.' ) ; return null ; } }
6315	public function setUpdateAction ( $ updateAction ) { $ updateAction = strtoupper ( $ updateAction ) ; if ( ! in_array ( $ updateAction , $ this -> getAvailableActions ( ) ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Action %s does not exist.' , $ updateAction ) ) ; } $ this -> updateAction = $ updateAction ; }
7570	public function getApplicationApiService ( ) { $ applicationService = new \ Greenhouse \ GreenhouseToolsPhp \ Services \ ApplicationService ( $ this -> _apiKey , $ this -> _boardToken ) ; $ apiClient = new GuzzleClient ( array ( 'base_uri' => ApiService :: APPLICATION_URL ) ) ; $ applicationService -> setClient ( $ apiClient ) ; return $ applicationService ; }
5711	public function FieldHolder ( $ attributes = array ( ) ) { if ( $ this -> shouldDisplay ( ) ) { $ this -> setContent ( $ this -> getButtonHTML ( ) ) ; return parent :: FieldHolder ( $ attributes ) ; } }
5528	protected function createCodeForMethods ( $ methods ) { $ code = '' ; $ methods = array_merge ( $ methods , $ this -> reflection -> getMethods ( ) ) ; foreach ( $ methods as $ method ) { if ( $ this -> isConstructorOrDeconstructor ( $ method ) ) { continue ; } $ mock_reflection = new SimpleReflection ( $ this -> mock_base ) ; if ( in_array ( $ method , $ mock_reflection -> getMethods ( ) ) ) { continue ; } $ code .= ' ' . $ this -> reflection -> getSignature ( $ method ) ; if ( $ mock_reflection -> isAbstract ( ) ) { $ code .= ";\n" ; } else { $ code .= " {\n" ; $ code .= " return \$this->invoke(\"$method\", func_get_args());\n" ; $ code .= " }\n" ; } } return $ code ; }
9233	public function actionCreate ( ) { $ model = new Post ( ) ; $ model -> time = date ( "Y-m-d H:i:s" ) ; $ model -> author_id = Yii :: $ app -> user -> id ; $ model -> isdel = 0 ; if ( Yii :: $ app -> request -> post ( ) ) { $ post = Yii :: $ app -> request -> post ( ) ; $ category = [ ] ; if ( isset ( $ post [ 'Post' ] [ 'category' ] ) ) { $ category = $ post [ 'Post' ] [ 'category' ] ; } if ( is_array ( $ post [ 'Post' ] [ 'tags' ] ) ) { $ post [ 'Post' ] [ 'tags' ] = implode ( "," , $ post [ 'Post' ] [ 'tags' ] ) ; } $ model -> load ( $ post ) ; $ transaction = Yii :: $ app -> db -> beginTransaction ( ) ; try { if ( $ model -> save ( ) ) { $ cs = BlogCatPos :: deleteAll ( "post_id = :id" , [ "id" => $ model -> id ] ) ; foreach ( $ category as $ d ) { $ c = new BlogCatPos ( ) ; $ c -> post_id = $ model -> id ; $ c -> category_id = $ d ; $ c -> isdel = 0 ; $ c -> save ( ) ; } $ transaction -> commit ( ) ; return $ this -> redirect ( [ 'view' , 'id' => $ model -> id ] ) ; } else { $ model -> id = array_merge ( $ category , [ ] ) ; $ transaction -> rollBack ( ) ; } } catch ( Exception $ e ) { $ transaction -> rollBack ( ) ; } } return $ this -> render ( 'create' , [ 'model' => $ model , ] ) ; }
4822	public function set ( $ name , $ value ) { if ( ! array_key_exists ( $ name , $ this -> row ) ) { $ this -> addField ( $ name , $ value ) ; } else { $ this -> row [ $ name ] = $ value ; } $ this -> informChanges ( ) ; }
4357	protected function processLog ( ) { $ str = '' ; foreach ( $ this -> data [ 'log' ] as $ entry ) { $ channel = isset ( $ entry [ 2 ] [ 'channel' ] ) ? $ entry [ 2 ] [ 'channel' ] : null ; if ( $ this -> channelTest ( $ channel ) ) { $ str .= $ this -> processLogEntryWEvent ( $ entry [ 0 ] , $ entry [ 1 ] , $ entry [ 2 ] ) ; } } return $ str ; }
12648	public function get ( ) { $ arResult = [ 'status' => $ this -> status ( ) , 'data' => $ this -> data ( ) , 'message' => $ this -> message ( ) , 'code' => $ this -> code ( ) , ] ; return $ arResult ; }
5443	protected function invokeParser ( $ content , $ is_match ) { if ( ( $ content === '' ) || ( $ content === false ) ) { return true ; } $ handler = $ this -> mode_handlers [ $ this -> mode -> getCurrent ( ) ] ; return $ this -> parser -> $ handler ( $ content , $ is_match ) ; }
9479	public function respondWithMessage ( $ message = null ) { $ res [ 'status' ] = $ this -> getStatusText ( ) ; if ( $ this -> getErrorCode ( ) ) { $ res [ 'error' ] = $ this -> getErrorCode ( ) ; if ( is_null ( $ message ) ) $ res [ 'message' ] = $ this -> getErrorMessage ( ) ; else $ res [ 'message' ] = $ message ; } else { $ res [ 'message' ] = $ message ; } return $ this -> respond ( $ res ) ; }
6664	public function instantiate ( $ profile , $ provider ) { $ this -> provider = $ provider ; switch ( $ provider ) { case 'facebook' : $ this -> info = $ this -> parseFb ( $ profile ) ; break ; case 'twitter' : $ this -> info = $ this -> parseTwt ( $ profile ) ; break ; } return $ this ; }
2210	public function fetchAssoc ( ) { if ( $ this -> intIndex >= $ this -> count ( ) - 1 ) { return false ; } $ this -> arrCache = $ this -> resultSet [ ++ $ this -> intIndex ] ; return $ this -> arrCache ; }
12572	public function previewImage ( $ message , $ to , $ by = self :: PREVIEW_BY_OPENID ) { return $ this -> preview ( self :: MSG_TYPE_IMAGE , $ message , $ to , $ by ) ; }
10704	public function getModel ( ) { if ( null === $ this -> model ) { $ mainService = $ this -> getServiceLocator ( ) -> get ( 'neobazaar.service.main' ) ; $ this -> model = $ mainService -> getUserEntityRepository ( ) ; } return $ this -> model ; }
11452	public function getActions ( ) { $ actions = [ ] ; if ( is_array ( $ this -> actions ) ) { foreach ( $ this -> actions as $ action ) { $ actions [ $ action ] = $ action ; } } return $ actions ; }
4328	public static function parseAttribString ( $ str , $ dataDecode = true ) { $ attribs = array ( ) ; $ regexAttribs = '/\b([\w\-]+)\b(?: \s*=\s*(["\'])(.*?)\\2 | \s*=\s*(\S+) )?/xs' ; \ preg_match_all ( $ regexAttribs , $ str , $ matches ) ; $ keys = \ array_map ( 'strtolower' , $ matches [ 1 ] ) ; $ values = \ array_replace ( $ matches [ 3 ] , \ array_filter ( $ matches [ 4 ] , 'strlen' ) ) ; foreach ( $ keys as $ i => $ k ) { $ attribs [ $ k ] = $ values [ $ i ] ; if ( \ in_array ( $ k , self :: $ htmlBoolAttr ) ) { $ attribs [ $ k ] = true ; } } \ ksort ( $ attribs ) ; foreach ( $ attribs as $ k => $ v ) { if ( \ is_string ( $ v ) ) { $ attribs [ $ k ] = \ htmlspecialchars_decode ( $ v ) ; } $ isDataAttrib = \ strpos ( $ k , 'data-' ) === 0 ; if ( $ isDataAttrib && $ dataDecode ) { $ val = $ attribs [ $ k ] ; $ attribs [ $ k ] = \ json_decode ( $ attribs [ $ k ] , true ) ; if ( $ attribs [ $ k ] === null && $ val !== 'null' ) { $ attribs [ $ k ] = \ json_decode ( '"' . $ val . '"' , true ) ; } } } return $ attribs ; }
6642	public static function encodeId ( $ id , $ salt , $ hashLength = self :: MIN_HASH_LENGTH ) { $ hashIds = new Hashids ( $ salt , $ hashLength ) ; return $ hashIds -> encode ( $ id ) ; }
11139	protected function getSetItem ( $ dataMember , $ offset , $ quote = true ) { $ item = $ this -> { $ dataMember } [ $ offset ] ; switch ( $ item [ 1 ] ) { case 'varchar' : $ type = 'varchar(255)' ; break ; default : $ type = $ item [ 1 ] ; } $ this -> { $ dataMember } [ $ offset ] [ 1 ] = $ type ; return $ this -> getArrayItem ( $ dataMember , $ offset , $ quote ) ; }
3731	protected function fetchRows ( $ arrIds , $ arrAttrOnly = array ( ) ) { $ builder = $ this -> getConnection ( ) -> createQueryBuilder ( ) ; $ query = $ builder -> select ( '*' ) -> from ( $ this -> getTableName ( ) ) -> where ( $ builder -> expr ( ) -> in ( 'id' , ':values' ) ) -> setParameter ( 'values' , $ arrIds , Connection :: PARAM_STR_ARRAY ) -> orderBy ( 'FIELD(id, :values)' ) -> execute ( ) ; if ( $ arrAttrOnly ) { $ arrAttrOnly = array_merge ( $ this -> systemColumns , $ arrAttrOnly ) ; } $ result = [ ] ; while ( $ row = $ query -> fetch ( \ PDO :: FETCH_ASSOC ) ) { $ data = [ ] ; foreach ( $ row as $ attribute => $ value ) { if ( ( ! $ arrAttrOnly ) || ( in_array ( $ attribute , $ arrAttrOnly , true ) ) ) { $ data [ $ attribute ] = $ value ; } } $ result [ $ row [ 'id' ] ] = $ data ; } return $ result ; }
4356	protected function methodTable ( $ array , $ columns = array ( ) ) { if ( ! \ is_array ( $ array ) ) { return $ this -> dump ( $ array ) ; } $ keys = $ columns ? : $ this -> debug -> methodTable -> colKeys ( $ array ) ; $ table = array ( ) ; $ classnames = array ( ) ; if ( $ this -> debug -> abstracter -> isAbstraction ( $ array ) && $ array [ 'traverseValues' ] ) { $ array = $ array [ 'traverseValues' ] ; } foreach ( $ array as $ k => $ row ) { $ values = $ this -> debug -> methodTable -> keyValues ( $ row , $ keys , $ objInfo ) ; $ values = $ this -> methodTableCleanValues ( $ values ) ; $ table [ $ k ] = $ values ; $ classnames [ $ k ] = $ objInfo [ 'row' ] ? $ objInfo [ 'row' ] [ 'className' ] : '' ; } if ( \ array_filter ( $ classnames ) ) { foreach ( $ classnames as $ k => $ classname ) { $ table [ $ k ] = \ array_merge ( array ( ' class_name' => $ classname ) , $ table [ $ k ] ) ; } } return $ table ; }
3094	public function getAvailableActions ( ) { return is_array ( $ this -> getOption ( self :: ACTIONS_OPTION ) ) ? $ this -> getOption ( self :: ACTIONS_OPTION ) : [ ] ; }
6860	private static function horner ( $ x , $ c ) { if ( count ( $ c ) == 0 ) throw new InvalidArgumentException ( 'No coefficients were provided' ) ; $ i = count ( $ c ) - 1 ; $ y = $ c [ $ i ] ; while ( $ i > 0 ) { $ i -- ; $ y = $ y * $ x + $ c [ $ i ] ; } return $ y ; }
3481	private static function includeConfigurationFile ( ) { static $ included = false ; if ( $ included ) { return ; } $ file = __DIR__ . '/config.php' ; if ( ! file_exists ( $ file ) ) { print sprintf ( 'The configuration file "%s" was not found.%sPlease copy %s/config.php.dist to %s/config.php and modify new file for set own parameters.%s' , $ file , PHP_EOL , __DIR__ , __DIR__ , PHP_EOL ) ; exit ( 1 ) ; } $ included = true ; include_once $ file ; }
5053	public function setResponse ( Response $ response ) { $ this -> setParam ( 'response' , $ response ) ; $ this -> response = $ response ; return $ this ; }
7718	function meth_Conv_Prepare ( & $ Loc , $ StrConv ) { $ x = strtolower ( $ StrConv ) ; $ x = '+' . str_replace ( ' ' , '' , $ x ) . '+' ; if ( strpos ( $ x , '+esc+' ) !== false ) { $ this -> f_Misc_ConvSpe ( $ Loc ) ; $ Loc -> ConvStr = false ; $ Loc -> ConvEsc = true ; } if ( strpos ( $ x , '+wsp+' ) !== false ) { $ this -> f_Misc_ConvSpe ( $ Loc ) ; $ Loc -> ConvWS = true ; } if ( strpos ( $ x , '+js+' ) !== false ) { $ this -> f_Misc_ConvSpe ( $ Loc ) ; $ Loc -> ConvStr = false ; $ Loc -> ConvJS = true ; } if ( strpos ( $ x , '+url+' ) !== false ) { $ this -> f_Misc_ConvSpe ( $ Loc ) ; $ Loc -> ConvStr = false ; $ Loc -> ConvUrl = true ; } if ( strpos ( $ x , '+utf8+' ) !== false ) { $ this -> f_Misc_ConvSpe ( $ Loc ) ; $ Loc -> ConvStr = false ; $ Loc -> ConvUtf8 = true ; } if ( strpos ( $ x , '+no+' ) !== false ) $ Loc -> ConvStr = false ; if ( strpos ( $ x , '+yes+' ) !== false ) $ Loc -> ConvStr = true ; if ( strpos ( $ x , '+nobr+' ) !== false ) { $ Loc -> ConvStr = true ; $ Loc -> ConvBr = false ; } }
6772	protected function didInvoiceCountryChanged ( SaleInterface $ sale ) { $ saleCs = $ this -> persistenceHelper -> getChangeSet ( $ sale ) ; $ oldCountry = $ newCountry = null ; $ oldAddress = isset ( $ saleCs [ 'invoiceAddress' ] ) ? $ saleCs [ 'invoiceAddress' ] [ 0 ] : $ sale -> getInvoiceAddress ( ) ; if ( null !== $ oldAddress ) { $ oldAddressCs = $ this -> persistenceHelper -> getChangeSet ( $ oldAddress ) ; $ oldCountry = isset ( $ oldAddressCs [ 'country' ] ) ? $ oldAddressCs [ 'country' ] [ 0 ] : $ oldAddress -> getCountry ( ) ; } if ( null !== $ newAddress = $ sale -> getInvoiceAddress ( ) ) { $ newCountry = $ newAddress -> getCountry ( ) ; } if ( $ oldCountry !== $ newCountry ) { return true ; } return false ; }
7673	function TbsStorePark ( ) { if ( $ this -> TbsCurrIdx !== false ) { $ this -> TbsStoreLst [ $ this -> TbsCurrIdx ] = array ( 'src' => $ this -> TBS -> Source , 'onshow' => true ) ; $ this -> TBS -> Source = '' ; $ this -> TbsCurrIdx = false ; } }
1804	protected function invalidateCacheTags ( self $ dc ) { if ( ! System :: getContainer ( ) -> has ( 'fos_http_cache.cache_manager' ) ) { return ; } $ ns = 'contao.db.' ; $ tags = array ( $ ns . $ dc -> table , $ ns . $ dc -> table . '.' . $ dc -> id ) ; if ( $ dc -> ptable && $ dc -> activeRecord && $ dc -> activeRecord -> pid > 0 ) { $ tags [ ] = $ ns . $ dc -> ptable ; $ tags [ ] = $ ns . $ dc -> ptable . '.' . $ dc -> activeRecord -> pid ; } if ( \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'config' ] [ 'oninvalidate_cache_tags_callback' ] ) ) { foreach ( $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'config' ] [ 'oninvalidate_cache_tags_callback' ] as $ callback ) { if ( \ is_array ( $ callback ) ) { $ this -> import ( $ callback [ 0 ] ) ; $ tags = $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ dc , $ tags ) ; } elseif ( \ is_callable ( $ callback ) ) { $ tags = $ callback ( $ dc , $ tags ) ; } } } $ tags = array_filter ( array_unique ( $ tags ) ) ; $ cacheManager = System :: getContainer ( ) -> get ( 'fos_http_cache.cache_manager' ) ; $ cacheManager -> invalidateTags ( $ tags ) ; }
10923	public function render ( ) { $ output = [ ] ; if ( count ( $ this -> rows ) > 0 ) { $ output [ ] = $ this -> renderLine ( ) ; } if ( count ( $ this -> columns ) > 0 ) { $ line = [ ] ; $ line [ ] = $ this -> charVertical ; $ columnNumber = 0 ; foreach ( $ this -> columns as $ index => $ column ) { $ title = $ column ; if ( isset ( $ this -> headers [ $ index ] ) ) { $ title = $ this -> headers [ $ index ] ; } $ line [ ] = $ this -> renderCell ( $ columnNumber , $ title , ' ' , 'info' ) ; $ line [ ] = $ this -> charVertical ; $ columnNumber ++ ; } $ output [ ] = implode ( '' , $ line ) ; } if ( count ( $ this -> rows ) > 0 ) { $ output [ ] = $ this -> renderLine ( ) ; foreach ( $ this -> rows as $ row ) { $ output [ ] = $ this -> renderRow ( $ row ) ; } $ output [ ] = $ this -> renderLine ( ) ; } return implode ( "\n" , $ output ) ; }
4267	public function dir_closedir ( ) { if ( ! $ this -> handle ) { return false ; } self :: restorePrev ( ) ; \ closedir ( $ this -> handle ) ; self :: register ( ) ; $ this -> handle = null ; return true ; }
13	public function setClassMapAuthoritative ( $ classMapAuthoritative = false ) { $ this -> classMapAuthoritative = ( bool ) $ classMapAuthoritative ; if ( $ this -> classMapAuthoritative ) { $ this -> setOptimizeAutoloader ( true ) ; } return $ this ; }
5076	public function getIndex ( $ aData = [ ] , $ iPage = null , $ iPerPage = null ) { $ oInput = Factory :: service ( 'Input' ) ; $ oItemModel = Factory :: model ( static :: CONFIG_MODEL_NAME , static :: CONFIG_MODEL_PROVIDER ) ; if ( is_null ( $ iPage ) ) { $ iPage = ( int ) $ oInput -> get ( 'page' ) ? : 1 ; } if ( is_null ( $ iPerPage ) ) { $ iPerPage = static :: CONFIG_MAX_ITEMS_PER_PAGE ; } $ aResults = $ oItemModel -> getAll ( $ iPage , $ iPerPage , $ aData ) ; $ oResponse = Factory :: factory ( 'ApiResponse' , 'nails/module-api' ) ; $ oResponse -> setData ( array_map ( [ $ this , 'formatObject' ] , $ aResults ) ) ; return $ oResponse ; }
7636	public function getBlobInstance ( $ containerName = '' , $ blobName = '' , $ snapshotId = null , $ leaseId = null , $ additionalHeaders = array ( ) ) { Assertion :: notEmpty ( $ containerName , 'Container name is not specified' ) ; self :: assertValidContainerName ( $ containerName ) ; Assertion :: notEmpty ( $ blobName , 'Blob name is not specified.' ) ; self :: assertValidRootContainerBlobName ( $ containerName , $ blobName ) ; $ query = array ( ) ; if ( ! is_null ( $ snapshotId ) ) { $ query [ 'snapshot' ] = $ snapshotId ; } $ headers = array ( ) ; if ( ! is_null ( $ leaseId ) ) { $ headers [ 'x-ms-lease-id' ] = $ leaseId ; } foreach ( $ additionalHeaders as $ key => $ value ) { $ headers [ $ key ] = $ value ; } $ resourceName = self :: createResourceName ( $ containerName , $ blobName ) ; $ response = $ this -> performRequest ( $ resourceName , $ query , 'HEAD' , $ headers , false , null , self :: RESOURCE_BLOB , self :: PERMISSION_READ ) ; if ( ! $ response -> isSuccessful ( ) ) { throw new BlobException ( $ this -> getErrorMessage ( $ response , 'Resource could not be accessed.' ) ) ; } $ metadata = $ this -> parseMetadataHeaders ( $ response -> getHeaders ( ) ) ; return new BlobInstance ( $ containerName , $ blobName , $ snapshotId , $ response -> getHeader ( 'Etag' ) , $ response -> getHeader ( 'Last-modified' ) , $ this -> getBaseUrl ( ) . '/' . $ containerName . '/' . $ blobName , $ response -> getHeader ( 'Content-Length' ) , $ response -> getHeader ( 'Content-Type' ) , $ response -> getHeader ( 'Content-Encoding' ) , $ response -> getHeader ( 'Content-Language' ) , $ response -> getHeader ( 'Cache-Control' ) , $ response -> getHeader ( 'x-ms-blob-type' ) , $ response -> getHeader ( 'x-ms-lease-status' ) , false , $ metadata ) ; }
9059	public function addUnique ( string ... $ name ) : self { $ key = new Index ( ... $ name ) ; $ key -> setUnique ( ) ; $ this -> keys [ $ key -> name ] = $ key ; return $ this ; }
2100	public static function getNumericTimeFormat ( ) { if ( TL_MODE == 'FE' ) { global $ objPage ; if ( $ objPage -> timeFormat != '' && static :: isNumericFormat ( $ objPage -> timeFormat ) ) { return $ objPage -> timeFormat ; } } return Config :: get ( 'timeFormat' ) ; }
9983	public static function dataTypeForValue ( $ pValue ) { if ( $ pValue === null ) { return DataType :: TYPE_NULL ; } elseif ( $ pValue === '' ) { return DataType :: TYPE_STRING ; } elseif ( $ pValue instanceof RichText ) { return DataType :: TYPE_INLINE ; } elseif ( $ pValue [ 0 ] === '=' && strlen ( $ pValue ) > 1 ) { return DataType :: TYPE_FORMULA ; } elseif ( is_bool ( $ pValue ) ) { return DataType :: TYPE_BOOL ; } elseif ( is_float ( $ pValue ) || is_int ( $ pValue ) ) { return DataType :: TYPE_NUMERIC ; } elseif ( preg_match ( '/^[\+\-]?(\d+\\.?\d*|\d*\\.?\d+)([Ee][\-\+]?[0-2]?\d{1,3})?$/' , $ pValue ) ) { $ tValue = ltrim ( $ pValue , '+-' ) ; if ( is_string ( $ pValue ) && $ tValue [ 0 ] === '0' && strlen ( $ tValue ) > 1 && $ tValue [ 1 ] !== '.' ) { return DataType :: TYPE_STRING ; } elseif ( ( strpos ( $ pValue , '.' ) === false ) && ( $ pValue > PHP_INT_MAX ) ) { return DataType :: TYPE_STRING ; } return DataType :: TYPE_NUMERIC ; } elseif ( is_string ( $ pValue ) ) { $ errorCodes = DataType :: getErrorCodes ( ) ; if ( isset ( $ errorCodes [ $ pValue ] ) ) { return DataType :: TYPE_ERROR ; } } return DataType :: TYPE_STRING ; }
1806	public function setNewPassword ( $ strPassword , $ user ) { if ( ! $ user ) { return $ strPassword ; } $ objUser = $ this -> Database -> prepare ( "SELECT * FROM tl_member WHERE id=?" ) -> limit ( 1 ) -> execute ( $ user -> id ) ; if ( $ objUser -> numRows ) { if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'setNewPassword' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'setNewPassword' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'setNewPassword' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ objUser , $ strPassword ) ; } } } return $ strPassword ; }
7882	public function getIndex ( ) { $ today = Carbon :: today ( ) -> format ( 'Y-m-d' ) ; if ( Session :: has ( 'success' ) || Session :: has ( 'error' ) ) { Session :: reflash ( ) ; } return Redirect :: to ( 'logviewer/' . $ today . '/all' ) ; }
11223	private static function checkRegexRoutes ( ) { $ pos = 0 ; self :: getRegexRoutes ( ) ; $ method = $ _SERVER [ 'REQUEST_METHOD' ] ; $ searches = array_keys ( self :: $ patterns ) ; $ replaces = array_values ( self :: $ patterns ) ; foreach ( self :: $ routes as $ route ) { $ segments = explode ( '/' , str_replace ( $ searches , '' , $ route ) ) ; $ route = str_replace ( $ searches , $ replaces , $ route ) ; $ route = Url :: addBackSlash ( $ route ) ; if ( preg_match ( '#^' . $ route . '$#' , self :: $ uri , $ matched ) ) { $ methodRoute = self :: $ methods [ $ pos ] ; if ( $ methodRoute == $ method || $ methodRoute == 'ANY' ) { $ matched = explode ( '/' , trim ( $ matched [ 0 ] , '/' ) ) ; $ matched = array_diff ( $ matched , $ segments ) ; if ( ! is_object ( self :: $ callbacks [ $ pos ] ) ) { self :: $ response = self :: invokeObject ( self :: $ callbacks [ $ pos ] , $ matched ) ; } else { self :: $ response = call_user_func_array ( self :: $ callbacks [ $ pos ] , $ matched ) ; } if ( ! self :: $ halts ) { return self :: $ response ; } self :: $ halts -- ; } } $ pos ++ ; } return self :: $ response ; }
11474	public function setObject ( $ object ) { if ( is_null ( $ this -> _objectType ) ) { $ this -> objectType = $ object -> objectType ; } $ this -> _object = $ object ; }
11964	private function checkSource ( $ connection ) { if ( gettype ( $ connection ) == "string" ) { $ config = include ( __DIR__ . '/../../../../../clusterpoint.php' ) ; $ connection = $ config [ $ connection ] ; } return $ connection ; }
5270	private function translateUpdate ( ) { $ build = array ( "update {$this->table} set" ) ; $ values = array ( ) ; foreach ( $ this -> statements [ 'values' ] as $ key => $ value ) { $ values [ ] = $ key . ' = ' . $ this -> esc_value ( $ value ) ; } if ( ! empty ( $ values ) ) { $ build [ ] = join ( ', ' , $ values ) ; } if ( ! empty ( $ this -> statements [ 'wheres' ] ) ) { $ build [ ] = join ( ' ' , $ this -> statements [ 'wheres' ] ) ; } if ( ! empty ( $ this -> limit ) ) { $ build [ ] = $ this -> limit ; } return join ( ' ' , $ build ) ; }
9770	function matchFormat ( string $ format ) : self { return $ this -> expect ( $ this -> target , matches ( $ format ) ) ; }
3569	public function __issetHook ( ) { return function ( $ next , $ isset , $ args ) { $ key = $ args -> get ( 'key' ) ; if ( ! $ isset ) { $ isset = ( bool ) $ this -> hasMeta ( $ key ) ; } return $ next ( $ isset , $ args ) ; } ; }
11292	protected function _getAttributeDataWhenUnset ( $ attributeName , $ query = false , $ loadMap = false , $ record = false ) { if ( $ attributeName != $ this -> getPrimaryKey ( ) ) { if ( $ this -> _isRelation ( $ attributeName ) && ! isset ( $ this -> model_dynamicOff ) ) { $ this -> $ attributeName = $ this -> _getRelation ( $ attributeName , $ query , $ loadMap , $ record ) ; } else { $ this -> $ attributeName = $ this -> _fetchData ( $ attributeName ) ; } } else { $ this -> $ attributeName = null ; } $ this -> beforeGet ( $ attributeName ) ; $ returnValue = $ this -> model_data [ $ attributeName ] ; $ this -> afterGet ( $ attributeName , $ returnValue ) ; return $ returnValue ; }
3474	public function handle ( ) { if ( ! $ this -> token ) { $ this -> error ( 'You must paste your Discord token (App Bot User token) into your `services.php` config file.' ) ; $ this -> error ( 'View the README for more info: https://github.com/laravel-notification-channels/discord#installation' ) ; return - 1 ; } if ( ! $ this -> confirm ( 'Is the bot already added to your server?' ) ) { $ clientId = $ this -> ask ( 'What is your Discord app client ID?' ) ; $ this -> warn ( 'Add the bot to your server by visiting this link: https://discordapp.com/oauth2/authorize?&client_id=' . $ clientId . '&scope=bot&permissions=0' ) ; if ( ! $ this -> confirm ( 'Continue?' , true ) ) { return - 1 ; } } $ this -> warn ( "Attempting to identify the bot with Discord's websocket gateway..." ) ; $ this -> gateway = $ this -> getGateway ( ) ; $ this -> warn ( "Connecting to '$this->gateway'..." ) ; $ client = $ this -> getSocket ( $ this -> gateway ) ; $ client -> send ( json_encode ( [ 'op' => 2 , 'd' => [ 'token' => $ this -> token , 'v' => 3 , 'compress' => false , 'properties' => [ '$os' => PHP_OS , '$browser' => 'laravel-notification-channels-discord' , '$device' => 'laravel-notification-channels-discord' , '$referrer' => '' , '$referring_domain' => '' , ] , ] , ] ) ) ; $ response = $ client -> receive ( ) ; $ identified = Arr :: get ( json_decode ( $ response , true ) , 'op' ) === 10 ; if ( ! $ identified ) { $ this -> error ( "Discord responded with an error while trying to identify the bot: $response" ) ; return - 1 ; } $ this -> info ( 'Your bot has been identified by Discord and can now send API requests!' ) ; }
8359	public function dashboards ( Environment $ environment , $ size ) { $ dashboards = null ; if ( $ this -> tokenStorage -> getToken ( ) -> getUser ( ) !== null ) { $ dashboardsAvailable = array ( 'ContactForm' , 'Email' , 'Events' , 'ExceptionChecker' , 'GiftVoucher' , 'PageEdit' , 'Payment' , 'PurchaseCredits' , 'Site' , 'User' ) ; foreach ( $ dashboardsAvailable as $ dashboardAvailable ) { if ( is_dir ( $ this -> container -> getParameter ( 'kernel.root_dir' ) . '/../vendor/c975l/' . strtolower ( $ dashboardAvailable ) . '-bundle' ) && $ this -> configService -> hasParameter ( 'c975L' . $ dashboardAvailable . '.roleNeeded' ) && $ this -> container -> get ( 'security.authorization_checker' ) -> isGranted ( $ this -> configService -> getParameter ( 'c975L' . $ dashboardAvailable . '.roleNeeded' ) ) ) { $ dashboards [ ] = strtolower ( $ dashboardAvailable ) ; } } } return $ environment -> render ( '@c975LToolbar/dashboards.html.twig' , array ( 'dashboards' => $ dashboards , 'size' => $ size , ) ) ; }
2508	public function createRequest ( $ messageName , RequestOptionsInterface $ params ) { $ this -> checkMessageIsInWsdl ( $ messageName ) ; $ builder = $ this -> findBuilderForMessage ( $ messageName ) ; if ( $ builder instanceof ConvertInterface ) { return $ builder -> convert ( $ params , $ this -> getActiveVersionFor ( $ messageName ) ) ; } else { throw new \ RuntimeException ( 'No builder found for message ' . $ messageName ) ; } }
8103	private function buildQuery ( $ sql , $ arguments = null ) { if ( is_array ( $ arguments ) ) { $ finalArgs = array ( ) ; foreach ( $ arguments as $ field => $ val ) { $ finalArgs [ ] = " {$field}=:{$field}" ; } $ finalArgs = implode ( ' AND' , $ finalArgs ) ; if ( strpos ( $ sql , ' _arguments_' ) ) { $ sql = str_replace ( ' _arguments_' , $ finalArgs , $ sql ) ; } else { } } $ sql = str_replace ( ' _table_' , " {$this->tableName} " , $ sql ) ; return $ sql ; }
1886	public function getItemsAsArray ( ) { $ arrLinks = array ( ) ; $ intNumberOfLinks = floor ( $ this -> intNumberOfLinks / 2 ) ; $ intFirstOffset = $ this -> intPage - $ intNumberOfLinks - 1 ; if ( $ intFirstOffset > 0 ) { $ intFirstOffset = 0 ; } $ intLastOffset = $ this -> intPage + $ intNumberOfLinks - $ this -> intTotalPages ; if ( $ intLastOffset < 0 ) { $ intLastOffset = 0 ; } $ intFirstLink = $ this -> intPage - $ intNumberOfLinks - $ intLastOffset ; if ( $ intFirstLink < 1 ) { $ intFirstLink = 1 ; } $ intLastLink = $ this -> intPage + $ intNumberOfLinks - $ intFirstOffset ; if ( $ intLastLink > $ this -> intTotalPages ) { $ intLastLink = $ this -> intTotalPages ; } for ( $ i = $ intFirstLink ; $ i <= $ intLastLink ; $ i ++ ) { if ( $ i == $ this -> intPage ) { $ arrLinks [ ] = array ( 'page' => $ i , 'href' => null , 'title' => null ) ; } else { $ arrLinks [ ] = array ( 'page' => $ i , 'href' => $ this -> linkToPage ( $ i ) , 'title' => StringUtil :: specialchars ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'goToPage' ] , $ i ) ) ) ; } } return $ arrLinks ; }
4104	protected static function parseDsn ( $ dsn ) { $ parts = parse_url ( $ dsn ) ; $ protocol = $ parts [ 'scheme' ] ; $ servers = $ parts [ 'host' ] . ':' . $ parts [ 'port' ] ; if ( isset ( $ parts [ 'path' ] ) ) { $ path = explode ( '/' , $ parts [ 'path' ] ) ; list ( $ index , $ type ) = array_values ( array_filter ( $ path ) ) ; } return compact ( 'protocol' , 'servers' , 'index' , 'type' ) ; }
3365	public function structure ( $ args , $ assoc_args ) { global $ wp_rewrite ; $ blog_prefix = '' ; $ prefix = $ blog_prefix ; if ( is_multisite ( ) && ! is_subdomain_install ( ) && is_main_site ( ) ) { $ blog_prefix = '/blog' ; } $ permalink_structure = ( 'default' === $ args [ 0 ] ) ? '' : $ args [ 0 ] ; if ( ! empty ( $ permalink_structure ) ) { $ permalink_structure = preg_replace ( '#/+#' , '/' , '/' . str_replace ( '#' , '' , $ permalink_structure ) ) ; if ( $ prefix && $ blog_prefix ) { $ permalink_structure = $ prefix . preg_replace ( '#^/?index\.php#' , '' , $ permalink_structure ) ; } else { $ permalink_structure = $ blog_prefix . $ permalink_structure ; } } $ wp_rewrite -> set_permalink_structure ( $ permalink_structure ) ; if ( isset ( $ assoc_args [ 'category-base' ] ) ) { $ category_base = $ assoc_args [ 'category-base' ] ; if ( ! empty ( $ category_base ) ) { $ category_base = $ blog_prefix . preg_replace ( '#/+#' , '/' , '/' . str_replace ( '#' , '' , $ category_base ) ) ; } $ wp_rewrite -> set_category_base ( $ category_base ) ; } if ( isset ( $ assoc_args [ 'tag-base' ] ) ) { $ tag_base = $ assoc_args [ 'tag-base' ] ; if ( ! empty ( $ tag_base ) ) { $ tag_base = $ blog_prefix . preg_replace ( '#/+#' , '/' , '/' . str_replace ( '#' , '' , $ tag_base ) ) ; } $ wp_rewrite -> set_tag_base ( $ tag_base ) ; } self :: apache_modules ( ) ; WP_CLI :: success ( 'Rewrite structure set.' ) ; $ new_assoc_args = [ ] ; $ cmd = 'rewrite flush' ; if ( Utils \ get_flag_value ( $ assoc_args , 'hard' ) ) { $ cmd .= ' --hard' ; $ new_assoc_args [ 'hard' ] = true ; if ( ! in_array ( 'mod_rewrite' , ( array ) WP_CLI :: get_config ( 'apache_modules' ) , true ) ) { WP_CLI :: warning ( 'Regenerating a .htaccess file requires special configuration. See usage docs.' ) ; } } $ process_run = WP_CLI :: runcommand ( $ cmd ) ; if ( ! empty ( $ process_run -> stderr ) ) { WP_CLI :: warning ( substr ( $ process_run -> stderr , 9 ) ) ; } }
4979	public function get ( $ form , $ options = null , $ params = null ) { if ( ! is_object ( $ form ) ) { $ form = $ this -> formElementManager -> get ( $ form , $ options ) ; } $ params = $ params ? : clone $ this -> getController ( ) -> getRequest ( ) -> getQuery ( ) ; $ hydrator = $ form -> getHydrator ( ) ; $ data = $ hydrator -> extract ( $ params ) ; $ form -> setData ( $ data ) ; $ hydrator -> hydrate ( $ data , $ params ) ; return $ form ; }
11145	protected function scanDir ( $ dir ) { $ result = array ( ) ; $ list = $ this -> scanDirExec ( $ dir ) ; foreach ( $ list as $ element ) { $ elementPath = $ dir . DIRECTORY_SEPARATOR . $ element ; if ( is_file ( $ elementPath ) ) { $ fileInfo = pathinfo ( $ element ) ; if ( in_array ( $ fileInfo [ 'extension' ] , $ this -> getAllowedFileExtensions ( ) ) ) { $ result [ ] = $ this -> getNameSpace ( ) . "\\" . $ fileInfo [ 'filename' ] ; } } } return $ result ; }
6049	public function setProperties ( array $ properties ) { $ this -> properties = [ ] ; foreach ( $ properties as $ item ) { $ this -> addPropertyResponse ( $ item ) ; } return $ this ; }
10546	public function setRequest ( Request $ request ) { $ this -> request = $ request ; $ this -> app = null ; $ this -> vhost = null ; $ this -> route = null ; $ this -> setVariable ( 'request' , $ request ) ; return $ this ; }
790	public function getErrorSummary ( $ showAllErrors ) { $ lines = [ ] ; $ errors = $ showAllErrors ? $ this -> getErrors ( ) : $ this -> getFirstErrors ( ) ; foreach ( $ errors as $ es ) { $ lines = array_merge ( ( array ) $ es , $ lines ) ; } return $ lines ; }
9113	public function setUp ( ) { $ this -> controllers = array ( ) ; $ this -> views = array ( ) ; $ this -> viewControls = array ( ) ; $ this -> setDefaults ( ) ; $ this -> init ( ) ; $ this -> setLogger ( new NullLogger ( ) ) ; return $ this ; }
2457	public function deleteChilds ( $ table , $ id , & $ delete ) { $ cctable = array ( ) ; $ ctable = $ GLOBALS [ 'TL_DCA' ] [ $ table ] [ 'config' ] [ 'ctable' ] ; if ( ! \ is_array ( $ ctable ) ) { return ; } foreach ( $ ctable as $ v ) { $ this -> loadDataContainer ( $ v ) ; $ cctable [ $ v ] = $ GLOBALS [ 'TL_DCA' ] [ $ v ] [ 'config' ] [ 'ctable' ] ; if ( $ GLOBALS [ 'TL_DCA' ] [ $ v ] [ 'config' ] [ 'dynamicPtable' ] ) { $ ptable = $ GLOBALS [ 'TL_DCA' ] [ $ v ] [ 'config' ] [ 'ptable' ] ; $ cond = ( $ ptable == 'tl_article' ) ? "(ptable=? OR ptable='')" : "ptable=?" ; $ objDelete = $ this -> Database -> prepare ( "SELECT id FROM $v WHERE pid=? AND $cond" ) -> execute ( $ id , $ ptable ) ; } else { $ objDelete = $ this -> Database -> prepare ( "SELECT id FROM $v WHERE pid=?" ) -> execute ( $ id ) ; } if ( ! $ GLOBALS [ 'TL_DCA' ] [ $ v ] [ 'config' ] [ 'doNotDeleteRecords' ] && \ strlen ( $ v ) && $ objDelete -> numRows ) { foreach ( $ objDelete -> fetchAllAssoc ( ) as $ row ) { $ delete [ $ v ] [ ] = $ row [ 'id' ] ; if ( ! empty ( $ cctable [ $ v ] ) ) { $ this -> deleteChilds ( $ v , $ row [ 'id' ] , $ delete ) ; } } } } }
11826	public function remove ( $ encoding ) { $ str = file_get_contents ( $ this -> uri ) ; return file_put_contents ( $ this -> uri , substr ( $ str , ( strlen ( $ this -> getBom ( $ encoding ) ) ) ) ) ; }
12286	public function inset ( string $ block , array $ vars = null ) : string { return trim ( $ this -> make ( $ block , $ vars ) ) . PHP_EOL ; }
3876	private function getMetaModelsPages ( $ config , $ rootPage = null , $ language = null ) { $ metaModelsIdentifier = $ config [ 'pid' ] ; $ filterIdentifier = $ config [ 'filter' ] ; $ presetParams = StringUtil :: deserialize ( $ config [ 'filterparams' ] , true ) ; $ renderSettingId = $ config [ 'rendersetting' ] ; $ metaModels = $ this -> getMetaModel ( $ metaModelsIdentifier , false ) ; $ availableLanguages = $ this -> getLanguage ( $ language , $ metaModels ) ; $ currentLanguage = $ GLOBALS [ 'TL_LANGUAGE' ] ; foreach ( $ availableLanguages as $ newLanguage ) { $ GLOBALS [ 'TL_LANGUAGE' ] = $ newLanguage ; $ view = $ this -> getView ( $ metaModelsIdentifier , $ renderSettingId ) ; $ jumpTos = $ view -> get ( 'jumpTo' ) ; $ processed = $ this -> setFilterParameters ( $ filterIdentifier , $ presetParams , array ( ) ) ; $ filter = $ metaModels -> getEmptyFilter ( ) ; $ filterSetting = $ this -> getFilterSettings ( $ filterIdentifier ) ; $ filterSetting -> addRules ( $ filter , $ processed ) ; $ newEntries = $ this -> getJumpTosFor ( $ metaModels , $ filter , $ view , $ rootPage ) ; $ this -> removeEmptyDetailPages ( $ jumpTos ) ; $ GLOBALS [ 'TL_LANGUAGE' ] = $ currentLanguage ; $ this -> foundPages = array_merge ( $ this -> foundPages , $ newEntries ) ; } $ GLOBALS [ 'TL_LANGUAGE' ] = $ currentLanguage ; }
11070	public function setBoolean ( string $ key , $ value , bool $ ignoredDefaultValue = null ) { $ this -> set ( $ key , ( bool ) $ value , $ ignoredDefaultValue ) ; return $ this ; }
539	protected function serializePagination ( $ pagination ) { return [ $ this -> linksEnvelope => Link :: serialize ( $ pagination -> getLinks ( true ) ) , $ this -> metaEnvelope => [ 'totalCount' => $ pagination -> totalCount , 'pageCount' => $ pagination -> getPageCount ( ) , 'currentPage' => $ pagination -> getPage ( ) + 1 , 'perPage' => $ pagination -> getPageSize ( ) , ] , ] ; }
1425	protected function getRelationshipPaths ( $ includePaths ) { return $ this -> convertIncludePaths ( $ includePaths ) -> merge ( $ this -> defaultWith ) -> unique ( ) -> all ( ) ; }
2633	public function execute ( ) { $ output = $ this -> layoutFactory -> create ( ) -> createBlock ( 'Fastly\Cdn\Block\Dashboard\Tab\Stats\Historic' ) -> toHtml ( ) ; $ resultRaw = $ this -> resultRawFactory -> create ( ) ; return $ resultRaw -> setContents ( $ output ) ; }
7242	public function validate ( $ request ) { if ( ! empty ( $ request [ 'send_by_bcc' ] ) && '1' === $ request [ 'send_by_bcc' ] ) $ request [ 'send_by_bcc' ] = '1' ; else $ request [ 'send_by_bcc' ] = '0' ; if ( ! empty ( $ request [ 'send_attachments' ] ) && '1' === $ request [ 'send_attachments' ] ) $ request [ 'send_attachments' ] = '1' ; else $ request [ 'send_attachments' ] = '0' ; return $ request ; }
6803	public function installTaxRules ( $ codes = [ 'US' ] ) { $ codes = ( array ) $ codes ; if ( empty ( $ codes ) ) { return ; } $ countryRepository = $ this -> manager -> getRepository ( Country :: class ) ; $ taxRepository = $ this -> manager -> getRepository ( Tax :: class ) ; $ taxRuleRepository = $ this -> manager -> getRepository ( TaxRule :: class ) ; foreach ( $ codes as $ code ) { $ path = __DIR__ . '/data/' . $ code . '_tax_rules.yml' ; if ( ! ( file_exists ( $ path ) && is_readable ( $ path ) ) ) { call_user_func ( $ this -> log , 'Tax rules data' , 'not found' ) ; continue ; } $ data = Yaml :: parse ( file_get_contents ( $ path ) ) ; if ( ! is_array ( $ data ) || empty ( $ data ) ) { continue ; } foreach ( $ data as $ datum ) { $ name = $ datum [ 'name' ] ; $ result = 'already exists' ; if ( null === $ taxRuleRepository -> findOneBy ( [ 'name' => $ name ] ) ) { $ taxRule = new TaxRule ( ) ; $ taxRule -> setName ( $ name ) -> setPriority ( $ datum [ 'priority' ] ) -> setCustomer ( $ datum [ 'customer' ] ) -> setBusiness ( $ datum [ 'business' ] ) -> setNotices ( $ datum [ 'notices' ] ) ; if ( ! empty ( $ countryCodes = $ datum [ 'countries' ] ) ) { $ taxRule -> setCountries ( $ countryRepository -> findBy ( [ 'code' => $ countryCodes ] ) ) ; } if ( ! empty ( $ taxNames = $ datum [ 'taxes' ] ) ) { $ taxRule -> setTaxes ( $ taxRepository -> findBy ( [ 'name' => $ taxNames ] ) ) ; } $ this -> manager -> persist ( $ taxRule ) ; $ result = 'done' ; } call_user_func ( $ this -> log , $ name , $ result ) ; } } $ this -> manager -> flush ( ) ; }
1286	private function createIdChunks ( array $ resourceIds ) : array { $ chunks = [ ] ; $ chunkId = - 1 ; $ resourceIds = \ array_values ( $ resourceIds ) ; foreach ( $ resourceIds as $ index => $ resourceId ) { if ( 0 === $ index % 30 ) { ++ $ chunkId ; $ chunks [ $ chunkId ] = [ ] ; } $ chunks [ $ chunkId ] [ ] = $ resourceId ; } return $ chunks ; }
930	public function transform ( Tokens $ tokens ) { foreach ( $ this -> items as $ transformer ) { foreach ( $ tokens as $ index => $ token ) { $ transformer -> process ( $ tokens , $ token , $ index ) ; } } }
5417	protected function createResponse ( $ socket ) { $ response = new SimpleHttpResponse ( $ socket , $ this -> route -> getUrl ( ) , $ this -> encoding ) ; $ socket -> close ( ) ; return $ response ; }
6155	protected function convertValue ( $ value ) { switch ( $ this -> propertyType -> getDataTypeId ( ) ) { case PropertyType :: DATATYPE_BOOLEAN : return ( bool ) $ value ; break ; case PropertyType :: DATATYPE_DATETIME : if ( $ value instanceof \ DateTime ) { return $ value ; } try { return new \ DateTime ( $ value ) ; } catch ( \ Exception $ e ) { return null ; } break ; case PropertyType :: DATATYPE_FLOAT : return ( float ) $ value ; break ; case PropertyType :: DATATYPE_INTEGER : return ( int ) $ value ; break ; case PropertyType :: DATATYPE_STRING : return ( string ) $ value ; break ; default : return $ value ; break ; } }
11661	public static function readFromFile ( $ file ) { $ real_file = File :: asFile ( $ file ) ; if ( $ real_file -> exists ( ) ) return self :: readFromString ( $ file -> getContent ( ) ) ; else return array ( ) ; }
7579	protected function configureDefaultData ( array $ data ) { foreach ( $ this -> _REQUIRED_DATA as $ property => $ value ) { if ( ! isset ( $ data [ $ property ] ) && $ value !== null ) { $ data [ $ property ] = $ value ; } } return $ data ; }
12679	public static function boot ( ConfigurationHandler $ configurationHandler ) { $ pluginDirs = $ configurationHandler -> pluginFolders ( ) ; foreach ( $ pluginDirs as $ pluginDir ) { self :: $ blocks += self :: parse ( $ pluginDir ) ; } }
2653	public function updateSnippet ( array $ snippet ) { $ url = $ this -> _getApiServiceUri ( ) . 'snippet' . '/' . $ snippet [ 'name' ] ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: PUT , $ snippet ) ; return $ result ; }
510	public function actionList ( ) { foreach ( $ this -> getCommandDescriptions ( ) as $ command => $ description ) { $ result = Yii :: $ app -> createController ( $ command ) ; if ( $ result === false || ! ( $ result [ 0 ] instanceof Controller ) ) { continue ; } list ( $ controller , $ actionID ) = $ result ; $ actions = $ this -> getActions ( $ controller ) ; if ( ! empty ( $ actions ) ) { $ prefix = $ controller -> getUniqueId ( ) ; $ this -> stdout ( "$prefix\n" ) ; foreach ( $ actions as $ action ) { $ this -> stdout ( "$prefix/$action\n" ) ; } } } }
7028	static function getDefaultImplementations ( ) { return [ Cart \ Model \ CartInterface :: class => Cart \ Entity \ Cart :: class , Cart \ Model \ CartAddressInterface :: class => Cart \ Entity \ CartAddress :: class , Customer \ Model \ CustomerInterface :: class => Customer \ Entity \ Customer :: class , Customer \ Model \ CustomerGroupInterface :: class => Customer \ Entity \ CustomerGroup :: class , Customer \ Model \ CustomerAddressInterface :: class => Customer \ Entity \ CustomerAddress :: class , Order \ Model \ OrderInterface :: class => Order \ Entity \ Order :: class , Order \ Model \ OrderAddressInterface :: class => Order \ Entity \ OrderAddress :: class , Payment \ Model \ PaymentMethodInterface :: class => Payment \ Entity \ PaymentMethod :: class , Payment \ Model \ PaymentTermInterface :: class => Payment \ Entity \ PaymentTerm :: class , Quote \ Model \ QuoteInterface :: class => Quote \ Entity \ Quote :: class , Quote \ Model \ QuoteAddressInterface :: class => Quote \ Entity \ QuoteAddress :: class , Shipment \ Model \ ShipmentMethodInterface :: class => Shipment \ Entity \ ShipmentMethod :: class , Supplier \ Model \ SupplierInterface :: class => Supplier \ Entity \ Supplier :: class , Supplier \ Model \ SupplierAddressInterface :: class => Supplier \ Entity \ SupplierAddress :: class , Supplier \ Model \ SupplierDeliveryInterface :: class => Supplier \ Entity \ SupplierDelivery :: class , Supplier \ Model \ SupplierOrderInterface :: class => Supplier \ Entity \ SupplierOrder :: class , Supplier \ Model \ SupplierProductInterface :: class => Supplier \ Entity \ SupplierProduct :: class , Support \ Model \ TicketInterface :: class => Support \ Entity \ Ticket :: class , Support \ Model \ TicketMessageInterface :: class => Support \ Entity \ TicketMessage :: class , ] ; }
11464	public static function error ( $ severity , $ message , $ file , $ line ) { if ( error_reporting ( ) == 0 ) return ; elseif ( error_reporting ( ) && $ severity ) { $ ErrorException = new PHPErrorException ( $ message , 0 , $ severity , $ file , $ line ) ; if ( assert_options ( ASSERT_ACTIVE ) ) { foreach ( $ ErrorException -> getStackTrace ( ) as $ element ) { if ( isset ( $ element [ 'function' ] ) && $ element [ 'function' ] == 'assert' ) { self :: exception ( $ ErrorException ) ; } } } $ recoverable = [ E_WARNING , E_NOTICE , E_USER_WARNING , E_USER_NOTICE , E_STRICT , E_DEPRECATED , E_USER_DEPRECATED ] ; if ( in_array ( $ severity , $ recoverable ) ) { return ; } throw $ ErrorException ; } }
10354	protected function getEventName ( ) { $ chunks = explode ( '\\' , get_class ( $ this ) ) ; $ name = $ chunks [ count ( $ chunks ) - 2 ] ; return strtolower ( $ name ) ; }
1096	protected function scopedAttributes ( $ node ) { $ keys = $ this -> node -> getScopedColumns ( ) ; if ( count ( $ keys ) == 0 ) return array ( ) ; $ values = array_map ( function ( $ column ) use ( $ node ) { return $ node -> getAttribute ( $ column ) ; } , $ keys ) ; return array_combine ( $ keys , $ values ) ; }
5945	public function freetext ( $ freetext , $ deploymentSiteIds = null , $ mode = self :: FREETEXT_OR , $ ignoreGrouping = false , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'deploymentSiteIds' => $ deploymentSiteIds , 'mode' => $ mode , 'ignoreGrouping' => $ ignoreGrouping ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/filters/freetext/' . $ freetext . '' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new FilterItem ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
7379	public function fetchFilter ( string $ key , $ default = null , $ filter = FILTER_DEFAULT , $ options = [ ] ) { $ value = $ this -> fetch ( $ key , $ default ) ; if ( ! is_array ( $ options ) && $ options ) { $ options = [ 'flags' => $ options ] ; } if ( is_array ( $ value ) && ! isset ( $ options [ 'flags' ] ) ) { $ options [ 'flags' ] = FILTER_REQUIRE_ARRAY ; } return filter_var ( $ value , $ filter , $ options ) ; }
1355	protected function defaultSort ( ) { return collect ( $ this -> defaultSort ) -> map ( function ( $ param ) { $ desc = ( $ param [ 0 ] === '-' ) ; $ field = ltrim ( $ param , '-' ) ; return new SortParameter ( $ field , ! $ desc ) ; } ) -> all ( ) ; }
7600	public function render ( array $ aButtons , array $ aButtonGroupOptions = null ) { if ( empty ( $ aButtonGroupOptions [ 'attributes' ] ) ) { $ aButtonGroupOptions [ 'attributes' ] = array ( 'class' => 'btn-group' ) ; } else { if ( ! is_array ( $ aButtonGroupOptions [ 'attributes' ] ) ) { throw new LogicException ( '"attributes" option expects an array, "' . gettype ( $ aButtonGroupOptions [ 'attributes' ] ) . '" given' ) ; } if ( empty ( $ aButtonGroupOptions [ 'attributes' ] [ 'class' ] ) ) { $ aButtonGroupOptions [ 'attributes' ] [ 'class' ] = 'btn-group' ; } elseif ( ! preg_match ( '/(\s|^)(?:btn-group|btn-group-vertical)(\s|$)/' , $ aButtonGroupOptions [ 'attributes' ] [ 'class' ] ) ) { $ aButtonGroupOptions [ 'attributes' ] [ 'class' ] .= ' btn-group' ; } } return sprintf ( static :: $ buttonGroupContainerFormat , $ this -> createAttributesString ( $ aButtonGroupOptions [ 'attributes' ] ) , $ this -> renderButtons ( $ aButtons , strpos ( $ aButtonGroupOptions [ 'attributes' ] [ 'class' ] , 'btn-group-justified' ) !== false ) ) ; }
5416	protected function dispatchRequest ( $ socket , $ encoding ) { foreach ( $ this -> headers as $ header_line ) { $ socket -> write ( $ header_line . "\r\n" ) ; } if ( count ( $ this -> cookies ) > 0 ) { $ socket -> write ( 'Cookie: ' . implode ( ';' , $ this -> cookies ) . "\r\n" ) ; } $ encoding -> writeHeadersTo ( $ socket ) ; $ socket -> write ( "\r\n" ) ; $ encoding -> writeTo ( $ socket ) ; }
1778	public static function optionChecked ( $ strOption , $ varValues ) { if ( $ strOption === '' ) { return '' ; } return ( \ is_array ( $ varValues ) ? \ in_array ( $ strOption , $ varValues ) : $ strOption == $ varValues ) ? ' checked' : '' ; }
10898	public function getScheme ( ) : array { if ( null === $ this -> scheme ) { $ raw = $ this -> medoo -> query ( 'DESCRIBE ' . $ this -> getTable ( ) ) -> fetchAll ( ) ; $ this -> scheme = [ ] ; foreach ( $ raw as $ field ) { $ this -> scheme [ $ field [ 'Field' ] ] = $ field ; } } return $ this -> scheme ; }
6604	public function makeAccessToken ( Response $ response ) { parse_str ( $ response -> content ( ) , $ params ) ; $ this -> validateAccessTokenResponse ( $ params ) ; $ this -> credentials [ 'key' ] = $ params [ 'oauth_token' ] ; $ this -> credentials [ 'secret' ] = $ params [ 'oauth_token_secret' ] ; $ this -> credentials [ 'user_id' ] = $ params [ 'user_id' ] ; $ this -> credentials [ 'screen_name' ] = $ params [ 'screen_name' ] ; return $ this ; }
1418	public function failedValidatorException ( ValidatorContract $ validator , \ Closure $ closure = null ) : JsonApiException { return new ValidationException ( $ this -> failedValidator ( $ validator , $ closure ) ) ; }
10691	public function shutdown ( ) { if ( ! $ this -> is_shutdown ) { $ this -> is_shutdown = true ; if ( ! empty ( $ this -> autoloader ) ) spl_autoload_unregister ( array ( $ this -> autoloader , 'autoload' ) ) ; ErrorInterceptor :: unregisterErrorHandler ( ) ; restore_exception_handler ( ) ; } }
8847	public function getArchivedBlogPosts ( $ year , $ month = null , $ day = null ) { $ query = $ this -> getBlogPosts ( ) -> dataQuery ( ) ; $ stage = $ query -> getQueryParam ( "Versioned.stage" ) ; if ( $ stage ) $ stage = '_' . Convert :: raw2sql ( $ stage ) ; $ query -> innerJoin ( "BlogPost" , "`SiteTree" . $ stage . "`.`ID` = `BlogPost" . $ stage . "`.`ID`" ) ; $ query -> where ( "YEAR(PublishDate) = '" . Convert :: raw2sql ( $ year ) . "'" ) ; if ( $ month ) { $ query -> where ( "MONTH(PublishDate) = '" . Convert :: raw2sql ( $ month ) . "'" ) ; if ( $ day ) { $ query -> where ( "DAY(PublishDate) = '" . Convert :: raw2sql ( $ day ) . "'" ) ; } } return $ this -> getBlogPosts ( ) -> setDataQuery ( $ query ) ; }
1159	public function getMessage ( $ attribute , $ rule , $ parameters ) { $ data = $ this -> fakeValidationData ( $ attribute , $ rule , $ parameters ) ; $ message = $ this -> validator -> getMessage ( $ attribute , $ rule ) ; $ message = $ this -> validator -> makeReplacements ( $ message , $ attribute , $ rule , $ parameters ) ; $ this -> validator -> setData ( $ data ) ; return $ message ; }
4134	public static function encryptAndAppendTag ( $ K , $ IV , $ P = null , $ A = null , $ tag_length = 128 ) { return implode ( self :: encrypt ( $ K , $ IV , $ P , $ A , $ tag_length ) ) ; }
10398	protected function doReplacement ( $ inputString ) { if ( is_string ( $ inputString ) ) { $ inputString = str_replace ( array_keys ( $ this -> replacements ) , array_values ( $ this -> replacements ) , $ inputString ) ; } return $ inputString ; }
1310	public static function categoriesMenu ( $ categories ) { $ menu = '<ul class="nav nav-pills nav-stacked">' ; foreach ( $ categories as $ category ) { $ menu .= '<li>' ; $ menu .= '<a href="/' . config ( 'chatter.routes.home' ) . '/' . config ( 'chatter.routes.category' ) . '/' . $ category [ 'slug' ] . '">' ; $ menu .= '<div class="chatter-box" style="background-color:' . $ category [ 'color' ] . '"></div>' ; $ menu .= $ category [ 'name' ] . '</a>' ; if ( count ( $ category [ 'parents' ] ) ) { $ menu .= static :: categoriesMenu ( $ category [ 'parents' ] ) ; } $ menu .= '</li>' ; } $ menu .= '</ul>' ; return $ menu ; }
9124	private function appendPayloadToRequest ( MemoryStream $ ms ) : MemoryStream { $ this -> payload -> reset ( ) ; while ( $ this -> payload -> ready ( ) ) { $ ms -> write ( $ this -> payload -> read ( 1024 ) ) ; } $ ms -> reset ( ) ; return $ ms ; }
1244	public static function memoize ( callable $ provider ) { return function ( ) use ( $ provider ) { static $ result ; static $ isConstant ; if ( $ isConstant ) { return $ result ; } $ isConstant = true ; return $ result = $ provider ( ) ; } ; }
8955	public function createRelation ( $ changeset , $ tags , $ members ) { $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = 'relation/create' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ tagList = '' ; if ( ! empty ( $ tags ) ) { foreach ( $ tags as $ key => $ value ) { $ tagList .= '<tag k="' . $ key . '" v="' . $ value . '"/>' ; } } $ memberList = '' ; if ( ! empty ( $ members ) ) { foreach ( $ members as $ member ) { if ( $ member [ 'type' ] == 'node' ) { $ memberList .= '<member type="' . $ member [ 'type' ] . '" role="' . $ member [ 'role' ] . '" ref="' . $ member [ 'ref' ] . '"/>' ; } elseif ( $ member [ 'type' ] == 'way' ) { $ memberList .= '<member type="' . $ member [ 'type' ] . '" ref="' . $ member [ 'ref' ] . '"/>' ; } } } $ xml = '<?xml version="1.0" encoding="UTF-8"?> <osm version="0.6" generator="JoomlaOpenStreetMap"> <relation relation="' . $ changeset . '" >' . $ tagList . $ memberList . '</relation> </osm>' ; $ header [ 'Content-Type' ] = 'text/xml' ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'PUT' , $ parameters , $ xml , $ header ) ; return $ response -> body ; }
1564	public function setResource ( $ resource ) : ClientJob { $ schema = $ this -> getApi ( ) -> getContainer ( ) -> getSchema ( $ resource ) ; $ this -> fill ( [ 'resource_type' => $ schema -> getResourceType ( ) , 'resource_id' => $ schema -> getId ( $ resource ) , ] ) ; return $ this ; }
5400	protected function truncateHost ( $ host ) { $ tlds = SimpleUrl :: getAllTopLevelDomains ( ) ; if ( preg_match ( '/[a-z\-]+\.(' . $ tlds . ')$/i' , $ host , $ matches ) ) { return $ matches [ 0 ] ; } elseif ( preg_match ( '/[a-z\-]+\.[a-z\-]+\.[a-z\-]+$/i' , $ host , $ matches ) ) { return $ matches [ 0 ] ; } return false ; }
8659	private function convertGetFeedSubmissionCount ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetFeedSubmissionCount' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetFeedTypeList ( ) ) { $ feedTypeList = $ request -> getFeedTypeList ( ) ; foreach ( $ feedTypeList -> getType ( ) as $ typeIndex => $ type ) { $ parameters [ 'FeedTypeList' . '.' . 'Type' . '.' . ( $ typeIndex + 1 ) ] = $ type ; } } if ( $ request -> isSetFeedProcessingStatusList ( ) ) { $ feedProcessingStatusList = $ request -> getFeedProcessingStatusList ( ) ; foreach ( $ feedProcessingStatusList -> getStatus ( ) as $ statusIndex => $ status ) { $ parameters [ 'FeedProcessingStatusList' . '.' . 'Status' . '.' . ( $ statusIndex + 1 ) ] = $ status ; } } if ( $ request -> isSetSubmittedFromDate ( ) ) { $ parameters [ 'SubmittedFromDate' ] = $ this -> getFormattedTimestamp ( $ request -> getSubmittedFromDate ( ) ) ; } if ( $ request -> isSetSubmittedToDate ( ) ) { $ parameters [ 'SubmittedToDate' ] = $ this -> getFormattedTimestamp ( $ request -> getSubmittedToDate ( ) ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
1285	private function fetchResourcesForGivenIds ( array $ resourceIds , string $ type , string $ locale = null ) : array { $ resources = [ ] ; $ resourcePoolOptions = [ 'locale' => $ locale ] ; foreach ( $ resourceIds as $ index => $ resourceId ) { if ( $ this -> resourcePool -> has ( $ type , $ resourceId , $ resourcePoolOptions ) ) { $ resources [ ] = $ this -> resourcePool -> get ( $ type , $ resourceId , $ resourcePoolOptions ) ; unset ( $ resourceIds [ $ index ] ) ; } } foreach ( $ this -> createIdChunks ( $ resourceIds ) as $ chunk ) { $ resources += $ this -> fetchCollectionFromApi ( $ chunk , $ type , $ locale ) ; } return $ resources ; }
2938	public function deleteBackups ( $ filePaths = [ ] ) { if ( empty ( $ filePaths ) ) { $ allBackups = $ this -> getBackups ( ) ; foreach ( $ allBackups as $ backup ) { $ filePaths [ ] = $ backup [ 'filepath' ] ; } } foreach ( $ filePaths as $ filePath ) { if ( is_file ( $ filePath ) ) { unlink ( $ filePath ) ; } } return $ this ; }
4755	public function stopProfiling ( ) { if ( ! $ this -> profiling ) { return false ; } $ this -> profiling = false ; $ xhprof_data = xhprof_disable ( ) ; if ( is_array ( $ xhprof_data ) ) { $ this -> parser -> parse ( $ xhprof_data ) ; } foreach ( $ this -> probes as $ probe ) { $ name = $ probe -> getName ( ) ; if ( $ probe -> isTimingProbe ( ) ) { $ this -> timers [ $ name ] = $ probe -> getTime ( ) ; } if ( $ probe -> isCallsProbe ( ) ) { $ this -> counters [ $ name ] = $ probe -> getCount ( ) ; } } return true ; }
3830	protected function prepareFrontendFilterOptions ( $ arrWidget , $ arrFilterUrl , $ arrJumpTo , $ blnAutoSubmit ) { $ arrOptions = array ( ) ; if ( ! isset ( $ arrWidget [ 'options' ] ) ) { return $ arrOptions ; } $ filterUrl = new FilterUrl ( $ arrJumpTo ) ; foreach ( $ arrFilterUrl as $ name => $ value ) { if ( is_array ( $ value ) ) { $ value = implode ( ',' , array_filter ( $ value ) ) ; } $ filterUrl -> setSlug ( $ name , ( string ) $ value ) ; } $ parameterName = $ arrWidget [ 'eval' ] [ 'urlparam' ] ; if ( $ arrWidget [ 'eval' ] [ 'includeBlankOption' ] ) { $ blnActive = $ this -> isActiveFrontendFilterValue ( $ arrWidget , $ arrFilterUrl , '' ) ; $ arrOptions [ ] = array ( 'key' => '' , 'value' => ( $ arrWidget [ 'eval' ] [ 'blankOptionLabel' ] ? $ arrWidget [ 'eval' ] [ 'blankOptionLabel' ] : $ GLOBALS [ 'TL_LANG' ] [ 'metamodels_frontendfilter' ] [ 'do_not_filter' ] ) , 'href' => $ this -> filterUrlBuilder -> generate ( $ filterUrl -> clone ( ) -> setSlug ( $ parameterName , '' ) ) , 'active' => $ blnActive , 'class' => 'doNotFilter' . ( $ blnActive ? ' active' : '' ) , ) ; } foreach ( $ arrWidget [ 'options' ] as $ strKeyOption => $ strOption ) { $ strValue = $ this -> getFrontendFilterValue ( $ arrWidget , $ arrFilterUrl , $ strKeyOption ) ; $ blnActive = $ this -> isActiveFrontendFilterValue ( $ arrWidget , $ arrFilterUrl , $ strKeyOption ) ; $ arrOptions [ ] = array ( 'key' => $ strKeyOption , 'value' => $ strOption , 'href' => $ this -> filterUrlBuilder -> generate ( $ filterUrl -> clone ( ) -> setSlug ( $ parameterName , $ strValue ) ) , 'active' => $ blnActive , 'class' => StringUtil :: standardize ( $ strKeyOption ) . ( $ blnActive ? ' active' : '' ) ) ; } return $ arrOptions ; }
3119	public function fromArray ( $ data ) { $ this -> points = [ ] ; if ( is_array ( $ data ) ) { foreach ( $ data as $ dataPoint ) { $ point = new TimePoint ( ) ; $ point -> fromArray ( $ dataPoint ) ; $ this -> points [ ] = $ point ; } } }
12156	public function getOwner ( ) { if ( ! $ this -> isOwnable ) { return ; } $ ownerObject = $ this -> getOwnerObject ( ) ; if ( is_object ( $ ownerObject ) ) { return $ ownerObject -> primaryKey ; } return $ ownerObject ; }
9460	public function deleteTickets ( array $ tickets ) { $ ids = array ( ) ; foreach ( $ tickets as $ ticket ) { $ ids [ ] = $ ticket -> getId ( ) ; } return parent :: deleteByIds ( $ ids , 'tickets/destroy_many.json' ) ; }
3264	protected static function checkStatusChange ( $ order , $ prevStatusCode ) { if ( ! empty ( $ prevStatusCode ) && $ order -> statusCode != $ prevStatusCode ) \ event ( new OrderStatusChanged ( $ order -> id , $ order -> statusCode , $ prevStatusCode ) ) ; }
4687	public function where ( ? string $ expression = null , ... $ args ) : self { $ this -> dirty ( ) ; $ this -> where = $ expression ; $ this -> args [ 'where' ] = $ args ; return $ this ; }
3380	public function getModel ( $ entity ) { if ( \ Links :: isMain ( $ entity ) ) { $ modelClass = 'Serverfireteam\\Panel\\' . $ entity ; } else { if ( ! empty ( \ Config :: get ( 'panel.modelPath' ) ) ) { $ modelClass = $ this -> getNameSpace ( ) . \ Config :: get ( 'panel.modelPath' ) . '\\' . $ entity ; } else { $ modelClass = $ this -> getNameSpace ( ) . $ entity ; } } return $ modelClass ; }
3077	public function processOutput ( QtiRunnerServiceContext $ context ) { $ messages = [ ] ; $ channels = $ this -> getOption ( self :: OPTION_CHANNELS ) ; if ( is_array ( $ channels [ self :: CHANNEL_TYPE_OUTPUT ] ) ) { foreach ( $ channels [ self :: CHANNEL_TYPE_OUTPUT ] as $ outputChannelName => $ outputChannelClass ) { $ channel = $ this -> getChannel ( $ outputChannelName , self :: CHANNEL_TYPE_OUTPUT ) ; $ message = $ this -> processChannel ( $ channel , $ context ) ; if ( $ message !== null ) { $ messages [ ] = [ 'channel' => $ channel -> getName ( ) , 'message' => $ message , ] ; } } } return $ messages ; }
9587	protected function getAttribute ( SimpleXmlElement $ node , $ name ) { $ attributes = $ node -> attributes ( ) ; return ( string ) $ attributes [ $ name ] ; }
6096	public function memberOf ( ) { $ groups = array ( $ this -> getParent ( ) -> channelGroupGetById ( $ this [ "client_channel_group_id" ] ) ) ; foreach ( explode ( "," , $ this [ "client_servergroups" ] ) as $ sgid ) { $ groups [ ] = $ this -> getParent ( ) -> serverGroupGetById ( $ sgid ) ; } return $ groups ; }
12483	private function plainBonus ( $ bonus ) { $ result = [ ] ; foreach ( $ bonus as $ item ) { $ bonusData = $ item -> getEntries ( ) ; foreach ( $ bonusData as $ entry ) { $ bonus = $ entry -> getValue ( ) ; if ( $ bonus > Cfg :: DEF_ZERO ) { $ result [ ] = $ entry ; } } } return $ result ; }
776	private function supportsFractionalSeconds ( ) { $ version = $ this -> db -> getSlavePdo ( ) -> getAttribute ( \ PDO :: ATTR_SERVER_VERSION ) ; return version_compare ( $ version , '5.6.4' , '>=' ) ; }
10900	public function validate ( string $ method = 'save' ) : array { $ errors = [ ] ; foreach ( $ this -> getValidators ( ) [ $ method ] ?? [ ] as $ field => $ validator ) { try { $ validator -> setName ( $ field ) -> assert ( $ this -> get ( $ field ) ) ; } catch ( NestedValidationException $ e ) { $ errors [ $ field ] = $ e -> getMessages ( ) ; } } return $ errors ; }
1460	protected function orderDesc ( ) { $ this -> query -> orderByDesc ( $ this -> column ) ; if ( $ this -> isNotPagingOnKey ( ) ) { $ this -> query -> orderByDesc ( $ this -> key ) ; } return $ this ; }
3862	public function getOutputFormat ( ) { if ( isset ( $ this -> strOutputFormat ) ) { return $ this -> strOutputFormat ; } if ( isset ( $ this -> objView ) && $ this -> objView -> get ( 'format' ) ) { return $ this -> objView -> get ( 'format' ) ; } $ page = $ this -> getPage ( ) ; if ( $ page && $ page -> outputFormat ) { return $ page -> outputFormat ; } return 'text' ; }
3534	public static function createNewUser ( $ username , $ individualGroupAssignmentOptions = null ) { if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: beginProfile ( 'createNewUser' , static :: YII2_PROFILE_NAME . 'createNewUser' ) ; } $ userObjectDb = new static ( ) ; $ userObjectDb -> username = $ username ; $ userObjectDb -> setIndividualGroupAssignmentOptions ( $ individualGroupAssignmentOptions ) ; if ( $ userObjectDb -> queryLdapUserObject ( ) == null ) { $ userObjectDb = null ; } else { $ roles = $ userObjectDb -> updateGroupAssignment ( ) ; if ( count ( $ roles ) > 0 || static :: getGroupAssigmentOptions ( 'LOGIN_POSSIBLE_WITH_ROLE_ASSIGNED_MATCHING_REGEX' , $ userObjectDb -> individualGroupAssignmentOptions ) == null ) { $ userObjectDb -> generateAuthKey ( ) ; $ userObjectDb -> updateAccountStatus ( ) ; $ userObjectDb -> save ( ) ; } else { $ userObjectDb = null ; } } if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: endProfile ( 'createNewUser' , static :: YII2_PROFILE_NAME . 'createNewUser' ) ; } return $ userObjectDb ; }
11716	public static function entry ( $ argv ) : void { self :: initialize ( ) ; if ( isset ( $ argv [ 1 ] ) ) { $ command = $ argv [ 1 ] ; } else { return ; } if ( ! in_array ( $ command , array_keys ( self :: $ commands ) ) ) { return ; } $ arguments = [ ] ; $ options = [ ] ; for ( $ index = 2 ; $ index < count ( $ argv ) ; $ index ++ ) { list ( $ key , $ value ) = Service :: parse ( $ argv [ $ index ] ) ; if ( Service :: determineTypeOfWord ( $ argv [ $ index ] ) == Service :: OPTION_TYPE ) { if ( ! $ value ) { $ options [ $ key ] = true ; } else { $ options [ $ key ] = $ value ; } } else { $ arguments [ ] = $ key ; } } Service :: runCommand ( self :: $ commands [ $ command ] , $ arguments , $ options ) ; }
98	public function add ( $ prefix , $ paths , $ prepend = false ) { if ( ! $ prefix ) { if ( $ prepend ) { $ this -> fallbackDirsPsr0 = array_merge ( ( array ) $ paths , $ this -> fallbackDirsPsr0 ) ; } else { $ this -> fallbackDirsPsr0 = array_merge ( $ this -> fallbackDirsPsr0 , ( array ) $ paths ) ; } return ; } $ first = $ prefix [ 0 ] ; if ( ! isset ( $ this -> prefixesPsr0 [ $ first ] [ $ prefix ] ) ) { $ this -> prefixesPsr0 [ $ first ] [ $ prefix ] = ( array ) $ paths ; return ; } if ( $ prepend ) { $ this -> prefixesPsr0 [ $ first ] [ $ prefix ] = array_merge ( ( array ) $ paths , $ this -> prefixesPsr0 [ $ first ] [ $ prefix ] ) ; } else { $ this -> prefixesPsr0 [ $ first ] [ $ prefix ] = array_merge ( $ this -> prefixesPsr0 [ $ first ] [ $ prefix ] , ( array ) $ paths ) ; } }
8812	public function view ( $ view , array $ data = [ ] ) { if ( function_exists ( 'app' ) ) { $ this -> setContent ( app ( 'load' ) -> view ( $ view , $ data ) ) ; return $ this ; } return ; }
12840	static public function getMimeType ( $ filePath , $ default = 'application/octet-stream' ) { $ mimeType = finfo_file ( finfo_open ( FILEINFO_MIME_TYPE ) , $ filePath ) ; if ( $ mimeType === false ) { $ mimeType = $ default ; } return $ mimeType ; }
5403	protected function fixPath ( $ path ) { if ( substr ( $ path , 0 , 1 ) != '/' ) { $ path = '/' . $ path ; } if ( substr ( $ path , - 1 , 1 ) != '/' ) { $ path .= '/' ; } return $ path ; }
3428	public function paginate ( $ perPage = 15 , $ pageName = 'page' ) { $ page = Paginator :: resolveCurrentPage ( $ pageName ) ; $ total = $ this -> count ( ) ; $ results = $ this -> forPage ( $ page , $ perPage ) -> getList ( ) ; return new LengthAwarePaginator ( $ results , $ total , $ perPage , $ page , [ 'path' => Paginator :: resolveCurrentPath ( ) , 'pageName' => $ pageName , ] ) ; }
7795	protected function statementBody ( $ text ) { switch ( substr ( $ this -> getLine ( '20' , $ text ) , 0 , 4 ) ) { case '940A' : $ this -> format = self :: FORMAT_CLASSIC ; break ; case '940S' : $ this -> format = self :: FORMAT_STRUCTURED ; break ; default : throw new \ RuntimeException ( 'Unknown file format' ) ; } return parent :: statementBody ( $ text ) ; }
12978	protected function detectMetadataDriver ( $ dir , $ configPath ) { foreach ( ( array ) $ configPath as $ cPath ) { $ path = $ dir . DS . $ cPath . DS ; if ( ( $ files = glob ( $ path . '*.dcm.xml' ) ) && count ( $ files ) ) { return 'xml' ; } elseif ( ( $ files = glob ( $ path . '*.orm.xml' ) ) && count ( $ files ) ) { return 'simplified_xml' ; } elseif ( ( $ files = glob ( $ path . '*.dcm.yml' ) ) && count ( $ files ) ) { return 'yml' ; } elseif ( ( $ files = glob ( $ path . '*.orm.yml' ) ) && count ( $ files ) ) { return 'simplified_yml' ; } elseif ( ( $ files = glob ( $ path . '*.php' ) ) && count ( $ files ) ) { return 'php' ; } } if ( is_dir ( $ dir . DS . $ this -> getClassPath ( ) . $ this -> getObjectName ( ) ) ) { return 'annotation' ; } return false ; }
5921	public function getProperty ( $ systemName ) { foreach ( $ this -> propertySets as $ propertySet ) { foreach ( $ propertySet -> getProperties ( ) as $ property ) { if ( $ property -> getPropertyType ( ) -> getSystemName ( ) == $ systemName ) { return $ property ; } } } throw new PropertyNotFoundException ( 'No Property with the system name "' . $ systemName . '" exists.' ) ; }
3265	protected function preserveLines ( $ data , bool $ reverse ) { $ search = [ "\n" , "\r" ] ; $ replace = [ '\\n' , '\\r' ] ; if ( $ reverse ) { $ search = [ '\\n' , '\\r' ] ; $ replace = [ "\n" , "\r" ] ; } if ( is_string ( $ data ) ) { $ data = str_replace ( $ search , $ replace , $ data ) ; } elseif ( is_array ( $ data ) ) { foreach ( $ data as & $ value ) { $ value = $ this -> preserveLines ( $ value , $ reverse ) ; } unset ( $ value ) ; } return $ data ; }
5770	public function getLoggedInAdministrator ( ) : Administrator { if ( ! isset ( $ _SESSION [ SlimPostgres :: SESSION_KEY_ADMINISTRATOR_ID ] ) ) { throw new \ Exception ( "No one is logged in" ) ; } if ( null === $ administrator = ( AdministratorsEntityMapper :: getInstance ( ) ) -> getObjectById ( $ _SESSION [ SlimPostgres :: SESSION_KEY_ADMINISTRATOR_ID ] ) ) { unset ( $ _SESSION [ SlimPostgres :: SESSION_KEY_ADMINISTRATOR_ID ] ) ; throw new \ Exception ( "Invalid administrator id " . $ _SESSION [ SlimPostgres :: SESSION_KEY_ADMINISTRATOR_ID ] . " in session" ) ; } return $ administrator ; }
10411	public function invalidate ( ) { $ script = escapeshellcmd ( $ this -> rootDir . "/../{$this->cacheScript}" ) ; $ urlsFile = escapeshellarg ( $ this -> createUrlsTempFile ( ) ) ; $ curlTimeout = escapeshellarg ( $ this -> curlTimeout ) ; $ process = new Process ( sprintf ( '%s %s %s' , $ script , $ urlsFile , $ curlTimeout ) ) ; $ process -> start ( ) ; $ this -> resetCache ( ) ; return $ urlsFile ; }
646	public function checkIntegrity ( $ check = true , $ schema = '' , $ table = '' ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> checkIntegrity ( $ check , $ schema , $ table ) ; return $ this -> setSql ( $ sql ) ; }
9803	public function setCreated ( $ time ) { if ( $ time === null ) { $ time = time ( ) ; } elseif ( is_string ( $ time ) ) { if ( is_numeric ( $ time ) ) { $ time = ( int ) $ time ; } else { $ time = strtotime ( $ time ) ; } } $ this -> created = $ time ; return $ this ; }
9054	public function createRelationTable ( $ tableName ) : self { $ table = $ this -> getTableData ( $ tableName ) ; $ name = $ this -> name . '_x_' . $ table -> name ; return $ this -> relationTables [ ] = $ this -> tableFactory -> create ( $ name , $ this -> prefix ) ; }
4985	public function setParam ( $ key , $ value ) { $ this -> params [ $ key ] = $ value ; foreach ( $ this -> forms as $ form ) { if ( isset ( $ form [ '__instance__' ] ) && is_object ( $ form [ '__instance__' ] ) && method_exists ( $ form [ '__instance__' ] , 'setParam' ) ) { $ form [ '__instance__' ] -> setParam ( $ key , $ value ) ; } } return $ this ; }
9950	public function duplicateStyle ( Style $ pCellStyle , $ pRange ) { $ workbook = $ this -> parent ; if ( $ existingStyle = $ this -> parent -> getCellXfByHashCode ( $ pCellStyle -> getHashCode ( ) ) ) { $ xfIndex = $ existingStyle -> getIndex ( ) ; } else { $ workbook -> addCellXf ( $ pCellStyle ) ; $ xfIndex = $ pCellStyle -> getIndex ( ) ; } list ( $ rangeStart , $ rangeEnd ) = Coordinate :: rangeBoundaries ( $ pRange . ':' . $ pRange ) ; if ( $ rangeStart [ 0 ] > $ rangeEnd [ 0 ] && $ rangeStart [ 1 ] > $ rangeEnd [ 1 ] ) { $ tmp = $ rangeStart ; $ rangeStart = $ rangeEnd ; $ rangeEnd = $ tmp ; } for ( $ col = $ rangeStart [ 0 ] ; $ col <= $ rangeEnd [ 0 ] ; ++ $ col ) { for ( $ row = $ rangeStart [ 1 ] ; $ row <= $ rangeEnd [ 1 ] ; ++ $ row ) { $ this -> getCell ( Coordinate :: stringFromColumnIndex ( $ col ) . $ row ) -> setXfIndex ( $ xfIndex ) ; } } return $ this ; }
5468	public function addHeaders ( $ request , $ url ) { if ( $ url -> getUsername ( ) && $ url -> getPassword ( ) ) { $ username = $ url -> getUsername ( ) ; $ password = $ url -> getPassword ( ) ; } elseif ( $ realm = $ this -> findRealmFromUrl ( $ url ) ) { $ username = $ realm -> getUsername ( ) ; $ password = $ realm -> getPassword ( ) ; } else { return ; } $ this -> addBasicHeaders ( $ request , $ username , $ password ) ; }
12778	public function getRefreshInstructions ( ) { $ i = [ ] ; $ i [ 'type' ] = 'widget' ; $ i [ 'systemId' ] = $ this -> collectorItem -> systemId ; $ i [ 'recreateParams' ] = $ this -> recreateParams ; if ( $ this -> section ) { $ i [ 'section' ] = $ this -> section -> systemId ; } return $ i ; }
9702	public function addFont ( \ PhpOffice \ PhpSpreadsheet \ Style \ Font $ font ) { $ fontHashCode = $ font -> getHashCode ( ) ; if ( isset ( $ this -> addedFonts [ $ fontHashCode ] ) ) { $ fontIndex = $ this -> addedFonts [ $ fontHashCode ] ; } else { $ countFonts = count ( $ this -> fontWriters ) ; $ fontIndex = ( $ countFonts < 4 ) ? $ countFonts : $ countFonts + 1 ; $ fontWriter = new Font ( $ font ) ; $ fontWriter -> setColorIndex ( $ this -> addColor ( $ font -> getColor ( ) -> getRGB ( ) ) ) ; $ this -> fontWriters [ ] = $ fontWriter ; $ this -> addedFonts [ $ fontHashCode ] = $ fontIndex ; } return $ fontIndex ; }
12088	public function view ( UserPolicy $ user , Response $ response ) { if ( $ user -> canDo ( 'forum.response.view' ) && $ user -> isAdmin ( ) ) { return true ; } return $ response -> user_id == user_id ( ) && $ response -> user_type == user_type ( ) ; }
11580	public function getStatus ( ) { $ message = 'Tracking ' ; $ numRepos = 0 ; if ( isset ( $ this [ 'repositories' ] ) && ( 1 === ( $ numRepos = count ( $ this [ 'repositories' ] ) ) ) ) { $ message .= '1 repository.' ; } else { $ message .= $ numRepos . ' repositories.' ; } return $ message ; }
3888	public function getAttributeNames ( \ DC_Table $ objDc ) { $ attributeNames = [ 'sorting' => $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'metamodels_sorting' ] , 'random' => $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'random' ] , 'id' => $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'id' ] [ 0 ] ] ; $ metaModelName = $ this -> factory -> translateIdToMetaModelName ( $ objDc -> activeRecord -> metamodel ) ; $ metaModel = $ this -> factory -> getMetaModel ( $ metaModelName ) ; if ( $ metaModel ) { foreach ( $ metaModel -> getAttributes ( ) as $ objAttribute ) { $ attributeNames [ $ objAttribute -> getColName ( ) ] = $ objAttribute -> getName ( ) ; } } return $ attributeNames ; }
9901	public function parse ( $ formula ) { $ this -> currentCharacter = 0 ; $ this -> formula = $ formula ; $ this -> lookAhead = isset ( $ formula [ 1 ] ) ? $ formula [ 1 ] : '' ; $ this -> advance ( ) ; $ this -> parseTree = $ this -> condition ( ) ; return true ; }
11378	public function postAction ( ) { if ( ! preg_match ( '/\/page\/(\w+[\-\w]*)\/text\/(..)$/' , $ this -> name , $ matches ) ) { throw new InvalidParameterException ( "Invalid parameters" ) ; } list ( $ dummy , $ pageName , $ language ) = $ matches ; $ request = $ this -> environment -> getRequestHelper ( ) ; $ name = $ request -> getIdentifierParam ( 'name' ) ; $ content = $ request -> getParam ( 'content' , '' ) ; try { $ pageTexts = $ this -> getTextModel ( $ pageName ) ; $ text = $ pageTexts -> addTextContainer ( $ name , $ this -> filter ( $ content ) , $ language ) ; $ this -> environment -> sendJSONResult ( $ text ) ; } catch ( \ Exception $ e ) { throw new InvalidParameterException ( $ e -> getMessage ( ) ) ; } }
7266	public static function find ( $ id , $ idColumn = null ) { $ tableName = static :: tableName ( ) ; $ idColumn = $ idColumn ? : static :: $ idColumn ; $ rows = Db :: query ( " select * from $tableName where $idColumn = :id " , [ "id" => $ id ] , static :: getDbName ( ) ) ; if ( $ rows === false ) return false ; if ( empty ( $ rows ) ) return null ; $ model = new static ; foreach ( $ rows [ 0 ] as $ col => $ val ) $ model -> $ col = $ model -> decodeValue ( $ val , $ col ) ; return $ model ; }
4591	public function setOwnerUuid ( ? string $ ownerUuid ) { if ( null !== $ ownerUuid ) { if ( ! preg_match ( '/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i' , $ ownerUuid ) ) { throw new InvalidArgumentException ( 'Owner uuid is not valid.' ) ; } } $ this -> ownerUuid = $ ownerUuid ; return $ this ; }
4570	public function postLoad ( LifecycleEventArgs $ args ) { $ entity = $ args -> getEntity ( ) ; if ( ! $ entity instanceof Encryptable ) { return ; } $ entity -> setEncrypted ( true ) ; $ this -> encryptionService -> decrypt ( $ entity ) ; }
8726	public function shouldFallback ( $ locale = null ) { if ( ! $ this -> getWithFallback ( ) || ! $ this -> getFallbackLocale ( ) ) { return false ; } $ locale = $ locale ? : $ this -> getLocale ( ) ; return $ locale != $ this -> getFallbackLocale ( ) ; }
2159	public function run210Update ( ) { $ this -> Database -> query ( "ALTER TABLE `tl_style` ADD `positioning` char(1) NOT NULL default ''" ) ; $ this -> Database -> query ( "UPDATE `tl_style` SET `positioning`=`size`" ) ; $ this -> Database -> query ( "UPDATE `tl_module` SET `guests`=1 WHERE `type`='lostPassword' OR `type`='registration'" ) ; $ this -> Database -> query ( "UPDATE `tl_news` SET `teaser`=CONCAT('<p>', teaser, '</p>') WHERE `teaser`!='' AND `teaser` NOT LIKE '<p>%'" ) ; }
4248	public function onOutput ( Event $ event ) { $ this -> outputEvent = $ event ; $ this -> channelName = $ this -> debug -> getCfg ( 'channel' ) ; $ this -> data = $ this -> debug -> getData ( ) ; $ event [ 'headers' ] [ ] = array ( 'X-Wf-Protocol-1' , 'http://meta.wildfirehq.org/Protocol/JsonStream/0.2' ) ; $ event [ 'headers' ] [ ] = array ( 'X-Wf-1-Plugin-1' , 'http://meta.firephp.org/Wildfire/Plugin/FirePHP/Library-FirePHPCore/' . self :: FIREPHP_PROTO_VER ) ; $ event [ 'headers' ] [ ] = array ( 'X-Wf-1-Structure-1' , 'http://meta.firephp.org/Wildfire/Structure/FirePHP/FirebugConsole/0.1' ) ; $ heading = isset ( $ _SERVER [ 'REQUEST_METHOD' ] ) ? $ _SERVER [ 'REQUEST_METHOD' ] . ' ' . $ _SERVER [ 'REQUEST_URI' ] : '$: ' . \ implode ( ' ' , $ _SERVER [ 'argv' ] ) ; $ this -> processLogEntryWEvent ( 'groupCollapsed' , array ( 'PHP: ' . $ heading ) ) ; $ this -> processAlerts ( ) ; $ this -> processSummary ( ) ; $ this -> processLog ( ) ; $ this -> processLogEntryWEvent ( 'groupEnd' ) ; $ event [ 'headers' ] [ ] = array ( 'X-Wf-1-Index' , $ this -> messageIndex ) ; $ this -> data = array ( ) ; return ; }
6902	public function url ( $ page = 1 ) { $ page = max ( 1 , ( int ) $ page ) ; if ( $ page === 1 AND ! $ this -> first_page_in_url ) { $ page = NULL ; } switch ( $ this -> current_page_source ) { case 'query_string' : case 'mixed' : return URL :: site ( $ this -> request -> uri ( ) . $ this -> query ( [ $ this -> current_page_source_key => $ page ] ) ) ; case 'route' : return URL :: site ( $ this -> route -> url ( array_merge ( $ this -> route_params , array ( $ this -> current_page_source_key => $ page ) ) ) . $ this -> query ( ) ) ; } return '#' ; }
5441	public function parse ( $ raw ) { if ( ! isset ( $ this -> parser ) ) { return false ; } $ length = strlen ( $ raw ) ; while ( is_array ( $ parsed = $ this -> reduce ( $ raw ) ) ) { list ( $ raw , $ unmatched , $ matched , $ mode ) = $ parsed ; if ( ! $ this -> dispatchTokens ( $ unmatched , $ matched , $ mode ) ) { return false ; } if ( $ raw === '' ) { return true ; } if ( strlen ( $ raw ) == $ length ) { return false ; } $ length = strlen ( $ raw ) ; } if ( ! $ parsed ) { return false ; } return $ this -> invokeParser ( $ raw , LEXER_UNMATCHED ) ; }
9621	protected function qsencode ( array $ data = array ( ) ) { $ req = '' ; if ( $ data ) { foreach ( $ data as $ key => $ value ) { $ req .= $ key . '=' . urlencode ( stripslashes ( $ value ) ) . '&' ; } $ req = substr ( $ req , 0 , strlen ( $ req ) - 1 ) ; } return $ req ; }
6284	protected static function buildHttpClient05 ( LoopInterface $ loop , $ connector = null ) { if ( $ connector instanceof DnsResolver ) { @ trigger_error ( sprintf ( 'Passing a %s to buildHttpClient is deprecated since version 2.1.0 and will be removed in 3.0. If you need no specific behaviour, omit the $dns argument, otherwise pass a %s' , DnsResolver :: class , ConnectorInterface :: class ) , E_USER_DEPRECATED ) ; $ connector = static :: buildConnector ( $ loop , $ connector ) ; } if ( null !== $ connector && ! $ connector instanceof ConnectorInterface ) { throw new \ InvalidArgumentException ( '$connector must be an instance of DnsResolver or ConnectorInterface' ) ; } return new HttpClient ( $ loop , $ connector ) ; }
5935	public function setGroups ( array $ groups ) { $ this -> groups = [ ] ; foreach ( $ groups as $ item ) { $ this -> addGroup ( $ item ) ; } return $ this ; }
4885	public function setExcludeMethods ( $ methods ) { if ( is_string ( $ methods ) ) { $ methods = array ( $ methods ) ; } foreach ( $ methods as $ method ) { $ this -> addFilter ( $ method , new MethodMatchFilter ( $ method ) , FilterComposite :: CONDITION_AND ) ; } }
6959	protected function updateExpiresAt ( CartInterface $ cart ) { $ date = new \ DateTime ( ) ; $ date -> modify ( $ this -> expirationDelay ) ; $ cart -> setExpiresAt ( $ date ) ; return true ; }
11552	public function removeConsignment ( ConsignmentInterface $ consignment ) { $ adapter = $ this -> getAdapter ( $ consignment ) ; $ event = new EventConsignment ( $ consignment ) ; $ this -> eventDispatcher -> dispatch ( Events :: PRE_CONSIGNMENT_REMOVE , $ event ) ; if ( $ consignment -> getStatus ( ) != ConsignmentStatusList :: STATUS_NEW ) { throw new OperationNotPermittedException ( sprintf ( 'Can not remove Consignment "%s" with status "%s"' , $ consignment -> getId ( ) , $ consignment -> getStatus ( ) ) ) ; } try { $ adapter -> removeConsignment ( $ consignment ) ; $ this -> consignmentRepository -> removeConsignment ( $ consignment ) ; } catch ( \ Exception $ e ) { throw new VendorAdapterException ( 'Error during consignment removing.' , null , $ e ) ; } $ event = new EventConsignment ( $ consignment ) ; $ this -> eventDispatcher -> dispatch ( Events :: POST_CONSIGNMENT_REMOVE , $ event ) ; }
5726	public function recordIsPublished ( ) { if ( ! $ this -> owner -> record -> checkVersioned ( ) ) { return false ; } if ( ! $ this -> owner -> record -> isInDB ( ) ) { return false ; } $ baseClass = DataObject :: getSchema ( ) -> baseDataClass ( $ this -> owner -> record ) ; $ stageTable = DataObject :: getSchema ( ) -> tableName ( $ baseClass ) . '_Live' ; return ( bool ) DB :: query ( "SELECT \"ID\" FROM \"{$stageTable}\" WHERE \"ID\" = {$this->owner->record->ID}" ) -> value ( ) ; }
10886	protected function startSession ( Request $ request , $ sessionId ) { return tap ( $ this -> getSession ( $ sessionId ) , function ( $ session ) use ( $ request ) { $ session -> setRequestOnHandler ( $ request ) ; $ session -> start ( ) ; } ) ; }
2059	public function generateSitemap ( ) { $ objSession = Contao \ System :: getContainer ( ) -> get ( 'session' ) ; $ session = $ objSession -> get ( 'sitemap_updater' ) ; if ( empty ( $ session ) || ! \ is_array ( $ session ) ) { return ; } $ this -> import ( 'Contao\Automator' , 'Automator' ) ; foreach ( $ session as $ id ) { $ this -> Automator -> generateSitemap ( $ id ) ; } $ objSession -> set ( 'sitemap_updater' , null ) ; }
12968	protected function renderPage ( ) { $ page = $ this -> options [ "page" ] ; $ request = $ this -> options [ "request" ] ; $ username = $ this -> options [ "username" ] ; $ pageOptions = array ( 'page' => $ request -> get ( 'page' ) , 'language' => $ request -> get ( '_locale' ) , 'country' => $ request -> get ( 'country' ) , ) ; $ page -> render ( $ this -> configuration -> siteDir ( ) , $ pageOptions , $ username ) ; return $ page ; }
8708	public function select ( $ columns = [ '*' ] ) { parent :: select ( $ columns ) ; $ this -> columns = $ this -> qualifyColumns ( $ this -> columns ) ; return $ this ; }
175	public static function remove ( & $ array , $ key , $ default = null ) { if ( is_array ( $ array ) && ( isset ( $ array [ $ key ] ) || array_key_exists ( $ key , $ array ) ) ) { $ value = $ array [ $ key ] ; unset ( $ array [ $ key ] ) ; return $ value ; } return $ default ; }
11000	public function selectLocaleFromAcceptHeader ( Accept $ header ) { $ my_locales = [ ] ; foreach ( $ this -> locales as $ supported_locale ) { $ list = $ supported_locale -> getFallbackList ( ) ; foreach ( $ list as $ locale ) $ my_locales [ $ locale -> getLocale ( ) ] = $ supported_locale -> getLocale ( ) ; } $ best = $ header -> getBestResponseType ( array_keys ( $ my_locales ) ) ; return empty ( $ best ) ? null : ( $ my_locales [ $ best ] ?? null ) ; }
2823	public function deleteExpiredRequests ( ) { $ helper = Mage :: helper ( 'sheep_debug' ) ; if ( ! $ helper -> isEnabled ( ) ) { return 'skipped: module is disabled.' ; } if ( $ helper -> getPersistLifetime ( ) == 0 ) { return 'skipped: lifetime is set to 0' ; } $ expirationDate = $ this -> getExpirationDate ( date ( self :: DATE_FORMAT ) ) ; $ table = $ this -> getRequestsTable ( ) ; $ deleteSql = "DELETE FROM {$table} WHERE date <= '{$expirationDate}'" ; $ connection = Mage :: getSingleton ( 'core/resource' ) -> getConnection ( 'core_write' ) ; $ result = $ connection -> query ( $ deleteSql ) ; return "{$result->rowCount()} requests deleted" ; }
1449	protected function relationshipRules ( $ record , string $ field ) : array { return collect ( $ this -> rules ( $ record ) ) -> filter ( function ( $ v , $ key ) use ( $ field ) { return Str :: startsWith ( $ key , $ field ) ; } ) -> all ( ) ; }
5448	public function acceptStartToken ( $ token , $ event ) { if ( $ event == LEXER_ENTER ) { $ this -> tag = strtolower ( substr ( $ token , 1 ) ) ; return true ; } if ( $ event == LEXER_EXIT ) { $ success = $ this -> listener -> startElement ( $ this -> tag , $ this -> attributes ) ; $ this -> tag = '' ; $ this -> attributes = array ( ) ; return $ success ; } if ( $ token !== '=' ) { $ this -> current_attribute = strtolower ( html_entity_decode ( $ token , ENT_QUOTES ) ) ; $ this -> attributes [ $ this -> current_attribute ] = '' ; } return true ; }
1741	public function checkFilename ( $ varValue , Contao \ DataContainer $ dc ) { $ varValue = str_replace ( '"' , '' , $ varValue ) ; if ( strpos ( $ varValue , '/' ) !== false || preg_match ( '/\.$/' , $ varValue ) ) { throw new Exception ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'invalidName' ] ) ; } if ( $ dc -> activeRecord && $ varValue != '' ) { $ intMaxlength = $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'fields' ] [ $ dc -> field ] [ 'eval' ] [ 'maxlength' ] ; if ( $ dc -> activeRecord -> type == 'file' ) { $ intMaxlength -= ( \ strlen ( $ dc -> activeRecord -> extension ) + 1 ) ; } if ( $ intMaxlength && Patchwork \ Utf8 :: strlen ( $ varValue ) > $ intMaxlength ) { throw new Exception ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'maxlength' ] , $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'fields' ] [ $ dc -> field ] [ 'label' ] [ 0 ] , $ intMaxlength ) ) ; } } return $ varValue ; }
10363	public function __isset ( $ childName ) { foreach ( $ this -> nodes as $ node ) { if ( isset ( $ node -> $ childName ) ) { return true ; } } return false ; }
3225	function createFolder ( $ path ) { Path :: checkArgNonRoot ( "path" , $ path ) ; $ response = $ this -> doPost ( $ this -> apiHost , "1/fileops/create_folder" , array ( "root" => "auto" , "path" => $ path , ) ) ; if ( $ response -> statusCode === 403 ) return null ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; return RequestUtil :: parseResponseJson ( $ response -> body ) ; }
7752	protected function completeMetadata ( ClassMetadata $ class ) { $ className = $ class -> getName ( ) ; if ( null === $ class -> getIri ( ) ) { $ class -> setIri ( $ this -> namingStrategy -> classIriFragment ( $ className ) ) ; } if ( null === $ class -> getExposeAs ( ) ) { $ class -> setExposeAs ( $ this -> namingStrategy -> classShortName ( $ className ) ) ; } if ( null === $ class -> getTitle ( ) ) { $ class -> setTitle ( $ this -> namingStrategy -> classShortName ( $ className ) ) ; } foreach ( $ class -> getProperties ( ) as $ property ) { $ propertyName = $ property -> getName ( ) ; if ( null === $ property -> getIri ( ) ) { $ property -> setIri ( $ this -> namingStrategy -> propertyIriFragment ( $ className , $ propertyName ) ) ; } if ( null === $ property -> getExposeAs ( ) ) { $ property -> setExposeAs ( $ this -> namingStrategy -> propertyShortName ( $ className , $ propertyName ) ) ; } if ( null === $ property -> getTitle ( ) ) { $ property -> setTitle ( $ this -> namingStrategy -> propertyShortName ( $ className , $ propertyName ) ) ; } } }
6271	protected function throwException ( $ msg ) { if ( $ this -> handle ) { fclose ( $ this -> handle ) ; unlink ( $ this -> tmpFileName ) ; } throw new Exception ( $ msg ) ; }
9388	public function prefix ( $ prefix = '' , $ namespace = '' ) { $ namespace === '' && $ namespace = ( string ) $ this -> namespace ; $ prefix && $ prefix [ 0 ] !== '/' && $ prefix = '/' . $ prefix ; $ namespace = str_replace ( '\\\\' , '\\' , $ namespace . '\\' ) ; $ this -> prefix = ( string ) $ prefix ; $ this -> namespace = ltrim ( $ namespace , '\\' ) ; return $ this ; }
10177	public function cloneCellCollection ( Worksheet $ parent ) { $ this -> storeCurrentCell ( ) ; $ newCollection = clone $ this ; $ newCollection -> parent = $ parent ; if ( ( $ newCollection -> currentCell !== null ) && ( is_object ( $ newCollection -> currentCell ) ) ) { $ newCollection -> currentCell -> attach ( $ this ) ; } $ oldKeys = $ newCollection -> getAllCacheKeys ( ) ; $ oldValues = $ newCollection -> cache -> getMultiple ( $ oldKeys ) ; $ newValues = [ ] ; $ oldCachePrefix = $ newCollection -> cachePrefix ; $ newCollection -> cachePrefix = $ newCollection -> getUniqueID ( ) ; foreach ( $ oldValues as $ oldKey => $ value ) { $ newValues [ str_replace ( $ oldCachePrefix , $ newCollection -> cachePrefix , $ oldKey ) ] = clone $ value ; } $ stored = $ newCollection -> cache -> setMultiple ( $ newValues ) ; if ( ! $ stored ) { $ newCollection -> __destruct ( ) ; throw new PhpSpreadsheetException ( 'Failed to copy cells in cache' ) ; } return $ newCollection ; }
6307	public function success ( $ message , $ title = null , $ options = [ ] ) { return $ this -> add ( 'success' , $ message , $ title , $ options ) ; }
4072	private function scanFiles ( $ extension ) { $ files = [ ] ; foreach ( Finder :: create ( ) -> in ( $ this -> uploadPath ) -> name ( '*.' . $ extension ) -> getIterator ( ) as $ item ) { $ files [ ] = 'files/' . Path :: normalize ( $ item -> getRelativePathname ( ) ) ; } return $ files ; }
11475	public function setObjectType ( $ type ) { if ( ! is_object ( $ type ) ) { if ( Yii :: $ app -> collectors [ 'types' ] -> has ( $ type ) ) { $ type = Yii :: $ app -> collectors [ 'types' ] -> getOne ( $ type ) -> object ; } else { $ type = null ; } } $ this -> _objectType = $ type ; }
3117	public function getCatValue ( $ testSessionId , $ assessmentSectionId , $ key ) { $ extendedState = $ this -> getExtendedState ( $ testSessionId ) ; return $ extendedState -> getCatValue ( $ assessmentSectionId , $ key ) ; }
11184	protected function generateActions ( ) { $ parser = new Parser ( ) ; $ parser -> setPath ( $ this -> getApplicationPath ( ) ) ; $ parser -> setNameSpace ( $ this -> getApplicationNameSpace ( ) ) ; $ list = $ parser -> run ( ) ; return $ list ; }
11097	public static function secondsBetweenDates ( $ start , $ end , $ absolute = true , $ timezone = 'Europe/Prague' ) { $ timezoneObj = new \ DateTimeZone ( $ timezone ) ; $ date = new DateTime ( $ end , $ timezoneObj ) ; $ diff = $ date -> diff ( new DateTime ( $ start , $ timezoneObj ) , $ absolute ) ; return ( $ diff -> invert ? - 1 : 1 ) * ( ( $ diff -> days * 86400 ) + ( $ diff -> h * 3600 ) + ( $ diff -> i * 60 ) + $ diff -> s ) ; }
9957	public function protectCellsByColumnAndRow ( $ columnIndex1 , $ row1 , $ columnIndex2 , $ row2 , $ password , $ alreadyHashed = false ) { $ cellRange = Coordinate :: stringFromColumnIndex ( $ columnIndex1 ) . $ row1 . ':' . Coordinate :: stringFromColumnIndex ( $ columnIndex2 ) . $ row2 ; return $ this -> protectCells ( $ cellRange , $ password , $ alreadyHashed ) ; }
12250	public function getAttribute ( $ strName , $ varDefault = false ) { if ( isset ( $ this -> attributes ( ) -> $ strName ) && ( ( ( string ) $ this -> attributes ( ) -> $ strName ) !== '' ) ) { return ( string ) $ this -> attributes ( ) -> $ strName ; } else { return $ varDefault ; } }
1524	protected function doRead ( StoreInterface $ store , FetchResource $ request ) { $ record = $ request -> getRecord ( ) ; if ( $ result = $ this -> invoke ( 'reading' , $ record , $ request ) ) { return $ result ; } $ record = $ store -> readRecord ( $ record , $ request -> getParameters ( ) ) ; if ( $ result = $ this -> invoke ( 'didRead' , $ record , $ request ) ) { return $ result ; } return $ record ; }
6974	private function buildAssociationValue ( ClassMetadata $ metadata , $ propertyPath , $ value ) { $ childMetadata = $ this -> manager -> getClassMetadata ( $ metadata -> getAssociationTargetClass ( $ propertyPath ) ) ; if ( $ metadata -> isSingleValuedAssociation ( $ propertyPath ) ) { if ( is_string ( $ value ) && '#' === substr ( $ value , 0 , 1 ) ) { return $ this -> getReference ( substr ( $ value , 1 ) ) ; } elseif ( is_array ( $ value ) ) { return $ this -> buildEntity ( $ childMetadata , $ value ) ; } throw new \ Exception ( "Unexpected value for single association '$propertyPath'." ) ; } elseif ( $ metadata -> isCollectionValuedAssociation ( $ propertyPath ) ) { if ( ! is_array ( $ value ) ) { throw new \ Exception ( 'Expected array.' ) ; } $ builtValue = [ ] ; foreach ( $ value as $ childData ) { if ( is_string ( $ childData ) && '#' === substr ( $ childData , 0 , 1 ) ) { array_push ( $ builtValue , $ this -> getReference ( substr ( $ childData , 1 ) ) ) ; } elseif ( is_array ( $ value ) ) { array_push ( $ builtValue , $ this -> buildEntity ( $ childMetadata , $ childData ) ) ; } else { throw new \ Exception ( "Unexpected value for association '$propertyPath'." ) ; } } return $ builtValue ; } throw new \ Exception ( "Unexpected association path '$propertyPath'." ) ; }
3272	public function setConfig ( Config $ config ) { $ this -> config = $ config ; $ this -> getDatabase ( ) -> setConfig ( $ config ) ; }
11863	public function setHandledDataItem ( $ value ) { if ( isset ( $ this -> _pairedDataItem ) ) { $ this -> pairedDataItem -> handledDataItem = $ value ; } if ( ! $ this -> _handledDataItem && $ value ) { $ this -> dataSource -> reduceRemaining ( $ this ) ; } $ this -> clean ( ) ; return $ this -> _handledDataItem = $ value ; }
565	public function getScriptFile ( ) { if ( $ this -> _scriptFile === null ) { if ( isset ( $ _SERVER [ 'SCRIPT_FILENAME' ] ) ) { $ this -> setScriptFile ( $ _SERVER [ 'SCRIPT_FILENAME' ] ) ; } else { throw new InvalidConfigException ( 'Unable to determine the entry script file path.' ) ; } } return $ this -> _scriptFile ; }
11598	private static function _getCacheObject ( ) { if ( self :: $ _sTypeOfCache === 'file' ) { if ( ! isset ( self :: $ _aCache [ 'file' ] ) ) { self :: $ _aCache [ 'file' ] = new CacheFile ; } return self :: $ _aCache [ 'file' ] ; } else if ( self :: $ _sTypeOfCache === 'memcache' ) { if ( ! isset ( self :: $ _aCache [ 'memcache' ] ) ) { $ oDbConf = Config :: get ( 'Memcache' ) -> configuration ; if ( isset ( $ oDbConf -> port ) ) { $ sPort = $ oDbConf -> port ; } else { $ sPort = null ; } if ( isset ( $ oDbConf -> timeout ) ) { $ iTimeout = $ oDbConf -> timeout ; } else { $ iTimeout = null ; } self :: $ _aCache [ 'memcache' ] = new CacheMemcache ( $ oDbConf -> host , $ sPort , $ iTimeout ) ; } return self :: $ _aCache [ 'memcache' ] ; } else if ( self :: $ _sTypeOfCache === 'apc' ) { if ( ! isset ( self :: $ _aCache [ 'apc' ] ) ) { self :: $ _aCache [ 'apc' ] = new Apc ; } return self :: $ _aCache [ 'apc' ] ; } else if ( self :: $ _sTypeOfCache === 'redis' ) { if ( ! isset ( self :: $ _aCache [ 'redis' ] ) ) { $ oDbConf = Config :: get ( 'Redis' ) -> configuration ; self :: $ _aCache [ 'memcache' ] = new Redis ( $ oDbConf ) ; } return self :: $ _aCache [ 'redis' ] ; } else if ( self :: $ _sTypeOfCache === 'mock' ) { if ( ! isset ( self :: $ _aCache [ 'mock' ] ) ) { self :: $ _aCache [ 'mock' ] = new Mock ; } return self :: $ _aCache [ 'mock' ] ; } }
7045	private function getColumnNamesFromTable ( $ tableName , $ typeFilter = null ) { if ( ! $ this -> connection -> getSchemaManager ( ) -> tablesExist ( [ $ tableName ] ) ) { return [ ] ; } $ result = [ ] ; foreach ( $ this -> connection -> getSchemaManager ( ) -> listTableColumns ( $ tableName ) as $ column ) { if ( ( $ typeFilter === null ) || \ in_array ( $ column -> getType ( ) -> getName ( ) , $ typeFilter , true ) ) { $ result [ $ column -> getName ( ) ] = $ column -> getName ( ) ; } } if ( ! empty ( $ result ) ) { \ asort ( $ result ) ; return $ result ; } return $ result ; }
1516	public function readRelatedResource ( StoreInterface $ store , FetchRelated $ request ) { $ record = $ request -> getRecord ( ) ; $ result = $ this -> beforeReadingRelationship ( $ record , $ request ) ; if ( $ this -> isResponse ( $ result ) ) { return $ result ; } $ related = $ store -> queryRelated ( $ record , $ request -> getRelationshipName ( ) , $ request -> getParameters ( ) ) ; $ records = ( $ related instanceof PageInterface ) ? $ related -> getData ( ) : $ related ; $ result = $ this -> afterReadingRelationship ( $ record , $ records , $ request ) ; if ( $ this -> isInvokedResult ( $ result ) ) { return $ result ; } return $ this -> reply ( ) -> content ( $ related ) ; }
12133	public function createService ( ServiceLocatorInterface $ serviceLocator ) { $ options = $ serviceLocator -> get ( 'HtSettingsModule\Options\ModuleOptions' ) ; $ settingsService = new SettingsService ( $ options , $ serviceLocator -> get ( 'HtSettingsModule_SettingsMapper' ) , $ serviceLocator -> get ( 'HtSettingsModule\Service\NamespaceHydratorProvider' ) ) ; if ( $ options -> getCacheOptions ( ) -> isEnabled ( ) ) { $ settingsService -> setCacheManager ( $ serviceLocator -> get ( 'HtSettingsModule\Service\CacheManager' ) ) ; } return $ settingsService ; }
10670	protected static function _fromArray ( $ dom , $ node , & $ data , $ format ) { if ( $ data === null || $ data === '' || ! \ is_array ( $ data ) ) { return ; } foreach ( $ data as $ key => $ value ) { if ( \ is_string ( $ key ) ) { if ( ! \ is_array ( $ value ) ) { if ( \ is_bool ( $ value ) ) { $ value = ( int ) $ value ; } elseif ( $ value === null ) { $ value = '' ; } $ isNamespace = strpos ( $ key , 'xmlns:' ) ; if ( $ isNamespace !== false ) { $ node -> setAttributeNS ( 'http://www.w3.org/2000/xmlns/' , $ key , $ value ) ; continue ; } if ( $ key [ 0 ] !== '@' && $ format === 'tags' ) { $ child = null ; if ( ! is_numeric ( $ value ) ) { $ child = $ dom -> createElement ( $ key , '' ) ; $ child -> appendChild ( new \ DOMText ( $ value ) ) ; } else { $ child = $ dom -> createElement ( $ key , $ value ) ; } $ node -> appendChild ( $ child ) ; } else { if ( $ key [ 0 ] === '@' ) { $ key = substr ( $ key , 1 ) ; } $ attribute = $ dom -> createAttribute ( $ key ) ; $ attribute -> appendChild ( $ dom -> createTextNode ( $ value ) ) ; $ node -> appendChild ( $ attribute ) ; } } else { if ( $ key [ 0 ] === '@' ) { throw new \ RuntimeException ( Tools :: poorManTranslate ( 'fts-shared' , 'Invalid array' ) ) ; } if ( array_keys ( $ value ) === range ( 0 , \ count ( $ value ) - 1 ) ) { foreach ( $ value as $ item ) { $ data = compact ( 'dom' , 'node' , 'key' , 'format' ) ; $ data [ 'value' ] = $ item ; self :: _createChild ( $ data ) ; } } else { self :: _createChild ( compact ( 'dom' , 'node' , 'key' , 'value' , 'format' ) ) ; } } } else { throw new \ RuntimeException ( Tools :: poorManTranslate ( 'fts-shared' , 'Invalid array' ) ) ; } } }
5769	public function setSql ( ) { $ this -> args [ ] = $ this -> updateOnColumnValue ; $ lastArgNum = count ( $ this -> args ) ; $ this -> sql = "UPDATE $this->dbTable SET $this->setColumnsValues WHERE $this->updateOnColumnName = $" . $ lastArgNum ; }
8108	public function getReviewFrom ( ) { $ from = $ this -> owner -> getField ( 'ReviewFrom' ) ; if ( $ from ) { return $ from ; } return Config :: inst ( ) -> get ( Email :: class , 'admin_email' ) ; }
12653	public function getTextsWithBaseTexts ( $ language ) { $ texts = $ this -> getPageTexts ( $ language ) ; if ( $ language !== $ this -> baseLang ) { $ baseTexts = $ this -> getPageTexts ( $ this -> baseLang ) ; $ texts = array_map ( function ( $ text , $ baseText ) { return $ text + array ( "basecontent" => $ baseText [ 'content' ] ) ; } , $ texts , $ baseTexts ) ; } return $ texts ; }
11447	public function actionIndex ( $ option = null ) { $ fixtures = Yii :: createObject ( Fixtures :: className ( ) ) ; $ option = Question :: displayWithQuit ( 'Select operation' , [ 'Export' , 'Import' ] , $ option ) ; if ( $ option == 'e' ) { $ allTables = $ fixtures -> tableNameList ( ) ; if ( ! empty ( $ allTables ) ) { $ answer = Select :: display ( 'Select tables for export' , $ allTables , 1 ) ; $ tables = $ fixtures -> export ( $ answer ) ; Output :: items ( $ tables , 'Exported tables' ) ; } else { Output :: block ( "not tables for export!" ) ; } } elseif ( $ option == 'i' ) { $ allTables = $ fixtures -> fixtureNameList ( ) ; if ( ! empty ( $ allTables ) ) { $ answer = Select :: display ( 'Select tables for import' , $ allTables , 1 ) ; $ tables = $ fixtures -> import ( $ answer ) ; Output :: items ( $ tables , 'Imported tables' ) ; } else { Output :: block ( "not tables for import!" ) ; } } }
1035	private function completeLeafValue ( LeafType $ returnType , & $ result ) { try { return $ returnType -> serialize ( $ result ) ; } catch ( Exception $ error ) { throw new InvariantViolation ( 'Expected a value of type "' . Utils :: printSafe ( $ returnType ) . '" but received: ' . Utils :: printSafe ( $ result ) , 0 , $ error ) ; } catch ( Throwable $ error ) { throw new InvariantViolation ( 'Expected a value of type "' . Utils :: printSafe ( $ returnType ) . '" but received: ' . Utils :: printSafe ( $ result ) , 0 , $ error ) ; } }
12859	public function addRoute ( string $ verb , string $ path , array $ callback ) : Router { $ this -> routeCollector -> addRoute ( $ verb , $ path , $ callback ) ; return $ this ; }
9902	private static function cellAddressInDeleteRange ( $ cellAddress , $ beforeRow , $ pNumRows , $ beforeColumnIndex , $ pNumCols ) { list ( $ cellColumn , $ cellRow ) = Coordinate :: coordinateFromString ( $ cellAddress ) ; $ cellColumnIndex = Coordinate :: columnIndexFromString ( $ cellColumn ) ; if ( $ pNumRows < 0 && ( $ cellRow >= ( $ beforeRow + $ pNumRows ) ) && ( $ cellRow < $ beforeRow ) ) { return true ; } elseif ( $ pNumCols < 0 && ( $ cellColumnIndex >= ( $ beforeColumnIndex + $ pNumCols ) ) && ( $ cellColumnIndex < $ beforeColumnIndex ) ) { return true ; } return false ; }
10027	function getContactByEmail ( $ email , $ standard_fields = array ( ) , $ custom_fields = array ( ) ) { $ queryParameters = array ( 'standard_field' => $ standard_fields ) ; $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , 'custom_field' , $ custom_fields ) ; return $ this -> get ( 'contacts/email/' . utf8_encode ( $ email ) , $ queryParameters ) ; }
41	public static function checkCertificateHost ( $ certificate , $ hostname , & $ cn = null ) { $ names = self :: getCertificateNames ( $ certificate ) ; if ( empty ( $ names ) ) { return false ; } $ combinedNames = array_merge ( $ names [ 'san' ] , array ( $ names [ 'cn' ] ) ) ; $ hostname = strtolower ( $ hostname ) ; foreach ( $ combinedNames as $ certName ) { $ matcher = self :: certNameMatcher ( $ certName ) ; if ( $ matcher && $ matcher ( $ hostname ) ) { $ cn = $ names [ 'cn' ] ; return true ; } } return false ; }
4100	public function setType ( $ type ) { if ( is_array ( $ type ) ) $ type = implode ( "," , array_filter ( $ type ) ) ; $ this -> type = $ type ; $ this -> transport -> setType ( $ type ) ; return $ this ; }
10342	protected function isValidDate ( $ year , $ month , $ day ) { if ( $ month <= 0 || $ month > 12 || $ day <= 0 || $ day > 31 ) { return false ; } if ( ( $ month == 4 || $ month == 6 || $ month == 9 || $ month == 11 ) && ( $ day == 31 ) ) { return false ; } if ( $ month == 2 ) { if ( $ day > 29 ) { return false ; } $ leap = date ( 'L' , strtotime ( $ year . '-01-01' ) ) ; if ( $ leap === '0' && $ day > 28 ) { return false ; } } return true ; }
3183	private function durationToMs ( $ duration ) { if ( ! is_null ( $ duration ) && $ duration instanceof QtiDuration ) { return TestRunnerUtils :: getDurationWithMicroseconds ( $ duration ) ; } return false ; }
10310	function getUniqueOpensCount ( $ fromDate = null , $ toDate = null , $ mailingIds = null , $ contactIds = null , $ contactEmails = null , $ contactExternalIds = null , $ excludeAnonymousOpens = false ) { $ params = $ this -> createCountQueryParameters ( $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , $ mailingIds , null ) ; if ( isset ( $ excludeAnonymousOpens ) ) $ params [ 'exclude_anonymous_opens' ] = ( $ excludeAnonymousOpens == true ) ? "true" : "false" ; return $ this -> get ( 'reports/opens/unique/count' , $ params ) ; }
3348	private function __preparePagedParams ( $ data , $ reverse , $ resultArr ) { $ nextParamsArr = parse_url ( $ data -> next ) ; $ prevParamsArr = parse_url ( $ data -> previous ) ; $ nextParamsArr = array_replace ( array ( 'query' => null ) , $ nextParamsArr ) ; $ prevParamsArr = array_replace ( array ( 'query' => null ) , $ prevParamsArr ) ; parse_str ( parse_url ( ! $ reverse ? $ data -> next : $ data -> previous , PHP_URL_QUERY ) , $ params ) ; if ( $ reverse ) { $ resultArr = array_reverse ( $ resultArr ) ; } return array ( 'nextParams' => $ reverse ? $ prevParamsArr : $ nextParamsArr , 'prevParams' => ! $ reverse ? $ prevParamsArr : $ nextParamsArr , 'params' => $ params , 'data' => $ resultArr , ) ; }
11152	public function setParameters ( array $ request ) { foreach ( $ this -> getRequiredParameters ( ) as $ param ) { if ( isset ( $ request [ $ param ] ) ) { $ dynamicMethod = "set" . ucfirst ( $ param ) ; if ( method_exists ( $ this , $ dynamicMethod ) ) { $ this -> $ dynamicMethod ( $ request [ $ param ] ) ; } else { throw new ExtDirectException ( "Method for required parameter '{$param}' not implemented" ) ; } } else { throw new ExtDirectException ( "Required parameter '{$param}' is missing" ) ; } } }
5948	protected function waitForReadyRead ( $ time = 0 ) { if ( ! $ this -> isConnected ( ) || $ this -> config [ "blocking" ] ) { return ; } do { $ read = array ( $ this -> stream ) ; $ null = null ; if ( $ time ) { Signal :: getInstance ( ) -> emit ( strtolower ( $ this -> getAdapterType ( ) ) . "WaitTimeout" , $ time , $ this -> getAdapter ( ) ) ; } $ time = $ time + $ this -> config [ "timeout" ] ; } while ( @ stream_select ( $ read , $ null , $ null , $ this -> config [ "timeout" ] ) == 0 ) ; }
9975	private static function fillBuiltInFormatCodes ( ) { if ( self :: $ builtInFormats === null ) { self :: $ builtInFormats = [ ] ; self :: $ builtInFormats [ 0 ] = self :: FORMAT_GENERAL ; self :: $ builtInFormats [ 1 ] = '0' ; self :: $ builtInFormats [ 2 ] = '0.00' ; self :: $ builtInFormats [ 3 ] = '#,##0' ; self :: $ builtInFormats [ 4 ] = '#,##0.00' ; self :: $ builtInFormats [ 9 ] = '0%' ; self :: $ builtInFormats [ 10 ] = '0.00%' ; self :: $ builtInFormats [ 11 ] = '0.00E+00' ; self :: $ builtInFormats [ 12 ] = '# ?/?' ; self :: $ builtInFormats [ 13 ] = '# ??/??' ; self :: $ builtInFormats [ 14 ] = 'm/d/yyyy' ; self :: $ builtInFormats [ 15 ] = 'd-mmm-yy' ; self :: $ builtInFormats [ 16 ] = 'd-mmm' ; self :: $ builtInFormats [ 17 ] = 'mmm-yy' ; self :: $ builtInFormats [ 18 ] = 'h:mm AM/PM' ; self :: $ builtInFormats [ 19 ] = 'h:mm:ss AM/PM' ; self :: $ builtInFormats [ 20 ] = 'h:mm' ; self :: $ builtInFormats [ 21 ] = 'h:mm:ss' ; self :: $ builtInFormats [ 22 ] = 'm/d/yyyy h:mm' ; self :: $ builtInFormats [ 37 ] = '#,##0_);(#,##0)' ; self :: $ builtInFormats [ 38 ] = '#,##0_);[Red](#,##0)' ; self :: $ builtInFormats [ 39 ] = '#,##0.00_);(#,##0.00)' ; self :: $ builtInFormats [ 40 ] = '#,##0.00_);[Red](#,##0.00)' ; self :: $ builtInFormats [ 44 ] = '_("$"* #,##0.00_);_("$"* \(#,##0.00\);_("$"* "-"??_);_(@_)' ; self :: $ builtInFormats [ 45 ] = 'mm:ss' ; self :: $ builtInFormats [ 46 ] = '[h]:mm:ss' ; self :: $ builtInFormats [ 47 ] = 'mm:ss.0' ; self :: $ builtInFormats [ 48 ] = '##0.0E+0' ; self :: $ builtInFormats [ 49 ] = '@' ; self :: $ builtInFormats [ 27 ] = '[$-404]e/m/d' ; self :: $ builtInFormats [ 30 ] = 'm/d/yy' ; self :: $ builtInFormats [ 36 ] = '[$-404]e/m/d' ; self :: $ builtInFormats [ 50 ] = '[$-404]e/m/d' ; self :: $ builtInFormats [ 57 ] = '[$-404]e/m/d' ; self :: $ builtInFormats [ 59 ] = 't0' ; self :: $ builtInFormats [ 60 ] = 't0.00' ; self :: $ builtInFormats [ 61 ] = 't#,##0' ; self :: $ builtInFormats [ 62 ] = 't#,##0.00' ; self :: $ builtInFormats [ 67 ] = 't0%' ; self :: $ builtInFormats [ 68 ] = 't0.00%' ; self :: $ builtInFormats [ 69 ] = 't# ?/?' ; self :: $ builtInFormats [ 70 ] = 't# ??/??' ; self :: $ flippedBuiltInFormats = array_flip ( self :: $ builtInFormats ) ; } }
12059	public function setTarget ( $ value ) { if ( in_array ( $ value , $ this -> possibleTargets ) ) { $ this -> _target = $ value ; } else { throw new Exception ( 'Unknown deletion target ' . $ value ) ; } }
9687	public function jsonSerialize ( ) { return array_map ( function ( $ value ) { if ( $ value instanceof JsonSerializable ) { return $ value -> jsonSerialize ( ) ; } elseif ( $ value instanceof JsonableInterface ) { return json_decode ( $ value -> toJson ( ) , true ) ; } elseif ( $ value instanceof ArrayableInterface ) { return $ value -> toArray ( ) ; } else { return $ value ; } } , $ this -> items ) ; }
5409	public function selectAsPairs ( $ url ) { $ pairs = array ( ) ; foreach ( $ this -> cookies as $ cookie ) { if ( $ this -> isMatch ( $ cookie , $ url -> getHost ( ) , $ url -> getPath ( ) , $ cookie -> getName ( ) ) ) { $ pairs [ ] = $ cookie -> getName ( ) . '=' . $ cookie -> getValue ( ) ; } } return $ pairs ; }
11370	public static function charAscii ( $ char ) { if ( self :: isAscii ( $ char ) ) { return $ char ; } $ char = htmlentities ( $ char ) ; return $ char ; }
1692	protected function shortenHexColor ( $ color ) { if ( $ color [ 0 ] == $ color [ 1 ] && $ color [ 2 ] == $ color [ 3 ] && $ color [ 4 ] == $ color [ 5 ] ) { return $ color [ 0 ] . $ color [ 2 ] . $ color [ 4 ] ; } return $ color ; }
1063	private function findConflictsWithinSelectionSet ( ValidationContext $ context , $ parentType , SelectionSetNode $ selectionSet ) { [ $ fieldMap , $ fragmentNames ] = $ this -> getFieldsAndFragmentNames ( $ context , $ parentType , $ selectionSet ) ; $ conflicts = [ ] ; $ this -> collectConflictsWithin ( $ context , $ conflicts , $ fieldMap ) ; $ fragmentNamesLength = count ( $ fragmentNames ) ; if ( $ fragmentNamesLength !== 0 ) { $ comparedFragments = [ ] ; for ( $ i = 0 ; $ i < $ fragmentNamesLength ; $ i ++ ) { $ this -> collectConflictsBetweenFieldsAndFragment ( $ context , $ conflicts , $ comparedFragments , false , $ fieldMap , $ fragmentNames [ $ i ] ) ; for ( $ j = $ i + 1 ; $ j < $ fragmentNamesLength ; $ j ++ ) { $ this -> collectConflictsBetweenFragments ( $ context , $ conflicts , false , $ fragmentNames [ $ i ] , $ fragmentNames [ $ j ] ) ; } } } return $ conflicts ; }
6555	public function stop ( $ reason ) { $ this -> log ( $ reason , LogLevel :: INFO ) ; $ this -> stopped = true ; }
7329	private function configurePaymentTermSubjectMapping ( LoadClassMetadataEventArgs $ eventArgs ) { $ metadata = $ eventArgs -> getClassMetadata ( ) ; $ class = $ metadata -> getName ( ) ; if ( ! is_subclass_of ( $ class , Payment \ PaymentTermSubjectInterface :: class ) ) { return ; } if ( in_array ( $ class , $ this -> paymentTermSubjectClassCache ) ) { return ; } if ( ! $ metadata -> hasAssociation ( 'paymentTerm' ) ) { $ metadata -> mapManyToOne ( [ 'fieldName' => 'paymentTerm' , 'targetEntity' => Payment \ PaymentTermInterface :: class , 'joinColumns' => [ [ 'name' => 'payment_term_id' , 'referencedColumnName' => 'id' , 'onDelete' => 'RESTRICT' , 'nullable' => true , ] , ] , ] ) ; } $ this -> paymentTermSubjectClassCache [ ] = $ class ; }
5824	public function setMethod ( $ method ) { $ method = strtolower ( $ method ) ; if ( ! array_key_exists ( $ method , $ this -> curl -> getAllowedMethods ( ) ) ) { throw new \ InvalidArgumentException ( "Method [$method] not a valid HTTP method." ) ; } $ this -> method = $ method ; return $ this ; }
12584	static function run_generate_extension_config ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { self :: setConfigDir ( $ cliopts ) ; $ overwrite = @ $ cliopts [ 'overwrite-existing' ] ; if ( count ( $ args ) == 0 ) { throw new pakeException ( "Missing extension name" ) ; } $ extname = $ args [ 0 ] ; $ configfile = self :: getOptionsDir ( ) . "/options-$extname.yaml" ; if ( file_exists ( $ configfile ) && ! $ overwrite ) { pake_echo ( "File $configfile already exists. Must overwrite it to continue" ) ; $ ok = pake_input ( "Do you want to overwrite it? [y/n]" , 'n' ) ; if ( $ ok != 'y' ) { return ; } } pake_mkdirs ( self :: getOptionsDir ( ) ) ; pake_copy ( self :: getResourceDir ( ) . '/options-sample.yaml' , $ configfile , array ( 'override' => true ) ) ; pake_echo ( "Created file $configfile, now go and edit it" ) ; }
8779	public function segment ( $ num = null ) { if ( is_null ( http ( ) -> server ( 'REQUEST_URI' ) ) || is_null ( http ( ) -> server ( 'SCRIPT_NAME' ) ) ) { return null ; } if ( ! is_null ( $ num ) ) { $ uri = $ this -> replace ( str_replace ( $ this -> base , '' , http ( ) -> server ( 'REQUEST_URI' ) ) ) ; $ uriA = explode ( '/' , $ uri ) ; return ( isset ( $ uriA [ $ num ] ) ? reset ( explode ( '?' , $ uriA [ $ num ] ) ) : null ) ; } return null ; }
9979	public function writeComments ( \ PhpOffice \ PhpSpreadsheet \ Worksheet \ Worksheet $ pWorksheet ) { $ objWriter = null ; if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' , 'yes' ) ; $ comments = $ pWorksheet -> getComments ( ) ; $ authors = [ ] ; $ authorId = 0 ; foreach ( $ comments as $ comment ) { if ( ! isset ( $ authors [ $ comment -> getAuthor ( ) ] ) ) { $ authors [ $ comment -> getAuthor ( ) ] = $ authorId ++ ; } } $ objWriter -> startElement ( 'comments' ) ; $ objWriter -> writeAttribute ( 'xmlns' , 'http://schemas.openxmlformats.org/spreadsheetml/2006/main' ) ; $ objWriter -> startElement ( 'authors' ) ; foreach ( $ authors as $ author => $ index ) { $ objWriter -> writeElement ( 'author' , $ author ) ; } $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'commentList' ) ; foreach ( $ comments as $ key => $ value ) { $ this -> writeComment ( $ objWriter , $ key , $ value , $ authors ) ; } $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
11763	public function replace ( $ needle , $ replacement ) : Pipeline { $ stages = [ ] ; $ found = false ; foreach ( $ this -> stages as $ stage ) { if ( $ this -> matches ( $ stage , $ needle ) ) { $ stages [ ] = $ replacement ; $ found = true ; continue ; } $ stages [ ] = $ stage ; } if ( $ found ) { $ pipeline = clone $ this ; $ pipeline -> stages = $ stages ; return $ pipeline ; } unset ( $ stages ) ; return $ this ; }
11205	public function merge ( $ data , $ key = false , $ dataKey = false ) { if ( $ data != false && ( is_array ( $ data ) || is_object ( $ data ) ) ) { foreach ( $ data as $ item ) { $ this -> add ( $ item , $ key , $ dataKey , true ) ; } } else { $ this -> add ( $ data , $ key , $ dataKey ) ; } return $ this ; }
6835	protected function preventForbiddenChange ( Model \ InvoiceLineInterface $ line ) { if ( $ this -> persistenceHelper -> isChanged ( $ line , 'type' ) ) { list ( $ old , $ new ) = $ this -> persistenceHelper -> getChangeSet ( $ line , 'type' ) ; if ( $ old !== $ new ) { throw new Exception \ RuntimeException ( "Changing the invoice line's type is not supported." ) ; } } }
3767	private function getOptions ( $ attribute , $ onlyUsed ) { $ options = [ ] ; foreach ( $ attribute -> getFilterOptions ( null , $ onlyUsed ) as $ key => $ value ) { $ value = trim ( strip_tags ( $ value ) ) ; if ( ! empty ( $ value ) ) { $ options [ $ key ] = $ value ; } } return $ options ; }
1397	public function deleted ( $ resource = null , array $ links = [ ] , $ meta = null , array $ headers = [ ] ) { return $ this -> getResourceResponse ( $ resource , $ links , $ meta , $ headers ) ; }
8300	public function handleEvent ( $ eventName , array $ params ) { parent :: handleEvent ( $ eventName , $ params ) ; if ( $ this -> isEnabled ( ) ) { $ this -> picoAuthPlugin -> handleEvent ( $ eventName , $ params ) ; } }
5492	protected function renderArguments ( $ args ) { $ descriptions = array ( ) ; if ( is_array ( $ args ) ) { foreach ( $ args as $ arg ) { $ dumper = new SimpleDumper ( ) ; $ descriptions [ ] = $ dumper -> describeValue ( $ arg ) ; } } return implode ( ', ' , $ descriptions ) ; }
9848	public function createSignedRequest ( string $ method , string $ uri , string $ body , SigningSecretKey $ key , array $ headers = [ ] ) : RequestInterface { $ signature = \ ParagonIE_Sodium_Compat :: crypto_sign_detached ( $ body , $ key -> getString ( true ) ) ; if ( isset ( $ headers [ Sapient :: HEADER_SIGNATURE_NAME ] ) ) { $ headers [ Sapient :: HEADER_SIGNATURE_NAME ] [ ] = Base64UrlSafe :: encode ( $ signature ) ; } else { $ headers [ Sapient :: HEADER_SIGNATURE_NAME ] = Base64UrlSafe :: encode ( $ signature ) ; } return new Request ( $ method , Uri :: createFromString ( $ uri ) , new Headers ( $ headers ) , [ ] , [ ] , $ this -> stringToStream ( $ body ) , [ ] ) ; }
2366	public static function censor ( $ strString , $ varWords , $ strReplace = '' ) { foreach ( ( array ) $ varWords as $ strWord ) { $ strString = preg_replace ( '/\b(' . str_replace ( '\*' , '\w*?' , preg_quote ( $ strWord , '/' ) ) . ')\b/i' , $ strReplace , $ strString ) ; } return $ strString ; }
7367	protected function checkInvoiceIntegrity ( SaleItemInterface $ item , SaleItem $ constraint ) { $ sale = $ item -> getSale ( ) ; if ( ! $ sale instanceof Invoice \ InvoiceSubjectInterface ) { return ; } if ( empty ( $ sale -> getInvoices ( ) -> toArray ( ) ) ) { return ; } $ min = $ this -> invoiceCalculator -> calculateInvoicedQuantity ( $ item ) ; $ qty = $ item -> getTotalQuantity ( ) ; if ( 1 === bccomp ( $ min , 0 , 3 ) && 1 === bccomp ( $ min , $ qty , 3 ) ) { $ this -> context -> buildViolation ( $ constraint -> quantity_is_lower_than_invoiced , [ '%min%' => $ min , ] ) -> atPath ( 'quantity' ) -> addViolation ( ) ; throw new ValidationFailedException ( ) ; } }
9379	protected function parse ( $ httpMethod , $ uri , $ route ) { $ matched = preg_match ( $ route [ 4 ] , $ uri , $ parameters ) ; if ( $ matched && ( $ httpMethod == $ route [ 0 ] || $ httpMethod == 'OPTIONS' ) ) { $ this -> allowed ( $ route [ 0 ] ) ; array_shift ( $ parameters ) ; return array ( $ route [ 2 ] , $ parameters , $ route [ 3 ] , $ route [ 5 ] ) ; } return null ; }
12304	public function adminIndex ( ) { $ config = [ 'title' => trans ( 'HCLanguages::languages.page_title' ) , 'listURL' => route ( 'admin.api.languages' ) , 'newFormUrl' => route ( 'admin.api.form-manager' , [ 'languages-new' ] ) , 'editFormUrl' => route ( 'admin.api.form-manager' , [ 'languages-edit' ] ) , 'imagesUrl' => route ( 'resource.get' , [ '/' ] ) , 'headers' => $ this -> getAdminListHeader ( ) , ] ; $ config [ 'actions' ] [ ] = 'search' ; return hcview ( 'HCCoreUI::admin.content.list' , [ 'config' => $ config ] ) ; }
4867	public function fail ( JobInterface $ job , array $ options = [ ] ) { $ envelope = $ this -> createEnvelope ( $ job , $ options ) ; unset ( $ envelope [ 'created' ] ) ; unset ( $ envelope [ 'scheduled' ] ) ; $ envelope [ 'status' ] = self :: STATUS_FAILED ; $ this -> mongoCollection -> findOneAndUpdate ( [ '_id' => new \ MongoDB \ BSON \ ObjectId ( $ job -> getId ( ) ) ] , [ '$set' => $ envelope ] ) ; }
9731	public function canRead ( $ pFilename ) { try { $ this -> openFile ( $ pFilename ) ; } catch ( Exception $ e ) { return false ; } $ data = fread ( $ this -> fileHandle , 2048 ) ; $ delimiterCount = substr_count ( $ data , ';' ) ; $ hasDelimiter = $ delimiterCount > 0 ; $ lines = explode ( "\n" , $ data ) ; $ hasId = substr ( $ lines [ 0 ] , 0 , 4 ) === 'ID;P' ; fclose ( $ this -> fileHandle ) ; return $ hasDelimiter && $ hasId ; }
474	public function update ( $ table , $ columns , $ condition = '' , $ params = [ ] ) { $ time = $ this -> beginCommand ( "update $table" ) ; $ this -> db -> createCommand ( ) -> update ( $ table , $ columns , $ condition , $ params ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
9220	protected function requestAllPages ( $ forceRefresh = false ) { $ _page = $ this -> page ; $ _key = $ this -> key ; $ nextPageNumber = false ; if ( isset ( $ this -> pagination [ CanvasPageLink :: NEXT ] ) ) { $ nextPageNumber = $ this -> pagination [ CanvasPageLink :: NEXT ] -> getPageNumber ( ) ; } while ( $ nextPageNumber !== false ) { $ this -> requestPageNumber ( $ nextPageNumber , $ forceRefresh ) ; if ( isset ( $ this -> paginationPerPage [ $ nextPageNumber ] [ CanvasPageLink :: NEXT ] ) ) { $ nextPageNumber = $ this -> paginationPerPage [ $ nextPageNumber ] [ CanvasPageLink :: NEXT ] -> getPageNumber ( ) ; } else { $ nextPageNumber = false ; } } $ this -> page = $ _page ; $ this -> key = $ _key ; }
8883	public function getQuote ( $ credentials , $ options ) { $ this -> loadCredentials ( $ credentials ) ; $ options = $ this -> checkDefaults ( $ options ) ; $ residential_flag = ( $ this -> commercial_rates ) ? '' : '<ResidentialAddressIndicator/>' ; $ negotiated_flag = ( $ this -> negotiated_rates ) ? '<RateInformation><NegotiatedRatesIndicator/></RateInformation>' : '' ; $ this -> xml = '<?xml version="1.0"?> <AccessRequest xml:lang="en-US"> <AccessLicenseNumber>' . $ this -> access_key . '</AccessLicenseNumber> <UserId>' . $ this -> username . '</UserId> <Password>' . $ this -> password . '</Password> </AccessRequest> <?xml version="1.0"?> <RatingServiceSelectionRequest xml:lang="en-US"> <Request> <TransactionReference> <CustomerContext>Rate Request</CustomerContext> <XpciVersion>1.0001</XpciVersion> </TransactionReference> <RequestAction>Rate</RequestAction> <RequestOption>' . $ options [ 'request_option' ] . '</RequestOption> </Request> <PickupType> <Code>01</Code> </PickupType> <Shipment> <Shipper> <ShipperNumber>' . $ this -> account_number . '</ShipperNumber> <Address> <PostalCode>' . $ options [ 'from_zip' ] . '</PostalCode> <StateProvinceCode>' . $ options [ 'from_state' ] . '</StateProvinceCode> <CountryCode>' . $ options [ 'from_country' ] . '</CountryCode> </Address> </Shipper> <ShipTo> <Address> <PostalCode>' . $ options [ 'to_zip' ] . '</PostalCode> <StateProvinceCode>' . $ options [ 'to_state' ] . '</StateProvinceCode> <CountryCode>' . $ options [ 'to_country' ] . '</CountryCode> ' . $ residential_flag . ' </Address> </ShipTo> <Service> <Code>' . $ options [ 'service_type' ] . '</Code> <Description>Package</Description> </Service> <ShipmentServiceOptions/> ' . $ this -> buildPackages ( $ options [ 'packages' ] , $ options [ 'weight' ] , $ options [ 'measurement' ] ) . $ negotiated_flag . ' </Shipment> </RatingServiceSelectionRequest>' ; return $ this -> send ( ) ; }
12419	static function run_php_pdepend_report ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { $ opts = self :: getOpts ( @ $ args [ 0 ] , @ $ args [ 1 ] , $ cliopts ) ; if ( ! SharedLock :: acquire ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ) throw new PakeException ( "Source code locked by another process" ) ; $ destdir = self :: getReportDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ; $ pdepend = self :: getTool ( 'pdepend' , $ opts , true ) ; pake_mkdirs ( $ destdir ) ; $ out = pake_sh ( $ pdepend . " --jdepend-chart=" . escapeshellarg ( self :: getReportDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] . '/jdependchart.svg' ) . " --overview-pyramid=" . escapeshellarg ( self :: getReportDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] . '/overview-pyramid.svg' ) . " --summary-xml=" . escapeshellarg ( self :: getReportDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] . '/summary.xml' ) . " " . escapeshellarg ( self :: getBuildDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ) ) ; SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; }
9868	private function writePrintOptions ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { $ objWriter -> startElement ( 'printOptions' ) ; $ objWriter -> writeAttribute ( 'gridLines' , ( $ pSheet -> getPrintGridlines ( ) ? 'true' : 'false' ) ) ; $ objWriter -> writeAttribute ( 'gridLinesSet' , 'true' ) ; if ( $ pSheet -> getPageSetup ( ) -> getHorizontalCentered ( ) ) { $ objWriter -> writeAttribute ( 'horizontalCentered' , 'true' ) ; } if ( $ pSheet -> getPageSetup ( ) -> getVerticalCentered ( ) ) { $ objWriter -> writeAttribute ( 'verticalCentered' , 'true' ) ; } $ objWriter -> endElement ( ) ; }
7331	private function configureStockSubjectMapping ( LoadClassMetadataEventArgs $ eventArgs ) { $ metadata = $ eventArgs -> getClassMetadata ( ) ; $ class = $ metadata -> getName ( ) ; if ( ! is_subclass_of ( $ class , Stock \ StockSubjectInterface :: class ) ) { return ; } if ( in_array ( $ class , $ this -> stockClassCache ) ) { return ; } $ this -> addMappings ( $ metadata , $ this -> getStockSubjectMappings ( ) ) ; $ this -> stockClassCache [ ] = $ class ; }
7861	public function draw ( $ workflow ) { $ this -> geometry -> setCore ( $ workflow ) ; $ this -> setPipesOfWorkflow ( $ workflow ) ; $ this -> drawCenteredChar ( static :: NOCK ) ; $ this -> drawPipesBeginning ( ) ; $ this -> drawCore ( ) ; $ this -> drawPipesEnd ( ) ; $ this -> drawCenteredChar ( static :: PILE ) ; return $ this -> drawing ; }
5329	final public function push ( string $ data ) { if ( $ this -> generator === null ) { throw new \ Error ( "The parser is no longer writable" ) ; } $ this -> buffer .= $ data ; $ end = false ; try { while ( $ this -> buffer !== "" ) { if ( \ is_int ( $ this -> delimiter ) ) { if ( \ strlen ( $ this -> buffer ) < $ this -> delimiter ) { break ; } $ send = \ substr ( $ this -> buffer , 0 , $ this -> delimiter ) ; $ this -> buffer = \ substr ( $ this -> buffer , $ this -> delimiter ) ; } elseif ( \ is_string ( $ this -> delimiter ) ) { if ( ( $ position = \ strpos ( $ this -> buffer , $ this -> delimiter ) ) === false ) { break ; } $ send = \ substr ( $ this -> buffer , 0 , $ position ) ; $ this -> buffer = \ substr ( $ this -> buffer , $ position + \ strlen ( $ this -> delimiter ) ) ; } else { $ send = $ this -> buffer ; $ this -> buffer = "" ; } $ this -> delimiter = $ this -> generator -> send ( $ send ) ; if ( ! $ this -> generator -> valid ( ) ) { $ end = true ; break ; } if ( $ this -> delimiter !== null && ( ! \ is_int ( $ this -> delimiter ) || $ this -> delimiter <= 0 ) && ( ! \ is_string ( $ this -> delimiter ) || ! \ strlen ( $ this -> delimiter ) ) ) { throw new InvalidDelimiterError ( $ this -> generator , \ sprintf ( "Invalid value yielded: Expected NULL, an int greater than 0, or a non-empty string; %s given" , \ is_object ( $ this -> delimiter ) ? \ sprintf ( "instance of %s" , \ get_class ( $ this -> delimiter ) ) : \ gettype ( $ this -> delimiter ) ) ) ; } } } catch ( \ Throwable $ exception ) { $ end = true ; throw $ exception ; } finally { if ( $ end ) { $ this -> generator = null ; } } }
1466	public static function doesRequestHaveBody ( $ request ) { if ( self :: hasHeader ( $ request , 'Transfer-Encoding' ) ) { return true ; } ; if ( 1 > self :: getHeader ( $ request , 'Content-Length' ) ) { return false ; } return true ; }
10604	public function setQueryParam ( $ name , $ value ) { if ( $ this -> checkQuery ( $ name ) ) { $ this -> editQuery ( $ name , $ value ) ; } else { $ this -> addQuery ( $ name , $ value ) ; } return $ this ; }
4440	public static function sigName ( int $ signal ) : string { $ signals = [ 'SIGHUP' , 'SIGINT' , 'SIGQUIT' , 'SIGILL' , 'SIGTRAP' , 'SIGABRT' , 'SIGIOT' , 'SIGBUS' , 'SIGFPE' , 'SIGKILL' , 'SIGUSR1' , 'SIGSEGV' , 'SIGUSR2' , 'SIGPIPE' , 'SIGALRM' , 'SIGTERM' , 'SIGSTKFLT' , 'SIGCLD' , 'SIGCHLD' , 'SIGCONT' , 'SIGSTOP' , 'SIGTSTP' , 'SIGTTIN' , 'SIGTTOU' , 'SIGURG' , 'SIGXCPU' , 'SIGXFSZ' , 'SIGVTALRM' , 'SIGPROF' , 'SIGWINCH' , 'SIGPOLL' , 'SIGIO' , 'SIGPWR' , 'SIGSYS' , 'SIGBABY' , ] ; foreach ( $ signals as $ name ) { if ( defined ( $ name ) && constant ( $ name ) === $ signal ) { return $ name ; } } return 'UNKNOWN' ; }
3782	public function modelToLabel ( ModelToLabelEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ model = $ event -> getModel ( ) ; $ type = $ model -> getProperty ( 'type' ) ; $ image = '<img src="' . $ this -> attributeFactory -> getIconForType ( $ type ) . '" />' ; $ metaModel = $ this -> getMetaModelByModelPid ( $ model ) ; $ attribute = $ this -> attributeFactory -> createAttribute ( $ model -> getPropertiesAsArray ( ) , $ metaModel ) ; if ( ! $ attribute ) { $ translator = $ event -> getEnvironment ( ) -> getTranslator ( ) ; $ event -> setLabel ( '<div class="field_heading cte_type"><strong>%s</strong> <em>[%s]</em></div> <div class="field_type block"> <strong>%s</strong><br /> </div>' ) -> setArgs ( array ( $ translator -> translate ( 'error_unknown_attribute.0' , 'tl_metamodel_attribute' ) , $ type , $ translator -> translate ( 'error_unknown_attribute.1' , 'tl_metamodel_attribute' , array ( $ type ) ) , ) ) ; return ; } $ colName = $ attribute -> getColName ( ) ; $ name = $ attribute -> getName ( ) ; $ arrDescription = StringUtil :: deserialize ( $ attribute -> get ( 'description' ) ) ; if ( is_array ( $ arrDescription ) ) { $ description = $ arrDescription [ $ attribute -> getMetaModel ( ) -> getActiveLanguage ( ) ] ; if ( ! $ description ) { $ description = $ arrDescription [ $ attribute -> getMetaModel ( ) -> getFallbackLanguage ( ) ] ; } } else { $ description = $ arrDescription ? : $ attribute -> getName ( ) ; } $ event -> setLabel ( '<div class="field_heading cte_type"><strong>%s</strong> <em>[%s]</em></div> <div class="field_type block"> %s<strong>%s</strong> - %s </div>' ) -> setArgs ( array ( $ colName , $ type , $ image , $ name , $ description ) ) ; }
7541	function setIndex ( $ index ) { if ( $ this -> parent ) { if ( $ index > $ this -> index ( ) ) { -- $ index ; } $ this -> delete ( ) ; $ this -> parent -> addChild ( $ this , $ index ) ; } }
3159	public function storeVariables ( QtiRunnerServiceContext $ context , $ itemUri , $ metaVariables , $ itemId = null ) { $ sessionId = $ context -> getTestSession ( ) -> getSessionId ( ) ; $ deliveryServerService = $ this -> getServiceManager ( ) -> get ( DeliveryServerService :: SERVICE_ID ) ; $ resultStore = $ deliveryServerService -> getResultStoreWrapper ( $ sessionId ) ; $ testUri = $ context -> getTestDefinitionUri ( ) ; if ( ! is_null ( $ itemUri ) ) { $ resultStore -> storeItemVariables ( $ testUri , $ itemUri , $ metaVariables , $ this -> getTransmissionId ( $ context , $ itemId ) ) ; } else { $ resultStore -> storeTestVariables ( $ testUri , $ metaVariables , $ sessionId ) ; } return true ; }
1648	public function calculateFinalBearing ( Coordinate $ point1 , Coordinate $ point2 ) : float { $ initialBearing = $ this -> calculateBearing ( $ point2 , $ point1 ) ; return fmod ( $ initialBearing + 180 , 360 ) ; }
3432	protected function normalizeSelect ( ) { if ( $ this -> fieldsMustBeSelected ( ) ) { $ this -> select = array_merge ( $ this -> standardFields , $ this -> select ) ; } if ( $ this -> propsMustBeSelected ( ) ) { $ this -> select [ ] = 'IBLOCK_ID' ; $ this -> select [ ] = 'UF_*' ; } $ this -> select [ ] = 'ID' ; return $ this -> clearSelectArray ( ) ; }
12191	protected function buildMessage ( ) { $ className = $ this -> getClassName ( ) ; $ methodName = $ this -> getMethodName ( ) ; $ functionName = $ this -> getFunctionName ( ) ; if ( $ className !== null && $ methodName !== null ) { $ callable = $ className . '::' . $ methodName ; ; } else { $ callable = $ functionName ; } $ this -> message = s ( 'Container could not resolve argument %s for %s.' , $ this -> getArgumentIndex ( ) , $ callable ) ; }
10005	public function setRibbonXMLData ( $ target , $ xmlData ) { if ( $ target !== null && $ xmlData !== null ) { $ this -> ribbonXMLData = [ 'target' => $ target , 'data' => $ xmlData ] ; } else { $ this -> ribbonXMLData = null ; } }
863	private function changeCodeHash ( $ codeHash ) { if ( null !== $ this -> codeHash ) { self :: clearCache ( $ this -> codeHash ) ; } $ this -> codeHash = $ codeHash ; self :: setCache ( $ this -> codeHash , $ this ) ; }
11903	public function getDescriptor ( ) { $ logModel = $ this -> getLogModel ( true ) ; if ( empty ( $ logModel ) || ! isset ( $ logModel -> dataInterface ) ) { return 'Unknown Data Interface' ; } return 'Interface: ' . $ logModel -> dataInterface -> name ; }
5555	public function getUrls ( ) { if ( is_integer ( $ this -> focus ) ) { return $ this -> frames [ $ this -> focus ] -> getUrls ( ) ; } $ urls = array ( ) ; foreach ( $ this -> frames as $ frame ) { $ urls = array_merge ( $ urls , $ frame -> getUrls ( ) ) ; } return array_values ( array_unique ( $ urls ) ) ; }
1247	public static function ini ( $ profile = null , $ filename = null ) { $ filename = $ filename ? : ( self :: getHomeDir ( ) . '/.ebay_sdk/credentials' ) ; $ profile = $ profile ? : ( getenv ( self :: ENV_PROFILE ) ? : 'default' ) ; return function ( ) use ( $ filename , $ profile ) { if ( ! is_readable ( $ filename ) ) { return new \ InvalidArgumentException ( "Cannot read credentials from $filename" ) ; } $ data = parse_ini_file ( $ filename , true ) ; if ( $ data === false ) { return new \ InvalidArgumentException ( "Invalid credentials file $filename" ) ; } if ( ! isset ( $ data [ $ profile ] ) ) { return new \ InvalidArgumentException ( "'$profile' not found in credentials file" ) ; } if ( ! isset ( $ data [ $ profile ] [ 'ebay_app_id' ] ) || ! isset ( $ data [ $ profile ] [ 'ebay_cert_id' ] ) || ! isset ( $ data [ $ profile ] [ 'ebay_dev_id' ] ) ) { return new \ InvalidArgumentException ( "No credentials present in INI profile '$profile' ($filename)" ) ; } return new Credentials ( $ data [ $ profile ] [ 'ebay_app_id' ] , $ data [ $ profile ] [ 'ebay_cert_id' ] , $ data [ $ profile ] [ 'ebay_dev_id' ] ) ; } ; }
5352	public function getSupportedNamespaces ( ) { if ( empty ( $ this -> data -> namespaces ) || ! is_array ( $ this -> data -> namespaces ) ) { return array ( ) ; } return $ this -> data -> namespaces ; }
4511	public function decoded ( JWTDecodedEvent $ event ) { $ payload = $ event -> getPayload ( ) ; $ payload = json_decode ( json_encode ( $ payload ) , true ) ; if ( ! $ this -> accessor -> isReadable ( $ payload , $ this -> property ) ) { $ event -> markAsInvalid ( ) ; } }
3032	public function getSessionState ( AssessmentTestSession $ session ) { $ deliveryExecution = $ this -> getDeliveryExecution ( $ session ) ; return $ deliveryExecution -> getState ( ) -> getUri ( ) ; }
1874	private function addComponents ( ContainerBuilder $ container ) : void { $ packages = $ container -> getDefinition ( 'assets.packages' ) ; $ context = new Reference ( 'contao.assets.assets_context' ) ; foreach ( Versions :: VERSIONS as $ name => $ version ) { if ( 0 !== strncmp ( 'contao-components/' , $ name , 18 ) ) { continue ; } $ serviceId = 'assets._package_' . $ name ; $ basePath = 'assets/' . substr ( $ name , 18 ) ; $ version = $ this -> createVersionStrategy ( $ container , $ version , $ name ) ; $ container -> setDefinition ( $ serviceId , $ this -> createPackageDefinition ( $ basePath , $ version , $ context ) ) ; $ packages -> addMethodCall ( 'addPackage' , [ $ name , new Reference ( $ serviceId ) ] ) ; } }
2242	public static function getContentElement ( $ intId , $ strColumn = 'main' ) { if ( \ is_object ( $ intId ) ) { $ objRow = $ intId ; } else { if ( ! \ strlen ( $ intId ) || $ intId < 1 ) { return '' ; } $ objRow = ContentModel :: findByPk ( $ intId ) ; if ( $ objRow === null ) { return '' ; } } if ( ! static :: isVisibleElement ( $ objRow ) ) { return '' ; } $ strClass = ContentElement :: findClass ( $ objRow -> type ) ; if ( ! class_exists ( $ strClass ) ) { static :: log ( 'Content element class "' . $ strClass . '" (content element "' . $ objRow -> type . '") does not exist' , __METHOD__ , TL_ERROR ) ; return '' ; } $ objRow -> typePrefix = 'ce_' ; $ objElement = new $ strClass ( $ objRow , $ strColumn ) ; $ strBuffer = $ objElement -> generate ( ) ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getContentElement' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getContentElement' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getContentElement' ] as $ callback ) { $ strBuffer = static :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ objRow , $ strBuffer , $ objElement ) ; } } if ( $ objElement -> protected && ! preg_match ( '/^\s*<!-- indexer::stop/' , $ strBuffer ) ) { $ strBuffer = "\n<!-- indexer::stop . $ strBuffer . "<!-- indexer::continue ; } return $ strBuffer ; }
5850	protected function buildForm ( array $ row ) { $ record = [ 'uid' => static :: virtualRecordId , 'pid' => 0 , ] ; $ record = array_merge ( $ record , $ row ) ; $ dataProviders = & $ GLOBALS [ 'TYPO3_CONF_VARS' ] [ 'SYS' ] [ 'formEngine' ] [ 'formDataGroup' ] [ 'tcaDatabaseRecord' ] ; $ dataProviders [ \ Causal \ ImageAutoresize \ Backend \ Form \ FormDataProvider \ VirtualDatabaseEditRow :: class ] = [ 'before' => [ \ TYPO3 \ CMS \ Backend \ Form \ FormDataProvider \ DatabaseEditRow :: class , ] ] ; \ Causal \ ImageAutoresize \ Backend \ Form \ FormDataProvider \ VirtualDatabaseEditRow :: initialize ( $ record ) ; $ formDataGroup = GeneralUtility :: makeInstance ( \ TYPO3 \ CMS \ Backend \ Form \ FormDataGroup \ TcaDatabaseRecord :: class ) ; $ formDataCompiler = GeneralUtility :: makeInstance ( \ TYPO3 \ CMS \ Backend \ Form \ FormDataCompiler :: class , $ formDataGroup ) ; $ nodeFactory = GeneralUtility :: makeInstance ( \ TYPO3 \ CMS \ Backend \ Form \ NodeFactory :: class ) ; $ formDataCompilerInput = [ 'tableName' => static :: virtualTable , 'vanillaUid' => $ record [ 'uid' ] , 'command' => 'edit' , 'returnUrl' => '' , ] ; $ this -> loadVirtualTca ( ) ; $ formData = $ formDataCompiler -> compile ( $ formDataCompilerInput ) ; $ formData [ 'renderType' ] = 'outerWrapContainer' ; $ formResult = $ nodeFactory -> create ( $ formData ) -> render ( ) ; $ html = preg_replace ( '/<h1>.*<\/h1>/' , '' , $ formResult [ 'html' ] ) ; $ startFooter = strrpos ( $ html , '<div class="help-block text-right">' ) ; $ endTag = '</div>' ; if ( $ startFooter !== false ) { $ endFooter = strpos ( $ html , $ endTag , $ startFooter ) ; $ html = substr ( $ html , 0 , $ startFooter ) . substr ( $ html , $ endFooter + strlen ( $ endTag ) ) ; } $ formResult [ 'html' ] = '' ; $ formResult [ 'doSaveFieldName' ] = 'doSave' ; $ this -> formResultCompiler -> mergeResult ( $ formResult ) ; $ formContent = ' <!-- EDITING FORM . $ html . ' <input type="hidden" name="returnUrl" value="' . htmlspecialchars ( $ this -> retUrl ) . '" /> <input type="hidden" name="closeDoc" value="0" /> <input type="hidden" name="doSave" value="0" /> <input type="hidden" name="_serialNumber" value="' . md5 ( microtime ( ) ) . '" /> <input type="hidden" name="_scrollPosition" value="" />' ; $ overriddenAjaxUrl = GeneralUtility :: quoteJSvalue ( BackendUtility :: getModuleUrl ( 'TxImageAutoresize::record_flex_container_add' ) ) ; $ formContent .= <<<HTML<script type="text/javascript"> TYPO3.settings.ajaxUrls['record_flex_container_add'] = $overriddenAjaxUrl;</script>HTML ; return $ formContent ; }
3542	public static function getExtensionOptions ( $ optionName ) { if ( isset ( Yii :: $ app -> params [ 'yii2-adldap-extension-Options' ] ) && is_array ( Yii :: $ app -> params [ 'yii2-adldap-extension-Options' ] ) && array_key_exists ( $ optionName , Yii :: $ app -> params [ 'yii2-adldap-extension-Options' ] ) ) { return Yii :: $ app -> params [ 'yii2-adldap-extension-Options' ] [ $ optionName ] ; } else if ( array_key_exists ( $ optionName , static :: EXTENSION_OPTIONS_DEFAULT ) ) { return static :: EXTENSION_OPTIONS_DEFAULT [ $ optionName ] ; } else { throw new \ yii \ base \ Exception ( 'Extension-Option ' . $ optionName . ' not found. Please define settings in the config/params.php of the yii2 framework as described on top of the UserDbLdap.php' ) ; } }
4546	public function setIncludeAssignedTasks ( ? bool $ includeAssignedTasks ) { $ this -> includeAssignedTasks = $ includeAssignedTasks ; $ this -> _includeAssignedTasks = null !== $ includeAssignedTasks ; return $ this ; }
486	public function addCommentOnTable ( $ table , $ comment ) { $ time = $ this -> beginCommand ( "add comment on table $table" ) ; $ this -> db -> createCommand ( ) -> addCommentOnTable ( $ table , $ comment ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
5959	public function clientGetByUid ( $ uid ) { foreach ( $ this -> clientList ( ) as $ client ) { if ( $ client [ "client_unique_identifier" ] == $ uid ) { return $ client ; } } throw new Ts3Exception ( "invalid clientID" , 0x200 ) ; }
4396	public function refund ( \ Aimeos \ MShop \ Order \ Item \ Iface $ order ) { $ provider = $ this -> getProvider ( ) ; if ( ! $ provider -> supportsRefund ( ) ) { return ; } $ base = $ this -> getOrderBase ( $ order -> getBaseId ( ) ) ; $ type = \ Aimeos \ MShop \ Order \ Item \ Base \ Service \ Base :: TYPE_PAYMENT ; $ service = $ this -> getBasketService ( $ base , $ type , $ this -> getServiceItem ( ) -> getCode ( ) ) ; $ data = array ( 'transactionReference' => $ this -> getTransactionReference ( $ base ) , 'currency' => $ base -> getPrice ( ) -> getCurrencyId ( ) , 'amount' => $ this -> getAmount ( $ base -> getPrice ( ) ) , 'transactionId' => $ order -> getId ( ) , ) ; $ response = $ provider -> refund ( $ data ) -> send ( ) ; if ( $ response -> isSuccessful ( ) ) { $ attr = array ( 'REFUNDID' => $ response -> getTransactionReference ( ) ) ; $ this -> setAttributes ( $ service , $ attr , 'payment/omnipay' ) ; $ this -> saveOrderBase ( $ base ) ; $ status = \ Aimeos \ MShop \ Order \ Item \ Base :: PAY_REFUND ; $ order -> setPaymentStatus ( $ status ) ; $ this -> saveOrder ( $ order ) ; } }
572	public function validatePassword ( $ password , $ hash ) { if ( ! is_string ( $ password ) || $ password === '' ) { throw new InvalidArgumentException ( 'Password must be a string and cannot be empty.' ) ; } if ( ! preg_match ( '/^\$2[axy]\$(\d\d)\$[\.\/0-9A-Za-z]{22}/' , $ hash , $ matches ) || $ matches [ 1 ] < 4 || $ matches [ 1 ] > 30 ) { throw new InvalidArgumentException ( 'Hash is invalid.' ) ; } if ( function_exists ( 'password_verify' ) ) { return password_verify ( $ password , $ hash ) ; } $ test = crypt ( $ password , $ hash ) ; $ n = strlen ( $ test ) ; if ( $ n !== 60 ) { return false ; } return $ this -> compareString ( $ test , $ hash ) ; }
3344	public function __batchProcessFiles ( $ filesUuidArr , $ request_type ) { $ filesChunkedArr = array_chunk ( $ filesUuidArr , $ this -> batchFilesChunkSize ) ; $ filesArr = array ( ) ; $ problemsArr = array ( ) ; $ lastStatus = '' ; foreach ( $ filesChunkedArr as $ chunk ) { $ res = $ this -> __batchProcessFilesChunk ( $ chunk , $ request_type ) ; $ lastStatus = $ res [ 'status' ] ; if ( $ lastStatus == "ok" ) { $ problemsObj = $ res [ 'problems' ] ; if ( count ( get_object_vars ( $ problemsObj ) ) > 0 ) { $ problemsArr [ ] = $ problemsObj ; } $ filesArr = array_merge ( $ filesArr , $ res [ 'files' ] ) ; } else { throw new \ Exception ( 'Error process multiple files' , $ res ) ; } } return array ( 'status' => $ lastStatus , 'files' => $ filesArr , 'problems' => $ problemsArr , ) ; }
6616	public function getEndpointResult ( $ method , $ endpointName , Request $ request ) { $ methodName = $ this -> parseEndpointName ( $ method , $ endpointName ) ; if ( ! $ this -> reflection -> hasMethod ( $ methodName ) ) { throw new \ RuntimeException ( "{$this->reflection->getName()}::{$methodName} does not exist" ) ; } $ reflectionMethod = $ this -> reflection -> getMethod ( $ methodName ) ; return $ reflectionMethod -> invokeArgs ( $ this -> controller , $ this -> mapRequestToArguments ( $ reflectionMethod , $ request ) ) ; }
4942	public function fileCountValidationCallback ( ) { if ( $ this -> form && ( $ object = $ this -> form -> getObject ( ) ) ) { if ( $ this -> getMaxFileCount ( ) - 1 < count ( $ object ) ) { return false ; } } return true ; }
5719	public function cancel ( ) { Controller :: curr ( ) -> getResponse ( ) -> addHeader ( "X-Pjax" , "Content" ) ; return Controller :: curr ( ) -> redirect ( $ this -> getBackLink ( ) ) ; }
1432	public function allow ( string ... $ params ) : self { $ this -> all = false ; foreach ( $ params as $ param ) { $ this -> allowed -> put ( $ param , $ param ) ; } return $ this ; }
8907	public function get_next_id ( ) { return ( int ) $ this -> _database -> select ( 'AUTO_INCREMENT' ) -> from ( 'information_schema.TABLES' ) -> where ( 'TABLE_NAME' , $ this -> _database -> dbprefix ( $ this -> get_table ( ) ) ) -> where ( 'TABLE_SCHEMA' , $ this -> _database -> database ) -> get ( ) -> row ( ) -> AUTO_INCREMENT ; }
2167	protected static function generateHelperObject ( $ value ) { $ return = new \ stdClass ( ) ; if ( ! \ is_array ( $ value ) ) { $ return -> value = rtrim ( $ value , "\x00" ) ; $ return -> isUuid = ( \ strlen ( $ value ) == 16 && ! is_numeric ( $ return -> value ) && strncmp ( $ return -> value , Config :: get ( 'uploadPath' ) . '/' , \ strlen ( Config :: get ( 'uploadPath' ) ) + 1 ) !== 0 ) ; $ return -> isNumeric = ( is_numeric ( $ return -> value ) && $ return -> value > 0 ) ; } else { $ return -> value = array_map ( function ( $ var ) { return rtrim ( $ var , "\x00" ) ; } , $ value ) ; $ return -> isUuid = ( \ strlen ( $ value [ 0 ] ) == 16 && ! is_numeric ( $ return -> value [ 0 ] ) && strncmp ( $ return -> value [ 0 ] , Config :: get ( 'uploadPath' ) . '/' , \ strlen ( Config :: get ( 'uploadPath' ) ) + 1 ) !== 0 ) ; $ return -> isNumeric = ( is_numeric ( $ return -> value [ 0 ] ) && $ return -> value [ 0 ] > 0 ) ; } return $ return ; }
4839	public function request ( $ method , $ endpoint , $ params = array ( ) ) { if ( ! isset ( $ params [ 'http_authorization' ] ) ) { if ( ! isset ( $ this -> account_details [ 'access_token' ] ) ) { throw new GoCardless_ClientException ( 'Access token missing' ) ; } $ params [ 'http_bearer' ] = $ this -> account_details [ 'access_token' ] ; } if ( isset ( $ this -> account_details [ 'ua_tag' ] ) ) { $ params [ 'ua_tag' ] = $ this -> account_details [ 'ua_tag' ] ; } if ( substr ( $ endpoint , 0 , 6 ) == '/oauth' ) { $ url = $ this -> base_url . $ endpoint ; } else { $ url = $ this -> base_url . self :: $ api_path . $ endpoint ; } return call_user_func ( GoCardless :: getClass ( 'Request' ) . '::' . $ method , $ url , $ params ) ; }
2583	protected function prepareForNextMessage ( $ messageName , $ messageOptions ) { if ( ! $ this -> isAuthenticated && $ messageName !== 'Security_Authenticate' ) { throw new InvalidSessionException ( 'No active session' ) ; } $ this -> getSoapClient ( $ messageName ) -> __setSoapHeaders ( null ) ; if ( $ this -> isAuthenticated === true && is_int ( $ this -> sessionData [ 'sequenceNumber' ] ) ) { $ this -> sessionData [ 'sequenceNumber' ] ++ ; $ session = new Client \ Struct \ HeaderV2 \ Session ( $ this -> sessionData [ 'sessionId' ] , $ this -> sessionData [ 'sequenceNumber' ] , $ this -> sessionData [ 'securityToken' ] ) ; $ this -> getSoapClient ( $ messageName ) -> __setSoapHeaders ( new \ SoapHeader ( self :: CORE_WS_V2_SESSION_NS , self :: NODENAME_SESSION , $ session ) ) ; } }
1336	protected function queryAllOrOne ( $ query , EncodingParametersInterface $ parameters ) { $ filters = collect ( $ parameters -> getFilteringParameters ( ) ) ; if ( $ this -> isSearchOne ( $ filters ) ) { return $ this -> queryOne ( $ query , $ parameters ) ; } return $ this -> queryAll ( $ query , $ parameters ) ; }
8527	private function _convertListFinancialEventGroups ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'ListFinancialEventGroups' ; if ( $ request -> isSetSellerId ( ) ) { $ parameters [ 'SellerId' ] = $ request -> getSellerId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } if ( $ request -> isSetMaxResultsPerPage ( ) ) { $ parameters [ 'MaxResultsPerPage' ] = $ request -> getMaxResultsPerPage ( ) ; } if ( $ request -> isSetFinancialEventGroupStartedAfter ( ) ) { $ parameters [ 'FinancialEventGroupStartedAfter' ] = $ request -> getFinancialEventGroupStartedAfter ( ) ; } if ( $ request -> isSetFinancialEventGroupStartedBefore ( ) ) { $ parameters [ 'FinancialEventGroupStartedBefore' ] = $ request -> getFinancialEventGroupStartedBefore ( ) ; } return $ parameters ; }
7819	public function settle ( ) { $ this -> files -> makeDirectory ( $ this -> path , 0755 , true , true ) ; $ this -> files -> put ( $ this -> getSource ( ) , '' ) ; }
4066	public function handle ( BuildWidgetEvent $ event ) { $ environment = $ event -> getEnvironment ( ) ; if ( ( $ environment -> getDataDefinition ( ) -> getName ( ) !== 'tl_metamodel_dcasetting' ) || ( $ event -> getProperty ( ) -> getName ( ) !== 'mandatory' ) || ( null === $ event -> getModel ( ) -> getId ( ) ) ) { return ; } $ model = $ event -> getModel ( ) ; $ metaModel = $ this -> getMetaModelFromModel ( $ model ) ; $ attribute = $ metaModel -> getAttributeById ( $ model -> getProperty ( 'attr_id' ) ) ; if ( null === $ attribute ) { return ; } if ( $ attribute -> get ( 'isunique' ) ) { Message :: addInfo ( $ this -> translator -> trans ( 'tl_metamodel_dcasetting.mandatory_for_unique_attr' , [ ] , 'contao_tl_metamodel_dcasetting' ) ) ; $ extra = $ event -> getProperty ( ) -> getExtra ( ) ; $ extra [ 'disabled' ] = true ; $ event -> getProperty ( ) -> setExtra ( $ extra ) ; $ model -> setProperty ( 'mandatory' , true ) ; } }
3236	public function getTotalPriceAttribute ( ) { if ( empty ( $ this -> shopCalculations ) ) $ this -> runCalculations ( ) ; return round ( $ this -> shopCalculations -> totalPrice , 2 ) ; }
2279	public static function get ( $ strKey ) { if ( isset ( static :: $ arrCache [ $ strKey ] ) ) { return static :: $ arrCache [ $ strKey ] ; } if ( \ in_array ( $ strKey , get_class_methods ( __CLASS__ ) ) ) { static :: $ arrCache [ $ strKey ] = static :: $ strKey ( ) ; } else { $ arrChunks = preg_split ( '/([A-Z][a-z]*)/' , $ strKey , - 1 , PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY ) ; $ strServerKey = strtoupper ( implode ( '_' , $ arrChunks ) ) ; static :: $ arrCache [ $ strKey ] = $ _SERVER [ $ strServerKey ] ; } return static :: $ arrCache [ $ strKey ] ; }
3253	public function clear ( ) { DB :: table ( Config :: get ( 'shop.item_table' ) ) -> where ( 'cart_id' , $ this -> attributes [ 'id' ] ) -> delete ( ) ; $ this -> resetCalculations ( ) ; return $ this ; }
3885	private function collectRulesFor ( $ parentSetting , $ filterSettings ) { $ childInformation = $ this -> database -> createQueryBuilder ( ) -> select ( '*' ) -> from ( 'tl_metamodel_filtersetting' ) -> where ( 'pid=:pid' ) -> andWhere ( 'enabled=1' ) -> orderBy ( 'sorting' , 'ASC' ) -> setParameter ( 'pid' , $ parentSetting -> get ( 'id' ) ) -> execute ( ) ; foreach ( $ childInformation -> fetchAll ( \ PDO :: FETCH_ASSOC ) as $ item ) { $ childSetting = $ this -> createSetting ( $ item , $ filterSettings ) ; if ( $ childSetting ) { $ parentSetting -> addChild ( $ childSetting ) ; } } }
6874	private function findOrCreateItem ( ShipmentInterface $ shipment , SaleItemInterface $ saleItem , $ expected , $ available = null ) { $ item = null ; if ( 0 >= $ expected ) { return $ item ; } foreach ( $ shipment -> getItems ( ) as $ i ) { if ( $ i -> getSaleItem ( ) === $ saleItem ) { $ item = $ i ; break ; } } if ( null === $ item ) { $ item = $ this -> factory -> createItemForShipment ( $ shipment ) ; $ item -> setShipment ( $ shipment ) ; $ item -> setSaleItem ( $ saleItem ) ; } $ item -> setExpected ( $ expected ) ; if ( $ shipment -> isReturn ( ) ) { $ item -> setAvailable ( $ expected ) ; } else { if ( null === $ available ) { $ available = $ this -> calculator -> calculateAvailableQuantity ( $ saleItem , $ shipment ) ; } $ item -> setAvailable ( $ available ) ; if ( null === $ shipment -> getId ( ) ) { $ item -> setQuantity ( min ( $ expected , $ available ) ) ; } } return $ item ; }
2584	public function analyze ( SendResult $ response ) { $ analyzeResponse = new Result ( $ response ) ; $ domXpath = $ this -> makeDomXpath ( $ response -> responseXml ) ; $ qPassErrors = "//m:passengerErrorInEnhancedData//m:errorDetails/m:errorCode" ; $ qPassErrorCat = "//m:passengerErrorInEnhancedData//m:errorDetails/m:errorCategory" ; $ qPassErrorMsg = "//m:passengerErrorInEnhancedData//m:freeText" ; $ errorCodeNodeList = $ domXpath -> query ( $ qPassErrors ) ; if ( $ errorCodeNodeList -> length > 0 ) { $ analyzeResponse -> status = Result :: STATUS_ERROR ; $ errorCatNode = $ domXpath -> query ( $ qPassErrorCat ) -> item ( 0 ) ; if ( $ errorCatNode instanceof \ DOMNode ) { $ analyzeResponse -> status = $ this -> makeStatusFromErrorQualifier ( $ errorCatNode -> nodeValue ) ; } $ code = $ errorCodeNodeList -> item ( 0 ) -> nodeValue ; $ errorTextNodeList = $ domXpath -> query ( $ qPassErrorMsg ) ; $ message = $ this -> makeMessageFromMessagesNodeList ( $ errorTextNodeList ) ; $ analyzeResponse -> messages [ ] = new Result \ NotOk ( $ code , trim ( $ message ) , 'passenger' ) ; } if ( empty ( $ analyzeResponse -> messages ) && $ analyzeResponse -> status === Result :: STATUS_OK ) { $ analyzeResponse = $ this -> analyzeSimpleResponseErrorCodeAndMessage ( $ response ) ; } return $ analyzeResponse ; }
6830	protected function moveAssignment ( Stock \ StockAssignmentInterface $ assignment , Stock \ StockUnitInterface $ targetUnit , $ quantity ) { $ quantity = min ( $ quantity , $ assignment -> getSoldQuantity ( ) - $ assignment -> getShippedQuantity ( ) ) ; if ( 0 >= $ quantity ) { return 0 ; } $ sourceUnit = $ assignment -> getStockUnit ( ) ; $ saleItem = $ assignment -> getSaleItem ( ) ; $ this -> logger -> unitSold ( $ sourceUnit , - $ quantity ) ; $ sourceUnit -> setSoldQuantity ( $ sourceUnit -> getSoldQuantity ( ) - $ quantity ) ; $ this -> manager -> persist ( $ sourceUnit ) ; $ this -> logger -> unitSold ( $ targetUnit , $ quantity ) ; $ targetUnit -> setSoldQuantity ( $ targetUnit -> getSoldQuantity ( ) + $ quantity ) ; $ this -> manager -> persist ( $ targetUnit ) ; $ merge = null ; foreach ( $ targetUnit -> getStockAssignments ( ) as $ m ) { if ( $ m -> getSaleItem ( ) === $ saleItem ) { $ merge = $ m ; break ; } } if ( $ quantity == $ assignment -> getSoldQuantity ( ) ) { if ( null !== $ merge ) { $ this -> logger -> assignmentSold ( $ merge , $ quantity ) ; $ merge -> setSoldQuantity ( $ merge -> getSoldQuantity ( ) + $ quantity ) ; $ this -> manager -> persist ( $ merge ) ; $ this -> logger -> assignmentSold ( $ assignment , 0 , false ) ; $ assignment -> setSoldQuantity ( 0 ) -> setSaleItem ( null ) -> setStockUnit ( null ) ; $ this -> manager -> remove ( $ assignment ) ; } else { $ this -> logger -> assignmentUnit ( $ assignment , $ targetUnit ) ; $ assignment -> setStockUnit ( $ targetUnit ) ; $ this -> manager -> persist ( $ assignment ) ; } } else { $ this -> logger -> assignmentSold ( $ assignment , - $ quantity ) ; $ assignment -> setSoldQuantity ( $ assignment -> getSoldQuantity ( ) - $ quantity ) ; $ this -> manager -> persist ( $ assignment ) ; if ( null !== $ merge ) { $ this -> logger -> assignmentSold ( $ merge , $ quantity ) ; $ merge -> setSoldQuantity ( $ merge -> getSoldQuantity ( ) + $ quantity ) ; $ this -> manager -> persist ( $ merge ) ; } else { $ create = $ this -> saleFactory -> createStockAssignmentForItem ( $ saleItem ) ; $ this -> logger -> assignmentSold ( $ create , $ quantity , false ) ; $ create -> setSoldQuantity ( $ quantity ) -> setSaleItem ( $ saleItem ) -> setStockUnit ( $ targetUnit ) ; $ this -> manager -> persist ( $ create ) ; } } return $ quantity ; }
1125	public function isDescendantOf ( $ other ) { return ( $ this -> getLeft ( ) > $ other -> getLeft ( ) && $ this -> getLeft ( ) < $ other -> getRight ( ) && $ this -> inSameScope ( $ other ) ) ; }
4995	public function getActiveFormNext ( ) { $ key = null ; $ actualKey = $ this -> getActiveFormActual ( ) ; if ( isset ( $ actualKey ) ) { $ forms = array_keys ( $ this -> forms ) ; $ formsFlip = array_flip ( $ forms ) ; $ index = $ formsFlip [ $ actualKey ] ; if ( $ index < count ( $ forms ) - 1 ) { $ key = $ forms [ $ index + 1 ] ; } } return $ key ; }
4095	protected function call ( $ url , $ method = "GET" , $ payload = null ) { $ conn = $ this -> ch ; $ protocol = "http" ; $ requestURL = $ protocol . "://" . $ this -> host . $ url ; curl_setopt ( $ conn , CURLOPT_URL , $ requestURL ) ; curl_setopt ( $ conn , CURLOPT_TIMEOUT , $ this -> timeout ) ; curl_setopt ( $ conn , CURLOPT_PORT , $ this -> port ) ; curl_setopt ( $ conn , CURLOPT_CUSTOMREQUEST , strtoupper ( $ method ) ) ; curl_setopt ( $ conn , CURLOPT_FORBID_REUSE , 0 ) ; $ headers = array ( ) ; $ headers [ ] = 'Accept: application/json' ; $ headers [ ] = 'Content-Type: application/json' ; curl_setopt ( $ conn , CURLOPT_HTTPHEADER , $ headers ) ; if ( is_array ( $ payload ) && count ( $ payload ) > 0 ) curl_setopt ( $ conn , CURLOPT_POSTFIELDS , json_encode ( $ payload ) ) ; else curl_setopt ( $ conn , CURLOPT_POSTFIELDS , $ payload ) ; ob_start ( ) ; curl_exec ( $ conn ) ; $ response = ob_get_clean ( ) ; if ( $ response !== false ) { $ data = json_decode ( $ response , true ) ; if ( ! $ data ) { $ data = array ( 'error' => $ response , "code" => curl_getinfo ( $ conn , CURLINFO_HTTP_CODE ) ) ; } } else { $ errno = curl_errno ( $ conn ) ; switch ( $ errno ) { case CURLE_UNSUPPORTED_PROTOCOL : $ error = "Unsupported protocol [$protocol]" ; break ; case CURLE_FAILED_INIT : $ error = "Internal cUrl error?" ; break ; case CURLE_URL_MALFORMAT : $ error = "Malformed URL [$requestURL] -d " . json_encode ( $ payload ) ; break ; case CURLE_COULDNT_RESOLVE_PROXY : $ error = "Couldnt resolve proxy" ; break ; case CURLE_COULDNT_RESOLVE_HOST : $ error = "Couldnt resolve host" ; break ; case CURLE_COULDNT_CONNECT : $ error = "Couldnt connect to host [{$this->host}], ElasticSearch down?" ; break ; case CURLE_OPERATION_TIMEDOUT : $ error = "Operation timed out on [$requestURL]" ; break ; default : $ error = "Unknown error" ; if ( $ errno == 0 ) { $ error .= ". Non-cUrl error" ; } else { $ errstr = curl_error ( $ conn ) ; $ error .= " ($errstr)" ; } break ; } $ exception = new HTTPException ( $ error ) ; $ exception -> payload = $ payload ; $ exception -> port = $ this -> port ; $ exception -> protocol = $ protocol ; $ exception -> host = $ this -> host ; $ exception -> method = $ method ; throw $ exception ; } return $ data ; }
12285	public function end ( ) : string { $ property = static :: END_ASSETS_NAME . static :: BLOCK_PROPERTY_SUFFIX ; return isset ( $ this -> $ property ) ? trim ( $ this -> make ( static :: END_ASSETS_NAME ) ) . PHP_EOL : PHP_EOL ; }
1866	public function addSenderNamePlaceholder ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ dc -> activeRecord && $ dc -> activeRecord -> pid ) { $ objChannel = $ this -> Database -> prepare ( "SELECT senderName FROM tl_newsletter_channel WHERE id=?" ) -> execute ( $ dc -> activeRecord -> pid ) ; $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'fields' ] [ $ dc -> field ] [ 'eval' ] [ 'placeholder' ] = $ objChannel -> senderName ; } return $ varValue ; }
9820	public function getColumn ( $ pColumn ) { $ this -> testColumnInRange ( $ pColumn ) ; if ( ! isset ( $ this -> columns [ $ pColumn ] ) ) { $ this -> columns [ $ pColumn ] = new AutoFilter \ Column ( $ pColumn , $ this ) ; } return $ this -> columns [ $ pColumn ] ; }
7501	public function clearCache ( string $ namespace = null ) { if ( null !== $ namespace ) { $ this -> cacheStore -> remove ( self :: APP_CACHE_PREFIX . $ namespace , array ( ) ) ; return ; } $ this -> cacheStore -> clear ( ) ; }
11700	public function getCachePool ( $ name ) { if ( array_key_exists ( $ name , $ this -> cachePools ) ) { return $ this -> cachePools [ $ name ] ; } throw new KeyNotFoundInSetException ( $ name , array_keys ( $ this -> cachePools ) , 'cache pools' ) ; }
2772	public function init ( array $ options = [ ] ) : string { $ argsAndOptions = [ $ this -> directory , $ options ] ; return $ this -> run ( 'init' , $ argsAndOptions , false ) ; }
12460	private function getDefaultGroupsId ( ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ customFieldsGroupIds = $ em -> createQuery ( 'SELECT g.id FROM ' . 'ChillCustomFieldsBundle:CustomFieldsDefaultGroup d ' . 'JOIN d.customFieldsGroup g' ) -> getResult ( Query :: HYDRATE_SCALAR ) ; $ result = array ( ) ; foreach ( $ customFieldsGroupIds as $ row ) { $ result [ ] = $ row [ 'id' ] ; } return $ result ; }
9414	public function variance ( ) { $ float_variance = pow ( $ this -> float_sigma , 2 ) ; if ( $ this -> int_precision ) { return round ( $ float_variance , $ this -> int_precision ) ; } return $ float_variance ; }
2085	public static function addFiles ( $ files ) { foreach ( $ files as $ name => $ file ) { self :: addFile ( $ name , $ file ) ; } }
10186	private static function fromArray ( $ object , $ type = null , $ innerType = null ) { if ( $ type == 'array' ) { foreach ( $ object as $ element ) { $ result [ ] = self :: fromArray ( $ element , $ innerType ) ; } return $ result ; } else if ( class_exists ( $ type ) ) { $ class = new $ type ( ) ; if ( is_subclass_of ( $ class , 'AbstractJSONWrapper' ) ) { $ class -> fromArray ( $ object ) ; return $ class ; } else { trigger_error ( __CLASS__ . ": Trying to deserialize " . get_class ( $ class ) ) ; return $ object ; } } else { return $ object ; } }
11719	public function saveAction ( Request $ request , Application $ app ) { $ options = array ( "request" => $ request , "configuration_handler" => $ app [ "red_kite_cms.configuration_handler" ] , 'security' => $ app [ "security" ] , "queue_manager" => $ app [ "red_kite_cms.queue_manager" ] , ) ; $ response = parent :: save ( $ options ) ; if ( $ app [ "red_kite_cms.queue_manager" ] -> hasQueue ( ) && $ response -> getContent ( ) == "Queue saved" ) { $ lastRoute = $ request -> getSession ( ) -> get ( 'last_uri' ) ; return $ app -> redirect ( $ lastRoute ) ; } return $ response ; }
2793	public function getCacheDirectory ( ) { if ( ! is_null ( $ this -> cacheDirectory ) ) { return $ this -> cacheDirectory ; } if ( defined ( 'PHP_WINDOWS_VERSION_MAJOR' ) ) { if ( ! getenv ( 'APPDATA' ) ) { throw new RuntimeException ( 'The APPDATA environment variable must be set for humbug.' ) ; } $ home = strtr ( getenv ( 'APPDATA' ) , '\\' , '/' ) . '/Humbug' ; } else { if ( ! getenv ( 'HOME' ) ) { throw new RuntimeException ( 'The HOME environment variable must be set for humbug.' ) ; } $ home = rtrim ( getenv ( 'HOME' ) , '/' ) . '/.humbug' ; } $ cache = $ home . '/cache' ; foreach ( [ $ home , $ cache ] as $ dir ) { if ( ! is_dir ( $ dir ) ) { mkdir ( $ dir , 0777 ) ; } } file_put_contents ( $ home . '/.htaccess' , 'Deny from all' ) ; $ this -> cacheDirectory = $ cache ; return $ cache ; }
4809	public function deactivate ( ) { $ this -> clear_schedule ( ) ; if ( ! is_multisite ( ) || wp_is_large_network ( ) ) { return ; } $ sites = ( array ) get_site_option ( $ this -> args [ 'name' ] . '_sites' , array ( ) ) ; $ sites and $ sites = array_diff ( $ sites , [ get_current_blog_id ( ) ] ) ; foreach ( $ sites as $ site ) { switch_to_blog ( $ site ) ; $ this -> clear_schedule ( ) ; } restore_current_blog ( ) ; delete_site_option ( $ this -> args [ 'name' ] . '_sites' ) ; }
915	public static function camelCaseToUnderscore ( $ string ) { return Preg :: replaceCallback ( '/(^|[a-z0-9])([A-Z])/' , static function ( array $ matches ) { return strtolower ( '' !== $ matches [ 1 ] ? $ matches [ 1 ] . '_' . $ matches [ 2 ] : $ matches [ 2 ] ) ; } , $ string ) ; }
2775	public function streamOutput ( bool $ streamOutput = true ) : void { if ( $ streamOutput && ! isset ( $ this -> gitOutputListener ) ) { $ this -> gitOutputListener = new GitOutputStreamListener ( ) ; $ this -> addOutputListener ( $ this -> gitOutputListener ) ; } if ( ! $ streamOutput && isset ( $ this -> gitOutputListener ) ) { $ this -> removeOutputListener ( $ this -> gitOutputListener ) ; unset ( $ this -> gitOutputListener ) ; } }
10107	private function writeColinfo ( $ col_array ) { if ( isset ( $ col_array [ 0 ] ) ) { $ colFirst = $ col_array [ 0 ] ; } if ( isset ( $ col_array [ 1 ] ) ) { $ colLast = $ col_array [ 1 ] ; } if ( isset ( $ col_array [ 2 ] ) ) { $ coldx = $ col_array [ 2 ] ; } else { $ coldx = 8.43 ; } if ( isset ( $ col_array [ 3 ] ) ) { $ xfIndex = $ col_array [ 3 ] ; } else { $ xfIndex = 15 ; } if ( isset ( $ col_array [ 4 ] ) ) { $ grbit = $ col_array [ 4 ] ; } else { $ grbit = 0 ; } if ( isset ( $ col_array [ 5 ] ) ) { $ level = $ col_array [ 5 ] ; } else { $ level = 0 ; } $ record = 0x007D ; $ length = 0x000C ; $ coldx *= 256 ; $ ixfe = $ xfIndex ; $ reserved = 0x0000 ; $ level = max ( 0 , min ( $ level , 7 ) ) ; $ grbit |= $ level << 8 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vvvvvv' , $ colFirst , $ colLast , $ coldx , $ ixfe , $ grbit , $ reserved ) ; $ this -> append ( $ header . $ data ) ; }
2981	private function findLastImportedPath ( $ yamlContents ) { $ data = Yaml :: parse ( $ yamlContents ) ; if ( ! isset ( $ data [ 'imports' ] ) ) { return false ; } $ lastImport = end ( $ data [ 'imports' ] ) ; if ( ! isset ( $ lastImport [ 'resource' ] ) ) { return false ; } return $ lastImport [ 'resource' ] ; }
5269	private function translateSelect ( ) { $ build = array ( 'select' ) ; if ( $ this -> found_rows ) { $ build [ ] = 'SQL_CALC_FOUND_ROWS' ; } if ( $ this -> distinct ) { $ build [ ] = 'distinct' ; } $ build [ ] = ! empty ( $ this -> statements [ 'select' ] ) && is_array ( $ this -> statements [ 'select' ] ) ? join ( ', ' , $ this -> statements [ 'select' ] ) : '*' ; $ build [ ] = 'from ' . $ this -> table ; if ( ! empty ( $ this -> statements [ 'wheres' ] ) ) { $ build [ ] = join ( ' ' , $ this -> statements [ 'wheres' ] ) ; } if ( ! empty ( $ this -> statements [ 'groups' ] ) ) { $ build [ ] = 'group by ' . join ( ', ' , $ this -> statements [ 'groups' ] ) ; if ( ! empty ( $ this -> statements [ 'having' ] ) ) { $ build [ ] = $ this -> statements [ 'having' ] ; } } if ( ! empty ( $ this -> statements [ 'orders' ] ) ) { $ build [ ] = $ this -> translateOrderBy ( ) ; } if ( ! empty ( $ this -> limit ) ) { $ build [ ] = $ this -> limit ; } return join ( ' ' , $ build ) ; }
7412	protected function customChmod ( string $ target , $ mode = 0666 ) { if ( false === @ chmod ( $ target , $ mode & ~ umask ( ) ) ) { throw new FileException ( sprintf ( 'Unable to change mode of the "%s"' , $ target ) ) ; } }
1367	protected function bootBladeDirectives ( ) { $ compiler = $ this -> app -> make ( BladeCompiler :: class ) ; $ compiler -> directive ( 'jsonapi' , Renderer :: class . '::compileWith' ) ; $ compiler -> directive ( 'encode' , Renderer :: class . '::compileEncode' ) ; }
1882	protected function getMD5Folders ( $ strPath ) { $ arrFiles = array ( ) ; foreach ( scan ( $ this -> strRootDir . '/' . $ strPath ) as $ strFile ) { if ( ! is_dir ( $ this -> strRootDir . '/' . $ strPath . '/' . $ strFile ) ) { continue ; } $ arrFiles [ substr ( md5 ( $ this -> strRootDir . '/' . $ strPath . '/' . $ strFile ) , 0 , 8 ) ] = 1 ; foreach ( $ this -> getMD5Folders ( $ strPath . '/' . $ strFile ) as $ k => $ v ) { $ arrFiles [ $ k ] = $ v ; } } return $ arrFiles ; }
11567	public function set ( string $ sNameOfDi , callable $ cFunction , bool $ bShared = false ) : Di { if ( $ bShared === true ) { self :: $ _aSharedDependencyInjectorContener [ md5 ( $ sNameOfDi ) ] = $ cFunction ; } else { $ this -> _aDependencyInjectorContener [ md5 ( $ sNameOfDi ) ] = $ cFunction ; } return $ this ; }
3846	protected static function changeSubPalettesToConditions ( ) { $ objDB = self :: DB ( ) ; if ( ! $ objDB -> tableExists ( 'tl_metamodel_dcasetting_condition' ) ) { $ objDB -> execute ( 'CREATE TABLE `tl_metamodel_dcasetting_condition` ( `id` int(10) unsigned NOT NULL auto_increment, `pid` int(10) unsigned NOT NULL default \'0\', `settingId` int(10) unsigned NOT NULL default \'0\', `sorting` int(10) unsigned NOT NULL default \'0\', `tstamp` int(10) unsigned NOT NULL default \'0\', `enabled` char(1) NOT NULL default \'\', `type` varchar(255) NOT NULL default \'\', `attr_id` int(10) unsigned NOT NULL default \'0\', `comment` varchar(255) NOT NULL default \'\', `value` blob NULL, PRIMARY KEY (`id`) )ENGINE=MyISAM DEFAULT CHARSET=utf8;' ) ; } if ( $ objDB -> tableExists ( 'tl_metamodel_dcasetting' , null , true ) && $ objDB -> fieldExists ( 'subpalette' , 'tl_metamodel_dcasetting' , true ) ) { $ subpalettes = $ objDB -> execute ( 'SELECT * FROM tl_metamodel_dcasetting WHERE subpalette!=0' ) ; if ( $ subpalettes -> numRows ) { $ attributes = $ objDB -> execute ( ' SELECT attr_id, colName FROM tl_metamodel_dcasetting AS setting LEFT JOIN tl_metamodel_attribute AS attribute ON (setting.attr_id=attribute.id) WHERE dcatype=\'attribute\' ' ) ; $ attr = array ( ) ; while ( $ attributes -> next ( ) ) { $ attr [ $ attributes -> attr_id ] = $ attributes -> colName ; } $ checkboxes = $ objDB -> execute ( ' SELECT * FROM tl_metamodel_dcasetting WHERE subpalette=0 AND dcatype=\'attribute\' ' ) ; $ check = array ( ) ; while ( $ checkboxes -> next ( ) ) { $ check [ $ checkboxes -> id ] = $ checkboxes -> attr_id ; } while ( $ subpalettes -> next ( ) ) { $ data = array ( 'pid' => 0 , 'settingId' => $ subpalettes -> id , 'sorting' => '128' , 'tstamp' => time ( ) , 'enabled' => '1' , 'type' => 'conditionpropertyvalueis' , 'attr_id' => $ check [ $ subpalettes -> subpalette ] , 'comment' => sprintf ( 'Only show when checkbox "%s" is checked' , $ attr [ $ check [ $ subpalettes -> subpalette ] ] ) , 'value' => '1' , ) ; $ objDB -> prepare ( 'INSERT INTO tl_metamodel_dcasetting_condition %s' ) -> set ( $ data ) -> execute ( ) ; $ objDB -> prepare ( 'UPDATE tl_metamodel_dcasetting SET subpalette=0 WHERE id=?' ) -> execute ( $ subpalettes -> id ) ; $ objDB -> prepare ( 'UPDATE tl_metamodel_dcasetting SET submitOnChange=1 WHERE id=?' ) -> execute ( $ subpalettes -> subpalette ) ; } } TableManipulation :: dropColumn ( 'tl_metamodel_dcasetting' , 'subpalette' , true ) ; } }
9157	final public function call ( $ action , Request $ request , View $ view ) { $ this -> request = $ request ; ob_start ( ) ; $ rf = new \ ReflectionMethod ( $ this , $ action ) ; $ anno = $ rf -> getDocComment ( ) ; $ matches = array ( ) ; if ( preg_match ( '#@responseType ([\w\/]+)#' , $ anno , $ matches ) ) { $ this -> response -> setType ( $ matches [ 1 ] ) ; } if ( preg_match ( '#@title ([^\\n]+)#' , $ anno , $ matches ) ) { $ this -> response -> setTitle ( $ matches [ 1 ] ) ; } $ rf -> invoke ( $ this , $ this -> request ) ; $ this -> response -> appendBody ( ob_get_clean ( ) ) ; $ view -> render ( $ this -> response , $ request , $ this -> viewParams ) ; $ this -> addControls ( $ this -> response , $ request , $ view ) ; return $ this -> response ; }
7188	private function buildCombinations ( $ quantity ) { if ( empty ( $ this -> map ) ) { return [ ] ; } $ combinations = [ ] ; foreach ( $ this -> map as $ id => $ qty ) { $ combinations [ ] = new AssignmentCombination ( [ $ id => $ qty ] , $ diff = $ qty - $ quantity ) ; if ( $ diff == 0 ) { return $ combinations ; } } for ( $ length = 2 ; $ length < count ( $ this -> map ) ; $ length ++ ) { foreach ( combine_assoc ( $ this -> map , $ length ) as $ map ) { $ combinations [ ] = new AssignmentCombination ( $ map , $ diff = array_sum ( $ map ) - $ quantity ) ; if ( $ diff == 0 ) { return $ combinations ; } } } $ combinations [ ] = new AssignmentCombination ( $ this -> map , array_sum ( $ this -> map ) - $ quantity ) ; return $ combinations ; }
8504	public function confirmTransportRequest ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_ConfirmTransportInputRequest ) ) { $ request = new FBAInboundServiceMWS_Model_ConfirmTransportInputRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ConfirmTransportRequest' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_ConfirmTransportRequestResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
9205	public function init ( ) { $ path = $ this -> absolutePath ( $ this -> getFile ( ) ) ; $ this -> quiet ( 'Initializing seed file: ' . $ this -> shortPath ( $ path ) ) ; $ this -> existsOrCreate ( $ path ) ; }
6854	private function findPaymentTokens ( PaymentInterface $ payment ) { $ identity = $ this -> getPaymentIdentity ( $ payment ) ; $ tokens = $ this -> payum -> getTokenStorage ( ) -> findBy ( [ 'details' => $ identity , ] ) ; return $ tokens ; }
2614	public function getWebsiteName ( ) { $ websites = $ this -> storeManager -> getWebsites ( ) ; $ websiteName = 'Not set.' ; foreach ( $ websites as $ website ) { if ( $ website -> getIsDefault ( ) ) { $ websiteName = $ website -> getName ( ) ; } } return $ websiteName ; }
9034	protected function init ( $ key ) { if ( ! isset ( $ this -> files [ $ key ] ) ) { $ this -> files [ $ key ] = fopen ( $ this -> dir . $ key . '.lockfile' , 'w+' ) ; $ this -> owns [ $ key ] = false ; } }
5258	public static function map ( $ query = [ ] , callable $ callback = null , $ limit = - 1 ) { if ( $ query instanceof QueryBuilder ) { $ query = $ query -> build ( ) ; } $ query [ 'from' ] = Arr :: get ( $ query , 'from' , 0 ) ; $ query [ 'size' ] = Arr :: get ( $ query , 'size' , 50 ) ; $ i = 0 ; $ models = static :: search ( $ query ) ; $ total = $ models -> getTotal ( ) ; while ( $ models ) { foreach ( $ models as $ model ) { if ( $ callback ) { $ callback ( $ model ) ; } $ i ++ ; } $ query [ 'from' ] += $ query [ 'size' ] ; if ( $ i >= $ total || ( $ limit > 0 && $ i >= $ limit ) ) { break ; } $ models = static :: search ( $ query ) ; } return $ total ; }
8413	public function getLink ( ) { if ( $ this -> isConnected ( ) === false ) { $ this -> connect ( ) ; } if ( isset ( $ this -> servers [ 'all' ] ) === true ) { return $ this -> servers [ 'all' ] [ 'link' ] ; } if ( $ this -> transactionLevel >= 1 ) { return $ this -> servers [ 'write' ] [ 'link' ] ; } return $ this -> servers [ 'read' ] [ 'link' ] ; }
717	public function dateTime ( $ precision = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_DATETIME , $ precision ) ; }
6092	public function removeMediaFromMoodboard ( $ moodboardId , $ mediaId ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> delete ( 'v1/moodboards/' . $ moodboardId . '/media/' . $ mediaId . '' , $ parameters ) ; return $ result ; }
1711	public function setEmptyEndTime ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ varValue === null ) { $ varValue = $ dc -> activeRecord -> startTime ; } return $ varValue ; }
4705	public function slice ( $ offset , $ length = null ) { return new Collection ( array_slice ( $ this -> objects , $ offset , $ length ) ) ; }
10842	protected function refreshProductSellPrices ( ProductInterface $ product ) { $ sellPrice = $ product -> getSellPrice ( ) ; $ grossAmount = $ sellPrice -> getGrossAmount ( ) ; $ discountedGrossAmount = $ sellPrice -> getDiscountedGrossAmount ( ) ; $ taxRate = $ product -> getSellPriceTax ( ) -> getValue ( ) ; $ netAmount = TaxHelper :: calculateNetPrice ( $ grossAmount , $ taxRate ) ; $ discountedNetAmount = TaxHelper :: calculateNetPrice ( $ discountedGrossAmount , $ taxRate ) ; $ sellPrice -> setTaxRate ( $ taxRate ) ; $ sellPrice -> setTaxAmount ( $ grossAmount - $ netAmount ) ; $ sellPrice -> setNetAmount ( $ netAmount ) ; $ sellPrice -> setDiscountedTaxAmount ( $ discountedGrossAmount - $ discountedNetAmount ) ; $ sellPrice -> setDiscountedNetAmount ( $ discountedNetAmount ) ; }
12760	public static function dispatch ( $ eventName , Event $ event ) { if ( null === self :: $ dispatcher ) { return $ event ; } self :: $ dispatcher -> dispatch ( $ eventName , $ event ) ; DataLogger :: log ( sprintf ( 'The "%s" event was dispatched' , $ eventName ) ) ; if ( $ event -> getAbort ( ) ) { DataLogger :: log ( sprintf ( 'The "%s" event was aborted' , $ eventName ) , DataLogger :: ERROR ) ; throw new EventAbortedException ( $ event -> getAbortMessage ( ) ) ; } return $ event ; }
12032	function addDispatchMethod ( ) { $ methodGenerator = new MethodGenerator ( 'dispatch' ) ; $ body = '' ; $ body .= $ this -> generateExecuteFragment ( ) ; $ body .= $ this -> generateResponseFragment ( ) ; $ docBlock = $ this -> generateExecuteDocBlock ( 'Dispatch the request for this operation and process the response. Allows you to modify the request before it is sent.' ) ; $ parameter = new ParameterGenerator ( 'request' , 'Amp\Artax\Request' ) ; $ methodGenerator -> setParameter ( $ parameter ) ; $ tag = createParamTag ( $ parameter , 'The request to be processed' ) ; $ docBlock -> setTag ( $ tag ) ; $ methodGenerator -> setDocBlock ( $ docBlock ) ; $ methodGenerator -> setBody ( $ body ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; }
9002	public function column_time ( AbstractLog $ item ) { $ time = $ item -> get_time ( ) ; if ( empty ( $ time ) ) { echo '-' ; } else { echo $ time -> format ( get_option ( 'date_format' ) . ' ' . get_option ( 'time_format' ) ) ; } }
11987	private function isEndOfLine ( $ i ) { $ ch = $ this -> data [ $ i ] ; if ( $ this -> getLineEndingModeCrlf ( ) ) { if ( $ ch == "\r" ) { $ more_ch = $ i + 1 < strlen ( $ this -> data ) ; if ( $ more_ch ) { $ next_n = $ this -> data [ $ i + 1 ] == "\n" ; if ( $ next_n ) return true ; } } } else { if ( $ ch == "\n" ) return true ; } return false ; }
4153	public function invalidateBearerToken ( ) { $ url = $ this -> getInvalidateBearerTokenUrl ( ) ; $ bearerToken = $ this -> bearerToken ; if ( $ bearerToken === null ) { $ bearerToken = $ this -> getBearerToken ( ) ; } $ params = array ( 'post' => array ( 'access_token' => $ bearerToken ) , 'headers' => $ this -> buildBearerTokenHeader ( ) , ) ; $ response = $ this -> curl -> send ( $ url , $ params ) ; $ obj = json_decode ( $ response [ 'body' ] ) ; if ( ! $ obj || ! isset ( $ obj -> access_token ) || $ obj -> access_token != $ bearerToken ) { $ this -> findExceptions ( $ response ) ; } unset ( $ url , $ bearerToken , $ params , $ response , $ obj ) ; return true ; }
5377	public function getAttribute ( $ label ) { $ label = strtolower ( $ label ) ; if ( ! isset ( $ this -> attributes [ $ label ] ) ) { return false ; } return ( string ) $ this -> attributes [ $ label ] ; }
6774	protected function didDeliveryCountryChanged ( SaleInterface $ sale ) { $ saleCs = $ this -> persistenceHelper -> getChangeSet ( $ sale ) ; $ oldCountry = $ newCountry = null ; $ oldSameAddress = isset ( $ saleCs [ 'sameAddress' ] ) ? $ saleCs [ 'sameAddress' ] [ 0 ] : $ sale -> isSameAddress ( ) ; if ( $ oldSameAddress ) { $ oldAddress = isset ( $ saleCs [ 'invoiceAddress' ] ) ? $ saleCs [ 'invoiceAddress' ] [ 0 ] : $ sale -> getInvoiceAddress ( ) ; } else { $ oldAddress = isset ( $ saleCs [ 'deliveryAddress' ] ) ? $ saleCs [ 'deliveryAddress' ] [ 0 ] : $ sale -> getDeliveryAddress ( ) ; } if ( null !== $ oldAddress ) { $ oldAddressCs = $ this -> persistenceHelper -> getChangeSet ( $ oldAddress ) ; $ oldCountry = isset ( $ oldAddressCs [ 'country' ] ) ? $ oldAddressCs [ 'country' ] [ 0 ] : $ oldAddress -> getCountry ( ) ; } $ newAddress = $ sale -> isSameAddress ( ) ? $ sale -> getInvoiceAddress ( ) : $ sale -> getDeliveryAddress ( ) ; if ( null !== $ newAddress ) { $ newCountry = $ newAddress -> getCountry ( ) ; } if ( $ oldCountry !== $ newCountry ) { return true ; } return false ; }
1427	protected function modelRelationForField ( $ field ) { return $ this -> camelCaseRelations ? Str :: camelize ( $ field ) : Str :: underscore ( $ field ) ; }
5879	protected static function createIndex ( $ fileName , $ width , $ height ) { $ relativePath = substr ( PathUtility :: dirname ( $ fileName ) , strlen ( PATH_site ) ) ; $ resourceFactory = \ TYPO3 \ CMS \ Core \ Resource \ ResourceFactory :: getInstance ( ) ; $ targetFolder = $ resourceFactory -> retrieveFileOrFolderObject ( $ relativePath ) ; $ targetFilename = PathUtility :: basename ( $ fileName ) ; $ storageConfiguration = $ targetFolder -> getStorage ( ) -> getConfiguration ( ) ; if ( ! isset ( $ storageConfiguration [ 'basePath' ] ) ) { return ; } $ basePath = rtrim ( $ storageConfiguration [ 'basePath' ] , '/' ) . '/' ; $ basePath = GeneralUtility :: getFileAbsFileName ( $ basePath ) ; $ identifier = substr ( $ fileName , strlen ( $ basePath ) - 1 ) ; $ driver = static :: accessProtectedProperty ( $ targetFolder -> getStorage ( ) , 'driver' ) ; $ fileInfo = $ driver -> getFileInfoByIdentifier ( $ identifier ) ; $ file = $ resourceFactory -> createFileObject ( $ fileInfo ) ; $ fileRepository = GeneralUtility :: makeInstance ( \ TYPO3 \ CMS \ Core \ Resource \ FileRepository :: class ) ; $ fileRepository -> addToIndex ( $ file ) ; }
8466	public static function setUrlParams ( $ url = false ) { $ url = $ url !== false ? $ url : self :: getCurrentPage ( ) ; if ( strpos ( $ url , '?' ) == false && strpos ( $ url , '&' ) != false ) { $ url = preg_replace ( '/&/' , '?' , $ url , 1 ) ; $ parts = parse_url ( $ url ) ; $ query = isset ( $ parts [ 'query' ] ) ? $ parts [ 'query' ] : '' ; parse_str ( $ query , $ query ) ; } foreach ( isset ( $ query ) ? $ query : [ ] as $ key => $ value ) { $ _GET [ $ key ] = $ value ; } return explode ( '?' , $ url ) [ 0 ] ; }
4315	protected function getGroupDepth ( ) { $ depth = 0 ; foreach ( $ this -> data [ 'groupStacks' ] as $ stack ) { $ depth += \ count ( $ stack ) ; } $ depth += \ count ( $ this -> data [ 'groupPriorityStack' ] ) ; return $ depth ; }
7008	private function format_l ( & $ str ) { if ( strstr ( $ str , '%l' ) ) $ str = str_replace ( '%l' , $ this -> dayName ( true ) , $ str ) ; }
81	public static function call ( $ callable ) { try { self :: suppress ( ) ; $ result = call_user_func_array ( $ callable , array_slice ( func_get_args ( ) , 1 ) ) ; self :: restore ( ) ; return $ result ; } catch ( \ Exception $ e ) { self :: restore ( ) ; throw $ e ; } }
8275	public function handleEvent ( $ eventName , array $ params ) { if ( method_exists ( $ this , $ eventName ) ) { call_user_func_array ( array ( $ this , $ eventName ) , $ params ) ; } }
8664	private function convertManageReportSchedule ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'ManageReportSchedule' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetReportType ( ) ) { $ parameters [ 'ReportType' ] = $ request -> getReportType ( ) ; } if ( $ request -> isSetSchedule ( ) ) { $ parameters [ 'Schedule' ] = $ request -> getSchedule ( ) ; } if ( $ request -> isSetScheduleDate ( ) ) { $ parameters [ 'ScheduleDate' ] = $ this -> getFormattedTimestamp ( $ request -> getScheduleDate ( ) ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
4152	public function getBearerToken ( ) { $ url = $ this -> getBearerTokenUrl ( ) ; $ params = array ( 'post' => array ( 'grant_type' => 'client_credentials' ) , 'headers' => $ this -> buildBearerTokenHeader ( ) , ) ; $ response = $ this -> curl -> send ( $ url , $ params ) ; $ obj = json_decode ( $ response [ 'body' ] ) ; if ( ! $ obj || ! isset ( $ obj -> token_type ) || $ obj -> token_type != 'bearer' ) { $ this -> findExceptions ( $ response ) ; } $ this -> bearerToken = rawurldecode ( $ obj -> access_token ) ; unset ( $ url , $ params , $ response , $ obj ) ; return $ this -> bearerToken ; }
6567	public function getLink ( $ phone_number = '' , $ body = '' ) { if ( ! empty ( $ body ) ) { $ body = "?body=" . $ body ; } $ sms = 'sms:' . trim ( $ phone_number . $ body ) ; return $ sms ; }
387	public function setAttributeOrders ( $ attributeOrders , $ validate = true ) { if ( $ attributeOrders === null || ! $ validate ) { $ this -> _attributeOrders = $ attributeOrders ; } else { $ this -> _attributeOrders = [ ] ; foreach ( $ attributeOrders as $ attribute => $ order ) { if ( isset ( $ this -> attributes [ $ attribute ] ) ) { $ this -> _attributeOrders [ $ attribute ] = $ order ; if ( ! $ this -> enableMultiSort ) { break ; } } } } }
10667	protected function buildOnDup ( ) { $ result = [ ] ; foreach ( $ this -> clause_ondup as $ col => $ expr ) { $ result [ ] = $ col . ' = ' . $ expr ; } return $ result ; }
9416	public function max ( ) { $ float_max = 1 / ( $ this -> float_sigma * sqrt ( 2 * pi ( ) ) ) ; if ( $ this -> int_precision ) { return round ( $ float_max , $ this -> int_precision ) ; } return $ float_max ; }
6901	public function destroy ( ) : void { if ( $ this -> is_active ( ) ) { session_unset ( ) ; session_destroy ( ) ; $ this -> _data = [ ] ; Cookie :: delete ( $ this -> name ) ; } }
10176	public function getHighestRow ( $ column = null ) { if ( $ column == null ) { $ colRow = $ this -> getHighestRowAndColumn ( ) ; return $ colRow [ 'row' ] ; } $ rowList = [ 0 ] ; foreach ( $ this -> getCoordinates ( ) as $ coord ) { sscanf ( $ coord , '%[A-Z]%d' , $ c , $ r ) ; if ( $ c != $ column ) { continue ; } $ rowList [ ] = $ r ; } return max ( $ rowList ) ; }
3274	public function set ( string $ key , $ data ) { Validation :: validateKey ( $ key ) ; if ( $ this -> get ( $ key ) !== false ) { $ this -> replace ( $ key , $ data ) ; return ; } $ this -> getDatabase ( ) -> appendToFile ( $ this -> getLineString ( $ key , $ data ) ) ; if ( $ cache = $ this -> getConfig ( ) -> getCache ( ) ) { $ cache -> delete ( $ key ) ; } }
11477	public function boot ( Plugin $ theme ) { $ this -> plugin = $ theme ; parent :: boot ( $ theme ) ; $ this -> initTemplates ( ) ; $ this -> initHomepageTemplate ( ) ; return $ this ; }
2957	public function confCharacterLength ( $ int ) { if ( $ this -> _dState !== SERIAL_DEVICE_SET ) { trigger_error ( "Unable to set length of a character : the device " . "is either not set or opened" , E_USER_WARNING ) ; return false ; } $ int = ( int ) $ int ; if ( $ int < 5 ) { $ int = 5 ; } elseif ( $ int > 8 ) { $ int = 8 ; } if ( $ this -> _os === "linux" ) { $ ret = $ this -> _exec ( "stty -F " . $ this -> _device . " cs" . $ int , $ out ) ; } elseif ( $ this -> _os === "osx" ) { $ ret = $ this -> _exec ( "stty -f " . $ this -> _device . " cs" . $ int , $ out ) ; } else { $ ret = $ this -> _exec ( "mode " . $ this -> _winDevice . " DATA=" . $ int , $ out ) ; } if ( $ ret === 0 ) { return true ; } trigger_error ( "Unable to set character length : " . $ out [ 1 ] , E_USER_WARNING ) ; return false ; }
6623	public function parseResponse ( Response $ response ) { $ json = $ response -> json ( ) ; if ( ! is_null ( $ json ) ) { if ( isset ( $ json -> error ) ) { $ error = $ json -> error ; throw new AccessTokenException ( $ error -> type . ': ' . $ error -> message , $ error -> code ) ; } } $ token = $ response -> content ( ) ; return $ this -> parseToken ( $ token ) ; }
4962	public function addViewModel ( $ name , $ model , $ priority = 0 ) { $ this -> models -> insert ( $ name , $ model , $ priority ) ; return $ this ; }
3777	protected function getParamName ( ) { if ( $ this -> get ( 'urlparam' ) ) { return $ this -> get ( 'urlparam' ) ; } $ objAttribute = $ this -> getFilteredAttribute ( ) ; if ( $ objAttribute ) { return $ objAttribute -> getColName ( ) ; } return null ; }
4858	public function getList ( $ namespace , $ callback ) { $ session = new Container ( $ namespace ) ; $ params = $ session -> params ? : array ( ) ; if ( ! $ session -> list ) { $ session -> list = is_array ( $ callback ) ? call_user_func ( $ callback , $ session -> params ) : $ callback -> getPaginationList ( $ session -> params ) ; } return $ session -> list ; }
1009	public static function defaultFieldResolver ( $ source , $ args , $ context , ResolveInfo $ info ) { $ fieldName = $ info -> fieldName ; $ property = null ; if ( is_array ( $ source ) || $ source instanceof ArrayAccess ) { if ( isset ( $ source [ $ fieldName ] ) ) { $ property = $ source [ $ fieldName ] ; } } elseif ( is_object ( $ source ) ) { if ( isset ( $ source -> { $ fieldName } ) ) { $ property = $ source -> { $ fieldName } ; } } return $ property instanceof Closure ? $ property ( $ source , $ args , $ context , $ info ) : $ property ; }
5989	public function setProperties ( array $ properties ) { $ this -> properties = [ ] ; foreach ( $ properties as $ item ) { $ this -> addPropertyCriteria ( $ item ) ; } return $ this ; }
12549	public function boot ( ) { $ pluginFolders = $ this -> configurationHandler -> pluginFolders ( ) ; $ this -> core = $ this -> findPlugins ( $ this -> configurationHandler -> corePluginsDir ( ) . "/Core" ) ; foreach ( $ pluginFolders as $ pluginFolder ) { $ this -> blocks += $ this -> findPlugins ( $ pluginFolder . "/Block" ) ; $ this -> themes += $ this -> findPlugins ( $ pluginFolder . "/Theme" ) ; } return $ this ; }
10907	public static function get ( array $ server ) : array { $ params = [ ] ; if ( isset ( $ server [ 'QUERY_STRING' ] ) ) { $ query = ltrim ( $ server [ 'QUERY_STRING' ] , '?' ) ; foreach ( explode ( '&' , $ query ) as $ pair ) { if ( $ pair ) { list ( $ name , $ value ) = self :: normalize ( array_map ( 'urldecode' , explode ( '=' , $ pair , 2 ) ) ) ; $ params [ $ name ] [ ] = $ value ; } } } return $ params ? array_map ( function ( $ v ) { return count ( $ v ) === 1 ? $ v [ 0 ] : $ v ; } , $ params ) : $ params ; }
12768	public function get ( string $ key = '' ) { if ( empty ( $ key ) ) { return $ this -> store ; } else { return $ this -> store [ $ key ] ?? null ; } }
12640	public function init ( $ adapter , $ client = null ) { $ this -> adapter = $ adapter ; if ( ! $ client ) { $ client = new \ PeterColes \ Cluster \ HttpClients \ GuzzleHttp ; } $ client -> initClient ( $ this -> adapter -> getHeaders ( ) ) ; $ this -> adapter -> setClient ( $ client ) ; }
3970	protected function attributeIdToName ( IMetaModel $ metaModel , $ attributeId ) { if ( null === $ attribute = $ metaModel -> getAttributeById ( $ attributeId ) ) { throw new \ RuntimeException ( sprintf ( 'Could not retrieve attribute %s from MetaModel %s.' , $ attributeId , $ metaModel -> getTableName ( ) ) ) ; } return $ attribute -> getColName ( ) ; }
1686	public function updateCurrentUser ( Contao \ DataContainer $ dc ) { if ( $ this -> User -> id == $ dc -> id ) { $ this -> User -> findBy ( 'id' , $ this -> User -> id ) ; } }
8124	protected function findRecord ( $ data ) { if ( empty ( $ data [ "ID" ] ) ) { throw new HTTPResponse_Exception ( "No record ID" , 404 ) ; } $ page = null ; $ id = $ data [ "ID" ] ; if ( is_numeric ( $ id ) ) { $ page = SiteTree :: get ( ) -> byID ( $ id ) ; } if ( ! $ page || ! $ page -> ID ) { throw new HTTPResponse_Exception ( "Bad record ID #{$id}" , 404 ) ; } return $ page ; }
6241	protected function normalizePathComponents ( ) : array { $ components = [ ] ; $ keys = array_keys ( $ this -> components ) ; $ positionStart = reset ( $ keys ) ; $ positionEnd = end ( $ keys ) ; foreach ( $ this -> components as $ position => $ component ) { $ path = self :: normalize ( $ component , $ position === $ positionStart , $ position === $ positionEnd ) ; $ path = str_replace ( [ '/' , '\\' , DIRECTORY_SEPARATOR . DIRECTORY_SEPARATOR ] , DIRECTORY_SEPARATOR , $ path ) ; if ( $ position === $ positionStart && $ path === DIRECTORY_SEPARATOR ) { $ components [ ] = DIRECTORY_SEPARATOR ; } elseif ( $ position === $ positionStart ) { $ components [ ] = rtrim ( $ path , DIRECTORY_SEPARATOR ) ; } else { $ components [ ] = trim ( $ path , DIRECTORY_SEPARATOR ) ; } } return $ components ; }
12471	protected function setDatabaseFactoryNamespaces ( ) { $ this -> replaceIn ( $ this -> laravel -> databasePath ( ) . '/factories/ModelFactory.php' , $ this -> currentRoot , $ this -> argument ( 'name' ) ) ; }
5	private function buildDepPackageConstraints ( $ depItem , $ depType ) { if ( $ this -> isHash ( $ depItem ) ) { $ depItem = array ( $ depItem ) ; } $ result = array ( ) ; foreach ( $ depItem as $ subDepItem ) { if ( ! array_key_exists ( 'channel' , $ subDepItem ) ) { $ subDepItem [ 'channel' ] = $ subDepItem [ 'uri' ] ; } $ depChannelName = $ subDepItem [ 'channel' ] ; $ depPackageName = $ subDepItem [ 'name' ] ; $ depVersionConstraint = $ this -> parse20VersionConstraint ( $ subDepItem ) ; if ( isset ( $ subDepItem [ 'conflicts' ] ) ) { $ depType = 'conflicts' ; } $ result [ ] = new DependencyConstraint ( $ depType , $ depVersionConstraint , $ depChannelName , $ depPackageName ) ; } return $ result ; }
2235	public function onGeneratePage ( PageModel $ pageModel , LayoutModel $ layoutModel ) : void { $ calendarfeeds = StringUtil :: deserialize ( $ layoutModel -> calendarfeeds ) ; if ( empty ( $ calendarfeeds ) || ! \ is_array ( $ calendarfeeds ) ) { return ; } $ this -> framework -> initialize ( ) ; $ adapter = $ this -> framework -> getAdapter ( CalendarFeedModel :: class ) ; if ( ! ( $ feeds = $ adapter -> findByIds ( $ calendarfeeds ) ) instanceof Collection ) { return ; } $ template = $ this -> framework -> getAdapter ( Template :: class ) ; $ environment = $ this -> framework -> getAdapter ( Environment :: class ) ; foreach ( $ feeds as $ feed ) { $ GLOBALS [ 'TL_HEAD' ] [ ] = $ template -> generateFeedTag ( sprintf ( '%sshare/%s.xml' , ( $ feed -> feedBase ? : $ environment -> get ( 'base' ) ) , $ feed -> alias ) , $ feed -> format , $ feed -> title ) ; } }
622	public function with ( ) { $ with = func_get_args ( ) ; if ( isset ( $ with [ 0 ] ) && is_array ( $ with [ 0 ] ) ) { $ with = $ with [ 0 ] ; } if ( empty ( $ this -> with ) ) { $ this -> with = $ with ; } elseif ( ! empty ( $ with ) ) { foreach ( $ with as $ name => $ value ) { if ( is_int ( $ name ) ) { $ this -> with [ ] = $ value ; } else { $ this -> with [ $ name ] = $ value ; } } } return $ this ; }
10574	public function remove ( $ key ) { $ this -> open ( ) ; if ( isset ( $ _SESSION [ $ key ] ) ) { $ value = $ _SESSION [ $ key ] ; unset ( $ _SESSION [ $ key ] ) ; return $ value ; } else { return null ; } }
10795	public function contact ( array $ data , $ destination = null ) { $ authService = $ this -> getServiceLocator ( ) -> get ( 'ControllerPluginManager' ) -> get ( 'zfcUserAuthentication' ) ; if ( null === $ destination && ! $ authService -> hasIdentity ( ) ) { throw new \ Exception ( "Errore si sistema." ) ; } $ identity = $ authService -> getIdentity ( ) ; $ data [ 'email' ] = null !== $ destination ? $ destination : $ identity -> getEmail ( ) ; $ form = $ this -> getServiceLocator ( ) -> get ( 'user.form.contact' ) ; $ form -> setData ( $ data ) ; if ( ! $ form -> isValid ( ) ) { throw new \ Exception ( serialize ( $ form -> getMessages ( ) ) ) ; } $ url = $ this -> getServiceLocator ( ) -> get ( 'ControllerPluginManager' ) -> get ( 'Url' ) ; $ data = array_merge ( $ form -> getData ( ) , array ( 'siteurl' => $ url -> fromRoute ( 'home' , array ( ) , array ( 'force_canonical' => true ) ) ) ) ; $ event = new UserContactEvent ( __FUNCTION__ , null , $ data ) ; $ this -> getEventManager ( ) -> trigger ( __FUNCTION__ . '.pre' , $ this , $ event ) ; $ this -> getEventManager ( ) -> trigger ( __FUNCTION__ . '.post' , $ this , $ event ) ; }
4579	public function getStartForm ( $ id , Parameters $ parameters = null ) { if ( null !== $ id ) { $ resource = str_replace ( '{id}' , $ id , static :: RESOURCE_OBJECT_START_FORM ) ; } else { $ key = $ parameters -> getKey ( ) ; $ tenantId = $ parameters -> getTenantId ( ) ; switch ( true ) { case null !== $ key && null !== $ tenantId : $ resource = str_replace ( [ '{key}' , '{tenant-id}' ] , [ $ key , $ tenantId ] , static :: RESOURCE_OBJECT_START_FORM_BY_KEY_AND_TENANT_ID ) ; break ; case null !== $ key : $ resource = str_replace ( '{key}' , $ key , static :: RESOURCE_OBJECT_START_FORM_BY_KEY ) ; break ; default : throw new LogicException ( '"Key" and/or "TenantId" parameters are not defined.' ) ; } } $ options = [ 'headers' => [ 'Accept' => 'application/json' ] ] ; $ result = $ this -> execute ( 'GET' , $ resource , $ options ) ; return $ result -> key ; }
8999	public function fileExists ( $ fileName ) : bool { if ( ! $ this -> exists ( ) ) { return false ; } $ file = sprintf ( "%s/%s" , $ this -> path , $ fileName ) ; return file_exists ( $ file ) ; }
4116	public function getBlockPath ( Mage_Core_Block_Abstract $ block ) { $ blockPath = array ( ) ; $ step = $ block -> getParentBlock ( ) ; $ i = 0 ; while ( $ i ++ < 20 && $ step instanceof Mage_Core_Block_Abstract ) { $ blockPath [ ] = $ this -> getBlockInfo ( $ step , false ) ; $ step = $ step -> getParentBlock ( ) ; } return $ blockPath ; }
12097	public function checkSignCode ( array $ params , $ secret ) { if ( false === isset ( $ params [ self :: SIGN_NAMESPACE ] ) ) { return false ; } return $ params [ self :: SIGN_NAMESPACE ] === $ this -> generateSignCode ( $ params , $ secret ) ; }
8373	protected function configure ( ) { $ this -> setName ( 'worker/process' ) -> setHidden ( true ) -> setDescription ( 'Runs a given worker' ) -> setDefinition ( new InputDefinition ( [ new InputOption ( 'config' , 'c' , InputOption :: VALUE_REQUIRED , 'A YAML configuration file' ) , new InputOption ( 'jobId' , null , InputOption :: VALUE_REQUIRED , 'A Job UUID' ) , new InputOption ( 'name' , null , InputOption :: VALUE_REQUIRED , 'The queue name to work with. Defaults to `default`.' ) , ] ) ) ; }
10543	public function setConfig ( Dictionary $ config ) { $ this -> config = $ config ; $ this -> configureSites ( ) ; $ this -> setVariable ( 'config' , $ config ) ; return $ this ; }
1927	public function isSemitransparent ( ) { if ( ! imageistruecolor ( $ this -> gdResource ) ) { return false ; } $ width = imagesx ( $ this -> gdResource ) ; $ height = imagesy ( $ this -> gdResource ) ; for ( $ x = 0 ; $ x < $ width ; $ x ++ ) { for ( $ y = 0 ; $ y < $ height ; $ y ++ ) { $ alpha = ( imagecolorat ( $ this -> gdResource , $ x , $ y ) >> 24 ) & 0x7F ; if ( $ alpha > 0 && $ alpha < 127 ) { return true ; } } } return false ; }
6178	private function keySort ( $ a , $ b , $ c = null ) { $ d = $ c !== null ? $ c : 1 ; if ( $ a == $ b ) { return 0 ; } return ( $ a > $ b ) ? 1 * $ d : - 1 * $ d ; }
10642	public function orWhere ( $ column , $ op , $ value , $ isParam = true ) { $ this -> clauses [ ] = array ( "OR" , $ column , $ op , $ value , $ isParam ) ; return $ this ; }
8562	public function createShipment ( $ request ) { if ( ! ( $ request instanceof MWSMerchantFulfillmentService_Model_CreateShipmentRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/CreateShipmentRequest.php' ) ; $ request = new MWSMerchantFulfillmentService_Model_CreateShipmentRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'CreateShipment' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/CreateShipmentResponse.php' ) ; $ response = MWSMerchantFulfillmentService_Model_CreateShipmentResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
146	protected function moveWatch ( $ fromLiteral , $ toLiteral , $ node ) { if ( ! isset ( $ this -> watchChains [ $ toLiteral ] ) ) { $ this -> watchChains [ $ toLiteral ] = new RuleWatchChain ; } $ node -> moveWatch ( $ fromLiteral , $ toLiteral ) ; $ this -> watchChains [ $ fromLiteral ] -> remove ( ) ; $ this -> watchChains [ $ toLiteral ] -> unshift ( $ node ) ; }
1377	protected function validateIdMember ( $ value , string $ path ) : bool { if ( ! is_string ( $ value ) ) { $ this -> memberNotString ( $ path , 'id' ) ; return false ; } if ( empty ( $ value ) ) { $ this -> memberEmpty ( $ path , 'id' ) ; return false ; } return true ; }
3762	private function getConditionChain ( LegendInterface $ legend , $ propertyName , array & $ conditions ) { if ( isset ( $ conditions [ $ legend -> getName ( ) ] [ $ propertyName ] ) ) { return $ conditions [ $ legend -> getName ( ) ] [ $ propertyName ] ; } $ property = $ this -> getLegendProperty ( $ legend , $ propertyName ) ; $ condition = $ this -> getVisibleCondition ( $ property ) ; $ orCondition = new PropertyConditionChain ( ) ; $ orCondition -> setConjunction ( PropertyConditionChain :: OR_CONJUNCTION ) ; $ conditions [ $ legend -> getName ( ) ] [ $ propertyName ] = $ orCondition ; $ condition -> addCondition ( $ orCondition ) ; return $ orCondition ; }
12003	public function getSessionKey ( $ jsCode ) { $ params = [ 'appid' => $ this -> config [ 'app_id' ] , 'secret' => $ this -> config [ 'secret' ] , 'js_code' => $ jsCode , 'grant_type' => 'authorization_code' , ] ; return $ this -> parseJSON ( 'GET' , [ self :: JSCODE_TO_SESSION , $ params ] ) ; }
2594	protected function loadCurrencyOverride ( $ currency ) { if ( is_string ( $ currency ) && strlen ( $ currency ) === 3 ) { $ this -> addPriceType ( PricingTicketing :: PRICETYPE_OVERRIDE_CURRENCY_CONVERSION ) ; $ this -> conversionRate = new ConversionRate ( $ currency ) ; } }
2966	public function createRequest ( $ method , $ path , $ options ) { if ( $ this -> isPsr7Version ( ) ) { $ headers = [ 'Content-Type' => 'application/json' , 'Authorization' => 'Bearer ' . $ this -> getAccessToken ( ) , ] ; $ body = ArrayUtils :: get ( $ options , 'body' , null ) ; $ uri = UriResolver :: resolve ( new Uri ( $ this -> getBaseEndpoint ( ) . '/' ) , new Uri ( $ path ) ) ; if ( $ body ) { $ body = json_encode ( $ body ) ; } if ( ArrayUtils :: has ( $ options , 'query' ) ) { $ query = $ options [ 'query' ] ; if ( is_array ( $ query ) ) { $ query = http_build_query ( $ query , null , '&' , PHP_QUERY_RFC3986 ) ; } if ( ! is_string ( $ query ) ) { throw new \ InvalidArgumentException ( 'query must be a string or array' ) ; } $ uri = $ uri -> withQuery ( $ query ) ; } $ request = new Request ( $ method , $ uri , $ headers , $ body ) ; } else { $ options [ 'auth' ] = [ $ this -> accessToken , '' ] ; $ request = $ this -> httpClient -> createRequest ( $ method , $ path , $ options ) ; $ query = ArrayUtils :: get ( $ options , 'query' ) ; if ( $ query ) { $ q = $ request -> getQuery ( ) ; foreach ( $ query as $ key => $ value ) { $ q -> set ( $ key , $ value ) ; } } } return $ request ; }
5873	public static function isTransparentPng ( $ fileName ) { $ bytes = file_get_contents ( $ fileName , false , null , 24 , 2 ) ; $ byte24 = ord ( $ bytes { 0 } ) ; $ byte25 = ord ( $ bytes { 1 } ) ; if ( $ byte24 === 16 || $ byte25 === 6 || $ byte25 === 4 ) { return true ; } else { $ content = file_get_contents ( $ fileName ) ; return strpos ( $ content , 'tRNS' ) !== false ; } }
12054	public function remove ( $ name ) { if ( isset ( $ this -> container [ $ name ] ) ) { unset ( $ this -> container [ $ name ] ) ; } return $ this ; }
11712	protected function performAjaxValidation ( $ models ) { if ( \ Yii :: $ app -> request -> isAjax ) { if ( is_array ( $ models ) ) { $ result = [ ] ; foreach ( $ models as $ model ) { if ( $ model -> load ( \ Yii :: $ app -> request -> post ( ) ) ) { \ Yii :: $ app -> response -> format = Response :: FORMAT_JSON ; $ result = array_merge ( $ result , ActiveForm :: validate ( $ model ) ) ; } } echo json_encode ( $ result ) ; \ Yii :: $ app -> end ( ) ; } else { if ( $ models -> load ( \ Yii :: $ app -> request -> post ( ) ) ) { \ Yii :: $ app -> response -> format = Response :: FORMAT_JSON ; echo json_encode ( ActiveForm :: validate ( $ models ) ) ; \ Yii :: $ app -> end ( ) ; } } } }
10575	public static function apply ( $ text , $ foreground = '' , $ background = '' ) { try { $ style = new OutputFormatterStyle ( ) ; if ( $ foreground != '' ) { $ style -> setForeground ( $ foreground ) ; } if ( $ background != '' ) { $ style -> setBackground ( $ background ) ; } return $ style -> apply ( $ text ) ; } catch ( \ Exception $ e ) { return $ text ; } }
7635	public function getBlockList ( $ containerName = '' , $ blobName = '' , $ snapshotId = null , $ leaseId = null , $ type = 0 ) { Assertion :: notEmpty ( $ containerName , 'Container name is not specified' ) ; self :: assertValidContainerName ( $ containerName ) ; Assertion :: notEmpty ( $ blobName , 'Blob name is not specified.' ) ; if ( $ type < 0 || $ type > 2 ) { throw new BlobException ( 'Invalid type of block list to retrieve.' ) ; } $ blockListType = 'all' ; if ( $ type == 1 ) { $ blockListType = 'committed' ; } if ( $ type == 2 ) { $ blockListType = 'uncommitted' ; } $ headers = array ( ) ; if ( ! is_null ( $ leaseId ) ) { $ headers [ 'x-ms-lease-id' ] = $ leaseId ; } $ query = array ( 'comp' => 'blocklist' , 'blocklisttype' => $ blockListType ) ; if ( ! is_null ( $ snapshotId ) ) { $ query [ 'snapshot' ] = $ snapshotId ; } $ resourceName = self :: createResourceName ( $ containerName , $ blobName ) ; $ response = $ this -> performRequest ( $ resourceName , $ query , 'GET' , $ headers , false , null , self :: RESOURCE_BLOB , self :: PERMISSION_READ ) ; if ( ! $ response -> isSuccessful ( ) ) { throw new BlobException ( $ this -> getErrorMessage ( $ response , 'Resource could not be accessed.' ) ) ; } $ blockList = $ this -> parseResponse ( $ response ) ; $ returnValue = array ( ) ; if ( $ blockList -> CommittedBlocks ) { foreach ( $ blockList -> CommittedBlocks -> Block as $ block ) { $ returnValue [ 'CommittedBlocks' ] [ ] = ( object ) array ( 'Name' => ( string ) $ block -> Name , 'Size' => ( string ) $ block -> Size ) ; } } if ( $ blockList -> UncommittedBlocks ) { foreach ( $ blockList -> UncommittedBlocks -> Block as $ block ) { $ returnValue [ 'UncommittedBlocks' ] [ ] = ( object ) array ( 'Name' => ( string ) $ block -> Name , 'Size' => ( string ) $ block -> Size ) ; } } return $ returnValue ; }
2121	public static function getActive ( ) { @ trigger_error ( 'Using ModuleLoader::getActive() has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; $ bundles = array_keys ( System :: getContainer ( ) -> getParameter ( 'kernel.bundles' ) ) ; foreach ( static :: $ legacy as $ bundleName => $ module ) { if ( \ in_array ( $ bundleName , $ bundles ) ) { $ bundles [ ] = $ module ; } } return $ bundles ; }
9943	public function setCellValueExplicit ( $ pCoordinate , $ pValue , $ pDataType ) { $ this -> getCell ( $ pCoordinate ) -> setValueExplicit ( $ pValue , $ pDataType ) ; return $ this ; }
1747	public function getCalendars ( ) { if ( ! $ this -> User -> isAdmin && ! \ is_array ( $ this -> User -> calendars ) ) { return array ( ) ; } $ arrCalendars = array ( ) ; $ objCalendars = $ this -> Database -> execute ( "SELECT id, title FROM tl_calendar ORDER BY title" ) ; while ( $ objCalendars -> next ( ) ) { if ( $ this -> User -> hasAccess ( $ objCalendars -> id , 'calendars' ) ) { $ arrCalendars [ $ objCalendars -> id ] = $ objCalendars -> title ; } } return $ arrCalendars ; }
5938	public function addFunctionality ( $ item ) { if ( ! ( $ item instanceof Functionality ) ) { if ( is_array ( $ item ) ) { try { $ item = new Functionality ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate Functionality. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "Functionality"!' , E_USER_WARNING ) ; } } $ this -> functionalities [ ] = $ item ; return $ this ; }
3829	protected function buildFilterUrl ( $ fragments , $ searchKey ) { @ trigger_error ( sprintf ( '"%1$s" has been deprecated in favor of the "FilterUrlBuilder"' , __METHOD__ ) , E_USER_DEPRECATED ) ; $ url = '' ; $ found = false ; foreach ( $ fragments as $ key => $ value ) { if ( ( $ key == 'language' ) && $ GLOBALS [ 'TL_CONFIG' ] [ 'addLanguageToUrl' ] ) { continue ; } if ( $ key == $ searchKey ) { if ( $ key !== 'auto_item' ) { $ url .= '%s' ; } else { $ url = '%s' . $ url ; } $ found = true ; } else { $ url = $ this -> addUrlParameter ( $ url , $ key , $ value ) ; } } if ( ! $ found ) { if ( $ searchKey !== 'auto_item' ) { $ url .= '%s' ; } else { $ url = '%s' . $ url ; } } return $ url ; }
5714	protected function filterFieldList ( Form $ form , FieldList $ actions ) { $ list = FieldList :: create ( ) ; foreach ( $ actions as $ a ) { if ( ! $ a instanceof BetterButtonInterface ) { throw new Exception ( "{$buttonObj->class} must implement BetterButtonInterface" ) ; } $ a -> bindGridField ( $ form , $ this -> owner ) ; if ( ! $ a -> shouldDisplay ( ) ) { continue ; } if ( ( $ a instanceof BetterButton_Versioned ) && ! $ this -> owner -> record -> checkVersioned ( ) ) { continue ; } $ list -> push ( $ a ) ; } return $ list ; }
10438	public function offsetSet ( $ attributeName , $ attribute ) { if ( ! is_string ( $ attributeName ) || ! is_string ( $ attribute ) ) { throw new ValueException ( $ attribute , 'string' ) ; } $ this -> attributes [ $ attributeName ] = $ attribute ; }
10826	public static function table ( array $ rows , array $ headers = [ ] ) { $ table = new Table ( ) ; $ table -> setRows ( $ rows ) ; if ( count ( $ headers ) > 0 ) { $ table -> setHeaders ( $ headers ) ; } $ output = $ table -> render ( ) ; self :: writeln ( $ output ) ; }
12371	public function addItem ( array $ item ) : self { if ( count ( $ item ) < 2 ) { throw new Exception ( 'Invalid count of item elements.' ) ; } $ this -> items [ ] = $ item ; return $ this ; }
5708	public function transformToButton ( ) { parent :: transformToButton ( ) ; if ( $ this -> gridFieldRequest -> recordIsPublished ( ) ) { $ this -> setTitle ( _t ( 'SiteTree.BUTTONPUBLISHED' , 'Published' ) ) ; } if ( $ this -> gridFieldRequest -> record -> stagesDiffer ( 'Stage' , 'Live' ) && $ this -> gridFieldRequest -> recordIsDeletedFromStage ( ) ) { $ this -> addExtraClass ( 'ss-ui-alternate' ) ; } return $ this ; }
11685	public function getCachePath ( ) { if ( empty ( $ this -> basePath ) ) { return false ; } $ cachePath = $ this -> basePath . DIRECTORY_SEPARATOR . 'cache' ; if ( ! is_dir ( $ cachePath ) ) { @ mkdir ( $ cachePath , 0777 , true ) ; } if ( ! is_dir ( $ cachePath ) ) { return false ; } return $ cachePath ; }
5130	protected function withString ( string $ string , string $ name = 'query' ) : self { $ string = ltrim ( ( string ) $ string , '#' ) ; $ clone = clone $ this ; $ clone -> { $ name } = $ this -> filterQuery ( $ string ) ; return $ clone ; }
9393	public function withStatus ( $ code , $ reason = '' ) { $ static = clone $ this ; $ static -> code = $ code ; $ static -> reason = $ reason ? : $ static -> codes [ $ code ] ; return $ static ; }
12045	public function destroy ( UserPolicy $ user , Question $ question ) { return $ question -> user_id == user_id ( ) && $ question -> user_type == user_type ( ) ; }
7603	public function render ( ElementInterface $ oElement ) { $ sElementType = $ oElement -> getAttribute ( 'type' ) ; if ( ! in_array ( $ sElementType , $ this -> options -> getIgnoredViewHelpers ( ) ) && ! ( $ oElement instanceof Collection ) ) { if ( $ sElementClass = $ oElement -> getAttribute ( 'class' ) ) { if ( ! preg_match ( '/(\s|^)form-control(\s|$)/' , $ sElementClass ) ) { $ oElement -> setAttribute ( 'class' , trim ( $ sElementClass . ' form-control' ) ) ; } } else { $ oElement -> setAttribute ( 'class' , 'form-control' ) ; } } $ sMarkup = parent :: render ( $ oElement ) ; if ( $ aAddOnPrepend = $ oElement -> getOption ( 'add-on-prepend' ) ) { $ sMarkup = $ this -> renderAddOn ( $ aAddOnPrepend ) . $ sMarkup ; } if ( $ aAddOnAppend = $ oElement -> getOption ( 'add-on-append' ) ) { $ sMarkup .= $ this -> renderAddOn ( $ aAddOnAppend ) ; } if ( $ aAddOnAppend || $ aAddOnPrepend ) { $ sSpecialClass = '' ; if ( $ sElementClass = $ oElement -> getAttribute ( 'class' ) ) { if ( preg_match ( '/(\s|^)input-lg(\s|$)/' , $ sElementClass ) ) { $ sSpecialClass .= ' input-group-lg' ; } elseif ( preg_match ( '/(\s|^)input-sm(\s|$)/' , $ sElementClass ) ) { $ sSpecialClass .= ' input-group-sm' ; } } return sprintf ( static :: $ inputGroupFormat , trim ( $ sSpecialClass ) , $ sMarkup ) ; } return $ sMarkup ; }
4656	public function create ( Job $ job ) { $ context = new Context ( $ this -> buildPath . DIRECTORY_SEPARATOR . $ job -> getDirectory ( ) ) ; $ buildStream = $ this -> docker -> getImageManager ( ) -> build ( $ context -> toStream ( ) , [ 't' => $ job -> getName ( ) , 'q' => $ this -> quietBuild , 'nocache' => ! $ this -> usecache ] , ImageManager :: FETCH_STREAM ) ; $ buildStream -> onFrame ( $ this -> logger -> getBuildCallback ( ) ) ; $ buildStream -> wait ( ) ; try { return $ this -> docker -> getImageManager ( ) -> find ( $ job -> getName ( ) ) ; } catch ( ClientErrorException $ e ) { if ( $ e -> getResponse ( ) -> getStatusCode ( ) == 404 ) { return false ; } throw $ e ; } }
173	private static function firstWildcardInPattern ( $ pattern ) { $ wildcards = [ '*' , '?' , '[' , '\\' ] ; $ wildcardSearch = function ( $ r , $ c ) use ( $ pattern ) { $ p = strpos ( $ pattern , $ c ) ; return $ r === false ? $ p : ( $ p === false ? $ r : min ( $ r , $ p ) ) ; } ; return array_reduce ( $ wildcards , $ wildcardSearch , false ) ; }
8573	public function listRecommendationsByNextToken ( $ request ) { if ( ! ( $ request instanceof MWSRecommendationsSectionService_Model_ListRecommendationsByNextTokenRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/ListRecommendationsByNextTokenRequest.php' ) ; $ request = new MWSRecommendationsSectionService_Model_ListRecommendationsByNextTokenRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListRecommendationsByNextToken' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/ListRecommendationsByNextTokenResponse.php' ) ; $ response = MWSRecommendationsSectionService_Model_ListRecommendationsByNextTokenResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
12287	public function insetIf ( bool $ condition , string $ block , array $ vars = null ) : string { return $ condition ? trim ( $ this -> make ( $ block , $ vars ) ) . PHP_EOL : PHP_EOL ; }
12682	private function registerProfilerConfiguration ( array $ config , XmlFileLoader $ loader ) { if ( $ config [ 'enabled' ] && $ config [ 'collect' ] && class_exists ( 'Symfony\Component\Debug\Debug' ) ) { $ loader -> load ( 'block_debug.xml' ) ; $ loader -> load ( 'collectors.xml' ) ; } }
1683	public function getModules ( ) { $ arrModules = array ( ) ; foreach ( $ GLOBALS [ 'BE_MOD' ] as $ k => $ v ) { if ( ! empty ( $ v ) ) { if ( $ k == 'accounts' ) { unset ( $ v [ 'login' ] ) ; } if ( $ k == 'system' ) { unset ( $ v [ 'undo' ] ) ; } $ arrModules [ $ k ] = array_keys ( $ v ) ; } } return $ arrModules ; }
6428	protected function getFacebookObject ( ) { if ( is_object ( $ this -> fb ) ) { return $ this -> fb ; } $ fb = new \ Facebook \ Facebook ( [ 'app_id' => $ this -> options [ 'api_key' ] , 'app_secret' => $ this -> options [ 'secret_key' ] , 'default_graph_version' => 'v3.0' , ] ) ; $ this -> fb = $ fb ; return $ fb ; }
8282	public function onPageRendering ( & $ templateName , array & $ twigVariables ) { $ twigVariables [ 'auth' ] [ 'plugin' ] = $ this ; $ twigVariables [ 'auth' ] [ 'vars' ] = $ this -> output ; if ( ! $ this -> errorOccurred ) { $ twigVariables [ 'auth' ] [ 'user' ] = $ this -> user ; $ old = $ this -> session -> getFlash ( 'old' ) ; if ( count ( $ old ) && isset ( $ old [ 0 ] ) ) { $ twigVariables [ 'auth' ] [ 'old' ] = $ old [ 0 ] ; } } }
12865	public function clearQuota ( ) { $ appid = $ this -> getAccessToken ( ) -> getAppId ( ) ; return $ this -> parseJSON ( 'json' , [ self :: API_CLEAR_QUOTA , compact ( 'appid' ) ] ) ; }
12206	public function createPagination ( $ currentPage , $ total , $ perPage = null , $ baseUrl = null , $ neighbours = null ) { if ( isset ( $ this -> container ) && $ this -> container instanceof \ League \ Container \ ContainerInterface ) { return $ this -> getContainer ( ) -> get ( 'Laasti\Pagination\Pagination' , [ $ currentPage , $ total , $ perPage , $ baseUrl , $ neighbours ] ) ; } $ perPage = $ perPage ? : 10 ; $ baseUrl = $ baseUrl ? : '' ; $ neighbours = $ neighbours ? : 3 ; return new Pagination ( $ currentPage , $ total , $ perPage , $ baseUrl , $ neighbours ) ; }
5509	public function expect ( $ method , $ args , $ message = '%s' ) { $ this -> dieOnNoMethod ( $ method , 'set expected arguments' ) ; $ this -> checkArgumentsIsArray ( $ args , 'set expected arguments' ) ; $ this -> expectations -> expectArguments ( $ method , $ args , $ message ) ; $ args = $ this -> replaceWildcards ( $ args ) ; $ message .= Mock :: getExpectationLine ( ) ; $ this -> expected_args [ strtolower ( $ method ) ] = new ParametersExpectation ( $ args , $ message ) ; }
4414	public function onKernelRequest ( GetResponseEvent $ event ) { if ( ! $ event -> isMasterRequest ( ) ) { return ; } if ( ! $ this -> isAdminSiteAccess ) { return ; } $ currentRoute = $ event -> getRequest ( ) -> attributes -> get ( '_route' ) ; if ( mb_stripos ( $ currentRoute , 'netgen_information_collection' ) !== 0 ) { return ; } $ this -> globalVariable -> setPageLayoutTemplate ( $ this -> pageLayoutTemplate ) ; }
5905	public function retrieveRole ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/accounts/roles/' . $ id . '' , $ parameters , $ cachePolicy ) ; $ result = new Role ( $ result ) ; return $ result ; }
11128	protected function getClassName ( $ fileName ) { $ namePiece = @ explode ( $ this -> config [ 'modelsPrefix' ] , $ fileName ) ; $ name = isset ( $ namePiece [ 1 ] ) ? $ namePiece [ 1 ] : $ fileName ; $ namePiece = @ explode ( $ this -> config [ 'modelsPostfix' ] , $ name ) ; $ name = isset ( $ namePiece [ 1 ] ) ? $ namePiece [ 0 ] : $ name ; $ namePiece = explode ( '.php' , $ name ) ; $ name = isset ( $ namePiece [ 1 ] ) ? $ namePiece [ 0 ] : $ name ; return $ name ; }
435	public function beforeAction ( $ action ) { $ event = new ActionEvent ( $ action ) ; $ this -> trigger ( self :: EVENT_BEFORE_ACTION , $ event ) ; return $ event -> isValid ; }
10880	public function renderPreviousExceptions ( $ exception ) { if ( ( $ previous = $ exception -> getPrevious ( ) ) !== null ) { return $ this -> renderFile ( $ this -> previousExceptionView , [ 'exception' => $ previous ] ) ; } else { return '' ; } }
11991	private function validateSlug ( string $ sku ) { if ( strlen ( $ sku ) == 0 ) { throw new SlugException ( "A Slug cannot be empty" ) ; } $ containsWhitespace = preg_match ( $ this -> whiteSpacePattern , $ sku ) == 1 ; if ( $ containsWhitespace ) { throw new SlugException ( sprintf ( "A Slug cannot contain white space characters: \"%s\"" , $ sku ) ) ; } $ containsInvalidCharacters = preg_match ( $ this -> invalidCharactersPattern , $ sku ) == 1 ; if ( $ containsInvalidCharacters ) { throw new SlugException ( sprintf ( "The Slug \"%s\" contains invalid characters. A Slug can only contain the following characters: a-z, 0-9 and -" , $ sku ) ) ; } if ( strlen ( $ sku ) < $ this -> minLength ) { throw new SlugException ( sprintf ( "The given Slug \"%s\" is too short. The minimum length for a Slug is: %s" , $ sku , $ this -> minLength ) ) ; } if ( strlen ( $ sku ) > $ this -> maxLength ) { throw new SlugException ( sprintf ( "The given Slug \"%s\" is too long (%s character). The maximum length for a Slug is: %s" , strlen ( $ sku ) , $ sku , $ this -> maxLength ) ) ; } }
7544	function getNextSibling ( $ skip_text_comments = true ) { $ offset = 1 ; while ( ( $ n = $ this -> getSibling ( $ offset ) ) !== null ) { if ( $ skip_text_comments && ( $ n -> tag [ 0 ] === '~' ) ) { ++ $ offset ; } else { break ; } } return $ n ; }
12063	public function can_save_post_meta ( $ post_id , $ action , $ nonce ) { $ is_autosave = wp_is_post_autosave ( $ post_id ) ; $ is_revision = wp_is_post_revision ( $ post_id ) ; $ is_valid_nonce = ( isset ( $ _POST [ $ nonce ] ) && wp_verify_nonce ( $ _POST [ $ nonce ] , $ action ) ) ; return ! ( $ is_autosave || $ is_revision ) && $ is_valid_nonce ; }
11289	protected function _getModel ( $ attributeName , $ relatedObjName = false , $ query = false , $ loadMap = false , $ record = false ) { $ def = $ this -> model_attributes [ $ attributeName ] ; $ result = null ; if ( $ relatedObjName ) { if ( $ loadMap instanceof \ Cora \ Adm \ LoadMap && ! $ loadMap -> fetchData ( ) && $ record !== false ) { $ relatedObj = $ this -> fetchRelatedObj ( $ def [ 'model' ] ) ; $ result = $ relatedObj -> _populate ( $ record , $ query , $ loadMap ) ; } else if ( isset ( $ def [ 'via' ] ) ) { $ result = $ this -> _getModelFromTableColumn ( $ attributeName , $ def [ 'model' ] , $ def [ 'via' ] , $ query , $ loadMap ) ; } else if ( isset ( $ def [ 'using' ] ) ) { $ result = $ this -> getModelFromCustomRelationship ( $ attributeName , $ def [ 'model' ] , $ query , $ loadMap ) ; } else if ( isset ( $ def [ 'usesRefTable' ] ) ) { $ result = $ this -> _getModelFromRelationTable ( $ attributeName , $ def [ 'model' ] , $ query , $ loadMap ) ; } else { $ relatedObj = $ this -> fetchRelatedObj ( $ def [ 'model' ] ) ; if ( $ query && $ query -> isCustom ( ) ) { $ data = $ query -> fetch ( ) ; $ result = $ relatedObj -> _populate ( $ data ) ; } else { if ( ! isset ( $ this -> model_data [ $ attributeName ] ) ) { $ this -> model_data [ $ attributeName ] = $ this -> _fetchData ( $ attributeName ) ; } if ( ! is_object ( $ this -> model_data [ $ attributeName ] ) ) { $ relObjRepo = $ relatedObj -> getRepository ( true ) ; $ result = $ relObjRepo -> find ( $ this -> model_data [ $ attributeName ] ) ; } else { $ result = $ this -> model_data [ $ attributeName ] ; } if ( $ result ) { $ result -> _populate ( [ ] , false , $ loadMap ) ; } } } } return $ result ; }
10378	protected static function get_routes_to_folder ( $ type ) { $ url = isset ( self :: $ unify [ "{$type}s" ] ) ? self :: $ unify [ "{$type}s" ] : self :: $ unify ; return [ 'url' => $ url , 'path' => self :: get_path_from_url ( $ url ) , ] ; }
362	protected function getClientOptions ( ) { $ filterUrl = isset ( $ this -> filterUrl ) ? $ this -> filterUrl : Yii :: $ app -> request -> url ; $ id = $ this -> filterRowOptions [ 'id' ] ; $ filterSelector = "#$id input, #$id select" ; if ( isset ( $ this -> filterSelector ) ) { $ filterSelector .= ', ' . $ this -> filterSelector ; } return [ 'filterUrl' => Url :: to ( $ filterUrl ) , 'filterSelector' => $ filterSelector , ] ; }
4662	public function sendNow ( ) { $ config = $ this -> getManager ( ) -> getDI ( ) -> getConfig ( ) ; $ message = $ this -> getMessage ( ) ; $ username = $ config -> email -> username ; $ password = $ config -> email -> password ; $ host = $ config -> email -> host ; $ port = $ config -> email -> port ; $ transport = \ Swift_SmtpTransport :: newInstance ( $ host , $ port ) ; $ transport -> setUsername ( $ username ) ; $ transport -> setPassword ( $ password ) ; $ swift = \ Swift_Mailer :: newInstance ( $ transport ) ; $ failures = [ ] ; $ swift -> send ( $ message , $ failures ) ; }
2544	protected function analyzeWithErrCodeCategoryMsgNodeName ( SendResult $ response , $ nodeErr , $ nodeCat , $ nodeMsg ) { $ analyzeResponse = new Result ( $ response ) ; $ domDoc = $ this -> loadDomDocument ( $ response -> responseXml ) ; $ errorCodeNode = $ domDoc -> getElementsByTagName ( $ nodeErr ) -> item ( 0 ) ; if ( ! is_null ( $ errorCodeNode ) ) { $ errorCatNode = $ domDoc -> getElementsByTagName ( $ nodeCat ) -> item ( 0 ) ; if ( $ errorCatNode instanceof \ DOMNode ) { $ analyzeResponse -> status = $ this -> makeStatusFromErrorQualifier ( $ errorCatNode -> nodeValue ) ; } else { $ analyzeResponse -> status = Result :: STATUS_ERROR ; } $ errorCode = $ errorCodeNode -> nodeValue ; $ errorTextNodeList = $ domDoc -> getElementsByTagName ( $ nodeMsg ) ; $ analyzeResponse -> messages [ ] = new Result \ NotOk ( $ errorCode , $ this -> makeMessageFromMessagesNodeList ( $ errorTextNodeList ) ) ; } return $ analyzeResponse ; }
8308	public function assertArrayOfStrings ( $ config , $ key ) { if ( ! array_key_exists ( $ key , $ config ) ) { return $ this ; } if ( ! is_array ( $ config [ $ key ] ) ) { throw new ConfigurationException ( $ key . " section must be an array." ) ; } foreach ( $ config [ $ key ] as $ value ) { if ( ! is_string ( $ value ) ) { throw new ConfigurationException ( "Values in the `{$key}` must be strings" . gettype ( $ value ) . " found." ) ; } elseif ( $ value === "" ) { throw new ConfigurationException ( "Empty string not allowed in `{$key}` array." ) ; } } return $ this ; }
8716	public static function createInLocale ( $ locale , array $ attributes = [ ] , $ translations = [ ] ) { $ model = ( new static ( $ attributes ) ) -> setLocale ( $ locale ) ; if ( $ model -> save ( ) && is_array ( $ translations ) ) { $ model -> saveTranslations ( $ translations ) ; } return $ model ; }
3547	public function boot ( ) { $ this -> loadViewsFrom ( realpath ( __DIR__ . '/../views' ) , 'entrust-gui' ) ; $ this -> setupRoutes ( $ this -> app -> router ) ; $ this -> loadTranslationsFrom ( realpath ( __DIR__ . '/../translations' ) , 'entrust-gui' ) ; $ this -> publishes ( [ __DIR__ . '/../config/entrust-gui.php' => config_path ( 'entrust-gui.php' ) ] , 'config' ) ; $ this -> publishes ( [ __DIR__ . '/../views' => base_path ( 'resources/views/vendor/entrust-gui' ) ] , 'views' ) ; $ this -> publishes ( [ __DIR__ . '/../translations' => base_path ( 'resources/lang/vendor/entrust-gui' ) ] , 'translations' ) ; $ this -> commands ( 'command.entrust-gui.models' ) ; }
12505	public static function commitTransaction ( $ connection ) { $ connection -> query = 'COMMIT' ; $ connection -> method = 'POST' ; $ connection -> action = '/_query' ; return self :: sendQuery ( $ connection ) ; }
11472	public function update ( ResponseRequest $ request , Response $ response ) { try { $ attributes = $ request -> all ( ) ; $ id = $ attributes [ 'question_id' ] ; $ question = $ this -> question -> selectquestion ( $ id ) ; $ response -> update ( $ attributes ) ; return redirect ( '/discussion/' . $ question [ 'slug' ] ) ; } catch ( Exception $ e ) { return $ this -> response -> message ( $ e -> getMessage ( ) ) -> code ( 400 ) -> status ( 'error' ) -> url ( guard_url ( 'forum/response/' . $ response -> getRouteKey ( ) ) ) -> redirect ( ) ; } }
229	public function getPdoType ( $ data ) { static $ typeMap = [ 'boolean' => \ PDO :: PARAM_BOOL , 'integer' => \ PDO :: PARAM_INT , 'string' => \ PDO :: PARAM_STR , 'resource' => \ PDO :: PARAM_LOB , 'NULL' => \ PDO :: PARAM_NULL , ] ; $ type = gettype ( $ data ) ; return isset ( $ typeMap [ $ type ] ) ? $ typeMap [ $ type ] : \ PDO :: PARAM_STR ; }
2689	private function fastlyResize ( ) { if ( $ this -> getWidth ( ) === null && $ this -> getHeight ( ) === null ) { return $ this ; } $ this -> adjustSize ( ) ; return $ this ; }
9566	public function addAfterHook ( $ hook ) { if ( ! isset ( $ this -> options [ 'after' ] ) ) { $ this -> options [ 'after' ] = [ ] ; } $ this -> options [ 'after' ] [ ] = $ hook ; }
8996	protected function buildNamespace ( ApiDefinition $ definition , $ namespace ) { if ( $ this -> config [ 'version_in_namespace' ] && $ definition -> getVersion ( ) ) { $ namespace .= '\\' . preg_replace ( array ( '/(^[0-9])/' , '/[^a-zA-Z0-9]/' ) , array ( 'Version\1' , '_' ) , $ definition -> getVersion ( ) ) ; } return $ namespace ; }
4430	protected function writeInstallerSummary ( $ errors ) { if ( ! $ errors ) { $ this -> writeSection ( 'You can now continue installation as per instructions in the README.md file!' ) ; return ; } $ this -> writeSection ( array ( 'The command was not able to install everything automatically.' , 'You must do the following changes manually.' , ) , 'error' ) ; $ this -> output -> writeln ( $ errors ) ; }
261	protected function typecastValue ( $ value , $ type ) { if ( is_scalar ( $ type ) ) { if ( is_object ( $ value ) && method_exists ( $ value , '__toString' ) ) { $ value = $ value -> __toString ( ) ; } switch ( $ type ) { case self :: TYPE_INTEGER : return ( int ) $ value ; case self :: TYPE_FLOAT : return ( float ) $ value ; case self :: TYPE_BOOLEAN : return ( bool ) $ value ; case self :: TYPE_STRING : if ( is_float ( $ value ) ) { return StringHelper :: floatToString ( $ value ) ; } return ( string ) $ value ; default : throw new InvalidArgumentException ( "Unsupported type '{$type}'" ) ; } } return call_user_func ( $ type , $ value ) ; }
2623	public function daysFromInstallation ( ) { $ stat = $ this -> statisticRepository -> getStatByAction ( self :: FASTLY_INSTALLED_FLAG ) ; if ( ! $ stat -> getCreatedAt ( ) ) { return null ; } $ installDate = date_create ( $ stat -> getCreatedAt ( ) ) ; $ currentDate = date_create ( $ this -> dateTime -> gmtDate ( ) ) ; $ dateDiff = date_diff ( $ installDate , $ currentDate ) ; return $ dateDiff -> days ; }
9651	public function duplicate ( $ doWrite = true ) { $ clonedNode = parent :: duplicate ( $ doWrite ) ; if ( $ this -> Options ( ) ) { foreach ( $ this -> Options ( ) as $ field ) { $ newField = $ field -> duplicate ( ) ; $ newField -> ParentID = $ clonedNode -> ID ; $ newField -> write ( ) ; } } return $ clonedNode ; }
4007	public function createMetaModel ( CreateMetaModelEvent $ event ) { if ( $ event -> getMetaModel ( ) !== null ) { return ; } if ( isset ( $ this -> instancesByTable [ $ event -> getMetaModelName ( ) ] ) ) { $ event -> setMetaModel ( $ this -> instancesByTable [ $ event -> getMetaModelName ( ) ] ) ; return ; } $ table = $ this -> database -> createQueryBuilder ( ) -> select ( '*' ) -> from ( 'tl_metamodel' ) -> where ( 'tableName=:tableName' ) -> setParameter ( 'tableName' , $ event -> getMetaModelName ( ) ) -> setMaxResults ( 1 ) -> execute ( ) -> fetch ( \ PDO :: FETCH_ASSOC ) ; if ( $ table ) { $ table [ 'system_columns' ] = $ this -> systemColumns ; $ this -> createInstance ( $ event , $ table ) ; } }
3354	public function copy ( $ target = null ) { Helper :: deprecate ( '2.0.0' , '3.0.0' , 'Use createLocalCopy() or createRemoteCopy() instead' ) ; return $ this -> api -> copyFile ( $ this -> getUrl ( ) , $ target ) ; }
9433	protected static function checkOrder ( $ float_min , $ float_max ) { if ( ! is_numeric ( $ float_min ) && ! is_numeric ( $ float_max ) ) { throw new \ InvalidArgumentException ( 'Min and max values must be valid numbers.' ) ; } if ( $ float_min >= $ float_max ) { throw new \ InvalidArgumentException ( 'Max value must be greater than min value!' ) ; } }
5435	public function getSignature ( $ name ) { $ interface = new ReflectionClass ( $ this -> interface ) ; $ method = $ interface -> getMethod ( $ name ) ; $ abstract = ( $ method -> isAbstract ( ) && ! $ interface -> isInterface ( ) && ! $ this -> isAbstractMethodInParents ( $ name ) ) ? 'abstract ' : '' ; if ( $ method -> isPublic ( ) ) { $ visibility = 'public' ; } elseif ( $ method -> isProtected ( ) ) { $ visibility = 'protected' ; } else { $ visibility = 'private' ; } $ static = $ method -> isStatic ( ) ? 'static ' : '' ; $ reference = $ method -> returnsReference ( ) ? '&' : '' ; $ params = $ this -> getParameterSignatures ( $ method ) ; $ returnType = $ this -> getReturnType ( $ method ) ; return "{$abstract}$visibility {$static}function $reference$name($params){$returnType}" ; }
10049	private static function toArray ( $ object ) { $ type = gettype ( $ object ) ; if ( $ type == 'array' ) { foreach ( $ object as $ element ) { $ result [ ] = self :: toArray ( $ element ) ; } return $ result ; } else if ( $ type == 'object' ) { if ( is_subclass_of ( $ object , 'AbstractJSONWrapper' ) ) { return $ object -> toArray ( ) ; } else { trigger_error ( "JSONSerializer: Trying to serialize " . get_class ( $ object ) ) ; return $ object ; } } else { return $ object ; } }
8189	final protected function getContext ( $ context , $ item , $ ignoreStrictCheck = false ) { if ( ! array_key_exists ( $ item , $ context ) ) { if ( $ ignoreStrictCheck || ! $ this -> env -> isStrictVariables ( ) ) { return ; } throw new Twig_Error_Runtime ( sprintf ( 'Variable "%s" does not exist.' , $ item ) , - 1 , $ this -> getSourceContext ( ) ) ; } return $ context [ $ item ] ; }
1920	private function getSqlDefinitions ( ) : array { $ this -> framework -> initialize ( ) ; $ installer = $ this -> framework -> createInstance ( Installer :: class ) ; $ sqlTarget = $ installer -> getFromDca ( ) ; $ sqlLegacy = $ installer -> getFromFile ( ) ; if ( ! empty ( $ sqlLegacy ) ) { foreach ( $ sqlLegacy as $ table => $ categories ) { foreach ( $ categories as $ category => $ fields ) { if ( \ is_array ( $ fields ) ) { foreach ( $ fields as $ name => $ sql ) { $ sqlTarget [ $ table ] [ $ category ] [ $ name ] = $ sql ; } } else { $ sqlTarget [ $ table ] [ $ category ] = $ fields ; } } } } if ( $ filter = $ this -> doctrine -> getConnection ( ) -> getConfiguration ( ) -> getFilterSchemaAssetsExpression ( ) ) { foreach ( array_keys ( $ sqlTarget ) as $ key ) { if ( ! preg_match ( $ filter , $ key ) ) { unset ( $ sqlTarget [ $ key ] ) ; } } } return $ sqlTarget ; }
8265	protected function onOauthResourceError ( IdentityProviderException $ e ) { $ this -> logger -> critical ( "OAuth2 IdentityProviderException: {e}, provider {provider}" , array ( "e" => $ e -> getMessage ( ) , "provider" => get_class ( $ this -> provider ) , ) ) ; $ this -> session -> addFlash ( "error" , "Failed to get an access token or user details." ) ; $ this -> picoAuth -> redirectToLogin ( ) ; }
1973	public static function findMultipleByPaths ( $ arrPaths , array $ arrOptions = array ( ) ) { if ( empty ( $ arrPaths ) || ! \ is_array ( $ arrPaths ) ) { return null ; } $ t = static :: $ strTable ; if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = Database :: getInstance ( ) -> findInSet ( "$t.path" , $ arrPaths ) ; } return static :: findBy ( array ( "$t.path IN(" . implode ( ',' , array_fill ( 0 , \ count ( $ arrPaths ) , '?' ) ) . ")" ) , $ arrPaths , $ arrOptions ) ; }
95	private function findBestVersionAndNameForPackage ( InputInterface $ input , $ name , $ phpVersion , $ preferredStability = 'stable' , $ requiredVersion = null , $ minimumStability = null ) { $ versionSelector = new VersionSelector ( $ this -> getPool ( $ input , $ minimumStability ) ) ; $ ignorePlatformReqs = $ input -> hasOption ( 'ignore-platform-reqs' ) && $ input -> getOption ( 'ignore-platform-reqs' ) ; if ( $ ignorePlatformReqs ) { $ phpVersion = null ; } $ package = $ versionSelector -> findBestCandidate ( $ name , $ requiredVersion , $ phpVersion , $ preferredStability ) ; if ( ! $ package ) { if ( $ ignorePlatformReqs && preg_match ( PlatformRepository :: PLATFORM_PACKAGE_REGEX , $ name ) ) { return array ( $ name , $ requiredVersion ? : '*' ) ; } if ( $ phpVersion && $ versionSelector -> findBestCandidate ( $ name , $ requiredVersion , null , $ preferredStability ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Package %s at version %s has a PHP requirement incompatible with your PHP version (%s)' , $ name , $ requiredVersion , $ phpVersion ) ) ; } if ( $ requiredVersion && $ versionSelector -> findBestCandidate ( $ name , null , $ phpVersion , $ preferredStability ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Could not find package %s in a version matching %s' , $ name , $ requiredVersion ) ) ; } if ( $ phpVersion && $ versionSelector -> findBestCandidate ( $ name ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Could not find package %s in any version matching your PHP version (%s)' , $ name , $ phpVersion ) ) ; } $ similar = $ this -> findSimilar ( $ name ) ; if ( $ similar ) { if ( $ requiredVersion === null && in_array ( $ name , $ similar , true ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Could not find a version of package %s matching your minimum-stability (%s). Require it with an explicit version constraint allowing its desired stability.' , $ name , $ this -> getMinimumStability ( $ input ) ) ) ; } throw new \ InvalidArgumentException ( sprintf ( "Could not find package %s.\n\nDid you mean " . ( count ( $ similar ) > 1 ? 'one of these' : 'this' ) . "?\n %s" , $ name , implode ( "\n " , $ similar ) ) ) ; } throw new \ InvalidArgumentException ( sprintf ( 'Could not find a matching version of package %s. Check the package spelling, your version constraint and that the package is available in a stability which matches your minimum-stability (%s).' , $ name , $ this -> getMinimumStability ( $ input ) ) ) ; } return array ( $ package -> getPrettyName ( ) , $ versionSelector -> findRecommendedRequireVersion ( $ package ) , ) ; }
9775	function startWith ( string $ value ) : self { return $ this -> expect ( $ this -> target , stringStartsWith ( $ value ) ) ; }
10386	protected function createInitializer ( ) { $ initializer = new Initializer ( ) ; $ initializer -> addTemplate ( 'Common' , new CommonTemplate ( ) ) ; $ initializer -> addTemplate ( 'Laravel' , new LaravelTemplate ( ) ) ; $ initializer -> addTemplate ( 'Symfony' , new SymfonyTemplate ( ) ) ; $ initializer -> addTemplate ( 'Yii' , new YiiTemplate ( ) ) ; $ initializer -> addTemplate ( 'Yii2 Basic App' , new Yii2BasicAppTemplate ( ) ) ; $ initializer -> addTemplate ( 'Yii2 Advanced App' , new Yii2AdvancedAppTemplate ( ) ) ; return $ initializer ; }
12243	public function XSLT ( $ filepath , $ use_xslcache = true ) { if ( $ use_xslcache && extension_loaded ( 'xslcache' ) ) { $ xslt = new XSLTCache ; $ xslt -> importStylesheet ( $ filepath ) ; } else { $ xsl = new DOMDocument ; $ xsl -> load ( $ filepath ) ; $ xslt = new XSLTProcessor ; $ xslt -> importStylesheet ( $ xsl ) ; } return $ xslt -> transformToXML ( dom_import_simplexml ( $ this ) ) ; }
1489	public function unless ( bool $ test , $ decodings ) : self { return $ this -> when ( true !== $ test , $ decodings ) ; }
1040	public function processPsrRequest ( ServerRequestInterface $ request , ResponseInterface $ response , StreamInterface $ writableBodyStream ) { $ result = $ this -> executePsrRequest ( $ request ) ; return $ this -> helper -> toPsrResponse ( $ result , $ response , $ writableBodyStream ) ; }
6140	public function checkUser ( $ username = null ) { if ( $ username === null ) { $ username = $ this -> user ; } if ( strlen ( $ username ) == 0 ) { return true ; } $ pattern = "/^(" . $ this -> regex [ "alphanum" ] . "|" . $ this -> regex [ "mark" ] . "|" . $ this -> regex [ "escaped" ] . "|[;:&=+$,])+$/" ; $ status = @ preg_match ( $ pattern , $ username ) ; if ( $ status === false ) { throw new Ts3Exception ( "URI username validation failed" ) ; } return ( $ status == 1 ) ; }
8498	public function listAllFulfillmentOrdersByNextToken ( $ request ) { if ( ! ( $ request instanceof FBAOutboundServiceMWS_Model_ListAllFulfillmentOrdersByNextTokenRequest ) ) { $ request = new FBAOutboundServiceMWS_Model_ListAllFulfillmentOrdersByNextTokenRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListAllFulfillmentOrdersByNextToken' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAOutboundServiceMWS_Model_ListAllFulfillmentOrdersByNextTokenResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
12762	public function set ( $ name , $ value , $ expire = 0 , $ path = null , $ domain = null , $ secure = false , $ httpOnly = false ) { if ( $ expire === - 1 ) { $ expire = time ( ) + 3600 * 24 * 365 ; } else { $ expire *= 60 ; } $ value = base64_encode ( $ value ) ; if ( $ path != null ) { if ( $ domain != null ) { if ( $ secure ) { if ( $ httpOnly ) { setcookie ( $ name , $ value , $ expire , $ path , $ domain , $ secure , $ httpOnly ) ; } else { setcookie ( $ name , $ value , $ expire , $ path , $ domain , $ secure ) ; } } else { setcookie ( $ name , $ value , $ expire , $ path , $ domain ) ; } } else { setcookie ( $ name , $ value , $ expire , $ path ) ; } } else { setcookie ( $ name , $ value , $ expire ) ; } }
8568	public function setCategoryQueryList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'CategoryQueryList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
11961	public function each ( Closure $ fn ) { foreach ( $ this -> elements as $ key => $ element ) { if ( $ fn ( $ element , $ key ) === false ) { return false ; } } return true ; }
7668	function RFCDate ( ) { $ tz = date ( "Z" ) ; $ tzs = ( $ tz < 0 ) ? "-" : "+" ; $ tz = abs ( $ tz ) ; $ tz = ( $ tz / 3600 ) * 100 + ( $ tz % 3600 ) / 60 ; $ result = sprintf ( "%s %s%04d" , date ( "D, j M Y H:i:s" ) , $ tzs , $ tz ) ; return $ result ; }
11480	private function getJsonBody ( RequestInterface $ request , ResponseInterface $ response ) : array { $ data = json_decode ( $ response -> getBody ( ) , true ) ; if ( ! $ data || ! is_array ( $ data ) || ! array_key_exists ( "data" , $ data ) ) { throw new ClientException ( "Response body does not contain a valid JSON object." , $ request , $ response ) ; } if ( ! is_array ( $ data ) || ! is_array ( $ data [ "data" ] ) ) { throw new ClientException ( "Not sure what happened. The list jobs endpoint didn't return a list. :worried:" , $ request , $ response ) ; } return $ data [ "data" ] ; }
2765	public function isUpToDate ( ) : bool { if ( ! $ this -> isTracking ( ) ) { throw new GitException ( 'Error: HEAD does not have a remote tracking branch. Cannot check if it is up-to-date.' ) ; } $ mergeBase = $ this -> run ( 'merge-base' , [ '@' , '@{u}' ] ) ; $ remoteSha = $ this -> run ( 'rev-parse' , [ '@{u}' ] ) ; return $ mergeBase === $ remoteSha ; }
3759	public function buildWidget ( BuildWidgetEvent $ event ) { if ( ! ( $ this -> wantToHandle ( $ event ) && \ in_array ( $ event -> getProperty ( ) -> getName ( ) , [ 'name' , 'description' ] ) ) ) { return ; } $ metaModel = $ this -> getMetaModelByModelPid ( $ event -> getModel ( ) ) ; Helper :: prepareLanguageAwareWidget ( $ event -> getEnvironment ( ) , $ event -> getProperty ( ) , $ metaModel , $ this -> translator -> trans ( 'tl_metamodel_attribute.name_langcode' , [ ] , 'contao_tl_metamodel_attribute' ) , $ this -> translator -> trans ( 'tl_metamodel_attribute.name_value' , [ ] , 'contao_tl_metamodel_attribute' ) , false , StringUtil :: deserialize ( $ event -> getModel ( ) -> getProperty ( $ event -> getProperty ( ) -> getName ( ) ) , true ) ) ; }
9155	private function parseAnnotations ( \ ReflectionMethod $ action ) { if ( $ action -> isConstructor ( ) || $ action -> isDestructor ( ) || $ action -> isStatic ( ) || $ action -> isFinal ( ) ) { return ; } $ rfMethod = new \ ReflectionMethod ( $ this , $ action -> name ) ; $ anno = $ rfMethod -> getDocComment ( ) ; if ( $ anno && preg_match ( '#@webMethod#' , $ anno ) ) { $ this -> actions [ ] = $ action -> name ; return ; } if ( ! $ this -> parseParameters ( $ action ) ) { return ; } $ this -> actions [ ] = $ action -> name ; }
9869	private function writePageMargins ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { $ objWriter -> startElement ( 'pageMargins' ) ; $ objWriter -> writeAttribute ( 'left' , StringHelper :: formatNumber ( $ pSheet -> getPageMargins ( ) -> getLeft ( ) ) ) ; $ objWriter -> writeAttribute ( 'right' , StringHelper :: formatNumber ( $ pSheet -> getPageMargins ( ) -> getRight ( ) ) ) ; $ objWriter -> writeAttribute ( 'top' , StringHelper :: formatNumber ( $ pSheet -> getPageMargins ( ) -> getTop ( ) ) ) ; $ objWriter -> writeAttribute ( 'bottom' , StringHelper :: formatNumber ( $ pSheet -> getPageMargins ( ) -> getBottom ( ) ) ) ; $ objWriter -> writeAttribute ( 'header' , StringHelper :: formatNumber ( $ pSheet -> getPageMargins ( ) -> getHeader ( ) ) ) ; $ objWriter -> writeAttribute ( 'footer' , StringHelper :: formatNumber ( $ pSheet -> getPageMargins ( ) -> getFooter ( ) ) ) ; $ objWriter -> endElement ( ) ; }
7359	public static function getDefaultPriceMapLoader ( ) { if ( null === self :: $ defaultPriceMapLoader ) { $ currencyDir = realpath ( __DIR__ . '/../../../data/prices' ) ; self :: $ defaultPriceMapLoader = new PhpFileLoader ( array ( $ currencyDir ) ) ; } return self :: $ defaultPriceMapLoader ; }
3536	public function updateAccountStatus ( ) { if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: beginProfile ( 'LDAP updateAccountStatus function' , static :: YII2_PROFILE_NAME . 'updateAccountStatus' ) ; } $ ldapUser = $ this -> queryLdapUserObject ( ) ; if ( $ ldapUser == null ) { $ this -> status = static :: STATUS_DISABLED ; } else { $ ldapAccountState = $ ldapUser -> getUserAccountControl ( ) ; $ disabledUser = ( $ ldapAccountState & AccountControl :: ACCOUNTDISABLE ) === AccountControl :: ACCOUNTDISABLE ; $ lockedUser = ( $ ldapAccountState & AccountControl :: LOCKOUT ) === AccountControl :: LOCKOUT ; $ pwExpired = ( $ ldapAccountState & AccountControl :: PASSWORD_EXPIRED ) === AccountControl :: PASSWORD_EXPIRED ; if ( $ disabledUser == true || $ lockedUser == true || $ pwExpired == true ) { $ this -> status = static :: STATUS_DISABLED ; } else { $ this -> status = static :: STATUS_ENABLED ; } } $ this -> save ( ) ; if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: endProfile ( 'LDAP updateAccountStatus function' , static :: YII2_PROFILE_NAME . 'updateAccountStatus' ) ; } return $ this -> status ; }
10012	public function getSheet ( $ pIndex ) { if ( ! isset ( $ this -> workSheetCollection [ $ pIndex ] ) ) { $ numSheets = $ this -> getSheetCount ( ) ; throw new Exception ( "Your requested sheet index: {$pIndex} is out of bounds. The actual number of sheets is {$numSheets}." ) ; } return $ this -> workSheetCollection [ $ pIndex ] ; }
2017	protected function resizeUploadedImage ( $ strImage ) { if ( Config :: get ( 'imageWidth' ) < 1 && Config :: get ( 'imageHeight' ) < 1 ) { return false ; } $ objFile = new File ( $ strImage ) ; if ( ! $ objFile -> isSvgImage && ! $ objFile -> isGdImage ) { return false ; } $ arrImageSize = $ objFile -> imageSize ; if ( $ objFile -> isGdImage && ( $ arrImageSize [ 0 ] > Config :: get ( 'gdMaxImgWidth' ) || $ arrImageSize [ 1 ] > Config :: get ( 'gdMaxImgHeight' ) ) ) { Message :: addInfo ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'fileExceeds' ] , $ objFile -> basename ) ) ; $ this -> log ( 'File "' . $ strImage . '" is too big to be resized automatically' , __METHOD__ , TL_FILES ) ; return false ; } $ blnResize = false ; if ( $ arrImageSize [ 0 ] > Config :: get ( 'imageWidth' ) ) { $ blnResize = true ; $ intWidth = Config :: get ( 'imageWidth' ) ; $ intHeight = round ( Config :: get ( 'imageWidth' ) * $ arrImageSize [ 1 ] / $ arrImageSize [ 0 ] ) ; $ arrImageSize = array ( $ intWidth , $ intHeight ) ; } if ( $ arrImageSize [ 1 ] > Config :: get ( 'imageHeight' ) ) { $ blnResize = true ; $ intWidth = round ( Config :: get ( 'imageHeight' ) * $ arrImageSize [ 0 ] / $ arrImageSize [ 1 ] ) ; $ intHeight = Config :: get ( 'imageHeight' ) ; $ arrImageSize = array ( $ intWidth , $ intHeight ) ; } if ( $ blnResize ) { $ container = System :: getContainer ( ) ; $ rootDir = $ container -> getParameter ( 'kernel.project_dir' ) ; $ container -> get ( 'contao.image.image_factory' ) -> create ( $ rootDir . '/' . $ strImage , array ( $ arrImageSize [ 0 ] , $ arrImageSize [ 1 ] ) , $ rootDir . '/' . $ strImage ) ; Message :: addInfo ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'fileResized' ] , $ objFile -> basename ) ) ; $ this -> log ( 'File "' . $ strImage . '" was scaled down to the maximum dimensions' , __METHOD__ , TL_FILES ) ; $ this -> blnHasResized = true ; return true ; } return false ; }
1800	protected function combiner ( $ names ) { $ return = array ( '' ) ; $ names = array_values ( $ names ) ; for ( $ i = 0 , $ c = \ count ( $ names ) ; $ i < $ c ; $ i ++ ) { $ buffer = array ( ) ; foreach ( $ return as $ k => $ v ) { $ buffer [ ] = ( $ k % 2 == 0 ) ? $ v : $ v . $ names [ $ i ] ; $ buffer [ ] = ( $ k % 2 == 0 ) ? $ v . $ names [ $ i ] : $ v ; } $ return = $ buffer ; } return array_filter ( $ return ) ; }
5291	public static function simpleDetect ( $ text ) { $ detections = self :: detect ( $ text ) ; if ( count ( $ detections ) > 0 ) return $ detections [ 0 ] -> language ; else return null ; }
9941	public function setTitle ( $ pValue , $ updateFormulaCellReferences = true , $ validate = true ) { if ( $ this -> getTitle ( ) == $ pValue ) { return $ this ; } $ oldTitle = $ this -> getTitle ( ) ; if ( $ validate ) { self :: checkSheetTitle ( $ pValue ) ; if ( $ this -> parent ) { if ( $ this -> parent -> sheetNameExists ( $ pValue ) ) { if ( Shared \ StringHelper :: countCharacters ( $ pValue ) > 29 ) { $ pValue = Shared \ StringHelper :: substring ( $ pValue , 0 , 29 ) ; } $ i = 1 ; while ( $ this -> parent -> sheetNameExists ( $ pValue . ' ' . $ i ) ) { ++ $ i ; if ( $ i == 10 ) { if ( Shared \ StringHelper :: countCharacters ( $ pValue ) > 28 ) { $ pValue = Shared \ StringHelper :: substring ( $ pValue , 0 , 28 ) ; } } elseif ( $ i == 100 ) { if ( Shared \ StringHelper :: countCharacters ( $ pValue ) > 27 ) { $ pValue = Shared \ StringHelper :: substring ( $ pValue , 0 , 27 ) ; } } } $ pValue .= " $i" ; } } } $ this -> title = $ pValue ; $ this -> dirty = true ; if ( $ this -> parent && $ this -> parent -> getCalculationEngine ( ) ) { $ newTitle = $ this -> getTitle ( ) ; $ this -> parent -> getCalculationEngine ( ) -> renameCalculationCacheForWorksheet ( $ oldTitle , $ newTitle ) ; if ( $ updateFormulaCellReferences ) { ReferenceHelper :: getInstance ( ) -> updateNamedFormulas ( $ this -> parent , $ oldTitle , $ newTitle ) ; } } return $ this ; }
7498	public function createAndSendMessageFromTemplate ( ) { $ args = func_get_args ( ) ; if ( empty ( $ args [ 0 ] ) ) { throw new \ RuntimeException ( 'First parameter must be a template filename or EmailTemplate entity' ) ; } elseif ( $ args [ 0 ] instanceof EmailTemplate ) { $ method = 'createMessageFromTemplateEntity' ; } else { $ method = 'createMessageFromTemplateFile' ; } $ message = call_user_func_array ( array ( $ this , $ method ) , $ args ) ; $ this -> mailer -> send ( $ message ) ; return true ; }
12563	public function sendNews ( $ message , $ to = null ) { return $ this -> send ( self :: MSG_TYPE_NEWS , $ message , $ to ) ; }
5109	public function orderBy ( $ column , $ type = OrderBy :: ASC ) : IWithLimit { if ( $ type == OrderBy :: DESC ) { $ this -> appendDesc ( $ column ) ; } else if ( ! is_array ( $ column ) ) { $ column = [ $ column ] ; } return $ this -> _orderBy ( $ column ) ; }
2597	public function isNextTokenAny ( array $ tokens ) { return null !== $ this -> lookahead && in_array ( $ this -> lookahead [ 'type' ] , $ tokens , true ) ; }
72	public function authorizeOAuth ( $ originUrl ) { if ( $ originUrl !== 'bitbucket.org' ) { return false ; } if ( 0 === $ this -> process -> execute ( 'git config bitbucket.accesstoken' , $ output ) ) { $ this -> io -> setAuthentication ( $ originUrl , 'x-token-auth' , trim ( $ output ) ) ; return true ; } return false ; }
1629	public function getMonolog ( ) { foreach ( $ this -> loggers as $ logger ) { if ( is_callable ( [ $ logger , 'getMonolog' ] ) ) { $ monolog = $ logger -> getMonolog ( ) ; if ( $ monolog === null ) { continue ; } return $ monolog ; } } }
6930	private function purgeShipmentInvoice ( Invoice \ InvoiceInterface $ invoice ) { $ changed = false ; $ shipment = $ invoice -> getShipment ( ) ; foreach ( $ invoice -> getLinesByType ( Document \ DocumentLineTypes :: TYPE_GOOD ) as $ line ) { foreach ( $ shipment -> getItems ( ) as $ shipmentItem ) { if ( $ line -> getSaleItem ( ) === $ shipmentItem -> getSaleItem ( ) ) { continue 2 ; } } $ invoice -> removeLine ( $ line ) ; $ this -> persistenceHelper -> remove ( $ line , false ) ; $ changed = true ; } $ sale = $ invoice -> getSale ( ) ; foreach ( $ invoice -> getLinesByType ( Document \ DocumentLineTypes :: TYPE_DISCOUNT ) as $ line ) { foreach ( $ sale -> getAdjustments ( Common \ AdjustmentTypes :: TYPE_DISCOUNT ) as $ saleAdjustment ) { if ( $ line -> getSaleAdjustment ( ) === $ saleAdjustment ) { continue 2 ; } } $ invoice -> removeLine ( $ line ) ; $ this -> persistenceHelper -> remove ( $ line , false ) ; $ changed = true ; } if ( null === $ sale -> getShipmentMethod ( ) ) { foreach ( $ invoice -> getLinesByType ( Document \ DocumentLineTypes :: TYPE_SHIPMENT ) as $ line ) { $ invoice -> removeLine ( $ line ) ; $ this -> persistenceHelper -> remove ( $ line , false ) ; $ changed = true ; } } return $ changed ; }
11739	public function getMd5Address ( $ scheme = true , $ www = true ) { return md5 ( $ this -> normalize ( $ scheme , $ www ) ) ; }
1541	public function withQualifiedKeyName ( $ keyName ) { $ parts = explode ( '.' , $ keyName ) ; if ( ! isset ( $ parts [ 1 ] ) ) { throw new \ InvalidArgumentException ( 'Expecting a valid qualified column name.' ) ; } $ this -> withIdentifierColumn ( $ parts [ 1 ] ) ; return $ this ; }
11810	protected function loadForeignObject ( ) { if ( $ this -> _isLoadingForeignObject ) { throw new RecursionException ( 'Ran into recursion while loading foreign object' ) ; } $ this -> _isLoadingForeignObject = true ; if ( isset ( $ this -> deferredModel ) && ( $ attributes = $ this -> deferredModel -> attributes ) ) { $ this -> foreignObject = $ this -> dataSource -> createModel ( $ this -> deferredModel -> id , $ this -> deferredModel -> attributes ) ; } $ this -> _isLoadingForeignObject = false ; }
6275	protected function read ( $ start , $ len ) { $ end = $ start + $ len ; if ( $ end <= 2048 ) { return substr ( $ this -> index , $ start , $ len ) ; } $ bytes = '' ; if ( $ this -> buf && $ start >= $ this -> bufStart ) { $ bytes .= substr ( $ this -> buf , $ start - $ this -> bufStart , $ len ) ; $ bytesRead = strlen ( $ bytes ) ; $ len -= $ bytesRead ; $ start += $ bytesRead ; } else { $ bytesRead = 0 ; } if ( ! $ len ) { return $ bytes ; } if ( $ start !== $ this -> filePos ) { if ( fseek ( $ this -> handle , $ start ) === - 1 ) { throw new Exception ( 'Seek failed, file "' . $ this -> fileName . '" may be corrupted.' ) ; } } $ buf = fread ( $ this -> handle , max ( $ len , 1024 ) ) ; if ( $ buf === false ) { $ buf = '' ; } $ bytes .= substr ( $ buf , 0 , $ len ) ; if ( strlen ( $ bytes ) !== $ len + $ bytesRead ) { throw new Exception ( 'Read from CDB file failed, file "' . $ this -> fileName . '" may be corrupted.' ) ; } $ this -> filePos = $ end ; $ this -> bufStart = $ start ; $ this -> buf = $ buf ; return $ bytes ; }
10436	public function channel ( string $ channel_id ) : LoggerChannelInterface { $ logger = $ this -> log_manager -> get ( $ channel_id ) ; if ( ! $ logger ) { return new NullLoggerChannel ( ) ; } return new CalgamoLoggerChannelAdapter ( $ logger ) ; }
9491	public function getFileListData ( $ sFieldName ) { if ( empty ( $ sFieldName ) ) { return [ ] ; } $ obFileList = $ this -> $ sFieldName ; if ( $ obFileList -> isEmpty ( ) ) { return [ ] ; } $ arResult = [ ] ; foreach ( $ obFileList as $ obFile ) { if ( empty ( $ obFile ) || ! $ obFile instanceof File ) { continue ; } $ arResult [ ] = $ this -> getFileDataValue ( $ obFile ) ; } return $ arResult ; }
9517	public function recreate ( $ file ) { if ( is_file ( $ file ) ) { return ; } $ virtual = $ tables = $ indexes = array ( ) ; if ( $ result = $ this -> query ( 'SELECT type, name, sql FROM sqlite_master' ) ) { while ( list ( $ type , $ name , $ sql ) = $ this -> fetch ( $ result ) ) { if ( ! empty ( $ sql ) ) { switch ( $ type ) { case 'table' : $ tables [ $ name ] = $ sql ; break ; case 'index' : $ indexes [ ] = $ sql ; break ; } } } $ this -> close ( $ result ) ; } foreach ( $ tables as $ name => $ sql ) { if ( strpos ( $ sql , 'VIRTUAL TABLE' ) ) { $ virtual [ ] = $ name ; } } foreach ( $ virtual as $ table ) { foreach ( $ tables as $ name => $ sql ) { if ( strpos ( $ name , "{$table}_" ) === 0 ) { unset ( $ tables [ $ name ] ) ; } } } $ db = new self ( $ file ) ; $ this -> exec ( 'ATTACH DATABASE ' . $ this -> dbEscape ( $ file ) . ' AS recreate' ) ; foreach ( $ tables as $ table => $ sql ) { $ db -> connection ( ) -> exec ( $ sql ) ; if ( $ fields = $ this -> row ( 'SELECT * FROM ' . $ table . ' LIMIT 1' , '' , 'assoc' ) ) { $ fields = implode ( ', ' , array_keys ( $ fields ) ) ; $ this -> exec ( "INSERT INTO recreate.{$table} ({$fields}) SELECT * FROM {$table}" ) ; } } foreach ( $ indexes as $ sql ) { $ db -> connection ( ) -> exec ( $ sql ) ; } $ db -> connection ( ) -> close ( ) ; }
9862	private function writeSheetFormatPr ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { $ objWriter -> startElement ( 'sheetFormatPr' ) ; if ( $ pSheet -> getDefaultRowDimension ( ) -> getRowHeight ( ) >= 0 ) { $ objWriter -> writeAttribute ( 'customHeight' , 'true' ) ; $ objWriter -> writeAttribute ( 'defaultRowHeight' , StringHelper :: formatNumber ( $ pSheet -> getDefaultRowDimension ( ) -> getRowHeight ( ) ) ) ; } else { $ objWriter -> writeAttribute ( 'defaultRowHeight' , '14.4' ) ; } if ( ( string ) $ pSheet -> getDefaultRowDimension ( ) -> getZeroHeight ( ) == '1' || strtolower ( ( string ) $ pSheet -> getDefaultRowDimension ( ) -> getZeroHeight ( ) ) == 'true' ) { $ objWriter -> writeAttribute ( 'zeroHeight' , '1' ) ; } if ( $ pSheet -> getDefaultColumnDimension ( ) -> getWidth ( ) >= 0 ) { $ objWriter -> writeAttribute ( 'defaultColWidth' , StringHelper :: formatNumber ( $ pSheet -> getDefaultColumnDimension ( ) -> getWidth ( ) ) ) ; } $ outlineLevelRow = 0 ; foreach ( $ pSheet -> getRowDimensions ( ) as $ dimension ) { if ( $ dimension -> getOutlineLevel ( ) > $ outlineLevelRow ) { $ outlineLevelRow = $ dimension -> getOutlineLevel ( ) ; } } $ objWriter -> writeAttribute ( 'outlineLevelRow' , ( int ) $ outlineLevelRow ) ; $ outlineLevelCol = 0 ; foreach ( $ pSheet -> getColumnDimensions ( ) as $ dimension ) { if ( $ dimension -> getOutlineLevel ( ) > $ outlineLevelCol ) { $ outlineLevelCol = $ dimension -> getOutlineLevel ( ) ; } } $ objWriter -> writeAttribute ( 'outlineLevelCol' , ( int ) $ outlineLevelCol ) ; $ objWriter -> endElement ( ) ; }
547	protected function addServers ( $ cache , $ servers ) { if ( empty ( $ servers ) ) { $ servers = [ new MemCacheServer ( [ 'host' => '127.0.0.1' , 'port' => 11211 , ] ) ] ; } else { foreach ( $ servers as $ server ) { if ( $ server -> host === null ) { throw new InvalidConfigException ( "The 'host' property must be specified for every memcache server." ) ; } } } if ( $ this -> useMemcached ) { $ this -> addMemcachedServers ( $ cache , $ servers ) ; } else { $ this -> addMemcacheServers ( $ cache , $ servers ) ; } }
10919	public static function getArray ( $ language ) { $ fileName = __DIR__ . '/stop-words/' . $ language . '.txt' ; if ( file_exists ( $ fileName ) ) { return array_map ( 'trim' , file ( $ fileName ) ) ; } return [ ] ; }
9584	public function getRouteForRequest ( Request $ request ) { $ method = $ request -> getMethod ( ) ; $ path = $ request -> getPathInfo ( ) ? : '/' ; $ result = $ this -> getDispatcher ( ) -> dispatch ( $ method , $ path ) ; if ( $ result [ 0 ] == \ FastRoute \ Dispatcher :: NOT_FOUND ) { throw new NotFoundHttpException ( "No route match for path $path" ) ; } else if ( $ result [ 0 ] == \ FastRoute \ Dispatcher :: METHOD_NOT_ALLOWED ) { throw new MethodNotAllowedHttpException ( $ result [ 1 ] , "Method $method not allowed for path $path" ) ; } else if ( $ result [ 0 ] !== \ FastRoute \ Dispatcher :: FOUND ) { throw new \ RuntimeException ( 'Unknown result from FastRoute: ' . $ result [ 0 ] ) ; } return $ this -> matchRoute ( $ result [ 1 ] , $ result [ 2 ] , $ request ) ; }
7421	protected function initializeProductMediaGalleryValueToEntity ( array $ attr ) { $ rowId = $ attr [ MemberNames :: ROW_ID ] ; $ valueId = $ attr [ MemberNames :: VALUE_ID ] ; if ( $ this -> loadProductMediaGalleryValueToEntityByValueIdAndRowId ( $ valueId , $ rowId ) ) { return ; } return $ attr ; }
2608	public function getCurrentVersion ( array $ versions ) { if ( ! empty ( $ versions ) ) { foreach ( $ versions as $ version ) { if ( $ version -> active ) { return $ activeVersion = $ version -> number ; } } } throw new LocalizedException ( __ ( 'Error fetching current version.' ) ) ; }
11874	protected function renewAccessToken ( ) { $ token = $ this -> authorizer -> getApi ( ) -> getAuthorizerToken ( $ this -> authorizer -> getAppId ( ) , $ this -> authorizer -> getRefreshToken ( ) ) ; $ this -> authorizer -> setAccessToken ( $ token [ 'authorizer_access_token' ] , $ token [ 'expires_in' ] - 1500 ) ; return $ token [ 'authorizer_access_token' ] ; }
9335	public function rad ( ) { if ( $ this -> original -> type == self :: TYPE_RAD ) { return $ this -> original -> value ; } return $ this -> float_rad ; }
12681	public function send ( ) { if ( empty ( $ this -> message ) ) { throw new RuntimeException ( 'No message to send.' ) ; } $ transformer = new Transformer ( ) ; if ( $ this -> message instanceof RawMessage ) { $ message = $ this -> message -> get ( 'content' ) ; } else { $ content = $ transformer -> transform ( $ this -> message ) ; $ message = [ 'touser' => $ this -> to , ] ; if ( $ this -> account ) { $ message [ 'customservice' ] = [ 'kf_account' => $ this -> account ] ; } $ message = array_merge ( $ message , $ content ) ; } return $ this -> staff -> send ( $ message ) ; }
12353	public function save ( ) { try { $ autenticacao = new Autenticacao ( ) ; $ autenticacao -> exchangeArray ( $ this -> form -> getData ( ) ) ; $ perfilDefault = $ this -> autenticacaoManager -> getPerfilManager ( ) -> obterPerfilByNome ( Acesso :: getDefaultRole ( ) ) ; $ autenticacao = $ this -> autenticacaoManager -> salvar ( $ autenticacao -> setPerfilId ( $ perfilDefault -> getId ( ) ) -> setPerfil ( $ perfilDefault ) ) ; $ this -> addNotificacao ( new Notificacao ( Notificacao :: TIPO_SUCESSO , self :: MESSAGE_INSERT_SUCCESS ) ) ; } catch ( \ Exception $ e ) { $ this -> addNotificacao ( new Notificacao ( Notificacao :: TIPO_ERRO , self :: MESSAGE_INTERNAL_ERROR ) ) ; } return true ; }
7463	private static function renderTemplate ( string $ __file__ , array $ data ) : string { ob_start ( ) ; extract ( $ data ) ; include $ __file__ ; return ob_get_clean ( ) ; }
251	public function removeFlash ( $ key ) { $ counters = $ this -> get ( $ this -> flashParam , [ ] ) ; $ value = isset ( $ _SESSION [ $ key ] , $ counters [ $ key ] ) ? $ _SESSION [ $ key ] : null ; unset ( $ counters [ $ key ] , $ _SESSION [ $ key ] ) ; $ _SESSION [ $ this -> flashParam ] = $ counters ; return $ value ; }
4653	public function getJobsToRemove ( $ projectPath , $ keep = 1 ) { $ currentJobs = $ this -> strategy -> getJobs ( $ projectPath ) ; $ existingJobs = $ this -> getJobs ( $ projectPath ) ; $ uniqList = array ( ) ; $ removes = array ( ) ; $ ordered = array ( ) ; foreach ( $ currentJobs as $ job ) { $ uniqList [ ] = $ job -> getUniq ( ) ; } foreach ( $ existingJobs as $ job ) { if ( ! in_array ( $ job -> getUniq ( ) , $ uniqList ) ) { $ removes [ ] = $ job ; } else { $ ordered [ $ job -> getUniq ( ) ] [ $ job -> getCreated ( ) -> format ( 'U' ) ] = $ job ; } } foreach ( $ ordered as $ jobs ) { ksort ( $ jobs ) ; $ keeped = count ( $ jobs ) ; while ( $ keeped > $ keep ) { $ removes [ ] = array_shift ( $ jobs ) ; $ keeped -- ; } } return $ removes ; }
6981	static public function factory ( $ type = 'html' , array $ params = null ) { if ( ! isset ( $ type ) || ! strcasecmp ( $ type , 'html' ) ) return ( new Html \ Renderer ( $ params ) ) ; throw new \ Exception ( "Unknown Skriv rendering type '$type'." ) ; }
1642	public static function fromString ( string $ string , Ellipsoid $ ellipsoid = null ) : Coordinate { $ string = self :: mergeSecondsToMinutes ( $ string ) ; $ result = self :: parseDecimalMinutesWithoutCardinalLetters ( $ string , $ ellipsoid ) ; if ( $ result instanceof Coordinate ) { return $ result ; } $ result = self :: parseDecimalMinutesWithCardinalLetters ( $ string , $ ellipsoid ) ; if ( $ result instanceof Coordinate ) { return $ result ; } $ result = self :: parseDecimalDegreesWithoutCardinalLetters ( $ string , $ ellipsoid ) ; if ( $ result instanceof Coordinate ) { return $ result ; } $ result = self :: parseDecimalDegreesWithCardinalLetters ( $ string , $ ellipsoid ) ; if ( $ result instanceof Coordinate ) { return $ result ; } throw new InvalidArgumentException ( 'Format of coordinates was not recognized' ) ; }
6475	public function readAsFormInput ( ? IHttpBody $ body ) : IDictionary { if ( $ body === null ) { return new HashTable ( ) ; } $ parsedFormInputCacheKey = spl_object_hash ( $ body ) ; if ( isset ( $ this -> parsedFormInputCache [ $ parsedFormInputCacheKey ] ) ) { return $ this -> parsedFormInputCache [ $ parsedFormInputCacheKey ] ; } $ formInputArray = [ ] ; parse_str ( $ body -> readAsString ( ) , $ formInputArray ) ; $ kvps = [ ] ; foreach ( $ formInputArray as $ key => $ value ) { $ kvps [ ] = new KeyValuePair ( $ key , $ value ) ; } $ formInputs = new HashTable ( $ kvps ) ; $ this -> parsedFormInputCache [ $ parsedFormInputCacheKey ] = $ formInputs ; return $ formInputs ; }
7707	function _ApplyDiffToAll ( $ Diff ) { $ this -> PosBeg += $ Diff ; $ this -> PosEnd += $ Diff ; $ this -> pST_PosEnd += $ Diff ; if ( $ this -> pET_PosBeg !== false ) $ this -> pET_PosBeg += $ Diff ; }
5991	public function setDeploymentDateRange ( $ deploymentDateRange ) { if ( $ deploymentDateRange instanceof DateTimeRange ) { $ this -> deploymentDateRange = $ deploymentDateRange ; } elseif ( is_array ( $ deploymentDateRange ) ) { $ this -> deploymentDateRange = new DateTimeRange ( $ deploymentDateRange ) ; } else { $ this -> deploymentDateRange = null ; trigger_error ( 'Argument must be an object of class DateTimeRange. Data loss!' , E_USER_WARNING ) ; } return $ this ; }
1135	public function moveToNewParent ( ) { $ pid = static :: $ moveToNewParentId ; if ( is_null ( $ pid ) ) $ this -> makeRoot ( ) ; else if ( $ pid !== FALSE ) $ this -> makeChildOf ( $ pid ) ; }
5093	public function rotate ( $ tableA , $ tableB ) { $ tableT = $ tableA . '_' . time ( ) . '_' . rand ( 0 , 1000000 ) ; return $ this -> rename ( [ $ tableB => $ tableT , $ tableA => $ tableB , $ tableT => $ tableA ] ) ; }
2636	public function getLastVersion ( ) { try { $ url = self :: CHECK_VERSION_URL ; $ client = $ this -> curlFactory -> create ( ) ; $ client -> write ( \ Zend_Http_Client :: GET , $ url , '1.1' ) ; $ responseBody = $ client -> read ( ) ; $ client -> close ( ) ; $ responseCode = \ Zend_Http_Response :: extractCode ( $ responseBody ) ; if ( $ responseCode !== 200 ) { return false ; } $ body = \ Zend_Http_Response :: extractBody ( $ responseBody ) ; $ json = json_decode ( $ body ) ; $ version = ! empty ( $ json -> version ) ? $ json -> version : false ; return $ version ; } catch ( \ Exception $ e ) { $ this -> _logger -> log ( 100 , $ e -> getMessage ( ) . $ url ) ; return false ; } }
655	protected function reset ( ) { $ this -> _sql = null ; $ this -> _pendingParams = [ ] ; $ this -> params = [ ] ; $ this -> _refreshTableName = null ; $ this -> _isolationLevel = false ; $ this -> _retryHandler = null ; }
8946	public function changePreference ( $ key , $ preference ) { $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = 'user/preferences/' . $ key ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'PUT' , $ parameters , $ preference ) ; return $ response -> body ; }
10164	private function readRangeProtection ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; $ offset = 0 ; if ( ! $ this -> readDataOnly ) { $ offset += 12 ; $ isf = self :: getUInt2d ( $ recordData , 12 ) ; if ( $ isf != 2 ) { return ; } $ offset += 2 ; $ offset += 5 ; $ cref = self :: getUInt2d ( $ recordData , 19 ) ; $ offset += 2 ; $ offset += 6 ; $ cellRanges = [ ] ; for ( $ i = 0 ; $ i < $ cref ; ++ $ i ) { try { $ cellRange = $ this -> readBIFF8CellRangeAddressFixed ( substr ( $ recordData , 27 + 8 * $ i , 8 ) ) ; } catch ( PhpSpreadsheetException $ e ) { return ; } $ cellRanges [ ] = $ cellRange ; $ offset += 8 ; } $ rgbFeat = substr ( $ recordData , $ offset ) ; $ offset += 4 ; $ wPassword = self :: getInt4d ( $ recordData , $ offset ) ; $ offset += 4 ; if ( $ cellRanges ) { $ this -> phpSheet -> protectCells ( implode ( ' ' , $ cellRanges ) , strtoupper ( dechex ( $ wPassword ) ) , true ) ; } } }
3088	public function isAssessmentSectionAdaptive ( AssessmentSection $ section ) { $ assessmentItemRefs = $ section -> getComponentsByClassName ( 'assessmentItemRef' ) ; return count ( $ assessmentItemRefs ) === 1 && $ this -> isAdaptivePlaceholder ( $ assessmentItemRefs [ 0 ] ) ; }
3083	public function getAssessmentItemRefByIdentifier ( \ tao_models_classes_service_StorageDirectory $ privateCompilationDirectory , $ identifier ) { $ compilationDataService = $ this -> getServiceLocator ( ) -> get ( CompilationDataService :: SERVICE_ID ) ; $ filename = "adaptive-assessment-item-ref-${identifier}" ; return $ compilationDataService -> readPhpCompilationData ( $ privateCompilationDirectory , "${filename}.php" , "${filename}" ) ; }
40	protected function fetchRootIdentifier ( ) { if ( $ this -> repoData ) { return ; } $ repoDataUrl = $ this -> getApiUrl ( ) . '/repos/' . $ this -> owner . '/' . $ this -> repository ; $ this -> repoData = JsonFile :: parseJson ( $ this -> getContents ( $ repoDataUrl , true ) , $ repoDataUrl ) ; if ( null === $ this -> repoData && null !== $ this -> gitDriver ) { return ; } $ this -> owner = $ this -> repoData [ 'owner' ] [ 'login' ] ; $ this -> repository = $ this -> repoData [ 'name' ] ; $ this -> isPrivate = ! empty ( $ this -> repoData [ 'private' ] ) ; if ( isset ( $ this -> repoData [ 'default_branch' ] ) ) { $ this -> rootIdentifier = $ this -> repoData [ 'default_branch' ] ; } elseif ( isset ( $ this -> repoData [ 'master_branch' ] ) ) { $ this -> rootIdentifier = $ this -> repoData [ 'master_branch' ] ; } else { $ this -> rootIdentifier = 'master' ; } $ this -> hasIssues = ! empty ( $ this -> repoData [ 'has_issues' ] ) ; }
11381	public function render ( FormInterface $ form ) { if ( method_exists ( $ form , 'prepare' ) ) { $ form -> prepare ( ) ; } if ( ! $ form -> getAttribute ( 'role' ) ) { $ form -> setAttribute ( 'role' , 'form' ) ; } $ formContent = '' ; foreach ( $ form as $ element ) { if ( $ element instanceof FieldsetInterface ) { $ formContent .= $ this -> getView ( ) -> formCollection ( $ element ) ; } else { $ element -> setOption ( '_form' , $ form ) ; $ formContent .= $ this -> getView ( ) -> formRow ( $ element ) ; } } return $ this -> openTag ( $ form ) . $ formContent . $ this -> closeTag ( ) ; }
9776	function throw ( string $ className = '' ) : self { if ( ! is_callable ( $ this -> target ) ) throw new \ BadMethodCallException ( 'The function target is not callable.' ) ; $ exception = null ; try { call_user_func ( $ this -> target ) ; } catch ( \ Throwable $ e ) { $ exception = $ e ; } $ constraint = logicalNot ( isNull ( ) ) ; return $ this -> expect ( $ exception , mb_strlen ( $ className ) ? logicalAnd ( $ constraint , isInstanceOf ( $ className ) ) : $ constraint ) ; }
12236	public function insertPI ( $ target , $ data = null , $ mode = 'before' ) { $ tmp = dom_import_simplexml ( $ this ) ; $ doc = $ tmp -> ownerDocument ; if ( isset ( $ data ) ) { if ( is_array ( $ data ) ) { $ str = '' ; foreach ( $ data as $ k => $ v ) { $ str .= $ k . '="' . htmlspecialchars ( $ v ) . '" ' ; } $ data = substr ( $ str , 0 , - 1 ) ; } else { $ data = ( string ) $ data ; } $ pi = $ doc -> createProcessingInstruction ( $ target , $ data ) ; } else { $ pi = $ doc -> createProcessingInstruction ( $ target ) ; } if ( $ pi !== false ) { $ this -> insertNode ( $ tmp , $ pi , $ mode ) ; } return $ this ; }
12776	protected function write ( $ namespace , array $ data ) { $ file = $ this -> adapter -> getFileName ( $ namespace ) ; $ contents = $ this -> adapter -> prepareForWriting ( $ data ) ; if ( ! $ this -> fileSystem -> has ( $ file ) ) { $ this -> fileSystem -> write ( $ file , $ contents ) ; } $ this -> fileSystem -> update ( $ file , $ contents ) ; }
5645	public function shouldInvoke ( $ test_case_name , $ method ) { $ numberOfReporters = count ( $ this -> reporters ) ; for ( $ i = 0 ; $ i < $ numberOfReporters ; $ i ++ ) { if ( ! $ this -> reporters [ $ i ] -> shouldInvoke ( $ test_case_name , $ method ) ) { return false ; } } return true ; }
12843	protected function addOptionShortcut ( $ name , $ description , $ default ) { $ this -> addOption ( $ name , null , InputOption :: VALUE_OPTIONAL , $ description , $ default ) ; return $ this ; }
8689	private static function doFlatten ( $ iterable , $ depth , callable $ predicate , array $ result = [ ] ) { foreach ( $ iterable as $ item ) { if ( $ depth >= 1 && $ predicate ( $ item ) ) { $ result = static :: doFlatten ( $ item , $ depth - 1 , $ predicate , $ result ) ; } else { $ result [ ] = $ item ; } } return $ result ; }
212	protected function initClientOptions ( ) { $ options = $ this -> clientOptions ; foreach ( $ options as $ key => $ value ) { if ( ! $ value instanceof JsExpression && in_array ( $ key , [ 'oncomplete' , 'onincomplete' , 'oncleared' , 'onKeyUp' , 'onKeyDown' , 'onBeforeMask' , 'onBeforePaste' , 'onUnMask' , 'isComplete' , 'determineActiveMasksetIndex' , ] , true ) ) { $ options [ $ key ] = new JsExpression ( $ value ) ; } } $ this -> clientOptions = $ options ; }
526	public function init ( ) { if ( $ this -> sourcePath !== null ) { $ this -> sourcePath = rtrim ( Yii :: getAlias ( $ this -> sourcePath ) , '/\\' ) ; } if ( $ this -> basePath !== null ) { $ this -> basePath = rtrim ( Yii :: getAlias ( $ this -> basePath ) , '/\\' ) ; } if ( $ this -> baseUrl !== null ) { $ this -> baseUrl = rtrim ( Yii :: getAlias ( $ this -> baseUrl ) , '/' ) ; } }
7689	function OpenXML_CTypesPrepareExt ( $ FileOrExt , $ ct = '' ) { $ ext = $ this -> Misc_FileExt ( $ FileOrExt ) ; $ this -> OpenXML_CTypesInit ( ) ; $ lst = & $ this -> OpenXmlCTypes [ 'Extension' ] ; if ( isset ( $ lst [ $ ext ] ) && ( $ lst [ $ ext ] !== '' ) ) return ; if ( ( $ ct === '' ) && isset ( $ this -> ExtInfo [ 'pic_ext' ] [ $ ext ] ) ) $ ct = 'image/' . $ this -> ExtInfo [ 'pic_ext' ] [ $ ext ] ; $ lst [ $ ext ] = $ ct ; }
3037	public function set ( $ userId , $ callId , $ data ) { $ key = $ this -> getCacheKey ( $ userId , $ callId ) ; $ cache = $ this -> getFromCache ( $ key ) ; if ( is_null ( $ cache ) || $ cache != $ data ) { $ this -> putInCache ( $ key , $ userId , $ callId , $ data , self :: STATE_PENDING_WRITE ) ; } return true ; }
9292	public function getEndpointNode ( ) { $ builder = new TreeBuilder ( ) ; $ node = $ builder -> root ( 'endpoints' ) ; $ node -> info ( 'Defines version endpoints.' ) -> useAttributeAsKey ( 'endpoint' ) -> prototype ( 'array' ) -> children ( ) -> scalarNode ( 'endpoint' ) -> info ( 'Endpoint name (will be included in url (e.g. products))' ) -> example ( 'products' ) -> end ( ) -> scalarNode ( 'repository' ) -> isRequired ( ) -> info ( 'Document service from Elasticsearch bundle which will be used for data fetching' ) -> example ( 'es.manager.default.products' ) -> end ( ) -> arrayNode ( 'methods' ) -> defaultValue ( [ Request :: METHOD_POST , Request :: METHOD_GET , Request :: METHOD_PUT , Request :: METHOD_DELETE ] ) -> prototype ( 'scalar' ) -> validate ( ) -> ifNotInArray ( [ Request :: METHOD_HEAD , Request :: METHOD_POST , Request :: METHOD_PATCH , Request :: METHOD_GET , Request :: METHOD_PUT , Request :: METHOD_DELETE ] ) -> thenInvalid ( 'Invalid HTTP method used! Please check your ongr_api endpoint configuration.' ) -> end ( ) -> end ( ) -> end ( ) -> booleanNode ( 'allow_extra_fields' ) -> defaultFalse ( ) -> info ( 'Allows to pass unknown fields to an api. ' . 'Make sure you have configured elasticsearch respectively.' ) -> end ( ) -> arrayNode ( 'allow_fields' ) -> defaultValue ( [ ] ) -> info ( 'A list off a allowed fields to operate through api for a document.' ) -> prototype ( 'scalar' ) -> end ( ) -> end ( ) -> booleanNode ( 'allow_get_all' ) -> defaultTrue ( ) -> info ( 'Allows to use `_all` elasticsearch api to get all documents from a type.' ) -> end ( ) -> booleanNode ( 'allow_batch' ) -> defaultTrue ( ) -> info ( 'Allows to use `_batch` elasticsearch api to pass multiple documents in single API request.' ) -> end ( ) -> booleanNode ( 'variants' ) -> defaultFalse ( ) -> info ( 'If set to true user can manipulate document variants over API.' ) -> end ( ) -> booleanNode ( 'batch' ) -> defaultTrue ( ) -> info ( 'If set to true user can sent documents in batch\'s.' ) -> end ( ) -> end ( ) -> end ( ) ; return $ node ; }
3293	public function linkedin ( $ summary = '' ) { $ base = config ( 'laravel-share.services.linkedin.uri' ) ; $ mini = config ( 'laravel-share.services.linkedin.extra.mini' ) ; $ url = $ base . '?mini=' . $ mini . '&url=' . $ this -> url . '&title=' . urlencode ( $ this -> title ) . '&summary=' . urlencode ( $ summary ) ; $ this -> buildLink ( 'linkedin' , $ url ) ; return $ this ; }
2212	public function fetchField ( $ intOffset = 0 ) { $ arrFields = array_values ( $ this -> resultSet [ $ this -> intIndex ] ) ; return $ arrFields [ $ intOffset ] ; }
7829	public function getLeftBordersWith ( $ border ) { $ border = str_repeat ( $ border , static :: BORDER_WIDTH ) ; $ space = str_repeat ( ' ' , static :: MIN_SPACE_FROM_BORDER_X ) ; return str_repeat ( "{$border}{$space}" , $ this -> nesting ) ; }
4175	public function getProviders ( ) { return $ this -> providers ? : $ this -> providers = new ServiceProvider ( clone $ this -> getFiles ( ) , $ this -> console ) ; }
10987	public static function D ( $ value , $ options = array ( ) ) { if ( is_numeric ( $ options ) ) { $ options = array ( 'depth' => $ options ) ; } elseif ( empty ( $ options ) ) { $ options = array ( ) ; } $ plop = new Dumpling ( $ options ) ; return $ plop -> dump ( $ value ) ; }
2926	public function load ( $ filePath = null , $ restoreIfNotFound = false , $ restorePath = null ) { $ this -> resetContent ( ) ; if ( ! is_null ( $ filePath ) ) { $ this -> filePath = $ filePath ; } else { if ( method_exists ( $ this -> app , 'environmentPath' ) && method_exists ( $ this -> app , 'environmentFile' ) ) { $ this -> filePath = $ this -> app -> environmentPath ( ) . '/' . $ this -> app -> environmentFile ( ) ; } else { $ this -> filePath = __DIR__ . '/../../../../../../.env' ; } } $ this -> reader -> load ( $ this -> filePath ) ; if ( file_exists ( $ this -> filePath ) ) { $ this -> writer -> setBuffer ( $ this -> getContent ( ) ) ; return $ this ; } elseif ( $ restoreIfNotFound ) { return $ this -> restore ( $ restorePath ) ; } else { return $ this ; } }
4663	public function smtp ( array $ params ) { if ( ! array_key_exists ( 'username' , $ params ) ) { throw new Exception ( 'We need a username' ) ; } if ( ! array_key_exists ( 'password' , $ params ) ) { throw new Exception ( 'We need a password' ) ; } $ this -> smtp = $ params ; $ this -> auth = true ; return $ this ; }
2828	public function getOptionArray ( array $ data ) { $ options = array ( ) ; foreach ( $ data as $ value ) { $ options [ ] = array ( 'value' => $ value , 'label' => $ value ) ; } return $ options ; }
6306	private function register ( array $ providers , array $ values ) { foreach ( $ providers as $ provider ) { $ factories = $ provider -> getFactories ( ) ; foreach ( $ factories as $ key => $ callable ) { $ this [ $ key ] = function ( ContainerInterface $ c ) use ( $ callable ) { return call_user_func ( $ callable , $ c ) ; } ; } } foreach ( $ providers as $ provider ) { $ extensions = $ provider -> getExtensions ( ) ; foreach ( $ extensions as $ key => $ callable ) { if ( isset ( $ this -> keys [ $ key ] ) ) { $ this [ $ key ] = $ this -> extend ( $ key , function ( $ previous , ContainerInterface $ c ) use ( $ callable ) { return call_user_func ( $ callable , $ c , $ previous ) ; } ) ; } else { $ this [ $ key ] = function ( ContainerInterface $ c ) use ( $ callable ) { return call_user_func ( $ callable , $ c ) ; } ; } } } foreach ( $ values as $ key => $ value ) { $ this [ $ key ] = $ value ; } }
7767	public function loadMetadataForClass ( $ className ) { foreach ( $ this -> drivers as $ namespace => $ driver ) { if ( strpos ( $ className , $ namespace ) === 0 ) { return $ driver -> loadMetadataForClass ( $ className ) ; } } return null ; }
7540	function index ( $ count_all = true ) { if ( ! $ this -> parent ) { return - 1 ; } elseif ( $ count_all ) { return $ this -> parent -> findChild ( $ this ) ; } else { $ index = - 1 ; foreach ( array_keys ( $ this -> parent -> children ) as $ k ) { if ( ! $ this -> parent -> children [ $ k ] -> isTextOrComment ( ) ) { ++ $ index ; } if ( $ this -> parent -> children [ $ k ] === $ this ) { return $ index ; } } return - 1 ; } }
1195	private function getExtensions ( ) { if ( null === $ this -> sorted ) { krsort ( $ this -> extensions ) ; $ this -> sorted = ! empty ( $ this -> extensions ) ? call_user_func_array ( 'array_merge' , $ this -> extensions ) : array ( ) ; } return $ this -> sorted ; }
11934	public function walk ( Callable $ callback ) { $ arrayCopy = $ this -> getArrayCopy ( ) ; $ result = array_walk ( $ arrayCopy , $ callback ) ; $ this -> exchangeArray ( $ arrayCopy ) ; return $ result ; }
5220	public function contains ( $ path ) { $ realpath = realpath ( $ path ) ; if ( false === $ realpath ) { return false ; } return substr ( $ realpath , 0 , strlen ( $ this -> rootpath ) ) === $ this -> rootpath ; }
7304	protected function updateFromParent ( CustomerInterface $ customer ) { if ( ! $ customer -> hasParent ( ) ) { if ( null === $ customer -> getDefaultInvoiceAddress ( ) ) { if ( false !== $ address = $ customer -> getAddresses ( ) -> first ( ) ) { $ address -> setInvoiceDefault ( true ) ; $ this -> persistenceHelper -> persistAndRecompute ( $ address , false ) ; } } if ( null === $ customer -> getDefaultDeliveryAddress ( ) ) { if ( false !== $ address = $ customer -> getAddresses ( ) -> first ( ) ) { $ address -> setDeliveryDefault ( true ) ; $ this -> persistenceHelper -> persistAndRecompute ( $ address , false ) ; } } return false ; } $ parent = $ customer -> getParent ( ) ; $ changed = false ; if ( empty ( $ customer -> getCompany ( ) ) ) { $ company = $ parent -> getCompany ( ) ; if ( $ company != $ customer -> getCompany ( ) ) { $ customer -> setCompany ( $ company ) ; $ changed = true ; } } $ group = $ parent -> getCustomerGroup ( ) ; if ( $ group !== $ customer -> getCustomerGroup ( ) ) { $ customer -> setCustomerGroup ( $ group ) ; $ changed = true ; } if ( ! empty ( $ customer -> getVatNumber ( ) ) ) { $ customer -> setVatNumber ( null ) ; $ changed = true ; } if ( ! empty ( $ customer -> getVatDetails ( ) ) ) { $ customer -> setVatDetails ( [ ] ) ; $ changed = true ; } if ( $ customer -> isVatValid ( ) ) { $ customer -> setVatValid ( false ) ; $ changed = true ; } if ( null !== $ customer -> getPaymentTerm ( ) ) { $ customer -> setPaymentTerm ( null ) ; $ changed = true ; } if ( 0 !== $ customer -> getOutstandingLimit ( ) ) { $ customer -> setOutstandingLimit ( 0 ) ; $ changed = true ; } return $ changed ; }
4903	public function createService ( ServiceLocatorInterface $ serviceLocator ) { $ select = $ this ( $ serviceLocator , self :: class , $ this -> options ) ; $ this -> options = [ ] ; return $ select ; }
3790	private function determineLanguages ( ) { $ languages = $ this -> getMetaModel ( ) -> getAvailableLanguages ( ) ; if ( $ languages === null ) { throw new \ RuntimeException ( 'MetaModel ' . $ this -> getMetaModel ( ) -> getName ( ) . ' does not seem to be translated.' ) ; } return $ languages ; }
1266	private function createRecoverLabelRequest ( $ trackingData , $ labelSpecificationOpts = null , $ labelDeliveryOpts = null , $ translateOpts = null ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; $ container = $ xml -> appendChild ( $ xml -> createElement ( 'LabelRecoveryRequest' ) ) ; $ request = $ container -> appendChild ( $ xml -> createElement ( 'Request' ) ) ; $ node = $ xml -> importNode ( $ this -> createTransactionNode ( ) , true ) ; $ request -> appendChild ( $ node ) ; $ request -> appendChild ( $ xml -> createElement ( 'RequestAction' , 'LabelRecovery' ) ) ; if ( is_string ( $ trackingData ) ) { $ container -> appendChild ( $ xml -> createElement ( 'TrackingNumber' , $ trackingData ) ) ; } elseif ( is_array ( $ trackingData ) ) { $ referenceNumber = $ container -> appendChild ( $ xml -> createElement ( 'ReferenceNumber' ) ) ; $ referenceNumber -> appendChild ( $ xml -> createElement ( 'Value' , $ trackingData [ 'value' ] ) ) ; $ container -> appendChild ( $ xml -> createElement ( 'ShipperNumber' , $ trackingData [ 'shipperNumber' ] ) ) ; } if ( ! empty ( $ labelSpecificationOpts ) ) { $ labelSpec = $ request -> appendChild ( $ xml -> createElement ( 'LabelSpecification' ) ) ; if ( isset ( $ labelSpecificationOpts [ 'userAgent' ] ) ) { $ labelSpec -> appendChild ( $ xml -> createElement ( 'HTTPUserAgent' , $ labelSpecificationOpts [ 'userAgent' ] ) ) ; } if ( isset ( $ labelSpecificationOpts [ 'imageFormat' ] ) ) { $ format = $ labelSpec -> appendChild ( $ xml -> createElement ( 'LabelImageFormat' ) ) ; $ format -> appendChild ( $ xml -> createElement ( 'Code' , $ labelSpecificationOpts [ 'imageFormat' ] ) ) ; } } if ( ! empty ( $ labelDeliveryOpts ) ) { $ labelDelivery = $ request -> appendChild ( $ xml -> createElement ( 'LabelDelivery' ) ) ; $ labelDelivery -> appendChild ( $ xml -> createElement ( 'LabelLinkIndicator' , $ labelDeliveryOpts [ 'link' ] ) ) ; } if ( ! empty ( $ translateOpts ) ) { $ translate = $ request -> appendChild ( $ xml -> createElement ( 'Translate' ) ) ; $ translate -> appendChild ( $ xml -> createElement ( 'LanguageCode' , $ translateOpts [ 'language' ] ) ) ; $ translate -> appendChild ( $ xml -> createElement ( 'DialectCode' , $ translateOpts [ 'dialect' ] ) ) ; $ translate -> appendChild ( $ xml -> createElement ( 'Code' , '01' ) ) ; } return $ xml -> saveXML ( ) ; }
3188	public function getFirstTimestamp ( $ tags ) { $ range = $ this -> getRange ( $ tags ) ; $ last = false ; if ( count ( $ range ) ) { $ last = $ range [ 0 ] -> getTimestamp ( ) ; } return $ last ; }
8617	public function setInvalidSKU ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'InvalidSKU' ] [ 'FieldValue' ] = $ value ; return $ this ; }
10446	protected function detectQueryType ( $ type ) { switch ( $ type ) { case 'INSERT INTO' : return ActionTypes :: CREATE ; case 'UPDATE' : return ActionTypes :: UPDATE ; case 'DELETE FROM' : return ActionTypes :: DELETE ; default : throw new \ UnexpectedValueException ( "Unknown statement of type {$type}" ) ; } }
3557	protected function setType ( $ value ) { $ this -> attributes [ 'meta_type' ] = $ this -> hasMutator ( $ value , 'setter' ) ? $ this -> getMutatedType ( $ value , 'setter' ) : $ this -> getValueType ( $ value ) ; }
1170	protected function createProtectedCaller ( $ instance ) { $ closure = function ( $ method , $ args ) { $ callable = [ $ this , $ method ] ; return call_user_func_array ( $ callable , $ args ) ; } ; return $ closure -> bindTo ( $ instance , $ instance ) ; }
1169	protected function purgeNonRemoteRules ( $ rules , $ validator ) { $ protectedValidator = $ this -> createProtectedCaller ( $ validator ) ; foreach ( $ rules as $ i => $ rule ) { $ parsedRule = ValidationRuleParser :: parse ( [ $ rule ] ) ; if ( ! $ this -> isRemoteRule ( $ parsedRule [ 0 ] ) ) { unset ( $ rules [ $ i ] ) ; } } return $ rules ; }
3817	private function fetchExisting ( $ table , $ parentId ) { $ this -> startSort = 0 ; $ this -> knownAttributes = [ ] ; $ alreadyExisting = $ this -> connection -> createQueryBuilder ( ) -> select ( '*' ) -> from ( $ table ) -> where ( 'pid=:pid' ) -> setParameter ( 'pid' , $ parentId ) -> orderBy ( 'sorting' ) -> execute ( ) ; foreach ( $ alreadyExisting -> fetchAll ( \ PDO :: FETCH_ASSOC ) as $ item ) { $ this -> knownAttributes [ $ item [ 'attr_id' ] ] = $ item ; $ this -> startSort = $ item [ 'sorting' ] ; } return $ this -> knownAttributes ; }
8095	public function add ( ) { if ( ! headers_sent ( ) ) { $ added = setcookie ( $ this -> name , $ this -> value , round ( time ( ) + 60 * 60 * 24 * $ this -> lifetime ) , $ this -> path , $ this -> host ) ; } else { echo "<script>" ; echo ' function setCookie(c_name,value,expiredays){ var exdate=new Date(); exdate.setDate(exdate.getDate()+expiredays); document.cookie=c_name+ "=" +escape(value)+((expiredays==null) ? "" : "; expires="+exdate.toUTCString()) + "; domain="+ escape("' . $ this -> host . '") + "; path=" + escape("' . $ this -> path . '"); } ' ; echo "setCookie('{$this->name}','{$this->value}',{$this->lifetime})" ; echo "</script>" ; $ added = true ; } return $ added ; }
3603	public function createJsonResponseFromException ( \ Exception $ exception , JsonRequest $ jsonRequest = null ) { $ jsonResponse = new JsonResponse ( ) ; if ( $ exception instanceof Exceptions \ ErrorException ) { $ jsonResponse -> setErrorCode ( 0 !== $ exception -> getCode ( ) ? $ exception -> getCode ( ) : - 32603 ) ; $ jsonResponse -> setErrorMessage ( ! empty ( $ exception -> getMessage ( ) ) ? $ exception -> getMessage ( ) : 'Internal error' ) ; $ jsonResponse -> setErrorData ( $ exception -> getData ( ) ) ; } else { $ jsonResponse -> setErrorCode ( 0 !== $ exception -> getCode ( ) ? $ exception -> getCode ( ) : - 32603 ) ; $ jsonResponse -> setErrorMessage ( ! empty ( $ exception -> getMessage ( ) ) ? $ exception -> getMessage ( ) : 'Internal error' ) ; } if ( $ jsonRequest ) { $ jsonResponse -> setId ( $ jsonRequest -> getId ( ) ) ; } return $ jsonResponse ; }
7594	public function render ( $ sLabelMessage , $ aLabelAttributes = 'label-default' ) { if ( ! is_scalar ( $ sLabelMessage ) ) { throw new InvalidArgumentException ( 'Label message expects a scalar value, "' . gettype ( $ sLabelMessage ) . '" given' ) ; } if ( empty ( $ aLabelAttributes ) ) { throw new InvalidArgumentException ( 'Label attributes are empty' ) ; } if ( is_string ( $ aLabelAttributes ) ) { $ aLabelAttributes = array ( 'class' => $ aLabelAttributes ) ; } elseif ( ! is_array ( $ aLabelAttributes ) ) { throw new InvalidArgumentException ( 'Label attributes expects a string or an array, "' . gettype ( $ aLabelAttributes ) . '" given' ) ; } elseif ( empty ( $ aLabelAttributes [ 'class' ] ) ) { throw new \ InvalidArgumentException ( 'Label "class" attribute is empty' ) ; } elseif ( ! is_string ( $ aLabelAttributes [ 'class' ] ) ) { throw new InvalidArgumentException ( 'Label "class" attribute expects string, "' . gettype ( $ aLabelAttributes ) . '" given' ) ; } if ( ! preg_match ( '/(\s|^)label(\s|$)/' , $ aLabelAttributes [ 'class' ] ) ) { $ aLabelAttributes [ 'class' ] .= ' label' ; } if ( null !== ( $ oTranslator = $ this -> getTranslator ( ) ) ) { $ sLabelMessage = $ oTranslator -> translate ( $ sLabelMessage , $ this -> getTranslatorTextDomain ( ) ) ; } return sprintf ( static :: $ labelFormat , isset ( $ aLabelAttributes [ 'tagName' ] ) ? $ aLabelAttributes [ 'tagName' ] : $ this -> tagName , $ this -> createAttributesString ( $ aLabelAttributes ) , $ sLabelMessage ) ; }
1050	public static function getDirectiveValues ( Directive $ directiveDef , $ node , $ variableValues = null ) { if ( isset ( $ node -> directives ) && $ node -> directives instanceof NodeList ) { $ directiveNode = Utils :: find ( $ node -> directives , static function ( DirectiveNode $ directive ) use ( $ directiveDef ) { return $ directive -> name -> value === $ directiveDef -> name ; } ) ; if ( $ directiveNode !== null ) { return self :: getArgumentValues ( $ directiveDef , $ directiveNode , $ variableValues ) ; } } return null ; }
11416	private function saveLog ( $ operId , $ calcId ) { $ entity = new ELogOper ( ) ; $ entity -> setOperId ( $ operId ) ; $ entity -> setCalcId ( $ calcId ) ; $ this -> daoLogOper -> create ( $ entity ) ; }
4369	public function buildTable ( $ rows , $ options = array ( ) ) { $ options = \ array_merge ( array ( 'attribs' => array ( ) , 'caption' => null , 'columns' => array ( ) , 'totalCols' => array ( ) , ) , $ options ) ; if ( \ is_string ( $ options [ 'attribs' ] ) ) { $ options [ 'attribs' ] = array ( 'class' => $ options [ 'attribs' ] , ) ; } if ( $ this -> debug -> abstracter -> isAbstraction ( $ rows ) && $ rows [ 'traverseValues' ] ) { $ options [ 'caption' ] .= ' (' . $ this -> markupClassname ( $ rows [ 'className' ] , 'span' , array ( 'title' => $ rows [ 'phpDoc' ] [ 'summary' ] ? : null , ) ) . ')' ; $ options [ 'caption' ] = \ trim ( $ options [ 'caption' ] ) ; $ rows = $ rows [ 'traverseValues' ] ; } $ keys = $ options [ 'columns' ] ? : $ this -> debug -> methodTable -> colKeys ( $ rows ) ; $ this -> tableInfo = array ( 'colClasses' => \ array_fill_keys ( $ keys , null ) , 'haveObjRow' => false , 'totals' => \ array_fill_keys ( $ options [ 'totalCols' ] , null ) , ) ; $ tBody = '' ; foreach ( $ rows as $ k => $ row ) { $ tBody .= $ this -> buildTableRow ( $ row , $ keys , $ k ) ; } if ( ! $ this -> tableInfo [ 'haveObjRow' ] ) { $ tBody = \ str_replace ( '<td class="t_classname"></td>' , '' , $ tBody ) ; } return $ this -> debug -> utilities -> buildTag ( 'table' , $ options [ 'attribs' ] , "\n" . ( $ options [ 'caption' ] ? '<caption>' . $ options [ 'caption' ] . '</caption>' . "\n" : '' ) . $ this -> buildTableHeader ( $ keys ) . '<tbody>' . "\n" . $ tBody . '</tbody>' . "\n" . $ this -> buildTableFooter ( $ keys ) ) ; }
6473	private function compareAcceptCharsetHeaders ( AcceptCharsetHeaderValue $ a , AcceptCharsetHeaderValue $ b ) : int { $ aQuality = $ a -> getQuality ( ) ; $ bQuality = $ b -> getQuality ( ) ; if ( $ aQuality < $ bQuality ) { return 1 ; } if ( $ aQuality > $ bQuality ) { return - 1 ; } $ aValue = $ a -> getCharset ( ) ; $ bValue = $ b -> getCharset ( ) ; if ( $ aValue === '*' ) { if ( $ bValue === '*' ) { return 0 ; } return 1 ; } if ( $ bValue === '*' ) { return - 1 ; } return 0 ; }
11337	public function getMigrationClassName ( ) { $ postfix = '_initial_' . $ this -> tableName ; if ( is_dir ( $ this -> migrationDirectory ) ) { $ searchExisting = FileHelper :: findFiles ( $ this -> migrationDirectory , [ 'only' => [ $ postfix . '.php' ] ] ) ; if ( ! empty ( $ searchExisting ) ) { return strstr ( basename ( $ searchExisting [ 0 ] ) , '.php' , true ) ; } } return 'm' . gmdate ( 'ymd_His' , $ this -> migrationTimestamp ) . $ postfix ; }
6098	protected function post ( $ endpoint , array $ parameters = [ ] , $ fireAndForget = false ) { return $ this -> call ( $ endpoint , $ parameters , self :: METHOD_POST , null , $ fireAndForget ) ; }
11212	protected function getFromLookup ( $ key ) { if ( $ key === $ this -> cache_key || $ this -> hasInLookup ( $ key ) ) { return $ this -> getFromRegistry ( $ this -> cache_reg , $ key ) ; } return null ; }
11796	public function setSubject ( $ subject = '' , $ clear = false ) { if ( true === $ clear ) { $ this -> clear ( 'subject' ) ; } $ this -> subject = $ subject ; return $ this ; }
2780	public function buildOptions ( ) : array { $ options = [ ] ; foreach ( $ this -> options as $ option => $ values ) { foreach ( ( array ) $ values as $ value ) { $ prefix = strlen ( $ option ) !== 1 ? '--' : '-' ; $ options [ ] = $ prefix . $ option ; if ( $ value !== true ) { $ options [ ] = $ value ; } } } return $ options ; }
6749	public function transformCollection ( $ collection ) { if ( is_object ( $ collection ) ) $ collection = $ collection -> toArray ( ) [ "data" ] ; return array_map ( [ $ this , "transform" ] , $ collection ) ; }
6529	public static function findOneUsingMixin ( $ mixin ) : Schema { $ schemas = self :: findAllUsingMixin ( $ mixin ) ; if ( 1 !== count ( $ schemas ) ) { throw new MoreThanOneMessageForMixin ( $ mixin , $ schemas ) ; } return current ( $ schemas ) ; }
8412	public function isConnected ( ) : bool { if ( isset ( $ this -> servers [ 'all' ] ) === true ) { return isset ( $ this -> servers [ 'all' ] [ 'link' ] ) ; } return isset ( $ this -> servers [ 'read' ] [ 'link' ] ) && isset ( $ this -> servers [ 'write' ] [ 'link' ] ) ; }
7741	public function addOperation ( OperationDefinition $ operation ) { if ( false === $ this -> supportsOperation ( $ operation -> getName ( ) ) ) { $ this -> operations [ ] = $ operation ; } return $ this ; }
7086	public function setOptionLabelColumnForDefaultOptionsLoader ( $ columnNameOrClosure ) { if ( ! is_string ( $ columnNameOrClosure ) && ! ( $ columnNameOrClosure instanceof DbExpr ) && ! ( $ columnNameOrClosure instanceof \ Closure ) ) { throw new \ InvalidArgumentException ( '$columnNameOrClosure argument must be a string, DbExpr or a Closure' ) ; } $ this -> optionLabelColumnForDefaultOptionsLoader = $ columnNameOrClosure ; return $ this ; }
956	public function isActiveTrial ( ) { return $ this -> isTrial ( ) && Carbon :: today ( ) -> lte ( Carbon :: parse ( $ this -> trial_ends_on ) ) ; }
11875	final public function getModuleDir ( ) { if ( ! $ this -> moduleDir ) { $ reflection = new ReflectionClass ( static :: class ) ; $ this -> moduleDir = dirname ( $ reflection -> getFileName ( ) ) ; } return $ this -> moduleDir ; }
9519	public function getPropertiesAsString ( ) { $ result = '' ; $ rFunction = new ReflectionFunction ( $ this -> parameterClosure ) ; if ( $ rFunction -> isVariadic ( ) ) { $ result .= '<' . $ rFunction -> getParameters ( ) [ 0 ] -> getName ( ) . ', ...>' ; } else { for ( $ i = 0 ; $ i < count ( $ rFunction -> getParameters ( ) ) ; $ i ++ ) { $ result .= ( $ result == '' ? '' : ' ' ) . '<' . $ rFunction -> getParameters ( ) [ $ i ] -> getName ( ) . '>' ; } } return $ result ; }
3918	private function checkDownloads ( ) { if ( $ this -> getShowImages ( ) ) { return ; } if ( ( $ file = Input :: get ( 'file' ) ) && ( $ key = Input :: get ( 'fileKey' ) ) ) { if ( ! ( array_key_exists ( $ file , $ _SESSION [ 'metaModels_downloads' ] ) && $ _SESSION [ 'metaModels_downloads' ] [ $ file ] === $ key ) ) { $ objHandler = new $ GLOBALS [ 'TL_PTY' ] [ 'error_403' ] ( ) ; $ objHandler -> generate ( $ file ) ; } Controller :: sendFileToBrowser ( $ file ) ; } }
10810	public function actionIndex ( $ option = null ) { $ allNames = [ 'web/assets' , 'runtime' , 'runtime/cache' , 'tests/_output' , ] ; $ answer = Select :: display ( 'Select objects' , $ allNames , 1 ) ; $ result = ClearHelper :: run ( $ answer ) ; if ( $ result ) { Output :: items ( $ result , "Clear completed: " . count ( $ result ) . " objects" ) ; } else { Output :: block ( "Not fount object for clear!" ) ; } }
7824	public function getHalfWidth ( $ up = false ) { $ number = $ this -> getTotalWidth ( ) ; return $ this -> roundHalf ( $ number , $ up ) ; }
597	public function one ( $ db = null ) { $ row = parent :: one ( $ db ) ; if ( $ row !== false ) { $ models = $ this -> populate ( [ $ row ] ) ; return reset ( $ models ) ? : null ; } return null ; }
3138	public function emptyResponse ( RunnerServiceContext $ context , $ responses ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ similar = 0 ; foreach ( $ responses as $ responseVariable ) { $ value = $ responseVariable -> getValue ( ) ; $ default = $ responseVariable -> getDefaultValue ( ) ; if ( TestRunnerUtils :: isQtiValueNull ( $ value ) === true ) { if ( TestRunnerUtils :: isQtiValueNull ( $ default ) === true ) { $ similar ++ ; } } elseif ( $ value -> equals ( $ default ) === true ) { $ similar ++ ; } } $ respCount = count ( $ responses ) ; return $ respCount > 0 && $ similar == $ respCount ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'storeItemResponse' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } }
7864	protected function drawPipesBeginning ( ) { foreach ( $ this -> pipes as $ pipe ) { $ this -> drawBorderTop ( ) ; $ this -> drawBordered ( $ this -> geometry -> getSpacedPipe ( $ pipe , static :: NOCK , 'before()' ) ) ; } }
9523	private function getConfig ( ) { $ yaml = new Parser ( ) ; $ configFile = getenv ( 'TRAVIS_BUILD_DIR' ) . '/.travis.yml' ; $ config = $ yaml -> parse ( file_get_contents ( $ configFile ) ) ; $ config = $ config [ 'travisdeployer' ] ; $ this -> branches = $ config [ 'branches' ] ; if ( count ( $ this -> branches ) === 0 ) { die ( 'No branches are configured to deploy to.' . PHP_EOL ) ; } $ this -> verbose = filter_input ( FILTER_VALIDATE_BOOLEAN , $ config [ 'verbose' ] ) ; }
9750	public function _savePps ( & $ raList ) { $ iC = count ( $ raList ) ; for ( $ i = 0 ; $ i < $ iC ; ++ $ i ) { fwrite ( $ this -> fileHandle , $ raList [ $ i ] -> _getPpsWk ( ) ) ; } $ iCnt = count ( $ raList ) ; $ iBCnt = $ this -> bigBlockSize / OLE :: OLE_PPS_SIZE ; if ( $ iCnt % $ iBCnt ) { fwrite ( $ this -> fileHandle , str_repeat ( "\x00" , ( $ iBCnt - ( $ iCnt % $ iBCnt ) ) * OLE :: OLE_PPS_SIZE ) ) ; } }
1048	public static function value ( $ rawString ) { $ lines = preg_split ( "/\\r\\n|[\\n\\r]/" , $ rawString ) ; $ commonIndent = null ; $ linesLength = count ( $ lines ) ; for ( $ i = 1 ; $ i < $ linesLength ; $ i ++ ) { $ line = $ lines [ $ i ] ; $ indent = self :: leadingWhitespace ( $ line ) ; if ( $ indent >= mb_strlen ( $ line ) || ( $ commonIndent !== null && $ indent >= $ commonIndent ) ) { continue ; } $ commonIndent = $ indent ; if ( $ commonIndent === 0 ) { break ; } } if ( $ commonIndent ) { for ( $ i = 1 ; $ i < $ linesLength ; $ i ++ ) { $ line = $ lines [ $ i ] ; $ lines [ $ i ] = mb_substr ( $ line , $ commonIndent ) ; } } while ( count ( $ lines ) > 0 && trim ( $ lines [ 0 ] , " \t" ) === '' ) { array_shift ( $ lines ) ; } while ( count ( $ lines ) > 0 && trim ( $ lines [ count ( $ lines ) - 1 ] , " \t" ) === '' ) { array_pop ( $ lines ) ; } return implode ( "\n" , $ lines ) ; }
11177	public function create ( ? string $ name = null ) { Whois :: print ( $ this -> getNotify ( ) ) ; $ this -> creator -> create ( $ this -> filesystem , $ name ) ; }
11160	public function resolve ( $ url , \ GuzzleHttp \ Message \ Response $ data , Event $ event , Queue $ queue ) { $ logger = $ this -> getLogger ( ) ; $ json = json_decode ( $ data -> getBody ( ) ) ; $ logger -> info ( 'resolve' , array ( 'url' => $ url , 'json' => $ json ) ) ; if ( isset ( $ json -> error ) ) { return $ logger -> warning ( 'Query response contained an error' , array ( 'url' => $ url , 'error' => $ json -> error , ) ) ; } $ entries = $ json -> items ; if ( ! is_array ( $ entries ) || ! $ entries ) { return $ logger -> warning ( 'Query returned no results' , array ( 'url' => $ url ) ) ; } $ entry = reset ( $ entries ) ; $ replacements = $ this -> getReplacements ( $ entry ) ; $ message = str_replace ( array_keys ( $ replacements ) , array_values ( $ replacements ) , $ this -> responseFormat ) ; $ queue -> ircPrivmsg ( $ event -> getSource ( ) , $ message ) ; }
2864	public function getLastFilePosition ( $ filePath ) { if ( ! file_exists ( $ filePath ) ) { return 0 ; } $ f = fopen ( $ filePath , 'r' ) ; fseek ( $ f , - 1 , SEEK_END ) ; return ftell ( $ f ) ; }
2286	protected static function agent ( ) { $ ua = static :: get ( 'httpUserAgent' ) ; $ return = new \ stdClass ( ) ; $ return -> string = $ ua ; $ os = 'unknown' ; $ mobile = false ; $ browser = 'other' ; $ shorty = '' ; $ version = '' ; $ engine = '' ; foreach ( Config :: get ( 'os' ) as $ k => $ v ) { if ( stripos ( $ ua , $ k ) !== false ) { $ os = $ v [ 'os' ] ; $ mobile = $ v [ 'mobile' ] ; break ; } } $ return -> os = $ os ; foreach ( Config :: get ( 'browser' ) as $ k => $ v ) { if ( stripos ( $ ua , $ k ) !== false ) { $ browser = $ v [ 'browser' ] ; $ shorty = $ v [ 'shorty' ] ; $ version = preg_replace ( $ v [ 'version' ] , '$1' , $ ua ) ; $ engine = $ v [ 'engine' ] ; break ; } } $ versions = explode ( '.' , $ version ) ; $ version = $ versions [ 0 ] ; $ return -> class = $ os . ' ' . $ browser . ' ' . $ engine ; if ( $ version != '' ) { $ return -> class .= ' ' . $ shorty . $ version ; } if ( $ os == 'android' && $ engine != 'presto' && stripos ( $ ua , 'mobile' ) === false ) { $ mobile = false ; } if ( $ mobile ) { $ return -> class .= ' mobile' ; } $ return -> browser = $ browser ; $ return -> shorty = $ shorty ; $ return -> version = $ version ; $ return -> engine = $ engine ; $ return -> versions = $ versions ; $ return -> mobile = $ mobile ; return $ return ; }
2207	protected function compileYearlyMenu ( ) { $ arrData = array ( ) ; $ arrAllEvents = $ this -> getAllEvents ( $ this -> cal_calendar , 0 , 2145913200 ) ; foreach ( $ arrAllEvents as $ intDay => $ arrDay ) { foreach ( $ arrDay as $ arrEvents ) { $ arrData [ substr ( $ intDay , 0 , 4 ) ] += \ count ( $ arrEvents ) ; } } ( $ this -> cal_order == 'ascending' ) ? ksort ( $ arrData ) : krsort ( $ arrData ) ; $ arrItems = array ( ) ; $ count = 0 ; $ limit = \ count ( $ arrData ) ; foreach ( $ arrData as $ intYear => $ intCount ) { $ intDate = $ intYear ; $ quantity = sprintf ( ( ( $ intCount < 2 ) ? $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'entry' ] : $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'entries' ] ) , $ intCount ) ; $ arrItems [ $ intYear ] [ 'date' ] = $ intDate ; $ arrItems [ $ intYear ] [ 'link' ] = $ intYear ; $ arrItems [ $ intYear ] [ 'href' ] = $ this -> strLink . '?year=' . $ intDate ; $ arrItems [ $ intYear ] [ 'title' ] = StringUtil :: specialchars ( $ intYear . ' (' . $ quantity . ')' ) ; $ arrItems [ $ intYear ] [ 'class' ] = trim ( ( ( ++ $ count == 1 ) ? 'first ' : '' ) . ( ( $ count == $ limit ) ? 'last' : '' ) ) ; $ arrItems [ $ intYear ] [ 'isActive' ] = ( Input :: get ( 'year' ) == $ intDate ) ; $ arrItems [ $ intYear ] [ 'quantity' ] = $ quantity ; } $ this -> Template -> yearly = true ; $ this -> Template -> items = $ arrItems ; $ this -> Template -> showQuantity = ( $ this -> cal_showQuantity != '' ) ? true : false ; }
3373	public function indexAction ( ) { $ request = $ this -> getRequest ( ) ; $ this -> httpClient -> setMethod ( Request :: METHOD_POST ) ; $ this -> httpClient -> setParameterPost ( [ 'dsl_text' => $ request -> getPost ( 'dsl_text' ) ] ) ; $ response = $ this -> httpClient -> send ( ) ; if ( ! $ response -> isSuccess ( ) ) { throw new \ UnexpectedValueException ( 'HTTP Request failed' ) ; } $ redirect = $ this -> plugin ( 'redirect' ) ; return $ redirect -> toUrl ( 'https://yuml.me/' . $ response -> getBody ( ) ) ; }
10276	public static function getTextWidthPixelsApprox ( $ columnText , \ PhpOffice \ PhpSpreadsheet \ Style \ Font $ font , $ rotation = 0 ) { $ fontName = $ font -> getName ( ) ; $ fontSize = $ font -> getSize ( ) ; switch ( $ fontName ) { case 'Calibri' : $ columnWidth = ( int ) ( 8.26 * StringHelper :: countCharacters ( $ columnText ) ) ; $ columnWidth = $ columnWidth * $ fontSize / 11 ; break ; case 'Arial' : $ columnWidth = ( int ) ( 8 * StringHelper :: countCharacters ( $ columnText ) ) ; $ columnWidth = $ columnWidth * $ fontSize / 10 ; break ; case 'Verdana' : $ columnWidth = ( int ) ( 8 * StringHelper :: countCharacters ( $ columnText ) ) ; $ columnWidth = $ columnWidth * $ fontSize / 10 ; break ; default : $ columnWidth = ( int ) ( 8.26 * StringHelper :: countCharacters ( $ columnText ) ) ; $ columnWidth = $ columnWidth * $ fontSize / 11 ; break ; } if ( $ rotation !== 0 ) { if ( $ rotation == - 165 ) { $ columnWidth = 4 ; } else { $ columnWidth = $ columnWidth * cos ( deg2rad ( $ rotation ) ) + $ fontSize * abs ( sin ( deg2rad ( $ rotation ) ) ) / 5 ; } } return ( int ) $ columnWidth ; }
1771	public function generateWithError ( $ blnSwitchOrder = false ) { $ strWidget = $ this -> generate ( ) ; $ strError = $ this -> getErrorAsHTML ( ) ; return $ blnSwitchOrder ? $ strWidget . $ strError : $ strError . $ strWidget ; }
10818	public static function error ( $ messages , $ linebreak = true , $ length = 0 ) { $ separator = $ linebreak ? "\n" : '' ; self :: write ( $ messages , 'error' , $ length , $ separator ) ; }
4550	public function setAssigneeLike ( ? string $ assigneeLike ) { $ this -> assigneeLike = $ assigneeLike ; $ this -> _assigneeLike = null !== $ assigneeLike ; return $ this ; }
11071	public function setInteger ( string $ key , $ value , int $ ignoredDefaultValue = null ) { $ this -> set ( $ key , ( int ) $ value , $ ignoredDefaultValue ) ; return $ this ; }
1036	private function completeAbstractValue ( AbstractType $ returnType , $ fieldNodes , ResolveInfo $ info , $ path , & $ result ) { $ exeContext = $ this -> exeContext ; $ runtimeType = $ returnType -> resolveType ( $ result , $ exeContext -> contextValue , $ info ) ; if ( $ runtimeType === null ) { $ runtimeType = self :: defaultTypeResolver ( $ result , $ exeContext -> contextValue , $ info , $ returnType ) ; } $ promise = $ this -> getPromise ( $ runtimeType ) ; if ( $ promise ) { return $ promise -> then ( function ( $ resolvedRuntimeType ) use ( $ returnType , $ fieldNodes , $ info , $ path , & $ result ) { return $ this -> completeObjectValue ( $ this -> ensureValidRuntimeType ( $ resolvedRuntimeType , $ returnType , $ info , $ result ) , $ fieldNodes , $ info , $ path , $ result ) ; } ) ; } return $ this -> completeObjectValue ( $ this -> ensureValidRuntimeType ( $ runtimeType , $ returnType , $ info , $ result ) , $ fieldNodes , $ info , $ path , $ result ) ; }
3187	public function end ( $ tags , $ timestamp ) { if ( ! is_numeric ( $ timestamp ) || $ timestamp < 0 ) { throw new InvalidDataException ( 'end() needs a valid timestamp!' ) ; } $ range = $ this -> getRange ( $ tags ) ; if ( $ this -> isRangeOpen ( $ range ) ) { $ this -> checkTimestampCoherence ( $ range , $ timestamp ) ; $ point = new TimePoint ( $ tags , $ timestamp , TimePoint :: TYPE_END , TimePoint :: TARGET_SERVER ) ; $ this -> timeLine -> add ( $ point ) ; } else { \ common_Logger :: t ( 'Range already closed, or missing START TimePoint in QtiTimer, continue anyway' ) ; } return $ this ; }
8037	public static function revert ( $ input , $ inputFormat = Code :: FORMAT_ALNUM , $ minLength = null ) { $ number = self :: convertBase ( $ input , $ inputFormat , Code :: FORMAT_NUMBER ) ; if ( is_int ( $ minLength ) ) { $ number -= self :: getMinForlength ( $ inputFormat , $ minLength ) ; } return $ number ; }
2239	private function addDefaultServerVersion ( array $ extensionConfigs , ContainerBuilder $ container ) : array { $ params = [ ] ; foreach ( $ extensionConfigs as $ extensionConfig ) { if ( isset ( $ extensionConfig [ 'dbal' ] [ 'connections' ] [ 'default' ] ) ) { $ params [ ] = $ extensionConfig [ 'dbal' ] [ 'connections' ] [ 'default' ] ; } } if ( ! empty ( $ params ) ) { $ params = array_merge ( ... $ params ) ; } $ parameterBag = $ container -> getParameterBag ( ) ; foreach ( $ params as $ key => $ value ) { $ params [ $ key ] = $ parameterBag -> resolveValue ( $ value ) ; } try { $ connection = DriverManager :: getConnection ( $ params ) ; $ connection -> connect ( ) ; $ connection -> close ( ) ; } catch ( DriverException $ e ) { $ extensionConfigs [ ] = [ 'dbal' => [ 'connections' => [ 'default' => [ 'server_version' => '5.5' , ] , ] , ] , ] ; } return $ extensionConfigs ; }
1313	public function setRetries ( $ maxRetries , $ retriesDelay ) { $ this -> maxRetries = ( int ) $ maxRetries ; $ this -> retriesDelay = ( int ) $ retriesDelay ; }
7393	public function unserialize ( $ serialized ) : void { $ this -> _initMetaData ( ) ; $ data = unserialize ( $ serialized ) ; foreach ( $ data as $ k => $ v ) { $ this -> { $ k } = $ v ; } }
5754	protected function setIndexFilter ( Request $ request , Response $ response , $ args , array $ listViewColumns , AdminListView $ view ) { $ this -> setRequestInput ( $ request , [ $ view -> getSessionFilterFieldKey ( ) ] ) ; if ( ! isset ( $ this -> requestInput [ $ view -> getSessionFilterFieldKey ( ) ] ) ) { throw new \ Exception ( "session filter input must be set" ) ; } $ this -> storeFilterFieldValueInSession ( $ view ) ; if ( null !== $ filterColumnsInfo = $ this -> getFilterColumns ( $ view -> getSessionFilterFieldKey ( ) , $ listViewColumns ) ) { $ this -> storeFilterColumnsInfoInSession ( $ filterColumnsInfo , $ view ) ; } }
7277	public function time ( $ timestamp = false ) { return $ timestamp ? ( new DateTime ( $ this -> time ) ) -> getTimestamp ( ) : $ this -> time ; }
5485	public function hasImage ( SelectorInterface $ selector ) { foreach ( $ this -> images as $ image ) { if ( $ selector -> isMatch ( $ image ) ) { return true ; } } return false ; }
1189	protected function isImplemented ( $ rule ) { return in_array ( $ rule , $ this -> clientRules ) || in_array ( $ rule , $ this -> serverRules ) ; }
4572	public function setIdentityUuid ( ? string $ identityUuid ) { if ( null !== $ identityUuid ) { if ( ! preg_match ( '/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i' , $ identityUuid ) ) { throw new InvalidArgumentException ( 'Identity uuid is not valid.' ) ; } } $ this -> identityUuid = $ identityUuid ; return $ this ; }
3408	public function getLockFactory ( ) : Factory { if ( $ this -> lockFactory !== null ) { return $ this -> lockFactory ; } if ( ! is_dir ( $ this -> lockPath ) ) { ( new Filesystem ( ) ) -> mkdir ( $ this -> lockPath ) ; } $ store = new FlockStore ( $ this -> lockPath ) ; return $ this -> setLockStore ( $ store ) ; }
59	public function addPackage ( $ source , $ target , $ reason ) { $ this -> suggestedPackages [ ] = array ( 'source' => $ source , 'target' => $ target , 'reason' => $ reason , ) ; return $ this ; }
7468	protected function colorize ( $ str , $ attrs ) { $ start = $ this -> start ( $ attrs ) ; return $ start . $ str . $ this -> end ( ) ; }
3237	public function getTotalAttribute ( ) { if ( empty ( $ this -> shopCalculations ) ) $ this -> runCalculations ( ) ; return $ this -> totalPrice + $ this -> totalTax + $ this -> totalShipping ; }
4473	public function heartbeat ( array $ data = [ ] ) : float { try { $ this -> expires = $ this -> client -> heartbeat ( $ this -> jid , $ this -> worker , json_encode ( $ data , JSON_UNESCAPED_SLASHES ) ) ; } catch ( QlessException $ e ) { throw new LostLockException ( $ e -> getMessage ( ) , 'Heartbeat' , $ this -> jid , $ e -> getCode ( ) , $ e ) ; } return $ this -> expires ; }
12646	public function setTrue ( $ obData = null ) { $ this -> bStatus = true ; $ this -> obData = $ obData ; return $ this ; }
2135	public static function preload ( ) { include __DIR__ . '/../../config/default.php' ; include __DIR__ . '/../../config/agents.php' ; include __DIR__ . '/../../config/mimetypes.php' ; $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( ( $ blnHasLcf = file_exists ( $ rootDir . '/system/config/localconfig.php' ) ) === true ) { include $ rootDir . '/system/config/localconfig.php' ; } static :: loadParameters ( ) ; static :: $ blnHasLcf = $ blnHasLcf ; }
12543	public function getLink ( ) : string { if ( $ this -> link === null ) { return str_replace ( "?" . $ _SERVER [ "QUERY_STRING" ] , "" , $ _SERVER [ "REQUEST_URI" ] ) ; } else { return $ this -> link ; } }
926	public function getLintErrors ( ) { return array_filter ( $ this -> errors , static function ( Error $ error ) { return Error :: TYPE_LINT === $ error -> getType ( ) ; } ) ; }
9694	public function canRead ( $ pFilename ) { try { $ this -> openFile ( $ pFilename ) ; } catch ( Exception $ e ) { return false ; } $ beginning = $ this -> readBeginning ( ) ; $ startWithTag = self :: startsWithTag ( $ beginning ) ; $ containsTags = self :: containsTags ( $ beginning ) ; $ endsWithTag = self :: endsWithTag ( $ this -> readEnding ( ) ) ; fclose ( $ this -> fileHandle ) ; return $ startWithTag && $ containsTags && $ endsWithTag ; }
3254	private function getItem ( $ sku ) { $ className = Config :: get ( 'shop.item' ) ; $ item = new $ className ( ) ; return $ item -> where ( 'sku' , $ sku ) -> where ( 'cart_id' , $ this -> attributes [ 'id' ] ) -> first ( ) ; }
4817	public function insertRowBefore ( $ rowNumber , $ row = null ) { if ( $ rowNumber > count ( $ this -> collection ) ) { $ this -> appendRow ( $ row ) ; } else { $ singleRow = $ row ; if ( ! ( $ row instanceof Row ) ) { $ singleRow = new Row ( $ row ) ; } array_splice ( $ this -> collection , $ rowNumber , 0 , '' ) ; $ this -> collection [ $ rowNumber ] = $ singleRow ; } }
3974	protected function build ( IMetaModelDataDefinition $ container ) { $ inputScreen = $ this -> viewCombination -> getScreen ( $ container -> getName ( ) ) ; if ( ! $ inputScreen ) { return ; } $ meta = $ inputScreen [ 'meta' ] ; $ config = $ this -> getDataProviderDefinition ( $ container ) ; if ( ! $ config -> hasInformation ( $ container -> getName ( ) ) ) { $ providerInformation = new ContaoDataProviderInformation ( ) ; $ providerInformation -> setName ( $ container -> getName ( ) ) ; $ config -> addInformation ( $ providerInformation ) ; } else { $ providerInformation = $ config -> getInformation ( $ container -> getName ( ) ) ; } $ basicDefinition = $ container -> getBasicDefinition ( ) ; if ( $ providerInformation instanceof ContaoDataProviderInformation ) { $ providerInformation -> setTableName ( $ container -> getName ( ) ) -> setClassName ( Driver :: class ) -> setInitializationData ( [ 'source' => $ container -> getName ( ) ] ) -> setVersioningEnabled ( false ) ; $ basicDefinition -> setDataProvider ( $ container -> getName ( ) ) ; } if ( $ basicDefinition -> getMode ( ) == BasicDefinitionInterface :: MODE_HIERARCHICAL ) { $ basicDefinition -> setRootDataProvider ( $ container -> getName ( ) ) ; } if ( 'ctable' === $ meta [ 'rendertype' ] ) { $ parentTable = $ meta [ 'ptable' ] ; if ( ! $ config -> hasInformation ( $ parentTable ) ) { $ providerInformation = new ContaoDataProviderInformation ( ) ; $ providerInformation -> setName ( $ parentTable ) ; $ config -> addInformation ( $ providerInformation ) ; } else { $ providerInformation = $ config -> getInformation ( $ parentTable ) ; } if ( $ providerInformation instanceof ContaoDataProviderInformation ) { $ providerInformation -> setTableName ( $ parentTable ) -> setInitializationData ( [ 'source' => $ parentTable ] ) ; if ( in_array ( $ parentTable , $ this -> factory -> collectNames ( ) ) ) { $ providerInformation -> setClassName ( Driver :: class ) ; } $ basicDefinition -> setParentDataProvider ( $ parentTable ) ; } } }
9598	protected function flashInput ( Request $ request = null ) { if ( $ request === null ) { $ request = $ this -> container -> resolve ( 'Symfony\Component\HttpFoundation\RequestStack' ) -> getCurrentRequest ( ) ; } $ this -> flash ( '_old_input' , $ request -> request -> all ( ) ) ; }
2290	protected function addRecipient ( $ strEmail , $ arrNew ) { if ( ( $ objOld = NewsletterRecipientsModel :: findOldSubscriptionsByEmailAndPids ( $ strEmail , $ arrNew ) ) !== null ) { while ( $ objOld -> next ( ) ) { $ objOld -> delete ( ) ; } } $ time = time ( ) ; $ arrRelated = array ( ) ; foreach ( $ arrNew as $ id ) { $ objRecipient = new NewsletterRecipientsModel ( ) ; $ objRecipient -> pid = $ id ; $ objRecipient -> tstamp = $ time ; $ objRecipient -> email = $ strEmail ; $ objRecipient -> active = '' ; $ objRecipient -> addedOn = $ time ; $ objRecipient -> save ( ) ; if ( ( $ objBlacklist = NewsletterBlacklistModel :: findByHashAndPid ( md5 ( $ strEmail ) , $ id ) ) !== null ) { $ objBlacklist -> delete ( ) ; } $ arrRelated [ 'tl_newsletter_recipients' ] [ ] = $ objRecipient -> id ; } $ optIn = System :: getContainer ( ) -> get ( 'contao.opt-in' ) ; $ optInToken = $ optIn -> create ( 'nl' , $ strEmail , $ arrRelated ) ; $ objChannel = NewsletterChannelModel :: findByIds ( $ arrNew ) ; $ arrData = array ( ) ; $ arrData [ 'token' ] = $ optInToken -> getIdentifier ( ) ; $ arrData [ 'domain' ] = Idna :: decode ( Environment :: get ( 'host' ) ) ; $ arrData [ 'link' ] = Idna :: decode ( Environment :: get ( 'base' ) ) . Environment :: get ( 'request' ) . ( ( strpos ( Environment :: get ( 'request' ) , '?' ) !== false ) ? '&' : '?' ) . 'token=' . $ optInToken -> getIdentifier ( ) ; $ arrData [ 'channel' ] = $ arrData [ 'channels' ] = implode ( "\n" , $ objChannel -> fetchEach ( 'title' ) ) ; $ optInToken -> send ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'nl_subject' ] , Idna :: decode ( Environment :: get ( 'host' ) ) ) , StringUtil :: parseSimpleTokens ( $ this -> nl_subscribe , $ arrData ) ) ; if ( ( $ objTarget = $ this -> objModel -> getRelated ( 'jumpTo' ) ) instanceof PageModel ) { $ this -> redirect ( $ objTarget -> getFrontendUrl ( ) ) ; } System :: getContainer ( ) -> get ( 'session' ) -> getFlashBag ( ) -> set ( 'nl_confirm' , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'nl_confirm' ] ) ; $ this -> reload ( ) ; }
8127	public static function findByUsernameOrEmail ( $ emailOrUsername ) { if ( filter_var ( $ emailOrUsername , FILTER_VALIDATE_EMAIL ) ) { return UserIdentity :: findByEmail ( $ emailOrUsername ) ; } return UserIdentity :: findByUsername ( $ emailOrUsername ) ; }
5995	public function addFolderResponse ( $ item ) { if ( ! ( $ item instanceof self ) ) { if ( is_array ( $ item ) ) { try { $ item = new self ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate FolderResponse. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "FolderResponse"!' , E_USER_WARNING ) ; } } $ this -> subFolders [ ] = $ item ; return $ this ; }
5414	public function getRequestLine ( $ method ) { $ url = $ this -> getUrl ( ) ; $ scheme = $ url -> getScheme ( ) ? $ url -> getScheme ( ) : 'http' ; $ port = $ url -> getPort ( ) ? ':' . $ url -> getPort ( ) : '' ; return $ method . ' ' . $ scheme . '://' . $ url -> getHost ( ) . $ port . $ url -> getPath ( ) . $ url -> getEncodedRequest ( ) . ' HTTP/1.0' ; }
2057	public function checkRootType ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ varValue != 'root' && $ dc -> activeRecord -> pid == 0 ) { throw new Exception ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'topLevelRoot' ] ) ; } return $ varValue ; }
853	public function getNonEmptySibling ( $ index , $ direction ) { while ( true ) { $ index += $ direction ; if ( ! $ this -> offsetExists ( $ index ) ) { return null ; } if ( ! $ this -> isEmptyAt ( $ index ) ) { return $ index ; } } }
9778	function writable ( ) : self { if ( ! $ this -> hasFlag ( 'directory' ) && ! $ this -> hasFlag ( 'file' ) ) throw new \ BadMethodCallException ( 'This assertion is not a file or directory one.' ) ; return $ this -> expect ( $ this -> target , isWritable ( ) ) ; }
12480	protected function findSlotsInTemplates ( ) { $ templates = $ this -> findTemplates ( ) ; $ slots = array ( ) ; foreach ( $ templates [ "base" ] as $ templateName => $ templateFile ) { $ templateContents = FilesystemTools :: readFile ( $ templateFile ) ; $ slots = array_merge_recursive ( $ slots , $ this -> findSlots ( $ templateName , $ templateContents ) ) ; } $ baseSlots [ "base" ] = $ slots ; $ slots = array ( ) ; foreach ( $ templates [ "template" ] as $ templateName => $ templateFile ) { $ templateContents = FilesystemTools :: readFile ( $ templateFile ) ; $ slots [ $ templateName ] = $ this -> findSlots ( $ templateName , $ templateContents ) ; } return array ( 'base' => $ baseSlots , 'templates' => $ slots , ) ; }
12117	public static function displayConsoleException ( \ Throwable $ Throwable ) { ob_start ( ) ; echo PHP_EOL . ' ' ; echo ( ( $ Throwable instanceof PHPAssertionFailed ) ? 'Assertion Failed' : 'Uncaught ' . self :: getShortName ( get_class ( $ Throwable ) ) ) ; echo ' <' . basename ( $ Throwable -> getFile ( ) ) . ':' . $ Throwable -> getLine ( ) . '>' ; echo PHP_EOL . PHP_EOL . ' ' ; if ( $ Throwable instanceof PHPAssertionFailed ) { $ message = $ Throwable -> getExpression ( ) ; if ( $ message == '' ) { $ message = 'false' ; } } else { $ message = $ Throwable -> getMessage ( ) ; } echo wordwrap ( $ message , self :: CONSOLE_WIDTH - 2 , PHP_EOL . ' ' ) ; echo PHP_EOL . PHP_EOL . ' Stack Trace:' . PHP_EOL . PHP_EOL ; if ( $ Throwable instanceof BaseException || $ Throwable instanceof PHPErrorException ) { $ trace = $ Throwable -> getStackTrace ( ) ; } else { $ trace = array_reverse ( $ Throwable -> getTrace ( ) ) ; } $ trace_empty = [ 'class' => '' , 'type' => '' , 'function' => '' , 'file' => '{unknown}' , 'line' => 0 ] ; foreach ( $ trace as $ key => $ trace_item ) { $ trace_item = array_merge ( $ trace_empty , $ trace_item ) ; $ trace_item [ 'file' ] = basename ( $ trace_item [ 'file' ] ) ; if ( $ trace_item [ 'function' ] != '{closure}' ) { $ trace_item [ 'function' ] .= '()' ; } $ key ++ ; echo str_pad ( " $key. " , 6 , ' ' ) ; echo self :: getShortName ( $ trace_item [ 'class' ] ) . $ trace_item [ 'type' ] . $ trace_item [ 'function' ] ; echo " <{$trace_item['file']}:{$trace_item['line']}>" . PHP_EOL ; } return ob_get_clean ( ) ; }
3370	private function getClassByName ( $ className ) { if ( ! isset ( $ this -> classByNames [ $ className ] ) ) { foreach ( $ this -> metadata as $ class ) { if ( $ class -> getName ( ) === $ className ) { $ this -> classByNames [ $ className ] = $ class ; break ; } } } return $ this -> classByNames [ $ className ] ?? null ; }
1859	public function copy ( $ strSource , $ strDestination ) { $ this -> validate ( $ strSource , $ strDestination ) ; return copy ( $ this -> strRootDir . '/' . $ strSource , $ this -> strRootDir . '/' . $ strDestination ) ; }
2337	private function setLegacyOptions ( Table $ table ) : void { if ( ! $ table -> hasOption ( 'engine' ) ) { $ table -> addOption ( 'engine' , 'MyISAM' ) ; } if ( ! $ table -> hasOption ( 'charset' ) ) { $ table -> addOption ( 'charset' , 'utf8' ) ; } if ( ! $ table -> hasOption ( 'collate' ) ) { $ table -> addOption ( 'collate' , 'utf8_general_ci' ) ; } }
3567	public function toArray ( ) { return function ( $ next , $ attributes ) { unset ( $ attributes [ 'meta_attributes' ] , $ attributes [ 'metaAttributes' ] ) ; $ attributes = array_merge ( $ attributes , $ this -> getMetaAttributesArray ( ) ) ; return $ next ( $ attributes ) ; } ; }
8770	protected function bindPathsInContainer ( ) { $ this -> instance ( 'path' , $ this -> path ( ) ) ; $ this -> instance ( 'path.base' , $ this -> basePath ( ) ) ; $ this -> instance ( 'path.lang' , $ this -> langPath ( ) ) ; $ this -> instance ( 'path.config' , $ this -> configPath ( ) ) ; $ this -> instance ( 'path.storage' , $ this -> storagePath ( ) ) ; $ this -> instance ( 'path.database' , $ this -> databasePath ( ) ) ; $ this -> instance ( 'path.cache' , $ this -> cachePath ( ) ) ; $ this -> instance ( 'path.public' , $ this -> publicPath ( ) ) ; }
12903	private function createCacheAdapter ( ) { $ extraData = & $ this -> extraData ; return new CallbackAdapter ( function ( Request $ request ) use ( & $ extraData ) { $ poolName = 'default' ; if ( isset ( $ this -> source [ 'cache' ] [ 'pool' ] ) ) { $ poolName = $ this -> source [ 'cache' ] [ 'pool' ] ; } $ adapter = new CacheAdapter ( $ this -> registry -> getCachePool ( $ poolName ) , new HttpApiAdapter ( ) , function ( Request $ request ) { $ data = $ request -> getData ( ) ; return $ this -> registry -> generateCacheItemKey ( sprintf ( '%s.%s.%s' , $ data [ 'service' ] , $ data [ 'group' ] , $ data [ 'action' ] ) , $ data [ 'arguments' ] ) ; } ) ; $ response = $ adapter -> receive ( $ request ) ; $ extraData = $ response -> getHeaders ( ) ; return $ response ; } ) ; }
12538	public function setRelations ( $ value ) { if ( $ this -> companionObject ) { $ baseObject = $ this -> companionObject ; } else { $ baseObject = $ this -> owner ; } $ fields = $ baseObject -> getFields ( ) ; foreach ( $ value as $ tabId => $ relation ) { if ( ! isset ( $ relation [ '_moduleHandler' ] ) ) { \ d ( "boom" ) ; exit ; continue ; } if ( ! isset ( $ fields [ $ relation [ '_moduleHandler' ] ] ) ) { \ d ( $ relation [ '_moduleHandler' ] ) ; \ d ( array_keys ( $ fields ) ) ; exit ; continue ; } $ baseAttributes = [ ] ; $ model = $ fields [ $ relation [ '_moduleHandler' ] ] -> model ; if ( empty ( $ model ) ) { $ model = $ fields [ $ relation [ '_moduleHandler' ] ] -> resetModel ( ) ; } $ model -> attributes = $ relation ; $ model -> _moduleHandler = $ relation [ '_moduleHandler' ] ; $ model -> tabularId = $ relation [ '_moduleHandler' ] ; list ( $ relationship , $ role ) = $ baseObject -> objectType -> getRelationship ( $ model -> _moduleHandler ) ; $ relatedHandler = $ baseObject -> objectType -> getRelatedType ( $ model -> _moduleHandler ) ; if ( ! $ relatedHandler ) { continue ; } if ( ! $ this -> owner -> tabularId && ! $ this -> owner -> isNewRecord && empty ( $ model -> parent_object_id ) && empty ( $ model -> child_object_id ) ) { continue ; } $ this -> _relations [ $ tabId ] = $ model ; } }
2778	public function cloneRepository ( string $ repository , ? string $ directory = null , array $ options = [ ] ) : GitWorkingCopy { if ( $ directory === null ) { $ directory = self :: parseRepositoryName ( $ repository ) ; } $ git = $ this -> workingCopy ( $ directory ) ; $ git -> cloneRepository ( $ repository , $ options ) ; $ git -> setCloned ( true ) ; return $ git ; }
5551	public function getMimeType ( ) { if ( is_integer ( $ this -> focus ) ) { return $ this -> frames [ $ this -> focus ] -> getMimeType ( ) ; } return $ this -> frameset -> getMimeType ( ) ; }
7736	private function documentProperties ( ClassMetadata $ metadata , ReflectionClass $ class ) { $ properties = array ( ) ; $ elements = array_merge ( $ class -> getProperties ( ) , $ class -> getMethods ( ) ) ; foreach ( $ elements as $ element ) { $ annotation = $ this -> getAnnotation ( $ element , 'ML\HydraBundle\Mapping\Expose' ) ; if ( null === $ annotation ) { continue ; } $ property = new PropertyDefinition ( $ class -> name , $ element -> name ) ; $ property -> setExposeAs ( $ annotation -> as ) ; $ property -> setIri ( $ annotation -> getIri ( ) ) ; if ( null !== $ annotation -> required ) { $ property -> setRequired ( $ annotation -> required ) ; } if ( null !== $ annotation -> readonly ) { $ property -> setReadOnly ( $ annotation -> readonly ) ; } if ( null !== $ annotation -> writeonly ) { $ property -> setWriteOnly ( $ annotation -> writeonly ) ; } $ tmp = $ this -> getDocBlockText ( $ element ) ; $ property -> setTitle ( $ tmp [ 'title' ] ) ; $ property -> setDescription ( $ tmp [ 'description' ] ) ; $ tmp = $ this -> getType ( $ element ) ; $ property -> setType ( $ tmp [ 'type' ] ) ; $ this -> documentRouteAndOperations ( $ property , $ element ) ; if ( null !== ( $ annotation = $ this -> getAnnotation ( $ element , 'ML\HydraBundle\Mapping\Collection' ) ) ) { $ property -> setRoute ( $ this -> getRouteMetadata ( $ annotation -> route ) ) ; if ( false === $ property -> supportsOperation ( $ annotation -> route ) ) { $ property -> addOperation ( $ this -> getRouteMetadata ( $ annotation -> route ) ) ; } $ property -> setType ( 'ML\HydraBundle\Entity\Collection' ) ; $ property -> setReadOnly ( true ) ; } $ properties [ ] = $ property ; } $ metadata -> setProperties ( $ properties ) ; }
9884	private function writeNamedRanges ( XMLWriter $ objWriter , Spreadsheet $ spreadsheet ) { $ namedRanges = $ spreadsheet -> getNamedRanges ( ) ; foreach ( $ namedRanges as $ namedRange ) { $ this -> writeDefinedNameForNamedRange ( $ objWriter , $ namedRange ) ; } }
5276	public function orderBy ( $ columns , $ direction = 'asc' ) { if ( is_string ( $ columns ) ) { $ columns = $ this -> argument_to_array ( $ columns ) ; } foreach ( $ columns as $ key => $ column ) { if ( is_numeric ( $ key ) ) { $ this -> statements [ 'orders' ] [ $ column ] = $ direction ; } else { $ this -> statements [ 'orders' ] [ $ key ] = $ column ; } } return $ this ; }
7682	function Ext_DeductFormat ( & $ Ext , $ Search ) { if ( strpos ( ',odt,ods,odg,odf,odp,odm,ott,ots,otg,otp,' , ',' . $ Ext . ',' ) !== false ) return 'odf' ; if ( strpos ( ',docx,xlsx,xlsm,pptx,' , ',' . $ Ext . ',' ) !== false ) return 'openxml' ; if ( ! $ Search ) return false ; if ( $ this -> FileExists ( 'content.xml' ) ) { if ( $ this -> FileExists ( 'META-INF/manifest.xml' ) ) { $ Ext = '?' ; return 'odf' ; } } elseif ( $ this -> FileExists ( '[Content_Types].xml' ) ) { if ( $ this -> FileExists ( 'word/document.xml' ) ) { $ Ext = 'docx' ; return 'openxml' ; } elseif ( $ this -> FileExists ( 'xl/workbook.xml' ) ) { $ Ext = 'xlsx' ; return 'openxml' ; } elseif ( $ this -> FileExists ( 'ppt/presentation.xml' ) ) { $ Ext = 'pptx' ; return 'openxml' ; } } return false ; }
4385	protected function dumpObject ( $ abs ) { $ isNested = $ this -> valueDepth > 0 ; $ this -> valueDepth ++ ; if ( $ abs [ 'isRecursion' ] ) { $ str = '(object) ' . $ abs [ 'className' ] . ' *RECURSION*' ; } elseif ( $ abs [ 'isExcluded' ] ) { $ str = '(object) ' . $ abs [ 'className' ] . ' (not inspected)' ; } else { $ str = '(object) ' . $ abs [ 'className' ] . "\n" ; $ str .= $ this -> dumpProperties ( $ abs ) ; if ( $ abs [ 'collectMethods' ] && $ this -> debug -> output -> getCfg ( 'outputMethods' ) ) { $ str .= $ this -> dumpMethods ( $ abs [ 'methods' ] ) ; } } $ str = \ trim ( $ str ) ; if ( $ isNested ) { $ str = \ str_replace ( "\n" , "\n " , $ str ) ; } return $ str ; }
5743	protected function parseContentType ( $ contentType ) { if ( false === stripos ( $ contentType , ';' ) ) { throw new ParserException ( 'ContentType does not contain a \';\'' ) ; } list ( $ mime , $ boundary ) = explode ( ';' , $ contentType , 2 ) ; list ( $ key , $ boundaryValue ) = explode ( '=' , trim ( $ boundary ) , 2 ) ; if ( 'boundary' != $ key ) { throw new ParserException ( 'Boundary does not start with \'boundary=\'' ) ; } return [ strtolower ( trim ( $ mime ) ) , $ boundaryValue ] ; }
4946	public function build ( ) { $ view = $ change = array ( ) ; foreach ( $ this -> assigned as $ resourceId => $ spec ) { if ( isset ( $ spec [ 'permission' ] ) ) { $ spec = array ( $ spec [ 'permission' ] => $ spec [ 'users' ] ) ; $ this -> assigned [ $ resourceId ] = $ spec ; } foreach ( $ spec as $ perm => $ userIds ) { if ( self :: PERMISSION_ALL == $ perm || self :: PERMISSION_CHANGE == $ perm ) { $ change = array_merge ( $ change , $ userIds ) ; } $ view = array_merge ( $ view , $ userIds ) ; } } $ this -> change = array_unique ( $ change ) ; $ this -> view = array_unique ( $ view ) ; return $ this ; }
4231	public static function findInheritedDoc ( \ Reflector $ reflector ) { $ name = $ reflector -> getName ( ) ; $ reflectionClass = $ reflector -> getDeclaringClass ( ) ; $ interfaces = $ reflectionClass -> getInterfaceNames ( ) ; foreach ( $ interfaces as $ className ) { $ reflectionClass2 = new \ ReflectionClass ( $ className ) ; if ( $ reflectionClass2 -> hasMethod ( $ name ) ) { return self :: getParsed ( $ reflectionClass2 -> getMethod ( $ name ) ) ; } } $ reflectionClass = $ reflectionClass -> getParentClass ( ) ; if ( $ reflectionClass && $ reflectionClass -> hasMethod ( $ name ) ) { return self :: getParsed ( $ reflectionClass -> getMethod ( $ name ) ) ; } }
6215	public function getParameters ( ) { $ parameters = $ this -> getUnfilteredParameters ( ) ; foreach ( $ this -> parameterFilters as $ filter ) { $ filter -> filter ( $ parameters ) ; } return $ parameters ; }
11684	protected function registerCommands ( ) { $ this -> commands ( \ Lab123 \ Odin \ Command \ AppRestart :: class ) ; $ this -> commands ( \ Lab123 \ Odin \ Command \ AppStart :: class ) ; $ this -> commands ( \ Lab123 \ Odin \ Command \ GeneratePasswordCommand :: class ) ; $ this -> commands ( \ Lab123 \ Odin \ Command \ LumenAppNameCommand :: class ) ; $ this -> commands ( \ Lab123 \ Odin \ Command \ LumenRouteList :: class ) ; $ this -> commands ( \ Lab123 \ Odin \ Command \ LumenVendorPublish :: class ) ; $ this -> commands ( \ Lab123 \ Odin \ Command \ LumenModelMake :: class ) ; }
8538	public function setOffer ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'Offer' ] [ 'FieldValue' ] = $ value ; return $ this ; }
4446	public function tagged ( string $ tag , int $ offset = 0 , int $ limit = 25 ) : array { $ response = json_decode ( $ this -> client -> call ( 'tag' , 'get' , $ tag , $ offset , $ limit ) , true ) ; if ( empty ( $ response [ 'jobs' ] ) ) { $ response [ 'jobs' ] = [ ] ; } return $ response [ 'jobs' ] ; }
12426	public function getAuthorizerInfo ( $ authorizerAppId ) { $ params = [ 'component_appid' => $ this -> getAppId ( ) , 'authorizer_appid' => $ authorizerAppId , ] ; return $ this -> parseJSON ( 'json' , [ self :: GET_AUTHORIZER_INFO , $ params ] ) ; }
12850	private function _checkCache ( \ stdClass $ oCache ) { $ sHearderValidity = false ; $ sHeader = "Cache-Control:" ; if ( isset ( $ oCache -> visibility ) && ( $ oCache -> visibility = 'public' || $ oCache -> visibility = 'private' ) ) { $ sHearderValidity = true ; $ sHeader .= " " . $ oCache -> visibility . "," ; } if ( isset ( $ oCache -> max_age ) ) { $ sHearderValidity = true ; $ sHeader .= " maxage=" . $ oCache -> max_age . "," ; } if ( isset ( $ oCache -> must_revalidate ) && $ oCache -> must_revalidate === true ) { $ sHearderValidity = true ; $ sHeader .= " must-revalidate," ; } if ( $ sHearderValidity === true ) { $ sHeader = substr ( $ sHeader , 0 , - 1 ) ; if ( ! headers_sent ( ) ) { header ( $ sHeader ) ; } } if ( isset ( $ oCache -> ETag ) ) { header ( "ETag: \"" . $ oCache -> ETag . "\"" ) ; } if ( isset ( $ oCache -> max_age ) ) { if ( ! headers_sent ( ) ) { header ( 'Expires: ' . gmdate ( 'D, d M Y H:i:s' , time ( ) + $ oCache -> max_age ) . ' GMT' ) ; } } if ( isset ( $ oCache -> last_modified ) ) { if ( ! headers_sent ( ) ) { header ( 'Last-Modified: ' . gmdate ( 'D, d M Y H:i:s' , time ( ) + $ oCache -> last_modified ) . ' GMT' ) ; } } if ( isset ( $ oCache -> vary ) ) { header ( 'Vary: ' . $ oCache -> vary ) ; } }
1151	protected function getViewData ( ) { $ this -> validator -> setRemote ( $ this -> remote ) ; $ data = $ this -> validator -> validationData ( ) ; $ data [ 'selector' ] = $ this -> selector ; if ( ! is_null ( $ this -> ignore ) ) { $ data [ 'ignore' ] = $ this -> ignore ; } return $ data ; }
3486	private static function addDefaultResolvers ( ) : void { static $ added = false ; if ( $ added ) { return ; } $ added = true ; self :: addResolver ( [ __CLASS__ , 'tryResolveByWebTokenJwtSystem' ] ) ; self :: addResolver ( [ __CLASS__ , 'tryResolveBySpomkyLabsJoseSystem' ] ) ; }
12006	final public function getAuthorityTree ( ) { $ database = $ this -> database ; $ statement = $ database -> select ( ) -> from ( '?authority' ) -> between ( "lft" , '1' , '6' ) -> prepare ( ) ; $ results = $ statement -> execute ( ) ; $ right = array ( ) ; }
11401	public function startAt ( $ startAt = 0 ) { if ( ! is_numeric ( $ startAt ) || $ startAt < 0 ) { throw new Exception ( "startAt: bad value" , 10 ) ; } $ this -> startAt = $ startAt ; return $ this ; }
4130	public function createNativeQuery ( $ designDocName , $ viewName ) { $ designDoc = $ this -> config -> getDesignDocument ( $ designDocName ) ; if ( $ designDoc ) { $ designDoc = new $ designDoc [ 'className' ] ( $ designDoc [ 'options' ] ) ; } $ query = new Query ( $ this -> couchDBClient -> getHttpClient ( ) , $ this -> couchDBClient -> getDatabase ( ) , $ designDocName , $ viewName , $ designDoc ) ; return $ query ; }
9861	private function writeDimension ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { $ objWriter -> startElement ( 'dimension' ) ; $ objWriter -> writeAttribute ( 'ref' , $ pSheet -> calculateWorksheetDimension ( ) ) ; $ objWriter -> endElement ( ) ; }
8612	public function setMarketplace ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'Marketplace' ] [ 'FieldValue' ] = $ value ; return $ this ; }
5912	public function updateUser ( $ id , User $ user , $ password = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'user' => $ user , 'password' => $ password ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/accounts/users/' . $ id . '' , $ parameters ) ; $ result = new User ( $ result ) ; return $ result ; }
10593	public function toArray ( ) { return [ 'level' => $ this -> level , 'datetime' => $ this -> datetime -> format ( 'Y-m-d H:i:s' ) , 'header' => $ this -> header , 'stack' => $ this -> stack , ] ; }
7424	public function render ( $ menu = 'Default' , $ debug = false , $ class = null ) { $ response = $ this -> initiateSubRequest ( ) ; return $ response -> getContent ( ) ; }
3923	protected function getConnection ( ) { if ( null === $ this -> connection ) { @ trigger_error ( 'Connection is missing in class ' . static :: class . '. The automatic fallback will be dropped in MetaModels 3.0. Please use dependency injection' , E_USER_DEPRECATED ) ; return $ this -> connection = System :: getContainer ( ) -> get ( 'database_connection' ) ; } return $ this -> connection ; }
10936	protected function authenticateUser ( CustomerInterface $ user , Response $ response ) { try { $ this -> get ( 'fos_user.security.login_manager' ) -> loginUser ( $ this -> getParameter ( 'fos_user.firewall_name' ) , $ user , $ response ) ; } catch ( AccountStatusException $ ex ) { } }
2672	public function upsertDictionaryItem ( $ dictionaryId , $ itemKey , $ itemValue ) { $ body = [ 'item_value' => $ itemValue ] ; $ url = $ this -> _getApiServiceUri ( ) . 'dictionary/' . $ dictionaryId . '/item/' . urlencode ( $ itemKey ) ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: PUT , $ body ) ; if ( ! $ result ) { throw new LocalizedException ( __ ( 'Failed to create Dictionary item.' ) ) ; } }
8733	public function update ( array $ values ) { $ updated = 0 ; $ modelKey = $ this -> getModel ( ) -> getKey ( ) ; $ modelKeyName = $ this -> model -> getKeyName ( ) ; $ values = $ this -> addUpdatedAtColumn ( $ values ) ; list ( $ values , $ i18nValues ) = $ this -> filterValues ( $ values ) ; $ ids = $ modelKey ? [ $ modelKey ] : $ this -> pluck ( $ modelKeyName ) -> all ( ) ; if ( $ values ) { $ updated += $ this -> updateBase ( $ values , $ ids ) ; } if ( $ i18nValues ) { $ updated += $ this -> updateI18n ( $ i18nValues , $ ids ) ; } return $ updated ; }
11626	private function isrunning ( ) { $ pids = explode ( PHP_EOL , `ps -e | awk '{print $1}'` ) ; if ( in_array ( $ this -> pid , $ pids ) ) return true ; return false ; }
7589	protected function configureType ( ) { switch ( $ this -> type ) { case 'POST' : $ this -> setOption ( CURLOPT_POST , true ) ; break ; case 'DELETE' : case 'PUT' : $ this -> setOption ( CURLOPT_CUSTOMREQUEST , $ this -> type ) ; break ; } }
8141	public function isTemplateFresh ( $ name , $ time ) { if ( 0 === $ this -> lastModifiedExtension ) { foreach ( $ this -> extensions as $ extension ) { $ r = new ReflectionObject ( $ extension ) ; if ( file_exists ( $ r -> getFileName ( ) ) && ( $ extensionTime = filemtime ( $ r -> getFileName ( ) ) ) > $ this -> lastModifiedExtension ) { $ this -> lastModifiedExtension = $ extensionTime ; } } } return $ this -> lastModifiedExtension <= $ time && $ this -> getLoader ( ) -> isFresh ( $ name , $ time ) ; }
308	protected function createRule ( $ pattern , $ prefix , $ action ) { $ verbs = 'GET|HEAD|POST|PUT|PATCH|DELETE|OPTIONS' ; if ( preg_match ( "/^((?:($verbs),)*($verbs))(?:\\s+(.*))?$/" , $ pattern , $ matches ) ) { $ verbs = explode ( ',' , $ matches [ 1 ] ) ; $ pattern = isset ( $ matches [ 4 ] ) ? $ matches [ 4 ] : '' ; } else { $ verbs = [ ] ; } $ config = $ this -> ruleConfig ; $ config [ 'verb' ] = $ verbs ; $ config [ 'pattern' ] = rtrim ( $ prefix . '/' . strtr ( $ pattern , $ this -> tokens ) , '/' ) ; $ config [ 'route' ] = $ action ; if ( ! empty ( $ verbs ) && ! in_array ( 'GET' , $ verbs ) ) { $ config [ 'mode' ] = WebUrlRule :: PARSING_ONLY ; } $ config [ 'suffix' ] = $ this -> suffix ; return Yii :: createObject ( $ config ) ; }
11196	public function __isset ( $ name ) { $ value = $ this -> find ( $ name ) ; if ( $ value !== null && ! ( $ value instanceof \ Exception ) ) { return true ; } return false ; }
4679	public function set ( $ template , $ data = [ ] , $ sort = 0 , $ type = "file" ) { if ( empty ( $ template ) ) { $ type = "empty" ; } elseif ( is_array ( $ template ) ) { if ( isset ( $ template [ "callback" ] ) ) { $ type = "callback" ; $ this -> template = $ template [ "callback" ] ; } else { $ this -> template = $ template [ "template" ] ; } $ this -> sortOrder = $ template [ "sort" ] ?? $ sort ; $ this -> type = $ template [ "type" ] ?? $ type ; $ data1 = $ template [ "data" ] ?? [ ] ; if ( empty ( $ data ) ) { $ this -> templateData = $ data1 ; } else if ( empty ( $ data1 ) ) { $ this -> templateData = $ data ; } else { foreach ( $ data as $ key => $ val ) { if ( is_array ( $ val ) ) { if ( ! array_key_exists ( $ key , $ data1 ) ) { $ data1 [ $ key ] = [ ] ; } $ data1 [ $ key ] = array_merge ( $ data1 [ $ key ] , $ val ) ; } else { $ data1 [ $ key ] = $ val ; } $ this -> templateData = $ data1 ; } } return ; } $ this -> template = $ template ; $ this -> templateData = $ data ; $ this -> sortOrder = $ sort ; $ this -> type = $ type ; return $ this ; }
2564	public static function generateSomewhatRandomString ( $ length = 22 ) { $ chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz" ; srand ( ( double ) microtime ( ) * 1000000 ) ; $ i = 0 ; $ somewhatRandom = '' ; while ( $ i < $ length ) { $ num = rand ( ) % 60 ; $ tmp = substr ( $ chars , $ num , 1 ) ; $ somewhatRandom = $ somewhatRandom . $ tmp ; $ i ++ ; } return $ somewhatRandom ; }
3430	protected function rememberInCache ( $ key , $ minutes , Closure $ callback ) { $ minutes = ( double ) $ minutes ; if ( $ minutes <= 0 ) { return $ callback ( ) ; } $ cache = Cache :: createInstance ( ) ; if ( $ cache -> initCache ( $ minutes * 60 , $ key , '/bitrix-models' ) ) { $ vars = $ cache -> getVars ( ) ; return ! empty ( $ vars [ 'isCollection' ] ) ? new Collection ( $ vars [ 'cache' ] ) : $ vars [ 'cache' ] ; } $ cache -> startDataCache ( ) ; $ result = $ callback ( ) ; $ isCollection = $ result instanceof Collection ; if ( $ isCollection ) { $ result = $ result -> all ( ) ; } $ cache -> endDataCache ( [ 'cache' => $ result , 'isCollection' => $ isCollection ] ) ; return $ isCollection ? new Collection ( $ result ) : $ result ; }
6052	public function retrieveFolder ( $ id , $ depth = 0 , $ includeProperties = true , $ includeObjectCounts = false , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'depth' => $ depth , 'includeProperties' => $ includeProperties , 'includeObjectCounts' => $ includeObjectCounts ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/folders/' . $ id . '' , $ parameters , $ cachePolicy ) ; $ result = new FolderResponse ( $ result ) ; return $ result ; }
10937	protected function getObfuscatedEmail ( CustomerInterface $ user ) { $ email = $ user -> getEmail ( ) ; if ( false !== $ pos = strpos ( $ email , '@' ) ) { $ email = '...' . substr ( $ email , $ pos ) ; } return $ email ; }
4610	public function geo ( $ sLat , $ sLon , $ iHeight ) { $ this -> sData .= 'GEO:' . $ sLat . ',' . $ sLon . ',' . $ iHeight . "\n" ; return $ this ; }
8775	public function admin ( $ data = null , $ secure = false ) { $ data = ( ! is_null ( $ data ) ) ? $ this -> url . '/' . ADMIN_FOLDER . '/' . $ data : $ this -> url . '/' . ADMIN_FOLDER . '/' ; return $ this -> getUrl ( $ data , $ secure ) ; }
10472	public function checkInItem ( $ item_id ) { $ request = new CheckInRequest ( $ this -> connector -> agency_id , $ item_id ) ; $ this -> emit ( 'request.checkin' , array ( $ item_id ) ) ; $ response = $ this -> post ( $ request ) ; return new CheckInResponse ( $ response ) ; }
8629	public function setParticipation ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'Participation' ] [ 'FieldValue' ] = $ value ; return $ this ; }
9467	protected function initializer ( string $ key , array $ storage ) : void { $ this -> _name = $ key ; $ this -> attached ( $ storage ) ; }
11793	public function setCc ( $ mail = '' , $ name = null ) { $ this -> cc = Helper :: deduplicate ( array_merge ( $ this -> cc , call_user_func_array ( array ( '\MimeMailer\Helper' , 'checkPeopleArgs' ) , func_get_args ( ) ) ) ) ; return $ this ; }
9390	public function getSortValBeforeAll ( $ groupingId = null ) { if ( $ groupingId === null && $ this -> grpColumn ) { throw new SortableException ( 'groupingId may be omitted only when grpColumn is not configured.' ) ; } $ query = ( new Query ( ) ) -> select ( [ $ this -> pkColumn , $ this -> srtColumn ] ) -> from ( $ this -> targetTable ) -> where ( [ 'and' , $ this -> grpColumn ? [ '=' , $ this -> grpColumn , $ groupingId ] : [ ] , $ this -> skipRowsClause ( ) ] ) -> orderBy ( [ $ this -> srtColumn => SORT_ASC ] ) -> limit ( 1 ) ; $ result = $ query -> one ( $ this -> db ) ; if ( $ result && $ result [ $ this -> srtColumn ] == 1 ) { $ this -> rebuildSortAfter ( $ result [ $ this -> pkColumn ] , true ) ; $ sortVal = $ this -> getIniSortVal ( ) ; } else if ( $ result ) { $ sortVal = ceil ( $ result [ $ this -> srtColumn ] / 2 ) ; } else $ sortVal = $ this -> getIniSortVal ( ) ; return ( int ) $ sortVal ; }
9662	private static function getReaderTypeFromExtension ( $ filename ) { $ pathinfo = pathinfo ( $ filename ) ; if ( ! isset ( $ pathinfo [ 'extension' ] ) ) { return null ; } switch ( strtolower ( $ pathinfo [ 'extension' ] ) ) { case 'xlsx' : case 'xlsm' : case 'xltx' : case 'xltm' : return 'Xlsx' ; case 'xls' : case 'xlt' : return 'Xls' ; case 'ods' : case 'ots' : return 'Ods' ; case 'slk' : return 'Slk' ; case 'xml' : return 'Xml' ; case 'gnumeric' : return 'Gnumeric' ; case 'htm' : case 'html' : return 'Html' ; case 'csv' : return null ; default : return null ; } }
4256	protected function buildNotInConsole ( ) { if ( ! $ this -> stats [ 'notInConsole' ] ) { return '' ; } $ errors = $ this -> errorHandler -> get ( 'errors' ) ; $ lis = array ( ) ; foreach ( $ errors as $ err ) { if ( \ array_intersect_assoc ( array ( 'category' => 'fatal' , 'inConsole' => true , 'isSuppressed' => true , ) , $ err -> getValues ( ) ) ) { continue ; } $ lis [ ] = '<li>' . $ err [ 'typeStr' ] . ': ' . $ err [ 'file' ] . ' (line ' . $ err [ 'line' ] . '): ' . ( $ err [ 'isHtml' ] ? $ err [ 'message' ] : \ htmlspecialchars ( $ err [ 'message' ] ) ) . '</li>' ; } if ( ! $ lis ) { return '' ; } $ count = \ count ( $ lis ) ; $ header = \ sprintf ( '%s %s captured while not collecting debug log' , $ this -> stats [ 'inConsole' ] || isset ( $ this -> stats [ 'counts' ] [ 'fatal' ] ) ? 'Additionally, there' : 'There' , $ count === 1 ? 'was 1 error' : 'were ' . $ count . ' errors' ) ; $ html = '<h3>' . $ header . '</h3>' . '<ul class="list-unstyled indent">' . "\n" . \ implode ( "\n" , $ lis ) . "\n" . '</ul>' ; return $ html ; }
10851	public function executeProcess ( $ command , $ beforeNotice = false , $ afterNotice = false ) : void { $ this -> echo ( 'info' , $ beforeNotice ? ' ' . $ beforeNotice : $ command ) ; $ process = new Process ( $ command , null , null , null , $ this -> option ( 'timeout' ) , null ) ; $ process -> run ( function ( $ type , $ buffer ) { if ( Process :: ERR === $ type ) { $ this -> echo ( 'comment' , $ buffer ) ; } else { $ this -> echo ( 'line' , $ buffer ) ; } } ) ; if ( ! $ process -> isSuccessful ( ) ) { throw new ProcessFailedException ( $ process ) ; } if ( $ this -> progressBar ) { $ this -> progressBar -> advance ( ) ; } if ( $ afterNotice ) { $ this -> echo ( 'info' , $ afterNotice ) ; } }
7946	public function getLineProperties ( $ id , $ line ) { if ( ! $ id ) throw new BadMethodCallException ( 'Missing parameter $id.' ) ; if ( ! $ line ) throw new BadMethodCallException ( 'Missing parameter $line.' ) ; try { $ r = $ this -> get ( 'xdsl/' . $ id . '/lines/' . $ line ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new XdslException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
8649	private function calculateStringToSignV2 ( array $ parameters , $ queuepath = null ) { $ parsedUrl = parse_url ( $ this -> config [ 'ServiceURL' ] ) ; $ endpoint = $ parsedUrl [ 'host' ] ; if ( isset ( $ parsedUrl [ 'port' ] ) && ! is_null ( $ parsedUrl [ 'port' ] ) ) { $ endpoint .= ':' . $ parsedUrl [ 'port' ] ; } $ data = 'POST' ; $ data .= "\n" ; $ data .= $ endpoint ; $ data .= "\n" ; if ( $ queuepath ) { $ uri = $ queuepath ; } else { $ uri = "/" ; } $ uriencoded = implode ( "/" , array_map ( array ( $ this , "urlencode" ) , explode ( "/" , $ uri ) ) ) ; $ data .= $ uriencoded ; $ data .= "\n" ; uksort ( $ parameters , 'strcmp' ) ; $ data .= $ this -> getParametersAsString ( $ parameters ) ; return $ data ; }
10086	public function writeDebugLog ( ... $ args ) { if ( $ this -> writeDebugLog ) { $ message = implode ( $ args ) ; $ cellReference = implode ( ' -> ' , $ this -> cellStack -> showStack ( ) ) ; if ( $ this -> echoDebugLog ) { echo $ cellReference , ( $ this -> cellStack -> count ( ) > 0 ? ' => ' : '' ) , $ message , PHP_EOL ; } $ this -> debugLog [ ] = $ cellReference . ( $ this -> cellStack -> count ( ) > 0 ? ' => ' : '' ) . $ message ; } }
2701	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ modules = $ this -> manifest -> getAllModlyManifests ( ) ; if ( ! $ modules ) { return $ result -> setData ( [ 'status' => false , 'modules' => '' , 'msg' => 'Use the Refresh button to get the latest modules.' ] ) ; } return $ result -> setData ( [ 'status' => true , 'modules' => $ modules ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
4551	public function getList ( $ form ) : array { $ objects = $ this -> execute ( 'GET' , 'http://www.mocky.io/v2/592c3c86110000f8016df7de' ) ; $ list = [ ] ; foreach ( $ objects as $ object ) { $ model = static :: toModel ( $ object ) ; $ list [ ] = $ model ; } return $ list ; }
9004	protected function months_dropdown ( $ post_type ) { global $ wpdb , $ wp_locale ; $ tn = $ this -> table -> get_table_name ( $ wpdb ) ; $ months = $ wpdb -> get_results ( " SELECT DISTINCT YEAR( time ) AS year, MONTH( time ) AS month FROM $tn ORDER BY time DESC " ) ; $ month_count = count ( $ months ) ; if ( ! $ month_count || ( 1 == $ month_count && 0 == $ months [ 0 ] -> month ) ) { return ; } $ m = isset ( $ _GET [ 'm' ] ) ? ( int ) $ _GET [ 'm' ] : 0 ; ?> <label for="filter-by-date" class="screen-reader-text"> <?php _e ( 'Filter by date' ) ; ?> </label> <select name="m" id="filter-by-date"> <option <?php selected ( $ m , 0 ) ; ?> value="0"> <?php _e ( 'All dates' ) ; ?> </option> <?php foreach ( $ months as $ arc_row ) { if ( 0 == $ arc_row -> year ) { continue ; } $ month = zeroise ( $ arc_row -> month , 2 ) ; $ year = $ arc_row -> year ; printf ( "<option %s value='%s'>%s</option>\n" , selected ( $ m , $ year . $ month , false ) , esc_attr ( $ arc_row -> year . $ month ) , sprintf ( __ ( '%1$s %2$d' ) , $ wp_locale -> get_month ( $ month ) , $ year ) ) ; } ?> </select> <?php }
298	public function updateAttributes ( $ attributes ) { $ attrs = [ ] ; foreach ( $ attributes as $ name => $ value ) { if ( is_int ( $ name ) ) { $ attrs [ ] = $ value ; } else { $ this -> $ name = $ value ; $ attrs [ ] = $ name ; } } $ values = $ this -> getDirtyAttributes ( $ attrs ) ; if ( empty ( $ values ) || $ this -> getIsNewRecord ( ) ) { return 0 ; } $ rows = static :: updateAll ( $ values , $ this -> getOldPrimaryKey ( true ) ) ; foreach ( $ values as $ name => $ value ) { $ this -> _oldAttributes [ $ name ] = $ this -> _attributes [ $ name ] ; } return $ rows ; }
10085	public function setMapping ( $ severity , $ pipe ) { if ( ! isset ( $ this -> mapping [ $ severity ] ) ) { throw new \ RuntimeException ( "Unknown severity: " . $ severity ) ; } if ( ( $ pipe !== self :: SILENCE ) && ( $ pipe !== self :: STDOUT ) && ( $ pipe !== self :: STDERR ) ) { throw new \ RuntimeException ( "Unknown output pipe: " . $ pipe ) ; } $ this -> mapping [ $ severity ] = $ pipe ; }
12421	public function dn ( $ domain , $ singular , $ plural , $ number ) { $ singular = ( string ) $ singular ; $ plural = ( string ) $ plural ; $ number = ( int ) $ number ; try { $ locale = $ this -> getLocale ( ) ; foreach ( $ this -> getTranslations ( $ domain ) as $ object ) { if ( ( $ string = $ object -> translatePlural ( $ singular , $ plural , $ number , $ domain , $ locale ) ) != $ singular ) { return $ string ; } } } catch ( \ Exception $ e ) { ; } if ( $ this -> getPluralIndex ( $ number , $ this -> getLocale ( ) ) > 0 ) { return ( string ) $ plural ; } return ( string ) $ singular ; }
5094	public function executeIterator ( ) { $ result = $ this -> execute ( ) ; if ( ! $ result ) throw new MySqlException ( 'Could not execute multiset query!' ) ; while ( true ) { yield new StatementResult ( $ result ) ; if ( ! $ result -> nextRowset ( ) ) { $ this -> checkForError ( $ result ) ; break ; } } }
9675	public function allFills ( Spreadsheet $ spreadsheet ) { $ aFills = [ ] ; $ fill0 = new Fill ( ) ; $ fill0 -> setFillType ( Fill :: FILL_NONE ) ; $ aFills [ ] = $ fill0 ; $ fill1 = new Fill ( ) ; $ fill1 -> setFillType ( Fill :: FILL_PATTERN_GRAY125 ) ; $ aFills [ ] = $ fill1 ; $ aStyles = $ this -> allStyles ( $ spreadsheet ) ; foreach ( $ aStyles as $ style ) { if ( ! isset ( $ aFills [ $ style -> getFill ( ) -> getHashCode ( ) ] ) ) { $ aFills [ $ style -> getFill ( ) -> getHashCode ( ) ] = $ style -> getFill ( ) ; } } return $ aFills ; }
3934	private function setExcluded ( PropertyInterface $ property , $ propInfo ) { if ( ! isset ( $ propInfo [ 'exclude' ] ) ) { return ; } $ property -> setExcluded ( ( bool ) $ propInfo [ 'exclude' ] ) ; }
6988	protected function finalize ( ContextInterface $ context ) : ContextInterface { if ( null === $ context -> getCustomerGroup ( ) ) { $ context -> setCustomerGroup ( $ this -> customerGroupRepository -> findDefault ( ) ) ; } if ( null === $ context -> getInvoiceCountry ( ) ) { $ context -> setInvoiceCountry ( $ this -> countryProvider -> getCountry ( ) ) ; } if ( null === $ context -> getDeliveryCountry ( ) ) { $ context -> setDeliveryCountry ( $ this -> countryProvider -> getCountry ( ) ) ; } if ( null === $ context -> getCurrency ( ) ) { $ context -> setCurrency ( $ this -> currencyProvider -> getCurrency ( ) ) ; } if ( null === $ context -> getLocale ( ) ) { $ context -> setLocale ( $ this -> localProvider -> getCurrentLocale ( ) ) ; } if ( null === $ context -> getVatDisplayMode ( ) ) { if ( null !== $ mode = $ context -> getCustomerGroup ( ) -> getVatDisplayMode ( ) ) { $ context -> setVatDisplayMode ( $ mode ) ; } else { $ context -> setVatDisplayMode ( $ this -> defaultVatDisplayMode ) ; } } $ this -> eventDispatcher -> dispatch ( ContextEvents :: BUILD , new ContextEvent ( $ context ) ) ; return $ context ; }
2485	public function bulkIndexDocuments ( array $ documents ) { $ documentMap = array ( ) ; $ mainTranslationsEndpoint = $ this -> endpointResolver -> getMainLanguagesEndpoint ( ) ; $ mainTranslationsDocuments = array ( ) ; foreach ( $ documents as $ translationDocuments ) { foreach ( $ translationDocuments as $ document ) { $ documentMap [ $ document -> languageCode ] [ ] = $ document ; if ( $ mainTranslationsEndpoint !== null && $ document -> isMainTranslation ) { $ mainTranslationsDocuments [ ] = $ this -> getMainTranslationDocument ( $ document ) ; } } } foreach ( $ documentMap as $ languageCode => $ translationDocuments ) { $ this -> doBulkIndexDocuments ( $ this -> endpointRegistry -> getEndpoint ( $ this -> endpointResolver -> getIndexingTarget ( $ languageCode ) ) , $ translationDocuments ) ; } if ( ! empty ( $ mainTranslationsDocuments ) ) { $ this -> doBulkIndexDocuments ( $ this -> endpointRegistry -> getEndpoint ( $ mainTranslationsEndpoint ) , $ mainTranslationsDocuments ) ; } }
10788	protected function getSearchFacets ( SessionInterface $ session ) { $ facets = $ session -> get ( $ this -> getSessionPrefix ( ) . '_facets' , false ) ; return $ facets ? \ json_decode ( $ facets , true ) : $ this -> getDefaultFacets ( ) ; }
2437	public function setData ( $ arrData ) { if ( ! \ is_array ( $ arrData ) ) { throw new \ Exception ( 'Array required to set session data' ) ; } foreach ( $ this -> mappedKeys as $ strKey ) { if ( isset ( $ arrData [ $ strKey ] ) ) { $ this -> session -> set ( $ strKey , $ arrData [ $ strKey ] ) ; unset ( $ arrData [ $ strKey ] ) ; } } $ this -> sessionBag -> replace ( $ arrData ) ; }
5972	public function deployment ( ) { if ( ! $ this -> deployment instanceof DeploymentController ) { $ this -> deployment = new DeploymentController ( $ this -> getClient ( ) , $ this -> cachePolicy , $ this -> cache ) ; $ this -> deployment -> setLogger ( $ this -> logger ) ; } return $ this -> deployment ; }
6682	private function setSecurityHeaders ( ) { $ headers = Yii :: $ app -> response -> headers ; $ headers -> add ( 'X-Frame-Options' , 'DENY' ) ; $ headers -> add ( 'X-XSS-Protection' , '1' ) ; }
625	public function handleHhvmError ( $ code , $ message , $ file , $ line , $ context , $ backtrace ) { if ( $ this -> handleError ( $ code , $ message , $ file , $ line ) ) { return true ; } if ( E_ERROR & $ code ) { $ exception = new ErrorException ( $ message , $ code , $ code , $ file , $ line ) ; $ ref = new \ ReflectionProperty ( '\Exception' , 'trace' ) ; $ ref -> setAccessible ( true ) ; $ ref -> setValue ( $ exception , $ backtrace ) ; $ this -> _hhvmException = $ exception ; } return false ; }
9278	public function fetchByWhere ( $ where = null , array $ options = array ( ) ) { $ select = $ this -> sql -> select ( ) ; if ( $ where instanceof Where ) { $ select -> where ( $ where ) ; } elseif ( is_string ( $ where ) && ! empty ( $ where ) ) { $ select -> where ( $ where ) ; } $ limit = array_key_exists ( 'limit' , $ options ) ? ( int ) $ limit : null ; if ( ! is_null ( $ limit ) && ( int ) $ limit > 0 ) { $ select -> limit ( $ limit ) ; } $ stmt = $ this -> sql -> prepareStatementForSqlObject ( $ select ) ; $ result = $ stmt -> execute ( ) ; $ hydrate = array_key_exists ( 'hydrate' , $ options ) ? ( bool ) $ options [ 'hydrate' ] : true ; if ( $ hydrate !== true ) { return $ result ; } return $ this -> hydrateResult ( $ result ) ; }
2053	public function getTemplateData ( ) { $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; $ image = System :: getContainer ( ) -> get ( 'contao.image.image_factory' ) -> create ( $ rootDir . '/' . $ this -> image -> getOriginalPath ( ) ) ; $ config = new PictureConfiguration ( ) ; $ config -> setSize ( $ this -> getConfigurationItem ( $ this -> imageSize ) ) ; $ sizeItems = array ( ) ; foreach ( $ this -> imageSizeItems as $ imageSizeItem ) { $ sizeItems [ ] = $ this -> getConfigurationItem ( $ imageSizeItem ) ; } $ config -> setSizeItems ( $ sizeItems ) ; $ importantPart = $ this -> image -> getImportantPart ( ) ; $ image -> setImportantPart ( new ImportantPart ( new Point ( $ importantPart [ 'x' ] , $ importantPart [ 'y' ] ) , new Box ( $ importantPart [ 'width' ] , $ importantPart [ 'height' ] ) ) ) ; $ container = System :: getContainer ( ) ; $ staticUrl = $ container -> get ( 'contao.assets.files_context' ) -> getStaticUrl ( ) ; $ picture = $ container -> get ( 'contao.image.picture_generator' ) -> generate ( $ image , $ config , ( new ResizeOptions ( ) ) -> setImagineOptions ( $ container -> getParameter ( 'contao.image.imagine_options' ) ) -> setBypassCache ( $ container -> getParameter ( 'contao.image.bypass_cache' ) ) ) ; return array ( 'img' => $ picture -> getImg ( $ rootDir , $ staticUrl ) , 'sources' => $ picture -> getSources ( $ rootDir , $ staticUrl ) , ) ; }
6069	public function listComments ( $ mediaId , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/media/' . $ mediaId . '/comments' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new CommentResponse ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
2474	public function bulkIndexContent ( array $ contentObjects ) { $ documents = array ( ) ; foreach ( $ contentObjects as $ content ) { try { $ documents [ ] = $ this -> mapper -> mapContentBlock ( $ content ) ; } catch ( NotFoundException $ ex ) { } } if ( ! empty ( $ documents ) ) { $ this -> gateway -> bulkIndexDocuments ( $ documents ) ; } }
5837	public function transform ( $ orig , $ transformation = null , $ overrides = array ( ) ) { return $ this -> transformer -> transform ( $ orig , $ transformation , $ overrides ) ; }
3616	public function setFanMode ( $ mode , $ serial_number = NULL ) { $ duty_cycle = NULL ; $ timer = NULL ; if ( is_array ( $ mode ) ) { $ modes = $ mode ; $ mode = $ modes [ 0 ] ; if ( count ( $ modes ) > 1 ) { if ( $ mode == FAN_MODE_MINUTES_PER_HOUR ) { $ duty_cycle = ( int ) $ modes [ 1 ] ; } else { $ timer = ( int ) $ modes [ 1 ] ; } } else { throw new Exception ( "setFanMode(array \$mode[, ...]) needs at least a mode and a value in the \$mode array." ) ; } } elseif ( ! is_string ( $ mode ) ) { throw new Exception ( "setFanMode() can only take a string or an array as it's first parameter." ) ; } return $ this -> _setFanMode ( $ mode , $ duty_cycle , $ timer , $ serial_number ) ; }
767	public function login ( IdentityInterface $ identity , $ duration = 0 ) { if ( $ this -> beforeLogin ( $ identity , false , $ duration ) ) { $ this -> switchIdentity ( $ identity , $ duration ) ; $ id = $ identity -> getId ( ) ; $ ip = Yii :: $ app -> getRequest ( ) -> getUserIP ( ) ; if ( $ this -> enableSession ) { $ log = "User '$id' logged in from $ip with duration $duration." ; } else { $ log = "User '$id' logged in from $ip. Session not enabled." ; } $ this -> regenerateCsrfToken ( ) ; Yii :: info ( $ log , __METHOD__ ) ; $ this -> afterLogin ( $ identity , false , $ duration ) ; } return ! $ this -> getIsGuest ( ) ; }
6890	protected function removeAssignment ( StockAssignmentInterface $ assignment ) { $ this -> unitUpdater -> updateSold ( $ assignment -> getStockUnit ( ) , - $ assignment -> getSoldQuantity ( ) , true ) ; $ assignment -> setSaleItem ( null ) -> setStockUnit ( null ) ; $ this -> persistenceHelper -> remove ( $ assignment ) ; }
3523	public function id ( $ id ) { foreach ( $ this -> items as $ item ) { if ( $ item -> itemId == $ id ) return $ item ; } return null ; }
4076	protected function getMetaModelName ( $ nameOrId ) { return isset ( $ this -> tableMap [ $ nameOrId ] ) ? $ this -> tableMap [ $ nameOrId ] : $ nameOrId ; }
9645	public function makePdo ( array $ config , $ connection = null ) { if ( ! isset ( $ config [ 'driver' ] ) && ! isset ( $ config [ 'dsn' ] ) ) { throw new InvalidArgumentException ( 'DSN or driver must be set' ) ; } $ options = isset ( $ config [ 'pdo_options' ] ) ? $ config [ 'pdo_options' ] : [ ] ; unset ( $ config [ 'pdo_options' ] ) ; $ options = array_replace ( $ this -> defaultPdoOptions , $ options ) ; $ initCommands = isset ( $ config [ 'pdo_init_commands' ] ) ? $ config [ 'pdo_init_commands' ] : [ ] ; unset ( $ config [ 'pdo_init_commands' ] ) ; if ( isset ( $ config [ 'driver' ] ) && $ config [ 'driver' ] == 'sqlite' ) { $ this -> validate ( $ config , 'path' , $ connection ) ; $ dsn = $ this -> makeSqliteDsn ( $ config [ 'path' ] ) ; return $ this -> makePdoInner ( $ dsn , null , null , $ options , $ initCommands ) ; } elseif ( isset ( $ config [ 'dsn' ] ) && strpos ( $ config [ 'dsn' ] , 'sqlite:' ) === 0 ) { return $ this -> makePdoInner ( $ config [ 'dsn' ] , null , null , $ options , $ initCommands ) ; } $ this -> validate ( $ config , 'username' , $ connection , false ) ; $ username = $ config [ 'username' ] ; unset ( $ config [ 'username' ] ) ; $ this -> validate ( $ config , 'password' , $ connection , true ) ; $ password = $ config [ 'password' ] ; unset ( $ config [ 'password' ] ) ; if ( isset ( $ config [ 'dsn' ] ) ) { $ dsn = $ config [ 'dsn' ] ; } else { $ driver = $ config [ 'driver' ] ; unset ( $ config [ 'driver' ] ) ; $ this -> validate ( $ config , 'host' , $ connection ) ; $ this -> validate ( $ config , 'dbname' , $ connection ) ; $ dsn = $ this -> makeDsn ( $ driver , $ config ) ; } return $ this -> makePdoInner ( $ dsn , $ username , $ password , $ options , $ initCommands ) ; }
11471	public function edit ( ResponseRequest $ request , Response $ response ) { return $ this -> response -> title ( trans ( 'app.edit' ) . ' ' . trans ( 'forum::response.name' ) ) -> view ( 'forum::response.edit' , true ) -> data ( compact ( 'response' ) ) -> output ( ) ; }
10595	protected function initViewPanelTableData ( ) { $ items = [ ] ; $ currentRouteName = $ this -> currentRoute ? $ this -> currentRoute -> GetName ( ) : NULL ; foreach ( $ this -> routes as & $ route ) { $ matched = FALSE ; if ( $ currentRouteName !== NULL && $ route -> GetName ( ) === $ currentRouteName ) { $ matched = TRUE ; } $ items [ ] = $ this -> initViewPanelTableRow ( $ route , $ matched ) ; } $ this -> view -> items = $ items ; }
3025	public function postRequest ( $ path , $ options , $ addApiKey ) { if ( isset ( $ options [ 'source' ] ) && is_array ( $ options [ 'source' ] ) ) { $ sources = $ options [ 'source' ] ; unset ( $ options [ 'source' ] ) ; foreach ( $ sources as $ i => $ source ) { $ options [ "source[$i]" ] = $ source ; } } $ response = $ this -> makeRequest ( 'POST' , $ path , $ options , $ addApiKey ) ; return $ this -> parseResponse ( $ response ) ; }
8874	public function addAttachment ( $ attachment ) { if ( ! file_exists ( $ attachment ) ) { pines_error ( 'Invalid attachment.' ) ; return false ; } $ this -> attachments [ ] = $ attachment ; return true ; }
12771	public function authorizeWithEmail ( $ hashedEmail , $ hashedPassword , $ remember = null , & $ user = null ) { $ result = new EmailStatus ( 0 ) ; if ( dbQuery ( $ this -> dbTable ) -> where ( $ this -> dbHashEmailField , $ hashedEmail ) -> first ( $ user ) ) { $ dbTable = $ this -> dbTable ; $ hashPasswordField = $ dbTable :: $ _attributes [ $ this -> dbHashPasswordField ] ; if ( $ user [ $ hashPasswordField ] === $ hashedPassword ) { $ result = new EmailStatus ( EmailStatus :: SUCCESS_EMAIL_AUTHORIZE ) ; $ this -> authorize ( $ user , $ remember ) ; } else { $ result = new EmailStatus ( EmailStatus :: ERROR_EMAIL_AUTHORIZE_WRONGPWD ) ; } } else { $ result = new EmailStatus ( EmailStatus :: ERROR_EMAIL_AUTHORIZE_NOTFOUND ) ; } if ( is_callable ( $ this -> authorizeHandler ) ) { if ( ! call_user_func_array ( $ this -> authorizeHandler , array ( & $ user , & $ result ) ) ) { $ result = new EmailStatus ( EmailStatus :: ERROR_EMAIL_AUTHORIZE_HANDLER ) ; } } return $ result ; }
1547	public function registerCustom ( ) : void { if ( ! $ fn = $ this -> group ) { return ; } $ this -> router -> group ( [ ] , function ( ) use ( $ fn ) { $ fn ( new RouteRegistrar ( $ this -> router , [ 'controller' => $ this -> controller ( ) ] , [ self :: PARAM_RESOURCE_TYPE => $ this -> resourceType ] ) ) ; } ) ; }
12227	public function deleteSelf ( ) { $ tmp = dom_import_simplexml ( $ this ) ; if ( $ tmp -> isSameNode ( $ tmp -> ownerDocument -> documentElement ) ) { throw new BadMethodCallException ( 'deleteSelf() cannot be used to delete the root node' ) ; } $ tmp -> parentNode -> removeChild ( $ tmp ) ; }
278	private function notifyUnloaded ( $ fixtures ) { $ this -> stdout ( "\nFixtures were successfully unloaded from namespace: " , Console :: FG_YELLOW ) ; $ this -> stdout ( Yii :: getAlias ( $ this -> namespace ) . "\"\n\n" , Console :: FG_GREEN ) ; $ this -> outputList ( $ fixtures ) ; }
11364	public static function headerTagger ( $ name = '' , $ value = '' , $ adds = array ( ) ) { $ str = $ name . ': ' . $ value ; if ( count ( $ adds ) ) { foreach ( $ adds as $ n => $ v ) { $ str .= Mailer :: $ HEADERS_SEPARATOR . ( $ n == 'boundary' ? "\n\t" : '' ) . $ n . "=\"" . $ v . "\"" ; } } return ( trim ( $ str , Mailer :: $ HEADERS_SEPARATOR ) ) ; }
6870	protected function buildPaymentList ( PM \ PaymentSubjectInterface $ subject ) { $ payments = array_filter ( $ subject -> getPayments ( ) -> toArray ( ) , function ( PM \ PaymentInterface $ p ) { if ( $ p -> getMethod ( ) -> isOutstanding ( ) ) { return false ; } if ( ! PM \ PaymentStates :: isPaidState ( $ p -> getState ( ) ) ) { return false ; } return true ; } ) ; usort ( $ payments , function ( PM \ PaymentInterface $ a , PM \ PaymentInterface $ b ) { return $ a -> getCompletedAt ( ) -> getTimestamp ( ) - $ b -> getCompletedAt ( ) -> getTimestamp ( ) ; } ) ; return array_map ( function ( PM \ PaymentInterface $ payment ) { return [ 'payment' => $ payment , 'amount' => $ payment -> getAmount ( ) , ] ; } , $ payments ) ; }
7369	private function updatePrice ( StockUnitInterface $ stockUnit ) { $ price = null ; if ( null !== $ item = $ stockUnit -> getSupplierOrderItem ( ) ) { if ( null === $ order = $ item -> getOrder ( ) ) { throw new StockLogicException ( "Supplier order item's order must be set at this point." ) ; } $ currency = $ order -> getCurrency ( ) -> getCode ( ) ; $ date = $ order -> getPaymentDate ( ) ; if ( $ date > new \ DateTime ( ) ) { $ date = null ; } $ price = $ this -> currencyConverter -> convert ( $ item -> getNetPrice ( ) , $ currency , null , $ date ) ; } if ( 0 !== Money :: compare ( $ stockUnit -> getNetPrice ( ) , $ price , $ this -> currencyConverter -> getDefaultCurrency ( ) ) ) { $ stockUnit -> setNetPrice ( $ price ) ; return true ; } return false ; }
9608	public function angleBetween ( self $ b ) { $ denominator = $ this -> length ( ) * $ b -> length ( ) ; if ( $ denominator == 0 ) { throw new Exception ( 'Cannot divide by zero' ) ; } return acos ( $ this -> dotProduct ( $ b ) / $ denominator ) ; }
5007	private function init ( $ name ) { if ( null === $ name ) { $ name = $ this -> default ; } if ( ! isset ( static :: $ orderMap [ $ name ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Unknown status name "%s" for "%s"' , $ name , static :: class ) ) ; } $ this -> name = $ name ; $ this -> order = static :: $ orderMap [ $ name ] ; }
10855	public function getLocationString ( ) { $ normalized = '' ; if ( $ this -> city !== null ) { $ normalized .= $ this -> city -> name ; } if ( $ this -> region !== null ) { $ normalized .= ' ' . $ this -> region -> name ; } if ( $ this -> postal_code !== null ) { $ normalized .= ' ' . $ this -> postal_code ; } return $ normalized ; }
9623	public function getConnectionConfig ( $ connection = null ) { if ( $ connection === null ) { $ connection = $ this -> defaultConnection ; } $ config = $ this -> config -> get ( "database.connections.$connection" ) ; if ( ! $ config ) { if ( ! is_string ( $ connection ) ) { $ connection = gettype ( $ connection ) ; } throw new \ InvalidArgumentException ( "No config found for connection: $connection" ) ; } return $ config ; }
1915	protected function getQuestion ( ) { $ this -> generateCaptcha ( ) ; $ question = $ GLOBALS [ 'TL_LANG' ] [ 'SEC' ] [ 'question' . random_int ( 1 , 3 ) ] ; $ question = sprintf ( $ question , $ this -> arrCaptcha [ 'int1' ] , $ this -> arrCaptcha [ 'int2' ] ) ; $ strEncoded = '' ; $ arrCharacters = Utf8 :: str_split ( $ question ) ; foreach ( $ arrCharacters as $ strCharacter ) { $ strEncoded .= sprintf ( '&#%s;' , Utf8 :: ord ( $ strCharacter ) ) ; } return $ strEncoded ; }
3040	public function del ( $ userId , $ callId ) { $ key = $ this -> getCacheKey ( $ userId , $ callId ) ; $ this -> putInCache ( $ key , $ userId , $ callId , null , self :: STATE_PENDING_DELETE ) ; return true ; }
7241	private function getDefaultClasses ( ) { return [ 'address' => [ Cart \ Model \ CartInterface :: class => Cart \ Entity \ CartAddress :: class , Order \ Model \ OrderInterface :: class => Order \ Entity \ OrderAddress :: class , Quote \ Model \ QuoteInterface :: class => Quote \ Entity \ QuoteAddress :: class , ] , 'attachment' => [ Cart \ Model \ CartInterface :: class => Cart \ Entity \ CartAttachment :: class , Order \ Model \ OrderInterface :: class => Order \ Entity \ OrderAttachment :: class , Quote \ Model \ QuoteInterface :: class => Quote \ Entity \ QuoteAttachment :: class , ] , 'notification' => [ Cart \ Model \ CartInterface :: class => Cart \ Entity \ CartNotification :: class , Order \ Model \ OrderInterface :: class => Order \ Entity \ OrderNotification :: class , Quote \ Model \ QuoteInterface :: class => Quote \ Entity \ QuoteNotification :: class , ] , 'item' => [ Cart \ Model \ CartInterface :: class => Cart \ Entity \ CartItem :: class , Order \ Model \ OrderInterface :: class => Order \ Entity \ OrderItem :: class , Quote \ Model \ QuoteInterface :: class => Quote \ Entity \ QuoteItem :: class , ] , 'adjustment' => [ Cart \ Model \ CartInterface :: class => Cart \ Entity \ CartAdjustment :: class , Order \ Model \ OrderInterface :: class => Order \ Entity \ OrderAdjustment :: class , Quote \ Model \ QuoteInterface :: class => Quote \ Entity \ QuoteAdjustment :: class , ] , 'item_adjustment' => [ Cart \ Model \ CartItemInterface :: class => Cart \ Entity \ CartItemAdjustment :: class , Order \ Model \ OrderItemInterface :: class => Order \ Entity \ OrderItemAdjustment :: class , Quote \ Model \ QuoteItemInterface :: class => Quote \ Entity \ QuoteItemAdjustment :: class , ] , 'item_stock_assignment' => [ Order \ Model \ OrderItemInterface :: class => Order \ Entity \ OrderItemStockAssignment :: class , ] , 'payment' => [ Cart \ Model \ CartInterface :: class => Cart \ Entity \ CartPayment :: class , Order \ Model \ OrderInterface :: class => Order \ Entity \ OrderPayment :: class , Quote \ Model \ QuoteInterface :: class => Quote \ Entity \ QuotePayment :: class , ] , 'shipment' => [ Order \ Model \ OrderInterface :: class => Order \ Entity \ OrderShipment :: class , ] , 'shipment_item' => [ Order \ Model \ OrderShipmentInterface :: class => Order \ Entity \ OrderShipmentItem :: class , ] , 'invoice' => [ Order \ Model \ OrderInterface :: class => Order \ Entity \ OrderInvoice :: class , ] , 'invoice_line' => [ Order \ Model \ OrderInvoiceInterface :: class => Order \ Entity \ OrderInvoiceLine :: class , ] , ] ; }
11174	public static function hash ( $ string , $ algorithm = 'blowfish' ) { switch ( strtolower ( $ algorithm ) ) : case ( 'md5' ) : $ salt = '$1$' . ( static :: rand ( 12 ) ) . '$' ; break ; case ( 'sha256' ) : $ salt = '$5$rounds=5000$' . ( static :: rand ( 16 ) ) . '$' ; break ; case ( 'sha512' ) : $ salt = '$6$rounds=5000$' . ( static :: rand ( 16 ) ) . '$' ; break ; case ( 'blowfish' ) : default : $ salt = '$2a$09$' . ( static :: rand ( 22 ) ) . '$' ; break ; endswitch ; return base64_encode ( crypt ( $ string , $ salt ) ) ; }
7258	protected function mergeItemsResults ( Model \ SaleItemInterface $ item , Amount $ result ) : void { foreach ( $ item -> getChildren ( ) as $ child ) { if ( $ child -> isPrivate ( ) ) { continue ; } if ( ! ( $ child -> isCompound ( ) && ! $ child -> hasPrivateChildren ( ) ) ) { $ result -> merge ( $ child -> getResult ( ) ) ; } if ( $ child -> hasChildren ( ) ) { $ this -> mergeItemsResults ( $ child , $ result ) ; } } }
10823	public static function ask ( $ question , $ defaultValue = null , $ secret = false ) { $ value = '' ; while ( trim ( $ value ) == '' ) { self :: writeln ( '' ) ; self :: write ( ' ' . $ question , 'info' ) ; if ( $ defaultValue !== null ) { self :: write ( ' [' ) ; self :: write ( $ defaultValue , 'comment' ) ; self :: write ( ']' ) ; } self :: writeln ( ':' ) ; if ( $ secret ) { self :: write ( ' > ' ) ; if ( self :: $ testValue === null ) { system ( 'stty -echo' ) ; $ value = trim ( fgets ( STDIN ) ) ; system ( 'stty echo' ) ; } else { $ value = self :: $ testValue ; } } else { if ( self :: $ testValue === null ) { $ value = readline ( ' > ' ) ; } else { $ value = self :: $ testValue ; } } if ( trim ( $ value ) == '' ) { $ value = $ defaultValue ; } if ( trim ( $ value ) == '' ) { self :: writeln ( '' ) ; self :: block ( '[ERROR] A value is required' , 'error' ) ; } self :: writeln ( '' ) ; } return trim ( $ value ) ; }
1498	public function merge ( EncodingList $ encodings ) : self { $ copy = new self ( ) ; $ copy -> stack = collect ( $ this -> stack ) -> merge ( $ encodings -> stack ) -> all ( ) ; return $ copy ; }
4493	public function setLocalizedText ( ? string $ key , ? array $ arguments = null ) : self { $ this -> setLocalizedKey ( $ key ) ; $ this -> setLocalizedArguments ( $ arguments ) ; return $ this ; }
8648	private function addRequiredParameters ( array $ parameters ) { $ parameters [ 'AWSAccessKeyId' ] = $ this -> awsAccessKeyId ; $ parameters [ 'Timestamp' ] = $ this -> getFormattedTimestamp ( new DateTime ( 'now' , new DateTimeZone ( 'UTC' ) ) ) ; $ parameters [ 'Version' ] = self :: SERVICE_VERSION ; $ parameters [ 'SignatureVersion' ] = $ this -> config [ 'SignatureVersion' ] ; if ( $ parameters [ 'SignatureVersion' ] > 1 ) { $ parameters [ 'SignatureMethod' ] = $ this -> config [ 'SignatureMethod' ] ; } $ parameters [ 'Signature' ] = $ this -> signParameters ( $ parameters , $ this -> awsSecretAccessKey ) ; return $ parameters ; }
722	public function json ( ) { if ( version_compare ( PHP_VERSION , '5.6' , '<' ) && $ this -> getDb ( ) -> getDriverName ( ) === 'mysql' ) { throw new \ yii \ base \ Exception ( 'JSON column type is not supported in PHP < 5.6' ) ; } return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_JSON ) ; }
5702	public function isCustomActionAllowed ( $ action ) { $ actions = $ this -> owner -> config ( ) -> better_buttons_actions ; if ( $ actions ) { return in_array ( $ action , $ actions ) ; } return false ; }
2934	public function save ( ) { if ( is_file ( $ this -> filePath ) && $ this -> autoBackup ) { $ this -> backup ( ) ; } $ this -> writer -> save ( $ this -> filePath ) ; return $ this ; }
10122	private function writePrintHeaders ( ) { $ record = 0x002a ; $ length = 0x0002 ; $ fPrintRwCol = $ this -> printHeaders ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ fPrintRwCol ) ; $ this -> append ( $ header . $ data ) ; }
11269	public function getPath ( Neuron_GameServer_Map_Location $ start , Neuron_GameServer_Map_Location $ end ) { $ x1 = $ start [ 0 ] ; $ y1 = $ start [ 1 ] ; $ x2 = $ end [ 0 ] ; $ y2 = $ end [ 1 ] ; if ( ! $ this -> isPassable ( $ x2 , $ y2 ) ) { return false ; } $ astar = $ this -> astar ( $ start , $ end ) ; return $ astar ; }
559	protected function buildAttributeCondition ( $ attribute , $ condition ) { if ( is_array ( $ condition ) ) { $ parts = [ ] ; foreach ( $ condition as $ operator => $ value ) { if ( isset ( $ this -> operatorTypes [ $ operator ] ) ) { if ( isset ( $ this -> conditionBuilders [ $ operator ] ) ) { $ method = $ this -> conditionBuilders [ $ operator ] ; if ( is_string ( $ method ) ) { $ callback = [ $ this , $ method ] ; } else { $ callback = $ method ; } $ parts [ ] = $ callback ( $ operator , $ value , $ attribute ) ; } else { $ parts [ ] = $ this -> buildOperatorCondition ( $ operator , $ value , $ attribute ) ; } } } if ( ! empty ( $ parts ) ) { if ( count ( $ parts ) > 1 ) { return array_merge ( [ 'AND' ] , $ parts ) ; } return array_shift ( $ parts ) ; } } return [ $ attribute => $ this -> filterAttributeValue ( $ attribute , $ condition ) ] ; }
7007	private function format_j ( & $ str ) { if ( strstr ( $ str , '%j' ) ) $ str = str_replace ( '%j' , sprintf ( '%01d' , $ this -> day ) , $ str ) ; }
11247	public function getLast ( ) : array { $ sql = "select migration from {$this->table} as b where exists (select max(batch) from {$this->table} as a where b.batch = a.batch) order by migration desc" ; $ stmt = $ this -> pdo -> prepare ( $ sql ) ; $ stmt -> execute ( ) ; return $ stmt -> fetchAll ( PDO :: FETCH_COLUMN ) ; }
12935	protected function resolveMoveOptions ( array $ options ) { if ( $ this -> optionsResolved ) { return ; } $ this -> optionsResolver -> clear ( ) ; $ this -> optionsResolver -> setRequired ( array ( 'page' , 'language' , 'country' , 'sourceSlot' , 'position' , ) ) ; $ this -> optionsResolver -> setDefined ( array ( 'targetSlot' , 'blockname' , 'oldName' , 'newName' , 'slot' , ) ) ; $ this -> optionsResolver -> resolve ( $ options ) ; $ this -> optionsResolved = true ; }
7533	function setInnerText ( $ text , $ parser = null ) { $ this -> clear ( ) ; if ( trim ( $ text ) ) { if ( $ parser === null ) { $ parser = new $ this -> parserClass ( ) ; } $ parser -> root = & $ this ; $ parser -> setDoc ( $ text ) ; $ parser -> parse_all ( ) ; } return ( ( $ parser && $ parser -> errors ) ? $ parser -> errors : true ) ; }
7956	public function getBillingAccountServices ( ) { $ serviceList = json_decode ( self :: getClient ( ) -> getBillingAccountServices ( $ this -> billingAccount ) ) ; $ services = array ( ) ; foreach ( $ serviceList as $ service ) { $ services [ ] = new TelephonyAccountService ( $ service , $ this ) ; } return $ services ; }
11610	public function connect ( ClientInterface $ client ) { $ attributes = $ client -> getUserAttributes ( ) ; $ provider = $ client -> getId ( ) ; $ clientId = $ attributes [ 'id' ] ; $ account = $ this -> finder -> findAccountByProviderAndClientId ( $ provider , $ clientId ) ; if ( $ account === null ) { $ account = \ Yii :: createObject ( [ 'class' => Account :: className ( ) , 'provider' => $ provider , 'client_id' => $ clientId , 'data' => json_encode ( $ attributes ) , 'user_id' => \ Yii :: $ app -> user -> id , ] ) ; $ account -> save ( false ) ; \ Yii :: $ app -> session -> setFlash ( 'success' , \ Yii :: t ( 'user' , 'Your account has been connected' ) ) ; } else if ( null == $ account -> user ) { $ account -> user_id = \ Yii :: $ app -> user -> id ; $ account -> save ( false ) ; } else { \ Yii :: $ app -> session -> setFlash ( 'error' , \ Yii :: t ( 'user' , 'This account has already been connected to another user' ) ) ; } $ this -> action -> successUrl = Url :: to ( [ '/user/settings/networks' ] ) ; }
3514	public function postMissingKeys ( ) { $ missingKeys = Request :: json ( 'missingKeys' ) ; $ this -> manager -> setConnectionName ( '' ) ; $ translator = App :: make ( 'translator' ) ; $ affectedGroups = [ ] ; foreach ( $ missingKeys as $ key ) { $ key = decodeKey ( $ key ) ; list ( $ namespace , $ group , $ item ) = $ translator -> parseKey ( $ key ) ; if ( $ item && $ group ) { if ( ! in_array ( $ group , $ this -> manager -> config ( Manager :: EXCLUDE_GROUPS_KEY ) ) ) { $ t = $ this -> manager -> missingKey ( $ namespace , $ group , $ item , null , false , true ) ; if ( ! $ t -> exists ) { $ affectedGroups [ ] = $ t -> group ; $ t -> save ( ) ; } } } else { } } $ data = [ 'connectionName' => '' , 'affectedGroups' => $ affectedGroups , 'missingKeys' => [ ] , ] ; $ pretty = Request :: has ( 'pretty-json' ) ? JSON_PRETTY_PRINT : 0 ; return Response :: json ( $ data , 200 , [ ] , JSON_UNESCAPED_SLASHES | $ pretty ) ; }
267	protected function loadMessagesFromDb ( $ category , $ language ) { $ mainQuery = ( new Query ( ) ) -> select ( [ 'message' => 't1.message' , 'translation' => 't2.translation' ] ) -> from ( [ 't1' => $ this -> sourceMessageTable , 't2' => $ this -> messageTable ] ) -> where ( [ 't1.id' => new Expression ( '[[t2.id]]' ) , 't1.category' => $ category , 't2.language' => $ language , ] ) ; $ fallbackLanguage = substr ( $ language , 0 , 2 ) ; $ fallbackSourceLanguage = substr ( $ this -> sourceLanguage , 0 , 2 ) ; if ( $ fallbackLanguage !== $ language ) { $ mainQuery -> union ( $ this -> createFallbackQuery ( $ category , $ language , $ fallbackLanguage ) , true ) ; } elseif ( $ language === $ fallbackSourceLanguage ) { $ mainQuery -> union ( $ this -> createFallbackQuery ( $ category , $ language , $ fallbackSourceLanguage ) , true ) ; } $ messages = $ mainQuery -> createCommand ( $ this -> db ) -> queryAll ( ) ; return ArrayHelper :: map ( $ messages , 'message' , 'translation' ) ; }
9226	public function get ( $ path , $ data = array ( ) , $ headers = array ( ) ) { return $ this -> postprocessResponse ( parent :: get ( $ path , $ this -> preprocessData ( $ data ) , $ headers ) ) ; }
6583	public static function create ( $ b , $ q , $ n = 1 ) { if ( $ n == 1 ) return new static ( $ b , $ q ) ; static :: ensureValid ( $ n , "Amount of elements must be an integer number bigger than zero." ) ; return new static ( $ b * ( 1 - $ q ) / ( 1 - pow ( $ q , $ n ) ) , $ q ) ; }
2397	public function parseBbCode ( $ strComment ) { $ arrSearch = array ( '@\[b\](.*)\[/b\]@Uis' , '@\[i\](.*)\[/i\]@Uis' , '@\[u\](.*)\[/u\]@Uis' , '@\s*\[code\](.*)\[/code\]\s*@Uis' , '@\[color=([^\]" ]+)\](.*)\[/color\]@Uis' , '@\s*\[quote\](.*)\[/quote\]\s*@Uis' , '@\s*\[quote=([^\]]+)\](.*)\[/quote\]\s*@Uis' , '@\[img\]\s*([^\[" ]+\.(jpe?g|png|gif|bmp|tiff?|ico))\s*\[/img\]@i' , '@\[url\]\s*([^\[" ]+)\s*\[/url\]@i' , '@\[url=([^\]" ]+)\](.*)\[/url\]@Uis' , '@\[email\]\s*([^\[" ]+)\s*\[/email\]@i' , '@\[email=([^\]" ]+)\](.*)\[/email\]@Uis' , '@href="(([a-z0-9]+\.)*[a-z0-9]+\.([a-z]{2}|asia|biz|com|info|name|net|org|tel)(/|"))@i' ) ; $ arrReplace = array ( '<strong>$1</strong>' , '<em>$1</em>' , '<span style="text-decoration:underline">$1</span>' , "\n\n" . '<div class="code"><p>' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'com_code' ] . '</p><pre>$1</pre></div>' . "\n\n" , '<span style="color:$1">$2</span>' , "\n\n" . '<blockquote>$1</blockquote>' . "\n\n" , "\n\n" . '<blockquote><p>' . sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'com_quote' ] , '$1' ) . '</p>$2</blockquote>' . "\n\n" , '<img src="$1" alt="" />' , '<a href="$1">$1</a>' , '<a href="$1">$2</a>' , '<a href="mailto:$1">$1</a>' , '<a href="mailto:$1">$2</a>' , 'href="http://$1' ) ; $ strComment = preg_replace ( $ arrSearch , $ arrReplace , $ strComment ) ; if ( strpos ( $ strComment , 'mailto:' ) !== false ) { $ strComment = StringUtil :: encodeEmail ( $ strComment ) ; } return $ strComment ; }
382	public function argumentsToString ( $ args ) { $ count = 0 ; $ isAssoc = $ args !== array_values ( $ args ) ; foreach ( $ args as $ key => $ value ) { $ count ++ ; if ( $ count >= 5 ) { if ( $ count > 5 ) { unset ( $ args [ $ key ] ) ; } else { $ args [ $ key ] = '...' ; } continue ; } if ( is_object ( $ value ) ) { $ args [ $ key ] = '<span class="title">' . $ this -> htmlEncode ( get_class ( $ value ) ) . '</span>' ; } elseif ( is_bool ( $ value ) ) { $ args [ $ key ] = '<span class="keyword">' . ( $ value ? 'true' : 'false' ) . '</span>' ; } elseif ( is_string ( $ value ) ) { $ fullValue = $ this -> htmlEncode ( $ value ) ; if ( mb_strlen ( $ value , 'UTF-8' ) > 32 ) { $ displayValue = $ this -> htmlEncode ( mb_substr ( $ value , 0 , 32 , 'UTF-8' ) ) . '...' ; $ args [ $ key ] = "<span class=\"string\" title=\"$fullValue\">'$displayValue'</span>" ; } else { $ args [ $ key ] = "<span class=\"string\">'$fullValue'</span>" ; } } elseif ( is_array ( $ value ) ) { $ args [ $ key ] = '[' . $ this -> argumentsToString ( $ value ) . ']' ; } elseif ( $ value === null ) { $ args [ $ key ] = '<span class="keyword">null</span>' ; } elseif ( is_resource ( $ value ) ) { $ args [ $ key ] = '<span class="keyword">resource</span>' ; } else { $ args [ $ key ] = '<span class="number">' . $ value . '</span>' ; } if ( is_string ( $ key ) ) { $ args [ $ key ] = '<span class="string">\'' . $ this -> htmlEncode ( $ key ) . "'</span> => $args[$key]" ; } elseif ( $ isAssoc ) { $ args [ $ key ] = "<span class=\"number\">$key</span> => $args[$key]" ; } } return implode ( ', ' , $ args ) ; }
2149	public function createNewUser ( $ intUser , $ arrData ) { $ arrNewsletters = StringUtil :: deserialize ( $ arrData [ 'newsletter' ] , true ) ; if ( ! \ is_array ( $ arrNewsletters ) ) { return ; } $ time = time ( ) ; foreach ( $ arrNewsletters as $ intNewsletter ) { $ intNewsletter = ( int ) $ intNewsletter ; if ( $ intNewsletter < 1 ) { continue ; } $ objRecipient = $ this -> Database -> prepare ( "SELECT COUNT(*) AS count FROM tl_newsletter_recipients WHERE pid=? AND email=?" ) -> execute ( $ intNewsletter , $ arrData [ 'email' ] ) ; if ( $ objRecipient -> count < 1 ) { $ this -> Database -> prepare ( "INSERT INTO tl_newsletter_recipients SET pid=?, tstamp=$time, email=?, addedOn=$time" ) -> execute ( $ intNewsletter , $ arrData [ 'email' ] ) ; } } }
12695	static function getVendorDir ( $ vendorPrefix = 'vendor' ) { if ( is_dir ( __DIR__ . '/../../../composer' ) && is_file ( __DIR__ . '/../../../autoload.php' ) ) { return realpath ( __DIR__ . '/../../..' ) ; } if ( is_dir ( __DIR__ . "/../$vendorPrefix/composer" ) && is_file ( __DIR__ . "/../$vendorPrefix/autoload.php" ) ) { return realpath ( __DIR__ . "/../$vendorPrefix" ) ; } return false ; }
2382	public static function findPublishedByParentAndIdOrAlias ( $ varId , $ arrPids , array $ arrOptions = array ( ) ) { if ( empty ( $ arrPids ) || ! \ is_array ( $ arrPids ) ) { return null ; } $ t = static :: $ strTable ; $ arrColumns = ! preg_match ( '/^[1-9]\d*$/' , $ varId ) ? array ( "$t.alias=?" ) : array ( "$t.id=?" ) ; $ arrColumns [ ] = "$t.pid IN(" . implode ( ',' , array_map ( '\intval' , $ arrPids ) ) . ")" ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ arrColumns [ ] = "$t.published='1'" ; } return static :: findOneBy ( $ arrColumns , $ varId , $ arrOptions ) ; }
10096	protected function processSize ( $ size ) { if ( $ size === null ) { return $ size ; } $ size = ( int ) $ size ; if ( $ size <= 0 ) { throw new InvalidArgumentException ( 'Size has to be larger than 0' ) ; } return ( int ) $ size ; }
11638	public function getAuthorities ( ) { $ authorities = [ ] ; foreach ( $ this -> getAll ( ) as $ typeItem ) { if ( isset ( $ typeItem -> object ) && $ typeItem -> object -> getBehavior ( 'Authority' ) !== null ) { $ authorities [ $ typeItem -> object -> systemId ] = $ typeItem -> object ; } } return $ authorities ; }
1696	public static function findByIds ( $ arrIds ) { if ( empty ( $ arrIds ) || ! \ is_array ( $ arrIds ) ) { return null ; } $ objDatabase = Database :: getInstance ( ) ; $ arrIds = array_map ( '\intval' , $ arrIds ) ; $ objResult = $ objDatabase -> execute ( "SELECT *, (SELECT tstamp FROM tl_theme WHERE tl_theme.id=tl_style_sheet.pid) AS tstamp3, (SELECT MAX(tstamp) FROM tl_style WHERE tl_style.pid=tl_style_sheet.id) AS tstamp2, (SELECT COUNT(*) FROM tl_style WHERE tl_style.selector='@font-face' AND tl_style.invisible='' AND tl_style.pid=tl_style_sheet.id) AS hasFontFace FROM tl_style_sheet WHERE id IN (" . implode ( ',' , $ arrIds ) . ") ORDER BY " . $ objDatabase -> findInSet ( 'id' , $ arrIds ) ) ; return static :: createCollectionFromDbResult ( $ objResult , 'tl_style_sheet' ) ; }
7880	protected function registerLogViewerController ( ) { $ this -> app -> bind ( LogViewerController :: class , function ( $ app ) { $ perPage = $ app [ 'config' ] [ 'logviewer.per_page' ] ; $ middleware = $ app [ 'config' ] [ 'logviewer.middleware' ] ; return new LogViewerController ( $ perPage , $ middleware ) ; } ) ; }
8212	protected function validateFile ( $ filePath , $ message = 'File' , $ allowEmpty = true ) { if ( ! file_exists ( $ filePath ) || ! is_readable ( $ filePath ) ) { throw new \ RuntimeException ( "$message '{$filePath}' doesn't exist or is not readable." ) ; } if ( ! $ allowEmpty && 0 === filesize ( $ filePath ) ) { throw new \ RuntimeException ( "$message '{$filePath}' is empty." ) ; } return realpath ( $ filePath ) ; }
11092	public static function poorManTranslate ( $ category , $ text , array $ params = [ ] ) { if ( class_exists ( 'Yii' ) ) { return \ Yii :: t ( $ category , $ text , $ params ) ; } $ pos = strrpos ( $ category , '/' ) ; $ category = $ pos === false ? $ category : substr ( $ category , $ pos + 1 ) ; $ translation = @ include 'messages/cs/' . $ category . '.php' ; if ( $ translation !== null && \ is_array ( $ translation ) && array_key_exists ( $ text , $ translation ) ) { $ keys = array_keys ( $ params ) ; array_walk ( $ keys , function ( & $ v ) { $ v = '{' . $ v . '}' ; } ) ; return str_replace ( array_values ( $ params ) , $ keys , $ translation [ $ text ] ) ; } return $ text ; }
5194	public function addRoutes ( RouteCollector $ routeCollector ) : void { foreach ( $ this -> routes as $ index => $ route ) { $ routeCollector -> addRoute ( $ route -> getMethods ( ) , $ route -> getPath ( ) , $ index ) ; } }
9465	public function getSummary ( ) { $ string = "---\n" ; foreach ( $ this -> getWords ( ) as $ k => $ v ) { $ string .= '[' . $ k . ']: Docs:' . $ v [ 'docs' ] . ' | Hits:' . $ v [ 'hits' ] . "\n" ; } return $ string ; }
5713	public function updateItemEditForm ( $ form ) { if ( $ this -> owner -> record -> stat ( 'better_buttons_enabled' ) !== true ) { return false ; } Requirements :: css ( BETTER_BUTTONS_DIR . '/css/gridfield_betterbuttons.css' ) ; Requirements :: javascript ( BETTER_BUTTONS_DIR . '/javascript/gridfield_betterbuttons.js' ) ; $ actions = $ this -> owner -> record -> getBetterButtonsActions ( ) ; $ form -> setActions ( $ this -> filterFieldList ( $ form , $ actions ) ) ; if ( $ form -> Fields ( ) -> hasTabSet ( ) ) { $ form -> Fields ( ) -> findOrMakeTab ( 'Root' ) -> setTemplate ( TabSet :: class ) ; $ form -> addExtraClass ( 'cms-tabset' ) ; } $ utils = $ this -> owner -> record -> getBetterButtonsUtils ( ) ; $ form -> Utils = $ this -> filterFieldList ( $ form , $ utils ) ; $ form -> setTemplate ( [ 'type' => 'Includes' , 'BetterButtons_EditForm' , ] ) ; $ form -> addExtraClass ( 'better-buttons-form' ) ; }
12966	public function getObjectTypeDescriptor ( ) { if ( is_null ( $ this -> _objectTypeDescriptor ) && isset ( $ this -> object ) ) { $ this -> _objectTypeDescriptor = $ this -> object -> objectType -> title -> upperSingular ; } return $ this -> _objectTypeDescriptor ; }
9140	public static function parseFromServerRequest ( $ serverVars , $ defaultController = 'Index' , $ defaultAction = 'index' ) { if ( ! isset ( $ serverVars [ 'REQUEST_URI' ] ) ) { throw new InvalidUrlException ( "No such uri provided" ) ; } return self :: parse ( $ serverVars [ 'REQUEST_URI' ] , $ serverVars , $ defaultController , $ defaultAction ) ; }
10439	protected function nextBufferLine ( ) { $ query = $ this -> parseQuery ( ) ; if ( ! empty ( $ query ) ) { $ this -> buffer [ $ this -> key ] [ self :: PARAM_QUERY ] = $ query ; } else { $ this -> buffer [ $ this -> key ] = false ; } }
8676	public function flip ( ) { if ( ! $ this -> items ) { return $ this -> createFrom ( [ ] ) ; } try { return $ this -> createFrom ( Thrower :: call ( 'array_flip' , $ this -> items ) ) ; } catch ( ErrorException $ e ) { throw new LogicException ( 'Only string and integer values can be flipped' ) ; } }
4196	private function getAbstractionDetails ( Event $ abs ) { $ reflector = $ abs [ 'reflector' ] ; $ abs [ 'phpDoc' ] = $ this -> phpDoc -> getParsed ( $ reflector ) ; $ traversed = false ; if ( $ abs [ 'debugMethod' ] === 'table' && \ count ( $ abs [ 'hist' ] ) < 2 ) { $ obj = $ abs -> getSubject ( ) ; if ( $ obj instanceof \ Traversable && ! $ abs [ 'traverseValues' ] ) { $ traversed = true ; $ abs [ 'hist' ] [ ] = $ obj ; foreach ( $ obj as $ k => $ v ) { $ abs [ 'traverseValues' ] [ $ k ] = $ this -> abstracter -> needsAbstraction ( $ v ) ? $ this -> abstracter -> getAbstraction ( $ v , $ abs [ 'debugMethod' ] , $ abs [ 'hist' ] ) : $ v ; } } } if ( ! $ traversed ) { $ this -> addConstants ( $ abs ) ; while ( $ reflector = $ reflector -> getParentClass ( ) ) { $ abs [ 'extends' ] [ ] = $ reflector -> getName ( ) ; } $ this -> addProperties ( $ abs ) ; $ this -> addMethods ( $ abs ) ; } }
8931	private function addRoute ( $ method ) { switch ( $ method ) { case 'index' : $ methodMap = [ 'GET' ] ; $ realRoute = '$route' ; $ controllerCallable = $ this -> controllerLocation . ':indexAction' ; break ; case 'get' : $ methodMap = [ 'GET' ] ; $ realRoute = '$route/{id}' ; $ controllerCallable = $ this -> controllerLocation . ':getAction' ; break ; case 'post' : $ methodMap = [ 'POST' ] ; $ realRoute = '$route' ; $ controllerCallable = $ this -> controllerLocation . ':postAction' ; break ; case 'put' : $ methodMap = [ 'POST' , 'PUT' ] ; $ realRoute = '$route/{id}' ; $ controllerCallable = $ this -> controllerLocation . ':putAction' ; break ; case 'delete' : $ methodMap = [ 'DELETE' ] ; $ realRoute = '$route/{id}' ; $ controllerCallable = $ this -> controllerLocation . ':deleteAction' ; break ; default : throw new \ Exception ( 'Invalid method.' . $ method ) ; break ; } $ methodMap = "['" . implode ( "', '" , $ methodMap ) . "']" ; $ command = strtr ( $ this -> template , [ '$methodMap' => $ methodMap , '$route' => $ realRoute , '$controllerCallable' => $ controllerCallable ] ) ; $ this -> commands [ ] = $ command ; }
5828	public function newRequest ( $ method , $ url , $ data = array ( ) , $ encoding = Request :: ENCODING_QUERY ) { $ class = $ this -> requestClass ; $ request = new $ class ( $ this ) ; $ request -> setMethod ( $ method ) ; $ request -> setUrl ( $ url ) ; $ request -> setData ( $ data ) ; $ request -> setEncoding ( $ encoding ) ; return $ request ; }
8687	public static function replaceRecursive ( $ iterable1 , $ iterable2 ) { Assert :: allIsIterable ( [ $ iterable1 , $ iterable2 ] ) ; if ( $ iterable1 instanceof Traversable ) { $ iterable1 = iterator_to_array ( $ iterable1 ) ; } if ( $ iterable2 instanceof Traversable ) { $ iterable2 = iterator_to_array ( $ iterable2 ) ; } $ merged = $ iterable1 ; foreach ( $ iterable2 as $ key => $ value ) { if ( $ value instanceof Traversable ) { $ value = iterator_to_array ( $ value ) ; } if ( is_array ( $ value ) && static :: isAssociative ( $ value ) && isset ( $ merged [ $ key ] ) && \ is_iterable ( $ merged [ $ key ] ) ) { $ merged [ $ key ] = static :: replaceRecursive ( $ merged [ $ key ] , $ value ) ; } elseif ( $ value === null && isset ( $ merged [ $ key ] ) && \ is_iterable ( $ merged [ $ key ] ) ) { if ( $ merged [ $ key ] instanceof Traversable ) { $ merged [ $ key ] = iterator_to_array ( $ merged [ $ key ] ) ; } continue ; } else { $ merged [ $ key ] = $ value ; } } return $ merged ; }
2357	public function getFrontendUsername ( ) : ? string { $ token = $ this -> getToken ( FrontendUser :: SECURITY_SESSION_KEY ) ; if ( null === $ token || ! $ token -> getUser ( ) instanceof FrontendUser ) { return null ; } return $ token -> getUser ( ) -> getUsername ( ) ; }
9864	private function writeDataValidations ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { $ dataValidationCollection = $ pSheet -> getDataValidationCollection ( ) ; if ( ! empty ( $ dataValidationCollection ) ) { $ dataValidationCollection = Coordinate :: mergeRangesInCollection ( $ dataValidationCollection ) ; $ objWriter -> startElement ( 'dataValidations' ) ; $ objWriter -> writeAttribute ( 'count' , count ( $ dataValidationCollection ) ) ; foreach ( $ dataValidationCollection as $ coordinate => $ dv ) { $ objWriter -> startElement ( 'dataValidation' ) ; if ( $ dv -> getType ( ) != '' ) { $ objWriter -> writeAttribute ( 'type' , $ dv -> getType ( ) ) ; } if ( $ dv -> getErrorStyle ( ) != '' ) { $ objWriter -> writeAttribute ( 'errorStyle' , $ dv -> getErrorStyle ( ) ) ; } if ( $ dv -> getOperator ( ) != '' ) { $ objWriter -> writeAttribute ( 'operator' , $ dv -> getOperator ( ) ) ; } $ objWriter -> writeAttribute ( 'allowBlank' , ( $ dv -> getAllowBlank ( ) ? '1' : '0' ) ) ; $ objWriter -> writeAttribute ( 'showDropDown' , ( ! $ dv -> getShowDropDown ( ) ? '1' : '0' ) ) ; $ objWriter -> writeAttribute ( 'showInputMessage' , ( $ dv -> getShowInputMessage ( ) ? '1' : '0' ) ) ; $ objWriter -> writeAttribute ( 'showErrorMessage' , ( $ dv -> getShowErrorMessage ( ) ? '1' : '0' ) ) ; if ( $ dv -> getErrorTitle ( ) !== '' ) { $ objWriter -> writeAttribute ( 'errorTitle' , $ dv -> getErrorTitle ( ) ) ; } if ( $ dv -> getError ( ) !== '' ) { $ objWriter -> writeAttribute ( 'error' , $ dv -> getError ( ) ) ; } if ( $ dv -> getPromptTitle ( ) !== '' ) { $ objWriter -> writeAttribute ( 'promptTitle' , $ dv -> getPromptTitle ( ) ) ; } if ( $ dv -> getPrompt ( ) !== '' ) { $ objWriter -> writeAttribute ( 'prompt' , $ dv -> getPrompt ( ) ) ; } $ objWriter -> writeAttribute ( 'sqref' , $ coordinate ) ; if ( $ dv -> getFormula1 ( ) !== '' ) { $ objWriter -> writeElement ( 'formula1' , $ dv -> getFormula1 ( ) ) ; } if ( $ dv -> getFormula2 ( ) !== '' ) { $ objWriter -> writeElement ( 'formula2' , $ dv -> getFormula2 ( ) ) ; } $ objWriter -> endElement ( ) ; } $ objWriter -> endElement ( ) ; } }
1909	private function stripNamespace ( string $ fqcn ) : string { if ( false !== ( $ pos = strrpos ( $ fqcn , '\\' ) ) ) { return substr ( $ fqcn , $ pos + 1 ) ; } return $ fqcn ; }
10626	public static function docroot ( ) { if ( ! empty ( $ _SERVER [ 'DOCUMENT_ROOT' ] ) ) { $ docroot = str_replace ( '\\' , '/' , $ _SERVER [ 'DOCUMENT_ROOT' ] ) ; } else { $ docroot = str_replace ( '\\' , '/' , dirname ( __FILE__ ) ) ; } return $ docroot ; }
4626	private function createIndexQueryPath ( Bucket $ bucket ) { $ command = $ this -> command ; if ( $ command -> isMatchQuery ( ) ) { $ path = sprintf ( '/types/%s/buckets/%s/index/%s/%s' , $ bucket -> getType ( ) , $ bucket -> getName ( ) , $ command -> getIndexName ( ) , $ command -> getMatchValue ( ) ) ; } elseif ( $ command -> isRangeQuery ( ) ) { $ path = sprintf ( '/types/%s/buckets/%s/index/%s/%s/%s' , $ bucket -> getType ( ) , $ bucket -> getName ( ) , $ command -> getIndexName ( ) , $ command -> getLowerBound ( ) , $ command -> getUpperBound ( ) ) ; } else { throw new Api \ Exception ( "Invalid Secondary Index Query." ) ; } return $ path ; }
5887	public function iconGetName ( $ key ) { $ iconid = ( $ this [ $ key ] < 0 ) ? ( pow ( 2 , 32 ) ) - ( $ this [ $ key ] * - 1 ) : $ this [ $ key ] ; return new StringHelper ( "/icon_" . $ iconid ) ; }
10141	private function loadOLE ( $ pFilename ) { $ ole = new OLERead ( ) ; $ ole -> read ( $ pFilename ) ; $ this -> data = $ ole -> getStream ( $ ole -> wrkbook ) ; $ this -> summaryInformation = $ ole -> getStream ( $ ole -> summaryInformation ) ; $ this -> documentSummaryInformation = $ ole -> getStream ( $ ole -> documentSummaryInformation ) ; }
10448	private function callIfExistsAndEnabled ( $ method , array $ parameters = [ ] ) { if ( ! $ this -> isEnabled ( ) ) return ; if ( method_exists ( $ this , $ method ) && $ this -> { "{$method}IsEnabled" } ( ) ) { $ this -> container -> call ( [ $ this , $ method ] , $ parameters ) ; } }
1013	private function readComment ( $ line , $ col , Token $ prev ) { $ start = $ this -> position ; $ value = '' ; $ bytes = 1 ; do { [ $ char , $ code , $ bytes ] = $ this -> moveStringCursor ( 1 , $ bytes ) -> readChar ( ) ; $ value .= $ char ; } while ( $ code && ( $ code > 0x001F || $ code === 0x0009 ) ) ; return new Token ( Token :: COMMENT , $ start , $ this -> position , $ line , $ col , $ prev , $ value ) ; }
12472	public static function isEnabled ( ) { $ class = self :: className ( ) ; foreach ( \ Yii :: $ app -> modules as $ module => $ params ) { switch ( gettype ( $ params ) ) { case 'array' : if ( $ class == @ $ params [ 'class' ] ) return true ; break ; case 'object' : if ( $ class == get_class ( $ params ) ) return true ; break ; default : if ( $ class == $ params ) return true ; } if ( $ module == $ class || ( isset ( $ module [ 'class' ] ) && $ module [ 'class' ] == $ class ) ) { return true ; } } return false ; }
12637	public static function connect ( string $ host = "" , int $ port = 0 , string $ dbname = "" , string $ user = "" , string $ pass = "" , bool $ reconnect = false ) : ? \ PDO { if ( self :: $ pdo !== null && ! $ reconnect ) return self :: $ pdo ; if ( $ host === "" && ( self :: $ databaseHost === null || self :: $ databaseHost === "" ) ) throw new Exceptions \ DatabaseConnectionException ( "A valid host name was not provided!" ) ; $ host = $ host ? : self :: $ databaseHost ; if ( $ port === 0 && ( self :: $ databasePort === null || self :: $ databasePort === 0 ) ) throw new Exceptions \ DatabaseConnectionException ( "A valid port number was not provided!" ) ; $ port = $ port ? : self :: $ databasePort ; if ( $ dbname === "" && ( self :: $ databaseName === null || self :: $ databaseName === "" ) ) throw new Exceptions \ DatabaseConnectionException ( "A valid database name was not provided!" ) ; $ dbname = $ dbname ? : self :: $ databaseName ; if ( $ user === "" && ( self :: $ databaseUser === null || self :: $ databaseUser === "" ) ) throw new Exceptions \ DatabaseConnectionException ( "A valid username was not provided!" ) ; $ user = $ user ? : self :: $ databaseUser ; if ( $ pass === "" && ( self :: $ databasePass === null || self :: $ databasePass === "" ) ) throw new Exceptions \ DatabaseConnectionException ( "A valid password was not provided!" ) ; $ pass = $ pass ? : self :: $ databasePass ; try { self :: $ pdo = new \ PDO ( "pgsql:host=$host;port=$port;dbname=$dbname" , $ user , $ pass , [ \ PDO :: ATTR_DEFAULT_FETCH_MODE => \ PDO :: FETCH_ASSOC , ] ) ; if ( self :: $ pdo ) return self :: $ pdo ; } catch ( \ PDOException $ e ) { throw new Exceptions \ DatabaseConnectionException ( $ e -> getMessage ( ) ) ; } return null ; }
8614	public function setFeedSubmissionInfoList ( $ feedSubmissionInfo ) { if ( ! $ this -> _isNumericArray ( $ feedSubmissionInfo ) ) { $ feedSubmissionInfo = array ( $ feedSubmissionInfo ) ; } $ this -> fields [ 'FeedSubmissionInfo' ] [ 'FieldValue' ] = $ feedSubmissionInfo ; return $ this ; }
2305	protected function doCreatePageList ( $ intId = 0 , $ level = - 1 ) { $ objPages = $ this -> Database -> prepare ( "SELECT id, title, type, dns FROM tl_page WHERE pid=? ORDER BY sorting" ) -> execute ( $ intId ) ; if ( $ objPages -> numRows < 1 ) { return '' ; } ++ $ level ; $ strOptions = '' ; while ( $ objPages -> next ( ) ) { if ( $ objPages -> type == 'root' ) { if ( $ objPages -> dns && $ objPages -> dns != Environment :: get ( 'host' ) ) { continue ; } $ strOptions .= '<optgroup label="' . $ objPages -> title . '">' ; $ strOptions .= $ this -> doCreatePageList ( $ objPages -> id , - 1 ) ; $ strOptions .= '</optgroup>' ; } else { $ strOptions .= sprintf ( '<option value="{{link_url::%s}}"%s>%s%s</option>' , $ objPages -> id , ( ( '{{link_url::' . $ objPages -> id . '}}' == Input :: get ( 'value' ) ) ? ' selected="selected"' : '' ) , str_repeat ( ' &nbsp; &nbsp; ' , $ level ) , StringUtil :: specialchars ( $ objPages -> title ) ) ; $ strOptions .= $ this -> doCreatePageList ( $ objPages -> id , $ level ) ; } } return $ strOptions ; }
6722	public function fetchAccessToken ( $ code ) { $ this -> validateTokenParams ( ) ; $ this -> oauth2 -> tokenUrl = $ this -> tokenUrl ; $ this -> oauth2 -> clientId = $ this -> clientId ; $ this -> oauth2 -> clientSecret = $ this -> clientSecret ; try { $ response = $ this -> oauth2 -> fetchAccessToken ( $ code ) ; } catch ( Exception $ ex ) { throw new Oauth2ClientException ( $ ex -> getMessage ( ) ) ; } return $ this -> handleTokenResponse ( $ response ) ; }
8409	public static function clear ( ) { $ keys = array_keys ( $ _COOKIE ) ; foreach ( $ keys as $ key ) { setcookie ( $ key , '' , time ( ) - 1 ) ; } }
2625	protected function _toHtml ( ) { if ( $ this -> config -> isGeoIpEnabled ( ) == false || $ this -> config -> isFastlyEnabled ( ) == false ) { return parent :: _toHtml ( ) ; } $ actionUrl = $ this -> getUrl ( 'fastlyCdn/geoip/getaction' ) ; $ header = $ this -> response -> getHeader ( 'x-esi' ) ; if ( empty ( $ header ) ) { $ this -> response -> setHeader ( "x-esi" , "1" ) ; } return sprintf ( '<esi:include src=\'%s\' />' , preg_replace ( "/^https/" , "http" , $ actionUrl ) ) ; }
2581	protected function loadOverrideSoapClient ( $ params ) { if ( isset ( $ params [ 'overrideSoapClient' ] ) && $ params [ 'overrideSoapClient' ] instanceof \ SoapClient ) { $ this -> overrideSoapClient = $ params [ 'overrideSoapClient' ] ; } if ( isset ( $ params [ 'overrideSoapClientWsdlName' ] ) ) { $ this -> overrideSoapClientWsdlName = $ params [ 'overrideSoapClientWsdlName' ] ; } }
10464	private function deductionForDeletion ( $ connection , $ tableName , $ documentType , $ documentId , $ shopId ) { $ sql = sprintf ( "SELECT `id` FROM {$tableName} WHERE `type` != 'D' AND `document_type` = :documentType AND `document_id` = :documentId AND `status` = :status AND `id` < :id" ) ; $ statement = $ connection -> prepare ( $ sql ) ; $ statement -> execute ( [ 'documentType' => $ documentType , 'documentId' => $ documentId , 'status' => self :: STATUS_NEW , 'id' => $ connection -> lastInsertId ( ) , ] ) ; $ entries = $ statement -> fetchAll ( ) ; foreach ( $ entries as $ entry ) { $ this -> removeRecord ( $ entry [ 'id' ] , [ $ shopId ] ) ; } }
5203	public function close ( ) { if ( isset ( $ this -> channel ) ) $ this -> channel -> close ( ) ; if ( isset ( $ this -> AMQPConnection ) ) $ this -> AMQPConnection -> close ( ) ; }
4987	public function setForm ( $ key , $ spec , $ enabled = true ) { if ( is_object ( $ spec ) ) { if ( $ spec instanceof FormParentInterface ) { $ spec -> setParent ( $ this ) ; } $ spec = [ '__instance__' => $ spec , 'name' => $ key , 'entity' => '*' ] ; } if ( ! is_array ( $ spec ) ) { $ spec = array ( 'type' => $ spec , 'name' => $ key ) ; } if ( ! isset ( $ spec [ 'name' ] ) ) { $ spec [ 'name' ] = $ key ; } if ( ! isset ( $ spec [ 'entity' ] ) ) { $ spec [ 'entity' ] = '*' ; } $ this -> forms [ $ key ] = $ spec ; if ( $ enabled ) { $ this -> enableForm ( $ key ) ; } elseif ( true === $ this -> activeForms ) { $ this -> activeForms = false ; } return $ this ; }
8327	public function recognizeRecaptchaV2 ( $ googleKey , $ pageUrl , $ extra = [ ] ) { $ captchaId = $ this -> sendRecaptchaV2 ( $ googleKey , $ pageUrl , $ extra ) ; $ startTime = time ( ) ; while ( true ) { $ this -> getLogger ( ) -> info ( "Waiting {$this->rTimeout} sec." ) ; sleep ( $ this -> recaptchaRTimeout ) ; if ( time ( ) - $ startTime >= $ this -> mTimeout ) { throw new RuntimeException ( "Captcha waiting timeout." ) ; } $ result = $ this -> getCaptchaResult ( $ captchaId ) ; if ( $ result === false ) { continue ; } $ this -> getLogger ( ) -> info ( "Elapsed " . ( time ( ) - $ startTime ) . " second(s)." ) ; return $ result ; } throw new RuntimeException ( 'Unknown recognition logic error.' ) ; }
238	protected function normalizePdoRowKeyCase ( array $ row , $ multiple ) { if ( $ this -> db -> getSlavePdo ( ) -> getAttribute ( \ PDO :: ATTR_CASE ) !== \ PDO :: CASE_UPPER ) { return $ row ; } if ( $ multiple ) { return array_map ( function ( array $ row ) { return array_change_key_case ( $ row , CASE_LOWER ) ; } , $ row ) ; } return array_change_key_case ( $ row , CASE_LOWER ) ; }
12101	public function setAccept ( $ accept ) { $ this -> setTag ( 'accept' , $ accept ) ; if ( $ this -> getValidator ( ) ) { $ this -> getValidator ( ) -> setOption ( 'accept' , $ accept ) ; } }
4375	protected function buildGroupMethod ( $ method , $ args = array ( ) , $ meta = array ( ) ) { $ str = '' ; if ( \ in_array ( $ method , array ( 'group' , 'groupCollapsed' ) ) ) { $ label = \ array_shift ( $ args ) ; $ levelClass = isset ( $ meta [ 'level' ] ) ? 'level-' . $ meta [ 'level' ] : null ; if ( ! empty ( $ meta [ 'isMethodName' ] ) ) { $ label = $ this -> markupClassname ( $ label ) ; } foreach ( $ args as $ k => $ v ) { $ args [ $ k ] = $ this -> dump ( $ v ) ; } $ argStr = \ implode ( ', ' , $ args ) ; $ str .= $ this -> debug -> utilities -> buildTag ( 'div' , array ( 'class' => array ( 'group-header' , $ method == 'groupCollapsed' ? 'collapsed' : 'expanded' , $ levelClass , ) , 'data-channel' => $ meta [ 'channel' ] , ) , '<span class="group-label">' . $ label . ( ! empty ( $ argStr ) ? '(</span>' . $ argStr . '<span class="group-label">)' : '' ) . '</span>' ) . "\n" ; $ str .= '<div' . $ this -> debug -> utilities -> buildAttribString ( array ( 'class' => array ( 'm_group' , $ levelClass , ) , ) ) . '>' ; } elseif ( $ method == 'groupEnd' ) { $ str = '</div>' ; } return $ str ; }
4227	public function unregister ( ) { if ( ! $ this -> registered ) { return ; } $ errHandlerCur = \ set_error_handler ( array ( $ this , 'handleError' ) ) ; \ restore_error_handler ( ) ; if ( $ errHandlerCur == array ( $ this , 'handleError' ) ) { \ restore_error_handler ( ) ; } $ exHandlerCur = \ set_exception_handler ( array ( $ this , 'handleException' ) ) ; \ restore_exception_handler ( ) ; if ( $ exHandlerCur == array ( $ this , 'handleException' ) ) { \ restore_exception_handler ( ) ; } \ ini_set ( 'display_errors' , $ this -> prevDisplayErrors ) ; $ this -> prevErrorHandler = null ; $ this -> prevExceptionHandler = null ; $ this -> registered = false ; return ; }
7287	public function getInvoicedAt ( $ latest = false ) { if ( 0 == $ this -> invoices -> count ( ) ) { return null ; } $ criteria = Criteria :: create ( ) ; $ criteria -> andWhere ( Criteria :: expr ( ) -> eq ( 'type' , InvoiceTypes :: TYPE_INVOICE ) ) -> orderBy ( [ 'createdAt' => $ latest ? Criteria :: DESC : Criteria :: ASC ] ) ; $ invoices = $ this -> invoices ; $ invoices = $ invoices -> matching ( $ criteria ) ; if ( false !== $ invoice = $ invoices -> first ( ) ) { return $ invoice -> getCreatedAt ( ) ; } return null ; }
11844	private function addAPerson ( array $ person , ObjectManager $ manager ) { $ p = new Person ( ) ; foreach ( $ person as $ key => $ value ) { switch ( $ key ) { case 'CountryOfBirth' : case 'Nationality' : $ value = $ this -> getCountry ( $ value ) ; break ; case 'Birthdate' : $ value = new \ DateTime ( $ value ) ; break ; case 'center' : case 'maritalStatus' : $ value = $ this -> getReference ( $ value ) ; break ; } if ( method_exists ( $ p , 'set' . $ key ) ) { call_user_func ( array ( $ p , 'set' . $ key ) , $ value ) ; } elseif ( method_exists ( $ p , 'add' . $ key ) ) { if ( ! is_array ( $ value ) ) { $ value = array ( $ value ) ; } foreach ( $ value as $ v ) { if ( $ v !== NULL ) { call_user_func ( array ( $ p , 'add' . $ key ) , $ v ) ; } } } } $ manager -> persist ( $ p ) ; echo "add person'" . $ p -> __toString ( ) . "'\n" ; }
195	public function sendContentAsFile ( $ content , $ attachmentName , $ options = [ ] ) { $ headers = $ this -> getHeaders ( ) ; $ contentLength = StringHelper :: byteLength ( $ content ) ; $ range = $ this -> getHttpRange ( $ contentLength ) ; if ( $ range === false ) { $ headers -> set ( 'Content-Range' , "bytes */$contentLength" ) ; throw new RangeNotSatisfiableHttpException ( ) ; } list ( $ begin , $ end ) = $ range ; if ( $ begin != 0 || $ end != $ contentLength - 1 ) { $ this -> setStatusCode ( 206 ) ; $ headers -> set ( 'Content-Range' , "bytes $begin-$end/$contentLength" ) ; $ this -> content = StringHelper :: byteSubstr ( $ content , $ begin , $ end - $ begin + 1 ) ; } else { $ this -> setStatusCode ( 200 ) ; $ this -> content = $ content ; } $ mimeType = isset ( $ options [ 'mimeType' ] ) ? $ options [ 'mimeType' ] : 'application/octet-stream' ; $ this -> setDownloadHeaders ( $ attachmentName , $ mimeType , ! empty ( $ options [ 'inline' ] ) , $ end - $ begin + 1 ) ; $ this -> format = self :: FORMAT_RAW ; return $ this ; }
9160	private function adjustHeaders ( $ requestType ) { if ( ! array_key_exists ( 'Accept' , $ this -> headers ) && $ requestType != 'HEAD' ) { $ this -> setHeader ( 'Accept' , 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8' ) ; } if ( ! array_key_exists ( 'Accept-Language' , $ this -> headers ) && $ requestType != 'HEAD' ) { $ this -> setHeader ( 'Accept-Language' , 'en-US;q=0.7,en;q=0.3' ) ; } if ( ! array_key_exists ( 'User-Agent' , $ this -> headers ) && $ requestType != 'HEAD' ) { $ this -> setHeader ( 'User-Agent' , 'phpGenerics 1.0' ) ; } if ( ! array_key_exists ( 'Connection' , $ this -> headers ) || strlen ( $ this -> headers [ 'Connection' ] ) == 0 ) { $ this -> adjustConnectionHeader ( $ requestType ) ; } if ( ! array_key_exists ( 'Accept-Encoding' , $ this -> headers ) ) { if ( function_exists ( 'gzinflate' ) ) { $ encoding = 'gzip, deflate' ; } else { $ encoding = 'identity' ; } $ this -> setHeader ( 'Accept-Encoding' , $ encoding ) ; } }
1810	public function adjustDcaByType ( $ dc ) { $ objCte = Contao \ ContentModel :: findByPk ( $ dc -> id ) ; if ( $ objCte === null ) { return ; } switch ( $ objCte -> type ) { case 'hyperlink' : unset ( $ GLOBALS [ 'TL_DCA' ] [ 'tl_content' ] [ 'fields' ] [ 'imageUrl' ] ) ; break ; case 'image' : $ GLOBALS [ 'TL_DCA' ] [ 'tl_content' ] [ 'fields' ] [ 'imagemargin' ] [ 'eval' ] [ 'tl_class' ] .= ' clr' ; break ; } }
1154	public function makeReplacements ( $ message , $ attribute , $ rule , $ parameters ) { if ( is_object ( $ rule ) ) { $ rule = get_class ( $ rule ) ; } return $ this -> callValidator ( 'makeReplacements' , [ $ message , $ attribute , $ rule , $ parameters ] ) ; }
828	private function isValidVariable ( Tokens $ tokens , $ index ) { if ( ! $ tokens [ $ index ] -> isGivenKind ( T_VARIABLE ) ) { return false ; } $ nextIndex = $ tokens -> getNextMeaningfulToken ( $ index ) ; return $ tokens [ $ nextIndex ] -> equals ( '=' ) ; }
10481	public function getDocuments ( ) { return new SyncStorageImportIterator ( [ 'sync_storage' => $ this -> getSyncStorage ( ) , 'shop_id' => $ this -> getShopId ( ) , 'document_type' => $ this -> getDocumentType ( ) , ] , $ this -> getElasticsearchManager ( ) -> getRepository ( $ this -> getDocumentClass ( ) ) , $ this -> getDoctrineManager ( ) , $ this -> getEntityClass ( ) ) ; }
5003	protected function getConfig ( $ services , $ name ) { $ defaults = [ 'service' => 'EventManager' , 'configure' => true , 'identifiers' => [ $ name ] , 'event' => '\Zend\EventManager\Event' , 'listeners' => [ ] , ] ; $ config = $ services -> get ( 'Config' ) ; $ config = isset ( $ config [ 'event_manager' ] [ $ name ] ) ? $ config [ 'event_manager' ] [ $ name ] : [ ] ; $ config = array_replace_recursive ( $ defaults , $ config ) ; return $ config ; }
4784	public function handle ( $ message , callable $ next ) { try { $ next ( $ message ) ; } catch ( UndefinedCallable $ exception ) { $ this -> logger -> log ( $ this -> logLevel , 'No message handler found, trying to handle it asynchronously' , [ 'type' => get_class ( $ message ) ] ) ; $ this -> publisher -> publish ( $ message ) ; } }
1111	public function map ( $ nodeList ) { $ self = $ this ; return $ this -> wrapInTransaction ( function ( ) use ( $ self , $ nodeList ) { forward_static_call ( array ( get_class ( $ self -> node ) , 'unguard' ) ) ; $ result = $ self -> mapTree ( $ nodeList ) ; forward_static_call ( array ( get_class ( $ self -> node ) , 'reguard' ) ) ; return $ result ; } ) ; }
1651	public function containsGeometry ( GeometryInterface $ geometry ) : bool { $ geometryInPolygon = true ; foreach ( $ geometry -> getPoints ( ) as $ point ) { $ geometryInPolygon = $ geometryInPolygon && $ this -> contains ( $ point ) ; } return $ geometryInPolygon ; }
1531	public static function create ( ValidatorInterface $ validator ) : self { $ ex = new self ( $ validator -> getErrors ( ) ) ; $ ex -> validator = $ validator ; return $ ex ; }
12171	public static function getDefaultForClass ( $ class , array $ params = array ( ) ) { $ reflectionClass = new ReflectionClass ( $ class ) ; if ( ! $ reflectionClass -> isInstantiable ( ) ) { throw new NotInstantiableException ( "Class $class is not instantiable" ) ; } $ factory = new static ( [ $ reflectionClass , 'newInstance' ] , "$class::__construct" ) ; if ( $ reflectionClass -> hasMethod ( '__construct' ) ) { static :: addReflectionArguments ( $ factory , $ reflectionClass -> getMethod ( '__construct' ) ) ; } return $ factory -> getFactory ( $ params ) ; }
5210	public static function getInstance ( OutputInterface $ output ) { $ questionHelper = new QuestionHelper ( ) ; $ application = new Application ( 'PHP to Zephir Command Line Interface' , 'Beta 0.2.1' ) ; $ application -> getHelperSet ( ) -> set ( new FormatterHelper ( ) , 'formatter' ) ; $ application -> getHelperSet ( ) -> set ( $ questionHelper , 'question' ) ; $ application -> add ( ConvertFactory :: getInstance ( $ output ) ) ; return $ application ; }
10510	public function detach ( \ SplObserver $ observer ) { foreach ( $ this -> _observers as $ observerItem ) { if ( $ observerItem -> observer === $ observer ) { $ this -> _observers -> detach ( $ observerItem ) ; } } }
5350	public function setMailBoxPassword ( $ domainName , $ mailBox , $ password ) { return $ this -> call ( self :: SERVICE , 'setMailBoxPassword' , [ $ domainName , $ mailBox , $ password ] ) ; }
11521	public function off ( $ eventType , $ listener = null ) { foreach ( $ this -> _eventListeners as $ i => $ l ) { if ( $ l -> getType ( ) == $ eventType ) { if ( $ listener === null || $ l -> getListener ( ) === $ listener ) { unset ( $ this -> _eventListeners [ $ i ] ) ; } } } }
12756	protected function deleteFieldsForCFGroup ( $ customFieldsGroup ) { $ em = $ this -> getContainer ( ) -> get ( 'doctrine.orm.default_entity_manager' ) ; foreach ( $ customFieldsGroup -> getCustomFields ( ) as $ field ) { $ em -> remove ( $ field ) ; } }
4080	protected function isInputScreenStandalone ( $ metaModel ) { $ information = $ this -> information [ $ metaModel ] ; $ inputScreen = isset ( $ information [ self :: INPUTSCREEN ] ) ? $ information [ self :: INPUTSCREEN ] : null ; if ( ! is_object ( $ inputScreen ) ) { return ( $ inputScreen [ 'row' ] [ 'rendertype' ] == 'standalone' ) ; } return $ inputScreen -> isStandalone ( ) ; }
2931	public function setKeys ( $ data ) { foreach ( $ data as $ setter ) { if ( array_key_exists ( 'key' , $ setter ) ) { $ key = $ this -> formatter -> formatKey ( $ setter [ 'key' ] ) ; $ value = array_key_exists ( 'value' , $ setter ) ? $ setter [ 'value' ] : null ; $ comment = array_key_exists ( 'comment' , $ setter ) ? $ setter [ 'comment' ] : null ; $ export = array_key_exists ( 'export' , $ setter ) ? $ setter [ 'export' ] : false ; if ( ! is_file ( $ this -> filePath ) || ! $ this -> keyExists ( $ key ) ) { $ this -> writer -> appendSetter ( $ key , $ value , $ comment , $ export ) ; } else { $ oldInfo = $ this -> getKeys ( [ $ key ] ) ; $ comment = is_null ( $ comment ) ? $ oldInfo [ $ key ] [ 'comment' ] : $ comment ; $ this -> writer -> updateSetter ( $ key , $ value , $ comment , $ export ) ; } } } return $ this ; }
2112	public function generate ( ) { global $ objPage ; $ obj404 = $ this -> prepare ( ) ; $ objPage = $ obj404 -> loadDetails ( ) ; $ objHandler = new $ GLOBALS [ 'TL_PTY' ] [ 'regular' ] ( ) ; header ( 'HTTP/1.1 404 Not Found' ) ; $ objHandler -> generate ( $ objPage ) ; }
7962	public function canChangeLns ( $ forceReload = false ) { if ( ! $ this -> properties || $ forceReload ) $ this -> getProperties ( ) ; return $ this -> properties -> capabilities -> canChangeLns ; }
9253	protected function getContainerInitializer ( ) { $ initializer = new DefaultInitializer ( $ this -> getConfigurationProvider ( ) ) ; if ( $ this -> cache ) { $ initializer = new CachedInitializer ( $ initializer , $ this -> getCacheDir ( ) ) ; } return $ initializer ; }
4334	public function getCfg ( $ path = null ) { if ( $ path == 'outputAs' ) { $ ret = $ this -> cfg [ 'outputAs' ] ; if ( ! $ ret ) { $ ret = $ this -> getDefaultOutputAs ( ) ; } } elseif ( $ path == 'css' ) { $ ret = $ this -> getCss ( ) ; } else { $ ret = $ this -> debug -> utilities -> arrayPathGet ( $ this -> cfg , $ path ) ; } return $ ret ; }
11395	public static function getTranslateErrorCode ( int $ iCode ) : string { if ( $ iCode === 1 && $ iCode === 16 && $ iCode === 256 && $ iCode === 4096 ) { return LogLevel :: ERROR ; } else if ( $ iCode === 2 && $ iCode === 32 && $ iCode === 128 && $ iCode === 512 ) { return LogLevel :: WARNING ; } else if ( $ iCode === 4 && $ iCode === 64 ) { return LogLevel :: EMERGENCY ; } else if ( $ iCode === 8 && $ iCode === 1024 ) { return LogLevel :: NOTICE ; } else if ( $ iCode === 2048 && $ iCode === 8192 && $ iCode === 16384 ) { return LogLevel :: INFO ; } else return LogLevel :: DEBUG ; }
11244	public function setUp ( Neuron_GameServer_Map_Vector3 $ start , Neuron_GameServer_Map_Vector3 $ end ) { $ this -> startUp = $ start -> normalize ( ) ; $ this -> endUp = $ end -> normalize ( ) ; }
653	protected function getCacheKey ( $ method , $ fetchMode , $ rawSql ) { return [ __CLASS__ , $ method , $ fetchMode , $ this -> db -> dsn , $ this -> db -> username , $ rawSql , ] ; }
9609	protected function _checkVectorSpace ( self $ b ) { if ( ! $ this -> isSameDimension ( $ b ) ) { throw new Exception ( 'The vectors must be of the same dimension' ) ; } if ( ! $ this -> isSameVectorSpace ( $ b ) ) { throw new Exception ( 'The vectors\' components must have the same keys' ) ; } }
7601	protected function renderButtons ( array $ aButtons , $ bJustified = false ) { $ sMarkup = '' ; foreach ( $ aButtons as $ oButton ) { if ( is_array ( $ oButton ) || ( $ oButton instanceof Traversable && ! ( $ oButton instanceof ElementInterface ) ) ) { $ oFactory = new Factory ( ) ; $ oButton = $ oFactory -> create ( $ oButton ) ; } elseif ( ! ( $ oButton instanceof ElementInterface ) ) { throw new LogicException ( sprintf ( 'Button expects an instanceof Zend\Form\ElementInterface or an array / Traversable, "%s" given' , is_object ( $ oButton ) ? get_class ( $ oButton ) : gettype ( $ oButton ) ) ) ; } $ sButtonMarkup = $ this -> getFormElementHelper ( ) -> __invoke ( $ oButton ) ; $ sMarkup .= $ bJustified ? sprintf ( static :: $ buttonGroupJustifiedFormat , $ sButtonMarkup ) : $ sButtonMarkup ; } return $ sMarkup ; }
9214	public function actionCreate ( ) { $ model = new StaticPage ( ) ; $ model -> time = date ( "Y-m-d H:i:s" ) ; $ model -> isdel = 0 ; $ post = Yii :: $ app -> request -> post ( ) ; if ( isset ( $ post [ 'StaticPage' ] [ 'tags' ] ) ) { if ( is_array ( $ post [ 'StaticPage' ] [ 'tags' ] ) ) { $ post [ 'StaticPage' ] [ 'tags' ] = implode ( "," , $ post [ 'StaticPage' ] [ 'tags' ] ) ; } } if ( $ model -> load ( $ post ) && $ model -> save ( ) ) { return $ this -> redirect ( [ 'view' , 'id' => $ model -> id ] ) ; } else { return $ this -> render ( 'create' , [ 'model' => $ model , ] ) ; } }
10514	private function updateObserverState ( \ StdClass $ observer ) { $ this -> event -> function = $ observer -> function ; $ observerObject = $ observer -> observer ; $ observerObject -> update ( $ this ) ; }
5014	public function logBootstrap ( BootstrapEvent $ event ) : void { $ this -> getLogger ( ) -> info ( sprintf ( $ this -> tmpl [ 'queue' ] , 'Start' , $ event -> getQueue ( ) -> getName ( ) ) ) ; $ this -> injectLoggerInObject ( $ event -> getWorker ( ) ) ; $ this -> injectLoggerInEvent ( $ event ) ; }
233	public function quoteSimpleTableName ( $ name ) { if ( is_string ( $ this -> tableQuoteCharacter ) ) { $ startingCharacter = $ endingCharacter = $ this -> tableQuoteCharacter ; } else { list ( $ startingCharacter , $ endingCharacter ) = $ this -> tableQuoteCharacter ; } return strpos ( $ name , $ startingCharacter ) !== false ? $ name : $ startingCharacter . $ name . $ endingCharacter ; }
4313	protected function autoloader ( $ className ) { $ className = \ ltrim ( $ className , '\\' ) ; if ( ! \ strpos ( $ className , '\\' ) ) { return ; } $ psr4Map = array ( 'bdk\\Debug\\' => __DIR__ , 'bdk\\PubSub\\' => __DIR__ . '/../PubSub' , 'bdk\\ErrorHandler\\' => __DIR__ . '/../ErrorHandler' , ) ; foreach ( $ psr4Map as $ namespace => $ dir ) { if ( \ strpos ( $ className , $ namespace ) === 0 ) { $ rel = \ substr ( $ className , \ strlen ( $ namespace ) ) ; $ rel = \ str_replace ( '\\' , '/' , $ rel ) ; require $ dir . '/' . $ rel . '.php' ; return ; } } $ classMap = array ( 'bdk\\ErrorHandler' => __DIR__ . '/../ErrorHandler/ErrorHandler.php' , ) ; if ( isset ( $ classMap [ $ className ] ) ) { require $ classMap [ $ className ] ; } }
4527	public function prePersist ( LifecycleEventArgs $ args ) { $ entity = $ args -> getEntity ( ) ; if ( ! $ entity instanceof Identitiable ) { return ; } $ this -> identityService -> generateIdentity ( $ entity ) ; }
10678	public function inflect ( $ text , $ zivotne = false , $ preferovanyRod = '' ) { $ aTxt = $ this -> _txtSplit ( $ text ) ; $ this -> PrefRod = '0' ; $ out = [ ] ; for ( $ i = \ count ( $ aTxt ) - 1 ; $ i >= 0 ; $ i -- ) { $ this -> _skl2 ( $ aTxt [ $ i ] , $ preferovanyRod , $ zivotne ) ; if ( $ i === \ count ( $ aTxt ) - 1 ) { $ this -> PrefRod = $ this -> astrTvar [ 0 ] ; } if ( $ i < \ count ( $ aTxt ) - 1 && mb_substr ( $ this -> PrefRod , 0 , 1 , 'UTF-8' ) !== '?' && mb_substr ( $ this -> astrTvar [ 0 ] , 0 , 1 , 'UTF-8' ) === '?' ) { for ( $ j = 1 ; $ j < 15 ; $ j ++ ) { $ this -> astrTvar [ $ j ] = $ aTxt [ $ i ] ; } } if ( mb_substr ( $ this -> astrTvar [ 0 ] , 0 , 1 , 'UTF-8' ) === '?' ) { $ this -> astrTvar [ 0 ] = '' ; } if ( $ i < \ count ( $ aTxt ) ) { for ( $ j = 1 ; $ j < 15 ; $ j ++ ) { @ $ out [ $ j ] = $ this -> astrTvar [ $ j ] . ' ' . @ $ out [ $ j ] ; } } else { for ( $ j = 1 ; $ j < 15 ; $ j ++ ) { @ $ out [ $ j ] = $ this -> astrTvar [ $ j ] ; } } } return $ out ; }
1435	public static function underscore ( $ value ) { if ( isset ( self :: $ underscored [ $ value ] ) ) { return self :: $ underscored [ $ value ] ; } return self :: $ underscored [ $ value ] = str_replace ( '-' , '_' , self :: decamelize ( $ value ) ) ; }
11545	public function changeEmail ( $ data ) { if ( ! ( $ user = $ this -> hydrate ( $ data , $ this -> getChangeEmailForm ( ) ) ) ) { return ; } $ eventManager = $ this -> getEventManager ( ) ; $ eventManager -> trigger ( __METHOD__ , $ this , $ user ) ; $ user -> setEmailConfirmed ( false ) ; $ viewModel = new ViewModel ( compact ( 'user' ) ) ; $ viewModel -> setTemplate ( 'mail-message/user-confirm-email' ) ; $ mailService = $ this -> getMailService ( ) ; $ message = $ mailService -> getMessage ( ) ; $ message -> setTo ( $ user -> getEmail ( ) , $ user -> getDisplayName ( ) ) ; $ subject = 'Please, confirm your email!' ; if ( $ this -> getTranslator ( ) && $ this -> isTranslatorEnabled ( ) ) { $ subject = $ this -> getTranslator ( ) -> translate ( $ subject , $ this -> getTranslatorTextDomain ( ) ) ; } $ message -> setSubject ( $ subject ) ; $ mailService -> setBody ( $ viewModel ) -> sendMessage ( ) ; $ this -> getMapper ( ) -> update ( $ user ) -> save ( ) ; $ eventManager -> trigger ( __METHOD__ . '.post' , $ this , $ user ) ; return $ user ; }
8767	protected function registerBaseBindings ( ) { static :: setInstance ( $ this ) ; $ this -> instance ( 'app' , $ this ) ; $ this -> instance ( Container :: class , $ this ) ; $ this -> singleton ( 'config' , function ( ) { return new \ Nur \ Config \ Config ( $ this -> config ) ; } ) ; $ this -> singleton ( 'files' , function ( ) { return new Filesystem ; } ) ; $ this -> instance ( PackageManifest :: class , new PackageManifest ( new Filesystem , $ this -> basePath ( ) , $ this -> getCachedPackagesPath ( ) ) ) ; }
8452	protected function checkUrlExistsAndSize ( $ fileUri , array $ mediaFileInfo ) { $ mediaFileInfo [ 'url' ] = $ fileUri ; $ curl = curl_init ( ) ; curl_setopt ( $ curl , CURLOPT_URL , "$fileUri" ) ; curl_setopt ( $ curl , CURLOPT_USERAGENT , "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.11) Gecko/20071127 Firefox/2.0.0.11" ) ; curl_setopt ( $ curl , CURLOPT_RETURNTRANSFER , true ) ; curl_setopt ( $ curl , CURLOPT_HEADER , false ) ; curl_setopt ( $ curl , CURLOPT_NOBODY , true ) ; if ( curl_exec ( $ curl ) === false ) { return false ; } $ info = curl_getinfo ( $ curl ) ; $ mediaFileInfo [ 'filesize' ] = $ info [ 'download_content_length' ] ; $ mediaFileInfo [ 'filemimetype' ] = $ info [ 'content_type' ] ; $ mediaFileInfo [ 'fileextension' ] = pathinfo ( parse_url ( $ mediaFileInfo [ 'url' ] , PHP_URL_PATH ) , PATHINFO_EXTENSION ) ; curl_close ( $ curl ) ; return $ mediaFileInfo ; }
2514	public function setConsumerId ( $ id ) { $ this -> sessionHandler -> setTransactionFlowLink ( true ) ; $ this -> sessionHandler -> setConsumerId ( $ id ) ; }
4706	public function each ( callable $ callable ) { foreach ( $ this -> objects as $ key => $ value ) { if ( false === call_user_func_array ( $ callable , array ( $ value , $ key ) ) ) { break ; } } return $ this ; }
2791	public function hasOks ( $ output ) { $ result = preg_match_all ( "%##teamcity\[testFinished%" , $ output ) ; if ( $ result ) { $ this -> okCount += $ result ; return $ this -> okCount ; } return false ; }
7834	protected function getPipesByOption ( $ option ) { $ pipes = $ this -> option ( $ option ) ; preg_match_all ( '/\w+/' , $ pipes , $ matches ) ; return array_map ( 'ucfirst' , $ matches [ 0 ] ) ; }
5074	public function outputSetFormat ( $ sFormat ) { if ( static :: isValidFormat ( $ sFormat ) ) { $ this -> sOutputFormat = strtoupper ( $ sFormat ) ; return true ; } return false ; }
1191	private function addCustomDefinition ( array $ definitionConfig , HTMLPurifier_Config $ configObject = null ) { if ( ! $ configObject ) { $ configObject = HTMLPurifier_Config :: createDefault ( ) ; $ configObject -> loadArray ( $ this -> getConfig ( ) ) ; } $ configObject -> set ( 'HTML.DefinitionID' , $ definitionConfig [ 'id' ] ) ; $ configObject -> set ( 'HTML.DefinitionRev' , $ definitionConfig [ 'rev' ] ) ; if ( ! isset ( $ definitionConfig [ 'debug' ] ) || $ definitionConfig [ 'debug' ] ) { $ configObject -> set ( 'Cache.DefinitionImpl' , null ) ; } if ( $ def = $ configObject -> maybeGetRawHTMLDefinition ( ) ) { if ( ! empty ( $ definitionConfig [ 'attributes' ] ) ) { $ this -> addCustomAttributes ( $ definitionConfig [ 'attributes' ] , $ def ) ; } if ( ! empty ( $ definitionConfig [ 'elements' ] ) ) { $ this -> addCustomElements ( $ definitionConfig [ 'elements' ] , $ def ) ; } } return $ configObject ; }
5324	public function dispatch ( ) { pcntl_signal_dispatch ( ) ; foreach ( $ this -> signalQueue as $ signal ) { foreach ( $ this -> handlers [ $ signal ] as & $ callable ) { call_user_func ( $ callable , $ signal ) ; } } return $ this ; }
7747	private function findAdderAndRemover ( ) { $ reflClass = new \ ReflectionClass ( $ this -> class ) ; $ singulars = ( array ) StringUtil :: singularify ( $ this -> camelize ( $ this -> name ) ) ; foreach ( $ singulars as $ singular ) { $ addMethod = 'add' . $ singular ; $ removeMethod = 'remove' . $ singular ; $ addMethodFound = $ this -> isAccessible ( $ reflClass , $ addMethod , 1 ) ; $ removeMethodFound = $ this -> isAccessible ( $ reflClass , $ removeMethod , 1 ) ; if ( $ addMethodFound && $ removeMethodFound ) { $ this -> adderRemover = $ singular ; return ; } } }
11048	function add_system_var ( & $ datatree , $ index , $ last , $ key ) { $ datatree -> _key = $ key ; $ datatree -> _index = $ index ; $ datatree -> _rank = $ index + 1 ; $ datatree -> _odd = $ datatree -> _not_even = ( 1 == $ datatree -> _rank % 2 ) ; $ datatree -> _even = $ datatree -> _not_odd = ( 0 == $ datatree -> _rank % 2 ) ; $ datatree -> _first = ( 0 == $ index ) ; $ datatree -> _middle = ! $ datatree -> _first && ! $ last ; $ datatree -> _last = $ last ; $ datatree -> _not_first = ! $ datatree -> _first ; $ datatree -> _not_last = ! $ last ; $ datatree -> _not_middle = ! $ datatree -> _middle ; }
12710	public function make ( $ instance , $ parameters = [ ] ) { return $ this -> resolve ( $ instance , is_array ( $ parameters ) ? $ parameters : array_slice ( func_get_args ( ) , 1 ) ) ; }
62	public function unlink ( $ path ) { $ unlinked = @ $ this -> unlinkImplementation ( $ path ) ; if ( ! $ unlinked ) { if ( Platform :: isWindows ( ) ) { usleep ( 350000 ) ; $ unlinked = @ $ this -> unlinkImplementation ( $ path ) ; } if ( ! $ unlinked ) { $ error = error_get_last ( ) ; $ message = 'Could not delete ' . $ path . ': ' . @ $ error [ 'message' ] ; if ( Platform :: isWindows ( ) ) { $ message .= "\nThis can be due to an antivirus or the Windows Search Indexer locking the file while they are analyzed" ; } throw new \ RuntimeException ( $ message ) ; } } return true ; }
1885	public function getItemsAsString ( $ strSeparator = ' ' ) { $ arrLinks = array ( ) ; foreach ( $ this -> getItemsAsArray ( ) as $ arrItem ) { if ( $ arrItem [ 'href' ] === null ) { $ arrLinks [ ] = sprintf ( '<li><strong class="active">%s</strong></li>' , $ arrItem [ 'page' ] ) ; } else { $ arrLinks [ ] = sprintf ( '<li><a href="%s" class="link" title="%s">%s</a></li>' , $ arrItem [ 'href' ] , $ arrItem [ 'title' ] , $ arrItem [ 'page' ] ) ; } } return implode ( $ strSeparator , $ arrLinks ) ; }
9109	public function getResolverObject ( $ state = null , array $ options = array ( ) ) { if ( $ state == null && isset ( $ this -> resolverObject [ 'last_resolver' ] ) ) { return $ this -> resolverObject [ 'last_resolver' ] ; } if ( $ state != 'resolver_adapter_service' && $ state != 'mvclayout_resolver_adapter' ) throw new \ Exception ( 'Invalid state name provided.' ) ; $ config = $ this -> getConfig ( ) ; if ( isset ( $ config [ 'theme_locator' ] ) ) $ config = $ config [ 'theme_locator' ] ; else $ config = array ( ) ; if ( ! isset ( $ config [ $ state ] ) ) throw new \ Exception ( "Theme Resolver Service not present in config[$state]." ) ; $ config = $ config [ $ state ] ; if ( is_string ( $ config ) ) { $ config = array ( "{$config}" => 1 ) ; } if ( isset ( $ this -> resolverObject [ $ state ] ) ) { $ resolver = $ this -> resolverObject [ $ state ] ; $ this -> resolverObject [ 'last_resolver' ] = $ resolver ; return $ resolver ; } else $ resolver = new Resolvers \ Aggregate ( ) ; foreach ( $ config as $ service => $ priority ) { if ( $ this -> getServiceLocator ( ) -> has ( $ service ) ) { $ service = $ this -> getServiceLocator ( ) -> get ( $ service ) ; } else { if ( ! class_exists ( $ service ) ) throw new \ Exception ( "Resolver '$service' not found for yimaTheme as Service either Class." ) ; $ service = new $ service ( ) ; } if ( $ service instanceof Resolvers \ LocatorResolverAwareInterface ) { $ service -> setThemeLocator ( $ this ) ; } if ( $ service instanceof Resolvers \ ConfigResolverAwareInterface ) { $ service -> setConfig ( $ this -> getConfig ( ) ) ; } if ( isset ( $ options [ 'event_mvc' ] ) ) if ( $ service instanceof Resolvers \ MvcResolverAwareInterface ) $ service -> setMvcEvent ( $ options [ 'event_mvc' ] ) ; $ resolver -> attach ( $ service , $ priority ) ; } $ this -> resolverObject [ $ state ] = $ resolver ; $ this -> resolverObject [ 'last_resolver' ] = $ resolver ; return $ resolver ; }
9225	private function preprocessData ( $ data ) { if ( is_array ( $ data ) && ! array_key_exists ( self :: PARAM_PER_PAGE , $ data ) ) { $ data [ self :: PARAM_PER_PAGE ] = CanvasArray :: MAXIMUM_PER_PAGE ; } return $ data ; }
8832	public function tokenise ( $ pattern , $ expand = false ) { preg_match_all ( ' / (?<class_U_explicit>\\\U) \{ (?<class_U_repetition>[0-9]+) \} | (?<class_U_implicit>\\\U) | \[ (?<range_token_explicit>[^]]+) \] \{ (?<range_repetition>[0-9]+) \} | \[ (?<range_token_implicit>[^]]+) \] | (?<literal_string>[^\\\[]+) /x ' , $ pattern , $ matches , \ PREG_SET_ORDER ) ; $ tokens = [ ] ; foreach ( $ matches as $ match ) { if ( ! empty ( $ match [ 'class_U_explicit' ] ) ) { $ token = [ 'type' => 'class' , 'class' => static :: CLASS_UPPERCASE_UNAMBIGUOUS , 'repetition' => ( int ) $ match [ 'class_U_repetition' ] ] ; if ( $ expand ) { $ token [ 'haystack' ] = 'ABCDEFGHKMNOPRSTUVWXYZ23456789' ; } $ tokens [ ] = $ token ; } else if ( ! empty ( $ match [ 'class_U_implicit' ] ) ) { $ token = [ 'type' => 'class' , 'class' => static :: CLASS_UPPERCASE_UNAMBIGUOUS , 'repetition' => 1 ] ; if ( $ expand ) { $ token [ 'haystack' ] = 'ABCDEFGHKMNOPRSTUVWXYZ23456789' ; } $ tokens [ ] = $ token ; } else if ( ! empty ( $ match [ 'range_token_explicit' ] ) ) { $ token = [ 'type' => 'range' , 'token' => $ match [ 'range_token_explicit' ] , 'repetition' => ( int ) $ match [ 'range_repetition' ] ] ; if ( $ expand ) { $ token [ 'haystack' ] = static :: expandRange ( $ match [ 'range_token_explicit' ] ) ; } $ tokens [ ] = $ token ; } else if ( ! empty ( $ match [ 'range_token_implicit' ] ) ) { $ token = [ 'type' => 'range' , 'token' => $ match [ 'range_token_implicit' ] , 'repetition' => 1 ] ; if ( $ expand ) { $ token [ 'haystack' ] = static :: expandRange ( $ match [ 'range_token_implicit' ] ) ; } $ tokens [ ] = $ token ; } else if ( ! empty ( $ match [ 'literal_string' ] ) ) { $ tokens [ ] = [ 'type' => 'literal' , 'string' => $ match [ 'literal_string' ] ] ; } } return $ tokens ; }
2284	protected static function ip ( ) { $ request = System :: getContainer ( ) -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; if ( $ request === null ) { return '' ; } return $ request -> getClientIp ( ) ; }
49	protected function getScriptListeners ( Event $ event ) { $ package = $ this -> composer -> getPackage ( ) ; $ scripts = $ package -> getScripts ( ) ; if ( empty ( $ scripts [ $ event -> getName ( ) ] ) ) { return array ( ) ; } if ( $ this -> loader ) { $ this -> loader -> unregister ( ) ; } $ generator = $ this -> composer -> getAutoloadGenerator ( ) ; if ( $ event instanceof ScriptEvent ) { $ generator -> setDevMode ( $ event -> isDevMode ( ) ) ; } $ packages = $ this -> composer -> getRepositoryManager ( ) -> getLocalRepository ( ) -> getCanonicalPackages ( ) ; $ packageMap = $ generator -> buildPackageMap ( $ this -> composer -> getInstallationManager ( ) , $ package , $ packages ) ; $ map = $ generator -> parseAutoloads ( $ packageMap , $ package ) ; $ this -> loader = $ generator -> createLoader ( $ map ) ; $ this -> loader -> register ( ) ; return $ scripts [ $ event -> getName ( ) ] ; }
8944	public function getDetails ( ) { $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = 'user/details' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'GET' , $ parameters ) ; return $ response -> body ; }
10729	public function getDay ( ) { if ( $ this -> value !== null ) { preg_match ( '/^(?P<year>[0-9]{4,4})-(?P<month>[0-9]{2,2})-(?P<day>[0-9]{2,2}) (?P<hour>[0-9]{2,2}):(?P<minute>[0-9]{2,2}):(?P<second>[0-9]{2,2})$/ui' , $ this -> value , $ m ) ; return ( int ) $ m [ 'day' ] ; } }
436	public function afterAction ( $ action , $ result ) { $ event = new ActionEvent ( $ action ) ; $ event -> result = $ result ; $ this -> trigger ( self :: EVENT_AFTER_ACTION , $ event ) ; return $ event -> result ; }
8125	protected function getSchemaRequested ( ) { $ parts = $ this -> owner -> getRequest ( ) -> getHeader ( LeftAndMain :: SCHEMA_HEADER ) ; return ! empty ( $ parts ) ; }
10226	public function noAssociationsMenuFor ( $ model , ModelConfig $ config = null ) { $ modelName = $ this -> resolveModelName ( $ model ) ; $ menuFactory = $ this -> app -> make ( 'Label305\AujaLaravel\Factory\NoAssociationsIndexMenuFactory' ) ; return $ menuFactory -> create ( $ modelName , $ config ) ; }
4544	public function kernelException ( GetResponseForExceptionEvent $ event ) { $ exception = $ event -> getException ( ) ; if ( $ exception instanceof ValidationException ) { return ; } $ data = [ 'type' => 'https://tools.ietf.org/html/rfc2616#section-10' , 'title' => 'An error occurred' ] ; if ( in_array ( $ this -> environment , [ 'dev' , 'test' ] , true ) ) { $ data [ 'detail' ] = $ exception -> getMessage ( ) ; $ data [ 'trace' ] = $ exception -> getTrace ( ) ; } $ request = $ event -> getRequest ( ) ; $ contentTypes = $ request -> getAcceptableContentTypes ( ) ; $ accept = array_shift ( $ contentTypes ) ; switch ( $ accept ) { case 'application/json' : case 'application/ld+json' : $ code = Response :: HTTP_INTERNAL_SERVER_ERROR ; if ( $ exception instanceof HttpException ) { $ code = $ exception -> getStatusCode ( ) ; } $ response = new JsonResponse ( $ data , $ code ) ; $ event -> setResponse ( $ response ) ; break ; } }
7123	protected function updateTicket ( TicketMessageInterface $ message ) { $ ticket = $ message -> getTicket ( ) -> setUpdatedAt ( new \ DateTime ( ) ) ; if ( $ message -> isLatest ( ) && ( $ ticket -> getState ( ) !== TicketStates :: STATE_CLOSED ) ) { if ( $ message -> isCustomer ( ) ) { if ( $ ticket -> getState ( ) === TicketStates :: STATE_PENDING ) { $ ticket -> setState ( TicketStates :: STATE_OPENED ) ; } } elseif ( $ ticket -> getState ( ) === TicketStates :: STATE_OPENED ) { $ ticket -> setState ( TicketStates :: STATE_PENDING ) ; } } $ this -> persistenceHelper -> persistAndRecompute ( $ ticket , false ) ; }
6334	private function attachHandlers ( $ parser ) { $ onElementStart = \ Closure :: bind ( function ( $ parser , $ name , $ attributes ) { $ name = $ this -> normalize ( $ name ) ; $ this -> currentElement = $ name ; $ this -> dataBuffer = null ; $ this -> stackSize ++ ; $ this -> onElementStart ( $ parser , $ name , $ attributes ) ; } , $ this ) ; $ onElementEnd = \ Closure :: bind ( function ( $ parser , $ name ) { $ name = $ this -> normalize ( $ name ) ; $ this -> currentElement = null ; $ this -> stackSize -- ; if ( null !== $ this -> dataBuffer ) { $ this -> onElementData ( $ parser , $ this -> dataBuffer ) ; } $ this -> dataBuffer = null ; $ this -> onElementEnd ( $ parser , $ name ) ; } , $ this ) ; $ onElementData = \ Closure :: bind ( function ( $ parser , $ data ) { $ this -> dataBuffer .= $ data ; } , $ this ) ; $ onNamespaceDeclarationStart = \ Closure :: bind ( function ( $ parser , $ prefix , $ uri ) { $ this -> namespaces [ $ prefix ] = rtrim ( $ uri , '/' ) ; $ this -> onNamespaceDeclarationStart ( $ parser , $ prefix , $ uri ) ; } , $ this ) ; $ onNamespaceDeclarationEnd = \ Closure :: bind ( function ( $ parser , $ prefix ) { $ this -> onNamespaceDeclarationEnd ( $ parser , $ prefix ) ; } , $ this ) ; xml_set_element_handler ( $ parser , $ onElementStart , $ onElementEnd ) ; xml_set_character_data_handler ( $ parser , $ onElementData ) ; xml_set_start_namespace_decl_handler ( $ parser , $ onNamespaceDeclarationStart ) ; xml_set_end_namespace_decl_handler ( $ parser , $ onNamespaceDeclarationEnd ) ; return $ this ; }
2985	protected function generateIndexView ( $ dir ) { $ this -> renderFile ( 'crud/views/index.html.twig.twig' , $ dir . '/index.html.twig' , array ( 'bundle' => $ this -> bundle -> getName ( ) , 'entity' => $ this -> entity , 'entity_pluralized' => $ this -> entityPluralized , 'entity_singularized' => $ this -> entitySingularized , 'identifier' => $ this -> metadata -> identifier [ 0 ] , 'fields' => $ this -> metadata -> fieldMappings , 'actions' => $ this -> actions , 'record_actions' => $ this -> getRecordActions ( ) , 'route_prefix' => $ this -> routePrefix , 'route_name_prefix' => $ this -> routeNamePrefix , ) ) ; }
9769	function match ( string $ pattern ) : self { return $ this -> expect ( $ this -> target , matchesRegularExpression ( $ pattern ) ) ; }
6116	public function serverGetByName ( $ name ) { foreach ( $ this -> serverList ( ) as $ server ) { if ( $ server [ "virtualserver_name" ] == $ name ) { return $ server ; } } throw new Ts3Exception ( "invalid serverID" , 0x400 ) ; }
2470	public function getMaxDepthForContent ( ContentType $ contentType ) : int { if ( isset ( $ this -> contentTypeMap [ $ contentType -> identifier ] ) ) { return $ this -> contentTypeMap [ $ contentType -> identifier ] ; } return $ this -> defaultIndexingDepth ; }
5114	private function conv ( $ str ) { if ( $ this -> supportsExtMbstring ) { return mb_convert_encoding ( $ str , 'UTF-16BE' , 'UTF-8' ) ; } return preg_replace_callback ( '/./su' , function ( $ m ) { if ( ! isset ( $ m [ 0 ] [ 1 ] ) ) { return "\x00" . $ m [ 0 ] ; } if ( isset ( $ m [ 0 ] [ 3 ] ) ) { $ code = ( ( ord ( $ m [ 0 ] [ 0 ] ) & 0x07 ) << 18 ) + ( ( ord ( $ m [ 0 ] [ 1 ] ) & 0x3F ) << 12 ) + ( ( ord ( $ m [ 0 ] [ 2 ] ) & 0x3F ) << 6 ) + ( ord ( $ m [ 0 ] [ 3 ] ) & 0x3F ) ; return pack ( 'nn' , ( $ code - 0x10000 >> 10 ) | 0xD800 , ( $ code & 0x03FF ) | 0xDC00 ) ; } if ( isset ( $ m [ 0 ] [ 2 ] ) ) { $ code = ( ( ord ( $ m [ 0 ] [ 0 ] ) & 0x0F ) << 12 ) + ( ( ord ( $ m [ 0 ] [ 1 ] ) & 0x3F ) << 6 ) + ( ord ( $ m [ 0 ] [ 2 ] ) & 0x3F ) ; } else { $ code = ( ( ord ( $ m [ 0 ] [ 0 ] ) & 0x1F ) << 6 ) + ( ord ( $ m [ 0 ] [ 1 ] ) & 0x3F ) ; } return chr ( $ code >> 8 ) . chr ( $ code & 0xFF ) ; } , $ str ) ; }
10435	public function post ( $ request ) { if ( $ request instanceof Request ) { $ request = $ request -> xml ( ) ; } $ ch = curl_init ( ) ; curl_setopt ( $ ch , CURLOPT_URL , $ this -> url ) ; if ( $ this -> user_agent != null ) { curl_setopt ( $ ch , CURLOPT_USERAGENT , $ this -> user_agent ) ; } curl_setopt ( $ ch , CURLOPT_HEADER , 0 ) ; curl_setopt ( $ ch , CURLOPT_RETURNTRANSFER , 1 ) ; curl_setopt ( $ ch , CURLOPT_POST , 1 ) ; curl_setopt ( $ ch , CURLOPT_POSTFIELDS , $ request ) ; curl_setopt ( $ ch , CURLOPT_HTTPHEADER , array ( 'Content-type: application/xml; charset=utf-8' , ) ) ; $ response = curl_exec ( $ ch ) ; curl_close ( $ ch ) ; if ( empty ( $ response ) ) { return null ; } return $ response ; }
6662	public function get ( $ url , $ params = [ ] ) { if ( ! is_array ( $ params ) ) { throw new HttpClientException ( HttpClientErrorMessages :: INVALID_QUERY_PARAMS ) ; } $ params = $ this -> filterParams ( $ params ) ; $ this -> lastRequestParams = $ params ; $ this -> lastRequestUrl = $ this -> buildUrl ( $ url , $ params ) ; return $ this -> curlAgent -> get ( $ this -> lastRequestUrl , $ this -> rawResponse ) ; }
5128	public function readQDateTime ( ) { $ day = $ this -> readUInt ( ) ; $ msec = $ this -> readUInt ( ) ; $ this -> readBool ( ) ; if ( $ day === 0 && $ msec === 0xFFFFFFFF ) { return null ; } $ time = ( $ day - 2440588 ) * 86400 + $ msec / 1000 ; $ dt = \ DateTime :: createFromFormat ( 'U.u' , sprintf ( '%.6F' , $ time ) ) ; $ dt -> setTimezone ( new \ DateTimeZone ( date_default_timezone_get ( ) ) ) ; return $ dt ; }
5312	protected function getHTMLFromGenerator ( IconFontGenerator $ generator , $ fontFile ) { $ fontOptions = $ generator -> getFont ( ) -> getOptions ( ) ; $ html = '<!doctype html> <html> <head> <title>' . htmlspecialchars ( $ fontOptions [ 'id' ] ) . '</title> <style> @font-face { font-family: "' . $ fontOptions [ 'id' ] . '"; src: url("' . $ fontFile . '") format("svg"), url("' . substr ( $ fontFile , 0 , - 4 ) . '.woff") format("woff"), url("' . substr ( $ fontFile , 0 , - 4 ) . '.ttf") format("truetype"); font-weight: normal; font-style: normal; } body { font-family: sans-serif; color: #444; line-height: 1.5; font-size: 16px; padding: 20px; } * { -moz-box-sizing: border-box; -webkit-box-sizing: border-box; box-sizing: border-box; margin: 0; paddin: 0; } .glyph{ display: inline-block; width: 120px; margin: 10px; text-align: center; vertical-align: top; background: #eee; border-radius: 10px; box-shadow: 1px 1px 5px rgba(0, 0, 0, .2); } .glyph-icon{ padding: 10px; display: block; font-family: "' . $ fontOptions [ 'id' ] . '"; font-size: 64px; line-height: 1; } .glyph-icon:before{ content: attr(data-icon); } .class-name{ font-size: 12px; } .glyph > input{ display: block; width: 100px; margin: 5px auto; text-align: center; font-size: 12px; cursor: text; } .glyph > input.icon-input{ font-family: "' . $ fontOptions [ 'id' ] . '"; font-size: 16px; margin-bottom: 10px; } </style> </head> <body> <section id="glyphs">' ; $ glyphNames = $ generator -> getGlyphNames ( ) ; asort ( $ glyphNames ) ; foreach ( $ glyphNames as $ unicode => $ glyph ) { $ html .= '<div class="glyph"> <div class="glyph-icon" data-icon="&#x' . $ unicode . ';"></div> <div class="class-name">icon-' . $ glyph . '</div> <input type="text" readonly="readonly" value="&amp;#x' . $ unicode . ';" /> <input type="text" readonly="readonly" value="\\' . $ unicode . '" /> <input type="text" readonly="readonly" value="&#x' . $ unicode . ';" class="icon-input" /> </div>' ; } $ html .= '</section> </body> </html>' ; return $ html ; }
415	public function getAcceptableContentTypes ( ) { if ( $ this -> _contentTypes === null ) { if ( $ this -> headers -> get ( 'Accept' ) !== null ) { $ this -> _contentTypes = $ this -> parseAcceptHeader ( $ this -> headers -> get ( 'Accept' ) ) ; } else { $ this -> _contentTypes = [ ] ; } } return $ this -> _contentTypes ; }
3655	private function getLabelText ( $ type ) { $ label = $ this -> translator -> trans ( 'tl_metamodel_dcasetting_condition.typedesc.' . $ type , [ ] , 'contao_tl_metamodel_dcasetting_condition' ) ; if ( $ label === 'tl_metamodel_dcasetting_condition.typedesc.' . $ type ) { $ label = $ this -> translator -> trans ( 'tl_metamodel_dcasetting_condition.typedesc._default_' , [ ] , 'contao_tl_metamodel_dcasetting_condition' ) ; if ( $ label === 'tl_metamodel_dcasetting_condition.typedesc._default_' ) { return $ type ; } } return $ label ; }
816	private function getMeaningfulSequence ( Tokens $ tokens , $ start , $ end ) { $ sequence = [ ] ; $ index = $ start ; while ( $ index < $ end ) { $ index = $ tokens -> getNextMeaningfulToken ( $ index ) ; if ( $ index >= $ end || null === $ index ) { break ; } $ sequence [ ] = $ tokens [ $ index ] ; } return Tokens :: fromArray ( $ sequence ) ; }
11491	public function getAll ( ) : array { $ res = [ ] ; foreach ( $ this -> getKeys ( ) as $ key ) { $ res [ $ key ] = $ this -> get ( $ key ) ; } return $ res ; }
1562	protected function deserializeAttribute ( $ value , $ field , $ record ) { if ( $ this -> isDateAttribute ( $ field , $ record ) ) { return $ this -> deserializeDate ( $ value , $ field , $ record ) ; } $ method = 'deserialize' . Str :: classify ( $ field ) . 'Field' ; if ( method_exists ( $ this , $ method ) ) { return $ this -> { $ method } ( $ value , $ record ) ; } return $ value ; }
12853	public function import ( Package $ package , $ id = null ) { $ id = is_null ( $ id ) ? $ package -> id : $ id ; $ this -> symbols = array_merge ( $ package -> symbols , $ this -> symbols ) ; $ this -> macros = array_merge ( $ package -> macros , $ this -> macros ) ; $ this -> packages [ $ id ] = $ package ; }
4463	private function handleProcessExitStatus ( int $ pid , int $ childType , int $ exitStatus ) { switch ( $ childType ) { case self :: PROCESS_TYPE_JOB : $ childType = 'Child' ; break ; default : $ childType = 'Watchdog' ; } if ( $ exitStatus === 0 ) { $ this -> logger -> debug ( "{type}: {$childType} process exited successfully" , $ this -> logContext ) ; return false ; } $ error = $ this -> readErrorFromSocket ( $ this -> sockets [ $ pid ] ) ; $ jobFailedMessage = $ error ? : "{$childType} process failed with status: {$exitStatus}" ; $ this -> logger -> error ( "{type}: fatal error in {$childType} process: {$jobFailedMessage}" , $ this -> logContext ) ; return $ jobFailedMessage ; }
2554	protected static function makePricingOptionFareFamilyOverride ( $ fareFamily ) { $ opt = [ ] ; if ( $ fareFamily !== null ) { $ po = new PricingOptionGroup ( PricingOptionKey :: OPTION_FARE_FAMILY ) ; $ po -> optionDetail = new OptionDetail ( [ [ 'FF' => $ fareFamily ] ] ) ; $ opt [ ] = $ po ; } return $ opt ; }
2032	public static function findFirstActiveByMemberGroups ( $ arrIds ) { if ( empty ( $ arrIds ) || ! \ is_array ( $ arrIds ) ) { return null ; } $ time = Date :: floorToMinute ( ) ; $ objDatabase = Database :: getInstance ( ) ; $ arrIds = array_map ( '\intval' , $ arrIds ) ; $ objResult = $ objDatabase -> prepare ( "SELECT p.* FROM tl_member_group g LEFT JOIN tl_page p ON g.jumpTo=p.id WHERE g.id IN(" . implode ( ',' , $ arrIds ) . ") AND g.jumpTo>0 AND g.redirect='1' AND g.disable!='1' AND (g.start='' OR g.start<='$time') AND (g.stop='' OR g.stop>'" . ( $ time + 60 ) . "') AND p.published='1' AND (p.start='' OR p.start<='$time') AND (p.stop='' OR p.stop>'" . ( $ time + 60 ) . "') ORDER BY " . $ objDatabase -> findInSet ( 'g.id' , $ arrIds ) ) -> limit ( 1 ) -> execute ( ) ; if ( $ objResult -> numRows < 1 ) { return null ; } $ objRegistry = Registry :: getInstance ( ) ; if ( $ objPage = $ objRegistry -> fetch ( 'tl_page' , $ objResult -> id ) ) { return $ objPage ; } return new static ( $ objResult ) ; }
433	public function setModules ( $ modules ) { foreach ( $ modules as $ id => $ module ) { $ this -> _modules [ $ id ] = $ module ; } }
4411	public function process ( ContainerBuilder $ container ) { if ( ! $ container -> has ( 'netgen_admin_ui.menu_plugin.registry' ) ) { return ; } $ menuPluginRegistry = $ container -> findDefinition ( 'netgen_admin_ui.menu_plugin.registry' ) ; $ menuPlugins = $ container -> findTaggedServiceIds ( 'netgen_admin_ui.menu_plugin' ) ; $ flattenedMenuPlugins = array ( ) ; foreach ( $ menuPlugins as $ identifier => $ menuPlugin ) { $ flattenedMenuPlugins [ $ identifier ] = isset ( $ menuPlugin [ 0 ] [ 'priority' ] ) ? $ menuPlugin [ 0 ] [ 'priority' ] : 0 ; } arsort ( $ flattenedMenuPlugins ) ; foreach ( array_keys ( $ flattenedMenuPlugins ) as $ menuPlugin ) { $ menuPluginRegistry -> addMethodCall ( 'addMenuPlugin' , array ( new Reference ( $ menuPlugin ) ) ) ; } }
3850	public function getServiceContainer ( ) { if ( ! $ this -> serviceContainer ) { $ this -> useDefaultServiceContainer ( ) ; } if ( is_callable ( $ this -> serviceContainer ) ) { return $ this -> serviceContainer = $ this -> serviceContainer -> __invoke ( ) ; } return $ this -> serviceContainer ; }
12268	protected function renderSlots ( Page $ page , array $ slots , array $ options = array ( ) ) { $ renderedSlots = array ( ) ; $ slots = $ this -> dispatchSlotsEvent ( RenderEvents :: SLOTS_RENDERING , $ page , $ slots ) ; foreach ( $ slots as $ slotName => $ slot ) { if ( is_string ( $ slot ) ) { $ renderedSlots [ $ slotName ] = $ slot ; continue ; } if ( ! $ slot instanceof Slot ) { continue ; } $ blocks = $ slot -> getEntitiesInUse ( ) ; $ renderedSlots [ $ slotName ] = $ this -> templating -> render ( 'RedKiteCms/Resources/views/Slot/slot.html.twig' , array ( 'options' => $ options , 'slotname' => $ slotName , 'data' => rawurlencode ( "[" . implode ( "," , $ blocks ) ) . "]" , 'next' => $ slot -> getNext ( ) , ) ) ; } return $ slots = $ this -> dispatchSlotsEvent ( RenderEvents :: SLOTS_RENDERED , $ page , $ renderedSlots ) ; }
5684	public function getUrlById ( $ id ) { foreach ( $ this -> links as $ link ) { if ( $ link -> getAttribute ( 'id' ) === ( string ) $ id ) { return $ this -> getUrlFromLink ( $ link ) ; } } return false ; }
6894	protected function compareStockUnitByPrice ( StockUnitInterface $ u1 , StockUnitInterface $ u2 ) { $ u1HasPrice = 0 < $ u1 -> getNetPrice ( ) ; $ u2HasPrice = 0 < $ u2 -> getNetPrice ( ) ; if ( ! $ u1HasPrice && $ u2HasPrice ) { return 1 ; } if ( $ u1HasPrice && ! $ u2HasPrice ) { return - 1 ; } if ( $ u1 -> getNetPrice ( ) != $ u2 -> getNetPrice ( ) ) { return $ u1 -> getNetPrice ( ) > $ u2 -> getNetPrice ( ) ? 1 : - 1 ; } return 0 ; }
12973	public function setMappings ( $ mappingName , array $ mappingConfig = null ) { if ( is_array ( $ mappingName ) === false ) { $ mappingName = array ( $ mappingName => $ mappingConfig ) ; } \ Arr :: set ( $ this -> config [ 'mappings' ] , $ mappingName ) ; return $ this ; }
9342	public function populate ( $ arrAll ) { $ this -> arr = array_chunk ( $ arrAll , $ this -> size -> cols ) ; return $ this ; }
9316	public static function filter ( $ region ) { $ r = array ( 'x' => intval ( $ region [ 'x' ] ) , 'y' => intval ( $ region [ 'y' ] ) , 'width' => intval ( $ region [ 'w' ] ) , 'height' => intval ( $ region [ 'h' ] ) ) ; return array ( new ezcImageFilter ( 'crop' , $ r ) ) ; }
12514	public static function create ( $ path = '' , $ mode = 0777 ) { $ path = Path :: clean ( $ path ) ; $ fs = new Filesystem ( ) ; try { $ fs -> mkdir ( $ path ) ; } catch ( IOExceptionInterface $ e ) { throw new Exception ( Helper :: getTranslation ( 'FAILED_CREATING' ) . ' ' . $ e -> getPath ( ) ) ; } return true ; }
847	public function getNextTokenOfKind ( $ index , array $ tokens = [ ] , $ caseSensitive = true ) { return $ this -> getTokenOfKindSibling ( $ index , 1 , $ tokens , $ caseSensitive ) ; }
292	public function hasAttribute ( $ name ) { return isset ( $ this -> _attributes [ $ name ] ) || in_array ( $ name , $ this -> attributes ( ) , true ) ; }
3937	private function setOptions ( PropertyInterface $ property , $ propInfo ) { if ( null !== $ property -> getOptions ( ) || ! isset ( $ propInfo [ 'options' ] ) ) { return ; } $ property -> setOptions ( $ propInfo [ 'options' ] ) ; }
12589	protected function sendEmails ( ContactInquiry $ inquiry ) { $ recipients = $ this -> container -> getParameter ( 'c33s_contact_form.email.recipients' ) ; if ( $ this -> container -> getParameter ( 'c33s_contact_form.email.send_copy_to_user' ) && $ inquiry -> hasSenderEmail ( ) ) { $ recipients [ ] = $ inquiry -> getSenderEmail ( ) ; } if ( empty ( $ recipients ) ) { return ; } $ translator = $ this -> get ( 'translator' ) ; $ subject = $ this -> container -> getParameter ( 'c33s_contact_form.email.subject' ) ; $ message = \ Swift_Message :: newInstance ( ) -> setSubject ( $ translator -> trans ( $ subject , array ( ) , 'C33sContactForm' ) ) -> setFrom ( $ this -> container -> getParameter ( 'c33s_contact_form.email.sender_email' ) ) -> setTo ( $ recipients ) -> setBody ( $ this -> renderView ( 'C33sContactFormBundle:ContactForm:email.txt.twig' , array ( 'inquiry' => $ inquiry ) ) ) ; $ this -> get ( 'mailer' ) -> send ( $ message ) ; }
1811	public function addCteType ( $ arrRow ) { $ key = $ arrRow [ 'invisible' ] ? 'unpublished' : 'published' ; $ type = $ GLOBALS [ 'TL_LANG' ] [ 'CTE' ] [ $ arrRow [ 'type' ] ] [ 0 ] ? : '&nbsp;' ; $ class = 'limit_height' ; if ( \ in_array ( $ arrRow [ 'type' ] , $ GLOBALS [ 'TL_WRAPPERS' ] [ 'start' ] ) || \ in_array ( $ arrRow [ 'type' ] , $ GLOBALS [ 'TL_WRAPPERS' ] [ 'separator' ] ) || \ in_array ( $ arrRow [ 'type' ] , $ GLOBALS [ 'TL_WRAPPERS' ] [ 'stop' ] ) ) { $ class = '' ; if ( ( $ group = $ this -> getContentElementGroup ( $ arrRow [ 'type' ] ) ) !== null ) { $ type = $ GLOBALS [ 'TL_LANG' ] [ 'CTE' ] [ $ group ] . ' (' . $ type . ')' ; } } elseif ( \ in_array ( $ arrRow [ 'type' ] , $ GLOBALS [ 'TL_WRAPPERS' ] [ 'single' ] ) ) { if ( ( $ group = $ this -> getContentElementGroup ( $ arrRow [ 'type' ] ) ) !== null ) { $ type = $ GLOBALS [ 'TL_LANG' ] [ 'CTE' ] [ $ group ] . ' (' . $ type . ')' ; } } if ( $ arrRow [ 'type' ] == 'alias' ) { $ type .= ' ID ' . $ arrRow [ 'cteAlias' ] ; } if ( $ arrRow [ 'protected' ] ) { $ type .= ' (' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'protected' ] . ')' ; } elseif ( $ arrRow [ 'guests' ] ) { $ type .= ' (' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'guests' ] . ')' ; } if ( $ arrRow [ 'type' ] == 'headline' ) { if ( \ is_array ( $ headline = Contao \ StringUtil :: deserialize ( $ arrRow [ 'headline' ] ) ) ) { $ type .= ' (' . $ headline [ 'unit' ] . ')' ; } } if ( ! Contao \ Config :: get ( 'doNotCollapse' ) ) { $ class .= ' h40' ; } $ objModel = new Contao \ ContentModel ( ) ; $ objModel -> setRow ( $ arrRow ) ; return '<div class="cte_type ' . $ key . '">' . $ type . '</div><div class="' . trim ( $ class ) . '">' . Contao \ StringUtil :: insertTagToSrc ( $ this -> getContentElement ( $ objModel ) ) . '</div>' . "\n" ; }
6127	public function setExpireDate ( $ expireDate ) { if ( $ expireDate instanceof DateTime ) { $ this -> expireDate = $ expireDate ; } else { try { $ this -> expireDate = new DateTime ( $ expireDate ) ; } catch ( \ Exception $ e ) { $ this -> expireDate = null ; } } return $ this ; }
1383	protected function dataGet ( $ key , $ default = null ) { if ( ! isset ( $ this -> document -> data ) ) { return $ default ; } return data_get ( $ this -> document -> data , $ key , $ default ) ; }
10571	protected function validateCache ( $ lastModified , $ etag ) { if ( isset ( $ _SERVER [ 'HTTP_IF_NONE_MATCH' ] ) ) { return $ etag !== null && in_array ( $ etag , Yii :: $ app -> request -> getEtags ( ) , true ) ; } elseif ( isset ( $ _SERVER [ 'HTTP_IF_MODIFIED_SINCE' ] ) ) { return $ lastModified !== null && @ strtotime ( $ _SERVER [ 'HTTP_IF_MODIFIED_SINCE' ] ) >= $ lastModified ; } else { return $ etag === null && $ lastModified === null ; } }
12809	private static function isPrimaryKey ( string $ table , string $ column ) : bool { return self :: getPrimaryKey ( $ table ) [ "column_name" ] === $ column ; }
10360	public static function fatal ( ) { $ e = error_get_last ( ) ; if ( $ e !== null && ( error_reporting ( ) & $ e [ 'type' ] ) !== 0 ) { ErrorHandler :: exception ( new \ ErrorException ( $ e [ 'message' ] , $ e [ 'type' ] , 0 , $ e [ 'file' ] , $ e [ 'line' ] ) ) ; exit ( 1 ) ; } }
7929	public function setDefaultGroup ( $ defaultGroup ) { list ( $ defaultGroup ) = $ this -> fireEvent ( 'default-group.set' , [ $ defaultGroup ] ) ; $ this -> defaultGroup = $ defaultGroup ; return $ this ; }
7566	protected function parse_single ( $ recursive = true ) { if ( ( $ c = $ this -> parse_conditions ( ) ) === false ) { return false ; } $ this -> parse_callback ( $ c , $ recursive , $ this -> search_root ) ; return true ; }
10460	public static function create ( $ type ) { switch ( $ type ) { case ActionTypes :: CREATE : return new CreateDiffItem ( ) ; case ActionTypes :: UPDATE : return new UpdateDiffItem ( ) ; case ActionTypes :: DELETE : return new DeleteDiffItem ( ) ; default : throw new \ InvalidArgumentException ( "Invalid type {$type}" ) ; } }
4097	public function field ( $ field , $ config = array ( ) ) { if ( is_string ( $ config ) ) $ config = array ( 'type' => $ config ) ; $ this -> properties [ $ field ] = $ config ; return $ this ; }
3234	static function stringEquals ( $ a , $ b ) { if ( func_num_args ( ) !== 2 ) { throw new \ InvalidArgumentException ( "Expecting 2 args, got " . func_num_args ( ) . "." ) ; } Checker :: argString ( "a" , $ a ) ; Checker :: argString ( "b" , $ b ) ; $ len = strlen ( $ a ) ; if ( strlen ( $ b ) !== $ len ) return false ; $ result = 0 ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { $ result |= ord ( $ a [ $ i ] ) ^ ord ( $ b [ $ i ] ) ; } return $ result === 0 ; }
12930	public function attemptConfirmation ( $ code ) { $ token = $ this -> finder -> findToken ( [ 'user_id' => $ this -> id , 'code' => $ code , 'type' => Token :: TYPE_CONFIRMATION , ] ) -> one ( ) ; if ( $ token === null || $ token -> isExpired ) { \ Yii :: $ app -> session -> setFlash ( 'danger' , \ Yii :: t ( 'user' , 'The confirmation link is invalid or expired. Please try requesting a new one.' ) ) ; } else { $ token -> delete ( ) ; $ this -> confirmed_at = time ( ) ; \ Yii :: $ app -> user -> login ( $ this ) ; \ Yii :: getLogger ( ) -> log ( 'User has been confirmed' , Logger :: LEVEL_INFO ) ; if ( $ this -> save ( false ) ) { \ Yii :: $ app -> session -> setFlash ( 'success' , \ Yii :: t ( 'user' , 'Thank you, registration is now complete.' ) ) ; } else { \ Yii :: $ app -> session -> setFlash ( 'danger' , \ Yii :: t ( 'user' , 'Something went wrong and your account has not been confirmed.' ) ) ; } } }
7832	protected function getSpacesByCore ( $ up = false ) { $ free = $ this -> getTotalWidth ( ) - $ this -> getBordersLength ( ) - $ this -> getCoreLength ( ) ; return $ free < 1 ? '' : str_repeat ( ' ' , $ this -> roundHalf ( $ free , $ up ) ) ; }
5166	protected function filterUriInstance ( $ uri ) : string { if ( $ uri instanceof UriInterface ) { return ( string ) $ uri ; } if ( is_string ( $ uri ) ) { return ( string ) \ One \ createUriFromString ( $ uri ) ; } return '' ; }
5425	public function isExpected ( $ test , $ exception ) { if ( $ this -> expected ) { return $ test -> assert ( $ this -> expected , $ exception , $ this -> message ) ; } foreach ( $ this -> ignored as $ ignored ) { if ( $ ignored -> test ( $ exception ) ) { return true ; } } return false ; }
6618	protected function parseEndpointName ( $ method , $ endpoint ) { $ endpoint = str_replace ( ' ' , '' , ucwords ( str_replace ( [ '-' , '+' , '%20' ] , ' ' , $ endpoint ) ) ) ; $ method = strtolower ( $ method ) ; return $ method . $ endpoint . 'Endpoint' ; }
8930	protected function getStackIconElement ( $ key , $ value , $ index ) { $ element = $ value ; if ( is_string ( $ key ) ) { $ element = $ this -> icon ( $ key ) -> addClass ( $ value ) ; } else if ( is_string ( $ value ) ) { $ element = $ this -> icon ( $ value ) ; } if ( ! is_a ( $ element , FontAwesomeIcon :: class ) ) { throw new \ InvalidArgumentException ( 'Invalid icon passed to stack' ) ; } return $ element -> addClass ( "fa-stack-{$index}x" ) ; }
7192	private function copyItem ( Model \ SaleItemInterface $ source , Model \ SaleItemInterface $ target ) { $ this -> copy ( $ source , $ target , [ 'designation' , 'description' , 'reference' , 'taxGroup' , 'netPrice' , 'weight' , 'quantity' , 'position' , 'compound' , 'immutable' , 'configurable' , 'private' , 'data' , ] ) ; $ this -> copy ( $ source -> getSubjectIdentity ( ) , $ target -> getSubjectIdentity ( ) , [ 'provider' , 'identifier' , ] ) ; foreach ( $ source -> getAdjustments ( ) as $ sourceAdjustment ) { $ targetAdjustment = $ this -> saleFactory -> createAdjustmentForItem ( $ target ) ; $ target -> addAdjustment ( $ targetAdjustment ) ; $ this -> copyAdjustment ( $ sourceAdjustment , $ targetAdjustment ) ; } foreach ( $ source -> getChildren ( ) as $ sourceChild ) { $ targetChild = $ this -> saleFactory -> createItemForSale ( $ target -> getSale ( ) ) ; $ target -> addChild ( $ targetChild ) ; $ this -> copyItem ( $ sourceChild , $ targetChild ) ; } }
6099	protected function put ( $ endpoint , array $ parameters = [ ] , $ fireAndForget = false ) { return $ this -> call ( $ endpoint , $ parameters , self :: METHOD_PUT , null , $ fireAndForget ) ; }
5386	public function isLabel ( $ label ) { for ( $ i = 0 , $ count = count ( $ this -> widgets ) ; $ i < $ count ; $ i ++ ) { if ( $ this -> widgets [ $ i ] -> isLabel ( $ label ) ) { return true ; } } return false ; }
6404	public static function propagateIfInstanceOf ( Exception $ exception , string $ exceptionClass ) : void { if ( is_a ( $ exception , $ exceptionClass ) ) { throw $ exception ; } }
8051	public function getAllEvents ( ) : array { $ calendarEvents = null ; $ cache = $ this -> cache ; if ( $ cache :: has ( self :: ALL_EVENTS_KEY ) ) { return $ cache :: get ( self :: ALL_EVENTS_KEY ) ; } $ allEvents = $ this -> calendarEvent -> with ( [ 'calendarEventRepeatDates' ] ) -> get ( ) ; $ calendarEvents = $ allEvents -> keyBy ( 'id' ) -> toArray ( ) ; $ cache :: put ( self :: ALL_EVENTS_KEY , $ calendarEvents , $ this -> cacheTimeToLive ) ; return $ calendarEvents ; }
12890	public function createView ( ) : \ stdClass { $ oView = new \ stdClass ; $ oView -> form = $ this -> _sView ; $ oView -> form_start = $ this -> _oForm -> getFormInObject ( ) -> start ; $ oView -> form_end = $ this -> _oForm -> getFormInObject ( ) -> end ; $ oView -> form_row = array ( ) ; foreach ( $ this -> _oForm -> getFormInObject ( ) -> form as $ sKey => $ mValue ) { if ( $ mValue instanceof Container ) { $ oNewForm = $ mValue -> createView ( ) ; $ oView -> form_row [ $ sKey ] = $ oNewForm -> form_row ; } else { $ oView -> form_row [ $ sKey ] = $ mValue ; } } return $ oView ; }
8287	protected function createContainer ( ) { $ configDir = $ this -> pico -> getConfigDir ( ) ; $ userContainer = $ configDir . "PicoAuth/container.php" ; if ( is_file ( $ userContainer ) && is_readable ( $ userContainer ) ) { $ this -> container = include $ userContainer ; if ( $ this -> container === false || ! ( $ this -> container instanceof \ League \ Container \ Container ) ) { throw new \ RuntimeException ( "The container.php does not return container instance." ) ; } } else { $ this -> container = include $ this -> pluginDir . '/src/container.php' ; } $ this -> container -> share ( 'configDir' , new \ League \ Container \ Argument \ RawArgument ( $ configDir ) ) ; $ this -> container -> share ( 'PicoAuth' , $ this ) ; if ( ! $ this -> config [ "rateLimit" ] ) { $ this -> container -> share ( 'RateLimit' , \ PicoAuth \ Security \ RateLimiting \ NullRateLimit :: class ) ; } }
2727	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ service = $ this -> api -> checkServiceDetails ( ) ; $ currActiveVersion = $ this -> vcl -> determineVersions ( $ service -> versions ) ; $ snippet = $ this -> config -> getVclSnippets ( Config :: VCL_WAF_PATH , Config :: VCL_WAF_ALLOWLIST_SNIPPET ) ; $ acls = $ this -> prepareAcls ( $ this -> request -> getParam ( 'acls' ) ) ; $ allowedItems = $ acls ; $ strippedAllowedItems = substr ( $ allowedItems , 0 , strrpos ( $ allowedItems , '||' , - 1 ) ) ; foreach ( $ snippet as $ key => $ value ) { if ( $ strippedAllowedItems === '' ) { $ value = '' ; } else { $ value = str_replace ( '####WAF_ALLOWLIST####' , $ strippedAllowedItems , $ value ) ; } $ snippetName = Config :: FASTLY_MAGENTO_MODULE . '_waf_' . $ key ; $ snippetId = $ this -> api -> getSnippet ( $ currActiveVersion [ 'active_version' ] , $ snippetName ) -> id ; $ params = [ 'name' => $ snippetId , 'content' => $ value ] ; $ this -> api -> updateSnippet ( $ params ) ; } $ this -> cacheTypeList -> cleanType ( 'config' ) ; $ this -> systemConfig -> clean ( ) ; return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
276	private function printHelpMessage ( ) { $ this -> stdout ( $ this -> getHelpSummary ( ) . "\n" ) ; $ helpCommand = Console :: ansiFormat ( 'yii help fixture' , [ Console :: FG_CYAN ] ) ; $ this -> stdout ( "Use $helpCommand to get usage info.\n" ) ; }
6840	public function getData ( $ key ) { if ( isset ( $ this -> data [ $ key ] ) ) { return $ this -> data [ $ key ] ; } throw new InjectorException ( "data $key not found" ) ; }
9430	public function getFontIconTag ( ) { if ( $ this -> owner -> hasFontIcon ( ) ) { return $ this -> backend -> getTag ( $ this -> owner -> FontIconClass , $ this -> owner -> FontIconColor ) ; } }
6318	public function query ( $ sql ) { $ rows = array ( ) ; foreach ( $ this -> getConnection ( ) -> query ( $ sql ) as $ row ) { $ rows [ ] = $ row ; } return $ rows ; }
12381	public static function interval ( $ startDate , $ endDate ) { $ hits = DB :: table ( 'views' ) -> select ( 'id' , 'ip' , 'created_at' ) -> whereBetween ( 'created_at' , [ $ startDate , $ endDate ] ) -> groupBy ( 'ip' ) -> get ( ) ; return count ( $ hits ) ; }
5517	public function errorAt ( $ timing , $ method , $ error = 'A mock error' , $ args = false , $ severity = E_USER_ERROR ) { $ this -> dieOnNoMethod ( $ method , 'error at' ) ; $ this -> actions -> registerAt ( $ timing , $ method , $ args , new SimpleErrorThrower ( $ error , $ severity ) ) ; }
8459	public function getVersion ( ) { if ( empty ( $ this -> drushVersion ) ) { $ isPrinted = $ this -> isPrinted ; $ this -> isPrinted = false ; $ result = $ this -> executeCommand ( $ this -> executable . ' version' ) ; $ output = $ result -> getMessage ( ) ; $ this -> drushVersion = 'unknown' ; if ( preg_match ( '#[0-9.]+#' , $ output , $ matches ) ) { $ this -> drushVersion = $ matches [ 0 ] ; } $ this -> isPrinted = $ isPrinted ; } return $ this -> drushVersion ; }
11829	public function getByTag ( $ tag ) { $ taggings = $ this -> getTaggings ( ) ; if ( array_key_exists ( $ tag , $ taggings ) ) { return $ taggings [ $ tag ] ; } return array ( ) ; }
12135	public function show ( QuestionRequest $ request , Question $ question ) { if ( $ question -> exists ) { $ view = 'forum::question.show' ; } else { $ view = 'forum::question.new' ; } return $ this -> response -> title ( trans ( 'app.view' ) . ' ' . trans ( 'forum::question.name' ) ) -> data ( compact ( 'question' ) ) -> view ( $ view , true ) -> output ( ) ; }
4033	public function push ( $ url , $ table , $ icon ) { $ this -> elements [ ] = [ 'url' => $ url , 'text' => $ this -> getLabel ( $ table ) , 'icon' => $ this -> iconBuilder -> getBackendIcon ( $ icon ) ] ; }
759	public function setChildren ( $ children ) { $ this -> _children = [ ] ; foreach ( $ children as $ child ) { $ child -> parent = $ this ; $ this -> _children [ ] = $ child ; } $ this -> updateCollectionOffsets ( ) ; }
5689	public function getFormById ( $ id ) { for ( $ i = 0 ; $ i < count ( $ this -> forms ) ; $ i ++ ) { if ( $ this -> forms [ $ i ] -> getId ( ) == $ id ) { return $ this -> forms [ $ i ] ; } } return ; }
7422	protected function renderAlertBlock ( ) { $ session = \ Yii :: $ app -> session ; $ flashes = $ session -> getAllFlashes ( ) ; $ alertContainerOptions = [ 'style' => 'max-width:400px' ] ; if ( count ( $ flashes ) === 0 ) { Html :: addCssStyle ( $ alertContainerOptions , 'display:none;' ) ; } $ out = Html :: beginTag ( 'div' , $ alertContainerOptions ) ; foreach ( $ flashes as $ type => $ message ) { if ( is_array ( $ message ) ) { $ message = implode ( '<br>' , $ message ) ; } $ alertWidgetOptions = [ ] ; $ alertWidgetOptions [ 'body' ] = $ message ; $ alertWidgetOptions [ 'options' ] = [ 'class' => [ 'alert' , 'alert-success' ] , 'style' => 'padding-left:10px;padding-right:10px;' ] ; $ out .= "\n" . Alert :: widget ( $ alertWidgetOptions ) ; $ session -> removeFlash ( $ type ) ; } $ out .= "\n</div>" ; return $ this -> alertBlockAddon . $ out ; }
290	public function __isset ( $ name ) { try { return $ this -> __get ( $ name ) !== null ; } catch ( \ Throwable $ t ) { return false ; } catch ( \ Exception $ e ) { return false ; } }
10499	public function gte ( $ value ) { $ value = Cast :: Float ( $ value ) ; if ( $ this -> value !== null && $ this -> value >= $ value ) { return true ; } return false ; }
7350	protected function initializePaymentSubject ( ) { $ this -> depositTotal = 0 ; $ this -> grandTotal = 0 ; $ this -> paidTotal = 0 ; $ this -> pendingTotal = 0 ; $ this -> outstandingAccepted = 0 ; $ this -> outstandingExpired = 0 ; $ this -> outstandingLimit = 0 ; $ this -> paymentState = PaymentStates :: STATE_NEW ; $ this -> payments = new ArrayCollection ( ) ; }
8597	public function listMarketplaceParticipationsByNextToken ( $ request ) { if ( ! ( $ request instanceof MarketplaceWebServiceSellers_Model_ListMarketplaceParticipationsByNextTokenRequest ) ) { $ request = new MarketplaceWebServiceSellers_Model_ListMarketplaceParticipationsByNextTokenRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListMarketplaceParticipationsByNextToken' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = MarketplaceWebServiceSellers_Model_ListMarketplaceParticipationsByNextTokenResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
755	public function validate ( $ input , $ caseSensitive ) { $ code = $ this -> getVerifyCode ( ) ; $ valid = $ caseSensitive ? ( $ input === $ code ) : strcasecmp ( $ input , $ code ) === 0 ; $ session = Yii :: $ app -> getSession ( ) ; $ session -> open ( ) ; $ name = $ this -> getSessionKey ( ) . 'count' ; $ session [ $ name ] += 1 ; if ( $ valid || $ session [ $ name ] > $ this -> testLimit && $ this -> testLimit > 0 ) { $ this -> getVerifyCode ( true ) ; } return $ valid ; }
1022	private static function buildExecutionContext ( Schema $ schema , DocumentNode $ documentNode , $ rootValue , $ contextValue , $ rawVariableValues , $ operationName = null , ? callable $ fieldResolver = null , ? PromiseAdapter $ promiseAdapter = null ) { $ errors = [ ] ; $ fragments = [ ] ; $ operation = null ; $ hasMultipleAssumedOperations = false ; foreach ( $ documentNode -> definitions as $ definition ) { switch ( $ definition -> kind ) { case NodeKind :: OPERATION_DEFINITION : if ( ! $ operationName && $ operation ) { $ hasMultipleAssumedOperations = true ; } if ( ! $ operationName || ( isset ( $ definition -> name ) && $ definition -> name -> value === $ operationName ) ) { $ operation = $ definition ; } break ; case NodeKind :: FRAGMENT_DEFINITION : $ fragments [ $ definition -> name -> value ] = $ definition ; break ; } } if ( $ operation === null ) { if ( $ operationName ) { $ errors [ ] = new Error ( sprintf ( 'Unknown operation named "%s".' , $ operationName ) ) ; } else { $ errors [ ] = new Error ( 'Must provide an operation.' ) ; } } elseif ( $ hasMultipleAssumedOperations ) { $ errors [ ] = new Error ( 'Must provide operation name if query contains multiple operations.' ) ; } $ variableValues = null ; if ( $ operation !== null ) { [ $ coercionErrors , $ coercedVariableValues ] = Values :: getVariableValues ( $ schema , $ operation -> variableDefinitions ? : [ ] , $ rawVariableValues ? : [ ] ) ; if ( empty ( $ coercionErrors ) ) { $ variableValues = $ coercedVariableValues ; } else { $ errors = array_merge ( $ errors , $ coercionErrors ) ; } } if ( ! empty ( $ errors ) ) { return $ errors ; } Utils :: invariant ( $ operation , 'Has operation if no errors.' ) ; Utils :: invariant ( $ variableValues !== null , 'Has variables if no errors.' ) ; return new ExecutionContext ( $ schema , $ fragments , $ rootValue , $ contextValue , $ operation , $ variableValues , $ errors , $ fieldResolver , $ promiseAdapter ) ; }
11673	public function offsetExists ( $ offset ) { if ( is_null ( $ this -> result ) ) { $ this -> fetchData ( ) ; } if ( array_key_exists ( $ offset , $ this -> result ) ) { return true ; } else { return false ; } }
12492	public static function orderBy ( $ field , $ order ) { if ( ! $ order ) { $ order = 'DESC' ; } $ order = strtoupper ( $ order ) ; if ( ! ( $ order == 'ASC' || $ order == 'DESC' ) ) { throw new ClusterpointException ( "\"->order()\" function: ordering should be DESC or ASC." , 9002 ) ; } if ( ! ( gettype ( $ field ) == "string" || $ field instanceof Key || $ field instanceof Raw ) ) { throw new ClusterpointException ( "\"->order()\" function: passed field selector is not in valid format." , 9002 ) ; } if ( $ field instanceof Key ) { $ field = self :: field ( "{$field}" ) ; } return "{$field} {$order}" ; }
1138	public function destroyDescendants ( ) { if ( is_null ( $ this -> getRight ( ) ) || is_null ( $ this -> getLeft ( ) ) ) return ; $ self = $ this ; $ this -> getConnection ( ) -> transaction ( function ( ) use ( $ self ) { $ self -> reload ( ) ; $ lftCol = $ self -> getLeftColumnName ( ) ; $ rgtCol = $ self -> getRightColumnName ( ) ; $ lft = $ self -> getLeft ( ) ; $ rgt = $ self -> getRight ( ) ; $ self -> newNestedSetQuery ( ) -> where ( $ lftCol , '>=' , $ lft ) -> select ( $ self -> getKeyName ( ) ) -> lockForUpdate ( ) -> get ( ) ; $ self -> newNestedSetQuery ( ) -> where ( $ lftCol , '>' , $ lft ) -> where ( $ rgtCol , '<' , $ rgt ) -> delete ( ) ; $ diff = $ rgt - $ lft + 1 ; $ self -> newNestedSetQuery ( ) -> where ( $ lftCol , '>' , $ rgt ) -> decrement ( $ lftCol , $ diff ) ; $ self -> newNestedSetQuery ( ) -> where ( $ rgtCol , '>' , $ rgt ) -> decrement ( $ rgtCol , $ diff ) ; } ) ; }
12365	public function init ( ) { $ config = new Zend_Config_Ini ( $ this -> config_path == null ? APPLICATION_PATH . DS . "configs" . DS . "secret.ini" : $ config_path , APPLICATION_ENV ) ; $ this -> setConsumer ( new Zend_Oauth_Consumer ( array ( 'callbackUrl' => $ config -> oauth -> callback , 'siteUrl' => $ config -> oauth -> siteurl , 'consumerKey' => $ config -> oauth -> consumerkey , 'consumerSecret' => $ config -> oauth -> consumersecret ) ) ) ; }
3607	protected function getTableNames ( ) { $ schemas = DB :: getConfig ( 'used_schemas' ) ? : [ DB :: getConfig ( 'schema' ) ] ; $ schemaCount = count ( $ schemas ) ; $ binds = implode ( ',' , array_fill ( 0 , $ schemaCount , '?' ) ) ; return collect ( DB :: select ( "SELECT schemaname || '.' || tablename AS table FROM pg_catalog.pg_tables WHERE schemaname IN (" . $ binds . ')' , $ schemas ) ) -> pluck ( 'table' ) -> reject ( function ( $ value , $ key ) { $ tableName = explode ( '.' , $ value ) [ 1 ] ; return $ tableName === 'spatial_ref_sys' ; } ) ; }
9402	public function build ( $ options ) { $ command = $ this -> path ; if ( isset ( $ options [ 'title' ] ) ) { $ command .= " -t {$options['title']}" ; } if ( isset ( $ options [ 'message' ] ) ) { $ command .= " -m {$options['message']}" ; } if ( isset ( $ options [ 'image' ] ) ) { $ pathInfo = pathinfo ( $ options [ 'image' ] ) ; if ( isset ( $ pathInfo [ 'extension' ] ) ) { $ command .= " --image {$options['image']}" ; } else { $ command .= " -a {$options['image']}" ; } } if ( isset ( $ options [ 'url' ] ) ) { $ command .= " --url {$options['url']}" ; } if ( isset ( $ options [ 'sticky' ] ) && $ options [ 'sticky' ] === true ) { $ command .= ' -s' ; } return $ command ; }
10944	public function onPrerenderPre ( PrerenderEvent $ events ) { $ cache = $ this -> getServiceLocator ( ) -> get ( $ this -> moduleOptions -> getCacheKey ( ) ) ; return $ cache -> getItem ( $ this -> getCacheEntryKey ( $ events -> getRequest ( ) ) ) ; }
1001	public static function doTypesOverlap ( Schema $ schema , CompositeType $ typeA , CompositeType $ typeB ) { if ( $ typeA === $ typeB ) { return true ; } if ( $ typeA instanceof AbstractType ) { if ( $ typeB instanceof AbstractType ) { foreach ( $ schema -> getPossibleTypes ( $ typeA ) as $ type ) { if ( $ schema -> isPossibleType ( $ typeB , $ type ) ) { return true ; } } return false ; } return $ schema -> isPossibleType ( $ typeA , $ typeB ) ; } if ( $ typeB instanceof AbstractType ) { return $ schema -> isPossibleType ( $ typeB , $ typeA ) ; } return false ; }
9910	function toArray ( ) { $ result = array ( ) ; $ object_vars = get_object_vars ( $ this ) ; foreach ( $ object_vars as $ key => $ value ) { if ( $ value == null ) { continue ; } if ( gettype ( $ value ) == "object" && is_subclass_of ( $ value , 'AbstractJSONWrapper' ) ) { if ( ! $ value -> isEmpty ( ) ) { $ result [ $ key ] = $ value -> toArray ( ) ; } } else { $ result [ $ key ] = $ value ; } } return $ result ; }
3779	protected function getParameterFilterOptions ( $ objAttribute , $ arrIds , & $ arrCount = null ) { $ arrOptions = $ objAttribute -> getFilterOptions ( $ this -> get ( 'onlypossible' ) ? $ arrIds : null , ( bool ) $ this -> get ( 'onlyused' ) , $ arrCount ) ; foreach ( $ arrOptions as $ mixOptionKey => $ mixOptions ) { $ mixOptions = strip_tags ( $ mixOptions ) ; $ mixOptions = trim ( $ mixOptions ) ; if ( $ mixOptions === '' || $ mixOptions === null ) { unset ( $ arrOptions [ $ mixOptionKey ] ) ; } } return $ arrOptions ; }
10482	public function getBucket ( string $ name ) : SessionBucketInterface { $ segment = $ this -> session -> getSegment ( $ name ) ; if ( ! $ segment ) { return null ; } return new AuraSessionBucketAdapter ( $ segment ) ; }
10518	protected function getProductPhoto ( MediaInterface $ media , ProductInterface $ modelData , $ values ) { $ mainPhoto = $ this -> isMainPhoto ( $ media , $ values [ 'main' ] ) ; $ productPhoto = new ProductPhoto ( ) ; $ productPhoto -> setPhoto ( $ media ) ; $ productPhoto -> setMainPhoto ( $ mainPhoto ) ; $ productPhoto -> setProduct ( $ modelData ) ; if ( $ mainPhoto ) { $ modelData -> setPhoto ( $ media ) ; } return $ productPhoto ; }
4332	private static function buildAttribArrayVal ( $ key , $ value = array ( ) ) { if ( $ key == 'class' ) { if ( ! \ is_array ( $ value ) ) { $ value = \ explode ( ' ' , $ value ) ; } $ value = \ array_filter ( \ array_unique ( $ value ) ) ; \ sort ( $ value ) ; $ value = \ implode ( ' ' , $ value ) ; } elseif ( $ key == 'style' ) { $ keyValues = array ( ) ; foreach ( $ value as $ k => $ v ) { $ keyValues [ ] = $ k . ':' . $ v . ';' ; } \ sort ( $ keyValues ) ; $ value = \ implode ( '' , $ keyValues ) ; } else { $ value = null ; } return $ value ; }
1119	public function scopeLimitDepth ( $ query , $ limit ) { $ depth = $ this -> exists ? $ this -> getDepth ( ) : $ this -> getLevel ( ) ; $ max = $ depth + $ limit ; $ scopes = array ( $ depth , $ max ) ; return $ query -> whereBetween ( $ this -> getDepthColumnName ( ) , array ( min ( $ scopes ) , max ( $ scopes ) ) ) ; }
8544	public function setRefundEventList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'RefundEventList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
9487	private function installModules ( ) { $ this -> frame ( 'Installing the modules' ) ; $ this -> line ( '' ) ; foreach ( $ this -> config ( ) -> get ( 'arcanesoft.foundation.modules.commands.install' , [ ] ) as $ command ) { $ this -> call ( $ command ) ; } $ this -> call ( 'db:seed' , [ '--class' => DatabaseSeeder :: class ] ) ; $ this -> line ( '' ) ; $ this -> comment ( 'Modules installed !' ) ; $ this -> line ( '' ) ; }
10447	public function post ( Payload $ payload , $ endpoint ) { if ( ! Type :: isValidWebhookType ( $ payload -> getAction ( ) ) ) { throw new \ Exception ( sprintf ( 'Webhook "%s" isn\'t valid' , $ payload -> getAction ( ) ) ) ; } $ requestContent = [ 'headers' => [ 'Content-Type' => 'application/json' ] , 'body' => json_encode ( $ payload ) , 'timeout' => self :: DEFAULT_REQUEST_TIMEOUT ] ; return $ this -> guzzleClient -> post ( $ endpoint , $ requestContent ) ; }
4534	public function setCandidateGroup ( ? string $ candidateGroup ) { $ this -> candidateGroup = $ candidateGroup ; $ this -> _candidateGroup = null !== $ candidateGroup ; return $ this ; }
8488	public static function getLoad ( ) { $ wmi = Windows :: getInstance ( ) ; $ load = [ ] ; foreach ( $ wmi -> ExecQuery ( "SELECT LoadPercentage FROM Win32_Processor" ) as $ cpu ) { $ load [ ] = $ cpu -> LoadPercentage ; } return round ( array_sum ( $ load ) / count ( $ load ) , 2 ) . "%" ; }
250	public function setUseCookies ( $ value ) { $ this -> freeze ( ) ; if ( $ value === false ) { ini_set ( 'session.use_cookies' , '0' ) ; ini_set ( 'session.use_only_cookies' , '0' ) ; } elseif ( $ value === true ) { ini_set ( 'session.use_cookies' , '1' ) ; ini_set ( 'session.use_only_cookies' , '1' ) ; } else { ini_set ( 'session.use_cookies' , '1' ) ; ini_set ( 'session.use_only_cookies' , '0' ) ; } $ this -> unfreeze ( ) ; }
12442	public function detach ( $ key ) { if ( isset ( $ this -> instances [ $ key ] ) ) { unset ( $ this -> instances [ $ key ] ) ; } return $ this ; }
396	public static function deleteAll ( $ condition = null , $ params = [ ] ) { $ command = static :: getDb ( ) -> createCommand ( ) ; $ command -> delete ( static :: tableName ( ) , $ condition , $ params ) ; return $ command -> execute ( ) ; }
1775	protected function isChecked ( $ arrOption ) { if ( empty ( $ this -> varValue ) && empty ( $ _POST ) && $ arrOption [ 'default' ] ) { return static :: optionChecked ( 1 , 1 ) ; } return static :: optionChecked ( $ arrOption [ 'value' ] , $ this -> varValue ) ; }
8704	public function apply ( EloquentBuilder $ builder , Eloquent $ model ) { $ this -> table = $ model -> getTable ( ) ; $ this -> locale = $ model -> getLocale ( ) ; $ this -> i18nTable = $ model -> getI18nTable ( ) ; $ this -> fallback = $ model -> getFallbackLocale ( ) ; if ( ! starts_with ( $ this -> table , 'laravel_reserved_' ) ) { $ this -> createJoin ( $ builder , $ model ) ; $ this -> createWhere ( $ builder , $ model ) ; $ this -> createSelect ( $ builder , $ model ) ; } }
7624	protected function performRequest ( $ path = '/' , $ query = array ( ) , $ httpVerb = 'GET' , $ headers = array ( ) , $ forTableStorage = false , $ rawData = null , $ resourceType = self :: RESOURCE_UNKNOWN , $ requiredPermission = self :: PERMISSION_READ ) { if ( strpos ( $ path , '/' ) !== 0 ) { $ path = '/' . $ path ; } if ( ! isset ( $ headers [ 'Content-Type' ] ) ) { $ headers [ 'Content-Type' ] = '' ; } if ( ! isset ( $ headers [ 'content-length' ] ) && ( $ rawData !== null || $ httpVerb == "PUT" ) ) { $ headers [ 'Content-Length' ] = strlen ( ( string ) $ rawData ) ; } $ headers [ 'Expect' ] = '' ; $ headers [ 'x-ms-version' ] = $ this -> apiVersion ; $ path = str_replace ( ' ' , '%20' , $ path ) ; $ requestUrl = $ this -> getBaseUrl ( ) . $ path ; if ( count ( $ query ) > 0 ) { $ queryString = '' ; foreach ( $ query as $ key => $ value ) { $ queryString .= ( $ queryString ? '&' : '?' ) . rawurlencode ( $ key ) . '=' . rawurlencode ( $ value ) ; } $ requestUrl .= $ queryString ; } $ requestUrl = $ this -> credentials -> signRequestUrl ( $ requestUrl , $ resourceType , $ requiredPermission ) ; $ headers = $ this -> credentials -> signRequestHeaders ( $ httpVerb , $ path , $ query , $ headers , $ forTableStorage , $ resourceType , $ requiredPermission , $ rawData ) ; return $ this -> httpClient -> request ( $ httpVerb , $ requestUrl , $ rawData , $ headers ) ; }
12571	public function previewVoice ( $ message , $ to , $ by = self :: PREVIEW_BY_OPENID ) { return $ this -> preview ( self :: MSG_TYPE_VOICE , $ message , $ to , $ by ) ; }
1139	public function shiftSiblingsForRestore ( ) { if ( is_null ( $ this -> getRight ( ) ) || is_null ( $ this -> getLeft ( ) ) ) return ; $ self = $ this ; $ this -> getConnection ( ) -> transaction ( function ( ) use ( $ self ) { $ lftCol = $ self -> getLeftColumnName ( ) ; $ rgtCol = $ self -> getRightColumnName ( ) ; $ lft = $ self -> getLeft ( ) ; $ rgt = $ self -> getRight ( ) ; $ diff = $ rgt - $ lft + 1 ; $ self -> newNestedSetQuery ( ) -> where ( $ lftCol , '>=' , $ lft ) -> increment ( $ lftCol , $ diff ) ; $ self -> newNestedSetQuery ( ) -> where ( $ rgtCol , '>=' , $ lft ) -> increment ( $ rgtCol , $ diff ) ; } ) ; }
2535	public function getMessagesAndVersions ( ) { if ( empty ( $ this -> messagesAndVersions ) ) { $ this -> messagesAndVersions = WsdlAnalyser :: loadMessagesAndVersions ( $ this -> params -> wsdl ) ; } return $ this -> messagesAndVersions ; }
3414	public function fill ( $ fields ) { if ( ! is_array ( $ fields ) ) { return ; } if ( isset ( $ fields [ 'ID' ] ) ) { $ this -> id = $ fields [ 'ID' ] ; } $ this -> fields = $ fields ; $ this -> fieldsAreFetched = true ; if ( method_exists ( $ this , 'afterFill' ) ) { $ this -> afterFill ( ) ; } $ this -> original = $ this -> fields ; }
5263	public function fields ( $ fields = false ) { if ( $ fields === false ) { $ this -> query [ 'body' ] [ '_source' ] = false ; } elseif ( ( array ) $ fields == [ '*' ] ) { unset ( $ this -> query [ 'body' ] [ '_source' ] ) ; } else { $ this -> query [ 'body' ] [ '_source' ] = $ fields ; } return $ this ; }
12377	public function superadmin ( User $ account , Container $ application , Database $ database ) { $ config = $ this -> config ; $ username = $ application -> input -> getString ( "user_first_name" , "" , "post" , FALSE , array ( ) ) ; $ usernameid = $ application -> input -> getString ( "user_name_id" , "" , "post" , FALSE , array ( ) ) ; $ userpass = $ application -> input -> getString ( "user_password" , "" , "post" , FALSE , array ( ) ) ; $ userpass2 = $ application -> input -> getString ( "user_password_2" , "" , "post" , FALSE , array ( ) ) ; $ useremail = $ application -> input -> getString ( "user_email" , "" , "post" , FALSE , array ( ) ) ; if ( empty ( $ userpass ) || empty ( $ username ) || empty ( $ usernameid ) || empty ( $ useremail ) ) { throw new Exception ( t ( 'Please provide at least a Name, Username, E-mail and Password' ) ) ; return false ; } if ( $ userpass <> $ userpass2 ) { throw new Exception ( t ( 'The user passwords do not match' ) ) ; return false ; } if ( ! $ account -> store ( $ application -> input -> data ( "post" ) , true ) ) { throw new Exception ( t ( 'Could not store the admin user account' ) ) ; return false ; } $ adminAuthority = $ this -> config -> get ( "setup.site.superadmin-authority" , NULL ) ; if ( ! empty ( $ adminAuthority ) ) { $ query = "INSERT INTO ?objects_authority( authority_id, object_id ) SELECT {$database->quote((int)$adminAuthority)}, object_id FROM ?objects WHERE object_uri={$database->quote($usernameid)}" ; $ database -> exec ( $ query ) ; } $ config -> set ( "setup.session.store" , "database" ) ; $ config -> set ( "setup.database.installed" , TRUE ) ; if ( ! $ config -> saveParams ( ) ) { throw new Exception ( "could not save config" ) ; return false ; } return true ; }
2928	public function getKeys ( $ keys = [ ] ) { $ allKeys = $ this -> reader -> keys ( ) ; return array_filter ( $ allKeys , function ( $ key ) use ( $ keys ) { if ( ! empty ( $ keys ) ) { return in_array ( $ key , $ keys ) ; } return true ; } , ARRAY_FILTER_USE_KEY ) ; }
639	public function renameColumn ( $ table , $ oldName , $ newName ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> renameColumn ( $ table , $ oldName , $ newName ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; }
3168	private function getCurrentThemeId ( ) { $ themeService = $ this -> getServiceLocator ( ) -> get ( ThemeService :: SERVICE_ID ) ; return $ themeService -> getTheme ( ) -> getId ( ) ; }
8912	protected function _fetch_primary_key ( ) { if ( $ this -> is_base_model_instance ( ) ) { return ; } if ( $ this -> primary_key == NULL && $ this -> _database ) { $ this -> primary_key = $ this -> execute_query ( "SHOW KEYS FROM `" . $ this -> _database -> dbprefix ( $ this -> _table ) . "` WHERE Key_name = 'PRIMARY'" ) -> row ( ) -> Column_name ; } }
2923	public function lines ( ) { $ content = [ ] ; $ lines = $ this -> readLinesFromFile ( ) ; foreach ( $ lines as $ row => $ line ) { $ data = [ 'line' => $ row + 1 , 'raw_data' => $ line , 'parsed_data' => $ this -> formatter -> parseLine ( $ line ) ] ; $ content [ ] = $ data ; } return $ content ; }
880	private function resolveSubset ( $ setName , $ setValue ) { $ rules = $ this -> getSetDefinition ( $ setName ) ; foreach ( $ rules as $ name => $ value ) { if ( '@' === $ name [ 0 ] ) { $ set = $ this -> resolveSubset ( $ name , $ setValue ) ; unset ( $ rules [ $ name ] ) ; $ rules = array_merge ( $ rules , $ set ) ; } elseif ( ! $ setValue ) { $ rules [ $ name ] = false ; } else { $ rules [ $ name ] = $ value ; } } return $ rules ; }
9976	public static function builtInFormatCode ( $ pIndex ) { $ pIndex = ( int ) $ pIndex ; self :: fillBuiltInFormatCodes ( ) ; if ( isset ( self :: $ builtInFormats [ $ pIndex ] ) ) { return self :: $ builtInFormats [ $ pIndex ] ; } return '' ; }
11943	private function validateUrl ( Request $ request , ConfigContainer $ config , $ position ) { $ url = $ request -> getUrl ( ) ; $ default = $ config -> getValue ( 'default' ) ; if ( preg_match ( '/^' . $ config -> getValue ( 'pattern' ) . '$/' , $ url , $ matches ) && isset ( $ matches [ 1 ] ) ) { return $ matches [ 1 ] ; } else if ( $ default !== false ) { return $ config -> getValue ( 'default' ) ; } else { throw new RequiredArgumentException ( $ position , $ config -> getValue ( 'name' ) ) ; } }
809	private function sortByLength ( array $ first , array $ second ) { $ firstNamespace = ( self :: IMPORT_TYPE_CLASS === $ first [ 'importType' ] ? '' : $ first [ 'importType' ] . ' ' ) . $ this -> prepareNamespace ( $ first [ 'namespace' ] ) ; $ secondNamespace = ( self :: IMPORT_TYPE_CLASS === $ second [ 'importType' ] ? '' : $ second [ 'importType' ] . ' ' ) . $ this -> prepareNamespace ( $ second [ 'namespace' ] ) ; $ firstNamespaceLength = \ strlen ( $ firstNamespace ) ; $ secondNamespaceLength = \ strlen ( $ secondNamespace ) ; if ( $ firstNamespaceLength === $ secondNamespaceLength ) { $ sortResult = strcasecmp ( $ firstNamespace , $ secondNamespace ) ; } else { $ sortResult = $ firstNamespaceLength > $ secondNamespaceLength ? 1 : - 1 ; } return $ sortResult ; }
7923	private function extractFilename ( \ ZipArchive $ zipArchive , $ fileIndex ) { $ entry = $ zipArchive -> statIndex ( $ fileIndex ) ; $ filename = str_replace ( '\\' , '/' , $ entry [ 'name' ] ) ; if ( $ this -> isValidPath ( $ filename ) ) { return $ filename ; } throw new \ Exception ( 'Invalid filename path in zip archive' ) ; }
6143	public function checkQuery ( $ query = null ) { if ( $ query === null ) { $ query = $ this -> query ; } if ( strlen ( $ query ) == 0 ) { return true ; } $ pattern = "/^" . $ this -> regex [ "uric" ] . "*$/" ; $ status = @ preg_match ( $ pattern , $ query ) ; if ( $ status === false ) { throw new Ts3Exception ( "URI query string validation failed" ) ; } return ( $ status == 1 ) ; }
8341	public static function init ( ) { if ( self :: $ isInit === false ) { self :: $ prettyPageHandler = new PrettyPageHandler ( ) ; self :: $ prettyPageHandler -> setPageTitle ( 'I just broke a string... - strayFw' ) ; $ whoops = new Run ( ) ; $ whoops -> pushHandler ( new JsonResponseHandler ( ) ) ; $ whoops -> pushHandler ( self :: $ prettyPageHandler ) ; $ whoops -> register ( ) ; self :: $ isInit = true ; } }
5798	public function routeIndex ( Request $ request , Response $ response , $ args ) { $ this -> tableName = $ args [ ROUTEARG_DATABASE_TABLE_NAME ] ; $ this -> tableMapper = new TableMapper ( $ this -> tableName ) ; parent :: __construct ( $ this -> container , $ this -> tableMapper , ROUTEPREFIX_ROLES ) ; return $ this -> indexView ( $ response ) ; }
4517	public function postUpdate ( LifecycleEventArgs $ args ) { $ entity = $ args -> getEntity ( ) ; if ( ! $ entity instanceof Parameter ) { return ; } $ entity -> setValue ( unserialize ( $ entity -> getValue ( ) ) ) ; }
7960	public function canChangeDslamProfile ( $ forceReload = false ) { if ( ! $ this -> properties || $ forceReload ) $ this -> getProperties ( ) ; return $ this -> properties -> capabilities -> canChangeDslamProfile ; }
3650	protected function getTemplate ( $ strTemplate , $ strFormat = 'html5' , $ blnFailIfNotFound = false ) { $ strTemplate = basename ( $ strTemplate ) ; $ strCustom = 'templates' ; if ( TL_MODE == 'FE' ) { $ tmpDir = str_replace ( '../' , '' , $ GLOBALS [ 'objPage' ] -> templateGroup ) ; if ( ! empty ( $ tmpDir ) ) { $ strCustom = $ tmpDir ; } } try { return \ TemplateLoader :: getPath ( $ strTemplate , $ strFormat , $ strCustom ) ; } catch ( \ Exception $ exception ) { if ( $ blnFailIfNotFound ) { throw new \ RuntimeException ( sprintf ( 'Could not find template %s.%s' , $ strTemplate , $ strFormat ) , 1 , $ exception ) ; } } return null ; }
4383	protected function buildArgString ( $ args ) { $ numArgs = \ count ( $ args ) ; if ( $ numArgs == 1 && \ is_string ( $ args [ 0 ] ) ) { $ args [ 0 ] = \ strip_tags ( $ args [ 0 ] ) ; } foreach ( $ args as $ k => $ v ) { if ( $ k > 0 || ! \ is_string ( $ v ) ) { $ args [ $ k ] = $ this -> dump ( $ v ) ; } $ this -> valDepth = 0 ; } $ glue = ', ' ; $ glueAfterFirst = true ; if ( $ numArgs && \ is_string ( $ args [ 0 ] ) ) { if ( \ preg_match ( '/[=:] ?$/' , $ args [ 0 ] ) ) { $ glueAfterFirst = false ; } elseif ( \ count ( $ args ) == 2 ) { $ glue = ' = ' ; } } if ( ! $ glueAfterFirst ) { return $ args [ 0 ] . \ implode ( $ glue , \ array_slice ( $ args , 1 ) ) ; } else { return \ implode ( $ glue , $ args ) ; } }
11538	public function setItems ( $ items ) { $ this -> _items = $ items ; if ( isset ( $ this -> _items [ 0 ] ) && is_array ( $ this -> _items [ 0 ] ) ) { $ this -> _items = $ this -> _items [ 0 ] ; } foreach ( $ this -> _items as $ item ) { $ item -> owner = $ this ; if ( ! $ item -> isValid ) { $ this -> isValid = false ; } } }
2917	protected function ensureFileIsWritable ( $ filePath ) { if ( ( is_file ( $ filePath ) && ! is_writable ( $ filePath ) ) || ( ! is_file ( $ filePath ) && ! is_writable ( dirname ( $ filePath ) ) ) ) { throw new UnableWriteToFileException ( sprintf ( 'Unable to write to the file at %s.' , $ filePath ) ) ; } }
12124	public function getLanguages ( ) { $ languages = array ( ) ; foreach ( $ this -> getAliases ( ) as $ siteAlias ) { $ language = $ siteAlias -> getLanguage ( ) ; if ( ! in_array ( $ language , $ languages ) ) { $ languages [ ] = $ language ; } } return $ languages ; }
11277	protected function getStubs ( ? string $ table = null , bool $ create = false ) : iterable { if ( is_null ( $ table ) ) { yield M :: TYPE_UP => $ this -> stubs -> read ( 'blank.sql.stub' ) ; yield M :: TYPE_DOWN => $ this -> stubs -> read ( 'blank.sql.stub' ) ; return ; } $ first = [ M :: TYPE_UP => 'create.sql.stub' , M :: TYPE_DOWN => 'down.sql.stub' ] ; $ second = [ M :: TYPE_UP => 'update.sql.stub' , M :: TYPE_DOWN => 'update.sql.stub' ] ; $ stubs = $ create ? $ first : $ second ; foreach ( $ stubs as $ type => $ stub ) { yield $ type => $ this -> stubs -> read ( $ stub ) ; } }
7593	public function openTag ( FormInterface $ form = null ) { $ this -> setFormClass ( $ form , $ this -> formLayout ) ; return parent :: openTag ( $ form ) ; }
9574	protected function registerProvider ( ProviderInterface $ provider ) { if ( $ provider instanceof AbstractProvider ) { $ provider -> setApplication ( $ this ) ; } $ provider -> register ( ) ; if ( $ this -> console && $ provider instanceof ConsoleProviderInterface ) { $ provider -> registerConsole ( $ this -> console ) ; } }
11124	public static function create ( $ notify ) { switch ( true ) { case $ notify === NotifyInterface :: STDOUT : return new NotifyStdout ( ) ; case $ notify === NotifyInterface :: LOGGER : return new NotifyLogger ( PrettyLogger :: create ( ) ) ; case $ notify === NotifyInterface :: BLACKHOLE : return new NotifyBlackhole ( ) ; case $ notify instanceof Output : return new NotifyConsole ( $ notify ) ; case $ notify instanceof LoggerInterface : return new NotifyLogger ( $ notify ) ; default : throw InvalidArgumentException :: forNotSupportedNotifier ( ) ; } }
6810	public function rates ( Adjustment ... $ adjustments ) : string { return implode ( ', ' , array_map ( function ( Adjustment $ adjustment ) { return $ this -> percent ( $ adjustment -> getRate ( ) ) ; } , $ adjustments ) ) ; }
8381	public function execute ( ) { if ( $ this -> statement == null ) { $ this -> statement = Database :: get ( $ this -> database ) -> { ( $ this -> isCritical === true ? 'getMasterLink' : 'getLink' ) } ( ) -> prepare ( $ this -> toSql ( ) ) ; } foreach ( $ this -> parameters as $ name => $ value ) { $ type = \ PDO :: PARAM_STR ; if ( is_int ( $ value ) === true ) { $ type = \ PDO :: PARAM_INT ; } elseif ( is_bool ( $ value ) === true ) { $ type = \ PDO :: PARAM_BOOL ; } elseif ( is_null ( $ value ) === true ) { $ type = \ PDO :: PARAM_NULL ; } $ this -> statement -> bindValue ( $ name , $ value , $ type ) ; } $ result = $ this -> statement -> execute ( ) ; $ this -> errorInfo = $ this -> statement -> errorInfo ( ) ; if ( $ this -> getErrorState ( ) != '00000' ) { Logger :: get ( ) -> error ( 'select query failed : ' . $ this -> getErrorMessage ( ) . ' (' . $ this -> toSql ( ) . ')' ) ; if ( constant ( 'STRAY_ENV' ) === 'development' ) { throw new AppException ( 'select query failed : ' . $ this -> getErrorMessage ( ) . ' (' . $ this -> toSql ( ) . ')' ) ; } } return $ result ; }
12011	private function addBlockSection ( ArrayNodeDefinition $ rootNode ) { $ rootNode -> fixXmlConfig ( 'block_theme' ) -> children ( ) -> arrayNode ( 'block_themes' ) -> prototype ( 'scalar' ) -> end ( ) -> example ( [ '@App/block.html.twig' ] ) -> end ( ) -> end ( ) ; }
2118	public function generateSqlForm ( ) { @ trigger_error ( 'Using the Installer::generateSqlForm() method has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; $ count = 0 ; $ return = '' ; $ sql_command = $ this -> compileCommands ( ) ; if ( empty ( $ sql_command ) ) { return '' ; } $ _SESSION [ 'sql_commands' ] = array ( ) ; $ arrOperations = array ( 'CREATE' => $ GLOBALS [ 'TL_LANG' ] [ 'tl_install' ] [ 'CREATE' ] , 'ALTER_ADD' => $ GLOBALS [ 'TL_LANG' ] [ 'tl_install' ] [ 'ALTER_ADD' ] , 'ALTER_CHANGE' => $ GLOBALS [ 'TL_LANG' ] [ 'tl_install' ] [ 'ALTER_CHANGE' ] , 'ALTER_DROP' => $ GLOBALS [ 'TL_LANG' ] [ 'tl_install' ] [ 'ALTER_DROP' ] , 'DROP' => $ GLOBALS [ 'TL_LANG' ] [ 'tl_install' ] [ 'DROP' ] ) ; foreach ( $ arrOperations as $ command => $ label ) { if ( \ is_array ( $ sql_command [ $ command ] ) ) { $ return .= ' <tr> <td colspan="2" class="tl_col_0">' . $ label . '</td> </tr>' ; $ return .= ' <tr> <td class="tl_col_1"><input type="checkbox" id="check_all_' . $ count . '" class="tl_checkbox" onclick="Backend.toggleCheckboxElements(this, \'' . strtolower ( $ command ) . '\')"></td> <td class="tl_col_2"><label for="check_all_' . $ count . '" style="color:#a6a6a6"><em>' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'selectAll' ] . '</em></label></td> </tr>' ; foreach ( $ sql_command [ $ command ] as $ vv ) { $ key = md5 ( $ vv ) ; $ _SESSION [ 'sql_commands' ] [ $ key ] = $ vv ; $ return .= ' <tr> <td class="tl_col_1"><input type="checkbox" name="sql[]" id="sql_' . $ count . '" class="tl_checkbox ' . strtolower ( $ command ) . '" value="' . $ key . '"' . ( ( stripos ( $ command , 'DROP' ) === false ) ? ' checked="checked"' : '' ) . '></td> <td class="tl_col_2"><pre><label for="sql_' . $ count ++ . '">' . $ vv . '</label></pre></td> </tr>' ; } } } return '<div id="sql_wrapper"> <table id="sql_table">' . $ return . ' </table></div>' ; }
11317	public function note ( string $ message ) : void { $ this -> logger -> log ( $ this -> level , strip_tags ( $ message ) ) ; }
9082	private static function parseRemoteHost ( Request & $ request , $ serverVars = array ( ) ) { if ( isset ( $ serverVars [ 'REMOTE_ADDR' ] ) ) { $ request -> remoteHost = $ serverVars [ 'REMOTE_ADDR' ] ; } if ( isset ( $ serverVars [ 'HTTP_X_FORWARDED_FOR' ] ) ) { $ request -> remoteHost = $ serverVars [ 'HTTP_X_FORWARDED_FOR' ] ; } }
10251	public function getFirstName ( $ gender = null ) { if ( empty ( $ gender ) ) { $ gender = $ this -> getGender ( ) ; } return FirstName :: where ( 'gender' , $ gender ) -> where ( 'rank' , '<=' , 250 ) -> orderByRaw ( Database :: random ( ) ) -> first ( ) -> name ; }
6872	private function initializeRelayPoint ( ShipmentInterface $ shipment ) { if ( null === $ method = $ shipment -> getMethod ( ) ) { if ( null !== $ shipment -> getRelayPoint ( ) ) { $ shipment -> setRelayPoint ( null ) ; } return ; } $ gateway = $ this -> registry -> getGateway ( $ method -> getGatewayName ( ) ) ; if ( ! $ gateway -> supports ( GatewayInterface :: CAPABILITY_RELAY ) ) { if ( null !== $ shipment -> getRelayPoint ( ) ) { $ shipment -> setRelayPoint ( null ) ; } return ; } if ( null !== $ relayPoint = $ shipment -> getSale ( ) -> getRelayPoint ( ) ) { $ shipment -> setRelayPoint ( $ relayPoint ) ; } }
5330	public function getEmojiPattern ( ) { if ( null === self :: $ emojiPattern ) { $ codeString = '' ; foreach ( $ this -> getEmojiCodeList ( ) as $ code ) { if ( is_array ( $ code ) ) { $ first = dechex ( array_shift ( $ code ) ) ; $ last = dechex ( array_pop ( $ code ) ) ; $ codeString .= '\x{' . $ first . '}-\x{' . $ last . '}' ; } else { $ codeString .= '\x{' . dechex ( $ code ) . '}' ; } } self :: $ emojiPattern = "/[$codeString]/u" ; } return self :: $ emojiPattern ; }
12017	public function calculateRequestFilename ( Request $ request ) { $ string = $ request -> getUri ( ) ; $ filename = parse_url ( $ string , PHP_URL_HOST ) ; $ filename .= '_' . parse_url ( $ string , PHP_URL_PATH ) ; $ headers = $ request -> getAllHeaders ( ) ; ksort ( $ headers ) ; foreach ( $ headers as $ header => $ values ) { $ string .= $ header ; foreach ( $ values as $ value ) { $ string .= $ value ; } } $ filename .= '_' . sha1 ( $ string ) ; if ( strpos ( $ filename , '_' ) === 0 ) { $ filename = substr ( $ filename , 1 ) ; } return $ this -> cacheDirectory . '/' . $ filename . '.cache' ; }
5706	public function shouldDisplay ( ) { return $ this -> gridFieldRequest -> record -> stagesDiffer ( 'Stage' , 'Live' ) && $ this -> gridFieldRequest -> recordIsPublished ( ) && $ this -> gridFieldRequest -> record -> canEdit ( ) ; }
6479	public function getClientIPAddress ( IHttpRequestMessage $ request ) : ? string { $ clientIPAddress = null ; $ request -> getProperties ( ) -> tryGet ( self :: CLIENT_IP_ADDRESS_PROPERTY , $ clientIPAddress ) ; return $ clientIPAddress ; }
9625	public function getById ( $ characterId ) { try { $ result = $ this -> client -> get ( $ this -> slug . '/' . $ characterId ) ; } catch ( RequestException $ e ) { $ return [ 'request' ] = $ e -> getRequest ( ) . "\n" ; if ( $ e -> hasResponse ( ) ) { return $ return [ 'response' ] = $ e -> getResponse ( ) . "\n" ; } } return $ result -> json ( ) ; }
8829	protected function option ( $ display , $ value , $ selected , array $ attributes = [ ] ) { $ selected = $ this -> getSelectedValue ( $ value , $ selected ) ; $ options = array_merge ( [ 'value' => $ value , 'selected' => $ selected ] , $ attributes ) ; return $ this -> toHtmlString ( '<option' . $ this -> html -> attributes ( $ options ) . '>' . e ( $ display ) . '</option>' ) ; }
481	public function addPrimaryKey ( $ name , $ table , $ columns ) { $ time = $ this -> beginCommand ( "add primary key $name on $table (" . ( is_array ( $ columns ) ? implode ( ',' , $ columns ) : $ columns ) . ')' ) ; $ this -> db -> createCommand ( ) -> addPrimaryKey ( $ name , $ table , $ columns ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
6540	public function load ( array $ identifier , $ propertyName , $ shardingKey = null ) { if ( isset ( $ identifier [ $ propertyName ] ) ) { return array ( $ propertyName => $ identifier [ $ propertyName ] ) ; } $ field = $ this -> getFieldNameFromProperty ( $ propertyName ) ; $ sources = $ this -> getSourcesFromPropertyName ( $ propertyName ) ; foreach ( $ sources as $ sourceName ) { $ source = $ this -> sourceManager -> getSource ( $ sourceName ) ; if ( $ source -> canHandle ( $ field ) ) { $ mappedIdentifiers = array ( ) ; foreach ( $ identifier as $ id => $ value ) { $ fieldName = $ this -> getFieldNameFromProperty ( $ id ) ; if ( $ source -> canHandle ( $ fieldName ) ) { $ mappedIdentifiers [ $ fieldName ] = $ value ; } } $ datas = $ source -> load ( $ mappedIdentifiers , false , $ shardingKey ) ; $ mappedDatas = $ this -> mapFieldsToProperties ( $ datas , $ sourceName ) ; return $ mappedDatas ; } } throw new \ Exception ( "No source support field $field from property $propertyName in {$this->name}" ) ; }
339	public function registerClientScript ( ) { $ id = $ this -> options [ 'id' ] ; $ options = Json :: htmlEncode ( $ this -> getClientOptions ( ) ) ; $ attributes = Json :: htmlEncode ( $ this -> attributes ) ; $ view = $ this -> getView ( ) ; ActiveFormAsset :: register ( $ view ) ; $ view -> registerJs ( "jQuery('#$id').yiiActiveForm($attributes, $options);" ) ; }
7316	public function setTimezone ( $ timezone ) { if ( is_string ( $ timezone ) ) { $ timezone = TimeZone :: parse ( $ timezone ) ; } else { if ( $ timezone instanceof TimeZone == false ) { throw new \ InvalidArgumentException ( ) ; } } $ jd = $ this -> toJD ( ) ; $ tzOffset = $ timezone -> offset ( $ jd ) - $ this -> timezone -> offset ( $ jd ) ; $ this -> add ( Time :: hours ( $ tzOffset ) ) ; $ this -> timezone = $ timezone ; $ this -> timezone0 = $ timezone ; return $ this ; }
6217	public static function thumbnailToId ( string $ thumbnailUrl ) : string { if ( 1 !== \ preg_match ( '/\/([\d]+)\/([\d]+)(\-avatar\.jpg)$/' , $ thumbnailUrl , $ match ) ) { throw new \ RuntimeException ( \ vsprintf ( 'Invalid thumbnail URL "%s"' , [ $ thumbnailUrl , ] ) ) ; } return ltrim ( $ match [ 1 ] . $ match [ 2 ] , '0' ) ; }
5563	protected function load ( $ url , $ parameters ) { $ frame = $ url -> getTarget ( ) ; if ( ! $ frame || ! $ this -> page -> hasFrames ( ) || ( strtolower ( $ frame ) == '_top' ) ) { return $ this -> loadPage ( $ url , $ parameters ) ; } return $ this -> loadFrame ( array ( $ frame ) , $ url , $ parameters ) ; }
12880	public function register ( ) { if ( ! $ this -> validate ( ) ) { return false ; } $ this -> user -> setAttributes ( [ 'email' => $ this -> email , 'username' => $ this -> username , 'password' => $ this -> password ] ) ; return $ this -> user -> register ( ) ; }
78	public function findPackage ( $ name , $ constraint ) { foreach ( $ this -> repositories as $ repository ) { if ( $ package = $ repository -> findPackage ( $ name , $ constraint ) ) { return $ package ; } } return null ; }
6538	public function init ( ) { Html :: addCssClass ( $ this -> options , [ 'panel' , 'sx-panel' , $ this -> color ] ) ; $ options = ArrayHelper :: merge ( $ this -> options , [ 'id' => $ this -> id , ] ) ; echo Html :: beginTag ( 'div' , $ options ) ; echo Html :: beginTag ( 'div' , $ this -> headingOptions ) ; echo <<<HTML <div class="pull-left"> <h2> {$this->name} </h2> </div> <div class="panel-actions panel-hidden-actions"> {$this->actions} </div>HTML ; echo Html :: endTag ( 'div' ) ; echo Html :: beginTag ( 'div' , $ this -> bodyOptions ) ; echo $ this -> content ; }
9468	public function map ( ) { $ this -> namespace ( 'System' ) -> prefix ( 'system' ) -> name ( 'system.' ) -> group ( function ( ) { $ this -> registerSystemInformationRoutes ( ) ; $ this -> registerLogViewerRoutes ( ) ; $ this -> registerRouteViewerRoutes ( ) ; } ) ; }
3883	public function getBackendIcon ( $ icon , $ defaultIcon = 'bundles/metamodelscore/images/icons/metamodels.png' ) { $ realIcon = $ this -> convertValueToPath ( $ icon , $ defaultIcon ) ; $ targetPath = $ this -> outputPath . '/' . basename ( $ realIcon ) ; if ( \ file_exists ( $ targetPath ) ) { return $ this -> webPath . '/' . basename ( $ realIcon ) ; } $ this -> imageFactory -> create ( $ realIcon , [ 16 , 16 , 'center_center' ] , $ targetPath ) ; return $ this -> webPath . '/' . basename ( $ realIcon ) ; }
3571	public function queryHook ( ) { return function ( $ next , $ query , $ bag ) { $ method = $ bag -> get ( 'method' ) ; $ args = $ bag -> get ( 'args' ) ; $ column = $ args -> get ( 'column' ) ; if ( ! $ this -> hasColumn ( $ column ) && $ this -> allowsMeta ( $ column ) && $ this -> isMetaQueryable ( $ method ) ) { return call_user_func_array ( [ $ this , 'metaQuery' ] , [ $ query , $ method , $ args ] ) ; } if ( in_array ( $ method , [ 'select' , 'addSelect' ] ) ) { call_user_func_array ( [ $ this , 'metaSelect' ] , [ $ query , $ args ] ) ; } return $ next ( $ query , $ bag ) ; } ; }
3331	public function fromResource ( $ fp ) { $ tmpfile = tempnam ( sys_get_temp_dir ( ) , 'ucr' ) ; $ temp = fopen ( $ tmpfile , 'w' ) ; while ( ! feof ( $ fp ) ) { fwrite ( $ temp , fread ( $ fp , 8192 ) ) ; } fclose ( $ temp ) ; fclose ( $ fp ) ; return $ this -> fromPath ( $ tmpfile ) ; }
8129	public function actionIndex ( ) { $ profile = Profile :: findOne ( [ 'uid' => Yii :: $ app -> user -> id ] ) ; if ( $ profile == NULL ) throw new NotFoundHttpException ; return $ this -> render ( 'index' , [ 'profile' => $ profile ] ) ; }
3761	private function getLegend ( PaletteInterface $ palette , $ legendName ) { if ( $ palette -> hasLegend ( $ legendName ) ) { return $ palette -> getLegend ( $ legendName ) ; } $ legend = new Legend ( $ legendName ) ; $ palette -> addLegend ( $ legend ) ; return $ legend ; }
3548	public function create ( $ request ) { $ model = $ this -> repository -> create ( $ request -> all ( ) ) ; $ model -> { $ this -> getShortRelationName ( ) } ( ) -> sync ( $ request -> get ( $ this -> getRelationName ( ) , [ ] ) ) ; $ event_class = "Acoustep\EntrustGui\Events\\" . ucwords ( $ this -> getModelName ( ) ) . 'CreatedEvent' ; $ event = new $ event_class ; $ this -> dispatcher -> fire ( $ event -> setModel ( $ model ) ) ; return $ model ; }
160	public function andHaving ( $ condition , $ params = [ ] ) { if ( $ this -> having === null ) { $ this -> having = $ condition ; } else { $ this -> having = [ 'and' , $ this -> having , $ condition ] ; } $ this -> addParams ( $ params ) ; return $ this ; }
8011	private static function setParityBit ( $ byte ) { $ parity = 1 ; for ( $ i = 1 ; $ i < 8 ; $ i ++ ) { $ parity = ( $ parity + ( ( $ byte >> $ i ) & 1 ) ) % 2 ; } $ byte = $ byte | ( $ parity & 1 ) ; return $ byte ; }
2977	public function unserialize ( $ serialized ) { $ this -> data = unserialize ( $ serialized ) ; $ this -> closure = __reconstruct_closure ( $ this -> data ) ; if ( ! $ this -> closure instanceof Closure ) { throw new ClosureUnserializationException ( 'The closure is corrupted and cannot be unserialized.' ) ; } if ( $ this -> data [ 'binding' ] || $ this -> data [ 'isStatic' ] ) { $ this -> closure = $ this -> closure -> bindTo ( $ this -> data [ 'binding' ] , $ this -> data [ 'scope' ] ) ; } }
7573	public function validateRequiredFields ( $ postVars ) { $ requiredFields = $ this -> getRequiredFields ( $ postVars [ 'id' ] ) ; $ missingKeys = array ( ) ; foreach ( $ requiredFields as $ human => $ keys ) { if ( ! $ this -> hasRequiredValue ( $ postVars , $ keys ) ) { $ missingKeys [ ] = $ human ; } } if ( ! empty ( $ missingKeys ) ) { throw new GreenhouseApplicationException ( 'Submission missing required answers for: ' . implode ( ', ' , $ missingKeys ) ) ; } return true ; }
8012	public static function forChallengeMessage ( $ challenge_message , $ code = 0 , Exception $ previous = null ) { $ message = self :: DEFAULT_MESSAGE ; $ reason_messages = [ ] ; if ( ( self :: CODE_FOR_INVALID_SIGNATURE & $ code ) === self :: CODE_FOR_INVALID_SIGNATURE ) { $ reason_messages [ ] = self :: MESSAGE_FOR_INVALID_SIGNATURE ; } if ( ( self :: CODE_FOR_INVALID_MESSAGE_TYPE & $ code ) === self :: CODE_FOR_INVALID_MESSAGE_TYPE ) { $ reason_messages [ ] = self :: MESSAGE_FOR_INVALID_MESSAGE_TYPE ; } $ message .= sprintf ( self :: MESSAGE_EXTENSION_FOR_REASONS_FORMAT , implode ( self :: MESSAGE_REASON_GLUE , $ reason_messages ) ) ; $ instance = new static ( $ message , $ code , $ previous ) ; $ instance -> challenge_message = $ challenge_message ; return $ instance ; }
12267	public function renderCmsBlock ( BaseBlock $ block , $ username , array $ options = array ( ) ) { $ blockTemplate = $ this -> fetchTemplateBlock ( $ block ) ; if ( $ blockTemplate == "" ) { return "" ; } $ permalinks = $ this -> pagesParser -> contributor ( $ username ) -> parse ( ) -> permalinksByLanguage ( ) ; $ options = array_merge ( array ( 'block' => $ block , 'permalinks' => $ permalinks , ) , $ options ) ; return $ this -> templating -> render ( $ blockTemplate , $ options ) ; }
2368	public static function extractEmail ( $ strString , $ strAllowedTags = '' ) { $ arrEmails = array ( ) ; if ( strpos ( $ strString , '@' ) === false ) { return $ arrEmails ; } preg_match_all ( '/mailto:(?:[^\x00-\x20\x22\x40\x7F]{1,64}+|\x22[^\x00-\x1F\x7F]{1,64}?\x22)@(?:\[(?:IPv)?[a-f0-9.:]{1,47}\]|[\w.-]{1,252}\.[a-z]{2,63}\b)/u' , $ strString , $ matches ) ; foreach ( $ matches [ 0 ] as & $ strEmail ) { $ strEmail = str_replace ( 'mailto:' , '' , $ strEmail ) ; if ( Validator :: isEmail ( $ strEmail ) ) { $ arrEmails [ ] = $ strEmail ; } } unset ( $ strEmail ) ; $ strString = preg_replace_callback ( '@</?([^\s<>/]*)@' , function ( $ matches ) use ( $ strAllowedTags ) { if ( $ matches [ 1 ] == '' || stripos ( $ strAllowedTags , '<' . strtolower ( $ matches [ 1 ] ) . '>' ) === false ) { $ matches [ 0 ] = str_replace ( '<' , '&lt;' , $ matches [ 0 ] ) ; } return $ matches [ 0 ] ; } , $ strString ) ; preg_match_all ( '/(?:[^\x00-\x20\x22\x40\x7F]{1,64}|\x22[^\x00-\x1F\x7F]{1,64}?\x22)@(?:\[(?:IPv)?[a-f0-9.:]{1,47}\]|[\w.-]{1,252}\.[a-z]{2,63}\b)/u' , strip_tags ( $ strString ) , $ matches ) ; foreach ( $ matches [ 0 ] as & $ strEmail ) { $ strEmail = str_replace ( '&lt;' , '<' , $ strEmail ) ; if ( Validator :: isEmail ( $ strEmail ) ) { $ arrEmails [ ] = $ strEmail ; } } return array_unique ( $ arrEmails ) ; }
10836	private function compileUsing ( array $ join ) { $ sql = array ( ) ; list ( $ using , $ table , $ type , $ column ) = $ join ; if ( $ type !== null ) { $ sql [ ] = $ type ; } array_push ( $ sql , "JOIN" , $ table , "USING({$column})" ) ; return join ( ' ' , $ sql ) ; }
529	public function actionPackage ( array $ what ) { $ this -> validateWhat ( $ what , [ 'app' ] ) ; $ versions = $ this -> getCurrentVersions ( $ what ) ; $ this -> stdout ( "You are about to generate packages for the following things:\n\n" ) ; foreach ( $ what as $ ext ) { if ( strncmp ( 'app-' , $ ext , 4 ) === 0 ) { $ this -> stdout ( ' - ' ) ; $ this -> stdout ( substr ( $ ext , 4 ) , Console :: FG_RED ) ; $ this -> stdout ( ' application version ' ) ; } elseif ( $ ext === 'framework' ) { $ this -> stdout ( ' - Yii Framework version ' ) ; } else { $ this -> stdout ( ' - ' ) ; $ this -> stdout ( $ ext , Console :: FG_RED ) ; $ this -> stdout ( ' extension version ' ) ; } $ this -> stdout ( $ versions [ $ ext ] , Console :: BOLD ) ; $ this -> stdout ( "\n" ) ; } $ this -> stdout ( "\n" ) ; $ packagePath = "{$this->basePath}/packages" ; $ this -> stdout ( "Packages will be stored in $packagePath\n\n" ) ; if ( ! $ this -> confirm ( 'Continue?' , false ) ) { $ this -> stdout ( "Canceled.\n" ) ; return 1 ; } foreach ( $ what as $ ext ) { if ( $ ext === 'framework' ) { throw new Exception ( 'Can not package framework.' ) ; } elseif ( strncmp ( 'app-' , $ ext , 4 ) === 0 ) { $ this -> packageApplication ( substr ( $ ext , 4 ) , $ versions [ $ ext ] , $ packagePath ) ; } else { throw new Exception ( 'Can not package extension.' ) ; } } $ this -> stdout ( "\ndone. verify the versions composer installed above and push it to github!\n\n" ) ; return 0 ; }
965	public function dispatchScripttags ( ) { $ scripttags = Config :: get ( 'shopify-app.scripttags' ) ; if ( count ( $ scripttags ) > 0 ) { ScripttagInstaller :: dispatch ( $ this -> shop , $ scripttags ) -> onQueue ( Config :: get ( 'shopify-app.job_queues.scripttags' ) ) ; } }
3403	protected function loadFromYml ( $ file ) { $ this -> parser = new Parser ( $ file ) ; $ this -> parser -> load ( $ this ) ; }
2154	public function getNewsletters ( $ objModule ) { $ objNewsletter = NewsletterChannelModel :: findAll ( ) ; if ( $ objNewsletter === null ) { return array ( ) ; } $ arrNewsletters = array ( ) ; if ( $ objModule === null || TL_MODE == 'BE' ) { while ( $ objNewsletter -> next ( ) ) { $ arrNewsletters [ $ objNewsletter -> id ] = $ objNewsletter -> title ; } } else { $ newsletters = StringUtil :: deserialize ( $ objModule -> newsletters , true ) ; if ( empty ( $ newsletters ) || ! \ is_array ( $ newsletters ) ) { return array ( ) ; } while ( $ objNewsletter -> next ( ) ) { if ( \ in_array ( $ objNewsletter -> id , $ newsletters ) ) { $ arrNewsletters [ $ objNewsletter -> id ] = $ objNewsletter -> title ; } } } natsort ( $ arrNewsletters ) ; return $ arrNewsletters ; }
9385	public function getGroupedIcons ( ) { if ( $ icons = self :: cache ( ) -> get ( $ this -> getCacheKey ( ) ) ) { return $ icons ; } $ icons = [ ] ; $ data = Yaml :: parse ( $ this -> getSourceData ( ) ) ; if ( isset ( $ data [ 'icons' ] ) ) { foreach ( $ data [ 'icons' ] as $ icon ) { foreach ( $ icon [ 'categories' ] as $ category ) { if ( ! isset ( $ icons [ $ category ] ) ) { $ icons [ $ category ] = [ ] ; } $ icons [ $ category ] [ $ icon [ 'id' ] ] = [ 'name' => $ icon [ 'name' ] , 'unicode' => $ icon [ 'unicode' ] ] ; } } } ksort ( $ icons ) ; foreach ( $ icons as & $ group ) { uasort ( $ group , function ( $ a , $ b ) { return strcasecmp ( $ a [ 'name' ] , $ b [ 'name' ] ) ; } ) ; } self :: cache ( ) -> set ( $ this -> getCacheKey ( ) , $ icons ) ; return $ icons ; }
3174	private function getTimeConstraint ( TestSession $ session , QtiComponent $ source , $ navigationMode ) { $ constraint = new QtiTimeConstraint ( $ source , $ session -> getTimerDuration ( $ source -> getIdentifier ( ) ) , $ navigationMode , true , true , $ session -> getTimerTarget ( ) ) ; $ constraint -> setTimer ( $ session -> getTimer ( ) ) ; return $ constraint ; }
1344	public function isReadResource ( ) : bool { return $ this -> isMethod ( 'get' ) && $ this -> getRoute ( ) -> isResource ( ) && $ this -> getRoute ( ) -> isNotRelationship ( ) ; }
6225	public function cd ( array $ path ) : void { array_unshift ( $ path , $ this -> path ) ; $ this -> path = new Path ( $ path ) ; }
10922	public function setRows ( array $ rows ) { foreach ( $ rows as $ row ) { $ columnNumber = 0 ; if ( ! is_array ( $ row ) ) { $ row = [ $ row ] ; } foreach ( $ row as $ column => $ value ) { $ this -> updateWidth ( $ columnNumber , $ this -> length ( $ column ) ) ; $ this -> updateWidth ( $ columnNumber , $ this -> length ( $ value ) ) ; if ( ! in_array ( $ column , $ this -> columns ) ) { $ this -> columns [ ] = $ column ; } $ columnNumber ++ ; } $ this -> rows [ ] = $ row ; } }
2384	public function onKernelException ( GetResponseForExceptionEvent $ event ) : void { $ exception = $ event -> getException ( ) ; if ( ! $ exception instanceof ResponseException ) { return ; } $ event -> allowCustomResponseCode ( ) ; $ event -> setResponse ( $ exception -> getResponse ( ) ) ; }
3106	public function getEvents ( ) { if ( isset ( $ this -> state [ self :: VAR_EVENTS_QUEUE ] ) ) { $ events = $ this -> state [ self :: VAR_EVENTS_QUEUE ] ; } else { $ events = [ ] ; } return $ events ; }
11439	public function getErrors ( $ echoable = false ) { if ( true === $ echoable ) { return join ( "\n<br />" , $ this -> errors ) ; } else { return $ this -> errors ; } }
3162	public function assertQtiRunnerServiceContext ( RunnerServiceContext $ context ) { if ( ! $ context instanceof QtiRunnerServiceContext ) { throw new \ common_exception_InvalidArgumentType ( __CLASS__ , __FUNCTION__ , 0 , QtiRunnerServiceContext :: class , $ context ) ; } }
1459	protected function whereId ( $ id , $ operator ) { if ( $ this -> isPagingOnKey ( ) ) { $ this -> query -> where ( $ this -> key , $ operator , $ id ) ; return $ this ; } $ value = $ this -> getColumnValue ( $ id ) ; $ this -> query -> where ( $ this -> column , $ operator . '=' , $ value ) -> where ( function ( $ query ) use ( $ id , $ value , $ operator ) { $ query -> where ( $ this -> column , $ operator , $ value ) -> orWhere ( $ this -> key , $ operator , $ id ) ; } ) ; return $ this ; }
832	private function fixParent ( Tokens $ tokens , $ classStart , $ classEnd ) { foreach ( $ tokens -> findGivenKind ( T_EXTENDS ) as $ index => $ token ) { $ parentIndex = $ tokens -> getNextMeaningfulToken ( $ index ) ; $ parentClass = $ tokens [ $ parentIndex ] -> getContent ( ) ; $ parentSeq = $ tokens -> findSequence ( [ [ T_STRING ] , [ T_DOUBLE_COLON ] , [ T_STRING , $ parentClass ] , '(' , ] , $ classStart , $ classEnd , [ 2 => false ] ) ; if ( null !== $ parentSeq ) { $ parentSeq = array_keys ( $ parentSeq ) ; if ( $ tokens [ $ parentSeq [ 0 ] ] -> equalsAny ( [ [ T_STRING , 'parent' ] , [ T_STRING , $ parentClass ] ] , false ) ) { $ tokens [ $ parentSeq [ 0 ] ] = new Token ( [ T_STRING , 'parent' ] ) ; $ tokens [ $ parentSeq [ 2 ] ] = new Token ( [ T_STRING , '__construct' ] ) ; } } $ parentSeq = $ tokens -> findSequence ( [ [ T_VARIABLE , '$this' ] , [ T_OBJECT_OPERATOR ] , [ T_STRING , $ parentClass ] , '(' , ] , $ classStart , $ classEnd , [ 2 => false ] ) ; if ( null !== $ parentSeq ) { $ parentSeq = array_keys ( $ parentSeq ) ; $ tokens [ $ parentSeq [ 0 ] ] = new Token ( [ T_STRING , 'parent' , ] ) ; $ tokens [ $ parentSeq [ 1 ] ] = new Token ( [ T_DOUBLE_COLON , '::' , ] ) ; $ tokens [ $ parentSeq [ 2 ] ] = new Token ( [ T_STRING , '__construct' ] ) ; } } }
9213	public function getOptionParser ( ) { $ parser = parent :: getOptionParser ( ) ; $ parser -> description ( 'Provides a mechanism for loading data into any of Cake\'s configured databases.' ) -> addSubcommand ( 'init' , [ 'help' => 'Initialize a new, empty seed file. Respects both the --dev and --file options.' , ] ) -> addOption ( 'dev' , [ 'short' => 'd' , 'boolean' => true , 'default' => false , 'help' => 'Use the "dev" seed file instead of the default.' ] ) -> addOption ( 'file' , [ 'short' => 'f' , 'help' => 'Manually specify the file that should be used. When this option is present, its argument will always be used explicitly, overriding the --dev option if it is also present.' ] ) ; return $ parser ; }
4416	public function onKernelResponse ( FilterResponseEvent $ event ) { $ routeName = $ event -> getRequest ( ) -> attributes -> get ( '_route' ) ; if ( $ routeName !== FallbackRouter :: ROUTE_NAME ) { return ; } $ response = $ event -> getResponse ( ) ; if ( ! $ response instanceof LegacyResponse ) { return ; } if ( ! $ this -> legacyMode && ( int ) $ response -> getStatusCode ( ) === Response :: HTTP_NOT_FOUND ) { $ moduleResult = $ response -> getModuleResult ( ) ; $ exception = new NotFoundHttpException ( isset ( $ moduleResult [ 'errorMessage' ] ) ? $ moduleResult [ 'errorMessage' ] : 'Not Found' ) ; $ exception -> setOriginalResponse ( $ response ) ; throw $ exception ; } }
158	public function andFilterCompare ( $ name , $ value , $ defaultOperator = '=' ) { if ( preg_match ( '/^(<>|>=|>|<=|<|=)/' , $ value , $ matches ) ) { $ operator = $ matches [ 1 ] ; $ value = substr ( $ value , strlen ( $ operator ) ) ; } else { $ operator = $ defaultOperator ; } return $ this -> andFilterWhere ( [ $ operator , $ name , $ value ] ) ; }
6932	private function isShipmentAmountInvoiced ( Invoice \ InvoiceInterface $ invoice ) { $ sale = $ invoice -> getSale ( ) ; foreach ( $ sale -> getInvoices ( ) as $ i ) { if ( $ i === $ invoice ) { continue ; } if ( $ i -> hasLineByType ( Document \ DocumentLineTypes :: TYPE_SHIPMENT ) ) { return true ; } } return false ; }
7977	public function deleteSecondaryDnsDomains ( $ domain2delete ) { json_decode ( self :: getClient ( ) -> deleteSecondaryDnsDomains ( $ this -> getDomain ( ) , $ domain2delete ) ) ; return true ; }
12787	public static function getPut ( ) { $ aPut = array ( ) ; $ rPutResource = fopen ( "php://input" , "r" ) ; while ( $ sData = fread ( $ rPutResource , 1024 ) ) { $ aSeparatePut = explode ( '&' , $ sData ) ; foreach ( $ aSeparatePut as $ sOne ) { $ aOnePut = explode ( '=' , $ sOne ) ; $ aPut [ $ aOnePut [ 0 ] ] = $ aOnePut [ 1 ] ; } } return $ aPut ; }
8732	public function challenge ( string $ hydroAddressId ) : ChallengeResponse { try { $ response = $ this -> callHydroApi ( 'post' , 'challenge' , [ 'json' => [ 'hydro_address_id' => $ hydroAddressId ] ] ) ; $ data = \ GuzzleHttp \ json_decode ( $ response -> getBody ( ) -> getContents ( ) , true , 512 , JSON_BIGINT_AS_STRING ) ; } catch ( RuntimeException $ e ) { throw ChallengeFailed :: forHydroAddressId ( $ hydroAddressId , $ e -> getMessage ( ) ) ; } catch ( InvalidArgumentException $ e ) { throw ChallengeFailed :: forHydroAddressId ( $ hydroAddressId , $ e -> getMessage ( ) ) ; } catch ( GuzzleException $ e ) { throw ChallengeFailed :: forHydroAddressId ( $ hydroAddressId , $ e -> getMessage ( ) ) ; } catch ( ApiRequestFailed $ e ) { throw ChallengeFailed :: forHydroAddressId ( $ hydroAddressId , $ e -> getMessage ( ) ) ; } return new ChallengeResponse ( $ data [ 'amount' ] , ( int ) $ data [ 'challenge' ] , ( int ) $ data [ 'partner_id' ] , $ data [ 'transaction_hash' ] ) ; }
8746	public function getListenerInstance ( EventDispatcher $ eventDispatcher = null , StreamableInterface $ stream = null ) { $ reflection = new \ ReflectionClass ( '\\Iber\\Phkey\\Environment\\' . $ this -> getEnvironment ( ) . '\\Matcher' ) ; $ matcher = $ reflection -> newInstance ( ) ; $ reflection = new \ ReflectionClass ( '\\Iber\\Phkey\\Environment\\' . $ this -> getEnvironment ( ) . '\\Listener' ) ; if ( null === $ eventDispatcher ) { $ eventDispatcher = new EventDispatcher ( ) ; } if ( null === $ stream ) { $ stream = new Stream ( ) ; } $ listener = $ reflection -> newInstance ( $ matcher , $ eventDispatcher , $ stream ) ; return $ listener ; }
564	public function renderSorter ( ) { $ sort = $ this -> dataProvider -> getSort ( ) ; if ( $ sort === false || empty ( $ sort -> attributes ) || $ this -> dataProvider -> getCount ( ) <= 0 ) { return '' ; } $ sorter = $ this -> sorter ; $ class = ArrayHelper :: remove ( $ sorter , 'class' , LinkSorter :: className ( ) ) ; $ sorter [ 'sort' ] = $ sort ; $ sorter [ 'view' ] = $ this -> getView ( ) ; return $ class :: widget ( $ sorter ) ; }
2269	public function lockTables ( $ arrTables ) { $ arrLocks = array ( ) ; foreach ( $ arrTables as $ table => $ mode ) { $ arrLocks [ ] = $ this -> resConnection -> quoteIdentifier ( $ table ) . ' ' . $ mode ; } $ this -> resConnection -> exec ( 'LOCK TABLES ' . implode ( ', ' , $ arrLocks ) . ';' ) ; }
12351	public function invalidate ( string $ api_session = null ) { if ( empty ( $ api_session ) === false && is_string ( $ api_session ) === true ) { $ session = Model \ Session :: where ( 'code' , $ api_session ) -> first ( ) ; if ( $ session !== null ) { $ session -> delete ( ) ; } } elseif ( empty ( $ _SESSION [ 'api_session' ] ) === false && is_string ( $ _SESSION [ 'api_session' ] ) === true ) { $ session = Model \ Session :: where ( 'code' , $ _SESSION [ 'api_session' ] ) -> first ( ) ; if ( $ session !== null ) { $ session -> delete ( ) ; } } elseif ( empty ( $ _GET [ 'api_session' ] ) === false && is_string ( $ _GET [ 'api_session' ] ) === true ) { $ session = Model \ Session :: where ( 'code' , $ _GET [ 'api_session' ] ) -> first ( ) ; if ( $ session !== null ) { $ session -> delete ( ) ; } } $ this -> details = false ; $ _SESSION [ 'api_session' ] = null ; $ _GET [ 'api_session' ] = null ; }
2442	protected function getUser ( ) : BackendUser { if ( null === $ this -> tokenStorage ) { throw new \ RuntimeException ( 'No token storage provided' ) ; } $ token = $ this -> tokenStorage -> getToken ( ) ; if ( null === $ token ) { throw new \ RuntimeException ( 'No token provided' ) ; } $ user = $ token -> getUser ( ) ; if ( ! $ user instanceof BackendUser ) { throw new \ RuntimeException ( 'The token does not contain a back end user object' ) ; } return $ user ; }
6152	public function run ( ) { if ( ! empty ( $ this -> _fields ) ) { throw new InvalidCallException ( 'Each beginField() should have a matching endField() call.' ) ; } $ id = $ this -> options [ 'id' ] ; $ options = Json :: encode ( $ this -> getClientOptions ( ) ) ; $ attributes = Json :: encode ( $ this -> attributes ) ; $ view = $ this -> getView ( ) ; AdminUiActiveForm :: register ( $ view ) ; $ view -> registerJs ( "jQuery('#$id').yiiActiveForm($attributes, $options);" ) ; echo Html :: endForm ( ) ; }
10600	public function returnUrl ( ) { $ return = '' ; $ return .= empty ( $ this -> _urlParts [ 'scheme' ] ) ? '' : $ this -> _urlParts [ 'scheme' ] . '://' ; $ return .= empty ( $ this -> _urlParts [ 'user' ] ) ? '' : $ this -> _urlParts [ 'user' ] ; $ return .= empty ( $ this -> _urlParts [ 'pass' ] ) || empty ( $ this -> _urlParts [ 'user' ] ) ? '' : ':' . $ this -> _urlParts [ 'pass' ] ; $ return .= empty ( $ this -> _urlParts [ 'user' ] ) ? '' : '@' ; $ return .= empty ( $ this -> _urlParts [ 'host' ] ) ? '' : $ this -> _urlParts [ 'host' ] ; $ return .= empty ( $ this -> _urlParts [ 'port' ] ) ? '' : ':' . $ this -> _urlParts [ 'port' ] ; $ return .= empty ( $ this -> _urlParts [ 'path' ] ) ? '' : '/' . ltrim ( $ this -> _urlParts [ 'path' ] , '/' ) ; $ return .= empty ( $ this -> _urlParts [ 'query' ] ) ? '' : '?' . $ this -> _urlParts [ 'query' ] ; $ return .= empty ( $ this -> _urlParts [ 'fragment' ] ) ? '' : '#' . $ this -> _urlParts [ 'fragment' ] ; return $ return ; }
12918	protected function findContentType ( $ spaceId , $ contentTypeName ) { $ contentTypes = $ this -> contentTypeRepo -> findNewestByName ( $ spaceId , $ contentTypeName ) ; if ( $ contentTypes -> isEmpty ( ) ) { throw new InvalidArgumentException ( sprintf ( 'Content type "%s" in space "%s" not found!' , $ contentTypeName , $ spaceId ) ) ; } if ( $ contentTypes -> count ( ) > 1 ) { throw new InvalidArgumentException ( sprintf ( 'Multiple content types with name "%s" found in space "%s"!' , $ contentTypeName , $ spaceId ) ) ; } $ contentType = $ contentTypes -> first ( ) ; return $ contentType ; }
3193	public function load ( ) { if ( ! $ this -> storage ) { throw new InvalidStorageException ( 'A storage must be defined in order to store the data!' ) ; } $ data = $ this -> storage -> load ( ) ; if ( isset ( $ data ) ) { if ( ! is_array ( $ data ) ) { $ data = [ self :: STORAGE_KEY_TIME_LINE => $ data , ] ; } if ( isset ( $ data [ self :: STORAGE_KEY_TIME_LINE ] ) ) { $ this -> timeLine = $ this -> unserializeTimeLine ( $ data [ self :: STORAGE_KEY_TIME_LINE ] ) ; } else { $ this -> timeLine = new QtiTimeLine ( ) ; } if ( isset ( $ data [ self :: STORAGE_KEY_EXTRA_TIME ] ) ) { $ this -> extraTime = $ data [ self :: STORAGE_KEY_EXTRA_TIME ] ; } else { $ this -> extraTime = 0 ; } if ( isset ( $ data [ self :: STORAGE_KEY_EXTENDED_TIME ] ) ) { $ this -> extendedTime = $ data [ self :: STORAGE_KEY_EXTENDED_TIME ] ; } else { $ this -> extendedTime = 0 ; } if ( isset ( $ data [ self :: STORAGE_KEY_CONSUMED_EXTRA_TIME ] ) ) { $ this -> consumedExtraTime = $ data [ self :: STORAGE_KEY_CONSUMED_EXTRA_TIME ] ; } else { $ this -> consumedExtraTime = 0 ; } if ( ! $ this -> timeLine instanceof TimeLine ) { throw new InvalidDataException ( 'The storage did not provide acceptable data when loading!' ) ; } } return $ this ; }
10700	public static function isMobilePhoneNumber ( $ phone ) { $ phoneNumber = substr ( Tools :: removeSpace ( $ phone ) , - 9 , 1 ) ; return ( ! self :: isCzechPhoneNumber ( $ phoneNumber ) || ( $ phoneNumber === '6' || $ phoneNumber === '7' ) ) ; }
7121	private function createFindBySubjectQueryBuilder ( ) { $ as = $ this -> getAlias ( ) ; $ qb = $ this -> createQueryBuilder ( ) ; return $ qb -> andWhere ( $ qb -> expr ( ) -> eq ( $ as . '.subjectIdentity.provider' , ':provider' ) ) -> andWhere ( $ qb -> expr ( ) -> eq ( $ as . '.subjectIdentity.identifier' , ':identifier' ) ) ; }
8218	protected function isAllowed ( $ limit , $ config ) { if ( $ limit [ "cnt" ] >= $ config [ "count" ] ) { if ( time ( ) > $ limit [ "ts" ] + $ config [ "blockDuration" ] ) { return true ; } else { return false ; } } else { return true ; } }
7850	protected function marshal ( ) { $ reflection = new ReflectionClass ( $ this -> command ) ; $ constructor = $ reflection -> getConstructor ( ) ; $ params = $ this -> getParamsToInject ( $ constructor -> getParameters ( ) ) ; return $ reflection -> newInstanceArgs ( $ params ) ; }
12715	protected function circularDependencyResolver ( $ class ) { if ( ! is_string ( $ class ) && ! class_exists ( $ class ) ) { throw Internal \ Exception \ ReflectionExceptionFactory :: invalidArgument ( sprintf ( "Parameter 1 of %s must be a string of valid class name." , __METHOD__ ) ) ; } $ reflector = Internal \ ReflectionClassFactory :: create ( $ class ) ; if ( ! $ this -> hasConstructor ( $ reflector ) ) { return $ this -> resolveInstanceWithoutConstructor ( $ reflector ) ; } else { $ param = $ this -> getMethodParameters ( $ reflector , '__construct' ) ; if ( empty ( $ param ) ) { return $ reflector -> newInstance ( ) ; } else { foreach ( $ param as $ key => $ value ) { $ class = $ value -> getClass ( ) ; if ( $ class instanceof \ ReflectionClass ) { if ( $ class -> isInterface ( ) ) { $ param [ $ key ] = $ this -> getConcreteFromInterface ( $ class -> getName ( ) ) ; } else { $ param [ $ key ] = $ this -> circularDependencyResolver ( $ class -> getName ( ) ) ; } } } return $ reflector -> newInstanceArgs ( $ param ) ; } } }
4911	protected function injectComponents ( array $ pages , $ routeMatch = null , $ router = null , $ request = null ) { if ( $ routeMatch ) { $ routeName = $ routeMatch -> getMatchedRouteName ( ) ; foreach ( $ pages as & $ page ) { if ( isset ( $ page [ 'active_on' ] ) && in_array ( $ routeName , ( array ) $ page [ 'active_on' ] ) ) { $ page [ 'active' ] = true ; } } } return parent :: injectComponents ( $ pages , $ routeMatch , $ router , $ request ) ; }
4580	public function encrypt ( Encryptable $ model ) : EncryptionService { if ( $ model -> getEncrypted ( ) ) { return $ this ; } $ properties = $ this -> getProperties ( $ model ) ; foreach ( $ properties as $ property ) { $ property -> setAccessible ( true ) ; $ property -> setValue ( $ model , $ this -> cipherService -> encrypt ( $ property -> getValue ( $ model ) ) ) ; } $ model -> setEncrypted ( true ) ; return $ this ; }
3664	private function getValueFromSource ( $ source , $ valueName , $ arguments ) { switch ( strtolower ( $ source ) ) { case 'get' : return $ this -> container -> get ( Input :: class ) -> get ( $ valueName ) ; case 'post' : return $ this -> container -> get ( Input :: class ) -> post ( $ valueName ) ; case 'cookie' : return $ this -> container -> get ( Input :: class ) -> cookie ( $ valueName ) ; case 'session' : return $ this -> container -> get ( Session :: class ) -> get ( $ valueName ) ; case 'filter' : if ( is_array ( $ this -> filterParameters ) ) { if ( array_key_exists ( $ valueName , $ this -> filterParameters ) ) { return $ this -> filterParameters [ $ valueName ] ; } return null ; } break ; case 'container' : @ trigger_error ( 'Getting filter values from the service container is deprecated, the container will get removed.' , E_USER_DEPRECATED ) ; return $ this -> getValueFromServiceContainer ( $ valueName , $ arguments ) ; default : } return null ; }
11183	public function getActions ( ) { if ( $ this -> useCache ( ) ) { if ( $ this -> getExtCache ( ) -> isCached ( ) ) { return $ this -> getExtCache ( ) -> getActions ( ) ; } } $ actions = $ this -> generateActions ( ) ; if ( $ this -> useCache ( ) ) { $ this -> getExtCache ( ) -> cacheActions ( $ actions ) ; } return $ actions ; }
4961	public function setForm ( $ form ) { if ( ! $ form instanceof FormInterface && ! $ form instanceof Container ) { throw new \ InvalidArgumentException ( 'Form must either implement \Zend\Form\FormInterface or extend from \Core\Form\Container' ) ; } $ this -> form = $ form ; return $ this ; }
955	public function retrieve ( ) { $ path = null ; switch ( $ this -> type ) { case self :: CHARGE_CREDIT : $ path = 'application_credits' ; break ; case self :: CHARGE_ONETIME : $ path = 'application_charges' ; break ; default : $ path = 'recurring_application_charges' ; break ; } return $ this -> shop -> api ( ) -> rest ( 'GET' , "/admin/{$path}/{$this->charge_id}.json" ) -> body -> { substr ( $ path , 0 , - 1 ) } ; }
7454	protected function getFirstTerm ( WP_Post $ post ) { $ taxonomies = $ this -> getTaxonomies ( $ post -> post_type ) ; foreach ( $ taxonomies as $ taxonomy ) { $ post_terms = \ get_the_terms ( $ post , $ taxonomy ) ; if ( ! $ post_terms || \ is_wp_error ( $ post_terms ) ) { continue ; } return $ post_terms [ 0 ] ; } }
7843	private function callIfExists ( $ method , array $ parameters = [ ] ) { if ( method_exists ( $ this , $ method ) ) { $ this -> container -> call ( [ $ this , $ method ] , $ parameters ) ; } }
3457	protected function replay ( Iterator $ historyEvents ) : void { foreach ( $ historyEvents as $ pastEvent ) { $ this -> version = $ pastEvent -> version ( ) ; $ this -> apply ( $ pastEvent ) ; } }
6951	private function getBaseQueryBuilder ( ) { $ qb = $ this -> getQueryBuilder ( 'r' , 'r.id' ) ; return $ qb -> andWhere ( $ qb -> expr ( ) -> orX ( $ qb -> expr ( ) -> isMemberOf ( ':country' , 'r.countries' ) , 'r.countries IS EMPTY' ) ) -> addOrderBy ( 'r.priority' , 'DESC' ) ; }
6406	protected function forceScriptCache ( $ fileName ) { if ( ( PHP_SAPI !== 'cli' && ini_get ( 'opcache.enable' ) ) || ini_get ( 'opcache.enable_cli' ) ) { opcache_invalidate ( $ fileName , true ) ; opcache_compile_file ( $ fileName ) ; } if ( ini_get ( 'apc.enabled' ) ) { apc_delete_file ( $ fileName ) ; apc_bin_loadfile ( $ fileName ) ; } }
6572	protected function registerCommands ( ) { $ this -> app [ 'command.countries.migration' ] = $ this -> app -> share ( function ( $ app ) { return new MigrationCommand ( $ app ) ; } ) ; $ this -> commands ( 'command.countries.migration' ) ; }
7902	protected function getFullFileName ( Provider $ provider ) { $ folder = $ this -> folder ? rtrim ( $ this -> folder , '/' ) . '/' : '' ; if ( $ this -> filename ) { $ filename = $ this -> filename ; } else { $ filename = md5 ( uniqid ( microtime ( true ) , true ) ) ; } return $ folder . $ filename . '.' . $ provider -> getExtension ( ) ; }
11840	public static function size ( $ inputImg ) { if ( is_string ( $ inputImg ) ) $ img = self :: imgCreate ( $ inputImg ) ; else $ img = $ inputImg ; $ imgW = imagesx ( $ img ) ; $ imgH = imagesy ( $ img ) ; if ( is_string ( $ inputImg ) ) imagedestroy ( $ img ) ; return array ( $ imgW , $ imgH ) ; }
11312	public static function buildAuthString ( array $ data ) { $ str = array ( ) ; foreach ( $ data as $ k => $ v ) { $ str [ ] = self :: urlEncode ( $ k ) . '="' . self :: urlEncode ( $ v ) . '"' ; } return implode ( ', ' , $ str ) ; }
9526	private function checkValidityAndContinueParse ( ) { $ valid = $ this -> validateRequiredParameters ( ) ; if ( $ valid !== true ) { $ this -> errorHandler -> call ( $ this , $ valid , 'Missing required argument: ' . $ valid -> parameterName ) ; $ this -> valid = false ; return [ ] ; } return $ this -> parseEvery ( ) ; }
8420	public function renderWidget ( $ config = [ ] ) { $ widgetHtml = $ this -> render ( $ this -> template , [ 'name' => $ this -> getModelName ( ) , 'attribute' => $ this -> attribute , 'label' => $ this -> label , 'texture' => $ this -> getTexture ( ) , 'disabled' => $ this -> disabled ] ) ; if ( $ this -> wrap ) { return Html :: tag ( $ this -> wrapper , $ widgetHtml , $ this -> options ) ; } return $ widgetHtml ; }
2299	public static function addFileMetaInformationToRequest ( $ strUuid , $ strPtable , $ intPid ) { @ trigger_error ( 'Using Backend::addFileMetaInformationToRequest() has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; $ objFile = FilesModel :: findByUuid ( $ strUuid ) ; if ( $ objFile === null ) { return ; } $ arrMeta = StringUtil :: deserialize ( $ objFile -> meta ) ; if ( empty ( $ arrMeta ) ) { return ; } $ objPage = null ; if ( $ strPtable == 'tl_article' ) { $ objPage = PageModel :: findOneBy ( array ( 'tl_page.id=(SELECT pid FROM tl_article WHERE id=?)' ) , $ intPid ) ; } else { if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'addFileMetaInformationToRequest' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'addFileMetaInformationToRequest' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'addFileMetaInformationToRequest' ] as $ callback ) { if ( ( $ val = System :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ strPtable , $ intPid ) ) !== false ) { $ objPage = $ val ; } } if ( $ objPage instanceof Result && $ objPage -> numRows < 1 ) { return ; } if ( \ is_object ( $ objPage ) && ! ( $ objPage instanceof PageModel ) ) { $ objPage = PageModel :: findByPk ( $ objPage -> id ) ; } } } if ( $ objPage === null ) { return ; } $ objPage -> loadDetails ( ) ; $ strLanguage = str_replace ( '-' , '_' , $ objPage -> rootLanguage ) ; if ( isset ( $ arrMeta [ $ strLanguage ] ) ) { if ( ! empty ( $ arrMeta [ $ strLanguage ] [ 'title' ] ) && Input :: post ( 'title' ) == '' ) { Input :: setPost ( 'title' , $ arrMeta [ $ strLanguage ] [ 'title' ] ) ; } if ( ! empty ( $ arrMeta [ $ strLanguage ] [ 'alt' ] ) && Input :: post ( 'alt' ) == '' ) { Input :: setPost ( 'alt' , $ arrMeta [ $ strLanguage ] [ 'alt' ] ) ; } if ( ! empty ( $ arrMeta [ $ strLanguage ] [ 'caption' ] ) && Input :: post ( 'caption' ) == '' ) { Input :: setPost ( 'caption' , $ arrMeta [ $ strLanguage ] [ 'caption' ] ) ; } } }
8262	protected function isValidCallback ( Request $ httpRequest ) { return $ this -> session -> has ( "provider" ) && $ httpRequest -> query -> has ( "state" ) && $ this -> session -> has ( "oauth2state" ) && is_string ( $ this -> session -> get ( "oauth2state" ) ) && ( strlen ( $ this -> session -> get ( "oauth2state" ) ) > 0 ) ; }
237	protected function setTableMetadata ( $ name , $ type , $ data ) { $ this -> _tableMetadata [ $ this -> getRawTableName ( $ name ) ] [ $ type ] = $ data ; }
5889	public function getViewer ( IViewer $ viewer ) { $ html = $ viewer -> fetchObject ( $ this ) ; $ iterator = new \ RecursiveIteratorIterator ( $ this , \ RecursiveIteratorIterator :: SELF_FIRST ) ; foreach ( $ iterator as $ node ) { $ siblings = array ( ) ; for ( $ level = 0 ; $ level < $ iterator -> getDepth ( ) ; $ level ++ ) { $ siblings [ ] = ( $ iterator -> getSubIterator ( $ level ) -> hasNext ( ) ) ? 1 : 0 ; } $ siblings [ ] = ( ! $ iterator -> getSubIterator ( $ level ) -> hasNext ( ) ) ? 1 : 0 ; $ html .= $ viewer -> fetchObject ( $ node , $ siblings ) ; } return $ html ; }
12761	protected function checkBrowsers ( ) { return ( $ this -> checkBrowserWebTv ( ) || $ this -> checkBrowserInternetExplorer ( ) || $ this -> checkBrowserOpera ( ) || $ this -> checkBrowserGaleon ( ) || $ this -> checkBrowserNetscapeNavigator9Plus ( ) || $ this -> checkBrowserFirefox ( ) || $ this -> checkBrowserChrome ( ) || $ this -> checkBrowserOmniWeb ( ) || $ this -> checkBrowserAndroid ( ) || $ this -> checkBrowseriPad ( ) || $ this -> checkBrowseriPod ( ) || $ this -> checkBrowseriPhone ( ) || $ this -> checkBrowserBlackBerry ( ) || $ this -> checkBrowserNokia ( ) || $ this -> checkBrowserGoogleBot ( ) || $ this -> checkBrowserMSNBot ( ) || $ this -> checkBrowserBingBot ( ) || $ this -> checkBrowserSlurp ( ) || $ this -> checkFacebookExternalHit ( ) || $ this -> checkBrowserSafari ( ) || $ this -> checkBrowserNetPositive ( ) || $ this -> checkBrowserFirebird ( ) || $ this -> checkBrowserKonqueror ( ) || $ this -> checkBrowserIcab ( ) || $ this -> checkBrowserPhoenix ( ) || $ this -> checkBrowserAmaya ( ) || $ this -> checkBrowserLynx ( ) || $ this -> checkBrowserShiretoko ( ) || $ this -> checkBrowserIceCat ( ) || $ this -> checkBrowserIceweasel ( ) || $ this -> checkBrowserW3CValidator ( ) || $ this -> checkBrowserMozilla ( ) ) ; }
1721	private function getStringRepresentation ( array $ chunks , $ value ) : string { switch ( \ count ( $ chunks ) ) { case 2 : return sprintf ( "\$GLOBALS['TL_LANG']['%s'][%s] = %s;\n" , $ chunks [ 0 ] , $ this -> quoteKey ( $ chunks [ 1 ] ) , $ this -> quoteValue ( $ value ) ) ; case 3 : return sprintf ( "\$GLOBALS['TL_LANG']['%s'][%s][%s] = %s;\n" , $ chunks [ 0 ] , $ this -> quoteKey ( $ chunks [ 1 ] ) , $ this -> quoteKey ( $ chunks [ 2 ] ) , $ this -> quoteValue ( $ value ) ) ; case 4 : return sprintf ( "\$GLOBALS['TL_LANG']['%s'][%s][%s][%s] = %s;\n" , $ chunks [ 0 ] , $ this -> quoteKey ( $ chunks [ 1 ] ) , $ this -> quoteKey ( $ chunks [ 2 ] ) , $ this -> quoteKey ( $ chunks [ 3 ] ) , $ this -> quoteValue ( $ value ) ) ; } throw new \ OutOfBoundsException ( 'Cannot load less than 2 or more than 4 levels in XLIFF language files.' ) ; }
3397	public function urlDecodeUnreservedChars ( $ string ) { $ string = rawurldecode ( $ string ) ; $ string = rawurlencode ( $ string ) ; $ string = str_replace ( array ( '%2F' , '%3A' , '%40' ) , array ( '/' , ':' , '@' ) , $ string ) ; return $ string ; }
2749	public function getVclFile ( $ vclTemplatePath ) { $ moduleEtcPath = $ this -> reader -> getModuleDir ( Dir :: MODULE_ETC_DIR , 'Fastly_Cdn' ) ; $ configFilePath = $ moduleEtcPath . '/' . $ this -> _scopeConfig -> getValue ( self :: FASTLY_CONFIGURATION_PATH ) ; $ directoryRead = $ this -> readFactory -> create ( $ moduleEtcPath ) ; $ configFilePath = $ directoryRead -> getRelativePath ( $ configFilePath ) ; $ data = $ directoryRead -> readFile ( $ configFilePath ) ; return strtr ( $ data , $ this -> getReplacements ( ) ) ; }
3484	public function withThreadId ( string $ threadId ) : Aps { $ cloned = clone $ this ; $ cloned -> threadId = $ threadId ; return $ cloned ; }
1664	protected function getCountries ( ) { if ( sizeof ( $ this -> countries ) == 0 ) { $ this -> countries = json_decode ( file_get_contents ( __DIR__ . '/Models/countries.json' ) , true ) ; } return $ this -> countries ; }
8490	public static function getUpTime ( ) { $ wmi = Windows :: getInstance ( ) ; $ booted_str = '' ; foreach ( $ wmi -> ExecQuery ( "SELECT LastBootUpTime FROM Win32_OperatingSystem" ) as $ os ) { $ booted_str = $ os -> LastBootUpTime ; } $ booted = [ 'year' => substr ( $ booted_str , 0 , 4 ) , 'month' => substr ( $ booted_str , 4 , 2 ) , 'day' => substr ( $ booted_str , 6 , 2 ) , 'hour' => substr ( $ booted_str , 8 , 2 ) , 'minute' => substr ( $ booted_str , 10 , 2 ) , 'second' => substr ( $ booted_str , 12 , 2 ) ] ; $ booted_ts = mktime ( $ booted [ 'hour' ] , $ booted [ 'minute' ] , $ booted [ 'second' ] , $ booted [ 'month' ] , $ booted [ 'day' ] , $ booted [ 'year' ] ) ; return date ( 'm/d/y h:i A (T)' , $ booted_ts ) ; }
4744	public function isReviewOptInError ( ) { $ formSent = \ OxidEsales \ Eshop \ Core \ Registry :: getConfig ( ) -> getRequestParameter ( 'rvw_oegdproptin' ) !== null ; $ review = oxNew ( \ OxidEsales \ Eshop \ Application \ Controller \ ReviewController :: class ) ; $ result = false ; if ( $ formSent && ! $ review -> validateOptIn ( ) ) { $ result = true ; } return $ result ; }
8878	private function safeSendSignal ( $ process , string $ signal , int $ mappedSignal ) : void { if ( true !== proc_terminate ( $ process , $ mappedSignal ) ) { throw new CommandExecutionException ( 'Call to proc_terminate with signal "' . $ signal . '" failed for unknown reason.' ) ; } }
10426	private function body ( ResponseInterface $ response ) : ResponseInterface { if ( ! in_array ( $ response -> getStatusCode ( ) , $ this -> responseIsEmpty ) ) { $ stream = $ response -> getBody ( ) ; if ( $ stream -> isSeekable ( ) ) { $ stream -> rewind ( ) ; } $ bufferLenght = ( ! $ response -> getHeaderLine ( 'Content-Length' ) ) ? $ stream -> getSize ( ) : $ response -> getHeaderLine ( 'Content-Length' ) ; if ( isset ( $ bufferLenght ) ) { $ lengthToRead = $ bufferLenght ; while ( $ lengthToRead > 0 && ! $ stream -> eof ( ) ) { $ data = $ stream -> read ( min ( $ this -> sizeLimit , $ lengthToRead ) ) ; echo $ data ; $ lengthToRead -= strlen ( $ data ) ; } } else { while ( ! $ stream -> eof ( ) ) { echo $ stream -> read ( $ this -> size ) ; } } } return $ response ; }
4442	public function completed ( int $ offset = 0 , int $ count = 25 ) { return $ this -> client -> jobs ( 'complete' , null , $ offset , $ count ) ; }
6007	public static function fromHex ( $ hex ) { if ( strlen ( $ hex ) != 2 ) { throw new Ts3Exception ( "given parameter '" . $ hex . "' is not a valid hexadecimal number" ) ; } return new self ( chr ( hexdec ( $ hex ) ) ) ; }
4338	private function removeHideIfEmptyGroups ( & $ log ) { $ groupStack = array ( ) ; $ groupStackCount = 0 ; $ removed = false ; for ( $ i = 0 , $ count = \ count ( $ log ) ; $ i < $ count ; $ i ++ ) { $ method = $ log [ $ i ] [ 0 ] ; if ( \ in_array ( $ method , array ( 'group' , 'groupCollapsed' ) ) ) { $ entry = $ log [ $ i ] ; $ groupStack [ ] = array ( 'i' => $ i , 'meta' => ! empty ( $ entry [ 2 ] ) ? $ entry [ 2 ] : array ( ) , 'hasEntries' => false , ) ; $ groupStackCount ++ ; } elseif ( $ method == 'groupEnd' ) { $ group = \ end ( $ groupStack ) ; if ( ! $ group [ 'hasEntries' ] && ! empty ( $ group [ 'meta' ] [ 'hideIfEmpty' ] ) ) { unset ( $ log [ $ group [ 'i' ] ] ) ; unset ( $ log [ $ i ] ) ; $ removed = true ; } \ array_pop ( $ groupStack ) ; $ groupStackCount -- ; } elseif ( $ groupStack ) { $ groupStack [ $ groupStackCount - 1 ] [ 'hasEntries' ] = true ; } } if ( $ removed ) { $ log = \ array_values ( $ log ) ; } }
1515	public function delete ( StoreInterface $ store , DeleteResource $ request ) { $ result = $ this -> transaction ( function ( ) use ( $ store , $ request ) { return $ this -> doDelete ( $ store , $ request ) ; } ) ; if ( $ this -> isResponse ( $ result ) ) { return $ result ; } return $ this -> reply ( ) -> deleted ( $ result ) ; }
3515	public function getLocale ( ) { if ( ! $ this -> cookiesLoaded ) { $ key = $ this -> cookiePrefix . 'lang_locale' ; $ queuedCookieLocale = \ Cookie :: queued ( $ key , null ) ; $ locale = getSupportedLocale ( $ queuedCookieLocale != null ? $ queuedCookieLocale -> getValue ( ) : \ Cookie :: get ( $ key , '' ) ) ; parent :: setLocale ( $ locale ) ; $ this -> getShowUnpublished ( ) ; $ this -> cookiesLoaded = true ; } return parent :: getLocale ( ) ; }
1089	protected function getStub ( $ name ) { if ( stripos ( $ name , '.php' ) === FALSE ) $ name = $ name . '.php' ; return $ this -> files -> get ( $ this -> getStubPath ( ) . '/' . $ name ) ; }
5649	public function assign ( $ key , $ value ) { if ( $ this -> $ key === false ) { $ this -> all [ $ key ] = $ value ; } elseif ( ! is_array ( $ this -> $ key ) ) { $ this -> all [ $ key ] = array ( $ this -> $ key , $ value ) ; } else { $ this -> all [ $ key ] [ ] = $ value ; } }
9175	public function fromRoute ( $ route = null , $ params = [ ] , $ options = [ ] , $ reuseMatchedParams = false ) { $ controller = $ this -> getController ( ) ; if ( ! $ controller || ! method_exists ( $ controller , 'plugin' ) ) { throw new Exception \ DomainException ( 'Redirect plugin requires a controller that defines the plugin() method' ) ; } $ referer = $ controller -> getRequest ( ) -> getHeader ( 'Referer' ) ; if ( $ referer ) { $ refererUrl = $ referer -> uri ( ) -> getPath ( ) ; $ refererHost = $ referer -> uri ( ) -> getHost ( ) ; $ host = $ controller -> getRequest ( ) -> getUri ( ) -> getHost ( ) ; if ( $ refererUrl && ( $ refererHost == $ host ) ) { return $ refererUrl ; } } $ urlPlugin = $ controller -> plugin ( 'url' ) ; return $ urlPlugin -> fromRoute ( $ route , $ params , $ options , $ reuseMatchedParams ) ; }
12961	public function getDb ( ) { if ( is_null ( $ this -> db ) ) { if ( $ this -> getAccessType ( ) == 'mysqli' && function_exists ( 'mysqli_select_db' ) ) { $ this -> db = new Db \ Mysqli ( ) ; } else { if ( $ this -> getAccessType ( ) == 'pdo' && class_exists ( 'PDO' ) ) { $ this -> db = new Db \ Pdo ( ) ; } } if ( is_null ( $ this -> db ) ) { if ( class_exists ( 'PDO' ) ) { $ this -> db = new Db \ Pdo ( ) ; } elseif ( function_exists ( 'mysqli_select_db' ) ) { $ this -> db = new Db \ Mysqli ( ) ; } else { throw new DbException ( 'Database engine not available! Must be either PDO or mysqli' ) ; } } $ this -> db -> setCredentials ( $ this -> credentials ) ; } return $ this -> db ; }
8055	public static function get ( $ length = 8 , $ outputFormat = Code :: FORMAT_ALNUM ) { static :: throwUnlessAcceptable ( $ outputFormat , $ length ) ; $ number = rand ( 100 , 900 ) . str_replace ( '.' , '' , microtime ( true ) ) ; $ output = self :: convertBase ( $ number , self :: FORMAT_NUMBER , $ outputFormat ) ; if ( strlen ( $ output ) < $ length ) { $ output .= substr ( str_shuffle ( $ outputFormat . $ outputFormat ) , 0 , ( $ length - strlen ( $ output ) ) ) ; } if ( strlen ( $ output ) > $ length ) { $ output = substr ( $ output , 0 , $ length ) ; } return $ output ; }
7358	private function loadPriceMap ( ) { if ( null === $ this -> pricesMap ) { $ this -> pricesMap = $ this -> getPricesMapLoader ( ) -> load ( $ this -> currency ) ; } }
7372	public function updateAction ( Request $ request ) { $ user = $ this -> getUser ( ) ; $ form = $ this -> createForm ( ProfileType :: class , $ user ) ; $ form -> bind ( $ request ) ; if ( $ form -> isValid ( ) ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; try { $ em -> persist ( $ user ) ; $ em -> flush ( ) ; $ this -> get ( 'session' ) -> getFlashBag ( ) -> set ( 'success' , 'Your changes have been saved.' ) ; return new JsonReloadResponse ( ) ; } catch ( \ Exception $ e ) { $ form -> addError ( new FormError ( 'Could not save changes. If the problem persists, please contact support.' ) ) ; } } return new JsonErrorResponse ( $ form ) ; }
8365	public function createPostTimelineEntry ( EntityPublishedEvent $ event ) : void { $ post = $ event -> getObject ( ) ; if ( ! $ post instanceof Post ) { return ; } $ author = $ this -> user_provider -> loadUserByUsername ( $ post -> getAuthor ( ) ) ; $ post_component = $ this -> action_manager -> findOrCreateComponent ( $ post ) ; $ author_component = $ this -> action_manager -> findOrCreateComponent ( $ author ) ; foreach ( $ post -> getGroups ( ) as $ group ) { $ group_component = $ this -> action_manager -> findOrCreateComponent ( $ group ) ; if ( null === $ post -> getParent ( ) ) { $ verb = 'post' ; } else { $ verb = 'reply' ; } $ action = $ this -> action_manager -> create ( $ author_component , $ verb , [ 'directComplement' => $ post_component , 'indirectComplement' => $ group_component , ] ) ; $ this -> action_manager -> updateAction ( $ action ) ; } }
3966	public function getInputScreen ( ) { return new InputScreen ( \ System :: getContainer ( ) -> get ( 'cca.legacy_dic' ) -> getService ( 'metamodels-service-container' ) , $ this -> inputScreen [ 'meta' ] , $ this -> inputScreen [ 'properties' ] , $ this -> inputScreen [ 'conditions' ] , $ this -> inputScreen [ 'groupSort' ] ) ; }
3245	public function onCharge ( $ order ) { $ this -> statusCode = 'pending' ; $ this -> detail = 'pending response, token:' . $ this -> token ; return parent :: onCharge ( $ order ) ; }
6761	public function find ( $ criteria ) { if ( ! $ criteria ) { error_log ( "collection error: no criteria specified" ) ; return null ; } else if ( is_callable ( $ criteria ) ) { foreach ( $ this -> models as $ model ) if ( $ criteria ( $ model ) ) return $ model ; } else if ( is_a ( $ criteria , "SnooPHP\Model\Model" ) ) { foreach ( $ this -> models as $ i => $ model ) if ( $ model == $ criteria ) return $ i ; } return null ; }
9186	protected function mergeParams ( & $ data , $ params ) { foreach ( $ params as $ paramName => $ paramValue ) { if ( is_array ( $ paramValue ) ) { foreach ( $ paramValue as $ key => $ value ) { foreach ( $ value as $ name => $ x ) { $ data [ $ paramName ] [ $ key ] [ $ name ] = $ x ; } } } else { $ data [ $ paramName ] = $ paramValue ; } } }
11725	public function assign ( string $ key , $ value , bool $ global = false ) { if ( $ global === false ) { $ this -> vars [ $ key ] = $ value ; } else { View :: $ global_vars [ $ key ] = $ value ; } return $ this ; }
7385	public function uploadAction ( ) { if ( $ this -> request -> hasFiles ( ) == true ) { $ this -> initializeScaffolding ( ) ; $ form = $ this -> scaffolding -> getForm ( ) ; $ name = key ( $ _FILES ) ; $ uploadElement = $ form -> get ( $ name ) ; $ model = $ uploadElement -> getModel ( ) ; $ path = $ uploadElement -> getPath ( ) ; $ maxFileSize = $ uploadElement -> getMaxFileSize ( ) ; $ minFileSize = $ uploadElement -> getMinFileSize ( ) ; foreach ( $ this -> request -> getUploadedFiles ( ) as $ file ) { $ fileName = $ file -> getName ( ) ; $ fileSize = $ file -> getSize ( ) ; $ fileType = $ file -> getRealType ( ) ; $ fileExtensions = pathinfo ( $ fileName , PATHINFO_EXTENSION ) ; $ allowed = $ uploadElement -> getAllowedExtensions ( ) ; if ( ! empty ( $ allowed ) ) { if ( ! in_array ( $ fileExtensions , $ allowed ) ) { throw new ForbiddenFileExtensionException ( ) ; } } $ forbidden = $ uploadElement -> getForbiddenExtensions ( ) ; if ( ! empty ( $ forbidden ) ) { if ( in_array ( $ fileExtensions , $ forbidden ) ) { throw new ForbiddenFileExtensionException ( ) ; } } $ allowedMime = $ uploadElement -> getAllowedMimeTypes ( ) ; if ( ! empty ( $ allowedMime ) ) { if ( ! in_array ( $ fileType , $ allowedMime ) ) { throw new ForbiddenFileMimeTypeException ( ) ; } } $ forbiddenMime = $ uploadElement -> getForbiddenMimeTypes ( ) ; if ( ! empty ( $ forbiddenMime ) ) { if ( in_array ( $ fileType , $ forbiddenMime ) ) { throw new ForbiddenFileMimeTypeException ( ) ; } } if ( ! empty ( $ maxFileSize ) ) { if ( $ fileSize > $ this -> convertFileSizeToBytes ( $ maxFileSize ) ) { throw new \ Exception ( 's' ) ; } } if ( ! empty ( $ minFileSize ) ) { if ( $ fileSize < $ this -> convertFileSizeToBytes ( $ minFileSize ) ) { throw new \ Exception ( 's' ) ; } } if ( empty ( $ path ) ) { $ path = 'files/' ; } $ model -> name = $ fileName ; $ model -> mime_type = $ fileType ; $ model -> path = $ path ; $ model -> save ( ) ; $ file -> moveTo ( $ path . $ model -> _id ) ; return $ this -> response -> setJsonContent ( ( string ) $ model -> _id ) ; } } $ this -> view -> setRenderLevel ( View :: LEVEL_NO_RENDER ) ; }
7292	public function get_users_by_meta ( $ meta_key , $ meta_value = '' , $ meta_compare = '' , $ include_empty = FALSE ) { if ( $ include_empty ) { if ( in_array ( $ meta_compare , array ( '<>' , '!=' ) ) ) { $ meta_compare = '=' ; } else { $ meta_compare = '!=' ; } $ query = new WP_User_Query ( array ( 'meta_key' => $ meta_key , 'meta_value' => $ meta_value , 'meta_compare' => $ meta_compare , 'fields' => 'ID' ) ) ; $ exclude_users = $ query -> get_results ( ) ; $ query = new WP_User_Query ( array ( 'fields' => 'all_with_meta' , 'exclude' => $ exclude_users ) ) ; return $ query -> get_results ( ) ; } $ query = new WP_User_Query ( array ( 'meta_key' => $ meta_key , 'meta_value' => $ meta_value , 'meta_compare' => $ meta_compare , 'fields' => 'all_with_meta' ) ) ; return $ query -> get_results ( ) ; }
5810	public function updateSearchableFields ( & $ fields ) { $ fields = array_merge ( array ( 'Tagging' => array ( 'title' => 'Tags' , 'field' => ListboxField :: create ( 'Tagging' , 'Tags' , FusionTag :: get ( ) -> map ( 'Title' , 'Title' ) -> toArray ( ) , ( Controller :: has_curr ( ) && ( $ filtering = Controller :: curr ( ) -> getRequest ( ) -> getVar ( 'q' ) ) && isset ( $ filtering [ 'Tagging' ] ) ) ? $ filtering [ 'Tagging' ] : array ( ) , null , true ) , 'filter' => $ this -> owner -> dbObject ( 'Tagging' ) -> stat ( 'default_search_filter_class' ) ) ) , $ fields ) ; $ this -> owner -> extend ( 'updateTaggingExtensionSearchableFields' , $ fields ) ; }
994	private function getDescription ( $ node ) { if ( $ node -> description ) { return $ node -> description -> value ; } if ( isset ( $ this -> options [ 'commentDescriptions' ] ) ) { $ rawValue = $ this -> getLeadingCommentBlock ( $ node ) ; if ( $ rawValue !== null ) { return BlockString :: value ( "\n" . $ rawValue ) ; } } return null ; }
623	protected function createModels ( $ rows ) { if ( $ this -> asArray ) { return $ rows ; } else { $ models = [ ] ; $ class = $ this -> modelClass ; foreach ( $ rows as $ row ) { $ model = $ class :: instantiate ( $ row ) ; $ modelClass = get_class ( $ model ) ; $ modelClass :: populateRecord ( $ model , $ row ) ; $ models [ ] = $ model ; } return $ models ; } }
5506	public function returnsAt ( $ timing , $ method , $ value , $ args = false ) { $ this -> dieOnNoMethod ( $ method , 'set return value sequence' ) ; $ this -> actions -> registerAt ( $ timing , $ method , $ args , new SimpleReturn ( $ value ) ) ; }
1695	public function checkStyleSheetName ( $ strName ) { $ objStyleSheet = $ this -> Database -> prepare ( "SELECT COUNT(*) AS count FROM tl_style_sheet WHERE name=?" ) -> limit ( 1 ) -> execute ( $ strName ) ; if ( $ objStyleSheet -> count < 1 ) { return $ strName ; } $ chunks = explode ( '-' , $ strName ) ; $ i = ( \ count ( $ chunks ) > 1 ) ? array_pop ( $ chunks ) : 0 ; $ strName = implode ( '-' , $ chunks ) . '-' . ( ( int ) $ i + 1 ) ; return $ this -> checkStyleSheetName ( $ strName ) ; }
8086	private function cleanConsole ( ) { $ channel = $ this -> namespaceChannel ( $ this -> currentChannel ) ; if ( empty ( $ this -> console [ 'errors' ] [ $ channel ] ) ) { unset ( $ this -> console [ 'errors' ] [ $ channel ] ) ; } if ( empty ( $ this -> console [ 'form' ] [ $ channel ] ) ) { unset ( $ this -> console [ 'form' ] [ $ channel ] ) ; } if ( empty ( $ this -> console [ 'reports' ] [ $ channel ] ) ) { unset ( $ this -> console [ 'reports' ] [ $ channel ] ) ; } }
6839	public function get ( $ key ) { if ( isset ( $ this -> objects [ $ key ] ) ) { return $ this -> objects [ $ key ] ; } throw new InjectorException ( "obj $key not found" ) ; }
3039	public function has ( $ userId , $ callId ) { $ key = $ this -> getCacheKey ( $ userId , $ callId ) ; if ( ! isset ( $ this -> cache [ $ key ] ) ) { return $ this -> getStorage ( ) -> has ( $ userId , $ callId ) ; } return $ this -> exists ( $ key ) ; }
8846	public function getBlogPosts ( ) { $ blogPosts = BlogPost :: get ( ) -> filter ( "ParentID" , $ this -> ID ) ; $ this -> extend ( 'updateGetBlogPosts' , $ blogPosts ) ; return $ blogPosts ; }
10320	function getUnsubscribers ( $ fromDate = null , $ toDate = null , $ mailingIds = null , $ contactIds = null , $ contactEmails = null , $ contactExternalIds = null , $ source = null , $ embedFieldBackups = false , $ pageIndex = 1 , $ pageSize = 100 ) { $ params = $ this -> createQueryParameters ( $ pageIndex , $ pageSize , $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , $ mailingIds , $ source , $ embedFieldBackups ) ; return $ this -> get ( 'reports/unsubscriptions' , $ params ) ; }
5559	protected function findFormInFrame ( $ page , $ index , $ method , $ attribute ) { $ form = $ this -> frames [ $ index ] -> $ method ( $ attribute ) ; if ( isset ( $ form ) ) { $ form -> setDefaultTarget ( $ this -> getPublicNameFromIndex ( $ index ) ) ; } return $ form ; }
7948	public function getPppLoginByMail ( $ id ) { if ( ! $ id ) throw new BadMethodCallException ( 'Missing parameter $id.' ) ; try { $ this -> post ( 'xdsl/' . $ id . '/requestPPPLoginMail' ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new XdslException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return ; }
8404	public static function registerApp ( string $ namespace , string $ path = null ) { $ namespace = rtrim ( $ namespace , '\\' ) ; if ( $ path == null ) { $ path = constant ( 'STRAY_PATH_APPS' ) . str_replace ( '_' , DIRECTORY_SEPARATOR , str_replace ( '\\' , DIRECTORY_SEPARATOR , $ namespace ) ) ; } self :: $ namespaces [ $ namespace ] = $ path ; self :: $ applications [ ] = $ namespace ; }
6671	public function restart_rating ( $ post_id , $ post , $ update ) { App :: setCurrentID ( 'EFG' ) ; if ( Module :: CustomRatingGrifus ( ) -> getOption ( 'restart-when-add' ) ) { unset ( $ _POST [ 'imdbRating' ] , $ _POST [ 'imdbVotes' ] ) ; if ( App :: main ( ) -> is_after_insert_post ( $ post , $ update ) ) { if ( ! $ this -> model -> get_movie_votes ( $ post_id ) ) { $ votes = $ this -> get_default_votes ( $ post_id ) ; $ this -> set_rating_and_votes ( $ post_id , $ votes ) ; return true ; } } } return false ; }
3326	public function render ( OptionCollection $ options ) { $ lines = array ( ) ; foreach ( $ options as $ option ) { $ c1 = $ this -> renderOption ( $ option ) ; $ lines [ ] = "\t" . $ c1 ; $ lines [ ] = wordwrap ( "\t\t" . $ option -> desc , $ this -> screenWidth , "\n\t\t" ) ; $ lines [ ] = '' ; } return implode ( "\n" , $ lines ) ; }
8106	protected function getEmailBody ( $ config , $ variables ) { $ template = SSViewer :: fromString ( $ config -> ReviewBody ) ; $ value = $ template -> process ( ArrayData :: create ( $ variables ) ) ; return DBField :: create_field ( 'HTMLText' , ( string ) $ value ) ; }
1171	protected function getProtected ( $ instance , $ property ) { $ closure = function ( $ property ) { return $ this -> $ property ; } ; $ callback = $ closure -> bindTo ( $ instance , $ instance ) ; return $ callback ( $ property ) ; }
10509	public function attach ( \ SplObserver $ observer , $ eventName = Null , $ function = Null , $ order = Null ) { $ newEventAttach = new \ stdClass ( ) ; $ newEventAttach -> observer = $ observer ; $ newEventAttach -> function = $ function ; $ newEventAttach -> eventName = $ eventName ; $ newEventAttach -> order = $ order ; $ this -> _observers -> attach ( $ newEventAttach ) ; }
1010	private function readName ( $ line , $ col , Token $ prev ) { $ value = '' ; $ start = $ this -> position ; [ $ char , $ code ] = $ this -> readChar ( ) ; while ( $ code && ( $ code === 95 || $ code >= 48 && $ code <= 57 || $ code >= 65 && $ code <= 90 || $ code >= 97 && $ code <= 122 ) ) { $ value .= $ char ; [ $ char , $ code ] = $ this -> moveStringCursor ( 1 , 1 ) -> readChar ( ) ; } return new Token ( Token :: NAME , $ start , $ this -> position , $ line , $ col , $ prev , $ value ) ; }
11892	public function newAction ( Request $ request ) { $ entity = new CustomField ( ) ; $ cfGroupId = $ request -> query -> get ( 'customFieldsGroup' , null ) ; if ( $ cfGroupId !== null ) { $ cfGroup = $ this -> getDoctrine ( ) -> getManager ( ) -> getRepository ( 'ChillCustomFieldsBundle:CustomFieldsGroup' ) -> find ( $ cfGroupId ) ; if ( ! $ cfGroup ) { throw $ this -> createNotFoundException ( 'CustomFieldsGroup with id ' . $ cfGroupId . ' is not found !' ) ; } $ entity -> setCustomFieldsGroup ( $ cfGroup ) ; } $ form = $ this -> createCreateForm ( $ entity , $ request -> query -> get ( 'type' ) ) ; return $ this -> render ( 'ChillCustomFieldsBundle:CustomField:new.html.twig' , array ( 'entity' => $ entity , 'form' => $ form -> createView ( ) , ) ) ; }
6290	public function get ( $ theme = null ) { if ( is_null ( $ theme ) ) { return $ this -> themes [ $ this -> activeTheme ] ; } return $ this -> themes [ $ theme ] ; }
2371	public static function splitCsv ( $ strString , $ strDelimiter = ',' ) { $ arrValues = preg_split ( '/' . $ strDelimiter . '(?=(?:[^"]*"[^"]*")*(?![^"]*"))/' , $ strString ) ; foreach ( $ arrValues as $ k => $ v ) { $ arrValues [ $ k ] = trim ( $ v , ' "' ) ; } return $ arrValues ; }
489	protected function findTableConstraints ( $ table , $ type ) { $ keyColumnUsageTableName = 'INFORMATION_SCHEMA.KEY_COLUMN_USAGE' ; $ tableConstraintsTableName = 'INFORMATION_SCHEMA.TABLE_CONSTRAINTS' ; if ( $ table -> catalogName !== null ) { $ keyColumnUsageTableName = $ table -> catalogName . '.' . $ keyColumnUsageTableName ; $ tableConstraintsTableName = $ table -> catalogName . '.' . $ tableConstraintsTableName ; } $ keyColumnUsageTableName = $ this -> quoteTableName ( $ keyColumnUsageTableName ) ; $ tableConstraintsTableName = $ this -> quoteTableName ( $ tableConstraintsTableName ) ; $ sql = <<<SQLSELECT [kcu].[constraint_name] AS [index_name], [kcu].[column_name] AS [field_name]FROM {$keyColumnUsageTableName} AS [kcu]LEFT JOIN {$tableConstraintsTableName} AS [tc] ON [kcu].[table_schema] = [tc].[table_schema] AND [kcu].[table_name] = [tc].[table_name] AND [kcu].[constraint_name] = [tc].[constraint_name]WHERE [tc].[constraint_type] = :type AND [kcu].[table_name] = :tableName AND [kcu].[table_schema] = :schemaNameSQL ; return $ this -> db -> createCommand ( $ sql , [ ':tableName' => $ table -> name , ':schemaName' => $ table -> schemaName , ':type' => $ type , ] ) -> queryAll ( ) ; }
12201	public function mediaAction ( Request $ request , Application $ app ) { $ options = array ( "connector" => $ app [ "red_kite_cms.elfinder_media_connector" ] , ) ; return parent :: show ( $ options ) ; }
12013	protected function instantiateCompiler ( string & $ className , & $ description ) : CompilerInterface { if ( is_array ( $ description ) ) { $ class = $ description [ self :: COMPILER_CLASS_KEY ] ?? $ className ; if ( ! isset ( $ description [ self :: COMPILER_ID_KEY ] ) ) $ description [ self :: COMPILER_ID_KEY ] = $ className ; $ id = $ description [ self :: COMPILER_ID_KEY ] ; if ( $ args = $ description [ self :: COMPILER_ARGUMENTS_KEY ] ?? NULL ) { return new $ class ( $ id , ... array_values ( $ args ) ) ; } else { return new $ class ( $ id , $ description ) ; } } else { $ instance = new $ description ( $ className ) ; $ description = [ self :: COMPILER_ID_KEY => $ className ] ; return $ instance ; } }
1220	private function validateSeq ( $ from , array $ types , $ a , $ b ) { $ ta = Utils :: type ( $ a ) ; $ tb = Utils :: type ( $ b ) ; if ( $ ta !== $ tb ) { $ msg = "encountered a type mismatch in sequence: {$ta}, {$tb}" ; $ this -> typeError ( $ from , $ msg ) ; } $ typeMatch = ( $ types && $ types [ 0 ] == 'any' ) || in_array ( $ ta , $ types ) ; if ( ! $ typeMatch ) { $ msg = 'encountered a type error in sequence. The argument must be ' . 'an array of ' . implode ( '|' , $ types ) . ' types. ' . "Found {$ta}, {$tb}." ; $ this -> typeError ( $ from , $ msg ) ; } }
2779	public function git ( string $ commandLine , ? string $ cwd = null ) : string { $ command = new GitCommand ( $ commandLine ) ; $ command -> executeRaw ( is_string ( $ commandLine ) ) ; $ command -> setDirectory ( $ cwd ) ; return $ this -> run ( $ command ) ; }
1256	public static function search ( $ expression , $ data ) { static $ runtime ; if ( ! $ runtime ) { $ runtime = Env :: createRuntime ( ) ; } return $ runtime ( $ expression , $ data ) ; }
2128	public function endblock ( ) { if ( empty ( $ this -> arrBlockNames ) ) { throw new \ Exception ( 'You must start a block before you can end it' ) ; } $ name = array_pop ( $ this -> arrBlockNames ) ; if ( $ this -> strParent === null ) { if ( $ this -> arrBlocks [ $ name ] != '[[TL_PARENT]]' ) { if ( strpos ( $ this -> arrBlocks [ $ name ] , '[[TL_PARENT]]' ) !== false ) { list ( , $ content ) = explode ( '[[TL_PARENT]]' , $ this -> arrBlocks [ $ name ] , 2 ) ; echo $ content ; } else { ob_end_clean ( ) ; -- $ this -> intBufferLevel ; } } } else { $ this -> arrBlocks [ $ name ] [ ] = ob_get_clean ( ) ; ob_start ( ) ; } }
4873	public function init ( ) { $ this -> setName ( 'buttons' ) ; if ( ! isset ( $ this -> options [ 'render_summary' ] ) ) { $ this -> options [ 'render_summary' ] = false ; } $ this -> setAttribute ( 'class' , 'text-right' ) ; $ this -> add ( array ( 'type' => 'Core/Spinner-Submit' , 'name' => 'submit' , 'options' => array ( 'label' => 'Save' , ) , 'attributes' => array ( 'id' => 'submit' , 'type' => 'submit' , 'value' => 'Save' , 'class' => 'sf-submit btn btn-primary btn-xs' ) , ) ) ; $ this -> add ( array ( 'type' => 'Button' , 'name' => 'cancel' , 'options' => array ( 'label' => 'Cancel' , ) , 'attributes' => array ( 'id' => 'cancel' , 'type' => 'reset' , 'value' => 'Cancel' , 'class' => 'sf-cancel btn btn-default btn-xs' ) , ) ) ; }
2462	public function generateMarkup ( ) { $ intMaxSize = round ( static :: getMaxUploadSize ( ) / 1024 / 1024 ) ; $ strAccepted = implode ( ',' , array_map ( function ( $ a ) { return '.' . $ a ; } , StringUtil :: trimsplit ( ',' , strtolower ( Config :: get ( 'uploadTypes' ) ) ) ) ) ; $ GLOBALS [ 'TL_CSS' ] [ ] = 'assets/dropzone/css/dropzone.min.css' ; $ GLOBALS [ 'TL_JAVASCRIPT' ] [ ] = 'assets/dropzone/js/dropzone.min.js' ; $ return = ' <input type="hidden" name="action" value="fileupload"> <div class="fallback"> <input type="file" name="' . $ this -> strName . '[]" class="tl_upload_field" onfocus="Backend.getScrollOffset()" multiple> </div> <div class="dropzone"> <div class="dz-default dz-message"> <span>' . $ GLOBALS [ 'TL_LANG' ] [ 'tl_files' ] [ 'dropzone' ] . '</span> </div> <span class="dropzone-previews"></span> </div> <script> Dropzone.autoDiscover = false; window.addEvent("domready", function() { new Dropzone("#tl_files", { paramName: "' . $ this -> strName . '", maxFilesize: ' . $ intMaxSize . ', acceptedFiles: "' . $ strAccepted . '", timeout: 0, previewsContainer: ".dropzone-previews", clickable: ".dropzone", dictFileTooBig: ' . json_encode ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_files' ] [ 'dropzoneFileTooBig' ] ) . ', dictInvalidFileType: ' . json_encode ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_files' ] [ 'dropzoneInvalidType' ] ) . ' }).on("addedfile", function() { $$(".dz-message").setStyle("display", "none"); }).on("success", function(file, message) { if (!message) return; var container = $("tl_message"); if (!container) { container = new Element("div", { "id": "tl_message", "class": "tl_message" }).inject($("tl_buttons"), "before"); } container.appendHTML(message); }); $$("div.tl_formbody_submit").setStyle("display", "none"); }); </script>' ; if ( isset ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_files' ] [ 'fileupload' ] [ 1 ] ) ) { $ return .= ' <p class="tl_help tl_tip">' . sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_files' ] [ 'fileupload' ] [ 1 ] , System :: getReadableSize ( static :: getMaxUploadSize ( ) ) , Config :: get ( 'gdMaxImgWidth' ) . 'x' . Config :: get ( 'gdMaxImgHeight' ) ) . '</p>' ; } return $ return ; }
12750	public function getUserAlias4User ( UserInterface $ user ) { if ( ! isset ( $ this -> userAliasCache [ $ user -> getUsername ( ) ] ) ) { $ userAliasEntityTmp = $ this -> getUserAliasEntity4User ( $ user ) ; if ( ! $ userAliasEntityTmp ) { $ userAliasEntityTmp = false ; } $ this -> userAliasCache [ $ user -> getUsername ( ) ] = $ userAliasEntityTmp ; } $ userAliasEntity = $ this -> userAliasCache [ $ user -> getUsername ( ) ] ; if ( $ userAliasEntity ) { $ result = $ userAliasEntity -> getCharName ( ) ; } else { $ result = $ user -> getUsername ( ) ; } return $ result ; }
2704	public function getContentTypeOptions ( ) { $ contentTypes = [ self :: CONTENT_TYPE_HTML => __ ( 'HTML' ) , self :: CONTENT_TYPE_CSS => __ ( 'CSS' ) , self :: CONTENT_TYPE_JS => __ ( 'JavaScript' ) , self :: CONTENT_TYPE_IMAGE => __ ( 'Images' ) ] ; return $ contentTypes ; }
61	public function isDirEmpty ( $ dir ) { $ finder = Finder :: create ( ) -> ignoreVCS ( false ) -> ignoreDotFiles ( false ) -> depth ( 0 ) -> in ( $ dir ) ; return count ( $ finder ) === 0 ; }
8252	protected function logInvalidLoginAttempt ( $ name ) { $ max = $ this -> config [ "registration" ] [ "nameLenMax" ] ; if ( strlen ( $ name ) > $ max ) { $ max = substr ( $ name , 0 , $ max ) . " (trimmed)" ; } $ this -> getLogger ( ) -> notice ( "Invalid login attempt for {name} by {addr}" , array ( "name" => $ name , "addr" => $ _SERVER [ 'REMOTE_ADDR' ] , ) ) ; }
518	private function generateClassName ( $ name ) { $ namespace = null ; $ name = trim ( $ name , '\\' ) ; if ( strpos ( $ name , '\\' ) !== false ) { $ namespace = substr ( $ name , 0 , strrpos ( $ name , '\\' ) ) ; $ name = substr ( $ name , strrpos ( $ name , '\\' ) + 1 ) ; } else { if ( $ this -> migrationPath === null ) { $ migrationNamespaces = $ this -> migrationNamespaces ; $ namespace = array_shift ( $ migrationNamespaces ) ; } } if ( $ namespace === null ) { $ class = 'm' . gmdate ( 'ymd_His' ) . '_' . $ name ; } else { $ class = 'M' . gmdate ( 'ymdHis' ) . ucfirst ( $ name ) ; } return [ $ namespace , $ class ] ; }
6578	public function parse ( $ url ) { $ parts = $ this -> _parse_url ( $ url ) ; foreach ( array ( 'user' , 'pass' , 'fragment' ) as $ part ) if ( isset ( $ parts [ $ part ] ) ) $ parts [ $ part ] = urldecode ( $ parts [ $ part ] ) ; if ( isset ( $ parts [ 'host' ] ) ) $ parts [ 'host' ] = idn_to_utf8 ( $ parts [ 'host' ] ) ; if ( isset ( $ parts [ 'path' ] ) ) $ parts [ 'path' ] = rawurldecode ( str_ireplace ( '%2F' , '%252F' , $ parts [ 'path' ] ) ) ; return $ this -> setParts ( $ parts ) ; }
3239	private function resetCalculations ( ) { $ this -> shopCalculations = null ; if ( Config :: get ( 'shop.cache_calculations' ) ) { Cache :: forget ( $ this -> calculationsCacheKey ) ; } }
4989	public function enableForm ( $ key = null ) { if ( null === $ key ) { $ this -> activeForms = array_keys ( $ this -> forms ) ; return $ this ; } if ( ! is_array ( $ key ) ) { $ key = array ( $ key ) ; } foreach ( $ key as $ k ) { if ( false !== strpos ( $ k , '.' ) ) { list ( $ childKey , $ childForm ) = explode ( '.' , $ k , 2 ) ; $ child = $ this -> getForm ( $ childKey ) ; $ child -> enableForm ( $ childForm ) ; } else { if ( isset ( $ this -> forms [ $ k ] ) && ! in_array ( $ k , $ this -> activeForms ) ) { $ this -> activeForms [ ] = $ k ; } } } return $ this ; }
4986	public function executeAction ( $ name , array $ data = [ ] ) { if ( false !== strpos ( $ name , '.' ) ) { list ( $ name , $ childKey ) = explode ( '.' , $ name , 2 ) ; $ container = $ this -> getForm ( $ name ) ; return $ container -> executeAction ( $ childKey , $ data ) ; } return [ ] ; }
2904	public function send ( $ email , $ name = null , array $ variables = array ( ) ) { $ zendMail = $ this -> getMail ( ) ; $ result = $ this -> parentSend ( $ email , $ name , $ variables ) ; try { $ this -> addEmailToProfile ( $ email , $ name , $ variables , $ result , $ zendMail ) ; } catch ( Exception $ e ) { Mage :: logException ( $ e ) ; } return $ result ; }
6316	public function setDeleteAction ( $ deleteAction ) { $ deleteAction = strtoupper ( $ deleteAction ) ; if ( ! in_array ( $ deleteAction , $ this -> getAvailableActions ( ) ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Action %s does not exist.' , $ deleteAction ) ) ; } $ this -> deleteAction = $ deleteAction ; }
6077	public function uploadNewVersionChunked ( $ fileData , $ id , $ revisionComment , $ name , $ chunk , $ chunks , $ fileId ) { $ parameters = [ 'query' => [ 'revisionComment' => $ revisionComment , 'name' => $ name , 'chunk' => $ chunk , 'chunks' => $ chunks , 'fileId' => $ fileId , ] , 'multipart' => [ [ 'name' => 'file' , 'contents' => \ GuzzleHttp \ Psr7 \ stream_for ( $ fileData ) , 'filename' => $ name , ] , ] , 'headers' => null , ] ; $ result = $ this -> post ( 'v1/media.json/' . $ id . '/version' , $ parameters ) ; return $ result ; }
12413	public function addDevice ( $ groupId , array $ deviceIdentifiers ) { $ params = [ 'group_id' => intval ( $ groupId ) , 'device_identifiers' => $ deviceIdentifiers , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_ADD_DEVICE , $ params ] ) ; }
5750	public function setRoles ( ) { $ this -> roles = [ ] ; if ( null !== $ records = $ this -> select ( ) ) { foreach ( $ records as $ record ) { $ this -> roles [ ( int ) $ record [ 'id' ] ] = $ record [ 'role' ] ; } } }
7173	protected function resolveCustomerTargetCountry ( CustomerInterface $ customer ) : ? CountryInterface { if ( null !== $ address = $ customer -> getDefaultDeliveryAddress ( ) ) { return $ address -> getCountry ( ) ; } return null ; }
5133	public static function create ( string $ string = '' ) : \ One \ Uri { if ( empty ( $ string ) ) { $ string = '/' ; } return self :: createFromString ( $ string ) ; }
9199	public function getAccessToken ( $ oauthToken , $ oauthVerifier ) { $ oauth = new Oauth1 ( array ( 'consumer_key' => $ this -> credentials -> getConsumerKey ( ) , 'consumer_secret' => $ this -> credentials -> getConsumerSecret ( ) , 'token' => $ oauthToken , 'verifier' => $ oauthVerifier ) ) ; $ this -> guzzleClient -> getEmitter ( ) -> attach ( $ oauth ) ; $ accessTokenResponse = $ this -> guzzleClient -> post ( Config :: get ( 'oauth_access_token' ) , array ( 'auth' => 'oauth' ) ) ; $ response = array ( ) ; parse_str ( $ accessTokenResponse -> getBody ( ) , $ response ) ; $ this -> credentials -> setAccessToken ( $ response [ 'oauth_token' ] ) -> setAccessTokenSecret ( $ response [ 'oauth_token_secret' ] ) ; return $ response ; }
12469	protected function replaceNamespace ( $ path ) { $ search = [ 'namespace ' . $ this -> currentRoot . ';' , $ this -> currentRoot . '\\' ] ; $ replace = [ 'namespace ' . $ this -> argument ( 'name' ) . ';' , $ this -> argument ( 'name' ) . '\\' ] ; $ this -> replaceIn ( $ path , $ search , $ replace ) ; }
4748	public function getPlan ( string $ planCode ) : array { $ cacheKey = sprintf ( 'plan_%s' , $ planCode ) ; $ hit = $ this -> getFromCache ( $ cacheKey ) ; if ( false === $ hit ) { $ response = $ this -> sendRequest ( 'GET' , sprintf ( 'plans/%s' , $ planCode ) ) ; $ data = $ this -> processResponse ( $ response ) ; $ plan = $ data [ 'plan' ] ; $ this -> saveToCache ( $ cacheKey , $ plan ) ; return $ plan ; } return $ hit ; }
7698	function MsPowerpoint_SlideIsIt ( $ FileName ) { $ this -> MsPowerpoint_InitSlideLst ( ) ; foreach ( $ this -> OpenXmlSlideLst as $ i => $ s ) { if ( $ FileName == $ s [ 'file' ] ) return true ; } return false ; }
970	public function setDomain ( string $ shopDomain ) { $ this -> fixLifetime ( ) ; Session :: put ( self :: DOMAIN , $ shopDomain ) ; }
8068	public function connect ( ) { $ port = $ this -> ssl ? $ this :: PORT_SSL : $ this :: PORT ; $ hostname = $ this -> domainController -> getHostname ( ) ; return $ this -> connection = ldap_connect ( $ hostname , $ port ) ; }
1280	public function extractEnvironmentId ( array $ data ) : string { if ( isset ( $ data [ 'sys' ] [ 'type' ] ) && 'Space' === $ data [ 'sys' ] [ 'type' ] ) { return $ this -> environmentId ; } if ( isset ( $ data [ 'sys' ] [ 'type' ] ) && 'Environment' === $ data [ 'sys' ] [ 'type' ] ) { return $ data [ 'sys' ] [ 'id' ] ; } if ( isset ( $ data [ 'sys' ] [ 'environment' ] ) ) { return $ data [ 'sys' ] [ 'environment' ] [ 'sys' ] [ 'id' ] ; } if ( isset ( $ data [ 'items' ] [ 0 ] [ 'sys' ] [ 'environment' ] ) ) { return $ data [ 'items' ] [ 0 ] [ 'sys' ] [ 'environment' ] [ 'sys' ] [ 'id' ] ; } if ( isset ( $ data [ 'items' ] ) && ! $ data [ 'items' ] ) { return $ this -> environmentId ; } return 'master' ; }
11137	protected function calculateDELETE ( ) { $ this -> query .= 'DELETE FROM ' ; $ this -> queryStringFromArray ( 'tables' , '' , ', ' ) ; $ this -> conditionStringFromArray ( 'wheres' , ' WHERE ' , ' AND ' ) ; $ this -> queryStringFromArray ( 'orderBys' , ' ORDER BY ' , ', ' , false ) ; if ( $ this -> limit ) { $ this -> query .= ' LIMIT ' . $ this -> limit ; } }
11287	protected function _getCustomValue ( $ attributeName , $ query , $ loadMap = false ) { $ def = $ this -> model_attributes [ $ attributeName ] ; $ result = $ this -> _getRelation ( $ attributeName , $ query , $ loadMap ) ; if ( ! $ result ) { $ result = $ query -> fetch ( ) ; } return $ result ; }
5792	private function setConstraints ( ) { $ q = new QueryBuilder ( "SELECT ccu.column_name, tc.constraint_type FROM INFORMATION_SCHEMA.constraint_column_usage ccu JOIN information_schema.table_constraints tc ON ccu.constraint_name = tc.constraint_name WHERE tc.table_name = ccu.table_name AND ccu.table_name = $1" , $ this -> tableName ) ; $ qResult = $ q -> execute ( ) ; while ( $ qRow = pg_fetch_assoc ( $ qResult ) ) { switch ( $ qRow [ 'constraint_type' ] ) { case 'PRIMARY KEY' : $ this -> primaryKeyColumnName = $ qRow [ 'column_name' ] ; break ; case 'UNIQUE' : $ this -> uniqueColumnNames [ ] = $ qRow [ 'column_name' ] ; } } }
543	public function init ( ) { parent :: init ( ) ; if ( $ this -> logFile === null ) { $ this -> logFile = Yii :: $ app -> getRuntimePath ( ) . '/logs/app.log' ; } else { $ this -> logFile = Yii :: getAlias ( $ this -> logFile ) ; } if ( $ this -> maxLogFiles < 1 ) { $ this -> maxLogFiles = 1 ; } if ( $ this -> maxFileSize < 1 ) { $ this -> maxFileSize = 1 ; } }
3113	public function setStoreId ( $ testSessionId , $ storeId ) { $ extendedState = $ this -> getExtendedState ( $ testSessionId ) ; $ extendedState -> setStoreId ( $ storeId ) ; $ extendedState -> save ( ) ; }
5234	public function withEntry ( $ key , $ value ) { $ this -> bindings [ $ key ] = $ this -> getValueCreator ( $ value ) ; return $ this ; }
1304	public function show ( $ category , $ slug = null ) { if ( ! isset ( $ category ) || ! isset ( $ slug ) ) { return redirect ( config ( 'chatter.routes.home' ) ) ; } $ discussion = Models :: discussion ( ) -> where ( 'slug' , '=' , $ slug ) -> first ( ) ; if ( is_null ( $ discussion ) ) { abort ( 404 ) ; } $ discussion_category = Models :: category ( ) -> find ( $ discussion -> chatter_category_id ) ; if ( $ category != $ discussion_category -> slug ) { return redirect ( config ( 'chatter.routes.home' ) . '/' . config ( 'chatter.routes.discussion' ) . '/' . $ discussion_category -> slug . '/' . $ discussion -> slug ) ; } $ posts = Models :: post ( ) -> with ( 'user' ) -> where ( 'chatter_discussion_id' , '=' , $ discussion -> id ) -> orderBy ( config ( 'chatter.order_by.posts.order' ) , config ( 'chatter.order_by.posts.by' ) ) -> paginate ( 10 ) ; $ chatter_editor = config ( 'chatter.editor' ) ; if ( $ chatter_editor == 'simplemde' ) { \ App :: register ( 'GrahamCampbell\Markdown\MarkdownServiceProvider' ) ; } $ discussion -> increment ( 'views' ) ; return view ( 'chatter::discussion' , compact ( 'discussion' , 'posts' , 'chatter_editor' ) ) ; }
9657	public function mount ( $ prefix = null ) { if ( $ prefix ) { $ this -> router -> group ( [ 'prefix' => $ prefix ] , function ( ) { $ this -> registerRoutes ( ) ; } ) ; } else { $ this -> registerRoutes ( ) ; } }
2806	public function viewLogAction ( ) { $ token = $ this -> getRequest ( ) -> getParam ( 'token' ) ; $ log = $ this -> getRequest ( ) -> getParam ( 'log' ) ; if ( ! $ token || ! $ log ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 400 ) -> setBody ( 'Invalid parameters' ) ; return ; } $ requestProfile = Mage :: getModel ( 'sheep_debug/requestInfo' ) -> load ( $ token , 'token' ) ; if ( ! $ requestProfile -> getId ( ) ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 404 ) -> setBody ( 'Request profile not found' ) ; return ; } try { $ content = $ requestProfile -> getLogging ( ) -> getLoggedContent ( $ log ) ; $ this -> getResponse ( ) -> setHttpResponseCode ( 200 ) -> setBody ( $ content ) ; } catch ( Exception $ e ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 200 ) -> setBody ( 'Unable to retrieve logged content' ) ; } }
8280	public function onPagesLoaded ( array & $ pages ) { unset ( $ pages [ "403" ] ) ; if ( ! $ this -> config [ "alterPageArray" ] ) { return ; } if ( $ this -> errorOccurred ) { $ pages = array ( ) ; return ; } foreach ( $ pages as $ id => $ page ) { try { $ allowed = $ this -> checkAccess ( $ id ) ; } catch ( \ Exception $ e ) { $ this -> errorHandler ( $ e , $ this -> requestUrl ) ; $ pages = array ( ) ; return ; } if ( ! $ allowed ) { unset ( $ pages [ $ id ] ) ; } } }
12842	static public function removeFiles ( $ directory ) { $ scan = glob ( rtrim ( $ directory , '/' ) . '/*' ) ; foreach ( $ scan as $ file ) { if ( is_file ( $ file ) ) { unlink ( $ file ) ; } } return true ; }
11259	public static function pascal2snake ( string $ pascal ) : string { preg_match_all ( '/((?:^|[A-Z])[a-z]+)/' , $ pascal , $ matches ) ; if ( $ matches !== null && count ( $ matches ) > 1 && count ( $ matches [ 1 ] ) > 1 ) { $ nameParts = $ matches [ 1 ] ; $ nameParts = array_map ( "lcfirst" , $ nameParts ) ; return implode ( "_" , $ nameParts ) ; } else { return lcfirst ( $ pascal ) ; } }
7938	public function getBackupFTPaccessBlock ( $ domain , $ ipBlock ) { $ domain = ( string ) $ domain ; if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; if ( ! $ ipBlock ) throw new BadMethodCallException ( 'Parameter $ipBlock is missing.' ) ; try { $ r = $ this -> get ( 'dedicated/server/' . $ domain . '/features/backupFTP/access/' . urlencode ( $ ipBlock ) ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new ServerException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
8018	public function getUrl ( $ name , $ expires = NULL ) { return $ this -> getClient ( ) -> getObjectUrl ( $ this -> bucket , $ name , $ expires ) ; }
5137	public static function handleError ( $ code , $ message , $ filename = '' , $ line = 0 ) { throw new \ ErrorException ( $ message , $ code , 0 , $ filename , $ line ) ; }
12099	public function priceNetto ( $ brutto , $ tax ) { $ tax = round ( ( double ) $ tax / 100.0 , 2 ) ; if ( $ tax < 0.00 ) { throw new Exception ( sprintf ( 'Tax must be greater than or equal to 0, given %s.' , $ tax ) ) ; } if ( $ tax === 0.00 ) { return $ brutto ; } $ result = $ brutto / ( $ tax + 1 ) ; return round ( $ result , 2 , PHP_ROUND_HALF_UP ) ; }
7975	public function createSender ( $ domain , $ sender ) { if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; if ( ! $ sender ) throw new BadMethodCallException ( 'Parameter $sender is missing.' ) ; if ( ! is_array ( $ sender ) ) throw new BadMethodCallException ( 'Parameter $sender must be a array. ' . gettype ( $ sender ) . ' given.' ) ; if ( ! array_key_exists ( 'sender' , $ sender ) ) throw new BadMethodCallException ( 'Parameter $sender have key sender (string).' ) ; $ t = array ( ) ; $ t [ 'sender' ] = $ sender [ 'sender' ] ; ( $ sender [ 'relaunch' ] ) ? $ t [ 'relaunch' ] = $ sender [ 'relaunch' ] : $ t [ 'relaunch' ] = '' ; ( $ sender [ 'reason' ] ) ? $ t [ 'reason' ] = $ sender [ 'reason' ] : $ t [ 'reason' ] = '' ; unset ( $ sender ) ; try { $ r = $ this -> post ( 'sms/' . $ domain . '/senders' , array ( 'Content-Type' => 'application/json;charset=UTF-8' ) , json_encode ( $ t ) ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new SmsException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } }
1660	public function reply ( $ reply ) { if ( is_string ( $ reply ) ) { $ this -> replies = [ $ reply ] ; } elseif ( is_array ( $ reply ) ) { $ this -> replies = $ reply ; } return $ this ; }
8673	private function iterateReverseFromIndex ( $ fromIndex ) { Assert :: nullOrInteger ( $ fromIndex ) ; $ index = count ( $ this -> items ) ; if ( $ index === 0 ) { return ; } if ( $ fromIndex !== null ) { $ index = $ fromIndex < 0 ? max ( $ index + $ fromIndex , 1 ) : min ( $ fromIndex + 1 , $ index ) ; } $ keys = array_keys ( $ this -> items ) ; while ( -- $ index >= 0 ) { $ key = $ keys [ $ index ] ; yield $ key => $ this -> items [ $ key ] ; } }
935	public static function isKeyCaseSensitive ( $ caseSensitive , $ key ) { if ( \ is_array ( $ caseSensitive ) ) { return isset ( $ caseSensitive [ $ key ] ) ? $ caseSensitive [ $ key ] : true ; } return $ caseSensitive ; }
3997	protected function getItem ( $ metaModelIdOrName , $ mixDataId , $ intIdRenderSetting , $ strOutput = null ) { $ objMetaModel = $ this -> loadMetaModel ( $ metaModelIdOrName ) ; if ( $ objMetaModel == null ) { return false ; } if ( empty ( $ strOutput ) ) { $ strOutput = 'html5' ; } $ objMetaModelList = new ItemList ( ) ; $ objMetaModelList -> setServiceContainer ( $ this -> getServiceContainer ( ) ) -> setMetaModel ( $ objMetaModel -> get ( 'id' ) , $ intIdRenderSetting ) -> overrideOutputFormat ( $ strOutput ) ; $ arrIds = StringUtil :: trimsplit ( ',' , $ mixDataId ) ; foreach ( $ arrIds as $ intKey => $ intId ) { if ( ! $ this -> isPublishedItem ( $ objMetaModel , $ intId ) ) { unset ( $ arrIds [ $ intKey ] ) ; } } if ( count ( $ arrIds ) < 1 ) { return '' ; } $ objMetaModelList -> addFilterRule ( new StaticIdList ( $ arrIds ) ) ; return $ objMetaModelList -> render ( false , $ this ) ; }
8516	public function updateInboundShipment ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_UpdateInboundShipmentRequest ) ) { $ request = new FBAInboundServiceMWS_Model_UpdateInboundShipmentRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'UpdateInboundShipment' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_UpdateInboundShipmentResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
11204	public function where ( $ key = false , $ desiredValue , $ op = "==" ) { $ collection = $ this -> getIterator ( ) ; $ subset = new Collection ( ) ; foreach ( $ collection as $ prop => $ result ) { $ realValue = $ result ; if ( is_object ( $ result ) ) { $ realValue = $ result -> $ key ; } else if ( is_array ( $ result ) ) { $ realValue = $ result [ $ key ] ; } $ add = false ; if ( $ op == '==' && $ realValue == $ desiredValue ) { $ add = true ; } else if ( $ op == '>=' && $ realValue >= $ desiredValue ) { $ add = true ; } else if ( $ op == '<=' && $ realValue <= $ desiredValue ) { $ add = true ; } else if ( $ op == '>' && $ realValue > $ desiredValue ) { $ add = true ; } else if ( $ op == '<' && $ realValue < $ desiredValue ) { $ add = true ; } else if ( $ op == '===' && $ realValue === $ desiredValue ) { $ add = true ; } else if ( $ op == '!=' && $ realValue != $ desiredValue ) { $ add = true ; } if ( $ add ) { $ subset -> add ( $ result , $ prop ) ; } } return $ subset ; }
1676	public function getModel ( ) { if ( $ this -> objModel === null && Dbafs :: shouldBeSynchronized ( $ this -> strFolder ) ) { $ this -> objModel = FilesModel :: findByPath ( $ this -> strFolder ) ; } return $ this -> objModel ; }
6407	public static function filter ( IteratorAggregate $ unfiltered , callable $ predicate ) : IteratorAggregate { return new CallableIterable ( function ( ) use ( $ unfiltered , $ predicate ) { return Iterators :: filter ( Iterators :: from ( $ unfiltered -> getIterator ( ) ) , $ predicate ) ; } ) ; }
12417	static function run_copy_paste_report ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { $ opts = self :: getOpts ( @ $ args [ 0 ] , @ $ args [ 1 ] , $ cliopts ) ; if ( ! SharedLock :: acquire ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ) throw new PakeException ( "Source code locked by another process" ) ; $ destdir = self :: getReportDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ; $ phpcpd = self :: getTool ( 'phpcpd' , $ opts , true ) ; try { $ out = pake_sh ( "$phpcpd " . escapeshellarg ( self :: getBuildDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ) ) ; } catch ( pakeException $ e ) { $ out = preg_replace ( '/^Problem executing command/' , '' , $ e -> getMessage ( ) ) ; } pake_mkdirs ( $ destdir ) ; pake_write_file ( $ destdir . '/phpcpd.txt' , $ out , true ) ; SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; }
10208	public function delete ( $ resourcePath , $ queryParameters = array ( ) , $ mimeType = 'application/vnd.maileon.api+xml' , $ deserializationType = null ) { $ curlSession = $ this -> prepareSession ( $ resourcePath , $ queryParameters , $ mimeType ) ; curl_setopt ( $ curlSession , CURLOPT_CUSTOMREQUEST , "DELETE" ) ; return $ this -> performRequest ( $ curlSession , $ deserializationType ) ; }
637	public function truncateTable ( $ table ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> truncateTable ( $ table ) ; return $ this -> setSql ( $ sql ) ; }
183	public function getPublishedUrl ( $ path ) { $ path = Yii :: getAlias ( $ path ) ; if ( isset ( $ this -> _published [ $ path ] ) ) { return $ this -> _published [ $ path ] [ 1 ] ; } if ( is_string ( $ path ) && ( $ path = realpath ( $ path ) ) !== false ) { return $ this -> baseUrl . '/' . $ this -> hash ( $ path ) . ( is_file ( $ path ) ? '/' . basename ( $ path ) : '' ) ; } return false ; }
10929	public function getCountOf ( string $ strSQL , ? array $ parans = null ) : int { $ r = $ this -> getDataColumn ( $ strSQL , $ parans , "int" ) ; return ( ( $ r === null ) ? 0 : $ r ) ; }
4606	public function createApp ( string $ client_name , string $ redirect_uris , string $ scopes , string $ website = '' ) : array { $ params = compact ( 'client_name' , 'redirect_uris' , 'scopes' , 'website' ) ; return $ this -> post ( '/apps' , $ params ) ; }
11467	public function init ( array $ viewDirs , array $ params ) { $ this -> viewDirs = $ viewDirs ; $ this -> params = $ params ; $ this -> parts = new ClearViewPartsCollection ( ) ; }
10852	public function echo ( $ type , $ content ) { if ( $ this -> option ( 'debug' ) == false ) { return ; } if ( trim ( $ content ) ) { $ this -> { $ type } ( $ content ) ; } }
6194	protected function loadControllers ( $ path ) { $ this -> app -> config [ 'controller' ] = array_unique ( array_merge ( $ this -> app -> config [ 'controller' ] ?? [ ] , $ path ) ) ; }
11607	public function actionProfile ( ) { $ model = $ this -> finder -> findProfileById ( \ Yii :: $ app -> user -> identity -> getId ( ) ) ; $ this -> performAjaxValidation ( $ model ) ; if ( $ model -> load ( \ Yii :: $ app -> request -> post ( ) ) && $ model -> save ( ) ) { \ Yii :: $ app -> getSession ( ) -> setFlash ( 'success' , \ Yii :: t ( 'user' , 'Your profile has been updated' ) ) ; return $ this -> refresh ( ) ; } return $ this -> render ( 'profile' , [ 'model' => $ model , ] ) ; }
5100	public function values ( $ values ) { if ( isset ( $ values [ 0 ] ) ) return $ this -> appendByPosition ( $ values ) ; $ this -> fixDefaultValues ( $ values ) ; if ( ! $ this -> fields ) { $ this -> placeholder = false ; $ this -> fields = array_keys ( $ values ) ; return $ this -> appendByPosition ( array_values ( $ values ) ) ; } return $ this -> appendByField ( $ values ) ; }
7634	public function putBlockList ( $ containerName = '' , $ blobName = '' , $ blockList = array ( ) , $ metadata = array ( ) , $ leaseId = null , $ additionalHeaders = array ( ) ) { Assertion :: notEmpty ( $ containerName , 'Container name is not specified' ) ; self :: assertValidContainerName ( $ containerName ) ; Assertion :: notEmpty ( $ blobName , 'Blob name is not specified.' ) ; Assertion :: notEmpty ( $ blockList , 'Block list does not contain any elements.' ) ; self :: assertValidRootContainerBlobName ( $ containerName , $ blobName ) ; $ blocks = '' ; foreach ( $ blockList as $ block ) { $ blocks .= ' <Latest>' . base64_encode ( $ block ) . '</Latest>' . "\n" ; } $ fileContents = utf8_encode ( implode ( "\n" , array ( '<?xml version="1.0" encoding="utf-8"?>' , '<BlockList>' , $ blocks , '</BlockList>' ) ) ) ; $ headers = array ( ) ; if ( ! is_null ( $ leaseId ) ) { $ headers [ 'x-ms-lease-id' ] = $ leaseId ; } $ headers = array_merge ( $ headers , $ this -> generateMetadataHeaders ( $ metadata ) ) ; foreach ( $ additionalHeaders as $ key => $ value ) { $ headers [ $ key ] = $ value ; } $ resourceName = self :: createResourceName ( $ containerName , $ blobName ) ; $ response = $ this -> performRequest ( $ resourceName , array ( 'comp' => 'blocklist' ) , 'PUT' , $ headers , false , $ fileContents , self :: RESOURCE_BLOB , self :: PERMISSION_WRITE ) ; if ( ! $ response -> isSuccessful ( ) ) { throw new BlobException ( $ this -> getErrorMessage ( $ response , 'Resource could not be accessed.' ) ) ; } }
12193	public function onKernelException ( GetResponseForExceptionEvent $ event ) { $ exception = $ event -> getException ( ) ; if ( $ exception instanceof AuthenticationCredentialsNotFoundException ) { return new RedirectResponse ( "/login" ) ; } $ message = $ exception -> getMessage ( ) ; if ( $ exception instanceof NotFoundHttpException || $ exception instanceof PageNotPublishedException ) { $ this -> render404page ( $ event , $ message ) ; return ; } if ( ! $ exception instanceof RedKiteCmsExceptionInterface ) { DataLogger :: log ( $ message , DataLogger :: CRITICAL ) ; if ( $ this -> debug ) { return $ event ; } $ this -> setUpResponse ( $ event , $ message ) ; return ; } $ message = Utils :: translateException ( $ message , $ exception ) ; $ this -> setUpResponse ( $ event , $ message ) ; DataLogger :: log ( $ message , DataLogger :: ERROR ) ; }
7596	protected function renderHelpBlock ( ElementInterface $ oElement ) { if ( $ sHelpBlock = $ oElement -> getOption ( 'help-block' ) ) { if ( $ oTranslator = $ this -> getTranslator ( ) ) { $ sHelpBlock = $ oTranslator -> translate ( $ sHelpBlock , $ this -> getTranslatorTextDomain ( ) ) ; } $ sHelpBlockString = strip_tags ( $ sHelpBlock ) ; if ( $ sHelpBlock === $ sHelpBlockString ) { $ sHelpBlock = $ this -> getEscapeHtmlHelper ( ) -> __invoke ( $ sHelpBlock ) ; } return sprintf ( static :: $ helpBlockFormat , $ sHelpBlock ) ; } else { return '' ; } }
2718	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ snippet = $ this -> getRequest ( ) -> getParam ( 'snippet_id' ) ; $ read = $ this -> filesystem -> getDirectoryRead ( DirectoryList :: VAR_DIR ) ; $ snippetPath = $ read -> getRelativePath ( Config :: CUSTOM_SNIPPET_PATH . $ snippet ) ; if ( $ read -> isExist ( $ snippetPath ) ) { $ explodeId = explode ( '.' , $ snippet , - 1 ) ; $ snippetParts = explode ( '_' , $ explodeId [ 0 ] , 3 ) ; $ type = $ snippetParts [ 0 ] ; $ priority = $ snippetParts [ 1 ] ; $ name = $ snippetParts [ 2 ] ; $ content = $ read -> readFile ( $ snippetPath ) ; } else { throw new LocalizedException ( __ ( 'Custom snippet not found.' ) ) ; } return $ result -> setData ( [ 'status' => true , 'type' => $ type , 'priority' => $ priority , 'name' => $ name , 'content' => $ content , 'original' => $ snippet ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
11154	public function getArrayKeyByPowers ( array $ powers ) { if ( empty ( $ powers ) ) { throw new InvalidArgumentException ( 'Empty powers set' ) ; } $ powersSum = 0 ; foreach ( $ powers as $ power ) { if ( $ power < 0 ) { throw new InvalidArgumentException ( 'Negative power found' ) ; } $ powersSum += $ power ; } if ( $ powersSum <= 0 ) { throw new InvalidArgumentException ( 'The sum of powers must be positive' ) ; } $ randomValue = $ this -> generator -> getFloat ( 0 , $ powersSum ) ; $ currentSum = 0 ; $ result = null ; foreach ( $ powers as $ key => $ power ) { $ currentSum += $ power ; if ( $ currentSum >= $ randomValue ) { $ result = $ key ; break ; } } return $ key ; }
11355	public function getValue ( $ name = null ) { if ( $ this -> has ( $ name ) ) { return $ this -> get ( $ name ) -> getValue ( ) ; } return parent :: getValue ( ) ; }
10204	public function setShrinkToFit ( $ pValue ) { if ( $ pValue == '' ) { $ pValue = false ; } if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'shrinkToFit' => $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> shrinkToFit = $ pValue ; } return $ this ; }
2792	public function get ( $ option ) { if ( ! array_key_exists ( $ option , $ this -> inputOptions ) ) { throw new \ InvalidArgumentException ( 'Option "' . $ option . ' not exists' ) ; } return $ this -> inputOptions [ $ option ] ; }
4420	public function onKernelBuilt ( PostBuildKernelEvent $ event ) { $ currentRequest = $ this -> requestStack -> getCurrentRequest ( ) ; if ( $ currentRequest === null || ! $ event -> getKernelHandler ( ) instanceof ezpWebBasedKernelHandler || $ this -> configResolver -> getParameter ( 'legacy_mode' ) === true || ! $ this -> isUserAuthenticated ( ) ) { return ; } $ currentRequest -> getSession ( ) -> set ( 'eZUserLoggedInID' , $ this -> repository -> getCurrentUser ( ) -> id ) ; }
10720	public function removeThumbnail ( \ TYPO3 \ CMS \ Extbase \ Domain \ Model \ FileReference $ thumbnail ) { $ this -> thumbnails -> detach ( $ thumbnail ) ; }
12980	protected function configureBehavior ( $ behavior , EventSubscriber $ es ) { switch ( $ behavior ) { case 'translatable' : $ es -> setTranslatableLocale ( \ Config :: get ( 'language' , 'en' ) ) ; $ es -> setDefaultLocale ( \ Config :: get ( 'language_fallback' , 'en' ) ) ; break ; } }
8430	protected function getFaFileIcon ( $ fileType ) { switch ( $ fileType ) { case FileManager :: FILE_TYPE_IMAGE : { return 'fa-file-image' ; } case FileManager :: FILE_TYPE_VIDEO : { return 'fa-file-video' ; } case FileManager :: FILE_TYPE_AUDIO : { return 'fa-file-audio' ; } case FileManager :: FILE_TYPE_DOCUMENT : { return 'fa-file' ; } case FileManager :: FILE_TYPE_COMPRESSED : { return 'fa-file-archive' ; } } }
4941	public function getAllowedTypes ( $ asArray = false ) { $ types = $ this -> getAttribute ( 'data-allowedtypes' ) ; if ( $ asArray ) { return explode ( ',' , $ types ) ; } return $ types ; }
427	public static function setInstance ( $ instance ) { if ( $ instance === null ) { unset ( Yii :: $ app -> loadedModules [ get_called_class ( ) ] ) ; } else { Yii :: $ app -> loadedModules [ get_class ( $ instance ) ] = $ instance ; } }
2695	public function execute ( Observer $ observer ) { if ( $ this -> fastlyConfig -> isFastlyEnabled ( ) != true ) { return ; } $ this -> response -> setHeader ( "x-esi" , "1" ) ; }
7836	protected function deleteAllFilesOfWorkflowIfForced ( $ workflow ) { $ files = $ this -> pipelines -> getPipesByPipeline ( $ workflow ) ; $ files [ ] = $ this -> inflector -> getRequest ( ) ; $ files [ ] = $ this -> inflector -> getJob ( ) ; $ this -> deleteIfForced ( $ files ) ; }
10856	public function has ( string $ typeName ) : bool { if ( isset ( $ this -> shared [ $ typeName ] ) || isset ( $ this -> definitions [ $ typeName ] ) ) { return true ; } if ( ! isset ( $ this -> typeCache [ $ typeName ] ) ) { if ( \ class_exists ( $ typeName ) || \ interface_exists ( $ typeName , false ) ) { $ this -> typeCache [ $ typeName ] = new \ ReflectionClass ( $ typeName ) ; } else { $ this -> typeCache [ $ typeName ] = false ; } } return $ this -> typeCache [ $ typeName ] !== false && $ this -> typeCache [ $ typeName ] -> isInstantiable ( ) ; }
4258	public function addSubscriberInterface ( SubscriberInterface $ interface ) { $ subscribers = $ this -> getInterfaceSubscribers ( $ interface ) ; foreach ( $ subscribers as $ row ) { $ this -> subscribe ( $ row [ 0 ] , $ row [ 1 ] , $ row [ 2 ] ) ; } return $ subscribers ; }
11503	private function createDeleteForm ( Comment $ comment ) { return $ this -> createFormBuilder ( ) -> setAction ( $ this -> generateUrl ( 'blog_comment_delete' , array ( 'id' => $ comment -> getId ( ) ) ) ) -> setMethod ( 'DELETE' ) -> getForm ( ) ; }
1187	protected function createValidator ( $ translator , $ data , $ rules , $ messages , $ customAttributes ) { if ( is_null ( $ this -> resolver ) ) { return new BaseValidator ( $ translator , $ data , $ rules , $ messages , $ customAttributes ) ; } return call_user_func ( $ this -> resolver , $ translator , $ data , $ rules , $ messages , $ customAttributes ) ; }
294	public function setAttribute ( $ name , $ value ) { if ( $ this -> hasAttribute ( $ name ) ) { if ( ! empty ( $ this -> _relationsDependencies [ $ name ] ) && ( ! array_key_exists ( $ name , $ this -> _attributes ) || $ this -> _attributes [ $ name ] !== $ value ) ) { $ this -> resetDependentRelations ( $ name ) ; } $ this -> _attributes [ $ name ] = $ value ; } else { throw new InvalidArgumentException ( get_class ( $ this ) . ' has no attribute named "' . $ name . '".' ) ; } }
2534	public function setSessionData ( array $ sessionData ) { if ( isset ( $ sessionData [ 'sessionId' ] , $ sessionData [ 'sequenceNumber' ] , $ sessionData [ 'securityToken' ] ) ) { $ this -> sessionData [ 'sessionId' ] = $ sessionData [ 'sessionId' ] ; $ this -> sessionData [ 'sequenceNumber' ] = $ sessionData [ 'sequenceNumber' ] ; $ this -> sessionData [ 'securityToken' ] = $ sessionData [ 'securityToken' ] ; $ this -> isAuthenticated = true ; } else { $ this -> isAuthenticated = false ; } return $ this -> isAuthenticated ; }
4410	public function onBuildView ( CollectViewParametersEvent $ event ) { $ view = $ event -> getView ( ) ; if ( ! $ view instanceof LayoutViewInterface && ! $ view instanceof RuleViewInterface ) { return ; } if ( $ view -> getContext ( ) !== 'ngadminui' ) { return ; } $ event -> addParameter ( 'is_enterprise' , $ this -> isEnterpriseVersion ) ; }
7872	public function send ( array $ destinations , string $ message ) : ? array { $ this -> checkConfig ( ) ; if ( ! empty ( $ destinations ) ) { $ destination = $ destinations [ 0 ] ; } $ query = http_build_query ( [ 'userkey' => $ this -> userkey , 'passkey' => $ this -> passkey , 'nohp' => $ destination , 'pesan' => $ message , ] ) ; $ response = Request :: get ( $ this -> baseUrl . '/smsapi.php?' . $ query ) ; $ xml = simplexml_load_string ( $ response -> body ) ; $ body = json_decode ( json_encode ( $ xml ) , true ) ; if ( ! empty ( $ body [ 'message' ] ) and $ body [ 'message' ] [ 'status' ] != 0 ) { Log :: error ( sprintf ( 'Zenziva: %s.' , $ body [ 'message' ] [ 'text' ] ) ) ; } return [ 'code' => $ response -> code , 'message' => ( $ response -> code == 200 ) ? 'OK' : $ body [ 'message' ] [ 'text' ] ?? '' , 'data' => $ body , ] ; }
220	private function formatNumber ( $ value , $ decimals , $ maxPosition , $ formatBase , $ options , $ textOptions ) { $ value = $ this -> normalizeNumericValue ( $ value ) ; $ position = 0 ; if ( is_array ( $ formatBase ) ) { $ maxPosition = count ( $ formatBase ) - 1 ; } do { if ( is_array ( $ formatBase ) ) { if ( ! isset ( $ formatBase [ $ position + 1 ] ) ) { break ; } if ( abs ( $ value ) < $ formatBase [ $ position + 1 ] ) { break ; } } else { if ( abs ( $ value ) < $ formatBase ) { break ; } $ value /= $ formatBase ; } $ position ++ ; } while ( $ position < $ maxPosition + 1 ) ; if ( is_array ( $ formatBase ) && $ position !== 0 ) { $ value /= $ formatBase [ $ position ] ; } if ( $ position === 0 ) { $ decimals = 0 ; } elseif ( $ decimals !== null ) { $ value = round ( $ value , $ decimals ) ; } $ oldThousandSeparator = $ this -> thousandSeparator ; $ this -> thousandSeparator = '' ; if ( $ this -> _intlLoaded && ! isset ( $ options [ NumberFormatter :: GROUPING_USED ] ) ) { $ options [ NumberFormatter :: GROUPING_USED ] = false ; } $ params = [ 'n' => abs ( $ value ) , 'nFormatted' => $ this -> asDecimal ( $ value , $ decimals , $ options , $ textOptions ) , ] ; $ this -> thousandSeparator = $ oldThousandSeparator ; return [ $ params , $ position ] ; }
3964	private function getJsonFile ( $ filename ) { if ( ! is_readable ( $ filename ) ) { return [ ] ; } $ contents = json_decode ( file_get_contents ( $ filename ) , true ) ; return $ contents ? : [ ] ; }
2180	private function findIn ( string $ path ) : Finder { return Finder :: create ( ) -> ignoreDotFiles ( false ) -> sort ( static function ( SplFileInfo $ a , SplFileInfo $ b ) : int { $ countA = substr_count ( strtr ( $ a -> getRelativePath ( ) , '\\' , '/' ) , '/' ) ; $ countB = substr_count ( strtr ( $ b -> getRelativePath ( ) , '\\' , '/' ) , '/' ) ; return $ countA <=> $ countB ; } ) -> followLinks ( ) -> in ( $ path ) ; }
457	public function dropUnique ( $ name , $ table ) { return 'ALTER TABLE ' . $ this -> db -> quoteTableName ( $ table ) . ' DROP CONSTRAINT ' . $ this -> db -> quoteColumnName ( $ name ) ; }
6144	public function hasQueryVar ( $ key ) { if ( ! $ this -> hasQuery ( ) ) { return false ; } parse_str ( $ this -> query , $ queryArray ) ; return array_key_exists ( $ key , $ queryArray ) ? true : false ; }
552	public function actionFlushAll ( ) { $ caches = $ this -> findCaches ( ) ; $ cachesInfo = [ ] ; if ( empty ( $ caches ) ) { $ this -> notifyNoCachesFound ( ) ; return ExitCode :: OK ; } foreach ( $ caches as $ name => $ class ) { $ cachesInfo [ ] = [ 'name' => $ name , 'class' => $ class , 'is_flushed' => $ this -> canBeFlushed ( $ class ) ? Yii :: $ app -> get ( $ name ) -> flush ( ) : false , ] ; } $ this -> notifyFlushed ( $ cachesInfo ) ; }
2468	public function getOptions ( ) : array { $ options = [ ] ; foreach ( self :: DEFAULT_OPTIONS as $ option => $ label ) { $ options [ $ option ] = $ this -> translator -> trans ( 'MSC.validCharacters.' . $ label , [ ] , 'contao_default' ) ; } $ event = new SlugValidCharactersEvent ( $ options ) ; $ this -> eventDispatcher -> dispatch ( ContaoCoreEvents :: SLUG_VALID_CHARACTERS , $ event ) ; return $ event -> getOptions ( ) ; }
7396	public function execute ( ) { $ addresses = $ this -> addressRepository -> createQueryBuilder ( 'a' ) -> where ( 'a.latitude IS NULL' ) -> orWhere ( 'a.longitude IS NULL' ) -> setMaxResults ( 500 ) -> getQuery ( ) -> getResult ( ) ; foreach ( $ addresses as $ address ) { try { $ this -> updateLatLong ( $ address ) ; } catch ( \ RuntimeException $ e ) { echo "Stopping work -- over the API query limit.\n" ; break ; } $ this -> entityManager -> persist ( $ address ) ; usleep ( self :: MILLISECONDS_PAUSE_BETWEEN_QUERIES ) ; } $ this -> entityManager -> flush ( ) ; }
7655	function AddAddress ( $ address , $ name = "" ) { $ cur = count ( $ this -> to ) ; $ this -> to [ $ cur ] [ 0 ] = trim ( $ address ) ; $ this -> to [ $ cur ] [ 1 ] = $ name ; }
9842	public function createSealedJsonResponse ( int $ status , array $ arrayToJsonify , SealingPublicKey $ key , array $ headers = [ ] , string $ version = '1.1' ) : ResponseInterface { if ( empty ( $ headers [ 'Content-Type' ] ) ) { $ headers [ 'Content-Type' ] = 'application/json' ; } $ body = \ json_encode ( $ arrayToJsonify , JSON_PRETTY_PRINT ) ; if ( ! \ is_string ( $ body ) ) { throw new InvalidMessageException ( 'Cannot JSON-encode this message.' ) ; } return $ this -> createSealedResponse ( $ status , $ body , $ key , $ headers , $ version ) ; }
6824	protected function getTaxAccountNumber ( float $ rate , string $ origin ) { foreach ( $ this -> accounts as $ account ) { if ( $ account -> getType ( ) !== AccountingTypes :: TYPE_TAX ) { continue ; } if ( 0 !== bccomp ( $ account -> getTax ( ) -> getRate ( ) , $ rate , 5 ) ) { continue ; } return $ account -> getNumber ( ) ; } throw new LogicException ( sprintf ( "No tax account number configured for tax rate '%s' (%s)" , $ rate , $ origin ) ) ; }
2381	public static function stripRootDir ( $ path ) { $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; $ length = \ strlen ( $ rootDir ) ; if ( strncmp ( $ path , $ rootDir , $ length ) !== 0 || \ strlen ( $ path ) <= $ length || ( $ path [ $ length ] !== '/' && $ path [ $ length ] !== '\\' ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Path "%s" is not inside the Contao root dir "%s"' , $ path , $ rootDir ) ) ; } return ( string ) substr ( $ path , $ length + 1 ) ; }
2841	public function renderArray ( $ data , $ noDataLabel = 'No Data' , $ header = null ) { $ block = $ this -> getLayout ( ) -> createBlock ( 'sheep_debug/view' ) ; $ block -> setTemplate ( 'sheep_debug/view/panel/_array.phtml' ) ; $ block -> setData ( 'array' , $ data ) ; $ block -> setData ( 'no_data_label' , $ noDataLabel ) ; $ block -> setData ( 'header' , $ header ) ; return $ block -> toHtml ( ) ; }
3687	protected function getAttributeFromFilterOperation ( $ operation ) { $ attribute = null ; if ( ! empty ( $ operation [ 'property' ] ) ) { $ attribute = $ this -> getMetaModel ( ) -> getAttribute ( $ operation [ 'property' ] ) ; } if ( $ attribute === null ) { throw new \ InvalidArgumentException ( 'Attribute ' . $ operation [ 'property' ] . ' not found.' ) ; } return $ attribute ; }
1317	public function delete ( $ path , array $ parameters = [ ] ) { return $ this -> http ( 'DELETE' , self :: API_HOST , $ path , $ parameters , false ) ; }
7547	function getEncoding ( ) { $ root = $ this -> getRoot ( ) ; if ( $ root !== null ) { if ( $ enc = $ root -> select ( 'meta[charset]' , 0 , true , true ) ) { return $ enc -> getAttribute ( "charset" ) ; } elseif ( $ enc = $ root -> select ( '"?xml"[encoding]' , 0 , true , true ) ) { return $ enc -> getAttribute ( "encoding" ) ; } elseif ( $ enc = $ root -> select ( 'meta[content*="charset="]' , 0 , true , true ) ) { $ enc = $ enc -> getAttribute ( "content" ) ; return substr ( $ enc , strpos ( $ enc , "charset=" ) + 8 ) ; } } return false ; }
2937	public function restore ( $ filePath = null ) { if ( is_null ( $ filePath ) ) { $ latestBackup = $ this -> getLatestBackup ( ) ; if ( is_null ( $ latestBackup ) ) { throw new NoBackupAvailableException ( "There are no available backups!" ) ; } $ filePath = $ latestBackup [ 'filepath' ] ; } if ( ! is_file ( $ filePath ) ) { throw new FileNotFoundException ( "File does not exist at path {$filePath}" ) ; } copy ( $ filePath , $ this -> filePath ) ; $ this -> writer -> setBuffer ( $ this -> getContent ( ) ) ; return $ this ; }
574	public function unmaskToken ( $ maskedToken ) { $ decoded = StringHelper :: base64UrlDecode ( $ maskedToken ) ; $ length = StringHelper :: byteLength ( $ decoded ) / 2 ; if ( ! is_int ( $ length ) ) { return '' ; } return StringHelper :: byteSubstr ( $ decoded , $ length , $ length ) ^ StringHelper :: byteSubstr ( $ decoded , 0 , $ length ) ; }
1204	protected function renderChildren ( ItemInterface $ item , array $ options ) { if ( null !== $ options [ 'depth' ] ) { $ options [ 'depth' ] = $ options [ 'depth' ] - 1 ; } if ( null !== $ options [ 'matchingDepth' ] && $ options [ 'matchingDepth' ] > 0 ) { $ options [ 'matchingDepth' ] = $ options [ 'matchingDepth' ] - 1 ; } $ html = '' ; foreach ( $ item -> getChildren ( ) as $ child ) { $ html .= $ this -> renderItem ( $ child , $ options ) ; } return $ html ; }
1684	public function checkAdminStatus ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ varValue == '' && $ this -> User -> id == $ dc -> id ) { $ varValue = 1 ; } return $ varValue ; }
8901	public function update_batch ( $ data , $ where_key ) { $ _data = array ( ) ; foreach ( $ data as $ key => $ row ) { if ( false !== $ row = $ this -> _do_pre_update ( $ row ) ) { $ _data [ $ key ] = $ row ; } } return $ this -> _database -> update_batch ( $ this -> _table , $ _data , $ where_key ) ; }
7879	protected function registerLogViewer ( ) { $ this -> app -> singleton ( 'logviewer' , function ( $ app ) { $ factory = $ app [ 'logviewer.factory' ] ; $ filesystem = $ app [ 'logviewer.filesystem' ] ; $ data = $ app [ 'logviewer.data' ] ; return new LogViewer ( $ factory , $ filesystem , $ data ) ; } ) ; $ this -> app -> alias ( 'logviewer' , LogViewer :: class ) ; }
9218	protected function pageNumberToKey ( $ pageNumber ) { if ( isset ( $ this -> pagination [ CanvasPageLink :: CURRENT ] ) ) { return ( $ pageNumber - 1 ) * $ this -> pagination [ CanvasPageLink :: CURRENT ] -> getPerPage ( ) ; } return false ; }
3750	public function getFilterOptions ( ConfigInterface $ objConfig ) { $ arrProperties = $ objConfig -> getFields ( ) ; if ( count ( $ arrProperties ) <> 1 ) { throw new \ RuntimeException ( 'objConfig must contain exactly one property to be retrieved.' ) ; } $ objFilter = $ this -> prepareFilter ( $ objConfig ) ; $ arrValues = $ this -> getMetaModel ( ) -> getAttribute ( $ arrProperties [ 0 ] ) -> getFilterOptions ( $ objFilter -> getMatchingIds ( ) , true ) ; $ objCollection = new DefaultFilterOptionCollection ( ) ; foreach ( $ arrValues as $ strKey => $ strValue ) { $ objCollection -> add ( $ strKey , $ strValue ) ; } return $ objCollection ; }
9629	protected function getRouteIdentifier ( Route $ route ) : string { return empty ( $ route -> getName ( ) ) ? $ route -> getTarget ( ) : $ route -> getName ( ) ; }
9807	private function readBlipJPEG ( ) { $ recInstance = ( 0xFFF0 & Xls :: getUInt2d ( $ this -> data , $ this -> pos ) ) >> 4 ; $ length = Xls :: getInt4d ( $ this -> data , $ this -> pos + 4 ) ; $ recordData = substr ( $ this -> data , $ this -> pos + 8 , $ length ) ; $ this -> pos += 8 + $ length ; $ pos = 0 ; $ rgbUid1 = substr ( $ recordData , 0 , 16 ) ; $ pos += 16 ; if ( in_array ( $ recInstance , [ 0x046B , 0x06E3 ] ) ) { $ rgbUid2 = substr ( $ recordData , 16 , 16 ) ; $ pos += 16 ; } $ tag = ord ( $ recordData [ $ pos ] ) ; $ pos += 1 ; $ data = substr ( $ recordData , $ pos ) ; $ blip = new Blip ( ) ; $ blip -> setData ( $ data ) ; $ this -> object -> setBlip ( $ blip ) ; }
12898	public static function translate ( $ message , $ parameters = array ( ) , $ domain = "RedKiteCms" , $ locale = null ) { if ( null === self :: $ translator ) { return $ message ; } return self :: $ translator -> trans ( $ message , $ parameters , $ domain , $ locale ) ; }
1566	public function substituteBindings ( StoreInterface $ store ) : void { $ this -> resourceId = $ this -> getResourceId ( ) ? : false ; $ this -> processId = $ this -> getProcessId ( ) ? : false ; if ( $ this -> resourceId ) { $ this -> route -> setParameter ( ResourceRegistrar :: PARAM_RESOURCE_ID , $ store -> findOrFail ( $ this -> getResourceType ( ) , $ this -> resourceId ) ) ; } if ( $ this -> processId ) { $ this -> route -> setParameter ( ResourceRegistrar :: PARAM_PROCESS_ID , $ store -> findOrFail ( $ this -> getProcessType ( ) , $ this -> processId ) ) ; } }
5300	public function getGlyphNames ( ) { $ glyphNames = array ( ) ; foreach ( $ this -> font -> getGlyphs ( ) as $ glyph ) { $ glyphNames [ static :: unicodeToHex ( $ glyph [ 'char' ] ) ] = empty ( $ glyph [ 'name' ] ) ? null : $ glyph [ 'name' ] ; } return $ glyphNames ; }
10409	protected function getUrlsByDocumentParameter ( ) { if ( count ( $ this -> documentParamCache ) < 1 ) { return [ ] ; } $ urls = [ ] ; $ query = new Query ( ) ; $ queryTerms = [ ] ; foreach ( $ this -> documentParamCache as $ param ) { $ queryTerms [ $ param [ 0 ] ] [ ] = $ param [ 1 ] ; } foreach ( $ queryTerms as $ field => $ values ) { $ termQuery = new TermQuery ( $ field , $ values ) ; $ query -> addQuery ( $ termQuery , 'should' ) ; } $ limitFilter = new LimitFilter ( count ( $ this -> documentParamCache ) ) ; $ repository = $ this -> manager -> getRepository ( 'MultiModel' ) ; $ search = $ repository -> createSearch ( ) -> addQuery ( $ query ) -> addFilter ( $ limitFilter ) ; $ documents = $ repository -> execute ( $ search ) ; foreach ( $ documents as $ document ) { if ( is_array ( $ document -> url ) ) { foreach ( $ document -> url as $ url ) { $ urls [ ] = $ url [ 'url' ] ; } } } array_walk ( $ urls , [ $ this , 'addWildcard' ] ) ; $ this -> addUrls ( $ urls ) ; return $ urls ; }
9329	protected function registerMarkdownBladeEngine ( $ resolver ) { $ app = $ this -> app ; $ app -> singleton ( 'markdown.blade.compiler' , function ( $ app ) { $ cache = $ app [ 'config' ] [ 'view.compiled' ] ; return new MarkdownBladeCompiler ( $ app [ 'files' ] , $ cache ) ; } ) ; $ resolver -> register ( 'markdown.blade' , function ( ) use ( $ app ) { return new MarkdownEngine ( $ app [ 'markdown.blade.compiler' ] , $ app [ 'files' ] ) ; } ) ; $ app [ 'view' ] -> addExtension ( 'md.blade.php' , 'markdown.blade' ) ; }
6008	protected function init ( $ ftkey ) { if ( strlen ( $ ftkey ) != 32 ) { throw new Ts3Exception ( "invalid file transfer key format" ) ; } $ this -> getProfiler ( ) -> start ( ) ; $ this -> getTransport ( ) -> send ( $ ftkey ) ; Signal :: getInstance ( ) -> emit ( "filetransferHandshake" , $ this ) ; }
2591	public function loadPaymentData ( MopInfo $ options ) { if ( $ this -> checkAnyNotEmpty ( $ options -> payMerchant , $ options -> transactionDate , $ options -> payments , $ options -> installmentsInfo , $ options -> fraudScreening , $ options -> payIds ) ) { $ this -> paymentData = new PaymentData ( $ options -> payMerchant , $ options -> transactionDate , $ options -> payments , $ options -> installmentsInfo , $ options -> fraudScreening , $ options -> payIds ) ; } }
4131	public function createLuceneQuery ( $ designDocName , $ viewName ) { $ luceneHandlerName = $ this -> config -> getLuceneHandlerName ( ) ; $ designDoc = $ this -> config -> getDesignDocument ( $ designDocName ) ; if ( $ designDoc ) { $ designDoc = new $ designDoc [ 'className' ] ( $ designDoc [ 'options' ] ) ; } $ query = new ODMLuceneQuery ( $ this -> couchDBClient -> getHttpClient ( ) , $ this -> couchDBClient -> getDatabase ( ) , $ luceneHandlerName , $ designDocName , $ viewName , $ designDoc ) ; $ query -> setDocumentManager ( $ this ) ; return $ query ; }
3356	public function getPath ( $ postfix = null ) { $ url = sprintf ( '/%s/' , $ this -> uuid ) ; if ( $ this -> default_effects ) { $ url = sprintf ( '%s-/%s' , $ url , $ this -> default_effects ) ; } if ( $ this -> filename && $ postfix === null ) { $ postfix = $ this -> filename ; } $ operations = array ( ) ; foreach ( $ this -> operations as $ i => $ operation_item ) { $ part = array ( ) ; foreach ( array_keys ( $ operation_item ) as $ operation_type ) { $ operation_params = $ operation_item [ $ operation_type ] ; $ part [ ] = $ operation_type ; switch ( $ operation_type ) { case 'crop' : $ part = $ this -> __addPartSize ( $ part , $ operation_params ) ; $ part = $ this -> __addPartCenter ( $ part , $ operation_params ) ; $ part = $ this -> __addPartFillColor ( $ part , $ operation_params ) ; break ; case 'resize' : $ part = $ this -> __addPartSize ( $ part , $ operation_params ) ; break ; case 'scale_crop' : $ part = $ this -> __addPartSize ( $ part , $ operation_params ) ; $ part = $ this -> __addPartCenter ( $ part , $ operation_params ) ; break ; case 'effect' : $ part = $ this -> __addPartEffect ( $ part , $ operation_params ) ; break ; case 'preview' : $ part = $ this -> __addPartSize ( $ part , $ operation_params ) ; break ; case 'custom' : $ part = array ( $ operation_params ) ; break ; } $ part_str = join ( '/' , $ part ) ; $ operations [ ] = $ part_str ; } } if ( count ( $ operations ) ) { $ operations_part = join ( '/-/' , $ operations ) ; return $ url . '-/' . $ operations_part . '/' . $ postfix ; } else { return $ url . $ postfix ; } }
502	public function registerClientScript ( ) { $ id = $ this -> grid -> options [ 'id' ] ; $ options = Json :: encode ( [ 'name' => $ this -> name , 'class' => $ this -> cssClass , 'multiple' => $ this -> multiple , 'checkAll' => $ this -> grid -> showHeader ? $ this -> getHeaderCheckBoxName ( ) : null , ] ) ; $ this -> grid -> getView ( ) -> registerJs ( "jQuery('#$id').yiiGridView('setSelectionColumn', $options);" ) ; }
7413	public function getResponse ( string & $ packageRoot , Request & $ request ) : Response { $ packageRoot = rtrim ( $ packageRoot , '/' ) ; $ route = preg_replace ( '/\/\d+/u' , '/D' , $ request -> route ( ) ) ; $ path = $ packageRoot . '/Route/' . $ route . '/' . $ request -> method ( ) . '.php' ; if ( file_exists ( $ path ) ) { require $ path ; $ controllerClass = $ request -> package ( ) . '\\Route_' . str_replace ( '/' , '_' , $ route ) . '\\' . $ request -> method ( ) ; if ( class_exists ( $ controllerClass ) ) { $ controller = new $ controllerClass ( $ packageRoot , $ request ) ; } else { throw new RouteException ( sprintf ( 'Route: the class "%s" does not exist' , $ controllerClass ) ) ; } $ handler = filter_input_array ( INPUT_POST ) [ 'handler' ] ?? filter_input_array ( INPUT_GET ) [ 'handler' ] ?? 'index' ; if ( method_exists ( $ controllerClass , $ handler ) ) { $ controller -> invoke ( $ handler ) ; return $ controller -> getResponse ( ) ; } else { throw new RouteException ( sprintf ( 'Route: the method "%s" does not exist' , $ handler ) ) ; } } else { throw new RouteException ( sprintf ( 'Route: path "%s" does not exist' , $ request -> package ( ) . '/Route/' . $ route . '/' . $ request -> method ( ) . '.php' ) ) ; } }
8178	protected function sendMail ( $ to , $ subject , $ view , $ params = [ ] ) { $ mailer = Yii :: $ app -> mailer ; $ mailer -> viewPath = '@abhimanyu/user/views/mail' ; return $ mailer -> compose ( [ 'html' => $ view , 'text' => 'text/' . $ view ] , $ params ) -> setTo ( $ to ) -> setFrom ( Yii :: $ app -> config -> get ( 'mail.username' ) , 'no@reply.com' ) -> setSubject ( $ subject ) -> send ( ) ; }
9624	public function makeHandler ( $ ident ) { if ( ! isset ( $ this -> factories [ $ ident ] ) ) { throw new \ InvalidArgumentException ( "Unknown session handler: $ident" ) ; } return $ this -> factories [ $ ident ] ( ) ; }
3421	protected function loadModels ( ) { $ queryType = 'UserQuery::getList' ; $ sort = $ this -> sort ; $ filter = $ this -> normalizeFilter ( ) ; $ params = [ 'SELECT' => $ this -> propsMustBeSelected ( ) ? [ 'UF_*' ] : ( $ this -> normalizeUfSelect ( ) ? : false ) , 'NAV_PARAMS' => $ this -> navigation , 'FIELDS' => $ this -> normalizeSelect ( ) , ] ; $ selectGroups = $ this -> groupsMustBeSelected ( ) ; $ keyBy = $ this -> keyBy ; $ callback = function ( ) use ( $ sort , $ filter , $ params , $ selectGroups ) { $ users = [ ] ; $ rsUsers = $ this -> bxObject -> getList ( $ sort , $ sortOrder = false , $ filter , $ params ) ; while ( $ arUser = $ this -> performFetchUsingSelectedMethod ( $ rsUsers ) ) { if ( $ selectGroups ) { $ arUser [ 'GROUP_ID' ] = $ this -> bxObject -> getUserGroup ( $ arUser [ 'ID' ] ) ; } $ this -> addItemToResultsUsingKeyBy ( $ users , new $ this -> modelName ( $ arUser [ 'ID' ] , $ arUser ) ) ; } return new Collection ( $ users ) ; } ; return $ this -> handleCacheIfNeeded ( compact ( 'queryType' , 'sort' , 'filter' , 'params' , 'selectGroups' , 'keyBy' ) , $ callback ) ; }
11076	public function getHttpClient ( ) { if ( null === $ this -> httpClient ) { $ this -> httpClient = new HttpClient ( ) ; $ this -> httpClient -> setAdapter ( $ this -> getHttpAdapter ( ) ) ; } return $ this -> httpClient ; }
8862	public function getYearlyArchiveLink ( ) { $ date = $ this -> dbObject ( "PublishDate" ) ; return Controller :: join_links ( $ this -> Parent ( ) -> Link ( "archive" ) , $ date -> format ( "Y" ) ) ; }
8852	public function getCurrentTag ( ) { $ tag = $ this -> request -> param ( "Tag" ) ; if ( $ tag ) { return $ this -> dataRecord -> Tags ( ) -> filter ( "URLSegment" , $ tag ) -> first ( ) ; } return null ; }
12707	public static function parseSignature ( string $ signature ) : array { $ signature = explode ( ' ' , trim ( $ signature ) ) ; $ command = trim ( $ signature [ 0 ] ) ; $ arguments = [ ] ; $ options = [ ] ; foreach ( $ signature as $ word ) { $ type = self :: determineTypeOfWord ( $ word ) ; if ( $ type == self :: OPTION_TYPE ) { list ( $ key , $ defaultValue ) = self :: parse ( $ word ) ; $ options [ $ key ] = $ defaultValue ; } elseif ( $ type == self :: ARGUMENT_TYPE ) { list ( $ key , $ defaultValue ) = self :: parse ( $ word ) ; $ arguments [ $ key ] = $ defaultValue ; } } return [ $ command , $ arguments , $ options ] ; }
909	private function getHeaderAsComment ( ) { $ lineEnding = $ this -> whitespacesConfig -> getLineEnding ( ) ; $ comment = ( self :: HEADER_COMMENT === $ this -> configuration [ 'comment_type' ] ? '/*' : '/**' ) . $ lineEnding ; $ lines = explode ( "\n" , str_replace ( "\r" , '' , $ this -> configuration [ 'header' ] ) ) ; foreach ( $ lines as $ line ) { $ comment .= rtrim ( ' * ' . $ line ) . $ lineEnding ; } return $ comment . ' */' ; }
10785	public function runQuery ( \ Peyote \ Query $ query ) { return $ this -> run ( $ query -> compile ( ) , $ query -> getParams ( ) ) ; }
3572	public function set ( $ key , $ value = null , $ group = null ) { if ( $ key instanceof Attribute ) { return $ this -> setInstance ( $ key ) ; } if ( $ this -> has ( $ key ) ) { $ this -> update ( $ key , $ value , $ group ) ; } else { $ this -> items [ $ key ] = $ this -> newAttribute ( $ key , $ value , $ group ) ; } return $ this ; }
8945	public function replacePreferences ( $ preferences ) { $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = 'user/preferences' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ preferenceList = '' ; if ( ! empty ( $ preferences ) ) { foreach ( $ preferences as $ key => $ value ) { $ preferenceList .= '<preference k="' . $ key . '" v="' . $ value . '"/>' ; } } $ xml = '<?xml version="1.0" encoding="UTF-8"?> <osm version="0.6" generator="JoomlaOpenStreetMap"> <preferences>' . $ preferenceList . '</preferences> </osm>' ; $ header [ 'Content-Type' ] = 'text/xml' ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'PUT' , $ parameters , $ xml , $ header ) ; return $ response -> body ; }
8263	protected function onStateMismatch ( ) { $ this -> logger -> warning ( "OAuth2 response state mismatch: provider: {provider} from {addr}" , array ( "provider" => get_class ( $ this -> provider ) , "addr" => $ _SERVER [ 'REMOTE_ADDR' ] ) ) ; $ this -> session -> remove ( "oauth2state" ) ; $ this -> session -> addFlash ( "error" , "Invalid OAuth response." ) ; $ this -> picoAuth -> redirectToLogin ( ) ; }
9534	private function parseQuote ( & $ argv , $ argument , $ quoteType ) { if ( substr ( $ argument , strlen ( $ argument ) - 1 , 1 ) !== $ quoteType ) { $ this -> argv [ ] = substr ( $ argument , 1 ) ; while ( ( $ argument_part = array_shift ( $ argv ) ) != null && substr ( $ argument_part , strlen ( $ argument_part ) - 1 , 1 ) !== $ quoteType ) { $ this -> argv [ count ( $ this -> argv ) - 1 ] .= ' ' . $ argument_part ; } $ this -> argv [ count ( $ this -> argv ) - 1 ] .= ' ' . substr ( $ argument_part , 0 , strlen ( $ argument_part ) - 1 ) ; } else { $ this -> argv [ ] = substr ( substr ( $ argument , 1 ) , 0 , strlen ( $ argument ) - 2 ) ; } }
11692	private function buildParsedRequests ( ApiParseResult $ parseResult ) : array { $ requests = [ ] ; foreach ( $ parseResult -> getApi ( ) -> getResourceGroups ( ) as $ apiResourceGroup ) { foreach ( $ apiResourceGroup -> getResources ( ) as $ apiResource ) { foreach ( $ apiResource -> getTransitions ( ) as $ apiStateTransition ) { foreach ( $ apiStateTransition -> getHttpTransactions ( ) as $ apiHttpTransaction ) { $ this -> processApiHttpTransactions ( $ apiHttpTransaction , $ apiResourceGroup , $ apiResource , $ apiStateTransition , $ requests ) ; } } } } return $ requests ; }
5647	public function paintCaseEnd ( $ test_name ) { $ numberOfReporters = count ( $ this -> reporters ) ; for ( $ i = 0 ; $ i < $ numberOfReporters ; $ i ++ ) { $ this -> reporters [ $ i ] -> paintCaseEnd ( $ test_name ) ; } }
9104	protected function parse_user ( ) { if ( ! empty ( $ this -> args [ 'user' ] ) ) { $ this -> args [ 'user__in' ] = array ( $ this -> args [ 'user' ] ) ; } return $ this -> parse_in_or_not_in_query ( 'user' , $ this -> args [ 'user__in' ] , $ this -> args [ 'user__not_in' ] ) ; }
4391	public function getConfigBE ( ) { $ list = [ ] ; foreach ( $ this -> beConfig as $ key => $ config ) { $ list [ $ key ] = new \ Aimeos \ MW \ Criteria \ Attribute \ Standard ( $ config ) ; } return $ list ; }
5153	public function addConfiguration ( $ configuration , $ configure = true ) { if ( ! $ configuration instanceof ConfigurationInterface ) { $ configuration = new Configuration ( $ configuration ) ; } $ config = $ this -> getConfiguration ( ) ; if ( $ config instanceof ConfigurationInterface ) { $ config -> merge ( $ configuration ) ; } if ( $ config === null ) { $ config = $ configuration ; } $ this -> setConfiguration ( $ config , $ configure ) ; }
6579	public function setParts ( array $ parts ) { $ parts = array_intersect_key ( $ parts , $ this -> params ) ; if ( isset ( $ parts [ 'port' ] ) ) $ parts [ 'port' ] = ( int ) $ parts [ 'port' ] ; if ( isset ( $ parts [ 'query' ] ) ) { $ query = $ this -> _parse_str ( $ parts [ 'query' ] ) ; $ this -> _rksort ( $ query ) ; $ parts [ 'query' ] = $ query ; } array_walk ( $ parts , function ( & $ part , $ key ) { if ( is_string ( $ part ) ) { $ part = strlen ( $ part ) ? $ part : null ; } else { $ part = $ part ? : null ; } } ) ; $ self = clone $ this ; $ self -> params = array_replace ( $ this -> params , $ parts ) ; return $ self ; }
4251	protected function methodTable ( $ array , $ columns = array ( ) ) { if ( ! \ is_array ( $ array ) ) { return $ this -> dump ( $ array ) ; } $ table = array ( ) ; $ keys = $ columns ? : $ this -> debug -> methodTable -> colKeys ( $ array ) ; $ headerVals = $ keys ; foreach ( $ headerVals as $ i => $ val ) { if ( $ val === MethodTable :: SCALAR ) { $ headerVals [ $ i ] = 'value' ; } } \ array_unshift ( $ headerVals , '' ) ; $ table [ ] = $ headerVals ; $ classNames = array ( ) ; if ( $ this -> debug -> abstracter -> isAbstraction ( $ array ) && $ array [ 'traverseValues' ] ) { $ array = $ array [ 'traverseValues' ] ; } foreach ( $ array as $ k => $ row ) { $ values = $ this -> debug -> methodTable -> keyValues ( $ row , $ keys , $ objInfo ) ; foreach ( $ values as $ k2 => $ val ) { if ( $ val === $ this -> debug -> abstracter -> UNDEFINED ) { $ values [ $ k2 ] = null ; } } $ classNames [ ] = $ objInfo [ 'row' ] ? $ objInfo [ 'row' ] [ 'className' ] : '' ; \ array_unshift ( $ values , $ k ) ; $ table [ ] = \ array_values ( $ values ) ; } if ( \ array_filter ( $ classNames ) ) { \ array_unshift ( $ table [ 0 ] , '' ) ; foreach ( $ classNames as $ i => $ className ) { \ array_splice ( $ table [ $ i + 1 ] , 1 , 0 , $ className ) ; } } return $ table ; }
8991	public function build ( $ attributes = null ) { if ( $ attributes instanceof \ ElggEntity ) { return $ attributes ; } if ( is_numeric ( $ attributes ) ) { return $ this -> get ( $ attributes ) ; } $ attributes = ( array ) $ attributes ; if ( ! empty ( $ attributes [ 'guid' ] ) ) { return $ this -> get ( $ attributes [ 'guid' ] ) ; } $ type = elgg_extract ( 'type' , $ attributes , 'object' ) ; $ subtype = elgg_extract ( 'subtype' , $ attributes , ELGG_ENTITIES_ANY_VALUE ) ; unset ( $ attributes [ 'type' ] ) ; unset ( $ attributes [ 'subtype' ] ) ; $ class = get_subtype_class ( $ type , $ subtype ) ; if ( class_exists ( $ class ) ) { $ entity = new $ class ( ) ; } else { switch ( $ type ) { case 'object' : $ entity = new \ ElggObject ( ) ; $ entity -> subtype = $ subtype ; break ; case 'user' : $ entity = new \ ElggUser ( ) ; $ entity -> subtype = $ subtype ; break ; case 'group' : $ entity = new \ ElggGroup ( ) ; $ entity -> subtype = $ subtype ; break ; } } foreach ( $ attributes as $ key => $ value ) { if ( in_array ( $ key , $ this -> getAttributeNames ( $ entity ) ) ) { $ entity -> $ key = $ value ; } } return $ entity ; }
10492	public function sub ( $ value ) { $ value = Cast :: Float ( $ value ) ; if ( $ this -> value === null ) { return new FloatType ( $ this -> value ) ; } return new FloatType ( $ this -> value - $ value ) ; }
8346	public static function route ( $ method , $ path , $ action ) { if ( self :: $ isInit === true ) { self :: $ routes [ ] = array ( 'type' => 'route' , 'method' => $ method , 'path' => $ path , 'action' => $ action , 'namespace' => self :: $ namespace , 'subdomain' => self :: $ subdomain , 'uri' => self :: $ uri ) ; } }
771	public function actionConfig ( $ filePath ) { $ filePath = Yii :: getAlias ( $ filePath ) ; $ dir = dirname ( $ filePath ) ; if ( file_exists ( $ filePath ) ) { if ( ! $ this -> confirm ( "File '{$filePath}' already exists. Do you wish to overwrite it?" ) ) { return ExitCode :: OK ; } } $ array = VarDumper :: export ( $ this -> getOptionValues ( $ this -> action -> id ) ) ; $ content = <<<EOD<?php/** * Configuration file for 'yii {$this->id}/{$this->defaultAction}' command. * * This file is automatically generated by 'yii {$this->id}/{$this->action->id}' command. * It contains parameters for source code messages extraction. * You may modify this file to suit your needs. * * You can use 'yii {$this->id}/{$this->action->id}-template' command to create * template configuration file with detailed description for each parameter. */return $array;EOD ; if ( FileHelper :: createDirectory ( $ dir ) === false || file_put_contents ( $ filePath , $ content , LOCK_EX ) === false ) { $ this -> stdout ( "Configuration file was NOT created: '{$filePath}'.\n\n" , Console :: FG_RED ) ; return ExitCode :: UNSPECIFIED_ERROR ; } $ this -> stdout ( "Configuration file created: '{$filePath}'.\n\n" , Console :: FG_GREEN ) ; return ExitCode :: OK ; }
3653	public static function render ( $ strTemplate , $ strOutputFormat , $ arrTplData , $ blnFailIfNotFound = false ) { $ objTemplate = new self ( $ strTemplate ) ; $ objTemplate -> setData ( $ arrTplData ) ; return $ objTemplate -> parse ( $ strOutputFormat , $ blnFailIfNotFound ) ; }
3738	private function getConnection ( ) { if ( $ this -> connection ) { return $ this -> connection ; } $ reflection = new \ ReflectionProperty ( \ Contao \ Database :: class , 'resConnection' ) ; $ reflection -> setAccessible ( true ) ; return $ this -> connection = $ reflection -> getValue ( $ this -> getDatabase ( ) ) ; }
1512	public function read ( StoreInterface $ store , FetchResource $ request ) { $ result = $ this -> doRead ( $ store , $ request ) ; if ( $ this -> isResponse ( $ result ) ) { return $ result ; } return $ this -> reply ( ) -> content ( $ result ) ; }
6281	public static function buildDnsResolver ( LoopInterface $ loop , $ dns = '8.8.8.8' ) { $ factory = new DnsResolverFactory ( ) ; return $ factory -> createCached ( $ dns , $ loop ) ; }
4697	public static function validate ( $ request_data = array ( ) , $ token_name = self :: TOKEN_NAME ) { if ( empty ( $ _SESSION [ $ token_name ] ) ) { static :: generateToken ( $ token_name ) ; return false ; } elseif ( empty ( $ request_data [ $ token_name ] ) ) { return false ; } else { if ( static :: compare ( $ request_data [ $ token_name ] , static :: getToken ( $ token_name ) ) ) { static :: generateToken ( $ token_name ) ; return true ; } else { return false ; } } }
10424	public function parseXml ( $ xml ) { if ( is_null ( $ xml ) ) { return null ; } $ xml = new QuiteSimpleXMLElement ( $ xml ) ; $ xml -> registerXPathNamespaces ( $ this -> namespaces ) ; return $ xml ; }
10517	private function getMediaIdentifiers ( $ values ) { $ identifiers = [ ] ; foreach ( $ values as $ key => $ id ) { if ( is_int ( $ key ) ) { $ identifiers [ ] = $ id ; } } return $ identifiers ; }
9283	private function needsCompilation ( $ lessPath , $ cssPath ) { $ isNewer = function ( $ subject , $ reference ) { return filemtime ( $ subject ) > filemtime ( $ reference ) ; } ; if ( $ this -> forceCompile || ! file_exists ( $ lessPath ) || ! file_exists ( $ cssPath ) || $ isNewer ( $ lessPath , $ cssPath ) ) { return true ; } return $ this -> checkImports ( $ lessPath , $ cssPath , $ isNewer ) ; }
1603	private function _getVariables ( ) { $ variables = $ this -> _overrideObject ; if ( $ this -> _element !== null ) { foreach ( $ this -> _element -> attributes ( ) as $ name ) if ( $ name !== $ this -> _handle ) $ variables [ $ name ] = $ this -> _element -> $ name ; $ variables = array_merge ( $ variables , $ this -> _element -> toArray ( $ this -> _element -> extraFields ( ) ) ) ; } return $ variables ; }
3551	public function parse ( InlineParserContext $ inlineContext ) { $ cursor = $ inlineContext -> getCursor ( ) ; $ previous = $ cursor -> peek ( - 1 ) ; if ( $ previous !== null && $ previous !== ' ' ) { return false ; } $ saved = $ cursor -> saveState ( ) ; $ cursor -> advance ( ) ; $ handle = $ cursor -> match ( '/^[a-z0-9\+\-_]+:/' ) ; if ( ! $ handle ) { $ cursor -> restoreState ( $ saved ) ; return false ; } $ next = $ cursor -> peek ( 0 ) ; if ( $ next !== null && $ next !== ' ' ) { $ cursor -> restoreState ( $ saved ) ; return false ; } $ key = substr ( $ handle , 0 , - 1 ) ; if ( $ this -> map === null ) { $ this -> map = $ this -> repo -> get ( ) ; } if ( ! array_key_exists ( $ key , $ this -> map ) ) { $ cursor -> restoreState ( $ saved ) ; return false ; } $ inline = new Image ( $ this -> map [ $ key ] , $ key ) ; $ inline -> data [ 'attributes' ] = [ 'class' => 'emoji' , 'data-emoji' => $ key ] ; $ inlineContext -> getContainer ( ) -> appendChild ( $ inline ) ; return true ; }
1765	public function colorize ( $ row , $ label ) { switch ( $ row [ 'action' ] ) { case 'CONFIGURATION' : case 'REPOSITORY' : $ label = preg_replace ( '@^(.*</span> )(.*)$@U' , '$1 <span class="tl_blue">$2</span>' , $ label ) ; break ; case 'CRON' : $ label = preg_replace ( '@^(.*</span> )(.*)$@U' , '$1 <span class="tl_green">$2</span>' , $ label ) ; break ; case 'ERROR' : $ label = preg_replace ( '@^(.*</span> )(.*)$@U' , '$1 <span class="tl_red">$2</span>' , $ label ) ; break ; default : if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'colorizeLogEntries' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'colorizeLogEntries' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'colorizeLogEntries' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ label = $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ row , $ label ) ; } } break ; } return '<div class="ellipsis">' . $ label . '</div>' ; }
12769	public function getDb ( ) { if ( is_null ( $ this -> _db ) ) { if ( ! isset ( $ this -> dbConfig [ 'class' ] ) ) { $ this -> dbConfig [ 'class' ] = 'cascade\components\dataInterface\connectors\db\Connection' ; } $ this -> _db = Yii :: createObject ( $ this -> dbConfig ) ; $ this -> _db -> open ( ) ; } if ( empty ( $ this -> _db ) || ! $ this -> _db -> isActive ) { throw new Exception ( "Unable to connect to foreign database." ) ; } return $ this -> _db ; }
7441	protected function hasAccessToAction ( $ packageKey , $ subpackageKey , $ controllerName , $ actionName ) { $ actionControllerName = $ this -> router -> getControllerObjectName ( $ packageKey , $ subpackageKey , $ controllerName ) ; try { return $ this -> privilegeManager -> isGranted ( 'Neos\Flow\Security\Authorization\Privilege\Method\MethodPrivilege' , new MethodPrivilegeSubject ( new JoinPoint ( NULL , $ actionControllerName , $ actionName . 'Action' , array ( ) ) ) ) ; } catch ( AccessDeniedException $ e ) { return FALSE ; } }
939	public function isWhitespace ( $ whitespaces = " \t\n\r\0\x0B" ) { if ( null === $ whitespaces ) { $ whitespaces = " \t\n\r\0\x0B" ; } if ( $ this -> isArray && ! $ this -> isGivenKind ( T_WHITESPACE ) ) { return false ; } return '' === trim ( $ this -> content , $ whitespaces ) ; }
11791	public function setFrom ( $ mail = '' , $ name = null , $ reply = true ) { $ mail = trim ( $ mail ) ; if ( strlen ( $ mail ) && Helper :: isEmail ( $ mail ) ) { $ this -> from = ! empty ( $ name ) ? array ( $ name => $ mail ) : array ( $ mail ) ; $ this -> getMailer ( ) -> setRegistry ( 'Return-Path' , '<' . $ mail . '>' , 'headers' ) ; $ this -> getMailer ( ) -> setRegistry ( 'X-Sender' , $ mail , 'headers' ) ; if ( $ reply ) { $ this -> setReplyTo ( $ mail , $ name ) ; } } return $ this ; }
4841	public function fetch_sub_resource ( $ type , $ params = array ( ) ) { $ endpoint = preg_replace ( '/api\/v[0-9]+\//' , '' , parse_url ( $ this -> sub_resource_uris [ $ type ] , PHP_URL_PATH ) ) ; $ sub_resource_params = array ( ) ; if ( $ param_string = parse_url ( $ this -> sub_resource_uris [ $ type ] , PHP_URL_QUERY ) ) { $ split_params = explode ( '&' , $ param_string ) ; foreach ( $ split_params as $ split_param ) { $ parts = explode ( '=' , $ split_param ) ; $ sub_resource_params [ $ parts [ 0 ] ] = $ parts [ 1 ] ; } } $ params = array_merge ( $ params , $ sub_resource_params ) ; $ class = 'GoCardless_' . GoCardless_Utils :: camelize ( GoCardless_Utils :: singularize ( $ type ) ) ; $ objects = array ( ) ; foreach ( $ this -> client -> request ( 'get' , $ endpoint , $ params ) as $ value ) { $ objects [ ] = new $ class ( $ this -> client , $ value ) ; } return $ objects ; }
5627	public function asString ( ) { $ path = $ this -> path ; $ scheme = $ identity = $ host = $ port = $ encoded = $ fragment = '' ; if ( $ this -> username && $ this -> password ) { $ identity = $ this -> username . ':' . $ this -> password . '@' ; } if ( $ this -> getHost ( ) ) { $ scheme = $ this -> getScheme ( ) ? $ this -> getScheme ( ) : 'http' ; $ scheme .= '://' ; $ host = $ this -> getHost ( ) ; } elseif ( $ this -> getScheme ( ) === 'file' ) { $ scheme = 'file://' ; } if ( $ this -> getPort ( ) && $ this -> getPort ( ) != 80 ) { $ port = ':' . $ this -> getPort ( ) ; } if ( substr ( $ this -> path , 0 , 1 ) == '/' ) { $ path = $ this -> normalisePath ( $ this -> path ) ; } $ encoded = $ this -> getEncodedRequest ( ) ; $ fragment = $ this -> getFragment ( ) ? '#' . $ this -> getFragment ( ) : '' ; $ coords = $ this -> getX ( ) === false ? '' : '?' . $ this -> getX ( ) . ',' . $ this -> getY ( ) ; return "$scheme$identity$host$port$path$encoded$fragment$coords" ; }
8063	protected function reaper ( $ pid = - 1 ) { if ( ! is_int ( $ pid ) ) { $ pid = - 1 ; } $ childpid = pcntl_waitpid ( $ pid , $ status , WNOHANG ) ; while ( $ childpid > 0 ) { $ stopSignal = pcntl_wstopsig ( $ status ) ; if ( pcntl_wifexited ( $ stopSignal ) === FALSE ) { array_push ( $ this -> results , array ( 'pid' => $ childpid , 'abnormalChildReturnCode' => $ stopSignal ) ) ; } $ processDetails = $ this -> workerProcesses -> getProcessDetails ( $ childpid ) ; if ( $ processDetails !== NULL ) { $ this -> workerPoolSize -- ; $ this -> workerProcesses -> remove ( $ processDetails ) ; unset ( $ processDetails ) ; } $ childpid = pcntl_waitpid ( $ pid , $ status , WNOHANG ) ; } }
9152	public function view ( $ vars = array ( ) ) { $ output = '' ; $ vars [ 'entity' ] = $ this -> entity ; foreach ( $ this -> fields as $ field ) { if ( ! $ field instanceof Field ) { continue ; } if ( $ field -> getOutputView ( ) === false ) { continue ; } if ( $ field -> getType ( ) == 'hidden' || $ field -> getValueType ( ) == 'hidden' ) { continue ; } if ( $ field -> isHiddenOnProfile ( ) ) { continue ; } $ field_view = $ field -> viewOutput ( $ vars ) ; if ( $ field_view ) { $ output .= elgg_format_element ( 'div' , array ( 'class' => 'prototyper-output' , ) , $ field_view ) ; } } return $ output ; }
140	public function markAliasInstalled ( RepositoryInterface $ repo , MarkAliasInstalledOperation $ operation ) { $ package = $ operation -> getPackage ( ) ; if ( ! $ repo -> hasPackage ( $ package ) ) { $ repo -> addPackage ( clone $ package ) ; } }
9163	private function getHeader ( string $ name ) : string { $ result = "" ; if ( Arrays :: hasElement ( $ this -> headers , $ name ) ) { $ result = $ this -> headers [ $ name ] ; } return $ result ; }
3096	public function process ( ) { $ this -> validate ( ) ; $ itemIdentifier = $ this -> hasRequestParameter ( 'itemDefinition' ) ? $ this -> getRequestParameter ( 'itemDefinition' ) : null ; if ( ! is_array ( $ itemIdentifier ) ) { $ itemIdentifier = [ $ itemIdentifier ] ; } try { if ( ! $ this -> getRunnerService ( ) -> getTestConfig ( ) -> getConfigValue ( 'itemCaching.enabled' ) ) { common_Logger :: w ( 'Attempt to disclose the next items without the configuration' ) ; throw new common_exception_Unauthorized ( ) ; } $ response = [ ] ; foreach ( $ itemIdentifier as $ itemId ) { $ response [ 'items' ] [ ] = $ this -> getItemData ( $ itemId ) ; } if ( isset ( $ response [ 'items' ] ) ) { $ response [ 'success' ] = true ; } } catch ( \ Exception $ e ) { $ response = $ this -> getErrorResponse ( $ e ) ; } return $ response ; }
1888	public function generateAjax ( $ id , $ strField , $ level ) { if ( ! Environment :: get ( 'isAjaxRequest' ) ) { return '' ; } $ this -> strField = $ strField ; $ this -> loadDataContainer ( $ this -> strTable ) ; switch ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'dataContainer' ] ) { case 'File' : if ( Config :: get ( $ this -> strField ) != '' ) { $ this -> varValue = Config :: get ( $ this -> strField ) ; } break ; case 'Table' : if ( ! $ this -> Database -> fieldExists ( $ this -> strField , $ this -> strTable ) ) { break ; } $ objField = $ this -> Database -> prepare ( "SELECT " . Database :: quoteIdentifier ( $ this -> strField ) . " FROM " . $ this -> strTable . " WHERE id=?" ) -> limit ( 1 ) -> execute ( $ this -> strId ) ; if ( $ objField -> numRows ) { $ this -> varValue = StringUtil :: deserialize ( $ objField -> { $ this -> strField } ) ; } break ; } $ this -> getPathNodes ( ) ; $ tree = '' ; $ level *= 20 ; $ objPage = $ this -> Database -> prepare ( "SELECT id FROM tl_page WHERE pid=? ORDER BY sorting" ) -> execute ( $ id ) ; while ( $ objPage -> next ( ) ) { $ tree .= $ this -> renderPagetree ( $ objPage -> id , $ level ) ; } return $ tree ; }
5052	public function getContentType ( ) { if ( ! $ this -> contentType ) { $ this -> setContentType ( $ this -> getParam ( 'contentType' ) ? : static :: TYPE_JSON ) ; } return $ this -> contentType ; }
4341	public function end ( ) { \ unregister_tick_function ( array ( $ this , 'tickFunction' ) ) ; while ( $ this -> funcStack ) { $ this -> popStack ( ) ; } \ uasort ( $ this -> data , function ( $ valA , $ valB ) { return ( $ valA [ 'totalTime' ] < $ valB [ 'totalTime' ] ) ? 1 : - 1 ; } ) ; $ data = \ array_map ( function ( $ row ) { $ row [ 'totalTime' ] = \ round ( $ row [ 'totalTime' ] , 6 ) ; $ row [ 'ownTime' ] = \ round ( $ row [ 'ownTime' ] , 6 ) ; return $ row ; } , $ this -> data ) ; $ this -> data = array ( ) ; $ this -> funcStack = array ( ) ; $ this -> isProfiling = false ; $ this -> rootStack = array ( ) ; return $ data ; }
9367	public function equal ( $ z ) { if ( is_numeric ( $ z ) ) { $ z = new self ( $ z , 0 ) ; } return ( $ z -> real == $ this -> float_r ) && ( $ z -> imaginary == $ this -> float_i ) ; }
12392	public function getPages ( $ startPage , $ endPage , $ urlStub ) { $ pages = [ ] ; for ( $ x = $ startPage ; $ x <= $ endPage ; $ x ++ ) { $ pages [ ] = $ urlStub . $ x ; } return $ pages ; }
8499	public function updateFulfillmentOrder ( $ request ) { if ( ! ( $ request instanceof FBAOutboundServiceMWS_Model_UpdateFulfillmentOrderRequest ) ) { $ request = new FBAOutboundServiceMWS_Model_UpdateFulfillmentOrderRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'UpdateFulfillmentOrder' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAOutboundServiceMWS_Model_UpdateFulfillmentOrderResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
7733	public function onKernelView ( GetResponseForControllerResultEvent $ event ) { $ request = $ event -> getRequest ( ) ; $ result = $ event -> getControllerResult ( ) ; if ( ! $ request -> attributes -> get ( '__hydra_serialize' ) ) { return ; } if ( is_array ( $ result ) || ( $ result instanceof \ ArrayAccess ) || ( $ result instanceof \ Traversable ) ) { $ result = new Collection ( $ request -> getUri ( ) , $ result ) ; } elseif ( null === $ result ) { $ event -> setResponse ( new JsonLdResponse ( '' , 200 ) ) ; return ; } elseif ( ! is_object ( $ result ) ) { throw new \ Exception ( "A Hydra controller must return either an array or an object, got a(n) " . gettype ( $ result ) ) ; } $ serialized = $ this -> serializer -> serialize ( $ result , 'jsonld' ) ; $ event -> setResponse ( new JsonLdResponse ( $ serialized ) ) ; }
7049	protected function buildGoodsLines ( Document \ DocumentInterface $ document ) { foreach ( $ document -> getSale ( ) -> getItems ( ) as $ item ) { $ this -> buildGoodLine ( $ item , $ document ) ; } }
3495	public function add ( HttpProtocolVisitorInterface $ visitor , int $ priority = 0 ) : void { $ this -> visitors -> insert ( $ visitor , $ priority ) ; }
12585	static function run_convert_configuration ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { self :: setConfigDir ( $ cliopts ) ; $ extname = @ $ args [ 0 ] ; if ( $ extname == '' ) { $ extname = dirname ( __FILE__ ) ; } while ( ! is_file ( "ant/$extname.properties" ) ) { $ extname = pake_input ( 'What is the name of the current extension?' ) ; if ( ! is_file ( "ant/$extname.properties" ) ) { pake_echo ( "File ant/$extname.properties not found" ) ; } } self :: convertPropertyFileToYamlFile ( "ant/$extname.properties" , self :: getConfigDir ( ) . "/options-$extname.yaml" , array ( $ extname => '' , 'external' => 'dependencies' , 'dependency' => 'extensions' , 'repository' => array ( 'svn' , 'url' ) ) , "extension:\n name: $extname\n\n" ) ; foreach ( array ( 'files.to.parse.txt' => 'to_parse' , 'files.to.exclude.txt' => 'to_exclude' ) as $ file => $ option ) { $ src = "ant/$file" ; if ( file_exists ( $ src ) ) { if ( count ( $ in = file ( $ src , FILE_SKIP_EMPTY_LINES | FILE_IGNORE_NEW_LINES ) ) ) { $ in = "\n\nfiles:\n $option: [" . implode ( ', ' , $ in ) . "]\n" ; file_put_contents ( self :: getConfigDir ( ) . "options-$extname.yaml" , $ in , FILE_APPEND ) ; } } } }
3695	protected function getBreadcrumbElements ( EnvironmentInterface $ environment , BreadcrumbStore $ elements ) { if ( $ this -> parent ) { $ this -> parent -> getBreadcrumbElements ( $ environment , $ elements ) ; } }
2096	public function getWeekBegin ( $ intStartDay = 0 ) { $ intOffset = date ( 'w' , $ this -> strDate ) - $ intStartDay ; if ( $ intOffset < 0 ) { $ intOffset += 7 ; } return strtotime ( '-' . $ intOffset . ' days' , $ this -> strDate ) ; }
11436	private function _removeDirectory ( $ sName ) { if ( $ rDirectory = opendir ( $ sName ) ) { while ( ( $ sFile = readdir ( $ rDirectory ) ) !== false ) { if ( $ sFile > '0' && filetype ( $ sName . $ sFile ) == "file" ) { unlink ( $ sName . $ sFile ) ; } elseif ( $ sFile > '0' && filetype ( $ sName . $ sFile ) == "dir" ) { remove_dir ( $ sName . $ sFile . "\\" ) ; } } closedir ( $ rDirectory ) ; rmdir ( $ sName ) ; } }
9310	protected function doPostAction ( $ uri , array $ data = [ ] ) { $ this -> setActionUri ( $ uri ) ; try { $ response = $ this -> client -> post ( $ this -> uri , [ 'json' => $ data ] ) ; } catch ( ClientException $ e ) { $ response = $ e -> getResponse ( ) ; } catch ( ServerException $ e ) { $ response = $ e -> getResponse ( ) ; } return $ this -> responseToJson ( $ response ) ; }
12081	public function deleteChild ( $ idParent , FilterRequest $ filters , $ idChild , $ relation ) { $ idParent = $ this -> getRealId ( $ idParent ) ; $ idChild = $ this -> getRealId ( $ idChild ) ; $ resource = $ this -> repository -> deleteChild ( $ idParent , $ relation , $ idChild ) ; if ( $ resource == null ) { } return $ this -> success ( ) ; }
9959	public function unprotectCellsByColumnAndRow ( $ columnIndex1 , $ row1 , $ columnIndex2 , $ row2 ) { $ cellRange = Coordinate :: stringFromColumnIndex ( $ columnIndex1 ) . $ row1 . ':' . Coordinate :: stringFromColumnIndex ( $ columnIndex2 ) . $ row2 ; return $ this -> unprotectCells ( $ cellRange ) ; }
3585	protected function getMetaOperator ( $ method , ArgumentBag $ args ) { if ( $ not = $ args -> get ( 'not' ) ) { $ args -> set ( 'not' , false ) ; } return ( $ not ^ $ this -> isWhereNull ( $ method , $ args ) ) ? '<' : '>=' ; }
2816	public function getCollectionsAsArray ( ) { $ data = array ( ) ; foreach ( $ this -> getCollections ( ) as $ collection ) { $ data [ ] = array ( 'type' => $ collection -> getType ( ) , 'class' => $ collection -> getClass ( ) , 'sql' => $ collection -> getQuery ( ) , 'count' => $ collection -> getCount ( ) ) ; } return $ data ; }
9582	public function getFieldValidationOptions ( ) { $ min = ( $ this -> getSetting ( 'MinValue' ) ) ? $ this -> getSetting ( 'MinValue' ) : '' ; $ max = ( $ this -> getSetting ( 'MaxValue' ) ) ? $ this -> getSetting ( 'MaxValue' ) : '' ; return [ new NumericField ( $ this -> getSettingName ( 'MinValue' ) , _t ( 'Moo_EditableField.MINVALUE' , 'Min Value' ) , $ min ) , new NumericField ( $ this -> getSettingName ( 'MaxValue' ) , _t ( 'Moo_EditableField.MAXVALUE' , 'Max Value' ) , $ max ) , ] ; }
3396	public function toMail ( $ notifiable ) { return ( new MailMessage ) -> subject ( __ ( 'confirmation::confirmation.confirmation_subject' ) ) -> line ( __ ( 'confirmation::confirmation.confirmation_subject_title' ) ) -> line ( __ ( 'confirmation::confirmation.confirmation_body' ) ) -> action ( __ ( 'confirmation::confirmation.confirmation_button' ) , url ( "register/confirm/$notifiable->confirmation_code" ) ) ; }
8234	protected function isExpired ( array $ tokenData , $ tokenValidity = null ) { return time ( ) > $ tokenData [ 'time' ] + ( ( $ tokenValidity !== null ) ? $ tokenValidity : self :: TOKEN_VALIDITY ) ; }
12969	public function transformFromFront ( array $ array ) { $ transformation = $ this -> getTransformation ( ) ; $ fillables = $ this -> getFillable ( ) ; $ transformed = [ ] ; foreach ( $ fillables as $ name ) { if ( ! key_exists ( $ name , $ array ) ) { continue ; } $ transformed [ $ name ] = $ array [ $ name ] ; } foreach ( $ transformation as $ name => $ new_name ) { if ( ! key_exists ( $ new_name , $ array ) ) { continue ; } $ transformed [ $ name ] = $ array [ $ new_name ] ; } return $ transformed ; }
7126	static public function copy ( AddressInterface $ source , AddressInterface $ target ) { $ target -> setCompany ( $ source -> getCompany ( ) ) -> setGender ( $ source -> getGender ( ) ) -> setFirstName ( $ source -> getFirstName ( ) ) -> setLastName ( $ source -> getLastName ( ) ) -> setStreet ( $ source -> getStreet ( ) ) -> setComplement ( $ source -> getComplement ( ) ) -> setSupplement ( $ source -> getSupplement ( ) ) -> setExtra ( $ source -> getExtra ( ) ) -> setCity ( $ source -> getCity ( ) ) -> setPostalCode ( $ source -> getPostalCode ( ) ) -> setCountry ( $ source -> getCountry ( ) ) -> setState ( $ source -> getState ( ) ) -> setDigicode1 ( $ source -> getDigicode1 ( ) ) -> setDigicode2 ( $ source -> getDigicode2 ( ) ) -> setIntercom ( $ source -> getIntercom ( ) ) -> setLatitude ( $ source -> getLatitude ( ) ) -> setLongitude ( $ source -> getLongitude ( ) ) ; if ( is_object ( $ phone = $ source -> getPhone ( ) ) ) { $ target -> setPhone ( clone $ phone ) ; } else { $ target -> setPhone ( $ phone ) ; } if ( is_object ( $ mobile = $ source -> getMobile ( ) ) ) { $ target -> setMobile ( clone $ mobile ) ; } else { $ target -> setMobile ( $ mobile ) ; } }
6121	public function permissionGetIdByName ( $ name ) { if ( ! array_key_exists ( ( string ) $ name , $ this -> permissionList ( ) ) ) { throw new Ts3Exception ( "invalid permission ID" , 0xA02 ) ; } return $ this -> permissionList [ ( string ) $ name ] [ "permid" ] ; }
6175	public function rightJoin ( $ table , $ column , $ operator = null , $ value = null ) { if ( $ column instanceof \ Closure ) { $ where = new Where ( ) ; call_user_func_array ( $ column , [ & $ where ] ) ; } else { $ where = ( new Where ( ) ) -> where ( $ column , $ operator , $ value ) ; } $ this -> request [ 'rightJoin' ] [ $ table ] [ 'table' ] = $ table ; $ this -> request [ 'rightJoin' ] [ $ table ] [ 'where' ] = $ where ; return $ this ; }
9119	public function registerController ( $ controller , $ applicationName = 'default' ) { if ( ! $ controller instanceof \ Nkey \ Caribu \ Mvc \ Controller \ AbstractController ) { if ( ! class_exists ( $ controller ) ) { throw new ControllerException ( "No such controller class {controller} found" , array ( 'controller' => $ controller ) ) ; } $ c = new $ controller ( ) ; if ( ! ( $ c instanceof AbstractController ) ) { throw new ControllerException ( "Controller {controller} is not in application scope" , array ( 'controller' => $ controller ) ) ; } } else { $ c = $ controller ; } $ settings = $ c -> getControllerSettings ( ) ; $ this -> controllers [ $ applicationName ] [ $ settings -> getControllerSimpleName ( ) ] = $ settings ; return $ this ; }
9012	public function text ( string $ charset = null ) : self { $ this -> type = 'text' . $ this -> stringOptions ( $ charset ) ; return $ this ; }
4555	protected function addJoinTranslation ( QueryBuilder $ queryBuilder , string $ resourceClass ) { $ rootAlias = $ queryBuilder -> getRootAliases ( ) [ 0 ] ; $ translationAlias = $ rootAlias . '_t' ; $ translationClass = call_user_func ( $ resourceClass . '::getTranslationEntityClass' ) ; $ parts = $ queryBuilder -> getDQLParts ( ) [ 'join' ] ; foreach ( $ parts as $ joins ) { foreach ( $ joins as $ join ) { if ( $ translationAlias === $ join -> getAlias ( ) ) { return $ translationAlias ; } } } $ queryBuilder -> leftJoin ( $ translationClass , $ translationAlias , Join :: WITH , $ rootAlias . '.id = ' . $ translationAlias . '.translatable' ) ; return $ translationAlias ; }
4889	public function viewAction ( Request $ request , $ id ) { $ pageManager = $ this -> getPageManager ( ) ; $ page = $ pageManager -> findForView ( $ id ) ; if ( null !== ( $ validator = $ this -> getViewActionValidator ( ) ) ) { $ validator -> validate ( $ page ) ; } if ( $ page instanceof ControllerPageInterface ) { return $ this -> forward ( $ page -> getController ( ) , ( array ) $ page -> getControllerParameters ( ) + array ( 'parameters' => $ request -> query -> all ( ) , '_locale' => $ request -> attributes -> get ( '_locale' ) , '_internal_url' => $ request -> attributes -> get ( '_internal_url' ) , ) , $ request -> query -> all ( ) ) ; } return $ this -> renderPage ( $ page ) ; }
6632	public function requestAccessToken ( $ code ) { if ( ! $ code || empty ( $ code ) ) { throw new InvalidFacebookCodeException ( ) ; } $ request = [ 'url' => $ this -> settings [ 'token_url' ] , 'params' => [ 'client_id' => $ this -> settings [ 'api_key' ] , 'redirect_uri' => $ this -> settings [ 'redirect_uri' ] , 'client_secret' => $ this -> settings [ 'secret' ] , 'code' => $ code , 'format' => 'json' , ] , ] ; return $ this -> access_token -> make ( $ this -> http -> get ( $ request ) ) ; }
10094	protected function srvGet ( $ domain , $ https = false ) { if ( isset ( $ https ) && $ https === true ) { $ subdomain = '_avatars-sec._tcp.' ; $ fallback = 'seccdn.' ; $ port = 443 ; } else { $ subdomain = '_avatars._tcp.' ; $ fallback = 'cdn.' ; $ port = 80 ; } if ( $ domain === null ) { return $ fallback . 'libravatar.org' ; } $ srv = dns_get_record ( $ subdomain . $ domain , DNS_SRV ) ; if ( count ( $ srv ) == 0 ) { return $ fallback . 'libravatar.org' ; } usort ( $ srv , array ( $ this , 'comparePriority' ) ) ; $ top = $ srv [ 0 ] ; $ sum = 0 ; shuffle ( $ srv ) ; $ srvs = array ( ) ; foreach ( $ srv as $ s ) { if ( $ s [ 'weight' ] == 0 ) { array_unshift ( $ srvs , $ s ) ; } else { array_push ( $ srvs , $ s ) ; } } foreach ( $ srvs as $ s ) { if ( $ s [ 'pri' ] == $ top [ 'pri' ] ) { $ sum += ( int ) $ s [ 'weight' ] ; $ pri [ $ sum ] = $ s ; } } $ random = rand ( 0 , $ sum ) ; foreach ( $ pri as $ k => $ v ) { if ( $ k >= $ random ) { $ target = $ v [ 'target' ] ; if ( $ v [ 'port' ] !== $ port ) { $ target .= ':' . $ v [ 'port' ] ; } return $ target ; } } }
11982	public function acquire ( AcquirerInterface $ acquirer , ResourceInterface $ resource ) { if ( ! $ this -> isAccessible ( $ acquirer , $ resource ) ) { throw new ResourceLockedException ( sprintf ( 'The resource is not accessible. It is locked by "%s".' , $ resource -> getLock ( ) -> getAcquirer ( ) -> getIdentifier ( ) ) ) ; } return $ this -> repository -> acquire ( $ acquirer , $ resource ) ; }
7105	public function onParse ( $ finalText ) { $ func = $ this -> getParam ( 'postParseFunction' ) ; if ( isset ( $ func ) ) $ finalText = $ func ( $ finalText ) ; if ( $ this -> getParam ( 'addFootnotes' ) ) { $ footnotes = $ this -> getFootnotes ( ) ; if ( ! empty ( $ footnotes ) ) $ finalText .= "\n" . $ footnotes ; } $ finalText .= str_repeat ( '</section>' , count ( $ this -> _sectionLevel ) ) ; return ( $ finalText ) ; }
3472	public function extract ( string $ namespace ) : Config { $ extracted = $ this -> get ( $ namespace ) ; if ( ! is_array ( $ extracted ) ) { throw ConfigException :: forExtractionFailure ( $ namespace ) ; } return new self ( $ extracted ) ; }
7284	public function status ( $ status = NULL ) { if ( $ status === NULL ) { return $ this -> status ; } elseif ( array_key_exists ( $ status , Response :: $ messages ) ) { $ this -> status = ( int ) $ status ; $ this -> status_message = Response :: $ messages [ $ this -> status ] ; return $ this ; } else { throw new Exception ( __METHOD__ . ' unknown status value : :value' , array ( ':value' => $ status ) ) ; } }
10601	public function editQuery ( $ name , $ value ) { $ parts = explode ( '&' , $ this -> _urlParts [ 'query' ] ) ; $ return = [ ] ; foreach ( $ parts as $ p ) { $ paramData = explode ( '=' , $ p ) ; if ( $ paramData [ 0 ] === $ name ) { $ paramData [ 1 ] = $ value ; } $ return [ ] = implode ( '=' , $ paramData ) ; } $ this -> _urlParts [ 'query' ] = implode ( '&' , $ return ) ; return $ this ; }
4785	function offsetExists ( $ key ) { $ this -> access ( $ key ) ; $ return = array_key_exists ( $ key , $ this -> row ) ; if ( ! $ return ) { $ this -> access ( $ key , true ) ; } return $ return ; }
3965	protected function authenticateUser ( ) { if ( \ System :: getContainer ( ) -> get ( 'cca.dc-general.scope-matcher' ) -> currentScopeIsUnknown ( ) ) { return false ; } if ( strpos ( Environment :: get ( 'script' ) , 'contao/login' ) !== false ) { return false ; } if ( strpos ( Environment :: get ( 'request' ) , 'install' ) !== false ) { return false ; } if ( strpos ( Environment :: get ( 'script' ) , 'system/bin' ) !== false ) { return false ; } $ authResult = $ this -> getUser ( ) -> authenticate ( ) ; return ( $ authResult === true || $ authResult === null ) ? true : false ; }
2069	public function cutPage ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { return ( $ this -> User -> hasAccess ( $ row [ 'type' ] , 'alpty' ) && $ this -> User -> isAllowed ( Contao \ BackendUser :: CAN_EDIT_PAGE_HIERARCHY , $ row ) ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' ; }
6465	public function isMultipart ( HttpHeaders $ headers ) : bool { $ contentType = null ; $ headers -> tryGetFirst ( 'Content-Type' , $ contentType ) ; return preg_match ( "/multipart\//i" , $ contentType ) === 1 ; }
4195	public function getAbstraction ( $ obj , $ method = null , & $ hist = array ( ) ) { if ( ! \ is_object ( $ obj ) ) { return $ obj ; } $ reflector = new \ ReflectionObject ( $ obj ) ; $ className = $ reflector -> getName ( ) ; $ isTableTop = $ method === 'table' && \ count ( $ hist ) < 2 ; $ abs = new Event ( $ obj , array ( 'className' => $ className , 'collectMethods' => ! $ isTableTop && $ this -> abstracter -> getCfg ( 'collectMethods' ) || $ className == 'Closure' , 'constants' => array ( ) , 'debug' => $ this -> abstracter -> ABSTRACTION , 'debugMethod' => $ method , 'definition' => array ( 'fileName' => $ reflector -> getFileName ( ) , 'startLine' => $ reflector -> getStartLine ( ) , 'extensionName' => $ reflector -> getExtensionName ( ) , ) , 'extends' => array ( ) , 'implements' => $ reflector -> getInterfaceNames ( ) , 'isExcluded' => $ this -> isObjExcluded ( $ obj ) , 'isRecursion' => \ in_array ( $ obj , $ hist , true ) , 'methods' => array ( ) , 'phpDoc' => array ( 'summary' => null , 'description' => null , ) , 'properties' => array ( ) , 'scopeClass' => $ this -> getScopeClass ( $ hist ) , 'stringified' => null , 'type' => 'object' , 'traverseValues' => array ( ) , 'viaDebugInfo' => $ this -> abstracter -> getCfg ( 'useDebugInfo' ) && $ reflector -> hasMethod ( '__debugInfo' ) , 'collectPropertyValues' => true , 'hist' => $ hist , 'propertyOverrideValues' => array ( ) , 'reflector' => $ reflector , ) ) ; $ keysTemp = \ array_flip ( array ( 'collectPropertyValues' , 'hist' , 'propertyOverrideValues' , 'reflector' ) ) ; if ( $ abs [ 'isRecursion' ] ) { return \ array_diff_key ( $ abs -> getValues ( ) , $ keysTemp ) ; } $ abs = $ this -> abstracter -> debug -> internal -> publishBubbleEvent ( 'debug.objAbstractStart' , $ abs ) ; if ( \ array_filter ( array ( $ abs [ 'isExcluded' ] , $ abs -> isPropagationStopped ( ) ) ) ) { return \ array_diff_key ( $ abs -> getValues ( ) , $ keysTemp ) ; } $ this -> getAbstractionDetails ( $ abs ) ; $ return = $ this -> abstracter -> debug -> internal -> publishBubbleEvent ( 'debug.objAbstractEnd' , $ abs ) -> getValues ( ) ; $ this -> sort ( $ return [ 'properties' ] ) ; $ this -> sort ( $ return [ 'methods' ] ) ; return \ array_diff_key ( $ return , $ keysTemp ) ; }
10687	private function setCreatePermissions ( ) { if ( $ this -> config -> has ( 'io' , 'group' ) ) Path :: setDefaultFileGroup ( $ this -> config -> get ( 'io' , 'group' ) ) ; $ file_mode = ( int ) $ this -> config -> get ( 'io' , 'file_mode' ) ; if ( $ file_mode ) { $ of = $ file_mode ; $ file_mode = octdec ( sprintf ( "%04d" , $ file_mode ) ) ; Path :: setDefaultFileMode ( $ file_mode ) ; } $ dir_mode = ( int ) $ this -> config -> get ( 'io' , 'dir_mode' ) ; if ( $ dir_mode ) { $ of = $ dir_mode ; $ dir_mode = octdec ( sprintf ( "%04d" , $ dir_mode ) ) ; Path :: setDefaultDirMode ( $ dir_mode ) ; } }
8183	public function getMemoryUsage ( ) { return isset ( $ this -> ends [ 'mu' ] ) && isset ( $ this -> starts [ 'mu' ] ) ? $ this -> ends [ 'mu' ] - $ this -> starts [ 'mu' ] : 0 ; }
8301	public function handleAccountPage ( Request $ httpRequest ) { if ( ! $ this -> config [ "enabled" ] ) { return ; } $ user = $ this -> picoAuth -> getUser ( ) ; $ this -> picoAuth -> addAllowed ( "account" ) ; $ this -> picoAuth -> setRequestFile ( $ this -> picoAuth -> getPluginPath ( ) . '/content/account.md' ) ; $ post = $ httpRequest -> request ; if ( $ post -> has ( "new_password" ) && $ post -> has ( "new_password_repeat" ) && $ post -> has ( "old_password" ) ) { $ newPassword = new Password ( $ post -> get ( "new_password" ) ) ; $ newPasswordRepeat = new Password ( $ post -> get ( "new_password_repeat" ) ) ; $ oldPassword = new Password ( $ post -> get ( "old_password" ) ) ; $ username = $ user -> getId ( ) ; if ( ! $ this -> picoAuth -> isValidCSRF ( $ post -> get ( "csrf_token" ) ) ) { $ this -> picoAuth -> redirectToPage ( "account" ) ; } if ( $ newPassword -> get ( ) !== $ newPasswordRepeat -> get ( ) ) { $ this -> session -> addFlash ( "error" , "The passwords do not match." ) ; $ this -> picoAuth -> redirectToPage ( "account" ) ; } $ localAuth = $ this -> picoAuth -> getContainer ( ) -> get ( 'LocalAuth' ) ; if ( ! $ localAuth -> loginAttempt ( $ username , $ oldPassword ) ) { $ this -> session -> addFlash ( "error" , "The current password is incorrect" ) ; $ this -> picoAuth -> redirectToPage ( "account" ) ; } if ( ! $ localAuth -> checkPasswordPolicy ( $ newPassword ) ) { $ this -> picoAuth -> redirectToPage ( "account" ) ; } $ userData = $ this -> storage -> getUserByName ( $ username ) ; $ localAuth -> userDataEncodePassword ( $ userData , $ newPassword ) ; $ this -> storage -> saveUser ( $ username , $ userData ) ; $ this -> session -> addFlash ( "success" , "Password changed successfully." ) ; $ this -> picoAuth -> redirectToPage ( "account" ) ; } }
3308	protected function signature ( ) { $ signatureKey = $ this -> buildSignatureKey ( ) ; $ sing = hash_hmac ( 'SHA1' , $ signatureKey , $ this -> secretKey , true ) ; return base64_encode ( $ sing . $ signatureKey ) ; }
244	public function export ( ) { openlog ( $ this -> identity , $ this -> options , $ this -> facility ) ; foreach ( $ this -> messages as $ message ) { if ( syslog ( $ this -> _syslogLevels [ $ message [ 1 ] ] , $ this -> formatMessage ( $ message ) ) === false ) { throw new LogRuntimeException ( 'Unable to export log through system log!' ) ; } } closelog ( ) ; }
2879	public function enableTemplateHintsAction ( ) { try { $ this -> getService ( ) -> setTemplateHints ( 1 ) ; $ this -> getService ( ) -> flushCache ( ) ; } catch ( Exception $ e ) { $ message = $ this -> __ ( 'Template hints cannot be enabled: %s' , $ e -> getMessage ( ) ) ; $ this -> getSession ( ) -> addError ( $ message ) ; } $ this -> _redirectReferer ( ) ; }
3185	public function process ( ) { $ this -> validate ( ) ; $ ref = $ this -> getRequestParameter ( 'ref' ) ? : null ; $ itemDuration = null ; $ scope = $ this -> getRequestParameter ( 'scope' ) ; $ start = $ this -> getRequestParameter ( 'start' ) !== false ; try { $ serviceContext = $ this -> getServiceContext ( ) ; $ this -> saveToolStates ( ) ; $ this -> getRunnerService ( ) -> endTimer ( $ serviceContext , $ itemDuration , $ this -> getTime ( ) ) ; if ( $ this -> getRequestParameter ( 'offline' ) === true ) { $ this -> setOffline ( ) ; } $ result = $ this -> getRunnerService ( ) -> skip ( $ serviceContext , $ scope , $ ref ) ; $ response = [ 'success' => $ result , ] ; if ( $ result ) { $ response [ 'testContext' ] = $ this -> getRunnerService ( ) -> getTestContext ( $ serviceContext ) ; if ( $ serviceContext -> containsAdaptive ( ) ) { $ response [ 'testMap' ] = $ this -> getRunnerService ( ) -> getTestMap ( $ serviceContext , true ) ; } } if ( $ start == true ) { $ this -> getRunnerService ( ) -> startTimer ( $ serviceContext , $ this -> getTime ( ) ) ; } } catch ( Exception $ e ) { $ response = $ this -> getErrorResponse ( $ e ) ; } return $ response ; }
9832	public function setRevisionsPassword ( $ pValue , $ pAlreadyHashed = false ) { if ( ! $ pAlreadyHashed ) { $ pValue = PasswordHasher :: hashPassword ( $ pValue ) ; } $ this -> revisionsPassword = $ pValue ; return $ this ; }
180	protected function loadDummyBundle ( $ name ) { if ( ! isset ( $ this -> _dummyBundles [ $ name ] ) ) { $ this -> _dummyBundles [ $ name ] = $ this -> loadBundle ( $ name , [ 'sourcePath' => null , 'js' => [ ] , 'css' => [ ] , 'depends' => [ ] , ] ) ; } return $ this -> _dummyBundles [ $ name ] ; }
9691	private function compile ( $ file ) { if ( ! file_exists ( $ file ) ) { throw new \ Exception ( "Could not compile $file, file not found" ) ; } if ( ! file_exists ( $ this -> views_cache ) && ! mkdir ( $ this -> views_cache ) ) { throw new \ Exception ( "Could no create cache directory." . " Make sure you have write permissions." ) ; } $ hash = md5 ( $ file ) ; $ compiled_file = $ this -> views_cache . '/' . $ hash ; $ compiled = null ; if ( $ this -> debug || ( ! file_exists ( $ compiled_file ) || filemtime ( $ compiled_file ) < filemtime ( $ file ) ) ) { $ source = file_get_contents ( $ file ) ; $ compiled = $ this -> compileString ( $ source ) ; $ compiled = "<?php\nfunction katar_" . $ hash . "(\$args) {\nextract(\$args);\n\$output = null;\n" . $ compiled . "\nreturn \$output;\n}\n" ; file_put_contents ( $ compiled_file , $ compiled ) ; } else { $ compiled = file_get_contents ( $ cache_file ) ; } return $ compiled ; }
4690	public function addGroupBy ( $ expression , ... $ args ) : self { $ this -> dirty ( ) ; $ this -> group [ ] = $ expression ; $ this -> pushArgs ( 'group' , $ args ) ; return $ this ; }
6259	protected function _isAllowedRole ( $ userRoles , array $ allowedRoles ) { if ( in_array ( '*' , $ allowedRoles ) ) { return true ; } if ( is_string ( $ userRoles ) ) { $ userRoles = [ $ userRoles ] ; } foreach ( $ userRoles as $ userRole ) { if ( in_array ( $ userRole , $ allowedRoles ) ) { return true ; } } return false ; }
11253	public function transaction ( callable $ callback ) : void { $ this -> pdo -> beginTransaction ( ) ; $ callback ( $ this ) ; $ this -> pdo -> commit ( ) ; }
4977	public function send ( \ Zend \ Mail \ Message $ message ) { $ options = $ this -> options ; $ filename = call_user_func ( $ options -> getCallback ( ) , $ this ) ; $ file = $ options -> getPath ( ) . DIRECTORY_SEPARATOR . $ filename ; $ contents = $ message -> toString ( ) ; $ umask = umask ( ) ; umask ( 022 ) ; if ( false === file_put_contents ( $ file , $ contents , LOCK_EX ) ) { throw new RuntimeException ( sprintf ( 'Unable to write mail to file (directory "%s")' , $ options -> getPath ( ) ) ) ; } umask ( $ umask ) ; $ this -> lastFile = $ file ; }
4482	public function setBacklog ( int $ backlog ) : void { if ( $ this -> client -> call ( 'recur.update' , $ this -> jid , 'backlog' , $ backlog ) ) { $ this -> backlog = $ backlog ; } }
2948	public function release ( $ version ) { $ package = 'upyun/sdk' ; $ name = 'php-sdk' ; $ collection = $ this -> collectionBuilder ( ) ; $ workingPath = __DIR__ . DIRECTORY_SEPARATOR . $ collection -> workDir ( "release" ) ; $ collection -> taskExec ( "composer create-project {$package} {$name} {$version}" ) -> dir ( $ workingPath ) -> arg ( '--prefer-dist' ) -> arg ( '--no-dev' ) -> arg ( '-vvv' ) -> taskExec ( 'composer dump-autoload --optimize' ) -> dir ( $ workingPath . DIRECTORY_SEPARATOR . $ name ) -> arg ( '-vvv' ) ; $ collection -> run ( ) ; $ zipFile = "release/{$name}-{$version}.zip" ; $ this -> _remove ( $ zipFile ) ; $ this -> taskPack ( $ zipFile ) -> addDir ( "php-sdk" , __DIR__ . "/release/php-sdk" ) -> run ( ) ; $ this -> _deleteDir ( "release/$name" ) ; }
2489	public function hasMultipleEndpoints ( ) { if ( $ this -> hasMultiple !== null ) { return $ this -> hasMultiple ; } $ endpointSet = array_flip ( $ this -> endpointMap ) ; if ( isset ( $ this -> defaultEndpoint ) ) { $ endpointSet [ $ this -> defaultEndpoint ] = true ; } if ( isset ( $ this -> mainLanguagesEndpoint ) ) { $ endpointSet [ $ this -> mainLanguagesEndpoint ] = true ; } return $ this -> hasMultiple = count ( $ endpointSet ) > 1 ; }
4825	public function replaceValue ( $ fieldName , $ oldvalue , $ newvalue ) { $ result = $ this -> row [ $ fieldName ] ; if ( ! is_array ( $ result ) ) { if ( $ oldvalue == $ result ) { $ this -> row [ $ fieldName ] = $ newvalue ; $ this -> informChanges ( ) ; } } else { for ( $ i = count ( $ result ) - 1 ; $ i >= 0 ; $ i -- ) { if ( $ result [ $ i ] == $ oldvalue ) { $ this -> row [ $ fieldName ] [ $ i ] = $ newvalue ; $ this -> informChanges ( ) ; } } } }
8457	protected function injectArguments ( $ command , $ assumeYes ) { $ cmd = $ this -> siteAlias . ' ' . $ command . ( $ assumeYes ? ' -y' : '' ) . $ this -> arguments . $ this -> argumentsForNextCommand ; $ this -> argumentsForNextCommand = '' ; return $ cmd ; }
8526	public function listFinancialEventGroups ( $ request ) { if ( ! ( $ request instanceof MWSFinancesService_Model_ListFinancialEventGroupsRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/ListFinancialEventGroupsRequest.php' ) ; $ request = new MWSFinancesService_Model_ListFinancialEventGroupsRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListFinancialEventGroups' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/ListFinancialEventGroupsResponse.php' ) ; $ response = MWSFinancesService_Model_ListFinancialEventGroupsResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
2640	public function cleanUrl ( $ url ) { $ result = $ this -> _purge ( $ url , 'PURGE' , 'PURGE' ) ; if ( $ result [ 'status' ] ) { $ this -> logger -> execute ( $ url ) ; } if ( $ this -> config -> areWebHooksEnabled ( ) && $ this -> config -> canPublishKeyUrlChanges ( ) ) { $ this -> sendWebHook ( '*clean by URL for* ' . $ url ) ; } return $ result ; }
12019	function addProperties ( ) { $ requiredProperties = [ 'api' => '\\' . $ this -> apiClassname , 'parameters' => 'array' , 'response' => '\Amp\Artax\Response' , 'originalResponse' => '\Amp\Artax\Response' , ] ; foreach ( $ requiredProperties as $ propertyName => $ typehint ) { $ propertyGenerator = new PropertyGenerator ( $ propertyName , null ) ; $ docBlock = new DocBlockGenerator ( '@var ' . $ typehint ) ; $ propertyGenerator -> setDocBlock ( $ docBlock ) ; $ this -> classGenerator -> addPropertyFromGenerator ( $ propertyGenerator ) ; } $ docBlock = new DocBlockGenerator ( 'Get the last response.' ) ; $ body = 'return $this->response;' ; $ methodGenerator = $ this -> createMethodGenerator ( 'getResponse' , $ body , $ docBlock , [ ] , '\Amp\Artax\Response' ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; $ docBlock = new DocBlockGenerator ( 'Set the last response. This should only be used by the API class when the operation has been dispatched. Storing the response is required as some APIs store out-of-bound information in the headers e.g. rate-limit info, pagination that is not really part of the operation.' ) ; $ body = '$this->response = $response;' ; $ methodGenerator = $ this -> createMethodGenerator ( 'setResponse' , $ body , $ docBlock , [ [ 'response' , 'Amp\Artax\Response' ] ] ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; }
3107	public function getItemHrefIndex ( ) { if ( isset ( $ this -> state [ self :: VAR_HREF_INDEX ] ) ) { $ table = $ this -> state [ self :: VAR_HREF_INDEX ] ; } else { $ table = [ ] ; } return $ table ; }
8408	public static function set ( $ name , $ value , $ expire = 0 , $ path = null ) { if ( $ path === null ) { setcookie ( $ name , $ value , $ expire ) ; } else { setcookie ( $ name , $ value , $ expire , $ path ) ; } }
1254	private function isSimplePhpType ( \ stdClass $ meta ) { $ phpTypes = explode ( '|' , $ meta -> phpType ) ; foreach ( $ phpTypes as $ phpType ) { switch ( $ phpType ) { case 'integer' : case 'string' : case 'double' : case 'boolean' : case 'DateTime' : continue ; default : return false ; } } return true ; }
3802	private function getOrCreatePaletteDefinition ( IMetaModelDataDefinition $ container ) { if ( $ container -> hasDefinition ( PalettesDefinitionInterface :: NAME ) ) { return $ container -> getDefinition ( PalettesDefinitionInterface :: NAME ) ; } $ container -> setDefinition ( PalettesDefinitionInterface :: NAME , $ palettesDefinition = new DefaultPalettesDefinition ( ) ) ; return $ palettesDefinition ; }
11634	public function bindPage ( array $ deviceIdentifier , array $ pageIds ) { $ params = [ 'device_identifier' => $ deviceIdentifier , 'page_ids' => $ pageIds , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_DEVICE_BINDPAGE , $ params ] ) ; }
2214	public function prev ( ) { if ( $ this -> intIndex < 1 ) { return false ; } $ this -> blnDone = false ; $ this -> arrCache = $ this -> resultSet [ -- $ this -> intIndex ] ; return $ this ; }
6344	public static function from ( Traversable $ traversable ) : Iterator { Preconditions :: checkArgument ( $ traversable instanceof Iterator || $ traversable instanceof IteratorAggregate ) ; return $ traversable instanceof Iterator ? $ traversable : Iterators :: from ( $ traversable -> getIterator ( ) ) ; }
5278	public function orWhere ( $ column , $ param1 = null , $ param2 = null ) { return $ this -> where ( $ column , $ param1 , $ param2 , 'or' ) ; }
11466	public static function writeLogLine ( $ log_file , $ input , $ timestamp = null ) { if ( is_null ( self :: $ _error_folder ) ) { return false ; } $ log_file = basename ( $ log_file ) ; $ fp = @ fopen ( self :: $ _error_folder . $ log_file , 'ab' ) ; if ( ! $ fp ) { return false ; } if ( empty ( $ timestamp ) ) { $ timestamp = time ( ) ; } $ line = [ ] ; $ line [ ] = date ( \ DateTime :: ISO8601 , $ timestamp ) ; if ( $ input instanceof \ Throwable ) { $ message = $ input -> getMessage ( ) ; if ( ! ( $ input instanceof BaseException ) ) { $ message = preg_replace ( '/\s+/' , ' ' , $ message ) ; } $ line [ ] = BaseException :: getShortName ( get_class ( $ input ) ) ; $ line [ ] = $ message ; $ line [ ] = $ input -> getFile ( ) ; $ line [ ] = $ input -> getLine ( ) ; $ line_out = vsprintf ( '[%s] %s: %s in %s on line %d' , $ line ) ; } elseif ( is_string ( $ input ) ) { $ line [ ] = $ input ; $ line_out = vsprintf ( '[%s] %s' , $ line ) ; } else { return false ; } if ( flock ( $ fp , LOCK_EX ) ) { fwrite ( $ fp , $ line_out . PHP_EOL ) ; flock ( $ fp , LOCK_UN ) ; fclose ( $ fp ) ; return true ; } else { return false ; } }
662	public function transaction ( callable $ callback , $ isolationLevel = null ) { $ transaction = $ this -> beginTransaction ( $ isolationLevel ) ; $ level = $ transaction -> level ; try { $ result = call_user_func ( $ callback , $ this ) ; if ( $ transaction -> isActive && $ transaction -> level === $ level ) { $ transaction -> commit ( ) ; } } catch ( \ Exception $ e ) { $ this -> rollbackTransactionOnLevel ( $ transaction , $ level ) ; throw $ e ; } catch ( \ Throwable $ e ) { $ this -> rollbackTransactionOnLevel ( $ transaction , $ level ) ; throw $ e ; } return $ result ; }
11569	public static function search ( $ query , & $ results = array ( ) ) { $ attachments = static :: getInstance ( ) ; if ( ! empty ( $ query ) ) : $ words = explode ( ' ' , $ query ) ; foreach ( $ words as $ word ) { $ _results = $ attachments -> setListLookUpConditions ( "attachment_name" , $ word , 'OR' ) -> setListLookUpConditions ( "attachment_title" , $ word , 'OR' ) -> setListLookUpConditions ( "attachment_description" , $ word , 'OR' ) -> setListLookUpConditions ( "attachment_tags" , $ word , 'OR' ) ; } $ _results = $ attachments -> setListLookUpConditions ( "attachment_owner" , array ( $ attachments -> user -> get ( "user_name_id" ) ) , "AND" , true ) -> setListOrderBy ( "o.object_created_on" , "DESC" ) -> getObjectsList ( "attachment" ) ; $ rows = $ _results -> fetchAll ( ) ; $ browsable = array ( "image/jpg" , "image/jpeg" , "image/png" , "image/gif" ) ; $ documents = array ( "filterid" => "attachments" , "title" => "Documents" , "results" => array ( ) ) ; foreach ( $ rows as $ attachment ) { $ document = array ( "title" => $ attachment [ 'attachment_title' ] , "description" => "" , "type" => $ attachment [ 'object_type' ] , "object_uri" => $ attachment [ 'object_uri' ] ) ; if ( in_array ( $ attachment [ 'attachment_type' ] , $ browsable ) ) : $ document [ 'icon' ] = "/system/object/{$attachment['object_uri']}/resize/170/170" ; $ document [ 'link' ] = "/system/media/photo/view/{$attachment['object_uri']}" ; else : $ document [ 'media_uri' ] = $ attachment [ 'object_uri' ] ; $ document [ 'link' ] = "/system/object/{$attachment['object_uri']}" ; endif ; $ documents [ "results" ] [ ] = $ document ; } if ( ! empty ( $ documents [ "results" ] ) ) $ results [ ] = $ documents ; endif ; return true ; }
12612	public function getIP ( ) { $ ip = "UNKNOWN" ; if ( getenv ( "HTTP_CLIENT_IP" ) ) { $ ip = getenv ( "HTTP_CLIENT_IP" ) ; } else if ( getenv ( "HTTP_X_FORWARDED_FOR" ) ) { $ ip = getenv ( "HTTP_X_FORWARDED_FOR" ) ; } else if ( getenv ( "REMOTE_ADDR" ) ) { $ ip = getenv ( "REMOTE_ADDR" ) ; } return $ ip ; }
6789	protected function assertShipmentPlatform ( ShipmentInterface $ shipment ) { if ( $ shipment -> getPlatformName ( ) !== $ this -> getName ( ) ) { throw new InvalidArgumentException ( sprintf ( "Platform %s does not support shipment %s." , $ this -> getName ( ) , $ shipment -> getNumber ( ) ) ) ; } }
10163	private function readSheetLayout ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; $ offset = 0 ; if ( ! $ this -> readDataOnly ) { $ sz = self :: getInt4d ( $ recordData , 12 ) ; switch ( $ sz ) { case 0x14 : $ colorIndex = self :: getUInt2d ( $ recordData , 16 ) ; $ color = Xls \ Color :: map ( $ colorIndex , $ this -> palette , $ this -> version ) ; $ this -> phpSheet -> getTabColor ( ) -> setRGB ( $ color [ 'rgb' ] ) ; break ; case 0x28 : return ; break ; } } }
9239	private function isInheritanceRelationship ( ForeignKeyConstraint $ fk ) { if ( ! $ fk -> getLocalTable ( ) -> hasPrimaryKey ( ) ) { return false ; } $ fkColumnNames = $ fk -> getLocalColumns ( ) ; $ pkColumnNames = $ fk -> getLocalTable ( ) -> getPrimaryKeyColumns ( ) ; sort ( $ fkColumnNames ) ; sort ( $ pkColumnNames ) ; return $ fkColumnNames == $ pkColumnNames ; }
7602	public function render ( FormInterface $ oForm , $ sMessage , $ bDismissable = false ) { $ errorHtml = sprintf ( $ this -> messageOpenFormat , $ sMessage ) ; $ sMessagesArray = array ( ) ; foreach ( $ oForm -> getMessages ( ) as $ fieldName => $ sMessages ) { foreach ( $ sMessages as $ sMessage ) { if ( $ oForm -> get ( $ fieldName ) -> getAttribute ( 'id' ) ) { $ sMessagesArray [ ] = sprintf ( '<a href="#%s">%s</a>' , $ oForm -> get ( $ fieldName ) -> getAttribute ( 'id' ) , $ oForm -> get ( $ fieldName ) -> getLabel ( ) . ': ' . $ sMessage ) ; } else { $ sMessagesArray [ ] = $ oForm -> get ( $ fieldName ) -> getLabel ( ) . ': ' . $ sMessage ; } } } return $ this -> dangerAlert ( $ errorHtml . implode ( $ this -> messageSeparatorString , $ sMessagesArray ) . $ this -> messageCloseString , $ bDismissable ) ; }
6875	public static function query ( $ queryString , array $ queryParams = [ ] , $ dbName = "master" , $ fetchResults = true ) { $ query = static :: instance ( $ dbName ) -> prepare ( $ queryString ) ; foreach ( $ queryParams as $ column => $ val ) $ query -> bindValue ( is_int ( $ column ) ? $ column + 1 : ":" . $ column , $ val ) ; if ( $ query -> execute ( ) ) return $ fetchResults ? $ query -> fetchAll ( PDO :: FETCH_ASSOC ) : $ query -> rowCount ( ) ; return false ; }
12165	private function createAuthorityPermissionsTable ( ) { $ this -> database -> query ( "DROP TABLE IF EXISTS `?authority_permissions`;" ) ; $ this -> database -> query ( "CREATE TABLE IF NOT EXISTS `?authority_permissions` ( `authority_permission_key` bigint(20) NOT NULL AUTO_INCREMENT, `authority_id` bigint(20) NOT NULL, `permission_area_uri` varchar(255) NOT NULL, `permission` varchar(45) NOT NULL DEFAULT '1', `permission_type` varchar(45) NOT NULL, `permission_title` varchar(45) NOT NULL, PRIMARY KEY (`authority_permission_key`), UNIQUE KEY `UNIQUE` (`permission_area_uri`,`permission_type`,`authority_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 AUTO_INCREMENT=1 ;" ) ; $ this -> database -> query ( "INSERT INTO `?authority_permissions` (`authority_permission_key`, `authority_id`, `permission_area_uri`, `permission`, `permission_type`, `permission_title`) VALUES (1, 4, '^/admin(/[a-z0-9-]*)*', 'allow', 'special', 'Console'), (2, 1, '^/admin/setup/install(/[a-z0-9-]*)*', 'allow', 'execute', 'Installer'), (3, 4, '^/page(/[a-z0-9-]*)*', 'allow', 'execute', 'Content'), (4, 2, '^/member(/[a-z0-9-]*)*', 'allow', 'execute', 'Member Pages'), (5, 1, '^/member/sign([a-z0-9-]*)*', 'allow', 'execute', 'Authentication'), (6, 2, '^/message(/[a-z0-9-]*)*', 'allow', 'execute', 'Messages'), (7, 1, '^/search(/[a-z0-9-]*)*', 'allow', 'execute', 'Search'), (8, 4, '^/listing(/[a-z0-9-]*)*', 'allow', 'special', 'Directory'), (9, 2, '^/notification(/[a-z0-9-]*)*', 'allow', 'execute', 'Messages'), (10, 1, '^/post(/[a-z0-9-]*)*', 'allow', 'view', 'Content'), (11, 1, '^/event(/[a-z0-9-]*)*', 'allow', 'view', 'Content'), (12, 1, '^/stream(/[a-z0-9-]*)*', 'allow', 'view', 'Content'), (13, 1, '^/group(/[a-z0-9-]*)*', 'allow', 'view', 'Content'), (14, 1, '^/file(/[a-z0-9-]*)*', 'allow', 'view', 'Content'), (16, 2, '^/post(/[a-z0-9-]*)*', 'allow', 'execute', 'Content'), (15, 1, '^/page(/[a-z0-9-]*)*', 'allow', 'view', 'Content');" ) ; }
10747	protected function sendItems ( Response $ response , iterable $ items , ? Pagination $ pagination = null , ? int $ total = null ) : Response { $ items = is_array ( $ items ) ? $ items : ( $ items instanceof \ Traversable ? iterator_to_array ( $ items , false ) : [ ] ) ; $ total = $ total ?? count ( $ items ) ; $ start = $ pagination === null ? 0 : $ pagination -> getOffset ( ) ; $ max = $ pagination === null ? 0 : $ pagination -> getMax ( ) ; $ end = max ( min ( ( PHP_INT_MAX - $ max < $ start ? PHP_INT_MAX : $ start + $ max ) , $ total ) - 1 , 0 ) ; return $ this -> sendJson ( $ response -> withHeader ( 'Content-Range' , "items $start-$end/$total" ) , $ items ) ; }
4615	public function buildCluster ( array $ hosts = [ 'localhost' ] ) { $ nodes = [ ] ; foreach ( $ hosts as $ host ) { $ nodes [ ] = $ this -> atHost ( $ host ) -> build ( ) ; } return $ nodes ; }
9191	public static function convert ( $ identifier , $ sourceFormat , $ outputFormat ) { $ parts = Parser :: parse ( $ identifier , $ sourceFormat ) ; return Formatter :: format ( $ parts , $ outputFormat ) ; }
5787	public function routeGetLogout ( Request $ request , Response $ response ) { $ this -> events -> setAdministratorId ( $ this -> authentication -> getAdministratorId ( ) ) ; if ( null === $ username = $ this -> authentication -> getAdministratorUsername ( ) ) { $ this -> events -> insertWarning ( EVENT_LOGOUT_FAULT ) ; } else { $ this -> events -> insertInfo ( EVENT_LOGOUT ) ; $ this -> authentication -> logout ( ) ; } return $ response -> withRedirect ( $ this -> router -> pathFor ( ROUTE_HOME ) ) ; }
8367	public static function get ( string $ name ) : array { if ( isset ( self :: $ mappings [ $ name ] ) === false ) { throw new MappingNotFound ( 'there\'s no registered mapping with name "' . $ name . '"' ) ; } return self :: $ mappings [ $ name ] ; }
3682	private function getFilterFactory ( ) : IFilterSettingFactory { if ( null === $ this -> filterFactory ) { return $ this -> filterFactory = System :: getContainer ( ) -> get ( 'metamodels.filter_setting_factory' ) ; } return $ this -> filterFactory ; }
10903	public function delete ( ) : bool { return ( bool ) $ this -> medoo -> delete ( $ this -> getTable ( ) , [ 'id' => $ this -> getId ( ) ] ) ; }
1414	public function resourceCannotBeDeleted ( string $ detail = null ) : ErrorInterface { return new Error ( null , null , Response :: HTTP_UNPROCESSABLE_ENTITY , $ this -> trans ( 'resource_cannot_be_deleted' , 'code' ) , $ this -> trans ( 'resource_cannot_be_deleted' , 'title' ) , $ detail ? : $ this -> trans ( 'resource_cannot_be_deleted' , 'detail' ) ) ; }
8533	public function setDebtRecoveryItemList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'DebtRecoveryItemList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
9354	public function subMatrix ( $ int_m , $ int_n ) { $ sm = new self ( $ this -> size -> rows - 1 , $ this -> size -> cols - 1 ) ; foreach ( $ this -> arr as $ m => $ row ) { if ( $ m != $ int_m ) { $ arr_row = array ( ) ; foreach ( $ row as $ n => $ v ) { if ( $ n != $ int_n ) { $ arr_row [ ] = $ v ; } } $ sm -> addRow ( $ arr_row ) ; } } return $ sm ; }
4108	public function getSkinFileContent ( $ file ) { $ package = Mage :: getSingleton ( 'core/design_package' ) ; $ areaBackup = $ package -> getArea ( ) ; $ path = $ package -> setArea ( 'frontend' ) -> getFilename ( $ file , array ( '_type' => 'skin' ) ) ; $ content = file_get_contents ( $ path ) ; $ package -> setArea ( $ areaBackup ) ; return $ content ; }
8735	public function decrement ( $ column , $ amount = 1 , array $ extra = [ ] ) { $ extra = $ this -> addUpdatedAtColumn ( $ extra ) ; return $ this -> noTranslationsQuery ( ) -> decrement ( $ column , $ amount , $ extra ) ; }
8451	public function setProfilePhoto ( $ mediaUri ) { $ processedMedia = $ this -> processMediaUri ( $ mediaUri ) ; if ( ! $ processedMedia ) { return false ; } $ result = $ this -> exec ( 'set_profile_photo ' . $ processedMedia [ 'filepath' ] ) ; $ this -> cleanUpMedia ( $ processedMedia ) ; return $ result ; }
4125	private function generateMethods ( ClassMetadata $ class ) { $ methods = '' ; foreach ( $ class -> reflClass -> getMethods ( ) as $ method ) { if ( $ method -> isConstructor ( ) || strtolower ( $ method -> getName ( ) ) == "__sleep" ) { continue ; } if ( $ method -> isPublic ( ) && ! $ method -> isFinal ( ) && ! $ method -> isStatic ( ) ) { $ methods .= PHP_EOL . ' public function ' ; if ( $ method -> returnsReference ( ) ) { $ methods .= '&' ; } $ methods .= $ method -> getName ( ) . '(' ; $ firstParam = true ; $ parameterString = $ argumentString = '' ; foreach ( $ method -> getParameters ( ) as $ param ) { if ( $ firstParam ) { $ firstParam = false ; } else { $ parameterString .= ', ' ; $ argumentString .= ', ' ; } if ( ( $ paramClass = $ param -> getClass ( ) ) !== null ) { $ parameterString .= '\\' . $ paramClass -> getName ( ) . ' ' ; } else if ( $ param -> isArray ( ) ) { $ parameterString .= 'array ' ; } if ( $ param -> isPassedByReference ( ) ) { $ parameterString .= '&' ; } $ parameterString .= '$' . $ param -> getName ( ) ; $ argumentString .= '$' . $ param -> getName ( ) ; if ( $ param -> isDefaultValueAvailable ( ) ) { $ parameterString .= ' = ' . var_export ( $ param -> getDefaultValue ( ) , true ) ; } } $ methods .= $ parameterString . ')' ; $ methods .= PHP_EOL . ' {' . PHP_EOL ; $ methods .= ' $this->__load();' . PHP_EOL ; $ methods .= ' return parent::' . $ method -> getName ( ) . '(' . $ argumentString . ');' ; $ methods .= PHP_EOL . ' }' . PHP_EOL ; } } return $ methods ; }
7473	public function editAction ( $ id ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ user = $ em -> getRepository ( 'Orkestra\Bundle\ApplicationBundle\Entity\User' ) -> find ( $ id ) ; if ( ! $ user ) { throw $ this -> createNotFoundException ( 'Unable to locate User' ) ; } $ form = $ this -> createForm ( UserType :: class , $ user , array ( 'include_password' => false ) ) ; return array ( 'user' => $ user , 'form' => $ form -> createView ( ) , ) ; }
2523	protected function makeMessageOptions ( array $ incoming , $ endSession = false ) { $ options = [ 'endSession' => $ endSession , 'returnXml' => $ this -> returnResultXml ] ; if ( array_key_exists ( 'endSession' , $ incoming ) ) { $ options [ 'endSession' ] = $ incoming [ 'endSession' ] ; } if ( array_key_exists ( 'returnXml' , $ incoming ) ) { $ options [ 'returnXml' ] = $ incoming [ 'returnXml' ] ; } return $ options ; }
1062	public static function findTypesAddedToUnions ( Schema $ oldSchema , Schema $ newSchema ) { $ oldTypeMap = $ oldSchema -> getTypeMap ( ) ; $ newTypeMap = $ newSchema -> getTypeMap ( ) ; $ typesAddedToUnion = [ ] ; foreach ( $ newTypeMap as $ typeName => $ newType ) { $ oldType = $ oldTypeMap [ $ typeName ] ?? null ; if ( ! ( $ oldType instanceof UnionType ) || ! ( $ newType instanceof UnionType ) ) { continue ; } $ typeNamesInOldUnion = [ ] ; foreach ( $ oldType -> getTypes ( ) as $ type ) { $ typeNamesInOldUnion [ $ type -> name ] = true ; } foreach ( $ newType -> getTypes ( ) as $ type ) { if ( isset ( $ typeNamesInOldUnion [ $ type -> name ] ) ) { continue ; } $ typesAddedToUnion [ ] = [ 'type' => self :: DANGEROUS_CHANGE_TYPE_ADDED_TO_UNION , 'description' => sprintf ( '%s was added to union type %s.' , $ type -> name , $ typeName ) , ] ; } } return $ typesAddedToUnion ; }
5651	public function explainFlag ( $ flags , $ explanation ) { $ flags = is_array ( $ flags ) ? $ flags : array ( $ flags ) ; $ this -> flag_sets [ ] = $ flags ; $ this -> explanations [ ] = $ explanation ; }
3014	public function unlike ( $ postId , $ reblogKey ) { $ options = array ( 'id' => $ postId , 'reblog_key' => $ reblogKey ) ; return $ this -> postRequest ( 'v2/user/unlike' , $ options , false ) ; }
7563	protected function parse_not ( ) { if ( ( ( $ this -> pos + 1 ) < $ this -> size ) && ( $ this -> doc [ $ this -> pos + 1 ] === '=' ) ) { ++ $ this -> pos ; return ( $ this -> token = self :: TOK_COMPARE_NOT_EQUAL ) ; } else { return ( $ this -> token = self :: TOK_NOT ) ; } }
11334	public function getFormattedValue ( ) { if ( $ this -> format instanceof BaseFormat ) { $ formattedValue = $ this -> format -> get ( ) ; } elseif ( is_callable ( $ this -> format ) || ( is_array ( $ this -> format ) && ! empty ( $ this -> format [ 0 ] ) && is_object ( $ this -> format [ 0 ] ) ) ) { $ formattedValue = $ this -> evaluateExpression ( $ this -> format , [ $ this -> value ] ) ; } else { $ formattedValue = $ this -> value ; } if ( is_object ( $ formattedValue ) ) { $ formattedValue = $ formattedValue -> viewLink ; } return $ formattedValue ; }
10084	protected function write ( $ stream , $ text ) { $ fp = fopen ( $ stream , 'a' ) ; fwrite ( $ fp , $ text ) ; fclose ( $ fp ) ; }
348	public static function cssStyleFromArray ( array $ style ) { $ result = '' ; foreach ( $ style as $ name => $ value ) { $ result .= "$name: $value; " ; } return $ result === '' ? null : rtrim ( $ result ) ; }
4953	public function call ( $ method , $ args = [ ] , $ expect = self :: EXPECT_SELF ) { if ( ! is_array ( $ args ) ) { $ expect = $ args ; $ args = [ ] ; } if ( ! $ this -> helper ) { return $ this -> expected ( $ expect ) ; } return call_user_func_array ( [ $ this -> helper , $ method ] , $ args ) ; }
5280	public function select ( $ fields = '' ) { if ( empty ( $ fields ) ) { return $ this ; } if ( is_string ( $ fields ) ) { $ this -> statements [ 'select' ] [ ] = $ fields ; return $ this ; } foreach ( $ fields as $ key => $ field ) { if ( is_string ( $ key ) ) { $ this -> statements [ 'select' ] [ ] = "$key as $field" ; } else { $ this -> statements [ 'select' ] [ ] = $ field ; } } return $ this ; }
10092	protected function identifierHash ( $ identifier , $ hash = 'md5' ) { if ( filter_var ( $ identifier , FILTER_VALIDATE_EMAIL ) || $ identifier === null ) { return hash ( $ hash , $ identifier ) ; } return hash ( 'sha256' , $ identifier ) ; }
12965	public function getIcon ( ) { if ( is_null ( $ this -> _icon ) && isset ( $ this -> object ) ) { $ this -> _icon = [ 'class' => $ this -> object -> objectType -> icon , 'title' => $ this -> objectTypeDescriptor ] ; } return $ this -> _icon ; }
3740	public function getCombinationsForUser ( $ userGroups , $ userType ) { $ userType = strtolower ( $ userType ) ; if ( 'fe' !== $ userType && 'be' !== $ userType ) { throw new \ InvalidArgumentException ( 'Unknown user type: ' . $ userType ) ; } return $ this -> getCombinationsFromDatabase ( $ userGroups , $ userType ) ; }
846	public function generatePartialCode ( $ start , $ end ) { $ code = '' ; for ( $ i = $ start ; $ i <= $ end ; ++ $ i ) { $ code .= $ this [ $ i ] -> getContent ( ) ; } return $ code ; }
10978	protected function setVerificationCode ( $ code = null ) { $ this -> { Config :: get ( 'verifier.store_column' ) } = $ code ; if ( $ code ) { $ this -> { Config :: get ( 'verifier.flag_column' ) } = false ; } else { $ this -> { Config :: get ( 'verifier.flag_column' ) } = true ; } $ this -> save ( ) ; }
9389	protected function parse ( $ route ) { $ route [ 0 ] = strtoupper ( $ route [ 0 ] ) ; $ route [ 1 ] = str_replace ( '//' , '/' , $ this -> prefix . $ route [ 1 ] ) ; is_string ( $ route [ 2 ] ) && $ route [ 2 ] = explode ( '@' , $ route [ 2 ] ) ; is_array ( $ route [ 2 ] ) && $ route [ 2 ] [ 0 ] = $ this -> namespace . $ route [ 2 ] [ 0 ] ; is_array ( $ route [ 3 ] ) || $ route [ 3 ] = array ( $ route [ 3 ] ) ; return $ route ; }
6688	public function isPostCheck ( $ redirectUrl = null ) { if ( $ this -> getRequest ( ) -> isPost ) { return true ; } if ( is_null ( $ redirectUrl ) ) { return false ; } $ this -> sendTerminalResponse ( $ redirectUrl ) ; }
5962	public function serverGroupPermList ( $ sgid , $ permsid = false ) { return $ this -> execute ( "servergrouppermlist" , array ( "sgid" => $ sgid , $ permsid ? "-permsid" : null ) ) -> toAssocArray ( $ permsid ? "permsid" : "permid" ) ; }
5212	public function getConstant ( $ name ) { return $ this -> getBinding ( ConstantBinding :: TYPE , $ name ) -> getInstance ( $ this , $ name ) ; }
2396	protected function unixToHex ( $ intTime = 0 ) { $ arrTime = $ intTime ? getdate ( $ intTime ) : getdate ( ) ; $ hexTime = dechex ( ( ( $ arrTime [ 'year' ] - 1980 ) << 25 ) | ( $ arrTime [ 'mon' ] << 21 ) | ( $ arrTime [ 'mday' ] << 16 ) | ( $ arrTime [ 'hours' ] << 11 ) | ( $ arrTime [ 'minutes' ] << 5 ) | ( $ arrTime [ 'seconds' ] >> 1 ) ) ; return pack ( "H*" , $ hexTime [ 6 ] . $ hexTime [ 7 ] . $ hexTime [ 4 ] . $ hexTime [ 5 ] . $ hexTime [ 2 ] . $ hexTime [ 3 ] . $ hexTime [ 0 ] . $ hexTime [ 1 ] ) ; }
11015	public static function sec2time ( $ seconds ) { $ sec = intval ( $ seconds ) ; $ dtF = new \ DateTime ( "@0" ) ; $ dtT = new \ DateTime ( "@$sec" ) ; return $ dtF -> diff ( $ dtT ) -> format ( '%a days, %h hours, %i minutes and %s seconds' ) ; }
5999	public function setProtocol ( $ protocol ) { if ( $ protocol instanceof Protocol ) { $ this -> protocol = $ protocol ; } elseif ( is_array ( $ protocol ) ) { $ this -> protocol = new Protocol ( $ protocol ) ; } else { $ this -> protocol = null ; trigger_error ( 'Argument must be an object of class Protocol. Data loss!' , E_USER_WARNING ) ; } return $ this ; }
2169	private function acceptLicense ( ) : Response { $ request = $ this -> container -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; if ( null === $ request ) { throw new \ RuntimeException ( 'The request stack did not contain a request' ) ; } if ( 'tl_license' !== $ request -> request -> get ( 'FORM_SUBMIT' ) ) { return $ this -> render ( 'license.html.twig' ) ; } $ this -> container -> get ( 'contao.install_tool' ) -> persistConfig ( 'licenseAccepted' , true ) ; return $ this -> getRedirectResponse ( ) ; }
2790	public static function getMutation ( array & $ tokens , $ index ) { $ num = ( float ) $ tokens [ $ index ] [ 1 ] ; if ( $ num == 0 ) { $ replace = 1.0 ; } elseif ( $ num == 1 ) { $ replace = 0.0 ; } elseif ( $ num < 2 ) { $ replace = $ num + 1 ; } else { $ replace = 1.0 ; } $ tokens [ $ index ] = [ T_DNUMBER , sprintf ( "%.2f" , $ replace ) ] ; }
2696	public function afterGetType ( Config $ config , $ result ) { if ( ! ( $ config instanceof \ Fastly \ Cdn \ Model \ Config ) ) { if ( $ result == \ Fastly \ Cdn \ Model \ Config :: FASTLY ) { return Config :: VARNISH ; } } return $ result ; }
12599	public function get ( $ key , $ default = null ) { return array_key_exists ( $ key , $ this -> configs ) ? $ this -> configs [ $ key ] : $ default ; }
7577	protected function setFileFieldValue ( $ value ) { if ( version_compare ( PHP_VERSION , '5.5.0' ) >= 0 ) { if ( ! ( $ value instanceof \ CURLFile ) ) { $ value = ltrim ( $ value , "@" ) ; $ value = new \ CURLFile ( $ value ) ; } } else { if ( strpos ( $ value , '@' ) !== 0 ) { $ value = '@' . $ value ; } } return $ value ; }
6753	public static function installWebServer ( ) { $ appPath = __DIR__ . '/../../../..' ; self :: createFolderIfNotExists ( "$appPath/web" ) ; self :: createCopy ( __DIR__ , 'app.php' , "$appPath/web" , 'app.php' ) ; self :: createCopy ( __DIR__ , 'app_dev.php' , "$appPath/web" , 'app_dev.php' ) ; }
8959	private function prepareArrayParameter ( $ name ) { if ( isset ( $ this -> parameters [ $ name ] ) ) { $ parameterArray = $ this -> parameters [ $ name ] ; $ count = count ( $ parameterArray ) ; $ str = "['" . $ parameterArray [ 0 ] . "'" ; for ( $ i = 1 ; $ i < $ count ; ++ $ i ) { $ str .= ", '" . $ parameterArray [ $ i ] . "'" ; } $ str .= ']' ; return $ str ; } }
3347	public function __preparedRequest ( $ type , $ request_type = 'GET' , $ params = array ( ) , $ data = array ( ) , $ retry_throttled = null ) { $ retry_throttled = $ retry_throttled ? : $ this -> retry_throttled ; $ path = $ this -> __getPath ( $ type , $ params ) ; while ( true ) { try { return $ this -> request ( $ request_type , $ path , $ data ) ; } catch ( ThrottledRequestException $ exception ) { if ( $ retry_throttled > 0 ) { sleep ( $ exception -> getTimeout ( ) ) ; $ retry_throttled -- ; continue ; } else { throw $ exception ; } } } return null ; }
6396	public function run ( ) : void { $ thrownException = null ; try { $ this -> lock -> lock ( ) ; try { $ this -> runnable -> run ( ) ; } catch ( Exception $ e ) { self :: getLogger ( ) -> error ( $ e ) ; $ thrownException = $ e ; } $ this -> lock -> unLock ( ) ; } catch ( LockException $ e ) { throw new RunException ( 'Lock error during running.' , 0 , $ e ) ; } if ( $ thrownException !== null ) { throw new RunException ( 'Error during execution wrapped Runnable object.' , 0 , $ thrownException ) ; } }
8547	public function setPayWithAmazonEventList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'PayWithAmazonEventList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
8163	static public function register ( ) { if ( static :: $ registered === true ) { return true ; } $ kirby = kirby ( ) ; if ( ! class_exists ( 'Kirby\Component\Template' ) ) { throw new Exception ( 'The Kirby Twig plugin requires Kirby 2.3 or higher. Current version: ' . $ kirby -> version ( ) ) ; } if ( ! class_exists ( 'Twig_Environment' ) ) { require_once __DIR__ . '/../lib/Twig/lib/Twig/Autoloader.php' ; \ Twig_Autoloader :: register ( ) ; } $ kirby -> set ( 'component' , 'template' , 'Kirby\Twig\TwigComponent' ) ; if ( is_executable ( 'twig' ) === false ) { require_once __DIR__ . '/helpers.php' ; } return static :: $ registered = true ; }
665	protected function openFromPoolSequentially ( array $ pool , array $ sharedConfig ) { if ( empty ( $ pool ) ) { return null ; } if ( ! isset ( $ sharedConfig [ 'class' ] ) ) { $ sharedConfig [ 'class' ] = get_class ( $ this ) ; } $ cache = is_string ( $ this -> serverStatusCache ) ? Yii :: $ app -> get ( $ this -> serverStatusCache , false ) : $ this -> serverStatusCache ; foreach ( $ pool as $ config ) { $ config = array_merge ( $ sharedConfig , $ config ) ; if ( empty ( $ config [ 'dsn' ] ) ) { throw new InvalidConfigException ( 'The "dsn" option must be specified.' ) ; } $ key = [ __METHOD__ , $ config [ 'dsn' ] ] ; if ( $ cache instanceof CacheInterface && $ cache -> get ( $ key ) ) { continue ; } $ db = Yii :: createObject ( $ config ) ; try { $ db -> open ( ) ; return $ db ; } catch ( \ Exception $ e ) { Yii :: warning ( "Connection ({$config['dsn']}) failed: " . $ e -> getMessage ( ) , __METHOD__ ) ; if ( $ cache instanceof CacheInterface ) { $ cache -> set ( $ key , 1 , $ this -> serverRetryInterval ) ; } } } return null ; }
5357	protected function createQueryParamStatements ( Operation $ operation ) { $ queryParamDocumentation = [ ] ; $ queryParamVariable = new Expr \ Variable ( 'queryParam' ) ; $ queryParamStatements = [ new Expr \ Assign ( $ queryParamVariable , new Expr \ New_ ( new Name ( 'QueryParam' ) ) ) ] ; if ( $ operation -> getOperation ( ) -> getParameters ( ) ) { foreach ( $ operation -> getOperation ( ) -> getParameters ( ) as $ parameter ) { if ( $ parameter instanceof Reference ) { $ parameter = $ this -> resolveParameter ( $ parameter ) ; } if ( $ parameter instanceof FormDataParameterSubSchema ) { $ queryParamStatements = array_merge ( $ queryParamStatements , $ this -> formDataParameterGenerator -> generateQueryParamStatements ( $ parameter , $ queryParamVariable ) ) ; $ queryParamDocumentation [ ] = $ this -> formDataParameterGenerator -> generateQueryDocParameter ( $ parameter ) ; } if ( $ parameter instanceof HeaderParameterSubSchema ) { $ queryParamStatements = array_merge ( $ queryParamStatements , $ this -> headerParameterGenerator -> generateQueryParamStatements ( $ parameter , $ queryParamVariable ) ) ; $ queryParamDocumentation [ ] = $ this -> headerParameterGenerator -> generateQueryDocParameter ( $ parameter ) ; } if ( $ parameter instanceof QueryParameterSubSchema ) { $ queryParamStatements = array_merge ( $ queryParamStatements , $ this -> queryParameterGenerator -> generateQueryParamStatements ( $ parameter , $ queryParamVariable ) ) ; $ queryParamDocumentation [ ] = $ this -> queryParameterGenerator -> generateQueryDocParameter ( $ parameter ) ; } } } return [ $ queryParamDocumentation , $ queryParamStatements , $ queryParamVariable ] ; }
6506	public function serializeReturnValue ( $ type , $ value ) { $ jobType = $ this -> registry -> get ( $ type ) ; return $ this -> serializer -> serialize ( $ value , 'json' , $ this -> getResponseSerializationContext ( $ jobType ) ) ; }
10273	function updateCustomProperty ( $ mailingId , $ property ) { $ queryParameters = array ( 'name' => $ property -> key , 'value' => $ property -> value ) ; return $ this -> put ( "mailings/${mailingId}/settings/properties" , "" , $ queryParameters ) ; }
9509	public function search ( Log $ log , $ level = 'all' , Request $ request ) { if ( is_null ( $ query = $ request -> get ( 'query' ) ) ) return redirect ( ) -> route ( 'admin::foundation.system.log-viewer.logs.show' , [ $ log -> date ] ) ; $ levels = $ this -> logViewer -> levelsNames ( ) ; $ entries = $ log -> entries ( $ level ) -> filter ( function ( LogEntry $ value ) use ( $ query ) { return Str :: contains ( $ value -> header , $ query ) ; } ) -> paginate ( $ this -> perPage ) ; return $ this -> view ( 'admin.system.log-viewer.show' , compact ( 'log' , 'levels' , 'level' , 'query' , 'entries' ) ) ; }
1137	public function setDepthWithSubtree ( ) { $ self = $ this ; $ this -> getConnection ( ) -> transaction ( function ( ) use ( $ self ) { $ self -> reload ( ) ; $ self -> descendantsAndSelf ( ) -> select ( $ self -> getKeyName ( ) ) -> lockForUpdate ( ) -> get ( ) ; $ oldDepth = ! is_null ( $ self -> getDepth ( ) ) ? $ self -> getDepth ( ) : 0 ; $ newDepth = $ self -> getLevel ( ) ; $ self -> newNestedSetQuery ( ) -> where ( $ self -> getKeyName ( ) , '=' , $ self -> getKey ( ) ) -> update ( array ( $ self -> getDepthColumnName ( ) => $ newDepth ) ) ; $ self -> setAttribute ( $ self -> getDepthColumnName ( ) , $ newDepth ) ; $ diff = $ newDepth - $ oldDepth ; if ( ! $ self -> isLeaf ( ) && $ diff != 0 ) $ self -> descendants ( ) -> increment ( $ self -> getDepthColumnName ( ) , $ diff ) ; } ) ; return $ this ; }
2006	protected function removeRecipient ( $ strEmail , $ arrRemove ) { if ( ( $ objRemove = NewsletterRecipientsModel :: findByEmailAndPids ( $ strEmail , $ arrRemove ) ) !== null ) { while ( $ objRemove -> next ( ) ) { $ strHash = md5 ( $ objRemove -> email ) ; if ( ( $ objBlacklist = NewsletterBlacklistModel :: findByHashAndPid ( $ strHash , $ objRemove -> pid ) ) === null ) { $ objBlacklist = new NewsletterBlacklistModel ( ) ; $ objBlacklist -> pid = $ objRemove -> pid ; $ objBlacklist -> hash = $ strHash ; $ objBlacklist -> save ( ) ; } $ objRemove -> delete ( ) ; } } $ objChannels = NewsletterChannelModel :: findByIds ( $ arrRemove ) ; $ arrChannels = $ objChannels -> fetchEach ( 'title' ) ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'removeRecipient' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'removeRecipient' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'removeRecipient' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ strEmail , $ arrRemove ) ; } } $ arrData = array ( ) ; $ arrData [ 'domain' ] = Idna :: decode ( Environment :: get ( 'host' ) ) ; $ arrData [ 'channel' ] = $ arrData [ 'channels' ] = implode ( "\n" , $ arrChannels ) ; $ objEmail = new Email ( ) ; $ objEmail -> from = $ GLOBALS [ 'TL_ADMIN_EMAIL' ] ; $ objEmail -> fromName = $ GLOBALS [ 'TL_ADMIN_NAME' ] ; $ objEmail -> subject = sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'nl_subject' ] , Idna :: decode ( Environment :: get ( 'host' ) ) ) ; $ objEmail -> text = StringUtil :: parseSimpleTokens ( $ this -> nl_unsubscribe , $ arrData ) ; $ objEmail -> sendTo ( $ strEmail ) ; if ( ( $ objTarget = $ this -> objModel -> getRelated ( 'jumpTo' ) ) instanceof PageModel ) { $ this -> redirect ( $ objTarget -> getFrontendUrl ( ) ) ; } System :: getContainer ( ) -> get ( 'session' ) -> getFlashBag ( ) -> set ( 'nl_removed' , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'nl_removed' ] ) ; $ this -> reload ( ) ; }
5557	protected function tagUrlsWithFrame ( $ urls , $ frame ) { $ tagged = array ( ) ; foreach ( $ urls as $ url ) { if ( ! $ url -> getTarget ( ) ) { $ url -> setTarget ( $ this -> getPublicNameFromIndex ( $ frame ) ) ; } $ tagged [ ] = $ url ; } return $ tagged ; }
4354	protected function setFile ( $ file ) { if ( $ file == $ this -> file ) { return ; } if ( $ this -> fileHandle ) { \ fclose ( $ this -> fileHandle ) ; $ this -> fileHandle = null ; } $ this -> file = $ file ; if ( empty ( $ file ) ) { return ; } $ fileExists = \ file_exists ( $ file ) ; $ this -> fileHandle = \ fopen ( $ file , 'a' ) ; if ( $ this -> fileHandle ) { \ fwrite ( $ this -> fileHandle , '***** ' . \ date ( 'Y-m-d H:i:s' ) . ' *****' . "\n" ) ; if ( ! $ fileExists ) { \ chmod ( $ file , 0660 ) ; } } }
10384	protected static function set_new_params ( $ type , $ hash , $ url , $ extension ) { $ data = [ 'name' => self :: $ id , 'url' => $ url . $ hash . $ extension , 'deps' => self :: unify_params ( $ type , 'deps' ) , 'version' => self :: unify_params ( $ type , 'version' , '1.0.0' ) , ] ; switch ( $ type ) { case 'style' : $ data [ 'media' ] = self :: unify_params ( $ type , 'media' , 'all' ) ; break ; case 'script' : $ data [ 'params' ] = self :: unify_params ( $ type , 'params' ) ; $ data [ 'footer' ] = self :: unify_params ( $ type , 'footer' , false ) ; $ data [ 'params' ] [ 'nonce' ] = wp_create_nonce ( self :: $ id ) ; break ; default : } self :: $ data [ $ type ] = [ $ data [ 'name' ] => $ data ] ; return true ; }
10189	public function writeVBARelationships ( Spreadsheet $ spreadsheet ) { $ objWriter = null ; if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' , 'yes' ) ; $ objWriter -> startElement ( 'Relationships' ) ; $ objWriter -> writeAttribute ( 'xmlns' , 'http://schemas.openxmlformats.org/package/2006/relationships' ) ; $ objWriter -> startElement ( 'Relationship' ) ; $ objWriter -> writeAttribute ( 'Id' , 'rId1' ) ; $ objWriter -> writeAttribute ( 'Type' , 'http://schemas.microsoft.com/office/2006/relationships/vbaProjectSignature' ) ; $ objWriter -> writeAttribute ( 'Target' , 'vbaProjectSignature.bin' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
325	public static function variablize ( $ word ) { $ word = static :: camelize ( $ word ) ; return mb_strtolower ( mb_substr ( $ word , 0 , 1 , self :: encoding ( ) ) ) . mb_substr ( $ word , 1 , null , self :: encoding ( ) ) ; }
8984	public function isEqual ( TableNode $ expected , TableNode $ actual , $ message = NULL ) { $ this -> doAssert ( 'Failed asserting that two tables were equivalent: ' , [ 'ignoreColumnSequence' => TRUE ] , $ expected , $ actual , $ message ) ; }
5180	private function addArray ( string $ key , $ value ) : self { $ this -> props [ $ key ] [ ] = $ value ; return $ this ; }
12079	public function childDissociate ( $ request , $ idParent , $ idChild , $ relation ) { $ idParent = $ this -> getRealId ( $ idParent ) ; $ idChild = $ this -> getRealId ( $ idChild ) ; if ( ! $ this -> repository -> detach ( $ idParent , $ idChild , $ relation ) ) { } return $ this -> success ( [ ] ) ; }
2070	public function deletePage ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { $ root = func_get_arg ( 7 ) ; return ( $ this -> User -> hasAccess ( $ row [ 'type' ] , 'alpty' ) && $ this -> User -> isAllowed ( Contao \ BackendUser :: CAN_DELETE_PAGE , $ row ) && ( $ this -> User -> isAdmin || ! \ in_array ( $ row [ 'id' ] , $ root ) ) ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' ; }
8351	protected function toSqlLevel ( array $ tree ) : string { if ( count ( $ tree ) == 0 ) { return '' ; } $ sql = '(' ; reset ( $ tree ) ; if ( is_numeric ( key ( $ tree ) ) === true ) { foreach ( $ tree as $ elem ) { $ sql .= $ elem . ' AND ' ; } $ sql = substr ( $ sql , 0 , - 5 ) ; } elseif ( key ( $ tree ) === 'OR' ) { foreach ( $ tree as $ value ) { if ( is_array ( $ value ) === true ) { $ sql .= $ this -> toSqlLevel ( $ value ) ; } else { $ sql .= $ value ; } $ sql .= ' OR ' ; } $ sql = substr ( $ sql , 0 , - 4 ) ; } elseif ( key ( $ tree ) === 'AND' ) { foreach ( $ tree as $ value ) { if ( is_array ( $ value ) === true ) { $ sql .= $ this -> toSqlLevel ( $ value ) ; } else { $ sql .= $ value ; } $ sql .= ' AND ' ; } $ sql = substr ( $ sql , 0 , - 5 ) ; } else { foreach ( $ tree as $ key => $ value ) { $ sql .= $ key . ' = ' . $ value . ' AND ' ; } $ sql = substr ( $ sql , 0 , - 5 ) ; } $ sql .= ')' ; return $ sql ; }
3819	private function checkboxCaption ( $ key , $ table , IAttribute $ attribute ) { return $ this -> translator -> trans ( $ table . '.' . $ key , [ $ attribute -> getName ( ) ] , 'contao_' . $ table ) ; }
2197	public function onAuthenticationSuccess ( Request $ request , TokenInterface $ token ) : RedirectResponse { $ this -> user = $ token -> getUser ( ) ; if ( ! $ this -> user instanceof User ) { return $ this -> getRedirectResponse ( $ request ) ; } $ this -> user -> lastLogin = $ this -> user -> currentLogin ; $ this -> user -> currentLogin = time ( ) ; $ this -> user -> save ( ) ; if ( null !== $ this -> logger ) { $ this -> logger -> info ( sprintf ( 'User "%s" has logged in' , $ this -> user -> username ) , [ 'contao' => new ContaoContext ( __METHOD__ , ContaoContext :: ACCESS , $ this -> user -> username ) ] ) ; } $ this -> triggerPostLoginHook ( ) ; return $ this -> getRedirectResponse ( $ request ) ; }
5909	public function retrieveUser ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/accounts/users/' . $ id . '' , $ parameters , $ cachePolicy ) ; $ result = new User ( $ result ) ; return $ result ; }
5360	protected function createBodyStatements ( Operation $ operation , $ queryParamVariable , Context $ context ) { $ bodyParameter = null ; $ bodyVariable = new Expr \ Variable ( 'body' ) ; $ parameterKey = 0 ; if ( $ operation -> getOperation ( ) -> getParameters ( ) ) { foreach ( $ operation -> getOperation ( ) -> getParameters ( ) as $ key => $ parameter ) { if ( $ parameter instanceof BodyParameter ) { $ bodyParameter = $ parameter ; $ parameterKey = $ key ; } } } if ( null === $ bodyParameter ) { return [ [ new Expr \ Assign ( $ bodyVariable , new Expr \ MethodCall ( $ queryParamVariable , 'buildFormDataString' , [ new Arg ( new Expr \ Variable ( 'parameters' ) ) ] ) ) ] , $ bodyVariable ] ; } if ( $ bodyParameter -> getSchema ( ) instanceof Reference || $ context -> getRegistry ( ) -> hasClass ( $ operation -> getReference ( ) . '/parameters/' . $ parameterKey ) ) { return [ [ new Expr \ Assign ( $ bodyVariable , new Expr \ MethodCall ( new Expr \ PropertyFetch ( new Expr \ Variable ( 'this' ) , 'serializer' ) , 'serialize' , [ new Arg ( new Expr \ Variable ( Inflector :: camelize ( $ bodyParameter -> getName ( ) ) ) ) , new Arg ( new Scalar \ String_ ( 'json' ) ) ] ) ) ] , $ bodyVariable ] ; } return [ [ new Expr \ Assign ( $ bodyVariable , new Expr \ Variable ( Inflector :: camelize ( $ bodyParameter -> getName ( ) ) ) ) ] , $ bodyVariable ] ; }
11129	protected function stringize ( array & $ arguments ) { array_walk ( $ arguments , function ( & $ value ) { if ( is_object ( $ value ) ) { $ value = get_class ( $ value ) ; } elseif ( is_scalar ( $ value ) ) { $ value = ( string ) $ value ; } else { $ value = json_encode ( $ value , 0 ) ; } } ) ; return $ this ; }
5177	public function map ( \ Closure $ callback , $ context = [ ] ) : self { $ collection = new static ( ) ; foreach ( $ this -> props as $ key => $ value ) { $ collection -> add ( $ key , $ callback ( $ value , $ key , $ context ) ) ; } return $ collection ; }
3296	protected function domDocumentArray ( $ root ) { $ result = [ ] ; if ( $ root -> hasAttributes ( ) ) { foreach ( $ root -> attributes as $ attribute ) { $ result [ '@attributes' ] [ $ attribute -> name ] = $ attribute -> value ; } } if ( $ root -> hasChildNodes ( ) ) { if ( 1 == $ root -> childNodes -> length ) { $ child = $ root -> childNodes -> item ( 0 ) ; if ( in_array ( $ child -> nodeType , [ XML_TEXT_NODE , XML_CDATA_SECTION_NODE ] ) && ! empty ( $ child -> nodeValue ) ) { $ result [ '_value' ] = $ child -> nodeValue ; return 1 == count ( $ result ) ? $ result [ '_value' ] : $ result ; } } $ groups = [ ] ; foreach ( $ root -> childNodes as $ child ) { if ( ! isset ( $ result [ $ child -> nodeName ] ) ) { $ result [ $ child -> nodeName ] = $ this -> domDocumentArray ( $ child ) ; } else { if ( ! isset ( $ groups [ $ child -> nodeName ] ) ) { $ result [ $ child -> nodeName ] = [ $ result [ $ child -> nodeName ] ] ; $ groups [ $ child -> nodeName ] = 1 ; } $ result [ $ child -> nodeName ] [ ] = $ this -> domDocumentArray ( $ child ) ; } } } return $ result ; }
632	public function update ( $ table , $ columns , $ condition = '' , $ params = [ ] ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> update ( $ table , $ columns , $ condition , $ params ) ; return $ this -> setSql ( $ sql ) -> bindValues ( $ params ) ; }
11655	private function _parseDsn ( $ dsn ) { $ dsn = parse_url ( $ dsn ) ; $ cfg = [ ] ; if ( isset ( $ dsn [ 'port' ] ) ) { $ cfg [ 'port' ] = $ dsn [ 'port' ] ; } return $ cfg + [ 'dbname' => isset ( $ dsn [ 'path' ] ) ? trim ( $ dsn [ 'path' ] , '/' ) : null , 'host' => isset ( $ dsn [ 'host' ] ) ? $ dsn [ 'host' ] : null , 'password' => isset ( $ dsn [ 'pass' ] ) ? $ dsn [ 'pass' ] : null , 'username' => isset ( $ dsn [ 'user' ] ) ? $ dsn [ 'user' ] : null , ] ; }
9802	public static function getLibXmlLoaderOptions ( ) { if ( self :: $ libXmlLoaderOptions === null && defined ( 'LIBXML_DTDLOAD' ) ) { self :: setLibXmlLoaderOptions ( LIBXML_DTDLOAD | LIBXML_DTDATTR ) ; } elseif ( self :: $ libXmlLoaderOptions === null ) { self :: $ libXmlLoaderOptions = true ; } return self :: $ libXmlLoaderOptions ; }
4882	public function getPermissions ( ) { if ( ! $ this -> permissions ) { $ perms = new Permissions ( ) ; if ( $ this -> user instanceof UserInterface ) { $ perms -> grant ( $ this -> user , PermissionsInterface :: PERMISSION_ALL ) ; } $ this -> setPermissions ( $ perms ) ; } return $ this -> permissions ; }
203	protected function createQuery ( $ targetClass , $ condition ) { $ query = $ targetClass :: find ( ) -> andWhere ( $ condition ) ; if ( $ this -> filter instanceof \ Closure ) { call_user_func ( $ this -> filter , $ query ) ; } elseif ( $ this -> filter !== null ) { $ query -> andWhere ( $ this -> filter ) ; } return $ query ; }
4664	public function setDynamicContent ( array $ params , string $ content ) { $ processed_content = preg_replace_callback ( '~\{(.*?)\}~si' , function ( $ match ) use ( $ params ) { return str_replace ( $ match [ 0 ] , isset ( $ params [ $ match [ 1 ] ] ) ? $ params [ $ match [ 1 ] ] : $ match [ 0 ] , $ match [ 0 ] ) ; } , $ content ) ; return $ processed_content ; }
537	protected function updateDocComment ( $ doc , $ properties ) { $ lines = explode ( "\n" , $ doc ) ; $ propertyPart = false ; $ propertyPosition = false ; foreach ( $ lines as $ i => $ line ) { $ line = trim ( $ line ) ; if ( strncmp ( $ line , '* @property ' , 12 ) === 0 ) { $ propertyPart = true ; } elseif ( $ propertyPart && $ line == '*' ) { $ propertyPosition = $ i ; $ propertyPart = false ; } if ( strncmp ( $ line , '* @author ' , 10 ) === 0 && $ propertyPosition === false ) { $ propertyPosition = $ i - 1 ; $ propertyPart = false ; } if ( $ propertyPart ) { unset ( $ lines [ $ i ] ) ; } } if ( $ propertyPosition === false ) { $ propertyPosition = \ count ( $ lines ) - 2 ; } $ finalDoc = '' ; foreach ( $ lines as $ i => $ line ) { $ finalDoc .= $ line . "\n" ; if ( $ i == $ propertyPosition ) { $ finalDoc .= $ properties ; } } return $ finalDoc ; }
3706	public function getMetaModelFrontendFilter ( HybridFilterBlock $ objFilterConfig ) { $ this -> objFilterConfig = $ objFilterConfig ; $ this -> formId .= $ this -> objFilterConfig -> id ; return $ this -> getFilters ( ) ; }
12654	public function getText ( $ name , $ language ) { $ allTexts = $ this -> getPageTexts ( $ language ) ; if ( isset ( $ allTexts [ $ name ] ) ) { return $ allTexts [ $ name ] ; } else { return null ; } }
11226	final public static function getShortName ( $ className = '' ) { $ base = strrchr ( static :: getRealClassName ( $ className ) , '\\' ) ; return $ base ? substr ( $ base , 1 ) : $ className ; }
7693	function MsExcel_SheetIsIt ( $ FileName ) { $ this -> MsExcel_SheetInit ( ) ; foreach ( $ this -> MsExcel_Sheets as $ o ) { if ( $ FileName == 'xl/' . $ o -> file ) return true ; } return false ; }
3623	public function temperatureInCelsius ( $ temperature , $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ temp_scale = $ this -> getDeviceTemperatureScale ( $ serial_number ) ; if ( $ temp_scale == 'F' ) { return ( $ temperature - 32 ) / 1.8 ; } return $ temperature ; }
7803	protected function statementBody ( $ text ) { $ accountNumber = $ this -> accountNumber ( $ text ) ; $ account = $ this -> reader -> createAccount ( $ accountNumber ) ; if ( ! ( $ account instanceof AccountInterface ) ) { return null ; } $ account -> setNumber ( $ accountNumber ) ; $ number = $ this -> statementNumber ( $ text ) ; $ statement = $ this -> reader -> createStatement ( $ account , $ number ) ; if ( ! ( $ statement instanceof StatementInterface ) ) { return null ; } $ statement -> setAccount ( $ account ) -> setNumber ( $ this -> statementNumber ( $ text ) ) -> setOpeningBalance ( $ this -> openingBalance ( $ text ) ) -> setClosingBalance ( $ this -> closingBalance ( $ text ) ) ; foreach ( $ this -> splitTransactions ( $ text ) as $ chunk ) { $ statement -> addTransaction ( $ this -> transaction ( $ chunk ) ) ; } return $ statement ; }
6038	protected function initTransport ( $ options , $ transport = "TCP" ) { if ( ! is_array ( $ options ) ) { throw new Ts3Exception ( "transport parameters must provided in an array" ) ; } if ( $ transport == "TCP" ) $ this -> transport = new TCP ( $ options ) ; else $ this -> transport = new UDP ( $ options ) ; }
9969	public function getDataValidation ( $ pCellCoordinate ) { if ( isset ( $ this -> dataValidationCollection [ $ pCellCoordinate ] ) ) { return $ this -> dataValidationCollection [ $ pCellCoordinate ] ; } $ this -> dataValidationCollection [ $ pCellCoordinate ] = new DataValidation ( ) ; return $ this -> dataValidationCollection [ $ pCellCoordinate ] ; }
2262	public function query ( $ strQuery ) { $ objStatement = new Statement ( $ this -> resConnection , $ this -> blnDisableAutocommit ) ; return $ objStatement -> query ( $ strQuery ) ; }
8578	public function setItemFeeAdjustmentList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ItemFeeAdjustmentList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
10805	protected function build ( ) { $ settings = $ this -> getSettings ( ) ; $ this -> beforeBuild ( ) ; $ configs = $ this -> getConfig ( ) ; $ result = [ $ this -> getType ( ) ] ; $ sp = $ settings [ 'seperator' ] ; $ in = $ settings [ 'indent' ] ; $ si = $ sp . $ in ; foreach ( $ configs as $ pos => $ part ) { if ( isset ( $ this -> before [ $ pos ] ) ) { $ result [ ] = join ( $ sp , $ this -> before [ $ pos ] ) ; } $ built = call_user_func ( [ $ this , $ part [ 'func' ] ] ) ; if ( ! empty ( $ built ) ) { $ prefix = $ part [ 'prefix' ] . ( empty ( $ part [ 'prefix' ] ) ? ( $ part [ 'indent' ] ? $ in : '' ) : $ si ) ; $ result [ ] = $ prefix . join ( $ part [ 'join' ] . $ si , $ built ) ; } if ( isset ( $ this -> after [ $ pos ] ) ) { $ result [ ] = join ( $ sp , $ this -> after [ $ pos ] ) ; } } return join ( $ sp , $ result ) ; }
12953	public function getForeignChildren ( ) { $ children = [ ] ; foreach ( $ this -> dataSource -> foreignChildKeys as $ keySet ) { $ model = $ keySet [ 'foreignModel' ] ; unset ( $ keySet [ 'foreignModel' ] ) ; if ( ! empty ( $ this -> foreignObject -> { $ keySet [ 'foreignId' ] } ) ) { $ keySet [ 'foreignId' ] = $ this -> foreignObject -> { $ keySet [ 'foreignId' ] } ; if ( ! isset ( $ children [ $ model ] ) ) { $ children [ $ model ] = [ ] ; } $ children [ $ model ] [ ] = $ keySet ; } } return $ children ; }
4877	public static function factory ( ContainerInterface $ container ) { $ config = $ container -> get ( 'ApplicationConfig' ) ; $ options = new ListenerOptions ( $ config [ 'module_listener_options' ] ) ; return new static ( $ options ) ; }
12777	public function render ( ) { $ sort = 0 ; $ query = $ this -> request -> getQuery ( ) ; if ( isset ( $ query [ 'sort' ] ) && isset ( $ this -> columns [ $ query [ 'sort' ] ] ) ) { $ sort = $ query [ 'sort' ] ; } return $ this -> formatter -> render ( $ this -> columns , $ this -> getRecords ( ) , $ this -> dataManager -> getTotalCount ( ) , $ this -> limit , $ this -> page , $ sort ) ; }
11592	public function getFullPath ( $ file = '' ) { $ this -> name = ( $ file ) ? $ file : $ this -> name ; return config ( 'odin.assetsUrl' ) . $ this -> getPath ( ) . $ this -> name ; }
2570	protected static function loadNonceBase ( $ handlerParams ) { if ( empty ( $ handlerParams -> authParams -> nonceBase ) ) { $ handlerParams -> authParams -> nonceBase = SomewhatRandomGenerator :: generateSomewhatRandomString ( ) ; } return $ handlerParams ; }
4376	protected function buildTableFooter ( $ keys ) { $ haveTotal = false ; $ cells = array ( ) ; foreach ( $ keys as $ key ) { $ colHasTotal = isset ( $ this -> tableInfo [ 'totals' ] [ $ key ] ) ; $ cells [ ] = $ colHasTotal ? $ this -> dump ( \ round ( $ this -> tableInfo [ 'totals' ] [ $ key ] , 6 ) , true , 'td' ) : '<td></td>' ; $ haveTotal = $ haveTotal || $ colHasTotal ; } if ( ! $ haveTotal ) { return '' ; } return '<tfoot>' . "\n" . '<tr><td>&nbsp;</td>' . ( $ this -> tableInfo [ 'haveObjRow' ] ? '<td>&nbsp;</td>' : '' ) . \ implode ( '' , $ cells ) . '</tr>' . "\n" . '</tfoot>' . "\n" ; }
10608	public function passwordRecoveredAction ( ) { $ this -> getResponse ( ) -> setStatusCode ( Response :: STATUS_CODE_201 ) ; $ userService = $ this -> getServiceLocator ( ) -> get ( 'user.service.user' ) ; $ id = $ this -> params ( ) -> fromRoute ( 'id' ) ; try { $ userService -> passwordRecovered ( $ id ) ; $ returnData = array ( 'status' => 'success' , 'message' => 'Ti abbiamo inviato un\'email con la nuova password per il tuo account. Se vorrai potrai modificarla una volta connesso.' ) ; } catch ( \ Exception $ e ) { $ this -> getResponse ( ) -> setStatusCode ( Response :: STATUS_CODE_500 ) ; $ returnData = @ unserialize ( $ e -> getMessage ( ) ) ; if ( ! is_array ( $ returnData ) ) { $ returnData = array ( 'status' => 'danger' , 'message' => $ e -> getMessage ( ) ) ; } } return new JsonModel ( $ returnData ) ; }
5848	public function populateMetadata ( \ TYPO3 \ CMS \ Core \ Resource \ FileInterface $ file , \ TYPO3 \ CMS \ Core \ Resource \ Folder $ folder ) { if ( is_array ( static :: $ metadata ) && count ( static :: $ metadata ) ) { \ Causal \ ImageAutoresize \ Utility \ FAL :: indexFile ( $ file , '' , '' , static :: $ metadata [ 'COMPUTED' ] [ 'Width' ] , static :: $ metadata [ 'COMPUTED' ] [ 'Height' ] , static :: $ metadata ) ; } }
2627	public function renderCellTemplate ( $ columnName ) { if ( $ columnName == 'store_id' && isset ( $ this -> _columns [ $ columnName ] ) ) { $ options = $ this -> getOptions ( __ ( '-- Select Store --' ) ) ; $ element = $ this -> elementFactory -> create ( 'select' ) ; $ element -> setForm ( $ this -> getForm ( ) ) -> setName ( $ this -> _getCellInputElementName ( $ columnName ) ) -> setHtmlId ( $ this -> _getCellInputElementId ( '<%- _id %>' , $ columnName ) ) -> setValues ( $ options ) ; return str_replace ( "\n" , '' , $ element -> getElementHtml ( ) ) ; } return parent :: renderCellTemplate ( $ columnName ) ; }
9806	private function readBSE ( ) { $ recInstance = ( 0xFFF0 & Xls :: getUInt2d ( $ this -> data , $ this -> pos ) ) >> 4 ; $ length = Xls :: getInt4d ( $ this -> data , $ this -> pos + 4 ) ; $ recordData = substr ( $ this -> data , $ this -> pos + 8 , $ length ) ; $ this -> pos += 8 + $ length ; $ BSE = new BSE ( ) ; $ this -> object -> addBSE ( $ BSE ) ; $ BSE -> setBLIPType ( $ recInstance ) ; $ btWin32 = ord ( $ recordData [ 0 ] ) ; $ btMacOS = ord ( $ recordData [ 1 ] ) ; $ rgbUid = substr ( $ recordData , 2 , 16 ) ; $ tag = Xls :: getUInt2d ( $ recordData , 18 ) ; $ size = Xls :: getInt4d ( $ recordData , 20 ) ; $ cRef = Xls :: getInt4d ( $ recordData , 24 ) ; $ foDelay = Xls :: getInt4d ( $ recordData , 28 ) ; $ unused1 = ord ( $ recordData [ 32 ] ) ; $ cbName = ord ( $ recordData [ 33 ] ) ; $ unused2 = ord ( $ recordData [ 34 ] ) ; $ unused3 = ord ( $ recordData [ 35 ] ) ; $ nameData = substr ( $ recordData , 36 , $ cbName ) ; $ blipData = substr ( $ recordData , 36 + $ cbName ) ; $ reader = new self ( $ BSE ) ; $ reader -> load ( $ blipData ) ; }
11319	function query ( $ sql , $ params = array ( ) ) { $ db = Neuron_DB_Database :: getInstance ( ) ; $ sql = $ this -> printf ( $ sql , $ params ) ; if ( $ this -> debug ) { echo $ sql . "<br><br>" ; } try { $ data = $ db -> query ( $ sql ) ; if ( $ this -> debug ) { echo '<pre>' ; var_dump ( $ data ) ; echo "</pre><br><br>" ; } $ this -> error = false ; return $ data ; } catch ( Exception $ e ) { $ this -> error = true ; echo 'error' ; } }
9883	private function writeDefinedNames ( XMLWriter $ objWriter , Spreadsheet $ spreadsheet ) { $ objWriter -> startElement ( 'definedNames' ) ; if ( count ( $ spreadsheet -> getNamedRanges ( ) ) > 0 ) { $ this -> writeNamedRanges ( $ objWriter , $ spreadsheet ) ; } $ sheetCount = $ spreadsheet -> getSheetCount ( ) ; for ( $ i = 0 ; $ i < $ sheetCount ; ++ $ i ) { $ this -> writeDefinedNameForAutofilter ( $ objWriter , $ spreadsheet -> getSheet ( $ i ) , $ i ) ; $ this -> writeDefinedNameForPrintTitles ( $ objWriter , $ spreadsheet -> getSheet ( $ i ) , $ i ) ; $ this -> writeDefinedNameForPrintArea ( $ objWriter , $ spreadsheet -> getSheet ( $ i ) , $ i ) ; } $ objWriter -> endElement ( ) ; }
9929	protected function handleUnpermittedParam ( $ key , $ params ) { if ( $ this -> getThrowExceptions ( ) ) { $ message = "Parameter '$key' is not allowed" ; throw new UnpermittedParameterException ( $ message ) ; } $ params -> delete ( $ key ) ; }
5104	public function execute ( ) { if ( is_null ( $ this -> conn ) ) throw new SquidException ( "Can't execute query, implicitly created without connection!" ) ; $ cmd = $ this -> assemble ( ) ; $ bind = $ this -> bind ( ) ; return $ this -> conn -> execute ( $ cmd , $ bind ) ; }
3314	protected function request ( $ url , $ images , array $ options = [ ] , $ requestType = false ) { $ http = ( new Http ) -> setHeaders ( [ 'Authorization' => $ this -> authorization -> getAuthorization ( ) ] ) ; $ image = is_array ( $ images ) ? $ images [ 0 ] : $ images ; $ urlName = $ requestType ? 'url_list' : 'url' ; if ( FileConverter :: isUrl ( $ image ) ) { $ isurl = true ; } else { $ isurl = false ; $ multiparts [ 'image' ] [ ] = $ image ; } $ options = $ this -> appendAppIdAndBucketIfEmpty ( $ options ) ; try { if ( $ isurl ) { $ response = $ http -> json ( $ url , array_merge ( $ options , [ $ urlName => $ image ] ) ) ; } else { $ response = $ http -> upload ( $ url , $ multiparts , $ options ) ; } } catch ( \ GuzzleHttp \ Exception \ ClientException $ e ) { if ( $ e -> hasResponse ( ) ) { $ response = $ e -> getResponse ( ) ; } } return $ http -> parseJson ( $ response ) ; }
3383	public function authenticate ( ) { $ user = $ this -> findUser ( ) ; if ( $ user === false ) { return new AuthenticationResult ( AuthenticationResult :: FAILURE_IDENTITY_NOT_FOUND , array ( ) , array ( 'User not found.' ) ) ; } $ validationResult = $ this -> passwordValidator -> isValid ( $ this -> credential , $ user [ $ this -> credentialColumn ] , $ user [ $ this -> identityColumn ] ) ; if ( $ validationResult -> isValid ( ) ) { unset ( $ user [ $ this -> getCredentialColumn ( ) ] ) ; return new AuthenticationResult ( AuthenticationResult :: SUCCESS , $ user , array ( ) ) ; } return new AuthenticationResult ( AuthenticationResult :: FAILURE_CREDENTIAL_INVALID , array ( ) , array ( 'Invalid username or password provided' ) ) ; }
4069	public function handle ( GetOptionsEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ event -> setOptions ( array_flip ( array_filter ( array_flip ( System :: getLanguages ( ) ) , function ( $ langCode ) { return ( strlen ( $ langCode ) == 2 ) ; } ) ) ) ; }
1379	protected function validateRelationship ( $ relation , ? string $ field = null ) : bool { $ path = $ field ? '/data/relationships' : '/' ; $ member = $ field ? : 'data' ; if ( ! is_object ( $ relation ) ) { $ this -> memberNotObject ( $ path , $ member ) ; return false ; } $ path = $ field ? "{$path}/{$field}" : $ path ; if ( ! property_exists ( $ relation , 'data' ) ) { $ this -> memberRequired ( $ path , 'data' ) ; return false ; } $ data = $ relation -> data ; if ( is_array ( $ data ) ) { return $ this -> validateToMany ( $ data , $ field ) ; } return $ this -> validateToOne ( $ data , $ field ) ; }
198	public function xSendFile ( $ filePath , $ attachmentName = null , $ options = [ ] ) { if ( $ attachmentName === null ) { $ attachmentName = basename ( $ filePath ) ; } if ( isset ( $ options [ 'mimeType' ] ) ) { $ mimeType = $ options [ 'mimeType' ] ; } elseif ( ( $ mimeType = FileHelper :: getMimeTypeByExtension ( $ filePath ) ) === null ) { $ mimeType = 'application/octet-stream' ; } if ( isset ( $ options [ 'xHeader' ] ) ) { $ xHeader = $ options [ 'xHeader' ] ; } else { $ xHeader = 'X-Sendfile' ; } $ disposition = empty ( $ options [ 'inline' ] ) ? 'attachment' : 'inline' ; $ this -> getHeaders ( ) -> setDefault ( $ xHeader , $ filePath ) -> setDefault ( 'Content-Type' , $ mimeType ) -> setDefault ( 'Content-Disposition' , $ this -> getDispositionHeaderValue ( $ disposition , $ attachmentName ) ) ; $ this -> format = self :: FORMAT_RAW ; return $ this ; }
232	public function quoteValue ( $ str ) { if ( ! is_string ( $ str ) ) { return $ str ; } if ( ( $ value = $ this -> db -> getSlavePdo ( ) -> quote ( $ str ) ) !== false ) { return $ value ; } return "'" . addcslashes ( str_replace ( "'" , "''" , $ str ) , "\000\n\r\\\032" ) . "'" ; }
8426	public function getAllInactiveQuery ( Production $ production ) : Query { $ qb = $ this -> createQueryBuilder ( 'p' ) ; return $ qb -> join ( 'p.groups' , 'g' ) -> andWhere ( $ qb -> expr ( ) -> eq ( 'g' , ':group' ) ) -> andWhere ( $ qb -> expr ( ) -> isNull ( 'p.parent' ) ) -> andWhere ( $ qb -> expr ( ) -> orX ( $ qb -> expr ( ) -> eq ( 'p.active' , ':active' ) , $ qb -> expr ( ) -> lt ( 'p.expiry' , ':now' ) ) ) -> setParameter ( 'group' , $ production ) -> setParameter ( 'active' , false ) -> setParameter ( 'now' , new \ DateTime ( ) ) -> addOrderBy ( 'p.updated' , 'DESC' ) -> getQuery ( ) ; }
10587	public static function cleanup ( ) : bool { $ ret = true ; foreach ( self :: $ entities as $ path => $ entity ) { if ( ! $ entity -> remove ( ) ) { $ ret = false ; } } self :: $ entities = [ ] ; return $ ret ; }
10231	public function write ( Spreadsheet $ spreadsheet = null ) { if ( ! $ spreadsheet ) { $ spreadsheet = $ this -> getParentWriter ( ) -> getSpreadsheet ( ) ; } $ objWriter = null ; if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' ) ; $ objWriter -> startElement ( 'office:document-meta' ) ; $ objWriter -> writeAttribute ( 'xmlns:office' , 'urn:oasis:names:tc:opendocument:xmlns:office:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:xlink' , 'http://www.w3.org/1999/xlink' ) ; $ objWriter -> writeAttribute ( 'xmlns:dc' , 'http://purl.org/dc/elements/1.1/' ) ; $ objWriter -> writeAttribute ( 'xmlns:meta' , 'urn:oasis:names:tc:opendocument:xmlns:meta:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:ooo' , 'http://openoffice.org/2004/office' ) ; $ objWriter -> writeAttribute ( 'xmlns:grddl' , 'http://www.w3.org/2003/g/data-view#' ) ; $ objWriter -> writeAttribute ( 'office:version' , '1.2' ) ; $ objWriter -> startElement ( 'office:meta' ) ; $ objWriter -> writeElement ( 'meta:initial-creator' , $ spreadsheet -> getProperties ( ) -> getCreator ( ) ) ; $ objWriter -> writeElement ( 'dc:creator' , $ spreadsheet -> getProperties ( ) -> getCreator ( ) ) ; $ objWriter -> writeElement ( 'meta:creation-date' , date ( DATE_W3C , $ spreadsheet -> getProperties ( ) -> getCreated ( ) ) ) ; $ objWriter -> writeElement ( 'dc:date' , date ( DATE_W3C , $ spreadsheet -> getProperties ( ) -> getCreated ( ) ) ) ; $ objWriter -> writeElement ( 'dc:title' , $ spreadsheet -> getProperties ( ) -> getTitle ( ) ) ; $ objWriter -> writeElement ( 'dc:description' , $ spreadsheet -> getProperties ( ) -> getDescription ( ) ) ; $ objWriter -> writeElement ( 'dc:subject' , $ spreadsheet -> getProperties ( ) -> getSubject ( ) ) ; $ keywords = explode ( ' ' , $ spreadsheet -> getProperties ( ) -> getKeywords ( ) ) ; foreach ( $ keywords as $ keyword ) { $ objWriter -> writeElement ( 'meta:keyword' , $ keyword ) ; } $ objWriter -> startElement ( 'meta:user-defined' ) ; $ objWriter -> writeAttribute ( 'meta:name' , 'Company' ) ; $ objWriter -> writeRaw ( $ spreadsheet -> getProperties ( ) -> getCompany ( ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'meta:user-defined' ) ; $ objWriter -> writeAttribute ( 'meta:name' , 'category' ) ; $ objWriter -> writeRaw ( $ spreadsheet -> getProperties ( ) -> getCategory ( ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
2745	public function isImageOptimizationEnabled ( ) { if ( $ this -> isFastlyEnabled ( ) !== true ) { return false ; } return $ this -> _scopeConfig -> isSetFlag ( self :: XML_FASTLY_IMAGE_OPTIMIZATIONS ) ; }
10622	public static function forThe ( MapsObjectsByIdentity $ mapped , string ... $ allowedClasses ) : MapsObjectsByIdentity { foreach ( $ mapped -> objects ( ) as $ object ) { if ( Whitelist :: doesNotHave ( $ object , $ allowedClasses ) ) { $ mapped = $ mapped -> removeThe ( $ object ) ; } } return new Whitelist ( $ allowedClasses , $ mapped ) ; }
8782	protected function finish ( $ output = null ) { if ( ! is_null ( $ output ) ) { $ file = fopen ( $ this -> file , 'w+' ) ; fwrite ( $ file , $ output ) ; fclose ( $ file ) ; return $ output ; } return false ; }
8399	public function display ( Environment $ environment , $ template , $ type = null , $ size = 'md' , $ object = null ) { $ tools = $ environment -> render ( $ template , array ( 'type' => $ type , 'object' => $ object , ) ) ; return $ environment -> render ( '@c975LToolbar/toolbar.html.twig' , array ( 'tools' => $ tools , 'size' => $ size , ) ) ; }
9640	protected function rebuildURL ( $ url ) { $ defaults = $ this -> config [ 'defaultparts' ] ; if ( ! preg_match ( '#^[a-zA-Z]+://#' , $ url ) ) { $ url = $ defaults [ 'scheme' ] . "://" . $ url ; } $ parts = parse_url ( $ url ) ; if ( ! $ parts ) { return "" ; } foreach ( $ parts as $ part => $ value ) { if ( $ this -> config [ 'removeparts' ] [ $ part ] === true ) { unset ( $ parts [ $ part ] ) ; } } foreach ( $ defaults as $ part => $ default ) { if ( ! isset ( $ parts [ $ part ] ) ) { $ parts [ $ part ] = $ default ; } } return rtrim ( http_build_url ( $ defaults , $ parts ) , "/" ) ; }
7735	private function documentRouteAndOperations ( $ metadata , Reflector $ element ) { if ( ( null !== ( $ annotation = $ this -> getAnnotation ( $ element , 'ML\HydraBundle\Mapping\Id' ) ) ) || ( null !== ( $ annotation = $ this -> getAnnotation ( $ element , 'ML\HydraBundle\Mapping\Route' ) ) ) ) { $ metadata -> setRoute ( $ this -> getRouteMetadata ( $ annotation -> route ) ) ; } $ annotation = $ this -> getAnnotation ( $ element , 'ML\HydraBundle\Mapping\Operations' ) ; if ( null !== $ annotation ) { $ operations = array_unique ( $ annotation -> operations ) ; $ operationsMetadata = array_map ( array ( $ this , 'getRouteMetadata' ) , $ operations ) ; $ metadata -> setOperations ( $ operationsMetadata ) ; } if ( null !== ( $ route = $ metadata -> getRoute ( ) ) ) { $ metadata -> addOperation ( $ this -> getRouteMetadata ( $ route -> getName ( ) ) ) ; } elseif ( null !== $ annotation ) { $ metadata -> setRoute ( $ this -> getRouteMetadata ( reset ( $ annotation -> operations ) ) ) ; } if ( ( $ metadata instanceof PropertyDefinition ) && ( count ( $ operations = $ metadata -> getOperations ( ) ) > 0 ) ) { foreach ( $ operations as $ operation ) { if ( ( 'GET' === $ operation -> getMethod ( ) ) && ( null !== $ operation -> getReturns ( ) ) ) { $ metadata -> setType ( $ operation -> getReturns ( ) ) ; return ; } } $ metadata -> setType ( 'ML\HydraBundle\Entity\Resource' ) ; } }
8077	public function delete ( $ endpoint , $ query = [ ] ) { $ endpoint = $ this -> buildUri ( $ endpoint , $ query ) ; $ headers = $ this -> buildHeaders ( ) ; $ this -> response = $ this -> client -> delete ( $ endpoint , $ headers ) ; return $ this -> response ; }
2004	public function addAttributes ( $ arrAttributes ) { parent :: addAttributes ( $ arrAttributes ) ; if ( $ this -> type != 'number' ) { return ; } foreach ( array ( 'minlength' , 'minval' , 'maxlength' , 'maxval' ) as $ name ) { if ( isset ( $ arrAttributes [ $ name ] ) ) { $ this -> $ name = $ arrAttributes [ $ name ] ; } } }
9683	public function getCountryName ( $ code ) { $ name = Intl :: getRegionBundle ( ) -> getCountryName ( strtoupper ( $ code ) , $ this -> getRequest ( ) -> getLanguageCode ( ) ? : 'en' ) ; if ( $ name ) { return $ name ; } return $ code ; }
8523	public function setAdvertisingRecommendations ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'AdvertisingRecommendations' ] [ 'FieldValue' ] = $ value ; return $ this ; }
5971	public function categories ( ) { if ( ! $ this -> categories instanceof CategoriesController ) { $ this -> categories = new CategoriesController ( $ this -> getClient ( ) , $ this -> cachePolicy , $ this -> cache ) ; $ this -> categories -> setLogger ( $ this -> logger ) ; } return $ this -> categories ; }
2491	private function configureSearchServices ( ContainerBuilder $ container , $ connectionName , $ connectionParams ) { $ alias = $ this -> getAlias ( ) ; $ endpointResolverDefinition = new DefinitionDecorator ( self :: ENDPOINT_RESOLVER_ID ) ; $ endpointResolverDefinition -> replaceArgument ( 0 , $ connectionParams [ 'entry_endpoints' ] ) ; $ endpointResolverDefinition -> replaceArgument ( 1 , $ connectionParams [ 'mapping' ] [ 'translations' ] ) ; $ endpointResolverDefinition -> replaceArgument ( 2 , $ connectionParams [ 'mapping' ] [ 'default' ] ) ; $ endpointResolverDefinition -> replaceArgument ( 3 , $ connectionParams [ 'mapping' ] [ 'main_translations' ] ) ; $ endpointResolverId = "$alias.connection.$connectionName.endpoint_resolver_id" ; $ container -> setDefinition ( $ endpointResolverId , $ endpointResolverDefinition ) ; $ coreFilterDefinition = new DefinitionDecorator ( self :: CORE_FILTER_ID ) ; $ coreFilterDefinition -> replaceArgument ( 0 , new Reference ( $ endpointResolverId ) ) ; $ coreFilterId = "$alias.connection.$connectionName.core_filter_id" ; $ container -> setDefinition ( $ coreFilterId , $ coreFilterDefinition ) ; $ gatewayDefinition = new DefinitionDecorator ( self :: GATEWAY_ID ) ; $ gatewayDefinition -> replaceArgument ( 1 , new Reference ( $ endpointResolverId ) ) ; $ gatewayId = "$alias.connection.$connectionName.gateway_id" ; $ container -> setDefinition ( $ gatewayId , $ gatewayDefinition ) ; }
689	public function addRules ( $ rules , $ append = true ) { if ( ! $ this -> enablePrettyUrl ) { return ; } $ rules = $ this -> buildRules ( $ rules ) ; if ( $ append ) { $ this -> rules = array_merge ( $ this -> rules , $ rules ) ; } else { $ this -> rules = array_merge ( $ rules , $ this -> rules ) ; } }
9742	public function addPrintAreaByColumnAndRow ( $ column1 , $ row1 , $ column2 , $ row2 , $ index = - 1 ) { return $ this -> setPrintArea ( Coordinate :: stringFromColumnIndex ( $ column1 ) . $ row1 . ':' . Coordinate :: stringFromColumnIndex ( $ column2 ) . $ row2 , $ index , self :: SETPRINTRANGE_INSERT ) ; }
8169	public static function register ( $ prepend = false ) { @ trigger_error ( 'Using Twig_Autoloader is deprecated since version 1.21. Use Composer instead.' , E_USER_DEPRECATED ) ; if ( PHP_VERSION_ID < 50300 ) { spl_autoload_register ( array ( __CLASS__ , 'autoload' ) ) ; } else { spl_autoload_register ( array ( __CLASS__ , 'autoload' ) , true , $ prepend ) ; } }
7936	public function getSeeOffers ( $ countryDestination , $ countryCurrencyPrice , $ quantity ) { return json_decode ( self :: getClient ( ) -> getSeeOffers ( $ this -> domain , $ countryDestination , $ countryCurrencyPrice , $ quantity ) ) ; }
10452	public function format ( string $ question , string $ default = null ) : string { if ( $ default != '' ) { $ default = sprintf ( '[%s]' , $ default ) ; } return trim ( $ question . $ default ) . sprintf ( '%s ' , $ this -> getDelimiter ( ) ) ; }
1487	public function merge ( DecodingList $ decodings ) : self { $ copy = new self ( ) ; $ copy -> stack = collect ( $ this -> stack ) -> merge ( $ decodings -> stack ) -> all ( ) ; return $ copy ; }
9741	public function isPrintAreaSet ( $ index = 0 ) { if ( $ index == 0 ) { return $ this -> printArea !== null ; } $ printAreas = explode ( ',' , $ this -> printArea ) ; return isset ( $ printAreas [ $ index - 1 ] ) ; }
3788	public static function calculateConditions ( IMetaModelDataDefinition $ container , array $ inputScreen ) { if ( $ container -> hasDefinition ( ModelRelationshipDefinitionInterface :: NAME ) ) { $ definition = $ container -> getDefinition ( ModelRelationshipDefinitionInterface :: NAME ) ; } else { $ definition = new DefaultModelRelationshipDefinition ( ) ; $ container -> setDefinition ( ModelRelationshipDefinitionInterface :: NAME , $ definition ) ; } if ( ! $ definition instanceof ModelRelationshipDefinitionInterface ) { throw new \ InvalidArgumentException ( 'Search element does not implement the correct interface.' ) ; } $ instance = new static ( ) ; $ instance -> container = $ container ; $ instance -> inputScreen = $ inputScreen ; $ instance -> definition = $ definition ; $ instance -> calculate ( ) ; }
3208	public static function encode ( $ string ) { if ( strlen ( $ string ) == 0 ) { return '' ; } $ binaryString = '' ; foreach ( str_split ( $ string ) as $ s ) { $ binaryString .= sprintf ( '%08b' , ord ( $ s ) ) ; } $ binaryArray = self :: chunk ( $ binaryString , 5 ) ; while ( count ( $ binaryArray ) % 8 !== 0 ) { $ binaryArray [ ] = null ; } $ base32String = '' ; foreach ( $ binaryArray as $ bin ) { $ char = 32 ; if ( ! is_null ( $ bin ) ) { $ bin = str_pad ( $ bin , 5 , 0 , STR_PAD_RIGHT ) ; $ char = bindec ( $ bin ) ; } $ base32String .= self :: $ alphabet [ $ char ] ; } return $ base32String ; }
4497	private function getAndroidJsonInner ( ? string $ text ) : array { $ data = [ ] ; if ( null !== $ text ) { $ data [ 'message' ] = $ text ; } if ( null !== $ this -> localizedKey ) { $ data [ 'message-loc-key' ] = $ this -> localizedKey ; if ( $ this -> localizedArguments ) { $ data [ 'message-loc-args' ] = $ this -> localizedArguments ; } } return $ data ; }
3780	protected function getFilteredAttribute ( ) { if ( ! ( $ attributeId = $ this -> get ( 'attr_id' ) ) ) { return null ; } if ( $ attribute = $ this -> getMetaModel ( ) -> getAttributeById ( $ attributeId ) ) { return $ attribute ; } return null ; }
3671	private function getFolderUrlFragments ( string $ alias , string $ host , string $ locale = null ) : ? array { $ pages = $ this -> getPageCandidates ( $ alias ) ; if ( null === $ pages ) { return null ; } if ( isset ( $ pages [ $ host ] ) ) { $ languages = $ pages [ $ host ] ; } else { $ languages = $ pages [ '*' ] ? : [ ] ; } unset ( $ pages ) ; $ pages = [ ] ; if ( ! $ this -> isLocalePrepended ) { $ pages = current ( $ languages ) ; } elseif ( $ locale && isset ( $ languages [ $ locale ] ) ) { $ pages = $ languages [ $ locale ] ; } if ( empty ( $ pages ) ) { return null ; } $ page = $ pages [ 0 ] ; if ( $ alias == $ page -> alias ) { $ arrFragments = [ $ alias ] ; } else { $ arrFragments = explode ( '/' , substr ( $ alias , ( \ strlen ( $ page -> alias ) + 1 ) ) ) ; array_unshift ( $ arrFragments , $ page -> alias ) ; } return $ arrFragments ; }
5829	public function newRawRequest ( $ method , $ url , $ data = '' ) { return $ this -> newRequest ( $ method , $ url , $ data , Request :: ENCODING_RAW ) ; }
9562	protected function matchesTypehint ( $ handler , Exception $ exception ) { if ( $ handler instanceof ErrorHandlerInterface ) { return true ; } if ( is_array ( $ handler ) ) { $ reflection = ( new ReflectionMethod ( $ handler [ 0 ] , $ handler [ 1 ] ) ) ; } else { $ reflection = ( new ReflectionFunction ( $ handler ) ) ; } $ params = $ reflection -> getParameters ( ) ; if ( empty ( $ params ) ) { return true ; } $ handlerHint = $ params [ 0 ] -> getClass ( ) ; if ( ! $ handlerHint ) { return true ; } return $ handlerHint -> isInstance ( $ exception ) ; }
9376	protected function check ( array $ files , $ path , $ source , $ template ) { $ file = null ; foreach ( ( array ) $ files as $ key => $ value ) { $ filepath = ( string ) str_replace ( $ path , $ source , $ value ) ; $ filepath = str_replace ( '\\' , '/' , ( string ) $ filepath ) ; $ filepath = ( string ) preg_replace ( '/^\d\//i' , '' , $ filepath ) ; $ exists = ( string ) $ filepath === $ template ; $ lowercase = strtolower ( $ filepath ) === $ template ; ( $ exists || $ lowercase ) && $ file = $ value ; } return $ file ; }
12336	public function changePasswordAction ( ) { if ( ! $ this -> cmsAuthentication ( ) -> hasIdentity ( ) ) { return $ this -> redirect ( ) -> toRoute ( $ this -> getOptions ( ) -> getLoginRoute ( ) ) ; } $ url = $ this -> url ( ) -> fromRoute ( null , [ 'action' => 'change-password' ] ) ; $ prg = $ this -> prg ( $ url , true ) ; if ( $ prg instanceof ResponseInterface ) { return $ prg ; } $ post = $ prg ; $ form = $ this -> getUserService ( ) -> getChangePasswordForm ( ) ; $ form -> setObject ( $ this -> cmsAuthentication ( ) -> getIdentity ( ) ) ; $ form -> setAttribute ( 'action' , $ url ) ; if ( $ post && $ form -> setData ( $ post ) -> isValid ( ) ) { $ identity = $ this -> getUserService ( ) -> changePassword ( $ post ) ; if ( $ identity instanceof ResponseInterface ) { return $ identity ; } elseif ( $ identity ) { $ viewModel = new ViewModel ( compact ( 'identity' ) ) ; $ viewModel -> setTemplate ( 'cms-user/index/change-password-success' ) ; return $ viewModel ; } } return new ViewModel ( compact ( 'form' ) ) ; }
10495	public function mod ( $ value ) { $ value = Cast :: Float ( $ value ) ; if ( $ value == 0 ) { throw new InvalidArgumentException ( 'Division by zero' ) ; } if ( $ this -> value === null ) { return new FloatType ( $ this -> value ) ; } return new FloatType ( $ this -> value % $ value ) ; }
5063	public function outputJson ( int $ depth = 512 , int $ options = 0 ) { $ json = json_decode ( $ this -> output ( ) , false , $ depth , $ options ) ; if ( is_null ( $ json ) ) { $ errorMessage = json_last_error_msg ( ) ; throw new JsonDecodeException ( $ errorMessage ) ; } return $ json ; }
1246	public static function env ( ) { return function ( ) { $ appId = getenv ( self :: ENV_APP_ID ) ; $ certId = getenv ( self :: ENV_CERT_ID ) ; $ devId = getenv ( self :: ENV_DEV_ID ) ; if ( $ appId && $ certId && $ devId ) { return new Credentials ( $ appId , $ certId , $ devId ) ; } else { return new \ InvalidArgumentException ( 'Could not find environment variable ' . 'credentials in ' . self :: ENV_APP_ID . '/' . self :: ENV_CERT_ID . '/' . self :: ENV_DEV_ID ) ; } } ; }
7772	protected function replaceMessageFormat ( $ message , array $ item ) { $ keys = array_keys ( $ item ) ; if ( ! empty ( $ item [ 'args' ] ) ) { $ args = $ item [ 'args' ] ; $ argReplace = array_map ( function ( $ i ) { return "{\${$i}}" ; } , array_keys ( $ args ) ) ; $ args [ ] = count ( $ item [ 'args' ] ) ; $ argReplace [ ] = '{$#}' ; $ args [ ] = implode ( ', ' , $ item [ 'args' ] ) ; $ argReplace [ ] = '{$*}' ; $ message = str_replace ( $ argReplace , $ args , $ message ) ; } $ message = str_replace ( [ '{field}' , '{value}' ] , [ $ item [ 'field' ] , $ item [ 'value' ] ] , $ message ) ; return $ message ; }
3415	public function update ( array $ fields = [ ] ) { $ keys = [ ] ; foreach ( $ fields as $ key => $ value ) { array_set ( $ this -> fields , $ key , $ value ) ; $ keys [ ] = $ key ; } return $ this -> save ( $ keys ) ; }
5141	public function run ( ) : void { $ request = $ request = ServerRequestFactory :: fromGlobals ( ) ; $ response = $ this -> process ( $ request ) ; $ emitter = $ this -> getContainer ( ) -> has ( EmitterInterface :: class ) ? $ this -> getContainer ( ) -> get ( EmitterInterface :: class ) : new SapiEmitter ( ) ; $ emitter -> emit ( $ response ) ; }
142	public function getInstallPath ( PackageInterface $ package ) { $ installer = $ this -> getInstaller ( $ package -> getType ( ) ) ; return $ installer -> getInstallPath ( $ package ) ; }
8406	private function getModelName ( ) { if ( isset ( $ this -> class ) ) { return $ this -> class ; } if ( isset ( $ this -> model ) ) { $ rClass = new \ ReflectionClass ( $ this -> model ) ; return $ rClass -> getShortName ( ) ; } return 'Icon' ; }
919	public function getEnd ( ) { $ reachedContent = false ; foreach ( $ this -> doc -> getLines ( ) as $ index => $ line ) { if ( $ reachedContent && ( $ line -> containsATag ( ) || ! $ line -> containsUsefulContent ( ) ) ) { return $ index - 1 ; } if ( $ line -> containsATag ( ) ) { return null ; } if ( $ line -> containsUsefulContent ( ) ) { $ reachedContent = true ; } } }
7805	protected function openingBalance ( $ text ) { if ( $ line = $ this -> getLine ( '60F|60M' , $ text ) ) { return $ this -> balance ( $ this -> reader -> createOpeningBalance ( ) , $ line ) ; } }
12455	public function hasToolbar ( ) { $ fileSkeleton = '/Resources/views/Editor/Toolbar/_toolbar_%s_buttons.html.twig' ; return file_exists ( $ this -> pluginDir . sprintf ( $ fileSkeleton , 'left' ) ) || file_exists ( $ this -> pluginDir . sprintf ( $ fileSkeleton , 'right' ) ) ; }
4234	private static function splitParams ( $ paramStr ) { $ depth = 0 ; $ startPos = 0 ; $ chars = \ str_split ( $ paramStr ) ; $ params = array ( ) ; foreach ( $ chars as $ pos => $ char ) { switch ( $ char ) { case ',' : if ( $ depth === 0 ) { $ params [ ] = \ trim ( \ substr ( $ paramStr , $ startPos , $ pos - $ startPos ) ) ; $ startPos = $ pos + 1 ; } break ; case '[' : case '(' : $ depth ++ ; break ; case ']' : case ')' : $ depth -- ; break ; } } $ params [ ] = \ trim ( \ substr ( $ paramStr , $ startPos , $ pos + 1 - $ startPos ) ) ; return $ params ; }
12281	public function getCode ( ) { $ data = [ 'component_appid' => $ this -> getAppId ( ) , ] ; $ result = $ this -> parseJSON ( 'json' , [ self :: CREATE_PRE_AUTH_CODE , $ data ] ) ; if ( empty ( $ result [ 'pre_auth_code' ] ) ) { throw new InvalidArgumentException ( 'Invalid response.' ) ; } return $ result [ 'pre_auth_code' ] ; }
10423	public function setTriggerType ( $ type ) { if ( ! array_key_exists ( $ type , $ this -> validTypes ) ) { throw new \ InvalidArgumentException ( 'The type MUST be one of:' . implode ( ',' , $ this -> validTypes ) ) ; } $ this -> type = $ this -> validTypes [ $ type ] ; $ this -> typeAlias = $ type ; }
3533	public static function findByAttribute ( $ attribute , $ searchValue ) { if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: beginProfile ( 'Attribute: ' . $ attribute . '; Value: ' . $ searchValue , static :: YII2_PROFILE_NAME . 'findByAttribute' ) ; } $ userObjectsFound = static :: getAdldapProvider ( ) -> search ( ) -> select ( 'samaccountname' ) -> where ( $ attribute , '=' , $ searchValue ) -> get ( ) ; $ userObjectReturn = null ; if ( count ( $ userObjectsFound ) == 1 ) { $ userObjectReturn = static :: findByUsername ( $ userObjectsFound [ 0 ] [ 'samaccountname' ] [ 0 ] ) ; } if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: endProfile ( 'Attribute: ' . $ attribute . '; Value: ' . $ searchValue , static :: YII2_PROFILE_NAME . 'findByAttribute' ) ; } return $ userObjectReturn ; }
3362	private function isFullyLoaded ( ) { return $ this -> fullyLoaded || ( $ this -> limit && count ( $ this -> container ) >= $ this -> limit ) ; }
1054	private function varTypeAllowedForType ( $ varType , $ expectedType ) { if ( $ expectedType instanceof NonNull ) { if ( $ varType instanceof NonNull ) { return $ this -> varTypeAllowedForType ( $ varType -> getWrappedType ( ) , $ expectedType -> getWrappedType ( ) ) ; } return false ; } if ( $ varType instanceof NonNull ) { return $ this -> varTypeAllowedForType ( $ varType -> getWrappedType ( ) , $ expectedType ) ; } if ( $ varType instanceof ListOfType && $ expectedType instanceof ListOfType ) { return $ this -> varTypeAllowedForType ( $ varType -> getWrappedType ( ) , $ expectedType -> getWrappedType ( ) ) ; } return $ varType === $ expectedType ; }
64	public function size ( $ path ) { if ( ! file_exists ( $ path ) ) { throw new \ RuntimeException ( "$path does not exist." ) ; } if ( is_dir ( $ path ) ) { return $ this -> directorySize ( $ path ) ; } return filesize ( $ path ) ; }
6060	public function retrieveFileData ( $ id , $ template = null , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'template' => $ template ] , 'body' => json_encode ( [ ] ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/media/' . $ id . '/asset' , $ parameters , $ cachePolicy ) ; return $ result ; }
10957	public function iLikeToMoveItMoveItBack ( ) { $ moveCommand = $ this -> popCommandFromList ( ) ; $ moveCommand -> reverseFromToDirs ( ) ; $ this -> direction = self :: DIRECTION_BACK ; $ this -> init ( $ moveCommand ) ; $ this -> processFiles ( ) ; }
10959	private function processSplFileInfo ( \ SplFileInfo $ file ) { if ( $ this -> getCurrentCommand ( ) -> isUsePathReplace ( ) ) { $ this -> getCurrentCommand ( ) -> setToDirectory ( NULL ) ; } $ filePathFrom = $ this -> prepareFilePathFrom ( $ file ) ; $ filePathTo = $ this -> prepareFilePathTo ( $ file ) ; $ this -> currentFilePathFrom = $ filePathFrom ; $ this -> currentFilePathTo = $ filePathTo ; $ this -> validateFileFrom ( $ filePathFrom ) ; $ this -> validateFileTo ( $ filePathTo ) ; if ( ! $ this -> isMoveIt ( ) ) { return null ; } $ result = $ this -> doSystemCommand ( $ filePathFrom , $ filePathTo ) ; return $ result ; }
6797	private function convertRows ( Statement $ dbResult , $ idColumn , $ valueColumn ) { $ result = [ ] ; while ( $ row = $ dbResult -> fetch ( \ PDO :: FETCH_ASSOC ) ) { if ( ! isset ( $ result [ $ row [ $ idColumn ] ] ) ) { $ result [ $ row [ $ idColumn ] ] = [ ] ; } $ data = $ row ; unset ( $ data [ $ idColumn ] ) ; $ result [ $ row [ $ idColumn ] ] [ $ row [ $ valueColumn ] ] = $ data ; } return $ result ; }
4303	public function profile ( $ name = null ) { if ( ! $ this -> cfg [ 'collect' ] ) { return ; } if ( ! $ this -> cfg [ 'enableProfiling' ] ) { $ callerInfo = $ this -> utilities -> getCallerInfo ( ) ; $ this -> appendLog ( __FUNCTION__ , array ( 'Profile: Unable to start - enableProfiling opt not set. ' . $ callerInfo [ 'file' ] . ' on line ' . $ callerInfo [ 'line' ] . '.' ) ) ; return ; } $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) , array ( 'name' => null ) , array ( 'name' ) ) ; if ( $ meta [ 'name' ] === null ) { $ meta [ 'name' ] = 'Profile ' . $ this -> data [ 'profileAutoInc' ] ; $ this -> data [ 'profileAutoInc' ] ++ ; } $ name = $ meta [ 'name' ] ; $ message = '' ; if ( isset ( $ this -> data [ 'profileInstances' ] [ $ name ] ) ) { $ instance = $ this -> data [ 'profileInstances' ] [ $ name ] ; $ instance -> end ( ) ; $ instance -> start ( ) ; unset ( $ this -> data [ 'profileInstances' ] [ $ name ] ) ; $ this -> data [ 'profileInstances' ] [ $ name ] = $ instance ; $ message = 'Profile \'' . $ name . '\' restarted' ; } else { $ this -> data [ 'profileInstances' ] [ $ name ] = $ this -> methodProfile ; $ message = 'Profile \'' . $ name . '\' started' ; } $ this -> appendLog ( __FUNCTION__ , array ( $ message , ) , $ meta ) ; }
12891	protected function redirectCorrectDomainSystemParams ( & $ domainParams ) { $ localizationParamName = static :: URL_PARAM_LOCALIZATION ; if ( isset ( $ domainParams [ $ localizationParamName ] ) ) { $ domainParams [ $ localizationParamName ] = $ this -> redirectLocalizationGetUrlValueAndUnsetGet ( $ domainParams [ $ localizationParamName ] ) ; } }
10716	public function deleteMany ( ArrayAccess $ models ) { $ results = [ ] ; foreach ( $ models as $ model ) { $ results [ ] = $ this -> delete ( $ model ) ; } return $ this -> returnResults ( $ results ) ; }
5583	public function clickLinkById ( $ id ) { if ( ! ( $ url = $ this -> getLinkById ( $ id ) ) ) { return false ; } $ this -> load ( $ url , new SimpleGetEncoding ( ) ) ; return $ this -> getContent ( ) ; }
4519	public function get ( string $ key ) { $ parameter = $ this -> repository -> findOneBy ( [ 'key' => $ key ] ) ; if ( ! $ parameter ) { throw new OutOfRangeException ( 'Parameter "' . $ key . '" does not exist.' ) ; } $ this -> manager -> detach ( $ parameter ) ; return $ parameter -> getValue ( ) ; }
2676	public function upsertAclItem ( $ aclId , $ itemValue , $ negated , $ comment = 'Added by Magento Module' , $ subnet = false ) { $ body = [ 'ip' => $ itemValue , 'negated' => $ negated , 'comment' => $ comment ] ; if ( $ subnet ) { $ body [ 'subnet' ] = $ subnet ; } $ url = $ this -> _getApiServiceUri ( ) . 'acl/' . $ aclId . '/entry' ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: POST , $ body ) ; return $ result ; }
9854	protected function append ( $ data ) { if ( strlen ( $ data ) - 4 > $ this -> limit ) { $ data = $ this -> addContinue ( $ data ) ; } $ this -> _data .= $ data ; $ this -> _datasize += strlen ( $ data ) ; }
2893	public function canCaptureBlock ( $ block ) { $ blockClass = get_class ( $ block ) ; if ( ! $ this -> canCaptureCoreBlocks ( ) && strpos ( $ blockClass , 'Mage_' ) === 0 ) { return false ; } if ( strpos ( $ blockClass , 'Sheep_Debug_Block' ) > 0 ) { return false ; } return true ; }
12061	public function getPermissionMap ( $ forRequestPath , $ forRoutePath = "" ) { if ( isset ( $ this -> loaded [ $ forRequestPath ] ) ) { return $ this -> loaded [ $ forRequestPath ] ; } $ database = $ this -> database ; $ permissionsSQLd = NULL ; if ( ! empty ( $ forRoutePath ) && ( $ forRoutePath <> $ forRequestPath ) ) : $ permissionsSQLd = "OR {$database->quote($forRoutePath)} REGEXP p.permission_area_uri" ; endif ; $ premissionsSQLc = "SELECT p.*, a.lft, a.rgt, a.authority_name,a.authority_parent_id FROM ?authority_permissions AS p LEFT JOIN ?authority AS a ON p.authority_id=a.authority_id WHERE {$database->quote($forRequestPath)} REGEXP p.permission_area_uri {$permissionsSQLd} ORDER BY a.lft ASC" ; $ permissionsSQL = $ database -> prepare ( $ premissionsSQLc ) ; $ permissions = $ permissionsSQL -> execute ( ) -> fetchAll ( ) ; $ this -> loaded [ $ forRoutePath ] = $ permissions ; return $ this -> loaded [ $ forRoutePath ] ; }
482	public function addForeignKey ( $ name , $ table , $ columns , $ refTable , $ refColumns , $ delete = null , $ update = null ) { $ time = $ this -> beginCommand ( "add foreign key $name: $table (" . implode ( ',' , ( array ) $ columns ) . ") references $refTable (" . implode ( ',' , ( array ) $ refColumns ) . ')' ) ; $ this -> db -> createCommand ( ) -> addForeignKey ( $ name , $ table , $ columns , $ refTable , $ refColumns , $ delete , $ update ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
2455	public function copyAll ( ) { if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notCopyable' ] ) { throw new InternalServerErrorException ( 'Table "' . $ this -> strTable . '" is not copyable.' ) ; } $ objSession = System :: getContainer ( ) -> get ( 'session' ) ; $ arrClipboard = $ objSession -> get ( 'CLIPBOARD' ) ; if ( isset ( $ arrClipboard [ $ this -> strTable ] ) && \ is_array ( $ arrClipboard [ $ this -> strTable ] [ 'id' ] ) ) { foreach ( $ arrClipboard [ $ this -> strTable ] [ 'id' ] as $ id ) { $ this -> intId = $ id ; $ id = $ this -> copy ( true ) ; Input :: setGet ( 'pid' , $ id ) ; Input :: setGet ( 'mode' , 1 ) ; } } $ this -> redirect ( $ this -> getReferer ( ) ) ; }
11265	public function model ( $ pathname ) { $ fullPath = $ this -> config [ 'pathToModels' ] . $ this -> getPath ( $ pathname ) . $ this -> config [ 'modelsPrefix' ] . $ this -> getName ( $ pathname ) . $ this -> config [ 'modelsPostfix' ] . '.php' ; include_once ( $ fullPath ) ; }
12845	protected function processTextType ( $ value , \ Symfony \ Component \ Form \ FormInterface $ form , \ Chill \ CustomFieldsBundle \ Entity \ CustomField $ cf ) { $ form -> submit ( array ( $ cf -> getSlug ( ) => $ value ) ) ; $ value = $ form -> getData ( ) [ $ cf -> getSlug ( ) ] ; $ this -> logger -> debug ( sprintf ( "Found value : %s for custom field with question " . "'%s'" , $ value , $ this -> helper -> localize ( $ cf -> getName ( ) ) ) ) ; return $ value ; }
7147	public function get_user_settings ( $ default = array ( ) , $ user_id = NULL ) { if ( ! $ user_id ) return $ default ; $ default_opt_in = apply_filters ( 'iac_default_opt_in' , FALSE ) ; $ default = $ default_opt_in ? '1' : '0' ; $ settings = array ( 'inform_about_posts' => get_user_meta ( $ user_id , 'post_subscription' , TRUE ) , 'inform_about_comments' => get_user_meta ( $ user_id , 'comment_subscription' , TRUE ) ) ; foreach ( $ settings as $ k => $ v ) { if ( '' === $ v ) $ settings [ $ k ] = $ default ; } return $ settings ; }
12602	public static function delete ( $ path ) { $ path = Path :: clean ( $ path ) ; $ fs = new Filesystem ( ) ; try { $ fs -> remove ( $ path ) ; } catch ( IOExceptionInterface $ e ) { throw new Exception ( Helper :: getTranslation ( 'FAILED_DELETING' ) . ' - (' . $ e -> getMessage ( ) . ')' ) ; } return true ; }
2762	public function log ( GitEvent $ gitEvent , string $ message , array $ context = [ ] , ? string $ eventName = null ) : void { if ( $ eventName === null && method_exists ( $ gitEvent , 'getName' ) ) { $ eventName = $ gitEvent -> getName ( ) ; } $ method = $ this -> getLogLevelMapping ( $ eventName ) ; $ context += [ 'command' => $ gitEvent -> getProcess ( ) -> getCommandLine ( ) ] ; $ this -> logger -> { $ method } ( $ message , $ context ) ; }
4566	public function getForms ( $ id ) { $ forms = [ ] ; $ form = $ this -> getForm ( $ id ) ; $ form -> setMethod ( 'POST' ) -> setPrimary ( true ) ; $ forms [ ] = $ form ; switch ( $ form -> getType ( ) ) { case Form :: TYPE_FORMIO : $ components = $ form -> getSchema ( ) ; $ resolverCollection = $ this -> resolverCollection ; $ extract = function ( & $ container , $ key , & $ component ) use ( & $ extract , & $ forms , $ resolverCollection ) { switch ( true ) { case property_exists ( $ component , 'components' ) : foreach ( $ component -> components as $ key => & $ subComponent ) { $ extract ( $ component -> components , $ key , $ subComponent ) ; } break ; case property_exists ( $ component , 'columns' ) : foreach ( $ component -> columns as & $ column ) { foreach ( $ column -> components as $ key => & $ subComponent ) { $ extract ( $ column -> components , $ key , $ subComponent ) ; } } break ; case property_exists ( $ component , 'properties' ) && is_object ( $ component -> properties ) && property_exists ( $ component -> properties , 'ds_form' ) : $ form = $ this -> getForm ( $ component -> properties -> ds_form ) ; $ data = [ ] ; if ( property_exists ( $ component , 'defaultValue' ) ) { try { $ data = $ resolverCollection -> resolve ( $ component -> defaultValue ) ; } catch ( UnresolvedException $ exception ) { $ data = [ ] ; } catch ( UnmatchedException $ exception ) { } } $ form -> setData ( $ data ) ; $ forms [ ] = $ form ; unset ( $ container [ $ key ] ) ; break ; } } ; foreach ( $ components as $ key => & $ component ) { $ extract ( $ components , $ key , $ component ) ; } $ form -> setSchema ( array_values ( $ components ) ) ; break ; case Form :: TYPE_SYMFONY : break ; default : throw new DomainException ( 'Form type does not exist.' ) ; } return $ forms ; }
7865	protected function drawBordered ( $ content ) { $ left = $ this -> geometry -> getLeftBordersWith ( static :: BORDER_X ) ; $ right = $ this -> geometry -> getRightBordersWith ( static :: BORDER_X ) ; $ this -> drawRow ( $ left . $ content . $ right ) ; }
8165	public function compile ( Twig_NodeInterface $ node , $ indentation = 0 ) { $ this -> lastLine = null ; $ this -> source = '' ; $ this -> debugInfo = array ( ) ; $ this -> sourceOffset = 0 ; $ this -> sourceLine = 1 ; $ this -> indentation = $ indentation ; $ this -> varNameSalt = 0 ; if ( $ node instanceof Twig_Node_Module ) { $ this -> filename = $ node -> getTemplateName ( ) ; } $ node -> compile ( $ this ) ; return $ this ; }
1899	private function createConfig ( $ size , ImageInterface $ image ) : array { if ( ! \ is_array ( $ size ) ) { $ size = [ 0 , 0 , $ size ] ; } $ config = new ResizeConfiguration ( ) ; if ( isset ( $ size [ 2 ] ) && is_numeric ( $ size [ 2 ] ) ) { $ imageModel = $ this -> framework -> getAdapter ( ImageSizeModel :: class ) ; $ imageSize = $ imageModel -> findByPk ( $ size [ 2 ] ) ; if ( null !== $ imageSize ) { $ config -> setWidth ( $ imageSize -> width ) -> setHeight ( $ imageSize -> height ) -> setMode ( $ imageSize -> resizeMode ) -> setZoomLevel ( $ imageSize -> zoom ) ; } return [ $ config , null ] ; } if ( ! empty ( $ size [ 0 ] ) ) { $ config -> setWidth ( $ size [ 0 ] ) ; } if ( ! empty ( $ size [ 1 ] ) ) { $ config -> setHeight ( $ size [ 1 ] ) ; } if ( ! isset ( $ size [ 2 ] ) || 1 !== substr_count ( $ size [ 2 ] , '_' ) ) { if ( ! empty ( $ size [ 2 ] ) ) { $ config -> setMode ( $ size [ 2 ] ) ; } return [ $ config , null ] ; } $ config -> setMode ( ResizeConfigurationInterface :: MODE_CROP ) ; return [ $ config , $ this -> getImportantPartFromLegacyMode ( $ image , $ size [ 2 ] ) ] ; }
4117	public function isWithinCachedBlock ( Mage_Core_Block_Abstract $ block ) { $ step = $ block ; $ i = 0 ; while ( $ i ++ < 20 && $ step instanceof Mage_Core_Block_Abstract ) { if ( ! is_null ( $ step -> getCacheLifetime ( ) ) ) { return true ; } $ step = $ step -> getParentBlock ( ) ; } return false ; }
3382	public function hasPermission ( $ permission ) { $ permission = Permission :: whereName ( $ permission ) -> first ( ) ; if ( is_null ( $ permission ) ) { return false ; } return $ this -> hasRole ( $ permission -> roles ) ; }
1126	public function isSelfOrDescendantOf ( $ other ) { return ( $ this -> getLeft ( ) >= $ other -> getLeft ( ) && $ this -> getLeft ( ) < $ other -> getRight ( ) && $ this -> inSameScope ( $ other ) ) ; }
12359	public static function decodeHashId ( $ idHashed ) { if ( ! config ( 'odin.hashid.active' ) ) { return $ idHashed ; } $ hashids = App :: make ( 'Hashids' ) ; $ hashId = $ hashids -> decode ( $ idHashed ) ; return ( count ( $ hashId ) > 0 ) ? $ hashId [ 0 ] : '' ; }
10711	public function getManyByIds ( array $ ids , $ columns = [ '*' ] ) { $ results = $ this -> getQuery ( ) -> findMany ( $ ids , $ columns ) ; return $ this -> returnResults ( $ results ) ; }
4086	public function handle ( BuildWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) || ( $ event -> getProperty ( ) -> getName ( ) !== 'filterparams' ) ) { return ; } $ model = $ event -> getModel ( ) ; $ objFilterSettings = $ this -> settingFactory -> createCollection ( $ model -> getProperty ( 'filter' ) ) ; $ extra = $ event -> getProperty ( ) -> getExtra ( ) ; $ extra [ 'subfields' ] = $ objFilterSettings -> getParameterDCA ( ) ; $ event -> getProperty ( ) -> setExtra ( $ extra ) ; }
4450	public function popByJid ( string $ jid , ? string $ worker = null ) : ? BaseJob { $ workerName = $ worker ? : $ this -> client -> getWorkerName ( ) ; $ data = json_decode ( $ this -> client -> popByJid ( $ this -> name , $ jid , $ workerName ) , true ) ; $ jobData = array_reduce ( $ data , 'array_merge' , [ ] ) ; if ( isset ( $ jobData [ 'jid' ] ) === false ) { return null ; } if ( $ jobData [ 'jid' ] === $ jid ) { $ job = new BaseJob ( $ this -> client , $ jobData ) ; $ job -> setEventsManager ( $ this -> getEventsManager ( ) ) ; } return $ job ?? null ; }
7374	public function has ( string $ key ) : bool { return isset ( $ _SESSION ) ? array_key_exists ( $ key , $ _SESSION ) : false ; }
12410	public function delete ( $ groupId ) { $ params = [ 'group_id' => intval ( $ groupId ) , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_DELETE , $ params ] ) ; }
3132	public function init ( RunnerServiceContext $ context ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ session = $ context -> getTestSession ( ) ; if ( $ session -> getState ( ) === AssessmentTestSessionState :: INITIAL ) { $ session -> beginTestSession ( ) ; $ event = new TestInitEvent ( $ session ) ; $ this -> getServiceManager ( ) -> get ( EventManager :: SERVICE_ID ) -> trigger ( $ event ) ; \ common_Logger :: i ( "Assessment Test Session begun." ) ; if ( $ context -> isAdaptive ( ) ) { \ common_Logger :: t ( "Very first item is adaptive." ) ; $ nextCatItemId = $ context -> selectAdaptiveNextItem ( ) ; $ context -> persistCurrentCatItemId ( $ nextCatItemId ) ; $ context -> persistSeenCatItemIds ( $ nextCatItemId ) ; } } elseif ( $ session -> getState ( ) === AssessmentTestSessionState :: SUSPENDED ) { $ session -> resume ( ) ; } $ session -> initItemTimer ( ) ; if ( $ session -> isTimeout ( ) === false ) { TestRunnerUtils :: beginCandidateInteraction ( $ session ) ; } $ this -> getServiceManager ( ) -> get ( ExtendedStateService :: SERVICE_ID ) -> clearEvents ( $ session -> getSessionId ( ) ) ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'init' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } return true ; }
10841	public function sayHello ( ) { $ text = $ this -> getHALLogo ( ) ; if ( $ this -> showText ) { $ text .= $ this -> getHelloDave ( ) ; } $ lines = explode ( "\n" , $ text ) ; $ spaces = '' ; if ( $ this -> center ) { $ max_length = 0 ; foreach ( $ lines as $ line ) { $ max_length = max ( $ max_length , Helper :: strlenWithoutDecoration ( $ this -> output -> getFormatter ( ) , $ line ) ) ; } $ numberOfSpaces = floor ( ( $ this -> screenSize [ 0 ] - $ max_length ) / 2 ) ; if ( $ numberOfSpaces > 0 ) { $ spaces = str_repeat ( ' ' , $ numberOfSpaces ) ; } } foreach ( $ lines as $ line ) { $ this -> output -> writeln ( $ spaces . $ line ) ; } }
3487	private static function tryResolveByWebTokenJwtSystem ( ) : ? WebTokenJwtSignatureGenerator { $ requiredClasses = [ WebTokenComponentJws :: class , WebTokenComponentJwk :: class , WebTokenComponentJWKFactory :: class , ] ; foreach ( $ requiredClasses as $ requiredClass ) { if ( ! class_exists ( $ requiredClass ) ) { return null ; } } return new WebTokenJwtSignatureGenerator ( ) ; }
6599	protected function getReturnType ( array $ lines ) { foreach ( $ lines as $ line ) { if ( strpos ( $ line , '@return' ) === 0 ) { $ type = trim ( str_replace ( '@return' , '' , $ line ) ) ; $ type = str_replace ( '$this' , 'self' , $ type ) ; $ type = explode ( '|' , $ type ) ; return $ type ; } } return [ ] ; }
2624	private function sendReqToGA ( $ body = '' , $ method = \ Zend_Http_Client :: POST , $ uri = self :: GA_API_ENDPOINT ) { $ reqGAData = ( array ) $ this -> getGAReqData ( ) ; if ( $ body != '' && is_array ( $ body ) && ! empty ( $ body ) ) { $ body = array_merge ( $ reqGAData , $ body ) ; } try { $ client = $ this -> curlFactory -> create ( ) ; $ client -> addOption ( CURLOPT_TIMEOUT , 10 ) ; $ client -> write ( $ method , $ uri , '1.1' , null , http_build_query ( $ body ) ) ; $ response = $ client -> read ( ) ; $ responseCode = \ Zend_Http_Response :: extractCode ( $ response ) ; $ client -> close ( ) ; if ( $ responseCode != '200' ) { throw new LocalizedException ( __ ( 'Return status ' . $ responseCode ) ) ; } return true ; } catch ( \ Exception $ e ) { return false ; } }
11066	public function addMethods ( $ mixin , array $ methods ) { foreach ( $ methods as $ method ) { $ this -> method_map [ $ method ] = $ mixin ; } return $ this ; }
4141	protected function getSignatureBaseString ( ) { $ method = strtoupper ( $ this -> method ) ; $ url = rawurlencode ( $ this -> getUrl ( ) ) ; return $ method . '&' . $ url . '&' . $ this -> getRequestString ( ) ; }
4737	public function sendException ( Request $ request , \ Exception $ exception ) { if ( ! $ this -> enabled ) { return ; } $ serverParams = $ request -> server -> all ( ) ; if ( isset ( $ serverParams [ 'PHP_AUTH_PW' ] ) ) { $ serverParams [ 'PHP_AUTH_PW' ] = '*****' ; } $ message = \ Swift_Message :: newInstance ( ) -> setSubject ( 'Error message from ' . $ request -> getHost ( ) . ' - ' . $ exception -> getMessage ( ) ) -> setFrom ( $ this -> from ) -> setTo ( $ this -> to ) -> setContentType ( 'text/html' ) -> setBody ( $ this -> templating -> render ( "SoclozMonitoringBundle:Notify:exception.html.twig" , array ( 'request' => $ request , 'exception' => $ exception , 'exception_class' => \ get_class ( $ exception ) , 'request_headers' => $ request -> server -> getHeaders ( ) , 'request_attributes' => $ this -> mailerTransformer -> transform ( $ request -> attributes -> all ( ) ) , 'server_params' => $ this -> mailerTransformer -> transform ( $ serverParams ) , ) ) ) ; try { $ this -> getMailer ( ) -> send ( $ message ) ; } catch ( \ Exception $ e ) { $ this -> logger -> error ( 'Sending mail error - ' . $ e -> getMessage ( ) ) ; } }
354	private static function tokenizePattern ( $ pattern ) { $ charset = Yii :: $ app ? Yii :: $ app -> charset : 'UTF-8' ; $ depth = 1 ; if ( ( $ start = $ pos = mb_strpos ( $ pattern , '{' , 0 , $ charset ) ) === false ) { return [ $ pattern ] ; } $ tokens = [ mb_substr ( $ pattern , 0 , $ pos , $ charset ) ] ; while ( true ) { $ open = mb_strpos ( $ pattern , '{' , $ pos + 1 , $ charset ) ; $ close = mb_strpos ( $ pattern , '}' , $ pos + 1 , $ charset ) ; if ( $ open === false && $ close === false ) { break ; } if ( $ open === false ) { $ open = mb_strlen ( $ pattern , $ charset ) ; } if ( $ close > $ open ) { $ depth ++ ; $ pos = $ open ; } else { $ depth -- ; $ pos = $ close ; } if ( $ depth === 0 ) { $ tokens [ ] = explode ( ',' , mb_substr ( $ pattern , $ start + 1 , $ pos - $ start - 1 , $ charset ) , 3 ) ; $ start = $ pos + 1 ; $ tokens [ ] = mb_substr ( $ pattern , $ start , $ open - $ start , $ charset ) ; $ start = $ open ; } if ( $ depth !== 0 && ( $ open === false || $ close === false ) ) { break ; } } if ( $ depth !== 0 ) { return false ; } return $ tokens ; }
12447	static function run_build_dependencies ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { $ opts = self :: getOpts ( @ $ args [ 0 ] , @ $ args [ 1 ] , $ cliopts ) ; $ current = $ opts [ 'extension' ] [ 'name' ] ; foreach ( $ opts [ 'dependencies' ] [ 'extensions' ] as $ ext => $ source ) { if ( $ ext != $ current ) { foreach ( $ source as $ type => $ def ) { break ; } $ tempconf = array ( 'extension' => array ( 'name' => $ ext ) , 'version' => array ( 'major' => 0 , 'minor' => 0 , 'release' => 0 ) , $ type => $ def ) ; $ tempconffile = self :: getOptionsDir ( ) . "/options-tmp_$ext.yaml" ; pakeYaml :: emitfile ( $ tempconf , $ tempconffile ) ; $ task = pakeTask :: get ( 'init' ) ; $ task -> execute ( array ( "tmp_$ext" ) , array_merge ( $ cliopts , array ( 'skip-init' => false , 'skip-init-fetch' => false , 'skip-init-clean' => true ) ) ) ; if ( is_file ( self :: getBuildDir ( $ opts ) . "/$ext/pake/options-$ext.yaml" ) ) { pake_copy ( self :: getBuildDir ( $ opts ) . "/$ext/pake/options-$ext.yaml" , self :: getOptionsDir ( ) . "/options-$ext.yaml" ) ; } else { throw new pakeException ( "Missing pake/options.yaml extension in dependent extension $ext" ) ; } $ task -> execute ( array ( "tmp_$ext" ) , array_merge ( $ cliopts , array ( 'skip-init' => false , 'skip-init-fetch' => true , 'skip-init-clean' => false ) ) ) ; pake_remove ( $ tempconffile , '' ) ; $ task = pakeTask :: get ( 'build' ) ; foreach ( $ task -> get_prerequisites ( ) as $ pretask ) { $ pretask = pakeTask :: get ( $ pretask ) ; $ pretask -> execute ( array ( $ ext ) , array_merge ( $ opts , array ( 'skip-init' => true ) ) ) ; } $ task -> execute ( array ( $ ext ) , array_merge ( $ opts , array ( 'skip-init' => true ) ) ) ; } } }
6202	public function methodFail ( $ errors = null ) { if ( $ errors === null ) { return $ this -> methodResult ( false ) ; } if ( ! is_array ( $ errors ) ) { $ errors = [ $ errors ] ; } return $ this -> methodResult ( false , [ 'errors' => $ errors ] ) ; }
1815	public function tableImportWizard ( ) { return ' <a href="' . $ this -> addToUrl ( 'key=table' ) . '" title="' . Contao \ StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'tw_import' ] [ 1 ] ) . '" onclick="Backend.getScrollOffset()">' . Contao \ Image :: getHtml ( 'tablewizard.svg' , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'tw_import' ] [ 0 ] ) . '</a> ' . Contao \ Image :: getHtml ( 'demagnify.svg' , '' , 'title="' . Contao \ StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'tw_shrink' ] ) . '" style="cursor:pointer" onclick="Backend.tableWizardResize(0.9)"' ) . Contao \ Image :: getHtml ( 'magnify.svg' , '' , 'title="' . Contao \ StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'tw_expand' ] ) . '" style="cursor:pointer" onclick="Backend.tableWizardResize(1.1)"' ) ; }
3729	protected function getAttributeImplementing ( $ interface ) { $ result = array ( ) ; foreach ( $ this -> getAttributes ( ) as $ colName => $ attribute ) { if ( $ attribute instanceof $ interface ) { $ result [ $ colName ] = $ attribute ; } } return $ result ; }
10956	protected function dealWithParam ( $ clause , array $ values ) { array_shift ( $ values ) ; array_shift ( $ values ) ; $ pat = $ rep = [ ] ; foreach ( $ values as $ val ) { $ pat [ ] = '/\?/' ; $ rep [ ] = $ this -> getBuilder ( ) -> generatePlaceholder ( $ val ) ; } return preg_replace ( $ pat , $ rep , $ clause , 1 ) ; }
5757	private function selectArray ( ? string $ selectColumns = null , array $ whereColumnsInfo = null , string $ orderBy = null ) : array { $ columns = $ selectColumns ?? $ this -> defaultSelectColumnsString ; $ permissionsArray = [ ] ; if ( null !== $ records = $ this -> select ( $ columns , $ whereColumnsInfo , $ orderBy ) ) { $ rolesTableMapper = RolesTableMapper :: getInstance ( ) ; foreach ( $ records as $ record ) { if ( null === $ key = $ this -> getPermissionsArrayKeyForId ( $ permissionsArray , ( int ) $ record [ 'id' ] ) ) { $ permissionsArray [ ] = [ 'id' => ( int ) $ record [ 'id' ] , 'title' => $ record [ 'title' ] , 'description' => $ record [ 'description' ] , 'roles' => [ $ rolesTableMapper -> getObjectById ( ( int ) $ record [ 'role_id' ] ) ] , 'active' => Postgres :: convertPostgresBoolToBool ( $ record [ 'active' ] ) , 'created' => new \ DateTimeImmutable ( $ record [ 'created' ] ) , ] ; } else { array_push ( $ permissionsArray [ $ key ] [ 'roles' ] , $ rolesTableMapper -> getObjectById ( ( int ) $ record [ 'role_id' ] ) ) ; } } } return $ permissionsArray ; }
3385	private function getRole ( $ identity = null ) { if ( is_object ( $ identity ) ) { return $ identity -> getRole ( ) ; } if ( is_array ( $ identity ) && isset ( $ identity [ 'role' ] ) ) { return $ identity [ 'role' ] ; } return 'guest' ; }
3717	public static function withName ( $ columnName , $ tableName , $ code = 0 , $ previous = null ) { return new static ( sprintf ( 'Column "%s" already exists on table "%s' , $ columnName , $ tableName ) , $ code , $ previous ) ; }
9481	public function respondWithResult ( $ data = NULL ) { $ res [ 'status' ] = $ this -> getStatusText ( ) ; if ( $ this -> getErrorCode ( ) && $ this -> getStatusCode ( ) == 420 ) { $ res [ 'error' ] = $ this -> getErrorCode ( ) ; $ res [ 'message' ] = $ data ; } else { $ res [ 'result' ] = $ data ; } return $ this -> respond ( $ res ) ; }
12764	public function add ( string $ header ) : self { foreach ( $ this -> getAll ( ) as $ tmp ) { if ( $ tmp === $ header ) { throw new Exception ( "The '{$header}' header has already been added." ) ; } } $ this -> headerList [ ] = $ header ; return self :: $ instance ; }
2200	public static function findPublishedByPidAndColumn ( $ intPid , $ strColumn , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = array ( "$t.pid=? AND $t.inColumn=?" ) ; $ arrValues = array ( $ intPid , $ strColumn ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.sorting" ; } return static :: findBy ( $ arrColumns , $ arrValues , $ arrOptions ) ; }
3863	private function getCaptionText ( $ langKey ) { $ tableName = $ this -> getMetaModel ( ) -> getTableName ( ) ; if ( isset ( $ this -> objView ) && isset ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ tableName ] [ $ this -> objView -> get ( 'id' ) ] [ $ langKey ] ) ) { return $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ tableName ] [ $ this -> objView -> get ( 'id' ) ] [ $ langKey ] ; } elseif ( isset ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ tableName ] [ $ langKey ] ) ) { return $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ tableName ] [ $ langKey ] ; } return $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ langKey ] ; }
7464	public function newAction ( Request $ request , $ hash ) { $ passwordHelper = $ this -> get ( 'orkestra.application.helper.password' ) ; $ hashedEntityHelper = $ this -> get ( 'orkestra.application.helper.hashed_entity' ) ; $ hashedEntity = $ passwordHelper -> lookup ( $ hash ) ; if ( ! $ hashedEntity ) { throw new EntityNotFoundException ( ) ; } $ user = $ hashedEntity -> getReferencedObject ( ) ; $ hashedEntityHelper -> invalidate ( $ hashedEntity ) ; $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ em -> persist ( $ hashedEntity ) ; $ em -> flush ( ) ; if ( $ user ) { $ request -> getSession ( ) -> set ( PasswordSetController :: CURRENT_USER_ID_KEY , $ user -> getId ( ) ) ; $ form = $ this -> getSetPasswordForm ( ) ; return array ( 'form' => $ form -> createView ( ) ) ; } else { throw $ this -> createNotFoundException ( 'No user was found.' ) ; } }
6234	protected function applyAccessMode ( int $ mode ) : void { if ( $ this -> mode === self :: MODE_CLOSED ) { $ this -> mode = $ mode ; return ; } elseif ( $ mode === $ this -> mode ) { return ; } throw new AccessDeniedException ( 'unable to switch access-mode for existing binary file handle' , 500 ) ; }
9249	public function generate ( $ name , array $ parameters = array ( ) , $ absolute = false ) { if ( ! $ this -> initialized ) { $ this -> initialize ( ) ; } $ path = $ this -> routes [ $ name ] ; if ( is_array ( $ path ) ) { $ params = $ path [ 'params' ] ; $ path = $ path [ 'path' ] ; foreach ( $ params as $ param ) { if ( ! isset ( $ parameters [ $ param ] ) ) { throw new \ RuntimeException ( 'Missing required parameter "' . $ param . '". Optional parameters not currently supported' ) ; } $ path = str_replace ( '{' . $ param . '}' , $ parameters [ $ param ] , $ path ) ; } } if ( $ this -> request ) { $ path = $ this -> request -> getBaseUrl ( ) . $ path ; if ( $ absolute ) { $ path = $ this -> request -> getSchemeAndHttpHost ( ) . $ path ; } } return $ path ; }
2145	public function replace ( $ strBuffer , $ blnCache = true ) { $ strBuffer = $ this -> doReplace ( $ strBuffer , $ blnCache ) ; while ( strpos ( $ strBuffer , '{{' ) !== false && ( $ strTmp = $ this -> doReplace ( $ strBuffer , $ blnCache ) ) != $ strBuffer ) { $ strBuffer = $ strTmp ; } return $ strBuffer ; }
311	private function applyTableAlias ( $ query , $ conditions , $ alias = null ) { if ( $ alias === null ) { $ alias = array_keys ( $ query -> getTablesUsedInFrom ( ) ) [ 0 ] ; } $ prefixedConditions = [ ] ; foreach ( $ conditions as $ columnName => $ columnValue ) { if ( strpos ( $ columnName , '(' ) === false ) { $ columnName = preg_replace ( '/^' . preg_quote ( $ alias ) . '\.(.*)$/' , '$1' , $ columnName ) ; if ( strpos ( $ columnName , '[[' ) === 0 ) { $ prefixedColumn = "{$alias}.{$columnName}" ; } else { $ prefixedColumn = "{$alias}.[[{$columnName}]]" ; } } else { $ prefixedColumn = $ columnName ; } $ prefixedConditions [ $ prefixedColumn ] = $ columnValue ; } return $ prefixedConditions ; }
11925	public function generate ( string $ outputDir ) : array { $ generatedFiles = [ ] ; foreach ( $ this -> generators as $ generator ) { $ this -> logger -> info ( 'Running generator ' . get_class ( $ generator ) ) ; $ result = $ generator -> generate ( ) ; foreach ( $ result -> all ( ) as $ phpFile ) { $ path = str_replace ( [ '/' , "\\" ] , DIRECTORY_SEPARATOR , $ outputDir . '/' . $ phpFile -> getFqcn ( ) -> getNamespace ( ) ) ; BaseUtil :: ensureDirectory ( $ path , 0711 ) ; $ filePath = $ path . DIRECTORY_SEPARATOR . $ phpFile -> getFqcn ( ) -> getName ( ) . '.php' ; $ this -> logger -> info ( 'Writing to file ' . $ filePath ) ; file_put_contents ( $ filePath , $ phpFile -> getText ( ) ) ; $ generatedFiles [ ] = new GeneratedFile ( $ filePath , $ phpFile ) ; } } return $ generatedFiles ; }
12177	public function addArgument ( ArgumentInterface $ argument ) { $ this -> argumentPositions [ $ argument -> getPosition ( ) ] = $ argument ; $ this -> argumentNames [ $ argument -> getName ( ) ] = $ argument ; if ( $ argument -> isClass ( ) ) { $ this -> argumentClasses [ $ argument -> getClass ( ) ] = $ argument ; } return $ argument ; }
4245	private function logPhpInfo ( ) { if ( ! $ this -> debug -> getCfg ( 'logEnvInfo.phpInfo' ) ) { return ; } $ this -> debug -> log ( 'PHP Version' , PHP_VERSION ) ; $ this -> debug -> log ( 'ini location' , \ php_ini_loaded_file ( ) ) ; $ this -> debug -> log ( 'memory_limit' , $ this -> debug -> utilities -> getBytes ( $ this -> debug -> utilities -> memoryLimit ( ) ) ) ; $ this -> debug -> log ( 'session.cache_limiter' , \ ini_get ( 'session.cache_limiter' ) ) ; if ( \ session_module_name ( ) === 'files' ) { $ this -> debug -> log ( 'session_save_path' , \ session_save_path ( ) ? : \ sys_get_temp_dir ( ) ) ; } $ extensionsCheck = array ( 'curl' , 'mbstring' ) ; $ extensionsCheck = \ array_filter ( $ extensionsCheck , function ( $ extension ) { return ! \ extension_loaded ( $ extension ) ; } ) ; if ( $ extensionsCheck ) { $ this -> debug -> warn ( 'These common extensions are not loaded:' , $ extensionsCheck ) ; } $ this -> logPhpInfoEr ( ) ; }
452	public function update ( $ table , $ columns , $ condition , & $ params ) { list ( $ lines , $ params ) = $ this -> prepareUpdateSets ( $ table , $ columns , $ params ) ; $ sql = 'UPDATE ' . $ this -> db -> quoteTableName ( $ table ) . ' SET ' . implode ( ', ' , $ lines ) ; $ where = $ this -> buildWhere ( $ condition , $ params ) ; return $ where === '' ? $ sql : $ sql . ' ' . $ where ; }
2148	public function removeSubscriptions ( $ intUser , $ strMode ) { if ( ! $ intUser ) { return ; } if ( $ strMode == 'close_delete' ) { $ this -> Database -> prepare ( "DELETE FROM tl_newsletter_recipients WHERE email=(SELECT email FROM tl_member WHERE id=?)" ) -> execute ( $ intUser ) ; } else { $ this -> Database -> prepare ( "UPDATE tl_newsletter_recipients SET active='' WHERE email=(SELECT email FROM tl_member WHERE id=?)" ) -> execute ( $ intUser ) ; } }
7226	public function info ( $ name = null ) { if ( $ name ) { return $ this -> info ? $ this -> info [ $ name ] : curl_getinfo ( $ this -> curl , "CURLINFO" . strtoupper ( $ name ) ) ; } else { return $ this -> info ? : curl_getinfo ( $ this -> curl ) ; } }
900	public function isArrayMultiLine ( $ index ) { if ( ! $ this -> isArray ( $ index ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Not an array at given index %d.' , $ index ) ) ; } $ tokens = $ this -> tokens ; if ( $ tokens [ $ index ] -> isGivenKind ( T_ARRAY ) ) { $ index = $ tokens -> getNextMeaningfulToken ( $ index ) ; } $ endIndex = $ tokens [ $ index ] -> equals ( '(' ) ? $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ index ) : $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_ARRAY_SQUARE_BRACE , $ index ) ; for ( ++ $ index ; $ index < $ endIndex ; ++ $ index ) { $ token = $ tokens [ $ index ] ; $ blockType = Tokens :: detectBlockType ( $ token ) ; if ( $ blockType && $ blockType [ 'isStart' ] ) { $ index = $ tokens -> findBlockEnd ( $ blockType [ 'type' ] , $ index ) ; continue ; } if ( $ token -> isWhitespace ( ) && ! $ tokens [ $ index - 1 ] -> isGivenKind ( T_END_HEREDOC ) && false !== strpos ( $ token -> getContent ( ) , "\n" ) ) { return true ; } } return false ; }
8259	protected function getResourceAttribute ( $ name , $ resourceOwner ) { $ method = "get" . $ name ; if ( is_callable ( array ( $ resourceOwner , $ method ) ) ) { $ res = $ resourceOwner -> $ method ( ) ; return $ res ; } else { $ resourceArray = $ resourceOwner -> toArray ( ) ; $ res = $ this -> getValueByKey ( $ resourceArray , $ name ) ; return $ res ; } }
4054	private function fetchGroupSort ( $ inputScreenId , IMetaModel $ metaModel ) : array { $ builder = $ this -> connection -> createQueryBuilder ( ) ; return array_map ( function ( $ information ) use ( $ inputScreenId , $ metaModel ) { $ information [ 'isdefault' ] = ( bool ) $ information [ 'isdefault' ] ; $ information [ 'ismanualsort' ] = ( bool ) $ information [ 'ismanualsort' ] ; $ information [ 'rendergrouplen' ] = ( int ) $ information [ 'rendergrouplen' ] ; if ( $ information [ 'ismanualsort' ] ) { $ information [ 'rendergrouptype' ] = 'none' ; } if ( ! empty ( $ information [ 'rendersortattr' ] ) ) { if ( ! ( $ attribute = $ metaModel -> getAttributeById ( $ information [ 'rendersortattr' ] ) ) ) { @ trigger_error ( sprintf ( 'Unknown attribute "%1$s" in group sorting "%2$s.%3$s"' , $ information [ 'rendersortattr' ] , $ inputScreenId , $ information [ 'id' ] ) , E_USER_WARNING ) ; return $ information ; } $ information [ 'col_name' ] = $ attribute -> getColName ( ) ; } return $ information ; } , $ builder -> select ( '*' ) -> from ( 'tl_metamodel_dca_sortgroup' ) -> where ( 'pid=:screenId' ) -> setParameter ( 'screenId' , $ inputScreenId ) -> orderBy ( 'sorting' ) -> execute ( ) -> fetchAll ( \ PDO :: FETCH_ASSOC ) ) ; }
1369	protected function bindInboundRequest ( ) { $ this -> app -> singleton ( JsonApiRequest :: class ) ; $ this -> app -> alias ( JsonApiRequest :: class , 'json-api.request' ) ; $ this -> app -> singleton ( Route :: class , function ( Application $ app ) { return new Route ( $ app -> make ( ResolverInterface :: class ) , $ app -> make ( 'router' ) -> current ( ) ) ; } ) ; $ this -> app -> bind ( StoreInterface :: class , function ( ) { return json_api ( ) -> getStore ( ) ; } ) ; $ this -> app -> bind ( ResolverInterface :: class , function ( ) { return json_api ( ) -> getResolver ( ) ; } ) ; $ this -> app -> bind ( ErrorRepositoryInterface :: class , function ( ) { return json_api ( ) -> getErrors ( ) ; } ) ; $ this -> app -> bind ( ContainerInterface :: class , function ( ) { return json_api ( ) -> getContainer ( ) ; } ) ; $ this -> app -> singleton ( HeaderParametersInterface :: class , function ( Application $ app ) { $ parser = $ app -> make ( HttpFactoryInterface :: class ) -> createHeaderParametersParser ( ) ; $ serverRequest = $ app -> make ( ServerRequestInterface :: class ) ; return $ parser -> parse ( $ serverRequest , http_contains_body ( $ serverRequest ) ) ; } ) ; $ this -> app -> singleton ( EncodingParametersInterface :: class , function ( Application $ app ) { $ parser = $ app -> make ( HttpFactoryInterface :: class ) -> createQueryParametersParser ( ) ; return $ parser -> parseQueryParameters ( request ( ) -> query ( ) ) ; } ) ; }
10664	public function withRequest ( RequestInterface $ request ) { $ object = clone $ this ; $ object -> request = $ request ; $ object -> method = $ request -> getMethod ( ) ; return $ object ; }
8088	public function generateUserPassword ( User $ user , $ password , $ generateOld = false ) { $ registrationDate = $ user -> RegDate ; $ pre = $ this -> encode ( $ registrationDate ) ; $ pos = substr ( $ registrationDate , 5 , 1 ) ; $ post = $ this -> encode ( $ registrationDate * ( substr ( $ registrationDate , $ pos , 1 ) ) ) ; $ finalString = $ pre . $ password . $ post ; return $ generateOld ? md5 ( $ finalString ) : sha1 ( $ finalString ) ; }
5246	public function get ( string $ path ) : string { if ( ! $ this -> isFile ( $ path ) ) { throw new RuntimeException ( 'File does not exist at path ' . $ path ) ; } return file_get_contents ( $ path ) ; }
7039	public function getShippedAt ( $ latest = false ) { if ( 0 == $ this -> shipments -> count ( ) ) { return null ; } $ criteria = Criteria :: create ( ) ; $ criteria -> andWhere ( Criteria :: expr ( ) -> eq ( 'return' , false ) ) -> andWhere ( Criteria :: expr ( ) -> in ( 'state' , [ ShipmentStates :: STATE_READY , ShipmentStates :: STATE_SHIPPED ] ) ) -> orderBy ( [ 'createdAt' => $ latest ? Criteria :: DESC : Criteria :: ASC ] ) ; $ shipments = $ this -> shipments ; $ shipments = $ shipments -> matching ( $ criteria ) ; if ( false !== $ shipment = $ shipments -> first ( ) ) { return $ shipment -> getCreatedAt ( ) ; } return null ; }
358	function compareByteSize ( $ a , $ b , $ compare = '>=' ) { $ compareExpression = '(' . $ this -> getByteSize ( $ a ) . $ compare . $ this -> getByteSize ( $ b ) . ')' ; return $ this -> evaluateExpression ( $ compareExpression ) ; }
4616	protected function validate ( ) { if ( ! $ this -> config -> getHost ( ) || ! $ this -> config -> getPort ( ) ) { throw new Node \ Builder \ Exception ( 'Node host address and port number are required.' ) ; } if ( $ this -> config -> getUser ( ) && $ this -> config -> getCertificate ( ) ) { throw new Node \ Builder \ Exception ( 'Connect with password OR certificate authentication, not both.' ) ; } if ( $ this -> config -> isAuth ( ) && ! $ this -> config -> getCaDirectory ( ) && ! $ this -> config -> getCaFile ( ) ) { throw new Node \ Builder \ Exception ( 'Certificate authority file is required for authentication.' ) ; } }
738	protected function saveItems ( ) { $ items = [ ] ; foreach ( $ this -> items as $ name => $ item ) { $ items [ $ name ] = array_filter ( [ 'type' => $ item -> type , 'description' => $ item -> description , 'ruleName' => $ item -> ruleName , 'data' => $ item -> data , ] ) ; if ( isset ( $ this -> children [ $ name ] ) ) { foreach ( $ this -> children [ $ name ] as $ child ) { $ items [ $ name ] [ 'children' ] [ ] = $ child -> name ; } } } $ this -> saveToFile ( $ items , $ this -> itemFile ) ; }
3604	public function handleJsonRequest ( $ jsonRequest ) { if ( \ is_array ( $ jsonRequest ) ) { $ jsonResponse = [ ] ; foreach ( $ jsonRequest as $ request ) { $ jsonResponse [ ] = $ this -> handleJsonRequest ( $ request ) ; } return $ jsonResponse ; } if ( $ this -> stopwatch ) { $ this -> stopwatch -> start ( 'rpc.execute' ) ; } try { $ this -> dispatch ( Event \ JsonRequestEvent :: EVENT , new Event \ JsonRequestEvent ( $ jsonRequest ) ) ; $ metadata = $ this -> getMethod ( $ jsonRequest ) ; $ isCache = $ this -> isCacheSupport ( $ jsonRequest ) ; $ cacheId = $ jsonRequest -> getHash ( ) ; $ jsonResponse = new JsonResponse ( $ jsonRequest ) ; if ( true === $ isCache && true === $ this -> getCache ( ) -> contains ( $ cacheId ) ) { $ jsonResponse -> setResult ( $ this -> getCache ( ) -> fetch ( $ cacheId ) ) ; $ isCache = false ; } $ result = $ jsonResponse -> getResult ( ) ; if ( null === $ result ) { $ result = $ this -> executeJsonRequest ( $ metadata , $ jsonRequest ) ; } if ( $ result instanceof JsonResponse ) { $ jsonResponse = $ result ; $ jsonResponse -> setRequest ( $ jsonRequest ) ; } else { $ jsonResponse -> setResult ( $ this -> serialize ( $ result ) ) ; } $ isCache && $ this -> cache -> save ( $ cacheId , $ jsonResponse -> getResult ( ) , $ metadata -> getCache ( ) ) ; $ this -> dispatch ( Event \ JsonResponseEvent :: EVENT , new Event \ JsonResponseEvent ( $ jsonResponse ) ) ; } catch ( \ Exception $ exception ) { $ jsonResponse = $ this -> createJsonResponseFromException ( $ exception , $ jsonRequest ) ; } if ( $ this -> stopwatch ) { $ this -> stopwatch -> stop ( 'rpc.execute' ) ; } return $ jsonResponse ; }
12722	protected function turnIntoResolvableClosure ( $ abstract , $ concrete ) { return function ( Container $ container , $ parameters = [ ] ) use ( $ abstract , $ concrete ) { return ( $ abstract == $ concrete ? $ container -> resolve ( $ abstract ) : $ container -> resolve ( $ concrete , $ parameters ) ) ; } ; }
8364	public static function setCurrentLanguage ( $ language ) { self :: $ currentLanguage = $ language ; Session :: set ( '_stray_language' , self :: $ currentLanguage ) ; setlocale ( LC_ALL , $ language ) ; }
4253	public function processLogEntry ( $ method , $ args = array ( ) , $ meta = array ( ) ) { if ( $ method == 'alert' ) { list ( $ method , $ args ) = $ this -> methodAlert ( $ args , $ meta ) ; } elseif ( $ method == 'assert' ) { \ array_unshift ( $ args , false ) ; } elseif ( \ in_array ( $ method , array ( 'count' , 'time' ) ) ) { $ method = 'log' ; } elseif ( \ in_array ( $ method , array ( 'profileEnd' , 'table' ) ) ) { $ method = 'log' ; if ( \ is_array ( $ args [ 0 ] ) ) { $ method = 'table' ; $ args = array ( $ this -> methodTable ( $ args [ 0 ] , $ meta [ 'columns' ] ) ) ; } elseif ( $ meta [ 'caption' ] ) { \ array_unshift ( $ args , $ meta [ 'caption' ] ) ; } } elseif ( $ method == 'trace' ) { $ method = 'table' ; $ args = array ( $ this -> methodTable ( $ args [ 0 ] , array ( 'function' , 'file' , 'line' ) ) ) ; } elseif ( \ in_array ( $ method , array ( 'error' , 'warn' ) ) ) { if ( isset ( $ meta [ 'file' ] ) ) { $ args [ ] = $ meta [ 'file' ] . ': line ' . $ meta [ 'line' ] ; } } if ( ! \ in_array ( $ method , $ this -> consoleMethods ) ) { $ method = 'log' ; } foreach ( $ args as $ k => $ arg ) { $ args [ $ k ] = \ json_encode ( $ this -> dump ( $ arg ) ) ; } $ str = 'console.' . $ method . '(' . \ implode ( ',' , $ args ) . ');' . "\n" ; $ str = \ str_replace ( \ json_encode ( $ this -> debug -> abstracter -> UNDEFINED ) , 'undefined' , $ str ) ; return $ str ; }
10832	public function actionIndex ( ) { $ searchModel = new SearchState ( Yii :: $ app -> request -> get ( ) ) ; $ dataProvider = $ searchModel -> search ( Yii :: $ app -> request -> queryParams ) ; return $ this -> render ( 'index' , [ 'searchModel' => $ searchModel , 'dataProvider' => $ dataProvider ] ) ; }
7590	public function renderTemplate ( CollectionElement $ collection ) { if ( false != ( $ sElementLayout = $ collection -> getOption ( 'twb-layout' ) ) ) { $ elementOrFieldset = $ collection -> getTemplateElement ( ) ; $ elementOrFieldset -> setOption ( 'twb-layout' , $ sElementLayout ) ; } return parent :: renderTemplate ( $ collection ) ; }
6455	public function textual ( ) { $ this -> restrictElements ( [ 'textarea' => [ ] , 'input' => [ ] , ] ) ; self :: debug ( [ 'Expected: %s' , 'Value: %s' , 'Tag: %s' , ] , [ $ this -> expected , $ this -> value , $ this -> tag , ] ) ; $ this -> assert ( trim ( $ this -> expected ) === $ this -> value ) ; }
6401	public function getResource ( $ resource ) : ? string { Preconditions :: checkState ( $ this -> isPsr0Compatible ( ) , "Class '%s' must be PSR-0 compatible!" , $ this -> getName ( ) ) ; $ slashedFileName = $ this -> getSlashedFileName ( ) ; $ filePath = $ resource [ 0 ] == '/' ? str_replace ( "/{$this->getSlashedName()}.php" , '' , $ slashedFileName ) . $ resource : dirname ( $ slashedFileName ) . '/' . $ resource ; return is_file ( $ filePath ) ? $ filePath : null ; }
2894	public function init ( Zend_Db_Profiler_Query $ profilerQuery , $ stacktrace = '' ) { $ this -> queryType = $ profilerQuery -> getQueryType ( ) ; $ this -> query = $ profilerQuery -> getQuery ( ) ; $ this -> queryParams = $ profilerQuery -> getQueryParams ( ) ; $ this -> elapsedSecs = $ profilerQuery -> getElapsedSecs ( ) ; $ this -> stacktrace = $ stacktrace ; }
7190	private function copyAttachment ( Model \ SaleAttachmentInterface $ source , Model \ SaleAttachmentInterface $ target ) { $ this -> copy ( $ source , $ target , [ 'path' , 'title' , 'type' , 'size' , 'internal' , 'createdAt' , 'updatedAt' , ] ) ; }
12422	public function getAll ( $ domain ) { $ messages = [ ] ; $ locale = $ this -> getLocale ( ) ; foreach ( $ this -> getTranslations ( $ domain ) as $ object ) { $ messages = $ messages + ( array ) $ object -> getMessages ( $ domain , $ locale ) ; } return $ messages ; }
9718	private function writePalette ( ) { $ aref = $ this -> palette ; $ record = 0x0092 ; $ length = 2 + 4 * count ( $ aref ) ; $ ccv = count ( $ aref ) ; $ data = '' ; foreach ( $ aref as $ color ) { foreach ( $ color as $ byte ) { $ data .= pack ( 'C' , $ byte ) ; } } $ header = pack ( 'vvv' , $ record , $ length , $ ccv ) ; $ this -> append ( $ header . $ data ) ; }
12147	public function hasException ( \ Exception $ exception ) { $ class = get_class ( $ exception ) ; $ exceptions = $ this -> getExceptions ( ) ; return isset ( $ exceptions [ $ class ] ) ; }
7474	public function updateAction ( Request $ request , $ id ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ user = $ em -> getRepository ( 'Orkestra\Bundle\ApplicationBundle\Entity\User' ) -> find ( $ id ) ; if ( ! $ user ) { throw $ this -> createNotFoundException ( 'Unable to locate User' ) ; } $ form = $ this -> createForm ( UserType :: class , $ user , array ( 'include_password' => false ) ) ; $ form -> bind ( $ request ) ; if ( $ form -> isValid ( ) ) { $ em -> persist ( $ user ) ; $ em -> flush ( ) ; $ this -> get ( 'session' ) -> getFlashBag ( ) -> set ( 'success' , 'Your changes have been saved.' ) ; return $ this -> redirect ( $ this -> generateUrl ( 'orkestra_user_show' , array ( 'id' => $ id ) ) ) ; } return array ( 'user' => $ user , 'form' => $ form -> createView ( ) , ) ; }
3446	private function getAccessorForLanguageField ( $ field ) { $ method = 'getValueFromLanguageField' ; return in_array ( $ field , $ this -> languageAccessors ) && method_exists ( $ this , $ method ) ? $ method : false ; }
3367	protected function prepareEvent ( EventInterface $ event ) { foreach ( [ 'elementSpec' , 'inputSpec' ] as $ type ) { if ( ! $ event -> getParam ( $ type ) ) { $ event -> setParam ( $ type , new ArrayObject ( ) ) ; } } $ elementSpec = $ event -> getParam ( 'elementSpec' ) ; $ inputSpec = $ event -> getParam ( 'inputSpec' ) ; if ( ! isset ( $ elementSpec [ 'spec' ] ) ) { $ elementSpec [ 'spec' ] = [ ] ; } if ( ! isset ( $ inputSpec [ 'filters' ] ) ) { $ inputSpec [ 'filters' ] = [ ] ; } if ( ! isset ( $ inputSpec [ 'validators' ] ) ) { $ inputSpec [ 'validators' ] = [ ] ; } }
6336	public function overlay ( $ title , $ message , $ level = 'info' , $ key = 'flash_message' ) { return $ this -> create ( $ title , $ message , $ level , $ key . '_overlay' ) ; }
4944	public function grant ( $ resource , $ permission = null , $ build = true ) { if ( is_array ( $ resource ) ) { foreach ( $ resource as $ r ) { $ this -> grant ( $ r , $ permission , false ) ; } if ( $ build ) { $ this -> build ( ) ; } return $ this ; } true === $ permission || ( null === $ permission && $ resource instanceof PermissionsResourceInterface ) || $ this -> checkPermission ( $ permission ) ; $ resourceId = $ this -> getResourceId ( $ resource ) ; if ( true === $ permission ) { $ permission = $ this -> getFrom ( $ resource ) ; } if ( self :: PERMISSION_NONE == $ permission ) { if ( $ resource instanceof PermissionsResourceInterface ) { $ refs = $ this -> getResources ( ) ; if ( $ refs -> contains ( $ resource ) ) { $ refs -> removeElement ( $ resource ) ; } } unset ( $ this -> assigned [ $ resourceId ] ) ; } else { if ( $ resource instanceof PermissionsResourceInterface ) { $ spec = $ resource -> getPermissionsUserIds ( $ this -> type ) ; if ( ! is_array ( $ spec ) || ! count ( $ spec ) ) { $ spec = array ( ) ; } elseif ( is_numeric ( key ( $ spec ) ) ) { $ spec = array ( $ permission => $ spec ) ; } } else { $ spec = array ( $ permission => $ resource instanceof UserInterface ? array ( $ resource -> getId ( ) ) : array ( $ resource ) ) ; } $ this -> assigned [ $ resourceId ] = $ spec ; if ( $ resource instanceof PermissionsResourceInterface ) { try { $ refs = $ this -> getResources ( ) ; if ( ! $ refs -> contains ( $ resource ) ) { $ refs -> add ( $ resource ) ; } } catch ( \ Exception $ e ) { } ; } } if ( $ build ) { $ this -> build ( ) ; } $ this -> hasChanged = true ; return $ this ; }
9135	public static function parseUrl ( $ url ) : Url { $ parts = parse_url ( $ url ) ; if ( false === $ parts || false === Arrays :: hasElement ( $ parts , 'host' ) || false === Arrays :: hasElement ( $ parts , 'scheme' ) ) { throw new InvalidUrlException ( 'The URL {url} does not contain necessary parts' , array ( 'url' => $ url ) ) ; } $ address = $ parts [ 'host' ] ; $ scheme = $ parts [ 'scheme' ] ; $ query = ( isset ( $ parts [ 'query' ] ) ? $ parts [ 'query' ] : '' ) ; $ port = 0 ; $ path = "/" ; if ( isset ( $ parts [ 'port' ] ) ) { $ port = intval ( $ parts [ 'port' ] ) ; } if ( $ port == 0 ) { $ port = self :: getPortByScheme ( $ scheme ) ; } if ( isset ( $ parts [ 'path' ] ) ) { $ path = $ parts [ 'path' ] ; } return new Url ( $ address , $ port , $ path , $ scheme , $ query ) ; }
3776	public function run ( ) { $ template = new BackendTemplate ( 'be_dcastylepicker' ) ; $ template -> main = '' ; $ template -> headline = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'metamodelspicker' ] ; $ inputName = Input :: get ( 'inputName' ) ; if ( ! preg_match ( '~^[a-z\-_0-9]+$~i' , $ inputName ) ) { throw new RuntimeException ( 'Field-Parameter ERROR!' ) ; } $ template -> field = $ inputName ; $ template -> items = $ GLOBALS [ Input :: get ( 'item' ) ] ; if ( ! strlen ( $ template -> headline ) ) { $ template -> headline = $ GLOBALS [ 'TL_CONFIG' ] [ 'websiteTitle' ] ; } $ template -> theme = Backend :: getTheme ( ) ; $ template -> base = Environment :: get ( 'base' ) ; $ template -> language = $ GLOBALS [ 'TL_LANGUAGE' ] ; $ template -> title = $ GLOBALS [ 'TL_CONFIG' ] [ 'websiteTitle' ] ; $ template -> charset = $ GLOBALS [ 'TL_CONFIG' ] [ 'characterSet' ] ; $ template -> pageOffset = Input :: cookie ( 'BE_PAGE_OFFSET' ) ; $ template -> error = ( Input :: get ( 'act' ) == 'error' ) ? $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'general' ] : '' ; $ template -> skipNavigation = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'skipNavigation' ] ; $ template -> request = ampersand ( Environment :: get ( 'request' ) ) ; $ template -> top = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'backToTop' ] ; $ template -> be27 = ! $ GLOBALS [ 'TL_CONFIG' ] [ 'oldBeTheme' ] ; $ template -> expandNode = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'expandNode' ] ; $ template -> collapseNode = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'collapseNode' ] ; $ template -> strField = Input :: get ( 'fld' ) ; $ template -> output ( ) ; }
2494	protected function escapeExpressions ( $ string , $ allowWildcard = false ) { if ( $ allowWildcard ) { $ reservedCharacters = preg_quote ( '+-&|!(){}[]^"~?:\\ ' ) ; } else { $ reservedCharacters = preg_quote ( '+-&|!(){}[]^"~*?:\\ ' ) ; } return preg_replace_callback ( '/([' . $ reservedCharacters . '])/' , function ( $ matches ) { return '\\' . $ matches [ 0 ] ; } , $ string ) ; }
2742	public function execute ( ) { $ result = $ this -> resultJsonFactory -> create ( ) ; try { $ serviceId = $ this -> config -> getServiceId ( ) ; $ apiKey = $ this -> config -> getApiKey ( ) ; if ( $ serviceId == null && $ apiKey == null ) { return $ result -> setData ( [ 'status' => true , 'flag' => false ] ) ; } return $ result -> setData ( [ 'status' => true , 'flag' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
3078	protected function hasChannel ( $ channelName , $ channelType ) { $ channels = $ this -> getOption ( self :: OPTION_CHANNELS ) ; return isset ( $ channels [ $ channelType ] [ $ channelName ] ) ; }
2248	public static function addToUrl ( $ strRequest , $ blnAddRef = true , $ arrUnset = array ( ) ) { $ query = new Query ( Environment :: get ( 'queryString' ) ) ; $ query = $ query -> withoutPairs ( array_merge ( array ( 'rt' , 'ref' ) , $ arrUnset ) ) ; $ query = $ query -> merge ( str_replace ( '&amp;' , '&' , $ strRequest ) ) ; if ( isset ( $ _GET [ 'ref' ] ) || ( $ strRequest != '' && $ blnAddRef ) ) { $ query = $ query -> merge ( 'ref=' . System :: getContainer ( ) -> get ( 'request_stack' ) -> getCurrentRequest ( ) -> attributes -> get ( '_contao_referer_id' ) ) ; } $ uri = $ query -> getUriComponent ( ) ; if ( strpos ( $ strRequest , '%2B' ) !== false ) { $ uri = str_replace ( '+' , '%2B' , $ uri ) ; } return TL_SCRIPT . ampersand ( $ uri ) ; }
5636	public function paintFail ( $ message ) { parent :: paintFail ( $ message ) ; print $ this -> getFailCount ( ) . ") $message\n" ; $ breadcrumb = $ this -> getTestList ( ) ; array_shift ( $ breadcrumb ) ; print "\tin " . implode ( "\n\tin " , array_reverse ( $ breadcrumb ) ) ; print "\n" ; }
4770	public function renderWidget ( string $ widgetGroup = '' , array $ widgetId = [ ] ) { $ widgets = $ this -> widgetBuilder -> build ( $ this -> widgets -> getWidgets ( ) , $ widgetGroup , $ widgetId ) ; return $ this -> engine -> render ( $ widgets ) ; }
7939	public function deleteBackupFTPaccessBlock ( $ domain , $ ipBlock ) { $ domain = ( string ) $ domain ; if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; if ( ! $ ipBlock ) throw new BadMethodCallException ( 'Parameter $ipBlock is missing.' ) ; try { $ r = $ this -> delete ( 'dedicated/server/' . $ domain . '/features/backupFTP/access/' . urlencode ( $ ipBlock ) ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new ServerException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
5159	private static function createGallery ( String $ body , int $ order , String $ photo , String $ source , string $ lead ) : \ One \ Model \ Gallery { return new Gallery ( $ body , $ order , $ photo , $ source , $ lead ) ; }
10653	protected function __propertyTraitHasProperty ( $ propertyName ) { if ( method_exists ( $ this , 'get' . $ propertyName ) || method_exists ( $ this , 'set' . $ propertyName ) ) { return true ; } try { $ classReflection = new \ ReflectionProperty ( get_class ( $ this ) , $ propertyName ) ; return $ classReflection -> isPublic ( ) ; } catch ( \ ReflectionException $ ex ) { return false ; } }
744	private function getFragmentCacheConfiguration ( ) { $ cache = $ this -> getCacheInstance ( ) ; $ fragmentCacheConfiguration = [ 'cache' => $ cache , 'duration' => $ this -> cacheDuration , 'dependency' => $ this -> cacheDependency , 'enabled' => $ this -> cacheEnabled , ] ; return $ fragmentCacheConfiguration ; }
4636	public function send ( $ email , array $ options = [ ] ) : ResultInterface { if ( is_string ( $ email ) ) { $ email = $ this -> emailBuilder -> build ( $ email , $ options ) ; } elseif ( is_array ( $ email ) ) { $ email = $ this -> emailBuilder -> build ( Email :: class , $ email ) ; } elseif ( ! $ email instanceof Email ) { throw Exception \ InvalidArgumentException :: fromValidTypes ( [ 'string' , 'array' , Email :: class ] , $ email , 'email' ) ; } $ this -> events -> triggerEvent ( $ this -> createMailEvent ( $ email , MailEvent :: EVENT_MAIL_PRE_RENDER ) ) ; $ this -> renderEmailBody ( $ email ) ; $ eventResp = $ this -> events -> triggerEvent ( $ this -> createMailEvent ( $ email , MailEvent :: EVENT_MAIL_PRE_SEND ) ) ; if ( $ eventResp -> contains ( false ) ) { return new MailResult ( $ email , false ) ; } try { $ message = MessageFactory :: createMessageFromEmail ( $ email ) -> setBody ( $ this -> buildBody ( $ email -> getBody ( ) , $ email -> getCharset ( ) ) ) ; $ this -> attachFiles ( $ message , $ email ) ; $ this -> addCustomHeaders ( $ message , $ email ) ; $ this -> transport -> send ( $ message ) ; $ result = new MailResult ( $ email ) ; $ this -> events -> triggerEvent ( $ this -> createMailEvent ( $ email , MailEvent :: EVENT_MAIL_POST_SEND , $ result ) ) ; return $ result ; } catch ( Throwable $ e ) { $ this -> events -> triggerEvent ( $ this -> createMailEvent ( $ email , MailEvent :: EVENT_MAIL_SEND_ERROR , new MailResult ( $ email , false , $ e ) ) ) ; throw new Exception \ MailException ( 'An error occurred while trying to send the email' , $ e -> getCode ( ) , $ e ) ; } }
12951	public function afterDelete ( ) { if ( ! empty ( $ this -> _tagsForDelete ) ) { $ relation = $ this -> owner -> getRelation ( 'tagsList' , false ) ; if ( $ relation instanceof ActiveQuery ) { $ class = $ relation -> modelClass ; $ class :: updateAllCounters ( [ 'count' => - 1 ] , [ 'in' , $ class :: primaryKey ( ) , $ this -> _tagsForDelete ] ) ; $ this -> owner -> getDb ( ) -> createCommand ( ) -> delete ( $ relation -> via -> from [ 0 ] , [ key ( $ relation -> via -> link ) => $ this -> owner -> getPrimaryKey ( ) ] ) -> execute ( ) ; } $ this -> _tagsForDelete = [ ] ; } }
10255	public function getApartment ( ) { $ types = [ 'Apt.' , 'Apartment' , 'Ste.' , 'Suite' , 'Box' ] ; if ( $ this -> getBool ( true , false ) ) { $ extra = $ this -> getLetter ( ) ; } else { $ extra = $ this -> getInteger ( 1 , 9999 ) ; } $ type = $ this -> fromArray ( $ types ) ; return $ type . ' ' . $ extra ; }
8903	public function delete_by_at ( $ condition , $ time ) { $ this -> prevent_if_not_soft_deletable ( ) ; $ this -> _set_where ( $ condition ) ; return $ this -> _delete ( $ condition , $ time ) ; }
4301	public function groupSummary ( $ priority = 0 ) { array ( $ priority ) ; $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) , array ( 'priority' => 0 ) , array ( 'priority' ) ) ; $ this -> data [ 'groupPriorityStack' ] [ ] = $ meta [ 'priority' ] ; $ this -> setLogDest ( 'summary' ) ; $ this -> internal -> publishBubbleEvent ( 'debug.log' , $ this , array ( 'method' => __FUNCTION__ , 'args' => array ( ) , 'meta' => $ meta , ) ) ; }
12702	public function get ( $ id ) { if ( isset ( $ this -> singletons [ $ id ] ) ) { return $ this -> singletons [ $ id ] ; } $ methodName = 'get' . Util :: mapIdToCamelCase ( $ id ) ; if ( method_exists ( $ this , $ methodName ) ) { return $ this -> $ methodName ( ) ; } throw new \ InvalidArgumentException ( "Unknown service '$id' in container '" . get_called_class ( ) . "'" ) ; }
10428	private function initSyncStorage ( ContainerBuilder $ container , array $ config ) { $ availableStorages = array_keys ( $ config [ 'sync' ] [ 'sync_storage' ] ) ; $ syncStorageStorage = current ( $ availableStorages ) ; if ( empty ( $ syncStorageStorage ) ) { throw new LogicException ( 'Data synchronization storage must be set.' ) ; } $ syncStorageStorageConfig = $ config [ 'sync' ] [ 'sync_storage' ] [ $ syncStorageStorage ] ; switch ( $ syncStorageStorage ) { case SyncStorage :: STORAGE_MYSQL : $ this -> initSyncStorageForMysql ( $ container , $ syncStorageStorageConfig ) ; break ; default : throw new LogicException ( "Unknown storage is set: {$syncStorageStorage}" ) ; } }
10540	protected function typeModification ( $ type , array $ args ) { if ( is_int ( $ args [ 1 ] ) ) { $ type .= '(' . $ args [ 1 ] ; if ( isset ( $ args [ 2 ] ) ) { $ type .= ',' . $ args [ 2 ] ; } $ type .= ')' ; } elseif ( is_array ( $ args [ 1 ] ) ) { if ( isset ( $ args [ 1 ] [ 'size' ] ) ) { $ type .= '(' . $ args [ 1 ] [ 'size' ] . ')' ; } foreach ( $ args [ 1 ] as $ key => $ val ) { if ( 'size' === $ key ) { continue ; } $ type .= ' ' . strtoupper ( $ key ) ; } } else { $ type .= $ args [ 1 ] ; } return $ type ; }
2737	private function setServiceID ( $ serviceId ) { $ this -> configWriter -> save ( Config :: XML_FASTLY_SERVICE_ID , $ serviceId ) ; $ this -> output -> writeln ( '<info>Service ID updated.</info>' , OutputInterface :: OUTPUT_NORMAL ) ; }
11004	public function getPath ( $ url ) { $ url = new URL ( $ url ) ; $ to_replace = $ this -> url -> path ; $ path = $ url -> path ; if ( strpos ( $ path , $ to_replace ) === 0 ) $ path = substr ( $ path , strlen ( $ to_replace ) ) ; $ path = '/' . urldecode ( $ path ) ; return $ path ; }
6200	public function currentPath ( ) { $ request = preg_replace ( '!' . $ this -> uri . '(.*)$!i' , '$1' , $ _SERVER [ 'REQUEST_URI' ] ) ; if ( defined ( 'MOD_REWRITE' ) and MOD_REWRITE === true ) { if ( substr ( $ request , - 1 ) != '/' ) { $ request .= '/' ; } $ parseUrl = $ this -> parseUrl ( $ request ) ; $ gets = $ parseUrl [ 'sVars' ] ; } else { $ gets = $ _SERVER [ 'QUERY_STRING' ] ; } return $ gets ; }
11072	public function setFloat ( string $ key , $ value , float $ ignoredDefaultValue = null ) { $ this -> set ( $ key , ( float ) $ value , $ ignoredDefaultValue ) ; return $ this ; }
10745	public function getObjectArray ( $ keys ) : array { return array_map ( function ( $ value ) { return $ this -> createObject ( $ value ) ; } , $ this -> getArray ( $ keys ) ) ; }
5707	public function getButtonLink ( ) { $ link = Controller :: join_links ( 'customaction' , $ this -> actionName ) ; return $ this -> gridFieldRequest -> Link ( $ link ) ; }
9363	public function add ( $ z ) { if ( is_numeric ( $ z ) ) { $ z = new self ( $ z , 0 ) ; } return new self ( $ this -> float_r + $ z -> re , $ this -> float_i + $ z -> im ) ; }
4912	public function setVariables ( $ variables , $ overwrite = false ) { if ( ! is_array ( $ variables ) && ! $ variables instanceof \ Traversable ) { throw new \ InvalidArgumentException ( sprintf ( '%s: expects an array, or Traversable argument; received "%s"' , __METHOD__ , ( is_object ( $ variables ) ? get_class ( $ variables ) : gettype ( $ variables ) ) ) ) ; } if ( $ overwrite ) { if ( is_object ( $ variables ) && ! $ variables instanceof \ ArrayAccess ) { $ variables = ArrayUtils :: iteratorToArray ( $ variables ) ; } $ this -> variables = $ variables ; return $ this ; } foreach ( $ variables as $ key => $ value ) { $ this -> setVariable ( $ key , $ value ) ; } return $ this ; }
449	public function init ( ) { parent :: init ( ) ; $ this -> cachePath = Yii :: getAlias ( $ this -> cachePath ) ; if ( ! is_dir ( $ this -> cachePath ) ) { FileHelper :: createDirectory ( $ this -> cachePath , $ this -> dirMode , true ) ; } }
1142	public function availableOptionValues ( ) { $ options = [ ] ; foreach ( $ this -> selector -> getOptions ( ) as $ option ) { $ options [ ] = $ option -> getAttribute ( 'value' ) ; } return $ options ; }
540	protected function addPaginationHeaders ( $ pagination ) { $ links = [ ] ; foreach ( $ pagination -> getLinks ( true ) as $ rel => $ url ) { $ links [ ] = "<$url>; rel=$rel" ; } $ this -> response -> getHeaders ( ) -> set ( $ this -> totalCountHeader , $ pagination -> totalCount ) -> set ( $ this -> pageCountHeader , $ pagination -> getPageCount ( ) ) -> set ( $ this -> currentPageHeader , $ pagination -> getPage ( ) + 1 ) -> set ( $ this -> perPageHeader , $ pagination -> pageSize ) -> set ( 'Link' , implode ( ', ' , $ links ) ) ; }
1020	public function getLocations ( ) { if ( $ this -> locations === null ) { $ positions = $ this -> getPositions ( ) ; $ source = $ this -> getSource ( ) ; $ nodes = $ this -> nodes ; if ( $ positions && $ source ) { $ this -> locations = array_map ( static function ( $ pos ) use ( $ source ) { return $ source -> getLocation ( $ pos ) ; } , $ positions ) ; } elseif ( $ nodes ) { $ locations = array_filter ( array_map ( static function ( $ node ) { if ( $ node -> loc && $ node -> loc -> source ) { return $ node -> loc -> source -> getLocation ( $ node -> loc -> start ) ; } } , $ nodes ) ) ; $ this -> locations = array_values ( $ locations ) ; } else { $ this -> locations = [ ] ; } } return $ this -> locations ; }
4814	private function createFrom ( $ filepath ) { if ( file_exists ( $ filepath ) ) { $ anyDataSet = XmlUtil :: createXmlDocumentFromFile ( $ filepath ) ; $ this -> collection = array ( ) ; $ rows = $ anyDataSet -> getElementsByTagName ( "row" ) ; foreach ( $ rows as $ row ) { $ sr = new Row ( ) ; $ fields = $ row -> getElementsByTagName ( "field" ) ; foreach ( $ fields as $ field ) { $ attr = $ field -> attributes -> getNamedItem ( "name" ) ; if ( is_null ( $ attr ) ) { throw new \ InvalidArgumentException ( 'Malformed anydataset file ' . basename ( $ filepath ) ) ; } $ sr -> addField ( $ attr -> nodeValue , $ field -> nodeValue ) ; } $ sr -> acceptChanges ( ) ; $ this -> collection [ ] = $ sr ; } $ this -> currentRow = count ( $ this -> collection ) - 1 ; } }
12266	public function renderCmsBlocks ( array $ blocks , $ username , array $ options = array ( ) ) { $ tmp = array ( ) ; foreach ( $ blocks as $ block ) { $ tmp [ ] = $ this -> renderCmsBlock ( $ block , $ username , $ options ) ; } return implode ( "\n" , $ tmp ) ; }
7978	public function setSshKey ( $ key ) { self :: getClient ( ) -> setSshKey ( $ this -> pp , $ this -> sn , $ key ) ; }
11556	protected function findParameter ( $ namespace , $ name , $ namespaceParameters ) { foreach ( $ namespaceParameters as $ namespaceParameter ) { if ( $ namespaceParameter -> getNamespace ( ) === $ namespace && $ namespaceParameter -> getName ( ) === $ name ) { return $ namespaceParameter ; } } return null ; }
2927	protected function resetContent ( ) { $ this -> filePath = null ; $ this -> reader -> load ( null ) ; $ this -> writer -> setBuffer ( null ) ; }
10736	public function compare ( $ x ) : int { if ( ! is_numeric ( $ x ) ) { throw new InvalidArgumentException ( __METHOD__ . "() expects parameter one, x, to be a number" ) ; } if ( $ x < $ this -> lower || ( ! $ this -> isLowerInclusive && $ x == $ this -> lower ) ) { return - 1 ; } elseif ( $ x > $ this -> upper || ( ! $ this -> isUpperInclusive && $ x == $ this -> upper ) ) { return 1 ; } else { return 0 ; } }
8157	public function prependPath ( $ path , $ namespace = self :: MAIN_NAMESPACE ) { $ this -> cache = $ this -> errorCache = array ( ) ; $ checkPath = $ this -> isAbsolutePath ( $ path ) ? $ path : $ this -> rootPath . $ path ; if ( ! is_dir ( $ checkPath ) ) { throw new Twig_Error_Loader ( sprintf ( 'The "%s" directory does not exist ("%s").' , $ path , $ checkPath ) ) ; } $ path = rtrim ( $ path , '/\\' ) ; if ( ! isset ( $ this -> paths [ $ namespace ] ) ) { $ this -> paths [ $ namespace ] [ ] = $ path ; } else { array_unshift ( $ this -> paths [ $ namespace ] , $ path ) ; } }
1870	private function isCorsRequest ( Request $ request ) : bool { return $ request -> headers -> has ( 'Origin' ) && $ request -> headers -> get ( 'Origin' ) !== $ request -> getSchemeAndHttpHost ( ) ; }
7025	public function addRememberMeCookie ( $ userId , $ options = [ ] ) { $ options = Hash :: merge ( [ 'expires' => '+14 days' , 'httpOnly' => true , 'secure' => false ] , $ options ) ; $ this -> Cookie -> config ( $ options ) ; $ this -> Cookie -> write ( 'User.id' , $ userId ) ; }
5544	public function getRaw ( ) { if ( is_integer ( $ this -> focus ) ) { return $ this -> frames [ $ this -> focus ] -> getRaw ( ) ; } $ raw = '' ; for ( $ i = 0 ; $ i < count ( $ this -> frames ) ; $ i ++ ) { $ raw .= $ this -> frames [ $ i ] -> getRaw ( ) ; } return $ raw ; }
5000	public function preRemove ( $ object ) { if ( ! is_null ( $ this -> urlProvider ) && ! is_null ( $ this -> menuManager ) ) { $ url = $ this -> urlProvider -> url ( $ object ) ; $ menuItem = $ this -> menuManager -> getItem ( $ url ) ; if ( $ menuItem instanceof MenuItem ) { $ this -> menuManager -> removeItem ( $ menuItem ) ; $ this -> menuManager -> flush ( ) ; } } }
317	public function registerAssetBundle ( $ name , $ position = null ) { if ( ! isset ( $ this -> assetBundles [ $ name ] ) ) { $ am = $ this -> getAssetManager ( ) ; $ bundle = $ am -> getBundle ( $ name ) ; $ this -> assetBundles [ $ name ] = false ; $ pos = isset ( $ bundle -> jsOptions [ 'position' ] ) ? $ bundle -> jsOptions [ 'position' ] : null ; foreach ( $ bundle -> depends as $ dep ) { $ this -> registerAssetBundle ( $ dep , $ pos ) ; } $ this -> assetBundles [ $ name ] = $ bundle ; } elseif ( $ this -> assetBundles [ $ name ] === false ) { throw new InvalidConfigException ( "A circular dependency is detected for bundle '$name'." ) ; } else { $ bundle = $ this -> assetBundles [ $ name ] ; } if ( $ position !== null ) { $ pos = isset ( $ bundle -> jsOptions [ 'position' ] ) ? $ bundle -> jsOptions [ 'position' ] : null ; if ( $ pos === null ) { $ bundle -> jsOptions [ 'position' ] = $ pos = $ position ; } elseif ( $ pos > $ position ) { throw new InvalidConfigException ( "An asset bundle that depends on '$name' has a higher javascript file position configured than '$name'." ) ; } foreach ( $ bundle -> depends as $ dep ) { $ this -> registerAssetBundle ( $ dep , $ pos ) ; } } return $ bundle ; }
7081	public function onPostCopy ( SaleTransformEvent $ event ) { $ source = $ event -> getSource ( ) ; $ target = $ event -> getTarget ( ) ; $ target -> setOriginNumber ( $ source -> getNumber ( ) ) ; if ( $ source instanceof OrderInterface && $ target instanceof OrderInterface ) { $ target -> setSample ( $ source -> isSample ( ) ) ; } if ( null === $ customer = $ source -> getCustomer ( ) ) { return ; } if ( $ target instanceof OrderInterface && $ customer -> hasParent ( ) ) { $ target -> setCustomer ( $ customer -> getParent ( ) ) ; if ( null === $ target -> getOriginCustomer ( ) ) { $ target -> setOriginCustomer ( $ customer ) ; } } }
4045	public function decodeValue ( DecodePropertyValueForWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) || ( $ event -> getProperty ( ) !== 'jumpTo' ) ) { return ; } $ propInfo = $ event -> getEnvironment ( ) -> getDataDefinition ( ) -> getPropertiesDefinition ( ) -> getProperty ( 'jumpTo' ) ; $ value = StringUtil :: deserialize ( $ event -> getValue ( ) , true ) ; $ extra = $ propInfo -> getExtra ( ) ; $ newValues = [ ] ; $ languages = $ extra [ 'columnFields' ] [ 'langcode' ] [ 'options' ] ; foreach ( array_keys ( $ languages ) as $ key ) { $ newValue = '' ; $ filter = 0 ; if ( $ value ) { foreach ( $ value as $ arr ) { if ( ! is_array ( $ arr ) ) { break ; } if ( array_search ( $ key , $ arr ) !== false ) { $ newValue = '{{link_url::' . $ arr [ 'value' ] . '}}' ; $ filter = $ arr [ 'filter' ] ; break ; } } } $ newValues [ ] = [ 'langcode' => $ key , 'value' => $ newValue , 'filter' => $ filter ] ; } $ event -> setValue ( $ newValues ) ; }
5922	public function setPropertySets ( array $ propertySets ) { $ this -> propertySets = [ ] ; foreach ( $ propertySets as $ item ) { $ this -> addPropertySet ( $ item ) ; } return $ this ; }
11218	public static function dispatch ( ) { self :: routeValidator ( ) ; self :: $ routes = str_replace ( '//' , '/' , self :: $ routes ) ; if ( in_array ( self :: $ uri , self :: $ routes , true ) ) { return self :: checkRoutes ( ) ; } if ( self :: checkRegexRoutes ( ) !== false ) { return self :: checkRegexRoutes ( ) ; } return self :: getErrorCallback ( ) ; }
12044	public function view ( UserPolicy $ user , Question $ question ) { if ( $ user -> canDo ( 'forum.question.view' ) && $ user -> isAdmin ( ) ) { return true ; } return $ question -> user_id == user_id ( ) && $ question -> user_type == user_type ( ) ; }
9303	public function setSuccessLogLifetime ( $ time ) { if ( ! is_numeric ( $ time ) ) { throw new \ InvalidArgumentException ( '`successLogLifetime` expects integer value!' ) ; } $ this -> options [ 'successLogLifetime' ] = ( int ) $ time ; return $ this ; }
2198	public static function findByIdOrAliasAndPid ( $ varId , $ intPid , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = ! preg_match ( '/^[1-9]\d*$/' , $ varId ) ? array ( "$t.alias=?" ) : array ( "$t.id=?" ) ; $ arrValues = array ( $ varId ) ; if ( $ intPid ) { $ arrColumns [ ] = "$t.pid=?" ; $ arrValues [ ] = $ intPid ; } return static :: findOneBy ( $ arrColumns , $ arrValues , $ arrOptions ) ; }
9524	public function deploy ( ) { $ pullRequest = getenv ( 'TRAVIS_PULL_REQUEST' ) ; $ branch = getenv ( 'TRAVIS_BRANCH' ) ; if ( ( int ) $ pullRequest >= 1 ) { die ( 'Not deploying pull requests.' . PHP_EOL ) ; } if ( ! array_key_exists ( $ branch , $ this -> branches ) ) { die ( 'Branch ' . $ branch . ' has no environment to deploy to.' . PHP_EOL ) ; } $ environment = $ this -> branches [ $ branch ] ; echo 'Downloading Deployer.phar...' . PHP_EOL ; passthru ( 'wget http://deployer.org/deployer.phar' ) ; echo 'Deploying...' . PHP_EOL ; $ deployCommand = 'php deployer.phar deploy' ; $ deployCommand .= ' ' . $ environment ; $ deployCommand .= $ this -> verbose ? ' -vvv' : '' ; passthru ( $ deployCommand ) ; }
4772	public function configs ( Request $ request , WidgetInterface $ widget , CacheInterface $ cache , string $ widgetId ) { $ widgets = $ widget -> getWidgets ( ) ; if ( isset ( $ widgets [ $ widgetId ] ) ) { $ widgetConfig = $ this -> getDoctrine ( ) -> getRepository ( 'PdWidgetBundle:WidgetUser' ) -> findOneBy ( [ 'owner' => $ this -> getUser ( ) ] ) ?? ( new WidgetUser ( ) ) -> setOwner ( $ this -> getUser ( ) ) ; if ( $ request -> get ( 'remove' ) ) { $ widgetConfig -> removeWidgetConfig ( $ widgetId , $ widgets [ $ widgetId ] -> getConfigProcess ( $ request ) ?? [ ] ) ; } else { $ widgetConfig -> addWidgetConfig ( $ widgetId , $ widgets [ $ widgetId ] -> getConfigProcess ( $ request ) ?? [ ] ) ; } $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ em -> persist ( $ widgetConfig ) ; $ em -> flush ( ) ; $ cache -> delete ( $ widgetId . $ this -> getUser ( ) -> getId ( ) ) ; } return $ this -> redirect ( $ request -> headers -> get ( 'referer' ) ?? $ this -> generateUrl ( $ this -> getParameter ( 'pd_widget.return_route' ) ) ) ; }
12566	public function sendVideo ( $ message , $ to = null ) { return $ this -> send ( self :: MSG_TYPE_VIDEO , $ message , $ to ) ; }
3184	public function jsonSerialize ( ) { $ source = $ this -> getSource ( ) ; $ timeLimits = $ source -> getTimeLimits ( ) ; if ( ! is_null ( $ timeLimits ) ) { $ identifier = $ source -> getIdentifier ( ) ; $ maxTime = $ timeLimits -> getMaxTime ( ) ; $ minTime = $ timeLimits -> getMinTime ( ) ; $ maxTimeRemaining = $ this -> getMaximumRemainingTime ( ) ; $ minTimeRemaining = $ this -> getMinimumRemainingTime ( ) ; if ( $ maxTimeRemaining !== false || $ minTimeRemaining !== false ) { $ label = method_exists ( $ source , 'getTitle' ) ? $ source -> getTitle ( ) : $ identifier ; $ extraTime = [ ] ; if ( ! is_null ( $ this -> getTimer ( ) ) && $ source -> getTimeLimits ( ) -> hasMaxTime ( ) ) { $ timer = $ this -> getTimer ( ) ; $ maxTimeSeconds = $ source -> getTimeLimits ( ) -> getMaxTime ( ) -> getSeconds ( true ) ; $ extraTime = [ 'total' => $ timer -> getExtraTime ( $ maxTimeSeconds ) , 'consumed' => $ timer -> getConsumedExtraTime ( $ identifier , $ maxTimeSeconds , $ this -> timerTarget ) , 'remaining' => $ timer -> getRemainingExtraTime ( $ identifier , $ maxTimeSeconds , $ this -> timerTarget ) , ] ; } $ labelFormatter = ServiceManager :: getServiceManager ( ) -> get ( TimerLabelFormatterService :: SERVICE_ID ) ; return [ 'label' => $ labelFormatter -> format ( $ label ) , 'source' => $ identifier , 'qtiClassName' => $ source -> getQtiClassName ( ) , 'extraTime' => $ extraTime , 'allowLateSubmission' => $ this -> allowLateSubmission ( ) , 'minTime' => $ this -> durationToMs ( $ minTime ) , 'minTimeRemaining' => $ this -> durationToMs ( $ minTimeRemaining ) , 'maxTime' => $ this -> durationToMs ( $ maxTime ) , 'maxTimeRemaining' => $ this -> durationToMs ( $ maxTimeRemaining ) , ] ; } } return null ; }
2160	public function run32Update ( ) { $ this -> Database -> query ( "ALTER TABLE `tl_layout` CHANGE `sections` `sections` varchar(1022) NOT NULL default ''" ) ; $ objLayout = $ this -> Database -> query ( "SELECT id, sections FROM tl_layout WHERE sections!=''" ) ; while ( $ objLayout -> next ( ) ) { $ strSections = '' ; $ tmp = StringUtil :: deserialize ( $ objLayout -> sections ) ; if ( ! empty ( $ tmp ) && \ is_array ( $ tmp ) ) { $ strSections = implode ( ', ' , $ tmp ) ; } $ this -> Database -> prepare ( "UPDATE tl_layout SET sections=? WHERE id=?" ) -> execute ( $ strSections , $ objLayout -> id ) ; } if ( ! $ this -> Database -> fieldExists ( 'uuid' , 'tl_files' ) ) { $ this -> Database -> query ( "ALTER TABLE `tl_files` ADD `uuid` binary(16) NULL" ) ; $ this -> Database -> query ( "ALTER TABLE `tl_files` ADD UNIQUE KEY `uuid` (`uuid`)" ) ; $ this -> Database -> query ( "ALTER TABLE `tl_files` ADD `pid_backup` int(10) unsigned NOT NULL default 0" ) ; $ this -> Database -> query ( "UPDATE `tl_files` SET `pid_backup`=`pid`" ) ; $ this -> Database -> query ( "ALTER TABLE `tl_files` CHANGE `pid` `pid` binary(16) NULL" ) ; $ this -> Database -> query ( "UPDATE `tl_files` SET `pid`=NULL" ) ; $ this -> Database -> query ( "UPDATE `tl_files` SET `pid`=NULL WHERE `pid_backup`=0" ) ; $ objFiles = $ this -> Database -> query ( "SELECT id FROM tl_files" ) ; while ( $ objFiles -> next ( ) ) { $ this -> Database -> prepare ( "UPDATE tl_files SET uuid=? WHERE id=?" ) -> execute ( $ this -> Database -> getUuid ( ) , $ objFiles -> id ) ; } $ objFiles = $ this -> Database -> query ( "SELECT pid_backup FROM tl_files WHERE pid_backup>0 GROUP BY pid_backup" ) ; while ( $ objFiles -> next ( ) ) { $ objParent = $ this -> Database -> prepare ( "SELECT uuid FROM tl_files WHERE id=?" ) -> execute ( $ objFiles -> pid_backup ) ; if ( $ objParent -> numRows < 1 ) { throw new \ Exception ( 'Invalid parent ID ' . $ objFiles -> pid_backup ) ; } $ this -> Database -> prepare ( "UPDATE tl_files SET pid=? WHERE pid_backup=?" ) -> execute ( $ objParent -> uuid , $ objFiles -> pid_backup ) ; } $ this -> Database -> query ( "ALTER TABLE `tl_files` DROP `pid_backup`" ) ; } $ this -> updateFileTreeFields ( ) ; }
5929	public function updateCategory ( $ id , Category $ category ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'category' => $ category ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/categories/' . $ id . '' , $ parameters ) ; $ result = new CategoryResponse ( $ result ) ; return $ result ; }
10758	protected function prepareHeader ( array $ data ) { return array_merge_recursive ( [ 'date' => trans ( 'dashboard::logs.date' ) , 'all' => trans ( 'dashboard::logs.all' ) , ] , $ this -> levels -> names ( $ this -> locale ) ) ; }
11689	public function isAccompanyingPeriodValid ( ExecutionContextInterface $ context ) { $ r = $ this -> checkAccompanyingPeriodsAreNotCollapsing ( ) ; if ( $ r !== true ) { if ( $ r [ 'result' ] === self :: ERROR_PERIODS_ARE_COLLAPSING ) { $ context -> addViolationAt ( 'accompanyingPeriods' , 'Two accompanying periods have days in commun' , array ( ) ) ; } if ( $ r [ 'result' ] === self :: ERROR_ADDIND_PERIOD_AFTER_AN_OPEN_PERIOD ) { $ context -> addViolationAt ( 'accompanyingPeriods' , 'A period is opened and a period is added after it' , array ( ) ) ; } } }
5731	public function getLeagues ( array $ filter = [ 'areas' => '' ] ) { $ leagues = $ this -> run ( "v2/competitions" . "?" . http_build_query ( $ filter ) ) ; return collect ( $ leagues -> competitions ) ; }
16	public static function getContentHash ( $ composerFileContents ) { $ content = json_decode ( $ composerFileContents , true ) ; $ relevantKeys = array ( 'name' , 'version' , 'require' , 'require-dev' , 'conflict' , 'replace' , 'provide' , 'minimum-stability' , 'prefer-stable' , 'repositories' , 'extra' , ) ; $ relevantContent = array ( ) ; foreach ( array_intersect ( $ relevantKeys , array_keys ( $ content ) ) as $ key ) { $ relevantContent [ $ key ] = $ content [ $ key ] ; } if ( isset ( $ content [ 'config' ] [ 'platform' ] ) ) { $ relevantContent [ 'config' ] [ 'platform' ] = $ content [ 'config' ] [ 'platform' ] ; } ksort ( $ relevantContent ) ; return md5 ( json_encode ( $ relevantContent ) ) ; }
530	public function actionSortChangelog ( array $ what ) { if ( \ count ( $ what ) > 1 ) { $ this -> stdout ( "Currently only one simultaneous release is supported.\n" ) ; return 1 ; } $ this -> validateWhat ( $ what , [ 'framework' , 'ext' ] , false ) ; $ version = $ this -> version ? : array_values ( $ this -> getNextVersions ( $ this -> getCurrentVersions ( $ what ) , self :: PATCH ) ) [ 0 ] ; $ this -> stdout ( 'sorting CHANGELOG of ' ) ; $ this -> stdout ( reset ( $ what ) , Console :: BOLD ) ; $ this -> stdout ( ' for version ' ) ; $ this -> stdout ( $ version , Console :: BOLD ) ; $ this -> stdout ( '...' ) ; $ this -> resortChangelogs ( $ what , $ version ) ; $ this -> stdout ( "done.\n" , Console :: BOLD , Console :: FG_GREEN ) ; }
1762	public static function convertXlfToPhp ( $ strName , $ strLanguage , $ blnLoad = false ) { @ trigger_error ( 'Using System::convertXlfToPhp() has been deprecated and will no longer work in Contao 5.0. Use the Contao\CoreBundle\Config\Loader\XliffFileLoader instead.' , E_USER_DEPRECATED ) ; $ rootDir = self :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( strpos ( $ strName , $ rootDir . '/' ) === false ) { $ strName = $ rootDir . '/' . $ strName ; } $ loader = new XliffFileLoader ( static :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) , $ blnLoad ) ; return $ loader -> load ( $ strName , $ strLanguage ) ; }
11422	public function get ( $ openId , $ lang = 'zh_CN' ) { $ params = [ 'openid' => $ openId , 'lang' => $ lang , ] ; return $ this -> parseJSON ( 'get' , [ self :: API_GET , $ params ] ) ; }
8628	public static function fromXML ( $ xml ) { $ dom = new DOMDocument ( ) ; $ dom -> loadXML ( $ xml ) ; $ xpath = new DOMXPath ( $ dom ) ; $ response = $ xpath -> query ( "//*[local-name()='GetCompetitivePricingForSKUResponse']" ) ; if ( $ response -> length == 1 ) { return new MarketplaceWebServiceProducts_Model_GetCompetitivePricingForSKUResponse ( ( $ response -> item ( 0 ) ) ) ; } else { throw new Exception ( "Unable to construct MarketplaceWebServiceProducts_Model_GetCompetitivePricingForSKUResponse from provided XML. Make sure that GetCompetitivePricingForSKUResponse is a root element" ) ; } }
8074	public function delete ( $ endpoint , $ headers = [ ] ) { $ request = new Request ( 'DELETE' , $ endpoint , $ headers ) ; $ response = $ this -> guzzle -> send ( $ request ) ; return $ this -> handle ( $ response ) ; }
10545	public function setVirtualHost ( VirtualHost $ vhost ) { $ this -> vhost = $ vhost ; $ this -> setVariable ( 'vhost' , $ vhost ) ; return $ this ; }
2969	protected function getTableGateway ( $ tableName ) { if ( ! array_key_exists ( $ tableName , $ this -> tableGateways ) ) { $ acl = TableSchema :: getAclInstance ( ) ; $ this -> tableGateways [ $ tableName ] = new RelationalTableGateway ( $ tableName , $ this -> connection , $ acl ) ; } return $ this -> tableGateways [ $ tableName ] ; }
671	public function run ( $ id ) { $ model = $ this -> findModel ( $ id ) ; if ( $ this -> checkAccess ) { call_user_func ( $ this -> checkAccess , $ this -> id , $ model ) ; } $ model -> scenario = $ this -> scenario ; $ model -> load ( Yii :: $ app -> getRequest ( ) -> getBodyParams ( ) , '' ) ; if ( $ model -> save ( ) === false && ! $ model -> hasErrors ( ) ) { throw new ServerErrorHttpException ( 'Failed to update the object for unknown reason.' ) ; } return $ model ; }
148	public static function createValidator ( $ type , $ model , $ attributes , $ params = [ ] ) { $ params [ 'attributes' ] = $ attributes ; if ( $ type instanceof \ Closure || ( $ model -> hasMethod ( $ type ) && ! isset ( static :: $ builtInValidators [ $ type ] ) ) ) { $ params [ 'class' ] = __NAMESPACE__ . '\InlineValidator' ; $ params [ 'method' ] = $ type ; } else { if ( isset ( static :: $ builtInValidators [ $ type ] ) ) { $ type = static :: $ builtInValidators [ $ type ] ; } if ( is_array ( $ type ) ) { $ params = array_merge ( $ type , $ params ) ; } else { $ params [ 'class' ] = $ type ; } } return Yii :: createObject ( $ params ) ; }
8602	public function deregisterDestination ( $ request ) { if ( ! ( $ request instanceof MWSSubscriptionsService_Model_DeregisterDestinationInput ) ) { require_once ( dirname ( __FILE__ ) . '/Model/DeregisterDestinationInput.php' ) ; $ request = new MWSSubscriptionsService_Model_DeregisterDestinationInput ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'DeregisterDestination' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/DeregisterDestinationResponse.php' ) ; $ response = MWSSubscriptionsService_Model_DeregisterDestinationResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
4868	protected function parseOptionsToDateTime ( $ options ) { $ time = microtime ( true ) ; $ micro = sprintf ( "%06d" , ( $ time - floor ( $ time ) ) * 1000000 ) ; $ this -> now = new \ DateTime ( date ( 'Y-m-d H:i:s.' . $ micro , $ time ) , new \ DateTimeZone ( date_default_timezone_get ( ) ) ) ; $ scheduled = isset ( $ options [ 'scheduled' ] ) ? Utils :: createDateTime ( $ options [ 'scheduled' ] ) : clone ( $ this -> now ) ; if ( isset ( $ options [ 'delay' ] ) ) { $ delay = Utils :: createDateInterval ( $ options [ 'delay' ] ) ; $ scheduled -> add ( $ delay ) ; } return $ scheduled ; }
5297	protected function getOptionsFromXML ( ) { $ options = array ( ) ; foreach ( array ( 'id' , 'horiz-adv-x' ) as $ key ) { if ( isset ( $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] [ $ key ] ) ) { $ options [ $ key ] = ( string ) $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] [ $ key ] ; } } foreach ( array ( 'units-per-em' , 'ascent' , 'descent' , 'x-height' , 'cap-height' ) as $ key ) { if ( isset ( $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] -> { 'font-face' } [ 0 ] [ $ key ] ) ) { $ options [ $ key ] = ( string ) $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] -> { 'font-face' } [ 0 ] [ $ key ] ; } } return $ options ; }
9164	protected function parseNode ( RuleCollection $ collection , \ DOMElement $ node , $ path , $ file ) { if ( self :: NAMESPACE_URI !== $ node -> namespaceURI ) { return ; } switch ( $ node -> localName ) { case 'rule' : $ this -> parseRule ( $ collection , $ node , $ path ) ; break ; case 'import' : $ this -> parseImport ( $ collection , $ node , $ path , $ file ) ; break ; default : throw new \ InvalidArgumentException ( sprintf ( 'Unknown tag "%s" used in file "%s". Expected "rule" or "import".' , $ node -> localName , $ path ) ) ; } }
6637	protected function initParams ( ) { Yii :: $ app -> view -> params [ 'h1' ] = Yii :: t ( 'wavecms/main' , '<i>Not set</i>' ) ; Yii :: $ app -> view -> params [ 'buttons_top' ] = [ ] ; Yii :: $ app -> view -> params [ 'buttons_btm' ] = [ ] ; Yii :: $ app -> view -> params [ 'buttons_sublist' ] = [ ] ; }
4715	public function split ( $ pattern , $ flags = PREG_SPLIT_DELIM_CAPTURE ) { return new Collection ( array_map ( function ( $ item ) { return new static ( $ item ) ; } , preg_split ( $ pattern , $ this -> text , - 1 , $ flags ) ) ) ; }
9237	private function getAmbiguityExceptionMessage ( array $ paths , Vertex $ startVertex , Vertex $ endVertex ) { $ textPaths = [ ] ; $ i = 1 ; foreach ( $ paths as $ path ) { $ textPaths [ ] = 'Path ' . $ i . ': ' . $ this -> getTextualPath ( $ path , $ startVertex ) ; ++ $ i ; } $ msg = sprintf ( "There are many possible shortest paths between table '%s' and table '%s'\n\n" , $ startVertex -> getId ( ) , $ endVertex -> getId ( ) ) ; $ msg .= implode ( "\n\n" , $ textPaths ) ; return $ msg ; }
5694	public function index ( HTTPRequest $ r ) { Requirements :: css ( BETTER_BUTTONS_DIR . '/css/betterbuttons_nested_form.css' ) ; return $ this -> customise ( array ( 'Form' => $ this -> Form ( ) ) ) -> renderWith ( BetterButtonNestedForm :: class ) ; }
4107	public function showHints ( ) { if ( is_null ( $ this -> showHints ) ) { $ this -> showHints = false ; if ( Mage :: helper ( 'core' ) -> isDevAllowed ( ) ) { if ( Mage :: getSingleton ( 'core/cookie' ) -> get ( 'ath' ) || Mage :: app ( ) -> getRequest ( ) -> get ( 'ath' ) ) { $ this -> showHints = true ; } } } return $ this -> showHints ; }
12873	protected function getElementValidatorChain ( \ Zend \ Form \ Element $ element ) { $ elementName = $ element -> getAttribute ( 'name' ) ; return $ this -> form -> getInputFilter ( ) -> get ( $ elementName ) -> getValidatorChain ( ) ; }
6317	public function execute ( $ sql ) { $ this -> dispatcher -> dispatch ( 'rentgen.sql_executed' , new SqlEvent ( $ sql ) ) ; return $ this -> getConnection ( ) -> exec ( $ sql ) ; }
1081	private function loc ( Token $ startToken ) { if ( empty ( $ this -> lexer -> options [ 'noLocation' ] ) ) { return new Location ( $ startToken , $ this -> lexer -> lastToken , $ this -> lexer -> source ) ; } return null ; }
8884	private function buildPackages ( $ number , $ weight , $ measurement = 'LBS' ) { $ packages = array ( ) ; if ( $ number > 1 ) { $ individual_weight = $ weight / $ number ; for ( $ i = 0 ; $ i < $ number ; $ i ++ ) { $ packages [ ] = '<Package> <PackagingType> <Code>02</Code> </PackagingType> <PackageWeight> <UnitOfMeasurement> <Code>' . $ measurement . '</Code> </UnitOfMeasurement> <Weight>' . $ individual_weight . '</Weight> </PackageWeight> </Package>' ; } } else { $ packages [ ] = '<Package> <PackagingType> <Code>02</Code> </PackagingType> <PackageWeight> <UnitOfMeasurement> <Code>' . $ measurement . '</Code> </UnitOfMeasurement> <Weight>' . $ weight . '</Weight> </PackageWeight> </Package>' ; } return implode ( '' , $ packages ) ; }
12651	private function writeTextsToFile ( $ language ) { $ textInfo = array ( ) ; $ outdateInfo = array ( ) ; foreach ( $ this -> contents [ $ language ] as $ id => $ info ) { $ textInfo [ $ id ] = $ info [ 'content' ] ; $ outdateInfo [ $ id ] = $ info [ 'outdated' ] ; } if ( $ language === $ this -> baseLang ) { $ content = array ( 'root' => $ textInfo ) + array_fill_keys ( $ this -> extraLangs , true ) ; } else { $ content = $ textInfo ; } $ encodeFlags = JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES ; $ content = "'use strict';\n/*global define*/\ndefine(" . json_encode ( $ content , $ encodeFlags ) . ");\n" ; $ fs = $ this -> env -> getFileSystem ( ) ; $ fs -> putFile ( $ this -> getFileName ( $ language ) , $ content ) ; $ fs -> putFile ( $ this -> getOutdateInfoFileName ( $ language ) , json_encode ( $ outdateInfo , $ encodeFlags ) ) ; }
3475	public function getGateway ( ) { $ gateway = $ this -> gateway ; try { $ response = $ this -> guzzle -> get ( 'https://discordapp.com/api/gateway' , [ 'headers' => [ 'Authorization' => 'Bot ' . $ this -> token , ] , ] ) ; $ gateway = Arr :: get ( json_decode ( $ response -> getBody ( ) , true ) , 'url' , $ gateway ) ; } catch ( Exception $ e ) { $ this -> warn ( "Could not get a websocket gateway address, defaulting to '{$gateway}'." ) ; } return $ gateway ; }
6019	public function removeSite ( $ id ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> delete ( 'v1/deployment/' . $ id . '' , $ parameters ) ; $ result = new DeploymentSiteResponse ( $ result ) ; return $ result ; }
5170	public static function getNameByType ( $ type ) { static $ map = array ( self :: TYPE_BOOL => 'Bool' , self :: TYPE_INT => 'Int' , self :: TYPE_UINT => 'UInt' , self :: TYPE_QCHAR => 'QChar' , self :: TYPE_QVARIANT_MAP => 'QVariantMap' , self :: TYPE_QVARIANT_LIST => 'QVariantList' , self :: TYPE_QSTRING => 'QString' , self :: TYPE_QSTRING_LIST => 'QStringList' , self :: TYPE_QBYTE_ARRAY => 'QByteArray' , self :: TYPE_QTIME => 'QTime' , self :: TYPE_QDATETIME => 'QDateTime' , self :: TYPE_QUSER_TYPE => 'QUserType' , self :: TYPE_SHORT => 'Short' , self :: TYPE_CHAR => 'Char' , self :: TYPE_USHORT => 'UShort' , self :: TYPE_UCHAR => 'UChar' , ) ; if ( ! isset ( $ map [ $ type ] ) ) { throw new \ InvalidArgumentException ( 'Invalid/unknown variant type (' . $ type . ')' ) ; } return $ map [ $ type ] ; }
3501	public function withCollapseId ( CollapseId $ collapseId = null ) : Notification { $ cloned = clone $ this ; $ cloned -> collapseId = $ collapseId ; return $ cloned ; }
2482	protected function generateQueryString ( array $ parameters ) { $ removedArrayCharacters = preg_replace ( '/%5B[0-9]+%5D=/' , '=' , http_build_query ( $ parameters ) ) ; $ removedDuplicatedEscapingForUrlPath = str_replace ( '%5C%5C%2F' , '%5C%2F' , $ removedArrayCharacters ) ; return $ removedDuplicatedEscapingForUrlPath ; }
10589	public function buildPayoutFromId ( $ sPayoutId ) { $ oPayout = new Freeagent \ DataWrapper \ PayoutVO ( ) ; $ oPayout -> setId ( $ sPayoutId ) ; try { $ oDets = $ this -> getTxnChargeDetails ( $ sPayoutId ) ; $ oPayout -> setDateArrival ( strtotime ( $ oDets -> PaymentDate ) ) -> setCurrency ( $ oDets -> GrossAmount -> currencyID ) ; $ oPayout -> addCharge ( $ this -> buildChargeFromTransaction ( $ sPayoutId ) ) ; } catch ( \ Exception $ oE ) { } return $ oPayout ; }
10779	private function addSessionCookie ( ResponseInterface $ response ) : ResponseInterface { $ params = session_get_cookie_params ( ) ; $ cookie = new SetCookie ( session_name ( ) , session_id ( ) , time ( ) + $ params [ "lifetime" ] , $ params [ "path" ] , $ params [ "domain" ] , $ params [ "secure" ] , $ params [ "httponly" ] ) ; return $ cookie -> addToResponse ( $ response ) ; }
2750	public function getVclSnippets ( $ path = '/vcl_snippets' , $ specificFile = null ) { $ snippetsData = [ ] ; $ moduleEtcPath = $ this -> reader -> getModuleDir ( Dir :: MODULE_ETC_DIR , 'Fastly_Cdn' ) . $ path ; $ directoryRead = $ this -> readFactory -> create ( $ moduleEtcPath ) ; if ( ! $ specificFile ) { $ files = $ directoryRead -> read ( ) ; if ( is_array ( $ files ) ) { foreach ( $ files as $ file ) { if ( substr ( $ file , strpos ( $ file , "." ) + 1 ) !== 'vcl' ) { continue ; } $ snippetFilePath = $ moduleEtcPath . '/' . $ file ; $ snippetFilePath = $ directoryRead -> getRelativePath ( $ snippetFilePath ) ; $ type = explode ( '.' , $ file ) [ 0 ] ; $ snippetsData [ $ type ] = $ directoryRead -> readFile ( $ snippetFilePath ) ; } } } else { $ snippetFilePath = $ moduleEtcPath . '/' . $ specificFile ; $ snippetFilePath = $ directoryRead -> getRelativePath ( $ snippetFilePath ) ; $ type = explode ( '.' , $ specificFile ) [ 0 ] ; $ snippetsData [ $ type ] = $ directoryRead -> readFile ( $ snippetFilePath ) ; } return $ snippetsData ; }
9301	public function setScheduleAhead ( $ time ) { if ( ! is_numeric ( $ time ) ) { throw new \ InvalidArgumentException ( '`scheduleAhead` expects integer value!' ) ; } $ this -> options [ 'scheduleAhead' ] = ( int ) $ time ; return $ this ; }
1634	public function boot ( ) { $ this -> app [ 'auth' ] -> viaRequest ( 'api' , function ( $ request ) { if ( $ request -> input ( 'api_token' ) ) { return User :: where ( 'api_token' , $ request -> input ( 'api_token' ) ) -> first ( ) ; } } ) ; }
8910	private function getCallableFunction ( $ method ) { if ( is_callable ( $ method ) ) { return $ method ; } if ( is_string ( $ method ) && is_callable ( array ( $ this , $ method ) ) ) { return array ( $ this , $ method ) ; } return FALSE ; }
10873	public function cleanUser ( string $ validate = null ) : int { $ result = 0 ; if ( $ validate ) { $ validateTo = new DateTime ; $ validateTo -> modify ( $ validate ) ; $ list = $ this -> getList ( ) -> where ( [ $ this -> tableName [ 0 ] . '.active' => false , $ this -> tableName [ 0 ] . '.added IS NOT NULL' , [ $ this -> tableName [ 0 ] . '.added<=%dt' , $ validateTo ] , ] ) ; foreach ( $ list as $ item ) { if ( $ this -> delete ( $ item [ self :: COLUMN_ID ] ) ) { $ result ++ ; } } } return $ result ; }
4337	private function getDefaultOutputAs ( ) { $ ret = 'html' ; $ interface = $ this -> debug -> utilities -> getInterface ( ) ; if ( $ interface == 'ajax' ) { $ ret = $ this -> cfg [ 'outputAsDefaultNonHtml' ] ; } elseif ( $ interface == 'http' ) { $ contentType = $ this -> debug -> utilities -> getResponseHeader ( ) ; if ( $ contentType && $ contentType !== 'text/html' ) { $ ret = $ this -> cfg [ 'outputAsDefaultNonHtml' ] ; } } else { $ ret = 'text' ; } return $ ret ; }
9055	public function addColumnToRename ( string $ name , Column $ column ) : self { $ this -> oldColumns [ $ name ] = $ column ; return $ this ; }
6581	public function translate ( $ shift , $ y = null , $ z = null ) { if ( $ shift instanceof self ) return new static ( $ this -> gps [ 'x' ] + $ shift -> gps [ 'x' ] , $ this -> gps [ 'y' ] + $ shift -> gps [ 'y' ] , $ this -> gps [ 'z' ] + $ shift -> gps [ 'z' ] ) ; else return new static ( $ this -> gps [ 'x' ] + $ shift , $ this -> gps [ 'y' ] + $ y , $ this -> gps [ 'z' ] + $ z ) ; }
8957	public function redaction ( $ element , $ id , $ version , $ redactionId ) { if ( $ element != 'node' && $ element != 'way' && $ element != 'relation' ) { throw new \ DomainException ( 'Element should be a node, a way or a relation' ) ; } $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = $ element . '/' . $ id . '/' . $ version . '/redact?redaction=' . $ redactionId ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'PUT' , $ parameters ) ; return simplexml_load_string ( $ response -> body ) ; }
3927	public function setValueOptionsMultiple ( ManipulateWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } if ( $ event -> getModel ( ) -> getProperty ( 'type' ) !== 'conditionpropertycontainanyof' ) { return ; } $ metaModel = $ this -> getMetaModel ( $ event -> getEnvironment ( ) ) ; $ attribute = $ metaModel -> getAttributeById ( $ event -> getModel ( ) -> getProperty ( 'attr_id' ) ) ; if ( ! ( $ attribute && ( $ attribute -> get ( 'type' ) == 'tags' ) ) ) { return ; } $ event -> getWidget ( ) -> multiple = true ; }
1579	public function withType ( string $ type ) : self { if ( empty ( $ type ) ) { throw new \ InvalidArgumentException ( 'Expecting a non-empty string.' ) ; } $ copy = clone $ this ; $ copy -> type = $ type ; $ copy -> normalize ( ) ; return $ copy ; }
11641	public function getColumns ( ) { if ( is_null ( $ this -> _columns ) ) { $ this -> columns = $ this -> dataProvider -> model -> attributeNames ( ) ; } return $ this -> _columns ; }
1127	public function isAncestorOf ( $ other ) { return ( $ this -> getLeft ( ) < $ other -> getLeft ( ) && $ this -> getRight ( ) > $ other -> getLeft ( ) && $ this -> inSameScope ( $ other ) ) ; }
6300	public function render ( $ mainName = 'default' , $ barName = false , array $ data = null ) { if ( $ data === null ) { $ data = [ 'title' => 'Navigation' , 'side' => 'dropdown' , 'inverse' => true ] ; } $ main = $ this -> getMain ( $ mainName ) ; if ( is_string ( $ barName ) ) { $ bar = $ this -> getBar ( $ barName ) ; if ( empty ( $ bar ) ) { $ bar = false ; } } else { $ bar = false ; } return $ this -> view -> make ( $ this -> name , array_merge ( $ data , [ 'main' => $ main , 'bar' => $ bar ] ) ) -> render ( ) ; }
2246	public static function isVisibleElement ( Model $ objElement ) { $ blnReturn = true ; if ( TL_MODE == 'FE' ) { if ( $ objElement -> protected ) { if ( ! FE_USER_LOGGED_IN ) { $ blnReturn = false ; } else { $ objUser = FrontendUser :: getInstance ( ) ; if ( ! \ is_array ( $ objUser -> groups ) ) { $ blnReturn = false ; } else { $ groups = StringUtil :: deserialize ( $ objElement -> groups ) ; if ( empty ( $ groups ) || ! \ is_array ( $ groups ) || ! \ count ( array_intersect ( $ groups , $ objUser -> groups ) ) ) { $ blnReturn = false ; } } } } elseif ( $ objElement -> guests && FE_USER_LOGGED_IN ) { $ blnReturn = false ; } } if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'isVisibleElement' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'isVisibleElement' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'isVisibleElement' ] as $ callback ) { $ blnReturn = static :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ objElement , $ blnReturn ) ; } } return $ blnReturn ; }
8021	public function payload ( array $ payload ) { $ client = new GuzzleClient ( [ 'base_uri' => $ this -> server ] ) ; $ client -> request ( 'POST' , $ this -> getUri ( ) , [ 'form_params' => [ 'payload' => json_encode ( $ payload ) ] ] ) ; }
4041	public function render ( ModelToLabelEvent $ event ) { $ environment = $ event -> getEnvironment ( ) ; $ definition = $ environment -> getDataDefinition ( ) ; $ viewSection = $ definition -> getDefinition ( Contao2BackendViewDefinitionInterface :: NAME ) ; $ listing = $ viewSection -> getListingConfig ( ) ; $ model = $ event -> getModel ( ) ; if ( ! ( $ model instanceof Model ) ) { return ; } $ nativeItem = $ model -> getItem ( ) ; $ metaModel = $ nativeItem -> getMetaModel ( ) ; $ renderSetting = $ this -> renderSettingFactory -> createCollection ( $ metaModel , $ definition -> getMetaModelDefinition ( ) -> getActiveRenderSetting ( ) ) ; if ( ! $ renderSetting ) { return ; } $ data = array ( $ nativeItem -> parseValue ( 'html5' , $ renderSetting ) ) ; if ( $ listing -> getShowColumns ( ) ) { $ event -> setArgs ( $ data [ 0 ] [ 'html5' ] ) ; return ; } $ template = new Template ( $ renderSetting -> get ( 'template' ) ) ; $ renderSetting = self :: removeInvariantAttributes ( $ nativeItem , $ renderSetting ) ; $ template -> setData ( array ( 'settings' => $ renderSetting , 'items' => new Items ( array ( $ nativeItem ) ) , 'view' => $ renderSetting , 'data' => $ data ) ) ; $ event -> setLabel ( '%s' ) -> setArgs ( array ( $ template -> parse ( 'html5' ) ) ) ; }
8374	public function set ( $ set ) { if ( is_array ( $ set ) === true ) { $ this -> set = '' ; foreach ( $ set as $ name => $ value ) { $ pos = stripos ( $ name , '.' ) ; if ( $ pos !== false ) { $ this -> set .= substr ( $ name , $ pos + 1 ) ; } else { $ this -> set .= $ name ; } $ this -> set .= ' = ' . $ value . ', ' ; } $ this -> set = substr ( $ this -> set , 0 , - 2 ) ; } else { $ this -> set = $ set ; } return $ this ; }
3672	private function getPageCandidates ( string $ alias ) { $ aliases = [ $ alias ] ; while ( '/' !== $ alias && false !== strpos ( $ alias , '/' ) ) { $ alias = \ dirname ( $ alias ) ; $ aliases [ ] = $ alias ; } $ pages = $ this -> pageModelAdapter -> findByAliases ( $ aliases ) ; if ( null === $ pages ) { return null ; } $ arrPages = [ ] ; while ( $ pages -> next ( ) ) { $ objModel = $ pages -> current ( ) ; $ objPage = $ objModel -> loadDetails ( ) ; $ domain = $ objPage -> domain ? : '*' ; $ arrPages [ $ domain ] [ $ objPage -> rootLanguage ] [ ] = $ objPage ; if ( $ objPage -> rootIsFallback ) { $ arrPages [ $ domain ] [ '*' ] [ ] = $ objPage ; } } return $ arrPages ; }
5519	protected function emulateCall ( $ method , $ args , $ step ) { return $ this -> actions -> respond ( $ step , $ method , $ args ) ; }
4448	public function put ( string $ className , array $ data , ? string $ jid = null , ? int $ delay = null , ? int $ retries = null , ? int $ priority = null , ? array $ tags = null , ? array $ depends = null ) { try { $ jid = $ jid ? : str_replace ( '-' , '' , Uuid :: uuid4 ( ) -> toString ( ) ) ; } catch ( \ Exception $ e ) { throw new RuntimeException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } $ data = new JobData ( $ data ) ; $ this -> getEventsManager ( ) -> fire ( new QueueEvent \ BeforeEnqueue ( $ this , $ jid , $ data , $ className ) ) ; if ( ! $ putData = json_encode ( $ data , JSON_UNESCAPED_SLASHES ) ) { throw new RuntimeException ( sprintf ( 'Unable to encode payload to put the described job "%s" to the "%s" queue.' , $ jid , $ this -> name ) ) ; } $ jid = $ this -> client -> put ( '' , $ this -> name , $ jid , $ className , $ putData , is_null ( $ delay ) ? 0 : $ delay , 'priority' , is_null ( $ priority ) ? 0 : $ priority , 'tags' , json_encode ( $ tags ? : [ ] , JSON_UNESCAPED_SLASHES ) , 'retries' , is_null ( $ retries ) ? 5 : $ retries , 'depends' , json_encode ( $ depends ? : [ ] , JSON_UNESCAPED_SLASHES ) ) ; $ this -> getEventsManager ( ) -> fire ( new QueueEvent \ AfterEnqueue ( $ this , $ jid , $ data -> toArray ( ) , $ className ) ) ; return $ jid ; }
6787	protected function fixDefault ( CustomerGroupInterface $ customerGroup ) { if ( ! $ this -> persistenceHelper -> isChanged ( $ customerGroup , [ 'default' ] ) ) { return ; } if ( $ customerGroup -> isDefault ( ) ) { try { $ previousGroup = $ this -> customerGroupRepository -> findDefault ( ) ; } catch ( RuntimeException $ e ) { return ; } if ( $ previousGroup === $ customerGroup ) { return ; } $ previousGroup -> setDefault ( false ) ; $ this -> persistenceHelper -> persistAndRecompute ( $ previousGroup , false ) ; } }
11252	public function repositoryExists ( ) : bool { switch ( $ this -> pdo -> getAttribute ( PDO :: ATTR_DRIVER_NAME ) ) { case 'pgsql' : $ sql = 'select count(*) from information_schema.tables where table_schema = current_schema() and table_name = ?' ; break ; case 'mysql' : $ sql = 'select count(*) from information_schema.tables where table_schema = database() and table_name = ?' ; break ; case 'sqlsrv' : $ sql = "select count(*) from sysobjects where type = 'U' and name = ?" ; break ; case 'sqlite' : $ sql = "select count(*) from sqlite_master where type = 'table' and name = ?" ; break ; default : throw InvalidArgumentException :: forDatabaseNotSupported ( ) ; } $ stmt = $ this -> pdo -> prepare ( $ sql ) ; $ stmt -> bindParam ( 1 , $ this -> table ) ; $ stmt -> execute ( ) ; return $ stmt -> fetch ( PDO :: FETCH_COLUMN ) > 0 ; }
11731	protected function generateSlot ( $ path , $ blocks = array ( ) , $ username = null ) { if ( is_dir ( $ path ) && ! $ this -> override ) { return ; } $ folders = array ( ) ; $ activeDir = $ path . '/active' ; $ contributorsDir = $ path . '/contributors' ; $ folders [ ] = $ activeDir . '/blocks' ; $ folders [ ] = $ activeDir . '/archive' ; $ folders [ ] = $ contributorsDir ; $ targetDir = $ activeDir ; $ blocksDir = $ activeDir . '/blocks' ; if ( null !== $ username ) { $ targetDir = $ contributorsDir . '/' . $ username ; $ blocksDir = $ targetDir . '/blocks' ; $ folders [ ] = $ targetDir ; $ folders [ ] = $ targetDir . '/archive' ; $ folders [ ] = $ blocksDir ; } $ this -> filesystem -> mkdir ( $ folders ) ; $ this -> generateBlocks ( $ blocks , $ blocksDir , $ targetDir ) ; }
11823	public function replace ( $ middleware , $ with ) { $ this -> pipeline = $ this -> pipeline -> replace ( $ middleware , $ with ) ; return $ this ; }
11056	public function urlFunction ( $ route , array $ params = [ ] ) { return $ this -> container [ 'url_generator' ] -> generate ( $ route , $ params , UrlGeneratorInterface :: ABSOLUTE_URL ) ; }
7776	protected function getRuleArgs ( $ rule ) { if ( ! $ this -> ruleHasArgs ( $ rule ) ) { return [ ] ; } list ( $ ruleName , $ argsWithBracketAtTheEnd ) = explode ( '(' , $ rule ) ; $ args = rtrim ( $ argsWithBracketAtTheEnd , ')' ) ; $ args = preg_replace ( '/\s+/' , '' , $ args ) ; $ args = explode ( ',' , $ args ) ; return $ args ; }
10471	public function checkOutItem ( $ user_id , $ item_id ) { $ request = new CheckOutRequest ( $ this -> connector -> agency_id , $ user_id , $ item_id ) ; $ this -> emit ( 'request.checkout' , array ( $ user_id , $ item_id ) ) ; $ response = $ this -> post ( $ request ) ; return new CheckOutResponse ( $ response ) ; }
9605	public function vectorTripleProduct ( self $ b , self $ c ) { return $ this -> crossProduct ( $ b -> crossProduct ( $ c ) ) ; }
2109	public function getRelatedRecords ( ) { $ arrRelated = array ( ) ; $ objDatabase = Database :: getInstance ( ) ; $ objRelated = $ objDatabase -> prepare ( "SELECT * FROM tl_opt_in_related WHERE pid=?" ) -> execute ( $ this -> id ) ; while ( $ objRelated -> next ( ) ) { $ arrRelated [ $ objRelated -> relTable ] [ ] = $ objRelated -> relId ; } return $ arrRelated ; }
12743	public function buildSlotMap ( ) { $ this -> slotmap -> reset ( ) ; foreach ( $ this -> pool as $ connectionID => $ connection ) { $ parameters = $ connection -> getParameters ( ) ; if ( ! isset ( $ parameters -> slots ) ) { continue ; } foreach ( explode ( ',' , $ parameters -> slots ) as $ slotRange ) { $ slots = explode ( '-' , $ slotRange , 2 ) ; if ( ! isset ( $ slots [ 1 ] ) ) { $ slots [ 1 ] = $ slots [ 0 ] ; } $ this -> slotmap -> setSlots ( $ slots [ 0 ] , $ slots [ 1 ] , $ connectionID ) ; } } }
12451	static function run_check_php_files ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { $ opts = self :: getOpts ( @ $ args [ 0 ] , @ $ args [ 1 ] , $ cliopts ) ; if ( ! SharedLock :: acquire ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ) throw new PakeException ( "Source code locked by another process" ) ; $ destdir = self :: getBuildDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ; $ files = pakeFinder :: type ( 'file' ) -> name ( array ( '*.php' ) ) -> in ( $ destdir ) ; if ( count ( $ files ) ) { $ php = self :: getTool ( 'php' , $ opts ) ; if ( strpos ( pake_sh ( $ php . " -v" ) , 'PHP' ) === false ) { SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; throw new pakeException ( "$php does not seem to be a valid php executable" ) ; } foreach ( pakeFinder :: type ( 'file' ) -> name ( array ( '*.php' ) ) -> in ( $ destdir ) as $ file ) { if ( strpos ( pake_sh ( $ php . " -l " . escapeshellarg ( $ file ) ) , 'No syntax errors detected' ) === false ) { SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; throw new pakeException ( "$file does not seem to be a valid php file" ) ; } } } SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; }
1058	public static function findTypesRemovedFromUnions ( Schema $ oldSchema , Schema $ newSchema ) { $ oldTypeMap = $ oldSchema -> getTypeMap ( ) ; $ newTypeMap = $ newSchema -> getTypeMap ( ) ; $ typesRemovedFromUnion = [ ] ; foreach ( $ oldTypeMap as $ typeName => $ oldType ) { $ newType = $ newTypeMap [ $ typeName ] ?? null ; if ( ! ( $ oldType instanceof UnionType ) || ! ( $ newType instanceof UnionType ) ) { continue ; } $ typeNamesInNewUnion = [ ] ; foreach ( $ newType -> getTypes ( ) as $ type ) { $ typeNamesInNewUnion [ $ type -> name ] = true ; } foreach ( $ oldType -> getTypes ( ) as $ type ) { if ( isset ( $ typeNamesInNewUnion [ $ type -> name ] ) ) { continue ; } $ typesRemovedFromUnion [ ] = [ 'type' => self :: BREAKING_CHANGE_TYPE_REMOVED_FROM_UNION , 'description' => sprintf ( '%s was removed from union type %s.' , $ type -> name , $ typeName ) , ] ; } } return $ typesRemovedFromUnion ; }
709	public function string ( $ length = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_STRING , $ length ) ; }
2456	public function deleteAll ( ) { if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notDeletable' ] ) { throw new InternalServerErrorException ( 'Table "' . $ this -> strTable . '" is not deletable.' ) ; } $ objSession = System :: getContainer ( ) -> get ( 'session' ) ; $ session = $ objSession -> all ( ) ; $ ids = $ session [ 'CURRENT' ] [ 'IDS' ] ; if ( \ is_array ( $ ids ) && \ strlen ( $ ids [ 0 ] ) ) { foreach ( $ ids as $ id ) { $ this -> intId = $ id ; $ this -> delete ( true ) ; } } $ this -> redirect ( $ this -> getReferer ( ) ) ; }
6640	private function getContainerRoute ( array $ routes , $ name ) { foreach ( $ routes as $ route => $ names ) { if ( in_array ( $ name , $ names , false ) ) { return $ route ; } } throw new Exception ( "Unknown configuration class name '{$name}'" ) ; }
10128	private function writeBreaks ( ) { $ vbreaks = [ ] ; $ hbreaks = [ ] ; foreach ( $ this -> phpSheet -> getBreaks ( ) as $ cell => $ breakType ) { $ coordinates = Coordinate :: coordinateFromString ( $ cell ) ; switch ( $ breakType ) { case \ PhpOffice \ PhpSpreadsheet \ Worksheet \ Worksheet :: BREAK_COLUMN : $ vbreaks [ ] = Coordinate :: columnIndexFromString ( $ coordinates [ 0 ] ) - 1 ; break ; case \ PhpOffice \ PhpSpreadsheet \ Worksheet \ Worksheet :: BREAK_ROW : $ hbreaks [ ] = $ coordinates [ 1 ] ; break ; case \ PhpOffice \ PhpSpreadsheet \ Worksheet \ Worksheet :: BREAK_NONE : default : break ; } } if ( ! empty ( $ hbreaks ) ) { sort ( $ hbreaks , SORT_NUMERIC ) ; if ( $ hbreaks [ 0 ] == 0 ) { array_shift ( $ hbreaks ) ; } $ record = 0x001b ; $ cbrk = count ( $ hbreaks ) ; $ length = 2 + 6 * $ cbrk ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ cbrk ) ; foreach ( $ hbreaks as $ hbreak ) { $ data .= pack ( 'vvv' , $ hbreak , 0x0000 , 0x00ff ) ; } $ this -> append ( $ header . $ data ) ; } if ( ! empty ( $ vbreaks ) ) { $ vbreaks = array_slice ( $ vbreaks , 0 , 1000 ) ; sort ( $ vbreaks , SORT_NUMERIC ) ; if ( $ vbreaks [ 0 ] == 0 ) { array_shift ( $ vbreaks ) ; } $ record = 0x001a ; $ cbrk = count ( $ vbreaks ) ; $ length = 2 + 6 * $ cbrk ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ cbrk ) ; foreach ( $ vbreaks as $ vbreak ) { $ data .= pack ( 'vvv' , $ vbreak , 0x0000 , 0xffff ) ; } $ this -> append ( $ header . $ data ) ; } }
1585	public function withLinks ( $ links ) : self { $ copy = clone $ this ; $ copy -> links = collect ( $ links ) -> all ( ) ; return $ copy ; }
6303	protected function active ( array $ nav ) { foreach ( $ nav as $ key => $ value ) { if ( isset ( $ value [ 'slug' ] ) ) { if ( $ this -> request -> is ( $ value [ 'slug' ] ) || $ this -> request -> is ( $ value [ 'slug' ] . '/*' ) ) { $ nav [ $ key ] [ 'active' ] = true ; } else { $ nav [ $ key ] [ 'active' ] = false ; } } else { $ nav [ $ key ] [ 'active' ] = false ; } } return $ nav ; }
4486	public function broadcast ( Message $ message , ? string $ platform = null ) { if ( null !== $ platform && ! isset ( $ this -> arns [ $ platform ] ) ) { throw new PlatformNotConfiguredException ( "There is no configured ARN for $platform" ) ; } if ( $ platform ) { $ this -> broadcastToPlatform ( $ message , $ platform ) ; } else { foreach ( $ this -> arns as $ platform => $ arn ) { $ this -> broadcastToPlatform ( $ message , $ platform ) ; } } }
6920	static public function validateIdentity ( ExecutionContextInterface $ context , IdentityInterface $ identity , array $ config = [ ] , $ pathPrefix = null ) { $ violationList = $ context -> getValidator ( ) -> validate ( $ identity , [ new Identity ( $ config ) ] ) ; if ( ! empty ( $ pathPrefix ) ) { $ pathPrefix = rtrim ( $ pathPrefix , '.' ) . '.' ; } foreach ( $ violationList as $ violation ) { $ context -> buildViolation ( $ violation -> getMessage ( ) ) -> atPath ( $ pathPrefix . $ violation -> getPropertyPath ( ) ) -> addViolation ( ) ; } }
9826	private function writeRelationship ( XMLWriter $ objWriter , $ pId , $ pType , $ pTarget , $ pTargetMode = '' ) { if ( $ pType != '' && $ pTarget != '' ) { $ objWriter -> startElement ( 'Relationship' ) ; $ objWriter -> writeAttribute ( 'Id' , 'rId' . $ pId ) ; $ objWriter -> writeAttribute ( 'Type' , $ pType ) ; $ objWriter -> writeAttribute ( 'Target' , $ pTarget ) ; if ( $ pTargetMode != '' ) { $ objWriter -> writeAttribute ( 'TargetMode' , $ pTargetMode ) ; } $ objWriter -> endElement ( ) ; } else { throw new WriterException ( 'Invalid parameters passed.' ) ; } }
11496	public static function end ( ) { if ( self :: $ startTime ) { $ time = round ( ( microtime ( true ) - self :: $ startTime ) , 4 ) ; self :: $ startTime = false ; } return ( isset ( $ time ) ) ? $ time : false ; }
3310	public function getAccessToken ( $ forceRefresh = false ) { $ cacheKey = $ this -> getCacheKey ( ) ; $ cached = $ this -> getCache ( ) -> fetch ( $ cacheKey ) ; if ( empty ( $ cached ) || $ forceRefresh ) { $ token = $ this -> getTokenFormApi ( ) ; $ this -> getCache ( ) -> save ( $ cacheKey , $ token [ $ this -> tokenSucessKey ] , $ token [ 'expires_in' ] ) ; return $ token [ $ this -> tokenSucessKey ] ; } return $ cached ; }
1469	public static function httpErrorStatus ( $ errors , int $ default = SymfonyResponse :: HTTP_BAD_REQUEST ) : int { if ( $ errors instanceof ErrorInterface ) { $ errors = [ $ errors ] ; } $ statuses = collect ( $ errors ) -> reject ( function ( ErrorInterface $ error ) { return is_null ( $ error -> getStatus ( ) ) ; } ) -> map ( function ( ErrorInterface $ error ) { return ( int ) $ error -> getStatus ( ) ; } ) -> unique ( ) ; if ( 2 > count ( $ statuses ) ) { return $ statuses -> first ( ) ? : $ default ; } $ only4xx = $ statuses -> every ( function ( int $ status ) { return 400 <= $ status && 499 >= $ status ; } ) ; return $ only4xx ? SymfonyResponse :: HTTP_BAD_REQUEST : SymfonyResponse :: HTTP_INTERNAL_SERVER_ERROR ; }
9185	protected function toArray ( $ data , $ type , $ format ) { $ serializer = SerializerBuilder :: create ( ) -> build ( ) ; return $ serializer -> toArray ( $ serializer -> deserialize ( $ data , $ type , $ format ) ) ; }
4621	public function buildJsonObject ( $ data ) { $ this -> object = new RObject ( ) ; $ this -> object -> setData ( $ data ) ; $ this -> object -> setContentType ( Http :: CONTENT_TYPE_JSON ) ; return $ this ; }
6165	public function setOptions ( $ options ) { if ( is_array ( $ options ) ) { $ this -> options = $ options ; return $ this ; } $ this -> options = json_decode ( $ options , true ) ; if ( null === $ this -> options ) { $ this -> options = $ options ; } return $ this ; }
9486	protected function checkFieldsSet ( $ fields ) { foreach ( $ fields as $ field ) { if ( property_exists ( $ this , $ field ) && $ this -> $ field === null ) { throw new \ Exception ( "'$field' is required" ) ; } } }
8182	public function getDuration ( ) { if ( $ this -> isRoot ( ) && $ this -> profiles ) { $ duration = 0 ; foreach ( $ this -> profiles as $ profile ) { $ duration += $ profile -> getDuration ( ) ; } return $ duration ; } return isset ( $ this -> ends [ 'wt' ] ) && isset ( $ this -> starts [ 'wt' ] ) ? $ this -> ends [ 'wt' ] - $ this -> starts [ 'wt' ] : 0 ; }
12404	public function transaction ( ) { $ transaction_id = Parser :: beginTransaction ( $ this -> connection ) ; $ connection = clone $ this -> connection ; $ connection -> transactionId = $ transaction_id ; return new Service ( $ connection ) ; }
7523	function parse_tag_default ( ) { if ( $ this -> status [ 'closing_tag' ] ) { $ this -> status [ 'attributes' ] = array ( ) ; $ this -> next_no_whitespace ( ) ; } else { if ( ! $ this -> parse_attributes ( ) ) { return false ; } } if ( $ this -> token !== self :: TOK_TAG_CLOSE ) { if ( $ this -> token === self :: TOK_SLASH_FORWARD ) { $ this -> status [ 'self_close' ] = true ; $ this -> next ( ) ; } elseif ( ( ( $ this -> status [ 'tag_name' ] [ 0 ] === '?' ) && ( $ this -> doc [ $ this -> pos ] === '?' ) ) || ( ( $ this -> status [ 'tag_name' ] [ 0 ] === '%' ) && ( $ this -> doc [ $ this -> pos ] === '%' ) ) ) { $ this -> status [ 'self_close' ] = true ; $ this -> pos ++ ; if ( isset ( $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) && ( ! is_string ( $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ) ) { $ this -> token = $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ; } else { $ this -> token = self :: TOK_UNKNOWN ; } } } if ( $ this -> token !== self :: TOK_TAG_CLOSE ) { $ this -> addError ( 'Expected ">", but found "' . $ this -> getTokenString ( ) . '"' ) ; if ( $ this -> next_pos ( '>' , false ) !== self :: TOK_UNKNOWN ) { $ this -> addError ( 'No ">" tag found for "' . $ this -> status [ 'tag_name' ] . '" tag' ) ; return false ; } } return true ; }
10470	public function lookupUser ( $ user_id ) { $ request = new UserRequest ( $ user_id ) ; $ this -> emit ( 'request.user' , array ( $ user_id ) ) ; $ response = $ this -> post ( $ request ) ; return new UserResponse ( $ response ) ; }
2644	public function getCustomerInfo ( ) { $ uri = $ this -> config -> getApiEndpoint ( ) . 'current_customer' ; $ result = $ this -> _fetch ( $ uri ) ; return $ result ; }
6677	public static function toRelativeTime ( $ fromTime , $ toTime = 'now' , $ format = 'days' ) { $ startTime = new DateTime ( $ fromTime ) ; $ endTime = new DateTime ( $ toTime ) ; return $ startTime -> diff ( $ endTime ) -> $ format ; }
338	protected function extractColumnSize ( $ column , $ dbType , $ precision , $ scale , $ length ) { $ column -> size = trim ( $ length ) === '' ? null : ( int ) $ length ; $ column -> precision = trim ( $ precision ) === '' ? null : ( int ) $ precision ; $ column -> scale = trim ( $ scale ) === '' ? null : ( int ) $ scale ; }
9409	protected function transform ( $ middleware , $ wrappable = true ) { if ( is_a ( $ middleware , Application :: MIDDLEWARE ) === false ) { $ approach = ( boolean ) $ this -> approach ( $ middleware ) ; $ response = $ approach === self :: SINGLE_PASS ? $ this -> response : null ; $ wrapper = new CallableMiddlewareWrapper ( $ middleware , $ response ) ; $ middleware = $ wrappable === true ? $ wrapper : $ middleware ; } return $ middleware ; }
11565	private function getApp ( ) { if ( is_null ( $ this -> app ) ) { $ this -> app = \ Concrete \ Core \ Support \ Facade \ Application :: getFacadeApplication ( ) ; } return $ this -> app ; }
1295	public function has ( string $ name , string $ locale = null , bool $ checkLinksAreResolved = true ) : bool { $ field = $ this -> sys -> getContentType ( ) -> getField ( $ name , true ) ; if ( ! $ field ) { return false ; } if ( ! \ array_key_exists ( $ field -> getId ( ) , $ this -> fields ) ) { return false ; } try { $ result = $ this -> getUnresolvedField ( $ field , $ locale ) ; if ( $ checkLinksAreResolved ) { $ this -> resolveFieldLinks ( $ result , $ locale ) ; } } catch ( \ Exception $ exception ) { return false ; } return true ; }
9148	public function markAsRead ( $ uid ) { if ( ! $ object = $ this -> model -> find ( $ uid ) ) { abort ( 404 ) ; } $ this -> authorize ( 'update' , $ object ) ; $ object -> markAsRead ( ) ; \ Cache :: tags ( 'response' ) -> flush ( ) ; return $ this -> successJsonResponse ( ) ; }
5735	public function getMatchesForTeam ( int $ teamID , array $ filter = [ 'dateFrom' => '' , 'dateTo' => '' , 'status' => '' , 'venue' => '' ] ) { $ matches = $ this -> run ( "v2/teams/{$teamID}/matches" . "?" . http_build_query ( $ filter ) ) ; return collect ( $ matches -> matches ) ; }
908	private function isShortArray ( Tokens $ tokens , $ index ) { if ( ! $ tokens [ $ index ] -> equals ( '[' ) ) { return false ; } static $ disallowedPrevTokens = [ ')' , ']' , '}' , '"' , [ T_CONSTANT_ENCAPSED_STRING ] , [ T_STRING ] , [ T_STRING_VARNAME ] , [ T_VARIABLE ] , [ CT :: T_ARRAY_SQUARE_BRACE_CLOSE ] , [ CT :: T_DYNAMIC_PROP_BRACE_CLOSE ] , [ CT :: T_DYNAMIC_VAR_BRACE_CLOSE ] , [ CT :: T_ARRAY_INDEX_CURLY_BRACE_CLOSE ] , ] ; $ prevToken = $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ index ) ] ; if ( $ prevToken -> equalsAny ( $ disallowedPrevTokens ) ) { return false ; } $ nextToken = $ tokens [ $ tokens -> getNextMeaningfulToken ( $ index ) ] ; if ( $ nextToken -> equals ( ']' ) ) { return true ; } return ! $ this -> isArrayDestructing ( $ tokens , $ index ) ; }
7561	protected function parse_sibling ( ) { if ( ( ( $ this -> pos + 1 ) < $ this -> size ) && ( $ this -> doc [ $ this -> pos + 1 ] === '=' ) ) { ++ $ this -> pos ; return ( $ this -> token = self :: TOK_COMPARE_CONTAINS_WORD ) ; } else { return ( $ this -> token = self :: TOK_SIBLING ) ; } }
571	public function generatePasswordHash ( $ password , $ cost = null ) { if ( $ cost === null ) { $ cost = $ this -> passwordHashCost ; } if ( function_exists ( 'password_hash' ) ) { return password_hash ( $ password , PASSWORD_DEFAULT , [ 'cost' => $ cost ] ) ; } $ salt = $ this -> generateSalt ( $ cost ) ; $ hash = crypt ( $ password , $ salt ) ; if ( ! is_string ( $ hash ) || strlen ( $ hash ) !== 60 ) { throw new Exception ( 'Unknown error occurred while generating hash.' ) ; } return $ hash ; }
4188	public function boot ( Factory $ validator ) { $ passwordStrength = app ( 'passwordStrength' ) ; $ translator = app ( 'passwordStrength.translationProvider' ) -> get ( $ validator ) ; foreach ( [ 'letters' , 'numbers' , 'caseDiff' , 'symbols' ] as $ rule ) { $ snakeCasedRule = snake_case ( $ rule ) ; $ validator -> extend ( $ rule , function ( $ _ , $ value , $ __ ) use ( $ passwordStrength , $ rule ) { $ capitalizedRule = ucfirst ( $ rule ) ; return call_user_func ( [ $ passwordStrength , "validate{$capitalizedRule}" ] , $ value ) ; } , $ translator -> get ( "password-strength::validation.{$snakeCasedRule}" ) ) ; } }
11594	public function postAction ( ) { $ request = $ this -> environment -> getRequestHelper ( ) ; $ id = $ request -> getIdentifierParam ( 'name' ) ; try { $ this -> pageList -> getPage ( $ id ) ; } catch ( InvalidParameterException $ e ) { $ page = $ this -> pageList -> addPageFromRequest ( $ id , $ request ) ; $ this -> environment -> sendJSONResult ( $ page -> getJSON ( ) ) ; return ; } throw new InvalidParameterException ( "Page already exists" ) ; }
5413	protected function createSocket ( $ scheme , $ host , $ port , $ timeout ) { if ( in_array ( $ scheme , array ( 'file' ) ) ) { return new SimpleFileSocket ( $ this -> url ) ; } elseif ( in_array ( $ scheme , array ( 'https' ) ) ) { return new SimpleSecureSocket ( $ host , $ port , $ timeout ) ; } else { return new SimpleSocket ( $ host , $ port , $ timeout ) ; } }
4190	protected function dumpMethods ( $ methods ) { $ label = \ count ( $ methods ) ? 'methods' : 'no methods' ; $ str = '<dt class="methods">' . $ label . '</dt>' . "\n" ; $ magicMethods = \ array_intersect ( array ( '__call' , '__callStatic' ) , \ array_keys ( $ methods ) ) ; $ str .= $ this -> magicMethodInfo ( $ magicMethods ) ; foreach ( $ methods as $ methodName => $ info ) { if ( ! isset ( $ info [ 'phpDoc' ] [ 'return' ] ) ) { $ info [ 'phpDoc' ] [ 'return' ] = array ( 'desc' => null , 'type' => null , ) ; } $ classes = \ array_keys ( \ array_filter ( array ( 'method' => true , 'deprecated' => $ info [ 'isDeprecated' ] , ) ) ) ; $ modifiers = \ array_keys ( \ array_filter ( array ( 'final' => $ info [ 'isFinal' ] , $ info [ 'visibility' ] => true , 'static' => $ info [ 'isStatic' ] , ) ) ) ; $ str .= $ this -> debug -> utilities -> buildTag ( 'dd' , array ( 'class' => \ array_merge ( $ classes , $ modifiers ) , 'data-implements' => $ info [ 'implements' ] , ) , \ implode ( ' ' , \ array_map ( function ( $ modifier ) { return '<span class="t_modifier_' . $ modifier . '">' . $ modifier . '</span>' ; } , $ modifiers ) ) . ' ' . $ this -> debug -> utilities -> buildTag ( 'span' , array ( 'class' => 't_type' , 'title' => $ info [ 'phpDoc' ] [ 'return' ] [ 'desc' ] , ) , $ info [ 'phpDoc' ] [ 'return' ] [ 'type' ] ) . ' ' . $ this -> debug -> utilities -> buildTag ( 'span' , array ( 'class' => 'method-name' , 'title' => \ trim ( $ info [ 'phpDoc' ] [ 'summary' ] . ( $ this -> debug -> output -> getCfg ( 'outputMethodDescription' ) ? "\n\n" . $ info [ 'phpDoc' ] [ 'description' ] : '' ) ) , ) , $ methodName ) . '<span class="t_punct">(</span>' . $ this -> dumpMethodParams ( $ info [ 'params' ] ) . '<span class="t_punct">)</span>' . ( $ methodName == '__toString' ? '<br />' . $ this -> debug -> output -> html -> dump ( $ info [ 'returnValue' ] ) : '' ) ) . "\n" ; } $ str = \ str_replace ( ' data-implements="null"' , '' , $ str ) ; $ str = \ str_replace ( ' <span class="t_type"></span>' , '' , $ str ) ; return $ str ; }
3613	public function setTargetTemperature ( $ temperature , $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ temperature = $ this -> temperatureInCelsius ( $ temperature , $ serial_number ) ; $ data = json_encode ( array ( 'target_change_pending' => TRUE , 'target_temperature' => $ temperature ) ) ; return $ this -> doPOST ( "/v2/put/shared." . $ serial_number , $ data ) ; }
9772	function property ( string $ name , $ value = null ) : self { $ isArray = is_array ( $ this -> target ) || $ this -> target instanceof \ ArrayAccess ; if ( ! $ isArray && ! is_object ( $ this -> target ) ) throw new \ BadMethodCallException ( 'The target is not an array nor an object.' ) ; $ hasProperty = $ isArray ? array_key_exists ( $ name , $ this -> target ) : property_exists ( $ this -> target , $ name ) ; $ hasPropertyConstraint = $ isArray ? arrayHasKey ( $ name ) : objectHasAttribute ( $ name ) ; $ property = $ isArray ? ( $ this -> target [ $ name ] ?? null ) : ( $ this -> target -> $ name ?? null ) ; if ( ! $ hasProperty || $ value === null ) $ this -> expect ( $ this -> target , $ hasPropertyConstraint ) ; else { assertThat ( $ this -> target , $ hasPropertyConstraint ) ; $ this -> expect ( $ property , equalTo ( $ value ) ) ; } $ this -> target = $ property ; return $ this ; }
1760	public static function anonymizeIp ( $ strIp ) { if ( $ strIp == '127.0.0.1' || $ strIp == '::1' ) { return $ strIp ; } if ( strpos ( $ strIp , ':' ) !== false ) { return substr_replace ( $ strIp , ':0000' , strrpos ( $ strIp , ':' ) ) ; } else { return substr_replace ( $ strIp , '.0' , strrpos ( $ strIp , '.' ) ) ; } }
9334	public function deg ( ) { if ( $ this -> original -> type == self :: TYPE_DEG ) { return $ this -> original -> value ; } return rad2deg ( $ this -> float_rad ) ; }
2872	public function init ( Mage_Core_Model_Abstract $ model ) { $ this -> class = get_class ( $ model ) ; $ this -> resource = $ model -> getResourceName ( ) ; $ this -> count = 0 ; }
10516	protected function createPhotosCollection ( Product $ product , $ values ) { $ photos = new ArrayCollection ( ) ; $ identifiers = $ this -> getMediaIdentifiers ( $ values ) ; $ hierarchy = 0 ; foreach ( $ identifiers as $ id ) { $ media = $ this -> getMediaById ( $ id ) ; $ photo = $ this -> getProductPhoto ( $ media , $ product , $ values ) ; $ photo -> setHierarchy ( $ hierarchy ++ ) ; if ( ! $ photos -> contains ( $ photo ) ) { $ photos -> add ( $ photo ) ; } } return $ photos ; }
715	public function double ( $ precision = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_DOUBLE , $ precision ) ; }
8913	protected function _set_where ( $ params ) { if ( count ( $ params ) == 1 ) { $ this -> _database -> where ( $ params [ 0 ] ) ; } else if ( count ( $ params ) == 2 ) { $ this -> _database -> where ( $ params [ 0 ] , $ params [ 1 ] ) ; } else if ( count ( $ params ) == 3 ) { $ this -> _database -> where ( $ params [ 0 ] , $ params [ 1 ] , $ params [ 2 ] ) ; } else { $ this -> _database -> where ( $ params ) ; } }
3471	public function merge ( Config $ config ) : Config { $ this -> config = array_merge_recursive ( $ this -> config , $ config -> config ) ; return $ this ; }
2782	public function renderShadowMark ( $ count , $ current , $ eolInterval = 60 ) { $ this -> progressCount ++ ; $ this -> write ( '<fg=blue;options=bold>S</fg=blue;options=bold>' , false ) ; if ( ( $ this -> progressCount % $ eolInterval ) == 0 ) { $ counter = str_pad ( $ this -> progressCount , 5 , ' ' , STR_PAD_LEFT ) ; $ this -> write ( ' |' . $ counter . ' (' . str_pad ( $ current , strlen ( $ count ) , ' ' , STR_PAD_LEFT ) . '/' . $ count . ')' . PHP_EOL , false ) ; } }
7852	protected function dispatchWorkflow ( $ workflow ) { $ job = $ this -> inflector -> getJob ( ) ; $ request = $ this -> resolveRequest ( ) ; $ pipes = $ this -> pipelines -> getPipesByPipeline ( $ workflow ) ; $ parameters = $ this -> container -> make ( 'router' ) -> current ( ) -> parameters ( ) ; return $ this -> dispatcher -> pipeThrough ( $ pipes ) -> dispatchFrom ( $ job , $ request , $ parameters ) ; }
4936	protected function getEntities ( $ args ) { $ dm = $ args -> getDocumentManager ( ) ; $ resource = $ args -> getDocument ( ) ; $ repositoryName = $ this -> getRepositoryName ( ) ; $ resourceId = $ resource -> getPermissionsResourceId ( ) ; $ repository = $ dm -> getRepository ( $ repositoryName ) ; $ criteria = array ( 'permissions.assigned.' . $ resourceId => array ( '$exists' => true ) ) ; $ entities = $ repository -> findBy ( $ criteria ) ; return $ entities ; }
5178	public function filter ( \ Closure $ callback ) : self { $ collection = new static ( ) ; foreach ( $ this -> props as $ key => $ value ) { if ( $ callback ( $ value , $ key ) ) { $ collection -> add ( $ key , $ value ) ; } } return $ collection ; }
1198	protected function escape ( $ value ) { return $ this -> fixDoubleEscape ( htmlspecialchars ( ( string ) $ value , ENT_QUOTES | ENT_SUBSTITUTE , $ this -> charset ) ) ; }
10062	public function update ( $ key , $ value ) { try { $ meta = $ this -> metaModel :: where ( 'key' , $ key ) -> firstOrFail ( ) ; } catch ( \ Exception $ e ) { $ message = "Can't update meta (key: $key). " ; $ message .= "Meta doesn't exist" ; throw new \ Exception ( $ message ) ; } $ meta -> value = $ value ; $ meta -> save ( ) ; }
3330	public function fromPath ( $ path , $ mime_type = false ) { if ( function_exists ( 'curl_file_create' ) ) { if ( $ mime_type ) { $ f = curl_file_create ( $ path , $ mime_type ) ; } else { $ f = curl_file_create ( $ path ) ; } } else { if ( $ mime_type ) { $ f = '@' . $ path . ';type=' . $ mime_type ; } else { $ f = '@' . $ path ; } } $ data = array ( 'UPLOADCARE_PUB_KEY' => $ this -> api -> getPublicKey ( ) , 'file' => $ f , ) ; $ ch = $ this -> __initRequest ( 'base' ) ; $ this -> __setRequestType ( $ ch ) ; $ this -> __setData ( $ ch , $ data ) ; $ this -> __setHeaders ( $ ch ) ; $ data = $ this -> __runRequest ( $ ch ) ; $ uuid = $ data -> file ; return new File ( $ uuid , $ this -> api ) ; }
3619	public function cancelFanModeOnWithTimer ( $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ data = json_encode ( array ( 'fan_timer_timeout' => 0 ) ) ; return $ this -> doPOST ( "/v2/put/device." . $ serial_number , $ data ) ; }
2033	public static function findWithDetails ( $ intId ) { $ objPage = static :: findByPk ( $ intId ) ; if ( $ objPage === null ) { return null ; } return $ objPage -> loadDetails ( ) ; }
1066	private function doTypesConflict ( OutputType $ type1 , OutputType $ type2 ) { if ( $ type1 instanceof ListOfType ) { return $ type2 instanceof ListOfType ? $ this -> doTypesConflict ( $ type1 -> getWrappedType ( ) , $ type2 -> getWrappedType ( ) ) : true ; } if ( $ type2 instanceof ListOfType ) { return $ type1 instanceof ListOfType ? $ this -> doTypesConflict ( $ type1 -> getWrappedType ( ) , $ type2 -> getWrappedType ( ) ) : true ; } if ( $ type1 instanceof NonNull ) { return $ type2 instanceof NonNull ? $ this -> doTypesConflict ( $ type1 -> getWrappedType ( ) , $ type2 -> getWrappedType ( ) ) : true ; } if ( $ type2 instanceof NonNull ) { return $ type1 instanceof NonNull ? $ this -> doTypesConflict ( $ type1 -> getWrappedType ( ) , $ type2 -> getWrappedType ( ) ) : true ; } if ( Type :: isLeafType ( $ type1 ) || Type :: isLeafType ( $ type2 ) ) { return $ type1 !== $ type2 ; } return false ; }
3372	private function getFormFactory ( ContainerInterface $ services ) { $ elements = null ; if ( $ services -> has ( 'FormElementManager' ) ) { $ elements = $ services -> get ( 'FormElementManager' ) ; } return new Factory ( $ elements ) ; }
3450	public function getDirectChildren ( array $ filter = [ ] ) { return static :: query ( ) -> filter ( $ filter ) -> filter ( [ 'SECTION_ID' => $ this -> id ] ) -> select ( 'ID' ) -> getList ( ) -> transform ( function ( $ section ) { return ( int ) $ section [ 'ID' ] ; } ) -> all ( ) ; }
12096	public function generateSignCode ( array $ params , $ secret ) { ksort ( $ params ) ; if ( isset ( $ params [ self :: SIGN_NAMESPACE ] ) ) { unset ( $ params [ self :: SIGN_NAMESPACE ] ) ; } return md5 ( implode ( '' , $ params ) . $ secret ) ; }
3901	public function createColumn ( ) { if ( $ this -> getColName ( ) ) { $ this -> tableManipulator -> createColumn ( $ this -> getMetaModel ( ) -> getTableName ( ) , $ this -> getColName ( ) , $ this -> getSQLDataType ( ) ) ; } }
505	public function init ( ) { parent :: init ( ) ; if ( ! isset ( $ this -> translations [ 'yii' ] ) && ! isset ( $ this -> translations [ 'yii*' ] ) ) { $ this -> translations [ 'yii' ] = [ 'class' => 'yii\i18n\PhpMessageSource' , 'sourceLanguage' => 'en-US' , 'basePath' => '@yii/messages' , ] ; } if ( ! isset ( $ this -> translations [ 'app' ] ) && ! isset ( $ this -> translations [ 'app*' ] ) ) { $ this -> translations [ 'app' ] = [ 'class' => 'yii\i18n\PhpMessageSource' , 'sourceLanguage' => Yii :: $ app -> sourceLanguage , 'basePath' => '@app/messages' , ] ; } }
10967	public static function isSsl ( ) { $ isSecure = false ; if ( isset ( $ _SERVER [ 'HTTPS' ] ) && in_array ( $ _SERVER [ 'HTTPS' ] , [ 'on' , '1' ] ) ) { $ isSecure = true ; } elseif ( isset ( $ _SERVER [ 'HTTP_X_FORWARDED_PROTO' ] ) && $ _SERVER [ 'HTTP_X_FORWARDED_PROTO' ] == 'https' ) { $ isSecure = true ; } elseif ( isset ( $ _SERVER [ 'HTTP_X_FORWARDED_SSL' ] ) && $ _SERVER [ 'HTTP_X_FORWARDED_SSL' ] == 'on' ) { $ isSecure = true ; } return $ isSecure ; }
1647	public function calculateBearing ( Coordinate $ point1 , Coordinate $ point2 ) : float { $ lat1 = deg2rad ( $ point1 -> getLat ( ) ) ; $ lat2 = deg2rad ( $ point2 -> getLat ( ) ) ; $ lng1 = deg2rad ( $ point1 -> getLng ( ) ) ; $ lng2 = deg2rad ( $ point2 -> getLng ( ) ) ; $ y = sin ( $ lng2 - $ lng1 ) * cos ( $ lat2 ) ; $ x = cos ( $ lat1 ) * sin ( $ lat2 ) - sin ( $ lat1 ) * cos ( $ lat2 ) * cos ( $ lng2 - $ lng1 ) ; $ bearing = rad2deg ( atan2 ( $ y , $ x ) ) ; if ( $ bearing < 0 ) { $ bearing = fmod ( $ bearing + 360 , 360 ) ; } return $ bearing ; }
10477	protected function displayExceptions ( Exception $ e ) { $ this -> display [ ] = 'Cerbero\Auth\Exceptions\DisplayException' ; foreach ( $ this -> display as $ exception ) { if ( $ e instanceof $ exception ) { return back ( ) -> withInput ( ) -> withError ( $ e -> getMessage ( ) ) ; } } }
4028	protected function getLabelImage ( ModelInterface $ model ) { $ typeFactory = $ this -> factory -> getTypeFactory ( $ model -> getProperty ( 'type' ) ) ; $ image = $ this -> iconBuilder -> getBackendIconImageTag ( $ this -> updateImageWithDisabled ( $ model , $ typeFactory -> getTypeIcon ( ) ) , '' , '' , $ this -> updateImageWithDisabled ( $ model , 'bundles/metamodelscore/images/icons/filter_default.png' ) ) ; $ urlEvent = $ this -> dispatcher -> dispatch ( ContaoEvents :: BACKEND_ADD_TO_URL , new AddToUrlEvent ( 'act=edit&amp;id=' . $ model -> getId ( ) ) ) ; return sprintf ( '<a href="%s">%s</a>' , $ urlEvent -> getUrl ( ) , $ image ) ; }
10783	public function orHaving ( $ column , $ op , $ value , $ isParam = true ) { $ this -> clauses [ ] = array ( "OR" , $ column , $ op , $ value , $ isParam ) ; return $ this ; }
8845	public function build ( ContainerBuilder $ container ) { $ container -> addCompilerPass ( new ThemeCompilerPass ( ) , PassConfig :: TYPE_BEFORE_OPTIMIZATION , - 10 ) ; $ container -> addCompilerPass ( new ThemeProviderPass ( ) ) ; }
10893	public function add ( $ name , UriInterface $ uri ) { unset ( $ this -> uris [ $ name ] ) ; $ this -> uris [ $ name ] = $ uri ; }
4206	private function getPropInfo ( Event $ abs , \ ReflectionProperty $ reflectionProperty ) { $ obj = $ abs -> getSubject ( ) ; $ reflectionProperty -> setAccessible ( true ) ; $ className = \ get_class ( $ obj ) ; $ commentInfo = $ this -> getPropCommentInfo ( $ reflectionProperty ) ; $ declaringClassName = $ reflectionProperty -> getDeclaringClass ( ) -> getName ( ) ; $ propInfo = \ array_merge ( static :: $ basePropInfo , array ( 'desc' => $ commentInfo [ 'desc' ] , 'inheritedFrom' => $ declaringClassName !== $ className ? $ declaringClassName : null , 'isStatic' => $ reflectionProperty -> isStatic ( ) , 'type' => $ commentInfo [ 'type' ] , ) ) ; if ( $ reflectionProperty -> isPrivate ( ) ) { $ propInfo [ 'visibility' ] = 'private' ; } elseif ( $ reflectionProperty -> isProtected ( ) ) { $ propInfo [ 'visibility' ] = 'protected' ; } if ( $ abs [ 'collectPropertyValues' ] ) { $ propName = $ reflectionProperty -> getName ( ) ; if ( \ array_key_exists ( $ propName , $ abs [ 'propertyOverrideValues' ] ) ) { $ propInfo [ 'value' ] = $ abs [ 'propertyOverrideValues' ] [ $ propName ] ; $ propInfo [ 'valueFrom' ] = 'debug' ; } else { $ propInfo [ 'value' ] = $ reflectionProperty -> getValue ( $ obj ) ; } } return $ propInfo ; }
10338	function toXML ( ) { $ xml = new SimpleXMLElement ( "<?xml version=\"1.0\"?><property></property>" ) ; $ xml -> addChild ( "key" , $ this -> key ) ; $ xml -> addChild ( "value" , $ this -> value ) ; return $ xml ; }
7407	public function serialize ( ) : string { return serialize ( [ '_type' => $ this -> _type , '_arrayOptions' => $ this -> _arrayOptions , '_jsonOptions' => $ this -> _jsonOptions , '_container' => $ this -> _container , ] ) ; }
11450	public function getParentUri ( ) { if ( $ this -> getParentName ( ) ) { $ func = $ this -> getParentName ( ) ; if ( ! is_string ( $ func ) ) { return ; } $ relat = $ this -> $ func ( ) ; $ parentResourceName = $ relat -> getRelated ( ) -> getResourceName ( ) ; $ field = $ relat -> getForeignKey ( ) ; if ( ! $ this -> $ field ) { return Api :: url ( ) ; } return Api :: url ( ) . '/' . $ parentResourceName . '/' . Api :: encodeHashId ( $ this -> $ field ) ; } return Api :: url ( ) ; }
12213	public function getMiddleware ( $ name , $ arguments = null ) { if ( $ this -> existsMiddleware ( $ name ) ) { return $ this -> middlewares [ $ name ] ( ) ; } return false ; }
3666	public function convertParameter ( $ arrMatch ) { list ( $ strSource , $ strQuery ) = explode ( '?' , $ arrMatch [ 1 ] , 2 ) ; parse_str ( $ strQuery , $ arrArgs ) ; $ arrName = ( array ) $ arrArgs [ 'name' ] ; $ var = $ this -> getValueFromSource ( $ strSource , array_shift ( $ arrName ) , $ arrArgs ) ; $ index = 0 ; $ count = count ( $ arrName ) ; while ( $ index < $ count && is_array ( $ var ) ) { $ var = $ var [ $ arrName [ $ index ++ ] ] ; } if ( $ index != $ count || $ var === null ) { if ( array_key_exists ( 'default' , $ arrArgs ) && ( null !== $ arrArgs [ 'default' ] ) ) { $ this -> addParameter ( $ arrArgs [ 'default' ] ) ; return '?' ; } else { return 'NULL' ; } } if ( ! isset ( $ arrArgs [ 'aggregate' ] ) ) { $ this -> addParameter ( $ var ) ; return '?' ; } return $ this -> convertParameterAggregate ( $ var , $ arrArgs ) ; }
7019	private function formatH ( & $ str ) { if ( strstr ( $ str , '%H' ) ) $ str = str_replace ( '%H' , sprintf ( '%02d' , $ this -> hour ) , $ str ) ; }
12484	protected function getDefaultOptionIds ( ) { $ optionIds = [ ] ; $ defaultDefinition = $ this -> getDefaultInputDefinition ( ) ; foreach ( $ defaultDefinition -> getOptions ( ) as $ option ) { $ optionIds [ ] = $ option -> getName ( ) ; } ; return $ optionIds ; }
10137	private function writeMsoDrawing ( ) { if ( isset ( $ this -> escher ) ) { $ writer = new Escher ( $ this -> escher ) ; $ data = $ writer -> close ( ) ; $ spOffsets = $ writer -> getSpOffsets ( ) ; $ spTypes = $ writer -> getSpTypes ( ) ; $ spOffsets [ 0 ] = 0 ; $ nm = count ( $ spOffsets ) - 1 ; for ( $ i = 1 ; $ i <= $ nm ; ++ $ i ) { $ record = 0x00EC ; $ dataChunk = substr ( $ data , $ spOffsets [ $ i - 1 ] , $ spOffsets [ $ i ] - $ spOffsets [ $ i - 1 ] ) ; $ length = strlen ( $ dataChunk ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ this -> append ( $ header . $ dataChunk ) ; $ record = 0x005D ; $ objData = '' ; if ( $ spTypes [ $ i ] == 0x00C9 ) { $ objData .= pack ( 'vvvvvVVV' , 0x0015 , 0x0012 , 0x0014 , $ i , 0x2101 , 0 , 0 , 0 ) ; $ objData .= pack ( 'vv' , 0x00C , 0x0014 ) ; $ objData .= pack ( 'H*' , '0000000000000000640001000A00000010000100' ) ; $ objData .= pack ( 'vv' , 0x0013 , 0x1FEE ) ; $ objData .= pack ( 'H*' , '00000000010001030000020008005700' ) ; } else { $ objData .= pack ( 'vvvvvVVV' , 0x0015 , 0x0012 , 0x0008 , $ i , 0x6011 , 0 , 0 , 0 ) ; } $ objData .= pack ( 'vv' , 0x0000 , 0x0000 ) ; $ length = strlen ( $ objData ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ this -> append ( $ header . $ objData ) ; } } }
8349	public static function toArray ( ) : array { if ( static :: $ array == null ) { $ ref = new \ ReflectionClass ( static :: class ) ; $ consts = $ ref -> getConstants ( ) ; static :: $ array = array ( ) ; foreach ( $ consts as $ key => $ value ) { if ( stripos ( $ key , 'VALUE_' ) === 0 ) { static :: $ array [ $ key ] = $ value ; } } } return static :: $ array ; }
4949	public function createQueryBuilder ( $ findDrafts = false ) { $ qb = parent :: createQueryBuilder ( ) ; if ( null !== $ findDrafts ) { $ qb -> field ( 'isDraft' ) -> equals ( $ findDrafts ) ; } return $ qb ; }
12728	public function expectsOutcome ( IOutcomeRule $ rule , IOutcomeRule $ rule2 = null , IOutcomeRule $ rule3 = null , IOutcomeRule $ rule4 = null , IOutcomeRule $ rule5 = null , IOutcomeRule $ rule6 = null , IOutcomeRule $ rule7 = null , IOutcomeRule $ rule8 = null , IOutcomeRule $ rule9 = null , IOutcomeRule $ rule10 = null ) { foreach ( func_get_args ( ) as $ arg ) { if ( $ arg instanceof IInputRule ) { $ this -> outcomeRules [ ] = $ arg ; } } return $ this ; }
5271	private function translateDelete ( ) { $ build = array ( "delete from {$this->table}" ) ; if ( ! empty ( $ this -> statements [ 'wheres' ] ) ) { $ build [ ] = join ( ' ' , $ this -> statements [ 'wheres' ] ) ; } if ( ! empty ( $ this -> limit ) ) { $ build [ ] = $ this -> limit ; } return join ( ' ' , $ build ) ; }
6987	protected function fillFromCustomer ( ContextInterface $ context , CustomerInterface $ customer ) : void { if ( null === $ context -> getCustomerGroup ( ) ) { $ context -> setCustomerGroup ( $ customer -> getCustomerGroup ( ) ) ; } if ( null === $ context -> getInvoiceCountry ( ) ) { if ( null !== $ address = $ customer -> getDefaultInvoiceAddress ( true ) ) { $ context -> setInvoiceCountry ( $ address -> getCountry ( ) ) ; } } if ( null === $ context -> getDeliveryCountry ( ) ) { if ( null !== $ address = $ customer -> getDefaultDeliveryAddress ( true ) ) { $ context -> setDeliveryCountry ( $ address -> getCountry ( ) ) ; } } }
4838	public function new_limit_url ( $ type , $ params ) { $ request = array ( ) ; $ params [ 'merchant_id' ] = $ this -> account_details [ 'merchant_id' ] ; $ opt_params = array ( 'redirect_uri' , 'cancel_uri' , 'state' ) ; foreach ( $ opt_params as $ opt_param ) { if ( isset ( $ params [ $ opt_param ] ) ) { $ request [ $ opt_param ] = $ params [ $ opt_param ] ; unset ( $ params [ $ opt_param ] ) ; } } if ( ! isset ( $ request [ 'redirect_uri' ] ) && isset ( $ this -> redirect_uri ) ) { $ request [ 'redirect_uri' ] = $ this -> redirect_uri ; } $ payment_params = array ( $ type => $ params ) ; $ request = array_merge ( $ request , $ payment_params , $ this -> generate_mandatory_params ( ) ) ; $ request [ 'signature' ] = GoCardless_Utils :: generate_signature ( $ request , $ this -> account_details [ 'app_secret' ] ) ; $ query_string = GoCardless_Utils :: generate_query_string ( $ request ) ; return $ this -> base_url . '/connect/' . $ type . 's/new?' . $ query_string ; }
7988	public function deleteSnapshot ( $ domain ) { $ domain = ( string ) $ domain ; if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; try { $ r = $ this -> delete ( 'vps/' . $ domain . '/snapshot' ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new VpsException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r ; }
6001	public function addImageTemplate ( $ item ) { if ( ! ( $ item instanceof ImageTemplate ) ) { if ( is_array ( $ item ) ) { try { $ item = new ImageTemplate ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate ImageTemplate. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "ImageTemplate"!' , E_USER_WARNING ) ; } } $ this -> imagetemplates [ ] = $ item ; return $ this ; }
4923	public function removeTypeFromRegion ( $ type , $ region ) { if ( array_key_exists ( $ region , $ this -> matrix ) ) { array_walk ( $ this -> matrix [ $ region ] , function ( $ value , $ idx , $ matrix ) use ( $ type , $ region ) { $ class = explode ( '\\' , $ value ) ; $ className = array_pop ( $ class ) ; if ( $ className === $ type ) { unset ( $ matrix [ $ region ] [ $ idx ] ) ; } } , $ this -> matrix ) ; } return $ this ; }
10806	protected function getConfig ( ) { $ config = array_replace ( $ this -> config , $ this -> dialect_config ) ; ksort ( $ config ) ; return $ config ; }
12196	public static function current ( ) { if ( defined ( 'PHPUNIT_RUNNING' ) ) { return 'http://localhost' ; } $ protocol = 'http://' ; if ( ! empty ( $ _SERVER [ 'HTTPS' ] ) || ( ! empty ( $ _SERVER [ 'HTTP_X_FORWARDED_PROTO' ] ) && $ _SERVER [ 'HTTP_X_FORWARDED_PROTO' ] === 'https' ) ) { $ protocol = 'https://' ; } return $ protocol . request ( ) -> server ( 'HTTP_HOST' ) . request ( ) -> server ( 'REQUEST_URI' ) ; }
3029	public function setToken ( $ token , $ secret ) { $ this -> token = new \ Eher \ OAuth \ Token ( $ token , $ secret ) ; }
1240	private static function propertyToXml ( $ name , $ value ) { if ( is_subclass_of ( $ value , '\DTS\eBaySDK\Types\BaseType' , false ) ) { return $ value -> toXml ( $ name ) ; } else { return sprintf ( '<%s>%s</%s>' , $ name , self :: encodeValueXml ( $ value ) , $ name ) ; } }
12941	public function storePermissions ( $ params = array ( ) ) { $ authorityAreaTitle = $ this -> input -> getString ( "area-title" ) ; $ authorityAreaURI = $ this -> input -> getString ( "area-uri" ) ; $ authorityAreaAction = $ this -> input -> getString ( "area-action" ) ; $ authorityAreaPermission = $ this -> input -> getString ( "area-permission" ) ; $ authorityId = $ this -> input -> getInt ( "area-authority" ) ; $ table = $ this -> load -> table ( "?authority_permissions" ) ; $ aData = array ( "authority_id" => $ authorityId , "permission_area_uri" => strtolower ( $ authorityAreaURI ) , "permission" => strtolower ( $ authorityAreaPermission ) , "permission_type" => strtolower ( $ authorityAreaAction ) , "permission_title" => $ authorityAreaTitle ) ; foreach ( $ aData as $ k => $ item ) { if ( empty ( $ item ) ) { $ this -> setError ( _t ( "Please complete all permission fields; Provide a title and uri defining the area, a permission type and value" ) ) ; return false ; } } if ( ! $ table -> bindData ( $ aData ) ) { throw new \ Platform \ Exception ( $ table -> getError ( ) ) ; return false ; } if ( $ table -> isNewRow ( ) ) { } if ( ! $ table -> save ( ) ) { return false ; } return true ; }
11860	public function setCompanionObject ( $ value ) { if ( $ this -> isForeign ) { return $ this -> localObject = $ value ; } else { return $ this -> foreignObject = $ value ; } }
12793	public function create ( $ params = array ( ) ) { $ serverConfig = array_merge ( $ this -> defaults , $ params ) ; try { $ response = $ this -> client -> request -> post ( $ this -> apiEndpoint . "/droplets" , [ 'json' => $ serverConfig ] ) ; if ( 202 != $ this -> client -> getStatus ( $ response ) ) { throw new Exception ( 'Unable to create server.' ) ; } } catch ( Exception $ e ) { echo 'Unable to create server because ' . $ e -> getMessage ( ) ; } return $ this -> client -> getBody ( $ response ) ; }
8836	public function setMaxRetries ( $ retries ) { switch ( gettype ( $ retries ) ) { case 'integer' : $ this -> maxRetries = new Retries ( $ retries ) ; break ; case 'object' : $ this -> maxRetries = $ retries ; break ; default : throw new InvalidArgumentException ( 'Invalid type for max retries given.' ) ; break ; } }
7889	public function make ( $ date , $ level = 'all' ) { $ raw = $ this -> filesystem -> read ( $ date ) ; $ levels = $ this -> levels ; return new Log ( $ raw , $ levels , $ level ) ; }
848	public function getNonWhitespaceSibling ( $ index , $ direction , $ whitespaces = null ) { while ( true ) { $ index += $ direction ; if ( ! $ this -> offsetExists ( $ index ) ) { return null ; } $ token = $ this [ $ index ] ; if ( ! $ token -> isWhitespace ( $ whitespaces ) ) { return $ index ; } } }
9761	function containOnlyInstancesOf ( string $ className ) : self { return $ this -> expect ( $ this -> target , containsOnlyInstancesOf ( $ className ) ) ; }
11782	protected function generateSourceFromChildren ( ) { $ i = 1 ; $ children = array ( ) ; foreach ( $ this -> children as $ child ) { $ childValue = Yaml :: parse ( $ child -> getSource ( ) ) ; if ( is_array ( $ childValue ) && array_key_exists ( "type" , $ childValue ) ) { $ childValue [ "type" ] = $ child -> getType ( ) ; } $ children [ 'item' . $ i ] = $ childValue ; $ i ++ ; } $ source = array ( "children" => $ children , ) ; if ( ! empty ( $ this -> tags ) ) { $ source [ "tags" ] = $ this -> tags ; } $ source [ "type" ] = $ this -> type ; return $ source ; }
164	public static function create ( $ from ) { return new self ( [ 'where' => $ from -> where , 'limit' => $ from -> limit , 'offset' => $ from -> offset , 'orderBy' => $ from -> orderBy , 'indexBy' => $ from -> indexBy , 'select' => $ from -> select , 'selectOption' => $ from -> selectOption , 'distinct' => $ from -> distinct , 'from' => $ from -> from , 'groupBy' => $ from -> groupBy , 'join' => $ from -> join , 'having' => $ from -> having , 'union' => $ from -> union , 'params' => $ from -> params , ] ) ; }
9903	public function updateCellReference ( $ pCellRange = 'A1' , $ pBefore = 'A1' , $ pNumCols = 0 , $ pNumRows = 0 ) { if ( strpos ( $ pCellRange , '!' ) !== false ) { return $ pCellRange ; } elseif ( ! Coordinate :: coordinateIsRange ( $ pCellRange ) ) { return $ this -> updateSingleCellReference ( $ pCellRange , $ pBefore , $ pNumCols , $ pNumRows ) ; } elseif ( Coordinate :: coordinateIsRange ( $ pCellRange ) ) { return $ this -> updateCellRange ( $ pCellRange , $ pBefore , $ pNumCols , $ pNumRows ) ; } return $ pCellRange ; }
9490	protected function getFileDataValue ( $ obFile ) { if ( empty ( $ obFile ) || ! $ obFile instanceof File ) { return null ; } $ sUploadFolder = Config :: get ( 'cms.storage.uploads.path' , '/storage/app/uploads' ) ; return [ 'full_path' => $ obFile -> getPath ( ) , 'path' => $ sUploadFolder . str_replace ( 'uploads' , '' , $ obFile -> getDiskPath ( ) ) , 'title' => $ obFile -> getAttribute ( 'title' ) , 'alt' => $ obFile -> getAttribute ( 'description' ) , ] ; }
6304	protected function process ( array $ nav ) { foreach ( $ nav as $ key => $ value ) { if ( ! isset ( $ value [ 'url' ] ) ) { $ nav [ $ key ] [ 'url' ] = $ this -> url -> to ( $ value [ 'slug' ] ) ; } unset ( $ nav [ $ key ] [ 'slug' ] ) ; } return $ nav ; }
10854	protected function buildCol ( ) { $ result = [ ] ; foreach ( $ this -> col_defs as $ col ) { $ res = [ ] ; $ res [ ] = $ this -> quote ( $ col [ 'name' ] ) ; $ res [ ] = $ col [ 'type' ] ; if ( isset ( $ col [ 'notNull' ] ) ) { $ res [ ] = 'NOT NULL' . ( $ col [ 'notNull' ] ? ( ' ' . $ col [ 'notNull' ] ) : '' ) ; } if ( isset ( $ col [ 'default' ] ) ) { $ res [ ] = 'DEFAULT ' . ( $ col [ 'default' ] [ 1 ] ? $ col [ 'default' ] [ 0 ] : $ this -> processValue ( $ col [ 'default' ] [ 0 ] ) ) ; } if ( isset ( $ col [ 'autoincrement' ] ) ) { $ res [ ] = 'AUTO_INCREMENT' ; } if ( isset ( $ col [ 'unique' ] ) ) { $ res [ ] = 'UNIQUE' . ( $ col [ 'unique' ] ? ( ' ' . $ col [ 'unique' ] ) : '' ) ; } if ( isset ( $ col [ 'primary' ] ) ) { $ res [ ] = 'PRIMARY KEY' . ( $ col [ 'primary' ] ? ( ' ' . $ col [ 'primary' ] ) : '' ) ; } if ( isset ( $ col [ 'constraint' ] ) ) { $ res [ ] = join ( ' ' , $ col [ 'constraint' ] ) ; } array_walk ( $ res , function ( $ m ) { return trim ( $ m ) ; } ) ; $ result [ ] = join ( ' ' , $ res ) ; } return $ result ; }
2372	public static function toXhtml ( $ strString ) { $ arrPregReplace = array ( '/<(br|hr|img)([^>]*)>/i' => '<$1$2 />' , '/ border="[^"]*"/' => '' ) ; $ arrStrReplace = array ( '/ />' => ' />' , '<b>' => '<strong>' , '</b>' => '</strong>' , '<i>' => '<em>' , '</i>' => '</em>' , '<u>' => '<span style="text-decoration:underline">' , '</u>' => '</span>' , ' target="_self"' => '' , ' target="_blank"' => ' onclick="return !window.open(this.href)"' ) ; $ strString = preg_replace ( array_keys ( $ arrPregReplace ) , $ arrPregReplace , $ strString ) ; $ strString = str_ireplace ( array_keys ( $ arrStrReplace ) , $ arrStrReplace , $ strString ) ; return $ strString ; }
2199	public static function findPublishedByIdOrAliasAndPid ( $ varId , $ intPid , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = ! preg_match ( '/^[1-9]\d*$/' , $ varId ) ? array ( "$t.alias=?" ) : array ( "$t.id=?" ) ; $ arrValues = array ( $ varId ) ; if ( $ intPid ) { $ arrColumns [ ] = "$t.pid=?" ; $ arrValues [ ] = $ intPid ; } if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } return static :: findOneBy ( $ arrColumns , $ arrValues , $ arrOptions ) ; }
6917	public function isEmpty ( ) { return empty ( $ this -> subject ) || ( empty ( $ this -> customMessage ) && empty ( $ this -> paymentMessage ) && empty ( $ this -> shipmentMessage ) ) ; }
259	protected function findViewFile ( $ view , $ context = null ) { if ( strncmp ( $ view , '@' , 1 ) === 0 ) { $ file = Yii :: getAlias ( $ view ) ; } elseif ( strncmp ( $ view , '//' , 2 ) === 0 ) { $ file = Yii :: $ app -> getViewPath ( ) . DIRECTORY_SEPARATOR . ltrim ( $ view , '/' ) ; } elseif ( strncmp ( $ view , '/' , 1 ) === 0 ) { if ( Yii :: $ app -> controller !== null ) { $ file = Yii :: $ app -> controller -> module -> getViewPath ( ) . DIRECTORY_SEPARATOR . ltrim ( $ view , '/' ) ; } else { throw new InvalidCallException ( "Unable to locate view file for view '$view': no active controller." ) ; } } elseif ( $ context instanceof ViewContextInterface ) { $ file = $ context -> getViewPath ( ) . DIRECTORY_SEPARATOR . $ view ; } elseif ( ( $ currentViewFile = $ this -> getRequestedViewFile ( ) ) !== false ) { $ file = dirname ( $ currentViewFile ) . DIRECTORY_SEPARATOR . $ view ; } else { throw new InvalidCallException ( "Unable to resolve view file for view '$view': no active view context." ) ; } if ( pathinfo ( $ file , PATHINFO_EXTENSION ) !== '' ) { return $ file ; } $ path = $ file . '.' . $ this -> defaultExtension ; if ( $ this -> defaultExtension !== 'php' && ! is_file ( $ path ) ) { $ path = $ file . '.php' ; } return $ path ; }
2963	public function isAuthorized ( ) { $ hasSession = Yii :: $ app -> session -> has ( $ this -> sessionParam ) ; $ sessionVal = Yii :: $ app -> session -> get ( $ this -> sessionParam ) ; return ( $ hasSession && ! empty ( $ sessionVal ) ) ; }
7263	protected function convert ( Model \ SaleInterface $ sale , float $ amount , string $ currency , bool $ round ) { if ( $ currency === $ this -> converter -> getDefaultCurrency ( ) ) { return $ round ? Money :: round ( $ amount , $ currency ) : $ amount ; } if ( null !== $ rate = $ sale -> getExchangeRate ( ) ) { return $ this -> converter -> convertWithRate ( $ amount , $ rate , $ currency , $ round ) ; } $ date = $ this -> contextProvider -> getContext ( $ sale ) -> getDate ( ) ; return $ this -> converter -> convert ( $ amount , $ this -> converter -> getDefaultCurrency ( ) , $ currency , $ date , $ round ) ; }
9287	public function drop ( ) { $ adapter = $ this -> dbAdapter ; $ ddl = new Ddl \ DropTable ( self :: TABLE_NAME ) ; $ sql = ( new Sql ( $ adapter ) ) -> getSqlStringForSqlObject ( $ ddl ) ; $ adapter -> query ( $ sql , $ adapter :: QUERY_MODE_EXECUTE ) ; }
7187	public function getAssignmentById ( $ id ) { foreach ( $ this -> unit -> getStockAssignments ( ) as & $ assignment ) { if ( $ assignment -> getId ( ) === $ id ) { return $ assignment ; } } return null ; }
4695	public function limitBy ( ? int $ limit , int $ offset = null ) : self { $ this -> dirty ( ) ; $ this -> limit = $ limit || $ offset ? [ $ limit , $ offset ] : null ; return $ this ; }
2906	public function getContent ( Zend_Mail $ mail ) { $ hasQueue = $ this -> hasQueue ( ) ; if ( $ hasQueue && $ queue = $ this -> getQueue ( ) ) { return $ queue -> getMessageBody ( ) ; } $ mimePart = $ this -> isPlain ( ) ? $ mail -> getBodyText ( ) : $ mail -> getBodyHtml ( ) ; return $ mimePart ? $ this -> getPartDecodedContent ( $ mimePart ) : '' ; }
3757	public function decodeValue ( DecodePropertyValueForWidgetEvent $ event ) { if ( ! ( $ this -> wantToHandle ( $ event ) && \ in_array ( $ event -> getProperty ( ) , [ 'name' , 'description' ] ) ) ) { return ; } $ metaModel = $ this -> getMetaModelByModelPid ( $ event -> getModel ( ) ) ; $ values = Helper :: decodeLangArray ( $ event -> getValue ( ) , $ metaModel ) ; $ event -> setValue ( unserialize ( $ values , [ 'allowed_classes' => false ] ) ) ; }
12004	public static function objectToArray ( $ mObject ) : array { if ( is_object ( $ mObject ) ) { $ mObject = ( array ) $ mObject ; } if ( is_array ( $ mObject ) ) { $ aNew = array ( ) ; foreach ( $ mObject as $ sKey => $ mValues ) { $ sKey = preg_replace ( "/^\\0(.*)\\0/" , "" , $ sKey ) ; $ aNew [ $ sKey ] = self :: objectToArray ( $ mValues ) ; } } else { $ aNew = $ mObject ; } return $ aNew ; }
12065	public function destroy ( ) { session_start ( ) ; $ _SESSION = array ( ) ; if ( ini_get ( "session.use_cookies" ) ) { $ aParams = session_get_cookie_params ( ) ; setcookie ( session_name ( ) , '' , time ( ) - 42000 , $ aParams [ "path" ] , $ aParams [ "domain" ] , $ aParams [ "secure" ] , $ aParams [ "httponly" ] ) ; } session_destroy ( ) ; }
7981	public function getSessionFilesProperties ( $ sessId , $ fileId ) { return json_decode ( self :: getClient ( ) -> getPcaSessionFilesProperties ( $ this -> pp , $ this -> sn , $ sessId , $ fileId ) ) ; }
10617	protected function setEtag ( Response $ response ) { if ( ! $ response -> getEtag ( ) ) { $ response -> setEtag ( $ this -> key_builder -> getEtag ( $ response ) ) ; } return $ this ; }
11584	public function exec ( $ calcId ) { $ result = [ ] ; $ bonusPercent = Cfg :: TEAM_BONUS_EU_PERCENT ; $ dwnlCompress = $ this -> daoBonDwnl -> getByCalcId ( $ calcId ) ; $ dwnlCurrent = $ this -> daoDwnl -> get ( ) ; $ mapDwnlById = $ this -> hlpDwnlTree -> mapById ( $ dwnlCompress , EBonDwnl :: A_CUST_REF ) ; $ mapCustById = $ this -> hlpDwnlTree -> mapById ( $ dwnlCurrent , ECustomer :: A_CUSTOMER_REF ) ; foreach ( $ mapDwnlById as $ custId => $ custDwnl ) { $ custData = $ mapCustById [ $ custId ] ; $ custMlmId = $ custData -> getMlmId ( ) ; $ pv = $ custDwnl -> getPv ( ) ; $ parentId = $ custDwnl -> getParentRef ( ) ; $ parentDwnl = $ mapDwnlById [ $ parentId ] ; $ parentData = $ mapCustById [ $ parentId ] ; $ parentMlmId = $ parentData -> getMlmId ( ) ; $ scheme = $ this -> hlpScheme -> getSchemeByCustomer ( $ parentData ) ; if ( $ scheme == Cfg :: SCHEMA_EU ) { $ pvParent = $ parentDwnl -> getPv ( ) ; if ( $ pvParent > ( Cfg :: PV_QUALIFICATION_LEVEL_EU - Cfg :: DEF_ZERO ) ) { $ bonus = $ this -> hlpFormat -> roundBonus ( $ pv * $ bonusPercent ) ; if ( $ bonus > Cfg :: DEF_ZERO ) { $ entry = new DBonus ( ) ; $ entry -> setCustomerRef ( $ parentId ) ; $ entry -> setDonatorRef ( $ custId ) ; $ entry -> setValue ( $ bonus ) ; $ result [ ] = $ entry ; } $ this -> logger -> debug ( "parent #$parentId (ref. #$parentMlmId) has '$bonus' as EU Team Bonus from downline customer #$custId (ref. #$custMlmId )." ) ; } else { $ this -> logger -> debug ( "parent #$parentId (ref. #$parentMlmId) does not qualified t oget EU Team Bonus from downline customer #$custId (ref. #$custMlmId )." ) ; } } else { $ this -> logger -> debug ( "Parent #$parentId (ref. #$parentMlmId) has incompatible scheme '$scheme' for EU Team Bonus." ) ; } } unset ( $ mapCustById ) ; unset ( $ mapDwnlById ) ; return $ result ; }
3602	public function isDebug ( ) { if ( null !== $ this -> container && $ this -> container -> has ( 'kernel' ) ) { return $ this -> container -> get ( 'kernel' ) -> isDebug ( ) ; } return true ; }
12567	public function sendCard ( $ message , $ to = null ) { return $ this -> send ( self :: MSG_TYPE_CARD , $ message , $ to ) ; }
2920	public function deleteSetter ( $ key ) { $ pattern = "/^(export\h)?\h*{$key}=.*\n/m" ; $ this -> buffer = preg_replace ( $ pattern , null , $ this -> buffer ) ; return $ this ; }
8224	protected function logRateLimitReached ( $ actionName , $ blockType , $ entityId , $ config ) { $ this -> getLogger ( ) -> notice ( "Rate limit of {cnt} reached: {action} for {entity} ({type})." , array ( 'cnt' => $ config [ "count" ] , 'action' => $ actionName , 'entity' => $ entityId , 'type' => $ blockType ) ) ; }
5293	protected function execute ( InputInterface $ input , OutputInterface $ output ) { $ directory = $ input -> getArgument ( 'directory' ) ; $ outputFile = $ input -> getArgument ( 'output-file' ) ; $ generator = new IconFontGenerator ; $ output -> writeln ( 'reading files from "' . $ directory . '" ...' ) ; $ generator -> generateFromDir ( $ directory , array ( 'id' => $ input -> getOption ( 'name' ) ? : 'SVGFont' , ) , $ input -> getOption ( 'rename-files' ) ) ; $ output -> writeln ( 'writing font to "' . $ outputFile . '" ...' ) ; file_put_contents ( $ outputFile , $ generator -> getFont ( ) -> getXML ( ) ) ; $ output -> getFormatter ( ) -> setStyle ( 'success' , new OutputFormatterStyle ( null , null , array ( 'bold' , 'reverse' ) ) ) ; $ output -> writeln ( '<success>created ' . $ outputFile . ' successfully</success>' ) ; }
6335	public function create ( $ title , $ message , $ level = 'info' , $ key = 'flash_message' ) { $ this -> session -> flash ( $ key , [ 'title' => $ title , 'message' => $ message , 'level' => $ level , ] ) ; return $ this ; }
8700	public function append ( $ element ) { if ( true === $ element instanceof \ SVGCreator \ Element ) { $ this -> childElements [ ] = $ element ; return $ element ; } else { $ elementCreated = $ this -> factoryElement ( $ element ) ; $ this -> childElements [ ] = $ elementCreated ; return $ elementCreated ; } }
2599	public function skipUntil ( $ type ) { while ( $ this -> lookahead !== null && $ this -> lookahead [ 'type' ] !== $ type ) { $ this -> moveNext ( ) ; } }
7783	public function registerTimezoneScript ( $ actionRoute ) { Yii :: $ app -> on ( Controller :: EVENT_BEFORE_ACTION , function ( $ event ) use ( $ actionRoute ) { $ view = $ event -> sender -> view ; $ js = <<<JS var timezone = ''; var timezoneAbbr = ''; try { var timezone = Intl.DateTimeFormat().resolvedOptions().timeZone; var timezoneAbbr = /\((.*)\)/.exec(new Date().toString())[1]; } catch(err) { console.log(err); } $.post("$actionRoute", { timezone: timezone, timezoneAbbr: timezoneAbbr, timezoneOffset: -new Date().getTimezoneOffset() / 60 });JS ; $ view -> registerJs ( $ js ) ; } ) ; }
11368	public static function deduplicate ( $ array ) { if ( empty ( $ array ) ) { return $ array ; } $ known = array ( ) ; foreach ( $ array as $ _index => $ entry ) { if ( is_array ( $ entry ) ) { foreach ( $ entry as $ i => $ _email ) { if ( ! in_array ( $ _email , $ known ) ) { $ known [ ] = $ _email ; } else { unset ( $ array [ $ _index ] ) ; } } } elseif ( is_string ( $ entry ) ) { if ( ! in_array ( $ entry , $ known ) ) { $ known [ ] = $ entry ; } else { unset ( $ array [ $ _index ] ) ; } } } return $ array ; }
5805	public function increment ( ) { $ this -> counter ++ ; if ( 1 === $ this -> counter ) { $ this -> expiresAt = $ this -> now ( ) + $ this -> expiresIn ; } }
10041	function toString ( ) { return "Rule [isCustomfield=" . ( $ this -> isCustomfield ) ? "true" : "false" . ", field=" . $ this -> field . ", operator=" . $ this -> operator . ", value=" . $ this -> value . " (type = " . $ this -> type . ")" ; }
4707	public function processMultipleUnderScore ( Text $ text ) { $ text -> replace ( '{<pre>.*?</pre>}m' , function ( Text $ w ) { $ md5 = md5 ( $ w ) ; $ this -> hashes [ $ md5 ] = $ w ; return "{gfm-extraction-$md5}" ; } ) ; $ text -> replace ( '/^(?! {4}|\t)(\[?\w+_\w+_\w[\w_]*\]?)/' , function ( Text $ w , Text $ word ) { $ underscores = $ word -> split ( '//' ) -> filter ( function ( Text $ item ) { return $ item == '_' ; } ) ; if ( count ( $ underscores ) >= 2 ) { $ word -> replaceString ( '_' , '\\_' ) ; } return $ word ; } ) ; $ text -> replace ( '/\{gfm-extraction-([0-9a-f]{32})\}/m' , function ( Text $ w , Text $ md5 ) { return "\n\n" . $ this -> hashes [ ( string ) $ md5 ] ; } ) ; }
567	private function parseDateValueFormat ( $ value , $ format ) { if ( is_array ( $ value ) ) { return false ; } if ( strncmp ( $ format , 'php:' , 4 ) === 0 ) { $ format = substr ( $ format , 4 ) ; } else { if ( extension_loaded ( 'intl' ) ) { return $ this -> parseDateValueIntl ( $ value , $ format ) ; } $ format = FormatConverter :: convertDateIcuToPhp ( $ format , 'date' ) ; } return $ this -> parseDateValuePHP ( $ value , $ format ) ; }
5652	public function render ( ) { $ tab_stop = $ this -> longestFlag ( $ this -> flag_sets ) + 4 ; $ text = $ this -> overview . "\n" ; $ numberOfFlags = count ( $ this -> flag_sets ) ; for ( $ i = 0 ; $ i < $ numberOfFlags ; $ i ++ ) { $ text .= $ this -> renderFlagSet ( $ this -> flag_sets [ $ i ] , $ this -> explanations [ $ i ] , $ tab_stop ) ; } return $ this -> noDuplicateNewLines ( $ text ) ; }
6585	protected function perform ( callable $ callback , ... $ params ) { $ result = $ callback ( $ this -> curl , ... $ params ) ; if ( curl_errno ( $ this -> curl ) !== CURLE_OK ) throw new CurlException ( $ this -> curl ) ; if ( $ result === false ) throw new CurlException ( "Unable to perform $callback - unknown error." ) ; return $ result ; }
9982	private function writeVMLComment ( XMLWriter $ objWriter , $ pCellReference , Comment $ pComment ) { list ( $ column , $ row ) = Coordinate :: coordinateFromString ( $ pCellReference ) ; $ column = Coordinate :: columnIndexFromString ( $ column ) ; $ id = 1024 + $ column + $ row ; $ id = substr ( $ id , 0 , 4 ) ; $ objWriter -> startElement ( 'v:shape' ) ; $ objWriter -> writeAttribute ( 'id' , '_x0000_s' . $ id ) ; $ objWriter -> writeAttribute ( 'type' , '#_x0000_t202' ) ; $ objWriter -> writeAttribute ( 'style' , 'position:absolute;margin-left:' . $ pComment -> getMarginLeft ( ) . ';margin-top:' . $ pComment -> getMarginTop ( ) . ';width:' . $ pComment -> getWidth ( ) . ';height:' . $ pComment -> getHeight ( ) . ';z-index:1;visibility:' . ( $ pComment -> getVisible ( ) ? 'visible' : 'hidden' ) ) ; $ objWriter -> writeAttribute ( 'fillcolor' , '#' . $ pComment -> getFillColor ( ) -> getRGB ( ) ) ; $ objWriter -> writeAttribute ( 'o:insetmode' , 'auto' ) ; $ objWriter -> startElement ( 'v:fill' ) ; $ objWriter -> writeAttribute ( 'color2' , '#' . $ pComment -> getFillColor ( ) -> getRGB ( ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'v:shadow' ) ; $ objWriter -> writeAttribute ( 'on' , 't' ) ; $ objWriter -> writeAttribute ( 'color' , 'black' ) ; $ objWriter -> writeAttribute ( 'obscured' , 't' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'v:path' ) ; $ objWriter -> writeAttribute ( 'o:connecttype' , 'none' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'v:textbox' ) ; $ objWriter -> writeAttribute ( 'style' , 'mso-direction-alt:auto' ) ; $ objWriter -> startElement ( 'div' ) ; $ objWriter -> writeAttribute ( 'style' , 'text-align:left' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'x:ClientData' ) ; $ objWriter -> writeAttribute ( 'ObjectType' , 'Note' ) ; $ objWriter -> writeElement ( 'x:MoveWithCells' , '' ) ; $ objWriter -> writeElement ( 'x:SizeWithCells' , '' ) ; $ objWriter -> writeElement ( 'x:AutoFill' , 'False' ) ; $ objWriter -> writeElement ( 'x:Row' , ( $ row - 1 ) ) ; $ objWriter -> writeElement ( 'x:Column' , ( $ column - 1 ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; }
9667	private function writeGradientFill ( XMLWriter $ objWriter , Fill $ pFill ) { $ objWriter -> startElement ( 'fill' ) ; $ objWriter -> startElement ( 'gradientFill' ) ; $ objWriter -> writeAttribute ( 'type' , $ pFill -> getFillType ( ) ) ; $ objWriter -> writeAttribute ( 'degree' , $ pFill -> getRotation ( ) ) ; $ objWriter -> startElement ( 'stop' ) ; $ objWriter -> writeAttribute ( 'position' , '0' ) ; $ objWriter -> startElement ( 'color' ) ; $ objWriter -> writeAttribute ( 'rgb' , $ pFill -> getStartColor ( ) -> getARGB ( ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'stop' ) ; $ objWriter -> writeAttribute ( 'position' , '1' ) ; $ objWriter -> startElement ( 'color' ) ; $ objWriter -> writeAttribute ( 'rgb' , $ pFill -> getEndColor ( ) -> getARGB ( ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; }
811	private function fixSpaceBelowClassElement ( Tokens $ tokens , $ classEndIndex , $ elementEndIndex ) { for ( $ nextNotWhite = $ elementEndIndex + 1 ; ; ++ $ nextNotWhite ) { if ( ( $ tokens [ $ nextNotWhite ] -> isComment ( ) || $ tokens [ $ nextNotWhite ] -> isWhitespace ( ) ) && false === strpos ( $ tokens [ $ nextNotWhite ] -> getContent ( ) , "\n" ) ) { continue ; } break ; } if ( $ tokens [ $ nextNotWhite ] -> isWhitespace ( ) ) { $ nextNotWhite = $ tokens -> getNextNonWhitespace ( $ nextNotWhite ) ; } $ this -> correctLineBreaks ( $ tokens , $ elementEndIndex , $ nextNotWhite , $ nextNotWhite === $ classEndIndex ? 1 : 2 ) ; }
3558	public function setValue ( $ value ) { $ this -> setType ( $ value ) ; if ( $ this -> hasMutator ( $ value , 'setter' ) ) { $ value = $ this -> mutateValue ( $ value , 'setter' ) ; } elseif ( ! $ this -> isStringable ( $ value ) && ! is_null ( $ value ) ) { throw new InvalidTypeException ( "Unsupported meta value type [{$this->getValueType($value)}]." ) ; } $ this -> attributes [ 'meta_value' ] = $ value ; }
5493	public function add ( $ parameters , $ action ) { $ place = count ( $ this -> map ) ; $ this -> map [ $ place ] = array ( ) ; $ this -> map [ $ place ] [ 'params' ] = new ParametersExpectation ( $ parameters ) ; $ this -> map [ $ place ] [ 'content' ] = $ action ; }
7708	function ReplaceSrc ( $ new ) { $ len = $ this -> GetLen ( ) ; $ this -> Txt = substr_replace ( $ this -> Txt , $ new , $ this -> PosBeg , $ len ) ; $ diff = strlen ( $ new ) - $ len ; $ this -> PosEnd += $ diff ; $ this -> pST_Src = false ; if ( $ new === '' ) { $ this -> pST_PosBeg = false ; $ this -> pST_PosEnd = false ; $ this -> pET_PosBeg = false ; } else { $ this -> pST_PosEnd += $ diff ; if ( $ this -> pET_PosBeg !== false ) $ this -> pET_PosBeg += $ diff ; } }
6066	public function listSocialMedia ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/media/' . $ id . '/socialmedia/sites' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new SocialMedia ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
4856	public function setParams ( $ namespace , $ params ) { $ session = new Container ( $ namespace ) ; $ session -> params = $ params ; unset ( $ session -> list ) ; return $ this ; }
9740	public function getPrintArea ( $ index = 0 ) { if ( $ index == 0 ) { return $ this -> printArea ; } $ printAreas = explode ( ',' , $ this -> printArea ) ; if ( isset ( $ printAreas [ $ index - 1 ] ) ) { return $ printAreas [ $ index - 1 ] ; } throw new PhpSpreadsheetException ( 'Requested Print Area does not exist' ) ; }
10765	public function generateImage ( $ filename = false , $ level = Constants :: QR_ECLEVEL_L , $ size = 3 , $ margin = 4 ) { $ result = 'SPD' . self :: DELIMITER . $ this -> version . self :: DELIMITER . $ this -> implodeContent ( ) ; if ( $ this -> appendCRC32 ) { $ result .= self :: DELIMITER . 'CRC32:' . sprintf ( '%x' , crc32 ( $ result ) ) ; } QRcode :: png ( $ result , $ filename , $ level , $ size , $ margin ) ; die ( ) ; }
9545	public function create ( $ table , array $ fields , $ tokenize = 'porter' ) { $ fields = implode ( ', ' , $ fields ) ; $ query = "CREATE VIRTUAL TABLE {$table} USING fts4({$fields}, tokenize={$tokenize})" ; $ executed = $ this -> db -> info ( 'tables' , $ table ) ; if ( $ query == $ executed ) { return false ; } if ( ! is_null ( $ executed ) ) { $ this -> db -> exec ( 'DROP TABLE ' . $ table ) ; } $ this -> db -> exec ( $ query ) ; $ this -> db -> info ( 'tables' , $ table , $ query ) ; return true ; }
6009	public function setDeleted ( $ deleted ) { if ( $ deleted instanceof DateTime ) { $ this -> deleted = $ deleted ; } else { try { $ this -> deleted = new DateTime ( $ deleted ) ; } catch ( \ Exception $ e ) { $ this -> deleted = null ; } } return $ this ; }
5983	protected function withOAuth2MiddleWare ( HandlerStack $ stack ) { if ( ! ( $ this -> oauth2Middleware instanceof OAuthMiddleware ) ) { $ oauthClient = new Client ( [ 'base_uri' => $ this -> basepath , 'verify' => $ this -> verifyCertificates , 'headers' => [ 'User-Agent' => 'qbank3api-phpwrapper/2 (qbankapi: 1; swagger: 1.1)' , ] , ] ) ; $ config = [ PasswordCredentials :: CONFIG_USERNAME => $ this -> credentials -> getUsername ( ) , PasswordCredentials :: CONFIG_PASSWORD => $ this -> credentials -> getPassword ( ) , PasswordCredentials :: CONFIG_CLIENT_ID => $ this -> credentials -> getClientId ( ) , PasswordCredentials :: CONFIG_TOKEN_URL => 'oauth2/token' , ] ; $ this -> oauth2Middleware = new OAuthMiddleware ( $ oauthClient , new PasswordCredentials ( $ oauthClient , $ config ) , new RefreshToken ( $ oauthClient , $ config ) ) ; $ tokens = $ this -> getTokens ( ) ; if ( ! empty ( $ tokens [ 'accessTokens' ] ) ) { $ this -> oauth2Middleware -> setAccessToken ( $ tokens [ 'accessTokens' ] ) ; } if ( ! empty ( $ tokens [ 'refreshTokens' ] ) ) { $ this -> oauth2Middleware -> setRefreshToken ( $ tokens [ 'refreshTokens' ] ) ; } } $ stack -> push ( $ this -> oauth2Middleware -> onBefore ( ) ) ; $ stack -> push ( $ this -> oauth2Middleware -> onFailure ( 3 ) ) ; return $ stack ; }
9432	protected static function random ( $ float_min , $ float_max ) { if ( $ float_max >= 0 ) { $ r = new Random ( ) ; while ( true ) { $ float_prov = $ float_max * $ r -> get ( ) ; if ( $ float_prov >= $ float_min ) { return $ float_prov ; } } } else { $ r = new Random ( ) ; while ( true ) { $ float_prov = $ float_min * $ r -> get ( ) ; if ( $ float_prov <= $ float_max ) { return $ float_prov ; } } } }
532	protected function resortChangelog ( $ changelog ) { foreach ( $ changelog as $ i => $ line ) { $ changelog [ $ i ] = rtrim ( $ line ) ; } $ changelog = array_filter ( $ changelog ) ; $ i = 0 ; ArrayHelper :: multisort ( $ changelog , function ( $ line ) use ( & $ i ) { if ( preg_match ( '/^- (Chg|Enh|Bug|New)( #\d+(, #\d+)*)?: .+/' , $ line , $ m ) ) { $ o = [ 'Bug' => 'C' , 'Enh' => 'D' , 'Chg' => 'E' , 'New' => 'F' ] ; return $ o [ $ m [ 1 ] ] . ' ' . ( ! empty ( $ m [ 2 ] ) ? $ m [ 2 ] : 'AAAA' . $ i ++ ) ; } return 'B' . $ i ++ ; } , SORT_ASC , SORT_NATURAL ) ; array_unshift ( $ changelog , '' ) ; $ changelog [ ] = '' ; $ changelog [ ] = '' ; return $ changelog ; }
3902	public function deleteColumn ( ) { $ schemaManager = $ this -> connection -> getSchemaManager ( ) ; $ columns = $ schemaManager -> listTableColumns ( $ this -> getMetaModel ( ) -> getTableName ( ) ) ; if ( $ this -> getColName ( ) && isset ( $ columns [ $ this -> getColName ( ) ] ) ) { $ this -> tableManipulator -> dropColumn ( $ this -> getMetaModel ( ) -> getTableName ( ) , $ this -> getColName ( ) ) ; } }
5466	public function setIdentityForRealm ( $ host , $ realm , $ username , $ password ) { if ( isset ( $ this -> realms [ $ host ] [ $ realm ] ) ) { $ this -> realms [ $ host ] [ $ realm ] -> setIdentity ( $ username , $ password ) ; } }
10702	public static function getPasswordComplexity ( $ password , $ minLength ) { $ group = [ 'upper' => '/[A-Z]/' , 'lower' => '/[a-z]/' , 'number' => '/[0-9]/' , 'special' => '/[^A-Za-z0-9]/' , ] ; $ score = 0 ; $ length = \ strlen ( $ password ) ; if ( $ length < $ minLength ) { return 0 ; } foreach ( $ group as $ pattern ) { if ( preg_match ( $ pattern , $ password ) ) { $ score ++ ; } } if ( $ score < 3 ) { $ score -- ; } if ( $ length > $ minLength ) { $ score += ( int ) floor ( ( $ length - $ minLength ) / 2 ) ; } return $ score ; }
2175	private function adjustDatabaseTables ( ) : ? RedirectResponse { $ this -> container -> get ( 'contao.install_tool' ) -> handleRunOnce ( ) ; $ installer = $ this -> container -> get ( 'contao.installer' ) ; $ this -> context [ 'sql_form' ] = $ installer -> getCommands ( ) ; $ request = $ this -> container -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; if ( null === $ request ) { throw new \ RuntimeException ( 'The request stack did not contain a request' ) ; } if ( 'tl_database_update' !== $ request -> request -> get ( 'FORM_SUBMIT' ) ) { return null ; } $ sql = $ request -> request -> get ( 'sql' ) ; if ( ! empty ( $ sql ) && \ is_array ( $ sql ) ) { foreach ( $ sql as $ hash ) { $ installer -> execCommand ( $ hash ) ; } } return $ this -> getRedirectResponse ( ) ; }
5868	public static function getMetadata ( $ fileName , $ fullExtract = false ) { $ metadata = static :: getBasicMetadata ( $ fileName ) ; if ( $ fullExtract && ! empty ( $ metadata ) ) { $ virtualFileObject = static :: getVirtualFileObject ( $ fileName , $ metadata ) ; $ extractorRegistry = \ TYPO3 \ CMS \ Core \ Resource \ Index \ ExtractorRegistry :: getInstance ( ) ; $ extractionServices = $ extractorRegistry -> getExtractorsWithDriverSupport ( 'Local' ) ; $ newMetadata = [ 0 => $ metadata , ] ; foreach ( $ extractionServices as $ service ) { if ( $ service -> canProcess ( $ virtualFileObject ) ) { $ newMetadata [ $ service -> getPriority ( ) ] = $ service -> extractMetaData ( $ virtualFileObject , $ newMetadata ) ; } } ksort ( $ newMetadata ) ; foreach ( $ newMetadata as $ data ) { $ metadata = array_merge ( $ metadata , $ data ) ; } } return $ metadata ; }
4044	private function removeInvariantAttributes ( IItem $ nativeItem , ICollection $ renderSetting ) { $ model = $ nativeItem -> getMetaModel ( ) ; if ( $ model -> hasVariants ( ) && ! $ nativeItem -> isVariantBase ( ) ) { $ renderSetting = clone $ renderSetting ; foreach ( array_keys ( $ model -> getInVariantAttributes ( ) ) as $ strAttrName ) { $ renderSetting -> setSetting ( $ strAttrName , null ) ; } } return $ renderSetting ; }
3867	public function handle ( ManipulateWidgetEvent $ event ) { if ( ! ( $ this -> wantToHandle ( $ event ) && ( 'tl_class' === $ event -> getProperty ( ) -> getName ( ) ) ) ) { return ; } $ link = ' <a href="%1$s" onclick="Backend.getScrollOffset();Backend.openModalIframe({' . '\'width\':765,' . '\'title\':\'%2$s\',' . '\'url\':this.href,' . '\'id\':\'%3$s\'' . '});return false">%4$s</a>' ; $ image = $ this -> iconBuilder -> getBackendIconImageTag ( 'bundles/metamodelscore/images/icons/dca_wizard.png' , $ event -> getEnvironment ( ) -> getTranslator ( ) -> translate ( 'stylepicker' , 'tl_metamodel_dca' ) , 'style="vertical-align:top;"' ) ; $ event -> getWidget ( ) -> wizard = sprintf ( $ link , $ this -> urlGenerator -> generate ( 'metamodels.picker' , [ 'tbl' => $ event -> getEnvironment ( ) -> getDataDefinition ( ) -> getName ( ) , 'fld' => $ event -> getProperty ( ) -> getName ( ) , 'inputName' => 'ctrl_' . $ event -> getProperty ( ) -> getName ( ) , 'id' => $ event -> getModel ( ) -> getId ( ) , 'item' => 'PALETTE_STYLE_PICKER' , ] ) , addslashes ( $ event -> getEnvironment ( ) -> getTranslator ( ) -> translate ( 'stylepicker' , 'tl_metamodel_dca' ) ) , $ event -> getModel ( ) -> getId ( ) , $ image ) ; }
3768	private function resolvePath ( $ value ) { $ path = Path :: canonicalize ( $ value ) ; if ( '\\' === DIRECTORY_SEPARATOR ) { $ path = str_replace ( '/' , '\\' , $ path ) ; } return $ path ; }
1969	public static function findMultipleByIds ( $ arrIds , array $ arrOptions = array ( ) ) { if ( empty ( $ arrIds ) || ! \ is_array ( $ arrIds ) ) { return null ; } if ( Validator :: isUuid ( current ( $ arrIds ) ) ) { return static :: findMultipleByUuids ( $ arrIds , $ arrOptions ) ; } return parent :: findMultipleByIds ( $ arrIds , $ arrOptions ) ; }
8583	public function getLowestOfferListingsForSKU ( $ request ) { if ( ! ( $ request instanceof MarketplaceWebServiceProducts_Model_GetLowestOfferListingsForSKURequest ) ) { $ request = new MarketplaceWebServiceProducts_Model_GetLowestOfferListingsForSKURequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetLowestOfferListingsForSKU' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = MarketplaceWebServiceProducts_Model_GetLowestOfferListingsForSKUResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
8534	public function setChargeInstrumentList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ChargeInstrumentList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
8397	public function getDefinition ( ) : array { if ( $ this -> definition == null ) { $ data = Mapping :: get ( $ this -> mapping ) ; $ this -> definition = Config :: get ( $ data [ 'config' ] [ 'schema' ] ) ; } return $ this -> definition ; }
1934	protected function getDateString ( ) { return 'Locale.define("en-US","Date",{' . 'months:["' . implode ( '","' , $ GLOBALS [ 'TL_LANG' ] [ 'MONTHS' ] ) . '"],' . 'days:["' . implode ( '","' , $ GLOBALS [ 'TL_LANG' ] [ 'DAYS' ] ) . '"],' . 'months_abbr:["' . implode ( '","' , $ GLOBALS [ 'TL_LANG' ] [ 'MONTHS_SHORT' ] ) . '"],' . 'days_abbr:["' . implode ( '","' , $ GLOBALS [ 'TL_LANG' ] [ 'DAYS_SHORT' ] ) . '"]' . '});' . 'Locale.define("en-US","DatePicker",{' . 'select_a_time:"' . $ GLOBALS [ 'TL_LANG' ] [ 'DP' ] [ 'select_a_time' ] . '",' . 'use_mouse_wheel:"' . $ GLOBALS [ 'TL_LANG' ] [ 'DP' ] [ 'use_mouse_wheel' ] . '",' . 'time_confirm_button:"' . $ GLOBALS [ 'TL_LANG' ] [ 'DP' ] [ 'time_confirm_button' ] . '",' . 'apply_range:"' . $ GLOBALS [ 'TL_LANG' ] [ 'DP' ] [ 'apply_range' ] . '",' . 'cancel:"' . $ GLOBALS [ 'TL_LANG' ] [ 'DP' ] [ 'cancel' ] . '",' . 'week:"' . $ GLOBALS [ 'TL_LANG' ] [ 'DP' ] [ 'week' ] . '"' . '});' ; }
2178	private function addDefaultsToContext ( array $ context ) : array { $ context = array_merge ( $ this -> context , $ context ) ; if ( ! isset ( $ context [ 'request_token' ] ) ) { $ context [ 'request_token' ] = $ this -> getRequestToken ( ) ; } if ( ! isset ( $ context [ 'language' ] ) ) { $ context [ 'language' ] = $ this -> container -> get ( 'translator' ) -> getLocale ( ) ; } if ( ! isset ( $ context [ 'ua' ] ) ) { $ context [ 'ua' ] = $ this -> getUserAgentString ( ) ; } if ( ! isset ( $ context [ 'path' ] ) ) { $ request = $ this -> container -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; if ( null === $ request ) { throw new \ RuntimeException ( 'The request stack did not contain a request' ) ; } $ context [ 'host' ] = $ request -> getHost ( ) ; $ context [ 'path' ] = $ request -> getBasePath ( ) ; } return $ context ; }
441	public function hasMethod ( $ name , $ checkBehaviors = true ) { if ( method_exists ( $ this , $ name ) ) { return true ; } elseif ( $ checkBehaviors ) { $ this -> ensureBehaviors ( ) ; foreach ( $ this -> _behaviors as $ behavior ) { if ( $ behavior -> hasMethod ( $ name ) ) { return true ; } } } return false ; }
12429	public function getAuthorizerList ( $ offset = 0 , $ count = 500 ) { $ params = [ 'component_appid' => $ this -> getAppId ( ) , 'offset' => $ offset , 'count' => $ count , ] ; return $ this -> parseJSON ( 'json' , [ self :: GET_AUTHORIZER_LIST , $ params ] ) ; }
4564	public function kernelException ( GetResponseForExceptionEvent $ event ) { $ exception = $ event -> getException ( ) ; if ( ! $ exception instanceof NoPermissionsException ) { return ; } $ response = new JsonResponse ( [ ] ) ; $ event -> setResponse ( $ response ) ; }
8956	public function waysForNode ( $ id ) { $ base = 'node/' . $ id . '/ways' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ xmlString = $ this -> sendRequest ( $ path ) ; return $ xmlString -> way ; }
2205	public static function findPost ( $ strKey ) { if ( isset ( $ _POST [ $ strKey ] ) ) { return $ _POST [ $ strKey ] ; } $ request = System :: getContainer ( ) -> get ( 'request_stack' ) -> getMasterRequest ( ) ; if ( $ request === null || ! $ request -> hasPreviousSession ( ) ) { return null ; } if ( isset ( $ _SESSION [ 'FORM_DATA' ] [ $ strKey ] ) ) { return ( $ strKey == 'FORM_SUBMIT' ) ? preg_replace ( '/^auto_/i' , '' , $ _SESSION [ 'FORM_DATA' ] [ $ strKey ] ) : $ _SESSION [ 'FORM_DATA' ] [ $ strKey ] ; } return null ; }
6157	public function redirectSelf ( ) : object { $ url = $ this -> di -> get ( "request" ) -> getCurrentUrl ( ) ; return parent :: redirect ( $ this -> di -> get ( "url" ) -> create ( $ url ) ) ; }
6289	public function set ( $ theme ) { if ( ! $ this -> has ( $ theme ) ) { throw new ThemeNotFoundException ( $ theme ) ; } $ this -> loadTheme ( $ theme ) ; }
5072	public function getHtmlMenu ( $ markup , $ topLevel = 1 , $ depth = 6 , RendererInterface $ renderer = null ) { if ( ! $ renderer ) { $ renderer = new ListRenderer ( new Matcher ( ) , [ 'currentClass' => 'active' , 'ancestorClass' => 'active_ancestor' ] ) ; } return $ renderer -> render ( $ this -> getMenu ( $ markup , $ topLevel , $ depth ) ) ; }
2673	public function getSingleAcl ( $ version , $ acl ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/acl/' . $ acl ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: GET ) ; return $ result ; }
5986	public function getTokens ( ) { $ tokens = [ 'accessToken' => null , 'refreshToken' => null ] ; if ( $ this -> oauth2Middleware instanceof OAuthMiddleware ) { $ tokens [ 'accessToken' ] = $ this -> oauth2Middleware -> getAccessToken ( ) ; $ tokens [ 'refreshToken' ] = $ this -> oauth2Middleware -> getRefreshToken ( ) ; } if ( $ this -> cache instanceof Cache && empty ( $ tokens [ 'accessToken' ] ) && $ this -> cache -> contains ( 'oauth2accesstoken' ) ) { $ tokens [ 'accessToken' ] = unserialize ( $ this -> cache -> fetch ( 'oauth2accesstoken' ) ) ; } if ( $ this -> cache instanceof Cache && empty ( $ tokens [ 'accessToken' ] ) && $ this -> cache -> contains ( 'oauth2refreshtoken' ) ) { $ tokens [ 'refreshToken' ] = unserialize ( $ this -> cache -> fetch ( 'oauth2refreshtoken' ) ) ; } if ( empty ( $ tokens [ 'accessToken' ] ) ) { $ response = $ this -> getClient ( ) -> get ( '/' ) ; $ tokens [ 'accessToken' ] = $ this -> oauth2Middleware -> getAccessToken ( ) ; $ tokens [ 'refreshToken' ] = $ this -> oauth2Middleware -> getRefreshToken ( ) ; } return $ tokens ; }
2035	public function onUnregister ( Registry $ registry ) { parent :: onUnregister ( $ registry ) ; if ( $ this -> fallback && $ this -> type == 'root' && $ registry -> isRegisteredAlias ( $ this , 'contao.dns-fallback' , $ this -> dns ) ) { $ registry -> unregisterAlias ( $ this , 'contao.dns-fallback' , $ this -> dns ) ; } }
10551	public function determineVirtualHost ( ) { $ cfg = $ this -> config -> getSection ( 'site' ) ; $ vhost = self :: findVirtualHost ( $ this -> request -> webroot , $ this -> sites ) ; if ( $ vhost === null ) { $ result = $ this -> handleUnknownHost ( $ this -> request -> webroot , $ this -> request -> url , $ this -> sites , $ cfg ) ; if ( $ result === null ) throw new HTTPError ( 404 , "Not found: " . $ this -> url ) ; if ( $ result instanceof URL ) throw new RedirectRequest ( $ result , 301 ) ; if ( $ result instanceof VirtualHost ) { $ vhost = $ result ; $ site = $ vhost -> getSite ( ) ; if ( isset ( $ this -> sites [ $ site -> getName ( ) ] ) ) $ this -> sites [ $ site -> getName ( ) ] = $ site ; } else throw \ RuntimeException ( "Unexpected response from handleUnknownWebsite" ) ; } else { $ target = $ vhost -> getRedirect ( $ this -> request -> url ) ; if ( $ target ) throw new RedirectRequest ( $ target , 301 ) ; } $ this -> setVirtualHost ( $ vhost ) ; return $ this ; }
5585	public function isClickable ( $ label ) { return $ this -> isSubmit ( $ label ) || ( $ this -> getLink ( $ label ) !== false ) || $ this -> isImage ( $ label ) ; }
12485	public function adapterHasBehavior ( Adapter $ adapter , $ behavior ) { if ( $ adapter instanceof KnowsItsBehaviors ) { return in_array ( $ behavior , $ adapter -> getBehaviors ( ) ) ; } return true === is_a ( $ adapter , $ behavior ) ; }
2930	public function getValue ( $ key ) { $ allKeys = $ this -> getKeys ( [ $ key ] ) ; if ( array_key_exists ( $ key , $ allKeys ) ) { return $ allKeys [ $ key ] [ 'value' ] ; } throw new KeyNotFoundException ( 'Requested key not found in your file.' ) ; }
11144	protected function processClass ( $ class ) { if ( ! class_exists ( '\\' . $ class ) ) { throw new ExtDirectException ( " '{$class}' does not exist!" ) ; } $ annotationReader = new AnnotationReader ( ) ; AnnotationRegistry :: registerLoader ( 'class_exists' ) ; $ reflectionClass = new ReflectionClass ( $ class ) ; $ classAnnotation = $ annotationReader -> getClassAnnotation ( $ reflectionClass , 'ExtDirect\Annotations\Direct' ) ; if ( $ classAnnotation instanceof \ ExtDirect \ Annotations \ Direct ) { $ classAnnotation -> setClassName ( $ class ) ; $ methodCollection = new RemotableCollection ( ) ; foreach ( $ reflectionClass -> getMethods ( ) as $ reflectionMethod ) { $ methodAnnotation = $ annotationReader -> getMethodAnnotation ( $ reflectionMethod , 'ExtDirect\Annotations\Remotable' ) ; if ( $ methodAnnotation instanceof \ ExtDirect \ Annotations \ Remotable ) { $ methodAnnotation -> setMethodName ( $ reflectionMethod -> getName ( ) ) ; $ methodCollection -> add ( $ methodAnnotation ) ; } } $ classAnnotation -> setMethods ( $ methodCollection ) ; return $ classAnnotation ; } return false ; }
6176	public static function arrayUniqueMultidimensional ( array $ input ) { $ serialized = array_map ( 'serialize' , $ input ) ; $ unique = array_unique ( $ serialized ) ; $ output = array_intersect_key ( $ input , $ unique ) ; return array_values ( $ output ) ; }
9952	public function setBreak ( $ pCoordinate , $ pBreak ) { $ pCoordinate = strtoupper ( $ pCoordinate ) ; if ( $ pCoordinate != '' ) { if ( $ pBreak == self :: BREAK_NONE ) { if ( isset ( $ this -> breaks [ $ pCoordinate ] ) ) { unset ( $ this -> breaks [ $ pCoordinate ] ) ; } } else { $ this -> breaks [ $ pCoordinate ] = $ pBreak ; } } else { throw new Exception ( 'No cell coordinate specified.' ) ; } return $ this ; }
4870	private function entityToString ( EntityInterface $ entity ) { if ( method_exists ( $ entity , '__toString' ) ) { return $ entity -> __toString ( ) ; } $ str = get_class ( $ entity ) ; if ( $ entity instanceof \ Core \ Entity \ IdentifiableEntityInterface ) { $ str .= '( ' . $ entity -> getId ( ) . ' )' ; } return $ str ; }
5537	public function setFrame ( $ path , $ page ) { $ name = array_shift ( $ path ) ; if ( isset ( $ this -> names [ $ name ] ) ) { $ index = $ this -> names [ $ name ] ; } else { $ index = $ name - 1 ; } if ( count ( $ path ) === 0 ) { $ this -> frames [ $ index ] = $ page ; return ; } $ this -> frames [ $ index ] -> setFrame ( $ path , $ page ) ; }
11887	public function getUser ( $ owner = true ) { if ( $ owner && $ this -> owner -> getBehavior ( 'Ownable' ) !== null && isset ( $ this -> owner -> objectOwner ) ) { return $ this -> owner -> objectOwner ; } elseif ( isset ( Yii :: $ app -> user ) && isset ( Yii :: $ app -> user -> identity -> primaryKey ) ) { return Yii :: $ app -> user -> identity ; } return false ; }
2826	public function getRequestViewUrl ( $ panel = null , $ token = null ) { $ token = $ token ? : $ this -> getRequestInfo ( ) -> getToken ( ) ; return $ token ? Mage :: helper ( 'sheep_debug/url' ) -> getRequestViewUrl ( $ token , $ panel ) : '#' ; }
1416	public function invalidQueryParameter ( string $ param , ? string $ detail = null , array $ failed = [ ] ) : ErrorInterface { return new Error ( null , null , Response :: HTTP_BAD_REQUEST , $ this -> trans ( 'query_invalid' , 'code' ) , $ this -> trans ( 'query_invalid' , 'title' ) , $ detail ? : $ this -> trans ( 'query_invalid' , 'detail' ) , [ Error :: SOURCE_PARAMETER => $ param ] , $ failed ? compact ( 'failed' ) : null ) ; }
1003	public function parseHttpRequest ( ? callable $ readRawBodyFn = null ) { $ method = $ _SERVER [ 'REQUEST_METHOD' ] ?? null ; $ bodyParams = [ ] ; $ urlParams = $ _GET ; if ( $ method === 'POST' ) { $ contentType = $ _SERVER [ 'CONTENT_TYPE' ] ?? null ; if ( $ contentType === null ) { throw new RequestError ( 'Missing "Content-Type" header' ) ; } if ( stripos ( $ contentType , 'application/graphql' ) !== false ) { $ rawBody = $ readRawBodyFn ? $ readRawBodyFn ( ) : $ this -> readRawBody ( ) ; $ bodyParams = [ 'query' => $ rawBody ? : '' ] ; } elseif ( stripos ( $ contentType , 'application/json' ) !== false ) { $ rawBody = $ readRawBodyFn ? $ readRawBodyFn ( ) : $ this -> readRawBody ( ) ; $ bodyParams = json_decode ( $ rawBody ? : '' , true ) ; if ( json_last_error ( ) ) { throw new RequestError ( 'Could not parse JSON: ' . json_last_error_msg ( ) ) ; } if ( ! is_array ( $ bodyParams ) ) { throw new RequestError ( 'GraphQL Server expects JSON object or array, but got ' . Utils :: printSafeJson ( $ bodyParams ) ) ; } } elseif ( stripos ( $ contentType , 'application/x-www-form-urlencoded' ) !== false ) { $ bodyParams = $ _POST ; } elseif ( stripos ( $ contentType , 'multipart/form-data' ) !== false ) { $ bodyParams = $ _POST ; } else { throw new RequestError ( 'Unexpected content type: ' . Utils :: printSafeJson ( $ contentType ) ) ; } } return $ this -> parseRequestParams ( $ method , $ bodyParams , $ urlParams ) ; }
7893	public function add ( $ property_name , $ value ) { $ this -> validateProperty ( $ property_name , $ value ) ; $ this -> data [ $ property_name ] [ ] = & $ value ; return $ this ; }
12240	public function getElementsByClassName ( $ class ) { if ( strpos ( $ class , '"' ) !== false || strpos ( $ class , "'" ) !== false ) { return array ( ) ; } $ xpath = './/*[contains(concat(" ", @class, " "), " ' . htmlspecialchars ( $ class ) . ' ")]' ; return $ this -> xpath ( $ xpath ) ; }
5933	public function setStartDate ( $ startDate ) { if ( $ startDate instanceof DateTime ) { $ this -> startDate = $ startDate ; } else { try { $ this -> startDate = new DateTime ( $ startDate ) ; } catch ( \ Exception $ e ) { $ this -> startDate = null ; } } return $ this ; }
2409	public static function getInstance ( $ strTable ) { if ( ! isset ( static :: $ arrInstances [ $ strTable ] ) ) { static :: $ arrInstances [ $ strTable ] = new static ( $ strTable ) ; } return static :: $ arrInstances [ $ strTable ] ; }
257	public function init ( ) { parent :: init ( ) ; if ( is_array ( $ this -> theme ) ) { if ( ! isset ( $ this -> theme [ 'class' ] ) ) { $ this -> theme [ 'class' ] = 'yii\base\Theme' ; } $ this -> theme = Yii :: createObject ( $ this -> theme ) ; } elseif ( is_string ( $ this -> theme ) ) { $ this -> theme = Yii :: createObject ( $ this -> theme ) ; } }
1234	private function toXml ( $ elementName , $ rootElement = false ) { return sprintf ( '%s<%s%s%s>%s</%s>' , $ rootElement ? "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" : '' , $ elementName , $ this -> attributesToXml ( ) , array_key_exists ( get_class ( $ this ) , self :: $ xmlNamespaces ) ? sprintf ( ' %s' , self :: $ xmlNamespaces [ get_class ( $ this ) ] ) : '' , $ this -> propertiesToXml ( ) , $ elementName ) ; }
176	public static function removeValue ( & $ array , $ value ) { $ result = [ ] ; if ( is_array ( $ array ) ) { foreach ( $ array as $ key => $ val ) { if ( $ val === $ value ) { $ result [ $ key ] = $ val ; unset ( $ array [ $ key ] ) ; } } } return $ result ; }
12606	public static function getPath ( string $ file ) { $ parts = explode ( '/' , $ file ) ; array_pop ( $ parts ) ; return implode ( '/' , $ parts ) ; }
11789	public function filesAction ( Request $ request , Application $ app ) { $ options = array ( "connector" => $ app [ "red_kite_cms.elfinder_files_connector" ] , ) ; return parent :: show ( $ options ) ; }
9858	private function isValueInList ( Cell $ cell ) { $ cellValue = $ cell -> getValue ( ) ; $ dataValidation = $ cell -> getDataValidation ( ) ; $ formula1 = $ dataValidation -> getFormula1 ( ) ; if ( ! empty ( $ formula1 ) ) { if ( $ formula1 [ 0 ] === '"' ) { return in_array ( strtolower ( $ cellValue ) , explode ( ',' , strtolower ( trim ( $ formula1 , '"' ) ) ) , true ) ; } elseif ( strpos ( $ formula1 , ':' ) > 0 ) { $ matchFormula = '=MATCH(' . $ cell -> getCoordinate ( ) . ', ' . $ formula1 . ', 0)' ; $ calculation = Calculation :: getInstance ( $ cell -> getWorksheet ( ) -> getParent ( ) ) ; try { $ result = $ calculation -> calculateFormula ( $ matchFormula , $ cell -> getCoordinate ( ) , $ cell ) ; return $ result !== Functions :: NA ( ) ; } catch ( Exception $ ex ) { return false ; } } } return true ; }
6914	public function removeShipment ( ShipmentInterface $ shipment ) { if ( $ this -> shipments -> contains ( $ shipment ) ) { $ this -> shipments -> removeElement ( $ shipment ) ; } return $ this ; }
2560	private function checkAndCreateMopDetailedData ( $ fopType ) { if ( is_null ( $ this -> paymentModule -> mopDetailedData ) ) { $ this -> paymentModule -> mopDetailedData = new MopDetailedData ( $ fopType ) ; } }
11591	private function upload ( $ path , $ payload ) { return Storage :: disk ( 's3' ) -> put ( $ path , $ payload , $ this -> visibility ) ; }
4469	public function cancel ( $ dependents = false ) : array { if ( $ dependents && ! empty ( $ this -> rawData [ 'dependents' ] ) ) { return call_user_func_array ( [ $ this -> client , 'cancel' ] , array_merge ( [ $ this -> jid ] , $ this -> rawData [ 'dependents' ] ) ) ; } return $ this -> client -> cancel ( $ this -> jid ) ; }
4795	function aggregation ( $ function ) { $ join = $ this -> createJoins ( implode ( "," , $ this -> conditions ) . ",$function" ) ; $ query = "SELECT $function FROM $this->table" . implode ( $ join ) ; if ( $ this -> where ) { $ query .= " WHERE " . implode ( $ this -> where ) ; } foreach ( $ this -> query ( $ query , $ this -> parameters ) -> fetch ( ) as $ return ) { return $ return ; } }
8811	public function header ( $ key , $ value ) { if ( is_array ( $ key ) && ! empty ( $ key ) ) { foreach ( $ key as $ k => $ v ) { $ this -> headers -> set ( $ k , $ v ) ; } } elseif ( is_string ( $ key ) && ! empty ( $ key ) ) { $ this -> headers -> set ( $ key , $ value ) ; } return $ this ; }
716	public function decimal ( $ precision = null , $ scale = null ) { $ length = [ ] ; if ( $ precision !== null ) { $ length [ ] = $ precision ; } if ( $ scale !== null ) { $ length [ ] = $ scale ; } return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_DECIMAL , $ length ) ; }
3186	public function start ( $ tags , $ timestamp ) { if ( ! is_numeric ( $ timestamp ) || $ timestamp < 0 ) { throw new InvalidDataException ( 'start() needs a valid timestamp!' ) ; } $ range = $ this -> getRange ( $ tags ) ; if ( $ this -> isRangeOpen ( $ range ) ) { \ common_Logger :: t ( 'Missing END TimePoint in QtiTimer, auto add an arbitrary value' ) ; $ point = new TimePoint ( $ tags , $ timestamp - ( 1 / TimePoint :: PRECISION ) , TimePoint :: TYPE_END , TimePoint :: TARGET_SERVER ) ; $ this -> timeLine -> add ( $ point ) ; $ range [ ] = $ point ; } $ this -> checkTimestampCoherence ( $ range , $ timestamp ) ; $ point = new TimePoint ( $ tags , $ timestamp , TimePoint :: TYPE_START , TimePoint :: TARGET_SERVER ) ; $ this -> timeLine -> add ( $ point ) ; return $ this ; }
10105	private function writeDefaultRowHeight ( ) { $ defaultRowHeight = $ this -> phpSheet -> getDefaultRowDimension ( ) -> getRowHeight ( ) ; if ( $ defaultRowHeight < 0 ) { return ; } $ defaultRowHeight = ( int ) 20 * $ defaultRowHeight ; $ record = 0x0225 ; $ length = 0x0004 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vv' , 1 , $ defaultRowHeight ) ; $ this -> append ( $ header . $ data ) ; }
12134	public function index ( QuestionRequest $ request ) { $ view = $ this -> response -> theme -> listView ( ) ; if ( $ this -> response -> typeIs ( 'json' ) ) { $ function = camel_case ( 'get-' . $ view ) ; return $ this -> repository -> setPresenter ( \ Litecms \ Forum \ Repositories \ Presenter \ QuestionPresenter :: class ) -> $ function ( ) ; } $ user_id = user_id ( ) ; $ questions = $ this -> repository -> questions ( $ user_id ) ; return $ this -> response -> title ( trans ( 'forum::question.names' ) ) -> view ( 'forum::question.index' , true ) -> data ( compact ( 'questions' , 'view' ) ) -> output ( ) ; }
6992	static protected function getCacheKeyForOptimizedUiTemplatesBasedOnUserId ( $ group ) : string { if ( static :: getAuthModule ( ) -> getAccessPolicyClassName ( ) === CmfAccessPolicy :: class ) { $ userId = 'any' ; } else { $ user = static :: getUser ( ) ; $ userId = $ user ? $ user -> getAuthIdentifier ( ) : 'not_authenticated' ; } return static :: url_prefix ( ) . '_templates_' . static :: getShortLocale ( ) . '_' . $ group . '_user_' . $ userId ; }
12851	public function beforeDeleteById ( \ Magento \ Customer \ Api \ CustomerRepositoryInterface $ subject , $ customerId ) { $ this -> deleteDwnl ( $ customerId ) ; $ result = [ $ customerId ] ; return $ result ; }
12175	public function addOptionalScalarArgument ( $ name , $ type , $ default ) { return $ this -> addArgument ( new ScalarArgument ( $ this -> argumentPosition ++ , $ name , $ type , false , $ default ) ) ; }
2347	public function getContent ( ) { $ strContent = file_get_contents ( $ this -> strRootDir . '/' . ( $ this -> strTmp ? : $ this -> strFile ) ) ; if ( strncmp ( $ strContent , "\xEF\xBB\xBF" , 3 ) === 0 ) { $ strContent = substr ( $ strContent , 3 ) ; } elseif ( strncmp ( $ strContent , "\xFF\xFE" , 2 ) === 0 ) { $ strContent = substr ( $ strContent , 2 ) ; } elseif ( strncmp ( $ strContent , "\xFE\xFF" , 2 ) === 0 ) { $ strContent = substr ( $ strContent , 2 ) ; } return $ strContent ; }
842	public function offsetSet ( $ index , $ newval ) { $ this -> blockEndCache = [ ] ; if ( ! $ this [ $ index ] || ! $ this [ $ index ] -> equals ( $ newval ) ) { $ this -> changed = true ; if ( isset ( $ this [ $ index ] ) ) { $ this -> unregisterFoundToken ( $ this [ $ index ] ) ; } $ this -> registerFoundToken ( $ newval ) ; } parent :: offsetSet ( $ index , $ newval ) ; }
4321	public static function arrayPathGet ( $ array , $ path ) { if ( ! \ is_array ( $ path ) ) { $ path = \ array_filter ( \ preg_split ( '#[\./]#' , $ path ) , 'strlen' ) ; } $ path = \ array_reverse ( $ path ) ; while ( $ path ) { $ key = \ array_pop ( $ path ) ; $ arrayAccess = \ is_array ( $ array ) || $ array instanceof \ ArrayAccess ; if ( ! $ arrayAccess ) { return null ; } elseif ( isset ( $ array [ $ key ] ) ) { $ array = $ array [ $ key ] ; } elseif ( $ key == '__count__' ) { return \ count ( $ array ) ; } elseif ( $ key == '__end__' ) { \ end ( $ array ) ; $ path [ ] = \ key ( $ array ) ; } elseif ( $ key == '__reset__' ) { \ reset ( $ array ) ; $ path [ ] = \ key ( $ array ) ; } else { return null ; } } return $ array ; }
9344	public function addCol ( $ arr_col ) { if ( isset ( $ this -> arr [ 0 ] ) && ( count ( $ this -> arr [ 0 ] ) == $ this -> size -> cols ) ) { throw new \ OutOfRangeException ( sprintf ( 'You cannot add another column! Max number of columns is %d' , $ this -> size -> cols ) ) ; } if ( count ( $ arr_col ) != $ this -> size -> rows ) { throw new \ InvalidArgumentException ( 'New column must have same amout of rows than previous columns.' ) ; } $ arr_col = array_values ( $ arr_col ) ; foreach ( $ arr_col as $ k => $ v ) { $ this -> arr [ $ k ] [ ] = $ arr_col [ $ k ] ; } return $ this ; }
7546	function setNamespace ( $ ns ) { if ( $ this -> getNamespace ( ) !== $ ns ) { $ this -> tag_ns [ 0 ] = $ ns ; $ this -> tag = $ ns . ':' . $ this -> tag_ns [ 1 ] ; } }
9843	public function createSignedJsonRequest ( string $ method , string $ uri , array $ arrayToJsonify , SigningSecretKey $ key , array $ headers = [ ] ) : RequestInterface { if ( empty ( $ headers [ 'Content-Type' ] ) ) { $ headers [ 'Content-Type' ] = 'application/json' ; } $ body = \ json_encode ( $ arrayToJsonify , JSON_PRETTY_PRINT ) ; if ( ! \ is_string ( $ body ) ) { throw new InvalidMessageException ( 'Cannot JSON-encode this message.' ) ; } return $ this -> createSignedRequest ( $ method , $ uri , $ body , $ key , $ headers ) ; }
2520	public function queuePlacePnr ( RequestOptions \ QueuePlacePnrOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'Queue_PlacePNR' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; }
8468	public static function getActiveHandlersList ( ) { $ cacheKey = 'DevGroup/EventsSystem:activeHandlersList' ; $ handlers = Yii :: $ app -> cache -> get ( $ cacheKey ) ; if ( $ handlers === false ) { $ eventEventHandlers = EventEventHandler :: find ( ) -> where ( [ 'is_active' => 1 ] ) -> orderBy ( [ 'sort_order' => SORT_ASC ] ) -> asArray ( true ) -> all ( ) ; $ events = Event :: find ( ) -> where ( [ 'id' => array_column ( $ eventEventHandlers , 'event_id' , 'event_id' ) ] ) -> indexBy ( 'id' ) -> asArray ( true ) -> all ( ) ; $ eventGroups = EventGroup :: find ( ) -> where ( [ 'id' => array_column ( $ events , 'event_group_id' , 'event_group_id' ) ] ) -> indexBy ( 'id' ) -> asArray ( true ) -> all ( ) ; $ eventHandlers = EventHandler :: find ( ) -> where ( [ 'id' => array_column ( $ eventEventHandlers , 'event_handler_id' , 'event_handler_id' ) ] ) -> indexBy ( 'id' ) -> asArray ( true ) -> all ( ) ; $ handlers = [ ] ; foreach ( $ eventEventHandlers as $ eventEventHandler ) { if ( isset ( $ eventHandlers [ $ eventEventHandler [ 'event_handler_id' ] ] , $ events [ $ eventEventHandler [ 'event_id' ] ] , $ eventGroups [ $ events [ $ eventEventHandler [ 'event_id' ] ] [ 'event_group_id' ] ] ) === false ) { continue ; } try { $ data = Json :: decode ( $ eventEventHandler [ 'packed_json_params' ] ) ; } catch ( \ Exception $ e ) { $ data = [ ] ; } $ handlers [ ] = [ 'class' => $ eventGroups [ $ events [ $ eventEventHandler [ 'event_id' ] ] [ 'event_group_id' ] ] [ 'owner_class_name' ] , 'name' => $ events [ $ eventEventHandler [ 'event_id' ] ] [ 'execution_point' ] , 'callable' => [ $ eventHandlers [ $ eventEventHandler [ 'event_handler_id' ] ] [ 'class_name' ] , $ eventEventHandler [ 'method' ] , ] , 'data' => $ data , ] ; } Yii :: $ app -> cache -> set ( $ cacheKey , $ handlers , 86400 , new TagDependency ( [ 'tags' => [ NamingHelper :: getCommonTag ( EventGroup :: className ( ) ) , NamingHelper :: getCommonTag ( Event :: className ( ) ) , NamingHelper :: getCommonTag ( EventHandler :: className ( ) ) , NamingHelper :: getCommonTag ( EventEventHandler :: className ( ) ) , ] , ] ) ) ; } return $ handlers ; }
11687	public function getAccompanyingPeriodsOrdered ( ) { $ periods = $ this -> getAccompanyingPeriods ( ) -> toArray ( ) ; usort ( $ periods , function ( $ a , $ b ) { $ dateA = $ a -> getOpeningDate ( ) ; $ dateB = $ b -> getOpeningDate ( ) ; if ( $ dateA == $ dateB ) { $ dateEA = $ a -> getClosingDate ( ) ; $ dateEB = $ b -> getClosingDate ( ) ; if ( $ dateEA == $ dateEB ) { return 0 ; } if ( $ dateEA < $ dateEB ) { return - 1 ; } else { return + 1 ; } } if ( $ dateA < $ dateB ) { return - 1 ; } else { return 1 ; } } ) ; return $ periods ; }
2022	public static function findFirstPublishedRootByHostAndLanguage ( $ strHost , $ varLanguage , array $ arrOptions = array ( ) ) { @ trigger_error ( 'Using PageModel::findFirstPublishedRootByHostAndLanguage() has been deprecated and will no longer work Contao 5.0.' , E_USER_DEPRECATED ) ; $ t = static :: $ strTable ; $ objDatabase = Database :: getInstance ( ) ; if ( \ is_array ( $ varLanguage ) ) { $ arrColumns = array ( "$t.type='root' AND ($t.dns=? OR $t.dns='')" ) ; if ( ! empty ( $ varLanguage ) ) { $ arrColumns [ ] = "($t.language IN('" . implode ( "','" , $ varLanguage ) . "') OR $t.fallback='1')" ; } else { $ arrColumns [ ] = "$t.fallback='1'" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.dns DESC" . ( ! empty ( $ varLanguage ) ? ", " . $ objDatabase -> findInSet ( "$t.language" , array_reverse ( $ varLanguage ) ) . " DESC" : "" ) . ", $t.sorting" ; } if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } return static :: findOneBy ( $ arrColumns , $ strHost , $ arrOptions ) ; } else { $ arrColumns = array ( "$t.type='root' AND ($t.dns=? OR $t.dns='') AND ($t.language=? OR $t.fallback='1')" ) ; $ arrValues = array ( $ strHost , $ varLanguage ) ; if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.dns DESC, $t.fallback" ; } if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } return static :: findOneBy ( $ arrColumns , $ arrValues , $ arrOptions ) ; } }
4657	public function run ( Job $ job , $ command ) { if ( is_string ( $ command ) ) { $ command = [ '/bin/bash' , '-c' , $ command ] ; } $ image = $ this -> docker -> getImageManager ( ) -> find ( $ job -> getName ( ) ) ; $ hostConfig = new HostConfig ( ) ; $ config = new ContainerConfig ( ) ; $ config -> setCmd ( $ command ) ; $ config -> setImage ( $ image -> getId ( ) ) ; $ config -> setHostConfig ( $ hostConfig ) ; $ config -> setLabels ( new \ ArrayObject ( [ 'com.jolici.container=true' ] ) ) ; $ config -> setAttachStderr ( true ) ; $ config -> setAttachStdout ( true ) ; $ links = [ ] ; foreach ( $ job -> getServices ( ) as $ service ) { if ( $ service -> getContainer ( ) ) { $ serviceContainer = $ this -> docker -> getContainerManager ( ) -> find ( $ service -> getContainer ( ) ) ; $ links [ ] = sprintf ( '%s:%s' , $ serviceContainer -> getName ( ) , $ service -> getName ( ) ) ; } } $ hostConfig -> setLinks ( $ links ) ; $ containerCreateResult = $ this -> docker -> getContainerManager ( ) -> create ( $ config ) ; $ attachStream = $ this -> docker -> getContainerManager ( ) -> attach ( $ containerCreateResult -> getId ( ) , [ 'stream' => true , 'stdout' => true , 'stderr' => true , ] , ContainerManager :: FETCH_STREAM ) ; $ attachStream -> onStdout ( $ this -> logger -> getRunStdoutCallback ( ) ) ; $ attachStream -> onStderr ( $ this -> logger -> getRunStderrCallback ( ) ) ; $ this -> docker -> getContainerManager ( ) -> start ( $ containerCreateResult -> getId ( ) ) ; $ attachStream -> wait ( ) ; $ containerWait = $ this -> docker -> getContainerManager ( ) -> wait ( $ containerCreateResult -> getId ( ) ) ; return $ containerWait -> getStatusCode ( ) ; }
1167	protected function validateJsRemoteRequest ( $ attribute , $ parameters ) { $ this -> setRemoteValidation ( $ attribute , $ parameters [ 'validate_all' ] ) ; $ validator = $ this -> validator ; if ( $ validator -> passes ( ) ) { return true ; } return $ validator -> messages ( ) -> get ( $ attribute ) ; }
12115	public static function getExceptionTree ( \ Throwable $ Throwable ) { $ exception = get_class ( $ Throwable ) ; for ( $ exception_tree [ ] = $ exception ; $ exception = get_parent_class ( $ exception ) ; $ exception_tree [ ] = $ exception ) { ; } $ exception_tree = array_reverse ( $ exception_tree ) ; if ( count ( $ exception_tree ) > 1 ) { array_shift ( $ exception_tree ) ; } return $ exception_tree ; }
2984	protected function peek ( $ nb = 1 ) { $ i = 0 ; $ tokens = $ this -> tokens ; while ( $ token = array_shift ( $ tokens ) ) { if ( is_array ( $ token ) && in_array ( $ token [ 0 ] , array ( T_WHITESPACE , T_COMMENT , T_DOC_COMMENT ) ) ) { continue ; } ++ $ i ; if ( $ i == $ nb ) { return $ token ; } } }
8288	protected function loadModules ( ) { foreach ( $ this -> config [ "authModules" ] as $ name ) { try { $ instance = $ this -> container -> get ( $ name ) ; } catch ( \ League \ Container \ Exception \ NotFoundException $ e ) { if ( ! class_exists ( $ name ) ) { throw new \ RuntimeException ( "PicoAuth module not found: " . $ name ) ; } $ instance = new $ name ; } if ( ! is_subclass_of ( $ instance , Module \ AbstractAuthModule :: class , false ) ) { throw new \ RuntimeException ( "PicoAuth module class must inherit from AbstractAuthModule." ) ; } $ name = $ instance -> getName ( ) ; $ this -> modules [ $ name ] = $ instance ; } }
1337	protected function getQueryParameters ( EncodingParametersInterface $ parameters ) { return new EncodingParameters ( $ parameters -> getIncludePaths ( ) , $ parameters -> getFieldSets ( ) , $ parameters -> getSortParameters ( ) ? : $ this -> defaultSort ( ) , $ parameters -> getPaginationParameters ( ) ? : $ this -> defaultPagination ( ) , $ parameters -> getFilteringParameters ( ) , $ parameters -> getUnrecognizedParameters ( ) ) ; }
5167	protected function filterDateInstance ( $ date ) : string { if ( empty ( $ date ) ) { $ date = new \ DateTime ( 'now' , new \ DateTimeZone ( 'Asia/Jakarta' ) ) ; } if ( is_string ( $ date ) || is_int ( $ date ) ) { $ date = new \ DateTime ( $ date , new \ DateTimeZone ( 'Asia/Jakarta' ) ) ; } return $ this -> formatDate ( $ date ) ; }
12912	public function join ( BaseManager $ manager , $ type = null , $ column = null , $ column_right = null ) { $ this -> joins [ $ manager -> table ] = array ( 'manager' => $ manager , 'type' => $ type , 'column' => $ column , 'column_right' => $ column_right ) ; return $ this ; }
12100	public function priceBrutto ( $ netto , $ tax ) { $ tax = round ( ( double ) $ tax / 100.0 , 2 ) ; if ( $ tax < 0.00 ) { throw new Exception ( sprintf ( 'Tax must be greater than or equal to 0, given %s.' , $ tax ) ) ; } if ( $ tax === 0.00 ) { return $ netto ; } $ result = $ netto * ( $ tax + 1 ) ; return round ( $ result , 2 , PHP_ROUND_HALF_UP ) ; }
9594	public function makeSessionHandler ( ) { $ handler = $ this -> dic -> resolve ( 'Autarky\Http\SessionHandlerFactory' ) -> makeHandler ( $ this -> config -> get ( 'session.handler' ) ) ; if ( $ this -> config -> get ( 'session.write_check' ) === true ) { $ handler = new WriteCheckSessionHandler ( $ handler ) ; } return $ handler ; }
10295	public static function dayStringToNumber ( $ day ) { $ strippedDayValue = ( str_replace ( self :: $ numberSuffixes , '' , $ day ) ) ; if ( is_numeric ( $ strippedDayValue ) ) { return ( int ) $ strippedDayValue ; } return $ day ; }
3675	private function collectAttributeFactories ( $ container ) { $ attributeFactory = $ container -> getDefinition ( 'metamodels.attribute_factory' ) ; foreach ( array_keys ( $ container -> findTaggedServiceIds ( self :: TAG_ATTRIBUTE_FACTORY ) ) as $ factory ) { $ attributeFactory -> addMethodCall ( 'addTypeFactory' , [ new Reference ( $ factory ) ] ) ; } }
3292	public function twitter ( ) { if ( is_null ( $ this -> title ) ) { $ this -> title = config ( 'laravel-share.services.twitter.text' ) ; } $ base = config ( 'laravel-share.services.twitter.uri' ) ; $ url = $ base . '?text=' . urlencode ( $ this -> title ) . '&url=' . $ this -> url ; $ this -> buildLink ( 'twitter' , $ url ) ; return $ this ; }
9003	protected function extra_tablenav ( $ which ) { if ( $ which !== 'top' ) { return ; } $ this -> months_dropdown ( '' ) ; $ selected = isset ( $ _GET [ 'level' ] ) ? $ _GET [ 'level' ] : '' ; ?> <label for="filter-by-level" class="screen-reader-text"> <?php echo $ this -> translations [ 'levelFilterLabel' ] ; ?> </label> <select name="level" id="filter-by-level"> <option value=""> <?php echo $ this -> translations [ 'allLevels' ] ; ?> </option> <?php foreach ( $ this -> get_levels ( ) as $ level => $ label ) : ?> <option value=" <?php echo esc_attr ( $ level ) ; ?> " <?php selected ( $ selected , $ level ) ; ?> > <?php echo $ label ; ?> </option> <?php endforeach ; ?> </select> <?php submit_button ( $ this -> translations [ 'filter' ] , 'button' , 'filter_action' , false ) ; }
12541	public static function random ( $ length = 8 , $ allowedChars = 'abcdefghjkmnpqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXY346789' ) { $ return = '' ; $ hashLength = strlen ( $ allowedChars ) - 1 ; for ( ; $ length > 0 ; -- $ length ) { $ return .= $ allowedChars { rand ( 0 , $ hashLength ) } ; } return str_shuffle ( $ return ) ; }
6000	public function setImagetemplates ( array $ imagetemplates ) { $ this -> imagetemplates = [ ] ; foreach ( $ imagetemplates as $ item ) { $ this -> addImageTemplate ( $ item ) ; } return $ this ; }
3217	function chunkedUploadContinue ( $ uploadId , $ byteOffset , $ data ) { Checker :: argStringNonEmpty ( "uploadId" , $ uploadId ) ; Checker :: argNat ( "byteOffset" , $ byteOffset ) ; Checker :: argString ( "data" , $ data ) ; $ response = $ this -> _chunkedUpload ( array ( "upload_id" => $ uploadId , "offset" => $ byteOffset ) , $ data ) ; if ( $ response -> statusCode === 404 ) { return false ; } $ correction = self :: _chunkedUploadCheckForOffsetCorrection ( $ response ) ; if ( $ correction !== null ) { list ( $ correctedUploadId , $ correctedByteOffset ) = $ correction ; if ( $ correctedUploadId !== $ uploadId ) throw new Exception_BadResponse ( "Corrective 400 upload_id mismatch: us=" . Util :: q ( $ uploadId ) . " server=" . Util :: q ( $ correctedUploadId ) ) ; if ( $ correctedByteOffset === $ byteOffset ) throw new Exception_BadResponse ( "Corrective 400 offset is the same as ours: $byteOffset" ) ; return $ correctedByteOffset ; } if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; list ( $ retUploadId , $ retByteOffset ) = self :: _chunkedUploadParse200Response ( $ response -> body ) ; $ nextByteOffset = $ byteOffset + strlen ( $ data ) ; if ( $ uploadId !== $ retUploadId ) throw new Exception_BadResponse ( "upload_id mismatch: us=" . Util :: q ( $ uploadId ) . ", server=" . Util :: q ( $ uploadId ) ) ; if ( $ nextByteOffset !== $ retByteOffset ) throw new Exception_BadResponse ( "next-offset mismatch: us=$nextByteOffset, server=$retByteOffset" ) ; return true ; }
264	protected function escapeColumnName ( $ columnName , & $ params = [ ] ) { if ( $ columnName instanceof Query ) { list ( $ sql , $ params ) = $ this -> queryBuilder -> build ( $ columnName , $ params ) ; return "($sql)" ; } elseif ( $ columnName instanceof ExpressionInterface ) { return $ this -> queryBuilder -> buildExpression ( $ columnName , $ params ) ; } elseif ( strpos ( $ columnName , '(' ) === false ) { return $ this -> queryBuilder -> db -> quoteColumnName ( $ columnName ) ; } return $ columnName ; }
1403	private function parse ( ) { if ( ! $ this -> response ) { return [ ] ; } $ body = json_decode ( ( string ) $ this -> response -> getBody ( ) , true ) ; return isset ( $ body [ 'errors' ] ) ? $ body [ 'errors' ] : [ ] ; }
8705	public function extend ( EloquentBuilder $ builder ) { $ builder -> macro ( 'onlyTranslated' , function ( EloquentBuilder $ builder , $ locale = null ) { $ builder -> getModel ( ) -> setOnlyTranslated ( true ) ; if ( $ locale ) { $ builder -> getModel ( ) -> setLocale ( $ locale ) ; } return $ builder ; } ) ; $ builder -> macro ( 'withUntranslated' , function ( EloquentBuilder $ builder ) { $ builder -> getModel ( ) -> setOnlyTranslated ( false ) ; return $ builder ; } ) ; $ builder -> macro ( 'withFallback' , function ( EloquentBuilder $ builder , $ fallbackLocale = null ) { $ builder -> getModel ( ) -> setWithFallback ( true ) ; if ( $ fallbackLocale ) { $ builder -> getModel ( ) -> setFallbackLocale ( $ fallbackLocale ) ; } return $ builder ; } ) ; $ builder -> macro ( 'withoutFallback' , function ( EloquentBuilder $ builder ) { $ builder -> getModel ( ) -> setWithFallback ( false ) ; return $ builder ; } ) ; $ builder -> macro ( 'translateInto' , function ( EloquentBuilder $ builder , $ locale ) { if ( $ locale ) { $ builder -> getModel ( ) -> setLocale ( $ locale ) ; } return $ builder ; } ) ; $ builder -> macro ( 'withoutTranslations' , function ( EloquentBuilder $ builder ) { $ builder -> withoutGlobalScope ( static :: class ) ; return $ builder ; } ) ; $ builder -> macro ( 'withAllTranslations' , function ( EloquentBuilder $ builder ) { $ builder -> withoutGlobalScope ( static :: class ) -> with ( 'translations' ) ; return $ builder ; } ) ; }
800	private function findStart ( Tokens $ tokens , $ index ) { while ( ! $ tokens [ $ index ] -> equalsAny ( [ '$' , [ T_VARIABLE ] ] ) ) { if ( $ tokens [ $ index ] -> equals ( ']' ) ) { $ index = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_INDEX_SQUARE_BRACE , $ index ) ; } elseif ( $ tokens [ $ index ] -> isGivenKind ( CT :: T_DYNAMIC_PROP_BRACE_CLOSE ) ) { $ index = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_DYNAMIC_PROP_BRACE , $ index ) ; } elseif ( $ tokens [ $ index ] -> isGivenKind ( CT :: T_DYNAMIC_VAR_BRACE_CLOSE ) ) { $ index = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_DYNAMIC_VAR_BRACE , $ index ) ; } elseif ( $ tokens [ $ index ] -> isGivenKind ( CT :: T_ARRAY_INDEX_CURLY_BRACE_CLOSE ) ) { $ index = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_ARRAY_INDEX_CURLY_BRACE , $ index ) ; } else { $ index = $ tokens -> getPrevMeaningfulToken ( $ index ) ; } } while ( $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ index ) ] -> equals ( '$' ) ) { $ index = $ tokens -> getPrevMeaningfulToken ( $ index ) ; } if ( $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ index ) ] -> isGivenKind ( T_OBJECT_OPERATOR ) ) { return $ this -> findStart ( $ tokens , $ tokens -> getPrevMeaningfulToken ( $ index ) ) ; } return $ index ; }
10966	public static function getScheme ( ) { $ protocol = isset ( $ _SERVER [ 'REQUEST_SCHEME' ] ) ? strtolower ( $ _SERVER [ 'REQUEST_SCHEME' ] ) : 'http' ; if ( $ protocol == 'http' && self :: isSsl ( ) ) { $ protocol .= 's' ; } return $ protocol ; }
7135	public function getPercent ( ) : float { $ amount = $ this -> getAmount ( ) ; if ( 0 < $ this -> sellingPrice ) { return round ( $ amount * 100 / $ this -> sellingPrice , 2 ) ; } return 0 ; }
1715	public function hasAccess ( $ field , $ array ) { if ( $ this -> isAdmin ) { return true ; } if ( ! \ is_array ( $ field ) ) { $ field = array ( $ field ) ; } if ( \ is_array ( $ this -> $ array ) && array_intersect ( $ field , $ this -> $ array ) ) { return true ; } elseif ( $ array == 'filemounts' ) { foreach ( $ this -> filemounts as $ folder ) { if ( preg_match ( '/^' . preg_quote ( $ folder , '/' ) . '(\/|$)/i' , $ field [ 0 ] ) ) { return true ; } } } return false ; }
4594	public function postLoad ( LifecycleEventArgs $ args ) { $ entity = $ args -> getEntity ( ) ; if ( ! $ entity instanceof Parameter ) { return ; } $ key = $ entity -> getKey ( ) ; $ encrypt = $ this -> parameterCollection -> get ( $ key ) [ 'encrypt' ] ; $ entity -> setEncrypt ( $ encrypt ) ; }
595	private function deletePublishedAssets ( $ bundles ) { $ this -> stdout ( "Deleting source files...\n" ) ; if ( $ this -> getAssetManager ( ) -> linkAssets ) { $ this -> stdout ( "`AssetManager::linkAssets` option is enabled. Deleting of source files canceled.\n" , Console :: FG_YELLOW ) ; return ; } foreach ( $ bundles as $ bundle ) { if ( $ bundle -> sourcePath !== null ) { foreach ( $ bundle -> js as $ jsFile ) { @ unlink ( $ bundle -> basePath . DIRECTORY_SEPARATOR . $ jsFile ) ; } foreach ( $ bundle -> css as $ cssFile ) { @ unlink ( $ bundle -> basePath . DIRECTORY_SEPARATOR . $ cssFile ) ; } } } $ this -> stdout ( "Source files deleted.\n" , Console :: FG_GREEN ) ; }
5031	public function setLoadedPage ( $ loadedPage ) { $ this -> dispatch ( Event \ PageEvents :: PAGE_VIEW , new Event \ PageViewEvent ( $ loadedPage ) ) ; $ this -> loadedPage = $ loadedPage ; }
6693	public static function sort ( $ a , $ b ) { if ( ! isset ( $ a [ 'position' ] ) ) { return 0 ; } if ( ! isset ( $ b [ 'position' ] ) ) { return 0 ; } if ( $ a [ 'position' ] === $ b [ 'position' ] ) { return 0 ; } return ( $ a [ 'position' ] < $ b [ 'position' ] ) ? - 1 : 1 ; }
10941	public function getModifiedResponse ( Request $ request , $ params = [ ] , $ lifetime = - 1 , Response $ response = null ) { $ response = $ this -> getResponse ( $ params , $ lifetime , $ response ) ; if ( $ response -> isNotModified ( $ request ) ) { throw new NotModifiedException ( $ response ) ; } return $ response ; }
8515	public function putTransportContent ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_PutTransportContentRequest ) ) { $ request = new FBAInboundServiceMWS_Model_PutTransportContentRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'PutTransportContent' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_PutTransportContentResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
7859	private function registerWorkflowRunnersHook ( ) { $ this -> app -> afterResolving ( function ( WorkflowRunner $ runner , $ app ) { $ runner -> setWorkflow ( $ app [ 'cerbero.workflow' ] ) ; } ) ; }
1473	public function createValidator ( array $ data , array $ rules , array $ messages = [ ] , array $ customAttributes = [ ] , \ Closure $ callback = null ) : ValidatorInterface { $ translator = $ this -> createErrorTranslator ( ) ; return new Validation \ Validator ( $ this -> makeValidator ( $ data , $ rules , $ messages , $ customAttributes ) , $ translator , $ callback ) ; }
6973	private function buildFieldValue ( ClassMetadata $ metadata , $ propertyPath , $ value ) { $ type = $ metadata -> getTypeOfField ( $ propertyPath ) ; switch ( $ type ) { case 'smallint' : case 'integer' : case 'bigint' : if ( ! is_int ( $ value ) ) { throw new \ Exception ( 'Expected integer.' ) ; } return intval ( $ value ) ; case 'boolean' : if ( ! is_bool ( $ value ) ) { throw new \ Exception ( 'Expected boolean.' ) ; } return ( bool ) $ value ; case 'float' : case 'double' : case 'decimal' : if ( ! is_numeric ( $ value ) ) { throw new \ Exception ( 'Expected float.' ) ; } return floatval ( $ value ) ; case 'datetime' : return new \ DateTime ( $ value ) ; case 'string' : return ( string ) $ value ; } throw new \ Exception ( "Unsupported field type '$type' for path '$propertyPath'." ) ; }
2615	public function isApiKeyValid ( ) { try { $ apiKey = $ this -> scopeConfig -> getValue ( Config :: XML_FASTLY_API_KEY ) ; $ serviceId = $ this -> scopeConfig -> getValue ( Config :: XML_FASTLY_SERVICE_ID ) ; $ isApiKeyValid = $ this -> api -> checkServiceDetails ( true , $ serviceId , $ apiKey ) ; } catch ( \ Exception $ e ) { return false ; } return ( bool ) $ isApiKeyValid ; }
11662	public static function saveToString ( $ properties ) { $ xn = new \ SimpleXMLElement ( self :: XML_ROOT_OPEN . self :: XML_ROOT_CLOSE , LIBXML_NOXMLDECL ) ; foreach ( $ properties as $ key => $ value ) { $ xn -> addChild ( "entry" , htmlspecialchars ( $ value , ENT_XML1 ) ) -> addAttribute ( "key" , htmlspecialchars ( $ key , ENT_XML1 ) ) ; } return preg_replace ( '/\<\?.*\?\>/' , self :: XML_PRELUDE , $ xn -> asXML ( ) ) ; }
10733	public static function checkLeapYear ( $ year ) { $ year = Cast :: _Int ( $ year ) ; if ( $ year % 4 !== 0 ) { return false ; } elseif ( $ year % 100 !== 0 ) { return true ; } elseif ( $ year % 400 !== 0 ) { return false ; } elseif ( $ year === 0 ) { return false ; } return true ; }
7063	protected function getAcceptedStates ( PaymentInterface $ payment ) { $ acceptedStates = PaymentStates :: getPaidStates ( ) ; if ( $ payment -> getMethod ( ) -> isOutstanding ( ) ) { $ acceptedStates [ ] = PaymentStates :: STATE_EXPIRED ; } return $ acceptedStates ; }
2295	public static function getTinyTemplates ( ) { $ strDir = Config :: get ( 'uploadPath' ) . '/tiny_templates' ; $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( ! is_dir ( $ rootDir . '/' . $ strDir ) ) { return '' ; } $ arrFiles = array ( ) ; $ arrTemplates = scan ( $ rootDir . '/' . $ strDir ) ; foreach ( $ arrTemplates as $ strFile ) { if ( strncmp ( '.' , $ strFile , 1 ) !== 0 && is_file ( $ rootDir . '/' . $ strDir . '/' . $ strFile ) ) { $ arrFiles [ ] = '{ title: "' . $ strFile . '", url: "' . $ strDir . '/' . $ strFile . '" }' ; } } return implode ( ",\n" , $ arrFiles ) . "\n" ; }
6207	public function set ( $ key , $ value ) { if ( $ this -> exists ( $ key ) ) { $ this -> dataStore [ $ key ] = $ value ; } }
4648	private function getConfigValue ( $ config , $ language , $ key ) { if ( ! isset ( $ config [ $ key ] ) || empty ( $ config [ $ key ] ) ) { if ( isset ( $ this -> defaults [ $ language ] [ $ key ] ) ) { return $ this -> defaults [ $ language ] [ $ key ] ; } return array ( ) ; } if ( ! is_array ( $ config [ $ key ] ) ) { return array ( $ config [ $ key ] ) ; } return $ config [ $ key ] ; }
4084	public function getParentOf ( $ metaModel ) { $ metaModelName = $ this -> getMetaModelName ( $ metaModel ) ; return isset ( $ this -> childMap [ $ metaModelName ] ) ? $ this -> childMap [ $ metaModelName ] : null ; }
11715	protected function getCachedToken ( array $ options ) { $ authOptions = array_intersect_key ( $ options , $ this -> api -> postTokens ( ) [ 'params' ] ) ; $ optionsToHash = array_merge ( $ authOptions , array_intersect_key ( $ options , [ 'authUrl' => true , ] ) ) ; if ( isset ( $ optionsToHash [ 'user' ] ) ) { unset ( $ optionsToHash [ 'user' ] [ 'password' ] ) ; } $ key = 'openstack-token-' . md5 ( json_encode ( $ optionsToHash ) ) ; if ( $ this -> cache -> has ( $ key ) ) { return $ this -> cache -> get ( $ key ) ; } $ token = $ this -> generateToken ( $ authOptions ) ; $ cachedToken = $ token -> export ( ) ; $ expiresAt = new DateTime ( $ cachedToken [ 'expires_at' ] ) ; $ this -> cache -> put ( $ key , $ cachedToken , $ expiresAt -> sub ( new DateInterval ( 'PT1M' ) ) ) ; return $ cachedToken ; }
5511	public function expectCallCount ( $ method , $ count , $ message = '%s' ) { $ this -> dieOnNoMethod ( $ method , 'set expected call count' ) ; $ message .= Mock :: getExpectationLine ( ) ; $ this -> expected_counts [ strtolower ( $ method ) ] = new CallCountExpectation ( $ method , $ count , $ message ) ; }
613	protected function build ( $ class , $ params , $ config ) { list ( $ reflection , $ dependencies ) = $ this -> getDependencies ( $ class ) ; foreach ( $ params as $ index => $ param ) { $ dependencies [ $ index ] = $ param ; } $ dependencies = $ this -> resolveDependencies ( $ dependencies , $ reflection ) ; if ( ! $ reflection -> isInstantiable ( ) ) { throw new NotInstantiableException ( $ reflection -> name ) ; } if ( empty ( $ config ) ) { return $ reflection -> newInstanceArgs ( $ dependencies ) ; } $ config = $ this -> resolveDependencies ( $ config ) ; if ( ! empty ( $ dependencies ) && $ reflection -> implementsInterface ( 'yii\base\Configurable' ) ) { $ dependencies [ count ( $ dependencies ) - 1 ] = $ config ; return $ reflection -> newInstanceArgs ( $ dependencies ) ; } $ object = $ reflection -> newInstanceArgs ( $ dependencies ) ; foreach ( $ config as $ name => $ value ) { $ object -> $ name = $ value ; } return $ object ; }
5545	public function getText ( ) { if ( is_integer ( $ this -> focus ) ) { return $ this -> frames [ $ this -> focus ] -> getText ( ) ; } $ raw = '' ; for ( $ i = 0 ; $ i < count ( $ this -> frames ) ; $ i ++ ) { $ raw .= ' ' . $ this -> frames [ $ i ] -> getText ( ) ; } return trim ( $ raw ) ; }
1546	public function document ( $ request ) : ? \ stdClass { if ( $ this -> cannotDecodeJsonApi ( ) ) { return null ; } return $ this -> decoding -> getJsonApiDecoder ( ) -> document ( $ request ) ; }
4282	public function stream_truncate ( $ size ) { if ( ! $ this -> handle ) { return false ; } self :: restorePrev ( ) ; $ success = \ ftruncate ( $ this -> handle , $ size ) ; self :: register ( ) ; return $ success ; }
10721	public function getLabel ( ) { $ label = $ this -> label ; $ title = $ this -> title ; if ( $ label ) { return $ label ; } else { return $ title ; } }
9617	public function registerSubscriber ( $ class , callable $ callback ) { $ service_id = "event." . strtolower ( str_replace ( "\\" , "." , $ class ) ) ; $ this [ $ service_id ] = $ callback ; $ this [ "dispatcher" ] -> addSubscriberService ( $ service_id , $ class ) ; }
1963	public static function encodeUrl ( $ strUrl ) { if ( $ strUrl == '' ) { return '' ; } if ( $ strUrl == '#' || strncmp ( $ strUrl , '{{' , 2 ) === 0 ) { return $ strUrl ; } if ( strncmp ( $ strUrl , 'mailto:' , 7 ) === 0 ) { return static :: encodeEmail ( $ strUrl ) ; } $ arrUrl = parse_url ( $ strUrl ) ; if ( ! isset ( $ arrUrl [ 'scheme' ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Expected a FQDN, got "%s"' , $ strUrl ) ) ; } if ( isset ( $ arrUrl [ 'scheme' ] ) ) { $ arrUrl [ 'scheme' ] .= ( ( substr ( $ strUrl , \ strlen ( $ arrUrl [ 'scheme' ] ) , 3 ) == '://' ) ? '://' : ':' ) ; } if ( isset ( $ arrUrl [ 'user' ] ) ) { $ arrUrl [ 'user' ] .= isset ( $ arrUrl [ 'pass' ] ) ? ':' : '@' ; } if ( isset ( $ arrUrl [ 'pass' ] ) ) { $ arrUrl [ 'pass' ] .= '@' ; } if ( isset ( $ arrUrl [ 'host' ] ) ) { $ arrUrl [ 'host' ] = static :: encode ( $ arrUrl [ 'host' ] ) ; } if ( isset ( $ arrUrl [ 'port' ] ) ) { $ arrUrl [ 'port' ] = ':' . $ arrUrl [ 'port' ] ; } if ( isset ( $ arrUrl [ 'query' ] ) ) { $ arrUrl [ 'query' ] = '?' . $ arrUrl [ 'query' ] ; } if ( isset ( $ arrUrl [ 'fragment' ] ) ) { $ arrUrl [ 'fragment' ] = '#' . $ arrUrl [ 'fragment' ] ; } $ strReturn = '' ; foreach ( array ( 'scheme' , 'user' , 'pass' , 'host' , 'port' , 'path' , 'query' , 'fragment' ) as $ key ) { if ( isset ( $ arrUrl [ $ key ] ) ) { $ strReturn .= $ arrUrl [ $ key ] ; } } return $ strReturn ; }
7620	public function createSignedQueryString ( $ path = '/' , $ queryString = '' , $ resource = 'b' , $ permissions = 'r' , $ start = '' , $ expiry = '' , $ identifier = '' ) { $ parts = array ( ) ; if ( $ start !== '' ) { $ parts [ ] = 'st=' . urlencode ( $ start ) ; } $ parts [ ] = 'se=' . urlencode ( $ expiry ) ; $ parts [ ] = 'sr=' . $ resource ; $ parts [ ] = 'sp=' . $ permissions ; if ( $ identifier !== '' ) { $ parts [ ] = 'si=' . urlencode ( $ identifier ) ; } $ parts [ ] = 'sig=' . urlencode ( $ this -> createSignature ( $ path , $ resource , $ permissions , $ start , $ expiry , $ identifier ) ) ; if ( $ queryString != '' ) { $ queryString .= '&' ; } $ queryString .= implode ( '&' , $ parts ) ; return $ queryString ; }
8149	public function compileSource ( $ source , $ name = null ) { if ( ! $ source instanceof Twig_Source ) { @ trigger_error ( sprintf ( 'Passing a string as the $source argument of %s() is deprecated since version 1.27. Pass a Twig_Source instance instead.' , __METHOD__ ) , E_USER_DEPRECATED ) ; $ source = new Twig_Source ( $ source , $ name ) ; } try { return $ this -> compile ( $ this -> parse ( $ this -> tokenize ( $ source ) ) ) ; } catch ( Twig_Error $ e ) { $ e -> setSourceContext ( $ source ) ; throw $ e ; } catch ( Exception $ e ) { throw new Twig_Error_Syntax ( sprintf ( 'An exception has been thrown during the compilation of a template ("%s").' , $ e -> getMessage ( ) ) , - 1 , $ source , $ e ) ; } }
10371	public static function add_scripts ( ) { self :: look_if_process_files ( 'script' ) ; foreach ( self :: $ data [ 'script' ] as $ data ) { $ params = [ 'plugin_url' => defined ( 'WP_PLUGIN_URL' ) ? WP_PLUGIN_URL . '/' : '' , 'nonce' => wp_create_nonce ( $ data [ 'name' ] ) , ] ; $ data [ 'params' ] = array_merge ( $ data [ 'params' ] , $ params ) ; wp_register_script ( $ data [ 'name' ] , $ data [ 'url' ] , $ data [ 'deps' ] , $ data [ 'version' ] , $ data [ 'footer' ] ) ; wp_enqueue_script ( $ data [ 'name' ] ) ; wp_localize_script ( $ data [ 'name' ] , $ data [ 'name' ] , $ data [ 'params' ] ) ; } }
10986	public static function getMaxUploadSize ( $ max_size = 0 ) { $ post_max_size = Tools :: unformatBytes ( ini_get ( 'post_max_size' ) ) ; $ upload_max_filesize = Tools :: unformatBytes ( ini_get ( 'upload_max_filesize' ) ) ; if ( $ max_size > 0 ) { $ result = min ( $ post_max_size , $ upload_max_filesize , $ max_size ) ; } else { $ result = min ( $ post_max_size , $ upload_max_filesize ) ; } return $ result ; }
10362	public static function exception ( $ exception ) { try { while ( ob_get_level ( ) > 0 ) ob_end_clean ( ) ; $ error [ 'code' ] = $ exception -> getCode ( ) ; $ error [ 'message' ] = $ exception -> getMessage ( ) ; $ error [ 'file' ] = $ exception -> getFile ( ) ; $ error [ 'line' ] = $ exception -> getLine ( ) ; if ( $ exception instanceof \ ErrorException ) { $ error [ 'type' ] = 'ErrorException: ' ; $ error [ 'type' ] .= in_array ( $ error [ 'code' ] , array_keys ( ErrorHandler :: $ levels ) ) ? ErrorHandler :: $ levels [ $ error [ 'code' ] ] : 'Unknown Error' ; } else { $ error [ 'type' ] = get_class ( $ exception ) ; } ErrorHandler :: writeLogs ( "{$error['type']}: {$error['message']} in {$error['file']} at line {$error['line']}" ) ; @ header ( 'Content-Type: text/html; charset=UTF-8' ) ; if ( DEVELOPMENT ) { $ error [ 'backtrace' ] = $ exception -> getTrace ( ) ; if ( $ exception instanceof \ ErrorException ) { $ error [ 'backtrace' ] = array_slice ( $ error [ 'backtrace' ] , 1 ) ; } $ error [ 'backtrace' ] = self :: formatBacktrace ( $ error [ 'backtrace' ] ) ; $ error [ 'highlighted' ] = self :: highlightCode ( $ error [ 'file' ] , $ error [ 'line' ] ) ; @ header ( 'HTTP/1.1 500 Internal Server Error' ) ; include 'views/exception.php' ; } else { @ header ( 'HTTP/1.1 500 Internal Server Error' ) ; include 'views/production.php' ; } } catch ( Exception $ e ) { while ( ob_get_level ( ) > 0 ) ob_end_clean ( ) ; echo $ e -> getMessage ( ) . ' in ' . $ e -> getFile ( ) . ' (line ' . $ e -> getLine ( ) . ').' ; } exit ( 1 ) ; }
10542	public static function createFromApplication ( Application $ app ) { $ dispatch = new static ( $ app -> request , $ app -> resolver , $ app -> config ) ; $ dispatch -> setApplication ( $ app ) ; return $ dispatch ; }
5949	public function setResults ( array $ results ) { $ this -> results = [ ] ; foreach ( $ results as $ item ) { switch ( $ item [ 'discriminatorId' ] ) { case ObjectResponse :: DISCRIMINATOR_FOLDER : $ this -> addFolderResponse ( $ item ) ; break ; case ObjectResponse :: DISCRIMINATOR_MEDIA : default : $ this -> addMediaResponse ( $ item ) ; break ; } } return $ this ; }
3892	public function getFilterParameterNames ( \ DC_Table $ objDc ) { $ return = array ( ) ; $ filter = $ objDc -> activeRecord -> metamodel_filtering ; if ( ! $ filter ) { return $ return ; } $ collection = $ this -> filterFactory -> createCollection ( $ filter ) ; return $ collection -> getParameterFilterNames ( ) ; }
8357	public static function extractDomain ( RawRequest $ rawRequest ) { $ domain = null ; if ( preg_match ( "/(?P<domain>[a-z0-9][a-z0-9\-]{1,63}\.[a-z\.]{2,6})$/i" , $ rawRequest -> getHost ( ) , $ matches ) ) { $ domain = $ matches [ 'domain' ] ; } return $ domain ; }
11388	public function create ( $ action ) { $ actionName = ucfirst ( $ action ) ; $ class = sprintf ( 'RedKiteCms\Content\BlockManager\BlockManager%s' , $ actionName ) ; if ( ! class_exists ( $ class ) ) { return null ; } $ reflectionClass = new \ ReflectionClass ( $ class ) ; return $ reflectionClass -> newInstance ( $ this -> serializer , $ this -> optionsResolver ) ; }
1848	protected function getMetaFields ( $ objArticle ) { $ meta = StringUtil :: deserialize ( $ this -> news_metaFields ) ; if ( ! \ is_array ( $ meta ) ) { return array ( ) ; } global $ objPage ; $ return = array ( ) ; foreach ( $ meta as $ field ) { switch ( $ field ) { case 'date' : $ return [ 'date' ] = Date :: parse ( $ objPage -> datimFormat , $ objArticle -> date ) ; break ; case 'author' : if ( ( $ objAuthor = $ objArticle -> getRelated ( 'author' ) ) instanceof UserModel ) { $ return [ 'author' ] = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'by' ] . ' <span itemprop="author">' . $ objAuthor -> name . '</span>' ; } break ; case 'comments' : if ( $ objArticle -> noComments || $ objArticle -> source != 'default' ) { break ; } $ bundles = System :: getContainer ( ) -> getParameter ( 'kernel.bundles' ) ; if ( ! isset ( $ bundles [ 'ContaoCommentsBundle' ] ) ) { break ; } $ intTotal = CommentsModel :: countPublishedBySourceAndParent ( 'tl_news' , $ objArticle -> id ) ; $ return [ 'ccount' ] = $ intTotal ; $ return [ 'comments' ] = sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'commentCount' ] , $ intTotal ) ; break ; } } return $ return ; }
9378	protected function files ( $ path ) { $ directory = new \ RecursiveDirectoryIterator ( $ path ) ; $ iterator = new \ RecursiveIteratorIterator ( $ directory ) ; $ regex = new \ RegexIterator ( $ iterator , '/^.+\.php$/i' , 1 ) ; return ( array ) array_keys ( iterator_to_array ( $ regex ) ) ; }
4305	public function table ( ) { if ( ! $ this -> cfg [ 'collect' ] ) { return ; } $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) ) ; $ event = $ this -> methodTable -> onLog ( new Event ( $ this , array ( 'method' => __FUNCTION__ , 'args' => $ args , 'meta' => $ meta , ) ) ) ; $ this -> appendLog ( $ event [ 'method' ] , $ event [ 'args' ] , $ event [ 'meta' ] ) ; }
12064	public function setFlashBag ( $ sName , $ sValue ) { if ( ! isset ( $ _SESSION [ 'flashbag' ] ) ) { $ _SESSION [ 'flashbag' ] = array ( ) ; } $ _SESSION [ 'flashbag' ] [ $ sName ] = $ sValue ; return $ this ; }
618	private function parseString ( $ value , & $ i ) { $ isQuoted = $ value [ $ i ] === '"' ; $ stringEndChars = $ isQuoted ? [ '"' ] : [ $ this -> delimiter , '}' ] ; $ result = '' ; $ len = strlen ( $ value ) ; for ( $ i += $ isQuoted ? 1 : 0 ; $ i < $ len ; ++ $ i ) { if ( in_array ( $ value [ $ i ] , [ '\\' , '"' ] , true ) && in_array ( $ value [ $ i + 1 ] , [ $ value [ $ i ] , '"' ] , true ) ) { ++ $ i ; } elseif ( in_array ( $ value [ $ i ] , $ stringEndChars , true ) ) { break ; } $ result .= $ value [ $ i ] ; } $ i -= $ isQuoted ? 0 : 1 ; if ( ! $ isQuoted && $ result === 'NULL' ) { $ result = null ; } return $ result ; }
8501	public function setGetMatchingProductForIdResult ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'GetMatchingProductForIdResult' ] [ 'FieldValue' ] = $ value ; return $ this ; }
12526	static public function cleanup ( $ opts = array ( ) ) { if ( strtoupper ( substr ( PHP_OS , 0 , 3 ) ) == 'WIN' ) { exec ( 'tasklist /FO CSV' , $ runningProcesses , $ return_var ) ; $ runningProcesses = array_map ( function ( $ line ) { $ cols = explode ( ',' , $ line ) ; return trim ( $ cols [ 1 ] , '"' ) ; } , $ runningProcesses ) ; unset ( $ runningProcesses [ 0 ] ) ; sort ( $ runningProcesses ) ; unset ( $ runningProcesses [ 0 ] ) ; } else { exec ( 'ps -e -o pid' , $ runningProcesses , $ return_var ) ; } if ( $ return_var != 0 ) { pake_echo_error ( "Could not get list of processes to remove stale lock files" ) ; return ; } $ lockDir = self :: lockDir ( $ opts ) ; foreach ( glob ( $ lockDir . "/*_W.lock" ) as $ writeLock ) { $ pid = file_get_contents ( $ writeLock ) ; if ( ! in_array ( $ pid , $ runningProcesses ) ) { pake_unlink ( $ writeLock ) ; } } foreach ( glob ( $ lockDir . "/*_R/*.lock" ) as $ readLock ) { $ pid = file_get_contents ( $ readLock ) ; if ( ! in_array ( $ pid , $ runningProcesses ) ) { pake_unlink ( $ readLock ) ; } } }
10598	protected function initViewPanelRequestedUrlData ( ) { $ req = & $ this -> request ; $ this -> view -> requestedUrl = ( object ) [ 'method' => htmlSpecialChars ( $ req -> GetMethod ( ) , ENT_IGNORE , 'UTF-8' ) , 'baseUrl' => htmlSpecialChars ( $ req -> GetBaseUrl ( ) , ENT_IGNORE , 'UTF-8' ) , 'path' => htmlSpecialChars ( $ req -> GetRequestPath ( ) , ENT_IGNORE , 'UTF-8' ) , ] ; }
6356	public static function convert ( $ style = TS_UNIX , $ ts ) { try { $ ct = new static ( $ ts ) ; return $ ct -> getTimestamp ( $ style ) ; } catch ( TimestampException $ e ) { return false ; } }
4632	public function responseHeaderCallback ( $ ch , $ header ) { if ( strpos ( $ header , ':' ) ) { list ( $ key , $ value ) = explode ( ':' , $ header , 2 ) ; $ value = trim ( $ value ) ; if ( ! empty ( $ value ) ) { if ( ! isset ( $ this -> responseHeaders [ $ key ] ) ) { $ this -> responseHeaders [ $ key ] = $ value ; } elseif ( is_array ( $ this -> responseHeaders [ $ key ] ) ) { $ this -> responseHeaders [ $ key ] = array_merge ( $ this -> responseHeaders [ $ key ] , [ $ value ] ) ; } else { $ this -> responseHeaders [ $ key ] = array_merge ( [ $ this -> responseHeaders [ $ key ] ] , [ $ value ] ) ; } } } return strlen ( $ header ) ; }
12700	public function createServiceWithName ( ServiceLocatorInterface $ serviceLocator , $ name , $ requestedName ) { $ config = $ serviceLocator -> get ( 'config' ) ; if ( isset ( $ config [ 'rznviewcomponent' ] [ 'cache_adapter' ] ) ) { $ config = $ config [ 'rznviewcomponent' ] [ 'cache_adapter' ] ; } else $ config = array ( 'name' => 'filesystem' , 'options' => array ( 'ttl' => 3600 , 'dirLevel' => 2 , 'file_locking' => false , 'cacheDir' => 'data/cache' , 'dirPermission' => 0755 , 'filePermission' => 0666 , ) , ) ; return \ Zend \ Cache \ StorageFactory :: factory ( array ( 'adapter' => $ config , 'plugins' => array ( 'serializer' ) , ) ) ; }
8928	public function add ( $ name , GeneratorInterface $ class ) { if ( array_key_exists ( $ name , $ this -> generators ) ) { throw new \ InvalidArgumentException ( 'Generator already exists.' ) ; } $ this -> generators [ $ name ] = $ class ; }
10246	public static function ascToUcs ( $ ascii ) { $ rawname = '' ; $ iMax = strlen ( $ ascii ) ; for ( $ i = 0 ; $ i < $ iMax ; ++ $ i ) { $ rawname .= $ ascii [ $ i ] . "\x00" ; } return $ rawname ; }
10791	public function register ( SilexApp $ app ) { $ app [ 'twig' ] = $ app -> share ( $ app -> extend ( 'twig' , function ( \ Twig_Environment $ twig , SilexApp $ app ) { $ class = $ this -> getServiceConfig ( ) -> getProviderClass ( ) ; $ twig -> addExtension ( new $ class ) ; return $ twig ; } ) ) ; }
4836	public function create_bill ( $ params ) { if ( ! isset ( $ params [ 'pre_authorization_id' ] ) ) { throw new GoCardless_ArgumentsException ( 'pre_authorization_id missing' ) ; } $ pre_auth = new GoCardless_PreAuthorization ( $ this , array ( 'id' => $ params [ 'pre_authorization_id' ] ) ) ; return $ pre_auth -> create_bill ( array ( 'amount' => $ params [ 'amount' ] ) ) ; }
1371	protected function make ( array $ data ) { $ validator = $ this -> validatorFactory -> make ( $ data , $ this -> getRules ( ) , $ this -> getMessages ( ) , $ this -> getAttributes ( ) ) ; $ this -> configureValidator ( $ validator ) ; return $ validator ; }
6542	public function current ( ) { if ( true === $ this -> wantNewModel ) { return $ this -> entityManager -> load ( $ this -> modelClassName , $ this -> selector -> current ( ) ) ; } else { $ this -> initializeModel ( $ this -> selector -> current ( ) , $ this -> selector -> currentShardingKey ( ) ) ; $ this -> entityManager -> resetModel ( $ this -> model , $ this -> selector -> current ( ) ) ; return $ this -> model ; } }
10746	protected function sendJson ( Response $ response , $ payload ) : Response { $ response -> getBody ( ) -> write ( json_encode ( $ payload ) ) ; return $ response -> withHeader ( 'Content-Type' , 'application/json' ) ; }
5456	protected function addContentToAllOpenTags ( $ text ) { foreach ( array_keys ( $ this -> tags ) as $ name ) { for ( $ i = 0 , $ count = count ( $ this -> tags [ $ name ] ) ; $ i < $ count ; $ i ++ ) { $ this -> tags [ $ name ] [ $ i ] -> addContent ( $ text ) ; } } }
7568	protected function parse ( ) { $ p = & $ this -> parser ; $ p -> setPos ( 0 ) ; $ this -> result = array ( ) ; if ( ! $ this -> parse_single ( ) ) { return false ; } while ( count ( $ this -> result ) > 0 ) { switch ( $ p -> token ) { case CSSQueryTokenizer :: TOK_CHILD : $ this -> parser -> next_no_whitespace ( ) ; if ( ! $ this -> parse_result ( false , 1 ) ) { return false ; } break ; case CSSQueryTokenizer :: TOK_SIBLING : $ this -> parser -> next_no_whitespace ( ) ; if ( ! $ this -> parse_result ( true , 1 ) ) { return false ; } break ; case CSSQueryTokenizer :: TOK_PLUS : $ this -> parser -> next_no_whitespace ( ) ; if ( ! $ this -> parse_adjacent ( ) ) { return false ; } break ; case CSSQueryTokenizer :: TOK_ALL : case CSSQueryTokenizer :: TOK_IDENTIFIER : case CSSQueryTokenizer :: TOK_STRING : case CSSQueryTokenizer :: TOK_BRACE_OPEN : case CSSQueryTokenizer :: TOK_BRACKET_OPEN : case CSSQueryTokenizer :: TOK_ID : case CSSQueryTokenizer :: TOK_CLASS : case CSSQueryTokenizer :: TOK_COLON : if ( ! $ this -> parse_result ( ) ) { return false ; } break ; case CSSQueryTokenizer :: TOK_NULL : break 2 ; default : $ this -> error ( 'Invalid search pattern(3): No result modifier found!' ) ; return false ; } } return true ; }
9024	public function hasDenial ( $ string ) { $ result = false ; $ words = $ this -> getWords ( $ string ) ; foreach ( $ words as $ word ) { if ( in_array ( $ word , $ this -> denialWords ) ) { $ result = true ; } } return $ result ; }
11820	public function cell_default ( $ item , $ column ) { $ ret = $ this -> val ( $ item , $ column ) ; return is_null ( $ ret ) ? '' : $ ret ; }
5265	public function getNotCachedAttributes ( $ key , array $ attributes = [ '*' ] ) { if ( ! $ this -> has ( $ key ) ) { return $ attributes ; } $ cachedAttributes = $ this -> cache [ $ key ] [ 'attributes' ] ; return $ cachedAttributes == [ '*' ] ? [ ] : array_diff ( $ attributes , $ cachedAttributes ) ; }
2639	public function aroundGetElementByPathParts ( \ Closure $ proceed , array $ pathParts ) { $ result = $ proceed ( $ pathParts ) ; if ( $ this -> isLoaded == true || false ) { return $ result ; } if ( ( $ result instanceof Section ) == false ) { return $ result ; } if ( isset ( $ pathParts [ 0 ] ) == false || $ pathParts [ 0 ] != 'system' ) { return $ result ; } $ this -> isLoaded = true ; $ data = $ result -> getData ( ) ; if ( isset ( $ data [ 'children' ] [ 'full_page_cache' ] [ 'children' ] [ 'fastly_edge_modules' ] [ 'children' ] ) == false ) { return $ result ; } $ original = $ data [ 'children' ] [ 'full_page_cache' ] [ 'children' ] [ 'fastly_edge_modules' ] [ 'children' ] ; $ data [ 'children' ] [ 'full_page_cache' ] [ 'children' ] [ 'fastly_edge_modules' ] [ 'children' ] = array_merge ( $ original , $ this -> loadModlyData ( ) ) ; $ result -> setData ( $ data , $ this -> scopeDefiner -> getScope ( ) ) ; return $ result ; }
10313	function getClicks ( $ fromDate = null , $ toDate = null , $ mailingIds = null , $ contactIds = null , $ contactEmails = null , $ contactExternalIds = null , $ formatFilter = null , $ linkIdFilter = null , $ linkUrlFilter = null , $ linkTagFilter = null , $ socialNetworkFilter = null , $ deviceTypeFilter = null , $ embedEmailClientInfos = false , $ excludeAnonymousClicks = false , $ standardFields = null , $ customFields = null , $ embedFieldBackups = false , $ pageIndex = 1 , $ pageSize = 100 , $ embedLinkTags = false ) { $ params = $ this -> createQueryParameters ( $ pageIndex , $ pageSize , $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , $ mailingIds , null , $ embedFieldBackups ) ; $ params = $ this -> appendArrayFields ( $ params , "standard_field" , $ standardFields ) ; $ params = $ this -> appendArrayFields ( $ params , "custom_field" , $ customFields ) ; if ( isset ( $ embedEmailClientInfos ) ) $ params [ 'embed_email_client_infos' ] = ( $ embedEmailClientInfos == true ) ? "true" : "false" ; if ( isset ( $ embedLinkTags ) ) $ params [ 'embed_link_tags' ] = ( $ embedLinkTags == true ) ? "true" : "false" ; if ( isset ( $ excludeAnonymousClicks ) ) $ params [ 'exclude_anonymous_clicks' ] = ( $ excludeAnonymousClicks == true ) ? "true" : "false" ; if ( isset ( $ formatFilter ) ) $ params [ 'format' ] = $ formatFilter ; $ params = $ this -> appendArrayFields ( $ params , "link_id" , $ linkIdFilter ) ; if ( isset ( $ linkUrlFilter ) ) $ params [ 'link_url' ] = $ linkUrlFilter ; $ params = $ this -> appendArrayFields ( $ params , "link_tag" , $ linkTagFilter ) ; $ params = $ this -> appendArrayFields ( $ params , "social_network" , $ socialNetworkFilter ) ; $ params = $ this -> appendArrayFields ( $ params , "device_type" , $ deviceTypeFilter ) ; return $ this -> get ( 'reports/clicks' , $ params ) ; }
3624	public function temperatureInUserScale ( $ temperature_in_celsius , $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ temp_scale = $ this -> getDeviceTemperatureScale ( $ serial_number ) ; if ( $ temp_scale == 'F' ) { return ( $ temperature_in_celsius * 1.8 ) + 32 ; } return $ temperature_in_celsius ; }
3648	protected function registerBinput ( ) { $ this -> app -> singleton ( 'binput' , function ( Container $ app ) { $ request = $ app [ 'request' ] ; $ security = $ app [ 'security' ] ; $ binput = new Binput ( $ request , $ security ) ; $ app -> refresh ( 'request' , $ binput , 'setRequest' ) ; return $ binput ; } ) ; $ this -> app -> alias ( 'binput' , Binput :: class ) ; }
10333	function fromXML ( $ xmlElement ) { parent :: fromXML ( $ xmlElement ) ; if ( isset ( $ xmlElement -> permissionType ) ) $ this -> permission = Permission :: getPermission ( $ xmlElement -> permissionType ) ; if ( isset ( $ xmlElement -> field_backups ) ) $ this -> fieldBackups = XMLDeserializer :: deserialize ( $ xmlElement -> field_backups ) ; }
405	public function addCorsHeaders ( $ response , $ headers ) { if ( empty ( $ headers ) === false ) { $ responseHeaders = $ response -> getHeaders ( ) ; foreach ( $ headers as $ field => $ value ) { $ responseHeaders -> set ( $ field , $ value ) ; } } }
8683	public static function from ( $ iterable ) { if ( is_array ( $ iterable ) ) { return $ iterable ; } if ( $ iterable instanceof ImmutableBag ) { return $ iterable -> toArray ( ) ; } if ( $ iterable instanceof Traversable ) { return iterator_to_array ( $ iterable ) ; } if ( $ iterable === null ) { return [ ] ; } if ( $ iterable instanceof \ stdClass ) { return ( array ) $ iterable ; } Assert :: nullOrIsIterable ( $ iterable ) ; }
12477	private function getTransformation ( ) { $ transforms = [ ] ; foreach ( $ this -> fields as $ field => $ extra ) { if ( is_int ( $ field ) ) { $ transforms [ $ extra ] = $ extra ; continue ; } $ transform = ( key_exists ( 'transform' , $ extra ) ) ? $ extra [ 'transform' ] : $ field ; if ( $ transform === false ) { continue ; } $ transforms [ $ field ] = $ transform ; } return $ transforms ; }
6135	public function search ( Search $ search , $ returnType = self :: RETURN_OBJECTS , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'returnType' => $ returnType ] , 'body' => json_encode ( [ 'search' => $ search ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> call ( 'v1/search' , $ parameters , self :: METHOD_POST , $ cachePolicy ) ; $ result = new SearchResult ( $ result ) ; return $ result ; }
6208	public function load ( $ data ) { if ( ! is_array ( $ data ) && ! $ data instanceof \ stdClass ) { return ; } foreach ( $ data as $ key => $ value ) { $ this -> set ( $ key , $ value ) ; } }
303	public function getAttributeHint ( $ attribute ) { $ hints = $ this -> attributeHints ( ) ; if ( isset ( $ hints [ $ attribute ] ) ) { return $ hints [ $ attribute ] ; } elseif ( strpos ( $ attribute , '.' ) ) { $ attributeParts = explode ( '.' , $ attribute ) ; $ neededAttribute = array_pop ( $ attributeParts ) ; $ relatedModel = $ this ; foreach ( $ attributeParts as $ relationName ) { if ( $ relatedModel -> isRelationPopulated ( $ relationName ) && $ relatedModel -> $ relationName instanceof self ) { $ relatedModel = $ relatedModel -> $ relationName ; } else { try { $ relation = $ relatedModel -> getRelation ( $ relationName ) ; } catch ( InvalidParamException $ e ) { return '' ; } $ modelClass = $ relation -> modelClass ; $ relatedModel = $ modelClass :: instance ( ) ; } } $ hints = $ relatedModel -> attributeHints ( ) ; if ( isset ( $ hints [ $ neededAttribute ] ) ) { return $ hints [ $ neededAttribute ] ; } } return '' ; }
10648	private function normalizeRules ( ) { foreach ( $ this -> rules as $ scope => $ rules ) { foreach ( $ rules as $ field => $ rule ) { if ( is_array ( $ rule ) ) { $ this -> rules [ $ scope ] [ $ field ] = implode ( '|' , $ rule ) ; } } } }
9622	public function getPdo ( $ connection = null ) { if ( $ connection === null ) { $ connection = $ this -> defaultConnection ; } if ( isset ( $ this -> instances [ $ connection ] ) ) { return $ this -> instances [ $ connection ] ; } $ config = $ this -> getConnectionConfig ( $ connection ) ; return $ this -> instances [ $ connection ] = $ this -> factory -> makePdo ( $ config , $ connection ) ; }
2229	public function dragFile ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { return '<button type="button" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '" ' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</button> ' ; }
3825	protected function compile ( ) { $ objItemRenderer = new ItemList ( ) ; $ this -> Template -> searchable = ! $ this -> metamodel_donotindex ; $ sorting = $ this -> metamodel_sortby ; $ direction = $ this -> metamodel_sortby_direction ; if ( $ this -> metamodel_sort_override ) { if ( \ Input :: get ( 'orderBy' ) ) { $ sorting = \ Input :: get ( 'orderBy' ) ; } if ( \ Input :: get ( 'orderDir' ) ) { $ direction = \ Input :: get ( 'orderDir' ) ; } } $ objItemRenderer -> setServiceContainerFallback ( function ( ) { return $ this -> getServiceContainer ( ) ; } ) -> setFactory ( System :: getContainer ( ) -> get ( 'metamodels.factory' ) ) -> setFilterFactory ( System :: getContainer ( ) -> get ( 'metamodels.filter_setting_factory' ) ) -> setRenderSettingFactory ( System :: getContainer ( ) -> get ( 'metamodels.render_setting_factory' ) ) -> setEventDispatcher ( System :: getContainer ( ) -> get ( 'event_dispatcher' ) ) -> setMetaModel ( $ this -> metamodel , $ this -> metamodel_rendersettings ) -> setLimit ( $ this -> metamodel_use_limit , $ this -> metamodel_offset , $ this -> metamodel_limit ) -> setPageBreak ( $ this -> perPage ) -> setSorting ( $ sorting , $ direction ) -> setFilterSettings ( $ this -> metamodel_filtering ) -> setFilterParameters ( StringUtil :: deserialize ( $ this -> metamodel_filterparams , true ) , $ this -> getFilterParameters ( $ objItemRenderer ) ) -> setMetaTags ( $ this -> metamodel_meta_title , $ this -> metamodel_meta_description ) ; $ this -> Template -> items = \ StringUtil :: encodeEmail ( $ objItemRenderer -> render ( $ this -> metamodel_noparsing , $ this ) ) ; $ this -> Template -> numberOfItems = $ objItemRenderer -> getItems ( ) -> getCount ( ) ; $ this -> Template -> pagination = $ objItemRenderer -> getPagination ( ) ; }
12905	public function index ( FilterRequest $ request ) { $ limit = $ request -> request -> get ( 'limit' , 15 ) ; $ limit = ( $ limit > 49 ) ? 50 : $ limit ; $ filter = $ this -> repository -> filter ( $ request ) ; if ( $ this -> list || $ request -> request -> get ( 'search_type' ) == 'list' ) { $ resources = $ filter -> get ( 1000 ) ; } else { $ resources = $ filter -> paginate ( $ limit ) ; } if ( $ resources -> count ( ) < 1 ) { } return $ this -> success ( $ resources ) ; }
2162	public function run35Update ( ) { $ this -> Database -> query ( "ALTER TABLE `tl_member` CHANGE `username` `username` varchar(64) COLLATE utf8_bin NULL" ) ; $ this -> Database -> query ( "UPDATE `tl_member` SET username=NULL WHERE username=''" ) ; $ this -> Database -> query ( "ALTER TABLE `tl_member` DROP INDEX `username`, ADD UNIQUE KEY `username` (`username`)" ) ; }
6720	public function authorize ( ) { $ this -> validateAuthParams ( ) ; try { $ response = $ this -> curl -> setOption ( CURLOPT_POSTFIELDS , http_build_query ( array ( 'grant_type' => self :: GRANT_TYPE_AUTHORIZATION_CODE , 'client_id' => $ this -> clientId , 'client_secret' => $ this -> clientSecret , 'response_type' => self :: RESPONSE_TYPE_CODE , 'state' => self :: STATE_ALIVE ) ) ) -> post ( $ this -> authUrl , false ) ; } catch ( InvalidParamException $ invalidParamException ) { throw new Oauth2ClientException ( $ invalidParamException -> getMessage ( ) ) ; } return $ this -> handleAuthorizeResponse ( $ response ) ; }
10307	public function setGlowProperties ( $ size , $ color_value = null , $ color_alpha = null , $ color_type = null ) { $ this -> setGlowSize ( $ size ) -> setGlowColor ( $ color_value === null ? $ this -> glowProperties [ 'color' ] [ 'value' ] : $ color_value , $ color_alpha === null ? ( int ) $ this -> glowProperties [ 'color' ] [ 'alpha' ] : $ color_alpha , $ color_type === null ? $ this -> glowProperties [ 'color' ] [ 'type' ] : $ color_type ) ; }
6408	public static function filterBy ( IteratorAggregate $ unfiltered , string $ className ) : IteratorAggregate { return self :: from ( Iterators :: filterBy ( Iterators :: from ( $ unfiltered -> getIterator ( ) ) , $ className ) ) ; }
8749	public function loadFromRegistry ( Registry $ registry ) { foreach ( $ registry as $ key => $ serviceProvider ) { $ this -> loadServiceProviderFactories ( $ serviceProvider , $ key ) ; } foreach ( $ registry as $ key => $ serviceProvider ) { $ this -> loadServiceProviderExtensions ( $ serviceProvider , $ key ) ; } }
2171	private function login ( ) : Response { $ request = $ this -> container -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; if ( null === $ request ) { throw new \ RuntimeException ( 'The request stack did not contain a request' ) ; } if ( 'tl_login' !== $ request -> request -> get ( 'FORM_SUBMIT' ) ) { return $ this -> render ( 'login.html.twig' ) ; } $ installTool = $ this -> container -> get ( 'contao.install_tool' ) ; $ verified = password_verify ( $ request -> request -> get ( 'password' ) , $ installTool -> getConfig ( 'installPassword' ) ) ; if ( ! $ verified ) { $ installTool -> increaseLoginCount ( ) ; return $ this -> render ( 'login.html.twig' , [ 'error' => $ this -> trans ( 'invalid_password' ) , ] ) ; } $ installTool -> resetLoginCount ( ) ; $ this -> container -> get ( 'contao.install_tool_user' ) -> setAuthenticated ( true ) ; return $ this -> getRedirectResponse ( ) ; }
2026	public static function findPublishedSubpagesWithoutGuestsByPid ( $ intPid , $ blnShowHidden = false , $ blnIsSitemap = false ) { $ time = Date :: floorToMinute ( ) ; $ objSubpages = Database :: getInstance ( ) -> prepare ( "SELECT p1.*, (SELECT COUNT(*) FROM tl_page p2 WHERE p2.pid=p1.id AND p2.type!='root' AND p2.type!='error_401' AND p2.type!='error_403' AND p2.type!='error_404'" . ( ! $ blnShowHidden ? ( $ blnIsSitemap ? " AND (p2.hide='' OR sitemap='map_always')" : " AND p2.hide=''" ) : "" ) . ( FE_USER_LOGGED_IN ? " AND p2.guests=''" : "" ) . ( ! BE_USER_LOGGED_IN ? " AND (p2.start='' OR p2.start<='$time') AND (p2.stop='' OR p2.stop>'" . ( $ time + 60 ) . "') AND p2.published='1'" : "" ) . ") AS subpages FROM tl_page p1 WHERE p1.pid=? AND p1.type!='root' AND p1.type!='error_401' AND p1.type!='error_403' AND p1.type!='error_404'" . ( ! $ blnShowHidden ? ( $ blnIsSitemap ? " AND (p1.hide='' OR sitemap='map_always')" : " AND p1.hide=''" ) : "" ) . ( FE_USER_LOGGED_IN ? " AND p1.guests=''" : "" ) . ( ! BE_USER_LOGGED_IN ? " AND (p1.start='' OR p1.start<='$time') AND (p1.stop='' OR p1.stop>'" . ( $ time + 60 ) . "') AND p1.published='1'" : "" ) . " ORDER BY p1.sorting" ) -> execute ( $ intPid ) ; if ( $ objSubpages -> numRows < 1 ) { return null ; } return static :: createCollectionFromDbResult ( $ objSubpages , 'tl_page' ) ; }
11783	public function add ( $ title , $ description , $ pageUrl , $ iconUrl , $ comment = '' ) { $ params = [ 'title' => $ title , 'description' => $ description , 'page_url' => $ pageUrl , 'icon_url' => $ iconUrl , ] ; if ( $ comment !== '' ) { $ params [ 'comment' ] = $ comment ; } return $ this -> parseJSON ( 'json' , [ self :: API_ADD , $ params ] ) ; }
2007	public function onKernelException ( GetResponseForExceptionEvent $ event ) : void { $ exception = $ event -> getException ( ) ; if ( $ exception -> getPrevious ( ) instanceof ResourceNotFoundException && ! $ this -> hasRootPages ( ) ) { $ exception = new NoRootPageFoundException ( 'No root page found' , 0 , $ exception ) ; } $ class = $ this -> getTargetClass ( $ exception ) ; if ( null === $ class ) { return ; } if ( null !== ( $ httpException = $ this -> convertToHttpException ( $ exception , $ class ) ) ) { $ event -> setException ( $ httpException ) ; } }
4734	public function write_data ( ) { $ option_key = "_wp_session_{$this->session_id}" ; if ( $ this -> dirty ) { if ( false === get_option ( $ option_key ) ) { add_option ( "_wp_session_{$this->session_id}" , $ this -> container , '' , 'no' ) ; add_option ( "_wp_session_expires_{$this->session_id}" , $ this -> expires , '' , 'no' ) ; } else { delete_option ( "_wp_session_{$this->session_id}" ) ; add_option ( "_wp_session_{$this->session_id}" , $ this -> container , '' , 'no' ) ; } } }
4412	public function getLegacyPreference ( $ name ) { $ legacyKernel = $ this -> legacyKernel ; return $ legacyKernel ( ) -> runCallback ( function ( ) use ( $ name ) { return eZPreferences :: value ( $ name ) ; } ) ; }
7200	protected function detachSaleItemRecursively ( SaleItemInterface $ item ) { $ this -> stockAssigner -> detachSaleItem ( $ item ) ; foreach ( $ item -> getChildren ( ) as $ child ) { $ this -> detachSaleItemRecursively ( $ child ) ; } }
12412	public function getDetails ( $ groupId , $ begin , $ count ) { $ params = [ 'group_id' => intval ( $ groupId ) , 'begin' => intval ( $ begin ) , 'count' => intval ( $ count ) , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_GET_DETAIL , $ params ] ) ; }
9812	protected function putRaw ( string $ path , $ body = null , array $ headers = [ ] ) { $ response = $ this -> client -> put ( $ path , $ headers , $ body ) ; return ResponseMediator :: getContent ( $ response ) ; }
4204	private function addPropertiesPhpDoc ( Event $ abs ) { $ tags = array ( 'property' => 'magic' , 'property-read' => 'magic-read' , 'property-write' => 'magic-write' , ) ; $ inheritedFrom = null ; if ( ! \ array_intersect_key ( $ abs [ 'phpDoc' ] , $ tags ) ) { $ found = false ; $ obj = $ abs -> getSubject ( ) ; if ( ! \ method_exists ( $ obj , '__get' ) ) { return ; } $ reflector = $ abs [ 'reflector' ] ; while ( $ reflector = $ reflector -> getParentClass ( ) ) { $ parsed = $ this -> phpDoc -> getParsed ( $ reflector ) ; $ tagIntersect = \ array_intersect_key ( $ parsed , $ tags ) ; if ( ! $ tagIntersect ) { continue ; } $ found = true ; $ inheritedFrom = $ reflector -> getName ( ) ; $ abs [ 'phpDoc' ] = \ array_merge ( $ abs [ 'phpDoc' ] , $ tagIntersect ) ; break ; } if ( ! $ found ) { return ; } } $ properties = $ abs [ 'properties' ] ; foreach ( $ tags as $ tag => $ vis ) { if ( ! isset ( $ abs [ 'phpDoc' ] [ $ tag ] ) ) { continue ; } foreach ( $ abs [ 'phpDoc' ] [ $ tag ] as $ phpDocProp ) { $ exists = isset ( $ properties [ $ phpDocProp [ 'name' ] ] ) ; $ properties [ $ phpDocProp [ 'name' ] ] = \ array_merge ( $ exists ? $ properties [ $ phpDocProp [ 'name' ] ] : self :: $ basePropInfo , array ( 'desc' => $ phpDocProp [ 'desc' ] , 'type' => $ phpDocProp [ 'type' ] , 'inheritedFrom' => $ inheritedFrom , 'visibility' => $ exists ? array ( $ properties [ $ phpDocProp [ 'name' ] ] [ 'visibility' ] , $ vis ) : $ vis , ) ) ; if ( ! $ exists ) { $ properties [ $ phpDocProp [ 'name' ] ] [ 'value' ] = $ this -> abstracter -> UNDEFINED ; } } unset ( $ abs [ 'phpDoc' ] [ $ tag ] ) ; } $ abs [ 'properties' ] = $ properties ; return ; }
4002	protected function getCountFor ( $ intMetaModelId , $ intFilterId ) { $ metaModel = $ this -> loadMetaModel ( $ intMetaModelId ) ; if ( $ metaModel == null ) { return false ; } $ objFilter = $ metaModel -> getEmptyFilter ( ) ; if ( $ intFilterId ) { $ collection = $ this -> getServiceContainer ( ) -> getFilterFactory ( ) -> createCollection ( $ intFilterId ) ; $ values = [ ] ; foreach ( $ collection -> getParameters ( ) as $ key ) { $ values [ $ key ] = Input :: get ( $ key ) ; } $ collection -> addRules ( $ objFilter , $ values ) ; } return $ metaModel -> getCount ( $ objFilter ) ; }
6621	public function set_submenu ( ) { $ submenu = Module :: CustomRatingGrifus ( ) -> getOption ( 'submenu' ) ; WP_Menu :: add ( 'submenu' , $ submenu [ 'custom-rating-grifus' ] , [ $ this , 'render' ] , [ $ this , 'add_scripts' ] , [ $ this , 'add_styles' ] ) ; }
2986	protected function generateForm ( $ bundle , $ entity , $ metadata , $ forceOverwrite = false ) { $ this -> getFormGenerator ( $ bundle ) -> generate ( $ bundle , $ entity , $ metadata [ 0 ] , $ forceOverwrite ) ; }
3445	private function getAccessor ( $ field ) { $ method = 'get' . camel_case ( $ field ) . 'Attribute' ; return method_exists ( $ this , $ method ) ? $ method : false ; }
12443	public function add ( InvokerInterface $ invoker , $ taskArgs = [ ] ) { $ taskArgs = ( is_array ( $ taskArgs ) ? $ taskArgs : array_slice ( func_get_args ( ) , 1 ) ) ; array_unshift ( $ this -> tasks , compact ( 'invoker' , 'taskArgs' ) ) ; return $ this ; }
8933	private function addDependency ( $ name , $ template ) { $ this -> commands [ ] = strtr ( $ template , [ '$namespace' => $ this -> namespaceRoot , '$name' => $ name ] ) ; }
11602	public function getComponentRoot ( string $ name ) : ? string { $ rootMap = $ this -> getConfig ( 'componentsRootMap' ) ; return isset ( $ rootMap [ $ name ] ) ? $ this -> getAppRoot ( ) . $ rootMap [ $ name ] : null ; }
3466	public function put ( string $ route , callable $ controller ) : void { $ this -> register ( $ controller , Route :: put ( $ route ) ) ; }
11487	protected function callResolvingCallbacks ( $ key , $ object ) { foreach ( $ this -> resolvingAnyCallbacks as $ callback ) { call_user_func ( $ callback , $ object , $ this ) ; } if ( isset ( $ this -> resolvingCallbacks [ $ key ] ) ) { foreach ( $ this -> resolvingCallbacks [ $ key ] as $ callback ) { call_user_func ( $ callback , $ object , $ this ) ; } } }
3298	public static function isImage ( $ file ) { try { $ level = error_reporting ( E_ERROR | E_PARSE ) ; $ isImage = self :: isFile ( $ file ) && getimagesize ( $ file ) !== false ; error_reporting ( $ level ) ; return $ isImage ; } catch ( Exception $ e ) { return false ; } }
3151	protected function continueInteraction ( RunnerServiceContext $ context ) { $ continue = false ; $ session = $ context -> getTestSession ( ) ; if ( $ session -> isRunning ( ) === true && $ session -> isTimeout ( ) === false ) { $ event = new QtiContinueInteractionEvent ( $ context , $ this ) ; $ this -> getServiceManager ( ) -> get ( EventManager :: SERVICE_ID ) -> trigger ( $ event ) ; TestRunnerUtils :: beginCandidateInteraction ( $ session ) ; $ continue = true ; } else { $ this -> finish ( $ context ) ; } return $ continue ; }
3703	protected function getProperty ( $ name , $ legend ) { foreach ( $ legend -> getProperties ( ) as $ property ) { if ( $ property -> getName ( ) === $ name ) { return $ property ; } } $ property = new Property ( $ name ) ; $ legend -> addProperty ( $ property ) ; return $ property ; }
9549	public function setPdo ( PDO $ pdo ) { $ this -> pdo = $ pdo ; $ this -> pdo -> setAttribute ( PDO :: ATTR_DEFAULT_FETCH_MODE , PDO :: FETCH_ASSOC ) ; return $ this ; }
4721	public function processListItems ( Text $ list , array $ options = array ( ) , $ level = 0 ) { $ list -> replace ( '/\n{2,}\z/' , "\n" ) ; $ list -> replace ( '{ (\n)? # leading line = $1 (^[ \t]*) # leading whitespace = $2 (' . $ this -> getPattern ( ) . ') [ \t]+ # list marker = $3 ((?s:.+?) # list item text = $4 (\n{1,2})) (?= \n* (\z | \2 (' . $ this -> getPattern ( ) . ') [ \t]+)) }mx' , function ( Text $ w , Text $ leadingLine , Text $ ls , Text $ m , Text $ item ) use ( $ options , $ level ) { if ( ( string ) $ leadingLine || $ item -> match ( '/\n{2,}/' ) ) { $ this -> markdown -> emit ( 'outdent' , array ( $ item ) ) ; $ this -> markdown -> emit ( 'block' , array ( $ item ) ) ; } else { $ this -> markdown -> emit ( 'outdent' , array ( $ item ) ) ; $ this -> processList ( $ item , $ options , ++ $ level ) ; $ item -> rtrim ( ) ; $ this -> markdown -> emit ( 'inline' , array ( $ item ) ) ; } return $ this -> getRenderer ( ) -> renderListItem ( $ item ) . "\n" ; } ) ; }
5152	static function sortEmailsByCreationDatePredicate ( $ emailA , $ emailB ) { $ sortKeyA = $ emailA -> sent_at ; $ sortKeyB = $ emailB -> sent_at ; return ( $ sortKeyA > $ sortKeyB ) ? - 1 : 1 ; }
2803	public function setProxyTargetDir ( string $ proxyTargetDir ) : void { if ( ! is_dir ( $ proxyTargetDir ) ) { throw new InvalidArgumentException ( sprintf ( 'Proxy target directory "%s" does not exist!' , $ proxyTargetDir ) , 10 ) ; } if ( ! is_writable ( $ proxyTargetDir ) ) { throw new InvalidArgumentException ( sprintf ( 'Proxy target directory "%s" is not writable!' , $ proxyTargetDir ) , 20 ) ; } $ this -> proxyTargetDir = $ proxyTargetDir ; }
7165	private function buildDiscountLine ( Model \ SaleAdjustmentInterface $ adjustment , $ level = 0 ) { if ( Model \ AdjustmentTypes :: TYPE_DISCOUNT !== $ adjustment -> getType ( ) ) { throw new InvalidArgumentException ( "Unexpected adjustment type." ) ; } $ lineNumber = $ this -> lineNumber ++ ; $ view = new LineView ( 'adjustment_' . ( $ lineNumber - 1 ) , 'adjustment_' . $ adjustment -> getId ( ) , $ lineNumber , $ level ) ; if ( empty ( $ designation = $ adjustment -> getDesignation ( ) ) ) { $ designation = 'Discount ' ; if ( $ adjustment -> getMode ( ) === Model \ AdjustmentModes :: MODE_PERCENT ) { $ designation .= $ this -> formatter -> percent ( $ adjustment -> getAmount ( ) ) ; } } $ result = $ adjustment -> getResult ( ) ; $ view -> setDesignation ( $ designation ) -> setBase ( $ this -> formatter -> currency ( $ result -> getBase ( ) ) ) -> setTaxAmount ( $ this -> formatter -> currency ( $ result -> getTax ( ) ) ) -> setTotal ( $ this -> formatter -> currency ( $ result -> getTotal ( ) ) ) ; foreach ( $ this -> types as $ type ) { $ type -> buildAdjustmentView ( $ adjustment , $ view , $ this -> options ) ; } return $ view ; }
2670	public function createDictionaryItems ( $ dictionaryId , $ params ) { $ url = $ this -> _getApiServiceUri ( ) . 'dictionary/' . $ dictionaryId . '/items' ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: PATCH , $ params ) ; return $ result ; }
3336	public function getIntegrationData ( ) { $ integrationData = '' ; $ framework = $ this -> api -> getFramework ( ) ; if ( $ framework ) { $ integrationData .= $ framework ; } $ extension = $ this -> api -> getExtension ( ) ; if ( $ extension ) { $ integrationData .= '; ' . $ extension ; } return $ integrationData ; }
4079	protected function buildInputScreen ( $ metaModel ) { $ metaModelName = $ this -> getMetaModelName ( $ metaModel ) ; $ inputScreen = $ this -> information [ $ metaModelName ] [ self :: INPUTSCREEN ] ; if ( ! is_object ( $ inputScreen ) ) { $ inputScreen = $ this -> information [ $ metaModelName ] [ self :: INPUTSCREEN ] = new InputScreen ( $ this -> container , $ inputScreen [ 'row' ] , $ inputScreen [ 'properties' ] , $ inputScreen [ 'conditions' ] , $ inputScreen [ 'groupSort' ] ) ; } return $ inputScreen ; }
8041	public function formatEventsToJson ( array $ calendarEvents ) { $ array = [ ] ; foreach ( $ calendarEvents as $ event ) { $ start = $ this -> carbon -> copy ( ) -> setTimestamp ( strtotime ( $ event -> start ) ) -> toIso8601String ( ) ; $ end = $ this -> carbon -> copy ( ) -> setTimestamp ( strtotime ( $ event -> end ) ) -> toIso8601String ( ) ; $ allDay = $ event -> all_day == 1 ; $ data = [ 'title' => $ event -> title , 'description' => $ event -> description , 'start' => $ start , 'end' => $ end , 'allDay' => $ allDay , 'borderColor' => $ event -> border_color , 'textColor' => $ event -> text_color , 'backgroundColor' => $ event -> background_color , ] ; $ array [ ] = $ data ; if ( $ event -> calendarEventRepeatDates ( ) -> count ( ) > 0 ) { foreach ( $ event -> calendarEventRepeatDates ( ) -> get ( ) as $ repeatDate ) { $ start = $ this -> carbon -> copy ( ) -> setTimestamp ( strtotime ( $ repeatDate -> start ) ) -> toIso8601String ( ) ; $ end = $ this -> carbon -> copy ( ) -> setTimestamp ( strtotime ( $ repeatDate -> end ) ) -> toIso8601String ( ) ; $ data [ 'start' ] = $ start ; $ data [ 'end' ] = $ end ; $ array [ ] = $ data ; } } } return $ array ; }
1624	protected function releaseLock ( $ name ) { static $ releaseLuaScript = <<<LUAif redis.call("GET",KEYS[1])==ARGV[1] then return redis.call("DEL",KEYS[1])else return 0endLUA ; if ( ! isset ( $ this -> _lockValues [ $ name ] ) || ! $ this -> redis -> executeCommand ( 'EVAL' , [ $ releaseLuaScript , 1 , $ this -> calculateKey ( $ name ) , $ this -> _lockValues [ $ name ] ] ) ) { return false ; } else { unset ( $ this -> _lockValues [ $ name ] ) ; return true ; } }
2071	private function getDateAndTime ( CalendarEventsModel $ objEvent , PageModel $ objPage , $ intStartTime , $ intEndTime , $ span ) { $ strDate = Date :: parse ( $ objPage -> dateFormat , $ intStartTime ) ; if ( $ span > 0 ) { $ strDate = Date :: parse ( $ objPage -> dateFormat , $ intStartTime ) . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'cal_timeSeparator' ] . Date :: parse ( $ objPage -> dateFormat , $ intEndTime ) ; } $ strTime = '' ; if ( $ objEvent -> addTime ) { if ( $ span > 0 ) { $ strDate = Date :: parse ( $ objPage -> datimFormat , $ intStartTime ) . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'cal_timeSeparator' ] . Date :: parse ( $ objPage -> datimFormat , $ intEndTime ) ; } elseif ( $ intStartTime == $ intEndTime ) { $ strTime = Date :: parse ( $ objPage -> timeFormat , $ intStartTime ) ; } else { $ strTime = Date :: parse ( $ objPage -> timeFormat , $ intStartTime ) . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'cal_timeSeparator' ] . Date :: parse ( $ objPage -> timeFormat , $ intEndTime ) ; } } return array ( $ strDate , $ strTime ) ; }
9291	public function addGrid16CSS ( \ PageModel $ objPage , \ LayoutModel $ objLayout , \ PageRegular $ objPageRegular ) { $ arrFrameworkGrid16 = \ StringUtil :: deserialize ( $ objLayout -> frameworkGrid16 ) ; if ( is_array ( $ arrFrameworkGrid16 ) ) { foreach ( $ arrFrameworkGrid16 as $ strFile ) { if ( $ objLayout -> loadingOrderGrid16 == 'before_framework' ) { $ GLOBALS [ 'TL_CSS' ] [ ] = 'bundles/bugbustergrid16/' . basename ( $ strFile , '.css' ) . '.min.css' ; } else { $ GLOBALS [ 'TL_HEAD' ] [ ] = '<link rel="stylesheet" href="bundles/bugbustergrid16/' . basename ( $ strFile , '.css' ) . '.min.css">' ; } } } return ; }
6495	public function visitPage ( $ path , $ code = 200 ) { if ( ! $ this -> assertStatusCode ( $ path , $ code ) ) { throw new \ Exception ( sprintf ( 'The page "%s" is not accessible!' , $ path ) ) ; } self :: debug ( [ 'Visited page: %s' ] , [ $ path ] ) ; $ this -> visitPath ( $ path ) ; }
12631	public function prepare ( Order $ order ) { $ order -> notify_url = $ order -> get ( 'notify_url' , $ this -> merchant -> notify_url ) ; if ( is_null ( $ order -> spbill_create_ip ) ) { $ order -> spbill_create_ip = ( $ order -> trade_type === Order :: NATIVE ) ? get_server_ip ( ) : get_client_ip ( ) ; } return $ this -> request ( $ this -> wrapApi ( self :: API_PREPARE_ORDER ) , $ order -> all ( ) ) ; }
640	public function dropPrimaryKey ( $ name , $ table ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> dropPrimaryKey ( $ name , $ table ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; }
7238	protected function fixDeliveryDefault ( CustomerAddressInterface $ address ) { if ( ! $ this -> persistenceHelper -> isChanged ( $ address , [ 'deliveryDefault' ] ) ) { return ; } $ customer = $ address -> getCustomer ( ) ; if ( $ address -> isDeliveryDefault ( ) ) { foreach ( $ customer -> getAddresses ( ) as $ a ) { if ( $ a === $ address ) { continue ; } if ( $ a -> isDeliveryDefault ( ) ) { $ a -> setDeliveryDefault ( false ) ; $ this -> persistenceHelper -> persistAndRecompute ( $ a , false ) ; } } } elseif ( null === $ customer -> getDefaultDeliveryAddress ( true ) ) { $ address -> setDeliveryDefault ( true ) ; $ this -> persistenceHelper -> persistAndRecompute ( $ address , false ) ; } }
2945	public function removeRole ( $ role ) { if ( is_string ( $ role ) ) { return $ this -> roles ( ) -> detach ( Role :: where ( 'slug' , $ role ) -> first ( ) ) ; } return $ this -> roles ( ) -> detach ( $ role ) ; }
6907	public function removeExtraRecipient ( Recipient $ recipient ) { if ( $ this -> extraRecipients -> contains ( $ recipient ) ) { $ this -> extraRecipients -> removeElement ( $ recipient ) ; } return $ this ; }
794	public function activeAttributes ( ) { $ scenario = $ this -> getScenario ( ) ; $ scenarios = $ this -> scenarios ( ) ; if ( ! isset ( $ scenarios [ $ scenario ] ) ) { return [ ] ; } $ attributes = array_keys ( array_flip ( $ scenarios [ $ scenario ] ) ) ; foreach ( $ attributes as $ i => $ attribute ) { if ( $ attribute [ 0 ] === '!' ) { $ attributes [ $ i ] = substr ( $ attribute , 1 ) ; } } return $ attributes ; }
6763	public function append ( Collection $ collection ) { if ( ! $ collection ) return $ this ; $ this -> models = array_merge ( $ this -> array ( ) , $ collection -> array ( ) ) ; return $ this ; }
4913	public function add ( $ name , $ entities = null , array $ options = null ) { if ( $ name instanceof DependencyResult ) { return $ this -> addResult ( $ name ) ; } if ( $ name instanceof \ Traversable ) { return $ this -> addTraversable ( $ name ) ; } if ( is_array ( $ name ) ) { return $ this -> addArray ( $ name ) ; } if ( null === $ entities ) { throw new \ UnexpectedValueException ( '$entities must not be null.' ) ; } return $ this -> addArray ( [ 'name' => $ name , 'entities' => $ entities , 'options' => $ options , ] ) ; }
3444	public function offsetGet ( $ offset ) { $ fieldValue = isset ( $ this -> fields [ $ offset ] ) ? $ this -> fields [ $ offset ] : null ; $ accessor = $ this -> getAccessor ( $ offset ) ; if ( $ accessor ) { return $ this -> $ accessor ( $ fieldValue ) ; } $ accessorForLanguageField = $ this -> getAccessorForLanguageField ( $ offset ) ; if ( $ accessorForLanguageField ) { return $ this -> $ accessorForLanguageField ( $ offset ) ; } return $ fieldValue ; }
2766	public function isAhead ( ) : bool { if ( ! $ this -> isTracking ( ) ) { throw new GitException ( 'Error: HEAD does not have a remote tracking branch. Cannot check if it is ahead.' ) ; } $ mergeBase = $ this -> run ( 'merge-base' , [ '@' , '@{u}' ] ) ; $ localSha = $ this -> run ( 'rev-parse' , [ '@' ] ) ; $ remoteSha = $ this -> run ( 'rev-parse' , [ '@{u}' ] ) ; return $ mergeBase === $ remoteSha && $ localSha !== $ remoteSha ; }
10387	public function newApp ( ) : ApplicationInterface { $ app = new CalgamoApplication ( $ this -> filesystem ) ; $ app -> requireModule ( CalgamoLogExceptionHandlerModule :: class ) ; $ app -> requireModule ( CalgamoRouterModule :: class ) ; $ app -> requireModule ( CalgamoDiModule :: class ) ; $ app -> requireModule ( Wa72SimpleLoggerModule :: class ) ; return $ app ; }
11248	public function getMigrationBatches ( ) : array { $ stmt = $ this -> pdo -> prepare ( "select * from {$this->table} order by batch, migration" ) ; $ stmt -> execute ( ) ; $ array = [ ] ; foreach ( $ stmt -> fetchAll ( PDO :: FETCH_ASSOC ) as $ item ) { $ array [ $ item [ 'migration' ] ] = $ item [ 'batch' ] ; } return $ array ; }
6032	public function getDeployedFile ( $ templateId , $ templateType = self :: TEMPLATE_IMAGE , $ siteId = null ) { foreach ( $ this -> deployedFiles as $ deployedFile ) { if ( null === $ siteId || $ siteId == $ deployedFile -> getDeployMentSiteId ( ) ) { if ( self :: TEMPLATE_VIDEO == $ templateType ) { if ( $ templateId == $ deployedFile -> getVideoTemplateId ( ) && null === $ deployedFile -> getImageTemplateId ( ) ) { return $ deployedFile ; } } elseif ( self :: TEMPLATE_IMAGE == $ templateType && $ templateId == $ deployedFile -> getImageTemplateId ( ) || ( null === $ templateId && null === $ deployedFile -> getImageTemplateId ( ) && null === $ deployedFile -> getVideoTemplateId ( ) ) ) { return $ deployedFile ; } } } throw new NotFoundException ( 'No DeploymentFile with the id "' . $ templateId . '" exists.' ) ; }
4791	function delete ( ) { if ( $ this -> notORM -> freeze ) { return false ; } $ where = $ this -> whereString ( ) ; if ( empty ( $ where ) ) { throw new Exception ( 'sorry, you can not delete the whole table --dogstar' ) ; } $ return = $ this -> query ( "DELETE" . $ this -> topString ( $ this -> limit ) . " FROM $this->table" . $ where , $ this -> parameters ) ; if ( ! $ return ) { return false ; } return $ return -> rowCount ( ) ; }
6423	public function isConfigured ( ) { if ( empty ( $ this -> options [ 'application_name' ] ) || empty ( $ this -> options [ 'client_id' ] ) || empty ( $ this -> options [ 'client_secret' ] ) ) { return false ; } return true ; }
11620	public function auth ( ) : \ TheCMSThread \ Core \ Main \ Auth { static $ auth ; if ( $ auth === null ) { $ auth = $ this -> container -> get ( "TheCMSThread\\Core\\Main\\Auth" ) ; } $ auth -> __construct ( ) ; return $ auth ; }
7322	public function sidereal ( $ mode = 'a' , Angle $ lon = null ) { $ ut = $ this -> copy ( ) -> toUT1 ( ) ; $ uta = $ ut -> jd ; $ utb = $ ut -> dayFrac ; $ ut = null ; $ tt = $ this -> copy ( ) -> toTT ( ) ; $ tta = $ tt -> jd ; $ ttb = $ tt -> dayFrac ; $ tt = null ; $ st ; if ( $ mode == 'a' ) { $ strad = IAU :: Gst06a ( $ uta , $ utb , $ tta , $ ttb ) ; } else { $ strad = IAU :: Gmst06 ( $ uta , $ utb , $ tta , $ ttb ) ; } if ( $ lon ) { $ st = Angle :: rad ( $ strad ) -> add ( $ lon ) -> norm ( ) -> toTime ( ) ; } else { $ st = Angle :: rad ( $ strad ) -> toTime ( ) ; } return $ st ; }
9288	public function truncate ( ) { $ adapter = $ this -> dbAdapter ; $ mapper = new \ CronHelper \ Model \ JobMapper ( $ adapter ) ; $ where = new \ Zend \ Db \ Sql \ Where ( ) ; $ mapper -> deleteByWhere ( $ where ) ; }
5272	protected function translateOrderBy ( ) { $ build = array ( ) ; foreach ( $ this -> statements [ 'orders' ] as $ column => $ direction ) { if ( is_array ( $ direction ) ) { list ( $ column , $ direction ) = $ direction ; } if ( ! is_null ( $ direction ) ) { $ column .= ' ' . $ direction ; } $ build [ ] = $ column ; } return 'order by ' . join ( ', ' , $ build ) ; }
5363	public function generate ( Registry $ registry ) { $ context = $ this -> createContext ( $ registry , 'Client' ) ; $ files = [ ] ; foreach ( $ registry -> getSchemas ( ) as $ schema ) { $ context -> setCurrentSchema ( $ schema ) ; $ files = array_merge ( $ files , $ this -> modelGenerator -> generate ( $ schema , $ schema -> getRootName ( ) , $ context ) ) ; $ files = array_merge ( $ files , $ this -> normalizerGenerator -> generate ( $ schema , $ schema -> getRootName ( ) , $ context ) ) ; $ clients = $ this -> clientGenerator -> generate ( $ schema -> getParsed ( ) , $ schema -> getNamespace ( ) , $ context , $ schema -> getOrigin ( ) . '#' ) ; foreach ( $ clients as $ node ) { $ files [ ] = new File ( $ schema -> getDirectory ( ) . DIRECTORY_SEPARATOR . 'Resource' . DIRECTORY_SEPARATOR . $ node -> stmts [ 2 ] -> name . '.php' , $ node , '' ) ; } } return $ files ; }
215	public function resolve ( ) { $ rawParams = $ this -> getParams ( ) ; $ endOfOptionsFound = false ; if ( isset ( $ rawParams [ 0 ] ) ) { $ route = array_shift ( $ rawParams ) ; if ( $ route === '--' ) { $ endOfOptionsFound = true ; $ route = array_shift ( $ rawParams ) ; } } else { $ route = '' ; } $ params = [ ] ; $ prevOption = null ; foreach ( $ rawParams as $ param ) { if ( $ endOfOptionsFound ) { $ params [ ] = $ param ; } elseif ( $ param === '--' ) { $ endOfOptionsFound = true ; } elseif ( preg_match ( '/^--([\w-]+)(?:=(.*))?$/' , $ param , $ matches ) ) { $ name = $ matches [ 1 ] ; if ( is_numeric ( substr ( $ name , 0 , 1 ) ) ) { throw new Exception ( 'Parameter "' . $ name . '" is not valid' ) ; } if ( $ name !== Application :: OPTION_APPCONFIG ) { $ params [ $ name ] = isset ( $ matches [ 2 ] ) ? $ matches [ 2 ] : true ; $ prevOption = & $ params [ $ name ] ; } } elseif ( preg_match ( '/^-([\w-]+)(?:=(.*))?$/' , $ param , $ matches ) ) { $ name = $ matches [ 1 ] ; if ( is_numeric ( $ name ) ) { $ params [ ] = $ param ; } else { $ params [ '_aliases' ] [ $ name ] = isset ( $ matches [ 2 ] ) ? $ matches [ 2 ] : true ; $ prevOption = & $ params [ '_aliases' ] [ $ name ] ; } } elseif ( $ prevOption === true ) { $ prevOption = $ param ; } else { $ params [ ] = $ param ; } } return [ $ route , $ params ] ; }
8032	public function validateDatesArray ( $ attribute , $ value , array $ parameters , Validator $ validator ) { foreach ( $ value as $ date ) { if ( false === strtotime ( $ date ) || empty ( $ date ) ) { return false ; } } return true ; }
6191	public function run ( $ controller = null , $ action = null , $ args = [ ] ) { $ this -> router = $ this -> router -> boot ( $ this ) ; if ( is_null ( $ controller ?? null ) and is_null ( $ action ?? null ) ) { $ this -> router -> parseGets ( ) ; $ controller = $ this -> router -> controller ; $ action = $ this -> router -> action ; $ namespace = $ this -> router -> namespace ; } $ loader = new Loader ( $ this -> baseClass ) ; $ Controller = $ loader -> loadController ( $ controller , $ namespace ?? '\\' ) ; $ response = [ ] ; if ( method_exists ( $ Controller , 'start' ) ) { $ response [ ] = [ 'start' , [ ] ] ; } if ( method_exists ( $ Controller , 'init' ) ) { $ response [ ] = [ 'init' , [ ] ] ; } if ( method_exists ( $ Controller , $ action ) or is_callable ( [ $ Controller , $ action ] ) ) { $ response [ ] = [ $ action , $ args ] ; } if ( method_exists ( $ Controller , 'end' ) ) { $ response [ ] = [ 'end' , [ ] ] ; } foreach ( $ response as $ key => $ data ) { $ run = call_user_func_array ( [ $ Controller , $ data [ 0 ] ] , $ data [ 1 ] ) ; if ( $ run instanceof Response ) { if ( isset ( $ this -> debug ) ) { $ this -> debug -> addHeader ( [ 'X-DF-Debug-Controller' => $ controller ] ) ; $ this -> debug -> addHeader ( [ 'X-DF-Debug-Method' => $ action ] ) ; $ run -> headers ( $ this -> debug -> getHeader ( ) ) ; } return $ run -> display ( ) ; } } return true ; }
4221	public function getAbstraction ( & $ array , $ method = null , & $ hist = array ( ) ) { if ( \ in_array ( $ array , $ hist , true ) ) { return $ this -> abstracter -> RECURSION ; } if ( self :: isCallable ( $ array ) ) { return array ( 'debug' => $ this -> abstracter -> ABSTRACTION , 'type' => 'callable' , 'values' => array ( \ get_class ( $ array [ 0 ] ) , $ array [ 1 ] ) , ) ; } $ return = array ( ) ; $ hist [ ] = $ array ; foreach ( $ array as $ k => $ v ) { if ( $ this -> abstracter -> needsAbstraction ( $ v ) ) { $ v = $ this -> abstracter -> getAbstraction ( $ array [ $ k ] , $ method , $ hist ) ; } $ return [ $ k ] = $ v ; } return $ return ; }
8828	public function image ( $ name , $ file , $ attributes = [ ] , $ secure = null ) { $ attributes [ 'src' ] = $ this -> uri -> assets ( $ file , $ secure ) ; return $ this -> input ( 'image' , $ name , null , $ attributes ) ; }
12318	protected function searchQuery ( Builder $ query , string $ phrase ) { return $ query -> where ( function ( Builder $ query ) use ( $ phrase ) { $ query -> where ( 'url' , 'LIKE' , '%' . $ phrase . '%' ) -> orWhere ( 'short_url_key' , 'LIKE' , '%' . $ phrase . '%' ) -> orWhere ( 'clicks' , 'LIKE' , '%' . $ phrase . '%' ) -> orWhere ( 'url' , 'LIKE' , '%' . $ phrase . '%' ) ; } ) ; }
1577	protected function validateDocumentCompliance ( $ document , ? ValidatorFactoryInterface $ validators ) : void { $ this -> passes ( $ this -> factory -> createNewResourceDocumentValidator ( $ document , $ this -> getResourceType ( ) , $ validators && $ validators -> supportsClientIds ( ) ) ) ; }
10220	public static function getConversionGroups ( ) { $ conversionGroups = [ ] ; foreach ( self :: $ conversionUnits as $ conversionUnit ) { $ conversionGroups [ ] = $ conversionUnit [ 'Group' ] ; } return array_merge ( array_unique ( $ conversionGroups ) ) ; }
1269	public function getSubscription ( $ name = null , $ beginDateTime = null , $ endDateTime = null , $ fileName = null , $ bookmark = null ) { if ( null !== $ beginDateTime ) { $ beginDateTime = $ this -> formatDateTime ( $ beginDateTime ) ; } if ( null !== $ endDateTime ) { $ endDateTime = $ this -> formatDateTime ( $ endDateTime ) ; } if ( null !== $ beginDateTime && null === $ endDateTime ) { $ endDateTime = $ this -> formatDateTime ( time ( ) ) ; } $ this -> name = $ name ; $ this -> beginDateTime = $ beginDateTime ; $ this -> endDateTime = $ endDateTime ; $ this -> fileName = $ fileName ; $ this -> bookmark = $ bookmark ; $ access = $ this -> createAccess ( ) ; $ request = $ this -> createRequest ( ) ; $ this -> response = $ this -> getRequest ( ) -> request ( $ access , $ request , $ this -> compileEndpointUrl ( self :: ENDPOINT ) ) ; $ response = $ this -> response -> getResponse ( ) ; if ( null === $ response ) { throw new Exception ( 'Failure (0): Unknown error' , 0 ) ; } if ( $ response -> Response -> ResponseStatusCode == 0 ) { throw new Exception ( "Failure ({$response->Response->Error->ErrorSeverity}): {$response->Response->Error->ErrorDescription}" , ( int ) $ response -> Response -> Error -> ErrorCode ) ; } else { if ( isset ( $ response -> Bookmark ) ) { $ this -> setBookmark ( ( string ) $ response -> Bookmark ) ; } else { $ this -> setBookmark ( null ) ; } return $ this -> formatResponse ( $ response ) ; } }
9501	public function watch ( WatcherInterface $ watcher ) { $ events = $ this -> getEvents ( ) ; $ watcher -> watch ( $ this -> getTrackedPaths ( ) , $ events , [ $ this , 'runPeridot' ] ) ; }
9679	function fromXML ( $ xmlElement ) { $ this -> contact = new ReportContact ( ) ; $ this -> contact -> fromXML ( $ xmlElement -> contact ) ; if ( isset ( $ xmlElement -> mailing_id ) ) $ this -> mailingId = $ xmlElement -> mailing_id ; if ( isset ( $ xmlElement -> source ) ) $ this -> source = $ xmlElement -> source ; if ( isset ( $ xmlElement -> timestamp ) ) $ this -> timestamp = $ xmlElement -> timestamp ; }
4365	public function onErrorHighPri ( Event $ error ) { $ this -> throttleDataRead ( ) ; $ hash = $ error [ 'hash' ] ; $ error [ 'email' ] = ( $ error [ 'type' ] & $ this -> cfg [ 'emailMask' ] ) && $ error [ 'isFirstOccur' ] && $ this -> cfg [ 'emailTo' ] ; $ error [ 'stats' ] = array ( 'tsEmailed' => 0 , 'countSince' => 0 , 'emailedTo' => '' , ) ; if ( isset ( $ this -> throttleData [ 'errors' ] [ $ hash ] ) ) { $ stats = \ array_intersect_key ( $ this -> throttleData [ 'errors' ] [ $ hash ] , $ error [ 'stats' ] ) ; $ error [ 'stats' ] = \ array_merge ( $ error [ 'stats' ] , $ stats ) ; } return ; }
10775	public function loginRequired ( $ checkAjax = true ) { $ request = Yii :: $ app -> getRequest ( ) ; if ( $ this -> enableSession && ( ! $ checkAjax || ! $ request -> getIsAjax ( ) ) ) { $ this -> setReturnUrl ( $ request -> getUrl ( ) ) ; } if ( $ this -> loginUrl !== null ) { $ loginUrl = ( array ) $ this -> loginUrl ; if ( $ loginUrl [ 0 ] !== Yii :: $ app -> requestedRoute ) { return Yii :: $ app -> getResponse ( ) -> redirect ( $ this -> loginUrl ) ; } } throw new ForbiddenHttpException ( Yii :: t ( 'yii' , 'Login Required' ) ) ; }
105	public function watch2OnHighest ( Decisions $ decisions ) { $ literals = $ this -> rule -> getLiterals ( ) ; if ( count ( $ literals ) < 3 ) { return ; } $ watchLevel = 0 ; foreach ( $ literals as $ literal ) { $ level = $ decisions -> decisionLevel ( $ literal ) ; if ( $ level > $ watchLevel ) { $ this -> watch2 = $ literal ; $ watchLevel = $ level ; } } }
2692	public function getFastlyUrl ( ) { $ baseFile = $ this -> getBaseFile ( ) ; $ url = $ this -> getBaseFileUrl ( $ baseFile ) ; $ imageQuality = $ this -> _scopeConfig -> getValue ( Config :: XML_FASTLY_IMAGE_OPTIMIZATION_IMAGE_QUALITY ) ; $ this -> setQuality ( $ imageQuality ) ; $ this -> fastlyParameters [ 'quality' ] = $ this -> _quality ; if ( $ this -> _scopeConfig -> isSetFlag ( Config :: XML_FASTLY_IMAGE_OPTIMIZATION_BG_COLOR ) == true ) { $ this -> fastlyParameters [ 'bg-color' ] = implode ( ',' , $ this -> _backgroundColor ) ; } if ( $ this -> _keepAspectRatio == true ) { $ this -> fastlyParameters [ 'fit' ] = 'bounds' ; } $ this -> fastlyUrl = $ url . '?' . $ this -> compileFastlyParameters ( ) ; }
837	public static function detectBlockType ( Token $ token ) { foreach ( self :: getBlockEdgeDefinitions ( ) as $ type => $ definition ) { if ( $ token -> equals ( $ definition [ 'start' ] ) ) { return [ 'type' => $ type , 'isStart' => true ] ; } if ( $ token -> equals ( $ definition [ 'end' ] ) ) { return [ 'type' => $ type , 'isStart' => false ] ; } } }
12449	static function run_check_gnu_files ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { $ opts = self :: getOpts ( @ $ args [ 0 ] , @ $ args [ 1 ] , $ cliopts ) ; if ( ! SharedLock :: acquire ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ) throw new PakeException ( "Source code locked by another process" ) ; $ destdir = self :: getBuildDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ; if ( $ opts [ 'files' ] [ 'gnu_dir' ] ) { $ destdir .= '/' . $ opts [ 'files' ] [ 'gnu_dir' ] ; } $ files = pakeFinder :: type ( 'file' ) -> name ( array ( 'README' , 'LICENSE' ) ) -> maxdepth ( 0 ) -> in ( $ destdir ) ; if ( count ( $ files ) != 2 ) { SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; throw new pakeException ( "README and/or LICENSE files missing. Please fix" ) ; } SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; }
1877	public function delete ( $ source = null ) { if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notDeletable' ] ) { throw new InternalServerErrorException ( 'Table "' . $ this -> strTable . '" is not deletable.' ) ; } $ blnDoNotRedirect = ( $ source !== null ) ; if ( $ source === null ) { $ source = $ this -> intId ; } $ this -> isValid ( $ source ) ; if ( ! file_exists ( $ this -> strRootDir . '/' . $ source ) || ! $ this -> isMounted ( $ source ) ) { throw new AccessDeniedException ( 'File or folder "' . $ source . '" is not mounted or cannot be found.' ) ; } if ( \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'ondelete_callback' ] ) ) { foreach ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'ondelete_callback' ] as $ callback ) { if ( \ is_array ( $ callback ) ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ source , $ this ) ; } elseif ( \ is_callable ( $ callback ) ) { $ callback ( $ source , $ this ) ; } } } $ this -> import ( Files :: class , 'Files' ) ; if ( is_dir ( $ this -> strRootDir . '/' . $ source ) ) { $ this -> Files -> rrdir ( $ source ) ; $ strWebDir = StringUtil :: stripRootDir ( System :: getContainer ( ) -> getParameter ( 'contao.web_dir' ) ) ; if ( is_link ( $ this -> strRootDir . '/' . $ strWebDir . '/' . $ source ) ) { $ this -> Files -> delete ( $ strWebDir . '/' . $ source ) ; } } else { $ this -> Files -> delete ( $ source ) ; } if ( $ this -> blnIsDbAssisted && Dbafs :: shouldBeSynchronized ( $ source ) ) { Dbafs :: deleteResource ( $ source ) ; } $ this -> log ( 'File or folder "' . $ source . '" has been deleted' , __METHOD__ , TL_FILES ) ; if ( ! $ blnDoNotRedirect ) { $ this -> redirect ( $ this -> getReferer ( ) ) ; } }
7856	private function publishConfig ( ) { $ config = __DIR__ . '/config/workflow.php' ; $ this -> publishes ( [ $ config => config_path ( 'workflow.php' ) ] ) ; $ this -> mergeConfigFrom ( $ config , 'workflow' ) ; }
11965	public static function hash ( $ password ) { return \ Yii :: $ app -> security -> generatePasswordHash ( $ password , \ Yii :: $ app -> getModule ( 'user' ) -> cost ) ; }
11374	private function getInjectHint ( \ ReflectionMethod $ method , \ ReflectionParameter $ parameter ) { $ hint = Psi :: it ( $ this -> reader -> getMethodAnnotations ( $ method ) ) -> filter ( new IsInstanceOf ( Di \ DiInjectHintAnnotation :: class ) ) -> filter ( function ( Di \ DiInjectHintAnnotation $ i ) use ( $ parameter ) { return $ i -> getParameter ( ) === $ parameter -> getName ( ) ; } ) -> getFirst ( ) ; if ( $ hint !== null ) { return $ hint ; } try { if ( $ parameter -> getClass ( ) === null ) { throw new \ InvalidArgumentException ( "Cannot inject constructor-param '{$parameter->getName()}' into {$method->getDeclaringClass()->getName()}. " . 'The parameter does not have a an @Inject hint and it has no type-hint.' ) ; } } catch ( \ ReflectionException $ e ) { } return Di \ Inject \ ByType :: create ( $ parameter -> getName ( ) , Util :: normalizeFqcn ( ( string ) $ parameter -> getType ( ) ) ) ; }
7631	public function setContainerMetadata ( $ containerName = '' , $ metadata = array ( ) , $ additionalHeaders = array ( ) ) { Assertion :: notEmpty ( $ containerName , 'Container name is not specified' ) ; self :: assertValidContainerName ( $ containerName ) ; Assertion :: isArray ( $ metadata , 'Meta data should be an array of key and value pairs.' ) ; if ( count ( $ metadata ) == 0 ) { return ; } $ headers = array ( ) ; $ headers = array_merge ( $ headers , $ this -> generateMetadataHeaders ( $ metadata ) ) ; foreach ( $ additionalHeaders as $ key => $ value ) { $ headers [ $ key ] = $ value ; } $ response = $ this -> performRequest ( $ containerName , array ( 'restype' => 'container' , 'comp' => 'metadata' ) , 'PUT' , $ headers , false , null , self :: RESOURCE_CONTAINER , self :: PERMISSION_WRITE ) ; if ( ! $ response -> isSuccessful ( ) ) { throw new BlobException ( $ this -> getErrorMessage ( $ response , 'Resource could not be accessed.' ) ) ; } }
2301	public static function convertLayoutSectionIdsToAssociativeArray ( $ arrSections ) { $ arrSections = array_flip ( array_values ( array_unique ( $ arrSections ) ) ) ; foreach ( array_keys ( $ arrSections ) as $ k ) { $ arrSections [ $ k ] = $ GLOBALS [ 'TL_LANG' ] [ 'COLS' ] [ $ k ] ; } asort ( $ arrSections ) ; return $ arrSections ; }
6697	public function isMethodHidden ( $ methodName ) { if ( ! method_exists ( $ this , $ methodName ) ) { throw new Exception ( 500 , "The method '$methodName' does not exist in " . get_called_class ( ) ) ; } return isset ( $ this -> hiddenMethods [ $ methodName ] ) ; }
3371	private function visitAssociation ( $ className , $ association = null ) { if ( null === $ association ) { if ( isset ( $ this -> visitedAssociations [ $ className ] ) ) { return false ; } $ this -> visitedAssociations [ $ className ] = [ ] ; return true ; } if ( isset ( $ this -> visitedAssociations [ $ className ] [ $ association ] ) ) { return false ; } if ( ! isset ( $ this -> visitedAssociations [ $ className ] ) ) { $ this -> visitedAssociations [ $ className ] = [ ] ; } $ this -> visitedAssociations [ $ className ] [ $ association ] = true ; return true ; }
9985	private function mapVAlign ( $ vAlign ) { switch ( $ vAlign ) { case Alignment :: VERTICAL_BOTTOM : return 'bottom' ; case Alignment :: VERTICAL_TOP : return 'top' ; case Alignment :: VERTICAL_CENTER : case Alignment :: VERTICAL_JUSTIFY : return 'middle' ; default : return 'baseline' ; } }
10018	public function removeNamedRange ( $ namedRange , Worksheet $ pSheet = null ) { if ( $ pSheet === null ) { if ( isset ( $ this -> namedRanges [ $ namedRange ] ) ) { unset ( $ this -> namedRanges [ $ namedRange ] ) ; } } else { if ( isset ( $ this -> namedRanges [ $ pSheet -> getTitle ( ) . '!' . $ namedRange ] ) ) { unset ( $ this -> namedRanges [ $ pSheet -> getTitle ( ) . '!' . $ namedRange ] ) ; } } return $ this ; }
12773	public function __async_authorize ( $ hashEmail = null , $ hashPassword = null ) { $ result = array ( 'status' => '0' ) ; if ( ! isset ( $ hashEmail ) ) { if ( isset ( $ _POST ) && isset ( $ _POST [ $ this -> dbHashEmailField ] ) ) { $ hashEmail = $ _POST [ $ this -> dbHashEmailField ] ; } elseif ( isset ( $ _GET ) && isset ( $ _GET [ $ this -> dbHashEmailField ] ) ) { $ hashEmail = $ _GET [ $ this -> dbHashEmailField ] ; } else { $ result [ 'email_error' ] = "\n" . '[' . $ this -> dbHashEmailField . '] field is not passed' ; } } if ( ! isset ( $ hashPassword ) ) { if ( isset ( $ _POST ) && isset ( $ _POST [ $ this -> dbHashPasswordField ] ) ) { $ hashPassword = $ _POST [ $ this -> dbHashPasswordField ] ; } elseif ( isset ( $ _GET ) && isset ( $ _GET [ $ this -> dbHashPasswordField ] ) ) { $ hashPassword = $ _GET [ $ this -> dbHashPasswordField ] ; } else { $ result [ 'email_error' ] = "\n" . '[' . $ this -> dbHashPasswordField . '] field is not passed' ; } } if ( isset ( $ hashEmail ) && isset ( $ hashPassword ) ) { $ hashEmail = $ this -> hash ( $ hashEmail ) ; $ hashPassword = $ this -> hash ( $ hashPassword ) ; $ authorizeResult = $ this -> authorizeWithEmail ( $ hashEmail , $ hashPassword ) ; if ( $ authorizeResult -> code == EmailStatus :: SUCCESS_EMAIL_AUTHORIZE ) { $ result [ 'status' ] = '1' ; } $ result [ self :: RESPONSE_STATUS_TEXTFIELD ] = $ authorizeResult -> text ; $ result [ self :: RESPONSE_STATUS_FIELD ] = $ authorizeResult -> code ; $ result = array_merge ( $ result , $ authorizeResult -> response ) ; } return $ result ; }
1373	public function all ( ) { if ( is_array ( $ this -> data ) ) { return $ this -> data ; } return $ this -> data = $ this -> route -> getCodec ( ) -> all ( $ this -> request ) ; }
9768	function lengthOf ( int $ value = null ) : self { if ( $ value === null ) return $ this -> setFlag ( 'length' ) ; if ( is_string ( $ this -> target ) ) { $ constraint = equalTo ( $ value ) ; $ target = mb_strlen ( $ this -> target ) ; } else { $ constraint = countOf ( $ value ) ; $ target = $ this -> target ; } return $ this -> expect ( $ target , $ constraint ) ; }
12798	public function getLines ( $ lazy = true , $ raw = false ) { if ( is_null ( $ this -> _lines ) ) { $ file = $ this -> filePointer ; if ( ! $ file ) { return false ; } rewind ( $ file ) ; $ this -> _lines = [ ] ; $ currentLineNumber = 0 ; while ( ( $ buffer = fgetcsv ( $ this -> filePointer , 0 , $ this -> delimeter ) ) !== false ) { $ currentLineNumber ++ ; if ( $ currentLineNumber <= $ this -> skipLines ) { continue ; } $ line = Yii :: createObject ( [ 'class' => SourceFileLine :: className ( ) , 'sourceFile' => $ this , 'lineNumber' => $ currentLineNumber - 1 , 'content' => $ buffer ] ) ; if ( $ this -> testIgnore ( $ line ) ) { continue ; } $ lineId = $ line -> id ; if ( ! isset ( $ lineId ) ) { continue ; } $ this -> _lines [ $ lineId ] = $ line ; if ( $ lazy ) { $ line -> clean ( ) ; } } } return $ this -> _lines ; }
1231	public function resolveOptions ( array $ configuration ) { foreach ( $ configuration as $ key => $ value ) { if ( isset ( $ this -> definitions [ $ key ] ) ) { $ def = $ this -> definitions [ $ key ] ; $ this -> checkType ( $ def [ 'valid' ] , $ key , $ value ) ; if ( isset ( $ def [ 'fn' ] ) ) { $ def [ 'fn' ] ( $ configuration [ $ key ] , $ configuration ) ; } } } return $ configuration ; }
11180	protected function set ( $ key , $ value ) { $ cache = apc_fetch ( $ this -> getKey ( ) ) ; $ cache [ $ key ] = $ value ; apc_store ( $ this -> getKey ( ) , $ cache ) ; }
258	public function render ( $ view , $ params = [ ] , $ context = null ) { $ viewFile = $ this -> findViewFile ( $ view , $ context ) ; return $ this -> renderFile ( $ viewFile , $ params , $ context ) ; }
9754	public static function assertFile ( $ filename ) { if ( ! is_file ( $ filename ) ) { throw new InvalidArgumentException ( 'File "' . $ filename . '" does not exist.' ) ; } if ( ! is_readable ( $ filename ) ) { throw new InvalidArgumentException ( 'Could not open "' . $ filename . '" for reading.' ) ; } }
6600	public function unlinkFiles ( $ fileName ) { $ folder = $ this -> getWebrootFolder ( ) ; if ( $ fileName ) { if ( @ file_exists ( $ folder . '/' . $ fileName ) ) { unlink ( $ folder . '/' . $ fileName ) ; } if ( @ file_exists ( $ folder . '/' . $ this -> thumbFolder . '/' . $ fileName ) ) { unlink ( $ folder . '/' . $ this -> thumbFolder . '/' . $ fileName ) ; } if ( is_array ( $ this -> sizes ) ) { $ i = 0 ; foreach ( $ this -> sizes as $ size ) { if ( @ file_exists ( $ folder . '/' . $ i . '/' . $ fileName ) ) { unlink ( $ folder . '/' . $ i . '/' . $ fileName ) ; } $ i ++ ; } } } }
6590	public function put ( $ url , $ data = null , $ len = null , $ method = "PUT" ) { return $ this -> request ( [ CURLOPT_PUT => true , CURLOPT_CUSTOMREQUEST => $ method ? : "PUT" , CURLOPT_URL => "$url" , CURLOPT_INFILE => $ data , CURLOPT_INFILESIZE => $ len , ] ) ; }
12811	private static function getForeignKeysNames ( string $ table ) : array { if ( self :: $ foreignKeysCache === null || ! array_key_exists ( $ table , self :: $ foreignKeysCache ) ) self :: getForeignKeys ( $ table ) ; return array_keys ( self :: $ foreignKeysCache [ $ table ] ) ; }
7157	private function setSubjectState ( StockSubjectInterface $ subject , $ state ) { if ( $ subject -> getStockState ( ) != $ state ) { $ subject -> setStockState ( $ state ) ; return true ; } return false ; }
4355	protected function checkTimestamp ( $ val ) { $ secs = 86400 * 90 ; $ tsNow = \ time ( ) ; if ( $ val > $ tsNow - $ secs && $ val < $ tsNow + $ secs ) { return \ date ( 'Y-m-d H:i:s' , $ val ) ; } return false ; }
7440	protected function reloadModule ( Wrapper $ wrapper , $ module ) { $ moduleStatus = $ wrapper -> ModuleManager -> reload ( $ module ) ; $ module = Inflector :: camelize ( $ module ) ; switch ( $ moduleStatus ) { case 'AU' : $ wrapper -> Channel -> sendMessage ( 'The Module `' . $ module . '` doesn\'t exist and cannot be reloaded.' ) ; break ; case 'AL' : $ wrapper -> Channel -> sendMessage ( 'The Module `' . $ module . '` is already loaded.' ) ; break ; case 'L' : $ wrapper -> Channel -> sendMessage ( 'Module `' . $ module . '` reloaded successfully.' ) ; break ; case 'NF' : $ wrapper -> Channel -> sendMessage ( 'Failed to reload the Module `' . $ module . '`.' ) ; break ; } }
10570	protected function parseSort ( string $ sort , array & $ sorts ) { if ( strlen ( trim ( $ sort ) ) === 0 ) { return ; } if ( substr ( $ sort , 0 , 1 ) == "[" ) { $ json = json_decode ( $ sort ) ; if ( is_array ( $ json ) ) { foreach ( $ json as $ s ) { if ( is_object ( $ s ) ) { $ sorts [ $ s -> property ] = strcasecmp ( self :: DESC , $ s -> direction ) !== 0 ; } } return ; } } if ( substr ( $ sort , - 4 ) == ",asc" ) { $ sorts [ substr ( $ sort , 0 , strlen ( $ sort ) - 4 ) ] = true ; } elseif ( substr ( $ sort , - 5 ) == ",desc" ) { $ sorts [ substr ( $ sort , 0 , strlen ( $ sort ) - 5 ) ] = false ; } elseif ( substr ( $ sort , - 10 ) == ":ascending" ) { $ sorts [ substr ( $ sort , 0 , strlen ( $ sort ) - 10 ) ] = true ; } elseif ( substr ( $ sort , - 11 ) == ":descending" ) { $ sorts [ substr ( $ sort , 0 , strlen ( $ sort ) - 11 ) ] = false ; } else { foreach ( explode ( ',' , $ sort ) as $ s ) { if ( substr ( $ s , 0 , 1 ) === '-' ) { $ sorts [ substr ( $ s , 1 ) ] = false ; } elseif ( substr ( $ s , 0 , 1 ) === '+' ) { $ sorts [ substr ( $ s , 1 ) ] = true ; } else { $ sorts [ $ s ] = true ; } } } }
8729	protected function updateFolderName ( HTTPRequest $ request ) { if ( ! $ this -> getCanSelectFolder ( ) ) { return ; } $ folderID = $ request -> requestVar ( "{$this->Name}/folder" ) ; $ path = $ this -> folderPathFromID ( $ folderID ) ; if ( $ path !== false ) { $ this -> setFolderName ( $ path ) ; $ this -> selectField -> setValue ( $ folderID ) ; } }
12693	public function generate ( ) { $ templates = array_merge ( array_keys ( $ this -> templates [ "base" ] ) , array_keys ( $ this -> templates [ "template" ] ) ) ; foreach ( $ templates as $ template ) { $ templateDir = $ this -> themeDir . '/' . $ template ; if ( ! is_dir ( $ templateDir ) ) { continue ; } $ finder = new Finder ( ) ; $ files = $ finder -> files ( ) -> depth ( 0 ) -> in ( $ templateDir ) ; foreach ( $ files as $ file ) { $ file = ( string ) $ file ; $ slotName = basename ( $ file , '.json' ) ; $ json = FilesystemTools :: readFile ( $ file ) ; $ slot = json_decode ( $ json , true ) ; $ blocks = array ( ) ; if ( array_key_exists ( "blocks" , $ slot ) ) { $ blocks = $ slot [ "blocks" ] ; } $ slotManager = $ this -> slotsManagerFactory -> createSlotManager ( $ slot [ "repeat" ] ) ; $ slotManager -> addSlot ( $ slotName , $ blocks ) ; } } }
3702	protected function getLegend ( $ name , $ palette , $ prevLegend = null ) { if ( strpos ( $ name , '+' ) === 0 ) { $ name = substr ( $ name , 1 ) ; } if ( ! $ palette -> hasLegend ( $ name ) ) { $ palette -> addLegend ( new Legend ( $ name ) , $ prevLegend ) ; } return $ palette -> getLegend ( $ name ) ; }
5154	public function configure ( ) { $ configuration = $ this -> getConfiguration ( ) ; if ( $ configuration instanceof ConfigurationInterface ) { $ this -> configuration -> configure ( $ this ) ; } }
10548	public function setTemplate ( Template $ template ) { $ this -> template = $ template ; $ this -> setVariable ( 'template' , $ template ) ; $ this -> setVariable ( 'tpl' , $ template ) ; return $ this ; }
554	private function notifyCachesCanBeFlushed ( $ caches ) { $ this -> stdout ( "The following caches were found in the system:\n\n" , Console :: FG_YELLOW ) ; foreach ( $ caches as $ name => $ class ) { if ( $ this -> canBeFlushed ( $ class ) ) { $ this -> stdout ( "\t* $name ($class)\n" , Console :: FG_GREEN ) ; } else { $ this -> stdout ( "\t* $name ($class) - can not be flushed via console\n" , Console :: FG_YELLOW ) ; } } $ this -> stdout ( "\n" ) ; }
7250	protected function validateDeliveryAddress ( SaleInterface $ sale , Constraint $ constraint ) { if ( ! $ sale -> isSameAddress ( ) && null === $ sale -> getDeliveryAddress ( ) ) { $ this -> context -> buildViolation ( $ constraint -> delivery_address_is_required ) -> atPath ( 'deliveryAddress' ) -> addViolation ( ) ; } elseif ( $ sale -> isSameAddress ( ) && null !== $ sale -> getDeliveryAddress ( ) ) { $ this -> context -> buildViolation ( $ constraint -> delivery_address_should_be_null ) -> atPath ( 'deliveryAddress' ) -> addViolation ( ) ; } }
9877	private function writeFileVersion ( XMLWriter $ objWriter ) { $ objWriter -> startElement ( 'fileVersion' ) ; $ objWriter -> writeAttribute ( 'appName' , 'xl' ) ; $ objWriter -> writeAttribute ( 'lastEdited' , '4' ) ; $ objWriter -> writeAttribute ( 'lowestEdited' , '4' ) ; $ objWriter -> writeAttribute ( 'rupBuild' , '4505' ) ; $ objWriter -> endElement ( ) ; }
7781	public function get ( $ key ) { if ( array_key_exists ( $ key , $ this -> messages ) ) { return ! empty ( $ this -> messages [ $ key ] ) ? $ this -> messages [ $ key ] : null ; } return null ; }
7979	public function getSessionProperties ( $ sessId ) { return json_decode ( self :: getClient ( ) -> getPcaSessionProperties ( $ this -> pp , $ this -> sn , $ sessId ) ) ; }
12116	public static function getShortName ( $ fqn ) { $ fqn_parts = explode ( '\\' , $ fqn ) ; $ final = array_pop ( $ fqn_parts ) ; if ( empty ( $ fqn_parts ) ) { return $ final ; } $ fqn_caps = preg_replace ( '/[a-z]+/' , '' , $ fqn_parts ) ; return implode ( '\\' , $ fqn_caps ) . '\\' . $ final ; }
3610	public function getDeviceSchedule ( $ serial_number = NULL ) { $ this -> prepareForGet ( ) ; $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ schedule_days = $ this -> last_status -> schedule -> { $ serial_number } -> days ; $ schedule = array ( ) ; foreach ( ( array ) $ schedule_days as $ day => $ scheduled_events ) { $ events = array ( ) ; foreach ( $ scheduled_events as $ scheduled_event ) { if ( $ scheduled_event -> entry_type == 'setpoint' ) { $ events [ ( int ) $ scheduled_event -> time ] = ( object ) array ( 'time' => $ scheduled_event -> time / 60 , 'target_temperature' => $ scheduled_event -> type == 'RANGE' ? array ( $ this -> temperatureInUserScale ( ( float ) $ scheduled_event -> { 'temp-min' } ) , $ this -> temperatureInUserScale ( ( float ) $ scheduled_event -> { 'temp-max' } ) ) : $ this -> temperatureInUserScale ( ( float ) $ scheduled_event -> temp ) , 'mode' => $ scheduled_event -> type == 'HEAT' ? TARGET_TEMP_MODE_HEAT : ( $ scheduled_event -> type == 'COOL' ? TARGET_TEMP_MODE_COOL : TARGET_TEMP_MODE_RANGE ) ) ; } } if ( ! empty ( $ events ) ) { ksort ( $ events ) ; $ schedule [ ( int ) $ day ] = array_values ( $ events ) ; } } ksort ( $ schedule ) ; $ sorted_schedule = array ( ) ; foreach ( $ schedule as $ day => $ events ) { $ sorted_schedule [ $ this -> days_maps [ ( int ) $ day ] ] = $ events ; } return $ sorted_schedule ; }
5022	protected function copyArrayValues ( array $ source , array $ keys ) { $ target = [ ] ; foreach ( $ keys as $ key => $ spec ) { if ( is_int ( $ key ) ) { $ key = $ spec ; $ spec = null ; } if ( ! array_key_exists ( $ key , $ source ) ) { continue ; } if ( null === $ spec ) { $ target [ $ key ] = $ source [ $ key ] ; continue ; } if ( is_string ( $ spec ) ) { $ target [ $ spec ] [ $ key ] = $ source [ $ key ] ; continue ; } if ( isset ( $ spec [ 'if' ] ) && $ source [ $ key ] !== $ spec [ 'if' ] ) { continue ; } if ( isset ( $ spec [ 'key' ] ) ) { $ targetKeys = is_array ( $ spec [ 'key' ] ) ? $ spec [ 'key' ] : [ $ spec [ 'key' ] ] ; $ value = isset ( $ spec [ 'value' ] ) ? $ spec [ 'value' ] : $ source [ $ key ] ; } else { $ targetKeys = $ spec ; $ value = $ source [ $ key ] ; } $ tmpTarget = & $ target ; foreach ( $ targetKeys as $ targetKey ) { if ( '*' == $ targetKey ) { $ targetKey = $ key ; } if ( ! isset ( $ tmpTarget [ $ targetKey ] ) ) { $ tmpTarget [ $ targetKey ] = [ ] ; } $ tmpTarget = & $ tmpTarget [ $ targetKey ] ; } $ tmpTarget = $ value ; } return $ target ; }
9015	function getRoot ( ) { $ sm = $ this -> sl -> getServiceLocator ( ) ; $ event = $ sm -> get ( 'Application' ) -> getMvcEvent ( ) ; return $ event -> getViewModel ( ) ; }
367	public function renderFilters ( ) { if ( $ this -> filterModel !== null ) { $ cells = [ ] ; foreach ( $ this -> columns as $ column ) { $ cells [ ] = $ column -> renderFilterCell ( ) ; } return Html :: tag ( 'tr' , implode ( '' , $ cells ) , $ this -> filterRowOptions ) ; } return '' ; }
5397	public function paintMessage ( $ message ) { parent :: paintMessage ( $ message ) ; print $ this -> getIndent ( 1 ) ; print '<' . $ this -> namespace . 'message>' ; print $ this -> toParsedXml ( $ message ) ; print '</' . $ this -> namespace . "message>\n" ; }
5943	public function fetchObject ( AbstractNode $ node , array $ siblings = array ( ) ) { $ this -> currObj = $ node ; $ this -> currSib = $ siblings ; $ args = array ( $ this -> getPrefix ( ) , $ this -> getCorpusIcon ( ) , $ this -> getCorpusName ( ) , ) ; return StringHelper :: factory ( $ this -> pattern ) -> arg ( $ args ) ; }
1101	protected function parentId ( ) { switch ( $ this -> position ) { case 'root' : return NULL ; case 'child' : return $ this -> target -> getKey ( ) ; default : return $ this -> target -> getParentId ( ) ; } }
9381	public function set ( $ id , $ concrete , $ share = false ) { return $ this -> add ( $ id , $ concrete , $ share ) ; }
6727	public function set_movie_votes ( $ post_id , $ total_votes ) { $ total_votes = $ total_votes ? : 'N/B' ; if ( ! add_post_meta ( $ post_id , 'imdbVotes' , $ total_votes , true ) ) { update_post_meta ( $ post_id , 'imdbVotes' , $ total_votes ) ; } }
11168	public function getApiAsArray ( ) { if ( $ this -> useCache ( ) ) { if ( $ this -> getExtCache ( ) -> isApiCached ( ) ) { return $ this -> getExtCache ( ) -> getApi ( ) ; } } $ api = $ this -> generateApi ( ) ; if ( $ this -> useCache ( ) ) { $ this -> getExtCache ( ) -> cacheApi ( $ api ) ; } return $ api ; }
3079	public static function getCatInfo ( AssessmentTest $ test , $ namespace = '' ) { if ( $ namespace === '' ) { $ namespace = CatService :: QTI_2X_ADAPTIVE_XML_NAMESPACE ; } $ info = [ ] ; foreach ( $ test -> getComponentsByClassName ( 'assessmentSection' ) as $ assessmentSection ) { if ( ( $ selection = $ assessmentSection -> getSelection ( ) ) !== null && ( ( $ xmlExtension = $ selection -> getXml ( ) ) ) !== null ) { $ xpath = new \ DOMXPath ( $ xmlExtension ) ; $ xpath -> registerNamespace ( 'ais' , $ namespace ) ; $ sectionIdentifier = $ assessmentSection -> getIdentifier ( ) ; $ sectionInfo = [ ] ; foreach ( $ xpath -> query ( './/ais:adaptiveItemSelection/ais:adaptiveEngineRef' , $ xmlExtension ) as $ adaptiveEngineRef ) { $ sectionInfo [ 'adaptiveEngineRef' ] = $ adaptiveEngineRef -> getAttribute ( 'href' ) ; } foreach ( $ xpath -> query ( './/ais:adaptiveItemSelection/ais:adaptiveSettingsRef' , $ xmlExtension ) as $ adaptiveSettingsRef ) { $ sectionInfo [ 'adaptiveSettingsRef' ] = $ adaptiveSettingsRef -> getAttribute ( 'href' ) ; } foreach ( $ xpath -> query ( './/ais:adaptiveItemSelection/ais:qtiUsagedataRef' , $ xmlExtension ) as $ qtiUsagedataRef ) { $ sectionInfo [ 'qtiUsagedataRef' ] = $ qtiUsagedataRef -> getAttribute ( 'href' ) ; } foreach ( $ xpath -> query ( './/ais:adaptiveItemSelection/ais:qtiMetadataRef' , $ xmlExtension ) as $ qtiMetadataRef ) { $ sectionInfo [ 'qtiMetadataRef' ] = $ qtiMetadataRef -> getAttribute ( 'href' ) ; } if ( ! empty ( $ sectionInfo ) ) { $ info [ $ sectionIdentifier ] = $ sectionInfo ; } } } return $ info ; }
12173	protected static function addReflectionArguments ( Definition $ factory , ReflectionFunctionAbstract $ reflectionFunction = null ) { if ( ! $ reflectionFunction ) { $ callable = $ factory -> getCallable ( ) ; if ( is_array ( $ callable ) ) { $ reflectionFunction = new ReflectionMethod ( $ callable [ 0 ] , $ callable [ 1 ] ) ; } else { $ reflectionFunction = new ReflectionFunction ( $ callable ) ; } } foreach ( $ reflectionFunction -> getParameters ( ) as $ arg ) { try { $ name = $ arg -> getName ( ) ; $ required = ! $ arg -> isOptional ( ) ; if ( $ argClass = $ arg -> getClass ( ) ) { $ factory -> addClassArgument ( $ name , $ argClass -> getName ( ) , $ required ) ; } else { $ default = ( $ required ? null : $ arg -> getDefaultValue ( ) ) ; $ factory -> addScalarArgument ( $ name , null , $ required , $ default ) ; } } catch ( ReflectionException $ re ) { throw UnresolvableArgumentException :: fromReflectionParam ( $ arg , $ reflectionFunction , $ re ) ; } } }
3297	public function doAutoRunEnhancements ( LeadEvent $ event ) { $ lead = $ event -> getLead ( ) ; if ( $ lead && ( null !== $ lead -> getDateIdentified ( ) || ! $ lead -> isAnonymous ( ) ) ) { $ leadKey = strtolower ( implode ( '|' , [ $ lead -> getFirstname ( ) , ( $ lead -> getLastActive ( ) ? $ lead -> getLastActive ( ) -> format ( 'c' ) : '' ) , $ lead -> getEmail ( ) , $ lead -> getPhone ( ) , $ lead -> getMobile ( ) , ] ) ) ; if ( strlen ( $ leadKey ) > 3 ) { if ( isset ( $ this -> leadsEnhanced [ $ leadKey ] ) ) { return ; } else { $ this -> leadsEnhanced [ $ leadKey ] = true ; } } $ integrations = $ this -> enhancerHelper -> getEnhancerIntegrations ( ) ; foreach ( $ integrations as $ integration ) { $ settings = $ integration -> getIntegrationSettings ( ) ; if ( $ settings -> getIsPublished ( ) ) { $ features = $ settings -> getFeatureSettings ( ) ; if ( isset ( $ features [ 'autorun_enabled' ] ) && $ features [ 'autorun_enabled' ] ) { try { $ integration -> doEnhancement ( $ lead ) ; } catch ( \ Exception $ exception ) { $ e = new ApiErrorException ( 'There was an issue using enhancer: ' . $ integration -> getName ( ) , 0 , $ exception ) ; if ( ! empty ( $ lead ) ) { $ e -> setContact ( $ lead ) ; } throw $ e ; } } } } $ this -> logger -> info ( 'doAutoRunEnhancements complete' ) ; } }
2350	public function copyTo ( $ strNewName ) { $ strParent = \ dirname ( $ strNewName ) ; if ( ! is_dir ( $ this -> strRootDir . '/' . $ strParent ) ) { new Folder ( $ strParent ) ; } $ return = $ this -> Files -> copy ( $ this -> strFile , $ strNewName ) ; $ syncSource = Dbafs :: shouldBeSynchronized ( $ this -> strFile ) ; $ syncTarget = Dbafs :: shouldBeSynchronized ( $ strNewName ) ; if ( $ syncSource && $ syncTarget ) { Dbafs :: copyResource ( $ this -> strFile , $ strNewName ) ; } elseif ( $ syncTarget ) { Dbafs :: addResource ( $ strNewName ) ; } return $ return ; }
7524	function parse_all ( ) { $ this -> errors = array ( ) ; $ this -> status [ 'last_pos' ] = - 1 ; if ( ( $ this -> token === self :: TOK_TAG_OPEN ) || ( $ this -> next_pos ( '<' , false ) === self :: TOK_UNKNOWN ) ) { do { if ( ! $ this -> parse_tag ( ) ) { return false ; } } while ( $ this -> next_pos ( '<' ) !== self :: TOK_NULL ) ; } $ this -> pos = $ this -> size ; $ this -> parse_text ( ) ; return true ; }
4905	public function getByKey ( $ key = null ) { if ( ! array_key_exists ( $ key , $ this -> applicationMap ) ) { $ this -> applicationMap [ $ key ] = array ( ) ; $ config = $ this -> serviceManager -> get ( 'Config' ) ; $ appConfig = $ this -> serviceManager -> get ( 'ApplicationConfig' ) ; foreach ( $ appConfig [ 'modules' ] as $ module ) { if ( array_key_exists ( $ module , $ config ) ) { if ( array_key_exists ( $ key , $ config [ $ module ] ) ) { $ this -> applicationMap [ $ key ] [ strtolower ( $ module ) ] = $ config [ $ module ] [ $ key ] ; } } } } return $ this -> applicationMap [ $ key ] ; }
8303	public function assertBool ( $ config , $ key ) { if ( array_key_exists ( $ key , $ config ) && ! is_bool ( $ config [ $ key ] ) ) { throw new ConfigurationException ( $ key . " must be a boolean value." ) ; } return $ this ; }
762	private function tokensMatch ( SqlToken $ patternToken , SqlToken $ token , $ offset = 0 , & $ firstMatchIndex = null , & $ lastMatchIndex = null ) { if ( $ patternToken -> getIsCollection ( ) !== $ token -> getIsCollection ( ) || ( ! $ patternToken -> getIsCollection ( ) && $ patternToken -> content !== $ token -> content ) ) { return false ; } if ( $ patternToken -> children === $ token -> children ) { $ firstMatchIndex = $ lastMatchIndex = $ offset ; return true ; } $ firstMatchIndex = $ lastMatchIndex = null ; $ wildcard = false ; for ( $ index = 0 , $ count = count ( $ patternToken -> children ) ; $ index < $ count ; $ index ++ ) { if ( $ patternToken [ $ index ] -> content === 'any' ) { $ wildcard = true ; continue ; } for ( $ limit = $ wildcard ? count ( $ token -> children ) : $ offset + 1 ; $ offset < $ limit ; $ offset ++ ) { if ( ! $ wildcard && ! isset ( $ token [ $ offset ] ) ) { break ; } if ( ! $ this -> tokensMatch ( $ patternToken [ $ index ] , $ token [ $ offset ] ) ) { continue ; } if ( $ firstMatchIndex === null ) { $ firstMatchIndex = $ offset ; $ lastMatchIndex = $ offset ; } else { $ lastMatchIndex = $ offset ; } $ wildcard = false ; $ offset ++ ; continue 2 ; } return false ; } return true ; }
7633	public function putBlock ( $ containerName = '' , $ blobName = '' , $ identifier = '' , $ contents = '' , $ leaseId = null ) { Assertion :: notEmpty ( $ containerName , 'Container name is not specified' ) ; self :: assertValidContainerName ( $ containerName ) ; Assertion :: notEmpty ( $ blobName , 'Blob name is not specified.' ) ; Assertion :: notEmpty ( $ identifier , 'Block identifier is not specified.' ) ; self :: assertValidRootContainerBlobName ( $ containerName , $ blobName ) ; if ( strlen ( $ contents ) > self :: MAX_BLOB_TRANSFER_SIZE ) { throw new BlobException ( 'Block size is too big.' ) ; } $ headers = array ( ) ; if ( ! is_null ( $ leaseId ) ) { $ headers [ 'x-ms-lease-id' ] = $ leaseId ; } $ resourceName = self :: createResourceName ( $ containerName , $ blobName ) ; $ response = $ this -> performRequest ( $ resourceName , array ( 'comp' => 'block' , 'blockid' => base64_encode ( $ identifier ) ) , 'PUT' , $ headers , false , $ contents , self :: RESOURCE_BLOB , self :: PERMISSION_WRITE ) ; if ( ! $ response -> isSuccessful ( ) ) { throw new BlobException ( $ this -> getErrorMessage ( $ response , 'Resource could not be accessed.' ) ) ; } }
11679	protected function log ( $ message , $ priority = Logger :: DEBUG , array $ extra = [ ] ) { if ( $ this -> getLogger ( ) === null ) { return $ this ; } $ this -> getLogger ( ) -> log ( $ priority , $ message , $ extra ) ; return $ this ; }
7535	function delete ( ) { if ( ( $ p = $ this -> parent ) !== null ) { $ this -> parent = null ; $ p -> deleteChild ( $ this ) ; } else { $ this -> clear ( ) ; } }
5756	private function selectWithRoleSubquery ( ? string $ columns = null , array $ whereColumnsInfo = null , string $ orderBy = null ) { $ columns = $ columns ?? $ this -> defaultSelectColumnsString ; $ q = new QueryBuilder ( "SELECT $columns " . $ this -> getFromClause ( ) . " WHERE permissions.id IN (SELECT permissions.id FROM permissions JOIN roles_permissions ON permissions.id=roles_permissions.permission_id JOIN roles ON roles_permissions.role_id=roles.id WHERE" ) ; $ opCount = 0 ; foreach ( $ whereColumnsInfo [ 'roles.role' ] [ 'operators' ] as $ op ) { $ sqlVarCount = $ opCount + 1 ; if ( $ opCount > 0 ) { $ q -> add ( " OR " ) ; } $ q -> add ( " roles.role $op $$sqlVarCount" , $ whereColumnsInfo [ 'roles.role' ] [ 'values' ] [ $ opCount ] ) ; ++ $ opCount ; } $ q -> add ( ") ORDER BY " . $ this -> getOrderBy ( ) ) ; return $ q -> execute ( ) ; }
11525	private function getDom ( $ url ) { $ ch = curl_init ( ) ; $ timeout = 5 ; curl_setopt ( $ ch , CURLOPT_URL , $ url ) ; curl_setopt ( $ ch , CURLOPT_RETURNTRANSFER , 1 ) ; curl_setopt ( $ ch , CURLOPT_CONNECTTIMEOUT , $ timeout ) ; $ dom = curl_exec ( $ ch ) ; curl_close ( $ ch ) ; return $ dom ; }
10381	protected static function unify_files ( $ params , $ data = '' ) { $ type = $ params [ 'type' ] ; $ routes = $ params [ 'routes' ] ; $ extension = ( 'style' == $ type ) ? '.css' : '.js' ; $ hash = sha1 ( implode ( '' , $ params [ 'files' ] ) ) ; $ min_file = $ routes [ 'path' ] . $ hash . $ extension ; if ( ! is_file ( $ min_file ) || self :: $ changes ) { foreach ( $ params [ 'paths' ] as $ id => $ path ) { if ( isset ( $ params [ 'urls' ] [ $ id ] ) ) { $ url = $ params [ 'urls' ] [ $ id ] ; $ path = $ routes [ 'path' ] . $ params [ 'files' ] [ $ id ] ; $ data .= self :: save_external_file ( $ url , $ path ) ; } $ data .= file_get_contents ( $ path ) ; } $ data = ( self :: $ minify ) ? self :: compress_files ( $ data ) : $ data ; self :: save_file ( $ min_file , $ data ) ; } self :: set_processed_files ( ) ; return self :: set_new_params ( $ type , $ hash , $ routes [ 'url' ] , $ extension ) ; }
918	public static function sortFixers ( array $ fixers ) { return self :: stableSort ( $ fixers , static function ( FixerInterface $ fixer ) { return $ fixer -> getPriority ( ) ; } , static function ( $ a , $ b ) { return self :: cmpInt ( $ b , $ a ) ; } ) ; }
1415	public function invalidResource ( string $ path , ? string $ detail = null , array $ failed = [ ] ) : ErrorInterface { return new Error ( null , null , Response :: HTTP_UNPROCESSABLE_ENTITY , $ this -> trans ( 'resource_invalid' , 'code' ) , $ this -> trans ( 'resource_invalid' , 'title' ) , $ detail ? : $ this -> trans ( 'resource_invalid' , 'detail' ) , $ this -> pointer ( $ path ) , $ failed ? compact ( 'failed' ) : null ) ; }
9043	protected function logImpl ( $ level , $ message , array $ context = array ( ) ) { if ( ! $ this -> levelHasReached ( $ level ) ) { return ; } if ( $ this -> isRotationNeeded ( ) ) { unlink ( $ this -> file ) ; } $ ms = $ this -> getMessage ( $ level , $ message , $ context ) ; $ fos = new FileOutputStream ( $ this -> file , true ) ; $ fos -> write ( $ ms ) ; $ fos -> flush ( ) ; $ fos -> close ( ) ; }
9738	public function setFitToHeight ( $ pValue , $ pUpdate = true ) { $ this -> fitToHeight = $ pValue ; if ( $ pUpdate ) { $ this -> fitToPage = true ; } return $ this ; }
7271	public function delete ( ) { $ tableName = static :: tableName ( ) ; $ columns = static :: tableColumns ( ) ; $ idColumn = static :: $ idColumn ; if ( isset ( $ this -> $ idColumn ) ) { $ status = Db :: query ( " delete from $tableName where $idColumn = :id " , [ "id" => $ this -> $ idColumn ] , static :: getDbName ( ) , false ) ; } else { $ condition = "" ; $ params = [ ] ; foreach ( $ columns as $ column ) { $ name = $ column [ "column_name" ] ; $ key = $ column [ "column_key" ] ; if ( isset ( $ this -> $ name ) ) { $ condition .= "$name = :$name and " ; $ params [ $ name ] = $ this -> encodeValue ( $ name ) ; } } $ condition = substr ( $ condition , 0 , - 5 ) ; var_dump ( " delete from $tableName where $condition " ) ; var_dump ( $ params ) ; $ status = Db :: query ( " delete from $tableName where $condition " , $ params , static :: getDbName ( ) , false ) ; } return $ status !== false && $ status > 0 ; }
5937	public function setFunctionalities ( array $ functionalities ) { $ this -> functionalities = [ ] ; foreach ( $ functionalities as $ item ) { $ this -> addFunctionality ( $ item ) ; } return $ this ; }
6399	public function createEvents ( array $ events ) { $ results = [ ] ; foreach ( $ events as $ index => $ opts ) { $ route = isset ( $ opts [ 'eventname' ] ) ? $ opts [ 'eventname' ] : '' ; if ( isset ( static :: $ routes [ $ route ] ) && ( $ opts [ 'userid' ] > 0 || $ opts [ 'relateduserid' ] > 0 ) ) { try { $ event = '\LogExpander\Events\\' . static :: $ routes [ $ route ] ; array_push ( $ results , ( new $ event ( $ this -> repo ) ) -> read ( $ opts ) ) ; } catch ( \ Exception $ e ) { } } } return $ results ; }
3752	public function resetFallback ( $ strField ) { @ trigger_error ( __CLASS__ . '::' . __METHOD__ . ' is deprecated - handle resetting manually' , E_USER_DEPRECATED ) ; $ metaModel = $ this -> getMetaModel ( ) ; $ attribute = $ metaModel -> getAttribute ( $ strField ) ; $ ids = $ metaModel -> getIdsFromFilter ( null ) ; if ( $ attribute instanceof IComplex ) { $ attribute -> unsetDataFor ( $ ids ) ; } if ( $ attribute instanceof ITranslated ) { $ attribute -> unsetValueFor ( $ ids , $ this -> getCurrentLanguage ( ) ) ; } if ( $ attribute instanceof IAttribute ) { $ data = array ( ) ; foreach ( $ ids as $ id ) { $ data [ $ id ] = null ; } $ attribute -> setDataFor ( $ data ) ; } throw new \ RuntimeException ( 'Unknown attribute or type ' . $ strField ) ; }
2964	public function performRequest ( $ method , $ path , array $ params = [ ] ) { $ request = $ this -> buildRequest ( $ method , $ path , $ params ) ; try { $ response = $ this -> httpClient -> send ( $ request ) ; $ content = json_decode ( $ response -> getBody ( ) -> getContents ( ) , true ) ; } catch ( ClientException $ ex ) { if ( $ ex -> getResponse ( ) -> getStatusCode ( ) == 401 ) { if ( $ this -> isPsr7Version ( ) ) { $ uri = $ request -> getUri ( ) ; } else { $ uri = $ request -> getUrl ( ) ; } $ message = sprintf ( 'Unauthorized %s Request to %s' , $ request -> getMethod ( ) , $ uri ) ; throw new UnauthorizedRequestException ( $ message ) ; } throw $ ex ; } return $ this -> createResponseFromData ( $ content ) ; }
527	public function registerAssetFiles ( $ view ) { $ manager = $ view -> getAssetManager ( ) ; foreach ( $ this -> js as $ js ) { if ( is_array ( $ js ) ) { $ file = array_shift ( $ js ) ; $ options = ArrayHelper :: merge ( $ this -> jsOptions , $ js ) ; $ view -> registerJsFile ( $ manager -> getAssetUrl ( $ this , $ file ) , $ options ) ; } else { if ( $ js !== null ) { $ view -> registerJsFile ( $ manager -> getAssetUrl ( $ this , $ js ) , $ this -> jsOptions ) ; } } } foreach ( $ this -> css as $ css ) { if ( is_array ( $ css ) ) { $ file = array_shift ( $ css ) ; $ options = ArrayHelper :: merge ( $ this -> cssOptions , $ css ) ; $ view -> registerCssFile ( $ manager -> getAssetUrl ( $ this , $ file ) , $ options ) ; } else { if ( $ css !== null ) { $ view -> registerCssFile ( $ manager -> getAssetUrl ( $ this , $ css ) , $ this -> cssOptions ) ; } } } }
8810	public function destroy ( ) { foreach ( $ _COOKIE as $ key => $ value ) { setcookie ( $ key , null , - 1 , '/' ) ; unset ( $ _COOKIE [ $ key ] ) ; } return ; }
12028	function addExecuteAsyncMethod ( ) { $ body = $ this -> generateCreateFragment ( ) ; $ body .= 'return $this->dispatchAsync($request, $callable);' ; $ docBlock = new DocBlockGenerator ( 'Execute the operation asynchronously, passing the parsed response to the callback' , null ) ; $ tags [ ] = new GenericTag ( 'return' , '\Amp\Promise' ) ; $ docBlock -> setTags ( $ tags ) ; $ callableParamGenerator = new ParameterGenerator ( 'callable' , 'callable' ) ; $ methodGenerator = new MethodGenerator ( 'executeAsync' ) ; $ methodGenerator -> setBody ( $ body ) ; $ methodGenerator -> setDocBlock ( $ docBlock ) ; $ methodGenerator -> setParameters ( [ $ callableParamGenerator ] ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; }
9970	public function setDataValidation ( $ pCellCoordinate , DataValidation $ pDataValidation = null ) { if ( $ pDataValidation === null ) { unset ( $ this -> dataValidationCollection [ $ pCellCoordinate ] ) ; } else { $ this -> dataValidationCollection [ $ pCellCoordinate ] = $ pDataValidation ; } return $ this ; }
11646	private function generateExecuteDocBlock ( $ methodDescription , $ returnType ) { $ docBlock = new DocBlockGenerator ( $ methodDescription , null ) ; $ tags [ ] = new GenericTag ( 'return' , $ returnType ) ; $ docBlock -> setTags ( $ tags ) ; return $ docBlock ; }
12183	public static function getOne ( Item $ parent , Item $ child , $ options = [ ] ) { $ key = md5 ( $ parent -> systemId . "." . $ child -> systemId ) ; if ( isset ( self :: $ _relationships [ $ key ] ) ) { self :: $ _relationships [ $ key ] -> mergeOptions ( $ options ) ; } else { self :: $ _relationships [ $ key ] = new Relationship ( $ parent , $ child , $ options ) ; } return self :: $ _relationships [ $ key ] ; }
11230	public function get ( $ section , array $ params = [ ] , $ headers = [ ] ) { $ params = array_merge ( $ this -> parameters , $ params , $ this -> defaultParameters ) ; return $ this -> client -> get ( $ this -> getUrl ( $ section , $ params ) , $ headers ) ; }
5319	public function isSuccessExit ( ) { $ this -> exitCode = pcntl_wexitstatus ( $ this -> status ) ; return ( pcntl_wifexited ( $ this -> status ) && ( $ this -> exitCode === 0 ) ) ; }
9478	protected function getCalendarDayDownloads ( $ limit = 30 ) { $ arrCalendarDayDownloads = array ( ) ; $ CalendarDays = date ( 'Y-m-d' , mktime ( 0 , 0 , 0 , date ( "m" ) , date ( "d" ) - $ limit , date ( "Y" ) ) ) ; $ objCalendarDayDownloads = \ Database :: getInstance ( ) -> prepare ( "SELECT dl.`id` , FROM_UNIXTIME(det.`tstamp`,GET_FORMAT(DATE,'ISO')) as datum , count(dl.`filename`) as downloads , dl.`filename` FROM `tl_dlstats` dl INNER JOIN `tl_dlstatdets` det on dl.id = det.pid WHERE FROM_UNIXTIME(det.`tstamp`,GET_FORMAT(DATE,'ISO')) >=? GROUP BY dl.`id`, datum ORDER BY datum DESC, `filename`" ) -> execute ( $ CalendarDays ) ; while ( $ objCalendarDayDownloads -> next ( ) ) { $ viewDate = $ this -> parseDate ( $ GLOBALS [ 'TL_CONFIG' ] [ 'dateFormat' ] , strtotime ( $ objCalendarDayDownloads -> datum ) ) ; $ c4d = $ this -> check4details ( $ objCalendarDayDownloads -> id ) ; $ arrCalendarDayDownloads [ ] = array ( $ viewDate , $ objCalendarDayDownloads -> filename , $ this -> getFormattedNumber ( $ objCalendarDayDownloads -> downloads , 0 ) , $ objCalendarDayDownloads -> id , $ c4d , $ objCalendarDayDownloads -> downloads , strtotime ( $ objCalendarDayDownloads -> datum ) ) ; } return $ arrCalendarDayDownloads ; }
240	private function saveTableMetadataToCache ( $ cache , $ name ) { if ( $ cache === null ) { return ; } $ metadata = $ this -> _tableMetadata [ $ name ] ; $ metadata [ 'cacheVersion' ] = static :: SCHEMA_CACHE_VERSION ; $ cache -> set ( $ this -> getCacheKey ( $ name ) , $ metadata , $ this -> db -> schemaCacheDuration , new TagDependency ( [ 'tags' => $ this -> getCacheTag ( ) ] ) ) ; }
5108	private function appendDesc ( & $ column ) : void { if ( is_array ( $ column ) ) { foreach ( $ column as & $ col ) { $ col = "$col DESC" ; } } else { $ column = [ "$column DESC" ] ; } }
2667	public function getSingleDictionary ( $ version , $ dictionaryName ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/dictionary/' . $ dictionaryName ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: GET ) ; return $ result ; }
5892	public static function logEntry ( $ entry ) { $ parts = explode ( "|" , $ entry , 5 ) ; $ array = array ( ) ; if ( count ( $ parts ) != 5 ) { $ array [ "timestamp" ] = 0 ; $ array [ "level" ] = TeamSpeak3 :: LOGLEVEL_ERROR ; $ array [ "channel" ] = "ParamParser" ; $ array [ "server_id" ] = "" ; $ array [ "msg" ] = StringHelper :: factory ( "convert error (" . trim ( $ entry ) . ")" ) ; $ array [ "msg_plain" ] = $ entry ; $ array [ "malformed" ] = true ; } else { $ array [ "timestamp" ] = strtotime ( trim ( $ parts [ 0 ] ) ) ; $ array [ "level" ] = self :: logLevel ( trim ( $ parts [ 1 ] ) ) ; $ array [ "channel" ] = trim ( $ parts [ 2 ] ) ; $ array [ "server_id" ] = trim ( $ parts [ 3 ] ) ; $ array [ "msg" ] = StringHelper :: factory ( trim ( $ parts [ 4 ] ) ) ; $ array [ "msg_plain" ] = $ entry ; $ array [ "malformed" ] = false ; } return $ array ; }
1294	public static function create ( JsonDecoderClientInterface $ client , ClientOptions $ options ) : ResourcePoolInterface { if ( $ options -> usesLowMemoryResourcePool ( ) ) { return new Standard ( $ client -> getApi ( ) , $ client -> getSpaceId ( ) , $ client -> getEnvironmentId ( ) ) ; } return new Extended ( $ client , $ options -> getCacheItemPool ( ) , $ options -> hasCacheAutoWarmup ( ) , $ options -> hasCacheContent ( ) ) ; }
4121	public function getProxy ( $ className , $ identifier ) { $ fqn = ClassUtils :: generateProxyClassName ( $ className , $ this -> proxyNamespace ) ; if ( ! class_exists ( $ fqn , false ) ) { $ fileName = $ this -> getProxyFileName ( $ className ) ; if ( $ this -> autoGenerate ) { $ this -> generateProxyClass ( $ this -> dm -> getClassMetadata ( $ className ) , $ fileName , self :: $ proxyClassTemplate ) ; } require $ fileName ; } if ( ! $ this -> dm -> getMetadataFactory ( ) -> hasMetadataFor ( $ fqn ) ) { $ this -> dm -> getMetadataFactory ( ) -> setMetadataFor ( $ fqn , $ this -> dm -> getClassMetadata ( $ className ) ) ; } return new $ fqn ( $ this -> dm , $ identifier ) ; }
9506	public function listLogs ( Request $ request ) { $ this -> authorize ( LogViewerPolicy :: PERMISSION_LIST ) ; $ stats = $ this -> logViewer -> statsTable ( ) ; $ headers = $ stats -> header ( ) ; $ page = $ request -> get ( 'page' , 1 ) ; $ offset = ( $ page * $ this -> perPage ) - $ this -> perPage ; $ rows = new LengthAwarePaginator ( array_slice ( $ stats -> rows ( ) , $ offset , $ this -> perPage , true ) , count ( $ stats -> rows ( ) ) , $ this -> perPage , $ page ) ; $ rows -> setPath ( $ request -> url ( ) ) ; $ this -> setTitle ( $ title = trans ( 'foundation::log-viewer.titles.logs-list' ) ) ; $ this -> addBreadcrumb ( $ title ) ; return $ this -> view ( 'admin.system.log-viewer.list' , compact ( 'headers' , 'rows' , 'footer' ) ) ; }
7076	private function addDiscountDetails ( array & $ details , Model \ SaleAdjustmentInterface $ discount ) { $ discountResult = $ discount -> getResult ( ) ; $ details [ 'L_PAYMENTREQUEST_0_NAME' . $ this -> line ] = $ discount -> getDesignation ( ) ; $ details [ 'L_PAYMENTREQUEST_0_AMT' . $ this -> line ] = '-' . $ this -> format ( $ discountResult -> getTotal ( ) ) ; $ this -> line ++ ; return - $ discountResult -> getTotal ( ) ; }
5115	public function submitArticle ( Article $ article ) : \ One \ Model \ Article { $ responseArticle = $ this -> post ( self :: ARTICLE_ENDPOINT , $ this -> normalizePayload ( $ article -> getCollection ( ) ) ) ; $ responseArticle = json_decode ( $ responseArticle , true ) ; $ article -> setId ( ( string ) $ responseArticle [ 'data' ] [ 'id' ] ) ; foreach ( $ article -> getPossibleAttachment ( ) as $ field ) { if ( $ article -> hasAttachment ( $ field ) ) { foreach ( $ article -> getAttachmentByField ( $ field ) as $ attachment ) { $ this -> submitAttachment ( $ article -> getId ( ) , $ attachment , $ field ) ; } } } return $ article ; }
11618	private function compressPhase2 ( $ calcIdWriteOff , $ calcIdPhase1 , $ calcIdPhase2 , $ scheme ) { $ pv = $ this -> rouGetPv -> exec ( $ calcIdWriteOff ) ; $ dwnlPlain = $ this -> daoBonDwnl -> getByCalcId ( $ calcIdWriteOff ) ; $ dwnlPhase1 = $ this -> daoBonDwnl -> getByCalcId ( $ calcIdPhase1 ) ; $ ctx = new \ Praxigento \ Core \ Data ( ) ; $ ctx -> set ( PCpmrsPhase2 :: IN_CALC_ID_PHASE2 , $ calcIdPhase2 ) ; $ ctx -> set ( PCpmrsPhase2 :: IN_SCHEME , $ scheme ) ; $ ctx -> set ( PCpmrsPhase2 :: IN_DWNL_PLAIN , $ dwnlPlain ) ; $ ctx -> set ( PCpmrsPhase2 :: IN_DWNL_PHASE1 , $ dwnlPhase1 ) ; $ ctx -> set ( PCpmrsPhase2 :: IN_MAP_PV , $ pv ) ; $ out = $ this -> procCmprsPhase2 -> exec ( $ ctx ) ; $ dwnlPhase2 = $ out -> get ( PCpmrsPhase2 :: OUT_DWNL_PHASE2 ) ; $ legs = $ out -> get ( PCpmrsPhase2 :: OUT_LEGS ) ; $ result = [ $ dwnlPhase2 , $ legs ] ; return $ result ; }
27	public function write ( ) { $ data = array ( ) ; $ dumper = new ArrayDumper ( ) ; foreach ( $ this -> getCanonicalPackages ( ) as $ package ) { $ data [ ] = $ dumper -> dump ( $ package ) ; } usort ( $ data , function ( $ a , $ b ) { return strcmp ( $ a [ 'name' ] , $ b [ 'name' ] ) ; } ) ; $ this -> file -> write ( $ data ) ; }
9308	public function register ( ) { $ app = $ this -> app ; $ app -> bind ( 'Germanazo\CkanApi\CkanApiClient' , function ( ) { $ config = [ 'base_uri' => config ( 'ckan_api.url' ) , 'headers' => [ 'Authorization' => config ( 'ckan_api.api_key' ) ] , ] ; return new CkanApiClient ( new Client ( $ config ) ) ; } ) ; $ app -> alias ( 'Germanazo\CkanApi\CkanApiClient' , 'CkanApi' ) ; }
9090	function isMultipart ( ) { foreach ( $ this -> fields as $ field ) { if ( ! $ field instanceof Field ) { continue ; } if ( $ field -> getType ( ) == 'file' || $ field -> getValueType ( ) == 'file' || $ field -> getDataType ( ) ) { return true ; } } return false ; }
9989	public function generateNavigation ( ) { if ( $ this -> spreadsheet === null ) { throw new WriterException ( 'Internal Spreadsheet object not set to an instance of an object.' ) ; } $ sheets = [ ] ; if ( $ this -> sheetIndex === null ) { $ sheets = $ this -> spreadsheet -> getAllSheets ( ) ; } else { $ sheets [ ] = $ this -> spreadsheet -> getSheet ( $ this -> sheetIndex ) ; } $ html = '' ; if ( count ( $ sheets ) > 1 ) { $ sheetId = 0 ; $ html .= '<ul class="navigation">' . PHP_EOL ; foreach ( $ sheets as $ sheet ) { $ html .= ' <li class="sheet' . $ sheetId . '"><a href="#sheet' . $ sheetId . '">' . $ sheet -> getTitle ( ) . '</a></li>' . PHP_EOL ; ++ $ sheetId ; } $ html .= '</ul>' . PHP_EOL ; } return $ html ; }
8624	public function setShippingServiceList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ShippingServiceList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
11663	public static function saveToFile ( $ file , $ properties ) { $ prop_string = self :: saveToString ( $ properties ) ; $ real_file = File :: asFile ( $ file ) ; if ( ! $ real_file -> exists ( ) ) { $ real_file -> touch ( ) ; } $ real_file -> setContent ( $ prop_string ) ; }
2498	private function getLanguageFilter ( array $ languageCodes ) { $ languageFilters = array ( ) ; foreach ( $ languageCodes as $ languageCode ) { $ condition = new CustomField ( self :: FIELD_LANGUAGE , Operator :: EQ , $ languageCode ) ; $ excluded = $ this -> getExcludedLanguageCodes ( $ languageCodes , $ languageCode ) ; if ( ! empty ( $ excluded ) ) { $ condition = new LogicalAnd ( array ( $ condition , new LogicalNot ( new CustomField ( self :: FIELD_LANGUAGES , Operator :: IN , $ excluded ) ) , ) ) ; } $ languageFilters [ ] = $ condition ; } if ( count ( $ languageFilters ) > 1 ) { $ languageFilters = array ( new LogicalOr ( $ languageFilters ) ) ; } if ( $ this -> hasMainLanguagesEndpoint ) { $ languageFilters [ ] = new LogicalNot ( new CustomField ( self :: FIELD_IS_MAIN_LANGUAGES_INDEX , Operator :: EQ , true ) ) ; } if ( count ( $ languageFilters ) > 1 ) { return new LogicalAnd ( $ languageFilters ) ; } return reset ( $ languageFilters ) ; }
11881	public function run ( ) { if ( false === $ this -> boot ( ) ) { exit ( 1 ) ; } $ this -> runner -> run ( $ this -> request , $ this -> response ) ; return $ this ; }
8208	public function getPheanstalk ( ) { if ( ! $ this -> pheanstalk ) { $ this -> pheanstalk = new Pheanstalk ( $ this -> host , $ this -> port ) ; } return $ this -> pheanstalk ; }
12860	public function getDispatcher ( ) : Dispatcher { if ( $ this -> forceReload || ! file_exists ( $ this -> cacheFile ) ) { $ dispatchData = $ this -> buildCache ( ) ; } else { $ dispatchData = require $ this -> cacheFile ; } return call_user_func ( $ this -> dispatcherFactory , $ dispatchData ) ; }
9707	private function writeDefinedNameBiff8 ( $ name , $ formulaData , $ sheetIndex = 0 , $ isBuiltIn = false ) { $ record = 0x0018 ; $ options = $ isBuiltIn ? 0x20 : 0x00 ; $ nlen = StringHelper :: countCharacters ( $ name ) ; $ name = substr ( StringHelper :: UTF8toBIFF8UnicodeLong ( $ name ) , 2 ) ; $ sz = strlen ( $ formulaData ) ; $ data = pack ( 'vCCvvvCCCC' , $ options , 0 , $ nlen , $ sz , 0 , $ sheetIndex , 0 , 0 , 0 , 0 ) . $ name . $ formulaData ; $ length = strlen ( $ data ) ; $ header = pack ( 'vv' , $ record , $ length ) ; return $ header . $ data ; }
3674	private function extractPostData ( FilterUrl $ filterUrl , $ options , Request $ request ) : void { if ( empty ( $ options [ 'postAsSlug' ] ) && empty ( $ options [ 'postAsGet' ] ) ) { return ; } foreach ( $ request -> request -> all ( ) as $ name => $ value ) { if ( is_array ( $ value ) ) { $ value = implode ( ',' , $ value ) ; } if ( in_array ( $ name , $ options [ 'postAsSlug' ] ) ) { $ filterUrl -> setSlug ( $ name , $ value ) ; } if ( in_array ( $ name , $ options [ 'postAsGet' ] ) ) { $ filterUrl -> setGet ( $ name , $ value ) ; } } }
1457	protected function next ( Cursor $ cursor , $ columns ) { if ( $ cursor -> isAfter ( ) ) { $ this -> whereId ( $ cursor -> getAfter ( ) , $ this -> descending ? '<' : '>' ) ; } $ items = $ this -> orderForNext ( ) -> get ( $ cursor -> getLimit ( ) + 1 , $ columns ) ; $ more = $ items -> count ( ) > $ cursor -> getLimit ( ) ; return new CursorPaginator ( $ items -> slice ( 0 , $ cursor -> getLimit ( ) ) , $ more , $ cursor , $ this -> key ) ; }
2499	private function getAlwaysAvailableFilter ( array $ languageCodes ) { $ conditions = array ( new CustomField ( self :: FIELD_IS_ALWAYS_AVAILABLE , Operator :: EQ , true ) , new LogicalNot ( new CustomField ( self :: FIELD_LANGUAGES , Operator :: IN , $ languageCodes ) ) , ) ; if ( $ this -> hasMainLanguagesEndpoint ) { $ conditions [ ] = new CustomField ( self :: FIELD_IS_MAIN_LANGUAGES_INDEX , Operator :: EQ , true ) ; } return new LogicalAnd ( $ conditions ) ; }
4914	private function addTraversable ( \ Traversable $ result ) { foreach ( $ result as $ item ) { break ; } if ( ! $ item instanceof EntityInterface ) { throw new \ InvalidArgumentException ( 'Traversable objects must be a non-empty collection of Entity instances.' ) ; } $ name = get_class ( $ item ) ; return $ this -> addArray ( [ 'name' => $ name , 'entities' => $ result , ] ) ; }
504	protected function renderHtmlResponse ( ) { return $ this -> controller -> render ( $ this -> view ? : $ this -> id , $ this -> getViewRenderParams ( ) ) ; }
9715	private function writeNumberFormat ( $ format , $ ifmt ) { $ record = 0x041E ; $ numberFormatString = StringHelper :: UTF8toBIFF8UnicodeLong ( $ format ) ; $ length = 2 + strlen ( $ numberFormatString ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ ifmt ) . $ numberFormatString ; $ this -> append ( $ header . $ data ) ; }
10131	private function writeObjectProtect ( ) { if ( ! $ this -> phpSheet -> getProtection ( ) -> getSheet ( ) ) { return ; } if ( ! $ this -> phpSheet -> getProtection ( ) -> getObjects ( ) ) { return ; } $ record = 0x0063 ; $ length = 0x0002 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , 1 ) ; $ this -> append ( $ header . $ data ) ; }
677	public function getLinks ( $ absolute = false ) { $ currentPage = $ this -> getPage ( ) ; $ pageCount = $ this -> getPageCount ( ) ; $ links = [ Link :: REL_SELF => $ this -> createUrl ( $ currentPage , null , $ absolute ) , ] ; if ( $ currentPage > 0 ) { $ links [ self :: LINK_FIRST ] = $ this -> createUrl ( 0 , null , $ absolute ) ; $ links [ self :: LINK_PREV ] = $ this -> createUrl ( $ currentPage - 1 , null , $ absolute ) ; } if ( $ currentPage < $ pageCount - 1 ) { $ links [ self :: LINK_NEXT ] = $ this -> createUrl ( $ currentPage + 1 , null , $ absolute ) ; $ links [ self :: LINK_LAST ] = $ this -> createUrl ( $ pageCount - 1 , null , $ absolute ) ; } return $ links ; }
9289	public function getDuration ( ) { $ executed = $ this -> getExecuted ( ) ; $ finished = $ this -> getFinished ( ) ; if ( is_null ( $ executed ) || is_null ( $ finished ) ) { return 0 ; } return strtotime ( $ finished ) - strtotime ( $ executed ) ; }
8961	public static function fromMinkResponse ( \ Behat \ Mink \ Session $ session ) { return self :: newInstance ( ) -> makeMinkResponseCSVTableParser ( ) -> parse ( $ session ) ; }
10281	public static function absoluteCoordinate ( $ pCoordinateString ) { if ( self :: coordinateIsRange ( $ pCoordinateString ) ) { throw new Exception ( 'Cell coordinate string can not be a range of cells' ) ; } $ worksheet = '' ; $ cellAddress = explode ( '!' , $ pCoordinateString ) ; if ( count ( $ cellAddress ) > 1 ) { list ( $ worksheet , $ pCoordinateString ) = $ cellAddress ; } if ( $ worksheet > '' ) { $ worksheet .= '!' ; } list ( $ column , $ row ) = self :: coordinateFromString ( $ pCoordinateString ) ; $ column = ltrim ( $ column , '$' ) ; $ row = ltrim ( $ row , '$' ) ; return $ worksheet . '$' . $ column . '$' . $ row ; }
2756	public function configDelete ( ConfigCrudEvent $ event ) { $ config = $ event -> getConfig ( ) ; if ( $ config -> getName ( ) === 'views.view.thunder_media' && ( $ media_view = View :: load ( 'media' ) ) ) { $ media_view -> setStatus ( TRUE ) -> save ( ) ; } }
2001	private function getFiles ( FileUpload $ uploader ) : array { $ files = $ uploader -> uploadTo ( 'system/tmp' ) ; if ( \ count ( $ files ) < 1 ) { throw new \ RuntimeException ( $ this -> translator -> trans ( 'ERR.all_fields' , [ ] , 'contao_default' ) ) ; } foreach ( $ files as & $ file ) { $ extension = pathinfo ( $ file , PATHINFO_EXTENSION ) ; if ( 'csv' !== $ extension ) { throw new \ RuntimeException ( sprintf ( $ this -> translator -> trans ( 'ERR.filetype' , [ ] , 'contao_default' ) , $ extension ) ) ; } $ file = $ this -> projectDir . '/' . $ file ; } return $ files ; }
7614	public function actionUpdate ( ) { $ model = $ this -> findModel ( ) ; $ model -> setScenario ( 'profile' ) ; if ( $ model -> load ( $ _POST ) && $ model -> save ( ) ) { return $ this -> redirect ( [ 'view' , 'id' => $ model -> id ] ) ; } else { return $ this -> render ( 'update' , [ 'model' => $ model , ] ) ; } }
8500	protected function setSSLCurlOptions ( $ ch ) { curl_setopt ( $ ch , CURLOPT_SSL_VERIFYPEER , $ this -> _config [ 'SSL_VerifyPeer' ] ) ; curl_setopt ( $ ch , CURLOPT_SSL_VERIFYHOST , $ this -> _config [ 'SSL_VerifyHost' ] ) ; }
2477	public function request ( $ method , Endpoint $ endpoint , $ path , Message $ message = null ) { $ message = $ message ? : new Message ( ) ; $ i = 0 ; do { ++ $ i ; if ( $ responseMessage = $ this -> requestStream ( $ method , $ endpoint , $ path , $ message ) ) { return $ responseMessage ; } usleep ( $ this -> retryWaitMs * 1000 ) ; } while ( $ i < $ this -> connectionRetry ) ; if ( $ this -> logger instanceof LoggerInterface ) { $ this -> logger -> error ( sprintf ( 'Connection to %s failed, attempted %d times' , $ endpoint -> getURL ( ) , $ this -> connectionRetry ) ) ; } throw new ConnectionException ( $ endpoint -> getURL ( ) , $ path , $ method ) ; }
9643	public static function getDriver ( MappingDriver $ originalDriver , $ namespace ) { if ( $ originalDriver instanceof MappingDriverChain ) { $ driver = new Driver \ Chain ( ) ; foreach ( $ originalDriver -> getDrivers ( ) as $ nestedNamespace => $ nestedDriver ) { $ driver -> addDriver ( static :: getDriver ( $ nestedDriver , $ namespace ) , $ nestedNamespace ) ; } if ( $ originalDriver -> getDefaultDriver ( ) !== null ) { $ driver -> setDefaultDriver ( static :: getDriver ( $ originalDriver -> getDefaultDriver ( ) , $ namespace ) ) ; } return $ driver ; } preg_match ( '/(?P<type>Xml|Yaml|Annotation)Driver$/' , get_class ( $ originalDriver ) , $ m ) ; $ type = isset ( $ m [ 'type' ] ) ? $ m [ 'type' ] : null ; $ driverClass = sprintf ( '%s\Mapping\Driver\%s' , $ namespace , $ type ) ; if ( ! $ type || ! class_exists ( $ driverClass ) ) { $ driverClass = sprintf ( '%s\Mapping\Driver\Annotation' , $ namespace ) ; if ( ! class_exists ( $ driverClass ) ) { throw new \ RuntimeException ( sprintf ( 'Failed to fallback to annotation driver: (%s), extension driver was not found.' , $ driverClass ) ) ; } } $ driver = new $ driverClass ( ) ; $ driver -> setOriginalDriver ( $ originalDriver ) ; if ( $ driver instanceof Driver \ File ) { $ driver -> setLocator ( $ originalDriver -> getLocator ( ) ) ; } elseif ( $ driver instanceof AnnotationDriverInterface ) { $ reader = static :: getAnnotationReader ( ) ; $ driver -> setAnnotationReader ( $ reader ) ; } return $ driver ; }
10350	protected function validate ( ) { $ this -> validateArgSet ( $ this -> args ) ; if ( $ this -> success ) { $ this -> validateArgSet ( $ this -> successArgs ) ; } if ( ! $ this -> success ) { $ this -> validateArgSet ( $ this -> failureArgs ) ; } }
3207	private static function chunk ( $ binaryString , $ bits ) { $ binaryString = chunk_split ( $ binaryString , $ bits , ' ' ) ; if ( substr ( $ binaryString , ( strlen ( $ binaryString ) ) - 1 ) == ' ' ) { $ binaryString = substr ( $ binaryString , 0 , strlen ( $ binaryString ) - 1 ) ; } return explode ( ' ' , $ binaryString ) ; }
3763	private function getLegendProperty ( LegendInterface $ legend , $ propertyName ) { if ( $ legend -> hasProperty ( $ propertyName ) ) { $ property = $ legend -> getProperty ( $ propertyName ) ; } else { $ property = new Property ( $ propertyName ) ; $ legend -> addProperty ( $ property ) ; } return $ property ; }
4883	public function generatePublicAlias ( $ subject , $ currentAlias = '' ) { $ alias = $ this -> strategyWrapper -> generatePublicAlias ( $ subject , $ currentAlias ) ; if ( $ alias !== null && method_exists ( $ subject , 'getLanguage' ) ) { if ( in_array ( $ subject -> getLanguage ( ) , $ this -> localesToPrefix ) ) { $ alias = sprintf ( '%s%s%s' , $ this -> basePath , $ subject -> getLanguage ( ) , $ alias ) ; } } return $ alias ; }
6409	public static function concat ( IteratorAggregate $ a , IteratorAggregate $ b ) : IteratorAggregate { return self :: from ( Iterators :: concat ( Iterators :: from ( $ a -> getIterator ( ) ) , Iterators :: from ( $ b -> getIterator ( ) ) ) ) ; }
990	public static function validate ( Schema $ schema , DocumentNode $ ast , ? array $ rules = null , ? TypeInfo $ typeInfo = null ) { if ( $ rules === null ) { $ rules = static :: allRules ( ) ; } if ( is_array ( $ rules ) === true && count ( $ rules ) === 0 ) { return [ ] ; } $ typeInfo = $ typeInfo ? : new TypeInfo ( $ schema ) ; return static :: visitUsingRules ( $ schema , $ typeInfo , $ ast , $ rules ) ; }
12041	public function getFullName ( $ first = NULL , $ middle = NULL , $ last = NULL ) { $ user_first_name = $ this -> getPropertyValue ( "user_first_name" ) ; $ user_middle_name = $ this -> getPropertyValue ( "user_middle_name" ) ; $ user_last_name = $ this -> getPropertyValue ( "user_last_name" ) ; $ user_full_name = implode ( ' ' , array ( empty ( $ user_first_name ) ? $ first : $ user_first_name , empty ( $ user_middle_name ) ? $ middle : $ user_middle_name , empty ( $ user_last_name ) ? $ last : $ user_last_name ) ) ; if ( ! empty ( $ user_full_name ) ) { return $ user_full_name ; } }
3743	protected function setLanguage ( $ language = '' ) { $ previousLanguage = $ GLOBALS [ 'TL_LANGUAGE' ] ; if ( ! empty ( $ language ) && ( $ GLOBALS [ 'TL_LANGUAGE' ] !== $ language ) ) { $ GLOBALS [ 'TL_LANGUAGE' ] = $ language ; } return $ previousLanguage ; }
8033	public function loadView ( $ viewName , $ data = array ( ) , $ mergeData = array ( ) ) { $ this -> htmlContent = View :: make ( $ viewName , $ data , $ mergeData ) ; return $ this ; }
10040	public function load ( $ pFilename ) { $ spreadsheet = new Spreadsheet ( ) ; $ spreadsheet -> removeSheetByIndex ( 0 ) ; return $ this -> loadIntoExisting ( $ pFilename , $ spreadsheet ) ; }
5833	protected function headerToArray ( $ header ) { $ tmp = explode ( "\r\n" , $ header ) ; $ headers = array ( ) ; foreach ( $ tmp as $ singleHeader ) { $ delimiter = strpos ( $ singleHeader , ': ' ) ; if ( $ delimiter !== false ) { $ key = substr ( $ singleHeader , 0 , $ delimiter ) ; $ val = substr ( $ singleHeader , $ delimiter + 2 ) ; $ headers [ $ key ] = $ val ; } else { $ delimiter = strpos ( $ singleHeader , ' ' ) ; if ( $ delimiter !== false ) { $ key = substr ( $ singleHeader , 0 , $ delimiter ) ; $ val = substr ( $ singleHeader , $ delimiter + 1 ) ; $ headers [ $ key ] = $ val ; } } } return $ headers ; }
7610	public function signup ( ) { if ( $ this -> validate ( ) ) { $ user = new User ( ) ; $ user -> username = $ this -> username ; $ user -> email = $ this -> email ; $ user -> setPassword ( $ this -> password ) ; $ user -> generateAuthKey ( ) ; if ( $ user -> save ( ) ) { return $ user ; } } return null ; }
11726	public function render ( $ filter = null ) : string { if ( empty ( $ this -> output ) ) { extract ( array_merge ( $ this -> vars , View :: $ global_vars ) , EXTR_REFS ) ; ob_start ( ) ; include ( $ this -> view_file ) ; $ this -> output = ob_get_clean ( ) ; } if ( $ filter !== null ) { $ this -> output = call_user_func ( $ filter , $ this -> output ) ; } return $ this -> output ; }
11302	public function loadAll ( ) { $ this -> data -> id = $ this -> id ; foreach ( $ this -> model_attributes as $ key => $ value ) { $ temp = $ this -> $ key ; } }
7724	public function setQuickReplies ( $ quickReplie ) { $ model = new QuickReplie ( ) ; $ type = ! empty ( $ quickReplie [ 'type' ] ) ? $ quickReplie [ 'type' ] : 'text' ; $ model -> setContentType ( $ type ) ; if ( ! empty ( $ quickReplie [ 'title' ] ) ) { $ model -> setPayload ( $ quickReplie [ 'payload' ] ) ; } if ( ! empty ( $ quickReplie [ 'title' ] ) ) { $ model -> setTitle ( $ quickReplie [ 'title' ] ) ; } if ( ! empty ( $ quickReplie [ 'image' ] ) ) { $ model -> setImageUrl ( $ quickReplie [ 'image' ] ) ; } $ this -> quickReplies [ ] = $ model ; }
8558	public function setFinancialEventGroupList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'FinancialEventGroupList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
5256	public function setParent ( ElasticsearchModel $ parent ) { $ this -> _parent = $ parent ; $ this -> setParentId ( $ parent -> getId ( ) ) ; }
967	protected function cleanShop ( ) { $ this -> shop -> shopify_token = null ; $ this -> shop -> plan_id = null ; $ this -> shop -> save ( ) ; }
10050	public function resolve ( ) { if ( is_null ( $ this -> config -> getDisplayField ( ) ) || $ this -> config -> getDisplayField ( ) == '' ) { $ this -> config -> setDisplayField ( $ this -> resolveDisplayField ( ) ) ; $ this -> config -> setVisibleFields ( $ this -> resolveVisibleFields ( ) ) ; } return $ this -> config ; }
8638	public function setOrderFeeAdjustmentList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'OrderFeeAdjustmentList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
356	public function init ( ) { parent :: init ( ) ; if ( $ this -> enableCoreCommands ) { foreach ( $ this -> coreCommands ( ) as $ id => $ command ) { if ( ! isset ( $ this -> controllerMap [ $ id ] ) ) { $ this -> controllerMap [ $ id ] = $ command ; } } } if ( ! isset ( $ this -> controllerMap [ 'help' ] ) ) { $ this -> controllerMap [ 'help' ] = 'yii\console\controllers\HelpController' ; } }
12861	private function buildCache ( ) : array { $ dispatchData = $ this -> routeCollector -> getData ( ) ; file_put_contents ( $ this -> cacheFile , '<?php return ' . var_export ( $ dispatchData , true ) . ';' ) ; return $ dispatchData ; }
3524	private function fetch ( $ account_id ) { if ( ! $ account_id ) return null ; $ data = FortniteClient :: sendFortniteGetRequest ( FortniteClient :: FORTNITE_API . 'stats/accountId/' . $ account_id . '/bulk/window/alltime' , $ this -> access_token ) ; $ this -> display_name = Account :: getDisplayNameFromID ( str_replace ( "-" , "" , $ this -> account_id ) , $ this -> access_token ) ; $ compiledStats = [ ] ; foreach ( $ data as $ stat ) { $ parsed = $ this -> parseStatItem ( $ stat ) ; $ compiledStats = array_merge_recursive ( $ compiledStats , $ parsed ) ; } $ platforms = [ ] ; foreach ( $ compiledStats as $ key => $ platform ) { $ platforms [ $ key ] = new Platform ( $ platform ) ; } return $ platforms ; }
1785	private function isRequestPrivate ( Request $ request ) : bool { if ( $ request -> headers -> has ( 'Authorization' ) ) { return true ; } if ( \ count ( $ request -> cookies -> all ( ) ) ) { return true ; } return false ; }
7723	public function objectToArray ( $ object , $ array = [ ] ) { $ reflectionClass = new \ ReflectionClass ( get_class ( $ object ) ) ; foreach ( $ reflectionClass -> getProperties ( ) as $ property ) { $ property -> setAccessible ( true ) ; $ name = trim ( strtolower ( preg_replace ( '/[A-Z]([A-Z](?![a-z]))*/' , '_$0' , $ property -> getName ( ) ) ) , '_' ) ; if ( empty ( $ property -> getValue ( $ object ) ) ) { continue ; } else if ( is_object ( $ property -> getValue ( $ object ) ) ) { $ array [ $ name ] = $ this -> objectToArray ( $ property -> getValue ( $ object ) ) ; } else if ( is_array ( $ property -> getValue ( $ object ) ) ) { foreach ( $ property -> getValue ( $ object ) as $ key => $ value ) { if ( is_object ( $ value ) ) { $ array [ $ name ] [ ] = $ this -> objectToArray ( $ value ) ; } } } else { $ array [ $ name ] = $ property -> getValue ( $ object ) ; } $ property -> setAccessible ( false ) ; } return $ array ; }
8248	public function checkPasswordPolicy ( Password $ password ) { $ result = true ; $ policy = $ this -> picoAuth -> getContainer ( ) -> get ( "PasswordPolicy" ) ; $ maxAllowedLen = $ this -> getPasswordEncoder ( ) -> getMaxAllowedLen ( ) ; if ( is_int ( $ maxAllowedLen ) && strlen ( $ password ) > $ maxAllowedLen ) { $ this -> session -> addFlash ( "error" , "Maximum length is {$maxAllowedLen}." ) ; $ result = false ; } if ( ! $ policy -> check ( $ password ) ) { $ errors = $ policy -> getErrors ( ) ; foreach ( $ errors as $ error ) { $ this -> session -> addFlash ( "error" , $ error ) ; } return false ; } return $ result ; }
269	public function formatMessage ( $ message ) { list ( $ text , $ level , $ category , $ timestamp ) = $ message ; $ level = Logger :: getLevelName ( $ level ) ; if ( ! is_string ( $ text ) ) { if ( $ text instanceof \ Throwable || $ text instanceof \ Exception ) { $ text = ( string ) $ text ; } else { $ text = VarDumper :: export ( $ text ) ; } } $ traces = [ ] ; if ( isset ( $ message [ 4 ] ) ) { foreach ( $ message [ 4 ] as $ trace ) { $ traces [ ] = "in {$trace['file']}:{$trace['line']}" ; } } $ prefix = $ this -> getMessagePrefix ( $ message ) ; return $ this -> getTime ( $ timestamp ) . " {$prefix}[$level][$category] $text" . ( empty ( $ traces ) ? '' : "\n " . implode ( "\n " , $ traces ) ) ; }
1143	protected function bootstrapViews ( ) { $ viewPath = realpath ( __DIR__ . '/../resources/views' ) ; $ this -> loadViewsFrom ( $ viewPath , 'jsvalidation' ) ; $ this -> publishes ( [ $ viewPath => $ this -> app [ 'path.base' ] . '/resources/views/vendor/jsvalidation' , ] , 'views' ) ; }
7899	protected function isProviderAliasExists ( $ provider ) { return array_key_exists ( $ provider , $ this -> providers ) || array_key_exists ( $ provider , $ this -> customProviders ) ; }
2117	public function getExcludedFields ( ) { $ processed = array ( ) ; $ files = Contao \ System :: getContainer ( ) -> get ( 'contao.resource_finder' ) -> findIn ( 'dca' ) -> depth ( 0 ) -> files ( ) -> name ( '*.php' ) ; foreach ( $ files as $ file ) { if ( \ in_array ( $ file -> getBasename ( ) , $ processed ) ) { continue ; } $ processed [ ] = $ file -> getBasename ( ) ; $ strTable = $ file -> getBasename ( '.php' ) ; Contao \ System :: loadLanguageFile ( $ strTable ) ; $ this -> loadDataContainer ( $ strTable ) ; } $ arrReturn = array ( ) ; foreach ( $ GLOBALS [ 'TL_DCA' ] as $ k => $ v ) { if ( \ is_array ( $ v [ 'fields' ] ) ) { foreach ( $ v [ 'fields' ] as $ kk => $ vv ) { if ( $ k == 'tl_user' && $ kk == 'admin' && ! $ this -> User -> isAdmin ) { continue ; } if ( $ vv [ 'exclude' ] || $ vv [ 'orig_exclude' ] ) { $ arrReturn [ $ k ] [ Contao \ StringUtil :: specialchars ( $ k . '::' . $ kk ) ] = isset ( $ vv [ 'label' ] [ 0 ] ) ? $ vv [ 'label' ] [ 0 ] . ' <span style="color:#999;padding-left:3px">[' . $ kk . ']</span>' : $ kk ; } } } } ksort ( $ arrReturn ) ; return $ arrReturn ; }
8994	private function update ( ) { if ( null !== $ this -> namespace ) { $ _SESSION [ $ this -> namespace ] = $ this -> sessionData ; } else { $ _SESSION = $ this -> sessionData ; } }
8316	public function startPasswordResetSession ( $ user ) { $ this -> session -> migrate ( true ) ; $ this -> session -> set ( "pwreset" , array ( 'user' => $ user , 'validity' => time ( ) + $ this -> config [ "resetTimeout" ] ) ) ; }
12539	public static function dasherize ( $ str , $ replacement = '_' ) { return preg_replace_callback ( '/([A-Z0-9-\s]+)/' , function ( $ match ) use ( $ replacement ) { return $ replacement . strtolower ( $ match [ 1 ] ) ; } , lcfirst ( $ str ) ) ; }
2012	public static function addNamespace ( $ name ) { @ trigger_error ( 'Using ClassLoader::addNamespace() has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; if ( \ in_array ( $ name , self :: $ namespaces ) ) { return ; } array_unshift ( self :: $ namespaces , $ name ) ; }
4426	protected function askForData ( $ optionIdentifier , $ optionName , $ defaultValue , $ validator = null ) { $ optionValue = $ this -> input -> getOption ( $ optionIdentifier ) ; $ optionValue = ! empty ( $ optionValue ) ? $ optionValue : $ defaultValue ; $ question = $ this -> getQuestion ( $ optionName , $ optionValue , $ validator ) ; $ optionValue = $ this -> questionHelper -> ask ( $ this -> input , $ this -> output , $ question ) ; $ this -> input -> setOption ( $ optionIdentifier , $ optionValue ) ; return $ optionValue ; }
3502	private function initializeCurlResource ( ) : void { if ( ! $ this -> resource ) { $ this -> resource = curl_init ( ) ; curl_setopt ( $ this -> resource , CURLOPT_RETURNTRANSFER , 1 ) ; curl_setopt ( $ this -> resource , CURLOPT_POST , 1 ) ; curl_setopt ( $ this -> resource , CURLOPT_HTTP_VERSION , 3 ) ; } }
4920	public function setForm ( $ key , $ spec , $ enabled = true ) { if ( is_object ( $ spec ) ) { if ( ! $ spec instanceof Container ) { throw new \ InvalidArgumentException ( 'Tab container must be of the type \Core\Form\Container' ) ; } if ( ! $ spec -> getLabel ( ) ) { throw new \ InvalidArgumentException ( 'Container instances must have a label.' ) ; } } if ( is_array ( $ spec ) ) { if ( ! isset ( $ spec [ 'type' ] ) ) { $ spec [ 'type' ] = 'Core/Container' ; } if ( ! isset ( $ spec [ 'options' ] [ 'forms' ] ) && isset ( $ spec [ 'forms' ] ) ) { $ spec [ 'options' ] [ 'forms' ] = $ spec [ 'forms' ] ; unset ( $ spec [ 'forms' ] ) ; } } return parent :: setForm ( $ key , $ spec , $ enabled ) ; }
693	public function compose ( $ view = null , array $ params = [ ] ) { $ message = $ this -> createMessage ( ) ; if ( $ view === null ) { return $ message ; } if ( ! array_key_exists ( 'message' , $ params ) ) { $ params [ 'message' ] = $ message ; } $ this -> _message = $ message ; if ( is_array ( $ view ) ) { if ( isset ( $ view [ 'html' ] ) ) { $ html = $ this -> render ( $ view [ 'html' ] , $ params , $ this -> htmlLayout ) ; } if ( isset ( $ view [ 'text' ] ) ) { $ text = $ this -> render ( $ view [ 'text' ] , $ params , $ this -> textLayout ) ; } } else { $ html = $ this -> render ( $ view , $ params , $ this -> htmlLayout ) ; } $ this -> _message = null ; if ( isset ( $ html ) ) { $ message -> setHtmlBody ( $ html ) ; } if ( isset ( $ text ) ) { $ message -> setTextBody ( $ text ) ; } elseif ( isset ( $ html ) ) { if ( preg_match ( '~<body[^>]*>(.*?)</body>~is' , $ html , $ match ) ) { $ html = $ match [ 1 ] ; } $ html = preg_replace ( '~<((style|script))[^>]*>(.*?)</\1>~is' , '' , $ html ) ; $ text = html_entity_decode ( strip_tags ( $ html ) , ENT_QUOTES | ENT_HTML5 , Yii :: $ app ? Yii :: $ app -> charset : 'UTF-8' ) ; $ text = preg_replace ( "~^[ \t]+~m" , '' , trim ( $ text ) ) ; $ text = preg_replace ( '~\R\R+~mu' , "\n\n" , $ text ) ; $ message -> setTextBody ( $ text ) ; } return $ message ; }
9792	public function setDataType ( $ pDataType ) { if ( $ pDataType == DataType :: TYPE_STRING2 ) { $ pDataType = DataType :: TYPE_STRING ; } $ this -> dataType = $ pDataType ; return $ this -> updateInCollection ( ) ; }
7869	protected function drawCore ( ) { $ this -> drawBorderTop ( true ) ; $ this -> drawBordered ( $ this -> geometry -> getSpacedCore ( ) ) ; $ this -> drawBorderBottom ( true ) ; }
11551	public function saveConsignment ( ConsignmentInterface $ consignment ) { $ adapter = $ this -> getAdapter ( $ consignment ) ; $ event = new EventConsignment ( $ consignment ) ; $ this -> eventDispatcher -> dispatch ( Events :: PRE_CONSIGNMENT_SAVE , $ event ) ; if ( ! $ consignment -> getStatus ( ) ) { $ consignment -> setStatus ( ConsignmentStatusList :: STATUS_NEW ) ; } try { $ adapter -> saveConsignment ( $ consignment ) ; $ this -> consignmentRepository -> saveConsignment ( $ consignment ) ; } catch ( \ Exception $ e ) { throw new VendorAdapterException ( 'Error during consignment saving.' , null , $ e ) ; } $ event = new EventConsignment ( $ consignment ) ; $ this -> eventDispatcher -> dispatch ( Events :: POST_CONSIGNMENT_SAVE , $ event ) ; }
730	public function run ( ) { if ( $ this -> checkAccess ) { call_user_func ( $ this -> checkAccess , $ this -> id ) ; } $ model = new $ this -> modelClass ( [ 'scenario' => $ this -> scenario , ] ) ; $ model -> load ( Yii :: $ app -> getRequest ( ) -> getBodyParams ( ) , '' ) ; if ( $ model -> save ( ) ) { $ response = Yii :: $ app -> getResponse ( ) ; $ response -> setStatusCode ( 201 ) ; $ id = implode ( ',' , array_values ( $ model -> getPrimaryKey ( true ) ) ) ; $ response -> getHeaders ( ) -> set ( 'Location' , Url :: toRoute ( [ $ this -> viewAction , 'id' => $ id ] , true ) ) ; } elseif ( ! $ model -> hasErrors ( ) ) { throw new ServerErrorHttpException ( 'Failed to create the object for unknown reason.' ) ; } return $ model ; }
4650	private function parseEnvironmentLine ( $ environmentLine ) { $ variables = array ( ) ; @ $ variableLines = explode ( ' ' , $ environmentLine ? : '' ) ; foreach ( $ variableLines as $ variableLine ) { if ( ! empty ( $ variableLine ) ) { list ( $ key , $ value ) = $ this -> parseEnvironementVariable ( $ variableLine ) ; $ variables [ $ key ] = $ value ; } } return $ variables ; }
5625	public function getEncodedRequest ( ) { if ( $ this -> raw ) { $ encoded = $ this -> raw ; } else { $ encoded = $ this -> request -> asUrlRequest ( ) ; } if ( $ encoded ) { return '?' . preg_replace ( '/^\?/' , '' , $ encoded ) ; } return '' ; }
3250	public function scopeWhereCurrent ( $ query ) { if ( Auth :: guest ( ) ) return $ query ; return $ query -> whereUser ( Auth :: user ( ) -> shopId ) ; }
719	public function time ( $ precision = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_TIME , $ precision ) ; }
8193	public function file ( $ name ) { $ usephp = c :: get ( 'twig.usephp' , true ) ; $ base = str_replace ( '\\' , '/' , $ this -> kirby -> roots ( ) -> templates ( ) . '/' . $ name ) ; $ twig = $ base . '.twig' ; $ php = $ base . '.php' ; if ( $ usephp and ! is_file ( $ twig ) and is_file ( $ php ) ) { return $ php ; } else { return $ twig ; } }
4918	public function setParam ( $ key , $ value ) { if ( $ this -> has ( $ key ) ) { $ this -> get ( $ key ) -> setValue ( $ value ) ; } else { $ this -> add ( [ 'type' => 'hidden' , 'name' => $ key , 'attributes' => [ 'value' => $ value ] ] ) ; } return $ this ; }
10579	private function codesEqual ( string $ known , string $ given ) : bool { if ( strlen ( $ given ) !== strlen ( $ known ) ) { return false ; } $ res = 0 ; $ knownLen = strlen ( $ known ) ; for ( $ i = 0 ; $ i < $ knownLen ; ++ $ i ) { $ res |= ( ord ( $ known [ $ i ] ) ^ ord ( $ given [ $ i ] ) ) ; } return $ res === 0 ; }
10002	public function apply ( Tag $ tag , Renderer $ renderer ) { foreach ( $ this -> stack as $ item ) { $ result = $ item [ 'decorator' ] ( $ tag , $ renderer ) ; if ( $ result instanceof Tag ) { $ tag = $ result ; } else { trigger_error ( sprintf ( '%s does not return an instance of Sirius\\Html\\Tag' , get_class ( $ item [ 'decorator' ] ) ) , E_USER_WARNING ) ; } } return $ tag ; }
8507	public function getPackageLabels ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_GetPackageLabelsRequest ) ) { $ request = new FBAInboundServiceMWS_Model_GetPackageLabelsRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetPackageLabels' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_GetPackageLabelsResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
758	protected function renderImageByImagick ( $ code ) { $ backColor = $ this -> transparent ? new \ ImagickPixel ( 'transparent' ) : new \ ImagickPixel ( '#' . str_pad ( dechex ( $ this -> backColor ) , 6 , 0 , STR_PAD_LEFT ) ) ; $ foreColor = new \ ImagickPixel ( '#' . str_pad ( dechex ( $ this -> foreColor ) , 6 , 0 , STR_PAD_LEFT ) ) ; $ image = new \ Imagick ( ) ; $ image -> newImage ( $ this -> width , $ this -> height , $ backColor ) ; $ draw = new \ ImagickDraw ( ) ; $ draw -> setFont ( $ this -> fontFile ) ; $ draw -> setFontSize ( 30 ) ; $ fontMetrics = $ image -> queryFontMetrics ( $ draw , $ code ) ; $ length = strlen ( $ code ) ; $ w = ( int ) $ fontMetrics [ 'textWidth' ] - 8 + $ this -> offset * ( $ length - 1 ) ; $ h = ( int ) $ fontMetrics [ 'textHeight' ] - 8 ; $ scale = min ( ( $ this -> width - $ this -> padding * 2 ) / $ w , ( $ this -> height - $ this -> padding * 2 ) / $ h ) ; $ x = 10 ; $ y = round ( $ this -> height * 27 / 40 ) ; for ( $ i = 0 ; $ i < $ length ; ++ $ i ) { $ draw = new \ ImagickDraw ( ) ; $ draw -> setFont ( $ this -> fontFile ) ; $ draw -> setFontSize ( ( int ) ( mt_rand ( 26 , 32 ) * $ scale * 0.8 ) ) ; $ draw -> setFillColor ( $ foreColor ) ; $ image -> annotateImage ( $ draw , $ x , $ y , mt_rand ( - 10 , 10 ) , $ code [ $ i ] ) ; $ fontMetrics = $ image -> queryFontMetrics ( $ draw , $ code [ $ i ] ) ; $ x += ( int ) $ fontMetrics [ 'textWidth' ] + $ this -> offset ; } $ image -> setImageFormat ( 'png' ) ; return $ image -> getImageBlob ( ) ; }
9593	public function checkboxListFilled ( $ items , $ options = [ ] ) { $ this -> addListInputCssClass ( $ options , $ this -> checkboxFilledCssClass ) ; return self :: checkboxList ( $ items , $ options ) ; }
4577	public function getXml ( $ id , Parameters $ parameters = null ) { if ( null !== $ id ) { $ resource = str_replace ( '{id}' , $ id , static :: RESOURCE_OBJECT_XML ) ; } else { $ key = $ parameters -> getKey ( ) ; $ tenantId = $ parameters -> getTenantId ( ) ; switch ( true ) { case null !== $ key && null !== $ tenantId : $ resource = str_replace ( [ '{key}' , '{tenant-id}' ] , [ $ key , $ tenantId ] , static :: RESOURCE_OBJECT_XML_BY_KEY_AND_TENANT_ID ) ; break ; case null !== $ key : $ resource = str_replace ( '{key}' , $ key , static :: RESOURCE_OBJECT_XML_BY_KEY ) ; break ; default : throw new LogicException ( '"Key" and/or "TenantId" parameters are not defined.' ) ; } } $ options = [ 'headers' => [ 'Accept' => 'application/json' ] ] ; $ object = $ this -> execute ( 'GET' , $ resource , $ options ) ; $ model = new Xml ; $ model -> setId ( $ object -> id ) -> setXml ( new SimpleXMLElement ( $ object -> bpmn20Xml ) ) ; return $ model ; }
3601	private function collectException ( $ httpRequest , $ httpResponse , $ exception ) { if ( $ this -> profiler ) { $ collector = new ExceptionDataCollector ( ) ; $ collector -> collect ( $ httpRequest , $ httpResponse , $ exception ) ; $ this -> profiler -> add ( $ collector ) ; } }
4181	public function getResources ( ) { return $ this -> resources ? : $ this -> resources = Resource :: instance ( clone $ this -> getFiles ( ) , $ this -> console ) ; }
8942	public function queryChangeset ( $ param ) { $ base = 'changesets/' . $ param ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ xmlString = $ this -> sendRequest ( $ path ) ; return $ xmlString -> osm ; }
4736	public function process ( ContainerBuilder $ container ) { $ serviceId = 'simple_bus.asynchronous.publishes_predefined_messages_middleware' ; if ( ! $ container -> hasDefinition ( $ serviceId ) ) { return ; } $ names = array ( ) ; $ this -> collectServiceIds ( $ container , 'asynchronous_event_subscriber' , 'subscribes_to' , function ( $ key ) use ( & $ names ) { $ names [ ] = $ key ; } ) ; $ container -> getDefinition ( $ serviceId ) -> replaceArgument ( 2 , array_unique ( $ names ) ) ; }
4139	protected function getOauthParameters ( ) { $ time = time ( ) ; return array ( 'oauth_consumer_key' => $ this -> getConsumerKey ( ) , 'oauth_nonce' => trim ( base64_encode ( $ time ) , '=' ) , 'oauth_signature_method' => 'HMAC-SHA1' , 'oauth_timestamp' => $ time , 'oauth_token' => $ this -> getAccessToken ( ) , 'oauth_version' => '1.0' ) ; }
5339	public function setMode ( $ mode ) { if ( ! in_array ( $ mode , $ this -> acceptedModes ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Invalid mode: [%s]' , $ mode ) ) ; } $ this -> mode = $ mode ; }
3468	public function delete ( string $ route , callable $ controller ) : void { $ this -> register ( $ controller , Route :: delete ( $ route ) ) ; }
6037	public function init ( ) { parent :: init ( ) ; if ( $ this -> data ) { $ order = 0 ; if ( is_array ( $ this -> model -> { $ this -> attribute } ) ) { foreach ( $ this -> model -> { $ this -> attribute } as $ value ) { $ order ++ ; if ( is_object ( $ value ) ) { $ this -> options [ 'options' ] [ $ value -> Id ] = [ 'data-order' => $ order ] ; } else { $ this -> options [ 'options' ] [ $ value ] = [ 'data-order' => $ order ] ; } } } } }
11920	public function onPageRemoved ( PageCollectionRemovedEvent $ event ) { $ pageName = basename ( $ event -> getFilePath ( ) ) ; $ page = $ this -> pagesParser -> contributor ( $ event -> getUsername ( ) ) -> parse ( ) -> page ( $ pageName ) ; if ( null === $ page ) { return ; } foreach ( $ page [ "seo" ] as $ seo ) { $ permalink = $ seo [ "permalink" ] ; $ this -> permalinkManager -> remove ( $ permalink ) ; } $ this -> permalinkManager -> save ( ) ; }
8422	public function addNoticeBoardItem ( ProductionMenuCollectionEvent $ event ) : void { $ menu = $ event -> getMenu ( ) ; $ group = $ event -> getGroup ( ) ; $ board = $ this -> factory -> createItem ( 'menu_item.notice_board' , [ 'route' => 'bkstg_board_show' , 'routeParameters' => [ 'production_slug' => $ group -> getSlug ( ) ] , 'extras' => [ 'icon' => 'comment' , 'translation_domain' => BkstgNoticeBoardBundle :: TRANSLATION_DOMAIN , ] , ] ) ; $ menu -> addChild ( $ board ) ; if ( $ this -> auth -> isGranted ( 'GROUP_ROLE_EDITOR' , $ group ) ) { $ posts = $ this -> factory -> createItem ( 'menu_item.notice_board_posts' , [ 'route' => 'bkstg_board_show' , 'routeParameters' => [ 'production_slug' => $ group -> getSlug ( ) ] , 'extras' => [ 'translation_domain' => BkstgNoticeBoardBundle :: TRANSLATION_DOMAIN ] , ] ) ; $ board -> addChild ( $ posts ) ; $ archive = $ this -> factory -> createItem ( 'menu_item.notice_board_archive' , [ 'route' => 'bkstg_board_archive' , 'routeParameters' => [ 'production_slug' => $ group -> getSlug ( ) ] , 'extras' => [ 'translation_domain' => BkstgNoticeBoardBundle :: TRANSLATION_DOMAIN ] , ] ) ; $ board -> addChild ( $ archive ) ; } }
7823	protected function updateWorkflow ( $ workflow ) { $ attachments = $ this -> getNamespacedPipesByOption ( 'attach' ) ; $ detachments = $ this -> getNamespacedPipesByOption ( 'detach' ) ; $ this -> pipelines -> update ( $ workflow , $ attachments , $ detachments ) ; }
9281	public function getPending ( array $ options = array ( ) ) { $ where = new Where ( ) ; $ where -> equalTo ( "{$this->tableName}.status" , JobEntity :: STATUS_PENDING ) ; return $ this -> fetchByWhere ( $ where , $ options ) ; }
6418	public static function isEmpty ( IteratorAggregate $ iterable ) : bool { return Iterators :: isEmpty ( Iterators :: from ( $ iterable -> getIterator ( ) ) ) ; }
1740	public function checkImportantPart ( Contao \ DataContainer $ dc ) { if ( ! $ dc -> id ) { return ; } $ rootDir = Contao \ System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( is_dir ( $ rootDir . '/' . $ dc -> id ) || ! \ in_array ( strtolower ( substr ( $ dc -> id , strrpos ( $ dc -> id , '.' ) + 1 ) ) , Contao \ StringUtil :: trimsplit ( ',' , strtolower ( Contao \ Config :: get ( 'validImageTypes' ) ) ) ) ) { $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'palettes' ] = str_replace ( ',importantPartX,importantPartY,importantPartWidth,importantPartHeight' , '' , $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'palettes' ] ) ; } }
8826	protected function migrationToClassName ( $ migrationName ) { $ class = str_replace ( '_' , ' ' , $ migrationName ) ; $ class = ucwords ( $ class ) ; $ class = str_replace ( ' ' , '' , $ class ) ; if ( ! $ this -> isValidClassName ( $ class ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Migration class "%s" is invalid' , $ class ) ) ; } return $ class ; }
978	protected function validateShop ( Request $ request ) { $ shopParam = ShopifyApp :: sanitizeShopDomain ( $ request -> get ( 'shop' ) ) ; $ shop = ShopifyApp :: shop ( $ shopParam ) ; $ session = new ShopSession ( $ shop ) ; if ( $ shop === null || $ shop -> trashed ( ) || empty ( $ session -> getToken ( true ) ) || ( $ shopParam && $ shopParam !== $ shop -> shopify_domain ) === true ) { $ session -> forget ( ) ; Session :: put ( 'return_to' , $ request -> fullUrl ( ) ) ; return Redirect :: route ( 'authenticate' , [ 'shop' => $ shopParam ] ) ; } return true ; }
7340	public function sendAttachment ( Chat $ chat , User $ recipient , Attachment $ attachment ) : void { $ type = $ attachment -> getType ( ) ; $ request = null ; switch ( $ type ) { case Attachment :: TYPE_FILE : $ request = new SendDocument ( ) ; $ request -> document = new InputFile ( $ attachment -> getPath ( ) ) ; $ request -> caption = $ attachment -> getParameters ( ) -> get ( 'caption' ) ; break ; case Attachment :: TYPE_IMAGE : $ request = new SendPhoto ( ) ; $ request -> caption = $ attachment -> getParameters ( ) -> get ( 'caption' ) ; break ; case Attachment :: TYPE_AUDIO : $ request = new SendAudio ( ) ; $ request -> chat_id = $ chat -> getId ( ) ; $ request -> caption = $ attachment -> getParameters ( ) -> get ( 'caption' ) ; $ request -> duration = $ attachment -> getParameters ( ) -> get ( 'duration' ) ; $ request -> performer = $ attachment -> getParameters ( ) -> get ( 'performer' ) ; $ request -> title = $ attachment -> getParameters ( ) -> get ( 'title' ) ; break ; case Attachment :: TYPE_VIDEO : $ request = new SendVideo ( ) ; $ request -> duration = $ attachment -> getParameters ( ) -> get ( 'duration' ) ; $ request -> width = $ attachment -> getParameters ( ) -> get ( 'width' ) ; $ request -> height = $ attachment -> getParameters ( ) -> get ( 'height' ) ; $ request -> caption = $ attachment -> getParameters ( ) -> get ( 'caption' ) ; break ; } if ( $ request ) { $ request -> chat_id = $ chat -> getId ( ) ; $ request -> disable_notification = $ attachment -> getParameters ( ) -> get ( 'disable_notification' ) ; $ request -> reply_to_message_id = $ attachment -> getParameters ( ) -> get ( 'reply_to_message_id' ) ; $ request -> reply_markup = $ attachment -> getParameters ( ) -> get ( 'reply_markup' ) ; $ this -> client -> performApiRequest ( $ request ) ; $ this -> loop -> run ( ) ; } }
7228	protected function parseHeader ( $ curl , $ header ) { if ( preg_match ( "/^([^:\s]+)\:\s+(.*)$/" , $ header , $ matches ) ) { $ matches [ 2 ] = trim ( $ matches [ 2 ] ) ; $ this -> lastHeader [ $ matches [ 1 ] ] = $ matches [ 2 ] ; $ this -> lastResultType = $ matches [ 1 ] === "Content-Type" ? $ matches [ 2 ] : $ this -> lastResultType ; } return strlen ( $ header ) ; }
2354	public function getResponse ( $ objPage ) { if ( $ objPage -> redirectBack ) { $ _SESSION [ 'LAST_PAGE_VISITED' ] = $ this -> getReferer ( ) ; } $ strLogoutUrl = System :: getContainer ( ) -> get ( 'security.logout_url_generator' ) -> getLogoutUrl ( ) ; $ strRedirect = Environment :: get ( 'base' ) ; if ( $ objPage -> redirectBack && ! empty ( $ _SESSION [ 'LAST_PAGE_VISITED' ] ) ) { $ strRedirect = $ _SESSION [ 'LAST_PAGE_VISITED' ] ; } elseif ( ( $ objTarget = $ objPage -> getRelated ( 'jumpTo' ) ) instanceof PageModel ) { $ strRedirect = $ objTarget -> getAbsoluteUrl ( ) ; } $ uri = Http :: createFromString ( $ strLogoutUrl ) ; $ query = new Query ( $ uri -> getQuery ( ) ) ; $ query = $ query -> merge ( 'redirect=' . $ strRedirect ) ; return new RedirectResponse ( ( string ) $ uri -> withQuery ( ( string ) $ query ) ) ; }
6265	public function resolve ( ResponseInterface $ response ) { if ( HttpPromise :: PENDING !== $ this -> state ) { throw new \ RuntimeException ( 'Promise is already resolved' ) ; } $ this -> state = HttpPromise :: FULFILLED ; $ this -> response = $ response ; $ this -> doResolve ( $ response ) ; }
7638	public function generateSharedAccessUrl ( $ containerName = '' , $ blobName = '' , $ resource = 'b' , $ permissions = 'r' , $ start = '' , $ expiry = '' , $ identifier = '' ) { Assertion :: notEmpty ( $ containerName , 'Container name is not specified' ) ; self :: assertValidContainerName ( $ containerName ) ; $ resourceName = self :: createResourceName ( $ containerName , $ blobName ) ; return $ this -> getBaseUrl ( ) . '/' . $ resourceName . '?' . $ this -> sharedAccessSignatureCredentials -> createSignedQueryString ( $ resourceName , '' , $ resource , $ permissions , $ start , $ expiry , $ identifier ) ; }
764	private function splitStatements ( $ sql , $ params ) { $ semicolonIndex = strpos ( $ sql , ';' ) ; if ( $ semicolonIndex === false || $ semicolonIndex === StringHelper :: byteLength ( $ sql ) - 1 ) { return false ; } $ tokenizer = new SqlTokenizer ( $ sql ) ; $ codeToken = $ tokenizer -> tokenize ( ) ; if ( count ( $ codeToken -> getChildren ( ) ) === 1 ) { return false ; } $ statements = [ ] ; foreach ( $ codeToken -> getChildren ( ) as $ statement ) { $ statements [ ] = [ $ statement -> getSql ( ) , $ this -> extractUsedParams ( $ statement , $ params ) ] ; } return $ statements ; }
7425	public function setSource ( $ source = '' ) { if ( ! $ this -> isValid ( $ source ) ) { throw new InvalidSourceExtensionException ( ) ; } $ this -> source = $ source ; return $ this ; }
7884	public function getShow ( $ date , $ level = null ) { $ logs = LogViewer :: logs ( ) ; if ( ! is_string ( $ level ) ) { $ level = 'all' ; } $ page = Input :: get ( 'page' ) ; if ( empty ( $ page ) ) { $ page = '1' ; } $ data = [ 'logs' => $ logs , 'date' => $ date , 'url' => 'logviewer' , 'data_url' => URL :: route ( 'logviewer.index' ) . '/data/' . $ date . '/' . $ level . '?page=' . $ page , 'levels' => LogViewer :: levels ( ) , 'current' => $ level , ] ; return View :: make ( 'logviewer::show' , $ data ) ; }
2377	public static function convertEncoding ( $ str , $ to , $ from = null ) { if ( $ str == '' ) { return '' ; } if ( ! $ from ) { $ from = mb_detect_encoding ( $ str , 'ASCII,ISO-2022-JP,UTF-8,EUC-JP,ISO-8859-1' ) ; } if ( $ from == $ to ) { return $ str ; } if ( $ from == 'UTF-8' && $ to == 'ISO-8859-1' ) { return utf8_decode ( $ str ) ; } if ( $ from == 'ISO-8859-1' && $ to == 'UTF-8' ) { return utf8_encode ( $ str ) ; } return mb_convert_encoding ( $ str , $ to , $ from ) ; }
1883	public static function find ( array $ arrOptions ) { $ objBase = DcaExtractor :: getInstance ( $ arrOptions [ 'table' ] ) ; if ( ! $ objBase -> hasRelations ( ) ) { $ strQuery = "SELECT * FROM " . $ arrOptions [ 'table' ] ; } else { $ arrJoins = array ( ) ; $ arrFields = array ( $ arrOptions [ 'table' ] . ".*" ) ; $ intCount = 0 ; foreach ( $ objBase -> getRelations ( ) as $ strKey => $ arrConfig ) { if ( $ arrConfig [ 'load' ] == 'eager' || $ arrOptions [ 'eager' ] ) { if ( $ arrConfig [ 'type' ] == 'hasOne' || $ arrConfig [ 'type' ] == 'belongsTo' ) { ++ $ intCount ; $ objRelated = DcaExtractor :: getInstance ( $ arrConfig [ 'table' ] ) ; foreach ( array_keys ( $ objRelated -> getFields ( ) ) as $ strField ) { $ arrFields [ ] = 'j' . $ intCount . '.' . Database :: quoteIdentifier ( $ strField ) . ' AS ' . $ strKey . '__' . $ strField ; } $ arrJoins [ ] = " LEFT JOIN " . $ arrConfig [ 'table' ] . " j$intCount ON " . $ arrOptions [ 'table' ] . "." . Database :: quoteIdentifier ( $ strKey ) . "=j$intCount." . $ arrConfig [ 'field' ] ; } } } $ strQuery = "SELECT " . implode ( ', ' , $ arrFields ) . " FROM " . $ arrOptions [ 'table' ] . implode ( "" , $ arrJoins ) ; } if ( isset ( $ arrOptions [ 'column' ] ) ) { $ strQuery .= " WHERE " . ( \ is_array ( $ arrOptions [ 'column' ] ) ? implode ( " AND " , $ arrOptions [ 'column' ] ) : $ arrOptions [ 'table' ] . '.' . Database :: quoteIdentifier ( $ arrOptions [ 'column' ] ) . "=?" ) ; } if ( isset ( $ arrOptions [ 'group' ] ) ) { $ strQuery .= " GROUP BY " . $ arrOptions [ 'group' ] ; } if ( isset ( $ arrOptions [ 'having' ] ) ) { $ strQuery .= " HAVING " . $ arrOptions [ 'having' ] ; } if ( isset ( $ arrOptions [ 'order' ] ) ) { $ strQuery .= " ORDER BY " . $ arrOptions [ 'order' ] ; } return $ strQuery ; }
6065	public function listSocialMediaFiles ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/media/' . $ id . '/socialmedia/files' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new DeploymentFile ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
10997	public function read ( int $ offset = 0 ) { if ( $ this -> test ( \ sndsgd \ Fs :: EXISTS | \ sndsgd \ Fs :: READABLE ) === false ) { $ this -> error = "failed to read file; {$this->error}" ; return false ; } return $ this -> readFile ( $ offset ) ; }
1095	public function children ( $ node ) { $ query = $ this -> node -> newQuery ( ) ; $ query -> where ( $ this -> node -> getQualifiedParentColumnName ( ) , '=' , $ node -> getKey ( ) ) ; foreach ( $ this -> scopedAttributes ( $ node ) as $ fld => $ value ) $ query -> where ( $ this -> qualify ( $ fld ) , '=' , $ value ) ; $ query -> orderBy ( $ this -> node -> getQualifiedLeftColumnName ( ) ) ; $ query -> orderBy ( $ this -> node -> getQualifiedRightColumnName ( ) ) ; $ query -> orderBy ( $ this -> node -> getQualifiedKeyName ( ) ) ; return $ query -> get ( ) ; }
8672	private function iterateFromIndex ( $ fromIndex ) { Assert :: integer ( $ fromIndex ) ; $ count = count ( $ this -> items ) ; if ( $ count === 0 ) { return ; } $ last = $ count - 2 ; $ index = $ fromIndex < 0 ? max ( $ last + $ fromIndex , - 1 ) : min ( $ fromIndex - 1 , $ last ) ; $ keys = array_keys ( $ this -> items ) ; while ( ++ $ index < $ count ) { $ key = $ keys [ $ index ] ; yield $ key => $ this -> items [ $ key ] ; } }
11081	public static function GUIDv4 ( ) { return sprintf ( '%04x%04x-%04x-%04x-%04x-%04x%04x%04x' , mt_rand ( 0 , 0xffff ) , mt_rand ( 0 , 0xffff ) , mt_rand ( 0 , 0xffff ) , mt_rand ( 0 , 0x0fff ) | 0x4000 , mt_rand ( 0 , 0x3fff ) | 0x8000 , mt_rand ( 0 , 0xffff ) , mt_rand ( 0 , 0xffff ) , mt_rand ( 0 , 0xffff ) ) ; }
10035	function unsubscribeContactByExternalId ( $ externalId , $ mailingId = "" , $ reasons = null ) { $ queryParameters = array ( ) ; if ( ! empty ( $ mailingId ) ) { $ queryParameters [ 'mailingId' ] = $ mailingId ; } if ( ! empty ( $ reasons ) ) { if ( is_array ( $ reasons ) ) { $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , 'reason' , $ reasons ) ; } else { $ queryParameters [ 'reason' ] = urlencode ( $ reasons ) ; } } $ encodedExternalId = utf8_encode ( $ externalId ) ; return $ this -> delete ( "contacts/externalid/${encodedExternalId}/unsubscribe" , $ queryParameters ) ; }
6003	public function addVideoTemplate ( $ item ) { if ( ! ( $ item instanceof VideoTemplate ) ) { if ( is_array ( $ item ) ) { try { $ item = new VideoTemplate ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate VideoTemplate. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "VideoTemplate"!' , E_USER_WARNING ) ; } } $ this -> videotemplates [ ] = $ item ; return $ this ; }
10046	function isEmpty ( ) { $ result = ! isset ( $ this -> id ) && ! isset ( $ this -> external_id ) && ! isset ( $ this -> email ) ; return $ result ; }
12178	public function getIndividual ( ) { if ( ! isset ( $ this -> _individual ) && ! empty ( $ this -> object_individual_id ) ) { $ this -> _individual = false ; $ individualType = Yii :: $ app -> collectors [ 'types' ] -> getOne ( 'Individual' ) ; if ( ! empty ( $ individualType -> object ) ) { $ individualClass = $ individualType -> object -> primaryModel ; $ this -> _individual = $ individualClass :: get ( $ this -> object_individual_id ) ; } } return $ this -> _individual ; }
4538	public function setTenantId ( ? string $ tenantId ) { $ this -> tenantId = $ tenantId ; $ this -> _tenantId = null !== $ tenantId ; return $ this ; }
2668	public function getAuthDictionary ( $ version ) { $ name = Config :: AUTH_DICTIONARY_NAME ; $ dictionary = $ this -> getSingleDictionary ( $ version , $ name ) ; return $ dictionary ; }
12721	public function isShared ( $ abstract ) { if ( ! isset ( $ this -> bindings [ $ abstract ] ) ) { throw Internal \ Exception \ ReflectionExceptionFactory :: invalidArgument ( sprintf ( "Parameter 1 of %s must be valid keys in binding container stack." , __METHOD__ ) ) ; } return ( $ this -> bindings [ $ abstract ] [ 'shared' ] ? true : false ) ; }
10657	public function getArrayCopyRec ( ) { $ ret = array ( ) ; $ it = $ this -> getIterator ( ) ; while ( $ it -> valid ( ) ) { if ( $ it -> current ( ) instanceof self ) { $ ret [ $ it -> key ( ) ] = $ it -> current ( ) -> getArrayCopyRec ( ) ; } else { $ ret [ $ it -> key ( ) ] = $ it -> current ( ) ; } $ it -> next ( ) ; } return $ ret ; }
6400	public static function init ( ) : void { self :: $ classMap = new CallbackLazyMap ( function ( $ className ) { $ trimmedClassName = trim ( $ className , '\\' ) ; return $ trimmedClassName === $ className ? new ObjectClass ( $ className ) : ObjectClass :: $ classMap -> $ trimmedClassName ; } ) ; }
10469	public function post ( Request $ request ) { $ this -> emit ( 'message.send' , array ( $ request -> xml ( ) ) ) ; $ response = $ this -> connector -> post ( $ request ) ; $ this -> emit ( 'message.recv' , array ( $ response ) ) ; try { return $ this -> parseXml ( $ response ) ; } catch ( InvalidXMLException $ e ) { throw new InvalidNcipResponseException ( 'Invalid response received from the NCIP service "' . $ this -> connector -> url . '": ' . $ response ) ; } }
9886	private function writeDefinedNameForAutofilter ( XMLWriter $ objWriter , Worksheet $ pSheet , $ pSheetId = 0 ) { $ autoFilterRange = $ pSheet -> getAutoFilter ( ) -> getRange ( ) ; if ( ! empty ( $ autoFilterRange ) ) { $ objWriter -> startElement ( 'definedName' ) ; $ objWriter -> writeAttribute ( 'name' , '_xlnm._FilterDatabase' ) ; $ objWriter -> writeAttribute ( 'localSheetId' , $ pSheetId ) ; $ objWriter -> writeAttribute ( 'hidden' , '1' ) ; $ range = Coordinate :: splitRange ( $ autoFilterRange ) ; $ range = $ range [ 0 ] ; if ( strpos ( $ range [ 0 ] , '!' ) !== false ) { list ( $ ws , $ range [ 0 ] ) = explode ( '!' , $ range [ 0 ] ) ; } $ range [ 0 ] = Coordinate :: absoluteCoordinate ( $ range [ 0 ] ) ; $ range [ 1 ] = Coordinate :: absoluteCoordinate ( $ range [ 1 ] ) ; $ range = implode ( ':' , $ range ) ; $ objWriter -> writeRawData ( '\'' . str_replace ( "'" , "''" , $ pSheet -> getTitle ( ) ) . '\'!' . $ range ) ; $ objWriter -> endElement ( ) ; } }
10552	public function resolveApp ( ) { $ this -> determineVirtualHost ( ) ; $ path = $ this -> vhost -> getPath ( $ this -> request -> url ) ; $ resolved = $ this -> resolver -> resolve ( "app" , $ path ) ; if ( $ resolved !== null ) { if ( $ resolved [ 'ext' ] ) { $ mime = new FileType ( $ resolved [ 'ext' ] , "" ) ; if ( ! empty ( $ mime ) ) { $ str = $ mime -> getMimeType ( ) . ";q=1.5," . ( string ) $ this -> request -> accept ; $ this -> request -> setAccept ( new Accept ( $ str ) ) ; } $ this -> suffix = $ resolved [ 'ext' ] ; } $ this -> route = $ resolved [ 'route' ] ; $ this -> app = $ resolved [ 'path' ] ; $ this -> arguments = new Dictionary ( $ resolved [ 'remainder' ] ) ; } else { $ this -> route = null ; $ this -> app = null ; $ this -> arguments = new Dictionary ( ) ; } }
8478	public function log ( $ level , $ message , array $ context = [ ] ) { if ( $ this -> config ( 'requiredScope' ) && ( empty ( $ context [ 'scope' ] ) ) ) return false ; $ scopes = ( empty ( $ context [ 'scope' ] ) ) ? [ null ] : $ context [ 'scope' ] ; unset ( $ context [ 'scope' ] ) ; $ this -> _context = $ context ; $ Table = TableRegistry :: get ( $ this -> config ( 'model' ) , [ 'table' => $ this -> config ( 'table' ) ] ) ; foreach ( $ scopes as $ scope ) { $ entity = $ Table -> newEntity ( ) ; $ data = [ 'level' => $ level , 'user_id' => $ this -> _userId ( ) , 'scope' => $ scope , 'message' => $ message , 'context' => $ this -> _context , ] ; $ entity = $ Table -> patchEntity ( $ entity , $ data ) ; $ Table -> save ( $ entity ) ; } return true ; }
1091	public function aggregate ( $ function , $ columns = array ( '*' ) ) { if ( ! isset ( $ this -> groups ) ) $ this -> reOrderBy ( null ) ; return parent :: aggregate ( $ function , $ columns ) ; }
1550	protected function getRelation ( $ record , $ key ) { $ relation = $ record -> { $ key } ( ) ; if ( ! $ relation || ! $ this -> acceptRelation ( $ relation ) ) { throw new RuntimeException ( sprintf ( 'JSON API relation %s cannot be used for an Eloquent %s relation.' , class_basename ( $ this ) , class_basename ( $ relation ) ) ) ; } return $ relation ; }
3313	protected function appendAppIdAndBucketIfEmpty ( array $ options = [ ] ) { $ options [ 'appid' ] = empty ( $ options [ 'appid' ] ) ? $ this -> authorization -> getAppId ( ) : $ options [ 'appid' ] ; $ options [ 'bucket' ] = empty ( $ options [ 'bucket' ] ) ? $ this -> authorization -> getBucket ( ) : $ options [ 'bucket' ] ; return $ options ; }
10061	public function create ( $ key , $ value ) { $ exists = $ this -> metaModel :: where ( 'key' , $ key ) -> exists ( ) ; if ( $ exists ) { $ message = "Can't create meta (key: $key). " ; $ message .= "Meta already exists" ; throw new \ Exception ( $ message ) ; } $ meta = new $ this -> metaModel ; $ meta -> key = $ key ; $ meta -> value = $ value ; $ meta -> save ( ) ; }
5465	public function addRealm ( $ url , $ type , $ realm ) { $ this -> realms [ $ url -> getHost ( ) ] [ $ realm ] = new SimpleRealm ( $ type , $ url ) ; }
2952	protected function prepareTemplate ( $ templateTxt ) { $ patterns = [ '/\\\{%(.*)%\\\}/U' , '/\s+/' , ] ; $ replacements = [ '(?<$1>.*)' , ' ' , ] ; $ templateTxt = preg_replace ( $ patterns , $ replacements , preg_quote ( $ templateTxt , '/' ) ) ; return trim ( $ templateTxt ) ; }
8938	public function updateChangeset ( $ id , $ tags = array ( ) ) { $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = 'changeset/' . $ id ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ tagList = '' ; if ( ! empty ( $ tags ) ) { foreach ( $ tags as $ key => $ value ) { $ tagList .= '<tag k="' . $ key . '" v="' . $ value . '"/>' ; } } $ xml = '<?xml version="1.0" encoding="UTF-8"?> <osm version="0.6" generator="JoomlaOpenStreetMap"> <changeset>' . $ tagList . '</changeset> </osm>' ; $ header [ 'Content-Type' ] = 'text/xml' ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'PUT' , $ parameters , $ xml , $ header ) ; $ xmlString = simplexml_load_string ( $ response -> body ) ; return $ xmlString -> changeset ; }
6430	public function completeLogin ( $ extrainputs = array ( ) ) { $ facebook = $ this -> getFacebookObject ( ) ; $ old_GET = $ _GET ; $ _GET = $ extrainputs ; $ helper = $ facebook -> getRedirectLoginHelper ( ) ; $ accessToken = $ helper -> getAccessToken ( ) ; $ _GET = $ old_GET ; if ( ! isset ( $ accessToken ) ) { if ( $ helper -> getError ( ) ) { throw new \ Exception ( $ helper -> getError ( ) . ' ' . $ helper -> getErrorCode ( ) . ' ' . $ helper -> getErrorReason ( ) . ' ' . $ helper -> getErrorDescription ( ) ) ; } else { throw new \ Exception ( 'Unknown error from Facebook' ) ; } } $ this -> accesstoken = $ accessToken ; return $ this -> getUserProfile ( ) ; }
3989	public function getScreen ( $ tableName ) { $ inputScreens = $ this -> getInputScreens ( ) ; if ( isset ( $ inputScreens [ $ tableName ] ) ) { return $ inputScreens [ $ tableName ] ; } return null ; }
7328	private function configureVatNumberSubjectMapping ( LoadClassMetadataEventArgs $ eventArgs ) { $ metadata = $ eventArgs -> getClassMetadata ( ) ; $ class = $ metadata -> getName ( ) ; if ( ! is_subclass_of ( $ class , Pricing \ Model \ VatNumberSubjectInterface :: class ) ) { return ; } if ( in_array ( $ class , $ this -> vatNumberSubjectClassCache ) ) { return ; } $ this -> addMappings ( $ metadata , $ this -> getVatNumberSubjectMappings ( ) ) ; $ this -> vatNumberSubjectClassCache [ ] = $ class ; }
6380	public function readAttempt ( $ id ) { $ model = $ this -> readObject ( $ id , 'quiz_attempts' ) ; $ model -> url = $ this -> cfg -> wwwroot . '/mod/quiz/attempt.php?attempt=' . $ id ; $ model -> name = 'Attempt ' . $ id ; return $ model ; }
5024	private function findLeaf ( NodeInterface $ leaf , $ value ) { $ parts = is_array ( $ value ) ? $ value : explode ( $ this -> shouldUseNames ( ) ? ' | ' : '-' , $ value ) ; $ value = array_shift ( $ parts ) ; foreach ( $ leaf -> getChildren ( ) as $ item ) { $ compare = $ this -> shouldUseNames ( ) ? $ item -> getName ( ) : $ item -> getValue ( ) ; if ( $ compare == $ value ) { if ( count ( $ parts ) ) { return $ this -> findLeaf ( $ item , $ parts ) ; } return $ item ; } } if ( $ value && $ this -> shouldCreateLeafs ( ) ) { $ nodeClass = get_class ( $ leaf ) ; $ node = new $ nodeClass ( $ value ) ; $ leaf -> addChild ( $ node ) ; if ( count ( $ parts ) ) { return $ this -> findLeaf ( $ node , $ parts ) ; } return $ node ; } return null ; }
1513	public function create ( StoreInterface $ store , CreateResource $ request ) { $ record = $ this -> transaction ( function ( ) use ( $ store , $ request ) { return $ this -> doCreate ( $ store , $ request ) ; } ) ; if ( $ this -> isResponse ( $ record ) ) { return $ record ; } return $ this -> reply ( ) -> created ( $ record ) ; }
12425	public function getAuthorizerToken ( $ appId , $ refreshToken ) { $ params = [ 'component_appid' => $ this -> getAppId ( ) , 'authorizer_appid' => $ appId , 'authorizer_refresh_token' => $ refreshToken , ] ; return $ this -> parseJSON ( 'json' , [ self :: GET_AUTHORIZER_TOKEN , $ params ] ) ; }
1791	private function prepareDomain ( RequestContext $ context , array & $ parameters , int & $ referenceType ) : void { if ( isset ( $ parameters [ '_ssl' ] ) ) { $ context -> setScheme ( true === $ parameters [ '_ssl' ] ? 'https' : 'http' ) ; } if ( isset ( $ parameters [ '_domain' ] ) && '' !== $ parameters [ '_domain' ] ) { $ this -> addHostToContext ( $ context , $ parameters , $ referenceType ) ; } unset ( $ parameters [ '_domain' ] , $ parameters [ '_ssl' ] ) ; }
1983	public static function hasMessages ( $ strScope = TL_MODE ) { return static :: hasError ( $ strScope ) || static :: hasConfirmation ( $ strScope ) || static :: hasNew ( $ strScope ) || static :: hasInfo ( $ strScope ) || static :: hasRaw ( $ strScope ) ; }
2138	public function onKernelRequest ( GetResponseEvent $ event ) : void { $ request = $ event -> getRequest ( ) ; if ( \ in_array ( $ request -> getClientIp ( ) , [ '127.0.0.1' , 'fe80::1' , '::1' ] , true ) ) { return ; } if ( '' === $ request -> getBasePath ( ) ) { return ; } throw new InsecureInstallationException ( 'Your installation is not secure. Please set the document root to the /web subfolder.' ) ; }
7029	public function getMessagesForQuantity ( float $ quantity ) { $ messages = [ ] ; if ( $ quantity < $ this -> minimumQuantity ) { $ messages [ ] = $ this -> minimumMessage ; } elseif ( 0 < $ this -> maximumQuantity && $ quantity > $ this -> maximumQuantity ) { $ messages [ ] = $ this -> maximumMessage ; } else { if ( null !== $ this -> availableMessage ) { $ messages [ ] = $ this -> availableMessage ; } if ( $ quantity > $ this -> availableQuantity ) { if ( null !== $ this -> resupplyMessage ) { $ messages [ ] = $ this -> resupplyMessage ; if ( $ quantity > $ this -> availableQuantity + $ this -> resupplyQuantity ) { $ messages [ ] = $ this -> overflowMessage ; } } else { $ messages [ ] = $ this -> overflowMessage ; } } } if ( empty ( $ messages ) ) { $ messages [ ] = $ this -> overflowMessage ; } return $ messages ; }
10111	private function writeSheetProtection ( ) { $ record = 0x0867 ; $ options = ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getObjects ( ) | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getScenarios ( ) << 1 | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getFormatCells ( ) << 2 | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getFormatColumns ( ) << 3 | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getFormatRows ( ) << 4 | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getInsertColumns ( ) << 5 | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getInsertRows ( ) << 6 | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getInsertHyperlinks ( ) << 7 | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getDeleteColumns ( ) << 8 | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getDeleteRows ( ) << 9 | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getSelectLockedCells ( ) << 10 | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getSort ( ) << 11 | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getAutoFilter ( ) << 12 | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getPivotTables ( ) << 13 | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getSelectUnlockedCells ( ) << 14 ; $ recordData = pack ( 'vVVCVVvv' , 0x0867 , 0x0000 , 0x0000 , 0x00 , 0x01000200 , 0xFFFFFFFF , $ options , 0x0000 ) ; $ length = strlen ( $ recordData ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ this -> append ( $ header . $ recordData ) ; }
8040	public function buildEventDates ( array $ data ) { $ dates = [ ] ; $ eventLength = $ this -> calculateEventLength ( $ data ) ; $ allDay = array_key_exists ( 'all_day' , $ data ) ; foreach ( $ data [ 'repeat_dates' ] as $ date ) { if ( strlen ( $ date ) > 0 ) { $ date = strtotime ( $ date . ' ' . $ data [ 'start' ] [ 'time' ] ) ; if ( false === $ date ) { throw new InvalidDateStringException ( 'Invalid date string!' ) ; } $ eventStart = $ this -> carbon -> copy ( ) -> setTimestamp ( $ date ) ; $ eventEnds = $ allDay ? null : $ eventStart -> copy ( ) -> addSeconds ( $ eventLength ) ; $ dates [ ] = [ 'start' => $ eventStart -> toDateTimeString ( ) , 'end' => ( null !== $ eventEnds ) ? $ eventEnds -> toDateTimeString ( ) : null , ] ; } } return $ dates ; }
2572	protected function loadSessionHandler ( $ params ) { if ( isset ( $ params [ 'sessionHandler' ] ) && $ params [ 'sessionHandler' ] instanceof Session \ Handler \ HandlerInterface ) { $ this -> sessionHandler = $ params [ 'sessionHandler' ] ; } }
11354	private function generateProxy ( $ className ) { if ( isset ( $ this -> checkedClasses [ $ className ] ) ) { return $ this -> checkedClasses [ $ className ] ; } $ proxyParameters = array ( 'className' => $ className , 'factory' => get_class ( $ this ) , 'proxyManagerVersion' => Version :: VERSION ) ; $ proxyClassName = $ this -> configuration -> getClassNameInflector ( ) -> getProxyClassName ( $ className , $ proxyParameters ) ; $ this -> generateProxyClass ( $ proxyClassName , $ className , $ proxyParameters ) ; $ this -> configuration -> getSignatureChecker ( ) -> checkSignature ( new ReflectionClass ( $ proxyClassName ) , $ proxyParameters ) ; return $ this -> checkedClasses [ $ className ] = $ proxyClassName ; }
4071	public function getJavascripts ( GetOptionsEvent $ event ) { if ( ( $ event -> getEnvironment ( ) -> getDataDefinition ( ) -> getName ( ) !== 'tl_metamodel_rendersettings' ) || ( $ event -> getPropertyName ( ) !== 'additionalJs' ) || ( $ event -> getSubPropertyName ( ) !== 'file' ) ) { return ; } $ event -> setOptions ( $ this -> scanFiles ( 'js' ) ) ; }
1292	private function buildResult ( array $ data ) : Result { $ token = $ this -> getTokenFromResponse ( $ data ) ; $ done = isset ( $ data [ 'nextSyncUrl' ] ) ; $ items = \ array_map ( function ( array $ item ) : ResourceInterface { return $ this -> builder -> build ( $ item ) ; } , $ data [ 'items' ] ) ; return new Result ( $ items , $ token , $ done ) ; }
6661	protected function getControllerMethod ( $ methodName ) { $ reflectionMethod = $ this -> reflectedController -> getMethod ( $ methodName ) ; $ reflectionMethod -> setAccessible ( true ) ; return function ( ) use ( $ reflectionMethod ) { return $ reflectionMethod -> invokeArgs ( $ this -> controller , func_get_args ( ) ) ; } ; }
1284	private function resolveLinksForResourceType ( string $ type , array $ links , string $ locale = null ) : array { $ resourceIds = \ array_map ( function ( Link $ link ) : string { return $ link -> getId ( ) ; } , \ array_filter ( $ links , function ( Link $ link ) use ( $ type ) : bool { return $ link -> getLinkType ( ) === $ type ; } ) ) ; $ resources = [ ] ; $ collection = $ this -> fetchResourcesForGivenIds ( $ resourceIds , $ type , $ locale ) ; foreach ( $ collection as $ resource ) { $ resources [ $ type . '.' . $ resource -> getId ( ) ] = $ resource ; } return $ resources ; }
5310	protected function getPathFromEllipse ( SimpleXMLElement $ ellipse ) { $ mult = 0.55228475 ; return 'M' . ( $ ellipse [ 'cx' ] - $ ellipse [ 'rx' ] ) . ' ' . $ ellipse [ 'cy' ] . 'C' . ( $ ellipse [ 'cx' ] - $ ellipse [ 'rx' ] ) . ' ' . ( $ ellipse [ 'cy' ] - $ ellipse [ 'ry' ] * $ mult ) . ' ' . ( $ ellipse [ 'cx' ] - $ ellipse [ 'rx' ] * $ mult ) . ' ' . ( $ ellipse [ 'cy' ] - $ ellipse [ 'ry' ] ) . ' ' . $ ellipse [ 'cx' ] . ' ' . ( $ ellipse [ 'cy' ] - $ ellipse [ 'ry' ] ) . 'C' . ( $ ellipse [ 'cx' ] + $ ellipse [ 'rx' ] * $ mult ) . ' ' . ( $ ellipse [ 'cy' ] - $ ellipse [ 'ry' ] ) . ' ' . ( $ ellipse [ 'cx' ] + $ ellipse [ 'rx' ] ) . ' ' . ( $ ellipse [ 'cy' ] - $ ellipse [ 'ry' ] * $ mult ) . ' ' . ( $ ellipse [ 'cx' ] + $ ellipse [ 'rx' ] ) . ' ' . $ ellipse [ 'cy' ] . 'C' . ( $ ellipse [ 'cx' ] + $ ellipse [ 'rx' ] ) . ' ' . ( $ ellipse [ 'cy' ] + $ ellipse [ 'ry' ] * $ mult ) . ' ' . ( $ ellipse [ 'cx' ] + $ ellipse [ 'rx' ] * $ mult ) . ' ' . ( $ ellipse [ 'cy' ] + $ ellipse [ 'ry' ] ) . ' ' . $ ellipse [ 'cx' ] . ' ' . ( $ ellipse [ 'cy' ] + $ ellipse [ 'ry' ] ) . 'C' . ( $ ellipse [ 'cx' ] - $ ellipse [ 'rx' ] * $ mult ) . ' ' . ( $ ellipse [ 'cy' ] + $ ellipse [ 'ry' ] ) . ' ' . ( $ ellipse [ 'cx' ] - $ ellipse [ 'rx' ] ) . ' ' . ( $ ellipse [ 'cy' ] + $ ellipse [ 'ry' ] * $ mult ) . ' ' . ( $ ellipse [ 'cx' ] - $ ellipse [ 'rx' ] ) . ' ' . $ ellipse [ 'cy' ] . 'Z' ; }
2134	public static function remove ( $ strKey ) { $ objConfig = static :: getInstance ( ) ; if ( strncmp ( $ strKey , '$GLOBALS' , 8 ) !== 0 ) { $ strKey = "\$GLOBALS['TL_CONFIG']['$strKey']" ; } $ objConfig -> delete ( $ strKey ) ; }
2412	protected function addTableTlTheme ( \ DOMDocument $ xml , \ DOMNode $ tables , Result $ objTheme ) { $ table = $ xml -> createElement ( 'table' ) ; $ table -> setAttribute ( 'name' , 'tl_theme' ) ; $ table = $ tables -> appendChild ( $ table ) ; $ this -> loadDataContainer ( 'tl_theme' ) ; $ objDcaExtractor = DcaExtractor :: getInstance ( 'tl_theme' ) ; $ arrOrder = $ objDcaExtractor -> getOrderFields ( ) ; $ this -> addDataRow ( $ xml , $ table , $ objTheme -> row ( ) , $ arrOrder ) ; }
4904	protected function createValueOptions ( NodeInterface $ node , $ allowSelectNodes = false , $ isRoot = true ) { $ key = $ isRoot ? $ node -> getValue ( ) : $ node -> getValueWithParents ( ) ; $ name = $ node -> getName ( ) ; if ( $ node -> hasChildren ( ) ) { $ leafOptions = [ ] ; if ( $ allowSelectNodes && ! $ isRoot ) { $ leafOptions [ $ key ] = $ name ; $ key = "$key-group" ; } foreach ( $ node -> getChildren ( ) as $ child ) { $ leafOptions += $ this -> createValueOptions ( $ child , $ allowSelectNodes , false ) ; } $ value = [ 'label' => $ name , 'options' => $ leafOptions ] ; } else { $ value = $ name ; } return [ $ key => $ value ] ; }
8815	public function get ( $ key = null , $ filter = false ) { if ( is_null ( $ key ) ) { return $ _GET ; } $ value = ( isset ( $ _GET [ $ key ] ) ? $ _GET [ $ key ] : null ) ; return $ this -> filter ( $ value , $ filter ) ; }
10914	public function execute ( ) { try { $ this -> output_buffer_level = ob_get_level ( ) ; ob_start ( ) ; $ response = $ this -> doExecute ( ) ; if ( ( is_object ( $ response ) && ! ( $ response instanceof Response ) ) || ( is_string ( $ response ) && class_exists ( $ response ) ) ) { $ response = $ this -> reflect ( $ response ) ; } if ( $ response instanceof Response ) throw $ response ; throw new HTTPError ( 500 , "App did not produce any response" ) ; } catch ( Response $ response ) { self :: $ logger -> debug ( "Response type {0} returned from controller: {1}" , [ get_class ( $ response ) , $ this -> app ] ) ; throw $ response ; } catch ( Throwable $ e ) { self :: $ logger -> debug ( "While executing controller: {0}" , [ $ this -> app ] ) ; self :: $ logger -> notice ( "Unexpected exception of type {0} thrown while processing request: {1}" , [ get_class ( $ e ) , $ e ] ) ; throw $ e ; } finally { $ this -> logScriptOutput ( ) ; } }
5393	public function paintFail ( $ message ) { parent :: paintFail ( $ message ) ; print $ this -> getIndent ( 1 ) ; print '<' . $ this -> namespace . 'fail>' ; print $ this -> toParsedXml ( $ message ) ; print '</' . $ this -> namespace . "fail>\n" ; }
9844	public function createSignedJsonResponse ( int $ status , array $ arrayToJsonify , SigningSecretKey $ key , array $ headers = [ ] , string $ version = '1.1' ) : ResponseInterface { if ( empty ( $ headers [ 'Content-Type' ] ) ) { $ headers [ 'Content-Type' ] = 'application/json' ; } $ body = \ json_encode ( $ arrayToJsonify , JSON_PRETTY_PRINT ) ; if ( ! \ is_string ( $ body ) ) { throw new InvalidMessageException ( 'Cannot JSON-encode this message.' ) ; } return $ this -> createSignedResponse ( $ status , $ body , $ key , $ headers , $ version ) ; }
8643	public function cancelReportRequests ( $ request ) { if ( ! $ request instanceof MarketplaceWebService_Model_CancelReportRequestsRequest ) { $ request = new MarketplaceWebService_Model_CancelReportRequestsRequest ( $ request ) ; } $ httpResponse = $ this -> invoke ( $ this -> convertCancelReportRequests ( $ request ) ) ; $ response = MarketplaceWebService_Model_CancelReportRequestsResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
2236	public function generate ( $ blnNoMarkup = false ) { if ( TL_MODE == 'FE' && ! BE_USER_LOGGED_IN && ( ! $ this -> published || ( $ this -> start != '' && $ this -> start > time ( ) ) || ( $ this -> stop != '' && $ this -> stop < time ( ) ) ) ) { return '' ; } $ this -> type = 'article' ; $ this -> blnNoMarkup = $ blnNoMarkup ; if ( System :: getContainer ( ) -> has ( 'fos_http_cache.http.symfony_response_tagger' ) ) { $ responseTagger = System :: getContainer ( ) -> get ( 'fos_http_cache.http.symfony_response_tagger' ) ; $ responseTagger -> addTags ( array ( 'contao.db.tl_article.' . $ this -> id ) ) ; } return parent :: generate ( ) ; }
10504	private function registerLogLevels ( ) { $ this -> app -> singleton ( Contracts \ Utilities \ LogLevels :: class , function ( $ app ) { $ translator = $ app [ 'translator' ] ; return new Utilities \ LogLevels ( $ translator , 'en' ) ; } ) ; $ this -> app -> singleton ( 'arcanedev.log-viewer.levels' , Contracts \ Utilities \ LogLevels :: class ) ; }
5257	public static function search ( $ query = [ ] ) { if ( $ query instanceof QueryBuilder ) { $ query = $ query -> build ( ) ; } $ model = static :: createInstance ( ) ; return $ model -> _dal -> search ( $ query ) ; }
1339	public function add ( ResourceIdentifierInterface $ identifier , $ record ) { if ( ! is_object ( $ record ) && ! is_bool ( $ record ) ) { throw new InvalidArgumentException ( 'Expecting an object or a boolean to add to the identity map.' ) ; } $ existing = $ this -> lookup ( $ identifier ) ; if ( is_object ( $ existing ) && is_bool ( $ record ) ) { throw new InvalidArgumentException ( 'Attempting to push a boolean into the map in place of an object.' ) ; } $ this -> map [ $ identifier -> toString ( ) ] = $ record ; return $ this ; }
152	public function batch ( $ batchSize = 100 , $ db = null ) { return Yii :: createObject ( [ 'class' => BatchQueryResult :: className ( ) , 'query' => $ this , 'batchSize' => $ batchSize , 'db' => $ db , 'each' => false , ] ) ; }
2259	protected function createInitialVersion ( $ strTable , $ intId ) { @ trigger_error ( 'Using Controller::createInitialVersion() has been deprecated and will no longer work in Contao 5.0. Use Versions->initialize() instead.' , E_USER_DEPRECATED ) ; $ objVersions = new Versions ( $ strTable , $ intId ) ; $ objVersions -> initialize ( ) ; }
8739	private function updateBase ( array $ values , array $ ids ) { $ query = $ this -> model -> newQuery ( ) -> whereIn ( $ this -> model -> getKeyName ( ) , $ ids ) -> getQuery ( ) ; return $ query -> update ( $ values ) ; }
5661	private function attributes ( $ node ) { if ( ! preg_match ( '|<[^ ]+\s(.*?)/?>|s' , $ node -> value , $ first_tag_contents ) ) { return array ( ) ; } $ attributes = array ( ) ; preg_match_all ( '/\S+\s*=\s*\'[^\']*\'|(\S+\s*=\s*"[^"]*")|([^ =]+\s*=\s*[^ "\']+?)|[^ "\']+/' , $ first_tag_contents [ 1 ] , $ matches ) ; foreach ( $ matches [ 0 ] as $ unparsed ) { $ attributes = $ this -> mergeAttribute ( $ attributes , $ unparsed ) ; } return $ attributes ; }
6477	public function readAsMultipart ( ? IHttpBody $ body , string $ boundary ) : ? MultipartBody { if ( $ body === null ) { return null ; } $ rawBodyParts = explode ( "--$boundary" , $ body -> readAsString ( ) ) ; array_shift ( $ rawBodyParts ) ; array_pop ( $ rawBodyParts ) ; $ parsedBodyParts = [ ] ; foreach ( $ rawBodyParts as $ rawBodyPart ) { $ headerStartIndex = strlen ( "\r\n" ) ; $ headerEndIndex = strpos ( $ rawBodyPart , "\r\n\r\n" ) ; $ bodyStartIndex = $ headerEndIndex + strlen ( "\r\n\r\n" ) ; $ bodyEndIndex = strlen ( $ rawBodyPart ) - strlen ( "\r\n" ) ; $ rawHeaders = explode ( "\r\n" , substr ( $ rawBodyPart , $ headerStartIndex , $ headerEndIndex - $ headerStartIndex ) ) ; $ parsedHeaders = new HttpHeaders ( ) ; foreach ( $ rawHeaders as $ headerLine ) { [ $ headerName , $ headerValue ] = explode ( ':' , $ headerLine , 2 ) ; $ parsedHeaders -> add ( trim ( $ headerName ) , trim ( $ headerValue ) ) ; } $ body = new StringBody ( substr ( $ rawBodyPart , $ bodyStartIndex , $ bodyEndIndex - $ bodyStartIndex ) ) ; $ parsedBodyParts [ ] = new MultipartBodyPart ( $ parsedHeaders , $ body ) ; } return new MultipartBody ( $ parsedBodyParts , $ boundary ) ; }
9494	private function formatSize ( $ bytes ) { $ kb = 1024 ; $ mb = $ kb * 1024 ; $ gb = $ mb * 1024 ; $ tb = $ gb * 1024 ; if ( ( $ bytes >= 0 ) && ( $ bytes < $ kb ) ) { return $ bytes . ' B' ; } elseif ( ( $ bytes >= $ kb ) && ( $ bytes < $ mb ) ) { return ceil ( $ bytes / $ kb ) . ' KB' ; } elseif ( ( $ bytes >= $ mb ) && ( $ bytes < $ gb ) ) { return ceil ( $ bytes / $ mb ) . ' MB' ; } elseif ( ( $ bytes >= $ gb ) && ( $ bytes < $ tb ) ) { return ceil ( $ bytes / $ gb ) . ' GB' ; } elseif ( $ bytes >= $ tb ) { return ceil ( $ bytes / $ tb ) . ' TB' ; } return $ bytes . ' B' ; }
4155	protected function buildRequestHeader ( ) { $ bearerToken = $ this -> bearerToken ; if ( $ this -> bearerToken === null ) { $ bearerToken = $ this -> getBearerToken ( ) ; } return array ( 'Authorization: Bearer ' . rawurlencode ( $ bearerToken ) , 'Expect:' ) ; }
12348	protected function getConnectionInitializer ( OptionsInterface $ options , $ callable ) { if ( ! is_callable ( $ callable ) ) { $ class = get_called_class ( ) ; throw new \ InvalidArgumentException ( "$class expects a valid callable" ) ; } $ option = $ this ; return function ( $ parameters = null ) use ( $ callable , $ options , $ option ) { $ connection = call_user_func ( $ callable , $ options , $ parameters ) ; if ( ! $ connection instanceof AggregateConnectionInterface ) { $ class = get_class ( $ option ) ; throw new \ InvalidArgumentException ( "$class expects a valid connection type returned by callable initializer" ) ; } return $ connection ; } ; }
4906	public function indexAction ( ) { $ view = $ this -> params ( 'view' ) ; $ view = 'content/' . $ view ; $ viewModel = new ViewModel ( ) ; $ viewModel -> setTemplate ( $ view ) ; $ request = $ this -> getRequest ( ) ; if ( $ request -> isXmlHttpRequest ( ) ) { $ viewModel -> setTerminal ( true ) ; } return $ viewModel ; }
7186	public function getCombination ( $ quantity , $ reset = false ) { if ( null !== $ this -> combination && ! $ reset ) { return $ this -> combination ; } $ this -> combination = null ; if ( ! empty ( $ combinations = $ this -> buildCombinations ( $ quantity ) ) ) { usort ( $ combinations , function ( AssignmentCombination $ a , AssignmentCombination $ b ) use ( $ quantity ) { if ( $ a -> diff == $ b -> diff ) { if ( $ a -> size == $ b -> size ) { return 0 ; } return $ a -> size < $ b -> size ? - 1 : 1 ; } if ( 0 <= $ a -> diff ) { return intval ( 0 > $ b -> diff ? - 1 : $ a -> diff - $ b -> diff ) ; } return intval ( 0 < $ b -> diff ? 1 : $ b -> diff - $ a -> diff ) ; } ) ; $ this -> combination = reset ( $ combinations ) ; } return $ this -> combination ; }
3694	public function getBreadcrumb ( GetBreadcrumbEvent $ event ) { $ environment = $ event -> getEnvironment ( ) ; if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ elements = $ this -> storeFactory -> createStore ( ) ; $ this -> getBreadcrumbElements ( $ environment , $ elements ) ; $ event -> setElements ( $ elements -> getElements ( ) ) ; $ event -> stopPropagation ( ) ; }
9352	public function cofactor ( ) { $ c = new self ( $ this -> size -> rows , $ this -> size -> cols ) ; for ( $ m = 0 ; $ m < $ this -> size -> rows ; $ m ++ ) { $ arr_row = array ( ) ; for ( $ n = 0 ; $ n < $ this -> size -> cols ; $ n ++ ) { if ( $ this -> size -> cols == 2 ) { $ arr_row [ ] = pow ( - 1 , $ m + $ n ) * $ this -> subMatrix ( $ m , $ n ) -> get ( 0 , 0 ) ; } else { $ arr_row [ ] = pow ( - 1 , $ m + $ n ) * $ this -> subMatrix ( $ m , $ n ) -> det ( ) ; } } $ c -> addRow ( $ arr_row ) ; } return $ c ; }
1104	protected function quoteIdentifier ( $ value ) { if ( is_null ( $ value ) ) return 'NULL' ; $ connection = $ this -> node -> getConnection ( ) ; $ pdo = $ connection -> getPdo ( ) ; return $ pdo -> quote ( $ value ) ; }
390	public function loadDefaultValues ( $ skipIfSet = true ) { foreach ( static :: getTableSchema ( ) -> columns as $ column ) { if ( $ column -> defaultValue !== null && ( ! $ skipIfSet || $ this -> { $ column -> name } === null ) ) { $ this -> { $ column -> name } = $ column -> defaultValue ; } } return $ this ; }
2579	protected function loadCustomerRefs ( $ dkNumber ) { if ( ! is_null ( $ dkNumber ) ) { $ this -> customerRef = new MasterPricer \ CustomerRef ( ) ; $ this -> customerRef -> customerReferences [ ] = new MasterPricer \ CustomerReferences ( $ dkNumber , MasterPricer \ CustomerReferences :: QUAL_AGENCY_GROUPING_ID ) ; } }
5118	public function deleteAttachment ( string $ idArticle , string $ field , string $ order ) : string { return $ this -> delete ( $ this -> getAttachmentEndPoint ( $ idArticle , $ field ) . "/${order}" ) ; }
1107	protected function writeModel ( $ name ) { $ output = pathinfo ( $ this -> modeler -> create ( $ name , $ this -> getModelsPath ( ) ) , PATHINFO_FILENAME ) ; $ this -> line ( " <fg=green;options=bold>create</fg=green;options=bold> $output" ) ; }
12174	public function addScalarArgument ( $ name , $ type , $ required = true , $ default = null ) { return $ this -> addArgument ( new ScalarArgument ( $ this -> argumentPosition ++ , $ name , $ type , $ required , $ default ) ) ; }
4216	private function clearErrors ( $ flags ) { $ clearErrors = $ flags & Debug :: CLEAR_LOG_ERRORS || $ flags & Debug :: CLEAR_SUMMARY_ERRORS ; if ( ! $ clearErrors ) { return ; } $ errorsNotCleared = array ( ) ; $ errorsNotCleared = $ this -> clearErrorsHelper ( $ this -> data [ 'log' ] , $ flags & Debug :: CLEAR_LOG_ERRORS ) ; foreach ( \ array_keys ( $ this -> data [ 'logSummary' ] ) as $ priority ) { $ errorsNotCleared = \ array_merge ( $ this -> clearErrorsHelper ( $ this -> data [ 'logSummary' ] [ $ priority ] , $ flags & Debug :: CLEAR_SUMMARY_ERRORS ) ) ; } $ errorsNotCleared = \ array_unique ( $ errorsNotCleared ) ; $ errors = $ this -> debug -> errorHandler -> get ( 'errors' ) ; foreach ( $ errors as $ error ) { if ( ! \ in_array ( $ error [ 'hash' ] , $ errorsNotCleared ) ) { $ error [ 'inConsole' ] = false ; } } }
650	public function dropCommentFromTable ( $ table ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> dropCommentFromTable ( $ table ) ; return $ this -> setSql ( $ sql ) ; }
8131	protected function removeNodeFilter ( Twig_Node $ node ) { if ( $ node instanceof Twig_Node_Expression_Filter ) { return $ this -> removeNodeFilter ( $ node -> getNode ( 'node' ) ) ; } return $ node ; }
9708	private function writeShortNameBiff8 ( $ name , $ sheetIndex , $ rangeBounds , $ isHidden = false ) { $ record = 0x0018 ; $ options = ( $ isHidden ? 0x21 : 0x00 ) ; $ extra = pack ( 'Cvvvvv' , 0x3B , $ sheetIndex - 1 , $ rangeBounds [ 0 ] [ 1 ] - 1 , $ rangeBounds [ 1 ] [ 1 ] - 1 , $ rangeBounds [ 0 ] [ 0 ] - 1 , $ rangeBounds [ 1 ] [ 0 ] - 1 ) ; $ sz = strlen ( $ extra ) ; $ data = pack ( 'vCCvvvCCCCC' , $ options , 0 , 1 , $ sz , 0 , $ sheetIndex , 0 , 0 , 0 , 0 , 0 ) . $ name . $ extra ; $ length = strlen ( $ data ) ; $ header = pack ( 'vv' , $ record , $ length ) ; return $ header . $ data ; }
10089	function addAttachmentFromBase64Data ( $ filename , $ mimetype , $ contents ) { $ attachment = new Attachment ( $ filename , $ mimetype , $ contents ) ; $ this -> attachments [ ] = $ attachment ; }
3563	protected function getMutator ( $ value , $ dir = 'setter' , $ type = null ) { $ type = $ type ? : $ this -> getValueType ( $ value ) ; foreach ( $ this -> { "{$dir}Mutators" } as $ mutated => $ mutator ) { if ( $ type == $ mutated || $ value instanceof $ mutated ) { return $ mutator ; } } }
10931	function countRowsWith ( string $ tablename , string $ colName , $ colValue ) : int { $ strSQL = "SELECT COUNT($colName) as count FROM $tablename WHERE $colName=:$colName;" ; return $ this -> getCountOf ( $ strSQL , [ "$colName" => $ colValue ] ) ; }
4257	protected function getErrorsInCategory ( $ category ) { $ errors = $ this -> errorHandler -> get ( 'errors' ) ; $ errorsInCat = array ( ) ; foreach ( $ errors as $ err ) { if ( $ err [ 'category' ] == $ category && $ err [ 'inConsole' ] ) { $ errorsInCat [ ] = $ err ; } } return $ errorsInCat ; }
11681	public function read ( $ id ) { $ path = $ this -> getPath ( $ id ) ; if ( ! file_exists ( $ path ) ) { return '' ; } if ( filemtime ( $ path ) < time ( ) - $ this -> lifeTime ) { return '' ; } return file_get_contents ( $ path ) ; }
11281	public function getFloat ( $ min , $ max ) { if ( $ min > $ max ) { throw new InvalidArgumentException ( 'Min cannot be greater than max' ) ; } $ random01 = \ mt_rand ( ) / \ mt_getrandmax ( ) ; return ( $ max - $ min ) * $ random01 + $ min ; }
10709	public function getManyPaginated ( $ perPage = null , $ columns = [ '*' ] ) { $ query = $ this -> getQuery ( ) ; $ results = $ query -> paginate ( $ perPage , $ columns ) ; return $ this -> returnResults ( $ results ) ; }
1109	protected function groupRootsByScope ( $ roots ) { $ rootsGroupedByScope = array ( ) ; foreach ( $ roots as $ root ) { $ key = $ this -> keyForScope ( $ root ) ; if ( ! isset ( $ rootsGroupedByScope [ $ key ] ) ) $ rootsGroupedByScope [ $ key ] = array ( ) ; $ rootsGroupedByScope [ $ key ] [ ] = $ root ; } return $ rootsGroupedByScope ; }
2724	public function execute ( \ Magento \ Framework \ Event \ Observer $ observer ) { if ( $ this -> config -> getType ( ) == Config :: FASTLY && $ this -> config -> isEnabled ( ) ) { $ object = $ observer -> getEvent ( ) -> getObject ( ) ; if ( $ object instanceof \ Magento \ Framework \ DataObject \ IdentityInterface && $ this -> canPurgeObject ( $ object ) ) { $ tags = [ ] ; foreach ( $ object -> getIdentities ( ) as $ tag ) { $ tag = $ this -> cacheTags -> convertCacheTags ( $ tag ) ; if ( ! in_array ( $ tag , $ this -> alreadyPurged ) ) { $ tags [ ] = $ tag ; $ this -> alreadyPurged [ ] = $ tag ; } } if ( ! empty ( $ tags ) ) { $ this -> purgeCache -> sendPurgeRequest ( array_unique ( $ tags ) ) ; } } } }
3045	protected function getAssessmentsFromDelivery ( \ core_kernel_classes_Resource $ compiledDelivery ) { $ unionAssignmentService = $ this -> getServiceLocator ( ) -> get ( UnionAssignmentService :: SERVICE_ID ) ; $ runtime = $ unionAssignmentService -> getRuntime ( $ compiledDelivery ) ; $ inputParameters = \ tao_models_classes_service_ServiceCallHelper :: getInputValues ( $ runtime , [ ] ) ; $ testDefinition = \ taoQtiTest_helpers_Utils :: getTestDefinition ( $ inputParameters [ 'QtiTestCompilation' ] ) ; $ assessmentItemRefs = $ testDefinition -> getComponentsByClassName ( 'assessmentItemRef' ) ; $ this -> report -> add ( new Report ( Report :: TYPE_INFO , "Starting to recompile items for delivery {$compiledDelivery->getLabel()} with identifier {$compiledDelivery->getUri()}:" ) ) ; $ count = 0 ; foreach ( $ assessmentItemRefs as $ assessmentItemRef ) { $ directoryIds = explode ( '|' , $ assessmentItemRef -> getHref ( ) ) ; $ item = $ this -> getResource ( $ directoryIds [ 0 ] ) ; $ properties = [ ] ; foreach ( $ item -> getRdfTriples ( ) as $ triple ) { $ properties [ $ triple -> predicate ] = $ triple -> object ; } if ( $ properties ) { $ directory = \ tao_models_classes_service_FileStorage :: singleton ( ) -> getDirectoryById ( $ directoryIds [ 2 ] ) ; $ languages = $ item -> getUsedLanguages ( $ this -> getProperty ( \ taoItems_models_classes_ItemsService :: PROPERTY_ITEM_CONTENT ) ) ; foreach ( $ languages as $ lang ) { $ path = $ lang . DIRECTORY_SEPARATOR . QtiJsonItemCompiler :: METADATA_FILE_NAME ; if ( ! $ directory -> has ( $ path ) ) { $ this -> writeMetadata ( $ item , $ directory , $ path , $ properties ) ; $ count ++ ; } } } } $ this -> report -> add ( new Report ( Report :: TYPE_INFO , "Was updated {$count} items." ) ) ; }
4806	protected function processMemberVar ( File $ phpcsFile , $ stackPtr ) { $ tokens = $ phpcsFile -> getTokens ( ) ; $ commentToken = [ T_COMMENT , T_DOC_COMMENT_CLOSE_TAG , ] ; $ commentEnd = $ phpcsFile -> findPrevious ( $ commentToken , $ stackPtr ) ; $ commentStart = $ tokens [ $ commentEnd ] [ 'comment_opener' ] ; if ( $ tokens [ $ commentEnd ] [ 'line' ] === $ tokens [ $ commentStart ] [ 'line' ] ) { $ phpcsFile -> addError ( 'Member variable comment should not be inline' , $ stackPtr , static :: ERROR_CODE ) ; } }
4651	public function clean ( $ projectPath , $ keep = 1 , $ force = false ) { $ builds = $ this -> getJobsToRemove ( $ projectPath , $ keep ) ; $ this -> cleanDirectories ( $ builds ) ; $ this -> cleanContainers ( $ builds ) ; $ this -> cleanImages ( $ builds , $ force ) ; }
11148	public function getMultipleDisplayObjects ( $ areas ) { $ out = array ( ) ; foreach ( $ areas as $ v ) { if ( ! ( $ v instanceof Neuron_GameServer_Map_Area ) ) { throw new Neuron_Exceptions_InvalidParameter ( "Parameters must be an array of area objects." ) ; } foreach ( $ this -> getDisplayObjects ( $ v ) as $ v ) { if ( ! $ v instanceof Neuron_GameServer_Map_MapObject ) { throw new Neuron_Core_Error ( "All map objects MUST implement Neuron_GameServer_Map_MapObject" ) ; } $ out [ ] = $ v ; } } return $ out ; }
2620	public function sendInstalledReq ( ) { $ pageViewParams = [ 'dl' => self :: GA_PAGEVIEW_URL . self :: FASTLY_INSTALLED_FLAG , 'dh' => preg_replace ( '#^https?://#' , '' , rtrim ( self :: GA_PAGEVIEW_URL , '/' ) ) , 'dp' => '/' . self :: FASTLY_INSTALLED_FLAG , 'dt' => ucfirst ( self :: FASTLY_INSTALLED_FLAG ) , 't' => self :: GA_HITTYPE_PAGEVIEW , ] ; $ this -> sendReqToGA ( $ pageViewParams , self :: GA_HITTYPE_PAGEVIEW ) ; $ eventParams = [ 'ec' => self :: GA_FASTLY_SETUP , 'ea' => 'Fastly ' . self :: FASTLY_INSTALLED_FLAG , 'el' => $ this -> getWebsiteName ( ) , 'ev' => 0 , 't' => self :: GA_HITTYPE_EVENT ] ; $ result = $ this -> sendReqToGA ( array_merge ( $ pageViewParams , $ eventParams ) ) ; return $ result ; }
11340	public function generateRules ( $ table ) { $ types = [ ] ; $ lengths = [ ] ; foreach ( $ table -> columns as $ column ) { if ( $ column -> autoIncrement ) { continue ; } if ( ! $ column -> allowNull && $ column -> defaultValue === null && ! $ column -> isPrimaryKey ) { $ types [ 'required' ] [ ] = $ column -> name ; } switch ( $ column -> type ) { case Schema :: TYPE_SMALLINT : case Schema :: TYPE_INTEGER : case Schema :: TYPE_BIGINT : $ types [ 'integer' ] [ ] = $ column -> name ; break ; case Schema :: TYPE_BOOLEAN : $ types [ 'boolean' ] [ ] = $ column -> name ; break ; case Schema :: TYPE_FLOAT : case Schema :: TYPE_DECIMAL : case Schema :: TYPE_MONEY : $ types [ 'number' ] [ ] = $ column -> name ; break ; case Schema :: TYPE_DATE : case Schema :: TYPE_TIME : case Schema :: TYPE_DATETIME : case Schema :: TYPE_TIMESTAMP : if ( ! in_array ( $ column -> name , [ 'created' , 'deleted' , 'modified' ] ) ) { $ types [ 'safe' ] [ ] = $ column -> name ; } break ; default : if ( $ column -> size > 0 ) { $ lengths [ $ column -> size ] [ ] = $ column -> name ; } else { $ types [ 'string' ] [ ] = $ column -> name ; } } } $ rules = [ ] ; foreach ( $ types as $ type => $ columns ) { $ rules [ ] = "[['" . implode ( "', '" , $ columns ) . "'], '$type']" ; } foreach ( $ lengths as $ length => $ columns ) { $ rules [ ] = "[['" . implode ( "', '" , $ columns ) . "'], 'string', 'max' => $length]" ; } return $ rules ; }
8556	private function fromDOMElement ( DOMElement $ dom ) { $ xpath = new DOMXPath ( $ dom -> ownerDocument ) ; $ xpath -> registerNamespace ( 'a' , 'http://mws.amazonaws.com/doc/2009-01-01/' ) ; foreach ( $ this -> fields as $ fieldName => $ field ) { $ fieldType = $ field [ 'FieldType' ] ; if ( is_array ( $ fieldType ) ) { if ( $ this -> isComplexType ( $ fieldType [ 0 ] ) ) { $ elements = $ xpath -> query ( "./a:$fieldName" , $ dom ) ; if ( $ elements -> length >= 1 ) { foreach ( $ elements as $ element ) { $ this -> fields [ $ fieldName ] [ 'FieldValue' ] [ ] = new $ fieldType [ 0 ] ( $ element ) ; } } } else { $ elements = $ xpath -> query ( "./a:$fieldName" , $ dom ) ; if ( $ elements -> length >= 1 ) { foreach ( $ elements as $ element ) { $ text = $ xpath -> query ( './text()' , $ element ) ; $ this -> fields [ $ fieldName ] [ 'FieldValue' ] [ ] = $ text -> item ( 0 ) -> data ; } } } } else { if ( $ this -> isComplexType ( $ fieldType ) ) { $ elements = $ xpath -> query ( "./a:$fieldName" , $ dom ) ; if ( $ elements -> length == 1 ) { $ this -> fields [ $ fieldName ] [ 'FieldValue' ] = new $ fieldType ( $ elements -> item ( 0 ) ) ; } } else { $ element = $ xpath -> query ( "./a:$fieldName/text()" , $ dom ) ; $ data = null ; if ( $ element -> length == 1 ) { switch ( $ this -> fields [ $ fieldName ] [ 'FieldType' ] ) { case 'DateTime' : $ data = new DateTime ( $ element -> item ( 0 ) -> data , new DateTimeZone ( 'UTC' ) ) ; break ; case 'bool' : $ value = $ element -> item ( 0 ) -> data ; $ data = $ value === 'true' ? true : false ; break ; default : $ data = $ element -> item ( 0 ) -> data ; break ; } $ this -> fields [ $ fieldName ] [ 'FieldValue' ] = $ data ; } } } } }
6980	protected function findOneAddressBy ( $ expression ) { if ( 0 < $ this -> addresses -> count ( ) ) { $ criteria = Criteria :: create ( ) -> where ( $ expression ) -> setMaxResults ( 1 ) ; $ matches = $ this -> addresses -> matching ( $ criteria ) ; if ( $ matches -> count ( ) == 1 ) { return $ matches -> first ( ) ; } } return null ; }
11981	public function isAccessible ( AcquirerInterface $ acquirer , ResourceInterface $ resource ) { if ( ! $ resource -> isLocked ( ) ) { return true ; } $ lock = $ resource -> getLock ( ) ; if ( $ lock instanceof ExpiringLockInterface and $ this -> isLockExpired ( $ lock ) ) { $ this -> release ( $ lock ) ; return true ; } return $ lock -> getAcquirer ( ) -> getIdentifier ( ) === $ acquirer -> getIdentifier ( ) ; }
6534	public function run ( ) { if ( ( $ exception = Yii :: $ app -> getErrorHandler ( ) -> exception ) === null ) { return '' ; } if ( $ exception instanceof \ HttpException ) { $ code = $ exception -> statusCode ; } else { $ code = $ exception -> getCode ( ) ; } if ( $ exception instanceof Exception ) { $ name = $ exception -> getName ( ) ; } else { $ name = $ this -> defaultName ? : Yii :: t ( 'yii' , 'Error' ) ; } if ( $ code ) { $ name .= " (#$code)" ; } if ( $ exception instanceof UserException ) { $ message = $ exception -> getMessage ( ) ; } else { $ message = $ this -> defaultMessage ? : Yii :: t ( 'yii' , 'An internal server error occurred.' ) ; } if ( Yii :: $ app -> getRequest ( ) -> getIsAjax ( ) ) { $ rr = new RequestResponse ( ) ; $ rr -> success = false ; $ rr -> message = "$name: $message" ; return ( array ) $ rr ; } else { if ( \ Yii :: $ app -> user -> can ( CmsManager :: PERMISSION_ADMIN_ACCESS ) ) { $ this -> controller -> layout = \ Yii :: $ app -> cms -> moduleAdmin -> layout ; return $ this -> controller -> render ( '@app/views/error/error' , [ 'message' => nl2br ( Html :: encode ( $ message ) ) ] ) ; } else { $ this -> controller -> layout = '@app/views/layouts/unauthorized' ; return $ this -> controller -> render ( '@app/views/error/unauthorized-403' , [ 'message' => nl2br ( Html :: encode ( $ message ) ) ] ) ; } } }
7305	protected function scheduleParentChangeEvents ( CustomerInterface $ customer ) { if ( ! $ customer -> hasChildren ( ) ) { return ; } foreach ( $ customer -> getChildren ( ) as $ child ) { $ this -> persistenceHelper -> scheduleEvent ( CustomerEvents :: PARENT_CHANGE , $ child ) ; } }
10290	protected function storeLastRun ( ) { if ( ! @ file_put_contents ( $ this -> lockDir . '/lastRun' , time ( ) ) ) { $ this -> logger -> log ( 'Failure storing last run time: ' . ( isset ( $ php_errormsg ) ? $ php_errormsg : 'Unknown error - enable the track_errors ini directive.' ) , Logger :: ERROR ) ; return ; } $ this -> logger -> log ( 'Stored last run time.' , Logger :: INFO ) ; }
392	protected static function filterCondition ( array $ condition , array $ aliases = [ ] ) { $ result = [ ] ; $ db = static :: getDb ( ) ; $ columnNames = static :: filterValidColumnNames ( $ db , $ aliases ) ; foreach ( $ condition as $ key => $ value ) { if ( is_string ( $ key ) && ! in_array ( $ db -> quoteSql ( $ key ) , $ columnNames , true ) ) { throw new InvalidArgumentException ( 'Key "' . $ key . '" is not a column name and can not be used as a filter' ) ; } $ result [ $ key ] = is_array ( $ value ) ? array_values ( $ value ) : $ value ; } return $ result ; }
12000	static protected function doctrineQuery ( $ tableName , $ field , $ generate ) { return \ Doctrine_Query :: create ( ) -> select ( $ field ) -> from ( $ tableName ) -> where ( "$field = ?" , $ generate ) -> execute ( array ( ) , \ Doctrine_Core :: HYDRATE_SINGLE_SCALAR ) ; }
6420	public function stop ( ) : Stopwatch { $ tick = $ this -> ticker -> read ( ) ; Preconditions :: checkState ( $ this -> isRunning , 'This stopwatch is already stopped.' ) ; $ this -> isRunning = false ; $ this -> elapsedMicros += ( $ tick - $ this -> startTick ) ; return $ this ; }
12144	public static function login ( $ rank = 1 , $ id = null ) { static :: provider ( ) -> set ( 'valid' , true ) ; static :: provider ( ) -> set ( 'rank' , $ rank ) ; static :: provider ( ) -> set ( 'id' , $ id ) ; return static :: user ( ) ; }
5870	protected static function getBasicMetadata ( $ fileName ) { $ extension = strtolower ( substr ( $ fileName , strrpos ( $ fileName , '.' ) + 1 ) ) ; $ metadata = [ ] ; if ( GeneralUtility :: inList ( 'jpg,jpeg,tif,tiff' , $ extension ) && function_exists ( 'exif_read_data' ) ) { $ exif = @ exif_read_data ( $ fileName ) ; if ( $ exif ) { $ metadata = $ exif ; $ metadata [ 'ImageDescription' ] = static :: safeUtf8Encode ( $ metadata [ 'ImageDescription' ] ) ; if ( isset ( $ metadata [ 'GPSLatitude' ] ) && is_array ( $ metadata [ 'GPSLatitude' ] ) ) { $ reference = isset ( $ metadata [ 'GPSLatitudeRef' ] ) ? $ metadata [ 'GPSLatitudeRef' ] : 'N' ; $ decimal = static :: rationalToDecimal ( $ metadata [ 'GPSLatitude' ] ) ; $ decimal *= $ reference === 'N' ? 1 : - 1 ; $ metadata [ 'GPSLatitudeDecimal' ] = $ decimal ; } if ( isset ( $ metadata [ 'GPSLongitude' ] ) && is_array ( $ metadata [ 'GPSLongitude' ] ) ) { $ reference = isset ( $ metadata [ 'GPSLongitudeRef' ] ) ? $ metadata [ 'GPSLongitudeRef' ] : 'E' ; $ decimal = static :: rationalToDecimal ( $ metadata [ 'GPSLongitude' ] ) ; $ decimal *= $ reference === 'E' ? 1 : - 1 ; $ metadata [ 'GPSLongitudeDecimal' ] = $ decimal ; } if ( isset ( $ metadata [ 'GPSAltitude' ] ) ) { $ rationalParts = explode ( '/' , $ metadata [ 'GPSAltitude' ] ) ; if ( ! empty ( $ rationalParts [ 1 ] ) ) { $ metadata [ 'GPSAltitudeDecimal' ] = $ rationalParts [ 0 ] / $ rationalParts [ 1 ] ; } else { $ metadata [ 'GPSAltitudeDecimal' ] = 0 ; } } } $ imageinfo = [ ] ; if ( function_exists ( 'iptcparse' ) && getimagesize ( $ fileName , $ imageinfo ) ) { if ( isset ( $ imageinfo [ 'APP13' ] ) ) { $ data = iptcparse ( $ imageinfo [ 'APP13' ] ) ; $ mapping = [ '2#005' => 'Title' , '2#025' => 'Keywords' , '2#040' => 'Instructions' , '2#080' => 'Creator' , '2#085' => 'CreatorFunction' , '2#090' => 'City' , '2#092' => 'Location' , '2#095' => 'Region' , '2#100' => 'CountryCode' , '2#101' => 'Country' , '2#103' => 'IdentifierWork' , '2#105' => 'CreatorTitle' , '2#110' => 'Credit' , '2#115' => 'Source' , '2#116' => 'Copyright' , '2#120' => 'Description' , '2#122' => 'DescriptionAuthor' , ] ; foreach ( $ mapping as $ iptcKey => $ metadataKey ) { if ( isset ( $ data [ $ iptcKey ] ) ) { $ metadata [ 'IPTC' . $ metadataKey ] = static :: safeUtf8Encode ( $ data [ $ iptcKey ] [ 0 ] ) ; } } } } } return $ metadata ; }
4457	public function detach ( string $ eventName , $ handler ) : void { if ( is_object ( $ handler ) == false && is_callable ( $ handler ) == false ) { throw new InvalidArgumentException ( sprintf ( 'Event handler must be either an object or a callable %s given.' , gettype ( $ handler ) ) ) ; } if ( isset ( $ this -> events [ $ eventName ] ) == false ) { return ; } $ priorityQueue = $ this -> events [ $ eventName ] ; $ priorityQueue -> setExtractFlags ( SplPriorityQueue :: EXTR_BOTH ) ; $ priorityQueue -> top ( ) ; $ newPriorityQueue = $ this -> createQueue ( ) ; while ( $ priorityQueue -> valid ( ) ) { $ data = $ priorityQueue -> current ( ) ; $ priorityQueue -> next ( ) ; if ( $ data [ 'data' ] !== $ handler ) { $ newPriorityQueue -> insert ( $ data [ 'data' ] , $ data [ 'priority' ] ) ; } } $ this -> events [ $ eventName ] = $ newPriorityQueue ; }
3954	public function getVariants ( $ objFilter ) { if ( $ this -> isVariantBase ( ) ) { return $ this -> getMetaModel ( ) -> findVariants ( array ( $ this -> get ( 'id' ) ) , $ objFilter ) ; } return null ; }
5342	private function getSoapClient ( $ service , $ method , array $ parameters ) { $ timestamp = time ( ) ; $ nonce = uniqid ( null , true ) ; $ soapClient = $ this -> client -> buildSoapClient ( $ service ) ; $ soapClient -> setTimestamp ( $ timestamp ) ; $ soapClient -> setNonce ( $ nonce ) ; $ soapClient -> setSignature ( array_merge ( $ parameters , [ '__method' => $ method ] ) , $ this -> client -> getPrivateKey ( ) , $ service , $ this -> client -> getEndpoint ( ) , $ timestamp , $ nonce ) ; return $ soapClient ; }
5472	private function getPrivatePropertyNoMatterWhat ( $ name , $ object ) { foreach ( ( array ) $ object as $ mangled_name => $ value ) { if ( $ this -> unmangle ( $ mangled_name ) == $ name ) { return $ value ; } } }
10109	private function writeMergedCells ( ) { $ mergeCells = $ this -> phpSheet -> getMergeCells ( ) ; $ countMergeCells = count ( $ mergeCells ) ; if ( $ countMergeCells == 0 ) { return ; } $ maxCountMergeCellsPerRecord = 1027 ; $ record = 0x00E5 ; $ i = 0 ; $ j = 0 ; $ recordData = '' ; foreach ( $ mergeCells as $ mergeCell ) { ++ $ i ; ++ $ j ; $ range = Coordinate :: splitRange ( $ mergeCell ) ; list ( $ first , $ last ) = $ range [ 0 ] ; list ( $ firstColumn , $ firstRow ) = Coordinate :: coordinateFromString ( $ first ) ; list ( $ lastColumn , $ lastRow ) = Coordinate :: coordinateFromString ( $ last ) ; $ recordData .= pack ( 'vvvv' , $ firstRow - 1 , $ lastRow - 1 , Coordinate :: columnIndexFromString ( $ firstColumn ) - 1 , Coordinate :: columnIndexFromString ( $ lastColumn ) - 1 ) ; if ( $ j == $ maxCountMergeCellsPerRecord or $ i == $ countMergeCells ) { $ recordData = pack ( 'v' , $ j ) . $ recordData ; $ length = strlen ( $ recordData ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ this -> append ( $ header . $ recordData ) ; $ recordData = '' ; $ j = 0 ; } } }
2183	public function create ( ) : ItemInterface { $ tree = $ this -> factory -> createItem ( 'root' ) ; $ this -> eventDispatcher -> dispatch ( ContaoCoreEvents :: BACKEND_MENU_BUILD , new MenuEvent ( $ this -> factory , $ tree ) ) ; return $ tree ; }
3322	public function anyOfOptions ( OptionCollection $ options ) { $ name = $ this -> getOptionName ( ) ; $ keys = $ options -> keys ( ) ; return in_array ( $ name , $ keys ) ; }
11260	public static function snake2pascal ( string $ snake ) : string { $ nameParts = explode ( "_" , $ snake ) ; $ nameParts = array_map ( "ucfirst" , $ nameParts ) ; return implode ( "" , $ nameParts ) ; }
12436	public function addExtra ( $ id , IFormField $ formField ) { $ formField -> setId ( $ id ) ; return $ this -> addFormField ( $ formField , true ) ; }
11929	public function setDataInterface ( $ value ) { if ( ( $ interfaceItem = Yii :: $ app -> collectors [ 'dataInterfaces' ] -> getOne ( $ value ) ) && ( $ interface = $ interfaceItem -> object ) ) { $ this -> _interface = $ interfaceItem ; } else { throw new Exception ( "Invalid interface!" ) ; } }
5224	protected function getProviderCreator ( $ provider ) { if ( is_string ( $ provider ) ) { return function ( $ injector , $ name , $ key ) use ( $ provider ) { $ providerInstance = $ injector -> getInstance ( $ provider ) ; if ( ! ( $ providerInstance instanceof InjectionProvider ) ) { throw new BindingException ( 'Configured provider class ' . $ provider . ' for ' . $ name . '[' . $ key . '] is not an instance of stubbles\ioc\InjectionProvider.' ) ; } return $ providerInstance -> get ( ) ; } ; } elseif ( $ provider instanceof InjectionProvider ) { return function ( ) use ( $ provider ) { return $ provider -> get ( ) ; } ; } throw new \ InvalidArgumentException ( 'Given provider must either be a instance of' . ' stubbles\ioc\InjectionProvider or a class name representing' . ' such a provider instance.' ) ; }
12924	public function getHandledLocalDataItems ( ) { $ handled = [ ] ; foreach ( $ this -> localDataItems as $ local ) { if ( $ local -> handled ) { $ handled [ ] = $ local ; } } return $ handled ; }
8897	public function insert_many ( $ data , $ insert_individual = false ) { if ( $ insert_individual ) { return $ this -> _insert_individual ( $ data ) ; } return $ this -> _insert_batch ( $ data ) ; }
756	protected function renderImage ( $ code ) { if ( isset ( $ this -> imageLibrary ) ) { $ imageLibrary = $ this -> imageLibrary ; } else { $ imageLibrary = Captcha :: checkRequirements ( ) ; } if ( $ imageLibrary === 'gd' ) { return $ this -> renderImageByGD ( $ code ) ; } elseif ( $ imageLibrary === 'imagick' ) { return $ this -> renderImageByImagick ( $ code ) ; } throw new InvalidConfigException ( "Defined library '{$imageLibrary}' is not supported" ) ; }
11544	public function confirmPasswordReset ( $ token ) { $ user = $ this -> getMapper ( ) -> findOneBy ( [ 'registrationToken' => $ token ] ) ; if ( ! $ user instanceof UserInterface ) { return ; } $ eventManager = $ this -> getEventManager ( ) ; $ eventManager -> trigger ( __METHOD__ , $ this , $ user ) ; $ user -> setRegistrationToken ( $ this -> getRegistrationToken ( ) ) ; $ user -> setEmailConfirmed ( true ) ; $ password = $ this -> getPasswordGenerator ( ) -> generate ( ) ; $ passwordService = $ this -> getMapper ( ) -> getPasswordService ( ) ; $ user -> setPassword ( $ passwordService -> create ( $ password ) ) ; $ viewModel = new ViewModel ( compact ( 'user' , 'password' ) ) ; $ viewModel -> setTemplate ( 'mail-message/user-change-password-success' ) ; $ mailService = $ this -> getMailService ( ) ; $ message = $ mailService -> getMessage ( ) ; $ message -> setTo ( $ user -> getEmail ( ) , $ user -> getDisplayName ( ) ) ; $ subject = 'Your password has been changed!' ; if ( $ this -> getTranslator ( ) && $ this -> isTranslatorEnabled ( ) ) { $ subject = $ this -> getTranslator ( ) -> translate ( $ subject , $ this -> getTranslatorTextDomain ( ) ) ; } $ message -> setSubject ( $ subject ) ; $ mailService -> setBody ( $ viewModel ) -> sendMessage ( ) ; $ this -> getMapper ( ) -> update ( $ user ) -> save ( ) ; $ eventManager -> trigger ( __METHOD__ . '.post' , $ this , $ user ) ; return $ user ; }
1734	public function validateCode ( User $ user , string $ code ) : bool { $ totp = TOTP :: create ( $ this -> getUpperUnpaddedSecretForUser ( $ user ) ) ; return $ totp -> verify ( $ code ) ; }
3166	public function getCurrentAssessmentSession ( RunnerServiceContext $ context ) { if ( $ context -> isAdaptive ( ) ) { return new AssessmentItemSession ( $ context -> getCurrentAssessmentItemRef ( ) , new SessionManager ( ) ) ; } else { return $ context -> getTestSession ( ) ; } }
92	protected static function validateSyntax ( $ json , $ file = null ) { $ parser = new JsonParser ( ) ; $ result = $ parser -> lint ( $ json ) ; if ( null === $ result ) { if ( defined ( 'JSON_ERROR_UTF8' ) && JSON_ERROR_UTF8 === json_last_error ( ) ) { throw new \ UnexpectedValueException ( '"' . $ file . '" is not UTF-8, could not parse as JSON' ) ; } return true ; } throw new ParsingException ( '"' . $ file . '" does not contain valid JSON' . "\n" . $ result -> getMessage ( ) , $ result -> getDetails ( ) ) ; }
12675	public function getForeignModel ( $ model ) { $ models = $ this -> foreignModels ; if ( isset ( $ models [ $ model ] ) ) { return $ models [ $ model ] ; } return false ; }
11498	public static function locate ( $ column , $ value ) { $ table = new static ( ) ; $ select = $ table -> select ( ) -> where ( "{$table->getAdapter()->quoteIdentifier($column)} = ?" , $ value ) -> limit ( 1 ) ; return $ table -> fetchRow ( $ select ) ; }
9374	protected function dispatcher ( ResponseInterface $ response , $ stack ) { $ dispatcher = new Dispatcher ( $ stack , $ response ) ; if ( class_exists ( 'Zend\Stratigility\MiddlewarePipe' ) ) { $ pipe = new MiddlewarePipe ; $ dispatcher = new StratigilityDispatcher ( $ pipe , $ stack , $ response ) ; } return $ dispatcher ; }
1517	public function readRelationship ( StoreInterface $ store , FetchRelationship $ request ) { $ record = $ request -> getRecord ( ) ; $ result = $ this -> beforeReadingRelationship ( $ record , $ request ) ; if ( $ this -> isResponse ( $ result ) ) { return $ result ; } $ related = $ store -> queryRelationship ( $ record , $ request -> getRelationshipName ( ) , $ request -> getParameters ( ) ) ; $ records = ( $ related instanceof PageInterface ) ? $ related -> getData ( ) : $ related ; $ result = $ this -> afterReadingRelationship ( $ record , $ records , $ request ) ; if ( $ this -> isInvokedResult ( $ result ) ) { return $ result ; } return $ this -> reply ( ) -> relationship ( $ related ) ; }
619	public static function validateData ( array $ data , $ rules = [ ] ) { $ model = new static ( $ data ) ; if ( ! empty ( $ rules ) ) { $ validators = $ model -> getValidators ( ) ; foreach ( $ rules as $ rule ) { if ( $ rule instanceof Validator ) { $ validators -> append ( $ rule ) ; } elseif ( is_array ( $ rule ) && isset ( $ rule [ 0 ] , $ rule [ 1 ] ) ) { $ validator = Validator :: createValidator ( $ rule [ 1 ] , $ model , ( array ) $ rule [ 0 ] , array_slice ( $ rule , 2 ) ) ; $ validators -> append ( $ validator ) ; } else { throw new InvalidConfigException ( 'Invalid validation rule: a rule must specify both attribute names and validator type.' ) ; } } } $ model -> validate ( ) ; return $ model ; }
8006	public static function forReasonCode ( $ code = 0 , Exception $ previous = null ) { switch ( $ code ) { case self :: CODE_FOR_ENCRYPTION_FAILURE : $ message = self :: MESSAGE_FOR_ENCRYPTION_FAILURE ; break ; case self :: CODE_FOR_RANDOM_DATA_GENERATION_FAILURE : $ message = self :: MESSAGE_FOR_RANDOM_DATA_GENERATION_FAILURE ; break ; default : $ message = self :: DEFAULT_MESSAGE ; } return new static ( $ message , $ code , $ previous ) ; }
9681	function fromXML ( $ xmlElement ) { if ( $ xmlElement -> getName ( ) == "contacts" ) { foreach ( $ xmlElement -> children ( ) as $ contactXml ) { $ contact = new Contact ( ) ; $ contact -> fromXML ( $ contactXml ) ; $ this -> contacts [ ] = $ contact ; } } }
4492	public function broadcast ( Message $ message , string $ topicArn ) { if ( $ this -> debug ) { $ this -> logger && $ this -> logger -> notice ( "Message would have been sent to $topicArn" , [ 'Message' => $ message , ] ) ; return ; } $ this -> messages -> send ( $ message , $ topicArn ) ; }
11035	function check_level ( $ error_level , $ errno , $ message ) { if ( error_reporting ( ) & $ error_level ) { switch ( $ error_level ) { case E_NOTICE : $ type = 'notice' ; break ; case E_WARNING : $ type = 'warning' ; break ; case E_ERROR : $ type = 'error' ; break ; } echo "<b>ETS $type:</b> $message" ; } if ( $ error_level == E_ERROR ) { exit ; } }
3463	public function handle ( ServerRequestInterface $ request ) : ResponseInterface { $ response = $ this -> getMiddlewarePipe ( ) -> handle ( $ request ) ; return $ response ; }
11708	public function actionCreate ( ) { $ user = \ Yii :: createObject ( [ 'class' => User :: className ( ) , 'scenario' => 'create' , ] ) ; $ this -> performAjaxValidation ( $ user ) ; if ( $ user -> load ( \ Yii :: $ app -> request -> post ( ) ) && $ user -> create ( ) ) { \ Yii :: $ app -> getSession ( ) -> setFlash ( 'success' , \ Yii :: t ( 'user' , 'User has been created' ) ) ; return $ this -> redirect ( [ 'index' ] ) ; } return $ this -> render ( 'create' , [ 'user' => $ user ] ) ; }
3976	public function handle ( EncodePropertyValueFromWidgetEvent $ event ) { if ( ! parent :: wantToHandle ( $ event ) || ( $ event -> getProperty ( ) !== 'colname' ) ) { return ; } $ oldColumnName = $ event -> getModel ( ) -> getProperty ( $ event -> getProperty ( ) ) ; $ columnName = $ event -> getValue ( ) ; $ metaModel = $ this -> getMetaModelByModelPid ( $ event -> getModel ( ) ) ; if ( ( ! $ columnName ) || $ oldColumnName !== $ columnName ) { $ this -> tableManipulator -> checkColumnDoesNotExist ( $ metaModel -> getTableName ( ) , $ columnName ) ; $ colNames = array_keys ( $ metaModel -> getAttributes ( ) ) ; if ( in_array ( $ columnName , $ colNames ) ) { throw new \ RuntimeException ( sprintf ( $ event -> getEnvironment ( ) -> getTranslator ( ) -> translate ( 'columnExists' , 'ERR' ) , $ columnName , $ metaModel -> getTableName ( ) ) ) ; } } }
5495	public function findFirstSlot ( $ parameters ) { $ count = count ( $ this -> map ) ; for ( $ i = 0 ; $ i < $ count ; $ i ++ ) { if ( $ this -> map [ $ i ] [ 'params' ] -> test ( $ parameters ) ) { return $ this -> map [ $ i ] ; } } return ; }
12324	protected function doExecute ( InputInterface $ input , OutputInterface $ output ) { if ( $ this -> askQuestions ( $ input , $ output ) == static :: RETURN_ERROR ) { return static :: RETURN_ERROR ; } $ data = $ this -> prepareData ( $ input ) ; $ this -> doPreExecuteTasks ( $ input , $ output , $ data ) ; $ return = $ this -> executeTasks ( $ input , $ output , $ data ) ; $ this -> doPostExecuteTasks ( $ input , $ output , $ data , $ return ) ; return $ return ; }
3541	public static function getGroupAssigmentOptions ( $ optionName , $ individualGroupAssignmentOptions = null ) { if ( $ individualGroupAssignmentOptions != null && is_array ( $ individualGroupAssignmentOptions ) && array_key_exists ( $ optionName , $ individualGroupAssignmentOptions ) ) { return $ individualGroupAssignmentOptions [ $ optionName ] ; } else if ( isset ( Yii :: $ app -> params [ 'LDAP-Group-Assignment-Options' ] ) && is_array ( Yii :: $ app -> params [ 'LDAP-Group-Assignment-Options' ] ) && array_key_exists ( $ optionName , Yii :: $ app -> params [ 'LDAP-Group-Assignment-Options' ] ) ) { return Yii :: $ app -> params [ 'LDAP-Group-Assignment-Options' ] [ $ optionName ] ; } else if ( array_key_exists ( $ optionName , static :: GROUP_ASSIGNMENT_TOUCH_ONLY_MATCHING_REGEX ) ) { return static :: GROUP_ASSIGNMENT_TOUCH_ONLY_MATCHING_REGEX [ $ optionName ] ; } else { throw new \ yii \ base \ Exception ( 'Group-Option ' . $ optionName . ' not found. Please define settings in the config/params.php of the yii2 framework as described on top of the UserDbLdap.php' ) ; } }
10455	public function consume ( ItemPipelineEvent $ event ) { if ( ! $ this -> setItem ( $ event ) ) { return ; } $ this -> log ( sprintf ( 'Start update single document of type %s id: %s' , get_class ( $ this -> getItem ( ) -> getDocument ( ) ) , $ this -> getItem ( ) -> getDocument ( ) -> getId ( ) ) ) ; if ( ! $ this -> persistDocument ( ) ) { return ; } ; $ this -> log ( 'End an update of a single document.' ) ; }
10556	public function make ( Log $ log , $ trans = true ) { $ items = [ ] ; $ route = 'dashboard.systems.logs.show' ; foreach ( $ log -> tree ( $ trans ) as $ level => $ item ) { $ items [ $ level ] = array_merge ( $ item , [ 'url' => route ( $ route , [ $ log -> date , $ level ] ) , 'icon' => $ this -> styler -> icon ( $ level ) ? : '' , ] ) ; } return $ items ; }
2752	public function processBlockedItems ( $ strippedBlockedItems , $ blockingType = null ) { if ( empty ( $ blockingType ) ) { $ blockingType = $ this -> _scopeConfig -> getValue ( self :: XML_FASTLY_BLOCKING_TYPE ) ; } if ( $ blockingType == '1' ) { $ strippedBlockedItems = '!(' . $ strippedBlockedItems . ')' ; } return $ strippedBlockedItems ; }
4982	public function setOptions ( $ options ) { foreach ( $ options as $ key => $ val ) { $ this -> setOption ( $ key , $ val ) ; } }
10562	private function _buildControllerName ( $ name ) { $ name = strtoupper ( $ name [ 0 ] ) . substr ( $ name , 1 ) ; $ controller = $ name ; $ namespace = NULL ; foreach ( $ this -> namespaces as $ ns ) { if ( class_exists ( $ ns . $ controller ) ) { $ namespace = $ ns ; $ controller = $ ns . $ controller ; break ; } } if ( NULL === $ namespace ) { return strtoupper ( $ this -> defaultController [ 0 ] ) . substr ( $ this -> defaultController , 1 ) . 'Controller' ; } else { return $ controller ; } }
6493	private function compareAcceptMediaTypeHeaders ( AcceptMediaTypeHeaderValue $ a , AcceptMediaTypeHeaderValue $ b ) : int { $ aQuality = $ a -> getQuality ( ) ; $ bQuality = $ b -> getQuality ( ) ; if ( $ aQuality < $ bQuality ) { return 1 ; } if ( $ aQuality > $ bQuality ) { return - 1 ; } $ aType = $ a -> getType ( ) ; $ bType = $ b -> getType ( ) ; $ aSubType = $ a -> getSubType ( ) ; $ bSubType = $ b -> getSubType ( ) ; if ( $ aType === '*' ) { if ( $ bType === '*' ) { return 0 ; } return 1 ; } if ( $ aSubType === '*' ) { if ( $ bSubType === '*' ) { return 0 ; } return 1 ; } if ( $ bType === '*' || $ bSubType === '*' ) { return - 1 ; } return 0 ; }
6258	public function authorizeByControllerAndAction ( $ user , Request $ request ) { $ roleField = $ this -> _config [ 'roleField' ] ; extract ( $ this -> getControllerNameAndAction ( $ request ) ) ; $ actionMap = $ this -> getActionMap ( ) ; if ( isset ( $ actionMap [ $ name ] [ '*' ] ) ) { if ( $ this -> _isAllowedRole ( $ user [ $ roleField ] , $ actionMap [ $ name ] [ '*' ] ) ) { return true ; } } if ( isset ( $ actionMap [ $ name ] [ $ action ] ) ) { if ( $ this -> _isAllowedRole ( $ user [ $ roleField ] , $ actionMap [ $ name ] [ $ action ] ) ) { return true ; } } if ( $ this -> config ( 'undefinedActionsAreAllowed' ) === true ) { return true ; } return false ; }
11745	public function getShakeInfo ( $ ticket , $ needPoi = null ) { $ params = [ 'ticket' => $ ticket , ] ; if ( $ needPoi !== null ) { $ params [ 'need_poi' ] = intval ( $ needPoi ) ; } return $ this -> parseJSON ( 'json' , [ self :: API_GET_SHAKE_INFO , $ params ] ) ; }
2743	public function execute ( Observer $ observer ) { if ( $ this -> backendAuthSession -> isLoggedIn ( ) == false ) { return ; } if ( $ this -> getFrequency ( ) + $ this -> getLastUpdate ( ) > time ( ) ) { return ; } $ modulePath = $ this -> moduleRegistry -> getPath ( ComponentRegistrar :: MODULE , 'Fastly_Cdn' ) ; $ filePath = str_replace ( [ '\\' , '/' ] , DIRECTORY_SEPARATOR , "$modulePath/composer.json" ) ; $ composerData = json_decode ( file_get_contents ( $ filePath ) ) ; $ currentVersion = ! empty ( $ composerData -> version ) ? $ composerData -> version : false ; if ( $ currentVersion ) { $ this -> feedFactory -> checkUpdate ( $ currentVersion ) ; } $ this -> setLastUpdate ( ) ; }
4585	public function decoded ( JWTDecodedEvent $ event ) { $ payload = $ event -> getPayload ( ) ; $ payload = json_decode ( json_encode ( $ payload ) , true ) ; if ( ! $ this -> accessor -> isReadable ( $ payload , $ this -> property ) ) { $ event -> markAsInvalid ( ) ; } elseif ( $ this -> validate && $ this -> accessor -> getValue ( $ payload , $ this -> property ) !== $ this -> getSignature ( ) ) { $ event -> markAsInvalid ( ) ; } }
7011	private function formatS ( & $ str ) { if ( strstr ( $ str , '%S' ) ) $ str = str_replace ( '%S' , static :: ordinal ( $ this -> day ) , $ str ) ; }
711	public function smallInteger ( $ length = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_SMALLINT , $ length ) ; }
8191	public function actionConfirm ( $ id , $ code ) { $ user = UserIdentity :: findByActivationToken ( $ id , $ code ) ; if ( $ user == NULL ) throw new NotFoundHttpException ; if ( ! empty ( $ user ) ) { $ user -> activation_token = NULL ; $ user -> status = User :: STATUS_ACTIVE ; $ user -> save ( FALSE ) ; Yii :: $ app -> session -> setFlash ( 'success' , Yii :: t ( 'user' , 'Account ' . $ user -> email . ' has successfully been activated' ) ) ; } else Yii :: $ app -> session -> setFlash ( 'error' , Yii :: t ( 'user' , 'Account ' . $ user -> email . ' could not been activated. Please contact the Administrator' ) ) ; return $ this -> render ( 'confirm' , [ 'user' => $ user ] ) ; }
10476	public function push ( string $ event , $ event_args = null ) : EventChannelInterface { try { $ this -> channel -> push ( $ event , $ event_args ) ; } catch ( EventSourceIsNotPushableException $ e ) { throw new EventStreamException ( 'Event is not pushable.' ) ; } return $ this ; }
9391	public function getSortValAfterAll ( $ groupingId = null ) { if ( ! $ groupingId === null && $ this -> grpColumn ) { throw new SortableException ( 'groupingId may be omitted only when grpColumn is not configured.' ) ; } $ query = ( new Query ( ) ) -> select ( $ this -> srtColumn ) -> from ( $ this -> targetTable ) -> where ( [ 'and' , $ this -> grpColumn ? [ '=' , $ this -> grpColumn , $ groupingId ] : [ ] , $ this -> skipRowsClause ( ) ] ) -> orderBy ( $ this -> srtColumn . ' DESC' ) -> limit ( 1 ) ; $ result = $ query -> one ( $ this -> db ) ; if ( $ result ) { $ result = array_values ( $ result ) ; $ sortVal = $ result [ 0 ] + $ this -> sortGap ; } else $ sortVal = $ this -> getIniSortVal ( ) ; return ( int ) $ sortVal ; }
7254	static public function isBetterState ( $ stateA , $ stateB ) { if ( $ stateA === static :: STATE_IN_STOCK ) { return $ stateB !== static :: STATE_IN_STOCK ; } elseif ( $ stateA === static :: STATE_PRE_ORDER ) { return $ stateB === static :: STATE_OUT_OF_STOCK ; } return false ; }
12512	public function login ( ) { if ( $ this -> validate ( ) ) { return \ Yii :: $ app -> getUser ( ) -> login ( $ this -> user , $ this -> rememberMe ? $ this -> module -> rememberFor : 0 ) ; } else { return false ; } }
10052	private function resolvePath ( $ path_alias , $ file_name ) { $ path = \ Yii :: getAlias ( $ path_alias , false ) ; $ path = $ path ? realpath ( $ path ) : $ path ; $ file_name = ! preg_match ( '/\.php$/i' , $ file_name ) ? $ file_name . '.php' : $ file_name ; if ( ! $ path || ! is_dir ( $ path ) || ! file_exists ( $ path . '/' . $ file_name ) ) { throw new Exception ( "Faker template \"{$path}/{$file_name}\" not found" ) ; } return $ path . '/' . $ file_name ; }
7901	protected function runUpload ( $ file ) { $ this -> provider -> setFile ( $ file ) ; if ( ! $ this -> provider -> isValid ( ) ) { throw new InvalidFileException ( "Given file [{$file}] is invalid." ) ; } $ filename = $ this -> getFullFileName ( $ this -> provider ) ; if ( $ this -> filesystem -> disk ( $ this -> disk ) -> put ( $ filename , $ this -> provider -> getContents ( ) , $ this -> getVisibility ( ) ) ) { return $ filename ; } return false ; }
4350	private function setCopyValues ( $ values ) { if ( isset ( $ values [ 'debug' ] [ 'emailLog' ] ) && $ values [ 'debug' ] [ 'emailLog' ] === true ) { $ values [ 'debug' ] [ 'emailLog' ] = 'onError' ; } foreach ( array ( 'emailFrom' , 'emailFunc' , 'emailTo' ) as $ key ) { if ( isset ( $ values [ 'debug' ] [ $ key ] ) && ! isset ( $ values [ 'errorEmailer' ] [ $ key ] ) ) { $ values [ 'errorEmailer' ] [ $ key ] = $ values [ 'debug' ] [ $ key ] ; } } return $ values ; }
11296	public function getAttributeValueExtended ( $ name , $ convertDates = true ) { if ( isset ( $ this -> model_data [ $ name ] ) ) { $ result = $ this -> model_data [ $ name ] ; if ( $ result instanceof \ DateTime && $ convertDates == true ) { $ result = $ result -> format ( 'Y-m-d H:i:s' ) ; } return $ result ; } if ( isset ( $ this -> data -> { $ name } ) ) { return $ this -> data -> { $ name } ; } else if ( isset ( $ this -> model_extends ) && isset ( $ this -> model_attributes [ $ this -> model_extends ] ) ) { $ extendedModel = $ this -> { $ this -> model_extends } ; if ( $ extendedModel && $ result = $ extendedModel -> getAttributeValue ( $ name ) ) { return $ result ; } } return null ; }
8247	public function userDataEncodePassword ( & $ userData , Password $ newPassword ) { $ encoderName = $ this -> config [ "encoder" ] ; $ encoder = $ this -> picoAuth -> getContainer ( ) -> get ( $ encoderName ) ; $ userData [ 'pwhash' ] = $ encoder -> encode ( $ newPassword -> get ( ) ) ; $ userData [ 'encoder' ] = $ encoderName ; if ( isset ( $ userData [ 'pwreset' ] ) ) { unset ( $ userData [ 'pwreset' ] ) ; } }
3935	private function setSearchable ( PropertyInterface $ property , $ propInfo ) { if ( ! isset ( $ propInfo [ 'search' ] ) ) { return ; } $ property -> setSearchable ( ( bool ) $ propInfo [ 'search' ] ) ; }
12820	public function execute ( callable $ callback , array $ vars ) : Response { $ arguments = $ this -> resolveDependencies ( $ callback , $ vars ) ; return call_user_func_array ( $ callback , $ arguments ) ; }
6374	public function transformAndConcat ( callable $ transformer ) : FluentIterable { return self :: from ( Iterables :: concatIterables ( $ this -> transform ( $ transformer ) ) ) ; }
8881	private function isValidRelativePath ( string $ relativePath , string $ cwd ) : bool { $ valid = false ; if ( './' === substr ( $ relativePath , 0 , 2 ) ) { $ tmpPath = $ cwd . DIRECTORY_SEPARATOR . substr ( $ relativePath , 2 , strlen ( $ relativePath ) ) ; $ valid = $ this -> isValidFullPath ( $ tmpPath ) ; } return $ valid ; }
11126	public function update ( Request $ request ) { foreach ( $ request -> all ( ) as $ key => $ value ) { if ( substr ( $ key , 0 , 8 ) == 'setting_' ) { $ skipSave = false ; $ key = substr ( $ key , 8 ) ; if ( ! $ skipSave ) { $ this -> settingRepository -> save ( $ key , $ value ) ; } } } Flash :: success ( trans ( 'l5starter::messages.update.success' ) ) ; return redirect ( route ( 'admin.settings.index' ) ) ; }
57	public function remove ( PackageInterface $ package , $ targetDir ) { $ downloader = $ this -> getDownloaderForInstalledPackage ( $ package ) ; if ( $ downloader ) { $ downloader -> remove ( $ package , $ targetDir ) ; } }
2311	public function getResizedPath ( ) { $ path = $ this -> resizedPath ; $ webDir = StringUtil :: stripRootDir ( System :: getContainer ( ) -> getParameter ( 'contao.web_dir' ) ) ; if ( strncmp ( $ path , $ webDir . '/' , \ strlen ( $ webDir ) + 1 ) === 0 ) { $ path = substr ( $ path , \ strlen ( $ webDir ) + 1 ) ; } return $ path ; }
4976	public static function factory ( ContainerInterface $ container ) { $ manager = $ container -> get ( 'ModuleManager' ) ; $ modules = $ manager -> getLoadedModules ( ) ; return new static ( $ modules ) ; }
1553	protected function resourceAttributes ( $ record = null ) { return $ this -> validatorFactory ( ) -> attributes ( $ this -> attributeRules ( $ record ) , $ this -> attributeMessages ( $ record ) , $ this -> attributeCustomAttributes ( $ record ) , function ( Validator $ validator ) use ( $ record ) { return $ this -> conditionalAttributes ( $ validator , $ record ) ; } , function ( ResourceObjectInterface $ resource , $ record ) { return $ this -> extractAttributes ( $ resource , $ record ) ; } ) ; }
11835	public function save ( IUser $ user ) : bool { if ( ! $ user instanceof Entity ) { return false ; } return entityManager ( ) -> save ( $ user ) ; }
2821	protected function _beforeSave ( ) { parent :: _beforeSave ( ) ; if ( ! $ this -> getId ( ) ) { $ this -> setToken ( $ this -> generateToken ( ) ) ; $ this -> setHttpMethod ( $ this -> getController ( ) -> getHttpMethod ( ) ) ; $ this -> setResponseCode ( $ this -> getController ( ) -> getResponseCode ( ) ) ; $ this -> setIp ( $ this -> getController ( ) -> getRemoteIp ( ) ) ; } $ this -> setRequestPath ( $ this -> getController ( ) -> getRequestOriginalPath ( ) ) ; $ this -> setSessionId ( $ this -> getController ( ) -> getSessionId ( ) ) ; $ this -> setInfo ( $ this -> getSerializedInfo ( ) ) ; return $ this ; }
11872	protected function _setDataKey ( $ key ) { if ( ! is_null ( $ key ) && ! is_string ( $ key ) && ! ( $ key instanceof Stringable ) ) { throw $ this -> _createInvalidArgumentException ( $ this -> __ ( 'Data key must be a string or stringable' ) , 0 , null , $ key ) ; } $ this -> dataKey = $ key ; return $ this ; }
3300	public function post ( $ url , $ params = [ ] ) { $ key = is_array ( $ params ) ? 'form_params' : 'body' ; return $ this -> request ( 'POST' , $ url , [ $ key => $ params ] ) ; }
3350	private function __getPath ( $ type , $ params = array ( ) ) { switch ( $ type ) { case 'root' : return '/' ; case 'account' : return '/account/' ; case 'file_list' : return '/files/' . $ this -> __getQueryString ( $ params , '?' ) ; case 'file_storage' : if ( array_key_exists ( 'uuid' , $ params ) == false ) { throw new \ Exception ( 'Please provide "uuid" param for request' ) ; } return sprintf ( '/files/%s/storage/' , $ params [ 'uuid' ] ) ; case 'file_copy' : return '/files/' ; case 'files_storage' : return '/files/storage/' ; case 'file' : if ( array_key_exists ( 'uuid' , $ params ) == false ) { throw new \ Exception ( 'Please provide "uuid" param for request' ) ; } return sprintf ( '/files/%s/' , $ params [ 'uuid' ] ) ; case 'group_list' : return '/groups/' . $ this -> __getQueryString ( $ params , '?' ) ; case 'group' : if ( array_key_exists ( 'uuid' , $ params ) == false ) { throw new \ Exception ( 'Please provide "uuid" param for request' ) ; } return sprintf ( '/groups/%s/' , $ params [ 'uuid' ] ) ; case 'group_storage' : if ( array_key_exists ( 'uuid' , $ params ) == false ) { throw new \ Exception ( 'Please provide "uuid" param for request' ) ; } return sprintf ( '/groups/%s/storage/' , $ params [ 'uuid' ] ) ; default : throw new \ Exception ( 'No api url type is provided for request "' . $ type . '". Use store, or appropriate constants.' ) ; } }
12312	private function writeToWebDir ( $ file , $ contents ) { if ( ! $ this -> webDir ) { return ; } if ( ! is_writable ( $ this -> webDir ) ) { trigger_error ( sprintf ( 'Directory %s is not writeable' , $ this -> webDir ) ) ; return ; } $ destFile = $ this -> webDir . $ file ; $ destDir = dirname ( $ destFile ) ; if ( ! is_dir ( $ destDir ) ) { mkdir ( $ destDir , 0777 , true ) ; } file_put_contents ( $ destFile , $ contents ) ; }
6148	public function setBody ( $ body ) { if ( is_string ( $ body ) ) { $ this -> body = $ body ; } elseif ( is_array ( $ body ) ) { $ this -> setJsonBody ( $ body ) ; } elseif ( is_callable ( $ body ) ) { ob_start ( ) ; $ res1 = call_user_func ( $ body ) ; $ res2 = ob_get_contents ( ) ; $ this -> body = $ res2 . $ res1 ; ob_end_clean ( ) ; } return $ this ; }
2097	public static function getRegexp ( $ strFormat = null ) { if ( $ strFormat === null ) { $ strFormat = static :: getNumericDateFormat ( ) ; } if ( ! static :: isNumericFormat ( $ strFormat ) ) { throw new \ Exception ( sprintf ( 'Invalid date format "%s"' , $ strFormat ) ) ; } return preg_replace_callback ( '/[a-zA-Z]/' , function ( $ matches ) { $ arrRegexp = array ( 'a' => '(?P<a>am|pm)' , 'A' => '(?P<A>AM|PM)' , 'd' => '(?P<d>0[1-9]|[12][0-9]|3[01])' , 'g' => '(?P<g>[1-9]|1[0-2])' , 'G' => '(?P<G>[0-9]|1[0-9]|2[0-3])' , 'h' => '(?P<h>0[1-9]|1[0-2])' , 'H' => '(?P<H>[01][0-9]|2[0-3])' , 'i' => '(?P<i>[0-5][0-9])' , 'j' => '(?P<j>[1-9]|[12][0-9]|3[01])' , 'm' => '(?P<m>0[1-9]|1[0-2])' , 'n' => '(?P<n>[1-9]|1[0-2])' , 's' => '(?P<s>[0-5][0-9])' , 'Y' => '(?P<Y>[0-9]{4})' , 'y' => '(?P<y>[0-9]{2})' , ) ; return $ arrRegexp [ $ matches [ 0 ] ] ?? $ matches [ 0 ] ; } , preg_quote ( $ strFormat ) ) ; }
4133	public function initializeObject ( $ obj ) { if ( $ obj instanceof PersistentCollection ) { $ obj -> initialize ( ) ; } else if ( $ obj instanceof Proxy \ Proxy ) { $ obj -> __doctrineLoad__ ( ) ; } }
8453	protected function determineFilename ( $ originalFilename , array $ mediaFileInfo ) { if ( is_null ( $ originalFilename ) || ! isset ( $ originalFilename ) || is_file ( sys_get_temp_dir ( ) . '/' . $ originalFilename ) ) { $ uniqueFilename = tempnam ( sys_get_temp_dir ( ) , 'tg' ) ; rename ( $ uniqueFilename , $ uniqueFilename . '.' . $ mediaFileInfo [ 'fileextension' ] ) ; $ mediaFileInfo [ 'filepath' ] = $ uniqueFilename . '.' . $ mediaFileInfo [ 'fileextension' ] ; } else { $ mediaFileInfo [ 'filepath' ] = sys_get_temp_dir ( ) . '/' . $ originalFilename ; } return $ mediaFileInfo ; }
1252	private function normalizeElementName ( $ name ) { $ nsElement = explode ( '@' , $ name ) ; if ( count ( $ nsElement ) > 1 ) { array_shift ( $ nsElement ) ; return $ nsElement [ 0 ] ; } else { return $ name ; } }
12118	public function getParam ( $ key , $ default = null ) { $ param = parent :: getParam ( $ key , $ default ) ; if ( is_string ( $ param ) ) { return trim ( $ param ) ; } return $ param ; }
8966	public static function exists ( $ currencyCode ) { $ currencyCode = trim ( strtoupper ( $ currencyCode ) ) ; return array_key_exists ( $ currencyCode , self :: $ codes ) ; }
3575	public function forget ( $ key ) { if ( $ attribute = $ this -> get ( $ key ) ) { $ attribute -> setValue ( null ) ; } return $ this ; }
12847	private function _loadController ( $ oControllerName , string $ sActionName , array $ aParams = array ( ) ) { $ aPhpDoc = PhpDoc :: getPhpDocOfMethod ( $ oControllerName , $ sActionName ) ; if ( isset ( $ aPhpDoc [ 'Cache' ] ) ) { if ( ! isset ( $ aPhpDoc [ 'Cache' ] [ 'maxage' ] ) ) { $ aPhpDoc [ 'Cache' ] [ 'maxage' ] = 0 ; } $ oMobileDetect = new \ Mobile_Detect ; if ( $ oMobileDetect -> isMobile ( ) ) { $ sCacheExt = '.mobi' ; } else { $ sCacheExt = '' ; } $ mCacheReturn = Cache :: get ( $ sActionName . $ sCacheExt , $ aPhpDoc [ 'Cache' ] [ 'maxage' ] ) ; if ( $ mCacheReturn !== false ) { return $ mCacheReturn ; } } if ( isset ( $ aPhpDoc [ 'Secure' ] ) ) { if ( isset ( $ aPhpDoc [ 'Secure' ] [ 'roles' ] ) && $ this -> _oSecurity -> getUserRole ( ) != $ aPhpDoc [ 'Secure' ] [ 'roles' ] ) { $ this -> _getPage403 ( ) ; } } $ oController = new $ oControllerName ; ob_start ( ) ; if ( ! defined ( 'PORTAL' ) ) { define ( 'PORTAL' , 'Batch' ) ; } if ( method_exists ( $ oController , 'beforeExecuteRoute' ) ) { call_user_func_array ( array ( $ oController , 'beforeExecuteRoute' ) , array ( ) ) ; } $ mReturnController = call_user_func_array ( array ( $ oController , $ sActionName ) , $ aParams ) ; if ( method_exists ( $ oController , 'afterExecuteRoute' ) ) { call_user_func_array ( array ( $ oController , 'afterExecuteRoute' ) , array ( ) ) ; } $ mReturn = ob_get_clean ( ) ; if ( $ mReturn == '' ) { $ mReturn = $ mReturnController ; } if ( isset ( $ aPhpDoc [ 'Cache' ] ) ) { $ oMobileDetect = new \ Mobile_Detect ; if ( $ oMobileDetect -> isMobile ( ) ) { $ sCacheExt = '.mobi' ; } else { $ sCacheExt = '' ; } if ( defined ( 'COMPRESS_HTML' ) && COMPRESS_HTML ) { $ mReturn = str_replace ( array ( "\t" , "\r" , " " ) , array ( "" , "" , "" , " " ) , $ mReturn ) ; } Cache :: set ( $ sActionName . $ sCacheExt , $ mReturn , $ aPhpDoc [ 'Cache' ] [ 'maxage' ] ) ; } return $ mReturn ; }
6814	private function getCurrencyFormatter ( ) { if ( $ this -> currencyFormatter ) { return $ this -> currencyFormatter ; } return $ this -> currencyFormatter = NumberFormatter :: create ( $ this -> locale , NumberFormatter :: CURRENCY ) ; }
2351	public function resizeTo ( $ width , $ height , $ mode = '' ) { if ( ! $ this -> isImage ) { return false ; } $ return = System :: getContainer ( ) -> get ( 'contao.image.image_factory' ) -> create ( $ this -> strRootDir . '/' . $ this -> strFile , array ( $ width , $ height , $ mode ) , $ this -> strRootDir . '/' . $ this -> strFile ) -> getUrl ( $ this -> strRootDir ) ; if ( $ return ) { $ this -> arrPathinfo = array ( ) ; $ this -> arrImageSize = array ( ) ; } return $ return ; }
8754	public function start ( $ block = true , $ interval = 100 ) { $ loop = $ this -> loop ; $ this -> pool = new ParallelPool ( function ( ) use ( $ loop ) { $ loop -> run ( ) ; } , $ this -> count ) ; $ this -> pool -> start ( ) ; $ this -> pool -> keep ( $ block , $ interval ) ; }
1903	public function limit ( $ intRows , $ intOffset = 0 ) { if ( $ intRows <= 0 ) { $ intRows = 30 ; } if ( $ intOffset < 0 ) { $ intOffset = 0 ; } if ( strncasecmp ( $ this -> strQuery , 'SELECT' , 6 ) === 0 ) { $ this -> strQuery .= ' LIMIT ' . $ intOffset . ',' . $ intRows ; } else { $ this -> strQuery .= ' LIMIT ' . $ intRows ; } return $ this ; }
8335	public function removeScope ( $ scope ) { if ( $ this -> isValidScope ( $ scope ) && $ this -> hasScope ( $ scope ) ) { unset ( $ this -> scope [ $ scope ] ) ; } return $ this ; }
541	protected function serializeModelErrors ( $ model ) { $ this -> response -> setStatusCode ( 422 , 'Data Validation Failed.' ) ; $ result = [ ] ; foreach ( $ model -> getFirstErrors ( ) as $ name => $ message ) { $ result [ ] = [ 'field' => $ name , 'message' => $ message , ] ; } return $ result ; }
5198	public function save ( ) { try { $ connection = new Connection ( $ this -> buildConnectionOptions ( ) ) ; $ connection -> open ( ) ; $ msg = new AMQPMessage ( $ this -> message , array ( 'content_type' => $ this -> content_type , 'delivery_mode' => 2 ) ) ; $ connection -> channel -> basic_publish ( $ msg , $ this -> exchange , $ this -> queue_name ) ; $ connection -> close ( ) ; } catch ( Exception $ e ) { $ connection -> close ( ) ; throw new Exception ( $ e ) ; } }
8481	public static function getNameById ( $ id , $ attributeName = 'name' ) { $ model = static :: loadModel ( $ id ) ; return empty ( $ model [ $ attributeName ] ) === false ? $ model [ $ attributeName ] : \ Yii :: t ( 'app' , 'Unknown' ) ; }
9096	public function update ( ) { hypePrototyper ( ) -> prototype -> saveStickyValues ( $ this -> action ) ; foreach ( $ this -> fields as $ field ) { if ( $ field -> getDataType ( ) == 'attribute' ) { $ this -> entity = $ field -> handle ( $ this -> entity ) ; } } if ( ! $ this -> entity -> save ( ) ) { return false ; } foreach ( $ this -> fields as $ field ) { if ( $ field -> getDataType ( ) !== 'attribute' ) { $ this -> entity = $ field -> handle ( $ this -> entity ) ; } } if ( ! $ this -> entity -> save ( ) ) { return false ; } hypePrototyper ( ) -> prototype -> clearStickyValues ( $ this -> action ) ; return $ this -> entity ; }
7362	protected function updateAmountsTotal ( SaleInterface $ sale ) { $ changed = false ; $ currency = $ sale -> getCurrency ( ) -> getCode ( ) ; $ sale -> clearResults ( ) ; $ result = $ this -> amountCalculator -> calculateSale ( $ sale ) ; if ( 0 != Money :: compare ( $ result -> getBase ( ) , $ sale -> getNetTotal ( ) , $ currency ) ) { $ sale -> setNetTotal ( $ result -> getBase ( ) ) ; $ changed = true ; } if ( 0 != Money :: compare ( $ result -> getTotal ( ) , $ sale -> getGrandTotal ( ) , $ currency ) ) { $ sale -> setGrandTotal ( $ result -> getTotal ( ) ) ; $ changed = true ; } return $ changed ; }
7048	protected function formatPhoneNumber ( PhoneNumber $ number = null ) { if ( $ number ) { return $ this -> phoneNumberUtil -> format ( $ number , PhoneNumberFormat :: INTERNATIONAL ) ; } return null ; }
10507	private function registerFilesystem ( ) { $ this -> app -> singleton ( Contracts \ Utilities \ Filesystem :: class , function ( $ app ) { $ files = $ app [ 'files' ] ; $ filesystem = new Utilities \ Filesystem ( $ files , storage_path ( 'logs' ) ) ; $ filesystem -> setPattern ( Utilities \ Filesystem :: PATTERN_PREFIX , Utilities \ Filesystem :: PATTERN_DATE , Utilities \ Filesystem :: PATTERN_EXTENSION ) ; return $ filesystem ; } ) ; $ this -> app -> singleton ( 'arcanedev.log-viewer.filesystem' , Contracts \ Utilities \ Filesystem :: class ) ; }
7434	private function getDirContents ( $ dir , & $ results = [ ] ) { $ files = scandir ( $ dir ) ; foreach ( $ files as $ value ) { $ path = realpath ( $ dir . DIRECTORY_SEPARATOR . $ value ) ; if ( ! is_dir ( $ path ) ) { $ results [ ] = $ path ; continue ; } if ( $ value != '.' && $ value != '..' ) { $ this -> getDirContents ( $ path , $ results ) ; $ results [ ] = $ path ; } } return $ results ; }
12293	public function update ( array $ data , $ id ) { $ resource = $ this -> model -> find ( $ id ) ; if ( ! $ resource ) { return '' ; } $ resource -> update ( $ data ) ; return $ resource ; }
11151	public function getApi ( ) { if ( $ this -> api === null ) { $ this -> api = new ExtDirectApi ( $ this -> useCache ( ) , $ this -> getApplicationPath ( ) , $ this -> getApplicationNameSpace ( ) ) ; } return $ this -> api ; }
10685	public function get ( $ parameter ) { switch ( $ parameter ) { case "dev" : return $ this -> dev ?? true ; case "config" : return $ this -> config ; case "injector" : return $ this -> injector ; case "pathConfig" : return $ this -> path_config ; case "request" : return $ this -> request ; case "resolver" : return $ this -> resolver ; case "moduleManager" : return $ this -> module_manager ; case "auth" : return $ this -> injector -> getInstance ( Authentication :: class ) ; case "db" : return $ this -> injector -> getInstance ( DB :: class ) ; case "dispatcher" : return $ this -> injector -> getInstance ( Dispatcher :: class ) ; case "template" : return $ this -> injector -> getInstance ( Template :: class ) ; case "mailer" : return $ this -> injector -> getInstance ( SMTPSender :: class ) ; case "i18n" : return $ this -> injector -> getInstance ( I18n :: class ) ; case "processChain" : return $ this -> injector -> getInstance ( ProcessChain :: class ) ; } throw new InvalidArgumentException ( "No such object: $parameter" ) ; }
2541	protected function analyzeWithErrCodeCategoryMsgQuery ( SendResult $ response , $ qErr , $ qCat , $ qMsg , $ errLevel = null ) { $ analyzeResponse = new Result ( $ response ) ; $ domXpath = $ this -> makeDomXpath ( $ response -> responseXml ) ; $ errorCodeNodeList = $ domXpath -> query ( $ qErr ) ; if ( $ errorCodeNodeList -> length > 0 ) { $ analyzeResponse -> status = Result :: STATUS_ERROR ; $ errorCatNode = $ domXpath -> query ( $ qCat ) -> item ( 0 ) ; if ( $ errorCatNode instanceof \ DOMNode ) { $ analyzeResponse -> status = $ this -> makeStatusFromErrorQualifier ( $ errorCatNode -> nodeValue ) ; } $ analyzeResponse -> messages [ ] = new Result \ NotOk ( $ errorCodeNodeList -> item ( 0 ) -> nodeValue , $ this -> makeMessageFromMessagesNodeList ( $ domXpath -> query ( $ qMsg ) ) , $ errLevel ) ; } return $ analyzeResponse ; }
810	private function toComparableNames ( array $ types , array $ symbolShortNames ) { $ normalized = array_map ( function ( $ type ) use ( $ symbolShortNames ) { $ type = strtolower ( $ type ) ; if ( isset ( $ symbolShortNames [ $ type ] ) ) { return $ symbolShortNames [ $ type ] ; } return $ type ; } , $ types ) ; sort ( $ normalized ) ; return $ normalized ; }
12955	public function getObject ( $ checkAccess = true ) { $ registryClass = Yii :: $ app -> classes [ 'Registry' ] ; $ return = $ registryClass :: getObject ( $ this -> registry_id , $ checkAccess ) ; if ( get_class ( $ return ) === 'cascade\models\Registry' ) { \ d ( $ this -> registry_id ) ; exit ; } return $ return ; }
5303	protected static function hexToUnicode ( $ char ) { if ( ! is_string ( $ char ) || ! preg_match ( '(^[0-9a-f]{2,6}$)i' , $ char ) ) { throw new \ InvalidArgumentException ( '$char must be one single unicode character as hex string' ) ; } return mb_convert_encoding ( '&#x' . strtolower ( $ char ) . ';' , 'UTF-8' , 'HTML-ENTITIES' ) ; }
3583	protected function joinMeta ( Builder $ query , $ column ) { $ query -> prefixColumnsForJoin ( ) ; $ alias = $ this -> generateMetaAlias ( ) ; $ table = ( new Attribute ) -> getTable ( ) ; $ query -> leftJoin ( "{$table} as {$alias}" , function ( $ join ) use ( $ alias , $ column ) { $ join -> on ( "{$alias}.metable_id" , '=' , $ this -> getQualifiedKeyName ( ) ) -> where ( "{$alias}.metable_type" , '=' , $ this -> getMorphClass ( ) ) -> where ( "{$alias}.meta_key" , '=' , $ column ) ; } ) ; return $ alias ; }
4093	public function wildcard ( $ val , $ field = false ) { $ this -> wildcard = ( $ field ) ? array ( $ field => $ val ) : $ val ; return $ this ; }
7426	private function isValid ( $ source = '' ) { if ( empty ( $ source ) ) { return false ; } else { $ extension = substr ( $ source , - 3 ) ; if ( strtolower ( $ extension ) !== 'swf' ) { return false ; } } return true ; }
1834	public static function findByPk ( $ varValue , array $ arrOptions = array ( ) ) { if ( empty ( $ arrOptions ) ) { $ objModel = Registry :: getInstance ( ) -> fetch ( static :: $ strTable , $ varValue ) ; if ( $ objModel !== null ) { return $ objModel ; } } $ arrOptions = array_merge ( array ( 'limit' => 1 , 'column' => static :: $ strPk , 'value' => $ varValue , 'return' => 'Model' ) , $ arrOptions ) ; return static :: find ( $ arrOptions ) ; }
799	private function removeSpaceAroundToken ( Tokens $ tokens , $ index ) { $ token = $ tokens [ $ index ] ; if ( $ token -> isWhitespace ( ) && false === strpos ( $ token -> getContent ( ) , "\n" ) ) { $ tokens -> clearAt ( $ index ) ; } }
12866	public function init_locales ( ) { if ( ! empty ( $ this -> textdomain ) && $ this -> locales_initialized !== true ) { load_plugin_textdomain ( $ this -> textdomain , true , $ this -> get_id ( ) ) ; $ this -> locales_initialized = true ; } }
12684	public function offsetSet ( $ offset , $ value ) { if ( is_null ( $ this -> result ) ) { $ this -> fetchData ( ) ; } if ( ! $ this -> isFetched ( ) ) { trigger_error ( 'Web2All_Table_ObjectList::offsetSet: cannot set value on unitialized list' , E_USER_NOTICE ) ; return false ; } if ( ! $ this -> is_assoc && ! is_numeric ( $ value ) ) { trigger_error ( 'Web2All_Table_ObjectList::offsetSet: can only set numeric keys non assoc lists' , E_USER_NOTICE ) ; return false ; } if ( $ value instanceof $ this -> classname ) { $ this -> result [ $ offset ] = $ value ; } else { trigger_error ( 'Web2All_Table_ObjectList::offsetSet: can only add objects of type ' . $ this -> classname . ' to the list' , E_USER_NOTICE ) ; return false ; } }
11768	public function updateSentinels ( ) { SENTINEL_QUERY : { $ sentinel = $ this -> getSentinelConnection ( ) ; try { $ payload = $ sentinel -> executeCommand ( RawCommand :: create ( 'SENTINEL' , 'sentinels' , $ this -> service ) ) ; $ this -> sentinels = array ( ) ; $ this -> sentinels [ ] = $ sentinel -> getParameters ( ) -> toArray ( ) ; foreach ( $ payload as $ sentinel ) { $ this -> sentinels [ ] = array ( 'host' => $ sentinel [ 3 ] , 'port' => $ sentinel [ 5 ] , 'role' => 'sentinel' , ) ; } } catch ( ConnectionException $ exception ) { $ this -> sentinelConnection = null ; goto SENTINEL_QUERY ; } } }
3126	protected function isStartPoint ( TimePoint $ point ) { return $ point -> match ( null , TimePoint :: TARGET_ALL , TimePoint :: TYPE_START ) ; }
10809	protected function __templates ( $ customTemplate = null , $ customTemplateSuffix = null ) { $ templates = SSViewer :: get_templates_by_class ( $ this -> class , $ customTemplateSuffix , \ FormField :: class ) ; if ( ! $ templates ) { throw new \ Exception ( "No template found for {$this->class}" ) ; } if ( $ customTemplate ) { array_unshift ( $ templates , $ customTemplate ) ; } return $ templates ; }
10224	private function buildComplexIndexMenu ( $ modelName , $ modelId , ModelConfig $ config = null ) { $ model = $ this -> aujaConfigurator -> getModel ( $ modelName ) ; $ relations = $ this -> aujaConfigurator -> getRelationsForModel ( $ model ) ; $ associationRelations = array ( ) ; foreach ( $ relations as $ relation ) { if ( $ relation -> getType ( ) == Relation :: HAS_MANY || $ relation -> getType ( ) == Relation :: HAS_AND_BELONGS_TO ) { $ associationRelations [ ] = $ relation ; } } switch ( count ( $ associationRelations ) ) { case 0 : $ menu = $ this -> noAssociationsMenuFor ( $ modelName , $ config ) ; break ; case 1 : $ menu = $ this -> singleAssociationMenuFor ( $ modelName , $ modelId , $ associationRelations [ 0 ] , $ config ) ; break ; default : $ menu = $ this -> multipleAssociationsMenuFor ( $ modelName , $ modelId , $ associationRelations , $ config ) ; break ; } return $ menu ; }
7145	public function add_custom_profile_fields ( $ user ) { $ user_settings = apply_filters ( 'iac_get_user_settings' , array ( ) , $ user -> ID ) ; $ nonce = wp_create_nonce ( 'iac_user_settings' ) ; ?> <h3> <?php _e ( 'Informer?' , $ this -> get_textdomain ( ) ) ; ?> </h3> <table class="form-table"> <tr id="post_subscription"> <th> <label for="post_subscription_checkbox"> <?php _e ( 'Posts subscription' , $ this -> get_textdomain ( ) ) ; ?> </label> </th> <td> <input type="checkbox" id="post_subscription_checkbox" name="post_subscription" value="1" <?php checked ( '1' , $ user_settings [ 'inform_about_posts' ] ) ; ?> /> <span class="description"> <?php _e ( 'Inform about new posts via e-mail, without your own posts.' , $ this -> get_textdomain ( ) ) ; ?> </span> </td> </tr> <tr id="comment_subscription"> <th> <label for="comment_subscription_checkbox"> <?php _e ( 'Comments subscription' , $ this -> get_textdomain ( ) ) ; ?> </label> </th> <td> <input type="checkbox" id="comment_subscription_checkbox" name="comment_subscription" value="1" <?php checked ( '1' , $ user_settings [ 'inform_about_comments' ] ) ; ?> /> <span class="description"> <?php _e ( 'Inform about new comments via e-mail, without your own comments.' , $ this -> get_textdomain ( ) ) ; ?> </span> <input type="hidden" name="iac_nonce" value=" <?php echo $ nonce ; ?> " /> </td> </tr> </table> <?php }
12235	public function insertXML ( $ xml , $ mode = 'append' ) { $ tmp = dom_import_simplexml ( $ this ) ; $ fragment = $ tmp -> ownerDocument -> createDocumentFragment ( ) ; $ use_errors = libxml_use_internal_errors ( true ) ; if ( ! $ fragment -> appendXML ( $ xml ) ) { libxml_use_internal_errors ( $ use_errors ) ; throw new InvalidArgumentException ( libxml_get_last_error ( ) -> message ) ; } libxml_use_internal_errors ( $ use_errors ) ; $ this -> insertNode ( $ tmp , $ fragment , $ mode ) ; return $ this ; }
12475	public function getCurrentTheme ( ) { $ theme = $ this -> getDefaultTheme ( ) ; if ( $ this -> container -> get ( 'session' ) -> has ( '_admin_theme' ) ) { $ theme = $ this -> container -> get ( 'session' ) -> get ( '_admin_theme' ) ; } return $ theme ; }
8591	public function setStatus ( $ status ) { if ( ! $ this -> isNumericArray ( $ status ) ) { $ status = array ( $ status ) ; } $ this -> fields [ 'Status' ] [ 'FieldValue' ] = $ status ; return $ this ; }
4886	public function plugin ( $ plugin , $ options = null ) { $ renderer = $ this -> getView ( ) ; if ( ! method_exists ( $ renderer , 'getHelperPluginManager' ) ) { return true === $ options ? false : new HelperProxy ( false ) ; } $ manager = $ renderer -> getHelperPluginManager ( ) ; $ hasPlugin = $ manager -> has ( $ plugin ) ; if ( true === $ options ) { return $ hasPlugin ; } if ( $ hasPlugin ) { $ pluginInstance = $ manager -> get ( $ plugin , $ options ) ; } else { $ pluginInstance = false ; } return new HelperProxy ( $ pluginInstance ) ; }
3634	public function events ( Request $ request ) : array { $ em = \ bean ( 'eventManager' ) ; if ( $ event = \ trim ( $ request -> query ( 'name' ) ) ) { if ( ! $ queue = $ em -> getListenerQueue ( $ event ) ) { return [ 'msg' => 'event name is invalid: ' . $ event ] ; } $ classes = [ ] ; foreach ( $ queue -> getIterator ( ) as $ listener ) { $ classes [ ] = \ get_class ( $ listener ) ; } return $ classes ; } return $ em -> getListenedEvents ( ) ; }
5603	public function paintException ( $ exception ) { if ( ! $ this -> fail && ! $ this -> error ) { $ this -> error = true ; $ message = 'Unexpected exception of type[' . get_class ( $ exception ) . '] with message [' . $ exception -> getMessage ( ) . '] in [' . $ exception -> getFile ( ) . ' line ' . $ exception -> getLine ( ) . ']' ; $ this -> message = self :: escapeVal ( $ message ) ; $ this -> listener -> write ( '{status:"error",message:"' . $ this -> message . '",group:"' . $ this -> group . '",case:"' . $ this -> case . '",method:"' . $ this -> method . '"}' ) ; } }
5594	protected function createRequest ( $ url , $ encoding ) { $ request = $ this -> createHttpRequest ( $ url , $ encoding ) ; $ this -> addAdditionalHeaders ( $ request ) ; if ( $ this -> cookies_enabled ) { $ request -> readCookiesFromJar ( $ this -> cookie_jar , $ url ) ; } $ this -> authenticator -> addHeaders ( $ request , $ url ) ; if ( $ this -> http_referer ) { $ headers = $ request -> getHeaders ( ) ; if ( is_array ( $ headers ) ) { $ custom_referer = false ; foreach ( $ headers as $ header ) { if ( preg_match ( '~^referer:~i' , $ header ) ) { $ custom_referer = true ; break ; } } if ( ! $ custom_referer ) { $ request -> addHeaderLine ( 'Referer: ' . $ this -> http_referer ) ; } } } return $ request ; }
11306	public static function getDataFromId ( $ id ) { $ db = Neuron_Core_Database :: __getInstance ( ) ; $ id = intval ( $ id ) ; $ r = $ db -> getDataFromQuery ( $ db -> customQuery ( " SELECT * FROM n_players WHERE n_players.plid = '" . $ id . "' " ) ) ; if ( count ( $ r ) == 1 ) { return $ r [ 0 ] ; } return null ; }
63	public function rmdir ( $ path ) { $ deleted = @ rmdir ( $ path ) ; if ( ! $ deleted ) { if ( Platform :: isWindows ( ) ) { usleep ( 350000 ) ; $ deleted = @ rmdir ( $ path ) ; } if ( ! $ deleted ) { $ error = error_get_last ( ) ; $ message = 'Could not delete ' . $ path . ': ' . @ $ error [ 'message' ] ; if ( Platform :: isWindows ( ) ) { $ message .= "\nThis can be due to an antivirus or the Windows Search Indexer locking the file while they are analyzed" ; } throw new \ RuntimeException ( $ message ) ; } } return true ; }
6417	public static function size ( IteratorAggregate $ iterable ) : int { if ( $ iterable instanceof Countable ) { return $ iterable -> count ( ) ; } return Iterators :: size ( Iterators :: from ( $ iterable -> getIterator ( ) ) ) ; }
11876	public static function getDump ( $ var , $ maxSize = null ) { $ trace = debug_backtrace ( ) ; $ dump = '' ; $ dump .= static :: getHeader ( 'Dump de variable' ) ; $ dump .= '<div class="dump_segment">Contexte</div>' ; if ( count ( $ trace ) > 2 ) { $ dump .= static :: getContext ( $ trace [ 1 ] , $ trace [ 2 ] ) ; } else { $ dump .= static :: getContext ( $ trace [ 1 ] ) ; } if ( is_object ( $ var ) && get_class ( $ var ) == 'sylab\common\sgbd\Query' ) { $ dump .= '<div class="dump_segment">Requte SQL</div>'; $ dump .= '<div class="dump_segment_content"><pre>' . $ var -> getSql ( ) . '</pre></div>' ; } $ dump .= '<div class="dump_segment">Exploration de la variable</div>' ; $ dump .= '<div class="dump_segment_content"><pre>' ; if ( is_object ( $ var ) && get_class ( $ var ) == 'sylab\framework\query\Query' ) { $ dump .= static :: getDumpQueryResult ( $ var -> getQueryResults ( ) ) ; } elseif ( is_object ( $ var ) && get_class ( $ var ) == 'sylab\framework\query\QueryResult' ) { $ dump .= static :: getDumpQueryResult ( $ var ) ; } else { $ dump .= static :: getDumpContent ( $ var , $ maxSize ) ; } $ dump .= '</pre></div>' ; $ dump .= static :: getFooter ( ) ; return $ dump ; }
6634	public function parseProfileResponse ( Response $ response , AccessTokenInterface $ access_token ) { $ profile = $ response -> json ( ) ; if ( gettype ( $ profile ) !== 'object' ) { throw new InvalidProfileException ( ) ; } if ( isset ( $ profile -> error ) ) { $ error = $ profile -> error ; throw new InvalidProfileException ( $ error -> type . ': ' . $ error -> message , $ error -> code ) ; } $ profile -> access_token = $ access_token -> token ( ) ; return $ this -> profile -> instantiate ( $ profile , $ this -> name ) ; }
5749	public static function arrayWalkToStringRecursive ( array $ arr , int $ level = 0 , int $ maxLevel = 1000 , $ newLine = '<br>' ) : string { $ out = "" ; $ tabs = " " ; for ( $ i = 0 ; $ i < $ level ; $ i ++ ) { $ tabs .= " ^" ; } foreach ( $ arr as $ k => $ v ) { $ out .= "$newLine$tabs$k: " ; if ( is_object ( $ v ) ) { $ out .= 'object type: ' . get_class ( $ v ) ; } elseif ( is_array ( $ v ) ) { $ newLevel = $ level + 1 ; if ( $ newLevel > $ maxLevel ) { $ out .= ' array too deep, quitting' ; } else { $ out .= self :: arrayWalkToStringRecursive ( $ v , $ newLevel , $ maxLevel , $ newLine ) ; } } else { $ out .= ( string ) $ v ; } } return $ out ; }
4053	private function fetchConditions ( $ inputScreenId ) : array { $ builder = $ this -> connection -> createQueryBuilder ( ) ; return $ builder -> select ( 'cond.*' , 'setting.attr_id AS setting_attr_id' ) -> from ( 'tl_metamodel_dcasetting_condition' , 'cond' ) -> leftJoin ( 'cond' , 'tl_metamodel_dcasetting' , 'setting' , 'cond.settingId=setting.id' ) -> leftJoin ( 'setting' , 'tl_metamodel_dca' , 'dca' , 'setting.pid=dca.id' ) -> where ( 'cond.enabled=1' ) -> andWhere ( 'setting.published=1' ) -> andWhere ( 'dca.id=:screenId' ) -> setParameter ( 'screenId' , $ inputScreenId ) -> orderBy ( 'pid' ) -> addOrderBy ( 'sorting' ) -> execute ( ) -> fetchAll ( \ PDO :: FETCH_ASSOC ) ; }
7542	function typeIndex ( ) { if ( ! $ this -> parent ) { return - 1 ; } else { $ index = - 1 ; foreach ( array_keys ( $ this -> parent -> children ) as $ k ) { if ( strcasecmp ( $ this -> tag , $ this -> parent -> children [ $ k ] -> tag ) === 0 ) { ++ $ index ; } if ( $ this -> parent -> children [ $ k ] === $ this ) { return $ index ; } } return - 1 ; } }
12069	public function updateProject ( Project $ project , $ composerJson ) { $ response = $ this -> getResponse ( 'post' , sprintf ( 'v2/projects/%s' , $ project -> getProjectKey ( ) ) , array ( ) , array ( 'project_file' => $ composerJson ) ) ; return $ this -> hydrator -> hydrate ( $ project , $ response ) ; }
11341	public function getModelMap ( ) { $ m = [ ] ; $ search = [ ] ; foreach ( $ this -> searchModels as $ path => $ namespace ) { $ files = FileHelper :: findFiles ( Yii :: getAlias ( $ path ) , [ 'only' => [ '.php' ] ] ) ; foreach ( $ files as $ file ) { $ baseName = strstr ( basename ( $ file ) , '.php' , true ) ; $ className = $ namespace . '\\' . $ baseName ; if ( class_exists ( $ className ) ) { $ reflector = new \ ReflectionClass ( $ className ) ; if ( $ reflector -> isSubclassOf ( 'yii\base\Model' ) ) { $ m [ $ baseName ] = $ className ; } } } } return $ m ; }
4861	public function pushLazy ( $ service , $ payload = null , array $ options = [ ] ) { $ manager = $ this -> getJobPluginManager ( ) ; $ serviceOptions = [ ] ; if ( is_array ( $ service ) ) { $ serviceOptions = $ service [ 'options' ] ?? $ service [ 1 ] ?? [ ] ; $ service = $ service [ 'name' ] ?? $ service [ 0 ] ?? null ; } if ( ! $ manager -> has ( $ service ) && ! class_exists ( $ service ) ) { throw new \ UnexpectedValueException ( sprintf ( 'Service name "%s" is not a known job service or existent class' , $ service ) ) ; } $ lazyOptions = [ 'name' => $ service , 'options' => $ serviceOptions , 'content' => $ payload , ] ; $ job = $ this -> getJobPluginManager ( ) -> build ( 'lazy' , $ lazyOptions ) ; $ this -> push ( $ job , $ options ) ; }
2501	private function getFacetParams ( array $ facetBuilders ) { $ facetSets = array_map ( function ( $ facetBuilder ) { return $ this -> facetBuilderVisitor -> visitBuilder ( $ facetBuilder , spl_object_hash ( $ facetBuilder ) ) ; } , $ facetBuilders ) ; $ facetParams = array ( ) ; foreach ( $ facetSets as $ facetSet ) { foreach ( $ facetSet as $ key => $ value ) { if ( isset ( $ facetParams [ $ key ] ) ) { if ( ! is_array ( $ facetParams [ $ key ] ) ) { $ facetParams [ $ key ] = array ( $ facetParams [ $ key ] ) ; } $ facetParams [ $ key ] [ ] = $ value ; } else { $ facetParams [ $ key ] = $ value ; } } } return $ facetParams ; }
7337	public function createClient ( ) : TgLog { $ this -> loop = Factory :: create ( ) ; $ handler = new HttpClientRequestHandler ( $ this -> loop ) ; return new TgLog ( $ this -> token , $ handler ) ; }
3504	private function createByReason ( string $ reason , array $ json ) : SendNotificationException { $ reason = strtolower ( $ reason ) ; switch ( $ reason ) { case 'badcollapseid' : return new BadCollapseIdException ( ) ; case 'baddevicetoken' : return new BadDeviceTokenException ( ) ; case 'badexpirationdate' : return new BadExpirationDateException ( ) ; case 'badmessageid' : return new BadMessageIdException ( ) ; case 'badpriority' : return new BadPriorityException ( ) ; case 'badtopic' : return new BadTopicException ( ) ; case 'devicetokennotfortopic' : return new DeviceTokenNotForTopicException ( ) ; case 'duplicateheaders' : return new DuplicateHeadersException ( ) ; case 'idletimeout' : return new IdleTimeoutException ( ) ; case 'missingdevicetoken' : return new MissingDeviceTokenException ( ) ; case 'missingtopic' : return new MissingTopicException ( ) ; case 'payloadempty' : return new PayloadEmptyException ( ) ; case 'topicdisallowed' : return new TopicDisallowedException ( ) ; case 'badcertificate' : return new BadCertificateException ( ) ; case 'badcertificateenvironment' : return new BadCertificateEnvironmentException ( ) ; case 'expiredprovidertoken' : return new ExpiredProviderTokenException ( ) ; case 'forbidden' : return new ForbiddenException ( ) ; case 'invalidprovidertoken' : return new InvalidProviderTokenException ( ) ; case 'missingprovidertoken' : return new MissingProviderTokenException ( ) ; case 'badpath' : return new BadPathException ( ) ; case 'methodnotallowed' : return new MethodNotAllowedException ( ) ; case 'unregistered' : $ timestamp = array_key_exists ( 'timestamp' , $ json ) ? $ json [ 'timestamp' ] : 0 ; $ lastConfirmed = new \ DateTime ( 'now' , new \ DateTimeZone ( 'UTC' ) ) ; $ lastConfirmed -> setTimestamp ( $ timestamp ) ; return new UnregisteredException ( $ lastConfirmed ) ; case 'payloadtoolarge' : return new PayloadTooLargeException ( ) ; case 'toomanyprovidertokenupdates' : return new TooManyProviderTokenUpdatesException ( ) ; case 'toomanyrequests' : return new TooManyRequestsException ( ) ; case 'internalservererror' : return new InternalServerErrorException ( ) ; case 'serviceunavailable' : return new ServiceUnavailableException ( ) ; case 'shutdown' : return new ShutdownException ( ) ; default : return new UndefinedErrorException ( ) ; } }
2530	protected function makeSoapClientOptions ( ) { $ options = $ this -> soapClientOptions ; $ options [ 'classmap' ] = array_merge ( Classmap :: $ soapheader4map , Classmap :: $ map ) ; if ( ! empty ( $ this -> params -> soapClientOptions ) ) { $ options = array_merge ( $ options , $ this -> params -> soapClientOptions ) ; } return $ options ; }
9327	protected function registerMarkdownEngine ( $ resolver ) { $ app = $ this -> app ; $ app -> singleton ( 'markdown.compiler' , function ( $ app ) { $ cache = $ app [ 'config' ] [ 'view.compiled' ] ; return new MarkdownCompiler ( $ app [ 'files' ] , $ cache ) ; } ) ; $ resolver -> register ( 'markdown' , function ( ) use ( $ app ) { return new MarkdownEngine ( $ app [ 'markdown.compiler' ] , $ app [ 'files' ] ) ; } ) ; $ app [ 'view' ] -> addExtension ( 'md' , 'markdown' ) ; }
5851	protected function addToolbarButtons ( ) { $ buttonBar = $ this -> moduleTemplate -> getDocHeaderComponent ( ) -> getButtonBar ( ) ; $ saveSplitButton = $ buttonBar -> makeSplitButton ( ) ; $ saveButton = $ buttonBar -> makeInputButton ( ) -> setTitle ( htmlspecialchars ( $ this -> languageService -> sL ( 'LLL:EXT:lang/Resources/Private/Language/locallang_core.xlf:rm.saveDoc' ) ) ) -> setName ( '_savedok' ) -> setValue ( '1' ) -> setForm ( 'EditDocumentController' ) -> setIcon ( $ this -> moduleTemplate -> getIconFactory ( ) -> getIcon ( 'actions-document-save' , \ TYPO3 \ CMS \ Core \ Imaging \ Icon :: SIZE_SMALL ) ) ; $ saveSplitButton -> addItem ( $ saveButton , true ) ; $ saveAndCloseButton = $ buttonBar -> makeInputButton ( ) -> setTitle ( htmlspecialchars ( $ this -> languageService -> sL ( 'LLL:EXT:lang/Resources/Private/Language/locallang_core.xlf:rm.saveCloseDoc' ) ) ) -> setName ( '_saveandclosedok' ) -> setValue ( '1' ) -> setForm ( 'EditDocumentController' ) -> setClasses ( 't3js-editform-submitButton' ) -> setIcon ( $ this -> moduleTemplate -> getIconFactory ( ) -> getIcon ( 'actions-document-save-close' , \ TYPO3 \ CMS \ Core \ Imaging \ Icon :: SIZE_SMALL ) ) ; $ saveSplitButton -> addItem ( $ saveAndCloseButton ) ; $ buttonBar -> addButton ( $ saveSplitButton , \ TYPO3 \ CMS \ Backend \ Template \ Components \ ButtonBar :: BUTTON_POSITION_LEFT , 2 ) ; $ closeButton = $ buttonBar -> makeLinkButton ( ) -> setTitle ( htmlspecialchars ( $ this -> languageService -> sL ( 'LLL:EXT:lang/Resources/Private/Language/locallang_core.xlf:rm.closeDoc' ) ) ) -> setHref ( '#' ) -> setClasses ( 't3js-editform-close' ) -> setIcon ( $ this -> moduleTemplate -> getIconFactory ( ) -> getIcon ( 'actions-view-go-back' , \ TYPO3 \ CMS \ Core \ Imaging \ Icon :: SIZE_SMALL ) ) ; $ buttonBar -> addButton ( $ closeButton ) ; }
11279	public static function applyDataToView ( $ view , $ data ) { if ( ! empty ( $ data ) ) { foreach ( $ data as $ name => $ value ) { if ( is_string ( $ value ) ) { $ view = str_replace ( '{' . $ name . '}' , $ value , $ view ) ; } } } return $ view ; }
3813	protected function transformGroupSort ( $ rows ) { foreach ( $ rows as $ row ) { $ this -> groupSort [ ] = new InputScreenGroupingAndSorting ( $ row , $ this ) ; } }
1847	protected function parseArticles ( $ objArticles , $ blnAddArchive = false ) { $ limit = $ objArticles -> count ( ) ; if ( $ limit < 1 ) { return array ( ) ; } $ count = 0 ; $ arrArticles = array ( ) ; while ( $ objArticles -> next ( ) ) { $ objArticle = $ objArticles -> current ( ) ; $ arrArticles [ ] = $ this -> parseArticle ( $ objArticle , $ blnAddArchive , ( ( ++ $ count == 1 ) ? ' first' : '' ) . ( ( $ count == $ limit ) ? ' last' : '' ) . ( ( ( $ count % 2 ) == 0 ) ? ' odd' : ' even' ) , $ count ) ; } return $ arrArticles ; }
821	private function splitUpDocBlock ( $ lines , Tokens $ tokens , $ docBlockIndex ) { $ lineContent = $ this -> getSingleLineDocBlockEntry ( $ lines ) ; $ lineEnd = $ this -> whitespacesConfig -> getLineEnding ( ) ; $ originalIndent = $ this -> detectIndent ( $ tokens , $ tokens -> getNextNonWhitespace ( $ docBlockIndex ) ) ; return [ new Line ( '/**' . $ lineEnd ) , new Line ( $ originalIndent . ' * ' . $ lineContent . $ lineEnd ) , new Line ( $ originalIndent . ' */' ) , ] ; }
12299	public function getPivotFields ( $ obj , $ prop ) { $ reflection = new \ ReflectionClass ( $ obj ) ; $ property = $ reflection -> getProperty ( $ prop ) ; $ property -> setAccessible ( true ) ; $ value = $ property -> getValue ( $ obj ) ; $ property -> setAccessible ( false ) ; return array_diff ( $ value , [ 'deleted_at' , 'created_at' , 'updated_at' ] ) ; }
7630	public function getContainerMetadata ( $ containerName = '' ) { Assertion :: notEmpty ( $ containerName , 'Container name is not specified' ) ; self :: assertValidContainerName ( $ containerName ) ; return $ this -> getContainer ( $ containerName ) -> Metadata ; }
9120	public function registerRouter ( AbstractRouter $ router ) { $ this -> router = $ router ; $ this -> router -> setApplication ( $ this ) ; return $ this ; }
3992	public function decodeValue ( DecodePropertyValueForWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ metaModel = $ this -> getMetaModelFromModel ( $ event -> getModel ( ) ) ; $ values = Helper :: decodeLangArray ( $ event -> getValue ( ) , $ metaModel ) ; $ event -> setValue ( unserialize ( $ values ) ) ; }
4531	public function process ( ContainerBuilder $ container ) { $ definition = $ container -> findDefinition ( LoaderCollection :: class ) ; $ services = $ container -> findTaggedServiceIds ( 'ds_tenant.loader' ) ; $ items = [ ] ; foreach ( $ services as $ id => $ tags ) { foreach ( $ tags as $ tag ) { $ items [ ] = [ 'id' => $ id , 'priority' => array_key_exists ( 'priority' , $ tag ) ? $ tag [ 'priority' ] : 0 , 'alias' => array_key_exists ( 'alias' , $ tag ) ? $ tag [ 'alias' ] : null ] ; } } usort ( $ items , function ( $ a , $ b ) { return $ a [ 'priority' ] === $ b [ 'priority' ] ? 0 : $ a [ 'priority' ] < $ b [ 'priority' ] ? - 1 : 1 ; } ) ; foreach ( $ items as $ item ) { if ( null !== $ item [ 'alias' ] ) { $ definition -> addMethodCall ( 'set' , [ $ item [ 'alias' ] , new Reference ( $ item [ 'id' ] ) ] ) ; } else { $ definition -> addMethodCall ( 'add' , [ new Reference ( $ item [ 'id' ] ) ] ) ; } } }
7361	protected function updateWeightTotal ( SaleInterface $ sale ) { $ weightTotal = $ this -> weightCalculator -> calculateSale ( $ sale ) ; if ( $ sale -> getWeightTotal ( ) != $ weightTotal ) { $ sale -> setWeightTotal ( $ weightTotal ) ; return true ; } return false ; }
9876	public function writeWorkbook ( Spreadsheet $ spreadsheet , $ recalcRequired = false ) { if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' , 'yes' ) ; $ objWriter -> startElement ( 'workbook' ) ; $ objWriter -> writeAttribute ( 'xml:space' , 'preserve' ) ; $ objWriter -> writeAttribute ( 'xmlns' , 'http://schemas.openxmlformats.org/spreadsheetml/2006/main' ) ; $ objWriter -> writeAttribute ( 'xmlns:r' , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships' ) ; $ this -> writeFileVersion ( $ objWriter ) ; $ this -> writeWorkbookPr ( $ objWriter ) ; $ this -> writeWorkbookProtection ( $ objWriter , $ spreadsheet ) ; if ( $ this -> getParentWriter ( ) -> getOffice2003Compatibility ( ) === false ) { $ this -> writeBookViews ( $ objWriter , $ spreadsheet ) ; } $ this -> writeSheets ( $ objWriter , $ spreadsheet ) ; $ this -> writeDefinedNames ( $ objWriter , $ spreadsheet ) ; $ this -> writeCalcPr ( $ objWriter , $ recalcRequired ) ; $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
5096	public function queryExists ( ) { foreach ( $ this -> selects as $ select ) { $ result = $ select -> queryExists ( ) ; if ( is_null ( $ result ) || $ result ) { return $ result ; } } return false ; }
9408	protected function resolve ( $ index ) { $ callback = null ; $ stack = $ this -> stack ; if ( isset ( $ this -> stack [ $ index ] ) ) { $ item = $ stack [ $ index ] ; $ next = $ this -> resolve ( $ index + 1 ) ; $ callback = function ( $ request ) use ( $ item , $ next ) { return $ item -> process ( $ request , $ next ) ; } ; } return new Delegate ( $ callback ) ; }
9909	public function setPositionXL ( $ positionXL ) { if ( ! isset ( self :: $ positionXLref [ $ positionXL ] ) ) { return false ; } $ this -> position = self :: $ positionXLref [ $ positionXL ] ; return true ; }
10065	public function setPieces ( $ pieces ) { if ( $ pieces && ! $ pieces instanceof PieceBag ) { $ pieces = new PieceBag ( is_array ( $ pieces ) ? $ pieces : [ ] ) ; } return $ this -> setParameter ( 'pieces' , $ pieces ) ; }
12186	public function getCompanionNiceId ( $ queryRole ) { $ companionRoleType = $ this -> companionRoleType ( $ queryRole ) ; if ( empty ( $ companionRoleType ) ) { return false ; } return implode ( ':' , [ $ this -> companionRole ( $ queryRole ) , $ companionRoleType -> systemId ] ) ; }
7078	static public function isSaleSupportsDocumentType ( SaleInterface $ sale , $ type ) { if ( ! DocumentTypes :: isValidType ( $ type ) ) { return false ; } if ( empty ( $ classes = DocumentTypes :: getClasses ( $ type ) ) ) { return false ; } foreach ( $ classes as $ class ) { if ( is_subclass_of ( $ sale , $ class ) ) { return true ; } } return false ; }
9151	public function getSelectOptions ( ) { $ filter = new UnderscoreToCamelCase ( ) ; $ funcName = "get" . ucfirst ( $ filter -> filter ( $ this -> getUserColumn ( ) ) ) ; $ resultSet = $ this -> fetchAll ( array ( 'user_id' , $ this -> getUserColumn ( ) ) , function ( Select $ select ) { $ select -> where -> notEqualTo ( 'user_id' , $ this -> getCurrentUser ( ) -> getId ( ) ) ; } ) ; $ options = array ( ) ; foreach ( $ resultSet as $ user ) { $ options [ $ user -> getId ( ) ] = $ user -> $ funcName ( ) ; } return $ options ; }
11194	protected function fixTree ( array $ data ) { $ result = [ ] ; foreach ( $ data as $ k => $ v ) { $ res = & $ this -> searchNode ( $ k , $ result ) ; if ( is_array ( $ v ) && is_array ( $ res ) ) { $ res = array_replace_recursive ( $ res , $ this -> fixTree ( $ v ) ) ; } else { $ res = $ v ; } } return $ result ; }
4601	public function kernelRequest ( GetResponseEvent $ event ) { $ request = $ event -> getRequest ( ) ; if ( ! $ request -> isMethod ( Request :: METHOD_PUT ) ) { return ; } if ( ! $ request -> attributes -> has ( 'data' ) ) { return ; } $ data = $ request -> attributes -> get ( 'data' ) ; if ( ! $ data instanceof Access ) { return ; } $ access = $ data ; $ manager = $ this -> accessService -> getManager ( ) ; foreach ( $ access -> getPermissions ( ) as $ permission ) { $ manager -> remove ( $ permission ) ; } $ manager -> flush ( ) ; }
12616	public function setAttributes ( array $ attributes ) { foreach ( $ attributes as $ key => $ attribute ) { if ( ! ( $ attribute instanceof AttributeInterface ) ) { if ( is_array ( $ attribute ) ) { $ attr = new AttributeCollection ( $ key ) ; $ attr -> setAttributes ( $ attribute ) ; $ attribute = $ attr ; } else { $ attribute = new Attribute ( $ key , $ attribute ) ; } } $ this -> attributes [ $ attribute -> getName ( ) ] = $ attribute ; } }
7069	static function isValid ( $ unit , $ throw = false ) { if ( in_array ( $ unit , static :: getUnits ( ) , true ) ) { return true ; } if ( $ throw ) { throw new InvalidArgumentException ( "Invalid unit '$unit'." ) ; } return false ; }
3399	public function get ( $ arguments = [ ] ) { try { $ this -> makeRequest ( $ arguments ) ; } catch ( ConnectException $ e ) { $ url = $ e -> getRequest ( ) -> getUrl ( ) ; return $ this -> errorResponse ( $ e -> getCode ( ) , $ e -> getMessage ( ) , $ url ) ; } catch ( RequestException $ e ) { $ url = $ e -> getRequest ( ) -> getUrl ( ) ; $ status = $ e -> getCode ( ) ; $ response = $ e -> getResponse ( ) ; $ reason = $ e -> getMessage ( ) ; if ( ! is_null ( $ response ) ) { $ reason = $ response -> getReasonPhrase ( ) ; } return $ this -> errorResponse ( $ status , $ reason , $ url ) ; } return $ this -> parseBlueprint ( $ this -> schemaBlueprint ) ; }
3914	protected function sortByName ( $ blnAscending = true ) { $ arrFiles = $ this -> foundFiles ; if ( ! $ arrFiles ) { return array ( 'files' => array ( ) , 'source' => array ( ) ) ; } \ uasort ( $ arrFiles , ( $ blnAscending ) ? '\basename_natcasecmp' : '\basename_natcasercmp' ) ; return $ this -> remapSorting ( $ arrFiles , $ this -> outputBuffer ) ; }
9394	public function execute ( ) { if ( $ this -> escape !== false ) { $ this -> options = $ this -> escape ( $ this -> options ) ; } if ( $ this -> builder !== null ) { $ command = $ this -> builder -> build ( $ this -> options ) ; exec ( $ command ) ; } }
8100	protected function validate ( $ name , $ limit , $ regEx = false ) { $ Name = ucfirst ( $ name ) ; $ value = $ this -> _updates -> $ name ; $ length = explode ( '-' , $ limit ) ; $ min = intval ( $ length [ 0 ] ) ; $ max = intval ( $ length [ 1 ] ) ; if ( ! $ max and ! $ min ) { $ this -> log -> error ( "Invalid second parameter for the $name validation" ) ; return false ; } if ( ! $ value ) { if ( is_null ( $ value ) ) { $ this -> log -> report ( "Missing index $name from the input" ) ; } if ( strlen ( $ value ) == $ min ) { $ this -> log -> report ( "$Name is blank and optional - skipped" ) ; return true ; } $ this -> log -> formError ( $ name , "$Name is required." ) ; return false ; } if ( strlen ( $ value ) > $ max ) { $ this -> log -> formError ( $ name , "The $Name is larger than $max characters." ) ; return false ; } if ( strlen ( $ value ) < $ min ) { $ this -> log -> formError ( $ name , "The $Name is too short. It should at least be $min characters long" ) ; return false ; } if ( $ regEx ) { preg_match ( $ regEx , $ value , $ match ) ; if ( preg_match ( $ regEx , $ value , $ match ) === 0 ) { $ this -> log -> formError ( $ name , "The $Name \"{$value}\" is not valid" ) ; return false ; } } $ this -> log -> report ( "The $name is Valid" ) ; return true ; }
5015	public function logFinish ( FinishEvent $ event ) : void { $ this -> getLogger ( ) -> info ( sprintf ( $ this -> tmpl [ 'queue' ] , 'Stop' , $ event -> getQueue ( ) -> getName ( ) ) ) ; $ this -> injectLoggerInEvent ( $ event ) ; }
601	public function orOnCondition ( $ condition , $ params = [ ] ) { if ( $ this -> on === null ) { $ this -> on = $ condition ; } else { $ this -> on = [ 'or' , $ this -> on , $ condition ] ; } $ this -> addParams ( $ params ) ; return $ this ; }
3268	protected function closeFile ( SplFileObject & $ file ) { if ( ! $ this -> getConfig ( ) -> useGzip ( ) && ! $ file -> flock ( LOCK_UN ) ) { $ file = null ; throw new Exception ( 'Could not unlock file' ) ; } $ file = null ; }
6903	public function render ( $ block = null ) { if ( $ this -> auto_hide === true AND $ this -> total_pages <= 1 ) return '' ; if ( $ block === null ) { $ block = $ this -> block ; } if ( ! $ block instanceof Block ) { $ block = block ( $ block ) ; } return $ block -> set ( get_object_vars ( $ this ) ) -> set ( 'page' , $ this ) -> render ( ) ; }
2182	public function listImageSizeItem ( $ row ) { $ html = '<div class="tl_content_left">' ; $ html .= $ row [ 'media' ] ; if ( $ row [ 'width' ] || $ row [ 'height' ] ) { $ html .= ' <span style="padding-left:3px">' . $ row [ 'width' ] . 'x' . $ row [ 'height' ] . '</span>' ; } if ( $ row [ 'zoom' ] ) { $ html .= ' <span style="color:#999;padding-left:3px">(' . $ row [ 'zoom' ] . '%)</span>' ; } $ html .= "</div>\n" ; return $ html ; }
8438	public function setPostLink ( TimelineLinkEvent $ event ) : void { $ action = $ event -> getAction ( ) ; if ( ! in_array ( $ action -> getVerb ( ) , [ 'post' , 'reply' ] ) ) { return ; } $ production = $ action -> getComponent ( 'indirectComplement' ) -> getData ( ) ; $ post = $ action -> getComponent ( 'directComplement' ) -> getData ( ) ; $ event -> setLink ( $ this -> url_generator -> generate ( 'bkstg_board_show' , [ 'production_slug' => $ production -> getSlug ( ) , '_fragment' => 'post-' . $ post -> getId ( ) , ] ) ) ; }
3581	protected function pluckMeta ( Builder $ query , ArgumentBag $ args , $ alias ) { list ( $ column , $ key ) = [ $ args -> get ( 'column' ) , $ args -> get ( 'key' ) ] ; $ query -> select ( "{$alias}.meta_value as {$column}" ) ; if ( ! is_null ( $ key ) ) { $ this -> metaSelectListsKey ( $ query , $ key ) ; } return $ query -> callParent ( 'pluck' , $ args -> all ( ) ) ; }
3618	public function setFanModeOnWithTimer ( $ mode , $ serial_number = NULL ) { $ modes = explode ( ',' , $ mode ) ; $ mode = $ modes [ 0 ] ; $ timer = ( int ) $ modes [ 1 ] ; return $ this -> _setFanMode ( $ mode , NULL , $ timer , $ serial_number ) ; }
5157	public function executeFor ( Route $ route ) : bool { if ( null === $ this -> pathConstraint ) { return true ; } return strpos ( $ route -> getPath ( ) , $ this -> pathConstraint ) === 0 ; }
8023	public function synchronize ( \ Closure $ closure ) { $ this -> acquire ( ) ; call_user_func ( $ closure ) ; $ this -> release ( ) ; return $ this ; }
5613	public function paintFail ( $ message ) { parent :: paintFail ( $ message ) ; $ node = new TreemapNode ( 'Assertion' , $ message , false ) ; $ current = $ this -> _stack -> peek ( ) ; $ current -> putChild ( $ node ) ; $ current -> fail ( ) ; }
7033	protected function lastMigration ( ) { try { $ migration = Db :: query ( "select * from migrations order by created_at desc limit 1" , [ ] , $ this -> dbName ) ; return $ migration [ 0 ] ; } catch ( PDOException $ e ) { if ( $ e -> getCode ( ) === "42S02" ) return null ; } return false ; }
11249	public function log ( string $ file , int $ batch ) : void { $ stmt = $ this -> pdo -> prepare ( "insert into {$this->table} (migration, batch) values (?, ?)" ) ; $ stmt -> bindParam ( 1 , $ file ) ; $ stmt -> bindParam ( 2 , $ batch , PDO :: PARAM_INT ) ; $ stmt -> execute ( ) ; }
3928	private function getOptionsViaDcGeneral ( $ metaModel , $ environment , $ attribute ) { $ factory = DcGeneralFactory :: deriveEmptyFromEnvironment ( $ environment ) -> setContainerName ( $ metaModel -> getTableName ( ) ) ; $ dcGeneral = $ factory -> createDcGeneral ( ) ; $ subEnv = $ dcGeneral -> getEnvironment ( ) ; $ optEv = new GetPropertyOptionsEvent ( $ subEnv , $ subEnv -> getDataProvider ( ) -> getEmptyModel ( ) ) ; $ optEv -> setPropertyName ( $ attribute -> getColName ( ) ) ; $ subEnv -> getEventDispatcher ( ) -> dispatch ( GetPropertyOptionsEvent :: NAME , $ optEv ) ; $ options = $ optEv -> getOptions ( ) ; return $ options ; }
9995	private function writeComment ( Worksheet $ pSheet , $ coordinate ) { $ result = '' ; if ( ! $ this -> isPdf && isset ( $ pSheet -> getComments ( ) [ $ coordinate ] ) ) { $ result .= '<a class="comment-indicator"></a>' ; $ result .= '<div class="comment">' . nl2br ( $ pSheet -> getComment ( $ coordinate ) -> getText ( ) -> getPlainText ( ) ) . '</div>' ; $ result .= PHP_EOL ; } return $ result ; }
10581	public function handleRequest ( ServerRequestInterface $ serverRequest , ResponseInterface $ response ) : ResponseInterface { $ response = $ response -> withProtocolVersion ( $ serverRequest -> getProtocolVersion ( ) ) ; try { try { $ APIRequest = $ this -> requestFactory -> create ( $ serverRequest ) ; } catch ( UnableToCreateRequestException $ exception ) { return $ this -> handleRequestFactoryException ( $ exception , $ response ) ; } try { $ APIResponse = $ this -> server -> handleRequest ( $ APIRequest ) ; } catch ( UnableToHandleRequestException $ exception ) { return $ this -> handleServerException ( $ exception , $ response ) ; } return $ this -> buildResponse ( $ APIResponse , $ response ) ; } catch ( \ Throwable $ e ) { $ this -> logCaughtThrowableResultingInHTTPCode ( 500 , $ e , LogLevel :: CRITICAL ) ; return $ response -> withStatus ( 500 , "Internal Server Error" ) ; } }
12400	public function first ( ) { $ this -> scope -> limit = 1 ; $ this -> scope -> offset = 0 ; return $ this -> get ( null ) ; }
9758	function closeTo ( $ value , float $ delta ) : self { return $ this -> expect ( $ this -> target , equalTo ( $ value , $ delta ) ) ; }
7122	protected function detectAndApplyLanguage ( ) { if ( $ this -> config ( 'autodetect' , true ) ) { $ detector = $ this -> getLanguageDetector ( ) ; $ language = $ detector -> getLanguageFromCookie ( ) ; if ( ! $ language || strlen ( $ language ) > 5 || ! in_array ( $ language , $ this -> getSupportedLanguages ( ) , true ) ) { $ language = $ detector -> getDriver ( ) -> detect ( ) ; if ( ! $ language || strlen ( $ language ) > 5 ) { $ language = $ this -> request -> getDefaultLocale ( ) ; } } $ this -> applyNewLanguage ( $ language , true ) ; } }
6273	public static function haveExtension ( ) { if ( ! function_exists ( 'dba_handlers' ) ) { return false ; } $ handlers = dba_handlers ( ) ; if ( ! in_array ( 'cdb' , $ handlers ) || ! in_array ( 'cdb_make' , $ handlers ) ) { return false ; } return true ; }
5236	public function get ( $ name = null ) { $ constructor = $ this -> class -> getConstructor ( ) ; if ( null === $ constructor || $ this -> class -> isInternal ( ) ) { return $ this -> class -> newInstance ( ) ; } $ params = $ this -> injectionValuesForMethod ( $ constructor ) ; if ( count ( $ params ) === 0 ) { return $ this -> class -> newInstance ( ) ; } return $ this -> class -> newInstanceArgs ( $ params ) ; }
12956	public function remove ( $ id ) { if ( ! $ this -> has ( $ id ) ) { throw new NotFoundException ( sprintf ( '%s not found in %s' , $ id , __CLASS__ ) ) ; } unset ( $ this -> objects [ $ id ] ) ; }
1017	public static function getAllBuiltInTypes ( ) { if ( self :: $ builtInTypes === null ) { self :: $ builtInTypes = array_merge ( Introspection :: getTypes ( ) , self :: getStandardTypes ( ) ) ; } return self :: $ builtInTypes ; }
4374	protected function buildChannelTree ( ) { if ( $ this -> channels == array ( $ this -> channelNameRoot ) ) { return array ( ) ; } \ sort ( $ this -> channels ) ; $ rootKey = \ array_search ( $ this -> channelNameRoot , $ this -> channels ) ; if ( $ rootKey !== false ) { unset ( $ this -> channels [ $ rootKey ] ) ; \ array_unshift ( $ this -> channels , $ this -> channelName ) ; } $ tree = array ( ) ; foreach ( $ this -> channels as $ channel ) { $ ref = & $ tree ; $ path = \ explode ( '.' , $ channel ) ; foreach ( $ path as $ k ) { if ( ! isset ( $ ref [ $ k ] ) ) { $ ref [ $ k ] = array ( ) ; } $ ref = & $ ref [ $ k ] ; } } return $ tree ; }
12938	public function setMin ( $ value ) { $ this -> setTag ( 'min' , $ value ) ; if ( $ this -> getValidator ( ) ) { $ this -> getValidator ( ) -> setOption ( 'min' , $ value ) ; } }
2471	public function findContent ( Query $ query , array $ languageFilter = array ( ) ) { $ query = clone $ query ; $ query -> filter = $ query -> filter ? : new Criterion \ MatchAll ( ) ; $ query -> query = $ query -> query ? : new Criterion \ MatchAll ( ) ; $ this -> coreFilter -> apply ( $ query , $ languageFilter , DocumentMapper :: DOCUMENT_TYPE_IDENTIFIER_CONTENT ) ; return $ this -> resultExtractor -> extract ( $ this -> gateway -> findContent ( $ query , $ languageFilter ) , $ query -> facetBuilders ) ; }
1970	public static function findByUuid ( $ strUuid , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; if ( Validator :: isStringUuid ( $ strUuid ) ) { $ strUuid = StringUtil :: uuidToBin ( $ strUuid ) ; } if ( empty ( $ arrOptions ) ) { $ objModel = Registry :: getInstance ( ) -> fetch ( static :: $ strTable , $ strUuid , 'uuid' ) ; if ( $ objModel !== null ) { return $ objModel ; } } return static :: findOneBy ( array ( "$t.uuid=UNHEX(?)" ) , bin2hex ( $ strUuid ) , $ arrOptions ) ; }
7355	public static function isValidSize ( $ size , $ throw = false ) { if ( in_array ( $ size , static :: getSizes ( ) , true ) ) { return true ; } if ( $ throw ) { throw new InvalidArgumentException ( "Unknown size '$size'." ) ; } return false ; }
9633	public function onBeforeWrite ( ) { $ return = parent :: onBeforeWrite ( ) ; $ exists = self :: get ( ) -> filter ( 'Name' , $ this -> Name ) -> exclude ( 'ID' , $ this -> ID ) ; if ( $ exists -> count ( ) ) { throw new ValidationException ( _t ( 'Moo_EditableField.UNIQUENAME' , 'Field name "{name}" must be unique' , '' , [ 'name' => $ this -> Name ] ) ) ; } $ this -> Name = preg_replace ( '/[^a-zA-Z0-9_]+/' , '' , $ this -> Name ) ; $ customSettings = $ this -> getSettings ( ) ; if ( empty ( $ customSettings ) ) { $ customSettings = ( array ) Controller :: curr ( ) -> getRequest ( ) -> postVar ( 'CustomSettings' ) ; } if ( ! empty ( $ this -> customSettingsFields ) ) { $ customSettings = array_intersect_key ( $ customSettings , array_flip ( ( array ) $ this -> customSettingsFields ) ) ; } $ this -> setSettings ( $ customSettings ) ; return $ return ; }
9713	private function writeExternalsheetBiff8 ( ) { $ totalReferences = count ( $ this -> parser -> references ) ; $ record = 0x0017 ; $ length = 2 + 6 * $ totalReferences ; $ supbook_index = 0 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ totalReferences ) ; for ( $ i = 0 ; $ i < $ totalReferences ; ++ $ i ) { $ data .= $ this -> parser -> references [ $ i ] ; } return $ this -> writeData ( $ header . $ data ) ; }
6288	private function buildResponse ( ReactResponse $ response , StreamInterface $ body ) { $ body -> rewind ( ) ; return $ this -> responseFactory -> createResponse ( $ response -> getCode ( ) , $ response -> getReasonPhrase ( ) , $ response -> getHeaders ( ) , $ body , $ response -> getVersion ( ) ) ; }
10340	public static function checkErrorCode ( $ pValue ) { $ pValue = ( string ) $ pValue ; if ( ! isset ( self :: $ errorCodes [ $ pValue ] ) ) { $ pValue = '#NULL!' ; } return $ pValue ; }
2848	public function setModuleStatus ( $ moduleName , $ isActive ) { $ moduleConfigFile = $ this -> getModuleConfigFilePath ( $ moduleName ) ; $ configXml = $ this -> loadXmlFile ( $ moduleConfigFile ) ; if ( $ configXml === false ) { throw new Exception ( "Unable to parse module configuration file {$moduleConfigFile}" ) ; } $ configXml -> modules -> { $ moduleName } -> active = $ isActive ? 'true' : 'false' ; if ( $ this -> saveXml ( $ configXml , $ moduleConfigFile ) === false ) { throw new Exception ( "Unable to save module configuration file {$moduleConfigFile}. Check to see if web server user has write permissions." ) ; } }
7075	private function addItemDetails ( array & $ details , Model \ SaleItemInterface $ item ) { $ total = 0 ; if ( ! ( $ item -> isCompound ( ) && ! $ item -> hasPrivateChildren ( ) ) ) { $ itemResult = $ item -> getResult ( ) ; $ details [ 'L_PAYMENTREQUEST_0_NAME' . $ this -> line ] = $ item -> getTotalQuantity ( ) . 'x ' . $ item -> getDesignation ( ) ; $ details [ 'L_PAYMENTREQUEST_0_NUMBER' . $ this -> line ] = $ item -> getReference ( ) ; if ( ! empty ( $ description = $ item -> getDescription ( ) ) ) { $ details [ 'L_PAYMENTREQUEST_0_DESC' . $ this -> line ] = $ description ; } $ details [ 'L_PAYMENTREQUEST_0_AMT' . $ this -> line ] = $ this -> format ( $ itemResult -> getTotal ( ) ) ; $ total = $ itemResult -> getTotal ( ) ; $ this -> line ++ ; } foreach ( $ item -> getChildren ( ) as $ child ) { $ total += $ this -> addItemDetails ( $ details , $ child ) ; } return $ total ; }
10082	protected function registerConfigurator ( ) { $ this -> app -> singleton ( 'auja.database' , function ( $ app ) { $ config = $ app [ 'config' ] [ 'auja-laravel' ] ? : $ app [ 'config' ] [ 'auja-laravel::config' ] ; switch ( $ config [ 'database' ] ) { case 'mysql' : return new MySQLDatabaseHelper ( ) ; break ; default : throw new NoDatabaseHelperException ( 'No Auja database helper for ' . $ config [ 'database' ] ) ; break ; } } ) ; $ this -> app -> bind ( 'Label305\AujaLaravel\Database\DatabaseHelper' , 'auja.database' ) ; $ this -> app -> singleton ( 'auja.configurator' , function ( $ app ) { return new AujaConfigurator ( $ app , $ app [ 'auja.database' ] ) ; } ) ; $ this -> app -> bind ( 'Label305\AujaLaravel\Config\AujaConfigurator' , 'auja.configurator' ) ; }
10686	private function showPermissionError ( PermissionError $ e ) { if ( PHP_SAPI !== "cli" ) { http_response_code ( 500 ) ; header ( "Content-type: text/plain" ) ; } if ( $ this -> dev ) { $ file = $ e -> path ; echo "{$e->getMessage()}\n" ; echo "\n" ; echo WF :: str ( $ e , false ) ; } else { echo "A permission error is preventing this page from displaying properly." ; } die ( ) ; }
6046	protected function registerPlugin ( $ name ) { $ view = $ this -> getView ( ) ; AdminUiAsset :: register ( $ view ) ; $ id = $ this -> options [ 'id' ] ; if ( $ this -> clientOptions !== false ) { $ options = empty ( $ this -> clientOptions ) ? '' : Json :: encode ( $ this -> clientOptions ) ; $ js = "jQuery('#$id').$name($options);" ; $ view -> registerJs ( $ js ) ; } if ( ! empty ( $ this -> clientEvents ) ) { $ js = [ ] ; foreach ( $ this -> clientEvents as $ event => $ handler ) { $ js [ ] = "jQuery('#$id').on('$event', $handler);" ; } $ view -> registerJs ( implode ( "\n" , $ js ) ) ; } }
10928	public function executeInstruction ( string $ strSQL , ? array $ parans = null ) : bool { $ this -> dbPreparedStatment = $ this -> dbConnection -> prepare ( $ strSQL ) ; $ this -> pdoLastError = null ; if ( $ parans !== null ) { foreach ( $ parans as $ key => $ value ) { $ val = $ value ; if ( is_bool ( $ value ) === true ) { if ( $ value === true ) { $ val = 1 ; } else { $ val = 0 ; } } else if ( is_a ( $ value , "\DateTime" ) === true ) { $ val = $ value -> format ( "Y-m-d H:i:s" ) ; } $ this -> dbPreparedStatment -> bindValue ( ":" . $ key , $ val ) ; } } try { $ this -> dbPreparedStatment -> execute ( ) ; } catch ( \ Exception $ ex ) { $ this -> pdoLastError = $ ex -> getMessage ( ) ; } return $ this -> isExecuted ( ) ; }
10116	private function writeHcenter ( ) { $ record = 0x0083 ; $ length = 0x0002 ; $ fHCenter = $ this -> phpSheet -> getPageSetup ( ) -> getHorizontalCentered ( ) ? 1 : 0 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ fHCenter ) ; $ this -> append ( $ header . $ data ) ; }
10072	function fromXML ( $ xmlElement ) { $ this -> id = $ xmlElement -> id ; $ this -> name = $ xmlElement -> name ; $ this -> author = $ xmlElement -> author ; $ this -> state = $ xmlElement -> state ; $ this -> type = $ xmlElement -> type ; $ this -> contactFilterName = $ xmlElement -> contact_filter_name ; $ this -> contactFilterId = $ xmlElement -> contact_filter_id ; $ this -> evaluated = $ xmlElement -> evaluated ; $ this -> created = $ xmlElement -> created ; $ this -> updated = $ xmlElement -> updated ; $ this -> countActiveContacts = $ xmlElement -> count_active_contacts ; $ this -> countContacts = $ xmlElement -> count_contacts ; }
3329	public function status ( $ token ) { $ data = array ( 'token' => $ token , ) ; $ ch = $ this -> __initRequest ( 'from_url/status' , $ data ) ; $ this -> __setHeaders ( $ ch ) ; $ data = $ this -> __runRequest ( $ ch ) ; return $ data ; }
11303	protected static function checkPath ( $ path ) { if ( ! file_exists ( $ path ) ) { throw new NotFoundException ( Message :: get ( Message :: MSG_PATH_NOTFOUND , $ path ) , Message :: MSG_PATH_NOTFOUND ) ; } if ( ! is_readable ( $ path ) ) { throw new RuntimeException ( Message :: get ( Message :: MSG_PATH_NONREADABLE , $ path ) , Message :: MSG_PATH_NONREADABLE ) ; } }
10501	public function autoComplete ( $ data ) { static $ counter = 0 ; $ this -> inputOptions [ 'class' ] .= ' typeahead typeahead-' . ( ++ $ counter ) ; foreach ( $ data as & $ item ) { $ item = [ 'word' => $ item ] ; } $ this -> form -> getView ( ) -> registerJs ( "yii.gii.autocomplete($counter, " . Json :: htmlEncode ( $ data ) . ");" ) ; return $ this ; }
11776	public function getHelper ( ) { if ( $ this -> helper === null ) { $ this -> helper = $ this -> command -> getHelper ( 'question' ) ; } return $ this -> helper ; }
6006	public function toUnicode ( ) { $ h = ord ( $ this -> char { 0 } ) ; if ( $ h <= 0x7F ) { return $ h ; } else { if ( $ h < 0xC2 ) { return false ; } else { if ( $ h <= 0xDF ) { return ( $ h & 0x1F ) << 6 | ( ord ( $ this -> char { 1 } ) & 0x3F ) ; } else { if ( $ h <= 0xEF ) { return ( $ h & 0x0F ) << 12 | ( ord ( $ this -> char { 1 } ) & 0x3F ) << 6 | ( ord ( $ this -> char { 2 } ) & 0x3F ) ; } else { if ( $ h <= 0xF4 ) { return ( $ h & 0x0F ) << 18 | ( ord ( $ this -> char { 1 } ) & 0x3F ) << 12 | ( ord ( $ this -> char { 2 } ) & 0x3F ) << 6 | ( ord ( $ this -> char { 3 } ) & 0x3F ) ; } else { return false ; } } } } } }
12209	private function getAccSys ( $ assetTypeCode ) { $ req = new \ Praxigento \ Accounting \ Api \ Service \ Account \ Get \ Request ( ) ; $ req -> setIsSystem ( TRUE ) ; $ req -> setAssetTypeCode ( $ assetTypeCode ) ; $ resp = $ this -> servAccount -> exec ( $ req ) ; $ result = $ resp -> getId ( ) ; return $ result ; }
4056	private function convertLegend ( array $ property , bool $ trans , $ condition , array & $ legend , array & $ result ) { if ( ! empty ( $ legend [ 'properties' ] ) ) { $ result [ 'legend' . ( \ count ( $ result ) + 1 ) ] = $ legend ; } $ legend = [ 'label' => $ trans ? unserialize ( $ property [ 'legendtitle' ] , [ 'allowed_classes' => false ] ) : [ '' => $ property [ 'legendtitle' ] ] , 'hide' => ( bool ) $ property [ 'legendhide' ] , 'properties' => [ ] , 'condition' => $ condition ( $ property ) ] ; }
2851	public function searchConfig ( $ query ) { $ configArray = array ( ) ; $ configArray = Mage :: helper ( 'sheep_debug' ) -> xml2array ( $ this -> getConfig ( ) -> getNode ( ) , $ configArray ) ; $ results = array ( ) ; $ configKeys = array_keys ( $ configArray ) ; foreach ( $ configKeys as $ configKey ) { if ( strpos ( $ configKey , $ query ) !== FALSE ) { $ results [ $ configKey ] = $ configArray [ $ configKey ] ; } } return $ results ; }
2407	public static function generateScriptTag ( $ src , $ async = false , $ mtime = false , $ hash = null , $ crossorigin = null ) { if ( $ mtime === null && ! preg_match ( '@^https?://@' , $ src ) ) { $ container = System :: getContainer ( ) ; $ rootDir = $ container -> getParameter ( 'kernel.project_dir' ) ; if ( file_exists ( $ rootDir . '/' . $ src ) ) { $ mtime = filemtime ( $ rootDir . '/' . $ src ) ; } else { $ webDir = StringUtil :: stripRootDir ( $ container -> getParameter ( 'contao.web_dir' ) ) ; if ( file_exists ( $ rootDir . '/' . $ webDir . '/' . $ src ) ) { $ mtime = filemtime ( $ rootDir . '/' . $ webDir . '/' . $ src ) ; } } } if ( $ mtime ) { $ src .= '?v=' . substr ( md5 ( $ mtime ) , 0 , 8 ) ; } return '<script src="' . $ src . '"' . ( $ async ? ' async' : '' ) . ( $ hash ? ' integrity="' . $ hash . '"' : '' ) . ( $ crossorigin ? ' crossorigin="' . $ crossorigin . '"' : '' ) . '></script>' ; }
12280	protected function initTemplateAssetsManager ( ) { $ templateAssetsManager = $ this -> options [ "template_assets" ] ; $ pluginManager = $ this -> options [ "plugin_manager" ] ; $ templateAssetsManager -> backend ( ) -> add ( $ pluginManager -> getAssets ( ) ) ; return $ templateAssetsManager ; }
6743	public function supports ( ParamConverter $ configuration ) { return $ configuration -> getClass ( ) && is_a ( $ configuration -> getClass ( ) , $ this -> getClass ( ) , true ) ; }
10078	public static function convertEncoding ( $ value , $ to , $ from ) { if ( self :: getIsIconvEnabled ( ) ) { $ result = iconv ( $ from , $ to . '//IGNORE//TRANSLIT' , $ value ) ; if ( false !== $ result ) { return $ result ; } } return mb_convert_encoding ( $ value , $ to , $ from ) ; }
8865	public function run ( PayloadInterface $ payload ) { $ tasks = $ this -> getTaskCollection ( ) -> getTasks ( ) ; $ tasksCount = $ tasks -> count ( ) ; if ( 0 === $ tasksCount ) { throw new LogicException ( 'Can\'t invoke task run. Empty task collection set.' ) ; } $ this -> log ( LogLevel :: INFO , sprintf ( 'Starting runner with %s tasks ready for execution.' , $ tasksCount ) ) ; $ this -> dispatch ( 'runner.start' , null , $ payload ) ; foreach ( $ tasks as $ task ) { try { $ task -> setPayload ( $ payload ) ; $ this -> runTask ( $ task , $ payload ) ; } catch ( \ Exception $ e ) { $ this -> logTask ( $ task , LogLevel :: ERROR , sprintf ( 'An exception was thrown. Message: %s' , $ e -> getMessage ( ) ) ) ; $ this -> dispatch ( 'runner.failure' , null , null , null , $ e ) ; throw new RunFailedException ( 'Complete run failed: ' . $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } } $ this -> log ( LogLevel :: INFO , 'All tasks were processed.' ) ; $ this -> log ( LogLevel :: INFO , 'Calling attached runners.' ) ; $ this -> notify ( $ payload ) ; $ this -> log ( LogLevel :: INFO , 'Execution successful.' ) ; $ this -> dispatch ( 'runner.success' , null , $ payload ) ; return $ payload ; }
5523	public function generateSubclass ( $ methods ) { if ( ! $ this -> reflection -> classOrInterfaceExists ( ) ) { return false ; } $ mock_class = "" ; if ( ! empty ( $ this -> namespace ) ) { $ mock_class .= $ this -> namespace . '\\' ; } $ mock_class .= $ this -> mock_class ; $ mock_reflection = new SimpleReflection ( $ mock_class ) ; if ( $ mock_reflection -> classExistsWithoutAutoload ( ) ) { return false ; } if ( $ this -> reflection -> isInterface ( ) || $ this -> reflection -> hasFinal ( ) ) { $ code = $ this -> createCodeForClass ( $ methods ? $ methods : array ( ) ) ; return eval ( "$code return \$code;" ) ; } else { $ code = $ this -> createCodeForSubclass ( $ methods ? $ methods : array ( ) ) ; return eval ( "$code return \$code;" ) ; } }
4732	protected function set_expiration ( ) { $ this -> exp_variant = time ( ) + ( int ) apply_filters ( 'wp_session_expiration_variant' , 24 * 60 ) ; $ this -> expires = time ( ) + ( int ) apply_filters ( 'wp_session_expiration' , 30 * 60 ) ; }
2327	public function setRow ( array $ arrData ) { if ( $ this -> intIndex < 0 ) { $ this -> first ( ) ; } $ this -> arrModels [ $ this -> intIndex ] -> setRow ( $ arrData ) ; return $ this ; }
4074	protected function resolve ( ) { $ factory = $ this -> container -> getFactory ( ) ; $ names = $ factory -> collectNames ( ) ; foreach ( $ names as $ name ) { $ this -> information [ $ name ] = array ( self :: COMBINATION => null , self :: INPUTSCREEN => null , self :: RENDERSETTING => null , self :: MODELID => null , ) ; } $ found = $ this -> getPaletteCombinationRows ( ) ; if ( ! $ found ) { $ found = array ( ) ; } foreach ( array_keys ( $ this -> information ) as $ tableName ) { if ( empty ( $ this -> information [ $ tableName ] [ self :: COMBINATION ] ) || empty ( $ this -> information [ $ tableName ] [ self :: COMBINATION ] [ 'dca_id' ] ) || empty ( $ this -> information [ $ tableName ] [ self :: COMBINATION ] [ 'view_id' ] ) ) { unset ( $ this -> information [ $ tableName ] ) ; } } $ this -> fetchInputScreenDetails ( ) ; }
11456	public function batchDeviceSummary ( $ timestamp , $ pageIndex ) { $ params = [ 'date' => $ timestamp , 'page_index' => $ pageIndex , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_DEVICE_LIST , $ params ] ) ; }
12114	protected function loadForeignDataItems ( ) { $ this -> _foreignDataItems = [ ] ; if ( $ this -> lazyForeign ) { $ primaryKeys = $ this -> foreignModel -> findPrimaryKeys ( $ this -> settings [ 'foreignPullParams' ] ) ; foreach ( $ primaryKeys as $ primaryKey ) { $ this -> createForeignDataItem ( null , [ 'foreignPrimaryKey' => $ primaryKey ] ) ; } } else { $ foreignModels = $ this -> foreignModel -> findAll ( $ this -> settings [ 'foreignPullParams' ] ) ; foreach ( $ foreignModels as $ key => $ model ) { $ this -> createForeignDataItem ( $ model , [ ] ) ; } } }
11617	public function records ( $ startTime , $ endTime , $ page = 1 , $ pageSize = 10 ) { $ params = [ 'starttime' => is_numeric ( $ startTime ) ? $ startTime : strtotime ( $ startTime ) , 'endtime' => is_numeric ( $ endTime ) ? $ endTime : strtotime ( $ endTime ) , 'pageindex' => $ page , 'pagesize' => $ pageSize , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_RECORDS , $ params ] ) ; }
1149	protected function setDefaults ( $ options ) { $ this -> selector = empty ( $ options [ 'selector' ] ) ? 'form' : $ options [ 'selector' ] ; $ this -> view = empty ( $ options [ 'view' ] ) ? 'jsvalidation::bootstrap' : $ options [ 'view' ] ; $ this -> remote = isset ( $ options [ 'remote' ] ) ? $ options [ 'remote' ] : true ; }
12770	public function authorize ( RecordInterface & $ user , $ remember = false ) { if ( parent :: authorize ( $ user , $ remember ) ) { if ( $ remember ) { $ token = $ user [ $ this -> dbHashEmailField ] . ( time ( ) + ( $ this -> cookieTime ) ) . $ user [ $ this -> dbHashPasswordField ] ; $ user [ $ this -> dbAccessToken ] = $ token ; $ user -> save ( ) ; $ expiry = time ( ) + ( $ this -> cookieTime ) ; $ cookieData = array ( "token" => $ token , "expiry" => $ expiry ) ; setcookie ( '_cookie_accessToken' , serialize ( $ cookieData ) , $ expiry ) ; } } }
3464	public function get ( string $ route , callable $ controller ) : void { $ this -> register ( $ controller , Route :: get ( $ route ) ) ; }
11460	public function send ( ) : bool { $ sHeaders = 'From: ' . $ this -> _sFrom . "\r\n" ; if ( empty ( $ this -> _aAttachments ) ) { if ( $ this -> _sFormat == "HTML" ) { $ sHeaders .= 'MIME-Version: 1.0' . "\r\n" ; $ sHeaders .= 'Content-type: text/html; charset=UTF-8' . "\r\n" ; } return mail ( implode ( ',' , $ this -> _aRecipient ) , $ this -> _sSubject , $ this -> _sMessage , $ sHeaders ) ; } else { $ sBoundary = "_" . md5 ( uniqid ( rand ( ) ) ) ; $ sAttached = "" ; foreach ( $ this -> _aAttachments as $ aAttachment ) { $ sAttached_file = chunk_split ( base64_encode ( $ aAttachment [ "content" ] ) ) ; $ sAttached = "\n\n" . "--" . $ sBoundary . "\nContent-Type: application; name=\"" . $ aAttachment [ "name" ] . "\"\r\nContent-Transfer-Encoding: base64\r\nContent-Disposition: attachment; filename=\"" . $ aAttachment [ "name" ] . "\"\r\n\n" . $ sAttached_file . "--" . $ sBoundary . "--" ; } $ sHeaders = 'From: ' . $ this -> _sFrom . "\r\n" ; $ sHeaders .= "MIME-Version: 1.0\r\nContent-Type: multipart/mixed; boundary=\"$sBoundary\"\r\n" ; $ sBody = "--" . $ sBoundary . "\nContent-Type: " . ( $ this -> _sFormat == "HTML" ? "text/html" : "text/plain" ) . "; charset=UTF-8\r\n\n" . $ this -> _sMessage . $ sAttached ; return mail ( implode ( ',' , $ this -> _aRecipient ) , $ this -> _sSubject , $ sBody , $ sHeaders ) ; } }
3068	protected function initServiceContext ( ) { $ serviceContext = $ this -> getServiceContext ( ) ; $ this -> getRunnerService ( ) -> check ( $ serviceContext ) ; return $ serviceContext -> init ( ) ; }
12660	public function removeAll ( ) { $ fs = $ this -> env -> getFileSystem ( ) ; $ fs -> deleteFile ( $ this -> baseDir . $ this -> pageName . '.js' ) ; $ fs -> deleteFile ( $ this -> outdatedDir . $ this -> baseLang . '/' . $ this -> pageName . '.json' ) ; foreach ( $ this -> extraLangs as $ language ) { $ fs -> deleteFile ( $ this -> baseDir . $ language . '/' . $ this -> pageName . '.js' ) ; $ fs -> deleteFile ( $ this -> outdatedDir . $ language . '/' . $ this -> pageName . '.json' ) ; } }
3333	public function createGroup ( $ files ) { $ data = array ( 'pub_key' => $ this -> api -> getPublicKey ( ) , ) ; foreach ( $ files as $ i => $ file ) { $ data [ "files[$i]" ] = $ file -> getUrl ( ) ; } $ ch = $ this -> __initRequest ( 'group' ) ; $ this -> __setRequestType ( $ ch ) ; $ this -> __setData ( $ ch , $ data ) ; $ this -> __setHeaders ( $ ch ) ; $ resp = $ this -> __runRequest ( $ ch ) ; $ group = $ this -> api -> getGroup ( $ resp -> id ) ; return $ group ; }
4578	public function start ( $ id , Parameters $ parameters = null ) { if ( null !== $ id ) { $ resource = str_replace ( '{id}' , $ id , static :: RESOURCE_OBJECT_START ) ; } else { $ key = $ parameters -> getKey ( ) ; $ tenantId = $ parameters -> getTenantId ( ) ; switch ( true ) { case null !== $ key && null !== $ tenantId : $ resource = str_replace ( [ '{key}' , '{tenant-id}' ] , [ $ key , $ tenantId ] , static :: RESOURCE_OBJECT_START_BY_KEY_AND_TENANT_ID ) ; break ; case null !== $ key : $ resource = str_replace ( '{key}' , $ key , static :: RESOURCE_OBJECT_START_BY_KEY ) ; break ; default : throw new LogicException ( '"Key" and/or "TenantId" parameters are not defined.' ) ; } } $ options = [ 'headers' => [ 'Accept' => 'application/json' , 'Content-Type' => 'application/json' ] ] ; if ( $ parameters ) { $ parameters = ( array ) $ parameters -> toObject ( true ) ; foreach ( $ parameters as $ name => $ value ) { switch ( $ name ) { case 'variables' : foreach ( $ value as $ variable ) { $ options [ 'json' ] [ $ name ] [ $ variable -> name ] = [ 'value' => Variable :: TYPE_JSON === $ variable -> type ? json_encode ( $ variable -> value ) : $ variable -> value , 'type' => $ variable -> type ] ; } break ; case 'key' : break ; default : $ options [ 'json' ] [ $ name ] = $ value ; } } } $ object = $ this -> execute ( 'POST' , $ resource , $ options ) ; $ model = ProcessInstanceService :: toModel ( $ object ) ; return $ model ; }
5612	public function paintPass ( $ message ) { parent :: paintPass ( $ message ) ; $ node = new TreemapNode ( 'Assertion' , $ message , true ) ; $ current = $ this -> _stack -> peek ( ) ; if ( $ current ) { $ current -> putChild ( $ node ) ; } else { echo 'no current node' ; } }
7297	private function modulate_next_group ( $ object_id , $ object_type , $ mail_to_chunks ) { if ( ! empty ( $ mail_to_chunks ) ) { $ this -> options [ 'static_options' ] [ 'send_next_group' ] [ $ object_id ] = $ mail_to_chunks ; if ( $ object_type == 'post' ) { $ this -> transit_posts [ $ object_id ] = array ( 'new_status' => 'publish' , 'old_status' => 'draft' ) ; $ this -> inform_about_posts ( $ object_id ) ; } elseif ( $ object_type == 'comment' ) { $ this -> inform_about_comment ( $ object_id ) ; } } else { } }
11461	public static function enable ( $ state = true , $ enable_assert = false ) { $ state = ( bool ) $ state ; self :: enableAssert ( ( bool ) $ enable_assert ) ; if ( $ state && self :: $ _enabled || ! $ state && ! self :: $ _enabled ) { return ; } if ( $ state ) { set_exception_handler ( __CLASS__ . '::exception' ) ; set_error_handler ( __CLASS__ . '::error' , error_reporting ( ) ) ; assert_options ( ASSERT_CALLBACK , __CLASS__ . '::assert' ) ; self :: $ _enabled = true ; } else { restore_exception_handler ( ) ; restore_error_handler ( ) ; assert_options ( ASSERT_CALLBACK , function ( ) { } ) ; self :: $ _enabled = false ; } }
4292	public function getCfg ( $ path = null ) { if ( ! \ strlen ( $ path ) ) { return $ this -> cfg ; } if ( isset ( $ this -> cfg [ $ path ] ) ) { return $ this -> cfg [ $ path ] ; } return null ; }
7801	protected function splitTransactions ( $ text ) { $ offset = 0 ; $ length = 0 ; $ position = 0 ; $ transactions = array ( ) ; while ( $ line = $ this -> getLine ( '61' , $ text , $ offset , $ offset , $ length ) ) { $ offset += 4 + $ length + 2 ; $ transaction = array ( $ line ) ; $ description = array ( ) ; while ( $ line = $ this -> getLine ( '86' , $ text , $ offset , $ position , $ length ) ) { if ( $ position == $ offset ) { $ offset += 4 + $ length + 2 ; $ description [ ] = $ line ; } else { break ; } } if ( $ description ) { $ transaction [ ] = implode ( "\r\n" , $ description ) ; } $ transactions [ ] = $ transaction ; } return $ transactions ; }
5934	public function setLastLogin ( $ lastLogin ) { if ( $ lastLogin instanceof DateTime ) { $ this -> lastLogin = $ lastLogin ; } else { try { $ this -> lastLogin = new DateTime ( $ lastLogin ) ; } catch ( \ Exception $ e ) { $ this -> lastLogin = null ; } } return $ this ; }
4333	private static function buildAttribBoolVal ( $ key , $ value = true ) { if ( $ key == 'autocomplete' ) { $ value = $ value ? 'on' : 'off' ; } elseif ( $ key == 'spellcheck' ) { $ value = $ value ? 'true' : 'false' ; } elseif ( $ key == 'translate' ) { $ value = $ value ? 'yes' : 'no' ; } elseif ( $ value ) { $ value = $ key ; } else { $ value = null ; } return $ value ; }
4441	public function fromSubscriptions ( string $ topic ) : array { $ response = [ ] ; if ( empty ( $ topic ) ) { return $ response ; } $ subscriptions = $ this -> client -> call ( 'subscription' , 'default' , 'all' , $ topic ) ; $ subscriptions = json_decode ( $ subscriptions , true ) ? : [ ] ; foreach ( $ subscriptions as $ subscription => $ queues ) { $ topicPattern = str_replace ( [ '.' , '*' , '#' ] , [ '\.' , '[a-zA-z0-9^.]{1,}' , '.*' ] , $ subscription ) ; if ( preg_match ( "/^$topicPattern$/" , $ topic ) ) { $ response = array_merge ( $ response , $ queues ) ; } } return array_unique ( $ response ) ; }
8939	public function closeChangeset ( $ id ) { $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = 'changeset/' . $ id . '/close' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ header [ 'format' ] = 'text/xml' ; $ this -> oauth -> oauthRequest ( $ path , 'PUT' , $ parameters , $ header ) ; }
1814	public function listImportWizard ( ) { return ' <a href="' . $ this -> addToUrl ( 'key=list' ) . '" title="' . Contao \ StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'lw_import' ] [ 1 ] ) . '" onclick="Backend.getScrollOffset()">' . Contao \ Image :: getHtml ( 'tablewizard.svg' , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'tw_import' ] [ 0 ] ) . '</a>' ; }
425	protected function addErrorClassIfNeeded ( & $ options ) { $ attributeName = Html :: getAttributeName ( $ this -> attribute ) ; if ( $ this -> model -> hasErrors ( $ attributeName ) ) { Html :: addCssClass ( $ options , $ this -> form -> errorCssClass ) ; } }
5780	private function setNav ( ) { $ this -> nav = [ 'System' => [ 'subSections' => [ 'Administrators' => [ 'route' => ROUTE_ADMINISTRATORS , 'authorization' => ADMINISTRATORS_VIEW_RESOURCE , 'subSections' => [ 'Insert' => [ 'route' => ROUTE_ADMINISTRATORS_INSERT , 'authorization' => ADMINISTRATORS_INSERT_RESOURCE , ] , ] ] , 'Roles' => [ 'route' => ROUTE_ADMINISTRATORS_ROLES , 'authorization' => ROLES_VIEW_RESOURCE , 'subSections' => [ 'Insert' => [ 'route' => ROUTE_ADMINISTRATORS_ROLES_INSERT , 'authorization' => ROLES_INSERT_RESOURCE , ] , ] , ] , 'Permissions' => [ 'route' => ROUTE_ADMINISTRATORS_PERMISSIONS , 'authorization' => PERMISSIONS_VIEW_RESOURCE , 'subSections' => [ 'Insert' => [ 'route' => ROUTE_ADMINISTRATORS_PERMISSIONS_INSERT , 'authorization' => PERMISSIONS_INSERT_RESOURCE , ] , ] ] , 'Events' => [ 'route' => ROUTE_EVENTS , 'authorization' => EVENTS_VIEW_RESOURCE , 'subSections' => [ 'Types' => [ 'route' => ROUTE_DATABASE_TABLES , 'args' => [ ROUTEARG_DATABASE_TABLE_NAME => 'event_types' ] , 'authorization' => EVENTS_VIEW_RESOURCE , ] , ] ] , 'Database' => [ 'authorization' => DATABASE_TABLES_VIEW_RESOURCE , 'subSections' => $ this -> getDatabaseTablesSection ( ) ] , ] ] , 'Logout' => [ 'route' => ROUTE_LOGOUT , ] , ] ; if ( isset ( $ this -> container [ 'settings' ] [ 'adminNav' ] ) ) { if ( ! is_array ( $ this -> container [ 'settings' ] [ 'adminNav' ] ) ) { throw new \ Exception ( "adminNav config must be array" ) ; } $ this -> nav = array_merge ( $ this -> container [ 'settings' ] [ 'adminNav' ] , $ this -> nav ) ; } }
12470	protected function setAppConfigNamespaces ( ) { $ search = [ $ this -> currentRoot . '\\Providers' , $ this -> currentRoot . '\\Http\\Controllers\\' ] ; $ replace = [ $ this -> argument ( 'name' ) . '\\Providers' , $ this -> argument ( 'name' ) . '\\Http\\Controllers\\' ] ; }
9589	public function dropDownListDefault ( $ items , $ options = [ ] ) { Html :: addCssClass ( $ options , 'browser-default' ) ; return parent :: dropDownList ( $ items , $ options ) ; }
7213	public function configure ( $ subject ) { if ( $ subject instanceof InvoiceInterface ) { $ this -> date = $ subject -> getCreatedAt ( ) -> format ( 'Y-m-d' ) ; } elseif ( $ subject instanceof PaymentInterface ) { $ this -> date = $ subject -> getCompletedAt ( ) -> format ( 'Y-m-d' ) ; } else { throw new InvalidArgumentException ( "Expected instance of " . InvoiceInterface :: class . " or " . PaymentInterface :: class ) ; } $ this -> number = $ subject -> getNumber ( ) ; $ sale = $ subject -> getSale ( ) ; if ( $ customer = $ sale -> getCustomer ( ) ) { $ this -> identity = $ customer -> getFirstName ( ) . ' ' . $ customer -> getLastName ( ) ; } else { $ this -> identity = $ sale -> getFirstName ( ) . ' ' . $ sale -> getLastName ( ) ; } }
8464	public static function getDomain ( $ url = false ) { if ( $ url ) { preg_match ( '/([\w]+[.]){1,}[a-z]+/' , $ url , $ matches ) ; return isset ( $ matches [ 0 ] ) ? $ matches [ 0 ] : false ; } return $ _SERVER [ 'SERVER_NAME' ] ; }
9161	private function addParsedHeader ( $ line ) { if ( strpos ( $ line , ':' ) === false ) { $ this -> responseCode = HttpStatus :: parseStatus ( $ line ) -> getCode ( ) ; } else { $ line = trim ( $ line ) ; list ( $ headerName , $ headerValue ) = explode ( ':' , $ line , 2 ) ; $ this -> headers [ $ headerName ] = trim ( $ headerValue ) ; } }
10205	public function setIndent ( $ pValue ) { if ( $ pValue > 0 ) { if ( $ this -> getHorizontal ( ) != self :: HORIZONTAL_GENERAL && $ this -> getHorizontal ( ) != self :: HORIZONTAL_LEFT && $ this -> getHorizontal ( ) != self :: HORIZONTAL_RIGHT ) { $ pValue = 0 ; } } if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'indent' => $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> indent = $ pValue ; } return $ this ; }
2976	public function serialize ( ) { try { $ this -> data = $ this -> data ? : $ this -> serializer -> getData ( $ this -> closure , true ) ; return serialize ( $ this -> data ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Serialization of closure failed: ' . $ e -> getMessage ( ) , E_USER_NOTICE ) ; return null ; } }
8748	public function addMethodCall ( $ methodName , array $ arguments = array ( ) ) { $ this -> actions [ ] = $ methodCall = new MethodCall ( $ methodName , $ arguments ) ; return $ methodCall ; }
10673	protected function _getCached ( $ key , $ default = null , $ ttl = null ) { try { return $ this -> _get ( $ key ) ; } catch ( NotFoundExceptionInterface $ e ) { if ( is_callable ( $ default ) ) { try { $ args = $ this -> _normalizeArray ( $ this -> _getGeneratorArgs ( $ key , $ default , $ ttl ) ) ; $ default = $ this -> _invokeCallable ( $ default , $ args ) ; } catch ( RootException $ e ) { throw $ this -> _createRuntimeException ( $ this -> __ ( 'Could not generate value' ) , null , $ e ) ; } } $ this -> _set ( $ key , $ default , $ ttl ) ; return $ default ; } }
3426	public function sort ( $ by , $ order = 'ASC' ) { $ this -> sort = is_array ( $ by ) ? $ by : [ $ by => $ order ] ; return $ this ; }
11717	public static function load ( string $ dir ) : void { self :: initialize ( ) ; $ commandDir = $ _SERVER [ 'DOCUMENT_ROOT' ] . $ dir ; $ files = scandir ( $ commandDir ) ; foreach ( $ files as $ file ) { if ( $ file == '.' || $ file == '..' ) { continue ; } require_once $ _SERVER [ 'DOCUMENT_ROOT' ] . $ dir . '/' . $ file ; } }
4339	private function setOutputAs ( $ outputAs ) { if ( \ is_object ( $ this -> cfg [ 'outputAs' ] ) ) { $ this -> debug -> removePlugin ( $ this -> cfg [ 'outputAs' ] ) ; $ this -> cfg [ 'outputAs' ] = null ; } $ prop = null ; $ obj = null ; if ( \ is_string ( $ outputAs ) ) { $ prop = $ outputAs ; $ classname = __NAMESPACE__ . '\\Output\\' . \ ucfirst ( $ outputAs ) ; if ( \ property_exists ( $ this , $ prop ) ) { $ obj = $ this -> { $ prop } ; } elseif ( \ class_exists ( $ classname ) ) { $ obj = new $ classname ( $ this -> debug ) ; } } elseif ( $ outputAs instanceof OutputInterface ) { $ classname = \ get_class ( $ outputAs ) ; $ prefix = __NAMESPACE__ . '\\Output\\' ; if ( \ strpos ( $ classname , $ prefix ) == 0 ) { $ prop = \ substr ( $ classname , \ strlen ( $ prefix ) ) ; $ prop = \ lcfirst ( $ prop ) ; } $ obj = $ outputAs ; } if ( $ obj ) { $ this -> debug -> addPlugin ( $ obj ) ; $ this -> cfg [ 'outputAs' ] = $ obj ; if ( $ prop ) { $ this -> { $ prop } = $ obj ; } } }
12917	public function sumValor ( ) { $ tableGateway = new TableGateway ( $ this -> tableName , $ this -> dbAdapter ) ; $ sql = $ tableGateway -> getSql ( ) ; $ select = $ sql -> select ( ) -> columns ( array ( 'sum' => new Expression ( 'SUM(valor)' ) ) ) ; return $ tableGateway -> selectWith ( $ select ) -> current ( ) ; }
8061	protected function runWorkerProcess ( WorkerInterface $ worker , SimpleSocket $ simpleSocket , $ i ) { $ replacements = array ( 'basename' => basename ( $ _SERVER [ 'PHP_SELF' ] ) , 'fullname' => $ _SERVER [ 'PHP_SELF' ] , 'class' => get_class ( $ worker ) , 'i' => $ i , 'state' => 'free' ) ; ProcessDetails :: setProcessTitle ( $ this -> childProcessTitleFormat , $ replacements ) ; $ this -> worker -> onProcessCreate ( $ this -> semaphore ) ; while ( TRUE ) { $ output = array ( 'pid' => getmypid ( ) ) ; try { $ replacements [ 'state' ] = 'free' ; ProcessDetails :: setProcessTitle ( $ this -> childProcessTitleFormat , $ replacements ) ; $ cmd = $ simpleSocket -> receive ( ) ; if ( ! isset ( $ cmd [ 'cmd' ] ) ) { break ; } $ replacements [ 'state' ] = 'busy' ; ProcessDetails :: setProcessTitle ( $ this -> childProcessTitleFormat , $ replacements ) ; if ( $ cmd [ 'cmd' ] == 'run' ) { try { $ output [ 'data' ] = $ this -> worker -> run ( $ cmd [ 'data' ] ) ; } catch ( \ Exception $ e ) { $ output [ 'workerException' ] = array ( 'class' => get_class ( $ e ) , 'message' => $ e -> getMessage ( ) , 'trace' => $ e -> getTraceAsString ( ) ) ; } $ simpleSocket -> send ( $ output ) ; } elseif ( $ cmd [ 'cmd' ] == 'exit' ) { break ; } } catch ( SimpleSocketException $ e ) { break ; } catch ( \ Exception $ e ) { $ output [ 'poolException' ] = array ( 'class' => get_class ( $ e ) , 'message' => $ e -> getMessage ( ) , 'trace' => $ e -> getTraceAsString ( ) ) ; $ simpleSocket -> send ( $ output ) ; } } $ this -> worker -> onProcessDestroy ( ) ; $ this -> exitPhp ( 0 ) ; }
10319	function getBlocksCount ( $ fromDate = null , $ toDate = null , $ contactIds = null , $ contactEmails = null , $ contactExternalIds = null , $ reasons = null , $ oldStatus = null , $ newStatus = null , $ excludeAnonymousBlocks = false ) { $ params = $ this -> createCountQueryParameters ( $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , null , null ) ; if ( isset ( $ excludeAnonymousBlocks ) ) $ params [ 'exclude_anonymous_blocks' ] = ( $ excludeAnonymousBlocks == true ) ? "true" : "false" ; $ params = $ this -> appendArrayFields ( $ params , "reasons" , $ reasons ) ; if ( isset ( $ oldStatus ) ) $ params [ 'old_status' ] = $ oldStatus ; if ( isset ( $ newStatus ) ) $ params [ 'new_status' ] = $ newStatus ; return $ this -> get ( 'reports/blocks/count' , $ params ) ; }
6619	public function hasChildController ( $ controllerName ) { $ methodName = $ this -> parseControllerName ( $ controllerName ) ; return $ this -> reflection -> hasMethod ( $ methodName ) ; }
97	private function selectRestVersion ( $ channelXml , $ supportedVersions ) { $ channelXml -> registerXPathNamespace ( 'ns' , self :: CHANNEL_NS ) ; foreach ( $ supportedVersions as $ version ) { $ xpathTest = "ns:servers/ns:*/ns:rest/ns:baseurl[@type='{$version}']" ; $ testResult = $ channelXml -> xpath ( $ xpathTest ) ; foreach ( $ testResult as $ result ) { $ result = ( string ) $ result ; if ( preg_match ( '{^https://}i' , $ result ) ) { return array ( 'version' => $ version , 'baseUrl' => $ result ) ; } } if ( count ( $ testResult ) > 0 ) { return array ( 'version' => $ version , 'baseUrl' => ( string ) $ testResult [ 0 ] ) ; } } return null ; }
7657	function Send ( ) { $ header = "" ; $ body = "" ; $ result = true ; if ( ( count ( $ this -> to ) + count ( $ this -> cc ) + count ( $ this -> bcc ) ) < 1 ) { $ this -> SetError ( $ this -> Lang ( "provide_address" ) ) ; return false ; } if ( ! empty ( $ this -> AltBody ) ) $ this -> ContentType = "multipart/alternative" ; $ this -> error_count = 0 ; $ this -> SetMessageType ( ) ; $ header .= $ this -> CreateHeader ( ) ; $ body = $ this -> CreateBody ( ) ; if ( $ body == "" ) { return false ; } switch ( $ this -> Mailer ) { case "sendmail" : $ result = $ this -> SendmailSend ( $ header , $ body ) ; break ; case "mail" : $ result = $ this -> MailSend ( $ header , $ body ) ; break ; case "smtp" : $ result = $ this -> SmtpSend ( $ header , $ body ) ; break ; default : $ this -> SetError ( $ this -> Mailer . $ this -> Lang ( "mailer_not_supported" ) ) ; $ result = false ; break ; } return $ result ; }
4879	public function getPrettySize ( ) { $ size = $ this -> getLength ( ) ; if ( $ size >= 1073741824 ) { return round ( $ size / 1073741824 , 2 ) . ' GB' ; } if ( $ size >= 1048576 ) { return round ( $ size / 1048576 , 2 ) . ' MB' ; } if ( $ size >= 1024 ) { return round ( $ size / 1024 , 2 ) . ' kB' ; } return ( string ) $ size ; }
8048	public function receive ( ) { $ hdr = '' ; do { $ read = socket_read ( $ this -> socket , 4 - strlen ( $ hdr ) ) ; if ( $ read === FALSE ) { throw new SimpleSocketException ( 'Reception failed with: ' . socket_strerror ( socket_last_error ( $ this -> socket ) ) ) ; } elseif ( $ read === '' || $ read === NULL ) { return NULL ; } $ hdr .= $ read ; } while ( strlen ( $ hdr ) < 4 ) ; list ( $ len ) = array_values ( unpack ( "N" , $ hdr ) ) ; $ buffer = '' ; do { $ read = socket_read ( $ this -> socket , $ len - strlen ( $ buffer ) ) ; if ( $ read === FALSE || $ read == '' ) { throw new SimpleSocketException ( 'Reception failed with: ' . socket_strerror ( socket_last_error ( $ this -> socket ) ) ) ; } elseif ( $ read == '' ) { return NULL ; } $ buffer .= $ read ; } while ( strlen ( $ buffer ) < $ len ) ; $ data = unserialize ( $ buffer ) ; return $ data ; }
2697	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ activateVcl = $ this -> getRequest ( ) -> getParam ( 'activate_flag' ) ; $ service = $ this -> api -> checkServiceDetails ( ) ; $ enabled = false ; $ this -> vcl -> checkCurrentVersionActive ( $ service -> versions , $ activeVersion ) ; $ currActiveVersion = $ this -> vcl -> getCurrentVersion ( $ service -> versions ) ; $ vclPath = Config :: VCL_AUTH_SNIPPET_PATH ; $ snippets = $ this -> config -> getVclSnippets ( $ vclPath ) ; $ status = true ; foreach ( $ snippets as $ key => $ value ) { $ name = Config :: FASTLY_MAGENTO_MODULE . '_basic_auth_' . $ key ; $ status = $ this -> api -> getSnippet ( $ activeVersion , $ name ) ; if ( ! $ status ) { break ; } } if ( ! $ status ) { $ this -> api -> checkAuthDictionaryPopulation ( $ activeVersion ) ; $ clone = $ this -> api -> cloneVersion ( $ currActiveVersion ) ; foreach ( $ snippets as $ key => $ value ) { $ snippetData = [ 'name' => Config :: FASTLY_MAGENTO_MODULE . '_basic_auth_' . $ key , 'type' => $ key , 'dynamic' => "0" , 'content' => $ value , 'priority' => 10 ] ; $ this -> api -> uploadSnippet ( $ clone -> number , $ snippetData ) ; } $ enabled = true ; } else { $ clone = $ this -> api -> cloneVersion ( $ currActiveVersion ) ; foreach ( $ snippets as $ key => $ value ) { $ name = Config :: FASTLY_MAGENTO_MODULE . '_basic_auth_' . $ key ; $ this -> api -> removeSnippet ( $ clone -> number , $ name ) ; } } $ this -> api -> validateServiceVersion ( $ clone -> number ) ; if ( $ activateVcl === 'true' ) { $ this -> api -> activateVersion ( $ clone -> number ) ; } $ this -> sendWebhook ( $ enabled , $ clone ) ; $ comment = [ 'comment' => 'Magento Module turned ON Basic Authentication' ] ; if ( ! $ enabled ) { $ comment = [ 'comment' => 'Magento Module turned OFF Basic Authentication' ] ; } $ this -> api -> addComment ( $ clone -> number , $ comment ) ; return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
7235	protected function assertItemAdjustmentClass ( Common \ AdjustmentInterface $ adjustment ) { if ( ! $ adjustment instanceof Model \ CartItemAdjustmentInterface ) { throw new InvalidArgumentException ( "Expected instance of " . Model \ CartItemAdjustmentInterface :: class ) ; } }
9039	public function getByHash ( $ columns , string $ hash ) : ? IEntity { if ( $ this -> manager -> hasher === null ) { throw new MissingServiceException ( 'Hasher is missing' ) ; } return $ this -> toEntity ( $ this -> manager -> hasher -> hashSQL ( $ this -> builder ( ) , $ columns , $ hash ) ) ; }
9267	public function recipe ( string $ string , string $ method , callable $ callback = null ) : string { return preg_replace_callback ( RegEx :: REGEX_SPACE , [ $ this , $ method ] , $ this -> callback ( $ string , $ callback ) ) ; }
10567	public function newAction ( ) { $ entity = new Media ( ) ; $ form = $ this -> createCreateForm ( $ entity ) ; return $ this -> render ( 'MMMediaBundle:Media:new.html.twig' , array ( 'entity' => $ entity , 'form' => $ form -> createView ( ) , ) ) ; }
12126	public function validate ( string $ sValue = null ) : bool { if ( $ this -> _sType == 'DateTime' ) { if ( preg_match ( '#^[0-9]{4}/[0-9]{2}/[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}#' , $ sValue ) ) { return true ; } } return false ; }
7926	public function fireEvent ( $ event , array $ args = [ ] ) { if ( isset ( $ this -> eventListeners [ $ event ] ) === false ) return $ args ; foreach ( $ this -> eventListeners [ $ event ] as $ listener ) call_user_func_array ( $ listener , $ args ) ; return $ args ; }
5554	public function getHeaders ( ) { if ( is_integer ( $ this -> focus ) ) { return $ this -> frames [ $ this -> focus ] -> getHeaders ( ) ; } return $ this -> frameset -> getHeaders ( ) ; }
5288	protected static function getRequestMethodName ( ) { $ request_engine = self :: $ requestEngine ; if ( $ request_engine == 'curl' && ! function_exists ( 'curl_init' ) ) { trigger_error ( "DetectLanguage::Client - CURL not found, switching to stream" ) ; $ request_engine = self :: $ requestEngine = 'stream' ; } switch ( $ request_engine ) { case 'curl' : return 'requestCurl' ; case 'stream' : return 'requestStream' ; default : throw new Error ( "Invalid request engine: " . $ request_engine ) ; } }
5608	public function after ( $ method ) { $ this -> invoker -> after ( $ method ) ; $ output = ob_get_contents ( ) ; ob_end_clean ( ) ; if ( $ output !== '' ) { $ result = $ this -> listener -> write ( '{status:"info",message:"' . EclipseReporter :: escapeVal ( $ output ) . '"}' ) ; } }
9557	public function addMany ( $ parameters ) { foreach ( $ parameters as $ parameter ) { $ this -> prefixes [ $ parameter -> prefix ] [ $ parameter -> parameterName ] = $ parameter ; } return $ this ; }
8513	public function listInboundShipments ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_ListInboundShipmentsRequest ) ) { $ request = new FBAInboundServiceMWS_Model_ListInboundShipmentsRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListInboundShipments' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_ListInboundShipmentsResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
6110	public function fileList ( $ cpw = "" , $ path = "/" , $ recursive = false ) { return $ this -> getParent ( ) -> channelFileList ( $ this -> getId ( ) , $ cpw , $ path , $ recursive ) ; }
7780	public function validate_unique ( $ value , $ input , $ args ) { $ table = $ args [ 0 ] ; $ column = $ args [ 1 ] ; $ value = trim ( $ value ) ; $ exists = $ this -> db -> prepare ( " SELECT count(*) as count FROM {$table} WHERE {$column} = :value " ) ; $ exists -> execute ( [ 'value' => $ value ] ) ; return ! ( bool ) $ exists -> fetchObject ( ) -> count ; }
2757	public function permissions ( ) { $ permissions = [ ] ; foreach ( $ this -> entityTypeManager -> getStorage ( 'taxonomy_vocabulary' ) -> loadMultiple ( ) as $ vocabulary ) { $ permissions += [ 'view published terms in ' . $ vocabulary -> id ( ) => [ 'title' => $ this -> t ( 'View published terms in %vocabulary' , [ '%vocabulary' => $ vocabulary -> label ( ) ] ) , ] , 'view unpublished terms in ' . $ vocabulary -> id ( ) => [ 'title' => $ this -> t ( 'View unpublished terms in %vocabulary' , [ '%vocabulary' => $ vocabulary -> label ( ) ] ) , ] , ] ; } return $ permissions ; }
7587	protected function extractFileName ( ) { foreach ( explode ( "\r\n" , $ this -> headers ) as $ header ) { if ( strpos ( $ header , 'filename' ) !== false && strpos ( $ header , 'Content-Disposition' ) !== false ) { $ fileName = substr ( $ header , ( strpos ( $ header , "=" ) + 1 ) ) ; $ this -> setFileName ( $ fileName ) ; break ; } } }
3019	public function getTaggedPosts ( $ tag , $ options = null ) { if ( ! $ options ) { $ options = array ( ) ; } $ options [ 'tag' ] = $ tag ; return $ this -> getRequest ( 'v2/tagged' , $ options , true ) ; }
3884	private function createSetting ( $ dbResult , $ filterSettings ) { $ factory = $ this -> getTypeFactory ( $ dbResult [ 'type' ] ) ; if ( $ factory ) { $ setting = $ factory -> createInstance ( $ dbResult , $ filterSettings ) ; if ( ! $ setting ) { return null ; } if ( $ factory -> isNestedType ( ) ) { $ this -> collectRulesFor ( $ setting , $ filterSettings ) ; } return $ setting ; } return null ; }
6390	public function readFacetofaceSessionSignups ( $ sessionid , $ timecreated ) { $ signups = $ this -> readStoreRecords ( 'facetoface_signups' , [ 'sessionid' => $ sessionid ] ) ; foreach ( $ signups as $ index => $ signup ) { $ signups [ $ index ] -> statuses = $ this -> readStoreRecords ( 'facetoface_signups_status' , [ 'signupid' => $ signup -> id ] ) ; $ signups [ $ index ] -> attendee = $ this -> readUser ( $ signup -> userid ) ; } return $ signups ; }
12598	public function isCacheable ( $ namespace ) { if ( ! $ this -> cacheOptions -> isEnabled ( ) ) { return false ; } $ namespaces = $ this -> cacheOptions -> getNamespaces ( ) ; if ( empty ( $ namespaces ) ) { return true ; } return in_array ( $ namespace , $ namespaces ) ; }
1288	private function buildContentTypeCollection ( array $ data ) { $ items = \ array_merge ( $ data [ 'items' ] , $ data [ 'includes' ] [ 'Entry' ] ?? [ ] ) ; $ ids = \ array_map ( function ( array $ item ) { return 'Entry' === $ item [ 'sys' ] [ 'type' ] ? $ item [ 'sys' ] [ 'contentType' ] [ 'sys' ] [ 'id' ] : null ; } , $ items ) ; $ ids = \ array_filter ( \ array_unique ( $ ids ) , function ( $ id ) : bool { return $ id && ! $ this -> resourcePool -> has ( 'ContentType' , $ id ) ; } ) ; if ( $ ids ) { $ query = ( new Query ( ) ) -> where ( 'sys.id[in]' , \ implode ( ',' , $ ids ) ) ; $ this -> client -> getContentTypes ( $ query ) ; } }
1067	private function findConflictsBetweenSubSelectionSets ( ValidationContext $ context , $ areMutuallyExclusive , $ parentType1 , SelectionSetNode $ selectionSet1 , $ parentType2 , SelectionSetNode $ selectionSet2 ) { $ conflicts = [ ] ; [ $ fieldMap1 , $ fragmentNames1 ] = $ this -> getFieldsAndFragmentNames ( $ context , $ parentType1 , $ selectionSet1 ) ; [ $ fieldMap2 , $ fragmentNames2 ] = $ this -> getFieldsAndFragmentNames ( $ context , $ parentType2 , $ selectionSet2 ) ; $ this -> collectConflictsBetween ( $ context , $ conflicts , $ areMutuallyExclusive , $ fieldMap1 , $ fieldMap2 ) ; $ fragmentNames2Length = count ( $ fragmentNames2 ) ; if ( $ fragmentNames2Length !== 0 ) { $ comparedFragments = [ ] ; for ( $ j = 0 ; $ j < $ fragmentNames2Length ; $ j ++ ) { $ this -> collectConflictsBetweenFieldsAndFragment ( $ context , $ conflicts , $ comparedFragments , $ areMutuallyExclusive , $ fieldMap1 , $ fragmentNames2 [ $ j ] ) ; } } $ fragmentNames1Length = count ( $ fragmentNames1 ) ; if ( $ fragmentNames1Length !== 0 ) { $ comparedFragments = [ ] ; for ( $ i = 0 ; $ i < $ fragmentNames1Length ; $ i ++ ) { $ this -> collectConflictsBetweenFieldsAndFragment ( $ context , $ conflicts , $ comparedFragments , $ areMutuallyExclusive , $ fieldMap2 , $ fragmentNames1 [ $ i ] ) ; } } for ( $ i = 0 ; $ i < $ fragmentNames1Length ; $ i ++ ) { for ( $ j = 0 ; $ j < $ fragmentNames2Length ; $ j ++ ) { $ this -> collectConflictsBetweenFragments ( $ context , $ conflicts , $ areMutuallyExclusive , $ fragmentNames1 [ $ i ] , $ fragmentNames2 [ $ j ] ) ; } } return $ conflicts ; }
12142	public static function provider ( ProviderInterface $ provider = null ) { if ( $ provider ) { static :: $ provider = $ provider ; } elseif ( ! static :: $ provider ) { static :: $ provider = new Provider \ Native ( static :: $ root ) ; } return static :: $ provider ; }
11167	protected function generateApi ( ) { $ api = array ( ) ; $ api [ "url" ] = $ this -> getUrl ( ) ; $ api [ "type" ] = "remoting" ; $ actionsArray = array ( ) ; $ actions = $ this -> getActions ( ) ; foreach ( $ actions as $ class ) { $ methodArray = array ( ) ; foreach ( $ class -> getMethods ( ) as $ method ) { $ methodArray [ ] = array ( "name" => $ method -> getAnnotatedName ( ) , "len" => $ method -> getLen ( ) ) ; } $ actionsArray [ $ class -> getAnnotatedName ( ) ] = $ methodArray ; } $ api [ "actions" ] = $ actionsArray ; return $ api ; }
11117	protected function rollbackMigrations ( array $ migrations ) : void { $ this -> notify -> note ( '' ) ; foreach ( $ this -> getMigrationFiles ( M :: TYPE_DOWN ) as $ file ) { if ( in_array ( $ name = $ this -> getMigrationName ( $ file ) , $ migrations , true ) ) { $ this -> runDown ( $ file ) ; continue ; } $ this -> notify -> note ( "<fg=red>Migrate not found (in database table):</> {$name}" ) ; } }
6481	private function createDefaultResponseContentNegotiationResult ( string $ type , ? string $ language , array $ acceptCharsetHeaders ) : ContentNegotiationResult { $ selectedMediaTypeFormatter = null ; foreach ( $ this -> mediaTypeFormatters as $ mediaTypeFormatter ) { if ( $ mediaTypeFormatter -> canWriteType ( $ type ) ) { $ selectedMediaTypeFormatter = $ mediaTypeFormatter ; break ; } } if ( $ selectedMediaTypeFormatter === null ) { return new ContentNegotiationResult ( null , null , null , $ language ) ; } $ encoding = $ this -> encodingMatcher -> getBestEncodingMatch ( $ selectedMediaTypeFormatter , $ acceptCharsetHeaders , null ) ; return new ContentNegotiationResult ( $ selectedMediaTypeFormatter , $ selectedMediaTypeFormatter -> getDefaultMediaType ( ) , $ encoding , $ language ) ; }
2723	public function execute ( Observer $ observer ) { if ( $ this -> fastlyConfig -> isFastlyEnabled ( ) != true ) { return ; } $ event = $ observer -> getEvent ( ) ; $ name = $ event -> getElementName ( ) ; $ layout = $ event -> getLayout ( ) ; $ block = $ layout -> getBlock ( $ name ) ; if ( $ block instanceof AbstractBlock ) { $ blockTtl = $ block -> getTtl ( ) ; if ( isset ( $ blockTtl ) ) { $ this -> response -> setHeader ( "x-esi" , "1" ) ; } } }
11310	public static function setMappings ( array $ messages , $ manual = true ) { $ class = get_called_class ( ) ; if ( $ manual ) { static :: $ messages = $ messages ; self :: setStatus ( ) ; } else { self :: $ mappings [ $ class ] = array_replace ( $ class :: getMappings ( ) , $ messages ) ; } }
590	protected function compressJsFiles ( $ inputFiles , $ outputFile ) { if ( empty ( $ inputFiles ) ) { return ; } $ this -> stdout ( " Compressing JavaScript files...\n" ) ; if ( is_string ( $ this -> jsCompressor ) ) { $ tmpFile = $ outputFile . '.tmp' ; $ this -> combineJsFiles ( $ inputFiles , $ tmpFile ) ; $ this -> stdout ( shell_exec ( strtr ( $ this -> jsCompressor , [ '{from}' => escapeshellarg ( $ tmpFile ) , '{to}' => escapeshellarg ( $ outputFile ) , ] ) ) ) ; @ unlink ( $ tmpFile ) ; } else { call_user_func ( $ this -> jsCompressor , $ this , $ inputFiles , $ outputFile ) ; } if ( ! file_exists ( $ outputFile ) ) { throw new Exception ( "Unable to compress JavaScript files into '{$outputFile}'." ) ; } $ this -> stdout ( " JavaScript files compressed into '{$outputFile}'.\n" ) ; }
11123	public function getUp ( $ time = NOW ) { foreach ( $ this -> movements as $ v ) { if ( $ v -> isActive ( $ time ) ) { $ up = $ v -> getCurrentUp ( $ time ) ; if ( isset ( $ up ) ) { return $ v -> getCurrentUp ( $ time ) ; } } } return new Neuron_GameServer_Map_Vector3 ( 0 , 1 , 0 ) ; }
4631	protected function prepareRequestMethod ( ) { switch ( $ this -> command -> getMethod ( ) ) { case "POST" : $ this -> options [ CURLOPT_POST ] = 1 ; break ; case "PUT" : $ this -> options [ CURLOPT_CUSTOMREQUEST ] = 'PUT' ; break ; case "DELETE" : $ this -> options [ CURLOPT_CUSTOMREQUEST ] = 'DELETE' ; break ; case "HEAD" : $ this -> options [ CURLOPT_NOBODY ] = 1 ; break ; default : $ this -> options [ CURLOPT_HTTPGET ] = 1 ; } return $ this ; }
4816	public function appendRow ( $ singleRow = null ) { if ( ! is_null ( $ singleRow ) ) { if ( $ singleRow instanceof Row ) { $ this -> collection [ ] = $ singleRow ; $ singleRow -> acceptChanges ( ) ; } elseif ( is_array ( $ singleRow ) ) { $ this -> collection [ ] = new Row ( $ singleRow ) ; } else { throw new InvalidArgumentException ( "You must pass an array or a Row object" ) ; } } else { $ singleRow = new Row ( ) ; $ this -> collection [ ] = $ singleRow ; $ singleRow -> acceptChanges ( ) ; } $ this -> currentRow = count ( $ this -> collection ) - 1 ; }
6074	public function restoreMedia ( $ id ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/media/' . $ id . '/restore' , $ parameters ) ; $ result = new MediaResponse ( $ result ) ; return $ result ; }
11914	public function addDynamic ( $ name , $ factory , $ createDefault = 0 , $ forceDefault = false ) { $ control = new RContainer ( $ factory , $ createDefault , $ forceDefault ) ; $ control -> currentGroup = $ this -> currentGroup ; return $ this [ $ name ] = $ control ; }
7873	public function credit ( ) : ? array { $ this -> checkConfig ( ) ; $ query = http_build_query ( [ 'userkey' => $ this -> userkey , 'passkey' => $ this -> passkey , ] ) ; $ response = Request :: get ( $ this -> baseUrl . '/smsapibalance.php?' . $ query ) ; $ xml = simplexml_load_string ( $ response -> body ) ; $ body = json_decode ( json_encode ( $ xml ) , true ) ; return [ 'code' => $ response -> code , 'message' => ( $ response -> code == 200 ) ? 'OK' : $ body [ 'message' ] [ 'text' ] ?? '' , 'data' => $ body , ] ; }
9840	public function createSymmetricEncryptedJsonResponse ( int $ status , array $ arrayToJsonify , SharedEncryptionKey $ key , array $ headers = [ ] , string $ version = '1.1' ) : ResponseInterface { if ( empty ( $ headers [ 'Content-Type' ] ) ) { $ headers [ 'Content-Type' ] = 'application/json' ; } $ body = \ json_encode ( $ arrayToJsonify , JSON_PRETTY_PRINT ) ; if ( ! \ is_string ( $ body ) ) { throw new InvalidMessageException ( 'Cannot JSON-encode this message.' ) ; } return $ this -> createSymmetricEncryptedResponse ( $ status , $ body , $ key , $ headers , $ version ) ; }
813	private function fixSpaceAboveClassElement ( Tokens $ tokens , $ classStartIndex , $ elementIndex ) { static $ methodAttr = [ T_PRIVATE , T_PROTECTED , T_PUBLIC , T_ABSTRACT , T_FINAL , T_STATIC ] ; $ firstElementAttributeIndex = $ elementIndex ; for ( $ i = $ elementIndex ; $ i > $ classStartIndex ; -- $ i ) { $ nonWhiteAbove = $ tokens -> getNonWhitespaceSibling ( $ i , - 1 ) ; if ( null !== $ nonWhiteAbove && $ tokens [ $ nonWhiteAbove ] -> isGivenKind ( $ methodAttr ) ) { $ firstElementAttributeIndex = $ nonWhiteAbove ; } else { break ; } } if ( $ tokens [ $ nonWhiteAbove ] -> isGivenKind ( T_COMMENT ) ) { if ( 1 === $ firstElementAttributeIndex - $ nonWhiteAbove ) { $ this -> correctLineBreaks ( $ tokens , $ nonWhiteAbove , $ firstElementAttributeIndex , 1 ) ; return ; } if ( substr_count ( $ tokens [ $ nonWhiteAbove + 1 ] -> getContent ( ) , "\n" ) > 1 ) { $ this -> correctLineBreaks ( $ tokens , $ nonWhiteAbove , $ firstElementAttributeIndex , 2 ) ; return ; } if ( $ tokens [ $ nonWhiteAbove - 1 ] -> isWhitespace ( ) && substr_count ( $ tokens [ $ nonWhiteAbove - 1 ] -> getContent ( ) , "\n" ) > 0 ) { $ this -> correctLineBreaks ( $ tokens , $ nonWhiteAbove , $ firstElementAttributeIndex , 1 ) ; $ nonWhiteAbove = $ this -> findCommentBlockStart ( $ tokens , $ nonWhiteAbove ) ; $ nonWhiteAboveComment = $ tokens -> getNonWhitespaceSibling ( $ nonWhiteAbove , - 1 ) ; $ this -> correctLineBreaks ( $ tokens , $ nonWhiteAboveComment , $ nonWhiteAbove , $ nonWhiteAboveComment === $ classStartIndex ? 1 : 2 ) ; } else { $ this -> correctLineBreaks ( $ tokens , $ nonWhiteAbove , $ firstElementAttributeIndex , 2 ) ; } return ; } if ( false === $ tokens [ $ nonWhiteAbove ] -> isGivenKind ( T_DOC_COMMENT ) ) { $ this -> correctLineBreaks ( $ tokens , $ nonWhiteAbove , $ firstElementAttributeIndex , $ nonWhiteAbove === $ classStartIndex ? 1 : 2 ) ; return ; } $ this -> correctLineBreaks ( $ tokens , $ nonWhiteAbove , $ firstElementAttributeIndex , 1 ) ; $ nonWhiteAbovePHPDoc = $ tokens -> getNonWhitespaceSibling ( $ nonWhiteAbove , - 1 ) ; $ this -> correctLineBreaks ( $ tokens , $ nonWhiteAbovePHPDoc , $ nonWhiteAbove , $ nonWhiteAbovePHPDoc === $ classStartIndex ? 1 : 2 ) ; }
10321	function getUnsubscribersCount ( $ fromDate = null , $ toDate = null , $ mailingIds = null , $ contactIds = null , $ contactEmails = null , $ contactExternalIds = null , $ source = null ) { $ params = $ this -> createCountQueryParameters ( $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , $ mailingIds , $ source ) ; return $ this -> get ( 'reports/unsubscriptions/count' , $ params ) ; }
4556	public function setOrganizationUuid ( ? string $ organizationUuid ) { $ this -> organizationUuid = $ organizationUuid ; $ this -> _organizationUuid = true ; return $ this ; }
2835	public function completeRendering ( Mage_Core_Block_Abstract $ block ) { $ this -> isRendering = false ; $ this -> renderedCompletedAt = microtime ( true ) ; $ this -> renderedDuration += ( $ this -> renderedCompletedAt * 1000 - $ this -> renderedAt * 1000 ) ; $ this -> templateFile = $ block instanceof Mage_Core_Block_Template ? $ block -> getTemplateFile ( ) : '' ; self :: $ endRenderingTime = $ this -> renderedCompletedAt ; }
4016	protected function getWidgetClass ( $ field ) { $ className = $ GLOBALS [ ( TL_MODE == 'BE' ? 'BE_FFL' : 'TL_FFL' ) ] [ $ field [ 'inputType' ] ] ; if ( ( $ className !== '' ) && class_exists ( $ className ) ) { return $ className ; } return null ; }
4759	protected function transformTemplate ( Template $ template ) { return array ( 'template' => $ template -> getTemplate ( ) , 'engine' => $ template -> getEngine ( ) , 'vars' => $ this -> transform ( $ template -> getVars ( ) ) , 'streamable' => $ this -> transformBoolean ( $ template -> isStreamable ( ) ) , ) ; }
8866	private function runTask ( TaskInterface $ task , PayloadInterface $ payload ) { $ this -> logTask ( $ task , LogLevel :: INFO , 'Starting execution.' ) ; try { if ( ! $ task -> unless ( ) ) { $ this -> dispatch ( 'runner.task.unless' , $ task , $ payload ) ; $ this -> logTask ( $ task , LogLevel :: INFO , 'Skipping because unless() returned boolean false.' ) ; return ; } $ this -> dispatch ( 'runner.task.start' , $ task , $ payload ) ; $ task -> setUp ( ) ; $ exitCode = ( int ) $ task -> run ( $ payload ) ? : 0 ; $ task -> tearDown ( ) ; if ( $ task -> isFailOnError ( ) && $ exitCode !== 0 ) { throw new FailException ( sprintf ( 'Task: %s failed with exit code %s' , get_class ( $ task ) , $ exitCode ) ) ; } $ message = sprintf ( 'Task exited with status code %s' , $ exitCode ) ; if ( $ exitCode === 0 ) { $ this -> logTask ( $ task , LogLevel :: INFO , $ message ) ; } else { $ this -> logTask ( $ task , LogLevel :: WARNING , $ message ) ; } $ this -> dispatch ( 'runner.task.success' , $ task , $ payload , $ exitCode ) ; $ task -> markAsSuccessfullyExecuted ( ) ; } catch ( SkipException $ e ) { $ this -> logTask ( $ task , LogLevel :: INFO , 'Skipping.' ) ; $ this -> dispatch ( 'runner.task.skip' , $ task , $ payload ) ; } catch ( RetryException $ e ) { $ this -> logTask ( $ task , LogLevel :: NOTICE , 'Retry thrown. Starting again.' ) ; $ this -> dispatch ( 'runner.task.retry' , $ task , $ payload ) ; if ( ! $ task -> getMaxRetries ( ) ) { throw new LogicException ( 'A retry exception was thrown, but no retries instance was set.' ) ; } $ task -> getMaxRetries ( ) -> increase ( ) ; $ this -> runTask ( $ task , $ payload ) ; return ; } catch ( FailException $ e ) { $ this -> logTask ( $ task , LogLevel :: WARNING , sprintf ( 'Failure thrown. Given message: %s' , $ e -> getMessage ( ) ) ) ; $ exitCode = $ e -> getCode ( ) ; if ( is_int ( $ exitCode ) ) { $ this -> dispatch ( 'runner.task.failure' , $ task , $ payload , $ exitCode ) ; } else { $ this -> dispatch ( 'runner.task.failure' , $ task , $ payload ) ; } throw $ e ; } $ this -> logTask ( $ task , LogLevel :: INFO , 'Execution successful.' ) ; }
7495	private static function convertString ( $ string , $ outputEncoding ) { if ( $ string instanceof StringBuilder ) { $ inputEncoding = $ string -> getEncoding ( ) ; } else { $ inputEncoding = mb_detect_encoding ( ( string ) $ string ) ; } $ string = ( string ) $ string ; if ( $ inputEncoding != $ outputEncoding ) { $ string = iconv ( $ inputEncoding , $ outputEncoding , $ string ) ; } return $ string ; }
11980	protected function query ( $ api , $ from , $ to ) { $ params = [ 'begin_date' => $ from , 'end_date' => $ to , ] ; return $ this -> parseJSON ( 'json' , [ $ api , $ params ] ) ; }
5217	protected static function getBindingsForApp ( $ className ) { $ bindings = method_exists ( $ className , '__bindings' ) ? $ className :: __bindings ( ) : [ ] ; if ( ! Runtime :: initialized ( ) ) { $ bindings [ ] = static :: runtime ( ) ; } return $ bindings ; }
12109	public function renamePage ( $ id , $ newName ) { $ this -> pages [ $ newName ] = $ this -> getPage ( $ id ) ; unset ( $ this -> pages [ $ id ] ) ; $ this -> persist ( ) ; }
9782	private function parseIf ( ) { $ if_open = $ this -> pop ( 'IF_OPEN' ) ; $ output = 'if(' . $ if_open [ 1 ] . ') {' . "\n" ; $ this -> currLine ++ ; $ seeking = true ; while ( $ seeking ) { list ( $ type , $ value ) = $ this -> peek ( ) ; switch ( $ type ) { case 'IF_CLOSE' : $ this -> pop ( ) ; $ output .= "}\n" ; $ seeking = false ; $ this -> currLine ++ ; break ; case 'ELSE' : $ this -> pop ( ) ; $ output .= "} else {\n" ; $ this -> currLine ++ ; break ; case 'ELSE_IF' : $ token = $ this -> pop ( ) ; $ output .= '} elseif(' . $ token [ 1 ] . ") {\n" ; $ this -> currLine ++ ; break ; default : $ output .= $ this -> parseExpression ( ) ; break ; } } return $ output ; }
8133	public function setSourceContext ( Twig_Source $ source = null ) { if ( null === $ source ) { $ this -> sourceCode = $ this -> filename = $ this -> sourcePath = null ; } else { $ this -> sourceCode = $ source -> getCode ( ) ; $ this -> filename = $ source -> getName ( ) ; $ this -> sourcePath = $ source -> getPath ( ) ; } $ this -> updateRepr ( ) ; }
11171	public function getFilters ( $ columnDescriptions = [ ] , $ activeFieldName = false ) { $ filters = [ ] ; if ( count ( $ this -> filtersArray ) > 0 ) { foreach ( $ this -> filtersArray as $ key => $ value ) { if ( isset ( $ this -> filters [ $ key ] ) ) { $ activeFieldName = $ activeFieldName ? : $ this -> filtersArray [ 'orderBy' ] ; $ friendlyFieldName = isset ( $ columnDescriptions [ $ activeFieldName ] ) ? $ columnDescriptions [ $ activeFieldName ] : $ activeFieldName ; $ filters [ ] = sprintf ( $ this -> filters [ $ key ] , $ friendlyFieldName , $ value ) ; } } } return $ filters ; }
9949	public function getStyleByColumnAndRow ( $ columnIndex1 , $ row1 , $ columnIndex2 = null , $ row2 = null ) { if ( $ columnIndex2 !== null && $ row2 !== null ) { $ cellRange = Coordinate :: stringFromColumnIndex ( $ columnIndex1 ) . $ row1 . ':' . Coordinate :: stringFromColumnIndex ( $ columnIndex2 ) . $ row2 ; return $ this -> getStyle ( $ cellRange ) ; } return $ this -> getStyle ( Coordinate :: stringFromColumnIndex ( $ columnIndex1 ) . $ row1 ) ; }
128	protected function getPackageBasePath ( PackageInterface $ package ) { $ installPath = $ this -> getInstallPath ( $ package ) ; $ targetDir = $ package -> getTargetDir ( ) ; if ( $ targetDir ) { return preg_replace ( '{/*' . str_replace ( '/' , '/+' , preg_quote ( $ targetDir ) ) . '/?$}' , '' , $ installPath ) ; } return $ installPath ; }
10611	public function confirmAction ( $ token ) { $ user = $ this -> get ( 'fos_user.user_manager' ) -> findUserByConfirmationToken ( $ token ) ; if ( null === $ user ) { throw new NotFoundHttpException ( sprintf ( 'The user with confirmation token "%s" does not exist' , $ token ) ) ; } $ user -> setConfirmationToken ( null ) ; $ user -> setEnabled ( true ) ; $ user -> setLastLogin ( new \ DateTime ( ) ) ; $ this -> get ( 'fos_user.user_manager' ) -> updateUser ( $ user ) ; $ response = $ this -> redirect ( $ this -> generateUrl ( 'miky_app_customer_registration_confirmed' ) ) ; $ this -> authenticateUser ( $ user , $ response ) ; return $ response ; }
10004	static function getStringFromHTTPStatusCode ( $ httpStatusCode ) { if ( array_key_exists ( $ httpStatusCode , HTTPResponseCodes :: $ codes ) === true ) { return HTTPResponseCodes :: $ codes [ $ httpStatusCode ] ; } else { return "unknown error code: " . $ httpStatusCode ; } }
11391	public function createMainMenu ( Request $ request ) { $ menu = $ this -> factory -> createItem ( 'root' ) ; $ menu -> setCurrentUri ( $ request -> getBaseUrl ( ) . $ request -> getPathInfo ( ) ) ; $ admin_pool = $ this -> container -> get ( 'sonata.admin.pool' ) ; foreach ( $ admin_pool -> getDashboardGroups ( ) as $ group ) { $ menu -> addChild ( $ group [ 'label' ] , array ( 'translationDomain' => $ group [ 'label_catalogue' ] ) ) ; foreach ( $ group [ 'items' ] as $ admin ) { if ( $ admin -> hasRoute ( 'list' ) && $ admin -> isGranted ( 'LIST' ) ) { $ menu [ $ group [ 'label' ] ] -> addChild ( $ admin -> getLabel ( ) , array ( 'admin' => $ admin ) ) ; } } } $ dispatcher = $ this -> container -> get ( 'event_dispatcher' ) ; $ event = new MenuCreateEvent ( $ menu ) ; $ dispatcher -> dispatch ( MenuEvents :: ADMIN_MENU_CREATE , $ event ) ; return $ menu ; }
4077	protected function getPaletteCombinationRows ( ) { $ combinations = $ this -> getCombinationsFromDatabase ( ) ; $ success = array ( ) ; if ( ! $ combinations ) { return array_keys ( $ this -> information ) ; } foreach ( $ combinations as $ combination ) { $ modelId = $ combination -> pid ; $ modelName = $ this -> tableNameFromId ( $ modelId ) ; if ( ! empty ( $ this -> information [ $ modelName ] [ self :: COMBINATION ] ) ) { continue ; } $ this -> information [ $ modelName ] [ self :: MODELID ] = $ modelId ; $ this -> information [ $ modelName ] [ self :: COMBINATION ] = array ( 'dca_id' => $ combination -> dca_id , 'view_id' => $ combination -> view_id ) ; $ this -> setTableMapping ( $ modelId , $ modelName ) ; $ success [ ] = $ modelId ; } return $ success ; }
4393	public function cancel ( \ Aimeos \ MShop \ Order \ Item \ Iface $ order ) { $ provider = $ this -> getProvider ( ) ; if ( ! $ provider -> supportsVoid ( ) ) { return ; } $ base = $ this -> getOrderBase ( $ order -> getBaseId ( ) ) ; $ data = array ( 'transactionReference' => $ this -> getTransactionReference ( $ base ) , 'currency' => $ base -> getPrice ( ) -> getCurrencyId ( ) , 'amount' => $ this -> getAmount ( $ base -> getPrice ( ) ) , 'transactionId' => $ order -> getId ( ) , ) ; $ response = $ provider -> void ( $ data ) -> send ( ) ; if ( $ response -> isSuccessful ( ) ) { $ status = \ Aimeos \ MShop \ Order \ Item \ Base :: PAY_CANCELED ; $ order -> setPaymentStatus ( $ status ) ; $ this -> saveOrder ( $ order ) ; } }
890	public function getTypes ( ) { if ( null === $ this -> types ) { $ this -> types = [ ] ; $ content = $ this -> getTypesContent ( ) ; while ( '' !== $ content && false !== $ content ) { Preg :: match ( '{^' . self :: REGEX_TYPES . '$}x' , $ content , $ matches ) ; $ this -> types [ ] = $ matches [ 'type' ] ; $ content = substr ( $ content , \ strlen ( $ matches [ 'type' ] ) + 1 ) ; } } return $ this -> types ; }
1821	protected function getQuicknavPages ( $ pid , $ level = 1 , $ host = null ) { global $ objPage ; $ groups = array ( ) ; $ arrPages = array ( ) ; if ( FE_USER_LOGGED_IN ) { $ this -> import ( FrontendUser :: class , 'User' ) ; $ groups = $ this -> User -> groups ; } $ objSubpages = PageModel :: findPublishedRegularWithoutGuestsByPid ( $ pid ) ; if ( $ objSubpages === null ) { return array ( ) ; } ++ $ level ; foreach ( $ objSubpages as $ objSubpage ) { $ _groups = StringUtil :: deserialize ( $ objSubpage -> groups ) ; if ( $ host !== null ) { $ objSubpage -> domain = $ host ; } if ( ! $ objSubpage -> protected || $ this -> showProtected || ( \ is_array ( $ _groups ) && \ is_array ( $ groups ) && array_intersect ( $ _groups , $ groups ) ) ) { if ( ! $ objSubpage -> hide || $ this -> showHidden ) { $ arrPages [ ] = array ( 'level' => ( $ level - 2 ) , 'title' => StringUtil :: specialchars ( StringUtil :: stripInsertTags ( $ objSubpage -> pageTitle ? : $ objSubpage -> title ) ) , 'href' => $ objSubpage -> getFrontendUrl ( ) , 'link' => StringUtil :: stripInsertTags ( $ objSubpage -> title ) , 'active' => ( $ objPage -> id == $ objSubpage -> id || ( $ objSubpage -> type == 'forward' && $ objPage -> id == $ objSubpage -> jumpTo ) ) ) ; if ( ! $ this -> showLevel || $ this -> showLevel >= $ level || ( ! $ this -> hardLimit && ( $ objPage -> id == $ objSubpage -> id || \ in_array ( $ objPage -> id , $ this -> Database -> getChildRecords ( $ objSubpage -> id , 'tl_page' ) ) ) ) ) { $ subpages = $ this -> getQuicknavPages ( $ objSubpage -> id , $ level ) ; if ( \ is_array ( $ subpages ) ) { $ arrPages = array_merge ( $ arrPages , $ subpages ) ; } } } } } return $ arrPages ; }
11163	protected function getResponseFormat ( array $ config ) { if ( isset ( $ config [ 'responseFormat' ] ) ) { if ( ! is_string ( $ config [ 'responseFormat' ] ) ) { throw new \ DomainException ( 'responseFormat must reference a string' , self :: ERR_INVALID_RESPONSEFORMAT ) ; } return $ config [ 'responseFormat' ] ; } return '[ %link% ] "%title%" by %author%' . '; Length %duration%' . '; Published %published%' . '; Views %views%' . '; Likes %likes%' ; }
5677	protected function stringDiffersAt ( $ first , $ second ) { if ( ! $ first || ! $ second ) { return 0 ; } if ( strlen ( $ first ) < strlen ( $ second ) ) { list ( $ first , $ second ) = array ( $ second , $ first ) ; } $ position = 0 ; $ step = strlen ( $ first ) ; while ( $ step > 1 ) { $ step = ( integer ) ( ( $ step + 1 ) / 2 ) ; if ( strncmp ( $ first , $ second , $ position + $ step ) == 0 ) { $ position += $ step ; } } return $ position ; }
4431	protected function writeSection ( $ text , $ style = 'bg=blue;fg=white' ) { $ this -> output -> writeln ( array ( '' , $ this -> getHelper ( 'formatter' ) -> formatBlock ( $ text , $ style , true ) , '' , ) ) ; }
12420	public function dt ( $ domain , $ singular ) { $ singular = ( string ) $ singular ; try { $ locale = $ this -> getLocale ( ) ; foreach ( $ this -> getTranslations ( $ domain ) as $ object ) { if ( ( $ string = $ object -> translate ( $ singular , $ domain , $ locale ) ) != $ singular ) { return $ string ; } } } catch ( \ Exception $ e ) { ; } return ( string ) $ singular ; }
6333	public function validateChecksum ( $ string ) { $ xml = new \ SimpleXMLElement ( $ string ) ; $ checksum = ( string ) $ xml -> Authentication -> Checksum ; $ original = str_replace ( $ checksum , $ this -> getMerchantPassword ( ) , $ string ) ; return md5 ( $ original ) == $ checksum ; }
1976	public static function findMultipleFoldersByFolder ( $ strPath , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ strPath = str_replace ( array ( '\\' , '%' , '_' ) , array ( '\\\\' , '\\%' , '\\_' ) , $ strPath ) ; return static :: findBy ( array ( "$t.type='folder' AND $t.path LIKE ? AND $t.path NOT LIKE ?" ) , array ( $ strPath . '/%' , $ strPath . '/%/%' ) , $ arrOptions ) ; }
10681	public function onBeforeWrite ( ) { if ( $ this -> owner -> Title ) { $ this -> owner -> URLSegment = $ this -> generateURLSegment ( $ this -> owner -> Title ) ; } parent :: onBeforeWrite ( ) ; }
5573	public function setField ( $ label , $ value , $ position = false ) { return $ this -> page -> setField ( new SelectByLabelOrName ( $ label ) , $ value , $ position ) ; }
10196	public function createStringTable ( Worksheet $ pSheet , $ pExistingTable = null ) { $ aStringTable = [ ] ; $ cellCollection = null ; $ aFlippedStringTable = null ; if ( ( $ pExistingTable !== null ) && is_array ( $ pExistingTable ) ) { $ aStringTable = $ pExistingTable ; } $ aFlippedStringTable = $ this -> flipStringTable ( $ aStringTable ) ; foreach ( $ pSheet -> getCoordinates ( ) as $ coordinate ) { $ cell = $ pSheet -> getCell ( $ coordinate ) ; $ cellValue = $ cell -> getValue ( ) ; if ( ! is_object ( $ cellValue ) && ( $ cellValue !== null ) && $ cellValue !== '' && ! isset ( $ aFlippedStringTable [ $ cellValue ] ) && ( $ cell -> getDataType ( ) == DataType :: TYPE_STRING || $ cell -> getDataType ( ) == DataType :: TYPE_STRING2 || $ cell -> getDataType ( ) == DataType :: TYPE_NULL ) ) { $ aStringTable [ ] = $ cellValue ; $ aFlippedStringTable [ $ cellValue ] = true ; } elseif ( $ cellValue instanceof RichText && ( $ cellValue !== null ) && ! isset ( $ aFlippedStringTable [ $ cellValue -> getHashCode ( ) ] ) ) { $ aStringTable [ ] = $ cellValue ; $ aFlippedStringTable [ $ cellValue -> getHashCode ( ) ] = true ; } } return $ aStringTable ; }
5569	public function delete ( $ url , $ parameters = false ) { if ( ! is_object ( $ url ) ) { $ url = new SimpleUrl ( $ url ) ; } return $ this -> load ( $ url , new SimpleDeleteEncoding ( $ parameters ) ) ; }
12119	private function getCustomersMap ( ) { $ customers = $ this -> daoCustDwnl -> get ( ) ; $ result = $ this -> hlpTree -> mapById ( $ customers , ECustomer :: A_CUSTOMER_REF ) ; return $ result ; }
2251	public static function convertRelativeUrls ( $ strContent , $ strBase = '' , $ blnHrefOnly = false ) { if ( $ strBase == '' ) { $ strBase = Environment :: get ( 'base' ) ; } $ search = $ blnHrefOnly ? 'href' : 'href|src' ; $ arrUrls = preg_split ( '/((' . $ search . ')="([^"]+)")/i' , $ strContent , - 1 , PREG_SPLIT_DELIM_CAPTURE ) ; $ strContent = '' ; for ( $ i = 0 , $ c = \ count ( $ arrUrls ) ; $ i < $ c ; $ i += 4 ) { $ strContent .= $ arrUrls [ $ i ] ; if ( ! isset ( $ arrUrls [ $ i + 2 ] ) ) { continue ; } $ strAttribute = $ arrUrls [ $ i + 2 ] ; $ strUrl = $ arrUrls [ $ i + 3 ] ; if ( ! preg_match ( '@^(?:[a-z0-9]+:|#)@i' , $ strUrl ) ) { $ strUrl = $ strBase . ( ( $ strUrl != '/' ) ? $ strUrl : '' ) ; } $ strContent .= $ strAttribute . '="' . $ strUrl . '"' ; } return $ strContent ; }
1875	private function getBundlePackageName ( string $ className ) : string { if ( 'Bundle' === substr ( $ className , - 6 ) ) { $ className = substr ( $ className , 0 , - 6 ) ; } return Container :: underscore ( $ className ) ; }
3827	protected function getFrontendFilterValue ( $ arrWidget , $ arrFilterUrl , $ strKeyOption ) { if ( $ this -> isActiveFrontendFilterValue ( $ arrWidget , $ arrFilterUrl , $ strKeyOption ) ) { return '' ; } return $ strKeyOption ; }
9722	public function write ( Spreadsheet $ spreadsheet , $ filename , array $ writers = [ 'Xlsx' , 'Xls' ] ) { $ spreadsheet -> setActiveSheetIndex ( 0 ) ; foreach ( $ writers as $ writerType ) { $ path = $ this -> getFilename ( $ filename , mb_strtolower ( $ writerType ) ) ; $ writer = IOFactory :: createWriter ( $ spreadsheet , $ writerType ) ; if ( $ writer instanceof Pdf ) { $ tempDir = $ this -> getTemporaryFolder ( ) ; $ writer -> setTempDir ( $ tempDir ) ; } $ callStartTime = microtime ( true ) ; $ writer -> save ( $ path ) ; $ this -> logWrite ( $ writer , $ path , $ callStartTime ) ; } $ this -> logEndingNotes ( ) ; }
7912	protected function renderToggleButton ( ) { if ( $ this -> toggleButton !== false ) { $ tag = ArrayHelper :: remove ( $ this -> toggleButton , 'tag' , 'div' ) ; $ label = ArrayHelper :: remove ( $ this -> toggleButton , 'label' , 'Show' ) ; if ( $ tag === 'button' && ! isset ( $ this -> toggleButton [ 'type' ] ) ) { $ this -> toggleButton [ 'type' ] = 'button' ; } if ( $ tag === 'div' ) { Html :: addCssClass ( $ this -> toggleButton , 'ui' ) ; Html :: addCssClass ( $ this -> toggleButton , 'button' ) ; } $ view = $ this -> getView ( ) ; DosAmigosAsset :: register ( $ view ) ; $ view -> registerJs ( 'dosamigos.semantic.init();' ) ; return Html :: tag ( $ tag , $ label , $ this -> toggleButton ) ; } else { return null ; } }
12347	public function add ( array $ assets ) { foreach ( $ assets as $ type => $ asset ) { if ( $ asset instanceof Plugin ) { $ this -> parse ( $ asset ) ; continue ; } $ this -> assets [ $ type ] = array_merge ( $ this -> assets [ $ type ] , $ asset ) ; } }
12076	public function childStore ( $ idParent , FilterRequest $ filters , $ relation ) { $ idParent = $ this -> getRealId ( $ idParent ) ; $ resource = $ this -> repository -> storeChild ( $ idParent , $ relation , $ filters -> all ( ) ) ; if ( ! $ resource ) { } return $ this -> success ( $ resource ) ; }
12963	public function checkDbExists ( $ name ) { $ data = $ this -> query ( "SELECT COUNT(*) AS total FROM INFORMATION_SCHEMA.SCHEMATA WHERE SCHEMA_NAME = '" . $ this -> escape ( $ name ) . "'" , true ) ; if ( isset ( $ data [ '0' ] [ 'total' ] ) && $ data [ '0' ] [ 'total' ] == '1' ) { return true ; } return false ; }
2734	public function afterGenerateXml ( \ Magento \ Framework \ View \ Layout $ subject , $ result ) { if ( $ subject -> isCacheable ( ) && $ this -> config -> isEnabled ( ) && $ this -> config -> getType ( ) == Config :: FASTLY && $ this -> config -> getTtl ( ) ) { $ header = $ this -> response -> getHeader ( 'cache-control' ) ; if ( ( $ header instanceof \ Zend \ Http \ Header \ HeaderInterface ) && ( $ value = $ header -> getFieldValue ( ) ) ) { if ( $ ttl = $ this -> config -> getStaleTtl ( ) ) { $ value .= ', stale-while-revalidate=' . $ ttl ; } if ( $ ttl = $ this -> config -> getStaleErrorTtl ( ) ) { $ value .= ', stale-if-error=' . $ ttl ; } $ this -> response -> setHeader ( $ header -> getFieldName ( ) , $ value , true ) ; } } if ( $ subject -> isCacheable ( ) ) { $ this -> response -> setHeader ( "fastly-page-cacheable" , "YES" ) ; } else { $ this -> response -> setHeader ( "fastly-page-cacheable" , "NO" ) ; } return $ result ; }
3681	public function getJumpTo ( ) { if ( ! isset ( $ this -> arrJumpTo ) ) { $ page = $ GLOBALS [ 'objPage' ] ; $ this -> setJumpTo ( $ page -> row ( ) ) ; if ( $ this -> metamodel_jumpTo ) { $ statement = $ this -> getConnection ( ) -> prepare ( 'SELECT id, alias FROM tl_page WHERE id=? LIMIT 0,1' ) ; $ statement -> bindValue ( 1 , $ this -> metamodel_jumpTo ) ; $ statement -> execute ( ) ; if ( $ statement -> rowCount ( ) ) { $ this -> setJumpTo ( $ statement -> fetch ( \ PDO :: FETCH_ASSOC ) ) ; } } } return $ this -> arrJumpTo ; }
7124	protected function getMessageFromEvent ( ResourceEventInterface $ event ) { $ message = $ event -> getResource ( ) ; if ( ! $ message instanceof TicketMessageInterface ) { throw new UnexpectedValueException ( "Expected instance of " . TicketMessageInterface :: class ) ; } return $ message ; }
10712	public function create ( array $ attributes = [ ] ) { $ model = $ this -> newModel ( ) ; $ model -> fill ( $ attributes ) ; $ this -> save ( $ model ) ; return $ model ; }
1828	public function save ( ) { if ( \ count ( \ func_get_args ( ) ) ) { throw new \ InvalidArgumentException ( 'The $blnForceInsert argument has been removed (see system/docs/UPGRADE.md)' ) ; } if ( $ this -> blnPreventSaving ) { throw new \ RuntimeException ( 'The model instance has been detached and cannot be saved' ) ; } $ objDatabase = Database :: getInstance ( ) ; $ arrFields = $ objDatabase -> getFieldNames ( static :: $ strTable ) ; if ( Registry :: getInstance ( ) -> isRegistered ( $ this ) ) { $ arrSet = array ( ) ; $ arrRow = $ this -> row ( ) ; foreach ( $ this -> arrModified as $ k => $ v ) { if ( \ in_array ( $ k , $ arrFields ) ) { $ arrSet [ $ k ] = $ arrRow [ $ k ] ; } } $ arrSet = $ this -> preSave ( $ arrSet ) ; if ( empty ( $ arrSet ) ) { return $ this ; } $ intPk = $ this -> { static :: $ strPk } ; if ( isset ( $ this -> arrModified [ static :: $ strPk ] ) ) { $ intPk = $ this -> arrModified [ static :: $ strPk ] ; } if ( $ intPk === null ) { throw new \ RuntimeException ( 'The primary key has not been set' ) ; } $ objDatabase -> prepare ( "UPDATE " . static :: $ strTable . " %s WHERE " . Database :: quoteIdentifier ( static :: $ strPk ) . "=?" ) -> set ( $ arrSet ) -> execute ( $ intPk ) ; $ this -> postSave ( self :: UPDATE ) ; $ this -> arrModified = array ( ) ; } else { $ arrSet = $ this -> row ( ) ; foreach ( $ arrSet as $ k => $ v ) { if ( ! \ in_array ( $ k , $ arrFields ) ) { unset ( $ arrSet [ $ k ] ) ; } } $ arrSet = $ this -> preSave ( $ arrSet ) ; if ( empty ( $ arrSet ) ) { return $ this ; } $ stmt = $ objDatabase -> prepare ( "INSERT INTO " . static :: $ strTable . " %s" ) -> set ( $ arrSet ) -> execute ( ) ; if ( static :: $ strPk == 'id' ) { $ this -> id = $ stmt -> insertId ; } $ this -> postSave ( self :: INSERT ) ; $ this -> arrModified = array ( ) ; Registry :: getInstance ( ) -> register ( $ this ) ; } return $ this ; }
12027	function addExecuteMethod ( ) { $ body = $ this -> generateCreateFragment ( ) ; $ body .= 'return $this->dispatch($request);' ; $ docBlock = $ this -> generateExecuteDocBlock ( 'Execute the operation, returning the parsed response' ) ; $ methodGenerator = new MethodGenerator ( 'execute' ) ; $ methodGenerator -> setBody ( $ body ) ; $ methodGenerator -> setDocBlock ( $ docBlock ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; }
3544	protected function writeable ( $ file_path ) { if ( $ this -> option ( 'force' ) ) { return true ; } return ( ! file_exists ( $ file_path ) || $ this -> confirmable ( $ file_path ) ) ; }
8402	public static function init ( ) { if ( self :: $ isInit === false ) { self :: $ namespaces = array ( ) ; self :: $ applications = array ( ) ; spl_autoload_register ( __CLASS__ . '::loadClass' ) ; self :: $ isInit = true ; Console :: init ( ) ; Console :: prefix ( '\\RocknRoot\\StrayFw\\Console' ) ; Console :: route ( 'help' , 'help' , 'this screen' , 'Controller.help' ) ; Console :: prefix ( '\\RocknRoot\\StrayFw\\Database' ) ; Console :: route ( 'db/list' , 'db/list' , 'list registered mappings' , 'Console.mappings' ) ; Console :: route ( 'db/build' , 'db/build mapping_name' , 'build data structures' , 'Console.build' ) ; Console :: route ( 'db/generate' , 'db/generate mapping_name' , 'generate base models' , 'Console.generate' ) ; Console :: route ( 'db/migration/create' , 'db/migration/create mapping_name migration_name' , 'create a new migration' , 'Migration.create' ) ; Console :: route ( 'db/migration/generate' , 'db/migration/generate mapping_name migration_name' , 'generate migration code' , 'Migration.generate' ) ; Console :: route ( 'db/migration/migrate' , 'db/migration/migrate mapping_name' , 'migrate' , 'Migration.migrate' ) ; Console :: route ( 'db/migration/rollback' , 'db/migration/rollback mapping_name' , 'rollback last migration' , 'Migration.rollback' ) ; Console :: prefix ( '\\RocknRoot\\StrayFw\\Http' ) ; Console :: route ( 'http/routing/list' , 'http/routing/list' , 'list registered routes' , 'Console.routes' ) ; Http :: init ( ) ; if ( defined ( 'STRAY_IS_HTTP' ) === true && constant ( 'STRAY_IS_HTTP' ) === true && constant ( 'STRAY_ENV' ) === 'development' ) { Debug \ ErrorPage :: init ( ) ; } } }
12498	public static function insertOne ( $ document , $ connection ) { $ connection -> query = self :: singleDocument ( $ document ) ; return self :: insert ( $ connection ) ; }
1318	public function put ( $ path , array $ parameters = [ ] ) { return $ this -> http ( 'PUT' , self :: API_HOST , $ path , $ parameters , false ) ; }
10206	public function setReadOrder ( $ pValue ) { if ( $ pValue < 0 || $ pValue > 2 ) { $ pValue = 0 ; } if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'readOrder' => $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> readOrder = $ pValue ; } return $ this ; }
8255	protected function handlePasswordReset ( Request $ httpRequest ) { $ passwordReset = $ this -> picoAuth -> getContainer ( ) -> get ( 'PasswordReset' ) ; $ passwordReset -> setConfig ( $ this -> config ) -> handlePasswordReset ( $ httpRequest ) ; }
7598	public function render ( $ sGlyphicon , array $ aGlyphiconAttributes = null ) { if ( ! is_scalar ( $ sGlyphicon ) ) { throw new InvalidArgumentException ( 'Glyphicon expects a scalar value, "' . gettype ( $ sGlyphicon ) . '" given' ) ; } if ( empty ( $ aGlyphiconAttributes ) ) { $ aGlyphiconAttributes = array ( 'class' => 'glyphicon' ) ; } else { if ( empty ( $ aGlyphiconAttributes [ 'class' ] ) ) { $ aGlyphiconAttributes [ 'class' ] = 'glyphicon' ; } elseif ( ! preg_match ( '/(\s|^)glyphicon(\s|$)/' , $ aGlyphiconAttributes [ 'class' ] ) ) { $ aGlyphiconAttributes [ 'class' ] .= ' glyphicon' ; } } if ( strpos ( 'glyphicon-' , $ sGlyphicon ) !== 0 ) { $ sGlyphicon = 'glyphicon-' . $ sGlyphicon ; } if ( ! preg_match ( '/(\s|^)' . preg_quote ( $ sGlyphicon , '/' ) . '(\s|$)/' , $ aGlyphiconAttributes [ 'class' ] ) ) { $ aGlyphiconAttributes [ 'class' ] .= ' ' . $ sGlyphicon ; } return sprintf ( static :: $ glyphiconFormat , $ this -> createAttributesString ( $ aGlyphiconAttributes ) ) ; }
3824	protected function getFilterParameters ( $ objItemRenderer ) { $ filterUrlBuilder = System :: getContainer ( ) -> get ( 'metamodels.filter_url' ) ; $ filterUrl = $ filterUrlBuilder -> getCurrentFilterUrl ( ) ; $ result = [ ] ; foreach ( $ objItemRenderer -> getFilterSettings ( ) -> getParameters ( ) as $ name ) { if ( $ filterUrl -> hasSlug ( $ name ) ) { $ result [ $ name ] = $ filterUrl -> getSlug ( $ name ) ; } Input :: get ( $ name ) ; } return $ filterUrl -> getSlugParameters ( ) ; }
3809	protected function applyLegendConditions ( $ attributeId , $ activeLegendId ) { if ( ! isset ( $ this -> conditions [ $ activeLegendId ] ) ) { return ; } if ( ! isset ( $ this -> conditions [ $ attributeId ] ) ) { $ this -> conditions [ $ attributeId ] = new PropertyConditionChain ( ) ; } $ this -> conditions [ $ attributeId ] -> addCondition ( $ this -> conditions [ $ activeLegendId ] ) ; }
9181	public function forget ( $ args = [ ] ) { if ( ! empty ( $ args ) ) { if ( is_array ( $ args ) ) { $ args = implode ( '_' , $ args ) ; } if ( empty ( $ this -> forgetful ) ) { $ this -> forgetful = get_class_methods ( $ this ) ; } foreach ( $ this -> forgetful as $ method ) { $ cacheKey = str_replace ( '\\' , '_' , get_class ( $ this ) . '_' . $ method . '_' ) ; $ this -> forgetByKey ( $ cacheKey ) ; $ cacheKey = str_replace ( '\\' , '_' , get_class ( $ this ) . '_' . $ method . '_' . $ args ) ; $ this -> forgetByKey ( $ cacheKey ) ; } } else { $ key = $ this -> getRememberKey ( ) ; $ this -> forgetByKey ( $ key ) ; } return $ this ; }
4127	public function newDefaultAnnotationDriver ( $ paths = array ( ) ) { $ reader = new \ Doctrine \ Common \ Annotations \ SimpleAnnotationReader ( ) ; $ reader -> addNamespace ( 'Doctrine\ODM\CouchDB\Mapping\Annotations' ) ; return new \ Doctrine \ ODM \ CouchDB \ Mapping \ Driver \ AnnotationDriver ( $ reader , ( array ) $ paths ) ; }
4866	public function delete ( JobInterface $ job , array $ options = [ ] ) { $ result = $ this -> mongoCollection -> deleteOne ( [ '_id' => $ job -> getId ( ) ] ) ; return ( bool ) $ result -> getDeletedCount ( ) ; }
3577	protected function metaQuery ( Builder $ query , $ method , ArgumentBag $ args ) { if ( in_array ( $ method , [ 'pluck' , 'value' , 'aggregate' , 'orderBy' , 'lists' ] ) ) { return $ this -> metaJoinQuery ( $ query , $ method , $ args ) ; } return $ this -> metaHasQuery ( $ query , $ method , $ args ) ; }
8541	public function compile ( ) { if ( ! count ( $ this -> msgid ) ) return "" ; $ str = "" ; if ( $ this -> comments ) $ str .= implode ( self :: NEWLINE , $ this -> comments ) . self :: NEWLINE ; if ( $ this -> msgctxt ) $ str .= 'msgctxt "' . $ this -> msgctxt . '"' . self :: NEWLINE ; $ included_blocks = [ 'msgid' ] ; if ( $ this -> msgstr_plural ) $ included_blocks [ ] = 'msgid_plural' ; else $ included_blocks [ ] = 'msgstr' ; foreach ( $ included_blocks as $ key ) { if ( is_array ( $ this -> $ key ) ) { $ str .= "$key " ; $ str .= implode ( self :: NEWLINE , array_map ( [ $ this , 'quoteWrap' ] , $ this -> $ key ) ) . self :: NEWLINE ; } } if ( $ this -> msgid_plural && $ this -> msgstr_plural ) { foreach ( $ this -> msgstr_plural as $ plural_key => $ plural_message ) { $ str .= 'msgstr[' . $ plural_key . '] ' ; $ str .= implode ( self :: NEWLINE , array_map ( [ $ this , 'quoteWrap' ] , $ plural_message ) ) . self :: NEWLINE ; } } return trim ( $ str ) ; }
1197	private function htmlAttributesCallback ( $ name , $ value ) { if ( false === $ value || null === $ value ) { return '' ; } return ' ' . $ this -> renderHtmlAttribute ( $ name , $ value ) ; }
7453	protected function renderLTR ( ) : string { $ trail = '' ; if ( $ this -> before ) { $ trail .= '<span class="before">' . $ this -> before . '</span> ' ; } $ trail .= \ join ( ' <span class="sep delimiter">' . $ this -> delimiter . '</span> ' , $ this -> links ) ; if ( $ this -> after ) { $ trail .= ' <span class="after">' . $ this -> after . '</span>' ; } return $ trail ; }
1913	protected function generateCaptcha ( ) { if ( $ this -> arrCaptcha ) { return ; } $ int1 = random_int ( 1 , 9 ) ; $ int2 = random_int ( 1 , 9 ) ; $ this -> arrCaptcha = array ( 'int1' => $ int1 , 'int2' => $ int2 , 'sum' => $ int1 + $ int2 , 'key' => $ this -> strCaptchaKey , 'hashes' => $ this -> generateHashes ( $ int1 + $ int2 ) ) ; }
11003	public function URL ( $ path = '' , $ current_url = null ) { $ url = new URL ( $ this -> url ) ; $ path = ltrim ( $ path , '/' ) ; $ url -> set ( 'path' , $ url -> path . $ path ) ; if ( $ current_url instanceof URL ) { if ( $ url -> host === $ current_url -> host && $ url -> scheme === $ current_url -> scheme && $ url -> port === $ current_url -> port ) { $ url -> host = null ; $ url -> scheme = null ; } } return $ url ; }
7085	public function setDbQueryConditionsForDefaultOptionsLoader ( $ conditonsAndOptions ) { if ( ! is_array ( $ conditonsAndOptions ) && ! ( $ conditonsAndOptions instanceof DbExpr ) && ! ( $ conditonsAndOptions instanceof \ Closure ) ) { throw new \ InvalidArgumentException ( '$conditonsAndOptions argument must be a string, DbExpr or a Closure' ) ; } $ this -> dbQueryConditionsForDefaultOptionsLoader = $ conditonsAndOptions ; return $ this ; }
805	private function hasVoidReturn ( Tokens $ tokens , $ startIndex , $ endIndex ) { $ tokensAnalyzer = new TokensAnalyzer ( $ tokens ) ; for ( $ i = $ startIndex ; $ i < $ endIndex ; ++ $ i ) { if ( ( $ tokens [ $ i ] -> isGivenKind ( T_CLASS ) && $ tokensAnalyzer -> isAnonymousClass ( $ i ) ) || ( $ tokens [ $ i ] -> isGivenKind ( T_FUNCTION ) && $ tokensAnalyzer -> isLambda ( $ i ) ) ) { $ i = $ tokens -> getNextTokenOfKind ( $ i , [ '{' ] ) ; $ i = $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_CURLY_BRACE , $ i ) ; continue ; } if ( $ tokens [ $ i ] -> isGivenKind ( [ T_YIELD , T_YIELD_FROM ] ) ) { return false ; } if ( ! $ tokens [ $ i ] -> isGivenKind ( T_RETURN ) ) { continue ; } $ i = $ tokens -> getNextMeaningfulToken ( $ i ) ; if ( ! $ tokens [ $ i ] -> equals ( ';' ) ) { return false ; } } return true ; }
11637	public function getTableRegistry ( ) { if ( is_null ( $ this -> _tableRegistry ) ) { $ objectTypeClass = Yii :: $ app -> classes [ 'ObjectTypeRegistry' ] ; $ this -> _tableRegistry = [ ] ; if ( $ objectTypeClass :: tableExists ( ) ) { $ om = $ objectTypeClass :: find ( ) -> all ( ) ; $ this -> _tableRegistry = ArrayHelper :: index ( $ om , 'name' ) ; } } return $ this -> _tableRegistry ; }
10932	public function hasRowsWith ( string $ tablename , string $ colName , $ colValue ) : bool { return ( $ this -> countRowsWith ( $ tablename , $ colName , $ colValue ) > 0 ) ; }
11010	public function addDefaultSrc ( string $ source ) : bool { if ( ! in_array ( $ source , $ this -> tags [ 'default-src' ] ) ) { $ this -> tags [ 'default-src' ] [ ] = $ source ; return true ; } return false ; }
4201	private function addMethodsMin ( Event $ abs ) { $ obj = $ abs -> getSubject ( ) ; if ( \ method_exists ( $ obj , '__toString' ) ) { $ abs [ 'methods' ] [ '__toString' ] = array ( 'returnValue' => \ call_user_func ( array ( $ obj , '__toString' ) ) , 'visibility' => 'public' , ) ; } if ( \ method_exists ( $ obj , '__get' ) ) { $ abs [ 'methods' ] [ '__get' ] = array ( 'visibility' => 'public' ) ; } if ( \ method_exists ( $ obj , '__set' ) ) { $ abs [ 'methods' ] [ '__set' ] = array ( 'visibility' => 'public' ) ; } return ; }
7406	public function replace ( $ in ) { $ this -> _massageBlockInput ( $ in ) ; foreach ( $ in as $ k => $ v ) { $ this -> offsetSet ( $ k , $ v ) ; } }
6280	public function nextkey ( ) { if ( $ this -> keyIterPos >= $ this -> keyIterStop ) { return false ; } $ keyLen = $ this -> readInt31 ( $ this -> keyIterPos ) ; $ dataLen = $ this -> readInt31 ( $ this -> keyIterPos + 4 ) ; $ key = $ this -> read ( $ this -> keyIterPos + 8 , $ keyLen ) ; $ this -> keyIterPos += 8 + $ keyLen + $ dataLen ; return $ key ; }
9033	protected function mapField ( $ field ) { if ( ! $ this -> classMetadata -> hasField ( $ field ) ) { $ this -> classMetadata -> mapField ( [ 'fieldName' => $ field , 'type' => 'datetime' , 'nullable' => true , ] ) ; } }
2809	public function getVisiblePanels ( ) { if ( $ this -> visiblePanels === null ) { $ this -> visiblePanels = array ( ) ; $ panels = $ this -> getSortedChildBlocks ( ) ; foreach ( $ panels as $ panel ) { if ( ! $ panel instanceof Sheep_Debug_Block_Panel ) { continue ; } $ this -> visiblePanels [ ] = $ panel ; } } return $ this -> visiblePanels ; }
577	protected static function normalizeRoute ( $ route ) { $ route = Yii :: getAlias ( ( string ) $ route ) ; if ( strncmp ( $ route , '/' , 1 ) === 0 ) { return ltrim ( $ route , '/' ) ; } if ( Yii :: $ app -> controller === null ) { throw new InvalidArgumentException ( "Unable to resolve the relative route: $route. No active controller is available." ) ; } if ( strpos ( $ route , '/' ) === false ) { return $ route === '' ? Yii :: $ app -> controller -> getRoute ( ) : Yii :: $ app -> controller -> getUniqueId ( ) . '/' . $ route ; } return ltrim ( Yii :: $ app -> controller -> module -> getUniqueId ( ) . '/' . $ route , '/' ) ; }
177	public static function htmlDecode ( $ data , $ valuesOnly = true ) { $ d = [ ] ; foreach ( $ data as $ key => $ value ) { if ( ! $ valuesOnly && is_string ( $ key ) ) { $ key = htmlspecialchars_decode ( $ key , ENT_QUOTES ) ; } if ( is_string ( $ value ) ) { $ d [ $ key ] = htmlspecialchars_decode ( $ value , ENT_QUOTES ) ; } elseif ( is_array ( $ value ) ) { $ d [ $ key ] = static :: htmlDecode ( $ value ) ; } else { $ d [ $ key ] = $ value ; } } return $ d ; }
5294	protected function execute ( InputInterface $ input , OutputInterface $ output ) { $ fontFile = realpath ( $ input -> getArgument ( 'font-file' ) ) ; if ( $ fontFile === false || ! file_exists ( $ fontFile ) ) { throw new \ InvalidArgumentException ( '"' . $ input -> getArgument ( 'font-file' ) . '" does not exist' ) ; } $ outputFile = $ input -> getArgument ( 'output-file' ) ; $ generator = new IconFontGenerator ; $ output -> writeln ( 'reading font file from "' . $ fontFile . '" ...' ) ; $ generator -> generateFromFont ( new Font ( array ( ) , file_get_contents ( $ fontFile ) ) ) ; $ output -> writeln ( 'writing CSS file to "' . $ outputFile . '" ...' ) ; file_put_contents ( $ outputFile , $ generator -> getCss ( ) ) ; $ output -> getFormatter ( ) -> setStyle ( 'success' , new OutputFormatterStyle ( null , null , array ( 'bold' , 'reverse' ) ) ) ; $ output -> writeln ( '<success>created CSS file successfully</success>' ) ; }
2030	public static function findPublishedRootPages ( array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = array ( "$t.type=?" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } return static :: findBy ( $ arrColumns , 'root' , $ arrOptions ) ; }
3631	public function events ( Request $ request ) : array { $ type = ( int ) $ request -> query ( 'type' ) ; if ( $ type === 1 ) { return ServerListenerCollector :: getCollector ( ) ; } if ( $ type === 2 ) { return SwooleListenerCollector :: getCollector ( ) ; } return [ 'server' => ServerListenerCollector :: getCollector ( ) , 'swoole' => SwooleListenerCollector :: getCollector ( ) , ] ; }
1770	public function getErrorsAsString ( $ strSeparator = null ) { if ( $ strSeparator === null ) { $ strSeparator = '<br' . $ this -> strTagEnding . "\n" ; } return $ this -> hasErrors ( ) ? implode ( $ strSeparator , $ this -> arrErrors ) : '' ; }
6832	protected function getSupplierOrderItemFromEvent ( ResourceEventInterface $ event ) { $ item = $ event -> getResource ( ) ; if ( ! $ item instanceof SupplierOrderItemInterface ) { throw new InvalidArgumentException ( "Expected instance of SupplierOrderItemInterface." ) ; } return $ item ; }
1601	public function injectRobots ( ) { $ headers = \ Craft :: $ app -> getResponse ( ) -> getHeaders ( ) ; if ( \ Craft :: $ app -> config -> general -> devMode ) { $ headers -> set ( 'x-robots-tag' , 'none, noimageindex' ) ; return ; } list ( $ field , $ element ) = $ this -> _getElementAndSeoFields ( ) ; $ robots = $ field -> robots ; if ( $ robots !== null ) $ headers -> set ( 'x-robots-tag' , $ robots ) ; if ( isset ( $ element -> expiryDate ) ) $ expiry = $ element -> expiryDate -> format ( \ DATE_RFC850 ) ; else $ expiry = null ; if ( $ expiry ) $ headers -> add ( 'x-robots-tag' , 'unavailable_after: ' . $ expiry ) ; }
3366	private static function apache_modules ( ) { $ mods = WP_CLI :: get_config ( 'apache_modules' ) ; if ( ! empty ( $ mods ) && ! function_exists ( 'apache_get_modules' ) ) { global $ is_apache ; $ is_apache = true ; $ _SERVER [ 'SCRIPT_FILENAME' ] = ABSPATH ; function apache_get_modules ( ) { return WP_CLI :: get_config ( 'apache_modules' ) ; } } }
188	private function getColumnDefinition ( $ table , $ column ) { $ row = $ this -> db -> createCommand ( 'SHOW CREATE TABLE ' . $ this -> db -> quoteTableName ( $ table ) ) -> queryOne ( ) ; if ( $ row === false ) { throw new Exception ( "Unable to find column '$column' in table '$table'." ) ; } if ( isset ( $ row [ 'Create Table' ] ) ) { $ sql = $ row [ 'Create Table' ] ; } else { $ row = array_values ( $ row ) ; $ sql = $ row [ 1 ] ; } $ sql = preg_replace ( '/^[^(]+\((.*)\).*$/' , '\1' , $ sql ) ; $ sql = str_replace ( ', [' , ",\n[" , $ sql ) ; if ( preg_match_all ( '/^\s*\[(.*?)\]\s+(.*?),?$/m' , $ sql , $ matches ) ) { foreach ( $ matches [ 1 ] as $ i => $ c ) { if ( $ c === $ column ) { return $ matches [ 2 ] [ $ i ] ; } } } return null ; }
2123	public function addMultiple ( array $ arrFiles , $ strVersion = null , $ strMedia = 'screen' ) { foreach ( $ arrFiles as $ strFile ) { $ this -> add ( $ strFile , $ strVersion , $ strMedia ) ; } }
9793	public function hasDataValidation ( ) { if ( ! isset ( $ this -> parent ) ) { throw new Exception ( 'Cannot check for data validation when cell is not bound to a worksheet' ) ; } return $ this -> getWorksheet ( ) -> dataValidationExists ( $ this -> getCoordinate ( ) ) ; }
3848	public static function perform ( ) { self :: upgradeJumpTo ( ) ; self :: upgradeDcaSettingsPublished ( ) ; self :: changeSubPalettesToConditions ( ) ; self :: upgradeClosed ( ) ; self :: upgradeInputScreenMode ( ) ; self :: upgradeInputScreenFlag ( ) ; }
4294	public static function getType ( $ val , & $ typeMore = null ) { if ( \ is_string ( $ val ) ) { $ type = 'string' ; if ( \ is_numeric ( $ val ) ) { $ typeMore = 'numeric' ; } elseif ( $ val === self :: UNDEFINED ) { $ type = 'undefined' ; } elseif ( $ val === self :: RECURSION ) { $ type = 'recursion' ; } } elseif ( \ is_array ( $ val ) ) { if ( \ in_array ( self :: ABSTRACTION , $ val , true ) ) { $ type = $ val [ 'type' ] ; $ typeMore = 'abstraction' ; } elseif ( AbstractArray :: isCallable ( $ val ) ) { $ type = 'callable' ; $ typeMore = 'raw' ; } else { $ type = 'array' ; $ typeMore = 'raw' ; } } elseif ( \ is_bool ( $ val ) ) { $ type = 'bool' ; $ typeMore = \ json_encode ( $ val ) ; } elseif ( \ is_float ( $ val ) ) { $ type = 'float' ; } elseif ( \ is_int ( $ val ) ) { $ type = 'int' ; } elseif ( \ is_null ( $ val ) ) { $ type = 'null' ; } elseif ( \ is_object ( $ val ) ) { $ type = 'object' ; $ typeMore = 'raw' ; } elseif ( \ is_resource ( $ val ) || \ strpos ( \ print_r ( $ val , true ) , 'Resource' ) === 0 ) { $ type = 'resource' ; $ typeMore = 'raw' ; } return $ type ; }
6655	public function normalizeHeaders ( $ params ) { $ out = '' ; foreach ( $ params as $ key => $ param ) { $ out .= $ key . '="' . rawurlencode ( trim ( $ param ) ) . '",' ; } return rtrim ( $ out , ',' ) ; }
11836	public function addAction ( AbstractAction $ action ) { $ action -> setGroup ( $ this ) ; $ this -> actions [ $ action -> getName ( ) ] = $ action ; return $ this ; }
2015	public static function load ( $ class ) { if ( class_exists ( $ class , false ) || interface_exists ( $ class , false ) || trait_exists ( $ class , false ) ) { return ; } $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( isset ( self :: $ classes [ $ class ] ) ) { if ( Config :: get ( 'debugMode' ) ) { $ GLOBALS [ 'TL_DEBUG' ] [ 'classes_set' ] [ $ class ] = $ class ; } include $ rootDir . '/' . self :: $ classes [ $ class ] ; } elseif ( ( $ namespaced = self :: findClass ( $ class ) ) !== null ) { if ( ! class_exists ( $ namespaced , false ) && ! interface_exists ( $ namespaced , false ) && ! trait_exists ( $ namespaced , false ) ) { if ( Config :: get ( 'debugMode' ) ) { $ GLOBALS [ 'TL_DEBUG' ] [ 'classes_aliased' ] [ $ class ] = $ namespaced ; } include $ rootDir . '/' . self :: $ classes [ $ namespaced ] ; } class_alias ( $ namespaced , $ class ) ; } elseif ( strncmp ( $ class , 'Contao\\' , 7 ) !== 0 ) { $ namespaced = 'Contao\\' . $ class ; if ( class_exists ( $ namespaced ) || interface_exists ( $ namespaced ) || trait_exists ( $ namespaced ) ) { if ( Config :: get ( 'debugMode' ) ) { $ GLOBALS [ 'TL_DEBUG' ] [ 'classes_composerized' ] [ $ class ] = $ namespaced ; } if ( ! class_exists ( $ class , false ) && ! interface_exists ( $ class , false ) && ! trait_exists ( $ class , false ) ) { class_alias ( $ namespaced , $ class ) ; } } } }
12121	public function getLastModified ( Request $ request ) { $ minModified = $ this -> getLastMinModifiedDate ( ) ; $ optionalLastModified = Option :: fromValue ( $ this -> cache -> fetch ( $ this -> getCacheKeyRequest ( sha1 ( $ request -> getUri ( ) ) , 'lastmodified' ) ) , false ) ; if ( $ optionalLastModified -> isEmpty ( ) ) { return $ minModified ; } return max ( $ minModified , new \ DateTime ( $ optionalLastModified -> get ( ) ) ) ; }
3922	private function resizeImage ( $ fileName ) { list ( $ width , $ height , $ mode ) = $ this -> getResizeImages ( ) ; if ( $ this -> getShowImages ( ) && ( $ width || $ height || $ mode ) ) { if ( $ this -> imageFactory ) { $ image = $ this -> imageFactory -> create ( $ this -> rootDir . '/' . $ fileName , [ $ width , $ height , $ mode ] ) ; return $ image -> getUrl ( $ this -> rootDir ) ; } $ event = new ResizeImageEvent ( $ fileName , $ width , $ height , $ mode ) ; $ this -> dispatcher -> dispatch ( ContaoEvents :: IMAGE_RESIZE , $ event ) ; return $ event -> getResultImage ( ) ; } return $ fileName ; }
2219	public static function countPublishedByPids ( $ arrPids , $ blnFeatured = null , array $ arrOptions = array ( ) ) { if ( empty ( $ arrPids ) || ! \ is_array ( $ arrPids ) ) { return 0 ; } $ t = static :: $ strTable ; $ arrColumns = array ( "$t.pid IN(" . implode ( ',' , array_map ( '\intval' , $ arrPids ) ) . ")" ) ; if ( $ blnFeatured === true ) { $ arrColumns [ ] = "$t.featured='1'" ; } elseif ( $ blnFeatured === false ) { $ arrColumns [ ] = "$t.featured=''" ; } if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } return static :: countBy ( $ arrColumns , null , $ arrOptions ) ; }
2359	public function isPreviewMode ( ) : bool { $ token = $ this -> getToken ( FrontendUser :: SECURITY_SESSION_KEY ) ; return $ token instanceof FrontendPreviewToken && $ token -> showUnpublished ( ) ; }
4035	public function getTemplatesForBase ( $ templateBaseName ) { $ allTemplates = array_replace_recursive ( $ this -> fetchTemplatesFromThemes ( $ templateBaseName ) , $ this -> fetchRootTemplates ( $ templateBaseName ) , $ this -> fetchTemplatesFromResourceDirectories ( $ templateBaseName ) ) ; $ templateList = array ( ) ; foreach ( $ allTemplates as $ template => $ themeList ) { $ templateList [ $ template ] = sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'template_in_theme' ] , $ template , implode ( ', ' , $ themeList ) ) ; } ksort ( $ templateList ) ; return array_unique ( $ templateList ) ; }
9767	function least ( $ value ) : self { $ target = $ this -> hasFlag ( 'length' ) ? $ this -> getLength ( $ this -> target ) : $ this -> target ; return $ this -> expect ( $ target , greaterThanOrEqual ( $ value ) ) ; }
319	public function registerJsFile ( $ url , $ options = [ ] , $ key = null ) { $ url = Yii :: getAlias ( $ url ) ; $ key = $ key ? : $ url ; $ depends = ArrayHelper :: remove ( $ options , 'depends' , [ ] ) ; if ( empty ( $ depends ) ) { $ position = ArrayHelper :: remove ( $ options , 'position' , self :: POS_END ) ; $ this -> jsFiles [ $ position ] [ $ key ] = Html :: jsFile ( $ url , $ options ) ; } else { $ this -> getAssetManager ( ) -> bundles [ $ key ] = Yii :: createObject ( [ 'class' => AssetBundle :: className ( ) , 'baseUrl' => '' , 'js' => [ strncmp ( $ url , '//' , 2 ) === 0 ? $ url : ltrim ( $ url , '/' ) ] , 'jsOptions' => $ options , 'depends' => ( array ) $ depends , ] ) ; $ this -> registerAssetBundle ( $ key ) ; } }
11546	public function changeSecurityQuestion ( $ data ) { if ( ! ( $ user = $ this -> hydrate ( $ data , $ this -> getChangeSecurityQuestionForm ( ) ) ) ) { return ; } $ eventManager = $ this -> getEventManager ( ) ; $ eventManager -> trigger ( __METHOD__ , $ this , $ user ) ; $ this -> getMapper ( ) -> update ( $ user ) -> save ( ) ; $ eventManager -> trigger ( __METHOD__ . '.post' , $ this , $ user ) ; return $ user ; }
10634	public function getArrayFromJsonFile ( $ strFilePath , $ strFileName ) { $ jSonContent = $ this -> getFileJsonContent ( $ strFilePath , $ strFileName ) ; $ arrayToReturn = json_decode ( $ jSonContent , true ) ; if ( json_last_error ( ) != JSON_ERROR_NONE ) { $ fName = $ this -> gluePathWithFileName ( $ strFilePath , $ strFileName ) ; throw new \ RuntimeException ( sprintf ( 'Unable to interpret JSON from %s file...' , $ fName ) ) ; } return $ arrayToReturn ; }
5976	public function media ( ) { if ( ! $ this -> media instanceof MediaController ) { $ this -> media = new MediaController ( $ this -> getClient ( ) , $ this -> cachePolicy , $ this -> cache ) ; $ this -> media -> setLogger ( $ this -> logger ) ; } return $ this -> media ; }
9797	public function getHyperlink ( ) { if ( ! isset ( $ this -> parent ) ) { throw new Exception ( 'Cannot get hyperlink for cell that is not bound to a worksheet' ) ; } return $ this -> getWorksheet ( ) -> getHyperlink ( $ this -> getCoordinate ( ) ) ; }
7695	function MsPowerpoint_InitSlideLst ( $ Master = false ) { if ( $ Master ) { $ RefLst = & $ this -> OpenXmlSlideMasterLst ; } else { $ RefLst = & $ this -> OpenXmlSlideLst ; } if ( $ RefLst !== false ) return $ RefLst ; $ PresFile = 'ppt/presentation.xml' ; $ prefix = ( $ Master ) ? 'slideMasters/' : 'slides/' ; $ o = $ this -> OpenXML_Rels_GetObj ( 'ppt/presentation.xml' , $ prefix ) ; $ Txt = $ this -> FileRead ( $ PresFile ) ; if ( $ Txt === false ) return false ; $ p = 0 ; $ i = 0 ; $ lst = array ( ) ; $ tag = ( $ Master ) ? 'p:sldMasterId' : 'p:sldId' ; while ( $ loc = clsTbsXmlLoc :: FindStartTag ( $ Txt , $ tag , $ p ) ) { $ i ++ ; $ rid = $ loc -> GetAttLazy ( 'r:id' ) ; if ( $ rid === false ) { $ this -> RaiseError ( "(Init Slide List) attribute 'r:id' is missing for slide #$i in '$PresFile'." ) ; } elseif ( isset ( $ o -> TargetLst [ $ rid ] ) ) { $ f = 'ppt/' . $ o -> TargetLst [ $ rid ] ; $ lst [ ] = array ( 'file' => $ f , 'idx' => $ this -> FileGetIdx ( $ f ) , 'rid' => $ rid ) ; } else { $ this -> RaiseError ( "(Init Slide List) Slide corresponding to rid=$rid is not found in the Rels file of '$PresFile'." ) ; } $ p = $ loc -> PosEnd ; } $ RefLst = $ lst ; return $ RefLst ; }
12513	public static function copy ( $ src , $ dest , $ force = false , $ delete = false ) { $ src = Path :: clean ( $ src ) ; $ dest = Path :: clean ( $ dest ) ; $ fs = new Filesystem ( ) ; try { $ fs -> mirror ( $ src , $ dest , null , [ 'override' => $ force , 'delete' => $ delete , 'copy_on_windows' => true ] ) ; } catch ( IOExceptionInterface $ e ) { throw new Exception ( Helper :: getTranslation ( 'CANNOT_FIND_SOURCE' ) . ' ' . $ e -> getPath ( ) ) ; } return true ; }
10879	protected function convertExceptionToArray ( $ exception ) { if ( ! YII_DEBUG && ! $ exception instanceof UserException && ! $ exception instanceof HttpException ) { $ exception = new HttpException ( 500 , 'There was an error at the server.' ) ; } $ array = [ 'name' => ( $ exception instanceof Exception || $ exception instanceof ErrorException ) ? $ exception -> getName ( ) : 'Exception' , 'message' => $ exception -> getMessage ( ) , 'code' => $ exception -> getCode ( ) , ] ; if ( $ exception instanceof HttpException ) { $ array [ 'status' ] = $ exception -> statusCode ; } if ( YII_DEBUG ) { $ array [ 'type' ] = get_class ( $ exception ) ; if ( ! $ exception instanceof UserException ) { $ array [ 'file' ] = $ exception -> getFile ( ) ; $ array [ 'line' ] = $ exception -> getLine ( ) ; $ array [ 'stack-trace' ] = explode ( "\n" , $ exception -> getTraceAsString ( ) ) ; if ( $ exception instanceof \ yii \ db \ Exception ) { $ array [ 'error-info' ] = $ exception -> errorInfo ; } } } if ( ( $ prev = $ exception -> getPrevious ( ) ) !== null ) { $ array [ 'previous' ] = $ this -> convertExceptionToArray ( $ prev ) ; } return $ array ; }
1824	public function originalRow ( ) { $ row = $ this -> row ( ) ; if ( ! $ this -> isModified ( ) ) { return $ row ; } $ originalRow = array ( ) ; foreach ( $ row as $ k => $ v ) { $ originalRow [ $ k ] = $ this -> arrModified [ $ k ] ?? $ v ; } return $ originalRow ; }
6358	public function setTimezone ( $ timezone ) { try { $ this -> timestamp -> setTimezone ( new DateTimeZone ( $ timezone ) ) ; } catch ( Exception $ e ) { throw new TimestampException ( __METHOD__ . ': Invalid timezone.' , $ e -> getCode ( ) , $ e ) ; } }
10179	public function removeColumn ( $ column ) { foreach ( $ this -> getCoordinates ( ) as $ coord ) { sscanf ( $ coord , '%[A-Z]%d' , $ c , $ r ) ; if ( $ c == $ column ) { $ this -> delete ( $ coord ) ; } } }
1646	public function getLength ( DistanceInterface $ calculator ) : float { $ distance = 0.0 ; if ( count ( $ this -> points ) <= 1 ) { return $ distance ; } foreach ( $ this -> getSegments ( ) as $ segment ) { $ distance += $ segment -> getLength ( $ calculator ) ; } return $ distance ; }
4799	function exec ( $ query ) { $ conn = $ this -> getConn ( ) ; $ sql = $ conn -> quote ( $ query ) ; return $ conn -> exec ( $ sql ) ; }
4777	public function getOutput ( ItemInterface $ item , $ userId ) { if ( $ item -> getCacheTime ( ) ) { $ cache = $ this -> cache -> getItem ( $ item -> getId ( ) . $ userId ) ; $ cache -> expiresAfter ( $ item -> getCacheTime ( ) ) ; if ( false === $ cache -> isHit ( ) ) { $ cache -> set ( $ item -> getTemplate ( ) ? $ this -> engine -> render ( $ item -> getTemplate ( ) , [ 'widget' => $ item ] ) : $ item -> getContent ( ) ) ; $ this -> cache -> save ( $ cache ) ; } return $ cache -> get ( ) ; } return $ item -> getTemplate ( ) ? $ this -> engine -> render ( $ item -> getTemplate ( ) , [ 'widget' => $ item ] ) : $ item -> getContent ( ) ; }
3189	public function getLastTimestamp ( $ tags ) { $ range = $ this -> getRange ( $ tags ) ; $ length = count ( $ range ) ; $ last = false ; if ( $ length ) { $ last = $ range [ $ length - 1 ] -> getTimestamp ( ) ; } return $ last ; }
8418	public static function registerDatabase ( string $ alias ) { if ( isset ( self :: $ databases [ $ alias ] ) === false ) { self :: $ databases [ $ alias ] = new static ( $ alias ) ; } }
2691	public function getForceLossyUrl ( ) { $ baseFile = $ this -> getBaseFile ( ) ; $ extension = pathinfo ( $ baseFile , PATHINFO_EXTENSION ) ; $ url = $ this -> getBaseFileUrl ( $ baseFile ) ; if ( $ extension == 'png' || $ extension == 'bmp' ) { if ( $ this -> isFastlyImageOptimizationEnabled ( ) == false ) { $ this -> lossyUrl = $ url . '?format=jpeg' ; } else { $ this -> lossyParam = '&format=jpeg' ; } } }
6806	public function create ( string $ locale = null , string $ currency = null ) { $ locale = $ locale ?? $ this -> localeProvider -> getCurrentLocale ( ) ; $ currency = $ currency ?? $ this -> currencyProvider -> getCurrentCurrency ( ) ; if ( isset ( $ this -> cache [ $ key = strtolower ( "$locale-$currency" ) ] ) ) { return $ this -> cache [ $ key ] ; } return $ this -> cache [ $ key ] = new Formatter ( $ locale , $ currency ) ; }
6448	public function getBestLanguageMatch ( array $ supportedLanguages , array $ languageHeaders ) : ? string { usort ( $ languageHeaders , [ $ this , 'compareAcceptLanguageHeaders' ] ) ; $ rankedLanguageHeaders = array_filter ( $ languageHeaders , [ $ this , 'filterZeroScores' ] ) ; $ rankedLanguageHeaderValues = $ this -> getLanguageValuesFromHeaders ( $ rankedLanguageHeaders ) ; foreach ( $ rankedLanguageHeaderValues as $ language ) { $ languageParts = explode ( '-' , $ language ) ; do { foreach ( $ supportedLanguages as $ supportedLanguage ) { if ( $ language === '*' || implode ( '-' , $ languageParts ) === $ supportedLanguage ) { return $ supportedLanguage ; } } array_pop ( $ languageParts ) ; } while ( count ( $ languageParts ) > 0 ) ; } return null ; }
1248	private static function getHomeDir ( ) { if ( $ homeDir = getenv ( 'HOME' ) ) { return $ homeDir ; } $ homeDrive = getenv ( 'HOMEDRIVE' ) ; $ homePath = getenv ( 'HOMEPATH' ) ; return ( $ homeDrive && $ homePath ) ? $ homeDrive . $ homePath : null ; }
4560	public function translate ( Translatable $ model ) { $ properties = $ this -> getProperties ( $ model ) ; foreach ( $ properties as $ property ) { $ get = 'get' . $ property -> getName ( ) ; $ set = 'set' . $ property -> getName ( ) ; $ values = [ ] ; foreach ( $ model -> getTranslations ( ) as $ translation ) { $ values [ $ translation -> getLocale ( ) ] = $ translation -> $ get ( ) ; } $ model -> $ set ( $ values ) ; } }
12242	public function asPrettyXML ( $ filepath = null ) { $ xml = dom_import_simplexml ( new SimpleXMLElement ( $ this -> asXML ( ) ) ) ; $ xsl = new DOMDocument ; $ xsl -> loadXML ( '<?xml version="1.0" encoding="utf-8"?><xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"> <xsl:output method="xml" indent="yes" /> <xsl:template match="text()"> <!-- remove everything that contains only whitespace, with at least one LF ) ; $ xslt = new XSLTProcessor ; $ xslt -> importStylesheet ( $ xsl ) ; $ result = trim ( $ xslt -> transformToXML ( $ xml ) ) ; if ( isset ( $ filepath ) ) { return ( bool ) file_put_contents ( $ filepath , $ result ) ; } return $ result ; }
2836	public function getLayoutUpdates ( ) { if ( $ this -> uncompressedLayoutUpdates === null ) { $ this -> uncompressedLayoutUpdates = $ this -> layoutUpdates ? json_decode ( gzuncompress ( $ this -> layoutUpdates ) , true ) : array ( ) ; } return $ this -> uncompressedLayoutUpdates ; }
3794	private function checkForAction ( $ clipboard , $ action ) { $ filter = new Filter ( ) ; $ filter -> andActionIs ( $ action ) ; $ items = $ clipboard -> fetch ( $ filter ) ; if ( $ items === null ) { return ; } foreach ( $ items as $ item ) { $ itemProviderName = $ item -> getDataProviderName ( ) ; $ modelId = $ item -> getModelId ( ) ; if ( $ this -> providerName !== $ itemProviderName ) { continue ; } if ( ! $ modelId ) { $ this -> checkEmpty ( $ action ) ; continue ; } $ containedModel = $ this -> getModelById ( $ modelId -> getId ( ) ) ; if ( $ this -> currentModel == null ) { $ this -> checkForRoot ( $ containedModel , $ action ) ; } elseif ( $ containedModel ) { $ this -> checkForModel ( $ containedModel , $ action ) ; } else { $ this -> checkEmpty ( $ action ) ; } } }
7111	static public function isValidReason ( $ reason , $ throw = true ) { if ( in_array ( $ reason , static :: getReasons ( ) , true ) ) { return true ; } if ( $ throw ) { throw new InvalidArgumentException ( "Invalid stock adjustment reason." ) ; } return false ; }
6443	public function httpRequest ( $ url ) { if ( DEBUG ) echo "HTTP request: $url\n" ; $ curl = curl_init ( ) ; curl_setopt ( $ curl , CURLOPT_URL , $ url ) ; curl_setopt ( $ curl , CURLOPT_HEADER , 0 ) ; curl_setopt ( $ curl , CURLOPT_RETURNTRANSFER , true ) ; curl_setopt ( $ curl , CURLOPT_TIMEOUT , CURL_TIMEOUT ) ; curl_setopt ( $ curl , CURLOPT_USERAGENT , SPIDER_NAME ) ; curl_setopt ( $ curl , CURLOPT_VERBOSE , false ) ; curl_setopt ( $ curl , CURLOPT_MAXREDIRS , 4 ) ; curl_setopt ( $ curl , CURLOPT_FOLLOWLOCATION , true ) ; $ response [ 'file' ] = curl_exec ( $ curl ) ; $ response [ 'status' ] = curl_getinfo ( $ curl ) ; $ response [ 'error' ] = curl_error ( $ curl ) ; curl_exec ( $ curl ) ; curl_close ( $ curl ) ; if ( DEBUG === 'verbose' ) { echo "Retrieved HTTP:\n" ; var_dump ( $ response [ 'status' ] ) ; var_dump ( $ response [ 'error' ] ) ; } if ( $ response [ 'file' ] == '' ) die ( "Error while making the HTTP request: no HTML retrieved." ) ; return $ response ; }
657	public function release ( $ name ) { if ( $ this -> releaseLock ( $ name ) ) { $ index = array_search ( $ name , $ this -> _locks ) ; if ( $ index !== false ) { unset ( $ this -> _locks [ $ index ] ) ; } return true ; } return false ; }
7529	function dumpLocation ( ) { return ( ( $ this -> parent ) ? ( ( $ p = $ this -> parent -> dumpLocation ( ) ) ? $ p . ' > ' : '' ) . $ this -> tag . '(' . $ this -> typeIndex ( ) . ')' : '' ) ; }
12224	public function paginate ( $ keys = [ ] , $ perPage = null ) { $ this -> buildIfNotBuilded ( ) ; $ keys = $ keys == [ ] ? $ this -> keys ( ) : $ keys ; if ( ! $ keys ) { return $ this -> builder -> paginate ( $ perPage ) ; } return $ this -> builder -> withColumns ( $ keys ) -> paginate ( $ perPage ) ; }
663	public function getMaster ( ) { if ( $ this -> _master === false ) { $ this -> _master = $ this -> shuffleMasters ? $ this -> openFromPool ( $ this -> masters , $ this -> masterConfig ) : $ this -> openFromPoolSequentially ( $ this -> masters , $ this -> masterConfig ) ; } return $ this -> _master ; }
2050	public function findBy ( $ strColumn , $ varValue ) { if ( parent :: findBy ( $ strColumn , $ varValue ) === false ) { return false ; } $ this -> arrGroups = $ this -> groups ; return true ; }
6927	protected function notify ( $ type , $ resource ) { $ notify = $ this -> builder -> create ( $ type , $ resource ) ; if ( ! $ this -> builder -> build ( $ notify ) ) { return ; } $ this -> queue -> add ( $ notify ) ; }
855	public function insertAt ( $ index , $ items ) { $ items = \ is_array ( $ items ) || $ items instanceof self ? $ items : [ $ items ] ; $ itemsCnt = \ count ( $ items ) ; if ( 0 === $ itemsCnt ) { return ; } $ oldSize = \ count ( $ this ) ; $ this -> changed = true ; $ this -> blockEndCache = [ ] ; $ this -> setSize ( $ oldSize + $ itemsCnt ) ; for ( $ i = $ oldSize + $ itemsCnt - 1 ; $ i >= $ index ; -- $ i ) { $ oldItem = parent :: offsetExists ( $ i - $ itemsCnt ) ? parent :: offsetGet ( $ i - $ itemsCnt ) : new Token ( '' ) ; parent :: offsetSet ( $ i , $ oldItem ) ; } for ( $ i = 0 ; $ i < $ itemsCnt ; ++ $ i ) { if ( '' === $ items [ $ i ] -> getContent ( ) ) { throw new \ InvalidArgumentException ( 'Must not add empty token to collection.' ) ; } $ this -> registerFoundToken ( $ items [ $ i ] ) ; parent :: offsetSet ( $ i + $ index , $ items [ $ i ] ) ; } }
8521	public function setListingQualityRecommendations ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ListingQualityRecommendations' ] [ 'FieldValue' ] = $ value ; return $ this ; }
1884	public static function count ( array $ arrOptions ) { $ strQuery = "SELECT COUNT(*) AS count FROM " . $ arrOptions [ 'table' ] ; if ( $ arrOptions [ 'column' ] !== null ) { $ strQuery .= " WHERE " . ( \ is_array ( $ arrOptions [ 'column' ] ) ? implode ( " AND " , $ arrOptions [ 'column' ] ) : $ arrOptions [ 'table' ] . '.' . Database :: quoteIdentifier ( $ arrOptions [ 'column' ] ) . "=?" ) ; } return $ strQuery ; }
127	public function ensureBinariesPresence ( PackageInterface $ package ) { $ this -> binaryInstaller -> installBinaries ( $ package , $ this -> getInstallPath ( $ package ) , false ) ; }
12763	public function remove ( $ name , $ path = null , $ domain = null , $ secure = false , $ httpOnly = false ) { if ( $ this -> exists ( $ name ) ) { $ expire = time ( ) - ( 3600 * 24 * 365 ) ; $ this -> set ( $ name , '' , $ expire , $ path , $ domain , $ secure , $ httpOnly ) ; } }
2185	public function onInitialize ( InitializeApplicationEvent $ event ) : void { $ this -> installAssets ( $ event ) ; $ this -> installContao ( $ event ) ; $ this -> createSymlinks ( $ event ) ; }
659	public function noCache ( callable $ callable ) { $ this -> _queryCacheInfo [ ] = false ; try { $ result = call_user_func ( $ callable , $ this ) ; array_pop ( $ this -> _queryCacheInfo ) ; return $ result ; } catch ( \ Exception $ e ) { array_pop ( $ this -> _queryCacheInfo ) ; throw $ e ; } catch ( \ Throwable $ e ) { array_pop ( $ this -> _queryCacheInfo ) ; throw $ e ; } }
1863	protected function validate ( ) { foreach ( \ func_get_args ( ) as $ strPath ) { if ( $ strPath == '' ) { throw new \ RuntimeException ( 'No file or folder name given' ) ; } elseif ( Validator :: isInsecurePath ( $ strPath ) ) { throw new \ RuntimeException ( 'Invalid file or folder name ' . $ strPath ) ; } } }
11011	public function getHeaderValue ( ) : ? string { $ headerValue = [ ] ; foreach ( $ this -> tags as $ name => $ tagValue ) { if ( is_array ( $ tagValue ) && ! empty ( $ tagValue ) ) { $ headerValue [ ] = $ name . ' ' . implode ( ' ' , $ tagValue ) . ';' ; } elseif ( is_string ( $ tagValue ) && ! empty ( $ tagValue ) ) { $ headerValue [ ] = $ name . ' ' . $ tagValue . ';' ; } elseif ( is_bool ( $ tagValue ) && $ tagValue ) { $ headerValue [ ] = $ name . ';' ; } } return $ headerValue ? implode ( ' ' , $ headerValue ) : null ; }
12260	private function _cacheCustomFields ( $ class ) { $ customFieldsGroups = $ this -> em -> getRepository ( 'ChillCustomFieldsBundle:CustomFieldsGroup' ) -> findBy ( array ( 'entity' => ( is_string ( $ class ) ) ? $ class : get_class ( $ class ) ) ) ; if ( ! $ customFieldsGroups ) { throw CustomFieldsHelperException :: customFieldsGroupNotFound ( ( is_string ( $ class ) ) ? $ class : get_class ( $ class ) ) ; } foreach ( $ customFieldsGroup as $ cfGroup ) { $ this -> _cacheCustomFields ( $ cfGroup ) ; } }
6446	public function completeLogin ( $ extrainputs = array ( ) ) { $ linkedin = $ this -> getClient ( ) ; $ this -> token = $ linkedin -> getAccessToken ( $ extrainputs [ 'code' ] ) ; return $ this -> getUserProfile ( ) ; }
4017	protected function handleLoadCallback ( $ field , $ value ) { if ( isset ( $ field [ 'load_callback' ] ) && is_array ( $ field [ 'load_callback' ] ) ) { foreach ( $ field [ 'load_callback' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ value = $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ value , $ this ) ; } } return $ value ; }
8654	private function convertSubmitFeed ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'SubmitFeed' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetMarketplaceIdList ( ) ) { $ marketplaceIdList = $ request -> getMarketplaceIdList ( ) ; foreach ( $ marketplaceIdList -> getId ( ) as $ idIndex => $ id ) { $ parameters [ 'MarketplaceIdList.Id.' . ( $ idIndex + 1 ) ] = $ id ; } } if ( $ request -> isSetFeedType ( ) ) { $ parameters [ 'FeedType' ] = $ request -> getFeedType ( ) ; } if ( $ request -> isSetPurgeAndReplace ( ) ) { $ parameters [ 'PurgeAndReplace' ] = $ request -> getPurgeAndReplace ( ) ? "true" : "false" ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } $ headers = array ( ) ; array_push ( $ headers , "Content-Type: " . $ request -> getContentType ( ) -> toString ( ) ) ; return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ headers ) ; }
3915	protected function sortByDate ( $ blnAscending = true ) { $ arrFiles = $ this -> foundFiles ; $ arrDates = $ this -> modifiedTime ; if ( ! $ arrFiles ) { return array ( 'files' => array ( ) , 'source' => array ( ) ) ; } if ( $ blnAscending ) { array_multisort ( $ arrFiles , SORT_NUMERIC , $ arrDates , SORT_ASC ) ; } else { array_multisort ( $ arrFiles , SORT_NUMERIC , $ arrDates , SORT_DESC ) ; } return $ this -> remapSorting ( $ arrFiles , $ this -> outputBuffer ) ; }
6107	public function clientPermList ( $ cldbid , $ permsid = false ) { return $ this -> getParent ( ) -> channelClientPermList ( $ this -> getId ( ) , $ cldbid , $ permsid ) ; }
3632	public function config ( Request $ request ) { if ( $ key = $ request -> query ( 'key' ) ) { return \ config ( $ key ) ; } return \ bean ( 'config' ) -> toArray ( ) ; }
6873	protected function buildItem ( SaleItemInterface $ saleItem , ShipmentInterface $ shipment ) { if ( $ saleItem -> isCompound ( ) ) { $ available = $ expected = null ; foreach ( $ saleItem -> getChildren ( ) as $ childSaleItem ) { if ( null !== $ child = $ this -> buildItem ( $ childSaleItem , $ shipment ) ) { $ saleItemQty = $ childSaleItem -> getQuantity ( ) ; $ e = $ child -> getExpected ( ) / $ saleItemQty ; if ( null === $ expected || $ expected > $ e ) { $ expected = $ e ; } $ a = $ child -> getAvailable ( ) / $ saleItemQty ; if ( null === $ available || $ available > $ a ) { $ available = $ a ; } } } if ( 0 < $ expected ) { return $ this -> findOrCreateItem ( $ shipment , $ saleItem , $ expected , $ available ) ; } return null ; } $ item = null ; if ( ! ( $ saleItem -> isCompound ( ) && ! $ saleItem -> hasPrivateChildren ( ) ) ) { $ expected = $ shipment -> isReturn ( ) ? $ this -> calculator -> calculateReturnableQuantity ( $ saleItem , $ shipment ) : $ this -> calculator -> calculateShippableQuantity ( $ saleItem , $ shipment ) ; if ( 0 < $ expected ) { $ item = $ this -> findOrCreateItem ( $ shipment , $ saleItem , $ expected ) ; } } if ( $ saleItem -> hasChildren ( ) ) { foreach ( $ saleItem -> getChildren ( ) as $ childSaleItem ) { $ this -> buildItem ( $ childSaleItem , $ shipment ) ; } } return $ item ; }
9037	protected function update ( $ entity , $ where = null , $ tableName = null , HydratorInterface $ hydrator = null ) { if ( ! $ where ) { $ where = 'id = ' . $ entity -> getId ( ) ; } return parent :: update ( $ entity , $ where , $ tableName , $ hydrator ) ; }
4557	public function generateCustomId ( CustomIdentifiable $ entity , bool $ overwrite = false ) { if ( null === $ entity -> getCustomId ( ) || $ overwrite ) { $ customId = uniqid ( ) ; $ entity -> setCustomId ( $ customId ) ; } return $ this ; }
3122	public function find ( $ tag = null , $ target = TimePoint :: TARGET_ALL , $ type = TimePoint :: TYPE_ALL ) { $ tags = null ; if ( isset ( $ tag ) ) { $ tags = is_array ( $ tag ) ? $ tag : [ $ tag ] ; } $ points = [ ] ; foreach ( $ this -> points as $ point ) { if ( $ point -> match ( $ tags , $ target , $ type ) ) { $ points [ ] = $ point ; } } return $ points ; }
12190	public function getActive ( ) { return ( isset ( $ this -> _child ) and $ this -> _child -> active ) and ( isset ( $ this -> _parent ) and $ this -> _parent -> active ) ; }
2393	public function addFile ( $ strFile , $ strName = null ) { if ( ! file_exists ( $ this -> strRootDir . '/' . $ strFile ) ) { throw new \ Exception ( "File $strFile does not exist" ) ; } if ( strncmp ( $ strName , '/' , 1 ) === 0 ) { $ strName = substr ( $ strName , 1 ) ; } $ this -> addString ( file_get_contents ( $ this -> strRootDir . '/' . $ strFile ) , $ strName ? : $ strFile , filemtime ( $ this -> strRootDir . '/' . $ strFile ) ) ; }
2571	public static function isValidFopType ( $ fopType ) { return ( $ fopType == self :: IDENT_CASH || $ fopType == self :: IDENT_CHECK || $ fopType == self :: IDENT_CREDITCARD || $ fopType == self :: IDENT_MISC ) ; }
8795	public function view ( $ name , array $ data = [ ] ) { $ file = app_path ( 'Views' . DIRECTORY_SEPARATOR . $ name . '.php' ) ; if ( file_exists ( $ file ) ) { extract ( $ data ) ; require $ file ; return ob_get_clean ( ) ; } throw new ExceptionHandler ( 'Oppss! File not found.' , 'View::' . $ name . ' not found.' ) ; }
10149	private function readPrintGridlines ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; if ( $ this -> version == self :: XLS_BIFF8 && ! $ this -> readDataOnly ) { $ printGridlines = ( bool ) self :: getUInt2d ( $ recordData , 0 ) ; $ this -> phpSheet -> setPrintGridlines ( $ printGridlines ) ; } }
8817	public function delete ( $ key = null , $ filter = true ) { parse_str ( file_get_contents ( "php://input" ) , $ _DELETE ) ; if ( $ key == null ) { return $ _DELETE ; } return $ this -> filter ( $ _DELETE [ $ key ] , $ filter ) ; }
1420	protected function pointer ( string $ path , ? string $ member = null ) : array { $ withoutMember = is_null ( $ member ) || '' === $ member ; $ pointer = ! $ withoutMember ? sprintf ( '%s/%s' , rtrim ( $ path , '/' ) , $ member ) : $ path ; return [ Error :: SOURCE_POINTER => $ pointer ] ; }
5541	public function setFrameFocus ( $ name ) { if ( is_integer ( $ this -> focus ) ) { if ( $ this -> frames [ $ this -> focus ] -> hasFrames ( ) ) { return $ this -> frames [ $ this -> focus ] -> setFrameFocus ( $ name ) ; } } if ( in_array ( $ name , array_keys ( $ this -> names ) ) ) { $ this -> focus = $ this -> names [ $ name ] ; return true ; } return false ; }
10945	public function onPrerenderPost ( PrerenderEvent $ events ) { $ cache = $ this -> getServiceLocator ( ) -> get ( $ this -> moduleOptions -> getCacheKey ( ) ) ; $ response = $ events -> getResponse ( ) ; $ key = $ this -> getCacheEntryKey ( $ events -> getRequest ( ) ) ; $ cache -> setItem ( $ key , $ events -> getResponse ( ) ) ; return $ this ; }
380	public function renderCallStack ( $ exception ) { $ out = '<ul>' ; $ out .= $ this -> renderCallStackItem ( $ exception -> getFile ( ) , $ exception -> getLine ( ) , null , null , [ ] , 1 ) ; for ( $ i = 0 , $ trace = $ exception -> getTrace ( ) , $ length = count ( $ trace ) ; $ i < $ length ; ++ $ i ) { $ file = ! empty ( $ trace [ $ i ] [ 'file' ] ) ? $ trace [ $ i ] [ 'file' ] : null ; $ line = ! empty ( $ trace [ $ i ] [ 'line' ] ) ? $ trace [ $ i ] [ 'line' ] : null ; $ class = ! empty ( $ trace [ $ i ] [ 'class' ] ) ? $ trace [ $ i ] [ 'class' ] : null ; $ function = null ; if ( ! empty ( $ trace [ $ i ] [ 'function' ] ) && $ trace [ $ i ] [ 'function' ] !== 'unknown' ) { $ function = $ trace [ $ i ] [ 'function' ] ; } $ args = ! empty ( $ trace [ $ i ] [ 'args' ] ) ? $ trace [ $ i ] [ 'args' ] : [ ] ; $ out .= $ this -> renderCallStackItem ( $ file , $ line , $ class , $ function , $ args , $ i + 2 ) ; } $ out .= '</ul>' ; return $ out ; }
1532	protected function deserialize ( array $ document , $ record = null ) : ResourceObject { $ data = $ document [ 'data' ] ?? [ ] ; if ( ! is_array ( $ data ) || empty ( $ data ) ) { throw new \ InvalidArgumentException ( 'Expecting a JSON API document with a data member.' ) ; } return ResourceObject :: create ( $ data ) ; }
1912	public function pickerAction ( Request $ request ) : RedirectResponse { $ extras = [ ] ; if ( $ request -> query -> has ( 'extras' ) ) { $ extras = $ request -> query -> get ( 'extras' ) ; if ( ! \ is_array ( $ extras ) ) { throw new BadRequestHttpException ( 'Invalid picker extras' ) ; } } $ config = new PickerConfig ( $ request -> query -> get ( 'context' ) , $ extras , $ request -> query -> get ( 'value' ) ) ; $ picker = $ this -> get ( 'contao.picker.builder' ) -> create ( $ config ) ; if ( null === $ picker ) { throw new BadRequestHttpException ( 'Unsupported picker context' ) ; } return new RedirectResponse ( $ picker -> getCurrentUrl ( ) ) ; }
10796	public function classifiedAnswer ( array $ data ) { $ id = isset ( $ data [ 'id' ] ) ? $ data [ 'id' ] : null ; if ( empty ( $ id ) ) { throw new \ Exception ( "Errore si sistema." ) ; } $ main = $ this -> getServiceLocator ( ) -> get ( 'neobazaar.service.main' ) ; $ documentRepository = $ main -> getDocumentEntityRepository ( ) ; $ classified = $ documentRepository -> getEntity ( $ id ) ; $ classifiedModel = $ this -> getServiceLocator ( ) -> get ( 'document.model.classifiedAdminListing' ) ; $ classifiedModel -> init ( $ classified , $ this -> getServiceLocator ( ) ) ; $ form = $ this -> getServiceLocator ( ) -> get ( 'user.form.classifiedanswer' ) ; $ form -> setData ( $ data ) ; if ( ! $ form -> isValid ( ) ) { throw new \ Exception ( serialize ( $ form -> getMessages ( ) ) ) ; } $ url = $ this -> getServiceLocator ( ) -> get ( 'ControllerPluginManager' ) -> get ( 'Url' ) ; $ data = array_merge ( $ form -> getData ( ) , array ( 'siteurl' => $ url -> fromRoute ( 'home' , array ( ) , array ( 'force_canonical' => true ) ) , 'to' => $ classifiedModel -> email , 'fullname' => $ classifiedModel -> fullname , 'title' => $ classifiedModel -> title , 'address' => $ classifiedModel -> address ) ) ; $ event = new ClassifiedAnswerEvent ( __FUNCTION__ , null , $ data ) ; $ this -> getEventManager ( ) -> trigger ( __FUNCTION__ . '.pre' , $ this , $ event ) ; $ this -> getEventManager ( ) -> trigger ( __FUNCTION__ . '.post' , $ this , $ event ) ; }
1801	protected function switchToEdit ( $ id ) { $ arrKeys = array ( ) ; $ arrUnset = array ( 'act' , 'id' , 'table' ) ; foreach ( array_keys ( $ _GET ) as $ strKey ) { if ( ! \ in_array ( $ strKey , $ arrUnset ) ) { $ arrKeys [ $ strKey ] = $ strKey . '=' . Input :: get ( $ strKey ) ; } } $ strUrl = TL_SCRIPT . '?' . implode ( '&' , $ arrKeys ) ; return $ strUrl . ( ! empty ( $ arrKeys ) ? '&' : '' ) . ( Input :: get ( 'table' ) ? 'table=' . Input :: get ( 'table' ) . '&amp;' : '' ) . 'act=edit&amp;id=' . rawurlencode ( $ id ) ; }
8446	private function convertQuestion ( Question $ question ) { $ buttons = Collection :: make ( $ question -> getButtons ( ) ) -> map ( function ( $ button ) { return [ 'label' => $ button [ 'text' ] , 'metadata' => $ button [ 'value' ] ] ; } ) ; return [ 'text' => $ question -> getText ( ) , 'quick_reply' => [ 'type' => 'options' , 'options' => $ buttons -> toArray ( ) , ] , ] ; }
8186	public function displayBlock ( $ name , array $ context , array $ blocks = array ( ) , $ useBlocks = true ) { $ name = ( string ) $ name ; if ( $ useBlocks && isset ( $ blocks [ $ name ] ) ) { $ template = $ blocks [ $ name ] [ 0 ] ; $ block = $ blocks [ $ name ] [ 1 ] ; } elseif ( isset ( $ this -> blocks [ $ name ] ) ) { $ template = $ this -> blocks [ $ name ] [ 0 ] ; $ block = $ this -> blocks [ $ name ] [ 1 ] ; } else { $ template = null ; $ block = null ; } if ( null !== $ template && ! $ template instanceof self ) { throw new LogicException ( 'A block must be a method on a Twig_Template instance.' ) ; } if ( null !== $ template ) { try { $ template -> $ block ( $ context , $ blocks ) ; } catch ( Twig_Error $ e ) { if ( ! $ e -> getSourceContext ( ) ) { $ e -> setSourceContext ( $ template -> getSourceContext ( ) ) ; } if ( false === $ e -> getTemplateLine ( ) ) { $ e -> setTemplateLine ( - 1 ) ; $ e -> guess ( ) ; } throw $ e ; } catch ( Exception $ e ) { throw new Twig_Error_Runtime ( sprintf ( 'An exception has been thrown during the rendering of a template ("%s").' , $ e -> getMessage ( ) ) , - 1 , $ template -> getSourceContext ( ) , $ e ) ; } } elseif ( false !== $ parent = $ this -> getParent ( $ context ) ) { $ parent -> displayBlock ( $ name , $ context , array_merge ( $ this -> blocks , $ blocks ) , false ) ; } else { @ trigger_error ( sprintf ( 'Silent display of undefined block "%s" in template "%s" is deprecated since version 1.29 and will throw an exception in 2.0. Use the "block(\'%s\') is defined" expression to test for block existence.' , $ name , $ this -> getTemplateName ( ) , $ name ) , E_USER_DEPRECATED ) ; } }
8325	public function deletePingback ( $ uri ) { $ response = $ this -> getHttpClient ( ) -> request ( 'GET' , "/res.php?key={$this->apiKey}&action=del_pingback&addr={$uri}" ) ; $ responseText = $ response -> getBody ( ) -> __toString ( ) ; if ( $ responseText === self :: STATUS_OK ) { return true ; } throw new ErrorResponseException ( $ this -> getErrorMessage ( $ responseText ) ? : $ responseText , $ this -> getErrorCode ( $ responseText ) ? : 0 ) ; }
4871	public function setEventPrototype ( EventInterface $ prototype ) { if ( ! $ prototype instanceof DependencyResultEvent ) { throw new \ InvalidArgumentException ( 'This event manager only accepts events of the type ' . DependencyResultEvent :: class ) ; } parent :: setEventPrototype ( $ prototype ) ; }
12524	public function deserializeJSON ( $ jsonString ) { $ data = json_decode ( $ jsonString ) ; $ this -> setContent ( $ data -> content ) ; $ this -> setContext ( $ data -> context ) ; }
2736	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ countries = $ this -> countryHelper -> toOptionArray ( ) ; if ( ! $ countries ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Could not fetch list countries.' ] ) ; } return $ result -> setData ( [ 'status' => true , 'countries' => $ countries ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
437	protected function compareValues ( $ operator , $ type , $ value , $ compareValue ) { if ( $ type === self :: TYPE_NUMBER ) { $ value = ( float ) $ value ; $ compareValue = ( float ) $ compareValue ; } else { $ value = ( string ) $ value ; $ compareValue = ( string ) $ compareValue ; } switch ( $ operator ) { case '==' : return $ value == $ compareValue ; case '===' : return $ value === $ compareValue ; case '!=' : return $ value != $ compareValue ; case '!==' : return $ value !== $ compareValue ; case '>' : return $ value > $ compareValue ; case '>=' : return $ value >= $ compareValue ; case '<' : return $ value < $ compareValue ; case '<=' : return $ value <= $ compareValue ; default : return false ; } }
3020	public function getBlogInfo ( $ blogName ) { $ path = $ this -> blogPath ( $ blogName , '/info' ) ; return $ this -> getRequest ( $ path , null , true ) ; }
23	public function removePackage ( PackageInterface $ package ) { $ packageId = $ package -> getUniqueName ( ) ; foreach ( $ this -> getPackages ( ) as $ key => $ repoPackage ) { if ( $ packageId === $ repoPackage -> getUniqueName ( ) ) { array_splice ( $ this -> packages , $ key , 1 ) ; return ; } } }
1526	protected function doUpdate ( StoreInterface $ store , UpdateResource $ request ) { if ( $ response = $ this -> beforeCommit ( $ request ) ) { return $ response ; } $ record = $ store -> updateRecord ( $ request -> getRecord ( ) , $ request -> all ( ) , $ request -> getParameters ( ) ) ; return $ this -> afterCommit ( $ request , $ record , true ) ? : $ record ; }
11159	protected function getApiRequest ( $ url , Event $ event , Queue $ queue ) { $ self = $ this ; $ request = new HttpRequest ( array ( 'url' => $ url , 'resolveCallback' => function ( $ data ) use ( $ self , $ url , $ event , $ queue ) { $ self -> resolve ( $ url , $ data , $ event , $ queue ) ; } , 'rejectCallback' => function ( $ error ) use ( $ self , $ url ) { $ self -> reject ( $ url , $ error ) ; } ) ) ; return $ request ; }
984	public function usageCharge ( StoreUsageCharge $ request ) { $ validated = $ request -> validated ( ) ; $ uc = new UsageCharge ( ShopifyApp :: shop ( ) , $ validated ) ; $ uc -> activate ( ) ; $ uc -> save ( ) ; return isset ( $ validated [ 'redirect' ] ) ? Redirect :: to ( $ validated [ 'redirect' ] ) -> with ( 'success' , 'usage_charge' ) : Redirect :: back ( ) -> with ( 'success' , 'usage_charge' ) ; }
1987	private function filterOptions ( array $ allowedSizes ) : array { if ( empty ( $ allowedSizes ) ) { return [ ] ; } $ filteredSizes = [ ] ; foreach ( $ this -> options as $ group => $ sizes ) { if ( 'image_sizes' === $ group ) { $ this -> filterImageSizes ( $ sizes , $ allowedSizes , $ filteredSizes , $ group ) ; } else { $ this -> filterResizeModes ( $ sizes , $ allowedSizes , $ filteredSizes , $ group ) ; } } return $ filteredSizes ; }
3131	public function persist ( QtiRunnerServiceContext $ context ) { $ testSession = $ context -> getTestSession ( ) ; $ sessionId = $ testSession -> getSessionId ( ) ; \ common_Logger :: d ( "Persisting QTI Assessment Test Session '${sessionId}'..." ) ; $ context -> getStorage ( ) -> persist ( $ testSession ) ; if ( $ this -> isTerminated ( $ context ) ) { $ userId = \ common_session_SessionManager :: getSession ( ) -> getUser ( ) -> getIdentifier ( ) ; $ eventManager = $ this -> getServiceManager ( ) -> get ( EventManager :: SERVICE_ID ) ; $ eventManager -> trigger ( new AfterAssessmentTestSessionClosedEvent ( $ testSession , $ userId ) ) ; } }
12581	public function previewCardByName ( $ message , $ to ) { return $ this -> preview ( self :: MSG_TYPE_CARD , $ message , $ to , self :: PREVIEW_BY_NAME ) ; }
10389	public static function loadFile ( $ xmlFile ) { if ( ! is_file ( $ xmlFile ) || ! is_readable ( $ xmlFile ) ) { throw new NoSuchFileException ( $ xmlFile ) ; } return self :: parseXml ( $ xmlFile ) ; }
9699	public function text ( $ paragraphs = null ) { $ this -> paragraphs = $ paragraphs ; $ this -> params [ 'plaintext' ] = true ; return $ this -> generate ( ) ; }
3413	public function refreshFields ( ) { if ( $ this -> id === null ) { $ this -> original = [ ] ; return $ this -> fields = [ ] ; } $ this -> fields = static :: query ( ) -> getById ( $ this -> id ) -> fields ; $ this -> original = $ this -> fields ; $ this -> fieldsAreFetched = true ; return $ this -> fields ; }
2611	public function getActiveVersion ( $ service , $ activeVersion ) { $ currActiveVersion = $ this -> determineVersions ( $ service -> versions ) ; if ( $ currActiveVersion [ 'active_version' ] != $ activeVersion ) { throw new LocalizedException ( __ ( 'Active versions mismatch.' ) ) ; } return $ currActiveVersion ; }
12802	public function getPage ( $ page = null ) { if ( is_null ( $ page ) ) { $ page = $ this -> page ; } list ( $ offset , $ size ) = $ this -> getLimts ( $ page ) ; $ this -> manager -> limit ( $ offset , $ size ) ; return $ this -> manager -> values ( ) ; }
9300	public function setOptions ( array $ options ) { if ( ! array_key_exists ( 'options' , $ options ) ) { $ options [ 'options' ] = array ( ) ; } $ this -> options = array_merge ( $ this -> getDefaultOptions ( ) , $ options [ 'options' ] ) ; return $ this ; }
9556	public function add ( ParameterClosure $ closure ) { $ this -> prefixes [ $ closure -> prefix ] [ $ closure -> parameterName ] = $ closure ; return $ this ; }
5778	public function set ( string $ sql , array $ args ) { $ this -> sql = $ sql ; $ this -> args = $ args ; }
4543	public function addFilterConstraint ( ClassMetadata $ targetEntity , $ targetTableAlias ) { if ( ! $ targetEntity -> reflClass -> implementsInterface ( Tenantable :: class ) ) { return '' ; } $ tenant = trim ( $ this -> getParameter ( 'tenant' ) , '\'' ) ; if ( '' === $ tenant ) { $ constraint = sprintf ( '%s.tenant is NULL' , $ targetTableAlias ) ; } else { $ constraint = sprintf ( '%s.tenant = \'%s\'' , $ targetTableAlias , $ tenant ) ; } return $ constraint ; }
2773	public function fetchTags ( ) : array { $ output = $ this -> gitWorkingCopy -> tag ( [ 'l' => true ] ) ; $ tags = ( array ) preg_split ( "/\r\n|\n|\r/" , rtrim ( $ output ) ) ; return array_map ( [ $ this , 'trimTags' ] , $ tags ) ; }
8002	private function resolveInputEncoding ( $ string ) { $ encoding = null ; if ( $ this -> detect ) { $ encoding = mb_detect_encoding ( $ string , null , true ) ; } if ( false === $ encoding || null === $ encoding ) { $ encoding = mb_internal_encoding ( ) ; } if ( false === $ encoding || null === $ encoding ) { throw EncodingDetectionException :: forString ( $ string ) ; } return $ encoding ; }
1935	public function generate ( $ objPage ) { $ this -> redirect ( $ this -> getForwardUrl ( $ objPage ) , $ this -> getRedirectStatusCode ( $ objPage ) ) ; }
8892	public function consumeSlimContainer ( Set $ container ) { foreach ( $ container as $ key => $ value ) { if ( $ value instanceof \ Closure ) { $ refFunc = new \ ReflectionFunction ( $ value ) ; $ shared = in_array ( 'object' , $ refFunc -> getStaticVariables ( ) ) ; $ this -> registerFactory ( $ key , $ value , $ shared ) ; } elseif ( is_callable ( $ value ) ) { $ this -> registerFactory ( $ key , $ value , false ) ; } else { $ this -> sm -> setService ( $ key , $ value ) ; } } }
7179	public function getType ( ) { if ( is_string ( $ this -> type ) ) { $ type = $ this -> type ; } elseif ( is_array ( $ this -> type ) ) { $ type = reset ( $ this -> type ) ; } else { $ type = null ; } return $ this -> isValidType ( $ type ) ? $ type : self :: ANY ; }
7605	public function setTranslator ( TranslatorInterface $ oTranslator = null , $ sTextDomain = null ) { $ this -> translator = $ oTranslator ; if ( null !== $ sTextDomain ) { $ this -> setTranslatorTextDomain ( $ sTextDomain ) ; } return $ this ; }
2107	public static function findOneByRelatedTableAndId ( $ strTable , $ intId , array $ arrOptions = array ( ) ) { @ trigger_error ( 'Using the Contao\OptInModel::findOneByRelatedTableAndIds() method has been deprecated and will no longer work in Contao 5.0. Use the Contao\OptInModel::findByRelatedTableAndIds() method instead.' , E_USER_DEPRECATED ) ; $ t = static :: $ strTable ; $ objDatabase = Database :: getInstance ( ) ; $ objResult = $ objDatabase -> prepare ( "SELECT * FROM $t WHERE id IN (SELECT pid FROM tl_opt_in_related WHERE relTable=? AND relId=?)" ) -> execute ( $ strTable , $ intId ) ; if ( $ objResult -> numRows < 1 ) { return null ; } $ objRegistry = Registry :: getInstance ( ) ; if ( $ objOptIn = $ objRegistry -> fetch ( $ t , $ objResult -> id ) ) { return $ objOptIn ; } return new static ( $ objResult ) ; }
11509	protected function parseMessageFromRequest ( $ content ) { $ content = strval ( $ content ) ; $ dataSet = json_decode ( $ content , true ) ; if ( $ dataSet && ( JSON_ERROR_NONE === json_last_error ( ) ) ) { $ content = XML :: build ( $ dataSet ) ; } if ( $ this -> isSafeMode ( ) ) { if ( ! $ this -> encryptor ) { throw new RuntimeException ( 'Safe mode Encryptor is necessary, please use Guard::setEncryptor(Encryptor $encryptor) set the encryptor instance.' ) ; } $ message = $ this -> encryptor -> decryptMsg ( $ this -> request -> get ( 'msg_signature' ) , $ this -> request -> get ( 'nonce' ) , $ this -> request -> get ( 'timestamp' ) , $ content ) ; } else { $ message = XML :: parse ( $ content ) ; } return $ message ; }
4052	private function fetchPropertiesFor ( $ inputScreenId , IMetaModel $ metaModel ) : array { $ builder = $ this -> connection -> createQueryBuilder ( ) ; return array_map ( function ( $ column ) use ( $ inputScreenId , $ metaModel ) { if ( 'attribute' !== $ column [ 'dcatype' ] ) { return $ column ; } if ( ! ( $ attribute = $ metaModel -> getAttributeById ( $ column [ 'attr_id' ] ) ) ) { @ trigger_error ( 'Unknown attribute "' . $ column [ 'attr_id' ] . '" in input screen "' . $ inputScreenId . '"' , E_USER_WARNING ) ; return $ column ; } $ column = array_merge ( $ column , $ attribute -> getFieldDefinition ( $ column ) , [ 'col_name' => $ attribute -> getColName ( ) ] ) ; return $ column ; } , $ builder -> select ( '*' ) -> from ( 'tl_metamodel_dcasetting' ) -> where ( 'pid=:pid' ) -> andWhere ( 'published=:published' ) -> setParameter ( 'pid' , $ inputScreenId ) -> setParameter ( 'published' , 1 ) -> orderBy ( 'sorting' ) -> execute ( ) -> fetchAll ( \ PDO :: FETCH_ASSOC ) ) ; }
4449	public function pop ( ? string $ worker = null , ? int $ numJobs = null ) { $ workerName = $ worker ? : $ this -> client -> getWorkerName ( ) ; $ jids = json_decode ( $ this -> client -> pop ( $ this -> name , $ workerName , $ numJobs ? : 1 ) , true ) ; $ jobs = [ ] ; array_map ( function ( array $ data ) use ( & $ jobs ) { $ job = new BaseJob ( $ this -> client , $ data ) ; $ job -> setEventsManager ( $ this -> getEventsManager ( ) ) ; $ jobs [ ] = $ job ; } , $ jids ? : [ ] ) ; return $ numJobs === null ? array_shift ( $ jobs ) : $ jobs ; }
4057	private function convertAttribute ( array $ property , $ condition , array & $ legend ) { if ( ! isset ( $ property [ 'col_name' ] ) ) { return ; } $ legend [ 'properties' ] [ ] = [ 'name' => $ property [ 'col_name' ] , 'condition' => $ condition ( $ property ) ] ; }
8520	public function setFulfillmentRecommendations ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'FulfillmentRecommendations' ] [ 'FieldValue' ] = $ value ; return $ this ; }
3194	public function getExtraTime ( $ maxTime = 0 ) { if ( $ maxTime && $ this -> getExtendedTime ( ) ) { $ secondsNew = $ maxTime * $ this -> getExtendedTime ( ) ; $ extraTime = $ secondsNew - $ maxTime ; $ this -> setExtraTime ( $ extraTime ) ; return $ extraTime ; } return $ this -> extraTime ; }
5715	public function doSaveAndAdd ( $ data , $ form ) { return $ this -> saveAndRedirect ( $ data , $ form , $ this -> owner -> Link ( "addnew" ) ) ; }
8429	protected function getCmtiFileIcon ( $ fileType ) { switch ( $ fileType ) { case FileManager :: FILE_TYPE_IMAGE : { return 'cmti-image' ; } case FileManager :: FILE_TYPE_VIDEO : { return 'cmti-file-video' ; } case FileManager :: FILE_TYPE_AUDIO : { return 'cmti-file-audio' ; } case FileManager :: FILE_TYPE_DOCUMENT : { return 'cmti-document' ; } case FileManager :: FILE_TYPE_COMPRESSED : { return 'cmti-file-zip' ; } } }
4200	private function addMethods ( Event $ abs ) { $ obj = $ abs -> getSubject ( ) ; if ( ! $ abs [ 'collectMethods' ] ) { $ this -> addMethodsMin ( $ abs ) ; return ; } if ( $ this -> abstracter -> getCfg ( 'cacheMethods' ) && isset ( static :: $ methodCache [ $ abs [ 'className' ] ] ) ) { $ abs [ 'methods' ] = static :: $ methodCache [ $ abs [ 'className' ] ] ; } else { $ methodArray = array ( ) ; $ methods = $ abs [ 'reflector' ] -> getMethods ( ) ; $ interfaceMethods = array ( 'ArrayAccess' => array ( 'offsetExists' , 'offsetGet' , 'offsetSet' , 'offsetUnset' ) , 'Countable' => array ( 'count' ) , 'Iterator' => array ( 'current' , 'key' , 'next' , 'rewind' , 'void' ) , 'IteratorAggregate' => array ( 'getIterator' ) , ) ; $ interfacesHide = \ array_intersect ( $ abs [ 'implements' ] , \ array_keys ( $ interfaceMethods ) ) ; foreach ( $ methods as $ reflectionMethod ) { $ info = $ this -> methodInfo ( $ obj , $ reflectionMethod ) ; $ methodName = $ reflectionMethod -> getName ( ) ; if ( $ info [ 'visibility' ] === 'private' && $ info [ 'inheritedFrom' ] ) { continue ; } foreach ( $ interfacesHide as $ interface ) { if ( \ in_array ( $ methodName , $ interfaceMethods [ $ interface ] ) ) { $ info [ 'implements' ] = $ interface ; break ; } } $ methodArray [ $ methodName ] = $ info ; } $ abs [ 'methods' ] = $ methodArray ; $ this -> addMethodsPhpDoc ( $ abs ) ; static :: $ methodCache [ $ abs [ 'className' ] ] = $ abs [ 'methods' ] ; } if ( isset ( $ abs [ 'methods' ] [ '__toString' ] ) ) { $ abs [ 'methods' ] [ '__toString' ] [ 'returnValue' ] = $ obj -> __toString ( ) ; } return ; }
2852	public function deleteTemplateHintsDbConfigs ( ) { $ configTable = Mage :: getResourceModel ( 'core/config' ) -> getMainTable ( ) ; $ db = Mage :: getSingleton ( 'core/resource' ) -> getConnection ( 'core_write' ) ; $ db -> delete ( $ configTable , "path like 'dev/debug/template_hints%'" ) ; }
6397	private function addEvolution ( $ decoded_taf , $ evolution , $ result , $ entity_name ) { $ new_evolution = clone ( $ evolution ) ; $ new_evolution -> setEntity ( $ result [ $ entity_name ] ) ; if ( $ entity_name == 'visibility' && $ this -> with_cavok == true ) { $ new_evolution -> setCavok ( true ) ; } $ getter_name = 'get' . ucfirst ( $ entity_name ) ; $ setter_name = 'set' . ucfirst ( $ entity_name ) ; $ decoded_entity = $ decoded_taf -> $ getter_name ( ) ; if ( $ decoded_entity == null || $ entity_name == 'clouds' || $ entity_name == 'weatherPhenomenons' ) { $ decoded_entity = $ this -> instantiateEntity ( $ entity_name ) ; } $ decoded_entity -> addEvolution ( $ new_evolution ) ; if ( $ entity_name == 'clouds' ) { $ decoded_taf -> addCloud ( $ decoded_entity ) ; } elseif ( $ entity_name == 'weatherPhenomenons' ) { $ decoded_taf -> addWeatherPhenomenon ( $ decoded_entity ) ; } else { $ decoded_taf -> $ setter_name ( $ decoded_entity ) ; } }
7913	protected function renderInput ( ) { return $ this -> hasModel ( ) ? Html :: activeCheckbox ( $ this -> model , $ this -> attribute , $ this -> options ) : Html :: checkbox ( $ this -> name , $ this -> checked , $ this -> options ) ; }
707	public function bigPrimaryKey ( $ length = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_BIGPK , $ length ) ; }
1468	public static function wantsJsonApi ( $ request ) { $ acceptable = $ request -> getAcceptableContentTypes ( ) ; return isset ( $ acceptable [ 0 ] ) && IlluminateStr :: contains ( $ acceptable [ 0 ] , MediaType :: JSON_API_SUB_TYPE ) ; }
10174	public function delete ( $ pCoord ) { if ( $ pCoord === $ this -> currentCoordinate && $ this -> currentCell !== null ) { $ this -> currentCell -> detach ( ) ; $ this -> currentCoordinate = null ; $ this -> currentCell = null ; $ this -> currentCellIsDirty = false ; } unset ( $ this -> index [ $ pCoord ] ) ; $ this -> cache -> delete ( $ this -> cachePrefix . $ pCoord ) ; }
5518	public function invoke ( $ method , $ args ) { $ method = strtolower ( $ method ) ; $ step = $ this -> getCallCount ( $ method ) ; $ this -> addCall ( $ method , $ args ) ; $ this -> checkExpectations ( $ method , $ args , $ step ) ; $ was = $ this -> disableEStrict ( ) ; try { $ result = $ this -> emulateCall ( $ method , $ args , $ step ) ; } catch ( Exception $ e ) { $ this -> restoreEStrict ( $ was ) ; throw $ e ; } $ this -> restoreEStrict ( $ was ) ; return $ result ; }
3321	public function getSuggestions ( ) { if ( $ this -> suggestions ) { if ( is_callable ( $ this -> suggestions ) ) { return call_user_func ( $ this -> suggestions ) ; } return $ this -> suggestions ; } return ; }
11570	final public static function load ( & $ object , & $ params ) { $ attachments = static :: getInstance ( ) ; $ attachment = & $ object ; if ( ! is_a ( $ attachment , Entity :: class ) ) { $ attachment = $ attachments -> loadObjectByURI ( $ attachment ) ; } if ( $ attachment -> getObjectType ( ) !== "attachment" ) return false ; $ fileId = $ attachment -> getObjectType ( ) ; $ filePath = FSPATH . DS . $ attachment -> getPropertyValue ( "attachment_src" ) ; $ contentType = $ attachment -> getPropertyValue ( "attachment_type" ) ; static :: place ( $ fileId , $ filePath , $ contentType , $ params ) ; }
8375	public function where ( $ where ) { $ this -> where = ( $ where instanceof Condition ? $ where : new Condition ( $ where ) ) ; return $ this ; }
8228	protected function assertLimits ( ) { if ( $ this -> storage -> getUsersCount ( ) >= $ this -> config [ "maxUsers" ] ) { $ this -> session -> addFlash ( "error" , "New registrations are currently disabled." ) ; $ this -> picoAuth -> redirectToPage ( "register" ) ; } }
10433	protected function prepareServiceConfigs ( ContainerBuilder $ container , $ pipelineConfig , $ pipelineName ) { return array_merge ( $ pipelineConfig [ 'config' ] , [ 'doctrineManager' => $ pipelineConfig [ 'doctrineManager' ] , 'elasticsearchManager' => $ pipelineConfig [ 'elasticsearchManager' ] , 'sync_storage' => $ pipelineConfig [ 'sync_storage' ] , 'diff_provider' => $ pipelineConfig [ 'diff_provider' ] , 'extractor' => $ pipelineConfig [ 'extractor' ] , 'chunk_size' => $ pipelineConfig [ 'chunk_size' ] , 'shop' => $ pipelineConfig [ 'shop' ] , 'shop_id' => $ this -> getShopId ( $ container , $ pipelineConfig [ 'shop' ] , $ pipelineName ) , ] ) ; }
6845	public static function seconds ( $ step = 1 , $ start = 0 , $ end = 60 ) { $ step = ( int ) $ step ; $ seconds = array ( ) ; for ( $ i = $ start ; $ i < $ end ; $ i += $ step ) { $ seconds [ $ i ] = sprintf ( '%02d' , $ i ) ; } return $ seconds ; }
3800	public function getMetaModel ( EnvironmentInterface $ interface ) { $ metaModelId = $ this -> connection -> createQueryBuilder ( ) -> select ( 'd.pid' ) -> from ( 'tl_metamodel_dca' , 'd' ) -> leftJoin ( 'd' , 'tl_metamodel_dcasetting' , 's' , '(d.id=s.pid)' ) -> where ( '(s.id=:id)' ) -> setParameter ( 'id' , ModelId :: fromSerialized ( $ interface -> getInputProvider ( ) -> getParameter ( 'pid' ) ) -> getId ( ) ) -> execute ( ) ; if ( $ tableName = $ this -> factory -> translateIdToMetaModelName ( $ metaModelId = $ metaModelId -> fetchColumn ( ) ) ) { return $ this -> factory -> getMetaModel ( $ tableName ) ; } throw new \ RuntimeException ( 'Could not retrieve MetaModel ' . $ metaModelId ) ; }
8744	protected function runLoop ( ) { while ( $ this -> isListening ) { $ this -> stream -> select ( ) ; if ( true === $ this -> charSequenceEnabled && null !== $ this -> escapePressedAt ) { if ( $ this -> escapeKeyHasExpired ( ) ) { $ this -> disableKeySequence ( ) ; $ this -> setCurrentKey ( $ this -> matcher -> getKey ( $ this -> matcher -> getEscapeKey ( ) ) ) ; $ this -> dispatchKeyPressEvents ( $ this -> getCurrentKey ( ) ) ; } } if ( $ this -> stream -> isAvailable ( ) ) { $ char = $ this -> stream -> getChar ( ) ; if ( $ this -> matcher -> getEscapeKey ( ) === $ char ) { $ this -> enableKeySequence ( ) ; $ this -> setCurrentKey ( $ char ) ; } else { $ this -> escapePressedAt = null ; if ( $ this -> charSequenceEnabled ) { $ this -> concatCurrentKey ( $ char ) ; $ mapped = $ this -> matcher -> getKey ( $ this -> getCurrentKey ( ) ) ; if ( $ mapped ) { $ this -> setCurrentKey ( $ mapped ) ; $ this -> disableKeySequence ( ) ; } else { continue ; } } else { if ( $ this -> matcher -> isBasicLatin ( $ char ) ) { continue ; } else { $ this -> setCurrentKey ( $ this -> matcher -> getKey ( $ char ) ? : $ char ) ; } } $ this -> dispatchKeyPressEvents ( $ this -> getCurrentKey ( ) ) ; } } } return $ this ; }
4012	private function calculatePaginated ( ) { $ this -> calculatedTotal = $ this -> getTotalAmount ( ) ; if ( ( $ this -> calculatedLimit !== null ) && ( $ this -> calculatedTotal > $ this -> calculatedLimit ) ) { $ this -> calculatedTotal -= $ this -> calculatedLimit ; } $ this -> calculatedTotal -= $ this -> calculatedOffset ; $ page = $ this -> getCurrentPage ( ) ; if ( $ page > ( $ this -> calculatedTotal / $ this -> getPerPage ( ) ) ) { $ page = ( int ) ceil ( $ this -> calculatedTotal / $ this -> getPerPage ( ) ) ; } $ pageOffset = ( ( max ( $ page , 1 ) - 1 ) * $ this -> getPerPage ( ) ) ; $ this -> calculatedOffset += $ pageOffset ; if ( $ this -> calculatedLimit === null ) { $ this -> calculatedLimit = $ this -> getPerPage ( ) ; } else { $ this -> calculatedLimit = min ( ( $ this -> calculatedLimit - $ this -> calculatedOffset ) , $ this -> getPerPage ( ) ) ; } }
12852	protected static function symbol ( $ symbol ) { if ( $ symbol instanceof Symbol ) return [ $ symbol -> symbol , $ symbol -> package ] ; throw new \ UnexpectedValueException ( sprintf ( "Unexpected value of type '%s'." , is_object ( $ symbol ) ? get_class ( $ symbol ) : gettype ( $ symbol ) ) ) ; }
3940	private function setEmptyValue ( PropertyInterface $ property , array $ propInfo ) { if ( ! array_key_exists ( 'empty_value' , $ propInfo ) || ! ( $ property instanceof EmptyValueAwarePropertyInterface ) ) { return ; } $ property -> setEmptyValue ( $ propInfo [ 'empty_value' ] ) ; }
4628	protected function prepareRequestUrl ( ) { $ protocol = $ this -> node -> useTls ( ) ? 'https' : 'http' ; $ this -> requestURL = sprintf ( '%s://%s%s?%s' , $ protocol , $ this -> node -> getUri ( ) , $ this -> path , $ this -> query ) ; $ this -> options [ CURLOPT_URL ] = $ this -> requestURL ; return $ this ; }
11522	public function get ( $ name ) { return isset ( $ this -> _items [ $ name ] ) ? $ this -> _items [ $ name ] : null ; }
5534	public function paintFooter ( $ group ) { $ aspect = 1 ; $ this -> paintResultsHeader ( ) ; $ this -> paintRectangleStart ( $ this -> _reporter -> getGraph ( ) , 100 , 100 ) ; $ this -> divideMapNodes ( $ this -> _reporter -> getGraph ( ) , $ aspect ) ; $ this -> paintRectangleEnd ( ) ; $ this -> paintResultsFooter ( ) ; }
3062	public function canMoveBackward ( ) { $ moveBack = false ; $ session = $ this -> getTestSession ( ) ; if ( $ this -> isAdaptive ( ) ) { $ positionInCatSession = array_search ( $ this -> getCurrentCatItemId ( ) , $ this -> getShadowTest ( ) ) ; if ( $ positionInCatSession === 0 ) { if ( $ session -> getRoute ( ) -> getPosition ( ) !== 0 ) { $ moveBack = $ session -> getPreviousRouteItem ( ) -> getTestPart ( ) -> getNavigationMode ( ) === NavigationMode :: NONLINEAR ; } } else { $ moveBack = $ session -> getRoute ( ) -> current ( ) -> getTestPart ( ) -> getNavigationMode ( ) === NavigationMode :: NONLINEAR ; } } else { $ moveBack = $ session -> canMoveBackward ( ) ; if ( $ moveBack ) { $ moveBack = $ this -> getServiceManager ( ) -> get ( SectionPauseService :: SERVICE_ID ) -> canMoveBackward ( $ session ) ; } } return $ moveBack ; }
9710	private function writeWindow1 ( ) { $ record = 0x003D ; $ length = 0x0012 ; $ xWn = 0x0000 ; $ yWn = 0x0000 ; $ dxWn = 0x25BC ; $ dyWn = 0x1572 ; $ grbit = 0x0038 ; $ ctabsel = 1 ; $ wTabRatio = 0x0258 ; $ itabFirst = 0 ; $ itabCur = $ this -> spreadsheet -> getActiveSheetIndex ( ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vvvvvvvvv' , $ xWn , $ yWn , $ dxWn , $ dyWn , $ grbit , $ itabCur , $ itabFirst , $ ctabsel , $ wTabRatio ) ; $ this -> append ( $ header . $ data ) ; }
6610	public static function getByCreatedDateRange ( $ startDate , $ endDate , $ createdAtColumn = 'created_at' ) { $ model = get_called_class ( ) ; $ model = new $ model ; return self :: find ( ) -> andWhere ( $ model :: tableName ( ) . '.' . $ createdAtColumn . ' BETWEEN :start_date AND :end_date' , [ 'start_date' => $ startDate , 'end_date' => $ endDate ] ) ; }
9964	public function getComment ( $ pCellCoordinate ) { $ pCellCoordinate = strtoupper ( $ pCellCoordinate ) ; if ( Coordinate :: coordinateIsRange ( $ pCellCoordinate ) ) { throw new Exception ( 'Cell coordinate string can not be a range of cells.' ) ; } elseif ( strpos ( $ pCellCoordinate , '$' ) !== false ) { throw new Exception ( 'Cell coordinate string must not be absolute.' ) ; } elseif ( $ pCellCoordinate == '' ) { throw new Exception ( 'Cell coordinate can not be zero-length string.' ) ; } if ( isset ( $ this -> comments [ $ pCellCoordinate ] ) ) { return $ this -> comments [ $ pCellCoordinate ] ; } $ newComment = new Comment ( ) ; $ this -> comments [ $ pCellCoordinate ] = $ newComment ; return $ newComment ; }
7663	function AddAttachment ( $ path , $ name = "" , $ encoding = "base64" , $ type = "application/octet-stream" ) { if ( ! @ is_file ( $ path ) ) { $ this -> SetError ( $ this -> Lang ( "file_access" ) . $ path ) ; return false ; } $ filename = basename ( $ path ) ; if ( $ name == "" ) $ name = $ filename ; $ cur = count ( $ this -> attachment ) ; $ this -> attachment [ $ cur ] [ 0 ] = $ path ; $ this -> attachment [ $ cur ] [ 1 ] = $ filename ; $ this -> attachment [ $ cur ] [ 2 ] = $ name ; $ this -> attachment [ $ cur ] [ 3 ] = $ encoding ; $ this -> attachment [ $ cur ] [ 4 ] = $ type ; $ this -> attachment [ $ cur ] [ 5 ] = false ; $ this -> attachment [ $ cur ] [ 6 ] = "attachment" ; $ this -> attachment [ $ cur ] [ 7 ] = 0 ; return true ; }
12636	protected function getSandboxSignKey ( ) { if ( $ this -> sandboxSignKey ) { return $ this -> sandboxSignKey ; } $ cacheKey = 'sandbox_signkey.' . $ this -> merchant -> merchant_id . $ this -> merchant -> sub_merchant_id ; $ cache = $ this -> getCache ( ) ; $ this -> sandboxSignKey = $ cache -> fetch ( $ cacheKey ) ; if ( ! $ this -> sandboxSignKey ) { $ result = $ this -> request ( self :: API_SANDBOX_SIGN_KEY , [ ] ) ; if ( $ result -> return_code === 'SUCCESS' ) { $ cache -> save ( $ cacheKey , $ result -> sandbox_signkey , 24 * 3600 ) ; return $ this -> sandboxSignKey = $ result -> sandbox_signkey ; } throw new Exception ( $ result -> return_msg ) ; } return $ this -> sandboxSignKey ; }
5676	protected function getMembers ( $ object ) { $ reflection = new ReflectionObject ( $ object ) ; $ members = array ( ) ; foreach ( $ reflection -> getProperties ( ) as $ property ) { if ( method_exists ( $ property , 'setAccessible' ) ) { $ property -> setAccessible ( true ) ; } try { $ members [ $ property -> getName ( ) ] = $ property -> getValue ( $ object ) ; } catch ( ReflectionException $ e ) { $ members [ $ property -> getName ( ) ] = $ this -> getPrivatePropertyNoMatterWhat ( $ property -> getName ( ) , $ object ) ; } } return $ members ; }
3962	private function createOrGetDefinition ( IMetaModelDataDefinition $ container ) { if ( $ container -> hasMetaModelDefinition ( ) ) { return $ container -> getMetaModelDefinition ( ) ; } $ container -> setMetaModelDefinition ( $ definition = new MetaModelDefinition ( ) ) ; return $ definition ; }
7318	public function toMJD ( $ scale = null ) { $ mjd = static :: MJD ; if ( $ scale ) { return bcsub ( bcadd ( $ this -> jd , $ this -> dayFrac , $ scale ) , $ mjd , $ scale ) ; } else { return $ this -> jd + $ this -> dayFrac - $ mjd ; } }
10905	public function getList ( $ asStrings = false ) { $ list = scandir ( $ this -> path ) ; if ( $ asStrings === true ) { return array_diff ( $ list , [ "." , ".." ] ) ; } $ ret = [ ] ; foreach ( $ list as $ name ) { if ( $ name === "." || $ name === ".." ) { continue ; } $ path = $ this -> path . DIRECTORY_SEPARATOR . $ name ; $ ret [ ] = ( is_dir ( $ path ) ) ? new static ( $ path ) : new FileEntity ( $ path ) ; } return $ ret ; }
6884	static public function isValidType ( $ type , $ throw = true ) { if ( in_array ( $ type , static :: getTypes ( ) , true ) ) { return true ; } if ( $ throw ) { throw new InvalidArgumentException ( 'Invalid notification type.' ) ; } return false ; }
5530	protected function chainMockExpectations ( ) { $ code = " function expect(\$method, \$args = false, \$msg = '%s') {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->expect(\$method, \$args, \$msg);\n" ; $ code .= " }\n" ; $ code .= " function expectAt(\$timing, \$method, \$args = false, \$msg = '%s') {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->expectAt(\$timing, \$method, \$args, \$msg);\n" ; $ code .= " }\n" ; $ code .= " function expectCallCount(\$method, \$count) {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->expectCallCount(\$method, \$count, \$msg = '%s');\n" ; $ code .= " }\n" ; $ code .= " function expectMaximumCallCount(\$method, \$count, \$msg = '%s') {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->expectMaximumCallCount(\$method, \$count, \$msg = '%s');\n" ; $ code .= " }\n" ; $ code .= " function expectMinimumCallCount(\$method, \$count, \$msg = '%s') {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->expectMinimumCallCount(\$method, \$count, \$msg = '%s');\n" ; $ code .= " }\n" ; $ code .= " function expectNever(\$method) {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->expectNever(\$method);\n" ; $ code .= " }\n" ; $ code .= " function expectOnce(\$method, \$args = false, \$msg = '%s') {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->expectOnce(\$method, \$args, \$msg);\n" ; $ code .= " }\n" ; $ code .= " function expectAtLeastOnce(\$method, \$args = false, \$msg = '%s') {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->expectAtLeastOnce(\$method, \$args, \$msg);\n" ; $ code .= " }\n" ; return $ code ; }
7298	public function append_signature ( $ message , $ signature = '' ) { if ( empty ( $ signature ) ) { return $ message ; } $ separator = apply_filters ( 'iac_signature_separator' , str_repeat ( PHP_EOL , 2 ) . '--' . PHP_EOL ) ; return $ message . $ separator . $ signature ; }
4438	public function create ( string $ className , string $ performMethod = 'perform' ) { if ( class_exists ( $ className ) == false ) { throw new InvalidArgumentException ( "Could not find job class {$className}." ) ; } if ( method_exists ( $ className , $ performMethod ) == false ) { throw new InvalidArgumentException ( sprintf ( 'Job class "%s" does not contain perform method "%s".' , $ className , $ performMethod ) ) ; } $ instance = new $ className ; if ( $ instance instanceof EventsManagerAwareInterface ) { $ instance -> setEventsManager ( $ this -> getEventsManager ( ) ) ; } return $ instance ; }
4259	public function getSubscribers ( $ eventName = null ) { if ( $ eventName !== null ) { if ( ! isset ( $ this -> subscribers [ $ eventName ] ) ) { return array ( ) ; } if ( ! isset ( $ this -> sorted [ $ eventName ] ) ) { $ this -> sortSubscribers ( $ eventName ) ; } return $ this -> sorted [ $ eventName ] ; } foreach ( \ array_keys ( $ this -> subscribers ) as $ eventName ) { if ( ! isset ( $ this -> sorted [ $ eventName ] ) ) { $ this -> sortSubscribers ( $ eventName ) ; } } return \ array_filter ( $ this -> sorted ) ; }
6164	public function setData ( $ data ) { if ( is_array ( $ data ) ) { $ this -> data = $ data ; return $ this ; } $ this -> data = json_decode ( $ data , true ) ; if ( null === $ this -> data ) { $ this -> data = $ data ; } return $ this ; }
7646	protected function getFileName ( $ path ) { $ url = parse_url ( $ path ) ; if ( $ url [ 'host' ] ) { $ fileName = isset ( $ url [ 'path' ] ) ? $ url [ 'path' ] : $ url [ 'host' ] ; if ( strpos ( $ fileName , '/' ) === 0 ) { $ fileName = substr ( $ fileName , 1 ) ; } return $ fileName ; } return '' ; }
1385	protected function memberRequired ( string $ path , string $ member ) : void { $ this -> errors -> add ( $ this -> translator -> memberRequired ( $ path , $ member ) ) ; }
5444	protected function reduce ( $ raw ) { if ( $ action = $ this -> regexes [ $ this -> mode -> getCurrent ( ) ] -> match ( $ raw , $ match ) ) { $ unparsed_character_count = strpos ( $ raw , $ match ) ; $ unparsed = substr ( $ raw , 0 , $ unparsed_character_count ) ; $ raw = substr ( $ raw , $ unparsed_character_count + strlen ( $ match ) ) ; return array ( $ raw , $ unparsed , $ match , $ action ) ; } return true ; }
11300	protected function _fetchData ( $ name ) { $ gateway = new \ Cora \ Gateway ( $ this -> getDbAdaptor ( ) , $ this -> getTableName ( ) , $ this -> getPrimaryKey ( ) ) ; return $ gateway -> fetchData ( $ this -> getFieldName ( $ name ) , $ this ) ; }
2694	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activate_flag = $ this -> getRequest ( ) -> getParam ( 'activate_flag' ) ; $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ formData = $ this -> getRequest ( ) -> getParams ( ) ; if ( in_array ( "" , $ formData ) ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Please fill in the required fields.' ] ) ; } $ service = $ this -> api -> checkServiceDetails ( ) ; $ this -> vcl -> checkCurrentVersionActive ( $ service -> versions , $ activeVersion ) ; $ currActiveVersion = $ this -> vcl -> getCurrentVersion ( $ service -> versions ) ; $ clone = $ this -> api -> cloneVersion ( $ currActiveVersion ) ; $ id = $ service -> id . '-' . $ clone -> number . '-imageopto' ; $ params = json_encode ( [ 'data' => [ 'id' => $ id , 'type' => 'io_settings' , 'attributes' => [ 'webp' => $ this -> getRequest ( ) -> getParam ( 'webp' ) , 'webp_quality' => $ this -> getRequest ( ) -> getParam ( 'webp_quality' ) , 'jpeg_type' => $ this -> getRequest ( ) -> getParam ( 'jpeg_type' ) , 'jpeg_quality' => $ this -> getRequest ( ) -> getParam ( 'jpeg_quality' ) , 'upscale' => $ this -> getRequest ( ) -> getParam ( 'upscale' ) , 'resize_filter' => $ this -> getRequest ( ) -> getParam ( 'resize_filter' ) ] ] ] ) ; $ configureIo = $ this -> api -> configureImageOptimizationDefaultConfigOptions ( $ params , $ clone -> number ) ; if ( ! $ configureIo ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to update image optimization default config options.' ] ) ; } $ this -> api -> validateServiceVersion ( $ clone -> number ) ; if ( $ activate_flag === 'true' ) { $ this -> api -> activateVersion ( $ clone -> number ) ; } if ( $ this -> config -> areWebHooksEnabled ( ) && $ this -> config -> canPublishConfigChanges ( ) ) { $ this -> api -> sendWebHook ( '*Image optimization default config options have been updated*' ) ; } $ comment = [ 'comment' => 'Magento Module updated the Image Optimization Default Configuration' ] ; $ this -> api -> addComment ( $ clone -> number , $ comment ) ; return $ result -> setData ( [ 'status' => true , 'active_version' => $ clone -> number ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
1609	public function delete ( $ id ) { $ redirect = RedirectRecord :: findOne ( compact ( 'id' ) ) -> delete ( ) ; if ( $ redirect === false ) return 'Unable find redirect with ID: ' . $ id ; return false ; }
4189	protected function dumpConstants ( $ constants ) { $ str = '' ; if ( $ constants && $ this -> debug -> output -> getCfg ( 'outputConstants' ) ) { $ str = '<dt class="constants">constants</dt>' . "\n" ; foreach ( $ constants as $ k => $ value ) { $ str .= '<dd class="constant">' . '<span class="constant-name">' . $ k . '</span>' . ' <span class="t_operator">=</span> ' . $ this -> debug -> output -> html -> dump ( $ value ) . '</dd>' . "\n" ; } } return $ str ; }
12379	public function handle ( ) : void { $ help = " -----------------------------------------------------------------\n" ; $ help .= " | Command Line Interface\n" ; $ help .= " | See more in https://github.com/senhungwong/command-line-interface\n" ; $ help .= " -------------------------------------------------------------------\n" ; $ commands = CommandEntry :: getCommands ( ) ; if ( $ command = $ this -> getArgument ( 'function-name' ) ) { $ command = new $ commands [ $ command ] ; $ help .= " - " . $ command -> getCommand ( ) . ": " ; $ help .= $ command -> getDescription ( ) . "\n" ; } else { foreach ( $ commands as $ command ) { $ command = new $ command ; $ help .= " - " ; $ help .= $ command -> getCommand ( ) . ": " ; $ help .= $ command -> getDescription ( ) . "\n" ; } } echo $ help ; }
8681	public function set ( $ key , $ value ) { Deprecated :: method ( 1.1 , MutableBag :: class ) ; $ this -> items [ $ key ] = $ value ; }
2706	public function getAllModules ( ) { $ modules = [ ] ; $ moduleCollection = $ this -> collectionFactory -> create ( ) -> getData ( ) ; foreach ( $ moduleCollection as $ module ) { $ modules [ ] = $ module ; } return $ modules ; }
4576	public function get ( $ id , Parameters $ parameters = null ) { if ( null !== $ id ) { $ resource = str_replace ( '{id}' , $ id , static :: RESOURCE_OBJECT ) ; } else { $ key = $ parameters -> getKey ( ) ; $ tenantId = $ parameters -> getTenantId ( ) ; switch ( true ) { case null !== $ key && null !== $ tenantId : $ resource = str_replace ( [ '{key}' , '{tenant-id}' ] , [ $ key , $ tenantId ] , static :: RESOURCE_OBJECT_BY_KEY_AND_TENANT_ID ) ; break ; case null !== $ key : $ resource = str_replace ( '{key}' , $ key , static :: RESOURCE_OBJECT_BY_KEY ) ; break ; default : throw new LogicException ( '"Key" and/or "TenantId" parameters are not defined.' ) ; } } $ options = [ 'headers' => [ 'Accept' => 'application/json' ] ] ; $ object = $ this -> execute ( 'GET' , $ resource , $ options ) ; $ model = static :: toModel ( $ object ) ; return $ model ; }
8598	public function createSubscription ( $ request ) { if ( ! ( $ request instanceof MWSSubscriptionsService_Model_CreateSubscriptionInput ) ) { require_once ( dirname ( __FILE__ ) . '/Model/CreateSubscriptionInput.php' ) ; $ request = new MWSSubscriptionsService_Model_CreateSubscriptionInput ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'CreateSubscription' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/CreateSubscriptionResponse.php' ) ; $ response = MWSSubscriptionsService_Model_CreateSubscriptionResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
6582	public static function getSession ( ServerRequestInterface $ request ) : SessionDataHolder { $ session = $ request -> getAttribute ( static :: REQ_ATTR ) ; if ( ! $ session instanceof SessionDataHolder ) { throw new SessionMiddlewareException ( "No session object is available in the request attributes" ) ; } return $ session ; }
3294	protected function buildLink ( $ provider , $ url ) { $ fontAwesomeVersion = config ( 'laravel-share.fontAwesomeVersion' , 4 ) ; $ this -> html .= trans ( "laravel-share::laravel-share-fa$fontAwesomeVersion.$provider" , [ 'url' => $ url , 'class' => key_exists ( 'class' , $ this -> options ) ? $ this -> options [ 'class' ] : '' , 'id' => key_exists ( 'id' , $ this -> options ) ? $ this -> options [ 'id' ] : '' , ] ) ; }
2473	public function indexContent ( Content $ content ) { $ this -> gateway -> bulkIndexDocuments ( array ( $ this -> mapper -> mapContentBlock ( $ content ) ) ) ; }
6676	public function render_meta_boxes ( $ post ) { App :: setCurrentID ( 'EFG' ) ; wp_nonce_field ( '_rating_movie_nonce' , 'rating_movie_nonce' ) ; $ meta_boxes = Module :: CustomRatingGrifus ( ) -> getOption ( 'path' , 'meta-boxes' ) ; $ data = [ 'votes' => $ this -> model -> get_movie_votes ( $ post -> ID ) ] ; $ this -> view -> renderizate ( $ meta_boxes , 'wp-insert-post' , $ data ) ; }
5191	private function handleString ( $ str ) : string { return is_string ( $ str ) && strlen ( $ str ) > 0 && $ str !== null ? $ str : '' ; }
5382	public function setValue ( $ desired ) { $ achieved = array ( ) ; foreach ( $ desired as $ value ) { $ success = false ; for ( $ i = 0 , $ count = count ( $ this -> options ) ; $ i < $ count ; $ i ++ ) { if ( $ this -> options [ $ i ] -> isValue ( $ value ) ) { $ achieved [ ] = $ this -> options [ $ i ] -> getValue ( ) ; $ success = true ; break ; } } if ( ! $ success ) { return false ; } } $ this -> values = $ achieved ; return true ; }
8888	public function process ( ServerRequestInterface $ request , RequestHandlerInterface $ requestHandler ) : ResponseInterface { $ this -> container -> set ( ServerRequestInterface :: class , $ request ) ; $ result = $ this -> dispatch ( $ this -> route ( $ request ) ) ; if ( $ result instanceof ResponseInterface ) { return $ result ; } return $ response = ( new Response ( ) ) -> withProtocolVersion ( '1.1' ) -> withBody ( \ GuzzleHttp \ Psr7 \ stream_for ( $ result ) ) ; }
10420	public function create ( $ pipelineName , $ listeners = [ ] ) { $ listeners = array_merge ( [ 'sources' => [ ] , 'modifiers' => [ ] , 'consumers' => [ ] , ] , $ listeners ) ; $ className = $ this -> getClassName ( ) ; $ pipeline = new $ className ( $ pipelineName ) ; if ( ! $ pipeline instanceof Pipeline ) { throw new \ InvalidArgumentException ( 'Pipeline class\' name must implement PipelineInterface' ) ; } $ pipeline -> setProgressBar ( $ this -> getProgressBar ( ) ) ; $ dispatcher = $ this -> getDispatcher ( ) ; $ pipeline -> setDispatcher ( $ dispatcher ) ; foreach ( $ listeners [ 'consumers' ] as & $ listener ) { if ( $ listener === self :: CONSUMER_RETURN ) { $ listener = function ( ItemPipelineEvent $ event ) { $ event -> setOutput ( $ event -> getItem ( ) ) ; } ; } } $ registerListener = function ( $ key , $ suffix ) use ( $ listeners , $ dispatcher , $ pipeline ) { foreach ( $ listeners [ $ key ] as $ listener ) { $ dispatcher -> addListener ( $ pipeline -> getEventName ( $ suffix ) , $ listener ) ; } } ; $ registerListener ( 'sources' , Pipeline :: EVENT_SUFFIX_SOURCE ) ; $ registerListener ( 'modifiers' , Pipeline :: EVENT_SUFFIX_MODIFY ) ; $ registerListener ( 'consumers' , Pipeline :: EVENT_SUFFIX_CONSUME ) ; return $ pipeline ; }
12565	public function sendImage ( $ message , $ to = null ) { return $ this -> send ( self :: MSG_TYPE_IMAGE , $ message , $ to ) ; }
11553	public function dispatch ( DispatchConfirmationInterface $ dispatchConfirmation ) { try { $ event = new EventDispatchConfirmation ( $ dispatchConfirmation ) ; $ this -> eventDispatcher -> dispatch ( Events :: PRE_CONSIGNMENTS_DISPATCH , $ event ) ; $ adapter = $ this -> getAdapter ( $ dispatchConfirmation -> getConsignments ( ) -> first ( ) ) ; $ adapter -> dispatch ( $ dispatchConfirmation ) ; $ this -> dispatchConfirmationRepository -> saveDispatchConfirmation ( $ dispatchConfirmation ) ; foreach ( $ dispatchConfirmation -> getConsignments ( ) as $ consignment ) { $ consignment -> setDispatchConfirmation ( $ dispatchConfirmation ) ; $ previousStatus = $ consignment -> getStatus ( ) ; foreach ( $ consignment -> getParcels ( ) as $ parcel ) { $ parcel -> setStatus ( ConsignmentStatusList :: STATUS_DISPATCHED ) ; } $ consignment -> setStatus ( ConsignmentStatusList :: STATUS_DISPATCHED ) ; $ this -> consignmentRepository -> saveConsignment ( $ consignment ) ; $ this -> dispatchOnConsignmentStatusChange ( $ consignment , $ previousStatus ) ; } $ event = new EventDispatchConfirmation ( $ dispatchConfirmation ) ; $ this -> eventDispatcher -> dispatch ( Events :: POST_CONSIGNMENTS_DISPATCH , $ event ) ; } catch ( \ Exception $ e ) { throw new VendorAdapterException ( 'Error during consignments dispatching.' , null , $ e ) ; } }
10198	private function writeRows ( XMLWriter $ objWriter , Worksheet $ sheet ) { $ numberRowsRepeated = self :: NUMBER_ROWS_REPEATED_MAX ; $ span_row = 0 ; $ rows = $ sheet -> getRowIterator ( ) ; while ( $ rows -> valid ( ) ) { -- $ numberRowsRepeated ; $ row = $ rows -> current ( ) ; if ( $ row -> getCellIterator ( ) -> valid ( ) ) { if ( $ span_row ) { $ objWriter -> startElement ( 'table:table-row' ) ; if ( $ span_row > 1 ) { $ objWriter -> writeAttribute ( 'table:number-rows-repeated' , $ span_row ) ; } $ objWriter -> startElement ( 'table:table-cell' ) ; $ objWriter -> writeAttribute ( 'table:number-columns-repeated' , self :: NUMBER_COLS_REPEATED_MAX ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ span_row = 0 ; } $ objWriter -> startElement ( 'table:table-row' ) ; $ this -> writeCells ( $ objWriter , $ row ) ; $ objWriter -> endElement ( ) ; } else { ++ $ span_row ; } $ rows -> next ( ) ; } }
499	protected function writeInteger ( $ fileHandle , $ integer ) { return $ this -> writeBytes ( $ fileHandle , pack ( $ this -> useBigEndian ? 'N' : 'V' , ( int ) $ integer ) ) ; }
561	public static function autoload ( $ className ) { if ( isset ( static :: $ classMap [ $ className ] ) ) { $ classFile = static :: $ classMap [ $ className ] ; if ( $ classFile [ 0 ] === '@' ) { $ classFile = static :: getAlias ( $ classFile ) ; } } elseif ( strpos ( $ className , '\\' ) !== false ) { $ classFile = static :: getAlias ( '@' . str_replace ( '\\' , '/' , $ className ) . '.php' , false ) ; if ( $ classFile === false || ! is_file ( $ classFile ) ) { return ; } } else { return ; } include $ classFile ; if ( YII_DEBUG && ! class_exists ( $ className , false ) && ! interface_exists ( $ className , false ) && ! trait_exists ( $ className , false ) ) { throw new UnknownClassException ( "Unable to find '$className' in file: $classFile. Namespace missing?" ) ; } }
4654	protected function getJobs ( $ projectPath ) { $ jobs = array ( ) ; $ project = $ this -> naming -> getProjectName ( $ projectPath ) ; $ repositoryRegex = sprintf ( '#^%s_([a-z]+?)/%s:\d+-\d+$#' , Job :: BASE_NAME , $ project ) ; foreach ( $ this -> docker -> getImageManager ( ) -> findAll ( ) as $ image ) { foreach ( $ image -> getRepoTags ( ) as $ name ) { if ( preg_match ( $ repositoryRegex , $ name , $ matches ) ) { $ jobs [ ] = $ this -> getJobFromImage ( $ image , $ name , $ matches [ 1 ] , $ project ) ; } } } return $ jobs ; }
10672	private static function addSegmentsToPath ( $ path , $ segments ) { $ segments = Arr :: toArray ( $ segments ) ; if ( count ( $ segments ) > 0 ) { $ path .= '/' . implode ( '/' , $ segments ) ; } return $ path ; }
8971	protected function fromJson ( $ json ) { $ data = json_decode ( $ json , true ) ; return new Rate ( $ data [ 'sourceName' ] , ( float ) $ data [ 'value' ] , $ data [ 'currencyCode' ] , $ data [ 'rateType' ] , \ DateTime :: createFromFormat ( \ DateTime :: ATOM , $ data [ 'date' ] ) , $ data [ 'baseCurrencyCode' ] , \ DateTime :: createFromFormat ( \ DateTime :: ATOM , $ data [ 'createdAt' ] ) , \ DateTime :: createFromFormat ( \ DateTime :: ATOM , $ data [ 'modifiedAt' ] ) ) ; }
6120	public function serverStart ( $ sid ) { if ( $ sid == $ this -> serverSelectedId ( ) ) { $ this -> serverDeselect ( ) ; } $ this -> execute ( "serverstart" , array ( "sid" => $ sid ) ) ; $ this -> serverListReset ( ) ; Signal :: getInstance ( ) -> emit ( "notifyServerstarted" , $ this , $ sid ) ; }
5637	public function paintError ( $ message ) { parent :: paintError ( $ message ) ; print 'Exception ' . $ this -> getExceptionCount ( ) . "!\n$message\n" ; $ breadcrumb = $ this -> getTestList ( ) ; array_shift ( $ breadcrumb ) ; print "\tin " . implode ( "\n\tin " , array_reverse ( $ breadcrumb ) ) ; print "\n" ; }
85	public function getPackageFilename ( PackageInterface $ package ) { $ nameParts = array ( preg_replace ( '#[^a-z0-9-_]#i' , '-' , $ package -> getName ( ) ) ) ; if ( preg_match ( '{^[a-f0-9]{40}$}' , $ package -> getDistReference ( ) ) ) { array_push ( $ nameParts , $ package -> getDistReference ( ) , $ package -> getDistType ( ) ) ; } else { array_push ( $ nameParts , $ package -> getPrettyVersion ( ) , $ package -> getDistReference ( ) ) ; } if ( $ package -> getSourceReference ( ) ) { $ nameParts [ ] = substr ( sha1 ( $ package -> getSourceReference ( ) ) , 0 , 6 ) ; } $ name = implode ( '-' , array_filter ( $ nameParts , function ( $ p ) { return ! empty ( $ p ) ; } ) ) ; return str_replace ( '/' , '-' , $ name ) ; }
9580	public function setDeferredChannel ( $ channel , callable $ callback ) { if ( isset ( $ this -> channels [ $ channel ] ) ) { throw new InvalidArgumentException ( "Channel $channel is already defined" ) ; } $ this -> deferredChannels [ $ channel ] = $ callback ; }
7694	function MsExcel_GetDrawingLst ( ) { $ lst = array ( ) ; $ dir = '../drawings/' ; $ dir_len = strlen ( $ dir ) ; $ o = $ this -> OpenXML_Rels_GetObj ( $ this -> TBS -> OtbsCurrFile , $ dir ) ; foreach ( $ o -> TargetLst as $ t ) { if ( ( substr ( $ t , 0 , $ dir_len ) === $ dir ) && ( substr ( $ t , - 4 ) === '.xml' ) ) $ lst [ ] = 'xl/drawings/' . substr ( $ t , $ dir_len ) ; } return $ lst ; }
9880	private function writeWorkbookProtection ( XMLWriter $ objWriter , Spreadsheet $ spreadsheet ) { if ( $ spreadsheet -> getSecurity ( ) -> isSecurityEnabled ( ) ) { $ objWriter -> startElement ( 'workbookProtection' ) ; $ objWriter -> writeAttribute ( 'lockRevision' , ( $ spreadsheet -> getSecurity ( ) -> getLockRevision ( ) ? 'true' : 'false' ) ) ; $ objWriter -> writeAttribute ( 'lockStructure' , ( $ spreadsheet -> getSecurity ( ) -> getLockStructure ( ) ? 'true' : 'false' ) ) ; $ objWriter -> writeAttribute ( 'lockWindows' , ( $ spreadsheet -> getSecurity ( ) -> getLockWindows ( ) ? 'true' : 'false' ) ) ; if ( $ spreadsheet -> getSecurity ( ) -> getRevisionsPassword ( ) != '' ) { $ objWriter -> writeAttribute ( 'revisionsPassword' , $ spreadsheet -> getSecurity ( ) -> getRevisionsPassword ( ) ) ; } if ( $ spreadsheet -> getSecurity ( ) -> getWorkbookPassword ( ) != '' ) { $ objWriter -> writeAttribute ( 'workbookPassword' , $ spreadsheet -> getSecurity ( ) -> getWorkbookPassword ( ) ) ; } $ objWriter -> endElement ( ) ; } }
7313	public function setDate ( $ year , $ month , $ day ) { $ status = IAU :: Cal2jd ( ( int ) $ year , ( int ) $ month , ( int ) $ day , $ djm0 , $ djm ) ; $ this -> checkDate ( $ status ) ; $ this -> jd = $ djm0 + $ djm ; return $ this ; }
11888	public function getFamiliarity ( $ user = null ) { if ( is_null ( $ user ) ) { $ user = $ this -> getUser ( false ) ; } if ( is_object ( $ user ) ) { $ user = $ user -> primaryKey ; } $ familarityKey = md5 ( $ user ) ; if ( ! isset ( $ this -> _familiarity [ $ familarityKey ] ) ) { $ this -> _familiarity [ $ familarityKey ] = false ; $ familiarityClass = Yii :: $ app -> classes [ 'ObjectFamiliarity' ] ; if ( ! empty ( $ user ) ) { $ attributes = [ ] ; $ attributes [ $ this -> objectField ] = $ this -> owner -> primaryKey ; $ attributes [ $ this -> userField ] = $ user ; $ this -> _familiarity [ $ familarityKey ] = $ familiarityClass :: find ( ) -> where ( $ attributes ) -> one ( ) ; if ( empty ( $ this -> _familiarity [ $ familarityKey ] ) ) { $ this -> _familiarity [ $ familarityKey ] = new $ familiarityClass ( ) ; $ this -> _familiarity [ $ familarityKey ] -> attributes = $ attributes ; } } } return $ this -> _familiarity [ $ familarityKey ] ; }
8720	protected function initTranslatableAttributes ( ) { if ( property_exists ( $ this , 'translatable' ) ) { $ attributes = $ this -> translatable ; } else { $ attributes = $ this -> getTranslatableAttributesFromSchema ( ) ; } static :: $ i18nAttributes [ $ this -> getTable ( ) ] = $ attributes ; }
9520	public function getAliasUsage ( $ withEncapsulation = true ) { $ aliases = '' ; foreach ( $ this -> aliases as $ prefix => $ alias ) { if ( $ withEncapsulation ) { $ aliases = ( $ aliases == '' ) ? ' (' : $ aliases ; $ aliases .= ' ' . $ prefix . $ alias ; } else { $ aliases = ( $ aliases == '' ) ? $ prefix . $ alias : $ aliases . ', ' . $ prefix . $ alias ; } } if ( $ withEncapsulation ) { $ aliases .= ( $ aliases == '' ) ? '' : ' )' ; } return $ aliases ; }
1491	public static function camelize ( $ data ) { return collect ( $ data ) -> mapWithKeys ( function ( $ value , $ key ) { $ key = Str :: camelize ( $ key ) ; if ( is_array ( $ value ) ) { return [ $ key => static :: camelize ( $ value ) ] ; } return [ $ key => $ value ] ; } ) -> all ( ) ; }
11127	protected function renderView ( $ view , $ data ) { try { return parent :: renderView ( $ view , $ data ) ; } catch ( \ InvalidArgumentException $ e ) { return static :: applyDataToView ( $ view , $ data ) ; } }
12869	public function bind ( $ sUser , $ sPassword ) : Ldap { return $ this -> _bConnected = ldap_bind ( $ this -> _rConnect , $ sUser , $ sPassword ) ; return $ this ; }
1290	public function setContentType ( $ contentType ) { if ( $ contentType instanceof ContentType ) { $ contentType = $ contentType -> getId ( ) ; } $ this -> contentType = $ contentType ; $ this -> setType ( 'Entry' ) ; return $ this ; }
12937	private function changeBlockSlotAndName ( $ targetFile , $ blockName , $ slotName ) { $ block = json_decode ( FilesystemTools :: readFile ( $ targetFile ) , true ) ; $ block [ "name" ] = $ blockName ; $ block [ "slot_name" ] = $ slotName ; $ json = json_encode ( $ block ) ; FilesystemTools :: writeFile ( $ targetFile , $ json ) ; return $ block ; }
8253	protected function handleAccountPage ( Request $ httpRequest ) { $ user = $ this -> picoAuth -> getUser ( ) ; if ( ! $ user -> getAuthenticated ( ) ) { $ this -> session -> addFlash ( "error" , "Login to access this page." ) ; $ this -> picoAuth -> redirectToLogin ( ) ; return ; } if ( $ user -> getAuthenticator ( ) !== $ this -> getName ( ) ) { $ this -> picoAuth -> redirectToPage ( "index" ) ; return ; } $ editAccount = $ this -> picoAuth -> getContainer ( ) -> get ( 'EditAccount' ) ; $ editAccount -> setConfig ( $ this -> config ) -> handleAccountPage ( $ httpRequest ) ; }
4804	private function getTemplatePath ( ) { $ tsfe = $ GLOBALS [ 'TSFE' ] ; if ( isset ( $ tsfe -> tmpl -> setup [ 'lib.' ] [ 'plugins.' ] [ 'tx_happyfeet.' ] [ 'view.' ] [ 'template' ] ) ) { $ templateFile = GeneralUtility :: getFileAbsFileName ( $ tsfe -> tmpl -> setup [ 'lib.' ] [ 'plugins.' ] [ 'tx_happyfeet.' ] [ 'view.' ] [ 'template' ] ) ; if ( is_file ( $ templateFile ) ) { return $ tsfe -> tmpl -> setup [ 'lib.' ] [ 'plugins.' ] [ 'tx_happyfeet.' ] [ 'view.' ] [ 'template' ] ; } } return $ this -> getTemplatePathAndFilename ( $ this -> defaultTemplate ) ; }
4646	public function compute ( ) { $ dimensions = $ this -> dimensions ; if ( empty ( $ dimensions ) ) { return array ( ) ; } $ values = reset ( $ dimensions ) ; $ name = key ( $ dimensions ) ; unset ( $ dimensions [ $ name ] ) ; $ posibilities = array ( ) ; foreach ( $ values as $ v ) { $ posibilities [ ] = array ( $ name => $ v ) ; } if ( empty ( $ dimensions ) ) { return $ posibilities ; } $ matrix = new Matrix ( ) ; foreach ( $ dimensions as $ name => $ values ) { $ matrix -> setDimension ( $ name , $ values ) ; } $ result = $ matrix -> compute ( ) ; $ newResult = array ( ) ; foreach ( $ result as $ value ) { foreach ( $ posibilities as $ possiblity ) { $ newResult [ ] = $ value + $ possiblity ; } } return $ newResult ; }
912	private function moveParamAnnotations ( $ content ) { $ doc = new DocBlock ( $ content ) ; $ params = $ doc -> getAnnotationsOfType ( 'param' ) ; if ( empty ( $ params ) ) { return $ content ; } $ others = $ doc -> getAnnotationsOfType ( [ 'throws' , 'return' ] ) ; if ( empty ( $ others ) ) { return $ content ; } $ end = end ( $ params ) -> getEnd ( ) ; $ line = $ doc -> getLine ( $ end ) ; foreach ( $ others as $ other ) { if ( $ other -> getStart ( ) < $ end ) { $ line -> setContent ( $ line -> getContent ( ) . $ other -> getContent ( ) ) ; $ other -> remove ( ) ; } } return $ doc -> getContent ( ) ; }
11087	public static function getUserPlatform ( ) { $ user_agent = $ _SERVER [ 'HTTP_USER_AGENT' ] ; $ user_platform = 'unknown' ; if ( false !== stripos ( $ user_agent , 'linux' ) ) { $ user_platform = 'Linux' ; } elseif ( preg_match ( '/macintosh|mac os x/i' , $ user_agent ) ) { $ user_platform = 'Mac' ; } elseif ( preg_match ( '/windows|win32/i' , $ user_agent ) ) { $ user_platform = 'Windows' ; } return $ user_platform ; }
548	protected function addMemcachedServers ( $ cache , $ servers ) { $ existingServers = [ ] ; if ( $ this -> persistentId !== null ) { foreach ( $ cache -> getServerList ( ) as $ s ) { $ existingServers [ $ s [ 'host' ] . ':' . $ s [ 'port' ] ] = true ; } } foreach ( $ servers as $ server ) { if ( empty ( $ existingServers ) || ! isset ( $ existingServers [ $ server -> host . ':' . $ server -> port ] ) ) { $ cache -> addServer ( $ server -> host , $ server -> port , $ server -> weight ) ; } } }
6039	public function custom ( $ sessionId , $ mediaId , $ event ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'sessionId' => $ sessionId , 'mediaId' => $ mediaId , 'event' => $ event ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/events/custom' , $ parameters , true ) ; return $ result ; }
5844	public function saveAdditionalFields ( array $ submittedData , \ TYPO3 \ CMS \ Scheduler \ Task \ AbstractTask $ task ) { $ task -> directories = trim ( $ submittedData [ 'scheduler_batchResize_directories' ] ) ; $ task -> excludeDirectories = trim ( $ submittedData [ 'scheduler_batchResize_excludeDirectories' ] ) ; }
5216	public static function createInstance ( $ className , $ projectPath ) { Runtime :: reset ( ) ; self :: $ projectPath = $ projectPath ; $ binder = new Binder ( ) ; foreach ( static :: getBindingsForApp ( $ className ) as $ bindingModule ) { if ( is_string ( $ bindingModule ) ) { $ bindingModule = new $ bindingModule ( ) ; } if ( $ bindingModule instanceof BindingModule ) { $ bindingModule -> configure ( $ binder , $ projectPath ) ; } elseif ( $ bindingModule instanceof \ Closure ) { $ bindingModule ( $ binder , $ projectPath ) ; } else { throw new \ InvalidArgumentException ( 'Given module class ' . get_class ( $ bindingModule ) . ' is not an instance of stubbles\ioc\module\BindingModule' ) ; } } return $ binder -> getInjector ( ) -> getInstance ( $ className ) ; }
10955	protected function redirect ( Response $ response , int $ code , string $ url ) : Response { return $ response -> withStatus ( $ code ) -> withHeader ( 'Location' , $ url ) ; }
12387	private static function showErrors ( ) { if ( count ( static :: $ errors ) > 0 ) { $ errorsList = '' ; foreach ( static :: $ errors as $ error ) { $ errorsList .= 'Tipo: ' . $ error [ 'type' ] . '<br>' ; $ errorsList .= 'Mensaje: ' . $ error [ 'message' ] . '<br>' ; $ errorsList .= 'Archivo: ' . $ error [ 'file' ] . '<br>' ; $ errorsList .= 'Line: ' . $ error [ 'line' ] . '<br><br>' ; } static :: viewException ( 1 , $ errorsList ) ; } }
3334	private function __initRequest ( $ type , $ data = null ) { $ url = sprintf ( 'https://%s/%s/' , $ this -> host , $ type ) ; if ( is_array ( $ data ) ) { $ url = sprintf ( '%s?%s' , $ url , http_build_query ( $ data ) ) ; } $ ch = curl_init ( $ url ) ; return $ ch ; }
4454	private function registerSyncCompleteEvent ( ) : void { $ this -> getEventsManager ( ) -> attach ( QueueEvent \ AfterEnqueue :: getName ( ) , function ( QueueEvent \ AfterEnqueue $ event ) { if ( ! $ this -> client -> config -> get ( 'sync-enabled' ) ) { return ; } $ job = $ this -> popByJid ( $ event -> getJid ( ) ) ; if ( ! empty ( $ job ) ) { $ job -> perform ( ) ; } } ) ; }
1152	public function selector ( $ selector ) { $ this -> selector = is_null ( $ selector ) ? $ this -> selector : $ selector ; return $ this ; }
12848	private function _getPage403 ( ) { var_dump ( debug_backtrace ( ) ) ; header ( "HTTP/1.0 403 Forbidden" ) ; if ( isset ( $ this -> _oRoutes -> e403 ) ) { $ this -> _oRoutes -> e403 -> route = '/' ; $ _SERVER [ 'REQUEST_URI' ] = '/' ; $ this -> _route ( $ this -> _oRoutes -> e403 , $ _SERVER [ 'REQUEST_URI' ] ) ; } exit ; }
8559	public function setError ( $ error ) { if ( ! $ this -> _isNumericArray ( $ error ) ) { $ error = array ( $ error ) ; } $ this -> fields [ 'Error' ] [ 'FieldValue' ] = $ error ; return $ this ; }
1421	protected function createBelongsToIdentity ( Model $ model , $ relationshipKey ) { $ relation = $ model -> { $ relationshipKey } ( ) ; if ( ! $ relation instanceof BelongsTo ) { throw new RuntimeException ( sprintf ( 'Expecting %s on %s to be a belongs-to relationship.' , $ relationshipKey , get_class ( $ model ) ) ) ; } $ foreignKey = method_exists ( $ relation , 'getForeignKeyName' ) ? $ relation -> getForeignKeyName ( ) : $ relation -> getForeignKey ( ) ; $ id = $ model -> { $ foreignKey } ; if ( is_null ( $ id ) ) { return null ; } $ ownerKey = method_exists ( $ relation , 'getOwnerKeyName' ) ? $ relation -> getOwnerKeyName ( ) : $ relation -> getOwnerKey ( ) ; $ related = $ relation -> getRelated ( ) -> replicate ( ) ; $ related -> { $ ownerKey } = $ id ; return $ related ; }
11228	protected function getUrl ( $ section , array $ uriParams = [ ] ) { $ endpoint = rtrim ( $ this -> getEndpoint ( ) , '/' ) ; $ section = ltrim ( $ section , '/' ) ; $ params = http_build_query ( $ uriParams ) ; if ( $ params ) { return sprintf ( "%s/%s?%s" , $ endpoint , $ section , $ params ) ; } else { return sprintf ( "%s/%s" , $ endpoint , $ section ) ; } }
9906	public static function map ( $ color , $ palette , $ version ) { if ( $ color <= 0x07 || $ color >= 0x40 ) { return Color \ BuiltIn :: lookup ( $ color ) ; } elseif ( isset ( $ palette , $ palette [ $ color - 8 ] ) ) { return $ palette [ $ color - 8 ] ; } if ( $ version == Xls :: XLS_BIFF8 ) { return Color \ BIFF8 :: lookup ( $ color ) ; } return Color \ BIFF5 :: lookup ( $ color ) ; }
3843	private function parsePanelSearch ( PanelRowInterface $ row ) { if ( $ row -> hasElement ( 'search' ) ) { $ element = $ row -> getElement ( 'search' ) ; } else { $ element = new DefaultSearchElementInformation ( ) ; } if ( ! $ element instanceof SearchElementInformationInterface ) { throw new \ InvalidArgumentException ( 'Search element does not implement the correct interface.' ) ; } foreach ( $ this -> inputScreen [ 'properties' ] as $ value ) { if ( ! empty ( $ value [ 'search' ] ) ) { $ element -> addProperty ( $ value [ 'col_name' ] ) ; } } if ( $ element -> getPropertyNames ( ) && ! $ row -> hasElement ( 'search' ) ) { $ row -> addElement ( $ element ) ; } }
12643	public function getWidgetId ( ) { if ( ! is_null ( $ this -> _widgetId ) ) { return $ this -> _widgetId ; } return $ this -> _widgetId = 'ic-widget-' . md5 ( microtime ( ) . mt_rand ( ) ) ; }
11979	public function transformCard ( AbstractMessage $ message ) { $ type = $ message -> getType ( ) ; return [ 'msgtype' => $ type , $ type => [ 'card_id' => $ message -> get ( 'card_id' ) , ] , ] ; }
3195	public function setConsumedExtraTime ( $ time ) { $ this -> consumedExtraTime = max ( $ this -> consumedExtraTime , floatval ( $ time ) ) ; return $ this ; }
9219	protected function requestPageNumber ( $ pageNumber , $ forceRefresh = false ) { if ( ! isset ( $ this -> data [ $ this -> pageNumberToKey ( $ pageNumber ) ] ) || ( $ forceRefresh && isset ( $ this -> api ) ) ) { if ( isset ( $ this -> pagination [ CanvasPageLink :: CURRENT ] ) ) { $ params = $ this -> pagination [ CanvasPageLink :: CURRENT ] -> getParams ( ) ; $ params [ CanvasPageLink :: PARAM_PAGE_NUMBER ] = $ pageNumber ; $ page = $ this -> api -> get ( $ this -> pagination [ CanvasPageLink :: CURRENT ] -> getEndpoint ( ) , $ params ) ; $ this -> data = array_replace ( $ this -> data , $ page -> data ) ; $ pagination = $ this -> parsePageLinks ( ) ; $ this -> paginationPerPage [ $ pagination [ CanvasPageLink :: CURRENT ] -> getPageNumber ( ) ] = $ pagination ; return true ; } } return false ; }
2674	public function deleteAcl ( $ version , $ name ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/acl/' . $ name ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: DELETE ) ; return $ result ; }
7364	protected function updateInvoiceTotal ( SaleInterface $ sale ) { if ( ! $ sale instanceof InvoiceSubjectInterface ) { return false ; } $ changed = false ; $ invoice = $ this -> invoiceCalculator -> calculateInvoiceTotal ( $ sale ) ; if ( 0 != Money :: compare ( $ invoice , $ sale -> getInvoiceTotal ( ) , $ sale -> getCurrency ( ) -> getCode ( ) ) ) { $ sale -> setInvoiceTotal ( $ invoice ) ; $ changed = true ; } $ credit = $ this -> invoiceCalculator -> calculateCreditTotal ( $ sale ) ; if ( 0 != Money :: compare ( $ credit , $ sale -> getCreditTotal ( ) , $ sale -> getCurrency ( ) -> getCode ( ) ) ) { $ sale -> setCreditTotal ( $ credit ) ; $ changed = true ; } return $ changed ; }
7309	public static function now ( $ timezone = null ) { $ now = explode ( ' ' , microtime ( ) ) ; $ unix = $ now [ 1 ] ; $ micro = Time :: sec ( $ now [ 0 ] ) ; $ jd = ( $ unix / 86400.0 ) + static :: UJD ; if ( $ timezone == null ) { $ timezone = TimeZone :: UTC ( ) ; } if ( is_string ( $ timezone ) ) { $ timezone = TimeZone :: parse ( $ timezone ) ; } return static :: jd ( $ jd ) -> add ( $ micro ) -> setTimezone ( $ timezone ) ; }
4857	public function getParams ( $ namespace , $ defaults , $ params = null ) { $ session = new Container ( $ namespace ) ; $ sessionParams = $ session -> params ? : array ( ) ; $ params = $ params ? : clone $ this -> getController ( ) -> getRequest ( ) -> getQuery ( ) ; if ( $ params -> get ( 'clear' ) ) { $ sessionParams = array ( ) ; unset ( $ params [ 'clear' ] ) ; } $ changed = false ; foreach ( $ defaults as $ key => $ default ) { if ( is_numeric ( $ key ) ) { $ key = $ default ; $ default = null ; } $ value = $ params -> get ( $ key ) ; if ( null === $ value ) { if ( isset ( $ sessionParams [ $ key ] ) ) { $ params -> set ( $ key , $ sessionParams [ $ key ] ) ; } elseif ( null !== $ default ) { $ params -> set ( $ key , $ default ) ; $ sessionParams [ $ key ] = $ default ; $ changed = true ; } } else { if ( ! isset ( $ sessionParams [ $ key ] ) || $ sessionParams [ $ key ] != $ value ) { $ changed = true ; $ sessionParams [ $ key ] = $ value ; } } } if ( $ changed ) { unset ( $ session -> list ) ; $ session -> params = $ sessionParams ; } return $ params ; }
7925	public function registerPlugin ( PluginInterface $ plugin ) { $ plugin -> register ( $ this ) ; $ this -> plugins [ ] = $ plugin ; return $ this ; }
11285	public function isPlaceholder ( $ attributeName ) { $ def = $ this -> model_attributes [ $ attributeName ] ; if ( isset ( $ def [ 'models' ] ) || ( isset ( $ def [ 'model' ] ) && isset ( $ def [ 'usesRefTable' ] ) ) ) { return true ; } return false ; }
10915	protected function findController ( $ object ) { $ urlargs = $ this -> arguments ; $ arg = $ urlargs -> shift ( ) ; $ controller = $ arg ; if ( ( $ pos = strpos ( $ controller , '.' ) ) !== false ) $ controller = substr ( $ controller , 0 , $ pos ) ; if ( ! method_exists ( $ object , $ controller ) ) { if ( method_exists ( $ object , "index" ) ) { if ( $ controller !== null ) $ urlargs -> unshift ( $ arg ) ; $ controller = "index" ; } else throw new HTTPError ( 404 , "Unknown controller: " . $ controller ) ; } return $ controller ; }
7612	public function getIsSuperAdmin ( ) { if ( $ this -> _isSuperAdmin !== null ) { return $ this -> _isSuperAdmin ; } $ this -> _isSuperAdmin = in_array ( $ this -> username , Yii :: $ app -> getModule ( 'auth' ) -> superAdmins ) ; return $ this -> _isSuperAdmin ; }
8204	protected function reserveJob ( $ tube ) { try { return $ this -> getPheanstalk ( ) -> reserveFromTube ( $ tube , 0 ) ; } catch ( ServerException $ e ) { if ( $ this -> isNotFoundException ( $ e ) ) { return ; } throw $ e ; } }
6323	public function getA ( StringType $ name ) { if ( ! $ this -> hasA ( $ name ) ) { throw new AttributesException ( "Attribute: {$name} does not exist" ) ; } return $ this -> attributes [ $ name ( ) ] ; }
2281	protected static function httpHost ( ) { if ( ! empty ( $ _SERVER [ 'HTTP_HOST' ] ) ) { $ host = $ _SERVER [ 'HTTP_HOST' ] ; } else { $ host = $ _SERVER [ 'SERVER_NAME' ] ; if ( $ _SERVER [ 'SERVER_PORT' ] != 80 ) { $ host .= ':' . $ _SERVER [ 'SERVER_PORT' ] ; } } return preg_replace ( '/[^A-Za-z0-9[\].:-]/' , '' , $ host ) ; }
5175	public function set ( string $ key , $ value ) : self { if ( ! isset ( $ this -> props [ $ key ] ) ) { throw new \ Exception ( 'Cannot add new property from set. Use add()' ) ; } $ this -> props [ $ key ] = $ value ; return $ this ; }
5590	public function setIdentity ( $ host , $ realm , $ username , $ password ) { $ this -> authenticator -> setIdentityForRealm ( $ host , $ realm , $ username , $ password ) ; }
10620	public function boot ( ) { if ( ! $ this -> booted ) { foreach ( $ this -> providers as $ provider ) { $ provider -> boot ( $ this ) ; } } $ this -> booted = true ; }
8772	protected function markAsRegistered ( ServiceProvider $ provider ) { $ this -> serviceProviders [ ] = $ provider ; $ this -> loadedProviders [ get_class ( $ provider ) ] = true ; }
4378	protected function buildTableRow ( $ row , $ keys , $ rowKey ) { $ str = '' ; $ values = $ this -> debug -> methodTable -> keyValues ( $ row , $ keys , $ objInfo ) ; $ parsed = $ this -> debug -> utilities -> parseTag ( $ this -> dump ( $ rowKey ) ) ; $ str .= '<tr>' ; $ str .= $ this -> debug -> utilities -> buildTag ( 'th' , array ( 'class' => 't_key text-right ' . $ parsed [ 'attribs' ] [ 'class' ] , 'scope' => 'row' , ) , $ parsed [ 'innerhtml' ] ) ; if ( $ objInfo [ 'row' ] ) { $ str .= $ this -> markupClassname ( $ objInfo [ 'row' ] [ 'className' ] , 'td' , array ( 'title' => $ objInfo [ 'row' ] [ 'phpDoc' ] [ 'summary' ] ? : null , ) ) ; $ this -> tableInfo [ 'haveObjRow' ] = true ; } else { $ str .= '<td class="t_classname"></td>' ; } foreach ( $ values as $ v ) { $ str .= $ this -> dump ( $ v , true , 'td' ) ; } $ str .= '</tr>' . "\n" ; $ str = \ str_replace ( ' title=""' , '' , $ str ) ; foreach ( \ array_keys ( $ this -> tableInfo [ 'totals' ] ) as $ k ) { $ this -> tableInfo [ 'totals' ] [ $ k ] += $ values [ $ k ] ; } foreach ( $ objInfo [ 'cols' ] as $ k2 => $ classname ) { if ( $ this -> tableInfo [ 'colClasses' ] [ $ k2 ] === false ) { continue ; } if ( $ this -> tableInfo [ 'colClasses' ] [ $ k2 ] === null ) { $ this -> tableInfo [ 'colClasses' ] [ $ k2 ] = $ classname ; } if ( $ this -> tableInfo [ 'colClasses' ] [ $ k2 ] !== $ classname ) { $ this -> tableInfo [ 'colClasses' ] [ $ k2 ] = false ; } } return $ str ; }
310	protected function composeMessage ( $ body ) { $ message = $ this -> mailer -> compose ( ) ; Yii :: configure ( $ message , $ this -> message ) ; $ message -> setTextBody ( $ body ) ; return $ message ; }
8863	public function getHTMLFragments ( $ gridField ) { $ dataClass = $ gridField -> getList ( ) -> dataClass ( ) ; $ obj = singleton ( $ dataClass ) ; if ( ! $ obj -> canCreate ( ) ) return "" ; $ dbField = $ this -> getDataObjectField ( ) ; $ textField = TextField :: create ( "gridfieldaddbydbfield[" . $ obj -> ClassName . "][" . Convert :: raw2htmlatt ( $ dbField ) . "]" ) -> setAttribute ( "placeholder" , $ obj -> fieldLabel ( $ dbField ) ) -> addExtraClass ( "no-change-track" ) ; $ addAction = new GridField_FormAction ( $ gridField , 'add' , _t ( 'GridFieldAddByDBField.Add' , "Add {name}" , "Add button text" , array ( "name" => $ obj -> i18n_singular_name ( ) ) ) , 'add' , 'add' ) ; $ addAction -> setAttribute ( 'data-icon' , 'add' ) ; $ forTemplate = new ArrayData ( array ( ) ) ; $ forTemplate -> Fields = new ArrayList ( ) ; $ forTemplate -> Fields -> push ( $ textField ) ; $ forTemplate -> Fields -> push ( $ addAction ) ; return array ( $ this -> targetFragment => $ forTemplate -> renderWith ( "GridFieldAddByDBField" ) ) ; }
2761	public function getLogLevelMapping ( string $ eventName ) : string { if ( ! isset ( $ this -> logLevelMappings [ $ eventName ] ) ) { throw new GitException ( sprintf ( 'Unknown event "%s"' , $ eventName ) ) ; } return $ this -> logLevelMappings [ $ eventName ] ; }
11398	public function remove ( $ sourceDir , array $ options , $ username ) { $ dir = $ this -> init ( $ sourceDir , $ options , $ username ) -> getDirInUse ( ) ; $ blockName = $ options [ "blockname" ] ; $ blocksDir = $ dir . '/blocks' ; $ filename = sprintf ( '%s/%s.json' , $ blocksDir , $ blockName ) ; $ options [ "block" ] = JsonTools :: jsonDecode ( FilesystemTools :: readFile ( $ filename ) ) ; Dispatcher :: dispatch ( BlockEvents :: BLOCK_REMOVING , new BlockRemovingEvent ( $ this -> serializer , $ filename ) ) ; $ this -> filesystem -> remove ( $ filename ) ; $ this -> removeBlockFromSlotFile ( $ options , $ dir ) ; Dispatcher :: dispatch ( BlockEvents :: BLOCK_REMOVED , new BlockRemovedEvent ( $ this -> serializer , $ filename ) ) ; DataLogger :: log ( sprintf ( 'Block "%s" has been removed from the "%s" slot on page "%s" for the "%s_%s" language' , $ options [ "blockname" ] , $ options [ "slot" ] , $ options [ "page" ] , $ options [ "language" ] , $ options [ "country" ] ) ) ; }
6190	public function renderJSON ( $ data , $ status = 200 ) { exit ( Response :: Create ( json_encode ( $ data ) ) -> status ( $ status ) -> headers ( [ 'Content-Type' => 'application/json' ] ) -> display ( ) ) ; }
6543	public function current ( ) { $ this -> prepareQuery ( ) ; if ( false !== current ( $ this -> idsArray ) ) { return current ( $ this -> idsArray ) ; } else { throw new PointerException ( 'Can\'t retrieve the current element' ) ; } }
12406	public function exists ( $ key ) { $ filenameCache = $ this -> location . DS . $ key ; if ( file_exists ( $ filenameCache ) ) { return true ; } return false ; }
6766	public function onAddressChange ( ResourceEventInterface $ event ) { $ sale = $ this -> getSaleFromEvent ( $ event ) ; if ( $ this -> persistenceHelper -> isScheduledForRemove ( $ sale ) ) { $ event -> stopPropagation ( ) ; return ; } if ( $ this -> handleAddressChange ( $ sale ) ) { $ this -> persistenceHelper -> persistAndRecompute ( $ sale , false ) ; $ this -> scheduleContentChangeEvent ( $ sale ) ; } }
9167	public function setFieldValidationStatus ( $ action = '' , $ shortname = '' , Elements \ ValidationStatus $ validation = null ) { if ( ! isset ( $ _SESSION [ 'prototyper_validation' ] [ $ action ] ) ) { $ _SESSION [ 'prototyper_validation' ] [ $ action ] = array ( ) ; } $ _SESSION [ 'prototyper_validation' ] [ $ action ] [ $ shortname ] = array ( 'status' => $ validation -> getStatus ( ) , 'messages' => $ validation -> getMessages ( ) ) ; }
9485	public function checkCreatable ( ) { if ( property_exists ( $ this , 'id' ) && $ this -> id > 0 ) { throw new \ Exception ( get_class ( $ this ) . " has ID:" . $ this -> id ( ) . " thus not creatable." ) ; } }
11173	public static function decrypt ( $ data , $ key , $ cipher = MCRYPT_RIJNDAEL_128 , $ mode = MCRYPT_MODE_CBC ) { $ key = hash ( 'sha256' , $ key , true ) ; @ list ( $ iv , $ encrypted ) = ( array ) unserialize ( base64_decode ( $ data ) ) ; return unserialize ( trim ( mcrypt_decrypt ( $ cipher , $ key , $ encrypted , $ mode , $ iv ) ) ) ; }
11321	function getRow ( $ sql , $ params = array ( ) ) { $ data = $ this -> query ( $ sql , $ params ) ; $ row = false ; if ( count ( $ data ) > 0 ) { $ row = $ data [ 0 ] ; } return $ row ; }
8221	protected function getEntityId ( $ blockType , $ config , $ params = array ( ) ) { $ entityId = null ; if ( $ blockType === "account" && isset ( $ params [ "name" ] ) ) { $ entityId = md5 ( $ params [ "name" ] ) ; } elseif ( $ blockType === "email" && isset ( $ params [ "email" ] ) ) { $ entityId = md5 ( $ params [ "email" ] ) ; } elseif ( $ blockType === "ip" ) { $ entityId = $ this -> getIp ( $ config ) ; } return $ entityId ; }
7004	public function format ( $ format ) { $ this -> format = $ format ; $ format = preg_replace ( '/([a-zA-Z])/' , '%$1' , $ format ) ; $ format = preg_replace ( '/\\\\%(.)/' , '\\\\$1' , $ format ) ; $ this -> format_d ( $ format ) ; $ this -> formatD ( $ format ) ; $ this -> format_j ( $ format ) ; $ this -> format_l ( $ format ) ; $ this -> formatL ( $ format ) ; $ this -> formatN ( $ format ) ; $ this -> formatS ( $ format ) ; $ this -> format_w ( $ format ) ; $ this -> format_z ( $ format ) ; $ this -> formatW ( $ format ) ; $ this -> formatF ( $ format ) ; $ this -> format_m ( $ format ) ; $ this -> formatM ( $ format ) ; $ this -> format_n ( $ format ) ; $ this -> format_t ( $ format ) ; $ this -> formatY ( $ format ) ; $ this -> format_y ( $ format ) ; $ this -> format_a ( $ format ) ; $ this -> formatA ( $ format ) ; $ this -> format_g ( $ format ) ; $ this -> formatG ( $ format ) ; $ this -> format_h ( $ format ) ; $ this -> formatH ( $ format ) ; $ this -> format_i ( $ format ) ; $ this -> format_s ( $ format ) ; $ this -> format_u ( $ format ) ; $ this -> format_e ( $ format ) ; $ this -> formatO ( $ format ) ; $ this -> formatP ( $ format ) ; $ this -> formatZ ( $ format ) ; $ this -> format_r ( $ format ) ; $ this -> format_c ( $ format ) ; $ this -> formatC ( $ format ) ; return str_replace ( '\\' , '' , $ format ) ; }
3529	public static function sendUnrealClientGetRequest ( $ endpoint , $ authorization = self :: EPIC_LAUNCHER_AUTHORIZATION , $ oauth = false ) { $ client = new Client ( ) ; try { $ response = $ client -> get ( $ endpoint , [ 'headers' => [ 'User-Agent' => self :: UNREAL_CLIENT_USER_AGENT , 'Authorization' => ( ! $ oauth ) ? 'basic ' . $ authorization : 'bearer ' . $ authorization ] ] ) ; return json_decode ( $ response -> getBody ( ) -> getContents ( ) ) ; } catch ( GuzzleException $ e ) { throw $ e ; } }
594	private function composeCircularDependencyTrace ( $ circularDependencyName , array $ registered ) { $ dependencyTrace = [ ] ; $ startFound = false ; foreach ( $ registered as $ name => $ value ) { if ( $ name === $ circularDependencyName ) { $ startFound = true ; } if ( $ startFound && $ value === false ) { $ dependencyTrace [ ] = $ name ; } } $ dependencyTrace [ ] = $ circularDependencyName ; return implode ( ' -> ' , $ dependencyTrace ) ; }
3116	public function setCatValue ( $ testSessionId , $ assessmentSectionId , $ key , $ value ) { $ extendedState = $ this -> getExtendedState ( $ testSessionId ) ; $ extendedState -> setCatValue ( $ assessmentSectionId , $ key , $ value ) ; $ extendedState -> save ( ) ; }
5359	protected function createUrlStatements ( Operation $ operation , $ queryParamVariable ) { $ urlVariable = new Expr \ Variable ( 'url' ) ; $ statements = [ new Expr \ Assign ( $ urlVariable , new Scalar \ String_ ( $ operation -> getPath ( ) ) ) ] ; if ( $ operation -> getOperation ( ) -> getParameters ( ) ) { foreach ( $ operation -> getOperation ( ) -> getParameters ( ) as $ parameter ) { if ( $ parameter instanceof Reference ) { $ parameter = $ this -> resolveParameter ( $ parameter ) ; } if ( $ parameter instanceof PathParameterSubSchema ) { $ statements [ ] = new Expr \ Assign ( $ urlVariable , new Expr \ FuncCall ( new Name ( 'str_replace' ) , [ new Arg ( new Scalar \ String_ ( '{' . $ parameter -> getName ( ) . '}' ) ) , new Arg ( new Expr \ FuncCall ( new Name ( 'urlencode' ) , [ new Arg ( new Expr \ Variable ( Inflector :: camelize ( $ parameter -> getName ( ) ) ) ) , ] ) ) , new Arg ( $ urlVariable ) ] ) ) ; } } } $ statements [ ] = new Expr \ Assign ( $ urlVariable , new Expr \ BinaryOp \ Concat ( $ urlVariable , new Expr \ BinaryOp \ Concat ( new Scalar \ String_ ( '?' ) , new Expr \ MethodCall ( $ queryParamVariable , 'buildQueryString' , [ new Arg ( new Expr \ Variable ( 'parameters' ) ) ] ) ) ) ) ; return [ $ statements , $ urlVariable ] ; }
8484	public static function getHostname ( ) { $ wmi = Windows :: getInstance ( ) ; foreach ( $ wmi -> ExecQuery ( "SELECT Name FROM Win32_ComputerSystem" ) as $ cs ) { return $ cs -> Name ; } return "Unknown" ; }
7947	public function lineResetDslamPort ( $ id , $ line ) { if ( ! $ id ) throw new BadMethodCallException ( 'Missing parameter $id.' ) ; if ( ! $ line ) throw new BadMethodCallException ( 'Missing parameter $line.' ) ; try { $ r = $ this -> post ( 'xdsl/' . $ id . '/lines/' . $ line . '/resetDslamPort' ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new XdslException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
6180	protected function write ( array $ record ) { $ severity = $ this -> getSeverity ( $ record [ 'level' ] ) ; if ( isset ( $ record [ 'context' ] [ 'exception' ] ) ) { $ this -> client -> notifyException ( $ record [ 'context' ] [ 'exception' ] , function ( \ Bugsnag \ Report $ report ) use ( $ record , $ severity ) { $ report -> setSeverity ( $ severity ) ; if ( isset ( $ record [ 'extra' ] ) ) { $ report -> setMetaData ( $ record [ 'extra' ] ) ; } } ) ; } else { $ this -> client -> notifyError ( ( string ) $ record [ 'message' ] , ( string ) $ record [ 'formatted' ] , function ( \ Bugsnag \ Report $ report ) use ( $ record , $ severity ) { $ report -> setSeverity ( $ severity ) ; if ( isset ( $ record [ 'extra' ] ) ) { $ report -> setMetaData ( $ record [ 'extra' ] ) ; } } ) ; } }
3578	protected function metaSelect ( Builder $ query , ArgumentBag $ args ) { $ columns = $ args -> get ( 'columns' ) ; foreach ( $ columns as $ key => $ column ) { list ( $ column , $ alias ) = $ this -> extractColumnAlias ( $ column ) ; if ( $ this -> hasColumn ( $ column ) ) { $ select = "{$this->getTable()}.{$column}" ; if ( $ column !== $ alias ) { $ select .= " as {$alias}" ; } $ columns [ $ key ] = $ select ; } elseif ( is_string ( $ column ) && $ column != '*' && strpos ( $ column , '.' ) === false ) { $ table = $ this -> joinMeta ( $ query , $ column ) ; $ columns [ $ key ] = "{$table}.meta_value as {$alias}" ; } } $ args -> set ( 'columns' , $ columns ) ; }
230	public function getLastInsertID ( $ sequenceName = '' ) { if ( $ this -> db -> isActive ) { return $ this -> db -> pdo -> lastInsertId ( $ sequenceName === '' ? null : $ this -> quoteTableName ( $ sequenceName ) ) ; } throw new InvalidCallException ( 'DB Connection is not active.' ) ; }
1750	public static function log ( $ strText , $ strFunction , $ strCategory ) { @ trigger_error ( 'Using System::log() has been deprecated and will no longer work in Contao 5.0. Use the logger service instead.' , E_USER_DEPRECATED ) ; $ level = 'ERROR' === $ strCategory ? LogLevel :: ERROR : LogLevel :: INFO ; $ logger = static :: getContainer ( ) -> get ( 'monolog.logger.contao' ) ; $ logger -> log ( $ level , $ strText , array ( 'contao' => new ContaoContext ( $ strFunction , $ strCategory ) ) ) ; }
7408	public function merge ( $ ta ) : self { $ this -> _massageBlockInput ( $ in ) ; $ ret = clone $ this ; foreach ( $ ta as $ k => $ v ) { if ( is_int ( $ k ) ) { $ ret [ ] = $ v ; } else { $ ret [ $ k ] = $ v ; } } return $ ret ; }
7378	public function fetchBool ( string $ key , bool $ default = false ) : bool { return $ this -> fetchFilter ( $ key , $ default , FILTER_VALIDATE_BOOLEAN ) ; }
989	public function save ( ) { if ( ! $ this -> response ) { throw new Exception ( 'No activation response was recieved.' ) ; } $ planCharge = $ this -> shop -> planCharge ( ) ; if ( $ planCharge && ! $ planCharge -> isDeclined ( ) && ! $ planCharge -> isCancelled ( ) ) { $ planCharge -> cancel ( ) ; } $ charge = Charge :: firstOrNew ( [ 'charge_id' => $ this -> chargeId , 'shop_id' => $ this -> shop -> id , ] ) ; $ charge -> plan_id = $ this -> plan -> id ; $ charge -> type = $ this -> plan -> type ; $ charge -> status = $ this -> response -> status ; if ( $ this -> plan -> isType ( Plan :: PLAN_RECURRING ) ) { $ charge -> billing_on = $ this -> response -> billing_on ; $ charge -> trial_ends_on = $ this -> response -> trial_ends_on ; } $ charge -> activated_on = $ this -> response -> activated_on ?? Carbon :: today ( ) -> format ( 'Y-m-d' ) ; $ planDetails = $ this -> chargeParams ( ) ; unset ( $ planDetails [ 'return_url' ] ) ; foreach ( $ planDetails as $ key => $ value ) { $ charge -> { $ key } = $ value ; } return $ charge -> save ( ) ; }
6851	public static function fuzzySpan ( $ timestamp , $ local_timestamp = null ) { $ local_timestamp = ( $ local_timestamp === null ) ? time ( ) : ( int ) $ local_timestamp ; $ offset = abs ( $ local_timestamp - $ timestamp ) ; if ( $ offset <= static :: MINUTE ) { $ span = 'moments' ; } elseif ( $ offset < ( static :: MINUTE * 20 ) ) { $ span = 'a few minutes' ; } elseif ( $ offset < static :: HOUR ) { $ span = 'less than an hour' ; } elseif ( $ offset < ( static :: HOUR * 4 ) ) { $ span = 'a couple of hours' ; } elseif ( $ offset < static :: DAY ) { $ span = 'less than a day' ; } elseif ( $ offset < ( static :: DAY * 2 ) ) { $ span = 'about a day' ; } elseif ( $ offset < ( static :: DAY * 4 ) ) { $ span = 'a couple of days' ; } elseif ( $ offset < static :: WEEK ) { $ span = 'less than a week' ; } elseif ( $ offset < ( static :: WEEK * 2 ) ) { $ span = 'about a week' ; } elseif ( $ offset < static :: MONTH ) { $ span = 'less than a month' ; } elseif ( $ offset < ( static :: MONTH * 2 ) ) { $ span = 'about a month' ; } elseif ( $ offset < ( static :: MONTH * 4 ) ) { $ span = 'a couple of months' ; } elseif ( $ offset < static :: YEAR ) { $ span = 'less than a year' ; } elseif ( $ offset < ( static :: YEAR * 2 ) ) { $ span = 'about a year' ; } elseif ( $ offset < ( static :: YEAR * 4 ) ) { $ span = 'a couple of years' ; } elseif ( $ offset < ( static :: YEAR * 8 ) ) { $ span = 'a few years' ; } elseif ( $ offset < ( static :: YEAR * 12 ) ) { $ span = 'about a decade' ; } elseif ( $ offset < ( static :: YEAR * 24 ) ) { $ span = 'a couple of decades' ; } elseif ( $ offset < ( static :: YEAR * 64 ) ) { $ span = 'several decades' ; } else { $ span = 'a long time' ; } if ( $ timestamp <= $ local_timestamp ) { return $ span . ' ago' ; } else { return 'in ' . $ span ; } }
12214	public function run ( $ route ) { if ( ! is_array ( $ route ) ) { $ this -> makeResponse ( $ route ) ; } $ viewSegments = explode ( '.' , $ route [ 'view' ] ) ; $ method = $ route [ 'method' ] ; Setup :: toDefine ( 'TEMPLATES_PATH' , APPS_ROOT . DS . $ this -> appName . DS . 'Templates' . DS ) ; Setup :: toDefine ( 'STATIC_PATH' , APPS_ROOT . DS . 'static' . DS ) ; $ viewPath = '' ; $ view = $ viewSegments [ 0 ] ; if ( count ( $ viewSegments ) > 1 ) { $ view = $ viewSegments [ count ( $ viewSegments ) - 1 ] ; array_pop ( $ viewSegments ) ; $ viewPath = implode ( '\\' , $ viewSegments ) ; $ viewPath .= '\\' ; } if ( $ view instanceof \ ForeverPHP \ View \ View ) { throw new ViewException ( "La vista ($view) no hereda de View." ) ; } if ( Settings :: getInstance ( ) -> get ( 'usingNamespaces' ) ) { $ view = '\\Apps\\' . $ this -> appName . '\\Views\\' . $ viewPath . $ view ; } $ v = new $ view ( ) ; $ returnValue = $ v -> $ method ( ) ; $ this -> makeResponse ( $ returnValue ) ; }
12915	protected function getColumnReference ( $ column , $ tableless ) { if ( $ tableless ) { return $ column ; } if ( count ( explode ( "." , $ column ) ) > 1 ) { return $ column ; } return "`" . $ this -> table . "`.`" . $ column . "`" ; }
3148	public function isItemCompleted ( RunnerServiceContext $ context , $ routeItem , $ itemSession , $ partially = true ) { if ( $ context instanceof QtiRunnerServiceContext && $ context -> isAdaptive ( ) ) { $ itemIdentifier = $ context -> getCurrentAssessmentItemRef ( ) -> getIdentifier ( ) ; $ itemState = $ this -> getItemState ( $ context , $ itemIdentifier ) ; if ( $ itemState !== null ) { $ itemResponse = [ ] ; foreach ( $ itemState as $ key => $ value ) { if ( isset ( $ value [ 'response' ] ) ) { $ itemResponse [ $ key ] = $ value [ 'response' ] ; } } $ responses = $ this -> parsesItemResponse ( $ context , $ itemIdentifier , $ itemResponse ) ; $ excludedResponseVariables = array ( 'numAttempts' , 'duration' ) ; foreach ( $ responses as $ var ) { if ( $ var instanceof ResponseVariable && in_array ( $ var -> getIdentifier ( ) , $ excludedResponseVariables ) === false ) { $ value = $ var -> getValue ( ) ; $ defaultValue = $ var -> getDefaultValue ( ) ; if ( Utils :: isNull ( $ value ) === true ) { if ( Utils :: isNull ( $ defaultValue ) === ( ( $ partially ) ? false : true ) ) { return ( ( $ partially ) ? true : false ) ; } } else { if ( $ value -> equals ( $ defaultValue ) === ( ( $ partially ) ? false : true ) ) { return ( ( $ partially ) ? true : false ) ; } } } } } return ( ( $ partially ) ? false : true ) ; } else { return TestRunnerUtils :: isItemCompleted ( $ routeItem , $ itemSession , $ partially ) ; } }
1560	protected function modelKeyForField ( $ field , $ model ) { if ( isset ( $ this -> attributes [ $ field ] ) ) { return $ this -> attributes [ $ field ] ; } $ key = $ model :: $ snakeAttributes ? Str :: underscore ( $ field ) : Str :: camelize ( $ field ) ; return $ this -> attributes [ $ field ] = $ key ; }
4435	public static function fromErrorMessage ( string $ error ) : QlessException { $ area = null ; $ message = $ error ; if ( preg_match ( self :: ERROR_MESSAGE_RE , $ error , $ matches ) > 0 ) { $ area = $ matches [ 'area' ] ; $ message = $ matches [ 'message' ] ; } switch ( true ) { case ( $ area === 'Requeue' && stripos ( $ message , 'does not exist' ) !== false ) : case ( stripos ( $ message , 'Job does not exist' ) !== false ) : return new InvalidJobException ( $ message , $ area ) ; case ( stripos ( $ message , 'Job given out to another worker' ) !== false ) : return new JobLostException ( $ message , $ area ) ; case ( stripos ( $ message , 'Job not currently running' ) !== false ) : default : return new QlessException ( $ message , $ area ) ; } }
3146	public function resume ( RunnerServiceContext $ context ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ context -> getTestSession ( ) -> resume ( ) ; $ this -> persist ( $ context ) ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'resume' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } return true ; }
9406	protected function approach ( $ middleware ) { if ( $ middleware instanceof \ Closure ) { $ object = new \ ReflectionFunction ( $ middleware ) ; return count ( $ object -> getParameters ( ) ) === 2 ; } $ class = ( string ) get_class ( $ middleware ) ; $ object = new \ ReflectionMethod ( $ class , '__invoke' ) ; return count ( $ object -> getParameters ( ) ) === 2 ; }
5980	public function socialmedia ( ) { if ( ! $ this -> socialmedia instanceof SocialmediaController ) { $ this -> socialmedia = new SocialmediaController ( $ this -> getClient ( ) , $ this -> cachePolicy , $ this -> cache ) ; $ this -> socialmedia -> setLogger ( $ this -> logger ) ; } return $ this -> socialmedia ; }
6517	public function setParameterType ( $ method , $ name , $ type ) { if ( ! isset ( $ this -> parameterTypes [ $ method ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'A method with name "%s" is not defined' , $ name , $ method ) ) ; } if ( ! array_key_exists ( $ name , $ this -> parameterTypes [ $ method ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'A parameter with name "%s" for method "%s" is not defined' , $ name , $ method ) ) ; } $ this -> parameterTypes [ $ method ] [ $ name ] = $ type ; }
2173	private function warmUpSymfonyCache ( ) : void { $ cacheDir = $ this -> getContainerParameter ( 'kernel.cache_dir' ) ; if ( file_exists ( $ cacheDir . '/contao/config/config.php' ) ) { return ; } $ warmer = $ this -> container -> get ( 'cache_warmer' ) ; if ( ! $ this -> getContainerParameter ( 'kernel.debug' ) ) { $ warmer -> enableOptionalWarmers ( ) ; } $ warmer -> warmUp ( $ cacheDir ) ; if ( \ function_exists ( 'opcache_reset' ) ) { opcache_reset ( ) ; } if ( \ function_exists ( 'apc_clear_cache' ) && ! ini_get ( 'apc.stat' ) ) { apc_clear_cache ( ) ; } }
765	private function extractUsedParams ( SqlToken $ statement , $ params ) { preg_match_all ( '/(?P<placeholder>[:][a-zA-Z0-9_]+)/' , $ statement -> getSql ( ) , $ matches , PREG_SET_ORDER ) ; $ result = [ ] ; foreach ( $ matches as $ match ) { $ phName = ltrim ( $ match [ 'placeholder' ] , ':' ) ; if ( isset ( $ params [ $ phName ] ) ) { $ result [ $ phName ] = $ params [ $ phName ] ; } elseif ( isset ( $ params [ ':' . $ phName ] ) ) { $ result [ ':' . $ phName ] = $ params [ ':' . $ phName ] ; } } return $ result ; }
10689	private function setupLogging ( ) { $ test = defined ( 'WEDETO_TEST' ) && WEDETO_TEST === 1 ? 'test' : '' ; $ root_logger = Logger :: getLogger ( ) ; $ root_logger -> setLevel ( LogLevel :: INFO ) ; if ( $ this -> path_config -> log ) { $ logfile = $ this -> path_config -> log . '/wedeto' . $ test . '.log' ; $ root_logger -> addLogWriter ( new FileWriter ( $ logfile , LogLevel :: DEBUG ) ) ; } if ( $ this -> config -> has ( 'log' , Type :: ARRAY ) ) { foreach ( $ this -> config [ 'log' ] as $ logname => $ level ) { if ( $ logname === "writer" ) { foreach ( $ level as $ logname => $ parameters ) { $ logger = Logger :: getLogger ( $ logname ) ; $ parameters = str_replace ( '{LOGDIR}' , $ this -> path_config -> log , $ parameters ) ; $ parameters = explode ( ';' , $ parameters ) ; $ class = array_shift ( $ parameters ) ; if ( ! class_exists ( $ class ) ) throw new \ DomainException ( "Invalid logger class: $class" ) ; $ refl = new \ ReflectionClass ( $ class ) ; $ writer = $ refl -> newInstanceArgs ( $ parameters ) ; if ( ! ( $ writer instanceof AbstractWriter ) ) throw new \ DomainException ( "Class $class is not a log writer" ) ; $ logger -> addLogWriter ( $ writer ) ; } continue ; } $ logger = Logger :: getLogger ( $ logname ) ; $ level = strtolower ( $ level ) ; try { $ logger -> setLevel ( $ level ) ; } catch ( \ DomainException $ e ) { self :: $ logger -> error ( "Failed to set log level for {0} to {1}: {2}" , [ $ logname , $ level , $ e -> getMessage ( ) ] ) ; } } } if ( $ this -> dev ) { $ devlogger = new MemLogWriter ( LogLevel :: DEBUG ) ; $ root_logger -> addLogWriter ( $ devlogger ) ; } if ( isset ( $ _SERVER [ 'REQUEST_URI' ] ) ) { self :: $ logger -> debug ( "*** Starting processing for {0} request to {1}" , [ $ _SERVER [ 'REQUEST_METHOD' ] , $ _SERVER [ 'REQUEST_URI' ] ] ) ; } if ( Request :: cli ( ) ) { $ limit = ( int ) $ this -> config -> dget ( 'cli' , 'memory_limit' , 1024 ) ; ini_set ( 'memory_limit' , $ limit . 'M' ) ; ini_set ( 'max_execution_time' , 0 ) ; ini_set ( 'display_errors' , 1 ) ; } else ini_set ( 'display_errors' , 0 ) ; }
3518	public function setShowUnpublished ( $ showUnpublished ) { if ( $ this -> useCookies ) { Cookie :: queue ( $ this -> cookiePrefix . 'show_unpublished' , $ showUnpublished ) ; } $ this -> useDB = $ showUnpublished ? 2 : 1 ; }
12590	public function getDataTablesI18nAction ( ) { $ locale = $ this -> get ( 'request_stack' ) -> getCurrentRequest ( ) -> getLocale ( ) ; $ format = $ this -> get ( 'request_stack' ) -> getCurrentRequest ( ) -> getRequestFormat ( ) ; return $ this -> render ( 'AdminBundle:Default/DataTables_i18n:' . $ locale . '.txt.' . $ format ) ; }
11957	public function add ( $ renderer , $ name = null ) { if ( is_null ( $ name ) ) { $ name = $ renderer ; } $ this -> renderers [ $ name ] = $ renderer ; }
3332	public function fromContent ( $ content , $ mime_type ) { $ tmpfile = tempnam ( sys_get_temp_dir ( ) , 'ucr' ) ; $ temp = fopen ( $ tmpfile , 'w' ) ; fwrite ( $ temp , $ content ) ; fclose ( $ temp ) ; return $ this -> fromPath ( $ tmpfile , $ mime_type ) ; }
5421	protected function parse ( $ raw ) { if ( ! $ raw ) { $ this -> setError ( 'Nothing fetched' ) ; $ this -> headers = new SimpleHttpHeaders ( '' ) ; } elseif ( 'file' === $ this -> url -> getScheme ( ) ) { $ this -> headers = new SimpleHttpHeaders ( '' ) ; $ this -> content = $ raw ; } elseif ( ! strstr ( $ raw , "\r\n\r\n" ) ) { $ this -> setError ( 'Could not split headers from content' ) ; $ this -> headers = new SimpleHttpHeaders ( $ raw ) ; } else { list ( $ headers , $ this -> content ) = explode ( "\r\n\r\n" , $ raw , 2 ) ; $ this -> headers = new SimpleHttpHeaders ( $ headers ) ; } }
10095	protected function processDefault ( $ url ) { if ( $ url === null ) { return $ url ; } $ url = ( string ) $ url ; switch ( $ url ) { case '404' : case 'mm' : case 'identicon' : case 'monsterid' : case 'wavatar' : case 'retro' : break ; default : $ valid = filter_var ( $ url , FILTER_VALIDATE_URL ) ; if ( ! $ valid ) { throw new InvalidArgumentException ( 'Invalid default avatar URL' ) ; } break ; } return $ url ; }
8150	public function initRuntime ( ) { $ this -> runtimeInitialized = true ; foreach ( $ this -> getExtensions ( ) as $ name => $ extension ) { if ( ! $ extension instanceof Twig_Extension_InitRuntimeInterface ) { $ m = new ReflectionMethod ( $ extension , 'initRuntime' ) ; if ( 'Twig_Extension' !== $ m -> getDeclaringClass ( ) -> getName ( ) ) { @ trigger_error ( sprintf ( 'Defining the initRuntime() method in the "%s" extension is deprecated since version 1.23. Use the `needs_environment` option to get the Twig_Environment instance in filters, functions, or tests; or explicitly implement Twig_Extension_InitRuntimeInterface if needed (not recommended).' , $ name ) , E_USER_DEPRECATED ) ; } } $ extension -> initRuntime ( $ this ) ; } }
4611	public function get ( $ iSize = 150 , $ sECLevel = 'L' , $ iMargin = 1 ) { return self :: API_URL . $ iSize . 'x' . $ iSize . '&cht=qr&chld=' . $ sECLevel . '|' . $ iMargin . '&chl=' . $ this -> sData ; }
7877	protected function setupPackage ( ) { $ source = realpath ( __DIR__ . '/../config/logviewer.php' ) ; $ this -> publishes ( [ $ source => config_path ( 'logviewer.php' ) ] , 'config' ) ; $ this -> publishes ( [ realpath ( __DIR__ . '/../assets/css' ) => public_path ( 'assets/styles' ) , realpath ( __DIR__ . '/../assets/js' ) => public_path ( 'assets/scripts' ) , ] , 'public' ) ; $ this -> mergeConfigFrom ( $ source , 'logviewer' ) ; $ this -> loadViewsFrom ( realpath ( __DIR__ . '/../views' ) , 'logviewer' ) ; }
2391	public function adjustPermissions ( $ insertId ) { if ( \ func_num_args ( ) == 4 ) { $ insertId = func_get_arg ( 1 ) ; } if ( $ this -> User -> isAdmin ) { return ; } if ( empty ( $ this -> User -> calendarfeeds ) || ! \ is_array ( $ this -> User -> calendarfeeds ) ) { $ root = array ( 0 ) ; } else { $ root = $ this -> User -> calendarfeeds ; } if ( \ in_array ( $ insertId , $ root ) ) { return ; } $ objSessionBag = Contao \ System :: getContainer ( ) -> get ( 'session' ) -> getBag ( 'contao_backend' ) ; $ arrNew = $ objSessionBag -> get ( 'new_records' ) ; if ( \ is_array ( $ arrNew [ 'tl_calendar_feed' ] ) && \ in_array ( $ insertId , $ arrNew [ 'tl_calendar_feed' ] ) ) { if ( $ this -> User -> inherit != 'custom' ) { $ objGroup = $ this -> Database -> execute ( "SELECT id, calendarfeeds, calendarfeedp FROM tl_user_group WHERE id IN(" . implode ( ',' , array_map ( '\intval' , $ this -> User -> groups ) ) . ")" ) ; while ( $ objGroup -> next ( ) ) { $ arrCalendarfeedp = Contao \ StringUtil :: deserialize ( $ objGroup -> calendarfeedp ) ; if ( \ is_array ( $ arrCalendarfeedp ) && \ in_array ( 'create' , $ arrCalendarfeedp ) ) { $ arrCalendarfeeds = Contao \ StringUtil :: deserialize ( $ objGroup -> calendarfeeds , true ) ; $ arrCalendarfeeds [ ] = $ insertId ; $ this -> Database -> prepare ( "UPDATE tl_user_group SET calendarfeeds=? WHERE id=?" ) -> execute ( serialize ( $ arrCalendarfeeds ) , $ objGroup -> id ) ; } } } if ( $ this -> User -> inherit != 'group' ) { $ objUser = $ this -> Database -> prepare ( "SELECT calendarfeeds, calendarfeedp FROM tl_user WHERE id=?" ) -> limit ( 1 ) -> execute ( $ this -> User -> id ) ; $ arrCalendarfeedp = Contao \ StringUtil :: deserialize ( $ objUser -> calendarfeedp ) ; if ( \ is_array ( $ arrCalendarfeedp ) && \ in_array ( 'create' , $ arrCalendarfeedp ) ) { $ arrCalendarfeeds = Contao \ StringUtil :: deserialize ( $ objUser -> calendarfeeds , true ) ; $ arrCalendarfeeds [ ] = $ insertId ; $ this -> Database -> prepare ( "UPDATE tl_user SET calendarfeeds=? WHERE id=?" ) -> execute ( serialize ( $ arrCalendarfeeds ) , $ this -> User -> id ) ; } } $ root [ ] = $ insertId ; $ this -> User -> calendarfeeds = $ root ; } }
11923	public function getPerUnitAmount ( ) { $ amount = $ this -> getProduct ( ) -> getPrice ( ) ; foreach ( $ this -> getOptions ( ) as $ cartOption ) { $ amount = bcadd ( $ amount , $ cartOption -> getOption ( ) -> getPrice ( ) , 2 ) ; } foreach ( $ this -> getExtras ( ) as $ cartExtra ) { $ amount = bcadd ( $ amount , $ cartExtra -> getExtra ( ) -> getPrice ( ) , 2 ) ; } return floatval ( $ amount ) ; }
6325	public function stop ( ) { $ fp = @ fopen ( $ this -> _file , 'w' ) ; fwrite ( $ fp , ob_get_contents ( ) ) ; fclose ( $ fp ) ; ob_end_flush ( ) ; }
593	public function combineCssFiles ( $ inputFiles , $ outputFile ) { $ content = '' ; $ outputFilePath = dirname ( $ this -> findRealPath ( $ outputFile ) ) ; foreach ( $ inputFiles as $ file ) { $ content .= "/*** BEGIN FILE: $file ***/\n" . $ this -> adjustCssUrl ( file_get_contents ( $ file ) , dirname ( $ this -> findRealPath ( $ file ) ) , $ outputFilePath ) . "/*** END FILE: $file ***/\n" ; } if ( ! file_put_contents ( $ outputFile , $ content ) ) { throw new Exception ( "Unable to write output CSS file '{$outputFile}'." ) ; } }
2680	public function checkImageOptimizationStatus ( ) { $ url = $ this -> _getApiServiceUri ( ) . 'dynamic_io_settings' ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: GET ) ; return $ result ; }
6347	public static function all ( Iterator $ iterator , callable $ predicate ) : bool { while ( $ iterator -> valid ( ) ) { if ( ! Predicates :: call ( $ predicate , $ iterator -> current ( ) ) ) { return false ; } $ iterator -> next ( ) ; } return true ; }
12482	private function mapByGeneration ( $ mapByDepthDesc , $ mapById ) { $ result = [ ] ; foreach ( $ mapByDepthDesc as $ depth => $ ids ) { foreach ( $ ids as $ custId ) { $ entry = $ mapById [ $ custId ] ; $ path = $ entry -> getPath ( ) ; $ parents = $ this -> hlpTree -> getParentsFromPathReversed ( $ path ) ; $ level = 0 ; foreach ( $ parents as $ parentId ) { $ level += 1 ; if ( ! isset ( $ result [ $ parentId ] ) ) { $ result [ $ parentId ] = [ ] ; } if ( ! isset ( $ result [ $ parentId ] [ $ level ] ) ) { $ result [ $ parentId ] [ $ level ] = [ ] ; } $ result [ $ parentId ] [ $ level ] [ ] = $ custId ; } } } return $ result ; }
2478	protected function getRequestHeaders ( Message $ message , Endpoint $ endpoint ) { $ headers = $ message -> headers ; if ( $ endpoint -> user !== null ) { $ headers [ 'Authorization' ] = 'Basic ' . base64_encode ( "{$endpoint->user}:{$endpoint->pass}" ) ; } $ requestHeaders = '' ; foreach ( $ headers as $ name => $ value ) { if ( is_numeric ( $ name ) ) { throw new \ RuntimeException ( "Invalid HTTP header name $name" ) ; } $ requestHeaders .= "$name: $value\r\n" ; } return $ requestHeaders ; }
1047	public static function create ( array $ params , bool $ readonly = false ) : OperationParams { $ instance = new static ( ) ; $ params = array_change_key_case ( $ params , CASE_LOWER ) ; $ instance -> originalInput = $ params ; $ params += [ 'query' => null , 'queryid' => null , 'documentid' => null , 'id' => null , 'operationname' => null , 'variables' => null , 'extensions' => null , ] ; if ( $ params [ 'variables' ] === '' ) { $ params [ 'variables' ] = null ; } foreach ( [ 'extensions' , 'variables' ] as $ param ) { if ( ! is_string ( $ params [ $ param ] ) ) { continue ; } $ tmp = json_decode ( $ params [ $ param ] , true ) ; if ( json_last_error ( ) ) { continue ; } $ params [ $ param ] = $ tmp ; } $ instance -> query = $ params [ 'query' ] ; $ instance -> queryId = $ params [ 'queryid' ] ? : $ params [ 'documentid' ] ? : $ params [ 'id' ] ; $ instance -> operation = $ params [ 'operationname' ] ; $ instance -> variables = $ params [ 'variables' ] ; $ instance -> extensions = $ params [ 'extensions' ] ; $ instance -> readOnly = $ readonly ; if ( isset ( $ instance -> extensions [ 'persistedQuery' ] [ 'sha256Hash' ] ) && empty ( $ instance -> query ) && empty ( $ instance -> queryId ) ) { $ instance -> queryId = $ instance -> extensions [ 'persistedQuery' ] [ 'sha256Hash' ] ; } return $ instance ; }
981	public function planCharge ( ) { return $ this -> charges ( ) -> whereIn ( 'type' , [ Charge :: CHARGE_RECURRING , Charge :: CHARGE_ONETIME ] ) -> where ( 'plan_id' , $ this -> plan_id ) -> orderBy ( 'created_at' , 'desc' ) -> first ( ) ; }
11492	public function remove ( string $ key ) { if ( $ this -> contains ( $ key ) ) { $ res = $ _SESSION [ $ key ] ; unset ( $ _SESSION [ $ key ] ) ; return $ res ; } else { return null ; } }
9280	public function deleteByWhere ( $ where = null , array $ options = array ( ) ) { $ delete = $ this -> sql -> delete ( ) ; if ( $ where instanceof Where ) { $ delete -> where ( $ where ) ; } elseif ( is_string ( $ where ) && ! empty ( $ where ) ) { $ delete -> where ( $ where ) ; } $ delete -> where ( $ where ) ; $ limit = array_key_exists ( 'limit' , $ options ) ? ( int ) $ limit : null ; if ( ! is_null ( $ limit ) && ( int ) $ limit > 0 ) { $ delete -> limit ( $ limit ) ; } $ stmt = $ this -> sql -> prepareStatementForSqlObject ( $ delete ) ; return $ stmt -> execute ( ) ; }
9019	public function getKeywords ( $ string , $ amount = 10 ) { $ words = $ this -> getWords ( $ string ) ; $ analysis = new FrequencyAnalysis ( $ words ) ; $ keywords = $ analysis -> getKeyValuesByFrequency ( ) ; return array_slice ( $ keywords , 0 , $ amount ) ; }
845	public function ensureWhitespaceAtIndex ( $ index , $ indexOffset , $ whitespace ) { $ removeLastCommentLine = static function ( self $ tokens , $ index , $ indexOffset , $ whitespace ) { $ token = $ tokens [ $ index ] ; if ( 1 === $ indexOffset && $ token -> isGivenKind ( T_OPEN_TAG ) ) { if ( 0 === strpos ( $ whitespace , "\r\n" ) ) { $ tokens [ $ index ] = new Token ( [ T_OPEN_TAG , rtrim ( $ token -> getContent ( ) ) . "\r\n" ] ) ; return \ strlen ( $ whitespace ) > 2 ? substr ( $ whitespace , 2 ) : '' ; } $ tokens [ $ index ] = new Token ( [ T_OPEN_TAG , rtrim ( $ token -> getContent ( ) ) . $ whitespace [ 0 ] ] ) ; return \ strlen ( $ whitespace ) > 1 ? substr ( $ whitespace , 1 ) : '' ; } return $ whitespace ; } ; if ( $ this [ $ index ] -> isWhitespace ( ) ) { $ whitespace = $ removeLastCommentLine ( $ this , $ index - 1 , $ indexOffset , $ whitespace ) ; if ( '' === $ whitespace ) { $ this -> clearAt ( $ index ) ; } else { $ this [ $ index ] = new Token ( [ T_WHITESPACE , $ whitespace ] ) ; } return false ; } $ whitespace = $ removeLastCommentLine ( $ this , $ index , $ indexOffset , $ whitespace ) ; if ( '' === $ whitespace ) { return false ; } $ this -> insertAt ( $ index + $ indexOffset , [ new Token ( [ T_WHITESPACE , $ whitespace ] ) , ] ) ; return true ; }
10969	public static function getQuery ( $ name = '' , $ defaultValue = null ) { $ queryStringParts = [ ] ; if ( isset ( $ _SERVER [ 'QUERY_STRING' ] ) ) { parse_str ( $ _SERVER [ 'QUERY_STRING' ] , $ queryStringParts ) ; } if ( $ name != '' ) { if ( isset ( $ queryStringParts [ $ name ] ) ) { return $ queryStringParts [ $ name ] ; } else { return $ defaultValue ; } } return $ queryStringParts ; }
6490	public function getDrupalSelector ( $ name ) { $ selectors = $ this -> getDrupalParameter ( 'selectors' ) ; if ( ! isset ( $ selectors [ $ name ] ) ) { throw new \ Exception ( sprintf ( 'No such selector configured: %s' , $ name ) ) ; } return $ selectors [ $ name ] ; }
10566	protected function formatJsonp ( $ response ) { $ response -> getHeaders ( ) -> set ( 'Content-Type' , 'application/javascript; charset=UTF-8' ) ; if ( is_array ( $ response -> data ) && isset ( $ response -> data [ 'data' ] , $ response -> data [ 'callback' ] ) ) { $ response -> content = sprintf ( '%s(%s);' , $ response -> data [ 'callback' ] , Json :: htmlEncode ( $ response -> data [ 'data' ] ) ) ; } elseif ( $ response -> data !== null ) { $ response -> content = '' ; Yii :: warning ( "The 'jsonp' response requires that the data be an array consisting of both 'data' and 'callback' elements." , __METHOD__ ) ; } }
1086	private function parseDocument ( ) { $ start = $ this -> lexer -> token ; $ this -> expect ( Token :: SOF ) ; $ definitions = [ ] ; do { $ definitions [ ] = $ this -> parseDefinition ( ) ; } while ( ! $ this -> skip ( Token :: EOF ) ) ; return new DocumentNode ( [ 'definitions' => new NodeList ( $ definitions ) , 'loc' => $ this -> loc ( $ start ) , ] ) ; }
3074	public function getRubrics ( RunnerServiceContext $ context , AssessmentItemRef $ itemRef = null ) { $ session = $ context -> getTestSession ( ) ; $ routeItem = null ; if ( ! is_null ( $ itemRef ) ) { try { $ routeItem = $ session -> getRoute ( ) -> getRouteItemsByAssessmentItemRef ( $ itemRef ) ; if ( $ routeItem ) { $ routeItem = $ routeItem [ 0 ] ; } } catch ( OutOfBoundsException $ obe ) { \ common_Logger :: d ( "Could not retrieve the route for item '${itemRef}'." ) ; } } else { $ routeItem = $ session -> getRoute ( ) -> current ( ) ; } return implode ( '' , $ this -> getRubricBlock ( $ routeItem , $ session , $ context -> getCompilationDirectory ( ) ) ) ; }
11433	public function query ( $ keyword , $ categories , array $ other = [ ] ) { $ params = [ 'query' => $ keyword , 'category' => implode ( ',' , ( array ) $ categories ) , 'appid' => $ this -> getAccessToken ( ) -> getAppId ( ) , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_SEARCH , array_merge ( $ params , $ other ) ] ) ; }
795	public function load ( $ data , $ formName = null ) { $ scope = $ formName === null ? $ this -> formName ( ) : $ formName ; if ( $ scope === '' && ! empty ( $ data ) ) { $ this -> setAttributes ( $ data ) ; return true ; } elseif ( isset ( $ data [ $ scope ] ) ) { $ this -> setAttributes ( $ data [ $ scope ] ) ; return true ; } return false ; }
9784	public function parseHTML ( ) { $ token = $ this -> pop ( 'HTML' ) ; $ value = $ this -> stripQuotes ( $ token [ 1 ] ) ; $ this -> currLine += substr_count ( $ value , "\n" ) ; return '$output .= \'' . $ value . "';\n" ; }
546	protected function getCreateTableSql ( $ table ) { $ row = $ this -> db -> createCommand ( 'SHOW CREATE TABLE ' . $ this -> quoteTableName ( $ table -> fullName ) ) -> queryOne ( ) ; if ( isset ( $ row [ 'Create Table' ] ) ) { $ sql = $ row [ 'Create Table' ] ; } else { $ row = array_values ( $ row ) ; $ sql = $ row [ 1 ] ; } return $ sql ; }
5379	protected function wrap ( $ text ) { $ text = str_replace ( "\r\r\n" , "\r\n" , str_replace ( "\n" , "\r\n" , $ text ) ) ; $ text = str_replace ( "\r\n\n" , "\r\n" , str_replace ( "\r" , "\r\n" , $ text ) ) ; if ( strncmp ( $ text , "\r\n" , strlen ( "\r\n" ) ) == 0 ) { $ text = substr ( $ text , strlen ( "\r\n" ) ) ; } if ( $ this -> wrapIsEnabled ( ) ) { return wordwrap ( $ text , ( integer ) $ this -> getAttribute ( 'cols' ) , "\r\n" ) ; } return $ text ; }
3723	public function addMetaModelNames ( $ metaModelNames ) { $ this -> metaModelNames = array_unique ( array_merge ( $ this -> metaModelNames , $ metaModelNames ) ) ; return $ this ; }
5134	private static function createUri ( string $ scheme , string $ host , ? int $ port , string $ user , string $ password , string $ path , string $ query , string $ fragment ) : \ One \ Uri { return new Uri ( $ scheme , $ host , $ port , $ path , $ query , $ fragment , $ user , $ password ) ; }
9085	public function getAlias ( string $ abstract ) : string { if ( ! isset ( $ this -> aliases [ $ abstract ] ) ) { return $ abstract ; } if ( $ this -> aliases [ $ abstract ] === $ abstract ) { throw new ContainerException ( "[{$abstract}] is aliased to itself." ) ; } return $ this -> getAlias ( $ this -> aliases [ $ abstract ] ) ; }
3659	public static function getSubscribedServices ( ) { return [ Connection :: class => Connection :: class , Input :: class => Input :: class , InsertTags :: class => InsertTags :: class , Session :: class => Session :: class , IMetaModelsServiceContainer :: class => IMetaModelsServiceContainer :: class ] ; }
10828	public static function sanitizeName ( string $ name ) : string { $ basename = basename ( $ name ) ; $ dir = ( $ basename === $ name ) ? null : dirname ( $ name ) ; $ basename = preg_replace ( "/[^a-zA-Z0-9-_.]/" , "_" , $ basename ) ; return ( $ dir === null ) ? $ basename : "$dir/$basename" ; }
9489	public function getFileData ( $ sFieldName ) { if ( empty ( $ sFieldName ) ) { return null ; } $ obFile = $ this -> $ sFieldName ; if ( empty ( $ obFile ) || ! $ obFile instanceof File ) { return null ; } return $ this -> getFileDataValue ( $ obFile ) ; }
7846	public function cancel ( array $ identifiers = [ ] ) : ? array { $ this -> checkConfig ( ) ; if ( empty ( $ identifiers ) ) { return null ; } $ messages = [ ] ; foreach ( $ identifiers as $ id ) { $ messages [ ] = [ 'id' => ( int ) $ id ] ; } $ body = Body :: json ( $ messages ) ; $ response = Request :: post ( $ this -> baseUrl . 'message/cancel' , [ ] , $ body ) ; if ( $ response -> code == 200 ) { return [ 'code' => $ response -> code , 'message' => 'OK' , 'data' => $ response -> body , ] ; } else { if ( ! empty ( $ response -> body -> message ) ) { Log :: error ( $ response -> body -> message ) ; } return [ 'code' => $ response -> code , 'message' => $ response -> body -> message ?? '' , 'data' => $ response -> body , ] ; } }
9105	protected function parse_time ( ) { if ( ! empty ( $ this -> args [ 'time' ] ) ) { $ date_query = new \ WP_Date_Query ( $ this -> args [ 'time' ] , 'q.time' ) ; return new Where_Date ( $ date_query ) ; } else { return null ; } }
1666	protected function enableTwoFactor ( BackendUser $ user , $ return ) { if ( $ user -> useTwoFactor ) { return ; } $ container = System :: getContainer ( ) ; $ verifyHelp = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'twoFactorVerificationHelp' ] ; $ authenticator = $ container -> get ( 'contao.security.two_factor.authenticator' ) ; if ( Input :: post ( 'FORM_SUBMIT' ) == 'tl_two_factor' ) { if ( $ authenticator -> validateCode ( $ user , Input :: post ( 'verify' ) ) ) { $ user -> useTwoFactor = '1' ; $ user -> save ( ) ; throw new RedirectResponseException ( $ return ) ; } $ this -> Template -> error = true ; $ verifyHelp = $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'invalidTwoFactor' ] ; } if ( ! $ user -> secret ) { $ user -> secret = random_bytes ( 128 ) ; $ user -> save ( ) ; } $ request = $ container -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; $ this -> Template -> enable = true ; $ this -> Template -> secret = Base32 :: encodeUpperUnpadded ( $ user -> secret ) ; $ this -> Template -> textCode = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'twoFactorTextCode' ] ; $ this -> Template -> qrCode = base64_encode ( $ authenticator -> getQrCode ( $ user , $ request ) ) ; $ this -> Template -> scan = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'twoFactorScan' ] ; $ this -> Template -> verify = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'twoFactorVerification' ] ; $ this -> Template -> verifyHelp = $ verifyHelp ; }
2067	public function getPageLayouts ( ) { $ objLayout = $ this -> Database -> execute ( "SELECT l.id, l.name, t.name AS theme FROM tl_layout l LEFT JOIN tl_theme t ON l.pid=t.id ORDER BY t.name, l.name" ) ; if ( $ objLayout -> numRows < 1 ) { return array ( ) ; } $ return = array ( ) ; while ( $ objLayout -> next ( ) ) { $ return [ $ objLayout -> theme ] [ $ objLayout -> id ] = $ objLayout -> name ; } return $ return ; }
4177	public function getMigration ( ) { return $ this -> migration ? : $ this -> migration = new Migration ( clone $ this -> getFiles ( ) , $ this -> console ) ; }
10450	public function delete ( $ key ) { try { $ this -> get ( $ key ) ; } catch ( KeyNotFoundException $ e ) { return false ; } return $ this -> getClient ( ) -> delete ( $ key ) ; }
141	public function markAliasUninstalled ( RepositoryInterface $ repo , MarkAliasUninstalledOperation $ operation ) { $ package = $ operation -> getPackage ( ) ; $ repo -> removePackage ( $ package ) ; }
1896	private function purgeOldFiles ( string $ webDir ) : void { if ( file_exists ( $ webDir . '/app_dev.php' ) ) { $ this -> fs -> remove ( $ webDir . '/app_dev.php' ) ; $ this -> io -> writeln ( 'Deleted the <comment>web/app_dev.php</comment> file.' ) ; } if ( file_exists ( $ webDir . '/install.php' ) ) { $ this -> fs -> remove ( $ webDir . '/install.php' ) ; $ this -> io -> writeln ( 'Deleted the <comment>web/install.php</comment> file.' ) ; } }
5334	protected function sign ( $ privateKey , $ parameters ) { if ( preg_match ( '/-----BEGIN (RSA )?PRIVATE KEY-----(.*)-----END (RSA )?PRIVATE KEY-----/si' , $ privateKey , $ matches ) ) { $ key = $ matches [ 2 ] ; $ key = preg_replace ( '/\s*/s' , '' , $ key ) ; $ key = chunk_split ( $ key , 64 , "\n" ) ; $ key = "-----BEGIN PRIVATE KEY-----\n" . $ key . '-----END PRIVATE KEY-----' ; $ digest = $ this -> sha512Asn1 ( $ this -> encodeParameters ( $ parameters ) ) ; if ( @ openssl_private_encrypt ( $ digest , $ signature , $ key ) ) { return base64_encode ( $ signature ) ; } throw new \ InvalidArgumentException ( 'Unable to sign the request, this has to do with the provided (invalid) private key.' ) ; } throw new \ InvalidArgumentException ( 'Invalid private key.' ) ; }
9646	public function build ( ) : Route { return new $ this -> routeClass ( $ this -> methods , $ this -> path , $ this -> target , $ this -> matchers , $ this -> name ) ; }
12408	protected function load ( ) { $ this -> config = array ( ) ; if ( file_exists ( $ this -> filePath ) ) { $ this -> config = Yaml :: parse ( $ this -> filePath ) ; } }
8844	private function log ( string $ message , array $ context = [ ] ) : void { $ this -> logger -> log ( $ this -> logLevel , $ message , $ context ) ; }
340	public function field ( $ model , $ attribute , $ options = [ ] ) { $ config = $ this -> fieldConfig ; if ( $ config instanceof \ Closure ) { $ config = call_user_func ( $ config , $ model , $ attribute ) ; } if ( ! isset ( $ config [ 'class' ] ) ) { $ config [ 'class' ] = $ this -> fieldClass ; } return Yii :: createObject ( ArrayHelper :: merge ( $ config , $ options , [ 'model' => $ model , 'attribute' => $ attribute , 'form' => $ this , ] ) ) ; }
4847	public static function unregister ( ) { if ( isset ( self :: $ autoloadFn ) ) { spl_autoload_unregister ( self :: $ autoloadFn ) ; self :: $ autoloadFn = null ; } self :: $ aliases = [ ] ; }
11238	public function getRedirect ( $ url = null ) { if ( $ url ) { if ( is_numeric ( $ url ) ) { $ steps = $ url ; $ offset = count ( $ _SESSION [ 'redirect' ] [ 'history' ] ) + $ steps ; if ( isset ( $ _SESSION [ 'redirect' ] [ 'history' ] [ $ offset ] ) ) { $ redirect = $ _SESSION [ 'redirect' ] [ 'history' ] [ $ offset ] ; if ( ! empty ( $ redirect ) ) { return $ redirect ; } else { return BASE_URL ; } } else { return $ this -> config [ 'site_url' ] ; } } else { if ( substr ( $ url , 0 , 1 ) == '/' ) { return $ this -> config [ 'site_url' ] . substr ( $ url , 1 ) ; } else { return $ url ; } } } else { return $ this -> config [ 'site_url' ] ; } }
3200	protected function binaryPopCount ( $ value ) { $ value -= ( ( $ value >> 1 ) & 0x55555555 ) ; $ value = ( ( ( $ value >> 2 ) & 0x33333333 ) + ( $ value & 0x33333333 ) ) ; $ value = ( ( ( $ value >> 4 ) + $ value ) & 0x0f0f0f0f ) ; $ value += ( $ value >> 8 ) ; $ value += ( $ value >> 16 ) ; return $ value & 0x0000003f ; }
793	public function getAttributes ( $ names = null , $ except = [ ] ) { $ values = [ ] ; if ( $ names === null ) { $ names = $ this -> attributes ( ) ; } foreach ( $ names as $ name ) { $ values [ $ name ] = $ this -> $ name ; } foreach ( $ except as $ name ) { unset ( $ values [ $ name ] ) ; } return $ values ; }
9799	public static function compareCells ( self $ a , self $ b ) { if ( $ a -> getRow ( ) < $ b -> getRow ( ) ) { return - 1 ; } elseif ( $ a -> getRow ( ) > $ b -> getRow ( ) ) { return 1 ; } elseif ( Coordinate :: columnIndexFromString ( $ a -> getColumn ( ) ) < Coordinate :: columnIndexFromString ( $ b -> getColumn ( ) ) ) { return - 1 ; } return 1 ; }
9413	public static function instance ( array $ server ) { $ secure = isset ( $ server [ 'HTTPS' ] ) ? $ server [ 'HTTPS' ] : 'off' ; $ http = $ secure === 'off' ? 'http' : 'https' ; $ url = $ http . '://' . $ server [ 'SERVER_NAME' ] ; $ url .= ( string ) $ server [ 'SERVER_PORT' ] ; return new Uri ( $ url . $ server [ 'REQUEST_URI' ] ) ; }
2211	public function fetchEach ( $ strKey ) { $ this -> reset ( ) ; $ arrReturn = array ( ) ; while ( ( $ arrRow = $ this -> fetchAssoc ( ) ) !== false ) { if ( $ strKey != 'id' && isset ( $ arrRow [ 'id' ] ) ) { $ arrReturn [ $ arrRow [ 'id' ] ] = $ arrRow [ $ strKey ] ; } else { $ arrReturn [ ] = $ arrRow [ $ strKey ] ; } } return $ arrReturn ; }
5499	public function respond ( $ step , $ method , $ args ) { $ method = strtolower ( $ method ) ; if ( isset ( $ this -> at [ $ method ] [ $ step ] ) ) { if ( $ this -> at [ $ method ] [ $ step ] -> isMatch ( $ args ) ) { $ action = $ this -> at [ $ method ] [ $ step ] -> findFirstAction ( $ args ) ; if ( isset ( $ action ) ) { return $ action -> act ( ) ; } } } if ( isset ( $ this -> always [ $ method ] ) ) { $ action = $ this -> always [ $ method ] -> findFirstAction ( $ args ) ; if ( isset ( $ action ) ) { return $ action -> act ( ) ; } } return ; }
8236	protected function checkServerConfiguration ( ) { $ pico = $ this -> picoAuth -> getPico ( ) ; $ configDir = $ pico -> getBaseUrl ( ) . basename ( $ pico -> getConfigDir ( ) ) ; $ configFile = $ configDir . "/config.yml" ; $ contentDir = $ pico -> getBaseUrl ( ) . basename ( $ pico -> getConfig ( 'content_dir' ) ) ; $ indexFile = $ contentDir . "/index" . $ pico -> getConfig ( 'content_ext' ) ; $ urls = array ( 'dir_listing' => $ configDir , 'config_file' => $ configFile , 'content_file' => $ indexFile ) ; $ this -> httpsTest ( ) ; $ this -> webRootDirsTest ( ) ; $ this -> picoAuth -> addOutput ( "installer_urltest" , $ urls ) ; }
6090	public function addMediaToMoodboard ( $ moodboardId , array $ mediaIds ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'mediaIds' => $ mediaIds ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/moodboards/' . $ moodboardId . '/media' , $ parameters ) ; return $ result ; }
379	public function renderCallStackItem ( $ file , $ line , $ class , $ method , $ args , $ index ) { $ lines = [ ] ; $ begin = $ end = 0 ; if ( $ file !== null && $ line !== null ) { $ line -- ; $ lines = @ file ( $ file ) ; if ( $ line < 0 || $ lines === false || ( $ lineCount = count ( $ lines ) ) < $ line ) { return '' ; } $ half = ( int ) ( ( $ index === 1 ? $ this -> maxSourceLines : $ this -> maxTraceSourceLines ) / 2 ) ; $ begin = $ line - $ half > 0 ? $ line - $ half : 0 ; $ end = $ line + $ half < $ lineCount ? $ line + $ half : $ lineCount - 1 ; } return $ this -> renderFile ( $ this -> callStackItemView , [ 'file' => $ file , 'line' => $ line , 'class' => $ class , 'method' => $ method , 'index' => $ index , 'lines' => $ lines , 'begin' => $ begin , 'end' => $ end , 'args' => $ args , ] ) ; }
4902	private static function getDockerEnv ( $ configuration ) { $ cacheDir = $ configuration [ 'module_listener_options' ] [ 'cache_dir' ] . '/docker' ; $ configDir = static :: getConfigDir ( ) ; $ hydratorDir = $ cacheDir . '/Doctrine/Hydrator' ; $ proxyDir = $ cacheDir . '/Doctrine/Proxy' ; if ( ! is_dir ( $ hydratorDir ) ) { mkdir ( $ hydratorDir , 0777 , true ) ; } if ( ! is_dir ( $ proxyDir ) ) { mkdir ( $ proxyDir , 0777 , true ) ; } return [ 'module_listener_options' => [ 'cache_dir' => $ cacheDir , 'config_glob_paths' => [ $ configDir . '/autoload/*.docker.php' , ] ] , 'doctrine' => [ 'configuration' => [ 'odm_default' => [ 'hydrator_dir' => $ hydratorDir , 'proxy_dir' => $ proxyDir , ] ] ] ] ; }
5437	public function addPattern ( $ pattern , $ label = true ) { $ count = count ( $ this -> patterns ) ; $ this -> patterns [ $ count ] = $ pattern ; $ this -> labels [ $ count ] = $ label ; $ this -> regex = null ; }
3281	public function setDir ( string $ dir ) { if ( ! is_dir ( $ dir ) ) { throw new Exception ( 'Directory does not exist: ' . $ dir ) ; } $ this -> config [ 'dir' ] = rtrim ( $ dir , '/\\' ) . DIRECTORY_SEPARATOR ; }
6635	public function bootstrap ( $ app ) { Yii :: setAlias ( '@wavecms' , '@vendor/mrstroz/yii2-wavecms' ) ; if ( $ app -> id === 'app-backend' || $ app -> id === 'app-frontend' ) { Yii :: setAlias ( '@frontWeb' , str_replace ( '/admin' , '' , Yii :: getAlias ( '@web' ) ) ) ; Yii :: setAlias ( '@frontWebroot' , str_replace ( '/public/admin' , '/public' , Yii :: getAlias ( '@webroot' ) ) ) ; } if ( $ app -> id === 'app-backend' ) { if ( ! Yii :: $ app -> user -> isGuest ) { Yii :: $ app -> language = Yii :: $ app -> user -> identity -> lang ; } } $ this -> initTranslations ( ) ; if ( $ app -> hasModule ( 'wavecms' ) && ( $ module = $ app -> getModule ( 'wavecms' ) ) instanceof Module ) { if ( $ app instanceof ConsoleApplication ) { $ module -> controllerNamespace = 'mrstroz\wavecms\commands' ; } else { $ module -> controllerNamespace = 'mrstroz\wavecms\controllers' ; if ( $ app -> id === 'app-backend' ) { Yii :: $ app -> errorHandler -> errorAction = $ module -> errorAction ; $ app -> set ( 'wavecms' , [ 'class' => 'mrstroz\wavecms\WavecmsComponent' , 'languages' => $ module -> languages ] ) ; $ app -> set ( 'cacheFrontend' , [ 'class' => 'yii\caching\FileCache' , 'cachePath' => Yii :: getAlias ( '@frontend' ) . '/runtime/cache' ] ) ; $ app -> set ( 'settings' , [ 'class' => 'yii2mod\settings\components\Settings' , ] ) ; Yii :: $ app -> assetManager -> appendTimestamp = true ; Yii :: $ app -> i18n -> translations [ 'yii2mod.settings' ] = [ 'class' => 'yii\i18n\PhpMessageSource' , 'basePath' => '@yii2mod/settings/messages' ] ; $ this -> initContainer ( $ module ) ; $ this -> initLanguages ( ) ; $ this -> initParams ( ) ; $ this -> initRoutes ( $ app , $ module ) ; $ this -> initNavigation ( ) ; } } } }
8848	public function tag ( ) { $ tag = $ this -> getCurrentTag ( ) ; if ( $ tag ) { $ this -> blogPosts = $ tag -> BlogPosts ( ) ; return $ this -> render ( ) ; } return $ this -> httpError ( 404 , "Not Found" ) ; }
9987	private function mapBorderStyle ( $ borderStyle ) { switch ( $ borderStyle ) { case Border :: BORDER_NONE : return 'none' ; case Border :: BORDER_DASHDOT : return '1px dashed' ; case Border :: BORDER_DASHDOTDOT : return '1px dotted' ; case Border :: BORDER_DASHED : return '1px dashed' ; case Border :: BORDER_DOTTED : return '1px dotted' ; case Border :: BORDER_DOUBLE : return '3px double' ; case Border :: BORDER_HAIR : return '1px solid' ; case Border :: BORDER_MEDIUM : return '2px solid' ; case Border :: BORDER_MEDIUMDASHDOT : return '2px dashed' ; case Border :: BORDER_MEDIUMDASHDOTDOT : return '2px dotted' ; case Border :: BORDER_MEDIUMDASHED : return '2px dashed' ; case Border :: BORDER_SLANTDASHDOT : return '2px dashed' ; case Border :: BORDER_THICK : return '3px solid' ; case Border :: BORDER_THIN : return '1px solid' ; default : return '1px solid' ; } }
2475	public function deleteContent ( $ contentId , $ versionId = null ) { $ idPrefix = $ this -> mapper -> generateContentDocumentId ( $ contentId ) ; $ this -> gateway -> deleteByQuery ( "_root_:{$idPrefix}*" ) ; }
2561	public function loadSpecificChanges ( $ changeTicketing , $ changeQueueing , $ changeOptQueueEl ) { if ( $ changeTicketing ) { $ this -> specificChanges [ ] = new SpecificChanges ( SpecificChanges :: ACTION_TICKETING_OFFICE ) ; } if ( $ changeQueueing ) { $ this -> specificChanges [ ] = new SpecificChanges ( SpecificChanges :: ACTION_QUEUEING_OFFICE ) ; } if ( $ changeOptQueueEl ) { $ this -> specificChanges [ ] = new SpecificChanges ( SpecificChanges :: ACTION_OPT_QUEUE_ELEMENT ) ; } }
2830	public function disableSqlProfilerAction ( ) { try { $ this -> getService ( ) -> setSqlProfilerStatus ( false ) ; $ this -> getService ( ) -> flushCache ( ) ; Mage :: getSingleton ( 'core/session' ) -> addSuccess ( 'SQL profiler was disabled.' ) ; } catch ( Exception $ e ) { Mage :: getSingleton ( 'core/session' ) -> addError ( 'Unable to disable SQL profiler: ' . $ e -> getMessage ( ) ) ; } $ this -> _redirectReferer ( ) ; }
6558	public function slug ( Entity $ entity ) { $ config = $ this -> config ( ) ; $ value = $ entity -> get ( $ config [ 'field' ] ) ; $ entity -> set ( $ config [ 'slug' ] , strtolower ( Inflector :: slug ( $ value , $ config [ 'replacement' ] ) ) ) ; }
1833	public function onUnregister ( Registry $ registry ) { foreach ( static :: getUniqueFields ( ) as $ strColumn ) { $ varAliasValue = $ this -> { $ strColumn } ; if ( $ registry -> isRegisteredAlias ( $ this , $ strColumn , $ varAliasValue ) ) { $ registry -> unregisterAlias ( $ this , $ strColumn , $ varAliasValue ) ; } } }
727	public static function on ( $ class , $ name , $ handler , $ data = null , $ append = true ) { $ class = ltrim ( $ class , '\\' ) ; if ( strpos ( $ class , '*' ) !== false || strpos ( $ name , '*' ) !== false ) { if ( $ append || empty ( self :: $ _eventWildcards [ $ name ] [ $ class ] ) ) { self :: $ _eventWildcards [ $ name ] [ $ class ] [ ] = [ $ handler , $ data ] ; } else { array_unshift ( self :: $ _eventWildcards [ $ name ] [ $ class ] , [ $ handler , $ data ] ) ; } return ; } if ( $ append || empty ( self :: $ _events [ $ name ] [ $ class ] ) ) { self :: $ _events [ $ name ] [ $ class ] [ ] = [ $ handler , $ data ] ; } else { array_unshift ( self :: $ _events [ $ name ] [ $ class ] , [ $ handler , $ data ] ) ; } }
6462	public function add ( $ name , $ values , bool $ append = false ) : void { $ normalizedName = self :: normalizeHeaderName ( $ name ) ; if ( ! $ append || ! $ this -> containsKey ( $ normalizedName ) ) { parent :: add ( $ normalizedName , ( array ) $ values ) ; } else { $ currentValues = [ ] ; $ this -> tryGet ( $ normalizedName , $ currentValues ) ; parent :: add ( $ normalizedName , array_merge ( $ currentValues , ( array ) $ values ) ) ; } }
723	public function checkIntegrity ( $ check = true , $ schema = '' , $ table = '' ) { $ enable = $ check ? 'CHECK' : 'NOCHECK' ; $ schema = $ schema ? : $ this -> db -> getSchema ( ) -> defaultSchema ; $ tableNames = $ this -> db -> getTableSchema ( $ table ) ? [ $ table ] : $ this -> db -> getSchema ( ) -> getTableNames ( $ schema ) ; $ viewNames = $ this -> db -> getSchema ( ) -> getViewNames ( $ schema ) ; $ tableNames = array_diff ( $ tableNames , $ viewNames ) ; $ command = '' ; foreach ( $ tableNames as $ tableName ) { $ tableName = $ this -> db -> quoteTableName ( "{$schema}.{$tableName}" ) ; $ command .= "ALTER TABLE $tableName $enable CONSTRAINT ALL; " ; } return $ command ; }
1838	public static function findBy ( $ strColumn , $ varValue , array $ arrOptions = array ( ) ) { $ blnModel = false ; $ arrColumn = ( array ) $ strColumn ; if ( \ count ( $ arrColumn ) == 1 && ( $ arrColumn [ 0 ] === static :: getPk ( ) || \ in_array ( $ arrColumn [ 0 ] , static :: getUniqueFields ( ) ) ) ) { $ blnModel = true ; } $ arrOptions = array_merge ( array ( 'column' => $ strColumn , 'value' => $ varValue , 'return' => $ blnModel ? 'Model' : 'Collection' ) , $ arrOptions ) ; return static :: find ( $ arrOptions ) ; }
167	protected static function loadMimeTypes ( $ magicFile ) { if ( $ magicFile === null ) { $ magicFile = static :: $ mimeMagicFile ; } $ magicFile = Yii :: getAlias ( $ magicFile ) ; if ( ! isset ( self :: $ _mimeTypes [ $ magicFile ] ) ) { self :: $ _mimeTypes [ $ magicFile ] = require $ magicFile ; } return self :: $ _mimeTypes [ $ magicFile ] ; }
355	public function prepare ( $ forcePrepare = false ) { if ( $ forcePrepare || $ this -> _models === null ) { $ this -> _models = $ this -> prepareModels ( ) ; } if ( $ forcePrepare || $ this -> _keys === null ) { $ this -> _keys = $ this -> prepareKeys ( $ this -> _models ) ; } }
6108	public function clientPermRemove ( $ cldbid , $ permid ) { return $ this -> getParent ( ) -> channelClientPermRemove ( $ this -> getId ( ) , $ cldbid , $ permid ) ; }
4404	public function getPath ( $ locationId ) { $ pathArray = array ( ) ; $ startingLocation = $ this -> locationService -> loadLocation ( $ locationId ) ; $ path = $ startingLocation -> path ; array_shift ( $ path ) ; $ rootLocationFound = false ; foreach ( $ path as $ index => $ pathItem ) { if ( ( int ) $ pathItem === $ this -> rootLocationId ) { $ rootLocationFound = true ; } if ( ! $ rootLocationFound ) { continue ; } try { $ location = $ this -> locationService -> loadLocation ( $ pathItem ) ; } catch ( UnauthorizedException $ e ) { return array ( ) ; } $ pathArray [ ] = array ( 'text' => $ this -> translationHelper -> getTranslatedContentNameByContentInfo ( $ location -> contentInfo ) , 'url' => $ location -> id !== $ startingLocation -> id ? $ this -> router -> generate ( $ location ) : false , 'locationId' => $ location -> id , 'contentId' => $ location -> contentId , ) ; } return $ pathArray ; }
2825	public function __ ( ) { $ args = func_get_args ( ) ; return $ this -> helper -> useStoreLocale ( ) ? $ this -> parentTranslate ( $ args ) : $ this -> dummyTranslate ( $ args ) ; }
12821	private function resolveDependencies ( callable $ callback , array $ vars ) : array { $ method = new \ ReflectionMethod ( $ callback [ 0 ] , $ callback [ 1 ] ) ; $ dependencies = [ ] ; foreach ( $ method -> getParameters ( ) as $ parameter ) { if ( $ parameter -> getClass ( ) === null && ! count ( $ vars ) ) { break ; } if ( $ parameter -> getClass ( ) === null && count ( $ vars ) ) { $ dependencies [ ] = array_shift ( $ vars ) ; continue ; } $ dependencies [ ] = $ this -> injector -> make ( $ parameter -> getClass ( ) -> name ) ; } return $ dependencies ; }
6174	protected function delete ( $ path , $ file ) { return $ this -> driver -> delete ( $ this -> root . $ path , $ file ) ; }
73	public function authorizeOAuthInteractively ( $ originUrl , $ message = null ) { if ( $ message ) { $ this -> io -> writeError ( $ message ) ; } $ url = 'https://confluence.atlassian.com/bitbucket/oauth-on-bitbucket-cloud-238027431.html' ; $ this -> io -> writeError ( sprintf ( 'Follow the instructions on %s' , $ url ) ) ; $ this -> io -> writeError ( sprintf ( 'to create a consumer. It will be stored in "%s" for future use by Composer.' , $ this -> config -> getAuthConfigSource ( ) -> getName ( ) ) ) ; $ this -> io -> writeError ( 'Ensure you enter a "Callback URL" (http://example.com is fine) or it will not be possible to create an Access Token (this callback url will not be used by composer)' ) ; $ consumerKey = trim ( $ this -> io -> askAndHideAnswer ( 'Consumer Key (hidden): ' ) ) ; if ( ! $ consumerKey ) { $ this -> io -> writeError ( '<warning>No consumer key given, aborting.</warning>' ) ; $ this -> io -> writeError ( 'You can also add it manually later by using "composer config --global --auth bitbucket-oauth.bitbucket.org <consumer-key> <consumer-secret>"' ) ; return false ; } $ consumerSecret = trim ( $ this -> io -> askAndHideAnswer ( 'Consumer Secret (hidden): ' ) ) ; if ( ! $ consumerSecret ) { $ this -> io -> writeError ( '<warning>No consumer secret given, aborting.</warning>' ) ; $ this -> io -> writeError ( 'You can also add it manually later by using "composer config --global --auth bitbucket-oauth.bitbucket.org <consumer-key> <consumer-secret>"' ) ; return false ; } $ this -> io -> setAuthentication ( $ originUrl , $ consumerKey , $ consumerSecret ) ; if ( ! $ this -> requestAccessToken ( $ originUrl ) ) { return false ; } $ this -> storeInAuthConfig ( $ originUrl , $ consumerKey , $ consumerSecret ) ; $ this -> config -> getAuthConfigSource ( ) -> removeConfigSetting ( 'http-basic.' . $ originUrl ) ; $ this -> io -> writeError ( '<info>Consumer stored successfully.</info>' ) ; return true ; }
2238	private function handlePrependLocale ( array $ extensionConfigs , ContainerBuilder $ container ) : array { if ( ! $ container -> hasParameter ( 'prepend_locale' ) ) { return $ extensionConfigs ; } foreach ( $ extensionConfigs as $ extensionConfig ) { if ( isset ( $ extensionConfig [ 'prepend_locale' ] ) ) { return $ extensionConfigs ; } } @ trigger_error ( 'Defining the "prepend_locale" parameter in the parameters.yml file has been deprecated and will no longer work in Contao 5.0. Define the "contao.prepend_locale" parameter in the config.yml file instead.' , E_USER_DEPRECATED ) ; $ extensionConfigs [ ] = [ 'prepend_locale' => '%prepend_locale%' , ] ; return $ extensionConfigs ; }
1291	public function continueSync ( $ token ) : Result { if ( $ token instanceof Result ) { if ( ! $ this -> isDeliveryApi && $ token -> isDone ( ) ) { throw new \ RuntimeException ( 'Can not continue syncing when using the Content Preview API.' ) ; } $ token = $ token -> getToken ( ) ; } $ response = $ this -> client -> syncRequest ( [ 'sync_token' => $ token ] ) ; return $ this -> buildResult ( $ response ) ; }
3806	private function isAttributeNameOrTypeChanged ( ModelInterface $ new , ModelInterface $ old ) { return ( $ old -> getProperty ( 'type' ) !== $ new -> getProperty ( 'type' ) ) || ( $ old -> getProperty ( 'colname' ) !== $ new -> getProperty ( 'colname' ) ) ; }
519	private function findMigrationPath ( $ namespace ) { if ( empty ( $ namespace ) ) { return is_array ( $ this -> migrationPath ) ? reset ( $ this -> migrationPath ) : $ this -> migrationPath ; } if ( ! in_array ( $ namespace , $ this -> migrationNamespaces , true ) ) { throw new Exception ( "Namespace '{$namespace}' not found in `migrationNamespaces`" ) ; } return $ this -> getNamespacePath ( $ namespace ) ; }
3223	function createTemporaryDirectLink ( $ path ) { Path :: checkArgNonRoot ( "path" , $ path ) ; $ response = $ this -> doPost ( $ this -> apiHost , $ this -> appendFilePath ( "1/media" , $ path ) ) ; if ( $ response -> statusCode === 404 ) return null ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; $ j = RequestUtil :: parseResponseJson ( $ response -> body ) ; $ url = self :: getField ( $ j , "url" ) ; $ expires = self :: parseDateTime ( self :: getField ( $ j , "expires" ) ) ; return array ( $ url , $ expires ) ; }
9726	public function logWrite ( IWriter $ writer , $ path , $ callStartTime ) { $ callEndTime = microtime ( true ) ; $ callTime = $ callEndTime - $ callStartTime ; $ reflection = new ReflectionClass ( $ writer ) ; $ format = $ reflection -> getShortName ( ) ; $ message = "Write {$format} format to <code>{$path}</code> in " . sprintf ( '%.4f' , $ callTime ) . ' seconds' ; $ this -> log ( $ message ) ; }
10489	public static function unbufferConnection ( Connection $ connection ) { $ wrappedConnection = $ connection -> getWrappedConnection ( ) ; if ( ! $ wrappedConnection instanceof PDOConnection ) { throw new InvalidArgumentException ( 'unbufferConection can only be used with pdo_mysql Doctrine driver.' ) ; } if ( $ wrappedConnection -> getAttribute ( PDO :: ATTR_DRIVER_NAME ) != 'mysql' ) { throw new InvalidArgumentException ( 'unbufferConection can only be used with PDO mysql driver, got "' . $ wrappedConnection -> getAttribute ( PDO :: ATTR_DRIVER_NAME ) . '" instead.' ) ; } if ( $ connection -> isConnected ( ) ) { $ connection -> close ( ) ; } $ connection -> getWrappedConnection ( ) -> setAttribute ( PDO :: MYSQL_ATTR_USE_BUFFERED_QUERY , false ) ; $ connection -> connect ( ) ; }
6735	public function getMiddleware ( $ name ) : Middleware { if ( ! array_key_exists ( $ name , $ this -> namedMiddleware ) ) { throw new \ UnexpectedValueException ( "No middleware registered under name '{$name}'" ) ; } return $ this -> namedMiddleware [ $ name ] ; }
9539	private function getClosure ( $ parameter ) { $ closure = null ; foreach ( array_keys ( $ this -> parameterCluster -> prefixes ) as $ prefix ) { if ( substr ( $ parameter , 0 , strlen ( $ prefix ) ) == $ prefix ) { @ $ closure = $ this -> parameterCluster -> prefixes [ $ prefix ] [ substr ( $ parameter , strlen ( $ prefix ) , strlen ( $ parameter ) - strlen ( $ prefix ) ) ] -> parameterClosure ; } } return $ closure ; }
10112	private function writeRangeProtection ( ) { foreach ( $ this -> phpSheet -> getProtectedCells ( ) as $ range => $ password ) { $ cellRanges = explode ( ' ' , $ range ) ; $ cref = count ( $ cellRanges ) ; $ recordData = pack ( 'vvVVvCVvVv' , 0x0868 , 0x00 , 0x0000 , 0x0000 , 0x02 , 0x0 , 0x0000 , $ cref , 0x0000 , 0x00 ) ; foreach ( $ cellRanges as $ cellRange ) { $ recordData .= $ this -> writeBIFF8CellRangeAddressFixed ( $ cellRange ) ; } $ recordData .= pack ( 'VV' , 0x0000 , hexdec ( $ password ) ) ; $ recordData .= StringHelper :: UTF8toBIFF8UnicodeLong ( 'p' . md5 ( $ recordData ) ) ; $ length = strlen ( $ recordData ) ; $ record = 0x0868 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ this -> append ( $ header . $ recordData ) ; } }
7940	public function setBackupFTPaccessBlock ( $ domain , $ ipBlock , $ ftp , $ nfs , $ cifs ) { $ domain = ( string ) $ domain ; if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; if ( ! $ ipBlock ) throw new BadMethodCallException ( 'Parameter $ipBlock is missing.' ) ; if ( ! $ ftp ) throw new BadMethodCallException ( 'Parameter $ftp is missing.' ) ; if ( ! $ nfs ) throw new BadMethodCallException ( 'Parameter $nfs is missing.' ) ; if ( ! $ cifs ) throw new BadMethodCallException ( 'Parameter $cifs is missing.' ) ; $ payload = array ( 'ftp' => ( $ ftp == 'on' ) , 'nfs' => ( $ nfs == 'on' ) , 'cifs' => ( $ cifs == 'on' ) ) ; try { $ r = $ this -> put ( 'dedicated/server/' . $ domain . '/features/backupFTP/access/' . urlencode ( $ ipBlock ) , array ( 'Content-Type' => 'application/json;charset=UTF-8' ) , json_encode ( $ payload ) ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new ServerException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
10979	public function postPersist ( LifecycleEventArgs $ args ) : void { if ( ! $ this -> enableIndexing ) { return ; } $ this -> updateEntity ( $ args -> getObject ( ) , $ args -> getObjectManager ( ) ) ; }
12056	public function getLabels ( ) { $ labels = [ ] ; $ labels [ 'delete_object' ] = [ 'short' => 'Delete ' . $ this -> object -> objectType -> title -> getSingular ( true ) , 'long' => 'delete the ' . $ this -> object -> objectType -> title -> getSingular ( false ) . ' <em>' . $ this -> object -> descriptor . '</em>' , 'past' => $ this -> object -> objectType -> title -> getSingular ( false ) . ' <em>' . $ this -> object -> descriptor . '</em> has been deleted' , 'options' => [ 'class' => 'btn-danger' ] , 'response' => 'home' , ] ; $ labels [ 'archive_object' ] = [ 'short' => 'Archive ' . $ this -> object -> objectType -> title -> getSingular ( true ) , 'long' => 'archive the ' . $ this -> object -> objectType -> title -> getSingular ( false ) . ' <em>' . $ this -> object -> descriptor . '</em>' , 'past' => $ this -> object -> objectType -> title -> getSingular ( false ) . ' <em>' . $ this -> object -> descriptor . '</em> has been archived' , 'response' => 'refresh' , ] ; $ labels [ 'unarchive_object' ] = [ 'short' => 'Unarchive ' . $ this -> object -> objectType -> title -> getSingular ( true ) , 'long' => 'unarchive the ' . $ this -> object -> objectType -> title -> getSingular ( false ) . ' <em>' . $ this -> object -> descriptor . '</em>' , 'past' => $ this -> object -> objectType -> title -> getSingular ( false ) . ' <em>' . $ this -> object -> descriptor . '</em> has been unarchived' , 'response' => 'refresh' , ] ; if ( isset ( $ this -> relationshipWith ) ) { $ labels [ 'delete_relationship' ] = [ 'short' => 'Delete Relationship' , 'long' => 'delete the relationship between <em>' . $ this -> object -> descriptor . '</em> and <em>' . $ this -> relationshipWith -> descriptor . '</em>' , 'past' => 'the relationship between <em>' . $ this -> object -> descriptor . '</em> and <em>' . $ this -> relationshipWith -> descriptor . '</em> has been deleted' , 'options' => [ 'class' => 'btn-warning' ] , ] ; $ labels [ 'end_relationship' ] = [ 'short' => 'End Relationship' , 'long' => 'end the relationship between <em>' . $ this -> object -> descriptor . '</em> and <em>' . $ this -> relationshipWith -> descriptor . '</em>' , 'past' => 'the relationship between <em>' . $ this -> object -> descriptor . '</em> and <em>' . $ this -> relationshipWith -> descriptor . '</em> has been ended' , ] ; } return $ labels ; }
11410	public function update ( $ tagId , $ name ) { $ params = [ 'tag' => [ 'id' => $ tagId , 'name' => $ name , ] , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_UPDATE , $ params ] ) ; }
9588	protected function isAttributeSet ( SimpleXmlElement $ node , $ name ) { $ attributes = $ node -> attributes ( ) ; return isset ( $ attributes [ $ name ] ) ; }
5683	public function getUrls ( ) { $ all = array ( ) ; foreach ( $ this -> links as $ link ) { $ url = $ this -> getUrlFromLink ( $ link ) ; $ all [ ] = $ url -> asString ( ) ; } return $ all ; }
10216	public function addFromSource ( array $ pSource = null ) { if ( $ pSource == null ) { return ; } foreach ( $ pSource as $ item ) { $ this -> add ( $ item ) ; } }
3435	public function substituteGroup ( $ old , $ new ) { $ groups = $ this -> getGroups ( ) ; if ( ( $ key = array_search ( $ old , $ groups ) ) !== false ) { unset ( $ groups [ $ key ] ) ; } if ( ! in_array ( $ new , $ groups ) ) { $ groups [ ] = $ new ; } $ this -> fields [ 'GROUP_ID' ] = $ groups ; }
10698	public static function isPasswd ( $ passwd , $ size = Validate :: PASSWORD_LENGTH ) { return self :: getPasswordComplexity ( $ passwd , $ size ) >= self :: PASSWORD_COMPLEXITY_MEDIUM ; }
11008	public function addReportUri ( string $ reportUri ) : bool { if ( ! filter_var ( $ reportUri , FILTER_VALIDATE_URL ) ) { throw new MiddlewareException ( $ this , sprintf ( "'%s' is not a valid URI and can not be set as the CSP report URI" , $ reportUri ) ) ; } if ( ! in_array ( $ reportUri , $ this -> tags [ 'report-uri' ] ) ) { $ this -> tags [ 'report-uri' ] [ ] = $ reportUri ; return true ; } return false ; }
9153	public function getUrlString ( ) : string { $ query = "" ; if ( strlen ( $ this -> queryString ) > 0 ) { $ query = sprintf ( "?%s" , $ this -> queryString ) ; } if ( ( $ this -> scheme == 'http' && $ this -> getPort ( ) == 80 ) || ( $ this -> scheme == 'ftp' && $ this -> getPort ( ) == 21 ) || ( $ this -> scheme == 'https' && $ this -> getPort ( ) == 443 ) ) { return sprintf ( "%s://%s%s%s" , $ this -> scheme , $ this -> getAddress ( ) , $ this -> path , $ query ) ; } return sprintf ( "%s://%s:%d%s%s" , $ this -> scheme , $ this -> getAddress ( ) , $ this -> getPort ( ) , $ this -> path , $ query ) ; }
12456	public function installAssets ( $ targetFolder = "web" , $ force = false ) { $ sourceDir = $ this -> pluginDir . '/Resources/public' ; $ targetDir = $ this -> rootDir . '/' . $ targetFolder . '/plugins/' . strtolower ( $ this -> name ) ; if ( is_dir ( $ targetDir ) && ! $ force ) { return ; } $ this -> filesystem -> symlink ( $ sourceDir , $ targetDir , true ) ; }
3692	protected function breadcrumb ( EnvironmentInterface $ environment ) { $ event = new GetBreadcrumbEvent ( $ environment ) ; $ environment -> getEventDispatcher ( ) -> dispatch ( $ event :: NAME , $ event ) ; $ arrReturn = $ event -> getElements ( ) ; if ( ! is_array ( $ arrReturn ) || count ( $ arrReturn ) == 0 ) { return null ; } $ GLOBALS [ 'TL_CSS' ] [ ] = 'bundles/ccadcgeneral/css/generalBreadcrumb.css' ; $ objTemplate = new ContaoBackendViewTemplate ( 'dcbe_general_breadcrumb' ) ; $ objTemplate -> elements = $ arrReturn ; return $ objTemplate -> parse ( ) ; }
12594	protected function makeDir ( $ dirName , LoggerInterface $ logger ) { $ dn = explode ( getcwd ( ) , $ dirName ) [ 1 ] ?? $ dirName ; if ( @ mkdir ( $ dirName ) ) { $ logger -> logText ( "Created directory <fg=green>%s</>" , LoggerInterface :: VERBOSITY_NORMAL , NULL , $ dn ) ; } else { $ logger -> logWarning ( "Creating directory $dn failed" ) ; } }
2646	public function cloneVersion ( $ curVersion ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ curVersion . '/clone' ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: PUT ) ; if ( ! $ result ) { throw new LocalizedException ( __ ( 'Failed to clone active version.' ) ) ; } return $ result ; }
12103	private function phpSizeToBytes ( $ size ) { if ( is_numeric ( $ size ) ) { return $ size ; } $ suffix = substr ( $ size , - 1 ) ; $ value = substr ( $ size , 0 , - 1 ) ; switch ( strtolower ( $ suffix ) ) { case 'p' : $ value *= 1024 ; case 't' : $ value *= 1024 ; case 'g' : $ value *= 1024 ; case 'm' : $ value *= 1024 ; case 'k' : $ value *= 1024 ; break ; } return $ value ; }
5558	protected function findForm ( $ method , $ attribute ) { if ( is_integer ( $ this -> focus ) ) { return $ this -> findFormInFrame ( $ this -> frames [ $ this -> focus ] , $ this -> focus , $ method , $ attribute ) ; } for ( $ i = 0 ; $ i < count ( $ this -> frames ) ; $ i ++ ) { $ form = $ this -> findFormInFrame ( $ this -> frames [ $ i ] , $ i , $ method , $ attribute ) ; if ( $ form ) { return $ form ; } } return ; }
7217	public function getDocumentationClassesList ( ) : array { $ classNames = $ this -> getCmfConfig ( ) -> config ( 'api_documentation.classes' , [ ] ) ; if ( empty ( $ classNames ) ) { $ classNames = $ this -> loadClassesFromFileSystem ( ) ; } return $ classNames ; }
3977	private function addEditMultipleCommand ( Contao2BackendViewDefinitionInterface $ view ) { $ definition = $ this -> container -> getBasicDefinition ( ) ; if ( ! $ definition -> isEditable ( ) && ! $ definition -> isDeletable ( ) && ! $ definition -> isCreatable ( ) ) { return ; } $ commands = $ view -> getGlobalCommands ( ) ; $ command = new SelectCommand ( ) ; $ command -> setName ( 'all' ) -> setLabel ( 'MSC.all.0' ) -> setDescription ( 'MSC.all.1' ) ; $ parameters = $ command -> getParameters ( ) ; $ parameters [ 'act' ] = 'select' ; $ extra = $ command -> getExtra ( ) ; $ extra [ 'class' ] = 'header_edit_all' ; $ commands -> addCommand ( $ command ) ; }
4598	public function generateIdentity ( Identitiable $ model , bool $ overwrite = false ) { if ( null === $ model -> getIdentity ( ) || $ overwrite ) { $ user = $ this -> tokenStorage -> getToken ( ) -> getUser ( ) ; $ model -> setIdentity ( $ user -> getIdentity ( ) -> getType ( ) ) -> setIdentityUuid ( $ user -> getIdentity ( ) -> getUuid ( ) ) ; } return $ this ; }
11132	public function exec ( ) { if ( $ this -> customQuery ) { return $ this -> execCustom ( ) ; } $ this -> last_wheres = $ this -> wheres ; $ this -> last_distinct = $ this -> distinct ; $ this -> last_ins = $ this -> ins ; $ this -> last_groupBys = $ this -> groupBys ; $ this -> last_havings = $ this -> havings ; $ this -> last_joins = $ this -> joins ; $ this -> calculate ( ) ; try { $ result = $ this -> db -> query ( $ this -> query ) ; } catch ( \ PDOException $ e ) { if ( $ this -> config [ 'mode' ] == 'development' ) { echo $ this -> getQuery ( ) ; } $ this -> reset ( ) ; throw $ e ; } $ this -> reset ( ) ; $ dbResult = new Db_MySQLResult ( $ result , $ this -> db ) ; return $ dbResult ; }
8257	protected function startAuthentication ( ) { $ authorizationUrl = $ this -> provider -> getAuthorizationUrl ( ) ; $ this -> session -> migrate ( true ) ; $ this -> session -> set ( "oauth2state" , $ this -> provider -> getState ( ) ) ; $ this -> picoAuth -> redirectToPage ( $ authorizationUrl , null , false ) ; }
3453	protected function determineStreamName ( string $ aggregateId ) : StreamName { if ( $ this -> oneStreamPerAggregate ) { if ( null === $ this -> streamName ) { $ prefix = $ this -> aggregateType -> toString ( ) ; } else { $ prefix = $ this -> streamName -> toString ( ) ; } return new StreamName ( $ prefix . '-' . $ aggregateId ) ; } if ( null === $ this -> streamName ) { return new StreamName ( 'event_stream' ) ; } return $ this -> streamName ; }
5703	public function bindGridField ( Form $ form , GridFieldDetailForm_ItemRequest $ request ) { $ this -> setForm ( $ form ) ; $ this -> gridFieldRequest = $ request ; return $ this ; }
2440	public function urlEncode ( ) : string { $ data = json_encode ( $ this ) ; if ( \ function_exists ( 'gzencode' ) && false !== ( $ encoded = @ gzencode ( $ data ) ) ) { $ data = $ encoded ; } return strtr ( base64_encode ( $ data ) , '+/=' , '-_,' ) ; }
12245	public function sortChildren ( ) { $ nodes = $ this -> removeNodes ( '*' ) ; $ args = func_get_args ( ) ; array_unshift ( $ args , null ) ; $ args [ 0 ] = & $ nodes ; call_user_func_array ( array ( get_class ( $ this ) , 'sort' ) , $ args ) ; foreach ( $ nodes as $ node ) { $ this -> appendChild ( $ node ) ; } return $ this ; }
789	public function getFirstError ( $ attribute ) { return isset ( $ this -> _errors [ $ attribute ] ) ? reset ( $ this -> _errors [ $ attribute ] ) : null ; }
8138	public function getTemplateClass ( $ name , $ index = null ) { $ key = $ this -> getLoader ( ) -> getCacheKey ( $ name ) . $ this -> optionsHash ; return $ this -> templateClassPrefix . hash ( 'sha256' , $ key ) . ( null === $ index ? '' : '_' . $ index ) ; }
11535	public function bootstrap ( $ app ) { Yii :: beginProfile ( get_called_class ( ) ) ; Yii :: $ app -> modules = static :: getModules ( ) ; Yii :: $ app -> on ( \ yii \ base \ Application :: EVENT_BEFORE_REQUEST , [ $ this , 'beforeRequest' ] ) ; Yii :: endProfile ( get_called_class ( ) ) ; Yii :: trace ( "Registered " . count ( static :: getModules ( ) ) . " modules in " . get_called_class ( ) ) ; }
8220	protected function getSubnet ( $ ip , $ netmask ) { $ binString = @ inet_pton ( $ ip ) ; if ( $ binString === false ) { throw new \ InvalidArgumentException ( "Not a valid IP address." ) ; } $ byteLen = mb_strlen ( $ binString , "8bit" ) ; if ( ! is_int ( $ netmask ) || $ netmask < 0 || $ netmask > $ byteLen * 8 ) { throw new \ InvalidArgumentException ( "Not a valid netmask." ) ; } for ( $ byte = $ byteLen - 1 ; ( $ byte + 1 ) * 8 > $ netmask ; -- $ byte ) { $ maskLen = min ( 8 , ( $ byte + 1 ) * 8 - $ netmask ) ; $ mask = ( ~ ( ( 1 << $ maskLen ) - 1 ) ) & 0xff ; $ maskedByte = $ mask & unpack ( 'C' , $ binString [ $ byte ] ) [ 1 ] ; $ binString [ $ byte ] = pack ( 'C' , $ maskedByte ) ; } return inet_ntop ( $ binString ) . '/' . $ netmask ; }
1082	private function skip ( $ kind ) { $ match = $ this -> lexer -> token -> kind === $ kind ; if ( $ match ) { $ this -> lexer -> advance ( ) ; } return $ match ; }
4739	public static function clearTmp ( $ clearFolderPath = '' ) { $ folderPath = self :: _getFolderToClear ( $ clearFolderPath ) ; $ directoryHandler = opendir ( $ folderPath ) ; if ( ! empty ( $ directoryHandler ) ) { while ( false !== ( $ fileName = readdir ( $ directoryHandler ) ) ) { $ filePath = $ folderPath . DIRECTORY_SEPARATOR . $ fileName ; self :: _clear ( $ fileName , $ filePath ) ; } closedir ( $ directoryHandler ) ; } return true ; }
6785	public function buildFormDataString ( $ options ) { $ options = $ this -> resolve ( $ options ) ; $ formOptions = [ ] ; foreach ( $ this -> formParameters as $ key => $ isFormParameter ) { if ( $ isFormParameter && isset ( $ options [ $ key ] ) ) { $ formOptions [ $ key ] = $ options [ $ key ] ; } } return http_build_query ( $ formOptions ) ; }
9810	private function readClientAnchor ( ) { $ length = Xls :: getInt4d ( $ this -> data , $ this -> pos + 4 ) ; $ recordData = substr ( $ this -> data , $ this -> pos + 8 , $ length ) ; $ this -> pos += 8 + $ length ; $ c1 = Xls :: getUInt2d ( $ recordData , 2 ) ; $ startOffsetX = Xls :: getUInt2d ( $ recordData , 4 ) ; $ r1 = Xls :: getUInt2d ( $ recordData , 6 ) ; $ startOffsetY = Xls :: getUInt2d ( $ recordData , 8 ) ; $ c2 = Xls :: getUInt2d ( $ recordData , 10 ) ; $ endOffsetX = Xls :: getUInt2d ( $ recordData , 12 ) ; $ r2 = Xls :: getUInt2d ( $ recordData , 14 ) ; $ endOffsetY = Xls :: getUInt2d ( $ recordData , 16 ) ; $ this -> object -> setStartCoordinates ( Coordinate :: stringFromColumnIndex ( $ c1 + 1 ) . ( $ r1 + 1 ) ) ; $ this -> object -> setStartOffsetX ( $ startOffsetX ) ; $ this -> object -> setStartOffsetY ( $ startOffsetY ) ; $ this -> object -> setEndCoordinates ( Coordinate :: stringFromColumnIndex ( $ c2 + 1 ) . ( $ r2 + 1 ) ) ; $ this -> object -> setEndOffsetX ( $ endOffsetX ) ; $ this -> object -> setEndOffsetY ( $ endOffsetY ) ; }
11413	public function batchUntagUsers ( array $ openIds , $ tagId ) { $ params = [ 'openid_list' => $ openIds , 'tagid' => $ tagId , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_MEMBER_BATCH_UNTAG , $ params ] ) ; }
12617	public function removeAttribute ( string $ attributeName ) { if ( isset ( $ this -> attributes [ $ attributeName ] ) ) unset ( $ this -> attributes [ $ attributeName ] ) ; }
8721	protected function getTranslatableAttributesFromSchema ( ) { if ( ( ! $ con = $ this -> getConnection ( ) ) || ( ! $ builder = $ con -> getSchemaBuilder ( ) ) ) { return [ ] ; } if ( $ columns = TranslatableConfig :: cacheGet ( $ this -> getI18nTable ( ) ) ) { return $ columns ; } $ columns = $ builder -> getColumnListing ( $ this -> getI18nTable ( ) ) ; unset ( $ columns [ array_search ( $ this -> getForeignKey ( ) , $ columns ) ] ) ; TranslatableConfig :: cacheSet ( $ this -> getI18nTable ( ) , $ columns ) ; return $ columns ; }
7514	function next_search ( $ characters , $ callback = true ) { $ this -> token_start = $ this -> pos ; if ( ! is_array ( $ characters ) ) { $ characters = array_fill_keys ( str_split ( $ characters ) , true ) ; } while ( ++ $ this -> pos < $ this -> size ) { if ( isset ( $ characters [ $ this -> doc [ $ this -> pos ] ] ) ) { if ( $ callback && isset ( $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ) { if ( is_string ( $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ) { return ( $ this -> token = $ this -> { $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] } ( ) ) ; } else { return ( $ this -> token = $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ; } } else { return ( $ this -> token = self :: TOK_UNKNOWN ) ; } } else { $ this -> parse_linebreak ( ) ; } } return ( $ this -> token = self :: TOK_NULL ) ; }
12849	private function _getPage404 ( ) { header ( "HTTP/1.0 404 Not Found" ) ; if ( isset ( $ this -> _oRoutes -> e404 ) ) { $ this -> _oRoutes -> e404 -> route = '/' ; $ _SERVER [ 'REQUEST_URI' ] = '/' ; $ this -> _route ( $ this -> _oRoutes -> e404 , $ _SERVER [ 'REQUEST_URI' ] ) ; } exit ; }
9302	public function setScheduleLifetime ( $ time ) { if ( ! is_numeric ( $ time ) ) { throw new \ InvalidArgumentException ( '`scheduleLifetime` expects integer value!' ) ; } $ this -> options [ 'scheduleLifetime' ] = ( int ) $ time ; return $ this ; }
11298	public function getModelsFromCustomRelationship ( $ attributeName , $ objName , $ query = false , $ loadMap = false ) { $ repo = \ Cora \ RepositoryFactory :: make ( $ objName , false , false , false , $ this -> model_db ) ; if ( ! $ query ) $ query = $ this -> _getQueryObjectForRelation ( $ attributeName ) ; $ definingFunctionName = $ this -> model_attributes [ $ attributeName ] [ 'using' ] ; $ query = $ this -> $ definingFunctionName ( $ query ) ; return $ repo -> findAll ( $ query , false , $ loadMap ) ; }
7013	private function format_m ( & $ str ) { if ( strstr ( $ str , '%m' ) ) $ str = str_replace ( '%m' , sprintf ( '%02d' , $ this -> month ) , $ str ) ; }
4479	public function tag ( ... $ tags ) : void { $ response = call_user_func_array ( [ $ this -> client , 'call' ] , array_merge ( [ 'tag' , 'add' , $ this -> jid ] , array_values ( func_get_args ( ) ) ) ) ; $ this -> setTags ( json_decode ( $ response , true ) ) ; }
5186	private function makeAttachmentObject ( string $ attachmentType , array $ attrReferences , array $ item ) { $ attrValues = [ ] ; foreach ( $ attrReferences as $ attrReference ) { $ attrValues [ $ attrReference ] = $ this -> getValue ( $ attrReference , $ item ) ; } switch ( $ attachmentType ) { case self :: JSON_PHOTO_FIELD : return $ this -> createPhoto ( $ attrValues [ 'photo_url' ] , $ attrValues [ 'photo_ratio' ] , '' , '' ) ; case self :: JSON_PAGE_FIELD : return $ this -> createPage ( $ attrValues [ 'page_title' ] , $ attrValues [ 'page_body' ] , $ attrValues [ 'page_source' ] , $ attrValues [ 'page_order' ] , $ attrValues [ 'page_cover' ] , $ attrValues [ 'page_lead' ] ) ; case self :: JSON_GALLERY_FIELD : return $ this -> createGallery ( $ attrValues [ 'gallery_body' ] , $ attrValues [ 'gallery_order' ] , $ attrValues [ 'gallery_photo' ] , $ attrValues [ 'gallery_source' ] , $ attrValues [ 'gallery_lead' ] ) ; case self :: JSON_VIDEO_FIELD : return $ this -> createVideo ( $ attrValues [ 'video_body' ] , $ attrValues [ 'video_source' ] , $ attrValues [ 'video_order' ] , $ attrValues [ 'video_cover' ] , $ attrValues [ 'video_lead' ] ) ; default : return null ; } }
5184	private function lookUp ( array $ articleConstant ) : array { $ copyListAttributes = $ this -> listAttributes ; return array_map ( function ( $ singleConst ) use ( $ copyListAttributes ) { $ res = $ copyListAttributes [ $ singleConst ] ; return array_map ( function ( $ str ) use ( $ singleConst ) { return $ singleConst . $ str ; } , $ res ) ; } , $ articleConstant ) ; }
6189	public function renderJSONP ( $ data ) { $ callback = null ; if ( isset ( $ _GET [ 'callback' ] ) ) { $ callback = $ _GET [ 'callback' ] ; } exit ( Response :: Create ( $ callback . '(' . json_encode ( $ data ) . ')' ) -> headers ( [ 'Content-Type' => 'application/jsonp' ] ) -> display ( ) ) ; }
4682	private static function formatTime ( float $ value , $ format ) : string { switch ( $ format ) { case static :: FORMAT_PRECISE : return ( string ) ( $ value * 1000 ) ; case static :: FORMAT_MILLISECONDS : return ( string ) round ( $ value * 1000 , 2 ) ; case static :: FORMAT_SECONDS : return ( string ) round ( $ value , 3 ) ; default : return ( string ) ( $ value * 1000 ) ; } }
2786	public static function mutates ( array & $ tokens , $ index ) { $ t = $ tokens [ $ index ] ; if ( ! is_array ( $ t ) && $ t == '+' ) { $ tokenCount = count ( $ tokens ) ; for ( $ i = $ index + 1 ; $ i < $ tokenCount ; $ i ++ ) { if ( ! is_array ( $ tokens [ $ i ] ) && $ tokens [ $ i ] [ 0 ] == '[' ) { return false ; } if ( is_array ( $ tokens [ $ i ] ) && $ tokens [ $ i ] [ 0 ] == T_ARRAY && $ tokens [ $ i ] [ 1 ] == 'array' ) { return false ; } if ( ! is_array ( $ tokens [ $ i ] ) && $ tokens [ $ i ] == ';' ) { return true ; } } return true ; } return false ; }
491	public function via ( $ relationName , callable $ callable = null ) { $ relation = $ this -> primaryModel -> getRelation ( $ relationName ) ; $ callableUsed = $ callable !== null ; $ this -> via = [ $ relationName , $ relation , $ callableUsed ] ; if ( $ callable !== null ) { call_user_func ( $ callable , $ relation ) ; } return $ this ; }
2907	public function getPartDecodedContent ( Zend_Mime_Part $ mimePart ) { if ( method_exists ( $ mimePart , 'getRawContent' ) ) { return $ mimePart -> getRawContent ( ) ; } $ content = '' ; if ( method_exists ( $ mimePart , 'getContent' ) ) { $ encoding = $ mimePart -> encoding ; $ mimePart -> encoding = 'none' ; $ content = $ mimePart -> getContent ( ) ; $ mimePart -> encoding = $ encoding ; } return $ content ; }
4685	public function select ( ? string $ expression = null , ... $ args ) : self { $ this -> dirty ( ) ; $ this -> select = $ expression === null ? null : [ $ expression ] ; $ this -> args [ 'select' ] = $ args ; return $ this ; }
12962	public function getTables ( ) { $ tables = $ this -> getDb ( ) -> getAllTables ( ) ; $ return = array ( ) ; foreach ( $ tables as $ name => $ table ) { foreach ( $ table as $ key => $ value ) { $ return [ $ table [ $ key ] ] = $ table [ $ key ] ; } } return $ return ; }
2087	public static function getDefaultPath ( $ template , $ format ) { $ file = $ template . '.' . $ format ; $ container = System :: getContainer ( ) ; $ rootDir = $ container -> getParameter ( 'kernel.project_dir' ) ; if ( isset ( self :: $ files [ $ template ] ) ) { return $ rootDir . '/' . self :: $ files [ $ template ] . '/' . $ file ; } $ strPath = null ; try { foreach ( $ container -> get ( 'contao.resource_finder' ) -> findIn ( 'templates' ) -> name ( $ file ) as $ file ) { $ strPath = $ file -> getPathname ( ) ; } } catch ( \ InvalidArgumentException $ e ) { } if ( $ strPath !== null ) { return $ strPath ; } throw new \ Exception ( 'Could not find template "' . $ template . '"' ) ; }
9202	public function createBearerToken ( ) { $ bearerCredentials = $ this -> createBearerCredentials ( ) ; $ headers = array ( 'Authorization' => 'Basic ' . $ bearerCredentials , 'Content-Type' => 'application/x-www-form-urlencoded;charset=UTF-8' ) ; $ body = 'grant_type=client_credentials' ; $ data = $ this -> guzzleClient -> post ( Config :: get ( 'oauth2_token' ) , array ( 'headers' => $ headers , 'body' => $ body ) ) -> json ( ) ; $ this -> credentials -> setBearerToken ( $ data [ 'access_token' ] ) ; return $ this ; }
7243	public function description ( ) { $ default = Inform_About_Content :: default_opt_in ( NULL ) ; $ subscribed_by_default = apply_filters ( 'iac_default_opt_in' , $ default ) ; $ description = $ subscribed_by_default ? __ ( 'Note: Users must opt-out from e-mail notifications by default' , Inform_About_Content :: TEXTDOMAIN ) : __ ( 'Note: Users must opt-in to e-mail notifications by default' , Inform_About_Content :: TEXTDOMAIN ) ; printf ( '<p class="description">%s</p>' , $ description ) ; }
8537	public function setRentalFeeList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'RentalFeeList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
8760	public function setLinePrefixMap ( array $ prefixMap ) { foreach ( $ prefixMap as $ status => $ prefix ) { $ this -> setLinePrefix ( $ status , $ prefix ) ; } }
11327	public function getLocations ( ) { if ( is_null ( $ this -> _locations ) ) { $ this -> _locations = $ this -> determineLocations ( ) ; } return $ this -> _locations ; }
330	public function get ( $ key ) { $ key = $ this -> buildKey ( $ key ) ; $ value = $ this -> getValue ( $ key ) ; if ( $ value === false || $ this -> serializer === false ) { return $ value ; } elseif ( $ this -> serializer === null ) { $ value = unserialize ( $ value ) ; } else { $ value = call_user_func ( $ this -> serializer [ 1 ] , $ value ) ; } if ( is_array ( $ value ) && ! ( $ value [ 1 ] instanceof Dependency && $ value [ 1 ] -> isChanged ( $ this ) ) ) { return $ value [ 0 ] ; } return false ; }
9350	public function transpose ( ) { $ out = new self ( $ this -> size -> cols , $ this -> size -> rows ) ; foreach ( $ this -> arr as $ row ) { $ out -> addCol ( $ row ) ; } return $ out ; }
9962	public function insertNewRowBefore ( $ pBefore , $ pNumRows = 1 ) { if ( $ pBefore >= 1 ) { $ objReferenceHelper = ReferenceHelper :: getInstance ( ) ; $ objReferenceHelper -> insertNewBefore ( 'A' . $ pBefore , 0 , $ pNumRows , $ this ) ; } else { throw new Exception ( 'Rows can only be inserted before at least row 1.' ) ; } return $ this ; }
11722	public function getPosts ( $ limit = null , $ offset = null ) { $ em = $ this -> container -> get ( 'doctrine' ) -> getManager ( ) ; if ( is_null ( $ limit ) && is_null ( $ offset ) ) { $ entities = $ em -> getRepository ( 'BlogBundle:Post' ) -> findBy ( array ( ) , array ( 'published' => 'DESC' ) ) ; } elseif ( is_null ( $ limit ) && ! is_null ( $ offset ) ) { $ entities = $ em -> getRepository ( 'BlogBundle:Post' ) -> findBy ( array ( ) , array ( 'published' => 'DESC' ) , $ limit ) ; } elseif ( ! is_null ( $ limit ) && ! is_null ( $ offset ) ) { $ entities = $ em -> getRepository ( 'BlogBundle:Post' ) -> findBy ( array ( ) , array ( 'published' => 'DESC' ) , $ limit , $ offset ) ; } return $ entities ; }
9211	protected function getFile ( ) { $ file = ( $ this -> params [ 'dev' ] ? $ this -> seedDevFile : $ this -> seedFile ) ; if ( ! empty ( $ this -> params [ 'file' ] ) ) { $ file = $ this -> params [ 'file' ] ; } return $ file ; }
4011	public function getPaginationString ( ) { $ this -> calculate ( ) ; if ( $ this -> getPerPage ( ) == 0 ) { return '' ; } $ objPagination = new \ Pagination ( $ this -> calculatedTotal , $ this -> getPerPage ( ) , $ this -> getMaxPaginationLinks ( ) ) ; return $ objPagination -> generate ( "\n " ) ; }
8338	public function returning ( $ returning ) { if ( is_array ( $ returning ) === true ) { $ this -> returning = implode ( ', ' , $ returning ) ; } else { $ this -> returning = $ returning ; } return $ this ; }
75	public function seek ( $ offset ) { $ this -> rewind ( ) ; for ( $ i = 0 ; $ i < $ offset ; $ i ++ , $ this -> next ( ) ) ; }
3325	public function renderOption ( Option $ opt ) { $ c1 = '' ; if ( $ opt -> short && $ opt -> long ) { $ c1 = sprintf ( '-%s, --%s' , $ opt -> short , $ opt -> long ) ; } else if ( $ opt -> short ) { $ c1 = sprintf ( '-%s' , $ opt -> short ) ; } else if ( $ opt -> long ) { $ c1 = sprintf ( '--%s' , $ opt -> long ) ; } $ c1 .= $ opt -> renderValueHint ( ) ; return $ c1 ; }
448	protected function renderPageButtons ( ) { $ pageCount = $ this -> pagination -> getPageCount ( ) ; if ( $ pageCount < 2 && $ this -> hideOnSinglePage ) { return '' ; } $ buttons = [ ] ; $ currentPage = $ this -> pagination -> getPage ( ) ; $ firstPageLabel = $ this -> firstPageLabel === true ? '1' : $ this -> firstPageLabel ; if ( $ firstPageLabel !== false ) { $ buttons [ ] = $ this -> renderPageButton ( $ firstPageLabel , 0 , $ this -> firstPageCssClass , $ currentPage <= 0 , false ) ; } if ( $ this -> prevPageLabel !== false ) { if ( ( $ page = $ currentPage - 1 ) < 0 ) { $ page = 0 ; } $ buttons [ ] = $ this -> renderPageButton ( $ this -> prevPageLabel , $ page , $ this -> prevPageCssClass , $ currentPage <= 0 , false ) ; } list ( $ beginPage , $ endPage ) = $ this -> getPageRange ( ) ; for ( $ i = $ beginPage ; $ i <= $ endPage ; ++ $ i ) { $ buttons [ ] = $ this -> renderPageButton ( $ i + 1 , $ i , null , $ this -> disableCurrentPageButton && $ i == $ currentPage , $ i == $ currentPage ) ; } if ( $ this -> nextPageLabel !== false ) { if ( ( $ page = $ currentPage + 1 ) >= $ pageCount - 1 ) { $ page = $ pageCount - 1 ; } $ buttons [ ] = $ this -> renderPageButton ( $ this -> nextPageLabel , $ page , $ this -> nextPageCssClass , $ currentPage >= $ pageCount - 1 , false ) ; } $ lastPageLabel = $ this -> lastPageLabel === true ? $ pageCount : $ this -> lastPageLabel ; if ( $ lastPageLabel !== false ) { $ buttons [ ] = $ this -> renderPageButton ( $ lastPageLabel , $ pageCount - 1 , $ this -> lastPageCssClass , $ currentPage >= $ pageCount - 1 , false ) ; } $ options = $ this -> options ; $ tag = ArrayHelper :: remove ( $ options , 'tag' , 'ul' ) ; return Html :: tag ( $ tag , implode ( "\n" , $ buttons ) , $ options ) ; }
3554	public function getValue ( ) { if ( $ this -> hasMutator ( $ this -> attributes [ 'meta_value' ] , 'getter' , $ this -> attributes [ 'meta_type' ] ) ) { return $ this -> mutateValue ( $ this -> attributes [ 'meta_value' ] , 'getter' ) ; } return $ this -> castValue ( ) ; }
4943	protected function addBaseFieldset ( ) { if ( null === $ this -> baseFieldset ) { return ; } $ fs = $ this -> baseFieldset ; if ( ! is_array ( $ fs ) ) { $ fs = array ( 'type' => $ fs , ) ; } if ( ! isset ( $ fs [ 'options' ] [ 'use_as_base_fieldset' ] ) ) { $ fs [ 'options' ] [ 'use_as_base_fieldset' ] = true ; } $ this -> add ( $ fs ) ; }
1168	protected function setRemoteValidation ( $ attribute , $ validateAll = false ) { $ validator = $ this -> validator ; $ rules = $ validator -> getRules ( ) ; $ rules = isset ( $ rules [ $ attribute ] ) ? $ rules [ $ attribute ] : [ ] ; if ( in_array ( 'no_js_validation' , $ rules ) ) { $ validator -> setRules ( [ $ attribute => [ ] ] ) ; return ; } if ( ! $ validateAll ) { $ rules = $ this -> purgeNonRemoteRules ( $ rules , $ validator ) ; } $ validator -> setRules ( [ $ attribute => $ rules ] ) ; }
2429	public static function initializeApplication ( Event $ event ) : void { $ webDir = self :: getWebDir ( $ event ) ; static :: purgeCacheFolder ( ) ; static :: addAppDirectory ( ) ; static :: executeCommand ( 'contao:install-web-dir' , $ event ) ; static :: executeCommand ( 'cache:clear --no-warmup' , $ event ) ; static :: executeCommand ( 'cache:warmup' , $ event ) ; static :: executeCommand ( sprintf ( 'assets:install %s --symlink --relative' , $ webDir ) , $ event ) ; static :: executeCommand ( sprintf ( 'contao:install %s' , $ webDir ) , $ event ) ; static :: executeCommand ( sprintf ( 'contao:symlinks %s' , $ webDir ) , $ event ) ; $ event -> getIO ( ) -> write ( '<info>Done! Please open the Contao install tool and make sure the database is up-to-date.</info>' ) ; }
5942	public function readLine ( $ token = "\n" ) { $ this -> connect ( ) ; $ line = StringHelper :: factory ( "" ) ; while ( ! $ line -> endsWith ( $ token ) ) { $ this -> waitForReadyRead ( ) ; $ data = @ fgets ( $ this -> stream , 4096 ) ; Signal :: getInstance ( ) -> emit ( strtolower ( $ this -> getAdapterType ( ) ) . "DataRead" , $ data ) ; if ( $ data === false ) { if ( $ line -> count ( ) ) { $ line -> append ( $ token ) ; } else { throw new Ts3Exception ( "connection to server '" . $ this -> config [ "host" ] . ":" . $ this -> config [ "port" ] . "' lost" ) ; } } else { $ line -> append ( $ data ) ; } } return $ line -> trim ( ) ; }
5390	protected function valueIsPossible ( $ value ) { $ widgets = $ this -> getWidgets ( ) ; for ( $ i = 0 , $ count = count ( $ widgets ) ; $ i < $ count ; $ i ++ ) { if ( $ widgets [ $ i ] -> getAttribute ( 'value' ) == $ value ) { return true ; } } return false ; }
6711	protected function urlToParameters ( $ url ) { $ urlParameters = [ ] ; $ url = parse_url ( $ url , PHP_URL_PATH ) ; $ urlParts = explode ( '/' , $ url ) ; reset ( $ urlParts ) ; $ key = next ( $ urlParts ) ; while ( ( $ value = next ( $ urlParts ) ) !== false ) { $ urlParameters [ $ key ] = $ value ; $ key = $ value ; } return $ urlParameters ; }
2150	public function activateAccount ( $ objUser ) { $ arrNewsletters = StringUtil :: deserialize ( $ objUser -> newsletter , true ) ; if ( ! \ is_array ( $ arrNewsletters ) ) { return ; } foreach ( $ arrNewsletters as $ intNewsletter ) { $ intNewsletter = ( int ) $ intNewsletter ; if ( $ intNewsletter < 1 ) { continue ; } $ this -> Database -> prepare ( "UPDATE tl_newsletter_recipients SET active='1' WHERE pid=? AND email=?" ) -> execute ( $ intNewsletter , $ objUser -> email ) ; } }
1911	protected function getType ( ) : string { if ( isset ( $ this -> options [ 'type' ] ) ) { return $ this -> options [ 'type' ] ; } $ className = ltrim ( strrchr ( static :: class , '\\' ) , '\\' ) ; if ( 'Controller' === substr ( $ className , - 10 ) ) { $ className = substr ( $ className , 0 , - 10 ) ; } return Container :: underscore ( $ className ) ; }
11122	public function getEndLocation ( ) { $ lastLocation = $ this -> getLocation ( ) ; $ lastDate = NOW ; foreach ( $ this -> movements as $ v ) { if ( $ v -> getEndTime ( ) > $ lastDate ) { $ lastDate = $ v -> getEndTime ( ) ; $ lastLocation = $ v -> getEndLocation ( ) ; } } return $ lastLocation ; }
6229	public function available ( ) { return $ this -> core -> api ( ) -> response ( $ this -> makeContainer ( $ this -> core -> modules ( ) -> getAllPermissions ( ) ) ) ; }
12323	protected function askQuestions ( InputInterface $ input , OutputInterface $ output ) { foreach ( $ this -> questions as $ question ) { if ( ! $ question -> ask ( $ input , $ output ) ) { return static :: RETURN_ERROR ; } } return static :: RETURN_SUCCESS ; }
8894	protected function _initialize_schema ( ) { $ this -> set_database ( $ this -> _database_group ) ; $ this -> _fetch_table ( ) ; $ this -> _fetch_primary_key ( ) ; if ( $ this -> primary_key == null && $ this -> is_base_model_instance ( ) ) { return ; } $ this -> _fields = $ this -> get_fields ( ) ; $ this -> _guess_is_soft_deletable ( ) ; $ this -> _guess_is_blamable ( ) ; $ this -> _guess_is_timestampable ( ) ; }
1746	public function addEnclosure ( $ strFile , $ strUrl = null , $ strMedia = 'enclosure' ) { if ( $ strFile == '' || ! file_exists ( System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) . '/' . $ strFile ) ) { return ; } if ( $ strUrl === null ) { $ strUrl = Environment :: get ( 'base' ) ; } $ objFile = new File ( $ strFile ) ; $ this -> arrData [ 'enclosure' ] [ ] = array ( 'media' => $ strMedia , 'url' => $ strUrl . System :: urlEncode ( $ strFile ) , 'length' => $ objFile -> size , 'type' => $ objFile -> mime ) ; }
10760	protected function buildUpdateSet ( ) { $ result = [ ] ; $ data = $ this -> clause_data [ 0 ] ; foreach ( $ data as $ col => $ val ) { $ result [ ] = $ this -> quote ( $ col ) . ' = ' . $ this -> processValue ( $ val ) ; } return $ result ; }
2170	private function setPassword ( ) : Response { $ request = $ this -> container -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; if ( null === $ request ) { throw new \ RuntimeException ( 'The request stack did not contain a request' ) ; } if ( 'tl_password' !== $ request -> request -> get ( 'FORM_SUBMIT' ) ) { return $ this -> render ( 'password.html.twig' ) ; } $ password = $ request -> request -> get ( 'password' ) ; $ confirmation = $ request -> request -> get ( 'confirmation' ) ; if ( $ password !== $ confirmation ) { return $ this -> render ( 'password.html.twig' , [ 'error' => $ this -> trans ( 'password_confirmation_mismatch' ) , ] ) ; } $ installTool = $ this -> container -> get ( 'contao.install_tool' ) ; $ minlength = $ installTool -> getConfig ( 'minPasswordLength' ) ; if ( Utf8 :: strlen ( $ password ) < $ minlength ) { return $ this -> render ( 'password.html.twig' , [ 'error' => sprintf ( $ this -> trans ( 'password_too_short' ) , $ minlength ) , ] ) ; } $ installTool -> persistConfig ( 'installPassword' , password_hash ( $ password , PASSWORD_DEFAULT ) ) ; $ this -> container -> get ( 'contao.install_tool_user' ) -> setAuthenticated ( true ) ; return $ this -> getRedirectResponse ( ) ; }
534	protected function fixFileDoc ( & $ lines ) { $ namespace = false ; $ namespaceLine = '' ; $ contentAfterNamespace = false ; foreach ( $ lines as $ i => $ line ) { $ line = trim ( $ line ) ; if ( ! empty ( $ line ) ) { if ( strncmp ( $ line , 'namespace' , 9 ) === 0 ) { $ namespace = $ i ; $ namespaceLine = $ line ; } elseif ( $ namespace !== false ) { $ contentAfterNamespace = $ i ; break ; } } } if ( $ namespace !== false && $ contentAfterNamespace !== false ) { while ( $ contentAfterNamespace > 0 ) { array_shift ( $ lines ) ; $ contentAfterNamespace -- ; } $ lines = array_merge ( [ '<?php' , '/**' , ' * @link http://www.yiiframework.com/' , ' * @copyright Copyright (c) 2008 Yii Software LLC' , ' * @license http://www.yiiframework.com/license/' , ' */' , '' , $ namespaceLine , '' , ] , $ lines ) ; } }
2375	public static function insertTagToSrc ( $ data ) { $ return = '' ; $ paths = preg_split ( '/((src|href)="([^"]*)\{\{file::([^"\}]+)\}\}")/i' , $ data , - 1 , PREG_SPLIT_DELIM_CAPTURE ) ; for ( $ i = 0 , $ c = \ count ( $ paths ) ; $ i < $ c ; $ i += 5 ) { $ return .= $ paths [ $ i ] ; if ( ! isset ( $ paths [ $ i + 1 ] ) ) { continue ; } $ file = FilesModel :: findByUuid ( $ paths [ $ i + 4 ] ) ; if ( $ file !== null ) { $ return .= $ paths [ $ i + 2 ] . '="' . $ paths [ $ i + 3 ] . $ file -> path . '"' ; } else { $ return .= $ paths [ $ i + 2 ] . '="' . $ paths [ $ i + 3 ] . $ paths [ $ i + 4 ] . '"' ; } } return $ return ; }
124	protected function getErrorMessage ( $ retval , $ file ) { switch ( $ retval ) { case ZipArchive :: ER_EXISTS : return sprintf ( "File '%s' already exists." , $ file ) ; case ZipArchive :: ER_INCONS : return sprintf ( "Zip archive '%s' is inconsistent." , $ file ) ; case ZipArchive :: ER_INVAL : return sprintf ( "Invalid argument (%s)" , $ file ) ; case ZipArchive :: ER_MEMORY : return sprintf ( "Malloc failure (%s)" , $ file ) ; case ZipArchive :: ER_NOENT : return sprintf ( "No such zip file: '%s'" , $ file ) ; case ZipArchive :: ER_NOZIP : return sprintf ( "'%s' is not a zip archive." , $ file ) ; case ZipArchive :: ER_OPEN : return sprintf ( "Can't open zip file: %s" , $ file ) ; case ZipArchive :: ER_READ : return sprintf ( "Zip read error (%s)" , $ file ) ; case ZipArchive :: ER_SEEK : return sprintf ( "Zip seek error (%s)" , $ file ) ; default : return sprintf ( "'%s' is not a valid zip archive, got error code: %s" , $ file , $ retval ) ; } }
7868	private function replaceUtf8 ( & $ original , $ replacement , $ position ) { $ start = mb_substr ( $ original , 0 , $ position , "UTF-8" ) ; $ end = mb_substr ( $ original , $ position + 1 , mb_strlen ( $ original , 'UTF-8' ) , "UTF-8" ) ; $ original = $ start . $ replacement . $ end ; }
9855	protected function storeBof ( $ type ) { $ record = 0x0809 ; $ length = 0x0010 ; $ unknown = pack ( 'VV' , 0x000100D1 , 0x00000406 ) ; $ build = 0x0DBB ; $ year = 0x07CC ; $ version = 0x0600 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vvvv' , $ version , $ type , $ build , $ year ) ; $ this -> append ( $ header . $ data . $ unknown ) ; }
6964	protected function getYear ( ) { $ year = 0 ; if ( $ this -> type == YearType :: Besselian ( ) ) $ year = 1900 + ( $ this -> jd - Epoch :: B1900 ( ) -> jd ) / static :: DaysBesselianYear ; else $ year = 2000 + ( $ this -> jd - Epoch :: J2000 ( ) -> jd ) / static :: DaysJulianYear ; return round ( $ year , 6 ) ; }
29	private function filterRequiredPackages ( RepositoryInterface $ repo , PackageInterface $ package , $ bucket = array ( ) ) { $ requires = array_keys ( $ package -> getRequires ( ) ) ; $ packageListNames = array_keys ( $ bucket ) ; $ packages = array_filter ( $ repo -> getPackages ( ) , function ( $ package ) use ( $ requires , $ packageListNames ) { return in_array ( $ package -> getName ( ) , $ requires ) && ! in_array ( $ package -> getName ( ) , $ packageListNames ) ; } ) ; $ bucket = $ this -> appendPackages ( $ packages , $ bucket ) ; foreach ( $ packages as $ package ) { $ bucket = $ this -> filterRequiredPackages ( $ repo , $ package , $ bucket ) ; } return $ bucket ; }
3649	public static function get ( ? string $ key = null ) { self :: init ( ) ; if ( $ key === null ) { return self :: $ utmCookie ; } else { if ( mb_strpos ( $ key , 'utm_' ) !== 0 ) { $ key = 'utm_' . $ key ; } if ( false === array_key_exists ( $ key , self :: $ utmCookie ) ) { throw new UnexpectedValueException ( sprintf ( 'Argument $key has unexpecte value "%s". Utm value with key "%s" does not exists.' , $ key , $ key ) ) ; } else { return self :: $ utmCookie [ $ key ] ; } } }
697	public function actionAll ( ) { if ( ! $ this -> confirm ( 'Install all applications and all extensions now?' ) ) { return 1 ; } foreach ( $ this -> extensions as $ ext => $ repo ) { $ ret = $ this -> actionExt ( $ ext ) ; if ( $ ret !== 0 ) { return $ ret ; } } foreach ( $ this -> apps as $ app => $ repo ) { $ ret = $ this -> actionApp ( $ app ) ; if ( $ ret !== 0 ) { return $ ret ; } } return 0 ; }
6665	public function parseFb ( $ raw_profile ) { $ profile = $ raw_profile ; $ profile -> avatar = sprintf ( 'http://graph.facebook.com/%s/picture' , $ profile -> id ) ; return ( array ) $ profile ; }
8709	protected function qualifyColumns ( $ columns ) { foreach ( $ columns as & $ column ) { if ( ! in_array ( $ column , $ this -> model -> translatableAttributes ( ) ) ) { continue ; } $ primary = $ this -> qualifyTranslationColumn ( $ column ) ; $ fallback = $ this -> qualifyTranslationColumn ( $ column , true ) ; if ( $ this -> model -> shouldFallback ( ) ) { $ column = new Expression ( $ this -> compileIfNull ( $ primary , $ fallback , $ column ) ) ; } else { $ column = $ primary ; } } return $ columns ; }
2233	public function checkPermission ( ) { if ( $ this -> User -> isAdmin ) { return ; } $ objSteps = $ this -> Database -> prepare ( "SELECT id FROM tl_undo WHERE pid=?" ) -> execute ( $ this -> User -> id ) ; $ GLOBALS [ 'TL_DCA' ] [ 'tl_undo' ] [ 'list' ] [ 'sorting' ] [ 'root' ] = $ objSteps -> numRows ? $ objSteps -> fetchEach ( 'id' ) : array ( 0 ) ; if ( Contao \ Input :: get ( 'act' ) && ! \ in_array ( Contao \ Input :: get ( 'id' ) , $ GLOBALS [ 'TL_DCA' ] [ 'tl_undo' ] [ 'list' ] [ 'sorting' ] [ 'root' ] ) ) { throw new Contao \ CoreBundle \ Exception \ AccessDeniedException ( 'Not enough permissions to ' . Contao \ Input :: get ( 'act' ) . ' undo step ID ' . Contao \ Input :: get ( 'id' ) . '.' ) ; } }
10087	private function createZip ( $ pFilename ) { $ zip = new ZipArchive ( ) ; if ( file_exists ( $ pFilename ) ) { unlink ( $ pFilename ) ; } if ( $ zip -> open ( $ pFilename , ZipArchive :: OVERWRITE ) !== true ) { if ( $ zip -> open ( $ pFilename , ZipArchive :: CREATE ) !== true ) { throw new WriterException ( "Could not open $pFilename for writing." ) ; } } return $ zip ; }
6800	public function installCurrencies ( $ code = 'USD' ) { $ currencyNames = Intl :: getCurrencyBundle ( ) -> getCurrencyNames ( ) ; if ( ! isset ( $ currencyNames [ $ code ] ) ) { throw new InvalidArgumentException ( "Invalid default currency code '$code'." ) ; } asort ( $ currencyNames ) ; $ this -> generate ( Currency :: class , $ currencyNames , $ code ) ; }
6342	final public static function valueOf ( $ name ) : self { $ className = static :: class ; Preconditions :: checkArgument ( array_key_exists ( $ className , self :: $ cache ) && array_key_exists ( $ name , self :: $ cache [ $ className ] ) , "The enum '%s' type has no constant with name '%s'" , $ className , $ name ) ; return self :: $ cache [ $ className ] [ $ name ] ; }
10130	private function writeScenProtect ( ) { if ( ! $ this -> phpSheet -> getProtection ( ) -> getSheet ( ) ) { return ; } if ( ! $ this -> phpSheet -> getProtection ( ) -> getScenarios ( ) ) { return ; } $ record = 0x00DD ; $ length = 0x0002 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , 1 ) ; $ this -> append ( $ header . $ data ) ; }
10656	public function usort ( $ cmp_function ) { $ tmp = $ this -> getArrayCopy ( ) ; $ ret = usort ( $ tmp , $ cmp_function ) ; $ tmp = new self ( $ tmp ) ; $ this -> exchangeArray ( $ tmp -> getArrayCopy ( ) ) ; return $ ret ; }
2855	public function getDatabaseUpdatesWithHandle ( $ handle , $ storeId , $ area ) { $ databaseHandles = array ( ) ; $ designPackage = Mage :: getModel ( 'core/design_package' ) ; $ designPackage -> setStore ( $ storeId ) ; $ designPackage -> setArea ( $ area ) ; $ layoutResourceModel = Mage :: getResourceModel ( 'core/layout' ) ; $ bind = array ( 'store_id' => $ storeId , 'area' => $ area , 'package' => $ designPackage -> getPackageName ( ) , 'theme' => $ designPackage -> getTheme ( 'layout' ) , 'layout_update_handle' => $ handle ) ; $ readAdapter = Mage :: getSingleton ( 'core/resource' ) -> getConnection ( 'core_read' ) ; $ select = $ readAdapter -> select ( ) -> from ( array ( 'layout_update' => $ layoutResourceModel -> getMainTable ( ) ) , array ( 'layout_update_id' , 'xml' ) ) -> join ( array ( 'link' => $ layoutResourceModel -> getTable ( 'core/layout_link' ) ) , 'link.layout_update_id=layout_update.layout_update_id' , '' ) -> where ( 'link.store_id IN (0, :store_id)' ) -> where ( 'link.area = :area' ) -> where ( 'link.package = :package' ) -> where ( 'link.theme = :theme' ) -> where ( 'layout_update.handle = :layout_update_handle' ) -> order ( 'layout_update.sort_order ' . Varien_Db_Select :: SQL_ASC ) ; $ result = $ readAdapter -> fetchAssoc ( $ select , $ bind ) ; if ( count ( $ result ) ) { foreach ( $ result as $ dbLayoutUpdate ) { $ databaseHandles [ $ dbLayoutUpdate [ 'layout_update_id' ] ] = $ dbLayoutUpdate [ 'xml' ] ; } } return $ databaseHandles ; }
8384	public function select ( $ select ) { if ( is_array ( $ select ) === true ) { $ this -> select = '' ; foreach ( $ select as $ key => $ elem ) { $ this -> select .= $ elem ; if ( is_numeric ( $ key ) === false ) { $ this -> select .= ' AS ' . $ key ; } $ this -> select .= ', ' ; } $ this -> select = substr ( $ this -> select , 0 , - 2 ) ; } elseif ( ! is_string ( $ select ) ) { throw new InvalidArgumentException ( sprintf ( 'Argument 1 passed to %s must be an array or string!' , __METHOD__ ) ) ; } else { $ this -> select = $ select ; } return $ this ; }
4539	public function setIndividualUuid ( ? string $ individualUuid ) { $ this -> individualUuid = $ individualUuid ; $ this -> _individualUuid = true ; return $ this ; }
2274	public function getEditableMemberProperties ( ) { $ return = array ( ) ; Contao \ System :: loadLanguageFile ( 'tl_member' ) ; $ this -> loadDataContainer ( 'tl_member' ) ; foreach ( $ GLOBALS [ 'TL_DCA' ] [ 'tl_member' ] [ 'fields' ] as $ k => $ v ) { if ( $ v [ 'eval' ] [ 'feEditable' ] ) { $ return [ $ k ] = $ GLOBALS [ 'TL_DCA' ] [ 'tl_member' ] [ 'fields' ] [ $ k ] [ 'label' ] [ 0 ] ; } } return $ return ; }
642	public function createIndex ( $ name , $ table , $ columns , $ unique = false ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> createIndex ( $ name , $ table , $ columns , $ unique ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; }
12876	private function setNamespace ( $ serviceName = null ) { if ( $ serviceName === null ) { $ this -> storage -> getOptions ( ) -> setNamespace ( $ this -> defaultNamespace ) ; } else { $ this -> storage -> getOptions ( ) -> setNamespace ( $ serviceName ) ; } }
4476	public function track ( ) : void { if ( $ this -> client -> call ( 'track' , 'track' , $ this -> jid ) ) { $ this -> tracked = true ; } }
7964	public function ipGetMonitoringNotification ( $ ip , $ notificationId ) { return json_decode ( self :: getClient ( ) -> ipGetMonitoringNotification ( $ this -> id , $ ip , $ notificationId ) ) ; }
9312	public function indexAction ( ) { if ( ! $ this -> isConsoleRequest ( ) ) { throw new \ RuntimeException ( 'You can only use this action from a console!' ) ; } $ console = $ this -> getConsole ( ) ; $ this -> printConsoleBanner ( $ console ) ; $ console -> writeLine ( 'TODO Finish indexAction!' , ConsoleColor :: LIGHT_RED ) ; }
7645	protected function getStorageClient ( $ path = '' ) { if ( is_null ( $ this -> storageClient ) ) { $ url = explode ( ':' , $ path ) ; if ( ! $ url ) { throw new BlobException ( 'Could not parse path "' . $ path . '".' ) ; } $ this -> storageClient = BlobClient :: getWrapperClient ( $ url [ 0 ] ) ; if ( ! $ this -> storageClient ) { throw new BlobException ( 'No storage client registered for stream type "' . $ url [ 0 ] . '://".' ) ; } } return $ this -> storageClient ; }
7151	public function equals ( SubjectIdentity $ identity ) { return $ this -> provider === $ identity -> getProvider ( ) && $ this -> identifier === $ identity -> getIdentifier ( ) ; }
11199	public function processDelete ( $ name , $ container = false ) { if ( ! $ container ) { $ container = $ this ; } if ( isset ( $ container -> singleton -> $ name ) ) { unset ( $ container -> singleton -> $ name ) ; return true ; } if ( isset ( $ container -> signature -> $ name ) ) { unset ( $ container -> signature -> $ name ) ; return true ; } elseif ( $ container -> parent ) { return $ container -> processDelete ( $ name , $ container -> parent ) ; } return false ; }
6748	public function handle ( ServerRequestInterface $ request ) { list ( $ httpResponse , $ _ ) = $ this -> requestHandler -> handleServerRequest ( $ request ) ; return $ httpResponse ; }
10335	public function setSuperscript ( $ pValue ) { if ( $ pValue == '' ) { $ pValue = false ; } if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'superscript' => $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> superscript = $ pValue ; $ this -> subscript = ! $ pValue ; } return $ this ; }
6016	public function createSite ( DeploymentSite $ deploymentSite ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'deploymentSite' => $ deploymentSite ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/deployment' , $ parameters ) ; $ result = new DeploymentSiteResponse ( $ result ) ; return $ result ; }
9224	public function setupToken ( $ token ) { if ( ! empty ( $ token ) ) { $ this -> headers [ 'Authorization' ] = "Bearer $token" ; return true ; } else { if ( $ this -> throw_exceptions ) { throw new CanvasPest_Exception ( 'API authorization token must be a non-zero-length string' , CanvasPest_Exception :: INVALID_TOKEN ) ; } return false ; } }
3024	public function getBlogPosts ( $ blogName , $ options = null ) { $ path = $ this -> blogPath ( $ blogName , '/posts' ) ; if ( $ options && isset ( $ options [ 'type' ] ) ) { $ path .= '/' . $ options [ 'type' ] ; unset ( $ options [ 'type' ] ) ; } return $ this -> getRequest ( $ path , $ options , true ) ; }
5974	public function filters ( ) { if ( ! $ this -> filters instanceof FiltersController ) { $ this -> filters = new FiltersController ( $ this -> getClient ( ) , $ this -> cachePolicy , $ this -> cache ) ; $ this -> filters -> setLogger ( $ this -> logger ) ; } return $ this -> filters ; }
12668	public function setCacheOptions ( $ cacheOptions ) { if ( $ cacheOptions instanceof CacheOptionsInterface ) { $ this -> cacheOptions = $ cacheOptions ; } elseif ( is_array ( $ cacheOptions ) ) { $ this -> cacheOptions = new CacheOptions ( $ cacheOptions ) ; } else { throw new Exception \ InvalidArgumentException ( sprintf ( '%s expects parameter 1 to be array or an instance of HtSettingsModule\Options\CacheOptionsInterface, %s provided instead' , __METHOD__ , is_object ( $ cacheOptions ) ? get_class ( $ cacheOptions ) : gettype ( $ cacheOptions ) ) ) ; } return $ this ; }
12346	private function createDeleteForm ( Post $ post ) { return $ this -> createFormBuilder ( ) -> setAction ( $ this -> generateUrl ( 'blog_category_delete' , array ( 'id' => $ post -> getId ( ) ) ) ) -> setMethod ( 'DELETE' ) -> getForm ( ) ; }
11843	private function getCalcId ( $ dsBegin , $ treeType ) { $ codeRegular = $ codeForecast = '' ; if ( $ treeType == OptionTreeType :: VAL_PLAIN ) { $ codeRegular = Cfg :: CODE_TYPE_CALC_PV_WRITE_OFF ; $ codeForecast = Cfg :: CODE_TYPE_CALC_FORECAST_PLAIN ; } elseif ( $ treeType == OptionTreeType :: VAL_COMPRESS ) { $ codeRegular = Cfg :: CODE_TYPE_CALC_COMPRESS_PHASE1 ; $ codeForecast = Cfg :: CODE_TYPE_CALC_FORECAST_PHASE1 ; } $ query = $ this -> qGetId -> build ( ) ; $ conn = $ query -> getConnection ( ) ; $ bind = [ QGetId :: BND_DS_BEGIN => $ dsBegin , QGetId :: BND_TYPE_CODE_REGULAR => $ codeRegular , QGetId :: BND_TYPE_CODE_FORECAST => $ codeForecast ] ; $ result = $ conn -> fetchOne ( $ query , $ bind ) ; return $ result ; }
1500	public function unless ( bool $ test , $ encodings ) : self { return $ this -> when ( true !== $ test , $ encodings ) ; }
6328	private function getColumnsSql ( ) { $ columnTypeMapper = new ColumnTypeMapper ( ) ; foreach ( $ this -> table -> getConstraints ( ) as $ constraint ) { if ( $ constraint instanceof PrimaryKey ) { $ primaryKey = $ constraint ; } } if ( ! isset ( $ primaryKey ) ) { $ primaryKey = new PrimaryKey ( ) ; $ primaryKey -> setTable ( $ this -> table ) ; $ this -> table -> addConstraint ( $ primaryKey ) ; } $ sql = '' ; if ( ! $ primaryKey -> isMulti ( ) && $ primaryKey -> isAutoCreateColumn ( ) ) { $ sql = sprintf ( '%s %s NOT NULL,' , $ primaryKey -> getColumns ( ) , $ primaryKey -> isAutoIncrement ( ) ? 'serial' : 'integer' ) ; } foreach ( $ this -> table -> getColumns ( ) as $ column ) { if ( $ column instanceof CustomColumn ) { $ columnType = $ column -> getType ( ) ; } else { $ columnType = $ columnTypeMapper -> getNative ( $ column -> getType ( ) ) ; } $ sql .= sprintf ( '%s %s%s %s %s,' , $ column -> getName ( ) , $ columnType , $ this -> getTypeConstraints ( $ column ) , $ column -> isNotNull ( ) ? 'NOT NULL' : '' , null === $ column -> getDefault ( ) ? '' : 'DEFAULT' . ' ' . $ this -> addQuotesIfNeeded ( $ column , $ column -> getDefault ( ) ) ) ; } return rtrim ( $ sql , ',' ) ; }
10011	public function removeSheetByIndex ( $ pIndex ) { $ numSheets = count ( $ this -> workSheetCollection ) ; if ( $ pIndex > $ numSheets - 1 ) { throw new Exception ( "You tried to remove a sheet by the out of bounds index: {$pIndex}. The actual number of sheets is {$numSheets}." ) ; } array_splice ( $ this -> workSheetCollection , $ pIndex , 1 ) ; if ( ( $ this -> activeSheetIndex >= $ pIndex ) && ( $ pIndex > count ( $ this -> workSheetCollection ) - 1 ) ) { -- $ this -> activeSheetIndex ; } }
10150	private function readHeader ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; if ( ! $ this -> readDataOnly ) { if ( $ recordData ) { if ( $ this -> version == self :: XLS_BIFF8 ) { $ string = self :: readUnicodeStringLong ( $ recordData ) ; } else { $ string = $ this -> readByteStringShort ( $ recordData ) ; } $ this -> phpSheet -> getHeaderFooter ( ) -> setOddHeader ( $ string [ 'value' ] ) ; $ this -> phpSheet -> getHeaderFooter ( ) -> setEvenHeader ( $ string [ 'value' ] ) ; } } }
6072	public function updateMedia ( $ id , Media $ media ) { if ( $ media instanceof MediaResponse ) { $ media = new Media ( json_decode ( json_encode ( $ media ) , true ) ) ; } $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'media' => $ media ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/media/' . $ id . '' , $ parameters ) ; $ result = new MediaResponse ( $ result ) ; return $ result ; }
9991	private function writeChartInCell ( Worksheet $ pSheet , $ coordinates ) { $ html = '' ; foreach ( $ pSheet -> getChartCollection ( ) as $ chart ) { if ( $ chart instanceof Chart ) { $ chartCoordinates = $ chart -> getTopLeftPosition ( ) ; if ( $ chartCoordinates [ 'cell' ] == $ coordinates ) { $ chartFileName = File :: sysGetTempDir ( ) . '/' . uniqid ( '' , true ) . '.png' ; if ( ! $ chart -> render ( $ chartFileName ) ) { return ; } $ html .= PHP_EOL ; $ imageDetails = getimagesize ( $ chartFileName ) ; if ( $ fp = fopen ( $ chartFileName , 'rb' , 0 ) ) { $ picture = fread ( $ fp , filesize ( $ chartFileName ) ) ; fclose ( $ fp ) ; $ base64 = chunk_split ( base64_encode ( $ picture ) ) ; $ imageData = 'data:' . $ imageDetails [ 'mime' ] . ';base64,' . $ base64 ; $ html .= '<div style="position: relative;">' ; $ html .= '<img style="position: absolute; z-index: 1; left: ' . $ chartCoordinates [ 'xOffset' ] . 'px; top: ' . $ chartCoordinates [ 'yOffset' ] . 'px; width: ' . $ imageDetails [ 0 ] . 'px; height: ' . $ imageDetails [ 1 ] . 'px;" src="' . $ imageData . '" border="0" />' . PHP_EOL ; $ html .= '</div>' ; unlink ( $ chartFileName ) ; } } } } return $ html ; }
8968	protected function load ( ) { $ this -> rates = array ( ) ; $ this -> latest = array ( ) ; $ handle = fopen ( $ this -> pathToFile , 'rb' ) ; if ( ! $ handle ) { throw new RuntimeException ( sprintf ( 'Error opening file on path "%s".' , $ this -> pathToFile ) ) ; } while ( ( $ line = fgets ( $ handle ) ) !== false ) { $ rate = $ this -> fromJson ( $ line ) ; $ this -> rates [ $ this -> getRateKey ( $ rate -> getCurrencyCode ( ) , $ rate -> getDate ( ) , $ rate -> getRateType ( ) , $ rate -> getSourceName ( ) ) ] = $ rate ; $ latestKey = sprintf ( '%s_%s_%s' , $ rate -> getCurrencyCode ( ) , $ rate -> getRateType ( ) , $ rate -> getSourceName ( ) ) ; if ( ! isset ( $ this -> latest [ $ latestKey ] ) || ( $ this -> latest [ $ latestKey ] -> getDate ( ) < $ rate -> getDate ( ) ) ) { $ this -> latest [ $ latestKey ] = $ rate ; } } fclose ( $ handle ) ; return $ this -> rates ; }
7794	protected function accountNumber ( $ text ) { if ( $ account = $ this -> getLine ( '25' , $ text ) ) { return ltrim ( substr ( $ account , 12 ) , '0' ) ; } return null ; }
4908	public function render ( SummaryFormInterface $ form , $ layout = Form :: LAYOUT_HORIZONTAL , $ parameter = array ( ) ) { $ renderer = $ this -> getView ( ) ; $ renderer -> headscript ( ) -> appendFile ( $ renderer -> basepath ( 'modules/Core/js/jquery.summary-form.js' ) ) ; $ label = $ form -> getLabel ( ) ; $ labelContent = $ label ? '<div class="sf-headline"><h3>' . $ this -> getView ( ) -> translate ( $ label ) . '</h3></div>' : '' ; $ formContent = $ this -> renderForm ( $ form , $ layout , $ parameter ) ; $ summaryContent = $ this -> renderSummary ( $ form ) ; $ formContent = sprintf ( '<div class="sf-form"><div class="panel panel-info"><div class="panel-body">%s</div></div></div> <div class="sf-summary">%s</div> ' , $ formContent , $ summaryContent ) ; if ( $ form instanceof DescriptionAwareFormInterface && $ form -> isDescriptionsEnabled ( ) ) { $ this -> getView ( ) -> headscript ( ) -> appendFile ( $ this -> getView ( ) -> basepath ( 'modules/Core/js/forms.descriptions.js' ) ) ; if ( $ desc = $ form -> getOption ( 'description' , '' ) ) { $ translator = $ this -> getTranslator ( ) ; $ textDomain = $ this -> getTranslatorTextDomain ( ) ; $ desc = $ translator -> translate ( $ desc , $ textDomain ) ; } $ formContent = sprintf ( '<div class="daf-form-container row"> <div class="daf-form col-md-8">%s</div> <div class="daf-desc col-md-4"> <div class="daf-desc-content alert alert-info">%s</div> </div> </div>' , $ formContent , $ desc ) ; } $ markup = '<div id="sf-%s" class="sf-container" data-display-mode="%s">' . '%s' . '%s' . '</div>' ; $ id = str_replace ( '.' , '-' , $ form -> getAttribute ( 'name' ) ) ; $ content = sprintf ( $ markup , $ id , $ form -> getDisplayMode ( ) , $ labelContent , $ formContent ) ; return $ content ; }
7953	public function getSpam ( $ ipblock , $ spamstate ) { if ( ! $ ipblock ) throw new BadMethodCallException ( 'Parameter $ipblock is missing.' ) ; if ( ! $ spamstate ) throw new BadMethodCallException ( 'Parameter $spamstate is missing.' ) ; switch ( $ spamstate ) { case "blockedForSpam" : case "unblocked" : case "unblocking" : break ; default : throw new BadMethodCallException ( 'Parameter $spamstate is invalid.' ) ; } try { $ r = $ this -> get ( 'ip/' . urlencode ( $ ipblock ) . '/spam/?state=' . $ spamstate ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new IpException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
7060	public function removeClass ( $ class ) { $ classes = $ this -> getClasses ( ) ; if ( false !== $ index = array_search ( $ class , $ classes ) ) { unset ( $ classes [ $ index ] ) ; } $ this -> setClasses ( $ classes ) ; return $ this ; }
9195	public function setThemesPath ( $ path ) { if ( ! is_dir ( $ path ) ) { throw new \ Exception ( sprintf ( 'Path "%s" not found.' , $ path ) ) ; } $ this -> themesPath = rtrim ( $ path , DS ) ; return $ this ; }
2367	public static function encodeEmail ( $ strString ) { if ( strpos ( $ strString , '@' ) === false ) { return $ strString ; } $ arrEmails = static :: extractEmail ( $ strString , Config :: get ( 'allowedTags' ) ) ; foreach ( $ arrEmails as $ strEmail ) { $ strEncoded = '' ; $ arrCharacters = Utf8 :: str_split ( $ strEmail ) ; foreach ( $ arrCharacters as $ strCharacter ) { $ strEncoded .= sprintf ( ( random_int ( 0 , 1 ) ? '&#x%X;' : '&#%s;' ) , Utf8 :: ord ( $ strCharacter ) ) ; } $ strString = str_replace ( $ strEmail , $ strEncoded , $ strString ) ; } return str_replace ( 'mailto:' , '&#109;&#97;&#105;&#108;&#116;&#111;&#58;' , $ strString ) ; }
11320	function getOne ( $ sql , $ params = array ( ) ) { $ data = $ this -> query ( $ sql , $ params ) ; if ( count ( $ data ) > 0 ) { $ data = array_values ( $ data [ 0 ] ) ; return $ data [ 0 ] ; } return false ; }
12767	public function set ( string $ key , $ value ) : self { $ this -> store [ $ key ] = $ value ; return self :: $ instance ; }
1507	public function didCreate ( $ resource ) : void { if ( $ this -> wasClientDispatched ( ) ) { $ this -> clientJob -> setResource ( $ resource ) -> save ( ) ; } }
3803	private function createProperty ( PropertyInterface $ property , $ propertyName , $ variantHandling , ConditionInterface $ condition = null , ConditionInterface $ legendCondition = null ) { $ paletteProperty = new Property ( $ propertyName ) ; $ extra = $ property -> getExtra ( ) ; $ chain = new PropertyConditionChain ( ) ; $ paletteProperty -> setEditableCondition ( $ chain ) ; if ( isset ( $ extra [ 'readonly' ] ) ) { $ chain -> addCondition ( new BooleanCondition ( $ extra [ 'readonly' ] ) ) ; } $ chain = new PropertyConditionChain ( ) ; $ paletteProperty -> setVisibleCondition ( $ chain ) ; if ( $ variantHandling ) { $ chain -> addCondition ( new IsVariantAttribute ( ) ) ; } $ chain -> addCondition ( new BooleanCondition ( ! ( ( isset ( $ extra [ 'doNotShow' ] ) && $ extra [ 'doNotShow' ] ) || ( isset ( $ extra [ 'hideInput' ] ) && $ extra [ 'hideInput' ] ) ) ) ) ; if ( null !== $ condition ) { $ chain -> addCondition ( $ condition ) ; } if ( null !== $ legendCondition ) { $ chain -> addCondition ( $ legendCondition ) ; } return $ paletteProperty ; }
12678	public function toJSON ( $ pretty = false ) { if ( $ pretty ) { return json_encode ( $ this -> scope -> results , JSON_PRETTY_PRINT ) ; } return json_encode ( $ this -> scope -> results ) ; }
7154	protected function match ( $ role , $ action ) : bool { $ roles = $ actions = [ '*' ] ; $ allow = false ; if ( $ role != '*' ) array_unshift ( $ roles , $ role ) ; if ( $ action != '*' ) array_unshift ( $ actions , $ action ) ; foreach ( $ roles as $ _role ) { foreach ( $ actions as $ _action ) { if ( isset ( $ this -> _rules [ $ _role ] [ $ _action ] ) ) { $ allow = $ this -> _rules [ $ _role ] [ $ _action ] ; break 2 ; } } } return $ allow === true ; }
3900	public function searchFor ( $ strPattern ) { $ strPattern = str_replace ( array ( '*' , '?' ) , array ( '%' , '_' ) , $ strPattern ) ; $ arrIds = $ this -> connection -> createQueryBuilder ( ) -> select ( 'id' ) -> from ( $ this -> getMetaModel ( ) -> getTableName ( ) ) -> where ( $ this -> getColName ( ) . ' LIKE :pattern' ) -> setParameter ( 'pattern' , $ strPattern ) -> execute ( ) -> fetchAll ( \ PDO :: FETCH_COLUMN , 'id' ) ; return $ arrIds ; }
9698	public function html ( $ paragraphs = null ) { $ this -> paragraphs = $ paragraphs ; unset ( $ this -> params [ 'plaintext' ] ) ; return $ this -> generate ( ) ; }
6937	private function has ( array & $ list , $ oid , StockUnitInterface $ unit ) { if ( ! isset ( $ list [ $ oid ] ) ) { return false ; } return false !== $ this -> find ( $ list , $ oid , $ unit ) ; }
7152	public function copy ( SubjectIdentity $ identity ) { $ this -> provider = $ identity -> getProvider ( ) ; $ this -> identifier = $ identity -> getIdentifier ( ) ; }
589	protected function registerBundle ( $ bundles , $ name , & $ registered ) { if ( ! isset ( $ registered [ $ name ] ) ) { $ registered [ $ name ] = false ; $ bundle = $ bundles [ $ name ] ; foreach ( $ bundle -> depends as $ depend ) { $ this -> registerBundle ( $ bundles , $ depend , $ registered ) ; } unset ( $ registered [ $ name ] ) ; $ registered [ $ name ] = $ bundle ; } elseif ( $ registered [ $ name ] === false ) { throw new Exception ( "A circular dependency is detected for target '{$name}': " . $ this -> composeCircularDependencyTrace ( $ name , $ registered ) . '.' ) ; } }
12813	private static function getNullables ( string $ table ) : array { if ( self :: $ nullablesCache !== null && array_key_exists ( $ table , self :: $ nullablesCache ) ) return self :: $ nullablesCache [ $ table ] ; $ pdo = Database :: connect ( ) ; $ query = " SELECT column_name, data_type, is_nullable, column_default FROM information_schema.columns WHERE table_name = '$table' AND is_nullable = 'YES' " ; self :: $ nullablesCache [ $ table ] = [ ] ; $ rows = $ pdo -> query ( $ query ) ; while ( $ row = $ rows -> fetch ( ) ) self :: $ nullablesCache [ $ table ] [ $ row [ "column_name" ] ] = $ row ; return self :: $ nullablesCache [ $ table ] ; }
1591	protected function validateData ( ) : bool { if ( ! property_exists ( $ this -> document , 'data' ) ) { $ this -> memberRequired ( '/' , 'data' ) ; return false ; } $ data = $ this -> document -> data ; if ( ! is_object ( $ data ) ) { $ this -> memberNotObject ( '/' , 'data' ) ; return false ; } return true ; }
10268	function createMailing ( $ name , $ subject , $ deprecatedParameter = false , $ type = "regular" ) { $ queryParameters = array ( 'name' => urlencode ( $ name ) , 'subject' => urlencode ( $ subject ) , 'type' => urlencode ( $ type ) , ) ; return $ this -> post ( 'mailings' , "" , $ queryParameters ) ; }
2283	protected static function url ( ) { $ host = static :: get ( 'httpHost' ) ; $ xhost = static :: get ( 'httpXForwardedHost' ) ; if ( $ xhost != '' && $ xhost == Config :: get ( 'sslProxyDomain' ) ) { return 'https://' . $ xhost . '/' . $ host ; } return ( static :: get ( 'ssl' ) ? 'https://' : 'http://' ) . $ host ; }
3953	public function get ( $ strAttributeName ) { return array_key_exists ( $ strAttributeName , $ this -> arrData ) ? $ this -> arrData [ $ strAttributeName ] : null ; }
9182	public function remember ( $ value , $ memoryDuration = null ) { if ( is_null ( $ memoryDuration ) ) { $ memoryDuration = $ this -> memoryDuration ; } $ key = $ this -> getRememberKey ( ) ; if ( Cache :: has ( $ key ) ) { $ value = Cache :: get ( $ key ) ; } else { $ expiresAt = Carbon :: now ( ) -> addMinutes ( $ memoryDuration ) ; if ( is_callable ( $ value ) ) { $ value = $ value ( ) ; } Cache :: put ( $ key , $ value , $ expiresAt ) ; } return $ value ; }
7402	public function Get ( $ name = null , $ value = null , ... $ param ) { if ( ! isset ( $ name ) ) return self :: $ config ; return isset ( $ value ) ? self :: $ config [ $ name ] [ $ value ] : ( isset ( self :: $ config [ $ name ] ) ? self :: $ config [ $ name ] : null ) ; }
7853	protected function resolveRequest ( ) { if ( class_exists ( $ request = $ this -> inflector -> getRequest ( ) ) ) { return $ this -> container -> make ( $ request ) ; } return $ this -> container -> make ( 'Illuminate\Http\Request' ) ; }
11730	public function validatePassword ( ) { $ user = User :: findByEmail ( $ this -> email ) ; if ( ! $ user || ! $ user -> validatePassword ( $ this -> password ) ) { $ this -> addError ( 'password' , 'Incorrect username or password.' ) ; } }
1274	private function createRequestLandedCost ( LandedCostRequest $ landedCostRequest ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; $ tradeabilityRequest = $ xml -> appendChild ( $ xml -> createElement ( 'LandedCostRequest' ) ) ; $ tradeabilityRequest -> setAttribute ( 'xml:lang' , 'en-US' ) ; $ request = $ tradeabilityRequest -> appendChild ( $ xml -> createElement ( 'Request' ) ) ; $ node = $ xml -> importNode ( $ this -> createTransactionNode ( ) , true ) ; $ request -> appendChild ( $ node ) ; $ request -> appendChild ( $ xml -> createElement ( 'RequestAction' , 'LandedCost' ) ) ; if ( $ landedCostRequest -> getQueryRequest ( ) !== null ) { $ tradeabilityRequest -> appendChild ( $ landedCostRequest -> getQueryRequest ( ) -> toNode ( $ xml ) ) ; } return $ xml -> saveXML ( ) ; }
11086	public static function getOctets ( $ option ) { if ( preg_match ( '/\d+k/i' , $ option ) ) { return 1024 * ( int ) $ option ; } if ( preg_match ( '/\d+m/i' , $ option ) ) { return 1024 * 1024 * ( int ) $ option ; } if ( preg_match ( '/\d+g/i' , $ option ) ) { return 1024 * 1024 * 1024 * ( int ) $ option ; } return $ option ; }
3538	public function queryLdapUserObject ( ) { if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: beginProfile ( 'queryLdapUserObject' , static :: YII2_PROFILE_NAME . 'queryLdapUserObject' ) ; } if ( $ this -> ldapUserObject == null ) { if ( $ this -> username == null ) { throw new \ yii \ base \ Exception ( 'Please set username attribute before calling queryLdapUserObject() function.' ) ; } $ userObjectsFound = static :: getAdldapProvider ( ) -> search ( ) -> where ( 'sAMAccountname' , '=' , $ this -> username ) -> get ( ) ; if ( count ( $ userObjectsFound ) != 1 ) { $ this -> ldapUserObject = null ; } else { $ this -> ldapUserObject = $ userObjectsFound [ 0 ] ; } } if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: endProfile ( 'queryLdapUserObject' , static :: YII2_PROFILE_NAME . 'queryLdapUserObject' ) ; } return $ this -> ldapUserObject ; }
11255	public function call ( string $ class ) : void { $ files = $ this -> all ( $ class ) ; if ( count ( $ files ) < 1 ) { throw InvalidArgumentException :: forNotFoundSeeder ( ) ; } foreach ( $ files as [ $ file , $ content ] ) { $ this -> load ( $ content ) ; $ this -> resolve ( $ file [ 'filename' ] ) -> run ( ) ; } }
906	public function isBinaryOperator ( $ index ) { static $ nonArrayOperators = [ '=' => true , '*' => true , '/' => true , '%' => true , '<' => true , '>' => true , '|' => true , '^' => true , '.' => true , ] ; static $ potentialUnaryNonArrayOperators = [ '+' => true , '-' => true , '&' => true , ] ; static $ arrayOperators ; if ( null === $ arrayOperators ) { $ arrayOperators = [ T_AND_EQUAL => true , T_BOOLEAN_AND => true , T_BOOLEAN_OR => true , T_CONCAT_EQUAL => true , T_DIV_EQUAL => true , T_DOUBLE_ARROW => true , T_IS_EQUAL => true , T_IS_GREATER_OR_EQUAL => true , T_IS_IDENTICAL => true , T_IS_NOT_EQUAL => true , T_IS_NOT_IDENTICAL => true , T_IS_SMALLER_OR_EQUAL => true , T_LOGICAL_AND => true , T_LOGICAL_OR => true , T_LOGICAL_XOR => true , T_MINUS_EQUAL => true , T_MOD_EQUAL => true , T_MUL_EQUAL => true , T_OR_EQUAL => true , T_PLUS_EQUAL => true , T_POW => true , T_POW_EQUAL => true , T_SL => true , T_SL_EQUAL => true , T_SR => true , T_SR_EQUAL => true , T_XOR_EQUAL => true , CT :: T_TYPE_ALTERNATION => true , ] ; if ( \ defined ( 'T_SPACESHIP' ) ) { $ arrayOperators [ T_SPACESHIP ] = true ; } if ( \ defined ( 'T_COALESCE' ) ) { $ arrayOperators [ T_COALESCE ] = true ; } } $ tokens = $ this -> tokens ; $ token = $ tokens [ $ index ] ; if ( $ token -> isArray ( ) ) { return isset ( $ arrayOperators [ $ token -> getId ( ) ] ) ; } if ( isset ( $ nonArrayOperators [ $ token -> getContent ( ) ] ) ) { return true ; } if ( isset ( $ potentialUnaryNonArrayOperators [ $ token -> getContent ( ) ] ) ) { return ! $ this -> isUnaryPredecessorOperator ( $ index ) ; } return false ; }
545	protected function rotateFiles ( ) { $ file = $ this -> logFile ; for ( $ i = $ this -> maxLogFiles ; $ i >= 0 ; -- $ i ) { $ rotateFile = $ file . ( $ i === 0 ? '' : '.' . $ i ) ; if ( is_file ( $ rotateFile ) ) { if ( $ i === $ this -> maxLogFiles ) { @ unlink ( $ rotateFile ) ; continue ; } $ newFile = $ this -> logFile . '.' . ( $ i + 1 ) ; $ this -> rotateByCopy ? $ this -> rotateByCopy ( $ rotateFile , $ newFile ) : $ this -> rotateByRename ( $ rotateFile , $ newFile ) ; if ( $ i === 0 ) { $ this -> clearLogFile ( $ rotateFile ) ; } } } }
10059	public function commit ( ) { foreach ( $ this -> deferred as $ item ) { $ this -> save ( $ item ) ; } $ this -> deferred = [ ] ; return true ; }
5408	protected function isMatch ( $ cookie , $ host , $ path , $ name ) { if ( $ cookie -> getName ( ) != $ name ) { return false ; } if ( $ host && $ cookie -> getHost ( ) && ! $ cookie -> isValidHost ( $ host ) ) { return false ; } if ( ! $ cookie -> isValidPath ( $ path ) ) { return false ; } return true ; }
3058	public function containsAdaptive ( ) { $ adaptiveSectionMap = $ this -> getServiceManager ( ) -> get ( CatService :: SERVICE_ID ) -> getAdaptiveSectionMap ( $ this -> getCompilationDirectory ( ) [ 'private' ] ) ; return ! empty ( $ adaptiveSectionMap ) ; }
4688	public function andWhere ( string $ expression , ... $ args ) : self { $ this -> dirty ( ) ; $ this -> where = $ this -> where ? '(' . $ this -> where . ') AND (' . $ expression . ')' : $ expression ; $ this -> pushArgs ( 'where' , $ args ) ; return $ this ; }
3805	public function generate ( ) { $ GLOBALS [ 'TL_CSS' ] [ ] = 'bundles/metamodelscore/css/style.css' ; $ arrModule = $ GLOBALS [ 'BE_MOD' ] [ 'metamodels' ] [ 'metamodels' ] ; if ( \ Input :: get ( 'key' ) && isset ( $ arrModule [ \ Input :: get ( 'key' ) ] ) ) { Callbacks :: call ( $ arrModule [ \ Input :: get ( 'key' ) ] , $ this , $ arrModule ) ; } $ act = \ Input :: get ( 'act' ) ; if ( ! strlen ( $ act ) ) { $ act = 'showAll' ; } return $ this -> dataContainer -> getEnvironment ( ) -> getController ( ) -> handle ( new Action ( $ act ) ) ; }
4455	public function attach ( string $ eventName , $ handler , int $ priority = 100 ) : void { if ( is_object ( $ handler ) == false && is_callable ( $ handler ) == false ) { throw new InvalidArgumentException ( sprintf ( 'Event handler must be either an object or a callable %s given.' , gettype ( $ handler ) ) ) ; } $ priorityQueue = $ this -> fetchQueue ( $ eventName ) ; $ priorityQueue -> insert ( $ handler , $ priority ) ; }
7793	public function getStatements ( $ text ) { if ( ! $ this -> parsers ) { $ this -> addParsers ( $ this -> getDefaultParsers ( ) ) ; } foreach ( $ this -> parsers as $ class ) { $ parser = new $ class ( $ this ) ; if ( $ parser -> accept ( $ text ) ) { return $ parser -> parse ( $ text ) ; } } throw new \ RuntimeException ( 'No suitable parser found.' ) ; }
6460	public function radioAction ( $ customized , $ selector ) { $ field = $ this -> getWorkingElement ( ) -> findField ( $ selector ) ; $ customized = ( bool ) $ customized ; if ( $ field !== null && ! $ customized ) { $ field -> selectOption ( $ field -> getAttribute ( 'value' ) ) ; return ; } foreach ( $ this -> findLabels ( $ selector ) as $ label ) { if ( $ customized && ! $ label -> isVisible ( ) ) { continue ; } $ label -> click ( ) ; return ; } $ this -> throwNoSuchElementException ( $ selector , $ field ) ; }
8278	public function onRequestUrl ( & $ url ) { $ this -> requestUrl = $ url ; try { $ this -> init ( ) ; $ this -> triggerEvent ( 'onPicoRequest' , [ $ url , $ this -> request ] ) ; } catch ( \ Exception $ e ) { $ this -> errorHandler ( $ e , $ url ) ; } if ( ! $ this -> errorOccurred ) { $ this -> authRoutes ( ) ; } }
10213	public function getSharedComponent ( ) { switch ( $ this -> parentPropertyName ) { case 'allBorders' : case 'horizontal' : case 'inside' : case 'outline' : case 'vertical' : throw new PhpSpreadsheetException ( 'Cannot get shared component for a pseudo-border.' ) ; break ; case 'bottom' : return $ this -> parent -> getSharedComponent ( ) -> getBottom ( ) ; case 'diagonal' : return $ this -> parent -> getSharedComponent ( ) -> getDiagonal ( ) ; case 'left' : return $ this -> parent -> getSharedComponent ( ) -> getLeft ( ) ; case 'right' : return $ this -> parent -> getSharedComponent ( ) -> getRight ( ) ; case 'top' : return $ this -> parent -> getSharedComponent ( ) -> getTop ( ) ; } }
11904	public function getLogModel ( $ refresh = false ) { $ config = $ this -> config ; if ( isset ( $ config [ 'logModel' ] ) ) { if ( ! is_object ( $ config [ 'logModel' ] ) ) { if ( $ refresh ) { return DataInterfaceLog :: find ( ) -> where ( [ 'id' => $ config [ 'logModel' ] ] ) -> one ( ) ; } else { return DataInterfaceLog :: get ( $ config [ 'logModel' ] ) ; } } if ( $ refresh ) { return DataInterfaceLog :: find ( ) -> where ( [ 'id' => $ config [ 'logModel' ] -> primaryKey ] ) -> one ( ) ; } return $ config [ 'logModel' ] ; } return ; }
11170	private function refreshSession ( ) { $ mapper = Neuron_GameServer_Mappers_UpdateMapper :: getInstance ( ) ; if ( ! isset ( $ _SESSION [ 'ngpu_lastlog' ] ) ) { $ _SESSION [ 'ngpu_lastlog' ] = $ mapper -> getLastLogId ( $ this -> objProfile ) ; $ _SESSION [ 'ngpu_data' ] = array ( ) ; } else { $ lastLogId = $ _SESSION [ 'ngpu_lastlog' ] ; $ updates = $ mapper -> getUpdates ( $ this -> objProfile , $ lastLogId ) ; foreach ( $ updates as $ v ) { $ _SESSION [ 'ngpu_data' ] [ $ v [ 'key' ] ] = $ v [ 'value' ] ; $ lastLogId = max ( $ v [ 'id' ] , $ lastLogId ) ; } $ _SESSION [ 'ngpu_lastlog' ] = $ lastLogId ; } }
12925	public function setSearch ( $ value ) { if ( ! is_object ( $ value ) ) { if ( ! isset ( $ value [ 'class' ] ) ) { $ value [ 'class' ] = $ this -> searchClass ; } $ value = Yii :: createObject ( $ value ) ; } $ value -> dataSource = $ this ; $ this -> _search = $ value ; }
878	public function useRuleSet ( RuleSetInterface $ ruleSet ) { $ fixers = [ ] ; $ fixersByName = [ ] ; $ fixerConflicts = [ ] ; $ fixerNames = array_keys ( $ ruleSet -> getRules ( ) ) ; foreach ( $ fixerNames as $ name ) { if ( ! \ array_key_exists ( $ name , $ this -> fixersByName ) ) { throw new \ UnexpectedValueException ( sprintf ( 'Rule "%s" does not exist.' , $ name ) ) ; } $ fixer = $ this -> fixersByName [ $ name ] ; $ config = $ ruleSet -> getRuleConfiguration ( $ name ) ; if ( null !== $ config ) { if ( $ fixer instanceof ConfigurableFixerInterface ) { if ( ! \ is_array ( $ config ) || ! \ count ( $ config ) ) { throw new InvalidFixerConfigurationException ( $ fixer -> getName ( ) , 'Configuration must be an array and may not be empty.' ) ; } $ fixer -> configure ( $ config ) ; } else { throw new InvalidFixerConfigurationException ( $ fixer -> getName ( ) , 'Is not configurable.' ) ; } } $ fixers [ ] = $ fixer ; $ fixersByName [ $ name ] = $ fixer ; $ conflicts = array_intersect ( $ this -> getFixersConflicts ( $ fixer ) , $ fixerNames ) ; if ( \ count ( $ conflicts ) > 0 ) { $ fixerConflicts [ $ name ] = $ conflicts ; } } if ( \ count ( $ fixerConflicts ) > 0 ) { throw new \ UnexpectedValueException ( $ this -> generateConflictMessage ( $ fixerConflicts ) ) ; } $ this -> fixers = $ fixers ; $ this -> fixersByName = $ fixersByName ; return $ this ; }
7935	public function send ( $ from , $ to , $ msg ) { $ opt = array ( 'sender' => $ from , 'receivers' => array ( $ to ) , 'message' => $ msg ) ; return $ this -> createJob ( $ opt ) ; }
424	protected function adjustLabelFor ( $ options ) { if ( ! isset ( $ options [ 'id' ] ) ) { return ; } $ this -> _inputId = $ options [ 'id' ] ; if ( ! isset ( $ this -> labelOptions [ 'for' ] ) ) { $ this -> labelOptions [ 'for' ] = $ options [ 'id' ] ; } }
2218	public function getFields ( ) { $ arrFields = $ GLOBALS [ 'TL_FFL' ] ; foreach ( array_keys ( $ arrFields ) as $ key ) { $ arrFields [ $ key ] = $ GLOBALS [ 'TL_LANG' ] [ 'FFL' ] [ $ key ] [ 0 ] ; } return $ arrFields ; }
3508	private static function doCharDiff ( $ from_text , $ to_text ) { $ result = array ( ) ; $ jobs = array ( array ( 0 , strlen ( $ from_text ) , 0 , strlen ( $ to_text ) ) ) ; while ( $ job = array_pop ( $ jobs ) ) { list ( $ from_segment_start , $ from_segment_end , $ to_segment_start , $ to_segment_end ) = $ job ; $ from_segment_len = $ from_segment_end - $ from_segment_start ; $ to_segment_len = $ to_segment_end - $ to_segment_start ; if ( ! $ from_segment_len || ! $ to_segment_len ) { if ( $ from_segment_len ) { $ result [ $ from_segment_start * 4 + 0 ] = new FineDiffDeleteOp ( $ from_segment_len ) ; } else if ( $ to_segment_len ) { $ result [ $ from_segment_start * 4 + 1 ] = new FineDiffInsertOp ( substr ( $ to_text , $ to_segment_start , $ to_segment_len ) ) ; } continue ; } if ( $ from_segment_len >= $ to_segment_len ) { $ copy_len = $ to_segment_len ; while ( $ copy_len ) { $ to_copy_start = $ to_segment_start ; $ to_copy_start_max = $ to_segment_end - $ copy_len ; while ( $ to_copy_start <= $ to_copy_start_max ) { $ from_copy_start = strpos ( substr ( $ from_text , $ from_segment_start , $ from_segment_len ) , substr ( $ to_text , $ to_copy_start , $ copy_len ) ) ; if ( $ from_copy_start !== false ) { $ from_copy_start += $ from_segment_start ; break 2 ; } $ to_copy_start ++ ; } $ copy_len -- ; } } else { $ copy_len = $ from_segment_len ; while ( $ copy_len ) { $ from_copy_start = $ from_segment_start ; $ from_copy_start_max = $ from_segment_end - $ copy_len ; while ( $ from_copy_start <= $ from_copy_start_max ) { $ to_copy_start = strpos ( substr ( $ to_text , $ to_segment_start , $ to_segment_len ) , substr ( $ from_text , $ from_copy_start , $ copy_len ) ) ; if ( $ to_copy_start !== false ) { $ to_copy_start += $ to_segment_start ; break 2 ; } $ from_copy_start ++ ; } $ copy_len -- ; } } if ( $ copy_len ) { $ jobs [ ] = array ( $ from_segment_start , $ from_copy_start , $ to_segment_start , $ to_copy_start ) ; $ result [ $ from_copy_start * 4 + 2 ] = new FineDiffCopyOp ( $ copy_len ) ; $ jobs [ ] = array ( $ from_copy_start + $ copy_len , $ from_segment_end , $ to_copy_start + $ copy_len , $ to_segment_end ) ; } else { $ result [ $ from_segment_start * 4 ] = new FineDiffReplaceOp ( $ from_segment_len , substr ( $ to_text , $ to_segment_start , $ to_segment_len ) ) ; } } ksort ( $ result , SORT_NUMERIC ) ; return array_values ( $ result ) ; }
11971	public function handleCommand ( Event $ event , Queue $ queue ) { if ( $ this -> validateParams ( $ event ) ) { $ params = $ event -> getCustomParams ( ) ; $ results = array ( ) ; $ total = 0 ; $ count = $ params [ 0 ] ; $ sides = ( isset ( $ params [ 1 ] ) ) ? $ params [ 1 ] : $ this -> defaultDieSides ; for ( $ roll = 1 ; $ roll <= $ count ; $ roll ++ ) { $ rollResult = $ this -> doRoll ( $ sides ) ; $ results [ ] = $ rollResult ; $ total += $ rollResult ; } $ response = $ this -> generateResponse ( $ event , $ total , $ results ) ; $ this -> sendIrcResponseLine ( $ event , $ queue , $ response ) ; } else { $ this -> handleCommandHelp ( $ event , $ queue ) ; } }
12067	public function fetchProjects ( ) { $ response = $ this -> getResponse ( 'get' , 'v2/projects' ) ; $ projects = array ( ) ; if ( is_array ( $ response ) ) { foreach ( $ response as $ data ) { $ projects [ ] = $ this -> hydrator -> hydrate ( new Project ( ) , $ data ) ; } } return $ projects ; }
3210	function disableOAuth1AccessToken ( $ oauth1AccessToken ) { OAuth1AccessToken :: checkArg ( "oauth1AccessToken" , $ oauth1AccessToken ) ; $ response = self :: doPost ( $ oauth1AccessToken , "1/disable_access_token" ) ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; }
4345	public function getCfgLazy ( $ name ) { if ( ! isset ( $ this -> cfgLazy [ $ name ] ) ) { return array ( ) ; } $ return = $ this -> cfgLazy [ $ name ] ; unset ( $ this -> cfgLazy [ $ name ] ) ; return $ return ; }
8235	protected function ivalidateToken ( $ index , array & $ tokenStorage ) { unset ( $ tokenStorage [ $ index ] ) ; $ this -> session -> set ( self :: SESSION_KEY , $ tokenStorage ) ; }
4792	function select ( $ columns ) { $ this -> __destruct ( ) ; if ( $ columns != "" ) { foreach ( func_get_args ( ) as $ columns ) { $ this -> select [ ] = $ columns ; } } else { $ this -> select = array ( ) ; } return $ this ; }
6760	static public function buildCacheKey ( $ columns = '*' , array $ conditionsAndOptions = [ ] ) { foreach ( $ conditionsAndOptions as & $ value ) { if ( $ value instanceof DbExpr ) { $ value = $ value -> get ( ) ; } else if ( is_object ( $ value ) ) { throw new \ InvalidArgumentException ( '$conditionsAndOptions argument may contain only strings and objects of class \PeskyORM\Core\DbExpr.' . ' Object of class ' . get_class ( $ value ) . ' detected' ) ; } } unset ( $ value ) ; if ( is_array ( $ columns ) ) { foreach ( $ columns as & $ value ) { if ( $ value instanceof DbExpr ) { $ value = $ value -> get ( ) ; } else if ( is_object ( $ value ) ) { throw new \ InvalidArgumentException ( '$columns argument may contain only strings and objects of class \PeskyORM\Core\DbExpr.' . ' Object of class ' . get_class ( $ value ) . ' detected' ) ; } } unset ( $ value ) ; } else if ( $ columns instanceof DbExpr ) { $ columns = $ columns -> get ( ) ; } return hash ( 'sha256' , json_encode ( array ( $ columns , $ conditionsAndOptions ) ) ) ; }
8231	public static function getItemByUrl ( $ items , $ url ) { if ( ! isset ( $ items ) ) { return null ; } if ( array_key_exists ( "/" . $ url , $ items ) ) { return $ items [ "/" . $ url ] ; } $ urlParts = explode ( "/" , trim ( $ url , "/" ) ) ; $ urlPartsLen = count ( $ urlParts ) ; while ( $ urlPartsLen > 0 ) { unset ( $ urlParts [ -- $ urlPartsLen ] ) ; $ subUrl = "/" . join ( "/" , $ urlParts ) ; if ( array_key_exists ( $ subUrl , $ items ) && ( ! isset ( $ items [ $ subUrl ] [ "recursive" ] ) || $ items [ $ subUrl ] [ "recursive" ] === true ) ) { return $ items [ $ subUrl ] ; } } return null ; }
1382	protected function dataHas ( $ key ) : bool { if ( ! isset ( $ this -> document -> data ) ) { return false ; } return property_exists ( $ this -> document -> data , $ key ) ; }
7586	public function setDestinationPath ( $ destination = null ) { if ( empty ( $ destination ) ) { $ destination = sys_get_temp_dir ( ) . '/SugarAPI' ; } $ this -> destinationPath = $ destination ; return $ this ; }
4548	public function getAll ( ) : Data { $ data = new Data ; foreach ( $ this -> statCollection as $ stat ) { $ datum = $ stat -> get ( ) ; $ data -> getCollection ( ) -> add ( $ datum ) ; } return $ data ; }
10892	public function isPrime ( ) { if ( $ this -> value < 2 ) { return false ; } if ( $ this -> value === 2 ) { return true ; } if ( $ this -> isEven ( ) ) { return false ; } for ( $ i = 3 ; $ i <= ceil ( sqrt ( $ this -> value ) ) ; $ i = $ i + 2 ) { if ( $ this -> value % $ i == 0 ) { return false ; } } return true ; }
8778	public function redirect ( $ data = null , int $ statusCode = 301 , $ secure = false ) { if ( substr ( $ data , 0 , 4 ) === 'http' || substr ( $ data , 0 , 5 ) === 'https' ) { header ( 'Location: ' . $ data , true , $ statusCode ) ; } else { $ data = ( ! is_null ( $ data ) ) ? $ this -> url . '/' . $ data : $ this -> url ; header ( 'Location: ' . $ this -> getUrl ( $ data , $ secure ) , true , $ statusCode ) ; } die ( ) ; }
10063	public function get ( $ key , $ default = null ) { $ meta = $ this -> metaModel :: where ( 'key' , $ key ) -> first ( ) ; return $ meta === null ? $ default : $ meta -> value ; }
3808	protected function translateProperty ( $ property , $ metaModel , $ legend ) { $ attribute = $ metaModel -> getAttributeById ( $ property [ 'attr_id' ] ) ; if ( ! $ attribute ) { return false ; } $ propName = $ attribute -> getColName ( ) ; $ this -> legends [ $ legend ] [ 'properties' ] [ ] = $ propName ; $ this -> properties [ $ propName ] = array ( 'info' => $ attribute -> getFieldDefinition ( $ property ) , ) ; return true ; }
4122	private function getProxyFileName ( $ className , $ baseDir = null ) { $ proxyDir = $ baseDir ? : $ this -> proxyDir ; return $ proxyDir . DIRECTORY_SEPARATOR . '__CG__' . str_replace ( '\\' , '' , $ className ) . '.php' ; }
12692	public function synchronize ( Page $ page , array $ pages ) { if ( ! $ this -> configurationHandler -> isTheme ( ) ) { return ; } foreach ( $ pages as $ pageValues ) { $ tokens = explode ( "_" , $ pageValues [ "seo" ] [ 0 ] [ "language" ] ) ; $ pageOptions = array ( 'page' => $ pageValues [ "name" ] , 'language' => $ tokens [ 0 ] , 'country' => $ tokens [ 1 ] , ) ; $ page -> render ( $ this -> configurationHandler -> siteDir ( ) , $ pageOptions ) ; $ this -> saveTemplateSlots ( $ page -> getPageSlots ( ) , $ pageValues [ "template" ] ) ; } $ this -> saveTemplateSlots ( $ page -> getCommonSlots ( ) , 'base' ) ; }
6505	public function deserializeParameters ( $ type , $ data ) { $ jobType = $ this -> registry -> get ( $ type ) ; $ indices = $ jobType -> getIndicesOfSerializableParameters ( ) ; $ serializedParameters = json_decode ( $ data , 1 ) ; if ( false === $ serializedParameters ) { throw new \ RuntimeException ( sprintf ( 'Deserialization failed with error "%s"' , json_last_error_msg ( ) ) ) ; } if ( count ( $ indices ) < count ( $ serializedParameters ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The serialized data contains more parameters than defined for job "%s"' , $ type ) ) ; } $ parameters = array ( ) ; foreach ( $ serializedParameters as $ index => $ data ) { if ( null === $ data ) { $ parameters [ ] = null ; } else { $ parameters [ ] = $ this -> serializer -> deserialize ( $ data , $ jobType -> getParameterType ( $ indices [ $ index ] ) , 'json' , $ this -> getParamDeserializationContext ( $ jobType , $ indices [ $ index ] ) ) ; } } return $ parameters ; }
11604	public function notify ( ) { declare ( ticks = 1 ) ; if ( is_array ( $ this -> _caller ) && ! empty ( $ this -> _caller ) ) { return call_user_func_array ( $ this -> _caller , [ $ this -> _interrupt ] ) ; } else if ( $ this -> _caller instanceof Closure ) { return $ this -> _caller -> call ( $ this , $ this -> _interrupt ) ; } else if ( is_callable ( $ this -> _caller ) ) { $ cl = Closure :: fromCallable ( $ this -> _caller ) ; return $ cl -> call ( $ this , $ this -> _interrupt ) ; } return null ; }
5482	public function setField ( SelectorInterface $ selector , $ value , $ position = false ) { $ success = false ; $ _position = 0 ; for ( $ i = 0 , $ count = count ( $ this -> widgets ) ; $ i < $ count ; $ i ++ ) { if ( $ selector -> isMatch ( $ this -> widgets [ $ i ] ) ) { $ _position ++ ; if ( $ position === false or $ _position === ( int ) $ position ) { if ( $ this -> widgets [ $ i ] -> setValue ( $ value ) ) { $ success = true ; } } } } return $ success ; }
12872	public function setElementRequired ( \ Zend \ Form \ Element $ element ) { $ element -> setAttribute ( 'required' , 'true' ) ; $ this -> form -> getInputFilter ( ) -> get ( $ element -> getAttribute ( 'name' ) ) -> setAllowEmpty ( false ) ; }
11970	public function extendExpiration ( ) { if ( null === $ this -> ttl ) { throw new DomainException ( 'There is no TTL set for this Lock.' ) ; } if ( ! $ this -> expiresAt ) { $ this -> expiresAt = new \ DateTime ( ) ; $ this -> expiresAt -> setTimestamp ( time ( ) ) ; } $ this -> expiresAt -> add ( $ this -> ttl ) ; }
1423	protected function with ( $ query , EncodingParametersInterface $ parameters ) { $ query -> with ( $ this -> getRelationshipPaths ( ( array ) $ parameters -> getIncludePaths ( ) ) ) ; }
7680	function TbsSheetSlide_DeleteDisplay ( $ id_or_name , $ ok , $ delete ) { if ( is_null ( $ ok ) ) $ ok = true ; $ ext = $ this -> ExtEquiv ; $ ok = ( boolean ) $ ok ; if ( ! is_array ( $ id_or_name ) ) $ id_or_name = array ( $ id_or_name ) ; foreach ( $ id_or_name as $ item => $ action ) { if ( ! is_bool ( $ action ) ) { $ item = $ action ; $ action = $ ok ; } $ item_ref = ( is_string ( $ item ) ) ? 'n:' . htmlspecialchars ( $ item ) : 'i:' . $ item ; if ( $ delete ) { if ( $ ok ) { $ this -> OtbsSheetSlidesDelete [ $ item_ref ] = $ item ; } else { unset ( $ this -> OtbsSheetSlidesVisible [ $ item_ref ] ) ; } } else { $ this -> OtbsSheetSlidesVisible [ $ item_ref ] = $ ok ; } } }
6359	public function limit ( int $ limit ) : BufferedIterable { Preconditions :: checkArgument ( 0 < $ limit , 'Limit must be a positive integer!' ) ; return new BufferedIterable ( $ this -> chunkProvider , $ this -> filter , $ limit , $ this -> providerCallLimit ) ; }
3416	protected function normalizeFieldsForSave ( $ selectedFields ) { $ fields = [ ] ; if ( $ this -> fields === null ) { return [ ] ; } foreach ( $ this -> fields as $ field => $ value ) { if ( ! $ this -> fieldShouldNotBeSaved ( $ field , $ value , $ selectedFields ) ) { $ fields [ $ field ] = $ value ; } } return $ fields ? : null ; }
4038	public function getMatchingIds ( ) { $ arrIds = array ( ) ; foreach ( $ this -> arrChildFilters as $ objChildFilter ) { $ arrChildMatches = $ objChildFilter -> getMatchingIds ( ) ; if ( $ arrChildMatches === null ) { return null ; } if ( $ arrChildMatches && $ this -> stopAfterMatch ) { return $ arrChildMatches ; } if ( $ arrChildMatches ) { $ arrIds = array_merge ( $ arrIds , $ arrChildMatches ) ; } } return array_unique ( $ arrIds ) ; }
8432	public function getDsn ( array $ info ) : string { $ dsn = 'pgsql:host=' ; $ dsn .= ( isset ( $ info [ 'host' ] ) === true ? $ info [ 'host' ] : 'localhost' ) . ';' ; if ( isset ( $ info [ 'port' ] ) === true ) { $ dsn .= 'port=' . $ info [ 'port' ] . ';' ; } $ dsn .= 'dbname=' . $ info [ 'name' ] . ';' ; return $ dsn ; }
447	private function attachBehaviorInternal ( $ name , $ behavior ) { if ( ! ( $ behavior instanceof Behavior ) ) { $ behavior = Yii :: createObject ( $ behavior ) ; } if ( is_int ( $ name ) ) { $ behavior -> attach ( $ this ) ; $ this -> _behaviors [ ] = $ behavior ; } else { if ( isset ( $ this -> _behaviors [ $ name ] ) ) { $ this -> _behaviors [ $ name ] -> detach ( ) ; } $ behavior -> attach ( $ this ) ; $ this -> _behaviors [ $ name ] = $ behavior ; } return $ behavior ; }
702	protected function findDirs ( $ dir ) { $ list = [ ] ; $ handle = @ opendir ( $ dir ) ; if ( $ handle === false ) { return [ ] ; } while ( ( $ file = readdir ( $ handle ) ) !== false ) { if ( $ file === '.' || $ file === '..' ) { continue ; } $ path = $ dir . DIRECTORY_SEPARATOR . $ file ; if ( is_dir ( $ path ) && preg_match ( '/^yii2-(.*)$/' , $ file , $ matches ) ) { $ list [ ] = $ matches [ 1 ] ; } } closedir ( $ handle ) ; foreach ( $ list as $ i => $ e ) { if ( $ e === 'composer' ) { unset ( $ list [ $ i ] ) ; } } return $ list ; }
12249	public function xpathByAttribute ( $ strXpathQuery , $ strIndexAttribute = 'name' ) { $ arrOut = array ( ) ; $ objResult = $ this -> xpath ( $ strXpathQuery ) ; foreach ( $ objResult as $ intIndex => $ objNode ) { $ strIndex = ( string ) $ objNode -> attributes ( ) -> $ strIndexAttribute ; $ arrOut [ $ strIndex ] = $ objResult [ $ intIndex ] ; } return $ arrOut ; }
11699	public function addService ( Service $ service ) { if ( array_key_exists ( $ service -> getName ( ) , $ this -> services ) ) { throw new KeyTakenInSetException ( $ service -> getName ( ) , 'services' ) ; } $ this -> services [ $ service -> getName ( ) ] = $ service ; return $ this ; }
11112	public function getMigrationFiles ( string $ type ) : array { $ array = [ ] ; foreach ( $ this -> filesystem -> listContents ( ) as $ file ) { if ( $ type === pathinfo ( $ file [ 'filename' ] , PATHINFO_EXTENSION ) ) { $ array [ ] = $ file ; } } return $ array ; }
6752	public static function getCallable ( Logger $ logger , $ type , $ maxMessageLength ) { return function ( MessageInterface $ message ) use ( $ logger , $ type , $ maxMessageLength ) { $ startMessage = null ; if ( $ message instanceof RequestInterface ) { $ startMessage = sprintf ( 'Proxy %s start: HTTP/%s %s %s' , $ type , $ message -> getProtocolVersion ( ) , $ message -> getMethod ( ) , $ message -> getRequestTarget ( ) ) ; } elseif ( $ message instanceof ResponseInterface ) { $ startMessage = sprintf ( 'Proxy %s start: HTTP/%s %s %s' , $ type , $ message -> getProtocolVersion ( ) , $ message -> getStatusCode ( ) , $ message -> getReasonPhrase ( ) ) ; } if ( ! is_null ( $ startMessage ) ) { $ logger -> log ( Logger :: INFO , $ startMessage ) ; } foreach ( $ message -> getHeaders ( ) as $ name => $ value ) { $ logger -> log ( Logger :: INFO , sprintf ( "Proxy %s header: %s => %s" , $ type , $ name , implode ( ', ' , $ value ) ) ) ; } $ body = $ message -> getBody ( ) ; if ( strlen ( $ body ) > $ maxMessageLength ) { $ body = substr ( $ body , 0 , $ maxMessageLength ) . '[TRUNCATED]' ; } $ logger -> log ( Logger :: INFO , sprintf ( "Proxy %s body: %s" , $ type , $ body ) ) ; if ( ! is_null ( $ message ) && $ message -> getBody ( ) -> isSeekable ( ) ) { $ message -> getBody ( ) -> rewind ( ) ; } return $ message ; } ; }
12018	protected function setup ( \ AMQPQueue $ queue ) { $ queue -> declareQueue ( ) ; foreach ( $ this -> binds as $ exchange => $ params ) { $ queue -> bind ( $ exchange , $ params [ 'routing_key' ] , $ params [ 'arguments' ] ) ; } }
5914	public function updateLastLogin ( $ id , $ successful = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'successful' => $ successful ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/accounts/users/' . $ id . '/registerloginattempt' , $ parameters ) ; $ result = new User ( $ result ) ; return $ result ; }
5767	private function create ( ) { $ m = new \ PHPMailer ( ) ; switch ( $ this -> protocol ) { case 'sendmail' : $ m -> isSendmail ( ) ; break ; case 'smtp' : $ m -> isSMTP ( ) ; $ m -> Host = $ this -> smtpHost ; $ m -> SMTPAuth = false ; $ m -> SMTPAutoTLS = false ; $ m -> Port = $ this -> smtpPort ; break ; case 'mail' : $ m -> isMail ( ) ; break ; case 'qmail' : $ m -> isQmail ( ) ; break ; default : throw new \ Exception ( 'bad phpmailerType: ' . $ this -> protocol ) ; } return $ m ; }
12200	public function getData ( $ object ) { if ( ! $ this -> validateObject ( $ object ) ) { throw new InvalidArgumentException ( "Given object isn't instance of {$this->localName}" ) ; } $ reflection = new ReflectionObject ( $ object ) ; $ data = [ ] ; foreach ( array_keys ( $ this -> properties ) as $ localProperty ) { $ property = $ reflection -> getProperty ( $ localProperty ) ; $ property -> setAccessible ( true ) ; $ data [ $ localProperty ] = $ property -> getValue ( $ object ) ; } return $ data ; }
6945	protected function watch ( OrderPaymentInterface $ payment ) { $ order = $ payment -> getOrder ( ) ; if ( ! $ order -> isAutoNotify ( ) || $ order -> isSample ( ) ) { return ; } if ( ! $ payment -> getMethod ( ) -> isManual ( ) ) { return ; } if ( ! $ this -> didStateChangeTo ( $ payment , PaymentStates :: STATE_CAPTURED ) ) { return ; } foreach ( $ order -> getNotifications ( ) as $ n ) { if ( $ n -> getType ( ) !== NotificationTypes :: PAYMENT_CAPTURED ) { continue ; } if ( $ n -> hasData ( 'payment' ) && $ n -> getData ( 'payment' ) === $ payment -> getNumber ( ) ) { return ; } } $ this -> notify ( NotificationTypes :: PAYMENT_CAPTURED , $ payment ) ; }
1575	public function api ( $ apiName = null ) { $ repo = $ this -> container -> make ( Repository :: class ) ; return $ repo -> createApi ( $ apiName ? : $ this -> defaultApi ( ) ) ; }
4951	public function getTargetFQCN ( ) { return is_object ( $ this -> target ) ? get_class ( $ this -> target ) : ( string ) $ this -> target ; }
3227	function buildUrlForGetOrPut ( $ host , $ path , $ params = null ) { return RequestUtil :: buildUrlForGetOrPut ( $ this -> userLocale , $ host , $ path , $ params ) ; }
7519	function parse_doctype ( ) { $ start = $ this -> pos ; if ( $ this -> next_search ( '[>' , false ) === self :: TOK_UNKNOWN ) { if ( $ this -> doc [ $ this -> pos ] === '[' ) { if ( ( $ this -> next_pos ( ']' , false ) !== self :: TOK_UNKNOWN ) || ( $ this -> next_pos ( '>' , false ) !== self :: TOK_UNKNOWN ) ) { $ this -> addError ( 'Invalid doctype' ) ; return false ; } } $ this -> token_start = $ start ; $ this -> status [ 'dtd' ] = $ this -> getTokenString ( 2 , - 1 ) ; $ this -> status [ 'last_pos' ] = $ this -> pos ; return true ; } else { $ this -> addError ( 'Invalid doctype' ) ; return false ; } }
9829	public function getAssociationName ( $ modelName , $ otherModelName ) { return sprintf ( 'auja.%s.%s' , $ this -> toUrlName ( $ modelName ) , $ this -> toUrlName ( $ otherModelName ) ) ; }
1053	public static function buildAST ( DocumentNode $ ast , ? callable $ typeConfigDecorator = null , array $ options = [ ] ) { $ builder = new self ( $ ast , $ typeConfigDecorator , $ options ) ; return $ builder -> buildSchema ( ) ; }
2892	public function onWebsiteRestriction ( Varien_Event_Observer $ observer ) { $ controller = $ observer -> getController ( ) ; $ result = $ observer -> getResult ( ) ; $ helper = Mage :: helper ( 'sheep_debug' ) ; if ( $ helper -> canShowToolbar ( ) && $ controller instanceof Sheep_Debug_Controller_Front_Action ) { $ result -> setShouldProceed ( false ) ; } }
5700	protected function getDefaultButtonList ( $ config ) { $ new = ( $ this -> owner -> ID == 0 ) ; $ list = $ new ? Config :: inst ( ) -> get ( $ config , $ this -> checkVersioned ( ) ? "versioned_create" : "create" ) : Config :: inst ( ) -> get ( $ config , $ this -> checkVersioned ( ) ? "versioned_edit" : "edit" ) ; return $ list ? : array ( ) ; }
9404	protected static function prepare ( Collection & $ collection , $ component ) { $ instance = new $ component ; $ type = $ instance -> type ( ) ; if ( empty ( $ type ) === false ) { $ parameters = array ( $ instance -> get ( ) ) ; $ type === 'http' && $ parameters = $ instance -> get ( ) ; $ class = array ( $ collection , 'set' . ucfirst ( $ type ) ) ; call_user_func_array ( $ class , $ parameters ) ; } return $ instance ; }
1616	public function count ( $ q = '*' , $ db = null ) { if ( $ this -> emulateExecution ) { return 0 ; } if ( $ this -> where === null ) { $ modelClass = $ this -> modelClass ; if ( $ db === null ) { $ db = $ modelClass :: getDb ( ) ; } return $ db -> executeCommand ( 'LLEN' , [ $ modelClass :: keyPrefix ( ) ] ) ; } else { return $ this -> executeScript ( $ db , 'Count' ) ; } }
6881	public function reverseTransform ( $ address ) { if ( null === $ address ) { return null ; } if ( ! $ address instanceof ShipmentAddress ) { throw new InvalidArgumentException ( "Expected instance of " . ShipmentAddress :: class ) ; } $ data = [ ] ; foreach ( $ this -> fields as $ field ) { $ value = $ this -> accessor -> getValue ( $ address , $ field ) ; if ( empty ( $ value ) ) { continue ; } if ( $ value instanceof CountryInterface ) { $ value = $ value -> getId ( ) ; } elseif ( $ value instanceof StateInterface ) { $ value = $ value -> getId ( ) ; } elseif ( $ value instanceof PhoneNumber ) { $ value = serialize ( $ value ) ; } $ data [ $ field ] = $ value ; } if ( empty ( $ data ) ) { return null ; } return $ data ; }
5009	public function setSubject ( $ subject , $ translate = true ) { if ( false !== $ translate ) { $ translator = $ this -> getTranslator ( ) ; $ domain = $ this -> getTranslatorTextDomain ( ) ; if ( true === $ translate ) { $ subject = $ translator -> translate ( $ subject , $ domain ) ; } else { $ args = func_get_args ( ) ; $ args [ 0 ] = $ translator -> translate ( $ args [ 0 ] , $ domain ) ; $ subject = call_user_func_array ( 'sprintf' , $ args ) ; } } return parent :: setSubject ( $ subject ) ; }
9244	private function __loadConfigFiles ( ) { $ additionalConfigs = $ this -> config ( 'additionalConfigFiles' ) ; foreach ( $ additionalConfigs as $ additionalConfig ) { Configure :: load ( $ additionalConfig ) ; } }
3033	public function getSessionDescription ( \ taoQtiTest_helpers_TestSession $ session ) { if ( $ session -> isRunning ( ) ) { $ config = \ common_ext_ExtensionsManager :: singleton ( ) -> getExtensionById ( 'taoQtiTest' ) -> getConfig ( 'testRunner' ) ; $ progressScope = isset ( $ config [ 'progress-indicator-scope' ] ) ? $ config [ 'progress-indicator-scope' ] : 'test' ; $ progress = $ this -> getSessionProgress ( $ session ) ; $ itemPosition = $ progress [ $ progressScope ] ; $ itemCount = $ progress [ $ progressScope . 'Length' ] ; $ format = $ this -> hasOption ( self :: OPTION_STATE_FORMAT ) ? $ this -> getOption ( self :: OPTION_STATE_FORMAT ) : __ ( '%s - item %p/%c' ) ; $ map = array ( '%s' => $ session -> getCurrentAssessmentSection ( ) -> getTitle ( ) , '%p' => $ itemPosition , '%c' => $ itemCount ) ; return strtr ( $ format , $ map ) ; } else { return __ ( 'finished' ) ; } }
9286	public function create ( ) { $ adapter = $ this -> dbAdapter ; $ ddl = new Ddl \ CreateTable ( ) ; $ ddl -> setTable ( self :: TABLE_NAME ) -> addColumn ( new Column \ Integer ( 'id' , false , null , array ( 'autoincrement' => true ) ) ) -> addColumn ( new Column \ Varchar ( 'code' , 55 ) ) -> addColumn ( new Column \ Varchar ( 'status' , 55 ) ) -> addColumn ( new Column \ Text ( 'error_msg' ) ) -> addColumn ( new Column \ Text ( 'stack_trace' ) ) -> addColumn ( new Column \ Varchar ( 'created' , 255 ) ) -> addColumn ( new Column \ Varchar ( 'scheduled' , 255 ) ) -> addColumn ( new Column \ Varchar ( 'executed' , 255 ) ) -> addColumn ( new Column \ Varchar ( 'finished' , 255 ) ) -> addConstraint ( new Constraint \ PrimaryKey ( 'id' ) ) ; $ sql = ( new Sql ( $ adapter ) ) -> getSqlStringForSqlObject ( $ ddl ) ; $ adapter -> query ( $ sql , $ adapter :: QUERY_MODE_EXECUTE ) ; }
11359	public function update ( $ previousPermalink , $ newPermalink ) { $ blocks = $ this -> permalinks [ $ previousPermalink ] ; $ this -> remove ( $ previousPermalink ) ; $ this -> permalinks [ $ newPermalink ] = $ blocks ; return $ this ; }
1398	public function error ( $ error , $ defaultStatusCode = null , array $ headers = [ ] ) { if ( is_string ( $ error ) ) { $ error = $ this -> api -> getErrors ( ) -> error ( $ error ) ; } else if ( is_array ( $ error ) ) { $ error = Error :: create ( $ error ) ; } if ( ! $ error instanceof ErrorInterface ) { throw new \ InvalidArgumentException ( 'Expecting a string, array or error object.' ) ; } return $ this -> errors ( $ error , $ defaultStatusCode , $ headers ) ; }
5964	public function channelGroupGetById ( $ cgid ) { if ( ! array_key_exists ( ( string ) $ cgid , $ this -> channelGroupList ( ) ) ) { throw new Ts3Exception ( "invalid groupID" , 0xA00 ) ; } return $ this -> cgroupList [ intval ( ( string ) $ cgid ) ] ; }
83	private function copyFiles ( $ files , $ source , $ target , $ roles , $ vars ) { foreach ( $ files as $ file ) { $ from = $ this -> combine ( $ source , $ file [ 'from' ] ) ; $ to = $ this -> combine ( $ target , $ roles [ $ file [ 'role' ] ] ) ; $ to = $ this -> combine ( $ to , $ file [ 'to' ] ) ; $ tasks = $ file [ 'tasks' ] ; $ this -> copyFile ( $ from , $ to , $ tasks , $ vars ) ; } }
12506	public static function sendQuery ( ConnectionInterface $ connection ) { $ response = DataLayer :: execute ( $ connection ) ; $ connection -> resetSelf ( ) ; return $ response ; }
7837	public function register ( ) { $ className = studly_case ( strtolower ( config ( 'message.vendor' , 'smsgatewayme' ) ) ) ; $ classPath = '\Yugo\SMSGateway\Vendors\\' . $ className ; if ( ! class_exists ( $ classPath ) ) { abort ( 500 , sprintf ( 'SMS vendor %s is not available.' , $ className ) ) ; } app ( ) -> bind ( SMS :: class , $ classPath ) ; }
10895	public function addCollection ( UriCollection $ collection ) { foreach ( $ collection -> all ( ) as $ name => $ uri ) { unset ( $ this -> uris [ $ name ] ) ; $ this -> uris [ $ name ] = $ uri ; } $ this -> resources = array_merge ( $ this -> resources , $ collection -> getResources ( ) ) ; }
4170	public function prettify ( Collection $ packages ) { $ summary = [ ] ; foreach ( $ packages as $ key => $ package ) { $ summary [ ] = [ 'id' => $ key + 1 , 'name' => $ this -> prettifyPackageInfo ( $ package ) , ] ; } return $ packages [ $ this -> askPackageKey ( $ summary ) ] [ 'name' ] ; }
8362	public static function registerTranslations ( $ baseDir , $ localesDir , $ prefix = null ) { if ( self :: $ isInit === true ) { $ dir = $ baseDir . DIRECTORY_SEPARATOR . $ localesDir ; if ( is_dir ( $ dir ) === false ) { throw new InvalidDirectory ( 'directory "' . $ dir . '" can\'t be identified' ) ; } $ language = self :: $ currentLanguage ; if ( ( $ pos = strpos ( $ language , '-' ) ) !== false ) { $ pos = ( int ) $ pos ; $ language = substr ( $ language , 0 , $ pos ) ; } if ( ( $ pos = strpos ( $ language , '_' ) ) !== false ) { $ pos = ( int ) $ pos ; $ language = substr ( $ language , 0 , $ pos ) ; } if ( is_readable ( $ dir . DIRECTORY_SEPARATOR . $ language . '.yml' ) === true ) { $ newOnes = Config :: get ( $ dir . DIRECTORY_SEPARATOR . $ language . '.yml' ) ; if ( is_array ( $ newOnes ) === true ) { if ( $ prefix != null ) { $ newOnes = array ( $ prefix => $ newOnes ) ; } self :: $ translations = array_merge ( self :: $ translations , $ newOnes ) ; } } else { Logger :: get ( ) -> notice ( 'can\'t find language "' . $ language . '" in directory "' . $ dir . '"' ) ; } } }
6170	protected function onAddError ( \ Exception $ e ) { $ this -> writeProgressWithColor ( 'fg-red,bold' , 'E' ) ; $ this -> exception = $ e ; $ this -> lastTestFailed = true ; $ this -> flawless = false ; }
8213	protected function renderJob ( $ job ) { $ stats = $ this -> getJobStats ( $ job ) ; $ format = '<info>id</info>: %u, <info>length</info>: %u, <info>priority</info>: %u, <info>delay</info>: %u, <info>age</info>: %u, <info>ttr</info>: %u' ; $ line = sprintf ( $ format , $ job -> getId ( ) , strlen ( $ job -> getData ( ) ) , $ stats [ 'pri' ] , $ stats [ 'delay' ] , $ stats [ 'age' ] , $ stats [ 'ttr' ] ) ; $ this -> output -> writeln ( $ line ) ; $ format = '<comment>reserves</comment>: %u, <comment>releases</comment>: %u, <comment>buries</comment>: %u, <comment>kicks</comment>: %u, <comment>timeouts</comment>: %u' ; $ line = sprintf ( $ format , $ stats [ 'reserves' ] , $ stats [ 'releases' ] , $ stats [ 'buries' ] , $ stats [ 'kicks' ] , $ stats [ 'timeouts' ] ) ; $ this -> output -> writeln ( $ line ) ; $ this -> output -> writeln ( '<comment>body:</comment>' ) ; $ data = $ job -> getData ( ) ; $ this -> output -> writeln ( "\"$data\"" ) ; }
2	private function buildDependency10Info ( $ depArray ) { static $ dep10toOperatorMap = array ( 'has' => '==' , 'eq' => '==' , 'ge' => '>=' , 'gt' => '>' , 'le' => '<=' , 'lt' => '<' , 'not' => '!=' ) ; $ result = array ( ) ; foreach ( $ depArray as $ depItem ) { if ( empty ( $ depItem [ 'rel' ] ) || ! array_key_exists ( $ depItem [ 'rel' ] , $ dep10toOperatorMap ) ) { continue ; } $ depType = ! empty ( $ depItem [ 'optional' ] ) && 'yes' == $ depItem [ 'optional' ] ? 'optional' : 'required' ; $ depType = 'not' == $ depItem [ 'rel' ] ? 'conflicts' : $ depType ; $ depVersion = ! empty ( $ depItem [ 'version' ] ) ? $ this -> parseVersion ( $ depItem [ 'version' ] ) : '*' ; $ depVersionConstraint = ( 'has' == $ depItem [ 'rel' ] || 'not' == $ depItem [ 'rel' ] ) && '*' == $ depVersion ? '*' : $ dep10toOperatorMap [ $ depItem [ 'rel' ] ] . $ depVersion ; switch ( $ depItem [ 'type' ] ) { case 'php' : $ depChannelName = 'php' ; $ depPackageName = '' ; break ; case 'pkg' : $ depChannelName = ! empty ( $ depItem [ 'channel' ] ) ? $ depItem [ 'channel' ] : 'pear.php.net' ; $ depPackageName = $ depItem [ 'name' ] ; break ; case 'ext' : $ depChannelName = 'ext' ; $ depPackageName = $ depItem [ 'name' ] ; break ; case 'os' : case 'sapi' : $ depChannelName = '' ; $ depPackageName = '' ; break ; default : $ depChannelName = '' ; $ depPackageName = '' ; break ; } if ( '' != $ depChannelName ) { $ result [ ] = new DependencyConstraint ( $ depType , $ depVersionConstraint , $ depChannelName , $ depPackageName ) ; } } return $ result ; }
9081	private static function parseParameters ( Request & $ req , $ serverVars ) { self :: parseElement ( $ req , $ serverVars , 'HTTP_ACCEPT' , 'Accept' ) ; self :: parseElement ( $ req , $ serverVars , 'HTTP_ACCEPT_LANGUAGE' , 'Accept-Language' ) ; self :: parseElement ( $ req , $ serverVars , 'HTTP_ACCEPT_ENCODING' , 'Accept-Encoding' ) ; self :: parseElement ( $ req , $ serverVars , 'HTTP_UA_CPU' , 'User-Agent-CPU' ) ; self :: parseElement ( $ req , $ serverVars , 'HTTP_USER_AGENT' , 'User-Agent' ) ; self :: parseElement ( $ req , $ serverVars , 'HTTP_HOST' , 'Host' ) ; self :: parseElement ( $ req , $ serverVars , 'HTTP_CACHE_COTROL' , 'Cache-Control' ) ; self :: parseElement ( $ req , $ serverVars , 'HTTP_CONNECTION' , 'Connection' ) ; self :: parseElement ( $ req , $ serverVars , 'HTTP_X_FORWARDED_FOR' , 'X-Forwarded-For' ) ; if ( isset ( $ req -> params [ 'Accept-Language' ] ) ) { $ accepted = explode ( ',' , $ req -> params [ 'Accept-Language' ] ) ; $ req -> params [ 'Accept-Language-Best' ] = $ accepted [ 0 ] ; foreach ( $ accepted as $ acceptedLang ) { $ matches = array ( ) ; if ( preg_match ( "/^((?i)[a-z]{2}[-_](?:[a-z]{2}){1,2}(?:_[a-z]{2})?).*/" , $ acceptedLang , $ matches ) ) { $ req -> params [ 'Accept-Language-Best' ] = $ matches [ 1 ] ; break ; } } } }
788	public function getAttributeHint ( $ attribute ) { $ hints = $ this -> attributeHints ( ) ; return isset ( $ hints [ $ attribute ] ) ? $ hints [ $ attribute ] : '' ; }
11571	public function onBlockEditing ( BlockEditingEvent $ event ) { $ encodedBlock = $ event -> getFileContent ( ) ; $ htmlBlock = $ this -> pageProductionRenderer -> renderBlock ( $ encodedBlock ) ; $ this -> permalinkManager -> add ( $ event -> getFilePath ( ) , $ htmlBlock ) -> save ( ) ; }
11815	protected function step2 ( ) { $ this -> view -> addToBlock ( "form" , "import://admin/setup/requirements" ) ; $ this -> view -> setData ( "step" , "2" ) ; $ this -> view -> setData ( "title" , t ( "Installation | Requirements" ) ) ; $ systemcheck = new Helpers \ Requirements ( ) ; $ requirements = [ ] ; $ directives = require_once ( PATH_CONFIG . '/requirements.inc' ) ; $ server = [ "title" => "Required Server Software" , "tests" => [ ] ] ; foreach ( $ directives [ "server" ] as $ name => $ directive ) { $ server [ "tests" ] [ ] = $ systemcheck -> testServerVersions ( $ name , $ directive ) ; } $ requirements [ ] = $ server ; $ modules = [ "title" => "Required Modules" , "tests" => [ ] ] ; foreach ( $ directives [ "modules" ] as $ name => $ directive ) { $ modules [ "tests" ] [ ] = $ systemcheck -> testModule ( $ name , $ directive ) ; } $ requirements [ ] = $ modules ; $ limits = [ "title" => "Required Resource Limits" , "tests" => [ ] ] ; foreach ( $ directives [ "limits" ] as $ name => $ directive ) { $ limits [ "tests" ] [ ] = $ systemcheck -> testLimit ( $ name , $ directive ) ; } $ requirements [ ] = $ limits ; $ directories = [ "title" => "Required Folder Permissions" , "tests" => [ ] ] ; foreach ( $ directives [ "directories" ] as $ name => $ directive ) { $ directories [ "tests" ] [ ] = $ systemcheck -> testFolderPermissions ( $ directive [ "path" ] , $ directive ) ; } $ requirements [ ] = $ directories ; $ this -> view -> setDataArray ( [ "requirements" => $ requirements ] ) ; return ; }
7410	public function offsetSet ( $ k , $ v ) { if ( null === $ k || ! array_key_exists ( $ k , $ this -> _container ) ) { $ v = ( is_object ( $ v ) && get_class ( $ v ) === $ this -> _type ) ? $ v : new $ this -> _type ( $ v ) ; if ( null === $ k ) { $ this -> _container [ ] = $ v ; } else { $ this -> _container [ $ k ] = $ v ; } return ; } if ( is_a ( $ this -> _type , AtomicInterface :: class , true ) ) { $ this -> _container [ $ k ] -> set ( $ v ) ; return ; } if ( is_a ( $ this -> _type , TypedAbstract :: class , true ) ) { $ this -> _container [ $ k ] -> replace ( $ v ) ; return ; } $ this -> _container [ $ k ] = new $ this -> _type ( $ v ) ; }
4137	protected function processHeaders ( $ headers ) { $ out = array ( ) ; $ headers = explode ( "\r\n" , trim ( $ headers ) ) ; foreach ( $ headers as $ header ) { if ( strpos ( $ header , ':' ) !== false ) { $ tmp = explode ( ':' , $ header ) ; $ out [ reset ( $ tmp ) ] = end ( $ tmp ) ; } else { if ( ! isset ( $ out [ 'http-code' ] ) ) { $ out [ 'http-code' ] = $ header ; } } } unset ( $ headers , $ header , $ tmp ) ; return $ out ; }
5494	public function findFirstAction ( $ parameters ) { $ slot = $ this -> findFirstSlot ( $ parameters ) ; if ( isset ( $ slot ) && isset ( $ slot [ 'content' ] ) ) { return $ slot [ 'content' ] ; } return ; }
5817	public function getFusionTagTypes ( ) { $ types = array ( ) ; $ configuration = Config :: inst ( ) ; $ exclusions = $ configuration -> get ( 'FusionService' , 'tag_type_exclusions' ) ; $ classes = ClassInfo :: subclassesFor ( 'DataObject' ) ; unset ( $ classes [ 'FusionTag' ] ) ; foreach ( $ classes as $ class ) { if ( ( strpos ( strrev ( $ class ) , strrev ( 'Tag' ) ) === 0 ) && ! in_array ( $ class , $ exclusions ) && ! ClassInfo :: classImplements ( $ class , 'TestOnly' ) ) { $ types [ $ class ] = 'Title' ; } } foreach ( $ configuration -> get ( 'FusionService' , 'custom_tag_types' ) as $ type => $ field ) { if ( in_array ( $ type , $ classes ) && ! in_array ( $ type , $ exclusions ) ) { $ types [ $ type ] = $ field ; } } return $ types ; }
7954	public function getSpamStats ( $ ipblock , $ spamstate , $ fromdate , $ todate ) { if ( ! $ ipblock ) throw new BadMethodCallException ( 'Parameter $ipblock is missing.' ) ; if ( ! $ ipv4 ) throw new BadMethodCallException ( 'Parameter $ipv4 is missing.' ) ; if ( ! $ fromdate ) throw new BadMethodCallException ( 'Parameter $fromdate is missing.' ) ; if ( ! $ todate ) throw new BadMethodCallException ( 'Parameter $todate is missing.' ) ; try { $ r = $ this -> get ( 'ip/' . urlencode ( $ ipblock ) . '/spam/' . $ ipv4 . '/stats?from=' . urlencode ( $ fromdate ) . '&to=' . urlencode ( $ todate ) ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new IpException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
12385	public function permalinksByLanguage ( $ language = null ) { $ result = array ( ) ; if ( null === $ language ) { $ language = $ this -> currentLanguage ; } foreach ( $ this -> pages as $ page ) { foreach ( $ page [ "seo" ] as $ pageAttribute ) { if ( $ pageAttribute [ "language" ] != $ language ) { continue ; } $ result [ ] = $ pageAttribute [ "permalink" ] ; } } return $ result ; }
6999	public function getCssClassesForContainer ( ) { $ colsXl = $ this -> getWidth ( ) >= 100 ? 12 : ceil ( 12 * ( $ this -> getWidth ( ) / 100 ) ) ; $ colsXlLeft = floor ( ( 12 - $ colsXl ) / 2 ) ; $ colsLg = $ colsXl >= 10 ? 12 : $ colsXl + 2 ; $ colsLgLeft = floor ( ( 12 - $ colsLg ) / 2 ) ; return "col-xs-12 col-xl-{$colsXl} col-lg-{$colsLg} col-xl-offset-{$colsXlLeft} col-lg-offset-{$colsLgLeft}" ; }
8856	public function increase ( ) { $ this -> retries ++ ; if ( $ this -> retries > $ this -> maxRetries ) { throw new MaxRetriesExceededException ( sprintf ( 'Max allowed retries exceeded. Allowed: %s. Tried: %s.' , $ this -> maxRetries , $ this -> retries ) ) ; } return $ this ; }
11229	public function init ( ) { $ this -> pluginClient = new PluginClient ( $ this -> httpClient ? : HttpClientDiscovery :: find ( ) , $ this -> plugins ) ; $ this -> client = new HttpMethodsClient ( $ this -> pluginClient , $ this -> messageFactory ? : MessageFactoryDiscovery :: find ( ) ) ; }
2181	private function filterNestedPaths ( Finder $ finder , string $ prepend ) : array { $ parents = [ ] ; $ files = iterator_to_array ( $ finder ) ; foreach ( $ files as $ key => $ file ) { $ path = rtrim ( strtr ( $ prepend . '/' . $ file -> getRelativePath ( ) , '\\' , '/' ) , '/' ) ; if ( ! empty ( $ parents ) ) { $ parent = \ dirname ( $ path ) ; while ( false !== strpos ( $ parent , '/' ) ) { if ( \ in_array ( $ parent , $ parents , true ) ) { $ this -> rows [ ] = [ sprintf ( '<fg=yellow;options=bold>%s</>' , '\\' === \ DIRECTORY_SEPARATOR ? 'WARNING' : '!' ) , $ this -> webDir . '/' . $ path , sprintf ( '<comment>Skipped because %s will be symlinked.</comment>' , $ parent ) , ] ; unset ( $ files [ $ key ] ) ; break ; } $ parent = \ dirname ( $ parent ) ; } } $ parents [ ] = $ path ; } return array_values ( $ files ) ; }
6721	private function handleTokenResponse ( $ response ) { $ params = ( $ response instanceof OAuthToken ) ? $ response -> getParams ( ) : $ response ; $ status = ArrayHelper :: getValue ( $ params , 'status' ) ; if ( ! is_null ( $ status ) && $ status == 'success' ) { $ token = ArrayHelper :: getValue ( $ params , 'data' ) ; if ( is_null ( $ token ) ) { throw new Oauth2ClientException ( self :: CODE_NOT_SET ) ; } return $ token ; } else { $ message = ArrayHelper :: getValue ( $ params , 'message' , self :: DEFAULT_ERROR ) ; throw new Oauth2ClientException ( $ message ) ; } }
8542	public function setPluralForm ( $ key , $ plural ) { if ( ! is_array ( $ plural ) ) $ plural = [ $ plural ] ; if ( ! $ this -> msgstr_plural ) $ this -> msgstr_plural = [ ] ; $ this -> msgstr_plural [ $ key ] = $ plural ; }
6272	public static function open ( $ fileName ) { return self :: haveExtension ( ) ? new Reader \ DBA ( $ fileName ) : new Reader \ PHP ( $ fileName ) ; }
10529	protected function normalizeProxyHeader ( $ header ) { $ header = strtoupper ( $ header ) ; $ header = str_replace ( '-' , '_' , $ header ) ; if ( 0 !== strpos ( $ header , 'HTTP_' ) ) { $ header = 'HTTP_' . $ header ; } return $ header ; }
9231	public function actionIndex ( $ format = false , $ arraymap = false , $ term = false , $ category = false , $ time = false ) { $ searchModel = new PostSearch ( ) ; $ req = Yii :: $ app -> request -> queryParams ; if ( $ term ) { $ req [ basename ( str_replace ( "\\" , "/" , get_class ( $ searchModel ) ) ) ] [ "term" ] = $ term ; } if ( $ category ) { $ req [ basename ( str_replace ( "\\" , "/" , get_class ( $ searchModel ) ) ) ] [ "category" ] = $ category ; } if ( $ time ) { $ req [ basename ( str_replace ( "\\" , "/" , get_class ( $ searchModel ) ) ) ] [ "time" ] = $ time ; } $ dataProvider = $ searchModel -> search ( $ req ) ; $ query = $ dataProvider -> query ; $ query -> andWhere ( [ 'status' => [ 1 ] ] ) ; if ( $ format == 'json' ) { $ model = [ ] ; foreach ( $ dataProvider -> getModels ( ) as $ d ) { $ obj = $ d -> attributes ; if ( $ arraymap ) { $ map = explode ( "," , $ arraymap ) ; if ( count ( $ map ) == 1 ) { $ obj = ( isset ( $ d [ $ arraymap ] ) ? $ d [ $ arraymap ] : null ) ; } else { $ obj = [ ] ; foreach ( $ map as $ a ) { $ k = explode ( ":" , $ a ) ; $ v = ( count ( $ k ) > 1 ? $ k [ 1 ] : $ k [ 0 ] ) ; $ obj [ $ k [ 0 ] ] = ( $ v == "Obj" ? json_encode ( $ d -> attributes ) : ( isset ( $ d -> $ v ) ? $ d -> $ v : null ) ) ; } } } if ( $ term ) { if ( ! in_array ( $ obj , $ model ) ) { array_push ( $ model , $ obj ) ; } } else { array_push ( $ model , $ obj ) ; } } header ( "Access-Control-Allow-Origin: *" ) ; header ( "Access-Control-Expose-Headers: X-Pagination-Per-Page,X-Pagination-Current-Page,X-Pagination-Page-Count,X-Pagination-Total-Count,Content-Type,Location" ) ; return \ yii \ helpers \ Json :: encode ( $ model ) ; } else { return $ this -> render ( 'index' , [ 'searchModel' => $ searchModel , 'dataProvider' => $ dataProvider , ] ) ; } }
729	protected function addDefaultPrimaryKey ( & $ fields ) { foreach ( $ fields as $ field ) { if ( false !== strripos ( $ field [ 'decorators' ] , 'primarykey()' ) ) { return ; } } array_unshift ( $ fields , [ 'property' => 'id' , 'decorators' => 'primaryKey()' ] ) ; }
10715	public function update ( Model $ model , array $ newAttributes ) { $ results = $ model -> update ( $ newAttributes ) ; if ( ! $ results ) { throw new UpdateFailedRepositoryException ( ) ; } return $ model ; }
7438	public static function handleException ( \ Throwable $ e ) { self :: render ( $ e -> getCode ( ) , $ e -> getMessage ( ) , $ e -> getFile ( ) , $ e -> getLine ( ) , null , $ e -> getTrace ( ) , get_class ( $ e ) ) ; }
11399	public function getCustomFieldByType ( $ type ) { if ( isset ( $ this -> servicesByType [ $ type ] ) ) { return $ this -> servicesByType [ $ type ] ; } else { throw new \ LogicException ( 'the custom field with type ' . $ type . ' ' . 'is not found' ) ; } }
4670	protected function afterGeneration ( ) { $ this -> mapTemplate -> writeToFile ( ) ; $ this -> autoloadMap -> writeToFile ( ) ; $ responseParserTemplate = new ResponseParserTemplate ( $ this -> config ) ; $ this -> autoloadMap -> addEntry ( $ responseParserTemplate -> getClassName ( ) , $ responseParserTemplate -> getClassPath ( ) ) ; $ responseParserTemplate -> writeToFile ( ) ; }
7203	public function addDiscountAdjustment ( Adjustment $ discount ) : void { foreach ( $ this -> discounts as $ d ) { if ( $ d -> isSameAs ( $ discount ) ) { $ d -> addAmount ( $ discount -> getAmount ( ) ) ; return ; } } $ this -> discounts [ ] = clone $ discount ; }
2334	public function onSwitchUser ( SwitchUserEvent $ event ) : void { $ token = $ this -> tokenStorage -> getToken ( ) ; if ( null === $ token ) { throw new \ RuntimeException ( 'The token storage did not contain a token.' ) ; } $ sourceUser = $ token -> getUser ( ) ; if ( $ sourceUser instanceof UserInterface ) { $ sourceUser = $ sourceUser -> getUsername ( ) ; } $ targetUser = $ event -> getTargetUser ( ) ; if ( $ targetUser instanceof UserInterface ) { $ targetUser = $ targetUser -> getUsername ( ) ; } $ this -> logger -> info ( sprintf ( 'User "%s" has switched to user "%s"' , $ sourceUser , $ targetUser ) , [ 'contao' => new ContaoContext ( __METHOD__ , ContaoContext :: ACCESS , $ sourceUser ) ] ) ; }
6714	public function getRequestChain ( ) { if ( is_null ( $ this -> requestChain ) ) { $ this -> requestChain = $ this -> getRequestChainFromUri ( $ this -> requestedUri ) ; } return $ this -> requestChain ; }
7264	private function validateItem ( SaleItemInterface $ item ) { foreach ( $ item -> getChildren ( ) as $ child ) { $ this -> validateItem ( $ child ) ; } if ( $ item -> isCompound ( ) ) { return ; } if ( null === $ subject = $ this -> subjectHelper -> resolve ( $ item , false ) ) { return ; } if ( ! $ subject instanceof StockSubjectInterface ) { return ; } $ quantity = $ item -> getTotalQuantity ( ) ; $ availability = $ this -> availabilityHelper -> getAvailability ( $ subject , is_null ( $ item -> getParent ( ) ) ) ; if ( $ quantity < $ availability -> getMinimumQuantity ( ) ) { $ message = $ availability -> getMinimumMessage ( ) ; } elseif ( $ quantity > $ availability -> getMaximumQuantity ( ) ) { $ message = $ availability -> getMaximumMessage ( ) ; } else { return ; } if ( null !== $ item -> getParent ( ) ) { $ message = $ item -> getDesignation ( ) . ' : ' . $ message ; } throw new ValidationFailedException ( $ message ) ; }
1196	protected function renderHtmlAttribute ( $ name , $ value ) { if ( true === $ value ) { return sprintf ( '%s="%s"' , $ name , $ this -> escape ( $ name ) ) ; } return sprintf ( '%s="%s"' , $ name , $ this -> escape ( $ value ) ) ; }
9816	public function writeRawData ( $ text ) { if ( is_array ( $ text ) ) { $ text = implode ( "\n" , $ text ) ; } return $ this -> writeRaw ( htmlspecialchars ( $ text ) ) ; }
11804	public function isRelation ( $ key ) { if ( ! method_exists ( $ this -> model , $ key ) ) { return false ; } $ relation = $ this -> model -> { $ key } ( ) ; return ( $ relation instanceof Relation ) ; }
3053	public function getCatEngine ( RouteItem $ routeItem = null ) { $ compiledDirectory = $ this -> getCompilationDirectory ( ) [ 'private' ] ; $ adaptiveSectionMap = $ this -> getServiceManager ( ) -> get ( CatService :: SERVICE_ID ) -> getAdaptiveSectionMap ( $ compiledDirectory ) ; $ routeItem = $ routeItem ? $ routeItem : $ this -> getTestSession ( ) -> getRoute ( ) -> current ( ) ; $ sectionId = $ routeItem -> getAssessmentSection ( ) -> getIdentifier ( ) ; $ catEngine = false ; if ( isset ( $ adaptiveSectionMap [ $ sectionId ] ) ) { $ catEngine = $ this -> getServiceManager ( ) -> get ( CatService :: SERVICE_ID ) -> getEngine ( $ adaptiveSectionMap [ $ sectionId ] [ 'endpoint' ] ) ; } return $ catEngine ; }
1463	private function guessColumn ( ) { if ( $ this -> query instanceof EloquentBuilder || $ this -> query instanceof Relation ) { return $ this -> query -> getModel ( ) -> getCreatedAtColumn ( ) ; } return Model :: CREATED_AT ; }
4694	public function addOrderBy ( string $ expression , ... $ args ) : self { $ this -> dirty ( ) ; $ this -> order [ ] = $ expression ; $ this -> pushArgs ( 'order' , $ args ) ; return $ this ; }
1434	public static function decamelize ( $ value ) { if ( isset ( self :: $ decamelized [ $ value ] ) ) { return self :: $ decamelized [ $ value ] ; } return self :: $ decamelized [ $ value ] = strtolower ( preg_replace ( '/(.)(?=[A-Z])/u' , '$1_' , $ value ) ) ; }
9542	public function runSyncAction ( $ syncActionBaseUrl , $ component , $ action , array $ configData ) { $ uriParts = [ ] ; if ( $ this -> super ) { $ uriParts [ ] = $ this -> super ; } $ uriParts [ ] = $ component ; $ uriParts [ ] = 'action' ; $ uriParts [ ] = $ action ; $ uri = rtrim ( $ syncActionBaseUrl , '/' ) . '/' . implode ( '/' , $ uriParts ) ; $ body = [ 'configData' => $ configData , ] ; try { $ request = new Request ( 'POST' , $ uri , [ ] , json_encode ( $ body ) ) ; $ response = $ this -> guzzle -> send ( $ request ) ; } catch ( RequestException $ e ) { throw new ClientException ( $ e -> getMessage ( ) , 0 , $ e ) ; } return $ this -> decodeResponse ( $ response ) ; }
8823	public function rule ( $ field , $ label , $ rules , array $ text = [ ] ) { $ this -> labels [ $ field ] = $ label ; $ this -> rules [ $ field ] = $ rules ; $ this -> texts [ $ field ] = ( ! empty ( $ text ) ? $ text : null ) ; }
8756	public static function build ( array $ subscribers = [ ] , $ totalItems = self :: UNKNOWN ) { $ that = new static ( $ totalItems ) ; foreach ( $ subscribers as $ subscriber ) { $ that -> addSubscriber ( $ subscriber ) ; } return $ that ; }
7896	public function from ( $ provider = null ) { $ provider = $ provider ? : $ this -> getDefaultProvider ( ) ; return new Uploader ( $ this -> app -> make ( 'config' ) , $ this -> app -> make ( 'filesystem' ) , $ this -> createProviderInstance ( $ provider ) ) ; }
9616	public function registerCommands ( array $ commands , callable $ handler ) { foreach ( $ commands as $ command ) { $ handler_id = "app.handler." . join ( '' , array_slice ( explode ( "\\" , $ command ) , - 1 ) ) ; $ this [ $ handler_id ] = $ handler ; } }
3926	public function encodeValue ( EncodePropertyValueFromWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } if ( is_array ( $ event -> getValue ( ) ) ) { $ values = [ ] ; foreach ( $ event -> getValue ( ) as $ value ) { $ values [ ] = substr ( $ value , 6 ) ; } $ event -> setValue ( $ values ) ; } else { $ event -> setValue ( substr ( $ event -> getValue ( ) , 6 ) ) ; } }
7437	public static function handleFatal ( ) { $ error = error_get_last ( ) ; if ( null !== $ error ) { self :: render ( $ error [ "type" ] , $ error [ "message" ] , $ error [ "file" ] , $ error [ "line" ] ) ; } }
5893	public function listAudioTemplates ( CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/templates/audio' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new AudioTemplate ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
5347	public function revertSnapshotToOtherVps ( $ sourceVpsName , $ snapshotName , $ destinationVpsName ) { return $ this -> call ( self :: SERVICE , 'revertSnapshotToOtherVps' , [ $ sourceVpsName , $ snapshotName , $ destinationVpsName ] ) ; }
1840	public static function countBy ( $ strColumn = null , $ varValue = null , array $ arrOptions = array ( ) ) { if ( static :: $ strTable == '' ) { return 0 ; } $ arrOptions = array_merge ( array ( 'table' => static :: $ strTable , 'column' => $ strColumn , 'value' => $ varValue ) , $ arrOptions ) ; $ strQuery = static :: buildCountQuery ( $ arrOptions ) ; return ( int ) Database :: getInstance ( ) -> prepare ( $ strQuery ) -> execute ( $ arrOptions [ 'value' ] ) -> count ; }
6726	public function get_movie_votes ( $ post_id ) { $ votes = get_post_meta ( $ post_id , 'imdbTotalVotes' , true ) ; if ( ! empty ( $ votes ) ) { return json_decode ( $ votes , true ) ; } return false ; }
10408	public function addDocumentParameter ( $ field , $ value ) { $ this -> documentParamCache [ md5 ( $ value . $ field ) ] = [ $ field , $ value ] ; }
804	private function hasReturnTypeHint ( Tokens $ tokens , $ index ) { $ endFuncIndex = $ tokens -> getPrevTokenOfKind ( $ index , [ ')' ] ) ; $ nextIndex = $ tokens -> getNextMeaningfulToken ( $ endFuncIndex ) ; return $ tokens [ $ nextIndex ] -> isGivenKind ( CT :: T_TYPE_COLON ) ; }
9305	public function setEmitEvents ( $ emitEvents ) { if ( ! is_bool ( $ emitEvents ) ) { throw new \ InvalidArgumentException ( '`emitEvents` expects boolean value!' ) ; } $ this -> options [ 'emitEvents' ] = ( bool ) $ emitEvents ; return $ this ; }
1452	protected function createValidator ( array $ data , array $ rules , array $ messages = [ ] , array $ customAttributes = [ ] ) : ValidatorInterface { return $ this -> factory -> createDeleteValidator ( $ data , $ rules , $ messages , $ customAttributes ) ; }
11518	protected function GenerateHTML5Favicon ( SiteTree $ owner , & $ metadata , Image $ HTML5Favicon ) { $ metadata .= $ owner -> MarkupComment ( 'HTML5 Favicon' ) ; $ metadata .= $ owner -> MarkupLink ( 'icon' , $ HTML5Favicon -> Fill ( 192 , 192 ) -> getAbsoluteURL ( ) , 'image/png' , '192x192' ) ; $ metadata .= $ owner -> MarkupLink ( 'icon' , $ HTML5Favicon -> Fill ( 128 , 128 ) -> getAbsoluteURL ( ) , 'image/png' , '128x128' ) ; $ metadata .= $ owner -> MarkupLink ( 'icon' , $ HTML5Favicon -> Fill ( 96 , 96 ) -> getAbsoluteURL ( ) , 'image/png' , '96x96' ) ; $ metadata .= $ owner -> MarkupLink ( 'icon' , $ HTML5Favicon -> Fill ( 32 , 32 ) -> getAbsoluteURL ( ) , 'image/png' , '32x32' ) ; $ metadata .= $ owner -> MarkupLink ( 'icon' , $ HTML5Favicon -> Fill ( 16 , 16 ) -> getAbsoluteURL ( ) , 'image/png' , '16x16' ) ; }
1593	protected function validateTypeAndId ( ) : bool { if ( ! ( $ this -> validateType ( ) && $ this -> validateId ( ) ) ) { return false ; } $ type = $ this -> dataGet ( 'type' ) ; $ id = $ this -> dataGet ( 'id' ) ; if ( $ id && ! $ this -> isNotFound ( $ type , $ id ) ) { $ this -> resourceExists ( $ type , $ id ) ; return false ; } return true ; }
11318	public function getBaseData ( ) { $ data = new FluidXml ( false ) ; $ message = $ data -> addChild ( 'Message' , [ 'version' => $ this -> getApiVersion ( ) ] , true ) ; $ header = $ message -> addChild ( 'Header' , true ) ; $ header -> addChild ( 'Time' , $ this -> getTime ( ) ) ; $ itentity = $ header -> addChild ( 'Identity' , true ) ; $ itentity -> addChild ( 'UserID' , $ this -> getUserId ( ) ) ; $ body = $ message -> addChild ( 'Body' , [ 'type' => 'GetInvoice' , 'live' => $ this -> getLive ( ) ] , true ) ; $ order = $ body -> addChild ( 'Order' , [ 'paymentMethod' => $ this -> getPaymentMethod ( ) ] , true ) ; $ order -> addChild ( 'MerchantID' , $ this -> getMerchantId ( ) ) ; $ order -> addChild ( 'SiteAddress' , $ this -> getSiteAddress ( ) ) ; $ order -> addChild ( 'PostbackURL' , $ this -> getNotifyUrl ( ) ) ; $ order -> addChild ( 'SuccessURL' , $ this -> getReturnUrl ( ) ) ; $ order -> addChild ( 'FailureURL' , $ this -> getCancelUrl ( ) ) ; return $ message ; }
5687	public function getFormBySubmit ( $ selector ) { for ( $ i = 0 ; $ i < count ( $ this -> forms ) ; $ i ++ ) { if ( $ this -> forms [ $ i ] -> hasSubmit ( $ selector ) ) { return $ this -> forms [ $ i ] ; } } return ; }
2217	public function getChannels ( ) { if ( ! $ this -> User -> isAdmin && ! \ is_array ( $ this -> User -> newsletters ) ) { return array ( ) ; } $ arrChannels = array ( ) ; $ objChannels = $ this -> Database -> execute ( "SELECT id, title FROM tl_newsletter_channel ORDER BY title" ) ; while ( $ objChannels -> next ( ) ) { if ( $ this -> User -> hasAccess ( $ objChannels -> id , 'newsletters' ) ) { $ arrChannels [ $ objChannels -> id ] = $ objChannels -> title ; } } return $ arrChannels ; }
10853	public function setLimit ( $ num , $ offset = 0 ) { $ this -> limit = ( int ) $ num ; $ this -> offset = ( int ) $ offset ; }
12527	public function getDataSources ( ) { if ( is_null ( $ this -> _dataSources ) ) { $ this -> _dataSources = [ ] ; foreach ( $ this -> dataSources ( ) as $ foreignModel => $ dataSource ) { if ( is_numeric ( $ foreignModel ) || isset ( $ dataSources [ 'foreignModel' ] ) ) { if ( ! isset ( $ dataSources [ 'foreignModel' ] ) ) { continue ; } $ foreignModel = $ dataSources [ 'foreignModel' ] ; unset ( $ dataSources [ 'foreignModel' ] ) ; } if ( ! isset ( $ dataSource [ 'class' ] ) ) { $ dataSource [ 'class' ] = $ this -> dataSourceClass ; } $ dataSource [ 'name' ] = $ foreignModel ; $ dataSource [ 'foreignModel' ] = $ this -> getForeignModel ( $ foreignModel ) ; if ( empty ( $ dataSource [ 'foreignModel' ] ) ) { continue ; } $ this -> _dataSources [ $ foreignModel ] = Yii :: createObject ( array_merge ( [ 'module' => $ this ] , $ dataSource ) ) ; } } return $ this -> _dataSources ; }
3262	public static function callback ( $ order , $ transaction , $ status , $ data = null ) { $ statusCode = $ order -> statusCode ; try { if ( in_array ( $ status , [ 'success' , 'fail' ] ) ) { static :: $ gatewayKey = $ transaction -> gateway ; static :: $ gateway = static :: instanceGateway ( ) ; if ( $ status == 'success' ) { static :: $ gateway -> onCallbackSuccess ( $ order , $ data ) ; $ order -> statusCode = static :: $ gateway -> getTransactionStatusCode ( ) ; $ order -> placeTransaction ( static :: $ gatewayKey , static :: $ gateway -> getTransactionId ( ) , static :: $ gateway -> getTransactionDetail ( ) , static :: $ gateway -> getTransactionToken ( ) ) ; if ( $ order -> isCompleted ) \ event ( new OrderCompleted ( $ order -> id ) ) ; } else if ( $ status == 'fail' ) { static :: $ gateway -> onCallbackFail ( $ order , $ data ) ; $ order -> statusCode = 'failed' ; } $ order -> save ( ) ; } } catch ( ShopException $ e ) { static :: setException ( $ e ) ; $ order -> statusCode = 'failed' ; $ order -> save ( ) ; } catch ( GatewayException $ e ) { static :: setException ( $ e ) ; $ order -> statusCode = 'failed' ; $ order -> save ( ) ; } static :: checkStatusChange ( $ order , $ statusCode ) ; }
5249	public function save ( $ child ) { $ children = ! is_array ( $ child ) ? [ $ child ] : $ child ; foreach ( $ children as $ child ) { $ child -> setParent ( $ this -> parent ) ; $ child -> save ( ) ; } }
5655	public function parse ( $ response ) { $ this -> page = new SimplePage ( $ response ) ; $ tidied = tidy_parse_string ( $ input = $ this -> insertGuards ( $ response -> getContent ( ) ) , array ( 'output-xml' => false , 'wrap' => '0' , 'indent' => 'no' ) , 'latin1' ) ; $ this -> walkTree ( $ tidied -> html ( ) ) ; $ this -> attachLabels ( $ this -> widgets_by_id , $ this -> labels ) ; $ this -> page -> setForms ( $ this -> forms ) ; $ page = $ this -> page ; $ this -> free ( ) ; return $ page ; }
11504	public function setSlots ( $ first , $ last , $ connection ) { if ( ! static :: isValidRange ( $ first , $ last ) ) { throw new \ OutOfBoundsException ( "Invalid slot range $first-$last for `$connection`" ) ; } $ this -> slots += array_fill ( $ first , $ last - $ first + 1 , ( string ) $ connection ) ; }
12634	public function reverse ( $ orderNo , $ type = self :: OUT_TRADE_NO ) { $ params = [ $ type => $ orderNo , ] ; return $ this -> safeRequest ( $ this -> wrapApi ( self :: API_REVERSE ) , $ params ) ; }
6686	public function showFlashMessages ( $ sticky = false ) { $ timeout = $ sticky ? 0 : 5000 ; $ flashMessages = [ ] ; $ allMessages = $ this -> getSession ( ) -> getAllFlashes ( ) ; foreach ( $ allMessages as $ key => $ message ) { if ( is_array ( $ message ) ) { $ message = $ this -> mergeFlashMessages ( $ message ) ; } $ flashMessages [ ] = [ 'message' => $ message , 'type' => $ key , 'timeout' => $ timeout ] ; } $ this -> getSession ( ) -> removeAllFlashes ( ) ; return Html :: script ( 'var notifications =' . json_encode ( $ flashMessages ) ) ; }
5575	public function clickSubmitByName ( $ name , $ additional = false ) { if ( ! ( $ form = $ this -> page -> getFormBySubmit ( new SelectByName ( $ name ) ) ) ) { return false ; } $ success = $ this -> load ( $ form -> getAction ( ) , $ form -> submitButton ( new SelectByName ( $ name ) , $ additional ) ) ; return ( $ success ? $ this -> getContent ( ) : $ success ) ; }
2678	public function updateAclItem ( $ aclId , $ aclItemId , $ itemValue , $ negated , $ comment = '' , $ subnet = false ) { $ body = [ 'ip' => $ itemValue , 'negated' => $ negated , 'comment' => $ comment ] ; if ( $ subnet ) { $ body [ 'subnet' ] = $ subnet ; } $ url = $ this -> _getApiServiceUri ( ) . 'acl/' . $ aclId . '/entry/' . $ aclItemId ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: PATCH , json_encode ( $ body ) ) ; return $ result ; }
9951	public function duplicateConditionalStyle ( array $ pCellStyle , $ pRange = '' ) { foreach ( $ pCellStyle as $ cellStyle ) { if ( ! ( $ cellStyle instanceof Conditional ) ) { throw new Exception ( 'Style is not a conditional style' ) ; } } list ( $ rangeStart , $ rangeEnd ) = Coordinate :: rangeBoundaries ( $ pRange . ':' . $ pRange ) ; if ( $ rangeStart [ 0 ] > $ rangeEnd [ 0 ] && $ rangeStart [ 1 ] > $ rangeEnd [ 1 ] ) { $ tmp = $ rangeStart ; $ rangeStart = $ rangeEnd ; $ rangeEnd = $ tmp ; } for ( $ col = $ rangeStart [ 0 ] ; $ col <= $ rangeEnd [ 0 ] ; ++ $ col ) { for ( $ row = $ rangeStart [ 1 ] ; $ row <= $ rangeEnd [ 1 ] ; ++ $ row ) { $ this -> setConditionalStyles ( Coordinate :: stringFromColumnIndex ( $ col ) . $ row , $ pCellStyle ) ; } } return $ this ; }
2155	public function getSearchablePages ( $ arrPages , $ intRoot = 0 , $ blnIsSitemap = false ) { $ arrRoot = array ( ) ; if ( $ intRoot > 0 ) { $ arrRoot = $ this -> Database -> getChildRecords ( $ intRoot , 'tl_page' ) ; } $ arrProcessed = array ( ) ; $ time = Date :: floorToMinute ( ) ; $ objNewsletter = NewsletterChannelModel :: findAll ( ) ; if ( $ objNewsletter !== null ) { while ( $ objNewsletter -> next ( ) ) { if ( ! $ objNewsletter -> jumpTo ) { continue ; } if ( ! empty ( $ arrRoot ) && ! \ in_array ( $ objNewsletter -> jumpTo , $ arrRoot ) ) { continue ; } if ( ! isset ( $ arrProcessed [ $ objNewsletter -> jumpTo ] ) ) { $ objParent = PageModel :: findWithDetails ( $ objNewsletter -> jumpTo ) ; if ( $ objParent === null ) { continue ; } if ( ! $ objParent -> published || ( $ objParent -> start != '' && $ objParent -> start > $ time ) || ( $ objParent -> stop != '' && $ objParent -> stop <= ( $ time + 60 ) ) ) { continue ; } if ( $ blnIsSitemap ) { if ( $ objParent -> protected ) { continue ; } if ( $ objParent -> sitemap == 'map_never' ) { continue ; } } $ arrProcessed [ $ objNewsletter -> jumpTo ] = $ objParent -> getAbsoluteUrl ( Config :: get ( 'useAutoItem' ) ? '/%s' : '/items/%s' ) ; } $ strUrl = $ arrProcessed [ $ objNewsletter -> jumpTo ] ; $ objItem = NewsletterModel :: findSentByPid ( $ objNewsletter -> id ) ; if ( $ objItem !== null ) { while ( $ objItem -> next ( ) ) { $ arrPages [ ] = sprintf ( preg_replace ( '/%(?!s)/' , '%%' , $ strUrl ) , ( $ objItem -> alias ? : $ objItem -> id ) ) ; } } } } return $ arrPages ; }
6293	private function scanThemes ( ) { $ themeDirectories = glob ( $ this -> basePath . '/*' , GLOB_ONLYDIR ) ; $ themes = [ ] ; foreach ( $ themeDirectories as $ themePath ) { $ json = $ themePath . '/theme.json' ; if ( file_exists ( $ json ) ) { $ contents = file_get_contents ( $ json ) ; if ( ! $ contents === false ) { $ th = $ this -> parseThemeInfo ( json_decode ( $ contents , true ) ) ; $ themes [ $ th -> getDirectory ( ) ] = $ th ; } } } $ this -> themes = $ themes ; if ( count ( $ themes ) && ! $ this -> activeTheme ) { $ this -> set ( array_keys ( $ themes ) [ 0 ] ) ; } }
5275	public function having ( $ column , $ param1 = null , $ param2 = null ) { $ this -> statements [ 'having' ] = $ this -> generateWhere ( $ column , $ param1 , $ param2 , 'having' ) ; return $ this ; }
679	protected function validateCondition ( $ condition ) { if ( ! is_array ( $ condition ) ) { $ this -> addError ( $ this -> filterAttributeName , $ this -> parseErrorMessage ( 'invalidFilter' ) ) ; return ; } if ( empty ( $ condition ) ) { return ; } foreach ( $ condition as $ key => $ value ) { $ method = 'validateAttributeCondition' ; if ( isset ( $ this -> filterControls [ $ key ] ) ) { $ controlKey = $ this -> filterControls [ $ key ] ; if ( isset ( $ this -> conditionValidators [ $ controlKey ] ) ) { $ method = $ this -> conditionValidators [ $ controlKey ] ; } } $ this -> $ method ( $ key , $ value ) ; } }
4614	public function withRangeValue ( $ lowerBound , $ upperBound ) { $ this -> lowerBound = $ lowerBound ; $ this -> upperBound = $ upperBound ; $ this -> match = null ; return $ this ; }
7784	public function addParser ( $ name , $ class , $ before = null ) { if ( $ before === null ) { $ this -> parsers [ $ name ] = $ class ; return $ this ; } if ( ( $ offset = array_search ( $ before , array_keys ( $ this -> parsers ) ) ) !== false ) { $ this -> parsers = array_slice ( $ this -> parsers , 0 , $ offset , true ) + array ( $ name => $ class ) + array_slice ( $ this -> parsers , $ offset , null , true ) ; return $ this ; } throw new \ RuntimeException ( sprintf ( 'Parser "%s" does not exist.' , $ before ) ) ; }
2690	public function getResizedImageInfo ( ) { if ( $ this -> isFastlyImageOptimizationEnabled ( ) == false ) { return parent :: getResizedImageInfo ( ) ; } if ( $ this -> getBaseFile ( ) !== null ) { return [ 0 => $ this -> getWidth ( ) , 1 => $ this -> getHeight ( ) ] ; } $ asset = $ this -> _assetRepo -> createAsset ( "Magento_Catalog::images/product/placeholder/{$this->getDestinationSubdir()}.jpg" ) ; $ img = $ asset -> getSourceFile ( ) ; $ imageInfo = getimagesize ( $ img ) ; $ this -> setWidth ( $ imageInfo [ 0 ] ) ; $ this -> setHeight ( $ imageInfo [ 1 ] ) ; return $ imageInfo ; }
10801	public function renderPageHistoricContentFiltersActionsAction ( ) { $ melisPageHistoricTable = $ this -> getServiceLocator ( ) -> get ( 'MelisPagehistoricTable' ) ; $ actions = $ melisPageHistoricTable -> getPageHistoricListOfActions ( ) -> toArray ( ) ; $ translator = $ this -> getServiceLocator ( ) -> get ( 'translator' ) ; $ options = '<option value="">' . $ translator -> translate ( 'tr_melispagehistoric_filter_action_select' ) . '</option>' ; foreach ( $ actions as $ action ) { $ options .= '<option value="' . $ action [ 'action' ] . '">' . $ action [ 'action' ] . '</option>' ; } $ view = new ViewModel ( ) ; $ view -> options = $ options ; return $ view ; }
6841	public function getCache ( $ key ) { return isset ( $ this -> caches [ $ key ] ) ? $ this -> caches [ $ key ] : null ; }
5069	public function infoRead ( int & $ msgsInQueue = null ) : ? CurlMultiInfoInterface { $ info = curl_multi_info_read ( $ this -> mh , $ msgsInQueue ) ; if ( ! $ info ) { return null ; } return new CurlMultiInfo ( $ info ) ; }
9129	public function setInterceptor ( StreamInterceptor $ interceptor ) { $ this -> interceptor = $ interceptor ; stream_filter_append ( $ this -> stdout , $ interceptor -> getFilterName ( ) ) ; }
2287	public static function findActiveByEmailAndUsername ( $ strEmail , $ strUsername = null , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ time = Date :: floorToMinute ( ) ; $ arrColumns = array ( "$t.email=? AND $t.login='1' AND ($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.disable=''" ) ; if ( $ strUsername !== null ) { $ arrColumns [ ] = "$t.username=?" ; } return static :: findOneBy ( $ arrColumns , array ( $ strEmail , $ strUsername ) , $ arrOptions ) ; }
5566	public function get ( $ url , $ parameters = false ) { if ( ! is_object ( $ url ) ) { $ url = new SimpleUrl ( $ url ) ; } if ( $ this -> getUrl ( ) ) { $ url = $ url -> makeAbsolute ( $ this -> getUrl ( ) ) ; } return $ this -> load ( $ url , new SimpleGetEncoding ( $ parameters ) ) ; }
12555	public function showAction ( Tag $ tag ) { $ deleteForm = $ this -> createDeleteForm ( $ tag ) ; return array ( 'entity' => $ tag , 'delete_form' => $ deleteForm -> createView ( ) , ) ; }
7401	private function getErrors ( Form $ form ) { $ errors = array ( ) ; if ( $ form -> isSubmitted ( ) && $ form -> isValid ( ) ) { return $ errors ; } $ id = $ form -> createView ( ) -> vars [ 'id' ] ; foreach ( $ form -> getErrors ( ) as $ error ) { if ( ! isset ( $ errors [ $ id ] ) ) { $ errors [ $ id ] = array ( ) ; } $ errors [ $ id ] [ ] = $ error -> getMessage ( ) ; } foreach ( $ form -> all ( ) as $ child ) { $ errors = array_merge ( $ this -> getErrors ( $ child ) , $ errors ) ; } return $ errors ; }
10927	private function updateWidth ( $ columnNumber , $ width ) { if ( $ width > $ this -> getWidth ( $ columnNumber ) ) { $ this -> widths [ $ columnNumber ] = $ width ; } }
10877	public function isValidForgotten ( string $ hash ) : bool { $ decode = $ this -> getDecodeHash ( $ hash ) ; $ id = ( int ) $ decode [ 'id' ] ; $ verifyHash = $ decode [ 'verifyHash' ] ; $ item = $ this -> getById ( $ id ) ; if ( $ item && $ id == $ item [ 'id' ] ) { return $ this -> verifyHash ( $ item [ 'id' ] . $ item [ 'login' ] , $ verifyHash ) ; } return false ; }
973	public function creating ( $ shop ) { if ( ! isset ( $ shop -> namespace ) ) { $ shop -> namespace = Config :: get ( 'shopify-app.namespace' ) ; } if ( Config :: get ( 'shopify-app.billing_freemium_enabled' ) === true && ! isset ( $ shop -> freemium ) ) { $ shop -> freemium = true ; } }
5623	protected function parseRequest ( $ raw ) { $ this -> raw = $ raw ; $ request = new SimpleGetEncoding ( ) ; foreach ( explode ( '&' , $ raw ) as $ pair ) { if ( preg_match ( '/(.*?)=(.*)/' , $ pair , $ matches ) ) { $ request -> add ( urldecode ( $ matches [ 1 ] ) , urldecode ( $ matches [ 2 ] ) ) ; } elseif ( $ pair ) { $ request -> add ( urldecode ( $ pair ) , '' ) ; } } return $ request ; }
6298	public function addToMain ( array $ item , $ name = 'default' , $ first = false ) { if ( ! array_key_exists ( $ name , $ this -> main ) ) { $ this -> main [ $ name ] = [ ] ; } if ( $ first ) { $ this -> main [ $ name ] = array_merge ( [ $ item ] , $ this -> main [ $ name ] ) ; } else { $ this -> main [ $ name ] [ ] = $ item ; } return $ this ; }
11940	public function getUrl ( string $ sCode , array $ aParams = array ( ) ) : string { if ( isset ( $ _SERVER ) && isset ( $ _SERVER [ 'HTTP_HOST' ] ) ) { foreach ( Config :: get ( 'route' ) as $ sHost => $ oHost ) { if ( ( ! strstr ( $ sHost , '/' ) && $ sHost == $ _SERVER [ 'HTTP_HOST' ] ) || ( strstr ( $ sHost , '/' ) && strstr ( $ _SERVER [ 'HTTP_HOST' ] . $ _SERVER [ 'REQUEST_URI' ] , $ sHost ) ) ) { if ( strstr ( $ sHost , '/' ) && strstr ( $ _SERVER [ 'HTTP_HOST' ] . $ _SERVER [ 'REQUEST_URI' ] , $ sHost ) ) { $ this -> _sBaseUri = preg_replace ( '#^[^/]+#' , '' , $ sHost ) ; } if ( isset ( $ oHost -> routes ) ) { foreach ( $ oHost -> routes as $ sKey => $ oRoute ) { if ( $ sKey === $ sCode ) { $ sRoute = $ this -> _sBaseUri . $ oRoute -> route ; if ( isset ( $ oRoute -> constraints ) ) { foreach ( $ oRoute -> constraints as $ sName => $ sType ) { if ( ! isset ( $ aParams [ $ sName ] ) ) { $ aParams [ $ sName ] = '' ; } if ( preg_match ( '#' . $ sType . '#' , $ aParams [ $ sName ] ) ) { if ( $ aParams [ $ sName ] ) { $ sRoute = str_replace ( '[/:' . $ sName . ']' , '/' . $ aParams [ $ sName ] , $ sRoute ) ; } else { $ sRoute = str_replace ( '[/:' . $ sName . ']' , '' , $ sRoute ) ; } $ sRoute = str_replace ( '[:' . $ sName . ']' , $ aParams [ $ sName ] , $ sRoute ) ; continue ; } else if ( isset ( $ oRoute -> defaults_constraints ) && isset ( $ oRoute -> defaults_constraints -> { $ sName } ) && preg_match ( '#' . $ sType . '#' , $ oRoute -> defaults_constraints -> { $ sName } ) ) { continue ; } throw new \ Exception ( 'For the route ' . $ sCode . ' the parameter ' . $ sName . ' is not good!' ) ; } } return $ sRoute ; } } } } } } }
11427	public function toObject ( ) { $ groups = $ this -> groups ; foreach ( $ groups as & $ group ) { $ group = $ group -> toObject ( ) ; } $ items = $ this -> items ; foreach ( $ items as & $ item ) { $ item = $ item -> toObject ( ) ; } return ( object ) [ 'type' => $ this -> type , 'value' => $ this -> value , 'text' => $ this -> text , 'groups' => $ groups , 'items' => $ items , ] ; }
8519	public function setPricingRecommendations ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'PricingRecommendations' ] [ 'FieldValue' ] = $ value ; return $ this ; }
7622	public function signRequestUrl ( $ requestUrl = '' , $ resourceType = Storage :: RESOURCE_UNKNOWN , $ requiredPermission = CredentialsAbstract :: PERMISSION_READ ) { foreach ( $ this -> getPermissionSet ( ) as $ permittedUrl ) { if ( $ this -> permissionMatchesRequest ( $ permittedUrl , $ requestUrl , $ resourceType , $ requiredPermission ) ) { $ parsedPermittedUrl = parse_url ( $ permittedUrl ) ; if ( strpos ( $ requestUrl , '?' ) === false ) { $ requestUrl .= '?' ; } else { $ requestUrl .= '&' ; } $ requestUrl .= $ parsedPermittedUrl [ 'query' ] ; return $ requestUrl ; } } return $ requestUrl ; }
1496	public function prepend ( Encoding ... $ encodings ) : self { $ copy = clone $ this ; array_unshift ( $ copy -> stack , ... $ encodings ) ; return $ copy ; }
5717	public function doPublishAndAdd ( $ data , $ form ) { return $ this -> publish ( $ data , $ form , $ this -> owner , $ this -> owner -> Link ( 'addnew' ) ) ; }
11917	public function newInstanceQuery ( array $ data = [ ] , array $ selectable = [ '*' ] ) { $ tm = new TextGenerator ( ) ; $ r = $ this -> newInstanceRepository ( ) ; $ query = $ r -> newQuery ( ) ; if ( ! empty ( $ this -> filter ) ) { $ filter = new Filter ( $ r -> getTableName ( ) , $ selectable ) ; $ filter -> build ( $ query , $ tm -> generateAndRender ( $ this -> filter , $ data ) ) ; } return $ query ; }
1359	public static function jsonApi ( int $ options = 0 , string $ urlPrefix = null , int $ depth = 512 ) : self { return self :: create ( MediaTypeInterface :: JSON_API_MEDIA_TYPE , $ options , $ urlPrefix , $ depth ) ; }
609	public function convert ( $ asset , $ basePath ) { $ pos = strrpos ( $ asset , '.' ) ; if ( $ pos !== false ) { $ ext = substr ( $ asset , $ pos + 1 ) ; if ( isset ( $ this -> commands [ $ ext ] ) ) { list ( $ ext , $ command ) = $ this -> commands [ $ ext ] ; $ result = substr ( $ asset , 0 , $ pos + 1 ) . $ ext ; if ( $ this -> forceConvert || @ filemtime ( "$basePath/$result" ) < @ filemtime ( "$basePath/$asset" ) ) { $ this -> runCommand ( $ command , $ basePath , $ asset , $ result ) ; } return $ result ; } } return $ asset ; }
6177	protected function executeDelete ( ) { foreach ( $ this -> tableData as $ key => $ row ) { if ( $ this -> where && ! $ this -> where -> execute ( $ row ) ) { continue ; } unset ( $ this -> tableData [ $ key ] ) ; } $ this -> tableData = array_values ( $ this -> tableData ) ; }
11566	public function register ( string ... $ mods ) : void { $ this -> kms = array_unique ( array_merge ( $ this -> kms , $ mods ) ) ; }
1691	protected function compileColor ( $ color , $ blnWriteToFile = false , $ vars = array ( ) ) { if ( ! \ is_array ( $ color ) ) { return '#' . $ this -> shortenHexColor ( $ color ) ; } elseif ( ! isset ( $ color [ 1 ] ) || empty ( $ color [ 1 ] ) ) { return '#' . $ this -> shortenHexColor ( $ color [ 0 ] ) ; } else { return 'rgba(' . implode ( ',' , $ this -> convertHexColor ( $ color [ 0 ] , $ blnWriteToFile , $ vars ) ) . ',' . ( $ color [ 1 ] / 100 ) . ')' ; } }
6940	private function pop ( array & $ list , $ oid , StockUnitInterface $ unit ) { if ( false !== $ index = $ this -> find ( $ list , $ oid , $ unit ) ) { unset ( $ list [ $ oid ] [ $ index ] ) ; if ( empty ( $ list [ $ oid ] ) ) { unset ( $ list [ $ oid ] ) ; } } }
8376	public function orderBy ( $ orderBy ) { if ( is_array ( $ orderBy ) === true ) { $ this -> orderBy = '' ; foreach ( $ orderBy as $ key => $ elem ) { $ this -> orderBy .= $ key . ' ' . $ elem . ', ' ; } $ this -> orderBy = substr ( $ this -> orderBy , 0 , - 2 ) ; } else { $ this -> orderBy = $ orderBy ; } return $ this ; }
9229	public function delete ( $ path , $ data = array ( ) , $ headers = array ( ) ) { if ( ! empty ( $ data ) ) { $ pathData = [ ] ; $ pos = strpos ( $ path , '?' ) ; if ( $ pos !== false ) { parse_str ( substr ( $ path , $ pos + 1 ) , $ pathData ) ; $ path = substr ( $ path , 0 , $ pos ) ; } $ path .= '?' . $ this -> http_build_query ( array_merge ( $ pathData , $ data ) ) ; } return $ this -> postprocessResponse ( parent :: delete ( $ path , $ headers ) ) ; }
6509	public function createHandlers ( JobInterface $ job , $ level , $ bubble ) { $ handlers = [ ] ; foreach ( $ this -> factories as $ factory ) { $ handlers [ ] = $ factory -> createHandler ( $ job , $ level , $ bubble ) ; } return $ handlers ; }
605	protected function indexAfter ( $ string , $ offset = null ) { if ( $ offset === null ) { $ offset = $ this -> offset ; } if ( $ offset + mb_strlen ( $ string , 'UTF-8' ) > $ this -> length ) { return $ this -> length ; } $ afterIndexOf = mb_strpos ( $ this -> sql , $ string , $ offset , 'UTF-8' ) ; if ( $ afterIndexOf === false ) { $ afterIndexOf = $ this -> length ; } else { $ afterIndexOf += mb_strlen ( $ string , 'UTF-8' ) ; } return $ afterIndexOf ; }
11605	protected function getHashGeneratorByDescription ( OptionsInterface $ options , $ description ) { if ( $ description === 'predis' ) { return new Hash \ CRC16 ( ) ; } elseif ( $ description === 'phpiredis' ) { return new Hash \ PhpiredisCRC16 ( ) ; } else { throw new \ InvalidArgumentException ( 'String value for the crc16 option must be either `predis` or `phpiredis`' ) ; } }
9543	public function getMessages ( ) { $ messages = array ( ) ; if ( ! empty ( $ this -> error ) ) { $ messages [ ] = $ this -> error ; } if ( ! empty ( $ this -> warning ) ) { $ messages [ ] = $ this -> warning ; } return $ messages ; }
1227	private function parseJson ( array $ token ) { $ value = json_decode ( $ token [ 'value' ] , true ) ; if ( $ error = json_last_error ( ) ) { $ value = json_decode ( '"' . $ token [ 'value' ] . '"' , true ) ; if ( $ error = json_last_error ( ) ) { $ token [ 'type' ] = self :: T_UNKNOWN ; return $ token ; } } $ token [ 'value' ] = $ value ; return $ token ; }
5458	protected function openTag ( $ tag ) { $ name = $ tag -> getTagName ( ) ; if ( ! in_array ( $ name , array_keys ( $ this -> tags ) ) ) { $ this -> tags [ $ name ] = array ( ) ; } $ this -> tags [ $ name ] [ ] = $ tag ; }
9692	private function compileString ( $ str ) { $ result = null ; try { $ result = $ this -> parser -> compile ( $ str ) ; } catch ( \ Exception $ e ) { throw new SyntaxErrorException ( "Syntax error in $this->currFile: " . $ e -> getMessage ( ) ) ; } return $ result ; }
5181	private function appendToArray ( string $ key , $ value ) : self { $ this -> props [ $ key ] = [ $ this -> props [ $ key ] , $ value ] ; return $ this ; }
7952	public function setReverseProperties ( $ ipblock , $ ip , $ reverse ) { if ( ! $ ipblock ) throw new BadMethodCallException ( 'Parameter $ipblock is missing.' ) ; if ( ! $ ip ) throw new BadMethodCallException ( 'Parameter $ip is missing.' ) ; $ payload = array ( 'ipReverse' => $ ip , 'reverse' => $ reverse ) ; try { $ r = $ this -> post ( 'ip/' . urlencode ( $ ipblock ) . '/reverse' , array ( 'Content-Type' => 'application/json;charset=UTF-8' ) , json_encode ( $ payload ) ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new IpException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
12698	static function archiveDir ( $ sourcedir , $ archivefile , $ no_top_dir = false ) { $ archivefile = str_replace ( '\\' , '/' , $ archivefile ) ; $ sourcedir = str_replace ( '\\' , '/' , realpath ( $ sourcedir ) ) ; if ( $ no_top_dir ) { $ srcdir = '.' ; $ workdir = $ sourcedir ; } else { $ srcdir = basename ( $ sourcedir ) ; $ workdir = dirname ( $ sourcedir ) ; } $ archivedir = dirname ( $ archivefile ) ; $ extra = '' ; $ tar = self :: getTool ( 'tar' ) ; if ( substr ( $ archivefile , - 7 ) == '.tar.gz' || substr ( $ archivefile , - 4 ) == '.tgz' ) { $ cmd = "$tar -z -cvf" ; $ extra = "-C " . escapeshellarg ( $ workdir ) ; $ workdir = $ archivedir ; $ archivefile = basename ( $ archivefile ) ; } else if ( substr ( $ archivefile , - 8 ) == '.tar.bz2' ) { $ cmd = "$tar -j -cvf" ; $ extra = "-C " . escapeshellarg ( $ workdir ) ; $ workdir = $ archivedir ; $ archivefile = basename ( $ archivefile ) ; } else if ( substr ( $ archivefile , - 4 ) == '.tar' ) { $ cmd = "$tar -cvf" ; $ extra = "-C " . escapeshellarg ( $ workdir ) ; $ workdir = $ archivedir ; $ archivefile = basename ( $ archivefile ) ; } else if ( substr ( $ archivefile , - 4 ) == '.zip' ) { $ zip = self :: getTool ( 'zip' ) ; $ cmd = "$zip -9 -r" ; } else { throw new pakeException ( "Can not determine archive type from filename: $archivefile" ) ; } pake_sh ( self :: getCdCmd ( $ workdir ) . " && $cmd $archivefile $extra $srcdir" ) ; pake_echo_action ( 'file+' , $ archivefile ) ; }
9514	public function addFacetedQuery ( $ query , $ index , array $ keys ) { $ this -> AddQuery ( $ query , $ index ) ; $ currentOffset = $ this -> _offset ; $ mode = $ this -> _sort ; $ sortby = $ this -> _sortby ; $ limit = $ this -> _limit ; $ this -> _offset = 0 ; $ this -> _sort = 0 ; $ this -> _sortby = '' ; $ this -> SetLimits ( 0 , 999 ) ; foreach ( $ keys as $ key ) { $ this -> setGroupByAttr ( $ key ) ; $ this -> AddQuery ( $ query , $ index ) ; } $ this -> _offset = $ currentOffset ; $ this -> _sort = $ mode ; $ this -> _sortby = $ sortby ; $ this -> SetLimits ( $ currentOffset , $ limit ) ; }
3691	public function presetVariantBase ( PreEditModelEvent $ event ) { $ model = $ event -> getModel ( ) ; if ( ! $ model instanceof Model ) { return ; } $ nativeItem = $ model -> getItem ( ) ; $ metaModel = $ nativeItem -> getMetaModel ( ) ; if ( $ metaModel -> hasVariants ( ) && ( ! $ nativeItem -> get ( 'vargroup' ) ) ) { $ nativeItem -> set ( 'varbase' , '1' ) ; } }
7237	protected function fixInvoiceDefault ( CustomerAddressInterface $ address ) { if ( ! $ this -> persistenceHelper -> isChanged ( $ address , [ 'invoiceDefault' ] ) ) { return ; } $ customer = $ address -> getCustomer ( ) ; if ( $ address -> isInvoiceDefault ( ) ) { foreach ( $ customer -> getAddresses ( ) as $ a ) { if ( $ a === $ address ) { continue ; } if ( $ a -> isInvoiceDefault ( ) ) { $ a -> setInvoiceDefault ( false ) ; $ this -> persistenceHelper -> persistAndRecompute ( $ a , false ) ; } } } elseif ( null === $ customer -> getDefaultInvoiceAddress ( true ) ) { $ address -> setInvoiceDefault ( true ) ; $ this -> persistenceHelper -> persistAndRecompute ( $ address , false ) ; } }
9127	private function checkConnection ( $ start ) : bool { if ( ! $ this -> ready ( ) ) { if ( time ( ) - $ start > $ this -> timeout ) { $ this -> disconnect ( ) ; throw new HttpException ( "Connection timed out!" ) ; } return false ; } return true ; }
6954	private function getGridForCountry ( CountryInterface $ country ) { if ( isset ( $ this -> grids [ $ country -> getId ( ) ] ) ) { return $ this -> grids [ $ country -> getId ( ) ] ; } $ grid = [ ] ; $ prices = $ this -> priceRepository -> findByCountry ( $ country ) ; foreach ( $ prices as $ price ) { $ method = $ price -> getMethod ( ) ; if ( ! isset ( $ grid [ $ method -> getId ( ) ] ) ) { $ gateway = $ this -> gatewayRegistry -> getGateway ( $ method -> getGatewayName ( ) ) ; $ grid [ $ method -> getId ( ) ] = [ 'method' => $ method , 'max_weight' => $ gateway -> getMaxWeight ( ) , 'prices' => [ ] , ] ; } $ grid [ $ method -> getId ( ) ] [ 'prices' ] [ ] = [ 'weight' => $ price -> getWeight ( ) , 'price' => $ price -> getNetPrice ( ) , ] ; } foreach ( $ grid as & $ method ) { usort ( $ method [ 'prices' ] , function ( $ a , $ b ) { if ( 0 === bccomp ( $ a [ 'weight' ] , $ b [ 'weight' ] , 3 ) ) { return 0 ; } return $ a [ 'weight' ] > $ b [ 'weight' ] ? 1 : - 1 ; } ) ; $ max = end ( $ method [ 'prices' ] ) [ 'weight' ] ; if ( 0 == $ method [ 'max_weight' ] || $ method [ 'max_weight' ] > $ max ) { $ method [ 'max_weight' ] = $ max ; } unset ( $ method ) ; } return $ this -> grids [ $ country -> getId ( ) ] = $ grid ; }
185	protected function renderInputHtml ( $ type ) { if ( $ this -> hasModel ( ) ) { return Html :: activeInput ( $ type , $ this -> model , $ this -> attribute , $ this -> options ) ; } return Html :: input ( $ type , $ this -> name , $ this -> value , $ this -> options ) ; }
6044	public function view ( $ sessionId , $ mediaId ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'sessionId' => $ sessionId , 'mediaId' => $ mediaId ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/events/view' , $ parameters , true ) ; return $ result ; }
7399	public function redirect ( string $ url = '' , int $ statusCode = 302 ) { $ this -> is404 = false ; $ server = filter_input_array ( INPUT_SERVER ) ; if ( '' == $ url && isset ( $ server [ 'REQUEST_URI' ] ) ) { $ url = '/' . trim ( $ server [ 'REQUEST_URI' ] , '/' ) ; preg_match ( '/^[\\a-zA-Z0-9-\._~:\/\?\#\[\]\@\!\$\&\'\(\)\*\+\,\;\=%]*$/iD' , $ url , $ match ) ; $ url = $ match [ 1 ] ?? '' ; } if ( ! headers_sent ( ) ) { header ( 'Location: ' . $ url , true , $ statusCode ) ; } echo sprintf ( '<!DOCTYPE html><html> <head> <meta charset="UTF-8" /> <meta http-equiv="refresh" content="0;url=%1$s" /> <title>Redirecting to %1$s</title> </head> <body> <script type="text/javascript"> window.location.href = "%1$s"; </script> Redirecting to <a href="%1$s">%1$s</a>. </body></html>' , htmlspecialchars ( $ url , ENT_QUOTES , 'UTF-8' ) ) ; }
5965	public function channelGroupPermList ( $ cgid , $ permsid = false ) { return $ this -> execute ( "channelgrouppermlist" , array ( "cgid" => $ cgid , $ permsid ? "-permsid" : null ) ) -> toAssocArray ( $ permsid ? "permsid" : "permid" ) ; }
10837	protected function buildOrderBy ( ) { $ result = [ ] ; foreach ( $ this -> clause_orderby as $ ord ) { $ result [ ] = $ ord [ 0 ] ? $ ord [ 1 ] : ( $ this -> quote ( $ ord [ 1 ] ) . ' ' . $ ord [ 2 ] ) ; } return $ result ; }
359	function checkUploadMaxFileSize ( $ min = null , $ max = null ) { $ postMaxSize = ini_get ( 'post_max_size' ) ; $ uploadMaxFileSize = ini_get ( 'upload_max_filesize' ) ; if ( $ min !== null ) { $ minCheckResult = $ this -> compareByteSize ( $ postMaxSize , $ min , '>=' ) && $ this -> compareByteSize ( $ uploadMaxFileSize , $ min , '>=' ) ; } else { $ minCheckResult = true ; } if ( $ max !== null ) { $ maxCheckResult = $ this -> compareByteSize ( $ postMaxSize , $ max , '<=' ) && $ this -> compareByteSize ( $ uploadMaxFileSize , $ max , '<=' ) ; } else { $ maxCheckResult = true ; } return ( $ minCheckResult && $ maxCheckResult ) ; }
5266	public static function merge ( Model $ model1 , Model $ model2 , array $ attributes ) { foreach ( $ attributes as $ attribute ) { $ model1 -> $ attribute = $ model2 -> $ attribute ; } return $ model1 ; }
11593	public function getAction ( ) { $ id = $ this -> getPageId ( ) ; if ( $ id !== null ) { $ result = $ this -> pageList -> getPage ( $ id ) -> getJSON ( ) ; } else { $ result = array ( ) ; foreach ( $ this -> pageList -> getPages ( ) as $ pageName ) { $ result [ ] = $ this -> pageList -> getPage ( $ pageName ) -> getJSON ( ) ; } } $ this -> environment -> sendJSONResult ( $ result ) ; }
7134	public function findOrCreateGoodLine ( Invoice \ InvoiceInterface $ invoice , Common \ SaleItemInterface $ item , $ available , $ expected = null ) { $ line = null ; if ( 0 >= $ available ) { return $ line ; } foreach ( $ invoice -> getLinesByType ( Document \ DocumentLineTypes :: TYPE_GOOD ) as $ invoiceLine ) { if ( $ invoiceLine -> getSaleItem ( ) === $ item ) { $ line = $ invoiceLine ; } } if ( null === $ line ) { $ line = $ this -> createLine ( $ invoice ) ; $ line -> setInvoice ( $ invoice ) -> setType ( Document \ DocumentLineTypes :: TYPE_GOOD ) -> setSaleItem ( $ item ) -> setDesignation ( $ item -> getDesignation ( ) ) -> setDescription ( $ item -> getDescription ( ) ) -> setReference ( $ item -> getReference ( ) ) ; } $ line -> setAvailable ( $ available ) ; $ line -> setExpected ( $ expected ) ; if ( Invoice \ InvoiceTypes :: isInvoice ( $ invoice ) && null === $ invoice -> getId ( ) ) { $ line -> setQuantity ( min ( $ expected , $ available ) ) ; } return $ line ; }
6442	public function getAllResources ( $ name , $ full = false , array $ filters = [ ] , array $ fields = [ ] ) { $ this -> lastRequest = new Request ; $ this -> lastRequest -> setMode ( Request :: MODE_READ ) ; $ this -> lastRequest -> setResourceName ( $ name ) ; if ( $ full ) { $ this -> lastRequest -> enableFullResults ( ) ; } $ this -> lastRequest -> setFilters ( $ filters ) ; $ this -> lastRequest -> setFields ( $ fields ) ; $ data = [ ] ; $ page = 1 ; do { $ this -> lastRequest -> setCurrentPage ( $ page ) ; $ response = $ this -> proceed ( ) ; $ data = ArrayUtils :: merge ( $ data , $ response -> getData ( ) -> getData ( ) ) ; $ page ++ ; } while ( $ response -> getPagination ( ) -> getPage ( ) != $ response -> getPagination ( ) -> getPages ( ) ) ; return $ data ; }
4897	public static function getConfigDir ( ) { if ( is_null ( static :: $ configDir ) ) { $ configDir = '' ; $ dirs = [ __DIR__ . '/../../../../*/sandbox/config' , __DIR__ . '/../../../config' , ] ; foreach ( $ dirs as $ dir ) { foreach ( glob ( $ dir ) as $ testDir ) { $ configDir = realpath ( $ testDir ) ; break ; } if ( is_dir ( $ configDir ) ) { break ; } } if ( ! is_dir ( $ configDir ) ) { throw new InvalidArgumentException ( 'Can not determine which config directory to be used.' ) ; } static :: $ configDir = $ configDir ; } return static :: $ configDir ; }
7381	public function route ( bool $ dropIndex = false ) : string { if ( $ dropIndex ) { if ( 'index' == $ this -> route ) { return '' ; } } return $ this -> route ; }
8855	public function getArchiveDate ( ) { $ year = $ this -> getArchiveYear ( ) ; $ month = $ this -> getArchiveMonth ( ) ; $ day = $ this -> getArchiveDay ( ) ; if ( $ year ) { if ( $ month ) { $ date = $ year . '-' . $ month . '-01' ; if ( $ day ) { $ date = $ year . '-' . $ month . '-' . $ day ; } } else { $ date = $ year . '-01-01' ; } return DBField :: create_field ( "Date" , $ date ) ; } }
11794	public function setBcc ( $ mail = '' , $ name = null ) { $ this -> bcc = Helper :: deduplicate ( array_merge ( $ this -> bcc , call_user_func_array ( array ( '\MimeMailer\Helper' , 'checkPeopleArgs' ) , func_get_args ( ) ) ) ) ; return $ this ; }
8701	public function getString ( ) { $ this -> validateElement ( ) ; $ elementStringData = '' ; $ elementStringData = '<' . static :: TYPE ; foreach ( $ this -> attributes as $ key => $ data ) { $ elementStringData .= ' ' . $ key . '="' . $ data . '"' ; } $ elementStringData .= '>' ; if ( $ this -> text !== null ) { $ elementStringData .= $ this -> text ; } if ( count ( $ this -> childElements ) > 0 ) { if ( static :: TYPE == 'svg' ) { foreach ( $ this -> childElements as $ childElement ) { $ this -> defs = array_merge ( $ this -> defs , $ childElement -> getDefs ( ) ) ; } if ( count ( $ this -> defs ) > 0 ) { $ defArea = new \ SVGCreator \ Elements \ Defs ( ) ; foreach ( $ this -> defs as $ def ) { $ defArea -> append ( $ def ) ; } $ elementStringData .= $ defArea -> getString ( ) ; } } foreach ( $ this -> childElements as $ childElement ) { $ elementStringData .= $ childElement -> getString ( ) ; } } $ elementStringData .= '</' . static :: TYPE . '>' ; $ this -> elementString = $ elementStringData ; return $ this -> elementString ; }
6339	private function getDocumentStream ( $ xmlDocument ) { foreach ( $ this -> streamAdapters as $ streamAdapter ) { if ( $ streamAdapter -> supports ( $ xmlDocument ) ) { return $ streamAdapter -> convert ( $ xmlDocument ) ; } } throw new RuntimeException ( sprintf ( 'Suitable XML document stream adapter is not registered for XML document of type "%s".' , is_object ( $ xmlDocument ) ? get_class ( $ xmlDocument ) : gettype ( $ xmlDocument ) ) ) ; }
493	private function indexBuckets ( $ buckets , $ indexBy ) { $ result = [ ] ; foreach ( $ buckets as $ key => $ models ) { $ result [ $ key ] = [ ] ; foreach ( $ models as $ model ) { $ index = is_string ( $ indexBy ) ? $ model [ $ indexBy ] : call_user_func ( $ indexBy , $ model ) ; $ result [ $ key ] [ $ index ] = $ model ; } } return $ result ; }
11009	public function addPluginType ( string $ mediaType ) : bool { if ( ! preg_match ( '#^[-\w]+/[-\w]+$#ui' , $ mediaType ) ) { throw new MiddlewareException ( $ this , sprintf ( "'%s' is not a valid media type and can not be used as a CSP plugin type" , $ mediaType ) ) ; } if ( ! in_array ( $ mediaType , $ this -> tags [ 'plugin-types' ] ) ) { $ this -> tags [ 'plugin-types' ] [ ] = $ mediaType ; return true ; } return false ; }
2234	public function showDeletedRecords ( $ data , $ row ) { $ arrData = Contao \ StringUtil :: deserialize ( $ row [ 'data' ] ) ; foreach ( $ arrData as $ strTable => $ arrTableData ) { Contao \ System :: loadLanguageFile ( $ strTable ) ; Contao \ Controller :: loadDataContainer ( $ strTable ) ; foreach ( $ arrTableData as $ arrRow ) { $ arrBuffer = array ( ) ; foreach ( $ arrRow as $ i => $ v ) { if ( \ is_array ( Contao \ StringUtil :: deserialize ( $ v ) ) ) { continue ; } if ( isset ( $ GLOBALS [ 'TL_DCA' ] [ $ strTable ] [ 'fields' ] [ $ i ] [ 'label' ] ) ) { $ label = \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ strTable ] [ 'fields' ] [ $ i ] [ 'label' ] ) ? $ GLOBALS [ 'TL_DCA' ] [ $ strTable ] [ 'fields' ] [ $ i ] [ 'label' ] [ 0 ] : $ GLOBALS [ 'TL_DCA' ] [ $ strTable ] [ 'fields' ] [ $ i ] [ 'label' ] ; } else { $ label = \ is_array ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ i ] ) ? $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ i ] [ 0 ] : $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ i ] ; } if ( ! $ label ) { $ label = $ i ; } $ arrBuffer [ $ label ] = $ v ; } $ data [ $ strTable ] [ ] = $ arrBuffer ; } } return $ data ; }
1733	protected function getBookPages ( $ intParentId , $ groups , $ time ) { $ objPages = PageModel :: findPublishedSubpagesWithoutGuestsByPid ( $ intParentId , $ this -> showHidden ) ; if ( $ objPages === null ) { return ; } foreach ( $ objPages as $ objPage ) { $ _groups = StringUtil :: deserialize ( $ objPage -> groups ) ; if ( ! $ objPage -> protected || $ this -> showProtected || ( \ is_array ( $ groups ) && \ is_array ( $ _groups ) && \ count ( array_intersect ( $ groups , $ _groups ) ) ) ) { $ this -> arrPages [ $ objPage -> id ] = $ objPage ; if ( $ objPage -> subpages > 0 ) { $ this -> getBookPages ( $ objPage -> id , $ groups , $ time ) ; } } } }
11469	public function show ( ResponseRequest $ request , Response $ response ) { if ( $ response -> exists ) { $ view = 'forum::response.show' ; } else { $ view = 'forum::response.new' ; } return $ this -> response -> title ( trans ( 'app.view' ) . ' ' . trans ( 'forum::response.name' ) ) -> data ( compact ( 'response' ) ) -> view ( $ view , true ) -> output ( ) ; }
5505	public function returns ( $ method , $ value , $ args = false ) { $ this -> dieOnNoMethod ( $ method , 'set return' ) ; $ this -> actions -> register ( $ method , $ args , new SimpleReturn ( $ value ) ) ; }
11299	function getFullClassName ( $ class = false ) { if ( $ class == false ) { $ class = $ this ; } $ className = get_class ( $ class ) ; if ( $ pos = strpos ( $ className , '\\' ) ) return substr ( $ className , $ pos + 1 ) ; return $ className ; }
2108	public static function findByRelatedTableAndIds ( $ strTable , array $ arrIds , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ objDatabase = Database :: getInstance ( ) ; $ objResult = $ objDatabase -> prepare ( "SELECT * FROM $t WHERE $t.id IN (SELECT pid FROM tl_opt_in_related WHERE relTable=? AND relId IN(" . implode ( ',' , array_map ( '\intval' , $ arrIds ) ) . ")) ORDER BY $t.createdOn DESC" ) -> execute ( $ strTable , $ arrIds ) ; if ( $ objResult -> numRows < 1 ) { return null ; } $ arrModels = array ( ) ; $ objRegistry = Registry :: getInstance ( ) ; while ( $ objResult -> next ( ) ) { if ( $ objOptIn = $ objRegistry -> fetch ( $ t , $ objResult -> id ) ) { $ arrModels [ ] = $ objOptIn ; } else { $ arrModels [ ] = new static ( $ objResult -> row ( ) ) ; } } return static :: createCollection ( $ arrModels , $ t ) ; }
2799	public static function generate ( $ mutantFile = null , $ bootstrap = '' , $ replacingFile = null ) { $ loadHumbug = '' ; if ( 'phar:' === substr ( __FILE__ , 0 , 5 ) ) { $ loadHumbug = '\Phar::loadPhar(\'' . str_replace ( 'phar://' , '' , \ Phar :: running ( ) ) . '\', \'humbug.phar\');' ; $ humbugBootstrap = 'phar://humbug.phar' . '/bootstrap.php' ; } else { $ humbugBootstrap = realpath ( __DIR__ . '/../../../bootstrap.php' ) ; } $ file = sys_get_temp_dir ( ) . '/humbug.phpunit.bootstrap.php' ; if ( ! is_null ( $ mutantFile ) ) { $ mutantFile = addslashes ( $ mutantFile ) ; $ replacingFile = addslashes ( $ replacingFile ) ; $ prepend = <<<PREPEND<?php{$loadHumbug}require_once '{$humbugBootstrap}';use Humbug\StreamWrapper\IncludeInterceptor;IncludeInterceptor::intercept('{$replacingFile}', '{$mutantFile}');IncludeInterceptor::enable();PREPEND ; if ( ! empty ( $ bootstrap ) ) { $ buffer = $ prepend . "\nrequire_once '{$bootstrap}';" ; } else { $ buffer = $ prepend ; } file_put_contents ( $ file , $ buffer ) ; } else { if ( ! empty ( $ bootstrap ) ) { $ buffer = "<?php\n{$loadHumbug}\nrequire_once '{$humbugBootstrap}';\nrequire_once '{$bootstrap}';" ; } else { $ buffer = "<?php\n{$loadHumbug}\nrequire_once '{$humbugBootstrap}';" ; } file_put_contents ( $ file , $ buffer ) ; } }
1643	public function getCenter ( ) : Coordinate { $ centerLat = ( $ this -> getNorth ( ) + $ this -> getSouth ( ) ) / 2 ; return new Coordinate ( $ centerLat , $ this -> getCenterLng ( ) ) ; }
11217	public static function getMethod ( $ route ) { $ route = Url :: addBackSlash ( $ route ) ; return isset ( self :: $ routes [ $ route ] ) ? self :: $ routes [ $ route ] : null ; }
11912	public function setIndustry ( $ industryOne , $ industryTwo ) { $ params = [ 'industry_id1' => $ industryOne , 'industry_id2' => $ industryTwo , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_SET_INDUSTRY , $ params ] ) ; }
8295	public function open ( ) { if ( $ this -> isOpened ( ) ) { return ; } $ this -> handle = @ fopen ( $ this -> filePath , self :: OPEN_MODE ) ; if ( $ this -> handle === false ) { throw new \ RuntimeException ( "Could not open file for writing: " . $ this -> filePath ) ; } if ( ! $ this -> lock ( LOCK_EX ) ) { $ this -> close ( ) ; throw new \ RuntimeException ( "Could not aquire an exclusive lock for " . $ this -> filePath ) ; } if ( $ this -> options [ "backup" ] ) { $ this -> createBkFile ( ) ; } $ this -> writeErrors = false ; }
1829	public function delete ( ) { $ intPk = $ this -> { static :: $ strPk } ; if ( isset ( $ this -> arrModified [ static :: $ strPk ] ) ) { $ intPk = $ this -> arrModified [ static :: $ strPk ] ; } $ intAffected = Database :: getInstance ( ) -> prepare ( "DELETE FROM " . static :: $ strTable . " WHERE " . Database :: quoteIdentifier ( static :: $ strPk ) . "=?" ) -> execute ( $ intPk ) -> affectedRows ; if ( $ intAffected ) { Registry :: getInstance ( ) -> unregister ( $ this ) ; $ this -> arrData [ static :: $ strPk ] = null ; } return $ intAffected ; }
12832	private function _processModifiers ( $ expression ) { $ mStart = '' ; $ mEnd = '' ; $ rawEcho = false ; if ( strpos ( $ expression , '|' ) !== false && strpos ( $ expression , '||' ) === false ) { $ modifiers = explode ( '|' , $ expression ) ; $ expression = array_shift ( $ modifiers ) ; foreach ( $ modifiers as $ modifier ) { $ params = array ( ) ; if ( strpos ( $ modifier , ':' ) !== false ) { $ params = explode ( ':' , $ modifier ) ; $ modifier = array_shift ( $ params ) ; } if ( $ modifier == 'raw' ) { $ rawEcho = true ; continue ; } if ( $ this -> isCallable ( $ modifier ) ) { $ mStart = $ modifier . '(' . $ mStart ; if ( $ modifier !== 'raw' ) { foreach ( $ params as $ param ) { $ mEnd .= ', ' . $ this -> compileExpression ( $ param ) ; } } $ mEnd .= ')' ; } else { throw new \ Exception ( 'SLOT compiler error: undefined modifier ' . $ modifier ) ; } } } return array ( $ expression , $ mStart , $ mEnd , $ rawEcho ) ; }
5773	public function isUpdatable ( ) : bool { if ( is_null ( $ this -> authorization ) ) { throw new \ Exception ( "Authorization must be set" ) ; } if ( $ this -> authorization -> hasTopRole ( ) ) { return true ; } if ( ! $ this -> hasTopRole ( ) ) { return true ; } return false ; }
12180	public function getTaxonomyPackage ( ) { if ( empty ( $ this -> taxonomy ) ) { return false ; } $ taxonomySettings = $ this -> taxonomy ; if ( ! is_array ( $ taxonomySettings ) ) { $ taxonomySettings = [ 'id' => $ taxonomySettings ] ; } $ taxonomy = Yii :: $ app -> collectors [ 'taxonomies' ] -> getOne ( $ taxonomySettings [ 'id' ] ) ; if ( empty ( $ taxonomy ) || empty ( $ taxonomy -> object ) ) { return false ; } return $ taxonomy -> package ( $ taxonomySettings ) ; }
1951	public function resendButton ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { return ( ! $ row [ 'confirmedOn' ] && ! $ row [ 'invalidatedThrough' ] && $ row [ 'emailSubject' ] && $ row [ 'emailText' ] && $ row [ 'createdOn' ] > strtotime ( '-24 hours' ) ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : '' ; }
2693	private function compileFastlyParameters ( ) { if ( isset ( $ this -> fastlyParameters [ 'width' ] ) == false ) { $ this -> fastlyParameters [ 'height' ] = $ this -> _height ; $ this -> fastlyParameters [ 'width' ] = $ this -> _width ; } $ params = [ ] ; foreach ( $ this -> fastlyParameters as $ key => $ value ) { $ params [ ] = $ key . '=' . $ value ; } return implode ( '&' , $ params ) ; }
2992	private function parse ( $ content ) { if ( $ this -> method == 'downloadFile' ) { return $ this -> parseResponseDownloadFile ( $ content ) ; } $ xml = new SimpleXMLElement ( $ content ) ; if ( isset ( $ xml -> error ) ) { throw new Exception \ ZohoErrorException ( new ZohoError ( ( string ) $ xml -> error -> code , ( string ) $ xml -> error -> message ) ) ; } if ( isset ( $ xml -> nodata ) ) { throw new Exception \ NoDataException ( new ZohoError ( ( string ) $ xml -> nodata -> code , ( string ) $ xml -> nodata -> message ) ) ; } if ( $ this -> method == 'getFields' ) { return $ this -> parseResponseGetFields ( $ xml ) ; } if ( $ this -> method == 'deleteRecords' ) { return $ this -> parseResponseDeleteRecords ( $ xml ) ; } if ( $ this -> method == 'uploadFile' ) { return $ this -> parseResponseUploadFile ( $ xml ) ; } if ( $ this -> method == 'deleteFile' ) { return $ this -> parseResponseDeleteFile ( $ xml ) ; } if ( $ this -> method == 'getDeletedRecordIds' ) { return $ this -> parseResponseGetDeletedRecordIds ( $ xml ) ; } if ( $ this -> method == 'convertLead' ) { return $ this -> parseResponseConvertLead ( $ xml ) ; } if ( $ this -> method == 'updateRelatedRecords' ) { return $ this -> parseUpdateRelatedRecords ( $ xml ) ; } if ( isset ( $ xml -> result -> { $ this -> module } ) ) { return $ this -> parseResponseGetRecords ( $ xml ) ; } if ( isset ( $ xml -> result -> row -> success ) || isset ( $ xml -> result -> row -> error ) ) { return $ this -> parseResponsePostRecordsMultiple ( $ xml ) ; } throw new Exception \ UnexpectedValueException ( 'Xml doesn\'t contain expected fields' ) ; }
11083	public static function passwdGen ( $ length = 8 , $ flag = 'ALPHANUMERIC' ) { switch ( $ flag ) { case 'NUMERIC' : $ str = '0123456789' ; break ; case 'ALPHA' : $ str = 'abcdefghijkmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ' ; break ; case 'ALPHA_LOWER' : $ str = 'abcdefghijkmnopqrstuvwxyz' ; break ; default : $ str = 'abcdefghijkmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' ; break ; } for ( $ i = 0 , $ passwd = '' ; $ i < $ length ; $ i ++ ) { $ passwd .= substr ( $ str , mt_rand ( 0 , \ strlen ( $ str ) - 1 ) , 1 ) ; } return $ passwd ; }
10800	public function renderPageHistoricTableAction ( ) { $ translator = $ this -> getServiceLocator ( ) -> get ( 'translator' ) ; $ melisKey = $ this -> params ( ) -> fromRoute ( 'melisKey' , '' ) ; $ melisTool = $ this -> getServiceLocator ( ) -> get ( 'MelisCoreTool' ) ; $ melisTool -> setMelisToolKey ( self :: PLUGIN_INDEX , self :: TOOL_KEY ) ; $ columns = $ melisTool -> getColumns ( ) ; $ idPage = $ this -> params ( ) -> fromRoute ( 'idPage' , $ this -> params ( ) -> fromQuery ( 'idPage' , '' ) ) ; $ container = new Container ( 'meliscore' ) ; $ locale = $ container [ 'melis-lang-locale' ] ; $ view = new ViewModel ( ) ; $ view -> melisKey = $ melisKey ; $ view -> tableColumns = $ columns ; $ view -> getToolDataTableConfig = $ melisTool -> getDataTableConfiguration ( '#tableHistoricPageId' . $ idPage , true ) ; $ view -> idPage = $ idPage ; $ view -> tableId = 'tableHistoricPageId' . $ idPage ; return $ view ; }
3951	protected function isEmptyValue ( $ mixValue ) { if ( is_array ( $ mixValue ) ) { return $ this -> isArrayEmpty ( $ mixValue ) ; } elseif ( $ mixValue === '' ) { return true ; } elseif ( $ mixValue === null ) { return true ; } return false ; }
10790	protected function quote ( $ str ) { return $ this -> getDialect ( ) -> quote ( $ str , $ this -> getSettings ( ) [ 'autoQuote' ] ? DialectInterface :: QUOTE_YES : DialectInterface :: QUOTE_NO ) ; }
5066	public function init ( string $ url = null ) : void { $ this -> ch = curl_init ( $ url ) ; CurlObjectLookup :: add ( $ this ) ; }
5398	public function paintSignal ( $ type , $ payload ) { parent :: paintSignal ( $ type , $ payload ) ; print $ this -> getIndent ( 1 ) ; print '<' . $ this -> namespace . "signal type=\"$type\">" ; print '<![CDATA[' . serialize ( $ payload ) . ']]>' ; print '</' . $ this -> namespace . "signal>\n" ; }
931	public function clear ( ) { @ trigger_error ( __METHOD__ . ' is deprecated and will be removed in 3.0.' , E_USER_DEPRECATED ) ; Tokens :: setLegacyMode ( true ) ; $ this -> content = '' ; $ this -> id = null ; $ this -> isArray = false ; }
9831	public function resource ( $ modelName , $ controller ) { if ( php_sapi_name ( ) == 'cli' ) { return ; } if ( ! class_exists ( $ controller ) ) { throw new ExpectedAujaControllerException ( $ controller . ' does not exist.' ) ; } if ( ! is_subclass_of ( $ controller , 'Label305\AujaLaravel\Controllers\Interfaces\AujaControllerInterface' ) ) { throw new ExpectedAujaControllerException ( $ controller . ' does not implement Label305\AujaLaravel\Controllers\Interfaces\AujaControllerInterface' ) ; } $ this -> registerIndex ( $ modelName , $ controller ) ; $ this -> registerMenu ( $ modelName , $ controller ) ; $ this -> registerShowMenu ( $ modelName , $ controller ) ; $ this -> registerCreate ( $ modelName , $ controller ) ; $ this -> registerStore ( $ modelName , $ controller ) ; $ this -> registerShow ( $ modelName , $ controller ) ; $ this -> registerEdit ( $ modelName , $ controller ) ; $ this -> registerUpdate ( $ modelName , $ controller ) ; $ this -> registerDelete ( $ modelName , $ controller ) ; $ model = $ this -> auja -> getModel ( ucfirst ( str_singular ( camel_case ( $ modelName ) ) ) ) ; $ relations = $ this -> auja -> getRelationsForModel ( $ model ) ; foreach ( $ relations as $ relation ) { $ otherModelName = $ relation -> getRight ( ) -> getName ( ) ; if ( $ relation -> getType ( ) == Relation :: BELONGS_TO ) { $ this -> registerBelongsToAssociationMenu ( $ modelName , $ otherModelName , $ controller ) ; } else { $ this -> registerAssociation ( $ modelName , $ otherModelName , $ controller ) ; $ this -> registerAssociationMenu ( $ modelName , $ otherModelName , $ controller ) ; $ this -> registerCreateAssociation ( $ modelName , $ otherModelName , $ controller ) ; } } }
986	public function confirmationUrl ( ) { $ charge = $ this -> api -> rest ( 'POST' , "/admin/{$this->plan->typeAsString(true)}.json" , [ "{$this->plan->typeAsString()}" => $ this -> chargeParams ( ) ] ) -> body -> { $ this -> plan -> typeAsString ( ) } ; return $ charge -> confirmation_url ; }
8555	public function setAdjustmentEventList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'AdjustmentEventList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
3559	protected function mutateValue ( $ value , $ dir = 'setter' ) { $ mutator = $ this -> getMutator ( $ value , $ dir , $ this -> attributes [ 'meta_type' ] ) ; if ( method_exists ( $ this , $ mutator ) ) { return $ this -> { $ mutator } ( $ value ) ; } return static :: $ attributeMutator -> mutate ( $ value , $ mutator ) ; }
12518	public static function files ( $ path , $ filter = '.' , $ recurse = false , $ full = false , $ exclude = array ( '.svn' , 'CVS' , '.DS_Store' , '__MACOSX' , 'Thumbs.db' ) , $ excludefilter = array ( '^\..*' , '.*~' ) , $ naturalSort = true ) { $ path = Path :: clean ( $ path ) ; if ( ! is_dir ( $ path ) ) { throw new Exception ( Helper :: getTranslation ( 'NOT_A_FOLDER' ) ) ; } if ( count ( $ excludefilter ) ) { $ excludefilter_string = '/(' . implode ( '|' , $ excludefilter ) . ')/' ; } else { $ excludefilter_string = '' ; } $ arr = Folder :: _items ( $ path , $ filter , $ recurse , $ full , $ exclude , $ excludefilter_string , true ) ; if ( $ naturalSort ) { natsort ( $ arr ) ; } else { asort ( $ arr ) ; } return array_values ( $ arr ) ; }
2370	public static function highlight ( $ strString , $ strPhrase , $ strOpeningTag = '<strong>' , $ strClosingTag = '</strong>' ) { if ( $ strString == '' || $ strPhrase == '' ) { return $ strString ; } return preg_replace ( '/(' . preg_quote ( $ strPhrase , '/' ) . ')/i' , $ strOpeningTag . '\\1' . $ strClosingTag , $ strString ) ; }
9659	public static function createReader ( $ readerType ) { if ( ! isset ( self :: $ readers [ $ readerType ] ) ) { throw new Reader \ Exception ( "No reader found for type $readerType" ) ; } $ className = self :: $ readers [ $ readerType ] ; $ reader = new $ className ( ) ; return $ reader ; }
2436	public function getData ( ) { $ data = $ this -> sessionBag -> all ( ) ; foreach ( $ this -> mappedKeys as $ strKey ) { unset ( $ data [ $ strKey ] ) ; if ( $ this -> session -> has ( $ strKey ) ) { $ data [ $ strKey ] = $ this -> session -> get ( $ strKey ) ; } } return $ data ; }
2300	public static function getSystemMessages ( ) { $ strMessages = '' ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getSystemMessages' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getSystemMessages' ] ) ) { $ arrMessages = array ( ) ; foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getSystemMessages' ] as $ callback ) { $ strBuffer = System :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( ) ; if ( $ strBuffer != '' ) { $ arrMessages [ ] = $ strBuffer ; } } if ( ! empty ( $ arrMessages ) ) { $ strMessages .= implode ( "\n" , $ arrMessages ) ; } } return $ strMessages ; }
9537	private function getPrefix ( $ parameter ) { $ prefix = null ; foreach ( array_keys ( $ this -> parameterCluster -> prefixes ) as $ _prefix ) { if ( substr ( $ parameter , 0 , strlen ( $ _prefix ) ) == $ _prefix ) { $ prefix = $ _prefix ; } } return $ prefix ; }
10260	public function getIp ( ) { $ parts = [ ] ; for ( $ i = 0 ; $ i < 4 ; $ i ++ ) { $ parts [ ] = $ this -> getInteger ( 0 , 255 ) ; } return join ( '.' , $ parts ) ; }
3255	public function scopeWhereUser ( $ query , $ userId ) { return $ query -> join ( Config :: get ( 'shop.order_table' ) , Config :: get ( 'shop.order_table' ) . '.id' , '=' , Config :: get ( 'shop.transaction_table' ) . '.order_id' ) -> where ( Config :: get ( 'shop.order_table' ) . '.user_id' , $ userId ) ; }
12878	public function setValue ( $ value ) { $ this -> value = $ value ; if ( is_array ( $ value ) && array_key_exists ( 'start' , $ value ) && array_key_exists ( 'end' , $ value ) ) { $ start = ( float ) $ value [ 'start' ] ; $ end = ( float ) $ value [ 'end' ] ; if ( $ start <= $ end ) { $ this -> startElement -> setValue ( $ start ) ; $ this -> endElement -> setValue ( $ end ) ; } } return $ this ; }
7330	private function configureSubjectRelativeMapping ( LoadClassMetadataEventArgs $ eventArgs ) { $ metadata = $ eventArgs -> getClassMetadata ( ) ; $ class = $ metadata -> getName ( ) ; if ( ! is_subclass_of ( $ class , SubjectRelativeInterface :: class ) ) { return ; } if ( in_array ( $ class , $ this -> relativeClassCache ) ) { return ; } $ this -> getSubjectIdentityMapper ( $ eventArgs -> getEntityManager ( ) ) -> processClassMetadata ( $ metadata , 'subjectIdentity' , 'subject_' ) ; $ this -> relativeClassCache [ ] = $ class ; }
7206	public function addTaxAdjustment ( Adjustment $ tax ) : void { foreach ( $ this -> taxes as $ t ) { if ( $ t -> isSameAs ( $ tax ) ) { $ t -> addAmount ( $ tax -> getAmount ( ) ) ; return ; } } $ this -> taxes [ ] = clone $ tax ; }
5161	public function attach ( string $ field , Model $ item ) : self { $ this -> attachment [ $ field ] [ ] = $ item ; return $ this ; }
10153	private function readVcenter ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; if ( ! $ this -> readDataOnly ) { $ isVerticalCentered = ( bool ) self :: getUInt2d ( $ recordData , 0 ) ; $ this -> phpSheet -> getPageSetup ( ) -> setVerticalCentered ( $ isVerticalCentered ) ; } }
7525	function select ( $ query = '*' , $ index = false , $ recursive = true , $ check_self = false ) { return $ this -> root -> select ( $ query , $ index , $ recursive , $ check_self ) ; }
3260	protected function process ( Request $ request ) { $ validator = Validator :: make ( [ 'order_id' => $ request -> get ( 'order_id' ) , 'status' => $ request -> get ( 'status' ) , 'shoptoken' => $ request -> get ( 'shoptoken' ) , ] , [ 'order_id' => 'required|exists:' . config ( 'shop.order_table' ) . ',id' , 'status' => 'required|in:success,fail' , 'shoptoken' => 'required|exists:' . config ( 'shop.transaction_table' ) . ',token,order_id,' . $ request -> get ( 'order_id' ) , ] ) ; if ( $ validator -> fails ( ) ) { abort ( 404 ) ; } $ order = call_user_func ( config ( 'shop.order' ) . '::find' , $ request -> get ( 'order_id' ) ) ; $ transaction = $ order -> transactions ( ) -> where ( 'token' , $ request -> get ( 'shoptoken' ) ) -> first ( ) ; Shop :: callback ( $ order , $ transaction , $ request -> get ( 'status' ) , $ request -> all ( ) ) ; $ transaction -> token = null ; $ transaction -> save ( ) ; return redirect ( ) -> route ( config ( 'shop.callback_redirect_route' ) , [ 'orderId' => $ order -> id ] ) ; }
12320	public static function getBundleLocationName ( string $ sName ) : string { $ oConfig = self :: get ( $ sName , null , true ) ; if ( isset ( $ oConfig -> redirect ) ) { return $ oConfig -> redirect ; } else { return PORTAL ; } }
6326	public static function getClassNameWithoutNamespace ( $ object ) { $ className = get_class ( $ object ) ; if ( preg_match ( '@\\\\([\w]+)$@' , $ className , $ matches ) ) { $ className = $ matches [ 1 ] ; } return $ className ; }
10958	private function processFiles ( ) { foreach ( $ this -> currentCommand -> getFilesToMove ( ) as $ fileToMove ) { if ( $ fileToMove instanceof \ SplFileInfo ) { $ this -> processSplFileInfo ( $ fileToMove ) ; } else { $ this -> processArray ( $ fileToMove ) ; } } }
3818	private function generateForm ( $ table , $ metaModel , Request $ request ) { $ fields = [ ] ; foreach ( $ metaModel -> getAttributes ( ) as $ attribute ) { $ attrId = $ attribute -> get ( 'id' ) ; if ( ! $ this -> accepts ( $ attribute ) ) { continue ; } if ( $ this -> knowsAttribute ( $ attribute ) ) { $ fields [ ] = [ 'checkbox' => false , 'text' => $ this -> checkboxCaption ( 'addAll_alreadycontained' , $ table , $ attribute ) , 'class' => 'tl_info' , 'attr_id' => $ attrId , 'name' => 'attribute_' . $ attrId ] ; continue ; } elseif ( $ this -> isAttributeSubmitted ( $ attrId , $ request ) ) { $ fields [ ] = array ( 'checkbox' => false , 'text' => $ this -> checkboxCaption ( 'addAll_addsuccess' , $ table , $ attribute ) , 'class' => 'tl_confirm' , 'attr_id' => $ attrId , 'name' => 'attribute_' . $ attrId ) ; continue ; } $ fields [ ] = [ 'checkbox' => true , 'text' => $ this -> checkboxCaption ( 'addAll_willadd' , $ table , $ attribute ) , 'class' => 'tl_new' , 'attr_id' => $ attrId , 'name' => 'attribute_' . $ attrId ] ; } return $ fields ; }
7143	private function sortAssignments ( array $ assignments , $ direction = SORT_DESC ) { usort ( $ assignments , function ( StockAssignmentInterface $ a , StockAssignmentInterface $ b ) use ( $ direction ) { $ aDate = $ a -> getSaleItem ( ) -> getSale ( ) -> getCreatedAt ( ) ; $ bDate = $ b -> getSaleItem ( ) -> getSale ( ) -> getCreatedAt ( ) ; if ( $ aDate == $ bDate ) { return 0 ; } if ( $ direction === SORT_ASC ) { return $ aDate < $ bDate ? - 1 : 1 ; } return $ aDate > $ bDate ? - 1 : 1 ; } ) ; return $ assignments ; }
9908	public function setPosition ( $ position ) { if ( ! in_array ( $ position , self :: $ positionXLref ) ) { return false ; } $ this -> position = $ position ; return true ; }
7786	public function createStatement ( AccountInterface $ account , $ number ) { return $ this -> createObject ( $ this -> statementClass , 'Jejik\MT940\StatementInterface' , array ( $ account , $ number ) ) ; }
9935	public function setOperator ( $ pOperator ) { if ( empty ( $ pOperator ) ) { $ pOperator = self :: AUTOFILTER_COLUMN_RULE_EQUAL ; } if ( ( ! in_array ( $ pOperator , self :: $ operators ) ) && ( ! in_array ( $ pOperator , self :: $ topTenValue ) ) ) { throw new PhpSpreadsheetException ( 'Invalid operator for column AutoFilter Rule.' ) ; } $ this -> operator = $ pOperator ; return $ this ; }
6605	public function validateRequestTokenResponse ( $ params ) { if ( ! isset ( $ params [ 'oauth_token' ] ) || ! isset ( $ params [ 'oauth_token_secret' ] ) || empty ( $ params [ 'oauth_token' ] ) || empty ( $ params [ 'oauth_token_secret' ] ) ) { throw new InvalidOAuthTokenException ( 'request token' ) ; } return true ; }
11896	protected function generateIV ( ) { $ sizeIV = $ this -> getSizeIV ( ) ; if ( $ sizeIV === 0 ) { return $ this ; } $ this -> setIV ( mcrypt_create_iv ( $ sizeIV , MCRYPT_RAND ) ) ; return $ this ; }
7753	public function serialize ( $ data , $ format , array $ context = array ( ) ) { if ( 'jsonld' !== $ format ) { throw new UnexpectedValueException ( 'Serialization for the format ' . $ format . ' is not supported' ) ; } if ( false === is_object ( $ data ) ) { throw new \ Exception ( 'Only objects can be serialized' ) ; } return JsonLD :: toString ( $ this -> doSerialize ( $ data , true ) , true ) ; }
411	private function utf8Encode ( $ s ) { $ s .= $ s ; $ len = \ strlen ( $ s ) ; for ( $ i = $ len >> 1 , $ j = 0 ; $ i < $ len ; ++ $ i , ++ $ j ) { switch ( true ) { case $ s [ $ i ] < "\x80" : $ s [ $ j ] = $ s [ $ i ] ; break ; case $ s [ $ i ] < "\xC0" : $ s [ $ j ] = "\xC2" ; $ s [ ++ $ j ] = $ s [ $ i ] ; break ; default : $ s [ $ j ] = "\xC3" ; $ s [ ++ $ j ] = \ chr ( \ ord ( $ s [ $ i ] ) - 64 ) ; break ; } } return substr ( $ s , 0 , $ j ) ; }
10663	public function setParamType ( $ type ) { if ( ! is_string ( $ type ) || ! in_array ( $ type , [ self :: PARAM_MULTIPART , self :: PARAM_FORM ] ) ) { throw new InvalidArgumentException ( sprintf ( "Invalid parameter form type, form type only allowed $1s and $2s" , self :: PARAM_FORM , self :: PARAM_MULTIPART ) , E_USER_ERROR ) ; } $ this -> currentParamType = $ type ; $ reverse_params = $ type == self :: PARAM_FORM ? self :: PARAM_MULTIPART : self :: PARAM_FORM ; $ reverse_params_value = isset ( $ this -> configs [ $ reverse_params ] ) ? $ this -> configs [ $ reverse_params ] : null ; $ params_value = isset ( $ this -> configs [ $ type ] ) ? $ this -> configs [ $ type ] : null ; unset ( $ this -> configs [ self :: PARAM_FORM ] , $ this -> configs [ self :: PARAM_MULTIPART ] ) ; $ this -> configs [ $ type ] = is_array ( $ reverse_params_value ) ? $ reverse_params_value : ( is_array ( $ params_value ) ? $ params_value : [ ] ) ; return $ this -> buildConfigClient ( ) ; }
8448	public function broadcastMsg ( array $ peers , $ msg ) { $ peerList = $ this -> formatPeers ( $ peers ) ; return $ this -> exec ( 'broadcast ' . $ peerList . ' ' . $ msg ) ; }
11800	public function substitution ( $ search , $ replace ) { $ this -> body = str_replace ( $ search , $ replace , $ this -> body ) ; return $ this -> body ; }
8084	public function clearErrors ( $ channelName = '' ) { $ channel = $ this -> namespaceChannel ( $ channelName ) ; $ this -> console [ 'errors' ] [ $ channel ] = array ( ) ; $ this -> console [ 'form' ] [ $ channel ] = array ( ) ; }
6373	public function filterBy ( string $ className ) : FluentIterable { return self :: from ( Iterables :: filterBy ( $ this , $ className ) ) ; }
10385	protected static function unify_params ( $ type , $ field , $ default = '' ) { $ data = array_column ( self :: $ data [ $ type ] , $ field ) ; switch ( $ field ) { case 'media' : case 'footer' : case 'version' : foreach ( $ data as $ key => $ value ) { if ( $ data [ 0 ] !== $ value ) { return $ default ; } } return ( isset ( $ data [ 0 ] ) && $ data [ 0 ] ) ? $ data [ 0 ] : $ default ; default : $ params = [ ] ; foreach ( $ data as $ key => $ value ) { $ params = array_merge ( $ params , $ value ) ; } return array_unique ( $ params ) ; } }
12176	public function addClassArgument ( $ name , $ class , $ required = true ) { return $ this -> addArgument ( new ClassArgument ( $ this -> argumentPosition ++ , $ name , $ class , $ required ) ) ; }
4741	private function createProfilerProbes ( $ name , ContainerBuilder $ container ) { $ key = sprintf ( "socloz_monitoring.profiler.probe.definition.%s" , $ name ) ; if ( $ container -> hasParameter ( $ key ) ) { $ definition = $ container -> getParameter ( $ key ) ; return array ( $ this -> createProbeDefinition ( $ name , Probe :: TRACKER_CALLS | Probe :: TRACKER_TIMING , $ definition , $ container ) ) ; } else { return array ( $ this -> createProbeDefinition ( $ name , Probe :: TRACKER_CALLS , $ container -> getParameter ( $ key . '.calls' ) , $ container ) , $ this -> createProbeDefinition ( $ name , Probe :: TRACKER_TIMING , $ container -> getParameter ( $ key . '.timing' ) , $ container ) , ) ; } }
6432	public function removeDisplayField ( $ displayField ) { $ key = array_search ( $ displayField , $ this -> displayFields ) ; if ( $ key ) { unset ( $ this -> displayFields [ $ key ] ) ; $ this -> displayFields = array_values ( $ this -> displayFields ) ; } }
1157	protected function ruleConfirmed ( $ attribute , array $ parameters ) { $ parameters [ 0 ] = $ this -> getAttributeName ( $ attribute ) ; $ attribute = "{$attribute}_confirmation" ; return [ $ attribute , $ parameters ] ; }
4184	public function getFile ( $ class ) { if ( is_null ( $ this -> count ) ) { return $ this -> fileHas ( $ class ) -> getFile ( $ class ) ; } if ( isset ( $ this -> files [ $ class ] ) ) { return $ this -> files [ $ class ] ; } throw new FileException ( "File does not exists with given `{$class}` class." ) ; }
1401	protected function isNoContent ( $ resource , $ links , $ meta ) { return is_null ( $ resource ) && empty ( $ links ) && empty ( $ meta ) ; }
5591	public function fetchResponse ( $ url , $ encoding ) { if ( ! in_array ( $ encoding -> getMethod ( ) , array ( 'POST' , 'PUT' ) ) ) { $ url -> addRequestParameters ( $ encoding ) ; $ encoding -> clear ( ) ; } $ response = $ this -> fetchWhileRedirected ( $ url , $ encoding ) ; if ( $ headers = $ response -> getHeaders ( ) ) { if ( $ headers -> isChallenge ( ) ) { $ this -> authenticator -> addRealm ( $ url , $ headers -> getAuthentication ( ) , $ headers -> getRealm ( ) ) ; } } return $ response ; }
3115	public function storeItemHrefIndex ( $ testSessionId , $ table ) { $ extendedState = $ this -> getExtendedState ( $ testSessionId ) ; $ extendedState -> setItemHrefIndex ( $ table ) ; $ extendedState -> save ( ) ; }
2045	public function generate ( ) { if ( TL_MODE == 'BE' ) { $ return = '<pre>' . htmlspecialchars ( $ this -> code ) . '</pre>' ; if ( $ this -> headline != '' ) { $ return = '<' . $ this -> hl . '>' . $ this -> headline . '</' . $ this -> hl . '>' . $ return ; } return $ return ; } return parent :: generate ( ) ; }
12504	public static function rollbackTransaction ( $ connection ) { $ connection -> query = 'ROLLBACK' ; $ connection -> method = 'POST' ; $ connection -> action = '/_query' ; return self :: sendQuery ( $ connection ) ; }
1384	protected function isNotFound ( string $ type , string $ id ) : bool { return ! $ this -> store -> exists ( ResourceIdentifier :: create ( $ type , $ id ) ) ; }
555	private function notifyNotFoundCaches ( $ cachesNames ) { $ this -> stdout ( "The following cache components were NOT found:\n\n" , Console :: FG_RED ) ; foreach ( $ cachesNames as $ name ) { $ this -> stdout ( "\t* $name \n" , Console :: FG_GREEN ) ; } $ this -> stdout ( "\n" ) ; }
8792	public function tag ( $ tag , $ content , array $ attributes = [ ] ) { $ content = is_array ( $ content ) ? implode ( PHP_EOL , $ content ) : $ content ; return $ this -> toHtmlString ( '<' . $ tag . $ this -> attributes ( $ attributes ) . '>' . PHP_EOL . $ this -> toHtmlString ( $ content ) . PHP_EOL . '</' . $ tag . '>' . PHP_EOL ) ; }
6492	private function getBestMediaTypeFormatterMatch ( string $ type , array $ formatters , array $ mediaTypeHeaders , string $ ioType ) : ? MediaTypeFormatterMatch { if ( count ( $ mediaTypeHeaders ) > 0 && $ mediaTypeHeaders [ 0 ] instanceof IHeaderValueWithQualityScore ) { $ mediaTypeHeaders = $ this -> rankAcceptMediaTypeHeaders ( $ mediaTypeHeaders ) ; } foreach ( $ mediaTypeHeaders as $ mediaTypeHeader ) { [ $ mediaType , $ mediaSubType ] = explode ( '/' , $ mediaTypeHeader -> getMediaType ( ) ) ; foreach ( $ formatters as $ formatter ) { foreach ( $ formatter -> getSupportedMediaTypes ( ) as $ supportedMediaType ) { if ( $ ioType === self :: FORMATTER_TYPE_INPUT && ! $ formatter -> canReadType ( $ type ) ) { continue ; } if ( $ ioType === self :: FORMATTER_TYPE_OUTPUT && ! $ formatter -> canWriteType ( $ type ) ) { continue ; } [ $ supportedType , $ supportedSubType ] = explode ( '/' , $ supportedMediaType ) ; if ( $ mediaType === '*' || ( $ mediaSubType === '*' && $ mediaType === $ supportedType ) || ( $ mediaType === $ supportedType && $ mediaSubType === $ supportedSubType ) ) { return new MediaTypeFormatterMatch ( $ formatter , $ supportedMediaType , $ mediaTypeHeader ) ; } } } } return null ; }
11483	public function getFactory ( $ class , array $ params = array ( ) ) { if ( ! isset ( $ this -> factories [ $ class ] ) && $ this -> autowire ) { $ this -> factories [ $ class ] = Definition :: getDefaultForClass ( $ class ) ; } $ factory = $ this -> factories [ $ class ] ; if ( $ params ) { $ factory = $ factory -> getFactory ( $ params ) ; } return $ factory ; }
9961	public function freezePane ( $ cell , $ topLeftCell = null ) { if ( is_string ( $ cell ) && Coordinate :: coordinateIsRange ( $ cell ) ) { throw new Exception ( 'Freeze pane can not be set on a range of cells.' ) ; } if ( $ cell !== null && $ topLeftCell === null ) { $ coordinate = Coordinate :: coordinateFromString ( $ cell ) ; $ topLeftCell = $ coordinate [ 0 ] . $ coordinate [ 1 ] ; } $ this -> freezePane = $ cell ; $ this -> topLeftCell = $ topLeftCell ; return $ this ; }
11271	public function render ( $ template , array $ vars = array ( ) ) { ob_start ( ) ; try { $ this -> display ( $ template , $ vars ) ; } catch ( Exception $ exception ) { ob_end_clean ( ) ; throw $ exception ; } return ob_get_clean ( ) ; }
8625	public function setTemporarilyUnavailableCarrierList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'TemporarilyUnavailableCarrierList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
7847	public function info ( int $ id ) : ? array { $ this -> checkConfig ( ) ; $ key = sprintf ( 'smsgatewayme.info.%s' , $ id ) ; if ( $ this -> cache === true and Cache :: has ( $ key ) ) { $ message = [ 'code' => 200 , 'message' => 'OK' , 'data' => Cache :: get ( $ key ) , ] ; } else { $ response = Request :: get ( $ this -> baseUrl . 'message/' . $ id ) ; if ( $ response -> code == 200 ) { Cache :: put ( $ key , $ response -> body , 3600 * 24 ) ; } else { if ( ! empty ( $ response -> body -> message ) ) { Log :: error ( $ response -> body -> message ) ; } } $ message = [ 'code' => $ response -> code , 'message' => ( $ response -> code == 200 ) ? 'OK' : $ response -> body -> message ?? '' , 'data' => $ response -> body , ] ; } return $ message ; }
12219	public function errorHandler ( $ errno , $ errstr , $ errfile , $ errline , array $ errcontext = [ ] ) { $ codes = array ( 256 => 'E_USER_ERROR' , 512 => 'E_USER_WARNING' , 1024 => 'E_USER_NOTICE' , 2048 => 'E_STRICT' , 4096 => 'E_RECOVERABLE_ERROR' , 8192 => 'E_DEPRECATED' , 16384 => 'E_USER_DEPRECATED' , 8 => 'E_NOTICE' , 2 => 'E_WARNING' ) ; $ message = 'Error of level ' ; if ( array_key_exists ( $ errno , $ codes ) ) { $ message .= $ codes [ $ errno ] ; } else { $ message .= sprintf ( 'Unknown error level, code of %d passed' , $ errno ) ; } $ message .= sprintf ( '. Error message was "%s" in file %s at line %d.' , $ errstr , $ errfile , $ errline ) ; $ this -> container [ 'log' ] -> error ( $ message , $ errcontext ) ; $ this -> exceptionHandler ( new InternalServerError ( 'An unexpected error occurred.' ) ) ; }
6808	public function number ( float $ number ) : string { return $ this -> getNumberFormatter ( ) -> format ( $ number , NumberFormatter :: TYPE_DEFAULT ) ; }
2223	protected function doGetTemplateFolders ( $ path , $ level = 0 ) { $ return = array ( ) ; $ rootDir = Contao \ System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; foreach ( scan ( $ rootDir . '/' . $ path ) as $ file ) { if ( is_dir ( $ rootDir . '/' . $ path . '/' . $ file ) ) { $ return [ $ path . '/' . $ file ] = str_repeat ( ' &nbsp; &nbsp; ' , $ level ) . $ file ; $ return = array_merge ( $ return , $ this -> doGetTemplateFolders ( $ path . '/' . $ file , $ level + 1 ) ) ; } } return $ return ; }
2458	public function undo ( ) { $ objRecords = $ this -> Database -> prepare ( "SELECT * FROM " . $ this -> strTable . " WHERE id=?" ) -> limit ( 1 ) -> execute ( $ this -> intId ) ; if ( $ objRecords -> numRows < 1 ) { $ this -> redirect ( $ this -> getReferer ( ) ) ; } $ error = false ; $ query = $ objRecords -> query ; $ data = StringUtil :: deserialize ( $ objRecords -> data ) ; if ( ! \ is_array ( $ data ) ) { $ this -> redirect ( $ this -> getReferer ( ) ) ; } $ arrFields = array ( ) ; foreach ( $ data as $ table => $ fields ) { $ this -> loadDataContainer ( $ table ) ; if ( ! isset ( $ arrFields [ $ table ] ) ) { $ arrFields [ $ table ] = array_flip ( $ this -> Database -> getFieldNames ( $ table ) ) ; } foreach ( $ fields as $ row ) { $ row = array_intersect_key ( $ row , $ arrFields [ $ table ] ) ; $ objInsertStmt = $ this -> Database -> prepare ( "INSERT INTO " . $ table . " %s" ) -> set ( $ row ) -> execute ( ) ; if ( $ objInsertStmt -> affectedRows < 1 ) { $ error = true ; } if ( \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ table ] [ 'config' ] [ 'onundo_callback' ] ) ) { foreach ( $ GLOBALS [ 'TL_DCA' ] [ $ table ] [ 'config' ] [ 'onundo_callback' ] as $ callback ) { if ( \ is_array ( $ callback ) ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ table , $ row , $ this ) ; } elseif ( \ is_callable ( $ callback ) ) { $ callback ( $ table , $ row , $ this ) ; } } } } } if ( ! $ error ) { $ this -> log ( 'Undone ' . $ query , __METHOD__ , TL_GENERAL ) ; $ this -> Database -> prepare ( "DELETE FROM " . $ this -> strTable . " WHERE id=?" ) -> limit ( 1 ) -> execute ( $ this -> intId ) ; } $ this -> redirect ( $ this -> getReferer ( ) ) ; }
5539	protected function getPublicNameFromIndex ( $ subject ) { foreach ( $ this -> names as $ name => $ index ) { if ( $ subject == $ index ) { return $ name ; } } return $ subject + 1 ; }
9804	public function setModified ( $ time ) { if ( $ time === null ) { $ time = time ( ) ; } elseif ( is_string ( $ time ) ) { if ( is_numeric ( $ time ) ) { $ time = ( int ) $ time ; } else { $ time = strtotime ( $ time ) ; } } $ this -> modified = $ time ; return $ this ; }
9183	protected function forgetByKey ( $ key ) { $ result = false ; if ( Cache :: has ( $ key ) ) { $ result = Cache :: forget ( $ key ) ; } return $ result ; }
2348	public static function putContent ( $ strFile , $ strContent ) { $ objFile = new static ( $ strFile ) ; $ objFile -> write ( $ strContent ) ; $ objFile -> close ( ) ; }
5653	private function longestFlag ( $ flag_sets ) { $ longest = 0 ; foreach ( $ flag_sets as $ flags ) { foreach ( $ flags as $ flag ) { $ longest = max ( $ longest , strlen ( $ this -> renderFlag ( $ flag ) ) ) ; } } return $ longest ; }
9306	public function setAllowJsonApi ( $ allowJsonApi ) { if ( ! is_bool ( $ allowJsonApi ) ) { throw new \ InvalidArgumentException ( '`allowJsonApi` expects boolean value!' ) ; } $ this -> options [ 'allowJsonApi' ] = ( bool ) $ allowJsonApi ; return $ this ; }
1251	private function startElement ( $ parser , $ name , array $ attributes ) { $ this -> metaStack -> push ( $ this -> getPhpMeta ( $ this -> normalizeElementName ( $ name ) , $ attributes ) ) ; }
10908	public function instance ( object $ object ) : Binding { if ( ! $ object instanceof $ this -> definition -> typeName ) { throw new \ InvalidArgumentException ( \ sprintf ( '%s is not an instance of %s' , \ get_class ( $ object ) , $ this -> definition -> typeName ) ) ; } $ this -> definition -> instantiator = new Instance ( $ object ) ; return $ this ; }
11540	protected function resolveAddOptions ( array $ options ) { if ( $ this -> optionsResolved ) { return ; } $ this -> optionsResolver -> clear ( ) ; $ this -> optionsResolver -> setRequired ( array ( 'page' , 'language' , 'country' , 'slot' , 'blockname' , 'type' , 'position' , 'direction' , ) ) ; $ this -> optionsResolver -> resolve ( $ options ) ; $ this -> optionsResolved = true ; }
8986	public function get_columns ( ) { return array ( 'id' => new IntegerBased ( 'BIGINT' , 'id' , array ( 'NOT NULL' , 'auto_increment' ) , array ( 20 ) ) , 'message' => new StringBased ( 'VARCHAR' , 'message' , array ( ) , array ( 255 ) ) , 'level' => new StringBased ( 'VARCHAR' , 'level' , array ( ) , array ( 20 ) ) , 'lgroup' => new StringBased ( 'VARCHAR' , 'lgroup' , array ( ) , array ( 20 ) ) , 'time' => new DateTime ( 'time' ) , 'user' => new ForeignUser ( 'user' ) , 'ip' => new StringBased ( 'VARCHAR' , 'ip' , array ( ) , array ( 45 ) ) , 'exception' => new StringBased ( 'VARCHAR' , 'exception' , array ( ) , array ( 255 ) ) , 'trace' => new StringBased ( 'LONGTEXT' , 'trace' ) , 'context' => new StringBased ( 'LONGTEXT' , 'context' ) , ) ; }
12516	public static function delete ( $ path ) { if ( ! Folder :: exists ( $ path ) ) { return true ; } $ path = Path :: clean ( $ path ) ; if ( trim ( $ path ) === '' ) { throw new Exception ( Helper :: getTranslation ( 'FAILED_DELETING' ) . ' : Cannot delete root path' ) ; } $ fs = new Filesystem ( ) ; try { $ fs -> remove ( $ path ) ; } catch ( IOExceptionInterface $ e ) { throw new Exception ( Helper :: getTranslation ( 'FAILED_DELETING' ) . ' - (' . $ e -> getMessage ( ) . ')' ) ; } return true ; }
7182	protected function generateKey ( PaymentInterface $ payment ) { if ( 0 == strlen ( $ payment -> getKey ( ) ) ) { $ this -> keyGenerator -> generate ( $ payment ) ; return true ; } return false ; }
4417	public function showLocationLayouts ( $ locationId ) { $ repository = $ this -> getRepository ( ) ; $ location = $ repository -> getLocationService ( ) -> loadLocation ( $ locationId ) ; $ content = $ repository -> getContentService ( ) -> loadContent ( $ location -> contentInfo -> id ) ; $ request = $ this -> createRequest ( $ content , $ location ) ; return $ this -> render ( '@NetgenAdminUI/layouts/location_layouts.html.twig' , array ( 'rules' => $ this -> layoutResolver -> resolveRules ( $ request , array ( 'ez_content_type' ) ) , 'related_layouts' => $ this -> relatedLayoutsLoader -> loadRelatedLayouts ( $ location ) , 'location' => $ location , ) ) ; }
4106	public function commitBulk ( ) { if ( $ this -> bulk && $ this -> bulk -> count ( ) ) { $ result = $ this -> bulk -> commit ( ) ; $ this -> bulk = null ; return $ result ; } }
7012	private function formatF ( & $ str ) { if ( strstr ( $ str , '%F' ) ) $ str = str_replace ( '%F' , $ this -> monthName ( true ) , $ str ) ; }
10537	public function prepareHeaders ( $ requestHeaders ) { $ responseHeaders = [ ] ; if ( isset ( $ requestHeaders [ 'Origin' ] , $ this -> cors [ 'Origin' ] ) ) { if ( in_array ( '*' , $ this -> cors [ 'Origin' ] ) || in_array ( $ requestHeaders [ 'Origin' ] , $ this -> cors [ 'Origin' ] ) ) { $ responseHeaders [ 'Access-Control-Allow-Origin' ] = $ requestHeaders [ 'Origin' ] ; } } $ this -> prepareAllowHeaders ( 'Headers' , $ requestHeaders , $ responseHeaders ) ; if ( isset ( $ requestHeaders [ 'Access-Control-Request-Method' ] ) ) { $ responseHeaders [ 'Access-Control-Allow-Methods' ] = implode ( ', ' , $ this -> cors [ 'Access-Control-Request-Method' ] ) ; } if ( isset ( $ this -> cors [ 'Access-Control-Allow-Credentials' ] ) ) { $ responseHeaders [ 'Access-Control-Allow-Credentials' ] = $ this -> cors [ 'Access-Control-Allow-Credentials' ] ? 'true' : 'false' ; } if ( isset ( $ this -> cors [ 'Access-Control-Max-Age' ] ) && Yii :: $ app -> getRequest ( ) -> getIsOptions ( ) ) { $ responseHeaders [ 'Access-Control-Max-Age' ] = $ this -> cors [ 'Access-Control-Max-Age' ] ; } if ( isset ( $ this -> cors [ 'Access-Control-Expose-Headers' ] ) ) { $ responseHeaders [ 'Access-Control-Expose-Headers' ] = implode ( ', ' , $ this -> cors [ 'Access-Control-Expose-Headers' ] ) ; } return $ responseHeaders ; }
3592	protected function loadMetaAttributes ( ) { if ( ! array_key_exists ( 'metaAttributes' , $ this -> relations ) ) { $ this -> reloadMetaAttributes ( ) ; } $ attributes = $ this -> getRelation ( 'metaAttributes' ) ; if ( ! $ attributes instanceof AttributeBag ) { $ this -> setRelation ( 'metaAttributes' , ( new Attribute ) -> newBag ( $ attributes -> all ( ) ) ) ; } }
10142	private function readDefault ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ this -> pos += 4 + $ length ; }
3120	public function remove ( $ tag , $ target = TimePoint :: TARGET_ALL , $ type = TimePoint :: TYPE_ALL ) { $ tags = is_array ( $ tag ) ? $ tag : [ $ tag ] ; $ removed = 0 ; foreach ( $ this -> points as $ idx => $ point ) { if ( $ point -> match ( $ tags , $ target , $ type ) ) { unset ( $ this -> points [ $ idx ] ) ; $ removed ++ ; } } return $ removed ; }
12889	public function getIdentity ( $ view ) { if ( ! isset ( $ view -> assetBundles [ $ this -> identityAssetBundle ] ) ) { return false ; } return Yii :: $ app -> assetManager -> getBundle ( $ this -> identityAssetBundle ) ; }
6958	public function setForcedRedirect ( $ url ) { $ data = $ this -> getData ( true ) ; $ data [ static :: $ forcedRedirectKey ] = $ url ; return $ this -> setData ( $ data ) ; }
6577	public function getList ( $ sort = null ) { $ countries = $ this -> getCountries ( ) ; $ validSorts = array ( 'name' , 'fullname' , 'iso_3166_2' , 'iso_3166_3' , 'capital' , 'citizenship' , 'currency' , 'currency_code' , 'calling_code' ) ; if ( ! is_null ( $ sort ) && in_array ( $ sort , $ validSorts ) ) { uasort ( $ countries , function ( $ a , $ b ) use ( $ sort ) { if ( ! isset ( $ a [ $ sort ] ) && ! isset ( $ b [ $ sort ] ) ) { return 0 ; } elseif ( ! isset ( $ a [ $ sort ] ) ) { return - 1 ; } elseif ( ! isset ( $ b [ $ sort ] ) ) { return 1 ; } else { return strcasecmp ( $ a [ $ sort ] , $ b [ $ sort ] ) ; } } ) ; } return $ countries ; }
5422	protected function readAll ( $ socket ) { $ all = '' ; while ( ! $ this -> isLastPacket ( $ next = $ socket -> read ( ) ) ) { $ all .= $ next ; } return $ all ; }
12388	public function logout ( AdapterChainEvent $ e ) { $ session = new Container ( $ this -> getStorage ( ) -> getNameSpace ( ) ) ; $ session -> getManager ( ) -> forgetMe ( ) ; $ session -> getManager ( ) -> destroy ( ) ; }
3439	public function section ( $ load = false ) { $ fields = $ this -> getFields ( ) ; $ sectionModel = static :: sectionModel ( ) ; return $ load ? $ sectionModel :: query ( ) -> getById ( $ fields [ 'IBLOCK_SECTION_ID' ] ) : new $ sectionModel ( $ fields [ 'IBLOCK_SECTION_ID' ] ) ; }
8870	public function detach ( Runner $ runner ) { if ( ! $ this -> runners -> contains ( $ runner ) ) { throw new LogicException ( 'Can\'t detach not attached runner.' ) ; } $ this -> runners -> detach ( $ runner ) ; return $ this ; }
12350	public function validate ( string $ api_session = null ) { $ this -> details = false ; if ( empty ( $ api_session ) === false && is_string ( $ api_session ) === true ) { $ session = Model \ Session :: with ( 'user' ) -> where ( 'code' , $ api_session ) -> first ( ) ; if ( $ session !== null ) { if ( strtotime ( $ session -> updated_at ) < strtotime ( "-1 hour" ) || $ session -> user === null ) { $ this -> invalidate ( $ api_session ) ; } else { $ session -> updated_at = date ( 'Y-m-d H:i:s' ) ; $ session -> save ( ) ; $ this -> details = $ session -> user ; } } else { $ _SESSION [ 'api_session' ] = null ; } } }
2609	public function getNextVersion ( array $ versions ) { if ( isset ( end ( $ versions ) -> number ) ) { return ( int ) end ( $ versions ) -> number + 1 ; } throw new LocalizedException ( __ ( 'Error fetching next version.' ) ) ; }
10761	public function encodeString ( $ string ) { $ string = strtolower ( $ string ) ; $ src = "abcdefghijklmnopqrstuvwxyz0123456789 " ; $ dst = "jklmnopqrstuvwxyz0123456789abcdefghi " ; for ( $ i = 0 ; $ i < strlen ( $ string ) ; $ i ++ ) { $ pos = strpos ( $ src , $ string [ $ i ] ) ; if ( $ pos === false ) { throw new \ Exception ( "Please provide only numbers and alphanumerical characters" ) ; } $ string [ $ i ] = $ dst [ $ pos ] ; } return $ string ; }
12438	public function get ( $ id ) { if ( isset ( $ this -> children [ $ id ] ) ) { return $ this -> children [ $ id ] ; } throw new FormalException ( "Unknown form field '$id' on form '" . get_called_class ( ) . "'. Available fields are: " . implode ( ', ' , array_keys ( $ this -> children ) ) ) ; }
2567	protected function checkAllNotEmpty ( ) { $ foundEmpty = false ; $ args = func_get_args ( ) ; foreach ( $ args as $ arg ) { if ( empty ( $ arg ) ) { $ foundEmpty = true ; break ; } } return ! $ foundEmpty ; }
7080	public function onPreCopy ( SaleTransformEvent $ event ) { $ source = $ event -> getSource ( ) ; if ( $ source instanceof OrderInterface ) { if ( $ source -> getState ( ) !== OrderStates :: STATE_NEW ) { $ event -> addMessage ( new ResourceMessage ( 'ekyna_commerce.sale.message.transform_prevented' , ResourceMessage :: TYPE_ERROR ) ) ; } } }
12264	public function addSource ( $ sourcePath , $ useStrict = true ) { if ( is_link ( $ sourcePath ) ) { return $ this -> addSource ( realpath ( $ sourcePath ) , $ useStrict ) ; } if ( is_dir ( $ sourcePath ) ) { $ this -> sourceDirs [ ] = $ sourcePath ; } elseif ( true === $ useStrict ) { throw new \ Exception ( sprintf ( 'Path {%s} is not a readable directory' , $ sourcePath ) ) ; } return $ this ; }
6864	protected function updateTotals ( InvoiceInterface $ invoice ) { $ changed = $ this -> invoiceCalculator -> calculate ( $ invoice ) ; if ( $ changed ) { foreach ( $ invoice -> getLines ( ) as $ line ) { $ this -> persistenceHelper -> persistAndRecompute ( $ line , false ) ; } } return $ changed ; }
11059	public static function files ( $ path , array $ extensions = array ( ) ) { $ files = array ( ) ; $ it = new \ RecursiveDirectoryIterator ( $ path ) ; $ filter = false ; if ( ! empty ( $ extensions ) && is_array ( $ extensions ) ) { $ filter = true ; } foreach ( new \ RecursiveIteratorIterator ( $ it ) as $ file ) { if ( $ filter ) { $ f = explode ( '.' , $ file ) ; $ ext = strtolower ( array_pop ( $ f ) ) ; if ( in_array ( $ ext , $ extensions ) ) { $ files [ ] = $ file ; } } else { $ files [ ] = $ file ; } } return $ files ; }
3390	public function redirectAfterResendConfirmationPath ( ) { if ( method_exists ( $ this , 'redirectAfterResendConfirmationTo' ) ) { return $ this -> redirectAfterResendConfirmationTo ( ) ; } return property_exists ( $ this , 'redirectAfterResendConfirmationTo' ) ? $ this -> redirectAfterResendConfirmationTo : route ( 'login' ) ; }
10125	private function writeAutoFilterInfo ( ) { $ record = 0x009D ; $ length = 0x0002 ; $ rangeBounds = Coordinate :: rangeBoundaries ( $ this -> phpSheet -> getAutoFilter ( ) -> getRange ( ) ) ; $ iNumFilters = 1 + $ rangeBounds [ 1 ] [ 0 ] - $ rangeBounds [ 0 ] [ 0 ] ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ iNumFilters ) ; $ this -> append ( $ header . $ data ) ; }
12283	public function render ( array $ data = null ) : string { $ this -> init ( $ data ?? [ ] ) ; return trim ( $ this -> make ( static :: LAYOUT_NAME ) ) . PHP_EOL ; }
748	protected function buildCompleteString ( $ format ) { $ placeholderValues = [ '{type}' => $ this -> type , '{length}' => $ this -> buildLengthString ( ) , '{unsigned}' => $ this -> buildUnsignedString ( ) , '{notnull}' => $ this -> buildNotNullString ( ) , '{unique}' => $ this -> buildUniqueString ( ) , '{default}' => $ this -> buildDefaultString ( ) , '{check}' => $ this -> buildCheckString ( ) , '{comment}' => $ this -> buildCommentString ( ) , '{pos}' => $ this -> isFirst ? $ this -> buildFirstString ( ) : $ this -> buildAfterString ( ) , '{append}' => $ this -> buildAppendString ( ) , ] ; return strtr ( $ format , $ placeholderValues ) ; }
1826	public function mergeRow ( array $ arrData ) { foreach ( $ arrData as $ k => $ v ) { if ( strpos ( $ k , '__' ) !== false ) { continue ; } if ( ! isset ( $ this -> arrModified [ $ k ] ) ) { $ this -> arrData [ $ k ] = $ v ; } } return $ this ; }
1505	protected function bindPageResolver ( ) : void { AbstractPaginator :: currentPageResolver ( function ( $ pageName ) { $ pagination = app ( EncodingParametersInterface :: class ) -> getPaginationParameters ( ) ? : [ ] ; return $ pagination [ $ pageName ] ?? null ; } ) ; }
12048	public function render ( ElementInterface $ element ) { $ renderer = $ this -> getView ( ) ; if ( $ element instanceof CkEditor ) { $ plugin = $ renderer -> plugin ( 'form_ckeditor' ) ; return $ plugin ( $ element ) ; } return parent :: render ( $ element ) ; }
2037	public function getSlugOptions ( ) { $ slugOptions = array ( 'locale' => $ this -> language ) ; if ( $ this -> validAliasCharacters ) { $ slugOptions [ 'validChars' ] = $ this -> validAliasCharacters ; } return $ slugOptions ; }
8609	private function _convertRegisterDestination ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'RegisterDestination' ; if ( $ request -> isSetSellerId ( ) ) { $ parameters [ 'SellerId' ] = $ request -> getSellerId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } if ( $ request -> isSetMarketplaceId ( ) ) { $ parameters [ 'MarketplaceId' ] = $ request -> getMarketplaceId ( ) ; } if ( $ request -> isSetDestination ( ) ) { $ DestinationRegisterDestinationInput = $ request -> getDestination ( ) ; foreach ( $ DestinationRegisterDestinationInput -> getDeliveryChannel ( ) as $ DeliveryChannelDestinationIndex => $ DeliveryChannelDestination ) { $ parameters [ 'Destination' . '.' . 'DeliveryChannel' . '.' . ( $ DeliveryChannelDestinationIndex + 1 ) ] = $ DeliveryChannelDestination ; } } return $ parameters ; }
8976	public static function typeOf ( $ arg ) { if ( null === $ arg ) { return 'NULL' ; } if ( is_object ( $ arg ) ) { return get_class ( $ arg ) ; } return gettype ( $ arg ) ; }
2086	public static function getPath ( $ template , $ format , $ custom = 'templates' ) { $ file = $ template . '.' . $ format ; $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( file_exists ( $ rootDir . '/' . $ custom . '/' . $ file ) ) { return $ rootDir . '/' . $ custom . '/' . $ file ; } if ( $ custom != 'templates' ) { if ( file_exists ( $ rootDir . '/templates/' . $ file ) ) { return $ rootDir . '/templates/' . $ file ; } } return static :: getDefaultPath ( $ template , $ format ) ; }
1105	protected function applyLockBetween ( $ lft , $ rgt ) { $ this -> node -> newQuery ( ) -> where ( $ this -> node -> getLeftColumnName ( ) , '>=' , $ lft ) -> where ( $ this -> node -> getRightColumnName ( ) , '<=' , $ rgt ) -> select ( $ this -> node -> getKeyName ( ) ) -> lockForUpdate ( ) -> get ( ) ; }
10497	public function sqrt ( ) { if ( $ this -> value === null ) { return new FloatType ( $ this -> value ) ; } return new FloatType ( sqrt ( $ this -> value ) ) ; }
1348	public function allow ( string $ resourceType , array $ fields = null ) : self { $ this -> all = false ; $ this -> allowed [ $ resourceType ] = $ fields ; return $ this ; }
3696	protected function extractIdFrom ( EnvironmentInterface $ environment , $ parameterName = 'pid' ) { $ parameter = $ environment -> getInputProvider ( ) -> getParameter ( $ parameterName ) ; return ModelId :: fromSerialized ( $ parameter ) -> getId ( ) ; }
1453	protected function excluded ( string ... $ keys ) : Collection { return collect ( $ keys ) -> mapWithKeys ( function ( $ key ) { return [ $ key => new DisallowedParameter ( $ key ) ] ; } ) ; }
7093	private function checkHierarchyIntegrity ( InvoiceInterface $ invoice ) { if ( null !== $ shipment = $ invoice -> getShipment ( ) ) { if ( $ invoice -> getSale ( ) !== $ shipment -> getSale ( ) ) { throw new ValidationFailedException ( ) ; } if ( InvoiceTypes :: isCredit ( $ invoice ) && ! $ shipment -> isReturn ( ) ) { throw new ValidationFailedException ( ) ; } if ( InvoiceTypes :: isInvoice ( $ invoice ) && $ shipment -> isReturn ( ) ) { throw new ValidationFailedException ( ) ; } } }
980	public function api ( ) { if ( ! $ this -> api ) { $ shopDomain = $ this -> shopify_domain ; $ token = $ this -> session ( ) -> getToken ( ) ; $ this -> api = ShopifyApp :: api ( ) ; $ this -> api -> setSession ( $ shopDomain , $ token ) ; } return $ this -> api ; }
5084	protected function validateUserInput ( $ aData , $ oItem = null ) { $ aOut = [ ] ; $ aFields = $ this -> oModel -> describeFields ( ) ; $ aKeys = array_unique ( array_merge ( array_keys ( $ aFields ) , arrayExtractProperty ( $ this -> oModel -> getExpandableFields ( ) , 'trigger' ) ) ) ; $ aValidKeys = array_diff ( $ aKeys , static :: IGNORE_FIELDS_WRITE ) ; foreach ( $ aValidKeys as $ sValidKey ) { $ oField = getFromArray ( $ sValidKey , $ aFields ) ; if ( array_key_exists ( $ sValidKey , $ aData ) ) { $ aOut [ $ sValidKey ] = getFromArray ( $ sValidKey , $ aData ) ; } } return $ aOut ; }
1960	public static function decode ( $ strDomain ) { if ( $ strDomain == '' ) { return '' ; } $ objPunycode = new Punycode ( ) ; try { return $ objPunycode -> decode ( $ strDomain ) ; } catch ( LabelOutOfBoundsException $ e ) { return '' ; } }
265	public function setLogger ( $ value ) { if ( is_string ( $ value ) || is_array ( $ value ) ) { $ value = Yii :: createObject ( $ value ) ; } $ this -> _logger = $ value ; $ this -> _logger -> dispatcher = $ this ; }
2651	public function activateVersion ( $ version ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/activate' ; $ result = $ this -> _fetch ( $ url , 'PUT' ) ; return $ result ; }
1208	public function moveChildToPosition ( ItemInterface $ item , ItemInterface $ child , $ position ) { $ name = $ child -> getName ( ) ; $ order = array_keys ( $ item -> getChildren ( ) ) ; $ oldPosition = array_search ( $ name , $ order ) ; unset ( $ order [ $ oldPosition ] ) ; $ order = array_values ( $ order ) ; array_splice ( $ order , $ position , 0 , $ name ) ; $ item -> reorderChildren ( $ order ) ; }
12212	public function getSnippet ( string $ snptName = '' ) { if ( empty ( $ snptName ) ) { return $ this -> snippets ; } else { return isset ( $ this -> snippets [ $ snptName ] ) ? $ this -> snippets [ $ snptName ] : null ; } }
3663	private function getValueFromServiceContainer ( $ valueName , $ arguments ) { if ( ! empty ( $ arguments [ 'service' ] ) ) { $ serviceName = $ arguments [ 'service' ] ; } else { $ serviceName = $ valueName ; } $ service = $ this -> container -> get ( IMetaModelsServiceContainer :: class ) -> getService ( $ serviceName ) ; if ( is_callable ( $ service ) ) { return call_user_func ( $ service , $ valueName , $ arguments ) ; } return 'NULL' ; }
9429	public function getFontIconClassNames ( ) { $ classes = [ ] ; if ( $ this -> owner -> FontIcon ) { if ( $ this -> owner -> FontIconListItem ) { $ classes [ ] = $ this -> backend -> getClassName ( 'list-item' ) ; } if ( $ this -> owner -> FontIconFixedWidth ) { $ classes [ ] = $ this -> backend -> getClassName ( 'fixed-width' ) ; } $ classes [ ] = $ this -> backend -> getClassName ( 'icon' , [ $ this -> owner -> FontIcon ] ) ; } return $ classes ; }
8757	public function run ( \ Traversable $ items , callable $ itemCallback ) { $ this -> start ( ) ; foreach ( $ items as $ item ) { call_user_func ( $ itemCallback , $ this , $ item ) ; } return $ this -> finish ( ) ; }
740	protected function saveRules ( ) { $ rules = [ ] ; foreach ( $ this -> rules as $ name => $ rule ) { $ rules [ $ name ] = serialize ( $ rule ) ; } $ this -> saveToFile ( $ rules , $ this -> ruleFile ) ; }
10181	public function add ( $ pCoord , Cell $ cell ) { if ( $ pCoord !== $ this -> currentCoordinate ) { $ this -> storeCurrentCell ( ) ; } $ this -> index [ $ pCoord ] = true ; $ this -> currentCoordinate = $ pCoord ; $ this -> currentCell = $ cell ; $ this -> currentCellIsDirty = true ; return $ cell ; }
6153	public function setPropertyType ( $ propertyType ) { if ( $ propertyType instanceof PropertyType ) { $ this -> propertyType = $ propertyType ; } elseif ( is_array ( $ propertyType ) ) { $ this -> propertyType = new PropertyType ( $ propertyType ) ; } else { $ this -> propertyType = null ; trigger_error ( 'Argument must be an object of class PropertyType. Data loss!' , E_USER_WARNING ) ; } return $ this ; }
6967	protected function calculateGoodLines ( Model \ DocumentInterface $ document ) : Amount { $ gross = new Amount ( $ document -> getCurrency ( ) ) ; foreach ( $ document -> getLinesByType ( Model \ DocumentLineTypes :: TYPE_GOOD ) as $ line ) { if ( null !== $ result = $ this -> calculateGoodLine ( $ line ) ) { $ gross -> merge ( $ result ) ; } } $ gross -> copyGrossToUnit ( ) ; return $ gross ; }
7142	private function registerActions ( ContainerBuilder $ container ) { if ( class_exists ( 'Ekyna\Component\Payum\Payzen\PayzenGatewayFactory' ) ) { $ definition = new Definition ( 'Ekyna\Component\Commerce\Bridge\Payum\Payzen\Action\ConvertAction' ) ; $ definition -> addTag ( 'payum.action' , [ 'factory' => 'payzen' , 'prepend' => true ] ) ; $ container -> setDefinition ( 'ekyna_commerce.payum.action.payzen.convert_payment' , $ definition ) ; $ definition = new Definition ( 'Ekyna\Component\Commerce\Bridge\Payum\Payzen\Action\FraudLevelAction' ) ; $ definition -> addTag ( 'payum.action' , [ 'factory' => 'payzen' , 'prepend' => true ] ) ; $ container -> setDefinition ( 'ekyna_commerce.payum.action.payzen.fraud_level' , $ definition ) ; } if ( class_exists ( 'Ekyna\Component\Payum\Sips\SipsGatewayFactory' ) ) { $ definition = new Definition ( 'Ekyna\Component\Commerce\Bridge\Payum\Sips\Action\ConvertAction' ) ; $ definition -> addTag ( 'payum.action' , [ 'factory' => 'atos_sips' , 'prepend' => true ] ) ; $ container -> setDefinition ( 'ekyna_commerce.payum.action.sips.convert_payment' , $ definition ) ; } if ( class_exists ( 'Payum\Paypal\ExpressCheckout\Nvp\PaypalExpressCheckoutGatewayFactory' ) ) { $ definition = new Definition ( 'Ekyna\Component\Commerce\Bridge\Payum\Paypal\Action\EcNvpConvertAction' ) ; $ definition -> setArgument ( 0 , new Reference ( 'ekyna_commerce.common.amount_calculator' ) ) ; if ( $ container -> has ( 'ekyna_setting.manager' ) && class_exists ( 'Ekyna\Bundle\AdminBundle\Settings\GeneralSettingsSchema' ) ) { $ definition -> setArgument ( 1 , new Expression ( "service('ekyna_setting.manager').getParameter('general.site_name')" ) ) ; } $ definition -> addTag ( 'payum.action' , [ 'factory' => 'paypal_express_checkout' , 'prepend' => true ] ) ; $ container -> setDefinition ( 'ekyna_commerce.payum.action.paypal_ec_nvp.convert_payment' , $ definition ) ; } $ actions = [ 'capture_payment' => Action \ CaptureAction :: class , 'notify_payment' => Action \ NotifyAction :: class , 'status_payment' => Action \ StatusAction :: class , ] ; foreach ( $ actions as $ name => $ class ) { $ definition = new Definition ( $ class ) ; $ definition -> addTag ( 'payum.action' , [ 'all' => true , 'prepend' => true ] ) ; $ container -> setDefinition ( 'ekyna_commerce.payum.action.' . $ name , $ definition ) ; } }
4358	protected function processSubstitutions ( $ args , & $ hasSubs ) { $ subRegex = '/%' . '(?:' . '[coO]|' . '[+-]?' . '(?:[ 0]|\'.{1})?' . '-?' . '\d*' . '(?:\.\d+)?' . '[difs]' . ')' . '/' ; if ( ! \ is_string ( $ args [ 0 ] ) ) { return $ args ; } $ index = 0 ; $ indexes = array ( 'c' => array ( ) , ) ; $ hasSubs = false ; $ args [ 0 ] = \ preg_replace_callback ( $ subRegex , function ( $ matches ) use ( & $ args , & $ hasSubs , & $ index , & $ indexes ) { $ hasSubs = true ; $ index ++ ; $ replacement = $ matches [ 0 ] ; $ type = \ substr ( $ matches [ 0 ] , - 1 ) ; if ( \ strpos ( 'difs' , $ type ) !== false ) { $ format = $ matches [ 0 ] ; $ sub = $ args [ $ index ] ; if ( $ type == 'i' ) { $ format = \ substr_replace ( $ format , 'd' , - 1 , 1 ) ; } elseif ( $ type === 's' ) { $ sub = $ this -> substitutionAsString ( $ sub ) ; } $ replacement = \ sprintf ( $ format , $ sub ) ; } elseif ( $ type === 'c' ) { $ asHtml = \ get_called_class ( ) == __NAMESPACE__ . '\\Html' ; if ( ! $ asHtml ) { return '' ; } $ replacement = '' ; if ( $ indexes [ 'c' ] ) { $ replacement = '</span>' ; } $ replacement .= '<span' . $ this -> debug -> utilities -> buildAttribString ( array ( 'style' => $ args [ $ index ] , ) ) . '>' ; $ indexes [ 'c' ] [ ] = $ index ; } elseif ( \ strpos ( 'oO' , $ type ) !== false ) { $ replacement = $ this -> dump ( $ args [ $ index ] ) ; } return $ replacement ; } , $ args [ 0 ] ) ; if ( $ indexes [ 'c' ] ) { $ args [ 0 ] .= '</span>' ; } if ( $ hasSubs ) { $ args = array ( $ args [ 0 ] ) ; } return $ args ; }
10030	function updateContact ( $ contact , $ checksum = "" , $ src = null , $ subscriptionPage = null , $ triggerDoi = FALSE , $ doiMailingKey = null , $ ignoreChecksum = false ) { $ queryParameters = array ( 'id' => $ contact -> id , 'checksum' => $ checksum , 'triggerdoi' => ( $ triggerDoi == TRUE ) ? "true" : "false" , 'ignore_checksum' => $ ignoreChecksum ? "true" : "false" ) ; if ( isset ( $ contact -> permission ) ) $ queryParameters [ 'permission' ] = $ contact -> permission -> getCode ( ) ; if ( isset ( $ src ) ) $ queryParameters [ 'src' ] = $ src ; if ( isset ( $ subscriptionPage ) ) $ queryParameters [ 'page_key' ] = $ subscriptionPage ; $ doiMailingKey = trim ( $ doiMailingKey ) ; if ( ! empty ( $ doiMailingKey ) ) $ queryParameters [ 'doimailing' ] = $ doiMailingKey ; $ contactToSend = new Contact ( null , $ contact -> email , null , $ contact -> external_id , null , $ contact -> standard_fields , $ contact -> custom_fields ) ; return $ this -> put ( "contacts/contact" , $ contactToSend -> toXMLString ( ) , $ queryParameters ) ; }
11440	public function getInfos ( $ echoable = false ) { if ( true === $ echoable ) { return join ( "\n<br />" , $ this -> infos ) ; } else { return $ this -> infos ; } }
2374	public static function srcToInsertTag ( $ data ) { $ return = '' ; $ paths = preg_split ( '/((src|href)="([^"]+)")/i' , $ data , - 1 , PREG_SPLIT_DELIM_CAPTURE ) ; for ( $ i = 0 , $ c = \ count ( $ paths ) ; $ i < $ c ; $ i += 4 ) { $ return .= $ paths [ $ i ] ; if ( ! isset ( $ paths [ $ i + 1 ] ) ) { continue ; } $ file = FilesModel :: findByPath ( $ paths [ $ i + 3 ] ) ; if ( $ file !== null ) { $ return .= $ paths [ $ i + 2 ] . '="{{file::' . static :: binToUuid ( $ file -> uuid ) . '}}"' ; } else { $ return .= $ paths [ $ i + 2 ] . '="' . $ paths [ $ i + 3 ] . '"' ; } } return $ return ; }
161	public function orHaving ( $ condition , $ params = [ ] ) { if ( $ this -> having === null ) { $ this -> having = $ condition ; } else { $ this -> having = [ 'or' , $ this -> having , $ condition ] ; } $ this -> addParams ( $ params ) ; return $ this ; }
2914	public function formatStacktrace ( array $ trace , $ stripFilepath = '' , $ trimPath = '' ) { $ out = '' ; foreach ( $ trace as $ index => $ row ) { if ( $ stripFilepath && isset ( $ row [ 'file' ] ) && strpos ( $ row [ 'file' ] , $ stripFilepath ) !== false ) { continue ; } if ( $ trimPath && isset ( $ row [ 'file' ] ) ) { $ row [ 'file' ] = str_replace ( $ trimPath , '' , $ row [ 'file' ] ) ; } if ( isset ( $ row [ 'file' ] ) ) { $ out .= "[$index] {$row['file']}:{$row['line']}\n" ; } else { $ out .= "[$index] (?) {$row['class']}:{$row['function']}\n" ; } } return $ out ; }
11473	public function destroy ( ResponseRequest $ request , Response $ response ) { try { $ id = $ response [ 'question_id' ] ; $ question = $ this -> question -> selectquestion ( $ id ) ; $ response -> delete ( ) ; return redirect ( '/discussion/' . $ question [ 'slug' ] ) ; } catch ( Exception $ e ) { return $ this -> response -> message ( $ e -> getMessage ( ) ) -> code ( 400 ) -> status ( 'error' ) -> url ( guard_url ( 'forum/response/' . $ response -> getRouteKey ( ) ) ) -> redirect ( ) ; } }
1533	protected function isFillableRelation ( $ field , $ record ) { return $ this -> isRelation ( $ field ) && $ this -> isFillable ( $ field , $ record ) ; }
252	public function removeAllFlashes ( ) { $ counters = $ this -> get ( $ this -> flashParam , [ ] ) ; foreach ( array_keys ( $ counters ) as $ key ) { unset ( $ _SESSION [ $ key ] ) ; } unset ( $ _SESSION [ $ this -> flashParam ] ) ; }
9006	public function build ( $ options = array ( ) ) { if ( is_string ( $ options ) ) { $ options = array ( 'type' => $ options , ) ; } else if ( ! is_array ( $ options ) ) { $ options = array ( 'type' => 'text' , ) ; } if ( empty ( $ options [ 'type' ] ) ) { $ options [ 'type' ] = 'text' ; } if ( empty ( $ options [ 'data_type' ] ) ) { $ options [ 'data_type' ] = 'metadata' ; } $ defaults = ( array ) $ this -> config -> getType ( $ options [ 'data_type' ] , $ options [ 'type' ] ) ; $ options = array_merge ( $ defaults , $ options ) ; $ classname = elgg_extract ( 'class_name' , $ options ) ; if ( class_exists ( $ classname ) ) { return new $ classname ( $ options ) ; } return false ; }
12148	public function getExceptionCode ( \ Exception $ exception ) { $ class = get_class ( $ exception ) ; $ exceptions = $ this -> getExceptions ( ) ; if ( ! isset ( $ exceptions [ $ class ] ) ) { throw new \ RuntimeException ( sprintf ( 'Not exist exception "%s" in storage.' , $ class ) ) ; } return $ exceptions [ $ class ] ; }
2005	protected function validateForm ( Widget $ objWidget = null ) { $ varInput = Idna :: encodeEmail ( Input :: post ( 'email' , true ) ) ; if ( ! Validator :: isEmail ( $ varInput ) ) { $ this -> Template -> mclass = 'error' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'email' ] ; return false ; } $ this -> Template -> email = $ varInput ; $ arrChannels = Input :: post ( 'channels' ) ; if ( ! \ is_array ( $ arrChannels ) ) { $ this -> Template -> mclass = 'error' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'noChannels' ] ; return false ; } $ arrChannels = array_intersect ( $ arrChannels , $ this -> nl_channels ) ; if ( empty ( $ arrChannels ) || ! \ is_array ( $ arrChannels ) ) { $ this -> Template -> mclass = 'error' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'noChannels' ] ; return false ; } $ this -> Template -> selectedChannels = $ arrChannels ; $ arrSubscriptions = array ( ) ; if ( ( $ objSubscription = NewsletterRecipientsModel :: findBy ( array ( "email=? AND active='1'" ) , $ varInput ) ) !== null ) { $ arrSubscriptions = $ objSubscription -> fetchEach ( 'pid' ) ; } $ arrChannels = array_intersect ( $ arrChannels , $ arrSubscriptions ) ; if ( empty ( $ arrChannels ) ) { $ this -> Template -> mclass = 'error' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'unsubscribed' ] ; return false ; } if ( $ objWidget !== null ) { $ objWidget -> validate ( ) ; if ( $ objWidget -> hasErrors ( ) ) { return false ; } } return array ( $ varInput , $ arrChannels ) ; }
10115	private function writeFooter ( ) { $ record = 0x0015 ; $ recordData = StringHelper :: UTF8toBIFF8UnicodeLong ( $ this -> phpSheet -> getHeaderFooter ( ) -> getOddFooter ( ) ) ; $ length = strlen ( $ recordData ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ this -> append ( $ header . $ recordData ) ; }
2313	public function executeResize ( ) { $ image = $ this -> prepareImage ( ) ; $ resizeConfig = $ this -> prepareResizeConfig ( ) ; if ( ! System :: getContainer ( ) -> getParameter ( 'contao.image.bypass_cache' ) && $ this -> getTargetPath ( ) && ! $ this -> getForceOverride ( ) && file_exists ( $ this -> strRootDir . '/' . $ this -> getTargetPath ( ) ) && $ this -> fileObj -> mtime <= filemtime ( $ this -> strRootDir . '/' . $ this -> getTargetPath ( ) ) ) { if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'executeResize' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'executeResize' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'executeResize' ] as $ callback ) { $ return = System :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ this ) ; if ( \ is_string ( $ return ) ) { $ this -> resizedPath = System :: urlEncode ( $ return ) ; return $ this ; } } } $ this -> resizedPath = System :: urlEncode ( $ this -> getTargetPath ( ) ) ; return $ this ; } $ image = System :: getContainer ( ) -> get ( 'contao.image.resizer' ) -> resize ( $ image , $ resizeConfig , ( new ResizeOptions ( ) ) -> setImagineOptions ( System :: getContainer ( ) -> getParameter ( 'contao.image.imagine_options' ) ) -> setTargetPath ( $ this -> targetPath ? $ this -> strRootDir . '/' . $ this -> targetPath : null ) -> setBypassCache ( System :: getContainer ( ) -> getParameter ( 'contao.image.bypass_cache' ) ) ) ; $ this -> resizedPath = $ image -> getUrl ( $ this -> strRootDir ) ; return $ this ; }
5957	public function channelGetByName ( $ name ) { foreach ( $ this -> channelList ( ) as $ channel ) { if ( $ channel [ "channel_name" ] == $ name ) { return $ channel ; } } throw new Ts3Exception ( "invalid channelID" , 0x300 ) ; }
2889	public function onCollectionLoad ( Varien_Event_Observer $ observer ) { if ( ! $ this -> canCollect ( ) ) { return ; } $ collection = $ observer -> getData ( 'collection' ) ; $ this -> getRequestInfo ( ) -> addCollection ( $ collection ) ; }
5034	public function hydrate ( $ value ) { if ( ! is_array ( $ value ) ) { return null ; } $ entity = $ this -> getTargetEntity ( ) ; foreach ( $ value as $ key => $ v ) { $ entity -> { "set$key" } ( $ v ) ; } return $ entity ; }
12730	public function renderStraight ( Zend_Navigation_Container $ container = null ) { if ( $ container === null ) { $ container = $ this -> getContainer ( ) ; } if ( ! $ active = $ this -> findActive ( $ container ) ) { return '' ; } $ active = $ active [ 'page' ] ; if ( $ this -> getLinkLast ( ) ) { $ html = '<li>' . $ this -> htmlify ( $ active ) . '</li>' ; } else { $ html = $ active -> getLabel ( ) ; if ( $ this -> getUseTranslator ( ) && $ t = $ this -> getTranslator ( ) ) { $ html = $ t -> translate ( $ html ) ; } $ html = '<li class="active">' . $ this -> view -> escape ( $ html ) . '</li>' ; } while ( ( $ parent = $ active -> getParent ( ) ) != null ) { if ( $ parent instanceof Zend_Navigation_Page ) { $ html = '<li>' . $ this -> htmlify ( $ parent ) . ' <span class="divider">' . $ this -> getSeparator ( ) . '</span></li>' . PHP_EOL . $ html ; } if ( $ parent === $ container ) { break ; } $ active = $ parent ; } return strlen ( $ html ) ? $ this -> getIndent ( ) . '<ul class="breadcrumb">' . $ html . '</ul>' : '' ; }
7944	public function ipGetRange ( $ id , $ ip ) { if ( ! $ id ) throw new BadMethodCallException ( 'Missing parameter $id.' ) ; if ( ! $ ip ) throw new BadMethodCallException ( 'Missing parameter $ip.' ) ; return json_decode ( $ this -> getIpProperties ( $ id , $ ip ) ) -> range ; }
4506	public function create ( OrganizationPersona $ persona , Parameters $ parameters = null ) : OrganizationPersona { $ options = [ ] ; $ options [ 'json' ] = ( array ) static :: toObject ( $ persona ) ; if ( $ parameters ) { $ options [ 'query' ] = ( array ) $ parameters -> toObject ( true ) ; } $ object = $ this -> execute ( 'POST' , static :: RESOURCE_LIST , $ options ) ; $ persona = static :: toModel ( $ object ) ; return $ persona ; }
3948	private function buildMap ( ) { $ map = [ ] ; foreach ( $ this -> combination -> getParented ( ) as $ childName => $ child ) { $ map [ $ child [ 'meta' ] [ 'ptable' ] ] [ $ childName ] = $ child ; } return $ map ; }
10913	public function setVariable ( string $ name , $ value , bool $ as_instance = true ) { $ this -> variables [ $ name ] = $ value ; if ( is_object ( $ value ) ) $ this -> instances [ get_class ( $ value ) ] = $ value ; return $ this ; }
202	private function queryValueExists ( $ query , $ value ) { if ( is_array ( $ value ) ) { return $ query -> count ( "DISTINCT [[$this->targetAttribute]]" ) == count ( $ value ) ; } return $ query -> exists ( ) ; }
7068	static function getUnits ( ) { return [ static :: PIECE , static :: METER , static :: CENTIMETER , static :: MILLIMETER , static :: INCH , static :: FOOT , static :: KILOGRAM , static :: GRAM , static :: CUBIC_METER , static :: LITER , static :: MILLILITER , static :: DAY , static :: HOUR , static :: MINUTE , static :: SECOND , ] ; }
10126	private function writeGuts ( ) { $ record = 0x0080 ; $ length = 0x0008 ; $ dxRwGut = 0x0000 ; $ dxColGut = 0x0000 ; $ maxRowOutlineLevel = 0 ; foreach ( $ this -> phpSheet -> getRowDimensions ( ) as $ rowDimension ) { $ maxRowOutlineLevel = max ( $ maxRowOutlineLevel , $ rowDimension -> getOutlineLevel ( ) ) ; } $ col_level = 0 ; $ colcount = count ( $ this -> columnInfo ) ; for ( $ i = 0 ; $ i < $ colcount ; ++ $ i ) { $ col_level = max ( $ this -> columnInfo [ $ i ] [ 5 ] , $ col_level ) ; } $ col_level = max ( 0 , min ( $ col_level , 7 ) ) ; if ( $ maxRowOutlineLevel ) { ++ $ maxRowOutlineLevel ; } if ( $ col_level ) { ++ $ col_level ; } $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vvvv' , $ dxRwGut , $ dxColGut , $ maxRowOutlineLevel , $ col_level ) ; $ this -> append ( $ header . $ data ) ; }
4507	public function created ( JWTCreatedEvent $ event ) { $ request = $ this -> requestStack -> getCurrentRequest ( ) ; $ data = $ event -> getData ( ) ; $ this -> accessor -> setValue ( $ data , $ this -> property , $ request -> getClientIp ( ) ) ; $ event -> setData ( $ data ) ; }
11201	public function fetchOffset ( $ num ) { if ( $ this -> contentModified ) { $ this -> generateContent ( ) ; } $ key = $ this -> fetchOffsetKey ( $ num ) ; if ( $ key != null ) { return $ this -> content [ $ key ] ; } return null ; }
3015	public function deletePost ( $ blogName , $ postId , $ reblogKey ) { $ options = array ( 'id' => $ postId , 'reblog_key' => $ reblogKey ) ; $ path = $ this -> blogPath ( $ blogName , '/post/delete' ) ; return $ this -> postRequest ( $ path , $ options , false ) ; }
8586	public function setCompetitivePrice ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'CompetitivePrice' ] [ 'FieldValue' ] = $ value ; return $ this ; }
10743	public function getDateTime ( $ keys , DateTime $ default = null ) { $ value = $ this -> getString ( $ keys ) ; if ( empty ( $ value ) ) { $ result = $ default ; } elseif ( $ value === ( string ) ( int ) $ value ) { $ result = new DateTime ( ) ; $ result -> setTimestamp ( ( int ) $ value ) ; } else { $ result = new DateTime ( $ value ) ; } return $ result ; }
12141	public function SignupUser ( $ moniker , $ mailer_id = null ) { $ endpoint = '/user/signup' ; $ postdata = array ( "moniker" => $ moniker , "mailer_id" => $ mailer_id ) ; return $ this -> executePostRequest ( $ endpoint , $ postdata ) ; }
7079	public static function getTypes ( ) { return [ self :: TYPE_WEBSITE , self :: TYPE_USER , self :: TYPE_ADMINISTRATOR , self :: TYPE_IN_CHARGE , self :: TYPE_CUSTOMER , self :: TYPE_SALESMAN , self :: TYPE_ACCOUNTABLE , self :: TYPE_SUPPLIER , ] ; }
5527	protected function extendClassCode ( $ methods ) { $ code = 'class ' . $ this -> mock_class . ' extends ' . $ this -> class . " {\n" ; $ code .= " protected \$mock;\n" ; $ code .= $ this -> addMethodList ( $ methods ) ; $ code .= "\n" ; $ code .= " function __construct() {\n" ; $ code .= ' $this->mock = new ' . $ this -> mock_base . "();\n" ; $ code .= " \$this->mock->disableExpectationNameChecks();\n" ; $ code .= " }\n" ; $ code .= $ this -> createCodeForConstructor ( ) ; $ code .= $ this -> chainMockReturns ( ) ; $ code .= $ this -> chainMockExpectations ( ) ; $ code .= $ this -> chainThrowMethods ( ) ; $ code .= $ this -> createCodeForOverridenMethods ( $ methods ) ; $ code .= "}\n" ; return $ code ; }
2971	public static function processAttachments ( array $ attachments ) { $ processed = [ ] ; foreach ( $ attachments as $ attachment ) { if ( ! ( $ attachment instanceof Attachment ) ) { throw new \ InvalidArgumentException ( 'Attachments must implement Stampie\\Attachment' ) ; } $ name = $ attachment -> getName ( ) ; if ( isset ( $ processed [ $ name ] ) ) { $ name = static :: findUniqueName ( $ name , array_keys ( $ processed ) ) ; } $ processed [ $ name ] = $ attachment ; } return $ processed ; }
5738	public function setDefaultSuffix ( $ defaultSuffix ) { $ this -> defaultSuffix = ( string ) $ defaultSuffix ; $ this -> defaultSuffix = ltrim ( $ this -> defaultSuffix , '.' ) ; return $ this ; }
7300	public static function load_class ( $ class_name = NULL ) { if ( NULL === $ class_name ) { foreach ( glob ( dirname ( __FILE__ ) . '/*.php' ) as $ path ) { require_once $ path ; } } else { if ( 0 !== strpos ( $ class_name , 'Iac_' ) ) return FALSE ; $ path = dirname ( __FILE__ ) . '/class-' . $ class_name . '.php' ; if ( file_exists ( $ path ) ) { require_once $ path ; return TRUE ; } } return FALSE ; }
2709	public function beforeSave ( \ Magento \ Config \ Model \ Config $ subject ) { $ data = $ subject -> getData ( ) ; if ( ! empty ( $ data [ 'groups' ] [ 'full_page_cache' ] [ 'fields' ] [ 'caching_application' ] [ 'value' ] ) ) { $ currentCacheConfig = $ data [ 'groups' ] [ 'full_page_cache' ] [ 'fields' ] [ 'caching_application' ] [ 'value' ] ; $ oldCacheConfig = $ this -> scopeConfig -> getValue ( \ Magento \ PageCache \ Model \ Config :: XML_PAGECACHE_TYPE ) ; if ( $ oldCacheConfig == \ Fastly \ Cdn \ Model \ Config :: FASTLY && $ currentCacheConfig != $ oldCacheConfig ) { $ this -> purge = true ; } } }
9431	public function routes ( ) { $ routes = array_merge ( $ this -> routes , $ this -> collector -> getData ( ) ) ; return function ( RouteCollector $ collector ) use ( $ routes ) { foreach ( array_filter ( $ routes ) as $ route ) { list ( $ method , $ uri , $ handler ) = ( array ) $ route ; $ collector -> addRoute ( $ method , $ uri , $ handler ) ; } } ; }
10147	private function readPalette ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; if ( ! $ this -> readDataOnly ) { $ nm = self :: getUInt2d ( $ recordData , 0 ) ; for ( $ i = 0 ; $ i < $ nm ; ++ $ i ) { $ rgb = substr ( $ recordData , 2 + 4 * $ i , 4 ) ; $ this -> palette [ ] = self :: readRGB ( $ rgb ) ; } } }
5704	public function Field ( $ properties = array ( ) ) { if ( $ this -> isGrouped ( ) ) { $ this -> transformToInput ( ) ; } else { $ this -> transformToButton ( ) ; } return parent :: Field ( $ properties ) ; }
10429	private function initSyncStorageForMysql ( ContainerBuilder $ container , array $ config ) { $ doctrineConnection = sprintf ( 'doctrine.dbal.%s_connection' , $ config [ 'connection' ] ) ; $ definition = $ container -> getDefinition ( 'ongr_connections.sync.storage_manager.mysql_storage_manager' ) ; $ definition -> setArguments ( [ new Reference ( $ doctrineConnection , ContainerInterface :: IGNORE_ON_INVALID_REFERENCE ) , $ config [ 'table_name' ] , ] ) ; $ definition -> addMethodCall ( 'setContainer' , [ new Reference ( 'service_container' ) ] ) ; $ container -> getDefinition ( 'ongr_connections.sync.sync_storage' ) -> setArguments ( [ $ definition ] ) ; }
1007	public static function isValidNameError ( $ name , $ node = null ) { self :: invariant ( is_string ( $ name ) , 'Expected string' ) ; if ( isset ( $ name [ 1 ] ) && $ name [ 0 ] === '_' && $ name [ 1 ] === '_' ) { return new Error ( sprintf ( 'Name "%s" must not begin with "__", which is reserved by ' , $ name ) . 'GraphQL introspection.' , $ node ) ; } if ( ! preg_match ( '/^[_a-zA-Z][_a-zA-Z0-9]*$/' , $ name ) ) { return new Error ( sprintf ( 'Names must match /^[_a-zA-Z][_a-zA-Z0-9]*$/ but "%s" does not.' , $ name ) , $ node ) ; } return null ; }
2380	public static function trimsplit ( $ strPattern , $ strString ) { if ( \ strlen ( $ strPattern ) == 1 ) { $ arrFragments = array_map ( 'trim' , explode ( $ strPattern , $ strString ) ) ; } else { $ arrFragments = array_map ( 'trim' , preg_split ( '/' . $ strPattern . '/ui' , $ strString ) ) ; } if ( \ count ( $ arrFragments ) < 2 && ! \ strlen ( $ arrFragments [ 0 ] ) ) { $ arrFragments = array ( ) ; } return $ arrFragments ; }
676	public function setPage ( $ value , $ validatePage = false ) { if ( $ value === null ) { $ this -> _page = null ; } else { $ value = ( int ) $ value ; if ( $ validatePage && $ this -> validatePage ) { $ pageCount = $ this -> getPageCount ( ) ; if ( $ value >= $ pageCount ) { $ value = $ pageCount - 1 ; } } if ( $ value < 0 ) { $ value = 0 ; } $ this -> _page = $ value ; } }
10531	public function count ( ) { if ( is_array ( $ this -> items ) && $ this -> items !== null ) { return count ( $ this -> items ) ; } return 0 ; }
4884	public function addDependencies ( $ name , $ entities = null , array $ options = null ) { return $ this -> dependencyResultCollection -> add ( $ name , $ entities , $ options ) ; }
6545	public function create ( $ name ) { $ sheet = $ this -> container -> createSheet ( ) ; $ sheet -> setTitle ( $ name ) ; return new \ Aimeos \ MW \ Container \ Content \ PHPExcel ( $ sheet , $ name , $ this -> getOptions ( ) ) ; }
442	public function hasEventHandlers ( $ name ) { $ this -> ensureBehaviors ( ) ; foreach ( $ this -> _eventWildcards as $ wildcard => $ handlers ) { if ( ! empty ( $ handlers ) && StringHelper :: matchWildcard ( $ wildcard , $ name ) ) { return true ; } } return ! empty ( $ this -> _events [ $ name ] ) || Event :: hasHandlers ( $ this , $ name ) ; }
4805	public function getLowestFreeIndexNumber ( ) { $ query = $ this -> createQuery ( ) ; $ query -> statement ( 'SELECT index_number from ' . strtolower ( $ this -> objectType ) . ' WHERE deleted=0' ) ; $ index = 1 ; $ results = $ query -> execute ( true ) ; if ( false === is_array ( $ results ) || sizeof ( $ results ) < 1 ) { return $ index ; } $ indexes = array ( ) ; foreach ( $ results as $ result ) { $ indexes [ ] = ( integer ) $ result [ 'index_number' ] ; } for ( $ index = 1 ; $ index <= sizeof ( $ indexes ) + 1 ; $ index ++ ) { if ( false === in_array ( $ index , $ indexes ) ) { break ; } } return $ index ; }
870	public function configure ( array $ configuration = null ) { parent :: configure ( $ configuration ) ; $ this -> candidateTokenKind = 'long' === $ this -> configuration [ 'syntax' ] ? CT :: T_DESTRUCTURING_SQUARE_BRACE_OPEN : T_LIST ; }
11313	public static function buildBasestring ( $ method , Url $ url , array $ data ) { $ base = array ( ) ; $ base [ ] = self :: urlEncode ( self :: getNormalizedMethod ( $ method ) ) ; $ base [ ] = self :: urlEncode ( self :: getNormalizedUrl ( $ url ) ) ; $ base [ ] = self :: urlEncode ( self :: getNormalizedParameters ( $ data ) ) ; return implode ( '&' , $ base ) ; }
12415	public static function init ( $ options = array ( ) ) { Flight :: map ( "render" , function ( $ template , $ data , $ toVar = false ) { Flight :: view ( ) -> render ( $ template , $ data , $ toVar ) ; } ) ; Flight :: register ( 'view' , get_called_class ( ) , $ options ) ; }
7423	protected function registerWidget ( $ name = null , $ id = null ) { if ( $ name === null ) { $ name = $ this -> getDefaultJsWidgetName ( ) ; } $ this -> _registerBundle ( ) ; if ( ! $ this -> isAjaxCrud && $ this -> getUpdateUrl ( ) ) { if ( $ id === null ) { $ id = $ this -> options [ 'id' ] ; } $ options = empty ( $ this -> clientOptions ) ? '' : Json :: htmlEncode ( [ 'updateUrl' => Url :: to ( $ this -> getUpdateUrl ( ) ) ] ) ; $ js = "jQuery('#$id').$name($options);" ; $ this -> getView ( ) -> registerJs ( $ js ) ; } }
9822	public function writeRelationships ( Spreadsheet $ spreadsheet ) { $ objWriter = null ; if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' , 'yes' ) ; $ objWriter -> startElement ( 'Relationships' ) ; $ objWriter -> writeAttribute ( 'xmlns' , 'http://schemas.openxmlformats.org/package/2006/relationships' ) ; $ customPropertyList = $ spreadsheet -> getProperties ( ) -> getCustomProperties ( ) ; if ( ! empty ( $ customPropertyList ) ) { $ this -> writeRelationship ( $ objWriter , 4 , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/custom-properties' , 'docProps/custom.xml' ) ; } $ this -> writeRelationship ( $ objWriter , 3 , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties' , 'docProps/app.xml' ) ; $ this -> writeRelationship ( $ objWriter , 2 , 'http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties' , 'docProps/core.xml' ) ; $ this -> writeRelationship ( $ objWriter , 1 , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument' , 'xl/workbook.xml' ) ; if ( $ spreadsheet -> hasRibbon ( ) ) { $ this -> writeRelationShip ( $ objWriter , 5 , 'http://schemas.microsoft.com/office/2006/relationships/ui/extensibility' , $ spreadsheet -> getRibbonXMLData ( 'target' ) ) ; } $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
187	protected function fetchData ( ) { if ( $ this -> _dataReader === null ) { $ this -> _dataReader = $ this -> query -> createCommand ( $ this -> db ) -> query ( ) ; } $ rows = [ ] ; $ count = 0 ; while ( $ count ++ < $ this -> batchSize && ( $ row = $ this -> _dataReader -> read ( ) ) ) { $ rows [ ] = $ row ; } return $ this -> query -> populate ( $ rows ) ; }
4192	protected function dumpPhpDoc ( $ phpDoc ) { $ str = '' ; foreach ( $ phpDoc as $ k => $ values ) { if ( ! \ is_array ( $ values ) ) { continue ; } foreach ( $ values as $ value ) { if ( $ k == 'link' ) { $ value = '<a href="' . $ value [ 'uri' ] . '" target="_blank">' . \ htmlspecialchars ( $ value [ 'desc' ] ? : $ value [ 'uri' ] ) . '</a>' ; } elseif ( $ k == 'see' && $ value [ 'uri' ] ) { $ value = '<a href="' . $ value [ 'uri' ] . '" target="_blank">' . \ htmlspecialchars ( $ value [ 'desc' ] ? : $ value [ 'uri' ] ) . '</a>' ; } else { $ value = \ htmlspecialchars ( \ implode ( ' ' , $ value ) ) ; } $ str .= '<dd class="phpdoc phpdoc-' . $ k . '">' . '<span class="phpdoc-tag">' . $ k . '</span>' . '<span class="t_operator">:</span> ' . $ value . '</dd>' . "\n" ; } } if ( $ str ) { $ str = '<dt class="phpDoc">phpDoc</dt>' . "\n" . $ str ; } return $ str ; }
1699	public function getFile ( $ strName ) { foreach ( $ this -> arrFiles as $ k => $ v ) { if ( $ strName == $ v [ 'file_name' ] ) { $ this -> intIndex = $ k ; return true ; } } return false ; }
1002	public static function visitWithTypeInfo ( TypeInfo $ typeInfo , $ visitor ) { return [ 'enter' => static function ( Node $ node ) use ( $ typeInfo , $ visitor ) { $ typeInfo -> enter ( $ node ) ; $ fn = self :: getVisitFn ( $ visitor , $ node -> kind , false ) ; if ( $ fn ) { $ result = call_user_func_array ( $ fn , func_get_args ( ) ) ; if ( $ result !== null ) { $ typeInfo -> leave ( $ node ) ; if ( $ result instanceof Node ) { $ typeInfo -> enter ( $ result ) ; } } return $ result ; } return null ; } , 'leave' => static function ( Node $ node ) use ( $ typeInfo , $ visitor ) { $ fn = self :: getVisitFn ( $ visitor , $ node -> kind , true ) ; $ result = $ fn ? call_user_func_array ( $ fn , func_get_args ( ) ) : null ; $ typeInfo -> leave ( $ node ) ; return $ result ; } , ] ; }
8470	public function alert ( $ scope , $ message , $ context = [ ] , $ config = [ ] ) { return $ this -> write ( 'alert' , $ scope , $ message , $ context , $ config ) ; }
6719	private function handleAuthorizeResponse ( $ response ) { $ status = ArrayHelper :: getValue ( $ response , 'status' ) ; if ( ! is_null ( $ status ) && $ status == 'success' ) { $ code = ArrayHelper :: getValue ( $ response , 'data.code' ) ; if ( is_null ( $ code ) ) { throw new Oauth2ClientException ( self :: CODE_NOT_SET ) ; } return $ code ; } else { $ message = ArrayHelper :: getValue ( $ response , 'message' , self :: DEFAULT_ERROR ) ; throw new Oauth2ClientException ( $ message ) ; } }
7158	public function compile ( Database $ db = NULL ) : string { if ( $ db === null ) { $ db = \ Mii :: $ app -> db ; } $ value = $ this -> value ( ) ; if ( ! empty ( $ this -> _parameters ) ) { $ params = array_map ( [ $ db , 'quote' ] , $ this -> _parameters ) ; $ value = strtr ( $ value , $ params ) ; } return $ value ; }
1954	public static function findExpiredSubscriptions ( array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ objDatabase = Database :: getInstance ( ) ; $ objResult = $ objDatabase -> prepare ( "SELECT * FROM $t WHERE active='' AND EXISTS (SELECT * FROM tl_opt_in_related r LEFT JOIN tl_opt_in o ON r.pid=o.id WHERE r.relTable='$t' AND r.relId=$t.id AND o.createdOn<=? AND o.confirmedOn=0)" ) -> execute ( strtotime ( '-24 hours' ) ) ; if ( $ objResult -> numRows < 1 ) { return null ; } return static :: createCollectionFromDbResult ( $ objResult , $ t ) ; }
2819	public function initQueries ( ) { $ this -> queries = array ( ) ; $ profiler = Mage :: helper ( 'sheep_debug' ) -> getSqlProfiler ( ) ; if ( $ profiler -> getEnabled ( ) && $ profiler instanceof Sheep_Debug_Model_Db_Profiler ) { $ this -> queries = $ profiler -> getQueryModels ( ) ? : array ( ) ; $ this -> setQueryCount ( $ profiler -> getTotalNumQueries ( ) ) ; $ this -> setQueryTime ( $ profiler -> getTotalElapsedSecs ( ) ) ; } }
2967	protected function createResponseFromData ( $ data ) { if ( isset ( $ data [ 'rows' ] ) || ( isset ( $ data [ 'data' ] ) && ArrayUtils :: isNumericKeys ( $ data [ 'data' ] ) ) ) { $ response = new EntryCollection ( $ data ) ; } else { $ response = new Entry ( $ data ) ; } return $ response ; }
