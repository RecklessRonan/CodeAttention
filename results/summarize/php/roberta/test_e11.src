2980	public function addResource ( Bundle $ bundle ) { if ( ! file_exists ( $ this -> file ) ) { throw new \ RuntimeException ( sprintf ( 'The target config file %s does not exist' , $ this -> file ) ) ; } $ code = $ this -> getImportCode ( $ bundle ) ; $ currentContents = file_get_contents ( $ this -> file ) ; if ( false !== strpos ( $ currentContents , $ code ) ) { throw new \ RuntimeException ( sprintf ( 'The %s configuration file from %s is already imported' , $ bundle -> getServicesConfigurationFilename ( ) , $ bundle -> getName ( ) ) ) ; } $ lastImportedPath = $ this -> findLastImportedPath ( $ currentContents ) ; if ( ! $ lastImportedPath ) { throw new \ RuntimeException ( sprintf ( 'Could not find the imports key in %s' , $ this -> file ) ) ; } $ importsPosition = strpos ( $ currentContents , 'imports:' ) ; $ lastImportPosition = strpos ( $ currentContents , $ lastImportedPath , $ importsPosition ) ; $ targetLinebreakPosition = strpos ( $ currentContents , "\n" , $ lastImportPosition ) ; $ newContents = substr ( $ currentContents , 0 , $ targetLinebreakPosition ) . "\n" . $ code . substr ( $ currentContents , $ targetLinebreakPosition ) ; if ( false === Generator :: dump ( $ this -> file , $ newContents ) ) { throw new \ RuntimeException ( sprintf ( 'Could not write file %s ' , $ this -> file ) ) ; } }
2314	protected function prepareImage ( ) { if ( $ this -> fileObj -> isSvgImage ) { $ imagine = System :: getContainer ( ) -> get ( 'contao.image.imagine_svg' ) ; } else { $ imagine = System :: getContainer ( ) -> get ( 'contao.image.imagine' ) ; } $ image = new NewImage ( $ this -> strRootDir . '/' . $ this -> fileObj -> path , $ imagine , System :: getContainer ( ) -> get ( 'filesystem' ) ) ; $ image -> setImportantPart ( $ this -> prepareImportantPart ( ) ) ; return $ image ; }
9321	protected function compileMarkdownEchos ( $ value ) { $ pattern = sprintf ( '/(@)?%s\s*(.+?)\s*%s(\r?\n)?/s' , $ this -> markdownTags [ 0 ] , $ this -> markdownTags [ 1 ] ) ; $ callback = function ( $ matches ) { $ wrapper = sprintf ( $ this -> markdownFormat , $ this -> compileEchoDefaults ( $ matches [ 2 ] ) ) ; return $ matches [ 1 ] ? strlen ( stripcslashes ( $ this -> markdownTags [ 0 ] ) ) > 2 ? $ matches [ 0 ] : substr ( $ matches [ 0 ] , 1 ) : '<?php echo ' . $ wrapper . '; ?>' ; } ; return preg_replace_callback ( $ pattern , $ callback , $ value ) ; }
1002	public static function visitWithTypeInfo ( TypeInfo $ typeInfo , $ visitor ) { return [ 'enter' => static function ( Node $ node ) use ( $ typeInfo , $ visitor ) { $ typeInfo -> enter ( $ node ) ; $ fn = self :: getVisitFn ( $ visitor , $ node -> kind , false ) ; if ( $ fn ) { $ result = call_user_func_array ( $ fn , func_get_args ( ) ) ; if ( $ result !== null ) { $ typeInfo -> leave ( $ node ) ; if ( $ result instanceof Node ) { $ typeInfo -> enter ( $ result ) ; } } return $ result ; } return null ; } , 'leave' => static function ( Node $ node ) use ( $ typeInfo , $ visitor ) { $ fn = self :: getVisitFn ( $ visitor , $ node -> kind , true ) ; $ result = $ fn ? call_user_func_array ( $ fn , func_get_args ( ) ) : null ; $ typeInfo -> leave ( $ node ) ; return $ result ; } , ] ; }
2486	public function commit ( $ flush = false ) { $ payload = $ flush ? '<commit/>' : '<commit softCommit="true"/>' ; foreach ( $ this -> endpointResolver -> getEndpoints ( ) as $ endpointName ) { $ result = $ this -> client -> request ( 'POST' , $ this -> endpointRegistry -> getEndpoint ( $ endpointName ) , '/update' , new Message ( array ( 'Content-Type' => 'text/xml' , ) , $ payload ) ) ; if ( $ result -> headers [ 'status' ] !== 200 ) { throw new RuntimeException ( 'Wrong HTTP status received from Solr: ' . $ result -> headers [ 'status' ] . var_export ( $ result , true ) ) ; } } }
8690	protected function validateElementValues ( ) { foreach ( self :: $ mandatoryFields as $ field ) { if ( array_key_exists ( $ field , $ this -> attributes ) ) { $ value = ( int ) $ this -> attributes [ $ field ] ; if ( $ value < 0 ) { throw new \ SVGCreator \ SVGException ( "The " . $ field . " value is lesser than 0, in element " . self :: TYPE , 1 ) ; } } } }
10695	public function select ( $ col = '' , $ colAlias = '' ) { return $ this -> getBuilder ( ) -> setPrevious ( $ this ) -> select ( $ col , $ colAlias ) ; }
7352	public function getRemainingAmount ( ) { $ amount = 0 ; $ currency = $ this -> getCurrency ( ) -> getCode ( ) ; $ hasDeposit = 1 === Money :: compare ( $ this -> depositTotal , 0 , $ currency ) ; if ( $ hasDeposit && ( - 1 === Money :: compare ( $ this -> paidTotal , $ this -> depositTotal , $ currency ) ) ) { $ total = $ this -> depositTotal ; } else { $ total = $ this -> grandTotal ; } $ c = Money :: compare ( $ total , $ this -> paidTotal + $ this -> outstandingAccepted + $ this -> pendingTotal , $ currency ) ; if ( 1 === $ c ) { $ amount = $ total - $ this -> paidTotal - $ this -> outstandingAccepted - $ this -> pendingTotal ; } else if ( 0 === $ c && 0 < $ this -> outstandingAccepted ) { $ amount = $ this -> outstandingAccepted ; } if ( 0 < $ amount ) { return $ amount ; } return 0 ; }
1631	public function getMetaData ( ) { $ data = [ ] ; $ data [ 'url' ] = $ this -> request -> fullUrl ( ) ; $ data [ 'httpMethod' ] = $ this -> request -> getMethod ( ) ; $ data [ 'params' ] = $ this -> request -> input ( ) ; $ data [ 'clientIp' ] = $ this -> request -> getClientIp ( ) ; if ( $ agent = $ this -> request -> header ( 'User-Agent' ) ) { $ data [ 'userAgent' ] = $ agent ; } if ( $ headers = $ this -> request -> headers -> all ( ) ) { $ data [ 'headers' ] = $ headers ; } return [ 'request' => $ data ] ; }
4402	protected function getProvider ( ) { $ config = $ this -> getServiceItem ( ) -> getConfig ( ) ; $ config [ 'apiKey' ] = $ this -> getServiceItem ( ) -> getConfigValue ( 'stripe.apiKey' ) ; if ( ! isset ( $ this -> provider ) ) { $ this -> provider = OPay :: create ( 'Stripe' ) ; $ this -> provider -> setTestMode ( ( bool ) $ this -> getValue ( 'testmode' , false ) ) ; $ this -> provider -> initialize ( $ config ) ; } return $ this -> provider ; }
1261	protected function createTransactionNode ( ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; $ trxRef = $ xml -> appendChild ( $ xml -> createElement ( 'TransactionReference' ) ) ; if ( null !== $ this -> context ) { $ trxRef -> appendChild ( $ xml -> createElement ( 'CustomerContext' , $ this -> context ) ) ; } return $ trxRef -> cloneNode ( true ) ; }
8966	public static function exists ( $ currencyCode ) { $ currencyCode = trim ( strtoupper ( $ currencyCode ) ) ; return array_key_exists ( $ currencyCode , self :: $ codes ) ; }
7197	protected function setIsFirst ( OrderInterface $ order ) { if ( null !== $ customer = $ order -> getCustomer ( ) ) { if ( $ customer -> hasParent ( ) ) { $ customer = $ customer -> getParent ( ) ; } $ first = ! $ this -> orderRepository -> existsForCustomer ( $ customer ) ; } else { $ first = ! $ this -> orderRepository -> existsForEmail ( $ order -> getEmail ( ) ) ; } if ( $ first != $ order -> isFirst ( ) ) { $ order -> setFirst ( $ first ) ; return true ; } return false ; }
1784	protected function fetchItems ( $ newsArchives , $ blnFeatured , $ limit , $ offset ) { if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'newsListFetchItems' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'newsListFetchItems' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'newsListFetchItems' ] as $ callback ) { if ( ( $ objCollection = System :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ newsArchives , $ blnFeatured , $ limit , $ offset , $ this ) ) === false ) { continue ; } if ( $ objCollection === null || $ objCollection instanceof Collection ) { return $ objCollection ; } } } $ t = NewsModel :: getTable ( ) ; $ arrOptions = array ( ) ; switch ( $ this -> news_order ) { case 'order_headline_asc' : $ arrOptions [ 'order' ] = "$t.headline" ; break ; case 'order_headline_desc' : $ arrOptions [ 'order' ] = "$t.headline DESC" ; break ; case 'order_random' : $ arrOptions [ 'order' ] = "RAND()" ; break ; case 'order_date_asc' : $ arrOptions [ 'order' ] = "$t.date" ; break ; default : $ arrOptions [ 'order' ] = "$t.date DESC" ; } return NewsModel :: findPublishedByPids ( $ newsArchives , $ blnFeatured , $ limit , $ offset , $ arrOptions ) ; }
9446	public function getConfigsPath ( Container $ app ) { static $ paths = [ ] ; $ me = get_class ( $ this ) ; if ( empty ( $ paths [ $ me ] ) ) { $ subpath = $ this -> packOptions [ 'configs_subpath' ] ; $ paths [ $ me ] = dirname ( $ this -> getReflector ( ) -> getFileName ( ) ) . '/' . $ subpath ; } return $ paths [ $ me ] ; }
683	private function normalizeComplexFilter ( array $ filter ) { $ result = [ ] ; foreach ( $ filter as $ key => $ value ) { if ( isset ( $ this -> filterControls [ $ key ] ) ) { $ key = $ this -> filterControls [ $ key ] ; } elseif ( isset ( $ this -> attributeMap [ $ key ] ) ) { $ key = $ this -> attributeMap [ $ key ] ; } if ( is_array ( $ value ) ) { $ result [ $ key ] = $ this -> normalizeComplexFilter ( $ value ) ; } else { $ result [ $ key ] = $ value ; } } return $ result ; }
7688	function OpenXML_Rels_ReplaceTarget ( $ RelsPath , $ OldTarget , $ NewTarget ) { $ idx = $ this -> FileGetIdx ( $ RelsPath ) ; if ( $ idx === false ) $ this -> RaiseError ( "Cannot edit target in '$RelsPath' because the file is not found." ) ; $ txt = $ this -> TbsStoreGet ( $ idx , 'Replace target in rels file' ) ; $ att = 'Target="' . $ OldTarget . '"' ; $ loc = clsTbsXmlLoc :: FindStartTagHavingAtt ( $ txt , $ att , 0 ) ; if ( $ loc ) { if ( $ NewTarget === false ) { $ loc -> Delete ( ) ; } else { $ loc -> ReplaceAtt ( 'Target' , $ NewTarget ) ; } $ this -> TbsStorePut ( $ idx , $ txt ) ; return true ; } else { return false ; } }
1799	public function help ( $ strClass = '' ) { $ return = $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ this -> strField ] [ 'label' ] [ 1 ] ; if ( ! Config :: get ( 'showHelp' ) || $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ this -> strField ] [ 'inputType' ] == 'password' || $ return == '' ) { return '' ; } return ' <p class="tl_help tl_tip' . $ strClass . '">' . $ return . '</p>' ; }
2619	public function generateCid ( ) { return sprintf ( '%04x%04x-%04x-%04x-%04x-%04x%04x%04x' , mt_rand ( 0 , 0xffff ) , mt_rand ( 0 , 0xffff ) , mt_rand ( 0 , 0xffff ) , mt_rand ( 0 , 0x0fff ) | 0x4000 , mt_rand ( 0 , 0x3fff ) | 0x8000 , mt_rand ( 0 , 0xffff ) , mt_rand ( 0 , 0xffff ) , mt_rand ( 0 , 0xffff ) ) ; }
1698	private function loadFrontendUser ( string $ username , BackendUser $ backendUser ) : ? FrontendUser { try { $ frontendUser = $ this -> userProvider -> loadUserByUsername ( $ username ) ; if ( ! $ frontendUser instanceof FrontendUser ) { throw new UsernameNotFoundException ( 'User is not a front end user' ) ; } } catch ( UsernameNotFoundException $ e ) { if ( null !== $ this -> logger ) { $ this -> logger -> info ( sprintf ( 'Could not find a front end user with the username "%s"' , $ username ) , [ 'contao' => new ContaoContext ( __METHOD__ , ContaoContext :: ACCESS , '' ) ] ) ; } return null ; } $ allowedGroups = StringUtil :: deserialize ( $ backendUser -> amg , true ) ; $ frontendGroups = StringUtil :: deserialize ( $ frontendUser -> groups , true ) ; if ( ! $ backendUser -> isAdmin && ! \ count ( array_intersect ( $ frontendGroups , $ allowedGroups ) ) ) { return null ; } return $ frontendUser ; }
7600	public function render ( array $ aButtons , array $ aButtonGroupOptions = null ) { if ( empty ( $ aButtonGroupOptions [ 'attributes' ] ) ) { $ aButtonGroupOptions [ 'attributes' ] = array ( 'class' => 'btn-group' ) ; } else { if ( ! is_array ( $ aButtonGroupOptions [ 'attributes' ] ) ) { throw new LogicException ( '"attributes" option expects an array, "' . gettype ( $ aButtonGroupOptions [ 'attributes' ] ) . '" given' ) ; } if ( empty ( $ aButtonGroupOptions [ 'attributes' ] [ 'class' ] ) ) { $ aButtonGroupOptions [ 'attributes' ] [ 'class' ] = 'btn-group' ; } elseif ( ! preg_match ( '/(\s|^)(?:btn-group|btn-group-vertical)(\s|$)/' , $ aButtonGroupOptions [ 'attributes' ] [ 'class' ] ) ) { $ aButtonGroupOptions [ 'attributes' ] [ 'class' ] .= ' btn-group' ; } } return sprintf ( static :: $ buttonGroupContainerFormat , $ this -> createAttributesString ( $ aButtonGroupOptions [ 'attributes' ] ) , $ this -> renderButtons ( $ aButtons , strpos ( $ aButtonGroupOptions [ 'attributes' ] [ 'class' ] , 'btn-group-justified' ) !== false ) ) ; }
5598	public function add ( $ severity , $ content , $ filename , $ line ) { $ content = str_replace ( '%' , '%%' , $ content ) ; $ this -> testLatestError ( $ severity , $ content , $ filename , $ line ) ; }
4272	public function stream_close ( ) { if ( ! $ this -> handle ) { return ; } self :: restorePrev ( ) ; \ fclose ( $ this -> handle ) ; $ this -> handle = null ; self :: register ( ) ; }
10698	public static function isPasswd ( $ passwd , $ size = Validate :: PASSWORD_LENGTH ) { return self :: getPasswordComplexity ( $ passwd , $ size ) >= self :: PASSWORD_COMPLEXITY_MEDIUM ; }
3673	private function getPageIdFromUrlHook ( ? array $ fragments ) : ? array { if ( ! ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getPageIdFromUrl' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getPageIdFromUrl' ] ) ) ) { return $ fragments ; } foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getPageIdFromUrl' ] as $ callback ) { $ fragments = System :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ fragments ) ; } return $ fragments ; }
12298	public function onlyFillablePivot ( $ pivotRelation , $ data ) { $ fillable = $ this -> getPivotFields ( $ pivotRelation , 'pivotColumns' ) ; return array_only ( $ data , $ fillable ) ; }
2368	public static function extractEmail ( $ strString , $ strAllowedTags = '' ) { $ arrEmails = array ( ) ; if ( strpos ( $ strString , '@' ) === false ) { return $ arrEmails ; } preg_match_all ( '/mailto:(?:[^\x00-\x20\x22\x40\x7F]{1,64}+|\x22[^\x00-\x1F\x7F]{1,64}?\x22)@(?:\[(?:IPv)?[a-f0-9.:]{1,47}\]|[\w.-]{1,252}\.[a-z]{2,63}\b)/u' , $ strString , $ matches ) ; foreach ( $ matches [ 0 ] as & $ strEmail ) { $ strEmail = str_replace ( 'mailto:' , '' , $ strEmail ) ; if ( Validator :: isEmail ( $ strEmail ) ) { $ arrEmails [ ] = $ strEmail ; } } unset ( $ strEmail ) ; $ strString = preg_replace_callback ( '@</?([^\s<>/]*)@' , function ( $ matches ) use ( $ strAllowedTags ) { if ( $ matches [ 1 ] == '' || stripos ( $ strAllowedTags , '<' . strtolower ( $ matches [ 1 ] ) . '>' ) === false ) { $ matches [ 0 ] = str_replace ( '<' , '&lt;' , $ matches [ 0 ] ) ; } return $ matches [ 0 ] ; } , $ strString ) ; preg_match_all ( '/(?:[^\x00-\x20\x22\x40\x7F]{1,64}|\x22[^\x00-\x1F\x7F]{1,64}?\x22)@(?:\[(?:IPv)?[a-f0-9.:]{1,47}\]|[\w.-]{1,252}\.[a-z]{2,63}\b)/u' , strip_tags ( $ strString ) , $ matches ) ; foreach ( $ matches [ 0 ] as & $ strEmail ) { $ strEmail = str_replace ( '&lt;' , '<' , $ strEmail ) ; if ( Validator :: isEmail ( $ strEmail ) ) { $ arrEmails [ ] = $ strEmail ; } } return array_unique ( $ arrEmails ) ; }
1525	protected function doCreate ( StoreInterface $ store , CreateResource $ request ) { if ( $ response = $ this -> beforeCommit ( $ request ) ) { return $ response ; } $ record = $ store -> createRecord ( $ request -> getResourceType ( ) , $ request -> all ( ) , $ request -> getParameters ( ) ) ; return $ this -> afterCommit ( $ request , $ record , false ) ? : $ record ; }
11246	public function getMigrations ( int $ steps ) : array { $ sql = "select migration from {$this->table} where batch >= 1 order by batch, migration desc limit ?" ; $ stmt = $ this -> pdo -> prepare ( $ sql ) ; $ stmt -> bindParam ( 1 , $ steps , PDO :: PARAM_INT ) ; $ stmt -> execute ( ) ; return $ stmt -> fetchAll ( PDO :: FETCH_COLUMN ) ; }
6594	public function getMethodDocumentation ( \ ReflectionMethod $ method ) { $ comment = $ this -> getMethodComment ( $ method ) ; $ summary = $ this -> getSummary ( $ comment ) ; $ parameters = $ this -> getParameters ( $ comment ) ; $ returnType = $ this -> getReturnType ( $ comment ) ; $ documentation = [ ] ; if ( $ summary ) { $ documentation [ 'summary' ] = $ summary ; $ description = $ this -> getDescription ( $ comment ) ; if ( $ description ) { $ documentation [ 'description' ] = $ description ; } } $ documentation [ 'parameters' ] = $ parameters ; $ documentation [ 'returnType' ] = $ returnType ; return $ documentation ; }
11779	protected function buildClass ( $ name ) { $ stub = $ this -> files -> get ( $ this -> getStub ( ) ) ; return str_replace ( 'DummyHelper' , $ this -> getNameInput ( ) , $ stub ) ; }
10792	public function get ( $ idOrUser ) { $ main = $ this -> getServiceLocator ( ) -> get ( 'neobazaar.service.main' ) ; $ userRepository = $ main -> getUserEntityRepository ( ) ; if ( 'current' == $ idOrUser ) { return $ userRepository -> get ( $ idOrUser , $ this -> getServiceLocator ( ) ) ; } $ user = $ this -> getEntity ( $ idOrUser ) ; if ( ! $ this -> checkIfOwnerOrAdmin ( $ user ) ) { throw new \ Exception ( 'Non possiedi i permessi per agire su questo documento' ) ; } return $ userRepository -> get ( $ user , $ this -> getServiceLocator ( ) ) ; }
5638	public function shouldInvoke ( $ test_case , $ method ) { if ( $ this -> shouldRunTest ( $ test_case , $ method ) ) { return $ this -> reporter -> shouldInvoke ( $ test_case , $ method ) ; } return false ; }
8197	public function collect ( Traversable $ iterator ) { $ this -> deprecations = array ( ) ; set_error_handler ( array ( $ this , 'errorHandler' ) ) ; foreach ( $ iterator as $ name => $ contents ) { try { $ this -> twig -> parse ( $ this -> twig -> tokenize ( new Twig_Source ( $ contents , $ name ) ) ) ; } catch ( Twig_Error_Syntax $ e ) { } } restore_error_handler ( ) ; $ deprecations = $ this -> deprecations ; $ this -> deprecations = array ( ) ; return $ deprecations ; }
11806	public function chunk ( $ count , callable $ callback ) { return $ this -> buildQuery ( $ this -> getQueryColumns ( ) ) -> chunk ( $ count , $ callback ) ; }
2615	public function isApiKeyValid ( ) { try { $ apiKey = $ this -> scopeConfig -> getValue ( Config :: XML_FASTLY_API_KEY ) ; $ serviceId = $ this -> scopeConfig -> getValue ( Config :: XML_FASTLY_SERVICE_ID ) ; $ isApiKeyValid = $ this -> api -> checkServiceDetails ( true , $ serviceId , $ apiKey ) ; } catch ( \ Exception $ e ) { return false ; } return ( bool ) $ isApiKeyValid ; }
8396	public static function ensureTable ( array $ mapping ) : bool { $ database = Database :: get ( $ mapping [ 'config' ] [ 'database' ] ) ; $ statement = 'CREATE TABLE IF NOT EXISTS _stray_migration (' ; $ statement .= 'date TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL, ' ; $ statement .= 'migration VARCHAR(255)' ; $ statement .= ')' ; $ statement = $ database -> getMasterLink ( ) -> prepare ( $ statement ) ; if ( $ statement -> execute ( ) === false ) { echo 'Can\'t create _stray_migration (' . $ statement -> errorInfo ( ) [ 2 ] . ')' . PHP_EOL ; return false ; } $ select = new Select ( $ mapping [ 'config' ] [ 'database' ] , true ) ; $ select -> select ( 'COUNT(*) as count' ) -> from ( '_stray_migration' ) ; if ( $ select -> execute ( ) === false ) { echo 'Can\'t fetch from _stray_migration (' . $ select -> getErrorMessage ( ) . ')' . PHP_EOL ; return false ; } if ( $ select -> fetch ( ) [ 'count' ] == 0 ) { $ insert = new Insert ( $ mapping [ 'config' ] [ 'database' ] ) ; $ insert -> into ( '_stray_migration' ) ; if ( $ insert -> execute ( ) === false ) { echo 'Can\'t insert into _stray_migration (' . $ insert -> getErrorMessage ( ) . ')' . PHP_EOL ; return false ; } } return true ; }
5247	public function get ( ) { $ child = $ this -> childClassName ; $ query = new QueryBuilder ( ) ; $ query -> filter ( new ParentFilter ( $ this -> parent -> getId ( ) ) ) ; $ collection = $ child :: search ( $ query ) ; $ collection -> each ( function ( ElasticsearchModel $ model ) { $ model -> setParent ( $ this -> parent ) ; } ) ; return $ collection ; }
3538	public function queryLdapUserObject ( ) { if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: beginProfile ( 'queryLdapUserObject' , static :: YII2_PROFILE_NAME . 'queryLdapUserObject' ) ; } if ( $ this -> ldapUserObject == null ) { if ( $ this -> username == null ) { throw new \ yii \ base \ Exception ( 'Please set username attribute before calling queryLdapUserObject() function.' ) ; } $ userObjectsFound = static :: getAdldapProvider ( ) -> search ( ) -> where ( 'sAMAccountname' , '=' , $ this -> username ) -> get ( ) ; if ( count ( $ userObjectsFound ) != 1 ) { $ this -> ldapUserObject = null ; } else { $ this -> ldapUserObject = $ userObjectsFound [ 0 ] ; } } if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: endProfile ( 'queryLdapUserObject' , static :: YII2_PROFILE_NAME . 'queryLdapUserObject' ) ; } return $ this -> ldapUserObject ; }
9808	private function readOPT ( ) { $ recInstance = ( 0xFFF0 & Xls :: getUInt2d ( $ this -> data , $ this -> pos ) ) >> 4 ; $ length = Xls :: getInt4d ( $ this -> data , $ this -> pos + 4 ) ; $ recordData = substr ( $ this -> data , $ this -> pos + 8 , $ length ) ; $ this -> pos += 8 + $ length ; $ this -> readOfficeArtRGFOPTE ( $ recordData , $ recInstance ) ; }
4258	public function addSubscriberInterface ( SubscriberInterface $ interface ) { $ subscribers = $ this -> getInterfaceSubscribers ( $ interface ) ; foreach ( $ subscribers as $ row ) { $ this -> subscribe ( $ row [ 0 ] , $ row [ 1 ] , $ row [ 2 ] ) ; } return $ subscribers ; }
3166	public function getCurrentAssessmentSession ( RunnerServiceContext $ context ) { if ( $ context -> isAdaptive ( ) ) { return new AssessmentItemSession ( $ context -> getCurrentAssessmentItemRef ( ) , new SessionManager ( ) ) ; } else { return $ context -> getTestSession ( ) ; } }
3475	public function getGateway ( ) { $ gateway = $ this -> gateway ; try { $ response = $ this -> guzzle -> get ( 'https://discordapp.com/api/gateway' , [ 'headers' => [ 'Authorization' => 'Bot ' . $ this -> token , ] , ] ) ; $ gateway = Arr :: get ( json_decode ( $ response -> getBody ( ) , true ) , 'url' , $ gateway ) ; } catch ( Exception $ e ) { $ this -> warn ( "Could not get a websocket gateway address, defaulting to '{$gateway}'." ) ; } return $ gateway ; }
10732	public function getSecond ( ) { if ( $ this -> value !== null ) { preg_match ( '/^(?P<year>[0-9]{4,4})-(?P<month>[0-9]{2,2})-(?P<day>[0-9]{2,2}) (?P<hour>[0-9]{2,2}):(?P<minute>[0-9]{2,2}):(?P<second>[0-9]{2,2})$/ui' , $ this -> value , $ m ) ; return ( int ) $ m [ 'second' ] ; } }
9704	public function writeWorkbook ( array $ pWorksheetSizes ) { $ this -> worksheetSizes = $ pWorksheetSizes ; $ total_worksheets = $ this -> spreadsheet -> getSheetCount ( ) ; $ this -> storeBof ( 0x0005 ) ; $ this -> writeCodepage ( ) ; $ this -> writeWindow1 ( ) ; $ this -> writeDateMode ( ) ; $ this -> writeAllFonts ( ) ; $ this -> writeAllNumberFormats ( ) ; $ this -> writeAllXfs ( ) ; $ this -> writeAllStyles ( ) ; $ this -> writePalette ( ) ; $ part3 = '' ; if ( $ this -> countryCode != - 1 ) { $ part3 .= $ this -> writeCountry ( ) ; } $ part3 .= $ this -> writeRecalcId ( ) ; $ part3 .= $ this -> writeSupbookInternal ( ) ; $ part3 .= $ this -> writeExternalsheetBiff8 ( ) ; $ part3 .= $ this -> writeAllDefinedNamesBiff8 ( ) ; $ part3 .= $ this -> writeMsoDrawingGroup ( ) ; $ part3 .= $ this -> writeSharedStringsTable ( ) ; $ part3 .= $ this -> writeEof ( ) ; $ this -> calcSheetOffsets ( ) ; for ( $ i = 0 ; $ i < $ total_worksheets ; ++ $ i ) { $ this -> writeBoundSheet ( $ this -> spreadsheet -> getSheet ( $ i ) , $ this -> worksheetOffsets [ $ i ] ) ; } $ this -> _data .= $ part3 ; return $ this -> _data ; }
4033	public function push ( $ url , $ table , $ icon ) { $ this -> elements [ ] = [ 'url' => $ url , 'text' => $ this -> getLabel ( $ table ) , 'icon' => $ this -> iconBuilder -> getBackendIcon ( $ icon ) ] ; }
5483	public function attachLabelBySelector ( SelectorInterface $ selector , $ label ) { for ( $ i = 0 , $ count = count ( $ this -> widgets ) ; $ i < $ count ; $ i ++ ) { if ( $ selector -> isMatch ( $ this -> widgets [ $ i ] ) ) { if ( method_exists ( $ this -> widgets [ $ i ] , 'setLabel' ) ) { $ this -> widgets [ $ i ] -> setLabel ( $ label ) ; return ; } } } }
2223	protected function doGetTemplateFolders ( $ path , $ level = 0 ) { $ return = array ( ) ; $ rootDir = Contao \ System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; foreach ( scan ( $ rootDir . '/' . $ path ) as $ file ) { if ( is_dir ( $ rootDir . '/' . $ path . '/' . $ file ) ) { $ return [ $ path . '/' . $ file ] = str_repeat ( ' &nbsp; &nbsp; ' , $ level ) . $ file ; $ return = array_merge ( $ return , $ this -> doGetTemplateFolders ( $ path . '/' . $ file , $ level + 1 ) ) ; } } return $ return ; }
3644	public function map ( array $ keys , bool $ trim = true , bool $ clean = true ) { $ values = $ this -> only ( array_keys ( $ keys ) , $ trim , $ clean ) ; $ new = [ ] ; foreach ( $ keys as $ key => $ value ) { $ new [ $ value ] = array_get ( $ values , $ key ) ; } return $ new ; }
2053	public function getTemplateData ( ) { $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; $ image = System :: getContainer ( ) -> get ( 'contao.image.image_factory' ) -> create ( $ rootDir . '/' . $ this -> image -> getOriginalPath ( ) ) ; $ config = new PictureConfiguration ( ) ; $ config -> setSize ( $ this -> getConfigurationItem ( $ this -> imageSize ) ) ; $ sizeItems = array ( ) ; foreach ( $ this -> imageSizeItems as $ imageSizeItem ) { $ sizeItems [ ] = $ this -> getConfigurationItem ( $ imageSizeItem ) ; } $ config -> setSizeItems ( $ sizeItems ) ; $ importantPart = $ this -> image -> getImportantPart ( ) ; $ image -> setImportantPart ( new ImportantPart ( new Point ( $ importantPart [ 'x' ] , $ importantPart [ 'y' ] ) , new Box ( $ importantPart [ 'width' ] , $ importantPart [ 'height' ] ) ) ) ; $ container = System :: getContainer ( ) ; $ staticUrl = $ container -> get ( 'contao.assets.files_context' ) -> getStaticUrl ( ) ; $ picture = $ container -> get ( 'contao.image.picture_generator' ) -> generate ( $ image , $ config , ( new ResizeOptions ( ) ) -> setImagineOptions ( $ container -> getParameter ( 'contao.image.imagine_options' ) ) -> setBypassCache ( $ container -> getParameter ( 'contao.image.bypass_cache' ) ) ) ; return array ( 'img' => $ picture -> getImg ( $ rootDir , $ staticUrl ) , 'sources' => $ picture -> getSources ( $ rootDir , $ staticUrl ) , ) ; }
10003	protected function removeRecursive ( $ path , $ pattern , Logger $ logger ) { if ( ! is_file ( $ path ) && ! is_dir ( $ path ) ) { $ logger -> log ( "$path is not a valid source." , Logger :: WARNING ) ; return ; } if ( ! is_readable ( $ path ) ) { $ logger -> log ( "$path is not readable, skipping." , Logger :: WARNING ) ; return ; } if ( ! is_writeable ( $ parent = dirname ( $ path ) ) ) { $ logger -> log ( "$parent is not writable, skipping." , Logger :: WARNING ) ; return ; } $ matchesPattern = ( ( $ pattern === null ) || ( preg_match ( $ pattern , basename ( $ path ) ) ) ) ; if ( is_file ( $ path ) ) { if ( $ matchesPattern ) { unlink ( $ path ) ; } return ; } $ dh = opendir ( $ path ) ; while ( ( $ file = readdir ( $ dh ) ) !== false ) { if ( ( $ file === '.' ) || ( $ file === '..' ) ) { continue ; } $ this -> removeRecursive ( $ path . '/' . $ file , ( $ matchesPattern ? null : $ pattern ) , $ logger ) ; } if ( $ matchesPattern ) { rmdir ( $ path ) ; } }
6004	public function setCategories ( array $ categories ) { $ this -> categories = [ ] ; foreach ( $ categories as $ item ) { $ this -> addCategoryResponse ( $ item ) ; } return $ this ; }
2236	public function generate ( $ blnNoMarkup = false ) { if ( TL_MODE == 'FE' && ! BE_USER_LOGGED_IN && ( ! $ this -> published || ( $ this -> start != '' && $ this -> start > time ( ) ) || ( $ this -> stop != '' && $ this -> stop < time ( ) ) ) ) { return '' ; } $ this -> type = 'article' ; $ this -> blnNoMarkup = $ blnNoMarkup ; if ( System :: getContainer ( ) -> has ( 'fos_http_cache.http.symfony_response_tagger' ) ) { $ responseTagger = System :: getContainer ( ) -> get ( 'fos_http_cache.http.symfony_response_tagger' ) ; $ responseTagger -> addTags ( array ( 'contao.db.tl_article.' . $ this -> id ) ) ; } return parent :: generate ( ) ; }
5176	public function add ( string $ key , $ value ) : self { if ( ! array_key_exists ( $ key , $ this -> props ) ) { return $ this -> addNew ( $ key , $ value ) ; } if ( is_array ( $ this -> props [ $ key ] ) ) { return $ this -> addArray ( $ key , $ value ) ; } return $ this -> appendToArray ( $ key , $ value ) ; }
7038	public function getShipments ( $ filter = null ) { if ( null === $ filter ) { return $ this -> shipments ; } return $ this -> shipments -> filter ( function ( ShipmentInterface $ shipment ) use ( $ filter ) { return $ filter xor $ shipment -> isReturn ( ) ; } ) ; }
8236	protected function checkServerConfiguration ( ) { $ pico = $ this -> picoAuth -> getPico ( ) ; $ configDir = $ pico -> getBaseUrl ( ) . basename ( $ pico -> getConfigDir ( ) ) ; $ configFile = $ configDir . "/config.yml" ; $ contentDir = $ pico -> getBaseUrl ( ) . basename ( $ pico -> getConfig ( 'content_dir' ) ) ; $ indexFile = $ contentDir . "/index" . $ pico -> getConfig ( 'content_ext' ) ; $ urls = array ( 'dir_listing' => $ configDir , 'config_file' => $ configFile , 'content_file' => $ indexFile ) ; $ this -> httpsTest ( ) ; $ this -> webRootDirsTest ( ) ; $ this -> picoAuth -> addOutput ( "installer_urltest" , $ urls ) ; }
9660	public static function identify ( $ pFilename ) { $ reader = self :: createReaderForFile ( $ pFilename ) ; $ className = get_class ( $ reader ) ; $ classType = explode ( '\\' , $ className ) ; unset ( $ reader ) ; return array_pop ( $ classType ) ; }
11711	public function actionBlock ( $ id , $ back = 'index' ) { if ( $ id == \ Yii :: $ app -> user -> getId ( ) ) { \ Yii :: $ app -> getSession ( ) -> setFlash ( 'danger' , \ Yii :: t ( 'user' , 'You can not block your own account' ) ) ; } else { $ user = $ this -> findModel ( $ id ) ; if ( $ user -> getIsBlocked ( ) ) { $ user -> unblock ( ) ; \ Yii :: $ app -> getSession ( ) -> setFlash ( 'success' , \ Yii :: t ( 'user' , 'User has been unblocked' ) ) ; } else { $ user -> block ( ) ; \ Yii :: $ app -> getSession ( ) -> setFlash ( 'success' , \ Yii :: t ( 'user' , 'User has been blocked' ) ) ; } } $ url = $ back == 'index' ? [ 'index' ] : [ 'update' , 'id' => $ id ] ; return $ this -> redirect ( $ url ) ; }
0	public static function supports ( IOInterface $ io , Config $ config , $ url , $ deep = false ) { if ( ! preg_match ( self :: URL_REGEX , $ url , $ match ) ) { return false ; } $ scheme = ! empty ( $ match [ 'scheme' ] ) ? $ match [ 'scheme' ] : null ; $ guessedDomain = ! empty ( $ match [ 'domain' ] ) ? $ match [ 'domain' ] : $ match [ 'domain2' ] ; $ urlParts = explode ( '/' , $ match [ 'parts' ] ) ; if ( false === self :: determineOrigin ( ( array ) $ config -> get ( 'gitlab-domains' ) , $ guessedDomain , $ urlParts ) ) { return false ; } if ( 'https' === $ scheme && ! extension_loaded ( 'openssl' ) ) { $ io -> writeError ( 'Skipping GitLab driver for ' . $ url . ' because the OpenSSL PHP extension is missing.' , true , IOInterface :: VERBOSE ) ; return false ; } return true ; }
11249	public function log ( string $ file , int $ batch ) : void { $ stmt = $ this -> pdo -> prepare ( "insert into {$this->table} (migration, batch) values (?, ?)" ) ; $ stmt -> bindParam ( 1 , $ file ) ; $ stmt -> bindParam ( 2 , $ batch , PDO :: PARAM_INT ) ; $ stmt -> execute ( ) ; }
836	public static function clearCache ( $ key = null ) { if ( null === $ key ) { self :: $ cache = [ ] ; return ; } if ( self :: hasCache ( $ key ) ) { unset ( self :: $ cache [ $ key ] ) ; } }
12064	public function setFlashBag ( $ sName , $ sValue ) { if ( ! isset ( $ _SESSION [ 'flashbag' ] ) ) { $ _SESSION [ 'flashbag' ] = array ( ) ; } $ _SESSION [ 'flashbag' ] [ $ sName ] = $ sValue ; return $ this ; }
1366	protected function bootResponseMacro ( ) { Response :: macro ( 'jsonApi' , function ( $ api = null ) { return json_api ( $ api ) -> getResponses ( ) -> withEncodingParameters ( app ( EncodingParametersInterface :: class ) ) ; } ) ; }
12679	public static function boot ( ConfigurationHandler $ configurationHandler ) { $ pluginDirs = $ configurationHandler -> pluginFolders ( ) ; foreach ( $ pluginDirs as $ pluginDir ) { self :: $ blocks += self :: parse ( $ pluginDir ) ; } }
6097	protected function get ( $ endpoint , array $ parameters = [ ] , CachePolicy $ cachePolicy = null , $ fireAndForget = false ) { return $ this -> call ( $ endpoint , $ parameters , self :: METHOD_GET , $ cachePolicy , $ fireAndForget ) ; }
5492	protected function renderArguments ( $ args ) { $ descriptions = array ( ) ; if ( is_array ( $ args ) ) { foreach ( $ args as $ arg ) { $ dumper = new SimpleDumper ( ) ; $ descriptions [ ] = $ dumper -> describeValue ( $ arg ) ; } } return implode ( ', ' , $ descriptions ) ; }
7798	public function parse ( $ text ) { $ statements = array ( ) ; foreach ( $ this -> splitStatements ( $ text ) as $ chunk ) { if ( $ statement = $ this -> statement ( $ chunk ) ) { $ statements [ ] = $ statement ; } } return $ statements ; }
11361	public function isClicked ( string $ sType ) : bool { if ( $ this -> getType ( ) === 'submit' || $ this -> getType ( ) === 'button' ) { if ( isset ( $ _POST [ $ this -> getName ( ) ] ) ) { return true ; } } return false ; }
2819	public function initQueries ( ) { $ this -> queries = array ( ) ; $ profiler = Mage :: helper ( 'sheep_debug' ) -> getSqlProfiler ( ) ; if ( $ profiler -> getEnabled ( ) && $ profiler instanceof Sheep_Debug_Model_Db_Profiler ) { $ this -> queries = $ profiler -> getQueryModels ( ) ? : array ( ) ; $ this -> setQueryCount ( $ profiler -> getTotalNumQueries ( ) ) ; $ this -> setQueryTime ( $ profiler -> getTotalElapsedSecs ( ) ) ; } }
3596	protected function createTables ( ) { $ tablesCreated = false ; $ tableSchema = Craft :: $ app -> db -> schema -> getTableSchema ( '{{%dolphiq_sitemap_entries}}' ) ; if ( $ tableSchema === null ) { $ tablesCreated = true ; $ this -> createTable ( '{{%dolphiq_sitemap_entries}}' , [ 'id' => $ this -> primaryKey ( ) , 'dateCreated' => $ this -> dateTime ( ) -> notNull ( ) , 'dateUpdated' => $ this -> dateTime ( ) -> notNull ( ) , 'uid' => $ this -> uid ( ) , 'linkId' => $ this -> integer ( ) -> notNull ( ) , 'type' => $ this -> string ( 30 ) -> notNull ( ) -> defaultValue ( '' ) , 'priority' => $ this -> double ( 2 ) -> notNull ( ) -> defaultValue ( 0.5 ) , 'changefreq' => $ this -> string ( 30 ) -> notNull ( ) -> defaultValue ( '' ) , ] ) ; } return $ tablesCreated ; }
1549	protected function authorizeRelationship ( AuthorizerInterface $ authorizer , $ request , $ record , string $ field ) : void { if ( $ this -> isModifyRelationship ( $ request ) ) { $ authorizer -> modifyRelationship ( $ record , $ field , $ request ) ; return ; } $ authorizer -> readRelationship ( $ record , $ field , $ request ) ; }
11753	public function close ( $ msgId , $ index ) { $ params = [ 'msg_data_id' => $ msgId , 'index' => $ index , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_CLOSE_COMMENT , $ params ] ) ; }
12016	public function unwatch ( ) { if ( ! $ this -> client -> getCommandFactory ( ) -> supportsCommand ( 'UNWATCH' ) ) { throw new NotSupportedException ( 'UNWATCH is not supported by the current command factory.' ) ; } $ this -> state -> unflag ( MultiExecState :: WATCH ) ; $ this -> __call ( 'UNWATCH' , array ( ) ) ; return $ this ; }
8281	public function onTwigRegistered ( & $ twig ) { $ twig -> getLoader ( ) -> addPath ( $ this -> pluginDir . '/theme' ) ; $ this_instance = $ this ; $ twig -> addFunction ( new \ Twig_SimpleFunction ( 'csrf_token' , function ( $ action = null ) use ( & $ this_instance ) { return $ this_instance -> csrf -> getToken ( $ action ) ; } , array ( 'is_safe' => array ( 'html' ) ) ) ) ; $ twig -> addFunction ( new \ Twig_SimpleFunction ( 'csrf_field' , function ( $ action = null ) use ( & $ this_instance ) { return '<input type="hidden" name="csrf_token" value="' . $ this_instance -> csrf -> getToken ( $ action ) . '">' ; } , array ( 'is_safe' => array ( 'html' ) ) ) ) ; }
6296	private static function migrateConfig ( array $ config ) : array { if ( isset ( $ config [ 'class' ] ) ) { do_action ( 'inpsyde.assets.debug' , 'The asset config-format with "type" and "class" is deprecated.' , $ config ) ; $ config [ 'location' ] = $ config [ 'type' ] ?? Asset :: FRONTEND ; $ config [ 'type' ] = $ config [ 'class' ] ; unset ( $ config [ 'class' ] ) ; } return $ config ; }
11914	public function addDynamic ( $ name , $ factory , $ createDefault = 0 , $ forceDefault = false ) { $ control = new RContainer ( $ factory , $ createDefault , $ forceDefault ) ; $ control -> currentGroup = $ this -> currentGroup ; return $ this [ $ name ] = $ control ; }
8115	public function advanceReviewDate ( ) { $ nextDateTimestamp = false ; $ options = $ this -> getOptions ( ) ; if ( $ options && $ options -> ReviewPeriodDays ) { $ nextDateTimestamp = strtotime ( ' + ' . $ options -> ReviewPeriodDays . ' days' , DBDatetime :: now ( ) -> getTimestamp ( ) ) ; $ this -> owner -> NextReviewDate = DBDate :: create ( ) -> setValue ( $ nextDateTimestamp ) -> Format ( DBDate :: ISO_DATE ) ; $ this -> owner -> write ( ) ; } return ( bool ) $ nextDateTimestamp ; }
7035	protected function createMigrationTable ( ) { $ migrations = new Table ( "migrations" , true ) ; $ migrations -> string ( "host" ) -> notNullable ( ) -> primaryComposite ( ) ; $ migrations -> timestamp ( "created_at" ) -> notNullable ( ) -> primaryComposite ( true ) ; $ migrations -> blob ( "tables" ) ; try { return $ migrations -> create ( $ this -> dbName ) ; } catch ( PDOException $ e ) { error_log ( $ e -> getMessage ( ) ) ; return false ; } }
10365	public function login ( LoginRequest $ request ) { $ this -> bus -> pipeThrough ( $ this -> pipesOf ( 'login' ) ) -> dispatchFrom ( LoginJob :: class , $ request ) ; return redirect ( ) -> route ( config ( '_auth.login.redirect' ) ) ; }
5536	public function addFrame ( $ page , $ name = false ) { $ this -> frames [ ] = $ page ; if ( $ name ) { $ this -> names [ $ name ] = count ( $ this -> frames ) - 1 ; } }
536	protected function cleanDocComment ( $ doc ) { $ lines = explode ( "\n" , $ doc ) ; $ n = \ count ( $ lines ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ lines [ $ i ] = rtrim ( $ lines [ $ i ] ) ; if ( trim ( $ lines [ $ i ] ) == '*' && trim ( $ lines [ $ i + 1 ] ) == '*' ) { unset ( $ lines [ $ i ] ) ; } } return implode ( "\n" , $ lines ) ; }
4229	protected function errorHash ( $ errorValues ) { $ errMsg = $ errorValues [ 'message' ] ; $ errMsg = \ preg_replace ( '/(\(.*?)\d+(.*?\))/' , '\1x\2' , $ errMsg ) ; $ errMsg = \ preg_replace ( '/\b([a-z]+\d+)+\b/' , 'xxx' , $ errMsg ) ; $ errMsg = \ preg_replace ( '/\b[\d.-]{4,}\b/' , 'xxx' , $ errMsg ) ; $ errMsg = \ preg_replace ( '/\s*##.+$/' , '' , $ errMsg ) ; $ hash = \ md5 ( $ errorValues [ 'file' ] . $ errorValues [ 'line' ] . $ errorValues [ 'type' ] . $ errMsg ) ; return $ hash ; }
2055	protected function validator ( $ varInput ) { $ arrTitles = array ( ) ; $ arrIds = array ( ) ; $ arrSections = array ( ) ; foreach ( $ varInput as $ arrSection ) { if ( ( ! empty ( $ arrSection [ 'title' ] ) && empty ( $ arrSection [ 'id' ] ) ) || ( empty ( $ arrSection [ 'title' ] ) && ! empty ( $ arrSection [ 'id' ] ) ) ) { $ this -> addError ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'emptyTitleOrId' ] ) ; } if ( \ in_array ( $ arrSection [ 'title' ] , $ arrTitles ) ) { $ this -> addError ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'duplicateSectionTitle' ] , $ arrSection [ 'title' ] ) ) ; } $ arrSection [ 'id' ] = StringUtil :: standardize ( $ arrSection [ 'id' ] , true ) ; if ( \ in_array ( $ arrSection [ 'id' ] , array ( 'top' , 'wrapper' , 'header' , 'container' , 'main' , 'left' , 'right' , 'footer' ) ) ) { $ arrSection [ 'id' ] .= '-custom' ; } if ( \ in_array ( $ arrSection [ 'id' ] , $ arrIds ) ) { $ this -> addError ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'duplicateSectionId' ] , $ arrSection [ 'id' ] ) ) ; } $ arrTitles [ ] = $ arrSection [ 'title' ] ; $ arrIds [ ] = $ arrSection [ 'id' ] ; $ arrSections [ ] = $ arrSection ; } return $ arrSections ; }
2331	public function fetchEach ( $ strKey ) { $ this -> reset ( ) ; $ return = array ( ) ; while ( $ this -> next ( ) ) { $ strPk = $ this -> current ( ) -> getPk ( ) ; if ( $ strKey != 'id' && isset ( $ this -> $ strPk ) ) { $ return [ $ this -> $ strPk ] = $ this -> $ strKey ; } else { $ return [ ] = $ this -> $ strKey ; } } return $ return ; }
8752	public function addDefinition ( $ identifier , DefinitionInterface $ definition ) { $ this -> definitions [ $ identifier ] = $ definition ; unset ( $ this -> dumpableDefinitions [ $ identifier ] ) ; }
6789	protected function assertShipmentPlatform ( ShipmentInterface $ shipment ) { if ( $ shipment -> getPlatformName ( ) !== $ this -> getName ( ) ) { throw new InvalidArgumentException ( sprintf ( "Platform %s does not support shipment %s." , $ this -> getName ( ) , $ shipment -> getNumber ( ) ) ) ; } }
7406	public function replace ( $ in ) { $ this -> _massageBlockInput ( $ in ) ; foreach ( $ in as $ k => $ v ) { $ this -> offsetSet ( $ k , $ v ) ; } }
6448	public function getBestLanguageMatch ( array $ supportedLanguages , array $ languageHeaders ) : ? string { usort ( $ languageHeaders , [ $ this , 'compareAcceptLanguageHeaders' ] ) ; $ rankedLanguageHeaders = array_filter ( $ languageHeaders , [ $ this , 'filterZeroScores' ] ) ; $ rankedLanguageHeaderValues = $ this -> getLanguageValuesFromHeaders ( $ rankedLanguageHeaders ) ; foreach ( $ rankedLanguageHeaderValues as $ language ) { $ languageParts = explode ( '-' , $ language ) ; do { foreach ( $ supportedLanguages as $ supportedLanguage ) { if ( $ language === '*' || implode ( '-' , $ languageParts ) === $ supportedLanguage ) { return $ supportedLanguage ; } } array_pop ( $ languageParts ) ; } while ( count ( $ languageParts ) > 0 ) ; } return null ; }
11183	public function getActions ( ) { if ( $ this -> useCache ( ) ) { if ( $ this -> getExtCache ( ) -> isCached ( ) ) { return $ this -> getExtCache ( ) -> getActions ( ) ; } } $ actions = $ this -> generateActions ( ) ; if ( $ this -> useCache ( ) ) { $ this -> getExtCache ( ) -> cacheActions ( $ actions ) ; } return $ actions ; }
6843	public function call ( Closure $ c , $ params = array ( ) ) { $ ref = new ReflectionFunction ( $ c ) ; $ params_need = $ ref -> getParameters ( ) ; $ args = $ this -> apply ( $ params_need , $ params ) ; return call_user_func_array ( $ c , $ args ) ; }
4211	public static function getConstants ( $ phpVer = null ) { $ phpVer = $ phpVer ? : PHP_VERSION ; $ phpVer = \ preg_match ( '/^\d+\.\d+$/' , $ phpVer ) ? $ phpVer . '.0' : $ phpVer ; $ constants = array ( 'E_ERROR' => 1 , 'E_WARNING' => 2 , 'E_PARSE' => 4 , 'E_NOTICE' => 8 , 'E_CORE_ERROR' => 16 , 'E_CORE_WARNING' => 32 , 'E_COMPILE_ERROR' => 64 , 'E_COMPILE_WARNING' => 128 , 'E_USER_ERROR' => 256 , 'E_USER_WARNING' => 512 , 'E_USER_NOTICE' => 1024 , 'E_STRICT' => \ version_compare ( $ phpVer , '5.0.0' , '>=' ) ? 2048 : null , 'E_RECOVERABLE_ERROR' => \ version_compare ( $ phpVer , '5.2.0' , '>=' ) ? 4096 : null , 'E_DEPRECATED' => \ version_compare ( $ phpVer , '5.3.0' , '>=' ) ? 8192 : null , 'E_USER_DEPRECATED' => \ version_compare ( $ phpVer , '5.3.0' , '>=' ) ? 16384 : null , 'E_ALL' => null , ) ; $ constants = \ array_filter ( $ constants ) ; $ constants [ 'E_ALL' ] = \ array_sum ( $ constants ) ; if ( isset ( $ constants [ 'E_STRICT' ] ) && \ version_compare ( $ phpVer , '5.4.0' , '<' ) ) { $ constants [ 'E_ALL' ] -= $ constants [ 'E_STRICT' ] ; } return $ constants ; }
9813	protected function deleteRaw ( string $ path , $ body = null , array $ headers = [ ] ) { $ response = $ this -> client -> delete ( $ path , $ headers , $ body ) ; return ResponseMediator :: getContent ( $ response ) ; }
168	protected static function loadMimeAliases ( $ aliasesFile ) { if ( $ aliasesFile === null ) { $ aliasesFile = static :: $ mimeAliasesFile ; } $ aliasesFile = Yii :: getAlias ( $ aliasesFile ) ; if ( ! isset ( self :: $ _mimeAliases [ $ aliasesFile ] ) ) { self :: $ _mimeAliases [ $ aliasesFile ] = require $ aliasesFile ; } return self :: $ _mimeAliases [ $ aliasesFile ] ; }
1343	public function isIndex ( ) : bool { return $ this -> isMethod ( 'get' ) && $ this -> getRoute ( ) -> isNotResource ( ) && $ this -> getRoute ( ) -> isNotProcesses ( ) ; }
7332	private function configureStockUnitDiscriminatorMap ( LoadClassMetadataEventArgs $ eventArgs ) { $ metadata = $ eventArgs -> getClassMetadata ( ) ; if ( ! is_subclass_of ( $ metadata -> name , Stock \ StockUnitInterface :: class ) ) { return ; } $ this -> getStockUnitMapper ( $ eventArgs -> getEntityManager ( ) ) -> processClassMetadata ( $ metadata ) ; }
6947	private function getOutstandingExpiredDueQueryBuilder ( ) { $ qb = $ this -> createQueryBuilder ( 'o' ) ; $ ex = $ qb -> expr ( ) ; $ qb -> join ( 'o.paymentTerm' , 't' ) -> where ( $ ex -> andX ( $ ex -> eq ( 'o.sample' , ':not_sample' ) , $ ex -> lt ( 'o.paidTotal' , 'o.grandTotal' ) , $ ex -> notIn ( 'o.invoiceState' , ':canceled_or_refunded' ) , $ qb -> expr ( ) -> lte ( 'o.outstandingDate' , ':today' ) , $ this -> getDueClauses ( ) ) ) -> addOrderBy ( 'o.outstandingDate' , 'ASC' ) -> setParameter ( 'not_sample' , false ) -> setParameter ( 'today' , ( new \ DateTime ( ) ) -> setTime ( 23 , 59 , 59 ) , Type :: DATETIME ) -> setParameter ( 'canceled_or_refunded' , [ InvoiceStates :: STATE_CANCELED , InvoiceStates :: STATE_CREDITED ] ) ; $ this -> setDueParameters ( $ qb ) ; return $ qb ; }
5414	public function getRequestLine ( $ method ) { $ url = $ this -> getUrl ( ) ; $ scheme = $ url -> getScheme ( ) ? $ url -> getScheme ( ) : 'http' ; $ port = $ url -> getPort ( ) ? ':' . $ url -> getPort ( ) : '' ; return $ method . ' ' . $ scheme . '://' . $ url -> getHost ( ) . $ port . $ url -> getPath ( ) . $ url -> getEncodedRequest ( ) . ' HTTP/1.0' ; }
105	public function watch2OnHighest ( Decisions $ decisions ) { $ literals = $ this -> rule -> getLiterals ( ) ; if ( count ( $ literals ) < 3 ) { return ; } $ watchLevel = 0 ; foreach ( $ literals as $ literal ) { $ level = $ decisions -> decisionLevel ( $ literal ) ; if ( $ level > $ watchLevel ) { $ this -> watch2 = $ literal ; $ watchLevel = $ level ; } } }
5	private function buildDepPackageConstraints ( $ depItem , $ depType ) { if ( $ this -> isHash ( $ depItem ) ) { $ depItem = array ( $ depItem ) ; } $ result = array ( ) ; foreach ( $ depItem as $ subDepItem ) { if ( ! array_key_exists ( 'channel' , $ subDepItem ) ) { $ subDepItem [ 'channel' ] = $ subDepItem [ 'uri' ] ; } $ depChannelName = $ subDepItem [ 'channel' ] ; $ depPackageName = $ subDepItem [ 'name' ] ; $ depVersionConstraint = $ this -> parse20VersionConstraint ( $ subDepItem ) ; if ( isset ( $ subDepItem [ 'conflicts' ] ) ) { $ depType = 'conflicts' ; } $ result [ ] = new DependencyConstraint ( $ depType , $ depVersionConstraint , $ depChannelName , $ depPackageName ) ; } return $ result ; }
11941	public function onExecuteAction ( ExecuteActionEvent $ event ) { $ request = $ event -> getRequest ( ) ; $ position = 1 ; foreach ( $ request -> getConfig ( ) -> getArray ( 'argument' ) as $ argument ) { $ this -> validateArgument ( $ request , $ argument , $ position ++ ) ; } }
11917	public function newInstanceQuery ( array $ data = [ ] , array $ selectable = [ '*' ] ) { $ tm = new TextGenerator ( ) ; $ r = $ this -> newInstanceRepository ( ) ; $ query = $ r -> newQuery ( ) ; if ( ! empty ( $ this -> filter ) ) { $ filter = new Filter ( $ r -> getTableName ( ) , $ selectable ) ; $ filter -> build ( $ query , $ tm -> generateAndRender ( $ this -> filter , $ data ) ) ; } return $ query ; }
10541	public function getFiltroConfiguration ( $ filtroName ) { if ( ! isset ( $ this -> config [ 'filtros' ] [ $ filtroName ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Filtro "%s" is not managed.' , $ filtroName ) ) ; } return $ this -> config [ 'filtros' ] [ $ filtroName ] ; }
5475	public function getAction ( ) { $ url = $ this -> action ; if ( $ this -> default_target && ! $ url -> getTarget ( ) ) { $ url -> setTarget ( $ this -> default_target ) ; } if ( $ this -> getMethod ( ) === 'get' ) { $ url -> clearRequest ( ) ; } return $ url ; }
2829	public function enableSqlProfilerAction ( ) { try { $ this -> getService ( ) -> setSqlProfilerStatus ( true ) ; $ this -> getService ( ) -> flushCache ( ) ; Mage :: getSingleton ( 'core/session' ) -> addSuccess ( 'SQL profiler was enabled.' ) ; } catch ( Exception $ e ) { Mage :: getSingleton ( 'core/session' ) -> addError ( 'Unable to enable SQL profiler: ' . $ e -> getMessage ( ) ) ; } $ this -> _redirectReferer ( ) ; }
11600	public function getConfig ( string $ sName = '' ) { if ( empty ( $ sName ) ) { return $ this -> configSet ; } elseif ( isset ( $ this -> configSet [ $ sName ] ) ) { return $ this -> configSet [ $ sName ] ; } else { return null ; } }
8289	protected function authRoutes ( ) { switch ( $ this -> requestUrl ) { case 'login' : if ( $ this -> user -> getAuthenticated ( ) ) { $ this -> redirectToPage ( $ this -> config [ "afterLogin" ] ) ; } break ; case 'logout' : if ( ! $ this -> user -> getAuthenticated ( ) ) { $ this -> redirectToLogin ( ) ; } $ this -> checkLogoutSubmission ( ) ; break ; } }
2312	public function getCacheName ( ) { $ importantPart = $ this -> getImportantPart ( ) ; $ strCacheKey = substr ( md5 ( '-w' . $ this -> getTargetWidth ( ) . '-h' . $ this -> getTargetHeight ( ) . '-o' . $ this -> getOriginalPath ( ) . '-m' . $ this -> getResizeMode ( ) . '-z' . $ this -> getZoomLevel ( ) . '-x' . $ importantPart [ 'x' ] . '-y' . $ importantPart [ 'y' ] . '-i' . $ importantPart [ 'width' ] . '-e' . $ importantPart [ 'height' ] . '-t' . $ this -> fileObj -> mtime ) , 0 , 8 ) ; return StringUtil :: stripRootDir ( System :: getContainer ( ) -> getParameter ( 'contao.image.target_dir' ) ) . '/' . substr ( $ strCacheKey , - 1 ) . '/' . $ this -> fileObj -> filename . '-' . $ strCacheKey . '.' . $ this -> fileObj -> extension ; }
2884	public function startProfiling ( ) { $ this -> canCapture = Mage :: helper ( 'sheep_debug' ) -> canCapture ( ) ; if ( ! $ this -> canCapture ) { return ; } $ requestInfo = $ this -> getRequestInfo ( ) ; $ requestInfo -> setIsStarted ( true ) ; $ this -> registerShutdown ( ) ; $ requestInfo -> setStoreId ( $ this -> getCurrentStore ( ) -> getId ( ) ) ; $ requestInfo -> setDate ( date ( 'Y-m-d H:i:s' ) ) ; $ requestInfo -> initController ( ) ; $ requestInfo -> initLogging ( ) ; if ( Mage :: helper ( 'sheep_debug' ) -> canEnableVarienProfiler ( ) ) { Varien_Profiler :: enable ( ) ; } $ stackTraceProfiler = Mage :: getModel ( 'sheep_debug/db_profiler' ) ; $ stackTraceProfiler -> setCaptureStacktraces ( Mage :: helper ( 'sheep_debug' ) -> canEnableSqlStacktrace ( ) ) ; $ stackTraceProfiler -> replaceProfiler ( ) ; }
12914	protected function getWhereAsArray ( ) { $ filters = [ ] ; if ( ! empty ( $ this -> filters ) ) { $ filters = $ this -> filters ; } if ( ! $ this -> allowDeleted ) { $ filters [ ] = "(`" . $ this -> table . "`.deleted = 0 OR `" . $ this -> table . "`.deleted IS NULL)" ; } if ( ! empty ( $ this -> joins ) ) { foreach ( $ this -> joins as $ join ) { $ manager = $ join [ 'manager' ] ; $ filters = array_merge ( $ filters , $ manager -> getWhereAsArray ( ) ) ; } } return $ filters ; }
7728	public function quickReplies ( $ text , $ quickReplies ) { $ this -> setText ( $ text ) ; foreach ( $ quickReplies as $ quickReplie ) { $ this -> setQuickReplies ( $ quickReplie ) ; } return $ this ; }
1099	protected function resolveNode ( $ node ) { if ( $ node instanceof \ Baum \ Node ) return $ node -> reload ( ) ; return $ this -> node -> newNestedSetQuery ( ) -> find ( $ node ) ; }
10664	public function withRequest ( RequestInterface $ request ) { $ object = clone $ this ; $ object -> request = $ request ; $ object -> method = $ request -> getMethod ( ) ; return $ object ; }
8326	public function sendRecaptchaV2 ( $ googleKey , $ pageUrl , $ extra = [ ] ) { $ this -> getLogger ( ) -> info ( "Try send google key (recaptcha) on {$this->serverBaseUri}/in.php" ) ; if ( $ this -> softId && ! isset ( $ extra [ Extra :: SOFT_ID ] ) ) { $ extra [ Extra :: SOFT_ID ] = $ this -> softId ; } $ response = $ this -> getHttpClient ( ) -> request ( 'POST' , "/in.php" , [ RequestOptions :: QUERY => array_merge ( $ extra , [ 'method' => 'userrecaptcha' , 'key' => $ this -> apiKey , 'googlekey' => $ googleKey , 'pageurl' => $ pageUrl ] ) ] ) ; $ responseText = $ response -> getBody ( ) -> __toString ( ) ; if ( strpos ( $ responseText , 'OK|' ) !== false ) { $ this -> lastCaptchaId = explode ( "|" , $ responseText ) [ 1 ] ; $ this -> getLogger ( ) -> info ( "Sending success. Got captcha id `{$this->lastCaptchaId}`." ) ; return $ this -> lastCaptchaId ; } throw new ErrorResponseException ( $ this -> getErrorMessage ( $ responseText ) ? : "Unknown error: `{$responseText}`." ) ; }
4567	public function resolve ( Form $ form ) { switch ( $ form -> getType ( ) ) { case Form :: TYPE_FORMIO : $ components = $ form -> getSchema ( ) ; $ resolverCollection = $ this -> resolverCollection ; $ resolve = function ( & $ component ) use ( & $ resolve , $ resolverCollection ) { switch ( true ) { case property_exists ( $ component , 'components' ) : foreach ( $ component -> components as & $ subComponent ) { $ resolve ( $ subComponent ) ; } break ; case property_exists ( $ component , 'columns' ) : foreach ( $ component -> columns as & $ column ) { foreach ( $ column -> components as & $ subComponent ) { $ resolve ( $ subComponent ) ; } } break ; case property_exists ( $ component , 'defaultValue' ) : if ( null !== $ component -> defaultValue ) { try { $ component -> defaultValue = $ resolverCollection -> resolve ( $ component -> defaultValue ) ; } catch ( UnresolvedException $ exception ) { $ component -> defaultValue = null ; } catch ( UnmatchedException $ exception ) { } } break ; } } ; foreach ( $ components as & $ component ) { $ resolve ( $ component ) ; } $ form -> setSchema ( $ components ) ; break ; case Form :: TYPE_SYMFONY : break ; default : throw new DomainException ( 'Form type does not exist.' ) ; } return $ form ; }
8653	private function convertUpdateReportAcknowledgements ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'UpdateReportAcknowledgements' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetReportIdList ( ) ) { $ reportIdList = $ request -> getReportIdList ( ) ; foreach ( $ reportIdList -> getId ( ) as $ idIndex => $ id ) { $ parameters [ 'ReportIdList' . '.' . 'Id' . '.' . ( $ idIndex + 1 ) ] = $ id ; } } if ( $ request -> isSetAcknowledged ( ) ) { $ parameters [ 'Acknowledged' ] = $ request -> getAcknowledged ( ) ? "true" : "false" ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
12007	final public function getPermissions ( $ authenticated ) { $ this -> userid = ( int ) $ authenticated -> get ( "user_id" ) ; if ( $ authenticated -> authenticated && ! empty ( $ this -> userid ) ) { $ this -> setAuthority ( AUTHROITY_IMPLIED_AUTHENTICATED ) ; } }
12162	public function getForm ( $ primaryModel = false , $ settings = [ ] ) { if ( ! $ primaryModel ) { return false ; } $ formSegments = [ $ this -> getFormSegment ( $ primaryModel , $ settings ) ] ; $ config = [ 'class' => $ this -> formGeneratorClass , 'models' => $ primaryModel -> collectModels ( ) , 'items' => $ formSegments ] ; return Yii :: createObject ( $ config ) ; }
6476	public function readAsJson ( ? IHttpBody $ body ) : array { if ( $ body === null ) { return [ ] ; } $ json = json_decode ( $ body -> readAsString ( ) , true ) ; if ( $ json === null ) { throw new RuntimeException ( 'Body could not be decoded as JSON' ) ; } return $ json ; }
2393	public function addFile ( $ strFile , $ strName = null ) { if ( ! file_exists ( $ this -> strRootDir . '/' . $ strFile ) ) { throw new \ Exception ( "File $strFile does not exist" ) ; } if ( strncmp ( $ strName , '/' , 1 ) === 0 ) { $ strName = substr ( $ strName , 1 ) ; } $ this -> addString ( file_get_contents ( $ this -> strRootDir . '/' . $ strFile ) , $ strName ? : $ strFile , filemtime ( $ this -> strRootDir . '/' . $ strFile ) ) ; }
6439	public function getUserProfile ( ) { $ connection = new TwitterOAuth ( $ this -> options [ 'consumer_key' ] , $ this -> options [ 'consumer_secret' ] , $ this -> access_token [ 'oauth_token' ] , $ this -> access_token [ 'oauth_token_secret' ] ) ; $ connection -> setTimeouts ( 10 , 15 ) ; $ user = $ connection -> get ( "account/verify_credentials" ) ; return array ( 'userid' => $ user -> id , 'name' => $ user -> screen_name , 'imageurl' => $ user -> profile_image_url ) ; }
6388	public function readSite ( ) { $ model = $ this -> readCourse ( 1 ) ; $ model -> url = $ this -> cfg -> wwwroot ; $ model -> type = "site" ; return $ model ; }
5012	public function injectLogger ( bool $ flag = null ) : bool { if ( null === $ flag ) { return $ this -> injectLogger ; } $ this -> injectLogger = $ flag ; return $ flag ; }
635	public function renameTable ( $ table , $ newName ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> renameTable ( $ table , $ newName ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; }
5493	public function add ( $ parameters , $ action ) { $ place = count ( $ this -> map ) ; $ this -> map [ $ place ] = array ( ) ; $ this -> map [ $ place ] [ 'params' ] = new ParametersExpectation ( $ parameters ) ; $ this -> map [ $ place ] [ 'content' ] = $ action ; }
3795	private function checkEmpty ( $ action ) { if ( $ this -> hasVariants ( ) && $ this -> currentModel !== null ) { $ this -> disablePA = false ; } elseif ( $ action == 'create' ) { $ this -> disablePA = false ; $ this -> disablePI = false ; } }
9043	protected function logImpl ( $ level , $ message , array $ context = array ( ) ) { if ( ! $ this -> levelHasReached ( $ level ) ) { return ; } if ( $ this -> isRotationNeeded ( ) ) { unlink ( $ this -> file ) ; } $ ms = $ this -> getMessage ( $ level , $ message , $ context ) ; $ fos = new FileOutputStream ( $ this -> file , true ) ; $ fos -> write ( $ ms ) ; $ fos -> flush ( ) ; $ fos -> close ( ) ; }
6739	public function set_options ( ) { $ slug = Module :: CustomRatingGrifus ( ) -> getOption ( 'slug' ) ; $ options = $ this -> model -> get_options ( ) ; foreach ( $ options as $ option => $ value ) { Module :: CustomRatingGrifus ( ) -> setOption ( $ option , $ value ) ; } }
273	public function asXml ( $ data ) { $ response = Yii :: $ app -> getResponse ( ) ; $ response -> format = Response :: FORMAT_XML ; $ response -> data = $ data ; return $ response ; }
1581	public function withAttributes ( $ attributes ) : self { $ copy = clone $ this ; $ copy -> attributes = collect ( $ attributes ) -> all ( ) ; $ copy -> normalize ( ) ; return $ copy ; }
1073	private function getSuggestedFieldNames ( Schema $ schema , $ type , $ fieldName ) { if ( $ type instanceof ObjectType || $ type instanceof InterfaceType ) { $ possibleFieldNames = array_keys ( $ type -> getFields ( ) ) ; return Utils :: suggestionList ( $ fieldName , $ possibleFieldNames ) ; } return [ ] ; }
9990	private function writeImageInCell ( Worksheet $ pSheet , $ coordinates ) { $ html = '' ; foreach ( $ pSheet -> getDrawingCollection ( ) as $ drawing ) { if ( $ drawing instanceof Drawing ) { if ( $ drawing -> getCoordinates ( ) == $ coordinates ) { $ filename = $ drawing -> getPath ( ) ; if ( substr ( $ filename , 0 , 1 ) == '.' ) { $ filename = substr ( $ filename , 1 ) ; } $ filename = $ this -> getImagesRoot ( ) . $ filename ; if ( substr ( $ filename , 0 , 1 ) == '.' && substr ( $ filename , 0 , 2 ) != './' ) { $ filename = substr ( $ filename , 1 ) ; } $ filename = htmlspecialchars ( $ filename ) ; $ html .= PHP_EOL ; if ( ( ! $ this -> embedImages ) || ( $ this -> isPdf ) ) { $ imageData = $ filename ; } else { $ imageDetails = getimagesize ( $ filename ) ; if ( $ fp = fopen ( $ filename , 'rb' , 0 ) ) { $ picture = fread ( $ fp , filesize ( $ filename ) ) ; fclose ( $ fp ) ; $ base64 = chunk_split ( base64_encode ( $ picture ) ) ; $ imageData = 'data:' . $ imageDetails [ 'mime' ] . ';base64,' . $ base64 ; } else { $ imageData = $ filename ; } } $ html .= '<div style="position: relative;">' ; $ html .= '<img style="position: absolute; z-index: 1; left: ' . $ drawing -> getOffsetX ( ) . 'px; top: ' . $ drawing -> getOffsetY ( ) . 'px; width: ' . $ drawing -> getWidth ( ) . 'px; height: ' . $ drawing -> getHeight ( ) . 'px;" src="' . $ imageData . '" border="0" />' ; $ html .= '</div>' ; } } elseif ( $ drawing instanceof MemoryDrawing ) { if ( $ drawing -> getCoordinates ( ) != $ coordinates ) { continue ; } ob_start ( ) ; imagepng ( $ drawing -> getImageResource ( ) ) ; $ contents = ob_get_contents ( ) ; ob_end_clean ( ) ; $ dataUri = 'data:image/jpeg;base64,' . base64_encode ( $ contents ) ; $ html .= '<img src="' . $ dataUri . '" style="max-width:100%;width:' . $ drawing -> getWidth ( ) . 'px;" />' ; } } return $ html ; }
10168	public static function getInt4d ( $ data , $ pos ) { $ _or_24 = ord ( $ data [ $ pos + 3 ] ) ; if ( $ _or_24 >= 128 ) { $ _ord_24 = - abs ( ( 256 - $ _or_24 ) << 24 ) ; } else { $ _ord_24 = ( $ _or_24 & 127 ) << 24 ; } return ord ( $ data [ $ pos ] ) | ( ord ( $ data [ $ pos + 1 ] ) << 8 ) | ( ord ( $ data [ $ pos + 2 ] ) << 16 ) | $ _ord_24 ; }
5593	protected function fetch ( $ url , $ encoding ) { $ request = $ this -> createRequest ( $ url , $ encoding ) ; return $ request -> fetch ( $ this -> connection_timeout ) ; }
10258	public function getCompanyName ( $ base_name = null ) { $ suffixes = [ 'Corporation' , 'Company' , 'Company, Limited' , 'Computer Repair' , 'Incorporated' , 'and Sons' , 'Group' , 'Group, PLC' , 'Furniture' , 'Flowers' , 'Sales' , 'Systems' , 'Tire' , 'Auto' , 'Plumbing' , 'Roofing' , 'Realty' , 'Foods' , 'Books' ] ; if ( empty ( $ base_name ) ) { $ base_name = $ this -> getLastName ( ) ; } return $ base_name . ' ' . $ this -> fromArray ( $ suffixes ) ; }
11277	protected function getStubs ( ? string $ table = null , bool $ create = false ) : iterable { if ( is_null ( $ table ) ) { yield M :: TYPE_UP => $ this -> stubs -> read ( 'blank.sql.stub' ) ; yield M :: TYPE_DOWN => $ this -> stubs -> read ( 'blank.sql.stub' ) ; return ; } $ first = [ M :: TYPE_UP => 'create.sql.stub' , M :: TYPE_DOWN => 'down.sql.stub' ] ; $ second = [ M :: TYPE_UP => 'update.sql.stub' , M :: TYPE_DOWN => 'update.sql.stub' ] ; $ stubs = $ create ? $ first : $ second ; foreach ( $ stubs as $ type => $ stub ) { yield $ type => $ this -> stubs -> read ( $ stub ) ; } }
6621	public function set_submenu ( ) { $ submenu = Module :: CustomRatingGrifus ( ) -> getOption ( 'submenu' ) ; WP_Menu :: add ( 'submenu' , $ submenu [ 'custom-rating-grifus' ] , [ $ this , 'render' ] , [ $ this , 'add_scripts' ] , [ $ this , 'add_styles' ] ) ; }
10973	public static function getAuthPassword ( ) { $ result = null ; if ( isset ( $ _SERVER [ 'PHP_AUTH_PW' ] ) ) { $ result = $ _SERVER [ 'PHP_AUTH_PW' ] ; } if ( trim ( $ result ) == '' ) { $ result = null ; } return $ result ; }
11959	public function splice ( $ offset = 0 , $ length = 0 , $ replacement = [ ] ) { return new static ( array_splice ( $ this -> elements , $ offset , $ length , $ replacement ) ) ; }
8059	public function setSemaphore ( Semaphore $ semaphore ) { if ( $ this -> created ) { throw new WorkerPoolException ( 'Cannot set the Worker Pool Size for a created pool.' ) ; } if ( ! $ semaphore -> isCreated ( ) ) { throw new \ InvalidArgumentException ( 'The Semaphore hasn\'t yet been created.' ) ; } $ this -> semaphore = $ semaphore ; return $ this ; }
12782	public function getAll ( ) { if ( is_null ( $ this -> intersections ) ) { $ this -> intersections = [ ] ; if ( $ this -> arraysSize >= 2 ) { $ this -> createIntersections ( ) ; } } return $ this -> intersections ; }
7725	public function url ( $ text , $ title , $ url ) { $ payload = [ 'template_type' => 'button' , 'text' => $ text , 'buttons' => [ [ 'title' => $ title , 'url' => $ url ] ] , ] ; $ this -> setAttachment ( 'template' , $ payload ) ; return $ this ; }
706	public function primaryKey ( $ length = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_PK , $ length ) ; }
827	public function getCommentBlockIndices ( Tokens $ tokens , $ index ) { if ( ! $ tokens [ $ index ] -> isGivenKind ( T_COMMENT ) ) { throw new \ InvalidArgumentException ( 'Given index must point to a comment.' ) ; } $ commentType = $ this -> getCommentType ( $ tokens [ $ index ] -> getContent ( ) ) ; $ indices = [ $ index ] ; if ( self :: TYPE_SLASH_ASTERISK === $ commentType ) { return $ indices ; } $ count = \ count ( $ tokens ) ; ++ $ index ; for ( ; $ index < $ count ; ++ $ index ) { if ( $ tokens [ $ index ] -> isComment ( ) ) { if ( $ commentType === $ this -> getCommentType ( $ tokens [ $ index ] -> getContent ( ) ) ) { $ indices [ ] = $ index ; continue ; } break ; } if ( ! $ tokens [ $ index ] -> isWhitespace ( ) || $ this -> getLineBreakCount ( $ tokens , $ index , $ index + 1 ) > 1 ) { break ; } } return $ indices ; }
7962	public function canChangeLns ( $ forceReload = false ) { if ( ! $ this -> properties || $ forceReload ) $ this -> getProperties ( ) ; return $ this -> properties -> capabilities -> canChangeLns ; }
8493	public function setFeeList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'FeeList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
8570	public function getLastUpdatedTimeForRecommendations ( $ request ) { if ( ! ( $ request instanceof MWSRecommendationsSectionService_Model_GetLastUpdatedTimeForRecommendationsRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/GetLastUpdatedTimeForRecommendationsRequest.php' ) ; $ request = new MWSRecommendationsSectionService_Model_GetLastUpdatedTimeForRecommendationsRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetLastUpdatedTimeForRecommendations' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/GetLastUpdatedTimeForRecommendationsResponse.php' ) ; $ response = MWSRecommendationsSectionService_Model_GetLastUpdatedTimeForRecommendationsResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
736	protected function getInheritedPermissionsByUser ( $ userId ) { $ assignments = $ this -> getAssignments ( $ userId ) ; $ result = [ ] ; foreach ( array_keys ( $ assignments ) as $ roleName ) { $ this -> getChildrenRecursive ( $ roleName , $ result ) ; } if ( empty ( $ result ) ) { return [ ] ; } $ permissions = [ ] ; foreach ( array_keys ( $ result ) as $ itemName ) { if ( isset ( $ this -> items [ $ itemName ] ) && $ this -> items [ $ itemName ] instanceof Permission ) { $ permissions [ $ itemName ] = $ this -> items [ $ itemName ] ; } } return $ permissions ; }
2874	public function enableAction ( ) { $ moduleName = ( string ) $ this -> getRequest ( ) -> getParam ( 'module' ) ; try { $ this -> getService ( ) -> setModuleStatus ( $ moduleName , true ) ; $ this -> getService ( ) -> flushCache ( ) ; Mage :: getSingleton ( 'core/session' ) -> addSuccess ( 'Module was enabled.' ) ; } catch ( Exception $ e ) { Mage :: getSingleton ( 'core/session' ) -> addError ( 'Unable to enable module: ' . $ e -> getMessage ( ) ) ; } $ this -> _redirectReferer ( ) ; }
12614	public function have_required_properties ( ) { return ( ! empty ( $ this -> handle ) && ! empty ( $ this -> relative_path ) && ! empty ( $ this -> filename ) ) ; }
10879	protected function convertExceptionToArray ( $ exception ) { if ( ! YII_DEBUG && ! $ exception instanceof UserException && ! $ exception instanceof HttpException ) { $ exception = new HttpException ( 500 , 'There was an error at the server.' ) ; } $ array = [ 'name' => ( $ exception instanceof Exception || $ exception instanceof ErrorException ) ? $ exception -> getName ( ) : 'Exception' , 'message' => $ exception -> getMessage ( ) , 'code' => $ exception -> getCode ( ) , ] ; if ( $ exception instanceof HttpException ) { $ array [ 'status' ] = $ exception -> statusCode ; } if ( YII_DEBUG ) { $ array [ 'type' ] = get_class ( $ exception ) ; if ( ! $ exception instanceof UserException ) { $ array [ 'file' ] = $ exception -> getFile ( ) ; $ array [ 'line' ] = $ exception -> getLine ( ) ; $ array [ 'stack-trace' ] = explode ( "\n" , $ exception -> getTraceAsString ( ) ) ; if ( $ exception instanceof \ yii \ db \ Exception ) { $ array [ 'error-info' ] = $ exception -> errorInfo ; } } } if ( ( $ prev = $ exception -> getPrevious ( ) ) !== null ) { $ array [ 'previous' ] = $ this -> convertExceptionToArray ( $ prev ) ; } return $ array ; }
1166	protected function parseParameters ( $ parameters ) { $ newParams = [ 'validate_all' => false ] ; if ( isset ( $ parameters [ 0 ] ) ) { $ newParams [ 'validate_all' ] = ( $ parameters [ 0 ] === 'true' ) ? true : false ; } return $ newParams ; }
7063	protected function getAcceptedStates ( PaymentInterface $ payment ) { $ acceptedStates = PaymentStates :: getPaidStates ( ) ; if ( $ payment -> getMethod ( ) -> isOutstanding ( ) ) { $ acceptedStates [ ] = PaymentStates :: STATE_EXPIRED ; } return $ acceptedStates ; }
2793	public function getCacheDirectory ( ) { if ( ! is_null ( $ this -> cacheDirectory ) ) { return $ this -> cacheDirectory ; } if ( defined ( 'PHP_WINDOWS_VERSION_MAJOR' ) ) { if ( ! getenv ( 'APPDATA' ) ) { throw new RuntimeException ( 'The APPDATA environment variable must be set for humbug.' ) ; } $ home = strtr ( getenv ( 'APPDATA' ) , '\\' , '/' ) . '/Humbug' ; } else { if ( ! getenv ( 'HOME' ) ) { throw new RuntimeException ( 'The HOME environment variable must be set for humbug.' ) ; } $ home = rtrim ( getenv ( 'HOME' ) , '/' ) . '/.humbug' ; } $ cache = $ home . '/cache' ; foreach ( [ $ home , $ cache ] as $ dir ) { if ( ! is_dir ( $ dir ) ) { mkdir ( $ dir , 0777 ) ; } } file_put_contents ( $ home . '/.htaccess' , 'Deny from all' ) ; $ this -> cacheDirectory = $ cache ; return $ cache ; }
3592	protected function loadMetaAttributes ( ) { if ( ! array_key_exists ( 'metaAttributes' , $ this -> relations ) ) { $ this -> reloadMetaAttributes ( ) ; } $ attributes = $ this -> getRelation ( 'metaAttributes' ) ; if ( ! $ attributes instanceof AttributeBag ) { $ this -> setRelation ( 'metaAttributes' , ( new Attribute ) -> newBag ( $ attributes -> all ( ) ) ) ; } }
9994	public function formatColor ( $ pValue , $ pFormat ) { $ color = null ; $ matches = [ ] ; $ color_regex = '/^\\[[a-zA-Z]+\\]/' ; if ( preg_match ( $ color_regex , $ pFormat , $ matches ) ) { $ color = str_replace ( [ '[' , ']' ] , '' , $ matches [ 0 ] ) ; $ color = strtolower ( $ color ) ; } $ value = htmlspecialchars ( $ pValue ) ; if ( $ color !== null ) { $ value = '<span style="color:' . $ color . '">' . $ value . '</span>' ; } return $ value ; }
6765	protected function handleUpdate ( SaleInterface $ sale ) { $ changed = false ; $ changed |= $ this -> updateNumber ( $ sale ) ; $ changed |= $ this -> updateKey ( $ sale ) ; $ changed |= $ this -> updateInformation ( $ sale , true ) ; if ( $ this -> persistenceHelper -> isChanged ( $ sale , 'vatNumber' ) ) { $ changed |= $ this -> pricingUpdater -> updateVatNumberSubject ( $ sale ) ; } if ( $ this -> persistenceHelper -> isChanged ( $ sale , 'customer' ) ) { $ changed |= $ this -> saleUpdater -> updatePaymentTerm ( $ sale ) ; } if ( $ this -> persistenceHelper -> isChanged ( $ sale , [ 'shipmentMethod' , 'customerGroup' ] ) ) { $ changed = $ this -> saleUpdater -> updateShipmentMethodAndAmount ( $ sale ) ; } if ( $ this -> isDiscountUpdateNeeded ( $ sale ) ) { $ changed |= $ this -> saleUpdater -> updateDiscounts ( $ sale , true ) ; } if ( $ this -> isTaxationUpdateNeeded ( $ sale ) ) { $ changed |= $ this -> saleUpdater -> updateTaxation ( $ sale , true ) ; } elseif ( $ this -> isShipmentTaxationUpdateNeeded ( $ sale ) ) { $ changed |= $ this -> saleUpdater -> updateShipmentTaxation ( $ sale , true ) ; } return $ changed ; }
2907	public function getPartDecodedContent ( Zend_Mime_Part $ mimePart ) { if ( method_exists ( $ mimePart , 'getRawContent' ) ) { return $ mimePart -> getRawContent ( ) ; } $ content = '' ; if ( method_exists ( $ mimePart , 'getContent' ) ) { $ encoding = $ mimePart -> encoding ; $ mimePart -> encoding = 'none' ; $ content = $ mimePart -> getContent ( ) ; $ mimePart -> encoding = $ encoding ; } return $ content ; }
11204	public function where ( $ key = false , $ desiredValue , $ op = "==" ) { $ collection = $ this -> getIterator ( ) ; $ subset = new Collection ( ) ; foreach ( $ collection as $ prop => $ result ) { $ realValue = $ result ; if ( is_object ( $ result ) ) { $ realValue = $ result -> $ key ; } else if ( is_array ( $ result ) ) { $ realValue = $ result [ $ key ] ; } $ add = false ; if ( $ op == '==' && $ realValue == $ desiredValue ) { $ add = true ; } else if ( $ op == '>=' && $ realValue >= $ desiredValue ) { $ add = true ; } else if ( $ op == '<=' && $ realValue <= $ desiredValue ) { $ add = true ; } else if ( $ op == '>' && $ realValue > $ desiredValue ) { $ add = true ; } else if ( $ op == '<' && $ realValue < $ desiredValue ) { $ add = true ; } else if ( $ op == '===' && $ realValue === $ desiredValue ) { $ add = true ; } else if ( $ op == '!=' && $ realValue != $ desiredValue ) { $ add = true ; } if ( $ add ) { $ subset -> add ( $ result , $ prop ) ; } } return $ subset ; }
5338	public function buildSoapClient ( $ service ) { $ director = new Soap \ SoapClientDirector ( $ this -> username , $ this -> mode , $ this -> endpoint ) ; switch ( $ service ) { case 'DomainService' : return $ director -> build ( new Soap \ Builder \ DomainSoapClientBuilder ) ; case 'ColocationService' : return $ director -> build ( new Soap \ Builder \ ColocationSoapClientBuilder ) ; case 'ForwardService' : return $ director -> build ( new Soap \ Builder \ ForwardSoapClientBuilder ) ; case 'VpsService' : return $ director -> build ( new Soap \ Builder \ VpsSoapClientBuilder ) ; case 'WebhostingService' : return $ director -> build ( new Soap \ Builder \ WebHostingSoapClientBuilder ) ; case 'HaipService' : return $ director -> build ( new Soap \ Builder \ HaipSoapClientBuilder ) ; default : throw new \ InvalidArgumentException ( sprintf ( 'Undefined soap client service builder called: [%s]' , $ service ) ) ; } }
7976	public function addSecondaryDnsDomains ( $ domain2add , $ ip ) { self :: getClient ( ) -> addSecondaryDnsDomains ( $ this -> getDomain ( ) , $ domain2add , $ ip ) ; return true ; }
1983	public static function hasMessages ( $ strScope = TL_MODE ) { return static :: hasError ( $ strScope ) || static :: hasConfirmation ( $ strScope ) || static :: hasNew ( $ strScope ) || static :: hasInfo ( $ strScope ) || static :: hasRaw ( $ strScope ) ; }
7098	private function findStockUnits ( StockSubjectInterface $ subject ) { $ repository = $ this -> entityManager -> getRepository ( $ subject :: getStockUnitClass ( ) ) ; $ stockUnits = array_merge ( $ repository -> findNotClosedBySubject ( $ subject ) , $ repository -> findLatestClosedBySubject ( $ subject ) ) ; usort ( $ stockUnits , function ( StockUnitInterface $ a , StockUnitInterface $ b ) { if ( $ a -> getState ( ) === StockUnitStates :: STATE_CLOSED && $ b -> getState ( ) !== StockUnitStates :: STATE_CLOSED ) { return 1 ; } if ( $ a -> getState ( ) !== StockUnitStates :: STATE_CLOSED && $ b -> getState ( ) === StockUnitStates :: STATE_CLOSED ) { return - 1 ; } if ( $ a -> getState ( ) === StockUnitStates :: STATE_CLOSED && $ b -> getState ( ) === StockUnitStates :: STATE_CLOSED ) { $ aDate = $ a -> getClosedAt ( ) -> getTimestamp ( ) ; $ bDate = $ b -> getClosedAt ( ) -> getTimestamp ( ) ; if ( $ aDate > $ bDate ) { return - 1 ; } if ( $ aDate < $ bDate ) { return 1 ; } } $ aDate = $ a -> getCreatedAt ( ) -> getTimestamp ( ) ; $ bDate = $ b -> getCreatedAt ( ) -> getTimestamp ( ) ; if ( $ aDate > $ bDate ) { return - 1 ; } if ( $ aDate < $ bDate ) { return 1 ; } return 0 ; } ) ; return $ stockUnits ; }
18	private function getPackageTime ( PackageInterface $ package ) { if ( ! function_exists ( 'proc_open' ) ) { return null ; } $ path = realpath ( $ this -> installationManager -> getInstallPath ( $ package ) ) ; $ sourceType = $ package -> getSourceType ( ) ; $ datetime = null ; if ( $ path && in_array ( $ sourceType , array ( 'git' , 'hg' ) ) ) { $ sourceRef = $ package -> getSourceReference ( ) ? : $ package -> getDistReference ( ) ; switch ( $ sourceType ) { case 'git' : GitUtil :: cleanEnv ( ) ; if ( 0 === $ this -> process -> execute ( 'git log -n1 --pretty=%ct ' . ProcessExecutor :: escape ( $ sourceRef ) , $ output , $ path ) && preg_match ( '{^\s*\d+\s*$}' , $ output ) ) { $ datetime = new \ DateTime ( '@' . trim ( $ output ) , new \ DateTimeZone ( 'UTC' ) ) ; } break ; case 'hg' : if ( 0 === $ this -> process -> execute ( 'hg log --template "{date|hgdate}" -r ' . ProcessExecutor :: escape ( $ sourceRef ) , $ output , $ path ) && preg_match ( '{^\s*(\d+)\s*}' , $ output , $ match ) ) { $ datetime = new \ DateTime ( '@' . $ match [ 1 ] , new \ DateTimeZone ( 'UTC' ) ) ; } break ; } } return $ datetime ? $ datetime -> format ( DATE_RFC3339 ) : null ; }
1455	protected function validateHasOne ( RelationshipInterface $ relationship , $ record = null , $ key = null , ResourceObjectInterface $ resource = null ) { if ( ! $ relationship -> isHasOne ( ) ) { $ this -> addError ( $ this -> errorFactory -> relationshipHasOneExpected ( $ key ) ) ; return false ; } $ identifier = $ relationship -> getData ( ) ; if ( ! $ identifier ) { return true ; } if ( ! $ this -> validateIdentifier ( $ identifier , $ key ) ) { return false ; } if ( ! $ this -> validateExists ( $ identifier , $ key ) ) { return false ; } if ( ! $ this -> validateAcceptable ( $ identifier , $ record , $ key , $ resource ) ) { return false ; } return true ; }
503	public function batchInsert ( $ table , $ columns , $ rows , & $ params = [ ] ) { if ( empty ( $ rows ) ) { return '' ; } $ this -> db -> open ( ) ; if ( version_compare ( $ this -> db -> getServerVersion ( ) , '3.7.11' , '>=' ) ) { return parent :: batchInsert ( $ table , $ columns , $ rows , $ params ) ; } $ schema = $ this -> db -> getSchema ( ) ; if ( ( $ tableSchema = $ schema -> getTableSchema ( $ table ) ) !== null ) { $ columnSchemas = $ tableSchema -> columns ; } else { $ columnSchemas = [ ] ; } $ values = [ ] ; foreach ( $ rows as $ row ) { $ vs = [ ] ; foreach ( $ row as $ i => $ value ) { if ( isset ( $ columnSchemas [ $ columns [ $ i ] ] ) ) { $ value = $ columnSchemas [ $ columns [ $ i ] ] -> dbTypecast ( $ value ) ; } if ( is_string ( $ value ) ) { $ value = $ schema -> quoteValue ( $ value ) ; } elseif ( is_float ( $ value ) ) { $ value = StringHelper :: floatToString ( $ value ) ; } elseif ( $ value === false ) { $ value = 0 ; } elseif ( $ value === null ) { $ value = 'NULL' ; } elseif ( $ value instanceof ExpressionInterface ) { $ value = $ this -> buildExpression ( $ value , $ params ) ; } $ vs [ ] = $ value ; } $ values [ ] = implode ( ', ' , $ vs ) ; } if ( empty ( $ values ) ) { return '' ; } foreach ( $ columns as $ i => $ name ) { $ columns [ $ i ] = $ schema -> quoteColumnName ( $ name ) ; } return 'INSERT INTO ' . $ schema -> quoteTableName ( $ table ) . ' (' . implode ( ', ' , $ columns ) . ') SELECT ' . implode ( ' UNION SELECT ' , $ values ) ; }
935	public static function isKeyCaseSensitive ( $ caseSensitive , $ key ) { if ( \ is_array ( $ caseSensitive ) ) { return isset ( $ caseSensitive [ $ key ] ) ? $ caseSensitive [ $ key ] : true ; } return $ caseSensitive ; }
98	public function add ( $ prefix , $ paths , $ prepend = false ) { if ( ! $ prefix ) { if ( $ prepend ) { $ this -> fallbackDirsPsr0 = array_merge ( ( array ) $ paths , $ this -> fallbackDirsPsr0 ) ; } else { $ this -> fallbackDirsPsr0 = array_merge ( $ this -> fallbackDirsPsr0 , ( array ) $ paths ) ; } return ; } $ first = $ prefix [ 0 ] ; if ( ! isset ( $ this -> prefixesPsr0 [ $ first ] [ $ prefix ] ) ) { $ this -> prefixesPsr0 [ $ first ] [ $ prefix ] = ( array ) $ paths ; return ; } if ( $ prepend ) { $ this -> prefixesPsr0 [ $ first ] [ $ prefix ] = array_merge ( ( array ) $ paths , $ this -> prefixesPsr0 [ $ first ] [ $ prefix ] ) ; } else { $ this -> prefixesPsr0 [ $ first ] [ $ prefix ] = array_merge ( $ this -> prefixesPsr0 [ $ first ] [ $ prefix ] , ( array ) $ paths ) ; } }
4683	public static function stop ( $ key = 'default' ) : void { if ( isset ( self :: $ timers [ $ key ] ) ) { self :: $ timers [ $ key ] -> stop ( ) ; } else { throw new \ LogicException ( 'Stopping timer when the given key timer was not initialized.' ) ; } }
1618	public function scalar ( $ attribute , $ db = null ) { if ( $ this -> emulateExecution ) { return null ; } $ record = $ this -> one ( $ db ) ; if ( $ record !== null ) { return $ record -> hasAttribute ( $ attribute ) ? $ record -> $ attribute : null ; } else { return null ; } }
154	public function populate ( $ rows ) { if ( $ this -> indexBy === null ) { return $ rows ; } $ result = [ ] ; foreach ( $ rows as $ row ) { $ result [ ArrayHelper :: getValue ( $ row , $ this -> indexBy ) ] = $ row ; } return $ result ; }
9114	public function init ( ) { $ this -> registerController ( \ Nkey \ Caribu \ Mvc \ Controller \ ErrorController :: class ) ; $ this -> registerView ( \ Nkey \ Caribu \ Mvc \ View \ DefaultView :: class ) ; }
11402	public function getAppCode ( $ path , $ width = 430 , $ autoColor = false , $ lineColor = [ 'r' => 0 , 'g' => 0 , 'b' => 0 ] ) { $ params = [ 'path' => $ path , 'width' => $ width , 'auto_color' => $ autoColor , 'line_color' => $ lineColor , ] ; return $ this -> getStream ( self :: API_GET_WXACODE , $ params ) ; }
7062	protected function updateCustomerBalance ( PaymentInterface $ payment , $ amount = null ) { if ( null === $ customer = $ payment -> getSale ( ) -> getCustomer ( ) ) { return false ; } $ amount = $ amount ? : $ payment -> getAmount ( ) ; if ( $ this -> isAcceptedPayment ( $ payment ) ) { $ amount = - $ amount ; } if ( $ payment -> getMethod ( ) -> isCredit ( ) ) { return $ this -> updateCreditBalance ( $ customer , $ amount , true ) ; } elseif ( $ payment -> getMethod ( ) -> isOutstanding ( ) ) { return $ this -> updateOutstandingBalance ( $ customer , $ amount , true ) ; } return false ; }
6065	public function listSocialMediaFiles ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/media/' . $ id . '/socialmedia/files' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new DeploymentFile ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
9319	public function markdown ( $ contents ) { $ contents = app ( 'markdown' ) -> convertToHtml ( $ contents ) ; if ( ! is_null ( $ this -> cachePath ) ) { $ this -> files -> put ( $ this -> getCompiledPath ( $ this -> getPath ( ) ) , $ contents ) ; } return $ contents ; }
1255	private function getValueToAssignToValue ( \ stdClass $ meta ) { if ( is_subclass_of ( $ meta -> phpObject , '\DTS\eBaySDK\Types\Base64BinaryType' , false ) ) { return $ meta -> strData ; } elseif ( is_subclass_of ( $ meta -> phpObject , '\DTS\eBaySDK\Types\BooleanType' , false ) ) { return strtolower ( $ meta -> strData ) === 'true' ; } elseif ( is_subclass_of ( $ meta -> phpObject , '\DTS\eBaySDK\Types\DecimalType' , false ) ) { return is_int ( 0 + $ meta -> strData ) ? ( integer ) $ meta -> strData : ( double ) $ meta -> strData ; } elseif ( is_subclass_of ( $ meta -> phpObject , '\DTS\eBaySDK\Types\DoubleType' , false ) ) { return ( double ) $ meta -> strData ; } elseif ( is_subclass_of ( $ meta -> phpObject , '\DTS\eBaySDK\Types\IntegerType' , false ) ) { return ( integer ) $ meta -> strData ; } elseif ( is_subclass_of ( $ meta -> phpObject , '\DTS\eBaySDK\Types\StringType' , false ) ) { return $ meta -> strData ; } elseif ( is_subclass_of ( $ meta -> phpObject , '\DTS\eBaySDK\Types\TokenType' , false ) ) { return $ meta -> strData ; } elseif ( is_subclass_of ( $ meta -> phpObject , '\DTS\eBaySDK\Types\URIType' , false ) ) { return $ meta -> strData ; } return $ meta -> strData ; }
12893	public function create ( $ account , $ openId ) { $ params = [ 'kf_account' => $ account , 'openid' => $ openId , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_CREATE , $ params ] ) ; }
9174	private function hierarchyToFlatArray ( $ items ) { $ flatArray = [ ] ; foreach ( $ items as $ item ) { $ flatArray [ ] = $ item -> getId ( ) ; if ( $ items -> getChildren ( ) -> count ( ) > 0 ) { $ flatArray = array_merge ( $ flatArray , $ this -> hierarchyToFlatArray ( $ items -> getChildren ( ) ) ) ; } } return $ flatArray ; }
3597	protected function createIndexes ( ) { $ this -> createIndex ( $ this -> db -> getIndexName ( '{{%dolphiq_sitemap_entries}}' , [ 'type' , 'linkId' ] , true ) , '{{%dolphiq_sitemap_entries}}' , [ 'type' , 'linkId' ] , true ) ; switch ( $ this -> driver ) { case DbConfig :: DRIVER_MYSQL : break ; case DbConfig :: DRIVER_PGSQL : break ; } }
4748	public function getPlan ( string $ planCode ) : array { $ cacheKey = sprintf ( 'plan_%s' , $ planCode ) ; $ hit = $ this -> getFromCache ( $ cacheKey ) ; if ( false === $ hit ) { $ response = $ this -> sendRequest ( 'GET' , sprintf ( 'plans/%s' , $ planCode ) ) ; $ data = $ this -> processResponse ( $ response ) ; $ plan = $ data [ 'plan' ] ; $ this -> saveToCache ( $ cacheKey , $ plan ) ; return $ plan ; } return $ hit ; }
7886	public function levels ( ) { if ( ! $ this -> levels ) { $ class = new ReflectionClass ( new LogLevel ( ) ) ; $ this -> levels = $ class -> getConstants ( ) ; } return $ this -> levels ; }
2933	public function deleteKeys ( $ keys = [ ] ) { foreach ( $ keys as $ key ) { $ this -> writer -> deleteSetter ( $ key ) ; } return $ this ; }
3798	private function checkModelWithVariants ( $ containedModel ) { $ isVarbase = ( bool ) $ containedModel -> getProperty ( 'varbase' ) ; $ vargroup = $ containedModel -> getProperty ( 'vargroup' ) ; $ isCurrentVarbase = ( bool ) $ this -> currentModel -> getProperty ( 'varbase' ) ; $ currentVargroup = $ this -> currentModel -> getProperty ( 'vargroup' ) ; if ( $ isVarbase && ! $ this -> circularReference && $ isCurrentVarbase ) { $ this -> disablePA = false ; } elseif ( ! $ isVarbase && ! $ isCurrentVarbase && $ vargroup == $ currentVargroup ) { $ this -> disablePA = false ; } $ this -> disablePI = ! $ isCurrentVarbase || $ isVarbase ; }
4252	public function onOutput ( Event $ event ) { $ this -> channelName = $ this -> debug -> getCfg ( 'channel' ) ; $ this -> data = $ this -> debug -> getData ( ) ; $ errorStats = $ this -> debug -> internal -> errorStats ( ) ; $ errorStr = '' ; if ( $ errorStats [ 'inConsole' ] ) { $ errorStr = 'Errors: ' ; foreach ( $ errorStats [ 'counts' ] as $ category => $ vals ) { $ errorStr .= $ vals [ 'inConsole' ] . ' ' . $ category . ', ' ; } $ errorStr = \ substr ( $ errorStr , 0 , - 2 ) ; } $ str = '' ; $ str .= '<script type="text/javascript">' . "\n" ; $ str .= $ this -> processLogEntryWEvent ( 'groupCollapsed' , array ( 'PHP' , ( isset ( $ _SERVER [ 'REQUEST_METHOD' ] ) && isset ( $ _SERVER [ 'REQUEST_URI' ] ) ? $ _SERVER [ 'REQUEST_METHOD' ] . ' ' . $ _SERVER [ 'REQUEST_URI' ] : '' ) , $ errorStr , ) ) ; $ str .= $ this -> processAlerts ( ) ; $ str .= $ this -> processSummary ( ) ; $ str .= $ this -> processLog ( ) ; $ str .= $ this -> processLogEntryWEvent ( 'groupEnd' ) ; $ str .= '</script>' . "\n" ; $ this -> data = array ( ) ; $ event [ 'return' ] .= $ str ; }
1185	public function resolver ( $ field ) { return function ( $ translator , $ data , $ rules , $ messages , $ customAttributes ) use ( $ field ) { return $ this -> resolve ( $ translator , $ data , $ rules , $ messages , $ customAttributes , $ field ) ; } ; }
7314	public function setTime ( $ hour , $ min , $ sec ) { $ status = IAU :: Tf2d ( '+' , ( int ) $ hour , ( int ) $ min , ( float ) $ sec , $ days ) ; $ this -> checkTime ( $ status ) ; $ this -> dayFrac = $ days ; return $ this ; }
5557	protected function tagUrlsWithFrame ( $ urls , $ frame ) { $ tagged = array ( ) ; foreach ( $ urls as $ url ) { if ( ! $ url -> getTarget ( ) ) { $ url -> setTarget ( $ this -> getPublicNameFromIndex ( $ frame ) ) ; } $ tagged [ ] = $ url ; } return $ tagged ; }
2389	private function applyFallback ( array & $ config , array $ action , bool $ skipLegends = false ) : void { if ( \ is_callable ( $ action [ 'fallback' ] ) ) { $ action [ 'fallback' ] ( $ config , $ action , $ skipLegends ) ; } else { $ this -> applyFallbackPalette ( $ config , $ action ) ; } }
3536	public function updateAccountStatus ( ) { if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: beginProfile ( 'LDAP updateAccountStatus function' , static :: YII2_PROFILE_NAME . 'updateAccountStatus' ) ; } $ ldapUser = $ this -> queryLdapUserObject ( ) ; if ( $ ldapUser == null ) { $ this -> status = static :: STATUS_DISABLED ; } else { $ ldapAccountState = $ ldapUser -> getUserAccountControl ( ) ; $ disabledUser = ( $ ldapAccountState & AccountControl :: ACCOUNTDISABLE ) === AccountControl :: ACCOUNTDISABLE ; $ lockedUser = ( $ ldapAccountState & AccountControl :: LOCKOUT ) === AccountControl :: LOCKOUT ; $ pwExpired = ( $ ldapAccountState & AccountControl :: PASSWORD_EXPIRED ) === AccountControl :: PASSWORD_EXPIRED ; if ( $ disabledUser == true || $ lockedUser == true || $ pwExpired == true ) { $ this -> status = static :: STATUS_DISABLED ; } else { $ this -> status = static :: STATUS_ENABLED ; } } $ this -> save ( ) ; if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: endProfile ( 'LDAP updateAccountStatus function' , static :: YII2_PROFILE_NAME . 'updateAccountStatus' ) ; } return $ this -> status ; }
8055	public static function get ( $ length = 8 , $ outputFormat = Code :: FORMAT_ALNUM ) { static :: throwUnlessAcceptable ( $ outputFormat , $ length ) ; $ number = rand ( 100 , 900 ) . str_replace ( '.' , '' , microtime ( true ) ) ; $ output = self :: convertBase ( $ number , self :: FORMAT_NUMBER , $ outputFormat ) ; if ( strlen ( $ output ) < $ length ) { $ output .= substr ( str_shuffle ( $ outputFormat . $ outputFormat ) , 0 , ( $ length - strlen ( $ output ) ) ) ; } if ( strlen ( $ output ) > $ length ) { $ output = substr ( $ output , 0 , $ length ) ; } return $ output ; }
2265	public function fieldExists ( $ strField , $ strTable , $ blnNoCache = false ) { if ( $ strField == '' || $ strTable == '' ) { return false ; } foreach ( $ this -> listFields ( $ strTable , $ blnNoCache ) as $ arrField ) { if ( $ arrField [ 'name' ] == $ strField && $ arrField [ 'type' ] != 'index' ) { return true ; } } return false ; }
11453	protected function getPublicIdAttribute ( ) { if ( $ id = Api :: decodeHashId ( $ this -> attributes [ 'id' ] ) ) { return $ id ; } return Api :: encodeHashId ( $ this -> attributes [ 'id' ] ) ; }
5119	private function assessOptions ( array $ options ) : void { $ defaultOptions = [ 'rest_server' => self :: REST_SERVER , 'auth_url' => self :: AUTHENTICATION , 'max_attempt' => self :: DEFAULT_MAX_ATTEMPT , 'default_headers' => [ 'Accept' => 'application/json' , ] , ] ; $ this -> options = new Collection ( array_merge ( $ defaultOptions , $ options ) ) ; if ( isset ( $ options [ 'access_token' ] ) ) { $ this -> setAuthorizationHeader ( $ options [ 'access_token' ] ) ; } if ( isset ( $ options [ 'recycle_token' ] ) && is_callable ( $ options [ 'recycle_token' ] ) ) { $ this -> recycleToken ( $ options [ 'recycle_token' ] ) ; } if ( isset ( $ options [ 'token_saver' ] ) && is_callable ( $ options [ 'token_saver' ] ) ) { $ this -> setTokenSaver ( $ options [ 'token_saver' ] ) ; } $ this -> httpClient = new Client ( [ 'base_uri' => $ this -> options -> get ( 'rest_server' ) , ] ) ; }
7834	protected function getPipesByOption ( $ option ) { $ pipes = $ this -> option ( $ option ) ; preg_match_all ( '/\w+/' , $ pipes , $ matches ) ; return array_map ( 'ucfirst' , $ matches [ 0 ] ) ; }
9313	public function infoAction ( ) { if ( ! $ this -> isConsoleRequest ( ) ) { throw new \ RuntimeException ( 'You can only use this action from a console!' ) ; } $ console = $ this -> getConsole ( ) ; $ this -> printConsoleBanner ( $ console ) ; $ mapper = $ this -> getJobMapper ( ) ; try { $ pendingJobs = $ mapper -> getPending ( ) -> count ( ) ; $ runningJobs = $ mapper -> getRunning ( ) -> count ( ) ; $ finishedJobs = $ mapper -> getHistory ( ) -> count ( ) ; $ console -> writeLine ( sprintf ( 'Pending jobs: %s' , $ pendingJobs ) ) ; $ console -> writeLine ( sprintf ( 'Running jobs: %s' , $ runningJobs ) ) ; $ console -> writeLine ( sprintf ( 'Finished jobs: %s' , $ finishedJobs ) ) ; } catch ( \ PDOException $ exception ) { $ console -> writeLine ( 'Something is bad with your database - either database ' . 'adapter is not properly configured or database table is ' . 'not created.' , ConsoleColor :: LIGHT_RED ) ; } }
10063	public function get ( $ key , $ default = null ) { $ meta = $ this -> metaModel :: where ( 'key' , $ key ) -> first ( ) ; return $ meta === null ? $ default : $ meta -> value ; }
12274	public static function createFromFormat ( $ format , $ time , $ object = null ) { if ( empty ( $ object ) ) { $ object = new DateTimeZone ( 'America/Sao_Paulo' ) ; } return self :: cast ( parent :: createFromFormat ( $ format , $ time , $ object ) ) ; }
9718	private function writePalette ( ) { $ aref = $ this -> palette ; $ record = 0x0092 ; $ length = 2 + 4 * count ( $ aref ) ; $ ccv = count ( $ aref ) ; $ data = '' ; foreach ( $ aref as $ color ) { foreach ( $ color as $ byte ) { $ data .= pack ( 'C' , $ byte ) ; } } $ header = pack ( 'vvv' , $ record , $ length , $ ccv ) ; $ this -> append ( $ header . $ data ) ; }
876	private function isCommentWithFixableIndentation ( Tokens $ tokens , $ index ) { if ( ! $ tokens [ $ index ] -> isComment ( ) ) { return false ; } if ( 0 === strpos ( $ tokens [ $ index ] -> getContent ( ) , '/*' ) ) { return true ; } $ firstCommentIndex = $ index ; while ( true ) { $ i = $ this -> getSiblingContinuousSingleLineComment ( $ tokens , $ firstCommentIndex , false ) ; if ( null === $ i ) { break ; } $ firstCommentIndex = $ i ; } $ lastCommentIndex = $ index ; while ( true ) { $ i = $ this -> getSiblingContinuousSingleLineComment ( $ tokens , $ lastCommentIndex , true ) ; if ( null === $ i ) { break ; } $ lastCommentIndex = $ i ; } if ( $ firstCommentIndex === $ lastCommentIndex ) { return true ; } for ( $ i = $ firstCommentIndex + 1 ; $ i < $ lastCommentIndex ; ++ $ i ) { if ( ! $ tokens [ $ i ] -> isWhitespace ( ) && ! $ tokens [ $ i ] -> isComment ( ) ) { return false ; } } return true ; }
10545	public function setVirtualHost ( VirtualHost $ vhost ) { $ this -> vhost = $ vhost ; $ this -> setVariable ( 'vhost' , $ vhost ) ; return $ this ; }
1745	public function showFile ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { if ( Contao \ Input :: get ( 'popup' ) ) { return '' ; } else { return '<a href="contao/popup.php?src=' . base64_encode ( $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . ' onclick="Backend.openModalIframe({\'title\':\'' . str_replace ( "'" , "\\'" , Contao \ StringUtil :: specialchars ( $ row [ 'fileNameEncoded' ] ) ) . '\',\'url\':this.href});return false">' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' ; } }
10244	public function getImplementedFunctionNames ( ) { $ returnValue = [ ] ; foreach ( self :: $ phpSpreadsheetFunctions as $ functionName => $ function ) { if ( $ this -> isImplemented ( $ functionName ) ) { $ returnValue [ ] = $ functionName ; } } return $ returnValue ; }
10481	public function getDocuments ( ) { return new SyncStorageImportIterator ( [ 'sync_storage' => $ this -> getSyncStorage ( ) , 'shop_id' => $ this -> getShopId ( ) , 'document_type' => $ this -> getDocumentType ( ) , ] , $ this -> getElasticsearchManager ( ) -> getRepository ( $ this -> getDocumentClass ( ) ) , $ this -> getDoctrineManager ( ) , $ this -> getEntityClass ( ) ) ; }
6873	protected function buildItem ( SaleItemInterface $ saleItem , ShipmentInterface $ shipment ) { if ( $ saleItem -> isCompound ( ) ) { $ available = $ expected = null ; foreach ( $ saleItem -> getChildren ( ) as $ childSaleItem ) { if ( null !== $ child = $ this -> buildItem ( $ childSaleItem , $ shipment ) ) { $ saleItemQty = $ childSaleItem -> getQuantity ( ) ; $ e = $ child -> getExpected ( ) / $ saleItemQty ; if ( null === $ expected || $ expected > $ e ) { $ expected = $ e ; } $ a = $ child -> getAvailable ( ) / $ saleItemQty ; if ( null === $ available || $ available > $ a ) { $ available = $ a ; } } } if ( 0 < $ expected ) { return $ this -> findOrCreateItem ( $ shipment , $ saleItem , $ expected , $ available ) ; } return null ; } $ item = null ; if ( ! ( $ saleItem -> isCompound ( ) && ! $ saleItem -> hasPrivateChildren ( ) ) ) { $ expected = $ shipment -> isReturn ( ) ? $ this -> calculator -> calculateReturnableQuantity ( $ saleItem , $ shipment ) : $ this -> calculator -> calculateShippableQuantity ( $ saleItem , $ shipment ) ; if ( 0 < $ expected ) { $ item = $ this -> findOrCreateItem ( $ shipment , $ saleItem , $ expected ) ; } } if ( $ saleItem -> hasChildren ( ) ) { foreach ( $ saleItem -> getChildren ( ) as $ childSaleItem ) { $ this -> buildItem ( $ childSaleItem , $ shipment ) ; } } return $ item ; }
2146	protected function generateEmailObject ( Result $ objNewsletter , $ arrAttachments ) { $ objEmail = new Email ( ) ; $ objEmail -> from = $ objNewsletter -> sender ; $ objEmail -> subject = $ objNewsletter -> subject ; if ( $ objNewsletter -> senderName != '' ) { $ objEmail -> fromName = $ objNewsletter -> senderName ; } $ objEmail -> embedImages = ! $ objNewsletter -> externalImages ; $ objEmail -> logFile = TL_NEWSLETTER . '_' . $ objNewsletter -> id ; if ( ! empty ( $ arrAttachments ) && \ is_array ( $ arrAttachments ) ) { $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; foreach ( $ arrAttachments as $ strAttachment ) { $ objEmail -> attachFile ( $ rootDir . '/' . $ strAttachment ) ; } } return $ objEmail ; }
4114	public function getRemoteCallEnabled ( ) { if ( is_null ( $ this -> remoteCallEnabled ) ) { $ this -> remoteCallEnabled = Mage :: getStoreConfigFlag ( 'dev/aoe_templatehints/enablePhpstormRemoteCall' ) ; } return $ this -> remoteCallEnabled ; }
7642	public function getBaseUrl ( ) { if ( $ this -> credentials -> usePathStyleUri ( ) ) { return $ this -> host . '/' . $ this -> accountName ; } return $ this -> host ; }
5226	private function isTypeMismatch ( $ type , $ value ) { if ( ! ( $ type instanceof \ ReflectionClass ) ) { return false ; } if ( ! is_object ( $ value ) ) { return true ; } return ! $ type -> isInstance ( $ value ) ; }
1598	protected function validateAllFields ( ) : bool { $ duplicates = collect ( ( array ) $ this -> dataGet ( 'attributes' , [ ] ) ) -> intersectByKeys ( ( array ) $ this -> dataGet ( 'relationships' , [ ] ) ) -> keys ( ) ; $ this -> resourceFieldsExistInAttributesAndRelationships ( $ duplicates ) ; return $ duplicates -> isEmpty ( ) ; }
3537	public function getGroupsAssignedInLdap ( ) { if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: beginProfile ( 'getGroupsAssignedInLdap' , static :: YII2_PROFILE_NAME . 'getGroupsAssignedInLdap' ) ; } $ ldapUser = $ this -> queryLdapUserObject ( ) ; $ ldapGroupsConverted = [ ] ; if ( $ ldapUser != null ) { if ( static :: getGroupAssigmentOptions ( 'SEARCH_NESTED_GROUPS' , $ this -> individualGroupAssignmentOptions ) == true ) { $ ldapGroups = static :: getAdldapProvider ( ) -> search ( ) -> rawFilter ( '(member:1.2.840.113556.1.4.1941:=' . $ ldapUser -> getDn ( ) . ')' ) -> select ( 'cn' ) -> raw ( ) -> get ( ) ; if ( $ ldapGroups == null ) { $ ldapGroups = [ ] ; } foreach ( $ ldapGroups as $ groupDn ) { if ( is_array ( $ groupDn ) && array_key_exists ( 'cn' , $ groupDn ) ) { array_push ( $ ldapGroupsConverted , $ groupDn [ 'cn' ] [ 0 ] ) ; } } } else { $ ldapGroups = $ ldapUser -> getAttribute ( 'memberof' ) ; if ( $ ldapGroups == null ) { $ ldapGroups = [ ] ; } foreach ( $ ldapGroups as $ groupDn ) { $ n = Utilities :: explodeDn ( $ groupDn ) [ 0 ] ; array_push ( $ ldapGroupsConverted , $ n ) ; } } } if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: endProfile ( 'getGroupsAssignedInLdap' , static :: YII2_PROFILE_NAME . 'getGroupsAssignedInLdap' ) ; } return $ ldapGroupsConverted ; }
473	public function batchInsert ( $ table , $ columns , $ rows ) { $ time = $ this -> beginCommand ( "insert into $table" ) ; $ this -> db -> createCommand ( ) -> batchInsert ( $ table , $ columns , $ rows ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
9127	private function checkConnection ( $ start ) : bool { if ( ! $ this -> ready ( ) ) { if ( time ( ) - $ start > $ this -> timeout ) { $ this -> disconnect ( ) ; throw new HttpException ( "Connection timed out!" ) ; } return false ; } return true ; }
5683	public function getUrls ( ) { $ all = array ( ) ; foreach ( $ this -> links as $ link ) { $ url = $ this -> getUrlFromLink ( $ link ) ; $ all [ ] = $ url -> asString ( ) ; } return $ all ; }
3805	public function generate ( ) { $ GLOBALS [ 'TL_CSS' ] [ ] = 'bundles/metamodelscore/css/style.css' ; $ arrModule = $ GLOBALS [ 'BE_MOD' ] [ 'metamodels' ] [ 'metamodels' ] ; if ( \ Input :: get ( 'key' ) && isset ( $ arrModule [ \ Input :: get ( 'key' ) ] ) ) { Callbacks :: call ( $ arrModule [ \ Input :: get ( 'key' ) ] , $ this , $ arrModule ) ; } $ act = \ Input :: get ( 'act' ) ; if ( ! strlen ( $ act ) ) { $ act = 'showAll' ; } return $ this -> dataContainer -> getEnvironment ( ) -> getController ( ) -> handle ( new Action ( $ act ) ) ; }
2762	public function log ( GitEvent $ gitEvent , string $ message , array $ context = [ ] , ? string $ eventName = null ) : void { if ( $ eventName === null && method_exists ( $ gitEvent , 'getName' ) ) { $ eventName = $ gitEvent -> getName ( ) ; } $ method = $ this -> getLogLevelMapping ( $ eventName ) ; $ context += [ 'command' => $ gitEvent -> getProcess ( ) -> getCommandLine ( ) ] ; $ this -> logger -> { $ method } ( $ message , $ context ) ; }
1570	public function getResource ( ) { $ resource = $ this -> parameter ( ResourceRegistrar :: PARAM_RESOURCE_ID ) ; return is_object ( $ resource ) ? $ resource : null ; }
8757	public function run ( \ Traversable $ items , callable $ itemCallback ) { $ this -> start ( ) ; foreach ( $ items as $ item ) { call_user_func ( $ itemCallback , $ this , $ item ) ; } return $ this -> finish ( ) ; }
3558	public function setValue ( $ value ) { $ this -> setType ( $ value ) ; if ( $ this -> hasMutator ( $ value , 'setter' ) ) { $ value = $ this -> mutateValue ( $ value , 'setter' ) ; } elseif ( ! $ this -> isStringable ( $ value ) && ! is_null ( $ value ) ) { throw new InvalidTypeException ( "Unsupported meta value type [{$this->getValueType($value)}]." ) ; } $ this -> attributes [ 'meta_value' ] = $ value ; }
9357	public function withoutHeader ( $ name ) { $ instance = clone $ this ; if ( $ this -> hasHeader ( $ name ) ) { $ static = clone $ this ; unset ( $ static -> headers [ $ name ] ) ; $ instance = $ static ; } return $ instance ; }
2649	public function setVclAsMain ( $ version , $ name ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/vcl/' . $ name . '/main' ; $ result = $ this -> _fetch ( $ url , 'PUT' ) ; return $ result ; }
8708	public function select ( $ columns = [ '*' ] ) { parent :: select ( $ columns ) ; $ this -> columns = $ this -> qualifyColumns ( $ this -> columns ) ; return $ this ; }
10994	public function getSize ( int $ precision = 0 , string $ point = "." , string $ sep = "," ) : string { $ bytes = $ this -> getByteSize ( ) ; if ( $ bytes === - 1 ) { return "" ; } return \ sndsgd \ Fs :: formatSize ( $ bytes , $ precision , $ point , $ sep ) ; }
2836	public function getLayoutUpdates ( ) { if ( $ this -> uncompressedLayoutUpdates === null ) { $ this -> uncompressedLayoutUpdates = $ this -> layoutUpdates ? json_decode ( gzuncompress ( $ this -> layoutUpdates ) , true ) : array ( ) ; } return $ this -> uncompressedLayoutUpdates ; }
995	private function getDeprecationReason ( $ node ) { $ deprecated = Values :: getDirectiveValues ( Directive :: deprecatedDirective ( ) , $ node ) ; return $ deprecated [ 'reason' ] ?? null ; }
971	public function getToken ( bool $ strict = false ) { $ tokens = [ self :: GRANT_PERUSER => Session :: get ( self :: TOKEN ) , self :: GRANT_OFFLINE => $ this -> shop -> { self :: TOKEN } , ] ; if ( $ strict ) { return $ tokens [ $ this -> getType ( ) ] ; } return $ tokens [ self :: GRANT_PERUSER ] ?? $ tokens [ self :: GRANT_OFFLINE ] ; }
5198	public function save ( ) { try { $ connection = new Connection ( $ this -> buildConnectionOptions ( ) ) ; $ connection -> open ( ) ; $ msg = new AMQPMessage ( $ this -> message , array ( 'content_type' => $ this -> content_type , 'delivery_mode' => 2 ) ) ; $ connection -> channel -> basic_publish ( $ msg , $ this -> exchange , $ this -> queue_name ) ; $ connection -> close ( ) ; } catch ( Exception $ e ) { $ connection -> close ( ) ; throw new Exception ( $ e ) ; } }
10703	public function loadLanguage ( $ controller , $ language = 'en_US' , $ return = FALSE ) { $ langDirEvent = new GetLanguageDirEvent ( ) ; $ this -> dispatcher -> fire ( Events :: EVENT_GET_LANG_DIR , $ langDirEvent ) ; $ langDir = $ langDirEvent -> getLangDir ( ) ; $ retVal = FALSE ; if ( NULL === $ langDir ) { $ retVal = FALSE ; } else { $ file = $ langDir . $ controller . DS . $ language . '_lang.php' ; if ( ! file_exists ( $ file ) ) { $ defaultLangEvent = new GetDefaultLanguageEvent ( ) ; $ this -> dispatcher -> fire ( Events :: EVENT_GET_DEFAULT_LANG , $ defaultLangEvent ) ; $ defaultLang = $ defaultLangEvent -> getDefaultLanguage ( ) ; if ( NULL === $ defaultLang ) { $ retval = FALSE ; } else { $ file = $ langDir . $ controller . DS . $ defaultLang . '_lang.php' ; } } if ( NULL === $ file ) { throw new RawException ( 'Failed to load language file for ' . $ controller ) ; } $ lang = include_once $ file ; $ this -> language = array_merge ( $ this -> language , $ lang ) ; $ retVal = $ lang ; } return $ retVal ; }
7498	public function createAndSendMessageFromTemplate ( ) { $ args = func_get_args ( ) ; if ( empty ( $ args [ 0 ] ) ) { throw new \ RuntimeException ( 'First parameter must be a template filename or EmailTemplate entity' ) ; } elseif ( $ args [ 0 ] instanceof EmailTemplate ) { $ method = 'createMessageFromTemplateEntity' ; } else { $ method = 'createMessageFromTemplateFile' ; } $ message = call_user_func_array ( array ( $ this , $ method ) , $ args ) ; $ this -> mailer -> send ( $ message ) ; return true ; }
7099	private function ceilComparison ( UnitCandidate $ a , UnitCandidate $ b , $ property , $ quantity ) { if ( $ a -> { $ property } >= $ quantity && $ b -> { $ property } < $ quantity ) { return - 1 ; } if ( $ a -> { $ property } < $ quantity && $ b -> { $ property } >= $ quantity ) { return 1 ; } return false ; }
6842	public function produce ( $ key , $ params = array ( ) , $ enable_reflect = true ) { if ( isset ( $ this -> data [ $ key ] ) ) return $ this -> data [ $ key ] ; if ( isset ( $ this -> caches [ $ key ] ) ) return $ this -> caches [ $ key ] ; if ( isset ( $ this -> objects [ $ key ] ) ) { $ obj = $ this -> get ( $ key ) ; $ concrete = $ obj [ self :: INDEX_CONCRETE ] ; } else { if ( $ this -> MUST_REG || ! $ enable_reflect ) { throw new InjectorException ( "$key not registered" ) ; } else { $ concrete = $ key ; $ not_reg = true ; } } $ result = $ this -> build ( $ concrete , $ params ) ; if ( $ not_reg === true || $ obj [ self :: INDEX_CACHED ] === true ) { $ this -> caches [ $ key ] = $ result ; } return $ result ; }
877	private function skipClass ( Tokens $ tokens , $ classIndex , $ classOpenIndex , $ classCloseIndex ) { $ prevToken = $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ classIndex ) ] ; if ( ! $ prevToken -> isGivenKind ( T_FINAL ) ) { return true ; } for ( $ index = $ classIndex ; $ index < $ classOpenIndex ; ++ $ index ) { if ( $ tokens [ $ index ] -> isGivenKind ( T_EXTENDS ) ) { return true ; } } $ useIndex = $ tokens -> getNextTokenOfKind ( $ classIndex , [ [ CT :: T_USE_TRAIT ] ] ) ; return $ useIndex && $ useIndex < $ classCloseIndex ; }
12439	public function render ( $ template , $ data ) { $ tplReady = '' ; $ this -> template = $ template ; $ this -> data = $ data ; if ( $ this -> loadTemplate ( ) ) { $ tplReady = $ this -> dataRender ; } if ( Settings :: getInstance ( ) -> get ( 'minifyTemplate' ) && ! Settings :: getInstance ( ) -> inDebug ( ) ) { $ tplReady = $ this -> minify ( $ tplReady ) ; } $ this -> release ( ) ; return $ tplReady ; }
7001	public function method ( $ method = null ) { if ( $ method ) $ this -> method = trim ( $ method ) ; return $ this -> method ; }
2327	public function setRow ( array $ arrData ) { if ( $ this -> intIndex < 0 ) { $ this -> first ( ) ; } $ this -> arrModels [ $ this -> intIndex ] -> setRow ( $ arrData ) ; return $ this ; }
4592	public function submit ( $ id , array $ variables ) { foreach ( $ variables as $ variable ) { if ( ! $ variable instanceof Variable ) { throw new InvalidArgumentException ( 'Array of variables is not valid.' ) ; } } $ resource = str_replace ( '{id}' , $ id , static :: RESOURCE_SUBMIT ) ; $ options = [ 'headers' => [ 'Accept' => 'application/json' , 'Content-Type' => 'application/json' ] ] ; foreach ( $ variables as $ variable ) { $ options [ 'json' ] [ 'variables' ] [ $ variable -> getName ( ) ] = [ 'value' => Variable :: TYPE_JSON === $ variable -> getType ( ) ? json_encode ( $ variable -> getValue ( ) ) : $ variable -> getValue ( ) , 'type' => $ variable -> getType ( ) ] ; } $ this -> execute ( 'POST' , $ resource , $ options ) ; }
562	public static function debug ( $ message , $ category = 'application' ) { if ( YII_DEBUG ) { static :: getLogger ( ) -> log ( $ message , Logger :: LEVEL_TRACE , $ category ) ; } }
11741	private function _getPerson ( $ id ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ person = $ em -> getRepository ( 'ChillPersonBundle:Person' ) -> find ( $ id ) ; return $ person ; }
12403	public function replace ( $ id , $ document = null ) { return Parser :: replace ( $ id , $ document , $ this -> connection ) ; }
10688	private function configureAutoloaderAndResolver ( ) { if ( $ this -> autoloader !== null ) return ; $ cache = $ this -> cachemanager -> getCache ( "resolution" ) ; $ this -> autoloader = new Autoloader ( ) ; $ this -> autoloader -> setCache ( $ cache ) ; $ this -> injector -> setInstance ( Autoloader :: class , $ this -> autoloader ) ; $ this -> resolver = new Resolver ( $ cache ) ; $ this -> resolver -> addResolverType ( 'template' , 'template' , '.php' ) -> addResolverType ( 'assets' , 'assets' ) -> addResolverType ( 'app' , 'app' ) -> addResolverType ( 'code' , 'src' ) -> addResolverType ( 'language' , 'language' ) -> addResolverType ( 'migrations' , 'migrations' ) -> setResolver ( "app" , new Router ( "router" ) ) ; $ this -> injector -> setInstance ( Resolver :: class , $ this -> resolver ) ; spl_autoload_register ( array ( $ this -> autoloader , 'autoload' ) , true , true ) ; $ cl = Autoloader :: findComposerAutoloader ( ) ; if ( ! empty ( $ cl ) ) { $ vendor_dir = Autoloader :: findComposerAutoloaderVendorDir ( $ cl ) ; $ this -> autoloader -> importComposerAutoloaderConfiguration ( $ vendor_dir ) ; $ this -> resolver -> autoConfigureFromComposer ( $ vendor_dir ) ; } else { $ my_dir = __DIR__ ; $ wedeto_dir = dirname ( dirname ( $ my_dir ) ) ; $ this -> autoloader -> registerNS ( "Wedeto\\" , $ wedeto_dir , Autoloader :: PSR4 ) ; $ modules = $ this -> resolver -> findModules ( $ wedeto_dir , '/modules' , "" , 0 ) ; foreach ( $ modules as $ name => $ path ) $ this -> resolver -> registerModule ( $ name , $ path ) ; } }
8325	public function deletePingback ( $ uri ) { $ response = $ this -> getHttpClient ( ) -> request ( 'GET' , "/res.php?key={$this->apiKey}&action=del_pingback&addr={$uri}" ) ; $ responseText = $ response -> getBody ( ) -> __toString ( ) ; if ( $ responseText === self :: STATUS_OK ) { return true ; } throw new ErrorResponseException ( $ this -> getErrorMessage ( $ responseText ) ? : $ responseText , $ this -> getErrorCode ( $ responseText ) ? : 0 ) ; }
4370	public function dump ( $ val , $ sanitize = true , $ tagName = 'span' ) { $ this -> wrapAttribs = array ( 'class' => array ( ) , 'title' => null , ) ; $ this -> sanitize = $ sanitize ; $ val = parent :: dump ( $ val ) ; if ( $ tagName && ! \ in_array ( $ this -> dumpType , array ( 'recursion' ) ) ) { $ wrapAttribs = $ this -> debug -> utilities -> arrayMergeDeep ( array ( 'class' => array ( 't_' . $ this -> dumpType , $ this -> dumpTypeMore , ) , ) , $ this -> wrapAttribs ) ; $ val = $ this -> debug -> utilities -> buildTag ( $ tagName , $ wrapAttribs , $ val ) ; } $ this -> wrapAttribs = array ( ) ; return $ val ; }
6651	private function appendExtraFields ( array $ extra ) { foreach ( $ this -> extraData as $ key => $ value ) { $ extra [ $ key ] = $ value ; } return $ extra ; }
9892	protected function createError ( ) { $ error = $ this -> getForm ( ) -> getValidator ( ) -> getMessages ( $ this -> getElement ( ) -> getName ( ) ) ; if ( $ error ) { $ this -> error = $ this -> builder -> make ( 'error' , [ ] , $ error ) ; } }
2157	public function generate ( ) { if ( $ this -> youtube == '' ) { return '' ; } if ( TL_MODE == 'BE' ) { $ return = '<p><a href="https://youtu.be/' . $ this -> youtube . '" target="_blank" rel="noreferrer noopener">youtu.be/' . $ this -> youtube . '</a></p>' ; if ( $ this -> headline != '' ) { $ return = '<' . $ this -> hl . '>' . $ this -> headline . '</' . $ this -> hl . '>' . $ return ; } return $ return ; } return parent :: generate ( ) ; }
11512	public function actionRequest ( ) { if ( ! $ this -> module -> enablePasswordRecovery ) { throw new NotFoundHttpException ; } $ model = \ Yii :: createObject ( [ 'class' => RecoveryForm :: className ( ) , 'scenario' => 'request' , ] ) ; $ this -> performAjaxValidation ( $ model ) ; if ( $ model -> load ( \ Yii :: $ app -> request -> post ( ) ) && $ model -> sendRecoveryMessage ( ) ) { return $ this -> render ( '/message' , [ 'title' => \ Yii :: t ( 'user' , 'Recovery message sent' ) , 'module' => $ this -> module , ] ) ; } return $ this -> render ( 'request' , [ 'model' => $ model , ] ) ; }
518	private function generateClassName ( $ name ) { $ namespace = null ; $ name = trim ( $ name , '\\' ) ; if ( strpos ( $ name , '\\' ) !== false ) { $ namespace = substr ( $ name , 0 , strrpos ( $ name , '\\' ) ) ; $ name = substr ( $ name , strrpos ( $ name , '\\' ) + 1 ) ; } else { if ( $ this -> migrationPath === null ) { $ migrationNamespaces = $ this -> migrationNamespaces ; $ namespace = array_shift ( $ migrationNamespaces ) ; } } if ( $ namespace === null ) { $ class = 'm' . gmdate ( 'ymd_His' ) . '_' . $ name ; } else { $ class = 'M' . gmdate ( 'ymdHis' ) . ucfirst ( $ name ) ; } return [ $ namespace , $ class ] ; }
4644	public function stop ( Job $ job , $ timeout = 10 ) { foreach ( $ job -> getServices ( ) as $ service ) { if ( $ service -> getContainer ( ) ) { try { $ this -> docker -> getContainerManager ( ) -> stop ( $ service -> getContainer ( ) , [ 't' => $ timeout ] ) ; } catch ( ClientErrorException $ e ) { if ( $ e -> getResponse ( ) -> getStatusCode ( ) != 304 ) { throw $ e ; } } $ this -> docker -> getContainerManager ( ) -> remove ( $ service -> getContainer ( ) , [ 'v' => true , 'force' => true ] ) ; $ service -> setContainer ( null ) ; } } }
10352	private function getSourceByJob ( $ job ) { $ login = head ( array_except ( $ job -> credentials , 'password' ) ) ; return $ login . app ( 'request' ) -> ip ( ) ; }
2498	private function getLanguageFilter ( array $ languageCodes ) { $ languageFilters = array ( ) ; foreach ( $ languageCodes as $ languageCode ) { $ condition = new CustomField ( self :: FIELD_LANGUAGE , Operator :: EQ , $ languageCode ) ; $ excluded = $ this -> getExcludedLanguageCodes ( $ languageCodes , $ languageCode ) ; if ( ! empty ( $ excluded ) ) { $ condition = new LogicalAnd ( array ( $ condition , new LogicalNot ( new CustomField ( self :: FIELD_LANGUAGES , Operator :: IN , $ excluded ) ) , ) ) ; } $ languageFilters [ ] = $ condition ; } if ( count ( $ languageFilters ) > 1 ) { $ languageFilters = array ( new LogicalOr ( $ languageFilters ) ) ; } if ( $ this -> hasMainLanguagesEndpoint ) { $ languageFilters [ ] = new LogicalNot ( new CustomField ( self :: FIELD_IS_MAIN_LANGUAGES_INDEX , Operator :: EQ , true ) ) ; } if ( count ( $ languageFilters ) > 1 ) { return new LogicalAnd ( $ languageFilters ) ; } return reset ( $ languageFilters ) ; }
5487	public function submitImage ( SelectorInterface $ selector , $ x , $ y , $ additional = false ) { $ additional = $ additional ? $ additional : array ( ) ; foreach ( $ this -> images as $ image ) { if ( $ selector -> isMatch ( $ image ) ) { $ encoding = $ this -> encode ( ) ; $ image -> write ( $ encoding , $ x , $ y ) ; if ( $ additional ) { $ encoding -> merge ( $ additional ) ; } return $ encoding ; } } return false ; }
12442	public function detach ( $ key ) { if ( isset ( $ this -> instances [ $ key ] ) ) { unset ( $ this -> instances [ $ key ] ) ; } return $ this ; }
3270	public function appendToFile ( string $ line ) { $ file = $ this -> openFile ( static :: FILE_APPEND ) ; $ file -> fwrite ( $ line ) ; $ this -> closeFile ( $ file ) ; }
8878	private function safeSendSignal ( $ process , string $ signal , int $ mappedSignal ) : void { if ( true !== proc_terminate ( $ process , $ mappedSignal ) ) { throw new CommandExecutionException ( 'Call to proc_terminate with signal "' . $ signal . '" failed for unknown reason.' ) ; } }
3677	private function fieldExists ( $ strTableName , $ strColumnName ) { $ columns = $ this -> connection -> getSchemaManager ( ) -> listTableColumns ( $ strTableName ) ; return isset ( $ columns [ $ strColumnName ] ) ; }
8025	public function addFree ( ProcessDetails $ processDetails ) { $ pid = $ processDetails -> getPid ( ) ; $ this -> processDetails [ $ pid ] = $ processDetails ; $ this -> sockets [ $ pid ] = $ processDetails -> getSocket ( ) ; $ this -> registerFreeProcess ( $ processDetails ) ; return $ this ; }
10492	public function sub ( $ value ) { $ value = Cast :: Float ( $ value ) ; if ( $ this -> value === null ) { return new FloatType ( $ this -> value ) ; } return new FloatType ( $ this -> value - $ value ) ; }
1966	public static function findByPk ( $ varValue , array $ arrOptions = array ( ) ) { if ( static :: $ strPk == 'id' ) { return static :: findById ( $ varValue , $ arrOptions ) ; } return parent :: findByPk ( $ varValue , $ arrOptions ) ; }
1994	public static function indexPageIfApplicable ( Response $ objResponse ) { global $ objPage ; if ( $ objPage === null ) { return ; } if ( Config :: get ( 'enableSearch' ) && $ objResponse -> getStatusCode ( ) == 200 && ! BE_USER_LOGGED_IN && ! $ objPage -> noSearch ) { if ( Config :: get ( 'indexProtected' ) || ( ! FE_USER_LOGGED_IN && ! $ objPage -> protected ) ) { $ blnIndex = true ; foreach ( array_keys ( $ _GET ) as $ key ) { if ( \ in_array ( $ key , $ GLOBALS [ 'TL_NOINDEX_KEYS' ] ) || strncmp ( $ key , 'page_' , 5 ) === 0 ) { $ blnIndex = false ; break ; } } if ( $ blnIndex ) { $ arrData = array ( 'url' => Environment :: get ( 'base' ) . Environment :: get ( 'relativeRequest' ) , 'content' => $ objResponse -> getContent ( ) , 'title' => $ objPage -> pageTitle ? : $ objPage -> title , 'protected' => ( $ objPage -> protected ? '1' : '' ) , 'groups' => $ objPage -> groups , 'pid' => $ objPage -> id , 'language' => $ objPage -> language ) ; Search :: indexPage ( $ arrData ) ; } } } }
5352	public function getSupportedNamespaces ( ) { if ( empty ( $ this -> data -> namespaces ) || ! is_array ( $ this -> data -> namespaces ) ) { return array ( ) ; } return $ this -> data -> namespaces ; }
184	public function init ( ) { parent :: init ( ) ; $ this -> cache = $ this -> enabled ? Instance :: ensure ( $ this -> cache , 'yii\caching\CacheInterface' ) : null ; if ( $ this -> cache instanceof CacheInterface && $ this -> getCachedContent ( ) === false ) { $ this -> getView ( ) -> pushDynamicContent ( $ this ) ; ob_start ( ) ; ob_implicit_flush ( false ) ; } }
892	public function getNormalizedTypes ( ) { $ normalized = array_map ( static function ( $ type ) { return strtolower ( $ type ) ; } , $ this -> getTypes ( ) ) ; sort ( $ normalized ) ; return $ normalized ; }
12139	public function renderWidget ( array $ fields , $ customFielsGroup , $ documentType = 'html' , array $ params = array ( ) ) { $ resolvedParams = array_merge ( $ this -> defaultParams , $ params ) ; return $ this -> container -> get ( 'templating' ) -> render ( $ resolvedParams [ 'layout' ] , array ( 'cFGroup' => $ customFielsGroup , 'cFData' => $ fields , 'show_empty' => $ resolvedParams [ 'show_empty' ] ) ) ; }
8563	private function _convertCreateShipment ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'CreateShipment' ; if ( $ request -> isSetSellerId ( ) ) { $ parameters [ 'SellerId' ] = $ request -> getSellerId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } if ( $ request -> isSetShipmentRequestDetails ( ) ) { $ ShipmentRequestDetailsCreateShipmentRequest = $ request -> getShipmentRequestDetails ( ) ; foreach ( $ ShipmentRequestDetailsCreateShipmentRequest -> getAmazonOrderId ( ) as $ AmazonOrderIdShipmentRequestDetailsIndex => $ AmazonOrderIdShipmentRequestDetails ) { $ parameters [ 'ShipmentRequestDetails' . '.' . 'AmazonOrderId' . '.' . ( $ AmazonOrderIdShipmentRequestDetailsIndex + 1 ) ] = $ AmazonOrderIdShipmentRequestDetails ; } } if ( $ request -> isSetShippingServiceId ( ) ) { $ parameters [ 'ShippingServiceId' ] = $ request -> getShippingServiceId ( ) ; } if ( $ request -> isSetShippingServiceOfferId ( ) ) { $ parameters [ 'ShippingServiceOfferId' ] = $ request -> getShippingServiceOfferId ( ) ; } return $ parameters ; }
9788	public function setConditions ( $ pValue ) { if ( ! is_array ( $ pValue ) ) { $ pValue = [ $ pValue ] ; } $ this -> condition = $ pValue ; return $ this ; }
4013	protected function calculate ( ) { if ( ! $ this -> isDirty ( ) ) { return ; } $ this -> isDirty = false ; $ this -> calculatedOffset = null ; $ this -> calculatedLimit = null ; if ( $ this -> isLimited ( ) ) { if ( $ this -> getLimit ( ) ) { $ this -> calculatedLimit = $ this -> getLimit ( ) ; } if ( $ this -> getOffset ( ) ) { $ this -> calculatedOffset = $ this -> getOffset ( ) ; } } if ( $ this -> getPerPage ( ) > 0 ) { $ this -> calculatePaginated ( ) ; return ; } if ( $ this -> calculatedLimit === null ) { $ this -> calculatedLimit = 0 ; } if ( $ this -> calculatedOffset === null ) { $ this -> calculatedOffset = 0 ; } }
10772	public function getMediaTypeMatch ( $ data ) { foreach ( $ this -> getMediaTypes ( ) as $ mediaTypeClass ) { $ instance = forward_static_call ( array ( $ mediaTypeClass , 'check' ) , $ data ) ; if ( $ instance ) { return $ instance ; } } }
11796	public function setSubject ( $ subject = '' , $ clear = false ) { if ( true === $ clear ) { $ this -> clear ( 'subject' ) ; } $ this -> subject = $ subject ; return $ this ; }
3329	public function status ( $ token ) { $ data = array ( 'token' => $ token , ) ; $ ch = $ this -> __initRequest ( 'from_url/status' , $ data ) ; $ this -> __setHeaders ( $ ch ) ; $ data = $ this -> __runRequest ( $ ch ) ; return $ data ; }
9375	public function render ( $ template , array $ data = array ( ) ) { list ( $ file , $ name ) = array ( null , str_replace ( '.' , '/' , $ template ) ) ; foreach ( ( array ) $ this -> paths as $ key => $ path ) { $ files = ( array ) $ this -> files ( $ path ) ; $ item = $ this -> check ( $ files , $ path , $ key , $ name . '.php' ) ; $ item !== null && $ file = $ item ; } if ( is_null ( $ file ) === true ) { $ message = 'Template file "' . $ name . '" not found.' ; throw new \ InvalidArgumentException ( ( string ) $ message ) ; } return $ this -> extract ( $ file , $ data ) ; }
5238	private function methodBindingName ( \ ReflectionMethod $ method ) { $ annotations = annotationsOf ( $ method ) ; if ( $ annotations -> contain ( 'List' ) ) { return $ annotations -> firstNamed ( 'List' ) -> getValue ( ) ; } if ( $ annotations -> contain ( 'Map' ) ) { return $ annotations -> firstNamed ( 'Map' ) -> getValue ( ) ; } if ( $ annotations -> contain ( 'Named' ) ) { return $ annotations -> firstNamed ( 'Named' ) -> getName ( ) ; } if ( $ annotations -> contain ( 'Property' ) ) { return $ annotations -> firstNamed ( 'Property' ) -> getValue ( ) ; } return null ; }
12684	public function offsetSet ( $ offset , $ value ) { if ( is_null ( $ this -> result ) ) { $ this -> fetchData ( ) ; } if ( ! $ this -> isFetched ( ) ) { trigger_error ( 'Web2All_Table_ObjectList::offsetSet: cannot set value on unitialized list' , E_USER_NOTICE ) ; return false ; } if ( ! $ this -> is_assoc && ! is_numeric ( $ value ) ) { trigger_error ( 'Web2All_Table_ObjectList::offsetSet: can only set numeric keys non assoc lists' , E_USER_NOTICE ) ; return false ; } if ( $ value instanceof $ this -> classname ) { $ this -> result [ $ offset ] = $ value ; } else { trigger_error ( 'Web2All_Table_ObjectList::offsetSet: can only add objects of type ' . $ this -> classname . ' to the list' , E_USER_NOTICE ) ; return false ; } }
8189	final protected function getContext ( $ context , $ item , $ ignoreStrictCheck = false ) { if ( ! array_key_exists ( $ item , $ context ) ) { if ( $ ignoreStrictCheck || ! $ this -> env -> isStrictVariables ( ) ) { return ; } throw new Twig_Error_Runtime ( sprintf ( 'Variable "%s" does not exist.' , $ item ) , - 1 , $ this -> getSourceContext ( ) ) ; } return $ context [ $ item ] ; }
12313	public function toArray ( ) { $ data = [ "uuid" => $ this -> uuid , "code" => $ this -> code , "modules" => $ this -> modules , "vars" => $ this -> vars , ] ; foreach ( [ 'modules' , 'vars' ] as $ key ) { if ( ! array_key_exists ( $ key , $ data ) ) { continue ; } if ( empty ( $ data [ $ key ] ) ) { $ data [ $ key ] = new \ stdClass ( ) ; } } return $ data ; }
6785	public function buildFormDataString ( $ options ) { $ options = $ this -> resolve ( $ options ) ; $ formOptions = [ ] ; foreach ( $ this -> formParameters as $ key => $ isFormParameter ) { if ( $ isFormParameter && isset ( $ options [ $ key ] ) ) { $ formOptions [ $ key ] = $ options [ $ key ] ; } } return http_build_query ( $ formOptions ) ; }
6953	private function resolvePrice ( array $ entry , $ weight ) { $ price = $ count = 0 ; if ( $ weight > $ entry [ 'max_weight' ] ) { $ count = floor ( $ weight / $ entry [ 'max_weight' ] ) ; $ weight = round ( fmod ( $ weight , $ count ) , 3 ) ; } if ( 0 < $ count ) { $ max = end ( $ entry [ 'prices' ] ) [ 'price' ] ; $ price = $ count * $ max ; } foreach ( $ entry [ 'prices' ] as $ p ) { if ( 1 === bccomp ( $ p [ 'weight' ] , $ weight , 3 ) ) { $ price += $ p [ 'price' ] ; break ; } } return $ price ; }
3097	protected function getItemData ( $ itemIdentifier ) { $ serviceContext = $ this -> getServiceContext ( ) ; $ itemRef = $ this -> getRunnerService ( ) -> getItemHref ( $ serviceContext , $ itemIdentifier ) ; $ itemData = $ this -> getRunnerService ( ) -> getItemData ( $ serviceContext , $ itemRef ) ; $ baseUrl = $ this -> getRunnerService ( ) -> getItemPublicUrl ( $ serviceContext , $ itemRef ) ; $ itemState = $ this -> getRunnerService ( ) -> getItemState ( $ serviceContext , $ itemIdentifier ) ; if ( $ itemState === null || ! count ( $ itemState ) ) { $ itemState = new stdClass ( ) ; } return [ 'baseUrl' => $ baseUrl , 'itemData' => $ itemData , 'itemState' => $ itemState , 'itemIdentifier' => $ itemIdentifier , ] ; }
7619	public function setPermissionSet ( $ value = array ( ) ) { foreach ( $ value as $ url ) { if ( strpos ( $ url , $ this -> accountName ) === false ) { throw new Exception ( 'The permission set can only contain URLs for the account name specified in the Credentials_SharedAccessSignature instance.' ) ; } } $ this -> permissionSet = $ value ; }
3486	private static function addDefaultResolvers ( ) : void { static $ added = false ; if ( $ added ) { return ; } $ added = true ; self :: addResolver ( [ __CLASS__ , 'tryResolveByWebTokenJwtSystem' ] ) ; self :: addResolver ( [ __CLASS__ , 'tryResolveBySpomkyLabsJoseSystem' ] ) ; }
12846	public function runHttpErrorPage ( int $ iError ) { if ( isset ( $ _SERVER ) && isset ( $ _SERVER [ 'HTTP_HOST' ] ) ) { foreach ( Config :: get ( 'route' ) as $ sHost => $ oHost ) { if ( ( ! strstr ( $ sHost , '/' ) && $ sHost == $ _SERVER [ 'HTTP_HOST' ] ) || ( strstr ( $ sHost , '/' ) && strstr ( $ _SERVER [ 'HTTP_HOST' ] . $ _SERVER [ 'REQUEST_URI' ] , $ sHost ) ) ) { $ this -> _oRoutes = $ oHost -> routes ; if ( strstr ( $ sHost , '/' ) && strstr ( $ _SERVER [ 'HTTP_HOST' ] . $ _SERVER [ 'REQUEST_URI' ] , $ sHost ) ) { $ this -> _sBaseUri = preg_replace ( '#^[^/]+#' , '' , $ sHost ) ; } $ sHttpErrorPageName = '_getPage' . iError ; $ this -> $ sHttpErrorPageName ( ) ; } } } }
2848	public function setModuleStatus ( $ moduleName , $ isActive ) { $ moduleConfigFile = $ this -> getModuleConfigFilePath ( $ moduleName ) ; $ configXml = $ this -> loadXmlFile ( $ moduleConfigFile ) ; if ( $ configXml === false ) { throw new Exception ( "Unable to parse module configuration file {$moduleConfigFile}" ) ; } $ configXml -> modules -> { $ moduleName } -> active = $ isActive ? 'true' : 'false' ; if ( $ this -> saveXml ( $ configXml , $ moduleConfigFile ) === false ) { throw new Exception ( "Unable to save module configuration file {$moduleConfigFile}. Check to see if web server user has write permissions." ) ; } }
12397	public function orWhere ( $ field , $ operator = null , $ value = null ) { return $ this -> where ( $ field , $ operator , $ value , '||' ) ; }
11690	protected function processAuth ( string $ actionName , array $ actionArgs ) : void { $ callAction = function ( string $ actionName , array $ actionArgs ) { if ( empty ( $ actionArgs ) ) { $ this -> ctrl -> { $ actionName } ( ) ; } else { ( new \ ReflectionMethod ( $ this -> ctrl , $ actionName ) ) -> invokeArgs ( $ this -> ctrl , $ actionArgs ) ; } } ; if ( class_exists ( '\extensions\core\Auth' ) ) { $ auth = new \ extensions \ core \ Auth ( $ this -> ctrl -> getRequest ( ) ) ; $ auth -> run ( ) ; if ( $ auth -> isValid ( ) ) { $ callAction ( $ actionName , $ actionArgs ) ; } else { $ auth -> onFail ( ) ; } } else { $ callAction ( $ actionName , $ actionArgs ) ; } }
2008	private function loadLanguageFile ( string $ name ) : void { $ system = $ this -> framework -> getAdapter ( System :: class ) ; $ system -> loadLanguageFile ( $ name ) ; }
387	public function setAttributeOrders ( $ attributeOrders , $ validate = true ) { if ( $ attributeOrders === null || ! $ validate ) { $ this -> _attributeOrders = $ attributeOrders ; } else { $ this -> _attributeOrders = [ ] ; foreach ( $ attributeOrders as $ attribute => $ order ) { if ( isset ( $ this -> attributes [ $ attribute ] ) ) { $ this -> _attributeOrders [ $ attribute ] = $ order ; if ( ! $ this -> enableMultiSort ) { break ; } } } } }
9546	public function count ( $ table , $ search , $ where = '' ) { if ( empty ( $ where ) ) { $ where = 'WHERE' ; } else { $ where = ( stripos ( $ where , 'WHERE' ) === false ) ? "WHERE {$where} AND" : "{$where} AND" ; } return $ this -> db -> value ( "SELECT COUNT(*) FROM {$table} AS s {$where} s.{$table} MATCH ?" , $ search ) ; }
8355	private function buildModel ( string $ modelName , array $ modelDefinition ) { $ mapping = Mapping :: get ( $ this -> mapping ) ; $ definition = $ this -> getDefinition ( ) ; $ database = GlobalDatabase :: get ( $ mapping [ 'config' ] [ 'database' ] ) ; $ tableName = null ; if ( isset ( $ modelDefinition [ 'name' ] ) === true ) { $ tableName = $ modelDefinition [ 'name' ] ; } else { $ tableName = Helper :: codifyName ( $ this -> mapping ) . '_' . Helper :: codifyName ( $ modelName ) ; } if ( isset ( $ modelDefinition [ 'fields' ] ) === false ) { throw new InvalidSchemaDefinition ( 'model "' . $ modelName . '" has no field' ) ; } $ statement = Mutation \ AddTable :: statement ( $ database , $ this -> getDefinition ( ) , $ this -> mapping , $ tableName , $ modelName ) ; if ( $ statement -> execute ( ) == false ) { throw new DatabaseError ( 'db/build : ' . print_r ( $ statement -> errorInfo ( ) , true ) ) ; } if ( isset ( $ modelDefinition [ 'indexes' ] ) === true ) { foreach ( $ modelDefinition [ 'indexes' ] as $ indexName => $ indexDefinition ) { $ statement = Mutation \ AddIndex :: statement ( $ database , $ modelName , $ tableName , $ modelDefinition , $ indexName ) ; if ( $ statement -> execute ( ) == false ) { throw new DatabaseError ( 'db/build : ' . print_r ( $ statement -> errorInfo ( ) , true ) ) ; } } } if ( isset ( $ modelDefinition [ 'uniques' ] ) === true ) { foreach ( $ modelDefinition [ 'uniques' ] as $ uniqueName => $ uniqueDefinition ) { $ statement = Mutation \ AddUnique :: statement ( $ database , $ modelName , $ tableName , $ modelDefinition , $ uniqueName ) ; if ( $ statement -> execute ( ) == false ) { throw new DatabaseError ( 'db/build : ' . print_r ( $ statement -> errorInfo ( ) , true ) ) ; } } } echo $ modelName . ' - Done' . PHP_EOL ; }
12093	public function getDomainUrl ( $ address , $ scheme = false ) { $ this -> urlAddress -> setAddress ( $ address ) ; return $ this -> urlAddress -> getDomain ( $ scheme ) ; }
9102	protected function build_sql ( ) { $ builder = new Builder ( ) ; $ select = $ this -> parse_select ( ) ; $ from = new From ( $ this -> table -> get_table_name ( $ GLOBALS [ 'wpdb' ] ) , 'q' ) ; $ where = new Where ( 1 , true , 1 ) ; if ( ( $ message = $ this -> parse_message ( ) ) !== null ) { $ where -> qAnd ( $ message ) ; } if ( ( $ level = $ this -> parse_level ( ) ) !== null ) { $ where -> qAnd ( $ level ) ; } if ( ( $ user = $ this -> parse_user ( ) ) !== null ) { $ where -> qAnd ( $ user ) ; } if ( ( $ group = $ this -> parse_group ( ) ) !== null ) { $ where -> qAnd ( $ group ) ; } if ( ( $ time = $ this -> parse_time ( ) ) !== null ) { $ where -> qAnd ( $ time ) ; } $ order = $ this -> parse_order ( ) ; $ limit = $ this -> parse_pagination ( ) ; $ builder -> append ( $ select ) -> append ( $ from ) ; $ builder -> append ( $ where ) ; $ builder -> append ( $ order ) ; if ( $ limit !== null ) { $ builder -> append ( $ limit ) ; } return $ builder -> build ( ) ; }
1127	public function isAncestorOf ( $ other ) { return ( $ this -> getLeft ( ) < $ other -> getLeft ( ) && $ this -> getRight ( ) > $ other -> getLeft ( ) && $ this -> inSameScope ( $ other ) ) ; }
9694	public function canRead ( $ pFilename ) { try { $ this -> openFile ( $ pFilename ) ; } catch ( Exception $ e ) { return false ; } $ beginning = $ this -> readBeginning ( ) ; $ startWithTag = self :: startsWithTag ( $ beginning ) ; $ containsTags = self :: containsTags ( $ beginning ) ; $ endsWithTag = self :: endsWithTag ( $ this -> readEnding ( ) ) ; fclose ( $ this -> fileHandle ) ; return $ startWithTag && $ containsTags && $ endsWithTag ; }
2363	public static function decodeEntities ( $ strString , $ strQuoteStyle = ENT_COMPAT , $ strCharset = null ) { if ( $ strString == '' ) { return '' ; } if ( $ strCharset === null ) { $ strCharset = Config :: get ( 'characterSet' ) ; } $ strString = preg_replace ( '/(&#*\w+)[\x00-\x20]+;/i' , '$1;' , $ strString ) ; $ strString = preg_replace ( '/(&#x*)([0-9a-f]+);/i' , '$1$2;' , $ strString ) ; return html_entity_decode ( $ strString , $ strQuoteStyle , $ strCharset ) ; }
813	private function fixSpaceAboveClassElement ( Tokens $ tokens , $ classStartIndex , $ elementIndex ) { static $ methodAttr = [ T_PRIVATE , T_PROTECTED , T_PUBLIC , T_ABSTRACT , T_FINAL , T_STATIC ] ; $ firstElementAttributeIndex = $ elementIndex ; for ( $ i = $ elementIndex ; $ i > $ classStartIndex ; -- $ i ) { $ nonWhiteAbove = $ tokens -> getNonWhitespaceSibling ( $ i , - 1 ) ; if ( null !== $ nonWhiteAbove && $ tokens [ $ nonWhiteAbove ] -> isGivenKind ( $ methodAttr ) ) { $ firstElementAttributeIndex = $ nonWhiteAbove ; } else { break ; } } if ( $ tokens [ $ nonWhiteAbove ] -> isGivenKind ( T_COMMENT ) ) { if ( 1 === $ firstElementAttributeIndex - $ nonWhiteAbove ) { $ this -> correctLineBreaks ( $ tokens , $ nonWhiteAbove , $ firstElementAttributeIndex , 1 ) ; return ; } if ( substr_count ( $ tokens [ $ nonWhiteAbove + 1 ] -> getContent ( ) , "\n" ) > 1 ) { $ this -> correctLineBreaks ( $ tokens , $ nonWhiteAbove , $ firstElementAttributeIndex , 2 ) ; return ; } if ( $ tokens [ $ nonWhiteAbove - 1 ] -> isWhitespace ( ) && substr_count ( $ tokens [ $ nonWhiteAbove - 1 ] -> getContent ( ) , "\n" ) > 0 ) { $ this -> correctLineBreaks ( $ tokens , $ nonWhiteAbove , $ firstElementAttributeIndex , 1 ) ; $ nonWhiteAbove = $ this -> findCommentBlockStart ( $ tokens , $ nonWhiteAbove ) ; $ nonWhiteAboveComment = $ tokens -> getNonWhitespaceSibling ( $ nonWhiteAbove , - 1 ) ; $ this -> correctLineBreaks ( $ tokens , $ nonWhiteAboveComment , $ nonWhiteAbove , $ nonWhiteAboveComment === $ classStartIndex ? 1 : 2 ) ; } else { $ this -> correctLineBreaks ( $ tokens , $ nonWhiteAbove , $ firstElementAttributeIndex , 2 ) ; } return ; } if ( false === $ tokens [ $ nonWhiteAbove ] -> isGivenKind ( T_DOC_COMMENT ) ) { $ this -> correctLineBreaks ( $ tokens , $ nonWhiteAbove , $ firstElementAttributeIndex , $ nonWhiteAbove === $ classStartIndex ? 1 : 2 ) ; return ; } $ this -> correctLineBreaks ( $ tokens , $ nonWhiteAbove , $ firstElementAttributeIndex , 1 ) ; $ nonWhiteAbovePHPDoc = $ tokens -> getNonWhitespaceSibling ( $ nonWhiteAbove , - 1 ) ; $ this -> correctLineBreaks ( $ tokens , $ nonWhiteAbovePHPDoc , $ nonWhiteAbove , $ nonWhiteAbovePHPDoc === $ classStartIndex ? 1 : 2 ) ; }
2592	public static function createRequestCreator ( $ params , $ libIdentifier ) { $ params -> receivedFrom = self :: makeReceivedFrom ( $ params -> receivedFrom , $ libIdentifier ) ; $ theRequestCreator = new Base ( $ params ) ; return $ theRequestCreator ; }
3782	public function modelToLabel ( ModelToLabelEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ model = $ event -> getModel ( ) ; $ type = $ model -> getProperty ( 'type' ) ; $ image = '<img src="' . $ this -> attributeFactory -> getIconForType ( $ type ) . '" />' ; $ metaModel = $ this -> getMetaModelByModelPid ( $ model ) ; $ attribute = $ this -> attributeFactory -> createAttribute ( $ model -> getPropertiesAsArray ( ) , $ metaModel ) ; if ( ! $ attribute ) { $ translator = $ event -> getEnvironment ( ) -> getTranslator ( ) ; $ event -> setLabel ( '<div class="field_heading cte_type"><strong>%s</strong> <em>[%s]</em></div> <div class="field_type block"> <strong>%s</strong><br /> </div>' ) -> setArgs ( array ( $ translator -> translate ( 'error_unknown_attribute.0' , 'tl_metamodel_attribute' ) , $ type , $ translator -> translate ( 'error_unknown_attribute.1' , 'tl_metamodel_attribute' , array ( $ type ) ) , ) ) ; return ; } $ colName = $ attribute -> getColName ( ) ; $ name = $ attribute -> getName ( ) ; $ arrDescription = StringUtil :: deserialize ( $ attribute -> get ( 'description' ) ) ; if ( is_array ( $ arrDescription ) ) { $ description = $ arrDescription [ $ attribute -> getMetaModel ( ) -> getActiveLanguage ( ) ] ; if ( ! $ description ) { $ description = $ arrDescription [ $ attribute -> getMetaModel ( ) -> getFallbackLanguage ( ) ] ; } } else { $ description = $ arrDescription ? : $ attribute -> getName ( ) ; } $ event -> setLabel ( '<div class="field_heading cte_type"><strong>%s</strong> <em>[%s]</em></div> <div class="field_type block"> %s<strong>%s</strong> - %s </div>' ) -> setArgs ( array ( $ colName , $ type , $ image , $ name , $ description ) ) ; }
1527	protected function doReplaceRelationship ( StoreInterface $ store , UpdateRelationship $ request ) { $ record = $ request -> getRecord ( ) ; $ name = Str :: classify ( $ field = $ request -> getRelationshipName ( ) ) ; if ( $ result = $ this -> invokeMany ( [ 'replacing' , "replacing{$name}" ] , $ record , $ request ) ) { return $ result ; } $ record = $ store -> replaceRelationship ( $ record , $ field , $ request -> all ( ) , $ request -> getParameters ( ) ) ; return $ this -> invokeMany ( [ "replaced{$name}" , "replaced" ] , $ record , $ request ) ? : $ record ; }
1271	public function noCandidates ( ) { if ( AddressValidation :: REQUEST_OPTION_ADDRESS_CLASSIFICATION == $ this -> requestAction ) { throw new \ BadMethodCallException ( __METHOD__ . ' should not be called on Address Classification only requests.' ) ; } return isset ( $ this -> response -> NoCandidatesIndicator ) ; }
1337	protected function getQueryParameters ( EncodingParametersInterface $ parameters ) { return new EncodingParameters ( $ parameters -> getIncludePaths ( ) , $ parameters -> getFieldSets ( ) , $ parameters -> getSortParameters ( ) ? : $ this -> defaultSort ( ) , $ parameters -> getPaginationParameters ( ) ? : $ this -> defaultPagination ( ) , $ parameters -> getFilteringParameters ( ) , $ parameters -> getUnrecognizedParameters ( ) ) ; }
1982	public static function hasError ( $ strScope = TL_MODE ) { $ session = System :: getContainer ( ) -> get ( 'session' ) ; if ( ! $ session -> isStarted ( ) ) { return false ; } return $ session -> getFlashBag ( ) -> has ( static :: getFlashBagKey ( 'error' , $ strScope ) ) ; }
9231	public function actionIndex ( $ format = false , $ arraymap = false , $ term = false , $ category = false , $ time = false ) { $ searchModel = new PostSearch ( ) ; $ req = Yii :: $ app -> request -> queryParams ; if ( $ term ) { $ req [ basename ( str_replace ( "\\" , "/" , get_class ( $ searchModel ) ) ) ] [ "term" ] = $ term ; } if ( $ category ) { $ req [ basename ( str_replace ( "\\" , "/" , get_class ( $ searchModel ) ) ) ] [ "category" ] = $ category ; } if ( $ time ) { $ req [ basename ( str_replace ( "\\" , "/" , get_class ( $ searchModel ) ) ) ] [ "time" ] = $ time ; } $ dataProvider = $ searchModel -> search ( $ req ) ; $ query = $ dataProvider -> query ; $ query -> andWhere ( [ 'status' => [ 1 ] ] ) ; if ( $ format == 'json' ) { $ model = [ ] ; foreach ( $ dataProvider -> getModels ( ) as $ d ) { $ obj = $ d -> attributes ; if ( $ arraymap ) { $ map = explode ( "," , $ arraymap ) ; if ( count ( $ map ) == 1 ) { $ obj = ( isset ( $ d [ $ arraymap ] ) ? $ d [ $ arraymap ] : null ) ; } else { $ obj = [ ] ; foreach ( $ map as $ a ) { $ k = explode ( ":" , $ a ) ; $ v = ( count ( $ k ) > 1 ? $ k [ 1 ] : $ k [ 0 ] ) ; $ obj [ $ k [ 0 ] ] = ( $ v == "Obj" ? json_encode ( $ d -> attributes ) : ( isset ( $ d -> $ v ) ? $ d -> $ v : null ) ) ; } } } if ( $ term ) { if ( ! in_array ( $ obj , $ model ) ) { array_push ( $ model , $ obj ) ; } } else { array_push ( $ model , $ obj ) ; } } header ( "Access-Control-Allow-Origin: *" ) ; header ( "Access-Control-Expose-Headers: X-Pagination-Per-Page,X-Pagination-Current-Page,X-Pagination-Page-Count,X-Pagination-Total-Count,Content-Type,Location" ) ; return \ yii \ helpers \ Json :: encode ( $ model ) ; } else { return $ this -> render ( 'index' , [ 'searchModel' => $ searchModel , 'dataProvider' => $ dataProvider , ] ) ; } }
10741	protected function buildRecord ( ) { $ res = [ ] ; foreach ( $ this -> clause_records as $ tbl ) { $ res [ ] = $ this -> quote ( $ tbl ) . '.*' ; } if ( ! empty ( $ res ) ) { return [ join ( ', ' , $ res ) ] ; } else { return [ ] ; } }
2740	public function execute ( ) { $ result = $ this -> resultJsonFactory -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ snippet = Config :: BLOCKING_SETTING_NAME ; $ req = $ this -> api -> hasSnippet ( $ activeVersion , $ snippet ) ; if ( $ req == false ) { return $ result -> setData ( [ 'status' => false ] ) ; } return $ result -> setData ( [ 'status' => true , 'req_setting' => $ req ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
11906	public function handle ( ServerRequestInterface $ request ) : ResponseInterface { $ msg = "This is the default request handler. This means no middleware produced a response before hitting it." ; $ contents = json_encode ( [ 'type' => MiddlewareStackExhaustedException :: class , 'message' => $ msg , ] ) ; $ response = $ this -> factory -> createResponse ( 404 ) -> withHeader ( 'Content-type' , 'application/json' ) ; $ response -> getBody ( ) -> write ( $ contents ) ; return $ response ; }
7828	protected function getSpacesByWord ( $ word ) { $ length = $ this -> getSideBordersLength ( ) + static :: SPACE_FROM_ARROW + static :: ARROW_WIDTH ; $ extra = $ this -> getHalfWidth ( true ) - $ length - strlen ( $ word ) ; return $ extra > 0 ? str_repeat ( ' ' , $ extra ) : '' ; }
356	public function init ( ) { parent :: init ( ) ; if ( $ this -> enableCoreCommands ) { foreach ( $ this -> coreCommands ( ) as $ id => $ command ) { if ( ! isset ( $ this -> controllerMap [ $ id ] ) ) { $ this -> controllerMap [ $ id ] = $ command ; } } } if ( ! isset ( $ this -> controllerMap [ 'help' ] ) ) { $ this -> controllerMap [ 'help' ] = 'yii\console\controllers\HelpController' ; } }
11739	public function getMd5Address ( $ scheme = true , $ www = true ) { return md5 ( $ this -> normalize ( $ scheme , $ www ) ) ; }
11243	public function setDirection ( Neuron_GameServer_Map_Vector3 $ start , Neuron_GameServer_Map_Vector3 $ end ) { $ this -> startRotation = $ start ; $ this -> endRotation = $ end ; }
10942	private function reset ( ) { $ time = new \ DateTime ( ) ; $ this -> driver -> set ( self :: LAST_UPDATE_KEY , $ time ) ; return $ time ; }
3299	public function setHeaders ( array $ headers = [ ] ) { $ originHeaders = empty ( $ this -> headers ) ? [ ] : $ this -> headers ; $ this -> headers = array_merge ( $ originHeaders , $ headers ) ; return $ this ; }
1688	public function updateStyleSheet ( $ intId ) { $ objStyleSheet = $ this -> Database -> prepare ( "SELECT * FROM tl_style_sheet WHERE id=?" ) -> limit ( 1 ) -> execute ( $ intId ) ; if ( $ objStyleSheet -> numRows < 1 ) { return ; } if ( Input :: get ( 'act' ) == 'delete' ) { $ this -> import ( Files :: class , 'Files' ) ; $ this -> Files -> delete ( 'assets/css/' . $ objStyleSheet -> name . '.css' ) ; } else { $ this -> writeStyleSheet ( $ objStyleSheet -> row ( ) ) ; $ this -> log ( 'Generated style sheet "' . $ objStyleSheet -> name . '.css"' , __METHOD__ , TL_CRON ) ; } }
5546	public function getTransportError ( ) { if ( is_integer ( $ this -> focus ) ) { return $ this -> frames [ $ this -> focus ] -> getTransportError ( ) ; } return $ this -> frameset -> getTransportError ( ) ; }
2809	public function getVisiblePanels ( ) { if ( $ this -> visiblePanels === null ) { $ this -> visiblePanels = array ( ) ; $ panels = $ this -> getSortedChildBlocks ( ) ; foreach ( $ panels as $ panel ) { if ( ! $ panel instanceof Sheep_Debug_Block_Panel ) { continue ; } $ this -> visiblePanels [ ] = $ panel ; } } return $ this -> visiblePanels ; }
2074	public function purgeSearchTables ( ) { $ objDatabase = Database :: getInstance ( ) ; $ objDatabase -> execute ( "TRUNCATE TABLE tl_search" ) ; $ objDatabase -> execute ( "TRUNCATE TABLE tl_search_index" ) ; $ strCachePath = StringUtil :: stripRootDir ( System :: getContainer ( ) -> getParameter ( 'kernel.cache_dir' ) ) ; $ objFolder = new Folder ( $ strCachePath . '/contao/search' ) ; $ objFolder -> purge ( ) ; $ this -> log ( 'Purged the search tables' , __METHOD__ , TL_CRON ) ; }
10657	public function getArrayCopyRec ( ) { $ ret = array ( ) ; $ it = $ this -> getIterator ( ) ; while ( $ it -> valid ( ) ) { if ( $ it -> current ( ) instanceof self ) { $ ret [ $ it -> key ( ) ] = $ it -> current ( ) -> getArrayCopyRec ( ) ; } else { $ ret [ $ it -> key ( ) ] = $ it -> current ( ) ; } $ it -> next ( ) ; } return $ ret ; }
305	private function setRelationDependencies ( $ name , $ relation , $ viaRelationName = null ) { if ( empty ( $ relation -> via ) && $ relation -> link ) { foreach ( $ relation -> link as $ attribute ) { $ this -> _relationsDependencies [ $ attribute ] [ $ name ] = $ name ; if ( $ viaRelationName !== null ) { $ this -> _relationsDependencies [ $ attribute ] [ ] = $ viaRelationName ; } } } elseif ( $ relation -> via instanceof ActiveQueryInterface ) { $ this -> setRelationDependencies ( $ name , $ relation -> via ) ; } elseif ( is_array ( $ relation -> via ) ) { list ( $ viaRelationName , $ viaQuery ) = $ relation -> via ; $ this -> setRelationDependencies ( $ name , $ viaQuery , $ viaRelationName ) ; } }
10423	public function setTriggerType ( $ type ) { if ( ! array_key_exists ( $ type , $ this -> validTypes ) ) { throw new \ InvalidArgumentException ( 'The type MUST be one of:' . implode ( ',' , $ this -> validTypes ) ) ; } $ this -> type = $ this -> validTypes [ $ type ] ; $ this -> typeAlias = $ type ; }
4428	protected function getQuestion ( $ questionName , $ defaultValue = null , $ validator = null ) { $ questionName = $ defaultValue ? '<info>' . $ questionName . '</info> [<comment>' . $ defaultValue . '</comment>]: ' : '<info>' . $ questionName . '</info>: ' ; $ question = new Question ( $ questionName , $ defaultValue ) ; if ( $ validator !== null ) { $ question -> setValidator ( $ validator ) ; } return $ question ; }
10208	public function delete ( $ resourcePath , $ queryParameters = array ( ) , $ mimeType = 'application/vnd.maileon.api+xml' , $ deserializationType = null ) { $ curlSession = $ this -> prepareSession ( $ resourcePath , $ queryParameters , $ mimeType ) ; curl_setopt ( $ curlSession , CURLOPT_CUSTOMREQUEST , "DELETE" ) ; return $ this -> performRequest ( $ curlSession , $ deserializationType ) ; }
4279	public function stream_seek ( $ offset , $ whence = SEEK_SET ) { if ( ! $ this -> handle ) { return false ; } self :: restorePrev ( ) ; $ result = \ fseek ( $ this -> handle , $ offset , $ whence ) ; $ success = $ result !== - 1 ; self :: register ( ) ; return $ success ; }
10598	protected function initViewPanelRequestedUrlData ( ) { $ req = & $ this -> request ; $ this -> view -> requestedUrl = ( object ) [ 'method' => htmlSpecialChars ( $ req -> GetMethod ( ) , ENT_IGNORE , 'UTF-8' ) , 'baseUrl' => htmlSpecialChars ( $ req -> GetBaseUrl ( ) , ENT_IGNORE , 'UTF-8' ) , 'path' => htmlSpecialChars ( $ req -> GetRequestPath ( ) , ENT_IGNORE , 'UTF-8' ) , ] ; }
8100	protected function validate ( $ name , $ limit , $ regEx = false ) { $ Name = ucfirst ( $ name ) ; $ value = $ this -> _updates -> $ name ; $ length = explode ( '-' , $ limit ) ; $ min = intval ( $ length [ 0 ] ) ; $ max = intval ( $ length [ 1 ] ) ; if ( ! $ max and ! $ min ) { $ this -> log -> error ( "Invalid second parameter for the $name validation" ) ; return false ; } if ( ! $ value ) { if ( is_null ( $ value ) ) { $ this -> log -> report ( "Missing index $name from the input" ) ; } if ( strlen ( $ value ) == $ min ) { $ this -> log -> report ( "$Name is blank and optional - skipped" ) ; return true ; } $ this -> log -> formError ( $ name , "$Name is required." ) ; return false ; } if ( strlen ( $ value ) > $ max ) { $ this -> log -> formError ( $ name , "The $Name is larger than $max characters." ) ; return false ; } if ( strlen ( $ value ) < $ min ) { $ this -> log -> formError ( $ name , "The $Name is too short. It should at least be $min characters long" ) ; return false ; } if ( $ regEx ) { preg_match ( $ regEx , $ value , $ match ) ; if ( preg_match ( $ regEx , $ value , $ match ) === 0 ) { $ this -> log -> formError ( $ name , "The $Name \"{$value}\" is not valid" ) ; return false ; } } $ this -> log -> report ( "The $name is Valid" ) ; return true ; }
10163	private function readSheetLayout ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; $ offset = 0 ; if ( ! $ this -> readDataOnly ) { $ sz = self :: getInt4d ( $ recordData , 12 ) ; switch ( $ sz ) { case 0x14 : $ colorIndex = self :: getUInt2d ( $ recordData , 16 ) ; $ color = Xls \ Color :: map ( $ colorIndex , $ this -> palette , $ this -> version ) ; $ this -> phpSheet -> getTabColor ( ) -> setRGB ( $ color [ 'rgb' ] ) ; break ; case 0x28 : return ; break ; } } }
1696	public static function findByIds ( $ arrIds ) { if ( empty ( $ arrIds ) || ! \ is_array ( $ arrIds ) ) { return null ; } $ objDatabase = Database :: getInstance ( ) ; $ arrIds = array_map ( '\intval' , $ arrIds ) ; $ objResult = $ objDatabase -> execute ( "SELECT *, (SELECT tstamp FROM tl_theme WHERE tl_theme.id=tl_style_sheet.pid) AS tstamp3, (SELECT MAX(tstamp) FROM tl_style WHERE tl_style.pid=tl_style_sheet.id) AS tstamp2, (SELECT COUNT(*) FROM tl_style WHERE tl_style.selector='@font-face' AND tl_style.invisible='' AND tl_style.pid=tl_style_sheet.id) AS hasFontFace FROM tl_style_sheet WHERE id IN (" . implode ( ',' , $ arrIds ) . ") ORDER BY " . $ objDatabase -> findInSet ( 'id' , $ arrIds ) ) ; return static :: createCollectionFromDbResult ( $ objResult , 'tl_style_sheet' ) ; }
4234	private static function splitParams ( $ paramStr ) { $ depth = 0 ; $ startPos = 0 ; $ chars = \ str_split ( $ paramStr ) ; $ params = array ( ) ; foreach ( $ chars as $ pos => $ char ) { switch ( $ char ) { case ',' : if ( $ depth === 0 ) { $ params [ ] = \ trim ( \ substr ( $ paramStr , $ startPos , $ pos - $ startPos ) ) ; $ startPos = $ pos + 1 ; } break ; case '[' : case '(' : $ depth ++ ; break ; case ']' : case ')' : $ depth -- ; break ; } } $ params [ ] = \ trim ( \ substr ( $ paramStr , $ startPos , $ pos + 1 - $ startPos ) ) ; return $ params ; }
7936	public function getSeeOffers ( $ countryDestination , $ countryCurrencyPrice , $ quantity ) { return json_decode ( self :: getClient ( ) -> getSeeOffers ( $ this -> domain , $ countryDestination , $ countryCurrencyPrice , $ quantity ) ) ; }
2982	public function addBundle ( $ bundle ) { if ( ! $ this -> getFilename ( ) ) { return false ; } $ src = file ( $ this -> getFilename ( ) ) ; $ method = $ this -> reflected -> getMethod ( 'registerBundles' ) ; $ lines = array_slice ( $ src , $ method -> getStartLine ( ) - 1 , $ method -> getEndLine ( ) - $ method -> getStartLine ( ) + 1 ) ; if ( false !== strpos ( implode ( '' , $ lines ) , $ bundle ) ) { throw new \ RuntimeException ( sprintf ( 'Bundle "%s" is already defined in "AppKernel::registerBundles()".' , $ bundle ) ) ; } $ this -> setCode ( token_get_all ( '<?php ' . implode ( '' , $ lines ) ) , $ method -> getStartLine ( ) ) ; while ( $ token = $ this -> next ( ) ) { if ( T_VARIABLE !== $ token [ 0 ] || '$bundles' !== $ token [ 1 ] ) { continue ; } $ this -> next ( ) ; $ token = $ this -> next ( ) ; if ( T_ARRAY !== $ token [ 0 ] && '[' !== $ this -> value ( $ token ) ) { return false ; } while ( $ token = $ this -> next ( ) ) { if ( ')' !== $ this -> value ( $ token ) && ']' !== $ this -> value ( $ token ) ) { continue ; } if ( ';' !== $ this -> value ( $ this -> peek ( ) ) ) { continue ; } $ this -> next ( ) ; $ leadingContent = implode ( '' , array_slice ( $ src , 0 , $ this -> line ) ) ; $ leadingContent = rtrim ( rtrim ( $ leadingContent ) , ';' ) ; $ closingSymbolRegex = '#(\)|])$#' ; preg_match ( $ closingSymbolRegex , $ leadingContent , $ matches ) ; $ closingSymbol = $ matches [ 0 ] ; $ leadingContent = rtrim ( preg_replace ( $ closingSymbolRegex , '' , rtrim ( $ leadingContent ) ) ) ; if ( '(' !== substr ( $ leadingContent , - 1 ) && '[' !== substr ( $ leadingContent , - 1 ) ) { $ leadingContent = rtrim ( $ leadingContent , ',' ) . ',' ; } $ lines = array_merge ( array ( $ leadingContent , "\n" ) , array ( str_repeat ( ' ' , 12 ) , sprintf ( 'new %s(),' , $ bundle ) , "\n" ) , array ( str_repeat ( ' ' , 8 ) , $ closingSymbol . ';' , "\n" ) , array_slice ( $ src , $ this -> line ) ) ; Generator :: dump ( $ this -> getFilename ( ) , implode ( '' , $ lines ) ) ; return true ; } } }
8781	public function save ( $ content = null , $ time = 30 ) { $ fileName = md5 ( $ this -> prefix . http ( ) -> server ( 'REQUEST_URI' ) ) . $ this -> extension ; $ this -> file = cache_path ( 'html' . DIRECTORY_SEPARATOR . $ fileName ) ; $ this -> start ( $ time ) ; return $ this -> finish ( $ content ) ; }
1613	public function close ( ) { if ( $ this -> _socket !== false ) { $ connection = ( $ this -> unixSocket ? : $ this -> hostname . ':' . $ this -> port ) . ', database=' . $ this -> database ; \ Yii :: trace ( 'Closing DB connection: ' . $ connection , __METHOD__ ) ; try { $ this -> executeCommand ( 'QUIT' ) ; } catch ( SocketException $ e ) { } fclose ( $ this -> _socket ) ; $ this -> _socket = false ; } }
7080	public function onPreCopy ( SaleTransformEvent $ event ) { $ source = $ event -> getSource ( ) ; if ( $ source instanceof OrderInterface ) { if ( $ source -> getState ( ) !== OrderStates :: STATE_NEW ) { $ event -> addMessage ( new ResourceMessage ( 'ekyna_commerce.sale.message.transform_prevented' , ResourceMessage :: TYPE_ERROR ) ) ; } } }
10790	protected function quote ( $ str ) { return $ this -> getDialect ( ) -> quote ( $ str , $ this -> getSettings ( ) [ 'autoQuote' ] ? DialectInterface :: QUOTE_YES : DialectInterface :: QUOTE_NO ) ; }
3080	public static function isAssessmentSectionAdaptive ( AssessmentSection $ section , $ namespace = '' ) { if ( $ namespace === '' ) { $ namespace = CatService :: QTI_2X_ADAPTIVE_XML_NAMESPACE ; } $ isAdaptive = false ; if ( ( $ selection = $ section -> getSelection ( ) ) !== null && ( ( $ xmlExtension = $ selection -> getXml ( ) ) ) !== null ) { $ xpath = new \ DOMXPath ( $ xmlExtension ) ; $ xpath -> registerNamespace ( 'ais' , $ namespace ) ; if ( $ xpath -> query ( './/ais:adaptiveItemSelection' , $ xmlExtension ) -> length > 0 ) { $ isAdaptive = true ; } } return $ isAdaptive ; }
3784	public function handle ( EncodePropertyValueFromWidgetEvent $ event ) { if ( ( 'tl_metamodel_dca_combine' !== $ event -> getEnvironment ( ) -> getDataDefinition ( ) -> getName ( ) ) || ( 'rows' !== $ event -> getProperty ( ) ) ) { return ; } $ environment = $ event -> getEnvironment ( ) ; $ dataProvider = $ environment -> getDataProvider ( ) ; $ properties = $ environment -> getDataDefinition ( ) -> getPropertiesDefinition ( ) ; $ values = ( array ) $ event -> getValue ( ) ; foreach ( $ values as $ row => $ current ) { $ values [ $ row ] = $ this -> updateValues ( $ current , $ properties , $ dataProvider ) ; } $ event -> setValue ( $ values ) ; }
2694	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activate_flag = $ this -> getRequest ( ) -> getParam ( 'activate_flag' ) ; $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ formData = $ this -> getRequest ( ) -> getParams ( ) ; if ( in_array ( "" , $ formData ) ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Please fill in the required fields.' ] ) ; } $ service = $ this -> api -> checkServiceDetails ( ) ; $ this -> vcl -> checkCurrentVersionActive ( $ service -> versions , $ activeVersion ) ; $ currActiveVersion = $ this -> vcl -> getCurrentVersion ( $ service -> versions ) ; $ clone = $ this -> api -> cloneVersion ( $ currActiveVersion ) ; $ id = $ service -> id . '-' . $ clone -> number . '-imageopto' ; $ params = json_encode ( [ 'data' => [ 'id' => $ id , 'type' => 'io_settings' , 'attributes' => [ 'webp' => $ this -> getRequest ( ) -> getParam ( 'webp' ) , 'webp_quality' => $ this -> getRequest ( ) -> getParam ( 'webp_quality' ) , 'jpeg_type' => $ this -> getRequest ( ) -> getParam ( 'jpeg_type' ) , 'jpeg_quality' => $ this -> getRequest ( ) -> getParam ( 'jpeg_quality' ) , 'upscale' => $ this -> getRequest ( ) -> getParam ( 'upscale' ) , 'resize_filter' => $ this -> getRequest ( ) -> getParam ( 'resize_filter' ) ] ] ] ) ; $ configureIo = $ this -> api -> configureImageOptimizationDefaultConfigOptions ( $ params , $ clone -> number ) ; if ( ! $ configureIo ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to update image optimization default config options.' ] ) ; } $ this -> api -> validateServiceVersion ( $ clone -> number ) ; if ( $ activate_flag === 'true' ) { $ this -> api -> activateVersion ( $ clone -> number ) ; } if ( $ this -> config -> areWebHooksEnabled ( ) && $ this -> config -> canPublishConfigChanges ( ) ) { $ this -> api -> sendWebHook ( '*Image optimization default config options have been updated*' ) ; } $ comment = [ 'comment' => 'Magento Module updated the Image Optimization Default Configuration' ] ; $ this -> api -> addComment ( $ clone -> number , $ comment ) ; return $ result -> setData ( [ 'status' => true , 'active_version' => $ clone -> number ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
5084	protected function validateUserInput ( $ aData , $ oItem = null ) { $ aOut = [ ] ; $ aFields = $ this -> oModel -> describeFields ( ) ; $ aKeys = array_unique ( array_merge ( array_keys ( $ aFields ) , arrayExtractProperty ( $ this -> oModel -> getExpandableFields ( ) , 'trigger' ) ) ) ; $ aValidKeys = array_diff ( $ aKeys , static :: IGNORE_FIELDS_WRITE ) ; foreach ( $ aValidKeys as $ sValidKey ) { $ oField = getFromArray ( $ sValidKey , $ aFields ) ; if ( array_key_exists ( $ sValidKey , $ aData ) ) { $ aOut [ $ sValidKey ] = getFromArray ( $ sValidKey , $ aData ) ; } } return $ aOut ; }
2347	public function getContent ( ) { $ strContent = file_get_contents ( $ this -> strRootDir . '/' . ( $ this -> strTmp ? : $ this -> strFile ) ) ; if ( strncmp ( $ strContent , "\xEF\xBB\xBF" , 3 ) === 0 ) { $ strContent = substr ( $ strContent , 3 ) ; } elseif ( strncmp ( $ strContent , "\xFF\xFE" , 2 ) === 0 ) { $ strContent = substr ( $ strContent , 2 ) ; } elseif ( strncmp ( $ strContent , "\xFE\xFF" , 2 ) === 0 ) { $ strContent = substr ( $ strContent , 2 ) ; } return $ strContent ; }
5502	protected function dieOnNoMethod ( $ method , $ task ) { if ( $ this -> is_strict && ! method_exists ( $ this , $ method ) ) { $ errormsg = sprintf ( 'Cannot %s. Method %s() not in class %s.' , $ task , $ method , get_class ( $ this ) ) ; trigger_error ( $ errormsg , E_USER_ERROR ) ; } }
8754	public function start ( $ block = true , $ interval = 100 ) { $ loop = $ this -> loop ; $ this -> pool = new ParallelPool ( function ( ) use ( $ loop ) { $ loop -> run ( ) ; } , $ this -> count ) ; $ this -> pool -> start ( ) ; $ this -> pool -> keep ( $ block , $ interval ) ; }
2516	public function pnrCreatePnr ( RequestOptions \ PnrCreatePnrOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'PNR_AddMultiElements' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; }
940	public function override ( $ other ) { @ trigger_error ( __METHOD__ . ' is deprecated and will be removed in 3.0.' , E_USER_DEPRECATED ) ; Tokens :: setLegacyMode ( true ) ; $ prototype = $ other instanceof self ? $ other -> getPrototype ( ) : $ other ; if ( $ this -> equals ( $ prototype ) ) { return ; } $ this -> changed = true ; if ( \ is_array ( $ prototype ) ) { $ this -> isArray = true ; $ this -> id = $ prototype [ 0 ] ; $ this -> content = $ prototype [ 1 ] ; return ; } $ this -> isArray = false ; $ this -> id = null ; $ this -> content = $ prototype ; }
2546	protected function makeStatusFromErrorQualifier ( $ qualifier , $ defaultStatus = Result :: STATUS_ERROR ) { $ statusQualMapping = [ 'INF' => Result :: STATUS_INFO , 'WEC' => Result :: STATUS_WARN , 'WZZ' => Result :: STATUS_WARN , 'WA' => Result :: STATUS_WARN , 'W' => Result :: STATUS_WARN , 'EC' => Result :: STATUS_ERROR , 'ERR' => Result :: STATUS_ERROR , 'ERC' => Result :: STATUS_ERROR , 'X' => Result :: STATUS_ERROR , '001' => Result :: STATUS_ERROR , 'O' => Result :: STATUS_OK , 'STA' => Result :: STATUS_OK , 'ZZZ' => Result :: STATUS_UNKNOWN ] ; if ( array_key_exists ( $ qualifier , $ statusQualMapping ) ) { $ status = $ statusQualMapping [ $ qualifier ] ; } elseif ( is_null ( $ qualifier ) ) { $ status = $ defaultStatus ; } else { $ status = Result :: STATUS_UNKNOWN ; } return $ status ; }
8302	public function assertArray ( $ config , $ key ) { if ( array_key_exists ( $ key , $ config ) && ! is_array ( $ config [ $ key ] ) ) { throw new ConfigurationException ( $ key . " section must be an array." ) ; } return $ this ; }
9157	final public function call ( $ action , Request $ request , View $ view ) { $ this -> request = $ request ; ob_start ( ) ; $ rf = new \ ReflectionMethod ( $ this , $ action ) ; $ anno = $ rf -> getDocComment ( ) ; $ matches = array ( ) ; if ( preg_match ( '#@responseType ([\w\/]+)#' , $ anno , $ matches ) ) { $ this -> response -> setType ( $ matches [ 1 ] ) ; } if ( preg_match ( '#@title ([^\\n]+)#' , $ anno , $ matches ) ) { $ this -> response -> setTitle ( $ matches [ 1 ] ) ; } $ rf -> invoke ( $ this , $ this -> request ) ; $ this -> response -> appendBody ( ob_get_clean ( ) ) ; $ view -> render ( $ this -> response , $ request , $ this -> viewParams ) ; $ this -> addControls ( $ this -> response , $ request , $ view ) ; return $ this -> response ; }
10224	private function buildComplexIndexMenu ( $ modelName , $ modelId , ModelConfig $ config = null ) { $ model = $ this -> aujaConfigurator -> getModel ( $ modelName ) ; $ relations = $ this -> aujaConfigurator -> getRelationsForModel ( $ model ) ; $ associationRelations = array ( ) ; foreach ( $ relations as $ relation ) { if ( $ relation -> getType ( ) == Relation :: HAS_MANY || $ relation -> getType ( ) == Relation :: HAS_AND_BELONGS_TO ) { $ associationRelations [ ] = $ relation ; } } switch ( count ( $ associationRelations ) ) { case 0 : $ menu = $ this -> noAssociationsMenuFor ( $ modelName , $ config ) ; break ; case 1 : $ menu = $ this -> singleAssociationMenuFor ( $ modelName , $ modelId , $ associationRelations [ 0 ] , $ config ) ; break ; default : $ menu = $ this -> multipleAssociationsMenuFor ( $ modelName , $ modelId , $ associationRelations , $ config ) ; break ; } return $ menu ; }
7994	public function getDedicatedServerList ( ) { $ request = $ this -> get ( 'dedicated/server' ) ; $ response = $ request -> send ( ) ; return $ response -> getBody ( true ) ; }
5840	protected function crop ( Builder $ url , $ args ) { $ url -> crop ( $ args [ 'top_left_x' ] , $ args [ 'top_left_y' ] , $ args [ 'bottom_right_x' ] , $ args [ 'bottom_right_y' ] ) ; }
10418	public static function extract ( $ yamlArray , $ key , $ needed = false ) { if ( ! empty ( $ yamlArray ) && array_key_exists ( $ key , $ yamlArray ) ) return $ yamlArray [ $ key ] ; if ( $ needed ) { throw new \ Deployer \ Exception \ Exception ( 'Cannot find the setting: ' . $ key . '. This key needs to be given!' ) ; } return null ; }
2576	protected function mergeOptions ( $ existingOptions , $ newOptions ) { if ( ! empty ( $ newOptions ) ) { $ existingOptions = array_merge ( $ existingOptions , $ newOptions ) ; } return $ existingOptions ; }
2142	private function getSessionBag ( Request $ request ) : SessionBagInterface { if ( ! $ request -> hasSession ( ) || null === ( $ session = $ request -> getSession ( ) ) ) { throw new \ RuntimeException ( 'The request did not contain a session.' ) ; } $ name = 'contao_frontend' ; if ( $ this -> scopeMatcher -> isBackendRequest ( $ request ) ) { $ name = 'contao_backend' ; } return $ session -> getBag ( $ name ) ; }
10220	public static function getConversionGroups ( ) { $ conversionGroups = [ ] ; foreach ( self :: $ conversionUnits as $ conversionUnit ) { $ conversionGroups [ ] = $ conversionUnit [ 'Group' ] ; } return array_merge ( array_unique ( $ conversionGroups ) ) ; }
2434	public function set ( $ strKey , $ varValue ) { if ( \ in_array ( $ strKey , $ this -> mappedKeys ) ) { $ this -> session -> set ( $ strKey , $ varValue ) ; } else { $ this -> sessionBag -> set ( $ strKey , $ varValue ) ; } }
434	private function isIncorrectClassNameOrPrefix ( $ className , $ prefix ) { if ( ! preg_match ( '%^[a-z][a-z0-9\\-_]*$%' , $ className ) ) { return true ; } if ( $ prefix !== '' && ! preg_match ( '%^[a-z0-9_/]+$%i' , $ prefix ) ) { return true ; } return false ; }
8065	protected function getNextFreeWorker ( ) { $ sec = 0 ; while ( TRUE ) { $ this -> collectWorkerResults ( $ sec ) ; $ freeProcess = $ this -> workerProcesses -> takeFreeProcess ( ) ; if ( $ freeProcess !== NULL ) { return $ freeProcess ; } $ sec = $ this -> child_timeout_sec ; if ( $ this -> workerPoolSize <= 0 ) { throw new WorkerPoolException ( 'All workers were gone.' ) ; } } return NULL ; }
6507	public function deserializeReturnValue ( $ type , $ data ) { $ jobType = $ this -> registry -> get ( $ type ) ; return $ this -> serializer -> deserialize ( $ data , $ jobType -> getReturnType ( ) , 'json' , $ this -> getResponseDeserializationContext ( $ jobType ) ) ; }
12259	public function compile ( callable $ validator = NULL ) { if ( ! ( $ project = $ this -> getProject ( ) ) ) { $ project = CC :: get ( $ this -> getConfiguration ( ) , CC :: COMPILER_PROJECT ) ; if ( ! $ project ) throw new CompilerException ( "Compilation without project settings is not possible" ) ; } $ this -> project = $ project ; try { set_error_handler ( function ( $ code , $ msg , $ file , $ line ) { switch ( AbstractErrorHandlerService :: detectErrorLevel ( $ code ) ) { case AbstractErrorHandlerService :: NOTICE_ERROR_LEVEL : return $ this -> getLogger ( ) -> logNotice ( $ msg , [ $ file , $ line ] ) ; case AbstractErrorHandlerService :: DEPRECATED_ERROR_LEVEL : case AbstractErrorHandlerService :: WARNING_ERROR_LEVEL : return $ this -> getLogger ( ) -> logWarning ( $ msg , [ $ file , $ line ] ) ; default : return $ this -> getLogger ( ) -> logError ( $ msg , [ $ file , $ line ] ) ; } } ) ; foreach ( $ this -> getOrganizedCompilers ( ) as $ compiler ) { if ( ! $ validator || $ validator ( $ compiler ) ) $ compiler -> compile ( $ this ) ; } } catch ( Throwable $ throwable ) { $ this -> getLogger ( ) -> logException ( $ throwable ) ; } finally { restore_error_handler ( ) ; } }
2440	public function urlEncode ( ) : string { $ data = json_encode ( $ this ) ; if ( \ function_exists ( 'gzencode' ) && false !== ( $ encoded = @ gzencode ( $ data ) ) ) { $ data = $ encoded ; } return strtr ( base64_encode ( $ data ) , '+/=' , '-_,' ) ; }
2174	private function setUpDatabaseConnection ( ) : Response { $ request = $ this -> container -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; if ( null === $ request ) { throw new \ RuntimeException ( 'The request stack did not contain a request' ) ; } if ( false !== getenv ( 'DATABASE_URL' ) ) { return $ this -> render ( 'misconfigured_database_url.html.twig' ) ; } $ parameters = [ 'parameters' => [ 'database_host' => $ this -> getContainerParameter ( 'database_host' ) , 'database_port' => $ this -> getContainerParameter ( 'database_port' ) , 'database_user' => $ this -> getContainerParameter ( 'database_user' ) , 'database_password' => $ this -> getContainerParameter ( 'database_password' ) , 'database_name' => $ this -> getContainerParameter ( 'database_name' ) , ] , ] ; if ( 'tl_database_login' !== $ request -> request -> get ( 'FORM_SUBMIT' ) ) { return $ this -> render ( 'database.html.twig' , $ parameters ) ; } $ parameters = [ 'parameters' => [ 'database_host' => $ request -> request -> get ( 'dbHost' ) , 'database_port' => $ request -> request -> get ( 'dbPort' ) , 'database_user' => $ request -> request -> get ( 'dbUser' ) , 'database_password' => $ this -> getContainerParameter ( 'database_password' ) , 'database_name' => $ request -> request -> get ( 'dbName' ) , ] , ] ; if ( '*****' !== $ request -> request -> get ( 'dbPassword' ) ) { $ parameters [ 'parameters' ] [ 'database_password' ] = $ request -> request -> get ( 'dbPassword' ) ; } if ( false !== strpos ( $ parameters [ 'parameters' ] [ 'database_name' ] , '.' ) ) { return $ this -> render ( 'database.html.twig' , array_merge ( $ parameters , [ 'database_error' => $ this -> trans ( 'database_dot_in_dbname' ) ] ) ) ; } $ installTool = $ this -> container -> get ( 'contao.install_tool' ) ; $ installTool -> setConnection ( ConnectionFactory :: create ( $ parameters ) ) ; if ( ! $ installTool -> canConnectToDatabase ( $ parameters [ 'parameters' ] [ 'database_name' ] ) ) { return $ this -> render ( 'database.html.twig' , array_merge ( $ parameters , [ 'database_error' => $ this -> trans ( 'database_could_not_connect' ) ] ) ) ; } $ dumper = new ParameterDumper ( $ this -> getContainerParameter ( 'kernel.project_dir' ) ) ; $ dumper -> setParameters ( $ parameters ) ; $ dumper -> dump ( ) ; $ this -> purgeSymfonyCache ( ) ; return $ this -> getRedirectResponse ( ) ; }
7142	private function registerActions ( ContainerBuilder $ container ) { if ( class_exists ( 'Ekyna\Component\Payum\Payzen\PayzenGatewayFactory' ) ) { $ definition = new Definition ( 'Ekyna\Component\Commerce\Bridge\Payum\Payzen\Action\ConvertAction' ) ; $ definition -> addTag ( 'payum.action' , [ 'factory' => 'payzen' , 'prepend' => true ] ) ; $ container -> setDefinition ( 'ekyna_commerce.payum.action.payzen.convert_payment' , $ definition ) ; $ definition = new Definition ( 'Ekyna\Component\Commerce\Bridge\Payum\Payzen\Action\FraudLevelAction' ) ; $ definition -> addTag ( 'payum.action' , [ 'factory' => 'payzen' , 'prepend' => true ] ) ; $ container -> setDefinition ( 'ekyna_commerce.payum.action.payzen.fraud_level' , $ definition ) ; } if ( class_exists ( 'Ekyna\Component\Payum\Sips\SipsGatewayFactory' ) ) { $ definition = new Definition ( 'Ekyna\Component\Commerce\Bridge\Payum\Sips\Action\ConvertAction' ) ; $ definition -> addTag ( 'payum.action' , [ 'factory' => 'atos_sips' , 'prepend' => true ] ) ; $ container -> setDefinition ( 'ekyna_commerce.payum.action.sips.convert_payment' , $ definition ) ; } if ( class_exists ( 'Payum\Paypal\ExpressCheckout\Nvp\PaypalExpressCheckoutGatewayFactory' ) ) { $ definition = new Definition ( 'Ekyna\Component\Commerce\Bridge\Payum\Paypal\Action\EcNvpConvertAction' ) ; $ definition -> setArgument ( 0 , new Reference ( 'ekyna_commerce.common.amount_calculator' ) ) ; if ( $ container -> has ( 'ekyna_setting.manager' ) && class_exists ( 'Ekyna\Bundle\AdminBundle\Settings\GeneralSettingsSchema' ) ) { $ definition -> setArgument ( 1 , new Expression ( "service('ekyna_setting.manager').getParameter('general.site_name')" ) ) ; } $ definition -> addTag ( 'payum.action' , [ 'factory' => 'paypal_express_checkout' , 'prepend' => true ] ) ; $ container -> setDefinition ( 'ekyna_commerce.payum.action.paypal_ec_nvp.convert_payment' , $ definition ) ; } $ actions = [ 'capture_payment' => Action \ CaptureAction :: class , 'notify_payment' => Action \ NotifyAction :: class , 'status_payment' => Action \ StatusAction :: class , ] ; foreach ( $ actions as $ name => $ class ) { $ definition = new Definition ( $ class ) ; $ definition -> addTag ( 'payum.action' , [ 'all' => true , 'prepend' => true ] ) ; $ container -> setDefinition ( 'ekyna_commerce.payum.action.' . $ name , $ definition ) ; } }
3974	protected function build ( IMetaModelDataDefinition $ container ) { $ inputScreen = $ this -> viewCombination -> getScreen ( $ container -> getName ( ) ) ; if ( ! $ inputScreen ) { return ; } $ meta = $ inputScreen [ 'meta' ] ; $ config = $ this -> getDataProviderDefinition ( $ container ) ; if ( ! $ config -> hasInformation ( $ container -> getName ( ) ) ) { $ providerInformation = new ContaoDataProviderInformation ( ) ; $ providerInformation -> setName ( $ container -> getName ( ) ) ; $ config -> addInformation ( $ providerInformation ) ; } else { $ providerInformation = $ config -> getInformation ( $ container -> getName ( ) ) ; } $ basicDefinition = $ container -> getBasicDefinition ( ) ; if ( $ providerInformation instanceof ContaoDataProviderInformation ) { $ providerInformation -> setTableName ( $ container -> getName ( ) ) -> setClassName ( Driver :: class ) -> setInitializationData ( [ 'source' => $ container -> getName ( ) ] ) -> setVersioningEnabled ( false ) ; $ basicDefinition -> setDataProvider ( $ container -> getName ( ) ) ; } if ( $ basicDefinition -> getMode ( ) == BasicDefinitionInterface :: MODE_HIERARCHICAL ) { $ basicDefinition -> setRootDataProvider ( $ container -> getName ( ) ) ; } if ( 'ctable' === $ meta [ 'rendertype' ] ) { $ parentTable = $ meta [ 'ptable' ] ; if ( ! $ config -> hasInformation ( $ parentTable ) ) { $ providerInformation = new ContaoDataProviderInformation ( ) ; $ providerInformation -> setName ( $ parentTable ) ; $ config -> addInformation ( $ providerInformation ) ; } else { $ providerInformation = $ config -> getInformation ( $ parentTable ) ; } if ( $ providerInformation instanceof ContaoDataProviderInformation ) { $ providerInformation -> setTableName ( $ parentTable ) -> setInitializationData ( [ 'source' => $ parentTable ] ) ; if ( in_array ( $ parentTable , $ this -> factory -> collectNames ( ) ) ) { $ providerInformation -> setClassName ( Driver :: class ) ; } $ basicDefinition -> setParentDataProvider ( $ parentTable ) ; } } }
7858	private function registerPipelineRepository ( ) { $ abstract = 'Cerbero\Workflow\Repositories\PipelineRepositoryInterface' ; $ this -> app -> bind ( $ abstract , function ( $ app ) { return new YamlPipelineRepository ( new SymfonyYamlParser , new \ Illuminate \ Filesystem \ Filesystem , config ( 'workflow.path' ) ) ; } ) ; }
9872	private function writeSheetData ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet , array $ pStringTable ) { $ aFlippedStringTable = $ this -> getParentWriter ( ) -> getWriterPart ( 'stringtable' ) -> flipStringTable ( $ pStringTable ) ; $ objWriter -> startElement ( 'sheetData' ) ; $ colCount = Coordinate :: columnIndexFromString ( $ pSheet -> getHighestColumn ( ) ) ; $ highestRow = $ pSheet -> getHighestRow ( ) ; $ cellsByRow = [ ] ; foreach ( $ pSheet -> getCoordinates ( ) as $ coordinate ) { $ cellAddress = Coordinate :: coordinateFromString ( $ coordinate ) ; $ cellsByRow [ $ cellAddress [ 1 ] ] [ ] = $ coordinate ; } $ currentRow = 0 ; while ( $ currentRow ++ < $ highestRow ) { $ rowDimension = $ pSheet -> getRowDimension ( $ currentRow ) ; $ writeCurrentRow = isset ( $ cellsByRow [ $ currentRow ] ) || $ rowDimension -> getRowHeight ( ) >= 0 || $ rowDimension -> getVisible ( ) == false || $ rowDimension -> getCollapsed ( ) == true || $ rowDimension -> getOutlineLevel ( ) > 0 || $ rowDimension -> getXfIndex ( ) !== null ; if ( $ writeCurrentRow ) { $ objWriter -> startElement ( 'row' ) ; $ objWriter -> writeAttribute ( 'r' , $ currentRow ) ; $ objWriter -> writeAttribute ( 'spans' , '1:' . $ colCount ) ; if ( $ rowDimension -> getRowHeight ( ) >= 0 ) { $ objWriter -> writeAttribute ( 'customHeight' , '1' ) ; $ objWriter -> writeAttribute ( 'ht' , StringHelper :: formatNumber ( $ rowDimension -> getRowHeight ( ) ) ) ; } if ( $ rowDimension -> getVisible ( ) == false ) { $ objWriter -> writeAttribute ( 'hidden' , 'true' ) ; } if ( $ rowDimension -> getCollapsed ( ) == true ) { $ objWriter -> writeAttribute ( 'collapsed' , 'true' ) ; } if ( $ rowDimension -> getOutlineLevel ( ) > 0 ) { $ objWriter -> writeAttribute ( 'outlineLevel' , $ rowDimension -> getOutlineLevel ( ) ) ; } if ( $ rowDimension -> getXfIndex ( ) !== null ) { $ objWriter -> writeAttribute ( 's' , $ rowDimension -> getXfIndex ( ) ) ; $ objWriter -> writeAttribute ( 'customFormat' , '1' ) ; } if ( isset ( $ cellsByRow [ $ currentRow ] ) ) { foreach ( $ cellsByRow [ $ currentRow ] as $ cellAddress ) { $ this -> writeCell ( $ objWriter , $ pSheet , $ cellAddress , $ aFlippedStringTable ) ; } } $ objWriter -> endElement ( ) ; } } $ objWriter -> endElement ( ) ; }
2091	public function generate ( ) { if ( TL_MODE == 'BE' ) { $ objTemplate = new BackendTemplate ( 'be_wildcard' ) ; $ objTemplate -> wildcard = '### ' . Utf8 :: strtoupper ( $ GLOBALS [ 'TL_LANG' ] [ 'CTE' ] [ 'form' ] [ 0 ] ) . ' ###' ; $ objTemplate -> id = $ this -> id ; $ objTemplate -> link = $ this -> title ; $ objTemplate -> href = 'contao/main.php?do=form&amp;table=tl_form_field&amp;id=' . $ this -> id ; return $ objTemplate -> parse ( ) ; } if ( $ this -> customTpl != '' && TL_MODE == 'FE' ) { $ this -> strTemplate = $ this -> customTpl ; } return parent :: generate ( ) ; }
7118	protected function getGetAvailableSumBySubjectQuery ( ) { if ( null !== $ this -> getAvailableSumBySubjectQuery ) { return $ this -> getAvailableSumBySubjectQuery ; } $ as = $ this -> getAlias ( ) ; $ qb = $ this -> createFindBySubjectQueryBuilder ( ) ; $ qb -> andWhere ( $ qb -> expr ( ) -> gte ( $ as . '.availableStock' , 0 ) ) -> select ( 'SUM(' . $ as . '.availableStock) as available' ) ; return $ this -> getAvailableSumBySubjectQuery = $ qb -> getQuery ( ) ; }
8999	public function fileExists ( $ fileName ) : bool { if ( ! $ this -> exists ( ) ) { return false ; } $ file = sprintf ( "%s/%s" , $ this -> path , $ fileName ) ; return file_exists ( $ file ) ; }
6666	public function setBodyData ( $ data ) { if ( ! $ data instanceof \ Generator ) { $ this -> body [ static :: DEFAULT_DATA_NAME ] = $ data ; return $ this ; } foreach ( $ data as $ key => $ value ) { $ actualKey = $ key ? : static :: DEFAULT_DATA_NAME ; $ this -> body [ $ actualKey ] = $ value ; } return $ this ; }
11709	public function actionUpdate ( $ id ) { $ user = $ this -> findModel ( $ id ) ; $ user -> scenario = 'update' ; $ profile = $ this -> finder -> findProfileById ( $ id ) ; $ r = \ Yii :: $ app -> request ; $ this -> performAjaxValidation ( [ $ user , $ profile ] ) ; if ( $ user -> load ( $ r -> post ( ) ) && $ profile -> load ( $ r -> post ( ) ) && $ user -> save ( ) && $ profile -> save ( ) ) { \ Yii :: $ app -> getSession ( ) -> setFlash ( 'success' , \ Yii :: t ( 'user' , 'User has been updated' ) ) ; return $ this -> refresh ( ) ; } return $ this -> render ( 'update' , [ 'user' => $ user , 'profile' => $ profile , 'module' => $ this -> module , ] ) ; }
11868	public function destroy ( string $ sessionIdentifier ) : void { if ( ! isset ( self :: $ files [ $ sessionIdentifier ] ) ) { throw new SessionNotFoundException ( ) ; } unset ( self :: $ files [ $ sessionIdentifier ] ) ; }
2164	public static function convertSingleField ( $ table , $ field ) { $ objDatabase = Database :: getInstance ( ) ; $ objRow = $ objDatabase -> query ( "SELECT id, $field FROM $table WHERE $field!=''" ) ; $ objDesc = $ objDatabase -> query ( "DESC $table $field" ) ; if ( $ objDesc -> Type != 'binary(16)' ) { $ objDatabase -> query ( "ALTER TABLE `$table` CHANGE `$field` `$field` binary(16) NULL" ) ; $ objDatabase -> query ( "UPDATE `$table` SET `$field`=NULL WHERE `$field`='' OR `$field`=0" ) ; } while ( $ objRow -> next ( ) ) { $ objHelper = static :: generateHelperObject ( $ objRow -> $ field ) ; if ( $ objHelper -> isUuid ) { continue ; } if ( $ objHelper -> isNumeric ) { $ objFile = FilesModel :: findByPk ( $ objHelper -> value ) ; $ objDatabase -> prepare ( "UPDATE $table SET $field=? WHERE id=?" ) -> execute ( $ objFile -> uuid , $ objRow -> id ) ; } else { $ objFile = FilesModel :: findByPath ( $ objHelper -> value ) ; $ objDatabase -> prepare ( "UPDATE $table SET $field=? WHERE id=?" ) -> execute ( $ objFile -> uuid , $ objRow -> id ) ; } } }
3078	protected function hasChannel ( $ channelName , $ channelType ) { $ channels = $ this -> getOption ( self :: OPTION_CHANNELS ) ; return isset ( $ channels [ $ channelType ] [ $ channelName ] ) ; }
5155	public function setConfiguration ( $ configuration , $ configure = true ) { if ( ! $ configuration instanceof ConfigurationInterface ) { $ configuration = new Configuration ( $ configuration ) ; } unset ( $ this -> configuration ) ; $ this -> configuration = $ configuration ; if ( $ configure ) { $ this -> configure ( ) ; } }
3868	protected function getConfigs ( ) { if ( ! count ( $ this -> configs ) ) { $ statement = $ this -> connection -> query ( 'SELECT * FROM tl_metamodel_searchable_pages' ) ; $ this -> configs = $ statement -> fetchAll ( \ PDO :: FETCH_ASSOC ) ; } return $ this -> configs ; }
9506	public function listLogs ( Request $ request ) { $ this -> authorize ( LogViewerPolicy :: PERMISSION_LIST ) ; $ stats = $ this -> logViewer -> statsTable ( ) ; $ headers = $ stats -> header ( ) ; $ page = $ request -> get ( 'page' , 1 ) ; $ offset = ( $ page * $ this -> perPage ) - $ this -> perPage ; $ rows = new LengthAwarePaginator ( array_slice ( $ stats -> rows ( ) , $ offset , $ this -> perPage , true ) , count ( $ stats -> rows ( ) ) , $ this -> perPage , $ page ) ; $ rows -> setPath ( $ request -> url ( ) ) ; $ this -> setTitle ( $ title = trans ( 'foundation::log-viewer.titles.logs-list' ) ) ; $ this -> addBreadcrumb ( $ title ) ; return $ this -> view ( 'admin.system.log-viewer.list' , compact ( 'headers' , 'rows' , 'footer' ) ) ; }
4629	protected function prepareRequestParameters ( ) { if ( $ this -> command -> hasParameters ( ) ) { $ this -> query = http_build_query ( $ this -> command -> getParameters ( ) , '' , '&' , PHP_QUERY_RFC3986 ) ; } return $ this ; }
7677	function TbsSearchInFiles ( $ files , $ str , $ returnFirstFound = true ) { $ keys_ok = array ( ) ; $ keys_todo = array ( ) ; $ idx_keys = array ( ) ; foreach ( $ files as $ k => $ f ) { $ idx = $ this -> FileGetIdx ( $ f ) ; if ( $ idx !== false ) { $ keys_todo [ $ k ] = $ idx ; $ idx_keys [ $ idx ] = $ k ; } } if ( ( $ this -> TbsCurrIdx !== false ) && isset ( $ idx_keys [ $ this -> TbsCurrIdx ] ) ) { $ key = $ idx_keys [ $ this -> TbsCurrIdx ] ; $ p = strpos ( $ this -> TBS -> Source , $ str ) ; if ( $ p !== false ) { $ keys_ok [ ] = array ( 'key' => $ key , 'idx' => $ this -> TbsCurrIdx , 'src' => & $ this -> TBS -> Source , 'pos' => $ p , 'curr' => true ) ; if ( $ returnFirstFound ) return $ keys_ok [ 0 ] ; } unset ( $ keys_todo [ $ key ] ) ; } foreach ( $ this -> TbsStoreLst as $ idx => $ s ) { if ( ( $ idx !== $ this -> TbsCurrIdx ) && isset ( $ idx_keys [ $ idx ] ) ) { $ key = $ idx_keys [ $ idx ] ; $ p = strpos ( $ s [ 'src' ] , $ str ) ; if ( $ p !== false ) { $ keys_ok [ ] = array ( 'key' => $ key , 'idx' => $ idx , 'src' => & $ s [ 'src' ] , 'pos' => $ p , 'curr' => false ) ; if ( $ returnFirstFound ) return $ keys_ok [ 0 ] ; } unset ( $ keys_todo [ $ key ] ) ; } } foreach ( $ keys_todo as $ key => $ idx ) { $ txt = $ this -> FileRead ( $ idx ) ; $ p = strpos ( $ txt , $ str ) ; if ( $ p !== false ) { $ keys_ok [ ] = array ( 'key' => $ key , 'idx' => $ idx , 'src' => $ txt , 'pos' => $ p , 'curr' => false ) ; if ( $ returnFirstFound ) return $ keys_ok [ 0 ] ; } } if ( $ returnFirstFound ) { return array ( 'key' => false , 'idx' => false , 'src' => false , 'pos' => false , 'curr' => false ) ; } else { return $ keys_ok ; } }
6991	static public function getLocaleWithSuffix ( $ separator = '_' , $ lowercased = false ) : ? string { $ locale = preg_split ( '%[-_]%' , strtolower ( app ( ) -> getLocale ( ) ) ) ; if ( count ( $ locale ) === 2 ) { return $ locale [ 0 ] . $ separator . ( $ lowercased ? $ locale [ 1 ] : strtoupper ( $ locale [ 1 ] ) ) ; } else { $ localeSuffix = isset ( static :: $ localeSuffixMap [ $ locale [ 0 ] ] ) ? static :: $ localeSuffixMap [ $ locale [ 0 ] ] : $ locale [ 0 ] ; return $ locale [ 0 ] . $ separator . ( $ lowercased ? $ localeSuffix : strtoupper ( $ localeSuffix ) ) ; } }
6321	public function addConstraint ( ConstraintInterface $ constraint ) { $ constraint -> setTable ( $ this ) ; $ this -> constraints [ ] = $ constraint ; return $ this ; }
131	protected function updateLocalRepo ( ) { $ fs = new Filesystem ( ) ; $ fs -> ensureDirectoryExists ( $ this -> checkoutDir ) ; if ( ! is_writable ( dirname ( $ this -> checkoutDir ) ) ) { throw new \ RuntimeException ( 'Can not clone ' . $ this -> url . ' to access package information. The "' . $ this -> checkoutDir . '" directory is not writable by the current user.' ) ; } if ( is_file ( $ this -> repoFile ) && is_dir ( $ this -> checkoutDir ) && 0 === $ this -> process -> execute ( 'fossil info' , $ output , $ this -> checkoutDir ) ) { if ( 0 !== $ this -> process -> execute ( 'fossil pull' , $ output , $ this -> checkoutDir ) ) { $ this -> io -> writeError ( '<error>Failed to update ' . $ this -> url . ', package information from this repository may be outdated (' . $ this -> process -> getErrorOutput ( ) . ')</error>' ) ; } } else { $ fs -> removeDirectory ( $ this -> checkoutDir ) ; $ fs -> remove ( $ this -> repoFile ) ; $ fs -> ensureDirectoryExists ( $ this -> checkoutDir ) ; if ( 0 !== $ this -> process -> execute ( sprintf ( 'fossil clone %s %s' , ProcessExecutor :: escape ( $ this -> url ) , ProcessExecutor :: escape ( $ this -> repoFile ) ) , $ output ) ) { $ output = $ this -> process -> getErrorOutput ( ) ; throw new \ RuntimeException ( 'Failed to clone ' . $ this -> url . ' to repository ' . $ this -> repoFile . "\n\n" . $ output ) ; } if ( 0 !== $ this -> process -> execute ( sprintf ( 'fossil open %s --nested' , ProcessExecutor :: escape ( $ this -> repoFile ) ) , $ output , $ this -> checkoutDir ) ) { $ output = $ this -> process -> getErrorOutput ( ) ; throw new \ RuntimeException ( 'Failed to open repository ' . $ this -> repoFile . ' in ' . $ this -> checkoutDir . "\n\n" . $ output ) ; } } }
11977	public function getInterfaceObject ( ) { if ( is_null ( $ this -> _interfaceObject ) ) { $ this -> _interfaceObject = DataInterface :: find ( ) -> where ( [ 'system_id' => $ this -> object -> systemId ] ) -> one ( ) ; if ( empty ( $ this -> _interfaceObject ) ) { $ this -> _interfaceObject = new DataInterface ( ) ; $ this -> _interfaceObject -> name = $ this -> object -> name ; $ this -> _interfaceObject -> system_id = $ this -> object -> systemId ; if ( ! $ this -> _interfaceObject -> save ( ) ) { var_dump ( $ this -> _interfaceObject -> errors ) ; throw new Exception ( "Unable to save interface object!" ) ; } } } return $ this -> _interfaceObject ; }
11635	public function getPageByDeviceId ( array $ deviceIdentifier , $ raw = false ) { $ params = [ 'type' => 1 , 'device_identifier' => $ deviceIdentifier , ] ; $ result = $ this -> parseJSON ( 'json' , [ self :: API_RELATION_SEARCH , $ params ] ) ; if ( $ raw === true ) { return $ result ; } $ page_ids = [ ] ; if ( ! empty ( $ result -> data [ 'relations' ] ) ) { foreach ( $ result -> data [ 'relations' ] as $ item ) { $ page_ids [ ] = $ item [ 'page_id' ] ; } } return $ page_ids ; }
4534	public function setCandidateGroup ( ? string $ candidateGroup ) { $ this -> candidateGroup = $ candidateGroup ; $ this -> _candidateGroup = null !== $ candidateGroup ; return $ this ; }
7401	private function getErrors ( Form $ form ) { $ errors = array ( ) ; if ( $ form -> isSubmitted ( ) && $ form -> isValid ( ) ) { return $ errors ; } $ id = $ form -> createView ( ) -> vars [ 'id' ] ; foreach ( $ form -> getErrors ( ) as $ error ) { if ( ! isset ( $ errors [ $ id ] ) ) { $ errors [ $ id ] = array ( ) ; } $ errors [ $ id ] [ ] = $ error -> getMessage ( ) ; } foreach ( $ form -> all ( ) as $ child ) { $ errors = array_merge ( $ this -> getErrors ( $ child ) , $ errors ) ; } return $ errors ; }
6748	public function handle ( ServerRequestInterface $ request ) { list ( $ httpResponse , $ _ ) = $ this -> requestHandler -> handleServerRequest ( $ request ) ; return $ httpResponse ; }
2621	public function sendValidationRequest ( $ validatedFlag , $ serviceId = null ) { if ( $ serviceId != null ) { $ this -> validationServiceId = $ serviceId ; } if ( $ validatedFlag ) { $ validationState = self :: FASTLY_VALIDATED_FLAG ; } else { $ validationState = self :: FASTLY_NON_VALIDATED_FLAG ; } $ pageViewParams = [ 'dl' => self :: GA_PAGEVIEW_URL . $ validationState , 'dh' => preg_replace ( '#^https?://#' , '' , rtrim ( self :: GA_PAGEVIEW_URL , '/' ) ) , 'dp' => '/' . $ validationState , 'dt' => ucfirst ( $ validationState ) , 't' => self :: GA_HITTYPE_PAGEVIEW , ] ; $ this -> sendReqToGA ( $ pageViewParams ) ; $ eventParams = [ 'ec' => self :: GA_FASTLY_SETUP , 'ea' => 'Fastly ' . $ validationState , 'el' => $ this -> getWebsiteName ( ) , 'ev' => $ this -> daysFromInstallation ( ) , 't' => self :: GA_HITTYPE_EVENT ] ; $ result = $ this -> sendReqToGA ( array_merge ( $ pageViewParams , $ eventParams ) ) ; return $ result ; }
660	public function createCommand ( $ sql = null , $ params = [ ] ) { $ driver = $ this -> getDriverName ( ) ; $ config = [ 'class' => 'yii\db\Command' ] ; if ( $ this -> commandClass !== $ config [ 'class' ] ) { $ config [ 'class' ] = $ this -> commandClass ; } elseif ( isset ( $ this -> commandMap [ $ driver ] ) ) { $ config = ! is_array ( $ this -> commandMap [ $ driver ] ) ? [ 'class' => $ this -> commandMap [ $ driver ] ] : $ this -> commandMap [ $ driver ] ; } $ config [ 'db' ] = $ this ; $ config [ 'sql' ] = $ sql ; $ command = Yii :: createObject ( $ config ) ; return $ command -> bindValues ( $ params ) ; }
840	public function setSize ( $ size ) { if ( $ this -> getSize ( ) !== $ size ) { $ this -> changed = true ; parent :: setSize ( $ size ) ; } }
4861	public function pushLazy ( $ service , $ payload = null , array $ options = [ ] ) { $ manager = $ this -> getJobPluginManager ( ) ; $ serviceOptions = [ ] ; if ( is_array ( $ service ) ) { $ serviceOptions = $ service [ 'options' ] ?? $ service [ 1 ] ?? [ ] ; $ service = $ service [ 'name' ] ?? $ service [ 0 ] ?? null ; } if ( ! $ manager -> has ( $ service ) && ! class_exists ( $ service ) ) { throw new \ UnexpectedValueException ( sprintf ( 'Service name "%s" is not a known job service or existent class' , $ service ) ) ; } $ lazyOptions = [ 'name' => $ service , 'options' => $ serviceOptions , 'content' => $ payload , ] ; $ job = $ this -> getJobPluginManager ( ) -> build ( 'lazy' , $ lazyOptions ) ; $ this -> push ( $ job , $ options ) ; }
9347	public function isDiagonal ( ) { $ int_size = min ( ( array ) $ this -> size ) ; if ( $ int_size > 0 ) { for ( $ i = 0 ; $ i < $ int_size ; $ i ++ ) { $ arr_row = $ this -> getRow ( $ i ) ; if ( $ arr_row [ $ i ] != 0 ) { unset ( $ arr_row [ $ i ] ) ; foreach ( $ arr_row as $ v ) { if ( $ v != 0 ) { return false ; } } } else { return false ; } } return true ; } return false ; }
852	public function getMeaningfulTokenSibling ( $ index , $ direction ) { return $ this -> getTokenNotOfKindSibling ( $ index , $ direction , [ [ T_WHITESPACE ] , [ T_COMMENT ] , [ T_DOC_COMMENT ] ] ) ; }
111	public function addPlugin ( PluginInterface $ plugin ) { $ this -> io -> writeError ( 'Loading plugin ' . get_class ( $ plugin ) , true , IOInterface :: DEBUG ) ; $ this -> plugins [ ] = $ plugin ; $ plugin -> activate ( $ this -> composer , $ this -> io ) ; if ( $ plugin instanceof EventSubscriberInterface ) { $ this -> composer -> getEventDispatcher ( ) -> addSubscriber ( $ plugin ) ; } }
1274	private function createRequestLandedCost ( LandedCostRequest $ landedCostRequest ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; $ tradeabilityRequest = $ xml -> appendChild ( $ xml -> createElement ( 'LandedCostRequest' ) ) ; $ tradeabilityRequest -> setAttribute ( 'xml:lang' , 'en-US' ) ; $ request = $ tradeabilityRequest -> appendChild ( $ xml -> createElement ( 'Request' ) ) ; $ node = $ xml -> importNode ( $ this -> createTransactionNode ( ) , true ) ; $ request -> appendChild ( $ node ) ; $ request -> appendChild ( $ xml -> createElement ( 'RequestAction' , 'LandedCost' ) ) ; if ( $ landedCostRequest -> getQueryRequest ( ) !== null ) { $ tradeabilityRequest -> appendChild ( $ landedCostRequest -> getQueryRequest ( ) -> toNode ( $ xml ) ) ; } return $ xml -> saveXML ( ) ; }
3408	public function getLockFactory ( ) : Factory { if ( $ this -> lockFactory !== null ) { return $ this -> lockFactory ; } if ( ! is_dir ( $ this -> lockPath ) ) { ( new Filesystem ( ) ) -> mkdir ( $ this -> lockPath ) ; } $ store = new FlockStore ( $ this -> lockPath ) ; return $ this -> setLockStore ( $ store ) ; }
6736	public function instantiate ( $ provider ) { if ( ! $ this -> supported ( $ provider ) ) { throw new ProviderNotSupportedException ( $ provider ) ; } $ class = $ this -> providerClass ( $ provider ) ; switch ( $ provider ) { case 'facebook' : return new $ class ( $ this -> config , $ this -> redirector , $ this -> http , $ this -> store , $ this -> profile , $ this -> access_token ) ; break ; case 'twitter' : return new $ class ( $ this -> config , $ this -> http , $ this -> redirector , $ this -> store , $ this -> profile , $ this -> signature , $ this -> consumer , $ this -> token , $ this -> oauth ) ; break ; } }
11245	public function getRan ( ) : array { $ stmt = $ this -> pdo -> query ( "select migration from {$this->table} order by batch, migration" ) ; $ stmt -> execute ( ) ; $ results = $ stmt -> fetchAll ( PDO :: FETCH_COLUMN ) ; return $ results ; }
3947	private function handleNonMetaModelTable ( $ tableName ) { if ( substr ( $ tableName , 0 , 3 ) === 'mm_' ) { return ; } static $ map ; if ( ! isset ( $ map ) ) { $ map = $ this -> buildMap ( ) ; } if ( ! isset ( $ map [ $ tableName ] ) ) { return ; } $ parentDCA = & $ GLOBALS [ 'TL_DCA' ] [ $ tableName ] ; $ this -> controller -> loadLanguageFile ( 'default' ) ; foreach ( $ map [ $ tableName ] as $ metaModelTable => $ inputScreen ) { $ metaModel = $ this -> factory -> getMetaModel ( $ metaModelTable ) ; $ caption = $ this -> buildCaption ( $ metaModel , $ inputScreen ) ; $ operationName = 'edit_' . $ metaModel -> getTableName ( ) ; $ parentDCA [ 'list' ] [ 'operations' ] [ $ operationName ] = array ( 'label' => & $ caption , 'href' => 'table=' . $ metaModelTable , 'icon' => $ this -> iconBuilder -> getBackendIcon ( $ inputScreen [ 'meta' ] [ 'backendicon' ] ) , 'attributes' => 'onclick="Backend.getScrollOffset()"' , ) ; if ( $ metaModel -> hasVariants ( ) ) { $ parentDCA [ 'list' ] [ 'operations' ] [ $ operationName ] [ 'idparam' ] = 'id_' . $ tableName ; } else { $ parentDCA [ 'list' ] [ 'operations' ] [ $ operationName ] [ 'idparam' ] = 'pid' ; } if ( $ parentDCA [ 'config' ] [ 'dataContainer' ] !== 'General' ) { $ idParameter = $ parentDCA [ 'list' ] [ 'operations' ] [ $ operationName ] [ 'idparam' ] ; $ parentDCA [ 'list' ] [ 'operations' ] [ $ operationName ] [ 'button_callback' ] = function ( $ row , $ href , $ label , $ name , $ icon , $ attributes , $ table ) use ( $ idParameter ) { return $ this -> buildChildOperationButton ( $ idParameter , $ row [ 'id' ] , $ href , $ label , $ name , $ icon , $ attributes , $ table ) ; } ; } } }
11081	public static function GUIDv4 ( ) { return sprintf ( '%04x%04x-%04x-%04x-%04x-%04x%04x%04x' , mt_rand ( 0 , 0xffff ) , mt_rand ( 0 , 0xffff ) , mt_rand ( 0 , 0xffff ) , mt_rand ( 0 , 0x0fff ) | 0x4000 , mt_rand ( 0 , 0x3fff ) | 0x8000 , mt_rand ( 0 , 0xffff ) , mt_rand ( 0 , 0xffff ) , mt_rand ( 0 , 0xffff ) ) ; }
6608	public static function getAllProvider ( $ relatedRecords = [ ] , $ sort = [ ] , $ limit = null ) { $ query = self :: find ( ) -> with ( $ relatedRecords ) -> orderBy ( $ sort ) ; return self :: convertToProvider ( $ query , [ ] , $ limit ) ; }
12928	public function update ( $ poiId , array $ data ) { $ data = array_merge ( $ data , [ 'poi_id' => $ poiId ] ) ; $ params = [ 'business' => [ 'base_info' => $ data ] , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_UPDATE , $ params ] ) ; }
5898	public function retrieveVideoTemplate ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/templates/videos/' . $ id . '' , $ parameters , $ cachePolicy ) ; $ result = new VideoTemplate ( $ result ) ; return $ result ; }
4792	function select ( $ columns ) { $ this -> __destruct ( ) ; if ( $ columns != "" ) { foreach ( func_get_args ( ) as $ columns ) { $ this -> select [ ] = $ columns ; } } else { $ this -> select = array ( ) ; } return $ this ; }
8199	public function expect ( $ type , $ value = null , $ message = null ) { $ token = $ this -> tokens [ $ this -> current ] ; if ( ! $ token -> test ( $ type , $ value ) ) { $ line = $ token -> getLine ( ) ; throw new Twig_Error_Syntax ( sprintf ( '%sUnexpected token "%s" of value "%s" ("%s" expected%s).' , $ message ? $ message . '. ' : '' , Twig_Token :: typeToEnglish ( $ token -> getType ( ) ) , $ token -> getValue ( ) , Twig_Token :: typeToEnglish ( $ type ) , $ value ? sprintf ( ' with value "%s"' , $ value ) : '' ) , $ line , $ this -> source ) ; } $ this -> next ( ) ; return $ token ; }
12489	protected static function setPath ( $ writePath ) { if ( is_file ( $ writePath ) ) { self :: $ logFilePath = $ writePath ; return true ; } throw new \ Exception ( 'Impossible de modifier la destination des logs : le fichier ' . $ writePath . ' n\'existe pas.' ) ; return false ; }
2333	public function onKernelRequest ( GetResponseEvent $ event ) : void { if ( ! $ this -> tokenChecker -> hasBackendUser ( ) ) { return ; } $ request = $ event -> getRequest ( ) ; $ request -> attributes -> set ( $ this -> requestAttribute , true ) ; }
1880	protected function isMounted ( $ strFolder ) { if ( $ strFolder == '' ) { return false ; } if ( empty ( $ this -> arrFilemounts ) ) { return true ; } $ path = $ strFolder ; while ( \ is_array ( $ this -> arrFilemounts ) && substr_count ( $ path , '/' ) > 0 ) { if ( \ in_array ( $ path , $ this -> arrFilemounts ) ) { return true ; } $ path = \ dirname ( $ path ) ; } return false ; }
4532	public function setFirstResult ( ? int $ firstResult ) { $ this -> firstResult = $ firstResult ; $ this -> _firstResult = null !== $ firstResult ; return $ this ; }
5074	public function outputSetFormat ( $ sFormat ) { if ( static :: isValidFormat ( $ sFormat ) ) { $ this -> sOutputFormat = strtoupper ( $ sFormat ) ; return true ; } return false ; }
2853	public function purgeAllProfiles ( ) { $ table = Mage :: getResourceModel ( 'sheep_debug/requestInfo' ) -> getMainTable ( ) ; $ deleteSql = "DELETE FROM {$table}" ; $ connection = Mage :: getSingleton ( 'core/resource' ) -> getConnection ( 'core_write' ) ; $ result = $ connection -> query ( $ deleteSql ) ; return $ result -> rowCount ( ) ; }
9161	private function addParsedHeader ( $ line ) { if ( strpos ( $ line , ':' ) === false ) { $ this -> responseCode = HttpStatus :: parseStatus ( $ line ) -> getCode ( ) ; } else { $ line = trim ( $ line ) ; list ( $ headerName , $ headerValue ) = explode ( ':' , $ line , 2 ) ; $ this -> headers [ $ headerName ] = trim ( $ headerValue ) ; } }
9477	protected function getTopDownloads ( $ limit = 20 ) { $ arrTopDownloads = array ( ) ; $ objTopDownloads = \ Database :: getInstance ( ) -> prepare ( "SELECT `tstamp`, `filename`, `downloads`, `id` FROM `tl_dlstats` ORDER BY `downloads` DESC" ) -> limit ( $ limit ) -> execute ( ) ; $ intRows = $ objTopDownloads -> numRows ; if ( $ intRows > 0 ) { while ( $ objTopDownloads -> next ( ) ) { $ c4d = $ this -> check4details ( $ objTopDownloads -> id ) ; $ arrTopDownloads [ ] = array ( $ objTopDownloads -> filename , $ this -> getFormattedNumber ( $ objTopDownloads -> downloads , 0 ) , $ this -> parseDate ( $ GLOBALS [ 'TL_CONFIG' ] [ 'datimFormat' ] , $ objTopDownloads -> tstamp ) , $ objTopDownloads -> id , $ c4d , $ objTopDownloads -> downloads , $ objTopDownloads -> tstamp ) ; } } return $ arrTopDownloads ; }
2781	public function getCommandLine ( ) { if ( $ this -> executeRaw ) { return $ this -> getCommand ( ) ; } $ command = array_merge ( [ $ this -> getCommand ( ) ] , $ this -> buildOptions ( ) , $ this -> args ) ; return array_filter ( $ command , 'strlen' ) ; }
50	protected function pushEvent ( Event $ event ) { $ eventName = $ event -> getName ( ) ; if ( in_array ( $ eventName , $ this -> eventStack ) ) { throw new \ RuntimeException ( sprintf ( "Circular call to script handler '%s' detected" , $ eventName ) ) ; } return array_push ( $ this -> eventStack , $ eventName ) ; }
8536	public function setRentalChargeList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'RentalChargeList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
10021	public function addCellStyleXf ( Style $ pStyle ) { $ this -> cellStyleXfCollection [ ] = $ pStyle ; $ pStyle -> setIndex ( count ( $ this -> cellStyleXfCollection ) - 1 ) ; }
9109	public function getResolverObject ( $ state = null , array $ options = array ( ) ) { if ( $ state == null && isset ( $ this -> resolverObject [ 'last_resolver' ] ) ) { return $ this -> resolverObject [ 'last_resolver' ] ; } if ( $ state != 'resolver_adapter_service' && $ state != 'mvclayout_resolver_adapter' ) throw new \ Exception ( 'Invalid state name provided.' ) ; $ config = $ this -> getConfig ( ) ; if ( isset ( $ config [ 'theme_locator' ] ) ) $ config = $ config [ 'theme_locator' ] ; else $ config = array ( ) ; if ( ! isset ( $ config [ $ state ] ) ) throw new \ Exception ( "Theme Resolver Service not present in config[$state]." ) ; $ config = $ config [ $ state ] ; if ( is_string ( $ config ) ) { $ config = array ( "{$config}" => 1 ) ; } if ( isset ( $ this -> resolverObject [ $ state ] ) ) { $ resolver = $ this -> resolverObject [ $ state ] ; $ this -> resolverObject [ 'last_resolver' ] = $ resolver ; return $ resolver ; } else $ resolver = new Resolvers \ Aggregate ( ) ; foreach ( $ config as $ service => $ priority ) { if ( $ this -> getServiceLocator ( ) -> has ( $ service ) ) { $ service = $ this -> getServiceLocator ( ) -> get ( $ service ) ; } else { if ( ! class_exists ( $ service ) ) throw new \ Exception ( "Resolver '$service' not found for yimaTheme as Service either Class." ) ; $ service = new $ service ( ) ; } if ( $ service instanceof Resolvers \ LocatorResolverAwareInterface ) { $ service -> setThemeLocator ( $ this ) ; } if ( $ service instanceof Resolvers \ ConfigResolverAwareInterface ) { $ service -> setConfig ( $ this -> getConfig ( ) ) ; } if ( isset ( $ options [ 'event_mvc' ] ) ) if ( $ service instanceof Resolvers \ MvcResolverAwareInterface ) $ service -> setMvcEvent ( $ options [ 'event_mvc' ] ) ; $ resolver -> attach ( $ service , $ priority ) ; } $ this -> resolverObject [ $ state ] = $ resolver ; $ this -> resolverObject [ 'last_resolver' ] = $ resolver ; return $ resolver ; }
8767	protected function registerBaseBindings ( ) { static :: setInstance ( $ this ) ; $ this -> instance ( 'app' , $ this ) ; $ this -> instance ( Container :: class , $ this ) ; $ this -> singleton ( 'config' , function ( ) { return new \ Nur \ Config \ Config ( $ this -> config ) ; } ) ; $ this -> singleton ( 'files' , function ( ) { return new Filesystem ; } ) ; $ this -> instance ( PackageManifest :: class , new PackageManifest ( new Filesystem , $ this -> basePath ( ) , $ this -> getCachedPackagesPath ( ) ) ) ; }
10462	public function getTableName ( $ shopId = null ) { $ tableName = parent :: getTableName ( ) ; if ( $ shopId === null ) { $ shopId = $ this -> getActiveShopId ( ) ; } if ( ! $ this -> isShopValid ( $ shopId ) ) { throw new InvalidArgumentException ( "Shop id \"{$shopId}\" is invalid." ) ; } $ tableName .= '_' . $ shopId ; try { SqlValidator :: validateTableName ( $ tableName ) ; } catch ( InvalidArgumentException $ e ) { throw new InvalidArgumentException ( "Shop id \"{$shopId}\" is invalid." , 0 , $ e ) ; } return $ tableName ; }
3656	public function boot ( ) { $ environment = System :: getContainer ( ) -> get ( 'contao.framework' ) -> getAdapter ( Environment :: class ) ; $ script = explode ( '?' , $ environment -> get ( 'relativeRequest' ) , 2 ) [ 0 ] ; if ( ( 'contao/login' === $ script ) || ( 'contao/install' === $ script ) ) { return ; } $ connection = System :: getContainer ( ) -> get ( 'database_connection' ) ; if ( ! $ connection -> getSchemaManager ( ) -> tablesExist ( [ 'tl_metamodel' , 'tl_metamodel_dca' , 'tl_metamodel_dca_sortgroup' , 'tl_metamodel_dcasetting' , 'tl_metamodel_dcasetting_condition' , 'tl_metamodel_attribute' , 'tl_metamodel_filter' , 'tl_metamodel_filtersetting' , 'tl_metamodel_rendersettings' , 'tl_metamodel_rendersetting' , 'tl_metamodel_dca_combine' , ] ) ) { System :: getContainer ( ) -> get ( 'logger' ) -> error ( 'MetaModels startup interrupted. Not all MetaModels tables have been created.' ) ; return ; } $ event = new MetaModelsBootEvent ( ) ; $ this -> tryDispatch ( MetaModelsEvents :: SUBSYSTEM_BOOT , $ event ) ; $ determinator = System :: getContainer ( ) -> get ( 'cca.dc-general.scope-matcher' ) ; switch ( true ) { case $ determinator -> currentScopeIsFrontend ( ) : $ this -> tryDispatch ( MetaModelsEvents :: SUBSYSTEM_BOOT_FRONTEND , $ event ) ; break ; case $ determinator -> currentScopeIsBackend ( ) : $ this -> tryDispatch ( MetaModelsEvents :: SUBSYSTEM_BOOT_BACKEND , $ event ) ; break ; default : } }
1253	private function newPhpObject ( \ stdClass $ meta ) { $ phpTypes = explode ( '|' , $ meta -> phpType ) ; foreach ( $ phpTypes as $ phpType ) { switch ( $ phpType ) { case 'integer' : case 'string' : case 'double' : case 'boolean' : case 'DateTime' : continue ; default : return $ meta -> phpType !== '' ? new $ phpType ( ) : null ; } } return null ; }
269	public function formatMessage ( $ message ) { list ( $ text , $ level , $ category , $ timestamp ) = $ message ; $ level = Logger :: getLevelName ( $ level ) ; if ( ! is_string ( $ text ) ) { if ( $ text instanceof \ Throwable || $ text instanceof \ Exception ) { $ text = ( string ) $ text ; } else { $ text = VarDumper :: export ( $ text ) ; } } $ traces = [ ] ; if ( isset ( $ message [ 4 ] ) ) { foreach ( $ message [ 4 ] as $ trace ) { $ traces [ ] = "in {$trace['file']}:{$trace['line']}" ; } } $ prefix = $ this -> getMessagePrefix ( $ message ) ; return $ this -> getTime ( $ timestamp ) . " {$prefix}[$level][$category] $text" . ( empty ( $ traces ) ? '' : "\n " . implode ( "\n " , $ traces ) ) ; }
9987	private function mapBorderStyle ( $ borderStyle ) { switch ( $ borderStyle ) { case Border :: BORDER_NONE : return 'none' ; case Border :: BORDER_DASHDOT : return '1px dashed' ; case Border :: BORDER_DASHDOTDOT : return '1px dotted' ; case Border :: BORDER_DASHED : return '1px dashed' ; case Border :: BORDER_DOTTED : return '1px dotted' ; case Border :: BORDER_DOUBLE : return '3px double' ; case Border :: BORDER_HAIR : return '1px solid' ; case Border :: BORDER_MEDIUM : return '2px solid' ; case Border :: BORDER_MEDIUMDASHDOT : return '2px dashed' ; case Border :: BORDER_MEDIUMDASHDOTDOT : return '2px dotted' ; case Border :: BORDER_MEDIUMDASHED : return '2px dashed' ; case Border :: BORDER_SLANTDASHDOT : return '2px dashed' ; case Border :: BORDER_THICK : return '3px solid' ; case Border :: BORDER_THIN : return '1px solid' ; default : return '1px solid' ; } }
6810	public function rates ( Adjustment ... $ adjustments ) : string { return implode ( ', ' , array_map ( function ( Adjustment $ adjustment ) { return $ this -> percent ( $ adjustment -> getRate ( ) ) ; } , $ adjustments ) ) ; }
1752	public static function isInstalledLanguage ( $ strLanguage ) { if ( ! isset ( static :: $ arrLanguages [ $ strLanguage ] ) ) { $ rootDir = self :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( is_dir ( $ rootDir . '/vendor/contao/core-bundle/src/Resources/contao/languages/' . $ strLanguage ) ) { static :: $ arrLanguages [ $ strLanguage ] = true ; } elseif ( is_dir ( static :: getContainer ( ) -> getParameter ( 'kernel.cache_dir' ) . '/contao/languages/' . $ strLanguage ) ) { static :: $ arrLanguages [ $ strLanguage ] = true ; } else { $ files = static :: getContainer ( ) -> get ( 'contao.resource_finder' ) -> findIn ( 'languages' ) -> depth ( 0 ) -> directories ( ) -> name ( $ strLanguage ) ; static :: $ arrLanguages [ $ strLanguage ] = \ count ( $ files ) > 0 ; } } return static :: $ arrLanguages [ $ strLanguage ] ; }
12010	public function addLink ( string $ name , string $ link = null , array $ arguments = [ ] ) : Link { $ name = $ this -> translator !== null ? $ this -> translator -> translate ( $ name ) : $ name ; return $ this -> addLinkUntranslated ( $ name , $ link , $ arguments ) ; }
3864	private function setTitleAndDescription ( ) { $ page = $ this -> getPage ( ) ; if ( $ page && $ this -> objItems -> getCount ( ) ) { if ( ! empty ( $ this -> strTitleAttribute ) ) { while ( $ this -> objItems -> next ( ) ) { $ objCurrentItem = $ this -> objItems -> current ( ) ; $ arrTitle = $ objCurrentItem -> parseAttribute ( $ this -> strTitleAttribute , 'text' , $ this -> getView ( ) ) ; if ( ! empty ( $ arrTitle [ 'text' ] ) ) { $ page -> pageTitle = strip_tags ( $ arrTitle [ 'text' ] ) ; break ; } } $ this -> objItems -> reset ( ) ; } if ( ! empty ( $ this -> strDescriptionAttribute ) ) { while ( $ this -> objItems -> next ( ) ) { $ objCurrentItem = $ this -> objItems -> current ( ) ; $ arrDescription = $ objCurrentItem -> parseAttribute ( $ this -> strDescriptionAttribute , 'text' , $ this -> getView ( ) ) ; if ( ! empty ( $ arrDescription [ 'text' ] ) ) { $ page -> description = StringUtil :: substr ( $ arrDescription [ 'text' ] , 160 ) ; break ; } } $ this -> objItems -> reset ( ) ; } } }
9083	private static function parseGetPostSessionCookie ( Request & $ request ) { foreach ( $ _GET as $ name => $ value ) { $ request -> params [ $ name ] = $ value ; } foreach ( $ _POST as $ name => $ value ) { $ request -> params [ $ name ] = $ value ; } foreach ( $ _COOKIE as $ name => $ value ) { $ request -> params [ $ name ] = $ value ; } foreach ( $ _FILES as $ name => $ value ) { $ request -> params [ $ name ] = $ value ; } if ( isset ( $ _SESSION ) ) { foreach ( $ _SESSION as $ name => $ value ) { $ request -> params [ $ name ] = $ value ; } } }
2481	protected function internalFind ( array $ parameters , array $ languageSettings = array ( ) ) { $ searchTargets = $ this -> getSearchTargets ( $ languageSettings ) ; if ( ! empty ( $ searchTargets ) ) { $ parameters [ 'shards' ] = $ searchTargets ; } return $ this -> search ( $ parameters ) ; }
321	public function normalizePathInfo ( $ pathInfo , $ suffix , & $ normalized = false ) { if ( empty ( $ pathInfo ) ) { return $ pathInfo ; } $ sourcePathInfo = $ pathInfo ; if ( $ this -> collapseSlashes ) { $ pathInfo = $ this -> collapseSlashes ( $ pathInfo ) ; } if ( $ this -> normalizeTrailingSlash === true ) { $ pathInfo = $ this -> normalizeTrailingSlash ( $ pathInfo , $ suffix ) ; } $ normalized = $ sourcePathInfo !== $ pathInfo ; return $ pathInfo ; }
3037	public function set ( $ userId , $ callId , $ data ) { $ key = $ this -> getCacheKey ( $ userId , $ callId ) ; $ cache = $ this -> getFromCache ( $ key ) ; if ( is_null ( $ cache ) || $ cache != $ data ) { $ this -> putInCache ( $ key , $ userId , $ callId , $ data , self :: STATE_PENDING_WRITE ) ; } return true ; }
3007	public function setLayout ( $ layout ) { if ( $ layout === "" || $ layout === null ) { $ this -> layout = null ; } else { $ layoutPath = $ this -> templatePath . $ layout ; if ( ! is_file ( $ layoutPath ) ) { throw new \ RuntimeException ( "Layout template `$layout` does not exist" ) ; } $ this -> layout = $ layoutPath ; } }
4269	public function dir_readdir ( ) { if ( ! $ this -> handle ) { return false ; } self :: restorePrev ( ) ; $ success = \ readdir ( $ this -> handle ) ; self :: register ( ) ; return $ success ; }
600	public function andOnCondition ( $ condition , $ params = [ ] ) { if ( $ this -> on === null ) { $ this -> on = $ condition ; } else { $ this -> on = [ 'and' , $ this -> on , $ condition ] ; } $ this -> addParams ( $ params ) ; return $ this ; }
11643	public function getFormatter ( ) { if ( $ this -> _formatter === null ) { $ this -> _formatter = Yii :: $ app -> format ; } return $ this -> _formatter ; }
10404	public function get ( $ key ) { $ pair = $ this -> repository -> find ( $ key ) ; return $ pair ? $ pair -> getValue ( ) : null ; }
12258	public function getOrganizedCompilers ( ) { if ( NULL === $ this -> orderedCompilers ) { $ depCollection = new DependencyCollection ( false ) ; $ depCollection -> setAcceptsDuplicates ( false ) ; foreach ( $ this -> compilers as $ compiler ) { if ( $ compiler instanceof CompilerInterface ) { $ id = $ compiler -> getCompilerID ( ) ; $ deps = $ compiler -> getDependsOnCompilerIDs ( ) ; if ( $ deps ) $ depCollection -> add ( $ id , $ compiler , $ deps ) ; else $ depCollection -> add ( $ id , $ compiler ) ; } elseif ( $ compiler instanceof CompilerFactoryInterface ) { $ compiler -> registerCompilerInstances ( $ depCollection , $ this ) ; } } $ this -> orderedCompilers = $ depCollection -> getOrderedElements ( ) ; } return $ this -> orderedCompilers ; }
2152	public function synchronize ( $ varValue , $ objUser , $ objModule = null ) { if ( $ objUser === null ) { return $ varValue ; } $ blnIsFrontend = true ; if ( $ objUser instanceof DataContainer ) { $ objUser = $ this -> Database -> prepare ( "SELECT * FROM tl_member WHERE id=?" ) -> limit ( 1 ) -> execute ( $ objUser -> id ) ; if ( $ objUser -> numRows < 1 ) { return $ varValue ; } $ blnIsFrontend = false ; } if ( $ varValue == $ objUser -> newsletter || $ objUser -> email == '' ) { return $ varValue ; } $ time = time ( ) ; $ varValue = StringUtil :: deserialize ( $ varValue , true ) ; if ( $ blnIsFrontend && $ objModule instanceof Module ) { $ arrChannel = StringUtil :: deserialize ( $ objModule -> newsletters , true ) ; } else { $ arrChannel = $ this -> Database -> query ( "SELECT id FROM tl_newsletter_channel" ) -> fetchEach ( 'id' ) ; } $ arrDelete = array_values ( array_diff ( $ arrChannel , $ varValue ) ) ; if ( ! empty ( $ arrDelete ) && \ is_array ( $ arrDelete ) ) { $ this -> Database -> prepare ( "DELETE FROM tl_newsletter_recipients WHERE pid IN(" . implode ( ',' , array_map ( '\intval' , $ arrDelete ) ) . ") AND email=?" ) -> execute ( $ objUser -> email ) ; } foreach ( $ varValue as $ intId ) { $ intId = ( int ) $ intId ; if ( $ intId < 1 ) { continue ; } $ objRecipient = $ this -> Database -> prepare ( "SELECT COUNT(*) AS count FROM tl_newsletter_recipients WHERE pid=? AND email=?" ) -> execute ( $ intId , $ objUser -> email ) ; if ( $ objRecipient -> count < 1 ) { $ this -> Database -> prepare ( "INSERT INTO tl_newsletter_recipients SET pid=?, tstamp=$time, email=?, active=?, addedOn=?" ) -> execute ( $ intId , $ objUser -> email , ( $ objUser -> disable ? '' : 1 ) , ( $ blnIsFrontend ? $ time : '' ) ) ; } } return serialize ( $ varValue ) ; }
839	public static function fromCode ( $ code ) { $ codeHash = self :: calculateCodeHash ( $ code ) ; if ( self :: hasCache ( $ codeHash ) ) { $ tokens = self :: getCache ( $ codeHash ) ; $ tokens -> generateCode ( ) ; if ( $ codeHash === $ tokens -> codeHash ) { $ tokens -> clearEmptyTokens ( ) ; $ tokens -> clearChanged ( ) ; return $ tokens ; } } $ tokens = new self ( ) ; $ tokens -> setCode ( $ code ) ; $ tokens -> clearChanged ( ) ; return $ tokens ; }
5213	private function getBinding ( $ type , $ name = null ) { $ binding = $ this -> findBinding ( $ type , $ name ) ; if ( null === $ binding ) { throw new BindingException ( 'No binding for ' . $ type . ' defined' ) ; } return $ binding ; }
5161	public function attach ( string $ field , Model $ item ) : self { $ this -> attachment [ $ field ] [ ] = $ item ; return $ this ; }
4561	public function transfer ( Translatable $ model ) { $ properties = $ this -> getProperties ( $ model ) ; foreach ( $ properties as $ property ) { $ get = 'get' . $ property -> getName ( ) ; $ set = 'set' . $ property -> getName ( ) ; $ values = $ model -> $ get ( ) ; if ( null !== $ values ) { foreach ( $ values as $ locale => $ value ) { $ model -> translate ( $ locale , false ) -> $ set ( $ value ) ; } } } $ model -> mergeNewTranslations ( ) ; }
7423	protected function registerWidget ( $ name = null , $ id = null ) { if ( $ name === null ) { $ name = $ this -> getDefaultJsWidgetName ( ) ; } $ this -> _registerBundle ( ) ; if ( ! $ this -> isAjaxCrud && $ this -> getUpdateUrl ( ) ) { if ( $ id === null ) { $ id = $ this -> options [ 'id' ] ; } $ options = empty ( $ this -> clientOptions ) ? '' : Json :: htmlEncode ( [ 'updateUrl' => Url :: to ( $ this -> getUpdateUrl ( ) ) ] ) ; $ js = "jQuery('#$id').$name($options);" ; $ this -> getView ( ) -> registerJs ( $ js ) ; } }
48	protected function getListeners ( Event $ event ) { $ scriptListeners = $ this -> getScriptListeners ( $ event ) ; if ( ! isset ( $ this -> listeners [ $ event -> getName ( ) ] [ 0 ] ) ) { $ this -> listeners [ $ event -> getName ( ) ] [ 0 ] = array ( ) ; } krsort ( $ this -> listeners [ $ event -> getName ( ) ] ) ; $ listeners = $ this -> listeners ; $ listeners [ $ event -> getName ( ) ] [ 0 ] = array_merge ( $ listeners [ $ event -> getName ( ) ] [ 0 ] , $ scriptListeners ) ; return call_user_func_array ( 'array_merge' , $ listeners [ $ event -> getName ( ) ] ) ; }
1660	public function reply ( $ reply ) { if ( is_string ( $ reply ) ) { $ this -> replies = [ $ reply ] ; } elseif ( is_array ( $ reply ) ) { $ this -> replies = $ reply ; } return $ this ; }
9430	public function getFontIconTag ( ) { if ( $ this -> owner -> hasFontIcon ( ) ) { return $ this -> backend -> getTag ( $ this -> owner -> FontIconClass , $ this -> owner -> FontIconColor ) ; } }
5097	private function appendByField ( $ values ) { $ fixed = array ( ) ; foreach ( $ this -> fields as $ field ) { $ fixed [ ] = $ values [ $ field ] ; } return $ this -> appendByPosition ( $ fixed ) ; }
4062	private static function isEmptyArrayEquivalent ( $ expected , $ actual ) { return ( gettype ( $ expected ) == 'string' ) && ( ( gettype ( $ actual ) == 'array' ) || ( gettype ( $ actual ) == 'NULL' ) ) && empty ( $ actual ) && empty ( $ expected ) ; }
6485	private function isUsingStandardPort ( ) : bool { return $ this -> port === null || ( ( $ this -> scheme === 'http' && $ this -> port === 80 ) || ( $ this -> scheme === 'https' && $ this -> port === 443 ) ) ; }
1339	public function add ( ResourceIdentifierInterface $ identifier , $ record ) { if ( ! is_object ( $ record ) && ! is_bool ( $ record ) ) { throw new InvalidArgumentException ( 'Expecting an object or a boolean to add to the identity map.' ) ; } $ existing = $ this -> lookup ( $ identifier ) ; if ( is_object ( $ existing ) && is_bool ( $ record ) ) { throw new InvalidArgumentException ( 'Attempting to push a boolean into the map in place of an object.' ) ; } $ this -> map [ $ identifier -> toString ( ) ] = $ record ; return $ this ; }
5882	protected static function read_1_byte ( $ handle ) { $ c = fgetc ( $ handle ) ; if ( $ c === false ) { throw new \ RuntimeException ( 'Premature EOF in JPEG file' , 1363533326 ) ; } return ord ( $ c ) ; }
8411	public function disconnect ( ) { if ( isset ( $ this -> servers [ 'all' ] ) === true ) { unset ( $ this -> servers [ 'all' ] [ 'link' ] ) ; } else { unset ( $ this -> servers [ 'read' ] [ 'link' ] ) ; unset ( $ this -> servers [ 'write' ] [ 'link' ] ) ; } }
11924	public function onPermalinkChanged ( PermalinkChangedEvent $ event ) { $ previousPermalink = $ event -> getOriginalText ( ) ; $ newPermalink = $ event -> getChangedText ( ) ; $ this -> updatePermalinkOnBlocks ( $ previousPermalink , $ newPermalink ) ; $ this -> updateHomepagePermalink ( $ previousPermalink , $ newPermalink ) ; }
7510	function addError ( $ error ) { $ this -> errors [ ] = htmlentities ( $ error . ' at ' . ( $ this -> line_pos [ 0 ] + 1 ) . ', ' . ( $ this -> pos - $ this -> line_pos [ 1 ] + 1 ) . '!' ) ; }
7561	protected function parse_sibling ( ) { if ( ( ( $ this -> pos + 1 ) < $ this -> size ) && ( $ this -> doc [ $ this -> pos + 1 ] === '=' ) ) { ++ $ this -> pos ; return ( $ this -> token = self :: TOK_COMPARE_CONTAINS_WORD ) ; } else { return ( $ this -> token = self :: TOK_SIBLING ) ; } }
10869	public function getByEmail ( string $ email ) { return $ this -> getList ( ) -> where ( [ $ this -> tableName [ 0 ] . '.email' => $ email , $ this -> tableName [ 0 ] . '.active' => true ] ) -> fetch ( ) ; }
7572	public function post ( Array $ postVars , Array $ headers , $ url = null ) { try { $ this -> guzzleResponse = $ this -> _client -> request ( 'POST' , $ url , array ( 'multipart' => $ postVars , 'headers' => $ headers ) ) ; } catch ( RequestException $ e ) { throw new GreenhouseAPIResponseException ( $ e -> getMessage ( ) , 0 , $ e ) ; } return ( string ) $ this -> guzzleResponse -> getBody ( ) ; }
4155	protected function buildRequestHeader ( ) { $ bearerToken = $ this -> bearerToken ; if ( $ this -> bearerToken === null ) { $ bearerToken = $ this -> getBearerToken ( ) ; } return array ( 'Authorization: Bearer ' . rawurlencode ( $ bearerToken ) , 'Expect:' ) ; }
596	public function actionCheckGuide ( $ directory = null ) { if ( $ directory === null ) { $ directory = \ dirname ( \ dirname ( __DIR__ ) ) . '/docs' ; } if ( is_file ( $ directory ) ) { $ files = [ $ directory ] ; } else { $ files = FileHelper :: findFiles ( $ directory , [ 'only' => [ '*.md' ] , ] ) ; } foreach ( $ files as $ file ) { $ content = file_get_contents ( $ file ) ; $ chars = preg_split ( '//u' , $ content , null , PREG_SPLIT_NO_EMPTY ) ; $ line = 1 ; $ pos = 0 ; foreach ( $ chars as $ c ) { $ ord = $ this -> unicodeOrd ( $ c ) ; $ pos ++ ; if ( $ ord == 0x000A ) { $ line ++ ; $ pos = 0 ; } if ( $ ord === false ) { $ this -> found ( 'BROKEN UTF8' , $ c , $ line , $ pos , $ file ) ; continue ; } if ( 0x2000 <= $ ord && $ ord <= 0x200F || 0x2028 <= $ ord && $ ord <= 0x202E || 0x205f <= $ ord && $ ord <= 0x206F ) { $ this -> found ( 'UNSUPPORTED SPACE CHARACTER' , $ c , $ line , $ pos , $ file ) ; continue ; } if ( $ ord < 0x0020 && $ ord != 0x000A && $ ord != 0x0009 || 0x0080 <= $ ord && $ ord < 0x009F ) { $ this -> found ( 'CONTROL CHARARCTER' , $ c , $ line , $ pos , $ file ) ; continue ; } } } }
907	private function findClassyElements ( $ index ) { $ elements = [ ] ; $ curlyBracesLevel = 0 ; $ bracesLevel = 0 ; $ classIndex = $ index ; ++ $ index ; for ( $ count = \ count ( $ this -> tokens ) ; $ index < $ count ; ++ $ index ) { $ token = $ this -> tokens [ $ index ] ; if ( $ token -> isGivenKind ( T_ENCAPSED_AND_WHITESPACE ) ) { continue ; } if ( $ token -> isClassy ( ) ) { list ( $ index , $ newElements ) = $ this -> findClassyElements ( $ index ) ; $ elements += $ newElements ; continue ; } if ( $ token -> equals ( '(' ) ) { ++ $ bracesLevel ; continue ; } if ( $ token -> equals ( ')' ) ) { -- $ bracesLevel ; continue ; } if ( $ token -> equals ( '{' ) ) { ++ $ curlyBracesLevel ; continue ; } if ( $ token -> equals ( '}' ) ) { -- $ curlyBracesLevel ; if ( 0 === $ curlyBracesLevel ) { break ; } continue ; } if ( 1 !== $ curlyBracesLevel || ! $ token -> isArray ( ) ) { continue ; } if ( 0 === $ bracesLevel && $ token -> isGivenKind ( T_VARIABLE ) ) { $ elements [ $ index ] = [ 'token' => $ token , 'type' => 'property' , 'classIndex' => $ classIndex , ] ; continue ; } if ( $ token -> isGivenKind ( T_FUNCTION ) ) { $ elements [ $ index ] = [ 'token' => $ token , 'type' => 'method' , 'classIndex' => $ classIndex , ] ; } elseif ( $ token -> isGivenKind ( T_CONST ) ) { $ elements [ $ index ] = [ 'token' => $ token , 'type' => 'const' , 'classIndex' => $ classIndex , ] ; } } return [ $ index , $ elements ] ; }
9979	public function writeComments ( \ PhpOffice \ PhpSpreadsheet \ Worksheet \ Worksheet $ pWorksheet ) { $ objWriter = null ; if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' , 'yes' ) ; $ comments = $ pWorksheet -> getComments ( ) ; $ authors = [ ] ; $ authorId = 0 ; foreach ( $ comments as $ comment ) { if ( ! isset ( $ authors [ $ comment -> getAuthor ( ) ] ) ) { $ authors [ $ comment -> getAuthor ( ) ] = $ authorId ++ ; } } $ objWriter -> startElement ( 'comments' ) ; $ objWriter -> writeAttribute ( 'xmlns' , 'http://schemas.openxmlformats.org/spreadsheetml/2006/main' ) ; $ objWriter -> startElement ( 'authors' ) ; foreach ( $ authors as $ author => $ index ) { $ objWriter -> writeElement ( 'author' , $ author ) ; } $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'commentList' ) ; foreach ( $ comments as $ key => $ value ) { $ this -> writeComment ( $ objWriter , $ key , $ value , $ authors ) ; } $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
6078	public function createComment ( $ mediaId , Comment $ comment ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'comment' => $ comment ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/media/' . $ mediaId . '/comments' , $ parameters ) ; $ result = new CommentResponse ( $ result ) ; return $ result ; }
11045	function read_content ( ) { if ( $ this -> external_source_read ) { $ fct = $ this -> source_read_name ; return $ fct ( $ this -> container ) ; } else { $ content = FALSE ; if ( $ handle = @ fopen ( $ this -> container , 'rb' ) ) { $ size = @ filesize ( $ this -> container ) ; $ content = @ fread ( $ handle , $ size ) ; fclose ( $ handle ) ; } return $ content ; } }
7856	private function publishConfig ( ) { $ config = __DIR__ . '/config/workflow.php' ; $ this -> publishes ( [ $ config => config_path ( 'workflow.php' ) ] ) ; $ this -> mergeConfigFrom ( $ config , 'workflow' ) ; }
5689	public function getFormById ( $ id ) { for ( $ i = 0 ; $ i < count ( $ this -> forms ) ; $ i ++ ) { if ( $ this -> forms [ $ i ] -> getId ( ) == $ id ) { return $ this -> forms [ $ i ] ; } } return ; }
8795	public function view ( $ name , array $ data = [ ] ) { $ file = app_path ( 'Views' . DIRECTORY_SEPARATOR . $ name . '.php' ) ; if ( file_exists ( $ file ) ) { extract ( $ data ) ; require $ file ; return ob_get_clean ( ) ; } throw new ExceptionHandler ( 'Oppss! File not found.' , 'View::' . $ name . ' not found.' ) ; }
253	protected function freeze ( ) { if ( $ this -> getIsActive ( ) ) { if ( isset ( $ _SESSION ) ) { $ this -> frozenSessionData = $ _SESSION ; } $ this -> close ( ) ; Yii :: info ( 'Session frozen' , __METHOD__ ) ; } }
11693	public function run ( ) : Robo \ Result { $ result = $ this -> collectionBuilder ( ) -> taskFilesystemStack ( ) -> mkdir ( $ this -> destination -> getPath ( ) ) -> touch ( $ this -> destination -> getPathname ( ) ) -> run ( ) -> wasSuccessful ( ) ; if ( ! $ result ) { throw new RuntimeException ( 'We can not write to the destination file: ' . $ this -> destination -> getPathname ( ) ) ; } $ asset_contents = '' ; foreach ( $ this -> source as $ file ) { $ this -> printTaskInfo ( 'Compiling - <info>' . $ file . '</info>' ) ; $ asset_contents .= $ this -> getCompiler ( new SplFileInfo ( $ file ) ) -> compile ( ) ; } if ( $ this -> cachebust === true ) { $ this -> bustCacheBalls ( $ asset_contents ) ; } $ this -> writeAsset ( $ asset_contents ) ; return \ Robo \ Result :: success ( $ this ) ; }
11414	public function decryptData ( $ sessionKey , $ iv , $ encrypted ) { try { $ decrypted = openssl_decrypt ( base64_decode ( $ encrypted , true ) , 'aes-128-cbc' , base64_decode ( $ sessionKey , true ) , OPENSSL_RAW_DATA | OPENSSL_NO_PADDING , base64_decode ( $ iv , true ) ) ; } catch ( Exception $ e ) { throw new EncryptionException ( $ e -> getMessage ( ) , EncryptionException :: ERROR_DECRYPT_AES ) ; } if ( is_null ( $ result = json_decode ( $ this -> decode ( $ decrypted ) , true ) ) ) { throw new EncryptionException ( 'ILLEGAL_BUFFER' , EncryptionException :: ILLEGAL_BUFFER ) ; } return $ result ; }
12575	public function previewByName ( $ msgType , $ message , $ to ) { return $ this -> preview ( $ msgType , $ message , $ to , self :: PREVIEW_BY_NAME ) ; }
11105	public function join ( $ table , $ type = null ) { $ this -> join -> addJoin ( $ table , $ type ) ; return $ this ; }
12498	public static function insertOne ( $ document , $ connection ) { $ connection -> query = self :: singleDocument ( $ document ) ; return self :: insert ( $ connection ) ; }
6466	private static function createDefaultBoundary ( ) : string { try { $ string = random_bytes ( 16 ) ; $ string [ 6 ] = chr ( ord ( $ string [ 6 ] ) & 0x0f | 0x40 ) ; $ string [ 8 ] = chr ( ord ( $ string [ 8 ] ) & 0x3f | 0x80 ) ; return vsprintf ( '%s%s-%s-%s-%s-%s%s%s' , str_split ( bin2hex ( $ string ) , 4 ) ) ; } catch ( Exception $ ex ) { throw new RuntimeException ( 'Failed to generate random bytes' , 0 , $ ex ) ; } }
4000	protected function loadMetaModel ( $ nameOrId ) { if ( is_numeric ( $ nameOrId ) ) { $ tableName = $ this -> getServiceContainer ( ) -> getFactory ( ) -> translateIdToMetaModelName ( $ nameOrId ) ; } elseif ( is_string ( $ nameOrId ) ) { $ tableName = $ nameOrId ; } if ( isset ( $ tableName ) ) { return $ this -> getServiceContainer ( ) -> getFactory ( ) -> getMetaModel ( $ tableName ) ; } return null ; }
10310	function getUniqueOpensCount ( $ fromDate = null , $ toDate = null , $ mailingIds = null , $ contactIds = null , $ contactEmails = null , $ contactExternalIds = null , $ excludeAnonymousOpens = false ) { $ params = $ this -> createCountQueryParameters ( $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , $ mailingIds , null ) ; if ( isset ( $ excludeAnonymousOpens ) ) $ params [ 'exclude_anonymous_opens' ] = ( $ excludeAnonymousOpens == true ) ? "true" : "false" ; return $ this -> get ( 'reports/opens/unique/count' , $ params ) ; }
11493	public function removeAll ( ) : array { $ res = [ ] ; foreach ( $ this -> getKeys ( ) as $ key ) { $ res [ $ key ] = $ this -> remove ( $ key ) ; } return $ res ; }
10573	protected function registerSessionHandler ( ) { if ( $ this -> handler !== null ) { if ( ! is_object ( $ this -> handler ) ) { $ this -> handler = Yii :: createObject ( $ this -> handler ) ; } if ( ! $ this -> handler instanceof \ SessionHandlerInterface ) { throw new InvalidConfigException ( '"' . get_class ( $ this ) . '::handler" must implement the SessionHandlerInterface.' ) ; } @ session_set_save_handler ( $ this -> handler , false ) ; } elseif ( $ this -> getUseCustomStorage ( ) ) { @ session_set_save_handler ( [ $ this , 'openSession' ] , [ $ this , 'closeSession' ] , [ $ this , 'readSession' ] , [ $ this , 'writeSession' ] , [ $ this , 'destroySession' ] , [ $ this , 'gcSession' ] ) ; } }
1061	public static function findValuesAddedToEnums ( Schema $ oldSchema , Schema $ newSchema ) { $ oldTypeMap = $ oldSchema -> getTypeMap ( ) ; $ newTypeMap = $ newSchema -> getTypeMap ( ) ; $ valuesAddedToEnums = [ ] ; foreach ( $ oldTypeMap as $ typeName => $ oldType ) { $ newType = $ newTypeMap [ $ typeName ] ?? null ; if ( ! ( $ oldType instanceof EnumType ) || ! ( $ newType instanceof EnumType ) ) { continue ; } $ valuesInOldEnum = [ ] ; foreach ( $ oldType -> getValues ( ) as $ value ) { $ valuesInOldEnum [ $ value -> name ] = true ; } foreach ( $ newType -> getValues ( ) as $ value ) { if ( isset ( $ valuesInOldEnum [ $ value -> name ] ) ) { continue ; } $ valuesAddedToEnums [ ] = [ 'type' => self :: DANGEROUS_CHANGE_VALUE_ADDED_TO_ENUM , 'description' => sprintf ( '%s was added to enum type %s.' , $ value -> name , $ typeName ) , ] ; } } return $ valuesAddedToEnums ; }
5008	public function trigger ( $ event , $ target = null ) { if ( empty ( $ this -> _template ) || ! is_string ( $ this -> _template ) ) { throw new \ InvalidArgumentException ( 'ContentCollector must have a template-name' ) ; } $ responseCollection = $ this -> getController ( ) -> getEventManager ( ) -> trigger ( $ event , $ target ) ; $ viewModel = new ViewModel ( ) ; $ viewModel -> setTemplate ( $ this -> _template ) ; foreach ( $ responseCollection as $ i => $ response ) { if ( is_string ( $ response ) ) { $ template = $ response ; $ response = new ViewModel ( array ( 'target' => $ target ) ) ; $ response -> setTemplate ( $ template ) ; } $ viewModel -> addChild ( $ response , $ this -> _captureTo . $ i ) ; } return $ viewModel ; }
10116	private function writeHcenter ( ) { $ record = 0x0083 ; $ length = 0x0002 ; $ fHCenter = $ this -> phpSheet -> getPageSetup ( ) -> getHorizontalCentered ( ) ? 1 : 0 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ fHCenter ) ; $ this -> append ( $ header . $ data ) ; }
7243	public function description ( ) { $ default = Inform_About_Content :: default_opt_in ( NULL ) ; $ subscribed_by_default = apply_filters ( 'iac_default_opt_in' , $ default ) ; $ description = $ subscribed_by_default ? __ ( 'Note: Users must opt-out from e-mail notifications by default' , Inform_About_Content :: TEXTDOMAIN ) : __ ( 'Note: Users must opt-in to e-mail notifications by default' , Inform_About_Content :: TEXTDOMAIN ) ; printf ( '<p class="description">%s</p>' , $ description ) ; }
340	public function field ( $ model , $ attribute , $ options = [ ] ) { $ config = $ this -> fieldConfig ; if ( $ config instanceof \ Closure ) { $ config = call_user_func ( $ config , $ model , $ attribute ) ; } if ( ! isset ( $ config [ 'class' ] ) ) { $ config [ 'class' ] = $ this -> fieldClass ; } return Yii :: createObject ( ArrayHelper :: merge ( $ config , $ options , [ 'model' => $ model , 'attribute' => $ attribute , 'form' => $ this , ] ) ) ; }
6061	public function listDeploymentSites ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/media/' . $ id . '/deployment/sites' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new DeploymentSiteResponse ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
5563	protected function load ( $ url , $ parameters ) { $ frame = $ url -> getTarget ( ) ; if ( ! $ frame || ! $ this -> page -> hasFrames ( ) || ( strtolower ( $ frame ) == '_top' ) ) { return $ this -> loadPage ( $ url , $ parameters ) ; } return $ this -> loadFrame ( array ( $ frame ) , $ url , $ parameters ) ; }
1157	protected function ruleConfirmed ( $ attribute , array $ parameters ) { $ parameters [ 0 ] = $ this -> getAttributeName ( $ attribute ) ; $ attribute = "{$attribute}_confirmation" ; return [ $ attribute , $ parameters ] ; }
4547	public function check ( $ alias = null ) { if ( null === $ alias ) { $ statuses = new Statuses ; $ statuses -> setHealthy ( true ) ; foreach ( $ this -> checkCollection as $ check ) { $ status = $ check -> execute ( ) ; $ statuses -> getCollection ( ) -> add ( $ status ) ; if ( ! $ status -> getHealthy ( ) ) { $ statuses -> setHealthy ( false ) ; } } return $ statuses ; } else { $ check = $ this -> checkCollection -> filter ( function ( $ element ) use ( $ alias ) { return $ element -> getAlias ( ) === $ alias ; } ) -> first ( ) ; if ( ! $ check ) { throw new InvalidAliasException ( 'Check alias does not exist.' ) ; } $ status = $ check -> execute ( ) ; return $ status ; } }
1619	public function buildAll ( $ query ) { $ modelClass = $ query -> modelClass ; $ key = $ this -> quoteValue ( $ modelClass :: keyPrefix ( ) . ':a:' ) ; return $ this -> build ( $ query , "n=n+1 pks[n]=redis.call('HGETALL',$key .. pk)" , 'pks' ) ; }
7047	protected function buildAddressData ( Common \ AddressInterface $ address , string $ locale ) { $ country = Intl :: getRegionBundle ( ) -> getCountryName ( $ address -> getCountry ( ) -> getCode ( ) , $ locale ) ; $ fullName = trim ( $ address -> getFirstName ( ) . ' ' . $ address -> getLastName ( ) ) ; $ data = [ 'company' => $ address -> getCompany ( ) , 'full_name' => $ fullName , 'street' => $ address -> getStreet ( ) , 'complement' => $ address -> getComplement ( ) , 'supplement' => $ address -> getSupplement ( ) , 'postal_code' => $ address -> getPostalCode ( ) , 'city' => $ address -> getCity ( ) , 'country' => $ country , 'state' => '' , 'phone' => $ this -> formatPhoneNumber ( $ address -> getPhone ( ) ) , 'mobile' => $ this -> formatPhoneNumber ( $ address -> getMobile ( ) ) , ] ; if ( $ address instanceof RelayPointInterface ) { $ data [ 'number' ] = $ address -> getNumber ( ) ; } return $ data ; }
7912	protected function renderToggleButton ( ) { if ( $ this -> toggleButton !== false ) { $ tag = ArrayHelper :: remove ( $ this -> toggleButton , 'tag' , 'div' ) ; $ label = ArrayHelper :: remove ( $ this -> toggleButton , 'label' , 'Show' ) ; if ( $ tag === 'button' && ! isset ( $ this -> toggleButton [ 'type' ] ) ) { $ this -> toggleButton [ 'type' ] = 'button' ; } if ( $ tag === 'div' ) { Html :: addCssClass ( $ this -> toggleButton , 'ui' ) ; Html :: addCssClass ( $ this -> toggleButton , 'button' ) ; } $ view = $ this -> getView ( ) ; DosAmigosAsset :: register ( $ view ) ; $ view -> registerJs ( 'dosamigos.semantic.init();' ) ; return Html :: tag ( $ tag , $ label , $ this -> toggleButton ) ; } else { return null ; } }
9164	protected function parseNode ( RuleCollection $ collection , \ DOMElement $ node , $ path , $ file ) { if ( self :: NAMESPACE_URI !== $ node -> namespaceURI ) { return ; } switch ( $ node -> localName ) { case 'rule' : $ this -> parseRule ( $ collection , $ node , $ path ) ; break ; case 'import' : $ this -> parseImport ( $ collection , $ node , $ path , $ file ) ; break ; default : throw new \ InvalidArgumentException ( sprintf ( 'Unknown tag "%s" used in file "%s". Expected "rule" or "import".' , $ node -> localName , $ path ) ) ; } }
8034	private function buildAttributesFromLdap ( $ entry ) { $ this -> attributes [ 'dn' ] = $ entry [ 'dn' ] ; foreach ( $ entry as $ index => $ key ) { if ( array_key_exists ( $ index , config ( 'ldap.search_fields' ) ) ) { $ this -> attributes [ $ key ] = isset ( $ entry [ $ key ] [ 1 ] ) ? $ entry [ $ key ] : $ entry [ $ key ] [ 0 ] ; } } ; }
346	private static function mergeCssClasses ( array $ existingClasses , array $ additionalClasses ) { foreach ( $ additionalClasses as $ key => $ class ) { if ( is_int ( $ key ) && ! in_array ( $ class , $ existingClasses ) ) { $ existingClasses [ ] = $ class ; } elseif ( ! isset ( $ existingClasses [ $ key ] ) ) { $ existingClasses [ $ key ] = $ class ; } } return array_unique ( $ existingClasses ) ; }
9583	public function addCachedRoute ( Route $ route ) { $ this -> routes -> attach ( $ route ) ; if ( $ name = $ route -> getName ( ) ) { $ this -> addNamedRoute ( $ name , $ route ) ; } }
2041	public static function symlink ( string $ target , string $ link , string $ rootDir ) : void { static :: validateSymlink ( $ target , $ link , $ rootDir ) ; $ fs = new Filesystem ( ) ; if ( ! $ fs -> isAbsolutePath ( $ target ) ) { $ target = $ rootDir . '/' . $ target ; } if ( ! $ fs -> isAbsolutePath ( $ link ) ) { $ link = $ rootDir . '/' . $ link ; } if ( '\\' === \ DIRECTORY_SEPARATOR ) { $ fs -> symlink ( $ target , $ link ) ; } else { $ fs -> symlink ( rtrim ( $ fs -> makePathRelative ( $ target , \ dirname ( $ link ) ) , '/' ) , $ link ) ; } }
2358	public function getBackendUsername ( ) : ? string { $ token = $ this -> getToken ( BackendUser :: SECURITY_SESSION_KEY ) ; if ( null === $ token || ! $ token -> getUser ( ) instanceof BackendUser ) { return null ; } return $ token -> getUser ( ) -> getUsername ( ) ; }
5549	public function getBaseUrl ( ) { if ( is_integer ( $ this -> focus ) ) { $ url = $ this -> frames [ $ this -> focus ] -> getBaseUrl ( ) ; } else { $ url = $ this -> frameset -> getBaseUrl ( ) ; } return $ url ; }
6563	public function carrier_data ( $ carrier = '' , $ field_output = '' ) { $ inputParams = array ( 'carrier' => $ carrier , 'field_output' => $ field_output ) ; $ field_output = strtolower ( $ field_output ) ; $ this -> debug -> info ( __FUNCTION__ , 'Input Params: ' , $ inputParams ) ; try { $ vnCarrierData = DataRepository :: getData ( 'vn_carrier_data' ) ; $ this -> debug -> debug ( __FUNCTION__ , 'VN Carrier All Data: ' , $ vnCarrierData ) ; if ( array_key_exists ( $ carrier , $ vnCarrierData ) ) { $ isCarrier = $ vnCarrierData [ $ carrier ] ; $ this -> debug -> debug ( __FUNCTION__ , 'Is Carrier Data: ' , $ isCarrier ) ; if ( array_key_exists ( $ field_output , $ isCarrier ) ) { $ result = $ isCarrier [ $ field_output ] ; $ this -> debug -> info ( __FUNCTION__ , 'Final Result get Field : ' . $ field_output , $ result ) ; return $ result ; } if ( $ field_output = 'full' ) { $ this -> debug -> info ( __FUNCTION__ , 'Final Result get Field : ' . $ field_output , $ isCarrier ) ; return $ isCarrier ; } } } catch ( \ Exception $ e ) { $ message = 'Error File: ' . $ e -> getFile ( ) . ' - Line: ' . $ e -> getLine ( ) . ' - Code: ' . $ e -> getCode ( ) . ' - Message: ' . $ e -> getMessage ( ) ; $ this -> debug -> error ( __FUNCTION__ , $ message ) ; return NULL ; } return NULL ; }
428	public function init ( ) { if ( $ this -> controllerNamespace === null ) { $ class = get_class ( $ this ) ; if ( ( $ pos = strrpos ( $ class , '\\' ) ) !== false ) { $ this -> controllerNamespace = substr ( $ class , 0 , $ pos ) . '\\controllers' ; } } }
2570	protected static function loadNonceBase ( $ handlerParams ) { if ( empty ( $ handlerParams -> authParams -> nonceBase ) ) { $ handlerParams -> authParams -> nonceBase = SomewhatRandomGenerator :: generateSomewhatRandomString ( ) ; } return $ handlerParams ; }
8179	public function login ( ) { return $ this -> validate ( ) ? Yii :: $ app -> user -> login ( $ this -> getUser ( ) , $ this -> rememberMe ? UserModule :: $ rememberMeDuration : 0 ) : FALSE ; }
1841	public static function parse ( $ file ) { if ( ! file_exists ( $ file ) ) { throw new \ InvalidArgumentException ( 'Invalid file ' . $ file ) ; } $ table = '' ; $ return = array ( ) ; $ data = file ( $ file ) ; foreach ( $ data as $ k => $ v ) { $ key_name = array ( ) ; $ subpatterns = array ( ) ; if ( preg_match ( '/^[#-]+/' , $ v ) || ! \ strlen ( trim ( $ v ) ) ) { unset ( $ data [ $ k ] ) ; continue ; } if ( preg_match ( '/^CREATE TABLE `([^`]+)`/i' , $ v , $ subpatterns ) ) { $ table = $ subpatterns [ 1 ] ; } elseif ( $ table != '' && preg_match ( '/^\)([^;]+);/' , $ v , $ subpatterns ) ) { $ return [ $ table ] [ 'TABLE_OPTIONS' ] = $ subpatterns [ 1 ] ; $ table = '' ; } elseif ( $ table != '' ) { preg_match ( '/^[^`]*`([^`]+)`/' , trim ( $ v ) , $ key_name ) ; $ first = preg_replace ( '/\s[^\n\r]+/' , '' , $ key_name [ 0 ] ) ; $ key = $ key_name [ 1 ] ; if ( \ in_array ( $ first , array ( 'KEY' , 'PRIMARY' , 'PRIMARY KEY' , 'FOREIGN' , 'FOREIGN KEY' , 'INDEX' , 'UNIQUE' , 'FULLTEXT' , 'CHECK' ) ) ) { if ( strncmp ( $ first , 'PRIMARY' , 7 ) === 0 ) { $ key = 'PRIMARY' ; } $ return [ $ table ] [ 'TABLE_CREATE_DEFINITIONS' ] [ $ key ] = preg_replace ( '/,$/' , '' , trim ( $ v ) ) ; } else { $ return [ $ table ] [ 'TABLE_FIELDS' ] [ $ key ] = preg_replace ( '/,$/' , '' , trim ( $ v ) ) ; } } } foreach ( array_keys ( $ return ) as $ table ) { if ( ! isset ( $ return [ $ table ] [ 'TABLE_CREATE_DEFINITIONS' ] [ 'PRIMARY' ] ) ) { unset ( $ return [ $ table ] [ 'TABLE_OPTIONS' ] ) ; } } return $ return ; }
580	public static function current ( array $ params = [ ] , $ scheme = false ) { $ currentParams = Yii :: $ app -> getRequest ( ) -> getQueryParams ( ) ; $ currentParams [ 0 ] = '/' . Yii :: $ app -> controller -> getRoute ( ) ; $ route = array_replace_recursive ( $ currentParams , $ params ) ; return static :: toRoute ( $ route , $ scheme ) ; }
6682	private function setSecurityHeaders ( ) { $ headers = Yii :: $ app -> response -> headers ; $ headers -> add ( 'X-Frame-Options' , 'DENY' ) ; $ headers -> add ( 'X-XSS-Protection' , '1' ) ; }
12662	protected function contributorDefined ( ) { if ( null === $ this -> username && ! $ this -> configurationHandler -> isTheme ( ) ) { $ exception = array ( "message" => 'exception_contributor_not_defined' , "show_exception" => true , ) ; throw new LogicException ( json_encode ( $ exception ) ) ; } }
8465	public static function getUriMethods ( ) { $ root = str_replace ( $ _SERVER [ 'DOCUMENT_ROOT' ] , '' , getcwd ( ) ) ; $ subfolder = trim ( $ root , '/' ) ; return trim ( str_replace ( $ subfolder , '' , self :: getUri ( ) ) , '/' ) ; }
9762	function empty ( ) : self { if ( is_object ( $ this -> target ) && ! ( $ this -> target instanceof \ Countable ) ) { $ constraint = countOf ( 0 ) ; $ target = get_object_vars ( $ this -> target ) ; } else if ( is_string ( $ this -> target ) ) { $ constraint = equalTo ( 0 ) ; $ target = $ this -> hasFlag ( 'file' ) ? @ filesize ( $ this -> target ) : mb_strlen ( $ this -> target ) ; } else { $ constraint = isEmpty ( ) ; $ target = $ this -> target ; } return $ this -> expect ( $ target , $ constraint ) ; }
6923	private function buildKey ( TaxGroupInterface $ taxGroup , CountryInterface $ country , $ business = false ) { return sprintf ( '%s-%s-%s' , $ taxGroup -> getId ( ) , $ country -> getId ( ) , ( int ) $ business ) ; }
8583	public function getLowestOfferListingsForSKU ( $ request ) { if ( ! ( $ request instanceof MarketplaceWebServiceProducts_Model_GetLowestOfferListingsForSKURequest ) ) { $ request = new MarketplaceWebServiceProducts_Model_GetLowestOfferListingsForSKURequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetLowestOfferListingsForSKU' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = MarketplaceWebServiceProducts_Model_GetLowestOfferListingsForSKUResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
5053	public function setResponse ( Response $ response ) { $ this -> setParam ( 'response' , $ response ) ; $ this -> response = $ response ; return $ this ; }
10435	public function post ( $ request ) { if ( $ request instanceof Request ) { $ request = $ request -> xml ( ) ; } $ ch = curl_init ( ) ; curl_setopt ( $ ch , CURLOPT_URL , $ this -> url ) ; if ( $ this -> user_agent != null ) { curl_setopt ( $ ch , CURLOPT_USERAGENT , $ this -> user_agent ) ; } curl_setopt ( $ ch , CURLOPT_HEADER , 0 ) ; curl_setopt ( $ ch , CURLOPT_RETURNTRANSFER , 1 ) ; curl_setopt ( $ ch , CURLOPT_POST , 1 ) ; curl_setopt ( $ ch , CURLOPT_POSTFIELDS , $ request ) ; curl_setopt ( $ ch , CURLOPT_HTTPHEADER , array ( 'Content-type: application/xml; charset=utf-8' , ) ) ; $ response = curl_exec ( $ ch ) ; curl_close ( $ ch ) ; if ( empty ( $ response ) ) { return null ; } return $ response ; }
8548	public function setServiceProviderCreditEventList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ServiceProviderCreditEventList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
6737	public function uninstallation ( ) { $ this -> model -> delete_post_meta ( ) ; $ this -> model -> delete_options ( ) ; $ this -> model -> remove_tables ( ) ; }
932	public function clearChanged ( ) { @ trigger_error ( __METHOD__ . ' is deprecated and will be removed in 3.0.' , E_USER_DEPRECATED ) ; Tokens :: setLegacyMode ( true ) ; $ this -> changed = false ; }
3187	public function end ( $ tags , $ timestamp ) { if ( ! is_numeric ( $ timestamp ) || $ timestamp < 0 ) { throw new InvalidDataException ( 'end() needs a valid timestamp!' ) ; } $ range = $ this -> getRange ( $ tags ) ; if ( $ this -> isRangeOpen ( $ range ) ) { $ this -> checkTimestampCoherence ( $ range , $ timestamp ) ; $ point = new TimePoint ( $ tags , $ timestamp , TimePoint :: TYPE_END , TimePoint :: TARGET_SERVER ) ; $ this -> timeLine -> add ( $ point ) ; } else { \ common_Logger :: t ( 'Range already closed, or missing START TimePoint in QtiTimer, continue anyway' ) ; } return $ this ; }
2560	private function checkAndCreateMopDetailedData ( $ fopType ) { if ( is_null ( $ this -> paymentModule -> mopDetailedData ) ) { $ this -> paymentModule -> mopDetailedData = new MopDetailedData ( $ fopType ) ; } }
6272	public static function open ( $ fileName ) { return self :: haveExtension ( ) ? new Reader \ DBA ( $ fileName ) : new Reader \ PHP ( $ fileName ) ; }
2507	protected static function loopOperationsWithQuery ( $ operations , $ query , $ wsdlIdentifier , $ domXpath ) { $ msgAndVer = [ ] ; foreach ( $ operations as $ operation ) { if ( ! empty ( $ operation -> value ) ) { $ fullVersion = $ domXpath -> evaluate ( sprintf ( $ query , $ operation -> value ) ) ; if ( ! empty ( $ fullVersion ) ) { $ extractedVersion = self :: extractMessageVersion ( $ fullVersion ) ; $ msgAndVer [ $ operation -> value ] = [ 'version' => $ extractedVersion , 'wsdl' => $ wsdlIdentifier ] ; } } } return $ msgAndVer ; }
3847	protected static function upgradeClosed ( ) { $ objDB = self :: DB ( ) ; if ( $ objDB -> tableExists ( 'tl_metamodel_dca' , null , true ) && ! $ objDB -> fieldExists ( 'iseditable' , 'tl_metamodel_dca' ) ) { TableManipulation :: createColumn ( 'tl_metamodel_dca' , 'iseditable' , 'char(1) NOT NULL default \'\'' ) ; TableManipulation :: createColumn ( 'tl_metamodel_dca' , 'iscreatable' , 'char(1) NOT NULL default \'\'' ) ; TableManipulation :: createColumn ( 'tl_metamodel_dca' , 'isdeleteable' , 'char(1) NOT NULL default \'\'' ) ; $ objDB -> execute ( ' UPDATE tl_metamodel_dca SET iseditable=isclosed^1, iscreatable=isclosed^1, isdeleteable=isclosed^1 ' ) ; TableManipulation :: dropColumn ( 'tl_metamodel_dca' , 'isclosed' , true ) ; } }
394	public static function updateAll ( $ attributes , $ condition = '' , $ params = [ ] ) { $ command = static :: getDb ( ) -> createCommand ( ) ; $ command -> update ( static :: tableName ( ) , $ attributes , $ condition , $ params ) ; return $ command -> execute ( ) ; }
8872	private function buildAttachmentPart ( ) { if ( count ( $ this -> attachments ) > 0 ) { $ attachment_part = '' ; foreach ( $ this -> attachments as $ attachment ) { $ file_str = chunk_split ( base64_encode ( file_get_contents ( $ attachment ) ) ) ; $ attachment_part .= "--MIME_BOUNDRY\nContent-Type: " . $ this -> getMimeType ( $ attachment ) . "; name=" . basename ( $ attachment ) . "\nContent-disposition: attachment\nContent-Transfer-Encoding: base64\n\n{$file_str}\n\n" ; } return $ attachment_part ; } }
11948	public function getSignature ( $ baseString , array $ params ) { unset ( $ params [ 'oauth_signature' ] ) ; if ( $ this -> signature_method === 'HMAC-SHA1' ) { $ result = $ this -> sign_HMAC_SHA1 ( $ baseString ) ; } else if ( $ this -> signature_method == 'RSA-SHA1' ) { $ result = $ this -> sign_RSA_SHA1 ( $ baseString ) ; } else if ( $ this -> signature_method == 'PLAINTEXT' ) { $ result = $ this -> sign_PLAINTEXT ( $ baseString ) ; } else { throw new ArtaxServiceException ( 'Unknown signature method: ' . $ this -> signature_method ) ; } return base64_encode ( $ result ) ; }
11614	public function update ( $ account , $ nickname ) { $ params = [ 'kf_account' => $ account , 'nickname' => $ nickname , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_UPDATE , $ params ] ) ; }
12802	public function getPage ( $ page = null ) { if ( is_null ( $ page ) ) { $ page = $ this -> page ; } list ( $ offset , $ size ) = $ this -> getLimts ( $ page ) ; $ this -> manager -> limit ( $ offset , $ size ) ; return $ this -> manager -> values ( ) ; }
2786	public static function mutates ( array & $ tokens , $ index ) { $ t = $ tokens [ $ index ] ; if ( ! is_array ( $ t ) && $ t == '+' ) { $ tokenCount = count ( $ tokens ) ; for ( $ i = $ index + 1 ; $ i < $ tokenCount ; $ i ++ ) { if ( ! is_array ( $ tokens [ $ i ] ) && $ tokens [ $ i ] [ 0 ] == '[' ) { return false ; } if ( is_array ( $ tokens [ $ i ] ) && $ tokens [ $ i ] [ 0 ] == T_ARRAY && $ tokens [ $ i ] [ 1 ] == 'array' ) { return false ; } if ( ! is_array ( $ tokens [ $ i ] ) && $ tokens [ $ i ] == ';' ) { return true ; } } return true ; } return false ; }
7633	public function putBlock ( $ containerName = '' , $ blobName = '' , $ identifier = '' , $ contents = '' , $ leaseId = null ) { Assertion :: notEmpty ( $ containerName , 'Container name is not specified' ) ; self :: assertValidContainerName ( $ containerName ) ; Assertion :: notEmpty ( $ blobName , 'Blob name is not specified.' ) ; Assertion :: notEmpty ( $ identifier , 'Block identifier is not specified.' ) ; self :: assertValidRootContainerBlobName ( $ containerName , $ blobName ) ; if ( strlen ( $ contents ) > self :: MAX_BLOB_TRANSFER_SIZE ) { throw new BlobException ( 'Block size is too big.' ) ; } $ headers = array ( ) ; if ( ! is_null ( $ leaseId ) ) { $ headers [ 'x-ms-lease-id' ] = $ leaseId ; } $ resourceName = self :: createResourceName ( $ containerName , $ blobName ) ; $ response = $ this -> performRequest ( $ resourceName , array ( 'comp' => 'block' , 'blockid' => base64_encode ( $ identifier ) ) , 'PUT' , $ headers , false , $ contents , self :: RESOURCE_BLOB , self :: PERMISSION_WRITE ) ; if ( ! $ response -> isSuccessful ( ) ) { throw new BlobException ( $ this -> getErrorMessage ( $ response , 'Resource could not be accessed.' ) ) ; } }
3726	public static function createFromQueryBuilder ( QueryBuilder $ builder , $ columnName = 'id' ) { return new self ( $ builder -> getSQL ( ) , $ builder -> getParameters ( ) , $ columnName , $ builder -> getConnection ( ) , $ builder -> getParameterTypes ( ) ) ; }
1999	private function getAcceptedLocales ( ) : array { $ accepted = [ ] ; $ locales = [ ] ; preg_match_all ( '/([a-z]{1,8}(-[a-z]{1,8})?)\s*(;\s*q\s*=\s*(1|0\.\d+))?/i' , $ this -> requestStack -> getCurrentRequest ( ) -> headers -> get ( 'accept-language' ) , $ accepted ) ; foreach ( $ accepted [ 1 ] as $ v ) { $ chunks = explode ( '-' , $ v ) ; if ( isset ( $ chunks [ 1 ] ) ) { $ locale = $ chunks [ 0 ] . '-' . strtoupper ( $ chunks [ 1 ] ) ; if ( preg_match ( '/^[a-z]{2}(\-[A-Z]{2})?$/' , $ locale ) ) { $ locales [ ] = $ locale ; } } if ( preg_match ( '/^[a-z]{2}$/' , $ chunks [ 0 ] ) ) { $ locales [ ] = $ chunks [ 0 ] ; } } return \ array_slice ( array_unique ( $ locales ) , 0 , 8 ) ; }
1323	private function encodeAppAuthorization ( Consumer $ consumer ) { $ key = rawurlencode ( $ consumer -> key ) ; $ secret = rawurlencode ( $ consumer -> secret ) ; return base64_encode ( $ key . ':' . $ secret ) ; }
4207	private function getPropCommentInfo ( \ ReflectionProperty $ reflectionProperty ) { $ name = $ reflectionProperty -> name ; $ phpDoc = $ this -> phpDoc -> getParsed ( $ reflectionProperty ) ; $ info = array ( 'type' => null , 'desc' => $ phpDoc [ 'summary' ] ? $ phpDoc [ 'summary' ] : null , ) ; if ( isset ( $ phpDoc [ 'var' ] ) ) { if ( \ count ( $ phpDoc [ 'var' ] ) == 1 ) { $ var = $ phpDoc [ 'var' ] [ 0 ] ; } else { foreach ( $ phpDoc [ 'var' ] as $ var ) { if ( $ var [ 'name' ] == $ name ) { break ; } } } $ info [ 'type' ] = $ var [ 'type' ] ; if ( ! $ info [ 'desc' ] ) { $ info [ 'desc' ] = $ var [ 'desc' ] ; } elseif ( $ var [ 'desc' ] ) { $ info [ 'desc' ] = $ info [ 'desc' ] . ': ' . $ var [ 'desc' ] ; } } return $ info ; }
4317	private static function getMethodDefaultArgs ( $ methodName ) { $ defaultArgs = array ( ) ; if ( isset ( self :: $ methodDefaultArgs [ $ methodName ] ) ) { $ defaultArgs = self :: $ methodDefaultArgs [ $ methodName ] ; } elseif ( \ method_exists ( self :: $ instance , $ methodName ) ) { $ reflectionMethod = new ReflectionMethod ( self :: $ instance , $ methodName ) ; $ params = $ reflectionMethod -> getParameters ( ) ; foreach ( $ params as $ reflectionParameter ) { $ defaultArgs [ ] = $ reflectionParameter -> isOptional ( ) ? $ reflectionParameter -> getDefaultValue ( ) : null ; } self :: $ methodDefaultArgs [ $ methodName ] = $ defaultArgs ; } return $ defaultArgs ; }
3250	public function scopeWhereCurrent ( $ query ) { if ( Auth :: guest ( ) ) return $ query ; return $ query -> whereUser ( Auth :: user ( ) -> shopId ) ; }
2989	public function setLogger ( LoggerInterface $ logger ) { if ( $ this -> transport instanceof LoggerAwareInterface ) { $ this -> transport -> setLogger ( $ logger ) ; } }
7783	public function registerTimezoneScript ( $ actionRoute ) { Yii :: $ app -> on ( Controller :: EVENT_BEFORE_ACTION , function ( $ event ) use ( $ actionRoute ) { $ view = $ event -> sender -> view ; $ js = <<<JS var timezone = ''; var timezoneAbbr = ''; try { var timezone = Intl.DateTimeFormat().resolvedOptions().timeZone; var timezoneAbbr = /\((.*)\)/.exec(new Date().toString())[1]; } catch(err) { console.log(err); } $.post("$actionRoute", { timezone: timezone, timezoneAbbr: timezoneAbbr, timezoneOffset: -new Date().getTimezoneOffset() / 60 });JS ; $ view -> registerJs ( $ js ) ; } ) ; }
6212	protected function array2Node ( $ parentNode , $ key , $ params ) { if ( count ( $ params ) == 0 ) { return ; } $ node = $ parentNode -> addChild ( $ key ) ; foreach ( $ params as $ key => $ value ) { if ( is_array ( $ value ) || is_object ( $ value ) ) { $ value = json_encode ( ( array ) $ value ) ; } $ node -> addChild ( 'var' , htmlspecialchars ( $ value ) ) -> addAttribute ( 'key' , $ key ) ; } }
2923	public function lines ( ) { $ content = [ ] ; $ lines = $ this -> readLinesFromFile ( ) ; foreach ( $ lines as $ row => $ line ) { $ data = [ 'line' => $ row + 1 , 'raw_data' => $ line , 'parsed_data' => $ this -> formatter -> parseLine ( $ line ) ] ; $ content [ ] = $ data ; } return $ content ; }
6928	private function persistInvoice ( Invoice \ InvoiceInterface $ invoice ) { $ this -> persistenceHelper -> persistAndRecompute ( $ invoice , true ) ; foreach ( $ invoice -> getLines ( ) as $ line ) { $ this -> persistenceHelper -> persistAndRecompute ( $ line , true ) ; } $ this -> persistenceHelper -> persistAndRecompute ( $ invoice -> getShipment ( ) , false ) ; }
2435	public function remove ( $ strKey ) { if ( \ in_array ( $ strKey , $ this -> mappedKeys ) ) { $ this -> session -> remove ( $ strKey ) ; } else { $ this -> sessionBag -> remove ( $ strKey ) ; } }
2140	private function fetchHttpHeaders ( ) : void { $ this -> headers = array_merge ( $ this -> headers , $ this -> headerStorage -> all ( ) ) ; $ this -> headerStorage -> clear ( ) ; }
9960	public function setAutoFilterByColumnAndRow ( $ columnIndex1 , $ row1 , $ columnIndex2 , $ row2 ) { return $ this -> setAutoFilter ( Coordinate :: stringFromColumnIndex ( $ columnIndex1 ) . $ row1 . ':' . Coordinate :: stringFromColumnIndex ( $ columnIndex2 ) . $ row2 ) ; }
10982	public static function getMemInfo ( ) { $ result = [ ] ; if ( $ n = preg_match_all ( '/^([\S]+):\s+(\d+)\skB$/im' , file_get_contents ( '/proc/meminfo' ) , $ matches ) ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ result [ $ matches [ 1 ] [ $ i ] ] = $ matches [ 2 ] [ $ i ] ; } } return $ result ; }
5566	public function get ( $ url , $ parameters = false ) { if ( ! is_object ( $ url ) ) { $ url = new SimpleUrl ( $ url ) ; } if ( $ this -> getUrl ( ) ) { $ url = $ url -> makeAbsolute ( $ this -> getUrl ( ) ) ; } return $ this -> load ( $ url , new SimpleGetEncoding ( $ parameters ) ) ; }
511	protected function formatOptionHelp ( $ name , $ required , $ type , $ defaultValue , $ comment ) { $ comment = trim ( $ comment ) ; $ type = trim ( $ type ) ; if ( strncmp ( $ type , 'bool' , 4 ) === 0 ) { $ type = 'boolean, 0 or 1' ; } if ( $ defaultValue !== null && ! is_array ( $ defaultValue ) ) { if ( $ type === null ) { $ type = gettype ( $ defaultValue ) ; } if ( is_bool ( $ defaultValue ) ) { $ defaultValue = ( int ) $ defaultValue ; } if ( is_string ( $ defaultValue ) ) { $ defaultValue = "'" . $ defaultValue . "'" ; } else { $ defaultValue = var_export ( $ defaultValue , true ) ; } $ doc = "$type (defaults to $defaultValue)" ; } else { $ doc = $ type ; } if ( $ doc === '' ) { $ doc = $ comment ; } elseif ( $ comment !== '' ) { $ doc .= "\n" . preg_replace ( '/^/m' , ' ' , $ comment ) ; } $ name = $ required ? "$name (required)" : $ name ; return $ doc === '' ? $ name : "$name: $doc" ; }
4117	public function isWithinCachedBlock ( Mage_Core_Block_Abstract $ block ) { $ step = $ block ; $ i = 0 ; while ( $ i ++ < 20 && $ step instanceof Mage_Core_Block_Abstract ) { if ( ! is_null ( $ step -> getCacheLifetime ( ) ) ) { return true ; } $ step = $ step -> getParentBlock ( ) ; } return false ; }
2181	private function filterNestedPaths ( Finder $ finder , string $ prepend ) : array { $ parents = [ ] ; $ files = iterator_to_array ( $ finder ) ; foreach ( $ files as $ key => $ file ) { $ path = rtrim ( strtr ( $ prepend . '/' . $ file -> getRelativePath ( ) , '\\' , '/' ) , '/' ) ; if ( ! empty ( $ parents ) ) { $ parent = \ dirname ( $ path ) ; while ( false !== strpos ( $ parent , '/' ) ) { if ( \ in_array ( $ parent , $ parents , true ) ) { $ this -> rows [ ] = [ sprintf ( '<fg=yellow;options=bold>%s</>' , '\\' === \ DIRECTORY_SEPARATOR ? 'WARNING' : '!' ) , $ this -> webDir . '/' . $ path , sprintf ( '<comment>Skipped because %s will be symlinked.</comment>' , $ parent ) , ] ; unset ( $ files [ $ key ] ) ; break ; } $ parent = \ dirname ( $ parent ) ; } } $ parents [ ] = $ path ; } return array_values ( $ files ) ; }
4044	private function removeInvariantAttributes ( IItem $ nativeItem , ICollection $ renderSetting ) { $ model = $ nativeItem -> getMetaModel ( ) ; if ( $ model -> hasVariants ( ) && ! $ nativeItem -> isVariantBase ( ) ) { $ renderSetting = clone $ renderSetting ; foreach ( array_keys ( $ model -> getInVariantAttributes ( ) ) as $ strAttrName ) { $ renderSetting -> setSetting ( $ strAttrName , null ) ; } } return $ renderSetting ; }
10316	function getBouncesCount ( $ fromDate = null , $ toDate = null , $ mailingIds = null , $ contactIds = null , $ contactEmails = null , $ contactExternalIds = null , $ statusCodeFilter = null , $ typeFilter = null , $ sourceFilter = null , $ excludeAnonymousBounces = false ) { $ params = $ this -> createCountQueryParameters ( $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , $ mailingIds , null ) ; if ( isset ( $ excludeAnonymousBounces ) ) $ params [ 'exclude_anonymous_bounces' ] = ( $ excludeAnonymousBounces == true ) ? "true" : "false" ; if ( isset ( $ typeFilter ) ) $ params [ 'type' ] = $ typeFilter ; if ( isset ( $ sourceFilter ) ) $ params [ 'source_filter' ] = $ sourceFilter ; return $ this -> get ( 'reports/bounces/count' , $ params ) ; }
2772	public function init ( array $ options = [ ] ) : string { $ argsAndOptions = [ $ this -> directory , $ options ] ; return $ this -> run ( 'init' , $ argsAndOptions , false ) ; }
3489	private function createTemporaryFile ( ) : string { $ tmpDir = $ this -> tmpDir ; $ tmpFileName = md5 ( uniqid ( ( string ) mt_rand ( ) , true ) ) . '.p8' ; $ tmpFilePath = $ tmpDir . '/' . $ tmpFileName ; $ errorCode = $ errorMessage = null ; set_error_handler ( function ( $ errCode , $ errMessage ) use ( & $ errorCode , & $ errorMessage ) { $ errorCode = $ errCode ; $ errorMessage = $ errMessage ; } ) ; if ( ! file_exists ( $ tmpDir ) ) { mkdir ( $ tmpDir , 0600 , true ) ; if ( $ errorCode || $ errorMessage ) { restore_error_handler ( ) ; throw new \ RuntimeException ( sprintf ( 'Can not create temporary directory "%s". Error: %s [%d].' , $ tmpDir , $ errorMessage ? : 'Undefined' , $ errorCode ? : '0' ) ) ; } } touch ( $ tmpFilePath ) ; if ( $ errorCode || $ errorMessage ) { restore_error_handler ( ) ; throw new \ RuntimeException ( sprintf ( 'Can not create temporary certificate file "%s". Error: %s [%d].' , $ tmpFilePath , $ errorMessage ? : 'Undefined' , $ errorCode ? : '0' ) ) ; } restore_error_handler ( ) ; return $ tmpFilePath ; }
3401	public function getValue ( ApistMethod $ method , Crawler $ rootNode = null ) { if ( is_null ( $ rootNode ) ) { $ rootNode = $ method -> getCrawler ( ) ; } $ result = $ rootNode -> filter ( $ this -> selector ) ; return $ this -> applyResultCallbackChain ( $ result , $ method ) ; }
10366	public function logout ( ) { $ this -> bus -> pipeThrough ( $ this -> pipesOf ( 'logout' ) ) -> dispatchNow ( new LogoutJob ) ; return redirect ( ) -> route ( config ( '_auth.logout.redirect' ) ) ; }
3293	public function linkedin ( $ summary = '' ) { $ base = config ( 'laravel-share.services.linkedin.uri' ) ; $ mini = config ( 'laravel-share.services.linkedin.extra.mini' ) ; $ url = $ base . '?mini=' . $ mini . '&url=' . $ this -> url . '&title=' . urlencode ( $ this -> title ) . '&summary=' . urlencode ( $ summary ) ; $ this -> buildLink ( 'linkedin' , $ url ) ; return $ this ; }
2121	public static function getActive ( ) { @ trigger_error ( 'Using ModuleLoader::getActive() has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; $ bundles = array_keys ( System :: getContainer ( ) -> getParameter ( 'kernel.bundles' ) ) ; foreach ( static :: $ legacy as $ bundleName => $ module ) { if ( \ in_array ( $ bundleName , $ bundles ) ) { $ bundles [ ] = $ module ; } } return $ bundles ; }
4564	public function kernelException ( GetResponseForExceptionEvent $ event ) { $ exception = $ event -> getException ( ) ; if ( ! $ exception instanceof NoPermissionsException ) { return ; } $ response = new JsonResponse ( [ ] ) ; $ event -> setResponse ( $ response ) ; }
7737	private function getAnnotation ( Reflector $ element , $ annotation ) { if ( $ element instanceof ReflectionClass ) { return $ this -> reader -> getClassAnnotation ( $ element , $ annotation ) ; } elseif ( $ element instanceof ReflectionMethod ) { return $ this -> reader -> getMethodAnnotation ( $ element , $ annotation ) ; } elseif ( $ element instanceof ReflectionProperty ) { return $ this -> reader -> getPropertyAnnotation ( $ element , $ annotation ) ; } return null ; }
5055	protected function getEntityClassName ( $ name ) { $ repositoryName = str_replace ( 'Repository/' , '' , $ name ) ; $ nameParts = explode ( '/' , $ repositoryName ) ; $ namespace = $ nameParts [ 0 ] ; $ entity = isset ( $ nameParts [ 1 ] ) ? $ nameParts [ 1 ] : substr ( $ namespace , 0 , - 1 ) ; $ class = "\\$namespace\\Entity\\$entity" ; return $ class ; }
4064	private static function calculateDiff ( $ expected , $ actual , $ strict ) { if ( $ expected === $ actual ) { return ; } if ( gettype ( $ expected ) !== gettype ( $ actual ) ) { if ( ! $ strict && self :: isEmptyArrayEquivalent ( $ expected , $ actual ) ) { return ; } throw new \ LogicException ( sprintf ( 'Encountered type %s expected %s (Found %s, expected %s)' , gettype ( $ actual ) , gettype ( $ expected ) , var_export ( $ actual , true ) , var_export ( $ expected , true ) ) , self :: TYPE_MISMATCH ) ; } if ( is_array ( $ expected ) ) { self :: calculateArrayDiff ( $ expected , $ actual , $ strict ) ; } throw new \ LogicException ( sprintf ( 'Found %s expected %s' , var_export ( $ actual , true ) , var_export ( $ expected , true ) ) , self :: VALUE_MISMATCH ) ; }
4225	public function onShutdown ( Event $ event ) { if ( ! $ this -> registered ) { return ; } $ error = $ event [ 'error' ] ? : \ error_get_last ( ) ; if ( ! $ error ) { return ; } if ( \ in_array ( $ error [ 'type' ] , $ this -> errCategories [ 'fatal' ] ) ) { \ error_reporting ( E_ALL | E_STRICT ) ; $ this -> handleError ( $ error [ 'type' ] , $ error [ 'message' ] , $ error [ 'file' ] , $ error [ 'line' ] ) ; } foreach ( $ this -> data [ 'errors' ] as $ error ) { if ( $ error [ 'category' ] === 'fatal' ) { $ event [ 'error' ] = $ error ; break ; } } return ; }
8358	public static function niceUrl ( string $ url ) { $ nice = null ; if ( ( $ pos = stripos ( $ url , '.' ) ) !== false ) { list ( $ subDomain , $ url ) = explode ( '.' , $ url ) ; $ request = Http :: getRequest ( ) ; $ nice = $ request -> getRawRequest ( ) -> getScheme ( ) . '://' ; if ( $ subDomain != null ) { $ nice .= $ subDomain . '.' ; } $ nice .= self :: extractDomain ( $ request -> getRawRequest ( ) ) ; } return $ nice . '/' . ltrim ( ( string ) preg_replace ( '/\/+/' , '/' , $ url ) , '/' ) ; }
11432	protected function head ( $ path , array $ parameters = array ( ) , $ requestHeaders = array ( ) ) { if ( array_key_exists ( 'ref' , $ parameters ) && is_null ( $ parameters [ 'ref' ] ) ) { unset ( $ parameters [ 'ref' ] ) ; } $ response = $ this -> client -> getHttpClient ( ) -> request ( $ path , null , 'HEAD' , $ requestHeaders , array ( 'query' => $ parameters ) ) ; return $ response ; }
9106	public function getPreparedThemeObject ( ) { $ name = $ this -> attainThemeName ( ) ; $ path = $ this -> attainPathName ( ) ; $ return = false ; if ( $ name && $ path ) { $ return = $ this -> getThemeObject ( ) ; $ return -> setName ( $ name ) ; $ return -> setThemesPath ( $ path ) ; } return $ return ; }
2079	public function purgeInternalCache ( ) { $ container = System :: getContainer ( ) ; $ clearer = $ container -> get ( 'contao.cache.clear_internal' ) ; $ clearer -> clear ( $ container -> getParameter ( 'kernel.cache_dir' ) ) ; $ this -> log ( 'Purged the internal cache' , __METHOD__ , TL_CRON ) ; }
653	protected function getCacheKey ( $ method , $ fetchMode , $ rawSql ) { return [ __CLASS__ , $ method , $ fetchMode , $ this -> db -> dsn , $ this -> db -> username , $ rawSql , ] ; }
10147	private function readPalette ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; if ( ! $ this -> readDataOnly ) { $ nm = self :: getUInt2d ( $ recordData , 0 ) ; for ( $ i = 0 ; $ i < $ nm ; ++ $ i ) { $ rgb = substr ( $ recordData , 2 + 4 * $ i , 4 ) ; $ this -> palette [ ] = self :: readRGB ( $ rgb ) ; } } }
8976	public static function typeOf ( $ arg ) { if ( null === $ arg ) { return 'NULL' ; } if ( is_object ( $ arg ) ) { return get_class ( $ arg ) ; } return gettype ( $ arg ) ; }
3227	function buildUrlForGetOrPut ( $ host , $ path , $ params = null ) { return RequestUtil :: buildUrlForGetOrPut ( $ this -> userLocale , $ host , $ path , $ params ) ; }
7954	public function getSpamStats ( $ ipblock , $ spamstate , $ fromdate , $ todate ) { if ( ! $ ipblock ) throw new BadMethodCallException ( 'Parameter $ipblock is missing.' ) ; if ( ! $ ipv4 ) throw new BadMethodCallException ( 'Parameter $ipv4 is missing.' ) ; if ( ! $ fromdate ) throw new BadMethodCallException ( 'Parameter $fromdate is missing.' ) ; if ( ! $ todate ) throw new BadMethodCallException ( 'Parameter $todate is missing.' ) ; try { $ r = $ this -> get ( 'ip/' . urlencode ( $ ipblock ) . '/spam/' . $ ipv4 . '/stats?from=' . urlencode ( $ fromdate ) . '&to=' . urlencode ( $ todate ) ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new IpException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
5145	public function _after ( \ Codeception \ TestCase $ test ) { if ( isset ( $ this -> config [ 'deleteEmailsAfterScenario' ] ) && $ this -> config [ 'deleteEmailsAfterScenario' ] ) { $ this -> deleteAllEmails ( ) ; } }
5010	public function getPermissions ( ) { if ( ! $ this -> permissions ) { $ type = property_exists ( $ this , 'permissionsType' ) ? $ this -> permissionsType : str_replace ( '\\Entity\\' , '/' , static :: class ) ; $ permissions = new Permissions ( $ type ) ; if ( method_exists ( $ this , 'setupPermissions' ) ) { $ this -> setupPermissions ( $ permissions ) ; } $ this -> setPermissions ( $ permissions ) ; } return $ this -> permissions ; }
11236	public function url ( $ url = null , $ append = '' ) { unset ( $ _POST ) ; unset ( $ _FILES ) ; header ( 'location: ' . $ this -> getRedirect ( $ url ) . $ append ) ; exit ; }
3533	public static function findByAttribute ( $ attribute , $ searchValue ) { if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: beginProfile ( 'Attribute: ' . $ attribute . '; Value: ' . $ searchValue , static :: YII2_PROFILE_NAME . 'findByAttribute' ) ; } $ userObjectsFound = static :: getAdldapProvider ( ) -> search ( ) -> select ( 'samaccountname' ) -> where ( $ attribute , '=' , $ searchValue ) -> get ( ) ; $ userObjectReturn = null ; if ( count ( $ userObjectsFound ) == 1 ) { $ userObjectReturn = static :: findByUsername ( $ userObjectsFound [ 0 ] [ 'samaccountname' ] [ 0 ] ) ; } if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: endProfile ( 'Attribute: ' . $ attribute . '; Value: ' . $ searchValue , static :: YII2_PROFILE_NAME . 'findByAttribute' ) ; } return $ userObjectReturn ; }
12513	public static function copy ( $ src , $ dest , $ force = false , $ delete = false ) { $ src = Path :: clean ( $ src ) ; $ dest = Path :: clean ( $ dest ) ; $ fs = new Filesystem ( ) ; try { $ fs -> mirror ( $ src , $ dest , null , [ 'override' => $ force , 'delete' => $ delete , 'copy_on_windows' => true ] ) ; } catch ( IOExceptionInterface $ e ) { throw new Exception ( Helper :: getTranslation ( 'CANNOT_FIND_SOURCE' ) . ' ' . $ e -> getPath ( ) ) ; } return true ; }
11922	public function getAmount ( ) { $ amount = $ this -> getPerUnitAmount ( ) ; $ totalAmount = bcmul ( $ amount , $ this -> getQuantity ( ) , 2 ) ; return floatval ( $ totalAmount ) ; }
5507	public function returnsByValue ( $ method , $ value , $ args = false ) { $ this -> dieOnNoMethod ( $ method , 'set return value' ) ; $ this -> actions -> register ( $ method , $ args , new SimpleByValue ( $ value ) ) ; }
9116	public function registerView ( $ view , $ order = null , $ applicationName = 'default' ) { if ( ! class_exists ( $ view ) ) { throw new ViewException ( "No such view class {view} found" , array ( 'view' => $ view ) ) ; } $ v = new $ view ( ) ; if ( ! $ v instanceof View ) { throw new ViewException ( "View {view} is not in application scope" , array ( 'view' => $ view ) ) ; } $ viewOrder = $ v -> getOrder ( ) ; if ( null !== $ order ) { $ viewOrder = intval ( $ order ) ; } $ settings = $ v -> getViewSettings ( ) ; $ this -> views [ $ applicationName ] [ $ viewOrder ] [ $ settings -> getViewSimpleName ( ) ] = $ settings ; return $ this ; }
7574	public function hasRequiredValue ( $ postVars , $ keys ) { foreach ( $ keys as $ key ) { $ requiredKey = $ this -> findKey ( $ key , $ postVars ) ; if ( array_key_exists ( $ requiredKey , $ postVars ) && $ postVars [ $ requiredKey ] !== '' ) return true ; } return false ; }
5320	public function waitReady ( ) { $ x = 0 ; while ( $ x ++ < 100 ) { usleep ( self :: WAIT_IDLE ) ; if ( $ this [ self :: STARTED_MARKER ] === true ) { return $ this ; } } throw new \ RuntimeException ( 'Wait process running timeout for child pid ' . $ this -> getPid ( ) ) ; }
12712	public function getResolvedConcreteFlag ( $ abstract ) { if ( ! $ this -> hasResolvedConcrete ( $ abstract ) ) { throw Internal \ Exception \ ReflectionExceptionFactory :: invalidArgument ( sprintf ( "Parameter 1 of %s must be an abstract class name which exists in resolved concrete stack." , __METHOD__ ) ) ; } return explode ( '|' , $ this -> resolved [ $ abstract ] [ 'flag' ] ) ; }
9722	public function write ( Spreadsheet $ spreadsheet , $ filename , array $ writers = [ 'Xlsx' , 'Xls' ] ) { $ spreadsheet -> setActiveSheetIndex ( 0 ) ; foreach ( $ writers as $ writerType ) { $ path = $ this -> getFilename ( $ filename , mb_strtolower ( $ writerType ) ) ; $ writer = IOFactory :: createWriter ( $ spreadsheet , $ writerType ) ; if ( $ writer instanceof Pdf ) { $ tempDir = $ this -> getTemporaryFolder ( ) ; $ writer -> setTempDir ( $ tempDir ) ; } $ callStartTime = microtime ( true ) ; $ writer -> save ( $ path ) ; $ this -> logWrite ( $ writer , $ path , $ callStartTime ) ; } $ this -> logEndingNotes ( ) ; }
3525	public function lookup ( $ username ) { try { $ data = FortniteClient :: sendFortniteGetRequest ( FortniteClient :: FORTNITE_PERSONA_API . 'public/account/lookup?q=' . urlencode ( $ username ) , $ this -> access_token ) ; return new self ( $ this -> access_token , $ data -> id ) ; } catch ( GuzzleException $ e ) { if ( $ e -> getResponse ( ) -> getStatusCode ( ) == 404 ) throw new UserNotFoundException ( 'User ' . $ username . ' was not found.' ) ; throw $ e ; } }
4397	protected function getRedirectForm ( \ Omnipay \ Common \ Message \ RedirectResponseInterface $ response ) { $ list = [ ] ; foreach ( ( array ) $ response -> getRedirectData ( ) as $ key => $ value ) { $ list [ $ key ] = new \ Aimeos \ MW \ Criteria \ Attribute \ Standard ( array ( 'label' => $ key , 'code' => $ key , 'type' => 'string' , 'internalcode' => $ key , 'internaltype' => 'string' , 'default' => $ value , 'public' => false , ) ) ; } $ url = $ response -> getRedirectUrl ( ) ; $ method = $ response -> getRedirectMethod ( ) ; return new \ Aimeos \ MShop \ Common \ Helper \ Form \ Standard ( $ url , $ method , $ list ) ; }
1273	public function isAmbiguous ( ) { if ( AddressValidation :: REQUEST_OPTION_ADDRESS_CLASSIFICATION == $ this -> requestAction ) { throw new \ BadMethodCallException ( __METHOD__ . ' should not be called on Address Classification only requests.' ) ; } return isset ( $ this -> response -> AmbiguousAddressIndicator ) ; }
7455	protected function getTaxonomies ( string $ post_type ) : array { $ return = [ ] ; $ taxes = \ get_object_taxonomies ( $ post_type , 'objects' ) ; foreach ( $ taxes as $ tax_slug => $ tax_object ) { if ( \ is_taxonomy_hierarchical ( $ tax_slug ) ) { $ return [ ] = $ tax_slug ; } } return $ return ; }
786	public function scenarios ( ) { $ scenarios = [ self :: SCENARIO_DEFAULT => [ ] ] ; foreach ( $ this -> getValidators ( ) as $ validator ) { foreach ( $ validator -> on as $ scenario ) { $ scenarios [ $ scenario ] = [ ] ; } foreach ( $ validator -> except as $ scenario ) { $ scenarios [ $ scenario ] = [ ] ; } } $ names = array_keys ( $ scenarios ) ; foreach ( $ this -> getValidators ( ) as $ validator ) { if ( empty ( $ validator -> on ) && empty ( $ validator -> except ) ) { foreach ( $ names as $ name ) { foreach ( $ validator -> attributes as $ attribute ) { $ scenarios [ $ name ] [ $ attribute ] = true ; } } } elseif ( empty ( $ validator -> on ) ) { foreach ( $ names as $ name ) { if ( ! in_array ( $ name , $ validator -> except , true ) ) { foreach ( $ validator -> attributes as $ attribute ) { $ scenarios [ $ name ] [ $ attribute ] = true ; } } } } else { foreach ( $ validator -> on as $ name ) { foreach ( $ validator -> attributes as $ attribute ) { $ scenarios [ $ name ] [ $ attribute ] = true ; } } } } foreach ( $ scenarios as $ scenario => $ attributes ) { if ( ! empty ( $ attributes ) ) { $ scenarios [ $ scenario ] = array_keys ( $ attributes ) ; } } return $ scenarios ; }
10725	public function getPageHistoricListOfActions ( $ order = 'ASC' ) { $ select = $ this -> tableGateway -> getSql ( ) -> select ( ) ; $ select -> columns ( [ "action" => new Expression ( 'DISTINCT(hist_action)' ) ] ) ; $ select -> order ( 'hist_action' . ' ' . $ order ) ; $ resultSet = $ this -> tableGateway -> selectWith ( $ select ) ; return $ resultSet ; }
1834	public static function findByPk ( $ varValue , array $ arrOptions = array ( ) ) { if ( empty ( $ arrOptions ) ) { $ objModel = Registry :: getInstance ( ) -> fetch ( static :: $ strTable , $ varValue ) ; if ( $ objModel !== null ) { return $ objModel ; } } $ arrOptions = array_merge ( array ( 'limit' => 1 , 'column' => static :: $ strPk , 'value' => $ varValue , 'return' => 'Model' ) , $ arrOptions ) ; return static :: find ( $ arrOptions ) ; }
12517	public static function move ( $ src , $ dest , $ overwrite = false ) { $ src = Path :: clean ( $ src ) ; $ dest = Path :: clean ( $ dest ) ; if ( ! Folder :: exists ( $ src ) ) { throw new Exception ( Helper :: getTranslation ( 'CANNOT_FIND_SOURCE' ) . ' : ' . $ src ) ; } if ( Folder :: exists ( $ dest ) ) { throw new Exception ( Helper :: getTranslation ( 'ALREADY_EXISTS' ) . ' : ' . $ dest ) ; } $ fs = new Filesystem ( ) ; try { $ fs -> rename ( $ src , $ dest , $ overwrite ) ; } catch ( IOExceptionInterface $ e ) { throw new Exception ( Helper :: getTranslation ( 'FAILED_RENAMING' ) . ' - (' . $ e -> getMessage ( ) . ')' ) ; } return true ; }
6395	public function init ( ) { parent :: init ( ) ; $ this -> path = Yii :: getAlias ( $ this -> path ) ; FileHelper :: createDirectory ( $ this -> path , $ this -> dirMode , true ) ; }
10032	function unsubscribeContactByEmail ( $ email , $ mailingId = "" , $ reasons = null ) { $ queryParameters = array ( ) ; if ( ! empty ( $ mailingId ) ) { $ queryParameters [ 'mailingId' ] = $ mailingId ; } if ( ! empty ( $ reasons ) ) { if ( is_array ( $ reasons ) ) { $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , 'reason' , $ reasons ) ; } else { $ queryParameters [ 'reason' ] = urlencode ( $ reasons ) ; } } $ encodedEmail = utf8_encode ( $ email ) ; return $ this -> delete ( "contacts/email/${encodedEmail}/unsubscribe" , $ queryParameters ) ; }
10999	public function matchLocale ( $ locale ) { $ locale = Locale :: create ( $ locale ) ; if ( ! empty ( $ this -> redirect ) ) return false ; if ( $ locale === null ) return true ; foreach ( $ this -> locales as $ l ) if ( $ l -> getLocale ( ) == $ locale -> getLocale ( ) ) return true ; return false ; }
7266	public static function find ( $ id , $ idColumn = null ) { $ tableName = static :: tableName ( ) ; $ idColumn = $ idColumn ? : static :: $ idColumn ; $ rows = Db :: query ( " select * from $tableName where $idColumn = :id " , [ "id" => $ id ] , static :: getDbName ( ) ) ; if ( $ rows === false ) return false ; if ( empty ( $ rows ) ) return null ; $ model = new static ; foreach ( $ rows [ 0 ] as $ col => $ val ) $ model -> $ col = $ model -> decodeValue ( $ val , $ col ) ; return $ model ; }
5847	public function sanitizeFileName ( $ fileName , \ TYPO3 \ CMS \ Core \ Resource \ Folder $ folder ) { $ slotArguments = func_get_args ( ) ; array_pop ( $ slotArguments ) ; $ storageConfiguration = $ folder -> getStorage ( ) -> getConfiguration ( ) ; $ storageRecord = $ folder -> getStorage ( ) -> getStorageRecord ( ) ; if ( $ storageRecord [ 'driver' ] !== 'Local' ) { return ; } $ targetDirectory = $ storageConfiguration [ 'pathType' ] === 'relative' ? PATH_site : '' ; $ targetDirectory .= rtrim ( rtrim ( $ storageConfiguration [ 'basePath' ] , '/' ) . $ folder -> getIdentifier ( ) , '/' ) ; $ processedFileName = static :: $ imageResizer -> getProcessedFileName ( $ targetDirectory . '/' . $ fileName , $ GLOBALS [ 'BE_USER' ] ) ; if ( $ processedFileName !== null ) { static :: $ originalFileName = $ fileName ; $ slotArguments [ 0 ] = PathUtility :: basename ( $ processedFileName ) ; return $ slotArguments ; } }
4248	public function onOutput ( Event $ event ) { $ this -> outputEvent = $ event ; $ this -> channelName = $ this -> debug -> getCfg ( 'channel' ) ; $ this -> data = $ this -> debug -> getData ( ) ; $ event [ 'headers' ] [ ] = array ( 'X-Wf-Protocol-1' , 'http://meta.wildfirehq.org/Protocol/JsonStream/0.2' ) ; $ event [ 'headers' ] [ ] = array ( 'X-Wf-1-Plugin-1' , 'http://meta.firephp.org/Wildfire/Plugin/FirePHP/Library-FirePHPCore/' . self :: FIREPHP_PROTO_VER ) ; $ event [ 'headers' ] [ ] = array ( 'X-Wf-1-Structure-1' , 'http://meta.firephp.org/Wildfire/Structure/FirePHP/FirebugConsole/0.1' ) ; $ heading = isset ( $ _SERVER [ 'REQUEST_METHOD' ] ) ? $ _SERVER [ 'REQUEST_METHOD' ] . ' ' . $ _SERVER [ 'REQUEST_URI' ] : '$: ' . \ implode ( ' ' , $ _SERVER [ 'argv' ] ) ; $ this -> processLogEntryWEvent ( 'groupCollapsed' , array ( 'PHP: ' . $ heading ) ) ; $ this -> processAlerts ( ) ; $ this -> processSummary ( ) ; $ this -> processLog ( ) ; $ this -> processLogEntryWEvent ( 'groupEnd' ) ; $ event [ 'headers' ] [ ] = array ( 'X-Wf-1-Index' , $ this -> messageIndex ) ; $ this -> data = array ( ) ; return ; }
9435	public function theta ( $ float_min , $ float_max ) { self :: checkOrder ( $ float_min , $ float_max ) ; if ( $ this -> r || $ this -> i ) { throw new \ RuntimeException ( 'You cannot set theta value, because algebraic form is in use.' ) ; } $ this -> theta = new \ stdClass ( ) ; $ this -> theta -> min = $ float_min ; $ this -> theta -> max = $ float_max ; return $ this ; }
5674	protected function isMatchingKeys ( $ first , $ second , $ identical ) { $ first_keys = array_keys ( $ first ) ; $ second_keys = array_keys ( $ second ) ; if ( $ identical ) { return ( $ first_keys === $ second_keys ) ; } sort ( $ first_keys ) ; sort ( $ second_keys ) ; return ( $ first_keys == $ second_keys ) ; }
10784	public function parse ( UriInterface $ uri ) : ParsedURL { $ matches = [ ] ; if ( preg_match ( $ this -> pattern , $ uri -> getPath ( ) , $ matches ) === 0 ) { throw new InvalidRequestURLException ( "Unable to parse request path: did not match regex" ) ; } if ( ! ( $ endpoint = $ matches [ "endpoint" ] ?? null ) ) { throw new InvalidRequestURLException ( "Unable to match endpoint in url" ) ; } $ element = $ matches [ "element" ] ?? null ; $ version = $ matches [ "version" ] ?? null ; $ apiKey = $ matches [ "apiKey" ] ?? null ; $ acceptableMimeTypes = [ ] ; if ( ( $ acceptableExtension = $ matches [ "acceptableExtension" ] ?? null ) ) { if ( ! $ this -> MIMEProvider ) { throw new UnableToParseURLException ( "Unable to accept acceptable extensions" ) ; } else { try { $ acceptableMimeTypes [ ] = $ this -> MIMEProvider -> provideMIME ( $ acceptableExtension ) ; } catch ( UnableToProvideMIMEException $ exception ) { throw new UnableToParseURLException ( $ exception -> getMessage ( ) ) ; } } } return new ParsedURL ( $ endpoint , $ element , $ version , $ apiKey , $ acceptableMimeTypes , $ uri -> getQuery ( ) ) ; }
5772	public function getRolesString ( ) : string { $ rolesString = "" ; foreach ( $ this -> roleNames as $ role ) { $ rolesString .= "$role, " ; } return Functions :: removeLastCharsFromString ( $ rolesString , 2 ) ; }
11638	public function getAuthorities ( ) { $ authorities = [ ] ; foreach ( $ this -> getAll ( ) as $ typeItem ) { if ( isset ( $ typeItem -> object ) && $ typeItem -> object -> getBehavior ( 'Authority' ) !== null ) { $ authorities [ $ typeItem -> object -> systemId ] = $ typeItem -> object ; } } return $ authorities ; }
2812	public function getObservers ( ) { if ( $ this -> observers === null ) { $ this -> observers = array ( ) ; foreach ( $ this -> getTimers ( ) as $ timerName => $ timer ) { if ( strpos ( $ timerName , 'OBSERVER' ) === 0 ) { $ this -> observers [ ] = array ( 'name' => $ timerName , 'count' => $ timer [ 'count' ] , 'sum' => round ( $ timer [ 'sum' ] * 1000 , 2 ) , 'mem_diff' => $ timer [ 'realmem' ] / pow ( 1024 , 2 ) , ) ; } } } return $ this -> observers ; }
5178	public function filter ( \ Closure $ callback ) : self { $ collection = new static ( ) ; foreach ( $ this -> props as $ key => $ value ) { if ( $ callback ( $ value , $ key ) ) { $ collection -> add ( $ key , $ value ) ; } } return $ collection ; }
12924	public function getHandledLocalDataItems ( ) { $ handled = [ ] ; foreach ( $ this -> localDataItems as $ local ) { if ( $ local -> handled ) { $ handled [ ] = $ local ; } } return $ handled ; }
9625	public function getById ( $ characterId ) { try { $ result = $ this -> client -> get ( $ this -> slug . '/' . $ characterId ) ; } catch ( RequestException $ e ) { $ return [ 'request' ] = $ e -> getRequest ( ) . "\n" ; if ( $ e -> hasResponse ( ) ) { return $ return [ 'response' ] = $ e -> getResponse ( ) . "\n" ; } } return $ result -> json ( ) ; }
5001	public function removeTab ( $ tabName , FormMapper $ formMapper ) { $ tabs = $ this -> getFormTabs ( ) ; if ( array_key_exists ( $ tabName , $ tabs ) ) { $ groups = $ this -> getFormGroups ( ) ; if ( ! is_array ( $ groups ) ) { return ; } foreach ( $ tabs [ $ tabName ] [ 'groups' ] as $ group ) { if ( isset ( $ groups [ $ group ] ) ) { foreach ( $ groups [ $ group ] [ 'fields' ] as $ field ) { $ formMapper -> remove ( $ field ) ; } } unset ( $ groups [ $ group ] ) ; } $ this -> setFormGroups ( $ groups ) ; $ this -> removeEmptyGroups ( ) ; } }
8585	public function setProductGroupList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ProductGroupList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
6214	protected function initialize ( ) { if ( $ this -> get ( 'serverData' ) === null ) { $ this -> set ( 'serverData' , ( array ) $ _SERVER ) ; } if ( $ this -> get ( 'getData' ) === null ) { $ this -> set ( 'getData' , ( array ) $ _GET ) ; } if ( $ this -> get ( 'postData' ) === null ) { $ this -> set ( 'postData' , ( array ) $ _POST ) ; } if ( $ this -> get ( 'sessionData' ) === null && isset ( $ _SESSION ) ) { $ this -> set ( 'sessionData' , ( array ) $ _SESSION ) ; } $ serverData = $ this -> get ( 'serverData' ) ; if ( ! $ this -> get ( 'projectRoot' ) ) { $ projectRoot = isset ( $ serverData [ '_' ] ) ? $ serverData [ '_' ] : $ serverData [ 'DOCUMENT_ROOT' ] ; $ this -> set ( 'projectRoot' , $ projectRoot ) ; } if ( ! $ this -> get ( 'url' ) ) { if ( isset ( $ serverData [ 'REDIRECT_URL' ] ) ) { $ this -> set ( 'url' , $ serverData [ 'REDIRECT_URL' ] ) ; } elseif ( isset ( $ serverData [ 'SCRIPT_NAME' ] ) ) { $ this -> set ( 'url' , $ serverData [ 'SCRIPT_NAME' ] ) ; } } if ( ! $ this -> get ( 'hostname' ) ) { $ this -> set ( 'hostname' , isset ( $ serverData [ 'HTTP_HOST' ] ) ? $ serverData [ 'HTTP_HOST' ] : 'No Host' ) ; } $ protocol = $ this -> get ( 'secure' ) ? 'https' : 'http' ; $ endPoint = $ this -> get ( 'apiEndPoint' ) ? : $ protocol . '://' . $ this -> get ( 'host' ) . $ this -> get ( 'resource' ) ; $ this -> set ( 'apiEndPoint' , $ endPoint ) ; }
7391	public function assign ( $ in ) { $ this -> _massageBlockInput ( $ in ) ; if ( empty ( $ in ) ) { foreach ( $ this -> _publicNames as $ publicName ) { $ this -> __unset ( $ publicName ) ; } } elseif ( is_object ( $ in ) ) { foreach ( $ this -> _publicNames as $ publicName ) { if ( isset ( $ in -> { $ publicName } ) ) { $ this -> _setByName ( $ publicName , $ in -> { $ publicName } ) ; } else { $ this -> __unset ( $ publicName ) ; } } } else { foreach ( $ this -> _publicNames as $ publicName ) { if ( isset ( $ in [ $ publicName ] ) ) { $ this -> _setByName ( $ publicName , $ in [ $ publicName ] ) ; } else { $ this -> __unset ( $ publicName ) ; } } } $ this -> _checkRelatedProperties ( ) ; }
12448	static function run_update_ezinfo ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { $ opts = self :: getOpts ( @ $ args [ 0 ] , @ $ args [ 1 ] , $ cliopts ) ; if ( ! SharedLock :: acquire ( $ opts [ 'extension' ] [ 'name' ] , LOCK_EX , $ opts ) ) throw new PakeException ( "Source code locked by another process" ) ; $ destdir = self :: getBuildDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ; $ files = pakeFinder :: type ( 'file' ) -> name ( 'ezinfo.php' ) -> maxdepth ( 0 ) ; pake_replace_regexp ( $ files , $ destdir , array ( '/^([\s]{1,25}\x27Version\x27[\s]+=>[\s]+[\x27\x22])(.*)([\x27\x22],?\r?\n?)/m' => '${1}' . $ opts [ 'version' ] [ 'alias' ] . $ opts [ 'releasenr' ] [ 'separator' ] . $ opts [ 'version' ] [ 'release' ] . '$3' , '/^([\s]{1,25}\x27License\x27[\s]+=>[\s]+[\x27\x22])(.*)([\x27\x22],?\r?\n?)/m' => '${1}' . $ opts [ 'version' ] [ 'license' ] . '$3' ) , 1 ) ; $ files = pakeFinder :: type ( 'file' ) -> maxdepth ( 0 ) -> name ( 'extension.xml' ) ; pake_replace_regexp ( $ files , $ destdir , array ( '#^([\s]{1,8}<version>)([^<]*)(</version>\r?\n?)#m' => '${1}' . $ opts [ 'version' ] [ 'alias' ] . $ opts [ 'releasenr' ] [ 'separator' ] . $ opts [ 'version' ] [ 'release' ] . '$3' , '#^([\s]{1,8}<license>)([^<]*)(</license>\r?\n?)#m' => '${1}' . htmlspecialchars ( $ opts [ 'version' ] [ 'license' ] ) . '$3' , '#^([\s]{1,8}<copyright>)Copyright \(C\) 1999-[\d]{4} eZ Systems AS(</copyright>\r?\n?)#m' => '${1}' . 'Copyright (C) 1999-' . strftime ( '%Y' ) . ' eZ Systems AS' . '$2' ) , 1 ) ; SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_EX , $ opts ) ; }
3084	public function getAssessmentItemRefByIdentifiers ( \ tao_models_classes_service_StorageDirectory $ privateCompilationDirectory , array $ identifiers ) { $ assessmentItemRefs = [ ] ; foreach ( $ identifiers as $ identifier ) { $ assessmentItemRefs [ ] = $ this -> getAssessmentItemRefByIdentifier ( $ privateCompilationDirectory , $ identifier ) ; } return $ assessmentItemRefs ; }
3365	public function structure ( $ args , $ assoc_args ) { global $ wp_rewrite ; $ blog_prefix = '' ; $ prefix = $ blog_prefix ; if ( is_multisite ( ) && ! is_subdomain_install ( ) && is_main_site ( ) ) { $ blog_prefix = '/blog' ; } $ permalink_structure = ( 'default' === $ args [ 0 ] ) ? '' : $ args [ 0 ] ; if ( ! empty ( $ permalink_structure ) ) { $ permalink_structure = preg_replace ( '#/+#' , '/' , '/' . str_replace ( '#' , '' , $ permalink_structure ) ) ; if ( $ prefix && $ blog_prefix ) { $ permalink_structure = $ prefix . preg_replace ( '#^/?index\.php#' , '' , $ permalink_structure ) ; } else { $ permalink_structure = $ blog_prefix . $ permalink_structure ; } } $ wp_rewrite -> set_permalink_structure ( $ permalink_structure ) ; if ( isset ( $ assoc_args [ 'category-base' ] ) ) { $ category_base = $ assoc_args [ 'category-base' ] ; if ( ! empty ( $ category_base ) ) { $ category_base = $ blog_prefix . preg_replace ( '#/+#' , '/' , '/' . str_replace ( '#' , '' , $ category_base ) ) ; } $ wp_rewrite -> set_category_base ( $ category_base ) ; } if ( isset ( $ assoc_args [ 'tag-base' ] ) ) { $ tag_base = $ assoc_args [ 'tag-base' ] ; if ( ! empty ( $ tag_base ) ) { $ tag_base = $ blog_prefix . preg_replace ( '#/+#' , '/' , '/' . str_replace ( '#' , '' , $ tag_base ) ) ; } $ wp_rewrite -> set_tag_base ( $ tag_base ) ; } self :: apache_modules ( ) ; WP_CLI :: success ( 'Rewrite structure set.' ) ; $ new_assoc_args = [ ] ; $ cmd = 'rewrite flush' ; if ( Utils \ get_flag_value ( $ assoc_args , 'hard' ) ) { $ cmd .= ' --hard' ; $ new_assoc_args [ 'hard' ] = true ; if ( ! in_array ( 'mod_rewrite' , ( array ) WP_CLI :: get_config ( 'apache_modules' ) , true ) ) { WP_CLI :: warning ( 'Regenerating a .htaccess file requires special configuration. See usage docs.' ) ; } } $ process_run = WP_CLI :: runcommand ( $ cmd ) ; if ( ! empty ( $ process_run -> stderr ) ) { WP_CLI :: warning ( substr ( $ process_run -> stderr , 9 ) ) ; } }
541	protected function serializeModelErrors ( $ model ) { $ this -> response -> setStatusCode ( 422 , 'Data Validation Failed.' ) ; $ result = [ ] ; foreach ( $ model -> getFirstErrors ( ) as $ name => $ message ) { $ result [ ] = [ 'field' => $ name , 'message' => $ message , ] ; } return $ result ; }
7022	private function formatO ( & $ str ) { if ( strstr ( $ str , '%O' ) ) { $ o = $ this -> timezone -> offset ; $ os = $ o >= 0 ? '+' : '-' ; $ oh = sprintf ( '%02d' , abs ( intval ( $ o ) ) ) ; $ om = sprintf ( '%02d' , abs ( $ o - intval ( $ o ) ) * 60 ) ; $ ofs = "{$os}{$oh}{$om}" ; $ str = str_replace ( '%O' , $ ofs , $ str ) ; } }
6171	protected function onAddFailure ( $ e ) { $ this -> writeProgressWithColor ( 'fg-red,bold' , 'F' ) ; $ this -> failure = $ e ; $ this -> lastTestFailed = true ; $ this -> flawless = false ; }
12261	private function _cacheCustomFieldsGroup ( CustomFieldsGroup $ group ) { foreach ( $ group -> getCustomFields ( ) as $ field ) { $ this -> cache [ $ group -> getEntity ( ) ] [ $ field -> getSlug ( ) ] = $ field ; } }
6351	public static function size ( Iterator $ iterator ) { $ result = 0 ; Iterators :: each ( $ iterator , function ( ) use ( & $ result ) { $ result ++ ; } ) ; return $ result ; }
3257	public function scopeWhereSKU ( $ query , $ sku ) { return $ query -> join ( config ( 'shop.item_table' ) , config ( 'shop.item_table' ) . '.order_id' , '=' , $ this -> table . '.id' ) -> where ( config ( 'shop.item_table' ) . '.sku' , $ sku ) ; }
5780	private function setNav ( ) { $ this -> nav = [ 'System' => [ 'subSections' => [ 'Administrators' => [ 'route' => ROUTE_ADMINISTRATORS , 'authorization' => ADMINISTRATORS_VIEW_RESOURCE , 'subSections' => [ 'Insert' => [ 'route' => ROUTE_ADMINISTRATORS_INSERT , 'authorization' => ADMINISTRATORS_INSERT_RESOURCE , ] , ] ] , 'Roles' => [ 'route' => ROUTE_ADMINISTRATORS_ROLES , 'authorization' => ROLES_VIEW_RESOURCE , 'subSections' => [ 'Insert' => [ 'route' => ROUTE_ADMINISTRATORS_ROLES_INSERT , 'authorization' => ROLES_INSERT_RESOURCE , ] , ] , ] , 'Permissions' => [ 'route' => ROUTE_ADMINISTRATORS_PERMISSIONS , 'authorization' => PERMISSIONS_VIEW_RESOURCE , 'subSections' => [ 'Insert' => [ 'route' => ROUTE_ADMINISTRATORS_PERMISSIONS_INSERT , 'authorization' => PERMISSIONS_INSERT_RESOURCE , ] , ] ] , 'Events' => [ 'route' => ROUTE_EVENTS , 'authorization' => EVENTS_VIEW_RESOURCE , 'subSections' => [ 'Types' => [ 'route' => ROUTE_DATABASE_TABLES , 'args' => [ ROUTEARG_DATABASE_TABLE_NAME => 'event_types' ] , 'authorization' => EVENTS_VIEW_RESOURCE , ] , ] ] , 'Database' => [ 'authorization' => DATABASE_TABLES_VIEW_RESOURCE , 'subSections' => $ this -> getDatabaseTablesSection ( ) ] , ] ] , 'Logout' => [ 'route' => ROUTE_LOGOUT , ] , ] ; if ( isset ( $ this -> container [ 'settings' ] [ 'adminNav' ] ) ) { if ( ! is_array ( $ this -> container [ 'settings' ] [ 'adminNav' ] ) ) { throw new \ Exception ( "adminNav config must be array" ) ; } $ this -> nav = array_merge ( $ this -> container [ 'settings' ] [ 'adminNav' ] , $ this -> nav ) ; } }
12606	public static function getPath ( string $ file ) { $ parts = explode ( '/' , $ file ) ; array_pop ( $ parts ) ; return implode ( '/' , $ parts ) ; }
9496	public function getCollection ( $ end_point , $ collectionName , $ page = 1 , $ per_page = 100 , $ sort_by = null , $ sort_order = 'asc' ) { $ end_point = strtolower ( $ end_point ) ; if ( strpos ( $ end_point , 'http' ) !== 0 ) { $ end_point = $ this -> api -> getApiUrl ( ) . $ end_point ; } $ request = $ this -> api -> get ( $ end_point ) ; $ query = $ request -> getQuery ( ) -> set ( 'page' , $ page ) -> set ( 'per_page' , $ per_page ) ; if ( $ sort_by ) { $ query -> set ( 'sort_by' , $ sort_by ) -> set ( 'sort_order' , $ sort_order == 'asc' ? 'asc' : 'desc' ) ; } $ response = $ this -> processRequest ( $ request ) ; $ values = $ response -> json ( ) ; $ result = new PaginatedResult ( ) ; $ result -> setClient ( $ this ) ; if ( array_key_exists ( 'count' , $ values ) ) { $ result -> setCount ( $ values [ 'count' ] ) ; } $ result -> setCurrentPage ( $ page ) ; $ result -> setPerPage ( $ per_page ) ; $ result -> setEndPoint ( $ end_point ) ; $ type = $ this -> getType ( ) ; if ( array_key_exists ( $ collectionName , $ values ) && is_array ( $ values [ $ collectionName ] ) ) { foreach ( $ values [ $ collectionName ] as $ value ) { $ entity = new $ type ( ) ; $ this -> manage ( $ entity ) ; $ result [ ] = $ entity -> fromArray ( $ value ) ; } } return $ result ; }
8390	public function addRightOuterJoin ( $ table , $ on ) { $ this -> rightOuterJoins [ ] = array ( 'table' => $ table , 'on' => ( $ on instanceof Condition ? $ on : new Condition ( $ on ) ) ) ; return $ this ; }
2081	public function purgeOptInTokens ( ) { $ optIn = System :: getContainer ( ) -> get ( 'contao.opt-in' ) ; $ optIn -> purgeTokens ( ) ; $ this -> log ( 'Purged the expired double opt-in tokens' , __METHOD__ , TL_CRON ) ; }
8386	public function having ( $ having ) { $ this -> having = ( $ having instanceof Condition ? $ having : new Condition ( $ having ) ) ; return $ this ; }
12128	public function run ( InputInterface $ input , OutputInterface $ output ) { $ this -> returnCode = static :: RETURN_SUCCESS ; $ this -> doPreRun ( $ input , $ output ) ; if ( ! $ this -> executeDependencies ( $ input , $ output ) ) { $ this -> returnCode = static :: RETURN_ERROR ; } else { $ this -> returnCode = ( int ) $ this -> execute ( $ input , $ output ) ; } $ this -> doPostRun ( $ input , $ output , $ this -> returnCode ) ; return $ this -> returnCode ; }
7519	function parse_doctype ( ) { $ start = $ this -> pos ; if ( $ this -> next_search ( '[>' , false ) === self :: TOK_UNKNOWN ) { if ( $ this -> doc [ $ this -> pos ] === '[' ) { if ( ( $ this -> next_pos ( ']' , false ) !== self :: TOK_UNKNOWN ) || ( $ this -> next_pos ( '>' , false ) !== self :: TOK_UNKNOWN ) ) { $ this -> addError ( 'Invalid doctype' ) ; return false ; } } $ this -> token_start = $ start ; $ this -> status [ 'dtd' ] = $ this -> getTokenString ( 2 , - 1 ) ; $ this -> status [ 'last_pos' ] = $ this -> pos ; return true ; } else { $ this -> addError ( 'Invalid doctype' ) ; return false ; } }
1574	public function defaultApi ( $ apiName = null ) { if ( is_null ( $ apiName ) ) { return LaravelJsonApi :: $ defaultApi ; } LaravelJsonApi :: defaultApi ( $ apiName ) ; return $ apiName ; }
3295	protected function getFingers ( Lead $ lead ) { $ fingers = [ ] ; if ( $ lead -> getEmail ( ) ) { $ fingers [ 'email' ] = strtolower ( $ lead -> getEmail ( ) ) ; } if ( $ lead -> getPhone ( ) ) { $ fingers [ 'phone' ] = preg_replace ( '/\D/' , '' , $ lead -> getPhone ( ) ) ; } if ( $ lead -> getMobile ( ) ) { $ fingers [ 'mobile' ] = preg_replace ( '/\D/' , '' , $ lead -> getMobile ( ) ) ; } return $ fingers ; }
9354	public function subMatrix ( $ int_m , $ int_n ) { $ sm = new self ( $ this -> size -> rows - 1 , $ this -> size -> cols - 1 ) ; foreach ( $ this -> arr as $ m => $ row ) { if ( $ m != $ int_m ) { $ arr_row = array ( ) ; foreach ( $ row as $ n => $ v ) { if ( $ n != $ int_n ) { $ arr_row [ ] = $ v ; } } $ sm -> addRow ( $ arr_row ) ; } } return $ sm ; }
1721	private function getStringRepresentation ( array $ chunks , $ value ) : string { switch ( \ count ( $ chunks ) ) { case 2 : return sprintf ( "\$GLOBALS['TL_LANG']['%s'][%s] = %s;\n" , $ chunks [ 0 ] , $ this -> quoteKey ( $ chunks [ 1 ] ) , $ this -> quoteValue ( $ value ) ) ; case 3 : return sprintf ( "\$GLOBALS['TL_LANG']['%s'][%s][%s] = %s;\n" , $ chunks [ 0 ] , $ this -> quoteKey ( $ chunks [ 1 ] ) , $ this -> quoteKey ( $ chunks [ 2 ] ) , $ this -> quoteValue ( $ value ) ) ; case 4 : return sprintf ( "\$GLOBALS['TL_LANG']['%s'][%s][%s][%s] = %s;\n" , $ chunks [ 0 ] , $ this -> quoteKey ( $ chunks [ 1 ] ) , $ this -> quoteKey ( $ chunks [ 2 ] ) , $ this -> quoteKey ( $ chunks [ 3 ] ) , $ this -> quoteValue ( $ value ) ) ; } throw new \ OutOfBoundsException ( 'Cannot load less than 2 or more than 4 levels in XLIFF language files.' ) ; }
3412	public function finishedCrawling ( ) { $ this -> consoleOutput -> writeln ( '' ) ; $ this -> consoleOutput -> writeln ( 'Crawling summary' ) ; $ this -> consoleOutput -> writeln ( '----------------' ) ; ksort ( $ this -> crawledUrls ) ; foreach ( $ this -> crawledUrls as $ statusCode => $ urls ) { $ colorTag = $ this -> getColorTagForStatusCode ( $ statusCode ) ; $ count = count ( $ urls ) ; if ( is_numeric ( $ statusCode ) ) { $ this -> consoleOutput -> writeln ( "<{$colorTag}>Crawled {$count} url(s) with statuscode {$statusCode}</{$colorTag}>" ) ; } if ( $ statusCode == static :: UNRESPONSIVE_HOST ) { $ this -> consoleOutput -> writeln ( "<{$colorTag}>{$count} url(s) did have unresponsive host(s)</{$colorTag}>" ) ; } } $ this -> consoleOutput -> writeln ( '' ) ; }
6293	private function scanThemes ( ) { $ themeDirectories = glob ( $ this -> basePath . '/*' , GLOB_ONLYDIR ) ; $ themes = [ ] ; foreach ( $ themeDirectories as $ themePath ) { $ json = $ themePath . '/theme.json' ; if ( file_exists ( $ json ) ) { $ contents = file_get_contents ( $ json ) ; if ( ! $ contents === false ) { $ th = $ this -> parseThemeInfo ( json_decode ( $ contents , true ) ) ; $ themes [ $ th -> getDirectory ( ) ] = $ th ; } } } $ this -> themes = $ themes ; if ( count ( $ themes ) && ! $ this -> activeTheme ) { $ this -> set ( array_keys ( $ themes ) [ 0 ] ) ; } }
3258	public function scopeFindByUser ( $ query , $ userId , $ statusCode = null ) { if ( ! empty ( $ status ) ) { $ query = $ query -> whereStatus ( $ status ) ; } return $ query -> whereUser ( $ userId ) -> get ( ) ; }
9870	private function writePageSetup ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { $ objWriter -> startElement ( 'pageSetup' ) ; $ objWriter -> writeAttribute ( 'paperSize' , $ pSheet -> getPageSetup ( ) -> getPaperSize ( ) ) ; $ objWriter -> writeAttribute ( 'orientation' , $ pSheet -> getPageSetup ( ) -> getOrientation ( ) ) ; if ( $ pSheet -> getPageSetup ( ) -> getScale ( ) !== null ) { $ objWriter -> writeAttribute ( 'scale' , $ pSheet -> getPageSetup ( ) -> getScale ( ) ) ; } if ( $ pSheet -> getPageSetup ( ) -> getFitToHeight ( ) !== null ) { $ objWriter -> writeAttribute ( 'fitToHeight' , $ pSheet -> getPageSetup ( ) -> getFitToHeight ( ) ) ; } else { $ objWriter -> writeAttribute ( 'fitToHeight' , '0' ) ; } if ( $ pSheet -> getPageSetup ( ) -> getFitToWidth ( ) !== null ) { $ objWriter -> writeAttribute ( 'fitToWidth' , $ pSheet -> getPageSetup ( ) -> getFitToWidth ( ) ) ; } else { $ objWriter -> writeAttribute ( 'fitToWidth' , '0' ) ; } if ( $ pSheet -> getPageSetup ( ) -> getFirstPageNumber ( ) !== null ) { $ objWriter -> writeAttribute ( 'firstPageNumber' , $ pSheet -> getPageSetup ( ) -> getFirstPageNumber ( ) ) ; $ objWriter -> writeAttribute ( 'useFirstPageNumber' , '1' ) ; } $ objWriter -> endElement ( ) ; }
10084	protected function write ( $ stream , $ text ) { $ fp = fopen ( $ stream , 'a' ) ; fwrite ( $ fp , $ text ) ; fclose ( $ fp ) ; }
11703	public function getForm ( ) { $ oForm = $ this -> getFormInObject ( ) ; $ sFormContent = $ oForm -> start ; foreach ( $ oForm -> form as $ sValue ) { $ sFormContent .= $ sValue . $ this -> _sSeparator ; } $ sFormContent .= $ oForm -> end ; $ oContainer = new Container ; $ oContainer -> setView ( $ sFormContent ) -> setForm ( $ this ) ; return $ oContainer ; }
8021	public function payload ( array $ payload ) { $ client = new GuzzleClient ( [ 'base_uri' => $ this -> server ] ) ; $ client -> request ( 'POST' , $ this -> getUri ( ) , [ 'form_params' => [ 'payload' => json_encode ( $ payload ) ] ] ) ; }
8923	public function generate ( $ sourceDocument , $ targetDocument ) { if ( $ sourceDocument === null || $ targetDocument === null ) { return $ targetDocument ; } if ( $ sourceDocument == new \ stdClass ( ) ) { return null ; } if ( is_array ( $ sourceDocument ) ) { if ( $ sourceDocument !== $ targetDocument ) { return $ targetDocument ; } return null ; } $ patchDocument = new \ stdClass ( ) ; $ sourceDocumentVars = get_object_vars ( $ sourceDocument ) ; $ targetDocumentVars = get_object_vars ( $ targetDocument ) ; foreach ( $ targetDocumentVars as $ var => $ value ) { if ( ! in_array ( $ var , array_keys ( $ sourceDocumentVars ) ) || ! in_array ( $ value , array_values ( $ sourceDocumentVars ) ) ) { $ patchDocument -> $ var = $ value ; } } foreach ( $ sourceDocumentVars as $ var => $ value ) { if ( $ targetDocumentVars === [ ] ) { $ patchDocument -> $ var = null ; break ; } if ( is_object ( $ value ) ) { if ( $ sourceDocument -> $ var !== null && is_object ( $ sourceDocument -> $ var ) ) { $ subPatch = $ this -> generate ( $ sourceDocument -> $ var , $ targetDocument -> $ var ) ; if ( $ subPatch !== null ) { $ patchDocument -> $ var = $ subPatch ; } } } elseif ( ! in_array ( $ var , array_keys ( $ targetDocumentVars ) ) || ! in_array ( $ value , array_values ( $ targetDocumentVars ) ) ) { $ sourceDocument -> $ var = null ; if ( ! in_array ( $ var , array_keys ( $ targetDocumentVars ) ) ) { $ patchDocument -> $ var = null ; } } } if ( count ( get_object_vars ( $ patchDocument ) ) > 0 ) { return $ patchDocument ; } return null ; }
5951	public function addFolderResponse ( $ item ) { if ( ! ( $ item instanceof FolderResponse ) ) { if ( is_array ( $ item ) ) { try { $ item = new FolderResponse ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate FolderResponse. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } elseif ( ! is_numeric ( $ item ) ) { trigger_error ( 'Array parameter item is not of expected type "FolderResponse"!' , E_USER_WARNING ) ; } } $ this -> results [ ] = $ item ; return $ this ; }
12653	public function getTextsWithBaseTexts ( $ language ) { $ texts = $ this -> getPageTexts ( $ language ) ; if ( $ language !== $ this -> baseLang ) { $ baseTexts = $ this -> getPageTexts ( $ this -> baseLang ) ; $ texts = array_map ( function ( $ text , $ baseText ) { return $ text + array ( "basecontent" => $ baseText [ 'content' ] ) ; } , $ texts , $ baseTexts ) ; } return $ texts ; }
6939	private function push ( array & $ list , $ oid , StockUnitInterface $ unit ) { if ( ! $ this -> has ( $ list , $ oid , $ unit ) ) { $ list [ $ oid ] [ ] = $ unit ; } }
1095	public function children ( $ node ) { $ query = $ this -> node -> newQuery ( ) ; $ query -> where ( $ this -> node -> getQualifiedParentColumnName ( ) , '=' , $ node -> getKey ( ) ) ; foreach ( $ this -> scopedAttributes ( $ node ) as $ fld => $ value ) $ query -> where ( $ this -> qualify ( $ fld ) , '=' , $ value ) ; $ query -> orderBy ( $ this -> node -> getQualifiedLeftColumnName ( ) ) ; $ query -> orderBy ( $ this -> node -> getQualifiedRightColumnName ( ) ) ; $ query -> orderBy ( $ this -> node -> getQualifiedKeyName ( ) ) ; return $ query -> get ( ) ; }
7751	protected function loadMetadata ( $ className ) { if ( false === isset ( $ this -> loadedMetadata [ $ className ] ) ) { if ( null === ( $ class = $ this -> driver -> loadMetadataForClass ( $ className ) ) ) { throw new \ Exception ( "Can't load metadata for $className" ) ; } $ this -> completeMetadata ( $ class ) ; $ this -> loadedMetadata [ $ className ] = $ class ; } return $ this -> loadedMetadata [ $ className ] ; }
7885	public function getData ( $ date , $ level = null ) { if ( ! is_string ( $ level ) ) { $ level = 'all' ; } $ data = LogViewer :: data ( $ date , $ level ) ; $ paginator = new Paginator ( $ data , $ this -> perPage ) ; $ path = ( new \ ReflectionClass ( $ paginator ) ) -> getProperty ( 'path' ) ; $ path -> setAccessible ( true ) ; $ path -> setValue ( $ paginator , URL :: route ( 'logviewer.index' ) . '/' . $ date . '/' . $ level ) ; if ( count ( $ data ) > $ paginator -> perPage ( ) ) { $ log = array_slice ( $ data , $ paginator -> firstItem ( ) - 1 , $ paginator -> perPage ( ) ) ; } else { $ log = $ data ; } return View :: make ( 'logviewer::data' , compact ( 'paginator' , 'log' ) ) ; }
3454	public static function fromAggregateRoot ( $ eventSourcedAggregateRoot ) : AggregateType { if ( ! \ is_object ( $ eventSourcedAggregateRoot ) ) { throw new Exception \ AggregateTypeException ( \ sprintf ( 'Aggregate root must be an object but type of %s given' , \ gettype ( $ eventSourcedAggregateRoot ) ) ) ; } if ( $ eventSourcedAggregateRoot instanceof AggregateTypeProvider ) { return $ eventSourcedAggregateRoot -> aggregateType ( ) ; } $ self = new static ( ) ; $ self -> aggregateType = \ get_class ( $ eventSourcedAggregateRoot ) ; return $ self ; }
12548	public function getThemePlugin ( $ name ) { if ( ! array_key_exists ( $ name , $ this -> themes ) ) { return null ; } return $ this -> themes [ $ name ] ; }
7947	public function lineResetDslamPort ( $ id , $ line ) { if ( ! $ id ) throw new BadMethodCallException ( 'Missing parameter $id.' ) ; if ( ! $ line ) throw new BadMethodCallException ( 'Missing parameter $line.' ) ; try { $ r = $ this -> post ( 'xdsl/' . $ id . '/lines/' . $ line . '/resetDslamPort' ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new XdslException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
161	public function orHaving ( $ condition , $ params = [ ] ) { if ( $ this -> having === null ) { $ this -> having = $ condition ; } else { $ this -> having = [ 'or' , $ this -> having , $ condition ] ; } $ this -> addParams ( $ params ) ; return $ this ; }
10576	public static function applyStyle ( $ text , $ style ) { $ foreground = self :: getForeground ( $ style ) ; $ background = self :: getBackground ( $ style ) ; return self :: apply ( $ text , $ foreground , $ background ) ; }
10911	public function marked ( Marker ... $ markers ) : Binding { if ( empty ( $ this -> definition -> markers ) ) { $ this -> definition -> markers = [ ] ; } foreach ( $ markers as $ marker ) { $ types = $ marker -> getAllowedTyes ( ) ; if ( empty ( $ types ) ) { $ this -> definition -> markers [ ] = $ marker ; continue ; } foreach ( $ types as $ type ) { if ( $ this -> definition -> typeName == $ type || \ is_subclass_of ( $ this -> definition -> typeName , $ type ) ) { $ this -> definition -> markers [ ] = $ marker ; continue 2 ; } } throw new \ RuntimeException ( \ vsprintf ( 'Type %s cannot be marked with %s, allowed types are [ %s ]' , [ $ this -> definition -> typeName , \ get_class ( $ marker ) , \ implode ( ', ' , $ types ) ] ) ) ; } return $ this ; }
7938	public function getBackupFTPaccessBlock ( $ domain , $ ipBlock ) { $ domain = ( string ) $ domain ; if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; if ( ! $ ipBlock ) throw new BadMethodCallException ( 'Parameter $ipBlock is missing.' ) ; try { $ r = $ this -> get ( 'dedicated/server/' . $ domain . '/features/backupFTP/access/' . urlencode ( $ ipBlock ) ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new ServerException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
726	public function getAttribute ( $ attribute ) { try { return parent :: getAttribute ( $ attribute ) ; } catch ( \ PDOException $ e ) { switch ( $ attribute ) { case self :: ATTR_SERVER_VERSION : return $ this -> query ( "SELECT CAST(SERVERPROPERTY('productversion') AS VARCHAR)" ) -> fetchColumn ( ) ; default : throw $ e ; } } }
11675	public function homepageTemplate ( ) { if ( null === $ this -> homepageTemplate ) { $ homepageFile = $ this -> pagesDir . "/" . $ this -> homepage ( ) . '/page.json' ; $ page = json_decode ( FilesystemTools :: readFile ( $ homepageFile ) , true ) ; $ this -> homepageTemplate = $ page [ "template" ] ; } return $ this -> homepageTemplate ; }
11573	public function SendHeaders ( ) { if ( headers_sent ( ) ) { return $ this ; } header ( 'HTTP/' . $ this -> Version . ' ' . $ this -> StatusCode . ' ' . $ this -> StatusText , true , $ this -> StatusCode ) ; foreach ( $ this -> Headers -> GetCookies ( ) as $ cookie ) { } return $ this ; }
8187	public function hasBlock ( $ name , array $ context = null , array $ blocks = array ( ) ) { if ( null === $ context ) { @ trigger_error ( 'The ' . __METHOD__ . ' method is internal and should never be called; calling it directly is deprecated since version 1.28 and won\'t be possible anymore in 2.0.' , E_USER_DEPRECATED ) ; return isset ( $ this -> blocks [ ( string ) $ name ] ) ; } if ( isset ( $ blocks [ $ name ] ) ) { return $ blocks [ $ name ] [ 0 ] instanceof self ; } if ( isset ( $ this -> blocks [ $ name ] ) ) { return true ; } if ( false !== $ parent = $ this -> getParent ( $ context ) ) { return $ parent -> hasBlock ( $ name , $ context ) ; } return false ; }
3306	protected function request ( $ url , array $ options = [ ] ) { $ httpClient = new Http ; try { $ response = $ httpClient -> request ( 'POST' , $ url , [ 'form_params' => $ options , 'query' => [ $ this -> accessToken -> getQueryName ( ) => $ this -> accessToken -> getAccessToken ( true ) ] ] ) ; } catch ( \ GuzzleHttp \ Exception \ ClientException $ e ) { if ( $ e -> hasResponse ( ) ) { $ response = $ e -> getResponse ( ) ; } else { throw $ e ; } } return $ httpClient -> parseJson ( $ response ) ; }
9283	private function needsCompilation ( $ lessPath , $ cssPath ) { $ isNewer = function ( $ subject , $ reference ) { return filemtime ( $ subject ) > filemtime ( $ reference ) ; } ; if ( $ this -> forceCompile || ! file_exists ( $ lessPath ) || ! file_exists ( $ cssPath ) || $ isNewer ( $ lessPath , $ cssPath ) ) { return true ; } return $ this -> checkImports ( $ lessPath , $ cssPath , $ isNewer ) ; }
10745	public function getObjectArray ( $ keys ) : array { return array_map ( function ( $ value ) { return $ this -> createObject ( $ value ) ; } , $ this -> getArray ( $ keys ) ) ; }
2036	public function getAbsoluteUrl ( $ strParams = null ) { $ this -> loadDetails ( ) ; $ objUrlGenerator = System :: getContainer ( ) -> get ( 'contao.routing.url_generator' ) ; $ strUrl = $ objUrlGenerator -> generate ( ( $ this -> alias ? : $ this -> id ) . $ strParams , array ( '_locale' => $ this -> rootLanguage , '_domain' => $ this -> domain , '_ssl' => ( bool ) $ this -> rootUseSSL , ) , UrlGeneratorInterface :: ABSOLUTE_URL ) ; $ strUrl = $ this -> applyLegacyLogic ( $ strUrl , $ strParams ) ; return $ strUrl ; }
391	protected static function filterValidAliases ( Query $ query ) { $ tables = $ query -> getTablesUsedInFrom ( ) ; $ aliases = array_diff ( array_keys ( $ tables ) , $ tables ) ; return array_map ( function ( $ alias ) { return preg_replace ( '/{{([\w]+)}}/' , '$1' , $ alias ) ; } , array_values ( $ aliases ) ) ; }
1942	public function listRecipient ( $ row ) { $ label = Contao \ Idna :: decodeEmail ( $ row [ 'email' ] ) ; if ( $ row [ 'addedOn' ] ) { $ label .= ' <span style="color:#999;padding-left:3px">(' . sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_newsletter_recipients' ] [ 'subscribed' ] , Contao \ Date :: parse ( Contao \ Config :: get ( 'datimFormat' ) , $ row [ 'addedOn' ] ) ) . ')</span>' ; } else { $ label .= ' <span style="color:#999;padding-left:3px">(' . $ GLOBALS [ 'TL_LANG' ] [ 'tl_newsletter_recipients' ] [ 'manually' ] . ')</span>' ; } return sprintf ( '<div class="tl_content_left"><div class="list_icon" style="background-image:url(\'%ssystem/themes/%s/icons/%s.svg\')" data-icon="member.svg" data-icon-disabled="member_.svg">%s</div></div>' , Contao \ System :: getContainer ( ) -> get ( 'contao.assets.assets_context' ) -> getStaticUrl ( ) , Contao \ Backend :: getTheme ( ) , ( $ row [ 'active' ] ? 'member' : 'member_' ) , $ label ) . "\n" ; }
10753	protected function getMobile ( UserEntity $ user ) { $ metadata = $ user -> getMetadata ( ) ; foreach ( $ metadata as $ meta ) { if ( 'cellulare' == $ meta -> getKey ( ) ) { return $ meta -> getValue ( ) ; } } return null ; }
4966	public function fromHeader ( $ header = null , $ default = null ) { if ( $ header === null ) { return $ this -> event -> getRequest ( ) -> getHeaders ( $ header , $ default ) -> toArray ( ) ; } return $ this -> event -> getRequest ( ) -> getHeaders ( $ header , $ default ) ; }
10336	public static function getDistanceY ( Worksheet $ sheet , $ startRow = 1 , $ startOffsetY = 0 , $ endRow = 1 , $ endOffsetY = 0 ) { $ distanceY = 0 ; for ( $ row = $ startRow ; $ row <= $ endRow ; ++ $ row ) { $ distanceY += self :: sizeRow ( $ sheet , $ row ) ; } $ distanceY -= ( int ) floor ( self :: sizeRow ( $ sheet , $ startRow ) * $ startOffsetY / 256 ) ; $ distanceY -= ( int ) floor ( self :: sizeRow ( $ sheet , $ endRow ) * ( 1 - $ endOffsetY / 256 ) ) ; return $ distanceY ; }
8226	protected function validateRegistration ( array $ reg ) { $ isValid = true ; try { $ this -> storage -> checkValidName ( $ reg [ "username" ] ) ; } catch ( \ RuntimeException $ e ) { $ isValid = false ; $ this -> session -> addFlash ( "error" , $ e -> getMessage ( ) ) ; } $ min = $ this -> config [ "nameLenMin" ] ; $ max = $ this -> config [ "nameLenMax" ] ; if ( strlen ( $ reg [ "username" ] ) < $ min || strlen ( $ reg [ "username" ] ) > $ max ) { $ isValid = false ; $ this -> session -> addFlash ( "error" , sprintf ( "Length of a username must be between %d-%d characters." , $ min , $ max ) ) ; } if ( ! filter_var ( $ reg [ "email" ] , FILTER_VALIDATE_EMAIL ) ) { $ isValid = false ; $ this -> session -> addFlash ( "error" , "Email address does not have a valid format." ) ; } if ( null !== $ this -> storage -> getUserByEmail ( $ reg [ "email" ] ) ) { $ isValid = false ; $ this -> session -> addFlash ( "error" , "This email is already in use." ) ; } if ( $ reg [ "password" ] -> get ( ) !== $ reg [ "passwordRepeat" ] -> get ( ) ) { $ isValid = false ; $ this -> session -> addFlash ( "error" , "The passwords do not match." ) ; } $ localAuth = $ this -> picoAuth -> getContainer ( ) -> get ( 'LocalAuth' ) ; if ( ! $ localAuth -> checkPasswordPolicy ( $ reg [ "password" ] ) ) { $ isValid = false ; } if ( $ this -> storage -> getUserByName ( $ reg [ "username" ] ) !== null ) { $ isValid = false ; $ this -> session -> addFlash ( "error" , "The username is already taken." ) ; } return $ isValid ; }
5242	public function getAutoloads ( ) : array { if ( empty ( $ this -> autoloads ) ) { $ this -> autoloads = $ this -> configCollection -> getAutoloads ( ) ; } return $ this -> autoloads ; }
1538	public function willSeeOne ( $ request ) : bool { if ( $ this -> route -> isRelationship ( ) ) { return false ; } if ( $ this -> route -> isResource ( ) ) { return true ; } return $ request -> isMethod ( 'POST' ) ; }
5149	protected function getFullEmail ( $ id ) { try { $ response = $ this -> sendRequest ( 'GET' , "/api/v1/inboxes/{$this->config['inbox_id']}/messages/{$id}" ) ; } catch ( Exception $ e ) { $ this -> fail ( 'Exception: ' . $ e -> getMessage ( ) ) ; } $ fullEmail = json_decode ( $ response -> getBody ( ) ) ; return $ fullEmail ; }
868	private function isInConditionWithoutBraces ( Tokens $ tokens , $ index , $ lowerLimitIndex ) { do { if ( $ tokens [ $ index ] -> isComment ( ) || $ tokens [ $ index ] -> isWhitespace ( ) ) { $ index = $ tokens -> getPrevMeaningfulToken ( $ index ) ; } $ token = $ tokens [ $ index ] ; if ( $ token -> isGivenKind ( [ T_IF , T_ELSEIF , T_ELSE ] ) ) { return true ; } if ( $ token -> equals ( ';' , '}' ) ) { return false ; } if ( $ token -> equals ( '{' ) ) { $ index = $ tokens -> getPrevMeaningfulToken ( $ index ) ; if ( $ tokens [ $ index ] -> isGivenKind ( T_DO ) ) { -- $ index ; continue ; } if ( ! $ tokens [ $ index ] -> equals ( ')' ) ) { return false ; } $ index = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ index ) ; $ index = $ tokens -> getPrevMeaningfulToken ( $ index ) ; if ( $ tokens [ $ index ] -> isGivenKind ( [ T_IF , T_ELSEIF ] ) ) { return false ; } } elseif ( $ token -> equals ( ')' ) ) { $ type = Tokens :: detectBlockType ( $ token ) ; $ index = $ tokens -> findBlockStart ( $ type [ 'type' ] , $ index ) ; $ index = $ tokens -> getPrevMeaningfulToken ( $ index ) ; } else { -- $ index ; } } while ( $ index > $ lowerLimitIndex ) ; return false ; }
918	public static function sortFixers ( array $ fixers ) { return self :: stableSort ( $ fixers , static function ( FixerInterface $ fixer ) { return $ fixer -> getPriority ( ) ; } , static function ( $ a , $ b ) { return self :: cmpInt ( $ b , $ a ) ; } ) ; }
3446	private function getAccessorForLanguageField ( $ field ) { $ method = 'getValueFromLanguageField' ; return in_array ( $ field , $ this -> languageAccessors ) && method_exists ( $ this , $ method ) ? $ method : false ; }
5261	public function mergeQuery ( array $ query ) { $ types = [ Filter :: MERGE_AND => 'must' , Filter :: MERGE_OR => 'should' ] ; $ type = $ this -> getMergeType ( ) ; $ query [ 'body' ] [ 'filter' ] [ 'bool' ] [ $ types [ $ type ] ] [ ] = $ this -> makeQuery ( ) ; return $ query ; }
11851	public function show ( ) { $ response = new \ Venus \ lib \ Response ( ) ; $ response -> setContent ( '<html><body><h1>Hello world!</h1></body></html>' ) ; $ response -> setStatusCode ( \ Venus \ lib \ Response :: HTTP_OK ) ; $ response -> headers -> set ( 'Content-Type' , 'text/html' ) ; $ response -> send ( ) ; }
927	private function getCommentBlock ( Tokens $ tokens , $ index ) { $ commentType = $ this -> getCommentType ( $ tokens [ $ index ] -> getContent ( ) ) ; $ empty = $ this -> isEmptyComment ( $ tokens [ $ index ] -> getContent ( ) ) ; $ start = $ index ; $ count = \ count ( $ tokens ) ; ++ $ index ; for ( ; $ index < $ count ; ++ $ index ) { if ( $ tokens [ $ index ] -> isComment ( ) ) { if ( $ commentType !== $ this -> getCommentType ( $ tokens [ $ index ] -> getContent ( ) ) ) { break ; } if ( $ empty ) { $ empty = $ this -> isEmptyComment ( $ tokens [ $ index ] -> getContent ( ) ) ; } continue ; } if ( ! $ tokens [ $ index ] -> isWhitespace ( ) || $ this -> getLineBreakCount ( $ tokens , $ index , $ index + 1 ) > 1 ) { break ; } } return [ $ start , $ index - 1 , $ empty ] ; }
2640	public function cleanUrl ( $ url ) { $ result = $ this -> _purge ( $ url , 'PURGE' , 'PURGE' ) ; if ( $ result [ 'status' ] ) { $ this -> logger -> execute ( $ url ) ; } if ( $ this -> config -> areWebHooksEnabled ( ) && $ this -> config -> canPublishKeyUrlChanges ( ) ) { $ this -> sendWebHook ( '*clean by URL for* ' . $ url ) ; } return $ result ; }
4505	public function getList ( Parameters $ parameters = null ) : array { $ options = [ ] ; if ( $ parameters ) { $ options [ 'query' ] = ( array ) $ parameters -> toObject ( true ) ; if ( array_key_exists ( 'organizationUuid' , $ options [ 'query' ] ) ) { $ options [ 'query' ] [ 'organization.uuid' ] = $ options [ 'query' ] [ 'organizationUuid' ] ; unset ( $ options [ 'query' ] [ 'organizationUuid' ] ) ; } } $ objects = $ this -> execute ( 'GET' , static :: RESOURCE_LIST , $ options ) ; $ list = [ ] ; foreach ( $ objects as $ object ) { $ model = static :: toModel ( $ object ) ; $ list [ ] = $ model ; } return $ list ; }
9104	protected function parse_user ( ) { if ( ! empty ( $ this -> args [ 'user' ] ) ) { $ this -> args [ 'user__in' ] = array ( $ this -> args [ 'user' ] ) ; } return $ this -> parse_in_or_not_in_query ( 'user' , $ this -> args [ 'user__in' ] , $ this -> args [ 'user__not_in' ] ) ; }
6692	public function addGroup ( $ prefix , array $ middleware , callable $ callback ) { $ previousMiddlewareStack = $ this -> middlewareStack ; $ previousGroupPrefix = $ this -> currentGroupPrefix ; $ this -> currentGroupPrefix = $ previousGroupPrefix . $ prefix ; $ this -> middlewareStack = array_merge ( $ previousMiddlewareStack , $ middleware ) ; $ callback ( $ this ) ; $ this -> currentGroupPrefix = $ previousGroupPrefix ; $ this -> middlewareStack = $ previousMiddlewareStack ; }
12279	public function moveUsers ( array $ openIds , $ groupId ) { $ params = [ 'openid_list' => $ openIds , 'to_groupid' => $ groupId , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_MEMBER_BATCH_UPDATE , $ params ] ) ; }
2123	public function addMultiple ( array $ arrFiles , $ strVersion = null , $ strMedia = 'screen' ) { foreach ( $ arrFiles as $ strFile ) { $ this -> add ( $ strFile , $ strVersion , $ strMedia ) ; } }
3247	public function add ( $ item , $ quantity = 1 , $ quantityReset = false ) { if ( ! is_array ( $ item ) && ! $ item -> isShoppable ) return ; $ cartItem = $ this -> getItem ( is_array ( $ item ) ? $ item [ 'sku' ] : $ item -> sku ) ; if ( empty ( $ cartItem ) ) { $ reflection = null ; if ( is_object ( $ item ) ) { $ reflection = new \ ReflectionClass ( $ item ) ; } $ cartItem = call_user_func ( Config :: get ( 'shop.item' ) . '::create' , [ 'user_id' => $ this -> user -> shopId , 'cart_id' => $ this -> attributes [ 'id' ] , 'sku' => is_array ( $ item ) ? $ item [ 'sku' ] : $ item -> sku , 'price' => is_array ( $ item ) ? $ item [ 'price' ] : $ item -> price , 'tax' => is_array ( $ item ) ? ( array_key_exists ( 'tax' , $ item ) ? $ item [ 'tax' ] : 0 ) : ( isset ( $ item -> tax ) && ! empty ( $ item -> tax ) ? $ item -> tax : 0 ) , 'shipping' => is_array ( $ item ) ? ( array_key_exists ( 'shipping' , $ item ) ? $ item [ 'shipping' ] : 0 ) : ( isset ( $ item -> shipping ) && ! empty ( $ item -> shipping ) ? $ item -> shipping : 0 ) , 'currency' => Config :: get ( 'shop.currency' ) , 'quantity' => $ quantity , 'class' => is_array ( $ item ) ? null : $ reflection -> getName ( ) , 'reference_id' => is_array ( $ item ) ? null : $ item -> shopId , ] ) ; } else { $ cartItem -> quantity = $ quantityReset ? $ quantity : $ cartItem -> quantity + $ quantity ; $ cartItem -> save ( ) ; } $ this -> resetCalculations ( ) ; return $ this ; }
5227	public function bindList ( $ name ) { if ( ! isset ( $ this -> listBindings [ $ name ] ) ) { $ this -> listBindings [ $ name ] = $ this -> addBinding ( new ListBinding ( $ name ) ) ; } return $ this -> listBindings [ $ name ] ; }
6375	public function first ( ) : Optional { try { return Optional :: ofNullable ( $ this -> get ( 0 ) ) ; } catch ( OutOfBoundsException $ e ) { return Optional :: absent ( ) ; } }
1026	private function doesFragmentConditionMatch ( $ fragment , ObjectType $ type ) { $ typeConditionNode = $ fragment -> typeCondition ; if ( $ typeConditionNode === null ) { return true ; } $ conditionalType = TypeInfo :: typeFromAST ( $ this -> exeContext -> schema , $ typeConditionNode ) ; if ( $ conditionalType === $ type ) { return true ; } if ( $ conditionalType instanceof AbstractType ) { return $ this -> exeContext -> schema -> isPossibleType ( $ conditionalType , $ type ) ; } return false ; }
7598	public function render ( $ sGlyphicon , array $ aGlyphiconAttributes = null ) { if ( ! is_scalar ( $ sGlyphicon ) ) { throw new InvalidArgumentException ( 'Glyphicon expects a scalar value, "' . gettype ( $ sGlyphicon ) . '" given' ) ; } if ( empty ( $ aGlyphiconAttributes ) ) { $ aGlyphiconAttributes = array ( 'class' => 'glyphicon' ) ; } else { if ( empty ( $ aGlyphiconAttributes [ 'class' ] ) ) { $ aGlyphiconAttributes [ 'class' ] = 'glyphicon' ; } elseif ( ! preg_match ( '/(\s|^)glyphicon(\s|$)/' , $ aGlyphiconAttributes [ 'class' ] ) ) { $ aGlyphiconAttributes [ 'class' ] .= ' glyphicon' ; } } if ( strpos ( 'glyphicon-' , $ sGlyphicon ) !== 0 ) { $ sGlyphicon = 'glyphicon-' . $ sGlyphicon ; } if ( ! preg_match ( '/(\s|^)' . preg_quote ( $ sGlyphicon , '/' ) . '(\s|$)/' , $ aGlyphiconAttributes [ 'class' ] ) ) { $ aGlyphiconAttributes [ 'class' ] .= ' ' . $ sGlyphicon ; } return sprintf ( static :: $ glyphiconFormat , $ this -> createAttributesString ( $ aGlyphiconAttributes ) ) ; }
2291	public function onKernelTerminate ( PostResponseEvent $ event ) : void { if ( ! $ this -> framework -> isInitialized ( ) ) { return ; } $ request = $ event -> getRequest ( ) ; if ( ! $ request -> isMethod ( Request :: METHOD_GET ) ) { return ; } if ( preg_match ( '~(?:^|/)' . preg_quote ( $ this -> fragmentPath , '~' ) . '/~' , $ request -> getPathInfo ( ) ) ) { return ; } $ frontend = $ this -> framework -> getAdapter ( Frontend :: class ) ; $ frontend -> indexPageIfApplicable ( $ event -> getResponse ( ) ) ; }
12383	public static function perMonth ( $ months = 1 , $ date_format = "Y-m" ) { $ hits_per_month = [ ] ; for ( $ i = 1 ; $ i <= $ months ; $ i ++ ) { $ hits_count = self :: interval ( Carbon :: now ( ) -> subMonths ( $ i ) -> firstOfMonth ( ) , Carbon :: now ( ) -> subMonths ( $ i ) -> lastOfMonth ( ) ) ; $ hits_per_month [ Carbon :: now ( ) -> subMonths ( $ i ) -> format ( $ date_format ) ] = $ hits_count ; } return $ hits_per_month ; }
12493	public static function groupBy ( $ field ) { if ( ! ( gettype ( $ field ) == "string" || $ field instanceof Key || $ field instanceof Raw ) ) { throw new ClusterpointException ( "\"->group()\" function: passed field selector is not in valid format." , 9002 ) ; } if ( $ field instanceof Key ) { $ field = self :: field ( "{$field}" ) ; } return "{$field}" ; }
11154	public function getArrayKeyByPowers ( array $ powers ) { if ( empty ( $ powers ) ) { throw new InvalidArgumentException ( 'Empty powers set' ) ; } $ powersSum = 0 ; foreach ( $ powers as $ power ) { if ( $ power < 0 ) { throw new InvalidArgumentException ( 'Negative power found' ) ; } $ powersSum += $ power ; } if ( $ powersSum <= 0 ) { throw new InvalidArgumentException ( 'The sum of powers must be positive' ) ; } $ randomValue = $ this -> generator -> getFloat ( 0 , $ powersSum ) ; $ currentSum = 0 ; $ result = null ; foreach ( $ powers as $ key => $ power ) { $ currentSum += $ power ; if ( $ currentSum >= $ randomValue ) { $ result = $ key ; break ; } } return $ key ; }
10318	function getBlocks ( $ fromDate = null , $ toDate = null , $ contactIds = null , $ contactEmails = null , $ contactExternalIds = null , $ reasons = null , $ oldStatus = null , $ newStatus = null , $ excludeAnonymousBlocks = false , $ standardFields = null , $ customFields = null , $ pageIndex = 1 , $ pageSize = 100 ) { $ params = $ this -> createQueryParameters ( $ pageIndex , $ pageSize , $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , null , null , null ) ; $ params = $ this -> appendArrayFields ( $ params , "standard_field" , $ standardFields ) ; $ params = $ this -> appendArrayFields ( $ params , "custom_field" , $ customFields ) ; if ( isset ( $ embedEmailClientInfos ) ) $ params [ 'embed_email_client_infos' ] = ( $ embedEmailClientInfos == true ) ? "true" : "false" ; if ( isset ( $ excludeAnonymousBlocks ) ) $ params [ 'exclude_anonymous_blocks' ] = ( $ excludeAnonymousBlocks == true ) ? "true" : "false" ; $ params = $ this -> appendArrayFields ( $ params , "reasons" , $ reasons ) ; if ( isset ( $ oldStatus ) ) $ params [ 'old_status' ] = $ oldStatus ; if ( isset ( $ newStatus ) ) $ params [ 'new_status' ] = $ newStatus ; return $ this -> get ( 'reports/blocks' , $ params ) ; }
8866	private function runTask ( TaskInterface $ task , PayloadInterface $ payload ) { $ this -> logTask ( $ task , LogLevel :: INFO , 'Starting execution.' ) ; try { if ( ! $ task -> unless ( ) ) { $ this -> dispatch ( 'runner.task.unless' , $ task , $ payload ) ; $ this -> logTask ( $ task , LogLevel :: INFO , 'Skipping because unless() returned boolean false.' ) ; return ; } $ this -> dispatch ( 'runner.task.start' , $ task , $ payload ) ; $ task -> setUp ( ) ; $ exitCode = ( int ) $ task -> run ( $ payload ) ? : 0 ; $ task -> tearDown ( ) ; if ( $ task -> isFailOnError ( ) && $ exitCode !== 0 ) { throw new FailException ( sprintf ( 'Task: %s failed with exit code %s' , get_class ( $ task ) , $ exitCode ) ) ; } $ message = sprintf ( 'Task exited with status code %s' , $ exitCode ) ; if ( $ exitCode === 0 ) { $ this -> logTask ( $ task , LogLevel :: INFO , $ message ) ; } else { $ this -> logTask ( $ task , LogLevel :: WARNING , $ message ) ; } $ this -> dispatch ( 'runner.task.success' , $ task , $ payload , $ exitCode ) ; $ task -> markAsSuccessfullyExecuted ( ) ; } catch ( SkipException $ e ) { $ this -> logTask ( $ task , LogLevel :: INFO , 'Skipping.' ) ; $ this -> dispatch ( 'runner.task.skip' , $ task , $ payload ) ; } catch ( RetryException $ e ) { $ this -> logTask ( $ task , LogLevel :: NOTICE , 'Retry thrown. Starting again.' ) ; $ this -> dispatch ( 'runner.task.retry' , $ task , $ payload ) ; if ( ! $ task -> getMaxRetries ( ) ) { throw new LogicException ( 'A retry exception was thrown, but no retries instance was set.' ) ; } $ task -> getMaxRetries ( ) -> increase ( ) ; $ this -> runTask ( $ task , $ payload ) ; return ; } catch ( FailException $ e ) { $ this -> logTask ( $ task , LogLevel :: WARNING , sprintf ( 'Failure thrown. Given message: %s' , $ e -> getMessage ( ) ) ) ; $ exitCode = $ e -> getCode ( ) ; if ( is_int ( $ exitCode ) ) { $ this -> dispatch ( 'runner.task.failure' , $ task , $ payload , $ exitCode ) ; } else { $ this -> dispatch ( 'runner.task.failure' , $ task , $ payload ) ; } throw $ e ; } $ this -> logTask ( $ task , LogLevel :: INFO , 'Execution successful.' ) ; }
4587	public function setStaffUuid ( ? string $ staffUuid ) { $ this -> staffUuid = $ staffUuid ; $ this -> _staffUuid = true ; return $ this ; }
12113	public function getUnmappedForeignKeys ( ) { $ mappedForeign = ArrayHelper :: getColumn ( $ this -> _map , 'foreignKey' ) ; $ u = array_diff ( array_keys ( $ this -> foreignModel -> meta -> schema -> columns ) , $ mappedForeign ) ; unset ( $ u [ $ this -> foreignPrimaryKeyName ] ) ; return $ u ; }
10035	function unsubscribeContactByExternalId ( $ externalId , $ mailingId = "" , $ reasons = null ) { $ queryParameters = array ( ) ; if ( ! empty ( $ mailingId ) ) { $ queryParameters [ 'mailingId' ] = $ mailingId ; } if ( ! empty ( $ reasons ) ) { if ( is_array ( $ reasons ) ) { $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , 'reason' , $ reasons ) ; } else { $ queryParameters [ 'reason' ] = urlencode ( $ reasons ) ; } } $ encodedExternalId = utf8_encode ( $ externalId ) ; return $ this -> delete ( "contacts/externalid/${encodedExternalId}/unsubscribe" , $ queryParameters ) ; }
12553	public function save ( $ path , $ name = null ) { if ( ! file_exists ( $ path ) ) { mkdir ( $ path , 0777 , true ) ; } $ destinationPath = rtrim ( $ path , '/' ) ; if ( $ name ) { $ destinationPath .= '/' . $ name ; } else { $ destinationPath .= '/' . $ this -> name ; } if ( ! copy ( $ this -> tmpName , $ destinationPath ) ) { $ reason = 'Unknown' ; if ( ! file_exists ( $ path ) ) { $ reason = 'Path "' . $ path . '" not exists.' ; } else if ( ! is_writeable ( $ path ) ) $ reason = 'Path "' . $ path . '" required permission to write.' ; throw new FileFailSavedException ( $ reason ) ; } }
1372	protected function isFillable ( $ field , $ record ) { if ( in_array ( $ field , $ fillable = $ this -> getFillable ( $ record ) ) ) { return true ; } if ( $ this -> isGuarded ( $ field , $ record ) ) { return false ; } return empty ( $ fillable ) ; }
9436	public function get ( ) { if ( $ this -> r || $ this -> i ) { if ( ! is_object ( $ this -> i ) ) { return new Complex ( self :: random ( $ this -> r -> min , $ this -> r -> max ) , 0 ) ; } if ( ! is_object ( $ this -> r ) ) { return new Complex ( 0 , self :: random ( $ this -> i -> min , $ this -> i -> max ) ) ; } return new Complex ( self :: random ( $ this -> r -> min , $ this -> r -> max ) , self :: random ( $ this -> i -> min , $ this -> i -> max ) ) ; } if ( $ this -> rho || $ this -> theta ) { if ( ! is_object ( $ this -> theta ) ) { return new Complex ( self :: random ( $ this -> rho -> min , $ this -> rho -> max ) , 0 , Complex :: TRIGONOMETRIC ) ; } if ( ! is_object ( $ this -> rho ) ) { return new Complex ( 0 , self :: random ( $ this -> theta -> min , $ this -> theta -> max ) , Complex :: TRIGONOMETRIC ) ; } return new Complex ( self :: random ( $ this -> rho -> min , $ this -> rho -> max ) , self :: random ( $ this -> theta -> min , $ this -> theta -> max ) , Complex :: TRIGONOMETRIC ) ; } }
9225	private function preprocessData ( $ data ) { if ( is_array ( $ data ) && ! array_key_exists ( self :: PARAM_PER_PAGE , $ data ) ) { $ data [ self :: PARAM_PER_PAGE ] = CanvasArray :: MAXIMUM_PER_PAGE ; } return $ data ; }
4400	protected function saveTransationRef ( \ Aimeos \ MShop \ Order \ Item \ Base \ Iface $ baseItem , $ ref ) { $ type = \ Aimeos \ MShop \ Order \ Item \ Base \ Service \ Base :: TYPE_PAYMENT ; $ serviceItem = $ this -> getBasketService ( $ baseItem , $ type , $ this -> getServiceItem ( ) -> getCode ( ) ) ; $ attr = array ( 'TRANSACTIONID' => $ ref ) ; $ this -> setAttributes ( $ serviceItem , $ attr , 'payment/omnipay' ) ; $ this -> saveOrderBase ( $ baseItem ) ; }
4853	public function getCurrentRealRows ( $ table = null ) { $ table = $ table ? : $ this -> getCurrentTable ( ) ; if ( ! isset ( $ this -> currentRealRows [ $ table ] ) || ! $ this -> currentRealRows [ $ table ] ) { $ fields = $ this -> getPreparedFields ( ) [ $ table ] ; $ this -> currentRealRows [ $ table ] = $ this -> getRealRow ( $ fields , $ table ) ; } return $ this -> currentRealRows [ $ table ] ; }
3167	private function isThemeSwitcherEnabled ( ) { $ extensionsManager = $ this -> getServiceLocator ( ) -> get ( \ common_ext_ExtensionsManager :: SERVICE_ID ) ; $ config = $ extensionsManager -> getExtensionById ( "taoTests" ) -> getConfig ( "test_runner_plugin_registry" ) ; return array_key_exists ( self :: TOOL_ITEM_THEME_SWITCHER_KEY , $ config ) && $ config [ self :: TOOL_ITEM_THEME_SWITCHER_KEY ] [ "active" ] === true ; }
294	public function setAttribute ( $ name , $ value ) { if ( $ this -> hasAttribute ( $ name ) ) { if ( ! empty ( $ this -> _relationsDependencies [ $ name ] ) && ( ! array_key_exists ( $ name , $ this -> _attributes ) || $ this -> _attributes [ $ name ] !== $ value ) ) { $ this -> resetDependentRelations ( $ name ) ; } $ this -> _attributes [ $ name ] = $ value ; } else { throw new InvalidArgumentException ( get_class ( $ this ) . ' has no attribute named "' . $ name . '".' ) ; } }
5103	public static function appendSet ( $ values , $ forceExist = false ) { if ( $ forceExist && ! $ values ) throw new SquidException ( 'SET clause must be present for this type of command!' ) ; return Assembly :: append ( 'SET' , $ values , ', ' ) ; }
6942	protected function scheduleSubjectStockUnitChangeEvent ( StockUnitInterface $ stockUnit ) { $ this -> persistenceHelper -> scheduleEvent ( $ this -> getSubjectStockUnitChangeEventName ( ) , new SubjectStockUnitEvent ( $ stockUnit ) ) ; }
9271	protected function setUri ( $ uriToSet ) { $ uri_parts = [ ] ; array_push ( $ uri_parts , 'api' ) ; array_push ( $ uri_parts , config ( 'ckan_api.api_version' ) ) ; array_push ( $ uri_parts , trim ( $ uriToSet , '/' ) ) ; $ uri_parts = array_filter ( $ uri_parts ) ; $ this -> uri = implode ( '/' , $ uri_parts ) ; }
11775	protected function getIsEnabled ( ) : \ Illuminate \ Database \ Eloquent \ Model { $ result = Model \ Setting :: find ( 1 ) ; $ result -> value = ( bool ) $ result -> value ; return $ result ; }
5423	public function invoke ( $ method ) { $ trap = SimpleTest :: getContext ( ) -> get ( 'SimpleExceptionTrap' ) ; $ trap -> clear ( ) ; try { $ has_thrown = false ; parent :: invoke ( $ method ) ; } catch ( Exception $ exception ) { $ has_thrown = true ; if ( ! $ trap -> isExpected ( $ this -> getTestCase ( ) , $ exception ) ) { $ this -> getTestCase ( ) -> exception ( $ exception ) ; } $ trap -> clear ( ) ; } if ( $ message = $ trap -> getOutstanding ( ) ) { $ this -> getTestCase ( ) -> fail ( $ message ) ; } if ( $ has_thrown ) { try { parent :: getTestCase ( ) -> tearDown ( ) ; } catch ( Exception $ e ) { } } }
631	public function batchInsert ( $ table , $ columns , $ rows ) { $ table = $ this -> db -> quoteSql ( $ table ) ; $ columns = array_map ( function ( $ column ) { return $ this -> db -> quoteSql ( $ column ) ; } , $ columns ) ; $ params = [ ] ; $ sql = $ this -> db -> getQueryBuilder ( ) -> batchInsert ( $ table , $ columns , $ rows , $ params ) ; $ this -> setRawSql ( $ sql ) ; $ this -> bindValues ( $ params ) ; return $ this ; }
6300	public function render ( $ mainName = 'default' , $ barName = false , array $ data = null ) { if ( $ data === null ) { $ data = [ 'title' => 'Navigation' , 'side' => 'dropdown' , 'inverse' => true ] ; } $ main = $ this -> getMain ( $ mainName ) ; if ( is_string ( $ barName ) ) { $ bar = $ this -> getBar ( $ barName ) ; if ( empty ( $ bar ) ) { $ bar = false ; } } else { $ bar = false ; } return $ this -> view -> make ( $ this -> name , array_merge ( $ data , [ 'main' => $ main , 'bar' => $ bar ] ) ) -> render ( ) ; }
2077	public function purgeScriptCache ( ) { foreach ( array ( 'assets/js' , 'assets/css' ) as $ dir ) { $ objFolder = new Folder ( $ dir ) ; $ objFolder -> purge ( ) ; } $ this -> import ( StyleSheets :: class , 'StyleSheets' ) ; $ this -> StyleSheets -> updateStyleSheets ( ) ; $ this -> purgePageCache ( ) ; $ this -> log ( 'Purged the script cache' , __METHOD__ , TL_CRON ) ; }
6973	private function buildFieldValue ( ClassMetadata $ metadata , $ propertyPath , $ value ) { $ type = $ metadata -> getTypeOfField ( $ propertyPath ) ; switch ( $ type ) { case 'smallint' : case 'integer' : case 'bigint' : if ( ! is_int ( $ value ) ) { throw new \ Exception ( 'Expected integer.' ) ; } return intval ( $ value ) ; case 'boolean' : if ( ! is_bool ( $ value ) ) { throw new \ Exception ( 'Expected boolean.' ) ; } return ( bool ) $ value ; case 'float' : case 'double' : case 'decimal' : if ( ! is_numeric ( $ value ) ) { throw new \ Exception ( 'Expected float.' ) ; } return floatval ( $ value ) ; case 'datetime' : return new \ DateTime ( $ value ) ; case 'string' : return ( string ) $ value ; } throw new \ Exception ( "Unsupported field type '$type' for path '$propertyPath'." ) ; }
2458	public function undo ( ) { $ objRecords = $ this -> Database -> prepare ( "SELECT * FROM " . $ this -> strTable . " WHERE id=?" ) -> limit ( 1 ) -> execute ( $ this -> intId ) ; if ( $ objRecords -> numRows < 1 ) { $ this -> redirect ( $ this -> getReferer ( ) ) ; } $ error = false ; $ query = $ objRecords -> query ; $ data = StringUtil :: deserialize ( $ objRecords -> data ) ; if ( ! \ is_array ( $ data ) ) { $ this -> redirect ( $ this -> getReferer ( ) ) ; } $ arrFields = array ( ) ; foreach ( $ data as $ table => $ fields ) { $ this -> loadDataContainer ( $ table ) ; if ( ! isset ( $ arrFields [ $ table ] ) ) { $ arrFields [ $ table ] = array_flip ( $ this -> Database -> getFieldNames ( $ table ) ) ; } foreach ( $ fields as $ row ) { $ row = array_intersect_key ( $ row , $ arrFields [ $ table ] ) ; $ objInsertStmt = $ this -> Database -> prepare ( "INSERT INTO " . $ table . " %s" ) -> set ( $ row ) -> execute ( ) ; if ( $ objInsertStmt -> affectedRows < 1 ) { $ error = true ; } if ( \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ table ] [ 'config' ] [ 'onundo_callback' ] ) ) { foreach ( $ GLOBALS [ 'TL_DCA' ] [ $ table ] [ 'config' ] [ 'onundo_callback' ] as $ callback ) { if ( \ is_array ( $ callback ) ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ table , $ row , $ this ) ; } elseif ( \ is_callable ( $ callback ) ) { $ callback ( $ table , $ row , $ this ) ; } } } } } if ( ! $ error ) { $ this -> log ( 'Undone ' . $ query , __METHOD__ , TL_GENERAL ) ; $ this -> Database -> prepare ( "DELETE FROM " . $ this -> strTable . " WHERE id=?" ) -> limit ( 1 ) -> execute ( $ this -> intId ) ; } $ this -> redirect ( $ this -> getReferer ( ) ) ; }
11099	public static function maxCount ( ) { $ array = \ func_get_args ( ) ; if ( ! \ is_array ( $ array ) ) { return 0 ; } $ maxCnt = 0 ; foreach ( $ array as $ item ) { if ( ! \ is_array ( $ item ) ) { continue ; } $ cnt = \ count ( $ item ) ; $ maxCnt = $ cnt > $ maxCnt ? $ cnt : $ maxCnt ; } return $ maxCnt ; }
9608	public function angleBetween ( self $ b ) { $ denominator = $ this -> length ( ) * $ b -> length ( ) ; if ( $ denominator == 0 ) { throw new Exception ( 'Cannot divide by zero' ) ; } return acos ( $ this -> dotProduct ( $ b ) / $ denominator ) ; }
10609	public function classifiedAnswerAction ( ) { $ request = $ this -> getRequest ( ) ; $ response = $ this -> getResponse ( ) ; if ( ! $ request -> isPost ( ) ) { $ response -> setStatusCode ( Response :: STATUS_CODE_500 ) ; return new JsonModel ( array ( 'status' => 'danger' , 'message' => 'Invalid method call' ) ) ; } $ userService = $ this -> getServiceLocator ( ) -> get ( 'user.service.user' ) ; $ data = array_merge_recursive ( $ this -> params ( ) -> fromPost ( ) , Json :: decode ( $ request -> getContent ( ) , Json :: TYPE_ARRAY ) ) ; try { $ response -> setStatusCode ( Response :: STATUS_CODE_200 ) ; $ userService -> classifiedAnswer ( $ data ) ; $ returnData = array ( 'status' => 'success' , 'message' => 'La tua risposta  stata inviata!' ) ; } catch ( \ Exception $ e ) { $ response -> setStatusCode ( Response :: STATUS_CODE_500 ) ; $ returnData = @ unserialize ( $ e -> getMessage ( ) ) ; if ( ! is_array ( $ returnData ) ) { $ returnData = array ( 'status' => 'danger' , 'message' => $ e -> getMessage ( ) ) ; } } return new JsonModel ( $ returnData ) ; }
3177	public static function checkTimedSectionExit ( RunnerServiceContext $ context , $ nextPosition ) { $ timerConfig = $ context -> getTestConfig ( ) -> getConfigValue ( 'timer' ) ; if ( empty ( $ timerConfig [ 'keepUpToTimeout' ] ) ) { $ session = $ context -> getTestSession ( ) ; $ route = $ session -> getRoute ( ) ; $ section = $ session -> getCurrentAssessmentSection ( ) ; $ limits = $ section -> getTimeLimits ( ) ; if ( ! ( $ context instanceof QtiRunnerServiceContext ) || ! $ context -> isAdaptive ( ) ) { $ isJumpOutOfSection = false ; if ( ( $ nextPosition >= 0 ) && ( $ nextPosition < $ route -> count ( ) ) ) { $ nextSection = $ route -> getRouteItemAt ( $ nextPosition ) ; $ isJumpOutOfSection = ( $ section -> getIdentifier ( ) !== $ nextSection -> getAssessmentSection ( ) -> getIdentifier ( ) ) ; } if ( $ isJumpOutOfSection && $ limits != null && $ limits -> hasMaxTime ( ) ) { $ assessmentItemRefs = $ section -> getComponentsByClassName ( 'assessmentItemRef' ) ; foreach ( $ assessmentItemRefs as $ assessmentItemRef ) { $ itemSessions = $ session -> getAssessmentItemSessions ( $ assessmentItemRef -> getIdentifier ( ) ) ; if ( $ itemSessions !== false ) { foreach ( $ itemSessions as $ itemSession ) { $ itemSession -> endItemSession ( ) ; } } } } } } }
12713	protected function resolve ( $ instance , $ parameters = [ ] ) { if ( $ this -> isInterface ( $ instance ) ) { return $ this -> getConcreteFromInterface ( $ instance ) ; } try { return $ this -> getResolvedSingleton ( $ instance ) ; } catch ( \ Exception $ e ) { } $ concrete = $ this -> getConcrete ( $ instance ) ; if ( ! is_null ( $ concrete ) ) { $ object = $ this -> build ( $ instance , $ concrete instanceof \ Closure ? $ concrete ( $ this ) : $ concrete ) ; if ( $ this -> isShared ( $ instance ) ) { $ this -> markAsResolved ( $ instance , $ object , 'singleton' ) ; } else { $ this -> markAsResolved ( $ instance , $ object ) ; } } else { $ object = $ this -> build ( $ instance , $ parameters ) ; } return $ object ; }
3549	protected function registerRepository ( ) { $ this -> app -> singleton ( CachingRepository :: class , function ( Container $ app ) { $ repo = new GitHubRepository ( GuzzleFactory :: make ( ) , $ app -> config -> get ( 'emoji.token' ) ) ; $ cache = $ app -> cache -> store ( $ app -> config -> get ( 'emoji.connection' ) ) ; $ key = $ app -> config -> get ( 'emoji.key' , 'emoji' ) ; $ life = ( int ) $ app -> config -> get ( 'emoji.life' , 10080 ) ; return new CachingRepository ( $ repo , $ cache , $ key , $ life ) ; } ) ; $ this -> app -> alias ( CachingRepository :: class , RepositoryInterface :: class ) ; }
315	public function setVendorPath ( $ path ) { $ this -> _vendorPath = Yii :: getAlias ( $ path ) ; Yii :: setAlias ( '@vendor' , $ this -> _vendorPath ) ; Yii :: setAlias ( '@bower' , $ this -> _vendorPath . DIRECTORY_SEPARATOR . 'bower' ) ; Yii :: setAlias ( '@npm' , $ this -> _vendorPath . DIRECTORY_SEPARATOR . 'npm' ) ; }
5703	public function bindGridField ( Form $ form , GridFieldDetailForm_ItemRequest $ request ) { $ this -> setForm ( $ form ) ; $ this -> gridFieldRequest = $ request ; return $ this ; }
12185	public function getNiceId ( $ queryRole ) { $ roleType = $ this -> roleType ( $ queryRole ) ; if ( empty ( $ roleType ) ) { return false ; } return implode ( ':' , [ $ this -> role ( $ queryRole ) , $ roleType -> systemId ] ) ; }
10817	public static function info ( $ messages , $ linebreak = true , $ length = 0 ) { $ separator = $ linebreak ? "\n" : '' ; self :: write ( $ messages , 'info' , $ length , $ separator ) ; }
1772	public function getAttribute ( $ strKey ) { if ( ! isset ( $ this -> arrAttributes [ $ strKey ] ) ) { return '' ; } $ varValue = $ this -> arrAttributes [ $ strKey ] ; if ( $ strKey == 'autofocus' ) { unset ( $ this -> arrAttributes [ $ strKey ] ) ; } if ( $ strKey == 'disabled' || $ strKey == 'readonly' || $ strKey == 'required' || $ strKey == 'autofocus' || $ strKey == 'multiple' ) { return ' ' . $ strKey ; } elseif ( $ varValue != '' ) { return ' ' . $ strKey . '="' . StringUtil :: specialchars ( $ varValue ) . '"' ; } return '' ; }
704	public function setDefaultRoles ( $ roles ) { if ( is_array ( $ roles ) ) { $ this -> defaultRoles = $ roles ; } elseif ( $ roles instanceof \ Closure ) { $ roles = call_user_func ( $ roles ) ; if ( ! is_array ( $ roles ) ) { throw new InvalidValueException ( 'Default roles closure must return an array' ) ; } $ this -> defaultRoles = $ roles ; } else { throw new InvalidArgumentException ( 'Default roles must be either an array or a callable' ) ; } }
10579	private function codesEqual ( string $ known , string $ given ) : bool { if ( strlen ( $ given ) !== strlen ( $ known ) ) { return false ; } $ res = 0 ; $ knownLen = strlen ( $ known ) ; for ( $ i = 0 ; $ i < $ knownLen ; ++ $ i ) { $ res |= ( ord ( $ known [ $ i ] ) ^ ord ( $ given [ $ i ] ) ) ; } return $ res === 0 ; }
6525	public function createMessage ( array $ data = [ ] ) { $ className = $ this -> className ; if ( empty ( $ data ) ) { return $ className :: create ( ) ; } return $ className :: fromArray ( $ data ) ; }
8295	public function open ( ) { if ( $ this -> isOpened ( ) ) { return ; } $ this -> handle = @ fopen ( $ this -> filePath , self :: OPEN_MODE ) ; if ( $ this -> handle === false ) { throw new \ RuntimeException ( "Could not open file for writing: " . $ this -> filePath ) ; } if ( ! $ this -> lock ( LOCK_EX ) ) { $ this -> close ( ) ; throw new \ RuntimeException ( "Could not aquire an exclusive lock for " . $ this -> filePath ) ; } if ( $ this -> options [ "backup" ] ) { $ this -> createBkFile ( ) ; } $ this -> writeErrors = false ; }
5695	public function nestedFormSave ( $ data , $ form , $ request ) { $ formAction = $ this -> getFormActionFromRequest ( $ request ) ; $ actionName = $ formAction -> getButtonName ( ) ; $ this -> record -> $ actionName ( $ data , $ form , $ request ) ; return Controller :: curr ( ) -> redirectBack ( ) ; }
3282	public function setExt ( string $ ext ) { if ( substr ( $ ext , 0 , 1 ) !== '.' ) { $ ext = '.' . $ ext ; } $ this -> config [ 'ext' ] = $ ext ; }
2937	public function restore ( $ filePath = null ) { if ( is_null ( $ filePath ) ) { $ latestBackup = $ this -> getLatestBackup ( ) ; if ( is_null ( $ latestBackup ) ) { throw new NoBackupAvailableException ( "There are no available backups!" ) ; } $ filePath = $ latestBackup [ 'filepath' ] ; } if ( ! is_file ( $ filePath ) ) { throw new FileNotFoundException ( "File does not exist at path {$filePath}" ) ; } copy ( $ filePath , $ this -> filePath ) ; $ this -> writer -> setBuffer ( $ this -> getContent ( ) ) ; return $ this ; }
6184	public function display ( $ type = 'all' , $ print = false ) { $ messages = '' ; $ data = '' ; if ( in_array ( $ type , $ this -> msgTypes ) ) { $ flashMessages = $ this -> driver -> get ( 'flash_messages' ) ; foreach ( $ flashMessages [ $ type ] as $ msg ) { $ messages .= $ msg ; } $ data .= $ messages ; $ this -> clear ( $ type ) ; } elseif ( $ type === 'all' ) { $ flashMessages = $ this -> driver -> get ( 'flash_messages' ) ; foreach ( $ flashMessages as $ type => $ msgArray ) { $ messages = '' ; foreach ( $ msgArray as $ msg ) { $ messages .= $ msg ; } $ data .= $ messages ; } $ this -> clear ( ) ; } else { return false ; } if ( $ print ) { echo $ data ; return null ; } return $ data ; }
6166	protected function writeProgress ( $ progress ) { $ this -> progress = ! $ this -> flawless && $ progress === '.' ? $ this -> formatWithColor ( 'fg-red' , '!' ) : $ progress ; ++ $ this -> numTestsRun ; }
6302	protected function getBar ( $ name = 'default' ) { $ this -> events -> fire ( 'navigation.bar' , [ [ 'name' => $ name ] ] ) ; if ( $ name !== 'default' && ! array_key_exists ( $ name , $ this -> bar ) ) { $ name = 'default' ; } if ( ! array_key_exists ( $ name , $ this -> bar ) ) { $ this -> bar [ $ name ] = [ ] ; } $ nav = $ this -> bar [ $ name ] ; return $ this -> process ( $ nav ) ; }
10965	public static function getStandardPort ( $ scheme = null ) { if ( $ scheme === null ) { $ scheme = self :: getScheme ( ) ; } if ( isset ( self :: $ schemes [ $ scheme ] ) ) { return self :: $ schemes [ $ scheme ] ; } return 0 ; }
3148	public function isItemCompleted ( RunnerServiceContext $ context , $ routeItem , $ itemSession , $ partially = true ) { if ( $ context instanceof QtiRunnerServiceContext && $ context -> isAdaptive ( ) ) { $ itemIdentifier = $ context -> getCurrentAssessmentItemRef ( ) -> getIdentifier ( ) ; $ itemState = $ this -> getItemState ( $ context , $ itemIdentifier ) ; if ( $ itemState !== null ) { $ itemResponse = [ ] ; foreach ( $ itemState as $ key => $ value ) { if ( isset ( $ value [ 'response' ] ) ) { $ itemResponse [ $ key ] = $ value [ 'response' ] ; } } $ responses = $ this -> parsesItemResponse ( $ context , $ itemIdentifier , $ itemResponse ) ; $ excludedResponseVariables = array ( 'numAttempts' , 'duration' ) ; foreach ( $ responses as $ var ) { if ( $ var instanceof ResponseVariable && in_array ( $ var -> getIdentifier ( ) , $ excludedResponseVariables ) === false ) { $ value = $ var -> getValue ( ) ; $ defaultValue = $ var -> getDefaultValue ( ) ; if ( Utils :: isNull ( $ value ) === true ) { if ( Utils :: isNull ( $ defaultValue ) === ( ( $ partially ) ? false : true ) ) { return ( ( $ partially ) ? true : false ) ; } } else { if ( $ value -> equals ( $ defaultValue ) === ( ( $ partially ) ? false : true ) ) { return ( ( $ partially ) ? true : false ) ; } } } } } return ( ( $ partially ) ? false : true ) ; } else { return TestRunnerUtils :: isItemCompleted ( $ routeItem , $ itemSession , $ partially ) ; } }
8991	public function build ( $ attributes = null ) { if ( $ attributes instanceof \ ElggEntity ) { return $ attributes ; } if ( is_numeric ( $ attributes ) ) { return $ this -> get ( $ attributes ) ; } $ attributes = ( array ) $ attributes ; if ( ! empty ( $ attributes [ 'guid' ] ) ) { return $ this -> get ( $ attributes [ 'guid' ] ) ; } $ type = elgg_extract ( 'type' , $ attributes , 'object' ) ; $ subtype = elgg_extract ( 'subtype' , $ attributes , ELGG_ENTITIES_ANY_VALUE ) ; unset ( $ attributes [ 'type' ] ) ; unset ( $ attributes [ 'subtype' ] ) ; $ class = get_subtype_class ( $ type , $ subtype ) ; if ( class_exists ( $ class ) ) { $ entity = new $ class ( ) ; } else { switch ( $ type ) { case 'object' : $ entity = new \ ElggObject ( ) ; $ entity -> subtype = $ subtype ; break ; case 'user' : $ entity = new \ ElggUser ( ) ; $ entity -> subtype = $ subtype ; break ; case 'group' : $ entity = new \ ElggGroup ( ) ; $ entity -> subtype = $ subtype ; break ; } } foreach ( $ attributes as $ key => $ value ) { if ( in_array ( $ key , $ this -> getAttributeNames ( $ entity ) ) ) { $ entity -> $ key = $ value ; } } return $ entity ; }
11233	public function run ( $ argument , Message $ message , ApiClient $ apiClient ) { $ this -> setApiClient ( $ apiClient ) ; $ this -> execute ( $ argument , $ message ) ; }
6401	public function getResource ( $ resource ) : ? string { Preconditions :: checkState ( $ this -> isPsr0Compatible ( ) , "Class '%s' must be PSR-0 compatible!" , $ this -> getName ( ) ) ; $ slashedFileName = $ this -> getSlashedFileName ( ) ; $ filePath = $ resource [ 0 ] == '/' ? str_replace ( "/{$this->getSlashedName()}.php" , '' , $ slashedFileName ) . $ resource : dirname ( $ slashedFileName ) . '/' . $ resource ; return is_file ( $ filePath ) ? $ filePath : null ; }
9882	private function writeSheet ( XMLWriter $ objWriter , $ pSheetname , $ pSheetId = 1 , $ pRelId = 1 , $ sheetState = 'visible' ) { if ( $ pSheetname != '' ) { $ objWriter -> startElement ( 'sheet' ) ; $ objWriter -> writeAttribute ( 'name' , $ pSheetname ) ; $ objWriter -> writeAttribute ( 'sheetId' , $ pSheetId ) ; if ( $ sheetState != 'visible' && $ sheetState != '' ) { $ objWriter -> writeAttribute ( 'state' , $ sheetState ) ; } $ objWriter -> writeAttribute ( 'r:id' , 'rId' . $ pRelId ) ; $ objWriter -> endElement ( ) ; } else { throw new WriterException ( 'Invalid parameters passed.' ) ; } }
8371	protected function shutdown ( ) { $ this -> shutdown = true ; $ this -> args [ 'messages' ] = array_filter ( $ this -> messages , function ( $ message ) { if ( ! isset ( $ message [ 'sent' ] ) || $ message [ 'sent' ] === false ) { return $ message ; } } ) ; $ redis = new Redis ; $ client = new Client ( $ redis ) ; $ client -> push ( static :: class , $ this -> args , 1 , 100 ) ; return true ; }
8046	public function hasData ( $ sec = 0 , $ usec = 0 ) { $ sec = ( int ) $ sec ; $ usec = ( int ) $ usec ; if ( $ sec < 0 ) { $ sec = 0 ; } if ( $ usec < 0 ) { $ usec = 0 ; } $ read = array ( $ this -> socket ) ; $ write = array ( ) ; $ except = array ( ) ; $ sockets = socket_select ( $ read , $ write , $ except , $ sec , $ usec ) ; if ( $ sockets === FALSE ) { return FALSE ; } return $ sockets > 0 ; }
4251	protected function methodTable ( $ array , $ columns = array ( ) ) { if ( ! \ is_array ( $ array ) ) { return $ this -> dump ( $ array ) ; } $ table = array ( ) ; $ keys = $ columns ? : $ this -> debug -> methodTable -> colKeys ( $ array ) ; $ headerVals = $ keys ; foreach ( $ headerVals as $ i => $ val ) { if ( $ val === MethodTable :: SCALAR ) { $ headerVals [ $ i ] = 'value' ; } } \ array_unshift ( $ headerVals , '' ) ; $ table [ ] = $ headerVals ; $ classNames = array ( ) ; if ( $ this -> debug -> abstracter -> isAbstraction ( $ array ) && $ array [ 'traverseValues' ] ) { $ array = $ array [ 'traverseValues' ] ; } foreach ( $ array as $ k => $ row ) { $ values = $ this -> debug -> methodTable -> keyValues ( $ row , $ keys , $ objInfo ) ; foreach ( $ values as $ k2 => $ val ) { if ( $ val === $ this -> debug -> abstracter -> UNDEFINED ) { $ values [ $ k2 ] = null ; } } $ classNames [ ] = $ objInfo [ 'row' ] ? $ objInfo [ 'row' ] [ 'className' ] : '' ; \ array_unshift ( $ values , $ k ) ; $ table [ ] = \ array_values ( $ values ) ; } if ( \ array_filter ( $ classNames ) ) { \ array_unshift ( $ table [ 0 ] , '' ) ; foreach ( $ classNames as $ i => $ className ) { \ array_splice ( $ table [ $ i + 1 ] , 1 , 0 , $ className ) ; } } return $ table ; }
8175	protected function optimizePrintNode ( Twig_NodeInterface $ node , Twig_Environment $ env ) { if ( ! $ node instanceof Twig_Node_Print ) { return $ node ; } $ exprNode = $ node -> getNode ( 'expr' ) ; if ( $ exprNode instanceof Twig_Node_Expression_BlockReference || $ exprNode instanceof Twig_Node_Expression_Parent ) { $ exprNode -> setAttribute ( 'output' , true ) ; return $ exprNode ; } return $ node ; }
3973	public function encodeAttributeValue ( EncodePropertyValueFromWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ metaModel = $ this -> getMetaModel ( $ event -> getEnvironment ( ) ) ; $ value = $ event -> getValue ( ) ; if ( ! ( $ metaModel && $ value ) ) { return ; } $ value = substr ( $ value , \ strlen ( $ metaModel -> getTableName ( ) . '_' ) ) ; $ attribute = $ metaModel -> getAttribute ( $ value ) ; if ( $ attribute ) { $ event -> setValue ( $ attribute -> get ( 'id' ) ) ; } }
12659	private function setExtraLanguagesOutdated ( $ name , $ content ) { foreach ( $ this -> extraLangs as $ lang ) { $ this -> getPageTexts ( $ lang ) ; $ this -> contents [ $ lang ] [ $ name ] [ 'outdated' ] = true ; if ( ! isset ( $ this -> contents [ $ lang ] [ $ name ] [ 'content' ] ) ) { $ this -> contents [ $ lang ] [ $ name ] [ 'content' ] = $ content ; } $ this -> writeTextsToFile ( $ lang ) ; } }
12661	public function createAuthorizerApplication ( $ appId , $ refreshToken ) { $ this -> fetch ( 'authorizer' , function ( $ authorizer ) use ( $ appId , $ refreshToken ) { $ authorizer -> setAppId ( $ appId ) ; $ authorizer -> setRefreshToken ( $ refreshToken ) ; } ) ; return $ this -> fetch ( 'app' , function ( $ app ) { $ app [ 'access_token' ] = $ this -> fetch ( 'authorizer_access_token' ) ; $ app [ 'oauth' ] = $ this -> fetch ( 'oauth' ) ; $ app [ 'server' ] = $ this -> fetch ( 'server' ) ; } ) ; }
7795	protected function statementBody ( $ text ) { switch ( substr ( $ this -> getLine ( '20' , $ text ) , 0 , 4 ) ) { case '940A' : $ this -> format = self :: FORMAT_CLASSIC ; break ; case '940S' : $ this -> format = self :: FORMAT_STRUCTURED ; break ; default : throw new \ RuntimeException ( 'Unknown file format' ) ; } return parent :: statementBody ( $ text ) ; }
9069	public function purge ( $ days_older_than = 60 , \ wpdb $ wpdb ) { $ days_older_than = absint ( $ days_older_than ) ; $ tn = $ this -> table -> get_table_name ( $ wpdb ) ; $ sql = "DELETE FROM {$tn} WHERE time < DATE_SUB(NOW(), INTERVAL $days_older_than DAY)" ; $ wpdb -> query ( $ sql ) ; }
6615	public function hasEndpoint ( $ method , $ endpointName ) { $ methodName = $ this -> parseEndpointName ( $ method , $ endpointName ) ; return $ this -> reflection -> hasMethod ( $ methodName ) ; }
9555	public function getHandler ( ) { if ( $ this -> namer === null ) { $ this -> namer = new GenericNamer ( ) ; } if ( $ this -> filesystem === null ) { throw new \ LogicException ( sprintf ( 'You should set a filesystem for the builder.' ) ) ; } $ handler = new UploadHandler ( $ this -> filesystem , $ this -> namer , $ this -> overwrite ) ; $ validator = $ handler -> getValidator ( ) ; foreach ( $ this -> constraints as $ constraint ) { $ validator -> addConstraint ( $ constraint ) ; } return $ handler ; }
3761	private function getLegend ( PaletteInterface $ palette , $ legendName ) { if ( $ palette -> hasLegend ( $ legendName ) ) { return $ palette -> getLegend ( $ legendName ) ; } $ legend = new Legend ( $ legendName ) ; $ palette -> addLegend ( $ legend ) ; return $ legend ; }
4799	function exec ( $ query ) { $ conn = $ this -> getConn ( ) ; $ sql = $ conn -> quote ( $ query ) ; return $ conn -> exec ( $ sql ) ; }
7690	function OpenXML_ChartGetInfoFromFile ( $ idx , $ Txt = false ) { if ( $ idx === false ) return false ; $ file = $ this -> CdFileLst [ $ idx ] [ 'v_name' ] ; $ relative = ( substr_count ( $ file , '/' ) == 1 ) ? '' : '../' ; $ o = $ this -> OpenXML_Rels_GetObj ( $ file , $ relative . 'charts/' ) ; if ( $ o -> ChartLst === false ) { if ( $ Txt === false ) $ Txt = $ this -> TbsStoreGet ( $ idx , 'OpenXML_ChartGetInfoFromFile' ) ; $ o -> ChartLst = array ( ) ; $ p = 0 ; while ( $ t = clsTbsXmlLoc :: FindStartTag ( $ Txt , 'c:chart' , $ p ) ) { $ rid = $ t -> GetAttLazy ( 'r:id' ) ; $ name = false ; $ title = false ; $ descr = false ; $ parent = clsTbsXmlLoc :: FindStartTag ( $ Txt , 'wp:inline' , $ t -> PosBeg , false ) ; if ( $ parent === false ) $ parent = clsTbsXmlLoc :: FindStartTag ( $ Txt , 'p:nvGraphicFramePr' , $ t -> PosBeg , false ) ; if ( $ parent !== false ) { $ parent -> FindEndTag ( ) ; $ src = $ parent -> GetInnerSrc ( ) ; $ el = clsTbsXmlLoc :: FindStartTagHavingAtt ( $ src , 'title' , 0 ) ; if ( $ el !== false ) $ title = $ el -> GetAttLazy ( 'title' ) ; $ el = clsTbsXmlLoc :: FindStartTagHavingAtt ( $ src , 'descr' , 0 ) ; if ( $ el !== false ) $ descr = $ el -> GetAttLazy ( 'descr' ) ; } if ( isset ( $ o -> TargetLst [ $ rid ] ) ) { $ name = basename ( $ o -> TargetLst [ $ rid ] ) ; if ( substr ( $ name , - 4 ) === '.xml' ) $ name = substr ( $ name , 0 , strlen ( $ name ) - 4 ) ; } $ o -> ChartLst [ ] = array ( 'rid' => $ rid , 'title' => $ title , 'descr' => $ descr , 'name' => $ name ) ; $ p = $ t -> PosEnd ; } } return $ o -> ChartLst ; }
10871	public function existLogin ( string $ login ) : int { return ( int ) $ this -> connection -> select ( self :: COLUMN_ID ) -> from ( $ this -> tableIdentity ) -> where ( [ 'login' => $ login ] ) -> fetchSingle ( ) ; }
817	private function fixFunction ( Tokens $ tokens , $ startFunctionIndex ) { $ endFunctionIndex = $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ startFunctionIndex ) ; $ isMultiline = false ; $ firstWhitespaceIndex = $ this -> findWhitespaceIndexAfterParenthesis ( $ tokens , $ startFunctionIndex , $ endFunctionIndex ) ; $ lastWhitespaceIndex = $ this -> findWhitespaceIndexAfterParenthesis ( $ tokens , $ endFunctionIndex , $ startFunctionIndex ) ; foreach ( [ $ firstWhitespaceIndex , $ lastWhitespaceIndex ] as $ index ) { if ( null === $ index || ! Preg :: match ( '/\R/' , $ tokens [ $ index ] -> getContent ( ) ) ) { continue ; } if ( 'ensure_single_line' !== $ this -> configuration [ 'on_multiline' ] ) { $ isMultiline = true ; continue ; } $ newLinesRemoved = $ this -> ensureSingleLine ( $ tokens , $ index ) ; if ( ! $ newLinesRemoved ) { $ isMultiline = true ; } } for ( $ index = $ endFunctionIndex - 1 ; $ index > $ startFunctionIndex ; -- $ index ) { $ token = $ tokens [ $ index ] ; if ( $ token -> equals ( ')' ) ) { $ index = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ index ) ; continue ; } if ( $ token -> isGivenKind ( CT :: T_ARRAY_SQUARE_BRACE_CLOSE ) ) { $ index = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_ARRAY_SQUARE_BRACE , $ index ) ; continue ; } if ( $ token -> equals ( '}' ) ) { $ index = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_CURLY_BRACE , $ index ) ; continue ; } if ( $ token -> equals ( ',' ) ) { $ this -> fixSpace2 ( $ tokens , $ index ) ; if ( ! $ isMultiline && $ this -> isNewline ( $ tokens [ $ index + 1 ] ) ) { $ isMultiline = true ; break ; } } } return $ isMultiline ; }
210	protected function getValidXmlElementName ( $ name ) { if ( empty ( $ name ) || is_int ( $ name ) || ! $ this -> isValidXmlName ( $ name ) ) { return $ this -> itemTag ; } return $ name ; }
4519	public function get ( string $ key ) { $ parameter = $ this -> repository -> findOneBy ( [ 'key' => $ key ] ) ; if ( ! $ parameter ) { throw new OutOfRangeException ( 'Parameter "' . $ key . '" does not exist.' ) ; } $ this -> manager -> detach ( $ parameter ) ; return $ parameter -> getValue ( ) ; }
1505	protected function bindPageResolver ( ) : void { AbstractPaginator :: currentPageResolver ( function ( $ pageName ) { $ pagination = app ( EncodingParametersInterface :: class ) -> getPaginationParameters ( ) ? : [ ] ; return $ pagination [ $ pageName ] ?? null ; } ) ; }
12734	public function unregister ( Listener $ register ) { $ id = $ register -> id ; $ success = false ; if ( isset ( $ this -> _byId [ $ id ] ) ) { unset ( $ this -> _byId [ $ id ] ) ; $ success = true ; } foreach ( $ this -> _bySignal as $ signal => $ reg ) { if ( isset ( $ reg [ $ id ] ) ) { unset ( $ this -> _bySignal [ $ signal ] [ $ id ] ) ; } } return $ success ; }
11405	public function createService ( ServiceLocatorInterface $ serviceLocator ) { $ cacheManager = new CacheManager ( $ serviceLocator -> get ( 'HtSettingsModule\Options\ModuleOptions' ) -> getCacheOptions ( ) ) ; $ cacheManager -> setServiceLocator ( $ serviceLocator ) ; return $ cacheManager ; }
9448	public function getPackPath ( Container $ app ) { static $ paths = [ ] ; $ me = get_class ( $ this ) ; if ( empty ( $ paths [ $ me ] ) ) { $ paths [ $ me ] = dirname ( $ this -> getReflector ( ) -> getFileName ( ) ) ; } return $ paths [ $ me ] ; }
3323	protected function consumeOptionToken ( Option $ spec , $ arg , $ next , & $ success = false ) { if ( $ spec -> isFlag ( ) ) { if ( $ spec -> isIncremental ( ) ) { $ spec -> increaseValue ( ) ; } else { $ spec -> setValue ( true ) ; } return 0 ; } else if ( $ spec -> isRequired ( ) ) { if ( $ next && ! $ next -> isEmpty ( ) && ! $ next -> anyOfOptions ( $ this -> specs ) ) { $ spec -> setValue ( $ next -> arg ) ; return 1 ; } else { throw new RequireValueException ( "Option '{$arg->getOptionName()}' requires a value." ) ; } } else if ( $ spec -> isMultiple ( ) ) { if ( $ next && ! $ next -> isEmpty ( ) && ! $ next -> anyOfOptions ( $ this -> specs ) ) { $ this -> pushOptionValue ( $ spec , $ arg , $ next ) ; return 1 ; } } else if ( $ spec -> isOptional ( ) && $ next && ! $ next -> isEmpty ( ) && ! $ next -> anyOfOptions ( $ this -> specs ) ) { $ spec -> setValue ( $ next -> arg ) ; return 1 ; } return 0 ; }
12032	function addDispatchMethod ( ) { $ methodGenerator = new MethodGenerator ( 'dispatch' ) ; $ body = '' ; $ body .= $ this -> generateExecuteFragment ( ) ; $ body .= $ this -> generateResponseFragment ( ) ; $ docBlock = $ this -> generateExecuteDocBlock ( 'Dispatch the request for this operation and process the response. Allows you to modify the request before it is sent.' ) ; $ parameter = new ParameterGenerator ( 'request' , 'Amp\Artax\Request' ) ; $ methodGenerator -> setParameter ( $ parameter ) ; $ tag = createParamTag ( $ parameter , 'The request to be processed' ) ; $ docBlock -> setTag ( $ tag ) ; $ methodGenerator -> setDocBlock ( $ docBlock ) ; $ methodGenerator -> setBody ( $ body ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; }
6815	protected function buildFile ( array $ orders , string $ name ) { if ( false === $ path = tempnam ( sys_get_temp_dir ( ) , $ name ) ) { throw new RuntimeException ( "Failed to create temporary file." ) ; } if ( false === $ handle = fopen ( $ path , "w" ) ) { throw new RuntimeException ( "Failed to open '$path' for writing." ) ; } if ( ! empty ( $ headers = $ this -> buildHeaders ( ) ) ) { fputcsv ( $ handle , $ headers , ';' , '"' ) ; } $ supplierTotal = 0 ; $ forwarderTotal = 0 ; foreach ( $ orders as $ order ) { if ( ! empty ( $ row = $ this -> buildRow ( $ order ) ) ) { fputcsv ( $ handle , $ row , ';' , '"' ) ; $ supplierTotal += $ row [ 'payment_total' ] ; $ forwarderTotal += $ row [ 'forwarder_total' ] ; } } fputcsv ( $ handle , [ 'id' => '' , 'number' => '' , 'state' => '' , 'ordered_at' => '' , 'completed_at' => '' , 'supplier' => '' , 'payment_total' => $ supplierTotal , 'payment_date' => '' , 'payment_due_date' => '' , 'carrier' => '' , 'forwarder_total' => $ forwarderTotal , 'forwarder_date' => '' , 'forwarder_due_date' => '' , ] , ';' , '"' ) ; fclose ( $ handle ) ; return $ path ; }
3406	public function loadCommands ( string $ path , string $ namespace = "" , string $ suffix = "Command" ) : Application { $ commands = [ ] ; $ realpath = ( string ) realpath ( $ path ) ; $ finder = ( new Finder ( ) ) -> files ( ) -> in ( $ path ) -> name ( "/[A-Z].*{$suffix}.php/" ) ; foreach ( $ finder as $ file ) { $ filename = ( string ) $ file -> getRealPath ( ) ; require_once $ filename ; $ class = $ filename ; $ class = str_replace ( $ realpath , "" , $ class ) ; $ class = str_replace ( ".php" , "" , $ class ) ; $ class = str_replace ( "/" , "\\" , $ class ) ; $ command = $ class ; if ( substr ( $ command , 0 , 1 ) == "\\" ) { $ command = substr ( $ command , 1 ) ; } $ command = ( string ) preg_replace_callback ( "/^([A-Z])(.*){$suffix}$/" , function ( $ match ) { return strtolower ( $ match [ 1 ] ) . $ match [ 2 ] ; } , $ command ) ; $ command = preg_replace_callback ( "/(\\\\)?([A-Z])/" , function ( $ match ) { $ result = ( $ match [ 1 ] ) ? ":" : "-" ; $ result .= strtolower ( $ match [ 2 ] ) ; return $ result ; } , $ command ) ; $ class = $ namespace . $ class ; $ reflected = new \ ReflectionClass ( $ class ) ; if ( ! $ reflected -> isInstantiable ( ) ) { continue ; } $ commands [ ] = new $ class ( $ command ) ; } if ( count ( $ commands ) < 1 ) { throw new \ InvalidArgumentException ( "No commands were found in the path (" . $ path . ")" ) ; } $ this -> addCommands ( $ commands ) ; return $ this ; }
2542	protected function analyzeWithErrorCodeMsgQueryLevel ( SendResult $ response , $ qErr , $ qMsg , $ qLvl , $ lvlToText ) { $ analyzeResponse = new Result ( $ response ) ; $ domXpath = $ this -> makeDomXpath ( $ response -> responseXml ) ; $ errorCodeNodeList = $ domXpath -> query ( $ qErr ) ; if ( $ errorCodeNodeList -> length > 0 ) { $ analyzeResponse -> status = Result :: STATUS_ERROR ; $ lvlNodeList = $ domXpath -> query ( $ qLvl ) ; $ level = null ; if ( $ lvlNodeList -> length > 0 ) { if ( array_key_exists ( $ lvlNodeList -> item ( 0 ) -> nodeValue , $ lvlToText ) ) { $ level = $ lvlToText [ $ lvlNodeList -> item ( 0 ) -> nodeValue ] ; } } $ analyzeResponse -> messages [ ] = new Result \ NotOk ( $ errorCodeNodeList -> item ( 0 ) -> nodeValue , $ this -> makeMessageFromMessagesNodeList ( $ domXpath -> query ( $ qMsg ) ) , $ level ) ; } return $ analyzeResponse ; }
11691	public function getData ( $ origin ) { return array_reduce ( $ this -> structure -> getChildren ( ) , function ( $ acc , $ childDef ) { return array_merge ( $ acc , array ( $ childDef [ 'name' ] => $ childDef [ 'name' ] ) ) ; } , $ this -> getMetadataValues ( ) ) ; }
7226	public function info ( $ name = null ) { if ( $ name ) { return $ this -> info ? $ this -> info [ $ name ] : curl_getinfo ( $ this -> curl , "CURLINFO" . strtoupper ( $ name ) ) ; } else { return $ this -> info ? : curl_getinfo ( $ this -> curl ) ; } }
11319	function query ( $ sql , $ params = array ( ) ) { $ db = Neuron_DB_Database :: getInstance ( ) ; $ sql = $ this -> printf ( $ sql , $ params ) ; if ( $ this -> debug ) { echo $ sql . "<br><br>" ; } try { $ data = $ db -> query ( $ sql ) ; if ( $ this -> debug ) { echo '<pre>' ; var_dump ( $ data ) ; echo "</pre><br><br>" ; } $ this -> error = false ; return $ data ; } catch ( Exception $ e ) { $ this -> error = true ; echo 'error' ; } }
1989	public static function addToUrl ( $ strRequest , $ blnIgnoreParams = false , $ arrUnset = array ( ) ) { $ arrGet = $ blnIgnoreParams ? array ( ) : $ _GET ; foreach ( array_keys ( $ arrGet ) as $ key ) { $ arrGet [ $ key ] = Input :: get ( $ key , true , true ) ; } $ arrFragments = preg_split ( '/&(amp;)?/i' , $ strRequest ) ; foreach ( $ arrFragments as $ strFragment ) { list ( $ key , $ value ) = explode ( '=' , $ strFragment ) ; if ( $ value == '' ) { unset ( $ arrGet [ $ key ] ) ; } else { $ arrGet [ $ key ] = $ value ; } } if ( Config :: get ( 'addLanguageToUrl' ) ) { unset ( $ arrGet [ 'language' ] ) ; } $ strParams = '' ; $ strConnector = '/' ; $ strSeparator = '/' ; foreach ( $ arrGet as $ k => $ v ) { if ( Config :: get ( 'useAutoItem' ) && ( $ k == 'auto_item' || \ in_array ( $ k , $ GLOBALS [ 'TL_AUTO_ITEM' ] ) ) ) { $ strParams = $ strConnector . urlencode ( $ v ) . $ strParams ; } else { $ strParams .= $ strConnector . urlencode ( $ k ) . $ strSeparator . urlencode ( $ v ) ; } } global $ objPage ; $ pageId = $ objPage -> alias ? : $ objPage -> id ; if ( empty ( $ pageId ) ) { $ pageId = static :: getPageIdFromUrl ( ) ; } $ arrParams = array ( ) ; $ arrParams [ 'alias' ] = $ pageId . $ strParams ; if ( Config :: get ( 'addLanguageToUrl' ) ) { $ arrParams [ '_locale' ] = $ objPage -> rootLanguage ; } $ strUrl = System :: getContainer ( ) -> get ( 'router' ) -> generate ( 'contao_frontend' , $ arrParams ) ; $ strUrl = substr ( $ strUrl , \ strlen ( Environment :: get ( 'path' ) ) + 1 ) ; return $ strUrl ; }
8010	private static function expand56BitKeyTo64BitKey ( $ string_key , $ set_parity = true ) { $ byte_array_56 = new SplFixedArray ( 7 ) ; $ byte_array_64 = new SplFixedArray ( 8 ) ; $ key_64bit = '' ; for ( $ i = 0 ; $ i < $ byte_array_56 -> getSize ( ) ; $ i ++ ) { $ byte_array_56 [ $ i ] = isset ( $ string_key [ $ i ] ) ? ord ( $ string_key [ $ i ] ) : 0 ; } $ byte_array_64 [ 0 ] = $ byte_array_56 [ 0 ] & 254 ; $ byte_array_64 [ 1 ] = ( $ byte_array_56 [ 0 ] << 7 ) | ( $ byte_array_56 [ 1 ] >> 1 ) ; $ byte_array_64 [ 2 ] = ( $ byte_array_56 [ 1 ] << 6 ) | ( $ byte_array_56 [ 2 ] >> 2 ) ; $ byte_array_64 [ 3 ] = ( $ byte_array_56 [ 2 ] << 5 ) | ( $ byte_array_56 [ 3 ] >> 3 ) ; $ byte_array_64 [ 4 ] = ( $ byte_array_56 [ 3 ] << 4 ) | ( $ byte_array_56 [ 4 ] >> 4 ) ; $ byte_array_64 [ 5 ] = ( $ byte_array_56 [ 4 ] << 3 ) | ( $ byte_array_56 [ 5 ] >> 5 ) ; $ byte_array_64 [ 6 ] = ( $ byte_array_56 [ 5 ] << 2 ) | ( $ byte_array_56 [ 6 ] >> 6 ) ; $ byte_array_64 [ 7 ] = $ byte_array_56 [ 6 ] << 1 ; foreach ( $ byte_array_64 as $ byte_val ) { $ byte_val = $ set_parity ? self :: setParityBit ( $ byte_val ) : $ byte_val ; $ key_64bit .= chr ( $ byte_val ) ; } return $ key_64bit ; }
1437	public static function classify ( $ value ) { if ( isset ( self :: $ classified [ $ value ] ) ) { return self :: $ classified [ $ value ] ; } $ converted = ucwords ( str_replace ( [ '-' , '_' ] , ' ' , $ value ) ) ; return self :: $ classified [ $ value ] = str_replace ( ' ' , '' , $ converted ) ; }
4658	public function getTravisCiStrategy ( ) { $ builder = new DockerfileBuilder ( ) ; $ generator = new Generator ( ) ; $ generator -> setTemplateDirs ( array ( __DIR__ . "/../../../resources/templates" , ) ) ; $ generator -> setMustOverwriteIfExists ( true ) ; $ generator -> addBuilder ( $ builder ) ; return new TravisCiBuildStrategy ( $ builder , $ this -> getBuildPath ( ) , $ this -> getNaming ( ) , $ this -> getFilesystem ( ) ) ; }
7094	private function loadItem ( Model \ SaleItemInterface $ item ) { $ item -> getAdjustments ( ) -> toArray ( ) ; $ children = $ item -> getChildren ( ) -> toArray ( ) ; foreach ( $ children as $ child ) { $ this -> loadItem ( $ child ) ; } }
10363	public function __isset ( $ childName ) { foreach ( $ this -> nodes as $ node ) { if ( isset ( $ node -> $ childName ) ) { return true ; } } return false ; }
7275	protected function encodeValue ( $ column ) { $ val = in_array ( $ column , static :: $ jsons ) ? to_json ( $ this -> $ column ) : $ this -> $ column ; if ( isset ( static :: $ casts [ $ column ] ) && ( static :: $ casts [ $ column ] === "object" || static :: $ casts [ $ column ] === "array" ) ) $ val = to_json ( $ this -> $ column ) ; if ( is_bool ( $ val ) ) $ val = ( int ) $ val ; return $ val ; }
7645	protected function getStorageClient ( $ path = '' ) { if ( is_null ( $ this -> storageClient ) ) { $ url = explode ( ':' , $ path ) ; if ( ! $ url ) { throw new BlobException ( 'Could not parse path "' . $ path . '".' ) ; } $ this -> storageClient = BlobClient :: getWrapperClient ( $ url [ 0 ] ) ; if ( ! $ this -> storageClient ) { throw new BlobException ( 'No storage client registered for stream type "' . $ url [ 0 ] . '://".' ) ; } } return $ this -> storageClient ; }
11097	public static function secondsBetweenDates ( $ start , $ end , $ absolute = true , $ timezone = 'Europe/Prague' ) { $ timezoneObj = new \ DateTimeZone ( $ timezone ) ; $ date = new DateTime ( $ end , $ timezoneObj ) ; $ diff = $ date -> diff ( new DateTime ( $ start , $ timezoneObj ) , $ absolute ) ; return ( $ diff -> invert ? - 1 : 1 ) * ( ( $ diff -> days * 86400 ) + ( $ diff -> h * 3600 ) + ( $ diff -> i * 60 ) + $ diff -> s ) ; }
8844	private function log ( string $ message , array $ context = [ ] ) : void { $ this -> logger -> log ( $ this -> logLevel , $ message , $ context ) ; }
10675	private function _sklon ( $ nPad , $ vzndx , $ txt , $ zivotne = false ) { if ( $ vzndx < 0 || $ vzndx >= \ count ( $ this -> vzor ) ) { return '???' ; } $ txt3 = $ this -> _xEdeten ( $ txt ) ; $ kndx = $ this -> _isShoda ( $ this -> vzor [ $ vzndx ] [ 1 ] , $ txt3 ) ; if ( $ kndx < 0 || $ nPad < 1 || $ nPad > 14 ) { return '???' ; } if ( $ this -> vzor [ $ vzndx ] [ $ nPad ] === '?' ) { return '?' ; } if ( ! $ this -> isDbgMode & $ nPad === 1 ) { $ rv = $ this -> _xDetene ( $ txt3 ) ; } else { $ rv = $ this -> _leftStr ( $ kndx , $ txt3 ) . '-' . $ this -> _cmpFrm ( $ this -> vzor [ $ vzndx ] [ $ nPad ] ) ; } if ( $ this -> isDbgMode ) { return $ rv ; } $ length = mb_strlen ( $ rv , 'UTF-8' ) ; for ( $ nnn = 0 ; $ nnn < $ length ; $ nnn ++ ) { if ( mb_substr ( $ rv , $ nnn , 1 , 'UTF-8' ) === '-' ) { break ; } } $ ndx1 = $ nnn ; for ( $ nnn = 0 ; $ nnn < $ length ; $ nnn ++ ) { if ( mb_substr ( $ rv , $ nnn , 1 , 'UTF-8' ) === '/' ) { break ; } } $ ndx2 = $ nnn ; if ( $ ndx1 !== $ length && $ ndx2 !== $ length ) { if ( $ zivotne ) { $ rv = $ this -> _leftStr ( $ ndx1 , $ rv ) . $ this -> _rightStr ( $ ndx2 + 1 , $ rv ) ; } else { $ rv = $ this -> _leftStr ( $ ndx2 , $ rv ) ; } $ length = mb_strlen ( $ rv , 'UTF-8' ) ; } $ txt3 = '' ; for ( $ nnn = 0 ; $ nnn < $ length ; $ nnn ++ ) { $ subStr = mb_substr ( $ rv , $ nnn , 1 , 'UTF-8' ) ; if ( ! ( $ subStr === '-' || $ subStr === '/' ) ) { $ txt3 .= mb_substr ( $ rv , $ nnn , 1 , 'UTF-8' ) ; } } $ rv = $ this -> _xDetene ( $ txt3 ) ; return $ rv ; }
8852	public function getCurrentTag ( ) { $ tag = $ this -> request -> param ( "Tag" ) ; if ( $ tag ) { return $ this -> dataRecord -> Tags ( ) -> filter ( "URLSegment" , $ tag ) -> first ( ) ; } return null ; }
4097	public function field ( $ field , $ config = array ( ) ) { if ( is_string ( $ config ) ) $ config = array ( 'type' => $ config ) ; $ this -> properties [ $ field ] = $ config ; return $ this ; }
11688	public function setCenter ( \ Chill \ MainBundle \ Entity \ Center $ center ) { $ this -> center = $ center ; return $ this ; }
9549	public function setPdo ( PDO $ pdo ) { $ this -> pdo = $ pdo ; $ this -> pdo -> setAttribute ( PDO :: ATTR_DEFAULT_FETCH_MODE , PDO :: FETCH_ASSOC ) ; return $ this ; }
5559	protected function findFormInFrame ( $ page , $ index , $ method , $ attribute ) { $ form = $ this -> frames [ $ index ] -> $ method ( $ attribute ) ; if ( isset ( $ form ) ) { $ form -> setDefaultTarget ( $ this -> getPublicNameFromIndex ( $ index ) ) ; } return $ form ; }
3286	public function onBootstrap ( EventInterface $ e ) { $ app = $ e -> getApplication ( ) ; $ container = $ app -> getServiceManager ( ) ; $ config = $ container -> get ( 'Configuration' ) ; $ env = $ container -> get ( Environment :: class ) ; $ name = static :: MODULE_NAME ; $ options = $ envOptions = empty ( $ config [ $ name ] ) ? [ ] : $ config [ $ name ] ; $ extensions = empty ( $ options [ 'extensions' ] ) ? [ ] : $ options [ 'extensions' ] ; $ renderer = $ container -> get ( TwigRenderer :: class ) ; foreach ( $ extensions as $ extension ) { if ( empty ( $ extension ) ) { continue ; } elseif ( is_string ( $ extension ) ) { if ( $ container -> has ( $ extension ) ) { $ extension = $ container -> get ( $ extension ) ; } else { $ extension = new $ extension ( $ container , $ renderer ) ; } } elseif ( ! is_object ( $ extension ) ) { throw new InvalidArgumentException ( 'Extensions should be a string or object.' ) ; } if ( ! $ env -> hasExtension ( get_class ( $ extension ) ) ) { $ env -> addExtension ( $ extension ) ; } } return ; }
10917	private function isCmsActive ( ) { $ melisCms = 'MelisCms' ; $ moduleSvc = $ this -> getServiceLocator ( ) -> get ( 'ModulesService' ) ; $ modules = $ moduleSvc -> getActiveModules ( ) ; if ( in_array ( $ melisCms , $ modules ) ) { return true ; } return false ; }
2856	public function init ( Varien_Data_Collection_Db $ collection ) { $ this -> class = get_class ( $ collection ) ; $ this -> type = $ collection instanceof Mage_Eav_Model_Entity_Collection_Abstract ? self :: TYPE_EAV : self :: TYPE_FLAT ; $ this -> query = $ collection -> getSelectSql ( true ) ; $ this -> count = 0 ; }
7517	function parse_text ( ) { $ len = $ this -> pos - 1 - $ this -> status [ 'last_pos' ] ; $ this -> status [ 'text' ] = ( ( $ len > 0 ) ? substr ( $ this -> doc , $ this -> status [ 'last_pos' ] + 1 , $ len ) : '' ) ; }
12722	protected function turnIntoResolvableClosure ( $ abstract , $ concrete ) { return function ( Container $ container , $ parameters = [ ] ) use ( $ abstract , $ concrete ) { return ( $ abstract == $ concrete ? $ container -> resolve ( $ abstract ) : $ container -> resolve ( $ concrete , $ parameters ) ) ; } ; }
3781	private function determineFilterValue ( $ filterValues , $ valueName ) { if ( ! isset ( $ filterValues [ $ valueName ] ) && $ this -> get ( 'defaultid' ) ) { return $ this -> get ( 'defaultid' ) ; } return $ filterValues [ $ valueName ] ; }
4398	protected function getTransactionReference ( \ Aimeos \ MShop \ Order \ Item \ Base \ Iface $ base ) { $ code = $ this -> getServiceItem ( ) -> getCode ( ) ; $ service = $ base -> getService ( \ Aimeos \ MShop \ Order \ Item \ Base \ Service \ Base :: TYPE_PAYMENT , $ code ) ; return $ service -> getAttribute ( 'TRANSACTIONID' , 'payment/omnipay' ) ; }
2623	public function daysFromInstallation ( ) { $ stat = $ this -> statisticRepository -> getStatByAction ( self :: FASTLY_INSTALLED_FLAG ) ; if ( ! $ stat -> getCreatedAt ( ) ) { return null ; } $ installDate = date_create ( $ stat -> getCreatedAt ( ) ) ; $ currentDate = date_create ( $ this -> dateTime -> gmtDate ( ) ) ; $ dateDiff = date_diff ( $ installDate , $ currentDate ) ; return $ dateDiff -> days ; }
3082	public function getEngine ( $ endpoint ) { if ( $ this -> isInitialCall == true ) { $ endpointCached = $ endpoint . '-init' ; } else { $ endpointCached = $ endpoint ; } if ( ! isset ( $ this -> engines [ $ endpointCached ] ) ) { $ endPoints = $ this -> getOption ( self :: OPTION_ENGINE_ENDPOINTS ) ; if ( ! empty ( $ endPoints [ $ endpoint ] ) ) { $ engineOptions = $ endPoints [ $ endpoint ] ; $ class = $ engineOptions [ self :: OPTION_ENGINE_CLASS ] ; $ args = $ engineOptions [ self :: OPTION_ENGINE_ARGS ] ; $ args = $ this -> alterTimeoutCallValue ( $ args ) ; $ url = isset ( $ engineOptions [ self :: OPTION_ENGINE_URL ] ) ? $ engineOptions [ self :: OPTION_ENGINE_URL ] : $ endpoint ; array_unshift ( $ args , $ endpoint ) ; try { $ this -> engines [ $ endpointCached ] = new $ class ( $ url , $ this -> getCatEngineVersion ( $ args ) , $ this -> getCatEngineClient ( $ args ) ) ; } catch ( \ Exception $ e ) { \ common_Logger :: e ( 'Fail to connect to CAT endpoint : ' . $ e -> getMessage ( ) ) ; throw new CatEngineNotFoundException ( 'CAT Engine for endpoint "' . $ endpoint . '" is misconfigured.' , $ endpoint , 0 , $ e ) ; } } } if ( empty ( $ this -> engines [ $ endpointCached ] ) ) { throw new CatEngineNotFoundException ( "CAT Engine for endpoint '${endpoint}' is not configured." , $ endpoint ) ; } return $ this -> engines [ $ endpointCached ] ; }
4374	protected function buildChannelTree ( ) { if ( $ this -> channels == array ( $ this -> channelNameRoot ) ) { return array ( ) ; } \ sort ( $ this -> channels ) ; $ rootKey = \ array_search ( $ this -> channelNameRoot , $ this -> channels ) ; if ( $ rootKey !== false ) { unset ( $ this -> channels [ $ rootKey ] ) ; \ array_unshift ( $ this -> channels , $ this -> channelName ) ; } $ tree = array ( ) ; foreach ( $ this -> channels as $ channel ) { $ ref = & $ tree ; $ path = \ explode ( '.' , $ channel ) ; foreach ( $ path as $ k ) { if ( ! isset ( $ ref [ $ k ] ) ) { $ ref [ $ k ] = array ( ) ; } $ ref = & $ ref [ $ k ] ; } } return $ tree ; }
554	private function notifyCachesCanBeFlushed ( $ caches ) { $ this -> stdout ( "The following caches were found in the system:\n\n" , Console :: FG_YELLOW ) ; foreach ( $ caches as $ name => $ class ) { if ( $ this -> canBeFlushed ( $ class ) ) { $ this -> stdout ( "\t* $name ($class)\n" , Console :: FG_GREEN ) ; } else { $ this -> stdout ( "\t* $name ($class) - can not be flushed via console\n" , Console :: FG_YELLOW ) ; } } $ this -> stdout ( "\n" ) ; }
9348	public function sameSize ( $ matrix ) { return ( $ this -> size -> cols == $ matrix -> cols && $ this -> size -> rows == $ matrix -> rows ) ; }
5516	public function errorOn ( $ method , $ error = 'A mock error' , $ args = false , $ severity = E_USER_ERROR ) { $ this -> dieOnNoMethod ( $ method , 'error on' ) ; $ this -> actions -> register ( $ method , $ args , new SimpleErrorThrower ( $ error , $ severity ) ) ; }
829	private function isStringPartToken ( Token $ token ) { return $ token -> isGivenKind ( T_ENCAPSED_AND_WHITESPACE ) || $ token -> isGivenKind ( T_START_HEREDOC ) || '"' === $ token -> getContent ( ) || 'b"' === strtolower ( $ token -> getContent ( ) ) ; }
10981	public function tree ( $ trans = false ) { $ tree = [ ] ; foreach ( $ this -> items as $ date => $ log ) { $ tree [ $ date ] = $ log -> tree ( $ trans ) ; } return $ tree ; }
12077	public function childStoreWithPivot ( $ idParent , $ request , $ relation ) { $ idParent = $ this -> getRealId ( $ idParent ) ; $ resource = $ this -> repository -> storeChildAndPivot ( $ idParent , $ relation , $ request -> all ( ) ) ; if ( ! $ resource ) { } return $ this -> success ( $ resource ) ; }
5750	public function setRoles ( ) { $ this -> roles = [ ] ; if ( null !== $ records = $ this -> select ( ) ) { foreach ( $ records as $ record ) { $ this -> roles [ ( int ) $ record [ 'id' ] ] = $ record [ 'role' ] ; } } }
924	public function getInvalidErrors ( ) { return array_filter ( $ this -> errors , static function ( Error $ error ) { return Error :: TYPE_INVALID === $ error -> getType ( ) ; } ) ; }
4939	public function setAllowedTypes ( $ types ) { if ( is_array ( $ types ) ) { $ types = implode ( ',' , $ types ) ; } return $ this -> setAttribute ( 'data-allowedtypes' , $ types ) ; }
358	function compareByteSize ( $ a , $ b , $ compare = '>=' ) { $ compareExpression = '(' . $ this -> getByteSize ( $ a ) . $ compare . $ this -> getByteSize ( $ b ) . ')' ; return $ this -> evaluateExpression ( $ compareExpression ) ; }
3748	protected function getIdsFromFilter ( $ filter , $ config ) { $ sorting = $ this -> extractSorting ( $ config ) ; return $ this -> getMetaModel ( ) -> getIdsFromFilter ( $ filter , $ sorting [ 0 ] , $ config -> getStart ( ) , $ config -> getAmount ( ) , strtoupper ( $ sorting [ 1 ] ) ) ; }
3718	protected function getMetaModelFromModel ( ModelInterface $ model ) { if ( ! ( ( $ model -> getProviderName ( ) == 'tl_metamodel_dca_sortgroup' ) && $ model -> getProperty ( 'pid' ) ) ) { throw new DcGeneralInvalidArgumentException ( sprintf ( 'Model must originate from tl_metamodel_dca_sortgroup and be saved, this one originates from %s ' . 'and has pid %s' , $ model -> getProviderName ( ) , $ model -> getProperty ( 'pid' ) ) ) ; } $ metaModelId = $ this -> connection -> createQueryBuilder ( ) -> select ( 'pid' ) -> from ( 'tl_metamodel_dca' ) -> where ( 'id=:id' ) -> setParameter ( 'id' , $ model -> getProperty ( 'pid' ) ) -> execute ( ) -> fetchColumn ( ) ; $ tableName = $ this -> factory -> translateIdToMetaModelName ( $ metaModelId ) ; return $ this -> factory -> getMetaModel ( $ tableName ) ; }
6259	protected function _isAllowedRole ( $ userRoles , array $ allowedRoles ) { if ( in_array ( '*' , $ allowedRoles ) ) { return true ; } if ( is_string ( $ userRoles ) ) { $ userRoles = [ $ userRoles ] ; } foreach ( $ userRoles as $ userRole ) { if ( in_array ( $ userRole , $ allowedRoles ) ) { return true ; } } return false ; }
11152	public function setParameters ( array $ request ) { foreach ( $ this -> getRequiredParameters ( ) as $ param ) { if ( isset ( $ request [ $ param ] ) ) { $ dynamicMethod = "set" . ucfirst ( $ param ) ; if ( method_exists ( $ this , $ dynamicMethod ) ) { $ this -> $ dynamicMethod ( $ request [ $ param ] ) ; } else { throw new ExtDirectException ( "Method for required parameter '{$param}' not implemented" ) ; } } else { throw new ExtDirectException ( "Required parameter '{$param}' is missing" ) ; } } }
4618	protected function required ( $ objectName ) { $ method = "get{$objectName}" ; $ class = "Basho\\Riak\\{$objectName}" ; $ value = $ this -> $ method ( ) ; if ( is_null ( $ value ) ) { throw new Builder \ Exception ( "Expected non-empty value for {$objectName}" ) ; } if ( is_object ( $ value ) && $ value instanceof $ class === false ) { throw new Builder \ Exception ( "Expected instance of {$class}, received instance of " . get_class ( $ value ) ) ; } if ( is_array ( $ value ) && count ( $ value ) == 0 ) { throw new Builder \ Exception ( "Expected non-empty array value for {$objectName}" ) ; } }
4310	public function getChannels ( $ allDescendants = false ) { if ( $ allDescendants ) { $ channels = array ( ) ; foreach ( $ this -> channels as $ channel ) { $ channels = \ array_merge ( $ channels , array ( $ channel -> getCfg ( 'channel' ) => $ channel ) , $ channel -> getChannels ( true ) ) ; } return $ channels ; } return $ this -> channels ; }
7499	protected function renderStringTemplate ( $ template , $ parameters = array ( ) ) { $ template = $ this -> environment -> createTemplate ( $ template ) ; return $ template -> render ( $ parameters ) ; }
1594	protected function validateType ( ) : bool { if ( ! $ this -> dataHas ( 'type' ) ) { $ this -> memberRequired ( '/data' , 'type' ) ; return false ; } $ value = $ this -> dataGet ( 'type' ) ; if ( ! $ this -> validateTypeMember ( $ value , '/data' ) ) { return false ; } if ( $ this -> expectedType !== $ value ) { $ this -> resourceTypeNotSupported ( $ value ) ; return false ; } return true ; }
7144	public static function remove_author_meta_values ( ) { global $ blog_id ; if ( isset ( $ blog_id ) && ! empty ( $ blog_id ) ) { $ blogusers = get_users ( array ( 'blog_id' => $ blog_id ) ) ; foreach ( $ blogusers as $ user_object ) { delete_user_meta ( $ user_object -> ID , 'post_subscription' ) ; delete_user_meta ( $ user_object -> ID , 'comment_subscription' ) ; } } }
2524	protected function loadFromAuthParams ( AuthParams $ authParams ) { $ this -> officeId = $ authParams -> officeId ; $ this -> dutyCode = $ authParams -> dutyCode ; $ this -> organizationId = $ authParams -> organizationId ; $ this -> originatorTypeCode = $ authParams -> originatorTypeCode ; $ this -> userId = $ authParams -> userId ; $ this -> passwordLength = $ authParams -> passwordLength ; $ this -> passwordData = $ authParams -> passwordData ; }
722	public function json ( ) { if ( version_compare ( PHP_VERSION , '5.6' , '<' ) && $ this -> getDb ( ) -> getDriverName ( ) === 'mysql' ) { throw new \ yii \ base \ Exception ( 'JSON column type is not supported in PHP < 5.6' ) ; } return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_JSON ) ; }
2952	protected function prepareTemplate ( $ templateTxt ) { $ patterns = [ '/\\\{%(.*)%\\\}/U' , '/\s+/' , ] ; $ replacements = [ '(?<$1>.*)' , ' ' , ] ; $ templateTxt = preg_replace ( $ patterns , $ replacements , preg_quote ( $ templateTxt , '/' ) ) ; return trim ( $ templateTxt ) ; }
8529	public function listFinancialEvents ( $ request ) { if ( ! ( $ request instanceof MWSFinancesService_Model_ListFinancialEventsRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/ListFinancialEventsRequest.php' ) ; $ request = new MWSFinancesService_Model_ListFinancialEventsRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListFinancialEvents' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/ListFinancialEventsResponse.php' ) ; $ response = MWSFinancesService_Model_ListFinancialEventsResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
6377	public function toArray ( ) : array { $ res = [ ] ; Iterators :: each ( $ this -> iterator ( ) , function ( $ element ) use ( & $ res ) { $ res [ ] = $ element ; } ) ; return $ res ; }
5293	protected function execute ( InputInterface $ input , OutputInterface $ output ) { $ directory = $ input -> getArgument ( 'directory' ) ; $ outputFile = $ input -> getArgument ( 'output-file' ) ; $ generator = new IconFontGenerator ; $ output -> writeln ( 'reading files from "' . $ directory . '" ...' ) ; $ generator -> generateFromDir ( $ directory , array ( 'id' => $ input -> getOption ( 'name' ) ? : 'SVGFont' , ) , $ input -> getOption ( 'rename-files' ) ) ; $ output -> writeln ( 'writing font to "' . $ outputFile . '" ...' ) ; file_put_contents ( $ outputFile , $ generator -> getFont ( ) -> getXML ( ) ) ; $ output -> getFormatter ( ) -> setStyle ( 'success' , new OutputFormatterStyle ( null , null , array ( 'bold' , 'reverse' ) ) ) ; $ output -> writeln ( '<success>created ' . $ outputFile . ' successfully</success>' ) ; }
2116	public function addTemplateWarning ( ) { if ( Contao \ Input :: get ( 'act' ) && Contao \ Input :: get ( 'act' ) != 'select' ) { return ; } $ objResult = $ this -> Database -> query ( "SELECT COUNT(*) AS cnt FROM tl_user_group WHERE modules LIKE '%\"tpl_editor\"%'" ) ; if ( $ objResult -> cnt > 0 ) { Contao \ Message :: addInfo ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'groupTemplateEditor' ] ) ; } }
8907	public function get_next_id ( ) { return ( int ) $ this -> _database -> select ( 'AUTO_INCREMENT' ) -> from ( 'information_schema.TABLES' ) -> where ( 'TABLE_NAME' , $ this -> _database -> dbprefix ( $ this -> get_table ( ) ) ) -> where ( 'TABLE_SCHEMA' , $ this -> _database -> database ) -> get ( ) -> row ( ) -> AUTO_INCREMENT ; }
3133	public function getRubrics ( RunnerServiceContext $ context , AssessmentItemRef $ itemRef = null ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ rubricHelper = $ this -> getServiceLocator ( ) -> get ( QtiRunnerRubric :: SERVICE_ID ) ; return $ rubricHelper -> getRubrics ( $ context , $ itemRef ) ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'getRubrics' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } }
4150	protected function getBinaryFile ( $ filename ) { if ( ! file_exists ( $ filename ) ) { throw new FileNotFoundException ; } if ( ! is_readable ( $ filename ) ) { throw new FileNotReadableException ; } ob_start ( ) ; readfile ( $ filename ) ; $ binary = ob_get_contents ( ) ; ob_end_clean ( ) ; unset ( $ filename ) ; return $ binary ; }
7008	private function format_l ( & $ str ) { if ( strstr ( $ str , '%l' ) ) $ str = str_replace ( '%l' , $ this -> dayName ( true ) , $ str ) ; }
7230	public function getMarginPercent ( ) { if ( 0 < $ this -> margin && 0 < $ this -> revenue ) { return round ( $ this -> margin * 100 / $ this -> revenue , 1 ) ; } return 0 ; }
10128	private function writeBreaks ( ) { $ vbreaks = [ ] ; $ hbreaks = [ ] ; foreach ( $ this -> phpSheet -> getBreaks ( ) as $ cell => $ breakType ) { $ coordinates = Coordinate :: coordinateFromString ( $ cell ) ; switch ( $ breakType ) { case \ PhpOffice \ PhpSpreadsheet \ Worksheet \ Worksheet :: BREAK_COLUMN : $ vbreaks [ ] = Coordinate :: columnIndexFromString ( $ coordinates [ 0 ] ) - 1 ; break ; case \ PhpOffice \ PhpSpreadsheet \ Worksheet \ Worksheet :: BREAK_ROW : $ hbreaks [ ] = $ coordinates [ 1 ] ; break ; case \ PhpOffice \ PhpSpreadsheet \ Worksheet \ Worksheet :: BREAK_NONE : default : break ; } } if ( ! empty ( $ hbreaks ) ) { sort ( $ hbreaks , SORT_NUMERIC ) ; if ( $ hbreaks [ 0 ] == 0 ) { array_shift ( $ hbreaks ) ; } $ record = 0x001b ; $ cbrk = count ( $ hbreaks ) ; $ length = 2 + 6 * $ cbrk ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ cbrk ) ; foreach ( $ hbreaks as $ hbreak ) { $ data .= pack ( 'vvv' , $ hbreak , 0x0000 , 0x00ff ) ; } $ this -> append ( $ header . $ data ) ; } if ( ! empty ( $ vbreaks ) ) { $ vbreaks = array_slice ( $ vbreaks , 0 , 1000 ) ; sort ( $ vbreaks , SORT_NUMERIC ) ; if ( $ vbreaks [ 0 ] == 0 ) { array_shift ( $ vbreaks ) ; } $ record = 0x001a ; $ cbrk = count ( $ vbreaks ) ; $ length = 2 + 6 * $ cbrk ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ cbrk ) ; foreach ( $ vbreaks as $ vbreak ) { $ data .= pack ( 'vvv' , $ vbreak , 0x0000 , 0xffff ) ; } $ this -> append ( $ header . $ data ) ; } }
2068	public function copyPageWithSubpages ( $ row , $ href , $ label , $ title , $ icon , $ attributes , $ table ) { if ( $ GLOBALS [ 'TL_DCA' ] [ $ table ] [ 'config' ] [ 'closed' ] ) { return '' ; } $ objSubpages = Contao \ PageModel :: findByPid ( $ row [ 'id' ] ) ; return ( $ objSubpages !== null && $ objSubpages -> count ( ) > 0 && $ this -> User -> hasAccess ( $ row [ 'type' ] , 'alpty' ) && $ this -> User -> isAllowed ( Contao \ BackendUser :: CAN_EDIT_PAGE_HIERARCHY , $ row ) ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' ; }
1427	protected function modelRelationForField ( $ field ) { return $ this -> camelCaseRelations ? Str :: camelize ( $ field ) : Str :: underscore ( $ field ) ; }
5778	public function set ( string $ sql , array $ args ) { $ this -> sql = $ sql ; $ this -> args = $ args ; }
6160	public function setProperties ( array $ properties ) { $ this -> properties = [ ] ; foreach ( $ properties as $ item ) { $ this -> addPropertyRequest ( $ item ) ; } return $ this ; }
1338	public static function defaultApi ( string $ name ) : self { if ( empty ( $ name ) ) { throw new \ InvalidArgumentException ( 'Default API name must not be empty.' ) ; } self :: $ defaultApi = $ name ; return new self ( ) ; }
104	public function isRateLimited ( array $ headers ) { foreach ( $ headers as $ header ) { if ( preg_match ( '{^X-RateLimit-Remaining: *0$}i' , trim ( $ header ) ) ) { return true ; } } return false ; }
6724	protected function validateTokenParams ( ) { if ( empty ( $ this -> tokenUrl ) || filter_var ( $ this -> tokenUrl , FILTER_VALIDATE_URL ) === false ) { throw new Oauth2ClientException ( sprintf ( self :: INVALID_TOKEN_URL , $ this -> tokenUrl ) ) ; } if ( empty ( $ this -> clientId ) ) { throw new Oauth2ClientException ( self :: INVALID_CLIENT_ID ) ; } if ( empty ( $ this -> clientSecret ) ) { throw new Oauth2ClientException ( self :: INVALID_CLIENT_SECRET ) ; } return true ; }
3310	public function getAccessToken ( $ forceRefresh = false ) { $ cacheKey = $ this -> getCacheKey ( ) ; $ cached = $ this -> getCache ( ) -> fetch ( $ cacheKey ) ; if ( empty ( $ cached ) || $ forceRefresh ) { $ token = $ this -> getTokenFormApi ( ) ; $ this -> getCache ( ) -> save ( $ cacheKey , $ token [ $ this -> tokenSucessKey ] , $ token [ 'expires_in' ] ) ; return $ token [ $ this -> tokenSucessKey ] ; } return $ cached ; }
904	public function isUnarySuccessorOperator ( $ index ) { static $ allowedPrevToken = [ ']' , [ T_STRING ] , [ T_VARIABLE ] , [ CT :: T_DYNAMIC_PROP_BRACE_CLOSE ] , [ CT :: T_DYNAMIC_VAR_BRACE_CLOSE ] , ] ; $ tokens = $ this -> tokens ; $ token = $ tokens [ $ index ] ; if ( ! $ token -> isGivenKind ( [ T_INC , T_DEC ] ) ) { return false ; } $ prevToken = $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ index ) ] ; return $ prevToken -> equalsAny ( $ allowedPrevToken ) ; }
1927	public function isSemitransparent ( ) { if ( ! imageistruecolor ( $ this -> gdResource ) ) { return false ; } $ width = imagesx ( $ this -> gdResource ) ; $ height = imagesy ( $ this -> gdResource ) ; for ( $ x = 0 ; $ x < $ width ; $ x ++ ) { for ( $ y = 0 ; $ y < $ height ; $ y ++ ) { $ alpha = ( imagecolorat ( $ this -> gdResource , $ x , $ y ) >> 24 ) & 0x7F ; if ( $ alpha > 0 && $ alpha < 127 ) { return true ; } } } return false ; }
5919	public function setCreated ( $ created ) { if ( $ created instanceof DateTime ) { $ this -> created = $ created ; } else { try { $ this -> created = new DateTime ( $ created ) ; } catch ( \ Exception $ e ) { $ this -> created = null ; } } return $ this ; }
11852	protected function setLayout ( string $ layoutName ) : void { if ( is_null ( $ this -> view ) ) { throw new Exception ( "It's unable to set Layout without View." ) ; } $ this -> layout = ViewFactory :: createLayout ( $ layoutName , $ this -> view ) ; }
10250	public function getDln ( $ state_code = null , $ min = 900000001 , $ max = 999999999 ) { $ dln = new Entities \ DriverLicense ( ) ; $ dln -> number = rand ( $ min , $ max ) ; $ dln -> state = ! empty ( $ state_code ) ? $ state_code : $ this -> getState ( ) ; $ dln -> expiration = $ this -> getExpiration ( ) ; return $ dln ; }
9662	private static function getReaderTypeFromExtension ( $ filename ) { $ pathinfo = pathinfo ( $ filename ) ; if ( ! isset ( $ pathinfo [ 'extension' ] ) ) { return null ; } switch ( strtolower ( $ pathinfo [ 'extension' ] ) ) { case 'xlsx' : case 'xlsm' : case 'xltx' : case 'xltm' : return 'Xlsx' ; case 'xls' : case 'xlt' : return 'Xls' ; case 'ods' : case 'ots' : return 'Ods' ; case 'slk' : return 'Slk' ; case 'xml' : return 'Xml' ; case 'gnumeric' : return 'Gnumeric' ; case 'htm' : case 'html' : return 'Html' ; case 'csv' : return null ; default : return null ; } }
5000	public function preRemove ( $ object ) { if ( ! is_null ( $ this -> urlProvider ) && ! is_null ( $ this -> menuManager ) ) { $ url = $ this -> urlProvider -> url ( $ object ) ; $ menuItem = $ this -> menuManager -> getItem ( $ url ) ; if ( $ menuItem instanceof MenuItem ) { $ this -> menuManager -> removeItem ( $ menuItem ) ; $ this -> menuManager -> flush ( ) ; } } }
9176	public function getPlugins ( ) { foreach ( $ this -> getOperations ( ) as $ operation ) { if ( $ this -> getOperation ( ) -> equals ( $ operation ) ) { return $ operation -> getPlugins ( ) ; } } throw new \ Exception ( sprintf ( 'Can\'t find any plugins for operation %s' , $ this -> getOperation ( ) ) ) ; }
5486	public function submitButton ( SelectorInterface $ selector , $ additional = false ) { $ additional = $ additional ? $ additional : array ( ) ; foreach ( $ this -> buttons as $ button ) { if ( $ selector -> isMatch ( $ button ) ) { $ encoding = $ this -> encode ( ) ; $ button -> write ( $ encoding ) ; if ( $ additional ) { $ encoding -> merge ( $ additional ) ; } return $ encoding ; } } return false ; }
6567	public function getLink ( $ phone_number = '' , $ body = '' ) { if ( ! empty ( $ body ) ) { $ body = "?body=" . $ body ; } $ sms = 'sms:' . trim ( $ phone_number . $ body ) ; return $ sms ; }
1070	private function collectConflictsBetweenFragments ( ValidationContext $ context , array & $ conflicts , $ areMutuallyExclusive , $ fragmentName1 , $ fragmentName2 ) { if ( $ fragmentName1 === $ fragmentName2 ) { return ; } if ( $ this -> comparedFragmentPairs -> has ( $ fragmentName1 , $ fragmentName2 , $ areMutuallyExclusive ) ) { return ; } $ this -> comparedFragmentPairs -> add ( $ fragmentName1 , $ fragmentName2 , $ areMutuallyExclusive ) ; $ fragment1 = $ context -> getFragment ( $ fragmentName1 ) ; $ fragment2 = $ context -> getFragment ( $ fragmentName2 ) ; if ( ! $ fragment1 || ! $ fragment2 ) { return ; } [ $ fieldMap1 , $ fragmentNames1 ] = $ this -> getReferencedFieldsAndFragmentNames ( $ context , $ fragment1 ) ; [ $ fieldMap2 , $ fragmentNames2 ] = $ this -> getReferencedFieldsAndFragmentNames ( $ context , $ fragment2 ) ; $ this -> collectConflictsBetween ( $ context , $ conflicts , $ areMutuallyExclusive , $ fieldMap1 , $ fieldMap2 ) ; $ fragmentNames2Length = count ( $ fragmentNames2 ) ; for ( $ j = 0 ; $ j < $ fragmentNames2Length ; $ j ++ ) { $ this -> collectConflictsBetweenFragments ( $ context , $ conflicts , $ areMutuallyExclusive , $ fragmentName1 , $ fragmentNames2 [ $ j ] ) ; } $ fragmentNames1Length = count ( $ fragmentNames1 ) ; for ( $ i = 0 ; $ i < $ fragmentNames1Length ; $ i ++ ) { $ this -> collectConflictsBetweenFragments ( $ context , $ conflicts , $ areMutuallyExclusive , $ fragmentNames1 [ $ i ] , $ fragmentName2 ) ; } }
7589	protected function configureType ( ) { switch ( $ this -> type ) { case 'POST' : $ this -> setOption ( CURLOPT_POST , true ) ; break ; case 'DELETE' : case 'PUT' : $ this -> setOption ( CURLOPT_CUSTOMREQUEST , $ this -> type ) ; break ; } }
12181	public function getPrimaryObject ( $ primaryObject , $ relatedObject , $ role ) { if ( ! $ this -> handlePrimary ) { return false ; } if ( $ role === 'child' ) { $ primaryField = 'primary_child' ; if ( ! $ relatedObject -> objectType -> getPrimaryAsChild ( $ this -> parent ) ) { return false ; } $ primaryParent = $ primaryObject ; } else { $ primaryField = 'primary_parent' ; if ( ! $ relatedObject -> objectType -> getPrimaryAsParent ( $ this -> child ) ) { return false ; } $ primaryParent = $ relatedObject ; } $ key = json_encode ( [ __FUNCTION__ , $ this -> systemId , $ primaryObject -> primaryKey ] ) ; if ( ! isset ( self :: $ _cache [ $ key ] ) ) { self :: $ _cache [ $ key ] = null ; $ relationClass = Yii :: $ app -> classes [ 'Relation' ] ; $ childClass = $ this -> child -> primaryModel ; $ relation = $ relationClass :: find ( ) ; $ alias = $ relationClass :: tableName ( ) ; $ relation -> andWhere ( [ '`' . $ alias . '`.`parent_object_id`' => $ primaryParent -> primaryKey , '`' . $ alias . '`.`' . $ primaryField . '`' => 1 ] ) ; $ relation -> andWhere ( [ 'or' , '`' . $ alias . '`.`child_object_id` LIKE :prefix' ] ) ; $ relation -> params [ ':prefix' ] = $ childClass :: modelPrefix ( ) . '-%' ; $ primaryObject -> addActiveConditions ( $ relation , $ alias ) ; $ relation = $ relation -> one ( ) ; if ( ! empty ( $ relation ) ) { self :: $ _cache [ $ key ] = $ relation ; } } return self :: $ _cache [ $ key ] ; }
9669	private function writeFont ( XMLWriter $ objWriter , Font $ pFont ) { $ objWriter -> startElement ( 'font' ) ; if ( $ pFont -> getBold ( ) !== null ) { $ objWriter -> startElement ( 'b' ) ; $ objWriter -> writeAttribute ( 'val' , $ pFont -> getBold ( ) ? '1' : '0' ) ; $ objWriter -> endElement ( ) ; } if ( $ pFont -> getItalic ( ) !== null ) { $ objWriter -> startElement ( 'i' ) ; $ objWriter -> writeAttribute ( 'val' , $ pFont -> getItalic ( ) ? '1' : '0' ) ; $ objWriter -> endElement ( ) ; } if ( $ pFont -> getStrikethrough ( ) !== null ) { $ objWriter -> startElement ( 'strike' ) ; $ objWriter -> writeAttribute ( 'val' , $ pFont -> getStrikethrough ( ) ? '1' : '0' ) ; $ objWriter -> endElement ( ) ; } if ( $ pFont -> getUnderline ( ) !== null ) { $ objWriter -> startElement ( 'u' ) ; $ objWriter -> writeAttribute ( 'val' , $ pFont -> getUnderline ( ) ) ; $ objWriter -> endElement ( ) ; } if ( $ pFont -> getSuperscript ( ) === true || $ pFont -> getSubscript ( ) === true ) { $ objWriter -> startElement ( 'vertAlign' ) ; if ( $ pFont -> getSuperscript ( ) === true ) { $ objWriter -> writeAttribute ( 'val' , 'superscript' ) ; } elseif ( $ pFont -> getSubscript ( ) === true ) { $ objWriter -> writeAttribute ( 'val' , 'subscript' ) ; } $ objWriter -> endElement ( ) ; } if ( $ pFont -> getSize ( ) !== null ) { $ objWriter -> startElement ( 'sz' ) ; $ objWriter -> writeAttribute ( 'val' , StringHelper :: formatNumber ( $ pFont -> getSize ( ) ) ) ; $ objWriter -> endElement ( ) ; } if ( $ pFont -> getColor ( ) -> getARGB ( ) !== null ) { $ objWriter -> startElement ( 'color' ) ; $ objWriter -> writeAttribute ( 'rgb' , $ pFont -> getColor ( ) -> getARGB ( ) ) ; $ objWriter -> endElement ( ) ; } if ( $ pFont -> getName ( ) !== null ) { $ objWriter -> startElement ( 'name' ) ; $ objWriter -> writeAttribute ( 'val' , $ pFont -> getName ( ) ) ; $ objWriter -> endElement ( ) ; } $ objWriter -> endElement ( ) ; }
4746	public function isReviewOptInError ( ) { $ review = oxNew ( \ OxidEsales \ Eshop \ Application \ Controller \ ReviewController :: class ) ; return $ review -> isReviewOptInError ( ) ; }
6108	public function clientPermRemove ( $ cldbid , $ permid ) { return $ this -> getParent ( ) -> channelClientPermRemove ( $ this -> getId ( ) , $ cldbid , $ permid ) ; }
4605	public function setEntityUuid ( ? string $ entityUuid ) { if ( null !== $ entityUuid ) { if ( ! preg_match ( '/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i' , $ entityUuid ) ) { throw new InvalidArgumentException ( 'Entity uuid is not valid.' ) ; } } $ this -> entityUuid = $ entityUuid ; return $ this ; }
4367	protected function emailErr ( Event $ error ) { $ dateTimeFmt = 'Y-m-d H:i:s (T)' ; $ errMsg = $ error [ 'message' ] ; if ( $ error [ 'isHtml' ] ) { $ errMsg = \ strip_tags ( $ errMsg ) ; $ errMsg = \ htmlspecialchars_decode ( $ errMsg ) ; } $ countSince = $ error [ 'stats' ] [ 'countSince' ] ; $ isCli = $ this -> isCli ( ) ; $ subject = $ isCli ? 'Error: ' . \ implode ( ' ' , $ _SERVER [ 'argv' ] ) : 'Website Error: ' . $ _SERVER [ 'SERVER_NAME' ] ; $ subject .= ': ' . $ errMsg . ( $ countSince ? ' (' . $ countSince . 'x)' : '' ) ; $ emailBody = '' ; if ( ! empty ( $ countSince ) ) { $ dateTimePrev = \ date ( $ dateTimeFmt , $ error [ 'stats' ] [ 'tsEmailed' ] ) ; $ emailBody .= 'Error has occurred ' . $ countSince . ' times since last email (' . $ dateTimePrev . ').' . "\n\n" ; } $ emailBody .= '' . 'datetime: ' . \ date ( $ dateTimeFmt ) . "\n" . 'errormsg: ' . $ errMsg . "\n" . 'errortype: ' . $ error [ 'type' ] . ' (' . $ error [ 'typeStr' ] . ')' . "\n" . 'file: ' . $ error [ 'file' ] . "\n" . 'line: ' . $ error [ 'line' ] . "\n" . '' ; if ( ! $ isCli ) { $ emailBody .= '' . 'remote_addr: ' . $ _SERVER [ 'REMOTE_ADDR' ] . "\n" . 'http_host: ' . $ _SERVER [ 'HTTP_HOST' ] . "\n" . 'referer: ' . ( isset ( $ _SERVER [ 'HTTP_REFERER' ] ) ? $ _SERVER [ 'HTTP_REFERER' ] : 'null' ) . "\n" . 'request_uri: ' . $ _SERVER [ 'REQUEST_URI' ] . "\n" . '' ; } if ( ! empty ( $ _POST ) ) { $ emailBody .= 'post params: ' . \ var_export ( $ _POST , true ) . "\n" ; } if ( $ error [ 'type' ] & $ this -> cfg [ 'emailTraceMask' ] ) { $ backtraceStr = $ this -> backtraceStr ( $ error ) ; $ emailBody .= "\n" . ( $ backtraceStr ? 'backtrace: ' . $ backtraceStr : 'no backtrace' ) ; } $ this -> email ( $ this -> cfg [ 'emailTo' ] , $ subject , $ emailBody ) ; return ; }
755	public function validate ( $ input , $ caseSensitive ) { $ code = $ this -> getVerifyCode ( ) ; $ valid = $ caseSensitive ? ( $ input === $ code ) : strcasecmp ( $ input , $ code ) === 0 ; $ session = Yii :: $ app -> getSession ( ) ; $ session -> open ( ) ; $ name = $ this -> getSessionKey ( ) . 'count' ; $ session [ $ name ] += 1 ; if ( $ valid || $ session [ $ name ] > $ this -> testLimit && $ this -> testLimit > 0 ) { $ this -> getVerifyCode ( true ) ; } return $ valid ; }
91	public static function parseJson ( $ json , $ file = null ) { if ( null === $ json ) { return ; } $ data = json_decode ( $ json , true ) ; if ( null === $ data && JSON_ERROR_NONE !== json_last_error ( ) ) { self :: validateSyntax ( $ json , $ file ) ; } return $ data ; }
11226	final public static function getShortName ( $ className = '' ) { $ base = strrchr ( static :: getRealClassName ( $ className ) , '\\' ) ; return $ base ? substr ( $ base , 1 ) : $ className ; }
11562	protected function getWeekWordsUnitsAndShortcuts ( $ lang ) { if ( ! isset ( $ this -> weekWords [ $ lang ] ) ) { if ( isset ( static :: $ WeekWordsDefault [ $ lang ] ) ) { $ this -> weekWords [ $ lang ] = explode ( ',' , static :: $ WeekWordsDefault [ $ lang ] ) ; } else { $ this -> weekWords [ $ lang ] = [ ] ; } } if ( ! $ this -> units ) $ this -> units = explode ( ',' , static :: $ UnitsDefault ) ; if ( ! isset ( $ this -> shortcuts [ $ lang ] ) ) { if ( isset ( static :: $ ShortcutsDefault [ $ lang ] ) ) { $ shortcuts = [ ] ; foreach ( static :: $ ShortcutsDefault [ $ lang ] as $ shortcutsLocalized ) foreach ( $ shortcutsLocalized as $ shortcut ) $ shortcuts [ $ shortcut ] = str_replace ( ' ' , '&nbsp;' , $ shortcut ) ; $ this -> shortcuts [ $ lang ] = & $ shortcuts ; } else { $ this -> shortcuts [ $ lang ] = [ ] ; } } return [ $ this -> weekWords [ $ lang ] , $ this -> units , $ this -> shortcuts [ $ lang ] ] ; }
1694	public function exportStyleSheet ( DataContainer $ dc ) { $ objStyleSheet = $ this -> Database -> prepare ( "SELECT * FROM tl_style_sheet WHERE id=?" ) -> limit ( 1 ) -> execute ( $ dc -> id ) ; if ( $ objStyleSheet -> numRows < 1 ) { throw new \ Exception ( "Invalid style sheet ID {$dc->id}" ) ; } $ vars = array ( ) ; $ objTheme = $ this -> Database -> prepare ( "SELECT vars FROM tl_theme WHERE id=?" ) -> limit ( 1 ) -> execute ( $ objStyleSheet -> pid ) ; if ( $ objTheme -> vars != '' ) { if ( \ is_array ( ( $ tmp = StringUtil :: deserialize ( $ objTheme -> vars ) ) ) ) { foreach ( $ tmp as $ v ) { $ vars [ $ v [ 'key' ] ] = $ v [ 'value' ] ; } } } if ( $ objStyleSheet -> vars != '' ) { if ( \ is_array ( ( $ tmp = StringUtil :: deserialize ( $ objStyleSheet -> vars ) ) ) ) { foreach ( $ tmp as $ v ) { $ vars [ $ v [ 'key' ] ] = $ v [ 'value' ] ; } } } uksort ( $ vars , 'length_sort_desc' ) ; $ objFile = new File ( 'system/tmp/' . md5 ( uniqid ( mt_rand ( ) , true ) ) ) ; $ objFile -> write ( '' ) ; if ( $ objStyleSheet -> mediaQuery != '' ) { $ objFile -> append ( '@media ' . $ objStyleSheet -> mediaQuery . ' {' ) ; } $ objDefinitions = $ this -> Database -> prepare ( "SELECT * FROM tl_style WHERE pid=? AND invisible!='1' ORDER BY sorting" ) -> execute ( $ objStyleSheet -> id ) ; while ( $ objDefinitions -> next ( ) ) { $ objFile -> append ( $ this -> compileDefinition ( $ objDefinitions -> row ( ) , false , $ vars , $ objStyleSheet -> row ( ) , true ) , '' ) ; } if ( $ objStyleSheet -> mediaQuery != '' ) { $ objFile -> append ( '}' ) ; } $ objFile -> close ( ) ; $ objFile -> sendToBrowser ( $ objStyleSheet -> name . '.css' ) ; $ objFile -> delete ( ) ; }
8163	static public function register ( ) { if ( static :: $ registered === true ) { return true ; } $ kirby = kirby ( ) ; if ( ! class_exists ( 'Kirby\Component\Template' ) ) { throw new Exception ( 'The Kirby Twig plugin requires Kirby 2.3 or higher. Current version: ' . $ kirby -> version ( ) ) ; } if ( ! class_exists ( 'Twig_Environment' ) ) { require_once __DIR__ . '/../lib/Twig/lib/Twig/Autoloader.php' ; \ Twig_Autoloader :: register ( ) ; } $ kirby -> set ( 'component' , 'template' , 'Kirby\Twig\TwigComponent' ) ; if ( is_executable ( 'twig' ) === false ) { require_once __DIR__ . '/helpers.php' ; } return static :: $ registered = true ; }
3008	public function getAttribute ( $ key ) { if ( ! isset ( $ this -> attributes [ $ key ] ) ) { return false ; } return $ this -> attributes [ $ key ] ; }
7026	public function checkRememberMeCookie ( ) { if ( ! $ this -> loggedIn ( ) && $ this -> Cookie -> read ( 'User.id' ) ) { return $ this -> Cookie -> read ( 'User.id' ) ; } return false ; }
11284	protected function _populateNonModelData ( $ record ) { $ nonObjectData = array_diff_key ( $ record , $ this -> model_attributes ) ; if ( count ( $ nonObjectData ) > 0 ) { foreach ( $ nonObjectData as $ key => $ value ) { $ this -> $ key = $ value ; } } }
7904	protected function renderSides ( $ sides ) { $ lines = [ ] ; $ lines [ ] = Html :: beginTag ( 'div' , $ this -> sidesOptions ) ; foreach ( $ sides as $ side ) { if ( ! array_key_exists ( 'content' , $ side ) ) { throw new InvalidConfigException ( "The 'content' option is required per sides" ) ; } $ options = ArrayHelper :: getValue ( $ side , 'options' , [ ] ) ; Ui :: addCssClass ( $ options , 'side' ) ; $ active = ArrayHelper :: getValue ( $ side , 'active' , false ) ; if ( $ active === true ) { Ui :: addCssClass ( $ options , 'active' ) ; } $ lines [ ] = Html :: tag ( 'div' , $ side [ 'content' ] , $ options ) ; } $ lines [ ] = Html :: endTag ( 'div' ) ; return implode ( "\n" , $ lines ) ; }
10604	public function setQueryParam ( $ name , $ value ) { if ( $ this -> checkQuery ( $ name ) ) { $ this -> editQuery ( $ name , $ value ) ; } else { $ this -> addQuery ( $ name , $ value ) ; } return $ this ; }
1062	public static function findTypesAddedToUnions ( Schema $ oldSchema , Schema $ newSchema ) { $ oldTypeMap = $ oldSchema -> getTypeMap ( ) ; $ newTypeMap = $ newSchema -> getTypeMap ( ) ; $ typesAddedToUnion = [ ] ; foreach ( $ newTypeMap as $ typeName => $ newType ) { $ oldType = $ oldTypeMap [ $ typeName ] ?? null ; if ( ! ( $ oldType instanceof UnionType ) || ! ( $ newType instanceof UnionType ) ) { continue ; } $ typeNamesInOldUnion = [ ] ; foreach ( $ oldType -> getTypes ( ) as $ type ) { $ typeNamesInOldUnion [ $ type -> name ] = true ; } foreach ( $ newType -> getTypes ( ) as $ type ) { if ( isset ( $ typeNamesInOldUnion [ $ type -> name ] ) ) { continue ; } $ typesAddedToUnion [ ] = [ 'type' => self :: DANGEROUS_CHANGE_TYPE_ADDED_TO_UNION , 'description' => sprintf ( '%s was added to union type %s.' , $ type -> name , $ typeName ) , ] ; } } return $ typesAddedToUnion ; }
4598	public function generateIdentity ( Identitiable $ model , bool $ overwrite = false ) { if ( null === $ model -> getIdentity ( ) || $ overwrite ) { $ user = $ this -> tokenStorage -> getToken ( ) -> getUser ( ) ; $ model -> setIdentity ( $ user -> getIdentity ( ) -> getType ( ) ) -> setIdentityUuid ( $ user -> getIdentity ( ) -> getUuid ( ) ) ; } return $ this ; }
11087	public static function getUserPlatform ( ) { $ user_agent = $ _SERVER [ 'HTTP_USER_AGENT' ] ; $ user_platform = 'unknown' ; if ( false !== stripos ( $ user_agent , 'linux' ) ) { $ user_platform = 'Linux' ; } elseif ( preg_match ( '/macintosh|mac os x/i' , $ user_agent ) ) { $ user_platform = 'Mac' ; } elseif ( preg_match ( '/windows|win32/i' , $ user_agent ) ) { $ user_platform = 'Windows' ; } return $ user_platform ; }
7264	private function validateItem ( SaleItemInterface $ item ) { foreach ( $ item -> getChildren ( ) as $ child ) { $ this -> validateItem ( $ child ) ; } if ( $ item -> isCompound ( ) ) { return ; } if ( null === $ subject = $ this -> subjectHelper -> resolve ( $ item , false ) ) { return ; } if ( ! $ subject instanceof StockSubjectInterface ) { return ; } $ quantity = $ item -> getTotalQuantity ( ) ; $ availability = $ this -> availabilityHelper -> getAvailability ( $ subject , is_null ( $ item -> getParent ( ) ) ) ; if ( $ quantity < $ availability -> getMinimumQuantity ( ) ) { $ message = $ availability -> getMinimumMessage ( ) ; } elseif ( $ quantity > $ availability -> getMaximumQuantity ( ) ) { $ message = $ availability -> getMaximumMessage ( ) ; } else { return ; } if ( null !== $ item -> getParent ( ) ) { $ message = $ item -> getDesignation ( ) . ' : ' . $ message ; } throw new ValidationFailedException ( $ message ) ; }
7780	public function validate_unique ( $ value , $ input , $ args ) { $ table = $ args [ 0 ] ; $ column = $ args [ 1 ] ; $ value = trim ( $ value ) ; $ exists = $ this -> db -> prepare ( " SELECT count(*) as count FROM {$table} WHERE {$column} = :value " ) ; $ exists -> execute ( [ 'value' => $ value ] ) ; return ! ( bool ) $ exists -> fetchObject ( ) -> count ; }
6957	private function _getRenderedToc ( $ list , $ depth = 1 ) { if ( ! isset ( $ list ) || empty ( $ list ) ) return ( '' ) ; $ html = "<ul class=\"toc-list\">\n" ; foreach ( $ list as $ entry ) { $ html .= "<li class=\"toc-entry\">\n" ; $ html .= '<a href="#' . $ this -> getParam ( 'anchorsPrefix' ) . $ this -> titleToIdentifier ( $ depth , $ entry [ 'value' ] ) . '">' . $ entry [ 'value' ] . "</a>\n" ; if ( isset ( $ entry [ 'sub' ] ) ) $ html .= $ this -> _getRenderedToc ( $ entry [ 'sub' ] , ( $ depth + 1 ) ) ; $ html .= "</li>\n" ; } $ html .= "</ul>\n" ; return ( $ html ) ; }
12613	private function checkOptions ( $ options ) { foreach ( $ this -> required as $ req ) { if ( ! array_key_exists ( $ req , $ options ) ) { throw new \ Exception ( '"' . $ req . '" option has not been defined' ) ; } } }
11416	private function saveLog ( $ operId , $ calcId ) { $ entity = new ELogOper ( ) ; $ entity -> setOperId ( $ operId ) ; $ entity -> setCalcId ( $ calcId ) ; $ this -> daoLogOper -> create ( $ entity ) ; }
5297	protected function getOptionsFromXML ( ) { $ options = array ( ) ; foreach ( array ( 'id' , 'horiz-adv-x' ) as $ key ) { if ( isset ( $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] [ $ key ] ) ) { $ options [ $ key ] = ( string ) $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] [ $ key ] ; } } foreach ( array ( 'units-per-em' , 'ascent' , 'descent' , 'x-height' , 'cap-height' ) as $ key ) { if ( isset ( $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] -> { 'font-face' } [ 0 ] [ $ key ] ) ) { $ options [ $ key ] = ( string ) $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] -> { 'font-face' } [ 0 ] [ $ key ] ; } } return $ options ; }
2782	public function renderShadowMark ( $ count , $ current , $ eolInterval = 60 ) { $ this -> progressCount ++ ; $ this -> write ( '<fg=blue;options=bold>S</fg=blue;options=bold>' , false ) ; if ( ( $ this -> progressCount % $ eolInterval ) == 0 ) { $ counter = str_pad ( $ this -> progressCount , 5 , ' ' , STR_PAD_LEFT ) ; $ this -> write ( ' |' . $ counter . ' (' . str_pad ( $ current , strlen ( $ count ) , ' ' , STR_PAD_LEFT ) . '/' . $ count . ')' . PHP_EOL , false ) ; } }
5514	public function expectOnce ( $ method , $ args = false , $ message = '%s' ) { $ this -> expectCallCount ( $ method , 1 , $ message ) ; if ( $ args !== false ) { $ this -> expect ( $ method , $ args , $ message ) ; } }
989	public function save ( ) { if ( ! $ this -> response ) { throw new Exception ( 'No activation response was recieved.' ) ; } $ planCharge = $ this -> shop -> planCharge ( ) ; if ( $ planCharge && ! $ planCharge -> isDeclined ( ) && ! $ planCharge -> isCancelled ( ) ) { $ planCharge -> cancel ( ) ; } $ charge = Charge :: firstOrNew ( [ 'charge_id' => $ this -> chargeId , 'shop_id' => $ this -> shop -> id , ] ) ; $ charge -> plan_id = $ this -> plan -> id ; $ charge -> type = $ this -> plan -> type ; $ charge -> status = $ this -> response -> status ; if ( $ this -> plan -> isType ( Plan :: PLAN_RECURRING ) ) { $ charge -> billing_on = $ this -> response -> billing_on ; $ charge -> trial_ends_on = $ this -> response -> trial_ends_on ; } $ charge -> activated_on = $ this -> response -> activated_on ?? Carbon :: today ( ) -> format ( 'Y-m-d' ) ; $ planDetails = $ this -> chargeParams ( ) ; unset ( $ planDetails [ 'return_url' ] ) ; foreach ( $ planDetails as $ key => $ value ) { $ charge -> { $ key } = $ value ; } return $ charge -> save ( ) ; }
1237	private function set ( $ class , $ name , $ value ) { self :: ensurePropertyExists ( $ class , $ name ) ; self :: ensurePropertyType ( $ class , $ name , $ value ) ; $ this -> setValue ( $ class , $ name , $ value ) ; }
1690	protected function writeStyleSheet ( $ row ) { if ( $ row [ 'id' ] == '' || $ row [ 'name' ] == '' ) { return ; } $ row [ 'name' ] = basename ( $ row [ 'name' ] ) ; if ( file_exists ( $ this -> strRootDir . '/assets/css/' . $ row [ 'name' ] . '.css' ) && ! $ this -> Files -> is_writeable ( 'assets/css/' . $ row [ 'name' ] . '.css' ) ) { Message :: addError ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'notWriteable' ] , 'assets/css/' . $ row [ 'name' ] . '.css' ) ) ; return ; } $ vars = array ( ) ; $ objTheme = $ this -> Database -> prepare ( "SELECT vars FROM tl_theme WHERE id=?" ) -> limit ( 1 ) -> execute ( $ row [ 'pid' ] ) ; if ( $ objTheme -> vars != '' ) { if ( \ is_array ( ( $ tmp = StringUtil :: deserialize ( $ objTheme -> vars ) ) ) ) { foreach ( $ tmp as $ v ) { $ vars [ $ v [ 'key' ] ] = $ v [ 'value' ] ; } } } if ( $ row [ 'vars' ] != '' ) { if ( \ is_array ( $ tmp = StringUtil :: deserialize ( $ row [ 'vars' ] ) ) ) { foreach ( $ tmp as $ v ) { $ vars [ $ v [ 'key' ] ] = $ v [ 'value' ] ; } } } uksort ( $ vars , 'length_sort_desc' ) ; $ objFile = new File ( 'assets/css/' . $ row [ 'name' ] . '.css' ) ; $ objFile -> write ( '/* ' . $ row [ 'name' ] . ".css */\n" ) ; $ objDefinitions = $ this -> Database -> prepare ( "SELECT * FROM tl_style WHERE pid=? AND invisible!='1' ORDER BY sorting" ) -> execute ( $ row [ 'id' ] ) ; while ( $ objDefinitions -> next ( ) ) { $ objFile -> append ( $ this -> compileDefinition ( $ objDefinitions -> row ( ) , true , $ vars , $ row ) , '' ) ; } $ objFile -> close ( ) ; }
1814	public function listImportWizard ( ) { return ' <a href="' . $ this -> addToUrl ( 'key=list' ) . '" title="' . Contao \ StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'lw_import' ] [ 1 ] ) . '" onclick="Backend.getScrollOffset()">' . Contao \ Image :: getHtml ( 'tablewizard.svg' , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'tw_import' ] [ 0 ] ) . '</a>' ; }
12506	public static function sendQuery ( ConnectionInterface $ connection ) { $ response = DataLayer :: execute ( $ connection ) ; $ connection -> resetSelf ( ) ; return $ response ; }
5340	public function setBalancingMode ( $ haipName , $ balancingMode , $ cookieName = '' ) { return $ this -> call ( self :: SERVICE , 'setBalancingMode' , [ $ haipName , $ balancingMode , $ cookieName ] ) ; }
9589	public function dropDownListDefault ( $ items , $ options = [ ] ) { Html :: addCssClass ( $ options , 'browser-default' ) ; return parent :: dropDownList ( $ items , $ options ) ; }
12075	public function childShow ( FilterRequest $ filters , $ id , $ idChild , $ relation ) { $ id = $ this -> getRealId ( $ id ) ; $ idChild = $ this -> getRealId ( $ idChild ) ; $ resource = $ this -> repository -> getChild ( $ id , $ relation , $ idChild , $ filters ) ; if ( ! $ resource ) { } return $ this -> success ( $ resource ) ; }
439	public function hasProperty ( $ name , $ checkVars = true , $ checkBehaviors = true ) { return $ this -> canGetProperty ( $ name , $ checkVars , $ checkBehaviors ) || $ this -> canSetProperty ( $ name , false , $ checkBehaviors ) ; }
12658	private function getFileName ( $ language ) { if ( $ language === $ this -> baseLang ) { return $ this -> baseDir . $ this -> pageName . '.js' ; } else { return $ this -> baseDir . $ language . '/' . $ this -> pageName . '.js' ; } }
3124	protected function fixRange ( $ range , $ lastTimestamp = null ) { $ fixedRange = [ ] ; $ last = null ; $ open = false ; foreach ( $ range as $ point ) { if ( $ this -> isStartPoint ( $ point ) ) { if ( $ last && $ open ) { $ fixedRange [ ] = $ this -> cloneTimePoint ( $ point , TimePoint :: TYPE_END ) ; } $ open = true ; } else if ( $ this -> isEndPoint ( $ point ) ) { if ( ! $ open ) { $ fixedRange [ ] = $ this -> cloneTimePoint ( $ last ? $ last : $ point , TimePoint :: TYPE_START ) ; } $ open = false ; } $ fixedRange [ ] = $ point ; $ last = $ point ; } if ( $ last && $ open ) { $ fixedRange [ ] = $ this -> cloneTimePoint ( $ last , TimePoint :: TYPE_END , $ lastTimestamp ) ; } return $ fixedRange ; }
12265	public function findInSourceDirs ( Finder $ finder ) { foreach ( $ this -> sourceDirs as $ dir ) { $ finder -> in ( $ dir ) ; } return $ finder ; }
8993	public function expecting ( ) { $ possibilities = count ( $ this -> samples ) ; $ orderedByOccurance = array_count_values ( $ this -> samples ) ; array_multisort ( $ orderedByOccurance , SORT_DESC ) ; $ probabilities = [ ] ; foreach ( $ orderedByOccurance as $ item => $ value ) { $ probabilities [ $ item ] = $ value / $ possibilities ; } return $ probabilities ; }
4175	public function getProviders ( ) { return $ this -> providers ? : $ this -> providers = new ServiceProvider ( clone $ this -> getFiles ( ) , $ this -> console ) ; }
4637	private function createMailEvent ( Email $ email , string $ name , ResultInterface $ result = null ) : MailEvent { $ event = new MailEvent ( $ email , $ name ) ; if ( $ result !== null ) { $ event -> setResult ( $ result ) ; } return $ event ; }
12065	public function destroy ( ) { session_start ( ) ; $ _SESSION = array ( ) ; if ( ini_get ( "session.use_cookies" ) ) { $ aParams = session_get_cookie_params ( ) ; setcookie ( session_name ( ) , '' , time ( ) - 42000 , $ aParams [ "path" ] , $ aParams [ "domain" ] , $ aParams [ "secure" ] , $ aParams [ "httponly" ] ) ; } session_destroy ( ) ; }
10327	function fromXML ( $ xmlElement ) { $ this -> author = $ xmlElement -> author ; $ this -> countContacts = $ xmlElement -> count_contacts ; $ this -> countRules = $ xmlElement -> count_rules ; $ this -> created = $ xmlElement -> created ; $ this -> id = $ xmlElement -> id ; $ this -> name = $ xmlElement -> name ; $ this -> state = $ xmlElement -> state ; if ( $ xmlElement -> rules ) { $ rules = $ xmlElement -> rules ; foreach ( $ rules as $ rule ) { array_push ( $ this -> rules , new Rule ( $ rule -> is_customfield , $ rule -> field , $ rule -> operator , $ rule -> value , $ rule -> type ) ) ; } } }
3939	private function setEval ( $ property , $ propInfo , $ isTranslated ) { $ extra = isset ( $ propInfo [ 'eval' ] ) ? $ propInfo [ 'eval' ] : [ ] ; if ( $ isTranslated ) { $ extra [ 'tl_class' ] = 'translat-attr' . ( ! empty ( $ extra [ 'tl_class' ] ) ? ' ' . $ extra [ 'tl_class' ] : '' ) ; } $ property -> setExtra ( array_merge ( ( array ) $ property -> getExtra ( ) , $ extra ) ) ; }
5990	public function addPropertyCriteria ( $ item ) { if ( ! ( $ item instanceof PropertyCriteria ) ) { if ( is_array ( $ item ) ) { try { $ item = new PropertyCriteria ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate PropertyCriteria. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "PropertyCriteria"!' , E_USER_WARNING ) ; } } $ this -> properties [ ] = $ item ; return $ this ; }
9812	protected function putRaw ( string $ path , $ body = null , array $ headers = [ ] ) { $ response = $ this -> client -> put ( $ path , $ headers , $ body ) ; return ResponseMediator :: getContent ( $ response ) ; }
10774	protected function loginByCookie ( ) { $ value = Yii :: $ app -> getRequest ( ) -> getCookies ( ) -> getValue ( $ this -> identityCookie [ 'name' ] ) ; if ( $ value === null ) { return ; } $ data = json_decode ( $ value , true ) ; if ( count ( $ data ) !== 3 || ! isset ( $ data [ 0 ] , $ data [ 1 ] , $ data [ 2 ] ) ) { return ; } list ( $ id , $ authKey , $ duration ) = $ data ; $ class = $ this -> identityClass ; $ identity = $ class :: findIdentity ( $ id ) ; if ( $ identity === null ) { return ; } elseif ( ! $ identity instanceof IdentityInterface ) { throw new InvalidValueException ( "$class::findIdentity() must return an object implementing IdentityInterface." ) ; } if ( $ identity -> validateAuthKey ( $ authKey ) ) { if ( $ this -> beforeLogin ( $ identity , true , $ duration ) ) { $ this -> switchIdentity ( $ identity , $ this -> autoRenewCookie ? $ duration : 0 ) ; $ ip = Yii :: $ app -> getRequest ( ) -> getUserIP ( ) ; Yii :: info ( "User '$id' logged in from $ip via cookie." , __METHOD__ ) ; $ this -> afterLogin ( $ identity , true , $ duration ) ; } } else { Yii :: warning ( "Invalid auth key attempted for user '$id': $authKey" , __METHOD__ ) ; } }
3511	protected function adjustTranslationTable ( $ sql ) { $ adjustedSql = $ this -> tableRenameNeeded ? str_replace ( ' ltm_translations ' , ' ' . $ this -> tableName . ' ' , $ sql ) : $ sql ; return $ adjustedSql ; }
8898	public function update ( $ primary_value , $ data ) { $ data = $ this -> _do_pre_update ( $ data ) ; if ( $ data !== FALSE ) { $ result = $ this -> _database -> where ( $ this -> primary_key , $ primary_value ) -> set ( $ data ) -> update ( $ this -> _table ) ; $ this -> trigger ( 'after_update' , array ( $ data , $ result ) ) ; return $ result ; } else { return FALSE ; } }
1524	protected function doRead ( StoreInterface $ store , FetchResource $ request ) { $ record = $ request -> getRecord ( ) ; if ( $ result = $ this -> invoke ( 'reading' , $ record , $ request ) ) { return $ result ; } $ record = $ store -> readRecord ( $ record , $ request -> getParameters ( ) ) ; if ( $ result = $ this -> invoke ( 'didRead' , $ record , $ request ) ) { return $ result ; } return $ record ; }
12809	private static function isPrimaryKey ( string $ table , string $ column ) : bool { return self :: getPrimaryKey ( $ table ) [ "column_name" ] === $ column ; }
12366	public function getNextVideoToConvert ( ) { $ query = $ this -> createQueryBuilder ( 'v' ) ; $ this -> onlyUploaded ( $ query ) ; return $ query -> getQuery ( ) -> getOneOrNullResult ( ) ; }
7481	public function setContent ( $ content ) { Argument :: i ( ) -> test ( 1 , 'string' ) ; try { $ this -> absolute ( ) ; } catch ( \ Eden \ Path \ Exception $ e ) { $ this -> touch ( ) ; } file_put_contents ( $ this -> data , $ content ) ; return $ this ; }
12481	public function registerServices ( ServicesFactory $ servicesFactory , array $ entityManagers ) { foreach ( $ entityManagers as $ name => $ entityManager ) { $ emConfig = Setup :: createAnnotationMetadataConfiguration ( ( array ) $ entityManager -> getEntities ( ) , true , null , null , true ) ; $ emConfig -> setNamingStrategy ( new UnderscoreNamingStrategy ( ) ) ; $ em = $ this -> createEntityManager ( $ entityManager -> toArray ( ) , $ emConfig ) ; $ emServiceId = 'doctrine.em.' . Str :: cast ( $ name ) -> lower ( ) ; $ servicesFactory -> registerService ( [ 'id' => $ emServiceId , 'instance' => $ em ] ) ; $ servicesFactory -> registerService ( [ 'id' => 'db.connection.' . $ name , 'instance' => $ em -> getConnection ( ) -> getWrappedConnection ( ) ] ) ; } }
3575	public function forget ( $ key ) { if ( $ attribute = $ this -> get ( $ key ) ) { $ attribute -> setValue ( null ) ; } return $ this ; }
12591	protected function checkParams ( $ params , $ operator ) { if ( ! is_array ( $ params ) ) { throw new Exception ( 'Web2All_Table_MultiValueOperator: first param must be an array' ) ; } if ( $ operator == 'IN' ) { if ( count ( $ params ) < 1 ) { throw new Exception ( 'Web2All_Table_MultiValueOperator: IN operator requires at least one param' ) ; } } elseif ( $ operator == 'BETWEEN' ) { if ( count ( $ params ) != 2 ) { throw new Exception ( 'Web2All_Table_MultiValueOperator: BETWEEN operator requires exactly two params' ) ; } } else { throw new Exception ( 'Web2All_Table_MultiValueOperator: unsupported operator "' . $ operator . '"' ) ; } }
11372	protected function onClassFound ( ScannedPhpClass $ subject ) { $ class = $ subject -> getClass ( ) ; $ main = $ this -> reader -> getClassAnnotation ( $ class , Di \ DiServiceAnnotation :: class ) ; if ( $ main instanceof Di \ DiServiceAnnotation ) { $ definition = $ this -> provideServiceDefinitionFor ( new ServiceDefinitionProvider \ Frame ( $ class , $ main , DiOptionsCollection :: from ( $ this -> reader , $ class ) , null ) ) ; $ this -> addServiceDefinition ( $ definition ) ; } }
3976	public function handle ( EncodePropertyValueFromWidgetEvent $ event ) { if ( ! parent :: wantToHandle ( $ event ) || ( $ event -> getProperty ( ) !== 'colname' ) ) { return ; } $ oldColumnName = $ event -> getModel ( ) -> getProperty ( $ event -> getProperty ( ) ) ; $ columnName = $ event -> getValue ( ) ; $ metaModel = $ this -> getMetaModelByModelPid ( $ event -> getModel ( ) ) ; if ( ( ! $ columnName ) || $ oldColumnName !== $ columnName ) { $ this -> tableManipulator -> checkColumnDoesNotExist ( $ metaModel -> getTableName ( ) , $ columnName ) ; $ colNames = array_keys ( $ metaModel -> getAttributes ( ) ) ; if ( in_array ( $ columnName , $ colNames ) ) { throw new \ RuntimeException ( sprintf ( $ event -> getEnvironment ( ) -> getTranslator ( ) -> translate ( 'columnExists' , 'ERR' ) , $ columnName , $ metaModel -> getTableName ( ) ) ) ; } } }
1645	public function getDistance ( Coordinate $ coordinate , DistanceInterface $ calculator ) : float { return $ calculator -> getDistance ( $ this , $ coordinate ) ; }
7829	public function getLeftBordersWith ( $ border ) { $ border = str_repeat ( $ border , static :: BORDER_WIDTH ) ; $ space = str_repeat ( ' ' , static :: MIN_SPACE_FROM_BORDER_X ) ; return str_repeat ( "{$border}{$space}" , $ this -> nesting ) ; }
2086	public static function getPath ( $ template , $ format , $ custom = 'templates' ) { $ file = $ template . '.' . $ format ; $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( file_exists ( $ rootDir . '/' . $ custom . '/' . $ file ) ) { return $ rootDir . '/' . $ custom . '/' . $ file ; } if ( $ custom != 'templates' ) { if ( file_exists ( $ rootDir . '/templates/' . $ file ) ) { return $ rootDir . '/templates/' . $ file ; } } return static :: getDefaultPath ( $ template , $ format ) ; }
5420	protected function parseCookie ( $ cookie_line ) { $ parts = explode ( ';' , $ cookie_line ) ; $ cookie = array ( ) ; preg_match ( '/\s*(.*?)\s*=(.*)/' , array_shift ( $ parts ) , $ cookie ) ; foreach ( $ parts as $ part ) { if ( preg_match ( '/\s*(.*?)\s*=(.*)/' , $ part , $ matches ) ) { $ cookie [ $ matches [ 1 ] ] = trim ( $ matches [ 2 ] ) ; } } return new SimpleCookie ( $ cookie [ 1 ] , trim ( $ cookie [ 2 ] ) , isset ( $ cookie [ 'path' ] ) ? $ cookie [ 'path' ] : '' , isset ( $ cookie [ 'expires' ] ) ? $ cookie [ 'expires' ] : false ) ; }
2672	public function upsertDictionaryItem ( $ dictionaryId , $ itemKey , $ itemValue ) { $ body = [ 'item_value' => $ itemValue ] ; $ url = $ this -> _getApiServiceUri ( ) . 'dictionary/' . $ dictionaryId . '/item/' . urlencode ( $ itemKey ) ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: PUT , $ body ) ; if ( ! $ result ) { throw new LocalizedException ( __ ( 'Failed to create Dictionary item.' ) ) ; } }
11955	public function generate ( RouterInterface $ router ) { $ routes = $ router -> getRouteCollection ( ) ; $ pagesDir = $ this -> configurationHandler -> pagesDir ( ) ; $ homepageValues = array ( '_locale' => $ this -> configurationHandler -> language ( ) , 'country' => $ this -> configurationHandler -> country ( ) , 'page' => $ this -> configurationHandler -> homepage ( ) , ) ; $ homeRouteName = '_home_' . $ homepageValues [ "_locale" ] . '_' . $ homepageValues [ "country" ] . '_' . $ homepageValues [ "page" ] ; $ this -> routes [ "homepage" ] = $ homeRouteName ; if ( $ this -> explicitHomepageRoute ) { $ values = array_merge ( $ homepageValues , array ( '_controller' => $ this -> frontController , ) ) ; $ routes -> add ( $ homeRouteName , new Route ( $ this -> pattern , $ values ) ) ; } $ seoFileName = 'seo.json' ; if ( null !== $ this -> contributor ) { $ seoFileName = $ this -> contributor . '.json' ; } $ finder = new Finder ( ) ; $ pages = $ finder -> directories ( ) -> depth ( 0 ) -> in ( $ pagesDir ) ; foreach ( $ pages as $ page ) { $ this -> generateLanguagesRoutes ( $ routes , $ page , $ seoFileName ) ; } }
3738	private function getConnection ( ) { if ( $ this -> connection ) { return $ this -> connection ; } $ reflection = new \ ReflectionProperty ( \ Contao \ Database :: class , 'resConnection' ) ; $ reflection -> setAccessible ( true ) ; return $ this -> connection = $ reflection -> getValue ( $ this -> getDatabase ( ) ) ; }
1349	public function any ( string ... $ resourceTypes ) : self { foreach ( $ resourceTypes as $ resourceType ) { $ this -> allow ( $ resourceType , null ) ; } return $ this ; }
1330	public function queryToMany ( $ relation , EncodingParametersInterface $ parameters ) { return $ this -> queryAllOrOne ( $ relation -> newQuery ( ) , $ this -> getQueryParameters ( $ parameters ) ) ; }
5518	public function invoke ( $ method , $ args ) { $ method = strtolower ( $ method ) ; $ step = $ this -> getCallCount ( $ method ) ; $ this -> addCall ( $ method , $ args ) ; $ this -> checkExpectations ( $ method , $ args , $ step ) ; $ was = $ this -> disableEStrict ( ) ; try { $ result = $ this -> emulateCall ( $ method , $ args , $ step ) ; } catch ( Exception $ e ) { $ this -> restoreEStrict ( $ was ) ; throw $ e ; } $ this -> restoreEStrict ( $ was ) ; return $ result ; }
10489	public static function unbufferConnection ( Connection $ connection ) { $ wrappedConnection = $ connection -> getWrappedConnection ( ) ; if ( ! $ wrappedConnection instanceof PDOConnection ) { throw new InvalidArgumentException ( 'unbufferConection can only be used with pdo_mysql Doctrine driver.' ) ; } if ( $ wrappedConnection -> getAttribute ( PDO :: ATTR_DRIVER_NAME ) != 'mysql' ) { throw new InvalidArgumentException ( 'unbufferConection can only be used with PDO mysql driver, got "' . $ wrappedConnection -> getAttribute ( PDO :: ATTR_DRIVER_NAME ) . '" instead.' ) ; } if ( $ connection -> isConnected ( ) ) { $ connection -> close ( ) ; } $ connection -> getWrappedConnection ( ) -> setAttribute ( PDO :: MYSQL_ATTR_USE_BUFFERED_QUERY , false ) ; $ connection -> connect ( ) ; }
1854	public static function findCurrentByPid ( $ intPid , $ intStart , $ intEnd , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ intStart = ( int ) $ intStart ; $ intEnd = ( int ) $ intEnd ; $ arrColumns = array ( "$t.pid=? AND (($t.startTime>=$intStart AND $t.startTime<=$intEnd) OR ($t.endTime>=$intStart AND $t.endTime<=$intEnd) OR ($t.startTime<=$intStart AND $t.endTime>=$intEnd) OR ($t.recurring='1' AND ($t.recurrences=0 OR $t.repeatEnd>=$intStart) AND $t.startTime<=$intEnd))" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.startTime" ; } return static :: findBy ( $ arrColumns , $ intPid , $ arrOptions ) ; }
7213	public function configure ( $ subject ) { if ( $ subject instanceof InvoiceInterface ) { $ this -> date = $ subject -> getCreatedAt ( ) -> format ( 'Y-m-d' ) ; } elseif ( $ subject instanceof PaymentInterface ) { $ this -> date = $ subject -> getCompletedAt ( ) -> format ( 'Y-m-d' ) ; } else { throw new InvalidArgumentException ( "Expected instance of " . InvoiceInterface :: class . " or " . PaymentInterface :: class ) ; } $ this -> number = $ subject -> getNumber ( ) ; $ sale = $ subject -> getSale ( ) ; if ( $ customer = $ sale -> getCustomer ( ) ) { $ this -> identity = $ customer -> getFirstName ( ) . ' ' . $ customer -> getLastName ( ) ; } else { $ this -> identity = $ sale -> getFirstName ( ) . ' ' . $ sale -> getLastName ( ) ; } }
7468	protected function colorize ( $ str , $ attrs ) { $ start = $ this -> start ( $ attrs ) ; return $ start . $ str . $ this -> end ( ) ; }
9431	public function routes ( ) { $ routes = array_merge ( $ this -> routes , $ this -> collector -> getData ( ) ) ; return function ( RouteCollector $ collector ) use ( $ routes ) { foreach ( array_filter ( $ routes ) as $ route ) { list ( $ method , $ uri , $ handler ) = ( array ) $ route ; $ collector -> addRoute ( $ method , $ uri , $ handler ) ; } } ; }
8751	private function addCurrentMessage ( ) { if ( $ this -> currentMessage -> hasTranslation ( ) ) { $ this -> messages [ ] = $ this -> currentMessage ; $ this -> currentMessage = new Message ( ) ; } }
1143	protected function bootstrapViews ( ) { $ viewPath = realpath ( __DIR__ . '/../resources/views' ) ; $ this -> loadViewsFrom ( $ viewPath , 'jsvalidation' ) ; $ this -> publishes ( [ $ viewPath => $ this -> app [ 'path.base' ] . '/resources/views/vendor/jsvalidation' , ] , 'views' ) ; }
3146	public function resume ( RunnerServiceContext $ context ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ context -> getTestSession ( ) -> resume ( ) ; $ this -> persist ( $ context ) ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'resume' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } return true ; }
8040	public function buildEventDates ( array $ data ) { $ dates = [ ] ; $ eventLength = $ this -> calculateEventLength ( $ data ) ; $ allDay = array_key_exists ( 'all_day' , $ data ) ; foreach ( $ data [ 'repeat_dates' ] as $ date ) { if ( strlen ( $ date ) > 0 ) { $ date = strtotime ( $ date . ' ' . $ data [ 'start' ] [ 'time' ] ) ; if ( false === $ date ) { throw new InvalidDateStringException ( 'Invalid date string!' ) ; } $ eventStart = $ this -> carbon -> copy ( ) -> setTimestamp ( $ date ) ; $ eventEnds = $ allDay ? null : $ eventStart -> copy ( ) -> addSeconds ( $ eventLength ) ; $ dates [ ] = [ 'start' => $ eventStart -> toDateTimeString ( ) , 'end' => ( null !== $ eventEnds ) ? $ eventEnds -> toDateTimeString ( ) : null , ] ; } } return $ dates ; }
583	public function actionCompress ( $ configFile , $ bundleFile ) { $ this -> loadConfiguration ( $ configFile ) ; $ bundles = $ this -> loadBundles ( $ this -> bundles ) ; $ targets = $ this -> loadTargets ( $ this -> targets , $ bundles ) ; foreach ( $ targets as $ name => $ target ) { $ this -> stdout ( "Creating output bundle '{$name}':\n" ) ; if ( ! empty ( $ target -> js ) ) { $ this -> buildTarget ( $ target , 'js' , $ bundles ) ; } if ( ! empty ( $ target -> css ) ) { $ this -> buildTarget ( $ target , 'css' , $ bundles ) ; } $ this -> stdout ( "\n" ) ; } $ targets = $ this -> adjustDependency ( $ targets , $ bundles ) ; $ this -> saveTargets ( $ targets , $ bundleFile ) ; if ( $ this -> deleteSource ) { $ this -> deletePublishedAssets ( $ bundles ) ; } }
12819	public static function setPermission ( array $ paths ) { foreach ( $ paths as $ path => $ permission ) { echo "chmod('$path', $permission)..." ; if ( is_dir ( $ path ) || is_file ( $ path ) ) { chmod ( $ path , octdec ( $ permission ) ) ; echo "done.\n" ; } else { echo "file not found.\n" ; } } }
5579	public function clickImageById ( $ id , $ x = 1 , $ y = 1 , $ additional = false ) { if ( ! ( $ form = $ this -> page -> getFormByImage ( new SelectById ( $ id ) ) ) ) { return false ; } $ success = $ this -> load ( $ form -> getAction ( ) , $ form -> submitImage ( new SelectById ( $ id ) , $ x , $ y , $ additional ) ) ; return ( $ success ? $ this -> getContent ( ) : $ success ) ; }
5418	public function writeCookiesToJar ( $ jar , $ url ) { foreach ( $ this -> cookies as $ cookie ) { $ jar -> setCookie ( $ cookie -> getName ( ) , $ cookie -> getValue ( ) , $ url -> getHost ( ) , $ cookie -> getPath ( ) , $ cookie -> getExpiry ( ) ) ; } }
2925	public function normaliseValue ( $ value , $ quote = '' ) { if ( strlen ( $ quote ) == 0 ) { return trim ( $ value ) ; } $ value = str_replace ( "\\$quote" , $ quote , $ value ) ; $ value = str_replace ( '\\\\' , '\\' , $ value ) ; return $ value ; }
9308	public function register ( ) { $ app = $ this -> app ; $ app -> bind ( 'Germanazo\CkanApi\CkanApiClient' , function ( ) { $ config = [ 'base_uri' => config ( 'ckan_api.url' ) , 'headers' => [ 'Authorization' => config ( 'ckan_api.api_key' ) ] , ] ; return new CkanApiClient ( new Client ( $ config ) ) ; } ) ; $ app -> alias ( 'Germanazo\CkanApi\CkanApiClient' , 'CkanApi' ) ; }
8069	public function bind ( $ username , $ password ) { if ( $ this -> tls ) { if ( ! ldap_start_tls ( $ this -> connection ) ) { throw new ConnectionException ( 'Unable to Connect to LDAP using TLS.' ) ; } } try { $ this -> bound = ldap_bind ( $ this -> connection , $ username , $ password ) ; } catch ( ErrorException $ e ) { $ this -> bound = false ; } return $ this -> bound ; }
2523	protected function makeMessageOptions ( array $ incoming , $ endSession = false ) { $ options = [ 'endSession' => $ endSession , 'returnXml' => $ this -> returnResultXml ] ; if ( array_key_exists ( 'endSession' , $ incoming ) ) { $ options [ 'endSession' ] = $ incoming [ 'endSession' ] ; } if ( array_key_exists ( 'returnXml' , $ incoming ) ) { $ options [ 'returnXml' ] = $ incoming [ 'returnXml' ] ; } return $ options ; }
337	protected function extractColumnType ( $ column , $ dbType , $ precision , $ scale , $ length ) { $ column -> dbType = $ dbType ; if ( strpos ( $ dbType , 'FLOAT' ) !== false || strpos ( $ dbType , 'DOUBLE' ) !== false ) { $ column -> type = 'double' ; } elseif ( strpos ( $ dbType , 'NUMBER' ) !== false ) { if ( $ scale === null || $ scale > 0 ) { $ column -> type = 'decimal' ; } else { $ column -> type = 'integer' ; } } elseif ( strpos ( $ dbType , 'INTEGER' ) !== false ) { $ column -> type = 'integer' ; } elseif ( strpos ( $ dbType , 'BLOB' ) !== false ) { $ column -> type = 'binary' ; } elseif ( strpos ( $ dbType , 'CLOB' ) !== false ) { $ column -> type = 'text' ; } elseif ( strpos ( $ dbType , 'TIMESTAMP' ) !== false ) { $ column -> type = 'timestamp' ; } else { $ column -> type = 'string' ; } }
3859	public function addFilterRule ( $ objFilterRule ) { if ( ! $ this -> objFilter ) { $ this -> objFilter = $ this -> objMetaModel -> getEmptyFilter ( ) ; } $ this -> objFilter -> addFilterRule ( $ objFilterRule ) ; return $ this ; }
9350	public function transpose ( ) { $ out = new self ( $ this -> size -> cols , $ this -> size -> rows ) ; foreach ( $ this -> arr as $ row ) { $ out -> addCol ( $ row ) ; } return $ out ; }
6053	public function retrieveParents ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/folders/' . $ id . '/parents' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new FolderParent ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
711	public function smallInteger ( $ length = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_SMALLINT , $ length ) ; }
1804	protected function invalidateCacheTags ( self $ dc ) { if ( ! System :: getContainer ( ) -> has ( 'fos_http_cache.cache_manager' ) ) { return ; } $ ns = 'contao.db.' ; $ tags = array ( $ ns . $ dc -> table , $ ns . $ dc -> table . '.' . $ dc -> id ) ; if ( $ dc -> ptable && $ dc -> activeRecord && $ dc -> activeRecord -> pid > 0 ) { $ tags [ ] = $ ns . $ dc -> ptable ; $ tags [ ] = $ ns . $ dc -> ptable . '.' . $ dc -> activeRecord -> pid ; } if ( \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'config' ] [ 'oninvalidate_cache_tags_callback' ] ) ) { foreach ( $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'config' ] [ 'oninvalidate_cache_tags_callback' ] as $ callback ) { if ( \ is_array ( $ callback ) ) { $ this -> import ( $ callback [ 0 ] ) ; $ tags = $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ dc , $ tags ) ; } elseif ( \ is_callable ( $ callback ) ) { $ tags = $ callback ( $ dc , $ tags ) ; } } } $ tags = array_filter ( array_unique ( $ tags ) ) ; $ cacheManager = System :: getContainer ( ) -> get ( 'fos_http_cache.cache_manager' ) ; $ cacheManager -> invalidateTags ( $ tags ) ; }
615	protected function resolveDependencies ( $ dependencies , $ reflection = null ) { foreach ( $ dependencies as $ index => $ dependency ) { if ( $ dependency instanceof Instance ) { if ( $ dependency -> id !== null ) { $ dependencies [ $ index ] = $ this -> get ( $ dependency -> id ) ; } elseif ( $ reflection !== null ) { $ name = $ reflection -> getConstructor ( ) -> getParameters ( ) [ $ index ] -> getName ( ) ; $ class = $ reflection -> getName ( ) ; throw new InvalidConfigException ( "Missing required parameter \"$name\" when instantiating \"$class\"." ) ; } } } return $ dependencies ; }
4619	public static function fromString ( $ location_string ) { preg_match ( '/^\/types\/([^\/]+)\/buckets\/([^\/]+)\/keys\/([^\/]+)$/' , $ location_string , $ matches ) ; return new self ( $ matches [ 3 ] , new Bucket ( $ matches [ 2 ] , $ matches [ 1 ] ) ) ; }
1957	public function generate ( ) { if ( $ this -> vimeo == '' ) { return '' ; } if ( TL_MODE == 'BE' ) { $ return = '<p><a href="https://vimeo.com/' . $ this -> vimeo . '" target="_blank" rel="noreferrer noopener">vimeo.com/' . $ this -> vimeo . '</a></p>' ; if ( $ this -> headline != '' ) { $ return = '<' . $ this -> hl . '>' . $ this -> headline . '</' . $ this -> hl . '>' . $ return ; } return $ return ; } return parent :: generate ( ) ; }
9554	public function naming ( $ namer ) { if ( $ namer instanceof \ Closure ) { $ namer = new ClosureNamer ( $ namer ) ; } $ this -> namer = $ namer ; return $ this ; }
661	public function beginTransaction ( $ isolationLevel = null ) { $ this -> open ( ) ; if ( ( $ transaction = $ this -> getTransaction ( ) ) === null ) { $ transaction = $ this -> _transaction = new Transaction ( [ 'db' => $ this ] ) ; } $ transaction -> begin ( $ isolationLevel ) ; return $ transaction ; }
7653	public function dir_opendir ( $ path , $ options ) { $ this -> blobs = $ this -> getStorageClient ( $ path ) -> listBlobs ( $ this -> getContainerName ( $ path ) ) ; return is_array ( $ this -> blobs ) ; }
3605	private function isCacheSupport ( JsonRequest $ jsonRequest ) { try { return $ jsonRequest -> getId ( ) && null !== $ this -> getMethod ( $ jsonRequest ) -> getCache ( ) && ! $ this -> isDebug ( ) && $ this -> getCache ( ) ; } catch ( \ Exception $ e ) { return false ; } }
9270	public function load ( ContainerBuilder $ container ) { $ loader = $ this -> getContainerLoader ( $ container ) ; $ loader -> load ( $ this -> configFile ) ; }
2639	public function aroundGetElementByPathParts ( \ Closure $ proceed , array $ pathParts ) { $ result = $ proceed ( $ pathParts ) ; if ( $ this -> isLoaded == true || false ) { return $ result ; } if ( ( $ result instanceof Section ) == false ) { return $ result ; } if ( isset ( $ pathParts [ 0 ] ) == false || $ pathParts [ 0 ] != 'system' ) { return $ result ; } $ this -> isLoaded = true ; $ data = $ result -> getData ( ) ; if ( isset ( $ data [ 'children' ] [ 'full_page_cache' ] [ 'children' ] [ 'fastly_edge_modules' ] [ 'children' ] ) == false ) { return $ result ; } $ original = $ data [ 'children' ] [ 'full_page_cache' ] [ 'children' ] [ 'fastly_edge_modules' ] [ 'children' ] ; $ data [ 'children' ] [ 'full_page_cache' ] [ 'children' ] [ 'fastly_edge_modules' ] [ 'children' ] = array_merge ( $ original , $ this -> loadModlyData ( ) ) ; $ result -> setData ( $ data , $ this -> scopeDefiner -> getScope ( ) ) ; return $ result ; }
624	public function findWith ( $ with , & $ models ) { $ primaryModel = reset ( $ models ) ; if ( ! $ primaryModel instanceof ActiveRecordInterface ) { $ modelClass = $ this -> modelClass ; $ primaryModel = $ modelClass :: instance ( ) ; } $ relations = $ this -> normalizeRelations ( $ primaryModel , $ with ) ; foreach ( $ relations as $ name => $ relation ) { if ( $ relation -> asArray === null ) { $ relation -> asArray ( $ this -> asArray ) ; } $ relation -> populateRelation ( $ name , $ models ) ; } }
2243	public static function getForm ( $ varId , $ strColumn = 'main' , $ blnModule = false ) { if ( \ is_object ( $ varId ) ) { $ objRow = $ varId ; } else { if ( $ varId == '' ) { return '' ; } $ objRow = FormModel :: findByIdOrAlias ( $ varId ) ; if ( $ objRow === null ) { return '' ; } } $ strClass = $ blnModule ? Module :: findClass ( 'form' ) : ContentElement :: findClass ( 'form' ) ; if ( ! class_exists ( $ strClass ) ) { static :: log ( 'Form class "' . $ strClass . '" does not exist' , __METHOD__ , TL_ERROR ) ; return '' ; } $ objRow -> typePrefix = $ blnModule ? 'mod_' : 'ce_' ; $ objRow -> form = $ objRow -> id ; $ objElement = new $ strClass ( $ objRow , $ strColumn ) ; $ strBuffer = $ objElement -> generate ( ) ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getForm' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getForm' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getForm' ] as $ callback ) { $ strBuffer = static :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ objRow , $ strBuffer , $ objElement ) ; } } return $ strBuffer ; }
9440	protected function value ( $ name ) { $ object = isset ( $ this -> instances [ $ name ] ) ? $ this -> get ( $ name ) : null ; $ exists = ! $ object && $ this -> extra -> has ( $ name ) === true ; return $ exists === true ? $ this -> extra -> get ( $ name ) : $ object ; }
12657	public function deleteTextContainer ( $ name ) { foreach ( $ this -> languages as $ lang ) { $ this -> getPageTexts ( $ lang ) ; unset ( $ this -> contents [ $ lang ] [ $ name ] ) ; $ this -> writeTextsToFile ( $ lang ) ; } }
8838	private function getStatus ( ) : array { $ status = proc_get_status ( $ this -> process ) ; if ( ! $ status [ 'running' ] && is_null ( $ this -> exitCode ) ) { $ this -> exitCode = $ status [ 'exitcode' ] ; } return $ status ; }
4990	public function disableForm ( $ key = null ) { if ( null === $ key ) { $ this -> activeForms = array ( ) ; return $ this ; } if ( ! is_array ( $ key ) ) { $ key = array ( $ key ) ; } foreach ( $ key as $ k ) { if ( false !== strpos ( $ k , '.' ) ) { list ( $ childKey , $ childForm ) = explode ( '.' , $ k , 2 ) ; $ child = $ this -> getForm ( $ childKey ) ; $ child -> disableForm ( $ childForm ) ; } elseif ( isset ( $ this -> forms [ $ k ] [ '__instance__' ] ) ) { unset ( $ this -> forms [ $ k ] [ '__instance__' ] ) ; } } $ this -> activeForms = array_filter ( $ this -> activeForms , function ( $ item ) use ( $ key ) { return ! in_array ( $ item , $ key ) ; } ) ; return $ this ; }
6428	protected function getFacebookObject ( ) { if ( is_object ( $ this -> fb ) ) { return $ this -> fb ; } $ fb = new \ Facebook \ Facebook ( [ 'app_id' => $ this -> options [ 'api_key' ] , 'app_secret' => $ this -> options [ 'secret_key' ] , 'default_graph_version' => 'v3.0' , ] ) ; $ this -> fb = $ fb ; return $ fb ; }
4056	private function convertLegend ( array $ property , bool $ trans , $ condition , array & $ legend , array & $ result ) { if ( ! empty ( $ legend [ 'properties' ] ) ) { $ result [ 'legend' . ( \ count ( $ result ) + 1 ) ] = $ legend ; } $ legend = [ 'label' => $ trans ? unserialize ( $ property [ 'legendtitle' ] , [ 'allowed_classes' => false ] ) : [ '' => $ property [ 'legendtitle' ] ] , 'hide' => ( bool ) $ property [ 'legendhide' ] , 'properties' => [ ] , 'condition' => $ condition ( $ property ) ] ; }
6266	public function reject ( Exception $ exception ) { if ( HttpPromise :: PENDING !== $ this -> state ) { throw new \ RuntimeException ( 'Promise is already resolved' ) ; } $ this -> state = HttpPromise :: REJECTED ; $ this -> exception = $ exception ; $ this -> doReject ( $ exception ) ; }
2010	public function indexAction ( ) : InitializeControllerResponse { @ trigger_error ( 'Custom entry points are deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; $ masterRequest = $ this -> get ( 'request_stack' ) -> getMasterRequest ( ) ; if ( null === $ masterRequest ) { throw new \ RuntimeException ( 'The request stack did not contain a master request.' ) ; } $ realRequest = Request :: createFromGlobals ( ) ; foreach ( [ 'REQUEST_URI' , 'SCRIPT_NAME' , 'SCRIPT_FILENAME' , 'PHP_SELF' ] as $ name ) { $ realRequest -> server -> set ( $ name , str_replace ( TL_SCRIPT , 'index.php' , $ realRequest -> server -> get ( $ name ) ) ) ; } $ realRequest -> attributes -> replace ( $ masterRequest -> attributes -> all ( ) ) ; $ this -> get ( 'request_stack' ) -> push ( $ realRequest ) ; $ this -> get ( 'contao.framework' ) -> initialize ( ) ; $ this -> get ( 'request_stack' ) -> push ( $ masterRequest ) ; return new InitializeControllerResponse ( '' , 204 ) ; }
7732	public function denormalize ( $ data , $ class , $ format = null , array $ context = array ( ) ) { $ value = $ data ; if ( is_array ( $ data ) ) { if ( ! isset ( $ data [ '@value' ] ) || ! isset ( $ data [ '@type' ] ) ) { throw new RuntimeException ( "Cannot denormalize the data as it isn't a valid JSON-LD typed value: " . var_export ( $ data , true ) ) ; } if ( self :: XSD_DATETIME_IRI !== $ data [ '@type' ] ) { throw new RuntimeException ( "Cannot denormalize the data as it isn't a XSD dateTime value: " . var_export ( $ data , true ) ) ; } $ value = $ data [ '@value' ] ; } elseif ( ! is_string ( $ data ) ) { throw new RuntimeException ( "Cannot denormalize the data into a DateTime object: " . var_export ( $ data , true ) ) ; } try { $ date = new \ DateTime ( $ value ) ; return $ date ; } catch ( Exception $ e ) { throw new RuntimeException ( "Cannot denormalize the data as the value is invalid: " . var_export ( $ data , true ) , 0 , $ e ) ; } }
6085	public function retrieveMoodboard ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/moodboards/' . $ id . '' , $ parameters , $ cachePolicy ) ; $ result = new MoodboardResponse ( $ result ) ; return $ result ; }
5893	public function listAudioTemplates ( CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/templates/audio' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new AudioTemplate ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
10231	public function write ( Spreadsheet $ spreadsheet = null ) { if ( ! $ spreadsheet ) { $ spreadsheet = $ this -> getParentWriter ( ) -> getSpreadsheet ( ) ; } $ objWriter = null ; if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' ) ; $ objWriter -> startElement ( 'office:document-meta' ) ; $ objWriter -> writeAttribute ( 'xmlns:office' , 'urn:oasis:names:tc:opendocument:xmlns:office:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:xlink' , 'http://www.w3.org/1999/xlink' ) ; $ objWriter -> writeAttribute ( 'xmlns:dc' , 'http://purl.org/dc/elements/1.1/' ) ; $ objWriter -> writeAttribute ( 'xmlns:meta' , 'urn:oasis:names:tc:opendocument:xmlns:meta:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:ooo' , 'http://openoffice.org/2004/office' ) ; $ objWriter -> writeAttribute ( 'xmlns:grddl' , 'http://www.w3.org/2003/g/data-view#' ) ; $ objWriter -> writeAttribute ( 'office:version' , '1.2' ) ; $ objWriter -> startElement ( 'office:meta' ) ; $ objWriter -> writeElement ( 'meta:initial-creator' , $ spreadsheet -> getProperties ( ) -> getCreator ( ) ) ; $ objWriter -> writeElement ( 'dc:creator' , $ spreadsheet -> getProperties ( ) -> getCreator ( ) ) ; $ objWriter -> writeElement ( 'meta:creation-date' , date ( DATE_W3C , $ spreadsheet -> getProperties ( ) -> getCreated ( ) ) ) ; $ objWriter -> writeElement ( 'dc:date' , date ( DATE_W3C , $ spreadsheet -> getProperties ( ) -> getCreated ( ) ) ) ; $ objWriter -> writeElement ( 'dc:title' , $ spreadsheet -> getProperties ( ) -> getTitle ( ) ) ; $ objWriter -> writeElement ( 'dc:description' , $ spreadsheet -> getProperties ( ) -> getDescription ( ) ) ; $ objWriter -> writeElement ( 'dc:subject' , $ spreadsheet -> getProperties ( ) -> getSubject ( ) ) ; $ keywords = explode ( ' ' , $ spreadsheet -> getProperties ( ) -> getKeywords ( ) ) ; foreach ( $ keywords as $ keyword ) { $ objWriter -> writeElement ( 'meta:keyword' , $ keyword ) ; } $ objWriter -> startElement ( 'meta:user-defined' ) ; $ objWriter -> writeAttribute ( 'meta:name' , 'Company' ) ; $ objWriter -> writeRaw ( $ spreadsheet -> getProperties ( ) -> getCompany ( ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'meta:user-defined' ) ; $ objWriter -> writeAttribute ( 'meta:name' , 'category' ) ; $ objWriter -> writeRaw ( $ spreadsheet -> getProperties ( ) -> getCategory ( ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
5811	public function updateCMSFields ( FieldList $ fields ) { $ fields -> removeByName ( 'FusionTags' ) ; $ types = array ( ) ; foreach ( singleton ( 'FusionService' ) -> getFusionTagTypes ( ) as $ type => $ field ) { $ types [ $ type ] = $ type ; } $ types = array_intersect ( $ this -> owner -> many_many ( ) , $ types ) ; if ( empty ( $ types ) ) { $ fields -> addFieldToTab ( 'Root.Tagging' , ListboxField :: create ( 'FusionTags' , 'Tags' , FusionTag :: get ( ) -> map ( ) -> toArray ( ) ) -> setMultiple ( true ) ) ; } $ this -> owner -> extend ( 'updateTaggingExtensionCMSFields' , $ fields ) ; }
2849	public function setSqlProfilerStatus ( $ isEnabled ) { $ filePath = $ this -> getLocalXmlFilePath ( ) ; $ xml = $ this -> loadXmlFile ( $ filePath ) ; if ( $ xml === false ) { throw new Exception ( "Unable to parse local.xml configuration file: {$filePath}" ) ; } $ connectionNode = $ xml -> global -> resources -> default_setup -> connection ; if ( $ isEnabled ) { $ connectionNode -> profiler = '1' ; } else { unset ( $ connectionNode -> profiler ) ; } if ( $ this -> saveXml ( $ xml , $ filePath ) === false ) { throw new Exception ( "Unable to save {$filePath}: check if web server user has write permission" ) ; } }
2597	public function isNextTokenAny ( array $ tokens ) { return null !== $ this -> lookahead && in_array ( $ this -> lookahead [ 'type' ] , $ tokens , true ) ; }
4020	protected function validateWidget ( & $ arrField , $ strRow , $ strKey , & $ varInput ) { $ varValue = $ varInput [ $ strRow ] [ $ strKey ] ; $ objWidget = $ this -> initializeWidget ( $ arrField , $ strRow , $ strKey , $ varValue ) ; if ( ! is_object ( $ objWidget ) ) { return false ; } if ( ( $ arrField [ 'inputType' ] == 'checkbox' ) && isset ( $ varInput [ $ strRow ] [ $ strKey ] ) ) { $ _POST [ $ objWidget -> name ] = $ varValue ; } $ objWidget -> validate ( ) ; $ varValue = $ objWidget -> value ; $ rgxp = $ arrField [ 'eval' ] [ 'rgxp' ] ; if ( ( $ rgxp == 'date' || $ rgxp == 'time' || $ rgxp == 'datim' ) && $ varValue != '' ) { $ objDate = new Date ( $ varValue , $ GLOBALS [ 'TL_CONFIG' ] [ $ rgxp . 'Format' ] ) ; $ varValue = $ objDate -> tstamp ; } $ varValue = $ this -> handleSaveCallback ( $ arrField , $ objWidget , $ varValue ) ; $ varInput [ $ strRow ] [ $ strKey ] = $ varValue ; if ( $ objWidget -> hasErrors ( ) ) { return false ; } return true ; }
6601	protected function buildUrl ( $ url , $ params = [ ] ) { if ( $ this -> useOauth ) { $ params [ 'access_token' ] = $ this -> getAccessToken ( ) ; } $ params = http_build_query ( $ params ) ; return $ this -> baseUrl . $ url . '?' . $ params ; }
10514	private function updateObserverState ( \ StdClass $ observer ) { $ this -> event -> function = $ observer -> function ; $ observerObject = $ observer -> observer ; $ observerObject -> update ( $ this ) ; }
9226	public function get ( $ path , $ data = array ( ) , $ headers = array ( ) ) { return $ this -> postprocessResponse ( parent :: get ( $ path , $ this -> preprocessData ( $ data ) , $ headers ) ) ; }
7245	private function buildSaleItemRemaining ( Common \ SaleItemInterface $ saleItem , Shipment \ RemainingList $ list , array $ shipments ) { if ( ! ( $ saleItem -> isCompound ( ) && ! $ saleItem -> hasPrivateChildren ( ) ) ) { $ quantity = $ saleItem -> getTotalQuantity ( ) ; foreach ( $ shipments as $ shipment ) { foreach ( $ shipment -> getItems ( ) as $ item ) { if ( $ item -> getSaleItem ( ) === $ saleItem ) { $ quantity += $ shipment -> isReturn ( ) ? $ item -> getQuantity ( ) : - $ item -> getQuantity ( ) ; continue 2 ; } } } if ( 0 < $ quantity ) { $ entry = new Shipment \ RemainingEntry ( ) ; $ entry -> setSaleItem ( $ saleItem ) -> setQuantity ( $ quantity ) ; $ list -> addEntry ( $ entry ) ; } } foreach ( $ saleItem -> getChildren ( ) as $ child ) { $ this -> buildSaleItemRemaining ( $ child , $ list , $ shipments ) ; } }
2696	public function afterGetType ( Config $ config , $ result ) { if ( ! ( $ config instanceof \ Fastly \ Cdn \ Model \ Config ) ) { if ( $ result == \ Fastly \ Cdn \ Model \ Config :: FASTLY ) { return Config :: VARNISH ; } } return $ result ; }
10968	public static function getPath ( ) { $ uri = isset ( $ _SERVER [ 'REQUEST_URI' ] ) ? $ _SERVER [ 'REQUEST_URI' ] : '' ; if ( strpos ( $ uri , '?' ) > 0 ) { $ uri = substr ( $ uri , 0 , strpos ( $ uri , '?' ) ) ; } $ uri = preg_replace ( "/^\\/(.*)$/" , "$1" , $ uri ) ; $ uri = preg_replace ( "/^(.*)\\/$/" , "$1" , $ uri ) ; return $ uri ; }
11697	public function __ ( $ key , array $ parameters = [ ] , $ locale = null , $ default = null , $ parseBBCode = true ) { return $ this -> translate ( $ key , $ parameters , $ locale , $ default , $ parseBBCode ) ; }
11787	public static function getAgeByDate ( string $ sBirthday ) : int { list ( $ iYear , $ iMonth , $ iDay ) = preg_split ( '/[-.]/' , $ sBirthday ) ; $ aToday = array ( ) ; $ aToday [ 'mois' ] = date ( 'n' ) ; $ aToday [ 'jour' ] = date ( 'j' ) ; $ aToday [ 'annee' ] = date ( 'Y' ) ; $ iYears = $ aToday [ 'annee' ] - $ iYear ; if ( $ aToday [ 'mois' ] <= $ iMonth ) { if ( $ iMonth == $ aToday [ 'mois' ] ) { if ( $ iDay > $ aToday [ 'jour' ] ) { $ iYears -- ; } } else { $ iYears -- ; } } return $ iYears ; }
11104	protected function registerClientScript ( ) { $ view = $ this -> getView ( ) ; DateTimePickerAssets :: register ( $ view ) ; $ id = $ this -> options [ 'id' ] ; $ options = Json :: encode ( $ this -> clientOptions ) ; $ view -> registerJs ( "jQuery('#$id').datetimepicker($options);" ) ; }
9726	public function logWrite ( IWriter $ writer , $ path , $ callStartTime ) { $ callEndTime = microtime ( true ) ; $ callTime = $ callEndTime - $ callStartTime ; $ reflection = new ReflectionClass ( $ writer ) ; $ format = $ reflection -> getShortName ( ) ; $ message = "Write {$format} format to <code>{$path}</code> in " . sprintf ( '%.4f' , $ callTime ) . ' seconds' ; $ this -> log ( $ message ) ; }
7522	function parse_style ( ) { if ( $ this -> parse_attributes ( ) && ( $ this -> token === self :: TOK_TAG_CLOSE ) && ( $ start = $ this -> pos ) && ( $ this -> next_pos ( '</style>' , false ) === self :: TOK_UNKNOWN ) ) { $ len = $ this -> pos - 1 - $ start ; $ this -> status [ 'text' ] = ( ( $ len > 0 ) ? substr ( $ this -> doc , $ start + 1 , $ len ) : '' ) ; $ this -> pos += 7 ; $ this -> status [ 'last_pos' ] = $ this -> pos ; return true ; } else { $ this -> addError ( 'No end for style tag found' ) ; return false ; } }
5912	public function updateUser ( $ id , User $ user , $ password = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'user' => $ user , 'password' => $ password ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/accounts/users/' . $ id . '' , $ parameters ) ; $ result = new User ( $ result ) ; return $ result ; }
7614	public function actionUpdate ( ) { $ model = $ this -> findModel ( ) ; $ model -> setScenario ( 'profile' ) ; if ( $ model -> load ( $ _POST ) && $ model -> save ( ) ) { return $ this -> redirect ( [ 'view' , 'id' => $ model -> id ] ) ; } else { return $ this -> render ( 'update' , [ 'model' => $ model , ] ) ; } }
4791	function delete ( ) { if ( $ this -> notORM -> freeze ) { return false ; } $ where = $ this -> whereString ( ) ; if ( empty ( $ where ) ) { throw new Exception ( 'sorry, you can not delete the whole table --dogstar' ) ; } $ return = $ this -> query ( "DELETE" . $ this -> topString ( $ this -> limit ) . " FROM $this->table" . $ where , $ this -> parameters ) ; if ( ! $ return ) { return false ; } return $ return -> rowCount ( ) ; }
12772	public function register ( $ email , $ hashedPassword = null , & $ user = null , $ valid = false ) { $ result = new EmailStatus ( 0 ) ; if ( ! dbQuery ( $ this -> dbTable ) -> cond ( $ this -> dbEmailField , $ email ) -> first ( $ user ) ) { if ( ! isset ( $ user ) ) { $ user = new $ this -> dbTable ( false ) ; } $ user [ $ this -> dbEmailField ] = $ email ; $ user [ $ this -> dbHashEmailField ] = $ this -> hash ( $ email ) ; if ( isset ( $ hashedPassword ) ) { $ user [ $ this -> dbHashPasswordField ] = $ hashedPassword ; } else { $ user [ $ this -> dbHashPasswordField ] = $ this -> generatePassword ( ) ; } if ( ! $ valid ) { $ user [ $ this -> dbConfirmField ] = $ this -> hash ( $ email . time ( ) ) ; } else { $ user [ $ this -> dbConfirmField ] = 1 ; } $ activeField = $ this -> dbActiveField ; $ createdField = $ this -> dbCreatedField ; $ user -> $ activeField = 1 ; $ user -> $ createdField = date ( 'Y-m-d H:i:s' ) ; $ user -> save ( ) ; $ this -> authorize ( $ user ) ; $ result = new EmailStatus ( EmailStatus :: SUCCESS_EMAIL_REGISTERED ) ; } else { $ result = new EmailStatus ( EmailStatus :: ERROR_EMAIL_REGISTER_FOUND ) ; } if ( is_callable ( $ this -> registerHandler ) ) { if ( ! call_user_func_array ( $ this -> registerHandler , array ( & $ user , & $ result ) ) ) { $ result = new EmailStatus ( EmailStatus :: ERROR_EMAIL_REGISTER_HANDLER ) ; } } return $ result ; }
9849	public function createSignedResponse ( int $ status , string $ body , SigningSecretKey $ key , array $ headers = [ ] , string $ version = '1.1' ) : ResponseInterface { $ signature = \ ParagonIE_Sodium_Compat :: crypto_sign_detached ( $ body , $ key -> getString ( true ) ) ; if ( isset ( $ headers [ Sapient :: HEADER_SIGNATURE_NAME ] ) ) { $ headers [ Sapient :: HEADER_SIGNATURE_NAME ] [ ] = Base64UrlSafe :: encode ( $ signature ) ; } else { $ headers [ Sapient :: HEADER_SIGNATURE_NAME ] = Base64UrlSafe :: encode ( $ signature ) ; } return new Response ( $ status , new Headers ( $ headers ) , $ this -> stringToStream ( $ body ) ) ; }
11712	protected function performAjaxValidation ( $ models ) { if ( \ Yii :: $ app -> request -> isAjax ) { if ( is_array ( $ models ) ) { $ result = [ ] ; foreach ( $ models as $ model ) { if ( $ model -> load ( \ Yii :: $ app -> request -> post ( ) ) ) { \ Yii :: $ app -> response -> format = Response :: FORMAT_JSON ; $ result = array_merge ( $ result , ActiveForm :: validate ( $ model ) ) ; } } echo json_encode ( $ result ) ; \ Yii :: $ app -> end ( ) ; } else { if ( $ models -> load ( \ Yii :: $ app -> request -> post ( ) ) ) { \ Yii :: $ app -> response -> format = Response :: FORMAT_JSON ; echo json_encode ( ActiveForm :: validate ( $ models ) ) ; \ Yii :: $ app -> end ( ) ; } } } }
6835	protected function preventForbiddenChange ( Model \ InvoiceLineInterface $ line ) { if ( $ this -> persistenceHelper -> isChanged ( $ line , 'type' ) ) { list ( $ old , $ new ) = $ this -> persistenceHelper -> getChangeSet ( $ line , 'type' ) ; if ( $ old !== $ new ) { throw new Exception \ RuntimeException ( "Changing the invoice line's type is not supported." ) ; } } }
6526	public static function resolveId ( SchemaId $ id ) : string { $ curieMajor = $ id -> getCurieMajor ( ) ; if ( isset ( self :: $ curies [ $ curieMajor ] ) ) { return self :: $ classes [ self :: $ curies [ $ curieMajor ] ] ; } $ curie = $ id -> getCurie ( ) -> toString ( ) ; if ( isset ( self :: $ curies [ $ curie ] ) ) { return self :: $ classes [ self :: $ curies [ $ curie ] ] ; } throw new NoMessageForSchemaId ( $ id ) ; }
9378	protected function files ( $ path ) { $ directory = new \ RecursiveDirectoryIterator ( $ path ) ; $ iterator = new \ RecursiveIteratorIterator ( $ directory ) ; $ regex = new \ RegexIterator ( $ iterator , '/^.+\.php$/i' , 1 ) ; return ( array ) array_keys ( iterator_to_array ( $ regex ) ) ; }
116	public function executeLocal ( $ command , $ path , $ cwd = null , $ verbose = false ) { return $ this -> executeWithAuthRetry ( $ command , $ cwd , '' , $ path , $ verbose ) ; }
8745	protected function resetListener ( ) { $ this -> currentKey = null ; $ this -> escapePressedAt = null ; $ this -> charSequenceEnabled = false ; $ this -> isListening = true ; return $ this ; }
628	public function bindValue ( $ name , $ value , $ dataType = null ) { if ( $ dataType === null ) { $ dataType = $ this -> db -> getSchema ( ) -> getPdoType ( $ value ) ; } $ this -> _pendingParams [ $ name ] = [ $ value , $ dataType ] ; $ this -> params [ $ name ] = $ value ; return $ this ; }
5249	public function save ( $ child ) { $ children = ! is_array ( $ child ) ? [ $ child ] : $ child ; foreach ( $ children as $ child ) { $ child -> setParent ( $ this -> parent ) ; $ child -> save ( ) ; } }
4577	public function getXml ( $ id , Parameters $ parameters = null ) { if ( null !== $ id ) { $ resource = str_replace ( '{id}' , $ id , static :: RESOURCE_OBJECT_XML ) ; } else { $ key = $ parameters -> getKey ( ) ; $ tenantId = $ parameters -> getTenantId ( ) ; switch ( true ) { case null !== $ key && null !== $ tenantId : $ resource = str_replace ( [ '{key}' , '{tenant-id}' ] , [ $ key , $ tenantId ] , static :: RESOURCE_OBJECT_XML_BY_KEY_AND_TENANT_ID ) ; break ; case null !== $ key : $ resource = str_replace ( '{key}' , $ key , static :: RESOURCE_OBJECT_XML_BY_KEY ) ; break ; default : throw new LogicException ( '"Key" and/or "TenantId" parameters are not defined.' ) ; } } $ options = [ 'headers' => [ 'Accept' => 'application/json' ] ] ; $ object = $ this -> execute ( 'GET' , $ resource , $ options ) ; $ model = new Xml ; $ model -> setId ( $ object -> id ) -> setXml ( new SimpleXMLElement ( $ object -> bpmn20Xml ) ) ; return $ model ; }
12120	public function onViewCreate ( ContentfulViewEvent $ e ) { $ viewMeta = $ e -> getView ( ) -> cfMeta ; $ updated = $ viewMeta [ 'updatedAt' ] ; $ this -> itemIds [ $ viewMeta [ 'itemId' ] ] = true ; if ( $ this -> lastModifiedContent === null ) { $ this -> lastModifiedContent = $ updated ; } else { if ( $ this -> lastModifiedContent < $ updated ) { $ this -> lastModifiedContent = $ updated ; } } }
2221	public static function findPublishedFromToByPids ( $ intFrom , $ intTo , $ arrPids , $ intLimit = 0 , $ intOffset = 0 , array $ arrOptions = array ( ) ) { if ( empty ( $ arrPids ) || ! \ is_array ( $ arrPids ) ) { return null ; } $ t = static :: $ strTable ; $ arrColumns = array ( "$t.date>=? AND $t.date<=? AND $t.pid IN(" . implode ( ',' , array_map ( '\intval' , $ arrPids ) ) . ")" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.date DESC" ; } $ arrOptions [ 'limit' ] = $ intLimit ; $ arrOptions [ 'offset' ] = $ intOffset ; return static :: findBy ( $ arrColumns , array ( $ intFrom , $ intTo ) , $ arrOptions ) ; }
2089	public static function findPublishedBySourceAndParent ( $ strSource , $ intParent , $ blnDesc = false , $ intLimit = 0 , $ intOffset = 0 , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = array ( "$t.source=? AND $t.parent=?" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ arrColumns [ ] = "$t.published='1'" ; } $ arrOptions [ 'limit' ] = $ intLimit ; $ arrOptions [ 'offset' ] = $ intOffset ; if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = ( $ blnDesc ? "$t.date DESC" : "$t.date" ) ; } return static :: findBy ( $ arrColumns , array ( $ strSource , ( int ) $ intParent ) , $ arrOptions ) ; }
9256	public function set ( $ id , $ service , $ scope = ContainerInterface :: SCOPE_CONTAINER ) { if ( ! $ this -> booted ) { $ this -> boot ( ) ; } $ this -> container -> set ( $ id , $ service , $ scope ) ; }
8917	public function message ( $ messageId ) { $ params = [ 'query' => [ 'apikey' => $ this -> apikey , ] ] ; $ response = $ this -> client -> get ( 'messages/' . $ messageId , $ params ) ; return $ response -> getBody ( ) ; }
4674	public function addCallback ( $ callback , $ data = [ ] , $ region = "main" , $ sort = 0 ) { $ view = new View ( ) ; $ view -> set ( [ "callback" => $ callback ] , $ data , $ sort , "callback" ) ; $ this -> views [ $ region ] [ ] = $ view ; return $ this ; }
937	public static function getKeywords ( ) { static $ keywords = null ; if ( null === $ keywords ) { $ keywords = self :: getTokenKindsForNames ( [ 'T_ABSTRACT' , 'T_ARRAY' , 'T_AS' , 'T_BREAK' , 'T_CALLABLE' , 'T_CASE' , 'T_CATCH' , 'T_CLASS' , 'T_CLONE' , 'T_CONST' , 'T_CONTINUE' , 'T_DECLARE' , 'T_DEFAULT' , 'T_DO' , 'T_ECHO' , 'T_ELSE' , 'T_ELSEIF' , 'T_EMPTY' , 'T_ENDDECLARE' , 'T_ENDFOR' , 'T_ENDFOREACH' , 'T_ENDIF' , 'T_ENDSWITCH' , 'T_ENDWHILE' , 'T_EVAL' , 'T_EXIT' , 'T_EXTENDS' , 'T_FINAL' , 'T_FINALLY' , 'T_FOR' , 'T_FOREACH' , 'T_FUNCTION' , 'T_GLOBAL' , 'T_GOTO' , 'T_HALT_COMPILER' , 'T_IF' , 'T_IMPLEMENTS' , 'T_INCLUDE' , 'T_INCLUDE_ONCE' , 'T_INSTANCEOF' , 'T_INSTEADOF' , 'T_INTERFACE' , 'T_ISSET' , 'T_LIST' , 'T_LOGICAL_AND' , 'T_LOGICAL_OR' , 'T_LOGICAL_XOR' , 'T_NAMESPACE' , 'T_NEW' , 'T_PRINT' , 'T_PRIVATE' , 'T_PROTECTED' , 'T_PUBLIC' , 'T_REQUIRE' , 'T_REQUIRE_ONCE' , 'T_RETURN' , 'T_STATIC' , 'T_SWITCH' , 'T_THROW' , 'T_TRAIT' , 'T_TRY' , 'T_UNSET' , 'T_USE' , 'T_VAR' , 'T_WHILE' , 'T_YIELD' , 'T_YIELD_FROM' , ] ) + [ CT :: T_ARRAY_TYPEHINT => CT :: T_ARRAY_TYPEHINT , CT :: T_CLASS_CONSTANT => CT :: T_CLASS_CONSTANT , CT :: T_CONST_IMPORT => CT :: T_CONST_IMPORT , CT :: T_FUNCTION_IMPORT => CT :: T_FUNCTION_IMPORT , CT :: T_NAMESPACE_OPERATOR => CT :: T_NAMESPACE_OPERATOR , CT :: T_USE_TRAIT => CT :: T_USE_TRAIT , CT :: T_USE_LAMBDA => CT :: T_USE_LAMBDA , ] ; } return $ keywords ; }
3073	public function process ( ) { $ this -> validate ( ) ; $ ref = $ this -> getRequestParameter ( 'ref' ) ? : null ; $ scope = $ this -> getRequestParameter ( 'scope' ) ; $ start = ( $ this -> getRequestParameter ( 'start' ) !== false ) ; try { $ serviceContext = $ this -> getServiceContext ( ) ; $ this -> saveToolStates ( ) ; if ( ! $ this -> getRunnerService ( ) -> isTerminated ( $ serviceContext ) ) { $ this -> endItemTimer ( $ this -> getTime ( ) ) ; $ this -> saveItemState ( ) ; } $ this -> initServiceContext ( ) ; $ this -> saveItemResponses ( ) ; if ( $ this -> getRequestParameter ( 'offline' ) === true ) { $ this -> setOffline ( ) ; } $ result = $ this -> getRunnerService ( ) -> timeout ( $ serviceContext , $ scope , $ ref ) ; $ response = [ 'success' => $ result , ] ; if ( $ result ) { $ response [ 'testContext' ] = $ this -> getRunnerService ( ) -> getTestContext ( $ serviceContext ) ; if ( $ serviceContext -> containsAdaptive ( ) ) { $ response [ 'testMap' ] = $ this -> getRunnerService ( ) -> getTestMap ( $ serviceContext , true ) ; } } if ( $ start == true ) { $ this -> getRunnerService ( ) -> startTimer ( $ serviceContext , $ this -> getTime ( ) ) ; } } catch ( Exception $ e ) { $ response = $ this -> getErrorResponse ( $ e ) ; } return $ response ; }
12572	public function previewImage ( $ message , $ to , $ by = self :: PREVIEW_BY_OPENID ) { return $ this -> preview ( self :: MSG_TYPE_IMAGE , $ message , $ to , $ by ) ; }
8340	public static function set ( string $ fileName , array $ content ) { try { $ json = Yaml :: dump ( $ content , 2 ) ; if ( file_put_contents ( $ fileName , $ json ) === false ) { throw new FileNotWritable ( 'can\'t write to "' . $ fileName . '"' ) ; } } catch ( DumpException $ e ) { throw new BadUse ( 'Config::set() content parameter can\'t be dump to YAML' ) ; } self :: $ files [ $ fileName ] = $ content ; }
4121	public function getProxy ( $ className , $ identifier ) { $ fqn = ClassUtils :: generateProxyClassName ( $ className , $ this -> proxyNamespace ) ; if ( ! class_exists ( $ fqn , false ) ) { $ fileName = $ this -> getProxyFileName ( $ className ) ; if ( $ this -> autoGenerate ) { $ this -> generateProxyClass ( $ this -> dm -> getClassMetadata ( $ className ) , $ fileName , self :: $ proxyClassTemplate ) ; } require $ fileName ; } if ( ! $ this -> dm -> getMetadataFactory ( ) -> hasMetadataFor ( $ fqn ) ) { $ this -> dm -> getMetadataFactory ( ) -> setMetadataFor ( $ fqn , $ this -> dm -> getClassMetadata ( $ className ) ) ; } return new $ fqn ( $ this -> dm , $ identifier ) ; }
7999	public function identifyTargetName ( $ username , $ nt_domain , ServerChallenge $ server_challenge ) { $ target_name = $ nt_domain ? : $ server_challenge -> getTargetName ( ) ; if ( false !== strpos ( $ username , static :: USER_PRINCIPAL_NAME_SEPARATOR ) ) { $ target_name = '' ; } return $ target_name ; }
10219	private static function nbrConversionFormat ( $ xVal , $ places ) { if ( $ places !== null ) { if ( is_numeric ( $ places ) ) { $ places = ( int ) $ places ; } else { return Functions :: VALUE ( ) ; } if ( $ places < 0 ) { return Functions :: NAN ( ) ; } if ( strlen ( $ xVal ) <= $ places ) { return substr ( str_pad ( $ xVal , $ places , '0' , STR_PAD_LEFT ) , - 10 ) ; } return Functions :: NAN ( ) ; } return substr ( $ xVal , - 10 ) ; }
11262	public static function main ( $ argv , ContainerInterface $ container = null ) { $ output = self :: cyanLine ( $ argv ) ; $ app = new Application ( '' ) ; $ app -> add ( new MigrateMakeCommand ( ) ) ; $ app -> add ( new MigrateUpCommand ( $ container ) ) ; $ app -> add ( new MigrateDownCommand ( ) ) ; $ app -> add ( new MigrateResetCommand ( ) ) ; $ app -> add ( new MigrateStatusCommand ( ) ) ; $ app -> add ( new MigrateRefreshCommand ( ) ) ; $ app -> add ( new MigrateFreshCommand ( $ container ) ) ; $ app -> add ( new MigrateDropCommand ( ) ) ; $ app -> add ( new SeedRunCommand ( $ container ) ) ; $ app -> add ( new SeedMakeCommand ( ) ) ; $ app -> add ( new BinMakeCommand ( ) ) ; $ app -> run ( null , $ output ) ; }
739	protected function saveAssignments ( ) { $ assignmentData = [ ] ; foreach ( $ this -> assignments as $ userId => $ assignments ) { foreach ( $ assignments as $ name => $ assignment ) { $ assignmentData [ $ userId ] [ ] = $ assignment -> roleName ; } } $ this -> saveToFile ( $ assignmentData , $ this -> assignmentFile ) ; }
9710	private function writeWindow1 ( ) { $ record = 0x003D ; $ length = 0x0012 ; $ xWn = 0x0000 ; $ yWn = 0x0000 ; $ dxWn = 0x25BC ; $ dyWn = 0x1572 ; $ grbit = 0x0038 ; $ ctabsel = 1 ; $ wTabRatio = 0x0258 ; $ itabFirst = 0 ; $ itabCur = $ this -> spreadsheet -> getActiveSheetIndex ( ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vvvvvvvvv' , $ xWn , $ yWn , $ dxWn , $ dyWn , $ grbit , $ itabCur , $ itabFirst , $ ctabsel , $ wTabRatio ) ; $ this -> append ( $ header . $ data ) ; }
5410	public function close ( ) { if ( ! $ this -> is_open ) { return false ; } $ this -> is_open = false ; return fclose ( $ this -> handle ) ; }
7640	public static function isValidContainerName ( $ containerName = '' ) { if ( $ containerName == '$root' ) { return true ; } if ( preg_match ( "/^[a-z0-9][a-z0-9-]*$/" , $ containerName ) === 0 ) { return false ; } if ( strpos ( $ containerName , '--' ) !== false ) { return false ; } if ( strtolower ( $ containerName ) != $ containerName ) { return false ; } if ( strlen ( $ containerName ) < 3 || strlen ( $ containerName ) > 63 ) { return false ; } if ( substr ( $ containerName , - 1 ) == '-' ) { return false ; } return true ; }
3472	public function extract ( string $ namespace ) : Config { $ extracted = $ this -> get ( $ namespace ) ; if ( ! is_array ( $ extracted ) ) { throw ConfigException :: forExtractionFailure ( $ namespace ) ; } return new self ( $ extracted ) ; }
194	public function sendFile ( $ filePath , $ attachmentName = null , $ options = [ ] ) { if ( ! isset ( $ options [ 'mimeType' ] ) ) { $ options [ 'mimeType' ] = FileHelper :: getMimeTypeByExtension ( $ filePath ) ; } if ( $ attachmentName === null ) { $ attachmentName = basename ( $ filePath ) ; } $ handle = fopen ( $ filePath , 'rb' ) ; $ this -> sendStreamAsFile ( $ handle , $ attachmentName , $ options ) ; return $ this ; }
8196	public function collectDir ( $ dir , $ ext = '.twig' ) { $ iterator = new RegexIterator ( new RecursiveIteratorIterator ( new RecursiveDirectoryIterator ( $ dir ) , RecursiveIteratorIterator :: LEAVES_ONLY ) , '{' . preg_quote ( $ ext ) . '$}' ) ; return $ this -> collect ( new Twig_Util_TemplateDirIterator ( $ iterator ) ) ; }
3104	public function save ( ) { $ storage = $ this -> getStorage ( ) ; if ( $ storage ) { $ success = $ storage -> set ( $ this -> userId , $ this -> getStorageKey ( ) , json_encode ( $ this -> state ) ) ; } else { $ success = false ; } return $ success ; }
10724	public function getNumRows ( ) { $ builtSql = SqlBuilder :: buildRowCountSql ( $ this ) ; if ( is_array ( $ builtSql ) ) { $ preparedSth = $ this -> connect ( ) -> prepare ( $ builtSql [ 0 ] ) ; $ boundSth = StatementBuilder :: bindValues ( $ preparedSth , $ builtSql [ 1 ] ) ; $ boundSth -> execute ( ) ; } else { $ boundSth = $ this -> connect ( ) -> query ( $ builtSql ) ; } $ result = $ boundSth -> fetch ( PDO :: FETCH_ASSOC ) ; return ( int ) $ result [ 'total_count' ] ; }
10884	public function report ( ErrorStreamReport $ report ) { $ report -> tags = $ this -> tags ; $ report -> context = $ this -> context ; return $ this -> makeRequest ( $ report ) ; }
3417	protected function getValueFromLanguageField ( $ field ) { $ key = $ field . '_' . $ this -> getCurrentLanguage ( ) ; return isset ( $ this -> fields [ $ key ] ) ? $ this -> fields [ $ key ] : null ; }
12748	public function setPattern ( $ pattern ) { $ this -> setTag ( 'pattern' , $ pattern ) ; if ( $ this -> getValidator ( ) ) { $ this -> getValidator ( ) -> setOption ( 'pattern' , $ pattern ) ; } }
4022	protected function getHelpForWidget ( $ widget ) { if ( $ GLOBALS [ 'TL_CONFIG' ] [ 'showHelp' ] && $ widget -> description ) { return sprintf ( '<p class="tl_help tl_tip%s">%s</p>' , $ widget -> tl_class , $ widget -> description ) ; } return '' ; }
8291	protected function logout ( ) { $ oldUser = $ this -> user ; $ this -> user = new User ( ) ; $ this -> session -> invalidate ( ) ; $ this -> triggerEvent ( "afterLogout" , [ $ oldUser ] ) ; $ this -> redirectToPage ( $ this -> config [ "afterLogout" ] ) ; }
790	public function getErrorSummary ( $ showAllErrors ) { $ lines = [ ] ; $ errors = $ showAllErrors ? $ this -> getErrors ( ) : $ this -> getFirstErrors ( ) ; foreach ( $ errors as $ es ) { $ lines = array_merge ( ( array ) $ es , $ lines ) ; } return $ lines ; }
12350	public function validate ( string $ api_session = null ) { $ this -> details = false ; if ( empty ( $ api_session ) === false && is_string ( $ api_session ) === true ) { $ session = Model \ Session :: with ( 'user' ) -> where ( 'code' , $ api_session ) -> first ( ) ; if ( $ session !== null ) { if ( strtotime ( $ session -> updated_at ) < strtotime ( "-1 hour" ) || $ session -> user === null ) { $ this -> invalidate ( $ api_session ) ; } else { $ session -> updated_at = date ( 'Y-m-d H:i:s' ) ; $ session -> save ( ) ; $ this -> details = $ session -> user ; } } else { $ _SESSION [ 'api_session' ] = null ; } } }
4076	protected function getMetaModelName ( $ nameOrId ) { return isset ( $ this -> tableMap [ $ nameOrId ] ) ? $ this -> tableMap [ $ nameOrId ] : $ nameOrId ; }
7412	protected function customChmod ( string $ target , $ mode = 0666 ) { if ( false === @ chmod ( $ target , $ mode & ~ umask ( ) ) ) { throw new FileException ( sprintf ( 'Unable to change mode of the "%s"' , $ target ) ) ; } }
10943	public function encode ( $ rawString ) { $ bytes = unpack ( 'C*' , $ rawString ) ; $ byteCount = count ( $ bytes ) ; $ encodedString = '' ; $ byte = array_shift ( $ bytes ) ; $ bitsRead = 0 ; $ chars = $ this -> chars ; $ bitsPerCharacter = $ this -> bitsPerCharacter ; $ rightPadFinalBits = $ this -> rightPadFinalBits ; $ padFinalGroup = $ this -> padFinalGroup ; $ padCharacter = $ this -> padCharacter ; for ( $ c = 0 ; $ c < $ byteCount * 8 / $ bitsPerCharacter ; ++ $ c ) { if ( $ bitsRead + $ bitsPerCharacter > 8 ) { $ oldBitCount = 8 - $ bitsRead ; $ oldBits = $ byte ^ ( $ byte >> $ oldBitCount << $ oldBitCount ) ; $ newBitCount = $ bitsPerCharacter - $ oldBitCount ; if ( ! $ bytes ) { if ( $ rightPadFinalBits ) { $ oldBits <<= $ newBitCount ; } $ encodedString .= $ chars [ $ oldBits ] ; if ( $ padFinalGroup ) { $ lcmMap = array ( 1 => 1 , 2 => 1 , 3 => 3 , 4 => 1 , 5 => 5 , 6 => 3 , 7 => 7 , 8 => 1 ) ; $ bytesPerGroup = $ lcmMap [ $ bitsPerCharacter ] ; $ pads = $ bytesPerGroup * 8 / $ bitsPerCharacter - ceil ( ( strlen ( $ rawString ) % $ bytesPerGroup ) * 8 / $ bitsPerCharacter ) ; $ encodedString .= str_repeat ( $ padCharacter [ 0 ] , $ pads ) ; } break ; } $ byte = array_shift ( $ bytes ) ; $ bitsRead = 0 ; } else { $ oldBitCount = 0 ; $ newBitCount = $ bitsPerCharacter ; } $ bits = $ byte >> 8 - ( $ bitsRead + ( $ newBitCount ) ) ; $ bits ^= $ bits >> $ newBitCount << $ newBitCount ; $ bitsRead += $ newBitCount ; if ( $ oldBitCount ) { $ bits = ( $ oldBits << $ newBitCount ) | $ bits ; } $ encodedString .= $ chars [ $ bits ] ; } return $ encodedString ; }
6763	public function append ( Collection $ collection ) { if ( ! $ collection ) return $ this ; $ this -> models = array_merge ( $ this -> array ( ) , $ collection -> array ( ) ) ; return $ this ; }
7932	public function load ( $ data ) { list ( $ data ) = $ this -> fireEvent ( 'load' , [ $ data ] ) ; if ( is_array ( $ data ) ) { $ this -> loadFromArray ( $ data ) ; } else { $ this -> loadFromCollection ( $ data ) ; } return $ this ; }
12640	public function init ( $ adapter , $ client = null ) { $ this -> adapter = $ adapter ; if ( ! $ client ) { $ client = new \ PeterColes \ Cluster \ HttpClients \ GuzzleHttp ; } $ client -> initClient ( $ this -> adapter -> getHeaders ( ) ) ; $ this -> adapter -> setClient ( $ client ) ; }
10677	private function _txtSplit ( $ txt ) { $ skp = 1 ; $ rv = [ ] ; $ rvx = 0 ; $ acc = '' ; $ length = mb_strlen ( $ txt , 'UTF-8' ) ; for ( $ i = 0 ; $ i < $ length ; $ i ++ ) { if ( mb_substr ( $ txt , $ i , 1 , 'UTF-8' ) === ' ' ) { if ( $ skp ) { continue ; } $ skp = 1 ; $ rv [ $ rvx ++ ] = $ acc ; $ acc = '' ; continue ; } $ skp = 0 ; $ acc .= mb_substr ( $ txt , $ i , 1 , 'UTF-8' ) ; } if ( ! $ skp ) { $ rv [ $ rvx ] = $ acc ; } return $ rv ; }
5137	public static function handleError ( $ code , $ message , $ filename = '' , $ line = 0 ) { throw new \ ErrorException ( $ message , $ code , 0 , $ filename , $ line ) ; }
7577	protected function setFileFieldValue ( $ value ) { if ( version_compare ( PHP_VERSION , '5.5.0' ) >= 0 ) { if ( ! ( $ value instanceof \ CURLFile ) ) { $ value = ltrim ( $ value , "@" ) ; $ value = new \ CURLFile ( $ value ) ; } } else { if ( strpos ( $ value , '@' ) !== 0 ) { $ value = '@' . $ value ; } } return $ value ; }
8406	private function getModelName ( ) { if ( isset ( $ this -> class ) ) { return $ this -> class ; } if ( isset ( $ this -> model ) ) { $ rClass = new \ ReflectionClass ( $ this -> model ) ; return $ rClass -> getShortName ( ) ; } return 'Icon' ; }
2922	protected function ensureFileIsReadable ( ) { if ( ! is_readable ( $ this -> filePath ) || ! is_file ( $ this -> filePath ) ) { throw new UnableReadFileException ( sprintf ( 'Unable to read the file at %s.' , $ this -> filePath ) ) ; } }
10549	public function setApplication ( Application $ app ) { $ this -> setVariable ( 'app' , $ app ) -> setVariable ( 'path_config' , $ app -> pathConfig ) -> setVariable ( 'i18n' , $ app -> i18n ) ; try { $ this -> setVariable ( 'db' , $ app -> db ) ; } catch ( \ Wedeto \ DB \ Exception \ ConfigurationException $ db ) { } return $ this ; }
1220	private function validateSeq ( $ from , array $ types , $ a , $ b ) { $ ta = Utils :: type ( $ a ) ; $ tb = Utils :: type ( $ b ) ; if ( $ ta !== $ tb ) { $ msg = "encountered a type mismatch in sequence: {$ta}, {$tb}" ; $ this -> typeError ( $ from , $ msg ) ; } $ typeMatch = ( $ types && $ types [ 0 ] == 'any' ) || in_array ( $ ta , $ types ) ; if ( ! $ typeMatch ) { $ msg = 'encountered a type error in sequence. The argument must be ' . 'an array of ' . implode ( '|' , $ types ) . ' types. ' . "Found {$ta}, {$tb}." ; $ this -> typeError ( $ from , $ msg ) ; } }
7610	public function signup ( ) { if ( $ this -> validate ( ) ) { $ user = new User ( ) ; $ user -> username = $ this -> username ; $ user -> email = $ this -> email ; $ user -> setPassword ( $ this -> password ) ; $ user -> generateAuthKey ( ) ; if ( $ user -> save ( ) ) { return $ user ; } } return null ; }
7675	function TbsStoreGet ( $ idx , $ caller ) { $ this -> LastReadNotStored = false ; if ( $ idx === $ this -> TbsCurrIdx ) { return $ this -> TBS -> Source ; } elseif ( isset ( $ this -> TbsStoreLst [ $ idx ] ) ) { $ txt = $ this -> TbsStoreLst [ $ idx ] [ 'src' ] ; if ( $ caller === false ) $ this -> TbsStoreLst [ $ idx ] [ 'src' ] = '' ; return $ txt ; } else { $ this -> LastReadNotStored = true ; $ txt = $ this -> FileRead ( $ idx , true ) ; if ( $ this -> LastReadComp > 0 ) { if ( $ caller === false ) { return $ txt ; } else { return $ this -> RaiseError ( "(" . $ caller . ") unable to uncompress '" . $ this -> TbsGetFileName ( $ idx ) . "'." ) ; } } else { return $ txt ; } } }
7862	protected function setPipesOfWorkflow ( $ workflow ) { $ pipes = $ this -> pipelines -> getPipesByPipeline ( $ workflow ) ; $ this -> pipes = array_map ( function ( $ pipe ) { $ chunks = explode ( '\\' , $ pipe ) ; return end ( $ chunks ) ; } , $ pipes ) ; $ this -> geometry -> setPipes ( $ this -> pipes ) ; }
3723	public function addMetaModelNames ( $ metaModelNames ) { $ this -> metaModelNames = array_unique ( array_merge ( $ this -> metaModelNames , $ metaModelNames ) ) ; return $ this ; }
1292	private function buildResult ( array $ data ) : Result { $ token = $ this -> getTokenFromResponse ( $ data ) ; $ done = isset ( $ data [ 'nextSyncUrl' ] ) ; $ items = \ array_map ( function ( array $ item ) : ResourceInterface { return $ this -> builder -> build ( $ item ) ; } , $ data [ 'items' ] ) ; return new Result ( $ items , $ token , $ done ) ; }
312	public function run ( ) { try { $ this -> state = self :: STATE_BEFORE_REQUEST ; $ this -> trigger ( self :: EVENT_BEFORE_REQUEST ) ; $ this -> state = self :: STATE_HANDLING_REQUEST ; $ response = $ this -> handleRequest ( $ this -> getRequest ( ) ) ; $ this -> state = self :: STATE_AFTER_REQUEST ; $ this -> trigger ( self :: EVENT_AFTER_REQUEST ) ; $ this -> state = self :: STATE_SENDING_RESPONSE ; $ response -> send ( ) ; $ this -> state = self :: STATE_END ; return $ response -> exitStatus ; } catch ( ExitException $ e ) { $ this -> end ( $ e -> statusCode , isset ( $ response ) ? $ response : null ) ; return $ e -> statusCode ; } }
7380	public function fetchEscape ( string $ key , \ mysqli $ db , string $ default = '' ) : string { return $ db -> real_escape_string ( $ this -> fetch ( $ key , $ default ) ) ; }
3220	function restoreFile ( $ path , $ rev ) { Path :: checkArgNonRoot ( "path" , $ path ) ; Checker :: argStringNonEmpty ( "rev" , $ rev ) ; $ response = $ this -> doPost ( $ this -> apiHost , $ this -> appendFilePath ( "1/restore" , $ path ) , array ( "rev" => $ rev ) ) ; if ( $ response -> statusCode === 404 ) return null ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; return RequestUtil :: parseResponseJson ( $ response -> body ) ; }
6887	private function httpGet ( $ path , array $ query = array ( ) ) { $ url = new Uri ( $ this -> baseUrl . $ path ) ; foreach ( $ query as $ name => $ value ) { $ url = Uri :: withQueryValue ( $ url , $ name , $ value ) ; } $ request = new Request ( 'GET' , $ url , $ this -> buildHeaders ( ) ) ; try { $ response = $ this -> getHttpClient ( ) -> sendRequest ( $ request ) ; } catch ( \ RuntimeException $ e ) { throw new Exception \ PostcodeException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } if ( $ response -> getStatusCode ( ) != 200 ) { throw $ this -> createErrorException ( $ response ) ; } return $ response ; }
7376	public function fetch ( string $ key , $ default = null ) { $ val = $ this -> bag [ $ key ] ?? $ default ; if ( ! is_array ( $ val ) ) { return trim ( $ val ) ; } else { return $ val ; } }
10098	public function setOutline ( $ visible = true , $ symbols_below = true , $ symbols_right = true , $ auto_style = false ) { $ this -> outlineOn = $ visible ; $ this -> outlineBelow = $ symbols_below ; $ this -> outlineRight = $ symbols_right ; $ this -> outlineStyle = $ auto_style ; if ( $ this -> outlineOn ) { $ this -> outlineOn = 1 ; } }
7730	public function api ( $ url , $ body = null , $ type = self :: TYPE_POST ) { $ body [ 'access_token' ] = $ this -> accessToken ; $ this -> setBody ( $ body ) ; $ headers = [ 'Content-Type: application/json' , ] ; if ( $ type == self :: TYPE_GET ) { $ url .= '?' . http_build_query ( $ body ) ; } $ curl = curl_init ( $ this -> url . $ url ) ; if ( $ type == self :: TYPE_POST ) { curl_setopt ( $ curl , CURLOPT_POST , 1 ) ; curl_setopt ( $ curl , CURLOPT_POSTFIELDS , http_build_query ( $ body ) ) ; } curl_setopt ( $ curl , CURLOPT_HTTPHEADER , $ headers ) ; curl_setopt ( $ curl , CURLOPT_SSL_VERIFYPEER , false ) ; curl_setopt ( $ curl , CURLOPT_RETURNTRANSFER , true ) ; $ response = curl_exec ( $ curl ) ; curl_close ( $ curl ) ; return json_decode ( $ response , true ) ; }
10650	private function getValidator ( $ scope = 'create' ) { $ rules = $ this -> buildValidationRules ( $ scope ) ; $ custom_messages = $ this -> buildMessages ( $ scope ) ; $ validation_values = $ this -> buildValidationValues ( ) ; return Validator :: make ( $ validation_values , $ rules , $ custom_messages ) ; }
2067	public function getPageLayouts ( ) { $ objLayout = $ this -> Database -> execute ( "SELECT l.id, l.name, t.name AS theme FROM tl_layout l LEFT JOIN tl_theme t ON l.pid=t.id ORDER BY t.name, l.name" ) ; if ( $ objLayout -> numRows < 1 ) { return array ( ) ; } $ return = array ( ) ; while ( $ objLayout -> next ( ) ) { $ return [ $ objLayout -> theme ] [ $ objLayout -> id ] = $ objLayout -> name ; } return $ return ; }
3040	public function del ( $ userId , $ callId ) { $ key = $ this -> getCacheKey ( $ userId , $ callId ) ; $ this -> putInCache ( $ key , $ userId , $ callId , null , self :: STATE_PENDING_DELETE ) ; return true ; }
9614	public function authenticate ( TokenInterface $ token ) { $ user = $ this -> userProvider -> loadUserByApiKey ( $ this -> encoder -> encodePassword ( $ token -> getCredentials ( ) ) ) ; if ( ! $ user || ! ( $ user instanceof UserInterface ) ) { throw new AuthenticationException ( 'Bad credentials' ) ; } $ token = new ApiKeyToken ( $ token -> getCredentials ( ) , $ user -> getRoles ( ) ) ; $ token -> setUser ( $ user ) ; return $ token ; }
3032	public function getSessionState ( AssessmentTestSession $ session ) { $ deliveryExecution = $ this -> getDeliveryExecution ( $ session ) ; return $ deliveryExecution -> getState ( ) -> getUri ( ) ; }
8474	public function notice ( $ scope , $ message , $ context = [ ] , $ config = [ ] ) { return $ this -> write ( 'notice' , $ scope , $ message , $ context , $ config ) ; }
4084	public function getParentOf ( $ metaModel ) { $ metaModelName = $ this -> getMetaModelName ( $ metaModel ) ; return isset ( $ this -> childMap [ $ metaModelName ] ) ? $ this -> childMap [ $ metaModelName ] : null ; }
1377	protected function validateIdMember ( $ value , string $ path ) : bool { if ( ! is_string ( $ value ) ) { $ this -> memberNotString ( $ path , 'id' ) ; return false ; } if ( empty ( $ value ) ) { $ this -> memberEmpty ( $ path , 'id' ) ; return false ; } return true ; }
4696	public static function getToken ( $ token_name = self :: TOKEN_NAME ) { if ( empty ( $ _SESSION [ $ token_name ] ) ) { static :: generateToken ( $ token_name ) ; } return $ _SESSION [ $ token_name ] ; }
12676	public function approve ( $ sourceDir , array $ options , $ username ) { $ this -> init ( $ sourceDir , $ options , $ username ) ; $ sourceFilename = sprintf ( '%s/blocks/%s.json' , $ this -> contributorDir , $ options [ 'blockname' ] ) ; $ targetFilename = sprintf ( '%s/blocks/%s.json' , $ this -> productionDir , $ options [ 'blockname' ] ) ; Dispatcher :: dispatch ( BlockEvents :: BLOCK_APPROVING , new BlockApprovingEvent ( $ this -> serializer , $ sourceFilename , $ targetFilename ) ) ; $ blockValues = JsonTools :: jsonDecode ( FilesystemTools :: readFile ( $ sourceFilename ) ) ; $ blockValues [ "history" ] = array ( ) ; FilesystemTools :: writeFile ( $ targetFilename , json_encode ( $ blockValues ) ) ; $ slotDefinitionContribution = $ this -> getSlotDefinition ( $ this -> getContributorDir ( ) ) ; $ this -> saveSlotDefinition ( $ this -> productionDir , $ slotDefinitionContribution ) ; Dispatcher :: dispatch ( BlockEvents :: BLOCK_APPROVED , new BlockApprovedEvent ( $ this -> serializer , $ sourceFilename , $ targetFilename ) ) ; DataLogger :: log ( sprintf ( 'Block "%s" has been approved on the "%s" slot on page "%s" for the "%s_%s" language' , $ options [ "blockname" ] , $ options [ "slot" ] , $ options [ "page" ] , $ options [ "language" ] , $ options [ "country" ] ) ) ; return $ blockValues ; }
11954	public function resetAllPropertiesExcept ( $ properties = array ( ) ) { foreach ( $ this -> obj_to_db_trans as $ obj_prop => $ db_field ) { if ( ! in_array ( $ obj_prop , $ this -> key_properties ) && ! in_array ( $ obj_prop , $ properties ) ) { $ this -> { $ obj_prop } = null ; } } }
8272	public function validateUsersSection ( & $ config ) { if ( ! isset ( $ config [ "users" ] ) ) { return ; } $ this -> assertArray ( $ config , "users" ) ; foreach ( $ config [ "users" ] as $ username => $ userData ) { $ this -> assertUsername ( $ username , $ config ) ; try { $ this -> validateUserData ( $ userData ) ; } catch ( ConfigurationException $ e ) { $ e -> addBeforeMessage ( "Invalid userdata for $username:" ) ; throw $ e ; } $ lowercaseName = strtolower ( $ username ) ; if ( $ username !== $ lowercaseName ) { if ( ! isset ( $ config [ "users" ] [ $ lowercaseName ] ) ) { $ config [ "users" ] [ $ lowercaseName ] = $ userData ; unset ( $ config [ "users" ] [ $ username ] ) ; } else { throw new ConfigurationException ( "User $username is defined multiple times." ) ; } } } }
8576	public function setItemChargeAdjustmentList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ItemChargeAdjustmentList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
424	protected function adjustLabelFor ( $ options ) { if ( ! isset ( $ options [ 'id' ] ) ) { return ; } $ this -> _inputId = $ options [ 'id' ] ; if ( ! isset ( $ this -> labelOptions [ 'for' ] ) ) { $ this -> labelOptions [ 'for' ] = $ options [ 'id' ] ; } }
12885	public function getReverseKeyTranslation ( $ localObject ) { $ key = is_object ( $ localObject ) ? $ localObject -> primaryKey : $ localObject ; if ( $ this -> settings [ 'universalKey' ] ) { return KeyTranslation :: find ( ) -> where ( [ 'registry_id' => $ key ] ) -> one ( ) ; } else { return KeyTranslation :: find ( ) -> where ( [ 'registry_id' => $ key , 'data_interface_id' => $ this -> module -> collectorItem -> interfaceObject -> primaryKey ] ) -> one ( ) ; } }
7279	public function file ( $ name = null ) { return ! $ name ? $ this -> files : ( $ this -> files [ $ name ] ?? null ) ; }
4814	private function createFrom ( $ filepath ) { if ( file_exists ( $ filepath ) ) { $ anyDataSet = XmlUtil :: createXmlDocumentFromFile ( $ filepath ) ; $ this -> collection = array ( ) ; $ rows = $ anyDataSet -> getElementsByTagName ( "row" ) ; foreach ( $ rows as $ row ) { $ sr = new Row ( ) ; $ fields = $ row -> getElementsByTagName ( "field" ) ; foreach ( $ fields as $ field ) { $ attr = $ field -> attributes -> getNamedItem ( "name" ) ; if ( is_null ( $ attr ) ) { throw new \ InvalidArgumentException ( 'Malformed anydataset file ' . basename ( $ filepath ) ) ; } $ sr -> addField ( $ attr -> nodeValue , $ field -> nodeValue ) ; } $ sr -> acceptChanges ( ) ; $ this -> collection [ ] = $ sr ; } $ this -> currentRow = count ( $ this -> collection ) - 1 ; } }
8153	public function removeExtension ( $ name ) { @ trigger_error ( sprintf ( 'The %s method is deprecated since version 1.12 and will be removed in Twig 2.0.' , __METHOD__ ) , E_USER_DEPRECATED ) ; if ( $ this -> extensionInitialized ) { throw new LogicException ( sprintf ( 'Unable to remove extension "%s" as extensions have already been initialized.' , $ name ) ) ; } $ class = ltrim ( $ name , '\\' ) ; if ( ! isset ( $ this -> extensionsByClass [ $ class ] ) && class_exists ( $ class , false ) ) { $ class = new ReflectionClass ( $ class ) ; $ class = $ class -> name ; } if ( isset ( $ this -> extensions [ $ class ] ) ) { if ( $ class !== get_class ( $ this -> extensions [ $ class ] ) ) { @ trigger_error ( sprintf ( 'Referencing the "%s" extension by its name (defined by getName()) is deprecated since 1.26 and will be removed in Twig 2.0. Use the Fully Qualified Extension Class Name instead.' , $ class ) , E_USER_DEPRECATED ) ; } unset ( $ this -> extensions [ $ class ] ) ; } unset ( $ this -> extensions [ $ class ] ) ; $ this -> updateOptionsHash ( ) ; }
10375	protected static function validate ( $ type , $ data , $ admin ) { $ place = ( isset ( $ data [ 'place' ] ) ) ? $ data [ 'place' ] : 'front' ; $ place = $ admin && 'admin' == $ place || ! $ admin && 'front' == $ place ; if ( ! $ place || self :: set_params ( $ type , $ data ) === false ) { return false ; } return true ; }
8311	public function applyDefaults ( $ config , array $ defaults , $ depth = 1 ) { if ( ! is_int ( $ depth ) || $ depth < 0 ) { throw new \ InvalidArgumentException ( "Depth must be non-negative integer." ) ; } if ( ! is_array ( $ config ) ) { return $ defaults ; } if ( $ depth === 0 ) { $ config += $ defaults ; return $ config ; } foreach ( $ defaults as $ key => $ defaultValue ) { if ( ! isset ( $ config [ $ key ] ) ) { $ config [ $ key ] = $ defaultValue ; continue ; } if ( is_array ( $ defaultValue ) ) { if ( is_array ( $ config [ $ key ] ) ) { $ config [ $ key ] = $ this -> applyDefaults ( $ config [ $ key ] , $ defaultValue , $ depth - 1 ) ; } else { throw new ConfigurationException ( "Configuration key " . $ key . " expects an array, a scalar value found." ) ; } } else { if ( is_array ( $ config [ $ key ] ) ) { throw new ConfigurationException ( "Configuration key " . $ key . " expects scalar, an array found." ) ; } } } return $ config ; }
3649	public static function get ( ? string $ key = null ) { self :: init ( ) ; if ( $ key === null ) { return self :: $ utmCookie ; } else { if ( mb_strpos ( $ key , 'utm_' ) !== 0 ) { $ key = 'utm_' . $ key ; } if ( false === array_key_exists ( $ key , self :: $ utmCookie ) ) { throw new UnexpectedValueException ( sprintf ( 'Argument $key has unexpecte value "%s". Utm value with key "%s" does not exists.' , $ key , $ key ) ) ; } else { return self :: $ utmCookie [ $ key ] ; } } }
12021	private function generateParameterSetBlock ( $ indent , \ ArtaxServiceBuilder \ Parameter $ operationParameter ) { switch ( $ operationParameter -> getLocation ( ) ) { case 'absoluteURL' : { return $ indent . '$url = $value;' . PHP_EOL ; break ; } case 'postField' : { return sprintf ( $ indent . '$formBody->addField(\'%s\', $value);' . PHP_EOL , $ operationParameter -> getSentAs ( ) ) ; } case 'postFile' : { return sprintf ( $ indent . '$formBody->addFileField(\'%s\', $value);' . PHP_EOL , $ operationParameter -> getSentAs ( ) ) ; break ; } case 'json' : { return sprintf ( $ indent . '$jsonParams[\'%s\'] = $value;' . PHP_EOL , $ operationParameter -> getSentAs ( ) ) ; } case ( 'header' ) : { return sprintf ( $ indent . '$request->setHeader(\'%s\', $value);' . PHP_EOL , $ operationParameter -> getSentAs ( ) , $ operationParameter -> getName ( ) ) ; } default : case 'query' : { return sprintf ( $ indent . '$queryParameters[\'%s\'] = $value;' . PHP_EOL , $ operationParameter -> getSentAs ( ) , $ operationParameter -> getName ( ) ) ; } } }
7960	public function canChangeDslamProfile ( $ forceReload = false ) { if ( ! $ this -> properties || $ forceReload ) $ this -> getProperties ( ) ; return $ this -> properties -> capabilities -> canChangeDslamProfile ; }
1871	public function generateAjax ( $ strFolder , $ strField , $ level , $ mount = false ) { if ( ! Environment :: get ( 'isAjaxRequest' ) ) { return '' ; } $ this -> strField = $ strField ; $ this -> loadDataContainer ( $ this -> strTable ) ; switch ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'dataContainer' ] ) { case 'File' : if ( Config :: get ( $ this -> strField ) != '' ) { $ this -> varValue = Config :: get ( $ this -> strField ) ; } break ; case 'Table' : $ this -> import ( Database :: class , 'Database' ) ; if ( ! $ this -> Database -> fieldExists ( $ this -> strField , $ this -> strTable ) ) { break ; } $ objField = $ this -> Database -> prepare ( "SELECT " . Database :: quoteIdentifier ( $ this -> strField ) . " FROM " . $ this -> strTable . " WHERE id=?" ) -> limit ( 1 ) -> execute ( $ this -> strId ) ; if ( $ objField -> numRows ) { $ this -> varValue = StringUtil :: deserialize ( $ objField -> { $ this -> strField } ) ; } break ; } $ this -> convertValuesToPaths ( ) ; if ( $ this -> extensions != '' ) { $ this -> arrValidFileTypes = StringUtil :: trimsplit ( ',' , $ this -> extensions ) ; } return $ this -> renderFiletree ( System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) . '/' . $ strFolder , ( $ level * 20 ) , $ mount , $ this -> isProtectedPath ( $ strFolder ) ) ; }
5411	public function write ( $ message ) { if ( $ this -> isError ( ) || ! $ this -> isOpen ( ) ) { return false ; } $ count = fwrite ( $ this -> handle , $ message ) ; if ( ! $ count ) { if ( $ count === false ) { $ this -> setError ( 'Cannot write to socket' ) ; $ this -> close ( ) ; } return false ; } fflush ( $ this -> handle ) ; $ this -> sent .= $ message ; return true ; }
3940	private function setEmptyValue ( PropertyInterface $ property , array $ propInfo ) { if ( ! array_key_exists ( 'empty_value' , $ propInfo ) || ! ( $ property instanceof EmptyValueAwarePropertyInterface ) ) { return ; } $ property -> setEmptyValue ( $ propInfo [ 'empty_value' ] ) ; }
9534	private function parseQuote ( & $ argv , $ argument , $ quoteType ) { if ( substr ( $ argument , strlen ( $ argument ) - 1 , 1 ) !== $ quoteType ) { $ this -> argv [ ] = substr ( $ argument , 1 ) ; while ( ( $ argument_part = array_shift ( $ argv ) ) != null && substr ( $ argument_part , strlen ( $ argument_part ) - 1 , 1 ) !== $ quoteType ) { $ this -> argv [ count ( $ this -> argv ) - 1 ] .= ' ' . $ argument_part ; } $ this -> argv [ count ( $ this -> argv ) - 1 ] .= ' ' . substr ( $ argument_part , 0 , strlen ( $ argument_part ) - 1 ) ; } else { $ this -> argv [ ] = substr ( substr ( $ argument , 1 ) , 0 , strlen ( $ argument ) - 2 ) ; } }
3739	private function saveBaseColumns ( IItem $ item , $ timestamp ) { $ isNew = false ; $ item -> set ( 'tstamp' , $ timestamp ) ; if ( ! $ item -> get ( 'id' ) ) { $ isNew = true ; $ this -> createNewItem ( $ item ) ; } if ( null !== $ item -> get ( 'pid' ) ) { $ this -> saveSimpleColumn ( 'pid' , [ $ item -> get ( 'id' ) ] , $ item -> get ( 'pid' ) ) ; } if ( null !== $ item -> get ( 'sorting' ) ) { $ this -> saveSimpleColumn ( 'sorting' , [ $ item -> get ( 'id' ) ] , $ item -> get ( 'sorting' ) ) ; } $ this -> saveSimpleColumn ( 'tstamp' , [ $ item -> get ( 'id' ) ] , $ item -> get ( 'tstamp' ) ) ; return $ isNew ; }
8183	public function getMemoryUsage ( ) { return isset ( $ this -> ends [ 'mu' ] ) && isset ( $ this -> starts [ 'mu' ] ) ? $ this -> ends [ 'mu' ] - $ this -> starts [ 'mu' ] : 0 ; }
8707	public function getLastFolderID ( ) { $ request = Controller :: curr ( ) -> getRequest ( ) ; $ session = $ request -> getSession ( ) ; return $ session -> get ( self :: class . '.FolderID' ) ; }
12254	public function addCompiler ( $ compiler ) { if ( $ compiler instanceof CompilerFactoryInterface || $ compiler instanceof CompilerInterface ) { $ this -> compilers [ ] = $ compiler ; $ this -> orderedCompilers = NULL ; } else throw new CompilerException ( "Can only add objects that implement CompilerInterface or CompilerFactoryInterface to context" ) ; }
6105	public function getHost ( ) { if ( $ this -> host === null ) { $ this -> host = new Host ( $ this ) ; } return $ this -> host ; }
11734	public function hide ( $ pageName , $ languageName ) { $ this -> contributorDefined ( ) ; $ baseDir = $ this -> pagesDir . '/' . $ pageName . '/' . $ languageName ; $ sourceFile = $ baseDir . '/seo.json' ; Dispatcher :: dispatch ( PageEvents :: PAGE_HIDING , new PageHidingEvent ( ) ) ; unlink ( $ sourceFile ) ; Dispatcher :: dispatch ( PageEvents :: PAGE_HID , new PageHidEvent ( ) ) ; DataLogger :: log ( sprintf ( 'Page "%s" for language "%s" was hidden from production' , $ pageName , $ languageName ) ) ; }
12194	public function instantiate ( $ className , array $ data = [ ] ) { $ refl = new \ ReflectionClass ( $ className ) ; $ instanceArgs = [ ] ; if ( $ data ) { $ instanceArgs = $ this -> extractArguments ( $ refl -> getConstructor ( ) -> getParameters ( ) , $ data ) ; } return $ refl -> newInstanceArgs ( $ instanceArgs ) ; }
8625	public function setTemporarilyUnavailableCarrierList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'TemporarilyUnavailableCarrierList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
77	protected function configure ( ) { $ this -> setDefinition ( array ( new InputArgument ( self :: ARGUMENT_PACKAGE , InputArgument :: REQUIRED , 'Package to inspect' ) , new InputArgument ( self :: ARGUMENT_CONSTRAINT , InputArgument :: OPTIONAL , 'Optional version constraint' , '*' ) , new InputOption ( self :: OPTION_RECURSIVE , 'r' , InputOption :: VALUE_NONE , 'Recursively resolves up to the root package' ) , new InputOption ( self :: OPTION_TREE , 't' , InputOption :: VALUE_NONE , 'Prints the results as a nested tree' ) , ) ) ; }
1748	protected function listSingleRecord ( $ id ) { if ( ! \ strlen ( $ this -> list_info_layout ) ) { $ this -> list_info_layout = 'info_default' ; } $ this -> Template = new FrontendTemplate ( $ this -> list_info_layout ) ; $ this -> Template -> record = array ( ) ; $ this -> Template -> referer = 'javascript:history.go(-1)' ; $ this -> Template -> back = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'goBack' ] ; $ this -> list_info = StringUtil :: deserialize ( $ this -> list_info ) ; $ this -> list_info_where = $ this -> replaceInsertTags ( $ this -> list_info_where , false ) ; $ objRecord = $ this -> Database -> prepare ( "SELECT " . implode ( ', ' , array_map ( 'Database::quoteIdentifier' , trimsplit ( ',' , $ this -> list_info ) ) ) . " FROM " . $ this -> list_table . " WHERE " . ( ( $ this -> list_info_where != '' ) ? "(" . $ this -> list_info_where . ") AND " : "" ) . Database :: quoteIdentifier ( $ this -> strPk ) . "=?" ) -> limit ( 1 ) -> execute ( $ id ) ; if ( $ objRecord -> numRows < 1 ) { return ; } $ arrFields = array ( ) ; $ arrRow = $ objRecord -> row ( ) ; $ limit = \ count ( $ arrRow ) ; $ count = - 1 ; foreach ( $ arrRow as $ k => $ v ) { if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> list_table ] [ 'fields' ] [ $ k ] [ 'inputType' ] == 'password' ) { -- $ limit ; continue ; } $ class = 'row_' . ++ $ count . ( ( $ count == 0 ) ? ' row_first' : '' ) . ( ( $ count >= ( $ limit - 1 ) ) ? ' row_last' : '' ) . ( ( ( $ count % 2 ) == 0 ) ? ' even' : ' odd' ) ; $ arrFields [ $ k ] = array ( 'raw' => $ v , 'label' => ( \ strlen ( $ label = $ GLOBALS [ 'TL_DCA' ] [ $ this -> list_table ] [ 'fields' ] [ $ k ] [ 'label' ] [ 0 ] ) ? $ label : $ k ) , 'content' => $ this -> formatValue ( $ k , $ v , true ) , 'class' => $ class ) ; } $ this -> Template -> record = $ arrFields ; }
10282	public static function splitRange ( $ pRange ) { if ( empty ( $ pRange ) ) { $ pRange = self :: DEFAULT_RANGE ; } $ exploded = explode ( ',' , $ pRange ) ; $ counter = count ( $ exploded ) ; for ( $ i = 0 ; $ i < $ counter ; ++ $ i ) { $ exploded [ $ i ] = explode ( ':' , $ exploded [ $ i ] ) ; } return $ exploded ; }
11164	protected function getPublishedFormat ( array $ config ) { if ( isset ( $ config [ 'publishedFormat' ] ) ) { if ( ! is_string ( $ config [ 'publishedFormat' ] ) ) { throw new \ DomainException ( 'publishedFormat must reference a string' , self :: ERR_INVALID_PUBLISHEDFORMAT ) ; } return $ config [ 'publishedFormat' ] ; } return 'n/j/y g:i A' ; }
11556	protected function findParameter ( $ namespace , $ name , $ namespaceParameters ) { foreach ( $ namespaceParameters as $ namespaceParameter ) { if ( $ namespaceParameter -> getNamespace ( ) === $ namespace && $ namespaceParameter -> getName ( ) === $ name ) { return $ namespaceParameter ; } } return null ; }
3568	public function replicate ( ) { return function ( $ next , $ copy , $ args ) { $ metaAttributes = $ args -> get ( 'original' ) -> getMetaAttributes ( ) -> replicate ( $ args -> get ( 'except' ) ) ; $ copy -> setRelation ( 'metaAttributes' , $ metaAttributes ) ; return $ next ( $ copy , $ args ) ; } ; }
2611	public function getActiveVersion ( $ service , $ activeVersion ) { $ currActiveVersion = $ this -> determineVersions ( $ service -> versions ) ; if ( $ currActiveVersion [ 'active_version' ] != $ activeVersion ) { throw new LocalizedException ( __ ( 'Active versions mismatch.' ) ) ; } return $ currActiveVersion ; }
1168	protected function setRemoteValidation ( $ attribute , $ validateAll = false ) { $ validator = $ this -> validator ; $ rules = $ validator -> getRules ( ) ; $ rules = isset ( $ rules [ $ attribute ] ) ? $ rules [ $ attribute ] : [ ] ; if ( in_array ( 'no_js_validation' , $ rules ) ) { $ validator -> setRules ( [ $ attribute => [ ] ] ) ; return ; } if ( ! $ validateAll ) { $ rules = $ this -> purgeNonRemoteRules ( $ rules , $ validator ) ; } $ validator -> setRules ( [ $ attribute => $ rules ] ) ; }
5822	public function renderFlashAlerts ( array $ options = array ( ) ) { $ options = $ this -> resolveOptions ( $ options ) ; return $ this -> templating -> render ( $ options [ 'template' ] , $ options ) ; }
9391	public function getSortValAfterAll ( $ groupingId = null ) { if ( ! $ groupingId === null && $ this -> grpColumn ) { throw new SortableException ( 'groupingId may be omitted only when grpColumn is not configured.' ) ; } $ query = ( new Query ( ) ) -> select ( $ this -> srtColumn ) -> from ( $ this -> targetTable ) -> where ( [ 'and' , $ this -> grpColumn ? [ '=' , $ this -> grpColumn , $ groupingId ] : [ ] , $ this -> skipRowsClause ( ) ] ) -> orderBy ( $ this -> srtColumn . ' DESC' ) -> limit ( 1 ) ; $ result = $ query -> one ( $ this -> db ) ; if ( $ result ) { $ result = array_values ( $ result ) ; $ sortVal = $ result [ 0 ] + $ this -> sortGap ; } else $ sortVal = $ this -> getIniSortVal ( ) ; return ( int ) $ sortVal ; }
261	protected function typecastValue ( $ value , $ type ) { if ( is_scalar ( $ type ) ) { if ( is_object ( $ value ) && method_exists ( $ value , '__toString' ) ) { $ value = $ value -> __toString ( ) ; } switch ( $ type ) { case self :: TYPE_INTEGER : return ( int ) $ value ; case self :: TYPE_FLOAT : return ( float ) $ value ; case self :: TYPE_BOOLEAN : return ( bool ) $ value ; case self :: TYPE_STRING : if ( is_float ( $ value ) ) { return StringHelper :: floatToString ( $ value ) ; } return ( string ) $ value ; default : throw new InvalidArgumentException ( "Unsupported type '{$type}'" ) ; } } return call_user_func ( $ type , $ value ) ; }
8436	public static function fetchArray ( array $ conditions , array $ orderBy = null , bool $ critical = false ) { $ entity = new static ( ) ; $ selectQuery = new Select ( $ entity -> getDatabaseName ( ) , $ critical ) ; $ selectQuery -> select ( $ entity -> getAllFieldsRealNames ( ) ) ; $ selectQuery -> from ( $ entity -> getTableName ( ) ) ; if ( count ( $ conditions ) > 0 ) { $ where = array ( ) ; foreach ( $ conditions as $ key => $ value ) { $ realName = constant ( get_called_class ( ) . '::FIELD_' . strtoupper ( Helper :: codifyName ( $ key ) ) ) ; $ where [ $ realName ] = ':where' . ucfirst ( $ key ) ; $ selectQuery -> bind ( 'where' . ucfirst ( $ key ) , $ value ) ; } $ selectQuery -> where ( $ where ) ; } if ( is_array ( $ orderBy ) && count ( $ orderBy ) > 0 ) { $ orders = array ( ) ; foreach ( $ orderBy as $ key => $ value ) { $ realName = constant ( get_called_class ( ) . '::FIELD_' . strtoupper ( Helper :: codifyName ( $ key ) ) ) ; $ orders [ $ realName ] = strtoupper ( ucfirst ( $ value ) ) ; } $ selectQuery -> orderBy ( $ orders ) ; } $ selectQuery -> limit ( 1 ) ; if ( $ selectQuery -> execute ( ) === false ) { return false ; } $ data = $ selectQuery -> fetch ( ) ; if ( is_array ( $ data ) === false ) { return false ; } return $ data ; }
10013	public function getSheetByName ( $ pName ) { $ worksheetCount = count ( $ this -> workSheetCollection ) ; for ( $ i = 0 ; $ i < $ worksheetCount ; ++ $ i ) { if ( $ this -> workSheetCollection [ $ i ] -> getTitle ( ) === $ pName ) { return $ this -> workSheetCollection [ $ i ] ; } } return null ; }
429	public function getUniqueId ( ) { return $ this -> module ? ltrim ( $ this -> module -> getUniqueId ( ) . '/' . $ this -> id , '/' ) : $ this -> id ; }
10627	public static function cpuCoreInfo ( ) { $ cores = array ( ) ; if ( false !== ( $ data = @ file ( '/proc/stat' ) ) ) { foreach ( $ data as $ line ) { if ( preg_match ( '/^cpu[0-9]/' , $ line ) ) { $ info = explode ( ' ' , $ line ) ; $ cores [ ] = array ( 'user' => $ info [ 1 ] , 'nice' => $ info [ 2 ] , 'sys' => $ info [ 3 ] , 'idle' => $ info [ 4 ] , 'iowait' => $ info [ 5 ] , 'irq' => $ info [ 6 ] , 'softirq' => $ info [ 7 ] ) ; } } } return $ cores ; }
3611	public function getNextScheduledEvent ( $ serial_number = NULL ) { $ schedule = $ this -> getDeviceSchedule ( $ serial_number ) ; $ next_event = FALSE ; $ time = date ( 'H' ) * 60 + date ( 'i' ) ; for ( $ i = 0 , $ day = date ( 'D' ) ; $ i ++ < 7 ; $ day = date ( 'D' , strtotime ( "+ $i days" ) ) ) { if ( isset ( $ schedule [ $ day ] ) ) { foreach ( $ schedule [ $ day ] as $ event ) { if ( $ event -> time > $ time ) { return $ event ; } } } $ time = 0 ; } return $ next_event ; }
3788	public static function calculateConditions ( IMetaModelDataDefinition $ container , array $ inputScreen ) { if ( $ container -> hasDefinition ( ModelRelationshipDefinitionInterface :: NAME ) ) { $ definition = $ container -> getDefinition ( ModelRelationshipDefinitionInterface :: NAME ) ; } else { $ definition = new DefaultModelRelationshipDefinition ( ) ; $ container -> setDefinition ( ModelRelationshipDefinitionInterface :: NAME , $ definition ) ; } if ( ! $ definition instanceof ModelRelationshipDefinitionInterface ) { throw new \ InvalidArgumentException ( 'Search element does not implement the correct interface.' ) ; } $ instance = new static ( ) ; $ instance -> container = $ container ; $ instance -> inputScreen = $ inputScreen ; $ instance -> definition = $ definition ; $ instance -> calculate ( ) ; }
7547	function getEncoding ( ) { $ root = $ this -> getRoot ( ) ; if ( $ root !== null ) { if ( $ enc = $ root -> select ( 'meta[charset]' , 0 , true , true ) ) { return $ enc -> getAttribute ( "charset" ) ; } elseif ( $ enc = $ root -> select ( '"?xml"[encoding]' , 0 , true , true ) ) { return $ enc -> getAttribute ( "encoding" ) ; } elseif ( $ enc = $ root -> select ( 'meta[content*="charset="]' , 0 , true , true ) ) { $ enc = $ enc -> getAttribute ( "content" ) ; return substr ( $ enc , strpos ( $ enc , "charset=" ) + 8 ) ; } } return false ; }
3759	public function buildWidget ( BuildWidgetEvent $ event ) { if ( ! ( $ this -> wantToHandle ( $ event ) && \ in_array ( $ event -> getProperty ( ) -> getName ( ) , [ 'name' , 'description' ] ) ) ) { return ; } $ metaModel = $ this -> getMetaModelByModelPid ( $ event -> getModel ( ) ) ; Helper :: prepareLanguageAwareWidget ( $ event -> getEnvironment ( ) , $ event -> getProperty ( ) , $ metaModel , $ this -> translator -> trans ( 'tl_metamodel_attribute.name_langcode' , [ ] , 'contao_tl_metamodel_attribute' ) , $ this -> translator -> trans ( 'tl_metamodel_attribute.name_value' , [ ] , 'contao_tl_metamodel_attribute' ) , false , StringUtil :: deserialize ( $ event -> getModel ( ) -> getProperty ( $ event -> getProperty ( ) -> getName ( ) ) , true ) ) ; }
11548	public function getGroup ( $ name ) { if ( array_key_exists ( $ name , $ this -> groups ) ) { return $ this -> groups [ $ name ] ; } throw new KeyNotFoundInSetException ( $ name , array_keys ( $ this -> groups ) , 'groups' ) ; }
4551	public function getList ( $ form ) : array { $ objects = $ this -> execute ( 'GET' , 'http://www.mocky.io/v2/592c3c86110000f8016df7de' ) ; $ list = [ ] ; foreach ( $ objects as $ object ) { $ model = static :: toModel ( $ object ) ; $ list [ ] = $ model ; } return $ list ; }
2455	public function copyAll ( ) { if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notCopyable' ] ) { throw new InternalServerErrorException ( 'Table "' . $ this -> strTable . '" is not copyable.' ) ; } $ objSession = System :: getContainer ( ) -> get ( 'session' ) ; $ arrClipboard = $ objSession -> get ( 'CLIPBOARD' ) ; if ( isset ( $ arrClipboard [ $ this -> strTable ] ) && \ is_array ( $ arrClipboard [ $ this -> strTable ] [ 'id' ] ) ) { foreach ( $ arrClipboard [ $ this -> strTable ] [ 'id' ] as $ id ) { $ this -> intId = $ id ; $ id = $ this -> copy ( true ) ; Input :: setGet ( 'pid' , $ id ) ; Input :: setGet ( 'mode' , 1 ) ; } } $ this -> redirect ( $ this -> getReferer ( ) ) ; }
6363	public function start ( $ name ) : Profiler { if ( ! $ this -> globalStopwatch -> isRunning ( ) ) { $ this -> globalStopwatch -> start ( ) ; } if ( $ this -> entryStopwatch -> isRunning ( ) ) { $ this -> recordEntry ( ) ; } $ this -> currentName = $ name ; $ this -> entryStopwatch -> start ( ) ; return $ this ; }
9459	public function getByIds ( array $ ids , $ page = 1 , $ per_page = 100 ) { return $ this -> getCollection ( 'tickets/show_many.json?ids=' . implode ( ',' , $ ids ) , 'tickets' , $ page , $ per_page ) ; }
1020	public function getLocations ( ) { if ( $ this -> locations === null ) { $ positions = $ this -> getPositions ( ) ; $ source = $ this -> getSource ( ) ; $ nodes = $ this -> nodes ; if ( $ positions && $ source ) { $ this -> locations = array_map ( static function ( $ pos ) use ( $ source ) { return $ source -> getLocation ( $ pos ) ; } , $ positions ) ; } elseif ( $ nodes ) { $ locations = array_filter ( array_map ( static function ( $ node ) { if ( $ node -> loc && $ node -> loc -> source ) { return $ node -> loc -> source -> getLocation ( $ node -> loc -> start ) ; } } , $ nodes ) ) ; $ this -> locations = array_values ( $ locations ) ; } else { $ this -> locations = [ ] ; } } return $ this -> locations ; }
9386	public function retrieve ( $ httpMethod , $ uri ) { $ route = array ( $ httpMethod , $ uri ) ; $ routes = array_map ( function ( $ route ) { return array ( $ route [ 0 ] , $ route [ 1 ] ) ; } , $ this -> routes ) ; $ key = array_search ( $ route , $ routes ) ; return $ key !== false ? $ this -> routes [ $ key ] : null ; }
12808	private static function getPrimaryKey ( string $ table ) : array { if ( self :: $ primaryKeyCache !== null && array_key_exists ( $ table , self :: $ primaryKeyCache ) ) return self :: $ primaryKeyCache [ $ table ] ; $ pdo = Database :: connect ( ) ; $ query = " SELECT tc.constraint_name, tc.table_name, kcu.column_name, ccu.table_name AS foreign_table_name, ccu.column_name AS foreign_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'PRIMARY KEY' AND tc.table_name = '$table' " ; $ results = $ pdo -> query ( $ query ) ; self :: $ primaryKeyCache [ $ table ] = $ results -> fetch ( ) ; return self :: $ primaryKeyCache [ $ table ] ; }
2147	protected function sendNewsletter ( Email $ objEmail , Result $ objNewsletter , $ arrRecipient , $ text , $ html , $ css = null ) { $ objEmail -> text = StringUtil :: parseSimpleTokens ( $ text , $ arrRecipient ) ; if ( ! $ objNewsletter -> sendText ) { if ( $ objNewsletter -> template == '' ) { $ objNewsletter -> template = 'mail_default' ; } $ objTemplate = new BackendTemplate ( $ objNewsletter -> template ) ; $ objTemplate -> setData ( $ objNewsletter -> row ( ) ) ; $ objTemplate -> title = $ objNewsletter -> subject ; $ objTemplate -> body = StringUtil :: parseSimpleTokens ( $ html , $ arrRecipient ) ; $ objTemplate -> charset = Config :: get ( 'characterSet' ) ; $ objTemplate -> recipient = $ arrRecipient [ 'email' ] ; $ objTemplate -> css = $ css ; $ objEmail -> html = $ objTemplate -> parse ( ) ; $ objEmail -> imageDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) . '/' ; } try { $ objEmail -> sendTo ( $ arrRecipient [ 'email' ] ) ; } catch ( \ Swift_RfcComplianceException $ e ) { $ _SESSION [ 'REJECTED_RECIPIENTS' ] [ ] = $ arrRecipient [ 'email' ] ; } if ( $ objEmail -> hasFailures ( ) ) { $ _SESSION [ 'REJECTED_RECIPIENTS' ] [ ] = $ arrRecipient [ 'email' ] ; } if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'sendNewsletter' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'sendNewsletter' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'sendNewsletter' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ objEmail , $ objNewsletter , $ arrRecipient , $ text , $ html ) ; } } }
665	protected function openFromPoolSequentially ( array $ pool , array $ sharedConfig ) { if ( empty ( $ pool ) ) { return null ; } if ( ! isset ( $ sharedConfig [ 'class' ] ) ) { $ sharedConfig [ 'class' ] = get_class ( $ this ) ; } $ cache = is_string ( $ this -> serverStatusCache ) ? Yii :: $ app -> get ( $ this -> serverStatusCache , false ) : $ this -> serverStatusCache ; foreach ( $ pool as $ config ) { $ config = array_merge ( $ sharedConfig , $ config ) ; if ( empty ( $ config [ 'dsn' ] ) ) { throw new InvalidConfigException ( 'The "dsn" option must be specified.' ) ; } $ key = [ __METHOD__ , $ config [ 'dsn' ] ] ; if ( $ cache instanceof CacheInterface && $ cache -> get ( $ key ) ) { continue ; } $ db = Yii :: createObject ( $ config ) ; try { $ db -> open ( ) ; return $ db ; } catch ( \ Exception $ e ) { Yii :: warning ( "Connection ({$config['dsn']}) failed: " . $ e -> getMessage ( ) , __METHOD__ ) ; if ( $ cache instanceof CacheInterface ) { $ cache -> set ( $ key , 1 , $ this -> serverRetryInterval ) ; } } } return null ; }
6026	public function setMimetype ( $ mimetype ) { if ( $ mimetype instanceof MimeType ) { $ this -> mimetype = $ mimetype ; } elseif ( is_array ( $ mimetype ) ) { $ this -> mimetype = new MimeType ( $ mimetype ) ; } else { $ this -> mimetype = null ; trigger_error ( 'Argument must be an object of class MimeType. Data loss!' , E_USER_WARNING ) ; } return $ this ; }
9393	public function withStatus ( $ code , $ reason = '' ) { $ static = clone $ this ; $ static -> code = $ code ; $ static -> reason = $ reason ? : $ static -> codes [ $ code ] ; return $ static ; }
10770	protected function resolveViewName ( ) { $ viewName = Yii :: $ app -> request -> get ( $ this -> viewParam , $ this -> defaultView ) ; if ( ! is_string ( $ viewName ) || ! preg_match ( '~^\w(?:(?!\/\.{0,2}\/)[\w\/\-\.])*$~' , $ viewName ) ) { if ( YII_DEBUG ) { throw new NotFoundHttpException ( "The requested view \"$viewName\" must start with a word character, must not contain /../ or /./, can contain only word characters, forward slashes, dots and dashes." ) ; } else { throw new NotFoundHttpException ( Yii :: t ( 'yii' , 'The requested view "{name}" was not found.' , [ 'name' => $ viewName ] ) ) ; } } return empty ( $ this -> viewPrefix ) ? $ viewName : $ this -> viewPrefix . '/' . $ viewName ; }
8906	public function count_by ( ) { $ where = func_get_args ( ) ; $ this -> _set_where ( $ where ) ; $ this -> apply_soft_delete_filter ( ) ; return $ this -> _database -> count_all_results ( $ this -> _table ) ; }
10493	public function mul ( $ value ) { $ value = Cast :: Float ( $ value ) ; if ( $ this -> value === null ) { return new FloatType ( $ this -> value ) ; } return new FloatType ( $ this -> value * $ value ) ; }
6791	public function create ( $ type , $ source = null ) { $ notify = new Notify ( ) ; $ notify -> setType ( $ type ) -> setSource ( $ source ) ; return $ notify ; }
8673	private function iterateReverseFromIndex ( $ fromIndex ) { Assert :: nullOrInteger ( $ fromIndex ) ; $ index = count ( $ this -> items ) ; if ( $ index === 0 ) { return ; } if ( $ fromIndex !== null ) { $ index = $ fromIndex < 0 ? max ( $ index + $ fromIndex , 1 ) : min ( $ fromIndex + 1 , $ index ) ; } $ keys = array_keys ( $ this -> items ) ; while ( -- $ index >= 0 ) { $ key = $ keys [ $ index ] ; yield $ key => $ this -> items [ $ key ] ; } }
9609	protected function _checkVectorSpace ( self $ b ) { if ( ! $ this -> isSameDimension ( $ b ) ) { throw new Exception ( 'The vectors must be of the same dimension' ) ; } if ( ! $ this -> isSameVectorSpace ( $ b ) ) { throw new Exception ( 'The vectors\' components must have the same keys' ) ; } }
3043	protected function unpackTimeLine ( & $ data ) { $ timeLine = new QtiTimeLine ( ) ; if ( isset ( $ data [ self :: STORAGE_KEY_TIMELINE_POINTS ] ) ) { $ epoch = 0 ; if ( isset ( $ data [ self :: STORAGE_KEY_TIMELINE_EPOCH ] ) ) { $ epoch = $ data [ self :: STORAGE_KEY_TIMELINE_EPOCH ] ; } $ tags = $ data [ self :: STORAGE_KEY_TIMELINE_TAGS ] ; foreach ( $ data [ self :: STORAGE_KEY_TIMELINE_POINTS ] as & $ dataPoint ) { $ point = new TimePoint ( $ tags , $ dataPoint [ 2 ] + $ epoch , $ dataPoint [ 1 ] , $ dataPoint [ 0 ] ) ; $ timeLine -> add ( $ point ) ; } $ points = $ timeLine -> getPoints ( ) ; foreach ( $ data [ self :: STORAGE_KEY_TIMELINE_INDEX ] as $ tag => & $ list ) { foreach ( $ list as $ index ) { $ points [ $ index ] -> addTag ( $ tag ) ; } } } else { $ timeLine -> fromArray ( $ data ) ; } return $ timeLine ; }
1213	public static function type ( $ arg ) { $ type = gettype ( $ arg ) ; if ( isset ( self :: $ typeMap [ $ type ] ) ) { return self :: $ typeMap [ $ type ] ; } elseif ( $ type === 'array' ) { if ( empty ( $ arg ) ) { return 'array' ; } reset ( $ arg ) ; return key ( $ arg ) === 0 ? 'array' : 'object' ; } elseif ( $ arg instanceof \ stdClass ) { return 'object' ; } elseif ( $ arg instanceof JmesPathableObjectInterface ) { return 'object' ; } elseif ( $ arg instanceof \ Closure ) { return 'expression' ; } elseif ( $ arg instanceof \ ArrayAccess && $ arg instanceof \ Countable ) { return count ( $ arg ) == 0 || $ arg -> offsetExists ( 0 ) ? 'array' : 'object' ; } elseif ( method_exists ( $ arg , '__toString' ) ) { return 'string' ; } throw new \ InvalidArgumentException ( 'Unable to determine JMESPath type from ' . get_class ( $ arg ) ) ; }
10577	private static function get ( $ style , $ setting , $ defaultValue = '' ) { if ( isset ( self :: $ styles [ $ style ] ) ) { $ style = self :: $ styles [ $ style ] ; if ( isset ( $ style [ $ setting ] ) ) { return $ style [ $ setting ] ; } } return $ defaultValue ; }
2870	public function getExtensionStatus ( ) { $ status = array ( ) ; $ extensions = $ this -> getExtensionRequirements ( ) ; foreach ( $ extensions as $ extension ) { $ status [ $ extension ] = extension_loaded ( $ extension ) ; } return $ status ; }
5539	protected function getPublicNameFromIndex ( $ subject ) { foreach ( $ this -> names as $ name => $ index ) { if ( $ subject == $ index ) { return $ name ; } } return $ subject + 1 ; }
8792	public function tag ( $ tag , $ content , array $ attributes = [ ] ) { $ content = is_array ( $ content ) ? implode ( PHP_EOL , $ content ) : $ content ; return $ this -> toHtmlString ( '<' . $ tag . $ this -> attributes ( $ attributes ) . '>' . PHP_EOL . $ this -> toHtmlString ( $ content ) . PHP_EOL . '</' . $ tag . '>' . PHP_EOL ) ; }
12176	public function addClassArgument ( $ name , $ class , $ required = true ) { return $ this -> addArgument ( new ClassArgument ( $ this -> argumentPosition ++ , $ name , $ class , $ required ) ) ; }
3267	protected function openFile ( int $ mode ) : SplFileObject { $ path = $ this -> getPath ( ) ; if ( ! is_file ( $ path ) && ! @ touch ( $ path ) ) { throw new Exception ( 'Could not create file: ' . $ path ) ; } if ( ! is_readable ( $ path ) || ! is_writable ( $ path ) ) { throw new Exception ( 'File does not have permission for read and write: ' . $ path ) ; } if ( $ this -> getConfig ( ) -> useGzip ( ) ) { $ path = 'compress.zlib://' . $ path ; } $ res = $ this -> fileAccessMode [ $ mode ] ; $ file = new SplFileObject ( $ path , $ res [ 'mode' ] ) ; if ( $ mode === self :: FILE_READ ) { $ file -> setFlags ( SplFileObject :: DROP_NEW_LINE | SplFileObject :: SKIP_EMPTY | SplFileObject :: READ_AHEAD ) ; } if ( ! $ this -> getConfig ( ) -> useGzip ( ) && ! $ file -> flock ( $ res [ 'operation' ] ) ) { $ file = null ; throw new Exception ( 'Could not lock file: ' . $ path ) ; } return $ file ; }
1492	public function current ( $ meta = null , array $ queryParams = [ ] ) { $ url = $ this -> generator -> current ( ) ; if ( $ queryParams ) { $ url .= '?' . http_build_query ( $ queryParams ) ; } return $ this -> factory -> createLink ( $ url , $ meta , true ) ; }
4536	public function setTenantIdIn ( array $ tenantIdIn ) { $ this -> tenantIdIn = $ tenantIdIn ; $ this -> _tenantIdIn = null !== $ tenantIdIn ; return $ this ; }
6367	public function min ( Traversable $ traversable ) { $ array = iterator_to_array ( $ traversable , false ) ; Arrays :: sort ( $ array , $ this ) ; return Preconditions :: checkElementExists ( $ array , 0 ) ; }
6141	public function checkPass ( $ password = null ) { if ( $ password === null ) { $ password = $ this -> pass ; } if ( strlen ( $ password ) == 0 ) { return true ; } $ pattern = "/^(" . $ this -> regex [ "alphanum" ] . "|" . $ this -> regex [ "mark" ] . "|" . $ this -> regex [ "escaped" ] . "|[;:&=+$,])+$/" ; $ status = @ preg_match ( $ pattern , $ password ) ; if ( $ status === false ) { throw new Ts3Exception ( "URI password validation failed" ) ; } return ( $ status == 1 ) ; }
687	protected function getChildrenRecursive ( $ name , $ childrenList , & $ result ) { if ( isset ( $ childrenList [ $ name ] ) ) { foreach ( $ childrenList [ $ name ] as $ child ) { $ result [ $ child ] = true ; $ this -> getChildrenRecursive ( $ child , $ childrenList , $ result ) ; } } }
10297	private function writeTitle ( XMLWriter $ objWriter , Title $ title = null ) { if ( $ title === null ) { return ; } $ objWriter -> startElement ( 'c:title' ) ; $ objWriter -> startElement ( 'c:tx' ) ; $ objWriter -> startElement ( 'c:rich' ) ; $ objWriter -> startElement ( 'a:bodyPr' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'a:lstStyle' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'a:p' ) ; $ caption = $ title -> getCaption ( ) ; if ( ( is_array ( $ caption ) ) && ( count ( $ caption ) > 0 ) ) { $ caption = $ caption [ 0 ] ; } $ this -> getParentWriter ( ) -> getWriterPart ( 'stringtable' ) -> writeRichTextForCharts ( $ objWriter , $ caption , 'a' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ this -> writeLayout ( $ objWriter , $ title -> getLayout ( ) ) ; $ objWriter -> startElement ( 'c:overlay' ) ; $ objWriter -> writeAttribute ( 'val' , 0 ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; }
5192	public function map ( array $ methods , string $ path , RequestHandlerInterface $ handler ) : Route { return $ this -> routes [ ] = new Route ( $ methods , $ path , $ handler ) ; }
6471	public function parseContentTypeHeader ( HttpHeaders $ headers ) : ? ContentTypeHeaderValue { if ( ! $ headers -> containsKey ( 'Content-Type' ) ) { return null ; } $ contentTypeHeaderParameters = $ this -> parseParameters ( $ headers , 'Content-Type' ) ; $ contentType = $ contentTypeHeaderParameters -> getKeys ( ) [ 0 ] ; return new ContentTypeHeaderValue ( $ contentType , $ contentTypeHeaderParameters ) ; }
12300	public function storeChild ( $ id , $ relation , array $ data ) { $ parent = $ this -> model -> find ( $ id ) ; if ( ! $ parent ) { return null ; } $ resource = $ parent -> $ relation ( ) -> create ( $ data ) ; return $ resource ; }
9238	private function getTextualPath ( array $ path , Vertex $ startVertex ) { $ currentVertex = $ startVertex ; $ currentTable = $ currentVertex -> getId ( ) ; $ textPath = $ currentTable ; foreach ( $ path as $ edge ) { if ( $ fk = $ edge -> getAttribute ( 'fk' ) ) { if ( $ fk -> getForeignTableName ( ) == $ currentTable ) { $ currentTable = $ fk -> getLocalTable ( ) -> getName ( ) ; $ isForward = false ; } else { $ currentTable = $ fk -> getForeignTableName ( ) ; $ isForward = true ; } $ columns = implode ( ',' , $ fk -> getLocalColumns ( ) ) ; $ textPath .= ' ' . ( ! $ isForward ? '<' : '' ) ; $ textPath .= '--(' . $ columns . ')--' ; $ textPath .= ( $ isForward ? '>' : '' ) . ' ' ; $ textPath .= $ currentTable ; } elseif ( $ junctionTable = $ edge -> getAttribute ( 'junction' ) ) { $ junctionFks = array_values ( $ junctionTable -> getForeignKeys ( ) ) ; $ fk = $ junctionFks [ 0 ] ; if ( $ fk -> getForeignTableName ( ) == $ currentTable ) { $ currentTable = $ junctionFks [ 1 ] -> getForeignTableName ( ) ; } else { $ currentTable = $ fk -> getForeignTableName ( ) ; } $ textPath .= ' <=(' . $ junctionTable -> getName ( ) . ')=> ' . $ currentTable ; } else { throw new SchemaAnalyzerException ( 'Unexpected edge. We should have a fk or a junction attribute.' ) ; } } return $ textPath ; }
4885	public function setExcludeMethods ( $ methods ) { if ( is_string ( $ methods ) ) { $ methods = array ( $ methods ) ; } foreach ( $ methods as $ method ) { $ this -> addFilter ( $ method , new MethodMatchFilter ( $ method ) , FilterComposite :: CONDITION_AND ) ; } }
4168	public function handle ( ) { $ packageInfo = $ this -> tokenizePackageInfo ( ) ; $ packages = $ this -> getPackages ( ) ; $ total = $ packages -> count ( ) ; if ( ! $ total ) { $ this -> warn ( ' No package found. Make sure you spell it correct as specified on github or packagist.' ) ; } if ( $ packages -> first ( ) [ 'name' ] !== $ packageInfo [ 'name' ] ) { $ this -> warn ( $ total . ' package' . ( $ total > 1 ? 's' : '' ) . ' found by given name.' ) ; return $ this -> call ( 'add' , [ 'package' => $ this -> prettify ( $ packages ) ] ) ; } $ this -> downloadPackage ( ) -> runConfiguration ( ) ; }
3792	private function getModelById ( $ modelId ) { if ( $ modelId === null ) { return null ; } $ provider = $ this -> environment -> getDataProvider ( ) ; $ config = $ provider -> getEmptyConfig ( ) -> setId ( $ modelId ) ; return $ provider -> fetch ( $ config ) ; }
7059	public function addClass ( $ class ) { $ classes = $ this -> getClasses ( ) ; if ( ! in_array ( $ class , $ classes ) ) { $ classes [ ] = $ class ; } $ this -> setClasses ( $ classes ) ; return $ this ; }
4235	private static function trimDesc ( $ desc ) { $ lines = \ explode ( "\n" , $ desc ) ; $ leadingSpaces = array ( ) ; foreach ( $ lines as $ line ) { if ( \ strlen ( $ line ) ) { $ leadingSpaces [ ] = \ strspn ( $ line , ' ' ) ; } } \ array_shift ( $ leadingSpaces ) ; $ trimLen = $ leadingSpaces ? \ min ( $ leadingSpaces ) : 0 ; if ( ! $ trimLen ) { return $ desc ; } foreach ( $ lines as $ i => $ line ) { $ lines [ $ i ] = $ i > 0 && \ strlen ( $ line ) ? \ substr ( $ line , $ trimLen ) : $ line ; } $ desc = \ implode ( "\n" , $ lines ) ; return $ desc ; }
7134	public function findOrCreateGoodLine ( Invoice \ InvoiceInterface $ invoice , Common \ SaleItemInterface $ item , $ available , $ expected = null ) { $ line = null ; if ( 0 >= $ available ) { return $ line ; } foreach ( $ invoice -> getLinesByType ( Document \ DocumentLineTypes :: TYPE_GOOD ) as $ invoiceLine ) { if ( $ invoiceLine -> getSaleItem ( ) === $ item ) { $ line = $ invoiceLine ; } } if ( null === $ line ) { $ line = $ this -> createLine ( $ invoice ) ; $ line -> setInvoice ( $ invoice ) -> setType ( Document \ DocumentLineTypes :: TYPE_GOOD ) -> setSaleItem ( $ item ) -> setDesignation ( $ item -> getDesignation ( ) ) -> setDescription ( $ item -> getDescription ( ) ) -> setReference ( $ item -> getReference ( ) ) ; } $ line -> setAvailable ( $ available ) ; $ line -> setExpected ( $ expected ) ; if ( Invoice \ InvoiceTypes :: isInvoice ( $ invoice ) && null === $ invoice -> getId ( ) ) { $ line -> setQuantity ( min ( $ expected , $ available ) ) ; } return $ line ; }
12533	public function bindLocation ( array $ deviceIdentifier , $ poiId , $ type = 1 , $ poiAppid = null ) { $ params = [ 'device_identifier' => $ deviceIdentifier , 'poi_id' => intval ( $ poiId ) , ] ; if ( $ type === 2 ) { if ( is_null ( $ poiAppid ) ) { throw new InvalidArgumentException ( 'If value of argument #3 is 2, argument #4 is required.' ) ; } $ params [ 'type' ] = 2 ; $ params [ 'poi_appid' ] = $ poiAppid ; } return $ this -> parseJSON ( 'json' , [ self :: API_DEVICE_BINDLOCATION , $ params ] ) ; }
6127	public function setExpireDate ( $ expireDate ) { if ( $ expireDate instanceof DateTime ) { $ this -> expireDate = $ expireDate ; } else { try { $ this -> expireDate = new DateTime ( $ expireDate ) ; } catch ( \ Exception $ e ) { $ this -> expireDate = null ; } } return $ this ; }
7261	protected function assertAdjustmentType ( Model \ AdjustmentInterface $ adjustment , string $ expected ) : void { if ( $ expected !== $ type = $ adjustment -> getType ( ) ) { throw new Exception \ InvalidArgumentException ( "Unexpected adjustment type '$type'." ) ; } }
548	protected function addMemcachedServers ( $ cache , $ servers ) { $ existingServers = [ ] ; if ( $ this -> persistentId !== null ) { foreach ( $ cache -> getServerList ( ) as $ s ) { $ existingServers [ $ s [ 'host' ] . ':' . $ s [ 'port' ] ] = true ; } } foreach ( $ servers as $ server ) { if ( empty ( $ existingServers ) || ! isset ( $ existingServers [ $ server -> host . ':' . $ server -> port ] ) ) { $ cache -> addServer ( $ server -> host , $ server -> port , $ server -> weight ) ; } } }
676	public function setPage ( $ value , $ validatePage = false ) { if ( $ value === null ) { $ this -> _page = null ; } else { $ value = ( int ) $ value ; if ( $ validatePage && $ this -> validatePage ) { $ pageCount = $ this -> getPageCount ( ) ; if ( $ value >= $ pageCount ) { $ value = $ pageCount - 1 ; } } if ( $ value < 0 ) { $ value = 0 ; } $ this -> _page = $ value ; } }
4144	public function get ( $ call , array $ getParams = null ) { $ this -> resetCallState ( ) ; $ this -> call = $ call ; $ this -> method = 'GET' ; if ( $ getParams !== null && is_array ( $ getParams ) ) { $ this -> getParams = $ getParams ; } $ response = $ this -> getResponse ( ) ; $ response [ 'body' ] = $ this -> findExceptions ( $ response ) ; $ this -> headers = $ response [ 'headers' ] ; unset ( $ call , $ getParams ) ; return $ this -> serializer -> format ( $ response [ 'body' ] ) ; }
7119	protected function getGetMinEdaBySubjectQuery ( ) { if ( null !== $ this -> getMinEdaBySubjectQuery ) { return $ this -> getMinEdaBySubjectQuery ; } $ as = $ this -> getAlias ( ) ; $ qb = $ this -> createFindBySubjectQueryBuilder ( ) ; $ qb -> andWhere ( $ qb -> expr ( ) -> isNotNull ( $ as . '.estimatedDateOfArrival' ) ) -> andWhere ( $ qb -> expr ( ) -> orX ( $ qb -> expr ( ) -> gte ( $ as . '.orderedStock' , 0 ) , $ qb -> expr ( ) -> gte ( $ as . '.availableStock' , 0 ) ) ) -> select ( 'MIN(' . $ as . '.estimatedDateOfArrival) as eda' ) ; return $ this -> getMinEdaBySubjectQuery = $ qb -> getQuery ( ) ; }
4593	public static function replace ( string $ string , array $ data = [ ] ) : string { $ expressionLanguage = new ExpressionLanguage ; preg_match_all ( '/\%([a-z0-9_\[\]\"\.]+)\%/i' , $ string , $ matches ) ; $ placeholders = array_unique ( $ matches [ 1 ] ) ; $ translations = [ ] ; foreach ( $ placeholders as $ placeholder ) { $ translations [ '%' . $ placeholder . '%' ] = $ expressionLanguage -> evaluate ( $ placeholder , $ data ) ; } $ string = strtr ( $ string , $ translations ) ; return $ string ; }
8549	public function setRetrochargeEventList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'RetrochargeEventList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
2997	public function setFrom ( $ email , $ title = null ) { $ this -> set ( 'From' , $ this -> buildMail ( $ email , $ title ) ) ; }
1911	protected function getType ( ) : string { if ( isset ( $ this -> options [ 'type' ] ) ) { return $ this -> options [ 'type' ] ; } $ className = ltrim ( strrchr ( static :: class , '\\' ) , '\\' ) ; if ( 'Controller' === substr ( $ className , - 10 ) ) { $ className = substr ( $ className , 0 , - 10 ) ; } return Container :: underscore ( $ className ) ; }
102	public function findFile ( $ class ) { if ( isset ( $ this -> classMap [ $ class ] ) ) { return $ this -> classMap [ $ class ] ; } if ( $ this -> classMapAuthoritative || isset ( $ this -> missingClasses [ $ class ] ) ) { return false ; } if ( null !== $ this -> apcuPrefix ) { $ file = apcu_fetch ( $ this -> apcuPrefix . $ class , $ hit ) ; if ( $ hit ) { return $ file ; } } $ file = $ this -> findFileWithExtension ( $ class , '.php' ) ; if ( false === $ file && defined ( 'HHVM_VERSION' ) ) { $ file = $ this -> findFileWithExtension ( $ class , '.hh' ) ; } if ( null !== $ this -> apcuPrefix ) { apcu_add ( $ this -> apcuPrefix . $ class , $ file ) ; } if ( false === $ file ) { $ this -> missingClasses [ $ class ] = true ; } return $ file ; }
2641	public function cleanBySurrogateKey ( $ keys ) { $ type = 'clean by key on ' ; $ uri = $ this -> _getApiServiceUri ( ) . 'purge' ; $ num = count ( $ keys ) ; $ result = false ; if ( $ num >= self :: FASTLY_MAX_HEADER_KEY_SIZE ) { $ parts = $ num / self :: FASTLY_MAX_HEADER_KEY_SIZE ; $ additional = ( $ parts > ( int ) $ parts ) ? 1 : 0 ; $ parts = ( int ) $ parts + ( int ) $ additional ; $ chunks = ceil ( $ num / $ parts ) ; $ collection = array_chunk ( $ keys , $ chunks ) ; } else { $ collection = [ $ keys ] ; } foreach ( $ collection as $ keys ) { $ payload = json_encode ( [ 'surrogate_keys' => $ keys ] ) ; $ result = $ this -> _purge ( $ uri , null , \ Zend_Http_Client :: POST , $ payload ) ; if ( $ result [ 'status' ] ) { foreach ( $ keys as $ key ) { $ this -> logger -> execute ( 'surrogate key: ' . $ key ) ; } } $ canPublishKeyUrlChanges = $ this -> config -> canPublishKeyUrlChanges ( ) ; $ canPublishPurgeChanges = $ this -> config -> canPublishPurgeChanges ( ) ; if ( $ this -> config -> areWebHooksEnabled ( ) && ( $ canPublishKeyUrlChanges || $ canPublishPurgeChanges ) ) { $ status = $ result [ 'status' ] ? '' : 'FAILED ' ; $ this -> sendWebHook ( $ status . '*clean by key on ' . join ( " " , $ keys ) . '*' ) ; $ canPublishPurgeByKeyDebugBacktrace = $ this -> config -> canPublishPurgeByKeyDebugBacktrace ( ) ; $ canPublishPurgeDebugBacktrace = $ this -> config -> canPublishPurgeDebugBacktrace ( ) ; if ( $ canPublishPurgeByKeyDebugBacktrace == false && $ canPublishPurgeDebugBacktrace == false ) { return $ result [ 'status' ] ; } $ this -> stackTrace ( $ type . join ( " " , $ keys ) ) ; } } return $ result [ 'status' ] ; }
11563	public function LineBreaks ( $ text , $ lang = "" ) { $ this -> text = $ text ; $ word = "" ; $ lang = $ lang ? $ lang : $ this -> lang ; list ( $ weekWords , $ units , $ shortcuts ) = $ this -> getWeekWordsUnitsAndShortcuts ( $ lang ) ; $ this -> text = preg_replace ( "#\t+#mu" , " " , $ this -> text ) ; $ this -> text = preg_replace ( "#[ ]{2,}#mu" , " " , $ this -> text ) ; for ( $ i = 0 , $ l = count ( $ weekWords ) ; $ i < $ l ; $ i += 1 ) { $ word = $ weekWords [ $ i ] ; $ this -> processWeakWord ( $ word ) ; $ word = mb_strtoupper ( mb_substr ( $ word , 0 , 1 ) ) . mb_substr ( $ word , 1 ) ; $ this -> processWeakWord ( $ word ) ; } for ( $ i = 0 , $ l = count ( $ units ) ; $ i < $ l ; $ i += 1 ) { $ word = $ units [ $ i ] ; $ regExp = "#([0-9])\\s(" . $ word . ")#mu" ; $ this -> text = preg_replace ( $ regExp , "$1&nbsp;$2" , $ this -> text ) ; } foreach ( $ shortcuts as $ sourceShortcut => $ targetShortcut ) { $ this -> text = str_replace ( $ sourceShortcut , $ targetShortcut , $ this -> text ) ; } $ this -> text = preg_replace ( "#([0-9])\s([0-9])#" , "$1&nbsp;$2" , $ this -> text ) ; return $ this -> text ; }
10560	public function init ( array $ config = [ ] ) { foreach ( $ config as $ key => $ value ) { switch ( $ key ) { case 'default_controller' : $ this -> defaultController = $ value ; break ; case 'default_action' : $ this -> defaultAction = $ value ; break ; case 'namespaces' : $ this -> namespaces = $ value ; break ; default : break ; } } }
7875	protected function settleRepositoryIfNotExists ( ) { $ source = $ this -> pipelines -> getSource ( ) ; if ( ! $ this -> files -> exists ( $ source ) ) { $ this -> pipelines -> settle ( ) ; } }
6249	protected function prepareForPresentation ( ) { if ( $ this -> prepared ) { return ; } $ this -> permissionGroups = new Collection ; $ this -> ungroupedPermissions = [ ] ; $ this -> groupedPermissionIndex = [ ] ; $ this -> loadPermissionsFromModules ( ) -> loadCustomPermissions ( ) -> loadCustomPermissionGroups ( ) -> addUngroupedPermissionGroup ( ) -> filterEmptyGroups ( ) ; }
12453	static function run_generate_sample_package_xml ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { pake_copy ( self :: getResourceDir ( ) . '/package_master.xml' , 'package.xml' ) ; $ tokens = array ( '$summary' => '[Summary]' , '$description' => '[Description]' , '$vendor' => '' , '$maintainers' => '' , '$documents' => '' , '$changelog' => '' , '$simple-files' => '' , '$state' => '[State]' , '$requires' => '' ) ; pake_replace_tokens ( 'package.xml' , '.' , '{' , '}' , $ tokens ) ; pake_echo ( "File package.xml generated. Please replace all tokens in square brackets in it (but do not replace values in curly brackets) then commit it to sources in the top dir of the extension" ) ; }
3662	private function parseTable ( ) { $ this -> queryString = str_replace ( '{{table}}' , $ this -> collection -> getMetaModel ( ) -> getTableName ( ) , $ this -> queryString ) ; }
1767	private function getRelativeRequestUri ( Request $ request ) : string { return ( string ) substr ( $ request -> getRequestUri ( ) , \ strlen ( $ request -> getBasePath ( ) ) + 1 ) ; }
906	public function isBinaryOperator ( $ index ) { static $ nonArrayOperators = [ '=' => true , '*' => true , '/' => true , '%' => true , '<' => true , '>' => true , '|' => true , '^' => true , '.' => true , ] ; static $ potentialUnaryNonArrayOperators = [ '+' => true , '-' => true , '&' => true , ] ; static $ arrayOperators ; if ( null === $ arrayOperators ) { $ arrayOperators = [ T_AND_EQUAL => true , T_BOOLEAN_AND => true , T_BOOLEAN_OR => true , T_CONCAT_EQUAL => true , T_DIV_EQUAL => true , T_DOUBLE_ARROW => true , T_IS_EQUAL => true , T_IS_GREATER_OR_EQUAL => true , T_IS_IDENTICAL => true , T_IS_NOT_EQUAL => true , T_IS_NOT_IDENTICAL => true , T_IS_SMALLER_OR_EQUAL => true , T_LOGICAL_AND => true , T_LOGICAL_OR => true , T_LOGICAL_XOR => true , T_MINUS_EQUAL => true , T_MOD_EQUAL => true , T_MUL_EQUAL => true , T_OR_EQUAL => true , T_PLUS_EQUAL => true , T_POW => true , T_POW_EQUAL => true , T_SL => true , T_SL_EQUAL => true , T_SR => true , T_SR_EQUAL => true , T_XOR_EQUAL => true , CT :: T_TYPE_ALTERNATION => true , ] ; if ( \ defined ( 'T_SPACESHIP' ) ) { $ arrayOperators [ T_SPACESHIP ] = true ; } if ( \ defined ( 'T_COALESCE' ) ) { $ arrayOperators [ T_COALESCE ] = true ; } } $ tokens = $ this -> tokens ; $ token = $ tokens [ $ index ] ; if ( $ token -> isArray ( ) ) { return isset ( $ arrayOperators [ $ token -> getId ( ) ] ) ; } if ( isset ( $ nonArrayOperators [ $ token -> getContent ( ) ] ) ) { return true ; } if ( isset ( $ potentialUnaryNonArrayOperators [ $ token -> getContent ( ) ] ) ) { return ! $ this -> isUnaryPredecessorOperator ( $ index ) ; } return false ; }
12399	public function orderBy ( $ field , $ order = null ) { $ this -> scope -> orderBy [ ] = Parser :: orderBy ( $ field , $ order ) ; return $ this ; }
12392	public function getPages ( $ startPage , $ endPage , $ urlStub ) { $ pages = [ ] ; for ( $ x = $ startPage ; $ x <= $ endPage ; $ x ++ ) { $ pages [ ] = $ urlStub . $ x ; } return $ pages ; }
9343	public function addRow ( array $ arr_row ) { if ( count ( $ this -> arr ) == $ this -> size -> rows ) { throw new \ OutOfRangeException ( sprintf ( 'You cannot add another row! Max number of rows is %d' , $ this -> size -> rows ) ) ; } if ( count ( $ arr_row ) != $ this -> size -> cols ) { throw new \ InvalidArgumentException ( 'New row must have same amout of columns than defined into the size matrix' ) ; } $ this -> arr [ ] = $ arr_row ; return $ this ; }
749	public function load ( $ filePath , $ context ) { $ pattern = '/(msgctxt\s+"(.*?(?<!\\\\))")?\s+' . 'msgid\s+((?:".*(?<!\\\\)"\s*)+)\s+' . 'msgstr\s+((?:".*(?<!\\\\)"\s*)+)/' ; $ content = file_get_contents ( $ filePath ) ; $ matches = [ ] ; $ matchCount = preg_match_all ( $ pattern , $ content , $ matches ) ; $ messages = [ ] ; for ( $ i = 0 ; $ i < $ matchCount ; ++ $ i ) { if ( $ matches [ 2 ] [ $ i ] === $ context ) { $ id = $ this -> decode ( $ matches [ 3 ] [ $ i ] ) ; $ message = $ this -> decode ( $ matches [ 4 ] [ $ i ] ) ; $ messages [ $ id ] = $ message ; } } return $ messages ; }
7921	private function extractFilenames ( \ ZipArchive $ zipArchive ) { $ filenames = array ( ) ; $ fileCount = $ zipArchive -> numFiles ; for ( $ i = 0 ; $ i < $ fileCount ; $ i ++ ) { if ( ( $ filename = $ this -> extractFilename ( $ zipArchive , $ i ) ) !== false ) { $ filenames [ ] = $ filename ; } } return $ filenames ; }
8435	public function delete ( ) : bool { $ status = false ; if ( $ this -> new === false ) { $ deleteQuery = new Delete ( $ this -> getDatabaseName ( ) ) ; $ deleteQuery -> from ( $ this -> getTableName ( ) ) ; $ where = array ( ) ; foreach ( $ this -> getPrimary ( ) as $ primary ) { $ field = $ this -> { 'field' . ucfirst ( $ primary ) } ; $ realName = constant ( get_called_class ( ) . '::FIELD_' . strtoupper ( Helper :: codifyName ( $ primary ) ) ) ; $ where [ $ realName ] = ':primary' . ucfirst ( $ primary ) ; $ deleteQuery -> bind ( 'primary' . ucfirst ( $ primary ) , $ field [ 'value' ] ) ; } $ deleteQuery -> where ( $ where ) ; $ status = $ deleteQuery -> execute ( ) ; } return $ status ; }
270	public function getEnabled ( ) { if ( is_callable ( $ this -> _enabled ) ) { return call_user_func ( $ this -> _enabled , $ this ) ; } return $ this -> _enabled ; }
11330	public function getMultiline ( ) { if ( is_null ( $ this -> _multiline ) ) { $ this -> _multiline = MultilineDetector :: test ( $ this -> fieldSchema ) ; } return $ this -> _multiline ; }
10482	public function getBucket ( string $ name ) : SessionBucketInterface { $ segment = $ this -> session -> getSegment ( $ name ) ; if ( ! $ segment ) { return null ; } return new AuraSessionBucketAdapter ( $ segment ) ; }
8930	protected function getStackIconElement ( $ key , $ value , $ index ) { $ element = $ value ; if ( is_string ( $ key ) ) { $ element = $ this -> icon ( $ key ) -> addClass ( $ value ) ; } else if ( is_string ( $ value ) ) { $ element = $ this -> icon ( $ value ) ; } if ( ! is_a ( $ element , FontAwesomeIcon :: class ) ) { throw new \ InvalidArgumentException ( 'Invalid icon passed to stack' ) ; } return $ element -> addClass ( "fa-stack-{$index}x" ) ; }
2898	public function queryEnd ( $ queryId ) { $ result = $ this -> parentQueryEnd ( $ queryId ) ; if ( $ this -> captureStacktraces ) { $ this -> stackTraces [ $ queryId ] = $ this -> getStackTrace ( ) ; } return $ result ; }
4445	public function failed ( ) : array { $ results = json_decode ( $ this -> client -> failed ( ) , true ) ; return is_array ( $ results ) ? $ results : [ ] ; }
11662	public static function saveToString ( $ properties ) { $ xn = new \ SimpleXMLElement ( self :: XML_ROOT_OPEN . self :: XML_ROOT_CLOSE , LIBXML_NOXMLDECL ) ; foreach ( $ properties as $ key => $ value ) { $ xn -> addChild ( "entry" , htmlspecialchars ( $ value , ENT_XML1 ) ) -> addAttribute ( "key" , htmlspecialchars ( $ key , ENT_XML1 ) ) ; } return preg_replace ( '/\<\?.*\?\>/' , self :: XML_PRELUDE , $ xn -> asXML ( ) ) ; }
9606	public function multiplyByScalar ( $ scalar ) { $ result = [ ] ; foreach ( $ this -> components ( ) as $ i => $ component ) { $ result [ $ i ] = $ component * $ scalar ; } return new static ( $ result ) ; }
3422	public function count ( ) { if ( $ this -> queryShouldBeStopped ) { return 0 ; } $ queryType = 'UserQuery::count' ; $ filter = $ this -> normalizeFilter ( ) ; $ callback = function ( ) use ( $ filter ) { return ( int ) $ this -> bxObject -> getList ( $ order = 'ID' , $ by = 'ASC' , $ filter , [ 'NAV_PARAMS' => [ 'nTopCount' => 0 , ] , ] ) -> NavRecordCount ; } ; return $ this -> handleCacheIfNeeded ( compact ( 'queryType' , 'filter' ) , $ callback ) ; }
9244	private function __loadConfigFiles ( ) { $ additionalConfigs = $ this -> config ( 'additionalConfigFiles' ) ; foreach ( $ additionalConfigs as $ additionalConfig ) { Configure :: load ( $ additionalConfig ) ; } }
12124	public function getLanguages ( ) { $ languages = array ( ) ; foreach ( $ this -> getAliases ( ) as $ siteAlias ) { $ language = $ siteAlias -> getLanguage ( ) ; if ( ! in_array ( $ language , $ languages ) ) { $ languages [ ] = $ language ; } } return $ languages ; }
3767	private function getOptions ( $ attribute , $ onlyUsed ) { $ options = [ ] ; foreach ( $ attribute -> getFilterOptions ( null , $ onlyUsed ) as $ key => $ value ) { $ value = trim ( strip_tags ( $ value ) ) ; if ( ! empty ( $ value ) ) { $ options [ $ key ] = $ value ; } } return $ options ; }
8806	protected function ensureFacadeExists ( $ alias ) { if ( file_exists ( $ path = storage_path ( 'cache/facade-' . sha1 ( $ alias ) . '.php' ) ) ) { return $ path ; } file_put_contents ( $ path , $ this -> formatFacadeStub ( $ alias , file_get_contents ( __DIR__ . '/stubs/facade.stub' ) ) ) ; return $ path ; }
5476	protected function encode ( ) { $ class = $ this -> encoding ; $ encoding = new $ class ( ) ; for ( $ i = 0 , $ count = count ( $ this -> widgets ) ; $ i < $ count ; $ i ++ ) { $ this -> widgets [ $ i ] -> write ( $ encoding ) ; } return $ encoding ; }
9547	public function rank ( $ info , $ weights ) { if ( ! empty ( $ weights ) ) { $ weights = explode ( ',' , $ weights ) ; } $ score = ( float ) 0.0 ; $ isize = 4 ; $ phrases = ( int ) ord ( substr ( $ info , 0 , $ isize ) ) ; $ columns = ( int ) ord ( substr ( $ info , $ isize , $ isize ) ) ; $ string = $ phrases . ' ' . $ columns . ' ' ; for ( $ p = 0 ; $ p < $ phrases ; ++ $ p ) { $ term = substr ( $ info , ( 2 + $ p * $ columns * 3 ) * $ isize ) ; for ( $ c = 0 ; $ c < $ columns ; ++ $ c ) { $ here = ( float ) ord ( substr ( $ term , ( 3 * $ c * $ isize ) , 1 ) ) ; $ total = ( float ) ord ( substr ( $ term , ( 3 * $ c + 1 ) * $ isize , 1 ) ) ; $ rows = ( float ) ord ( substr ( $ term , ( 3 * $ c + 2 ) * $ isize , 1 ) ) ; $ relevance = ( ! empty ( $ total ) ) ? ( $ rows / $ total ) * $ here : 0 ; $ weight = ( isset ( $ weights [ $ c ] ) ) ? ( float ) $ weights [ $ c ] : 1 ; $ score += $ relevance * $ weight ; $ string .= $ here . $ total . $ rows . ' (' . round ( $ relevance , 2 ) . '*' . $ weight . ') ' ; } } return $ score ; }
12	public function setOptimizeAutoloader ( $ optimizeAutoloader = false ) { $ this -> optimizeAutoloader = ( bool ) $ optimizeAutoloader ; if ( ! $ this -> optimizeAutoloader ) { $ this -> setClassMapAuthoritative ( false ) ; } return $ this ; }
11197	public function add ( $ item , $ key = false , $ dataKey = false ) { $ keyPrefix = '' ; if ( is_array ( $ dataKey ) ) { $ keyPrefix = $ dataKey [ 1 ] ; $ dataKey = $ dataKey [ 0 ] ; } if ( is_object ( $ item ) ) { if ( $ key ) { if ( ! isset ( $ this -> key ) ) { $ this -> size += 1 ; } $ this -> singleton -> $ key = $ item ; } else if ( $ dataKey && isset ( $ item -> $ dataKey ) ) { $ key = $ item -> $ dataKey ; if ( ! isset ( $ this -> key ) ) { $ this -> size += 1 ; } $ this -> singleton -> { $ keyPrefix . $ key } = $ item ; } else { $ offset = '_item' . $ this -> size ; $ this -> size += 1 ; $ this -> singleton -> { "$offset" } = $ item ; } } else if ( is_array ( $ item ) ) { if ( $ key ) { if ( ! isset ( $ this -> key ) ) { $ this -> size += 1 ; } $ this -> singleton -> $ key = $ item ; } else if ( $ dataKey && isset ( $ item [ $ dataKey ] ) ) { $ key = $ item [ $ dataKey ] ; if ( ! isset ( $ this -> key ) ) { $ this -> size += 1 ; } $ this -> singleton -> { $ keyPrefix . $ key } = $ item ; } else { $ offset = '_item' . $ this -> size ; $ this -> size += 1 ; $ this -> singleton -> { "$offset" } = $ item ; } } else { if ( $ key ) { if ( ! $ this -> __isset ( $ key ) ) { $ this -> size += 1 ; } $ this -> singleton -> $ key = $ item ; } else { $ offset = '_item' . $ this -> size ; $ this -> size += 1 ; $ this -> singleton -> { "$offset" } = $ item ; } } $ this -> contentModified = true ; return $ this ; }
9626	public function getAll ( array $ filterAttributes = [ ] ) { $ filters = [ 'query' => [ $ filterAttributes ] ] ; try { $ result = $ this -> client -> get ( $ this -> slug , $ filters ) ; } catch ( RequestException $ e ) { $ return [ 'request' ] = $ e -> getRequest ( ) . "\n" ; if ( $ e -> hasResponse ( ) ) { return $ return [ 'response' ] = $ e -> getResponse ( ) . "\n" ; } } return $ result -> json ( ) ; }
471	public function down ( ) { $ transaction = $ this -> db -> beginTransaction ( ) ; try { if ( $ this -> safeDown ( ) === false ) { $ transaction -> rollBack ( ) ; return false ; } $ transaction -> commit ( ) ; } catch ( \ Exception $ e ) { $ this -> printException ( $ e ) ; $ transaction -> rollBack ( ) ; return false ; } catch ( \ Throwable $ e ) { $ this -> printException ( $ e ) ; $ transaction -> rollBack ( ) ; return false ; } return null ; }
3369	private function getClassString ( ClassMetadata $ class ) { $ this -> visitAssociation ( $ class -> getName ( ) ) ; $ className = $ class -> getName ( ) ; $ classText = '[' . str_replace ( '\\' , '.' , $ className ) ; $ fields = [ ] ; $ parent = $ this -> getParent ( $ class ) ; $ parentFields = $ parent ? $ parent -> getFieldNames ( ) : [ ] ; foreach ( $ class -> getFieldNames ( ) as $ fieldName ) { if ( in_array ( $ fieldName , $ parentFields ) ) { continue ; } if ( $ class -> isIdentifier ( $ fieldName ) ) { $ fields [ ] = '+' . $ fieldName ; } else { $ fields [ ] = $ fieldName ; } } if ( ! empty ( $ fields ) ) { $ classText .= '|' . implode ( ';' , $ fields ) ; } $ classText .= ']' ; return $ classText ; }
4143	public function getHeaders ( $ key = null ) { if ( $ key === null ) { return $ this -> headers ; } if ( isset ( $ this -> headers [ $ key ] ) ) { return $ this -> headers [ $ key ] ; } return false ; }
1810	public function adjustDcaByType ( $ dc ) { $ objCte = Contao \ ContentModel :: findByPk ( $ dc -> id ) ; if ( $ objCte === null ) { return ; } switch ( $ objCte -> type ) { case 'hyperlink' : unset ( $ GLOBALS [ 'TL_DCA' ] [ 'tl_content' ] [ 'fields' ] [ 'imageUrl' ] ) ; break ; case 'image' : $ GLOBALS [ 'TL_DCA' ] [ 'tl_content' ] [ 'fields' ] [ 'imagemargin' ] [ 'eval' ] [ 'tl_class' ] .= ' clr' ; break ; } }
10863	protected function createIterator ( ) { $ options = \ RecursiveDirectoryIterator :: SKIP_DOTS ; $ iterator = new \ RecursiveDirectoryIterator ( $ this -> dir , $ options ) ; $ options = \ RecursiveIteratorIterator :: SELF_FIRST ; return new \ RecursiveIteratorIterator ( $ iterator , $ options ) ; }
9929	protected function handleUnpermittedParam ( $ key , $ params ) { if ( $ this -> getThrowExceptions ( ) ) { $ message = "Parameter '$key' is not allowed" ; throw new UnpermittedParameterException ( $ message ) ; } $ params -> delete ( $ key ) ; }
3877	public function build ( ) { if ( ! $ this -> isEmpty ( ) ) { return new SimpleQuery ( sprintf ( 'SELECT id FROM %s WHERE %s' , $ this -> tableName , $ this -> getProcedure ( ) ) , $ this -> getParameters ( ) , 'id' , $ this -> connection ) ; } return null ; }
4767	public static function convertXmlToPhpObj ( $ node ) { $ ret = array ( ) ; if ( is_object ( $ node ) && $ node -> hasChildNodes ( ) ) { foreach ( $ node -> childNodes as $ child ) { $ name = self :: decode ( $ child -> nodeName ) ; if ( $ child -> nodeType == XML_TEXT_NODE ) { $ ret = self :: decode ( $ child -> nodeValue ) ; } else { if ( 'array' === $ name ) { return self :: parseArray ( $ child ) ; } else { $ ret [ $ name ] = self :: convertXmlToPhpObj ( $ child ) ; } } } } return ! empty ( $ ret ) ? $ ret : null ; }
11726	public function render ( $ filter = null ) : string { if ( empty ( $ this -> output ) ) { extract ( array_merge ( $ this -> vars , View :: $ global_vars ) , EXTR_REFS ) ; ob_start ( ) ; include ( $ this -> view_file ) ; $ this -> output = ob_get_clean ( ) ; } if ( $ filter !== null ) { $ this -> output = call_user_func ( $ filter , $ this -> output ) ; } return $ this -> output ; }
5841	public function addRole ( $ role ) { if ( is_string ( $ role ) ) { $ role = new Role ( $ role ) ; } elseif ( ! $ role instanceof RoleInterface ) { throw new \ InvalidArgumentException ( sprintf ( 'Role must be a string or RoleInterface instance, but got %s.' , gettype ( $ role ) ) ) ; } if ( ! \ in_array ( $ role , $ this -> roles ) ) { $ this -> roles [ ] = $ role ; } }
893	private function getTypesContent ( ) { if ( null === $ this -> typesContent ) { $ name = $ this -> getTag ( ) -> getName ( ) ; if ( ! $ this -> supportTypes ( ) ) { throw new \ RuntimeException ( 'This tag does not support types.' ) ; } $ matchingResult = Preg :: match ( '{^(?:\s*\*|/\*\*)\s*@' . $ name . '\s+' . self :: REGEX_TYPES . '(?:[ \t].*)?$}sx' , $ this -> lines [ 0 ] -> getContent ( ) , $ matches ) ; $ this -> typesContent = 1 === $ matchingResult ? $ matches [ 'types' ] : '' ; } return $ this -> typesContent ; }
11825	public function add ( $ encoding = 'UTF-8' ) { $ str = file_get_contents ( $ this -> uri ) ; return file_put_contents ( $ this -> uri , $ this -> getBom ( $ encoding ) . $ str ) ; }
6072	public function updateMedia ( $ id , Media $ media ) { if ( $ media instanceof MediaResponse ) { $ media = new Media ( json_decode ( json_encode ( $ media ) , true ) ) ; } $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'media' => $ media ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/media/' . $ id . '' , $ parameters ) ; $ result = new MediaResponse ( $ result ) ; return $ result ; }
6509	public function createHandlers ( JobInterface $ job , $ level , $ bubble ) { $ handlers = [ ] ; foreach ( $ this -> factories as $ factory ) { $ handlers [ ] = $ factory -> createHandler ( $ job , $ level , $ bubble ) ; } return $ handlers ; }
31	public function parseHgIgnoreLine ( $ line ) { if ( preg_match ( '#^syntax\s*:\s*(glob|regexp)$#' , $ line , $ matches ) ) { if ( $ matches [ 1 ] === 'glob' ) { $ this -> patternMode = self :: HG_IGNORE_GLOB ; } else { $ this -> patternMode = self :: HG_IGNORE_REGEX ; } return null ; } if ( $ this -> patternMode == self :: HG_IGNORE_GLOB ) { return $ this -> patternFromGlob ( $ line ) ; } return $ this -> patternFromRegex ( $ line ) ; }
5622	protected function chompPath ( & $ url ) { if ( preg_match ( '/(.*?)(\?|#|$)(.*)/' , $ url , $ matches ) ) { $ url = $ matches [ 2 ] . $ matches [ 3 ] ; return ( $ matches [ 1 ] ? $ matches [ 1 ] : '' ) ; } return '' ; }
10993	public function getByteSize ( ) : int { if ( $ this -> test ( \ sndsgd \ Fs :: READABLE ) !== true ) { $ this -> error = "failed to stat filesize; {$this->error}" ; return - 1 ; } $ bytes = @ filesize ( $ this -> path ) ; if ( $ bytes === false ) { $ this -> setError ( "failed to stat filesize for '{$this->path}'" ) ; return - 1 ; } return $ bytes ; }
2582	protected function loadTransactionFlowLink ( $ params ) { if ( isset ( $ params [ 'enableTransactionFlowLink' ] ) && $ params [ 'enableTransactionFlowLink' ] === true ) { $ this -> enableTransactionFlowLink = true ; $ this -> consumerId = ( isset ( $ params [ 'consumerId' ] ) ) ? $ params [ 'consumerId' ] : null ; } }
2548	private function findHandlerForMessage ( $ messageName ) { $ handler = null ; if ( array_key_exists ( $ messageName , $ this -> responseHandlers ) && $ this -> responseHandlers [ $ messageName ] instanceof MessageResponseHandler ) { $ handler = $ this -> responseHandlers [ $ messageName ] ; } else { $ section = substr ( $ messageName , 0 , strpos ( $ messageName , '_' ) ) ; $ message = substr ( $ messageName , strpos ( $ messageName , '_' ) + 1 ) ; $ handlerClass = __NAMESPACE__ . '\\' . $ section . '\\Handler' . $ message ; if ( class_exists ( $ handlerClass ) ) { $ handler = new $ handlerClass ( ) ; $ this -> responseHandlers [ $ messageName ] = $ handler ; } } return $ handler ; }
5225	private function resolve ( Injector $ injector , $ type ) { $ resolved = [ ] ; foreach ( $ this -> getBindings ( ) as $ key => $ bindingValue ) { $ value = $ bindingValue ( $ injector , $ this -> name , $ key ) ; if ( $ this -> isTypeMismatch ( $ type , $ value ) ) { $ valueType = ( ( is_object ( $ value ) ) ? ( get_class ( $ value ) ) : ( gettype ( $ value ) ) ) ; throw new BindingException ( 'Value of type ' . $ valueType . ' for ' . ( ( is_int ( $ key ) ) ? ( 'list' ) : ( 'map' ) ) . ' named ' . $ this -> name . ' at position ' . $ key . ' is not of type ' . $ type -> getName ( ) ) ; } $ resolved [ $ key ] = $ value ; } return $ resolved ; }
229	public function getPdoType ( $ data ) { static $ typeMap = [ 'boolean' => \ PDO :: PARAM_BOOL , 'integer' => \ PDO :: PARAM_INT , 'string' => \ PDO :: PARAM_STR , 'resource' => \ PDO :: PARAM_LOB , 'NULL' => \ PDO :: PARAM_NULL , ] ; $ type = gettype ( $ data ) ; return isset ( $ typeMap [ $ type ] ) ? $ typeMap [ $ type ] : \ PDO :: PARAM_STR ; }
5412	public function read ( ) { if ( $ this -> isError ( ) || ! $ this -> isOpen ( ) ) { return false ; } $ raw = @ fread ( $ this -> handle , $ this -> block_size ) ; if ( $ raw === false ) { $ this -> setError ( 'Cannot read from socket' ) ; $ this -> close ( ) ; } return $ raw ; }
8756	public static function build ( array $ subscribers = [ ] , $ totalItems = self :: UNKNOWN ) { $ that = new static ( $ totalItems ) ; foreach ( $ subscribers as $ subscriber ) { $ that -> addSubscriber ( $ subscriber ) ; } return $ that ; }
4503	public function replaceWith ( DOMNode $ replacement ) : void { $ this -> parentNode -> insertBefore ( $ replacement , $ this ) ; $ this -> remove ( ) ; }
10263	public function getCreditCard ( $ weighted = true ) { if ( $ weighted ) { $ weight [ ] = [ 'American Express' , 1 ] ; $ weight [ ] = [ 'Discover' , 2 ] ; $ weight [ ] = [ 'MasterCard' , 10 ] ; $ weight [ ] = [ 'Visa' , 10 ] ; foreach ( $ weight as $ w ) { $ type = $ w [ 0 ] ; $ count = $ w [ 1 ] ; for ( $ i = 0 ; $ i < $ count ; $ i ++ ) { $ card_types [ ] = $ type ; } } } else { $ card_types = [ 'American Express' , 'Discover' , 'MasterCard' , 'Visa' ] ; } $ cc = new Entities \ CreditCard ; $ cc -> type = $ this -> fromArray ( $ card_types ) ; $ cc -> number = $ this -> getBankNumber ( $ cc -> type ) ; $ cc -> expiration = $ this -> getExpiration ( ) ; return $ cc ; }
1249	public function createService ( $ namespace , array $ config = [ ] ) { $ configuration = $ this -> config ; if ( isset ( $ this -> config [ $ namespace ] ) ) { $ configuration = arrayMergeDeep ( $ configuration , $ this -> config [ $ namespace ] ) ; } $ configuration = arrayMergeDeep ( $ configuration , $ config ) ; $ service = "DTS\\eBaySDK\\{$namespace}\\Services\\{$namespace}Service" ; return new $ service ( $ configuration ) ; }
10501	public function autoComplete ( $ data ) { static $ counter = 0 ; $ this -> inputOptions [ 'class' ] .= ' typeahead typeahead-' . ( ++ $ counter ) ; foreach ( $ data as & $ item ) { $ item = [ 'word' => $ item ] ; } $ this -> form -> getView ( ) -> registerJs ( "yii.gii.autocomplete($counter, " . Json :: htmlEncode ( $ data ) . ");" ) ; return $ this ; }
8807	public function set ( $ key , $ value , $ time = 0 ) { if ( is_array ( $ key ) ) { foreach ( $ key as $ k => $ v ) { setcookie ( $ k , $ v , ( $ time == 0 ? 0 : time ( ) + $ time ) , '/' ) ; $ _COOKIE [ $ k ] = $ v ; } } else { setcookie ( $ key , $ value , ( $ time == 0 ? 0 : time ( ) + $ time ) , '/' ) ; $ _COOKIE [ $ key ] = $ value ; } return ; }
7698	function MsPowerpoint_SlideIsIt ( $ FileName ) { $ this -> MsPowerpoint_InitSlideLst ( ) ; foreach ( $ this -> OpenXmlSlideLst as $ i => $ s ) { if ( $ FileName == $ s [ 'file' ] ) return true ; } return false ; }
11527	public function registerPackageHelpers ( ) { foreach ( $ this -> packageHelpers as $ helper ) { $ dashName = last ( explode ( '/' , $ helper ) ) ; $ underscoreName = str_replace ( '-' , '_' , $ dashName ) ; if ( in_array ( '*' , $ this -> packageInclude ) || in_array ( $ dashName , $ this -> packageInclude ) || in_array ( $ underscoreName , $ this -> packageInclude ) ) { require_once $ this -> replaceVariables ( $ this -> packageHelperPattern , compact ( 'dashName' , 'underscoreName' ) ) ; } } }
8090	static public function generate ( $ uid = 0 , $ hash = false ) { if ( $ uid ) { $ e_uid = self :: encode ( $ uid ) ; $ e_uid_length = strlen ( $ e_uid ) ; $ e_uid_length = str_pad ( $ e_uid_length , 2 , 0 , STR_PAD_LEFT ) ; $ e_uid_pos = rand ( 10 , 32 - $ e_uid_length - 1 ) ; if ( ! $ hash ) { $ hash = sha1 ( uniqid ( rand ( ) , true ) ) ; } $ code = $ e_uid_pos . $ e_uid_length ; $ code .= substr ( $ hash , 0 , $ e_uid_pos - strlen ( $ code ) ) ; $ code .= $ e_uid ; $ code .= substr ( $ hash , strlen ( $ code ) ) ; return $ code ; } else { return sha1 ( uniqid ( rand ( ) , true ) ) ; } }
12961	public function getDb ( ) { if ( is_null ( $ this -> db ) ) { if ( $ this -> getAccessType ( ) == 'mysqli' && function_exists ( 'mysqli_select_db' ) ) { $ this -> db = new Db \ Mysqli ( ) ; } else { if ( $ this -> getAccessType ( ) == 'pdo' && class_exists ( 'PDO' ) ) { $ this -> db = new Db \ Pdo ( ) ; } } if ( is_null ( $ this -> db ) ) { if ( class_exists ( 'PDO' ) ) { $ this -> db = new Db \ Pdo ( ) ; } elseif ( function_exists ( 'mysqli_select_db' ) ) { $ this -> db = new Db \ Mysqli ( ) ; } else { throw new DbException ( 'Database engine not available! Must be either PDO or mysqli' ) ; } } $ this -> db -> setCredentials ( $ this -> credentials ) ; } return $ this -> db ; }
6137	public function searchtotal ( Search $ search ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'search' => $ search ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/search/total' , $ parameters ) ; return $ result ; }
11960	public function reduce ( Closure $ fn , $ initial = null ) { return array_reduce ( $ this -> elements , $ fn , $ initial ) ; }
208	public static function select ( $ prompt , $ options = [ ] ) { top : static :: stdout ( "$prompt [" . implode ( ',' , array_keys ( $ options ) ) . ',?]: ' ) ; $ input = static :: stdin ( ) ; if ( $ input === '?' ) { foreach ( $ options as $ key => $ value ) { static :: output ( " $key - $value" ) ; } static :: output ( ' ? - Show help' ) ; goto top ; } elseif ( ! array_key_exists ( $ input , $ options ) ) { goto top ; } return $ input ; }
160	public function andHaving ( $ condition , $ params = [ ] ) { if ( $ this -> having === null ) { $ this -> having = $ condition ; } else { $ this -> having = [ 'and' , $ this -> having , $ condition ] ; } $ this -> addParams ( $ params ) ; return $ this ; }
3371	private function visitAssociation ( $ className , $ association = null ) { if ( null === $ association ) { if ( isset ( $ this -> visitedAssociations [ $ className ] ) ) { return false ; } $ this -> visitedAssociations [ $ className ] = [ ] ; return true ; } if ( isset ( $ this -> visitedAssociations [ $ className ] [ $ association ] ) ) { return false ; } if ( ! isset ( $ this -> visitedAssociations [ $ className ] ) ) { $ this -> visitedAssociations [ $ className ] = [ ] ; } $ this -> visitedAssociations [ $ className ] [ $ association ] = true ; return true ; }
3003	public function attachFile ( $ path , $ alias = null , $ cid = null ) { $ this -> smtp -> attach ( $ path , $ alias , $ cid ) ; }
2777	public function init ( string $ directory , array $ options = [ ] ) : GitWorkingCopy { $ git = $ this -> workingCopy ( $ directory ) ; $ git -> init ( $ options ) ; $ git -> setCloned ( true ) ; return $ git ; }
3817	private function fetchExisting ( $ table , $ parentId ) { $ this -> startSort = 0 ; $ this -> knownAttributes = [ ] ; $ alreadyExisting = $ this -> connection -> createQueryBuilder ( ) -> select ( '*' ) -> from ( $ table ) -> where ( 'pid=:pid' ) -> setParameter ( 'pid' , $ parentId ) -> orderBy ( 'sorting' ) -> execute ( ) ; foreach ( $ alreadyExisting -> fetchAll ( \ PDO :: FETCH_ASSOC ) as $ item ) { $ this -> knownAttributes [ $ item [ 'attr_id' ] ] = $ item ; $ this -> startSort = $ item [ 'sorting' ] ; } return $ this -> knownAttributes ; }
8245	protected function abortIfExpired ( $ id , $ userData ) { if ( isset ( $ userData [ 'pwreset' ] ) && $ userData [ 'pwreset' ] ) { $ this -> session -> addFlash ( "error" , "Please set a new password." ) ; $ this -> picoAuth -> getContainer ( ) -> get ( 'PasswordReset' ) -> startPasswordResetSession ( $ id ) ; $ this -> picoAuth -> redirectToPage ( "password_reset" ) ; } }
1342	public function getParameters ( ) : EncodingParametersInterface { if ( $ this -> parameters ) { return $ this -> parameters ; } return $ this -> parameters = $ this -> container -> make ( EncodingParametersInterface :: class ) ; }
10206	public function setReadOrder ( $ pValue ) { if ( $ pValue < 0 || $ pValue > 2 ) { $ pValue = 0 ; } if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'readOrder' => $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> readOrder = $ pValue ; } return $ this ; }
9000	private function fixDirectorySeparator ( $ path ) : string { $ path = str_replace ( "\\" , DIRECTORY_SEPARATOR , $ path ) ; $ path = str_replace ( "/" , DIRECTORY_SEPARATOR , $ path ) ; return $ path ; }
9779	private function expect ( $ target , Constraint $ constraint ) : self { assertThat ( $ target , $ this -> hasFlag ( 'negate' ) ? logicalNot ( $ constraint ) : $ constraint , $ this -> message ) ; return $ this ; }
8638	public function setOrderFeeAdjustmentList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'OrderFeeAdjustmentList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
7655	function AddAddress ( $ address , $ name = "" ) { $ cur = count ( $ this -> to ) ; $ this -> to [ $ cur ] [ 0 ] = trim ( $ address ) ; $ this -> to [ $ cur ] [ 1 ] = $ name ; }
894	public function getArguments ( Tokens $ tokens , $ openParenthesis , $ closeParenthesis ) { $ arguments = [ ] ; $ firstSensibleToken = $ tokens -> getNextMeaningfulToken ( $ openParenthesis ) ; if ( $ tokens [ $ firstSensibleToken ] -> equals ( ')' ) ) { return $ arguments ; } $ paramContentIndex = $ openParenthesis + 1 ; $ argumentsStart = $ paramContentIndex ; for ( ; $ paramContentIndex < $ closeParenthesis ; ++ $ paramContentIndex ) { $ token = $ tokens [ $ paramContentIndex ] ; $ blockDefinitionProbe = Tokens :: detectBlockType ( $ token ) ; if ( null !== $ blockDefinitionProbe && true === $ blockDefinitionProbe [ 'isStart' ] ) { $ paramContentIndex = $ tokens -> findBlockEnd ( $ blockDefinitionProbe [ 'type' ] , $ paramContentIndex ) ; continue ; } if ( $ token -> equals ( ',' ) ) { if ( $ tokens -> getNextMeaningfulToken ( $ paramContentIndex ) === $ closeParenthesis ) { break ; } $ arguments [ $ argumentsStart ] = $ paramContentIndex - 1 ; $ argumentsStart = $ paramContentIndex + 1 ; } } $ arguments [ $ argumentsStart ] = $ paramContentIndex - 1 ; return $ arguments ; }
10090	public function getUrl ( $ identifier , $ options = array ( ) ) { if ( ! $ identifier ) { $ identifier = null ; } else { $ identifier = $ this -> normalizeIdentifier ( $ identifier ) ; } $ options = $ this -> checkOptionsArray ( $ options ) ; $ https = $ this -> https ; if ( isset ( $ options [ 'https' ] ) ) { $ https = ( bool ) $ options [ 'https' ] ; } $ algorithm = $ this -> algorithm ; if ( isset ( $ options [ 'algorithm' ] ) ) { $ algorithm = $ this -> processAlgorithm ( $ options [ 'algorithm' ] ) ; } $ default = $ this -> default ; if ( isset ( $ options [ 'default' ] ) ) { $ default = $ this -> processDefault ( $ options [ 'default' ] ) ; } $ size = $ this -> size ; if ( isset ( $ options [ 'size' ] ) ) { $ size = $ this -> processSize ( $ options [ 'size' ] ) ; } $ identifierHash = $ this -> identifierHash ( $ identifier , $ algorithm ) ; $ domain = $ this -> domainGet ( $ identifier ) ; $ service = $ this -> srvGet ( $ domain , $ https ) ; $ protocol = $ https ? 'https' : 'http' ; $ params = array ( ) ; if ( $ size !== null ) { $ params [ 'size' ] = $ size ; } if ( $ default !== null ) { $ params [ 'default' ] = $ default ; } $ paramString = '' ; if ( count ( $ params ) > 0 ) { $ paramString = '?' . http_build_query ( $ params ) ; } $ url = $ protocol . '://' . $ service . '/avatar/' . $ identifierHash . $ paramString ; return $ url ; }
9443	public function setPackOptions ( Container $ app ) { foreach ( $ this -> packOptions as $ key => & $ value ) { $ key = $ this -> _ns ( $ key ) ; if ( isset ( $ app [ $ key ] ) ) { $ value = $ app [ $ key ] ; } } }
10950	private function xorTokens ( $ token1 , $ token2 ) { $ n1 = StringHelper :: byteLength ( $ token1 ) ; $ n2 = StringHelper :: byteLength ( $ token2 ) ; if ( $ n1 > $ n2 ) { $ token2 = str_pad ( $ token2 , $ n1 , $ token2 ) ; } elseif ( $ n1 < $ n2 ) { $ token1 = str_pad ( $ token1 , $ n2 , $ n1 === 0 ? ' ' : $ token1 ) ; } return $ token1 ^ $ token2 ; }
908	private function isShortArray ( Tokens $ tokens , $ index ) { if ( ! $ tokens [ $ index ] -> equals ( '[' ) ) { return false ; } static $ disallowedPrevTokens = [ ')' , ']' , '}' , '"' , [ T_CONSTANT_ENCAPSED_STRING ] , [ T_STRING ] , [ T_STRING_VARNAME ] , [ T_VARIABLE ] , [ CT :: T_ARRAY_SQUARE_BRACE_CLOSE ] , [ CT :: T_DYNAMIC_PROP_BRACE_CLOSE ] , [ CT :: T_DYNAMIC_VAR_BRACE_CLOSE ] , [ CT :: T_ARRAY_INDEX_CURLY_BRACE_CLOSE ] , ] ; $ prevToken = $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ index ) ] ; if ( $ prevToken -> equalsAny ( $ disallowedPrevTokens ) ) { return false ; } $ nextToken = $ tokens [ $ tokens -> getNextMeaningfulToken ( $ index ) ] ; if ( $ nextToken -> equals ( ']' ) ) { return true ; } return ! $ this -> isArrayDestructing ( $ tokens , $ index ) ; }
12425	public function getAuthorizerToken ( $ appId , $ refreshToken ) { $ params = [ 'component_appid' => $ this -> getAppId ( ) , 'authorizer_appid' => $ appId , 'authorizer_refresh_token' => $ refreshToken , ] ; return $ this -> parseJSON ( 'json' , [ self :: GET_AUTHORIZER_TOKEN , $ params ] ) ; }
12828	protected function registerCustomFunctions ( ) { $ functionList = $ this -> functionGenerator -> getFunctionList ( ) ; foreach ( $ functionList as $ function ) { if ( isset ( $ function [ 'name' ] ) && isset ( $ function [ 'callable' ] ) ) { $ twigFunction = new Twig_SimpleFunction ( $ function [ 'name' ] , $ function [ 'callable' ] ) ; $ this -> engine -> addFunction ( $ twigFunction ) ; } } }
859	public function isAllTokenKindsFound ( array $ tokenKinds ) { foreach ( $ tokenKinds as $ tokenKind ) { if ( empty ( $ this -> foundTokenKinds [ $ tokenKind ] ) ) { return false ; } } return true ; }
3658	public function handle ( EncodePropertyValueFromWidgetEvent $ event ) { if ( ( 'tl_metamodel_dca_combine' !== $ event -> getEnvironment ( ) -> getDataDefinition ( ) -> getName ( ) ) || ( 'rows' !== $ event -> getProperty ( ) ) ) { return ; } $ values = $ event -> getValue ( ) ; $ index = 0 ; $ time = time ( ) ; foreach ( array_keys ( $ values ) as $ key ) { $ values [ $ key ] [ 'sorting' ] = $ index ; $ values [ $ key ] [ 'tstamp' ] = $ time ; $ index += 128 ; } $ event -> setValue ( $ values ) ; }
2065	public function checkJumpTo ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ varValue == $ dc -> id ) { throw new Exception ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'circularReference' ] ) ; } return $ varValue ; }
12743	public function buildSlotMap ( ) { $ this -> slotmap -> reset ( ) ; foreach ( $ this -> pool as $ connectionID => $ connection ) { $ parameters = $ connection -> getParameters ( ) ; if ( ! isset ( $ parameters -> slots ) ) { continue ; } foreach ( explode ( ',' , $ parameters -> slots ) as $ slotRange ) { $ slots = explode ( '-' , $ slotRange , 2 ) ; if ( ! isset ( $ slots [ 1 ] ) ) { $ slots [ 1 ] = $ slots [ 0 ] ; } $ this -> slotmap -> setSlots ( $ slots [ 0 ] , $ slots [ 1 ] , $ connectionID ) ; } } }
4743	public function validateOptIn ( ) { $ optInValue = \ OxidEsales \ Eshop \ Core \ Registry :: getConfig ( ) -> getRequestParameter ( 'rvw_oegdproptin' ) ; if ( $ this -> isReviewOptInValidationRequired ( ) && ! $ optInValue ) { return false ; } return true ; }
1874	private function addComponents ( ContainerBuilder $ container ) : void { $ packages = $ container -> getDefinition ( 'assets.packages' ) ; $ context = new Reference ( 'contao.assets.assets_context' ) ; foreach ( Versions :: VERSIONS as $ name => $ version ) { if ( 0 !== strncmp ( 'contao-components/' , $ name , 18 ) ) { continue ; } $ serviceId = 'assets._package_' . $ name ; $ basePath = 'assets/' . substr ( $ name , 18 ) ; $ version = $ this -> createVersionStrategy ( $ container , $ version , $ name ) ; $ container -> setDefinition ( $ serviceId , $ this -> createPackageDefinition ( $ basePath , $ version , $ context ) ) ; $ packages -> addMethodCall ( 'addPackage' , [ $ name , new Reference ( $ serviceId ) ] ) ; } }
8231	public static function getItemByUrl ( $ items , $ url ) { if ( ! isset ( $ items ) ) { return null ; } if ( array_key_exists ( "/" . $ url , $ items ) ) { return $ items [ "/" . $ url ] ; } $ urlParts = explode ( "/" , trim ( $ url , "/" ) ) ; $ urlPartsLen = count ( $ urlParts ) ; while ( $ urlPartsLen > 0 ) { unset ( $ urlParts [ -- $ urlPartsLen ] ) ; $ subUrl = "/" . join ( "/" , $ urlParts ) ; if ( array_key_exists ( $ subUrl , $ items ) && ( ! isset ( $ items [ $ subUrl ] [ "recursive" ] ) || $ items [ $ subUrl ] [ "recursive" ] === true ) ) { return $ items [ $ subUrl ] ; } } return null ; }
444	public function trigger ( $ name , Event $ event = null ) { $ this -> ensureBehaviors ( ) ; $ eventHandlers = [ ] ; foreach ( $ this -> _eventWildcards as $ wildcard => $ handlers ) { if ( StringHelper :: matchWildcard ( $ wildcard , $ name ) ) { $ eventHandlers = array_merge ( $ eventHandlers , $ handlers ) ; } } if ( ! empty ( $ this -> _events [ $ name ] ) ) { $ eventHandlers = array_merge ( $ eventHandlers , $ this -> _events [ $ name ] ) ; } if ( ! empty ( $ eventHandlers ) ) { if ( $ event === null ) { $ event = new Event ( ) ; } if ( $ event -> sender === null ) { $ event -> sender = $ this ; } $ event -> handled = false ; $ event -> name = $ name ; foreach ( $ eventHandlers as $ handler ) { $ event -> data = $ handler [ 1 ] ; call_user_func ( $ handler [ 0 ] , $ event ) ; if ( $ event -> handled ) { return ; } } } Event :: trigger ( $ this , $ name , $ event ) ; }
11617	public function records ( $ startTime , $ endTime , $ page = 1 , $ pageSize = 10 ) { $ params = [ 'starttime' => is_numeric ( $ startTime ) ? $ startTime : strtotime ( $ startTime ) , 'endtime' => is_numeric ( $ endTime ) ? $ endTime : strtotime ( $ endTime ) , 'pageindex' => $ page , 'pagesize' => $ pageSize , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_RECORDS , $ params ] ) ; }
11811	protected function loadLocalObject ( ) { if ( $ this -> _isLoadingLocalObject ) { throw new RecursionException ( 'Ran into recursion while loading local object' ) ; } $ this -> _isLoadingLocalObject = true ; if ( isset ( $ this -> foreignObject ) && ! isset ( $ this -> _localObject ) ) { $ keyTranslation = $ this -> dataSource -> getKeyTranslation ( $ this -> foreignObject ) ; if ( ! empty ( $ keyTranslation ) && ( $ localObject = $ keyTranslation -> object ) ) { $ this -> localObject = $ localObject ; } } $ this -> _isLoadingLocalObject = false ; }
6010	public function setDateRange ( $ dateRange ) { if ( $ dateRange instanceof DateTimeRange ) { $ this -> dateRange = $ dateRange ; } elseif ( is_array ( $ dateRange ) ) { $ this -> dateRange = new DateTimeRange ( $ dateRange ) ; } else { $ this -> dateRange = null ; trigger_error ( 'Argument must be an object of class DateTimeRange. Data loss!' , E_USER_WARNING ) ; } return $ this ; }
11575	public function actionRegister ( ) { if ( ! $ this -> module -> enableRegistration ) { throw new NotFoundHttpException ; } $ model = \ Yii :: createObject ( RegistrationForm :: className ( ) ) ; $ this -> performAjaxValidation ( $ model ) ; if ( $ model -> load ( \ Yii :: $ app -> request -> post ( ) ) && $ model -> register ( ) ) { return $ this -> render ( '/message' , [ 'title' => \ Yii :: t ( 'user' , 'Your account has been created' ) , 'module' => $ this -> module , ] ) ; } return $ this -> render ( 'register' , [ 'model' => $ model , 'module' => $ this -> module , ] ) ; }
7488	public function append ( $ string ) { $ string = static :: convertString ( $ string , $ this -> encoding ) ; $ this -> string .= $ string ; return $ this ; }
5165	public function render ( DataBuilder $ data_builder , $ parameters , array $ data = [ ] ) { $ parameters = $ this -> castParameters ( $ parameters ) ; $ tm = new TemplateManager ( ) ; $ result = new Result ( ) ; try { $ bag = new Bag ( $ parameters ) ; $ bag -> set ( 'body' , $ tm -> renderRaw ( 'text/html' , strval ( $ bag -> get ( 'body' ) ) , $ data ) ) ; $ attachments = [ ] ; foreach ( ( array ) Yaml :: parse ( strval ( $ bag -> get ( 'attachments' ) ) ) as $ key => $ attachment ) { $ attachment = ( object ) $ attachment ; $ attachments [ $ key ] [ 'as' ] = strval ( $ tm -> renderRaw ( 'text/plain' , $ attachment -> as , $ data ) ) ; $ attachments [ $ key ] [ 'source' ] = strval ( $ tm -> renderRaw ( 'text/plain' , $ attachment -> source , $ data ) ) ; } $ bag -> set ( 'attachments' , $ attachments ) ; $ bag -> set ( 'recipients' , explode ( ',' , $ tm -> renderRaw ( 'text/plain' , strval ( $ bag -> get ( 'recipients' ) ) , $ data ) ) ) ; $ bag -> set ( 'subject' , $ tm -> renderRaw ( 'text/plain' , strval ( $ bag -> get ( 'subject' ) ) , $ data ) ) ; $ bag -> set ( 'sender' , $ tm -> renderRaw ( 'text/plain' , strval ( $ bag -> get ( 'sender' ) ) , $ data ) ) ; $ result -> setResources ( new Collection ( [ $ bag -> toArray ( ) ] ) ) ; } catch ( \ Twig_Error $ e ) { $ e = new Exceptions \ EmailSenderRenderException ( $ e -> getRawMessage ( ) . ' on line ' . $ e -> getTemplateLine ( ) ) ; $ result -> addErrors ( new Collection ( [ $ e ] ) ) ; } return $ result ; }
7734	private function isHydraOperation ( \ ReflectionMethod $ method ) { $ annotation = $ this -> annotationReader -> getMethodAnnotation ( $ method , 'ML\HydraBundle\Mapping\Operation' ) ; return null !== $ annotation ; }
1746	public function addEnclosure ( $ strFile , $ strUrl = null , $ strMedia = 'enclosure' ) { if ( $ strFile == '' || ! file_exists ( System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) . '/' . $ strFile ) ) { return ; } if ( $ strUrl === null ) { $ strUrl = Environment :: get ( 'base' ) ; } $ objFile = new File ( $ strFile ) ; $ this -> arrData [ 'enclosure' ] [ ] = array ( 'media' => $ strMedia , 'url' => $ strUrl . System :: urlEncode ( $ strFile ) , 'length' => $ objFile -> size , 'type' => $ objFile -> mime ) ; }
6193	protected function loadModels ( $ path ) { $ this -> app -> config [ 'model' ] = array_unique ( array_merge ( $ this -> app -> config [ 'model' ] ?? [ ] , $ path ) ) ; }
7347	static public function calculateDeliveryRemainingQuantity ( $ item ) { if ( $ item instanceof SupplierOrderItemInterface ) { return $ item -> getQuantity ( ) - static :: calculateReceivedQuantity ( $ item ) ; } if ( ! $ item instanceof SupplierDeliveryItemInterface ) { throw new InvalidArgumentException ( "Expected instance of " . SupplierOrderItemInterface :: class . " or " . SupplierDeliveryItemInterface :: class ) ; } $ orderItem = $ item -> getOrderItem ( ) ; $ result = $ orderItem -> getQuantity ( ) - static :: calculateReceivedQuantity ( $ orderItem ) ; if ( 0 < $ item -> getQuantity ( ) ) { $ result += $ item -> getQuantity ( ) ; } return $ result ; }
8659	private function convertGetFeedSubmissionCount ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetFeedSubmissionCount' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetFeedTypeList ( ) ) { $ feedTypeList = $ request -> getFeedTypeList ( ) ; foreach ( $ feedTypeList -> getType ( ) as $ typeIndex => $ type ) { $ parameters [ 'FeedTypeList' . '.' . 'Type' . '.' . ( $ typeIndex + 1 ) ] = $ type ; } } if ( $ request -> isSetFeedProcessingStatusList ( ) ) { $ feedProcessingStatusList = $ request -> getFeedProcessingStatusList ( ) ; foreach ( $ feedProcessingStatusList -> getStatus ( ) as $ statusIndex => $ status ) { $ parameters [ 'FeedProcessingStatusList' . '.' . 'Status' . '.' . ( $ statusIndex + 1 ) ] = $ status ; } } if ( $ request -> isSetSubmittedFromDate ( ) ) { $ parameters [ 'SubmittedFromDate' ] = $ this -> getFormattedTimestamp ( $ request -> getSubmittedFromDate ( ) ) ; } if ( $ request -> isSetSubmittedToDate ( ) ) { $ parameters [ 'SubmittedToDate' ] = $ this -> getFormattedTimestamp ( $ request -> getSubmittedToDate ( ) ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
3020	public function getBlogInfo ( $ blogName ) { $ path = $ this -> blogPath ( $ blogName , '/info' ) ; return $ this -> getRequest ( $ path , null , true ) ; }
6826	protected function getUnpaidAccountNumber ( CustomerGroupInterface $ group , string $ origin ) { foreach ( $ this -> accounts as $ account ) { if ( $ account -> getType ( ) !== AccountingTypes :: TYPE_UNPAID ) { continue ; } foreach ( $ account -> getCustomerGroups ( ) as $ g ) { if ( $ g -> getId ( ) === $ group -> getId ( ) ) { return $ account -> getNumber ( ) ; } } } foreach ( $ this -> accounts as $ account ) { if ( $ account -> getType ( ) !== AccountingTypes :: TYPE_UNPAID ) { continue ; } if ( 0 < $ account -> getCustomerGroups ( ) -> count ( ) ) { continue ; } return $ account -> getNumber ( ) ; } throw new LogicException ( sprintf ( "No unpaid account number configured for customer group '%s' (%s)" , $ group -> getName ( ) , $ origin ) ) ; }
10	private function getCurrentPackages ( $ installedRepo ) { if ( $ this -> locker -> isLocked ( ) ) { try { return $ this -> locker -> getLockedRepository ( true ) -> getPackages ( ) ; } catch ( \ RuntimeException $ e ) { return $ this -> locker -> getLockedRepository ( ) -> getPackages ( ) ; } } return $ installedRepo -> getPackages ( ) ; }
11798	public function setHtml ( $ html = '' , $ clear = false ) { if ( true === $ clear ) { $ this -> clear ( 'text' ) ; } $ this -> html .= Helper :: formatText ( $ html , 'ascii' ) ; return $ this ; }
7559	function select ( $ query = '*' , $ index = false , $ recursive = true , $ check_self = false ) { $ s = new $ this -> selectClass ( $ this , $ query , $ check_self , $ recursive ) ; $ res = $ s -> result ; unset ( $ s ) ; if ( is_array ( $ res ) && ( $ index === true ) && ( count ( $ res ) === 1 ) ) { return $ res [ 0 ] ; } elseif ( is_int ( $ index ) && is_array ( $ res ) ) { if ( $ index < 0 ) { $ index += count ( $ res ) ; } return ( $ index < count ( $ res ) ) ? $ res [ $ index ] : null ; } else { return $ res ; } }
8695	public static function format ( $ size , $ decimals = 2 , $ decPoint = '.' , $ thousandsSep = '' , $ unitSep = '' ) { $ output = $ unit = null ; foreach ( self :: getBinarySizes ( ) as $ unit => $ divider ) { $ output = $ size / $ divider ; if ( $ output < 1000 ) { break ; } } if ( null === $ output ) { throw new \ UnexpectedValueException ( "Unable to parse value: '{$size}'" ) ; } $ unit = $ unit === 'o' ? 'o' : ucfirst ( $ unit ) ; $ trimmed = rtrim ( rtrim ( number_format ( $ output , $ decimals , $ decPoint , $ thousandsSep ) , '0' ) , $ decPoint ) ; $ formatted = $ trimmed . $ unitSep . $ unit ; return str_replace ( ' ' , utf8_encode ( chr ( 160 ) ) , $ formatted ) ; }
12109	public function renamePage ( $ id , $ newName ) { $ this -> pages [ $ newName ] = $ this -> getPage ( $ id ) ; unset ( $ this -> pages [ $ id ] ) ; $ this -> persist ( ) ; }
674	private function normalizeTableRowData ( $ table , $ columns ) { if ( $ columns instanceof Query ) { return $ columns ; } if ( ( $ tableSchema = $ this -> db -> getSchema ( ) -> getTableSchema ( $ table ) ) !== null ) { $ columnSchemas = $ tableSchema -> columns ; foreach ( $ columns as $ name => $ value ) { if ( isset ( $ columnSchemas [ $ name ] ) && $ columnSchemas [ $ name ] -> type === Schema :: TYPE_BINARY && is_string ( $ value ) ) { $ columns [ $ name ] = new PdoValue ( $ value , \ PDO :: PARAM_LOB ) ; } } } return $ columns ; }
3173	protected function getRouteItemAssessmentItemRefs ( RunnerServiceContext $ context , RouteItem $ routeItem , & $ catSession ) { $ catService = $ this -> getServiceManager ( ) -> get ( CatService :: SERVICE_ID ) ; $ compilationDirectory = $ context -> getCompilationDirectory ( ) [ 'private' ] ; $ itemRefs = [ ] ; $ catSession = false ; if ( $ context -> isAdaptive ( $ routeItem -> getAssessmentItemRef ( ) ) ) { $ catSession = $ context -> getCatSession ( $ routeItem ) ; $ itemRefs = $ catService -> getAssessmentItemRefByIdentifiers ( $ compilationDirectory , $ context -> getShadowTest ( $ routeItem ) ) ; } else { $ itemRefs [ ] = $ routeItem -> getAssessmentItemRef ( ) ; } return $ itemRefs ; }
124	protected function getErrorMessage ( $ retval , $ file ) { switch ( $ retval ) { case ZipArchive :: ER_EXISTS : return sprintf ( "File '%s' already exists." , $ file ) ; case ZipArchive :: ER_INCONS : return sprintf ( "Zip archive '%s' is inconsistent." , $ file ) ; case ZipArchive :: ER_INVAL : return sprintf ( "Invalid argument (%s)" , $ file ) ; case ZipArchive :: ER_MEMORY : return sprintf ( "Malloc failure (%s)" , $ file ) ; case ZipArchive :: ER_NOENT : return sprintf ( "No such zip file: '%s'" , $ file ) ; case ZipArchive :: ER_NOZIP : return sprintf ( "'%s' is not a zip archive." , $ file ) ; case ZipArchive :: ER_OPEN : return sprintf ( "Can't open zip file: %s" , $ file ) ; case ZipArchive :: ER_READ : return sprintf ( "Zip read error (%s)" , $ file ) ; case ZipArchive :: ER_SEEK : return sprintf ( "Zip seek error (%s)" , $ file ) ; default : return sprintf ( "'%s' is not a valid zip archive, got error code: %s" , $ file , $ retval ) ; } }
6985	protected function createSaleContext ( SaleInterface $ sale ) : ContextInterface { $ context = $ this -> createContext ( ) ; if ( null !== $ group = $ sale -> getCustomerGroup ( ) ) { $ context -> setCustomerGroup ( $ group ) -> setBusiness ( $ group -> isBusiness ( ) ) ; } if ( null !== $ address = $ sale -> getInvoiceAddress ( ) ) { $ context -> setInvoiceCountry ( $ address -> getCountry ( ) ) ; } $ address = $ sale -> isSameAddress ( ) ? $ sale -> getInvoiceAddress ( ) : $ sale -> getDeliveryAddress ( ) ; if ( null !== $ address ) { $ context -> setDeliveryCountry ( $ address -> getCountry ( ) ) ; } if ( null !== $ currency = $ sale -> getCurrency ( ) ) { $ context -> setCurrency ( $ currency ) ; } if ( null !== $ mode = $ sale -> getVatDisplayMode ( ) ) { $ context -> setVatDisplayMode ( $ mode ) ; } if ( $ sale instanceof OrderInterface && null !== $ date = $ sale -> getCreatedAt ( ) ) { $ context -> setDate ( $ date ) ; } $ context -> setTaxExempt ( $ sale -> isTaxExempt ( ) ) ; if ( null !== $ customer = $ sale -> getCustomer ( ) ) { $ this -> fillFromCustomer ( $ context , $ customer ) ; } elseif ( $ this -> customerProvider -> hasCustomer ( ) ) { $ this -> fillFromCustomer ( $ context , $ this -> customerProvider -> getCustomer ( ) ) ; } $ this -> finalize ( $ context ) ; $ sale -> setContext ( $ context ) ; return $ context ; }
1713	protected function executePostActionsHook ( DataContainer $ dc ) { if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'executePostActions' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'executePostActions' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'executePostActions' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ this -> strAction , $ dc ) ; } } }
5246	public function get ( string $ path ) : string { if ( ! $ this -> isFile ( $ path ) ) { throw new RuntimeException ( 'File does not exist at path ' . $ path ) ; } return file_get_contents ( $ path ) ; }
4365	public function onErrorHighPri ( Event $ error ) { $ this -> throttleDataRead ( ) ; $ hash = $ error [ 'hash' ] ; $ error [ 'email' ] = ( $ error [ 'type' ] & $ this -> cfg [ 'emailMask' ] ) && $ error [ 'isFirstOccur' ] && $ this -> cfg [ 'emailTo' ] ; $ error [ 'stats' ] = array ( 'tsEmailed' => 0 , 'countSince' => 0 , 'emailedTo' => '' , ) ; if ( isset ( $ this -> throttleData [ 'errors' ] [ $ hash ] ) ) { $ stats = \ array_intersect_key ( $ this -> throttleData [ 'errors' ] [ $ hash ] , $ error [ 'stats' ] ) ; $ error [ 'stats' ] = \ array_merge ( $ error [ 'stats' ] , $ stats ) ; } return ; }
365	public function renderColumnGroup ( ) { foreach ( $ this -> columns as $ column ) { if ( ! empty ( $ column -> options ) ) { $ cols = [ ] ; foreach ( $ this -> columns as $ col ) { $ cols [ ] = Html :: tag ( 'col' , '' , $ col -> options ) ; } return Html :: tag ( 'colgroup' , implode ( "\n" , $ cols ) ) ; } } return false ; }
1873	private function addBundles ( ContainerBuilder $ container ) : void { $ packages = $ container -> getDefinition ( 'assets.packages' ) ; $ context = new Reference ( 'contao.assets.assets_context' ) ; if ( $ container -> hasDefinition ( 'assets._version_default' ) ) { $ version = new Reference ( 'assets._version_default' ) ; } else { $ version = new Reference ( 'assets.empty_version_strategy' ) ; } $ bundles = $ container -> getParameter ( 'kernel.bundles' ) ; $ meta = $ container -> getParameter ( 'kernel.bundles_metadata' ) ; foreach ( $ bundles as $ name => $ class ) { if ( ! is_dir ( $ meta [ $ name ] [ 'path' ] . '/Resources/public' ) ) { continue ; } $ packageVersion = $ version ; $ packageName = $ this -> getBundlePackageName ( $ name ) ; $ serviceId = 'assets._package_' . $ packageName ; $ basePath = 'bundles/' . preg_replace ( '/bundle$/' , '' , strtolower ( $ name ) ) ; if ( is_file ( $ meta [ $ name ] [ 'path' ] . '/Resources/public/manifest.json' ) ) { $ def = new ChildDefinition ( 'assets.json_manifest_version_strategy' ) ; $ def -> replaceArgument ( 0 , $ meta [ $ name ] [ 'path' ] . '/Resources/public/manifest.json' ) ; $ container -> setDefinition ( 'assets._version_' . $ packageName , $ def ) ; $ packageVersion = new Reference ( 'assets._version_' . $ packageName ) ; } $ container -> setDefinition ( $ serviceId , $ this -> createPackageDefinition ( $ basePath , $ packageVersion , $ context ) ) ; $ packages -> addMethodCall ( 'addPackage' , [ $ packageName , new Reference ( $ serviceId ) ] ) ; } }
10527	public function getValue ( ) { static $ ip = null ; if ( is_null ( $ ip ) ) { $ ip = $ this -> getIpAddressFromProxy ( ) ; if ( isset ( $ _SERVER [ 'REMOTE_ADDR' ] ) ) { $ ip = $ _SERVER [ 'REMOTE_ADDR' ] ; } } return $ ip ; }
2133	public static function persist ( $ strKey , $ varValue ) { $ objConfig = static :: getInstance ( ) ; if ( strncmp ( $ strKey , '$GLOBALS' , 8 ) !== 0 ) { $ strKey = "\$GLOBALS['TL_CONFIG']['$strKey']" ; } $ objConfig -> add ( $ strKey , $ varValue ) ; }
7820	public function store ( $ pipeline , array $ pipes ) { $ workflow = [ $ pipeline => $ pipes ] ; $ yaml = $ this -> parser -> dump ( $ workflow ) ; $ this -> files -> append ( $ this -> getSource ( ) , $ yaml ) ; }
9240	public function renderLanguageSwitcher ( ) { return $ this -> _View -> element ( $ this -> config ( 'element' ) , [ 'availableLanguages' => $ this -> config ( 'availableLanguages' ) , 'displayNames' => $ this -> config ( 'displayNames' ) , 'imageMapping' => $ this -> config ( 'imageMapping' ) , 'renderToggleButtonDisplayName' => $ this -> config ( 'renderToggleButtonDisplayName' ) ] ) ; }
6543	public function current ( ) { $ this -> prepareQuery ( ) ; if ( false !== current ( $ this -> idsArray ) ) { return current ( $ this -> idsArray ) ; } else { throw new PointerException ( 'Can\'t retrieve the current element' ) ; } }
2059	public function generateSitemap ( ) { $ objSession = Contao \ System :: getContainer ( ) -> get ( 'session' ) ; $ session = $ objSession -> get ( 'sitemap_updater' ) ; if ( empty ( $ session ) || ! \ is_array ( $ session ) ) { return ; } $ this -> import ( 'Contao\Automator' , 'Automator' ) ; foreach ( $ session as $ id ) { $ this -> Automator -> generateSitemap ( $ id ) ; } $ objSession -> set ( 'sitemap_updater' , null ) ; }
4566	public function getForms ( $ id ) { $ forms = [ ] ; $ form = $ this -> getForm ( $ id ) ; $ form -> setMethod ( 'POST' ) -> setPrimary ( true ) ; $ forms [ ] = $ form ; switch ( $ form -> getType ( ) ) { case Form :: TYPE_FORMIO : $ components = $ form -> getSchema ( ) ; $ resolverCollection = $ this -> resolverCollection ; $ extract = function ( & $ container , $ key , & $ component ) use ( & $ extract , & $ forms , $ resolverCollection ) { switch ( true ) { case property_exists ( $ component , 'components' ) : foreach ( $ component -> components as $ key => & $ subComponent ) { $ extract ( $ component -> components , $ key , $ subComponent ) ; } break ; case property_exists ( $ component , 'columns' ) : foreach ( $ component -> columns as & $ column ) { foreach ( $ column -> components as $ key => & $ subComponent ) { $ extract ( $ column -> components , $ key , $ subComponent ) ; } } break ; case property_exists ( $ component , 'properties' ) && is_object ( $ component -> properties ) && property_exists ( $ component -> properties , 'ds_form' ) : $ form = $ this -> getForm ( $ component -> properties -> ds_form ) ; $ data = [ ] ; if ( property_exists ( $ component , 'defaultValue' ) ) { try { $ data = $ resolverCollection -> resolve ( $ component -> defaultValue ) ; } catch ( UnresolvedException $ exception ) { $ data = [ ] ; } catch ( UnmatchedException $ exception ) { } } $ form -> setData ( $ data ) ; $ forms [ ] = $ form ; unset ( $ container [ $ key ] ) ; break ; } } ; foreach ( $ components as $ key => & $ component ) { $ extract ( $ components , $ key , $ component ) ; } $ form -> setSchema ( array_values ( $ components ) ) ; break ; case Form :: TYPE_SYMFONY : break ; default : throw new DomainException ( 'Form type does not exist.' ) ; } return $ forms ; }
10355	public function incrementAttempts ( ) { $ this -> cache -> add ( $ this -> key , 0 , $ this -> getExpiry ( ) ) ; $ this -> cache -> increment ( $ this -> key ) ; }
7941	public function setBootDevice ( $ domain , $ currentState , $ bootDevice ) { if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; $ domain = ( string ) $ domain ; if ( ! $ bootDevice ) throw new BadMethodCallException ( 'Parameter $bootDevice is missing.' ) ; $ bootDevice = ( string ) $ bootDevice ; $ payload = array ( 'bootId' => $ bootDevice , 'monitoring' => $ currentState -> monitoring , 'rootDevice' => $ currentState -> rootDevice ) ; try { $ r = $ this -> put ( 'dedicated/server/' . $ domain , array ( 'Content-Type' => 'application/json;charset=UTF-8' ) , json_encode ( $ payload ) ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new ServerException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
12570	public function previewNews ( $ message , $ to , $ by = self :: PREVIEW_BY_OPENID ) { return $ this -> preview ( self :: MSG_TYPE_NEWS , $ message , $ to , $ by ) ; }
8237	protected function configGenerationAction ( ParameterBag $ post ) { if ( ! $ this -> picoAuth -> isValidCSRF ( $ post -> get ( "csrf_token" ) ) ) { $ this -> picoAuth -> addOutput ( "installer_step" , 1 ) ; return ; } $ this -> picoAuth -> addOutput ( "installer_step" , 2 ) ; $ this -> outputModulesConfiguration ( $ post ) ; }
1170	protected function createProtectedCaller ( $ instance ) { $ closure = function ( $ method , $ args ) { $ callable = [ $ this , $ method ] ; return call_user_func_array ( $ callable , $ args ) ; } ; return $ closure -> bindTo ( $ instance , $ instance ) ; }
9895	private function convert ( $ token ) { if ( preg_match ( '/"([^"]|""){0,255}"/' , $ token ) ) { return $ this -> convertString ( $ token ) ; } elseif ( is_numeric ( $ token ) ) { return $ this -> convertNumber ( $ token ) ; } elseif ( preg_match ( '/^\$?([A-Ia-i]?[A-Za-z])\$?(\d+)$/' , $ token ) ) { return $ this -> convertRef2d ( $ token ) ; } elseif ( preg_match ( '/^' . self :: REGEX_SHEET_TITLE_UNQUOTED . '(\\:' . self :: REGEX_SHEET_TITLE_UNQUOTED . ')?\\!\$?[A-Ia-i]?[A-Za-z]\$?(\\d+)$/u' , $ token ) ) { return $ this -> convertRef3d ( $ token ) ; } elseif ( preg_match ( "/^'" . self :: REGEX_SHEET_TITLE_QUOTED . '(\\:' . self :: REGEX_SHEET_TITLE_QUOTED . ")?'\\!\\$?[A-Ia-i]?[A-Za-z]\\$?(\\d+)$/u" , $ token ) ) { return $ this -> convertRef3d ( $ token ) ; } elseif ( preg_match ( '/^(\$)?[A-Ia-i]?[A-Za-z](\$)?(\d+)\:(\$)?[A-Ia-i]?[A-Za-z](\$)?(\d+)$/' , $ token ) ) { return $ this -> convertRange2d ( $ token ) ; } elseif ( preg_match ( '/^' . self :: REGEX_SHEET_TITLE_UNQUOTED . '(\\:' . self :: REGEX_SHEET_TITLE_UNQUOTED . ')?\\!\$?([A-Ia-i]?[A-Za-z])?\$?(\\d+)\\:\$?([A-Ia-i]?[A-Za-z])?\$?(\\d+)$/u' , $ token ) ) { return $ this -> convertRange3d ( $ token ) ; } elseif ( preg_match ( "/^'" . self :: REGEX_SHEET_TITLE_QUOTED . '(\\:' . self :: REGEX_SHEET_TITLE_QUOTED . ")?'\\!\\$?([A-Ia-i]?[A-Za-z])?\\$?(\\d+)\\:\\$?([A-Ia-i]?[A-Za-z])?\\$?(\\d+)$/u" , $ token ) ) { return $ this -> convertRange3d ( $ token ) ; } elseif ( isset ( $ this -> ptg [ $ token ] ) ) { return pack ( 'C' , $ this -> ptg [ $ token ] ) ; } elseif ( preg_match ( '/^#[A-Z0\\/]{3,5}[!?]{1}$/' , $ token ) or $ token == '#N/A' ) { return $ this -> convertError ( $ token ) ; } elseif ( $ token == 'arg' ) { return '' ; } throw new WriterException ( "Unknown token $token" ) ; }
3988	public function getChildrenOf ( $ parentTable ) { $ inputScreens = array_filter ( $ this -> getInputScreens ( ) , function ( $ inputScreen ) use ( $ parentTable ) { return ( $ inputScreen [ 'meta' ] [ 'rendertype' ] === 'ctable' ) && ( $ inputScreen [ 'meta' ] [ 'ptable' ] === $ parentTable ) ; } ) ; return $ inputScreens ; }
6493	private function compareAcceptMediaTypeHeaders ( AcceptMediaTypeHeaderValue $ a , AcceptMediaTypeHeaderValue $ b ) : int { $ aQuality = $ a -> getQuality ( ) ; $ bQuality = $ b -> getQuality ( ) ; if ( $ aQuality < $ bQuality ) { return 1 ; } if ( $ aQuality > $ bQuality ) { return - 1 ; } $ aType = $ a -> getType ( ) ; $ bType = $ b -> getType ( ) ; $ aSubType = $ a -> getSubType ( ) ; $ bSubType = $ b -> getSubType ( ) ; if ( $ aType === '*' ) { if ( $ bType === '*' ) { return 0 ; } return 1 ; } if ( $ aSubType === '*' ) { if ( $ bSubType === '*' ) { return 0 ; } return 1 ; } if ( $ bType === '*' || $ bSubType === '*' ) { return - 1 ; } return 0 ; }
4098	public function config ( $ key , $ value = null ) { if ( is_array ( $ key ) ) $ this -> config = $ key + $ this -> config ; else { if ( $ value !== null ) $ this -> config [ $ key ] = $ value ; if ( ! isset ( $ this -> config [ $ key ] ) ) throw new \ Exception ( "Configuration key `type` is not set" ) ; return $ this -> config [ $ key ] ; } }
9397	protected function escape ( array $ options ) { $ results = [ ] ; foreach ( $ options as $ key => $ value ) { if ( ! in_array ( $ key , $ this -> safe ) ) { $ results [ $ key ] = escapeshellarg ( $ value ) ; } else { $ results [ $ key ] = $ value ; } } return $ results ; }
7844	public function device ( ? int $ id = null ) : ? array { if ( is_null ( $ id ) ) { $ id = $ this -> device ; } $ key = sprintf ( 'smsgatewayme.device.%s' , $ id ) ; $ device = Cache :: remember ( $ key , 3600 * 24 * 7 , function ( ) use ( & $ response , $ id ) { $ response = Request :: get ( $ this -> baseUrl . 'device/' . $ id ) ; if ( $ response -> code != 200 ) { if ( ! empty ( $ response -> body -> message ) ) { Log :: error ( $ response -> body -> message ) ; } } return $ response -> body ; } ) ; return [ 'code' => $ response -> code ?? 200 , 'message' => 'OK' , 'data' => $ device , ] ; }
12610	public function getParents ( ) { $ parents = [ ] ; foreach ( $ this -> _parents as $ key => $ parent ) { if ( ! $ parent -> active ) { continue ; } $ parents [ $ key ] = $ parent ; } return $ parents ; }
10122	private function writePrintHeaders ( ) { $ record = 0x002a ; $ length = 0x0002 ; $ fPrintRwCol = $ this -> printHeaders ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ fPrintRwCol ) ; $ this -> append ( $ header . $ data ) ; }
10433	protected function prepareServiceConfigs ( ContainerBuilder $ container , $ pipelineConfig , $ pipelineName ) { return array_merge ( $ pipelineConfig [ 'config' ] , [ 'doctrineManager' => $ pipelineConfig [ 'doctrineManager' ] , 'elasticsearchManager' => $ pipelineConfig [ 'elasticsearchManager' ] , 'sync_storage' => $ pipelineConfig [ 'sync_storage' ] , 'diff_provider' => $ pipelineConfig [ 'diff_provider' ] , 'extractor' => $ pipelineConfig [ 'extractor' ] , 'chunk_size' => $ pipelineConfig [ 'chunk_size' ] , 'shop' => $ pipelineConfig [ 'shop' ] , 'shop_id' => $ this -> getShopId ( $ container , $ pipelineConfig [ 'shop' ] , $ pipelineName ) , ] ) ; }
8832	public function tokenise ( $ pattern , $ expand = false ) { preg_match_all ( ' / (?<class_U_explicit>\\\U) \{ (?<class_U_repetition>[0-9]+) \} | (?<class_U_implicit>\\\U) | \[ (?<range_token_explicit>[^]]+) \] \{ (?<range_repetition>[0-9]+) \} | \[ (?<range_token_implicit>[^]]+) \] | (?<literal_string>[^\\\[]+) /x ' , $ pattern , $ matches , \ PREG_SET_ORDER ) ; $ tokens = [ ] ; foreach ( $ matches as $ match ) { if ( ! empty ( $ match [ 'class_U_explicit' ] ) ) { $ token = [ 'type' => 'class' , 'class' => static :: CLASS_UPPERCASE_UNAMBIGUOUS , 'repetition' => ( int ) $ match [ 'class_U_repetition' ] ] ; if ( $ expand ) { $ token [ 'haystack' ] = 'ABCDEFGHKMNOPRSTUVWXYZ23456789' ; } $ tokens [ ] = $ token ; } else if ( ! empty ( $ match [ 'class_U_implicit' ] ) ) { $ token = [ 'type' => 'class' , 'class' => static :: CLASS_UPPERCASE_UNAMBIGUOUS , 'repetition' => 1 ] ; if ( $ expand ) { $ token [ 'haystack' ] = 'ABCDEFGHKMNOPRSTUVWXYZ23456789' ; } $ tokens [ ] = $ token ; } else if ( ! empty ( $ match [ 'range_token_explicit' ] ) ) { $ token = [ 'type' => 'range' , 'token' => $ match [ 'range_token_explicit' ] , 'repetition' => ( int ) $ match [ 'range_repetition' ] ] ; if ( $ expand ) { $ token [ 'haystack' ] = static :: expandRange ( $ match [ 'range_token_explicit' ] ) ; } $ tokens [ ] = $ token ; } else if ( ! empty ( $ match [ 'range_token_implicit' ] ) ) { $ token = [ 'type' => 'range' , 'token' => $ match [ 'range_token_implicit' ] , 'repetition' => 1 ] ; if ( $ expand ) { $ token [ 'haystack' ] = static :: expandRange ( $ match [ 'range_token_implicit' ] ) ; } $ tokens [ ] = $ token ; } else if ( ! empty ( $ match [ 'literal_string' ] ) ) { $ tokens [ ] = [ 'type' => 'literal' , 'string' => $ match [ 'literal_string' ] ] ; } } return $ tokens ; }
2850	public function setTemplateHints ( $ status ) { $ this -> deleteTemplateHintsDbConfigs ( ) ; $ config = $ this -> getConfig ( ) ; $ config -> saveConfig ( 'dev/debug/template_hints' , ( int ) $ status ) ; $ config -> saveConfig ( 'dev/debug/template_hints_blocks' , ( int ) $ status ) ; }
5326	public function begin ( string $ profile ) { Craft :: beginProfile ( $ profile , Craft :: t ( 'twig-profiler' , self :: CATEGORY_PREFIX ) . TwigProfiler :: $ renderingTemplate ) ; }
11776	public function getHelper ( ) { if ( $ this -> helper === null ) { $ this -> helper = $ this -> command -> getHelper ( 'question' ) ; } return $ this -> helper ; }
6122	public function permissionGetNameById ( $ permid ) { foreach ( $ this -> permissionList ( ) as $ name => $ perm ) { if ( $ perm [ "permid" ] == $ permid ) { return new Ts3Exception ( $ name ) ; } } throw new Ts3Exception ( "invalid permission ID" , 0xA02 ) ; }
7320	public function diff ( AstroDate $ b ) { $ prec = 12 ; $ jd1 = $ this -> toJD ( $ prec ) ; $ jd2 = $ b -> toJD ( $ prec ) ; $ days = bcsub ( $ jd1 , $ jd2 , $ prec ) ; return Time :: days ( - 1 * $ days ) ; }
7431	public static function getInstance ( ) : MimeType { if ( null === self :: $ instance ) { self :: $ instance = new self ( ) ; } return self :: $ instance ; }
11247	public function getLast ( ) : array { $ sql = "select migration from {$this->table} as b where exists (select max(batch) from {$this->table} as a where b.batch = a.batch) order by migration desc" ; $ stmt = $ this -> pdo -> prepare ( $ sql ) ; $ stmt -> execute ( ) ; return $ stmt -> fetchAll ( PDO :: FETCH_COLUMN ) ; }
9180	final public function getViewSettings ( ) { $ rf = new \ ReflectionClass ( $ this ) ; $ this -> viewName = str_replace ( 'View' , '' , $ rf -> getShortName ( ) ) ; $ matches = array ( ) ; if ( preg_match ( "#@applyTo\((.*)\)#" , $ rf -> getDocComment ( ) , $ matches ) ) { $ params = array ( ) ; parse_str ( str_replace ( ',' , '&' , $ matches [ 1 ] ) , $ params ) ; if ( is_array ( $ params ) ) { foreach ( $ params as $ param => $ value ) { if ( $ param == 'controller' ) { $ this -> controllers = explode ( '|' , $ value ) ; } if ( $ param == 'action' ) { $ this -> actions = explode ( '|' , $ value ) ; } } } } return $ this ; }
12309	public function resetPasswordAction ( ) { if ( $ this -> cmsAuthentication ( ) -> hasIdentity ( ) ) { return $ this -> redirect ( ) -> toRoute ( $ this -> getOptions ( ) -> getDefaultUserRoute ( ) ) ; } if ( $ token = $ this -> params ( ) -> fromRoute ( 'token' ) ) { $ identity = $ this -> getUserService ( ) -> confirmPasswordReset ( $ token ) ; if ( $ identity instanceof ResponseInterface ) { return $ identity ; } elseif ( $ identity ) { $ viewModel = new ViewModel ( compact ( 'identity' ) ) ; $ viewModel -> setTemplate ( 'cms-user/authentication/reset-password-success' ) ; return $ viewModel ; } return $ this -> redirect ( ) -> toRoute ( ) ; } $ url = $ this -> url ( ) -> fromRoute ( ) ; $ prg = $ this -> prg ( $ url , true ) ; if ( $ prg instanceof ResponseInterface ) { return $ prg ; } $ post = $ prg ; $ form = $ this -> getUserService ( ) -> getResetPasswordForm ( ) ; $ form -> setAttribute ( 'action' , $ url ) ; if ( $ post && $ form -> setData ( $ post ) -> isValid ( ) ) { $ identity = $ this -> getUserService ( ) -> resetPassword ( $ form -> get ( 'identity' ) -> getValue ( ) ) ; if ( $ identity instanceof ResponseInterface ) { return $ identity ; } elseif ( $ identity ) { $ viewModel = new ViewModel ( compact ( 'identity' ) ) ; $ viewModel -> setTemplate ( 'cms-user/authentication/reset-password-warning' ) ; return $ viewModel ; } } return new ViewModel ( compact ( 'form' ) ) ; }
10853	public function setLimit ( $ num , $ offset = 0 ) { $ this -> limit = ( int ) $ num ; $ this -> offset = ( int ) $ offset ; }
12101	public function setAccept ( $ accept ) { $ this -> setTag ( 'accept' , $ accept ) ; if ( $ this -> getValidator ( ) ) { $ this -> getValidator ( ) -> setOption ( 'accept' , $ accept ) ; } }
5272	protected function translateOrderBy ( ) { $ build = array ( ) ; foreach ( $ this -> statements [ 'orders' ] as $ column => $ direction ) { if ( is_array ( $ direction ) ) { list ( $ column , $ direction ) = $ direction ; } if ( ! is_null ( $ direction ) ) { $ column .= ' ' . $ direction ; } $ build [ ] = $ column ; } return 'order by ' . join ( ', ' , $ build ) ; }
8022	public function addField ( $ title , $ value , $ short = false ) { $ this -> fields [ ] = [ 'title' => $ title , 'value' => $ value , 'short' => $ short ] ; }
671	public function run ( $ id ) { $ model = $ this -> findModel ( $ id ) ; if ( $ this -> checkAccess ) { call_user_func ( $ this -> checkAccess , $ this -> id , $ model ) ; } $ model -> scenario = $ this -> scenario ; $ model -> load ( Yii :: $ app -> getRequest ( ) -> getBodyParams ( ) , '' ) ; if ( $ model -> save ( ) === false && ! $ model -> hasErrors ( ) ) { throw new ServerErrorHttpException ( 'Failed to update the object for unknown reason.' ) ; } return $ model ; }
2272	public static function quoteIdentifier ( $ strName ) { static $ strQuoteCharacter = null ; if ( $ strQuoteCharacter === null ) { $ strQuoteCharacter = System :: getContainer ( ) -> get ( 'database_connection' ) -> getDatabasePlatform ( ) -> getIdentifierQuoteCharacter ( ) ; } if ( strncmp ( $ strName , $ strQuoteCharacter , 1 ) === 0 ) { return $ strName ; } if ( ! preg_match ( '/^[A-Za-z0-9_$.]+$/' , $ strName ) ) { return $ strName ; } return System :: getContainer ( ) -> get ( 'database_connection' ) -> quoteIdentifier ( $ strName ) ; }
1892	public function accept ( ) { if ( strncmp ( $ this -> current ( ) -> getFilename ( ) , '.' , 1 ) === 0 ) { return false ; } $ strPath = $ this -> current ( ) -> getPathname ( ) ; if ( is_file ( $ strPath ) ) { $ strPath = \ dirname ( $ strPath ) ; } $ objFolder = new Folder ( StringUtil :: stripRootDir ( $ strPath ) ) ; return ! $ objFolder -> isUnsynchronized ( ) ; }
9974	public function setBuiltInFormatCode ( $ pValue ) { if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'formatCode' => self :: builtInFormatCode ( $ pValue ) ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> builtInFormatCode = $ pValue ; $ this -> formatCode = self :: builtInFormatCode ( $ pValue ) ; } return $ this ; }
68	public function junction ( $ target , $ junction ) { if ( ! Platform :: isWindows ( ) ) { throw new \ LogicException ( sprintf ( 'Function %s is not available on non-Windows platform' , __CLASS__ ) ) ; } if ( ! is_dir ( $ target ) ) { throw new IOException ( sprintf ( 'Cannot junction to "%s" as it is not a directory.' , $ target ) , 0 , null , $ target ) ; } $ cmd = sprintf ( 'mklink /J %s %s' , ProcessExecutor :: escape ( str_replace ( '/' , DIRECTORY_SEPARATOR , $ junction ) ) , ProcessExecutor :: escape ( realpath ( $ target ) ) ) ; if ( $ this -> getProcess ( ) -> execute ( $ cmd , $ output ) !== 0 ) { throw new IOException ( sprintf ( 'Failed to create junction to "%s" at "%s".' , $ target , $ junction ) , 0 , null , $ target ) ; } clearstatcache ( true , $ junction ) ; }
6240	public static function getMimeFor ( string $ extension ) : ? string { $ extensions = static :: getExtensions ( ) ; if ( isset ( $ extensions [ $ extension ] ) ) { return $ extensions [ $ extension ] ; } return null ; }
941	public function getPath ( ) { if ( null === $ this -> path ) { $ filesystem = new Filesystem ( ) ; $ cwd = $ this -> cwd ; if ( 1 === \ count ( $ this -> options [ 'path' ] ) && '-' === $ this -> options [ 'path' ] [ 0 ] ) { $ this -> path = $ this -> options [ 'path' ] ; } else { $ this -> path = array_map ( static function ( $ path ) use ( $ cwd , $ filesystem ) { $ absolutePath = $ filesystem -> isAbsolutePath ( $ path ) ? $ path : $ cwd . \ DIRECTORY_SEPARATOR . $ path ; if ( ! file_exists ( $ absolutePath ) ) { throw new InvalidConfigurationException ( sprintf ( 'The path "%s" is not readable.' , $ path ) ) ; } return $ absolutePath ; } , $ this -> options [ 'path' ] ) ; } } return $ this -> path ; }
12978	protected function detectMetadataDriver ( $ dir , $ configPath ) { foreach ( ( array ) $ configPath as $ cPath ) { $ path = $ dir . DS . $ cPath . DS ; if ( ( $ files = glob ( $ path . '*.dcm.xml' ) ) && count ( $ files ) ) { return 'xml' ; } elseif ( ( $ files = glob ( $ path . '*.orm.xml' ) ) && count ( $ files ) ) { return 'simplified_xml' ; } elseif ( ( $ files = glob ( $ path . '*.dcm.yml' ) ) && count ( $ files ) ) { return 'yml' ; } elseif ( ( $ files = glob ( $ path . '*.orm.yml' ) ) && count ( $ files ) ) { return 'simplified_yml' ; } elseif ( ( $ files = glob ( $ path . '*.php' ) ) && count ( $ files ) ) { return 'php' ; } } if ( is_dir ( $ dir . DS . $ this -> getClassPath ( ) . $ this -> getObjectName ( ) ) ) { return 'annotation' ; } return false ; }
1118	public static function allLeaves ( ) { $ instance = new static ; $ grammar = $ instance -> getConnection ( ) -> getQueryGrammar ( ) ; $ rgtCol = $ grammar -> wrap ( $ instance -> getQualifiedRightColumnName ( ) ) ; $ lftCol = $ grammar -> wrap ( $ instance -> getQualifiedLeftColumnName ( ) ) ; return $ instance -> newQuery ( ) -> whereRaw ( $ rgtCol . ' - ' . $ lftCol . ' = 1' ) -> orderBy ( $ instance -> getQualifiedOrderColumnName ( ) ) ; }
5790	private function setDefaultValue ( $ columnDefault ) { if ( is_null ( $ columnDefault ) ) { $ this -> defaultValue = '' ; } else { switch ( $ this -> type ) { case 'character' : case 'character varying' : case 'text' : case 'USER-DEFINED' : $ parseColumnDefault = explode ( "'" , $ columnDefault ) ; $ this -> defaultValue = $ parseColumnDefault [ 1 ] ; break ; case 'boolean' : if ( $ columnDefault == 'true' ) { $ this -> defaultValue = Postgres :: BOOLEAN_TRUE ; } break ; default : $ this -> defaultValue = $ columnDefault ; } } }
8830	protected function getSelectedValue ( $ value , $ selected ) { if ( is_array ( $ selected ) ) { return in_array ( $ value , $ selected , true ) ? 'selected' : null ; } return ( ( string ) $ value == ( string ) $ selected ) ? 'selected' : null ; }
8691	public static function symlinkJQueryFileUpload ( Event $ event ) { $ IO = $ event -> getIO ( ) ; $ composer = $ event -> getComposer ( ) ; $ cmanager = new ComposerPathFinder ( $ composer ) ; $ ds = DIRECTORY_SEPARATOR ; $ options = [ 'targetSuffix' => self :: getTargetSuffix ( 'jquery-file-upload' ) , 'sourcePrefix' => "..{$ds}..{$ds}..{$ds}" , ] ; list ( $ symlinkTarget , $ symlinkName ) = $ cmanager -> getSymlinkFromComposer ( 'sidus/file-upload-bundle' , 'blueimp/jquery-file-upload' , $ options ) ; $ IO -> write ( 'Checking Symlink' , false ) ; if ( false === self :: checkSymlink ( $ symlinkTarget , $ symlinkName , true ) ) { $ IO -> write ( 'Creating Symlink: ' . $ symlinkName , false ) ; self :: createSymlink ( $ symlinkTarget , $ symlinkName ) ; } $ IO -> write ( '<info>OK</info>' ) ; }
8389	public function addLeftOuterJoin ( $ table , $ on ) { $ this -> leftOuterJoins [ ] = array ( 'table' => $ table , 'on' => ( $ on instanceof Condition ? $ on : new Condition ( $ on ) ) ) ; return $ this ; }
4667	public function setRenderView ( $ viewPath , $ params ) { $ this -> setViewEngines ( [ '.volt' => function ( $ view = null ) { $ volt = new Volt ( $ view ) ; $ volt -> setOptions ( [ 'compiledPath' => APP_PATH . '/cache/volt/' , 'compiledSeparator' => '_' , 'compileAlways' => ! $ this -> getDI ( ) -> get ( 'config' ) -> application -> production , ] ) ; return $ volt ; } ] ) ; $ view = $ this -> getView ( ) ; $ content = $ view -> render ( $ viewPath , $ params ) ; return $ content ; }
6746	public function getCatalogue ( $ locale = null ) { if ( $ this -> translator instanceof TranslatorBagInterface ) { return $ this -> translator -> getCatalogue ( $ locale ) ; } return null ; }
1113	protected function mapTreeRecursive ( array $ tree , $ parentKey = null , & $ affectedKeys = array ( ) ) { foreach ( $ tree as $ attributes ) { $ node = $ this -> firstOrNew ( $ this -> getSearchAttributes ( $ attributes ) ) ; $ data = $ this -> getDataAttributes ( $ attributes ) ; if ( ! is_null ( $ parentKey ) ) $ data [ $ node -> getParentColumnName ( ) ] = $ parentKey ; $ node -> fill ( $ data ) ; $ result = $ node -> save ( ) ; if ( ! $ result ) return false ; $ affectedKeys [ ] = $ node -> getKey ( ) ; if ( array_key_exists ( $ this -> getChildrenKeyName ( ) , $ attributes ) ) { $ children = $ attributes [ $ this -> getChildrenKeyName ( ) ] ; if ( count ( $ children ) > 0 ) { $ result = $ this -> mapTreeRecursive ( $ children , $ node -> getKey ( ) , $ affectedKeys ) ; if ( ! $ result ) return false ; } } } return true ; }
3484	public function withThreadId ( string $ threadId ) : Aps { $ cloned = clone $ this ; $ cloned -> threadId = $ threadId ; return $ cloned ; }
9053	private function recursiveMenuItemHandling ( Collection $ menuItems ) { $ data = [ ] ; foreach ( $ menuItems as $ menuItem ) { if ( ! in_array ( $ menuItem -> getId ( ) , $ this -> alreadySetIds ) ) { $ this -> alreadySetIds [ ] = $ menuItem -> getId ( ) ; $ itemNode = [ ] ; $ itemNode [ 'name' ] = $ menuItem -> getTitle ( ) ; $ itemNode [ 'url' ] = $ menuItem -> getTarget ( ) ; $ itemNode [ 'id' ] = $ this -> position ; $ itemNode [ 'persist_id' ] = $ menuItem -> getId ( ) ; if ( null === $ menuItem -> getParent ( ) ) { $ itemNode [ 'owner_type' ] = get_class ( $ this -> currentOwner ) ; $ itemNode [ 'owner_id' ] = $ this -> currentOwner -> getId ( ) ; } $ this -> position ++ ; if ( $ menuItem -> getChildren ( ) -> count ( ) > 0 ) { $ itemNode [ 'children' ] = $ this -> recursiveMenuItemHandling ( $ menuItem -> getChildren ( ) ) ; } $ data [ ] = $ itemNode ; } } return $ data ; }
9207	public function importTable ( Table $ Table , $ records , array $ options = [ ] ) { $ defaultOptions = [ 'checkRules' => true , 'checkExisting' => true , ] ; $ options = $ options + $ defaultOptions ; foreach ( $ records as $ record ) { $ action = ( $ record -> isNew ( ) ? 'Create' : 'Update' ) ; $ result = $ Table -> save ( $ record , $ options ) ; $ key = $ this -> findKey ( $ Table , $ record ) ; if ( $ result ) { $ this -> verbose ( "<success>{$Table->alias()} ({$key}): {$action} successful.</success>" ) ; } else { $ this -> quiet ( "<warning>{$Table->alias()} ({$key}): {$action} failed.</warning>" ) ; $ this -> printValidationErrors ( $ Table -> alias ( ) , $ this -> findKey ( $ Table , $ record ) , $ record -> errors ( ) ) ; } } }
1242	private static function determineActualValueToAssign ( $ class , $ property , $ value ) { if ( ! array_key_exists ( $ property , self :: $ properties [ $ class ] ) ) { return $ value ; } $ info = self :: propertyInfo ( $ class , $ property ) ; if ( $ info [ 'repeatable' ] && is_array ( $ value ) ) { $ values = [ ] ; foreach ( $ value as $ val ) { $ values [ ] = self :: actualValue ( $ info , $ val ) ; } return $ values ; } return self :: actualValue ( $ info , $ value ) ; }
4392	public function checkConfigBE ( array $ attributes ) { return array_merge ( parent :: checkConfigBE ( $ attributes ) , $ this -> checkConfig ( $ this -> beConfig , $ attributes ) ) ; }
1161	private function fakeRequiredIfData ( $ data , $ rule , $ parameters ) { if ( $ rule !== 'RequiredIf' ) { return ; } $ newData = $ data ; $ newData [ $ parameters [ 0 ] ] = $ parameters [ 1 ] ; $ this -> validator -> setData ( $ newData ) ; }
5596	public function invoke ( $ method ) { $ queue = $ this -> createErrorQueue ( ) ; set_error_handler ( 'SimpleTestErrorHandler' ) ; parent :: invoke ( $ method ) ; restore_error_handler ( ) ; $ queue -> tally ( ) ; }
1977	public function onPreviewUrlCreate ( PreviewUrlCreateEvent $ event ) : void { if ( ! $ this -> framework -> isInitialized ( ) || 'news' !== $ event -> getKey ( ) ) { return ; } $ request = $ this -> requestStack -> getCurrentRequest ( ) ; if ( null === $ request ) { throw new \ RuntimeException ( 'The request stack did not contain a request' ) ; } if ( 'tl_news' === $ request -> query -> get ( 'table' ) && ! $ request -> query -> has ( 'act' ) ) { return ; } if ( null === ( $ newsModel = $ this -> getNewsModel ( $ this -> getId ( $ event , $ request ) ) ) ) { return ; } $ event -> setQuery ( 'news=' . $ newsModel -> id ) ; }
5528	protected function createCodeForMethods ( $ methods ) { $ code = '' ; $ methods = array_merge ( $ methods , $ this -> reflection -> getMethods ( ) ) ; foreach ( $ methods as $ method ) { if ( $ this -> isConstructorOrDeconstructor ( $ method ) ) { continue ; } $ mock_reflection = new SimpleReflection ( $ this -> mock_base ) ; if ( in_array ( $ method , $ mock_reflection -> getMethods ( ) ) ) { continue ; } $ code .= ' ' . $ this -> reflection -> getSignature ( $ method ) ; if ( $ mock_reflection -> isAbstract ( ) ) { $ code .= ";\n" ; } else { $ code .= " {\n" ; $ code .= " return \$this->invoke(\"$method\", func_get_args());\n" ; $ code .= " }\n" ; } } return $ code ; }
8415	public function beginTransaction ( ) : bool { if ( $ this -> isConnected ( ) === false ) { $ this -> connect ( ) ; } ++ $ this -> transactionLevel ; if ( $ this -> transactionLevel == 1 ) { return $ this -> providerDatabase -> beginTransaction ( $ this -> GetMasterLink ( ) ) ; } return $ this -> providerDatabase -> savePoint ( $ this -> GetMasterLink ( ) , 'LEVEL' . ( $ this -> transactionLevel - 1 ) ) ; }
5264	public function put ( $ key , Model $ instance , array $ attributes = [ '*' ] ) { if ( $ attributes != [ '*' ] && $ this -> has ( $ key ) ) { $ instance = Model :: merge ( $ this -> cache [ $ key ] [ 'instance' ] , $ instance , $ attributes ) ; $ attributes = array_merge ( $ this -> cache [ $ key ] [ 'attributes' ] , $ attributes ) ; } $ this -> cache [ $ key ] = [ 'instance' => $ instance , 'attributes' => $ attributes ] ; return $ instance ; }
7263	protected function convert ( Model \ SaleInterface $ sale , float $ amount , string $ currency , bool $ round ) { if ( $ currency === $ this -> converter -> getDefaultCurrency ( ) ) { return $ round ? Money :: round ( $ amount , $ currency ) : $ amount ; } if ( null !== $ rate = $ sale -> getExchangeRate ( ) ) { return $ this -> converter -> convertWithRate ( $ amount , $ rate , $ currency , $ round ) ; } $ date = $ this -> contextProvider -> getContext ( $ sale ) -> getDate ( ) ; return $ this -> converter -> convert ( $ amount , $ this -> converter -> getDefaultCurrency ( ) , $ currency , $ date , $ round ) ; }
4528	public function postLoad ( Permission $ permission , LifecycleEventArgs $ event ) { $ item = $ this -> permissionCollection -> get ( $ permission -> getKey ( ) ) ; if ( ! $ item ) { throw new UnexpectedValueException ( 'Permission "' . $ permission -> getKey ( ) . '" does not exist.' ) ; } $ permission -> setType ( $ item -> getType ( ) ) -> setValue ( $ item -> getValue ( ) ) ; }
1322	private function parseHeaders ( $ header ) { $ headers = [ ] ; foreach ( explode ( "\r\n" , $ header ) as $ line ) { if ( strpos ( $ line , ':' ) !== false ) { list ( $ key , $ value ) = explode ( ': ' , $ line ) ; $ key = str_replace ( '-' , '_' , strtolower ( $ key ) ) ; $ headers [ $ key ] = trim ( $ value ) ; } } return $ headers ; }
516	public function actionMark ( $ version ) { $ originalVersion = $ version ; if ( ( $ namespaceVersion = $ this -> extractNamespaceMigrationVersion ( $ version ) ) !== false ) { $ version = $ namespaceVersion ; } elseif ( ( $ migrationName = $ this -> extractMigrationVersion ( $ version ) ) !== false ) { $ version = $ migrationName ; } elseif ( $ version !== static :: BASE_MIGRATION ) { throw new Exception ( "The version argument must be either a timestamp (e.g. 101129_185401)\nor the full name of a migration (e.g. m101129_185401_create_user_table)\nor the full name of a namespaced migration (e.g. app\\migrations\\M101129185401CreateUserTable)." ) ; } $ migrations = $ this -> getNewMigrations ( ) ; foreach ( $ migrations as $ i => $ migration ) { if ( strpos ( $ migration , $ version ) === 0 ) { if ( $ this -> confirm ( "Set migration history at $originalVersion?" ) ) { for ( $ j = 0 ; $ j <= $ i ; ++ $ j ) { $ this -> addMigrationHistory ( $ migrations [ $ j ] ) ; } $ this -> stdout ( "The migration history is set at $originalVersion.\nNo actual migration was performed.\n" , Console :: FG_GREEN ) ; } return ExitCode :: OK ; } } $ migrations = array_keys ( $ this -> getMigrationHistory ( null ) ) ; $ migrations [ ] = static :: BASE_MIGRATION ; foreach ( $ migrations as $ i => $ migration ) { if ( strpos ( $ migration , $ version ) === 0 ) { if ( $ i === 0 ) { $ this -> stdout ( "Already at '$originalVersion'. Nothing needs to be done.\n" , Console :: FG_YELLOW ) ; } else { if ( $ this -> confirm ( "Set migration history at $originalVersion?" ) ) { for ( $ j = 0 ; $ j < $ i ; ++ $ j ) { $ this -> removeMigrationHistory ( $ migrations [ $ j ] ) ; } $ this -> stdout ( "The migration history is set at $originalVersion.\nNo actual migration was performed.\n" , Console :: FG_GREEN ) ; } } return ExitCode :: OK ; } } throw new Exception ( "Unable to find the version '$originalVersion'." ) ; }
304	private function resetDependentRelations ( $ attribute ) { foreach ( $ this -> _relationsDependencies [ $ attribute ] as $ relation ) { unset ( $ this -> _related [ $ relation ] ) ; } unset ( $ this -> _relationsDependencies [ $ attribute ] ) ; }
1517	public function readRelationship ( StoreInterface $ store , FetchRelationship $ request ) { $ record = $ request -> getRecord ( ) ; $ result = $ this -> beforeReadingRelationship ( $ record , $ request ) ; if ( $ this -> isResponse ( $ result ) ) { return $ result ; } $ related = $ store -> queryRelationship ( $ record , $ request -> getRelationshipName ( ) , $ request -> getParameters ( ) ) ; $ records = ( $ related instanceof PageInterface ) ? $ related -> getData ( ) : $ related ; $ result = $ this -> afterReadingRelationship ( $ record , $ records , $ request ) ; if ( $ this -> isInvokedResult ( $ result ) ) { return $ result ; } return $ this -> reply ( ) -> relationship ( $ related ) ; }
7217	public function getDocumentationClassesList ( ) : array { $ classNames = $ this -> getCmfConfig ( ) -> config ( 'api_documentation.classes' , [ ] ) ; if ( empty ( $ classNames ) ) { $ classNames = $ this -> loadClassesFromFileSystem ( ) ; } return $ classNames ; }
283	private function findFixtures ( array $ fixtures = [ ] ) { $ fixturesPath = $ this -> getFixturePath ( ) ; $ filesToSearch = [ '*Fixture.php' ] ; $ findAll = ( $ fixtures === [ ] ) ; if ( ! $ findAll ) { $ filesToSearch = [ ] ; foreach ( $ fixtures as $ fileName ) { $ filesToSearch [ ] = $ fileName . 'Fixture.php' ; } } $ files = FileHelper :: findFiles ( $ fixturesPath , [ 'only' => $ filesToSearch ] ) ; $ foundFixtures = [ ] ; foreach ( $ files as $ fixture ) { $ foundFixtures [ ] = $ this -> getFixtureRelativeName ( $ fixture ) ; } return $ foundFixtures ; }
1229	private function expr ( $ rbp = 0 ) { $ left = $ this -> { "nud_{$this->token['type']}" } ( ) ; while ( $ rbp < self :: $ bp [ $ this -> token [ 'type' ] ] ) { $ left = $ this -> { "led_{$this->token['type']}" } ( $ left ) ; } return $ left ; }
6145	public function checkFragment ( $ fragment = null ) { if ( $ fragment === null ) { $ fragment = $ this -> fragment ; } if ( strlen ( $ fragment ) == 0 ) { return true ; } $ pattern = "/^" . $ this -> regex [ "uric" ] . "*$/" ; $ status = @ preg_match ( $ pattern , $ fragment ) ; if ( $ status === false ) { throw new Ts3Exception ( "URI fragment validation failed" ) ; } return ( $ status == 1 ) ; }
3314	protected function request ( $ url , $ images , array $ options = [ ] , $ requestType = false ) { $ http = ( new Http ) -> setHeaders ( [ 'Authorization' => $ this -> authorization -> getAuthorization ( ) ] ) ; $ image = is_array ( $ images ) ? $ images [ 0 ] : $ images ; $ urlName = $ requestType ? 'url_list' : 'url' ; if ( FileConverter :: isUrl ( $ image ) ) { $ isurl = true ; } else { $ isurl = false ; $ multiparts [ 'image' ] [ ] = $ image ; } $ options = $ this -> appendAppIdAndBucketIfEmpty ( $ options ) ; try { if ( $ isurl ) { $ response = $ http -> json ( $ url , array_merge ( $ options , [ $ urlName => $ image ] ) ) ; } else { $ response = $ http -> upload ( $ url , $ multiparts , $ options ) ; } } catch ( \ GuzzleHttp \ Exception \ ClientException $ e ) { if ( $ e -> hasResponse ( ) ) { $ response = $ e -> getResponse ( ) ; } } return $ http -> parseJson ( $ response ) ; }
4441	public function fromSubscriptions ( string $ topic ) : array { $ response = [ ] ; if ( empty ( $ topic ) ) { return $ response ; } $ subscriptions = $ this -> client -> call ( 'subscription' , 'default' , 'all' , $ topic ) ; $ subscriptions = json_decode ( $ subscriptions , true ) ? : [ ] ; foreach ( $ subscriptions as $ subscription => $ queues ) { $ topicPattern = str_replace ( [ '.' , '*' , '#' ] , [ '\.' , '[a-zA-z0-9^.]{1,}' , '.*' ] , $ subscription ) ; if ( preg_match ( "/^$topicPattern$/" , $ topic ) ) { $ response = array_merge ( $ response , $ queues ) ; } } return array_unique ( $ response ) ; }
4270	public function dir_rewinddir ( ) { if ( ! $ this -> handle ) { return false ; } self :: restorePrev ( ) ; \ rewinddir ( $ this -> handle ) ; self :: register ( ) ; return true ; }
8068	public function connect ( ) { $ port = $ this -> ssl ? $ this :: PORT_SSL : $ this :: PORT ; $ hostname = $ this -> domainController -> getHostname ( ) ; return $ this -> connection = ldap_connect ( $ hostname , $ port ) ; }
12019	function addProperties ( ) { $ requiredProperties = [ 'api' => '\\' . $ this -> apiClassname , 'parameters' => 'array' , 'response' => '\Amp\Artax\Response' , 'originalResponse' => '\Amp\Artax\Response' , ] ; foreach ( $ requiredProperties as $ propertyName => $ typehint ) { $ propertyGenerator = new PropertyGenerator ( $ propertyName , null ) ; $ docBlock = new DocBlockGenerator ( '@var ' . $ typehint ) ; $ propertyGenerator -> setDocBlock ( $ docBlock ) ; $ this -> classGenerator -> addPropertyFromGenerator ( $ propertyGenerator ) ; } $ docBlock = new DocBlockGenerator ( 'Get the last response.' ) ; $ body = 'return $this->response;' ; $ methodGenerator = $ this -> createMethodGenerator ( 'getResponse' , $ body , $ docBlock , [ ] , '\Amp\Artax\Response' ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; $ docBlock = new DocBlockGenerator ( 'Set the last response. This should only be used by the API class when the operation has been dispatched. Storing the response is required as some APIs store out-of-bound information in the headers e.g. rate-limit info, pagination that is not really part of the operation.' ) ; $ body = '$this->response = $response;' ; $ methodGenerator = $ this -> createMethodGenerator ( 'setResponse' , $ body , $ docBlock , [ [ 'response' , 'Amp\Artax\Response' ] ] ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; }
11136	protected function calculateINSERT ( ) { $ this -> query .= 'INSERT INTO ' ; $ this -> queryStringFromArray ( 'tables' , '' , ', ' ) ; if ( ! empty ( $ this -> inserts ) ) { $ this -> query .= ' (' ; $ this -> queryStringFromArray ( 'inserts' , '' , ', ' ) ; $ this -> query .= ')' ; } $ this -> valueStringFromArray ( 'values' , ' VALUES ' , ', ' ) ; }
1407	protected function getModelAttributes ( Model $ model ) { $ attributes = [ ] ; foreach ( $ this -> attributeKeys ( $ model ) as $ modelKey => $ field ) { if ( is_numeric ( $ modelKey ) ) { $ modelKey = $ field ; $ field = $ this -> fieldForAttribute ( $ field ) ; } $ attributes [ $ field ] = $ this -> extractAttribute ( $ model , $ modelKey , $ field ) ; } return $ attributes ; }
3633	public function pools ( Request $ request ) : array { if ( $ name = $ request -> query ( 'name' ) ) { if ( ! App :: hasPool ( $ name ) ) { return [ ] ; } $ poolConfig = App :: getPool ( $ name ) -> getPoolConfig ( ) ; return $ poolConfig -> toArray ( ) ; } return PoolCollector :: getCollector ( ) ; }
6028	public function setDeployedFiles ( array $ deployedFiles ) { $ this -> deployedFiles = [ ] ; foreach ( $ deployedFiles as $ item ) { $ this -> addDeploymentFile ( $ item ) ; } return $ this ; }
10909	public function inject ( string ... $ methods ) : Binding { if ( $ this -> definition -> injects === null ) { $ this -> definition -> injects = \ array_fill_keys ( $ methods , true ) ; } else { foreach ( $ methods as $ f ) { $ this -> definition -> injects [ $ f ] = true ; } } return $ this ; }
4760	public function updateStats ( $ stats , $ delta = 1 , $ sampleRate = 1 ) { if ( ! is_array ( $ stats ) ) { $ stats = array ( $ stats ) ; } $ data = array ( ) ; foreach ( $ stats as $ stat ) { $ data [ $ stat ] = "$delta|c" ; } $ this -> queue ( $ data , $ sampleRate ) ; }
10878	public function processForgotten ( string $ hash , string $ password ) : bool { $ decode = $ this -> getDecodeHash ( $ hash ) ; $ id = ( int ) $ decode [ 'id' ] ; $ verifyHash = $ decode [ 'verifyHash' ] ; $ item = $ this -> getById ( $ id ) ; if ( $ item && $ id == $ item [ 'id' ] ) { $ values [ 'hash' ] = $ this -> getHash ( $ password ) ; if ( $ this -> verifyHash ( $ item [ 'id' ] . $ item [ 'login' ] , $ verifyHash ) ) { return $ this -> update ( $ item [ 'id' ] , $ values ) ; } else { throw new IdentityException ( 'Invalid hash!' ) ; } } else { throw new IdentityException ( 'User does not exist!' ) ; } }
12852	protected static function symbol ( $ symbol ) { if ( $ symbol instanceof Symbol ) return [ $ symbol -> symbol , $ symbol -> package ] ; throw new \ UnexpectedValueException ( sprintf ( "Unexpected value of type '%s'." , is_object ( $ symbol ) ? get_class ( $ symbol ) : gettype ( $ symbol ) ) ) ; }
10612	public function confirmedAction ( ) { $ user = $ this -> getUser ( ) ; if ( ! is_object ( $ user ) || ! $ user instanceof UserInterface ) { throw $ this -> createAccessDeniedException ( 'This user does not have access to this section.' ) ; } return $ this -> render ( "@MikyUser/Frontend/Registration/confirmed.html.twig" , array ( 'user' => $ user , ) ) ; }
8261	protected function saveAfterLogin ( Request $ httpRequest ) { $ referer = $ httpRequest -> headers -> get ( "referer" , null , true ) ; $ afterLogin = Utils :: getRefererQueryParam ( $ referer , "afterLogin" ) ; if ( $ afterLogin && Utils :: isValidPageId ( $ afterLogin ) ) { $ this -> session -> set ( "afterLogin" , $ afterLogin ) ; } }
9520	public function getAliasUsage ( $ withEncapsulation = true ) { $ aliases = '' ; foreach ( $ this -> aliases as $ prefix => $ alias ) { if ( $ withEncapsulation ) { $ aliases = ( $ aliases == '' ) ? ' (' : $ aliases ; $ aliases .= ' ' . $ prefix . $ alias ; } else { $ aliases = ( $ aliases == '' ) ? $ prefix . $ alias : $ aliases . ', ' . $ prefix . $ alias ; } } if ( $ withEncapsulation ) { $ aliases .= ( $ aliases == '' ) ? '' : ' )' ; } return $ aliases ; }
7384	private function generateString ( ) { $ this -> generateNumbers ( ) ; $ this -> adjective = $ this -> adjectives [ $ this -> first ] ; $ this -> animal = $ this -> animals [ $ this -> second ] ; switch ( $ this -> case ) { case 'ucfirst' : $ this -> string = ucfirst ( $ this -> adjective . $ this -> animal . $ this -> number ) ; break ; case 'ucwords' : case 'sentence' : $ this -> string = ucfirst ( $ this -> adjective ) . ucfirst ( $ this -> animal ) . ucfirst ( $ this -> number ) ; break ; case 'camel' : $ this -> string = $ this -> adjective . ucfirst ( $ this -> animal ) . $ this -> number ; break ; default : $ this -> string = $ this -> adjective . $ this -> animal . $ this -> number ; break ; } }
9373	public function display ( ) { $ handler = new PrettyPageHandler ; error_reporting ( E_ALL ) ; $ this -> __call ( 'pushHandler' , array ( $ handler ) ) ; return $ this -> whoops -> register ( ) ; }
5220	public function contains ( $ path ) { $ realpath = realpath ( $ path ) ; if ( false === $ realpath ) { return false ; } return substr ( $ realpath , 0 , strlen ( $ this -> rootpath ) ) === $ this -> rootpath ; }
651	public function dropView ( $ viewName ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> dropView ( $ viewName ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ viewName ) ; }
6678	public static function getDateRangeText ( $ startDate , $ endDate , $ toSeparator = 'to' ) { if ( $ startDate == $ endDate ) { return self :: format ( $ startDate , DateFormat :: FORMAT_SHORT ) ; } elseif ( self :: format ( $ startDate , DateFormat :: FORMAT_YEAR ) == self :: format ( $ endDate , DateFormat :: FORMAT_YEAR ) ) { $ start_date = ( self :: format ( $ startDate , DateFormat :: FORMAT_MONTH ) == self :: format ( $ endDate , DateFormat :: FORMAT_MONTH ) ) ? self :: format ( $ startDate , DateFormat :: FORMAT_DAY ) : self :: format ( $ startDate , DateFormat :: FORMAT_SHORT_NO_YEAR ) ; } else { $ start_date = self :: format ( $ startDate , DateFormat :: FORMAT_SHORT ) ; } return $ start_date . ' ' . $ toSeparator . ' ' . self :: format ( $ endDate , DateFormat :: FORMAT_SHORT ) ; }
10865	protected function setInstProperty ( $ inst , $ propertyName , $ mappingDefinition , $ propertyValue = null ) { if ( $ mappingDefinition === false ) { return false ; } if ( func_num_args ( ) <= 3 ) { $ propertyValue = $ this -> $ propertyName ; } if ( $ mappingDefinition === true || is_string ( $ mappingDefinition ) ) { $ instPropertyName = $ mappingDefinition === true ? $ propertyName : $ mappingDefinition ; $ setInstPropertyMethod = 'setInstProperty' . ucfirst ( $ instPropertyName ) ; if ( method_exists ( $ this , $ setInstPropertyMethod ) ) { $ this -> $ setInstPropertyMethod ( $ propertyValue , $ inst ) ; return ; } else { $ instSetterMethod = 'set' . ucfirst ( $ instPropertyName ) ; if ( method_exists ( $ inst , $ instSetterMethod ) ) { $ inst -> $ instSetterMethod ( $ propertyValue ) ; return ; } else { $ inst -> $ instPropertyName = $ propertyValue ; return ; } } } elseif ( is_array ( $ mappingDefinition ) ) { if ( reset ( $ mappingDefinition ) === null ) { $ mappingDefinition [ 0 ] = $ inst ; call_user_func_array ( $ mappingDefinition , [ $ propertyValue ] ) ; return ; } elseif ( reset ( $ mappingDefinition ) === $ this ) { call_user_func_array ( $ mappingDefinition , [ $ propertyValue , $ inst ] ) ; return ; } } throw new \ yii \ base \ ErrorException ( 'Could not set property ' . $ propertyName . ' in wrapped object' ) ; }
10036	function getBlockedContacts ( $ standardFields = array ( ) , $ customFields = array ( ) , $ pageIndex = 1 , $ pageSize = 1000 ) { $ queryParameters = array ( 'standard_field' => $ standardFields , 'page_index' => $ pageIndex , 'page_size' => $ pageSize ) ; $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , 'custom_field' , $ customFields ) ; return $ this -> get ( 'contacts/blocked' , $ queryParameters ) ; }
10370	public static function add ( $ type , $ data = [ ] ) { $ is_admin = is_admin ( ) ; if ( self :: validate ( $ type , $ data , $ is_admin ) ) { $ hook = $ is_admin ? 'admin_enqueue_scripts' : 'wp_enqueue_scripts' ; $ method = __CLASS__ . "::add_{$type}s" ; if ( has_action ( $ hook , $ method ) === false ) { add_action ( $ hook , $ method ) ; } return true ; } return false ; }
1827	public function markModified ( $ strKey ) { if ( ! isset ( $ this -> arrModified [ $ strKey ] ) ) { $ this -> arrModified [ $ strKey ] = $ this -> arrData [ $ strKey ] ?? null ; } }
5894	public function retrieveAudioTemplate ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/templates/audiotemplate' , $ parameters , $ cachePolicy ) ; $ result = new AudioTemplate ( $ result ) ; return $ result ; }
12558	public function actionFlush ( $ category = null ) { if ( is_null ( $ category ) ) { $ category = $ this -> prompt ( "Category (blank for all): " ) ; } if ( empty ( $ category ) ) { $ category = 'all' ; } else { $ category = [ 'category' , $ category ] ; } Cacher :: invalidateGroup ( $ category ) ; $ this -> out ( "Done!" ) ; }
3984	private function addMenu ( & $ modules , $ section , $ name , $ module , Request $ request ) { if ( ! isset ( $ modules [ $ section ] ) ) { $ modules [ $ section ] = $ this -> buildBackendMenuSection ( $ section , $ request ) ; } $ active = $ this -> isActive ( $ module [ 'route' ] , $ module [ 'param' ] , $ request ) ; $ class = 'navigation ' . $ name ; if ( isset ( $ module [ 'class' ] ) ) { $ class .= ' ' . $ module [ 'class' ] ; } if ( $ active ) { $ class .= ' active' ; } if ( $ request -> query -> has ( 'ref' ) ) { $ module [ 'param' ] [ 'ref' ] = $ request -> query -> get ( 'ref' ) ; } $ modules [ $ section ] [ 'modules' ] [ $ name ] = [ 'label' => $ module [ 'label' ] , 'title' => $ module [ 'title' ] , 'class' => $ class , 'isActive' => $ active , 'href' => $ this -> urlGenerator -> generate ( $ module [ 'route' ] , $ module [ 'param' ] ) , ] ; }
5944	public function categories ( $ categoryIds , $ deploymentSiteIds = null , $ ignoreGrouping = false , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'deploymentSiteIds' => $ deploymentSiteIds , 'ignoreGrouping' => $ ignoreGrouping ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/filters/categories/' . $ categoryIds . '' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new FilterItem ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
6602	public function make ( $ key , $ secret ) { $ this -> credentials [ 'key' ] = $ key ; $ this -> credentials [ 'secret' ] = $ secret ; return $ this ; }
12248	public function xpathSingle ( $ strXpathQuery ) { $ arrResults = $ this -> xpath ( $ strXpathQuery ) ; if ( $ arrResults === false ) { return null ; } if ( is_array ( $ arrResults ) && count ( $ arrResults ) == 0 ) { return null ; } else { if ( count ( $ arrResults ) > 1 ) { throw new Exception ( 'xpathSingle expects a single element as result, got ' . count ( $ arrResults ) . ' elements instead.' ) ; } else { return current ( $ arrResults ) ; } } }
8634	public function setOrderChargeAdjustmentList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'OrderChargeAdjustmentList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
243	protected function renderAttribute ( $ attribute , $ index ) { if ( is_string ( $ this -> template ) ) { $ captionOptions = Html :: renderTagAttributes ( ArrayHelper :: getValue ( $ attribute , 'captionOptions' , [ ] ) ) ; $ contentOptions = Html :: renderTagAttributes ( ArrayHelper :: getValue ( $ attribute , 'contentOptions' , [ ] ) ) ; return strtr ( $ this -> template , [ '{label}' => $ attribute [ 'label' ] , '{value}' => $ this -> formatter -> format ( $ attribute [ 'value' ] , $ attribute [ 'format' ] ) , '{captionOptions}' => $ captionOptions , '{contentOptions}' => $ contentOptions , ] ) ; } return call_user_func ( $ this -> template , $ attribute , $ index , $ this ) ; }
7855	public function boot ( ) { $ this -> publishConfig ( ) ; $ this -> commands ( $ this -> commands ) ; $ facade = 'Cerbero\Workflow\Facades\Workflow' ; AliasLoader :: getInstance ( ) -> alias ( 'Workflow' , $ facade ) ; }
4504	public function item ( $ index ) { $ count = 0 ; foreach ( $ this as $ element ) { if ( $ index === $ count ) { return $ element ; } $ count ++ ; } return null ; }
6658	public function jsonSerialize ( ) { $ serialized = [ 'message' => $ this -> getPublicMessage ( ) , 'code' => $ this -> getCode ( ) , ] ; if ( $ this -> getPrevious ( ) instanceof $ this ) { $ previous = $ this -> getPrevious ( ) ; $ serialized [ 'previous' ] = $ previous -> jsonSerialize ( ) ; } return $ serialized ; }
6725	public static function getAccessToken ( ) { $ oauthClientParams = ArrayHelper :: getValue ( \ Yii :: $ app -> params , 'oauth' ) ; $ oauthClient = new Oauth2Client ( $ oauthClientParams ) ; $ code = $ oauthClient -> authorize ( ) ; $ token = $ oauthClient -> fetchAccessToken ( $ code ) ; $ accessToken = ArrayHelper :: getValue ( $ token , 'access_token' ) ; return $ accessToken ; }
10794	public function passwordRecovery ( array $ data ) { $ main = $ this -> getServiceLocator ( ) -> get ( 'neobazaar.service.main' ) ; $ userRepository = $ main -> getUserEntityRepository ( ) ; $ form = $ this -> getServiceLocator ( ) -> get ( 'user.form.passwordrecovery' ) ; $ form -> setData ( $ data ) ; if ( ! $ form -> isValid ( ) ) { throw new \ Exception ( serialize ( $ form -> getMessages ( ) ) ) ; } $ data = $ form -> getData ( ) ; $ email = isset ( $ data [ 'email' ] ) ? $ data [ 'email' ] : null ; $ user = $ userRepository -> findOneBy ( array ( 'email' => $ email ) ) ; if ( null === $ user ) { throw new \ Exception ( 'No user found' ) ; } $ userModel = $ this -> getServiceLocator ( ) -> get ( 'user.model.user' ) ; $ userModel -> init ( $ user , $ this -> getServiceLocator ( ) ) ; $ hash = $ userModel -> hashId . sha1 ( $ user -> getPassword ( ) ) ; $ url = $ this -> getServiceLocator ( ) -> get ( 'ControllerPluginManager' ) -> get ( 'Url' ) ; $ event = new PasswordRecoveryEvent ( __FUNCTION__ , null , array ( 'user' => $ user , 'form' => $ form , 'hash' => $ hash , 'email' => $ email , 'siteurl' => $ url -> fromRoute ( 'home' , array ( ) , array ( 'force_canonical' => true ) ) ) ) ; $ this -> getEventManager ( ) -> trigger ( __FUNCTION__ . '.pre' , $ this , $ event ) ; $ this -> getEventManager ( ) -> trigger ( __FUNCTION__ . '.post' , $ this , $ event ) ; return $ user ; }
3888	public function getAttributeNames ( \ DC_Table $ objDc ) { $ attributeNames = [ 'sorting' => $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'metamodels_sorting' ] , 'random' => $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'random' ] , 'id' => $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'id' ] [ 0 ] ] ; $ metaModelName = $ this -> factory -> translateIdToMetaModelName ( $ objDc -> activeRecord -> metamodel ) ; $ metaModel = $ this -> factory -> getMetaModel ( $ metaModelName ) ; if ( $ metaModel ) { foreach ( $ metaModel -> getAttributes ( ) as $ objAttribute ) { $ attributeNames [ $ objAttribute -> getColName ( ) ] = $ objAttribute -> getName ( ) ; } } return $ attributeNames ; }
12974	protected function autoLoadMappingInfo ( ) { $ mappings = array ( ) ; foreach ( \ Package :: loaded ( ) as $ package => $ path ) { $ mappings [ ] = $ package . '::package' ; } foreach ( \ Module :: loaded ( ) as $ module => $ path ) { $ mappings [ ] = $ module . '::module' ; } $ mappings [ ] = 'app' ; $ mappings = array_fill_keys ( $ mappings , array ( 'is_component' => true ) ) ; $ this -> setMappings ( $ mappings ) ; }
10456	protected function setItem ( ItemPipelineEvent $ event ) { $ tempItem = $ event -> getItem ( ) ; if ( ! $ tempItem instanceof $ this -> importItemClass ) { $ this -> log ( "Item provided is not an {$this->importItemClass}" , LogLevel :: ERROR ) ; return false ; } $ this -> importItem = $ tempItem ; return true ; }
896	private function findComparisonStart ( Tokens $ tokens , $ index ) { -- $ index ; $ nonBlockFound = false ; while ( 0 <= $ index ) { $ token = $ tokens [ $ index ] ; if ( $ token -> isGivenKind ( [ T_WHITESPACE , T_COMMENT , T_DOC_COMMENT ] ) ) { -- $ index ; continue ; } if ( $ this -> isOfLowerPrecedence ( $ token ) ) { break ; } $ block = Tokens :: detectBlockType ( $ token ) ; if ( null === $ block ) { -- $ index ; $ nonBlockFound = true ; continue ; } if ( $ block [ 'isStart' ] || ( $ nonBlockFound && Tokens :: BLOCK_TYPE_CURLY_BRACE === $ block [ 'type' ] ) ) { break ; } $ index = $ tokens -> findBlockStart ( $ block [ 'type' ] , $ index ) - 1 ; } return $ tokens -> getNextMeaningfulToken ( $ index ) ; }
7531	function toString ( $ attributes = true , $ recursive = true , $ content_only = false ) { if ( $ content_only ) { if ( is_int ( $ content_only ) ) { -- $ content_only ; } return $ this -> toString_content ( $ attributes , $ recursive , $ content_only ) ; } $ s = '<' . $ this -> tag ; if ( $ attributes ) { $ s .= $ this -> toString_attributes ( ) ; } if ( $ this -> self_close ) { $ s .= $ this -> self_close_str . '>' ; } else { $ s .= '>' ; if ( $ recursive ) { $ s .= $ this -> toString_content ( $ attributes ) ; } $ s .= '</' . $ this -> tag . '>' ; } return $ s ; }
5771	public function hasOneRole ( array $ roleIds ) : bool { foreach ( $ roleIds as $ roleId ) { if ( $ this -> hasRole ( ( int ) $ roleId ) ) { return true ; } } return false ; }
7902	protected function getFullFileName ( Provider $ provider ) { $ folder = $ this -> folder ? rtrim ( $ this -> folder , '/' ) . '/' : '' ; if ( $ this -> filename ) { $ filename = $ this -> filename ; } else { $ filename = md5 ( uniqid ( microtime ( true ) , true ) ) ; } return $ folder . $ filename . '.' . $ provider -> getExtension ( ) ; }
4083	public function getStandaloneInputScreens ( ) { $ result = array ( ) ; foreach ( array_keys ( $ this -> information ) as $ modelName ) { if ( $ this -> isInputScreenStandalone ( $ modelName ) ) { $ result [ ] = $ this -> getInputScreenDetails ( $ modelName ) ; } } return $ result ; }
8542	public function setPluralForm ( $ key , $ plural ) { if ( ! is_array ( $ plural ) ) $ plural = [ $ plural ] ; if ( ! $ this -> msgstr_plural ) $ this -> msgstr_plural = [ ] ; $ this -> msgstr_plural [ $ key ] = $ plural ; }
9627	protected function matchParams ( Route $ route , array $ params ) : bool { $ matchers = $ route -> getMatchers ( ) ; foreach ( $ params as $ name => $ value ) { if ( ! isset ( $ matchers [ $ name ] ) ) { continue ; } $ valueMatchers = $ matchers [ $ name ] ; foreach ( $ valueMatchers as $ matcher ) { if ( ! $ matcher ( $ value ) ) { $ this -> logger -> debug ( sprintf ( 'Value "%s" for param "%s" did not match criteria of matcher "%s"' , $ value , $ name , get_class ( $ matcher ) ) ) ; return false ; } } } return true ; }
1108	protected function validateDuplicates ( ) { return ( ! $ this -> duplicatesExistForColumn ( $ this -> node -> getQualifiedLeftColumnName ( ) ) && ! $ this -> duplicatesExistForColumn ( $ this -> node -> getQualifiedRightColumnName ( ) ) ) ; }
2564	public static function generateSomewhatRandomString ( $ length = 22 ) { $ chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz" ; srand ( ( double ) microtime ( ) * 1000000 ) ; $ i = 0 ; $ somewhatRandom = '' ; while ( $ i < $ length ) { $ num = rand ( ) % 60 ; $ tmp = substr ( $ chars , $ num , 1 ) ; $ somewhatRandom = $ somewhatRandom . $ tmp ; $ i ++ ; } return $ somewhatRandom ; }
498	public function applyTo ( $ path ) { $ pathMap = $ this -> pathMap ; if ( empty ( $ pathMap ) ) { if ( ( $ basePath = $ this -> getBasePath ( ) ) === null ) { throw new InvalidConfigException ( 'The "basePath" property must be set.' ) ; } $ pathMap = [ Yii :: $ app -> getBasePath ( ) => [ $ basePath ] ] ; } $ path = FileHelper :: normalizePath ( $ path ) ; foreach ( $ pathMap as $ from => $ tos ) { $ from = FileHelper :: normalizePath ( Yii :: getAlias ( $ from ) ) . DIRECTORY_SEPARATOR ; if ( strpos ( $ path , $ from ) === 0 ) { $ n = strlen ( $ from ) ; foreach ( ( array ) $ tos as $ to ) { $ to = FileHelper :: normalizePath ( Yii :: getAlias ( $ to ) ) . DIRECTORY_SEPARATOR ; $ file = $ to . substr ( $ path , $ n ) ; if ( is_file ( $ file ) ) { return $ file ; } } } } return $ path ; }
4267	public function dir_closedir ( ) { if ( ! $ this -> handle ) { return false ; } self :: restorePrev ( ) ; \ closedir ( $ this -> handle ) ; self :: register ( ) ; $ this -> handle = null ; return true ; }
6280	public function nextkey ( ) { if ( $ this -> keyIterPos >= $ this -> keyIterStop ) { return false ; } $ keyLen = $ this -> readInt31 ( $ this -> keyIterPos ) ; $ dataLen = $ this -> readInt31 ( $ this -> keyIterPos + 4 ) ; $ key = $ this -> read ( $ this -> keyIterPos + 8 , $ keyLen ) ; $ this -> keyIterPos += 8 + $ keyLen + $ dataLen ; return $ key ; }
12043	public function search ( $ query , & $ results = array ( ) ) { if ( ! empty ( $ query ) ) : $ words = explode ( ' ' , $ query ) ; foreach ( $ words as $ word ) { $ _results = $ this -> setListLookUpConditions ( "user_first_name" , $ word , 'OR' ) -> setListLookUpConditions ( "user_last_name" , $ word , 'OR' ) -> setListLookUpConditions ( "user_middle_name" , $ word , 'OR' ) -> setListLookUpConditions ( "user_name_id" , $ word , 'OR' ) ; } $ _results = $ this -> getObjectsList ( "user" ) ; $ rows = $ _results -> fetchAll ( ) ; $ members = array ( "filterid" => "users" , "title" => "People" , "results" => array ( ) ) ; foreach ( $ rows as $ member ) { $ photo = empty ( $ member [ 'user_photo' ] ) ? "" : "/system/object/{$member['user_photo']}/resize/170/170" ; $ members [ "results" ] [ ] = array ( "icon" => $ photo , "link" => "/member:{$member['user_name_id']}/profile/timeline" , "title" => $ this -> getFullName ( $ member [ 'user_first_name' ] , $ member [ 'user_middle_name' ] , $ member [ 'user_last_name' ] ) , "description" => "" , "type" => $ member [ 'object_type' ] , "user_name_id" => $ member [ 'user_name_id' ] ) ; } if ( ! empty ( $ members [ "results" ] ) ) $ results [ ] = $ members ; endif ; return true ; }
11553	public function dispatch ( DispatchConfirmationInterface $ dispatchConfirmation ) { try { $ event = new EventDispatchConfirmation ( $ dispatchConfirmation ) ; $ this -> eventDispatcher -> dispatch ( Events :: PRE_CONSIGNMENTS_DISPATCH , $ event ) ; $ adapter = $ this -> getAdapter ( $ dispatchConfirmation -> getConsignments ( ) -> first ( ) ) ; $ adapter -> dispatch ( $ dispatchConfirmation ) ; $ this -> dispatchConfirmationRepository -> saveDispatchConfirmation ( $ dispatchConfirmation ) ; foreach ( $ dispatchConfirmation -> getConsignments ( ) as $ consignment ) { $ consignment -> setDispatchConfirmation ( $ dispatchConfirmation ) ; $ previousStatus = $ consignment -> getStatus ( ) ; foreach ( $ consignment -> getParcels ( ) as $ parcel ) { $ parcel -> setStatus ( ConsignmentStatusList :: STATUS_DISPATCHED ) ; } $ consignment -> setStatus ( ConsignmentStatusList :: STATUS_DISPATCHED ) ; $ this -> consignmentRepository -> saveConsignment ( $ consignment ) ; $ this -> dispatchOnConsignmentStatusChange ( $ consignment , $ previousStatus ) ; } $ event = new EventDispatchConfirmation ( $ dispatchConfirmation ) ; $ this -> eventDispatcher -> dispatch ( Events :: POST_CONSIGNMENTS_DISPATCH , $ event ) ; } catch ( \ Exception $ e ) { throw new VendorAdapterException ( 'Error during consignments dispatching.' , null , $ e ) ; } }
11882	private function prepareFieldOptions ( CustomField $ customField , $ type ) { $ options = $ customField -> getOptions ( ) ; $ fieldOptions = array ( ) ; $ fieldOptions [ 'required' ] = False ; $ fieldOptions [ 'label' ] = $ this -> translatableStringHelper -> localize ( $ customField -> getName ( ) ) ; if ( $ options [ self :: MIN ] !== NULL ) { $ fieldOptions [ 'constraints' ] [ ] = new GreaterThanOrEqual ( array ( 'value' => $ options [ self :: MIN ] ) ) ; } if ( $ options [ self :: MAX ] !== NULL ) { $ fieldOptions [ 'constraints' ] [ ] = new LessThanOrEqual ( array ( 'value' => $ options [ self :: MAX ] ) ) ; } if ( $ type === 'number' ) { $ fieldOptions [ 'scale' ] = $ options [ self :: SCALE ] ; } if ( ! empty ( $ options [ self :: POST_TEXT ] ) ) { $ fieldOptions [ 'post_text' ] = $ options [ self :: POST_TEXT ] ; } return $ fieldOptions ; }
12137	public function update ( QuestionRequest $ request , Question $ question ) { try { $ request = $ request -> all ( ) ; $ attributes [ 'title' ] = $ request [ 'title' ] ; $ attributes [ 'question' ] = $ request [ 'question' ] ; $ attributes [ 'category_id' ] = $ request [ 'category_id' ] ; $ question -> update ( $ attributes ) ; return redirect ( '/discussion/' . $ request [ 'slug' ] ) ; } catch ( Exception $ e ) { return $ this -> response -> message ( $ e -> getMessage ( ) ) -> code ( 400 ) -> status ( 'error' ) -> url ( guard_url ( 'forum/question/' . $ question -> getRouteKey ( ) ) ) -> redirect ( ) ; } }
8319	public function matches ( $ regexp , $ message ) { if ( ! is_string ( $ regexp ) || ! is_string ( $ message ) ) { throw new \ InvalidArgumentException ( "Both arguments must be string." ) ; } $ this -> constraints [ ] = ( function ( Password $ str ) use ( $ regexp , $ message ) { if ( ! preg_match ( $ regexp , $ str ) ) { return $ message ; } else { return true ; } } ) ; return $ this ; }
2063	public function purgeSearchIndex ( Contao \ DataContainer $ dc ) { if ( ! $ dc -> id ) { return ; } $ objResult = $ this -> Database -> prepare ( "SELECT id FROM tl_search WHERE pid=?" ) -> execute ( $ dc -> id ) ; while ( $ objResult -> next ( ) ) { $ this -> Database -> prepare ( "DELETE FROM tl_search WHERE id=?" ) -> execute ( $ objResult -> id ) ; $ this -> Database -> prepare ( "DELETE FROM tl_search_index WHERE pid=?" ) -> execute ( $ objResult -> id ) ; } }
8203	protected function peekJob ( $ tube , $ state ) { $ peekMethod = 'peek' . ucfirst ( $ state ) ; try { return $ this -> getPheanstalk ( ) -> $ peekMethod ( $ tube ) ; } catch ( ServerException $ e ) { if ( $ this -> isNotFoundException ( $ e ) ) { return ; } throw $ e ; } }
6909	public function removeCopy ( Recipient $ copy ) { if ( $ this -> copies -> contains ( $ copy ) ) { $ this -> copies -> removeElement ( $ copy ) ; } return $ this ; }
992	public static function visitUsingRules ( Schema $ schema , TypeInfo $ typeInfo , DocumentNode $ documentNode , array $ rules ) { $ context = new ValidationContext ( $ schema , $ documentNode , $ typeInfo ) ; $ visitors = [ ] ; foreach ( $ rules as $ rule ) { $ visitors [ ] = $ rule -> getVisitor ( $ context ) ; } Visitor :: visit ( $ documentNode , Visitor :: visitWithTypeInfo ( $ typeInfo , Visitor :: visitInParallel ( $ visitors ) ) ) ; return $ context -> getErrors ( ) ; }
10387	public function newApp ( ) : ApplicationInterface { $ app = new CalgamoApplication ( $ this -> filesystem ) ; $ app -> requireModule ( CalgamoLogExceptionHandlerModule :: class ) ; $ app -> requireModule ( CalgamoRouterModule :: class ) ; $ app -> requireModule ( CalgamoDiModule :: class ) ; $ app -> requireModule ( Wa72SimpleLoggerModule :: class ) ; return $ app ; }
10759	public function set ( $ col , $ value = ClauseInterface :: NO_VALUE ) { if ( is_array ( $ col ) ) { return $ this -> setWithArrayData ( $ col ) ; } if ( ! isset ( $ this -> clause_set [ $ col ] ) ) { $ this -> clause_set [ $ col ] = true ; } if ( ClauseInterface :: NO_VALUE !== $ value ) { $ this -> clause_data [ $ this -> clause_rownum ] [ $ col ] = $ value ; } return $ this ; }
7714	function switchToRelative ( ) { $ this -> FindEndTag ( ) ; $ this -> rel_Txt = & $ this -> Txt ; $ this -> rel_PosBeg = $ this -> PosBeg ; $ this -> rel_Len = $ this -> GetLen ( ) ; $ src = $ this -> GetSrc ( ) ; $ this -> Txt = & $ src ; $ this -> _ApplyDiffToAll ( - $ this -> PosBeg ) ; }
4808	public function unschedule_specific_event ( $ timestamp = '' ) { if ( empty ( $ timestamp ) ) { $ timestamp = wp_next_scheduled ( $ this -> args [ 'name' ] , $ this -> args [ 'args' ] ) ; } wp_unschedule_event ( $ timestamp , $ this -> args [ 'name' ] , $ this -> args [ 'args' ] ) ; }
12220	public function exceptionHandler ( $ exception ) { $ request = ( isset ( $ this -> container [ 'latestRequest' ] ) ? $ this -> container [ 'latestRequest' ] : $ this -> container [ 'request' ] ) ; $ response = ( isset ( $ this -> container [ 'latestResponse' ] ) ? $ this -> container [ 'latestResponse' ] : $ this -> container [ 'response' ] ) ; if ( ! ( $ exception instanceof Exception ) ) { $ exception = new InternalServerError ( $ exception -> getMessage ( ) , $ exception -> getCode ( ) , $ exception -> getPrevious ( ) ) ; } $ this -> logException ( $ exception ) ; $ response = $ response -> withBody ( new Stream ( 'php://memory' , 'w+' ) ) ; $ response = $ response -> withStatus ( $ exception -> getStatusCode ( ) ) ; $ body = $ this -> prepareErrorBody ( $ exception ) ; $ response = $ response -> withUnserializedBody ( $ body ) ; $ this -> container [ 'pipeline' ] -> prepareErrorQueue ( ) ; $ this -> container [ 'pipeline' ] ( $ request , $ response ) ; }
8156	public function addPath ( $ path , $ namespace = self :: MAIN_NAMESPACE ) { $ this -> cache = $ this -> errorCache = array ( ) ; $ checkPath = $ this -> isAbsolutePath ( $ path ) ? $ path : $ this -> rootPath . $ path ; if ( ! is_dir ( $ checkPath ) ) { throw new Twig_Error_Loader ( sprintf ( 'The "%s" directory does not exist ("%s").' , $ path , $ checkPath ) ) ; } $ this -> paths [ $ namespace ] [ ] = rtrim ( $ path , '/\\' ) ; }
6609	public static function getIdByField ( $ field , $ value ) { $ result = self :: find ( ) -> where ( [ $ field => $ value ] ) -> limit ( 1 ) -> one ( ) ; return ( $ result ) ? $ result -> id : null ; }
6362	public function convert ( float $ duration , TimeUnit $ timeUnit ) : float { return $ duration * ( $ timeUnit -> inMicros / $ this -> inMicros ) ; }
11426	public function blacklist ( $ beginOpenid = null ) { $ params = [ 'begin_openid' => $ beginOpenid ] ; return $ this -> parseJSON ( 'json' , [ self :: API_GET_BLACK_LIST , $ params ] ) ; }
5173	public static function createArticle ( String $ title , string $ body , string $ source , string $ uniqueId , int $ typeId , int $ categoryId , string $ reporter , string $ lead , string $ tags , string $ publishedAt , int $ identifier ) : Article { return new Article ( $ title , $ body , $ source , $ uniqueId , $ typeId , $ categoryId , $ reporter , $ lead , $ tags , $ publishedAt , $ identifier ) ; }
3632	public function config ( Request $ request ) { if ( $ key = $ request -> query ( 'key' ) ) { return \ config ( $ key ) ; } return \ bean ( 'config' ) -> toArray ( ) ; }
92	protected static function validateSyntax ( $ json , $ file = null ) { $ parser = new JsonParser ( ) ; $ result = $ parser -> lint ( $ json ) ; if ( null === $ result ) { if ( defined ( 'JSON_ERROR_UTF8' ) && JSON_ERROR_UTF8 === json_last_error ( ) ) { throw new \ UnexpectedValueException ( '"' . $ file . '" is not UTF-8, could not parse as JSON' ) ; } return true ; } throw new ParsingException ( '"' . $ file . '" does not contain valid JSON' . "\n" . $ result -> getMessage ( ) , $ result -> getDetails ( ) ) ; }
4542	public function postFlush ( PostFlushEventArgs $ args ) { $ maps = $ args -> getEntityManager ( ) -> getUnitOfWork ( ) -> getIdentityMap ( ) ; foreach ( $ maps as $ entities ) { foreach ( $ entities as $ entity ) { if ( ! $ entity instanceof Parameter ) { continue ; } $ entity -> setValue ( unserialize ( $ entity -> getValue ( ) ) ) ; } } }
3048	public function init ( ) { $ sessionStateService = $ this -> getServiceManager ( ) -> get ( SessionStateService :: SERVICE_ID ) ; $ sessionStateService -> resumeSession ( $ this -> getTestSession ( ) ) ; $ this -> retrieveItemIndex ( ) ; }
10427	private function initShops ( ContainerBuilder $ container , array $ config ) { $ activeShop = ! empty ( $ config [ 'active_shop' ] ) ? $ config [ 'active_shop' ] : null ; if ( $ activeShop !== null && ! isset ( $ config [ 'shops' ] [ $ activeShop ] ) ) { throw new LogicException ( "Parameter 'ongr_connections.active_shop' must be set to one" . "of the values defined in 'ongr_connections.shops'." ) ; } $ container -> setParameter ( 'ongr_connections.active_shop' , $ activeShop ) ; $ container -> setParameter ( 'ongr_connections.shops' , $ config [ 'shops' ] ) ; $ container -> setDefinition ( 'ongr_connections.shop_service' , new Definition ( 'ONGR\ConnectionsBundle\Service\ShopService' , [ $ activeShop , $ config [ 'shops' ] , ] ) ) ; }
10926	private function renderCell ( $ columnNumber , $ value , $ filler , $ style = '' ) { $ output = [ ] ; $ width = $ this -> getWidth ( $ columnNumber ) ; $ output [ ] = $ filler ; while ( $ this -> length ( $ value ) < $ width ) { $ value .= $ filler ; } $ output [ ] = Style :: applyStyle ( $ value , $ style ) ; $ output [ ] = $ filler ; return implode ( '' , $ output ) ; }
5191	private function handleString ( $ str ) : string { return is_string ( $ str ) && strlen ( $ str ) > 0 && $ str !== null ? $ str : '' ; }
5471	private function getProperty ( $ name , $ object ) { $ reflection = new ReflectionObject ( $ object ) ; $ property = $ reflection -> getProperty ( $ name ) ; if ( method_exists ( $ property , 'setAccessible' ) ) { $ property -> setAccessible ( true ) ; } try { return $ property -> getValue ( $ object ) ; } catch ( ReflectionException $ e ) { return $ this -> getPrivatePropertyNoMatterWhat ( $ name , $ object ) ; } }
12316	public function editAction ( Request $ request , Category $ category ) { $ deleteForm = $ this -> createDeleteForm ( $ category ) ; $ editForm = $ this -> createForm ( 'BlogBundle\Form\CategoryType' , $ category ) ; $ editForm -> handleRequest ( $ request ) ; if ( $ editForm -> isSubmitted ( ) && $ editForm -> isValid ( ) ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ em -> persist ( $ category ) ; $ em -> flush ( ) ; $ this -> get ( 'session' ) -> getFlashBag ( ) -> add ( 'success' , 'category.edited' ) ; return $ this -> redirectToRoute ( 'blog_category_index' ) ; } return array ( 'entity' => $ category , 'edit_form' => $ editForm -> createView ( ) , 'delete_form' => $ deleteForm -> createView ( ) , ) ; }
4730	public static function transcode ( $ source , $ fromEncoding , $ toEncoding ) { if ( \ is_string ( $ source ) ) { switch ( ICONV_IMPL ) { case 'glibc' : return @ iconv ( $ fromEncoding , $ toEncoding . '//TRANSLIT,IGNORE' , $ source ) ; case 'libiconv' : default : return iconv ( $ fromEncoding , $ toEncoding . '//IGNORE//TRANSLIT' , $ source ) ; } } }
6998	protected function prepareRelatedRecord ( $ relationName , array $ relationRecordData , $ index = null ) { $ recordWithBackup = $ relationRecordData ; $ valueViewers = $ this -> getViewersForRelations ( ) ; foreach ( $ relationRecordData as $ columnName => $ value ) { $ viewerName = $ relationName . '.' . ( $ index === null ? '' : $ index . '.' ) . $ columnName ; if ( array_key_exists ( $ viewerName , $ valueViewers ) && $ valueViewers [ $ viewerName ] -> getRelation ( ) -> getName ( ) === $ relationName ) { $ recordWithBackup [ $ columnName ] = $ recordWithBackup [ '__' . $ columnName ] = $ value ; $ valueViewer = $ valueViewers [ $ viewerName ] ; if ( is_object ( $ valueViewer ) && method_exists ( $ valueViewer , 'convertValue' ) && ( ! method_exists ( $ valueViewer , 'isVisible' ) || $ valueViewer -> isVisible ( ) ) ) { $ recordWithBackup [ $ columnName ] = $ valueViewer -> convertValue ( $ recordWithBackup [ $ columnName ] , $ relationRecordData ) ; } } } return $ recordWithBackup ; }
4764	protected function validateDeliveryAddressOptIn ( ) { $ return = true ; $ optin = ( int ) $ this -> getRequestParameter ( 'oegdproptin_deliveryaddress' ) ; $ changeExistigAddress = ( int ) $ this -> getRequestParameter ( 'oegdproptin_changeDelAddress' ) ; $ addressId = $ this -> getRequestParameter ( 'oxaddressid' ) ; $ deliveryAddressData = $ this -> _getDelAddressData ( ) ; if ( \ OxidEsales \ Eshop \ Core \ Registry :: getConfig ( ) -> getConfigParam ( 'blOeGdprOptinDeliveryAddress' ) && ( ( null == $ addressId ) || ( '-1' == $ addressId ) || ( 1 == $ changeExistigAddress ) ) && ! empty ( $ deliveryAddressData ) && ( 1 !== $ optin ) ) { $ return = false ; } return $ return ; }
198	public function xSendFile ( $ filePath , $ attachmentName = null , $ options = [ ] ) { if ( $ attachmentName === null ) { $ attachmentName = basename ( $ filePath ) ; } if ( isset ( $ options [ 'mimeType' ] ) ) { $ mimeType = $ options [ 'mimeType' ] ; } elseif ( ( $ mimeType = FileHelper :: getMimeTypeByExtension ( $ filePath ) ) === null ) { $ mimeType = 'application/octet-stream' ; } if ( isset ( $ options [ 'xHeader' ] ) ) { $ xHeader = $ options [ 'xHeader' ] ; } else { $ xHeader = 'X-Sendfile' ; } $ disposition = empty ( $ options [ 'inline' ] ) ? 'attachment' : 'inline' ; $ this -> getHeaders ( ) -> setDefault ( $ xHeader , $ filePath ) -> setDefault ( 'Content-Type' , $ mimeType ) -> setDefault ( 'Content-Disposition' , $ this -> getDispositionHeaderValue ( $ disposition , $ attachmentName ) ) ; $ this -> format = self :: FORMAT_RAW ; return $ this ; }
9667	private function writeGradientFill ( XMLWriter $ objWriter , Fill $ pFill ) { $ objWriter -> startElement ( 'fill' ) ; $ objWriter -> startElement ( 'gradientFill' ) ; $ objWriter -> writeAttribute ( 'type' , $ pFill -> getFillType ( ) ) ; $ objWriter -> writeAttribute ( 'degree' , $ pFill -> getRotation ( ) ) ; $ objWriter -> startElement ( 'stop' ) ; $ objWriter -> writeAttribute ( 'position' , '0' ) ; $ objWriter -> startElement ( 'color' ) ; $ objWriter -> writeAttribute ( 'rgb' , $ pFill -> getStartColor ( ) -> getARGB ( ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'stop' ) ; $ objWriter -> writeAttribute ( 'position' , '1' ) ; $ objWriter -> startElement ( 'color' ) ; $ objWriter -> writeAttribute ( 'rgb' , $ pFill -> getEndColor ( ) -> getARGB ( ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; }
12580	public function previewVideoByName ( $ message , $ to ) { return $ this -> preview ( self :: MSG_TYPE_VIDEO , $ message , $ to , self :: PREVIEW_BY_NAME ) ; }
4609	protected function registerPlugin ( ) { $ view = $ this -> getView ( ) ; MultiSelectAsset :: register ( $ view ) ; $ id = $ this -> options [ 'id' ] ; $ options = $ this -> clientOptions !== false && ! empty ( $ this -> clientOptions ) ? Json :: encode ( $ this -> clientOptions ) : '' ; $ js = "jQuery('#$id').multiselect($options);" ; $ view -> registerJs ( $ js ) ; }
8414	public function getMasterLink ( ) { if ( $ this -> isConnected ( ) === false ) { $ this -> connect ( ) ; } if ( isset ( $ this -> servers [ 'all' ] ) === true ) { return $ this -> servers [ 'all' ] [ 'link' ] ; } return $ this -> servers [ 'write' ] [ 'link' ] ; }
12140	public static function get ( $ key , $ fallback = null ) { $ message = static :: provider ( ) -> get ( $ key , $ fallback ) ; static :: provider ( ) -> drop ( $ key ) ; return $ message ; }
10900	public function validate ( string $ method = 'save' ) : array { $ errors = [ ] ; foreach ( $ this -> getValidators ( ) [ $ method ] ?? [ ] as $ field => $ validator ) { try { $ validator -> setName ( $ field ) -> assert ( $ this -> get ( $ field ) ) ; } catch ( NestedValidationException $ e ) { $ errors [ $ field ] = $ e -> getMessages ( ) ; } } return $ errors ; }
5867	public static function getOrientation ( $ fileName ) { $ orientation = 1 ; $ metadata = static :: getMetadata ( $ fileName ) ; if ( isset ( $ metadata [ 'Orientation' ] ) ) { $ orientation = $ metadata [ 'Orientation' ] ; } return $ orientation ; }
8454	protected function downloadMediaFileFromURL ( $ fileUri , $ tempFileName ) { $ curl = curl_init ( ) ; curl_setopt ( $ curl , CURLOPT_URL , "$fileUri" ) ; curl_setopt ( $ curl , CURLOPT_USERAGENT , "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.11) Gecko/20071127 Firefox/2.0.0.11" ) ; curl_setopt ( $ curl , CURLOPT_RETURNTRANSFER , true ) ; curl_setopt ( $ curl , CURLOPT_HEADER , false ) ; curl_setopt ( $ curl , CURLOPT_NOBODY , false ) ; curl_setopt ( $ curl , CURLOPT_BUFFERSIZE , 1024 ) ; curl_setopt ( $ curl , CURLOPT_FILE , $ tempFileName ) ; curl_exec ( $ curl ) ; curl_close ( $ curl ) ; }
10641	public function andWhere ( $ column , $ op , $ value , $ isParam = true ) { $ this -> clauses [ ] = array ( "AND" , $ column , $ op , $ value , $ isParam ) ; return $ this ; }
9988	public function generateHTMLHeader ( $ pIncludeStyles = false ) { if ( $ this -> spreadsheet === null ) { throw new WriterException ( 'Internal Spreadsheet object not set to an instance of an object.' ) ; } $ properties = $ this -> spreadsheet -> getProperties ( ) ; $ html = '<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">' . PHP_EOL ; $ html .= '<html>' . PHP_EOL ; $ html .= ' <head>' . PHP_EOL ; $ html .= ' <meta http-equiv="Content-Type" content="text/html; charset=utf-8">' . PHP_EOL ; $ html .= ' <meta name="generator" content="PhpSpreadsheet, https://github.com/PHPOffice/PhpSpreadsheet">' . PHP_EOL ; if ( $ properties -> getTitle ( ) > '' ) { $ html .= ' <title>' . htmlspecialchars ( $ properties -> getTitle ( ) ) . '</title>' . PHP_EOL ; } if ( $ properties -> getCreator ( ) > '' ) { $ html .= ' <meta name="author" content="' . htmlspecialchars ( $ properties -> getCreator ( ) ) . '" />' . PHP_EOL ; } if ( $ properties -> getTitle ( ) > '' ) { $ html .= ' <meta name="title" content="' . htmlspecialchars ( $ properties -> getTitle ( ) ) . '" />' . PHP_EOL ; } if ( $ properties -> getDescription ( ) > '' ) { $ html .= ' <meta name="description" content="' . htmlspecialchars ( $ properties -> getDescription ( ) ) . '" />' . PHP_EOL ; } if ( $ properties -> getSubject ( ) > '' ) { $ html .= ' <meta name="subject" content="' . htmlspecialchars ( $ properties -> getSubject ( ) ) . '" />' . PHP_EOL ; } if ( $ properties -> getKeywords ( ) > '' ) { $ html .= ' <meta name="keywords" content="' . htmlspecialchars ( $ properties -> getKeywords ( ) ) . '" />' . PHP_EOL ; } if ( $ properties -> getCategory ( ) > '' ) { $ html .= ' <meta name="category" content="' . htmlspecialchars ( $ properties -> getCategory ( ) ) . '" />' . PHP_EOL ; } if ( $ properties -> getCompany ( ) > '' ) { $ html .= ' <meta name="company" content="' . htmlspecialchars ( $ properties -> getCompany ( ) ) . '" />' . PHP_EOL ; } if ( $ properties -> getManager ( ) > '' ) { $ html .= ' <meta name="manager" content="' . htmlspecialchars ( $ properties -> getManager ( ) ) . '" />' . PHP_EOL ; } if ( $ pIncludeStyles ) { $ html .= $ this -> generateStyles ( true ) ; } $ html .= ' </head>' . PHP_EOL ; $ html .= '' . PHP_EOL ; $ html .= ' <body>' . PHP_EOL ; return $ html ; }
10472	public function checkInItem ( $ item_id ) { $ request = new CheckInRequest ( $ this -> connector -> agency_id , $ item_id ) ; $ this -> emit ( 'request.checkin' , array ( $ item_id ) ) ; $ response = $ this -> post ( $ request ) ; return new CheckInResponse ( $ response ) ; }
7952	public function setReverseProperties ( $ ipblock , $ ip , $ reverse ) { if ( ! $ ipblock ) throw new BadMethodCallException ( 'Parameter $ipblock is missing.' ) ; if ( ! $ ip ) throw new BadMethodCallException ( 'Parameter $ip is missing.' ) ; $ payload = array ( 'ipReverse' => $ ip , 'reverse' => $ reverse ) ; try { $ r = $ this -> post ( 'ip/' . urlencode ( $ ipblock ) . '/reverse' , array ( 'Content-Type' => 'application/json;charset=UTF-8' ) , json_encode ( $ payload ) ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new IpException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
2132	public function add ( $ strKey , $ varValue ) { $ this -> markModified ( ) ; $ this -> arrData [ $ strKey ] = $ this -> escape ( $ varValue ) . ';' ; }
673	public function alterColumn ( $ table , $ column , $ type ) { $ columnName = $ this -> db -> quoteColumnName ( $ column ) ; $ tableName = $ this -> db -> quoteTableName ( $ table ) ; if ( preg_match ( '/^(DROP|SET|RESET)\s+/i' , $ type ) ) { return "ALTER TABLE {$tableName} ALTER COLUMN {$columnName} {$type}" ; } $ type = 'TYPE ' . $ this -> getColumnType ( $ type ) ; $ multiAlterStatement = [ ] ; $ constraintPrefix = preg_replace ( '/[^a-z0-9_]/i' , '' , $ table . '_' . $ column ) ; if ( preg_match ( '/\s+DEFAULT\s+(["\']?\w+["\']?)/i' , $ type , $ matches ) ) { $ type = preg_replace ( '/\s+DEFAULT\s+(["\']?\w+["\']?)/i' , '' , $ type ) ; $ multiAlterStatement [ ] = "ALTER COLUMN {$columnName} SET DEFAULT {$matches[1]}" ; } else { $ multiAlterStatement [ ] = "ALTER COLUMN {$columnName} DROP DEFAULT" ; } $ type = preg_replace ( '/\s+NOT\s+NULL/i' , '' , $ type , - 1 , $ count ) ; if ( $ count ) { $ multiAlterStatement [ ] = "ALTER COLUMN {$columnName} SET NOT NULL" ; } else { $ type = preg_replace ( '/\s+NULL/i' , '' , $ type ) ; $ multiAlterStatement [ ] = "ALTER COLUMN {$columnName} DROP NOT NULL" ; } if ( preg_match ( '/\s+CHECK\s+\((.+)\)/i' , $ type , $ matches ) ) { $ type = preg_replace ( '/\s+CHECK\s+\((.+)\)/i' , '' , $ type ) ; $ multiAlterStatement [ ] = "ADD CONSTRAINT {$constraintPrefix}_check CHECK ({$matches[1]})" ; } $ type = preg_replace ( '/\s+UNIQUE/i' , '' , $ type , - 1 , $ count ) ; if ( $ count ) { $ multiAlterStatement [ ] = "ADD UNIQUE ({$columnName})" ; } array_unshift ( $ multiAlterStatement , "ALTER COLUMN {$columnName} {$type}" ) ; return 'ALTER TABLE ' . $ tableName . ' ' . implode ( ', ' , $ multiAlterStatement ) ; }
4782	public function removeWidgetConfig ( string $ widgetId , array $ config = [ ] ) { foreach ( $ config as $ id => $ content ) { if ( isset ( $ this -> config [ $ widgetId ] [ $ id ] ) ) { unset ( $ this -> config [ $ widgetId ] [ $ id ] ) ; } } return $ this ; }
8770	protected function bindPathsInContainer ( ) { $ this -> instance ( 'path' , $ this -> path ( ) ) ; $ this -> instance ( 'path.base' , $ this -> basePath ( ) ) ; $ this -> instance ( 'path.lang' , $ this -> langPath ( ) ) ; $ this -> instance ( 'path.config' , $ this -> configPath ( ) ) ; $ this -> instance ( 'path.storage' , $ this -> storagePath ( ) ) ; $ this -> instance ( 'path.database' , $ this -> databasePath ( ) ) ; $ this -> instance ( 'path.cache' , $ this -> cachePath ( ) ) ; $ this -> instance ( 'path.public' , $ this -> publicPath ( ) ) ; }
5467	protected function findRealmFromUrl ( $ url ) { if ( ! isset ( $ this -> realms [ $ url -> getHost ( ) ] ) ) { return false ; } foreach ( $ this -> realms [ $ url -> getHost ( ) ] as $ name => $ realm ) { if ( $ realm -> isWithin ( $ url ) ) { return $ realm ; } } return false ; }
3992	public function decodeValue ( DecodePropertyValueForWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ metaModel = $ this -> getMetaModelFromModel ( $ event -> getModel ( ) ) ; $ values = Helper :: decodeLangArray ( $ event -> getValue ( ) , $ metaModel ) ; $ event -> setValue ( unserialize ( $ values ) ) ; }
11459	public function attachFile ( string $ sFileName , string $ sContent , string $ sType ) : bool { $ this -> _aAttachments [ ] = array ( "name" => $ sFileName , "content" => $ sContent , "type" => $ sType ) ; return true ; }
5562	protected function parse ( $ response , $ depth = 0 ) { $ page = $ this -> buildPage ( $ response ) ; if ( $ this -> ignore_frames || ! $ page -> hasFrames ( ) || ( $ depth > $ this -> maximum_nested_frames ) ) { return $ page ; } $ frameset = new SimpleFrameset ( $ page ) ; foreach ( $ page -> getFrameset ( ) as $ key => $ url ) { $ frame = $ this -> fetch ( $ url , new SimpleGetEncoding ( ) , $ depth + 1 ) ; $ frameset -> addFrame ( $ frame , $ key ) ; } return $ frameset ; }
11216	public static function setSingletonName ( $ method ) { if ( ! is_string ( $ method ) || empty ( $ method ) ) { return false ; } self :: $ singleton = $ method ; return true ; }
1352	protected function notAllowed ( string $ resourceType , string $ fields ) : Collection { $ fields = collect ( explode ( ',' , $ fields ) ) ; if ( ! $ this -> allowed -> has ( $ resourceType ) ) { return $ fields ; } $ allowed = $ this -> allowed -> get ( $ resourceType ) ; if ( is_null ( $ allowed ) ) { return collect ( ) ; } $ allowed = collect ( ( array ) $ allowed ) ; return $ fields -> reject ( function ( $ value ) use ( $ allowed ) { return $ allowed -> contains ( $ value ) ; } ) ; }
3465	public function post ( string $ route , callable $ controller ) : void { $ this -> register ( $ controller , Route :: post ( $ route ) ) ; }
11390	public function getStatus ( ) { if ( isset ( $ this -> _log ) ) { $ this -> _status = $ this -> log -> statusLog ; } elseif ( ! isset ( $ this -> _status ) ) { $ this -> _status = new Status ( $ this -> log ) ; } return $ this -> _status ; }
9832	public function setRevisionsPassword ( $ pValue , $ pAlreadyHashed = false ) { if ( ! $ pAlreadyHashed ) { $ pValue = PasswordHasher :: hashPassword ( $ pValue ) ; } $ this -> revisionsPassword = $ pValue ; return $ this ; }
3036	protected function persistCacheEntry ( $ key ) { $ success = true ; if ( isset ( $ this -> cache [ $ key ] ) ) { $ cache = $ this -> cache [ $ key ] ; switch ( $ cache [ 'state' ] ) { case self :: STATE_PENDING_WRITE : $ success = $ this -> getStorage ( ) -> set ( $ cache [ 'userId' ] , $ cache [ 'callId' ] , $ cache [ 'data' ] ) ; if ( ! $ success ) { throw new \ common_exception_Error ( 'Can\'t write into test runner state storage at ' . static :: class ) ; } $ this -> cache [ $ key ] [ 'state' ] = self :: STATE_ALIGNED ; break ; case self :: STATE_PENDING_DELETE : $ success = $ this -> getStorage ( ) -> del ( $ cache [ 'userId' ] , $ cache [ 'callId' ] ) ; if ( $ success ) { unset ( $ this -> cache [ $ key ] ) ; } break ; } } return $ success ; }
8560	public function setProduct ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'Product' ] [ 'FieldValue' ] = $ value ; return $ this ; }
5834	protected function setCode ( $ code ) { $ this -> code = $ code ; $ this -> statusText = $ code ; list ( $ this -> statusCode , ) = explode ( ' ' , $ code ) ; }
3997	protected function getItem ( $ metaModelIdOrName , $ mixDataId , $ intIdRenderSetting , $ strOutput = null ) { $ objMetaModel = $ this -> loadMetaModel ( $ metaModelIdOrName ) ; if ( $ objMetaModel == null ) { return false ; } if ( empty ( $ strOutput ) ) { $ strOutput = 'html5' ; } $ objMetaModelList = new ItemList ( ) ; $ objMetaModelList -> setServiceContainer ( $ this -> getServiceContainer ( ) ) -> setMetaModel ( $ objMetaModel -> get ( 'id' ) , $ intIdRenderSetting ) -> overrideOutputFormat ( $ strOutput ) ; $ arrIds = StringUtil :: trimsplit ( ',' , $ mixDataId ) ; foreach ( $ arrIds as $ intKey => $ intId ) { if ( ! $ this -> isPublishedItem ( $ objMetaModel , $ intId ) ) { unset ( $ arrIds [ $ intKey ] ) ; } } if ( count ( $ arrIds ) < 1 ) { return '' ; } $ objMetaModelList -> addFilterRule ( new StaticIdList ( $ arrIds ) ) ; return $ objMetaModelList -> render ( false , $ this ) ; }
12636	protected function getSandboxSignKey ( ) { if ( $ this -> sandboxSignKey ) { return $ this -> sandboxSignKey ; } $ cacheKey = 'sandbox_signkey.' . $ this -> merchant -> merchant_id . $ this -> merchant -> sub_merchant_id ; $ cache = $ this -> getCache ( ) ; $ this -> sandboxSignKey = $ cache -> fetch ( $ cacheKey ) ; if ( ! $ this -> sandboxSignKey ) { $ result = $ this -> request ( self :: API_SANDBOX_SIGN_KEY , [ ] ) ; if ( $ result -> return_code === 'SUCCESS' ) { $ cache -> save ( $ cacheKey , $ result -> sandbox_signkey , 24 * 3600 ) ; return $ this -> sandboxSignKey = $ result -> sandbox_signkey ; } throw new Exception ( $ result -> return_msg ) ; } return $ this -> sandboxSignKey ; }
3936	private function setWidgetType ( PropertyInterface $ property , $ propInfo ) { if ( null !== $ property -> getWidgetType ( ) || ! isset ( $ propInfo [ 'inputType' ] ) ) { return ; } $ property -> setWidgetType ( $ propInfo [ 'inputType' ] ) ; }
2846	public function getUrl ( $ path , array $ params = array ( ) ) { $ path = self :: MODULE_ROUTE . $ path ; $ params [ '_store' ] = $ this -> getRouteStoreId ( ) ; $ params [ '_nosid' ] = true ; return $ this -> _getUrl ( $ path , $ params ) ; }
4790	function insert_update ( array $ unique , array $ insert , array $ update = array ( ) ) { if ( ! $ update ) { $ update = $ insert ; } $ insert = $ unique + $ insert ; $ values = "(" . implode ( ", " , array_keys ( $ insert ) ) . ") VALUES " . $ this -> quote ( $ insert ) ; if ( $ this -> notORM -> driver == "mysql" ) { $ set = array ( ) ; if ( ! $ update ) { $ update = $ unique ; } $ quoteChar = $ this -> getQuoteChar ( ) ; foreach ( $ update as $ key => $ val ) { $ set [ ] = "{$quoteChar}{$key}{$quoteChar} = " . $ this -> quote ( $ val ) ; } return $ this -> insert ( "$values ON DUPLICATE KEY UPDATE " . implode ( ", " , $ set ) ) ; } else { $ connection = $ this -> notORM -> connection ; $ errorMode = $ connection -> getAttribute ( PDO :: ATTR_ERRMODE ) ; $ connection -> setAttribute ( PDO :: ATTR_ERRMODE , PDO :: ERRMODE_EXCEPTION ) ; try { $ return = $ this -> insert ( $ values ) ; $ connection -> setAttribute ( PDO :: ATTR_ERRMODE , $ errorMode ) ; return $ return ; } catch ( PDOException $ e ) { $ connection -> setAttribute ( PDO :: ATTR_ERRMODE , $ errorMode ) ; if ( $ e -> getCode ( ) == "23000" || $ e -> getCode ( ) == "23505" ) { if ( ! $ update ) { return 0 ; } $ clone = clone $ this ; $ return = $ clone -> where ( $ unique ) -> update ( $ update ) ; return ( $ return ? $ return + 1 : $ return ) ; } if ( $ errorMode == PDO :: ERRMODE_EXCEPTION ) { throw $ e ; } elseif ( $ errorMode == PDO :: ERRMODE_WARNING ) { trigger_error ( "PDOStatement::execute(): " . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } } return 0 ; }
9508	public function showByLevel ( Log $ log , $ level ) { $ this -> authorize ( LogViewerPolicy :: PERMISSION_SHOW ) ; if ( $ level == 'all' ) return redirect ( ) -> route ( 'admin::foundation.system.log-viewer.logs.show' , [ $ log -> date ] ) ; $ levels = $ this -> logViewer -> levelsNames ( ) ; $ entries = $ this -> logViewer -> entries ( $ log -> date , $ level ) -> paginate ( $ this -> perPage ) ; $ this -> addBreadcrumbRoute ( trans ( 'foundation::log-viewer.titles.logs-list' ) , 'admin::foundation.system.log-viewer.logs.list' ) ; $ this -> setTitle ( $ log -> date . ' | ' . ucfirst ( $ level ) ) ; $ this -> addBreadcrumbRoute ( $ log -> date , 'admin::foundation.system.log-viewer.logs.show' , [ $ log -> date ] ) ; $ this -> addBreadcrumb ( ucfirst ( $ level ) ) ; return $ this -> view ( 'admin.system.log-viewer.show' , compact ( 'log' , 'levels' , 'entries' , 'level' ) ) ; }
1617	public function column ( $ column , $ db = null ) { if ( $ this -> emulateExecution ) { return [ ] ; } return $ this -> executeScript ( $ db , 'Column' , $ column ) ; }
12467	public function renderFormAction ( $ id , Request $ request ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ entity = $ em -> getRepository ( 'ChillCustomFieldsBundle:CustomFieldsGroup' ) -> find ( $ id ) ; if ( ! $ entity ) { throw $ this -> createNotFoundException ( 'Unable to find CustomFieldsGroups entity.' ) ; } $ form = $ this -> createForm ( 'custom_field' , null , array ( 'group' => $ entity ) ) ; $ form -> add ( 'submit_dump' , 'submit' , array ( 'label' => 'POST AND DUMP' ) ) ; $ form -> add ( 'submit_render' , 'submit' , array ( 'label' => 'POST AND RENDER' ) ) ; $ form -> handleRequest ( $ request ) ; $ this -> get ( 'twig.loader' ) -> addPath ( __DIR__ . '/../Tests/Fixtures/App/app/Resources/views/' , $ namespace = 'test' ) ; if ( $ form -> isSubmitted ( ) ) { if ( $ form -> get ( 'submit_render' ) -> isClicked ( ) ) { return $ this -> render ( 'ChillCustomFieldsBundle:CustomFieldsGroup:render_for_test.html.twig' , array ( 'fields' => $ form -> getData ( ) , 'customFieldsGroup' => $ entity ) ) ; } var_dump ( $ form -> getData ( ) ) ; var_dump ( json_enccode ( $ form -> getData ( ) ) ) ; } return $ this -> render ( '@test/CustomField/simple_form_render.html.twig' , array ( 'form' => $ form -> createView ( ) ) ) ; }
3197	public function getRemainingExtraTime ( $ tags = null , $ maxTime = 0 , $ target = TimePoint :: TARGET_SERVER ) { return max ( 0 , $ this -> getExtraTime ( $ maxTime ) - $ this -> getConsumedExtraTime ( $ tags , $ maxTime , $ target ) ) ; }
4174	public function build ( ) { $ providers = $ this -> getProviders ( ) -> search ( ) ; $ facades = $ this -> getFacades ( ) -> search ( ) ; if ( ! ConfigFile :: instance ( $ providers , $ facades ) -> make ( ) ) { throw new ErrorException ( 'Unable to register providers and facades. Please report this incident at Qafeen/Manager' ) ; } $ this -> getResources ( ) -> publish ( $ providers [ 0 ] ) ; return $ this ; }
6382	public function readQuestions ( $ quizId ) { $ quizSlots = $ this -> readStoreRecords ( 'quiz_slots' , [ 'quizid' => $ quizId ] ) ; $ questions = [ ] ; foreach ( $ quizSlots as $ index => $ quizSlot ) { try { $ question = $ this -> readStoreRecord ( 'question' , [ 'id' => $ quizSlot -> questionid ] ) ; $ question -> answers = $ this -> readStoreRecords ( 'question_answers' , [ 'question' => $ question -> id ] ) ; $ question -> url = $ this -> cfg -> wwwroot . '/mod/question/question.php?id=' . $ question -> id ; if ( $ question -> qtype == 'numerical' ) { $ question -> numerical = ( object ) [ 'answers' => $ this -> readStoreRecords ( 'question_numerical' , [ 'question' => $ question -> id ] ) , 'options' => $ this -> readStoreRecord ( 'question_numerical_options' , [ 'question' => $ question -> id ] ) , 'units' => $ this -> readStoreRecords ( 'question_numerical_units' , [ 'question' => $ question -> id ] ) ] ; } else if ( $ question -> qtype == 'match' ) { $ question -> match = ( object ) [ 'options' => $ this -> readStoreRecord ( 'qtype_match_options' , [ 'questionid' => $ question -> id ] ) , 'subquestions' => $ this -> readStoreRecords ( 'qtype_match_subquestions' , [ 'questionid' => $ question -> id ] ) ] ; } else if ( strpos ( $ question -> qtype , 'calculated' ) === 0 ) { $ question -> calculated = ( object ) [ 'answers' => $ this -> readStoreRecords ( 'question_calculated' , [ 'question' => $ question -> id ] ) , 'options' => $ this -> readStoreRecord ( 'question_calculated_options' , [ 'question' => $ question -> id ] ) ] ; } else if ( $ question -> qtype == 'shortanswer' ) { $ question -> shortanswer = ( object ) [ 'options' => $ this -> readStoreRecord ( 'qtype_shortanswer_options' , [ 'questionid' => $ question -> id ] ) ] ; } $ questions [ $ question -> id ] = $ question ; } catch ( \ Exception $ e ) { } } return $ questions ; }
12912	public function join ( BaseManager $ manager , $ type = null , $ column = null , $ column_right = null ) { $ this -> joins [ $ manager -> table ] = array ( 'manager' => $ manager , 'type' => $ type , 'column' => $ column , 'column_right' => $ column_right ) ; return $ this ; }
6246	public function files ( ? int $ constraints = null ) : \ Generator { foreach ( $ this -> all ( $ constraints ) as $ file ) { if ( ! $ file -> isDir ( ) ) { yield $ file ; } } }
3491	public function withHeader ( string $ name , string $ value ) : Request { $ cloned = clone $ this ; $ cloned -> headers [ $ name ] = $ value ; return $ cloned ; }
12302	public function getChild ( $ id , $ relation , $ idChild , $ filters = null ) { $ parent = $ this -> model -> find ( $ id ) ; if ( ! $ parent ) { return null ; } if ( count ( $ filters -> request -> all ( ) ) > 0 ) { $ child = $ parent -> $ relation ( ) -> getRelated ( ) ; $ search = new Search ( $ child , $ filters , $ parent -> $ relation ( ) ) ; $ this -> builder = $ search -> getBuilder ( ) ; $ this -> builder -> select ( "{$child->getTable()}.*" ) ; if ( $ parent -> $ relation ( ) instanceof \ Illuminate \ Database \ Eloquent \ Relations \ BelongsToMany ) { $ this -> builder -> where ( $ parent -> $ relation ( ) -> getOtherKey ( ) , $ idChild ) ; } $ resource = $ this -> builder -> get ( ) ; } else { $ resource = $ parent -> $ relation ( ) -> find ( $ idChild ) ; } return $ resource ; }
11735	private function updateOv ( $ dwnl ) { $ entity = new EBonDwnl ( ) ; foreach ( $ dwnl as $ one ) { $ ov = $ one -> getOv ( ) ; $ calcId = $ one -> getCalculationRef ( ) ; $ custId = $ one -> getCustomerRef ( ) ; $ entity -> setOv ( $ ov ) ; $ id = [ EBonDwnl :: A_CALC_REF => $ calcId , EBonDwnl :: A_CUST_REF => $ custId ] ; $ this -> daoBonDwnl -> updateById ( $ id , $ entity ) ; } }
6113	public function sendPluginCmd ( $ plugin , $ data , $ cpw = null , $ subscribed = false ) { if ( $ this -> getId ( ) != $ this -> getParent ( ) -> whoamiGet ( "client_channel_id" ) ) { $ this -> getParent ( ) -> clientMove ( $ this -> getParent ( ) -> whoamiGet ( "client_id" ) , $ this -> getId ( ) , $ cpw ) ; } $ this -> execute ( "plugincmd" , array ( "name" => $ plugin , "data" => $ data , "targetmode" => $ subscribed ? TeamSpeak3 :: PLUGINCMD_CHANNEL_SUBSCRIBED : TeamSpeak3 :: PLUGINCMD_CHANNEL ) ) ; }
6932	private function isShipmentAmountInvoiced ( Invoice \ InvoiceInterface $ invoice ) { $ sale = $ invoice -> getSale ( ) ; foreach ( $ sale -> getInvoices ( ) as $ i ) { if ( $ i === $ invoice ) { continue ; } if ( $ i -> hasLineByType ( Document \ DocumentLineTypes :: TYPE_SHIPMENT ) ) { return true ; } } return false ; }
4759	protected function transformTemplate ( Template $ template ) { return array ( 'template' => $ template -> getTemplate ( ) , 'engine' => $ template -> getEngine ( ) , 'vars' => $ this -> transform ( $ template -> getVars ( ) ) , 'streamable' => $ this -> transformBoolean ( $ template -> isStreamable ( ) ) , ) ; }
10458	public function validate ( string $ answer ) : string { if ( trim ( ( string ) $ answer ) === '' ) { throw new \ RuntimeException ( sprintf ( '%s Given value: "%s"' , $ this -> getErrorMessage ( ) , $ answer ) ) ; } return $ answer ; }
4204	private function addPropertiesPhpDoc ( Event $ abs ) { $ tags = array ( 'property' => 'magic' , 'property-read' => 'magic-read' , 'property-write' => 'magic-write' , ) ; $ inheritedFrom = null ; if ( ! \ array_intersect_key ( $ abs [ 'phpDoc' ] , $ tags ) ) { $ found = false ; $ obj = $ abs -> getSubject ( ) ; if ( ! \ method_exists ( $ obj , '__get' ) ) { return ; } $ reflector = $ abs [ 'reflector' ] ; while ( $ reflector = $ reflector -> getParentClass ( ) ) { $ parsed = $ this -> phpDoc -> getParsed ( $ reflector ) ; $ tagIntersect = \ array_intersect_key ( $ parsed , $ tags ) ; if ( ! $ tagIntersect ) { continue ; } $ found = true ; $ inheritedFrom = $ reflector -> getName ( ) ; $ abs [ 'phpDoc' ] = \ array_merge ( $ abs [ 'phpDoc' ] , $ tagIntersect ) ; break ; } if ( ! $ found ) { return ; } } $ properties = $ abs [ 'properties' ] ; foreach ( $ tags as $ tag => $ vis ) { if ( ! isset ( $ abs [ 'phpDoc' ] [ $ tag ] ) ) { continue ; } foreach ( $ abs [ 'phpDoc' ] [ $ tag ] as $ phpDocProp ) { $ exists = isset ( $ properties [ $ phpDocProp [ 'name' ] ] ) ; $ properties [ $ phpDocProp [ 'name' ] ] = \ array_merge ( $ exists ? $ properties [ $ phpDocProp [ 'name' ] ] : self :: $ basePropInfo , array ( 'desc' => $ phpDocProp [ 'desc' ] , 'type' => $ phpDocProp [ 'type' ] , 'inheritedFrom' => $ inheritedFrom , 'visibility' => $ exists ? array ( $ properties [ $ phpDocProp [ 'name' ] ] [ 'visibility' ] , $ vis ) : $ vis , ) ) ; if ( ! $ exists ) { $ properties [ $ phpDocProp [ 'name' ] ] [ 'value' ] = $ this -> abstracter -> UNDEFINED ; } } unset ( $ abs [ 'phpDoc' ] [ $ tag ] ) ; } $ abs [ 'properties' ] = $ properties ; return ; }
3532	public static function sendFortnitePostRequest ( $ endpoint , $ access_token , $ params = null ) { $ client = new Client ( ) ; try { $ response = $ client -> post ( $ endpoint , [ 'json' => $ params , 'headers' => [ 'User-Agent' => self :: FORTNITE_USER_AGENT , 'Authorization' => 'bearer ' . $ access_token ] ] ) ; return json_decode ( $ response -> getBody ( ) -> getContents ( ) ) ; } catch ( GuzzleException $ e ) { throw $ e ; } }
1281	protected function buildFile ( array $ data ) : FileInterface { if ( isset ( $ data [ 'uploadFrom' ] ) ) { return new LocalUploadFile ( $ data [ 'fileName' ] , $ data [ 'contentType' ] , new Link ( $ data [ 'uploadFrom' ] [ 'sys' ] [ 'id' ] , $ data [ 'uploadFrom' ] [ 'sys' ] [ 'linkType' ] ) ) ; } if ( isset ( $ data [ 'upload' ] ) ) { return new RemoteUploadFile ( $ data [ 'fileName' ] , $ data [ 'contentType' ] , $ data [ 'upload' ] ) ; } if ( isset ( $ data [ 'details' ] [ 'image' ] ) ) { return new ImageFile ( $ data [ 'fileName' ] , $ data [ 'contentType' ] , $ data [ 'url' ] , $ data [ 'details' ] [ 'size' ] , $ data [ 'details' ] [ 'image' ] [ 'width' ] , $ data [ 'details' ] [ 'image' ] [ 'height' ] ) ; } return new File ( $ data [ 'fileName' ] , $ data [ 'contentType' ] , $ data [ 'url' ] , $ data [ 'details' ] [ 'size' ] ) ; }
8312	public function handlePasswordReset ( Request $ httpRequest ) { $ this -> httpRequest = $ httpRequest ; $ this -> checkResetLink ( ) ; $ resetData = $ this -> session -> get ( "pwreset" ) ; if ( $ resetData === null ) { $ this -> beginPasswordReset ( ) ; } else { $ this -> finishPasswordReset ( $ resetData ) ; } }
9594	public function makeSessionHandler ( ) { $ handler = $ this -> dic -> resolve ( 'Autarky\Http\SessionHandlerFactory' ) -> makeHandler ( $ this -> config -> get ( 'session.handler' ) ) ; if ( $ this -> config -> get ( 'session.write_check' ) === true ) { $ handler = new WriteCheckSessionHandler ( $ handler ) ; } return $ handler ; }
5640	public function paintGroupEnd ( $ test_name ) { array_pop ( $ this -> test_stack ) ; if ( count ( $ this -> test_stack ) == 0 ) { $ this -> paintFooter ( $ test_name ) ; } }
8996	protected function buildNamespace ( ApiDefinition $ definition , $ namespace ) { if ( $ this -> config [ 'version_in_namespace' ] && $ definition -> getVersion ( ) ) { $ namespace .= '\\' . preg_replace ( array ( '/(^[0-9])/' , '/[^a-zA-Z0-9]/' ) , array ( 'Version\1' , '_' ) , $ definition -> getVersion ( ) ) ; } return $ namespace ; }
5162	public function attachGallery ( Gallery $ gallery ) : self { return $ this -> attach ( self :: ATTACHMENT_FIELD_GALLERY , $ this -> ensureOrder ( $ gallery , self :: ATTACHMENT_FIELD_GALLERY ) ) ; }
648	public function addCommentOnTable ( $ table , $ comment ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> addCommentOnTable ( $ table , $ comment ) ; return $ this -> setSql ( $ sql ) ; }
6798	public function install ( $ country = 'US' , $ currency = 'USD' ) { $ this -> installCountries ( $ country ) ; $ this -> installCurrencies ( $ currency ) ; $ this -> installTaxes ( $ country ) ; $ this -> installTaxGroups ( $ country ) ; $ this -> installTaxRules ( $ country ) ; $ this -> installCustomerGroups ( ) ; }
1454	protected function validateRelationship ( RelationshipInterface $ relationship , $ key = null ) { if ( ! $ relationship -> has ( RelationshipInterface :: DATA ) ) { $ this -> addError ( $ this -> errorFactory -> memberRequired ( RelationshipInterface :: DATA , $ key ? P :: relationship ( $ key ) : P :: data ( ) ) ) ; return false ; } if ( ! $ relationship -> isHasOne ( ) && ! $ relationship -> isHasMany ( ) ) { $ this -> addError ( $ this -> errorFactory -> memberRelationshipExpected ( RelationshipInterface :: DATA , $ key ? P :: relationship ( $ key ) : P :: data ( ) ) ) ; return false ; } if ( ! $ this -> validateEmpty ( $ relationship , $ key ) ) { return false ; } return true ; }
4377	protected function buildTableHeader ( $ keys ) { $ headers = array ( ) ; foreach ( $ keys as $ key ) { $ headers [ $ key ] = $ key === MethodTable :: SCALAR ? 'value' : \ htmlspecialchars ( $ key ) ; if ( $ this -> tableInfo [ 'colClasses' ] [ $ key ] ) { $ headers [ $ key ] .= ' ' . $ this -> markupClassname ( $ this -> tableInfo [ 'colClasses' ] [ $ key ] ) ; } } return '<thead>' . "\n" . '<tr><th>&nbsp;</th>' . ( $ this -> tableInfo [ 'haveObjRow' ] ? '<th>&nbsp;</th>' : '' ) . '<th>' . \ implode ( '</th><th scope="col">' , $ headers ) . '</th>' . '</tr>' . "\n" . '</thead>' . "\n" ; }
8360	private function startProcessQueue ( ) { $ this -> logger -> info ( 'Starting queue in process mode' ) ; $ dispatcher = new ProcessDispatcher ( $ this -> client , $ this -> logger , $ this -> queue , \ array_merge ( $ this -> queueConfig , [ 'process' => $ this -> config [ 'process' ] ] ) , [ 'configFile' => $ this -> configName ] ) ; $ dispatcher -> start ( ) ; }
7618	public function get ( $ name ) { if ( ! isset ( $ this -> accounts [ $ name ] ) ) { throw new \ RuntimeException ( "No account found with " . $ name ) ; } return $ this -> accounts [ $ name ] ; }
9961	public function freezePane ( $ cell , $ topLeftCell = null ) { if ( is_string ( $ cell ) && Coordinate :: coordinateIsRange ( $ cell ) ) { throw new Exception ( 'Freeze pane can not be set on a range of cells.' ) ; } if ( $ cell !== null && $ topLeftCell === null ) { $ coordinate = Coordinate :: coordinateFromString ( $ cell ) ; $ topLeftCell = $ coordinate [ 0 ] . $ coordinate [ 1 ] ; } $ this -> freezePane = $ cell ; $ this -> topLeftCell = $ topLeftCell ; return $ this ; }
73	public function authorizeOAuthInteractively ( $ originUrl , $ message = null ) { if ( $ message ) { $ this -> io -> writeError ( $ message ) ; } $ url = 'https://confluence.atlassian.com/bitbucket/oauth-on-bitbucket-cloud-238027431.html' ; $ this -> io -> writeError ( sprintf ( 'Follow the instructions on %s' , $ url ) ) ; $ this -> io -> writeError ( sprintf ( 'to create a consumer. It will be stored in "%s" for future use by Composer.' , $ this -> config -> getAuthConfigSource ( ) -> getName ( ) ) ) ; $ this -> io -> writeError ( 'Ensure you enter a "Callback URL" (http://example.com is fine) or it will not be possible to create an Access Token (this callback url will not be used by composer)' ) ; $ consumerKey = trim ( $ this -> io -> askAndHideAnswer ( 'Consumer Key (hidden): ' ) ) ; if ( ! $ consumerKey ) { $ this -> io -> writeError ( '<warning>No consumer key given, aborting.</warning>' ) ; $ this -> io -> writeError ( 'You can also add it manually later by using "composer config --global --auth bitbucket-oauth.bitbucket.org <consumer-key> <consumer-secret>"' ) ; return false ; } $ consumerSecret = trim ( $ this -> io -> askAndHideAnswer ( 'Consumer Secret (hidden): ' ) ) ; if ( ! $ consumerSecret ) { $ this -> io -> writeError ( '<warning>No consumer secret given, aborting.</warning>' ) ; $ this -> io -> writeError ( 'You can also add it manually later by using "composer config --global --auth bitbucket-oauth.bitbucket.org <consumer-key> <consumer-secret>"' ) ; return false ; } $ this -> io -> setAuthentication ( $ originUrl , $ consumerKey , $ consumerSecret ) ; if ( ! $ this -> requestAccessToken ( $ originUrl ) ) { return false ; } $ this -> storeInAuthConfig ( $ originUrl , $ consumerKey , $ consumerSecret ) ; $ this -> config -> getAuthConfigSource ( ) -> removeConfigSetting ( 'http-basic.' . $ originUrl ) ; $ this -> io -> writeError ( '<info>Consumer stored successfully.</info>' ) ; return true ; }
10566	protected function formatJsonp ( $ response ) { $ response -> getHeaders ( ) -> set ( 'Content-Type' , 'application/javascript; charset=UTF-8' ) ; if ( is_array ( $ response -> data ) && isset ( $ response -> data [ 'data' ] , $ response -> data [ 'callback' ] ) ) { $ response -> content = sprintf ( '%s(%s);' , $ response -> data [ 'callback' ] , Json :: htmlEncode ( $ response -> data [ 'data' ] ) ) ; } elseif ( $ response -> data !== null ) { $ response -> content = '' ; Yii :: warning ( "The 'jsonp' response requires that the data be an array consisting of both 'data' and 'callback' elements." , __METHOD__ ) ; } }
235	protected function getColumnPhpType ( $ column ) { static $ typeMap = [ self :: TYPE_TINYINT => 'integer' , self :: TYPE_SMALLINT => 'integer' , self :: TYPE_INTEGER => 'integer' , self :: TYPE_BIGINT => 'integer' , self :: TYPE_BOOLEAN => 'boolean' , self :: TYPE_FLOAT => 'double' , self :: TYPE_DOUBLE => 'double' , self :: TYPE_BINARY => 'resource' , self :: TYPE_JSON => 'array' , ] ; if ( isset ( $ typeMap [ $ column -> type ] ) ) { if ( $ column -> type === 'bigint' ) { return PHP_INT_SIZE === 8 && ! $ column -> unsigned ? 'integer' : 'string' ; } elseif ( $ column -> type === 'integer' ) { return PHP_INT_SIZE === 4 && $ column -> unsigned ? 'string' : 'integer' ; } return $ typeMap [ $ column -> type ] ; } return 'string' ; }
8470	public function alert ( $ scope , $ message , $ context = [ ] , $ config = [ ] ) { return $ this -> write ( 'alert' , $ scope , $ message , $ context , $ config ) ; }
6846	public static function hours ( $ step = 1 , $ long = false , $ start = null ) { if ( ! $ start ) { $ start = $ long ? 0 : 1 ; } $ size = $ long ? 23 : 12 ; $ step = ( int ) $ step ; $ hours = array ( ) ; for ( $ i = $ start ; $ i <= $ size ; $ i += $ step ) { $ hours [ $ i ] = ( string ) $ i ; } return $ hours ; }
10985	public static function checkPhpVersion ( ) { $ version = null ; if ( \ defined ( 'PHP_VERSION' ) ) { $ version = PHP_VERSION ; } else { $ version = phpversion ( '' ) ; } if ( strpos ( $ version , '-' ) !== false ) { $ version = substr ( $ version , 0 , strpos ( $ version , '-' ) ) ; } return $ version ; }
10839	protected function deleteRaw ( $ Key ) { $ CacheFile = $ this -> getCacheFile ( $ Key ) ; if ( file_exists ( $ CacheFile ) ) { return unlink ( $ CacheFile ) ; } return true ; }
8581	public function setPrepInstruction ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'PrepInstruction' ] [ 'FieldValue' ] = $ value ; return $ this ; }
974	public function handle ( Request $ request , Closure $ next ) { $ hmac = $ request -> header ( 'x-shopify-hmac-sha256' ) ? : '' ; $ shop = $ request -> header ( 'x-shopify-shop-domain' ) ; $ data = $ request -> getContent ( ) ; $ hmacLocal = ShopifyApp :: createHmac ( [ 'data' => $ data , 'raw' => true , 'encode' => true ] ) ; if ( ! hash_equals ( $ hmac , $ hmacLocal ) || empty ( $ shop ) ) { return Response :: make ( 'Invalid webhook signature.' , 401 ) ; } return $ next ( $ request ) ; }
11644	protected function getConnection ( ) { $ connection = $ this -> getClient ( ) -> getConnection ( ) ; if ( $ connection instanceof ReplicationInterface ) { $ connection -> switchToMaster ( ) ; } return $ connection ; }
8394	public static function before ( string $ path , string $ usage , string $ help , string $ action ) { if ( self :: $ isInit === true ) { self :: $ routes [ ] = array ( 'type' => 'before' , 'path' => $ path , 'usage' => $ usage , 'help' => $ help , 'action' => $ action , 'namespace' => self :: $ namespace ) ; } }
2769	public function addRemote ( string $ name , string $ url , array $ options = [ ] ) : string { $ this -> ensureAddRemoveArgsAreValid ( $ name , $ url ) ; $ args = [ 'add' ] ; foreach ( [ '-f' , '--tags' , '--no-tags' ] as $ option ) { if ( ! empty ( $ options [ $ option ] ) ) { $ args [ ] = $ option ; } } if ( ! empty ( $ options [ '-t' ] ) ) { foreach ( $ options [ '-t' ] as $ branch ) { array_push ( $ args , '-t' , $ branch ) ; } } if ( ! empty ( $ options [ '-m' ] ) ) { array_push ( $ args , '-m' , $ options [ '-m' ] ) ; } array_push ( $ args , $ name , $ url ) ; return $ this -> remote ( ... $ args ) ; }
9461	public function appendValueFilter ( $ key , $ value ) { if ( ! empty ( $ value ) ) { if ( $ this -> getValues ( $ key ) ) { return $ this -> append ( $ key , $ value ) ; } else { return $ this -> addValuesFilter ( $ key , [ $ value ] ) ; } } else { return $ this ; } }
11639	public function getColumnSettings ( ) { if ( is_null ( $ this -> _columnSettings ) ) { $ this -> _columnSettings = [ ] ; foreach ( $ this -> columns as $ key => $ c ) { if ( ! $ c -> visible ) { continue ; } $ this -> _columnSettings [ $ key ] = [ 'label' => $ c -> getDataLabel ( ) ] ; if ( ! isset ( $ c -> htmlOptions ) ) { $ c -> htmlOptions = [ ] ; } $ this -> _columnSettings [ $ key ] [ 'htmlOptions' ] = $ c -> htmlOptions ; $ sortableResolve = $ this -> dataProvider -> sort -> resolveAttribute ( $ c -> name ) ; $ this -> _columnSettings [ $ key ] [ 'sortable' ] = ! empty ( $ sortableResolve ) ; } } return $ this -> _columnSettings ; }
11447	public function actionIndex ( $ option = null ) { $ fixtures = Yii :: createObject ( Fixtures :: className ( ) ) ; $ option = Question :: displayWithQuit ( 'Select operation' , [ 'Export' , 'Import' ] , $ option ) ; if ( $ option == 'e' ) { $ allTables = $ fixtures -> tableNameList ( ) ; if ( ! empty ( $ allTables ) ) { $ answer = Select :: display ( 'Select tables for export' , $ allTables , 1 ) ; $ tables = $ fixtures -> export ( $ answer ) ; Output :: items ( $ tables , 'Exported tables' ) ; } else { Output :: block ( "not tables for export!" ) ; } } elseif ( $ option == 'i' ) { $ allTables = $ fixtures -> fixtureNameList ( ) ; if ( ! empty ( $ allTables ) ) { $ answer = Select :: display ( 'Select tables for import' , $ allTables , 1 ) ; $ tables = $ fixtures -> import ( $ answer ) ; Output :: items ( $ tables , 'Imported tables' ) ; } else { Output :: block ( "not tables for import!" ) ; } } }
10788	protected function getSearchFacets ( SessionInterface $ session ) { $ facets = $ session -> get ( $ this -> getSessionPrefix ( ) . '_facets' , false ) ; return $ facets ? \ json_decode ( $ facets , true ) : $ this -> getDefaultFacets ( ) ; }
3300	public function post ( $ url , $ params = [ ] ) { $ key = is_array ( $ params ) ? 'form_params' : 'body' ; return $ this -> request ( 'POST' , $ url , [ $ key => $ params ] ) ; }
1423	protected function with ( $ query , EncodingParametersInterface $ parameters ) { $ query -> with ( $ this -> getRelationshipPaths ( ( array ) $ parameters -> getIncludePaths ( ) ) ) ; }
1152	public function selector ( $ selector ) { $ this -> selector = is_null ( $ selector ) ? $ this -> selector : $ selector ; return $ this ; }
3887	public function editRenderSettingButton ( \ DC_Table $ dataContainer ) { if ( $ dataContainer -> value < 1 ) { return '' ; } $ url = $ this -> urlBuilderFactory -> create ( 'contao/main.php?do=metamodels&table=tl_metamodel_rendersetting' ) -> setQueryParameter ( 'pid' , ModelId :: fromValues ( 'tl_metamodel_rendersettings' , $ dataContainer -> value ) -> getSerialized ( ) ) ; return $ this -> renderEditButton ( $ GLOBALS [ 'TL_LANG' ] [ static :: $ tableName ] [ 'editrendersetting' ] [ 0 ] , sprintf ( StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ static :: $ tableName ] [ 'editrendersetting' ] [ 1 ] ) , $ dataContainer -> value ) , $ url ) ; }
4427	protected function askForChoiceData ( $ optionIdentifier , $ optionName , array $ choices , $ defaultValue ) { $ optionValue = $ this -> input -> getOption ( $ optionIdentifier ) ; $ optionValue = ! empty ( $ optionValue ) ? $ optionValue : $ defaultValue ; $ question = $ this -> getChoiceQuestion ( $ optionName , $ optionValue , $ choices ) ; $ optionValue = $ this -> questionHelper -> ask ( $ this -> input , $ this -> output , $ question ) ; $ this -> input -> setOption ( $ optionIdentifier , $ optionValue ) ; return $ optionValue ; }
4596	public function getList ( ) : array { $ objects = $ this -> execute ( 'GET' , static :: RESOURCE_LIST ) ; $ list = [ ] ; foreach ( $ objects as $ name => $ object ) { $ model = static :: toModel ( $ object ) ; $ list [ ] = $ model ; } return $ list ; }
10008	public function disconnectWorksheets ( ) { $ worksheet = null ; foreach ( $ this -> workSheetCollection as $ k => & $ worksheet ) { $ worksheet -> disconnectCells ( ) ; $ this -> workSheetCollection [ $ k ] = null ; } unset ( $ worksheet ) ; $ this -> workSheetCollection = [ ] ; }
6155	protected function convertValue ( $ value ) { switch ( $ this -> propertyType -> getDataTypeId ( ) ) { case PropertyType :: DATATYPE_BOOLEAN : return ( bool ) $ value ; break ; case PropertyType :: DATATYPE_DATETIME : if ( $ value instanceof \ DateTime ) { return $ value ; } try { return new \ DateTime ( $ value ) ; } catch ( \ Exception $ e ) { return null ; } break ; case PropertyType :: DATATYPE_FLOAT : return ( float ) $ value ; break ; case PropertyType :: DATATYPE_INTEGER : return ( int ) $ value ; break ; case PropertyType :: DATATYPE_STRING : return ( string ) $ value ; break ; default : return $ value ; break ; } }
6702	protected function precedence ( $ a , $ b ) { if ( count ( $ a ) > count ( $ b ) ) { $ l = - 1 ; $ r = 1 ; $ x = $ a ; $ y = $ b ; } else { $ l = 1 ; $ r = - 1 ; $ x = $ b ; $ y = $ a ; } foreach ( array_keys ( $ x ) as $ i ) { if ( false === isset ( $ y [ $ i ] ) ) { return $ l ; } if ( $ x [ $ i ] === $ y [ $ i ] ) { continue ; } $ xi = is_integer ( $ x [ $ i ] ) ; $ yi = is_integer ( $ y [ $ i ] ) ; if ( $ xi && $ yi ) { return ( $ x [ $ i ] > $ y [ $ i ] ) ? $ l : $ r ; } elseif ( ( false === $ xi ) && ( false === $ yi ) ) { return ( max ( $ x [ $ i ] , $ y [ $ i ] ) == $ x [ $ i ] ) ? $ l : $ r ; } else { return $ xi ? $ r : $ l ; } } return 0 ; }
5564	protected function loadFrame ( $ frames , $ url , $ parameters ) { $ page = $ this -> fetch ( $ url , $ parameters ) ; $ this -> page -> setFrame ( $ frames , $ page ) ; return $ page -> getRaw ( ) ; }
3967	protected function getMetaModelByModelPid ( ModelInterface $ model ) { $ metaModel = $ this -> factory -> getMetaModel ( $ this -> factory -> translateIdToMetaModelName ( $ model -> getProperty ( 'pid' ) ) ) ; if ( $ metaModel === null ) { throw new \ InvalidArgumentException ( 'Could not retrieve MetaModel ' . $ model -> getProperty ( 'pid' ) ) ; } return $ metaModel ; }
6600	public function unlinkFiles ( $ fileName ) { $ folder = $ this -> getWebrootFolder ( ) ; if ( $ fileName ) { if ( @ file_exists ( $ folder . '/' . $ fileName ) ) { unlink ( $ folder . '/' . $ fileName ) ; } if ( @ file_exists ( $ folder . '/' . $ this -> thumbFolder . '/' . $ fileName ) ) { unlink ( $ folder . '/' . $ this -> thumbFolder . '/' . $ fileName ) ; } if ( is_array ( $ this -> sizes ) ) { $ i = 0 ; foreach ( $ this -> sizes as $ size ) { if ( @ file_exists ( $ folder . '/' . $ i . '/' . $ fileName ) ) { unlink ( $ folder . '/' . $ i . '/' . $ fileName ) ; } $ i ++ ; } } } }
8407	private function getIcon ( ) { if ( isset ( $ this -> model ) ) { $ icon = $ this -> attribute ; if ( isset ( $ this -> model -> $ icon ) ) { return $ this -> model -> $ icon ; } } if ( isset ( $ this -> icon ) ) { return $ this -> icon ; } return $ this -> default ; }
6473	private function compareAcceptCharsetHeaders ( AcceptCharsetHeaderValue $ a , AcceptCharsetHeaderValue $ b ) : int { $ aQuality = $ a -> getQuality ( ) ; $ bQuality = $ b -> getQuality ( ) ; if ( $ aQuality < $ bQuality ) { return 1 ; } if ( $ aQuality > $ bQuality ) { return - 1 ; } $ aValue = $ a -> getCharset ( ) ; $ bValue = $ b -> getCharset ( ) ; if ( $ aValue === '*' ) { if ( $ bValue === '*' ) { return 0 ; } return 1 ; } if ( $ bValue === '*' ) { return - 1 ; } return 0 ; }
4627	protected function prepareRequestData ( ) { if ( in_array ( $ this -> command -> getMethod ( ) , [ 'POST' , 'PUT' ] ) ) { $ this -> requestBody = $ this -> command -> getEncodedData ( ) ; $ this -> options [ CURLOPT_POSTFIELDS ] = $ this -> requestBody ; } return $ this ; }
5512	public function expectMaximumCallCount ( $ method , $ count , $ message = '%s' ) { $ this -> dieOnNoMethod ( $ method , 'set maximum call count' ) ; $ message .= Mock :: getExpectationLine ( ) ; $ this -> max_counts [ strtolower ( $ method ) ] = new MaximumCallCountExpectation ( $ method , $ count , $ message ) ; }
3949	private function buildCaption ( $ metaModel , $ inputScreen ) : array { $ caption = [ sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'metamodel_edit_as_child' ] [ 'label' ] , $ metaModel -> getName ( ) ) , '' ] ; foreach ( $ inputScreen [ 'label' ] as $ langCode => $ label ) { if ( $ label !== '' && $ langCode === $ GLOBALS [ 'TL_LANGUAGE' ] ) { $ caption = [ $ label , $ inputScreen [ 'description' ] [ $ langCode ] ] ; } } return $ caption ; }
1224	private function fillPathParams ( $ uri , array & $ paramValues ) { return preg_replace_callback ( '/{(\S+)}/U' , function ( $ matches ) use ( & $ paramValues ) { $ path = $ matches [ 1 ] ; if ( array_key_exists ( $ path , $ paramValues ) ) { $ value = $ paramValues [ $ path ] ; unset ( $ paramValues [ $ path ] ) ; } else { $ value = $ path ; } return $ value ; } , $ uri ) ; }
5283	public function insert ( $ data , $ format = null ) { global $ wpdb ; $ wpdb -> insert ( $ this -> table , $ data , $ format ) ; return $ wpdb -> insert_id ; }
9696	function createTransactions ( $ transactions , $ release = true , $ ignoreInvalidEvents = false ) { $ queryParameters = array ( 'release' => ( $ release == true ) ? 'true' : 'false' , 'ignore_invalid_transactions' => ( $ ignoreInvalidEvents == true ) ? 'true' : 'false' ) ; $ data = JSONSerializer :: json_encode ( $ transactions ) ; $ result = $ this -> post ( "transactions" , $ data , $ queryParameters , "application/json" , 'com_maileon_api_transactions_ProcessingReports' ) ; return $ result ; }
10182	public function unsetWorksheetCells ( ) { if ( $ this -> currentCell !== null ) { $ this -> currentCell -> detach ( ) ; $ this -> currentCell = null ; $ this -> currentCoordinate = null ; } $ this -> __destruct ( ) ; $ this -> index = [ ] ; $ this -> parent = null ; }
5166	protected function filterUriInstance ( $ uri ) : string { if ( $ uri instanceof UriInterface ) { return ( string ) $ uri ; } if ( is_string ( $ uri ) ) { return ( string ) \ One \ createUriFromString ( $ uri ) ; } return '' ; }
3273	public function get ( string $ key ) { Validation :: validateKey ( $ key ) ; if ( $ cache = $ this -> getConfig ( ) -> getCache ( ) ) { if ( $ cache -> contains ( $ key ) ) { return $ cache -> get ( $ key ) ; } } $ file = $ this -> getDatabase ( ) -> readFromFile ( ) ; $ data = false ; foreach ( $ file as $ line ) { if ( $ line -> getKey ( ) == $ key ) { $ data = $ this -> decodeData ( $ line -> getData ( ) ) ; break ; } } if ( $ cache && $ data !== false ) { $ cache -> set ( $ key , $ data ) ; } return $ data ; }
8812	public function view ( $ view , array $ data = [ ] ) { if ( function_exists ( 'app' ) ) { $ this -> setContent ( app ( 'load' ) -> view ( $ view , $ data ) ) ; return $ this ; } return ; }
12559	public function fixFile ( $ file ) { $ contents = preg_split ( "/\\r\\n|\\r|\\n/" , file_get_contents ( $ file ) ) ; $ changed = false ; if ( $ this -> fixFileSlashes ( $ file , $ contents ) ) { $ changed = true ; } if ( $ changed ) { file_put_contents ( $ file , implode ( "\n" , $ contents ) ) ; } return $ changed ; }
7569	public function getJobApiService ( ) { $ apiService = new \ Greenhouse \ GreenhouseToolsPhp \ Services \ JobApiService ( $ this -> _boardToken ) ; $ apiClient = new GuzzleClient ( array ( 'base_uri' => ApiService :: jobBoardBaseUrl ( $ this -> _boardToken ) ) ) ; $ apiService -> setClient ( $ apiClient ) ; return $ apiService ; }
3675	private function collectAttributeFactories ( $ container ) { $ attributeFactory = $ container -> getDefinition ( 'metamodels.attribute_factory' ) ; foreach ( array_keys ( $ container -> findTaggedServiceIds ( self :: TAG_ATTRIBUTE_FACTORY ) ) as $ factory ) { $ attributeFactory -> addMethodCall ( 'addTypeFactory' , [ new Reference ( $ factory ) ] ) ; } }
8131	protected function removeNodeFilter ( Twig_Node $ node ) { if ( $ node instanceof Twig_Node_Expression_Filter ) { return $ this -> removeNodeFilter ( $ node -> getNode ( 'node' ) ) ; } return $ node ; }
4555	protected function addJoinTranslation ( QueryBuilder $ queryBuilder , string $ resourceClass ) { $ rootAlias = $ queryBuilder -> getRootAliases ( ) [ 0 ] ; $ translationAlias = $ rootAlias . '_t' ; $ translationClass = call_user_func ( $ resourceClass . '::getTranslationEntityClass' ) ; $ parts = $ queryBuilder -> getDQLParts ( ) [ 'join' ] ; foreach ( $ parts as $ joins ) { foreach ( $ joins as $ join ) { if ( $ translationAlias === $ join -> getAlias ( ) ) { return $ translationAlias ; } } } $ queryBuilder -> leftJoin ( $ translationClass , $ translationAlias , Join :: WITH , $ rootAlias . '.id = ' . $ translationAlias . '.translatable' ) ; return $ translationAlias ; }
7673	function TbsStorePark ( ) { if ( $ this -> TbsCurrIdx !== false ) { $ this -> TbsStoreLst [ $ this -> TbsCurrIdx ] = array ( 'src' => $ this -> TBS -> Source , 'onshow' => true ) ; $ this -> TBS -> Source = '' ; $ this -> TbsCurrIdx = false ; } }
4404	public function getPath ( $ locationId ) { $ pathArray = array ( ) ; $ startingLocation = $ this -> locationService -> loadLocation ( $ locationId ) ; $ path = $ startingLocation -> path ; array_shift ( $ path ) ; $ rootLocationFound = false ; foreach ( $ path as $ index => $ pathItem ) { if ( ( int ) $ pathItem === $ this -> rootLocationId ) { $ rootLocationFound = true ; } if ( ! $ rootLocationFound ) { continue ; } try { $ location = $ this -> locationService -> loadLocation ( $ pathItem ) ; } catch ( UnauthorizedException $ e ) { return array ( ) ; } $ pathArray [ ] = array ( 'text' => $ this -> translationHelper -> getTranslatedContentNameByContentInfo ( $ location -> contentInfo ) , 'url' => $ location -> id !== $ startingLocation -> id ? $ this -> router -> generate ( $ location ) : false , 'locationId' => $ location -> id , 'contentId' => $ location -> contentId , ) ; } return $ pathArray ; }
1568	public function getResourceId ( ) : ? string { if ( is_null ( $ this -> resourceId ) ) { return $ this -> parameter ( ResourceRegistrar :: PARAM_RESOURCE_ID ) ; } return $ this -> resourceId ? : null ; }
9141	public function getParam ( $ name , $ typeOf = 'string' ) { $ result = $ this -> hasParam ( $ name ) ? $ this -> params [ $ name ] : null ; switch ( $ typeOf ) { case 'bool' : case 'boolean' : $ result = function_exists ( 'boolval' ) ? boolval ( $ result ) : ( bool ) $ result ; break ; case 'double' : case 'float' : $ result = doubleval ( $ result ) ; break ; case 'int' : $ result = intval ( $ result ) ; break ; case 'string' : default : $ result = htmlentities ( strval ( $ result ) ) ; break ; } return $ result ; }
3062	public function canMoveBackward ( ) { $ moveBack = false ; $ session = $ this -> getTestSession ( ) ; if ( $ this -> isAdaptive ( ) ) { $ positionInCatSession = array_search ( $ this -> getCurrentCatItemId ( ) , $ this -> getShadowTest ( ) ) ; if ( $ positionInCatSession === 0 ) { if ( $ session -> getRoute ( ) -> getPosition ( ) !== 0 ) { $ moveBack = $ session -> getPreviousRouteItem ( ) -> getTestPart ( ) -> getNavigationMode ( ) === NavigationMode :: NONLINEAR ; } } else { $ moveBack = $ session -> getRoute ( ) -> current ( ) -> getTestPart ( ) -> getNavigationMode ( ) === NavigationMode :: NONLINEAR ; } } else { $ moveBack = $ session -> canMoveBackward ( ) ; if ( $ moveBack ) { $ moveBack = $ this -> getServiceManager ( ) -> get ( SectionPauseService :: SERVICE_ID ) -> canMoveBackward ( $ session ) ; } } return $ moveBack ; }
2308	public function setImportantPart ( array $ importantPart = null ) { if ( $ importantPart !== null ) { if ( ! isset ( $ importantPart [ 'x' ] ) || ! isset ( $ importantPart [ 'y' ] ) || ! isset ( $ importantPart [ 'width' ] ) || ! isset ( $ importantPart [ 'height' ] ) ) { throw new \ InvalidArgumentException ( 'Malformed array for setting the important part!' ) ; } $ this -> importantPart = array ( 'x' => max ( 0 , min ( $ this -> fileObj -> viewWidth - 1 , ( int ) $ importantPart [ 'x' ] ) ) , 'y' => max ( 0 , min ( $ this -> fileObj -> viewHeight - 1 , ( int ) $ importantPart [ 'y' ] ) ) , ) ; $ this -> importantPart [ 'width' ] = max ( 1 , min ( $ this -> fileObj -> viewWidth - $ this -> importantPart [ 'x' ] , ( int ) $ importantPart [ 'width' ] ) ) ; $ this -> importantPart [ 'height' ] = max ( 1 , min ( $ this -> fileObj -> viewHeight - $ this -> importantPart [ 'y' ] , ( int ) $ importantPart [ 'height' ] ) ) ; } else { $ this -> importantPart = null ; } return $ this ; }
1743	public function uploadFile ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { if ( ! $ GLOBALS [ 'TL_DCA' ] [ 'tl_files' ] [ 'config' ] [ 'closed' ] && ! $ GLOBALS [ 'TL_DCA' ] [ 'tl_files' ] [ 'config' ] [ 'notCreatable' ] && Contao \ Input :: get ( 'act' ) != 'select' && isset ( $ row [ 'type' ] ) && $ row [ 'type' ] == 'folder' ) { return '<a href="' . $ this -> addToUrl ( $ href . '&amp;pid=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '" ' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' ; } return ' ' ; }
9551	public function setOrderBy ( $ order_by , $ order = null ) { $ this -> order_by = $ order_by ; $ this -> order = $ order ; return $ this ; }
659	public function noCache ( callable $ callable ) { $ this -> _queryCacheInfo [ ] = false ; try { $ result = call_user_func ( $ callable , $ this ) ; array_pop ( $ this -> _queryCacheInfo ) ; return $ result ; } catch ( \ Exception $ e ) { array_pop ( $ this -> _queryCacheInfo ) ; throw $ e ; } catch ( \ Throwable $ e ) { array_pop ( $ this -> _queryCacheInfo ) ; throw $ e ; } }
7265	public static function select ( $ queryString = "" , array $ queryParams = [ ] ) { $ tableName = static :: tableName ( ) ; $ rows = Db :: query ( " select $tableName.* from $tableName $queryString " , $ queryParams , static :: getDbName ( ) ) ; if ( $ rows === false ) return false ; if ( empty ( $ rows ) ) return new Collection ( [ ] ) ; $ collection = [ ] ; foreach ( $ rows as $ row ) { $ model = new static ; foreach ( $ row as $ column => $ val ) $ model -> $ column = $ model -> decodeValue ( $ val , $ column ) ; $ collection [ ] = $ model ; } return new Collection ( $ collection ) ; }
12411	public function lists ( $ begin , $ count ) { $ params = [ 'begin' => intval ( $ begin ) , 'count' => intval ( $ count ) , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_GET_LIST , $ params ] ) ; }
80	public static function suppress ( $ mask = null ) { if ( ! isset ( $ mask ) ) { $ mask = E_WARNING | E_NOTICE | E_USER_WARNING | E_USER_NOTICE | E_DEPRECATED | E_USER_DEPRECATED | E_STRICT ; } $ old = error_reporting ( ) ; self :: $ stack [ ] = $ old ; error_reporting ( $ old & ~ $ mask ) ; return $ old ; }
11956	function addQueue ( $ channel , $ queue , $ weight = 1 ) { $ orig = $ channel ; $ channel = $ this -> _normalizeQueueName ( $ channel ) ; if ( ! $ queue instanceof iQueueDriver ) throw new \ Exception ( sprintf ( 'Queue must be instance of iQueueDriver; given: (%s).' , \ Poirot \ Std \ flatten ( $ queue ) ) ) ; if ( isset ( $ this -> channels_queue [ $ channel ] ) ) throw new \ RuntimeException ( sprintf ( 'Channel (%s) is currently filled with (%s) and is not empty.' , $ orig , get_class ( $ this -> channels_queue [ $ channel ] ) ) ) ; $ this -> channels_queue [ $ channel ] = $ queue ; $ this -> channels_weight [ $ channel ] = $ weight ; return $ this ; }
2076	public function purgeImageCache ( ) { $ container = System :: getContainer ( ) ; $ strTargetPath = StringUtil :: stripRootDir ( $ container -> getParameter ( 'contao.image.target_dir' ) ) ; $ strRootDir = $ container -> getParameter ( 'kernel.project_dir' ) ; foreach ( scan ( $ strRootDir . '/' . $ strTargetPath ) as $ dir ) { if ( strncmp ( $ dir , '.' , 1 ) !== 0 ) { $ objFolder = new Folder ( $ strTargetPath . '/' . $ dir ) ; $ objFolder -> purge ( ) ; } } $ this -> purgePageCache ( ) ; $ this -> log ( 'Purged the image cache' , __METHOD__ , TL_CRON ) ; }
4360	public static function dump ( $ str , $ useHtml = false , $ sanitizeNonBinary = false ) { self :: $ useHtml = $ useHtml ; self :: $ sanitizeNonBinary = $ sanitizeNonBinary ; self :: setStr ( $ str ) ; $ controlCharAs = 'other' ; $ curBlockType = 'utf8' ; $ newBlockType = null ; $ curBlockStart = 0 ; $ strNew = '' ; while ( self :: $ curI < self :: $ stats [ 'strLen' ] ) { $ curI = self :: $ curI ; $ isUtf8 = self :: isOffsetUtf8 ( $ isSpecial , true ) ; if ( $ isUtf8 && $ isSpecial && $ controlCharAs !== 'utf8special' && \ ord ( $ str [ $ curI ] ) < 0x80 ) { if ( $ controlCharAs == 'other' ) { $ isUtf8 = false ; } elseif ( $ controlCharAs == 'utf8' ) { $ isSpecial = false ; } } if ( $ isUtf8 ) { if ( $ isSpecial ) { if ( $ curBlockType !== 'utf8special' ) { $ newBlockType = 'utf8special' ; } } else { if ( $ curBlockType !== 'utf8' ) { $ newBlockType = 'utf8' ; } } } else { if ( $ curBlockType !== 'other' ) { $ newBlockType = 'other' ; } } if ( $ newBlockType ) { $ len = $ curI - $ curBlockStart ; self :: incStat ( $ curBlockType , $ len ) ; $ subStr = \ substr ( self :: $ str , $ curBlockStart , $ len ) ; $ strNew .= self :: dumpBlock ( $ subStr , $ curBlockType ) ; $ curBlockStart = $ curI ; $ curBlockType = $ newBlockType ; $ newBlockType = null ; } } $ len = self :: $ stats [ 'strLen' ] - $ curBlockStart ; self :: incStat ( $ curBlockType , $ len ) ; if ( self :: $ stats [ 'strLen' ] ) { $ percentOther = ( self :: $ stats [ 'bytesOther' ] ) / self :: $ stats [ 'strLen' ] * 100 ; if ( $ percentOther > 33 ) { $ strNew = self :: dumpBlock ( $ str , 'other' , array ( 'prefix' => false ) ) ; } else { $ subStr = \ substr ( self :: $ str , $ curBlockStart , $ len ) ; $ strNew .= self :: dumpBlock ( $ subStr , $ curBlockType ) ; } } return $ strNew ; }
10768	public static function accountToIBAN ( $ account , $ country = 'CZ' ) { $ allowedCountries = [ 'AT' , 'BE' , 'BG' , 'CZ' , 'CY' , 'DK' , 'EE' , 'FI' , 'FR' , 'DE' , 'GI' , 'GR' , 'HU' , 'IE' , 'IS' , 'IT' , 'LI' , 'LT' , 'LU' , 'LV' , 'MC' , 'MT' , 'NL' , 'NO' , 'PL' , 'PT' , 'RO' , 'SE' , 'CH' , 'SI' , 'SK' , 'ES' , 'GB' ] ; $ account = self :: normalizeAccountNumber ( $ account ) ; $ accountArray = explode ( '/' , str_replace ( '-' , '' , $ account ) ) ; if ( 2 !== \ count ( $ accountArray ) ) { throw new RuntimeException ( Tools :: poorManTranslate ( 'fts-shared' , 'Wrong bank account (some part missing).' ) ) ; } $ country = strtoupper ( $ country ) ; if ( ! \ in_array ( $ country , $ allowedCountries , true ) ) { throw new RuntimeException ( Tools :: poorManTranslate ( 'fts-shared' , 'Invalid country code.' ) ) ; } $ accountStr = str_pad ( $ accountArray [ 1 ] , 4 , '0' , STR_PAD_LEFT ) . str_pad ( $ accountArray [ 0 ] , 16 , '0' , STR_PAD_LEFT ) . ( \ ord ( $ country [ 0 ] ) - 55 ) . ( \ ord ( $ country [ 1 ] ) - 55 ) . '00' ; $ crc = '' ; $ pos = 0 ; while ( \ strlen ( $ accountStr ) > 0 ) { $ len = 9 - \ strlen ( $ crc ) ; $ crc = ( int ) ( $ crc . substr ( $ accountStr , $ pos , $ len ) ) % 97 ; $ accountStr = substr ( $ accountStr , $ len ) ; } return ( $ country . str_pad ( 98 - $ crc , 2 , '0' , STR_PAD_LEFT ) . $ accountArray [ 1 ] . $ accountArray [ 0 ] ) ; }
10858	public function eachMarked ( callable $ callback , $ result = null ) { $ ref = new \ ReflectionFunction ( $ callback ) ; $ params = $ ref -> getParameters ( ) ; if ( \ count ( $ params ) < 2 ) { throw new \ InvalidArgumentException ( \ sprintf ( 'Callback for marker processing must declare at least 2 arguments (object and marker)' ) ) ; } try { $ markerType = $ params [ 1 ] -> getClass ( ) ; } catch ( \ ReflectionException $ e ) { throw new \ InvalidArgumentException ( \ sprintf ( 'Marker class not found: %s' , $ params [ 1 ] -> getType ( ) ) , 0 , $ e ) ; } if ( $ markerType === null ) { throw new \ InvalidArgumentException ( \ sprintf ( 'Argument #2 of marker callback needs to declare a type-hint for the marker' ) ) ; } $ marker = $ markerType -> getName ( ) ; if ( ! $ markerType -> isSubclassOf ( Marker :: class ) ) { throw new \ InvalidArgumentException ( \ sprintf ( 'Marker implementation %s must extend %s' , $ marker , Marker :: class ) ) ; } if ( ! isset ( $ this -> marked [ $ marker ] ) ) { $ this -> cacheMarkers ( $ marker ) ; } foreach ( $ this -> marked [ $ marker ] as list ( $ definition , $ registration ) ) { $ result = $ callback ( $ this -> shared [ $ definition -> typeName ] ?? $ this -> get ( $ definition -> typeName ) , clone $ registration , $ result ) ; } return $ result ; }
9628	protected function validateParams ( Route $ route , array $ params , array $ requiredParams ) { $ identifier = $ this -> getRouteIdentifier ( $ route ) ; $ givenParams = array_keys ( $ params ) ; $ missingParams = array_diff ( $ requiredParams , $ givenParams ) ; if ( count ( $ missingParams ) > 0 ) { throw new \ InvalidArgumentException ( sprintf ( 'Error while validating params "%s": Required parameters "%s" are missing' , $ identifier , implode ( ', ' , $ missingParams ) ) ) ; } if ( ! $ this -> matchParams ( $ route , $ params ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Error while validing params for target "%s": Params don\'t fulfill their matcher\'s criteria' , $ identifier ) ) ; } }
6538	public function init ( ) { Html :: addCssClass ( $ this -> options , [ 'panel' , 'sx-panel' , $ this -> color ] ) ; $ options = ArrayHelper :: merge ( $ this -> options , [ 'id' => $ this -> id , ] ) ; echo Html :: beginTag ( 'div' , $ options ) ; echo Html :: beginTag ( 'div' , $ this -> headingOptions ) ; echo <<<HTML <div class="pull-left"> <h2> {$this->name} </h2> </div> <div class="panel-actions panel-hidden-actions"> {$this->actions} </div>HTML ; echo Html :: endTag ( 'div' ) ; echo Html :: beginTag ( 'div' , $ this -> bodyOptions ) ; echo $ this -> content ; }
11518	protected function GenerateHTML5Favicon ( SiteTree $ owner , & $ metadata , Image $ HTML5Favicon ) { $ metadata .= $ owner -> MarkupComment ( 'HTML5 Favicon' ) ; $ metadata .= $ owner -> MarkupLink ( 'icon' , $ HTML5Favicon -> Fill ( 192 , 192 ) -> getAbsoluteURL ( ) , 'image/png' , '192x192' ) ; $ metadata .= $ owner -> MarkupLink ( 'icon' , $ HTML5Favicon -> Fill ( 128 , 128 ) -> getAbsoluteURL ( ) , 'image/png' , '128x128' ) ; $ metadata .= $ owner -> MarkupLink ( 'icon' , $ HTML5Favicon -> Fill ( 96 , 96 ) -> getAbsoluteURL ( ) , 'image/png' , '96x96' ) ; $ metadata .= $ owner -> MarkupLink ( 'icon' , $ HTML5Favicon -> Fill ( 32 , 32 ) -> getAbsoluteURL ( ) , 'image/png' , '32x32' ) ; $ metadata .= $ owner -> MarkupLink ( 'icon' , $ HTML5Favicon -> Fill ( 16 , 16 ) -> getAbsoluteURL ( ) , 'image/png' , '16x16' ) ; }
8455	protected function argsForNextCommand ( $ args ) { if ( ! is_array ( $ args ) ) { $ args = func_get_args ( ) ; } $ this -> argumentsForNextCommand .= ' ' . implode ( ' ' , $ args ) ; return $ this ; }
12767	public function set ( string $ key , $ value ) : self { $ this -> store [ $ key ] = $ value ; return self :: $ instance ; }
182	protected function publishFile ( $ src ) { $ dir = $ this -> hash ( $ src ) ; $ fileName = basename ( $ src ) ; $ dstDir = $ this -> basePath . DIRECTORY_SEPARATOR . $ dir ; $ dstFile = $ dstDir . DIRECTORY_SEPARATOR . $ fileName ; if ( ! is_dir ( $ dstDir ) ) { FileHelper :: createDirectory ( $ dstDir , $ this -> dirMode , true ) ; } if ( $ this -> linkAssets ) { if ( ! is_file ( $ dstFile ) ) { try { symlink ( $ src , $ dstFile ) ; } catch ( \ Exception $ e ) { if ( ! is_file ( $ dstFile ) ) { throw $ e ; } } } } elseif ( @ filemtime ( $ dstFile ) < @ filemtime ( $ src ) ) { copy ( $ src , $ dstFile ) ; if ( $ this -> fileMode !== null ) { @ chmod ( $ dstFile , $ this -> fileMode ) ; } } if ( $ this -> appendTimestamp && ( $ timestamp = @ filemtime ( $ dstFile ) ) > 0 ) { $ fileName = $ fileName . "?v=$timestamp" ; } return [ $ dstFile , $ this -> baseUrl . "/$dir/$fileName" ] ; }
10373	public static function unify ( $ id , $ params , $ minify = '' ) { self :: $ id = $ id ; self :: $ unify = $ params ; self :: $ minify = $ minify ; return true ; }
3445	private function getAccessor ( $ field ) { $ method = 'get' . camel_case ( $ field ) . 'Attribute' ; return method_exists ( $ this , $ method ) ? $ method : false ; }
4610	public function geo ( $ sLat , $ sLon , $ iHeight ) { $ this -> sData .= 'GEO:' . $ sLat . ',' . $ sLon . ',' . $ iHeight . "\n" ; return $ this ; }
12552	private function addHeaders ( ) { self :: response ( ) -> addHeader ( 'Cache-Control' , 'no-cache, no-store, must-revalidate' ) ; self :: response ( ) -> addHeader ( 'Pragma' , 'no-cache' ) ; self :: response ( ) -> addHeader ( 'Expires' , '-1' ) ; }
3324	public function advance ( ) { if ( $ this -> index >= $ this -> length ) { throw new LogicException ( "Argument index out of bounds." ) ; } return $ this -> argv [ $ this -> index ++ ] ; }
8337	public function values ( $ values ) { if ( is_array ( $ values ) === true ) { if ( is_numeric ( key ( $ values ) ) === true ) { $ this -> values = array ( null , implode ( ', ' , $ values ) ) ; } else { $ this -> values = array ( '' , '' ) ; foreach ( $ values as $ key => $ value ) { if ( stripos ( $ key , '.' ) !== false ) { $ key = substr ( $ key , stripos ( $ key , '.' ) + 1 ) ; } $ this -> values [ 0 ] .= $ key . ', ' ; $ this -> values [ 1 ] .= $ value . ', ' ; } $ this -> values [ 0 ] = substr ( $ this -> values [ 0 ] , 0 , - 2 ) ; $ this -> values [ 1 ] = substr ( $ this -> values [ 1 ] , 0 , - 2 ) ; } } else { $ this -> values = array ( null , $ values ) ; } return $ this ; }
2049	private function executeHook ( string $ message , ContaoContext $ context ) : void { if ( null === $ this -> container || ! $ this -> container -> has ( 'contao.framework' ) ) { return ; } $ framework = $ this -> container -> get ( 'contao.framework' ) ; if ( ! $ this -> hasAddLogEntryHook ( ) || ! $ framework -> isInitialized ( ) ) { return ; } @ trigger_error ( 'Using the addLogEntry hook has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; $ system = $ framework -> getAdapter ( System :: class ) ; $ func = $ context -> getFunc ( ) ; $ action = $ context -> getAction ( ) ; foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'addLogEntry' ] as $ callback ) { $ system -> importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ message , $ func , $ action ) ; } }
1908	private function getArgumentName ( Request $ request , ArgumentMetadata $ argument ) : ? string { if ( $ request -> attributes -> has ( $ argument -> getName ( ) ) ) { return $ argument -> getName ( ) ; } $ className = lcfirst ( $ this -> stripNamespace ( $ argument -> getType ( ) ) ) ; if ( $ request -> attributes -> has ( $ className ) ) { return $ className ; } return null ; }
129	protected function requestContent ( $ origin , $ path ) { $ url = rtrim ( $ origin , '/' ) . '/' . ltrim ( $ path , '/' ) ; $ content = $ this -> rfs -> getContents ( $ origin , $ url , false ) ; if ( ! $ content ) { throw new \ UnexpectedValueException ( 'The PEAR channel at ' . $ url . ' did not respond.' ) ; } return str_replace ( 'http://pear.php.net/rest/' , 'https://pear.php.net/rest/' , $ content ) ; }
6380	public function readAttempt ( $ id ) { $ model = $ this -> readObject ( $ id , 'quiz_attempts' ) ; $ model -> url = $ this -> cfg -> wwwroot . '/mod/quiz/attempt.php?attempt=' . $ id ; $ model -> name = 'Attempt ' . $ id ; return $ model ; }
6519	private function unFreeze ( ) { $ this -> isFrozen = false ; $ this -> isReplay = null ; foreach ( static :: schema ( ) -> getFields ( ) as $ field ) { if ( $ field -> getType ( ) -> isMessage ( ) ) { $ value = $ this -> get ( $ field -> getName ( ) ) ; if ( empty ( $ value ) ) { continue ; } if ( $ value instanceof Message ) { $ value -> unFreeze ( ) ; continue ; } foreach ( $ value as $ v ) { $ v -> unFreeze ( ) ; } } } }
10888	public function addOption ( $ short , $ long , $ arg , $ description ) { $ this -> parameters [ ] = array ( $ short , $ long , $ arg , $ description ) ; return $ this ; }
1664	protected function getCountries ( ) { if ( sizeof ( $ this -> countries ) == 0 ) { $ this -> countries = json_decode ( file_get_contents ( __DIR__ . '/Models/countries.json' ) , true ) ; } return $ this -> countries ; }
7480	public function getMime ( ) { $ this -> absolute ( ) ; if ( function_exists ( 'mime_content_type' ) ) { return mime_content_type ( $ this -> data ) ; } if ( function_exists ( 'finfo_open' ) ) { $ resource = finfo_open ( FILEINFO_MIME_TYPE ) ; $ mime = finfo_file ( $ resource , $ this -> data ) ; finfo_close ( $ finfo ) ; return $ mime ; } $ extension = strtolower ( $ this -> getExtension ( ) ) ; $ types = self :: $ mimeTypes ; if ( isset ( $ types [ $ extension ] ) ) { return $ types [ $ extension ] ; } return $ types [ 'class' ] ; }
1836	public static function findMultipleByIds ( $ arrIds , array $ arrOptions = array ( ) ) { if ( empty ( $ arrIds ) || ! \ is_array ( $ arrIds ) ) { return null ; } $ arrRegistered = array ( ) ; $ arrUnregistered = array ( ) ; foreach ( $ arrIds as $ intId ) { if ( empty ( $ arrOptions ) ) { $ arrRegistered [ $ intId ] = Registry :: getInstance ( ) -> fetch ( static :: $ strTable , $ intId ) ; } if ( ! isset ( $ arrRegistered [ $ intId ] ) ) { $ arrUnregistered [ ] = $ intId ; } } if ( ! empty ( $ arrUnregistered ) ) { $ t = static :: $ strTable ; $ arrOptions = array_merge ( array ( 'column' => array ( "$t.id IN(" . implode ( ',' , array_map ( '\intval' , $ arrUnregistered ) ) . ")" ) , 'value' => null , 'order' => Database :: getInstance ( ) -> findInSet ( "$t.id" , $ arrIds ) , 'return' => 'Collection' ) , $ arrOptions ) ; $ objMissing = static :: find ( $ arrOptions ) ; if ( $ objMissing !== null ) { while ( $ objMissing -> next ( ) ) { $ intId = $ objMissing -> { static :: $ strPk } ; $ arrRegistered [ $ intId ] = $ objMissing -> current ( ) ; } } } $ arrRegistered = array_filter ( array_values ( $ arrRegistered ) ) ; if ( empty ( $ arrRegistered ) ) { return null ; } return static :: createCollection ( $ arrRegistered , static :: $ strTable ) ; }
7550	function wrapInner ( $ node , $ start = 0 , $ end = - 1 , $ wrap_index = - 1 , $ node_index = null ) { if ( $ end < 0 ) { $ end += count ( $ this -> children ) ; } if ( $ node_index === null ) { $ node_index = $ end + 1 ; } if ( ! is_object ( $ node ) ) { $ node = $ this -> addChild ( $ node , $ node_index ) ; } elseif ( $ node -> parent !== $ this ) { $ node -> changeParent ( $ this -> parent , $ node_index ) ; } $ this -> moveChildren ( $ node , $ wrap_index , $ start , $ end ) ; return $ node ; }
4995	public function getActiveFormNext ( ) { $ key = null ; $ actualKey = $ this -> getActiveFormActual ( ) ; if ( isset ( $ actualKey ) ) { $ forms = array_keys ( $ this -> forms ) ; $ formsFlip = array_flip ( $ forms ) ; $ index = $ formsFlip [ $ actualKey ] ; if ( $ index < count ( $ forms ) - 1 ) { $ key = $ forms [ $ index + 1 ] ; } } return $ key ; }
5254	public static function destroy ( $ id ) { $ ids = is_array ( $ id ) ? $ id : [ $ id ] ; foreach ( $ ids as $ id ) { $ model = static :: find ( $ id ) ; if ( ! is_null ( $ model ) ) { $ model -> delete ( ) ; } } }
12196	public static function current ( ) { if ( defined ( 'PHPUNIT_RUNNING' ) ) { return 'http://localhost' ; } $ protocol = 'http://' ; if ( ! empty ( $ _SERVER [ 'HTTPS' ] ) || ( ! empty ( $ _SERVER [ 'HTTP_X_FORWARDED_PROTO' ] ) && $ _SERVER [ 'HTTP_X_FORWARDED_PROTO' ] === 'https' ) ) { $ protocol = 'https://' ; } return $ protocol . request ( ) -> server ( 'HTTP_HOST' ) . request ( ) -> server ( 'REQUEST_URI' ) ; }
9148	public function markAsRead ( $ uid ) { if ( ! $ object = $ this -> model -> find ( $ uid ) ) { abort ( 404 ) ; } $ this -> authorize ( 'update' , $ object ) ; $ object -> markAsRead ( ) ; \ Cache :: tags ( 'response' ) -> flush ( ) ; return $ this -> successJsonResponse ( ) ; }
2871	public function getModules ( ) { $ items = array ( ) ; $ items [ ] = array ( 'module' => 'Magento' , 'codePool' => 'core' , 'active' => true , 'version' => $ this -> getMagentoVersion ( ) ) ; $ modulesConfig = Mage :: getConfig ( ) -> getModuleConfig ( ) ; foreach ( $ modulesConfig as $ node ) { foreach ( $ node as $ module => $ data ) { $ items [ ] = array ( 'module' => $ module , 'codePool' => ( string ) $ data -> codePool , 'active' => $ data -> active == 'true' , 'version' => ( string ) $ data -> version ) ; } } return $ items ; }
9220	protected function requestAllPages ( $ forceRefresh = false ) { $ _page = $ this -> page ; $ _key = $ this -> key ; $ nextPageNumber = false ; if ( isset ( $ this -> pagination [ CanvasPageLink :: NEXT ] ) ) { $ nextPageNumber = $ this -> pagination [ CanvasPageLink :: NEXT ] -> getPageNumber ( ) ; } while ( $ nextPageNumber !== false ) { $ this -> requestPageNumber ( $ nextPageNumber , $ forceRefresh ) ; if ( isset ( $ this -> paginationPerPage [ $ nextPageNumber ] [ CanvasPageLink :: NEXT ] ) ) { $ nextPageNumber = $ this -> paginationPerPage [ $ nextPageNumber ] [ CanvasPageLink :: NEXT ] -> getPageNumber ( ) ; } else { $ nextPageNumber = false ; } } $ this -> page = $ _page ; $ this -> key = $ _key ; }
7634	public function putBlockList ( $ containerName = '' , $ blobName = '' , $ blockList = array ( ) , $ metadata = array ( ) , $ leaseId = null , $ additionalHeaders = array ( ) ) { Assertion :: notEmpty ( $ containerName , 'Container name is not specified' ) ; self :: assertValidContainerName ( $ containerName ) ; Assertion :: notEmpty ( $ blobName , 'Blob name is not specified.' ) ; Assertion :: notEmpty ( $ blockList , 'Block list does not contain any elements.' ) ; self :: assertValidRootContainerBlobName ( $ containerName , $ blobName ) ; $ blocks = '' ; foreach ( $ blockList as $ block ) { $ blocks .= ' <Latest>' . base64_encode ( $ block ) . '</Latest>' . "\n" ; } $ fileContents = utf8_encode ( implode ( "\n" , array ( '<?xml version="1.0" encoding="utf-8"?>' , '<BlockList>' , $ blocks , '</BlockList>' ) ) ) ; $ headers = array ( ) ; if ( ! is_null ( $ leaseId ) ) { $ headers [ 'x-ms-lease-id' ] = $ leaseId ; } $ headers = array_merge ( $ headers , $ this -> generateMetadataHeaders ( $ metadata ) ) ; foreach ( $ additionalHeaders as $ key => $ value ) { $ headers [ $ key ] = $ value ; } $ resourceName = self :: createResourceName ( $ containerName , $ blobName ) ; $ response = $ this -> performRequest ( $ resourceName , array ( 'comp' => 'blocklist' ) , 'PUT' , $ headers , false , $ fileContents , self :: RESOURCE_BLOB , self :: PERMISSION_WRITE ) ; if ( ! $ response -> isSuccessful ( ) ) { throw new BlobException ( $ this -> getErrorMessage ( $ response , 'Resource could not be accessed.' ) ) ; } }
9611	public function getAssetUrl ( $ path , $ relative = false ) { if ( substr ( $ path , 0 , 1 ) !== '/' ) { $ path = '/' . $ path ; } if ( $ this -> assetRoot !== null ) { $ base = $ this -> assetRoot ; } else if ( $ relative ) { $ base = $ this -> requests -> getCurrentRequest ( ) -> getBaseUrl ( ) ; } else { $ base = $ this -> getRootUrl ( ) ; } return $ base . $ path ; }
1493	public function index ( $ resourceType , $ meta = null , array $ queryParams = [ ] ) { return $ this -> factory -> createLink ( $ this -> urls -> index ( $ resourceType , $ queryParams ) , $ meta , true ) ; }
9234	public function actionUpdate ( $ id ) { $ model = $ this -> findModel ( $ id ) ; $ model -> tags = ! empty ( $ model -> tags ) ? explode ( "," , $ model -> tags ) : [ ] ; if ( Yii :: $ app -> request -> post ( ) ) { $ post = Yii :: $ app -> request -> post ( ) ; $ category = [ ] ; if ( isset ( $ post [ 'Post' ] [ 'category' ] ) ) { $ category = $ post [ 'Post' ] [ 'category' ] ; } if ( is_array ( $ post [ 'Post' ] [ 'tags' ] ) ) { $ post [ 'Post' ] [ 'tags' ] = implode ( "," , $ post [ 'Post' ] [ 'tags' ] ) ; } $ model -> load ( $ post ) ; $ transaction = Yii :: $ app -> db -> beginTransaction ( ) ; try { if ( $ model -> save ( ) ) { $ cs = BlogCatPos :: deleteAll ( "post_id = :id" , [ "id" => $ model -> id ] ) ; foreach ( $ category as $ d ) { $ c = new BlogCatPos ( ) ; $ c -> post_id = $ model -> id ; $ c -> category_id = $ d ; $ c -> isdel = 0 ; $ c -> save ( ) ; } $ transaction -> commit ( ) ; return $ this -> redirect ( [ 'view' , 'id' => $ model -> id ] ) ; } else { $ transaction -> rollBack ( ) ; } } catch ( Exception $ e ) { $ transaction -> rollBack ( ) ; } } return $ this -> render ( 'update' , [ 'model' => $ model , ] ) ; }
6545	public function create ( $ name ) { $ sheet = $ this -> container -> createSheet ( ) ; $ sheet -> setTitle ( $ name ) ; return new \ Aimeos \ MW \ Container \ Content \ PHPExcel ( $ sheet , $ name , $ this -> getOptions ( ) ) ; }
5465	public function addRealm ( $ url , $ type , $ realm ) { $ this -> realms [ $ url -> getHost ( ) ] [ $ realm ] = new SimpleRealm ( $ type , $ url ) ; }
10984	public static function getHostId ( ) { if ( self :: isWindows ( ) ) { $ uuid = explode ( "\r\n" , trim ( shell_exec ( 'wmic csproduct get UUID' ) ) ) ; return ( \ count ( $ uuid ) === 2 ? $ uuid [ 1 ] : false ) ; } $ uuid = trim ( shell_exec ( 'hostid' ) ) ; return $ uuid === null ? false : $ uuid ; }
1683	public function getModules ( ) { $ arrModules = array ( ) ; foreach ( $ GLOBALS [ 'BE_MOD' ] as $ k => $ v ) { if ( ! empty ( $ v ) ) { if ( $ k == 'accounts' ) { unset ( $ v [ 'login' ] ) ; } if ( $ k == 'system' ) { unset ( $ v [ 'undo' ] ) ; } $ arrModules [ $ k ] = array_keys ( $ v ) ; } } return $ arrModules ; }
3432	protected function normalizeSelect ( ) { if ( $ this -> fieldsMustBeSelected ( ) ) { $ this -> select = array_merge ( $ this -> standardFields , $ this -> select ) ; } if ( $ this -> propsMustBeSelected ( ) ) { $ this -> select [ ] = 'IBLOCK_ID' ; $ this -> select [ ] = 'UF_*' ; } $ this -> select [ ] = 'ID' ; return $ this -> clearSelectArray ( ) ; }
3638	public function env ( Output $ output ) : void { $ info = [ 'OS' => \ PHP_OS , 'Php version' => \ PHP_VERSION , 'Swoole version' => \ SWOOLE_VERSION , 'Swoft version' => \ Swoft :: VERSION , 'App Name' => \ config ( 'name' , 'unknown' ) , 'Base Path' => \ BASE_PATH , ] ; Show :: aList ( $ info , 'System Environment Info' ) ; }
5345	public function requestAccess ( $ when , $ duration , array $ visitors , $ phoneNumber ) { return $ this -> call ( self :: SERVICE , 'requestAccess' , [ $ when , $ duration , $ visitors , $ phoneNumber ] ) ; }
7382	public static function toInsert ( $ input , array $ include = [ ] ) { if ( is_object ( $ input ) ) { if ( method_exists ( $ input , 'toArray' ) ) { $ input = $ input -> toArray ( ) ; } elseif ( $ input instanceof \ Traversable ) { $ input = iterator_to_array ( $ input ) ; } else { $ input = ( array ) $ input ; } } elseif ( ! is_array ( $ input ) ) { throw new InvalidArgumentException ( 'input must be an associative array or traversable object' ) ; } if ( count ( $ include ) ) { $ arr = [ ] ; foreach ( $ include as $ i ) { if ( isset ( $ input [ $ i ] ) ) { $ arr [ $ i ] &= $ input [ $ i ] ; } } } else { $ arr = & $ input ; } $ sqlStrs = [ ] ; foreach ( $ arr as $ k => & $ v ) { $ kEq = '`' . $ k . '` = ' ; switch ( gettype ( $ v ) ) { case 'bool' : case 'boolean' : $ sqlStrs [ ] = $ kEq . ( $ v ? '1' : '0' ) ; break ; case 'int' : case 'integer' : case 'float' : case 'double' : $ sqlStrs [ ] = $ kEq . $ v ; break ; case 'string' : if ( $ v === 'NULL' ) { $ sqlStrs [ ] = $ kEq . 'NULL' ; } else { $ sqlStrs [ ] = $ kEq . '"' . addslashes ( $ v ) . '"' ; } break ; case 'null' : case 'NULL' : $ sqlStrs [ ] = $ kEq . 'NULL' ; break ; case 'object' : if ( $ v instanceof DateTime ) { $ sqlStrs [ ] = $ kEq . '"' . $ v . '"' ; break ; } case 'array' : $ sqlStrs [ ] = $ kEq . '"' . addslashes ( json_encode ( $ v ) ) . '"' ; $ jsonLastErr = json_last_error ( ) ; if ( $ jsonLastErr !== JSON_ERROR_NONE ) { throw new UnexpectedValueException ( json_last_error_msg ( ) , $ jsonLastErr ) ; } break ; default : break ; } } return implode ( ",\n" , $ sqlStrs ) ; }
6840	public function getData ( $ key ) { if ( isset ( $ this -> data [ $ key ] ) ) { return $ this -> data [ $ key ] ; } throw new InjectorException ( "data $key not found" ) ; }
11446	public function getSpooler ( ) { if ( empty ( $ this -> spooler ) ) { $ spool_class = $ this -> getDefault ( 'spooler' ) ; if ( class_exists ( $ spool_class ) ) { $ this -> setSpooler ( new $ spool_class ) ; } else { throw new \ Exception ( sprintf ( 'Default spool class "%s" not found!' , $ spool_class ) ) ; } } return $ this -> spooler ; }
11765	public function remove ( ExpressionContract $ e ) { unset ( $ this -> expressions [ $ this -> indexOf ( $ e ) ] ) ; $ this -> expressions = array_values ( $ this -> expressions ) ; return $ this ; }
7733	public function onKernelView ( GetResponseForControllerResultEvent $ event ) { $ request = $ event -> getRequest ( ) ; $ result = $ event -> getControllerResult ( ) ; if ( ! $ request -> attributes -> get ( '__hydra_serialize' ) ) { return ; } if ( is_array ( $ result ) || ( $ result instanceof \ ArrayAccess ) || ( $ result instanceof \ Traversable ) ) { $ result = new Collection ( $ request -> getUri ( ) , $ result ) ; } elseif ( null === $ result ) { $ event -> setResponse ( new JsonLdResponse ( '' , 200 ) ) ; return ; } elseif ( ! is_object ( $ result ) ) { throw new \ Exception ( "A Hydra controller must return either an array or an object, got a(n) " . gettype ( $ result ) ) ; } $ serialized = $ this -> serializer -> serialize ( $ result , 'jsonld' ) ; $ event -> setResponse ( new JsonLdResponse ( $ serialized ) ) ; }
2858	public function layoutUpdatesAction ( ) { $ token = $ this -> getRequest ( ) -> getParam ( 'token' ) ; if ( ! $ token ) { return $ this -> getResponse ( ) -> setHttpResponseCode ( 400 ) -> setBody ( 'Invalid parameters' ) ; } $ requestProfile = Mage :: getModel ( 'sheep_debug/requestInfo' ) -> load ( $ token , 'token' ) ; if ( ! $ requestProfile -> getId ( ) ) { return $ this -> getResponse ( ) -> setHttpResponseCode ( 404 ) -> setBody ( 'Request profile not found' ) ; } $ layoutUpdates = $ requestProfile -> getDesign ( ) -> getLayoutUpdates ( ) ; $ this -> renderArray ( $ layoutUpdates , 'No Data' , array ( '#' , 'XML' ) ) ; }
10990	public function hasExtension ( string $ extension ) : bool { $ test = $ this -> getExtension ( ) ; return ( strcasecmp ( $ extension , $ test ) === 0 ) ; }
1110	protected function keyForScope ( $ node ) { return implode ( '-' , array_map ( function ( $ column ) use ( $ node ) { $ value = $ node -> getAttribute ( $ column ) ; if ( is_null ( $ value ) ) return 'NULL' ; return $ value ; } , $ node -> getScopedColumns ( ) ) ) ; }
195	public function sendContentAsFile ( $ content , $ attachmentName , $ options = [ ] ) { $ headers = $ this -> getHeaders ( ) ; $ contentLength = StringHelper :: byteLength ( $ content ) ; $ range = $ this -> getHttpRange ( $ contentLength ) ; if ( $ range === false ) { $ headers -> set ( 'Content-Range' , "bytes */$contentLength" ) ; throw new RangeNotSatisfiableHttpException ( ) ; } list ( $ begin , $ end ) = $ range ; if ( $ begin != 0 || $ end != $ contentLength - 1 ) { $ this -> setStatusCode ( 206 ) ; $ headers -> set ( 'Content-Range' , "bytes $begin-$end/$contentLength" ) ; $ this -> content = StringHelper :: byteSubstr ( $ content , $ begin , $ end - $ begin + 1 ) ; } else { $ this -> setStatusCode ( 200 ) ; $ this -> content = $ content ; } $ mimeType = isset ( $ options [ 'mimeType' ] ) ? $ options [ 'mimeType' ] : 'application/octet-stream' ; $ this -> setDownloadHeaders ( $ attachmentName , $ mimeType , ! empty ( $ options [ 'inline' ] ) , $ end - $ begin + 1 ) ; $ this -> format = self :: FORMAT_RAW ; return $ this ; }
6123	public function login ( $ username , $ password ) { $ this -> execute ( "login" , array ( "client_login_name" => $ username , "client_login_password" => $ password ) ) ; $ this -> whoamiReset ( ) ; $ crypt = new Crypt ( $ username ) ; $ this -> setStorage ( "_login_user" , $ username ) ; $ this -> setStorage ( "_login_pass" , $ crypt -> encrypt ( $ password ) ) ; Signal :: getInstance ( ) -> emit ( "notifyLogin" , $ this ) ; }
10679	private function _sklStd ( $ slovo , $ ii , $ zivotne ) { if ( $ ii < 0 || $ ii > \ count ( $ this -> vzor ) ) { $ this -> astrTvar [ 0 ] = '!!!???' ; } $ count = \ count ( $ this -> v0 ) ; for ( $ jj = 0 ; $ jj < $ count ; $ jj ++ ) { if ( $ this -> _isShoda ( $ this -> v0 [ $ jj ] , $ slovo ) >= 0 ) { return null ; } } $ this -> astrTvar [ 0 ] = $ this -> vzor [ $ ii ] [ 0 ] ; for ( $ jj = 1 ; $ jj < 15 ; $ jj ++ ) { $ this -> astrTvar [ $ jj ] = $ this -> _sklon ( $ jj , $ ii , $ slovo , $ zivotne ) ; } $ count = \ count ( $ this -> v3 ) ; for ( $ jj = 0 ; $ jj < $ count ; $ jj ++ ) { if ( $ this -> _isShoda ( $ this -> v3 [ $ jj ] , $ slovo ) >= 0 ) { return ; } } }
1576	public function register ( $ apiName , $ options = [ ] , Closure $ routes = null ) : ApiRegistration { $ registrar = $ this -> container -> make ( 'json-api.registrar' ) ; return $ registrar -> api ( $ apiName , $ options , $ routes ) ; }
11717	public static function load ( string $ dir ) : void { self :: initialize ( ) ; $ commandDir = $ _SERVER [ 'DOCUMENT_ROOT' ] . $ dir ; $ files = scandir ( $ commandDir ) ; foreach ( $ files as $ file ) { if ( $ file == '.' || $ file == '..' ) { continue ; } require_once $ _SERVER [ 'DOCUMENT_ROOT' ] . $ dir . '/' . $ file ; } }
5601	public function paintPass ( $ message ) { if ( ! $ this -> pass ) { $ this -> message = self :: escapeVal ( $ message ) ; } $ this -> pass = true ; }
10213	public function getSharedComponent ( ) { switch ( $ this -> parentPropertyName ) { case 'allBorders' : case 'horizontal' : case 'inside' : case 'outline' : case 'vertical' : throw new PhpSpreadsheetException ( 'Cannot get shared component for a pseudo-border.' ) ; break ; case 'bottom' : return $ this -> parent -> getSharedComponent ( ) -> getBottom ( ) ; case 'diagonal' : return $ this -> parent -> getSharedComponent ( ) -> getDiagonal ( ) ; case 'left' : return $ this -> parent -> getSharedComponent ( ) -> getLeft ( ) ; case 'right' : return $ this -> parent -> getSharedComponent ( ) -> getRight ( ) ; case 'top' : return $ this -> parent -> getSharedComponent ( ) -> getTop ( ) ; } }
2774	public function setPrivateKey ( string $ privateKey , int $ port = 22 , ? string $ wrapper = null ) : void { if ( $ wrapper === null ) { $ wrapper = __DIR__ . '/../bin/git-ssh-wrapper.sh' ; } if ( ! $ wrapperPath = realpath ( $ wrapper ) ) { throw new GitException ( 'Path to GIT_SSH wrapper script could not be resolved: ' . $ wrapper ) ; } if ( ! $ privateKeyPath = realpath ( $ privateKey ) ) { throw new GitException ( 'Path private key could not be resolved: ' . $ privateKey ) ; } $ this -> setEnvVar ( 'GIT_SSH' , $ wrapperPath ) ; $ this -> setEnvVar ( 'GIT_SSH_KEY' , $ privateKeyPath ) ; $ this -> setEnvVar ( 'GIT_SSH_PORT' , $ port ) ; }
11055	public function getBundle ( $ name , $ publish = true ) { if ( $ this -> bundles === false ) { return $ this -> loadDummyBundle ( $ name ) ; } elseif ( ! isset ( $ this -> bundles [ $ name ] ) ) { return $ this -> bundles [ $ name ] = $ this -> loadBundle ( $ name , [ ] , $ publish ) ; } elseif ( $ this -> bundles [ $ name ] instanceof AssetBundle ) { return $ this -> bundles [ $ name ] ; } elseif ( is_array ( $ this -> bundles [ $ name ] ) ) { return $ this -> bundles [ $ name ] = $ this -> loadBundle ( $ name , $ this -> bundles [ $ name ] , $ publish ) ; } elseif ( $ this -> bundles [ $ name ] === false ) { return $ this -> loadDummyBundle ( $ name ) ; } else { throw new InvalidConfigException ( "Invalid asset bundle configuration: $name" ) ; } }
6599	protected function getReturnType ( array $ lines ) { foreach ( $ lines as $ line ) { if ( strpos ( $ line , '@return' ) === 0 ) { $ type = trim ( str_replace ( '@return' , '' , $ line ) ) ; $ type = str_replace ( '$this' , 'self' , $ type ) ; $ type = explode ( '|' , $ type ) ; return $ type ; } } return [ ] ; }
4541	public function set ( string $ key , $ value ) { $ config = $ this -> repository -> findOneBy ( [ 'key' => $ key ] ) ; if ( ! $ config ) { throw new OutOfRangeException ( 'Config "' . $ key . '" does not exist.' ) ; } $ config -> setKey ( $ key ) -> setValue ( $ value ) ; $ this -> manager -> persist ( $ config ) ; $ this -> manager -> flush ( ) ; $ this -> manager -> detach ( $ config ) ; }
10727	public function getYear ( ) { if ( $ this -> value !== null ) { preg_match ( '/^(?P<year>[0-9]{4,4})-(?P<month>[0-9]{2,2})-(?P<day>[0-9]{2,2}) (?P<hour>[0-9]{2,2}):(?P<minute>[0-9]{2,2}):(?P<second>[0-9]{2,2})$/ui' , $ this -> value , $ m ) ; return ( int ) $ m [ 'year' ] ; } }
6699	public function setBuild ( $ build ) { $ this -> build = array_values ( ( array ) $ build ) ; array_walk ( $ this -> build , function ( & $ v ) { if ( preg_match ( '/^[0-9]+$/' , $ v ) ) { $ v = ( int ) $ v ; } } ) ; }
1669	public function delete ( ) { $ this -> Files -> rrdir ( $ this -> strFolder ) ; if ( Dbafs :: shouldBeSynchronized ( $ this -> strFolder ) ) { Dbafs :: deleteResource ( $ this -> strFolder ) ; } }
8350	public function perform ( array $ args = [ ] ) : int { $ transport = new Swift_SmtpTransport ( $ args [ 'smtp' ] [ 'host' ] , $ args [ 'smtp' ] [ 'port' ] ) ; $ transport -> setUsername ( $ args [ 'smtp' ] [ 'username' ] ) ; $ transport -> setPassword ( $ args [ 'smtp' ] [ 'password' ] ) ; $ mailer = new Swift_Mailer ( $ transport ) ; $ message = ( new Swift_Message ( $ args [ 'subject' ] ) ) -> setFrom ( [ $ args [ 'from' ] [ 'email' ] => $ args [ 'from' ] [ 'email' ] ] ) -> setTo ( [ $ args [ 'to' ] [ 'email' ] => $ args [ 'to' ] [ 'name' ] ] ) -> setBody ( $ args [ 'message' ] ) ; $ result = $ mailer -> send ( $ message ) ; return $ result === 1 ; }
5250	public function save ( $ columns = [ '*' ] ) { $ columns = $ columns ? ( array ) $ columns : [ '*' ] ; if ( $ this -> saving ( ) === false ) { return false ; } $ this -> fillTimestamp ( ) ; $ this -> _dal -> put ( $ columns ) ; $ this -> _exist = true ; if ( $ this -> saved ( ) === false ) { return false ; } return true ; }
5799	public function selectArrayWithRolesString ( string $ columns = "*" , array $ whereColumnsInfo = null ) : array { $ administrators = [ ] ; $ results = $ this -> selectArray ( $ columns , $ whereColumnsInfo ) ; foreach ( $ results as $ index => $ administrator ) { $ administrators [ $ index ] = $ administrator ; $ administrators [ $ index ] [ 'roles' ] = implode ( ", " , $ administrators [ $ index ] [ 'roles' ] ) ; } return $ administrators ; }
9049	private function renderButtons ( $ rendered , $ buttons ) { foreach ( $ buttons as $ button ) { if ( ! isset ( $ button [ 'name' ] ) ) { throw new ControlException ( "Button must have at least a name!" ) ; } $ buttonType = isset ( $ button [ 'type' ] ) ? $ button [ 'type' ] : "submit" ; $ id = isset ( $ button [ 'id' ] ) ? $ button [ 'id' ] : $ button [ 'name' ] ; $ class = isset ( $ button [ 'class' ] ) ? $ button [ 'class' ] : $ button [ 'name' ] ; $ label = isset ( $ button [ 'label' ] ) ? $ button [ 'label' ] : $ button [ 'name' ] ; $ rendered .= sprintf ( '<button type="%s" id="%s" class="%s" name="%s">%s</button>' , $ buttonType , $ id , $ class , $ button [ 'name' ] , $ label ) ; } return $ rendered ; }
6479	public function getClientIPAddress ( IHttpRequestMessage $ request ) : ? string { $ clientIPAddress = null ; $ request -> getProperties ( ) -> tryGet ( self :: CLIENT_IP_ADDRESS_PROPERTY , $ clientIPAddress ) ; return $ clientIPAddress ; }
12465	private function getOptionsAvailable ( $ entity ) { $ options = $ this -> getParameter ( 'chill_custom_fields.' . 'customizables_entities' ) ; foreach ( $ options as $ key => $ definition ) { if ( $ definition [ 'class' ] == $ entity ) { foreach ( $ definition [ 'options' ] as $ key => $ value ) { yield $ key ; } } } }
10039	public function trySimpleXMLLoadString ( $ pFilename ) { try { $ xml = simplexml_load_string ( $ this -> securityScan ( file_get_contents ( $ pFilename ) ) , 'SimpleXMLElement' , Settings :: getLibXmlLoaderOptions ( ) ) ; } catch ( \ Exception $ e ) { throw new Exception ( 'Cannot load invalid XML file: ' . $ pFilename , 0 , $ e ) ; } return $ xml ; }
8892	public function consumeSlimContainer ( Set $ container ) { foreach ( $ container as $ key => $ value ) { if ( $ value instanceof \ Closure ) { $ refFunc = new \ ReflectionFunction ( $ value ) ; $ shared = in_array ( 'object' , $ refFunc -> getStaticVariables ( ) ) ; $ this -> registerFactory ( $ key , $ value , $ shared ) ; } elseif ( is_callable ( $ value ) ) { $ this -> registerFactory ( $ key , $ value , false ) ; } else { $ this -> sm -> setService ( $ key , $ value ) ; } } }
12322	public function run ( InputInterface $ input , OutputInterface $ output ) { $ this -> doPreRun ( $ input , $ output ) ; $ code = parent :: run ( $ input , $ output ) ; $ this -> doPostRun ( $ input , $ output , $ code ) ; return $ code ; }
3196	public function getConsumedExtraTime ( $ tags = null , $ maxTime = 0 , $ target = TimePoint :: TARGET_SERVER ) { if ( $ maxTime ) { $ totalConsumed = $ this -> compute ( $ tags , $ target ) ; $ consumedExtraTime = $ totalConsumed - $ maxTime < 0 ? 0 : $ totalConsumed - $ maxTime ; $ this -> setConsumedExtraTime ( $ consumedExtraTime ) -> save ( ) ; } return $ this -> consumedExtraTime ; }
11710	public function actionConfirm ( $ id , $ back = 'index' ) { $ this -> findModel ( $ id ) -> confirm ( ) ; \ Yii :: $ app -> getSession ( ) -> setFlash ( 'success' , \ Yii :: t ( 'user' , 'User has been confirmed' ) ) ; $ url = $ back == 'index' ? [ 'index' ] : [ 'update' , 'id' => $ id ] ; return $ this -> redirect ( $ url ) ; }
7336	private function getStockSubjectMappings ( ) { return [ [ 'fieldName' => 'stockMode' , 'columnName' => 'stock_mode' , 'type' => 'string' , 'length' => 16 , 'nullable' => false , 'default' => Stock \ StockSubjectModes :: MODE_AUTO , ] , [ 'fieldName' => 'stockState' , 'columnName' => 'stock_state' , 'type' => 'string' , 'length' => 16 , 'nullable' => false , 'default' => Stock \ StockSubjectStates :: STATE_OUT_OF_STOCK , ] , [ 'fieldName' => 'stockFloor' , 'columnName' => 'stock_floor' , 'type' => 'decimal' , 'precision' => 10 , 'scale' => 3 , 'nullable' => true , 'default' => 0 , ] , [ 'fieldName' => 'inStock' , 'columnName' => 'in_stock' , 'type' => 'decimal' , 'precision' => 10 , 'scale' => 3 , 'nullable' => false , 'default' => 0 , ] , [ 'fieldName' => 'availableStock' , 'columnName' => 'available_stock' , 'type' => 'decimal' , 'precision' => 10 , 'scale' => 3 , 'nullable' => false , 'default' => 0 , ] , [ 'fieldName' => 'virtualStock' , 'columnName' => 'virtual_stock' , 'type' => 'decimal' , 'precision' => 10 , 'scale' => 3 , 'nullable' => false , 'default' => 0 , ] , [ 'fieldName' => 'replenishmentTime' , 'columnName' => 'replenishment_time' , 'type' => 'smallint' , 'nullable' => false , 'default' => 7 , ] , [ 'fieldName' => 'estimatedDateOfArrival' , 'columnName' => 'estimated_date_of_arrival' , 'type' => 'datetime' , 'nullable' => true , ] , [ 'fieldName' => 'geocode' , 'columnName' => 'geocode' , 'type' => 'string' , 'length' => 16 , 'nullable' => true , ] , [ 'fieldName' => 'minimumOrderQuantity' , 'columnName' => 'minimum_order_quantity' , 'type' => 'decimal' , 'precision' => 10 , 'scale' => 3 , 'nullable' => false , 'default' => 1 , ] , [ 'fieldName' => 'quoteOnly' , 'columnName' => 'quote_only' , 'type' => 'boolean' , 'nullable' => false , 'default' => false , ] , [ 'fieldName' => 'endOfLife' , 'columnName' => 'end_of_life' , 'type' => 'boolean' , 'nullable' => false , 'default' => false , ] , ] ; }
10588	public function buildChargeFromTransaction ( $ sTxnID ) { $ oCharge = new Freeagent \ DataWrapper \ ChargeVO ( ) ; try { $ oDets = $ this -> getTxnChargeDetails ( $ sTxnID ) ; $ oCharge -> setId ( $ sTxnID ) -> setGateway ( 'paypalexpress' ) -> setPaymentTerms ( 1 ) -> setAmount_Gross ( $ oDets -> GrossAmount -> value ) -> setAmount_Fee ( $ oDets -> FeeAmount -> value ) -> setAmount_Net ( $ oDets -> GrossAmount -> value - $ oDets -> FeeAmount -> value ) -> setDate ( strtotime ( $ oDets -> PaymentDate ) ) -> setCurrency ( $ oDets -> GrossAmount -> currencyID ) ; } catch ( \ Exception $ oE ) { } return $ oCharge ; }
8468	public static function getActiveHandlersList ( ) { $ cacheKey = 'DevGroup/EventsSystem:activeHandlersList' ; $ handlers = Yii :: $ app -> cache -> get ( $ cacheKey ) ; if ( $ handlers === false ) { $ eventEventHandlers = EventEventHandler :: find ( ) -> where ( [ 'is_active' => 1 ] ) -> orderBy ( [ 'sort_order' => SORT_ASC ] ) -> asArray ( true ) -> all ( ) ; $ events = Event :: find ( ) -> where ( [ 'id' => array_column ( $ eventEventHandlers , 'event_id' , 'event_id' ) ] ) -> indexBy ( 'id' ) -> asArray ( true ) -> all ( ) ; $ eventGroups = EventGroup :: find ( ) -> where ( [ 'id' => array_column ( $ events , 'event_group_id' , 'event_group_id' ) ] ) -> indexBy ( 'id' ) -> asArray ( true ) -> all ( ) ; $ eventHandlers = EventHandler :: find ( ) -> where ( [ 'id' => array_column ( $ eventEventHandlers , 'event_handler_id' , 'event_handler_id' ) ] ) -> indexBy ( 'id' ) -> asArray ( true ) -> all ( ) ; $ handlers = [ ] ; foreach ( $ eventEventHandlers as $ eventEventHandler ) { if ( isset ( $ eventHandlers [ $ eventEventHandler [ 'event_handler_id' ] ] , $ events [ $ eventEventHandler [ 'event_id' ] ] , $ eventGroups [ $ events [ $ eventEventHandler [ 'event_id' ] ] [ 'event_group_id' ] ] ) === false ) { continue ; } try { $ data = Json :: decode ( $ eventEventHandler [ 'packed_json_params' ] ) ; } catch ( \ Exception $ e ) { $ data = [ ] ; } $ handlers [ ] = [ 'class' => $ eventGroups [ $ events [ $ eventEventHandler [ 'event_id' ] ] [ 'event_group_id' ] ] [ 'owner_class_name' ] , 'name' => $ events [ $ eventEventHandler [ 'event_id' ] ] [ 'execution_point' ] , 'callable' => [ $ eventHandlers [ $ eventEventHandler [ 'event_handler_id' ] ] [ 'class_name' ] , $ eventEventHandler [ 'method' ] , ] , 'data' => $ data , ] ; } Yii :: $ app -> cache -> set ( $ cacheKey , $ handlers , 86400 , new TagDependency ( [ 'tags' => [ NamingHelper :: getCommonTag ( EventGroup :: className ( ) ) , NamingHelper :: getCommonTag ( Event :: className ( ) ) , NamingHelper :: getCommonTag ( EventHandler :: className ( ) ) , NamingHelper :: getCommonTag ( EventEventHandler :: className ( ) ) , ] , ] ) ) ; } return $ handlers ; }
7419	protected function setRedirect ( string $ url = '' , int $ statusCode = 303 ) { $ this -> response -> redirect ( $ url , $ statusCode ) ; }
10298	private function writeLegend ( XMLWriter $ objWriter , Legend $ legend = null ) { if ( $ legend === null ) { return ; } $ objWriter -> startElement ( 'c:legend' ) ; $ objWriter -> startElement ( 'c:legendPos' ) ; $ objWriter -> writeAttribute ( 'val' , $ legend -> getPosition ( ) ) ; $ objWriter -> endElement ( ) ; $ this -> writeLayout ( $ objWriter , $ legend -> getLayout ( ) ) ; $ objWriter -> startElement ( 'c:overlay' ) ; $ objWriter -> writeAttribute ( 'val' , ( $ legend -> getOverlay ( ) ) ? '1' : '0' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:txPr' ) ; $ objWriter -> startElement ( 'a:bodyPr' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'a:lstStyle' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'a:p' ) ; $ objWriter -> startElement ( 'a:pPr' ) ; $ objWriter -> writeAttribute ( 'rtl' , 0 ) ; $ objWriter -> startElement ( 'a:defRPr' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'a:endParaRPr' ) ; $ objWriter -> writeAttribute ( 'lang' , 'en-US' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; }
9751	public function set_images ( $ post_id ) { if ( ! $ post_id || is_null ( $ post_id ) ) { return 0 ; } update_post_meta ( $ post_id , 'custom_images_grifus' , 'true' ) ; $ count = 0 ; $ tmdb = 'image.tmdb.org' ; $ poster = get_post_meta ( $ post_id , 'poster_url' , true ) ; if ( filter_var ( $ poster , FILTER_VALIDATE_URL ) && strpos ( $ poster , $ tmdb ) ) { $ count ++ ; $ poster = WP_Image :: save ( $ poster , $ post_id , true ) ; update_post_meta ( $ post_id , 'poster_url' , $ poster ) ; } $ main = get_post_meta ( $ post_id , 'fondo_player' , true ) ; if ( filter_var ( $ main , FILTER_VALIDATE_URL ) && strpos ( $ main , $ tmdb ) ) { $ count ++ ; $ main = WP_Image :: save ( $ main , $ post_id ) ; update_post_meta ( $ post_id , 'fondo_player' , $ main ) ; } $ images = get_post_meta ( $ post_id , 'imagenes' , true ) ; $ images_array = explode ( "\n" , $ images ) ; $ new_images = '' ; foreach ( $ images_array as $ image ) { $ image = trim ( $ image ) ; if ( filter_var ( $ image , FILTER_VALIDATE_URL ) && strpos ( $ image , $ tmdb ) ) { $ count ++ ; $ url = WP_Image :: save ( $ image , $ post_id ) ; $ new_images .= $ url . "\n" ; } } if ( ! empty ( $ new_images ) ) { update_post_meta ( $ post_id , 'imagenes' , $ new_images ) ; } return $ count ; }
10528	protected function getIpAddressFromProxy ( ) { if ( ! $ this -> useProxy || ( isset ( $ _SERVER [ 'REMOTE_ADDR' ] ) && ! in_array ( $ _SERVER [ 'REMOTE_ADDR' ] , $ this -> trustedProxies ) ) ) { return false ; } $ header = $ this -> proxyHeader ; if ( ! isset ( $ _SERVER [ $ header ] ) || empty ( $ _SERVER [ $ header ] ) ) { return false ; } $ ips = explode ( ',' , $ _SERVER [ $ header ] ) ; $ ips = array_map ( 'trim' , $ ips ) ; $ ips = array_diff ( $ ips , $ this -> trustedProxies ) ; if ( empty ( $ ips ) ) { return false ; } $ ip = array_pop ( $ ips ) ; return $ ip ; }
10089	function addAttachmentFromBase64Data ( $ filename , $ mimetype , $ contents ) { $ attachment = new Attachment ( $ filename , $ mimetype , $ contents ) ; $ this -> attachments [ ] = $ attachment ; }
6347	public static function all ( Iterator $ iterator , callable $ predicate ) : bool { while ( $ iterator -> valid ( ) ) { if ( ! Predicates :: call ( $ predicate , $ iterator -> current ( ) ) ) { return false ; } $ iterator -> next ( ) ; } return true ; }
8741	protected function i18nDeleteQuery ( $ withGlobalScopes = true ) { $ subQuery = $ withGlobalScopes ? $ this -> toBase ( ) : $ this -> getQuery ( ) ; $ subQuery -> select ( $ this -> model -> getQualifiedKeyName ( ) ) ; return $ this -> i18nQuery ( ) -> whereIn ( $ this -> model -> getForeignKey ( ) , $ subQuery -> pluck ( $ this -> model -> getKeyName ( ) ) ) ; }
2124	public function getFileUrls ( ) { $ return = array ( ) ; $ strTarget = substr ( $ this -> strMode , 1 ) ; foreach ( $ this -> arrFiles as $ arrFile ) { if ( $ arrFile [ 'extension' ] == self :: SCSS || $ arrFile [ 'extension' ] == self :: LESS ) { $ strPath = 'assets/' . $ strTarget . '/' . str_replace ( '/' , '_' , $ arrFile [ 'name' ] ) . $ this -> strMode ; if ( Config :: get ( 'debugMode' ) || ! file_exists ( $ this -> strRootDir . '/' . $ strPath ) ) { $ objFile = new File ( $ strPath ) ; $ objFile -> write ( $ this -> handleScssLess ( file_get_contents ( $ this -> strRootDir . '/' . $ arrFile [ 'name' ] ) , $ arrFile ) ) ; $ objFile -> close ( ) ; } $ return [ ] = $ strPath . '|' . $ arrFile [ 'version' ] ; } else { $ name = $ arrFile [ 'name' ] ; if ( strncmp ( $ name , $ this -> strWebDir . '/' , \ strlen ( $ this -> strWebDir ) + 1 ) === 0 ) { $ name = substr ( $ name , \ strlen ( $ this -> strWebDir ) + 1 ) ; } if ( $ this -> strMode == self :: CSS && $ arrFile [ 'media' ] != '' && $ arrFile [ 'media' ] != 'all' && ! $ this -> hasMediaTag ( $ arrFile [ 'name' ] ) ) { $ name .= '|' . $ arrFile [ 'media' ] ; } $ return [ ] = $ name . '|' . $ arrFile [ 'version' ] ; } } return $ return ; }
12296	public function filter ( FilterRequest $ filters ) { $ search = new Search ( $ this -> model , $ filters ) ; $ this -> builder = $ search -> getBuilder ( ) ; return $ this ; }
2222	public static function countPublishedFromToByPids ( $ intFrom , $ intTo , $ arrPids , array $ arrOptions = array ( ) ) { if ( empty ( $ arrPids ) || ! \ is_array ( $ arrPids ) ) { return null ; } $ t = static :: $ strTable ; $ arrColumns = array ( "$t.date>=? AND $t.date<=? AND $t.pid IN(" . implode ( ',' , array_map ( '\intval' , $ arrPids ) ) . ")" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } return static :: countBy ( $ arrColumns , array ( $ intFrom , $ intTo ) , $ arrOptions ) ; }
2056	public function setRootType ( Contao \ DataContainer $ dc ) { if ( Contao \ Input :: get ( 'act' ) != 'create' ) { return ; } if ( Contao \ Input :: get ( 'pid' ) == 0 ) { $ GLOBALS [ 'TL_DCA' ] [ 'tl_page' ] [ 'fields' ] [ 'type' ] [ 'default' ] = 'root' ; } elseif ( Contao \ Input :: get ( 'mode' ) == 1 ) { $ objPage = $ this -> Database -> prepare ( "SELECT * FROM " . $ dc -> table . " WHERE id=?" ) -> limit ( 1 ) -> execute ( Contao \ Input :: get ( 'pid' ) ) ; if ( $ objPage -> pid == 0 ) { $ GLOBALS [ 'TL_DCA' ] [ 'tl_page' ] [ 'fields' ] [ 'type' ] [ 'default' ] = 'root' ; } } }
6888	protected function createErrorException ( ResponseInterface $ response ) { $ body = json_decode ( $ response -> getBody ( ) , true ) ; $ message = "HTTP:{$response->getStatusCode()} - " ; $ message .= ( is_array ( $ body ) ) ? print_r ( $ body , true ) : 'Unexpected response from server' ; return new Exception \ ApiException ( $ message , $ response -> getStatusCode ( ) , $ response ) ; }
11248	public function getMigrationBatches ( ) : array { $ stmt = $ this -> pdo -> prepare ( "select * from {$this->table} order by batch, migration" ) ; $ stmt -> execute ( ) ; $ array = [ ] ; foreach ( $ stmt -> fetchAll ( PDO :: FETCH_ASSOC ) as $ item ) { $ array [ $ item [ 'migration' ] ] = $ item [ 'batch' ] ; } return $ array ; }
7237	protected function fixInvoiceDefault ( CustomerAddressInterface $ address ) { if ( ! $ this -> persistenceHelper -> isChanged ( $ address , [ 'invoiceDefault' ] ) ) { return ; } $ customer = $ address -> getCustomer ( ) ; if ( $ address -> isInvoiceDefault ( ) ) { foreach ( $ customer -> getAddresses ( ) as $ a ) { if ( $ a === $ address ) { continue ; } if ( $ a -> isInvoiceDefault ( ) ) { $ a -> setInvoiceDefault ( false ) ; $ this -> persistenceHelper -> persistAndRecompute ( $ a , false ) ; } } } elseif ( null === $ customer -> getDefaultInvoiceAddress ( true ) ) { $ address -> setInvoiceDefault ( true ) ; $ this -> persistenceHelper -> persistAndRecompute ( $ address , false ) ; } }
5046	public function form ( $ form , $ options = null , $ as = 'searchform' ) { if ( is_string ( $ options ) ) { $ as = $ options ; $ options = null ; } $ this -> stack [ 'form' ] = [ 'as' => $ as , $ form , $ options ] ; return $ this ; }
11025	public function __isset ( $ name ) : bool { if ( strrpos ( $ name , 'facet_' , - strlen ( $ name ) ) !== false ) { return true ; } return false ; }
12048	public function render ( ElementInterface $ element ) { $ renderer = $ this -> getView ( ) ; if ( $ element instanceof CkEditor ) { $ plugin = $ renderer -> plugin ( 'form_ckeditor' ) ; return $ plugin ( $ element ) ; } return parent :: render ( $ element ) ; }
533	public function actionFix ( $ root = null ) { $ files = $ this -> findFiles ( $ root , false ) ; $ nFilesTotal = 0 ; $ nFilesUpdated = 0 ; foreach ( $ files as $ file ) { $ contents = file_get_contents ( $ file ) ; $ hash = $ this -> hash ( $ contents ) ; $ lines = preg_split ( '/(\r\n|\n|\r)/' , $ contents ) ; if ( ! $ this -> skipFrameworkRequirements ) { $ this -> fixFileDoc ( $ lines ) ; } $ this -> fixDocBlockIndentation ( $ lines ) ; $ lines = array_values ( $ this -> fixLineSpacing ( $ lines ) ) ; $ newContent = implode ( "\n" , $ lines ) ; if ( $ hash !== $ this -> hash ( $ newContent ) ) { file_put_contents ( $ file , $ newContent ) ; $ nFilesUpdated ++ ; } $ nFilesTotal ++ ; } $ this -> stdout ( "\nParsed $nFilesTotal files.\n" ) ; $ this -> stdout ( "Updated $nFilesUpdated files.\n" ) ; }
2838	public function getRequestInfo ( ) { if ( $ this -> requestInfo === null ) { $ this -> requestInfo = Mage :: registry ( 'sheep_debug_request_info' ) ; } return $ this -> requestInfo ; }
8949	function constructUrl ( Request $ appRequest , Nette \ Http \ Url $ refUrl ) { return $ this -> getRouter ( ) -> constructUrl ( $ appRequest , $ refUrl ) ; }
5268	public function esc_like ( $ value , $ start = '%' , $ end = '%' ) { global $ wpdb ; return $ start . $ wpdb -> esc_like ( $ value ) . $ end ; }
1766	public function onKernelResponse ( FilterResponseEvent $ event ) : void { if ( ! $ this -> scopeMatcher -> isContaoMasterRequest ( $ event ) ) { return ; } $ request = $ event -> getRequest ( ) ; if ( ! $ request -> isMethod ( Request :: METHOD_GET ) ) { return ; } $ response = $ event -> getResponse ( ) ; if ( 200 !== $ response -> getStatusCode ( ) ) { return ; } $ token = $ this -> tokenStorage -> getToken ( ) ; if ( null === $ token || $ this -> authenticationTrustResolver -> isAnonymous ( $ token ) ) { return ; } if ( $ this -> scopeMatcher -> isBackendRequest ( $ request ) ) { $ this -> storeBackendReferer ( $ request ) ; } else { $ this -> storeFrontendReferer ( $ request ) ; } }
10364	public function offsetSet ( $ item , $ node ) { if ( $ item !== null ) { throw new ValueException ( $ item , 'null' ) ; } return $ this -> nodes [ ] = $ node ; }
9664	public static function registerReader ( $ readerType , $ readerClass ) { if ( ! is_a ( $ readerClass , Reader \ IReader :: class , true ) ) { throw new Reader \ Exception ( 'Registered readers must implement ' . Reader \ IReader :: class ) ; } self :: $ readers [ $ readerType ] = $ readerClass ; }
4822	public function set ( $ name , $ value ) { if ( ! array_key_exists ( $ name , $ this -> row ) ) { $ this -> addField ( $ name , $ value ) ; } else { $ this -> row [ $ name ] = $ value ; } $ this -> informChanges ( ) ; }
12876	private function setNamespace ( $ serviceName = null ) { if ( $ serviceName === null ) { $ this -> storage -> getOptions ( ) -> setNamespace ( $ this -> defaultNamespace ) ; } else { $ this -> storage -> getOptions ( ) -> setNamespace ( $ serviceName ) ; } }
3626	protected function getDefaultSerial ( $ serial_number ) { if ( empty ( $ serial_number ) ) { $ devices_serials = $ this -> getDevices ( ) ; if ( count ( $ devices_serials ) == 0 ) { $ devices_serials = $ this -> getDevices ( DEVICE_TYPE_PROTECT ) ; } $ serial_number = $ devices_serials [ 0 ] ; } return $ serial_number ; }
10341	protected function validateColumns ( $ columns ) { $ patterns = array ( '((?P<minute>(?:\*|(?:(?:[0-9]|[1-5][0-9])(?:-(?:[0-9]|[1-5][0-9]))?)(?:,(?:[0-9]|[1-5][0-9])(?:-(?:[0-9]|[1-5][0-9]))?)*)(?:/(?:[1-9]|[1-5][0-9]))?)$)AD' , '((?P<hour>(?:\*|(?:(?:[0-9]|1[0-9]|2[0-3])(?:-(?:[0-9]|1[0-9]|2[0-3]))?)(?:,(?:[0-9]|1[0-9]|2[0-3])(?:-(?:[0-9]|1[0-9]|2[0-3]))?)*)(?:/(?:[1-9]|1[0-9]|2[0-3]))?)$)AD' , '((?P<dayOfMonth>(?:\*|(?:(?:[1-9]|[1-2][0-9]|3[0-1])(?:-(?:[1-9]|[1-2][0-9]|3[0-1]))?)(?:,(?:[1-9]|[1-2][0-9]|3[0-1])(?:-(?:[1-9]|[1-2][0-9]|3[0-1]))?)*)(?:/(?:[1-9]|[1-2][0-9]|3[0-1]))?)$)AD' , '((?P<month>(?:\*|(?:(?:[1-9]|1[0-2])(?:-(?:[1-9]|1[1-2]))?)(?:,(?:[1-9]|1[1-2])(?:-(?:[1-9]|1[1-2]))?)*)(?:/(?:[1-9]|1[1-2]))?)$)AD' , '((?P<dayOfWeek>(?:\*|(?:(?:[0-7])(?:-(?:[0-7]))?)(?:,(?:[0-7])(?:-(?:[0-7]))?)*)(?:/(?:[1-7]))?)$)AD' , ) ; if ( count ( $ columns ) !== 5 ) { return false ; } foreach ( $ columns as $ key => $ column ) { if ( preg_match ( $ patterns [ $ key ] , $ column ) !== 1 ) { return ( int ) $ key ; } } return true ; }
8716	public static function createInLocale ( $ locale , array $ attributes = [ ] , $ translations = [ ] ) { $ model = ( new static ( $ attributes ) ) -> setLocale ( $ locale ) ; if ( $ model -> save ( ) && is_array ( $ translations ) ) { $ model -> saveTranslations ( $ translations ) ; } return $ model ; }
5620	protected function chompCoordinates ( & $ url ) { if ( preg_match ( '/(.*)\?(\d+),(\d+)$/' , $ url , $ matches ) ) { $ url = $ matches [ 1 ] ; return array ( ( integer ) $ matches [ 2 ] , ( integer ) $ matches [ 3 ] ) ; } return array ( false , false ) ; }
8362	public static function registerTranslations ( $ baseDir , $ localesDir , $ prefix = null ) { if ( self :: $ isInit === true ) { $ dir = $ baseDir . DIRECTORY_SEPARATOR . $ localesDir ; if ( is_dir ( $ dir ) === false ) { throw new InvalidDirectory ( 'directory "' . $ dir . '" can\'t be identified' ) ; } $ language = self :: $ currentLanguage ; if ( ( $ pos = strpos ( $ language , '-' ) ) !== false ) { $ pos = ( int ) $ pos ; $ language = substr ( $ language , 0 , $ pos ) ; } if ( ( $ pos = strpos ( $ language , '_' ) ) !== false ) { $ pos = ( int ) $ pos ; $ language = substr ( $ language , 0 , $ pos ) ; } if ( is_readable ( $ dir . DIRECTORY_SEPARATOR . $ language . '.yml' ) === true ) { $ newOnes = Config :: get ( $ dir . DIRECTORY_SEPARATOR . $ language . '.yml' ) ; if ( is_array ( $ newOnes ) === true ) { if ( $ prefix != null ) { $ newOnes = array ( $ prefix => $ newOnes ) ; } self :: $ translations = array_merge ( self :: $ translations , $ newOnes ) ; } } else { Logger :: get ( ) -> notice ( 'can\'t find language "' . $ language . '" in directory "' . $ dir . '"' ) ; } } }
4018	protected function initializeWidget ( & $ arrField , $ strRow , $ strKey , $ varValue ) { $ xlabel = $ this -> getHelpWizard ( $ strKey , $ arrField ) ; if ( isset ( $ arrField [ 'input_field_callback' ] ) && is_array ( $ arrField [ 'input_field_callback' ] ) ) { if ( ! is_object ( $ this -> $ arrField [ 'input_field_callback' ] [ 0 ] ) ) { $ this -> import ( $ arrField [ 'input_field_callback' ] [ 0 ] ) ; } return $ this -> { $ arrField [ 'input_field_callback' ] [ 0 ] } -> $ arrField [ 'input_field_callback' ] [ 1 ] ( $ this , $ xlabel ) ; } $ strClass = $ this -> getWidgetClass ( $ arrField ) ; if ( empty ( $ strClass ) ) { return null ; } $ varValue = $ this -> handleLoadCallback ( $ arrField , $ varValue ) ; $ arrField = $ this -> makeMandatory ( $ arrField , $ strRow , $ strKey ) ; $ arrField [ 'name' ] = $ this -> strName . '[' . $ strRow . '][' . $ strKey . ']' ; $ arrField [ 'id' ] = $ this -> strId . '_' . $ strRow . '_' . $ strKey ; $ arrField [ 'value' ] = ( $ varValue !== '' ) ? $ varValue : $ arrField [ 'default' ] ; $ arrField [ 'eval' ] [ 'tableless' ] = true ; $ event = new GetAttributesFromDcaEvent ( $ arrField , $ arrField [ 'name' ] , $ arrField [ 'value' ] , null , $ this -> strTable , $ this -> objDca ) ; $ this -> getEventDispatcher ( ) -> dispatch ( ContaoEvents :: WIDGET_GET_ATTRIBUTES_FROM_DCA , $ event ) ; $ objWidget = new $ strClass ( $ event -> getResult ( ) ) ; $ objWidget -> strId = $ arrField [ 'id' ] ; $ objWidget -> storeValues = true ; $ objWidget -> xlabel = $ xlabel ; return $ objWidget ; }
6376	public function sorted ( Comparator $ comparator ) : FluentIterable { $ array = $ this -> toArray ( ) ; Arrays :: sort ( $ array , $ comparator ) ; return self :: of ( $ array ) ; }
274	public function renderDataCell ( $ model , $ key , $ index ) { if ( $ this -> contentOptions instanceof Closure ) { $ options = call_user_func ( $ this -> contentOptions , $ model , $ key , $ index , $ this ) ; } else { $ options = $ this -> contentOptions ; } return Html :: tag ( 'td' , $ this -> renderDataCellContent ( $ model , $ key , $ index ) , $ options ) ; }
1262	protected function compileEndpointUrl ( $ segment ) { $ base = ( $ this -> useIntegration ? $ this -> integrationBaseUrl : $ this -> productionBaseUrl ) ; return $ base . $ segment ; }
6915	public function addAttachment ( AttachmentInterface $ attachment ) { if ( ! $ this -> attachments -> contains ( $ attachment ) ) { $ this -> attachments -> add ( $ attachment ) ; } return $ this ; }
4449	public function pop ( ? string $ worker = null , ? int $ numJobs = null ) { $ workerName = $ worker ? : $ this -> client -> getWorkerName ( ) ; $ jids = json_decode ( $ this -> client -> pop ( $ this -> name , $ workerName , $ numJobs ? : 1 ) , true ) ; $ jobs = [ ] ; array_map ( function ( array $ data ) use ( & $ jobs ) { $ job = new BaseJob ( $ this -> client , $ data ) ; $ job -> setEventsManager ( $ this -> getEventsManager ( ) ) ; $ jobs [ ] = $ job ; } , $ jids ? : [ ] ) ; return $ numJobs === null ? array_shift ( $ jobs ) : $ jobs ; }
7037	protected static function computeDependencies ( array $ tables ) { $ result = [ ] ; while ( ! empty ( $ tables ) ) { $ num = count ( $ tables ) ; foreach ( $ tables as $ i => $ table ) if ( ! $ table -> dependent ( ) ) { $ result [ ] = $ table ; unset ( $ tables [ $ i ] ) ; foreach ( $ tables as $ t ) $ t -> removeDependency ( $ table -> name ( ) ) ; } if ( count ( $ tables ) === $ num ) return false ; } return $ result ; }
5751	public function deleteByPrimaryKey ( $ primaryKeyValue , ? string $ returnField = null ) : ? string { if ( null === $ role = $ this -> getObjectById ( ( int ) $ primaryKeyValue ) ) { throw new Exceptions \ QueryResultsNotFoundException ( "Role not found: id $primaryKeyValue" ) ; } if ( ! $ role -> isDeletable ( ( int ) $ primaryKeyValue ) ) { throw new Exceptions \ UnallowedActionException ( "Role in use: id $primaryKeyValue" ) ; } return parent :: deleteByPrimaryKey ( $ primaryKeyValue , $ returnField ) ; }
9444	public function getName ( ) { static $ names = [ ] ; $ me = get_class ( $ this ) ; if ( empty ( $ names [ $ me ] ) ) { $ names [ $ me ] = $ this -> getReflector ( ) -> getShortName ( ) ; $ suffix = defined ( 'static::PACK_SUFFIX' ) ? static :: PACK_SUFFIX : 'Pack' ; if ( strrpos ( $ names [ $ me ] , $ suffix ) == ( strlen ( $ names [ $ me ] ) - strlen ( $ suffix ) ) ) { $ names [ $ me ] = substr ( $ names [ $ me ] , 0 , strlen ( $ names [ $ me ] ) - strlen ( $ suffix ) ) ; } } return $ names [ $ me ] ; }
3393	public function register ( Request $ request ) { $ this -> validator ( $ request -> all ( ) ) -> validate ( ) ; event ( new Registered ( $ user = $ this -> create ( $ request -> all ( ) ) ) ) ; $ this -> sendConfirmationToUser ( $ user ) ; return $ this -> registered ( $ request , $ user ) ? : redirect ( $ this -> redirectAfterRegistrationPath ( ) ) -> with ( 'confirmation' , __ ( 'confirmation::confirmation.confirmation_info' ) ) ; }
1719	public function getNewsArchives ( ) { if ( ! $ this -> User -> isAdmin && ! \ is_array ( $ this -> User -> news ) ) { return array ( ) ; } $ arrArchives = array ( ) ; $ objArchives = $ this -> Database -> execute ( "SELECT id, title FROM tl_news_archive ORDER BY title" ) ; while ( $ objArchives -> next ( ) ) { if ( $ this -> User -> hasAccess ( $ objArchives -> id , 'news' ) ) { $ arrArchives [ $ objArchives -> id ] = $ objArchives -> title ; } } return $ arrArchives ; }
12947	protected function ownerHasTagAttribute ( ) { if ( $ this -> _hasTagAttribute === null ) { $ this -> _hasTagAttribute = $ this -> owner -> hasAttribute ( 'tags' ) ; } return $ this -> _hasTagAttribute ; }
9686	public function implode ( $ value , $ glue = null ) { $ new_collection = new Collection ( $ this -> toArray ( ) ) ; $ first = $ new_collection -> first ( ) ; if ( is_array ( $ first ) || is_object ( $ first ) ) { return implode ( $ glue , $ new_collection -> pluck ( $ value ) -> all ( ) ) ; } return implode ( $ value , $ new_collection -> all ( ) ) ; }
9940	public function calculateColumnWidths ( ) { $ autoSizes = [ ] ; foreach ( $ this -> getColumnDimensions ( ) as $ colDimension ) { if ( $ colDimension -> getAutoSize ( ) ) { $ autoSizes [ $ colDimension -> getColumnIndex ( ) ] = - 1 ; } } if ( ! empty ( $ autoSizes ) ) { $ isMergeCell = [ ] ; foreach ( $ this -> getMergeCells ( ) as $ cells ) { foreach ( Coordinate :: extractAllCellReferencesInRange ( $ cells ) as $ cellReference ) { $ isMergeCell [ $ cellReference ] = true ; } } foreach ( $ this -> getCoordinates ( false ) as $ coordinate ) { $ cell = $ this -> getCell ( $ coordinate , false ) ; if ( $ cell !== null && isset ( $ autoSizes [ $ this -> cellCollection -> getCurrentColumn ( ) ] ) ) { $ isMerged = isset ( $ isMergeCell [ $ this -> cellCollection -> getCurrentCoordinate ( ) ] ) ; $ isMergedButProceed = false ; if ( $ isMerged && $ cell -> isMergeRangeValueCell ( ) ) { $ range = $ cell -> getMergeRange ( ) ; $ rangeBoundaries = Coordinate :: rangeDimension ( $ range ) ; if ( $ rangeBoundaries [ 0 ] == 1 ) { $ isMergedButProceed = true ; } } if ( ! $ isMerged || $ isMergedButProceed ) { $ cellValue = NumberFormat :: toFormattedString ( $ cell -> getCalculatedValue ( ) , $ this -> getParent ( ) -> getCellXfByIndex ( $ cell -> getXfIndex ( ) ) -> getNumberFormat ( ) -> getFormatCode ( ) ) ; $ autoSizes [ $ this -> cellCollection -> getCurrentColumn ( ) ] = max ( ( float ) $ autoSizes [ $ this -> cellCollection -> getCurrentColumn ( ) ] , ( float ) Shared \ Font :: calculateColumnWidth ( $ this -> getParent ( ) -> getCellXfByIndex ( $ cell -> getXfIndex ( ) ) -> getFont ( ) , $ cellValue , $ this -> getParent ( ) -> getCellXfByIndex ( $ cell -> getXfIndex ( ) ) -> getAlignment ( ) -> getTextRotation ( ) , $ this -> getParent ( ) -> getDefaultStyle ( ) -> getFont ( ) ) ) ; } } } foreach ( $ autoSizes as $ columnIndex => $ width ) { if ( $ width == - 1 ) { $ width = $ this -> getDefaultColumnDimension ( ) -> getWidth ( ) ; } $ this -> getColumnDimension ( $ columnIndex ) -> setWidth ( $ width ) ; } } return $ this ; }
12317	public function load ( $ name ) { foreach ( $ this -> sourceDirs as $ dir ) { if ( 0 === strpos ( $ name , DIRECTORY_SEPARATOR ) ) { $ yamlFile = $ name ; } else { $ yamlFile = $ dir . '/' . $ name ; } if ( false === strstr ( $ yamlFile , self :: EXT_YML ) ) { $ yamlFile .= self :: EXT_YML ; } if ( is_file ( $ yamlFile ) ) { return new ArrayCollection ( Yaml :: parse ( $ yamlFile ) ) ; } } throw new \ Exception ( sprintf ( 'No Yaml file found for {%s}' , $ name ) ) ; }
10467	public static function createSimpleAnonymousRecipient ( $ emailAddress , $ countryCode ) { return ( new Recipient ( ) ) -> setHash ( self :: getEmailAddressHash ( $ emailAddress ) ) -> setCountry ( $ countryCode ) -> setProvider ( self :: getDomainFromEmail ( $ emailAddress ) ) ; }
12752	public function sendConfirmationMessage ( User $ user , Token $ token ) { return $ this -> sendMessage ( $ user -> email , $ this -> confirmationSubject , 'confirmation' , [ 'user' => $ user , 'token' => $ token ] ) ; }
4127	public function newDefaultAnnotationDriver ( $ paths = array ( ) ) { $ reader = new \ Doctrine \ Common \ Annotations \ SimpleAnnotationReader ( ) ; $ reader -> addNamespace ( 'Doctrine\ODM\CouchDB\Mapping\Annotations' ) ; return new \ Doctrine \ ODM \ CouchDB \ Mapping \ Driver \ AnnotationDriver ( $ reader , ( array ) $ paths ) ; }
12585	static function run_convert_configuration ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { self :: setConfigDir ( $ cliopts ) ; $ extname = @ $ args [ 0 ] ; if ( $ extname == '' ) { $ extname = dirname ( __FILE__ ) ; } while ( ! is_file ( "ant/$extname.properties" ) ) { $ extname = pake_input ( 'What is the name of the current extension?' ) ; if ( ! is_file ( "ant/$extname.properties" ) ) { pake_echo ( "File ant/$extname.properties not found" ) ; } } self :: convertPropertyFileToYamlFile ( "ant/$extname.properties" , self :: getConfigDir ( ) . "/options-$extname.yaml" , array ( $ extname => '' , 'external' => 'dependencies' , 'dependency' => 'extensions' , 'repository' => array ( 'svn' , 'url' ) ) , "extension:\n name: $extname\n\n" ) ; foreach ( array ( 'files.to.parse.txt' => 'to_parse' , 'files.to.exclude.txt' => 'to_exclude' ) as $ file => $ option ) { $ src = "ant/$file" ; if ( file_exists ( $ src ) ) { if ( count ( $ in = file ( $ src , FILE_SKIP_EMPTY_LINES | FILE_IGNORE_NEW_LINES ) ) ) { $ in = "\n\nfiles:\n $option: [" . implode ( ', ' , $ in ) . "]\n" ; file_put_contents ( self :: getConfigDir ( ) . "options-$extname.yaml" , $ in , FILE_APPEND ) ; } } } }
6200	public function currentPath ( ) { $ request = preg_replace ( '!' . $ this -> uri . '(.*)$!i' , '$1' , $ _SERVER [ 'REQUEST_URI' ] ) ; if ( defined ( 'MOD_REWRITE' ) and MOD_REWRITE === true ) { if ( substr ( $ request , - 1 ) != '/' ) { $ request .= '/' ; } $ parseUrl = $ this -> parseUrl ( $ request ) ; $ gets = $ parseUrl [ 'sVars' ] ; } else { $ gets = $ _SERVER [ 'QUERY_STRING' ] ; } return $ gets ; }
7255	public function loggedIn ( ) { if ( $ this -> _viewAuth ) { return $ this -> sessionKey && $ this -> request -> session ( ) -> check ( $ this -> sessionKey ) ; } return false ; }
9388	public function prefix ( $ prefix = '' , $ namespace = '' ) { $ namespace === '' && $ namespace = ( string ) $ this -> namespace ; $ prefix && $ prefix [ 0 ] !== '/' && $ prefix = '/' . $ prefix ; $ namespace = str_replace ( '\\\\' , '\\' , $ namespace . '\\' ) ; $ this -> prefix = ( string ) $ prefix ; $ this -> namespace = ltrim ( $ namespace , '\\' ) ; return $ this ; }
9312	public function indexAction ( ) { if ( ! $ this -> isConsoleRequest ( ) ) { throw new \ RuntimeException ( 'You can only use this action from a console!' ) ; } $ console = $ this -> getConsole ( ) ; $ this -> printConsoleBanner ( $ console ) ; $ console -> writeLine ( 'TODO Finish indexAction!' , ConsoleColor :: LIGHT_RED ) ; }
12214	public function run ( $ route ) { if ( ! is_array ( $ route ) ) { $ this -> makeResponse ( $ route ) ; } $ viewSegments = explode ( '.' , $ route [ 'view' ] ) ; $ method = $ route [ 'method' ] ; Setup :: toDefine ( 'TEMPLATES_PATH' , APPS_ROOT . DS . $ this -> appName . DS . 'Templates' . DS ) ; Setup :: toDefine ( 'STATIC_PATH' , APPS_ROOT . DS . 'static' . DS ) ; $ viewPath = '' ; $ view = $ viewSegments [ 0 ] ; if ( count ( $ viewSegments ) > 1 ) { $ view = $ viewSegments [ count ( $ viewSegments ) - 1 ] ; array_pop ( $ viewSegments ) ; $ viewPath = implode ( '\\' , $ viewSegments ) ; $ viewPath .= '\\' ; } if ( $ view instanceof \ ForeverPHP \ View \ View ) { throw new ViewException ( "La vista ($view) no hereda de View." ) ; } if ( Settings :: getInstance ( ) -> get ( 'usingNamespaces' ) ) { $ view = '\\Apps\\' . $ this -> appName . '\\Views\\' . $ viewPath . $ view ; } $ v = new $ view ( ) ; $ returnValue = $ v -> $ method ( ) ; $ this -> makeResponse ( $ returnValue ) ; }
4092	public function term ( $ term , $ field = false ) { $ this -> term = ( $ field ) ? array ( $ field => $ term ) : $ term ; return $ this ; }
12088	public function view ( UserPolicy $ user , Response $ response ) { if ( $ user -> canDo ( 'forum.response.view' ) && $ user -> isAdmin ( ) ) { return true ; } return $ response -> user_id == user_id ( ) && $ response -> user_type == user_type ( ) ; }
10137	private function writeMsoDrawing ( ) { if ( isset ( $ this -> escher ) ) { $ writer = new Escher ( $ this -> escher ) ; $ data = $ writer -> close ( ) ; $ spOffsets = $ writer -> getSpOffsets ( ) ; $ spTypes = $ writer -> getSpTypes ( ) ; $ spOffsets [ 0 ] = 0 ; $ nm = count ( $ spOffsets ) - 1 ; for ( $ i = 1 ; $ i <= $ nm ; ++ $ i ) { $ record = 0x00EC ; $ dataChunk = substr ( $ data , $ spOffsets [ $ i - 1 ] , $ spOffsets [ $ i ] - $ spOffsets [ $ i - 1 ] ) ; $ length = strlen ( $ dataChunk ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ this -> append ( $ header . $ dataChunk ) ; $ record = 0x005D ; $ objData = '' ; if ( $ spTypes [ $ i ] == 0x00C9 ) { $ objData .= pack ( 'vvvvvVVV' , 0x0015 , 0x0012 , 0x0014 , $ i , 0x2101 , 0 , 0 , 0 ) ; $ objData .= pack ( 'vv' , 0x00C , 0x0014 ) ; $ objData .= pack ( 'H*' , '0000000000000000640001000A00000010000100' ) ; $ objData .= pack ( 'vv' , 0x0013 , 0x1FEE ) ; $ objData .= pack ( 'H*' , '00000000010001030000020008005700' ) ; } else { $ objData .= pack ( 'vvvvvVVV' , 0x0015 , 0x0012 , 0x0008 , $ i , 0x6011 , 0 , 0 , 0 ) ; } $ objData .= pack ( 'vv' , 0x0000 , 0x0000 ) ; $ length = strlen ( $ objData ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ this -> append ( $ header . $ objData ) ; } } }
333	public function add ( $ key , $ value , $ duration = 0 , $ dependency = null ) { if ( $ dependency !== null && $ this -> serializer !== false ) { $ dependency -> evaluateDependency ( $ this ) ; } if ( $ this -> serializer === null ) { $ value = serialize ( [ $ value , $ dependency ] ) ; } elseif ( $ this -> serializer !== false ) { $ value = call_user_func ( $ this -> serializer [ 0 ] , [ $ value , $ dependency ] ) ; } $ key = $ this -> buildKey ( $ key ) ; return $ this -> addValue ( $ key , $ value , $ duration ) ; }
8788	public function style ( $ url , $ attributes = [ ] , $ secure = null ) { $ defaults = [ 'media' => 'all' , 'type' => 'text/css' , 'rel' => 'stylesheet' ] ; $ attributes = array_merge ( $ attributes , $ defaults ) ; $ attributes [ 'href' ] = $ this -> uri -> assets ( $ url , $ secure ) ; return $ this -> toHtmlString ( '<link' . $ this -> attributes ( $ attributes ) . '>' . PHP_EOL ) ; }
12666	public function edit ( $ sourceDir , array $ options , $ username , $ values ) { $ this -> resolveOptions ( $ options ) ; $ this -> init ( $ sourceDir , $ options , $ username ) ; $ this -> createContributorDir ( $ sourceDir , $ options , $ username ) ; $ filename = sprintf ( '%s/blocks/%s.json' , $ this -> getDirInUse ( ) , $ options [ "blockname" ] ) ; $ currentBlock = $ options [ "baseBlock" ] = JsonTools :: jsonDecode ( FilesystemTools :: readFile ( $ filename ) ) ; $ values = $ this -> parseChildren ( $ values ) ; $ block = JsonTools :: join ( $ currentBlock , $ values ) ; $ encodedBlock = json_encode ( $ block ) ; $ blockClass = BlockFactory :: getBlockClass ( $ block [ "type" ] ) ; $ event = Dispatcher :: dispatch ( BlockEvents :: BLOCK_EDITING , new BlockEditingEvent ( $ this -> serializer , $ filename , $ encodedBlock , $ blockClass ) ) ; $ blockContent = $ event -> getFileContent ( ) ; FilesystemTools :: writeFile ( $ filename , $ blockContent ) ; Dispatcher :: dispatch ( BlockEvents :: BLOCK_EDITED , new BlockEditedEvent ( $ this -> serializer , $ filename , $ encodedBlock , $ blockClass ) ) ; DataLogger :: log ( sprintf ( 'Block "%s" has been edited on the "%s" slot on page "%s" for the "%s_%s" language' , $ options [ "blockname" ] , $ options [ "slot" ] , $ options [ "page" ] , $ options [ "language" ] , $ options [ "country" ] ) ) ; }
8437	public static function countRows ( array $ conditions , bool $ critical = false ) { $ entity = new static ( ) ; $ selectQuery = new Select ( $ entity -> getDatabaseName ( ) , $ critical ) ; $ selectQuery -> select ( [ 'count' => 'COUNT(*)' ] ) ; $ selectQuery -> from ( $ entity -> getTableName ( ) ) ; if ( count ( $ conditions ) > 0 ) { $ where = array ( ) ; foreach ( $ conditions as $ key => $ value ) { $ realName = constant ( get_called_class ( ) . '::FIELD_' . strtoupper ( Helper :: codifyName ( $ key ) ) ) ; $ where [ $ realName ] = ':where' . ucfirst ( $ key ) ; $ selectQuery -> bind ( 'where' . ucfirst ( $ key ) , $ value ) ; } $ selectQuery -> where ( $ where ) ; } if ( $ selectQuery -> execute ( ) === false ) { return false ; } $ data = $ selectQuery -> fetch ( ) ; if ( $ data === false ) { return false ; } return $ data [ 'count' ] ; }
1374	private function filterCommands ( Collection $ commands , $ type ) { $ baseCommandName = 'make:json-api:' ; $ filterValues = explode ( ',' , $ this -> option ( $ type ) ) ; $ targetCommands = collect ( $ filterValues ) -> map ( function ( $ target ) use ( $ baseCommandName ) { return $ baseCommandName . strtolower ( trim ( $ target ) ) ; } ) ; return $ commands -> { $ type } ( $ targetCommands -> toArray ( ) ) ; }
6037	public function init ( ) { parent :: init ( ) ; if ( $ this -> data ) { $ order = 0 ; if ( is_array ( $ this -> model -> { $ this -> attribute } ) ) { foreach ( $ this -> model -> { $ this -> attribute } as $ value ) { $ order ++ ; if ( is_object ( $ value ) ) { $ this -> options [ 'options' ] [ $ value -> Id ] = [ 'data-order' => $ order ] ; } else { $ this -> options [ 'options' ] [ $ value ] = [ 'data-order' => $ order ] ; } } } } }
431	public function getModule ( $ id , $ load = true ) { if ( ( $ pos = strpos ( $ id , '/' ) ) !== false ) { $ module = $ this -> getModule ( substr ( $ id , 0 , $ pos ) ) ; return $ module === null ? null : $ module -> getModule ( substr ( $ id , $ pos + 1 ) , $ load ) ; } if ( isset ( $ this -> _modules [ $ id ] ) ) { if ( $ this -> _modules [ $ id ] instanceof self ) { return $ this -> _modules [ $ id ] ; } elseif ( $ load ) { Yii :: debug ( "Loading module: $id" , __METHOD__ ) ; $ module = Yii :: createObject ( $ this -> _modules [ $ id ] , [ $ id , $ this ] ) ; $ module -> setInstance ( $ module ) ; return $ this -> _modules [ $ id ] = $ module ; } } return null ; }
4289	public function processLogEntry ( $ method , $ args = array ( ) , $ meta = array ( ) ) { $ meta = \ array_merge ( array ( 'format' => 'raw' , 'requestId' => $ this -> requestId , ) , $ meta ) ; if ( $ meta [ 'channel' ] == $ this -> debug -> getCfg ( 'channel' ) ) { unset ( $ meta [ 'channel' ] ) ; } if ( $ meta [ 'format' ] == 'raw' ) { $ args = $ this -> crateValues ( $ args ) ; } if ( ! empty ( $ meta [ 'backtrace' ] ) ) { $ meta [ 'backtrace' ] = $ this -> crateValues ( $ meta [ 'backtrace' ] ) ; } $ this -> wamp -> publish ( $ this -> topic , array ( $ method , $ args , $ meta ) ) ; }
12131	public function handle ( ) { $ view = $ this -> application -> createInstance ( "view" , [ $ this -> application -> response , $ this -> application -> createInstance ( "viewengine" , [ $ this -> application -> response ] ) , $ this -> application ] ) ; $ view -> setData ( "title" , "An Error Occured" ) ; $ this -> application -> response -> send ( $ view -> render ( "errors/error" ) ) ; return Handler :: LAST_HANDLER ; }
2245	public static function getPageStatusIcon ( $ objPage ) { $ sub = 0 ; $ image = $ objPage -> type . '.svg' ; if ( ! $ objPage -> published || ( $ objPage -> start != '' && $ objPage -> start > time ( ) ) || ( $ objPage -> stop != '' && $ objPage -> stop < time ( ) ) ) { ++ $ sub ; } if ( $ objPage -> hide && ! \ in_array ( $ objPage -> type , array ( 'root' , 'error_401' , 'error_403' , 'error_404' ) ) ) { $ sub += 2 ; } if ( $ objPage -> protected && ! \ in_array ( $ objPage -> type , array ( 'root' , 'error_401' , 'error_403' , 'error_404' ) ) ) { $ sub += 4 ; } if ( $ sub > 0 ) { $ image = $ objPage -> type . '_' . $ sub . '.svg' ; } if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getPageStatusIcon' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getPageStatusIcon' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getPageStatusIcon' ] as $ callback ) { $ image = static :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ objPage , $ image ) ; } } return $ image ; }
364	public function renderCaption ( ) { if ( ! empty ( $ this -> caption ) ) { return Html :: tag ( 'caption' , $ this -> caption , $ this -> captionOptions ) ; } return false ; }
830	private function processException ( $ name , $ e ) { $ this -> dispatchEvent ( FixerFileProcessedEvent :: NAME , new FixerFileProcessedEvent ( FixerFileProcessedEvent :: STATUS_EXCEPTION ) ) ; $ this -> errorsManager -> report ( new Error ( Error :: TYPE_EXCEPTION , $ name , $ e ) ) ; }
8910	private function getCallableFunction ( $ method ) { if ( is_callable ( $ method ) ) { return $ method ; } if ( is_string ( $ method ) && is_callable ( array ( $ this , $ method ) ) ) { return array ( $ this , $ method ) ; } return FALSE ; }
295	public function getOldAttribute ( $ name ) { return isset ( $ this -> _oldAttributes [ $ name ] ) ? $ this -> _oldAttributes [ $ name ] : null ; }
6975	private function throwIllegalOperationIfAdjustmentIsImmutable ( ResourceEventInterface $ event ) { if ( $ event -> getHard ( ) ) { return ; } $ adjustment = $ this -> getAdjustmentFromEvent ( $ event ) ; if ( $ adjustment -> isImmutable ( ) ) { throw new IllegalOperationException ( 'ekyna_commerce.sale.message.immutable_element' ) ; } }
4968	public function fromQuery ( $ param = null , $ default = null ) { if ( $ param === null ) { return $ this -> event -> getRequest ( ) -> getQuery ( $ param , $ default ) -> toArray ( ) ; } return $ this -> event -> getRequest ( ) -> getQuery ( $ param , $ default ) ; }
2529	protected function generateGuid ( ) { mt_srand ( ( double ) microtime ( ) * 10000 ) ; $ charId = strtoupper ( md5 ( uniqid ( rand ( ) , true ) ) ) ; $ hyphen = chr ( 45 ) ; $ uuid = substr ( $ charId , 0 , 8 ) . $ hyphen . substr ( $ charId , 8 , 4 ) . $ hyphen . substr ( $ charId , 12 , 4 ) . $ hyphen . substr ( $ charId , 16 , 4 ) . $ hyphen . substr ( $ charId , 20 , 12 ) ; return $ uuid ; }
3184	public function jsonSerialize ( ) { $ source = $ this -> getSource ( ) ; $ timeLimits = $ source -> getTimeLimits ( ) ; if ( ! is_null ( $ timeLimits ) ) { $ identifier = $ source -> getIdentifier ( ) ; $ maxTime = $ timeLimits -> getMaxTime ( ) ; $ minTime = $ timeLimits -> getMinTime ( ) ; $ maxTimeRemaining = $ this -> getMaximumRemainingTime ( ) ; $ minTimeRemaining = $ this -> getMinimumRemainingTime ( ) ; if ( $ maxTimeRemaining !== false || $ minTimeRemaining !== false ) { $ label = method_exists ( $ source , 'getTitle' ) ? $ source -> getTitle ( ) : $ identifier ; $ extraTime = [ ] ; if ( ! is_null ( $ this -> getTimer ( ) ) && $ source -> getTimeLimits ( ) -> hasMaxTime ( ) ) { $ timer = $ this -> getTimer ( ) ; $ maxTimeSeconds = $ source -> getTimeLimits ( ) -> getMaxTime ( ) -> getSeconds ( true ) ; $ extraTime = [ 'total' => $ timer -> getExtraTime ( $ maxTimeSeconds ) , 'consumed' => $ timer -> getConsumedExtraTime ( $ identifier , $ maxTimeSeconds , $ this -> timerTarget ) , 'remaining' => $ timer -> getRemainingExtraTime ( $ identifier , $ maxTimeSeconds , $ this -> timerTarget ) , ] ; } $ labelFormatter = ServiceManager :: getServiceManager ( ) -> get ( TimerLabelFormatterService :: SERVICE_ID ) ; return [ 'label' => $ labelFormatter -> format ( $ label ) , 'source' => $ identifier , 'qtiClassName' => $ source -> getQtiClassName ( ) , 'extraTime' => $ extraTime , 'allowLateSubmission' => $ this -> allowLateSubmission ( ) , 'minTime' => $ this -> durationToMs ( $ minTime ) , 'minTimeRemaining' => $ this -> durationToMs ( $ minTimeRemaining ) , 'maxTime' => $ this -> durationToMs ( $ maxTime ) , 'maxTimeRemaining' => $ this -> durationToMs ( $ maxTimeRemaining ) , ] ; } } return null ; }
1179	protected function getValidationData ( array $ rules , array $ customAttributes = [ ] ) { $ attributes = array_filter ( array_keys ( $ rules ) , function ( $ attribute ) { return $ attribute !== '' && mb_strpos ( $ attribute , '*' ) !== false ; } ) ; $ attributes = array_merge ( array_keys ( $ customAttributes ) , $ attributes ) ; $ data = array_reduce ( $ attributes , function ( $ data , $ attribute ) { Arr :: set ( $ data , $ attribute , true ) ; return $ data ; } , [ ] ) ; return $ data ; }
7296	private function get_mail_to_chunk ( $ to , $ send_next_group = array ( ) ) { $ object_id = $ this -> options [ 'static_options' ] [ 'object' ] [ 'id' ] ; $ object_type = $ this -> options [ 'static_options' ] [ 'object' ] [ 'type' ] ; if ( empty ( $ send_next_group ) ) { $ chunk_size = $ this -> options [ 'static_options' ] [ 'mail_to_chunking' ] [ 'chunksize' ] ; $ send_next_group = array_chunk ( $ to , $ chunk_size ) ; } $ to = apply_filters ( 'iac_email_address_chunk' , array_shift ( $ send_next_group ) , $ object_id , $ object_type ) ; $ to = implode ( ',' , $ to ) ; if ( ! empty ( $ send_next_group ) ) { wp_schedule_single_event ( time ( ) + $ this -> options [ 'static_options' ] [ 'schedule_interval' ] , 'iac_schedule_send_chunks' , array ( $ object_id , $ object_type , $ send_next_group ) ) ; } return $ to ; }
2007	public function onKernelException ( GetResponseForExceptionEvent $ event ) : void { $ exception = $ event -> getException ( ) ; if ( $ exception -> getPrevious ( ) instanceof ResourceNotFoundException && ! $ this -> hasRootPages ( ) ) { $ exception = new NoRootPageFoundException ( 'No root page found' , 0 , $ exception ) ; } $ class = $ this -> getTargetClass ( $ exception ) ; if ( null === $ class ) { return ; } if ( null !== ( $ httpException = $ this -> convertToHttpException ( $ exception , $ class ) ) ) { $ event -> setException ( $ httpException ) ; } }
5344	public function make ( $ wsdl , array $ classMap = [ ] ) { return new SoapClient ( $ wsdl , [ 'trace' => true , 'exceptions' => true , 'encoding' => 'utf-8' , 'features' => SOAP_SINGLE_ELEMENT_ARRAYS , 'classmap' => $ classMap , 'cache_wsdl' => WSDL_CACHE_MEMORY , ] ) ; }
3598	public function parserHttpRequest ( HttpRequest $ httpRequest ) { $ json = \ json_decode ( $ httpRequest -> getContent ( ) , true ) ; if ( JSON_ERROR_NONE !== \ json_last_error ( ) ) { throw new Exceptions \ ParseException ( ) ; } $ createJsonRequest = function ( $ json ) use ( $ httpRequest ) { $ id = null ; $ method = null ; $ params = [ ] ; if ( \ is_array ( $ json ) ) { $ id = \ array_key_exists ( 'id' , $ json ) ? $ json [ 'id' ] : null ; $ method = \ array_key_exists ( 'method' , $ json ) ? $ json [ 'method' ] : null ; $ params = \ array_key_exists ( 'params' , $ json ) ? $ json [ 'params' ] : [ ] ; } $ request = new JsonRequest ( $ method , $ params , $ id ) ; $ request -> headers ( ) -> add ( $ httpRequest -> headers -> all ( ) ) ; return $ request ; } ; if ( \ array_keys ( $ json ) === \ range ( 0 , \ count ( $ json ) - 1 ) ) { $ requests = [ ] ; foreach ( $ json as $ part ) { $ requests [ ] = $ createJsonRequest ( $ part ) ; } } else { $ requests = $ createJsonRequest ( $ json ) ; } return $ requests ; }
11182	public function cacheActions ( DirectCollection $ collection ) { $ serializedCollection = serialize ( $ collection ) ; $ this -> set ( Keys :: EXT_ACTION , $ serializedCollection ) ; }
9900	private function advance ( ) { $ i = $ this -> currentCharacter ; $ formula_length = strlen ( $ this -> formula ) ; if ( $ i < $ formula_length ) { while ( $ this -> formula [ $ i ] == ' ' ) { ++ $ i ; } if ( $ i < ( $ formula_length - 1 ) ) { $ this -> lookAhead = $ this -> formula [ $ i + 1 ] ; } $ token = '' ; } while ( $ i < $ formula_length ) { $ token .= $ this -> formula [ $ i ] ; if ( $ i < ( $ formula_length - 1 ) ) { $ this -> lookAhead = $ this -> formula [ $ i + 1 ] ; } else { $ this -> lookAhead = '' ; } if ( $ this -> match ( $ token ) != '' ) { $ this -> currentCharacter = $ i + 1 ; $ this -> currentToken = $ token ; return 1 ; } if ( $ i < ( $ formula_length - 2 ) ) { $ this -> lookAhead = $ this -> formula [ $ i + 2 ] ; } else { $ this -> lookAhead = '' ; } ++ $ i ; } }
4819	public function getIterator ( IteratorFilter $ itf = null ) { if ( is_null ( $ itf ) ) { return new AnyIterator ( $ this -> collection ) ; } return new AnyIterator ( $ itf -> match ( $ this -> collection ) ) ; }
11549	public function onExecuteAction ( ExecuteActionEvent $ event ) { $ request = $ event -> getRequest ( ) ; $ authenticate = $ request -> getConfig ( ) -> getObject ( 'authenticate' ) ; if ( $ authenticate ) { $ this -> execute ( $ event , $ authenticate ) ; } }
8889	public function set ( $ key , $ value ) { if ( is_callable ( $ value ) ) { $ this -> registerFactory ( $ key , $ value , false ) ; } else { $ this -> sm -> setService ( $ key , $ value ) ; } }
8	public function fix ( $ packageName , ConstraintInterface $ constraint = null ) { $ this -> addJob ( $ packageName , 'install' , $ constraint , true ) ; }
9890	public static function xml ( $ response ) { $ body = self :: toString ( $ response ) ; $ errorMessage = null ; $ internalErrors = libxml_use_internal_errors ( true ) ; $ disableEntities = libxml_disable_entity_loader ( true ) ; libxml_clear_errors ( ) ; $ xml = null ; try { $ xml = new \ SimpleXMLElement ( ( string ) $ body ? : '<root />' , LIBXML_NONET ) ; } catch ( \ Exception $ e ) { $ errorMessage = $ e -> getMessage ( ) ; } libxml_clear_errors ( ) ; libxml_use_internal_errors ( $ internalErrors ) ; libxml_disable_entity_loader ( $ disableEntities ) ; if ( $ errorMessage !== null ) { throw new RuntimeException ( 'Unable to parse response body into XML: ' . $ errorMessage ) ; } return $ xml ; }
7959	public function getPairsNumber ( $ forceReload = false ) { if ( ! $ this -> properties || $ forceReload ) $ this -> getProperties ( ) ; return $ this -> properties -> pairsNumber ; }
6180	protected function write ( array $ record ) { $ severity = $ this -> getSeverity ( $ record [ 'level' ] ) ; if ( isset ( $ record [ 'context' ] [ 'exception' ] ) ) { $ this -> client -> notifyException ( $ record [ 'context' ] [ 'exception' ] , function ( \ Bugsnag \ Report $ report ) use ( $ record , $ severity ) { $ report -> setSeverity ( $ severity ) ; if ( isset ( $ record [ 'extra' ] ) ) { $ report -> setMetaData ( $ record [ 'extra' ] ) ; } } ) ; } else { $ this -> client -> notifyError ( ( string ) $ record [ 'message' ] , ( string ) $ record [ 'formatted' ] , function ( \ Bugsnag \ Report $ report ) use ( $ record , $ severity ) { $ report -> setSeverity ( $ severity ) ; if ( isset ( $ record [ 'extra' ] ) ) { $ report -> setMetaData ( $ record [ 'extra' ] ) ; } } ) ; } }
5917	public function updateSetting ( $ key , $ value ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'value' => $ value ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> put ( 'v1/accounts/settings/' . $ key . '' , $ parameters ) ; return $ result ; }
10362	public static function exception ( $ exception ) { try { while ( ob_get_level ( ) > 0 ) ob_end_clean ( ) ; $ error [ 'code' ] = $ exception -> getCode ( ) ; $ error [ 'message' ] = $ exception -> getMessage ( ) ; $ error [ 'file' ] = $ exception -> getFile ( ) ; $ error [ 'line' ] = $ exception -> getLine ( ) ; if ( $ exception instanceof \ ErrorException ) { $ error [ 'type' ] = 'ErrorException: ' ; $ error [ 'type' ] .= in_array ( $ error [ 'code' ] , array_keys ( ErrorHandler :: $ levels ) ) ? ErrorHandler :: $ levels [ $ error [ 'code' ] ] : 'Unknown Error' ; } else { $ error [ 'type' ] = get_class ( $ exception ) ; } ErrorHandler :: writeLogs ( "{$error['type']}: {$error['message']} in {$error['file']} at line {$error['line']}" ) ; @ header ( 'Content-Type: text/html; charset=UTF-8' ) ; if ( DEVELOPMENT ) { $ error [ 'backtrace' ] = $ exception -> getTrace ( ) ; if ( $ exception instanceof \ ErrorException ) { $ error [ 'backtrace' ] = array_slice ( $ error [ 'backtrace' ] , 1 ) ; } $ error [ 'backtrace' ] = self :: formatBacktrace ( $ error [ 'backtrace' ] ) ; $ error [ 'highlighted' ] = self :: highlightCode ( $ error [ 'file' ] , $ error [ 'line' ] ) ; @ header ( 'HTTP/1.1 500 Internal Server Error' ) ; include 'views/exception.php' ; } else { @ header ( 'HTTP/1.1 500 Internal Server Error' ) ; include 'views/production.php' ; } } catch ( Exception $ e ) { while ( ob_get_level ( ) > 0 ) ob_end_clean ( ) ; echo $ e -> getMessage ( ) . ' in ' . $ e -> getFile ( ) . ' (line ' . $ e -> getLine ( ) . ').' ; } exit ( 1 ) ; }
5704	public function Field ( $ properties = array ( ) ) { if ( $ this -> isGrouped ( ) ) { $ this -> transformToInput ( ) ; } else { $ this -> transformToButton ( ) ; } return parent :: Field ( $ properties ) ; }
3574	protected function update ( $ key , $ value = null , $ group = null ) { if ( $ key instanceof Attribute ) { $ value = $ key -> getValue ( ) ; $ group = $ key -> getMetaGroup ( ) ; $ key = $ key -> getMetaKey ( ) ; } $ this -> get ( $ key ) -> setValue ( $ value ) ; $ this -> get ( $ key ) -> setMetaGroup ( $ group ) ; return $ this ; }
9481	public function respondWithResult ( $ data = NULL ) { $ res [ 'status' ] = $ this -> getStatusText ( ) ; if ( $ this -> getErrorCode ( ) && $ this -> getStatusCode ( ) == 420 ) { $ res [ 'error' ] = $ this -> getErrorCode ( ) ; $ res [ 'message' ] = $ data ; } else { $ res [ 'result' ] = $ data ; } return $ this -> respond ( $ res ) ; }
7306	protected function getCustomerFromEvent ( ResourceEventInterface $ event ) { $ resource = $ event -> getResource ( ) ; if ( ! $ resource instanceof CustomerInterface ) { throw new InvalidArgumentException ( 'Expected instance of ' . CustomerInterface :: class ) ; } return $ resource ; }
2651	public function activateVersion ( $ version ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/activate' ; $ result = $ this -> _fetch ( $ url , 'PUT' ) ; return $ result ; }
2547	public function analyzeResponse ( $ sendResult , $ messageName ) { if ( ! empty ( $ sendResult -> exception ) ) { return $ this -> makeResultForException ( $ sendResult ) ; } $ handler = $ this -> findHandlerForMessage ( $ messageName ) ; if ( $ handler instanceof MessageResponseHandler ) { return $ handler -> analyze ( $ sendResult ) ; } else { return new Result ( $ sendResult , Result :: STATUS_UNKNOWN ) ; } }
11488	public function setName ( string $ name ) : void { if ( ! empty ( $ name ) ) { if ( ! is_numeric ( $ name ) ) { @ session_name ( $ name ) ; } else { throw new Exception ( 'The session name can\'t consist only of digits, ' . 'at least one letter must be presented.' ) ; } } else { throw new Exception ( 'Empty session name value was passed.' ) ; } }
4737	public function sendException ( Request $ request , \ Exception $ exception ) { if ( ! $ this -> enabled ) { return ; } $ serverParams = $ request -> server -> all ( ) ; if ( isset ( $ serverParams [ 'PHP_AUTH_PW' ] ) ) { $ serverParams [ 'PHP_AUTH_PW' ] = '*****' ; } $ message = \ Swift_Message :: newInstance ( ) -> setSubject ( 'Error message from ' . $ request -> getHost ( ) . ' - ' . $ exception -> getMessage ( ) ) -> setFrom ( $ this -> from ) -> setTo ( $ this -> to ) -> setContentType ( 'text/html' ) -> setBody ( $ this -> templating -> render ( "SoclozMonitoringBundle:Notify:exception.html.twig" , array ( 'request' => $ request , 'exception' => $ exception , 'exception_class' => \ get_class ( $ exception ) , 'request_headers' => $ request -> server -> getHeaders ( ) , 'request_attributes' => $ this -> mailerTransformer -> transform ( $ request -> attributes -> all ( ) ) , 'server_params' => $ this -> mailerTransformer -> transform ( $ serverParams ) , ) ) ) ; try { $ this -> getMailer ( ) -> send ( $ message ) ; } catch ( \ Exception $ e ) { $ this -> logger -> error ( 'Sending mail error - ' . $ e -> getMessage ( ) ) ; } }
327	public function send ( MailerInterface $ mailer = null ) { if ( $ mailer === null && $ this -> mailer === null ) { $ mailer = Yii :: $ app -> getMailer ( ) ; } elseif ( $ mailer === null ) { $ mailer = $ this -> mailer ; } return $ mailer -> send ( $ this ) ; }
1582	public function withRelationships ( $ relationships ) : self { $ copy = clone $ this ; $ copy -> relationships = collect ( $ relationships ) -> all ( ) ; $ copy -> normalize ( ) ; return $ copy ; }
10486	protected function retrieveMapping ( $ table ) { $ result = $ this -> connection -> fetchAll ( 'SELECT COLUMN_NAME, ORDINAL_POSITION FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = ?' , [ $ table ] ) ; if ( empty ( $ result ) ) { return false ; } $ columns = [ ] ; foreach ( $ result as $ column ) { $ columns [ $ column [ 'ORDINAL_POSITION' ] ] = $ column [ 'COLUMN_NAME' ] ; } return $ columns ; }
6006	public function toUnicode ( ) { $ h = ord ( $ this -> char { 0 } ) ; if ( $ h <= 0x7F ) { return $ h ; } else { if ( $ h < 0xC2 ) { return false ; } else { if ( $ h <= 0xDF ) { return ( $ h & 0x1F ) << 6 | ( ord ( $ this -> char { 1 } ) & 0x3F ) ; } else { if ( $ h <= 0xEF ) { return ( $ h & 0x0F ) << 12 | ( ord ( $ this -> char { 1 } ) & 0x3F ) << 6 | ( ord ( $ this -> char { 2 } ) & 0x3F ) ; } else { if ( $ h <= 0xF4 ) { return ( $ h & 0x0F ) << 18 | ( ord ( $ this -> char { 1 } ) & 0x3F ) << 12 | ( ord ( $ this -> char { 2 } ) & 0x3F ) << 6 | ( ord ( $ this -> char { 3 } ) & 0x3F ) ; } else { return false ; } } } } } }
3268	protected function closeFile ( SplFileObject & $ file ) { if ( ! $ this -> getConfig ( ) -> useGzip ( ) && ! $ file -> flock ( LOCK_UN ) ) { $ file = null ; throw new Exception ( 'Could not unlock file' ) ; } $ file = null ; }
9452	public function query ( $ index , array $ filters = null , array $ queries = null , array $ fieldWeights = null , $ limit = 20 , $ offset = 0 ) { $ sphinxClient = $ this -> getSphinxClient ( ) ; $ sphinxClient -> SetLimits ( $ offset , $ limit ) ; if ( null !== $ filters ) { foreach ( $ filters as $ filter ) { if ( ! isset ( $ filter [ 'key' ] ) ) { } if ( array_key_exists ( 'min' , $ filter ) && array_key_exists ( 'max' , $ filter ) ) { $ sphinxClient -> SetFilterRange ( $ filter [ 'key' ] , ( integer ) $ filter [ 'min' ] , ( integer ) $ filter [ 'max' ] ) ; } else { if ( ! isset ( $ filter [ 'values' ] ) || ! is_array ( $ filter [ 'values' ] ) ) { } $ sphinxClient -> SetFilter ( $ filter [ 'key' ] , $ filter [ 'values' ] ) ; } } } if ( null !== $ queries ) { foreach ( $ queries as $ key => $ queryInfo ) { $ query = $ this -> implodeQueryValues ( $ queryInfo ) ; if ( array_key_exists ( 'countableAttributes' , $ queryInfo ) ) { $ array = $ queryInfo [ 'countableAttributes' ] ; if ( ! is_array ( $ array ) ) { $ array = [ $ array ] ; } $ sphinxClient -> addFacetedQuery ( $ query , $ index , $ array ) ; } else { $ sphinxClient -> AddQuery ( $ query , $ index ) ; } } } if ( null !== $ fieldWeights ) { $ sphinxClient -> SetFieldWeights ( $ fieldWeights ) ; } $ result = $ this -> getResult ( $ sphinxClient ) ; return $ result ; }
11919	public function attr ( $ keys = [ ] ) { if ( ! is_array ( $ keys ) ) { $ keys = [ $ keys ] ; } $ out = '' ; foreach ( $ keys as $ key ) { $ value = $ this -> getValue ( $ key ) -> attr ( ) ; if ( ! empty ( $ value ) ) { $ out .= ' ' . $ value ; } } return ltrim ( $ out , ' ' ) ; }
9798	public function setHyperlink ( Hyperlink $ pHyperlink = null ) { if ( ! isset ( $ this -> parent ) ) { throw new Exception ( 'Cannot set hyperlink for cell that is not bound to a worksheet' ) ; } $ this -> getWorksheet ( ) -> setHyperlink ( $ this -> getCoordinate ( ) , $ pHyperlink ) ; return $ this -> updateInCollection ( ) ; }
7576	protected function configureData ( $ data ) { if ( is_string ( $ data ) ) { if ( ! empty ( $ this -> Options ) ) { $ fileField = end ( $ this -> Options ) ; $ data = array ( $ fileField => $ data ) ; } else { throw new RequiredOptionsException ( get_called_class ( ) , "Options are required, when passing String for data." ) ; } } if ( is_array ( $ data ) ) { foreach ( $ data as $ key => $ value ) { if ( ! array_key_exists ( $ key , $ this -> _REQUIRED_DATA ) ) { $ data [ $ key ] = $ this -> setFileFieldValue ( $ value ) ; } } } parent :: configureData ( $ data ) ; }
10334	public function setName ( $ pValue ) { if ( $ pValue == '' ) { $ pValue = 'Calibri' ; } if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'name' => $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> name = $ pValue ; } return $ this ; }
11759	public function deleteReply ( $ msgId , $ index , $ commentId ) { $ params = [ 'msg_data_id' => $ msgId , 'index' => $ index , 'user_comment_id' => $ commentId , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_DELETE_REPLY , $ params ] ) ; }
8845	public function build ( ContainerBuilder $ container ) { $ container -> addCompilerPass ( new ThemeCompilerPass ( ) , PassConfig :: TYPE_BEFORE_OPTIMIZATION , - 10 ) ; $ container -> addCompilerPass ( new ThemeProviderPass ( ) ) ; }
5494	public function findFirstAction ( $ parameters ) { $ slot = $ this -> findFirstSlot ( $ parameters ) ; if ( isset ( $ slot ) && isset ( $ slot [ 'content' ] ) ) { return $ slot [ 'content' ] ; } return ; }
9298	public function getHome ( ) { $ query = $ this -> createQueryBuilder ( 'c' ) -> join ( 'c.forums' , 'f' ) -> join ( 'f.lastMessage' , 'm' ) -> join ( 'm.user' , 'u' ) -> addSelect ( 'f' ) -> addSelect ( 'm' ) -> addSelect ( 'u' ) -> where ( 'f.status = :status' ) -> setParameter ( 'status' , Forum :: STATUS_PUBLIC ) ; $ query -> orderBy ( 'c.position' , 'ASC' ) -> addOrderBy ( 'f.position' , 'ASC' ) ; return $ query -> getQuery ( ) ; }
8089	static protected function encode ( $ number ) { $ k = self :: $ encoder ; preg_match_all ( "/[1-9][0-9]|[0-9]/" , $ number , $ a ) ; $ n = '' ; $ o = count ( $ k ) ; foreach ( $ a [ 0 ] as $ i ) { if ( $ i < $ o ) { $ n .= $ k [ $ i ] ; } else { $ n .= '1' . $ k [ $ i - $ o ] ; } } return $ n ; }
3120	public function remove ( $ tag , $ target = TimePoint :: TARGET_ALL , $ type = TimePoint :: TYPE_ALL ) { $ tags = is_array ( $ tag ) ? $ tag : [ $ tag ] ; $ removed = 0 ; foreach ( $ this -> points as $ idx => $ point ) { if ( $ point -> match ( $ tags , $ target , $ type ) ) { unset ( $ this -> points [ $ idx ] ) ; $ removed ++ ; } } return $ removed ; }
11850	public static function createFault ( $ code , $ message ) { $ response = new \ SimpleXMLElement ( "<methodResponse></methodResponse>" ) ; $ struct = $ response -> addChild ( "fault" ) -> addChild ( "value" ) -> addChild ( "struct" ) ; $ member = $ struct -> addChild ( "member" ) ; $ member -> addChild ( "name" , "faultCode" ) ; $ member -> addChild ( "value" ) -> addChild ( "int" , $ code ) ; $ member = $ struct -> addChild ( "member" ) ; $ member -> addChild ( "name" , "faultString" ) ; $ member -> addChild ( "value" , $ message ) ; return $ response -> asXML ( ) ; }
4783	public function getModule ( ) { if ( ! is_object ( $ this -> _module ) ) { $ this -> _module = Yii :: $ app -> getModule ( $ this -> _module ) ; } return $ this -> _module ; }
717	public function dateTime ( $ precision = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_DATETIME , $ precision ) ; }
7338	public function createEvent ( Request $ request ) : Event { if ( empty ( $ request -> input ( ) ) ) { return new Unknown ( ) ; } $ update = new Update ( $ request -> input ( ) ) ; $ this -> update = $ update ; if ( $ message = $ update -> message ) { $ chat = new Chat ( ( string ) $ message -> chat -> id , $ message -> chat -> title , $ message -> chat -> type ) ; $ from = new User ( ( string ) $ message -> from -> id , $ message -> from -> first_name , $ message -> from -> username ) ; return new MessageReceived ( $ chat , $ from , $ message -> text , $ message -> location , null , optional ( $ update -> callback_query ) -> data , $ update ) ; } if ( $ callbackQuery = $ update -> callback_query ) { $ message = $ callbackQuery -> message ; $ chat = new Chat ( ( string ) $ message -> chat -> id , $ message -> chat -> title , $ message -> chat -> type ) ; $ from = new User ( ( string ) $ message -> chat -> id , $ message -> from -> first_name , $ message -> from -> username ) ; return new MessageReceived ( $ chat , $ from , $ message -> text , $ message -> location , null , $ callbackQuery -> data , $ update ) ; } return new Unknown ( ) ; }
5291	public static function simpleDetect ( $ text ) { $ detections = self :: detect ( $ text ) ; if ( count ( $ detections ) > 0 ) return $ detections [ 0 ] -> language ; else return null ; }
921	private function fixAnnotations ( DocBlock $ doc ) { foreach ( $ doc -> getAnnotations ( ) as $ index => $ annotation ) { $ next = $ doc -> getAnnotation ( $ index + 1 ) ; if ( null === $ next ) { break ; } if ( true === $ next -> getTag ( ) -> valid ( ) ) { if ( TagComparator :: shouldBeTogether ( $ annotation -> getTag ( ) , $ next -> getTag ( ) ) ) { $ this -> ensureAreTogether ( $ doc , $ annotation , $ next ) ; } else { $ this -> ensureAreSeparate ( $ doc , $ annotation , $ next ) ; } } } return $ doc -> getContent ( ) ; }
10646	public function execute ( ) { $ ch = curl_init ( ) ; curl_setopt ( $ ch , CURLOPT_URL , $ this -> getURI ( ) ) ; curl_setopt ( $ ch , CURLOPT_RETURNTRANSFER , true ) ; curl_setopt ( $ ch , CURLOPT_POST , true ) ; curl_setopt ( $ ch , CURLOPT_POSTFIELDS , $ this -> data ) ; $ response = curl_exec ( $ ch ) ; $ result = json_decode ( $ response ) ; curl_close ( $ ch ) ; if ( empty ( $ result ) || ! $ result -> success ) { throw new \ Exception ( "Pipedrive API error!" ) ; } return $ result ; }
4247	private function logRequestHeaders ( ) { if ( ! $ this -> debug -> getCfg ( 'logEnvInfo.headers' ) ) { return ; } if ( ! empty ( $ _SERVER [ 'argv' ] ) ) { return ; } $ headers = $ this -> debug -> utilities -> getAllHeaders ( ) ; \ ksort ( $ headers , SORT_NATURAL ) ; $ this -> debug -> log ( 'request headers' , $ headers ) ; }
6897	public function bind ( $ key , & $ value ) { $ this -> open ( ) ; $ this -> _data [ $ key ] = & $ value ; return $ this ; }
1954	public static function findExpiredSubscriptions ( array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ objDatabase = Database :: getInstance ( ) ; $ objResult = $ objDatabase -> prepare ( "SELECT * FROM $t WHERE active='' AND EXISTS (SELECT * FROM tl_opt_in_related r LEFT JOIN tl_opt_in o ON r.pid=o.id WHERE r.relTable='$t' AND r.relId=$t.id AND o.createdOn<=? AND o.confirmedOn=0)" ) -> execute ( strtotime ( '-24 hours' ) ) ; if ( $ objResult -> numRows < 1 ) { return null ; } return static :: createCollectionFromDbResult ( $ objResult , $ t ) ; }
12242	public function asPrettyXML ( $ filepath = null ) { $ xml = dom_import_simplexml ( new SimpleXMLElement ( $ this -> asXML ( ) ) ) ; $ xsl = new DOMDocument ; $ xsl -> loadXML ( '<?xml version="1.0" encoding="utf-8"?><xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"> <xsl:output method="xml" indent="yes" /> <xsl:template match="text()"> <!-- remove everything that contains only whitespace, with at least one LF ) ; $ xslt = new XSLTProcessor ; $ xslt -> importStylesheet ( $ xsl ) ; $ result = trim ( $ xslt -> transformToXML ( $ xml ) ) ; if ( isset ( $ filepath ) ) { return ( bool ) file_put_contents ( $ filepath , $ result ) ; } return $ result ; }
7629	public function setContainerAcl ( $ containerName = '' , $ acl = self :: ACL_PRIVATE , $ signedIdentifiers = array ( ) ) { Assertion :: notEmpty ( $ containerName , 'Container name is not specified' ) ; self :: assertValidContainerName ( $ containerName ) ; $ headers = array ( ) ; if ( $ acl != self :: ACL_PRIVATE && ! is_null ( $ acl ) && $ acl != '' ) { $ headers [ Storage :: PREFIX_STORAGE_HEADER . 'blob-public-access' ] = $ acl ; } $ policies = null ; if ( is_array ( $ signedIdentifiers ) && count ( $ signedIdentifiers ) > 0 ) { $ policies = '' ; $ policies .= '<?xml version="1.0" encoding="utf-8"?>' . "\r\n" ; $ policies .= '<SignedIdentifiers>' . "\r\n" ; foreach ( $ signedIdentifiers as $ signedIdentifier ) { $ policies .= ' <SignedIdentifier>' . "\r\n" ; $ policies .= ' <Id>' . $ signedIdentifier -> Id . '</Id>' . "\r\n" ; $ policies .= ' <AccessPolicy>' . "\r\n" ; if ( $ signedIdentifier -> Start != '' ) $ policies .= ' <Start>' . $ signedIdentifier -> Start . '</Start>' . "\r\n" ; if ( $ signedIdentifier -> Expiry != '' ) $ policies .= ' <Expiry>' . $ signedIdentifier -> Expiry . '</Expiry>' . "\r\n" ; if ( $ signedIdentifier -> Permissions != '' ) $ policies .= ' <Permission>' . $ signedIdentifier -> Permissions . '</Permission>' . "\r\n" ; $ policies .= ' </AccessPolicy>' . "\r\n" ; $ policies .= ' </SignedIdentifier>' . "\r\n" ; } $ policies .= '</SignedIdentifiers>' . "\r\n" ; } $ response = $ this -> performRequest ( $ containerName , array ( 'restype' => 'container' , 'comp' => 'acl' ) , 'PUT' , $ headers , false , $ policies , self :: RESOURCE_CONTAINER , self :: PERMISSION_WRITE ) ; if ( ! $ response -> isSuccessful ( ) ) { throw new BlobException ( $ this -> getErrorMessage ( $ response , 'Resource could not be accessed.' ) ) ; } }
1239	private static function getActualType ( $ value ) { $ actualType = gettype ( $ value ) ; if ( 'object' === $ actualType ) { $ actualType = get_class ( $ value ) ; } return $ actualType ; }
9598	protected function flashInput ( Request $ request = null ) { if ( $ request === null ) { $ request = $ this -> container -> resolve ( 'Symfony\Component\HttpFoundation\RequestStack' ) -> getCurrentRequest ( ) ; } $ this -> flash ( '_old_input' , $ request -> request -> all ( ) ) ; }
11511	protected static function unescapeString ( $ matches ) { static $ map = [ 'n' => "\n" , 'r' => "\r" , 't' => "\t" , 'v' => "\v" , 'f' => "\f" ] ; if ( ! empty ( $ matches [ 2 ] ) ) return chr ( octdec ( $ matches [ 2 ] ) ) ; elseif ( ! empty ( $ matches [ 3 ] ) ) return chr ( hexdec ( $ matches [ 3 ] ) ) ; elseif ( isset ( $ map [ $ matches [ 1 ] ] ) ) return $ map [ $ matches [ 1 ] ] ; return $ matches [ 1 ] ; }
6552	public function lock ( ) { if ( $ this -> pid === $ this -> getSerial ( ) ) { return ; } $ this -> pid = $ this -> getSerial ( ) ; $ this -> fh = fopen ( $ filename = $ this -> getPidFilename ( ) , 'a+' ) ; if ( ! flock ( $ this -> fh , LOCK_EX | LOCK_NB ) ) { throw new ImportAlreadyRunningException ( sprintf ( 'PID file %s is already in use' , $ filename ) ) ; } if ( fwrite ( $ this -> fh , $ this -> pid . PHP_EOL ) === false ) { throw new \ Exception ( sprintf ( 'Can\'t write PID %s to PID file %s' , $ this -> pid , $ filename ) ) ; } }
11024	protected function buildGroupBy ( ) { $ result = [ ] ; foreach ( $ this -> clause_groupby as $ grp ) { $ result [ ] = $ grp [ 0 ] ? $ grp [ 1 ] : $ this -> quote ( $ grp [ 1 ] ) ; } return $ result ; }
735	protected function getDirectPermissionsByUser ( $ userId ) { $ permissions = [ ] ; foreach ( $ this -> getAssignments ( $ userId ) as $ name => $ assignment ) { $ permission = $ this -> items [ $ assignment -> roleName ] ; if ( $ permission -> type === Item :: TYPE_PERMISSION ) { $ permissions [ $ name ] = $ permission ; } } return $ permissions ; }
2866	public function getTotalLineCount ( ) { if ( $ this -> logLineCount === null ) { $ this -> logLineCount = 0 ; foreach ( $ this -> getFiles ( ) as $ log ) { $ this -> logLineCount += $ this -> getLineCount ( $ log ) ; } } return $ this -> logLineCount ; }
741	public function beforeRun ( $ event ) { $ cacheKey = $ this -> getCacheKey ( ) ; $ fragmentCacheConfiguration = $ this -> getFragmentCacheConfiguration ( ) ; if ( ! $ this -> owner -> view -> beginCache ( $ cacheKey , $ fragmentCacheConfiguration ) ) { $ event -> isValid = false ; } }
2305	protected function doCreatePageList ( $ intId = 0 , $ level = - 1 ) { $ objPages = $ this -> Database -> prepare ( "SELECT id, title, type, dns FROM tl_page WHERE pid=? ORDER BY sorting" ) -> execute ( $ intId ) ; if ( $ objPages -> numRows < 1 ) { return '' ; } ++ $ level ; $ strOptions = '' ; while ( $ objPages -> next ( ) ) { if ( $ objPages -> type == 'root' ) { if ( $ objPages -> dns && $ objPages -> dns != Environment :: get ( 'host' ) ) { continue ; } $ strOptions .= '<optgroup label="' . $ objPages -> title . '">' ; $ strOptions .= $ this -> doCreatePageList ( $ objPages -> id , - 1 ) ; $ strOptions .= '</optgroup>' ; } else { $ strOptions .= sprintf ( '<option value="{{link_url::%s}}"%s>%s%s</option>' , $ objPages -> id , ( ( '{{link_url::' . $ objPages -> id . '}}' == Input :: get ( 'value' ) ) ? ' selected="selected"' : '' ) , str_repeat ( ' &nbsp; &nbsp; ' , $ level ) , StringUtil :: specialchars ( $ objPages -> title ) ) ; $ strOptions .= $ this -> doCreatePageList ( $ objPages -> id , $ level ) ; } } return $ strOptions ; }
12315	public function sortAction ( Request $ request ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; if ( $ request -> isXmlHttpRequest ( ) ) { $ this -> get ( 'admin_manager' ) -> sort ( 'BlogBundle:Category' , $ request -> get ( 'values' ) ) ; return new Response ( 0 , 200 ) ; } $ categories = $ em -> getRepository ( 'BlogBundle:Category' ) -> findBy ( array ( 'parentCategory' => NULL ) , array ( 'order' => 'asc' ) ) ; return array ( 'categories' => $ categories ) ; }
5523	public function generateSubclass ( $ methods ) { if ( ! $ this -> reflection -> classOrInterfaceExists ( ) ) { return false ; } $ mock_class = "" ; if ( ! empty ( $ this -> namespace ) ) { $ mock_class .= $ this -> namespace . '\\' ; } $ mock_class .= $ this -> mock_class ; $ mock_reflection = new SimpleReflection ( $ mock_class ) ; if ( $ mock_reflection -> classExistsWithoutAutoload ( ) ) { return false ; } if ( $ this -> reflection -> isInterface ( ) || $ this -> reflection -> hasFinal ( ) ) { $ code = $ this -> createCodeForClass ( $ methods ? $ methods : array ( ) ) ; return eval ( "$code return \$code;" ) ; } else { $ code = $ this -> createCodeForSubclass ( $ methods ? $ methods : array ( ) ) ; return eval ( "$code return \$code;" ) ; } }
1175	protected function jsConvertRules ( $ attribute , $ rules , $ includeRemote ) { $ jsRules = [ ] ; foreach ( $ rules as $ rawRule ) { list ( $ rule , $ parameters ) = $ this -> validator -> parseRule ( $ rawRule ) ; list ( $ jsAttribute , $ jsRule , $ jsParams ) = $ this -> rules -> getRule ( $ attribute , $ rule , $ parameters , $ rawRule ) ; if ( $ this -> isValidatable ( $ jsRule , $ includeRemote ) ) { $ jsRules [ $ jsAttribute ] [ $ jsRule ] [ ] = [ $ rule , $ jsParams , $ this -> messages -> getMessage ( $ attribute , $ rule , $ parameters ) , $ this -> validator -> isImplicit ( $ rule ) , ] ; } } return $ jsRules ; }
2715	public function render ( ) { return [ 'id' => $ this -> getId ( ) , 'translate' => 'label comment' , 'showInDefault' => 1 , 'showInWebsite' => 0 , 'showInStore' => 0 , 'sortOrder' => 1 , 'label' => $ this -> label , 'comment' => $ this -> comment , '_elementType' => 'group' , 'path' => self :: BASE_CONFIG_PATH , 'children' => $ this -> children ] ; }
8458	public function updateDb ( ) { $ this -> printTaskInfo ( 'Do database updates' ) ; $ this -> drush ( 'updb' ) ; $ drushVersion = $ this -> getVersion ( ) ; if ( - 1 === version_compare ( $ drushVersion , '6.0' ) ) { $ this -> printTaskInfo ( 'Will clear cache after db updates for drush ' . $ drushVersion ) ; $ this -> clearCache ( ) ; } else { $ this -> printTaskInfo ( 'Will not clear cache after db updates, since drush ' . $ drushVersion . ' should do it automatically' ) ; } return $ this ; }
7449	public function exec ( string $ execfile , array $ args ) : bool { return $ this -> process -> exec ( $ execfile , $ args ) ; }
5160	public function getAttachmentByField ( string $ field ) : array { if ( isset ( $ this -> attachment [ $ field ] ) ) { return $ this -> attachment [ $ field ] ; } return [ ] ; }
5447	protected function addAttributeTokens ( ) { $ this -> mapHandler ( 'dq_attribute' , 'acceptAttributeToken' ) ; $ this -> addEntryPattern ( '=\s*"' , 'tag' , 'dq_attribute' ) ; $ this -> addPattern ( '\\\\"' , 'dq_attribute' ) ; $ this -> addExitPattern ( '"' , 'dq_attribute' ) ; $ this -> mapHandler ( 'sq_attribute' , 'acceptAttributeToken' ) ; $ this -> addEntryPattern ( "=\s*'" , 'tag' , 'sq_attribute' ) ; $ this -> addPattern ( "\\\\'" , 'sq_attribute' ) ; $ this -> addExitPattern ( "'" , 'sq_attribute' ) ; $ this -> mapHandler ( 'uq_attribute' , 'acceptAttributeToken' ) ; $ this -> addSpecialPattern ( '=\s*[^>\s]*' , 'tag' , 'uq_attribute' ) ; }
2106	public function getMaxUploadFileSize ( ) { $ objResult = Database :: getInstance ( ) -> prepare ( "SELECT MAX(maxlength) AS maxlength FROM tl_form_field WHERE pid=? AND invisible='' AND type='upload' AND maxlength>0" ) -> execute ( $ this -> id ) ; if ( $ objResult -> numRows > 0 && $ objResult -> maxlength > 0 ) { return $ objResult -> maxlength ; } else { return Config :: get ( 'maxFileSize' ) ; } }
7125	static public function equals ( AddressInterface $ source , AddressInterface $ target ) { if ( ! ( $ source -> getCompany ( ) === $ target -> getCompany ( ) && $ source -> getGender ( ) === $ target -> getGender ( ) && $ source -> getFirstName ( ) === $ target -> getFirstName ( ) && $ source -> getLastName ( ) === $ target -> getLastName ( ) && $ source -> getStreet ( ) === $ target -> getStreet ( ) && $ source -> getComplement ( ) === $ target -> getComplement ( ) && $ source -> getSupplement ( ) === $ target -> getSupplement ( ) && $ source -> getExtra ( ) === $ target -> getExtra ( ) && $ source -> getCity ( ) === $ target -> getCity ( ) && $ source -> getPostalCode ( ) === $ target -> getPostalCode ( ) && $ source -> getDigicode1 ( ) === $ target -> getDigicode1 ( ) && $ source -> getDigicode2 ( ) === $ target -> getDigicode2 ( ) && $ source -> getIntercom ( ) === $ target -> getIntercom ( ) ) ) { return false ; } $ sourceCountryId = $ source -> getCountry ( ) ? $ source -> getCountry ( ) -> getId ( ) : null ; $ targetCountryId = $ target -> getCountry ( ) ? $ target -> getCountry ( ) -> getId ( ) : null ; if ( $ sourceCountryId != $ targetCountryId ) { return false ; } $ sourceStateId = $ source -> getState ( ) ? $ source -> getState ( ) -> getId ( ) : null ; $ targetStateId = $ target -> getState ( ) ? $ target -> getState ( ) -> getId ( ) : null ; if ( $ sourceStateId != $ targetStateId ) { return false ; } $ sourcePhone = ( string ) $ source -> getPhone ( ) ; $ targetPhone = ( string ) $ target -> getPhone ( ) ; if ( $ sourcePhone !== $ targetPhone ) { return false ; } $ sourceMobile = ( string ) $ source -> getMobile ( ) ; $ targetMobile = ( string ) $ target -> getMobile ( ) ; if ( $ sourceMobile !== $ targetMobile ) { return false ; } return true ; }
12958	public function inject ( ... $ injects ) : void { $ container = new Container ; $ requested = [ ] ; foreach ( $ injects as $ inject ) { if ( is_string ( $ inject ) ) { $ requested [ ] = $ inject ; } elseif ( is_callable ( $ inject ) ) { $ reflection = new ReflectionFunction ( $ inject ) ; foreach ( $ reflection -> getParameters ( ) as $ param ) { $ requested [ ] = $ param -> name ; } } } foreach ( $ requested as $ dependency ) { $ this -> $ dependency = $ container -> get ( $ dependency ) ; } }
978	protected function validateShop ( Request $ request ) { $ shopParam = ShopifyApp :: sanitizeShopDomain ( $ request -> get ( 'shop' ) ) ; $ shop = ShopifyApp :: shop ( $ shopParam ) ; $ session = new ShopSession ( $ shop ) ; if ( $ shop === null || $ shop -> trashed ( ) || empty ( $ session -> getToken ( true ) ) || ( $ shopParam && $ shopParam !== $ shop -> shopify_domain ) === true ) { $ session -> forget ( ) ; Session :: put ( 'return_to' , $ request -> fullUrl ( ) ) ; return Redirect :: route ( 'authenticate' , [ 'shop' => $ shopParam ] ) ; } return true ; }
6506	public function serializeReturnValue ( $ type , $ value ) { $ jobType = $ this -> registry -> get ( $ type ) ; return $ this -> serializer -> serialize ( $ value , 'json' , $ this -> getResponseSerializationContext ( $ jobType ) ) ; }
11670	public function getClientBy ( $ selector , $ value , $ callable = null ) { $ selector = strtolower ( $ selector ) ; if ( ! in_array ( $ selector , array ( 'id' , 'key' , 'slot' , 'role' , 'alias' , 'command' ) ) ) { throw new \ InvalidArgumentException ( "Invalid selector type: `$selector`" ) ; } if ( ! method_exists ( $ this -> connection , $ method = "getConnectionBy$selector" ) ) { $ class = get_class ( $ this -> connection ) ; throw new \ InvalidArgumentException ( "Selecting connection by $selector is not supported by $class" ) ; } if ( ! $ connection = $ this -> connection -> $ method ( $ value ) ) { throw new \ InvalidArgumentException ( "Cannot find a connection by $selector matching `$value`" ) ; } $ client = new static ( $ connection , $ this -> getOptions ( ) ) ; if ( $ callable ) { return call_user_func ( $ callable , $ client ) ; } else { return $ client ; } }
6869	protected function buildInvoiceList ( IM \ InvoiceSubjectInterface $ subject ) { $ invoices = $ subject -> getInvoices ( true ) -> toArray ( ) ; usort ( $ invoices , function ( IM \ InvoiceInterface $ a , IM \ InvoiceInterface $ b ) { return $ a -> getCreatedAt ( ) -> getTimestamp ( ) - $ b -> getCreatedAt ( ) -> getTimestamp ( ) ; } ) ; return array_map ( function ( IM \ InvoiceInterface $ invoice ) { return [ 'invoice' => $ invoice , 'total' => $ invoice -> getGrandTotal ( ) , ] ; } , $ invoices ) ; }
9847	public function createSealedResponse ( int $ status , string $ body , SealingPublicKey $ key , array $ headers = [ ] , string $ version = '1.1' ) : ResponseInterface { return new Response ( $ status , new Headers ( $ headers ) , $ this -> stringToStream ( Base64UrlSafe :: encode ( Simple :: seal ( $ body , $ key ) ) ) ) ; }
796	public function getAnnotationEnd ( $ index ) { $ currentIndex = null ; if ( isset ( $ this [ $ index + 2 ] ) ) { if ( $ this [ $ index + 2 ] -> isType ( DocLexer :: T_OPEN_PARENTHESIS ) ) { $ currentIndex = $ index + 2 ; } elseif ( isset ( $ this [ $ index + 3 ] ) && $ this [ $ index + 2 ] -> isType ( DocLexer :: T_NONE ) && $ this [ $ index + 3 ] -> isType ( DocLexer :: T_OPEN_PARENTHESIS ) && Preg :: match ( '/^(\R\s*\*\s*)*\s*$/' , $ this [ $ index + 2 ] -> getContent ( ) ) ) { $ currentIndex = $ index + 3 ; } } if ( null !== $ currentIndex ) { $ level = 0 ; for ( $ max = \ count ( $ this ) ; $ currentIndex < $ max ; ++ $ currentIndex ) { if ( $ this [ $ currentIndex ] -> isType ( DocLexer :: T_OPEN_PARENTHESIS ) ) { ++ $ level ; } elseif ( $ this [ $ currentIndex ] -> isType ( DocLexer :: T_CLOSE_PARENTHESIS ) ) { -- $ level ; } if ( 0 === $ level ) { return $ currentIndex ; } } return null ; } return $ index + 1 ; }
2515	public function pnrRetrieve ( RequestOptions \ PnrRetrieveOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'PNR_Retrieve' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; }
2609	public function getNextVersion ( array $ versions ) { if ( isset ( end ( $ versions ) -> number ) ) { return ( int ) end ( $ versions ) -> number + 1 ; } throw new LocalizedException ( __ ( 'Error fetching next version.' ) ) ; }
12145	public function set ( $ name , $ value = null ) { if ( $ value == null ) { return false ; } $ this -> settings [ $ name ] = $ value ; }
350	public static function getAttributeValue ( $ model , $ attribute ) { if ( ! preg_match ( static :: $ attributeRegex , $ attribute , $ matches ) ) { throw new InvalidArgumentException ( 'Attribute name must contain word characters only.' ) ; } $ attribute = $ matches [ 2 ] ; $ value = $ model -> $ attribute ; if ( $ matches [ 3 ] !== '' ) { foreach ( explode ( '][' , trim ( $ matches [ 3 ] , '[]' ) ) as $ id ) { if ( ( is_array ( $ value ) || $ value instanceof \ ArrayAccess ) && isset ( $ value [ $ id ] ) ) { $ value = $ value [ $ id ] ; } else { return null ; } } } if ( is_array ( $ value ) ) { foreach ( $ value as $ i => $ v ) { if ( $ v instanceof ActiveRecordInterface ) { $ v = $ v -> getPrimaryKey ( false ) ; $ value [ $ i ] = is_array ( $ v ) ? json_encode ( $ v ) : $ v ; } } } elseif ( $ value instanceof ActiveRecordInterface ) { $ value = $ value -> getPrimaryKey ( false ) ; return is_array ( $ value ) ? json_encode ( $ value ) : $ value ; } return $ value ; }
7379	public function fetchFilter ( string $ key , $ default = null , $ filter = FILTER_DEFAULT , $ options = [ ] ) { $ value = $ this -> fetch ( $ key , $ default ) ; if ( ! is_array ( $ options ) && $ options ) { $ options = [ 'flags' => $ options ] ; } if ( is_array ( $ value ) && ! isset ( $ options [ 'flags' ] ) ) { $ options [ 'flags' ] = FILTER_REQUIRE_ARRAY ; } return filter_var ( $ value , $ filter , $ options ) ; }
12527	public function getDataSources ( ) { if ( is_null ( $ this -> _dataSources ) ) { $ this -> _dataSources = [ ] ; foreach ( $ this -> dataSources ( ) as $ foreignModel => $ dataSource ) { if ( is_numeric ( $ foreignModel ) || isset ( $ dataSources [ 'foreignModel' ] ) ) { if ( ! isset ( $ dataSources [ 'foreignModel' ] ) ) { continue ; } $ foreignModel = $ dataSources [ 'foreignModel' ] ; unset ( $ dataSources [ 'foreignModel' ] ) ; } if ( ! isset ( $ dataSource [ 'class' ] ) ) { $ dataSource [ 'class' ] = $ this -> dataSourceClass ; } $ dataSource [ 'name' ] = $ foreignModel ; $ dataSource [ 'foreignModel' ] = $ this -> getForeignModel ( $ foreignModel ) ; if ( empty ( $ dataSource [ 'foreignModel' ] ) ) { continue ; } $ this -> _dataSources [ $ foreignModel ] = Yii :: createObject ( array_merge ( [ 'module' => $ this ] , $ dataSource ) ) ; } } return $ this -> _dataSources ; }
12685	public function removeFromDB ( ) { if ( is_null ( $ this -> result ) ) { $ this -> fetchData ( ) ; } if ( count ( $ this -> result ) > 0 ) { if ( ! $ this -> result [ 0 ] instanceof Web2All_Table_SaveObject ) { throw new Exception ( "Web2All_Table_ObjectList->removeFromDB: Not a saveobject, you can't delete a non saveobject." ) ; } foreach ( $ this -> result as $ row ) { $ row -> deleteFromDB ( ) ; } } }
11213	protected function removeFromLookup ( $ registry ) { foreach ( $ this -> lookup_pool as $ idx => $ reg ) { if ( $ registry === $ reg ) { if ( $ reg instanceof DelegatorAwareInterface ) { $ reg -> setDelegator ( ) ; } unset ( $ this -> lookup_pool [ $ idx ] ) ; } } return $ this ; }
2728	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ name = $ this -> getRequest ( ) -> getParam ( 'name' ) ; $ type = $ this -> getRequest ( ) -> getParam ( 'type' ) ; $ priority = $ this -> getRequest ( ) -> getParam ( 'priority' ) ; $ vcl = $ this -> getRequest ( ) -> getParam ( 'vcl' ) ; $ validation = $ this -> config -> validateCustomSnippet ( $ name , $ type , $ priority ) ; $ error = $ validation [ 'error' ] ; if ( $ error != null ) { throw new LocalizedException ( __ ( $ error ) ) ; } $ snippetName = $ validation [ 'snippet_name' ] ; $ fileName = $ type . '_' . $ priority . '_' . $ snippetName . '.vcl' ; $ write = $ this -> filesystem -> getDirectoryWrite ( DirectoryList :: VAR_DIR ) ; $ snippetPath = $ write -> getRelativePath ( Config :: CUSTOM_SNIPPET_PATH . $ fileName ) ; $ write -> writeFile ( $ snippetPath , $ vcl ) ; return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
7493	public function trimLeft ( $ characters = null ) { $ this -> string = ltrim ( $ this -> string , $ characters ) ; return $ this ; }
5714	protected function filterFieldList ( Form $ form , FieldList $ actions ) { $ list = FieldList :: create ( ) ; foreach ( $ actions as $ a ) { if ( ! $ a instanceof BetterButtonInterface ) { throw new Exception ( "{$buttonObj->class} must implement BetterButtonInterface" ) ; } $ a -> bindGridField ( $ form , $ this -> owner ) ; if ( ! $ a -> shouldDisplay ( ) ) { continue ; } if ( ( $ a instanceof BetterButton_Versioned ) && ! $ this -> owner -> record -> checkVersioned ( ) ) { continue ; } $ list -> push ( $ a ) ; } return $ list ; }
11804	public function isRelation ( $ key ) { if ( ! method_exists ( $ this -> model , $ key ) ) { return false ; } $ relation = $ this -> model -> { $ key } ( ) ; return ( $ relation instanceof Relation ) ; }
3103	public function load ( ) { $ storage = $ this -> getStorage ( ) ; if ( $ storage ) { $ data = $ storage -> get ( $ this -> userId , $ this -> getStorageKey ( ) ) ; if ( $ data ) { $ this -> state = json_decode ( $ data , true ) ; } else { $ this -> state = [ ] ; } $ success = is_array ( $ this -> state ) ; } else { $ success = false ; } return $ success ; }
7632	public function putBlobData ( $ containerName = '' , $ blobName = '' , $ data = '' , $ metadata = array ( ) , $ leaseId = null , $ additionalHeaders = array ( ) ) { Assertion :: notEmpty ( $ containerName , 'Container name is not specified' ) ; self :: assertValidContainerName ( $ containerName ) ; Assertion :: notEmpty ( $ blobName , 'Blob name is not specified.' ) ; self :: assertValidRootContainerBlobName ( $ containerName , $ blobName ) ; $ headers = array ( ) ; if ( ! is_null ( $ leaseId ) ) { $ headers [ 'x-ms-lease-id' ] = $ leaseId ; } $ headers = array_merge ( $ headers , $ this -> generateMetadataHeaders ( $ metadata ) ) ; foreach ( $ additionalHeaders as $ key => $ value ) { $ headers [ $ key ] = $ value ; } $ headers [ Storage :: PREFIX_STORAGE_HEADER . 'blob-type' ] = self :: BLOBTYPE_BLOCK ; $ resourceName = self :: createResourceName ( $ containerName , $ blobName ) ; $ response = $ this -> performRequest ( $ resourceName , array ( ) , 'PUT' , $ headers , false , $ data , self :: RESOURCE_BLOB , self :: PERMISSION_WRITE ) ; if ( ! $ response -> isSuccessful ( ) ) { throw new BlobException ( $ this -> getErrorMessage ( $ response , 'Resource could not be accessed.' ) ) ; } return new BlobInstance ( $ containerName , $ blobName , null , $ response -> getHeader ( 'Etag' ) , $ response -> getHeader ( 'Last-modified' ) , $ this -> getBaseUrl ( ) . '/' . $ containerName . '/' . $ blobName , strlen ( $ data ) , '' , '' , '' , false , $ metadata ) ; }
5988	public function setUpdatedRange ( $ updatedRange ) { if ( $ updatedRange instanceof DateTimeRange ) { $ this -> updatedRange = $ updatedRange ; } elseif ( is_array ( $ updatedRange ) ) { $ this -> updatedRange = new DateTimeRange ( $ updatedRange ) ; } else { $ this -> updatedRange = null ; trigger_error ( 'Argument must be an object of class DateTimeRange. Data loss!' , E_USER_WARNING ) ; } return $ this ; }
3213	static function checkArgOrNull ( $ argName , $ argValue ) { if ( $ argValue === null ) return ; if ( ! ( $ argValue instanceof self ) ) Checker :: throwError ( $ argName , $ argValue , __CLASS__ ) ; }
1824	public function originalRow ( ) { $ row = $ this -> row ( ) ; if ( ! $ this -> isModified ( ) ) { return $ row ; } $ originalRow = array ( ) ; foreach ( $ row as $ k => $ v ) { $ originalRow [ $ k ] = $ this -> arrModified [ $ k ] ?? $ v ; } return $ originalRow ; }
12674	public function getForeignModelConfig ( $ sourceFile , $ modelName ) { $ config = [ 'class' => Model :: className ( ) ] ; if ( isset ( $ this -> foreignModelsConfig [ $ modelName ] ) ) { $ config = array_merge ( $ config , $ this -> foreignModelsConfig [ $ modelName ] ) ; } $ config [ 'modelName' ] = $ modelName ; $ config [ 'sourceFile' ] = $ sourceFile ; $ config [ 'interface' ] = $ this ; return $ config ; }
420	public function run ( ) { $ block = ob_get_clean ( ) ; if ( $ this -> renderInPlace ) { echo $ block ; } $ this -> view -> blocks [ $ this -> getId ( ) ] = $ block ; }
9827	public function setPassword ( $ pValue , $ pAlreadyHashed = false ) { if ( ! $ pAlreadyHashed ) { $ pValue = PasswordHasher :: hashPassword ( $ pValue ) ; } $ this -> password = $ pValue ; return $ this ; }
10885	protected function makeRequest ( $ data ) { $ url = 'https://www.errorstream.com/api/1.0/errors/create?' . http_build_query ( [ 'api_token' => $ this -> api_token , 'project_token' => $ this -> project_token ] ) ; try { $ ch = curl_init ( ) ; curl_setopt ( $ ch , CURLOPT_URL , $ url ) ; curl_setopt ( $ ch , CURLOPT_POST , true ) ; curl_setopt ( $ ch , CURLOPT_POSTFIELDS , json_encode ( $ data ) ) ; curl_setopt ( $ ch , CURLOPT_HTTPHEADER , array ( 'Content-Type:application/json' ) ) ; curl_setopt ( $ ch , CURLOPT_RETURNTRANSFER , true ) ; $ result = curl_exec ( $ ch ) ; curl_close ( $ ch ) ; return $ result ; } catch ( \ Exception $ ex ) { return $ ex -> getMessage ( ) ; } }
2066	public function getPageTypes ( Contao \ DataContainer $ dc ) { $ arrOptions = array ( ) ; foreach ( array_keys ( $ GLOBALS [ 'TL_PTY' ] ) as $ pty ) { if ( $ pty == 'root' && $ dc -> activeRecord && $ dc -> activeRecord -> pid > 0 ) { continue ; } if ( $ pty == $ dc -> value || $ this -> User -> hasAccess ( $ pty , 'alpty' ) ) { $ arrOptions [ ] = $ pty ; } } return $ arrOptions ; }
259	protected function findViewFile ( $ view , $ context = null ) { if ( strncmp ( $ view , '@' , 1 ) === 0 ) { $ file = Yii :: getAlias ( $ view ) ; } elseif ( strncmp ( $ view , '//' , 2 ) === 0 ) { $ file = Yii :: $ app -> getViewPath ( ) . DIRECTORY_SEPARATOR . ltrim ( $ view , '/' ) ; } elseif ( strncmp ( $ view , '/' , 1 ) === 0 ) { if ( Yii :: $ app -> controller !== null ) { $ file = Yii :: $ app -> controller -> module -> getViewPath ( ) . DIRECTORY_SEPARATOR . ltrim ( $ view , '/' ) ; } else { throw new InvalidCallException ( "Unable to locate view file for view '$view': no active controller." ) ; } } elseif ( $ context instanceof ViewContextInterface ) { $ file = $ context -> getViewPath ( ) . DIRECTORY_SEPARATOR . $ view ; } elseif ( ( $ currentViewFile = $ this -> getRequestedViewFile ( ) ) !== false ) { $ file = dirname ( $ currentViewFile ) . DIRECTORY_SEPARATOR . $ view ; } else { throw new InvalidCallException ( "Unable to resolve view file for view '$view': no active view context." ) ; } if ( pathinfo ( $ file , PATHINFO_EXTENSION ) !== '' ) { return $ file ; } $ path = $ file . '.' . $ this -> defaultExtension ; if ( $ this -> defaultExtension !== 'php' && ! is_file ( $ path ) ) { $ path = $ file . '.php' ; } return $ path ; }
12605	public static function getName ( $ file ) { $ file = str_replace ( '\\' , '/' , $ file ) ; $ slash = strrpos ( $ file , '/' ) ; if ( $ slash !== false ) { return substr ( $ file , $ slash + 1 ) ; } return $ file ; }
10711	public function getManyByIds ( array $ ids , $ columns = [ '*' ] ) { $ results = $ this -> getQuery ( ) -> findMany ( $ ids , $ columns ) ; return $ this -> returnResults ( $ results ) ; }
11331	public function setModel ( $ value ) { $ this -> _model = $ value ; if ( is_object ( $ value ) && $ this -> _attributes ) { $ this -> _model -> attributes = $ this -> _attributes ; } return true ; }
10861	protected function createObjectUsingFactory ( string $ typeName , Factory $ factory , ? bool $ nullable = false ) : ? object { $ this -> underConstruction [ $ typeName ] = true ; try { $ object = ( $ factory -> callback ) ( ... $ this -> populateArguments ( $ factory -> getReflection ( ) , null , $ typeName ) ) ; if ( ! $ object instanceof $ typeName ) { if ( $ object === null && $ nullable ) { return null ; } $ type = \ is_object ( $ object ) ? \ get_class ( $ object ) : \ gettype ( $ object ) ; throw new ContainerException ( \ sprintf ( 'Factory must return an instance of %s, returned value is %s' , $ typeName , $ type ) ) ; } } finally { unset ( $ this -> underConstruction [ $ typeName ] ) ; } return $ object ; }
4829	public function cancel ( ) { $ endpoint = self :: $ endpoint . '/' . $ this -> id . '/cancel' ; return new self ( $ this -> client , $ this -> client -> request ( 'put' , $ endpoint ) ) ; }
4010	public function getMaxPaginationLinks ( ) { if ( null === $ this -> maxPaginationLinks ) { $ this -> setMaxPaginationLinks ( \ Config :: get ( 'maxPaginationLinks' ) ) ; } return $ this -> maxPaginationLinks ; }
1457	protected function next ( Cursor $ cursor , $ columns ) { if ( $ cursor -> isAfter ( ) ) { $ this -> whereId ( $ cursor -> getAfter ( ) , $ this -> descending ? '<' : '>' ) ; } $ items = $ this -> orderForNext ( ) -> get ( $ cursor -> getLimit ( ) + 1 , $ columns ) ; $ more = $ items -> count ( ) > $ cursor -> getLimit ( ) ; return new CursorPaginator ( $ items -> slice ( 0 , $ cursor -> getLimit ( ) ) , $ more , $ cursor , $ this -> key ) ; }
12841	static public function recursiveDelete ( $ path ) { if ( is_file ( $ path ) ) { return unlink ( $ path ) ; } $ scans = glob ( rtrim ( $ path , '/' ) . '/*' ) ; foreach ( $ scans as $ scan ) { self :: recursiveDelete ( $ scan ) ; } return rmdir ( $ path ) ; }
853	public function getNonEmptySibling ( $ index , $ direction ) { while ( true ) { $ index += $ direction ; if ( ! $ this -> offsetExists ( $ index ) ) { return null ; } if ( ! $ this -> isEmptyAt ( $ index ) ) { return $ index ; } } }
4754	public function startProfiling ( ) { if ( PHP_SAPI == 'cli' ) { $ _SERVER [ 'REMOTE_ADDR' ] = null ; $ _SERVER [ 'REQUEST_URI' ] = $ _SERVER [ 'SCRIPT_NAME' ] ; } if ( function_exists ( 'xhprof_enable' ) && count ( $ this -> probes ) > 0 ) { $ this -> profiling = true ; xhprof_enable ( $ this -> memory ? XHPROF_FLAGS_MEMORY : null ) ; } }
6282	public static function buildHttpClient ( LoopInterface $ loop , $ connector = null ) { if ( class_exists ( HttpClientFactory :: class ) ) { return static :: buildHttpClient04 ( $ loop , $ connector ) ; } else { return static :: buildHttpClient05 ( $ loop , $ connector ) ; } }
1843	protected function getControllerName ( Reference $ reference , array $ attributes ) : string { $ controller = ( string ) $ reference ; if ( isset ( $ attributes [ 'method' ] ) ) { $ controller .= ':' . $ attributes [ 'method' ] ; } return $ controller ; }
8759	public function postUpload ( Request $ request ) { $ input = $ request -> all ( ) ; $ response = $ this -> uploadRepository -> upload ( $ input ) ; return $ response ; }
5966	public function permReset ( ) { $ token = $ this -> request ( "permreset" ) -> toList ( ) ; Signal :: getInstance ( ) -> emit ( "notifyTokencreated" , $ this , $ token [ "token" ] ) ; return $ token [ "token" ] ; }
3839	private function ensureSubmitElement ( $ panelRows ) { $ hasSubmit = false ; foreach ( $ panelRows as $ panelRow ) { foreach ( $ panelRow as $ element ) { if ( $ element instanceof SubmitElementInformationInterface ) { $ hasSubmit = true ; break ; } if ( $ hasSubmit ) { break ; } } } if ( ! $ hasSubmit && $ panelRows -> getRowCount ( ) ) { $ row = $ panelRows -> getRow ( $ panelRows -> getRowCount ( ) - 1 ) ; $ row -> addElement ( new DefaultSubmitElementInformation ( ) , 0 ) ; } }
5982	protected function getClient ( ) { if ( ! ( $ this -> client instanceof Client ) ) { $ handlerStack = HandlerStack :: create ( ) ; $ handlerStack = $ this -> withOAuth2MiddleWare ( $ handlerStack ) ; $ this -> client = new Client ( [ 'handler' => $ handlerStack , 'auth' => 'oauth2' , 'base_uri' => $ this -> basepath , 'headers' => [ 'Accept' => 'application/json' , 'Content-type' => 'application/json' , 'User-Agent' => 'qbank3api-phpwrapper/2 (qbankapi: 1; swagger: 1.1)' , ] , 'verify' => $ this -> verifyCertificates , ] ) ; $ this -> logger -> debug ( 'Guzzle client instantiated.' , [ 'basepath' => $ this -> basepath ] ) ; } return $ this -> client ; }
1038	private function executeFields ( ObjectType $ parentType , $ source , $ path , $ fields ) { $ containsPromise = false ; $ finalResults = [ ] ; foreach ( $ fields as $ responseName => $ fieldNodes ) { $ fieldPath = $ path ; $ fieldPath [ ] = $ responseName ; $ result = $ this -> resolveField ( $ parentType , $ source , $ fieldNodes , $ fieldPath ) ; if ( $ result === self :: $ UNDEFINED ) { continue ; } if ( ! $ containsPromise && $ this -> getPromise ( $ result ) ) { $ containsPromise = true ; } $ finalResults [ $ responseName ] = $ result ; } if ( ! $ containsPromise ) { return self :: fixResultsIfEmptyArray ( $ finalResults ) ; } return $ this -> promiseForAssocArray ( $ finalResults ) ; }
7713	function FindEndTag ( $ Encaps = false ) { if ( is_null ( $ this -> SelfClosing ) ) { $ pe = $ this -> PosEnd ; $ SelfClosing = ( substr ( $ this -> Txt , $ pe - 1 , 1 ) == '/' ) ; if ( ! $ SelfClosing ) { if ( $ Encaps ) { $ loc = clsTinyButStrong :: f_Xml_FindTag ( $ this -> Txt , $ this -> FindName ( ) , null , $ pe , true , - 1 , false , false ) ; if ( $ loc === false ) return false ; $ this -> pET_PosBeg = $ loc -> PosBeg ; $ this -> PosEnd = $ loc -> PosEnd ; } else { $ pe = clsTinyButStrong :: f_Xml_FindTagStart ( $ this -> Txt , $ this -> FindName ( ) , false , $ pe , true , true ) ; if ( $ pe === false ) return false ; $ this -> pET_PosBeg = $ pe ; $ pe = strpos ( $ this -> Txt , '>' , $ pe ) ; if ( $ pe === false ) return false ; $ this -> PosEnd = $ pe ; } } $ this -> SelfClosing = $ SelfClosing ; } return true ; }
12047	public function range ( ) { $ arg_num = func_num_args ( ) ; if ( $ arg_num % 2 != 0 ) { throw new \ InvalidArgumentException ( "Number of args must be even" , 1 ) ; } $ value = "[" ; $ arg_list = func_get_args ( ) ; for ( $ i = 0 ; $ i < $ arg_num ; ) { $ value .= self :: sanitize ( $ arg_list [ $ i ++ ] ) . "-" . self :: sanitize ( $ arg_list [ $ i ++ ] ) ; } $ value .= "]" ; return $ this -> add ( $ value ) ; }
10378	protected static function get_routes_to_folder ( $ type ) { $ url = isset ( self :: $ unify [ "{$type}s" ] ) ? self :: $ unify [ "{$type}s" ] : self :: $ unify ; return [ 'url' => $ url , 'path' => self :: get_path_from_url ( $ url ) , ] ; }
2712	public function _getElementHtml ( AbstractElement $ element ) { $ this -> setNamePrefix ( $ element -> getName ( ) ) -> setHtmlId ( $ element -> getHtmlId ( ) ) ; return $ this -> _toHtml ( ) ; }
12267	public function renderCmsBlock ( BaseBlock $ block , $ username , array $ options = array ( ) ) { $ blockTemplate = $ this -> fetchTemplateBlock ( $ block ) ; if ( $ blockTemplate == "" ) { return "" ; } $ permalinks = $ this -> pagesParser -> contributor ( $ username ) -> parse ( ) -> permalinksByLanguage ( ) ; $ options = array_merge ( array ( 'block' => $ block , 'permalinks' => $ permalinks , ) , $ options ) ; return $ this -> templating -> render ( $ blockTemplate , $ options ) ; }
1562	protected function deserializeAttribute ( $ value , $ field , $ record ) { if ( $ this -> isDateAttribute ( $ field , $ record ) ) { return $ this -> deserializeDate ( $ value , $ field , $ record ) ; } $ method = 'deserialize' . Str :: classify ( $ field ) . 'Field' ; if ( method_exists ( $ this , $ method ) ) { return $ this -> { $ method } ( $ value , $ record ) ; } return $ value ; }
2096	public function getWeekBegin ( $ intStartDay = 0 ) { $ intOffset = date ( 'w' , $ this -> strDate ) - $ intStartDay ; if ( $ intOffset < 0 ) { $ intOffset += 7 ; } return strtotime ( '-' . $ intOffset . ' days' , $ this -> strDate ) ; }
6336	public function overlay ( $ title , $ message , $ level = 'info' , $ key = 'flash_message' ) { return $ this -> create ( $ title , $ message , $ level , $ key . '_overlay' ) ; }
3302	public function json ( $ url , $ options = [ ] , $ encodeOption = JSON_UNESCAPED_UNICODE , $ queries = [ ] ) { is_array ( $ options ) && $ options = json_encode ( $ options , $ encodeOption ) ; return $ this -> setHeaders ( [ 'content-type' => 'application/json' ] ) -> request ( 'POST' , $ url , [ 'query' => $ queries , 'body' => $ options ] ) ; }
4222	public function get ( $ key = null ) { if ( $ key == 'lastError' ) { return isset ( $ this -> data [ 'lastError' ] ) ? $ this -> data [ 'lastError' ] -> getValues ( ) : null ; } if ( isset ( $ this -> data [ $ key ] ) ) { return $ this -> data [ $ key ] ; } if ( isset ( $ this -> { $ key } ) ) { return $ this -> { $ key } ; } return null ; }
1359	public static function jsonApi ( int $ options = 0 , string $ urlPrefix = null , int $ depth = 512 ) : self { return self :: create ( MediaTypeInterface :: JSON_API_MEDIA_TYPE , $ options , $ urlPrefix , $ depth ) ; }
3643	public function except ( $ keys , bool $ trim = true , bool $ clean = true ) { $ values = $ this -> request -> except ( ( array ) $ keys ) ; return $ this -> clean ( $ values , $ trim , $ clean ) ; }
3058	public function containsAdaptive ( ) { $ adaptiveSectionMap = $ this -> getServiceManager ( ) -> get ( CatService :: SERVICE_ID ) -> getAdaptiveSectionMap ( $ this -> getCompilationDirectory ( ) [ 'private' ] ) ; return ! empty ( $ adaptiveSectionMap ) ; }
1485	public function prepend ( Decoding ... $ decodings ) : self { $ copy = clone $ this ; array_unshift ( $ copy -> stack , ... $ decodings ) ; return $ copy ; }
384	protected function validateImage ( $ image ) { if ( false === ( $ imageInfo = getimagesize ( $ image -> tempName ) ) ) { return [ $ this -> notImage , [ 'file' => $ image -> name ] ] ; } list ( $ width , $ height ) = $ imageInfo ; if ( $ width == 0 || $ height == 0 ) { return [ $ this -> notImage , [ 'file' => $ image -> name ] ] ; } if ( $ this -> minWidth !== null && $ width < $ this -> minWidth ) { return [ $ this -> underWidth , [ 'file' => $ image -> name , 'limit' => $ this -> minWidth ] ] ; } if ( $ this -> minHeight !== null && $ height < $ this -> minHeight ) { return [ $ this -> underHeight , [ 'file' => $ image -> name , 'limit' => $ this -> minHeight ] ] ; } if ( $ this -> maxWidth !== null && $ width > $ this -> maxWidth ) { return [ $ this -> overWidth , [ 'file' => $ image -> name , 'limit' => $ this -> maxWidth ] ] ; } if ( $ this -> maxHeight !== null && $ height > $ this -> maxHeight ) { return [ $ this -> overHeight , [ 'file' => $ image -> name , 'limit' => $ this -> maxHeight ] ] ; } return null ; }
1509	public function getResourceUrl ( string $ type , $ id , array $ params = [ ] ) : string { return $ this -> url ( [ $ type , $ id ] , $ params ) ; }
3049	protected function initCompilationDirectory ( ) { $ fileStorage = \ tao_models_classes_service_FileStorage :: singleton ( ) ; $ directoryIds = explode ( '|' , $ this -> getTestCompilationUri ( ) ) ; $ directories = array ( 'private' => $ fileStorage -> getDirectoryById ( $ directoryIds [ 0 ] ) , 'public' => $ fileStorage -> getDirectoryById ( $ directoryIds [ 1 ] ) ) ; $ this -> compilationDirectory = $ directories ; }
5004	protected function createEventManager ( $ services , $ config ) { if ( $ services -> has ( $ config [ 'service' ] ) ) { $ events = $ services -> get ( $ config [ 'service' ] ) ; } else { if ( ! class_exists ( $ config [ 'service' ] , true ) ) { throw new \ UnexpectedValueException ( sprintf ( 'Class or service %s does not exists. Cannot create event manager instance.' , $ config [ 'service' ] ) ) ; } $ events = new $ config [ 'service' ] ( ) ; } if ( false === $ config [ 'configure' ] ) { return $ events ; } $ events -> setIdentifiers ( $ config [ 'identifiers' ] ) ; $ event = $ services -> has ( $ config [ 'event' ] ) ? $ services -> get ( $ config [ 'event' ] ) : new $ config [ 'event' ] ( ) ; $ events -> setEventPrototype ( $ event ) ; if ( 'EventManager' != $ config [ 'service' ] && method_exists ( $ events , 'setSharedManager' ) && $ services -> has ( 'SharedEventManager' ) ) { $ sharedEvents = $ services -> get ( 'SharedEventManager' ) ; $ events -> setSharedManager ( $ sharedEvents ) ; } return $ events ; }
8733	public function update ( array $ values ) { $ updated = 0 ; $ modelKey = $ this -> getModel ( ) -> getKey ( ) ; $ modelKeyName = $ this -> model -> getKeyName ( ) ; $ values = $ this -> addUpdatedAtColumn ( $ values ) ; list ( $ values , $ i18nValues ) = $ this -> filterValues ( $ values ) ; $ ids = $ modelKey ? [ $ modelKey ] : $ this -> pluck ( $ modelKeyName ) -> all ( ) ; if ( $ values ) { $ updated += $ this -> updateBase ( $ values , $ ids ) ; } if ( $ i18nValues ) { $ updated += $ this -> updateI18n ( $ i18nValues , $ ids ) ; } return $ updated ; }
10931	function countRowsWith ( string $ tablename , string $ colName , $ colValue ) : int { $ strSQL = "SELECT COUNT($colName) as count FROM $tablename WHERE $colName=:$colName;" ; return $ this -> getCountOf ( $ strSQL , [ "$colName" => $ colValue ] ) ; }
2930	public function getValue ( $ key ) { $ allKeys = $ this -> getKeys ( [ $ key ] ) ; if ( array_key_exists ( $ key , $ allKeys ) ) { return $ allKeys [ $ key ] [ 'value' ] ; } throw new KeyNotFoundException ( 'Requested key not found in your file.' ) ; }
4735	public function regenerate_id ( $ delete_old = false ) { if ( $ delete_old ) { delete_option ( "_wp_session_{$this->session_id}" ) ; } $ this -> session_id = $ this -> generate_id ( ) ; $ this -> set_cookie ( ) ; }
3907	public function handle ( BuildDataDefinitionEvent $ event ) { $ container = $ event -> getContainer ( ) ; if ( $ container instanceof IMetaModelDataDefinition ) { $ this -> build ( $ container ) ; } }
11151	public function getApi ( ) { if ( $ this -> api === null ) { $ this -> api = new ExtDirectApi ( $ this -> useCache ( ) , $ this -> getApplicationPath ( ) , $ this -> getApplicationNameSpace ( ) ) ; } return $ this -> api ; }
7749	public function getAllMetadata ( ) { $ metadata = array ( ) ; foreach ( $ this -> driver -> getAllClassNames ( ) as $ className ) { $ metadata [ ] = $ this -> getMetadataFor ( $ className ) ; } $ this -> validate ( $ metadata ) ; return $ metadata ; }
960	public function handle ( Request $ request , Closure $ next ) { if ( Config :: get ( 'shopify-app.billing_enabled' ) === true ) { $ shop = ShopifyApp :: shop ( ) ; if ( ! $ shop -> isFreemium ( ) && ! $ shop -> isGrandfathered ( ) && ! $ shop -> plan ) { return Redirect :: route ( 'billing' ) ; } } return $ next ( $ request ) ; }
1870	private function isCorsRequest ( Request $ request ) : bool { return $ request -> headers -> has ( 'Origin' ) && $ request -> headers -> get ( 'Origin' ) !== $ request -> getSchemeAndHttpHost ( ) ; }
12973	public function setMappings ( $ mappingName , array $ mappingConfig = null ) { if ( is_array ( $ mappingName ) === false ) { $ mappingName = array ( $ mappingName => $ mappingConfig ) ; } \ Arr :: set ( $ this -> config [ 'mappings' ] , $ mappingName ) ; return $ this ; }
6863	protected function registerManager ( ) { $ this -> app -> singleton ( 'notifyme' , function ( $ app ) { $ config = $ app [ 'config' ] ; $ factory = $ app [ 'notifyme.factory' ] ; return new NotifyMeManager ( $ config , $ factory ) ; } ) ; $ this -> app -> alias ( 'notifyme' , NotifyMeManager :: class ) ; $ this -> app -> alias ( 'notifyme' , ManagerInterface :: class ) ; }
7337	public function createClient ( ) : TgLog { $ this -> loop = Factory :: create ( ) ; $ handler = new HttpClientRequestHandler ( $ this -> loop ) ; return new TgLog ( $ this -> token , $ handler ) ; }
11294	public function getDataAttributes ( $ excludeExtended = false ) { $ attributes = new \ Cora \ Collection ( ) ; foreach ( $ this -> model_attributes as $ key => $ def ) { if ( ! isset ( $ def [ 'model' ] ) && ! isset ( $ def [ 'models' ] ) ) { $ attributes -> add ( $ key ) ; } } if ( isset ( $ this -> model_extends ) && isset ( $ this -> model_attributes [ $ this -> model_extends ] ) ) { $ extendedModel = $ this -> { $ this -> model_extends } ; if ( $ extendedModel ) { $ attributes -> merge ( $ extendedModel -> getDataAttributes ( ) ) ; } } return array_unique ( $ attributes -> toArray ( ) ) ; }
2397	public function parseBbCode ( $ strComment ) { $ arrSearch = array ( '@\[b\](.*)\[/b\]@Uis' , '@\[i\](.*)\[/i\]@Uis' , '@\[u\](.*)\[/u\]@Uis' , '@\s*\[code\](.*)\[/code\]\s*@Uis' , '@\[color=([^\]" ]+)\](.*)\[/color\]@Uis' , '@\s*\[quote\](.*)\[/quote\]\s*@Uis' , '@\s*\[quote=([^\]]+)\](.*)\[/quote\]\s*@Uis' , '@\[img\]\s*([^\[" ]+\.(jpe?g|png|gif|bmp|tiff?|ico))\s*\[/img\]@i' , '@\[url\]\s*([^\[" ]+)\s*\[/url\]@i' , '@\[url=([^\]" ]+)\](.*)\[/url\]@Uis' , '@\[email\]\s*([^\[" ]+)\s*\[/email\]@i' , '@\[email=([^\]" ]+)\](.*)\[/email\]@Uis' , '@href="(([a-z0-9]+\.)*[a-z0-9]+\.([a-z]{2}|asia|biz|com|info|name|net|org|tel)(/|"))@i' ) ; $ arrReplace = array ( '<strong>$1</strong>' , '<em>$1</em>' , '<span style="text-decoration:underline">$1</span>' , "\n\n" . '<div class="code"><p>' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'com_code' ] . '</p><pre>$1</pre></div>' . "\n\n" , '<span style="color:$1">$2</span>' , "\n\n" . '<blockquote>$1</blockquote>' . "\n\n" , "\n\n" . '<blockquote><p>' . sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'com_quote' ] , '$1' ) . '</p>$2</blockquote>' . "\n\n" , '<img src="$1" alt="" />' , '<a href="$1">$1</a>' , '<a href="$1">$2</a>' , '<a href="mailto:$1">$1</a>' , '<a href="mailto:$1">$2</a>' , 'href="http://$1' ) ; $ strComment = preg_replace ( $ arrSearch , $ arrReplace , $ strComment ) ; if ( strpos ( $ strComment , 'mailto:' ) !== false ) { $ strComment = StringUtil :: encodeEmail ( $ strComment ) ; } return $ strComment ; }
4037	private function getTemplatesForBaseFrom ( $ base , $ folder , $ themeName ) { if ( ! is_dir ( $ folder ) ) { return [ ] ; } $ themeName = trim ( $ themeName ) ; $ foundTemplates = Finder :: create ( ) -> in ( $ folder ) -> name ( $ base . '*' ) ; $ templates = [ ] ; foreach ( $ foundTemplates as $ template ) { $ templates [ $ template -> getBasename ( '.' . $ template -> getExtension ( ) ) ] = [ $ themeName => $ themeName ] ; } return $ templates ; }
10160	private function readMsoDrawing ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ splicedRecordData = $ this -> getSplicedRecordData ( ) ; $ recordData = $ splicedRecordData [ 'recordData' ] ; $ this -> drawingData .= $ recordData ; }
12594	protected function makeDir ( $ dirName , LoggerInterface $ logger ) { $ dn = explode ( getcwd ( ) , $ dirName ) [ 1 ] ?? $ dirName ; if ( @ mkdir ( $ dirName ) ) { $ logger -> logText ( "Created directory <fg=green>%s</>" , LoggerInterface :: VERBOSITY_NORMAL , NULL , $ dn ) ; } else { $ logger -> logWarning ( "Creating directory $dn failed" ) ; } }
3669	public function getCurrentFilterUrl ( $ options = null ) : FilterUrl { $ this -> addFromCurrentRequest ( $ filterUrl = new FilterUrl ( ) , $ options ) ; return $ filterUrl ; }
9093	public function getPagePartial ( $ page ) { if ( isset ( $ this -> pagePartials [ $ page ] ) ) { return $ this -> pagePartials [ $ page ] ; } return null ; }
12362	public function database ( $ db ) { $ connection = $ this -> connection ; $ connection -> db = $ db ; $ this -> constructConnections = $ connection ; $ connection = class_exists ( "Clusterpoint\Connection" ) ? new Connection ( $ this -> constructConnections ) : new StandartConnection ( $ this -> constructConnections ) ; return new Service ( $ connection ) ; }
11599	public function run ( ) : void { if ( ! $ this -> isAppRootSet ( ) ) { throw new Exception ( "The application root wasn't defined." ) ; } if ( ! $ this -> isConfigFileSet ( ) ) { throw new Exception ( "The main config file wasn't defined." ) ; } $ configPath = $ this -> getAppRoot ( ) . $ this -> getConfigFile ( ) ; if ( ! is_readable ( $ configPath ) ) { throw new Exception ( "It's unable to load " . $ configPath . 'as main config file.' ) ; } $ config = require_once $ configPath ; if ( ! is_array ( $ config ) ) { throw new Exception ( 'The main config must be an array.' ) ; } $ this -> configSet = $ config ; }
9460	public function deleteTickets ( array $ tickets ) { $ ids = array ( ) ; foreach ( $ tickets as $ ticket ) { $ ids [ ] = $ ticket -> getId ( ) ; } return parent :: deleteByIds ( $ ids , 'tickets/destroy_many.json' ) ; }
7105	public function onParse ( $ finalText ) { $ func = $ this -> getParam ( 'postParseFunction' ) ; if ( isset ( $ func ) ) $ finalText = $ func ( $ finalText ) ; if ( $ this -> getParam ( 'addFootnotes' ) ) { $ footnotes = $ this -> getFootnotes ( ) ; if ( ! empty ( $ footnotes ) ) $ finalText .= "\n" . $ footnotes ; } $ finalText .= str_repeat ( '</section>' , count ( $ this -> _sectionLevel ) ) ; return ( $ finalText ) ; }
7778	protected function extractInput ( array $ data ) { $ input = [ ] ; foreach ( $ data as $ field => $ fieldData ) { $ input [ $ field ] = $ fieldData [ 0 ] ; } return $ input ; }
1151	protected function getViewData ( ) { $ this -> validator -> setRemote ( $ this -> remote ) ; $ data = $ this -> validator -> validationData ( ) ; $ data [ 'selector' ] = $ this -> selector ; if ( ! is_null ( $ this -> ignore ) ) { $ data [ 'ignore' ] = $ this -> ignore ; } return $ data ; }
10050	public function resolve ( ) { if ( is_null ( $ this -> config -> getDisplayField ( ) ) || $ this -> config -> getDisplayField ( ) == '' ) { $ this -> config -> setDisplayField ( $ this -> resolveDisplayField ( ) ) ; $ this -> config -> setVisibleFields ( $ this -> resolveVisibleFields ( ) ) ; } return $ this -> config ; }
6770	protected function handleStateChange ( SaleInterface $ sale ) { if ( $ this -> configureAcceptedSale ( $ sale ) ) { $ this -> persistenceHelper -> persistAndRecompute ( $ sale , false ) ; } }
10736	public function compare ( $ x ) : int { if ( ! is_numeric ( $ x ) ) { throw new InvalidArgumentException ( __METHOD__ . "() expects parameter one, x, to be a number" ) ; } if ( $ x < $ this -> lower || ( ! $ this -> isLowerInclusive && $ x == $ this -> lower ) ) { return - 1 ; } elseif ( $ x > $ this -> upper || ( ! $ this -> isUpperInclusive && $ x == $ this -> upper ) ) { return 1 ; } else { return 0 ; } }
5462	public function stretch ( $ url ) { $ this -> root = $ this -> getCommonPath ( $ this -> root , $ url -> getPath ( ) ) ; }
6752	public static function getCallable ( Logger $ logger , $ type , $ maxMessageLength ) { return function ( MessageInterface $ message ) use ( $ logger , $ type , $ maxMessageLength ) { $ startMessage = null ; if ( $ message instanceof RequestInterface ) { $ startMessage = sprintf ( 'Proxy %s start: HTTP/%s %s %s' , $ type , $ message -> getProtocolVersion ( ) , $ message -> getMethod ( ) , $ message -> getRequestTarget ( ) ) ; } elseif ( $ message instanceof ResponseInterface ) { $ startMessage = sprintf ( 'Proxy %s start: HTTP/%s %s %s' , $ type , $ message -> getProtocolVersion ( ) , $ message -> getStatusCode ( ) , $ message -> getReasonPhrase ( ) ) ; } if ( ! is_null ( $ startMessage ) ) { $ logger -> log ( Logger :: INFO , $ startMessage ) ; } foreach ( $ message -> getHeaders ( ) as $ name => $ value ) { $ logger -> log ( Logger :: INFO , sprintf ( "Proxy %s header: %s => %s" , $ type , $ name , implode ( ', ' , $ value ) ) ) ; } $ body = $ message -> getBody ( ) ; if ( strlen ( $ body ) > $ maxMessageLength ) { $ body = substr ( $ body , 0 , $ maxMessageLength ) . '[TRUNCATED]' ; } $ logger -> log ( Logger :: INFO , sprintf ( "Proxy %s body: %s" , $ type , $ body ) ) ; if ( ! is_null ( $ message ) && $ message -> getBody ( ) -> isSeekable ( ) ) { $ message -> getBody ( ) -> rewind ( ) ; } return $ message ; } ; }
8177	public static function sendWelcomeMessage ( User $ user ) { return Mailer :: sendMail ( $ user -> email , 'Welcome to ' . Yii :: $ app -> name , 'welcome' , [ 'user' => $ user ] ) ; }
10795	public function contact ( array $ data , $ destination = null ) { $ authService = $ this -> getServiceLocator ( ) -> get ( 'ControllerPluginManager' ) -> get ( 'zfcUserAuthentication' ) ; if ( null === $ destination && ! $ authService -> hasIdentity ( ) ) { throw new \ Exception ( "Errore si sistema." ) ; } $ identity = $ authService -> getIdentity ( ) ; $ data [ 'email' ] = null !== $ destination ? $ destination : $ identity -> getEmail ( ) ; $ form = $ this -> getServiceLocator ( ) -> get ( 'user.form.contact' ) ; $ form -> setData ( $ data ) ; if ( ! $ form -> isValid ( ) ) { throw new \ Exception ( serialize ( $ form -> getMessages ( ) ) ) ; } $ url = $ this -> getServiceLocator ( ) -> get ( 'ControllerPluginManager' ) -> get ( 'Url' ) ; $ data = array_merge ( $ form -> getData ( ) , array ( 'siteurl' => $ url -> fromRoute ( 'home' , array ( ) , array ( 'force_canonical' => true ) ) ) ) ; $ event = new UserContactEvent ( __FUNCTION__ , null , $ data ) ; $ this -> getEventManager ( ) -> trigger ( __FUNCTION__ . '.pre' , $ this , $ event ) ; $ this -> getEventManager ( ) -> trigger ( __FUNCTION__ . '.post' , $ this , $ event ) ; }
4166	public function run ( $ command ) { $ process = new Process ( $ command , null , null , null , ini_get ( 'max_execution_time' ) ) ; $ process -> run ( function ( $ type , $ buffer ) { if ( Process :: ERR === $ type ) { $ this -> console -> warn ( trim ( $ buffer ) ) ; } else { $ this -> console -> info ( trim ( $ buffer ) ) ; } } ) ; if ( ! $ process -> isSuccessful ( ) ) { throw new ProcessFailedException ( $ process ) ; } return true ; }
724	public function getUniqueId ( ) { return $ this -> module instanceof Application ? $ this -> id : $ this -> module -> getUniqueId ( ) . '/' . $ this -> id ; }
7328	private function configureVatNumberSubjectMapping ( LoadClassMetadataEventArgs $ eventArgs ) { $ metadata = $ eventArgs -> getClassMetadata ( ) ; $ class = $ metadata -> getName ( ) ; if ( ! is_subclass_of ( $ class , Pricing \ Model \ VatNumberSubjectInterface :: class ) ) { return ; } if ( in_array ( $ class , $ this -> vatNumberSubjectClassCache ) ) { return ; } $ this -> addMappings ( $ metadata , $ this -> getVatNumberSubjectMappings ( ) ) ; $ this -> vatNumberSubjectClassCache [ ] = $ class ; }
7300	public static function load_class ( $ class_name = NULL ) { if ( NULL === $ class_name ) { foreach ( glob ( dirname ( __FILE__ ) . '/*.php' ) as $ path ) { require_once $ path ; } } else { if ( 0 !== strpos ( $ class_name , 'Iac_' ) ) return FALSE ; $ path = dirname ( __FILE__ ) . '/class-' . $ class_name . '.php' ; if ( file_exists ( $ path ) ) { require_once $ path ; return TRUE ; } } return FALSE ; }
565	public function getScriptFile ( ) { if ( $ this -> _scriptFile === null ) { if ( isset ( $ _SERVER [ 'SCRIPT_FILENAME' ] ) ) { $ this -> setScriptFile ( $ _SERVER [ 'SCRIPT_FILENAME' ] ) ; } else { throw new InvalidConfigException ( 'Unable to determine the entry script file path.' ) ; } } return $ this -> _scriptFile ; }
2419	protected function addTemplatesToArchive ( ZipWriter $ objArchive , $ strFolder ) { $ strFolder = preg_replace ( '@^templates/@' , '' , $ strFolder ) ; if ( $ strFolder == '' ) { $ strFolder = 'templates' ; } else { $ strFolder = 'templates/' . $ strFolder ; } if ( Validator :: isInsecurePath ( $ strFolder ) ) { throw new \ RuntimeException ( 'Insecure path ' . $ strFolder ) ; } if ( ! is_dir ( $ this -> strRootDir . '/' . $ strFolder ) ) { return ; } foreach ( scan ( $ this -> strRootDir . '/' . $ strFolder ) as $ strFile ) { if ( preg_match ( '/\.(html5|sql)$/' , $ strFile ) && strncmp ( $ strFile , 'be_' , 3 ) !== 0 && strncmp ( $ strFile , 'nl_' , 3 ) !== 0 ) { $ objArchive -> addFile ( $ strFolder . '/' . $ strFile ) ; } } }
12595	protected function getMinifier ( SplFileInfo $ file , string $ source ) : Minifier { $ minifier = '\Gears\Asset\Minifiers\\' ; $ minifier .= ucfirst ( $ this -> destination -> getExtension ( ) ) ; if ( ! class_exists ( $ minifier ) ) { throw new RuntimeException ( 'Minification is not supported for type: ' . $ this -> destination -> getExtension ( ) ) ; } return new $ minifier ( $ file , $ source ) ; }
4902	private static function getDockerEnv ( $ configuration ) { $ cacheDir = $ configuration [ 'module_listener_options' ] [ 'cache_dir' ] . '/docker' ; $ configDir = static :: getConfigDir ( ) ; $ hydratorDir = $ cacheDir . '/Doctrine/Hydrator' ; $ proxyDir = $ cacheDir . '/Doctrine/Proxy' ; if ( ! is_dir ( $ hydratorDir ) ) { mkdir ( $ hydratorDir , 0777 , true ) ; } if ( ! is_dir ( $ proxyDir ) ) { mkdir ( $ proxyDir , 0777 , true ) ; } return [ 'module_listener_options' => [ 'cache_dir' => $ cacheDir , 'config_glob_paths' => [ $ configDir . '/autoload/*.docker.php' , ] ] , 'doctrine' => [ 'configuration' => [ 'odm_default' => [ 'hydrator_dir' => $ hydratorDir , 'proxy_dir' => $ proxyDir , ] ] ] ] ; }
7857	public function register ( ) { $ this -> registerPipelineRepository ( ) ; $ this -> registerInflector ( ) ; $ this -> registerDispatcher ( ) ; $ this -> registerWorkflow ( ) ; $ this -> registerWorkflowRunnersHook ( ) ; $ this -> registerCommands ( ) ; }
2084	public function rotateLogs ( ) { @ trigger_error ( 'Using Automator::rotateLogs() has been deprecated and will no longer work in Contao 5.0. Use the logger service instead, which rotates its log files automatically.' , E_USER_DEPRECATED ) ; $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; $ arrFiles = preg_grep ( '/\.log$/' , scan ( $ rootDir . '/system/logs' ) ) ; foreach ( $ arrFiles as $ strFile ) { $ objFile = new File ( 'system/logs/' . $ strFile . '.9' ) ; if ( $ objFile -> exists ( ) ) { $ objFile -> delete ( ) ; } for ( $ i = 8 ; $ i > 0 ; $ i -- ) { $ strGzName = 'system/logs/' . $ strFile . '.' . $ i ; if ( file_exists ( $ rootDir . '/' . $ strGzName ) ) { $ objFile = new File ( $ strGzName ) ; $ objFile -> renameTo ( 'system/logs/' . $ strFile . '.' . ( $ i + 1 ) ) ; } } $ objFile = new File ( 'system/logs/' . $ strFile ) ; $ objFile -> renameTo ( 'system/logs/' . $ strFile . '.1' ) ; } }
4122	private function getProxyFileName ( $ className , $ baseDir = null ) { $ proxyDir = $ baseDir ? : $ this -> proxyDir ; return $ proxyDir . DIRECTORY_SEPARATOR . '__CG__' . str_replace ( '\\' , '' , $ className ) . '.php' ; }
3280	protected function normalizeConfig ( array $ config ) : array { $ defaultConfig = [ 'dir' => getcwd ( ) , 'ext' => '.dat' , 'gzip' => false , 'cache' => true , 'formatter' => null , 'swap_memory_limit' => 2097152 , ] ; return array_replace ( $ defaultConfig , $ config ) ; }
7848	private function checkConfig ( ) : void { if ( empty ( $ this -> device ) ) { Log :: warning ( 'Config "message.smsgatewayme.device" is not defined.' ) ; } if ( empty ( $ this -> token ) ) { Log :: warning ( 'Config "message.smsgatewayme.token" is not defined.' ) ; } }
2238	private function handlePrependLocale ( array $ extensionConfigs , ContainerBuilder $ container ) : array { if ( ! $ container -> hasParameter ( 'prepend_locale' ) ) { return $ extensionConfigs ; } foreach ( $ extensionConfigs as $ extensionConfig ) { if ( isset ( $ extensionConfig [ 'prepend_locale' ] ) ) { return $ extensionConfigs ; } } @ trigger_error ( 'Defining the "prepend_locale" parameter in the parameters.yml file has been deprecated and will no longer work in Contao 5.0. Define the "contao.prepend_locale" parameter in the config.yml file instead.' , E_USER_DEPRECATED ) ; $ extensionConfigs [ ] = [ 'prepend_locale' => '%prepend_locale%' , ] ; return $ extensionConfigs ; }
3407	public function setLockStore ( StoreInterface $ store ) : Factory { $ this -> lockFactory = new Factory ( $ store ) ; return $ this -> lockFactory ; }
10205	public function setIndent ( $ pValue ) { if ( $ pValue > 0 ) { if ( $ this -> getHorizontal ( ) != self :: HORIZONTAL_GENERAL && $ this -> getHorizontal ( ) != self :: HORIZONTAL_LEFT && $ this -> getHorizontal ( ) != self :: HORIZONTAL_RIGHT ) { $ pValue = 0 ; } } if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'indent' => $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> indent = $ pValue ; } return $ this ; }
7637	public function getBlobProperties ( $ containerName = '' , $ blobName = '' , $ snapshotId = null , $ leaseId = null ) { Assertion :: notEmpty ( $ containerName , 'Container name is not specified' ) ; self :: assertValidContainerName ( $ containerName ) ; Assertion :: notEmpty ( $ blobName , 'Blob name is not specified.' ) ; self :: assertValidRootContainerBlobName ( $ containerName , $ blobName ) ; return $ this -> getBlobInstance ( $ containerName , $ blobName , $ snapshotId , $ leaseId ) ; }
2962	public function serialflush ( ) { if ( ! $ this -> _ckOpened ( ) ) { return false ; } if ( fwrite ( $ this -> _dHandle , $ this -> _buffer ) !== false ) { $ this -> _buffer = "" ; return true ; } else { $ this -> _buffer = "" ; trigger_error ( "Error while sending message" , E_USER_WARNING ) ; return false ; } }
6316	public function setDeleteAction ( $ deleteAction ) { $ deleteAction = strtoupper ( $ deleteAction ) ; if ( ! in_array ( $ deleteAction , $ this -> getAvailableActions ( ) ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Action %s does not exist.' , $ deleteAction ) ) ; } $ this -> deleteAction = $ deleteAction ; }
5361	protected function createHeaderStatements ( Operation $ operation , $ queryParamVariable ) { $ headerVariable = new Expr \ Variable ( 'headers' ) ; $ headers = [ new Expr \ ArrayItem ( new Scalar \ String_ ( $ operation -> getHost ( ) ) , new Scalar \ String_ ( 'Host' ) ) , ] ; $ produces = $ operation -> getOperation ( ) -> getProduces ( ) ; if ( $ produces && in_array ( "application/json" , $ produces ) ) { $ headers [ ] = new Expr \ ArrayItem ( new Expr \ Array_ ( [ new Expr \ ArrayItem ( new Scalar \ String_ ( "application/json" ) ) , ] ) , new Scalar \ String_ ( 'Accept' ) ) ; } $ consumes = $ operation -> getOperation ( ) -> getProduces ( ) ; if ( $ operation -> getOperation ( ) -> getParameters ( ) && $ consumes ) { $ bodyParameters = array_filter ( $ operation -> getOperation ( ) -> getParameters ( ) , function ( $ parameter ) { return $ parameter instanceof BodyParameter ; } ) ; if ( count ( $ bodyParameters ) > 0 && in_array ( "application/json" , $ consumes ) ) { $ headers [ ] = new Expr \ ArrayItem ( new Scalar \ String_ ( "application/json" ) , new Scalar \ String_ ( 'Content-Type' ) ) ; } } return [ [ new Expr \ Assign ( $ headerVariable , new Expr \ FuncCall ( new Name ( 'array_merge' ) , [ new Arg ( new Expr \ Array_ ( $ headers ) ) , new Arg ( new Expr \ MethodCall ( $ queryParamVariable , 'buildHeaders' , [ new Arg ( new Expr \ Variable ( 'parameters' ) ) ] ) ) ] ) ) ] , $ headerVariable ] ; }
7583	protected function extractInfo ( ) { $ this -> info = curl_getinfo ( $ this -> CurlRequest ) ; $ this -> status = $ this -> info [ 'http_code' ] ; if ( curl_errno ( $ this -> CurlRequest ) !== CURLE_OK ) { $ this -> error = curl_error ( $ this -> CurlRequest ) ; } else { $ this -> error = false ; } }
10440	protected function parseQuery ( ) { if ( empty ( $ this -> lastLine ) || $ this -> lastLineType != self :: LINE_TYPE_QUERY ) { $ this -> getNextLine ( self :: LINE_TYPE_QUERY ) ; if ( empty ( $ this -> lastLine ) ) { return false ; } } $ buffer = $ this -> handleStart ( $ this -> lastLine ) ; $ this -> buffer [ $ this -> key ] [ self :: PARAM_DATE ] = $ this -> lastDateTime ; $ this -> buffer [ $ this -> key ] [ self :: PARAM_POSITION ] = $ this -> lastLogPosition ; $ this -> getNextLine ( self :: LINE_TYPE_QUERY ) ; if ( $ buffer [ 'type' ] == ActionTypes :: DELETE || $ buffer [ 'type' ] === ActionTypes :: UPDATE ) { $ buffer [ 'where' ] = $ this -> handleStatement ( $ this -> lastLine , self :: STATEMENT_TYPE_WHERE ) ; } if ( $ buffer [ 'type' ] == ActionTypes :: CREATE || $ buffer [ 'type' ] === ActionTypes :: UPDATE ) { $ buffer [ 'set' ] = $ this -> handleStatement ( $ this -> lastLine , self :: STATEMENT_TYPE_SET ) ; } return $ buffer ; }
8834	private function getObserver ( ) : ProcessObserverInterface { if ( 1 === count ( $ this -> observerList ) ) { $ observer = $ this -> observerList [ 0 ] ; } elseif ( count ( $ this -> observerList ) ) { $ observer = new AggregateLogger ( $ this -> observerList ) ; } else { $ observer = new NullProcessObserver ( ) ; } return $ observer ; }
5179	private function addNew ( string $ key , $ value ) : self { $ this -> props [ $ key ] = $ value ; return $ this ; }
12789	protected function loadForeignObject ( ) { if ( $ this -> _isLoadingForeignObject ) { throw new RecursionException ( 'Ran into recursion while loading foreign object' ) ; } $ this -> _isLoadingForeignObject = true ; if ( isset ( $ this -> foreignPrimaryKey ) ) { $ foreignObject = $ this -> dataSource -> getForeignDataModel ( $ this -> foreignPrimaryKey ) ; if ( $ foreignObject ) { $ this -> foreignObject = $ foreignObject ; } } if ( empty ( $ this -> _foreignObject ) ) { \ d ( $ this -> foreignPrimaryKey ) ; \ d ( $ this -> dataSource -> name ) ; throw new MissingItemException ( 'Foreign item could not be found: ' . $ this -> foreignPrimaryKey ) ; } $ this -> _isLoadingForeignObject = false ; }
1186	protected function resolve ( $ translator , $ data , $ rules , $ messages , $ customAttributes , $ field ) { $ validateAll = Arr :: get ( $ data , $ field . '_validate_all' , false ) ; $ validationRule = 'bail|' . Validator :: EXTENSION_NAME . ':' . $ validateAll ; $ rules = [ $ field => $ validationRule ] + $ rules ; $ validator = $ this -> createValidator ( $ translator , $ data , $ rules , $ messages , $ customAttributes ) ; return $ validator ; }
4535	public function prePersist ( LifecycleEventArgs $ args ) { $ entity = $ args -> getEntity ( ) ; if ( ! $ entity instanceof Tenantable ) { return ; } if ( null !== $ entity -> getTenant ( ) ) { return ; } $ tenant = $ this -> container -> get ( TenantService :: class ) -> getContext ( ) ; $ entity -> setTenant ( $ tenant ) ; }
483	public function createIndex ( $ name , $ table , $ columns , $ unique = false ) { $ time = $ this -> beginCommand ( 'create' . ( $ unique ? ' unique' : '' ) . " index $name on $table (" . implode ( ',' , ( array ) $ columns ) . ')' ) ; $ this -> db -> createCommand ( ) -> createIndex ( $ name , $ table , $ columns , $ unique ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
2522	protected function callMessage ( $ messageName , $ options , $ messageOptions , $ endSession = false ) { $ messageOptions = $ this -> makeMessageOptions ( $ messageOptions , $ endSession ) ; $ this -> lastMessage = $ messageName ; $ sendResult = $ this -> sessionHandler -> sendMessage ( $ messageName , $ this -> requestCreator -> createRequest ( $ messageName , $ options ) , $ messageOptions ) ; $ response = $ this -> responseHandler -> analyzeResponse ( $ sendResult , $ messageName ) ; if ( $ messageOptions [ 'returnXml' ] === false ) { $ response -> responseXml = null ; } return $ response ; }
3559	protected function mutateValue ( $ value , $ dir = 'setter' ) { $ mutator = $ this -> getMutator ( $ value , $ dir , $ this -> attributes [ 'meta_type' ] ) ; if ( method_exists ( $ this , $ mutator ) ) { return $ this -> { $ mutator } ( $ value ) ; } return static :: $ attributeMutator -> mutate ( $ value , $ mutator ) ; }
11486	protected function resolveNonClassArg ( ReflectionParameter $ param , array $ params , ReflectionFunctionAbstract $ func ) { $ name = '$' . $ param -> getName ( ) ; if ( $ params && array_key_exists ( $ name , $ params ) ) { $ argument = $ params [ $ name ] ; if ( is_array ( $ argument ) && isset ( $ this -> factories [ $ argument [ 0 ] ] ) ) { $ argument = $ this -> callFactory ( $ argument [ 0 ] , $ argument [ 1 ] ) ; } return $ argument ; } if ( $ param -> isDefaultValueAvailable ( ) ) { return $ param -> getDefaultValue ( ) ; } throw Exception \ UnresolvableArgumentException :: fromReflectionParam ( $ param , $ func ) ; }
11165	protected function getDurationFormat ( array $ config ) { if ( isset ( $ config [ 'durationFormat' ] ) ) { if ( ! is_string ( $ config [ 'durationFormat' ] ) ) { throw new \ DomainException ( 'durationFormat must reference a string' , self :: ERR_INVALID_DURATIONFORMAT ) ; } return $ config [ 'durationFormat' ] ; } return '%im%ss' ; }
1944	public function section ( $ key , $ template = null ) { if ( empty ( $ this -> sections [ $ key ] ) ) { return ; } $ this -> id = $ key ; $ this -> content = $ this -> sections [ $ key ] ; if ( $ template === null ) { $ template = 'block_section' ; foreach ( $ this -> positions as $ position ) { if ( isset ( $ position [ $ key ] [ 'template' ] ) ) { $ template = $ position [ $ key ] [ 'template' ] ; } } } include $ this -> getTemplate ( $ template ) ; }
7740	public function validate ( $ entity ) { if ( ! $ this -> container -> has ( 'validator' ) ) { throw new \ LogicException ( 'The validator service is not available.' ) ; } $ errors = $ this -> container -> get ( 'validator' ) -> validate ( $ entity ) ; if ( count ( $ errors ) === 0 ) { return false ; } return new JsonLdResponse ( '{ "error": "Validation error" }' , 400 ) ; }
7120	protected function getFindBySubjectAndSupplierQuery ( ) { if ( null !== $ this -> findBySubjectAndSupplierQuery ) { return $ this -> findBySubjectAndSupplierQuery ; } $ qb = $ this -> createFindBySubjectQueryBuilder ( ) ; return $ this -> findBySubjectAndSupplierQuery = $ qb -> andWhere ( $ qb -> expr ( ) -> eq ( $ this -> getAlias ( ) . '.supplier' , ':supplier' ) ) -> getQuery ( ) ; }
289	protected function isLanguageSupported ( $ requested , $ supported ) { $ supported = str_replace ( '_' , '-' , strtolower ( $ supported ) ) ; $ requested = str_replace ( '_' , '-' , strtolower ( $ requested ) ) ; return strpos ( $ requested . '-' , $ supported . '-' ) === 0 ; }
1941	public function checkBlacklistedRecipient ( $ varValue , Contao \ DataContainer $ dc ) { $ objBlacklist = $ this -> Database -> prepare ( "SELECT COUNT(*) AS count FROM tl_newsletter_blacklist WHERE hash=? AND pid=(SELECT pid FROM tl_newsletter_recipients WHERE id=?) AND id!=?" ) -> execute ( md5 ( $ varValue ) , $ dc -> id , $ dc -> id ) ; if ( $ objBlacklist -> count > 0 ) { throw new Exception ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'blacklisted' ] ) ; } return $ varValue ; }
10946	public function post ( $ name = null , $ defaultValue = null ) { if ( $ name === null ) { return $ this -> getBodyParams ( ) ; } else { return $ this -> getBodyParam ( $ name , $ defaultValue ) ; } }
2749	public function getVclFile ( $ vclTemplatePath ) { $ moduleEtcPath = $ this -> reader -> getModuleDir ( Dir :: MODULE_ETC_DIR , 'Fastly_Cdn' ) ; $ configFilePath = $ moduleEtcPath . '/' . $ this -> _scopeConfig -> getValue ( self :: FASTLY_CONFIGURATION_PATH ) ; $ directoryRead = $ this -> readFactory -> create ( $ moduleEtcPath ) ; $ configFilePath = $ directoryRead -> getRelativePath ( $ configFilePath ) ; $ data = $ directoryRead -> readFile ( $ configFilePath ) ; return strtr ( $ data , $ this -> getReplacements ( ) ) ; }
7997	public static function getSpecificationString ( $ reversed = false ) { $ reflection = new ReflectionClass ( get_class ( ) ) ; $ constants = $ reflection -> getConstants ( ) ; if ( $ reversed ) { $ constants = array_reverse ( $ constants ) ; } $ string = '' ; foreach ( $ constants as $ name => $ int_val ) { $ binary_val_string = base_convert ( ( string ) $ int_val , '10' , '2' ) ; $ string .= sprintf ( '0b%s : %s' , str_pad ( $ binary_val_string , 32 , '0' , STR_PAD_LEFT ) , $ name ) ; $ string .= PHP_EOL ; } return $ string ; }
10837	protected function buildOrderBy ( ) { $ result = [ ] ; foreach ( $ this -> clause_orderby as $ ord ) { $ result [ ] = $ ord [ 0 ] ? $ ord [ 1 ] : ( $ this -> quote ( $ ord [ 1 ] ) . ' ' . $ ord [ 2 ] ) ; } return $ result ; }
7262	protected function assertAdjustmentMode ( Model \ AdjustmentInterface $ adjustment , string $ expected ) : void { if ( $ expected !== $ mode = $ adjustment -> getMode ( ) ) { throw new Exception \ InvalidArgumentException ( "Unexpected adjustment mode '$mode'." ) ; } }
9544	public static function allExcept ( $ except ) { $ result = [ 'parameter' => [ 'longest' => 9 + $ columnPadding , 'values' => [ ] , 'fetch' => function ( $ parameter ) { return $ parameter -> prefix . $ parameter -> parameterName ; } , ] , 'properties' => [ 'longest' => 10 + $ columnPadding , 'values' => [ ] , 'fetch' => function ( $ parameter ) { return $ parameter -> getPropertiesAsString ( ) ; } , ] , 'aliases' => [ 'longest' => 7 + $ columnPadding , 'values' => [ ] , 'fetch' => function ( $ parameter ) { return $ parameter -> getAliasUsage ( false ) ; } , ] , 'description' => [ 'longest' => 11 + $ columnPadding , 'values' => [ ] , 'fetch' => function ( $ parameter ) { return $ parameter -> description ; } , ] , 'required' => [ 'longest' => 8 + $ columnPadding , 'values' => [ ] , 'fetch' => function ( $ parameter ) { return $ parameter -> required ? 'Yes' : '' ; } , ] , ] ; foreach ( $ except as $ exceptKey ) { unset ( $ result [ $ exceptKey ] ) ; } return $ result ; }
1141	public function setValue ( $ value ) { if ( \ is_bool ( $ value ) ) { if ( 'checkbox' !== $ this -> type ) { throw new \ InvalidArgumentException ( \ sprintf ( 'Invalid argument of type "%s"' , \ gettype ( $ value ) ) ) ; } if ( $ value ) { if ( ! $ this -> element -> isSelected ( ) ) { $ this -> element -> click ( ) ; } } elseif ( $ this -> element -> isSelected ( ) ) { $ this -> element -> click ( ) ; } return ; } foreach ( ( array ) $ value as $ v ) { $ this -> selector -> selectByValue ( $ v ) ; } }
9571	public function bootConsole ( ) { $ this -> console = new ConsoleApplication ( 'Autarky' , static :: VERSION ) ; $ this -> console -> setAutarkyApplication ( $ this ) ; $ this -> boot ( ) ; return $ this -> console ; }
11524	public function parseBotUA ( $ botName ) { $ dom = $ this -> getDom ( 'https://udger.com/resources/ua-list/bot-detail?bot=' . $ botName ) ; if ( false === $ dom ) { echo "Can not parse DOM" . PHP_EOL ; return false ; } $ this -> currentBotName = $ botName ; $ crawlerBot = new Crawler ( ) ; $ crawlerBot -> addContent ( $ dom ) ; $ crawlerBot -> filter ( 'body #container table tr td > a' ) -> each ( function ( $ el , $ i ) { if ( strpos ( $ el -> attr ( 'href' ) , '/resources/online-parser' ) !== false ) { $ botUA = $ el -> text ( ) ; $ this -> addBotUA ( $ botUA ) ; } } ) ; return true ; }
3824	protected function getFilterParameters ( $ objItemRenderer ) { $ filterUrlBuilder = System :: getContainer ( ) -> get ( 'metamodels.filter_url' ) ; $ filterUrl = $ filterUrlBuilder -> getCurrentFilterUrl ( ) ; $ result = [ ] ; foreach ( $ objItemRenderer -> getFilterSettings ( ) -> getParameters ( ) as $ name ) { if ( $ filterUrl -> hasSlug ( $ name ) ) { $ result [ $ name ] = $ filterUrl -> getSlug ( $ name ) ; } Input :: get ( $ name ) ; } return $ filterUrl -> getSlugParameters ( ) ; }
7760	protected function detectMetadataDriver ( $ dir , ContainerBuilder $ container ) { $ configPath = $ this -> getMappingResourceConfigDirectory ( ) ; $ resource = $ dir . '/' . $ configPath ; while ( ! is_dir ( $ resource ) ) { $ resource = dirname ( $ resource ) ; } $ container -> addResource ( new FileResource ( $ resource ) ) ; $ extension = $ this -> getMappingResourceExtension ( ) ; if ( ( $ files = glob ( $ dir . '/' . $ configPath . '/*.' . $ extension . '.xml' ) ) && count ( $ files ) ) { return 'xml' ; } elseif ( ( $ files = glob ( $ dir . '/' . $ configPath . '/*.' . $ extension . '.yml' ) ) && count ( $ files ) ) { return 'yml' ; } elseif ( ( $ files = glob ( $ dir . '/' . $ configPath . '/*.' . $ extension . '.php' ) ) && count ( $ files ) ) { return 'php' ; } $ container -> addResource ( new FileResource ( $ dir ) ) ; if ( is_dir ( $ dir . '/' . $ this -> getMappingObjectDefaultName ( ) ) ) { return 'annotation' ; } return null ; }
11339	public function getModuleSetModules ( ) { if ( empty ( $ this -> moduleSet ) || ! isset ( Yii :: $ app -> extensions [ $ this -> moduleSet ] ) ) { return '' ; } $ bsClass = Yii :: $ app -> extensions [ $ this -> moduleSet ] [ 'bootstrap' ] ; $ p = [ ] ; $ bs = new $ bsClass ( ) ; $ modules = $ bs -> getModules ( ) ; $ modules [ $ this -> moduleID ] = [ 'class' => $ this -> moduleClass ] ; foreach ( $ modules as $ id => $ module ) { $ e = '$m[\'' . $ id . '\'] = [' ; if ( ! is_array ( $ module ) ) { $ module = [ 'class' => $ module ] ; } $ n = 0 ; foreach ( $ module as $ k => $ v ) { $ e .= "\n\t\t\t'{$k}' => " ; if ( is_string ( $ v ) ) { $ e .= "'" . addslashes ( $ v ) . "'" ; } elseif ( is_numeric ( $ v ) ) { $ e .= $ v ; } $ n ++ ; if ( $ n !== count ( $ module ) ) { $ e .= ',' ; } } $ e .= "\n\t\t];" ; $ p [ ] = $ e ; } return implode ( "\n\t\t" , $ p ) ; }
3200	protected function binaryPopCount ( $ value ) { $ value -= ( ( $ value >> 1 ) & 0x55555555 ) ; $ value = ( ( ( $ value >> 2 ) & 0x33333333 ) + ( $ value & 0x33333333 ) ) ; $ value = ( ( ( $ value >> 4 ) + $ value ) & 0x0f0f0f0f ) ; $ value += ( $ value >> 8 ) ; $ value += ( $ value >> 16 ) ; return $ value & 0x0000003f ; }
9353	public function inverse ( ) { $ det = $ this -> det ( ) ; if ( $ det == 0 ) { throw new \ RuntimeException ( 'Cannot get inverse matrix: determinant is nul!' ) ; } return $ this -> adjugate ( ) -> multiply ( 1 / $ det ) ; }
6032	public function getDeployedFile ( $ templateId , $ templateType = self :: TEMPLATE_IMAGE , $ siteId = null ) { foreach ( $ this -> deployedFiles as $ deployedFile ) { if ( null === $ siteId || $ siteId == $ deployedFile -> getDeployMentSiteId ( ) ) { if ( self :: TEMPLATE_VIDEO == $ templateType ) { if ( $ templateId == $ deployedFile -> getVideoTemplateId ( ) && null === $ deployedFile -> getImageTemplateId ( ) ) { return $ deployedFile ; } } elseif ( self :: TEMPLATE_IMAGE == $ templateType && $ templateId == $ deployedFile -> getImageTemplateId ( ) || ( null === $ templateId && null === $ deployedFile -> getImageTemplateId ( ) && null === $ deployedFile -> getVideoTemplateId ( ) ) ) { return $ deployedFile ; } } } throw new NotFoundException ( 'No DeploymentFile with the id "' . $ templateId . '" exists.' ) ; }
10057	public function hasItem ( $ key ) { if ( isset ( $ this -> data [ $ key ] ) ) { $ item = $ this -> data [ $ key ] ; if ( $ item -> isHit ( ) === true && ( $ item -> getExpires ( ) === null || $ item -> getExpires ( ) > new DateTime ( ) ) ) { return true ; } } return false ; }
549	public static function dumpAsString ( $ var , $ depth = 10 , $ highlight = false ) { self :: $ _output = '' ; self :: $ _objects = [ ] ; self :: $ _depth = $ depth ; self :: dumpInternal ( $ var , 0 ) ; if ( $ highlight ) { $ result = highlight_string ( "<?php\n" . self :: $ _output , true ) ; self :: $ _output = preg_replace ( '/&lt;\\?php<br \\/>/' , '' , $ result , 1 ) ; } return self :: $ _output ; }
8449	public function contactAdd ( $ phoneNumber , $ firstName , $ lastName ) { $ phoneNumber = $ this -> formatPhoneNumber ( $ phoneNumber ) ; return $ this -> exec ( 'add_contact ' . $ phoneNumber . ' ' . $ this -> escapeStringArgument ( $ firstName ) . ' ' . $ this -> escapeStringArgument ( $ lastName ) ) ; }
9355	public function det ( ) { if ( ! $ this -> isSquare ( ) ) { throw new \ RuntimeException ( 'Cannot compute determinant of non square matrix!' ) ; } if ( $ this -> size -> rows == 2 ) { return $ this -> get ( 0 , 0 ) * $ this -> get ( 1 , 1 ) - $ this -> get ( 0 , 1 ) * $ this -> get ( 1 , 0 ) ; } else { $ int_out = 0 ; $ arr_row = $ this -> arr [ 0 ] ; foreach ( $ arr_row as $ n => $ v ) { $ int_out += pow ( - 1 , $ n + 2 ) * $ v * $ this -> subMatrix ( 0 , $ n ) -> det ( ) ; } return $ int_out ; } }
5888	public function getClass ( $ prefix = "ts3_" ) { if ( $ this instanceof Channel && $ this -> isSpacer ( ) ) { return $ prefix . "spacer" ; } elseif ( $ this instanceof Client && $ this [ "client_type" ] ) { return $ prefix . "query" ; } return $ prefix . StringHelper :: factory ( get_class ( $ this ) ) -> toLower ( ) ; }
6922	public function set ( TaxGroupInterface $ taxGroup , CountryInterface $ country , $ business = false , array $ taxes ) { $ key = $ this -> buildKey ( $ taxGroup , $ country , $ business ) ; $ this -> taxes [ $ key ] = $ taxes ; }
2479	protected function getSearchFields ( Criterion $ criterion , $ fieldDefinitionIdentifier , $ fieldTypeIdentifier = null , $ name = null ) { return $ this -> fieldNameResolver -> getFieldTypes ( $ criterion , $ fieldDefinitionIdentifier , $ fieldTypeIdentifier , $ name ) ; }
5795	public function insert ( array $ columnValues , bool $ addBooleanColumnFalse = false ) { if ( $ addBooleanColumnFalse ) { $ columnValues = $ this -> addBooleanColumnFalse ( $ columnValues ) ; } $ ib = new InsertBuilder ( $ this -> tableName ) ; if ( $ this -> getPrimaryKeyColumnName ( ) !== null ) { $ ib -> setPrimaryKeyName ( $ this -> getPrimaryKeyColumnName ( ) ) ; } $ this -> addColumnsToBuilder ( $ ib , $ columnValues ) ; return $ ib -> runExecute ( ) ; }
12835	private function generateFactoryCreatorMethod ( FactoredService $ service ) : string { $ factoryMethod = $ service -> getFactoryMethod ( ) ; $ taggedAs = implode ( ', ' , $ service -> getTags ( ) ) ; $ classNormalized = $ this -> normalizeFqcn ( $ service -> getClass ( ) ) ; $ optional = $ service -> getFactoryMethod ( ) -> isOptional ( ) ? '?' : '' ; if ( $ service -> isSingleton ( ) ) { return <<<PHP /** * Get the factored service "{$service->getId()}" (Singleton) * * It is tagged as: {$taggedAs} * * @return {$this->normalizeFqcn($service->getClass())} */ public function {$this->mapIdToServiceGetter($service->getId())} () : {$optional}{$classNormalized} { if (isset(\$this->singletons['{$service->getId()}'])) { return \$this->singletons['{$service->getId()}']; } /** @noinspection OneTimeUseVariablesInspection */ \$service = \$this->singletons['{$service->getId()}'] = {$this->generateCreatorByServiceId($factoryMethod->getFactoryId())}->{$factoryMethod->getMethodName()}({$this->buildInjectionParameters($this->container, $factoryMethod->getInjection())} );{$this->generateSetterInjectionsCode($service)} return \$service; }PHP ; } return <<<PHP /** * Get a fresh instance of service "{$service->getId()}" (Prototype) * * It is tagged as: {$taggedAs} * * @return {$this->normalizeFqcn($service->getClass())} */ public function {$this->mapIdToServiceGetter($service->getId())} () : $classNormalized { \$this->prototypes['{$service->getId()}'] = (\$this->prototypes['{$service->getId()}'] ?? 0) + 1; /** @noinspection OneTimeUseVariablesInspection */ \$service = {$this->generateCreatorByServiceId($factoryMethod->getFactoryId())}->{$factoryMethod->getMethodName()}({$this->buildInjectionParameters($this->container, $factoryMethod->getInjection())} );{$this->generateSetterInjectionsCode($service)} return \$service; }PHP ; }
773	public function actionExtract ( $ configFile = null ) { $ this -> initConfig ( $ configFile ) ; $ files = FileHelper :: findFiles ( realpath ( $ this -> config [ 'sourcePath' ] ) , $ this -> config ) ; $ messages = [ ] ; foreach ( $ files as $ file ) { $ messages = array_merge_recursive ( $ messages , $ this -> extractMessages ( $ file , $ this -> config [ 'translator' ] , $ this -> config [ 'ignoreCategories' ] ) ) ; } $ catalog = isset ( $ this -> config [ 'catalog' ] ) ? $ this -> config [ 'catalog' ] : 'messages' ; if ( in_array ( $ this -> config [ 'format' ] , [ 'php' , 'po' ] ) ) { foreach ( $ this -> config [ 'languages' ] as $ language ) { $ dir = $ this -> config [ 'messagePath' ] . DIRECTORY_SEPARATOR . $ language ; if ( ! is_dir ( $ dir ) && ! @ mkdir ( $ dir ) ) { throw new Exception ( "Directory '{$dir}' can not be created." ) ; } if ( $ this -> config [ 'format' ] === 'po' ) { $ this -> saveMessagesToPO ( $ messages , $ dir , $ this -> config [ 'overwrite' ] , $ this -> config [ 'removeUnused' ] , $ this -> config [ 'sort' ] , $ catalog , $ this -> config [ 'markUnused' ] ) ; } else { $ this -> saveMessagesToPHP ( $ messages , $ dir , $ this -> config [ 'overwrite' ] , $ this -> config [ 'removeUnused' ] , $ this -> config [ 'sort' ] , $ this -> config [ 'markUnused' ] ) ; } } } elseif ( $ this -> config [ 'format' ] === 'db' ) { $ db = Instance :: ensure ( $ this -> config [ 'db' ] , Connection :: className ( ) ) ; $ sourceMessageTable = isset ( $ this -> config [ 'sourceMessageTable' ] ) ? $ this -> config [ 'sourceMessageTable' ] : '{{%source_message}}' ; $ messageTable = isset ( $ this -> config [ 'messageTable' ] ) ? $ this -> config [ 'messageTable' ] : '{{%message}}' ; $ this -> saveMessagesToDb ( $ messages , $ db , $ sourceMessageTable , $ messageTable , $ this -> config [ 'removeUnused' ] , $ this -> config [ 'languages' ] , $ this -> config [ 'markUnused' ] ) ; } elseif ( $ this -> config [ 'format' ] === 'pot' ) { $ this -> saveMessagesToPOT ( $ messages , $ this -> config [ 'messagePath' ] , $ catalog ) ; } }
846	public function generatePartialCode ( $ start , $ end ) { $ code = '' ; for ( $ i = $ start ; $ i <= $ end ; ++ $ i ) { $ code .= $ this [ $ i ] -> getContent ( ) ; } return $ code ; }
4900	public static function loadDotEnv ( ) { $ dotenv = new Dotenv ( ) ; if ( is_file ( getcwd ( ) . '/.env.dist' ) ) { $ dotenv -> load ( getcwd ( ) . '/.env.dist' ) ; } if ( is_file ( $ file = getcwd ( ) . '/.env' ) ) { $ dotenv -> load ( $ file ) ; } if ( false === getenv ( 'TIMEZONE' ) ) { putenv ( 'TIMEZONE=Europe/Berlin' ) ; } date_default_timezone_set ( getenv ( 'TIMEZONE' ) ) ; }
6349	public static function limit ( Iterator $ iterator , int $ limitSize ) : Iterator { Preconditions :: checkArgument ( 0 <= $ limitSize ) ; return new NoRewindNecessaryLimitIterator ( $ iterator , $ limitSize ) ; }
6288	private function buildResponse ( ReactResponse $ response , StreamInterface $ body ) { $ body -> rewind ( ) ; return $ this -> responseFactory -> createResponse ( $ response -> getCode ( ) , $ response -> getReasonPhrase ( ) , $ response -> getHeaders ( ) , $ body , $ response -> getVersion ( ) ) ; }
6541	public function fetchOne ( $ tableName , array $ identifier , $ shardingKey = null , $ forceFromMaster = true ) { return $ this -> fetch ( $ tableName , $ identifier , $ shardingKey , array ( '*' ) , false , $ forceFromMaster ) ; }
1172	protected function callProtected ( $ instance , $ method , $ args = [ ] ) { if ( ! ( $ instance instanceof Closure ) ) { $ instance = $ this -> createProtectedCaller ( $ instance ) ; } return call_user_func ( $ instance , $ method , $ args ) ; }
4649	protected function getServices ( $ config ) { $ services = array ( ) ; $ travisServices = isset ( $ config [ 'services' ] ) && is_array ( $ config [ 'services' ] ) ? $ config [ 'services' ] : array ( ) ; foreach ( $ travisServices as $ service ) { if ( isset ( $ this -> servicesMapping [ $ service ] ) ) { $ services [ ] = new Service ( $ service , $ this -> servicesMapping [ $ service ] [ 'repository' ] , $ this -> servicesMapping [ $ service ] [ 'tag' ] , $ this -> servicesMapping [ $ service ] [ 'config' ] ) ; } } return $ services ; }
1362	public function accept ( AcceptMediaTypeInterface $ mediaType ) : bool { if ( 0 === $ mediaType -> getQuality ( ) ) { return false ; } return $ this -> matchesTo ( $ mediaType ) ; }
11958	public function remove ( $ element ) { if ( ! $ this -> contains ( $ element ) ) { return false ; } $ this -> offsetUnset ( $ this -> indexOf ( $ element ) ) ; return true ; }
6393	public static function run ( callable $ tryBlock , array $ exceptions = [ ] , callable $ finallyBlock = null ) : TryTo { try { return Success :: of ( Functions :: call ( $ tryBlock ) ) ; } catch ( Exception $ e ) { if ( count ( $ exceptions ) === 0 ) { return Failure :: of ( $ e ) ; } $ error = FluentIterable :: of ( $ exceptions ) -> filter ( Predicates :: assignableFrom ( get_class ( $ e ) ) ) -> first ( ) ; if ( $ error -> isPresent ( ) ) { return Failure :: of ( $ e ) ; } throw $ e ; } finally { if ( $ finallyBlock !== null ) { Functions :: call ( $ finallyBlock ) ; } } }
5678	protected function extractResponse ( $ response ) { $ this -> transport_error = $ response -> getError ( ) ; $ this -> raw = $ response -> getContent ( ) ; $ this -> sent = $ response -> getSent ( ) ; $ this -> headers = $ response -> getHeaders ( ) ; $ this -> method = $ response -> getMethod ( ) ; $ this -> url = $ response -> getUrl ( ) ; $ this -> request_data = $ response -> getRequestData ( ) ; }
4181	public function getResources ( ) { return $ this -> resources ? : $ this -> resources = Resource :: instance ( clone $ this -> getFiles ( ) , $ this -> console ) ; }
176	public static function removeValue ( & $ array , $ value ) { $ result = [ ] ; if ( is_array ( $ array ) ) { foreach ( $ array as $ key => $ val ) { if ( $ val === $ value ) { $ result [ $ key ] = $ val ; unset ( $ array [ $ key ] ) ; } } } return $ result ; }
797	public function getArrayEnd ( $ index ) { $ level = 1 ; for ( ++ $ index , $ max = \ count ( $ this ) ; $ index < $ max ; ++ $ index ) { if ( $ this [ $ index ] -> isType ( DocLexer :: T_OPEN_CURLY_BRACES ) ) { ++ $ level ; } elseif ( $ this [ $ index ] -> isType ( $ index , DocLexer :: T_CLOSE_CURLY_BRACES ) ) { -- $ level ; } if ( 0 === $ level ) { return $ index ; } } return null ; }
1201	public function isCurrent ( ItemInterface $ item ) { if ( null === $ this -> matcher ) { throw new \ BadMethodCallException ( 'The matcher must be set to get the breadcrumbs array' ) ; } return $ this -> matcher -> isCurrent ( $ item ) ; }
7963	public function ipSetMonitoringNotifications ( $ ip , $ frequency = 'once' , $ email = '' , $ sms = array ( ) ) { return json_decode ( self :: getClient ( ) -> ipSetMonitoringNotifications ( $ this -> id , $ ip , $ frequency , $ email , $ sms ) ) ; }
12066	public function invokeRpcCall ( $ method , $ arguments = [ ] ) { if ( ! is_null ( $ this -> namespace ) ) { $ method = $ this -> namespace . '.' . $ method ; } $ body = XmlRpcBuilder :: createRequest ( $ method , $ arguments ) ; $ guzzle = new \ GuzzleHttp \ Client ( ) ; $ this -> getLogger ( ) -> info ( "sending request for $method to {$this->url}" ) ; $ this -> getLogger ( ) -> debug ( "sending request for $method to {$this->url}, with parameters: " . print_r ( $ arguments , true ) ) ; $ response = $ guzzle -> post ( $ this -> url , [ 'body' => $ body , 'headers' => [ 'User-Agent' => 'Devedge\XmlRpc\Client/' . self :: $ version , 'Content-Type' => 'text/xml' ] ] ) ; if ( $ response -> xml ( ) -> fault -> count ( ) > 0 ) { $ this -> logger -> warning ( "serverside error occured, details: " . $ response -> getBody ( ) ) ; throw XmlRpcParser :: parseFault ( $ response -> xml ( ) -> fault ) ; } return array_shift ( XmlRpcParser :: parseParams ( $ response -> xml ( ) -> params ) ) ; }
2120	public function getFromFile ( ) { $ return = array ( ) ; $ files = System :: getContainer ( ) -> get ( 'contao.resource_finder' ) -> findIn ( 'config' ) -> depth ( 0 ) -> files ( ) -> name ( 'database.sql' ) ; foreach ( $ files as $ file ) { $ return = array_replace_recursive ( $ return , SqlFileParser :: parse ( $ file ) ) ; } ksort ( $ return ) ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'sqlGetFromFile' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'sqlGetFromFile' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'sqlGetFromFile' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ return = $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ return ) ; } } return $ return ; }
12960	public function query ( $ sql , $ return = false ) { $ query = $ this -> getDb ( ) -> query ( $ sql , true ) ; if ( $ return ) { return $ query ; } }
9284	private function checkImports ( $ lessPath , $ cssPath , $ callback ) { static $ needsRecompile = false ; if ( $ needsRecompile ) return $ needsRecompile ; $ lessContent = file_get_contents ( $ lessPath ) ; preg_match_all ( '/(?<=@import)\s+"([^"]+)/im' , $ lessContent , $ imports ) ; foreach ( $ imports [ 1 ] as $ import ) { $ importPath = realpath ( dirname ( $ lessPath ) . DIRECTORY_SEPARATOR . $ import ) ; if ( file_exists ( $ importPath ) ) { if ( $ callback ( $ importPath , $ cssPath ) ) { $ needsRecompile = true ; break ; } else $ needsRecompile = $ this -> checkImports ( $ importPath , $ cssPath , $ callback ) ; } } return $ needsRecompile ; }
7669	function ServerVar ( $ varName ) { global $ HTTP_SERVER_VARS ; global $ HTTP_ENV_VARS ; if ( ! isset ( $ _SERVER ) ) { $ _SERVER = $ HTTP_SERVER_VARS ; if ( ! isset ( $ _SERVER [ "REMOTE_ADDR" ] ) ) $ _SERVER = $ HTTP_ENV_VARS ; } if ( isset ( $ _SERVER [ $ varName ] ) ) return $ _SERVER [ $ varName ] ; else return "" ; }
4029	protected function getLabelText ( TranslatorInterface $ translator , ModelInterface $ model ) { $ type = $ model -> getProperty ( 'type' ) ; $ label = $ translator -> translate ( 'typenames.' . $ type , 'tl_metamodel_filtersetting' ) ; if ( $ label == 'typenames.' . $ type ) { return $ type ; } return $ label ; }
405	public function addCorsHeaders ( $ response , $ headers ) { if ( empty ( $ headers ) === false ) { $ responseHeaders = $ response -> getHeaders ( ) ; foreach ( $ headers as $ field => $ value ) { $ responseHeaders -> set ( $ field , $ value ) ; } } }
1424	protected function load ( $ record , EncodingParametersInterface $ parameters ) { $ relationshipPaths = $ this -> getRelationshipPaths ( $ parameters -> getIncludePaths ( ) ) ; $ record -> loadMissing ( $ relationshipPaths ) ; }
11062	public static function isEncodingSupported ( $ encoding ) { $ encoding = strtolower ( $ encoding ) ; if ( isset ( static :: supportedEncodings ( ) [ $ encoding ] ) ) { return true ; } return false ; }
10088	function addAttachmentFromBinaryData ( $ filename , $ mimetype , $ contents ) { $ attachment = new Attachment ( $ filename , $ mimetype , base64_encode ( $ contents ) ) ; $ this -> attachments [ ] = $ attachment ; }
10667	protected function buildOnDup ( ) { $ result = [ ] ; foreach ( $ this -> clause_ondup as $ col => $ expr ) { $ result [ ] = $ col . ' = ' . $ expr ; } return $ result ; }
1499	public function when ( bool $ test , $ encodings ) : self { if ( ! $ test || is_null ( $ encodings ) ) { return $ this ; } if ( $ encodings instanceof \ Closure ) { return $ encodings ( $ this ) ; } if ( is_string ( $ encodings ) ) { $ encodings = Encoding :: custom ( $ encodings ) ; } $ encodings = $ encodings instanceof Encoding ? [ $ encodings ] : $ encodings ; return $ this -> push ( ... $ encodings ) ; }
4978	public function filter ( $ value ) { return isset ( $ this -> map [ $ value ] ) ? $ this -> map [ $ value ] : $ value ; }
1635	protected function setupEvents ( Dispatcher $ events , array $ config ) { if ( isset ( $ config [ 'auto_capture_sessions' ] ) && $ config [ 'auto_capture_sessions' ] ) { $ events -> listen ( RouteMatched :: class , function ( $ event ) { $ this -> app -> bugsnag -> getSessionTracker ( ) -> startSession ( ) ; } ) ; } if ( isset ( $ config [ 'query' ] ) && ! $ config [ 'query' ] ) { return ; } $ show = isset ( $ config [ 'bindings' ] ) && $ config [ 'bindings' ] ; if ( class_exists ( QueryExecuted :: class ) ) { $ events -> listen ( QueryExecuted :: class , function ( QueryExecuted $ query ) use ( $ show ) { $ this -> app -> bugsnag -> leaveBreadcrumb ( 'Query executed' , Breadcrumb :: PROCESS_TYPE , $ this -> formatQuery ( $ query -> sql , $ show ? $ query -> bindings : [ ] , $ query -> time , $ query -> connectionName ) ) ; } ) ; } else { $ events -> listen ( 'illuminate.query' , function ( $ sql , array $ bindings , $ time , $ connection ) use ( $ show ) { $ this -> app -> bugsnag -> leaveBreadcrumb ( 'Query executed' , Breadcrumb :: PROCESS_TYPE , $ this -> formatQuery ( $ sql , $ show ? $ bindings : [ ] , $ time , $ connection ) ) ; } ) ; } }
2020	public function getSearchablePages ( $ arrPages , $ intRoot = 0 , $ blnIsSitemap = false ) { $ arrRoot = array ( ) ; if ( $ intRoot > 0 ) { $ arrRoot = $ this -> Database -> getChildRecords ( $ intRoot , 'tl_page' ) ; } $ arrProcessed = array ( ) ; $ time = Date :: floorToMinute ( ) ; $ objFaq = FaqCategoryModel :: findAll ( ) ; if ( $ objFaq !== null ) { while ( $ objFaq -> next ( ) ) { if ( ! $ objFaq -> jumpTo ) { continue ; } if ( ! empty ( $ arrRoot ) && ! \ in_array ( $ objFaq -> jumpTo , $ arrRoot ) ) { continue ; } if ( ! isset ( $ arrProcessed [ $ objFaq -> jumpTo ] ) ) { $ objParent = PageModel :: findWithDetails ( $ objFaq -> jumpTo ) ; if ( $ objParent === null ) { continue ; } if ( ! $ objParent -> published || ( $ objParent -> start != '' && $ objParent -> start > $ time ) || ( $ objParent -> stop != '' && $ objParent -> stop <= ( $ time + 60 ) ) ) { continue ; } if ( $ blnIsSitemap ) { if ( $ objParent -> protected ) { continue ; } if ( $ objParent -> sitemap == 'map_never' ) { continue ; } } $ arrProcessed [ $ objFaq -> jumpTo ] = $ objParent -> getAbsoluteUrl ( Config :: get ( 'useAutoItem' ) ? '/%s' : '/items/%s' ) ; } $ strUrl = $ arrProcessed [ $ objFaq -> jumpTo ] ; $ objItems = FaqModel :: findPublishedByPid ( $ objFaq -> id ) ; if ( $ objItems !== null ) { while ( $ objItems -> next ( ) ) { $ arrPages [ ] = sprintf ( preg_replace ( '/%(?!s)/' , '%%' , $ strUrl ) , ( $ objItems -> alias ? : $ objItems -> id ) ) ; } } } } return $ arrPages ; }
10417	public function startPipeline ( $ prefix , $ target ) { if ( $ target === null ) { $ target = 'default' ; } $ this -> getPipelineFactory ( ) -> create ( $ prefix . $ target ) -> start ( ) ; }
9610	public function getRouteUrl ( $ name , array $ params = array ( ) , $ relative = false ) { $ route = $ this -> router -> getRoute ( $ name ) ; $ routeParams = [ ] ; $ query = [ ] ; foreach ( $ params as $ key => $ value ) { if ( is_int ( $ key ) ) { $ routeParams [ ] = $ value ; } else { $ query [ $ key ] = $ value ; } } $ path = $ this -> routePathGenerator -> getRoutePath ( $ route , $ routeParams ) ; if ( $ query ) { $ path .= '?' . http_build_query ( $ query ) ; } if ( $ relative ) { $ root = $ this -> requests -> getCurrentRequest ( ) -> getBaseUrl ( ) ; } else { $ root = $ this -> getRootUrl ( ) ; } return $ root . $ path ; }
162	public function addParams ( $ params ) { if ( ! empty ( $ params ) ) { if ( empty ( $ this -> params ) ) { $ this -> params = $ params ; } else { foreach ( $ params as $ name => $ value ) { if ( is_int ( $ name ) ) { $ this -> params [ ] = $ value ; } else { $ this -> params [ $ name ] = $ value ; } } } } return $ this ; }
7681	function TbsPrepareMergeCell ( & $ Txt , & $ Loc ) { if ( $ this -> ExtEquiv == 'docx' ) { $ xml = clsTbsXmlLoc :: FindStartTag ( $ Txt , 'w:tcPr' , $ Loc -> PosBeg , false ) ; if ( $ xml ) { $ Txt = substr_replace ( $ Txt , '' , $ Loc -> PosBeg , $ Loc -> PosEnd - $ Loc -> PosBeg + 1 ) ; $ Loc -> PosBeg = $ xml -> PosEnd + 1 ; $ Loc -> PosEnd = $ xml -> PosEnd ; $ this -> PrevVals [ $ Loc -> FullName ] = '' ; $ Loc -> ConvStr = false ; } } }
6421	public static function ands ( callable ... $ predicates ) : callable { return function ( $ element ) use ( $ predicates ) { foreach ( $ predicates as $ predicate ) { if ( ! self :: call ( $ predicate , $ element ) ) { return false ; } } return true ; } ; }
10169	public function write ( Spreadsheet $ spreadsheet = null ) { $ objWriter = null ; if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' ) ; $ objWriter -> startElement ( 'office:document-settings' ) ; $ objWriter -> writeAttribute ( 'xmlns:office' , 'urn:oasis:names:tc:opendocument:xmlns:office:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:xlink' , 'http://www.w3.org/1999/xlink' ) ; $ objWriter -> writeAttribute ( 'xmlns:config' , 'urn:oasis:names:tc:opendocument:xmlns:config:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:ooo' , 'http://openoffice.org/2004/office' ) ; $ objWriter -> writeAttribute ( 'office:version' , '1.2' ) ; $ objWriter -> startElement ( 'office:settings' ) ; $ objWriter -> startElement ( 'config:config-item-set' ) ; $ objWriter -> writeAttribute ( 'config:name' , 'ooo:view-settings' ) ; $ objWriter -> startElement ( 'config:config-item-map-indexed' ) ; $ objWriter -> writeAttribute ( 'config:name' , 'Views' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'config:config-item-set' ) ; $ objWriter -> writeAttribute ( 'config:name' , 'ooo:configuration-settings' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
6256	public function searchPickupPointsByText ( $ query_text , $ service_provider = null , $ limit = 5 ) { if ( $ query_text == null || trim ( $ query_text ) == '' ) { return '[]' ; } $ post_params = array ( 'query' => ( string ) $ query_text , 'service_provider' => ( string ) $ service_provider , 'limit' => ( int ) $ limit ) ; return $ this -> doPost ( '/pickup-points/search' , $ post_params ) ; }
10618	public function steptwo ( ) { $ input = Input :: only ( array ( 'name' , 'email' , 'comment' , 'to_email' , 'to_name' ) ) ; $ input [ 'name' ] = $ this -> quickSanitize ( $ input [ 'name' ] ) ; $ input [ 'email' ] = $ this -> quickSanitize ( $ input [ 'email' ] ) ; $ input [ 'comment' ] = $ this -> quickSanitize ( $ input [ 'comment' ] ) ; return view ( 'lasallecmscontact::step_two_form' , [ 'input' => $ input , 'message' => false , ] ) ; }
11017	public function run ( ) { $ event = new BeforeControllerRunEvent ( ) ; $ this -> dispatcher -> fire ( Events :: EVENT_BEFORE_CONTROLLER_RUN , $ event ) ; $ action = $ this -> action -> getName ( ) ; if ( $ this -> action -> hasParams ( ) ) { call_user_func_array ( [ $ this , $ action ] , $ this -> action -> getParams ( ) ) ; } else { $ this -> $ action ( ) ; } $ event = new AfterControllerRunEvent ( ) ; $ this -> dispatcher -> fire ( Events :: EVENT_AFTER_CONTROLLER_RUN , $ event ) ; }
8712	public function whereTranslated ( $ column , $ operator = null , $ value = null , $ boolean = 'and' ) { if ( func_num_args ( ) == 2 ) { list ( $ value , $ operator ) = [ $ operator , '=' ] ; } elseif ( $ this -> invalidOperatorAndValue ( $ operator , $ value ) ) { throw new InvalidArgumentException ( 'Illegal operator and value combination.' ) ; } if ( ! in_array ( strtolower ( $ operator ) , $ this -> operators , true ) ) { list ( $ value , $ operator ) = [ $ operator , '=' ] ; } $ fallbackColumn = $ this -> qualifyTranslationColumn ( $ column , true ) ; $ column = $ this -> qualifyTranslationColumn ( $ column ) ; if ( ! $ this -> model -> shouldFallback ( ) || $ column instanceof Closure ) { return $ this -> where ( $ column , $ operator , $ value , $ boolean ) ; } $ condition = $ this -> compileIfNull ( $ column , $ fallbackColumn ) ; return $ this -> whereRaw ( "$condition $operator ?" , [ $ value ] , $ boolean ) ; }
7057	public function hasData ( $ key = null ) { if ( ! is_null ( $ key ) ) { return isset ( $ this -> data [ $ key ] ) ; } return ! empty ( $ this -> data ) ; }
4769	public function run ( ) { if ( ! $ this -> is_debug ( ) || ! $ this -> is_debug_display ( ) ) { return ; } $ run = $ this [ 'run' ] ; $ run -> register ( ) ; ob_start ( ) ; }
1101	protected function parentId ( ) { switch ( $ this -> position ) { case 'root' : return NULL ; case 'child' : return $ this -> target -> getKey ( ) ; default : return $ this -> target -> getParentId ( ) ; } }
1216	public static function stableSort ( array $ data , callable $ sortFn ) { array_walk ( $ data , function ( & $ v , $ k ) { $ v = [ $ v , $ k ] ; } ) ; uasort ( $ data , function ( $ a , $ b ) use ( $ sortFn ) { return $ sortFn ( $ a [ 0 ] , $ b [ 0 ] ) ? : ( $ a [ 1 ] < $ b [ 1 ] ? - 1 : 1 ) ; } ) ; return array_map ( function ( $ v ) { return $ v [ 0 ] ; } , array_values ( $ data ) ) ; }
5650	private function parseArgument ( & $ arguments ) { $ argument = array_shift ( $ arguments ) ; if ( preg_match ( '/^-(\w)=(.+)$/' , $ argument , $ matches ) ) { return array ( $ matches [ 1 ] , $ matches [ 2 ] ) ; } elseif ( preg_match ( '/^-(\w)$/' , $ argument , $ matches ) ) { return array ( $ matches [ 1 ] , $ this -> nextNonFlagElseTrue ( $ arguments ) ) ; } elseif ( preg_match ( '/^--(\w+)=(.+)$/' , $ argument , $ matches ) ) { return array ( $ matches [ 1 ] , $ matches [ 2 ] ) ; } elseif ( preg_match ( '/^--(\w+)$/' , $ argument , $ matches ) ) { return array ( $ matches [ 1 ] , $ this -> nextNonFlagElseTrue ( $ arguments ) ) ; } }
11107	public function shouldThrottle ( APIRequest $ request ) : bool { $ item = $ this -> cacheItemPool -> getItem ( $ this -> deriveCacheKey ( $ request ) ) ; return $ item -> get ( ) >= $ this -> limit ; }
4913	public function add ( $ name , $ entities = null , array $ options = null ) { if ( $ name instanceof DependencyResult ) { return $ this -> addResult ( $ name ) ; } if ( $ name instanceof \ Traversable ) { return $ this -> addTraversable ( $ name ) ; } if ( is_array ( $ name ) ) { return $ this -> addArray ( $ name ) ; } if ( null === $ entities ) { throw new \ UnexpectedValueException ( '$entities must not be null.' ) ; } return $ this -> addArray ( [ 'name' => $ name , 'entities' => $ entities , 'options' => $ options , ] ) ; }
3180	public function useClientContainer ( ) { if ( $ this -> hasOption ( self :: OPTION_CLIENT_TESTRUNNER ) ) { return $ this -> getOption ( self :: OPTION_CLIENT_TESTRUNNER ) ; } else { $ itemModel = $ this -> getServiceLocator ( ) -> get ( ItemModel :: SERVICE_ID ) ; return $ itemModel -> getCompilerClass ( ) == QtiJsonItemCompiler :: class ; } }
4678	public function render ( string $ file , array $ data ) : void { if ( ! is_readable ( $ file ) ) { throw new Exception ( "Could not find template file: " . $ this -> template ) ; } $ di = $ this -> di ; $ app = null ; if ( $ di -> has ( "app" ) ) { $ app = $ di -> get ( "app" ) ; } extract ( $ data ) ; require $ file ; }
8513	public function listInboundShipments ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_ListInboundShipmentsRequest ) ) { $ request = new FBAInboundServiceMWS_Model_ListInboundShipmentsRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListInboundShipments' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_ListInboundShipmentsResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
6838	public function mapDatas ( $ kvs ) { foreach ( $ kvs as $ k => $ v ) { $ this -> mapData ( $ k , $ v ) ; } }
3290	public function join ( ) : Promise { if ( ! $ this -> handle ) { throw new StatusError ( "Process has not been started." ) ; } return $ this -> processRunner -> join ( $ this -> handle ) ; }
2727	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ service = $ this -> api -> checkServiceDetails ( ) ; $ currActiveVersion = $ this -> vcl -> determineVersions ( $ service -> versions ) ; $ snippet = $ this -> config -> getVclSnippets ( Config :: VCL_WAF_PATH , Config :: VCL_WAF_ALLOWLIST_SNIPPET ) ; $ acls = $ this -> prepareAcls ( $ this -> request -> getParam ( 'acls' ) ) ; $ allowedItems = $ acls ; $ strippedAllowedItems = substr ( $ allowedItems , 0 , strrpos ( $ allowedItems , '||' , - 1 ) ) ; foreach ( $ snippet as $ key => $ value ) { if ( $ strippedAllowedItems === '' ) { $ value = '' ; } else { $ value = str_replace ( '####WAF_ALLOWLIST####' , $ strippedAllowedItems , $ value ) ; } $ snippetName = Config :: FASTLY_MAGENTO_MODULE . '_waf_' . $ key ; $ snippetId = $ this -> api -> getSnippet ( $ currActiveVersion [ 'active_version' ] , $ snippetName ) -> id ; $ params = [ 'name' => $ snippetId , 'content' => $ value ] ; $ this -> api -> updateSnippet ( $ params ) ; } $ this -> cacheTypeList -> cleanType ( 'config' ) ; $ this -> systemConfig -> clean ( ) ; return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
1028	private function resolveField ( ObjectType $ parentType , $ source , $ fieldNodes , $ path ) { $ exeContext = $ this -> exeContext ; $ fieldNode = $ fieldNodes [ 0 ] ; $ fieldName = $ fieldNode -> name -> value ; $ fieldDef = $ this -> getFieldDef ( $ exeContext -> schema , $ parentType , $ fieldName ) ; if ( ! $ fieldDef ) { return self :: $ UNDEFINED ; } $ returnType = $ fieldDef -> getType ( ) ; $ info = new ResolveInfo ( $ fieldName , $ fieldNodes , $ returnType , $ parentType , $ path , $ exeContext -> schema , $ exeContext -> fragments , $ exeContext -> rootValue , $ exeContext -> operation , $ exeContext -> variableValues ) ; if ( $ fieldDef -> resolveFn !== null ) { $ resolveFn = $ fieldDef -> resolveFn ; } elseif ( $ parentType -> resolveFieldFn !== null ) { $ resolveFn = $ parentType -> resolveFieldFn ; } else { $ resolveFn = $ this -> exeContext -> fieldResolver ; } $ context = $ exeContext -> contextValue ; $ result = $ this -> resolveOrError ( $ fieldDef , $ fieldNode , $ resolveFn , $ source , $ context , $ info ) ; $ result = $ this -> completeValueCatchingError ( $ returnType , $ fieldNodes , $ info , $ path , $ result ) ; return $ result ; }
12821	private function resolveDependencies ( callable $ callback , array $ vars ) : array { $ method = new \ ReflectionMethod ( $ callback [ 0 ] , $ callback [ 1 ] ) ; $ dependencies = [ ] ; foreach ( $ method -> getParameters ( ) as $ parameter ) { if ( $ parameter -> getClass ( ) === null && ! count ( $ vars ) ) { break ; } if ( $ parameter -> getClass ( ) === null && count ( $ vars ) ) { $ dependencies [ ] = array_shift ( $ vars ) ; continue ; } $ dependencies [ ] = $ this -> injector -> make ( $ parameter -> getClass ( ) -> name ) ; } return $ dependencies ; }
6721	private function handleTokenResponse ( $ response ) { $ params = ( $ response instanceof OAuthToken ) ? $ response -> getParams ( ) : $ response ; $ status = ArrayHelper :: getValue ( $ params , 'status' ) ; if ( ! is_null ( $ status ) && $ status == 'success' ) { $ token = ArrayHelper :: getValue ( $ params , 'data' ) ; if ( is_null ( $ token ) ) { throw new Oauth2ClientException ( self :: CODE_NOT_SET ) ; } return $ token ; } else { $ message = ArrayHelper :: getValue ( $ params , 'message' , self :: DEFAULT_ERROR ) ; throw new Oauth2ClientException ( $ message ) ; } }
404	public function prepareHeaders ( $ requestHeaders ) { $ responseHeaders = [ ] ; if ( isset ( $ requestHeaders [ 'Origin' ] , $ this -> cors [ 'Origin' ] ) ) { if ( in_array ( $ requestHeaders [ 'Origin' ] , $ this -> cors [ 'Origin' ] , true ) ) { $ responseHeaders [ 'Access-Control-Allow-Origin' ] = $ requestHeaders [ 'Origin' ] ; } if ( in_array ( '*' , $ this -> cors [ 'Origin' ] , true ) ) { if ( isset ( $ this -> cors [ 'Access-Control-Allow-Credentials' ] ) && $ this -> cors [ 'Access-Control-Allow-Credentials' ] ) { if ( YII_DEBUG ) { throw new InvalidConfigException ( "Allowing credentials for wildcard origins is insecure. Please specify more restrictive origins or set 'credentials' to false in your CORS configuration." ) ; } else { Yii :: error ( "Allowing credentials for wildcard origins is insecure. Please specify more restrictive origins or set 'credentials' to false in your CORS configuration." , __METHOD__ ) ; } } else { $ responseHeaders [ 'Access-Control-Allow-Origin' ] = '*' ; } } } $ this -> prepareAllowHeaders ( 'Headers' , $ requestHeaders , $ responseHeaders ) ; if ( isset ( $ requestHeaders [ 'Access-Control-Request-Method' ] ) ) { $ responseHeaders [ 'Access-Control-Allow-Methods' ] = implode ( ', ' , $ this -> cors [ 'Access-Control-Request-Method' ] ) ; } if ( isset ( $ this -> cors [ 'Access-Control-Allow-Credentials' ] ) ) { $ responseHeaders [ 'Access-Control-Allow-Credentials' ] = $ this -> cors [ 'Access-Control-Allow-Credentials' ] ? 'true' : 'false' ; } if ( isset ( $ this -> cors [ 'Access-Control-Max-Age' ] ) && $ this -> request -> getIsOptions ( ) ) { $ responseHeaders [ 'Access-Control-Max-Age' ] = $ this -> cors [ 'Access-Control-Max-Age' ] ; } if ( isset ( $ this -> cors [ 'Access-Control-Expose-Headers' ] ) ) { $ responseHeaders [ 'Access-Control-Expose-Headers' ] = implode ( ', ' , $ this -> cors [ 'Access-Control-Expose-Headers' ] ) ; } if ( isset ( $ this -> cors [ 'Access-Control-Allow-Headers' ] ) ) { $ responseHeaders [ 'Access-Control-Allow-Headers' ] = implode ( ', ' , $ this -> cors [ 'Access-Control-Allow-Headers' ] ) ; } return $ responseHeaders ; }
2378	public static function specialchars ( $ strString , $ blnStripInsertTags = false , $ blnDoubleEncode = false ) { if ( $ blnStripInsertTags ) { $ strString = static :: stripInsertTags ( $ strString ) ; } return htmlspecialchars ( $ strString , ENT_COMPAT , Config :: get ( 'characterSet' ) , $ blnDoubleEncode ) ; }
5913	public function addUserToGroup ( $ id , array $ groupIds ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'groupIds' => $ groupIds ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/accounts/users/' . $ id . '/groups' , $ parameters ) ; $ result = new User ( $ result ) ; return $ result ; }
11780	public function fromDbToEntity ( array $ data ) { $ hydratorFactory = $ this -> documentManager -> getHydratorFactory ( ) ; $ documentClass = $ this -> documentClass ; $ document = new $ documentClass ( ) ; $ hydratorFactory -> hydrate ( $ document , $ data ) ; return $ document ; }
6199	protected function transformParam ( $ param , $ k ) { if ( isset ( $ this -> routeMapParse [ $ k ] [ $ param ] ) and ! is_array ( $ this -> routeMapParse [ $ k ] [ $ param ] ) ) { return $ this -> routeMapParse [ $ k ] [ $ param ] ; } else { return '(.+?)' ; } }
7471	public function createAction ( Request $ request ) { $ user = new User ( ) ; $ form = $ this -> createForm ( UserType :: class , $ user ) ; $ form -> bind ( $ request ) ; if ( $ form -> isValid ( ) ) { $ factory = $ this -> get ( 'security.encoder_factory' ) ; $ encoder = $ factory -> getEncoder ( $ user ) ; $ user -> setPassword ( $ encoder -> encodePassword ( $ user -> getPassword ( ) , $ user -> getSalt ( ) ) ) ; $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ em -> persist ( $ user ) ; $ em -> flush ( ) ; $ this -> get ( 'session' ) -> getFlashBag ( ) -> set ( 'success' , 'The user has been created.' ) ; return $ this -> redirect ( $ this -> generateUrl ( 'orkestra_user_show' , array ( 'id' => $ user -> getId ( ) ) ) ) ; } return array ( 'user' => $ user , 'form' => $ form -> createView ( ) ) ; }
2633	public function execute ( ) { $ output = $ this -> layoutFactory -> create ( ) -> createBlock ( 'Fastly\Cdn\Block\Dashboard\Tab\Stats\Historic' ) -> toHtml ( ) ; $ resultRaw = $ this -> resultRawFactory -> create ( ) ; return $ resultRaw -> setContents ( $ output ) ; }
8042	protected function calculateEventLength ( array $ data ) { $ start = $ this -> carbon -> copy ( ) -> setTimestamp ( strtotime ( $ data [ 'start' ] [ 'date' ] . ' ' . $ data [ 'start' ] [ 'time' ] ) ) ; if ( array_key_exists ( 'all_day' , $ data ) ) { $ end = $ this -> carbon -> copy ( ) -> setTimestamp ( strtotime ( $ data [ 'start' ] [ 'date' ] . ' 23:59:59' ) ) ; } else { $ end = $ this -> carbon -> copy ( ) -> setTimestamp ( strtotime ( $ data [ 'start' ] [ 'date' ] . ' ' . $ data [ 'end' ] [ 'time' ] ) ) ; } return $ start -> diffInSeconds ( $ end ) ; }
455	public function dropColumn ( $ table , $ column ) { return 'ALTER TABLE ' . $ this -> db -> quoteTableName ( $ table ) . ' DROP COLUMN ' . $ this -> db -> quoteColumnName ( $ column ) ; }
3563	protected function getMutator ( $ value , $ dir = 'setter' , $ type = null ) { $ type = $ type ? : $ this -> getValueType ( $ value ) ; foreach ( $ this -> { "{$dir}Mutators" } as $ mutated => $ mutator ) { if ( $ type == $ mutated || $ value instanceof $ mutated ) { return $ mutator ; } } }
8822	public function rules ( Array $ rules ) { foreach ( $ rules as $ key => $ value ) { $ this -> rule ( $ key , $ value [ 'label' ] , $ value [ 'rules' ] , isset ( $ value [ 'text' ] ) && ! empty ( $ value [ 'text' ] ) ? $ value [ 'text' ] : [ ] ) ; } }
3582	protected function metaSelectListsKey ( Builder $ query , $ key ) { if ( strpos ( $ key , '.' ) !== false ) { return $ query -> addSelect ( $ key ) ; } elseif ( $ this -> hasColumn ( $ key ) ) { return $ query -> addSelect ( $ this -> getTable ( ) . '.' . $ key ) ; } $ alias = $ this -> joinMeta ( $ query , $ key ) ; return $ query -> addSelect ( "{$alias}.meta_value as {$key}" ) ; }
2586	protected function loadBare ( PnrAddMultiElementsOptions $ params ) { $ tattooCounter = 0 ; if ( ! is_null ( $ params -> actionCode ) ) { $ this -> pnrActions = new AddMultiElements \ PnrActions ( $ params -> actionCode ) ; } if ( ! is_null ( $ params -> recordLocator ) ) { $ this -> reservationInfo = new AddMultiElements \ ReservationInfo ( $ params -> recordLocator ) ; } if ( $ params -> travellerGroup !== null ) { $ this -> addTravellerGroup ( $ params -> travellerGroup ) ; } else { $ this -> addTravellers ( $ params -> travellers ) ; } $ this -> addItineraries ( $ params -> itineraries , $ params -> tripSegments , $ tattooCounter ) ; if ( ! empty ( $ params -> elements ) ) { $ this -> addElements ( $ params -> elements , $ tattooCounter , $ params -> autoAddReceivedFrom , $ params -> defaultReceivedFrom , $ params -> receivedFrom ) ; } else { $ this -> addReceivedFrom ( $ params -> receivedFrom , $ params -> autoAddReceivedFrom , $ params -> defaultReceivedFrom , $ tattooCounter ) ; } }
1241	private static function encodeValueXml ( $ value ) { if ( $ value instanceof \ DateTime ) { return $ value -> format ( 'Y-m-d\TH:i:s.000\Z' ) ; } elseif ( is_bool ( $ value ) ) { return $ value ? 'true' : 'false' ; } else { return htmlspecialchars ( $ value , ENT_QUOTES , 'UTF-8' , true ) ; } }
2711	public function execute ( ) { $ result = $ this -> resultJsonFactory -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ dictionaryName = Config :: AUTH_DICTIONARY_NAME ; $ dictionary = $ this -> api -> getSingleDictionary ( $ activeVersion , $ dictionaryName ) ; if ( ( is_array ( $ dictionary ) && empty ( $ dictionary ) ) || $ dictionary == false || ! isset ( $ dictionary -> id ) ) { return $ result -> setData ( [ 'status' => 'empty' , 'msg' => 'Basic Authentication cannot be enabled because there are no users assigned to it.' ] ) ; } else { $ authItems = $ this -> api -> dictionaryItemsList ( $ dictionary -> id ) ; if ( is_array ( $ authItems ) && empty ( $ authItems ) ) { return $ result -> setData ( [ 'status' => 'empty' , 'msg' => 'Basic Authentication cannot be enabled because there are no users assigned to it.' ] ) ; } return $ result -> setData ( [ 'status' => true ] ) ; } } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
1018	private function arrayMergeDeep ( array $ array1 , array $ array2 ) : array { $ merged = $ array1 ; foreach ( $ array2 as $ key => & $ value ) { if ( is_numeric ( $ key ) ) { if ( ! in_array ( $ value , $ merged , true ) ) { $ merged [ ] = $ value ; } } elseif ( is_array ( $ value ) && isset ( $ merged [ $ key ] ) && is_array ( $ merged [ $ key ] ) ) { $ merged [ $ key ] = $ this -> arrayMergeDeep ( $ merged [ $ key ] , $ value ) ; } else { $ merged [ $ key ] = $ value ; } } return $ merged ; }
8050	public function getCalendarEvent ( $ id ) { $ calendarEvent = null ; $ cache = $ this -> cache ; if ( $ cache :: has ( self :: CACHE_KEY . $ id ) ) { return $ cache :: get ( self :: CACHE_KEY . $ id ) ; } $ calendarEvent = $ this -> calendarEvent -> with ( [ 'calendarEventRepeatDates' ] ) -> where ( 'id' , $ id ) -> firstOrFail ( ) ; $ cache :: put ( self :: CACHE_KEY . $ id , $ calendarEvent , $ this -> cacheTimeToLive ) ; return $ calendarEvent ; }
898	private function isOfLowerPrecedence ( Token $ token ) { static $ tokens ; if ( null === $ tokens ) { $ tokens = [ T_AND_EQUAL , T_BOOLEAN_AND , T_BOOLEAN_OR , T_CASE , T_CONCAT_EQUAL , T_DIV_EQUAL , T_DOUBLE_ARROW , T_GOTO , T_LOGICAL_AND , T_LOGICAL_OR , T_LOGICAL_XOR , T_MINUS_EQUAL , T_MUL_EQUAL , T_OR_EQUAL , T_PLUS_EQUAL , T_RETURN , T_SL_EQUAL , T_SR_EQUAL , T_THROW , T_XOR_EQUAL , T_ECHO , T_PRINT , T_OPEN_TAG , T_OPEN_TAG_WITH_ECHO , ] ; if ( \ defined ( 'T_POW_EQUAL' ) ) { $ tokens [ ] = T_POW_EQUAL ; } if ( \ defined ( 'T_COALESCE' ) ) { $ tokens [ ] = T_COALESCE ; } } static $ otherTokens = [ '&' , '|' , '^' , '?' , ':' , '=' , ',' , ';' , ] ; return $ token -> isGivenKind ( $ tokens ) || $ token -> equalsAny ( $ otherTokens ) ; }
4538	public function setTenantId ( ? string $ tenantId ) { $ this -> tenantId = $ tenantId ; $ this -> _tenantId = null !== $ tenantId ; return $ this ; }
7986	public function getModels ( $ domain ) { $ domain = ( string ) $ domain ; if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; try { $ r = $ this -> get ( 'vps/' . $ domain . '/models' ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new VpsException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
5253	public static function findOrFail ( $ id , array $ columns = [ '*' ] , $ parent = null ) { $ model = static :: find ( $ id , $ columns , [ 'parent' => $ parent ] ) ; if ( is_null ( $ model ) ) { throw new ModelNotFoundException ( get_called_class ( ) , $ id ) ; } return $ model ; }
2449	public function editComment ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { return $ this -> isAllowedToEditComment ( $ row [ 'parent' ] , $ row [ 'source' ] ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : Contao \ Image :: getHtml ( preg_replace ( '/\.svg/i' , '_.svg' , $ icon ) ) . ' ' ; }
12971	public function seek ( $ position ) { if ( ! array_key_exists ( $ position , $ this -> elements ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Position %s does not exist in collection' , $ position ) ) ; } reset ( $ this -> elements ) ; while ( key ( $ this -> elements ) !== $ position ) { next ( $ this -> elements ) ; } }
2872	public function init ( Mage_Core_Model_Abstract $ model ) { $ this -> class = get_class ( $ model ) ; $ this -> resource = $ model -> getResourceName ( ) ; $ this -> count = 0 ; }
497	public function calculateTimings ( $ messages ) { $ timings = [ ] ; $ stack = [ ] ; foreach ( $ messages as $ i => $ log ) { list ( $ token , $ level , $ category , $ timestamp , $ traces ) = $ log ; $ memory = isset ( $ log [ 5 ] ) ? $ log [ 5 ] : 0 ; $ log [ 6 ] = $ i ; $ hash = md5 ( json_encode ( $ token ) ) ; if ( $ level == self :: LEVEL_PROFILE_BEGIN ) { $ stack [ $ hash ] = $ log ; } elseif ( $ level == self :: LEVEL_PROFILE_END ) { if ( isset ( $ stack [ $ hash ] ) ) { $ timings [ $ stack [ $ hash ] [ 6 ] ] = [ 'info' => $ stack [ $ hash ] [ 0 ] , 'category' => $ stack [ $ hash ] [ 2 ] , 'timestamp' => $ stack [ $ hash ] [ 3 ] , 'trace' => $ stack [ $ hash ] [ 4 ] , 'level' => count ( $ stack ) - 1 , 'duration' => $ timestamp - $ stack [ $ hash ] [ 3 ] , 'memory' => $ memory , 'memoryDiff' => $ memory - ( isset ( $ stack [ $ hash ] [ 5 ] ) ? $ stack [ $ hash ] [ 5 ] : 0 ) , ] ; unset ( $ stack [ $ hash ] ) ; } } } ksort ( $ timings ) ; return array_values ( $ timings ) ; }
725	public function render ( $ view , $ params = [ ] ) { $ content = $ this -> getView ( ) -> render ( $ view , $ params , $ this ) ; return $ this -> renderContent ( $ content ) ; }
5989	public function setProperties ( array $ properties ) { $ this -> properties = [ ] ; foreach ( $ properties as $ item ) { $ this -> addPropertyCriteria ( $ item ) ; } return $ this ; }
9126	private function requestImpl ( string $ requestType ) { if ( $ requestType == 'HEAD' ) { $ this -> setTimeout ( 1 ) ; } $ ms = $ this -> prepareRequest ( $ requestType ) ; $ ms = $ this -> appendPayloadToRequest ( $ ms ) ; if ( ! $ this -> isConnected ( ) ) { $ this -> connect ( ) ; } while ( $ ms -> ready ( ) ) { $ this -> write ( $ ms -> read ( 1024 ) ) ; } $ this -> retrieveAndParseResponse ( $ requestType ) ; if ( $ this -> getHeader ( 'Connection' ) == 'close' ) { $ this -> disconnect ( ) ; } }
4813	public function get ( $ name , $ default = null ) { return array_key_exists ( $ name , $ this -> storage ) ? $ this -> storage [ $ name ] : $ default ; }
10276	public static function getTextWidthPixelsApprox ( $ columnText , \ PhpOffice \ PhpSpreadsheet \ Style \ Font $ font , $ rotation = 0 ) { $ fontName = $ font -> getName ( ) ; $ fontSize = $ font -> getSize ( ) ; switch ( $ fontName ) { case 'Calibri' : $ columnWidth = ( int ) ( 8.26 * StringHelper :: countCharacters ( $ columnText ) ) ; $ columnWidth = $ columnWidth * $ fontSize / 11 ; break ; case 'Arial' : $ columnWidth = ( int ) ( 8 * StringHelper :: countCharacters ( $ columnText ) ) ; $ columnWidth = $ columnWidth * $ fontSize / 10 ; break ; case 'Verdana' : $ columnWidth = ( int ) ( 8 * StringHelper :: countCharacters ( $ columnText ) ) ; $ columnWidth = $ columnWidth * $ fontSize / 10 ; break ; default : $ columnWidth = ( int ) ( 8.26 * StringHelper :: countCharacters ( $ columnText ) ) ; $ columnWidth = $ columnWidth * $ fontSize / 11 ; break ; } if ( $ rotation !== 0 ) { if ( $ rotation == - 165 ) { $ columnWidth = 4 ; } else { $ columnWidth = $ columnWidth * cos ( deg2rad ( $ rotation ) ) + $ fontSize * abs ( sin ( deg2rad ( $ rotation ) ) ) / 5 ; } } return ( int ) $ columnWidth ; }
10747	protected function sendItems ( Response $ response , iterable $ items , ? Pagination $ pagination = null , ? int $ total = null ) : Response { $ items = is_array ( $ items ) ? $ items : ( $ items instanceof \ Traversable ? iterator_to_array ( $ items , false ) : [ ] ) ; $ total = $ total ?? count ( $ items ) ; $ start = $ pagination === null ? 0 : $ pagination -> getOffset ( ) ; $ max = $ pagination === null ? 0 : $ pagination -> getMax ( ) ; $ end = max ( min ( ( PHP_INT_MAX - $ max < $ start ? PHP_INT_MAX : $ start + $ max ) , $ total ) - 1 , 0 ) ; return $ this -> sendJson ( $ response -> withHeader ( 'Content-Range' , "items $start-$end/$total" ) , $ items ) ; }
2632	public function sendPurgeRequest ( $ pattern = '' ) { if ( empty ( $ pattern ) ) { if ( $ this -> config -> canPreserveStatic ( ) ) { $ result = $ this -> api -> cleanBySurrogateKey ( [ 'text' ] ) ; } else { $ result = $ this -> api -> cleanAll ( ) ; } } elseif ( ! is_array ( $ pattern ) && strpos ( $ pattern , 'http' ) === 0 ) { $ result = $ this -> api -> cleanUrl ( $ pattern ) ; } elseif ( is_array ( $ pattern ) ) { $ result = $ this -> api -> cleanBySurrogateKey ( $ pattern ) ; } else { return false ; } return $ result ; }
12703	public function publishAction ( Request $ request , Application $ app ) { $ options = array ( "request" => $ request , "page_manager" => $ app [ "red_kite_cms.page_manager" ] , "username" => $ this -> fetchUsername ( $ app [ "security" ] , $ app [ "red_kite_cms.configuration_handler" ] ) , ) ; return parent :: publish ( $ options ) ; }
4578	public function start ( $ id , Parameters $ parameters = null ) { if ( null !== $ id ) { $ resource = str_replace ( '{id}' , $ id , static :: RESOURCE_OBJECT_START ) ; } else { $ key = $ parameters -> getKey ( ) ; $ tenantId = $ parameters -> getTenantId ( ) ; switch ( true ) { case null !== $ key && null !== $ tenantId : $ resource = str_replace ( [ '{key}' , '{tenant-id}' ] , [ $ key , $ tenantId ] , static :: RESOURCE_OBJECT_START_BY_KEY_AND_TENANT_ID ) ; break ; case null !== $ key : $ resource = str_replace ( '{key}' , $ key , static :: RESOURCE_OBJECT_START_BY_KEY ) ; break ; default : throw new LogicException ( '"Key" and/or "TenantId" parameters are not defined.' ) ; } } $ options = [ 'headers' => [ 'Accept' => 'application/json' , 'Content-Type' => 'application/json' ] ] ; if ( $ parameters ) { $ parameters = ( array ) $ parameters -> toObject ( true ) ; foreach ( $ parameters as $ name => $ value ) { switch ( $ name ) { case 'variables' : foreach ( $ value as $ variable ) { $ options [ 'json' ] [ $ name ] [ $ variable -> name ] = [ 'value' => Variable :: TYPE_JSON === $ variable -> type ? json_encode ( $ variable -> value ) : $ variable -> value , 'type' => $ variable -> type ] ; } break ; case 'key' : break ; default : $ options [ 'json' ] [ $ name ] = $ value ; } } } $ object = $ this -> execute ( 'POST' , $ resource , $ options ) ; $ model = ProcessInstanceService :: toModel ( $ object ) ; return $ model ; }
12089	public function destroy ( UserPolicy $ user , Response $ response ) { return $ response -> user_id == user_id ( ) && $ response -> user_type == user_type ( ) ; }
10855	public function getLocationString ( ) { $ normalized = '' ; if ( $ this -> city !== null ) { $ normalized .= $ this -> city -> name ; } if ( $ this -> region !== null ) { $ normalized .= ' ' . $ this -> region -> name ; } if ( $ this -> postal_code !== null ) { $ normalized .= ' ' . $ this -> postal_code ; } return $ normalized ; }
8233	public function getToken ( $ action = null , $ reuse = true ) { $ tokenStorage = $ this -> session -> get ( self :: SESSION_KEY , [ ] ) ; $ index = ( $ action ) ? $ action : self :: DEFAULT_SELECTOR ; if ( ! isset ( $ tokenStorage [ $ index ] ) ) { $ token = bin2hex ( random_bytes ( self :: TOKEN_SIZE ) ) ; $ tokenStorage [ $ index ] = array ( 'time' => time ( ) , 'token' => $ token ) ; } else { $ token = $ tokenStorage [ $ index ] [ 'token' ] ; $ tokenStorage [ $ index ] [ 'time' ] = time ( ) ; } $ tokenStorage [ $ index ] [ 'reuse' ] = $ reuse ; $ key = bin2hex ( random_bytes ( self :: TOKEN_SIZE ) ) ; $ tokenHMAC = $ this -> tokenHMAC ( $ token , $ key ) ; $ this -> session -> set ( self :: SESSION_KEY , $ tokenStorage ) ; return $ key . self :: TOKEN_DELIMTER . $ tokenHMAC ; }
4287	public function getSubscriptions ( ) { if ( ! $ this -> isConnected ( ) ) { $ this -> debug -> alert ( 'WAMP publisher not connected to WAMP router' ) ; return array ( ) ; } $ this -> publishMeta ( ) ; $ this -> processExistingData ( ) ; return array ( 'debug.log' => array ( 'onLog' , PHP_INT_MAX * - 1 ) , 'errorHandler.error' => 'onError' , 'php.shutdown' => array ( 'onShutdown' , PHP_INT_MAX * - 1 ) , ) ; }
7584	protected function extractResponse ( $ curlResponse ) { $ this -> headers = substr ( $ curlResponse , 0 , $ this -> info [ 'header_size' ] ) ; $ this -> body = substr ( $ curlResponse , $ this -> info [ 'header_size' ] ) ; }
2466	protected function welcomeScreen ( ) { System :: loadLanguageFile ( 'explain' ) ; $ objTemplate = new BackendTemplate ( 'be_welcome' ) ; $ objTemplate -> messages = Message :: generateUnwrapped ( ) . Backend :: getSystemMessages ( ) ; $ objTemplate -> loginMsg = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'firstLogin' ] ; if ( $ this -> User -> lastLogin > 0 ) { $ formatter = new DateTimeFormatter ( System :: getContainer ( ) -> get ( 'translator' ) ) ; $ diff = $ formatter -> formatDiff ( new \ DateTime ( date ( 'Y-m-d H:i:s' , $ this -> User -> lastLogin ) ) , new \ DateTime ( ) ) ; $ objTemplate -> loginMsg = sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'lastLogin' ] [ 1 ] , '<time title="' . Date :: parse ( Config :: get ( 'datimFormat' ) , $ this -> User -> lastLogin ) . '">' . $ diff . '</time>' ) ; } Versions :: addToTemplate ( $ objTemplate ) ; $ objTemplate -> showDifferences = StringUtil :: specialchars ( str_replace ( "'" , "\\'" , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'showDifferences' ] ) ) ; $ objTemplate -> recordOfTable = StringUtil :: specialchars ( str_replace ( "'" , "\\'" , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'recordOfTable' ] ) ) ; $ objTemplate -> systemMessages = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'systemMessages' ] ; $ objTemplate -> shortcuts = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'shortcuts' ] [ 0 ] ; $ objTemplate -> shortcutsLink = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'shortcuts' ] [ 1 ] ; $ objTemplate -> editElement = StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'editElement' ] ) ; return $ objTemplate -> parse ( ) ; }
8886	private function parseResult ( ) { if ( $ this -> xml_result -> Response -> ResponseStatusCode != '1' ) { return array ( 'Error' => array ( 'ErrorSeverity' => "{$this->xml_result->Response->Error->ErrorSeverity}" , 'ErrorCode' => "{$this->xml_result->Response->Error->ErrorCode}" , 'ErrorDescription' => "{$this->xml_result->Response->Error->ErrorDescription}" ) ) ; return $ this -> xml_result ; } $ simplified = array ( ) ; $ shipping_choices = array ( ) ; foreach ( $ this -> xml_result -> RatedShipment as $ service ) { $ simplified [ ] = '{' . $ service -> TotalCharges -> MonetaryValue . '}' ; } foreach ( $ simplified as $ key => $ value ) { $ service = $ this -> xml_result -> RatedShipment [ $ key ] -> children ( ) ; if ( $ this -> negotiated_rates && $ service -> NegotiatedRates -> NetSummaryCharges -> GrandTotal -> MonetaryValue ) { $ rate = number_format ( ( double ) ( $ service -> NegotiatedRates -> NetSummaryCharges -> GrandTotal -> MonetaryValue ) , 2 ) ; } else { $ rate = number_format ( ( double ) ( $ service -> TransportationCharges -> MonetaryValue ) , 2 ) ; } $ shipping_choices [ "{$service->Service->Code}" ] = array ( 'service' => $ this -> shipperCodes ( "{$service->Service->Code}" ) , 'rate' => "{$rate}" ) ; } return $ shipping_choices ; }
2264	public function tableExists ( $ strTable , $ strDatabase = null , $ blnNoCache = false ) { if ( $ strTable == '' ) { return false ; } return \ in_array ( $ strTable , $ this -> listTables ( $ strDatabase , $ blnNoCache ) ) ; }
2921	public function save ( $ filePath ) { $ this -> ensureFileIsWritable ( $ filePath ) ; file_put_contents ( $ filePath , $ this -> buffer ) ; return $ this ; }
1340	public function exists ( ResourceIdentifierInterface $ identifier ) { $ record = $ this -> lookup ( $ identifier ) ; return is_object ( $ record ) ? true : $ record ; }
5859	public function getAllDirectories ( ) { $ directories = [ ] ; foreach ( $ this -> rulesets as $ ruleset ) { $ dirs = GeneralUtility :: trimExplode ( ',' , $ ruleset [ 'directories_config' ] , true ) ; $ directories = array_merge ( $ directories , $ dirs ) ; } $ directories = array_unique ( $ directories ) ; asort ( $ directories ) ; return $ directories ; }
1971	public static function findMultipleByUuids ( $ arrUuids , array $ arrOptions = array ( ) ) { if ( empty ( $ arrUuids ) || ! \ is_array ( $ arrUuids ) ) { return null ; } $ t = static :: $ strTable ; foreach ( $ arrUuids as $ k => $ v ) { if ( Validator :: isStringUuid ( $ v ) ) { $ v = StringUtil :: uuidToBin ( $ v ) ; } $ arrUuids [ $ k ] = "UNHEX('" . bin2hex ( $ v ) . "')" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.uuid!=" . implode ( ", $t.uuid!=" , $ arrUuids ) ; } return static :: findBy ( array ( "$t.uuid IN(" . implode ( "," , $ arrUuids ) . ")" ) , null , $ arrOptions ) ; }
1440	protected function getResourceName ( ) { $ name = ucwords ( $ this -> getResourceInput ( ) ) ; if ( $ this -> isByResource ( ) ) { return str_plural ( $ name ) ; } return $ name ; }
5887	public function iconGetName ( $ key ) { $ iconid = ( $ this [ $ key ] < 0 ) ? ( pow ( 2 , 32 ) ) - ( $ this [ $ key ] * - 1 ) : $ this [ $ key ] ; return new StringHelper ( "/icon_" . $ iconid ) ; }
6491	protected function getInstance ( $ selector = '' ) { if ( empty ( $ this -> object ) ) { throw new \ RuntimeException ( 'Editor instance was not set.' ) ; } if ( empty ( $ this -> selector ) && empty ( $ selector ) ) { throw new \ RuntimeException ( 'No such editor was not selected.' ) ; } $ this -> setSelector ( $ selector ) ; if ( empty ( $ this -> instances [ $ this -> selector ] ) ) { $ instanceId = $ this -> context -> element ( 'field' , $ this -> selector ) -> getAttribute ( 'id' ) ; $ instance = sprintf ( $ this -> object , $ instanceId ) ; if ( ! $ this -> context -> executeJs ( "return !!$instance" ) ) { throw new \ Exception ( sprintf ( 'Editor "%s" was not found.' , $ instanceId ) ) ; } $ this -> instances [ $ this -> selector ] = $ instance ; } return $ this -> instances [ $ this -> selector ] ; }
2504	protected static function getMessagesAndVersionsFromImportedWsdl ( $ import , $ wsdlPath , $ wsdlIdentifier ) { $ msgAndVer = [ ] ; $ domXpath = null ; $ importPath = realpath ( dirname ( $ wsdlPath ) ) . DIRECTORY_SEPARATOR . $ import ; $ wsdlContent = file_get_contents ( $ importPath ) ; if ( $ wsdlContent !== false ) { $ domDoc = new \ DOMDocument ( '1.0' , 'UTF-8' ) ; $ ok = $ domDoc -> loadXML ( $ wsdlContent ) ; if ( $ ok === true ) { $ domXpath = new \ DOMXPath ( $ domDoc ) ; $ domXpath -> registerNamespace ( 'wsdl' , 'http://schemas.xmlsoap.org/wsdl/' ) ; $ domXpath -> registerNamespace ( 'soap' , 'http://schemas.xmlsoap.org/wsdl/soap/' ) ; } } else { throw new InvalidWsdlFileException ( 'WSDL ' . $ importPath . ' import could not be loaded' ) ; } if ( $ domXpath instanceof \ DOMXPath ) { $ nodeList = $ domXpath -> query ( self :: XPATH_ALL_OPERATIONS ) ; $ msgAndVer = array_merge ( $ msgAndVer , self :: loopOperationsWithQuery ( $ nodeList , self :: XPATH_ALT_VERSION_FOR_OPERATION , $ wsdlIdentifier , $ domXpath ) ) ; } return $ msgAndVer ; }
4315	protected function getGroupDepth ( ) { $ depth = 0 ; foreach ( $ this -> data [ 'groupStacks' ] as $ stack ) { $ depth += \ count ( $ stack ) ; } $ depth += \ count ( $ this -> data [ 'groupPriorityStack' ] ) ; return $ depth ; }
11660	public static function readFromString ( $ string ) { $ xml = new \ DOMDocument ( ) ; $ xml -> loadXML ( $ string ) ; $ result = [ ] ; $ props = $ xml -> childNodes -> item ( $ xml -> childNodes -> length - 1 ) -> childNodes ; for ( $ i = 0 ; $ i < $ props -> length ; $ i ++ ) { $ entry = $ props -> item ( $ i ) ; if ( $ entry -> nodeName == "entry" ) $ result [ $ entry -> attributes -> getNamedItem ( "key" ) -> nodeValue ] = $ entry -> textContent ; } return $ result ; }
3026	private function parseResponse ( $ response ) { $ response -> json = json_decode ( $ response -> body ) ; if ( $ response -> status < 400 ) { return $ response -> json -> response ; } else { throw new RequestException ( $ response ) ; } }
12110	public function deletePage ( $ id ) { $ this -> getPage ( $ id ) ; unset ( $ this -> pages [ $ id ] ) ; $ this -> persist ( ) ; }
10927	private function updateWidth ( $ columnNumber , $ width ) { if ( $ width > $ this -> getWidth ( $ columnNumber ) ) { $ this -> widths [ $ columnNumber ] = $ width ; } }
7056	protected static function dayOfYear ( $ y , $ m , $ d ) { $ l = ( ( int ) $ y % 4 == 0 && ( int ) $ y % 100 != 0 ) || ( int ) $ y % 400 == 0 ; $ k = $ l ? 1 : 2 ; $ n = intval ( 275 * ( int ) $ m / 9 ) - $ k * intval ( ( ( int ) $ m + 9 ) / 12 ) + ( int ) $ d - 30 ; return ( int ) $ n ; }
3896	public function getTemplates ( \ DC_Table $ objDC ) { $ type = $ objDC -> activeRecord -> type ; return $ this -> getTemplateList ( 'mod_' . $ type ) ; }
8682	public function setPath ( $ path , $ value ) { Deprecated :: method ( 1.1 , MutableBag :: class ) ; Arr :: set ( $ this -> items , $ path , $ value ) ; }
11592	public function getFullPath ( $ file = '' ) { $ this -> name = ( $ file ) ? $ file : $ this -> name ; return config ( 'odin.assetsUrl' ) . $ this -> getPath ( ) . $ this -> name ; }
6016	public function createSite ( DeploymentSite $ deploymentSite ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'deploymentSite' => $ deploymentSite ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/deployment' , $ parameters ) ; $ result = new DeploymentSiteResponse ( $ result ) ; return $ result ; }
12042	public function update ( $ usernameId , $ data = array ( ) ) { if ( empty ( $ usernameId ) ) return false ; $ existing = ( array ) $ this -> getPropertyData ( ) ; $ data = empty ( $ data ) ? $ existing : array_merge ( $ data , $ existing ) ; $ profile = $ this -> loadObjectByURI ( $ usernameId , array_keys ( $ this -> getPropertyModel ( ) ) ) ; $ this -> setObjectId ( $ profile -> getObjectId ( ) ) ; $ this -> setObjectURI ( $ profile -> getObjectURI ( ) ) ; $ profileData = $ profile -> getPropertyData ( ) ; $ updatedProfile = array_merge ( $ profileData , $ data ) ; foreach ( $ updatedProfile as $ property => $ value ) : $ this -> setPropertyValue ( $ property , $ value ) ; endforeach ; $ this -> defineValueGroup ( "user" ) ; if ( ! $ this -> saveObject ( $ this -> getPropertyValue ( "user_name_id" ) , "user" , $ this -> getObjectId ( ) ) ) { $ profile -> setError ( "Could not save the profile data" ) ; return false ; } return true ; }
1348	public function allow ( string $ resourceType , array $ fields = null ) : self { $ this -> all = false ; $ this -> allowed [ $ resourceType ] = $ fields ; return $ this ; }
4123	public function generateProxyClasses ( array $ classes , $ toDir = null ) { $ proxyDir = $ toDir ? : $ this -> proxyDir ; $ proxyDir = rtrim ( $ proxyDir , DIRECTORY_SEPARATOR ) . DIRECTORY_SEPARATOR ; foreach ( $ classes as $ class ) { if ( $ class -> isMappedSuperclass ) { continue ; } $ proxyFileName = $ this -> getProxyFileName ( $ class -> name , $ toDir ) ; $ this -> generateProxyClass ( $ class , $ proxyFileName , self :: $ proxyClassTemplate ) ; } }
12072	private function getForcedCustomersIds ( ) { $ mlmIds = array_keys ( $ this -> QUALIFIED_CUSTOMERS ) ; $ where = '' ; foreach ( $ mlmIds as $ one ) { if ( strlen ( $ where ) > 0 ) { $ where .= ' OR ' ; } $ quoted = $ this -> conn -> quote ( $ one ) ; $ where .= Customer :: A_MLM_ID . "=\"$quoted\"" ; } $ cols = [ Customer :: A_CUSTOMER_REF , Customer :: A_MLM_ID ] ; $ result = $ this -> daoGeneric -> getEntities ( Customer :: ENTITY_NAME , $ cols , $ where ) ; return $ result ; }
10306	public function setLineStyleProperties ( $ line_width = null , $ compound_type = null , $ dash_type = null , $ cap_type = null , $ join_type = null , $ head_arrow_type = null , $ head_arrow_size = null , $ end_arrow_type = null , $ end_arrow_size = null ) { ( $ line_width !== null ) ? $ this -> lineStyleProperties [ 'width' ] = $ this -> getExcelPointsWidth ( ( float ) $ line_width ) : null ; ( $ compound_type !== null ) ? $ this -> lineStyleProperties [ 'compound' ] = ( string ) $ compound_type : null ; ( $ dash_type !== null ) ? $ this -> lineStyleProperties [ 'dash' ] = ( string ) $ dash_type : null ; ( $ cap_type !== null ) ? $ this -> lineStyleProperties [ 'cap' ] = ( string ) $ cap_type : null ; ( $ join_type !== null ) ? $ this -> lineStyleProperties [ 'join' ] = ( string ) $ join_type : null ; ( $ head_arrow_type !== null ) ? $ this -> lineStyleProperties [ 'arrow' ] [ 'head' ] [ 'type' ] = ( string ) $ head_arrow_type : null ; ( $ head_arrow_size !== null ) ? $ this -> lineStyleProperties [ 'arrow' ] [ 'head' ] [ 'size' ] = ( string ) $ head_arrow_size : null ; ( $ end_arrow_type !== null ) ? $ this -> lineStyleProperties [ 'arrow' ] [ 'end' ] [ 'type' ] = ( string ) $ end_arrow_type : null ; ( $ end_arrow_size !== null ) ? $ this -> lineStyleProperties [ 'arrow' ] [ 'end' ] [ 'size' ] = ( string ) $ end_arrow_size : null ; }
11911	public static function trimStringRight ( $ str , $ remove ) { if ( ! is_string ( $ str ) ) throw new InvalidArgumentException ( '$str has to be a string' ) ; if ( ! is_string ( $ remove ) ) throw new InvalidArgumentException ( '$remove has to be a string' ) ; $ len = strlen ( $ remove ) ; $ offset = strlen ( $ str ) - $ len ; while ( 0 < $ offset && strpos ( $ str , $ remove , $ offset ) === $ offset ) { $ str = substr ( $ str , 0 , $ offset ) ; $ offset = strlen ( $ str ) - $ len ; } return $ str ; }
8805	protected function driver ( ) { if ( $ this -> getDefaultDriver ( ) === 'argon' ) { return $ this -> createArgonDriver ( ) ; } elseif ( $ this -> getDefaultDriver ( ) === 'argon2id' ) { return $ this -> createArgon2IdDriver ( ) ; } return $ this -> createBcryptDriver ( ) ; }
12918	protected function findContentType ( $ spaceId , $ contentTypeName ) { $ contentTypes = $ this -> contentTypeRepo -> findNewestByName ( $ spaceId , $ contentTypeName ) ; if ( $ contentTypes -> isEmpty ( ) ) { throw new InvalidArgumentException ( sprintf ( 'Content type "%s" in space "%s" not found!' , $ contentTypeName , $ spaceId ) ) ; } if ( $ contentTypes -> count ( ) > 1 ) { throw new InvalidArgumentException ( sprintf ( 'Multiple content types with name "%s" found in space "%s"!' , $ contentTypeName , $ spaceId ) ) ; } $ contentType = $ contentTypes -> first ( ) ; return $ contentType ; }
1761	protected static function readPhpFileWithoutTags ( $ strName ) { @ trigger_error ( 'Using System::readPhpFileWithoutTags() has been deprecated and will no longer work in Contao 5.0. Use the Contao\CoreBundle\Config\Loader\PhpFileLoader instead.' , E_USER_DEPRECATED ) ; $ rootDir = self :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( strpos ( $ strName , $ rootDir . '/' ) === false ) { $ strName = $ rootDir . '/' . $ strName ; } $ loader = new PhpFileLoader ( ) ; return $ loader -> load ( $ strName ) ; }
3956	public function getSiblings ( $ objFilter ) { if ( ! $ this -> getMetaModel ( ) -> hasVariants ( ) ) { return null ; } return $ this -> getMetaModel ( ) -> findVariantsWithBase ( array ( $ this -> get ( 'id' ) ) , $ objFilter ) ; }
10623	public static function synchronizeMigrations ( CommandEvent $ event ) { $ packages = $ event -> getComposer ( ) -> getRepositoryManager ( ) -> getLocalRepository ( ) -> getPackages ( ) ; $ installer = $ event -> getComposer ( ) -> getInstallationManager ( ) ; $ appMigrationDir = self :: getDestinationDir ( $ event -> getComposer ( ) ) ; $ io = $ event -> getIO ( ) ; $ areFileMigrated = array ( ) ; $ areFileMigrated [ ] = self :: handlePackage ( '.' , $ event -> getComposer ( ) -> getPackage ( ) , $ io , $ appMigrationDir ) ; foreach ( $ packages as $ package ) { $ areFileMigrated [ ] = self :: handlePackage ( $ installer -> getInstallPath ( $ package ) , $ package , $ io , $ appMigrationDir ) ; } if ( in_array ( true , $ areFileMigrated ) ) { $ io -> write ( "<warning>Some migration files have been imported. " . "You should run `php app/console doctrine:migrations:status` and/or " . "`php app/console doctrine:migrations:migrate` to apply them to your DB." ) ; } }
375	public function getActionArgsHelp ( $ action ) { $ method = $ this -> getActionMethodReflection ( $ action ) ; $ tags = $ this -> parseDocCommentTags ( $ method ) ; $ params = isset ( $ tags [ 'param' ] ) ? ( array ) $ tags [ 'param' ] : [ ] ; $ args = [ ] ; foreach ( $ method -> getParameters ( ) as $ i => $ reflection ) { if ( $ reflection -> getClass ( ) !== null ) { continue ; } $ name = $ reflection -> getName ( ) ; $ tag = isset ( $ params [ $ i ] ) ? $ params [ $ i ] : '' ; if ( preg_match ( '/^(\S+)\s+(\$\w+\s+)?(.*)/s' , $ tag , $ matches ) ) { $ type = $ matches [ 1 ] ; $ comment = $ matches [ 3 ] ; } else { $ type = null ; $ comment = $ tag ; } if ( $ reflection -> isDefaultValueAvailable ( ) ) { $ args [ $ name ] = [ 'required' => false , 'type' => $ type , 'default' => $ reflection -> getDefaultValue ( ) , 'comment' => $ comment , ] ; } else { $ args [ $ name ] = [ 'required' => true , 'type' => $ type , 'default' => null , 'comment' => $ comment , ] ; } } return $ args ; }
10187	protected static function buildAuthorizationHeader ( string $ method , string $ token , string $ password = null ) { switch ( $ method ) { case Client :: AUTH_HTTP_PASSWORD : return 'Basic ' . base64_encode ( "$token:$password" ) ; case Client :: AUTH_OAUTH_TOKEN : return "Bearer $token" ; } throw new RuntimeException ( sprintf ( 'Authentication method "%s" not implemented.' , $ method ) ) ; }
913	private function moveReturnAnnotations ( $ content ) { $ doc = new DocBlock ( $ content ) ; $ returns = $ doc -> getAnnotationsOfType ( 'return' ) ; if ( empty ( $ returns ) ) { return $ content ; } $ others = $ doc -> getAnnotationsOfType ( [ 'param' , 'throws' ] ) ; if ( empty ( $ others ) ) { return $ content ; } $ start = $ returns [ 0 ] -> getStart ( ) ; $ line = $ doc -> getLine ( $ start ) ; foreach ( array_reverse ( $ others ) as $ other ) { if ( $ other -> getEnd ( ) > $ start ) { $ line -> setContent ( $ other -> getContent ( ) . $ line -> getContent ( ) ) ; $ other -> remove ( ) ; } } return $ doc -> getContent ( ) ; }
8631	public function setReportInfoList ( $ reportInfo ) { if ( ! $ this -> _isNumericArray ( $ reportInfo ) ) { $ reportInfo = array ( $ reportInfo ) ; } $ this -> fields [ 'ReportInfo' ] [ 'FieldValue' ] = $ reportInfo ; return $ this ; }
9	public function authorizeOAuth ( $ originUrl ) { if ( ! in_array ( $ originUrl , $ this -> config -> get ( 'gitlab-domains' ) , true ) ) { return false ; } if ( 0 === $ this -> process -> execute ( 'git config gitlab.accesstoken' , $ output ) ) { $ this -> io -> setAuthentication ( $ originUrl , trim ( $ output ) , 'oauth2' ) ; return true ; } $ authTokens = $ this -> config -> get ( 'gitlab-token' ) ; if ( isset ( $ authTokens [ $ originUrl ] ) ) { $ this -> io -> setAuthentication ( $ originUrl , $ authTokens [ $ originUrl ] , 'private-token' ) ; return true ; } return false ; }
4443	public function multiget ( array $ jids ) : array { if ( empty ( $ jids ) ) { return [ ] ; } $ results = call_user_func_array ( [ $ this -> client , 'multiget' ] , $ jids ) ; $ jobs = json_decode ( $ results , true ) ? : [ ] ; $ ret = [ ] ; foreach ( $ jobs as $ data ) { $ job = new BaseJob ( $ this -> client , $ data ) ; $ job -> setEventsManager ( $ this -> client -> getEventsManager ( ) ) ; $ ret [ $ job -> jid ] = $ job ; } return $ ret ; }
7672	function TbsLoadSubFileAsTemplate ( $ SubFileLst ) { if ( ! is_array ( $ SubFileLst ) ) $ SubFileLst = array ( $ SubFileLst ) ; $ ok = true ; $ TBS = false ; foreach ( $ SubFileLst as $ SubFile ) { $ idx = $ this -> FileGetIdx ( $ SubFile ) ; if ( $ idx === false ) { $ ok = $ this -> RaiseError ( 'Cannot load "' . $ SubFile . '". The file is not found in the archive "' . $ this -> ArchFile . '".' ) ; } elseif ( $ idx !== $ this -> TbsCurrIdx ) { $ this -> TbsStorePark ( ) ; if ( ! is_string ( $ SubFile ) ) $ SubFile = $ this -> TbsGetFileName ( $ idx ) ; $ this -> TbsStoreLoad ( $ idx , $ SubFile ) ; if ( $ this -> LastReadNotStored ) { if ( $ TBS === false ) { $ this -> TbsSwitchMode ( true ) ; $ MergeAutoFields = $ this -> TbsMergeAutoFields ( ) ; $ TBS = & $ this -> TBS ; } if ( $ this -> LastReadComp <= 0 ) { if ( $ this -> ExtInfo !== false ) { $ i = $ this -> ExtInfo ; $ e = $ this -> ExtEquiv ; if ( isset ( $ i [ 'rpl_what' ] ) ) { $ TBS -> Source = str_replace ( $ i [ 'rpl_what' ] , $ i [ 'rpl_with' ] , $ TBS -> Source ) ; } if ( ( $ e === 'odt' ) && $ TBS -> OtbsClearWriter ) { $ this -> OpenDoc_CleanRsID ( $ TBS -> Source ) ; } if ( ( $ e === 'ods' ) && $ TBS -> OtbsMsExcelCompatibility ) { $ this -> OpenDoc_MsExcelCompatibility ( $ TBS -> Source ) ; } if ( $ e === 'docx' ) { if ( $ TBS -> OtbsSpacePreserve ) $ this -> MsWord_CleanSpacePreserve ( $ TBS -> Source ) ; if ( $ TBS -> OtbsClearMsWord ) $ this -> MsWord_Clean ( $ TBS -> Source ) ; } if ( ( $ e === 'pptx' ) && $ TBS -> OtbsClearMsPowerpoint ) { $ this -> MsPowerpoint_Clean ( $ TBS -> Source ) ; } if ( ( $ e === 'xlsx' ) && $ TBS -> OtbsMsExcelConsistent ) { $ this -> MsExcel_DeleteFormulaResults ( $ TBS -> Source ) ; $ this -> MsExcel_ConvertToRelative ( $ TBS -> Source ) ; } } if ( $ MergeAutoFields ) $ TBS -> LoadTemplate ( null , '+' ) ; } } } } if ( $ TBS !== false ) $ this -> TbsSwitchMode ( false ) ; return $ ok ; }
1774	public function addAttributes ( $ arrAttributes ) { if ( ! \ is_array ( $ arrAttributes ) ) { return ; } foreach ( $ arrAttributes as $ k => $ v ) { $ this -> $ k = $ v ; } }
7735	private function documentRouteAndOperations ( $ metadata , Reflector $ element ) { if ( ( null !== ( $ annotation = $ this -> getAnnotation ( $ element , 'ML\HydraBundle\Mapping\Id' ) ) ) || ( null !== ( $ annotation = $ this -> getAnnotation ( $ element , 'ML\HydraBundle\Mapping\Route' ) ) ) ) { $ metadata -> setRoute ( $ this -> getRouteMetadata ( $ annotation -> route ) ) ; } $ annotation = $ this -> getAnnotation ( $ element , 'ML\HydraBundle\Mapping\Operations' ) ; if ( null !== $ annotation ) { $ operations = array_unique ( $ annotation -> operations ) ; $ operationsMetadata = array_map ( array ( $ this , 'getRouteMetadata' ) , $ operations ) ; $ metadata -> setOperations ( $ operationsMetadata ) ; } if ( null !== ( $ route = $ metadata -> getRoute ( ) ) ) { $ metadata -> addOperation ( $ this -> getRouteMetadata ( $ route -> getName ( ) ) ) ; } elseif ( null !== $ annotation ) { $ metadata -> setRoute ( $ this -> getRouteMetadata ( reset ( $ annotation -> operations ) ) ) ; } if ( ( $ metadata instanceof PropertyDefinition ) && ( count ( $ operations = $ metadata -> getOperations ( ) ) > 0 ) ) { foreach ( $ operations as $ operation ) { if ( ( 'GET' === $ operation -> getMethod ( ) ) && ( null !== $ operation -> getReturns ( ) ) ) { $ metadata -> setType ( $ operation -> getReturns ( ) ) ; return ; } } $ metadata -> setType ( 'ML\HydraBundle\Entity\Resource' ) ; } }
7165	private function buildDiscountLine ( Model \ SaleAdjustmentInterface $ adjustment , $ level = 0 ) { if ( Model \ AdjustmentTypes :: TYPE_DISCOUNT !== $ adjustment -> getType ( ) ) { throw new InvalidArgumentException ( "Unexpected adjustment type." ) ; } $ lineNumber = $ this -> lineNumber ++ ; $ view = new LineView ( 'adjustment_' . ( $ lineNumber - 1 ) , 'adjustment_' . $ adjustment -> getId ( ) , $ lineNumber , $ level ) ; if ( empty ( $ designation = $ adjustment -> getDesignation ( ) ) ) { $ designation = 'Discount ' ; if ( $ adjustment -> getMode ( ) === Model \ AdjustmentModes :: MODE_PERCENT ) { $ designation .= $ this -> formatter -> percent ( $ adjustment -> getAmount ( ) ) ; } } $ result = $ adjustment -> getResult ( ) ; $ view -> setDesignation ( $ designation ) -> setBase ( $ this -> formatter -> currency ( $ result -> getBase ( ) ) ) -> setTaxAmount ( $ this -> formatter -> currency ( $ result -> getTax ( ) ) ) -> setTotal ( $ this -> formatter -> currency ( $ result -> getTotal ( ) ) ) ; foreach ( $ this -> types as $ type ) { $ type -> buildAdjustmentView ( $ adjustment , $ view , $ this -> options ) ; } return $ view ; }
1076	private static function isMissingVariable ( $ valueNode , $ variables ) { return $ valueNode instanceof VariableNode && ( count ( $ variables ) === 0 || ! array_key_exists ( $ valueNode -> name -> value , $ variables ) ) ; }
7231	public function loadResult ( array $ result ) { $ changed = false ; foreach ( [ 'revenue' , 'shipping' , 'margin' , 'orders' , 'items' , 'average' , 'details' ] as $ property ) { if ( $ this -> { $ property } != $ result [ $ property ] ) { $ this -> { $ property } = $ result [ $ property ] ; $ changed = true ; } } return $ changed ; }
3243	public function getShopUrlAttribute ( ) { if ( $ this -> hasObject ) return $ this -> object -> shopUrl ; if ( ! property_exists ( $ this , 'itemRouteName' ) && ! property_exists ( $ this , 'itemRouteParams' ) ) return '#' ; $ params = [ ] ; foreach ( array_keys ( $ this -> attributes ) as $ attribute ) { if ( in_array ( $ attribute , $ this -> itemRouteParams ) ) $ params [ $ attribute ] = $ this -> attributes [ $ attribute ] ; } return empty ( $ this -> itemRouteName ) ? '#' : \ route ( $ this -> itemRouteName , $ params ) ; }
8829	protected function option ( $ display , $ value , $ selected , array $ attributes = [ ] ) { $ selected = $ this -> getSelectedValue ( $ value , $ selected ) ; $ options = array_merge ( [ 'value' => $ value , 'selected' => $ selected ] , $ attributes ) ; return $ this -> toHtmlString ( '<option' . $ this -> html -> attributes ( $ options ) . '>' . e ( $ display ) . '</option>' ) ; }
10717	public function newModel ( ) { $ model = app ( ) -> make ( $ this -> modelClass ) ; if ( ! $ model instanceof Model ) { throw new RepositoryException ( "Class {$this->modelClass} must be an instance of Illuminate\\Database\\Eloquent\\Model" ) ; } return $ model ; }
5597	protected function createErrorQueue ( ) { $ context = SimpleTest :: getContext ( ) ; $ test = $ this -> getTestCase ( ) ; $ queue = $ context -> get ( 'SimpleErrorQueue' ) ; $ queue -> setTestCase ( $ test ) ; return $ queue ; }
1662	public function reply ( $ message ) { if ( is_string ( $ message ) ) { $ this -> messages [ ] = Text :: create ( ) -> text ( $ message ) -> setAgentVersion ( $ this -> agentVersion ) -> setRequestSource ( $ this -> requestSource ) ; if ( ! $ this -> doesSupportRichMessage ( ) ) { $ this -> text = $ message ; } } elseif ( $ message instanceof RichMessage ) { if ( ! $ this -> doesSupportRichMessage ( ) ) { $ this -> text = $ message -> getFallbackText ( ) ; } $ message -> setAgentVersion ( $ this -> agentVersion ) -> setRequestSource ( $ this -> requestSource ) ; $ this -> messages [ ] = $ message ; } elseif ( $ message instanceof Conversation ) { $ this -> messages [ ] = Payload :: create ( $ message -> render ( ) ) -> setAgentVersion ( $ this -> agentVersion ) -> setRequestSource ( $ this -> requestSource ) ; } return $ this ; }
5612	public function paintPass ( $ message ) { parent :: paintPass ( $ message ) ; $ node = new TreemapNode ( 'Assertion' , $ message , true ) ; $ current = $ this -> _stack -> peek ( ) ; if ( $ current ) { $ current -> putChild ( $ node ) ; } else { echo 'no current node' ; } }
11300	protected function _fetchData ( $ name ) { $ gateway = new \ Cora \ Gateway ( $ this -> getDbAdaptor ( ) , $ this -> getTableName ( ) , $ this -> getPrimaryKey ( ) ) ; return $ gateway -> fetchData ( $ this -> getFieldName ( $ name ) , $ this ) ; }
882	private function normalizeType ( $ type ) { if ( '[]' === substr ( $ type , - 2 ) ) { return $ this -> normalize ( substr ( $ type , 0 , - 2 ) ) . '[]' ; } return $ this -> normalize ( $ type ) ; }
8004	public static function forString ( $ string , $ code = self :: CODE_FOR_STRING , Exception $ previous = null ) { $ message = self :: DEFAULT_MESSAGE . sprintf ( self :: MESSAGE_EXTENSION_FOR_STRING_FORMAT , $ string ) ; return new static ( $ message , $ code , $ previous ) ; }
869	private function createProcessForSource ( $ source ) { if ( null === $ this -> temporaryFile ) { $ this -> temporaryFile = tempnam ( '.' , 'cs_fixer_tmp_' ) ; $ this -> fileRemoval -> observe ( $ this -> temporaryFile ) ; } if ( false === @ file_put_contents ( $ this -> temporaryFile , $ source ) ) { throw new IOException ( sprintf ( 'Failed to write file "%s".' , $ this -> temporaryFile ) , 0 , null , $ this -> temporaryFile ) ; } return $ this -> createProcessForFile ( $ this -> temporaryFile ) ; }
10083	protected function registerRouter ( ) { $ this -> app -> singleton ( 'auja.router' , function ( $ app ) { $ config = $ app [ 'config' ] [ 'auja-laravel' ] ? : $ app [ 'config' ] [ 'auja-laravel::config' ] ; return new AujaRouter ( $ app [ 'auja' ] , $ app [ 'router' ] , $ config [ 'route' ] ) ; } ) ; $ this -> app -> bind ( 'Label305\AujaLaravel\Routing\AujaRouter' , 'auja.router' ) ; }
9836	protected function openFile ( $ pFilename ) { File :: assertFile ( $ pFilename ) ; $ this -> fileHandle = fopen ( $ pFilename , 'r' ) ; if ( $ this -> fileHandle === false ) { throw new Exception ( 'Could not open file ' . $ pFilename . ' for reading.' ) ; } }
2791	public function hasOks ( $ output ) { $ result = preg_match_all ( "%##teamcity\[testFinished%" , $ output ) ; if ( $ result ) { $ this -> okCount += $ result ; return $ this -> okCount ; } return false ; }
4476	public function track ( ) : void { if ( $ this -> client -> call ( 'track' , 'track' , $ this -> jid ) ) { $ this -> tracked = true ; } }
30	public function appendPackages ( array $ packages , array $ bucket ) { foreach ( $ packages as $ package ) { $ bucket [ $ package -> getName ( ) ] = $ package ; } return $ bucket ; }
5419	protected function parseHeaderLine ( $ header_line ) { if ( preg_match ( '/HTTP\/(\d+\.\d+)\s+(\d+)/i' , $ header_line , $ matches ) ) { $ this -> http_version = $ matches [ 1 ] ; $ this -> response_code = $ matches [ 2 ] ; } if ( preg_match ( '/Content-type:\s*(.*)/i' , $ header_line , $ matches ) ) { $ this -> mime_type = trim ( $ matches [ 1 ] ) ; } if ( preg_match ( '/Location:\s*(.*)/i' , $ header_line , $ matches ) ) { $ this -> location = trim ( $ matches [ 1 ] ) ; } if ( preg_match ( '/Set-cookie:(.*)/i' , $ header_line , $ matches ) ) { $ this -> cookies [ ] = $ this -> parseCookie ( $ matches [ 1 ] ) ; } if ( preg_match ( '/WWW-Authenticate:\s+(\S+)\s+realm=\"(.*?)\"/i' , $ header_line , $ matches ) ) { $ this -> authentication = $ matches [ 1 ] ; $ this -> realm = trim ( $ matches [ 2 ] ) ; } }
9275	public function onBootstrap ( MvcEvent $ event ) { $ eventManager = $ event -> getApplication ( ) -> getEventManager ( ) ; $ sharedEventManager = $ eventManager -> getSharedManager ( ) ; }
9052	public function getMenuItemsJson ( Collection $ menuItems , $ currentOwner ) { $ this -> alreadySetIds = [ ] ; $ this -> position = 0 ; $ this -> currentOwner = $ currentOwner ; return json_encode ( $ this -> recursiveMenuItemHandling ( $ menuItems ) ) ; }
11193	protected function setPath ( $ url ) { $ cleanURI = str_replace ( '?' . $ _SERVER [ 'QUERY_STRING' ] , '' , $ url ) ; $ this -> pathString = explode ( $ this -> config [ 'site_url' ] , $ cleanURI , 2 ) [ 1 ] ; if ( $ this -> config [ 'lowercase_url' ] ) { $ this -> pathString = strtolower ( $ this -> pathString ) ; } $ this -> path = explode ( '/' , $ this -> pathString ) ; }
10949	protected function loadCsrfToken ( ) { if ( $ this -> enableCsrfCookie ) { return $ this -> getCookies ( ) -> getValue ( $ this -> csrfParam ) ; } else { return Yii :: $ app -> getSession ( ) -> get ( $ this -> csrfParam ) ; } }
780	public function getValue ( $ name , $ defaultValue = null ) { return isset ( $ this -> _cookies [ $ name ] ) ? $ this -> _cookies [ $ name ] -> value : $ defaultValue ; }
11484	protected function getFunctionArguments ( ReflectionFunctionAbstract $ func , array $ params = array ( ) ) { $ args = [ ] ; foreach ( $ func -> getParameters ( ) as $ param ) { $ class = $ param -> getClass ( ) ; if ( $ class ) { $ args [ ] = $ this -> resolveClassArg ( $ class , $ param , $ params ) ; } else { $ args [ ] = $ this -> resolveNonClassArg ( $ param , $ params , $ func ) ; } } return $ args ; }
4202	private function addMethodsPhpDoc ( Event $ abs ) { $ inheritedFrom = null ; if ( empty ( $ abs [ 'phpDoc' ] [ 'method' ] ) ) { if ( \ array_intersect_key ( $ abs [ 'methods' ] , \ array_flip ( array ( '__call' , '__callStatic' ) ) ) ) { $ reflector = $ abs [ 'reflector' ] ; while ( $ reflector = $ reflector -> getParentClass ( ) ) { $ parsed = $ this -> phpDoc -> getParsed ( $ reflector ) ; if ( isset ( $ parsed [ 'method' ] ) ) { $ inheritedFrom = $ reflector -> getName ( ) ; $ abs [ 'phpDoc' ] [ 'method' ] = $ parsed [ 'method' ] ; break ; } } } if ( empty ( $ abs [ 'phpDoc' ] [ 'method' ] ) ) { return ; } } foreach ( $ abs [ 'phpDoc' ] [ 'method' ] as $ phpDocMethod ) { $ className = $ inheritedFrom ? $ inheritedFrom : $ abs [ 'className' ] ; $ abs [ 'methods' ] [ $ phpDocMethod [ 'name' ] ] = array ( 'implements' => null , 'inheritedFrom' => $ inheritedFrom , 'isAbstract' => false , 'isDeprecated' => false , 'isFinal' => false , 'isStatic' => $ phpDocMethod [ 'static' ] , 'params' => \ array_map ( function ( $ param ) use ( $ className ) { $ info = $ this -> phpDocParam ( $ param , $ className ) ; return array ( 'constantName' => $ info [ 'constantName' ] , 'defaultValue' => $ info [ 'defaultValue' ] , 'desc' => null , 'name' => $ param [ 'name' ] , 'optional' => false , 'type' => $ param [ 'type' ] , ) ; } , $ phpDocMethod [ 'param' ] ) , 'phpDoc' => array ( 'summary' => $ phpDocMethod [ 'desc' ] , 'description' => null , 'return' => array ( 'type' => $ phpDocMethod [ 'type' ] , 'desc' => null , ) ) , 'visibility' => 'magic' , ) ; } unset ( $ abs [ 'phpDoc' ] [ 'method' ] ) ; return ; }
11259	public static function pascal2snake ( string $ pascal ) : string { preg_match_all ( '/((?:^|[A-Z])[a-z]+)/' , $ pascal , $ matches ) ; if ( $ matches !== null && count ( $ matches ) > 1 && count ( $ matches [ 1 ] ) > 1 ) { $ nameParts = $ matches [ 1 ] ; $ nameParts = array_map ( "lcfirst" , $ nameParts ) ; return implode ( "_" , $ nameParts ) ; } else { return lcfirst ( $ pascal ) ; } }
4908	public function render ( SummaryFormInterface $ form , $ layout = Form :: LAYOUT_HORIZONTAL , $ parameter = array ( ) ) { $ renderer = $ this -> getView ( ) ; $ renderer -> headscript ( ) -> appendFile ( $ renderer -> basepath ( 'modules/Core/js/jquery.summary-form.js' ) ) ; $ label = $ form -> getLabel ( ) ; $ labelContent = $ label ? '<div class="sf-headline"><h3>' . $ this -> getView ( ) -> translate ( $ label ) . '</h3></div>' : '' ; $ formContent = $ this -> renderForm ( $ form , $ layout , $ parameter ) ; $ summaryContent = $ this -> renderSummary ( $ form ) ; $ formContent = sprintf ( '<div class="sf-form"><div class="panel panel-info"><div class="panel-body">%s</div></div></div> <div class="sf-summary">%s</div> ' , $ formContent , $ summaryContent ) ; if ( $ form instanceof DescriptionAwareFormInterface && $ form -> isDescriptionsEnabled ( ) ) { $ this -> getView ( ) -> headscript ( ) -> appendFile ( $ this -> getView ( ) -> basepath ( 'modules/Core/js/forms.descriptions.js' ) ) ; if ( $ desc = $ form -> getOption ( 'description' , '' ) ) { $ translator = $ this -> getTranslator ( ) ; $ textDomain = $ this -> getTranslatorTextDomain ( ) ; $ desc = $ translator -> translate ( $ desc , $ textDomain ) ; } $ formContent = sprintf ( '<div class="daf-form-container row"> <div class="daf-form col-md-8">%s</div> <div class="daf-desc col-md-4"> <div class="daf-desc-content alert alert-info">%s</div> </div> </div>' , $ formContent , $ desc ) ; } $ markup = '<div id="sf-%s" class="sf-container" data-display-mode="%s">' . '%s' . '%s' . '</div>' ; $ id = str_replace ( '.' , '-' , $ form -> getAttribute ( 'name' ) ) ; $ content = sprintf ( $ markup , $ id , $ form -> getDisplayMode ( ) , $ labelContent , $ formContent ) ; return $ content ; }
12761	protected function checkBrowsers ( ) { return ( $ this -> checkBrowserWebTv ( ) || $ this -> checkBrowserInternetExplorer ( ) || $ this -> checkBrowserOpera ( ) || $ this -> checkBrowserGaleon ( ) || $ this -> checkBrowserNetscapeNavigator9Plus ( ) || $ this -> checkBrowserFirefox ( ) || $ this -> checkBrowserChrome ( ) || $ this -> checkBrowserOmniWeb ( ) || $ this -> checkBrowserAndroid ( ) || $ this -> checkBrowseriPad ( ) || $ this -> checkBrowseriPod ( ) || $ this -> checkBrowseriPhone ( ) || $ this -> checkBrowserBlackBerry ( ) || $ this -> checkBrowserNokia ( ) || $ this -> checkBrowserGoogleBot ( ) || $ this -> checkBrowserMSNBot ( ) || $ this -> checkBrowserBingBot ( ) || $ this -> checkBrowserSlurp ( ) || $ this -> checkFacebookExternalHit ( ) || $ this -> checkBrowserSafari ( ) || $ this -> checkBrowserNetPositive ( ) || $ this -> checkBrowserFirebird ( ) || $ this -> checkBrowserKonqueror ( ) || $ this -> checkBrowserIcab ( ) || $ this -> checkBrowserPhoenix ( ) || $ this -> checkBrowserAmaya ( ) || $ this -> checkBrowserLynx ( ) || $ this -> checkBrowserShiretoko ( ) || $ this -> checkBrowserIceCat ( ) || $ this -> checkBrowserIceweasel ( ) || $ this -> checkBrowserW3CValidator ( ) || $ this -> checkBrowserMozilla ( ) ) ; }
9688	public function det ( ) { if ( $ this -> m == $ this -> n ) { $ d = $ this -> pivsign ; for ( $ j = 0 ; $ j < $ this -> n ; ++ $ j ) { $ d *= $ this -> LU [ $ j ] [ $ j ] ; } return $ d ; } throw new CalculationException ( Matrix :: MATRIX_DIMENSION_EXCEPTION ) ; }
8580	public function setPromotionAdjustmentList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'PromotionAdjustmentList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
3769	public function collectAttributeSettings ( IMetaModel $ metaModel , $ renderSetting ) { $ attributeRows = $ this -> database -> createQueryBuilder ( ) -> select ( '*' ) -> from ( 'tl_metamodel_rendersetting' ) -> where ( 'pid=:pid' ) -> andWhere ( 'enabled=1' ) -> orderBy ( 'sorting' ) -> setParameter ( 'pid' , $ renderSetting -> get ( 'id' ) ) -> execute ( ) ; foreach ( $ attributeRows -> fetchAll ( \ PDO :: FETCH_ASSOC ) as $ attributeRow ) { $ attribute = $ metaModel -> getAttributeById ( $ attributeRow [ 'attr_id' ] ) ; if ( ! $ attribute ) { continue ; } $ attributeSetting = $ renderSetting -> getSetting ( $ attribute -> getColName ( ) ) ; if ( ! $ attributeSetting ) { $ attributeSetting = $ attribute -> getDefaultRenderSettings ( ) ; } foreach ( $ attributeRow as $ strKey => $ varValue ) { if ( $ varValue ) { $ attributeSetting -> set ( $ strKey , StringUtil :: deserialize ( $ varValue ) ) ; } } $ renderSetting -> setSetting ( $ attribute -> getColName ( ) , $ attributeSetting ) ; } }
7186	public function getCombination ( $ quantity , $ reset = false ) { if ( null !== $ this -> combination && ! $ reset ) { return $ this -> combination ; } $ this -> combination = null ; if ( ! empty ( $ combinations = $ this -> buildCombinations ( $ quantity ) ) ) { usort ( $ combinations , function ( AssignmentCombination $ a , AssignmentCombination $ b ) use ( $ quantity ) { if ( $ a -> diff == $ b -> diff ) { if ( $ a -> size == $ b -> size ) { return 0 ; } return $ a -> size < $ b -> size ? - 1 : 1 ; } if ( 0 <= $ a -> diff ) { return intval ( 0 > $ b -> diff ? - 1 : $ a -> diff - $ b -> diff ) ; } return intval ( 0 < $ b -> diff ? 1 : $ b -> diff - $ a -> diff ) ; } ) ; $ this -> combination = reset ( $ combinations ) ; } return $ this -> combination ; }
942	public function isDryRun ( ) { if ( null === $ this -> isDryRun ) { if ( $ this -> isStdIn ( ) ) { $ this -> isDryRun = true ; } else { $ this -> isDryRun = $ this -> options [ 'dry-run' ] ; } } return $ this -> isDryRun ; }
10671	public static function toArray ( $ obj ) { if ( $ obj instanceof \ DOMNode ) { $ obj = simplexml_import_dom ( $ obj ) ; } if ( ! ( $ obj instanceof \ SimpleXMLElement ) ) { throw new \ RuntimeException ( Tools :: poorManTranslate ( 'fts-shared' , 'The input is not instance of SimpleXMLElement, DOMDocument or DOMNode.' ) ) ; } $ result = [ ] ; $ namespaces = array_merge ( [ '' => '' ] , $ obj -> getNamespaces ( true ) ) ; self :: _toArray ( $ obj , $ result , '' , array_keys ( $ namespaces ) ) ; return $ result ; }
8881	private function isValidRelativePath ( string $ relativePath , string $ cwd ) : bool { $ valid = false ; if ( './' === substr ( $ relativePath , 0 , 2 ) ) { $ tmpPath = $ cwd . DIRECTORY_SEPARATOR . substr ( $ relativePath , 2 , strlen ( $ relativePath ) ) ; $ valid = $ this -> isValidFullPath ( $ tmpPath ) ; } return $ valid ; }
7294	public function inform_about_posts ( $ post_id = FALSE ) { if ( ! $ post_id ) { return $ post_id ; } if ( ! isset ( $ this -> transit_posts [ $ post_id ] ) ) { return $ post_id ; } $ transit = $ this -> transit_posts [ $ post_id ] ; if ( 'publish' != $ transit [ 'new_status' ] || 'publish' == $ transit [ 'old_status' ] ) { return $ post_id ; } $ post_data = get_post ( $ post_id ) ; $ user = get_userdata ( $ post_data -> post_author ) ; $ to = $ this -> get_members ( $ user -> data -> user_email , 'post' ) ; if ( empty ( $ to ) ) { return $ post_id ; } $ subject = get_option ( 'blogname' ) . ': ' . get_the_title ( $ post_data -> ID ) ; $ message = $ post_data -> post_content ; $ headers = array ( ) ; $ headers [ 'From' ] = get_the_author_meta ( 'display_name' , $ user -> ID ) . ' (' . get_bloginfo ( 'name' ) . ')' . ' <' . $ user -> data -> user_email . '>' ; if ( $ this -> options [ 'send_by_bcc' ] ) { $ bcc = $ to ; $ to = empty ( $ this -> options [ 'bcc_to_recipient' ] ) ? get_bloginfo ( 'admin_email' ) : $ this -> options [ 'bcc_to_recipient' ] ; $ headers [ 'Bcc' ] = $ bcc ; } $ to = apply_filters ( 'iac_post_to' , $ to , $ this -> options , $ post_id ) ; $ subject = apply_filters ( 'iac_post_subject' , $ subject , $ this -> options , $ post_id ) ; $ message = apply_filters ( 'iac_post_message' , $ message , $ this -> options , $ post_id ) ; $ headers = apply_filters ( 'iac_post_headers' , $ headers , $ this -> options , $ post_id ) ; $ attachments = apply_filters ( 'iac_post_attachments' , array ( ) , $ this -> options , $ post_id ) ; $ signature = apply_filters ( 'iac_post_signature' , '' , $ this -> options , $ post_id ) ; $ this -> options [ 'static_options' ] [ 'object' ] = array ( 'id' => $ post_id , 'type' => 'post' ) ; $ this -> send_mail ( $ to , $ subject , $ this -> append_signature ( $ message , $ signature ) , $ headers , $ attachments ) ; return $ post_id ; }
2399	public static function notifyCommentsSubscribers ( CommentsModel $ objComment ) { if ( $ objComment -> notified ) { return ; } $ objNotify = CommentsNotifyModel :: findActiveBySourceAndParent ( $ objComment -> source , $ objComment -> parent ) ; if ( $ objNotify !== null ) { while ( $ objNotify -> next ( ) ) { if ( $ objNotify -> email == $ objComment -> email ) { continue ; } $ strUrl = Idna :: decode ( Environment :: get ( 'base' ) ) . $ objNotify -> url ; $ objEmail = new Email ( ) ; $ objEmail -> from = $ GLOBALS [ 'TL_ADMIN_EMAIL' ] ; $ objEmail -> fromName = $ GLOBALS [ 'TL_ADMIN_NAME' ] ; $ objEmail -> subject = sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'com_notifySubject' ] , Idna :: decode ( Environment :: get ( 'host' ) ) ) ; $ objEmail -> text = sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'com_notifyMessage' ] , $ objNotify -> name , $ strUrl . '#c' . $ objComment -> id , $ strUrl . '?token=' . $ objNotify -> tokenRemove ) ; $ objEmail -> sendTo ( $ objNotify -> email ) ; } } $ objComment -> notified = '1' ; $ objComment -> save ( ) ; }
3628	protected static function getCURLCerts ( ) { $ url = 'https://curl.haxx.se/ca/cacert.pem' ; $ certs = @ file_get_contents ( $ url ) ; if ( ! $ certs ) { $ ch = curl_init ( ) ; curl_setopt ( $ ch , CURLOPT_URL , $ url ) ; curl_setopt ( $ ch , CURLOPT_RETURNTRANSFER , TRUE ) ; curl_setopt ( $ ch , CURLOPT_SSL_VERIFYPEER , TRUE ) ; curl_setopt ( $ ch , CURLOPT_SSL_VERIFYHOST , 2 ) ; $ response = curl_exec ( $ ch ) ; $ info = curl_getinfo ( $ ch ) ; curl_close ( $ ch ) ; if ( $ info [ 'http_code' ] == 200 ) { $ certs = $ response ; } } return $ certs ; }
1225	private function buildQueryParameters ( array $ paramValues ) { if ( empty ( $ paramValues ) ) { return '' ; } $ query = [ ] ; foreach ( $ paramValues as $ param => $ value ) { if ( is_array ( $ value ) ) { $ value = join ( ',' , $ value ) ; } elseif ( is_bool ( $ value ) ) { $ value = $ value ? 'true' : 'false' ; } elseif ( is_callable ( $ value ) ) { $ value = $ value ( ) ; } $ query [ ] = $ param . '=' . urlencode ( $ value ) ; } return '?' . join ( '&' , $ query ) ; }
11526	public function resolve ( $ templatePath ) { $ templatePathReal = realpath ( $ templatePath ) ; if ( $ templatePathReal === false ) { throw new \ Exception ( 'Template file does not exist: ' . $ templatePath ) ; } if ( $ this -> hasCache ( $ templatePathReal ) ) { return $ this -> getCache ( $ templatePathReal ) ; } $ template = file_get_contents ( $ templatePathReal ) ; $ this -> setCache ( $ templatePathReal , $ template ) ; return $ template ; }
3529	public static function sendUnrealClientGetRequest ( $ endpoint , $ authorization = self :: EPIC_LAUNCHER_AUTHORIZATION , $ oauth = false ) { $ client = new Client ( ) ; try { $ response = $ client -> get ( $ endpoint , [ 'headers' => [ 'User-Agent' => self :: UNREAL_CLIENT_USER_AGENT , 'Authorization' => ( ! $ oauth ) ? 'basic ' . $ authorization : 'bearer ' . $ authorization ] ] ) ; return json_decode ( $ response -> getBody ( ) -> getContents ( ) ) ; } catch ( GuzzleException $ e ) { throw $ e ; } }
7013	private function format_m ( & $ str ) { if ( strstr ( $ str , '%m' ) ) $ str = str_replace ( '%m' , sprintf ( '%02d' , $ this -> month ) , $ str ) ; }
1853	public function onReplaceInsertTags ( string $ tag ) { $ chunks = explode ( '::' , $ tag ) ; if ( 'trans' !== $ chunks [ 0 ] ) { return false ; } $ parameters = isset ( $ chunks [ 3 ] ) ? explode ( ':' , $ chunks [ 3 ] ) : [ ] ; return $ this -> translator -> trans ( $ chunks [ 1 ] , $ parameters , $ chunks [ 2 ] ?? null ) ; }
4793	function order ( $ columns ) { $ this -> rows = null ; if ( $ columns != "" ) { foreach ( func_get_args ( ) as $ columns ) { if ( $ this -> union ) { $ this -> unionOrder [ ] = $ columns ; } else { $ this -> order [ ] = $ columns ; } } } elseif ( $ this -> union ) { $ this -> unionOrder = array ( ) ; } else { $ this -> order = array ( ) ; } return $ this ; }
8428	public function getFileIcon ( $ fileType , $ iconLib = 'cmti' ) { switch ( $ iconLib ) { case 'cmti' : { return $ this -> getCmtiFileIcon ( $ fileType ) ; } case 'fa' : { return $ this -> getFaFileIcon ( $ fileType ) ; } } }
716	public function decimal ( $ precision = null , $ scale = null ) { $ length = [ ] ; if ( $ precision !== null ) { $ length [ ] = $ precision ; } if ( $ scale !== null ) { $ length [ ] = $ scale ; } return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_DECIMAL , $ length ) ; }
11720	public function countPost ( $ actor ) { $ em = $ this -> container -> get ( 'doctrine' ) -> getManager ( ) ; $ entities = $ em -> getRepository ( 'BlogBundle:Post' ) -> findBy ( array ( 'actor' => $ actor ) ) ; return count ( $ entities ) ; }
2338	public function initialize ( ) { if ( ! $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'enableVersioning' ] ) { return ; } $ objVersion = $ this -> Database -> prepare ( "SELECT COUNT(*) AS count FROM tl_version WHERE fromTable=? AND pid=?" ) -> limit ( 1 ) -> execute ( $ this -> strTable , $ this -> intPid ) ; if ( $ objVersion -> count > 0 ) { return ; } $ this -> create ( ) ; }
1287	private function fetchCollectionFromApi ( array $ resourceIds , string $ type , string $ locale = null ) : array { $ query = ( new Query ( ) ) -> where ( 'sys.id[in]' , $ resourceIds ) ; if ( 'Asset' === $ type || 'Entry' === $ type ) { $ query -> setLocale ( $ locale ) ; } switch ( $ type ) { case 'Asset' : return $ this -> client -> getAssets ( $ query ) -> getItems ( ) ; case 'ContentType' : return $ this -> client -> getContentTypes ( $ query ) -> getItems ( ) ; case 'Entry' : return $ this -> client -> getEntries ( $ query ) -> getItems ( ) ; case 'Environment' : return [ $ this -> client -> getEnvironment ( ) ] ; case 'Space' : return [ $ this -> client -> getSpace ( ) ] ; default : throw new \ InvalidArgumentException ( \ sprintf ( 'Trying to resolve link for unknown type "%s".' , $ type ) ) ; } }
6165	public function setOptions ( $ options ) { if ( is_array ( $ options ) ) { $ this -> options = $ options ; return $ this ; } $ this -> options = json_decode ( $ options , true ) ; if ( null === $ this -> options ) { $ this -> options = $ options ; } return $ this ; }
4025	private function addCondition ( PropertyInterface $ property , ConditionInterface $ condition ) { $ chain = $ property -> getVisibleCondition ( ) ; if ( ! ( $ chain && ( $ chain instanceof PropertyConditionChain ) && $ chain -> getConjunction ( ) == PropertyConditionChain :: AND_CONJUNCTION ) ) { if ( $ property -> getVisibleCondition ( ) ) { $ previous = array ( $ property -> getVisibleCondition ( ) ) ; } else { $ previous = array ( ) ; } $ chain = new PropertyConditionChain ( $ previous , PropertyConditionChain :: AND_CONJUNCTION ) ; $ property -> setVisibleCondition ( $ chain ) ; } $ chain -> addCondition ( $ condition ) ; }
10639	protected function processUrls ( Request $ request ) { $ externalRawMediaUrls = array ( ) ; if ( $ request -> get ( 'urls' ) ) { foreach ( $ request -> get ( 'urls' ) as $ url ) { $ externalRawMediaUrls [ ] = $ url ; } } return $ externalRawMediaUrls ; }
761	public function getSql ( ) { $ code = $ this ; while ( $ code -> parent !== null ) { $ code = $ code -> parent ; } return mb_substr ( $ code -> content , $ this -> startOffset , $ this -> endOffset - $ this -> startOffset , 'UTF-8' ) ; }
6537	public function registerAssetFiles ( $ view ) { if ( \ Yii :: $ app -> request -> isPjax ) { return parent :: registerAssetFiles ( $ view ) ; } parent :: registerAssetFiles ( $ view ) ; }
3240	public function setCallbacks ( $ order ) { $ this -> callbackSuccess = route ( config ( 'shop.callback_route' ) , [ 'status' => 'success' , 'id' => $ order -> id , 'token' => $ this -> token , ] ) ; $ this -> callbackFail = route ( config ( 'shop.callback_route' ) , [ 'status' => 'fail' , 'id' => $ order -> id , 'token' => $ this -> token , ] ) ; }
10533	public function last ( ) { if ( is_array ( $ this -> items ) && count ( $ this -> items ) > 0 ) { return end ( $ this -> items ) ; } return null ; }
10893	public function add ( $ name , UriInterface $ uri ) { unset ( $ this -> uris [ $ name ] ) ; $ this -> uris [ $ name ] = $ uri ; }
11834	public function doStore ( ModulesEvent $ event ) { $ cache = $ this -> getCache ( ) ; $ config = $ this -> getConfig ( ) ; $ cache -> set ( 'config' , $ config ) ; }
7107	static public function round ( $ amount , $ currency ) { $ precision = static :: getPrecision ( $ currency ) ; $ roundingIncrement = static :: getRoundingIncrement ( $ currency ) ; $ amount = round ( $ amount , $ precision , \ PHP_ROUND_HALF_EVEN ) ; if ( 0 < $ roundingIncrement && 0 < $ precision ) { $ roundingFactor = $ roundingIncrement / pow ( 10 , $ precision ) ; $ amount = round ( $ amount / $ roundingFactor ) * $ roundingFactor ; } return $ amount ; }
11334	public function getFormattedValue ( ) { if ( $ this -> format instanceof BaseFormat ) { $ formattedValue = $ this -> format -> get ( ) ; } elseif ( is_callable ( $ this -> format ) || ( is_array ( $ this -> format ) && ! empty ( $ this -> format [ 0 ] ) && is_object ( $ this -> format [ 0 ] ) ) ) { $ formattedValue = $ this -> evaluateExpression ( $ this -> format , [ $ this -> value ] ) ; } else { $ formattedValue = $ this -> value ; } if ( is_object ( $ formattedValue ) ) { $ formattedValue = $ formattedValue -> viewLink ; } return $ formattedValue ; }
6510	protected function initHandler ( HandlerInterface $ handler ) { if ( $ this -> formatter != null ) { $ handler -> setFormatter ( $ this -> formatter ) ; } foreach ( $ this -> processors as $ processor ) { $ handler -> pushProcessor ( $ processor ) ; } return $ handler ; }
7079	public static function getTypes ( ) { return [ self :: TYPE_WEBSITE , self :: TYPE_USER , self :: TYPE_ADMINISTRATOR , self :: TYPE_IN_CHARGE , self :: TYPE_CUSTOMER , self :: TYPE_SALESMAN , self :: TYPE_ACCOUNTABLE , self :: TYPE_SUPPLIER , ] ; }
1638	protected function getGuzzle ( array $ config ) { $ options = [ ] ; if ( isset ( $ config [ 'proxy' ] ) && $ config [ 'proxy' ] ) { if ( isset ( $ config [ 'proxy' ] [ 'http' ] ) && php_sapi_name ( ) != 'cli' ) { unset ( $ config [ 'proxy' ] [ 'http' ] ) ; } $ options [ 'proxy' ] = $ config [ 'proxy' ] ; } return Client :: makeGuzzle ( isset ( $ config [ 'endpoint' ] ) ? $ config [ 'endpoint' ] : null , $ options ) ; }
4357	protected function processLog ( ) { $ str = '' ; foreach ( $ this -> data [ 'log' ] as $ entry ) { $ channel = isset ( $ entry [ 2 ] [ 'channel' ] ) ? $ entry [ 2 ] [ 'channel' ] : null ; if ( $ this -> channelTest ( $ channel ) ) { $ str .= $ this -> processLogEntryWEvent ( $ entry [ 0 ] , $ entry [ 1 ] , $ entry [ 2 ] ) ; } } return $ str ; }
7635	public function getBlockList ( $ containerName = '' , $ blobName = '' , $ snapshotId = null , $ leaseId = null , $ type = 0 ) { Assertion :: notEmpty ( $ containerName , 'Container name is not specified' ) ; self :: assertValidContainerName ( $ containerName ) ; Assertion :: notEmpty ( $ blobName , 'Blob name is not specified.' ) ; if ( $ type < 0 || $ type > 2 ) { throw new BlobException ( 'Invalid type of block list to retrieve.' ) ; } $ blockListType = 'all' ; if ( $ type == 1 ) { $ blockListType = 'committed' ; } if ( $ type == 2 ) { $ blockListType = 'uncommitted' ; } $ headers = array ( ) ; if ( ! is_null ( $ leaseId ) ) { $ headers [ 'x-ms-lease-id' ] = $ leaseId ; } $ query = array ( 'comp' => 'blocklist' , 'blocklisttype' => $ blockListType ) ; if ( ! is_null ( $ snapshotId ) ) { $ query [ 'snapshot' ] = $ snapshotId ; } $ resourceName = self :: createResourceName ( $ containerName , $ blobName ) ; $ response = $ this -> performRequest ( $ resourceName , $ query , 'GET' , $ headers , false , null , self :: RESOURCE_BLOB , self :: PERMISSION_READ ) ; if ( ! $ response -> isSuccessful ( ) ) { throw new BlobException ( $ this -> getErrorMessage ( $ response , 'Resource could not be accessed.' ) ) ; } $ blockList = $ this -> parseResponse ( $ response ) ; $ returnValue = array ( ) ; if ( $ blockList -> CommittedBlocks ) { foreach ( $ blockList -> CommittedBlocks -> Block as $ block ) { $ returnValue [ 'CommittedBlocks' ] [ ] = ( object ) array ( 'Name' => ( string ) $ block -> Name , 'Size' => ( string ) $ block -> Size ) ; } } if ( $ blockList -> UncommittedBlocks ) { foreach ( $ blockList -> UncommittedBlocks -> Block as $ block ) { $ returnValue [ 'UncommittedBlocks' ] [ ] = ( object ) array ( 'Name' => ( string ) $ block -> Name , 'Size' => ( string ) $ block -> Size ) ; } } return $ returnValue ; }
7580	protected function verifyUrl ( ) { $ UrlArray = explode ( "?" , $ this -> Url ) ; if ( strpos ( $ UrlArray [ 0 ] , "$" ) !== false ) { throw new InvalidURLException ( get_called_class ( ) , "Configured URL is " . $ this -> Url ) ; } return true ; }
8102	public function getStatement ( $ sql , $ args = false ) { $ query = $ this -> buildQuery ( $ sql , $ args ) ; if ( $ connection = $ this -> db -> getConnection ( ) ) { if ( $ stmt = $ connection -> prepare ( $ query ) ) { $ this -> log -> report ( "SQL Statement: {$query}" ) ; $ stmt -> setFetchMode ( \ PDO :: FETCH_INTO , new Collection ( ) ) ; if ( $ args ) { $ this -> log -> report ( "SQL Data Sent: [" . implode ( ', ' , $ args ) . "]" ) ; $ stmt -> execute ( $ args ) ; } if ( $ stmt -> errorCode ( ) > 0 ) { $ error = $ stmt -> errorInfo ( ) ; $ this -> log -> error ( "PDO({$error[0]})[{$error[1]}] {$error[2]}" ) ; return false ; } return $ stmt ; } else { $ this -> log -> error ( 'Failed to create a PDO statement with: ' . $ query ) ; return false ; } } else { return false ; } }
11335	public function getFormValue ( ) { if ( $ this -> format instanceof BaseFormat ) { $ formValue = $ this -> format -> getFormValue ( ) ; } elseif ( is_callable ( $ this -> format ) || ( is_array ( $ this -> format ) && ! empty ( $ this -> format [ 0 ] ) && is_object ( $ this -> format [ 0 ] ) ) ) { $ formValue = $ this -> evaluateExpression ( $ this -> format , [ $ this -> value ] ) ; } else { $ formValue = $ this -> value ; } return $ formValue ; }
1439	protected function getStub ( ) { if ( $ this -> isIndependent ) { return $ this -> getStubFor ( 'independent' ) ; } if ( $ this -> isEloquent ( ) ) { return $ this -> getStubFor ( 'eloquent' ) ; } return $ this -> getStubFor ( 'abstract' ) ; }
6845	public static function seconds ( $ step = 1 , $ start = 0 , $ end = 60 ) { $ step = ( int ) $ step ; $ seconds = array ( ) ; for ( $ i = $ start ; $ i < $ end ; $ i += $ step ) { $ seconds [ $ i ] = sprintf ( '%02d' , $ i ) ; } return $ seconds ; }
7514	function next_search ( $ characters , $ callback = true ) { $ this -> token_start = $ this -> pos ; if ( ! is_array ( $ characters ) ) { $ characters = array_fill_keys ( str_split ( $ characters ) , true ) ; } while ( ++ $ this -> pos < $ this -> size ) { if ( isset ( $ characters [ $ this -> doc [ $ this -> pos ] ] ) ) { if ( $ callback && isset ( $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ) { if ( is_string ( $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ) { return ( $ this -> token = $ this -> { $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] } ( ) ) ; } else { return ( $ this -> token = $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ; } } else { return ( $ this -> token = self :: TOK_UNKNOWN ) ; } } else { $ this -> parse_linebreak ( ) ; } } return ( $ this -> token = self :: TOK_NULL ) ; }
3189	public function getLastTimestamp ( $ tags ) { $ range = $ this -> getRange ( $ tags ) ; $ length = count ( $ range ) ; $ last = false ; if ( $ length ) { $ last = $ range [ $ length - 1 ] -> getTimestamp ( ) ; } return $ last ; }
1848	protected function getMetaFields ( $ objArticle ) { $ meta = StringUtil :: deserialize ( $ this -> news_metaFields ) ; if ( ! \ is_array ( $ meta ) ) { return array ( ) ; } global $ objPage ; $ return = array ( ) ; foreach ( $ meta as $ field ) { switch ( $ field ) { case 'date' : $ return [ 'date' ] = Date :: parse ( $ objPage -> datimFormat , $ objArticle -> date ) ; break ; case 'author' : if ( ( $ objAuthor = $ objArticle -> getRelated ( 'author' ) ) instanceof UserModel ) { $ return [ 'author' ] = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'by' ] . ' <span itemprop="author">' . $ objAuthor -> name . '</span>' ; } break ; case 'comments' : if ( $ objArticle -> noComments || $ objArticle -> source != 'default' ) { break ; } $ bundles = System :: getContainer ( ) -> getParameter ( 'kernel.bundles' ) ; if ( ! isset ( $ bundles [ 'ContaoCommentsBundle' ] ) ) { break ; } $ intTotal = CommentsModel :: countPublishedBySourceAndParent ( 'tl_news' , $ objArticle -> id ) ; $ return [ 'ccount' ] = $ intTotal ; $ return [ 'comments' ] = sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'commentCount' ] , $ intTotal ) ; break ; } } return $ return ; }
8012	public static function forChallengeMessage ( $ challenge_message , $ code = 0 , Exception $ previous = null ) { $ message = self :: DEFAULT_MESSAGE ; $ reason_messages = [ ] ; if ( ( self :: CODE_FOR_INVALID_SIGNATURE & $ code ) === self :: CODE_FOR_INVALID_SIGNATURE ) { $ reason_messages [ ] = self :: MESSAGE_FOR_INVALID_SIGNATURE ; } if ( ( self :: CODE_FOR_INVALID_MESSAGE_TYPE & $ code ) === self :: CODE_FOR_INVALID_MESSAGE_TYPE ) { $ reason_messages [ ] = self :: MESSAGE_FOR_INVALID_MESSAGE_TYPE ; } $ message .= sprintf ( self :: MESSAGE_EXTENSION_FOR_REASONS_FORMAT , implode ( self :: MESSAGE_REASON_GLUE , $ reason_messages ) ) ; $ instance = new static ( $ message , $ code , $ previous ) ; $ instance -> challenge_message = $ challenge_message ; return $ instance ; }
7892	public function set ( $ property_name , $ value ) { $ this -> validateProperty ( $ property_name , $ value ) ; $ this -> data [ $ property_name ] = $ value ; return $ this ; }
6579	public function setParts ( array $ parts ) { $ parts = array_intersect_key ( $ parts , $ this -> params ) ; if ( isset ( $ parts [ 'port' ] ) ) $ parts [ 'port' ] = ( int ) $ parts [ 'port' ] ; if ( isset ( $ parts [ 'query' ] ) ) { $ query = $ this -> _parse_str ( $ parts [ 'query' ] ) ; $ this -> _rksort ( $ query ) ; $ parts [ 'query' ] = $ query ; } array_walk ( $ parts , function ( & $ part , $ key ) { if ( is_string ( $ part ) ) { $ part = strlen ( $ part ) ? $ part : null ; } else { $ part = $ part ? : null ; } } ) ; $ self = clone $ this ; $ self -> params = array_replace ( $ this -> params , $ parts ) ; return $ self ; }
12616	public function setAttributes ( array $ attributes ) { foreach ( $ attributes as $ key => $ attribute ) { if ( ! ( $ attribute instanceof AttributeInterface ) ) { if ( is_array ( $ attribute ) ) { $ attr = new AttributeCollection ( $ key ) ; $ attr -> setAttributes ( $ attribute ) ; $ attribute = $ attr ; } else { $ attribute = new Attribute ( $ key , $ attribute ) ; } } $ this -> attributes [ $ attribute -> getName ( ) ] = $ attribute ; } }
11984	public function boot ( ) { if ( $ this -> booted ) { return $ this ; } if ( extension_loaded ( 'pinba' ) ) { ini_set ( 'pinba.enabled' , false ) ; } if ( extension_loaded ( 'newrelic' ) ) { ini_set ( 'newrelic.enabled' , false ) ; } if ( ! empty ( $ this -> settings [ 'timezone' ] ) ) { date_default_timezone_set ( $ this -> settings [ 'timezone' ] ) ; } $ this -> booted = true ; return $ this ; }
2080	public function purgeRegistrations ( ) { $ objMember = MemberModel :: findExpiredRegistrations ( ) ; if ( $ objMember === null ) { return ; } while ( $ objMember -> next ( ) ) { $ objMember -> delete ( ) ; } $ this -> log ( 'Purged the unactivated member registrations' , __METHOD__ , TL_CRON ) ; }
5464	public function isWithin ( $ url ) { if ( $ this -> isIn ( $ this -> root , $ url -> getBasePath ( ) ) ) { return true ; } if ( $ this -> isIn ( $ this -> root , $ url -> getBasePath ( ) . $ url -> getPage ( ) . '/' ) ) { return true ; } return false ; }
1715	public function hasAccess ( $ field , $ array ) { if ( $ this -> isAdmin ) { return true ; } if ( ! \ is_array ( $ field ) ) { $ field = array ( $ field ) ; } if ( \ is_array ( $ this -> $ array ) && array_intersect ( $ field , $ this -> $ array ) ) { return true ; } elseif ( $ array == 'filemounts' ) { foreach ( $ this -> filemounts as $ folder ) { if ( preg_match ( '/^' . preg_quote ( $ folder , '/' ) . '(\/|$)/i' , $ field [ 0 ] ) ) { return true ; } } } return false ; }
7044	private function getMetaModelTableNames ( $ keyTranslated , $ keyUntranslated ) { $ result = [ ] ; foreach ( $ this -> factory -> collectNames ( ) as $ table ) { $ metaModel = $ this -> factory -> getMetaModel ( $ table ) ; if ( null === $ metaModel ) { continue ; } if ( $ metaModel -> isTranslated ( ) ) { $ result [ $ keyTranslated ] [ $ table ] = \ sprintf ( '%s (%s)' , $ metaModel -> get ( 'name' ) , $ table ) ; } else { $ result [ $ keyUntranslated ] [ $ table ] = \ sprintf ( '%s (%s)' , $ metaModel -> get ( 'name' ) , $ table ) ; } } return $ result ; }
4209	private function methodInfo ( $ obj , \ ReflectionMethod $ reflectionMethod ) { $ declaringClassName = $ reflectionMethod -> getDeclaringClass ( ) -> getName ( ) ; $ phpDoc = $ this -> phpDoc -> getParsed ( $ reflectionMethod ) ; $ vis = 'public' ; if ( $ reflectionMethod -> isPrivate ( ) ) { $ vis = 'private' ; } elseif ( $ reflectionMethod -> isProtected ( ) ) { $ vis = 'protected' ; } $ info = array ( 'implements' => null , 'inheritedFrom' => $ declaringClassName != \ get_class ( $ obj ) ? $ declaringClassName : null , 'isAbstract' => $ reflectionMethod -> isAbstract ( ) , 'isDeprecated' => $ reflectionMethod -> isDeprecated ( ) || isset ( $ phpDoc [ 'deprecated' ] ) , 'isFinal' => $ reflectionMethod -> isFinal ( ) , 'isStatic' => $ reflectionMethod -> isStatic ( ) , 'params' => $ this -> getParams ( $ reflectionMethod , $ phpDoc ) , 'phpDoc' => $ phpDoc , 'visibility' => $ vis , ) ; unset ( $ info [ 'phpDoc' ] [ 'param' ] ) ; return $ info ; }
8900	public function update_by ( ) { $ args = func_get_args ( ) ; $ data = array_pop ( $ args ) ; $ data = $ this -> _do_pre_update ( $ data ) ; if ( $ data !== FALSE ) { $ this -> _set_where ( $ args ) ; return $ this -> _update ( $ data ) ; } return FALSE ; }
7807	protected function closingBalance ( $ text ) { if ( $ line = $ this -> getLine ( '62M' , $ text ) ) { return $ this -> balance ( $ this -> reader -> createClosingBalance ( ) , $ line ) ; } }
6093	public function section ( $ separator , $ first = 0 , $ last = 0 ) { $ sections = explode ( $ separator , $ this -> string ) ; $ total = count ( $ sections ) ; $ first = intval ( $ first ) ; $ last = intval ( $ last ) ; if ( $ first > $ total ) { return null ; } if ( $ first > $ last ) { $ last = $ first ; } for ( $ i = 0 ; $ i < $ total ; $ i ++ ) { if ( $ i < $ first || $ i > $ last ) { unset ( $ sections [ $ i ] ) ; } } $ string = implode ( $ separator , $ sections ) ; return new self ( $ string ) ; }
6070	public function downloadArchive ( array $ ids , $ template = null , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'ids' => $ ids , 'template' => $ template ] , 'body' => json_encode ( [ ] ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/media/download' , $ parameters , $ cachePolicy ) ; return $ result ; }
7564	protected function parse_compare ( ) { if ( ( ( $ this -> pos + 1 ) < $ this -> size ) && ( $ this -> doc [ $ this -> pos + 1 ] === '=' ) ) { switch ( $ this -> doc [ $ this -> pos ++ ] ) { case '$' : return ( $ this -> token = self :: TOK_COMPARE_ENDS ) ; case '%' : return ( $ this -> token = self :: TOK_COMPARE_REGEX ) ; case '^' : return ( $ this -> token = self :: TOK_COMPARE_STARTS ) ; case '<' : return ( $ this -> token = self :: TOK_COMPARE_SMALLER_THAN ) ; } } return false ; }
10649	private function buildUniqueRules ( ) { $ rulescopes = $ this -> rules ; foreach ( $ rulescopes as $ scope => & $ rules ) { foreach ( $ rules as $ field => & $ ruleset ) { $ ruleset = ( is_string ( $ ruleset ) ) ? explode ( '|' , $ ruleset ) : $ ruleset ; foreach ( $ ruleset as & $ rule ) { if ( str_contains ( $ rule , 'unique' ) && str_contains ( $ rule , '{id}' ) == false ) { $ params = explode ( ',' , $ rule ) ; $ uniqueRules = array ( ) ; $ table = explode ( ':' , $ params [ 0 ] ) ; if ( count ( $ table ) == 1 ) $ uniqueRules [ 1 ] = $ this -> table ; else $ uniqueRules [ 1 ] = $ table [ 1 ] ; if ( count ( $ params ) == 1 ) $ uniqueRules [ 2 ] = $ field ; else $ uniqueRules [ 2 ] = $ params [ 1 ] ; $ uniqueRules [ 3 ] = $ this -> getKey ( ) ; $ uniqueRules [ 4 ] = $ this -> getKeyName ( ) ; $ rule = 'unique:' . implode ( ',' , $ uniqueRules ) ; } elseif ( str_contains ( $ rule , 'unique' ) && str_contains ( $ rule , '{id}' ) ) { $ rule = str_replace ( '{id}' , $ this -> getKey ( ) , $ rule ) ; } } } } $ this -> rules = $ rulescopes ; }
9570	public function addMiddleware ( $ middleware , $ priority = null ) { $ this -> middlewares -> insert ( $ middleware , ( int ) $ priority ) ; }
11546	public function changeSecurityQuestion ( $ data ) { if ( ! ( $ user = $ this -> hydrate ( $ data , $ this -> getChangeSecurityQuestionForm ( ) ) ) ) { return ; } $ eventManager = $ this -> getEventManager ( ) ; $ eventManager -> trigger ( __METHOD__ , $ this , $ user ) ; $ this -> getMapper ( ) -> update ( $ user ) -> save ( ) ; $ eventManager -> trigger ( __METHOD__ . '.post' , $ this , $ user ) ; return $ user ; }
7236	private function phoneNumberCountry ( PhoneNumber $ phoneNumber = null ) { if ( $ phoneNumber ) { return $ this -> phoneNumberUtil -> getRegionCodeForNumber ( $ phoneNumber ) ; } return null ; }
8931	private function addRoute ( $ method ) { switch ( $ method ) { case 'index' : $ methodMap = [ 'GET' ] ; $ realRoute = '$route' ; $ controllerCallable = $ this -> controllerLocation . ':indexAction' ; break ; case 'get' : $ methodMap = [ 'GET' ] ; $ realRoute = '$route/{id}' ; $ controllerCallable = $ this -> controllerLocation . ':getAction' ; break ; case 'post' : $ methodMap = [ 'POST' ] ; $ realRoute = '$route' ; $ controllerCallable = $ this -> controllerLocation . ':postAction' ; break ; case 'put' : $ methodMap = [ 'POST' , 'PUT' ] ; $ realRoute = '$route/{id}' ; $ controllerCallable = $ this -> controllerLocation . ':putAction' ; break ; case 'delete' : $ methodMap = [ 'DELETE' ] ; $ realRoute = '$route/{id}' ; $ controllerCallable = $ this -> controllerLocation . ':deleteAction' ; break ; default : throw new \ Exception ( 'Invalid method.' . $ method ) ; break ; } $ methodMap = "['" . implode ( "', '" , $ methodMap ) . "']" ; $ command = strtr ( $ this -> template , [ '$methodMap' => $ methodMap , '$route' => $ realRoute , '$controllerCallable' => $ controllerCallable ] ) ; $ this -> commands [ ] = $ command ; }
12379	public function handle ( ) : void { $ help = " -----------------------------------------------------------------\n" ; $ help .= " | Command Line Interface\n" ; $ help .= " | See more in https://github.com/senhungwong/command-line-interface\n" ; $ help .= " -------------------------------------------------------------------\n" ; $ commands = CommandEntry :: getCommands ( ) ; if ( $ command = $ this -> getArgument ( 'function-name' ) ) { $ command = new $ commands [ $ command ] ; $ help .= " - " . $ command -> getCommand ( ) . ": " ; $ help .= $ command -> getDescription ( ) . "\n" ; } else { foreach ( $ commands as $ command ) { $ command = new $ command ; $ help .= " - " ; $ help .= $ command -> getCommand ( ) . ": " ; $ help .= $ command -> getDescription ( ) . "\n" ; } } echo $ help ; }
9948	public function getColumnDimension ( $ pColumn , $ create = true ) { $ pColumn = strtoupper ( $ pColumn ) ; if ( ! isset ( $ this -> columnDimensions [ $ pColumn ] ) ) { if ( ! $ create ) { return null ; } $ this -> columnDimensions [ $ pColumn ] = new ColumnDimension ( $ pColumn ) ; if ( Coordinate :: columnIndexFromString ( $ this -> cachedHighestColumn ) < Coordinate :: columnIndexFromString ( $ pColumn ) ) { $ this -> cachedHighestColumn = $ pColumn ; } } return $ this -> columnDimensions [ $ pColumn ] ; }
11620	public function auth ( ) : \ TheCMSThread \ Core \ Main \ Auth { static $ auth ; if ( $ auth === null ) { $ auth = $ this -> container -> get ( "TheCMSThread\\Core\\Main\\Auth" ) ; } $ auth -> __construct ( ) ; return $ auth ; }
8909	public function serialize_row ( $ row ) { foreach ( $ this -> callback_parameters as $ column ) { $ row [ $ column ] = serialize ( $ row [ $ column ] ) ; } return $ row ; }
7175	public static function set_path ( & $ array , $ path , $ value , $ delimiter = null ) : void { if ( ! $ delimiter ) { $ delimiter = static :: $ delimiter ; } $ keys = $ path ; if ( ! is_array ( $ path ) ) { $ keys = explode ( $ delimiter , $ path ) ; } while ( count ( $ keys ) > 1 ) { $ key = array_shift ( $ keys ) ; if ( is_string ( $ key ) && ctype_digit ( $ key ) ) { $ key = ( int ) $ key ; } if ( ! isset ( $ array [ $ key ] ) ) { $ array [ $ key ] = array ( ) ; } $ array = & $ array [ $ key ] ; } $ array [ array_shift ( $ keys ) ] = $ value ; }
3428	public function paginate ( $ perPage = 15 , $ pageName = 'page' ) { $ page = Paginator :: resolveCurrentPage ( $ pageName ) ; $ total = $ this -> count ( ) ; $ results = $ this -> forPage ( $ page , $ perPage ) -> getList ( ) ; return new LengthAwarePaginator ( $ results , $ total , $ perPage , $ page , [ 'path' => Paginator :: resolveCurrentPath ( ) , 'pageName' => $ pageName , ] ) ; }
12954	public static function priceStringToInt ( string $ str , string $ propertyPath = '' ) : int { $ str = trim ( $ str ) ; if ( ! preg_match ( '/(\.|,)[0-9]{2}$/' , $ str ) ) { throw new \ InvalidArgumentException ( ( $ propertyPath ? $ propertyPath . ' (value: "' . $ str . '")' : $ str ) . ' does not match the currency string format' ) ; } $ str = preg_replace ( '/[^0-9]+/' , '' , $ str ) ; return intval ( $ str ) ; }
9272	protected function dataToMultipart ( array $ data = [ ] ) { $ multipart = [ ] ; foreach ( $ data as $ name => $ contents ) { array_push ( $ multipart , [ 'name' => $ name , 'contents' => $ contents ] ) ; } return $ multipart ; }
8037	public static function revert ( $ input , $ inputFormat = Code :: FORMAT_ALNUM , $ minLength = null ) { $ number = self :: convertBase ( $ input , $ inputFormat , Code :: FORMAT_NUMBER ) ; if ( is_int ( $ minLength ) ) { $ number -= self :: getMinForlength ( $ inputFormat , $ minLength ) ; } return $ number ; }
1094	public function roots ( ) { return $ this -> node -> newQuery ( ) -> whereNull ( $ this -> node -> getQualifiedParentColumnName ( ) ) -> orderBy ( $ this -> node -> getQualifiedLeftColumnName ( ) ) -> orderBy ( $ this -> node -> getQualifiedRightColumnName ( ) ) -> orderBy ( $ this -> node -> getQualifiedKeyName ( ) ) -> get ( ) ; }
10479	protected function inlineContext ( $ selectQuery , $ itemRow ) { $ selectQuery = str_replace ( [ 'OLD.' , 'NEW.' ] , '__ctx__' , $ selectQuery ) ; $ prefixedKeys = array_map ( function ( $ key ) { return '__ctx__' . $ key ; } , array_keys ( $ itemRow ) ) ; $ connection = $ this -> getConnection ( ) ; $ escapedValues = array_map ( function ( $ value ) use ( $ connection ) { return $ connection -> quote ( $ value ) ; } , array_values ( $ itemRow ) ) ; $ sql = str_replace ( $ prefixedKeys , $ escapedValues , $ selectQuery ) ; return $ sql ; }
9982	private function writeVMLComment ( XMLWriter $ objWriter , $ pCellReference , Comment $ pComment ) { list ( $ column , $ row ) = Coordinate :: coordinateFromString ( $ pCellReference ) ; $ column = Coordinate :: columnIndexFromString ( $ column ) ; $ id = 1024 + $ column + $ row ; $ id = substr ( $ id , 0 , 4 ) ; $ objWriter -> startElement ( 'v:shape' ) ; $ objWriter -> writeAttribute ( 'id' , '_x0000_s' . $ id ) ; $ objWriter -> writeAttribute ( 'type' , '#_x0000_t202' ) ; $ objWriter -> writeAttribute ( 'style' , 'position:absolute;margin-left:' . $ pComment -> getMarginLeft ( ) . ';margin-top:' . $ pComment -> getMarginTop ( ) . ';width:' . $ pComment -> getWidth ( ) . ';height:' . $ pComment -> getHeight ( ) . ';z-index:1;visibility:' . ( $ pComment -> getVisible ( ) ? 'visible' : 'hidden' ) ) ; $ objWriter -> writeAttribute ( 'fillcolor' , '#' . $ pComment -> getFillColor ( ) -> getRGB ( ) ) ; $ objWriter -> writeAttribute ( 'o:insetmode' , 'auto' ) ; $ objWriter -> startElement ( 'v:fill' ) ; $ objWriter -> writeAttribute ( 'color2' , '#' . $ pComment -> getFillColor ( ) -> getRGB ( ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'v:shadow' ) ; $ objWriter -> writeAttribute ( 'on' , 't' ) ; $ objWriter -> writeAttribute ( 'color' , 'black' ) ; $ objWriter -> writeAttribute ( 'obscured' , 't' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'v:path' ) ; $ objWriter -> writeAttribute ( 'o:connecttype' , 'none' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'v:textbox' ) ; $ objWriter -> writeAttribute ( 'style' , 'mso-direction-alt:auto' ) ; $ objWriter -> startElement ( 'div' ) ; $ objWriter -> writeAttribute ( 'style' , 'text-align:left' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'x:ClientData' ) ; $ objWriter -> writeAttribute ( 'ObjectType' , 'Note' ) ; $ objWriter -> writeElement ( 'x:MoveWithCells' , '' ) ; $ objWriter -> writeElement ( 'x:SizeWithCells' , '' ) ; $ objWriter -> writeElement ( 'x:AutoFill' , 'False' ) ; $ objWriter -> writeElement ( 'x:Row' , ( $ row - 1 ) ) ; $ objWriter -> writeElement ( 'x:Column' , ( $ column - 1 ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; }
10799	public function renderPageHistoricAction ( ) { $ idPage = $ this -> params ( ) -> fromRoute ( 'idPage' , $ this -> params ( ) -> fromQuery ( 'idPage' , '' ) ) ; $ melisKey = $ this -> params ( ) -> fromRoute ( 'melisKey' , '' ) ; $ view = new ViewModel ( ) ; $ view -> idPage = $ idPage ; $ view -> melisKey = $ melisKey ; return $ view ; }
11280	public static function getErrorString ( int $ errno ) { $ errno = intval ( $ errno ) ; $ errors = array ( E_ERROR => 'E_ERROR' , E_WARNING => 'E_WARNING' , E_PARSE => 'E_PARSE' , E_NOTICE => 'E_NOTICE' , E_CORE_ERROR => 'E_CORE_ERROR' , E_CORE_WARNING => 'E_CORE_WARNING' , E_COMPILE_ERROR => 'E_COMPILE_ERROR' , E_COMPILE_WARNING => 'E_COMPILE_WARNING' , E_USER_ERROR => 'E_USER_ERROR' , E_USER_NOTICE => 'E_USER_NOTICE' , E_STRICT => 'E_STRICT' , E_RECOVERABLE_ERROR => 'E_RECOVERABLE_ERROR' , ) ; $ errors [ 8192 ] = 'E_DEPRECATED' ; $ errors [ 16384 ] = 'E_USER_DEPRECATED' ; $ errors_desc = array ( ) ; foreach ( $ errors as $ key => $ value ) { if ( ( $ errno & $ key ) != 0 ) { $ errors_desc [ ] = $ value ; } } return implode ( '|' , $ errors_desc ) ; }
999	public function getType ( $ name ) { if ( ! isset ( $ this -> resolvedTypes [ $ name ] ) ) { $ type = $ this -> loadType ( $ name ) ; if ( ! $ type ) { return null ; } $ this -> resolvedTypes [ $ name ] = $ type ; } return $ this -> resolvedTypes [ $ name ] ; }
10252	public function getLastName ( $ max = 250 ) { return LastName :: where ( 'rank' , '<=' , $ max ) -> orderByRaw ( Database :: random ( ) ) -> first ( ) -> name ; }
3523	public function id ( $ id ) { foreach ( $ this -> items as $ item ) { if ( $ item -> itemId == $ id ) return $ item ; } return null ; }
6726	public function get_movie_votes ( $ post_id ) { $ votes = get_post_meta ( $ post_id , 'imdbTotalVotes' , true ) ; if ( ! empty ( $ votes ) ) { return json_decode ( $ votes , true ) ; } return false ; }
3086	public function getAdaptiveAssessmentSectionInfo ( AssessmentTest $ test , \ tao_models_classes_service_StorageDirectory $ compilationDirectory , $ basePath , $ qtiAssessmentSectionIdentifier ) { $ info = CatUtils :: getCatInfo ( $ test ) ; $ adaptiveInfo = [ 'qtiSectionIdentifier' => $ qtiAssessmentSectionIdentifier , 'adaptiveSectionIdentifier' => false , 'adaptiveEngineRef' => false ] ; if ( isset ( $ info [ $ qtiAssessmentSectionIdentifier ] ) ) { if ( isset ( $ info [ $ qtiAssessmentSectionIdentifier ] [ 'adaptiveEngineRef' ] ) ) { $ adaptiveInfo [ 'adaptiveEngineRef' ] = $ info [ $ qtiAssessmentSectionIdentifier ] [ 'adaptiveEngineRef' ] ; } if ( isset ( $ info [ $ qtiAssessmentSectionIdentifier ] [ 'adaptiveSettingsRef' ] ) ) { $ adaptiveInfo [ 'adaptiveSectionIdentifier' ] = trim ( $ compilationDirectory -> read ( "./${basePath}/" . $ info [ $ qtiAssessmentSectionIdentifier ] [ 'adaptiveSettingsRef' ] ) ) ; } } return ( ! isset ( $ info [ $ qtiAssessmentSectionIdentifier ] [ 'adaptiveEngineRef' ] ) || ! isset ( $ info [ $ qtiAssessmentSectionIdentifier ] [ 'adaptiveSettingsRef' ] ) ) ? false : $ adaptiveInfo ; }
12881	public function getForeignDataItem ( $ key ) { if ( ! isset ( $ this -> _foreignDataItems [ $ key ] ) ) { $ this -> createForeignDataItem ( null , [ 'foreignPrimaryKey' => $ key ] ) ; } if ( isset ( $ this -> _foreignDataItems [ $ key ] ) ) { return $ this -> _foreignDataItems [ $ key ] ; } return false ; }
9601	public function add ( self $ b ) { $ this -> _checkVectorSpace ( $ b ) ; $ bComponents = $ b -> components ( ) ; $ sum = [ ] ; foreach ( $ this -> components ( ) as $ i => $ component ) { $ sum [ $ i ] = $ component + $ bComponents [ $ i ] ; } return new static ( $ sum ) ; }
70	public function createLoader ( array $ autoloads ) { $ loader = new ClassLoader ( ) ; if ( isset ( $ autoloads [ 'psr-0' ] ) ) { foreach ( $ autoloads [ 'psr-0' ] as $ namespace => $ path ) { $ loader -> add ( $ namespace , $ path ) ; } } if ( isset ( $ autoloads [ 'psr-4' ] ) ) { foreach ( $ autoloads [ 'psr-4' ] as $ namespace => $ path ) { $ loader -> addPsr4 ( $ namespace , $ path ) ; } } if ( isset ( $ autoloads [ 'classmap' ] ) ) { $ blacklist = null ; if ( ! empty ( $ autoloads [ 'exclude-from-classmap' ] ) ) { $ blacklist = '{(' . implode ( '|' , $ autoloads [ 'exclude-from-classmap' ] ) . ')}' ; } foreach ( $ autoloads [ 'classmap' ] as $ dir ) { try { $ loader -> addClassMap ( $ this -> generateClassMap ( $ dir , $ blacklist , null , false ) ) ; } catch ( \ RuntimeException $ e ) { $ this -> io -> writeError ( '<warning>' . $ e -> getMessage ( ) . '</warning>' ) ; } } } return $ loader ; }
3183	private function durationToMs ( $ duration ) { if ( ! is_null ( $ duration ) && $ duration instanceof QtiDuration ) { return TestRunnerUtils :: getDurationWithMicroseconds ( $ duration ) ; } return false ; }
11464	public static function error ( $ severity , $ message , $ file , $ line ) { if ( error_reporting ( ) == 0 ) return ; elseif ( error_reporting ( ) && $ severity ) { $ ErrorException = new PHPErrorException ( $ message , 0 , $ severity , $ file , $ line ) ; if ( assert_options ( ASSERT_ACTIVE ) ) { foreach ( $ ErrorException -> getStackTrace ( ) as $ element ) { if ( isset ( $ element [ 'function' ] ) && $ element [ 'function' ] == 'assert' ) { self :: exception ( $ ErrorException ) ; } } } $ recoverable = [ E_WARNING , E_NOTICE , E_USER_WARNING , E_USER_NOTICE , E_STRICT , E_DEPRECATED , E_USER_DEPRECATED ] ; if ( in_array ( $ severity , $ recoverable ) ) { return ; } throw $ ErrorException ; } }
9540	private function getParameterClosure ( $ parameter ) { $ parameterClosure = null ; foreach ( array_keys ( $ this -> parameterCluster -> prefixes ) as $ prefix ) { if ( substr ( $ parameter , 0 , strlen ( $ prefix ) ) == $ prefix ) { @ $ parameterClosure = $ this -> parameterCluster -> prefixes [ $ prefix ] [ substr ( $ parameter , strlen ( $ prefix ) , strlen ( $ parameter ) - strlen ( $ prefix ) ) ] ; } } return $ parameterClosure ; }
6635	public function bootstrap ( $ app ) { Yii :: setAlias ( '@wavecms' , '@vendor/mrstroz/yii2-wavecms' ) ; if ( $ app -> id === 'app-backend' || $ app -> id === 'app-frontend' ) { Yii :: setAlias ( '@frontWeb' , str_replace ( '/admin' , '' , Yii :: getAlias ( '@web' ) ) ) ; Yii :: setAlias ( '@frontWebroot' , str_replace ( '/public/admin' , '/public' , Yii :: getAlias ( '@webroot' ) ) ) ; } if ( $ app -> id === 'app-backend' ) { if ( ! Yii :: $ app -> user -> isGuest ) { Yii :: $ app -> language = Yii :: $ app -> user -> identity -> lang ; } } $ this -> initTranslations ( ) ; if ( $ app -> hasModule ( 'wavecms' ) && ( $ module = $ app -> getModule ( 'wavecms' ) ) instanceof Module ) { if ( $ app instanceof ConsoleApplication ) { $ module -> controllerNamespace = 'mrstroz\wavecms\commands' ; } else { $ module -> controllerNamespace = 'mrstroz\wavecms\controllers' ; if ( $ app -> id === 'app-backend' ) { Yii :: $ app -> errorHandler -> errorAction = $ module -> errorAction ; $ app -> set ( 'wavecms' , [ 'class' => 'mrstroz\wavecms\WavecmsComponent' , 'languages' => $ module -> languages ] ) ; $ app -> set ( 'cacheFrontend' , [ 'class' => 'yii\caching\FileCache' , 'cachePath' => Yii :: getAlias ( '@frontend' ) . '/runtime/cache' ] ) ; $ app -> set ( 'settings' , [ 'class' => 'yii2mod\settings\components\Settings' , ] ) ; Yii :: $ app -> assetManager -> appendTimestamp = true ; Yii :: $ app -> i18n -> translations [ 'yii2mod.settings' ] = [ 'class' => 'yii\i18n\PhpMessageSource' , 'basePath' => '@yii2mod/settings/messages' ] ; $ this -> initContainer ( $ module ) ; $ this -> initLanguages ( ) ; $ this -> initParams ( ) ; $ this -> initRoutes ( $ app , $ module ) ; $ this -> initNavigation ( ) ; } } } }
12475	public function getCurrentTheme ( ) { $ theme = $ this -> getDefaultTheme ( ) ; if ( $ this -> container -> get ( 'session' ) -> has ( '_admin_theme' ) ) { $ theme = $ this -> container -> get ( 'session' ) -> get ( '_admin_theme' ) ; } return $ theme ; }
6036	public function addCommand ( $ item ) { if ( ! ( $ item instanceof Command ) ) { if ( is_array ( $ item ) ) { try { $ item = new Command ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate Command. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "Command"!' , E_USER_WARNING ) ; } } $ this -> commands [ ] = $ item ; return $ this ; }
11202	public function toArray ( ) { $ collection = $ this -> getIterator ( ) ; $ plainArray = [ ] ; foreach ( $ collection as $ prop => $ result ) { if ( is_object ( $ result ) && method_exists ( $ result , 'toArray' ) ) { $ plainArray [ ] = $ result -> toArray ( ) ; } else { $ plainArray [ ] = $ result ; } } return $ plainArray ; }
83	private function copyFiles ( $ files , $ source , $ target , $ roles , $ vars ) { foreach ( $ files as $ file ) { $ from = $ this -> combine ( $ source , $ file [ 'from' ] ) ; $ to = $ this -> combine ( $ target , $ roles [ $ file [ 'role' ] ] ) ; $ to = $ this -> combine ( $ to , $ file [ 'to' ] ) ; $ tasks = $ file [ 'tasks' ] ; $ this -> copyFile ( $ from , $ to , $ tasks , $ vars ) ; } }
12318	protected function searchQuery ( Builder $ query , string $ phrase ) { return $ query -> where ( function ( Builder $ query ) use ( $ phrase ) { $ query -> where ( 'url' , 'LIKE' , '%' . $ phrase . '%' ) -> orWhere ( 'short_url_key' , 'LIKE' , '%' . $ phrase . '%' ) -> orWhere ( 'clicks' , 'LIKE' , '%' . $ phrase . '%' ) -> orWhere ( 'url' , 'LIKE' , '%' . $ phrase . '%' ) ; } ) ; }
11326	public static function removeSuffix ( $ string , $ suffix ) { if ( static :: hasSuffix ( $ string , $ suffix ) ) { return substr ( $ string , 0 , - strlen ( $ suffix ) ) ; } return $ string ; }
5692	public function baseTransform ( ) { parent :: baseTransform ( ) ; Requirements :: javascript ( BETTER_BUTTONS_DIR . '/javascript/gridfield_betterbuttons_delete.js' ) ; return $ this -> setUseButtonTag ( true ) -> addExtraClass ( 'btn-danger-outline btn-hide-outline font-icon-trash-bin gridfield-better-buttons-delete' ) -> setAttribute ( "data-toggletext" , _t ( 'GridFieldBetterButtons.AREYOUSURE' , 'Yes. Delete this item.' ) ) -> setAttribute ( "data-confirmtext" , _t ( 'GridFieldDetailForm.CANCELDELETE' , 'No. Don\'t delete.' ) ) ; }
2284	protected static function ip ( ) { $ request = System :: getContainer ( ) -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; if ( $ request === null ) { return '' ; } return $ request -> getClientIp ( ) ; }
3780	protected function getFilteredAttribute ( ) { if ( ! ( $ attributeId = $ this -> get ( 'attr_id' ) ) ) { return null ; } if ( $ attribute = $ this -> getMetaModel ( ) -> getAttributeById ( $ attributeId ) ) { return $ attribute ; } return null ; }
8300	public function handleEvent ( $ eventName , array $ params ) { parent :: handleEvent ( $ eventName , $ params ) ; if ( $ this -> isEnabled ( ) ) { $ this -> picoAuthPlugin -> handleEvent ( $ eventName , $ params ) ; } }
3556	public function setMetaGroup ( $ group = null ) { if ( ! preg_match ( '/^[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*$/' , $ group ) && $ group !== null ) { throw new InvalidArgumentException ( "Provided group [{$group}] is not valid variable name." ) ; } $ this -> attributes [ 'meta_group' ] = $ group ; }
10756	public function map ( $ method , $ route , $ target , $ name = null , $ hostGroup = null , $ prepend = false ) { if ( ! $ hostGroup ) { $ hostGroup = null ; } if ( $ prepend ) { array_unshift ( $ this -> routes , array ( $ method , $ route , $ target , $ name , $ hostGroup ) ) ; } else { $ this -> routes [ ] = array ( $ method , $ route , $ target , $ name , $ hostGroup ) ; } if ( $ name ) { if ( array_key_exists ( $ name , $ this -> namedRoutes ) ) { throw new HaltoRouterException ( "Can not redeclare route $name" ) ; } $ this -> namedRoutes [ $ name ] = array ( $ route , $ hostGroup ) ; } return $ this ; }
6289	public function set ( $ theme ) { if ( ! $ this -> has ( $ theme ) ) { throw new ThemeNotFoundException ( $ theme ) ; } $ this -> loadTheme ( $ theme ) ; }
8367	public static function get ( string $ name ) : array { if ( isset ( self :: $ mappings [ $ name ] ) === false ) { throw new MappingNotFound ( 'there\'s no registered mapping with name "' . $ name . '"' ) ; } return self :: $ mappings [ $ name ] ; }
4887	public function createAttachedEntity ( $ entityClass , $ values = [ ] , $ key = null ) { if ( is_string ( $ values ) ) { $ key = $ values ; $ values = [ ] ; } $ entity = $ this -> repositories -> getRepository ( $ entityClass ) -> create ( $ values ) ; $ this -> addAttachedEntity ( $ entity , $ key ) ; return $ entity ; }
2300	public static function getSystemMessages ( ) { $ strMessages = '' ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getSystemMessages' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getSystemMessages' ] ) ) { $ arrMessages = array ( ) ; foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getSystemMessages' ] as $ callback ) { $ strBuffer = System :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( ) ; if ( $ strBuffer != '' ) { $ arrMessages [ ] = $ strBuffer ; } } if ( ! empty ( $ arrMessages ) ) { $ strMessages .= implode ( "\n" , $ arrMessages ) ; } } return $ strMessages ; }
1676	public function getModel ( ) { if ( $ this -> objModel === null && Dbafs :: shouldBeSynchronized ( $ this -> strFolder ) ) { $ this -> objModel = FilesModel :: findByPath ( $ this -> strFolder ) ; } return $ this -> objModel ; }
11781	public function fromEntityToDb ( $ document ) { $ unitOfWork = $ this -> documentManager -> getUnitOfWork ( ) ; $ persistenceBuilder = new PersistenceBuilder ( $ this -> documentManager , $ unitOfWork ) ; $ mapping = array ( 'targetDocument' => $ this -> documentClass , ) ; return $ persistenceBuilder -> prepareEmbeddedDocumentValue ( $ mapping , $ document , true ) ; }
9901	public function parse ( $ formula ) { $ this -> currentCharacter = 0 ; $ this -> formula = $ formula ; $ this -> lookAhead = isset ( $ formula [ 1 ] ) ? $ formula [ 1 ] : '' ; $ this -> advance ( ) ; $ this -> parseTree = $ this -> condition ( ) ; return true ; }
11618	private function compressPhase2 ( $ calcIdWriteOff , $ calcIdPhase1 , $ calcIdPhase2 , $ scheme ) { $ pv = $ this -> rouGetPv -> exec ( $ calcIdWriteOff ) ; $ dwnlPlain = $ this -> daoBonDwnl -> getByCalcId ( $ calcIdWriteOff ) ; $ dwnlPhase1 = $ this -> daoBonDwnl -> getByCalcId ( $ calcIdPhase1 ) ; $ ctx = new \ Praxigento \ Core \ Data ( ) ; $ ctx -> set ( PCpmrsPhase2 :: IN_CALC_ID_PHASE2 , $ calcIdPhase2 ) ; $ ctx -> set ( PCpmrsPhase2 :: IN_SCHEME , $ scheme ) ; $ ctx -> set ( PCpmrsPhase2 :: IN_DWNL_PLAIN , $ dwnlPlain ) ; $ ctx -> set ( PCpmrsPhase2 :: IN_DWNL_PHASE1 , $ dwnlPhase1 ) ; $ ctx -> set ( PCpmrsPhase2 :: IN_MAP_PV , $ pv ) ; $ out = $ this -> procCmprsPhase2 -> exec ( $ ctx ) ; $ dwnlPhase2 = $ out -> get ( PCpmrsPhase2 :: OUT_DWNL_PHASE2 ) ; $ legs = $ out -> get ( PCpmrsPhase2 :: OUT_LEGS ) ; $ result = [ $ dwnlPhase2 , $ legs ] ; return $ result ; }
1283	public function addUnknownField ( string $ name ) : Field { $ this -> fields [ $ name ] = new Field ( $ name , $ name , 'Unknown' ) ; return $ this -> fields [ $ name ] ; }
1559	protected function fillAttributes ( $ record , Collection $ attributes ) { $ record -> fill ( $ this -> deserializeAttributes ( $ attributes , $ record ) ) ; }
4081	public function getRenderSetting ( $ metaModel ) { $ metaModelName = $ this -> getMetaModelName ( $ metaModel ) ; return isset ( $ this -> information [ $ metaModelName ] [ self :: COMBINATION ] [ 'view_id' ] ) ? $ this -> information [ $ metaModelName ] [ self :: COMBINATION ] [ 'view_id' ] : null ; }
3105	public function getStoreId ( ) { return isset ( $ this -> state [ self :: VAR_STORE_ID ] ) ? $ this -> state [ self :: VAR_STORE_ID ] : false ; }
12283	public function render ( array $ data = null ) : string { $ this -> init ( $ data ?? [ ] ) ; return trim ( $ this -> make ( static :: LAYOUT_NAME ) ) . PHP_EOL ; }
12966	public function getObjectTypeDescriptor ( ) { if ( is_null ( $ this -> _objectTypeDescriptor ) && isset ( $ this -> object ) ) { $ this -> _objectTypeDescriptor = $ this -> object -> objectType -> title -> upperSingular ; } return $ this -> _objectTypeDescriptor ; }
2115	private function getFieldValue ( ? PageModel $ page ) : string { if ( null === $ page ) { return '' ; } return ( string ) $ page -> { $ this -> field } ; }
5565	public function head ( $ url , $ parameters = false ) { if ( ! is_object ( $ url ) ) { $ url = new SimpleUrl ( $ url ) ; } if ( $ this -> getUrl ( ) ) { $ url = $ url -> makeAbsolute ( $ this -> getUrl ( ) ) ; } $ response = $ this -> user_agent -> fetchResponse ( $ url , new SimpleHeadEncoding ( $ parameters ) ) ; $ this -> page = new SimplePage ( $ response ) ; return ! $ response -> isError ( ) ; }
12776	protected function write ( $ namespace , array $ data ) { $ file = $ this -> adapter -> getFileName ( $ namespace ) ; $ contents = $ this -> adapter -> prepareForWriting ( $ data ) ; if ( ! $ this -> fileSystem -> has ( $ file ) ) { $ this -> fileSystem -> write ( $ file , $ contents ) ; } $ this -> fileSystem -> update ( $ file , $ contents ) ; }
1883	public static function find ( array $ arrOptions ) { $ objBase = DcaExtractor :: getInstance ( $ arrOptions [ 'table' ] ) ; if ( ! $ objBase -> hasRelations ( ) ) { $ strQuery = "SELECT * FROM " . $ arrOptions [ 'table' ] ; } else { $ arrJoins = array ( ) ; $ arrFields = array ( $ arrOptions [ 'table' ] . ".*" ) ; $ intCount = 0 ; foreach ( $ objBase -> getRelations ( ) as $ strKey => $ arrConfig ) { if ( $ arrConfig [ 'load' ] == 'eager' || $ arrOptions [ 'eager' ] ) { if ( $ arrConfig [ 'type' ] == 'hasOne' || $ arrConfig [ 'type' ] == 'belongsTo' ) { ++ $ intCount ; $ objRelated = DcaExtractor :: getInstance ( $ arrConfig [ 'table' ] ) ; foreach ( array_keys ( $ objRelated -> getFields ( ) ) as $ strField ) { $ arrFields [ ] = 'j' . $ intCount . '.' . Database :: quoteIdentifier ( $ strField ) . ' AS ' . $ strKey . '__' . $ strField ; } $ arrJoins [ ] = " LEFT JOIN " . $ arrConfig [ 'table' ] . " j$intCount ON " . $ arrOptions [ 'table' ] . "." . Database :: quoteIdentifier ( $ strKey ) . "=j$intCount." . $ arrConfig [ 'field' ] ; } } } $ strQuery = "SELECT " . implode ( ', ' , $ arrFields ) . " FROM " . $ arrOptions [ 'table' ] . implode ( "" , $ arrJoins ) ; } if ( isset ( $ arrOptions [ 'column' ] ) ) { $ strQuery .= " WHERE " . ( \ is_array ( $ arrOptions [ 'column' ] ) ? implode ( " AND " , $ arrOptions [ 'column' ] ) : $ arrOptions [ 'table' ] . '.' . Database :: quoteIdentifier ( $ arrOptions [ 'column' ] ) . "=?" ) ; } if ( isset ( $ arrOptions [ 'group' ] ) ) { $ strQuery .= " GROUP BY " . $ arrOptions [ 'group' ] ; } if ( isset ( $ arrOptions [ 'having' ] ) ) { $ strQuery .= " HAVING " . $ arrOptions [ 'having' ] ; } if ( isset ( $ arrOptions [ 'order' ] ) ) { $ strQuery .= " ORDER BY " . $ arrOptions [ 'order' ] ; } return $ strQuery ; }
11214	public function count ( $ coraDbQuery = false ) { if ( ! $ coraDbQuery ) { $ coraDbQuery = $ this -> gateway -> getDb ( ) ; } $ coraDbQuery = $ this -> model :: model_constraints ( $ coraDbQuery ) ; return $ this -> gateway -> count ( $ coraDbQuery ) ; }
9115	public function setDefaults ( $ defaultController = 'Index' , $ defaultAction = 'index' ) { $ this -> defaultController = $ defaultController ; $ this -> defaultAction = $ defaultAction ; return $ this ; }
6278	protected function find ( $ key ) { $ keyLen = strlen ( $ key ) ; $ u = Util :: hash ( $ key ) ; $ upos = ( $ u << 3 ) & 2047 ; $ hashSlots = $ this -> readInt31 ( $ upos + 4 ) ; if ( ! $ hashSlots ) { return false ; } $ hashPos = $ this -> readInt31 ( $ upos ) ; $ keyHash = $ u ; $ u = Util :: unsignedShiftRight ( $ u , 8 ) ; $ u = Util :: unsignedMod ( $ u , $ hashSlots ) ; $ u <<= 3 ; $ keyPos = $ hashPos + $ u ; for ( $ i = 0 ; $ i < $ hashSlots ; $ i ++ ) { $ hash = $ this -> readInt32 ( $ keyPos ) ; $ pos = $ this -> readInt31 ( $ keyPos + 4 ) ; if ( ! $ pos ) { return false ; } $ keyPos += 8 ; if ( $ keyPos == $ hashPos + ( $ hashSlots << 3 ) ) { $ keyPos = $ hashPos ; } if ( $ hash === $ keyHash ) { if ( $ keyLen === $ this -> readInt31 ( $ pos ) ) { $ dataLen = $ this -> readInt31 ( $ pos + 4 ) ; $ dataPos = $ pos + 8 + $ keyLen ; $ foundKey = $ this -> read ( $ pos + 8 , $ keyLen ) ; if ( $ foundKey === $ key ) { $ this -> dataLen = $ dataLen ; $ this -> dataPos = $ dataPos ; return true ; } } } } return false ; }
9490	protected function getFileDataValue ( $ obFile ) { if ( empty ( $ obFile ) || ! $ obFile instanceof File ) { return null ; } $ sUploadFolder = Config :: get ( 'cms.storage.uploads.path' , '/storage/app/uploads' ) ; return [ 'full_path' => $ obFile -> getPath ( ) , 'path' => $ sUploadFolder . str_replace ( 'uploads' , '' , $ obFile -> getDiskPath ( ) ) , 'title' => $ obFile -> getAttribute ( 'title' ) , 'alt' => $ obFile -> getAttribute ( 'description' ) , ] ; }
3851	public function setLimit ( $ blnUse , $ intOffset , $ intLimit ) { $ this -> paginationLimitCalculator -> setApplyLimitAndOffset ( $ blnUse ) -> setOffset ( $ intOffset ) -> setLimit ( $ intLimit ) ; return $ this ; }
11963	private function setParam ( $ key , $ value , $ allowed_keys ) { if ( in_array ( $ key , $ allowed_keys ) ) { $ this -> { $ key } = $ value ; } }
7402	public function Get ( $ name = null , $ value = null , ... $ param ) { if ( ! isset ( $ name ) ) return self :: $ config ; return isset ( $ value ) ? self :: $ config [ $ name ] [ $ value ] : ( isset ( self :: $ config [ $ name ] ) ? self :: $ config [ $ name ] : null ) ; }
1972	public static function findByPath ( $ path , array $ arrOptions = array ( ) ) { $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( strncmp ( $ path , $ rootDir . '/' , \ strlen ( $ rootDir ) + 1 ) === 0 ) { $ path = substr ( $ path , \ strlen ( $ rootDir ) + 1 ) ; } return static :: findOneBy ( 'path' , $ path , $ arrOptions ) ; }
6440	public function transform ( $ target = null , $ controller = null , $ action = null , array $ params = [ ] , array $ trailing = [ ] , array $ config = [ ] ) { if ( ! empty ( $ trailing ) ) { $ params [ 'trailing' ] = join ( '_' , $ trailing ) ; } $ params = $ this -> sanitize ( $ params ) ; $ refType = \ Symfony \ Component \ Routing \ Generator \ UrlGeneratorInterface :: ABSOLUTE_PATH ; if ( isset ( $ config [ 'absoluteUri' ] ) ) { $ refType = \ Symfony \ Component \ Routing \ Generator \ UrlGeneratorInterface :: ABSOLUTE_URL ; } return $ this -> router -> generate ( $ target , $ params + $ this -> fixed , $ refType ) ; }
8161	public function block ( ) { $ this -> status = User :: STATUS_BLOCKED ; if ( $ this -> save ( FALSE ) ) return TRUE ; return FALSE ; }
9513	public function setMatchModeByModeName ( $ modeName ) { $ modes = [ 'all' => 0 , 'any' => 1 , 'phrase' => 2 , 'boolean' => 3 , 'extended' => 4 , 'fullscan' => 5 , ] ; if ( array_key_exists ( $ modeName , $ modes ) ) { $ mode = $ modes [ $ modeName ] ; $ this -> SetMatchMode ( $ mode ) ; } else { throw new \ LogicException ( 'Wrong Mode' ) ; } }
1884	public static function count ( array $ arrOptions ) { $ strQuery = "SELECT COUNT(*) AS count FROM " . $ arrOptions [ 'table' ] ; if ( $ arrOptions [ 'column' ] !== null ) { $ strQuery .= " WHERE " . ( \ is_array ( $ arrOptions [ 'column' ] ) ? implode ( " AND " , $ arrOptions [ 'column' ] ) : $ arrOptions [ 'table' ] . '.' . Database :: quoteIdentifier ( $ arrOptions [ 'column' ] ) . "=?" ) ; } return $ strQuery ; }
2595	public static function findMessage ( $ code ) { $ message = null ; if ( array_key_exists ( $ code , self :: $ errorList ) ) { $ message = self :: $ errorList [ $ code ] ; } return $ message ; }
11200	public function checkIfSingleton ( $ name , $ item ) { if ( isset ( $ this -> signaturesToSingletons -> $ name ) and $ this -> signaturesToSingletons -> $ name ) { $ this -> $ name = $ item ; $ this -> signaturesToSingletons = false ; } }
6521	public function boot ( ) { $ this -> app -> when ( SmsGatewayChannel :: class ) -> needs ( SmsGatewayClient :: class ) -> give ( function ( ) { $ config = $ this -> app [ 'config' ] [ 'services.smsgateway' ] ; return new SmsGatewayClient ( new HttpClient , $ config [ 'email' ] , $ config [ 'password' ] , $ config [ 'device' ] ) ; } ) ; }
6813	private function getNumberFormatter ( ) { if ( $ this -> numberFormatter ) { return $ this -> numberFormatter ; } return $ this -> numberFormatter = NumberFormatter :: create ( $ this -> locale , NumberFormatter :: DECIMAL ) ; }
12210	private function saveTransLogs ( $ orders , $ transIds ) { $ bySaleId = [ ] ; foreach ( $ orders as $ custId => $ order ) { $ saleId = $ order [ QGetOrders :: A_SALE_ID ] ; $ bySaleId [ $ saleId ] = $ order ; } foreach ( $ transIds as $ tranId => $ one ) { $ pref = substr ( $ one , 0 , 2 ) ; $ orderId = str_replace ( $ pref , '' , $ one ) ; if ( $ pref == self :: PREFIX_PV ) { $ custId = $ bySaleId [ $ orderId ] [ QGetOrders :: A_CUST_ID ] ; $ this -> daoLogCust -> create ( [ LogCust :: A_TRANS_ID => $ tranId , LogCust :: A_CUSTOMER_ID => $ custId ] ) ; $ this -> daoLogSale -> create ( [ LogSales :: A_TRANS_ID => $ tranId , LogSales :: A_SALE_ORDER_ID => $ orderId ] ) ; } elseif ( $ pref == self :: PREFIX_BONUS_FATHER ) { $ custId = $ bySaleId [ $ orderId ] [ QGetOrders :: A_PARENT_ID ] ; $ this -> daoLogCust -> create ( [ LogCust :: A_TRANS_ID => $ tranId , LogCust :: A_CUSTOMER_ID => $ custId ] ) ; } else { $ custId = $ bySaleId [ $ orderId ] [ QGetOrders :: A_PARENT_GRAND_ID ] ; $ this -> daoLogCust -> create ( [ LogCust :: A_TRANS_ID => $ tranId , LogCust :: A_CUSTOMER_ID => $ custId ] ) ; } } }
10156	private function readSharedFmla ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; $ cellRange = substr ( $ recordData , 0 , 6 ) ; $ cellRange = $ this -> readBIFF5CellRangeAddressFixed ( $ cellRange ) ; $ no = ord ( $ recordData [ 7 ] ) ; $ formula = substr ( $ recordData , 8 ) ; $ this -> sharedFormulas [ $ this -> baseCell ] = $ formula ; }
7895	public function extend ( $ provider , Closure $ callback ) { if ( $ this -> isProviderAliasExists ( $ provider ) ) { throw new InvalidArgumentException ( "Alias provider is already reserved [{$provider}]" ) ; } $ this -> customProviders [ $ provider ] = $ callback ; return $ this ; }
3917	protected function sortByRandom ( ) { $ arrFiles = $ this -> foundFiles ; $ arrSource = $ this -> outputBuffer ; if ( ! $ arrFiles ) { return array ( 'files' => array ( ) , 'source' => array ( ) ) ; } $ keys = array_keys ( $ arrFiles ) ; $ files = array ( ) ; shuffle ( $ keys ) ; foreach ( $ keys as $ key ) { $ files [ $ key ] = $ arrFiles [ $ key ] ; } return $ this -> remapSorting ( $ files , $ arrSource ) ; }
2444	public static function decrypt ( $ varValue , $ strKey = null ) { if ( \ is_array ( $ varValue ) ) { foreach ( $ varValue as $ k => $ v ) { $ varValue [ $ k ] = static :: decrypt ( $ v ) ; } return $ varValue ; } elseif ( $ varValue == '' ) { return '' ; } if ( static :: $ resTd === null ) { static :: initialize ( ) ; } $ varValue = base64_decode ( $ varValue ) ; $ ivsize = mcrypt_enc_get_iv_size ( static :: $ resTd ) ; $ iv = substr ( $ varValue , 0 , $ ivsize ) ; $ varValue = substr ( $ varValue , $ ivsize ) ; if ( $ varValue == '' ) { return '' ; } if ( ! $ strKey ) { $ strKey = System :: getContainer ( ) -> getParameter ( 'contao.encryption_key' ) ; } mcrypt_generic_init ( static :: $ resTd , md5 ( $ strKey ) , $ iv ) ; $ strDecrypted = mdecrypt_generic ( static :: $ resTd , $ varValue ) ; mcrypt_generic_deinit ( static :: $ resTd ) ; return $ strDecrypted ; }
1964	public static function decodeUrl ( $ strUrl ) { if ( $ strUrl == '' ) { return '' ; } if ( $ strUrl == '#' || strncmp ( $ strUrl , '{{' , 2 ) === 0 ) { return $ strUrl ; } if ( strncmp ( $ strUrl , 'mailto:' , 7 ) === 0 ) { return static :: decodeEmail ( $ strUrl ) ; } $ arrUrl = parse_url ( $ strUrl ) ; if ( ! isset ( $ arrUrl [ 'scheme' ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Expected a FQDN, got "%s"' , $ strUrl ) ) ; } if ( isset ( $ arrUrl [ 'scheme' ] ) ) { $ arrUrl [ 'scheme' ] .= ( ( substr ( $ strUrl , \ strlen ( $ arrUrl [ 'scheme' ] ) , 3 ) == '://' ) ? '://' : ':' ) ; } if ( isset ( $ arrUrl [ 'user' ] ) ) { $ arrUrl [ 'user' ] .= isset ( $ arrUrl [ 'pass' ] ) ? ':' : '@' ; } if ( isset ( $ arrUrl [ 'pass' ] ) ) { $ arrUrl [ 'pass' ] .= '@' ; } if ( isset ( $ arrUrl [ 'host' ] ) ) { $ arrUrl [ 'host' ] = static :: decode ( $ arrUrl [ 'host' ] ) ; } if ( isset ( $ arrUrl [ 'port' ] ) ) { $ arrUrl [ 'port' ] = ':' . $ arrUrl [ 'port' ] ; } if ( isset ( $ arrUrl [ 'query' ] ) ) { $ arrUrl [ 'query' ] = '?' . $ arrUrl [ 'query' ] ; } if ( isset ( $ arrUrl [ 'fragment' ] ) ) { $ arrUrl [ 'fragment' ] = '#' . $ arrUrl [ 'fragment' ] ; } $ strReturn = '' ; foreach ( array ( 'scheme' , 'user' , 'pass' , 'host' , 'port' , 'path' , 'query' , 'fragment' ) as $ key ) { if ( isset ( $ arrUrl [ $ key ] ) ) { $ strReturn .= $ arrUrl [ $ key ] ; } } return $ strReturn ; }
11091	public static function gpsDistance ( $ lat1 , $ lon1 , $ lat2 , $ lon2 ) { $ lat1 = deg2rad ( $ lat1 ) ; $ lon1 = deg2rad ( $ lon1 ) ; $ lat2 = deg2rad ( $ lat2 ) ; $ lon2 = deg2rad ( $ lon2 ) ; $ lonDelta = $ lon2 - $ lon1 ; $ a = ( ( cos ( $ lat2 ) * sin ( $ lonDelta ) ) ** 2 ) + ( ( cos ( $ lat1 ) * sin ( $ lat2 ) - sin ( $ lat1 ) * cos ( $ lat2 ) * cos ( $ lonDelta ) ) ** 2 ) ; $ b = sin ( $ lat1 ) * sin ( $ lat2 ) + cos ( $ lat1 ) * cos ( $ lat2 ) * cos ( $ lonDelta ) ; return atan2 ( sqrt ( $ a ) , $ b ) * 6371.0088 ; }
7852	protected function dispatchWorkflow ( $ workflow ) { $ job = $ this -> inflector -> getJob ( ) ; $ request = $ this -> resolveRequest ( ) ; $ pipes = $ this -> pipelines -> getPipesByPipeline ( $ workflow ) ; $ parameters = $ this -> container -> make ( 'router' ) -> current ( ) -> parameters ( ) ; return $ this -> dispatcher -> pipeThrough ( $ pipes ) -> dispatchFrom ( $ job , $ request , $ parameters ) ; }
4889	public function viewAction ( Request $ request , $ id ) { $ pageManager = $ this -> getPageManager ( ) ; $ page = $ pageManager -> findForView ( $ id ) ; if ( null !== ( $ validator = $ this -> getViewActionValidator ( ) ) ) { $ validator -> validate ( $ page ) ; } if ( $ page instanceof ControllerPageInterface ) { return $ this -> forward ( $ page -> getController ( ) , ( array ) $ page -> getControllerParameters ( ) + array ( 'parameters' => $ request -> query -> all ( ) , '_locale' => $ request -> attributes -> get ( '_locale' ) , '_internal_url' => $ request -> attributes -> get ( '_internal_url' ) , ) , $ request -> query -> all ( ) ) ; } return $ this -> renderPage ( $ page ) ; }
255	public function beforeRun ( ) { $ event = new WidgetEvent ( ) ; $ this -> trigger ( self :: EVENT_BEFORE_RUN , $ event ) ; return $ event -> isValid ; }
3144	public function finish ( RunnerServiceContext $ context , $ finalState = DeliveryExecution :: STATE_FINISHED ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ executionUri = $ context -> getTestExecutionUri ( ) ; $ userUri = \ common_session_SessionManager :: getSession ( ) -> getUserUri ( ) ; $ executionService = ServiceProxy :: singleton ( ) ; $ deliveryExecution = $ executionService -> getDeliveryExecution ( $ executionUri ) ; if ( $ deliveryExecution -> getUserIdentifier ( ) == $ userUri ) { \ common_Logger :: i ( "Finishing the delivery execution {$executionUri}" ) ; $ result = $ deliveryExecution -> setState ( $ finalState ) ; } else { \ common_Logger :: w ( "Non owner {$userUri} tried to finish deliveryExecution {$executionUri}" ) ; $ result = false ; } $ this -> getServiceManager ( ) -> get ( ExtendedStateService :: SERVICE_ID ) -> clearEvents ( $ executionUri ) ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'finish' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } return $ result ; }
8524	public function setItemList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ItemList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
8170	public function recoverPassword ( ) { $ user = User :: findOne ( [ 'email' => $ this -> email ] ) ; if ( $ user != NULL ) { $ user -> password_reset_token = Yii :: $ app -> getSecurity ( ) -> generateRandomString ( ) . '_' . time ( ) ; $ user -> save ( FALSE ) ; } Mailer :: sendRecoveryMessage ( $ user ) ; Yii :: $ app -> session -> setFlash ( 'info' , 'You will receive an email with instructions on how to reset your password in a few minutes.' ) ; }
11420	protected function getCache ( $ pk ) { $ app = App :: getInstance ( ) ; return $ app [ 'cache' ] -> getItem ( $ this -> dbtable . '/' . $ pk -> getValue ( ) ) ; }
6172	public function setConfig ( $ host , $ name = 'schema' , DriverInterface $ driver = null ) { $ this -> driver = \ is_null ( $ driver ) ? new Driver \ Json ( ) : $ driver ; $ this -> path = $ host ; $ this -> name = $ name ; $ this -> file = $ host . DIRECTORY_SEPARATOR . $ name . '.' . $ this -> driver -> getExtension ( ) ; return $ this ; }
4981	public function convertToPhpValue ( $ value ) { if ( ! is_array ( $ value ) || ! isset ( $ value [ 'date' ] ) || ! $ value [ 'date' ] instanceof \ MongoDate || ! isset ( $ value [ 'tz' ] ) ) { return null ; } $ timestamp = $ value [ 'date' ] -> sec ; $ date = new \ DateTime ( '@' . $ timestamp ) ; $ date -> setTimezone ( new \ DateTimeZone ( $ value [ 'tz' ] ) ) ; return $ date ; }
7019	private function formatH ( & $ str ) { if ( strstr ( $ str , '%H' ) ) $ str = str_replace ( '%H' , sprintf ( '%02d' , $ this -> hour ) , $ str ) ; }
7270	public function save ( $ create = false ) { $ tableName = static :: tableName ( ) ; $ columns = static :: tableColumns ( ) ; $ idColumn = static :: $ idColumn ; $ isModel = false ; $ into = "" ; $ values = "" ; $ updates = "" ; $ condition = "" ; $ params = [ ] ; $ primaries = [ ] ; $ updateCondition = "" ; foreach ( $ columns as $ i => $ column ) { $ name = $ column [ "column_name" ] ; $ key = $ column [ "column_key" ] ; if ( property_exists ( $ this , $ name ) && ! in_array ( $ name , static :: $ autos ) ) { $ into .= "$name, " ; $ values .= ":$name, " ; $ updates .= "$name = :$name, " ; $ condition .= "$name = :$name and " ; $ params [ $ name ] = $ this -> encodeValue ( $ name ) ; } if ( strcasecmp ( $ key , "PRI" ) === 0 ) { $ updateCondition .= "$name = :$name and " ; if ( property_exists ( $ this , $ name ) && ! in_array ( $ name , static :: $ autos ) ) $ primaries [ $ name ] = $ this -> encodeValue ( $ name ) ; if ( $ name === $ idColumn ) $ isModel = true ; } } $ into = substr ( $ into , 0 , - 2 ) ; $ values = substr ( $ values , 0 , - 2 ) ; $ updates = substr ( $ updates , 0 , - 2 ) ; $ condition = substr ( $ condition , 0 , - 5 ) ; $ updateCondition = substr ( $ updateCondition , 0 , - 5 ) ; try { $ status = Db :: query ( " insert into $tableName ($into) values ($values) " , $ params , static :: getDbName ( ) , false ) !== false ; } catch ( PDOException $ e ) { if ( $ create ) throw $ e ; if ( $ e -> getCode ( ) === "23000" && preg_match ( "/.*'PRIMARY'$/" , $ e -> getMessage ( ) ) ) { $ status = Db :: query ( " update $tableName set $updates where $updateCondition " , $ params , static :: getDbName ( ) , false ) !== false ; } else throw $ e ; } if ( $ status ) { $ lastInsertId = Db :: instance ( static :: getDbName ( ) ) -> lastInsertId ( ) ; if ( $ lastInsertId > 0 ) return static :: find ( $ lastInsertId ) ; else return static :: select ( "where $updateCondition" , $ primaries , static :: getDbName ( ) ) -> first ( ) ; } else return false ; }
8660	private function convertGetReportList ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetReportList' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetMaxCount ( ) ) { $ parameters [ 'MaxCount' ] = $ request -> getMaxCount ( ) ; } if ( $ request -> isSetReportTypeList ( ) ) { $ reportTypeList = $ request -> getReportTypeList ( ) ; foreach ( $ reportTypeList -> getType ( ) as $ typeIndex => $ type ) { $ parameters [ 'ReportTypeList' . '.' . 'Type' . '.' . ( $ typeIndex + 1 ) ] = $ type ; } } if ( $ request -> isSetAcknowledged ( ) ) { $ parameters [ 'Acknowledged' ] = $ request -> getAcknowledged ( ) ? "true" : "false" ; } if ( $ request -> isSetAvailableFromDate ( ) ) { $ parameters [ 'AvailableFromDate' ] = $ this -> getFormattedTimestamp ( $ request -> getAvailableFromDate ( ) ) ; } if ( $ request -> isSetAvailableToDate ( ) ) { $ parameters [ 'AvailableToDate' ] = $ this -> getFormattedTimestamp ( $ request -> getAvailableToDate ( ) ) ; } if ( $ request -> isSetReportRequestIdList ( ) ) { $ reportRequestIdList = $ request -> getReportRequestIdList ( ) ; foreach ( $ reportRequestIdList -> getId ( ) as $ idIndex => $ id ) { $ parameters [ 'ReportRequestIdList' . '.' . 'Id' . '.' . ( $ idIndex + 1 ) ] = $ id ; } } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
867	private function getPreviousBlock ( Tokens $ tokens , $ index ) { $ close = $ previous = $ tokens -> getPrevMeaningfulToken ( $ index ) ; if ( $ tokens [ $ close ] -> equals ( '}' ) ) { $ previous = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_CURLY_BRACE , $ close ) ; } $ open = $ tokens -> getPrevTokenOfKind ( $ previous , [ [ T_IF ] , [ T_ELSE ] , [ T_ELSEIF ] ] ) ; if ( $ tokens [ $ open ] -> isGivenKind ( T_IF ) ) { $ elseCandidate = $ tokens -> getPrevMeaningfulToken ( $ open ) ; if ( $ tokens [ $ elseCandidate ] -> isGivenKind ( T_ELSE ) ) { $ open = $ elseCandidate ; } } return [ $ open , $ close ] ; }
3724	private function buildCacheService ( ContainerBuilder $ container , array $ config ) { if ( ! $ config [ 'enable_cache' ] ) { $ cache = $ container -> getDefinition ( 'metamodels.cache' ) ; $ cache -> setClass ( ArrayCache :: class ) ; $ cache -> setArguments ( [ ] ) ; $ container -> setParameter ( 'metamodels.cache_dir' , null ) ; return ; } $ container -> setParameter ( 'metamodels.cache_dir' , $ config [ 'cache_dir' ] ) ; }
9931	public function getRule ( $ pIndex ) { if ( ! isset ( $ this -> ruleset [ $ pIndex ] ) ) { $ this -> ruleset [ $ pIndex ] = new Column \ Rule ( $ this ) ; } return $ this -> ruleset [ $ pIndex ] ; }
9950	public function duplicateStyle ( Style $ pCellStyle , $ pRange ) { $ workbook = $ this -> parent ; if ( $ existingStyle = $ this -> parent -> getCellXfByHashCode ( $ pCellStyle -> getHashCode ( ) ) ) { $ xfIndex = $ existingStyle -> getIndex ( ) ; } else { $ workbook -> addCellXf ( $ pCellStyle ) ; $ xfIndex = $ pCellStyle -> getIndex ( ) ; } list ( $ rangeStart , $ rangeEnd ) = Coordinate :: rangeBoundaries ( $ pRange . ':' . $ pRange ) ; if ( $ rangeStart [ 0 ] > $ rangeEnd [ 0 ] && $ rangeStart [ 1 ] > $ rangeEnd [ 1 ] ) { $ tmp = $ rangeStart ; $ rangeStart = $ rangeEnd ; $ rangeEnd = $ tmp ; } for ( $ col = $ rangeStart [ 0 ] ; $ col <= $ rangeEnd [ 0 ] ; ++ $ col ) { for ( $ row = $ rangeStart [ 1 ] ; $ row <= $ rangeEnd [ 1 ] ; ++ $ row ) { $ this -> getCell ( Coordinate :: stringFromColumnIndex ( $ col ) . $ row ) -> setXfIndex ( $ xfIndex ) ; } } return $ this ; }
6025	public function addMetaData ( $ item ) { if ( ! ( $ item instanceof MetaData ) ) { if ( is_array ( $ item ) ) { try { $ item = new MetaData ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate MetaData. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "MetaData"!' , E_USER_WARNING ) ; } } $ this -> metadata [ ] = $ item ; return $ this ; }
445	public function getBehavior ( $ name ) { $ this -> ensureBehaviors ( ) ; return isset ( $ this -> _behaviors [ $ name ] ) ? $ this -> _behaviors [ $ name ] : null ; }
12438	public function get ( $ id ) { if ( isset ( $ this -> children [ $ id ] ) ) { return $ this -> children [ $ id ] ; } throw new FormalException ( "Unknown form field '$id' on form '" . get_called_class ( ) . "'. Available fields are: " . implode ( ', ' , array_keys ( $ this -> children ) ) ) ; }
10014	public function getIndex ( Worksheet $ pSheet ) { foreach ( $ this -> workSheetCollection as $ key => $ value ) { if ( $ value -> getHashCode ( ) == $ pSheet -> getHashCode ( ) ) { return $ key ; } } throw new Exception ( 'Sheet does not exist.' ) ; }
1072	private function getSuggestedTypeNames ( Schema $ schema , $ type , $ fieldName ) { if ( Type :: isAbstractType ( $ type ) ) { $ suggestedObjectTypes = [ ] ; $ interfaceUsageCount = [ ] ; foreach ( $ schema -> getPossibleTypes ( $ type ) as $ possibleType ) { $ fields = $ possibleType -> getFields ( ) ; if ( ! isset ( $ fields [ $ fieldName ] ) ) { continue ; } $ suggestedObjectTypes [ ] = $ possibleType -> name ; foreach ( $ possibleType -> getInterfaces ( ) as $ possibleInterface ) { $ fields = $ possibleInterface -> getFields ( ) ; if ( ! isset ( $ fields [ $ fieldName ] ) ) { continue ; } $ interfaceUsageCount [ $ possibleInterface -> name ] = ! isset ( $ interfaceUsageCount [ $ possibleInterface -> name ] ) ? 0 : $ interfaceUsageCount [ $ possibleInterface -> name ] + 1 ; } } arsort ( $ interfaceUsageCount ) ; $ suggestedInterfaceTypes = array_keys ( $ interfaceUsageCount ) ; return array_merge ( $ suggestedInterfaceTypes , $ suggestedObjectTypes ) ; } return [ ] ; }
11551	public function saveConsignment ( ConsignmentInterface $ consignment ) { $ adapter = $ this -> getAdapter ( $ consignment ) ; $ event = new EventConsignment ( $ consignment ) ; $ this -> eventDispatcher -> dispatch ( Events :: PRE_CONSIGNMENT_SAVE , $ event ) ; if ( ! $ consignment -> getStatus ( ) ) { $ consignment -> setStatus ( ConsignmentStatusList :: STATUS_NEW ) ; } try { $ adapter -> saveConsignment ( $ consignment ) ; $ this -> consignmentRepository -> saveConsignment ( $ consignment ) ; } catch ( \ Exception $ e ) { throw new VendorAdapterException ( 'Error during consignment saving.' , null , $ e ) ; } $ event = new EventConsignment ( $ consignment ) ; $ this -> eventDispatcher -> dispatch ( Events :: POST_CONSIGNMENT_SAVE , $ event ) ; }
11360	public function setSortBy ( $ sortKeys ) { if ( $ sortKeys == null ) { $ sortKeys = [ ] ; } if ( ! is_array ( $ sortKeys ) ) { $ sortKeys = [ $ sortKeys ] ; } $ this -> sortKeys = $ sortKeys ; }
12774	public function __authorize ( $ hashEmail = null , $ hashPassword = null ) { $ asyncResult = $ this -> __async_authorize ( $ hashEmail , $ hashPassword ) ; if ( $ asyncResult ) { } }
5171	private function getAvailableRatios ( ) : array { return [ self :: RATIO_SQUARE , self :: RATIO_RECTANGLE , self :: RATIO_HEADLINE , self :: RATIO_VERTICAL , self :: RATIO_COVER , ] ; }
6309	public function drop ( DatabaseObjectInterface $ databaseObject , $ cascade = false ) { $ command = $ this -> getCommand ( $ databaseObject , false ) ; if ( $ cascade ) { $ command -> cascade ( ) ; } return $ command -> execute ( ) ; }
5933	public function setStartDate ( $ startDate ) { if ( $ startDate instanceof DateTime ) { $ this -> startDate = $ startDate ; } else { try { $ this -> startDate = new DateTime ( $ startDate ) ; } catch ( \ Exception $ e ) { $ this -> startDate = null ; } } return $ this ; }
6954	private function getGridForCountry ( CountryInterface $ country ) { if ( isset ( $ this -> grids [ $ country -> getId ( ) ] ) ) { return $ this -> grids [ $ country -> getId ( ) ] ; } $ grid = [ ] ; $ prices = $ this -> priceRepository -> findByCountry ( $ country ) ; foreach ( $ prices as $ price ) { $ method = $ price -> getMethod ( ) ; if ( ! isset ( $ grid [ $ method -> getId ( ) ] ) ) { $ gateway = $ this -> gatewayRegistry -> getGateway ( $ method -> getGatewayName ( ) ) ; $ grid [ $ method -> getId ( ) ] = [ 'method' => $ method , 'max_weight' => $ gateway -> getMaxWeight ( ) , 'prices' => [ ] , ] ; } $ grid [ $ method -> getId ( ) ] [ 'prices' ] [ ] = [ 'weight' => $ price -> getWeight ( ) , 'price' => $ price -> getNetPrice ( ) , ] ; } foreach ( $ grid as & $ method ) { usort ( $ method [ 'prices' ] , function ( $ a , $ b ) { if ( 0 === bccomp ( $ a [ 'weight' ] , $ b [ 'weight' ] , 3 ) ) { return 0 ; } return $ a [ 'weight' ] > $ b [ 'weight' ] ? 1 : - 1 ; } ) ; $ max = end ( $ method [ 'prices' ] ) [ 'weight' ] ; if ( 0 == $ method [ 'max_weight' ] || $ method [ 'max_weight' ] > $ max ) { $ method [ 'max_weight' ] = $ max ; } unset ( $ method ) ; } return $ this -> grids [ $ country -> getId ( ) ] = $ grid ; }
11373	public function createPublicMethodInjection ( \ ReflectionMethod $ method ) : MethodInjection { $ injections = [ ] ; foreach ( $ method -> getParameters ( ) as $ parameter ) { $ injections [ ] = new ParameterInjection ( $ parameter -> getName ( ) , ( string ) $ parameter -> getType ( ) , $ parameter -> isArray ( ) , $ this -> getInjectHint ( $ method , $ parameter ) ) ; } return new MethodInjection ( $ injections , $ method -> getName ( ) ) ; }
7918	public static function labelGroup ( $ labels = [ ] , $ options = [ ] ) { Ui :: addCssClasses ( $ options , [ 'ui' , 'labels' ] ) ; $ lines = [ ] ; foreach ( $ labels as $ label ) { $ content = ArrayHelper :: remove ( $ label , 'content' ) ; $ lines [ ] = static :: label ( $ content , $ label ) ; } return Ui :: tag ( 'div' , implode ( "\n" , $ lines ) , $ options ) ; }
9403	public static function get ( ContainerInterface $ container , array $ components = array ( ) , & $ globals = null ) { $ configuration = new Configuration ; $ collection = new Collection ; foreach ( ( array ) $ components as $ component ) { $ instance = self :: prepare ( $ collection , $ component ) ; $ container = $ instance -> define ( $ container , $ configuration ) ; } $ collection -> setContainer ( $ container ) ; $ globals === null || $ globals [ 'container' ] = $ container ; return $ collection ; }
5860	public function getAllFileTypes ( ) { $ fileTypes = [ ] ; foreach ( $ this -> rulesets as $ ruleset ) { if ( is_array ( $ ruleset [ 'file_types' ] ) ) { $ fileTypes = array_merge ( $ fileTypes , $ ruleset [ 'file_types' ] ) ; } } $ fileTypes = array_unique ( $ fileTypes ) ; return $ fileTypes ; }
2424	public static function getFolderHash ( $ strPath ) { $ strPath = str_replace ( array ( '\\' , '%' , '_' ) , array ( '\\\\' , '\\%' , '\\_' ) , $ strPath ) ; $ arrHash = array ( ) ; $ objChildren = Database :: getInstance ( ) -> prepare ( "SELECT hash, name FROM tl_files WHERE path LIKE ? AND path NOT LIKE ? ORDER BY name" ) -> execute ( $ strPath . '/%' , $ strPath . '/%/%' ) ; if ( $ objChildren !== null ) { while ( $ objChildren -> next ( ) ) { $ arrHash [ ] = $ objChildren -> hash . $ objChildren -> name ; } } return md5 ( implode ( "\0" , $ arrHash ) ) ; }
6223	public function getMenuPresence ( ) { return [ 'id' => 'simple-acl' , 'type' => MenuPresenceType :: GROUP , 'label' => 'Access Control' , 'children' => [ [ 'id' => 'simple-acl-users' , 'type' => MenuPresenceType :: ACTION , 'label' => 'Users' , 'permissions' => 'acl.users.show' , 'action' => $ this -> core -> prefixRoute ( 'acl.users.index' ) , 'parameters' => [ ] , ] , [ 'id' => 'simple-acl-create-user' , 'type' => MenuPresenceType :: ACTION , 'label' => 'New User' , 'permissions' => 'acl.users.create' , 'action' => $ this -> core -> prefixRoute ( 'acl.users.create' ) , 'parameters' => [ ] , ] , [ 'id' => 'simple-acl-roles' , 'type' => MenuPresenceType :: ACTION , 'label' => 'Roles' , 'permissions' => 'acl.roles.show' , 'action' => $ this -> core -> prefixRoute ( 'acl.roles.index' ) , 'parameters' => [ ] , ] , ] ] ; }
11169	public static function boot ( ) { parent :: boot ( ) ; static :: addGlobalScope ( 'type' , function ( $ query ) { return $ query -> when ( static :: class !== StripeObject :: class , function ( $ query ) { $ query -> where ( 'type' , class_basename ( ( new static ( ) ) -> objectClass ) ) ; } ) ; } ) ; static :: created ( function ( StripeObject $ object ) { if ( $ object -> relatesWith ) { list ( $ related , $ tag ) = $ object -> relatesWith ; $ object -> relations ( get_class ( $ related ) ) -> attach ( $ related -> id , [ 'tag' => $ tag ] ) ; } } ) ; }
4641	private function buildCallback ( BuildInfo $ output ) { $ message = "" ; if ( $ output -> getError ( ) ) { $ this -> logger -> error ( sprintf ( "Error when creating job: %s\n" , $ output -> getError ( ) ) , array ( 'static' => false , 'static-id' => null ) ) ; return ; } if ( $ output -> getStream ( ) ) { $ message = $ output -> getStream ( ) ; } if ( $ output -> getStatus ( ) ) { $ message = $ output -> getStatus ( ) ; if ( $ output -> getProgress ( ) ) { $ message .= " " . $ output -> getProgress ( ) ; } } if ( ! $ output -> getId ( ) && ! preg_match ( '#\n#' , $ message ) ) { $ message .= "\n" ; } $ this -> logger -> debug ( $ message , array ( 'static' => $ output -> getId ( ) !== null , 'static-id' => $ output -> getId ( ) , ) ) ; }
10211	function fromXML ( $ xmlElement ) { if ( isset ( $ xmlElement -> id ) ) $ this -> id = $ xmlElement -> id ; $ this -> email = ( string ) $ xmlElement -> email ; if ( isset ( $ xmlElement -> permission ) ) $ this -> permission = Permission :: getPermission ( ( string ) $ xmlElement -> permission ) ; if ( isset ( $ xmlElement -> external_id ) ) ( string ) $ this -> external_id = $ xmlElement -> external_id ; if ( isset ( $ xmlElement -> anonymous ) ) ( string ) $ this -> anonymous = $ xmlElement -> anonymous ; if ( isset ( $ xmlElement [ 'anonymous' ] ) ) $ this -> anonymous = $ xmlElement [ 'anonymous' ] ; if ( isset ( $ xmlElement -> created ) ) $ this -> created = $ xmlElement -> created ; if ( isset ( $ xmlElement -> updated ) ) $ this -> updated = $ xmlElement -> updated ; if ( isset ( $ xmlElement -> standard_fields ) ) { $ this -> standard_fields = array ( ) ; foreach ( $ xmlElement -> standard_fields -> children ( ) as $ field ) { $ this -> standard_fields [ trim ( $ field -> name ) ] = ( string ) $ field -> value ; } } if ( isset ( $ xmlElement -> custom_fields ) ) { foreach ( $ xmlElement -> custom_fields -> children ( ) as $ field ) { $ this -> custom_fields [ trim ( $ field -> name ) ] = ( string ) $ field -> value ; } } }
4922	public function removeRegion ( $ region ) { if ( array_key_exists ( $ region , $ this -> matrix ) ) { unset ( $ this -> matrix [ $ region ] ) ; } return $ this ; }
1507	public function didCreate ( $ resource ) : void { if ( $ this -> wasClientDispatched ( ) ) { $ this -> clientJob -> setResource ( $ resource ) -> save ( ) ; } }
12896	public function isClosingAfterOpening ( ) { $ diff = $ this -> getOpeningDate ( ) -> diff ( $ this -> getClosingDate ( ) ) ; if ( $ diff -> invert === 0 ) { return true ; } else { return false ; } }
7053	public static function get_instance ( ) { if ( ! self :: $ instance instanceof self ) { $ new = new self ; $ new -> init ( ) ; self :: $ instance = $ new ; } return self :: $ instance ; }
296	public function isAttributeChanged ( $ name , $ identical = true ) { if ( isset ( $ this -> _attributes [ $ name ] , $ this -> _oldAttributes [ $ name ] ) ) { if ( $ identical ) { return $ this -> _attributes [ $ name ] !== $ this -> _oldAttributes [ $ name ] ; } return $ this -> _attributes [ $ name ] != $ this -> _oldAttributes [ $ name ] ; } return isset ( $ this -> _attributes [ $ name ] ) || isset ( $ this -> _oldAttributes [ $ name ] ) ; }
7719	function meth_Conv_Str ( & $ Txt , $ ConvBr = true ) { if ( $ this -> Charset === '' ) { $ Txt = htmlspecialchars ( $ Txt ) ; if ( $ ConvBr ) $ Txt = nl2br ( $ Txt ) ; } elseif ( $ this -> _CharsetFct ) { $ Txt = call_user_func ( $ this -> Charset , $ Txt , $ ConvBr ) ; } else { $ Txt = htmlspecialchars ( $ Txt , ENT_COMPAT , $ this -> Charset ) ; if ( $ ConvBr ) $ Txt = nl2br ( $ Txt ) ; } }
11616	public function invite ( $ account , $ wechatId ) { $ params = [ 'kf_account' => $ account , 'invite_wx' => $ wechatId , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_INVITE_BIND , $ params ] ) ; }
6176	public static function arrayUniqueMultidimensional ( array $ input ) { $ serialized = array_map ( 'serialize' , $ input ) ; $ unique = array_unique ( $ serialized ) ; $ output = array_intersect_key ( $ input , $ unique ) ; return array_values ( $ output ) ; }
6442	public function getAllResources ( $ name , $ full = false , array $ filters = [ ] , array $ fields = [ ] ) { $ this -> lastRequest = new Request ; $ this -> lastRequest -> setMode ( Request :: MODE_READ ) ; $ this -> lastRequest -> setResourceName ( $ name ) ; if ( $ full ) { $ this -> lastRequest -> enableFullResults ( ) ; } $ this -> lastRequest -> setFilters ( $ filters ) ; $ this -> lastRequest -> setFields ( $ fields ) ; $ data = [ ] ; $ page = 1 ; do { $ this -> lastRequest -> setCurrentPage ( $ page ) ; $ response = $ this -> proceed ( ) ; $ data = ArrayUtils :: merge ( $ data , $ response -> getData ( ) -> getData ( ) ) ; $ page ++ ; } while ( $ response -> getPagination ( ) -> getPage ( ) != $ response -> getPagination ( ) -> getPages ( ) ) ; return $ data ; }
10992	public function splitName ( string $ defaultExtension = "" ) : array { $ filename = basename ( $ this -> path ) ; $ extpos = strrpos ( $ filename , "." ) ; if ( $ extpos === false || $ extpos === 0 ) { $ name = $ filename ; $ ext = $ defaultExtension ; } else { $ name = substr ( $ filename , 0 , $ extpos ) ; $ ext = substr ( $ filename , $ extpos + 1 ) ; } return [ $ name , $ ext ] ; }
7330	private function configureSubjectRelativeMapping ( LoadClassMetadataEventArgs $ eventArgs ) { $ metadata = $ eventArgs -> getClassMetadata ( ) ; $ class = $ metadata -> getName ( ) ; if ( ! is_subclass_of ( $ class , SubjectRelativeInterface :: class ) ) { return ; } if ( in_array ( $ class , $ this -> relativeClassCache ) ) { return ; } $ this -> getSubjectIdentityMapper ( $ eventArgs -> getEntityManager ( ) ) -> processClassMetadata ( $ metadata , 'subjectIdentity' , 'subject_' ) ; $ this -> relativeClassCache [ ] = $ class ; }
9774	function satisfy ( callable $ predicate ) : self { return $ this -> expect ( call_user_func ( $ predicate , $ this -> target ) , isTrue ( ) ) ; }
8800	public function needsRehash ( $ hashedValue , array $ options = [ ] ) { return password_needs_rehash ( $ hashedValue , PASSWORD_ARGON2I , [ 'memory_cost' => $ this -> memory ( $ options ) , 'time_cost' => $ this -> time ( $ options ) , 'threads' => $ this -> threads ( $ options ) , ] ) ; }
7442	public function showAction ( $ id ) { $ em = $ this -> getDoctrine ( ) -> getEntityManager ( ) ; $ group = $ em -> getRepository ( 'Orkestra\Bundle\ApplicationBundle\Entity\Group' ) -> find ( $ id ) ; if ( ! $ group ) { throw $ this -> createNotFoundException ( 'Unable to locate Group' ) ; } return array ( 'group' => $ group , ) ; }
146	protected function moveWatch ( $ fromLiteral , $ toLiteral , $ node ) { if ( ! isset ( $ this -> watchChains [ $ toLiteral ] ) ) { $ this -> watchChains [ $ toLiteral ] = new RuleWatchChain ; } $ node -> moveWatch ( $ fromLiteral , $ toLiteral ) ; $ this -> watchChains [ $ fromLiteral ] -> remove ( ) ; $ this -> watchChains [ $ toLiteral ] -> unshift ( $ node ) ; }
3471	public function merge ( Config $ config ) : Config { $ this -> config = array_merge_recursive ( $ this -> config , $ config -> config ) ; return $ this ; }
328	public static function instance ( $ refresh = false ) { $ className = get_called_class ( ) ; if ( $ refresh || ! isset ( self :: $ _instances [ $ className ] ) ) { self :: $ _instances [ $ className ] = Yii :: createObject ( $ className ) ; } return self :: $ _instances [ $ className ] ; }
8520	public function setFulfillmentRecommendations ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'FulfillmentRecommendations' ] [ 'FieldValue' ] = $ value ; return $ this ; }
759	public function setChildren ( $ children ) { $ this -> _children = [ ] ; foreach ( $ children as $ child ) { $ child -> parent = $ this ; $ this -> _children [ ] = $ child ; } $ this -> updateCollectionOffsets ( ) ; }
2931	public function setKeys ( $ data ) { foreach ( $ data as $ setter ) { if ( array_key_exists ( 'key' , $ setter ) ) { $ key = $ this -> formatter -> formatKey ( $ setter [ 'key' ] ) ; $ value = array_key_exists ( 'value' , $ setter ) ? $ setter [ 'value' ] : null ; $ comment = array_key_exists ( 'comment' , $ setter ) ? $ setter [ 'comment' ] : null ; $ export = array_key_exists ( 'export' , $ setter ) ? $ setter [ 'export' ] : false ; if ( ! is_file ( $ this -> filePath ) || ! $ this -> keyExists ( $ key ) ) { $ this -> writer -> appendSetter ( $ key , $ value , $ comment , $ export ) ; } else { $ oldInfo = $ this -> getKeys ( [ $ key ] ) ; $ comment = is_null ( $ comment ) ? $ oldInfo [ $ key ] [ 'comment' ] : $ comment ; $ this -> writer -> updateSetter ( $ key , $ value , $ comment , $ export ) ; } } } return $ this ; }
7651	public function rename ( $ path_from , $ path_to ) { if ( $ this -> getContainerName ( $ path_from ) != $ this -> getContainerName ( $ path_to ) ) { throw new BlobException ( 'Container name can not be changed.' ) ; } if ( $ this -> getFileName ( $ path_from ) == $ this -> getContainerName ( $ path_to ) ) { return true ; } $ this -> getStorageClient ( $ path_from ) -> copyBlob ( $ this -> getContainerName ( $ path_from ) , $ this -> getFileName ( $ path_from ) , $ this -> getContainerName ( $ path_to ) , $ this -> getFileName ( $ path_to ) ) ; $ this -> getStorageClient ( $ path_from ) -> deleteBlob ( $ this -> getContainerName ( $ path_from ) , $ this -> getFileName ( $ path_from ) ) ; clearstatcache ( true , $ path_from ) ; clearstatcache ( true , $ path_to ) ; return true ; }
10876	public function processApprove ( string $ hash ) : bool { $ decode = $ this -> getDecodeHash ( $ hash ) ; $ id = ( int ) $ decode [ 'id' ] ; $ verifyHash = $ decode [ 'verifyHash' ] ; $ item = $ this -> getById ( $ id ) ; if ( $ item && $ id == $ item [ 'id' ] ) { if ( ! $ item [ 'active' ] ) { if ( $ this -> verifyHash ( $ item [ 'id' ] . $ item [ 'login' ] , $ verifyHash ) ) { return $ this -> update ( $ item [ 'id' ] , [ 'active' => true ] ) ; } else { throw new IdentityException ( 'Invalid hash!' ) ; } } else { throw new IdentityException ( 'User is already approve!' ) ; } } else { throw new IdentityException ( 'User does not exist!' ) ; } }
4871	public function setEventPrototype ( EventInterface $ prototype ) { if ( ! $ prototype instanceof DependencyResultEvent ) { throw new \ InvalidArgumentException ( 'This event manager only accepts events of the type ' . DependencyResultEvent :: class ) ; } parent :: setEventPrototype ( $ prototype ) ; }
11671	public function executeRaw ( array $ arguments , & $ error = null ) { $ error = false ; $ commandID = array_shift ( $ arguments ) ; $ response = $ this -> connection -> executeCommand ( new RawCommand ( $ commandID , $ arguments ) ) ; if ( $ response instanceof ResponseInterface ) { if ( $ response instanceof ErrorResponseInterface ) { $ error = true ; } return ( string ) $ response ; } return $ response ; }
569	protected function encrypt ( $ data , $ passwordBased , $ secret , $ info ) { if ( ! extension_loaded ( 'openssl' ) ) { throw new InvalidConfigException ( 'Encryption requires the OpenSSL PHP extension' ) ; } if ( ! isset ( $ this -> allowedCiphers [ $ this -> cipher ] [ 0 ] , $ this -> allowedCiphers [ $ this -> cipher ] [ 1 ] ) ) { throw new InvalidConfigException ( $ this -> cipher . ' is not an allowed cipher' ) ; } list ( $ blockSize , $ keySize ) = $ this -> allowedCiphers [ $ this -> cipher ] ; $ keySalt = $ this -> generateRandomKey ( $ keySize ) ; if ( $ passwordBased ) { $ key = $ this -> pbkdf2 ( $ this -> kdfHash , $ secret , $ keySalt , $ this -> derivationIterations , $ keySize ) ; } else { $ key = $ this -> hkdf ( $ this -> kdfHash , $ secret , $ keySalt , $ info , $ keySize ) ; } $ iv = $ this -> generateRandomKey ( $ blockSize ) ; $ encrypted = openssl_encrypt ( $ data , $ this -> cipher , $ key , OPENSSL_RAW_DATA , $ iv ) ; if ( $ encrypted === false ) { throw new \ yii \ base \ Exception ( 'OpenSSL failure on encryption: ' . openssl_error_string ( ) ) ; } $ authKey = $ this -> hkdf ( $ this -> kdfHash , $ key , null , $ this -> authKeyInfo , $ keySize ) ; $ hashed = $ this -> hashData ( $ iv . $ encrypted , $ authKey ) ; return $ keySalt . $ hashed ; }
1965	public function generate ( ) { $ this -> multiSRC = StringUtil :: deserialize ( $ this -> multiSRC ) ; if ( empty ( $ this -> multiSRC ) || ! \ is_array ( $ this -> multiSRC ) ) { return '' ; } $ this -> objFiles = FilesModel :: findMultipleByUuids ( $ this -> multiSRC ) ; if ( $ this -> objFiles === null ) { return '' ; } return parent :: generate ( ) ; }
85	public function getPackageFilename ( PackageInterface $ package ) { $ nameParts = array ( preg_replace ( '#[^a-z0-9-_]#i' , '-' , $ package -> getName ( ) ) ) ; if ( preg_match ( '{^[a-f0-9]{40}$}' , $ package -> getDistReference ( ) ) ) { array_push ( $ nameParts , $ package -> getDistReference ( ) , $ package -> getDistType ( ) ) ; } else { array_push ( $ nameParts , $ package -> getPrettyVersion ( ) , $ package -> getDistReference ( ) ) ; } if ( $ package -> getSourceReference ( ) ) { $ nameParts [ ] = substr ( sha1 ( $ package -> getSourceReference ( ) ) , 0 , 6 ) ; } $ name = implode ( '-' , array_filter ( $ nameParts , function ( $ p ) { return ! empty ( $ p ) ; } ) ) ; return str_replace ( '/' , '-' , $ name ) ; }
8019	public function getClient ( ) { if ( $ this -> _client === null ) { $ settings = [ 'key' => $ this -> key , 'secret' => $ this -> secret ] ; if ( $ this -> enableV4 ) $ settings [ 'signature' ] = 'v4' ; $ this -> _client = S3Client :: factory ( $ settings ) ; } return $ this -> _client ; }
1456	protected function validateHasMany ( RelationshipInterface $ relationship , $ record = null , $ key = null , ResourceObjectInterface $ resource = null ) { if ( ! $ relationship -> isHasMany ( ) ) { $ this -> addError ( $ this -> errorFactory -> relationshipHasManyExpected ( $ key ) ) ; return false ; } $ identifiers = $ relationship -> getIdentifiers ( ) ; if ( ! $ this -> validateIdentifiers ( $ identifiers , $ record , $ key , $ resource ) ) { return false ; } return true ; }
12948	public function removeTagValues ( $ tags ) { $ this -> _tagsList = array_diff ( $ this -> getTagValues ( ) , $ this -> parseTags ( $ tags ) ) ; $ this -> updateOwnerTags ( ) ; }
11896	protected function generateIV ( ) { $ sizeIV = $ this -> getSizeIV ( ) ; if ( $ sizeIV === 0 ) { return $ this ; } $ this -> setIV ( mcrypt_create_iv ( $ sizeIV , MCRYPT_RAND ) ) ; return $ this ; }
789	public function getFirstError ( $ attribute ) { return isset ( $ this -> _errors [ $ attribute ] ) ? reset ( $ this -> _errors [ $ attribute ] ) : null ; }
2456	public function deleteAll ( ) { if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notDeletable' ] ) { throw new InternalServerErrorException ( 'Table "' . $ this -> strTable . '" is not deletable.' ) ; } $ objSession = System :: getContainer ( ) -> get ( 'session' ) ; $ session = $ objSession -> all ( ) ; $ ids = $ session [ 'CURRENT' ] [ 'IDS' ] ; if ( \ is_array ( $ ids ) && \ strlen ( $ ids [ 0 ] ) ) { foreach ( $ ids as $ id ) { $ this -> intId = $ id ; $ this -> delete ( true ) ; } } $ this -> redirect ( $ this -> getReferer ( ) ) ; }
378	protected function renderException ( $ exception ) { if ( Yii :: $ app -> has ( 'response' ) ) { $ response = Yii :: $ app -> getResponse ( ) ; $ response -> isSent = false ; $ response -> stream = null ; $ response -> data = null ; $ response -> content = null ; } else { $ response = new Response ( ) ; } $ response -> setStatusCodeByException ( $ exception ) ; $ useErrorView = $ response -> format === Response :: FORMAT_HTML && ( ! YII_DEBUG || $ exception instanceof UserException ) ; if ( $ useErrorView && $ this -> errorAction !== null ) { $ result = Yii :: $ app -> runAction ( $ this -> errorAction ) ; if ( $ result instanceof Response ) { $ response = $ result ; } else { $ response -> data = $ result ; } } elseif ( $ response -> format === Response :: FORMAT_HTML ) { if ( $ this -> shouldRenderSimpleHtml ( ) ) { $ response -> data = '<pre>' . $ this -> htmlEncode ( static :: convertExceptionToString ( $ exception ) ) . '</pre>' ; } else { if ( YII_DEBUG ) { ini_set ( 'display_errors' , 1 ) ; } $ file = $ useErrorView ? $ this -> errorView : $ this -> exceptionView ; $ response -> data = $ this -> renderFile ( $ file , [ 'exception' => $ exception , ] ) ; } } elseif ( $ response -> format === Response :: FORMAT_RAW ) { $ response -> data = static :: convertExceptionToString ( $ exception ) ; } else { $ response -> data = $ this -> convertExceptionToArray ( $ exception ) ; } $ response -> send ( ) ; }
6690	public function canAccess ( $ permissionKeys , $ fullAccessKey , $ errorMsg , $ defaultUrl , $ redirect = false ) { if ( $ this -> getUser ( ) -> isGuest ) { return $ this -> getUser ( ) -> loginRequired ( ) ; } if ( $ this -> getPermissionManager ( ) -> canAccess ( $ fullAccessKey ) ) { return true ; } if ( ! is_array ( $ permissionKeys ) ) { $ permissionKeys = [ $ permissionKeys ] ; } foreach ( $ permissionKeys as $ permissionKey ) { if ( $ this -> getPermissionManager ( ) -> canAccess ( $ permissionKey ) ) { return true ; } } if ( $ redirect ) { $ this -> flashError ( $ errorMsg ) ; $ request = $ this -> getRequest ( ) ; $ referrerUrl = $ request -> referrer ; $ redirectUrl = ( $ referrerUrl == $ request -> url || is_null ( $ referrerUrl ) ) ? $ defaultUrl : $ referrerUrl ; $ this -> redirect ( $ redirectUrl ) -> send ( ) ; Yii :: $ app -> end ( ) ; } return false ; }
8508	public function getPrepInstructionsForASIN ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_GetPrepInstructionsForASINRequest ) ) { $ request = new FBAInboundServiceMWS_Model_GetPrepInstructionsForASINRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetPrepInstructionsForASIN' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_GetPrepInstructionsForASINResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
8329	public function whereExists ( Closure $ callback , $ boolean = 'and' , $ not = false ) { $ type = $ not ? 'NotExists' : 'Exists' ; $ this -> wheres [ ] = compact ( 'type' , 'callback' , 'boolean' ) ; return $ this ; }
7325	protected function cachingIsPossible ( ) { if ( static :: $ _cachingIsPossible === null ) { $ storeClass = '\AlternativeLaravelCache\Core\AlternativeCacheStore' ; $ poolInterface = '\Cache\Taggable\TaggablePoolInterface' ; $ cache = app ( 'cache.store' ) -> getStore ( ) ; static :: $ _cachingIsPossible = ( $ cache instanceof $ storeClass && $ cache -> getWrappedConnection ( ) instanceof $ poolInterface ) ; } return static :: $ _cachingIsPossible ; }
11831	public static function create ( $ command , $ app ) { static $ cache = [ ] ; $ cacheKey = $ command ; if ( isset ( $ cache [ $ cacheKey ] ) ) { $ class = $ cache [ $ cacheKey ] [ 'class' ] ; $ command = $ cache [ $ cacheKey ] [ 'command' ] ; } else { if ( false === strpos ( $ command , '.' ) ) { $ class = __NAMESPACE__ . '\\' . String :: convertToCamelCase ( $ command ) ; } else { $ class = explode ( '.' , $ command ) ; $ class = array_map ( array ( 'In2pire\\Component\\Utility\\Text' , 'convertToCamelCase' ) , $ class ) ; $ class = implode ( '\\' , $ class ) ; $ command = substr ( $ command , strrpos ( $ command , '.' ) + 1 ) ; } $ cache [ $ cacheKey ] = [ 'class' => $ class , 'command' => $ command ] ; } if ( ! class_exists ( $ class ) ) { throw new \ RuntimeException ( 'Unknow command ' . $ cacheKey ) ; } return new $ class ( $ app ) ; }
1139	public function shiftSiblingsForRestore ( ) { if ( is_null ( $ this -> getRight ( ) ) || is_null ( $ this -> getLeft ( ) ) ) return ; $ self = $ this ; $ this -> getConnection ( ) -> transaction ( function ( ) use ( $ self ) { $ lftCol = $ self -> getLeftColumnName ( ) ; $ rgtCol = $ self -> getRightColumnName ( ) ; $ lft = $ self -> getLeft ( ) ; $ rgt = $ self -> getRight ( ) ; $ diff = $ rgt - $ lft + 1 ; $ self -> newNestedSetQuery ( ) -> where ( $ lftCol , '>=' , $ lft ) -> increment ( $ lftCol , $ diff ) ; $ self -> newNestedSetQuery ( ) -> where ( $ rgtCol , '>=' , $ lft ) -> increment ( $ rgtCol , $ diff ) ; } ) ; }
1805	public function getActiveGroups ( ) { $ arrGroups = array ( ) ; $ objGroup = Contao \ MemberGroupModel :: findAllActive ( ) ; if ( $ objGroup !== null ) { while ( $ objGroup -> next ( ) ) { $ arrGroups [ $ objGroup -> id ] = $ objGroup -> name ; } } return $ arrGroups ; }
9022	public function getStopWords ( $ string , $ language = 'english' ) { $ words = $ this -> getWords ( $ string ) ; $ filter = new StopWordsFilter ( $ language ) ; $ stopWords = [ ] ; foreach ( $ words as $ word ) { if ( ! is_null ( $ filter -> filter ( $ word ) ) ) { $ stopWords [ ] = $ word ; } } return $ stopWords ; }
10178	public function removeRow ( $ row ) { foreach ( $ this -> getCoordinates ( ) as $ coord ) { sscanf ( $ coord , '%[A-Z]%d' , $ c , $ r ) ; if ( $ r == $ row ) { $ this -> delete ( $ coord ) ; } } }
6709	protected function useActualParameters ( ) { $ this -> setParameters ( $ this -> urlToParameters ( $ this -> getRequestedUri ( ) ) ) ; $ this -> setParameters ( $ _REQUEST ) ; $ this -> setParameters ( $ this -> parseHeader ( $ _SERVER ) ) ; $ this -> setParameters ( $ this -> stringToArray ( $ this -> readBody ( ) ) ) ; return $ this -> getParameters ( ) ; }
8074	public function delete ( $ endpoint , $ headers = [ ] ) { $ request = new Request ( 'DELETE' , $ endpoint , $ headers ) ; $ response = $ this -> guzzle -> send ( $ request ) ; return $ this -> handle ( $ response ) ; }
7922	private function isValidPath ( $ path ) { $ pathParts = explode ( '/' , $ path ) ; if ( ! strncmp ( $ path , '/' , 1 ) || array_search ( '..' , $ pathParts ) !== false || strpos ( $ path , ':' ) !== false ) { return false ; } return true ; }
8888	public function process ( ServerRequestInterface $ request , RequestHandlerInterface $ requestHandler ) : ResponseInterface { $ this -> container -> set ( ServerRequestInterface :: class , $ request ) ; $ result = $ this -> dispatch ( $ this -> route ( $ request ) ) ; if ( $ result instanceof ResponseInterface ) { return $ result ; } return $ response = ( new Response ( ) ) -> withProtocolVersion ( '1.1' ) -> withBody ( \ GuzzleHttp \ Psr7 \ stream_for ( $ result ) ) ; }
11153	public function getBoolean ( $ probability = 0.5 ) { if ( ( \ is_int ( $ probability ) || \ is_float ( $ probability ) ) === false || $ probability < 0 || $ probability > 1 ) { throw new InvalidArgumentException ( 'Invalid probability' ) ; } if ( $ probability == 0 ) { $ result = false ; } else { $ random = $ this -> generator -> getFloat ( 0 , 1 ) ; $ result = ( $ probability >= $ random ) ; } return $ result ; }
9908	public function setPosition ( $ position ) { if ( ! in_array ( $ position , self :: $ positionXLref ) ) { return false ; } $ this -> position = $ position ; return true ; }
5392	public function paintPass ( $ message ) { parent :: paintPass ( $ message ) ; print $ this -> getIndent ( 1 ) ; print '<' . $ this -> namespace . 'pass>' ; print $ this -> toParsedXml ( $ message ) ; print '</' . $ this -> namespace . "pass>\n" ; }
1046	public static function toSafeTrace ( $ error ) { $ trace = $ error -> getTrace ( ) ; if ( isset ( $ trace [ 0 ] [ 'function' ] ) && isset ( $ trace [ 0 ] [ 'class' ] ) && ( $ trace [ 0 ] [ 'class' ] . '::' . $ trace [ 0 ] [ 'function' ] === 'GraphQL\Utils\Utils::invariant' ) ) { array_shift ( $ trace ) ; } elseif ( ! isset ( $ trace [ 0 ] [ 'file' ] ) ) { array_shift ( $ trace ) ; } return array_map ( static function ( $ err ) { $ safeErr = array_intersect_key ( $ err , [ 'file' => true , 'line' => true ] ) ; if ( isset ( $ err [ 'function' ] ) ) { $ func = $ err [ 'function' ] ; $ args = ! empty ( $ err [ 'args' ] ) ? array_map ( [ self :: class , 'printVar' ] , $ err [ 'args' ] ) : [ ] ; $ funcStr = $ func . '(' . implode ( ', ' , $ args ) . ')' ; if ( isset ( $ err [ 'class' ] ) ) { $ safeErr [ 'call' ] = $ err [ 'class' ] . '::' . $ funcStr ; } else { $ safeErr [ 'function' ] = $ funcStr ; } } return $ safeErr ; } , $ trace ) ; }
11594	public function postAction ( ) { $ request = $ this -> environment -> getRequestHelper ( ) ; $ id = $ request -> getIdentifierParam ( 'name' ) ; try { $ this -> pageList -> getPage ( $ id ) ; } catch ( InvalidParameterException $ e ) { $ page = $ this -> pageList -> addPageFromRequest ( $ id , $ request ) ; $ this -> environment -> sendJSONResult ( $ page -> getJSON ( ) ) ; return ; } throw new InvalidParameterException ( "Page already exists" ) ; }
11587	public function end ( $ taskName ) { if ( ! isset ( $ this -> _tasks [ $ taskName ] ) ) { throw new Exception ( "Undefined task name: `'{$taskName}`." ) ; } $ task = $ this -> _tasks [ $ taskName ] ; $ task -> end ( ) ; return $ task ; }
7385	public function uploadAction ( ) { if ( $ this -> request -> hasFiles ( ) == true ) { $ this -> initializeScaffolding ( ) ; $ form = $ this -> scaffolding -> getForm ( ) ; $ name = key ( $ _FILES ) ; $ uploadElement = $ form -> get ( $ name ) ; $ model = $ uploadElement -> getModel ( ) ; $ path = $ uploadElement -> getPath ( ) ; $ maxFileSize = $ uploadElement -> getMaxFileSize ( ) ; $ minFileSize = $ uploadElement -> getMinFileSize ( ) ; foreach ( $ this -> request -> getUploadedFiles ( ) as $ file ) { $ fileName = $ file -> getName ( ) ; $ fileSize = $ file -> getSize ( ) ; $ fileType = $ file -> getRealType ( ) ; $ fileExtensions = pathinfo ( $ fileName , PATHINFO_EXTENSION ) ; $ allowed = $ uploadElement -> getAllowedExtensions ( ) ; if ( ! empty ( $ allowed ) ) { if ( ! in_array ( $ fileExtensions , $ allowed ) ) { throw new ForbiddenFileExtensionException ( ) ; } } $ forbidden = $ uploadElement -> getForbiddenExtensions ( ) ; if ( ! empty ( $ forbidden ) ) { if ( in_array ( $ fileExtensions , $ forbidden ) ) { throw new ForbiddenFileExtensionException ( ) ; } } $ allowedMime = $ uploadElement -> getAllowedMimeTypes ( ) ; if ( ! empty ( $ allowedMime ) ) { if ( ! in_array ( $ fileType , $ allowedMime ) ) { throw new ForbiddenFileMimeTypeException ( ) ; } } $ forbiddenMime = $ uploadElement -> getForbiddenMimeTypes ( ) ; if ( ! empty ( $ forbiddenMime ) ) { if ( in_array ( $ fileType , $ forbiddenMime ) ) { throw new ForbiddenFileMimeTypeException ( ) ; } } if ( ! empty ( $ maxFileSize ) ) { if ( $ fileSize > $ this -> convertFileSizeToBytes ( $ maxFileSize ) ) { throw new \ Exception ( 's' ) ; } } if ( ! empty ( $ minFileSize ) ) { if ( $ fileSize < $ this -> convertFileSizeToBytes ( $ minFileSize ) ) { throw new \ Exception ( 's' ) ; } } if ( empty ( $ path ) ) { $ path = 'files/' ; } $ model -> name = $ fileName ; $ model -> mime_type = $ fileType ; $ model -> path = $ path ; $ model -> save ( ) ; $ file -> moveTo ( $ path . $ model -> _id ) ; return $ this -> response -> setJsonContent ( ( string ) $ model -> _id ) ; } } $ this -> view -> setRenderLevel ( View :: LEVEL_NO_RENDER ) ; }
3809	protected function applyLegendConditions ( $ attributeId , $ activeLegendId ) { if ( ! isset ( $ this -> conditions [ $ activeLegendId ] ) ) { return ; } if ( ! isset ( $ this -> conditions [ $ attributeId ] ) ) { $ this -> conditions [ $ attributeId ] = new PropertyConditionChain ( ) ; } $ this -> conditions [ $ attributeId ] -> addCondition ( $ this -> conditions [ $ activeLegendId ] ) ; }
5363	public function generate ( Registry $ registry ) { $ context = $ this -> createContext ( $ registry , 'Client' ) ; $ files = [ ] ; foreach ( $ registry -> getSchemas ( ) as $ schema ) { $ context -> setCurrentSchema ( $ schema ) ; $ files = array_merge ( $ files , $ this -> modelGenerator -> generate ( $ schema , $ schema -> getRootName ( ) , $ context ) ) ; $ files = array_merge ( $ files , $ this -> normalizerGenerator -> generate ( $ schema , $ schema -> getRootName ( ) , $ context ) ) ; $ clients = $ this -> clientGenerator -> generate ( $ schema -> getParsed ( ) , $ schema -> getNamespace ( ) , $ context , $ schema -> getOrigin ( ) . '#' ) ; foreach ( $ clients as $ node ) { $ files [ ] = new File ( $ schema -> getDirectory ( ) . DIRECTORY_SEPARATOR . 'Resource' . DIRECTORY_SEPARATOR . $ node -> stmts [ 2 ] -> name . '.php' , $ node , '' ) ; } } return $ files ; }
11327	public function getLocations ( ) { if ( is_null ( $ this -> _locations ) ) { $ this -> _locations = $ this -> determineLocations ( ) ; } return $ this -> _locations ; }
3830	protected function prepareFrontendFilterOptions ( $ arrWidget , $ arrFilterUrl , $ arrJumpTo , $ blnAutoSubmit ) { $ arrOptions = array ( ) ; if ( ! isset ( $ arrWidget [ 'options' ] ) ) { return $ arrOptions ; } $ filterUrl = new FilterUrl ( $ arrJumpTo ) ; foreach ( $ arrFilterUrl as $ name => $ value ) { if ( is_array ( $ value ) ) { $ value = implode ( ',' , array_filter ( $ value ) ) ; } $ filterUrl -> setSlug ( $ name , ( string ) $ value ) ; } $ parameterName = $ arrWidget [ 'eval' ] [ 'urlparam' ] ; if ( $ arrWidget [ 'eval' ] [ 'includeBlankOption' ] ) { $ blnActive = $ this -> isActiveFrontendFilterValue ( $ arrWidget , $ arrFilterUrl , '' ) ; $ arrOptions [ ] = array ( 'key' => '' , 'value' => ( $ arrWidget [ 'eval' ] [ 'blankOptionLabel' ] ? $ arrWidget [ 'eval' ] [ 'blankOptionLabel' ] : $ GLOBALS [ 'TL_LANG' ] [ 'metamodels_frontendfilter' ] [ 'do_not_filter' ] ) , 'href' => $ this -> filterUrlBuilder -> generate ( $ filterUrl -> clone ( ) -> setSlug ( $ parameterName , '' ) ) , 'active' => $ blnActive , 'class' => 'doNotFilter' . ( $ blnActive ? ' active' : '' ) , ) ; } foreach ( $ arrWidget [ 'options' ] as $ strKeyOption => $ strOption ) { $ strValue = $ this -> getFrontendFilterValue ( $ arrWidget , $ arrFilterUrl , $ strKeyOption ) ; $ blnActive = $ this -> isActiveFrontendFilterValue ( $ arrWidget , $ arrFilterUrl , $ strKeyOption ) ; $ arrOptions [ ] = array ( 'key' => $ strKeyOption , 'value' => $ strOption , 'href' => $ this -> filterUrlBuilder -> generate ( $ filterUrl -> clone ( ) -> setSlug ( $ parameterName , $ strValue ) ) , 'active' => $ blnActive , 'class' => StringUtil :: standardize ( $ strKeyOption ) . ( $ blnActive ? ' active' : '' ) ) ; } return $ arrOptions ; }
1370	protected function bindExceptionParser ( ) { $ this -> app -> singleton ( ExceptionParserInterface :: class , ExceptionParser :: class ) ; $ this -> app -> alias ( ExceptionParserInterface :: class , 'json-api.exceptions' ) ; }
8723	public function translateOrNew ( $ locale ) { if ( is_null ( $ instance = $ this -> translate ( $ locale ) ) ) { return $ this -> newModelInstance ( ) ; } return $ instance ; }
6194	protected function loadControllers ( $ path ) { $ this -> app -> config [ 'controller' ] = array_unique ( array_merge ( $ this -> app -> config [ 'controller' ] ?? [ ] , $ path ) ) ; }
11122	public function getEndLocation ( ) { $ lastLocation = $ this -> getLocation ( ) ; $ lastDate = NOW ; foreach ( $ this -> movements as $ v ) { if ( $ v -> getEndTime ( ) > $ lastDate ) { $ lastDate = $ v -> getEndTime ( ) ; $ lastLocation = $ v -> getEndLocation ( ) ; } } return $ lastLocation ; }
12413	public function addDevice ( $ groupId , array $ deviceIdentifiers ) { $ params = [ 'group_id' => intval ( $ groupId ) , 'device_identifiers' => $ deviceIdentifiers , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_ADD_DEVICE , $ params ] ) ; }
12246	static public function sort ( array & $ nodes ) { $ args = func_get_args ( ) ; unset ( $ args [ 0 ] ) ; $ sort = array ( ) ; $ tmp = array ( ) ; foreach ( $ args as $ k => $ arg ) { if ( is_string ( $ arg ) ) { $ tmp [ $ k ] = array ( ) ; if ( preg_match ( '#^@?[a-z_0-9]+$#Di' , $ arg ) ) { if ( $ arg [ 0 ] === '@' ) { $ name = substr ( $ arg , 1 ) ; foreach ( $ nodes as $ node ) { $ tmp [ $ k ] [ ] = ( string ) $ node [ $ name ] ; } } else { foreach ( $ nodes as $ node ) { $ tmp [ $ k ] [ ] = ( string ) $ node -> $ arg ; } } } elseif ( preg_match ( '#^current\\(\\)|text\\(\\)|\\.$#i' , $ arg ) ) { foreach ( $ nodes as $ node ) { $ tmp [ $ k ] [ ] = dom_import_simplexml ( $ node ) -> textContent ; } } else { foreach ( $ nodes as $ node ) { $ _nodes = $ node -> xpath ( $ arg ) ; $ tmp [ $ k ] [ ] = ( empty ( $ _nodes ) ) ? '' : ( string ) $ _nodes [ 0 ] ; } } } else { $ tmp [ $ k ] = $ arg ; } $ sort [ ] = & $ tmp [ $ k ] ; } $ sort [ ] = & $ nodes ; call_user_func_array ( 'array_multisort' , $ sort ) ; }
7824	public function getHalfWidth ( $ up = false ) { $ number = $ this -> getTotalWidth ( ) ; return $ this -> roundHalf ( $ number , $ up ) ; }
604	protected function substring ( $ length , $ caseSensitive = true , $ offset = null ) { if ( $ offset === null ) { $ offset = $ this -> offset ; } if ( $ offset + $ length > $ this -> length ) { return '' ; } $ cacheKey = $ offset . ',' . $ length ; if ( ! isset ( $ this -> _substrings [ $ cacheKey . ',1' ] ) ) { $ this -> _substrings [ $ cacheKey . ',1' ] = mb_substr ( $ this -> sql , $ offset , $ length , 'UTF-8' ) ; } if ( ! $ caseSensitive && ! isset ( $ this -> _substrings [ $ cacheKey . ',0' ] ) ) { $ this -> _substrings [ $ cacheKey . ',0' ] = mb_strtoupper ( $ this -> _substrings [ $ cacheKey . ',1' ] , 'UTF-8' ) ; } return $ this -> _substrings [ $ cacheKey . ',' . ( int ) $ caseSensitive ] ; }
10201	private function writeCellMerge ( XMLWriter $ objWriter , Cell $ cell ) { if ( ! $ cell -> isMergeRangeValueCell ( ) ) { return ; } $ mergeRange = Coordinate :: splitRange ( $ cell -> getMergeRange ( ) ) ; list ( $ startCell , $ endCell ) = $ mergeRange [ 0 ] ; $ start = Coordinate :: coordinateFromString ( $ startCell ) ; $ end = Coordinate :: coordinateFromString ( $ endCell ) ; $ columnSpan = Coordinate :: columnIndexFromString ( $ end [ 0 ] ) - Coordinate :: columnIndexFromString ( $ start [ 0 ] ) + 1 ; $ rowSpan = $ end [ 1 ] - $ start [ 1 ] + 1 ; $ objWriter -> writeAttribute ( 'table:number-columns-spanned' , $ columnSpan ) ; $ objWriter -> writeAttribute ( 'table:number-rows-spanned' , $ rowSpan ) ; }
5535	public function divideMapNodes ( $ map , $ aspect ) { $ aspect = ! $ aspect ; $ divisions = $ map -> getSize ( ) ; $ total = $ map -> getTotalSize ( ) ; foreach ( $ map -> getChildren ( ) as $ node ) { if ( ! $ node -> isLeaf ( ) ) { $ dist = $ node -> getTotalSize ( ) / $ total * 100 ; } else { $ dist = 1 / $ total * 100 ; } if ( $ aspect ) { $ horiz = $ dist ; $ vert = 100 ; } else { $ horiz = 100 ; $ vert = $ dist ; } $ this -> paintRectangleStart ( $ node , $ horiz , $ vert ) ; $ this -> divideMapNodes ( $ node , $ aspect ) ; $ this -> paintRectangleEnd ( ) ; } }
10955	protected function redirect ( Response $ response , int $ code , string $ url ) : Response { return $ response -> withStatus ( $ code ) -> withHeader ( 'Location' , $ url ) ; }
1458	protected function previous ( Cursor $ cursor , $ columns ) { $ items = $ this -> whereId ( $ cursor -> getBefore ( ) , $ this -> descending ? '>' : '<' ) -> orderForPrevious ( ) -> get ( $ cursor -> getLimit ( ) , $ columns ) -> reverse ( ) -> values ( ) ; return new CursorPaginator ( $ items , true , $ cursor , $ this -> key ) ; }
5037	public function setImages ( array $ images , PermissionsInterface $ permissions = null ) { $ this -> clear ( ) ; foreach ( $ images as $ prop => $ image ) { $ this -> set ( $ prop , $ image , false ) ; } if ( $ permissions ) { $ this -> setPermissions ( $ permissions ) ; } return $ this ; }
12280	protected function initTemplateAssetsManager ( ) { $ templateAssetsManager = $ this -> options [ "template_assets" ] ; $ pluginManager = $ this -> options [ "plugin_manager" ] ; $ templateAssetsManager -> backend ( ) -> add ( $ pluginManager -> getAssets ( ) ) ; return $ templateAssetsManager ; }
2026	public static function findPublishedSubpagesWithoutGuestsByPid ( $ intPid , $ blnShowHidden = false , $ blnIsSitemap = false ) { $ time = Date :: floorToMinute ( ) ; $ objSubpages = Database :: getInstance ( ) -> prepare ( "SELECT p1.*, (SELECT COUNT(*) FROM tl_page p2 WHERE p2.pid=p1.id AND p2.type!='root' AND p2.type!='error_401' AND p2.type!='error_403' AND p2.type!='error_404'" . ( ! $ blnShowHidden ? ( $ blnIsSitemap ? " AND (p2.hide='' OR sitemap='map_always')" : " AND p2.hide=''" ) : "" ) . ( FE_USER_LOGGED_IN ? " AND p2.guests=''" : "" ) . ( ! BE_USER_LOGGED_IN ? " AND (p2.start='' OR p2.start<='$time') AND (p2.stop='' OR p2.stop>'" . ( $ time + 60 ) . "') AND p2.published='1'" : "" ) . ") AS subpages FROM tl_page p1 WHERE p1.pid=? AND p1.type!='root' AND p1.type!='error_401' AND p1.type!='error_403' AND p1.type!='error_404'" . ( ! $ blnShowHidden ? ( $ blnIsSitemap ? " AND (p1.hide='' OR sitemap='map_always')" : " AND p1.hide=''" ) : "" ) . ( FE_USER_LOGGED_IN ? " AND p1.guests=''" : "" ) . ( ! BE_USER_LOGGED_IN ? " AND (p1.start='' OR p1.start<='$time') AND (p1.stop='' OR p1.stop>'" . ( $ time + 60 ) . "') AND p1.published='1'" : "" ) . " ORDER BY p1.sorting" ) -> execute ( $ intPid ) ; if ( $ objSubpages -> numRows < 1 ) { return null ; } return static :: createCollectionFromDbResult ( $ objSubpages , 'tl_page' ) ; }
11117	protected function rollbackMigrations ( array $ migrations ) : void { $ this -> notify -> note ( '' ) ; foreach ( $ this -> getMigrationFiles ( M :: TYPE_DOWN ) as $ file ) { if ( in_array ( $ name = $ this -> getMigrationName ( $ file ) , $ migrations , true ) ) { $ this -> runDown ( $ file ) ; continue ; } $ this -> notify -> note ( "<fg=red>Migrate not found (in database table):</> {$name}" ) ; } }
1890	public function grantsAccess ( ) : bool { $ content = array_filter ( file ( ( string ) $ this -> file ) ) ; foreach ( $ content as $ line ) { if ( $ this -> hasRequireGranted ( $ line ) ) { return true ; } } return false ; }
4340	private function uncollapseErrors ( & $ log ) { $ groupStack = array ( ) ; for ( $ i = 0 , $ count = \ count ( $ log ) ; $ i < $ count ; $ i ++ ) { $ method = $ log [ $ i ] [ 0 ] ; if ( \ in_array ( $ method , array ( 'group' , 'groupCollapsed' ) ) ) { $ groupStack [ ] = $ i ; } elseif ( $ method == 'groupEnd' ) { \ array_pop ( $ groupStack ) ; } elseif ( \ in_array ( $ method , array ( 'error' , 'warn' ) ) ) { foreach ( $ groupStack as $ i2 ) { $ log [ $ i2 ] [ 0 ] = 'group' ; } } } }
5643	public function makeDry ( $ is_dry = true ) { $ numberOfReporters = count ( $ this -> reporters ) ; for ( $ i = 0 ; $ i < $ numberOfReporters ; $ i ++ ) { $ this -> reporters [ $ i ] -> makeDry ( $ is_dry ) ; } }
6131	protected function getSuffixIconServer ( ) { $ html = "" ; if ( $ this -> currObj [ "virtualserver_icon_id" ] ) { if ( ! $ this -> currObj -> iconIsLocal ( "virtualserver_icon_id" ) && $ this -> ftclient ) { if ( ! isset ( $ this -> cacheIcon [ $ this -> currObj [ "virtualserver_icon_id" ] ] ) ) { $ download = $ this -> currObj -> transferInitDownload ( rand ( 0x0000 , 0xFFFF ) , 0 , $ this -> currObj -> iconGetName ( "virtualserver_icon_id" ) ) ; if ( $ this -> ftclient == "data:image" ) { $ download = TeamSpeak3 :: factory ( "filetransfer://" . $ download [ "host" ] . ":" . $ download [ "port" ] ) -> download ( $ download [ "ftkey" ] , $ download [ "size" ] ) ; } $ this -> cacheIcon [ $ this -> currObj [ "virtualserver_icon_id" ] ] = $ download ; } else { $ download = $ this -> cacheIcon [ $ this -> currObj [ "virtualserver_icon_id" ] ] ; } if ( $ this -> ftclient == "data:image" ) { $ html .= $ this -> getImage ( "data:" . Convert :: imageMimeType ( $ download ) . ";base64," . base64_encode ( $ download ) , "Server Icon" , null , false ) ; } else { $ html .= $ this -> getImage ( $ this -> ftclient . "?ftdata=" . base64_encode ( serialize ( $ download ) ) , "Server Icon" , null , false ) ; } } elseif ( in_array ( $ this -> currObj [ "virtualserver_icon_id" ] , $ this -> cachedIcons ) ) { $ html .= $ this -> getImage ( "group_icon_" . $ this -> currObj [ "virtualserver_icon_id" ] . ".png" , "Server Icon" ) ; } } return $ html ; }
4996	public function getColumnMap ( ) { $ map = $ this -> getOption ( 'column_map' ) ; if ( null === $ map ) { $ map = [ ] ; foreach ( $ this as $ element ) { $ col = $ element -> getOption ( 'span' ) ; if ( null !== $ col ) { $ map [ $ element -> getName ( ) ] = $ col ; } } $ this -> setOption ( 'column_map' , $ map ) ; } return $ map ; }
863	private function changeCodeHash ( $ codeHash ) { if ( null !== $ this -> codeHash ) { self :: clearCache ( $ this -> codeHash ) ; } $ this -> codeHash = $ codeHash ; self :: setCache ( $ this -> codeHash , $ this ) ; }
7560	protected function parse_gt ( ) { if ( ( ( $ this -> pos + 1 ) < $ this -> size ) && ( $ this -> doc [ $ this -> pos + 1 ] === '=' ) ) { ++ $ this -> pos ; return ( $ this -> token = self :: TOK_COMPARE_BIGGER_THAN ) ; } else { return ( $ this -> token = self :: TOK_CHILD ) ; } }
10469	public function post ( Request $ request ) { $ this -> emit ( 'message.send' , array ( $ request -> xml ( ) ) ) ; $ response = $ this -> connector -> post ( $ request ) ; $ this -> emit ( 'message.recv' , array ( $ response ) ) ; try { return $ this -> parseXml ( $ response ) ; } catch ( InvalidXMLException $ e ) { throw new InvalidNcipResponseException ( 'Invalid response received from the NCIP service "' . $ this -> connector -> url . '": ' . $ response ) ; } }
12955	public function getObject ( $ checkAccess = true ) { $ registryClass = Yii :: $ app -> classes [ 'Registry' ] ; $ return = $ registryClass :: getObject ( $ this -> registry_id , $ checkAccess ) ; if ( get_class ( $ return ) === 'cascade\models\Registry' ) { \ d ( $ this -> registry_id ) ; exit ; } return $ return ; }
4475	public function fail ( string $ group , string $ message ) { if ( $ this -> completed || $ this -> failed ) { throw new JobAlreadyFinishedException ( ) ; } $ jsonData = json_encode ( $ this -> data , JSON_UNESCAPED_SLASHES ) ? : '{}' ; $ this -> getEventsManager ( ) -> fire ( new JobEvent \ OnFailure ( $ this , $ this , $ group , $ message ) ) ; $ this -> failed = true ; return $ this -> client -> fail ( $ this -> jid , $ this -> worker , $ group , $ message , $ jsonData ) ; }
12482	private function mapByGeneration ( $ mapByDepthDesc , $ mapById ) { $ result = [ ] ; foreach ( $ mapByDepthDesc as $ depth => $ ids ) { foreach ( $ ids as $ custId ) { $ entry = $ mapById [ $ custId ] ; $ path = $ entry -> getPath ( ) ; $ parents = $ this -> hlpTree -> getParentsFromPathReversed ( $ path ) ; $ level = 0 ; foreach ( $ parents as $ parentId ) { $ level += 1 ; if ( ! isset ( $ result [ $ parentId ] ) ) { $ result [ $ parentId ] = [ ] ; } if ( ! isset ( $ result [ $ parentId ] [ $ level ] ) ) { $ result [ $ parentId ] [ $ level ] = [ ] ; } $ result [ $ parentId ] [ $ level ] [ ] = $ custId ; } } } return $ result ; }
3771	public function fixupModules ( DataContainer $ dataContainer ) { if ( ! class_exists ( 'tl_user_group' , false ) ) { throw new \ RuntimeException ( 'data container is not loaded!' ) ; } $ original = new \ tl_user_group ( ) ; $ modules = $ original -> getModules ( ) ; foreach ( array_keys ( $ modules ) as $ group ) { foreach ( $ modules [ $ group ] as $ key => $ module ) { if ( strpos ( $ module , 'metamodel_' ) === 0 ) { unset ( $ modules [ $ group ] [ $ key ] ) ; } } $ modules [ $ group ] = array_values ( $ modules [ $ group ] ) ; } $ modules [ 'metamodels' ] [ ] = 'support_metamodels' ; if ( false !== $ index = array_search ( 'metamodels' , $ modules [ 'metamodels' ] , true ) ) { unset ( $ modules [ 'metamodels' ] [ $ index ] ) ; $ modules [ 'metamodels' ] = array_values ( $ modules [ 'metamodels' ] ) ; } $ combinations = $ this -> combinationBuilder -> getCombinationsForUser ( [ $ dataContainer -> activeRecord -> id ] , 'be' ) ; $ screenIds = array_map ( function ( $ combination ) { return $ combination [ 'dca_id' ] ; } , $ combinations [ 'byName' ] ) ; $ screens = $ this -> inputScreens -> fetchInputScreens ( $ screenIds ) ; $ locale = $ this -> requestStack -> getCurrentRequest ( ) -> getLocale ( ) ; foreach ( $ screens as $ metaModel => $ screen ) { if ( 'standalone' === $ screen [ 'meta' ] [ 'rendertype' ] ) { $ modules [ $ screen [ 'meta' ] [ 'backendsection' ] ] [ ] = 'metamodel_' . $ metaModel ; $ this -> buildLanguageString ( 'metamodel_' . $ metaModel , $ screen , $ locale ) ; } } return $ modules ; }
12799	public function getFilePointer ( ) { if ( ! isset ( $ this -> _filePointer ) ) { ini_set ( 'auto_detect_line_endings' , true ) ; $ this -> _filePointer = false ; $ file = null ; if ( isset ( $ this -> local ) && file_exists ( $ this -> local ) ) { $ file = $ this -> local ; $ pathinfo = pathinfo ( $ this -> local ) ; } elseif ( isset ( $ this -> url ) ) { $ fileCacheKey = md5 ( __CLASS__ . __FUNCTION__ . $ this -> url ) ; $ fileContent = Yii :: $ app -> fileCache -> get ( $ fileCacheKey ) ; $ pathinfo = pathinfo ( $ this -> url ) ; $ file = Yii :: $ app -> fileStorage -> getTempFile ( false , $ pathinfo [ 'extension' ] ) ; if ( $ fileContent ) { file_put_contents ( $ file , $ fileContent ) ; } else { if ( ! $ this -> downloadFile ( $ this -> url , $ file ) ) { $ file = null ; } else { Yii :: $ app -> fileCache -> set ( $ fileCacheKey , file_get_contents ( $ file ) , 86400 ) ; } } } if ( isset ( $ file ) ) { $ file = $ this -> normalizeFile ( $ file ) ; } if ( file_exists ( $ file ) ) { $ this -> _filePointer = fopen ( $ file , 'r' ) ; } } return $ this -> _filePointer ; }
12212	public function getSnippet ( string $ snptName = '' ) { if ( empty ( $ snptName ) ) { return $ this -> snippets ; } else { return isset ( $ this -> snippets [ $ snptName ] ) ? $ this -> snippets [ $ snptName ] : null ; } }
3182	public function getMinimumRemainingTime ( ) { if ( ( $ timeLimits = $ this -> getSource ( ) -> getTimeLimits ( ) ) !== null && ( $ minTime = $ timeLimits -> getMinTime ( ) ) !== null ) { return $ this -> getRemainingTimeFrom ( $ minTime ) ; } return false ; }
11634	public function bindPage ( array $ deviceIdentifier , array $ pageIds ) { $ params = [ 'device_identifier' => $ deviceIdentifier , 'page_ids' => $ pageIds , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_DEVICE_BINDPAGE , $ params ] ) ; }
1711	public function setEmptyEndTime ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ varValue === null ) { $ varValue = $ dc -> activeRecord -> startTime ; } return $ varValue ; }
42	public static function getCertificateNames ( $ certificate ) { if ( is_array ( $ certificate ) ) { $ info = $ certificate ; } elseif ( CaBundle :: isOpensslParseSafe ( ) ) { $ info = openssl_x509_parse ( $ certificate , false ) ; } if ( ! isset ( $ info [ 'subject' ] [ 'commonName' ] ) ) { return null ; } $ commonName = strtolower ( $ info [ 'subject' ] [ 'commonName' ] ) ; $ subjectAltNames = array ( ) ; if ( isset ( $ info [ 'extensions' ] [ 'subjectAltName' ] ) ) { $ subjectAltNames = preg_split ( '{\s*,\s*}' , $ info [ 'extensions' ] [ 'subjectAltName' ] ) ; $ subjectAltNames = array_filter ( array_map ( function ( $ name ) { if ( 0 === strpos ( $ name , 'DNS:' ) ) { return strtolower ( ltrim ( substr ( $ name , 4 ) ) ) ; } return null ; } , $ subjectAltNames ) ) ; $ subjectAltNames = array_values ( $ subjectAltNames ) ; } return array ( 'cn' => $ commonName , 'san' => $ subjectAltNames , ) ; }
2460	protected function paginationMenu ( ) { $ objSessionBag = System :: getContainer ( ) -> get ( 'session' ) -> getBag ( 'contao_backend' ) ; $ session = $ objSessionBag -> all ( ) ; $ filter = ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'mode' ] == 4 ) ? $ this -> strTable . '_' . CURRENT_ID : $ this -> strTable ; list ( $ offset , $ limit ) = explode ( ',' , $ this -> limit ) ; if ( isset ( $ _GET [ 'lp' ] ) ) { $ lp = ( int ) Input :: get ( 'lp' ) - 1 ; if ( $ lp >= 0 && $ lp < ceil ( $ this -> total / $ limit ) ) { $ session [ 'filter' ] [ $ filter ] [ 'limit' ] = ( $ lp * $ limit ) . ',' . $ limit ; $ objSessionBag -> replace ( $ session ) ; } $ this -> redirect ( preg_replace ( '/&(amp;)?lp=[^&]+/i' , '' , Environment :: get ( 'request' ) ) ) ; } if ( $ limit ) { Input :: setGet ( 'lp' , $ offset / $ limit + 1 ) ; } $ objPagination = new Pagination ( $ this -> total , $ limit , 7 , 'lp' , new BackendTemplate ( 'be_pagination' ) , true ) ; return $ objPagination -> generate ( ) ; }
8310	public function standardizeUrlFormat ( & $ rules , $ pageUrl ) { if ( ! is_string ( $ pageUrl ) || $ pageUrl === "" || ! is_array ( $ rules ) || ! array_key_exists ( $ pageUrl , $ rules ) ) { return ; } $ oldIndex = $ pageUrl ; if ( $ pageUrl [ 0 ] !== '/' ) { $ pageUrl = '/' . $ pageUrl ; } $ len = strlen ( $ pageUrl ) ; if ( $ len > 1 && $ pageUrl [ $ len - 1 ] === '/' ) { $ pageUrl = rtrim ( $ pageUrl , '/' ) ; } if ( $ oldIndex !== $ pageUrl ) { $ rules [ $ pageUrl ] = $ rules [ $ oldIndex ] ; unset ( $ rules [ $ oldIndex ] ) ; } }
3153	public function storeTraceVariable ( RunnerServiceContext $ context , $ itemUri , $ variableIdentifier , $ variableValue ) { $ this -> assertQtiRunnerServiceContext ( $ context ) ; $ metaVariable = $ this -> getTraceVariable ( $ variableIdentifier , $ variableValue ) ; return $ this -> storeVariable ( $ context , $ itemUri , $ metaVariable ) ; }
502	public function registerClientScript ( ) { $ id = $ this -> grid -> options [ 'id' ] ; $ options = Json :: encode ( [ 'name' => $ this -> name , 'class' => $ this -> cssClass , 'multiple' => $ this -> multiple , 'checkAll' => $ this -> grid -> showHeader ? $ this -> getHeaderCheckBoxName ( ) : null , ] ) ; $ this -> grid -> getView ( ) -> registerJs ( "jQuery('#$id').yiiGridView('setSelectionColumn', $options);" ) ; }
239	private function loadTableMetadataFromCache ( $ cache , $ name ) { if ( $ cache === null ) { $ this -> _tableMetadata [ $ name ] = [ ] ; return ; } $ metadata = $ cache -> get ( $ this -> getCacheKey ( $ name ) ) ; if ( ! is_array ( $ metadata ) || ! isset ( $ metadata [ 'cacheVersion' ] ) || $ metadata [ 'cacheVersion' ] !== static :: SCHEMA_CACHE_VERSION ) { $ this -> _tableMetadata [ $ name ] = [ ] ; return ; } unset ( $ metadata [ 'cacheVersion' ] ) ; $ this -> _tableMetadata [ $ name ] = $ metadata ; }
3358	public function resize ( $ width = false , $ height = false ) { if ( ! $ width && ! $ height ) { throw new \ Exception ( 'Please, provide at least $width or $height for resize' ) ; } $ result = clone $ this ; $ result -> operations [ ] [ 'resize' ] = array ( 'width' => $ width , 'height' => $ height , ) ; return $ result ; }
9010	public function char ( int $ size = 36 , string $ charset = null ) : self { $ this -> type = 'char(' . $ size . ')' . $ this -> stringOptions ( $ charset ) ; return $ this ; }
5806	public function validate ( ValidationResult $ result ) { $ validate = 'Title' ; $ class = $ this -> owner -> ClassName ; foreach ( Config :: inst ( ) -> get ( 'FusionService' , 'custom_tag_types' ) as $ type => $ field ) { if ( $ type === $ class ) { $ validate = $ field ; } } if ( $ result -> valid ( ) && ! $ this -> owner -> $ validate ) { $ result -> error ( "\"{$validate}\" required!" ) ; } $ this -> owner -> extend ( 'validateFusionExtension' , $ result ) ; return $ result ; }
1856	protected function getPageLayout ( $ objPage ) { $ objLayout = LayoutModel :: findByPk ( $ objPage -> layout ) ; if ( null === $ objLayout ) { $ this -> log ( 'Could not find layout ID "' . $ objPage -> layout . '"' , __METHOD__ , TL_ERROR ) ; throw new NoLayoutSpecifiedException ( 'No layout specified' ) ; } $ objPage -> hasJQuery = $ objLayout -> addJQuery ; $ objPage -> hasMooTools = $ objLayout -> addMooTools ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getPageLayout' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getPageLayout' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getPageLayout' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ objPage , $ objLayout , $ this ) ; } } return $ objLayout ; }
11800	public function substitution ( $ search , $ replace ) { $ this -> body = str_replace ( $ search , $ replace , $ this -> body ) ; return $ this -> body ; }
7961	public function canResetDslamPort ( $ forceReload = false ) { if ( ! $ this -> properties || $ forceReload ) $ this -> getProperties ( ) ; return $ this -> properties -> capabilities -> canResetDslamPort ; }
3307	protected function buildRequestParam ( $ images , $ options = [ ] ) { if ( is_array ( $ images ) && ! empty ( $ images [ 0 ] ) ) { $ images = $ images [ 0 ] ; } if ( $ this -> supportUrl && FileConverter :: isUrl ( $ images ) ) { $ options [ 'url' ] = $ images ; } else { $ options [ 'image' ] = FileConverter :: toBase64Encode ( $ images ) ; } return $ options ; }
1587	public function pointerForRelationship ( string $ key , string $ default = '/' ) : string { $ field = collect ( explode ( '.' , $ key ) ) -> first ( ) ; if ( ! $ this -> isRelationship ( $ field ) ) { throw new \ InvalidArgumentException ( "Field {$field} is not a relationship." ) ; } $ pointer = $ this -> pointer ( $ key ) ; return Str :: after ( $ pointer , "relationships/{$field}" ) ? : $ default ; }
9622	public function getPdo ( $ connection = null ) { if ( $ connection === null ) { $ connection = $ this -> defaultConnection ; } if ( isset ( $ this -> instances [ $ connection ] ) ) { return $ this -> instances [ $ connection ] ; } $ config = $ this -> getConnectionConfig ( $ connection ) ; return $ this -> instances [ $ connection ] = $ this -> factory -> makePdo ( $ config , $ connection ) ; }
11506	public function offsetSet ( $ slot , $ connection ) { if ( ! static :: isValid ( $ slot ) ) { throw new \ OutOfBoundsException ( "Invalid slot $slot for `$connection`" ) ; } $ this -> slots [ ( int ) $ slot ] = ( string ) $ connection ; }
3192	public function save ( ) { if ( ! $ this -> storage ) { throw new InvalidStorageException ( 'A storage must be defined in order to store the data!' ) ; } $ this -> storage -> store ( $ this -> toArray ( ) ) ; return $ this ; }
1623	public function buildCondition ( $ condition , & $ columns ) { static $ builders = [ 'not' => 'buildNotCondition' , 'and' => 'buildAndCondition' , 'or' => 'buildAndCondition' , 'between' => 'buildBetweenCondition' , 'not between' => 'buildBetweenCondition' , 'in' => 'buildInCondition' , 'not in' => 'buildInCondition' , 'like' => 'buildLikeCondition' , 'not like' => 'buildLikeCondition' , 'or like' => 'buildLikeCondition' , 'or not like' => 'buildLikeCondition' , '>' => 'buildCompareCondition' , '>=' => 'buildCompareCondition' , '<' => 'buildCompareCondition' , '<=' => 'buildCompareCondition' , ] ; if ( ! is_array ( $ condition ) ) { throw new NotSupportedException ( 'Where condition must be an array in redis ActiveRecord.' ) ; } if ( isset ( $ condition [ 0 ] ) ) { $ operator = strtolower ( $ condition [ 0 ] ) ; if ( isset ( $ builders [ $ operator ] ) ) { $ method = $ builders [ $ operator ] ; array_shift ( $ condition ) ; return $ this -> $ method ( $ operator , $ condition , $ columns ) ; } else { throw new Exception ( 'Found unknown operator in query: ' . $ operator ) ; } } else { return $ this -> buildHashCondition ( $ condition , $ columns ) ; } }
9672	private function writeBorderPr ( XMLWriter $ objWriter , $ pName , Border $ pBorder ) { if ( $ pBorder -> getBorderStyle ( ) != Border :: BORDER_NONE ) { $ objWriter -> startElement ( $ pName ) ; $ objWriter -> writeAttribute ( 'style' , $ pBorder -> getBorderStyle ( ) ) ; $ objWriter -> startElement ( 'color' ) ; $ objWriter -> writeAttribute ( 'rgb' , $ pBorder -> getColor ( ) -> getARGB ( ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; } }
10857	public function getMarked ( string $ marker ) : array { if ( ! \ is_subclass_of ( $ marker , Marker :: class ) ) { throw new \ InvalidArgumentException ( \ sprintf ( 'Marker implementation %s must extend %s' , $ marker , Marker :: class ) ) ; } if ( ! isset ( $ this -> marked [ $ marker ] ) ) { $ this -> cacheMarkers ( $ marker ) ; } return \ array_map ( function ( array $ marked ) { return $ this -> shared [ $ marked [ 0 ] -> typeName ] ?? $ this -> get ( $ marked [ 0 ] -> typeName ) ; } , $ this -> marked [ $ marker ] ) ; }
10583	public static function dumpResponse ( ResponseInterface $ response ) { $ statusLine = sprintf ( "HTTP/%s %d %s" , $ response -> getProtocolVersion ( ) , $ response -> getStatusCode ( ) , $ response -> getReasonPhrase ( ) ) ; header ( $ statusLine , true , $ response -> getStatusCode ( ) ) ; foreach ( $ response -> getHeaders ( ) as $ name => $ values ) { foreach ( $ values as $ value ) { header ( sprintf ( '%s: %s' , $ name , $ value ) , false ) ; } } $ body = $ response -> getBody ( ) ; while ( ! $ body -> eof ( ) ) { echo $ body -> read ( 1024 ) ; } }
7443	public function newAction ( ) { $ group = new Group ( ) ; $ form = $ this -> createForm ( GroupType :: class , $ group ) ; return array ( 'group' => $ group , 'form' => $ form -> createView ( ) ) ; }
589	protected function registerBundle ( $ bundles , $ name , & $ registered ) { if ( ! isset ( $ registered [ $ name ] ) ) { $ registered [ $ name ] = false ; $ bundle = $ bundles [ $ name ] ; foreach ( $ bundle -> depends as $ depend ) { $ this -> registerBundle ( $ bundles , $ depend , $ registered ) ; } unset ( $ registered [ $ name ] ) ; $ registered [ $ name ] = $ bundle ; } elseif ( $ registered [ $ name ] === false ) { throw new Exception ( "A circular dependency is detected for target '{$name}': " . $ this -> composeCircularDependencyTrace ( $ name , $ registered ) . '.' ) ; } }
2	private function buildDependency10Info ( $ depArray ) { static $ dep10toOperatorMap = array ( 'has' => '==' , 'eq' => '==' , 'ge' => '>=' , 'gt' => '>' , 'le' => '<=' , 'lt' => '<' , 'not' => '!=' ) ; $ result = array ( ) ; foreach ( $ depArray as $ depItem ) { if ( empty ( $ depItem [ 'rel' ] ) || ! array_key_exists ( $ depItem [ 'rel' ] , $ dep10toOperatorMap ) ) { continue ; } $ depType = ! empty ( $ depItem [ 'optional' ] ) && 'yes' == $ depItem [ 'optional' ] ? 'optional' : 'required' ; $ depType = 'not' == $ depItem [ 'rel' ] ? 'conflicts' : $ depType ; $ depVersion = ! empty ( $ depItem [ 'version' ] ) ? $ this -> parseVersion ( $ depItem [ 'version' ] ) : '*' ; $ depVersionConstraint = ( 'has' == $ depItem [ 'rel' ] || 'not' == $ depItem [ 'rel' ] ) && '*' == $ depVersion ? '*' : $ dep10toOperatorMap [ $ depItem [ 'rel' ] ] . $ depVersion ; switch ( $ depItem [ 'type' ] ) { case 'php' : $ depChannelName = 'php' ; $ depPackageName = '' ; break ; case 'pkg' : $ depChannelName = ! empty ( $ depItem [ 'channel' ] ) ? $ depItem [ 'channel' ] : 'pear.php.net' ; $ depPackageName = $ depItem [ 'name' ] ; break ; case 'ext' : $ depChannelName = 'ext' ; $ depPackageName = $ depItem [ 'name' ] ; break ; case 'os' : case 'sapi' : $ depChannelName = '' ; $ depPackageName = '' ; break ; default : $ depChannelName = '' ; $ depPackageName = '' ; break ; } if ( '' != $ depChannelName ) { $ result [ ] = new DependencyConstraint ( $ depType , $ depVersionConstraint , $ depChannelName , $ depPackageName ) ; } } return $ result ; }
888	private function isStrictOrNullableReturnTypeFunction ( Tokens $ tokens , $ returnIndex ) { $ functionIndex = $ returnIndex ; do { $ functionIndex = $ tokens -> getPrevTokenOfKind ( $ functionIndex , [ [ T_FUNCTION ] ] ) ; if ( null === $ functionIndex ) { return false ; } $ openingCurlyBraceIndex = $ tokens -> getNextTokenOfKind ( $ functionIndex , [ '{' ] ) ; $ closingCurlyBraceIndex = $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_CURLY_BRACE , $ openingCurlyBraceIndex ) ; } while ( $ closingCurlyBraceIndex < $ returnIndex ) ; $ possibleVoidIndex = $ tokens -> getPrevMeaningfulToken ( $ openingCurlyBraceIndex ) ; $ isStrictReturnType = $ tokens [ $ possibleVoidIndex ] -> isGivenKind ( T_STRING ) && 'void' !== $ tokens [ $ possibleVoidIndex ] -> getContent ( ) ; $ nullableTypeIndex = $ tokens -> getNextTokenOfKind ( $ functionIndex , [ [ CT :: T_NULLABLE_TYPE ] ] ) ; $ isNullableReturnType = null !== $ nullableTypeIndex && $ nullableTypeIndex < $ openingCurlyBraceIndex ; return $ isStrictReturnType || $ isNullableReturnType ; }
3785	private function updateValues ( array & $ values , PropertiesDefinitionInterface $ properties , DataProviderInterface $ dataProvider ) { foreach ( $ values as $ propertyName => $ propertyValue ) { if ( ( $ dataProvider -> getIdProperty ( ) === $ propertyName ) || ( $ dataProvider -> getGroupColumnProperty ( ) === $ propertyName ) || ( $ dataProvider -> getSortingColumnProperty ( ) === $ propertyName ) || ( $ dataProvider -> getTimeStampProperty ( ) === $ propertyName ) || ! $ properties -> hasProperty ( $ propertyName ) ) { continue ; } $ values [ $ propertyName ] = ModelManipulator :: sanitizeValue ( $ properties -> getProperty ( $ propertyName ) , $ propertyValue ) ; } return $ values ; }
2561	public function loadSpecificChanges ( $ changeTicketing , $ changeQueueing , $ changeOptQueueEl ) { if ( $ changeTicketing ) { $ this -> specificChanges [ ] = new SpecificChanges ( SpecificChanges :: ACTION_TICKETING_OFFICE ) ; } if ( $ changeQueueing ) { $ this -> specificChanges [ ] = new SpecificChanges ( SpecificChanges :: ACTION_QUEUEING_OFFICE ) ; } if ( $ changeOptQueueEl ) { $ this -> specificChanges [ ] = new SpecificChanges ( SpecificChanges :: ACTION_OPT_QUEUE_ELEMENT ) ; } }
7315	public function setDateTime ( $ year , $ month , $ day , $ hour , $ min , $ sec ) { return $ this -> setDate ( $ year , $ month , $ day ) -> setTime ( $ hour , $ min , $ sec ) ; }
9306	public function setAllowJsonApi ( $ allowJsonApi ) { if ( ! is_bool ( $ allowJsonApi ) ) { throw new \ InvalidArgumentException ( '`allowJsonApi` expects boolean value!' ) ; } $ this -> options [ 'allowJsonApi' ] = ( bool ) $ allowJsonApi ; return $ this ; }
7985	public function getAvailableOptions ( $ domain ) { $ domain = ( string ) $ domain ; if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; try { $ r = $ this -> get ( 'vps/' . $ domain . '/availableOptions' ) -> send ( ) ; } catch ( ClientErrorResponseException $ e ) { if ( $ e -> getResponse ( ) -> getStatusCode ( ) == '404' && json_decode ( $ e -> getResponse ( ) -> getBody ( ) ) -> message == "No options found" ) return "[]" ; else throw new VpsException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } catch ( \ Exception $ e ) { throw new VpsException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
206	public static function stdin ( $ raw = false ) { return $ raw ? fgets ( \ STDIN ) : rtrim ( fgets ( \ STDIN ) , PHP_EOL ) ; }
1910	protected function createTemplate ( Model $ model , string $ templateName ) : Template { if ( isset ( $ this -> options [ 'template' ] ) ) { $ templateName = $ this -> options [ 'template' ] ; } if ( $ model -> customTpl ) { $ templateName = $ model -> customTpl ; } $ template = $ this -> get ( 'contao.framework' ) -> createInstance ( FrontendTemplate :: class , [ $ templateName ] ) ; $ template -> setData ( $ model -> row ( ) ) ; return $ template ; }
6861	public function doDefaultValueConversionByType ( $ value , $ type , array $ record ) { switch ( $ type ) { case static :: TYPE_DATETIME : return date ( static :: FORMAT_DATETIME , is_numeric ( $ value ) ? $ value : strtotime ( $ value ) ) ; case static :: TYPE_DATE : return date ( static :: FORMAT_DATE , is_numeric ( $ value ) ? $ value : strtotime ( $ value ) ) ; case static :: TYPE_TIME : return date ( static :: FORMAT_TIME , is_numeric ( $ value ) ? $ value : strtotime ( $ value ) ) ; case static :: TYPE_MULTILINE : return '<pre class="multiline-text">' . $ value . '</pre>' ; case static :: TYPE_JSON : case static :: TYPE_JSONB : if ( ! is_array ( $ value ) && $ value !== null ) { if ( is_string ( $ value ) || is_numeric ( $ value ) || is_bool ( $ value ) ) { $ value = json_decode ( $ value , true ) ; if ( $ value === null && strtolower ( $ value ) !== 'null' ) { $ value = 'Failed to decode JSON: ' . print_r ( $ value , true ) ; } } else { $ value = 'Invalid value for JSON: ' . print_r ( $ value , true ) ; } } return '<pre class="json-text">' . htmlentities ( stripslashes ( json_encode ( $ value , JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE ) ) ) . '</pre>' ; break ; } return $ value ; }
5759	public function buildPermission ( int $ id , string $ title , ? string $ description , bool $ active , \ DateTimeImmutable $ created , array $ roles ) : Permission { return new Permission ( $ id , $ title , $ description , $ active , $ created , $ roles ) ; }
5766	private function clear ( ) { if ( ! isset ( $ this -> phpMailer ) ) { return ; } $ this -> phpMailer -> clearAddresses ( ) ; $ this -> phpMailer -> clearCCs ( ) ; $ this -> phpMailer -> clearBCCs ( ) ; $ this -> phpMailer -> clearReplyTos ( ) ; $ this -> phpMailer -> clearAllRecipients ( ) ; $ this -> phpMailer -> clearAttachments ( ) ; $ this -> phpMailer -> clearCustomHeaders ( ) ; }
8664	private function convertManageReportSchedule ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'ManageReportSchedule' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetReportType ( ) ) { $ parameters [ 'ReportType' ] = $ request -> getReportType ( ) ; } if ( $ request -> isSetSchedule ( ) ) { $ parameters [ 'Schedule' ] = $ request -> getSchedule ( ) ; } if ( $ request -> isSetScheduleDate ( ) ) { $ parameters [ 'ScheduleDate' ] = $ this -> getFormattedTimestamp ( $ request -> getScheduleDate ( ) ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
8865	public function run ( PayloadInterface $ payload ) { $ tasks = $ this -> getTaskCollection ( ) -> getTasks ( ) ; $ tasksCount = $ tasks -> count ( ) ; if ( 0 === $ tasksCount ) { throw new LogicException ( 'Can\'t invoke task run. Empty task collection set.' ) ; } $ this -> log ( LogLevel :: INFO , sprintf ( 'Starting runner with %s tasks ready for execution.' , $ tasksCount ) ) ; $ this -> dispatch ( 'runner.start' , null , $ payload ) ; foreach ( $ tasks as $ task ) { try { $ task -> setPayload ( $ payload ) ; $ this -> runTask ( $ task , $ payload ) ; } catch ( \ Exception $ e ) { $ this -> logTask ( $ task , LogLevel :: ERROR , sprintf ( 'An exception was thrown. Message: %s' , $ e -> getMessage ( ) ) ) ; $ this -> dispatch ( 'runner.failure' , null , null , null , $ e ) ; throw new RunFailedException ( 'Complete run failed: ' . $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } } $ this -> log ( LogLevel :: INFO , 'All tasks were processed.' ) ; $ this -> log ( LogLevel :: INFO , 'Calling attached runners.' ) ; $ this -> notify ( $ payload ) ; $ this -> log ( LogLevel :: INFO , 'Execution successful.' ) ; $ this -> dispatch ( 'runner.success' , null , $ payload ) ; return $ payload ; }
1120	public function getRoot ( ) { if ( $ this -> exists ) { return $ this -> ancestorsAndSelf ( ) -> whereNull ( $ this -> getParentColumnName ( ) ) -> first ( ) ; } else { $ parentId = $ this -> getParentId ( ) ; if ( ! is_null ( $ parentId ) && $ currentParent = static :: find ( $ parentId ) ) { return $ currentParent -> getRoot ( ) ; } else { return $ this ; } } }
1391	protected function resourceFieldsExistInAttributesAndRelationships ( iterable $ fields ) : void { foreach ( $ fields as $ field ) { $ this -> errors -> add ( $ this -> translator -> resourceFieldExistsInAttributesAndRelationships ( $ field ) ) ; } }
7272	public static function deleteWhere ( $ condition = "" , array $ conditionParams = [ ] ) { $ tableName = static :: tableName ( ) ; if ( empty ( $ condition ) ) return Db :: query ( "delete from $tableName" , [ ] , static :: getDbName ( ) , false ) ; else return Db :: query ( " delete from $tableName where $condition " , $ conditionParams , static :: getDbName ( ) , false ) ; }
130	protected function requestXml ( $ origin , $ path ) { $ xml = simplexml_load_string ( $ this -> requestContent ( $ origin , $ path ) , "SimpleXMLElement" , LIBXML_NOERROR ) ; if ( false === $ xml ) { throw new \ UnexpectedValueException ( sprintf ( 'The PEAR channel at ' . $ origin . ' is broken. (Invalid XML at file `%s`)' , $ path ) ) ; } return $ xml ; }
7426	private function isValid ( $ source = '' ) { if ( empty ( $ source ) ) { return false ; } else { $ extension = substr ( $ source , - 3 ) ; if ( strtolower ( $ extension ) !== 'swf' ) { return false ; } } return true ; }
320	protected function renderBodyEndHtml ( $ ajaxMode ) { $ lines = [ ] ; if ( ! empty ( $ this -> jsFiles [ self :: POS_END ] ) ) { $ lines [ ] = implode ( "\n" , $ this -> jsFiles [ self :: POS_END ] ) ; } if ( $ ajaxMode ) { $ scripts = [ ] ; if ( ! empty ( $ this -> js [ self :: POS_END ] ) ) { $ scripts [ ] = implode ( "\n" , $ this -> js [ self :: POS_END ] ) ; } if ( ! empty ( $ this -> js [ self :: POS_READY ] ) ) { $ scripts [ ] = implode ( "\n" , $ this -> js [ self :: POS_READY ] ) ; } if ( ! empty ( $ this -> js [ self :: POS_LOAD ] ) ) { $ scripts [ ] = implode ( "\n" , $ this -> js [ self :: POS_LOAD ] ) ; } if ( ! empty ( $ scripts ) ) { $ lines [ ] = Html :: script ( implode ( "\n" , $ scripts ) ) ; } } else { if ( ! empty ( $ this -> js [ self :: POS_END ] ) ) { $ lines [ ] = Html :: script ( implode ( "\n" , $ this -> js [ self :: POS_END ] ) ) ; } if ( ! empty ( $ this -> js [ self :: POS_READY ] ) ) { $ js = "jQuery(function ($) {\n" . implode ( "\n" , $ this -> js [ self :: POS_READY ] ) . "\n});" ; $ lines [ ] = Html :: script ( $ js ) ; } if ( ! empty ( $ this -> js [ self :: POS_LOAD ] ) ) { $ js = "jQuery(window).on('load', function () {\n" . implode ( "\n" , $ this -> js [ self :: POS_LOAD ] ) . "\n});" ; $ lines [ ] = Html :: script ( $ js ) ; } } return empty ( $ lines ) ? '' : implode ( "\n" , $ lines ) ; }
7005	private function format_d ( & $ str ) { if ( strstr ( $ str , '%d' ) ) $ str = str_replace ( '%d' , sprintf ( '%02d' , $ this -> day ) , $ str ) ; }
5829	public function newRawRequest ( $ method , $ url , $ data = '' ) { return $ this -> newRequest ( $ method , $ url , $ data , Request :: ENCODING_RAW ) ; }
11375	public function upload ( string $ sFile ) { if ( $ _FILES [ $ sFile ] [ 'error' ] > 0 ) { $ this -> _sError = "Error while the upload" ; return false ; } if ( $ _FILES [ $ sFile ] [ 'size' ] > $ this -> _iMaxFile ) { $ this -> _sError = "The file is too big" ; return false ; } $ sExtension = strtolower ( substr ( strrchr ( $ _FILES [ $ sFile ] [ 'name' ] , '.' ) , 1 ) ) ; if ( count ( $ this -> _aAllowExtension ) > 0 && ! in_array ( $ sExtension , $ this -> _aAllowExtension ) ) { $ this -> _sError = "The extension is not good" ; return false ; } $ sPath = str_replace ( 'bundles' . DIRECTORY_SEPARATOR . 'lib' , 'data' . DIRECTORY_SEPARATOR . 'upload' . DIRECTORY_SEPARATOR , __DIR__ ) ; if ( $ this -> _sExtension === null ) { $ this -> setExtension ( $ sExtension ) ; } if ( $ this -> _sName ) { $ sName = $ sPath . $ this -> _sName . '.' . $ this -> _sExtension ; } else { $ sName = $ sPath . md5 ( uniqid ( rand ( ) , true ) ) . '.' . $ this -> _sExtension ; } if ( $ this -> _bProportion === true && ( $ this -> _iWidth || $ this -> _iHeight ) ) { $ aImageSizes = getimagesize ( $ _FILES [ $ sFile ] [ 'tmp_name' ] ) ; $ fRatio = min ( $ aImageSizes [ 0 ] / $ this -> _iWidth , $ aImageSizes [ 1 ] / $ this -> _iHeight ) ; $ iHeight = $ aImageSizes [ 1 ] / $ fRatio ; $ iWidth = $ aImageSizes [ 0 ] / $ fRatio ; $ fY = ( $ iHeight - $ this -> _iHeight ) / 2 * $ fRatio ; $ fX = ( $ iWidth - $ this -> _iWidth ) / 2 * $ fRatio ; $ rNewImage = imagecreatefromjpeg ( $ _FILES [ $ sFile ] [ 'tmp_name' ] ) ; $ rNewImgTrueColor = imagecreatetruecolor ( $ this -> _iWidth , $ this -> _iHeight ) ; imagecopyresampled ( $ rNewImgTrueColor , $ rNewImage , 0 , 0 , $ fX , $ fY , $ this -> _iWidth , $ this -> _iHeight , $ iWidth * $ fRatio - $ fX * 2 , $ iHeight * $ fRatio - $ fY * 2 ) ; imagejpeg ( $ rNewImgTrueColor , $ sName , 100 ) ; } else { $ bResultat = move_uploaded_file ( $ _FILES [ $ sFile ] [ 'tmp_name' ] , $ sName ) ; if ( $ bResultat ) { return true ; } } }
2127	protected function fixPaths ( $ content , $ arrFile ) { $ strName = $ arrFile [ 'name' ] ; if ( strpos ( $ strName , $ this -> strWebDir . '/' ) === 0 ) { $ strName = substr ( $ strName , \ strlen ( $ this -> strWebDir ) + 1 ) ; } $ strDirname = \ dirname ( $ strName ) ; $ strGlue = ( $ strDirname != '.' ) ? $ strDirname . '/' : '' ; return preg_replace_callback ( '/url\(("[^"\n]+"|\'[^\'\n]+\'|[^"\'\s()]+)\)/' , function ( $ matches ) use ( $ strDirname , $ strGlue ) { $ strData = $ matches [ 1 ] ; if ( $ strData [ 0 ] == '"' || $ strData [ 0 ] == "'" ) { $ strData = substr ( $ strData , 1 , - 1 ) ; } if ( strncmp ( $ strData , 'data:' , 5 ) === 0 || strncmp ( $ strData , 'http://' , 7 ) === 0 || strncmp ( $ strData , 'https://' , 8 ) === 0 || strncmp ( $ strData , '/' , 1 ) === 0 || strncmp ( $ strData , 'assets/css3pie/' , 15 ) === 0 ) { return $ matches [ 0 ] ; } if ( strncmp ( $ strData , '../' , 3 ) !== 0 ) { $ strData = '../../' . $ strGlue . $ strData ; } else { $ dir = $ strDirname ; while ( strncmp ( $ strData , '../' , 3 ) === 0 ) { $ dir = \ dirname ( $ dir ) ; $ strData = substr ( $ strData , 3 ) ; } $ glue = ( $ dir != '.' ) ? $ dir . '/' : '' ; $ strData = '../../' . $ glue . $ strData ; } $ strQuote = '' ; if ( $ matches [ 1 ] [ 0 ] == "'" || $ matches [ 1 ] [ 0 ] == '"' ) { $ strQuote = $ matches [ 1 ] [ 0 ] ; } if ( preg_match ( '/[(),\s"\']/' , $ strData ) ) { if ( $ matches [ 1 ] [ 0 ] == "'" ) { $ strData = str_replace ( "'" , "\\'" , $ strData ) ; } else { $ strQuote = '"' ; $ strData = str_replace ( '"' , '\"' , $ strData ) ; } } return 'url(' . $ strQuote . $ strData . $ strQuote . ')' ; } , $ content ) ; }
11988	function readLine ( ) { $ i = $ this -> pos ; $ tot_len = strlen ( $ this -> data ) ; while ( $ i < $ tot_len && ! $ this -> isEndOfLine ( $ i ) ) { $ i ++ ; } $ result = substr ( $ this -> data , $ this -> pos , $ i - $ this -> pos ) ; $ i ++ ; if ( $ this -> getLineEndingModeCrlf ( ) ) $ i ++ ; $ this -> pos = $ i ; return $ result ; }
11385	public static function signUrlForGoogle ( string $ sUrlToSign , string $ sClientId , string $ sPrivateKey ) : string { $ aUrl = parse_url ( $ sUrlToSign ) ; $ aUrl [ 'query' ] .= '&client=' . $ sClientId ; $ aUrlToSign = $ aUrl [ 'path' ] . "?" . $ aUrl [ 'query' ] ; $ decodedKey = base64_decode ( str_replace ( array ( '-' , '_' ) , array ( '+' , '/' ) , $ sPrivateKey ) ) ; $ sSignature = hash_hmac ( "sha1" , $ aUrlToSign , $ decodedKey , true ) ; $ sEncodedSignature = str_replace ( array ( '+' , '/' ) , array ( '-' , '_' ) , base64_encode ( $ sSignature ) ) ; $ sOriginalUrl = $ aUrl [ 'scheme' ] . "://" . $ aUrl [ 'host' ] . $ aUrl [ 'path' ] . "?" . $ aUrl [ 'query' ] ; return $ sOriginalUrl . '&signature=' . $ sEncodedSignature ; }
1520	public function removeFromRelationship ( StoreInterface $ store , UpdateRelationship $ request ) { $ result = $ this -> transaction ( function ( ) use ( $ store , $ request ) { return $ this -> doRemoveFromRelationship ( $ store , $ request ) ; } ) ; if ( $ this -> isResponse ( $ result ) ) { return $ result ; } return $ this -> reply ( ) -> noContent ( ) ; }
1681	public function copyUser ( $ row , $ href , $ label , $ title , $ icon , $ attributes , $ table ) { if ( $ GLOBALS [ 'TL_DCA' ] [ $ table ] [ 'config' ] [ 'closed' ] ) { return '' ; } return ( $ this -> User -> isAdmin || ! $ row [ 'admin' ] ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' ; }
9279	public function save ( JobEntity $ job ) { $ query = null ; if ( ( int ) $ job -> getId ( ) == 0 ) { $ query = $ this -> sql -> insert ( ) ; $ query -> values ( $ job -> getArrayCopy ( ) ) ; } else { $ query = $ this -> sql -> update ( ) ; $ query -> set ( $ job -> getArrayCopy ( ) ) ; $ query -> where ( array ( 'id' => $ job -> getId ( ) ) ) ; } $ stmt = $ this -> sql -> prepareStatementForSqlObject ( $ query ) ; $ res = $ stmt -> execute ( ) ; if ( ( int ) $ job -> getId ( ) == 0 ) { $ job -> setId ( ( int ) $ res -> getGeneratedValue ( ) ) ; } return $ job ; }
12887	private function getComposer ( $ fileOrPackage ) { if ( isset ( $ this -> jsonCache [ $ fileOrPackage ] ) ) return $ this -> jsonCache [ $ fileOrPackage ] ; if ( $ file = $ this -> files [ $ fileOrPackage ] ?? NULL ) { return $ this -> getComposer ( $ file ) ; } if ( is_dir ( $ fileOrPackage ) ) $ fileOrPackage .= "/composer.json" ; if ( is_file ( $ fileOrPackage ) ) { $ json = json_decode ( file_get_contents ( $ fileOrPackage ) , true ) ; $ name = $ json [ "name" ] ; $ this -> jsonCache [ $ name ] = $ json ; $ this -> files [ $ name ] = $ fileOrPackage ; return $ json ; } return NULL ; }
9661	public static function createReaderForFile ( $ filename ) { File :: assertFile ( $ filename ) ; $ guessedReader = self :: getReaderTypeFromExtension ( $ filename ) ; if ( $ guessedReader !== null ) { $ reader = self :: createReader ( $ guessedReader ) ; if ( isset ( $ reader ) && $ reader -> canRead ( $ filename ) ) { return $ reader ; } } foreach ( self :: $ readers as $ type => $ class ) { if ( $ type !== $ guessedReader ) { $ reader = self :: createReader ( $ type ) ; if ( $ reader -> canRead ( $ filename ) ) { return $ reader ; } } } throw new Reader \ Exception ( 'Unable to identify a reader for this file' ) ; }
1023	private function executeOperation ( OperationDefinitionNode $ operation , $ rootValue ) { $ type = $ this -> getOperationRootType ( $ this -> exeContext -> schema , $ operation ) ; $ fields = $ this -> collectFields ( $ type , $ operation -> selectionSet , new ArrayObject ( ) , new ArrayObject ( ) ) ; $ path = [ ] ; try { $ result = $ operation -> operation === 'mutation' ? $ this -> executeFieldsSerially ( $ type , $ rootValue , $ path , $ fields ) : $ this -> executeFields ( $ type , $ rootValue , $ path , $ fields ) ; if ( $ this -> isPromise ( $ result ) ) { return $ result -> then ( null , function ( $ error ) { $ this -> exeContext -> addError ( $ error ) ; return $ this -> exeContext -> promises -> createFulfilled ( null ) ; } ) ; } return $ result ; } catch ( Error $ error ) { $ this -> exeContext -> addError ( $ error ) ; return null ; } }
3608	public function getResourceOwnerDetailsUrl ( AccessToken $ token ) { $ uri = new Uri ( $ this -> urlResourceOwnerDetails ) ; return ( string ) Uri :: withQueryValue ( $ uri , 'access_token' , ( string ) $ token ) ; }
4095	protected function call ( $ url , $ method = "GET" , $ payload = null ) { $ conn = $ this -> ch ; $ protocol = "http" ; $ requestURL = $ protocol . "://" . $ this -> host . $ url ; curl_setopt ( $ conn , CURLOPT_URL , $ requestURL ) ; curl_setopt ( $ conn , CURLOPT_TIMEOUT , $ this -> timeout ) ; curl_setopt ( $ conn , CURLOPT_PORT , $ this -> port ) ; curl_setopt ( $ conn , CURLOPT_CUSTOMREQUEST , strtoupper ( $ method ) ) ; curl_setopt ( $ conn , CURLOPT_FORBID_REUSE , 0 ) ; $ headers = array ( ) ; $ headers [ ] = 'Accept: application/json' ; $ headers [ ] = 'Content-Type: application/json' ; curl_setopt ( $ conn , CURLOPT_HTTPHEADER , $ headers ) ; if ( is_array ( $ payload ) && count ( $ payload ) > 0 ) curl_setopt ( $ conn , CURLOPT_POSTFIELDS , json_encode ( $ payload ) ) ; else curl_setopt ( $ conn , CURLOPT_POSTFIELDS , $ payload ) ; ob_start ( ) ; curl_exec ( $ conn ) ; $ response = ob_get_clean ( ) ; if ( $ response !== false ) { $ data = json_decode ( $ response , true ) ; if ( ! $ data ) { $ data = array ( 'error' => $ response , "code" => curl_getinfo ( $ conn , CURLINFO_HTTP_CODE ) ) ; } } else { $ errno = curl_errno ( $ conn ) ; switch ( $ errno ) { case CURLE_UNSUPPORTED_PROTOCOL : $ error = "Unsupported protocol [$protocol]" ; break ; case CURLE_FAILED_INIT : $ error = "Internal cUrl error?" ; break ; case CURLE_URL_MALFORMAT : $ error = "Malformed URL [$requestURL] -d " . json_encode ( $ payload ) ; break ; case CURLE_COULDNT_RESOLVE_PROXY : $ error = "Couldnt resolve proxy" ; break ; case CURLE_COULDNT_RESOLVE_HOST : $ error = "Couldnt resolve host" ; break ; case CURLE_COULDNT_CONNECT : $ error = "Couldnt connect to host [{$this->host}], ElasticSearch down?" ; break ; case CURLE_OPERATION_TIMEDOUT : $ error = "Operation timed out on [$requestURL]" ; break ; default : $ error = "Unknown error" ; if ( $ errno == 0 ) { $ error .= ". Non-cUrl error" ; } else { $ errstr = curl_error ( $ conn ) ; $ error .= " ($errstr)" ; } break ; } $ exception = new HTTPException ( $ error ) ; $ exception -> payload = $ payload ; $ exception -> port = $ this -> port ; $ exception -> protocol = $ protocol ; $ exception -> host = $ this -> host ; $ exception -> method = $ method ; throw $ exception ; } return $ data ; }
10818	public static function error ( $ messages , $ linebreak = true , $ length = 0 ) { $ separator = $ linebreak ? "\n" : '' ; self :: write ( $ messages , 'error' , $ length , $ separator ) ; }
172	private static function matchPathname ( $ path , $ basePath , $ pattern , $ firstWildcard , $ flags ) { if ( isset ( $ pattern [ 0 ] ) && $ pattern [ 0 ] === '/' ) { $ pattern = StringHelper :: byteSubstr ( $ pattern , 1 , StringHelper :: byteLength ( $ pattern ) ) ; if ( $ firstWildcard !== false && $ firstWildcard !== 0 ) { $ firstWildcard -- ; } } $ namelen = StringHelper :: byteLength ( $ path ) - ( empty ( $ basePath ) ? 0 : StringHelper :: byteLength ( $ basePath ) + 1 ) ; $ name = StringHelper :: byteSubstr ( $ path , - $ namelen , $ namelen ) ; if ( $ firstWildcard !== 0 ) { if ( $ firstWildcard === false ) { $ firstWildcard = StringHelper :: byteLength ( $ pattern ) ; } if ( $ firstWildcard > $ namelen ) { return false ; } if ( strncmp ( $ pattern , $ name , $ firstWildcard ) ) { return false ; } $ pattern = StringHelper :: byteSubstr ( $ pattern , $ firstWildcard , StringHelper :: byteLength ( $ pattern ) ) ; $ name = StringHelper :: byteSubstr ( $ name , $ firstWildcard , $ namelen ) ; if ( empty ( $ pattern ) && empty ( $ name ) ) { return true ; } } $ matchOptions = [ 'filePath' => true ] ; if ( $ flags & self :: PATTERN_CASE_INSENSITIVE ) { $ matchOptions [ 'caseSensitive' ] = false ; } return StringHelper :: matchWildcard ( $ pattern , $ name , $ matchOptions ) ; }
7615	private function encodeBearer ( $ consumer_key , $ consumer_secret ) { $ consumer_key = rawurlencode ( $ consumer_key ) ; $ consumer_secret = rawurlencode ( $ consumer_secret ) ; return base64_encode ( $ consumer_key . ':' . $ consumer_secret ) ; }
966	public function dispatchAfterAuthenticate ( ) { $ jobsConfig = Config :: get ( 'shopify-app.after_authenticate_job' ) ; $ fireJob = function ( $ config ) { $ job = $ config [ 'job' ] ; if ( isset ( $ config [ 'inline' ] ) && $ config [ 'inline' ] === true ) { $ job :: dispatchNow ( $ this -> shop ) ; } else { $ job :: dispatch ( $ this -> shop ) -> onQueue ( Config :: get ( 'shopify-app.job_queues.after_authenticate' ) ) ; } return true ; } ; if ( isset ( $ jobsConfig [ 0 ] ) ) { foreach ( $ jobsConfig as $ jobConfig ) { $ fireJob ( $ jobConfig ) ; } return true ; } if ( isset ( $ jobsConfig [ 'job' ] ) ) { return $ fireJob ( $ jobsConfig ) ; } return false ; }
5690	public static function normalise ( $ html ) { $ rules = array ( '#<!--.*? , '#<(script|option|textarea)[^>]*>.*?</\1>#si' , '#<img[^>]*alt\s*=\s*("([^"]*)"|\'([^\']*)\'|([a-zA-Z_]+))[^>]*>#' , '#<[^>]*>#' , ) ; $ replace = array ( '' , '' , ' \2\3\4 ' , '' , ) ; $ text = preg_replace ( $ rules , $ replace , $ html ) ; $ text = html_entity_decode ( $ text , ENT_QUOTES ) ; $ text = preg_replace ( '#\s+#' , ' ' , $ text ) ; return trim ( trim ( $ text ) , "\xA0" ) ; }
2681	public function configureImageOptimizationDefaultConfigOptions ( $ params , $ version ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/io_settings' ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: PATCH , $ params ) ; return $ result ; }
8408	public static function set ( $ name , $ value , $ expire = 0 , $ path = null ) { if ( $ path === null ) { setcookie ( $ name , $ value , $ expire ) ; } else { setcookie ( $ name , $ value , $ expire , $ path ) ; } }
4455	public function attach ( string $ eventName , $ handler , int $ priority = 100 ) : void { if ( is_object ( $ handler ) == false && is_callable ( $ handler ) == false ) { throw new InvalidArgumentException ( sprintf ( 'Event handler must be either an object or a callable %s given.' , gettype ( $ handler ) ) ) ; } $ priorityQueue = $ this -> fetchQueue ( $ eventName ) ; $ priorityQueue -> insert ( $ handler , $ priority ) ; }
11932	protected function generateOption ( $ key , $ value ) { $ option = new FieldOption ( ) ; $ option -> setKey ( $ key ) ; $ option -> setValue ( $ value ) ; return $ option ; }
10434	protected function prepareTypeServiceConfigs ( $ serviceConfig , $ typeConfig , $ type ) { return array_merge ( $ serviceConfig , $ typeConfig [ 'config' ] , [ 'entity_class' => $ typeConfig [ 'entity_class' ] , 'document_class' => $ typeConfig [ 'document_class' ] , 'document_type' => $ type , ] ) ; }
8106	protected function getEmailBody ( $ config , $ variables ) { $ template = SSViewer :: fromString ( $ config -> ReviewBody ) ; $ value = $ template -> process ( ArrayData :: create ( $ variables ) ) ; return DBField :: create_field ( 'HTMLText' , ( string ) $ value ) ; }
7176	public static function extract ( $ array , array $ paths , $ default = null ) { $ found = array ( ) ; foreach ( $ paths as $ path ) { static :: set_path ( $ found , $ path , static :: path ( $ array , $ path , $ default ) ) ; } return $ found ; }
7741	public function addOperation ( OperationDefinition $ operation ) { if ( false === $ this -> supportsOperation ( $ operation -> getName ( ) ) ) { $ this -> operations [ ] = $ operation ; } return $ this ; }
807	public function generate ( $ input ) { $ tokens = [ ] ; $ parts = explode ( '\\' , $ input ) ; foreach ( $ parts as $ index => $ part ) { $ tokens [ ] = new Token ( [ T_STRING , $ part ] ) ; if ( $ index !== \ count ( $ parts ) - 1 ) { $ tokens [ ] = new Token ( [ T_NS_SEPARATOR , '\\' ] ) ; } } return $ tokens ; }
7989	public function getTemplateProperties ( $ domain , $ templateId ) { $ domain = ( string ) $ domain ; if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; $ templateId = ( string ) $ templateId ; if ( ! $ templateId ) throw new BadMethodCallException ( "Parameter $templateId is missing" ) ; try { $ r = $ this -> get ( 'vps/' . $ domain . '/templates/' . $ templateId ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new VpsException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( ) ; }
5112	protected function setPart ( $ part , $ sql , $ bind = false ) { $ this -> parts [ $ part ] = $ sql ; if ( is_array ( $ bind ) ) $ this -> bind [ $ part ] = $ bind ; else if ( $ bind === false ) $ this -> bind [ $ part ] = false ; else $ this -> bind [ $ part ] = [ $ bind ] ; return $ this ; }
10763	public function setPaymentType ( $ paymentType ) { if ( self :: PAYMENT_PEER_TO_PEER !== $ paymentType ) { throw new RuntimeException ( Tools :: poorManTranslate ( 'fts-shared' , 'Invalid payment type.' ) ) ; } return $ this -> add ( 'PT' , $ paymentType ) ; }
12957	public function authenticate ( ) { $ identity = $ this -> getIdentity ( ) ; $ results = $ this -> model -> findByIdentity ( $ identity ) ; $ identityObject = null ; $ count = 0 ; foreach ( $ results as $ identityObject ) { if ( $ count > 1 ) { return new Result ( Result :: FAILURE_IDENTITY_AMBIGUOUS , $ identity , [ 'More than one record matches the supplied identity.' ] ) ; } $ count ++ ; } if ( $ count == 0 ) { return new Result ( Result :: FAILURE_IDENTITY_NOT_FOUND , $ identity , [ 'A record with the supplied identity could not be found.' ] ) ; } if ( $ identityObject instanceof ObjectInterface ) { if ( $ identityObject -> validateCredential ( $ this -> getCredential ( ) ) ) { return new Result ( Result :: SUCCESS , $ identity ) ; } return new Result ( Result :: FAILURE_CREDENTIAL_INVALID , $ identity , [ 'wrong password' ] ) ; } return new Result ( Result :: FAILURE_UNCATEGORIZED , $ identity , [ 'generic error' ] ) ; }
5740	protected static function logDuration ( Request $ request , Response $ response , $ startTime ) { $ duration = microtime ( true ) - $ startTime ; $ tags = [ "status_code" => $ response -> getStatusCode ( ) ] ; if ( ! config ( 'datadog-helper.middleware_disable_url_tag' , false ) ) { $ tags [ "url" ] = $ request -> getSchemeAndHttpHost ( ) . $ request -> getRequestUri ( ) ; } Datadog :: timing ( 'request_time' , $ duration , 1 , $ tags ) ; }
7988	public function deleteSnapshot ( $ domain ) { $ domain = ( string ) $ domain ; if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; try { $ r = $ this -> delete ( 'vps/' . $ domain . '/snapshot' ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new VpsException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r ; }
6650	public function unlinkFiles ( $ fileName ) { $ folder = $ this -> getWebrootFolder ( ) ; if ( $ fileName ) { if ( @ file_exists ( $ folder . '/' . $ fileName ) ) { unlink ( $ folder . '/' . $ fileName ) ; } } }
10925	private function renderRow ( array $ row ) { $ output = [ ] ; $ output [ ] = $ this -> charVertical ; $ columnNumber = 0 ; foreach ( $ row as $ column => $ value ) { $ output [ ] = $ this -> renderCell ( $ columnNumber , $ value , ' ' ) ; $ output [ ] = $ this -> charVertical ; $ columnNumber ++ ; } return implode ( '' , $ output ) ; }
824	public function getName ( ) { if ( null === $ this -> name ) { Preg :: matchAll ( '/@[a-zA-Z0-9_-]+(?=\s|$)/' , $ this -> line -> getContent ( ) , $ matches ) ; if ( isset ( $ matches [ 0 ] [ 0 ] ) ) { $ this -> name = ltrim ( $ matches [ 0 ] [ 0 ] , '@' ) ; } else { $ this -> name = 'other' ; } } return $ this -> name ; }
4556	public function setOrganizationUuid ( ? string $ organizationUuid ) { $ this -> organizationUuid = $ organizationUuid ; $ this -> _organizationUuid = true ; return $ this ; }
9368	protected function globals ( Configuration $ config ) { $ cookies = $ config -> get ( 'app.http.cookies' , array ( ) ) ; $ files = $ config -> get ( 'app.http.files' , array ( ) ) ; $ get = $ config -> get ( 'app.http.get' , array ( ) ) ; $ post = $ config -> get ( 'app.http.post' , array ( ) ) ; $ server = $ config -> get ( 'app.http.server' , $ this -> server ( ) ) ; return array ( $ server , $ cookies , $ get , $ files , $ post ) ; }
11252	public function repositoryExists ( ) : bool { switch ( $ this -> pdo -> getAttribute ( PDO :: ATTR_DRIVER_NAME ) ) { case 'pgsql' : $ sql = 'select count(*) from information_schema.tables where table_schema = current_schema() and table_name = ?' ; break ; case 'mysql' : $ sql = 'select count(*) from information_schema.tables where table_schema = database() and table_name = ?' ; break ; case 'sqlsrv' : $ sql = "select count(*) from sysobjects where type = 'U' and name = ?" ; break ; case 'sqlite' : $ sql = "select count(*) from sqlite_master where type = 'table' and name = ?" ; break ; default : throw InvalidArgumentException :: forDatabaseNotSupported ( ) ; } $ stmt = $ this -> pdo -> prepare ( $ sql ) ; $ stmt -> bindParam ( 1 , $ this -> table ) ; $ stmt -> execute ( ) ; return $ stmt -> fetch ( PDO :: FETCH_COLUMN ) > 0 ; }
6359	public function limit ( int $ limit ) : BufferedIterable { Preconditions :: checkArgument ( 0 < $ limit , 'Limit must be a positive integer!' ) ; return new BufferedIterable ( $ this -> chunkProvider , $ this -> filter , $ limit , $ this -> providerCallLimit ) ; }
2229	public function dragFile ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { return '<button type="button" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '" ' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</button> ' ; }
8655	private function convertGetReportCount ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetReportCount' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetReportTypeList ( ) ) { $ reportTypeList = $ request -> getReportTypeList ( ) ; foreach ( $ reportTypeList -> getType ( ) as $ typeIndex => $ type ) { $ parameters [ 'ReportTypeList' . '.' . 'Type' . '.' . ( $ typeIndex + 1 ) ] = $ type ; } } if ( $ request -> isSetAcknowledged ( ) ) { $ parameters [ 'Acknowledged' ] = $ request -> getAcknowledged ( ) ? "true" : "false" ; } if ( $ request -> isSetAvailableFromDate ( ) ) { $ parameters [ 'AvailableFromDate' ] = $ this -> getFormattedTimestamp ( $ request -> getAvailableFromDate ( ) ) ; } if ( $ request -> isSetAvailableToDate ( ) ) { $ parameters [ 'AvailableToDate' ] = $ this -> getFormattedTimestamp ( $ request -> getAvailableToDate ( ) ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
2099	public static function getNumericDateFormat ( ) { if ( TL_MODE == 'FE' ) { global $ objPage ; if ( $ objPage -> dateFormat != '' && static :: isNumericFormat ( $ objPage -> dateFormat ) ) { return $ objPage -> dateFormat ; } } return Config :: get ( 'dateFormat' ) ; }
4668	public function generate ( ) { $ this -> beforeGeneration ( ) ; $ this -> config -> getLogger ( ) -> startBreak ( 'Class Generation' ) ; foreach ( $ this -> XSDMap as $ fhirElementName => $ mapEntry ) { $ this -> config -> getLogger ( ) -> debug ( "Generating class for element {$fhirElementName}..." ) ; $ classTemplate = ClassGenerator :: buildFHIRElementClassTemplate ( $ this -> config , $ this -> XSDMap , $ mapEntry ) ; FileUtils :: createDirsFromNS ( $ classTemplate -> getNamespace ( ) , $ this -> config ) ; MethodGenerator :: implementConstructor ( $ this -> config , $ classTemplate ) ; $ classTemplate -> writeToFile ( $ this -> config -> getOutputPath ( ) ) ; $ this -> mapTemplate -> addEntry ( $ classTemplate ) ; $ this -> autoloadMap -> addPHPFHIRClassEntry ( $ classTemplate ) ; $ this -> config -> getLogger ( ) -> debug ( "{$fhirElementName} completed." ) ; } $ this -> config -> getLogger ( ) -> endBreak ( 'Class Generation' ) ; $ this -> afterGeneration ( ) ; }
5642	public function paintCaseEnd ( $ test_name ) { $ this -> progress ++ ; array_pop ( $ this -> test_stack ) ; if ( count ( $ this -> test_stack ) == 0 ) { $ this -> paintFooter ( $ test_name ) ; } }
7459	private function color ( string $ color ) : Font { $ this -> color = $ color ; if ( $ this -> background ) { $ this -> turnToBackground ( ) ; } return $ this ; }
12686	public function inferType ( $ value ) { if ( is_string ( $ value ) ) { return new StringType ( ) ; } elseif ( is_array ( $ value ) ) { return new ArrayType ( ) ; } elseif ( is_object ( $ value ) ) { return $ this -> inferObjectType ( $ value ) ; } elseif ( is_integer ( $ value ) ) { return new IntegerType ( ) ; } elseif ( is_bool ( $ value ) ) { return new BooleanType ( ) ; } elseif ( is_null ( $ value ) ) { return new MixedType ( ) ; } $ e = new InferException ( 'Typ konnte nicht geraten werden: ' . Util :: varInfo ( $ value ) ) ; $ e -> value = $ value ; throw $ e ; }
6631	public function authURL ( $ state ) { $ url = $ this -> settings [ 'authentication_url' ] ; $ params = [ 'client_id' => $ this -> settings ( 'api_key' ) , 'redirect_uri' => $ this -> settings ( 'redirect_uri' ) , 'scope' => $ this -> settings ( 'permissions' ) , 'state' => $ state , ] ; return $ url . '?' . http_build_query ( $ params ) ; }
9866	private function writeProtectedRanges ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { if ( count ( $ pSheet -> getProtectedCells ( ) ) > 0 ) { $ objWriter -> startElement ( 'protectedRanges' ) ; foreach ( $ pSheet -> getProtectedCells ( ) as $ protectedCell => $ passwordHash ) { $ objWriter -> startElement ( 'protectedRange' ) ; $ objWriter -> writeAttribute ( 'name' , 'p' . md5 ( $ protectedCell ) ) ; $ objWriter -> writeAttribute ( 'sqref' , $ protectedCell ) ; if ( ! empty ( $ passwordHash ) ) { $ objWriter -> writeAttribute ( 'password' , $ passwordHash ) ; } $ objWriter -> endElement ( ) ; } $ objWriter -> endElement ( ) ; } }
10530	public function toJson ( $ prettyPrint = false ) { $ options = 0 ; if ( $ prettyPrint ) { $ options += JSON_PRETTY_PRINT ; } return json_encode ( $ this -> items , $ options ) ; }
954	protected function returnTo ( ) { $ return_to = Session :: get ( 'return_to' ) ; if ( $ return_to ) { Session :: forget ( 'return_to' ) ; return Redirect :: to ( $ return_to ) ; } return Redirect :: route ( 'home' ) ; }
6205	public function onException ( \ Exception $ exception ) { if ( $ this -> shouldNotifyException ( $ exception ) ) { $ this -> airbrakeClient -> notifyOnException ( $ exception ) ; } return true ; }
12035	private function createMethodGenerator ( $ methodName , $ body , DocBlockGenerator $ docBlock , $ parameterInfoArray , $ returnType = null ) { $ parameters = [ ] ; foreach ( $ parameterInfoArray as $ parameterInfo ) { $ parameters [ ] = new ParameterGenerator ( $ parameterInfo [ 0 ] , $ parameterInfo [ 1 ] ) ; } $ methodGenerator = new MethodGenerator ( $ methodName ) ; $ methodGenerator -> setParameters ( $ parameters ) ; if ( $ returnType != null ) { if ( is_array ( $ returnType ) ) { $ returnType = implode ( '|' , $ returnType ) ; } $ tags [ ] = new GenericTag ( 'return' , $ returnType ) ; $ docBlock -> setTags ( $ tags ) ; } $ methodGenerator -> setDocBlock ( $ docBlock ) ; $ methodGenerator -> setBody ( $ body ) ; return $ methodGenerator ; }
11978	public function transform ( $ message ) { if ( is_array ( $ message ) ) { $ class = News :: class ; } else { if ( is_string ( $ message ) ) { $ message = new Text ( [ 'content' => $ message ] ) ; } $ class = get_class ( $ message ) ; } $ handle = 'transform' . substr ( $ class , strlen ( 'EasyWeChat\Message\\' ) ) ; return method_exists ( $ this , $ handle ) ? $ this -> $ handle ( $ message ) : [ ] ; }
8584	public function setASIN ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ASIN' ] [ 'FieldValue' ] = $ value ; return $ this ; }
4087	protected function transformDSLTermToString ( $ dslTerm ) { $ string = "" ; if ( is_array ( $ dslTerm ) ) { $ key = key ( $ dslTerm ) ; $ value = $ dslTerm [ $ key ] ; if ( is_string ( $ key ) ) $ string .= "$key:" ; } else $ value = $ dslTerm ; if ( strpos ( $ value , " " ) !== false ) $ string .= '"' . $ value . '"' ; else $ string .= $ value ; return $ string ; }
12056	public function getLabels ( ) { $ labels = [ ] ; $ labels [ 'delete_object' ] = [ 'short' => 'Delete ' . $ this -> object -> objectType -> title -> getSingular ( true ) , 'long' => 'delete the ' . $ this -> object -> objectType -> title -> getSingular ( false ) . ' <em>' . $ this -> object -> descriptor . '</em>' , 'past' => $ this -> object -> objectType -> title -> getSingular ( false ) . ' <em>' . $ this -> object -> descriptor . '</em> has been deleted' , 'options' => [ 'class' => 'btn-danger' ] , 'response' => 'home' , ] ; $ labels [ 'archive_object' ] = [ 'short' => 'Archive ' . $ this -> object -> objectType -> title -> getSingular ( true ) , 'long' => 'archive the ' . $ this -> object -> objectType -> title -> getSingular ( false ) . ' <em>' . $ this -> object -> descriptor . '</em>' , 'past' => $ this -> object -> objectType -> title -> getSingular ( false ) . ' <em>' . $ this -> object -> descriptor . '</em> has been archived' , 'response' => 'refresh' , ] ; $ labels [ 'unarchive_object' ] = [ 'short' => 'Unarchive ' . $ this -> object -> objectType -> title -> getSingular ( true ) , 'long' => 'unarchive the ' . $ this -> object -> objectType -> title -> getSingular ( false ) . ' <em>' . $ this -> object -> descriptor . '</em>' , 'past' => $ this -> object -> objectType -> title -> getSingular ( false ) . ' <em>' . $ this -> object -> descriptor . '</em> has been unarchived' , 'response' => 'refresh' , ] ; if ( isset ( $ this -> relationshipWith ) ) { $ labels [ 'delete_relationship' ] = [ 'short' => 'Delete Relationship' , 'long' => 'delete the relationship between <em>' . $ this -> object -> descriptor . '</em> and <em>' . $ this -> relationshipWith -> descriptor . '</em>' , 'past' => 'the relationship between <em>' . $ this -> object -> descriptor . '</em> and <em>' . $ this -> relationshipWith -> descriptor . '</em> has been deleted' , 'options' => [ 'class' => 'btn-warning' ] , ] ; $ labels [ 'end_relationship' ] = [ 'short' => 'End Relationship' , 'long' => 'end the relationship between <em>' . $ this -> object -> descriptor . '</em> and <em>' . $ this -> relationshipWith -> descriptor . '</em>' , 'past' => 'the relationship between <em>' . $ this -> object -> descriptor . '</em> and <em>' . $ this -> relationshipWith -> descriptor . '</em> has been ended' , ] ; } return $ labels ; }
3059	public function selectAdaptiveNextItem ( ) { $ lastItemId = $ this -> getCurrentCatItemId ( ) ; $ lastOutput = $ this -> getLastCatItemOutput ( ) ; $ catSession = $ this -> getCatSession ( ) ; $ preSelection = $ catSession -> getTestMap ( ) ; try { if ( ! $ this -> syncingMode ) { $ selection = $ catSession -> getTestMap ( array_values ( $ lastOutput ) ) ; if ( ! $ this -> saveAdaptiveResults ( $ catSession ) ) { \ common_Logger :: w ( 'Unable to save CatService results.' ) ; } $ isShadowItem = false ; } else { $ selection = $ catSession -> getTestMap ( ) ; $ isShadowItem = true ; } } catch ( CatEngineException $ e ) { \ common_Logger :: e ( 'Error during CatEngine processing. ' . $ e -> getMessage ( ) ) ; $ selection = $ catSession -> getTestMap ( ) ; $ isShadowItem = true ; } $ event = new SelectAdaptiveNextItemEvent ( $ this -> getTestSession ( ) , $ lastItemId , $ preSelection , $ selection , $ isShadowItem ) ; $ this -> getServiceManager ( ) -> get ( EventManager :: SERVICE_ID ) -> trigger ( $ event ) ; $ this -> persistCatSession ( $ catSession ) ; if ( is_array ( $ selection ) && count ( $ selection ) > 0 ) { \ common_Logger :: d ( "New CAT item selection is '" . implode ( ', ' , $ selection ) . "'." ) ; return $ selection [ 0 ] ; } else { \ common_Logger :: d ( 'No new CAT item selection.' ) ; return null ; } }
7410	public function offsetSet ( $ k , $ v ) { if ( null === $ k || ! array_key_exists ( $ k , $ this -> _container ) ) { $ v = ( is_object ( $ v ) && get_class ( $ v ) === $ this -> _type ) ? $ v : new $ this -> _type ( $ v ) ; if ( null === $ k ) { $ this -> _container [ ] = $ v ; } else { $ this -> _container [ $ k ] = $ v ; } return ; } if ( is_a ( $ this -> _type , AtomicInterface :: class , true ) ) { $ this -> _container [ $ k ] -> set ( $ v ) ; return ; } if ( is_a ( $ this -> _type , TypedAbstract :: class , true ) ) { $ this -> _container [ $ k ] -> replace ( $ v ) ; return ; } $ this -> _container [ $ k ] = new $ this -> _type ( $ v ) ; }
8932	public function loadDependencies ( ) { $ config = ConfigService :: fetch ( dirname ( __DIR__ ) ) ; $ config = array_merge ( $ config , ConfigService :: fetch ( ) ) ; $ moduleService = new ModuleService ; if ( ! array_key_exists ( 'slim-api' , $ config ) ) { $ config [ 'slim-api' ] = [ 'modules' => [ 'SlimApi\Phinx' , 'SlimApi\Mvc' ] ] ; } else { require 'vendor/autoload.php' ; } foreach ( $ config [ 'slim-api' ] [ 'modules' ] as $ moduleNamespace ) { $ config = array_merge ( $ config , $ moduleService -> load ( $ moduleNamespace ) ) ; } return $ config ; }
4133	public function initializeObject ( $ obj ) { if ( $ obj instanceof PersistentCollection ) { $ obj -> initialize ( ) ; } else if ( $ obj instanceof Proxy \ Proxy ) { $ obj -> __doctrineLoad__ ( ) ; } }
6716	protected function getRequestChainFromUri ( $ requestedUri ) { $ requestedUri = preg_replace ( '/[\?\.].*$/' , '' , $ requestedUri ) ; $ requestChain = explode ( '/' , $ requestedUri ) ; if ( ! $ requestChain [ 0 ] ) { unset ( $ requestChain [ 0 ] ) ; } return array_values ( $ requestChain ) ; }
9381	public function set ( $ id , $ concrete , $ share = false ) { return $ this -> add ( $ id , $ concrete , $ share ) ; }
2753	protected function getRequestForPath ( $ path , array $ exclude ) { if ( ! empty ( $ exclude [ $ path ] ) ) { return NULL ; } $ request = Request :: create ( $ path ) ; $ request -> headers -> set ( 'Accept' , 'text/html' ) ; $ processed = $ this -> pathProcessor -> processInbound ( $ path , $ request ) ; if ( empty ( $ processed ) || ! empty ( $ exclude [ $ processed ] ) ) { return NULL ; } $ this -> currentPath -> setPath ( $ processed , $ request ) ; try { $ request -> attributes -> add ( $ this -> router -> matchRequest ( $ request ) ) ; return $ request ; } catch ( ParamNotConvertedException $ e ) { return NULL ; } catch ( ResourceNotFoundException $ e ) { return NULL ; } catch ( MethodNotAllowedException $ e ) { return NULL ; } catch ( AccessDeniedHttpException $ e ) { return NULL ; } }
12576	public function previewTextByName ( $ message , $ to ) { return $ this -> preview ( self :: MSG_TYPE_TEXT , $ message , $ to , self :: PREVIEW_BY_NAME ) ; }
7428	public function renderObject ( ) { if ( ! $ this -> isValid ( $ this -> source ) ) { throw new InvalidSourceExtensionException ( ) ; } return sprintf ( $ this -> objectDecorator , $ this -> width , $ this -> height , $ this -> source ) ; }
9316	public static function filter ( $ region ) { $ r = array ( 'x' => intval ( $ region [ 'x' ] ) , 'y' => intval ( $ region [ 'y' ] ) , 'width' => intval ( $ region [ 'w' ] ) , 'height' => intval ( $ region [ 'h' ] ) ) ; return array ( new ezcImageFilter ( 'crop' , $ r ) ) ; }
2165	public static function convertMultiField ( $ table , $ field ) { $ objDatabase = Database :: getInstance ( ) ; $ objRow = $ objDatabase -> query ( "SELECT id, $field FROM $table WHERE $field!=''" ) ; $ objDesc = $ objDatabase -> query ( "DESC $table $field" ) ; if ( $ objDesc -> Type != 'blob' ) { $ objDatabase -> query ( "ALTER TABLE `$table` CHANGE `$field` `$field` blob NULL" ) ; $ objDatabase -> query ( "UPDATE `$table` SET `$field`=NULL WHERE `$field`=''" ) ; } while ( $ objRow -> next ( ) ) { $ arrValues = StringUtil :: deserialize ( $ objRow -> $ field , true ) ; if ( empty ( $ arrValues ) ) { continue ; } $ objHelper = static :: generateHelperObject ( $ arrValues ) ; if ( $ objHelper -> isUuid ) { continue ; } foreach ( $ arrValues as $ k => $ v ) { if ( $ objHelper -> isNumeric ) { $ objFile = FilesModel :: findByPk ( $ objHelper -> value [ $ k ] ) ; $ arrValues [ $ k ] = $ objFile -> uuid ; } else { $ objFile = FilesModel :: findByPath ( $ objHelper -> value [ $ k ] ) ; $ arrValues [ $ k ] = $ objFile -> uuid ; } } $ objDatabase -> prepare ( "UPDATE $table SET $field=? WHERE id=?" ) -> execute ( serialize ( $ arrValues ) , $ objRow -> id ) ; } }
6533	protected function getConnectionFactory ( $ type ) { if ( false === isset ( $ this -> connectionFactories [ $ type ] ) ) { throw new \ InvalidArgumentException ( "Missing connection factory \"$type\"" ) ; } return $ this -> connectionFactories [ $ type ] ; }
343	protected function renderSortLinks ( ) { $ attributes = empty ( $ this -> attributes ) ? array_keys ( $ this -> sort -> attributes ) : $ this -> attributes ; $ links = [ ] ; foreach ( $ attributes as $ name ) { $ links [ ] = $ this -> sort -> link ( $ name , $ this -> linkOptions ) ; } return Html :: ul ( $ links , array_merge ( $ this -> options , [ 'encode' => false ] ) ) ; }
2905	public function addEmailToProfile ( $ email , $ name , $ variables , $ result , Zend_Mail $ mail ) { $ emailCapture = Mage :: getModel ( 'sheep_debug/email' ) ; $ subject = $ this -> decodeSubject ( $ mail -> getSubject ( ) ) ; $ body = $ this -> getContent ( $ mail ) ; $ emailCapture -> setFromName ( $ this -> getSenderName ( ) ) ; $ emailCapture -> setFromEmail ( $ this -> getSenderEmail ( ) ) ; $ emailCapture -> setToEmail ( $ email ) ; $ emailCapture -> setToName ( $ name ) ; $ emailCapture -> setSubject ( $ subject ) ; $ emailCapture -> setIsPlain ( $ this -> isPlain ( ) ) ; $ emailCapture -> setBody ( $ body ) ; $ emailCapture -> setIsAccepted ( $ result ) ; $ emailCapture -> setVariables ( $ variables ) ; $ emailCapture -> setIsSmtpDisabled ( ( bool ) Mage :: getStoreConfigFlag ( 'system/smtp/disable' ) ) ; Mage :: getSingleton ( 'sheep_debug/observer' ) -> getRequestInfo ( ) -> addEmail ( $ emailCapture ) ; }
3915	protected function sortByDate ( $ blnAscending = true ) { $ arrFiles = $ this -> foundFiles ; $ arrDates = $ this -> modifiedTime ; if ( ! $ arrFiles ) { return array ( 'files' => array ( ) , 'source' => array ( ) ) ; } if ( $ blnAscending ) { array_multisort ( $ arrFiles , SORT_NUMERIC , $ arrDates , SORT_ASC ) ; } else { array_multisort ( $ arrFiles , SORT_NUMERIC , $ arrDates , SORT_DESC ) ; } return $ this -> remapSorting ( $ arrFiles , $ this -> outputBuffer ) ; }
1943	public function onReplaceInsertTags ( string $ tag ) { $ chunks = explode ( '::' , $ tag ) ; if ( 'asset' !== $ chunks [ 0 ] ) { return false ; } $ url = $ this -> packages -> getUrl ( $ chunks [ 1 ] , $ chunks [ 2 ] ?? null ) ; return ltrim ( $ url , '/' ) ; }
3858	public function setFilterSettings ( $ intFilter ) { $ this -> intFilter = $ intFilter ; $ this -> objFilterSettings = $ this -> getFilterFactory ( ) -> createCollection ( $ this -> intFilter ) ; if ( ! $ this -> objFilterSettings ) { throw new \ RuntimeException ( 'Error: no filter object defined.' ) ; } return $ this ; }
3361	private function exists ( $ offset = null ) { return isset ( $ this -> container [ $ offset !== null ? $ offset : $ this -> position ] ) ; }
8051	public function getAllEvents ( ) : array { $ calendarEvents = null ; $ cache = $ this -> cache ; if ( $ cache :: has ( self :: ALL_EVENTS_KEY ) ) { return $ cache :: get ( self :: ALL_EVENTS_KEY ) ; } $ allEvents = $ this -> calendarEvent -> with ( [ 'calendarEventRepeatDates' ] ) -> get ( ) ; $ calendarEvents = $ allEvents -> keyBy ( 'id' ) -> toArray ( ) ; $ cache :: put ( self :: ALL_EVENTS_KEY , $ calendarEvents , $ this -> cacheTimeToLive ) ; return $ calendarEvents ; }
7164	private function buildSaleDiscountsLinesViews ( Model \ SaleInterface $ sale ) { if ( ! $ sale -> hasAdjustments ( Model \ AdjustmentTypes :: TYPE_DISCOUNT ) ) { return ; } foreach ( $ sale -> getAdjustments ( Model \ AdjustmentTypes :: TYPE_DISCOUNT ) as $ adjustment ) { $ this -> view -> addDiscount ( $ this -> buildDiscountLine ( $ adjustment ) ) ; } }
1097	public static function to ( $ node , $ target , $ position ) { $ instance = new static ( $ node , $ target , $ position ) ; return $ instance -> perform ( ) ; }
2439	public function cloneForCurrent ( string $ current ) : self { return new self ( $ this -> context , $ this -> extras , $ this -> value , $ current ) ; }
2670	public function createDictionaryItems ( $ dictionaryId , $ params ) { $ url = $ this -> _getApiServiceUri ( ) . 'dictionary/' . $ dictionaryId . '/items' ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: PATCH , $ params ) ; return $ result ; }
4479	public function tag ( ... $ tags ) : void { $ response = call_user_func_array ( [ $ this -> client , 'call' ] , array_merge ( [ 'tag' , 'add' , $ this -> jid ] , array_values ( func_get_args ( ) ) ) ) ; $ this -> setTags ( json_decode ( $ response , true ) ) ; }
910	private function findHeaderCommentInsertionIndex ( Tokens $ tokens ) { if ( 'after_open' === $ this -> configuration [ 'location' ] ) { return 1 ; } $ index = $ tokens -> getNextMeaningfulToken ( 0 ) ; if ( null === $ index ) { return 1 ; } if ( ! $ tokens [ $ index ] -> isGivenKind ( T_DECLARE ) ) { return 1 ; } $ next = $ tokens -> getNextMeaningfulToken ( $ index ) ; if ( null === $ next || ! $ tokens [ $ next ] -> equals ( '(' ) ) { return 1 ; } $ next = $ tokens -> getNextMeaningfulToken ( $ next ) ; if ( null === $ next || ! $ tokens [ $ next ] -> equals ( [ T_STRING , 'strict_types' ] , false ) ) { return 1 ; } $ next = $ tokens -> getNextMeaningfulToken ( $ next ) ; if ( null === $ next || ! $ tokens [ $ next ] -> equals ( '=' ) ) { return 1 ; } $ next = $ tokens -> getNextMeaningfulToken ( $ next ) ; if ( null === $ next || ! $ tokens [ $ next ] -> isGivenKind ( T_LNUMBER ) ) { return 1 ; } $ next = $ tokens -> getNextMeaningfulToken ( $ next ) ; if ( null === $ next || ! $ tokens [ $ next ] -> equals ( ')' ) ) { return 1 ; } $ next = $ tokens -> getNextMeaningfulToken ( $ next ) ; if ( null === $ next || ! $ tokens [ $ next ] -> equals ( ';' ) ) { return 1 ; } return $ next + 1 ; }
10281	public static function absoluteCoordinate ( $ pCoordinateString ) { if ( self :: coordinateIsRange ( $ pCoordinateString ) ) { throw new Exception ( 'Cell coordinate string can not be a range of cells' ) ; } $ worksheet = '' ; $ cellAddress = explode ( '!' , $ pCoordinateString ) ; if ( count ( $ cellAddress ) > 1 ) { list ( $ worksheet , $ pCoordinateString ) = $ cellAddress ; } if ( $ worksheet > '' ) { $ worksheet .= '!' ; } list ( $ column , $ row ) = self :: coordinateFromString ( $ pCoordinateString ) ; $ column = ltrim ( $ column , '$' ) ; $ row = ltrim ( $ row , '$' ) ; return $ worksheet . '$' . $ column . '$' . $ row ; }
1771	public function generateWithError ( $ blnSwitchOrder = false ) { $ strWidget = $ this -> generate ( ) ; $ strError = $ this -> getErrorAsHTML ( ) ; return $ blnSwitchOrder ? $ strWidget . $ strError : $ strError . $ strWidget ; }
1044	private static function highlightSourceAtLocation ( Source $ source , SourceLocation $ location ) { $ line = $ location -> line ; $ lineOffset = $ source -> locationOffset -> line - 1 ; $ columnOffset = self :: getColumnOffset ( $ source , $ location ) ; $ contextLine = $ line + $ lineOffset ; $ contextColumn = $ location -> column + $ columnOffset ; $ prevLineNum = ( string ) ( $ contextLine - 1 ) ; $ lineNum = ( string ) $ contextLine ; $ nextLineNum = ( string ) ( $ contextLine + 1 ) ; $ padLen = strlen ( $ nextLineNum ) ; $ lines = preg_split ( '/\r\n|[\n\r]/' , $ source -> body ) ; $ lines [ 0 ] = self :: whitespace ( $ source -> locationOffset -> column - 1 ) . $ lines [ 0 ] ; $ outputLines = [ sprintf ( '%s (%s:%s)' , $ source -> name , $ contextLine , $ contextColumn ) , $ line >= 2 ? ( self :: lpad ( $ padLen , $ prevLineNum ) . ': ' . $ lines [ $ line - 2 ] ) : null , self :: lpad ( $ padLen , $ lineNum ) . ': ' . $ lines [ $ line - 1 ] , self :: whitespace ( 2 + $ padLen + $ contextColumn - 1 ) . '^' , $ line < count ( $ lines ) ? self :: lpad ( $ padLen , $ nextLineNum ) . ': ' . $ lines [ $ line ] : null , ] ; return implode ( "\n" , array_filter ( $ outputLines ) ) ; }
11771	private function retryCommandOnFailure ( CommandInterface $ command , $ method ) { $ retries = 0 ; SENTINEL_RETRY : { try { $ response = $ this -> getConnectionByCommand ( $ command ) -> $ method ( $ command ) ; } catch ( CommunicationException $ exception ) { $ this -> wipeServerList ( ) ; $ exception -> getConnection ( ) -> disconnect ( ) ; if ( $ retries == $ this -> retryLimit ) { throw $ exception ; } usleep ( $ this -> retryWait * 1000 ) ; ++ $ retries ; goto SENTINEL_RETRY ; } } return $ response ; }
9552	public function allowMimeTypes ( $ mimeTypes ) { if ( ! is_array ( $ mimeTypes ) ) { $ mimeTypes = [ $ mimeTypes ] ; } $ this -> constraints [ ] = new MimeTypeConstraint ( $ mimeTypes ) ; return $ this ; }
10506	private function registerLogMenu ( ) { $ this -> app -> singleton ( Contracts \ Utilities \ LogMenu :: class , Utilities \ LogMenu :: class ) ; $ this -> app -> singleton ( 'arcanedev.log-viewer.menu' , Contracts \ Utilities \ LogMenu :: class ) ; }
9595	public function makeSessionStorage ( ) { $ storage = $ this -> config -> get ( 'session.storage' ) ; if ( $ storage == 'mock_array' ) { return new MockArraySessionStorage ; } if ( $ storage == 'mock_file' ) { return new MockFileSessionStorage ; } $ handler = $ this -> dic -> resolve ( 'SessionHandlerInterface' ) ; if ( $ storage == 'bridge' ) { return new PhpBridgeSessionStorage ( $ handler ) ; } $ options = $ this -> config -> get ( 'session.storage_options' , [ ] ) ; if ( $ storage == 'native' ) { return new NativeSessionStorage ( $ options , $ handler ) ; } if ( ! is_string ( $ storage ) ) { $ storage = gettype ( $ storage ) ; } throw new \ RuntimeException ( "Unknown session storage driver: $storage" ) ; }
912	private function moveParamAnnotations ( $ content ) { $ doc = new DocBlock ( $ content ) ; $ params = $ doc -> getAnnotationsOfType ( 'param' ) ; if ( empty ( $ params ) ) { return $ content ; } $ others = $ doc -> getAnnotationsOfType ( [ 'throws' , 'return' ] ) ; if ( empty ( $ others ) ) { return $ content ; } $ end = end ( $ params ) -> getEnd ( ) ; $ line = $ doc -> getLine ( $ end ) ; foreach ( $ others as $ other ) { if ( $ other -> getStart ( ) < $ end ) { $ line -> setContent ( $ line -> getContent ( ) . $ other -> getContent ( ) ) ; $ other -> remove ( ) ; } } return $ doc -> getContent ( ) ; }
11321	function getRow ( $ sql , $ params = array ( ) ) { $ data = $ this -> query ( $ sql , $ params ) ; $ row = false ; if ( count ( $ data ) > 0 ) { $ row = $ data [ 0 ] ; } return $ row ; }
10508	private function registerChecker ( ) { $ this -> app -> singleton ( Contracts \ Utilities \ LogChecker :: class , Utilities \ LogChecker :: class ) ; $ this -> app -> singleton ( 'arcanedev.log-viewer.checker' , Contracts \ Utilities \ LogChecker :: class ) ; }
8148	public function compile ( Twig_NodeInterface $ node ) { if ( null === $ this -> compiler ) { $ this -> compiler = new Twig_Compiler ( $ this ) ; } return $ this -> compiler -> compile ( $ node ) -> getSource ( ) ; }
33	protected function addReason ( $ id , $ reason ) { if ( ! isset ( $ this -> reasonSeen [ $ id ] ) ) { $ this -> reasonSeen [ $ id ] = true ; $ this -> reasons [ $ this -> section ] [ ] = $ reason ; } }
4039	protected function getClassForOption ( $ index ) { $ intSub = ( $ this -> arrConfiguration [ 'includeBlankOption' ] ? - 1 : 1 ) ; $ strClass = $ this -> strName ; if ( $ index == 0 ) { $ strClass .= ' first' ; } elseif ( $ index === ( count ( $ this -> options ) - $ intSub ) ) { $ strClass .= ' last' ; } if ( ( $ index % 2 ) == 1 ) { $ strClass .= ' even' ; } else { $ strClass .= ' odd' ; } return ( ( strlen ( $ this -> strClass ) ) ? ' ' . $ this -> strClass : '' ) . $ strClass ; }
3777	protected function getParamName ( ) { if ( $ this -> get ( 'urlparam' ) ) { return $ this -> get ( 'urlparam' ) ; } $ objAttribute = $ this -> getFilteredAttribute ( ) ; if ( $ objAttribute ) { return $ objAttribute -> getColName ( ) ; } return null ; }
10011	public function removeSheetByIndex ( $ pIndex ) { $ numSheets = count ( $ this -> workSheetCollection ) ; if ( $ pIndex > $ numSheets - 1 ) { throw new Exception ( "You tried to remove a sheet by the out of bounds index: {$pIndex}. The actual number of sheets is {$numSheets}." ) ; } array_splice ( $ this -> workSheetCollection , $ pIndex , 1 ) ; if ( ( $ this -> activeSheetIndex >= $ pIndex ) && ( $ pIndex > count ( $ this -> workSheetCollection ) - 1 ) ) { -- $ this -> activeSheetIndex ; } }
12071	private function getCfgParamsByRanks ( ) { $ asParams = 'pbhcp' ; $ asRank = 'pbhr' ; $ tblParams = $ this -> resource -> getTableName ( CfgParam :: ENTITY_NAME ) ; $ tblRank = $ this -> resource -> getTableName ( Rank :: ENTITY_NAME ) ; $ query = $ this -> conn -> select ( ) ; $ query -> from ( [ $ asParams => $ tblParams ] ) ; $ on = "$asParams." . CfgParam :: A_RANK_ID . "=$asRank." . Rank :: A_ID ; $ cols = [ Rank :: A_CODE ] ; $ query -> joinLeft ( [ $ asRank => $ tblRank ] , $ on , $ cols ) ; $ entries = $ this -> conn -> fetchAll ( $ query ) ; $ result = [ ] ; foreach ( $ entries as $ entry ) { $ rankCode = $ entry [ Rank :: A_CODE ] ; $ rankScheme = $ entry [ CfgParam :: A_SCHEME ] ; $ result [ $ rankCode ] [ $ rankScheme ] = $ entry ; } return $ result ; }
707	public function bigPrimaryKey ( $ length = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_BIGPK , $ length ) ; }
6542	public function current ( ) { if ( true === $ this -> wantNewModel ) { return $ this -> entityManager -> load ( $ this -> modelClassName , $ this -> selector -> current ( ) ) ; } else { $ this -> initializeModel ( $ this -> selector -> current ( ) , $ this -> selector -> currentShardingKey ( ) ) ; $ this -> entityManager -> resetModel ( $ this -> model , $ this -> selector -> current ( ) ) ; return $ this -> model ; } }
9497	protected function getOne ( $ end_point ) { $ end_point = strtolower ( $ end_point ) ; if ( strpos ( $ end_point , 'http' ) !== 0 ) { $ end_point = $ this -> api -> getApiUrl ( ) . $ end_point ; } $ request = $ this -> api -> get ( $ end_point ) ; $ response = $ this -> processRequest ( $ request ) ; $ result = $ response -> json ( ) ; $ type = $ this -> getType ( ) ; $ className = explode ( '\\' , $ type ) ; $ baseName = strtolower ( end ( $ className ) ) ; if ( $ result && isset ( $ result [ $ baseName ] ) ) { $ t = new $ type ( ) ; $ t -> setManagingClient ( $ this ) ; return $ t -> fromArray ( $ result [ $ baseName ] ) ; } return null ; }
248	public function destroy ( ) { if ( $ this -> getIsActive ( ) ) { $ sessionId = session_id ( ) ; $ this -> close ( ) ; $ this -> setId ( $ sessionId ) ; $ this -> open ( ) ; session_unset ( ) ; session_destroy ( ) ; $ this -> setId ( $ sessionId ) ; } }
8098	protected function toCollection ( $ data ) { if ( is_array ( $ data ) ) { return new Collection ( $ data ) ; } else { if ( ! ( $ data instanceof Collection ) ) { $ data = new Collection ( ) ; } } return $ data ; }
593	public function combineCssFiles ( $ inputFiles , $ outputFile ) { $ content = '' ; $ outputFilePath = dirname ( $ this -> findRealPath ( $ outputFile ) ) ; foreach ( $ inputFiles as $ file ) { $ content .= "/*** BEGIN FILE: $file ***/\n" . $ this -> adjustCssUrl ( file_get_contents ( $ file ) , dirname ( $ this -> findRealPath ( $ file ) ) , $ outputFilePath ) . "/*** END FILE: $file ***/\n" ; } if ( ! file_put_contents ( $ outputFile , $ content ) ) { throw new Exception ( "Unable to write output CSS file '{$outputFile}'." ) ; } }
5141	public function run ( ) : void { $ request = $ request = ServerRequestFactory :: fromGlobals ( ) ; $ response = $ this -> process ( $ request ) ; $ emitter = $ this -> getContainer ( ) -> has ( EmitterInterface :: class ) ? $ this -> getContainer ( ) -> get ( EmitterInterface :: class ) : new SapiEmitter ( ) ; $ emitter -> emit ( $ response ) ; }
12118	public function getParam ( $ key , $ default = null ) { $ param = parent :: getParam ( $ key , $ default ) ; if ( is_string ( $ param ) ) { return trim ( $ param ) ; } return $ param ; }
1828	public function save ( ) { if ( \ count ( \ func_get_args ( ) ) ) { throw new \ InvalidArgumentException ( 'The $blnForceInsert argument has been removed (see system/docs/UPGRADE.md)' ) ; } if ( $ this -> blnPreventSaving ) { throw new \ RuntimeException ( 'The model instance has been detached and cannot be saved' ) ; } $ objDatabase = Database :: getInstance ( ) ; $ arrFields = $ objDatabase -> getFieldNames ( static :: $ strTable ) ; if ( Registry :: getInstance ( ) -> isRegistered ( $ this ) ) { $ arrSet = array ( ) ; $ arrRow = $ this -> row ( ) ; foreach ( $ this -> arrModified as $ k => $ v ) { if ( \ in_array ( $ k , $ arrFields ) ) { $ arrSet [ $ k ] = $ arrRow [ $ k ] ; } } $ arrSet = $ this -> preSave ( $ arrSet ) ; if ( empty ( $ arrSet ) ) { return $ this ; } $ intPk = $ this -> { static :: $ strPk } ; if ( isset ( $ this -> arrModified [ static :: $ strPk ] ) ) { $ intPk = $ this -> arrModified [ static :: $ strPk ] ; } if ( $ intPk === null ) { throw new \ RuntimeException ( 'The primary key has not been set' ) ; } $ objDatabase -> prepare ( "UPDATE " . static :: $ strTable . " %s WHERE " . Database :: quoteIdentifier ( static :: $ strPk ) . "=?" ) -> set ( $ arrSet ) -> execute ( $ intPk ) ; $ this -> postSave ( self :: UPDATE ) ; $ this -> arrModified = array ( ) ; } else { $ arrSet = $ this -> row ( ) ; foreach ( $ arrSet as $ k => $ v ) { if ( ! \ in_array ( $ k , $ arrFields ) ) { unset ( $ arrSet [ $ k ] ) ; } } $ arrSet = $ this -> preSave ( $ arrSet ) ; if ( empty ( $ arrSet ) ) { return $ this ; } $ stmt = $ objDatabase -> prepare ( "INSERT INTO " . static :: $ strTable . " %s" ) -> set ( $ arrSet ) -> execute ( ) ; if ( static :: $ strPk == 'id' ) { $ this -> id = $ stmt -> insertId ; } $ this -> postSave ( self :: INSERT ) ; $ this -> arrModified = array ( ) ; Registry :: getInstance ( ) -> register ( $ this ) ; } return $ this ; }
3874	protected function removeEmptyDetailPages ( $ jumpTos ) { foreach ( $ jumpTos as $ jumpTo ) { $ event = new GetPageDetailsEvent ( $ jumpTo [ 'value' ] ) ; $ this -> getEventDispatcher ( ) -> dispatch ( ContaoEvents :: CONTROLLER_GET_PAGE_DETAILS , $ event ) ; $ pageDetails = $ event -> getPageDetails ( ) ; if ( $ pageDetails === null ) { continue ; } $ baseUrl = $ this -> getBaseUrl ( $ pageDetails ) ; if ( ( $ strKey = array_search ( $ baseUrl -> getUrl ( ) , $ this -> foundPages ) ) !== false ) { unset ( $ this -> foundPages [ $ strKey ] ) ; } $ baseUrl = $ this -> getBaseUrl ( $ pageDetails , null , true ) ; if ( ( $ strKey = array_search ( $ baseUrl -> getUrl ( ) , $ this -> foundPages ) ) !== false ) { unset ( $ this -> foundPages [ $ strKey ] ) ; } } }
7129	public function hasNotifications ( $ type = null ) { if ( null !== $ type ) { NotificationTypes :: isValidType ( $ type ) ; return $ this -> getNotifications ( $ type ) -> count ( ) ; } return 0 < $ this -> notifications -> count ( ) ; }
1494	public static function fromArray ( iterable $ config , string $ urlPrefix = null ) : self { return new self ( ... collect ( $ config ) -> map ( function ( $ value , $ key ) use ( $ urlPrefix ) { return Encoding :: fromArray ( $ key , $ value , $ urlPrefix ) ; } ) -> values ( ) ) ; }
25	public function getContents ( $ originUrl , $ fileUrl , $ progress = true , $ options = array ( ) ) { return $ this -> get ( $ originUrl , $ fileUrl , $ options , null , $ progress ) ; }
120	protected function hasAuth ( ) { if ( null !== $ this -> hasAuth ) { return $ this -> hasAuth ; } if ( false === $ this -> createAuthFromConfig ( ) ) { $ this -> createAuthFromUrl ( ) ; } return $ this -> hasAuth ; }
1289	public function setType ( string $ type = null ) { $ validTypes = [ 'all' , 'Asset' , 'Entry' , 'Deletion' , 'DeletedAsset' , 'DeletedEntry' ] ; if ( ! \ in_array ( $ type , $ validTypes , true ) ) { throw new \ InvalidArgumentException ( \ sprintf ( 'Unexpected type "%s".' , $ type ) ) ; } $ this -> type = $ type ; return $ this ; }
12604	public static function upload ( $ src , $ dest ) { $ dest = Path :: clean ( $ dest ) ; $ baseDir = dirname ( $ dest ) ; try { if ( ! Folder :: exists ( $ baseDir ) ) { Folder :: create ( $ baseDir ) ; } } catch ( Exception $ e ) { throw $ e ; } if ( is_writeable ( $ baseDir ) && move_uploaded_file ( $ src , $ dest ) ) { if ( Path :: setPermissions ( $ dest ) ) { return true ; } throw new Exception ( Helper :: getTranslation ( 'FAILED_CHMOD' ) ) ; } throw new Exception ( Helper :: getTranslation ( 'FAILED_MOVE_UPLOAD' ) ) ; }
1607	public function save ( $ uri , $ to , $ type , $ siteId = null , $ id = null ) { if ( $ siteId === 'null' ) $ siteId = null ; if ( $ id ) { $ record = RedirectRecord :: findOne ( compact ( 'id' ) ) ; if ( ! $ record ) return 'Unable to find redirect with ID: ' . $ id ; } else { $ existing = RedirectRecord :: findOne ( compact ( 'uri' , 'siteId' ) ) ; if ( $ existing ) return 'A redirect with that URI already exists!' ; $ record = new RedirectRecord ( ) ; } $ record -> uri = $ uri ; $ record -> to = $ to ; $ record -> type = $ type ; if ( $ siteId !== false ) $ record -> siteId = $ siteId ; if ( ! $ record -> save ( ) ) return $ record -> getErrors ( ) ; return $ record -> id ; }
527	public function registerAssetFiles ( $ view ) { $ manager = $ view -> getAssetManager ( ) ; foreach ( $ this -> js as $ js ) { if ( is_array ( $ js ) ) { $ file = array_shift ( $ js ) ; $ options = ArrayHelper :: merge ( $ this -> jsOptions , $ js ) ; $ view -> registerJsFile ( $ manager -> getAssetUrl ( $ this , $ file ) , $ options ) ; } else { if ( $ js !== null ) { $ view -> registerJsFile ( $ manager -> getAssetUrl ( $ this , $ js ) , $ this -> jsOptions ) ; } } } foreach ( $ this -> css as $ css ) { if ( is_array ( $ css ) ) { $ file = array_shift ( $ css ) ; $ options = ArrayHelper :: merge ( $ this -> cssOptions , $ css ) ; $ view -> registerCssFile ( $ manager -> getAssetUrl ( $ this , $ file ) , $ options ) ; } else { if ( $ css !== null ) { $ view -> registerCssFile ( $ manager -> getAssetUrl ( $ this , $ css ) , $ this -> cssOptions ) ; } } } }
5457	protected function addContentTagToOpenTags ( & $ tag ) { if ( $ tag -> getTagName ( ) != 'option' ) { return ; } foreach ( array_keys ( $ this -> tags ) as $ name ) { for ( $ i = 0 , $ count = count ( $ this -> tags [ $ name ] ) ; $ i < $ count ; $ i ++ ) { $ this -> tags [ $ name ] [ $ i ] -> addTag ( $ tag ) ; } } }
6945	protected function watch ( OrderPaymentInterface $ payment ) { $ order = $ payment -> getOrder ( ) ; if ( ! $ order -> isAutoNotify ( ) || $ order -> isSample ( ) ) { return ; } if ( ! $ payment -> getMethod ( ) -> isManual ( ) ) { return ; } if ( ! $ this -> didStateChangeTo ( $ payment , PaymentStates :: STATE_CAPTURED ) ) { return ; } foreach ( $ order -> getNotifications ( ) as $ n ) { if ( $ n -> getType ( ) !== NotificationTypes :: PAYMENT_CAPTURED ) { continue ; } if ( $ n -> hasData ( 'payment' ) && $ n -> getData ( 'payment' ) === $ payment -> getNumber ( ) ) { return ; } } $ this -> notify ( NotificationTypes :: PAYMENT_CAPTURED , $ payment ) ; }
3518	public function setShowUnpublished ( $ showUnpublished ) { if ( $ this -> useCookies ) { Cookie :: queue ( $ this -> cookiePrefix . 'show_unpublished' , $ showUnpublished ) ; } $ this -> useDB = $ showUnpublished ? 2 : 1 ; }
8662	private function convertGetFeedSubmissionList ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetFeedSubmissionList' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetFeedSubmissionIdList ( ) ) { $ feedSubmissionIdList = $ request -> getFeedSubmissionIdList ( ) ; foreach ( $ feedSubmissionIdList -> getId ( ) as $ idIndex => $ id ) { $ parameters [ 'FeedSubmissionIdList' . '.' . 'Id' . '.' . ( $ idIndex + 1 ) ] = $ id ; } } if ( $ request -> isSetMaxCount ( ) ) { $ parameters [ 'MaxCount' ] = $ request -> getMaxCount ( ) ; } if ( $ request -> isSetFeedTypeList ( ) ) { $ feedTypeList = $ request -> getFeedTypeList ( ) ; foreach ( $ feedTypeList -> getType ( ) as $ typeIndex => $ type ) { $ parameters [ 'FeedTypeList' . '.' . 'Type' . '.' . ( $ typeIndex + 1 ) ] = $ type ; } } if ( $ request -> isSetFeedProcessingStatusList ( ) ) { $ feedProcessingStatusList = $ request -> getFeedProcessingStatusList ( ) ; foreach ( $ feedProcessingStatusList -> getStatus ( ) as $ statusIndex => $ status ) { $ parameters [ 'FeedProcessingStatusList' . '.' . 'Status' . '.' . ( $ statusIndex + 1 ) ] = $ status ; } } if ( $ request -> isSetSubmittedFromDate ( ) ) { $ parameters [ 'SubmittedFromDate' ] = $ this -> getFormattedTimestamp ( $ request -> getSubmittedFromDate ( ) ) ; } if ( $ request -> isSetSubmittedToDate ( ) ) { $ parameters [ 'SubmittedToDate' ] = $ this -> getFormattedTimestamp ( $ request -> getSubmittedToDate ( ) ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
258	public function render ( $ view , $ params = [ ] , $ context = null ) { $ viewFile = $ this -> findViewFile ( $ view , $ context ) ; return $ this -> renderFile ( $ viewFile , $ params , $ context ) ; }
8725	public function translationModel ( ) { $ translation = new TranslationModel ( ) ; $ translation -> setConnection ( $ this -> getI18nConnection ( ) ) ; $ translation -> setTable ( $ this -> getI18nTable ( ) ) ; $ translation -> setKeyName ( $ this -> getForeignKey ( ) ) ; $ translation -> setLocaleKey ( $ this -> getLocaleKey ( ) ) ; if ( $ attributes = $ this -> translatableAttributes ( ) ) { $ translation -> fillable ( array_intersect ( $ attributes , $ this -> getFillable ( ) ) ) ; } return $ translation ; }
9328	protected function registerMarkdownPhpEngine ( $ resolver ) { $ app = $ this -> app ; $ app -> singleton ( 'markdown.php.compiler' , function ( $ app ) { $ cache = $ app [ 'config' ] [ 'view.compiled' ] ; return new MarkdownPhpCompiler ( $ app [ 'files' ] , $ cache ) ; } ) ; $ resolver -> register ( 'markdown.php' , function ( ) use ( $ app ) { return new MarkdownEngine ( $ app [ 'markdown.php.compiler' ] , $ app [ 'files' ] ) ; } ) ; $ app [ 'view' ] -> addExtension ( 'md.php' , 'markdown.php' ) ; }
1940	public function checkUniqueRecipient ( $ varValue , Contao \ DataContainer $ dc ) { $ objRecipient = $ this -> Database -> prepare ( "SELECT COUNT(*) AS count FROM tl_newsletter_recipients WHERE email=? AND pid=(SELECT pid FROM tl_newsletter_recipients WHERE id=?) AND id!=?" ) -> execute ( $ varValue , $ dc -> id , $ dc -> id ) ; if ( $ objRecipient -> count > 0 ) { throw new Exception ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'unique' ] , $ GLOBALS [ 'TL_LANG' ] [ $ dc -> table ] [ $ dc -> field ] [ 0 ] ) ) ; } return $ varValue ; }
8650	private function getFormattedTimestamp ( $ dateTime ) { if ( ! $ dateTime instanceof DateTime ) { $ dateTime = new DateTime ( $ dateTime ) ; } return $ dateTime -> format ( DATE_ISO8601 ) ; }
957	public function remainingTrialDays ( ) { if ( ! $ this -> isTrial ( ) ) { return ; } return $ this -> isActiveTrial ( ) ? Carbon :: today ( ) -> diffInDays ( $ this -> trial_ends_on ) : 0 ; }
9486	protected function checkFieldsSet ( $ fields ) { foreach ( $ fields as $ field ) { if ( property_exists ( $ this , $ field ) && $ this -> $ field === null ) { throw new \ Exception ( "'$field' is required" ) ; } } }
11217	public static function getMethod ( $ route ) { $ route = Url :: addBackSlash ( $ route ) ; return isset ( self :: $ routes [ $ route ] ) ? self :: $ routes [ $ route ] : null ; }
12890	public function createView ( ) : \ stdClass { $ oView = new \ stdClass ; $ oView -> form = $ this -> _sView ; $ oView -> form_start = $ this -> _oForm -> getFormInObject ( ) -> start ; $ oView -> form_end = $ this -> _oForm -> getFormInObject ( ) -> end ; $ oView -> form_row = array ( ) ; foreach ( $ this -> _oForm -> getFormInObject ( ) -> form as $ sKey => $ mValue ) { if ( $ mValue instanceof Container ) { $ oNewForm = $ mValue -> createView ( ) ; $ oView -> form_row [ $ sKey ] = $ oNewForm -> form_row ; } else { $ oView -> form_row [ $ sKey ] = $ mValue ; } } return $ oView ; }
5520	protected function checkExpectations ( $ method , $ args , $ timing ) { $ test = $ this -> getCurrentTestCase ( ) ; if ( isset ( $ this -> max_counts [ $ method ] ) ) { if ( ! $ this -> max_counts [ $ method ] -> test ( $ timing + 1 ) ) { $ test -> assert ( $ this -> max_counts [ $ method ] , $ timing + 1 ) ; } } if ( isset ( $ this -> expected_args_at [ $ timing ] [ $ method ] ) ) { $ test -> assert ( $ this -> expected_args_at [ $ timing ] [ $ method ] , $ args , "Mock method [$method] at [$timing] -> %s" ) ; } elseif ( isset ( $ this -> expected_args [ $ method ] ) ) { $ test -> assert ( $ this -> expected_args [ $ method ] , $ args , "Mock method [$method] -> %s" ) ; } }
9031	public function execute ( Closure $ callback ) { foreach ( $ this -> getServices ( ) as $ service ) { try { return $ callback ( $ this -> container -> make ( $ service ) ) ; } catch ( Exception $ e ) { } } throw new RuntimeException ( 'Could not execute any service.' ) ; }
9889	public static function json ( $ response ) { $ body = self :: toString ( $ response ) ; $ data = json_decode ( $ body , true ) ; if ( JSON_ERROR_NONE !== json_last_error ( ) ) { throw new RuntimeException ( 'Unable to parse response body into JSON: ' . json_last_error ( ) ) ; } return $ data === null ? [ ] : $ data ; }
2924	public function formatSetterLine ( $ key , $ value = null , $ comment = null , $ export = false ) { $ forceQuotes = ( strlen ( $ comment ) > 0 && strlen ( trim ( $ value ) ) == 0 ) ; $ value = $ this -> formatValue ( $ value , $ forceQuotes ) ; $ key = $ this -> formatKey ( $ key ) ; $ comment = $ this -> formatComment ( $ comment ) ; $ export = $ export ? 'export ' : '' ; $ line = "{$export}{$key}={$value}{$comment}" ; return $ line ; }
11059	public static function files ( $ path , array $ extensions = array ( ) ) { $ files = array ( ) ; $ it = new \ RecursiveDirectoryIterator ( $ path ) ; $ filter = false ; if ( ! empty ( $ extensions ) && is_array ( $ extensions ) ) { $ filter = true ; } foreach ( new \ RecursiveIteratorIterator ( $ it ) as $ file ) { if ( $ filter ) { $ f = explode ( '.' , $ file ) ; $ ext = strtolower ( array_pop ( $ f ) ) ; if ( in_array ( $ ext , $ extensions ) ) { $ files [ ] = $ file ; } } else { $ files [ ] = $ file ; } } return $ files ; }
12975	public function registerMapping ( Configuration $ config ) { $ driverChain = new DriverChain ; $ aliasMap = array ( ) ; $ drivers = array ( ) ; $ this -> parseMappingInfo ( ) ; foreach ( $ this -> getMappings ( ) as $ mappingName => $ mappingConfig ) { if ( empty ( $ mappingConfig [ 'prefix' ] ) ) { $ mappingConfig [ 'prefix' ] = '__DEFAULT__' ; } $ drivers [ $ mappingConfig [ 'type' ] ] [ $ mappingConfig [ 'prefix' ] ] = $ mappingConfig [ 'dir' ] ; if ( isset ( $ mappingConfig [ 'alias' ] ) ) { $ aliasMap [ $ mappingConfig [ 'alias' ] ] = $ mappingConfig [ 'prefix' ] ; } } foreach ( $ drivers as $ driverType => $ driverPaths ) { if ( $ driverType === 'annotation' ) { $ driver = $ config -> newDefaultAnnotationDriver ( $ driverPaths , false ) ; } else { $ paths = $ driverPaths ; if ( strpos ( $ driverType , 'simplified' ) === 0 ) { $ paths = array_flip ( $ driverPaths ) ; } $ driver = DiC :: resolve ( $ driverType , [ $ paths ] ) ; } foreach ( $ driverPaths as $ prefix => $ driverPath ) { if ( $ prefix === '__DEFAULT__' or count ( $ this -> config [ 'mappings' ] ) === 1 ) { $ driverChain -> setDefaultDriver ( $ driver ) ; } else { $ driverChain -> addDriver ( $ driver , $ prefix ) ; } } } $ config -> setMetadataDriverImpl ( $ driverChain ) ; $ config -> setEntityNamespaces ( $ aliasMap ) ; }
10848	protected function getTableName ( $ returnAlias = false ) { $ result = '' ; foreach ( $ this -> clause_table as $ k => $ v ) { if ( ! is_int ( $ k ) && $ returnAlias ) { return $ k ; } else { return $ v ; } } return $ result ; }
7785	public function setStatementClass ( $ statementClass ) { if ( ! is_callable ( $ statementClass ) && ! class_exists ( $ statementClass ) ) { throw new \ InvalidArgumentException ( '$statementClass must be a valid classname or a PHP callable' ) ; } $ this -> statementClass = $ statementClass ; return $ this ; }
9691	private function compile ( $ file ) { if ( ! file_exists ( $ file ) ) { throw new \ Exception ( "Could not compile $file, file not found" ) ; } if ( ! file_exists ( $ this -> views_cache ) && ! mkdir ( $ this -> views_cache ) ) { throw new \ Exception ( "Could no create cache directory." . " Make sure you have write permissions." ) ; } $ hash = md5 ( $ file ) ; $ compiled_file = $ this -> views_cache . '/' . $ hash ; $ compiled = null ; if ( $ this -> debug || ( ! file_exists ( $ compiled_file ) || filemtime ( $ compiled_file ) < filemtime ( $ file ) ) ) { $ source = file_get_contents ( $ file ) ; $ compiled = $ this -> compileString ( $ source ) ; $ compiled = "<?php\nfunction katar_" . $ hash . "(\$args) {\nextract(\$args);\n\$output = null;\n" . $ compiled . "\nreturn \$output;\n}\n" ; file_put_contents ( $ compiled_file , $ compiled ) ; } else { $ compiled = file_get_contents ( $ cache_file ) ; } return $ compiled ; }
12253	public function dump ( ) { $ dom = new DOMDocument ( '1.0' ) ; $ dom -> preserveWhiteSpace = false ; $ dom -> formatOutput = true ; $ dom -> loadXML ( $ this -> asXML ( ) ) ; return $ dom -> saveXML ( ) ; }
12031	function addCreateAndExecuteMethod ( ) { $ methodGenerator = new MethodGenerator ( 'createAndExecute' ) ; $ body = '' ; $ body .= $ this -> generateCreateFragment ( ) ; $ body .= $ this -> generateExecuteFragment ( ) ; $ body .= PHP_EOL ; $ body .= 'return $response;' . PHP_EOL ; ; $ docBlock = new DocBlockGenerator ( 'Create and execute the operation, returning the raw response from the server.' , null ) ; $ tags [ ] = new GenericTag ( 'return' , '\Amp\Artax\Response' ) ; $ docBlock -> setTags ( $ tags ) ; $ methodGenerator -> setBody ( $ body ) ; $ methodGenerator -> setDocBlock ( $ docBlock ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; }
12255	public function removeCompiler ( $ compiler ) { if ( ( $ idx = array_search ( $ compiler , $ this -> compilers ) ) !== false ) { unset ( $ this -> compilers [ $ idx ] ) ; $ this -> orderedCompilers = NULL ; } }
3516	public function setLocale ( $ locale ) { if ( $ this -> useCookies ) { Cookie :: queue ( $ this -> cookiePrefix . 'lang_locale' , $ locale ) ; } parent :: setLocale ( $ locale ) ; }
9642	public function resolve ( $ path ) { $ paths = [ ] ; foreach ( $ this -> paths as $ configuredPath ) { $ paths [ ] = $ configuredPath . '/' . $ path ; } $ parts = explode ( '/' , $ path ) ; if ( count ( $ parts ) == 1 ) { return $ paths ; } $ current = '' ; $ mountPaths = [ ] ; foreach ( $ parts as $ part ) { if ( $ current ) { $ current .= '/' . $ part ; } else { $ current = $ part ; } if ( isset ( $ this -> mounts [ $ current ] ) ) { foreach ( $ this -> mounts [ $ current ] as $ mount ) { $ relativePath = str_replace ( $ current , '' , $ path ) ; $ mountPaths [ ] = $ mount . $ relativePath ; } } } return array_merge ( $ mountPaths , $ paths ) ; }
10930	public function countRowsFrom ( string $ tableName , string $ pkName ) : int { $ strSQL = "SELECT COUNT($pkName) as count FROM $tableName;" ; return $ this -> getCountOf ( $ strSQL ) ; }
3621	public function useEcoTempWhenAway ( $ enabled , $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ data = json_encode ( array ( 'auto_away_enable' => $ enabled ) ) ; return $ this -> doPOST ( "/v2/put/device." . $ serial_number , $ data ) ; }
12387	private static function showErrors ( ) { if ( count ( static :: $ errors ) > 0 ) { $ errorsList = '' ; foreach ( static :: $ errors as $ error ) { $ errorsList .= 'Tipo: ' . $ error [ 'type' ] . '<br>' ; $ errorsList .= 'Mensaje: ' . $ error [ 'message' ] . '<br>' ; $ errorsList .= 'Archivo: ' . $ error [ 'file' ] . '<br>' ; $ errorsList .= 'Line: ' . $ error [ 'line' ] . '<br><br>' ; } static :: viewException ( 1 , $ errorsList ) ; } }
10873	public function cleanUser ( string $ validate = null ) : int { $ result = 0 ; if ( $ validate ) { $ validateTo = new DateTime ; $ validateTo -> modify ( $ validate ) ; $ list = $ this -> getList ( ) -> where ( [ $ this -> tableName [ 0 ] . '.active' => false , $ this -> tableName [ 0 ] . '.added IS NOT NULL' , [ $ this -> tableName [ 0 ] . '.added<=%dt' , $ validateTo ] , ] ) ; foreach ( $ list as $ item ) { if ( $ this -> delete ( $ item [ self :: COLUMN_ID ] ) ) { $ result ++ ; } } } return $ result ; }
4452	public function stats ( ? int $ date = null ) : array { $ date = $ date ? : time ( ) ; return json_decode ( $ this -> client -> stats ( $ this -> name , $ date ) , true ) ; }
9330	static function filter ( $ width , $ height ) { return array ( new ezcImageFilter ( 'scale' , array ( 'width' => intval ( $ width ) , 'height' => intval ( $ height ) , 'direction' => ezcImageGeometryFilters :: SCALE_BOTH ) ) ) ; }
8091	static public function examine ( $ hash ) { if ( strlen ( $ hash ) == 40 && preg_match ( "/^[0-9]{4}/" , $ hash ) ) { $ e_uid_pos = substr ( $ hash , 0 , 2 ) ; $ e_uid_length = substr ( $ hash , 2 , 2 ) ; $ e_uid = substr ( $ hash , $ e_uid_pos , $ e_uid_length ) ; $ uid = self :: decode ( $ e_uid ) ; preg_match ( '/^([0-9]{4})(.{2,' . ( $ e_uid_pos - 4 ) . '})(' . $ e_uid . ')/' , $ hash , $ excerpt ) ; $ partial = $ excerpt [ 2 ] ; return array ( $ uid , $ partial ) ; } else { return array ( false , false ) ; } }
7485	public function charAt ( $ index ) { $ index = ( int ) $ index ; if ( $ index < 0 || $ index >= $ this -> length ( ) ) { throw new \ OutOfBoundsException ( ) ; } return mb_substr ( $ this -> string , $ index , 1 , $ this -> encoding ) ; }
11946	protected function getCurrentUser ( ) { try { return JWTAuth :: parseToken ( ) -> authenticate ( ) ; } catch ( \ Tymon \ JWTAuth \ Exceptions \ JWTException $ ex ) { return null ; } }
9374	protected function dispatcher ( ResponseInterface $ response , $ stack ) { $ dispatcher = new Dispatcher ( $ stack , $ response ) ; if ( class_exists ( 'Zend\Stratigility\MiddlewarePipe' ) ) { $ pipe = new MiddlewarePipe ; $ dispatcher = new StratigilityDispatcher ( $ pipe , $ stack , $ response ) ; } return $ dispatcher ; }
9172	public function getViewHelpers ( ) { return [ 'aliases' => [ 'formmulticheckbox' => Form \ View \ Helper \ FormMultiCheckbox :: class , 'formradio' => Form \ View \ Helper \ FormRadio :: class , 'zettaFlashMessenger' => View \ Helper \ FlashMessenger :: class , 'zettaFormMultiCheckbox' => Form \ View \ Helper \ FormMultiCheckbox :: class , 'zettaFormRadio' => Form \ View \ Helper \ FormRadio :: class , 'zettaFormRow' => Form \ View \ Helper \ FormRow :: class , 'zettaPaginator' => View \ Helper \ Paginator :: class , 'zettaReferer' => View \ Helper \ Referer :: class , 'settings' => View \ Helper \ Settings :: class , 'thumbnail' => View \ Helper \ Thumbnail :: class , 'zettaUrl' => View \ Helper \ Url :: class , ] , 'factories' => [ Form \ View \ Helper \ FormMultiCheckbox :: class => InvokableFactory :: class , Form \ View \ Helper \ FormRadio :: class => InvokableFactory :: class , Form \ View \ Helper \ FormRow :: class => InvokableFactory :: class , View \ Helper \ FlashMessenger :: class => InvokableFactory :: class , View \ Helper \ Paginator :: class => View \ Helper \ Factory \ PaginatorFactory :: class , View \ Helper \ Referer :: class => View \ Helper \ Factory \ RefererFactory :: class , View \ Helper \ Settings :: class => Factory \ WithSettingsFactory :: class , View \ Helper \ Thumbnail :: class => Factory \ WithThumbnailFactory :: class , View \ Helper \ Url :: class => View \ Helper \ Factory \ UrlFactory :: class ] , ] ; }
7624	protected function performRequest ( $ path = '/' , $ query = array ( ) , $ httpVerb = 'GET' , $ headers = array ( ) , $ forTableStorage = false , $ rawData = null , $ resourceType = self :: RESOURCE_UNKNOWN , $ requiredPermission = self :: PERMISSION_READ ) { if ( strpos ( $ path , '/' ) !== 0 ) { $ path = '/' . $ path ; } if ( ! isset ( $ headers [ 'Content-Type' ] ) ) { $ headers [ 'Content-Type' ] = '' ; } if ( ! isset ( $ headers [ 'content-length' ] ) && ( $ rawData !== null || $ httpVerb == "PUT" ) ) { $ headers [ 'Content-Length' ] = strlen ( ( string ) $ rawData ) ; } $ headers [ 'Expect' ] = '' ; $ headers [ 'x-ms-version' ] = $ this -> apiVersion ; $ path = str_replace ( ' ' , '%20' , $ path ) ; $ requestUrl = $ this -> getBaseUrl ( ) . $ path ; if ( count ( $ query ) > 0 ) { $ queryString = '' ; foreach ( $ query as $ key => $ value ) { $ queryString .= ( $ queryString ? '&' : '?' ) . rawurlencode ( $ key ) . '=' . rawurlencode ( $ value ) ; } $ requestUrl .= $ queryString ; } $ requestUrl = $ this -> credentials -> signRequestUrl ( $ requestUrl , $ resourceType , $ requiredPermission ) ; $ headers = $ this -> credentials -> signRequestHeaders ( $ httpVerb , $ path , $ query , $ headers , $ forTableStorage , $ resourceType , $ requiredPermission , $ rawData ) ; return $ this -> httpClient -> request ( $ httpVerb , $ requestUrl , $ rawData , $ headers ) ; }
10077	public static function sanitizeUTF8 ( $ value ) { if ( self :: getIsIconvEnabled ( ) ) { $ value = @ iconv ( 'UTF-8' , 'UTF-8' , $ value ) ; return $ value ; } $ value = mb_convert_encoding ( $ value , 'UTF-8' , 'UTF-8' ) ; return $ value ; }
167	protected static function loadMimeTypes ( $ magicFile ) { if ( $ magicFile === null ) { $ magicFile = static :: $ mimeMagicFile ; } $ magicFile = Yii :: getAlias ( $ magicFile ) ; if ( ! isset ( self :: $ _mimeTypes [ $ magicFile ] ) ) { self :: $ _mimeTypes [ $ magicFile ] = require $ magicFile ; } return self :: $ _mimeTypes [ $ magicFile ] ; }
3275	public function delete ( string $ key ) { Validation :: validateKey ( $ key ) ; if ( $ this -> get ( $ key ) !== false ) { $ this -> replace ( $ key , false ) ; } }
9390	public function getSortValBeforeAll ( $ groupingId = null ) { if ( $ groupingId === null && $ this -> grpColumn ) { throw new SortableException ( 'groupingId may be omitted only when grpColumn is not configured.' ) ; } $ query = ( new Query ( ) ) -> select ( [ $ this -> pkColumn , $ this -> srtColumn ] ) -> from ( $ this -> targetTable ) -> where ( [ 'and' , $ this -> grpColumn ? [ '=' , $ this -> grpColumn , $ groupingId ] : [ ] , $ this -> skipRowsClause ( ) ] ) -> orderBy ( [ $ this -> srtColumn => SORT_ASC ] ) -> limit ( 1 ) ; $ result = $ query -> one ( $ this -> db ) ; if ( $ result && $ result [ $ this -> srtColumn ] == 1 ) { $ this -> rebuildSortAfter ( $ result [ $ this -> pkColumn ] , true ) ; $ sortVal = $ this -> getIniSortVal ( ) ; } else if ( $ result ) { $ sortVal = ceil ( $ result [ $ this -> srtColumn ] / 2 ) ; } else $ sortVal = $ this -> getIniSortVal ( ) ; return ( int ) $ sortVal ; }
2746	public function isImageOptimizationPixelRatioEnabled ( ) { if ( $ this -> isImageOptimizationEnabled ( ) !== true ) { return false ; } return $ this -> _scopeConfig -> isSetFlag ( self :: XML_FASTLY_IMAGE_OPTIMIZATIONS_PIXEL_RATIO ) ; }
9556	public function add ( ParameterClosure $ closure ) { $ this -> prefixes [ $ closure -> prefix ] [ $ closure -> parameterName ] = $ closure ; return $ this ; }
11651	public function getProduct ( array $ productData ) { foreach ( $ this -> mandatoryFields as $ mandatoryField ) { if ( ! array_key_exists ( $ mandatoryField , $ productData ) ) { throw new ProductException ( "The field '$mandatoryField' is missing in the given product data" ) ; } } try { $ sku = new SKU ( $ productData [ self :: FIELD_SKU ] ) ; $ slug = new Slug ( $ productData [ self :: FIELD_SLUG ] ) ; $ content = $ this -> contentMapper -> getContent ( $ productData ) ; $ product = new Product ( $ sku , $ slug , $ content ) ; return $ product ; } catch ( \ Exception $ productException ) { throw new ProductException ( sprintf ( "Failed to create a product from the given data: %s" , $ productException -> getMessage ( ) ) , $ productException ) ; } }
6313	private function loadConstraints ( Table $ table ) { foreach ( $ this -> getConstraints ( ) as $ constraint ) { switch ( $ constraint [ 'constraint_type' ] ) { case 'FOREIGN KEY' : $ foreignKey = new ForeignKey ( new Table ( $ constraint [ 'table_name' ] ) , new Table ( $ constraint [ 'column_name' ] ) ) ; $ foreignKey -> setColumns ( $ constraint [ 'references_table' ] ) ; $ foreignKey -> setReferencedColumns ( $ constraint [ 'references_field' ] ) ; $ table -> addConstraint ( $ foreignKey ) ; break ; case 'PRIMARY KEY' : $ table -> addConstraint ( new PrimaryKey ( $ constraint [ 'column_name' ] , $ table ) ) ; break ; case 'UNIQUE' : $ table -> addConstraint ( new Unique ( $ constraint [ 'column_name' ] , new Table ( $ constraint [ 'table_name' ] ) ) ) ; break ; } } }
4603	public function decrypt ( string $ data , string $ key = null ) { $ key = $ this -> createKey ( $ key ) ; $ data = unserialize ( Crypto :: decrypt ( $ data , $ key ) ) ; return $ data ; }
4263	public function unsubscribe ( $ eventName , $ callable ) { if ( ! isset ( $ this -> subscribers [ $ eventName ] ) ) { return ; } if ( $ this -> isClosureFactory ( $ callable ) ) { $ callable [ 0 ] = $ callable [ 0 ] ( ) ; } foreach ( $ this -> subscribers [ $ eventName ] as $ priority => $ subscribers ) { foreach ( $ subscribers as $ k => $ v ) { if ( $ v !== $ callable && $ this -> isClosureFactory ( $ v ) ) { $ v [ 0 ] = $ v [ 0 ] ( ) ; } if ( $ v === $ callable ) { unset ( $ subscribers [ $ k ] , $ this -> sorted [ $ eventName ] ) ; } else { $ subscribers [ $ k ] = $ v ; } } if ( $ subscribers ) { $ this -> subscribers [ $ eventName ] [ $ priority ] = $ subscribers ; } else { unset ( $ this -> subscribers [ $ eventName ] [ $ priority ] ) ; } } }
7139	protected function getGroupsForStep ( $ step ) { $ groups = [ 'Default' ] ; if ( $ step === static :: CHECKOUT_STEP ) { $ groups [ ] = 'Checkout' ; $ groups [ ] = 'Identity' ; $ groups [ ] = 'Availability' ; } elseif ( $ step === static :: SHIPMENT_STEP ) { $ groups [ ] = 'Availability' ; } return $ groups ; }
5449	public function acceptEndToken ( $ token , $ event ) { if ( ! preg_match ( '/<\/(.*)>/' , $ token , $ matches ) ) { return false ; } return $ this -> listener -> endElement ( strtolower ( $ matches [ 1 ] ) ) ; }
4623	public function execute ( Command $ command ) { $ response = $ this -> getActiveNode ( ) -> execute ( $ command , $ this -> api ) ; if ( empty ( $ response ) && count ( $ this -> nodes ) > 1 && $ this -> attempts < $ this -> getConfigValue ( 'max_connect_attempts' ) ) { $ response = $ this -> pickNewNode ( ) -> execute ( $ command ) ; } elseif ( empty ( $ response ) && $ this -> attempts >= $ this -> getConfigValue ( 'max_connect_attempts' ) ) { throw new Exception ( 'Nodes unreachable. Error Msg: ' . $ this -> api -> getError ( ) ) ; } elseif ( $ response == false ) { throw new Exception ( 'Command failed to execute against Riak. Error Msg: ' . $ this -> api -> getError ( ) ) ; } return $ response ; }
8737	public function insertGetId ( array $ values , $ sequence = null ) { list ( $ values , $ i18nValues ) = $ this -> filterValues ( $ values ) ; if ( $ id = $ this -> query -> insertGetId ( $ values , $ sequence ) ) { if ( $ this -> insertI18n ( $ i18nValues , $ id ) ) { return $ id ; } } return false ; }
10702	public static function getPasswordComplexity ( $ password , $ minLength ) { $ group = [ 'upper' => '/[A-Z]/' , 'lower' => '/[a-z]/' , 'number' => '/[0-9]/' , 'special' => '/[^A-Za-z0-9]/' , ] ; $ score = 0 ; $ length = \ strlen ( $ password ) ; if ( $ length < $ minLength ) { return 0 ; } foreach ( $ group as $ pattern ) { if ( preg_match ( $ pattern , $ password ) ) { $ score ++ ; } } if ( $ score < 3 ) { $ score -- ; } if ( $ length > $ minLength ) { $ score += ( int ) floor ( ( $ length - $ minLength ) / 2 ) ; } return $ score ; }
537	protected function updateDocComment ( $ doc , $ properties ) { $ lines = explode ( "\n" , $ doc ) ; $ propertyPart = false ; $ propertyPosition = false ; foreach ( $ lines as $ i => $ line ) { $ line = trim ( $ line ) ; if ( strncmp ( $ line , '* @property ' , 12 ) === 0 ) { $ propertyPart = true ; } elseif ( $ propertyPart && $ line == '*' ) { $ propertyPosition = $ i ; $ propertyPart = false ; } if ( strncmp ( $ line , '* @author ' , 10 ) === 0 && $ propertyPosition === false ) { $ propertyPosition = $ i - 1 ; $ propertyPart = false ; } if ( $ propertyPart ) { unset ( $ lines [ $ i ] ) ; } } if ( $ propertyPosition === false ) { $ propertyPosition = \ count ( $ lines ) - 2 ; } $ finalDoc = '' ; foreach ( $ lines as $ i => $ line ) { $ finalDoc .= $ line . "\n" ; if ( $ i == $ propertyPosition ) { $ finalDoc .= $ properties ; } } return $ finalDoc ; }
8918	public function messages ( $ options ) { $ params = [ 'query' => [ 'apikey' => $ this -> apikey , 'limit' => 100 , 'page' => 1 ] ] ; if ( array_key_exists ( 'limit' , $ options ) ) { $ params [ 'query' ] [ 'limit' ] = $ options [ 'limit' ] ; } if ( array_key_exists ( 'page' , $ options ) ) { $ params [ 'query' ] [ 'page' ] = $ options [ 'page' ] ; } if ( array_key_exists ( 'startDate' , $ options ) ) { $ params [ 'query' ] [ 'startDate' ] = $ options [ 'startDate' ] ; } if ( array_key_exists ( 'endDate' , $ options ) ) { $ params [ 'query' ] [ 'endDate' ] = $ options [ 'endDate' ] ; } if ( array_key_exists ( 'status' , $ options ) ) { $ params [ 'query' ] [ 'status' ] = $ options [ 'status' ] ; } if ( array_key_exists ( 'network' , $ options ) ) { $ params [ 'query' ] [ 'network' ] = $ options [ 'network' ] ; } if ( array_key_exists ( 'sendername' , $ options ) ) { $ params [ 'query' ] [ 'sendername' ] = $ options [ 'sendername' ] ; } $ response = $ this -> client -> get ( 'messages' , $ params ) ; return $ response -> getBody ( ) ; }
8229	public static function readFile ( $ fileName , $ options = [ ] ) { $ reader = new File \ FileReader ( $ fileName , $ options ) ; $ success = true ; $ contents = null ; try { $ reader -> open ( ) ; $ contents = $ reader -> read ( ) ; } catch ( \ RuntimeException $ e ) { self :: $ lastError = $ e -> getMessage ( ) ; $ success = false ; } try { $ reader -> close ( ) ; } catch ( \ RuntimeException $ e ) { self :: $ lastError = $ e -> getMessage ( ) ; $ success = false ; } return ( $ success ) ? $ contents : false ; }
2042	public static function validateSymlink ( string $ target , string $ link , string $ rootDir ) : void { if ( '' === $ target ) { throw new \ InvalidArgumentException ( 'The symlink target must not be empty.' ) ; } if ( '' === $ link ) { throw new \ InvalidArgumentException ( 'The symlink path must not be empty.' ) ; } if ( false !== strpos ( $ link , '../' ) ) { throw new \ InvalidArgumentException ( 'The symlink path must not be relative.' ) ; } $ fs = new Filesystem ( ) ; if ( $ fs -> exists ( $ rootDir . '/' . $ link ) && ! is_link ( $ rootDir . '/' . $ link ) ) { throw new \ LogicException ( sprintf ( 'The path "%s" exists and is not a symlink.' , $ link ) ) ; } }
9149	public function markAsUnread ( $ uid ) { if ( ! $ object = $ this -> model -> find ( $ uid ) ) { abort ( 404 ) ; } $ this -> authorize ( 'update' , $ object ) ; if ( ! is_null ( $ object -> read_at ) ) { $ object -> forceFill ( [ 'read_at' => null ] ) -> save ( ) ; } \ Cache :: tags ( 'response' ) -> flush ( ) ; return $ this -> successJsonResponse ( ) ; }
3174	private function getTimeConstraint ( TestSession $ session , QtiComponent $ source , $ navigationMode ) { $ constraint = new QtiTimeConstraint ( $ source , $ session -> getTimerDuration ( $ source -> getIdentifier ( ) ) , $ navigationMode , true , true , $ session -> getTimerTarget ( ) ) ; $ constraint -> setTimer ( $ session -> getTimer ( ) ) ; return $ constraint ; }
8030	public function takeFreeProcess ( ) { if ( $ this -> getFreeProcessesCount ( ) === 0 ) { return NULL ; } $ freePid = array_shift ( $ this -> freeProcessIds ) ; if ( $ freePid === NULL ) { return NULL ; } return $ this -> getProcessDetails ( $ freePid ) ; }
587	protected function buildTarget ( $ target , $ type , $ bundles ) { $ inputFiles = [ ] ; foreach ( $ target -> depends as $ name ) { if ( isset ( $ bundles [ $ name ] ) ) { if ( ! $ this -> isBundleExternal ( $ bundles [ $ name ] ) ) { foreach ( $ bundles [ $ name ] -> $ type as $ file ) { if ( is_array ( $ file ) ) { $ inputFiles [ ] = $ bundles [ $ name ] -> basePath . '/' . $ file [ 0 ] ; } else { $ inputFiles [ ] = $ bundles [ $ name ] -> basePath . '/' . $ file ; } } } } else { throw new Exception ( "Unknown bundle: '{$name}'" ) ; } } if ( empty ( $ inputFiles ) ) { $ target -> $ type = [ ] ; } else { FileHelper :: createDirectory ( $ target -> basePath , $ this -> getAssetManager ( ) -> dirMode ) ; $ tempFile = $ target -> basePath . '/' . strtr ( $ target -> $ type , [ '{hash}' => 'temp' ] ) ; if ( $ type === 'js' ) { $ this -> compressJsFiles ( $ inputFiles , $ tempFile ) ; } else { $ this -> compressCssFiles ( $ inputFiles , $ tempFile ) ; } $ targetFile = strtr ( $ target -> $ type , [ '{hash}' => md5_file ( $ tempFile ) ] ) ; $ outputFile = $ target -> basePath . '/' . $ targetFile ; rename ( $ tempFile , $ outputFile ) ; $ target -> $ type = [ $ targetFile ] ; } }
7422	protected function renderAlertBlock ( ) { $ session = \ Yii :: $ app -> session ; $ flashes = $ session -> getAllFlashes ( ) ; $ alertContainerOptions = [ 'style' => 'max-width:400px' ] ; if ( count ( $ flashes ) === 0 ) { Html :: addCssStyle ( $ alertContainerOptions , 'display:none;' ) ; } $ out = Html :: beginTag ( 'div' , $ alertContainerOptions ) ; foreach ( $ flashes as $ type => $ message ) { if ( is_array ( $ message ) ) { $ message = implode ( '<br>' , $ message ) ; } $ alertWidgetOptions = [ ] ; $ alertWidgetOptions [ 'body' ] = $ message ; $ alertWidgetOptions [ 'options' ] = [ 'class' => [ 'alert' , 'alert-success' ] , 'style' => 'padding-left:10px;padding-right:10px;' ] ; $ out .= "\n" . Alert :: widget ( $ alertWidgetOptions ) ; $ session -> removeFlash ( $ type ) ; } $ out .= "\n</div>" ; return $ this -> alertBlockAddon . $ out ; }
11848	private function checkReadOnly ( ) { if ( true === $ this -> _readOnly ) { $ this -> _pushError ( '' , self :: ERR_READ_ONLY , 'This row has been marked read-only' ) ; return false ; } return true ; }
5122	private function setAuthorizationHeader ( string $ accessToken ) : self { $ this -> accessToken = $ accessToken ; $ this -> options -> set ( 'default_headers' , array_merge ( $ this -> options -> get ( 'default_headers' ) , [ 'Authorization' => 'Bearer ' . $ accessToken , ] ) ) ; return $ this ; }
26	protected function getRemoteContents ( $ originUrl , $ fileUrl , $ context , array & $ responseHeaders = null ) { try { $ e = null ; $ result = file_get_contents ( $ fileUrl , false , $ context ) ; } catch ( \ Throwable $ e ) { } catch ( \ Exception $ e ) { } $ responseHeaders = isset ( $ http_response_header ) ? $ http_response_header : array ( ) ; if ( null !== $ e ) { throw $ e ; } return $ result ; }
6400	public static function init ( ) : void { self :: $ classMap = new CallbackLazyMap ( function ( $ className ) { $ trimmedClassName = trim ( $ className , '\\' ) ; return $ trimmedClassName === $ className ? new ObjectClass ( $ className ) : ObjectClass :: $ classMap -> $ trimmedClassName ; } ) ; }
6660	protected function getControllers ( ) { if ( ! $ this -> controllersCache ) { $ isHidden = $ this -> getControllerMethod ( 'isMethodHidden' ) ; $ methods = $ this -> reflectedController -> getMethods ( \ ReflectionMethod :: IS_PUBLIC ) ; $ controllers = [ ] ; foreach ( $ methods as $ method ) { if ( preg_match ( '/(\w+)Controller$/' , $ method -> getName ( ) , $ parts ) ) { if ( ! $ isHidden ( $ method -> getName ( ) ) ) { $ controllers [ ] = $ this -> camelcaseToHyphenated ( $ parts [ 1 ] ) ; } } } $ this -> controllersCache = $ controllers ; } return $ this -> controllersCache ; }
6301	protected function getMain ( $ name = 'default' ) { $ this -> events -> fire ( 'navigation.main' , [ [ 'name' => $ name ] ] ) ; if ( $ name !== 'default' && ! array_key_exists ( $ name , $ this -> main ) ) { $ name = 'default' ; } if ( ! array_key_exists ( $ name , $ this -> main ) ) { $ this -> main [ $ name ] = [ ] ; } $ nav = $ this -> active ( $ this -> main [ $ name ] ) ; return $ this -> process ( $ nav ) ; }
10379	protected static function is_modified_file ( $ filepath ) { $ actual = filemtime ( $ filepath ) ; $ last = isset ( self :: $ files [ $ filepath ] ) ? self :: $ files [ $ filepath ] : 0 ; if ( $ actual !== $ last ) { self :: $ files [ $ filepath ] = $ actual ; self :: $ changes = true ; return self :: $ changes ; } return false ; }
11810	protected function loadForeignObject ( ) { if ( $ this -> _isLoadingForeignObject ) { throw new RecursionException ( 'Ran into recursion while loading foreign object' ) ; } $ this -> _isLoadingForeignObject = true ; if ( isset ( $ this -> deferredModel ) && ( $ attributes = $ this -> deferredModel -> attributes ) ) { $ this -> foreignObject = $ this -> dataSource -> createModel ( $ this -> deferredModel -> id , $ this -> deferredModel -> attributes ) ; } $ this -> _isLoadingForeignObject = false ; }
3010	public function setConsumer ( $ consumerKey , $ consumerSecret ) { $ this -> apiKey = $ consumerKey ; $ this -> requestHandler -> setConsumer ( $ consumerKey , $ consumerSecret ) ; }
7453	protected function renderLTR ( ) : string { $ trail = '' ; if ( $ this -> before ) { $ trail .= '<span class="before">' . $ this -> before . '</span> ' ; } $ trail .= \ join ( ' <span class="sep delimiter">' . $ this -> delimiter . '</span> ' , $ this -> links ) ; if ( $ this -> after ) { $ trail .= ' <span class="after">' . $ this -> after . '</span>' ; } return $ trail ; }
12894	public function close ( $ account , $ openId ) { $ params = [ 'kf_account' => $ account , 'openid' => $ openId , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_CLOSE , $ params ] ) ; }
10140	private function readRecordData ( $ data , $ pos , $ len ) { $ data = substr ( $ data , $ pos , $ len ) ; if ( $ this -> encryption == self :: MS_BIFF_CRYPTO_NONE || $ pos < $ this -> encryptionStartPos ) { return $ data ; } $ recordData = '' ; if ( $ this -> encryption == self :: MS_BIFF_CRYPTO_RC4 ) { $ oldBlock = floor ( $ this -> rc4Pos / self :: REKEY_BLOCK ) ; $ block = floor ( $ pos / self :: REKEY_BLOCK ) ; $ endBlock = floor ( ( $ pos + $ len ) / self :: REKEY_BLOCK ) ; if ( $ block != $ oldBlock || $ pos < $ this -> rc4Pos || ! $ this -> rc4Key ) { $ this -> rc4Key = $ this -> makeKey ( $ block , $ this -> md5Ctxt ) ; $ step = $ pos % self :: REKEY_BLOCK ; } else { $ step = $ pos - $ this -> rc4Pos ; } $ this -> rc4Key -> RC4 ( str_repeat ( "\0" , $ step ) ) ; while ( $ block != $ endBlock ) { $ step = self :: REKEY_BLOCK - ( $ pos % self :: REKEY_BLOCK ) ; $ recordData .= $ this -> rc4Key -> RC4 ( substr ( $ data , 0 , $ step ) ) ; $ data = substr ( $ data , $ step ) ; $ pos += $ step ; $ len -= $ step ; ++ $ block ; $ this -> rc4Key = $ this -> makeKey ( $ block , $ this -> md5Ctxt ) ; } $ recordData .= $ this -> rc4Key -> RC4 ( substr ( $ data , 0 , $ len ) ) ; $ this -> rc4Pos = $ pos + $ len ; } elseif ( $ this -> encryption == self :: MS_BIFF_CRYPTO_XOR ) { throw new Exception ( 'XOr encryption not supported' ) ; } return $ recordData ; }
8442	public function render ( array $ args , bool $ prettyPrint = null ) { header ( 'Content-type: application/json' ) ; if ( ( constant ( 'STRAY_ENV' ) === 'development' && $ prettyPrint !== false ) || $ prettyPrint === true ) { return ( string ) json_encode ( $ args , JSON_PRETTY_PRINT ) ; } return ( string ) json_encode ( $ args ) ; }
11237	public function saveUrl ( $ url = false , $ append = '' ) { if ( $ url == false ) { $ url = '//' . $ this -> config [ 'base_url' ] . $ _SERVER [ 'REQUEST_URI' ] ; } $ this -> saved = $ this -> getRedirect ( $ url ) . $ append ; $ this -> session -> savedUrl = $ this -> saved ; }
12830	public function compileSource ( $ source ) { $ source = $ this -> stripComments ( $ source ) ; $ source = $ this -> saveLiterals ( $ source ) ; $ result = preg_replace_callback ( '#' . $ this -> _config [ 'tokenStart' ] . '(.*)' . $ this -> _config [ 'tokenEnd' ] . '#smU' , array ( $ this , 'onTokenFound' ) , $ source ) ; $ result = $ this -> restoreLiterals ( $ result ) ; return $ result ; }
9728	function fromXML ( $ xmlElement ) { if ( isset ( $ xmlElement -> minutes ) ) $ this -> minutes = $ xmlElement -> minutes ; if ( isset ( $ xmlElement -> hours ) ) $ this -> hours = $ xmlElement -> hours ; if ( isset ( $ xmlElement -> state ) ) $ this -> state = $ xmlElement -> state ; if ( isset ( $ xmlElement -> date ) ) $ this -> date = $ xmlElement -> date ; }
1217	public static function slice ( $ value , $ start = null , $ stop = null , $ step = 1 ) { if ( ! Utils :: isArray ( $ value ) && ! is_string ( $ value ) ) { throw new \ InvalidArgumentException ( 'Expects string or array' ) ; } return self :: sliceIndices ( $ value , $ start , $ stop , $ step ) ; }
6206	public function onShutdown ( ) { if ( self :: $ instance == null ) { return ; } self :: $ instance = null ; if ( ! $ error = error_get_last ( ) ) { return ; } if ( ! $ this -> shouldNotifyError ( $ error [ 'type' ] , $ error [ 'message' ] , $ error [ 'file' ] , $ error [ 'line' ] ) ) { return ; } $ backtrace = array ( array ( 'file' => $ error [ 'file' ] , 'line' => $ error [ 'line' ] , 'function' => '' , 'args' => array ( ) , ) ) ; $ this -> airbrakeClient -> notifyOnError ( '[Improper Shutdown] ' . $ error [ 'message' ] , $ backtrace ) ; }
6207	public function set ( $ key , $ value ) { if ( $ this -> exists ( $ key ) ) { $ this -> dataStore [ $ key ] = $ value ; } }
2193	protected function sendActivationMail ( $ arrData ) { $ optIn = System :: getContainer ( ) -> get ( 'contao.opt-in' ) ; $ optInToken = $ optIn -> create ( 'reg' , $ arrData [ 'email' ] , array ( 'tl_member' => array ( $ arrData [ 'id' ] ) ) ) ; $ arrTokenData = $ arrData ; $ arrTokenData [ 'activation' ] = $ optInToken -> getIdentifier ( ) ; $ arrTokenData [ 'domain' ] = Idna :: decode ( Environment :: get ( 'host' ) ) ; $ arrTokenData [ 'link' ] = Idna :: decode ( Environment :: get ( 'base' ) ) . Environment :: get ( 'request' ) . ( ( strpos ( Environment :: get ( 'request' ) , '?' ) !== false ) ? '&' : '?' ) . 'token=' . $ optInToken -> getIdentifier ( ) ; $ arrTokenData [ 'channels' ] = '' ; $ bundles = System :: getContainer ( ) -> getParameter ( 'kernel.bundles' ) ; if ( isset ( $ bundles [ 'ContaoNewsletterBundle' ] ) ) { if ( ! \ is_array ( $ arrData [ 'newsletter' ] ) ) { if ( $ arrData [ 'newsletter' ] != '' ) { $ arrData [ 'newsletter' ] = array ( $ arrData [ 'newsletter' ] ) ; } else { $ arrData [ 'newsletter' ] = array ( ) ; } } if ( ! empty ( $ arrData [ 'newsletter' ] ) ) { $ objChannels = NewsletterChannelModel :: findByIds ( $ arrData [ 'newsletter' ] ) ; if ( $ objChannels !== null ) { $ arrTokenData [ 'channels' ] = implode ( "\n" , $ objChannels -> fetchEach ( 'title' ) ) ; } } } $ arrTokenData [ 'channel' ] = $ arrTokenData [ 'channels' ] ; $ optInToken -> send ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'emailSubject' ] , Idna :: decode ( Environment :: get ( 'host' ) ) ) , StringUtil :: parseSimpleTokens ( $ this -> reg_text , $ arrTokenData ) ) ; }
11803	public static function importFromApp ( $ path ) { $ importPath = APPS_ROOT . DS . $ path . '.php' ; if ( file_exists ( $ importPath ) ) { include_once $ importPath ; } else { throw new SetupException ( "The object to import ($path) not exists." ) ; } }
7209	public static function createFinalFromGross ( Amount $ gross ) : Amount { $ final = new Amount ( $ gross -> getCurrency ( ) , $ gross -> getBase ( ) , $ gross -> getBase ( ) , 0 , $ gross -> getBase ( ) , $ gross -> getTax ( ) , $ gross -> getTotal ( ) ) ; foreach ( $ gross -> getTaxAdjustments ( ) as $ t ) { $ final -> addTaxAdjustment ( $ t ) ; } return $ final ; }
8014	protected function prepareCommand ( $ filename , $ saveToFile , $ pdfIsTemp = false ) { $ resultIsTemp = false ; $ command = new Command ( ) ; $ command -> setPdfFile ( $ filename , $ pdfIsTemp ) ; if ( $ saveToFile === null ) { $ saveToFile = tempnam ( sys_get_temp_dir ( ) , 'pdfbox' ) ; $ resultIsTemp = true ; } $ command -> setTextFile ( $ saveToFile , $ resultIsTemp ) ; return $ command ; }
2058	public function makeRedirectPageMandatory ( Contao \ DataContainer $ dc ) { $ objPage = $ this -> Database -> prepare ( "SELECT * FROM " . $ dc -> table . " WHERE id=?" ) -> limit ( 1 ) -> execute ( $ dc -> id ) ; if ( $ objPage -> numRows && $ objPage -> type == 'logout' ) { $ GLOBALS [ 'TL_DCA' ] [ 'tl_page' ] [ 'fields' ] [ 'jumpTo' ] [ 'eval' ] [ 'mandatory' ] = true ; } }
175	public static function remove ( & $ array , $ key , $ default = null ) { if ( is_array ( $ array ) && ( isset ( $ array [ $ key ] ) || array_key_exists ( $ key , $ array ) ) ) { $ value = $ array [ $ key ] ; unset ( $ array [ $ key ] ) ; return $ value ; } return $ default ; }
1148	protected function getAttributeName ( $ attribute ) { $ attributeArray = explode ( '.' , $ attribute ) ; if ( count ( $ attributeArray ) > 1 ) { return $ attributeArray [ 0 ] . '[' . implode ( '][' , array_slice ( $ attributeArray , 1 ) ) . ']' ; } return $ attribute ; }
10645	public function bindInstance ( object $ object ) : Binding { return $ this -> bind ( \ get_class ( $ object ) ) -> instance ( $ object ) ; }
6535	protected function hydrate ( $ propertyName ) { if ( isset ( $ this -> yuccaMappingManager ) && ( false === isset ( $ this -> yuccaInitialized [ $ propertyName ] ) ) && ( false === empty ( $ this -> yuccaIdentifier ) ) ) { $ values = $ this -> yuccaMappingManager -> getMapper ( get_class ( $ this ) ) -> load ( $ this -> yuccaIdentifier , $ propertyName , $ this -> yuccaShardingKey ) ; foreach ( $ values as $ property => $ value ) { if ( false === isset ( $ this -> yuccaInitialized [ $ property ] ) ) { $ this -> $ property = $ value ; $ this -> yuccaInitialized [ $ property ] = true ; } } } $ this -> yuccaInitialized [ $ propertyName ] = true ; return $ this ; }
3931	private function getOrCreateProperty ( PropertiesDefinitionInterface $ definition , $ propName ) { if ( $ definition -> hasProperty ( $ propName ) ) { return $ definition -> getProperty ( $ propName ) ; } $ property = new DefaultProperty ( $ propName ) ; $ definition -> addProperty ( $ property ) ; return $ property ; }
1310	public static function categoriesMenu ( $ categories ) { $ menu = '<ul class="nav nav-pills nav-stacked">' ; foreach ( $ categories as $ category ) { $ menu .= '<li>' ; $ menu .= '<a href="/' . config ( 'chatter.routes.home' ) . '/' . config ( 'chatter.routes.category' ) . '/' . $ category [ 'slug' ] . '">' ; $ menu .= '<div class="chatter-box" style="background-color:' . $ category [ 'color' ] . '"></div>' ; $ menu .= $ category [ 'name' ] . '</a>' ; if ( count ( $ category [ 'parents' ] ) ) { $ menu .= static :: categoriesMenu ( $ category [ 'parents' ] ) ; } $ menu .= '</li>' ; } $ menu .= '</ul>' ; return $ menu ; }
5468	public function addHeaders ( $ request , $ url ) { if ( $ url -> getUsername ( ) && $ url -> getPassword ( ) ) { $ username = $ url -> getUsername ( ) ; $ password = $ url -> getPassword ( ) ; } elseif ( $ realm = $ this -> findRealmFromUrl ( $ url ) ) { $ username = $ realm -> getUsername ( ) ; $ password = $ realm -> getPassword ( ) ; } else { return ; } $ this -> addBasicHeaders ( $ request , $ username , $ password ) ; }
2894	public function init ( Zend_Db_Profiler_Query $ profilerQuery , $ stacktrace = '' ) { $ this -> queryType = $ profilerQuery -> getQueryType ( ) ; $ this -> query = $ profilerQuery -> getQuery ( ) ; $ this -> queryParams = $ profilerQuery -> getQueryParams ( ) ; $ this -> elapsedSecs = $ profilerQuery -> getElapsedSecs ( ) ; $ this -> stacktrace = $ stacktrace ; }
56	public function update ( PackageInterface $ initial , PackageInterface $ target , $ targetDir ) { $ downloader = $ this -> getDownloaderForInstalledPackage ( $ initial ) ; if ( ! $ downloader ) { return ; } $ installationSource = $ initial -> getInstallationSource ( ) ; if ( 'dist' === $ installationSource ) { $ initialType = $ initial -> getDistType ( ) ; $ targetType = $ target -> getDistType ( ) ; } else { $ initialType = $ initial -> getSourceType ( ) ; $ targetType = $ target -> getSourceType ( ) ; } if ( $ target -> isDev ( ) && 'dist' === $ installationSource ) { $ downloader -> remove ( $ initial , $ targetDir ) ; $ this -> download ( $ target , $ targetDir ) ; return ; } if ( $ initialType === $ targetType ) { $ target -> setInstallationSource ( $ installationSource ) ; try { $ downloader -> update ( $ initial , $ target , $ targetDir ) ; return ; } catch ( \ RuntimeException $ e ) { if ( ! $ this -> io -> isInteractive ( ) ) { throw $ e ; } $ this -> io -> writeError ( '<error> Update failed (' . $ e -> getMessage ( ) . ')</error>' ) ; if ( ! $ this -> io -> askConfirmation ( ' Would you like to try reinstalling the package instead [<comment>yes</comment>]? ' , true ) ) { throw $ e ; } } } $ downloader -> remove ( $ initial , $ targetDir ) ; $ this -> download ( $ target , $ targetDir , 'source' === $ installationSource ) ; }
3828	protected function addUrlParameter ( $ url , $ name , $ value ) { @ trigger_error ( sprintf ( '"%1$s" has been deprecated in favor of the "FilterUrlBuilder"' , __METHOD__ ) , E_USER_DEPRECATED ) ; if ( is_array ( $ value ) ) { $ value = implode ( ',' , array_filter ( $ value ) ) ; } $ value = str_replace ( '%' , '%%' , urlencode ( $ value ) ) ; if ( empty ( $ value ) ) { return $ url ; } if ( $ name !== 'auto_item' ) { $ url .= '/' . $ name . '/' . $ value ; } else { $ url = '/' . $ value . $ url ; } return $ url ; }
10292	public static function setDefaultTimezone ( $ timeZone ) { if ( $ timeZone = self :: validateTimeZone ( $ timeZone ) ) { self :: $ defaultTimeZone = $ timeZone ; return true ; } return false ; }
12701	public function setEditorConfig ( $ config ) { if ( $ config instanceof Traversable ) { $ config = ArrayUtils :: iteratorToArray ( $ config ) ; } if ( ! is_array ( $ config ) ) { throw new InvalidArgumentException ( 'The options parameter must be an array or a Traversable' ) ; } $ this -> editorConfig = $ config ; return $ this ; }
10395	protected function getShopIds ( ) { $ shopIds = [ ] ; try { $ shops = $ this -> container -> getParameter ( 'ongr_connections.shops' ) ; } catch ( InvalidArgumentException $ e ) { $ shops = [ ] ; } foreach ( $ shops as $ shop ) { $ shopIds [ ] = $ shop [ 'shop_id' ] ; } return $ shopIds ; }
9028	protected function randomizeSamples ( $ referencePrefix , array $ samples , $ limit = 1 ) { $ sample = array_rand ( $ samples , $ limit ) ; if ( 1 === $ limit ) { $ referenceName = sprintf ( '%s_%s' , $ referencePrefix , $ samples [ $ sample ] ) ; return $ this -> getReference ( $ referenceName ) ; } else { $ collection = new ArrayCollection ( ) ; foreach ( $ sample as $ index ) { $ referenceName = sprintf ( '%s_%s' , $ referencePrefix , $ samples [ $ index ] ) ; $ collection -> add ( $ this -> getReference ( $ referenceName ) ) ; } return $ collection ; } }
12525	static function release ( $ token , $ mode , $ opts = array ( ) ) { clearstatcache ( ) ; $ lockDir = self :: lockDir ( $ opts ) ; if ( $ mode == LOCK_EX ) { $ wLockFile = "$lockDir/{$token}_W.lock" ; if ( is_file ( $ wLockFile ) && ! unlink ( $ wLockFile ) ) { pake_echo_error ( "Could not remove W lock file '$wLockFile'" ) ; } return ; } $ rLockFile = "$lockDir/{$token}_R/" . getmypid ( ) . ".lock" ; if ( is_file ( $ rLockFile ) && ! unlink ( $ rLockFile ) ) { pake_echo_error ( "Could not remove R lock file '$rLockFile'" ) ; } }
8064	public function getFreeAndBusyWorkers ( ) { $ free = $ this -> getFreeWorkers ( ) ; return array ( 'free' => $ free , 'busy' => $ this -> workerPoolSize - $ free , 'total' => $ this -> workerPoolSize ) ; }
6063	public function listFolders ( $ id , $ depth = 0 , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'depth' => $ depth ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/media/' . $ id . '/folders' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new FolderResponse ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
12020	function addSetAPIMethod ( ) { $ methodGenerator = new MethodGenerator ( 'setAPI' ) ; $ methodGenerator -> setBody ( '$this->api = $api;' ) ; $ parameterGenerator = new ParameterGenerator ( 'api' , $ this -> apiClassname ) ; $ methodGenerator -> setParameter ( $ parameterGenerator ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; }
10746	protected function sendJson ( Response $ response , $ payload ) : Response { $ response -> getBody ( ) -> write ( json_encode ( $ payload ) ) ; return $ response -> withHeader ( 'Content-Type' , 'application/json' ) ; }
12441	public function attach ( $ key , $ instance , $ type = self :: OBJECT ) { switch ( $ type ) { case self :: OBJECT : case self :: CACHE : if ( ! is_object ( $ instance ) ) { throw new \ LogicException ( 'Instance is not an object!' ) ; } break ; case self :: DATABASE : if ( ! ( $ instance instanceof \ PDO ) ) { throw new \ LogicException ( ) ; } break ; } if ( isset ( $ this -> instances [ $ key ] ) ) { return $ this ; } $ this -> instances [ $ key ] = $ instance ; return $ this ; }
3145	public function pause ( RunnerServiceContext $ context ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ context -> getTestSession ( ) -> suspend ( ) ; $ this -> persist ( $ context ) ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'pause' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } return true ; }
8919	protected function parseAuthority ( $ authority , & $ out ) { if ( ! empty ( $ authority ) ) { $ out [ 'id' ] = $ authority ; if ( preg_match ( '/\((.*?)\)(.*)/' , $ authority , $ matches ) ) { $ out [ 'vocabulary' ] = $ matches [ 1 ] ; $ out [ 'id' ] = $ matches [ 2 ] ; } } }
9794	public function getDataValidation ( ) { if ( ! isset ( $ this -> parent ) ) { throw new Exception ( 'Cannot get data validation for cell that is not bound to a worksheet' ) ; } return $ this -> getWorksheet ( ) -> getDataValidation ( $ this -> getCoordinate ( ) ) ; }
6951	private function getBaseQueryBuilder ( ) { $ qb = $ this -> getQueryBuilder ( 'r' , 'r.id' ) ; return $ qb -> andWhere ( $ qb -> expr ( ) -> orX ( $ qb -> expr ( ) -> isMemberOf ( ':country' , 'r.countries' ) , 'r.countries IS EMPTY' ) ) -> addOrderBy ( 'r.priority' , 'DESC' ) ; }
7369	private function updatePrice ( StockUnitInterface $ stockUnit ) { $ price = null ; if ( null !== $ item = $ stockUnit -> getSupplierOrderItem ( ) ) { if ( null === $ order = $ item -> getOrder ( ) ) { throw new StockLogicException ( "Supplier order item's order must be set at this point." ) ; } $ currency = $ order -> getCurrency ( ) -> getCode ( ) ; $ date = $ order -> getPaymentDate ( ) ; if ( $ date > new \ DateTime ( ) ) { $ date = null ; } $ price = $ this -> currencyConverter -> convert ( $ item -> getNetPrice ( ) , $ currency , null , $ date ) ; } if ( 0 !== Money :: compare ( $ stockUnit -> getNetPrice ( ) , $ price , $ this -> currencyConverter -> getDefaultCurrency ( ) ) ) { $ stockUnit -> setNetPrice ( $ price ) ; return true ; } return false ; }
10903	public function delete ( ) : bool { return ( bool ) $ this -> medoo -> delete ( $ this -> getTable ( ) , [ 'id' => $ this -> getId ( ) ] ) ; }
10710	public function getById ( $ id , $ columns = [ '*' ] ) { try { $ results = $ this -> getQuery ( ) -> findOrFail ( $ id , $ columns ) ; } catch ( ModelNotFoundException $ e ) { throw new NotFoundRepositoryException ( $ e ) ; } return $ this -> returnResults ( $ results ) ; }
5540	public function setFrameFocusByIndex ( $ choice ) { if ( is_integer ( $ this -> focus ) ) { if ( $ this -> frames [ $ this -> focus ] -> hasFrames ( ) ) { return $ this -> frames [ $ this -> focus ] -> setFrameFocusByIndex ( $ choice ) ; } } if ( ( $ choice < 1 ) || ( $ choice > count ( $ this -> frames ) ) ) { return false ; } $ this -> focus = $ choice - 1 ; return true ; }
9586	public function scaffoldFormField ( $ title = null , $ params = null ) { $ field = new ExternalURLField ( $ this -> name , $ title ) ; $ field -> setMaxLength ( $ this -> getSize ( ) ) ; return $ field ; }
5862	protected function expandValuesInRuleset ( array $ ruleset ) { $ values = [ ] ; foreach ( $ ruleset as $ key => $ value ) { switch ( $ key ) { case 'usergroup' : $ value = GeneralUtility :: trimExplode ( ',' , $ value , true ) ; break ; case 'directories' : $ values [ 'directories_config' ] = '' ; $ value = GeneralUtility :: trimExplode ( ',' , $ value , true ) ; foreach ( $ value as & $ directory ) { $ directory = rtrim ( $ directory , '/' ) . '/' ; if ( ! empty ( $ values [ 'directories_config' ] ) ) { $ values [ 'directories_config' ] .= ',' ; } $ values [ 'directories_config' ] .= $ directory ; $ directory = $ this -> getDirectoryPattern ( $ directory ) ; } if ( count ( $ value ) == 0 ) { $ value = '' ; } break ; case 'file_types' : $ value = GeneralUtility :: trimExplode ( ',' , $ value , true ) ; if ( count ( $ value ) == 0 ) { $ value = '' ; } break ; case 'threshold' : if ( ! is_numeric ( $ value ) ) { $ unit = strtoupper ( substr ( $ value , - 1 ) ) ; $ factor = 1 * ( $ unit === 'K' ? 1024 : ( $ unit === 'M' ? 1024 * 1024 : 0 ) ) ; $ value = intval ( trim ( substr ( $ value , 0 , strlen ( $ value ) - 1 ) ) ) * $ factor ; } case 'max_width' : case 'max_height' : if ( $ value <= 0 ) { $ value = '' ; } break ; case 'max_size' : if ( ! is_numeric ( $ value ) ) { $ unit = strtoupper ( substr ( $ value , - 1 ) ) ; $ factor = 1 * ( $ unit === 'M' ? 1000000 : 1 ) ; $ value = intval ( trim ( substr ( $ value , 0 , strlen ( $ value ) - 1 ) ) ) * $ factor ; } break ; case 'conversion_mapping' : if ( strpos ( $ value , CRLF ) !== false ) { $ mapping = GeneralUtility :: trimExplode ( CRLF , $ value , true ) ; } else { $ mapping = GeneralUtility :: trimExplode ( ',' , $ value , true ) ; } if ( count ( $ mapping ) > 0 ) { $ value = $ this -> expandConversionMapping ( $ mapping ) ; } else { $ value = '' ; } break ; } $ values [ $ key ] = $ value ; } return $ values ; }
12150	public function checkReservedCodes ( ) { $ reserved = $ this -> getReservedCodes ( ) ; foreach ( $ reserved as $ factoryClass => $ reservedForFactory ) { foreach ( $ reserved as $ checkInFactory => $ reservedInCheckFactory ) { if ( $ checkInFactory == $ factoryClass ) { continue ; } if ( $ reservedInCheckFactory [ 0 ] >= $ reservedForFactory [ 0 ] && $ reservedInCheckFactory [ 0 ] <= $ reservedForFactory [ 1 ] ) { throw new \ RuntimeException ( sprintf ( 'The reserved codes for factory "%s" [%d - %d] superimposed on "%s" factory [%d - %d].' , $ checkInFactory , $ reservedInCheckFactory [ 0 ] , $ reservedInCheckFactory [ 1 ] , $ factoryClass , $ reservedForFactory [ 0 ] , $ reservedForFactory [ 1 ] ) ) ; } if ( $ reservedInCheckFactory [ 1 ] >= $ reservedForFactory [ 0 ] && $ reservedInCheckFactory [ 1 ] <= $ reservedForFactory [ 1 ] ) { throw new \ RuntimeException ( sprintf ( 'The reserved codes for factory "%s" [%d - %d] superimposed on "%s" factory [%d - %d].' , $ checkInFactory , $ reservedInCheckFactory [ 0 ] , $ reservedInCheckFactory [ 1 ] , $ factoryClass , $ reservedForFactory [ 0 ] , $ reservedForFactory [ 1 ] ) ) ; } } } }
2913	public function formatMemorySize ( $ size , $ precision = 2 ) { $ sizes = array ( " Bytes" , " KB" , " MB" , " GB" , " TB" , " PB" , " EB" , " ZB" , " YB" ) ; if ( $ size == 0 ) { return $ this -> __ ( 'n/a' ) ; } else { $ value = round ( $ size / pow ( 1000 , ( $ i = floor ( log ( $ size , 1000 ) ) ) ) , $ precision ) ; $ unitIndex = ( int ) $ i ; return $ this -> __ ( '%s%s' , $ this -> formatNumber ( $ value , $ precision ) , $ sizes [ $ unitIndex ] ) ; } }
11947	public function getPriority ( ) { if ( isset ( $ this -> object -> singleWidget ) ) { if ( isset ( $ this -> object -> singleWidget ) && isset ( $ this -> object -> singleWidget -> content -> priorityAdjust ) ) { return $ this -> _priority + $ this -> object -> singleWidget -> content -> priorityAdjust ; } } return $ this -> _priority ; }
6469	public function parseAcceptHeader ( HttpHeaders $ headers ) : array { $ headerValues = [ ] ; if ( ! $ headers -> tryGet ( 'Accept' , $ headerValues ) ) { return [ ] ; } $ parsedHeaderValues = [ ] ; $ numHeaderValues = count ( $ headerValues ) ; for ( $ i = 0 ; $ i < $ numHeaderValues ; $ i ++ ) { $ parsedHeaderParameters = $ this -> parseParameters ( $ headers , 'Accept' , $ i ) ; $ mediaType = $ parsedHeaderParameters -> getKeys ( ) [ 0 ] ; $ parsedHeaderValues [ ] = new AcceptMediaTypeHeaderValue ( $ mediaType , $ parsedHeaderParameters ) ; } return $ parsedHeaderValues ; }
6944	protected function registerClassInstanceSingleton ( $ singletonName , $ classNameOrInstance = null ) { if ( empty ( $ classNameOrInstance ) ) { $ classNameOrInstance = $ singletonName ; } $ this -> app -> singleton ( $ singletonName , function ( ) use ( $ classNameOrInstance ) { return is_string ( $ classNameOrInstance ) ? $ classNameOrInstance :: getInstance ( ) : $ classNameOrInstance ; } ) ; }
5879	protected static function createIndex ( $ fileName , $ width , $ height ) { $ relativePath = substr ( PathUtility :: dirname ( $ fileName ) , strlen ( PATH_site ) ) ; $ resourceFactory = \ TYPO3 \ CMS \ Core \ Resource \ ResourceFactory :: getInstance ( ) ; $ targetFolder = $ resourceFactory -> retrieveFileOrFolderObject ( $ relativePath ) ; $ targetFilename = PathUtility :: basename ( $ fileName ) ; $ storageConfiguration = $ targetFolder -> getStorage ( ) -> getConfiguration ( ) ; if ( ! isset ( $ storageConfiguration [ 'basePath' ] ) ) { return ; } $ basePath = rtrim ( $ storageConfiguration [ 'basePath' ] , '/' ) . '/' ; $ basePath = GeneralUtility :: getFileAbsFileName ( $ basePath ) ; $ identifier = substr ( $ fileName , strlen ( $ basePath ) - 1 ) ; $ driver = static :: accessProtectedProperty ( $ targetFolder -> getStorage ( ) , 'driver' ) ; $ fileInfo = $ driver -> getFileInfoByIdentifier ( $ identifier ) ; $ file = $ resourceFactory -> createFileObject ( $ fileInfo ) ; $ fileRepository = GeneralUtility :: makeInstance ( \ TYPO3 \ CMS \ Core \ Resource \ FileRepository :: class ) ; $ fileRepository -> addToIndex ( $ file ) ; }
1388	protected function resourceDoesNotSupportClientIds ( string $ type , string $ path = '/data' ) : void { $ this -> errors -> add ( $ this -> translator -> resourceDoesNotSupportClientIds ( $ type , $ path ) ) ; }
5023	public function allowSelectMultipleItems ( ) { $ flagOrCallback = $ this -> allowSelectMultipleItems ; return is_callable ( $ flagOrCallback ) ? ( bool ) $ flagOrCallback ( ) : ( bool ) $ flagOrCallback ; }
10346	protected function getNextFutureTimestamp ( ) { if ( $ this -> yearOffset === 0 ) { $ currentHour = ( int ) date ( 'H' , $ this -> getCurrentTime ( ) ) ; $ currentMinute = ( int ) date ( 'i' , $ this -> getCurrentTime ( ) ) ; $ currentDay = ( int ) date ( 'd' , $ this -> getCurrentTime ( ) ) ; $ currentMonth = ( int ) date ( 'm' , $ this -> getCurrentTime ( ) ) ; } do { $ minute = current ( $ this -> minutes ) ; $ hour = current ( $ this -> hours ) ; $ monthAndDay = current ( $ this -> monthAndDays ) ; $ minute = next ( $ this -> minutes ) ; if ( $ minute === false ) { $ minute = reset ( $ this -> minutes ) ; $ hour = next ( $ this -> hours ) ; if ( $ hour === false ) { $ hour = reset ( $ this -> hours ) ; $ monthAndDay = next ( $ this -> monthAndDays ) ; if ( $ monthAndDay === false ) { $ this -> generateTimetable ( $ this -> yearOffset + 1 ) ; $ minute = reset ( $ this -> minutes ) ; $ hour = reset ( $ this -> hours ) ; $ monthAndDay = reset ( $ this -> monthAndDays ) ; } } } if ( $ this -> yearOffset === 0 ) { if ( ( $ month = ( int ) substr ( $ monthAndDay , 0 , 2 ) ) === $ currentMonth ) { if ( ( $ day = ( int ) substr ( $ monthAndDay , 3 , 2 ) ) < $ currentDay ) { continue ; } if ( $ day === $ currentDay ) { if ( $ hour < $ currentHour ) { continue ; } if ( $ hour === $ currentHour ) { if ( $ minute < $ currentMinute ) { continue ; } } } } } $ nextElement = strtotime ( sprintf ( '%d-%s %02d:%02d:00' , $ this -> year + $ this -> yearOffset , $ monthAndDay , $ hour , $ minute ) ) ; break ; } while ( true ) ; return $ nextElement ; }
11822	public function render_admin_header ( ) { $ page = filter_input ( INPUT_GET , 'page' ) ; if ( $ this -> page != $ page ) { return ; } echo '<style type="text/css">' ; echo $ this -> twig -> render ( 'list_table.css.twig' , array ( ) ) ; echo '</style>' ; }
45	public function dispatchPackageEvent ( $ eventName , $ devMode , PolicyInterface $ policy , Pool $ pool , CompositeRepository $ installedRepo , Request $ request , array $ operations , OperationInterface $ operation ) { return $ this -> doDispatch ( new PackageEvent ( $ eventName , $ this -> composer , $ this -> io , $ devMode , $ policy , $ pool , $ installedRepo , $ request , $ operations , $ operation ) ) ; }
2322	public static function getPixelValue ( $ size ) { @ trigger_error ( 'Using Image::getPixelValue() has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; $ value = preg_replace ( '/[^0-9.-]+/' , '' , $ size ) ; $ unit = preg_replace ( '/[^acehimnprtvwx%]/' , '' , $ size ) ; switch ( $ unit ) { case '' : case 'px' : return ( int ) round ( $ value ) ; break ; case 'em' : return ( int ) round ( $ value * 16 ) ; break ; case 'ex' : return ( int ) round ( $ value * 16 / 2 ) ; break ; case 'pt' : return ( int ) round ( $ value * 16 / 12 ) ; break ; case 'pc' : return ( int ) round ( $ value * 16 ) ; break ; case 'in' : return ( int ) round ( $ value * 16 * 6 ) ; break ; case 'cm' : return ( int ) round ( $ value * 16 / ( 2.54 / 6 ) ) ; break ; case 'mm' : return ( int ) round ( $ value * 16 / ( 25.4 / 6 ) ) ; break ; case '%' : return ( int ) round ( $ value * 16 / 100 ) ; break ; } return 0 ; }
2626	protected function _construct ( ) { $ this -> addColumn ( 'backend_name' , [ 'label' => __ ( 'Name' ) ] ) ; $ this -> _addAfter = false ; $ this -> _template = 'Fastly_Cdn::system/config/form/field/acl.phtml' ; parent :: _construct ( ) ; }
5848	public function populateMetadata ( \ TYPO3 \ CMS \ Core \ Resource \ FileInterface $ file , \ TYPO3 \ CMS \ Core \ Resource \ Folder $ folder ) { if ( is_array ( static :: $ metadata ) && count ( static :: $ metadata ) ) { \ Causal \ ImageAutoresize \ Utility \ FAL :: indexFile ( $ file , '' , '' , static :: $ metadata [ 'COMPUTED' ] [ 'Width' ] , static :: $ metadata [ 'COMPUTED' ] [ 'Height' ] , static :: $ metadata ) ; } }
11827	public function getBom ( $ encoding = 'UTF-8' ) { $ boms = array ( 'UTF-8' => pack ( 'CCC' , 0xef , 0xbb , 0xbf ) , 'UTF-16 Big Endian' => pack ( 'CC' , 0xfe , 0xff ) , 'UTF-16 Little Endian' => pack ( 'CC' , 0xff , 0xfe ) , 'UTF-32 Big Endian' => pack ( 'CCCC' , 0x00 , 0x00 , 0xfe , 0xff ) , 'UTF-32 Little Endian' => pack ( 'CCCC' , 0xff , 0xfe , 0x00 , 0x00 ) , 'SCSU' => pack ( 'CCC' , 0x0e , 0xfe , 0xff ) , 'UTF-7 (1)' => pack ( 'CCCC' , 0x2b , 0x2f , 0x76 , 0x38 ) , 'UTF-7 (2)' => pack ( 'CCCC' , 0x2b , 0x2f , 0x76 , 0x39 ) , 'UTF-7 (3)' => pack ( 'CCCC' , 0x2b , 0x2f , 0x76 , 0x2b ) , 'UTF-7 (4)' => pack ( 'CCCC' , 0x2b , 0x2f , 0x76 , 0x2f ) , 'UTF-7 (5)' => pack ( 'CCCCC' , 0x2b , 0x2f , 0x76 , 0x38 , 0x2d ) , 'UTF-1' => pack ( 'CCC' , 0xF7 , 0x64 , 0x4c ) , 'UTF-EBCDIC' => pack ( 'CCCC' , 0xdd , 0x73 , 0x66 , 0x73 ) , 'BOCU-1' => pack ( 'CCC' , 0xfb , 0xee , 0x28 ) , 'GB-18030' => pack ( 'CCCC' , 0x84 , 0x31 , 0x95 , 0x33 ) , ) ; if ( 'all' == $ encoding ) { return $ boms ; } return $ boms [ $ encoding ] ; }
4874	public function setFormId ( $ formId ) { $ this -> formId = $ formId . '-' ; foreach ( $ this as $ button ) { $ button -> setAttribute ( 'id' , $ this -> formId . $ button -> getAttribute ( 'id' ) ) ; } return $ this ; }
2299	public static function addFileMetaInformationToRequest ( $ strUuid , $ strPtable , $ intPid ) { @ trigger_error ( 'Using Backend::addFileMetaInformationToRequest() has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; $ objFile = FilesModel :: findByUuid ( $ strUuid ) ; if ( $ objFile === null ) { return ; } $ arrMeta = StringUtil :: deserialize ( $ objFile -> meta ) ; if ( empty ( $ arrMeta ) ) { return ; } $ objPage = null ; if ( $ strPtable == 'tl_article' ) { $ objPage = PageModel :: findOneBy ( array ( 'tl_page.id=(SELECT pid FROM tl_article WHERE id=?)' ) , $ intPid ) ; } else { if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'addFileMetaInformationToRequest' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'addFileMetaInformationToRequest' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'addFileMetaInformationToRequest' ] as $ callback ) { if ( ( $ val = System :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ strPtable , $ intPid ) ) !== false ) { $ objPage = $ val ; } } if ( $ objPage instanceof Result && $ objPage -> numRows < 1 ) { return ; } if ( \ is_object ( $ objPage ) && ! ( $ objPage instanceof PageModel ) ) { $ objPage = PageModel :: findByPk ( $ objPage -> id ) ; } } } if ( $ objPage === null ) { return ; } $ objPage -> loadDetails ( ) ; $ strLanguage = str_replace ( '-' , '_' , $ objPage -> rootLanguage ) ; if ( isset ( $ arrMeta [ $ strLanguage ] ) ) { if ( ! empty ( $ arrMeta [ $ strLanguage ] [ 'title' ] ) && Input :: post ( 'title' ) == '' ) { Input :: setPost ( 'title' , $ arrMeta [ $ strLanguage ] [ 'title' ] ) ; } if ( ! empty ( $ arrMeta [ $ strLanguage ] [ 'alt' ] ) && Input :: post ( 'alt' ) == '' ) { Input :: setPost ( 'alt' , $ arrMeta [ $ strLanguage ] [ 'alt' ] ) ; } if ( ! empty ( $ arrMeta [ $ strLanguage ] [ 'caption' ] ) && Input :: post ( 'caption' ) == '' ) { Input :: setPost ( 'caption' , $ arrMeta [ $ strLanguage ] [ 'caption' ] ) ; } } }
12335	public function editProfileAction ( ) { if ( ! $ this -> cmsAuthentication ( ) -> hasIdentity ( ) ) { return $ this -> redirect ( ) -> toRoute ( $ this -> getOptions ( ) -> getLoginRoute ( ) ) ; } $ url = $ this -> url ( ) -> fromRoute ( null , [ 'action' => 'edit-profile' ] ) ; $ prg = $ this -> prg ( $ url , true ) ; if ( $ prg instanceof ResponseInterface ) { return $ prg ; } $ post = $ prg ; $ form = $ this -> getUserService ( ) -> getEditProfileForm ( ) ; $ identity = $ this -> cmsAuthentication ( ) -> getIdentity ( ) ; $ form -> bind ( $ identity ) ; $ form -> setAttribute ( 'action' , $ url ) ; if ( $ post && $ form -> setData ( $ post ) -> isValid ( ) ) { $ result = $ this -> getUserService ( ) -> editProfile ( $ identity ) ; if ( $ result instanceof ResponseInterface ) { return $ result ; } elseif ( $ result ) { $ fm = $ this -> flashMessenger ( ) ; $ fm -> setNamespace ( $ form -> getName ( ) . '-' . $ fm :: NAMESPACE_SUCCESS ) -> addMessage ( $ this -> translate ( 'Data has been successfully saved' ) ) ; } } return new ViewModel ( compact ( 'form' ) ) ; }
11992	public function toArray ( ) { $ urls = [ ] ; $ actions = [ ] ; if ( count ( $ this -> items ) < 1 ) { return parent :: toArray ( ) ; } $ entity = $ this -> items [ 0 ] ; if ( is_array ( $ entity -> load ) ) { foreach ( $ entity -> load as $ k => $ load ) { $ this -> load ( $ load ) ; } } $ data = parent :: toArray ( ) ; $ actions = $ entity -> getActions ( ) ; if ( count ( $ actions ) > 0 ) { foreach ( $ data as $ k => $ resource ) { if ( count ( $ resource ) < 2 ) { continue ; } $ data [ $ k ] += [ 'actions' => $ actions ] ; } } $ data = $ this -> normalizeArray ( $ data ) ; return $ data ; }
3832	protected function validateWidget ( $ widget , $ value ) { if ( null === $ value ) { return ; } $ widget -> setInputCallback ( function ( ) use ( $ value ) { return $ value ; } ) ; $ widget -> validate ( ) ; }
7759	protected function getMappingDriverBundleConfigDefaults ( array $ bundleConfig , \ ReflectionClass $ bundle , ContainerBuilder $ container ) { $ bundleDir = dirname ( $ bundle -> getFilename ( ) ) ; if ( ! $ bundleConfig [ 'type' ] ) { $ bundleConfig [ 'type' ] = $ this -> detectMetadataDriver ( $ bundleDir , $ container ) ; } if ( ! $ bundleConfig [ 'type' ] ) { return false ; } if ( ! $ bundleConfig [ 'dir' ] ) { if ( in_array ( $ bundleConfig [ 'type' ] , array ( 'annotation' , 'staticphp' ) ) ) { $ bundleConfig [ 'dir' ] = $ bundleDir . '/' . $ this -> getMappingObjectDefaultName ( ) ; } else { $ bundleConfig [ 'dir' ] = $ bundleDir . '/' . $ this -> getMappingResourceConfigDirectory ( ) ; } } else { $ bundleConfig [ 'dir' ] = $ bundleDir . '/' . $ bundleConfig [ 'dir' ] ; } if ( ! $ bundleConfig [ 'prefix' ] ) { $ bundleConfig [ 'prefix' ] = $ bundle -> getNamespaceName ( ) . '\\' . $ this -> getMappingObjectDefaultName ( ) ; } return $ bundleConfig ; }
8854	public function getArchiveYear ( ) { $ year = $ this -> request -> param ( "Year" ) ; if ( preg_match ( "/^[0-9]{4}$/" , $ year ) ) { return ( int ) $ year ; } return null ; }
2765	public function isUpToDate ( ) : bool { if ( ! $ this -> isTracking ( ) ) { throw new GitException ( 'Error: HEAD does not have a remote tracking branch. Cannot check if it is up-to-date.' ) ; } $ mergeBase = $ this -> run ( 'merge-base' , [ '@' , '@{u}' ] ) ; $ remoteSha = $ this -> run ( 'rev-parse' , [ '@{u}' ] ) ; return $ mergeBase === $ remoteSha ; }
2163	public function run40Update ( ) { $ this -> Database -> query ( "ALTER TABLE `tl_layout` ADD `scripts` text NULL" ) ; $ objLayout = $ this -> Database -> query ( "SELECT id, addJQuery, jquery, addMooTools, mootools FROM tl_layout WHERE framework!=''" ) ; while ( $ objLayout -> next ( ) ) { $ arrScripts = array ( ) ; if ( $ objLayout -> addJQuery ) { $ jquery = StringUtil :: deserialize ( $ objLayout -> jquery ) ; if ( ! empty ( $ jquery ) && \ is_array ( $ jquery ) ) { if ( ( $ key = array_search ( 'j_slider' , $ jquery ) ) !== false ) { $ arrScripts [ ] = 'js_slider' ; unset ( $ jquery [ $ key ] ) ; $ this -> Database -> prepare ( "UPDATE tl_layout SET jquery=? WHERE id=?" ) -> execute ( serialize ( array_values ( $ jquery ) ) , $ objLayout -> id ) ; } } } if ( $ objLayout -> addMooTools ) { $ mootools = StringUtil :: deserialize ( $ objLayout -> mootools ) ; if ( ! empty ( $ mootools ) && \ is_array ( $ mootools ) ) { if ( ( $ key = array_search ( 'moo_slider' , $ mootools ) ) !== false ) { $ arrScripts [ ] = 'js_slider' ; unset ( $ mootools [ $ key ] ) ; $ this -> Database -> prepare ( "UPDATE tl_layout SET mootools=? WHERE id=?" ) -> execute ( serialize ( array_values ( $ mootools ) ) , $ objLayout -> id ) ; } } } if ( ! empty ( $ arrScripts ) ) { $ this -> Database -> prepare ( "UPDATE tl_layout SET scripts=? WHERE id=?" ) -> execute ( serialize ( array_values ( array_unique ( $ arrScripts ) ) ) , $ objLayout -> id ) ; } } }
4284	public function url_stat ( $ path , $ flags ) { self :: restorePrev ( ) ; if ( ! \ file_exists ( $ path ) ) { $ info = false ; } elseif ( $ flags & STREAM_URL_STAT_LINK ) { $ info = $ flags & STREAM_URL_STAT_QUIET ? @ \ lstat ( $ path ) : \ lstat ( $ path ) ; } else { $ info = $ flags & STREAM_URL_STAT_QUIET ? @ \ stat ( $ path ) : \ stat ( $ path ) ; } self :: register ( ) ; return $ info ; }
11000	public function selectLocaleFromAcceptHeader ( Accept $ header ) { $ my_locales = [ ] ; foreach ( $ this -> locales as $ supported_locale ) { $ list = $ supported_locale -> getFallbackList ( ) ; foreach ( $ list as $ locale ) $ my_locales [ $ locale -> getLocale ( ) ] = $ supported_locale -> getLocale ( ) ; } $ best = $ header -> getBestResponseType ( array_keys ( $ my_locales ) ) ; return empty ( $ best ) ? null : ( $ my_locales [ $ best ] ?? null ) ; }
10972	public static function getAuthUsername ( ) { $ result = null ; if ( isset ( $ _SERVER [ 'PHP_AUTH_USER' ] ) ) { $ result = $ _SERVER [ 'PHP_AUTH_USER' ] ; } if ( trim ( $ result ) == '' ) { $ result = null ; } return $ result ; }
5271	private function translateDelete ( ) { $ build = array ( "delete from {$this->table}" ) ; if ( ! empty ( $ this -> statements [ 'wheres' ] ) ) { $ build [ ] = join ( ' ' , $ this -> statements [ 'wheres' ] ) ; } if ( ! empty ( $ this -> limit ) ) { $ build [ ] = $ this -> limit ; } return join ( ' ' , $ build ) ; }
6926	protected function didStateChangeTo ( $ resource , $ state ) { if ( empty ( $ stateCs = $ this -> tracker -> getChangeSet ( $ resource , 'state' ) ) ) { return false ; } if ( $ stateCs [ 1 ] === $ state && $ stateCs [ 0 ] !== $ state ) { return true ; } return false ; }
4119	public static function addType ( $ name , $ className ) { if ( isset ( self :: $ _typesMap [ $ name ] ) ) { throw TypeException :: typeExists ( $ name ) ; } self :: $ _typesMap [ $ name ] = $ className ; }
9026	public function hasEmail ( $ string ) { $ result = false ; $ tokenizer = new General ( ) ; $ words = $ tokenizer -> tokenize ( $ string ) ; foreach ( $ words as $ word ) { if ( filter_var ( $ word , FILTER_VALIDATE_EMAIL ) ) { $ result = true ; } } return $ result ; }
12424	public function getAuthorizationInfo ( $ authCode = null ) { $ params = [ 'component_appid' => $ this -> getAppId ( ) , 'authorization_code' => $ authCode ? : $ this -> request -> get ( 'auth_code' ) , ] ; return $ this -> parseJSON ( 'json' , [ self :: GET_AUTH_INFO , $ params ] ) ; }
7990	public function getPcaServices ( $ pp ) { if ( ! $ pp ) throw new BadMethodCallException ( 'Missing parameter $pp (passport).' ) ; try { $ r = $ this -> get ( 'cloud/' . $ pp . '/pca' ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new CloudException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
5754	protected function setIndexFilter ( Request $ request , Response $ response , $ args , array $ listViewColumns , AdminListView $ view ) { $ this -> setRequestInput ( $ request , [ $ view -> getSessionFilterFieldKey ( ) ] ) ; if ( ! isset ( $ this -> requestInput [ $ view -> getSessionFilterFieldKey ( ) ] ) ) { throw new \ Exception ( "session filter input must be set" ) ; } $ this -> storeFilterFieldValueInSession ( $ view ) ; if ( null !== $ filterColumnsInfo = $ this -> getFilterColumns ( $ view -> getSessionFilterFieldKey ( ) , $ listViewColumns ) ) { $ this -> storeFilterColumnsInfoInSession ( $ filterColumnsInfo , $ view ) ; } }
461	public function buildColumns ( $ columns ) { if ( ! is_array ( $ columns ) ) { if ( strpos ( $ columns , '(' ) !== false ) { return $ columns ; } $ rawColumns = $ columns ; $ columns = preg_split ( '/\s*,\s*/' , $ columns , - 1 , PREG_SPLIT_NO_EMPTY ) ; if ( $ columns === false ) { throw new InvalidArgumentException ( "$rawColumns is not valid columns." ) ; } } foreach ( $ columns as $ i => $ column ) { if ( $ column instanceof ExpressionInterface ) { $ columns [ $ i ] = $ this -> buildExpression ( $ column ) ; } elseif ( strpos ( $ column , '(' ) === false ) { $ columns [ $ i ] = $ this -> db -> quoteColumnName ( $ column ) ; } } return implode ( ', ' , $ columns ) ; }
6717	protected function setParameters ( $ newParameters ) { if ( is_scalar ( $ newParameters ) ) { if ( ! is_string ( $ newParameters ) ) { throw new \ Exception ( 'newParameters can not be scalar' ) ; } $ newParameters = $ this -> stringToArray ( $ newParameters ) ; } foreach ( $ newParameters as $ field => $ value ) { $ this -> setParameter ( $ field , $ value ) ; } return $ this ; }
10502	public function setParameters ( $ subject , ParameterBagInterface $ parameters ) { if ( ! is_object ( $ subject ) ) { throw new InvalidSubjectException ( $ subject ) ; } if ( $ subject instanceof ParameterBagAwareInterface ) { $ subject -> setParameters ( $ parameters ) ; } else { foreach ( $ parameters as $ key => $ value ) { $ this -> setParameter ( $ subject , $ key , $ value ) ; } } }
12320	public static function getBundleLocationName ( string $ sName ) : string { $ oConfig = self :: get ( $ sName , null , true ) ; if ( isset ( $ oConfig -> redirect ) ) { return $ oConfig -> redirect ; } else { return PORTAL ; } }
12025	private function generateExecuteFragment ( ) { $ body = '' ; if ( $ this -> operationDefinition -> getNeedsSigning ( ) ) { $ body .= '$request = $this->api->signRequest($request);' . PHP_EOL ; } $ body .= '$response = $this->api->execute($request, $this);' . PHP_EOL ; $ body .= '$this->response = $response;' . PHP_EOL ; return $ body ; }
7068	static function getUnits ( ) { return [ static :: PIECE , static :: METER , static :: CENTIMETER , static :: MILLIMETER , static :: INCH , static :: FOOT , static :: KILOGRAM , static :: GRAM , static :: CUBIC_METER , static :: LITER , static :: MILLILITER , static :: DAY , static :: HOUR , static :: MINUTE , static :: SECOND , ] ; }
6921	public function get ( TaxGroupInterface $ taxGroup , CountryInterface $ country , $ business = false ) { $ key = $ this -> buildKey ( $ taxGroup , $ country , $ business ) ; if ( isset ( $ this -> taxes [ $ key ] ) ) { return $ this -> taxes [ $ key ] ; } return null ; }
8837	private function hasExceededTimeout ( ) : bool { return - 1 !== $ this -> timeout && ( microtime ( true ) - $ this -> startTime ) * 1000000 > $ this -> timeout ; }
6258	public function authorizeByControllerAndAction ( $ user , Request $ request ) { $ roleField = $ this -> _config [ 'roleField' ] ; extract ( $ this -> getControllerNameAndAction ( $ request ) ) ; $ actionMap = $ this -> getActionMap ( ) ; if ( isset ( $ actionMap [ $ name ] [ '*' ] ) ) { if ( $ this -> _isAllowedRole ( $ user [ $ roleField ] , $ actionMap [ $ name ] [ '*' ] ) ) { return true ; } } if ( isset ( $ actionMap [ $ name ] [ $ action ] ) ) { if ( $ this -> _isAllowedRole ( $ user [ $ roleField ] , $ actionMap [ $ name ] [ $ action ] ) ) { return true ; } } if ( $ this -> config ( 'undefinedActionsAreAllowed' ) === true ) { return true ; } return false ; }
5258	public static function map ( $ query = [ ] , callable $ callback = null , $ limit = - 1 ) { if ( $ query instanceof QueryBuilder ) { $ query = $ query -> build ( ) ; } $ query [ 'from' ] = Arr :: get ( $ query , 'from' , 0 ) ; $ query [ 'size' ] = Arr :: get ( $ query , 'size' , 50 ) ; $ i = 0 ; $ models = static :: search ( $ query ) ; $ total = $ models -> getTotal ( ) ; while ( $ models ) { foreach ( $ models as $ model ) { if ( $ callback ) { $ callback ( $ model ) ; } $ i ++ ; } $ query [ 'from' ] += $ query [ 'size' ] ; if ( $ i >= $ total || ( $ limit > 0 && $ i >= $ limit ) ) { break ; } $ models = static :: search ( $ query ) ; } return $ total ; }
4909	public function renderForm ( SummaryFormInterface $ form , $ layout = Form :: LAYOUT_HORIZONTAL , $ parameter = array ( ) ) { $ renderer = $ this -> getView ( ) ; $ formHelper = $ renderer -> plugin ( 'form' ) ; $ fieldset = $ form -> getBaseFieldset ( ) ; $ resetPartial = false ; if ( $ fieldset instanceof ViewPartialProviderInterface ) { $ origPartial = $ fieldset -> getViewPartial ( ) ; $ partial = "$origPartial.form" ; if ( $ renderer -> resolver ( $ partial ) ) { $ fieldset -> setViewPartial ( $ partial ) ; $ resetPartial = true ; } } $ markup = $ formHelper -> renderBare ( $ form , $ layout , $ parameter ) ; if ( $ resetPartial ) { $ fieldset -> setViewPartial ( $ origPartial ) ; } return $ markup ; }
2342	protected function getUserId ( ) { if ( $ this -> intUserId !== null ) { return $ this -> intUserId ; } $ this -> import ( BackendUser :: class , 'User' ) ; return $ this -> User -> id ; }
8785	public function fullUrlWithQuery ( array $ query ) { $ question = $ this -> getBaseUrl ( ) . $ this -> getPathInfo ( ) == '/' ? '/?' : '?' ; return count ( $ this -> query ( ) ) > 0 ? $ this -> url ( ) . $ question . http_build_query ( array_merge ( $ this -> query ( ) , $ query ) ) : $ this -> fullUrl ( ) . $ question . http_build_query ( $ query ) ; }
11358	public function removeBlock ( $ blockFile ) { foreach ( $ this -> permalinks as $ permalink => $ associatedBlocks ) { $ tmp = array_flip ( $ associatedBlocks ) ; unset ( $ tmp [ $ blockFile ] ) ; if ( empty ( $ tmp ) ) { unset ( $ this -> permalinks [ $ permalink ] ) ; continue ; } $ this -> permalinks [ $ permalink ] = array_flip ( $ tmp ) ; } return $ this ; }
11147	public function getFromLocation ( Neuron_GameServer_Map_Location $ location ) { $ area = new Neuron_GameServer_Map_Area ( $ location , 1 ) ; $ objects = $ this -> getDisplayObjects ( $ area ) ; $ out = array ( ) ; foreach ( $ objects as $ v ) { if ( $ v -> getLocation ( ) -> equals ( $ location ) ) { $ out [ ] = $ v ; } } return $ out ; }
7800	protected function splitStatements ( $ text ) { $ chunks = preg_split ( '/^:20:/m' , $ text , - 1 ) ; $ chunks = array_filter ( array_map ( 'trim' , array_slice ( $ chunks , 1 ) ) ) ; return array_map ( function ( $ statement ) { return ':20:' . $ statement ; } , $ chunks ) ; }
5386	public function isLabel ( $ label ) { for ( $ i = 0 , $ count = count ( $ this -> widgets ) ; $ i < $ count ; $ i ++ ) { if ( $ this -> widgets [ $ i ] -> isLabel ( $ label ) ) { return true ; } } return false ; }
12509	public function build ( ) { if ( empty ( $ this -> msgType ) ) { throw new RuntimeException ( 'message type not exist.' ) ; } if ( empty ( $ this -> message ) ) { throw new RuntimeException ( 'No message content to send.' ) ; } if ( $ this -> msgType === Broadcast :: MSG_TYPE_VIDEO ) { if ( is_array ( $ this -> message ) ) { $ this -> message = array_shift ( $ this -> message ) ; } $ this -> msgType = 'mpvideo' ; } $ content = ( new Transformer ( $ this -> msgType , $ this -> message ) ) -> transform ( ) ; $ group = isset ( $ this -> to ) ? $ this -> to : null ; $ message = array_merge ( $ this -> buildGroup ( $ group ) , $ content ) ; return $ message ; }
9006	public function build ( $ options = array ( ) ) { if ( is_string ( $ options ) ) { $ options = array ( 'type' => $ options , ) ; } else if ( ! is_array ( $ options ) ) { $ options = array ( 'type' => 'text' , ) ; } if ( empty ( $ options [ 'type' ] ) ) { $ options [ 'type' ] = 'text' ; } if ( empty ( $ options [ 'data_type' ] ) ) { $ options [ 'data_type' ] = 'metadata' ; } $ defaults = ( array ) $ this -> config -> getType ( $ options [ 'data_type' ] , $ options [ 'type' ] ) ; $ options = array_merge ( $ defaults , $ options ) ; $ classname = elgg_extract ( 'class_name' , $ options ) ; if ( class_exists ( $ classname ) ) { return new $ classname ( $ options ) ; } return false ; }
9078	private static function parseContextPrefix ( Request & $ request , $ serverVars = array ( ) ) { if ( isset ( $ serverVars [ 'CONTEXT_PREFIX' ] ) && $ serverVars [ 'CONTEXT_PREFIX' ] != '' ) { $ request -> setContextPrefix ( $ serverVars [ 'CONTEXT_PREFIX' ] . '/' ) ; } elseif ( isset ( $ serverVars [ 'REDIRECT_BASE' ] ) ) { $ request -> setContextPrefix ( $ serverVars [ 'REDIRECT_BASE' ] ) ; } elseif ( isset ( $ serverVars [ 'SCRIPT_FILENAME' ] ) && isset ( $ serverVars [ 'SCRIPT_NAME' ] ) ) { if ( isset ( $ serverVars [ 'HTTP_HOST' ] ) ) { $ scriptName = preg_replace ( '/^.+[\\\\\\/]/' , '' , $ serverVars [ 'SCRIPT_FILENAME' ] ) ; $ request -> contextPrefix = str_replace ( $ scriptName , '' , $ serverVars [ 'SCRIPT_NAME' ] ) ; } } }
7229	public static function create ( $ method , $ url , $ data = "" , array $ headers = [ ] , array $ options = [ ] , $ initOnly = false ) { $ curl = null ; if ( ! strcasecmp ( $ method , "GET" ) ) $ curl = new static ( $ url , $ options + [ CURLOPT_CUSTOMREQUEST => "GET" , CURLOPT_RETURNTRANSFER => true ] , $ headers , $ initOnly ) ; else if ( ! strcasecmp ( $ method , "POST" ) ) $ curl = new static ( $ url , $ options + [ CURLOPT_CUSTOMREQUEST => "POST" , CURLOPT_POSTFIELDS => $ data , CURLOPT_RETURNTRANSFER => true ] , $ headers , $ initOnly ) ; else if ( ! strcasecmp ( $ method , "PUT" ) ) $ curl = new static ( $ url , $ options + [ CURLOPT_CUSTOMREQUEST => "PUT" , CURLOPT_POSTFIELDS => $ data , CURLOPT_RETURNTRANSFER => true ] , $ headers , $ initOnly ) ; else if ( ! strcasecmp ( $ method , "DELETE" ) ) $ curl = new static ( $ url , $ options + [ CURLOPT_CUSTOMREQUEST => "DELETE" , CURLOPT_RETURNTRANSFER => true ] , $ headers , $ initOnly ) ; return $ curl ; }
3989	public function getScreen ( $ tableName ) { $ inputScreens = $ this -> getInputScreens ( ) ; if ( isset ( $ inputScreens [ $ tableName ] ) ) { return $ inputScreens [ $ tableName ] ; } return null ; }
598	public function joinWith ( $ with , $ eagerLoading = true , $ joinType = 'LEFT JOIN' ) { $ relations = [ ] ; foreach ( ( array ) $ with as $ name => $ callback ) { if ( is_int ( $ name ) ) { $ name = $ callback ; $ callback = null ; } if ( preg_match ( '/^(.*?)(?:\s+AS\s+|\s+)(\w+)$/i' , $ name , $ matches ) ) { list ( , $ relation , $ alias ) = $ matches ; $ name = $ relation ; $ callback = function ( $ query ) use ( $ callback , $ alias ) { $ query -> alias ( $ alias ) ; if ( $ callback !== null ) { call_user_func ( $ callback , $ query ) ; } } ; } if ( $ callback === null ) { $ relations [ ] = $ name ; } else { $ relations [ $ name ] = $ callback ; } } $ this -> joinWith [ ] = [ $ relations , $ eagerLoading , $ joinType ] ; return $ this ; }
6434	public function getLoginStartUrl ( $ redirecturl ) { $ credentials = array ( 'identifier' => $ this -> options [ 'consumer_key' ] , 'secret' => $ this -> options [ 'consumer_secret' ] , 'callback_uri' => $ redirecturl ) ; $ server = new \ League \ OAuth1 \ Client \ Server \ Xing ( $ credentials ) ; $ this -> temp_credentials = $ server -> getTemporaryCredentials ( ) ; return $ server -> getAuthorizationUrl ( $ this -> temp_credentials ) ; }
640	public function dropPrimaryKey ( $ name , $ table ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> dropPrimaryKey ( $ name , $ table ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; }
10959	private function processSplFileInfo ( \ SplFileInfo $ file ) { if ( $ this -> getCurrentCommand ( ) -> isUsePathReplace ( ) ) { $ this -> getCurrentCommand ( ) -> setToDirectory ( NULL ) ; } $ filePathFrom = $ this -> prepareFilePathFrom ( $ file ) ; $ filePathTo = $ this -> prepareFilePathTo ( $ file ) ; $ this -> currentFilePathFrom = $ filePathFrom ; $ this -> currentFilePathTo = $ filePathTo ; $ this -> validateFileFrom ( $ filePathFrom ) ; $ this -> validateFileTo ( $ filePathTo ) ; if ( ! $ this -> isMoveIt ( ) ) { return null ; } $ result = $ this -> doSystemCommand ( $ filePathFrom , $ filePathTo ) ; return $ result ; }
12569	public function previewText ( $ message , $ to , $ by = self :: PREVIEW_BY_OPENID ) { return $ this -> preview ( self :: MSG_TYPE_TEXT , $ message , $ to , $ by ) ; }
6402	public static function register ( ) { set_error_handler ( function ( $ code , $ message , $ file , $ line , $ context ) { if ( error_reporting ( ) == 0 ) { return false ; } ErrorType :: forCode ( $ code ) -> throwException ( $ message , $ file , $ line , $ context ) ; } ) ; }
579	public static function ensureScheme ( $ url , $ scheme ) { if ( static :: isRelative ( $ url ) || ! is_string ( $ scheme ) ) { return $ url ; } if ( substr ( $ url , 0 , 2 ) === '//' ) { return $ scheme === '' ? $ url : "$scheme:$url" ; } if ( ( $ pos = strpos ( $ url , '://' ) ) !== false ) { if ( $ scheme === '' ) { $ url = substr ( $ url , $ pos + 1 ) ; } else { $ url = $ scheme . substr ( $ url , $ pos ) ; } } return $ url ; }
9671	private function writeCellStyleDxf ( XMLWriter $ objWriter , \ PhpOffice \ PhpSpreadsheet \ Style \ Style $ pStyle ) { $ objWriter -> startElement ( 'dxf' ) ; $ this -> writeFont ( $ objWriter , $ pStyle -> getFont ( ) ) ; $ this -> writeNumFmt ( $ objWriter , $ pStyle -> getNumberFormat ( ) ) ; $ this -> writeFill ( $ objWriter , $ pStyle -> getFill ( ) ) ; $ objWriter -> startElement ( 'alignment' ) ; if ( $ pStyle -> getAlignment ( ) -> getHorizontal ( ) !== null ) { $ objWriter -> writeAttribute ( 'horizontal' , $ pStyle -> getAlignment ( ) -> getHorizontal ( ) ) ; } if ( $ pStyle -> getAlignment ( ) -> getVertical ( ) !== null ) { $ objWriter -> writeAttribute ( 'vertical' , $ pStyle -> getAlignment ( ) -> getVertical ( ) ) ; } if ( $ pStyle -> getAlignment ( ) -> getTextRotation ( ) !== null ) { $ textRotation = 0 ; if ( $ pStyle -> getAlignment ( ) -> getTextRotation ( ) >= 0 ) { $ textRotation = $ pStyle -> getAlignment ( ) -> getTextRotation ( ) ; } elseif ( $ pStyle -> getAlignment ( ) -> getTextRotation ( ) < 0 ) { $ textRotation = 90 - $ pStyle -> getAlignment ( ) -> getTextRotation ( ) ; } $ objWriter -> writeAttribute ( 'textRotation' , $ textRotation ) ; } $ objWriter -> endElement ( ) ; $ this -> writeBorder ( $ objWriter , $ pStyle -> getBorders ( ) ) ; if ( ( $ pStyle -> getProtection ( ) -> getLocked ( ) !== null ) || ( $ pStyle -> getProtection ( ) -> getHidden ( ) !== null ) ) { if ( $ pStyle -> getProtection ( ) -> getLocked ( ) !== Protection :: PROTECTION_INHERIT || $ pStyle -> getProtection ( ) -> getHidden ( ) !== Protection :: PROTECTION_INHERIT ) { $ objWriter -> startElement ( 'protection' ) ; if ( ( $ pStyle -> getProtection ( ) -> getLocked ( ) !== null ) && ( $ pStyle -> getProtection ( ) -> getLocked ( ) !== Protection :: PROTECTION_INHERIT ) ) { $ objWriter -> writeAttribute ( 'locked' , ( $ pStyle -> getProtection ( ) -> getLocked ( ) == Protection :: PROTECTION_PROTECTED ? 'true' : 'false' ) ) ; } if ( ( $ pStyle -> getProtection ( ) -> getHidden ( ) !== null ) && ( $ pStyle -> getProtection ( ) -> getHidden ( ) !== Protection :: PROTECTION_INHERIT ) ) { $ objWriter -> writeAttribute ( 'hidden' , ( $ pStyle -> getProtection ( ) -> getHidden ( ) == Protection :: PROTECTION_PROTECTED ? 'true' : 'false' ) ) ; } $ objWriter -> endElement ( ) ; } } $ objWriter -> endElement ( ) ; }
9805	private function readDefault ( ) { $ verInstance = Xls :: getUInt2d ( $ this -> data , $ this -> pos ) ; $ fbt = Xls :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recVer = ( 0x000F & $ verInstance ) >> 0 ; $ length = Xls :: getInt4d ( $ this -> data , $ this -> pos + 4 ) ; $ recordData = substr ( $ this -> data , $ this -> pos + 8 , $ length ) ; $ this -> pos += 8 + $ length ; }
6786	public function buildHeaders ( $ options ) { $ options = $ this -> resolve ( $ options ) ; $ headerOptions = [ ] ; foreach ( $ this -> headerParameters as $ key => $ isHeaderParameter ) { if ( $ isHeaderParameter && isset ( $ options [ $ key ] ) ) { $ headerOptions [ $ key ] = $ options [ $ key ] ; } } return $ headerOptions ; }
11819	public function addAppDependencies ( ) { $ container = $ this -> getContainer ( ) ; $ container [ 'person' ] = $ container -> protect ( function ( $ name ) { return 'Person name: ' . $ name ; } ) ; return $ this ; }
301	public static function isPrimaryKey ( $ keys ) { $ pks = static :: primaryKey ( ) ; if ( count ( $ keys ) === count ( $ pks ) ) { return count ( array_intersect ( $ keys , $ pks ) ) === count ( $ pks ) ; } return false ; }
2159	public function run210Update ( ) { $ this -> Database -> query ( "ALTER TABLE `tl_style` ADD `positioning` char(1) NOT NULL default ''" ) ; $ this -> Database -> query ( "UPDATE `tl_style` SET `positioning`=`size`" ) ; $ this -> Database -> query ( "UPDATE `tl_module` SET `guests`=1 WHERE `type`='lostPassword' OR `type`='registration'" ) ; $ this -> Database -> query ( "UPDATE `tl_news` SET `teaser`=CONCAT('<p>', teaser, '</p>') WHERE `teaser`!='' AND `teaser` NOT LIKE '<p>%'" ) ; }
5058	public function generate ( $ subject , $ status , $ color , $ format ) { $ badge = new Badge ( $ subject , $ status , $ color , $ format ) ; return $ this -> getRenderFor ( $ badge -> getFormat ( ) ) -> render ( $ badge ) ; }
1356	protected function getSortColumn ( $ field , Model $ model ) { if ( isset ( $ this -> sortColumns [ $ field ] ) ) { return $ this -> sortColumns [ $ field ] ; } return $ model :: $ snakeAttributes ? Str :: underscore ( $ field ) : Str :: camelize ( $ field ) ; }
5877	protected static function findExistingFile ( $ fileName ) { $ file = null ; $ relativePath = substr ( PathUtility :: dirname ( $ fileName ) , strlen ( PATH_site ) ) ; $ resourceFactory = \ TYPO3 \ CMS \ Core \ Resource \ ResourceFactory :: getInstance ( ) ; $ targetFolder = $ resourceFactory -> retrieveFileOrFolderObject ( $ relativePath ) ; $ storageConfiguration = $ targetFolder -> getStorage ( ) -> getConfiguration ( ) ; if ( isset ( $ storageConfiguration [ 'basePath' ] ) ) { $ basePath = rtrim ( $ storageConfiguration [ 'basePath' ] , '/' ) . '/' ; $ basePath = GeneralUtility :: getFileAbsFileName ( $ basePath ) ; $ identifier = substr ( $ fileName , strlen ( $ basePath ) - 1 ) ; $ row = GeneralUtility :: makeInstance ( ConnectionPool :: class ) -> getConnectionForTable ( 'sys_file' ) -> select ( [ 'uid' ] , 'sys_file' , [ 'storage' => $ targetFolder -> getStorage ( ) -> getUid ( ) , 'identifier' => $ identifier , ] ) -> fetch ( ) ; if ( ! empty ( $ row [ 'uid' ] ) ) { $ fileRepository = GeneralUtility :: makeInstance ( \ TYPO3 \ CMS \ Core \ Resource \ FileRepository :: class ) ; $ file = $ fileRepository -> findByUid ( $ row [ 'uid' ] ) ; } } return $ file ; }
4142	protected function getOauthString ( ) { $ oauth = array_merge ( $ this -> getOauthParameters ( ) , array ( 'oauth_signature' => $ this -> calculateSignature ( ) ) ) ; ksort ( $ oauth ) ; $ values = array ( ) ; foreach ( $ oauth as $ key => $ value ) { $ values [ ] = $ key . '="' . rawurlencode ( $ value ) . '"' ; } $ oauth = implode ( ', ' , $ values ) ; unset ( $ values , $ key , $ value ) ; return $ oauth ; }
3079	public static function getCatInfo ( AssessmentTest $ test , $ namespace = '' ) { if ( $ namespace === '' ) { $ namespace = CatService :: QTI_2X_ADAPTIVE_XML_NAMESPACE ; } $ info = [ ] ; foreach ( $ test -> getComponentsByClassName ( 'assessmentSection' ) as $ assessmentSection ) { if ( ( $ selection = $ assessmentSection -> getSelection ( ) ) !== null && ( ( $ xmlExtension = $ selection -> getXml ( ) ) ) !== null ) { $ xpath = new \ DOMXPath ( $ xmlExtension ) ; $ xpath -> registerNamespace ( 'ais' , $ namespace ) ; $ sectionIdentifier = $ assessmentSection -> getIdentifier ( ) ; $ sectionInfo = [ ] ; foreach ( $ xpath -> query ( './/ais:adaptiveItemSelection/ais:adaptiveEngineRef' , $ xmlExtension ) as $ adaptiveEngineRef ) { $ sectionInfo [ 'adaptiveEngineRef' ] = $ adaptiveEngineRef -> getAttribute ( 'href' ) ; } foreach ( $ xpath -> query ( './/ais:adaptiveItemSelection/ais:adaptiveSettingsRef' , $ xmlExtension ) as $ adaptiveSettingsRef ) { $ sectionInfo [ 'adaptiveSettingsRef' ] = $ adaptiveSettingsRef -> getAttribute ( 'href' ) ; } foreach ( $ xpath -> query ( './/ais:adaptiveItemSelection/ais:qtiUsagedataRef' , $ xmlExtension ) as $ qtiUsagedataRef ) { $ sectionInfo [ 'qtiUsagedataRef' ] = $ qtiUsagedataRef -> getAttribute ( 'href' ) ; } foreach ( $ xpath -> query ( './/ais:adaptiveItemSelection/ais:qtiMetadataRef' , $ xmlExtension ) as $ qtiMetadataRef ) { $ sectionInfo [ 'qtiMetadataRef' ] = $ qtiMetadataRef -> getAttribute ( 'href' ) ; } if ( ! empty ( $ sectionInfo ) ) { $ info [ $ sectionIdentifier ] = $ sectionInfo ; } } } return $ info ; }
7076	private function addDiscountDetails ( array & $ details , Model \ SaleAdjustmentInterface $ discount ) { $ discountResult = $ discount -> getResult ( ) ; $ details [ 'L_PAYMENTREQUEST_0_NAME' . $ this -> line ] = $ discount -> getDesignation ( ) ; $ details [ 'L_PAYMENTREQUEST_0_AMT' . $ this -> line ] = '-' . $ this -> format ( $ discountResult -> getTotal ( ) ) ; $ this -> line ++ ; return - $ discountResult -> getTotal ( ) ; }
8017	public function fileExists ( $ name ) { $ http = new \ Guzzle \ Http \ Client ( ) ; try { $ response = $ http -> get ( $ this -> getUrl ( $ name ) ) -> send ( ) ; } catch ( ClientErrorResponseException $ e ) { return false ; } return $ response -> isSuccessful ( ) ; }
9735	public static function indexedColor ( $ pIndex , $ background = false ) { $ pIndex = ( int ) $ pIndex ; if ( self :: $ indexedColors === null ) { self :: $ indexedColors = [ 1 => 'FF000000' , 2 => 'FFFFFFFF' , 3 => 'FFFF0000' , 4 => 'FF00FF00' , 5 => 'FF0000FF' , 6 => 'FFFFFF00' , 7 => 'FFFF00FF' , 8 => 'FF00FFFF' , 9 => 'FF800000' , 10 => 'FF008000' , 11 => 'FF000080' , 12 => 'FF808000' , 13 => 'FF800080' , 14 => 'FF008080' , 15 => 'FFC0C0C0' , 16 => 'FF808080' , 17 => 'FF9999FF' , 18 => 'FF993366' , 19 => 'FFFFFFCC' , 20 => 'FFCCFFFF' , 21 => 'FF660066' , 22 => 'FFFF8080' , 23 => 'FF0066CC' , 24 => 'FFCCCCFF' , 25 => 'FF000080' , 26 => 'FFFF00FF' , 27 => 'FFFFFF00' , 28 => 'FF00FFFF' , 29 => 'FF800080' , 30 => 'FF800000' , 31 => 'FF008080' , 32 => 'FF0000FF' , 33 => 'FF00CCFF' , 34 => 'FFCCFFFF' , 35 => 'FFCCFFCC' , 36 => 'FFFFFF99' , 37 => 'FF99CCFF' , 38 => 'FFFF99CC' , 39 => 'FFCC99FF' , 40 => 'FFFFCC99' , 41 => 'FF3366FF' , 42 => 'FF33CCCC' , 43 => 'FF99CC00' , 44 => 'FFFFCC00' , 45 => 'FFFF9900' , 46 => 'FFFF6600' , 47 => 'FF666699' , 48 => 'FF969696' , 49 => 'FF003366' , 50 => 'FF339966' , 51 => 'FF003300' , 52 => 'FF333300' , 53 => 'FF993300' , 54 => 'FF993366' , 55 => 'FF333399' , 56 => 'FF333333' , ] ; } if ( isset ( self :: $ indexedColors [ $ pIndex ] ) ) { return new self ( self :: $ indexedColors [ $ pIndex ] ) ; } if ( $ background ) { return new self ( self :: COLOR_WHITE ) ; } return new self ( self :: COLOR_BLACK ) ; }
4189	protected function dumpConstants ( $ constants ) { $ str = '' ; if ( $ constants && $ this -> debug -> output -> getCfg ( 'outputConstants' ) ) { $ str = '<dt class="constants">constants</dt>' . "\n" ; foreach ( $ constants as $ k => $ value ) { $ str .= '<dd class="constant">' . '<span class="constant-name">' . $ k . '</span>' . ' <span class="t_operator">=</span> ' . $ this -> debug -> output -> html -> dump ( $ value ) . '</dd>' . "\n" ; } } return $ str ; }
8152	public function getExtension ( $ class ) { $ class = ltrim ( $ class , '\\' ) ; if ( ! isset ( $ this -> extensionsByClass [ $ class ] ) && class_exists ( $ class , false ) ) { $ class = new ReflectionClass ( $ class ) ; $ class = $ class -> name ; } if ( isset ( $ this -> extensions [ $ class ] ) ) { if ( $ class !== get_class ( $ this -> extensions [ $ class ] ) ) { @ trigger_error ( sprintf ( 'Referencing the "%s" extension by its name (defined by getName()) is deprecated since 1.26 and will be removed in Twig 2.0. Use the Fully Qualified Extension Class Name instead.' , $ class ) , E_USER_DEPRECATED ) ; } return $ this -> extensions [ $ class ] ; } if ( ! isset ( $ this -> extensionsByClass [ $ class ] ) ) { throw new Twig_Error_Runtime ( sprintf ( 'The "%s" extension is not enabled.' , $ class ) ) ; } return $ this -> extensionsByClass [ $ class ] ; }
12202	public function create ( int $ status = 200 , array $ headers = [ ] , $ body = null ) : ResponseInterface { return new Response ( $ status , $ headers , $ body ) ; }
8561	public function cancelShipment ( $ request ) { if ( ! ( $ request instanceof MWSMerchantFulfillmentService_Model_CancelShipmentRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/CancelShipmentRequest.php' ) ; $ request = new MWSMerchantFulfillmentService_Model_CancelShipmentRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'CancelShipment' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/CancelShipmentResponse.php' ) ; $ response = MWSMerchantFulfillmentService_Model_CancelShipmentResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
1447	protected function dataForDelete ( $ record ) : array { $ schema = $ this -> container -> getSchema ( $ record ) ; return ResourceObject :: create ( [ 'type' => $ schema -> getResourceType ( ) , 'id' => $ schema -> getId ( $ record ) , 'attributes' => $ schema -> getAttributes ( $ record ) , 'relationships' => collect ( $ this -> existingRelationships ( $ record ) ) -> all ( ) , ] ) -> all ( ) ; }
8869	public function attach ( Runner $ runner ) { if ( $ this -> runners -> contains ( $ runner ) ) { throw new LogicException ( 'Can\'t attach already attached runner.' ) ; } $ this -> runners -> attach ( $ runner ) ; return $ this ; }
4161	public function modifyRelationship ( $ action , $ user ) { if ( true === in_array ( $ action , $ this -> _actions ) && isset ( $ user ) ) { return $ this -> _makeCall ( 'users/' . $ user . '/relationship' , array ( 'action' => $ action ) , 'POST' ) ; } throw new InvalidParameterException ( 'Error: modifyRelationship() - This method requires an action command and the target user id.' ) ; }
6603	public function makeRequestToken ( Response $ response ) { parse_str ( $ response -> content ( ) , $ params ) ; $ this -> validateRequestTokenResponse ( $ params ) ; $ this -> credentials [ 'key' ] = $ params [ 'oauth_token' ] ; $ this -> credentials [ 'secret' ] = $ params [ 'oauth_token_secret' ] ; $ this -> credentials [ 'callback_confirmed' ] = ( isset ( $ params [ 'oauth_callback_confirmed' ] ) ) ? ( boolean ) $ params [ 'oauth_callback_confirmed' ] : null ; return $ this ; }
1855	public static function findUpcomingByPids ( $ arrIds , $ intLimit = 0 , array $ arrOptions = array ( ) ) { if ( empty ( $ arrIds ) || ! \ is_array ( $ arrIds ) ) { return null ; } $ t = static :: $ strTable ; $ time = Date :: floorToMinute ( ) ; $ arrColumns = array ( "($t.endTime>=$time OR ($t.recurring='1' AND ($t.recurrences=0 OR $t.repeatEnd>=$time))) AND $t.pid IN(" . implode ( ',' , array_map ( '\intval' , $ arrIds ) ) . ") AND ($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ) ; if ( $ intLimit > 0 ) { $ arrOptions [ 'limit' ] = $ intLimit ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.startTime" ; } return static :: findBy ( $ arrColumns , null , $ arrOptions ) ; }
12126	public function validate ( string $ sValue = null ) : bool { if ( $ this -> _sType == 'DateTime' ) { if ( preg_match ( '#^[0-9]{4}/[0-9]{2}/[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}#' , $ sValue ) ) { return true ; } } return false ; }
51	public function addRepository ( RepositoryInterface $ repository ) { if ( $ repository instanceof self ) { foreach ( $ repository -> getRepositories ( ) as $ repo ) { $ this -> addRepository ( $ repo ) ; } } else { $ this -> repositories [ ] = $ repository ; } }
12820	public function execute ( callable $ callback , array $ vars ) : Response { $ arguments = $ this -> resolveDependencies ( $ callback , $ vars ) ; return call_user_func_array ( $ callback , $ arguments ) ; }
3405	public function timeout ( int $ timeout ) : bool { $ application = $ this -> getApplication ( ) ; if ( ! $ application instanceof Application ) { return false ; } if ( ! $ application -> timeLimit ( ) ) { return false ; } $ endTime = $ this -> startTime + $ timeout ; return ( time ( ) > $ endTime ) ; }
9796	public function hasHyperlink ( ) { if ( ! isset ( $ this -> parent ) ) { throw new Exception ( 'Cannot check for hyperlink when cell is not bound to a worksheet' ) ; } return $ this -> getWorksheet ( ) -> hyperlinkExists ( $ this -> getCoordinate ( ) ) ; }
4550	public function setAssigneeLike ( ? string $ assigneeLike ) { $ this -> assigneeLike = $ assigneeLike ; $ this -> _assigneeLike = null !== $ assigneeLike ; return $ this ; }
11689	public function isAccompanyingPeriodValid ( ExecutionContextInterface $ context ) { $ r = $ this -> checkAccompanyingPeriodsAreNotCollapsing ( ) ; if ( $ r !== true ) { if ( $ r [ 'result' ] === self :: ERROR_PERIODS_ARE_COLLAPSING ) { $ context -> addViolationAt ( 'accompanyingPeriods' , 'Two accompanying periods have days in commun' , array ( ) ) ; } if ( $ r [ 'result' ] === self :: ERROR_ADDIND_PERIOD_AFTER_AN_OPEN_PERIOD ) { $ context -> addViolationAt ( 'accompanyingPeriods' , 'A period is opened and a period is added after it' , array ( ) ) ; } } }
9125	private function handleHeader ( & $ delimiterFound , & $ numBytes , & $ tmp ) { if ( $ tmp == "\r\n" ) { $ numBytes = $ this -> adjustNumbytes ( $ numBytes ) ; $ delimiterFound = true ; $ tmp = "" ; return ; } if ( substr ( $ tmp , - 2 , 2 ) == "\r\n" ) { $ this -> addParsedHeader ( $ tmp ) ; $ tmp = "" ; } }
12451	static function run_check_php_files ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { $ opts = self :: getOpts ( @ $ args [ 0 ] , @ $ args [ 1 ] , $ cliopts ) ; if ( ! SharedLock :: acquire ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ) throw new PakeException ( "Source code locked by another process" ) ; $ destdir = self :: getBuildDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ; $ files = pakeFinder :: type ( 'file' ) -> name ( array ( '*.php' ) ) -> in ( $ destdir ) ; if ( count ( $ files ) ) { $ php = self :: getTool ( 'php' , $ opts ) ; if ( strpos ( pake_sh ( $ php . " -v" ) , 'PHP' ) === false ) { SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; throw new pakeException ( "$php does not seem to be a valid php executable" ) ; } foreach ( pakeFinder :: type ( 'file' ) -> name ( array ( '*.php' ) ) -> in ( $ destdir ) as $ file ) { if ( strpos ( pake_sh ( $ php . " -l " . escapeshellarg ( $ file ) ) , 'No syntax errors detected' ) === false ) { SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; throw new pakeException ( "$file does not seem to be a valid php file" ) ; } } } SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; }
12798	public function getLines ( $ lazy = true , $ raw = false ) { if ( is_null ( $ this -> _lines ) ) { $ file = $ this -> filePointer ; if ( ! $ file ) { return false ; } rewind ( $ file ) ; $ this -> _lines = [ ] ; $ currentLineNumber = 0 ; while ( ( $ buffer = fgetcsv ( $ this -> filePointer , 0 , $ this -> delimeter ) ) !== false ) { $ currentLineNumber ++ ; if ( $ currentLineNumber <= $ this -> skipLines ) { continue ; } $ line = Yii :: createObject ( [ 'class' => SourceFileLine :: className ( ) , 'sourceFile' => $ this , 'lineNumber' => $ currentLineNumber - 1 , 'content' => $ buffer ] ) ; if ( $ this -> testIgnore ( $ line ) ) { continue ; } $ lineId = $ line -> id ; if ( ! isset ( $ lineId ) ) { continue ; } $ this -> _lines [ $ lineId ] = $ line ; if ( $ lazy ) { $ line -> clean ( ) ; } } } return $ this -> _lines ; }
4706	public function each ( callable $ callable ) { foreach ( $ this -> objects as $ key => $ value ) { if ( false === call_user_func_array ( $ callable , array ( $ value , $ key ) ) ) { break ; } } return $ this ; }
3347	public function __preparedRequest ( $ type , $ request_type = 'GET' , $ params = array ( ) , $ data = array ( ) , $ retry_throttled = null ) { $ retry_throttled = $ retry_throttled ? : $ this -> retry_throttled ; $ path = $ this -> __getPath ( $ type , $ params ) ; while ( true ) { try { return $ this -> request ( $ request_type , $ path , $ data ) ; } catch ( ThrottledRequestException $ exception ) { if ( $ retry_throttled > 0 ) { sleep ( $ exception -> getTimeout ( ) ) ; $ retry_throttled -- ; continue ; } else { throw $ exception ; } } } return null ; }
2963	public function isAuthorized ( ) { $ hasSession = Yii :: $ app -> session -> has ( $ this -> sessionParam ) ; $ sessionVal = Yii :: $ app -> session -> get ( $ this -> sessionParam ) ; return ( $ hasSession && ! empty ( $ sessionVal ) ) ; }
8842	private function stringToArray ( string $ string ) : array { $ lines = preg_split ( '/\R/' , $ string ) ; if ( 1 === count ( $ lines ) && '' === $ lines [ 0 ] ) { $ lines = [ ] ; } return $ lines ; }
11732	protected function generateBlocks ( array $ blocks , $ blocksDir , $ targetDir ) { $ c = 1 ; $ generatedBlocks = array ( ) ; foreach ( $ blocks as $ block ) { $ blockName = 'block' . $ c ; $ fileName = sprintf ( '%s/%s.json' , $ blocksDir , $ blockName ) ; $ generatedBlocks [ ] = $ blockName ; $ value = $ block ; if ( is_array ( $ value ) ) { $ value = json_encode ( $ block ) ; } FilesystemTools :: writeFile ( $ fileName , $ value ) ; $ c ++ ; } $ slotDefinition = array ( 'next' => $ c , 'blocks' => $ generatedBlocks , 'revision' => 1 , ) ; FilesystemTools :: writeFile ( $ targetDir . '/slot.json' , json_encode ( $ slotDefinition ) ) ; }
5070	protected function determineHeaderTags ( $ topLevel , $ depth ) { $ desired = range ( ( int ) $ topLevel , ( int ) $ topLevel + ( ( int ) $ depth - 1 ) ) ; $ allowed = [ 1 , 2 , 3 , 4 , 5 , 6 ] ; return array_map ( function ( $ val ) { return 'h' . $ val ; } , array_intersect ( $ desired , $ allowed ) ) ; }
4904	protected function createValueOptions ( NodeInterface $ node , $ allowSelectNodes = false , $ isRoot = true ) { $ key = $ isRoot ? $ node -> getValue ( ) : $ node -> getValueWithParents ( ) ; $ name = $ node -> getName ( ) ; if ( $ node -> hasChildren ( ) ) { $ leafOptions = [ ] ; if ( $ allowSelectNodes && ! $ isRoot ) { $ leafOptions [ $ key ] = $ name ; $ key = "$key-group" ; } foreach ( $ node -> getChildren ( ) as $ child ) { $ leafOptions += $ this -> createValueOptions ( $ child , $ allowSelectNodes , false ) ; } $ value = [ 'label' => $ name , 'options' => $ leafOptions ] ; } else { $ value = $ name ; } return [ $ key => $ value ] ; }
458	public function dropCheck ( $ name , $ table ) { return 'ALTER TABLE ' . $ this -> db -> quoteTableName ( $ table ) . ' DROP CONSTRAINT ' . $ this -> db -> quoteColumnName ( $ name ) ; }
216	public function asNtext ( $ value ) { if ( $ value === null ) { return $ this -> nullDisplay ; } return nl2br ( Html :: encode ( $ value ) ) ; }
1416	public function invalidQueryParameter ( string $ param , ? string $ detail = null , array $ failed = [ ] ) : ErrorInterface { return new Error ( null , null , Response :: HTTP_BAD_REQUEST , $ this -> trans ( 'query_invalid' , 'code' ) , $ this -> trans ( 'query_invalid' , 'title' ) , $ detail ? : $ this -> trans ( 'query_invalid' , 'detail' ) , [ Error :: SOURCE_PARAMETER => $ param ] , $ failed ? compact ( 'failed' ) : null ) ; }
4700	protected function handleInput ( InputInterface $ input ) { if ( $ file = $ input -> getArgument ( 'file' ) ) { if ( ! file_exists ( $ file ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The input file "%s" not found' , $ file ) ) ; } return file_get_contents ( $ file ) ; } else { $ contents = '' ; if ( $ stdin = fopen ( 'php://stdin' , 'r' ) ) { if ( stream_set_blocking ( $ stdin , false ) ) { $ contents = stream_get_contents ( $ stdin ) ; } fclose ( $ stdin ) ; } if ( $ contents ) { return $ contents ; } } throw new \ InvalidArgumentException ( 'No input file' ) ; }
10613	protected function authenticateUser ( UserInterface $ user , Response $ response ) { try { $ this -> get ( 'fos_user.security.login_manager' ) -> loginUser ( $ this -> container -> getParameter ( 'fos_user.firewall_name' ) , $ user , $ response ) ; } catch ( AccountStatusException $ ex ) { } }
3053	public function getCatEngine ( RouteItem $ routeItem = null ) { $ compiledDirectory = $ this -> getCompilationDirectory ( ) [ 'private' ] ; $ adaptiveSectionMap = $ this -> getServiceManager ( ) -> get ( CatService :: SERVICE_ID ) -> getAdaptiveSectionMap ( $ compiledDirectory ) ; $ routeItem = $ routeItem ? $ routeItem : $ this -> getTestSession ( ) -> getRoute ( ) -> current ( ) ; $ sectionId = $ routeItem -> getAssessmentSection ( ) -> getIdentifier ( ) ; $ catEngine = false ; if ( isset ( $ adaptiveSectionMap [ $ sectionId ] ) ) { $ catEngine = $ this -> getServiceManager ( ) -> get ( CatService :: SERVICE_ID ) -> getEngine ( $ adaptiveSectionMap [ $ sectionId ] [ 'endpoint' ] ) ; } return $ catEngine ; }
10758	protected function prepareHeader ( array $ data ) { return array_merge_recursive ( [ 'date' => trans ( 'dashboard::logs.date' ) , 'all' => trans ( 'dashboard::logs.all' ) , ] , $ this -> levels -> names ( $ this -> locale ) ) ; }
12909	public function all ( ) { $ _filters = $ this -> filters ; if ( ! $ this -> allowDeleted ) { $ this -> filters = array ( "`" . $ this -> table . "`.deleted = 0" ) ; } else { $ this -> filters = array ( ) ; } $ values = $ this -> values ( ) ; $ this -> filters = $ _filters ; return $ values ; }
4179	public function hasManagerFile ( ) { if ( app ( 'filesystem' ) -> exists ( $ this -> directory . 'manager.yml' ) ) { return true ; } $ this -> console -> warn ( "No manager.yml file found in {$this->name} package." ) ; return false ; }
9930	public function setFilterType ( $ pFilterType ) { if ( ! in_array ( $ pFilterType , self :: $ filterTypes ) ) { throw new PhpSpreadsheetException ( 'Invalid filter type for column AutoFilter.' ) ; } $ this -> filterType = $ pFilterType ; return $ this ; }
6976	protected function scheduleSaleContentChangeEvent ( Model \ AdjustmentInterface $ adjustment ) { if ( $ adjustment instanceof Model \ SaleAdjustmentInterface ) { if ( null === $ sale = $ this -> getSaleFromAdjustment ( $ adjustment ) ) { return ; } } elseif ( $ adjustment instanceof Model \ SaleItemAdjustmentInterface ) { if ( null === $ item = $ this -> getItemFromAdjustment ( $ adjustment ) ) { return ; } if ( null === $ sale = $ this -> getSaleFromItem ( $ item ) ) { return ; } } else { throw new InvalidArgumentException ( "Unexpected adjustment type." ) ; } $ this -> persistenceHelper -> scheduleEvent ( $ this -> getSaleChangeEvent ( ) , $ sale ) ; }
12230	public function deleteNodes ( $ xpath ) { if ( ! is_string ( $ xpath ) ) { throw new InvalidArgumentException ( 'Argument 1 passed to deleteNodes() must be a string, ' . gettype ( $ xpath ) . ' given' ) ; } $ nodes = $ this -> _xpath ( $ xpath ) ; if ( isset ( $ nodes [ 0 ] ) ) { $ tmp = dom_import_simplexml ( $ nodes [ 0 ] ) ; if ( $ tmp -> isSameNode ( $ tmp -> ownerDocument -> documentElement ) ) { unset ( $ nodes [ 0 ] ) ; } } foreach ( $ nodes as $ node ) { $ node -> deleteSelf ( ) ; } return count ( $ nodes ) ; }
4675	public function addString ( $ content , $ region = "main" , $ sort = 0 ) { $ view = new View ( ) ; $ view -> set ( $ content , [ ] , $ sort , "string" ) ; $ this -> views [ $ region ] [ ] = $ view ; return $ this ; }
5959	public function clientGetByUid ( $ uid ) { foreach ( $ this -> clientList ( ) as $ client ) { if ( $ client [ "client_unique_identifier" ] == $ uid ) { return $ client ; } } throw new Ts3Exception ( "invalid clientID" , 0x200 ) ; }
6612	public static function getDropdownMap ( $ keyAttribute , $ valueAttribute , array $ default = [ ] ) { $ map = ArrayHelper :: map ( self :: getActive ( ) , $ keyAttribute , $ valueAttribute ) ; if ( $ default ) { $ map = array_merge ( $ default , $ map ) ; } return $ map ; }
3773	private function buildMetaPaletteConditions ( $ palette , $ metaPalettes ) { foreach ( $ metaPalettes as $ typeName => $ paletteInfo ) { if ( 'default' === $ typeName ) { continue ; } if ( preg_match ( '#^(\w+) extends (\w+)$#' , $ typeName , $ matches ) ) { $ typeName = $ matches [ 1 ] ; } foreach ( $ paletteInfo as $ legendName => $ properties ) { foreach ( $ properties as $ propertyName ) { $ condition = new AttributeByIdIsOfType ( $ typeName , $ this -> connection , 'attr_id' ) ; $ legend = $ this -> getLegend ( $ legendName , $ palette ) ; $ property = $ this -> getProperty ( $ propertyName , $ legend ) ; $ this -> addCondition ( $ property , $ condition ) ; } } } }
11944	private function validateGetPost ( $ data , ConfigContainer $ config , $ position ) { $ argumentName = $ config -> getValue ( 'name' ) ; $ default = $ config -> getValue ( 'default' ) ; if ( ! isset ( $ data [ $ argumentName ] ) ) { if ( $ default !== false ) { return $ default ; } else { throw new RequiredArgumentException ( $ position , $ argumentName ) ; } } return $ data [ $ argumentName ] ; }
3024	public function getBlogPosts ( $ blogName , $ options = null ) { $ path = $ this -> blogPath ( $ blogName , '/posts' ) ; if ( $ options && isset ( $ options [ 'type' ] ) ) { $ path .= '/' . $ options [ 'type' ] ; unset ( $ options [ 'type' ] ) ; } return $ this -> getRequest ( $ path , $ options , true ) ; }
12500	public static function update ( $ id , $ document , $ connection ) { $ from = $ connection -> db ; if ( strpos ( $ from , '.' ) !== false ) { $ tmp = explode ( '.' , $ connection -> db ) ; $ from = end ( $ tmp ) ; } $ connection -> method = 'PATCH' ; $ connection -> action = '[' . urlencode ( $ id ) . ']' ; switch ( gettype ( $ document ) ) { case "string" : $ connection -> query = $ document ; break ; case "array" : case "object" : $ connection -> method = 'POST' ; $ connection -> action = '/_query' ; $ connection -> query = 'UPDATE ' . $ from . '["' . $ id . '"] SET ' . self :: updateRecursion ( $ document ) ; break ; default : throw new ClusterpointException ( "\"->update()\" function: parametr passed " . json_encode ( self :: escape_string ( $ document ) ) . " is not in valid format." , 9002 ) ; break ; } return self :: sendQuery ( $ connection ) ; }
3440	public function saveProps ( $ selected = [ ] ) { $ propertyValues = $ this -> constructPropertyValuesForSave ( $ selected ) ; if ( empty ( $ propertyValues ) ) { return false ; } $ bxMethod = empty ( $ selected ) ? 'setPropertyValues' : 'setPropertyValuesEx' ; static :: $ bxObject -> $ bxMethod ( $ this -> id , static :: iblockId ( ) , $ propertyValues ) ; return true ; }
8551	public function setPerformanceBondRefundEventList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'PerformanceBondRefundEventList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
10142	private function readDefault ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ this -> pos += 4 + $ length ; }
8066	protected function collectWorkerResults ( $ sec = 0 ) { $ this -> respawnIfRequired ( ) ; pcntl_signal_dispatch ( ) ; if ( isset ( $ this -> workerProcesses ) === FALSE ) { throw new WorkerPoolException ( 'There is no list of worker processes. Maybe you destroyed the worker pool?' , 1401179881 ) ; } $ result = SimpleSocket :: select ( $ this -> workerProcesses -> getSockets ( ) , array ( ) , array ( ) , $ sec ) ; foreach ( $ result [ 'read' ] as $ socket ) { $ processId = $ socket -> annotation [ 'pid' ] ; $ result = $ socket -> receive ( ) ; $ possibleArrayKeys = array ( 'data' , 'poolException' , 'workerException' ) ; if ( is_array ( $ result ) && count ( ( $ resultTypes = array_intersect ( array_keys ( $ result ) , $ possibleArrayKeys ) ) ) === 1 ) { $ this -> workerProcesses -> registerFreeProcessId ( $ processId ) ; $ result [ 'pid' ] = $ processId ; $ resultType = reset ( $ resultTypes ) ; if ( $ resultType !== 'data' || $ result [ 'data' ] !== NULL ) { array_push ( $ this -> results , $ result ) ; } } } pcntl_signal_dispatch ( ) ; $ this -> respawnIfRequired ( ) ; }
777	private function defaultTimeTypeMap ( ) { $ map = [ Schema :: TYPE_DATETIME => 'datetime' , Schema :: TYPE_TIMESTAMP => 'timestamp' , Schema :: TYPE_TIME => 'time' , ] ; if ( $ this -> supportsFractionalSeconds ( ) ) { $ map = [ Schema :: TYPE_DATETIME => 'datetime(0)' , Schema :: TYPE_TIMESTAMP => 'timestamp(0)' , Schema :: TYPE_TIME => 'time(0)' , ] ; } return $ map ; }
3093	public function process ( $ data , $ serviceContext ) { if ( empty ( $ data ) ) { throw new \ common_exception_InconsistentData ( 'No action to check. Processing action requires data.' ) ; } $ actions = [ ] ; $ duration = 0 ; foreach ( $ data as $ entry ) { $ action = $ this -> resolve ( $ entry ) ; $ actions [ ] = $ action ; if ( $ action -> hasRequestParameter ( 'itemDuration' ) ) { $ duration += $ action -> getRequestParameter ( 'itemDuration' ) + self :: TIMEPOINT_INTERVAL ; } } $ now = microtime ( true ) ; $ last = $ serviceContext -> getTestSession ( ) -> getTimer ( ) -> getLastRegisteredTimestamp ( ) ; $ elapsed = $ now - $ last ; if ( $ duration > $ elapsed ) { \ common_Logger :: t ( 'Ignoring the last timestamp to take into account the actual duration to sync. Could introduce TimeLine inconsistency!' ) ; $ last = $ now - $ duration ; } usort ( $ actions , function ( $ a , $ b ) { return $ a -> getTimestamp ( ) - $ b -> getTimestamp ( ) ; } ) ; $ response = [ ] ; foreach ( $ actions as $ action ) { try { $ serviceContext -> setSyncingMode ( $ action -> getRequestParameter ( 'offline' ) ) ; if ( $ action -> hasRequestParameter ( 'itemDuration' ) && $ serviceContext -> isSyncingMode ( ) ) { $ last += $ action -> getRequestParameter ( 'itemDuration' ) + self :: TIMEPOINT_INTERVAL ; $ action -> setTime ( $ last ) ; } else { $ action -> setTime ( $ now ) ; } $ action -> setServiceContext ( $ serviceContext ) ; if ( $ serviceContext instanceof QtiRunnerServiceContext ) { } $ responseAction = $ action -> process ( ) ; } catch ( \ common_Exception $ e ) { $ responseAction = [ 'error' => $ e -> getMessage ( ) ] ; $ responseAction [ 'success' ] = false ; } $ responseAction [ 'name' ] = $ action -> getName ( ) ; $ responseAction [ 'timestamp' ] = $ action -> getTimeStamp ( ) ; $ responseAction [ 'requestParameters' ] = $ action -> getRequestParameters ( ) ; $ response [ ] = $ responseAction ; if ( $ responseAction [ 'success' ] === false ) { break ; } } $ this -> getRunnerService ( ) -> persist ( $ serviceContext ) ; return $ response ; }
4947	protected function checkPermission ( $ permission ) { $ perms = array ( self :: PERMISSION_ALL , self :: PERMISSION_CHANGE , self :: PERMISSION_NONE , self :: PERMISSION_VIEW , ) ; if ( ! in_array ( $ permission , $ perms ) ) { throw new \ InvalidArgumentException ( 'Invalid permission. Must be one of ' . implode ( ', ' , $ perms ) ) ; } }
2795	public function getTempDirectory ( ) { if ( is_null ( $ this -> tempDirectory ) ) { $ root = sys_get_temp_dir ( ) ; if ( ! is_dir ( $ root . '/humbug' ) ) { mkdir ( $ root . '/humbug' , 0777 , true ) ; } $ this -> tempDirectory = $ root . '/humbug' ; } return $ this -> tempDirectory ; }
3076	public function processInput ( QtiRunnerServiceContext $ context , array $ input ) { $ responses = [ ] ; foreach ( $ input as $ data ) { if ( ! is_array ( $ data ) || ! isset ( $ data [ 'channel' ] ) || ! isset ( $ data [ 'message' ] ) ) { throw new \ common_exception_InconsistentData ( 'Wrong message chunk received by the bidirectional communication service: either channel or message content is missing!' ) ; } if ( $ this -> hasChannel ( $ data [ 'channel' ] , self :: CHANNEL_TYPE_INPUT ) ) { $ channel = $ this -> getChannel ( $ data [ 'channel' ] , self :: CHANNEL_TYPE_INPUT ) ; $ responses [ ] = $ this -> processChannel ( $ channel , $ context , $ data [ 'message' ] ) ; } else { $ responses [ ] = $ this -> fallback ( $ data [ 'channel' ] , $ context , $ data [ 'message' ] ) ; } } return $ responses ; }
5746	public function getForm ( string $ csrfNameKey , string $ csrfNameValue , string $ csrfValueKey , string $ csrfValueValue , string $ action , ? string $ usernameValue = null ) { $ administratorsTableMapper = AdministratorsTableMapper :: getInstance ( ) ; $ fields = [ ] ; $ fields [ ] = DatabaseTableForm :: getFieldFromDatabaseColumn ( $ administratorsTableMapper -> getColumnByName ( self :: USERNAME_FIELD ) , null , $ usernameValue ) ; $ fields [ ] = DatabaseTableForm :: getFieldFromDatabaseColumn ( $ administratorsTableMapper -> getColumnByName ( self :: PASSWORD_FIELD ) , null , null , 'Password' , 'password' ) ; $ fields [ ] = FormHelper :: getCsrfNameField ( $ csrfNameKey , $ csrfNameValue ) ; $ fields [ ] = FormHelper :: getCsrfValueField ( $ csrfValueKey , $ csrfValueValue ) ; $ fields [ ] = FormHelper :: getSubmitField ( ) ; return new Form ( $ fields , [ 'method' => 'post' , 'action' => $ action , 'novalidate' => 'novalidate' ] , FormHelper :: getGeneralError ( ) ) ; }
5237	private function injectionValuesForMethod ( \ ReflectionMethod $ method ) { $ paramValues = [ ] ; $ defaultName = $ this -> methodBindingName ( $ method ) ; foreach ( $ method -> getParameters ( ) as $ param ) { $ type = $ this -> paramType ( $ method , $ param ) ; $ name = $ this -> detectBindingName ( $ param , $ defaultName ) ; $ hasExplicitBinding = $ this -> injector -> hasExplicitBinding ( $ type , $ name ) ; if ( ! $ hasExplicitBinding && $ param -> isDefaultValueAvailable ( ) ) { $ paramValues [ ] = $ param -> getDefaultValue ( ) ; continue ; } if ( ! $ this -> injector -> hasBinding ( $ type , $ name ) ) { $ typeMsg = $ this -> createTypeMessage ( $ type , $ name ) ; throw new BindingException ( 'Can not inject into ' . $ this -> class -> getName ( ) . '::' . $ method -> getName ( ) . '(' . $ this -> createParamString ( $ param , $ type ) . '). No binding for type ' . $ typeMsg . ' specified. Injection stack: ' . "\n" . join ( "\n" , $ this -> injector -> stack ( ) ) ) ; } $ paramValues [ ] = $ this -> injector -> getInstance ( $ type , $ name ) ; } return $ paramValues ; }
9689	static function getDataType ( $ value ) { switch ( $ value ) { case "string" : return self :: $ STRING ; case "double" : return self :: $ DOUBLE ; case "float" : return self :: $ FLOAT ; case "integer" : return self :: $ INTEGER ; case "boolean" : return self :: $ BOOLEAN ; case "timestamp" : return self :: $ TIMESTAMP ; case "json" : return self :: $ JSON ; default : return null ; } }
8704	public function apply ( EloquentBuilder $ builder , Eloquent $ model ) { $ this -> table = $ model -> getTable ( ) ; $ this -> locale = $ model -> getLocale ( ) ; $ this -> i18nTable = $ model -> getI18nTable ( ) ; $ this -> fallback = $ model -> getFallbackLocale ( ) ; if ( ! starts_with ( $ this -> table , 'laravel_reserved_' ) ) { $ this -> createJoin ( $ builder , $ model ) ; $ this -> createWhere ( $ builder , $ model ) ; $ this -> createSelect ( $ builder , $ model ) ; } }
4177	public function getMigration ( ) { return $ this -> migration ? : $ this -> migration = new Migration ( clone $ this -> getFiles ( ) , $ this -> console ) ; }
1231	public function resolveOptions ( array $ configuration ) { foreach ( $ configuration as $ key => $ value ) { if ( isset ( $ this -> definitions [ $ key ] ) ) { $ def = $ this -> definitions [ $ key ] ; $ this -> checkType ( $ def [ 'valid' ] , $ key , $ value ) ; if ( isset ( $ def [ 'fn' ] ) ) { $ def [ 'fn' ] ( $ configuration [ $ key ] , $ configuration ) ; } } } return $ configuration ; }
4416	public function onKernelResponse ( FilterResponseEvent $ event ) { $ routeName = $ event -> getRequest ( ) -> attributes -> get ( '_route' ) ; if ( $ routeName !== FallbackRouter :: ROUTE_NAME ) { return ; } $ response = $ event -> getResponse ( ) ; if ( ! $ response instanceof LegacyResponse ) { return ; } if ( ! $ this -> legacyMode && ( int ) $ response -> getStatusCode ( ) === Response :: HTTP_NOT_FOUND ) { $ moduleResult = $ response -> getModuleResult ( ) ; $ exception = new NotFoundHttpException ( isset ( $ moduleResult [ 'errorMessage' ] ) ? $ moduleResult [ 'errorMessage' ] : 'Not Found' ) ; $ exception -> setOriginalResponse ( $ response ) ; throw $ exception ; } }
11227	final public function setProperties ( array $ properties = [ ] ) { foreach ( $ properties as $ name => $ value ) { if ( property_exists ( $ this , $ name ) ) { $ this -> $ name = $ value ; } else { trigger_error ( Message :: get ( Message :: MSG_PROPERTY_UNKNOWN , $ name , get_class ( $ this ) ) , E_USER_WARNING ) ; } } }
2207	protected function compileYearlyMenu ( ) { $ arrData = array ( ) ; $ arrAllEvents = $ this -> getAllEvents ( $ this -> cal_calendar , 0 , 2145913200 ) ; foreach ( $ arrAllEvents as $ intDay => $ arrDay ) { foreach ( $ arrDay as $ arrEvents ) { $ arrData [ substr ( $ intDay , 0 , 4 ) ] += \ count ( $ arrEvents ) ; } } ( $ this -> cal_order == 'ascending' ) ? ksort ( $ arrData ) : krsort ( $ arrData ) ; $ arrItems = array ( ) ; $ count = 0 ; $ limit = \ count ( $ arrData ) ; foreach ( $ arrData as $ intYear => $ intCount ) { $ intDate = $ intYear ; $ quantity = sprintf ( ( ( $ intCount < 2 ) ? $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'entry' ] : $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'entries' ] ) , $ intCount ) ; $ arrItems [ $ intYear ] [ 'date' ] = $ intDate ; $ arrItems [ $ intYear ] [ 'link' ] = $ intYear ; $ arrItems [ $ intYear ] [ 'href' ] = $ this -> strLink . '?year=' . $ intDate ; $ arrItems [ $ intYear ] [ 'title' ] = StringUtil :: specialchars ( $ intYear . ' (' . $ quantity . ')' ) ; $ arrItems [ $ intYear ] [ 'class' ] = trim ( ( ( ++ $ count == 1 ) ? 'first ' : '' ) . ( ( $ count == $ limit ) ? 'last' : '' ) ) ; $ arrItems [ $ intYear ] [ 'isActive' ] = ( Input :: get ( 'year' ) == $ intDate ) ; $ arrItems [ $ intYear ] [ 'quantity' ] = $ quantity ; } $ this -> Template -> yearly = true ; $ this -> Template -> items = $ arrItems ; $ this -> Template -> showQuantity = ( $ this -> cal_showQuantity != '' ) ? true : false ; }
8944	public function getDetails ( ) { $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = 'user/details' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'GET' , $ parameters ) ; return $ response -> body ; }
5280	public function select ( $ fields = '' ) { if ( empty ( $ fields ) ) { return $ this ; } if ( is_string ( $ fields ) ) { $ this -> statements [ 'select' ] [ ] = $ fields ; return $ this ; } foreach ( $ fields as $ key => $ field ) { if ( is_string ( $ key ) ) { $ this -> statements [ 'select' ] [ ] = "$key as $field" ; } else { $ this -> statements [ 'select' ] [ ] = $ field ; } } return $ this ; }
7711	function Delete ( $ Contents = true ) { $ this -> FindEndTag ( ) ; if ( $ Contents || $ this -> SelfClosing ) { $ this -> ReplaceSrc ( '' ) ; } else { $ inner = $ this -> GetInnerSrc ( ) ; $ this -> ReplaceSrc ( $ inner ) ; } }
11034	private function loadFromFile ( ) { if ( is_file ( $ this -> _file ) ) { $ this -> _params = require ( $ this -> _file ) ; } else { $ this -> _params = [ 'users' => [ ] ] ; } }
8247	public function userDataEncodePassword ( & $ userData , Password $ newPassword ) { $ encoderName = $ this -> config [ "encoder" ] ; $ encoder = $ this -> picoAuth -> getContainer ( ) -> get ( $ encoderName ) ; $ userData [ 'pwhash' ] = $ encoder -> encode ( $ newPassword -> get ( ) ) ; $ userData [ 'encoder' ] = $ encoderName ; if ( isset ( $ userData [ 'pwreset' ] ) ) { unset ( $ userData [ 'pwreset' ] ) ; } }
121	private function createAuthFromConfig ( ) { if ( ! $ this -> config -> has ( 'http-basic' ) ) { return $ this -> hasAuth = false ; } $ authConfig = $ this -> config -> get ( 'http-basic' ) ; $ host = parse_url ( $ this -> url , PHP_URL_HOST ) ; if ( isset ( $ authConfig [ $ host ] ) ) { $ this -> credentials [ 'username' ] = $ authConfig [ $ host ] [ 'username' ] ; $ this -> credentials [ 'password' ] = $ authConfig [ $ host ] [ 'password' ] ; return $ this -> hasAuth = true ; } return $ this -> hasAuth = false ; }
3221	function searchFileNames ( $ basePath , $ query , $ limit = null , $ includeDeleted = false ) { Path :: checkArg ( "basePath" , $ basePath ) ; Checker :: argStringNonEmpty ( "query" , $ query ) ; Checker :: argNatOrNull ( "limit" , $ limit ) ; Checker :: argBool ( "includeDeleted" , $ includeDeleted ) ; $ response = $ this -> doPost ( $ this -> apiHost , $ this -> appendFilePath ( "1/search" , $ basePath ) , array ( "query" => $ query , "file_limit" => $ limit , "include_deleted" => $ includeDeleted , ) ) ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; return RequestUtil :: parseResponseJson ( $ response -> body ) ; }
8836	public function setMaxRetries ( $ retries ) { switch ( gettype ( $ retries ) ) { case 'integer' : $ this -> maxRetries = new Retries ( $ retries ) ; break ; case 'object' : $ this -> maxRetries = $ retries ; break ; default : throw new InvalidArgumentException ( 'Invalid type for max retries given.' ) ; break ; } }
3834	public function hookAdditionalFormatters ( $ arrBaseFormatted , $ arrRowData , $ strOutputFormat , $ objSettings ) { $ arrResult = $ arrBaseFormatted ; if ( isset ( $ GLOBALS [ 'METAMODEL_HOOKS' ] [ 'parseValue' ] ) && is_array ( $ GLOBALS [ 'METAMODEL_HOOKS' ] [ 'parseValue' ] ) ) { foreach ( $ GLOBALS [ 'METAMODEL_HOOKS' ] [ 'parseValue' ] as $ callback ) { list ( $ strClass , $ strMethod ) = $ callback ; $ objCallback = ( in_array ( 'getInstance' , get_class_methods ( $ strClass ) ) ) ? call_user_func ( array ( $ strClass , 'getInstance' ) ) : new $ strClass ( ) ; $ arrResult = $ objCallback -> $ strMethod ( $ this , $ arrResult , $ arrRowData , $ strOutputFormat , $ objSettings ) ; } } return $ arrResult ; }
7836	protected function deleteAllFilesOfWorkflowIfForced ( $ workflow ) { $ files = $ this -> pipelines -> getPipesByPipeline ( $ workflow ) ; $ files [ ] = $ this -> inflector -> getRequest ( ) ; $ files [ ] = $ this -> inflector -> getJob ( ) ; $ this -> deleteIfForced ( $ files ) ; }
586	protected function loadDependency ( $ bundle , & $ result ) { $ am = $ this -> getAssetManager ( ) ; foreach ( $ bundle -> depends as $ name ) { if ( ! isset ( $ result [ $ name ] ) ) { $ dependencyBundle = $ am -> getBundle ( $ name ) ; $ result [ $ name ] = false ; $ this -> loadDependency ( $ dependencyBundle , $ result ) ; $ result [ $ name ] = $ dependencyBundle ; } elseif ( $ result [ $ name ] === false ) { throw new Exception ( "A circular dependency is detected for bundle '{$name}': " . $ this -> composeCircularDependencyTrace ( $ name , $ result ) . '.' ) ; } } }
542	protected function serializeModels ( array $ models ) { list ( $ fields , $ expand ) = $ this -> getRequestedFields ( ) ; foreach ( $ models as $ i => $ model ) { if ( $ model instanceof Arrayable ) { $ models [ $ i ] = $ model -> toArray ( $ fields , $ expand ) ; } elseif ( is_array ( $ model ) ) { $ models [ $ i ] = ArrayHelper :: toArray ( $ model ) ; } } return $ models ; }
3462	public function process ( ServerRequestInterface $ request , RequestHandlerInterface $ next ) : ResponseInterface { $ route = $ this -> router -> find ( $ request -> getMethod ( ) , $ request -> getUri ( ) -> getPath ( ) ) ; $ controller = $ route -> getController ( ) ; if ( $ request instanceof ServerRequest ) { $ request = $ request -> withAttributes ( $ route -> getAttributes ( ) ) ; } if ( is_string ( $ controller ) && class_exists ( $ controller ) && is_subclass_of ( $ controller , Controller :: class ) ) { $ instance = $ this -> resolver -> resolve ( $ controller ) ; return $ instance ( $ request ) ; } if ( is_callable ( $ controller ) ) { $ response = $ controller ( $ request ) ; if ( ! $ response instanceof ResponseInterface ) { throw ControllerException :: forInvalidReturnValue ( ) ; } return $ response ; } throw ControllerException :: forMissingController ( $ route -> getPath ( ) ) ; }
2087	public static function getDefaultPath ( $ template , $ format ) { $ file = $ template . '.' . $ format ; $ container = System :: getContainer ( ) ; $ rootDir = $ container -> getParameter ( 'kernel.project_dir' ) ; if ( isset ( self :: $ files [ $ template ] ) ) { return $ rootDir . '/' . self :: $ files [ $ template ] . '/' . $ file ; } $ strPath = null ; try { foreach ( $ container -> get ( 'contao.resource_finder' ) -> findIn ( 'templates' ) -> name ( $ file ) as $ file ) { $ strPath = $ file -> getPathname ( ) ; } } catch ( \ InvalidArgumentException $ e ) { } if ( $ strPath !== null ) { return $ strPath ; } throw new \ Exception ( 'Could not find template "' . $ template . '"' ) ; }
9716	private function writeCountry ( ) { $ record = 0x008C ; $ length = 4 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vv' , $ this -> countryCode , $ this -> countryCode ) ; return $ this -> writeData ( $ header . $ data ) ; }
11275	protected function buildResponse ( ) { $ res = array ( ) ; $ res [ 'type' ] = $ this -> getParameters ( ) -> getType ( ) ; $ res [ 'tid' ] = $ this -> getParameters ( ) -> getTid ( ) ; $ res [ 'action' ] = $ this -> getParameters ( ) -> getAction ( ) ; $ res [ 'method' ] = $ this -> getParameters ( ) -> getMethod ( ) ; $ res [ 'result' ] = $ this -> getResult ( ) ; return $ res ; }
2573	protected function loadAuthParams ( $ params ) { if ( isset ( $ params [ 'authParams' ] ) ) { if ( $ params [ 'authParams' ] instanceof AuthParams ) { $ this -> authParams = $ params [ 'authParams' ] ; } elseif ( is_array ( $ params [ 'authParams' ] ) ) { $ this -> authParams = new AuthParams ( $ params [ 'authParams' ] ) ; } } }
8546	public function setChargebackEventList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ChargebackEventList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
2945	public function removeRole ( $ role ) { if ( is_string ( $ role ) ) { return $ this -> roles ( ) -> detach ( Role :: where ( 'slug' , $ role ) -> first ( ) ) ; } return $ this -> roles ( ) -> detach ( $ role ) ; }
9790	public function getFormattedValue ( ) { return ( string ) NumberFormat :: toFormattedString ( $ this -> getCalculatedValue ( ) , $ this -> getStyle ( ) -> getNumberFormat ( ) -> getFormatCode ( ) ) ; }
5243	public function transform ( string $ target ) { if ( $ this -> filesystem -> isFile ( $ target ) ) { $ this -> doTransform ( $ target ) ; return ; } $ files = $ this -> filesystem -> allFiles ( $ target ) ; array_walk ( $ files , function ( SplFileInfo $ file ) { $ this -> doTransform ( $ file -> getRealPath ( ) ) ; } ) ; }
7870	protected function drawBorderBottom ( $ isCore = false ) { $ this -> geometry -> decreaseNesting ( ) ; $ crossroads = $ isCore ? static :: CROSSROADS_DOWN : static :: CROSSROADS ; $ this -> drawBorder ( static :: BORDER_SW , $ crossroads , static :: BORDER_SE ) ; }
12301	public function getChilds ( $ id , $ relation , $ filters = null ) { $ parent = $ this -> model -> find ( $ id ) ; if ( ! $ parent ) { return null ; } if ( count ( $ filters -> request -> all ( ) ) > 0 ) { $ child = $ parent -> $ relation ( ) -> getRelated ( ) ; $ search = new Search ( $ child , $ filters , $ parent -> $ relation ( ) ) ; $ this -> builder = $ search -> getBuilder ( ) ; $ this -> builder -> select ( "{$child->getTable()}.*" ) ; return $ this -> builder -> get ( ) ; } $ resource = $ parent -> $ relation ; return $ resource ; }
3885	private function collectRulesFor ( $ parentSetting , $ filterSettings ) { $ childInformation = $ this -> database -> createQueryBuilder ( ) -> select ( '*' ) -> from ( 'tl_metamodel_filtersetting' ) -> where ( 'pid=:pid' ) -> andWhere ( 'enabled=1' ) -> orderBy ( 'sorting' , 'ASC' ) -> setParameter ( 'pid' , $ parentSetting -> get ( 'id' ) ) -> execute ( ) ; foreach ( $ childInformation -> fetchAll ( \ PDO :: FETCH_ASSOC ) as $ item ) { $ childSetting = $ this -> createSetting ( $ item , $ filterSettings ) ; if ( $ childSetting ) { $ parentSetting -> addChild ( $ childSetting ) ; } } }
685	public function getCurrencySymbol ( $ currencyCode = null ) { $ locale = $ this -> locale ; if ( $ currencyCode !== null ) { $ locale .= '@currency=' . $ currencyCode ; } $ formatter = new \ NumberFormatter ( $ locale , \ NumberFormatter :: CURRENCY ) ; return $ formatter -> getSymbol ( \ NumberFormatter :: CURRENCY_SYMBOL ) ; }
11515	public function getNamedParam ( string $ category , string $ key ) { $ params = $ this -> getNamedParams ( $ category ) ; return $ params [ $ key ] ?? '' ; }
5828	public function newRequest ( $ method , $ url , $ data = array ( ) , $ encoding = Request :: ENCODING_QUERY ) { $ class = $ this -> requestClass ; $ request = new $ class ( $ this ) ; $ request -> setMethod ( $ method ) ; $ request -> setUrl ( $ url ) ; $ request -> setData ( $ data ) ; $ request -> setEncoding ( $ encoding ) ; return $ request ; }
10180	private function storeCurrentCell ( ) { if ( $ this -> currentCellIsDirty && ! empty ( $ this -> currentCoordinate ) ) { $ this -> currentCell -> detach ( ) ; $ stored = $ this -> cache -> set ( $ this -> cachePrefix . $ this -> currentCoordinate , $ this -> currentCell ) ; if ( ! $ stored ) { $ this -> __destruct ( ) ; throw new PhpSpreadsheetException ( "Failed to store cell {$this->currentCoordinate} in cache" ) ; } $ this -> currentCellIsDirty = false ; } $ this -> currentCoordinate = null ; $ this -> currentCell = null ; }
3678	public function generateAjax ( $ folder , $ strField , $ level , $ mount = false ) { return parent :: generateAjax ( $ folder , $ this -> strField , $ level , $ mount ) ; }
10734	public function setLower ( $ lower ) : self { if ( ! is_numeric ( $ lower ) ) { throw new InvalidArgumentException ( __METHOD__ . "() expects parameter one, lower, to be a number" ) ; } $ this -> lower = + $ lower ; return $ this ; }
12239	public function innerXML ( ) { $ xml = $ this -> outerXML ( ) ; $ pos = 1 + strpos ( $ xml , '>' ) ; $ len = strrpos ( $ xml , '<' ) - $ pos ; return substr ( $ xml , $ pos , $ len ) ; }
257	public function init ( ) { parent :: init ( ) ; if ( is_array ( $ this -> theme ) ) { if ( ! isset ( $ this -> theme [ 'class' ] ) ) { $ this -> theme [ 'class' ] = 'yii\base\Theme' ; } $ this -> theme = Yii :: createObject ( $ this -> theme ) ; } elseif ( is_string ( $ this -> theme ) ) { $ this -> theme = Yii :: createObject ( $ this -> theme ) ; } }
11301	public function getFieldName ( $ attributeName ) { if ( isset ( $ this -> model_attributes [ $ attributeName ] [ 'field' ] ) ) { return $ this -> model_attributes [ $ attributeName ] [ 'field' ] ; } return $ attributeName ; }
9075	public function add ( $ name , Rule $ rule ) { unset ( $ this -> rules [ $ name ] ) ; $ this -> rules [ $ name ] = $ rule ; }
5616	public function compareChildren ( $ a , $ b ) { if ( $ this -> _children [ $ a ] -> getTotalSize ( ) > $ this -> _children [ $ b ] -> getTotalSize ( ) ) { $ node_a = $ this -> _children [ $ a ] ; $ node_b = $ this -> _children [ $ b ] ; $ this -> _children [ $ a ] = $ node_b ; $ this -> _children [ $ b ] = $ node_a ; } }
5843	public function validateAdditionalFields ( array & $ submittedData , \ TYPO3 \ CMS \ Scheduler \ Controller \ SchedulerModuleController $ parentObject ) { $ result = true ; $ directories = GeneralUtility :: trimExplode ( LF , $ submittedData [ 'scheduler_batchResize_directories' ] , true ) ; foreach ( $ directories as $ directory ) { $ absoluteDirectory = GeneralUtility :: getFileAbsFileName ( $ directory ) ; if ( ! @ is_dir ( $ absoluteDirectory ) ) { $ result = false ; $ parentObject -> addMessage ( sprintf ( $ GLOBALS [ 'LANG' ] -> sL ( 'LLL:EXT:image_autoresize/Resources/Private/Language/locallang_mod.xlf:msg.invalidDirectories' ) , $ directory ) , \ TYPO3 \ CMS \ Core \ Messaging \ FlashMessage :: ERROR ) ; } } $ directories = GeneralUtility :: trimExplode ( LF , $ submittedData [ 'scheduler_batchResize_excludeDirectories' ] , true ) ; foreach ( $ directories as $ directory ) { $ absoluteDirectory = GeneralUtility :: getFileAbsFileName ( $ directory ) ; if ( ! @ is_dir ( $ absoluteDirectory ) ) { $ result = false ; $ parentObject -> addMessage ( sprintf ( $ GLOBALS [ 'LANG' ] -> sL ( 'LLL:EXT:image_autoresize/Resources/Private/Language/locallang_mod.xlf:msg.invalidExcludeDirectories' ) , $ directory ) , \ TYPO3 \ CMS \ Core \ Messaging \ FlashMessage :: ERROR ) ; } } return $ result ; }
3703	protected function getProperty ( $ name , $ legend ) { foreach ( $ legend -> getProperties ( ) as $ property ) { if ( $ property -> getName ( ) === $ name ) { return $ property ; } } $ property = new Property ( $ name ) ; $ legend -> addProperty ( $ property ) ; return $ property ; }
11408	public function onBootstrap ( MvcEvent $ e ) { if ( ! $ e -> getRequest ( ) instanceof HttpRequest ) { return ; } $ app = $ e -> getApplication ( ) ; $ services = $ app -> getServiceManager ( ) ; $ eventManager = $ app -> getEventManager ( ) ; $ sharedEventManager = $ eventManager -> getSharedManager ( ) ; $ sharedEventManager -> attach ( UserService :: class , 'register' , function ( $ e ) use ( $ services ) { $ user = $ e -> getParam ( 'user' ) ; if ( $ user instanceof RoleableInterface && $ services -> has ( AuthorizationModuleOptions :: class ) ) { $ config = $ services -> get ( PermissionsModuleOptions :: class ) ; $ roleClass = $ config -> getRoleEntityClass ( ) ; $ mapper = $ services -> get ( 'MapperManager' ) -> get ( $ roleClass ) ; if ( $ defaultRole = $ mapper -> find ( $ config -> getAuthenticatedRole ( ) ) ) { $ user -> addRole ( $ defaultRole ) ; } } } , 100 ) ; }
1345	public function isUpdateResource ( ) : bool { return $ this -> isMethod ( 'patch' ) && $ this -> getRoute ( ) -> isResource ( ) && $ this -> getRoute ( ) -> isNotRelationship ( ) ; }
4607	public function statuses ( int $ account_id , int $ limit = 40 , int $ since_id = null ) : array { $ url = "/accounts/${account_id}/statuses" ; $ query = [ 'limit' => $ limit , 'since_id' => $ since_id , ] ; return $ this -> get ( $ url , $ query ) ; }
1381	protected function validateToMany ( array $ value , ? string $ field = null ) : bool { $ path = $ field ? "/data/relationships/{$field}/data" : "/data" ; $ valid = true ; foreach ( $ value as $ index => $ item ) { if ( ! $ this -> validateIdentifier ( $ item , $ path , $ index ) ) { $ valid = false ; continue ; } if ( $ this -> isNotFound ( $ item -> type , $ item -> id ) ) { $ this -> resourceDoesNotExist ( "{$path}/{$index}" ) ; $ valid = false ; } } return $ valid ; }
5836	public function handleRequest ( Request $ request ) : Promise { $ path = removeDotPathSegments ( $ request -> getUri ( ) -> getPath ( ) ) ; return new Coroutine ( ( $ fileInfo = $ this -> fetchCachedStat ( $ path , $ request ) ) ? $ this -> respondFromFileInfo ( $ fileInfo , $ request ) : $ this -> respondWithLookup ( $ this -> root . $ path , $ path , $ request ) ) ; }
4316	private function getDefaultServices ( ) { return array ( 'abstracter' => function ( Debug $ debug ) { return new Debug \ Abstracter ( $ debug , $ debug -> config -> getCfgLazy ( 'abstracter' ) ) ; } , 'config' => function ( Debug $ debug ) { return new Debug \ Config ( $ debug , $ debug -> cfg ) ; } , 'errorEmailer' => function ( Debug $ debug ) { return new ErrorEmailer ( $ debug -> config -> getCfgLazy ( 'errorEmailer' ) ) ; } , 'errorHandler' => function ( Debug $ debug ) { if ( ErrorHandler :: getInstance ( ) ) { return ErrorHandler :: getInstance ( ) ; } else { $ errorHandler = new ErrorHandler ( $ debug -> eventManager ) ; $ errorHandler -> setCfg ( 'onEUserError' , 'log' ) ; return $ errorHandler ; } } , 'eventManager' => function ( ) { return new EventManager ( ) ; } , 'internal' => function ( Debug $ debug ) { return new Debug \ Internal ( $ debug ) ; } , 'logger' => function ( Debug $ debug ) { return new Debug \ Logger ( $ debug ) ; } , 'methodClear' => function ( Debug $ debug ) { return new Debug \ MethodClear ( $ debug , $ debug -> data ) ; } , 'methodTable' => function ( ) { return new Debug \ MethodTable ( ) ; } , 'output' => function ( Debug $ debug ) { $ output = new Debug \ Output ( $ debug , $ debug -> config -> getCfgLazy ( 'output' ) ) ; $ debug -> eventManager -> addSubscriberInterface ( $ output ) ; return $ output ; } , 'utf8' => function ( ) { return new Debug \ Utf8 ( ) ; } , 'utilities' => function ( ) { return new Debug \ Utilities ( ) ; } , ) ; }
5439	public function addPattern ( $ pattern , $ mode = 'accept' ) { if ( ! isset ( $ this -> regexes [ $ mode ] ) ) { $ this -> regexes [ $ mode ] = new ParallelRegex ( $ this -> case ) ; } $ this -> regexes [ $ mode ] -> addPattern ( $ pattern ) ; if ( ! isset ( $ this -> mode_handlers [ $ mode ] ) ) { $ this -> mode_handlers [ $ mode ] = $ mode ; } }
1566	public function substituteBindings ( StoreInterface $ store ) : void { $ this -> resourceId = $ this -> getResourceId ( ) ? : false ; $ this -> processId = $ this -> getProcessId ( ) ? : false ; if ( $ this -> resourceId ) { $ this -> route -> setParameter ( ResourceRegistrar :: PARAM_RESOURCE_ID , $ store -> findOrFail ( $ this -> getResourceType ( ) , $ this -> resourceId ) ) ; } if ( $ this -> processId ) { $ this -> route -> setParameter ( ResourceRegistrar :: PARAM_PROCESS_ID , $ store -> findOrFail ( $ this -> getProcessType ( ) , $ this -> processId ) ) ; } }
2148	public function removeSubscriptions ( $ intUser , $ strMode ) { if ( ! $ intUser ) { return ; } if ( $ strMode == 'close_delete' ) { $ this -> Database -> prepare ( "DELETE FROM tl_newsletter_recipients WHERE email=(SELECT email FROM tl_member WHERE id=?)" ) -> execute ( $ intUser ) ; } else { $ this -> Database -> prepare ( "UPDATE tl_newsletter_recipients SET active='' WHERE email=(SELECT email FROM tl_member WHERE id=?)" ) -> execute ( $ intUser ) ; } }
8485	public static function getCpuModel ( ) { $ wmi = Windows :: getInstance ( ) ; $ object = $ wmi -> ExecQuery ( "SELECT Name FROM Win32_Processor" ) ; foreach ( $ object as $ cpu ) { return $ cpu -> Name ; } return 'Unknown' ; }
12862	public function parseBehaviour ( \ stdClass $ block , $ search ) { if ( ! isset ( $ block -> behaviour ) ) { return false ; } $ behaviours = array ( ) ; foreach ( explode ( ' ' , trim ( $ block -> behaviour ) ) as $ b ) { if ( strstr ( $ b , ':' ) ) { list ( $ name , $ prop ) = explode ( ':' , $ b , 2 ) ; $ behaviours [ $ name ] = $ prop ; } else { $ behaviours [ $ b ] = true ; } } return isset ( $ behaviours [ $ search ] ) ? $ behaviours [ $ search ] : false ; }
6734	protected function handleException ( \ Throwable $ e , Request $ request ) : Response { if ( ! $ e instanceof Exception \ Exception ) { $ e = new Exception \ UncaughtException ( $ e ) ; } $ code = $ e -> getStatusCode ( ) ; if ( $ this -> exceptionHandlers [ $ code ] instanceof ExceptionHandler ) { return $ this -> exceptionHandlers [ $ code ] -> handle ( $ e , $ request ) ; } elseif ( $ this -> defaultExceptionHandler instanceof ExceptionHandler ) { return $ this -> defaultExceptionHandler -> handle ( $ e , $ request ) ; } else { return ( new \ Circuit \ ExceptionHandler \ DefaultHandler ) -> handle ( $ e , $ request ) ; } }
11	private function mockLocalRepositories ( RepositoryManager $ rm ) { $ packages = array ( ) ; foreach ( $ rm -> getLocalRepository ( ) -> getPackages ( ) as $ package ) { $ packages [ ( string ) $ package ] = clone $ package ; } foreach ( $ packages as $ key => $ package ) { if ( $ package instanceof AliasPackage ) { $ alias = ( string ) $ package -> getAliasOf ( ) ; $ packages [ $ key ] = new AliasPackage ( $ packages [ $ alias ] , $ package -> getVersion ( ) , $ package -> getPrettyVersion ( ) ) ; } } $ rm -> setLocalRepository ( new InstalledArrayRepository ( $ packages ) ) ; }
7978	public function setSshKey ( $ key ) { self :: getClient ( ) -> setSshKey ( $ this -> pp , $ this -> sn , $ key ) ; }
1068	private function collectConflictsBetween ( ValidationContext $ context , array & $ conflicts , $ parentFieldsAreMutuallyExclusive , array $ fieldMap1 , array $ fieldMap2 ) { foreach ( $ fieldMap1 as $ responseName => $ fields1 ) { if ( ! isset ( $ fieldMap2 [ $ responseName ] ) ) { continue ; } $ fields2 = $ fieldMap2 [ $ responseName ] ; $ fields1Length = count ( $ fields1 ) ; $ fields2Length = count ( $ fields2 ) ; for ( $ i = 0 ; $ i < $ fields1Length ; $ i ++ ) { for ( $ j = 0 ; $ j < $ fields2Length ; $ j ++ ) { $ conflict = $ this -> findConflict ( $ context , $ parentFieldsAreMutuallyExclusive , $ responseName , $ fields1 [ $ i ] , $ fields2 [ $ j ] ) ; if ( ! $ conflict ) { continue ; } $ conflicts [ ] = $ conflict ; } } } }
11535	public function bootstrap ( $ app ) { Yii :: beginProfile ( get_called_class ( ) ) ; Yii :: $ app -> modules = static :: getModules ( ) ; Yii :: $ app -> on ( \ yii \ base \ Application :: EVENT_BEFORE_REQUEST , [ $ this , 'beforeRequest' ] ) ; Yii :: endProfile ( get_called_class ( ) ) ; Yii :: trace ( "Registered " . count ( static :: getModules ( ) ) . " modules in " . get_called_class ( ) ) ; }
3129	private function loadItemData ( $ itemRef , $ path ) { $ cacheKey = $ itemRef . $ path ; if ( ! empty ( $ cacheKey ) && isset ( $ this -> dataCache [ $ itemRef . $ path ] ) ) { return $ this -> dataCache [ $ itemRef . $ path ] ; } $ directoryIds = explode ( '|' , $ itemRef ) ; if ( count ( $ directoryIds ) < 3 ) { if ( is_scalar ( $ itemRef ) ) { $ itemRefInfo = gettype ( $ itemRef ) . ': ' . strval ( $ itemRef ) ; } elseif ( is_object ( $ itemRef ) ) { $ itemRefInfo = gettype ( $ itemRef ) . ': ' . get_class ( $ itemRef ) ; } else { $ itemRefInfo = gettype ( $ itemRef ) ; } throw new \ common_exception_InconsistentData ( "The itemRef (value = '${itemRefInfo}') is not formatted correctly." ) ; } $ itemUri = $ directoryIds [ 0 ] ; $ userDataLang = \ common_session_SessionManager :: getSession ( ) -> getDataLanguage ( ) ; $ directory = \ tao_models_classes_service_FileStorage :: singleton ( ) -> getDirectoryById ( $ directoryIds [ 2 ] ) ; if ( $ directory -> has ( $ userDataLang ) ) { $ lang = $ userDataLang ; } elseif ( $ directory -> has ( DEFAULT_LANG ) ) { \ common_Logger :: d ( $ userDataLang . ' is not part of compilation directory for item : ' . $ itemUri . ' use ' . DEFAULT_LANG ) ; $ lang = DEFAULT_LANG ; } else { throw new \ common_Exception ( 'item : ' . $ itemUri . 'is neither compiled in ' . $ userDataLang . ' nor in ' . DEFAULT_LANG ) ; } try { $ content = $ directory -> read ( $ lang . DIRECTORY_SEPARATOR . $ path ) ; $ assetService = $ this -> getServiceManager ( ) -> get ( ItemAssetsReplacement :: SERVICE_ID ) ; $ jsonContent = json_decode ( $ content , true ) ; $ jsonAssets = [ ] ; if ( isset ( $ jsonContent [ 'assets' ] ) ) { foreach ( $ jsonContent [ 'assets' ] as $ type => $ assets ) { foreach ( $ assets as $ key => $ asset ) { $ jsonAssets [ $ type ] [ $ key ] = $ assetService -> postProcessAssets ( $ asset ) ; } } $ jsonContent [ "assets" ] = $ jsonAssets ; } $ this -> dataCache [ $ cacheKey ] = $ jsonContent ; return $ this -> dataCache [ $ cacheKey ] ; } catch ( \ FileNotFoundException $ e ) { throw new \ tao_models_classes_FileNotFoundException ( $ path . ' for item reference ' . $ itemRef ) ; } catch ( \ League \ Flysystem \ FileNotFoundException $ e ) { throw new \ tao_models_classes_FileNotFoundException ( $ path . ' for item reference ' . $ itemRef ) ; } }
11208	protected function getValue ( $ data , $ key = false ) { $ returnValue = $ data ; if ( $ key && is_object ( $ data ) ) { $ returnValue = $ data -> $ key ; } else if ( $ key && is_array ( $ data ) ) { $ returnValue = $ data [ $ key ] ; } return $ returnValue ; }
3381	public function hasRole ( $ role ) { if ( is_string ( $ role ) ) { return $ this -> roles -> contains ( 'name' , $ role ) ; } return ! ! $ role -> intersect ( $ this -> roles ) -> count ( ) ; }
10995	public function write ( string $ contents , int $ opts = 0 ) : bool { if ( $ this -> prepareWrite ( ) !== true ) { $ this -> error = "failed to write '{$this->path}; {$this->error}" ; return false ; } return $ this -> writeFile ( $ contents , $ opts ) ; }
3366	private static function apache_modules ( ) { $ mods = WP_CLI :: get_config ( 'apache_modules' ) ; if ( ! empty ( $ mods ) && ! function_exists ( 'apache_get_modules' ) ) { global $ is_apache ; $ is_apache = true ; $ _SERVER [ 'SCRIPT_FILENAME' ] = ABSPATH ; function apache_get_modules ( ) { return WP_CLI :: get_config ( 'apache_modules' ) ; } } }
6046	protected function registerPlugin ( $ name ) { $ view = $ this -> getView ( ) ; AdminUiAsset :: register ( $ view ) ; $ id = $ this -> options [ 'id' ] ; if ( $ this -> clientOptions !== false ) { $ options = empty ( $ this -> clientOptions ) ? '' : Json :: encode ( $ this -> clientOptions ) ; $ js = "jQuery('#$id').$name($options);" ; $ view -> registerJs ( $ js ) ; } if ( ! empty ( $ this -> clientEvents ) ) { $ js = [ ] ; foreach ( $ this -> clientEvents as $ event => $ handler ) { $ js [ ] = "jQuery('#$id').on('$event', $handler);" ; } $ view -> registerJs ( implode ( "\n" , $ js ) ) ; } }
10302	private function writePrintSettings ( $ objWriter ) { $ objWriter -> startElement ( 'c:printSettings' ) ; $ objWriter -> startElement ( 'c:headerFooter' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:pageMargins' ) ; $ objWriter -> writeAttribute ( 'footer' , 0.3 ) ; $ objWriter -> writeAttribute ( 'header' , 0.3 ) ; $ objWriter -> writeAttribute ( 'r' , 0.7 ) ; $ objWriter -> writeAttribute ( 'l' , 0.7 ) ; $ objWriter -> writeAttribute ( 't' , 0.75 ) ; $ objWriter -> writeAttribute ( 'b' , 0.75 ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:pageSetup' ) ; $ objWriter -> writeAttribute ( 'orientation' , 'portrait' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; }
3368	public function generateFromMetadata ( array $ metadata ) { $ this -> metadata = $ metadata ; $ this -> visitedAssociations = [ ] ; $ str = [ ] ; foreach ( $ metadata as $ class ) { $ parent = $ this -> getParent ( $ class ) ; if ( $ parent ) { $ str [ ] = $ this -> getClassString ( $ parent ) . '^' . $ this -> getClassString ( $ class ) ; } $ associations = $ class -> getAssociationNames ( ) ; if ( empty ( $ associations ) && ! isset ( $ this -> visitedAssociations [ $ class -> getName ( ) ] ) ) { $ str [ ] = $ this -> getClassString ( $ class ) ; continue ; } foreach ( $ associations as $ associationName ) { if ( $ parent && in_array ( $ associationName , $ parent -> getAssociationNames ( ) ) ) { continue ; } if ( $ this -> visitAssociation ( $ class -> getName ( ) , $ associationName ) ) { $ str [ ] = $ this -> getAssociationString ( $ class , $ associationName ) ; } } } return implode ( ',' , $ str ) ; }
9894	public function add ( $ item ) { if ( $ item instanceof ShippingMethodInterface ) { $ this -> items [ ] = $ item ; } else { $ this -> items [ ] = new Item ( $ item ) ; } }
3134	public function getItemData ( RunnerServiceContext $ context , $ itemRef ) { if ( $ context instanceof QtiRunnerServiceContext ) { return $ this -> loadItemData ( $ itemRef , QtiJsonItemCompiler :: ITEM_FILE_NAME ) ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'getItemData' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } }
3955	public function getVariantBase ( ) { if ( $ this -> getMetaModel ( ) -> hasVariants ( ) && ! $ this -> isVariantBase ( ) ) { return $ this -> getMetaModel ( ) -> findById ( $ this -> get ( 'vargroup' ) ) ; } return $ this ; }
10822	public static function block ( $ messages , $ style ) { if ( is_string ( $ messages ) ) { $ messages = [ $ messages ] ; } if ( count ( $ messages ) > 0 ) { self :: writeln ( str_repeat ( ' ' , self :: $ lineLength ) , $ style ) ; foreach ( $ messages as $ message ) { $ message = ' ' . $ message ; while ( strlen ( $ message ) < self :: $ lineLength ) { $ message .= ' ' ; } self :: writeln ( $ message , $ style ) ; } self :: writeln ( str_repeat ( ' ' , self :: $ lineLength ) , $ style ) ; } }
6470	public function parseAcceptLanguageHeader ( HttpHeaders $ headers ) : array { $ headerValues = [ ] ; if ( ! $ headers -> tryGet ( 'Accept-Language' , $ headerValues ) ) { return [ ] ; } $ parsedHeaderValues = [ ] ; $ numHeaderValues = count ( $ headerValues ) ; for ( $ i = 0 ; $ i < $ numHeaderValues ; $ i ++ ) { $ parsedHeaderParameters = $ this -> parseParameters ( $ headers , 'Accept-Language' , $ i ) ; $ language = $ parsedHeaderParameters -> getKeys ( ) [ 0 ] ; $ parsedHeaderValues [ ] = new AcceptLanguageHeaderValue ( $ language , $ parsedHeaderParameters ) ; } return $ parsedHeaderValues ; }
9927	private function cleanUnwanted ( Parameters $ params , $ permitted ) { foreach ( $ params -> toArray ( ) as $ key => $ value ) { if ( is_array ( $ value ) && ! is_int ( $ key ) ) { if ( ! array_key_exists ( $ key , $ permitted ) ) { $ this -> handleUnpermittedParam ( $ key , $ params ) ; } } elseif ( ! is_int ( $ key ) && ! in_array ( $ key , $ permitted ) && ! array_key_exists ( $ key , $ permitted ) ) { $ this -> handleUnpermittedParam ( $ key , $ params ) ; } } }
12524	public function deserializeJSON ( $ jsonString ) { $ data = json_decode ( $ jsonString ) ; $ this -> setContent ( $ data -> content ) ; $ this -> setContext ( $ data -> context ) ; }
6370	public static function forMap ( array $ map ) : callable { return function ( $ index ) use ( $ map ) { Preconditions :: checkArgument ( array_key_exists ( $ index , $ map ) , "The given key '%s' does not exist in the map" , $ index ) ; return $ map [ $ index ] ; } ; }
3157	public function storeResponseVariable ( RunnerServiceContext $ context , $ itemUri , $ variableIdentifier , $ variableValue ) { $ this -> assertQtiRunnerServiceContext ( $ context ) ; $ metaVariable = $ this -> getResponseVariable ( $ variableIdentifier , $ variableValue ) ; return $ this -> storeVariable ( $ context , $ itemUri , $ metaVariable ) ; }
7966	public function getProperties ( $ billingAccount ) { if ( ! $ billingAccount ) throw new BadMethodCallException ( 'Parameter $billingAccount is missing.' ) ; try { $ r = $ this -> get ( 'telephony/' . $ billingAccount ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new TelephonyException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
12951	public function afterDelete ( ) { if ( ! empty ( $ this -> _tagsForDelete ) ) { $ relation = $ this -> owner -> getRelation ( 'tagsList' , false ) ; if ( $ relation instanceof ActiveQuery ) { $ class = $ relation -> modelClass ; $ class :: updateAllCounters ( [ 'count' => - 1 ] , [ 'in' , $ class :: primaryKey ( ) , $ this -> _tagsForDelete ] ) ; $ this -> owner -> getDb ( ) -> createCommand ( ) -> delete ( $ relation -> via -> from [ 0 ] , [ key ( $ relation -> via -> link ) => $ this -> owner -> getPrimaryKey ( ) ] ) -> execute ( ) ; } $ this -> _tagsForDelete = [ ] ; } }
8885	private function send ( ) { $ ch = curl_init ( $ this -> url ) ; curl_setopt ( $ ch , CURLOPT_HEADER , 1 ) ; curl_setopt ( $ ch , CURLOPT_POST , 1 ) ; curl_setopt ( $ ch , CURLOPT_TIMEOUT , 60 ) ; curl_setopt ( $ ch , CURLOPT_RETURNTRANSFER , 1 ) ; curl_setopt ( $ ch , CURLOPT_SSL_VERIFYPEER , 0 ) ; curl_setopt ( $ ch , CURLOPT_SSL_VERIFYHOST , 0 ) ; curl_setopt ( $ ch , CURLOPT_POSTFIELDS , $ this -> xml ) ; $ result = curl_exec ( $ ch ) ; $ this -> xml = strstr ( $ result , '<?' ) ; $ this -> xml_result = new \ SimpleXMLElement ( $ this -> xml ) ; return $ this -> parseResult ( ) ; }
1807	public function storeDateAdded ( $ dc ) { if ( ! $ dc instanceof Contao \ DataContainer ) { return ; } if ( ! $ dc -> activeRecord || $ dc -> activeRecord -> dateAdded > 0 ) { return ; } if ( $ dc -> activeRecord -> lastLogin > 0 ) { $ time = $ dc -> activeRecord -> lastLogin ; } else { $ time = time ( ) ; } $ this -> Database -> prepare ( "UPDATE tl_member SET dateAdded=? WHERE id=?" ) -> execute ( $ time , $ dc -> id ) ; }
9441	public function get ( ) { if ( $ this -> range -> as_integer ) { return mt_rand ( $ this -> range -> min , $ this -> range -> max ) ; } else { return mt_rand ( 0 , mt_getrandmax ( ) ) / mt_getrandmax ( ) ; } }
10466	public function onModify ( ItemPipelineEvent $ event ) { $ item = $ event -> getItem ( ) ; if ( $ item instanceof ImportItem ) { $ this -> modify ( $ item , $ event ) ; } elseif ( $ item instanceof SyncExecuteItem ) { $ syncStorageData = $ item -> getSyncStorageData ( ) ; if ( $ syncStorageData [ 'type' ] !== ActionTypes :: DELETE ) { $ this -> modify ( $ item , $ event ) ; } else { ItemSkipper :: skip ( $ event , 'Delete item with id = ' . $ syncStorageData [ 'id' ] ) ; } } else { $ this -> log ( 'The type of provided item is not ImportItem or SyncExecuteItem.' , LogLevel :: ERROR ) ; } }
637	public function truncateTable ( $ table ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> truncateTable ( $ table ) ; return $ this -> setSql ( $ sql ) ; }
8001	public function calculateChallengeResponseData ( HashCredentialInterface $ hash_credential , $ data ) { $ padded_hash = str_pad ( $ hash_credential -> getValue ( ) , static :: DESL_FULL_KEY_LENGTH , static :: NULL_PAD_CHARACTER ) ; $ key_blocks = str_split ( $ padded_hash , static :: DESL_KEY_BLOCK_SEGMENT_LENGTH ) ; $ binary_data = array_reduce ( $ key_blocks , function ( $ result , $ key_block ) use ( $ data ) { return $ result . $ this -> des_encrypter -> encrypt ( $ key_block , $ data , CipherMode :: ECB , '' ) ; } , '' ) ; return $ binary_data ; }
5617	public function getTotalSize ( ) { if ( ! isset ( $ this -> _size ) ) { $ size = $ this -> getSize ( ) ; if ( ! $ this -> isLeaf ( ) ) { foreach ( $ this -> getChildren ( ) as $ child ) { $ size += $ child -> getTotalSize ( ) ; } } $ this -> _size = $ size ; } return $ this -> _size ; }
11918	public function register ( callable $ inject ) : void { $ reflection = new ReflectionFunction ( $ inject ) ; $ parameters = $ reflection -> getParameters ( ) ; foreach ( $ parameters as $ parameter ) { $ key = $ parameter -> name ; $ getter = function ( $ c ) use ( $ reflection , $ parameters , $ key ) { if ( isset ( $ c -> delegate ) ) { try { return $ c -> delegate -> get ( $ key ) ; } catch ( NotFoundExceptionInterface $ e ) { } } $ args = [ ] ; foreach ( $ parameters as $ param ) { if ( ! $ param -> isPassedByReference ( ) ) { $ args [ ] = $ c -> get ( $ param -> name ) ; } else { $ { $ param -> name } = null ; $ args [ $ param -> name ] = & $ { $ param -> name } ; } } $ reflection -> invokeArgs ( $ args ) ; foreach ( $ args as $ found => $ value ) { if ( ! is_numeric ( $ found ) && $ found == $ key ) { $ c :: $ map [ $ found ] = $ value ; } } if ( array_key_exists ( $ key , $ args ) ) { return $ args [ $ key ] ; } throw new NotFoundException ( $ key ) ; } ; static :: $ map [ $ key ] = new ReflectionFunction ( $ getter ) ; } }
10509	public function attach ( \ SplObserver $ observer , $ eventName = Null , $ function = Null , $ order = Null ) { $ newEventAttach = new \ stdClass ( ) ; $ newEventAttach -> observer = $ observer ; $ newEventAttach -> function = $ function ; $ newEventAttach -> eventName = $ eventName ; $ newEventAttach -> order = $ order ; $ this -> _observers -> attach ( $ newEventAttach ) ; }
4208	private function isObjExcluded ( $ obj ) { if ( \ in_array ( \ get_class ( $ obj ) , $ this -> abstracter -> getCfg ( 'objectsExclude' ) ) ) { return true ; } foreach ( $ this -> abstracter -> getCfg ( 'objectsExclude' ) as $ exclude ) { if ( \ is_subclass_of ( $ obj , $ exclude ) ) { return true ; } } return false ; }
10380	protected static function is_modified_hash ( $ url , $ path ) { if ( self :: is_external_url ( $ url ) ) { if ( sha1_file ( $ url ) !== sha1_file ( $ path ) ) { self :: $ changes = true ; return self :: $ changes ; } } return false ; }
39	protected function generatePackageTree ( PackageInterface $ package , RepositoryInterface $ installedRepo , RepositoryInterface $ distantRepos ) { $ requires = $ package -> getRequires ( ) ; ksort ( $ requires ) ; $ children = array ( ) ; foreach ( $ requires as $ requireName => $ require ) { $ packagesInTree = array ( $ package -> getName ( ) , $ requireName ) ; $ treeChildDesc = array ( 'name' => $ requireName , 'version' => $ require -> getPrettyConstraint ( ) , ) ; $ deepChildren = $ this -> addTree ( $ requireName , $ require , $ installedRepo , $ distantRepos , $ packagesInTree ) ; if ( $ deepChildren ) { $ treeChildDesc [ 'requires' ] = $ deepChildren ; } $ children [ ] = $ treeChildDesc ; } $ tree = array ( 'name' => $ package -> getPrettyName ( ) , 'version' => $ package -> getPrettyVersion ( ) , 'description' => $ package -> getDescription ( ) , ) ; if ( $ children ) { $ tree [ 'requires' ] = $ children ; } return $ tree ; }
11145	protected function scanDir ( $ dir ) { $ result = array ( ) ; $ list = $ this -> scanDirExec ( $ dir ) ; foreach ( $ list as $ element ) { $ elementPath = $ dir . DIRECTORY_SEPARATOR . $ element ; if ( is_file ( $ elementPath ) ) { $ fileInfo = pathinfo ( $ element ) ; if ( in_array ( $ fileInfo [ 'extension' ] , $ this -> getAllowedFileExtensions ( ) ) ) { $ result [ ] = $ this -> getNameSpace ( ) . "\\" . $ fileInfo [ 'filename' ] ; } } } return $ result ; }
1394	public function withMediaType ( string $ mediaType ) : self { if ( ! $ encoding = $ this -> api -> getEncodings ( ) -> find ( $ mediaType ) ) { throw new \ InvalidArgumentException ( "Media type {$mediaType} is not valid for API {$this->api->getName()}." ) ; } $ codec = $ this -> factory -> createCodec ( $ this -> api -> getContainer ( ) , $ encoding , null ) ; return $ this -> withCodec ( $ codec ) ; }
9783	public function parseExpression ( ) { $ token = $ this -> peek ( ) ; $ type = $ token [ 0 ] ; switch ( $ type ) { case 'IF_OPEN' : return $ this -> parseIf ( ) ; case 'FOR_OPEN' : return $ this -> parseFor ( ) ; case 'FILTERED_VALUE' : return $ this -> parseFilteredValue ( ) ; case 'VALUE' : return $ this -> parseValue ( ) ; case 'HTML' : return $ this -> parseHTML ( ) ; case 'ESCAPE' : return $ this -> parseEscape ( ) ; case 'INCLUDE' : return $ this -> parseInclude ( ) ; default : throw new SyntaxErrorException ( "Could not parse expression, invalid token '$type'" ) ; } }
4796	protected function execute ( ) { if ( ! isset ( $ this -> rows ) ) { $ result = false ; $ exception = null ; $ parameters = array ( ) ; foreach ( array_merge ( $ this -> select , array ( $ this , $ this -> group , $ this -> having ) , $ this -> order , $ this -> unionOrder ) as $ val ) { if ( ( $ val instanceof NotORM_Literal || $ val instanceof self ) && $ val -> parameters ) { $ parameters = array_merge ( $ parameters , $ val -> parameters ) ; } } try { $ result = $ this -> query ( $ this -> __toString ( ) , $ parameters ) ; } catch ( PDOException $ exception ) { } if ( ! $ result ) { if ( ! $ this -> select && $ this -> accessed ) { $ this -> accessed = '' ; $ this -> access = array ( ) ; $ result = $ this -> query ( $ this -> __toString ( ) , $ parameters ) ; } elseif ( $ exception ) { throw $ exception ; } } $ this -> rows = array ( ) ; if ( $ result ) { $ result -> setFetchMode ( PDO :: FETCH_ASSOC ) ; foreach ( $ result as $ key => $ row ) { if ( isset ( $ row [ $ this -> primary ] ) ) { $ key = $ row [ $ this -> primary ] ; if ( ! is_string ( $ this -> access ) ) { $ this -> access [ $ this -> primary ] = true ; } } if ( $ this -> notORM -> isKeepPrimaryKeyIndex ) { $ this -> rows [ $ key ] = $ row ; } else { $ this -> rows [ ] = $ row ; } } } $ this -> data = $ this -> rows ; } }
3534	public static function createNewUser ( $ username , $ individualGroupAssignmentOptions = null ) { if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: beginProfile ( 'createNewUser' , static :: YII2_PROFILE_NAME . 'createNewUser' ) ; } $ userObjectDb = new static ( ) ; $ userObjectDb -> username = $ username ; $ userObjectDb -> setIndividualGroupAssignmentOptions ( $ individualGroupAssignmentOptions ) ; if ( $ userObjectDb -> queryLdapUserObject ( ) == null ) { $ userObjectDb = null ; } else { $ roles = $ userObjectDb -> updateGroupAssignment ( ) ; if ( count ( $ roles ) > 0 || static :: getGroupAssigmentOptions ( 'LOGIN_POSSIBLE_WITH_ROLE_ASSIGNED_MATCHING_REGEX' , $ userObjectDb -> individualGroupAssignmentOptions ) == null ) { $ userObjectDb -> generateAuthKey ( ) ; $ userObjectDb -> updateAccountStatus ( ) ; $ userObjectDb -> save ( ) ; } else { $ userObjectDb = null ; } } if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: endProfile ( 'createNewUser' , static :: YII2_PROFILE_NAME . 'createNewUser' ) ; } return $ userObjectDb ; }
11324	public static function convertCase ( $ string , $ toCase ) { $ str = strtolower ( ltrim ( preg_replace ( [ '/[A-Z]/' , '/[_]/' ] , [ ' $0' , ' ' ] , $ string ) ) ) ; switch ( strtoupper ( $ toCase ) ) { case 'PASCAL' : return str_replace ( ' ' , '' , ucwords ( $ str ) ) ; case 'CAMEL' : return lcfirst ( str_replace ( ' ' , '' , ucwords ( $ str ) ) ) ; default : return str_replace ( ' ' , '_' , $ str ) ; } }
3825	protected function compile ( ) { $ objItemRenderer = new ItemList ( ) ; $ this -> Template -> searchable = ! $ this -> metamodel_donotindex ; $ sorting = $ this -> metamodel_sortby ; $ direction = $ this -> metamodel_sortby_direction ; if ( $ this -> metamodel_sort_override ) { if ( \ Input :: get ( 'orderBy' ) ) { $ sorting = \ Input :: get ( 'orderBy' ) ; } if ( \ Input :: get ( 'orderDir' ) ) { $ direction = \ Input :: get ( 'orderDir' ) ; } } $ objItemRenderer -> setServiceContainerFallback ( function ( ) { return $ this -> getServiceContainer ( ) ; } ) -> setFactory ( System :: getContainer ( ) -> get ( 'metamodels.factory' ) ) -> setFilterFactory ( System :: getContainer ( ) -> get ( 'metamodels.filter_setting_factory' ) ) -> setRenderSettingFactory ( System :: getContainer ( ) -> get ( 'metamodels.render_setting_factory' ) ) -> setEventDispatcher ( System :: getContainer ( ) -> get ( 'event_dispatcher' ) ) -> setMetaModel ( $ this -> metamodel , $ this -> metamodel_rendersettings ) -> setLimit ( $ this -> metamodel_use_limit , $ this -> metamodel_offset , $ this -> metamodel_limit ) -> setPageBreak ( $ this -> perPage ) -> setSorting ( $ sorting , $ direction ) -> setFilterSettings ( $ this -> metamodel_filtering ) -> setFilterParameters ( StringUtil :: deserialize ( $ this -> metamodel_filterparams , true ) , $ this -> getFilterParameters ( $ objItemRenderer ) ) -> setMetaTags ( $ this -> metamodel_meta_title , $ this -> metamodel_meta_description ) ; $ this -> Template -> items = \ StringUtil :: encodeEmail ( $ objItemRenderer -> render ( $ this -> metamodel_noparsing , $ this ) ) ; $ this -> Template -> numberOfItems = $ objItemRenderer -> getItems ( ) -> getCount ( ) ; $ this -> Template -> pagination = $ objItemRenderer -> getPagination ( ) ; }
7507	function getTokenString ( $ start_offset = 0 , $ end_offset = 0 ) { $ token_start = ( ( is_int ( $ this -> token_start ) ) ? $ this -> token_start : $ this -> pos ) + $ start_offset ; $ len = $ this -> pos - $ token_start + 1 + $ end_offset ; return ( ( $ len > 0 ) ? substr ( $ this -> doc , $ token_start , $ len ) : '' ) ; }
132	public function disablePlugins ( ) { foreach ( $ this -> installers as $ i => $ installer ) { if ( ! $ installer instanceof PluginInstaller ) { continue ; } unset ( $ this -> installers [ $ i ] ) ; } }
7889	public function make ( $ date , $ level = 'all' ) { $ raw = $ this -> filesystem -> read ( $ date ) ; $ levels = $ this -> levels ; return new Log ( $ raw , $ levels , $ level ) ; }
3198	protected function checkTimestampCoherence ( $ points , $ timestamp ) { foreach ( $ points as $ point ) { if ( $ point -> getTimestamp ( ) > $ timestamp ) { throw new InconsistentRangeException ( 'A new TimePoint cannot be set before an existing one!' ) ; } } }
6181	protected function getSeverity ( $ errorCode ) { if ( isset ( $ this -> severityMapping [ $ errorCode ] ) ) { return $ this -> severityMapping [ $ errorCode ] ; } else { return $ this -> severityMapping [ Logger :: ERROR ] ; } }
12365	public function init ( ) { $ config = new Zend_Config_Ini ( $ this -> config_path == null ? APPLICATION_PATH . DS . "configs" . DS . "secret.ini" : $ config_path , APPLICATION_ENV ) ; $ this -> setConsumer ( new Zend_Oauth_Consumer ( array ( 'callbackUrl' => $ config -> oauth -> callback , 'siteUrl' => $ config -> oauth -> siteurl , 'consumerKey' => $ config -> oauth -> consumerkey , 'consumerSecret' => $ config -> oauth -> consumersecret ) ) ) ; }
11048	function add_system_var ( & $ datatree , $ index , $ last , $ key ) { $ datatree -> _key = $ key ; $ datatree -> _index = $ index ; $ datatree -> _rank = $ index + 1 ; $ datatree -> _odd = $ datatree -> _not_even = ( 1 == $ datatree -> _rank % 2 ) ; $ datatree -> _even = $ datatree -> _not_odd = ( 0 == $ datatree -> _rank % 2 ) ; $ datatree -> _first = ( 0 == $ index ) ; $ datatree -> _middle = ! $ datatree -> _first && ! $ last ; $ datatree -> _last = $ last ; $ datatree -> _not_first = ! $ datatree -> _first ; $ datatree -> _not_last = ! $ last ; $ datatree -> _not_middle = ! $ datatree -> _middle ; }
5880	protected static function accessProtectedProperty ( $ object , $ propertyName ) { $ className = get_class ( $ object ) ; if ( ! isset ( static :: $ reflectedClasses [ $ className ] ) ) { static :: $ reflectedClasses [ $ className ] = new \ ReflectionClass ( $ className ) ; } $ class = static :: $ reflectedClasses [ $ className ] ; $ property = $ class -> getProperty ( $ propertyName ) ; $ property -> setAccessible ( true ) ; return $ property -> getValue ( $ object ) ; }
3961	private function variantCssClass ( ) { if ( $ this -> isVariant ( ) ) { return 'variant' ; } if ( $ this -> isVariantBase ( ) ) { $ result = 'varbase' ; if ( 0 !== $ this -> getVariants ( null ) -> getCount ( ) ) { $ result .= ' varbase-with-variants' ; } return $ result ; } return '' ; }
7821	public function update ( $ pipeline , array $ attachments , array $ detachments ) { $ this -> detach ( $ this -> pipelines [ $ pipeline ] , $ detachments ) ; $ this -> attach ( $ this -> pipelines [ $ pipeline ] , $ attachments ) ; $ this -> refreshPipelines ( ) ; }
11725	public function assign ( string $ key , $ value , bool $ global = false ) { if ( $ global === false ) { $ this -> vars [ $ key ] = $ value ; } else { View :: $ global_vars [ $ key ] = $ value ; } return $ this ; }
2705	public function execute ( ) { $ result = $ this -> resultJsonFactory -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ snippets = $ this -> config -> getVclSnippets ( Config :: VCL_AUTH_SNIPPET_PATH ) ; foreach ( $ snippets as $ key => $ value ) { $ name = Config :: FASTLY_MAGENTO_MODULE . '_basic_auth_' . $ key ; $ status = $ this -> api -> hasSnippet ( $ activeVersion , $ name ) ; if ( $ status == false ) { return $ result -> setData ( [ 'status' => false ] ) ; } } return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
11925	public function generate ( string $ outputDir ) : array { $ generatedFiles = [ ] ; foreach ( $ this -> generators as $ generator ) { $ this -> logger -> info ( 'Running generator ' . get_class ( $ generator ) ) ; $ result = $ generator -> generate ( ) ; foreach ( $ result -> all ( ) as $ phpFile ) { $ path = str_replace ( [ '/' , "\\" ] , DIRECTORY_SEPARATOR , $ outputDir . '/' . $ phpFile -> getFqcn ( ) -> getNamespace ( ) ) ; BaseUtil :: ensureDirectory ( $ path , 0711 ) ; $ filePath = $ path . DIRECTORY_SEPARATOR . $ phpFile -> getFqcn ( ) -> getName ( ) . '.php' ; $ this -> logger -> info ( 'Writing to file ' . $ filePath ) ; file_put_contents ( $ filePath , $ phpFile -> getText ( ) ) ; $ generatedFiles [ ] = new GeneratedFile ( $ filePath , $ phpFile ) ; } } return $ generatedFiles ; }
5585	public function isClickable ( $ label ) { return $ this -> isSubmit ( $ label ) || ( $ this -> getLink ( $ label ) !== false ) || $ this -> isImage ( $ label ) ; }
12655	public function addTextContainer ( $ name , $ content , $ language ) { $ allTexts = $ this -> getPageTexts ( $ language ) ; if ( isset ( $ allTexts [ $ name ] ) ) { throw new \ Exception ( "Text container name already used." ) ; } $ this -> contents [ $ language ] [ $ name ] = array ( 'id' => $ name , 'name' => $ name , 'content' => $ content , 'outdated' => false ) ; $ this -> writeTextsToFile ( $ language ) ; if ( $ language === $ this -> baseLang ) { $ this -> setExtraLanguagesOutdated ( $ name , $ content ) ; } return $ this -> contents [ $ language ] [ $ name ] ; }
8475	public function debug ( $ scope , $ message , $ context = [ ] , $ config = [ ] ) { return $ this -> write ( 'debug' , $ scope , $ message , $ context , $ config ) ; }
6328	private function getColumnsSql ( ) { $ columnTypeMapper = new ColumnTypeMapper ( ) ; foreach ( $ this -> table -> getConstraints ( ) as $ constraint ) { if ( $ constraint instanceof PrimaryKey ) { $ primaryKey = $ constraint ; } } if ( ! isset ( $ primaryKey ) ) { $ primaryKey = new PrimaryKey ( ) ; $ primaryKey -> setTable ( $ this -> table ) ; $ this -> table -> addConstraint ( $ primaryKey ) ; } $ sql = '' ; if ( ! $ primaryKey -> isMulti ( ) && $ primaryKey -> isAutoCreateColumn ( ) ) { $ sql = sprintf ( '%s %s NOT NULL,' , $ primaryKey -> getColumns ( ) , $ primaryKey -> isAutoIncrement ( ) ? 'serial' : 'integer' ) ; } foreach ( $ this -> table -> getColumns ( ) as $ column ) { if ( $ column instanceof CustomColumn ) { $ columnType = $ column -> getType ( ) ; } else { $ columnType = $ columnTypeMapper -> getNative ( $ column -> getType ( ) ) ; } $ sql .= sprintf ( '%s %s%s %s %s,' , $ column -> getName ( ) , $ columnType , $ this -> getTypeConstraints ( $ column ) , $ column -> isNotNull ( ) ? 'NOT NULL' : '' , null === $ column -> getDefault ( ) ? '' : 'DEFAULT' . ' ' . $ this -> addQuotesIfNeeded ( $ column , $ column -> getDefault ( ) ) ) ; } return rtrim ( $ sql , ',' ) ; }
10227	public function pageFor ( $ model , $ itemId = 0 , ModelConfig $ config = null ) { $ modelName = $ this -> resolveModelName ( $ model ) ; $ item = $ this -> findItem ( $ modelName , $ itemId ) ; $ pageFactory = $ this -> app -> make ( 'Label305\AujaLaravel\Factory\PageFactory' ) ; return $ pageFactory -> create ( $ modelName , $ item , $ config ) ; }
188	private function getColumnDefinition ( $ table , $ column ) { $ row = $ this -> db -> createCommand ( 'SHOW CREATE TABLE ' . $ this -> db -> quoteTableName ( $ table ) ) -> queryOne ( ) ; if ( $ row === false ) { throw new Exception ( "Unable to find column '$column' in table '$table'." ) ; } if ( isset ( $ row [ 'Create Table' ] ) ) { $ sql = $ row [ 'Create Table' ] ; } else { $ row = array_values ( $ row ) ; $ sql = $ row [ 1 ] ; } $ sql = preg_replace ( '/^[^(]+\((.*)\).*$/' , '\1' , $ sql ) ; $ sql = str_replace ( ', [' , ",\n[" , $ sql ) ; if ( preg_match_all ( '/^\s*\[(.*?)\]\s+(.*?),?$/m' , $ sql , $ matches ) ) { foreach ( $ matches [ 1 ] as $ i => $ c ) { if ( $ c === $ column ) { return $ matches [ 2 ] [ $ i ] ; } } } return null ; }
2501	private function getFacetParams ( array $ facetBuilders ) { $ facetSets = array_map ( function ( $ facetBuilder ) { return $ this -> facetBuilderVisitor -> visitBuilder ( $ facetBuilder , spl_object_hash ( $ facetBuilder ) ) ; } , $ facetBuilders ) ; $ facetParams = array ( ) ; foreach ( $ facetSets as $ facetSet ) { foreach ( $ facetSet as $ key => $ value ) { if ( isset ( $ facetParams [ $ key ] ) ) { if ( ! is_array ( $ facetParams [ $ key ] ) ) { $ facetParams [ $ key ] = array ( $ facetParams [ $ key ] ) ; } $ facetParams [ $ key ] [ ] = $ value ; } else { $ facetParams [ $ key ] = $ value ; } } } return $ facetParams ; }
8260	protected function saveLoginInfo ( $ resourceOwner ) { $ u = new User ( ) ; $ u -> setAuthenticated ( true ) ; $ u -> setAuthenticator ( $ this -> getName ( ) ) ; $ attrMap = $ this -> providerConfig [ 'attributeMap' ] ; $ userIdAttr = $ attrMap [ 'userId' ] ; $ userId = $ this -> getResourceAttribute ( $ userIdAttr , $ resourceOwner ) ; $ u -> setId ( $ userId ) ; unset ( $ attrMap [ 'userId' ] ) ; if ( isset ( $ attrMap [ 'displayName' ] ) ) { $ name = $ this -> getResourceAttribute ( $ attrMap [ 'displayName' ] , $ resourceOwner ) ; $ u -> setDisplayName ( $ name ) ; unset ( $ attrMap [ 'displayName' ] ) ; } foreach ( $ attrMap as $ mapKey => $ mapValue ) { $ value = $ this -> getResourceAttribute ( $ mapValue , $ resourceOwner ) ; $ u -> setAttribute ( $ mapKey , $ value ) ; } $ u -> setGroups ( $ this -> providerConfig [ 'default' ] [ 'groups' ] ) ; foreach ( $ this -> providerConfig [ 'default' ] [ 'attributes' ] as $ key => $ value ) { if ( null === $ u -> getAttribute ( $ key ) ) { $ u -> setAttribute ( $ key , $ value ) ; } } $ this -> picoAuth -> setUser ( $ u ) ; $ this -> picoAuth -> afterLogin ( ) ; }
166	protected function loadMessagesFromFile ( $ messageFile , $ category ) { if ( is_file ( $ messageFile ) ) { if ( $ this -> useMoFile ) { $ gettextFile = new GettextMoFile ( [ 'useBigEndian' => $ this -> useBigEndian ] ) ; } else { $ gettextFile = new GettextPoFile ( ) ; } $ messages = $ gettextFile -> load ( $ messageFile , $ category ) ; if ( ! is_array ( $ messages ) ) { $ messages = [ ] ; } return $ messages ; } return null ; }
5861	protected function compileRulesets ( array $ rulesets ) { $ out = [ ] ; $ elements = $ rulesets [ 'data' ] [ 'sDEF' ] [ 'lDEF' ] [ 'ruleset' ] [ 'el' ] ; foreach ( $ elements as $ container ) { if ( isset ( $ container [ 'container' ] [ 'el' ] ) ) { $ values = [ ] ; foreach ( $ container [ 'container' ] [ 'el' ] as $ key => $ value ) { if ( $ key === 'title' ) { continue ; } $ values [ $ key ] = $ value [ 'vDEF' ] ; } $ out [ ] = $ this -> expandValuesInRuleset ( $ values ) ; } } return $ out ; }
10843	protected function refreshProductVariantSellPrice ( VariantInterface $ variant ) { $ product = $ variant -> getProduct ( ) ; $ sellPrice = $ product -> getSellPrice ( ) ; $ grossAmount = $ this -> calculateAttributePrice ( $ variant , $ sellPrice -> getGrossAmount ( ) ) ; $ discountedGrossAmount = $ this -> calculateAttributePrice ( $ variant , $ sellPrice -> getDiscountedGrossAmount ( ) ) ; $ taxRate = $ product -> getSellPriceTax ( ) -> getValue ( ) ; $ netAmount = TaxHelper :: calculateNetPrice ( $ grossAmount , $ taxRate ) ; $ discountedNetAmount = TaxHelper :: calculateNetPrice ( $ discountedGrossAmount , $ taxRate ) ; $ productAttributeSellPrice = $ variant -> getSellPrice ( ) ; $ productAttributeSellPrice -> setTaxRate ( $ taxRate ) ; $ productAttributeSellPrice -> setTaxAmount ( $ grossAmount - $ netAmount ) ; $ productAttributeSellPrice -> setGrossAmount ( $ grossAmount ) ; $ productAttributeSellPrice -> setNetAmount ( $ netAmount ) ; $ productAttributeSellPrice -> setDiscountedGrossAmount ( $ discountedGrossAmount ) ; $ productAttributeSellPrice -> setDiscountedTaxAmount ( $ discountedGrossAmount - $ discountedNetAmount ) ; $ productAttributeSellPrice -> setDiscountedNetAmount ( $ discountedNetAmount ) ; $ productAttributeSellPrice -> setValidFrom ( $ sellPrice -> getValidFrom ( ) ) ; $ productAttributeSellPrice -> setValidTo ( $ sellPrice -> getValidTo ( ) ) ; $ productAttributeSellPrice -> setCurrency ( $ sellPrice -> getCurrency ( ) ) ; }
1039	private static function printPath ( ? array $ path = null ) { $ pathStr = '' ; $ currentPath = $ path ; while ( $ currentPath ) { $ pathStr = ( is_string ( $ currentPath [ 'key' ] ) ? '.' . $ currentPath [ 'key' ] : '[' . $ currentPath [ 'key' ] . ']' ) . $ pathStr ; $ currentPath = $ currentPath [ 'prev' ] ; } return $ pathStr ? 'value' . $ pathStr : '' ; }
5899	public function listFunctionalities ( $ includeDeleted = false , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'includeDeleted' => $ includeDeleted ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/accounts/functionalities' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new Functionality ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
8750	public static function dumpValue ( $ value , $ containerVariable , array $ usedVariables ) : InlineEntryInterface { if ( is_array ( $ value ) ) { return self :: dumpArray ( $ value , $ containerVariable , $ usedVariables ) ; } elseif ( $ value instanceof ReferenceInterface ) { return self :: dumpReference ( $ value , $ containerVariable , $ usedVariables ) ; } elseif ( $ value instanceof DumpableInterface ) { return self :: dumpDefinition ( $ value , $ containerVariable , $ usedVariables ) ; } elseif ( is_object ( $ value ) || is_resource ( $ value ) ) { throw new \ RuntimeException ( 'Unable to dump a container if a parameter is an object or a resource.' ) ; } else { return new InlineEntry ( var_export ( $ value , true ) , null , $ usedVariables , false ) ; } }
12294	public function delete ( $ id ) { $ resource = $ this -> model -> find ( $ id ) ; if ( ! $ resource ) { return '' ; } return $ resource -> delete ( ) ; }
10247	public function getString ( $ type = 'letter' , $ desired_length = null ) { if ( empty ( $ desired_length ) ) { $ desired_length = $ this -> getInteger ( 1 , 50 ) ; } $ result = '' ; while ( strlen ( $ result ) < $ desired_length ) { if ( $ type == 'letter' ) { $ result .= $ this -> getLetter ( ) ; } elseif ( $ type == 'number' ) { $ result .= $ this -> getInteger ( 1 , 10 ) ; } else { $ result .= $ this -> getUniqueHash ( ) ; } } return substr ( $ result , 0 , $ desired_length ) ; }
4500	public function matches ( string $ selectors ) : bool { $ matches = $ this -> getRootDocument ( ) -> querySelectorAll ( $ selectors ) ; $ i = $ matches -> length ; while ( -- $ i >= 0 && $ matches -> item ( $ i ) !== $ this ) { ; } return ( $ i >= 0 ) ; }
12297	public function getRules ( array $ fields = [ ] ) { $ default_rules = $ this -> model -> getRules ( ) ; if ( count ( $ fields ) < 1 ) { return $ default_rules ; } foreach ( $ fields as $ field => $ rule ) { if ( is_int ( $ field ) ) { $ rules [ $ rule ] = $ default_rules [ $ rule ] ; continue ; } if ( ! key_exists ( $ field , $ default_rules ) ) { continue ; } $ default_rules [ $ field ] .= '|' . $ rule ; } $ rules = [ ] ; $ transformation = $ this -> model -> getTransformation ( ) ; foreach ( $ transformation as $ original => $ transformed ) { $ rules [ $ transformed ] = $ default_rules [ $ original ] ; } foreach ( $ fields as $ field => $ rule ) { if ( ! key_exists ( $ field , $ rules ) ) { continue ; } $ rules [ $ field ] .= '|' . $ rule ; } return $ rules ; }
1634	public function boot ( ) { $ this -> app [ 'auth' ] -> viaRequest ( 'api' , function ( $ request ) { if ( $ request -> input ( 'api_token' ) ) { return User :: where ( 'api_token' , $ request -> input ( 'api_token' ) ) -> first ( ) ; } } ) ; }
3503	private function prepareCurlResourceByRequest ( Request $ request ) : void { curl_setopt ( $ this -> resource , CURLOPT_URL , $ request -> getUrl ( ) ) ; curl_setopt ( $ this -> resource , CURLOPT_POSTFIELDS , $ request -> getContent ( ) ) ; if ( $ request -> getCertificate ( ) ) { curl_setopt ( $ this -> resource , CURLOPT_SSLCERT , $ request -> getCertificate ( ) ) ; curl_setopt ( $ this -> resource , CURLOPT_SSLCERTPASSWD , $ request -> getCertificatePassPhrase ( ) ) ; } $ inlineHeaders = [ ] ; foreach ( $ request -> getHeaders ( ) as $ name => $ value ) { $ inlineHeaders [ ] = sprintf ( '%s: %s' , $ name , $ value ) ; } curl_setopt ( $ this -> resource , CURLOPT_HTTPHEADER , $ inlineHeaders ) ; }
8292	protected function checkAccess ( $ url ) { foreach ( $ this -> modules as $ module ) { if ( false === $ module -> handleEvent ( 'checkAccess' , [ $ url ] ) ) { return false ; } } return true ; }
11198	public function delete ( $ name ) { $ name = $ this -> getName ( $ name ) ; $ resourceKey = $ name ; if ( is_numeric ( $ name ) ) { $ resourceKey = $ this -> fetchOffsetKey ( $ name ) ; } if ( $ this -> processDelete ( $ resourceKey ) ) { $ this -> contentModified = true ; $ this -> size -= 1 ; } }
8397	public function getDefinition ( ) : array { if ( $ this -> definition == null ) { $ data = Mapping :: get ( $ this -> mapping ) ; $ this -> definition = Config :: get ( $ data [ 'config' ] [ 'schema' ] ) ; } return $ this -> definition ; }
5588	public function setCookies ( array $ lstCookies ) { foreach ( $ lstCookies as $ aCookies ) { $ this -> cookie_jar -> setCookie ( $ aCookies [ 'name' ] , $ aCookies [ 'value' ] , $ aCookies [ 'host' ] , $ aCookies [ 'path' ] , $ aCookies [ 'expiry' ] ) ; } }
5902	public function retrieveGroup ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/accounts/groups/' . $ id . '' , $ parameters , $ cachePolicy ) ; $ result = new Group ( $ result ) ; return $ result ; }
5685	protected function getUrlFromLink ( $ link ) { $ url = $ this -> expandUrl ( $ link -> getHref ( ) ) ; if ( $ link -> getAttribute ( 'target' ) ) { $ url -> setTarget ( $ link -> getAttribute ( 'target' ) ) ; } return $ url ; }
5389	public function setValue ( $ value ) { if ( ! $ this -> valueIsPossible ( $ value ) ) { return false ; } $ index = false ; $ widgets = $ this -> getWidgets ( ) ; for ( $ i = 0 , $ count = count ( $ widgets ) ; $ i < $ count ; $ i ++ ) { if ( ! $ widgets [ $ i ] -> setValue ( $ value ) ) { $ widgets [ $ i ] -> setValue ( false ) ; } } return true ; }
9510	public function download ( Log $ log ) { $ this -> authorize ( LogViewerPolicy :: PERMISSION_DOWNLOAD ) ; return $ this -> logViewer -> download ( $ log -> date ) ; }
7241	private function getDefaultClasses ( ) { return [ 'address' => [ Cart \ Model \ CartInterface :: class => Cart \ Entity \ CartAddress :: class , Order \ Model \ OrderInterface :: class => Order \ Entity \ OrderAddress :: class , Quote \ Model \ QuoteInterface :: class => Quote \ Entity \ QuoteAddress :: class , ] , 'attachment' => [ Cart \ Model \ CartInterface :: class => Cart \ Entity \ CartAttachment :: class , Order \ Model \ OrderInterface :: class => Order \ Entity \ OrderAttachment :: class , Quote \ Model \ QuoteInterface :: class => Quote \ Entity \ QuoteAttachment :: class , ] , 'notification' => [ Cart \ Model \ CartInterface :: class => Cart \ Entity \ CartNotification :: class , Order \ Model \ OrderInterface :: class => Order \ Entity \ OrderNotification :: class , Quote \ Model \ QuoteInterface :: class => Quote \ Entity \ QuoteNotification :: class , ] , 'item' => [ Cart \ Model \ CartInterface :: class => Cart \ Entity \ CartItem :: class , Order \ Model \ OrderInterface :: class => Order \ Entity \ OrderItem :: class , Quote \ Model \ QuoteInterface :: class => Quote \ Entity \ QuoteItem :: class , ] , 'adjustment' => [ Cart \ Model \ CartInterface :: class => Cart \ Entity \ CartAdjustment :: class , Order \ Model \ OrderInterface :: class => Order \ Entity \ OrderAdjustment :: class , Quote \ Model \ QuoteInterface :: class => Quote \ Entity \ QuoteAdjustment :: class , ] , 'item_adjustment' => [ Cart \ Model \ CartItemInterface :: class => Cart \ Entity \ CartItemAdjustment :: class , Order \ Model \ OrderItemInterface :: class => Order \ Entity \ OrderItemAdjustment :: class , Quote \ Model \ QuoteItemInterface :: class => Quote \ Entity \ QuoteItemAdjustment :: class , ] , 'item_stock_assignment' => [ Order \ Model \ OrderItemInterface :: class => Order \ Entity \ OrderItemStockAssignment :: class , ] , 'payment' => [ Cart \ Model \ CartInterface :: class => Cart \ Entity \ CartPayment :: class , Order \ Model \ OrderInterface :: class => Order \ Entity \ OrderPayment :: class , Quote \ Model \ QuoteInterface :: class => Quote \ Entity \ QuotePayment :: class , ] , 'shipment' => [ Order \ Model \ OrderInterface :: class => Order \ Entity \ OrderShipment :: class , ] , 'shipment_item' => [ Order \ Model \ OrderShipmentInterface :: class => Order \ Entity \ OrderShipmentItem :: class , ] , 'invoice' => [ Order \ Model \ OrderInterface :: class => Order \ Entity \ OrderInvoice :: class , ] , 'invoice_line' => [ Order \ Model \ OrderInvoiceInterface :: class => Order \ Entity \ OrderInvoiceLine :: class , ] , ] ; }
12430	public function sort ( $ key , $ order = Sortable :: ASC ) { $ this -> criteria -> sort ( $ key , $ order ) ; return $ this ; }
12266	public function renderCmsBlocks ( array $ blocks , $ username , array $ options = array ( ) ) { $ tmp = array ( ) ; foreach ( $ blocks as $ block ) { $ tmp [ ] = $ this -> renderCmsBlock ( $ block , $ username , $ options ) ; } return implode ( "\n" , $ tmp ) ; }
4255	protected function buildFatal ( ) { $ haveFatal = isset ( $ this -> stats [ 'counts' ] [ 'fatal' ] ) ; if ( ! $ haveFatal ) { return '' ; } $ lastError = $ this -> errorHandler -> get ( 'lastError' ) ; $ isHtml = $ lastError [ 'isHtml' ] ; $ backtrace = $ lastError [ 'backtrace' ] ; $ html = '<h3>Fatal Error</h3>' ; $ html .= '<ul class="list-unstyled indent">' ; if ( \ count ( $ backtrace ) > 1 ) { $ table = $ this -> outputHtml -> buildTable ( $ backtrace , array ( 'attribs' => 'trace table-bordered' , 'caption' => 'trace' , 'columns' => array ( 'file' , 'line' , 'function' ) , ) ) ; $ html .= '<li>' . $ lastError [ 'message' ] . '</li>' ; $ html .= '<li>' . $ table . '</li>' ; if ( ! $ isHtml ) { $ html = \ str_replace ( $ lastError [ 'message' ] , \ htmlspecialchars ( $ lastError [ 'message' ] ) , $ html ) ; } } else { $ keysKeep = array ( 'typeStr' , 'message' , 'file' , 'line' ) ; $ lastError = \ array_intersect_key ( $ lastError , \ array_flip ( $ keysKeep ) ) ; $ html .= '<li>' . $ this -> outputHtml -> dump ( $ lastError ) . '</li>' ; if ( $ isHtml ) { $ html = \ str_replace ( \ htmlspecialchars ( $ lastError [ 'message' ] ) , $ lastError [ 'message' ] , $ html ) ; } } if ( ! \ extension_loaded ( 'xdebug' ) ) { $ html .= '<li>Want to see a backtrace here? Install <a target="_blank" href="https://xdebug.org/docs/install">xdebug</a> PHP extension.</li>' ; } $ html .= '</ul>' ; return $ html ; }
4327	public static function isList ( $ val ) { if ( ! \ is_array ( $ val ) ) { return false ; } $ keys = \ array_keys ( $ val ) ; foreach ( $ keys as $ i => $ key ) { if ( $ i != $ key ) { return false ; } } return true ; }
7832	protected function getSpacesByCore ( $ up = false ) { $ free = $ this -> getTotalWidth ( ) - $ this -> getBordersLength ( ) - $ this -> getCoreLength ( ) ; return $ free < 1 ? '' : str_repeat ( ' ' , $ this -> roundHalf ( $ free , $ up ) ) ; }
254	public static function end ( ) { if ( ! empty ( self :: $ stack ) ) { $ widget = array_pop ( self :: $ stack ) ; if ( get_class ( $ widget ) === get_called_class ( ) ) { if ( $ widget -> beforeRun ( ) ) { $ result = $ widget -> run ( ) ; $ result = $ widget -> afterRun ( $ result ) ; echo $ result ; } return $ widget ; } throw new InvalidCallException ( 'Expecting end() of ' . get_class ( $ widget ) . ', found ' . get_called_class ( ) ) ; } throw new InvalidCallException ( 'Unexpected ' . get_called_class ( ) . '::end() call. A matching begin() is not found.' ) ; }
10081	protected function registerManager ( ) { $ this -> app -> singleton ( 'auja' , function ( $ app ) { $ config = $ app [ 'config' ] [ 'auja-laravel' ] ? : $ app [ 'config' ] [ 'auja-laravel::config' ] ; return new Auja ( $ app , $ app [ 'auja.configurator' ] , $ config [ 'models' ] ) ; } ) ; $ this -> app -> bind ( 'Label305\AujaLaravel\Auja' , 'auja' ) ; }
1086	private function parseDocument ( ) { $ start = $ this -> lexer -> token ; $ this -> expect ( Token :: SOF ) ; $ definitions = [ ] ; do { $ definitions [ ] = $ this -> parseDefinition ( ) ; } while ( ! $ this -> skip ( Token :: EOF ) ) ; return new DocumentNode ( [ 'definitions' => new NodeList ( $ definitions ) , 'loc' => $ this -> loc ( $ start ) , ] ) ; }
4226	public function register ( ) { if ( $ this -> registered ) { return ; } $ this -> prevDisplayErrors = \ ini_set ( 'display_errors' , 0 ) ; $ this -> prevErrorHandler = \ set_error_handler ( array ( $ this , 'handleError' ) ) ; $ this -> prevExceptionHandler = \ set_exception_handler ( array ( $ this , 'handleException' ) ) ; $ this -> registered = true ; return ; }
75	public function seek ( $ offset ) { $ this -> rewind ( ) ; for ( $ i = 0 ; $ i < $ offset ; $ i ++ , $ this -> next ( ) ) ; }
3789	protected function getSetValues ( $ arrValue , $ intId , $ strLangCode ) { if ( ( $ arrValue !== null ) && ! is_array ( $ arrValue ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Invalid value provided: %s' , var_export ( $ arrValue , true ) ) ) ; } return array ( 'tstamp' => time ( ) , 'value' => ( string ) $ arrValue [ 'value' ] , 'att_id' => $ this -> get ( 'id' ) , 'langcode' => $ strLangCode , 'item_id' => $ intId , ) ; }
10264	public function getBank ( ) { $ bank_account = new Entities \ BankAccount ; $ bank_account -> type = $ this -> fromArray ( [ 'Checking' , 'Savings' ] ) ; $ bank_account -> name = $ this -> fromArray ( [ 'First National' , 'Arvest' , 'Regions' , 'Metropolitan' , 'Wells Fargo' ] ) ; $ bank_account -> account = $ this -> getInteger ( '1000' , '999999999' ) ; $ bank_account -> routing = $ this -> getBankNumber ( 'Routing' ) ; return $ bank_account ; }
3041	public function persist ( $ userId = null , $ callId = null ) { if ( $ userId && $ callId ) { $ keys = [ $ this -> getCacheKey ( $ userId , $ callId ) ] ; } else { $ keys = array_keys ( $ this -> cache ) ; } $ success = true ; foreach ( $ keys as $ key ) { if ( ! $ this -> persistCacheEntry ( $ key ) ) { $ success = false ; } } return $ success ; }
5542	protected function clearNestedFramesFocus ( ) { for ( $ i = 0 ; $ i < count ( $ this -> frames ) ; $ i ++ ) { $ this -> frames [ $ i ] -> clearFrameFocus ( ) ; } }
7974	public function getSender ( $ domain , $ sender ) { if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; if ( ! $ sender ) throw new BadMethodCallException ( 'Parameter $sender is missing.' ) ; $ sender = urlencode ( $ sender ) ; try { $ r = $ this -> get ( 'sms/' . $ domain . '/senders/' . $ sender ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new SmsException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
6392	public static function reverseOrder ( Comparator $ comparator = null ) : Comparator { if ( $ comparator === null ) { $ comparator = ComparableComparator :: instance ( ) ; } return new ReverseComparator ( $ comparator ) ; }
4430	protected function writeInstallerSummary ( $ errors ) { if ( ! $ errors ) { $ this -> writeSection ( 'You can now continue installation as per instructions in the README.md file!' ) ; return ; } $ this -> writeSection ( array ( 'The command was not able to install everything automatically.' , 'You must do the following changes manually.' , ) , 'error' ) ; $ this -> output -> writeln ( $ errors ) ; }
2373	public static function toHtml5 ( $ strString ) { $ arrPregReplace = array ( '/<(br|hr|img)([^>]*) \/>/i' => '<$1$2>' , '/ (cellpadding|cellspacing|border)="[^"]*"/' => '' , '/ rel="lightbox(\[([^\]]+)\])?"/' => ' data-lightbox="$2"' ) ; $ arrStrReplace = array ( '<u>' => '<span style="text-decoration:underline">' , '</u>' => '</span>' , ' target="_self"' => '' , ' onclick="window.open(this.href); return false"' => ' target="_blank"' , ' onclick="window.open(this.href);return false"' => ' target="_blank"' , ' onclick="window.open(this.href); return false;"' => ' target="_blank"' ) ; $ strString = preg_replace ( array_keys ( $ arrPregReplace ) , $ arrPregReplace , $ strString ) ; $ strString = str_ireplace ( array_keys ( $ arrStrReplace ) , $ arrStrReplace , $ strString ) ; return $ strString ; }
11631	private function getTransitions ( $ dsBegin , $ dsEnd ) { $ assetTypeId = $ this -> daoTypeAsset -> getIdByCode ( Cfg :: CODE_TYPE_ASSET_PV ) ; $ dateFrom = $ this -> hlpPeriod -> getTimestampFrom ( $ dsBegin ) ; $ dateTo = $ this -> hlpPeriod -> getTimestampNextFrom ( $ dsEnd ) ; $ query = $ this -> aQGetData -> build ( ) ; $ bind = [ $ this -> aQGetData :: BND_ASSET_TYPE_ID => $ assetTypeId , $ this -> aQGetData :: BND_DATE_FROM => $ dateFrom , $ this -> aQGetData :: BND_DATE_TO => $ dateTo ] ; $ conn = $ query -> getConnection ( ) ; $ rs = $ conn -> fetchAll ( $ query , $ bind ) ; $ result = [ ] ; foreach ( $ rs as $ one ) { $ item = new \ Praxigento \ BonusHybrid \ Service \ Calc \ PvWriteOff \ A \ Data \ Trans ( $ one ) ; $ result [ ] = $ item ; } return $ result ; }
1536	protected function fillRelationships ( $ record , Collection $ relationships , EncodingParametersInterface $ parameters ) { $ relationships -> filter ( function ( $ value , $ field ) use ( $ record ) { return $ this -> isFillableRelation ( $ field , $ record ) ; } ) -> each ( function ( $ value , $ field ) use ( $ record , $ parameters ) { $ this -> fillRelationship ( $ record , $ field , $ value , $ parameters ) ; } ) ; }
10526	public function setFieldFromData ( $ name ) { $ value = $ this -> getFieldFormData ( $ name ) ; return $ this -> setFieldValue ( $ name , $ value ) ; }
6952	private function isSaleItemCovered ( Common \ SaleItemInterface $ saleItem , array $ coveredIds ) { if ( $ saleItem -> isCompound ( ) && ! $ saleItem -> hasPrivateChildren ( ) ) { return true ; } if ( ! in_array ( $ saleItem -> getId ( ) , $ coveredIds , true ) ) { return false ; } foreach ( $ saleItem -> getChildren ( ) as $ child ) { if ( ! $ this -> isSaleItemCovered ( $ child , $ coveredIds ) ) { return false ; } } return true ; }
4451	public function recur ( string $ className , array $ data , ? int $ interval = null , ? int $ offset = null , ? string $ jid = null , ? int $ retries = null , ? int $ priority = null , ? int $ backlog = null , ? array $ tags = null ) { try { $ jid = $ jid ? : Uuid :: uuid4 ( ) -> toString ( ) ; } catch ( \ Exception $ e ) { throw new RuntimeException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } $ data = json_encode ( $ data , JSON_UNESCAPED_SLASHES ) ; if ( empty ( $ data ) ) { throw new RuntimeException ( sprintf ( 'Unable to encode payload to make a recurring job "%s" for the "%s" queue.' , $ jid , $ this -> name ) ) ; } return $ this -> client -> recur ( $ this -> name , $ jid , $ className , $ data , 'interval' , is_null ( $ interval ) ? 60 : $ interval , is_null ( $ offset ) ? 0 : $ offset , 'priority' , is_null ( $ priority ) ? 0 : $ priority , 'tags' , json_encode ( $ tags ? : [ ] , JSON_UNESCAPED_SLASHES ) , 'retries' , is_null ( $ retries ) ? 5 : $ retries , 'backlog' , is_null ( $ backlog ) ? 0 : $ backlog ) ; }
11080	public static function getDayName ( $ day ) { if ( $ day < self :: DOW_MONDAY || $ day > self :: DOW_SUNDAY ) { return '' ; } $ dayNames = [ self :: DOW_MONDAY => self :: poorManTranslate ( 'fts-shared' , 'Monday' ) , self :: DOW_TUESDAY => self :: poorManTranslate ( 'fts-shared' , 'Tuesday' ) , self :: DOW_WEDNESDAY => self :: poorManTranslate ( 'fts-shared' , 'Wednesday' ) , self :: DOW_THURSDAY => self :: poorManTranslate ( 'fts-shared' , 'Thursday' ) , self :: DOW_FRIDAY => self :: poorManTranslate ( 'fts-shared' , 'Friday' ) , self :: DOW_SATURDAY => self :: poorManTranslate ( 'fts-shared' , 'Saturday' ) , self :: DOW_SUNDAY => self :: poorManTranslate ( 'fts-shared' , 'Sunday' ) , ] ; return $ dayNames [ $ day ] ; }
1630	public function resolve ( ) { $ request = $ this -> app -> make ( Request :: class ) ; if ( $ this -> app -> runningInConsole ( ) ) { $ command = $ request -> server ( 'argv' , [ ] ) ; if ( ! is_array ( $ command ) ) { $ command = explode ( ' ' , $ command ) ; } return new ConsoleRequest ( $ command ) ; } return new LaravelRequest ( $ request ) ; }
1404	public function add ( $ record , array $ relationship , EncodingParametersInterface $ parameters ) { $ related = $ this -> findRelated ( $ record , $ relationship ) ; $ relation = $ this -> getRelation ( $ record , $ this -> key ) ; $ existing = $ relation -> getQuery ( ) -> whereKey ( $ related -> modelKeys ( ) ) -> get ( ) ; $ relation -> saveMany ( $ related -> diff ( $ existing ) ) ; $ record -> refresh ( ) ; return $ record ; }
9921	private function findManyToManyRelations ( array $ models ) { for ( $ i = 0 ; $ i < sizeof ( $ models ) ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < sizeof ( $ models ) ; $ j ++ ) { $ model1 = $ models [ $ i ] ; $ model2 = $ models [ $ j ] ; if ( strcasecmp ( $ model1 -> getName ( ) , $ model2 -> getName ( ) ) < 0 ) { $ tableName = strtolower ( $ model1 -> getName ( ) ) . '_' . strtolower ( $ model2 -> getName ( ) ) ; } else { $ tableName = strtolower ( $ model2 -> getName ( ) ) . '_' . strtolower ( $ model1 -> getName ( ) ) ; } if ( $ this -> databaseRepository -> hasTable ( $ tableName ) ) { $ this -> defineManyToManyRelation ( $ model1 , $ model2 ) ; } } } }
8000	public function calculateNtResponse ( HashCredentialInterface $ hash_credential , $ client_challenge = null , $ server_challenge_nonce = null ) { $ encryption_data = $ server_challenge_nonce ; if ( null !== $ client_challenge ) { $ extended_security_hasher = $ this -> crypt_hasher_factory -> build ( static :: EXTENDED_SESSION_SECURITY_HASHER_ALGORITHM ) ; $ nt_extended_security_challenge_source = $ server_challenge_nonce . $ client_challenge ; $ nt_extended_security_hash = $ extended_security_hasher -> update ( $ nt_extended_security_challenge_source ) -> digest ( ) ; $ nt_extended_security_challenge = substr ( $ nt_extended_security_hash , 0 , static :: EXTENDED_SESSION_SECURITY_CHALLENGE_LENGTH ) ; $ encryption_data = $ nt_extended_security_challenge ; } return $ this -> calculateChallengeResponseData ( $ hash_credential , $ encryption_data ) ; }
3744	protected function getMetaModel ( ) { if ( ! $ this -> metaModel ) { if ( $ this -> metaModel === null ) { throw new \ RuntimeException ( 'No MetaModel instance set for ' . $ this -> strTable ) ; } } return $ this -> metaModel ; }
1914	protected function generateHashes ( $ sum ) { $ time = ( int ) round ( time ( ) / 60 / 30 ) ; return array_map ( function ( $ hashTime ) use ( $ sum ) { return hash_hmac ( 'sha256' , $ sum . "\0" . $ hashTime , System :: getContainer ( ) -> getParameter ( 'kernel.secret' ) ) ; } , array ( $ time , $ time - 1 ) ) ; }
12696	static function getAvailableExtNames ( ) { $ files = pakeFinder :: type ( 'file' ) -> name ( 'options-*.yaml' ) -> not_name ( 'options-sample.yaml' ) -> not_name ( 'options-user.yaml' ) -> maxdepth ( 0 ) -> in ( self :: getOptionsDir ( ) ) ; foreach ( $ files as $ i => $ file ) { $ files [ $ i ] = substr ( basename ( $ file ) , 8 , - 5 ) ; } return $ files ; }
12134	public function index ( QuestionRequest $ request ) { $ view = $ this -> response -> theme -> listView ( ) ; if ( $ this -> response -> typeIs ( 'json' ) ) { $ function = camel_case ( 'get-' . $ view ) ; return $ this -> repository -> setPresenter ( \ Litecms \ Forum \ Repositories \ Presenter \ QuestionPresenter :: class ) -> $ function ( ) ; } $ user_id = user_id ( ) ; $ questions = $ this -> repository -> questions ( $ user_id ) ; return $ this -> response -> title ( trans ( 'forum::question.names' ) ) -> view ( 'forum::question.index' , true ) -> data ( compact ( 'questions' , 'view' ) ) -> output ( ) ; }
10420	public function create ( $ pipelineName , $ listeners = [ ] ) { $ listeners = array_merge ( [ 'sources' => [ ] , 'modifiers' => [ ] , 'consumers' => [ ] , ] , $ listeners ) ; $ className = $ this -> getClassName ( ) ; $ pipeline = new $ className ( $ pipelineName ) ; if ( ! $ pipeline instanceof Pipeline ) { throw new \ InvalidArgumentException ( 'Pipeline class\' name must implement PipelineInterface' ) ; } $ pipeline -> setProgressBar ( $ this -> getProgressBar ( ) ) ; $ dispatcher = $ this -> getDispatcher ( ) ; $ pipeline -> setDispatcher ( $ dispatcher ) ; foreach ( $ listeners [ 'consumers' ] as & $ listener ) { if ( $ listener === self :: CONSUMER_RETURN ) { $ listener = function ( ItemPipelineEvent $ event ) { $ event -> setOutput ( $ event -> getItem ( ) ) ; } ; } } $ registerListener = function ( $ key , $ suffix ) use ( $ listeners , $ dispatcher , $ pipeline ) { foreach ( $ listeners [ $ key ] as $ listener ) { $ dispatcher -> addListener ( $ pipeline -> getEventName ( $ suffix ) , $ listener ) ; } } ; $ registerListener ( 'sources' , Pipeline :: EVENT_SUFFIX_SOURCE ) ; $ registerListener ( 'modifiers' , Pipeline :: EVENT_SUFFIX_MODIFY ) ; $ registerListener ( 'consumers' , Pipeline :: EVENT_SUFFIX_CONSUME ) ; return $ pipeline ; }
2895	public function send ( ) { try { $ this -> captureEmail ( ) ; } catch ( Exception $ e ) { Mage :: logException ( $ e ) ; } return $ this -> parentSend ( ) ; }
1821	protected function getQuicknavPages ( $ pid , $ level = 1 , $ host = null ) { global $ objPage ; $ groups = array ( ) ; $ arrPages = array ( ) ; if ( FE_USER_LOGGED_IN ) { $ this -> import ( FrontendUser :: class , 'User' ) ; $ groups = $ this -> User -> groups ; } $ objSubpages = PageModel :: findPublishedRegularWithoutGuestsByPid ( $ pid ) ; if ( $ objSubpages === null ) { return array ( ) ; } ++ $ level ; foreach ( $ objSubpages as $ objSubpage ) { $ _groups = StringUtil :: deserialize ( $ objSubpage -> groups ) ; if ( $ host !== null ) { $ objSubpage -> domain = $ host ; } if ( ! $ objSubpage -> protected || $ this -> showProtected || ( \ is_array ( $ _groups ) && \ is_array ( $ groups ) && array_intersect ( $ _groups , $ groups ) ) ) { if ( ! $ objSubpage -> hide || $ this -> showHidden ) { $ arrPages [ ] = array ( 'level' => ( $ level - 2 ) , 'title' => StringUtil :: specialchars ( StringUtil :: stripInsertTags ( $ objSubpage -> pageTitle ? : $ objSubpage -> title ) ) , 'href' => $ objSubpage -> getFrontendUrl ( ) , 'link' => StringUtil :: stripInsertTags ( $ objSubpage -> title ) , 'active' => ( $ objPage -> id == $ objSubpage -> id || ( $ objSubpage -> type == 'forward' && $ objPage -> id == $ objSubpage -> jumpTo ) ) ) ; if ( ! $ this -> showLevel || $ this -> showLevel >= $ level || ( ! $ this -> hardLimit && ( $ objPage -> id == $ objSubpage -> id || \ in_array ( $ objPage -> id , $ this -> Database -> getChildRecords ( $ objSubpage -> id , 'tl_page' ) ) ) ) ) { $ subpages = $ this -> getQuicknavPages ( $ objSubpage -> id , $ level ) ; if ( \ is_array ( $ subpages ) ) { $ arrPages = array_merge ( $ arrPages , $ subpages ) ; } } } } } return $ arrPages ; }
6999	public function getCssClassesForContainer ( ) { $ colsXl = $ this -> getWidth ( ) >= 100 ? 12 : ceil ( 12 * ( $ this -> getWidth ( ) / 100 ) ) ; $ colsXlLeft = floor ( ( 12 - $ colsXl ) / 2 ) ; $ colsLg = $ colsXl >= 10 ? 12 : $ colsXl + 2 ; $ colsLgLeft = floor ( ( 12 - $ colsLg ) / 2 ) ; return "col-xs-12 col-xl-{$colsXl} col-lg-{$colsLg} col-xl-offset-{$colsXlLeft} col-lg-offset-{$colsLgLeft}" ; }
8987	public static function parseStatus ( $ statusLine ) : HttpStatus { list ( $ proto , $ code ) = sscanf ( $ statusLine , "%s %d %s" ) ; return new HttpStatus ( $ code , $ proto ) ; }
2094	private function isScope ( string $ scope ) : bool { if ( null === $ this -> container || null === ( $ request = $ this -> container -> get ( 'request_stack' ) -> getCurrentRequest ( ) ) ) { return false ; } $ matcher = $ this -> container -> get ( 'contao.routing.scope_matcher' ) ; if ( ContaoCoreBundle :: SCOPE_BACKEND === $ scope ) { return $ matcher -> isBackendRequest ( $ request ) ; } if ( ContaoCoreBundle :: SCOPE_FRONTEND === $ scope ) { return $ matcher -> isFrontendRequest ( $ request ) ; } return false ; }
9605	public function vectorTripleProduct ( self $ b , self $ c ) { return $ this -> crossProduct ( $ b -> crossProduct ( $ c ) ) ; }
10809	protected function __templates ( $ customTemplate = null , $ customTemplateSuffix = null ) { $ templates = SSViewer :: get_templates_by_class ( $ this -> class , $ customTemplateSuffix , \ FormField :: class ) ; if ( ! $ templates ) { throw new \ Exception ( "No template found for {$this->class}" ) ; } if ( $ customTemplate ) { array_unshift ( $ templates , $ customTemplate ) ; } return $ templates ; }
10957	public function iLikeToMoveItMoveItBack ( ) { $ moveCommand = $ this -> popCommandFromList ( ) ; $ moveCommand -> reverseFromToDirs ( ) ; $ this -> direction = self :: DIRECTION_BACK ; $ this -> init ( $ moveCommand ) ; $ this -> processFiles ( ) ; }
5955	public function channelPermList ( $ cid , $ permsid = false ) { return $ this -> execute ( "channelpermlist" , array ( "cid" => $ cid , $ permsid ? "-permsid" : null ) ) -> toAssocArray ( $ permsid ? "permsid" : "permid" ) ; }
449	public function init ( ) { parent :: init ( ) ; $ this -> cachePath = Yii :: getAlias ( $ this -> cachePath ) ; if ( ! is_dir ( $ this -> cachePath ) ) { FileHelper :: createDirectory ( $ this -> cachePath , $ this -> dirMode , true ) ; } }
3609	public function getUserLocations ( ) { $ this -> prepareForGet ( ) ; $ structures = ( array ) $ this -> last_status -> structure ; $ user_structures = array ( ) ; $ class_name = get_class ( $ this ) ; $ topaz = isset ( $ this -> last_status -> topaz ) ? $ this -> last_status -> topaz : array ( ) ; foreach ( $ structures as $ struct_id => $ structure ) { $ protects = array ( ) ; foreach ( $ topaz as $ protect ) { if ( $ protect -> structure_id == $ struct_id ) { $ protects [ ] = $ protect -> serial_number ; } } $ weather_data = $ this -> getWeather ( $ structure -> postal_code , $ structure -> country_code ) ; $ user_structures [ ] = ( object ) array ( 'name' => isset ( $ structure -> name ) ? $ structure -> name : '' , 'address' => ! empty ( $ structure -> street_address ) ? $ structure -> street_address : NULL , 'city' => $ structure -> location , 'postal_code' => $ structure -> postal_code , 'country' => $ structure -> country_code , 'outside_temperature' => $ weather_data -> outside_temperature , 'outside_humidity' => $ weather_data -> outside_humidity , 'away' => $ structure -> away , 'away_last_changed' => date ( DATETIME_FORMAT , $ structure -> away_timestamp ) , 'thermostats' => array_map ( array ( $ class_name , 'cleanDevices' ) , $ structure -> devices ) , 'protects' => $ protects , ) ; } return $ user_structures ; }
8761	public function writeLogLine ( Tick $ tick ) { $ lineSegs = array ( ) ; switch ( $ tick -> getStatus ( ) ) { case Tick :: SUCCESS : $ lineSegs [ ] = sprintf ( "<fg=green>%s</fg=green>" , $ this -> linePrefixMap [ Tick :: SUCCESS ] ) ; break ; case Tick :: FAIL : $ lineSegs [ ] = sprintf ( "<fg=red>%s</fg=red>" , $ this -> linePrefixMap [ Tick :: FAIL ] ) ; break ; case Tick :: SKIP : default : $ lineSegs [ ] = $ this -> linePrefixMap [ Tick :: SKIP ] ; } $ lineSegs [ ] = sprintf ( "[%s%s]" , $ tick -> getReport ( ) -> getNumItemsProcessed ( ) , $ tick -> getReport ( ) -> getTotalItemCount ( ) != Tracker :: UNKNOWN ? "/" . $ tick -> getReport ( ) -> getTotalItemCount ( ) : '' ) ; if ( $ this -> output -> getVerbosity ( ) >= OutputInterface :: VERBOSITY_VERBOSE ) { $ lineSegs [ ] = $ this -> formatSeconds ( $ tick -> getReport ( ) -> getTimeElapsed ( ) ) ; $ lineSegs [ ] = sprintf ( '(<fg=green>%s</fg=green>/%s/<fg=red>%s</fg=red>)' , $ tick -> getReport ( ) -> getNumItemsSuccess ( ) , $ tick -> getReport ( ) -> getNumItemsSkip ( ) , $ tick -> getReport ( ) -> getNumItemsFail ( ) ) ; } if ( $ this -> output -> getVerbosity ( ) >= OutputInterface :: VERBOSITY_VERY_VERBOSE ) { $ lineSegs [ ] = sprintf ( "{%s/%s}" , $ this -> bytesToHuman ( $ tick -> getReport ( ) -> getMemUsage ( ) ) , $ this -> bytesToHuman ( $ tick -> getReport ( ) -> getMemPeakUsage ( ) ) ) ; } $ lineSegs [ ] = $ tick -> getMessage ( ) ? : sprintf ( "Processing item %s" , number_format ( $ tick -> getReport ( ) -> getNumItemsProcessed ( ) , 0 ) ) ; $ this -> output -> writeln ( implode ( ' ' , $ lineSegs ) ) ; }
10446	protected function detectQueryType ( $ type ) { switch ( $ type ) { case 'INSERT INTO' : return ActionTypes :: CREATE ; case 'UPDATE' : return ActionTypes :: UPDATE ; case 'DELETE FROM' : return ActionTypes :: DELETE ; default : throw new \ UnexpectedValueException ( "Unknown statement of type {$type}" ) ; } }
6758	private function messageInMessage ( string $ message ) : string { $ decodedMessage = json_decode ( $ message , true ) ; if ( is_array ( $ decodedMessage ) && isset ( $ decodedMessage [ 'message' ] ) && is_string ( $ decodedMessage [ 'message' ] ) ) { return $ decodedMessage [ 'message' ] ; } return $ message ; }
4585	public function decoded ( JWTDecodedEvent $ event ) { $ payload = $ event -> getPayload ( ) ; $ payload = json_decode ( json_encode ( $ payload ) , true ) ; if ( ! $ this -> accessor -> isReadable ( $ payload , $ this -> property ) ) { $ event -> markAsInvalid ( ) ; } elseif ( $ this -> validate && $ this -> accessor -> getValue ( $ payload , $ this -> property ) !== $ this -> getSignature ( ) ) { $ event -> markAsInvalid ( ) ; } }
12850	private function _checkCache ( \ stdClass $ oCache ) { $ sHearderValidity = false ; $ sHeader = "Cache-Control:" ; if ( isset ( $ oCache -> visibility ) && ( $ oCache -> visibility = 'public' || $ oCache -> visibility = 'private' ) ) { $ sHearderValidity = true ; $ sHeader .= " " . $ oCache -> visibility . "," ; } if ( isset ( $ oCache -> max_age ) ) { $ sHearderValidity = true ; $ sHeader .= " maxage=" . $ oCache -> max_age . "," ; } if ( isset ( $ oCache -> must_revalidate ) && $ oCache -> must_revalidate === true ) { $ sHearderValidity = true ; $ sHeader .= " must-revalidate," ; } if ( $ sHearderValidity === true ) { $ sHeader = substr ( $ sHeader , 0 , - 1 ) ; if ( ! headers_sent ( ) ) { header ( $ sHeader ) ; } } if ( isset ( $ oCache -> ETag ) ) { header ( "ETag: \"" . $ oCache -> ETag . "\"" ) ; } if ( isset ( $ oCache -> max_age ) ) { if ( ! headers_sent ( ) ) { header ( 'Expires: ' . gmdate ( 'D, d M Y H:i:s' , time ( ) + $ oCache -> max_age ) . ' GMT' ) ; } } if ( isset ( $ oCache -> last_modified ) ) { if ( ! headers_sent ( ) ) { header ( 'Last-Modified: ' . gmdate ( 'D, d M Y H:i:s' , time ( ) + $ oCache -> last_modified ) . ' GMT' ) ; } } if ( isset ( $ oCache -> vary ) ) { header ( 'Vary: ' . $ oCache -> vary ) ; } }
7896	public function from ( $ provider = null ) { $ provider = $ provider ? : $ this -> getDefaultProvider ( ) ; return new Uploader ( $ this -> app -> make ( 'config' ) , $ this -> app -> make ( 'filesystem' ) , $ this -> createProviderInstance ( $ provider ) ) ; }
11128	protected function getClassName ( $ fileName ) { $ namePiece = @ explode ( $ this -> config [ 'modelsPrefix' ] , $ fileName ) ; $ name = isset ( $ namePiece [ 1 ] ) ? $ namePiece [ 1 ] : $ fileName ; $ namePiece = @ explode ( $ this -> config [ 'modelsPostfix' ] , $ name ) ; $ name = isset ( $ namePiece [ 1 ] ) ? $ namePiece [ 0 ] : $ name ; $ namePiece = explode ( '.php' , $ name ) ; $ name = isset ( $ namePiece [ 1 ] ) ? $ namePiece [ 0 ] : $ name ; return $ name ; }
6346	public static function concat ( Iterator $ a , Iterator $ b ) : Iterator { return self :: concatIterators ( new ArrayIterator ( [ $ a , $ b ] ) ) ; }
2823	public function deleteExpiredRequests ( ) { $ helper = Mage :: helper ( 'sheep_debug' ) ; if ( ! $ helper -> isEnabled ( ) ) { return 'skipped: module is disabled.' ; } if ( $ helper -> getPersistLifetime ( ) == 0 ) { return 'skipped: lifetime is set to 0' ; } $ expirationDate = $ this -> getExpirationDate ( date ( self :: DATE_FORMAT ) ) ; $ table = $ this -> getRequestsTable ( ) ; $ deleteSql = "DELETE FROM {$table} WHERE date <= '{$expirationDate}'" ; $ connection = Mage :: getSingleton ( 'core/resource' ) -> getConnection ( 'core_write' ) ; $ result = $ connection -> query ( $ deleteSql ) ; return "{$result->rowCount()} requests deleted" ; }
2736	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ countries = $ this -> countryHelper -> toOptionArray ( ) ; if ( ! $ countries ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Could not fetch list countries.' ] ) ; } return $ result -> setData ( [ 'status' => true , 'countries' => $ countries ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
1603	private function _getVariables ( ) { $ variables = $ this -> _overrideObject ; if ( $ this -> _element !== null ) { foreach ( $ this -> _element -> attributes ( ) as $ name ) if ( $ name !== $ this -> _handle ) $ variables [ $ name ] = $ this -> _element -> $ name ; $ variables = array_merge ( $ variables , $ this -> _element -> toArray ( $ this -> _element -> extraFields ( ) ) ) ; } return $ variables ; }
575	protected function getDefaultValue ( $ event ) { if ( $ this -> defaultValue instanceof \ Closure || ( is_array ( $ this -> defaultValue ) && is_callable ( $ this -> defaultValue ) ) ) { return call_user_func ( $ this -> defaultValue , $ event ) ; } return $ this -> defaultValue ; }
10578	public function multipleToAPIResponseData ( ? array $ resources ) : APIResponseData { if ( is_null ( $ resources ) ) { return $ this -> toAPIResponseData ( null ) ; } return new APIResponseData ( array_map ( function ( Resource $ resource ) { return $ this -> toAPIResponseData ( $ resource ) -> getData ( ) ; } , $ resources ) ) ; }
12704	public function getTitleAttribute ( $ value ) { if ( $ value === null ) { $ value = '' ; } if ( getenv ( "BYPASS_HOOKS" ) != true ) { global $ hooks , $ codes ; return $ hooks -> apply_filters ( "TCT-Core-Main-Model-Page-Title" , $ codes -> do_shortcode ( $ value ) ) ; } else { return $ value ; } }
1116	public function newNestedSetQuery ( $ excludeDeleted = true ) { $ builder = $ this -> newQuery ( $ excludeDeleted ) -> orderBy ( $ this -> getQualifiedOrderColumnName ( ) ) ; if ( $ this -> isScoped ( ) ) { foreach ( $ this -> scoped as $ scopeFld ) $ builder -> where ( $ scopeFld , '=' , $ this -> $ scopeFld ) ; } return $ builder ; }
4647	public function copy ( $ originFile , $ targetFile , $ override = false ) { parent :: copy ( $ originFile , $ targetFile , $ override ) ; $ this -> chmod ( $ targetFile , fileperms ( $ originFile ) ) ; }
563	public function renderSummary ( ) { $ count = $ this -> dataProvider -> getCount ( ) ; if ( $ count <= 0 ) { return '' ; } $ summaryOptions = $ this -> summaryOptions ; $ tag = ArrayHelper :: remove ( $ summaryOptions , 'tag' , 'div' ) ; if ( ( $ pagination = $ this -> dataProvider -> getPagination ( ) ) !== false ) { $ totalCount = $ this -> dataProvider -> getTotalCount ( ) ; $ begin = $ pagination -> getPage ( ) * $ pagination -> pageSize + 1 ; $ end = $ begin + $ count - 1 ; if ( $ begin > $ end ) { $ begin = $ end ; } $ page = $ pagination -> getPage ( ) + 1 ; $ pageCount = $ pagination -> pageCount ; if ( ( $ summaryContent = $ this -> summary ) === null ) { return Html :: tag ( $ tag , Yii :: t ( 'yii' , 'Showing <b>{begin, number}-{end, number}</b> of <b>{totalCount, number}</b> {totalCount, plural, one{item} other{items}}.' , [ 'begin' => $ begin , 'end' => $ end , 'count' => $ count , 'totalCount' => $ totalCount , 'page' => $ page , 'pageCount' => $ pageCount , ] ) , $ summaryOptions ) ; } } else { $ begin = $ page = $ pageCount = 1 ; $ end = $ totalCount = $ count ; if ( ( $ summaryContent = $ this -> summary ) === null ) { return Html :: tag ( $ tag , Yii :: t ( 'yii' , 'Total <b>{count, number}</b> {count, plural, one{item} other{items}}.' , [ 'begin' => $ begin , 'end' => $ end , 'count' => $ count , 'totalCount' => $ totalCount , 'page' => $ page , 'pageCount' => $ pageCount , ] ) , $ summaryOptions ) ; } } return Yii :: $ app -> getI18n ( ) -> format ( $ summaryContent , [ 'begin' => $ begin , 'end' => $ end , 'count' => $ count , 'totalCount' => $ totalCount , 'page' => $ page , 'pageCount' => $ pageCount , ] , Yii :: $ app -> language ) ; }
4786	function offsetGet ( $ key ) { $ this -> access ( $ key ) ; if ( ! array_key_exists ( $ key , $ this -> row ) ) { $ this -> access ( $ key , true ) ; } return $ this -> row [ $ key ] ; }
10497	public function sqrt ( ) { if ( $ this -> value === null ) { return new FloatType ( $ this -> value ) ; } return new FloatType ( sqrt ( $ this -> value ) ) ; }
5587	public function getCookies ( ) { $ lstCookies = $ this -> cookie_jar -> getCookies ( ) ; $ aCookies = [ ] ; foreach ( $ lstCookies as $ oCookies ) { $ aCookies [ ] = [ 'name' => $ oCookies -> getName ( ) , 'value' => $ oCookies -> getValue ( ) , 'host' => $ oCookies -> getHost ( ) , 'path' => $ oCookies -> getPath ( ) , 'expiry' => $ oCookies -> getExpiry ( ) , ] ; } return $ aCookies ; }
12069	public function updateProject ( Project $ project , $ composerJson ) { $ response = $ this -> getResponse ( 'post' , sprintf ( 'v2/projects/%s' , $ project -> getProjectKey ( ) ) , array ( ) , array ( 'project_file' => $ composerJson ) ) ; return $ this -> hydrator -> hydrate ( $ project , $ response ) ; }
11056	public function urlFunction ( $ route , array $ params = [ ] ) { return $ this -> container [ 'url_generator' ] -> generate ( $ route , $ params , UrlGeneratorInterface :: ABSOLUTE_URL ) ; }
8114	public function addReviewNote ( Member $ reviewer , $ message ) { $ reviewLog = ContentReviewLog :: create ( ) ; $ reviewLog -> Note = $ message ; $ reviewLog -> ReviewerID = $ reviewer -> ID ; $ this -> owner -> ReviewLogs ( ) -> add ( $ reviewLog ) ; }
3968	protected function createAttributeInstance ( ModelInterface $ model = null ) { if ( null === $ model ) { return null ; } return $ this -> attributeFactory -> createAttribute ( $ model -> getPropertiesAsArray ( ) , $ this -> getMetaModelByModelPid ( $ model ) ) ; }
3418	public static function registerEloquent ( ) { $ capsule = self :: bootstrapIlluminateDatabase ( ) ; class_alias ( Capsule :: class , 'DB' ) ; if ( $ _COOKIE [ "show_sql_stat" ] == "Y" ) { Capsule :: enableQueryLog ( ) ; $ em = \ Bitrix \ Main \ EventManager :: getInstance ( ) ; $ em -> addEventHandler ( 'main' , 'OnAfterEpilog' , [ IlluminateQueryDebugger :: class , 'onAfterEpilogHandler' ] ) ; } static :: addEventListenersForHelpersHighloadblockTables ( $ capsule ) ; }
12012	private function addDoctrineSection ( ArrayNodeDefinition $ rootNode ) { $ rootNode -> children ( ) -> arrayNode ( 'doctrine' ) -> info ( 'doctrine configuration' ) -> canBeEnabled ( ) -> children ( ) -> booleanNode ( 'enabled' ) -> defaultTrue ( ) -> end ( ) -> end ( ) -> end ( ) -> end ( ) ; }
4134	public static function encryptAndAppendTag ( $ K , $ IV , $ P = null , $ A = null , $ tag_length = 128 ) { return implode ( self :: encrypt ( $ K , $ IV , $ P , $ A , $ tag_length ) ) ; }
3728	protected function tryUnserialize ( $ value ) { if ( ! is_array ( $ value ) && 0 === strpos ( $ value , 'a:' ) && is_array ( $ unSerialized = unserialize ( $ value , [ 'allowed_classes' => false ] ) ) ) { return $ unSerialized ; } return $ value ; }
9653	public function addLoader ( $ extensions , $ loaderClass ) { foreach ( ( array ) $ extensions as $ extension ) { $ this -> extensions [ ] = $ extension ; if ( is_string ( $ loaderClass ) ) { $ this -> loaderClasses [ $ extension ] = $ loaderClass ; } elseif ( $ loaderClass instanceof LoaderInterface ) { $ this -> loaders [ $ extension ] = $ loaderClass ; } } }
11119	protected function runUp ( array $ file , int $ batch ) : void { $ this -> notify -> note ( "<comment>Migrating:</comment> {$file['basename']}" ) ; $ this -> runMigration ( $ file ) ; $ this -> repository -> log ( $ this -> getMigrationName ( $ file ) , $ batch ) ; $ this -> notify -> note ( "<info>Migrated:</info> {$file['basename']}" ) ; }
5351	public function setDatabasePassword ( $ domainName , $ database , $ password ) { return $ this -> call ( self :: SERVICE , 'setDatabasePassword' , [ $ domainName , $ database , $ password ] ) ; }
10413	public function loadUrlsByType ( $ type ) { foreach ( $ this -> urlCollectors as $ collector ) { $ this -> addUrls ( $ collector -> getUrlsByType ( $ type , $ this -> router ) ) ; } }
12178	public function getIndividual ( ) { if ( ! isset ( $ this -> _individual ) && ! empty ( $ this -> object_individual_id ) ) { $ this -> _individual = false ; $ individualType = Yii :: $ app -> collectors [ 'types' ] -> getOne ( 'Individual' ) ; if ( ! empty ( $ individualType -> object ) ) { $ individualClass = $ individualType -> object -> primaryModel ; $ this -> _individual = $ individualClass :: get ( $ this -> object_individual_id ) ; } } return $ this -> _individual ; }
4811	public function create ( ) { $ language = new ExpressionLanguage ( ) ; foreach ( $ this -> providers as $ provider ) { $ language -> registerProvider ( $ provider ) ; } return $ language ; }
5611	public function paintMethodStart ( $ message ) { parent :: paintMethodStart ( $ message ) ; $ node = new TreemapNode ( 'Method' , $ message ) ; $ this -> _stack -> push ( $ node ) ; }
6468	public function parseAcceptCharsetHeader ( HttpHeaders $ headers ) : array { $ headerValues = [ ] ; if ( ! $ headers -> tryGet ( 'Accept-Charset' , $ headerValues ) ) { return [ ] ; } $ parsedHeaderValues = [ ] ; $ numHeaderValues = count ( $ headerValues ) ; for ( $ i = 0 ; $ i < $ numHeaderValues ; $ i ++ ) { $ parsedHeaderParameters = $ this -> parseParameters ( $ headers , 'Accept-Charset' , $ i ) ; $ charset = $ parsedHeaderParameters -> getKeys ( ) [ 0 ] ; $ parsedHeaderValues [ ] = new AcceptCharsetHeaderValue ( $ charset , $ parsedHeaderParameters ) ; } return $ parsedHeaderValues ; }
4573	public function getProperties ( Auditable $ entity ) { $ reflection = new ReflectionObject ( $ entity ) ; $ properties = [ ] ; foreach ( $ reflection -> getProperties ( ) as $ key => $ property ) { if ( ! $ this -> annotationReader -> getPropertyAnnotation ( $ property , AuditAnnotation :: class ) ) { continue ; } $ properties [ ] = $ property -> name ; } return $ properties ; }
6449	private function compareAcceptLanguageHeaders ( AcceptLanguageHeaderValue $ a , AcceptLanguageHeaderValue $ b ) : int { $ aQuality = $ a -> getQuality ( ) ; $ bQuality = $ b -> getQuality ( ) ; if ( $ aQuality < $ bQuality ) { return 1 ; } if ( $ aQuality > $ bQuality ) { return - 1 ; } $ aValue = $ a -> getLanguage ( ) ; $ bValue = $ b -> getLanguage ( ) ; if ( $ aValue === '*' ) { if ( $ bValue === '*' ) { return 0 ; } return 1 ; } if ( $ bValue === '*' ) { return - 1 ; } return 0 ; }
11215	public static function __callstatic ( $ method , $ params ) { $ uri = $ params [ 0 ] ; $ callback = $ params [ 1 ] ; array_push ( self :: $ routes , $ uri ) ; array_push ( self :: $ methods , strtoupper ( $ method ) ) ; array_push ( self :: $ callbacks , $ callback ) ; }
2075	public function purgeVersionTable ( ) { $ objDatabase = Database :: getInstance ( ) ; $ objDatabase -> execute ( "TRUNCATE TABLE tl_version" ) ; $ this -> log ( 'Purged the version table' , __METHOD__ , TL_CRON ) ; }
480	public function alterColumn ( $ table , $ column , $ type ) { $ time = $ this -> beginCommand ( "alter column $column in table $table to $type" ) ; $ this -> db -> createCommand ( ) -> alterColumn ( $ table , $ column , $ type ) -> execute ( ) ; if ( $ type instanceof ColumnSchemaBuilder && $ type -> comment !== null ) { $ this -> db -> createCommand ( ) -> addCommentOnColumn ( $ table , $ column , $ type -> comment ) -> execute ( ) ; } $ this -> endCommand ( $ time ) ; }
6149	public function sendJson ( $ data , $ statusCode = null ) { return $ this -> setStatusCode ( $ statusCode ) -> setJsonBody ( $ data ) -> send ( ) ; }
231	public function insert ( $ table , $ columns ) { $ command = $ this -> db -> createCommand ( ) -> insert ( $ table , $ columns ) ; if ( ! $ command -> execute ( ) ) { return false ; } $ tableSchema = $ this -> getTableSchema ( $ table ) ; $ result = [ ] ; foreach ( $ tableSchema -> primaryKey as $ name ) { if ( $ tableSchema -> columns [ $ name ] -> autoIncrement ) { $ result [ $ name ] = $ this -> getLastInsertID ( $ tableSchema -> sequenceName ) ; break ; } $ result [ $ name ] = isset ( $ columns [ $ name ] ) ? $ columns [ $ name ] : $ tableSchema -> columns [ $ name ] -> defaultValue ; } return $ result ; }
4712	public function escapeHtml ( $ option = ENT_QUOTES ) { $ this -> text = htmlspecialchars ( $ this -> text , $ option , 'UTF-8' , false ) ; return $ this ; }
8169	public static function register ( $ prepend = false ) { @ trigger_error ( 'Using Twig_Autoloader is deprecated since version 1.21. Use Composer instead.' , E_USER_DEPRECATED ) ; if ( PHP_VERSION_ID < 50300 ) { spl_autoload_register ( array ( __CLASS__ , 'autoload' ) ) ; } else { spl_autoload_register ( array ( __CLASS__ , 'autoload' ) , true , $ prepend ) ; } }
6089	public function updateMoodboard ( $ id , Moodboard $ moodboard ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'moodboard' => $ moodboard ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/moodboards/' . $ id . '' , $ parameters ) ; $ result = new MoodboardResponse ( $ result ) ; return $ result ; }
3345	public function __batchProcessFilesChunk ( $ filesUuidArr , $ request_type ) { if ( count ( $ filesUuidArr ) > $ this -> batchFilesChunkSize ) { throw new \ Exception ( 'Files number should not exceed ' . $ this -> batchFilesChunkSize . ' items per request.' ) ; } $ data = $ this -> __preparedRequest ( 'files_storage' , $ request_type , array ( ) , $ filesUuidArr ) ; $ files_raw = ( array ) $ data -> result ; $ result = array ( ) ; foreach ( $ files_raw as $ file_raw ) { $ result [ ] = new File ( $ file_raw -> uuid , $ this , $ file_raw ) ; } return array ( 'status' => ( string ) $ data -> status , 'files' => $ result , 'problems' => $ data -> problems , ) ; }
5762	public function indexView ( Response $ response , ? array $ displayItems = null ) { if ( $ displayItems === null ) { $ displayItems = $ this -> getDisplayItems ( ) ; } $ filterErrorMessage = FormHelper :: getFieldError ( $ this -> sessionFilterFieldKey ) ; FormHelper :: unsetSessionFormErrors ( ) ; return $ this -> view -> render ( $ response , $ this -> template , [ 'title' => $ this -> mapper -> getListViewTitle ( ) , 'insertLinkInfo' => $ this -> insertLinkInfo , 'filterOpsList' => QueryBuilder :: getWhereOperatorsText ( ) , 'filterValue' => $ this -> getFilterFieldValue ( ) , 'filterErrorMessage' => $ filterErrorMessage , 'filterFormActionRoute' => $ this -> indexRoute , 'filterFieldName' => $ this -> sessionFilterFieldKey , 'isFiltered' => $ this -> getFilterFieldValue ( ) != '' , 'resetFilterRoute' => $ this -> filterResetRoute , 'updatesPermitted' => $ this -> updatesPermitted , 'updateColumn' => $ this -> updateColumn , 'updateRoute' => $ this -> updateRoute , 'deletesPermitted' => $ this -> deletesPermitted , 'deleteRoute' => $ this -> deleteRoute , 'displayItems' => $ displayItems , 'columnCount' => $ this -> mapper -> getCountSelectColumns ( ) , 'sortColumn' => $ this -> mapper -> getListViewSortColumn ( ) , 'sortAscending' => $ this -> mapper -> getListViewSortAscending ( ) , 'navigationItems' => $ this -> navigationItems ] ) ; }
6360	public function filter ( callable $ predicate ) : BufferedIterable { return new BufferedIterable ( $ this -> chunkProvider , $ predicate , $ this -> limit , $ this -> providerCallLimit ) ; }
11065	public function icon ( $ level , $ default = null ) { if ( array_key_exists ( $ level , $ this -> icons ) ) { return $ this -> icons [ $ level ] ; } return $ default ; }
5774	public function isDeletable ( ) : bool { if ( is_null ( $ this -> authorization ) ) { throw new \ Exception ( "Authorization must be set" ) ; } $ id = $ this -> getId ( ) ; if ( $ this -> isLoggedIn ( ) ) { $ this -> notDeletableReason = "Administrator cannot delete own account: id $id" ; return false ; } if ( ! $ this -> getAuthorization ( ) -> hasTopRole ( ) && $ this -> hasTopRole ( ) ) { $ this -> notDeletableReason = "Not authorized to delete administrator: id $id" ; return false ; } if ( ( EventsTableMapper :: getInstance ( ) ) -> existForAdministrator ( $ id ) ) { $ this -> notDeletableReason = "Events exist for administrator: id $id" ; return false ; } return true ; }
8130	public function addSuggestions ( $ name , array $ items ) { if ( ! $ alternatives = self :: computeAlternatives ( $ name , $ items ) ) { return ; } $ this -> appendMessage ( sprintf ( ' Did you mean "%s"?' , implode ( '", "' , $ alternatives ) ) ) ; }
10659	protected function normalizeHeaderName ( $ keyName ) { if ( ! is_string ( $ keyName ) ) { return null ; } return ucwords ( trim ( strtolower ( $ keyName ) ) , '-' ) ? : null ; }
5863	protected function expandConversionMapping ( array $ mapping ) { $ ret = [ ] ; $ matches = [ ] ; foreach ( $ mapping as $ m ) { if ( preg_match ( '/^(.*)\s*=>\s*(.*)/' , $ m , $ matches ) ) { $ ret [ trim ( $ matches [ 1 ] ) ] = trim ( $ matches [ 2 ] ) ; } } return $ ret ; }
8433	public function migrate ( Request $ req ) { if ( count ( $ req -> getArgs ( ) ) != 1 ) { echo 'Wrong arguments.' . PHP_EOL . 'Usage : db/migration/migrate mapping_name' . PHP_EOL ; } else { $ mappingName = $ req -> getArgs ( ) [ 0 ] ; $ mapping = Mapping :: get ( $ mappingName ) ; $ cl = '\\' . ltrim ( rtrim ( $ mapping [ 'config' ] [ 'provider' ] , '\\' ) , '\\' ) . '\\Migration::migrate' ; if ( is_callable ( $ cl ) === false ) { throw new RuntimeException ( 'Migration migrate method is not callable on configured provider!' ) ; } call_user_func ( $ cl , $ mapping ) ; echo 'Migrate - Done' . PHP_EOL ; } }
8562	public function createShipment ( $ request ) { if ( ! ( $ request instanceof MWSMerchantFulfillmentService_Model_CreateShipmentRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/CreateShipmentRequest.php' ) ; $ request = new MWSMerchantFulfillmentService_Model_CreateShipmentRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'CreateShipment' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/CreateShipmentResponse.php' ) ; $ response = MWSMerchantFulfillmentService_Model_CreateShipmentResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
3195	public function setConsumedExtraTime ( $ time ) { $ this -> consumedExtraTime = max ( $ this -> consumedExtraTime , floatval ( $ time ) ) ; return $ this ; }
5325	protected function lockExecute ( callable $ task ) { if ( $ this -> mutex -> isAcquired ( ) ) { return $ task ( ) ; } return $ this -> mutex -> lockExecute ( $ task ) ; }
12711	public function register ( $ alias , $ abstract ) { if ( ! is_string ( $ alias ) || ! is_string ( $ abstract ) ) { throw new \ InvalidArgumentException ( sprintf ( "Parameter 1 and 2 of %s must be a string." , __METHOD__ ) ) ; } if ( ! isset ( $ this -> aliases [ $ alias ] ) ) { $ this -> aliases [ $ alias ] = $ this -> make ( $ abstract ) ; } return $ this ; }
12179	public function getPhotoEmail ( ) { if ( ! empty ( $ this -> email ) && substr ( $ this -> email , - 6 ) !== ".local" ) { return $ this -> email ; } return false ; }
7075	private function addItemDetails ( array & $ details , Model \ SaleItemInterface $ item ) { $ total = 0 ; if ( ! ( $ item -> isCompound ( ) && ! $ item -> hasPrivateChildren ( ) ) ) { $ itemResult = $ item -> getResult ( ) ; $ details [ 'L_PAYMENTREQUEST_0_NAME' . $ this -> line ] = $ item -> getTotalQuantity ( ) . 'x ' . $ item -> getDesignation ( ) ; $ details [ 'L_PAYMENTREQUEST_0_NUMBER' . $ this -> line ] = $ item -> getReference ( ) ; if ( ! empty ( $ description = $ item -> getDescription ( ) ) ) { $ details [ 'L_PAYMENTREQUEST_0_DESC' . $ this -> line ] = $ description ; } $ details [ 'L_PAYMENTREQUEST_0_AMT' . $ this -> line ] = $ this -> format ( $ itemResult -> getTotal ( ) ) ; $ total = $ itemResult -> getTotal ( ) ; $ this -> line ++ ; } foreach ( $ item -> getChildren ( ) as $ child ) { $ total += $ this -> addItemDetails ( $ details , $ child ) ; } return $ total ; }
7718	function meth_Conv_Prepare ( & $ Loc , $ StrConv ) { $ x = strtolower ( $ StrConv ) ; $ x = '+' . str_replace ( ' ' , '' , $ x ) . '+' ; if ( strpos ( $ x , '+esc+' ) !== false ) { $ this -> f_Misc_ConvSpe ( $ Loc ) ; $ Loc -> ConvStr = false ; $ Loc -> ConvEsc = true ; } if ( strpos ( $ x , '+wsp+' ) !== false ) { $ this -> f_Misc_ConvSpe ( $ Loc ) ; $ Loc -> ConvWS = true ; } if ( strpos ( $ x , '+js+' ) !== false ) { $ this -> f_Misc_ConvSpe ( $ Loc ) ; $ Loc -> ConvStr = false ; $ Loc -> ConvJS = true ; } if ( strpos ( $ x , '+url+' ) !== false ) { $ this -> f_Misc_ConvSpe ( $ Loc ) ; $ Loc -> ConvStr = false ; $ Loc -> ConvUrl = true ; } if ( strpos ( $ x , '+utf8+' ) !== false ) { $ this -> f_Misc_ConvSpe ( $ Loc ) ; $ Loc -> ConvStr = false ; $ Loc -> ConvUtf8 = true ; } if ( strpos ( $ x , '+no+' ) !== false ) $ Loc -> ConvStr = false ; if ( strpos ( $ x , '+yes+' ) !== false ) $ Loc -> ConvStr = true ; if ( strpos ( $ x , '+nobr+' ) !== false ) { $ Loc -> ConvStr = true ; $ Loc -> ConvBr = false ; } }
8282	public function onPageRendering ( & $ templateName , array & $ twigVariables ) { $ twigVariables [ 'auth' ] [ 'plugin' ] = $ this ; $ twigVariables [ 'auth' ] [ 'vars' ] = $ this -> output ; if ( ! $ this -> errorOccurred ) { $ twigVariables [ 'auth' ] [ 'user' ] = $ this -> user ; $ old = $ this -> session -> getFlash ( 'old' ) ; if ( count ( $ old ) && isset ( $ old [ 0 ] ) ) { $ twigVariables [ 'auth' ] [ 'old' ] = $ old [ 0 ] ; } } }
12589	protected function sendEmails ( ContactInquiry $ inquiry ) { $ recipients = $ this -> container -> getParameter ( 'c33s_contact_form.email.recipients' ) ; if ( $ this -> container -> getParameter ( 'c33s_contact_form.email.send_copy_to_user' ) && $ inquiry -> hasSenderEmail ( ) ) { $ recipients [ ] = $ inquiry -> getSenderEmail ( ) ; } if ( empty ( $ recipients ) ) { return ; } $ translator = $ this -> get ( 'translator' ) ; $ subject = $ this -> container -> getParameter ( 'c33s_contact_form.email.subject' ) ; $ message = \ Swift_Message :: newInstance ( ) -> setSubject ( $ translator -> trans ( $ subject , array ( ) , 'C33sContactForm' ) ) -> setFrom ( $ this -> container -> getParameter ( 'c33s_contact_form.email.sender_email' ) ) -> setTo ( $ recipients ) -> setBody ( $ this -> renderView ( 'C33sContactFormBundle:ContactForm:email.txt.twig' , array ( 'inquiry' => $ inquiry ) ) ) ; $ this -> get ( 'mailer' ) -> send ( $ message ) ; }
4379	protected function dumpArray ( $ array ) { if ( empty ( $ array ) ) { $ html = '<span class="t_keyword">array</span>' . '<span class="t_punct">()</span>' ; } else { $ displayKeys = $ this -> debug -> getCfg ( 'output.displayListKeys' ) || ! $ this -> debug -> utilities -> isList ( $ array ) ; $ html = '<span class="t_keyword">array</span>' . '<span class="t_punct">(</span>' . "\n" ; if ( $ displayKeys ) { $ html .= '<span class="array-inner">' . "\n" ; foreach ( $ array as $ key => $ val ) { $ html .= "\t" . '<span class="key-value">' . '<span class="t_key' . ( \ is_int ( $ key ) ? ' t_int' : '' ) . '">' . $ this -> dump ( $ key , true , false ) . '</span> ' . '<span class="t_operator">=&gt;</span> ' . $ this -> dump ( $ val ) . '</span>' . "\n" ; } $ html .= '</span>' ; } else { $ html .= '<ul class="array-inner list-unstyled">' . "\n" ; foreach ( $ array as $ val ) { $ html .= $ this -> dump ( $ val , true , 'li' ) ; } $ html .= '</ul>' ; } $ html .= '<span class="t_punct">)</span>' ; } return $ html ; }
7909	protected function renderSearchInput ( ) { $ lines = [ ] ; $ lines [ ] = Html :: beginTag ( 'div' , [ 'class' => 'ui icon search input' ] ) ; $ lines [ ] = Html :: tag ( 'i' , '' , [ 'class' => 'search icon' ] ) ; $ lines [ ] = Html :: input ( 'text' , $ this -> getId ( ) . '-search' , '' , $ this -> searchInputOptions ) ; $ lines [ ] = Html :: endTag ( 'div' ) ; $ lines [ ] = Html :: tag ( 'div' , '' , [ 'class' => 'divider' ] ) ; return implode ( "\n" , $ lines ) ; }
11612	protected function _resolveContainer ( BaseContainerInterface $ container ) { $ parent = null ; while ( $ container instanceof ContainerAwareInterface ) { $ parent = $ container -> getContainer ( ) ; if ( ! ( $ parent instanceof BaseContainerInterface ) ) { break ; } $ container = $ parent ; } return $ container ; }
8174	protected function checkLoopUsageCondition ( Twig_TokenStream $ stream , Twig_NodeInterface $ node ) { if ( $ node instanceof Twig_Node_Expression_GetAttr && $ node -> getNode ( 'node' ) instanceof Twig_Node_Expression_Name && 'loop' == $ node -> getNode ( 'node' ) -> getAttribute ( 'name' ) ) { throw new Twig_Error_Syntax ( 'The "loop" variable cannot be used in a looping condition.' , $ node -> getTemplateLine ( ) , $ stream -> getSourceContext ( ) ) ; } foreach ( $ node as $ n ) { if ( ! $ n ) { continue ; } $ this -> checkLoopUsageCondition ( $ stream , $ n ) ; } }
2668	public function getAuthDictionary ( $ version ) { $ name = Config :: AUTH_DICTIONARY_NAME ; $ dictionary = $ this -> getSingleDictionary ( $ version , $ name ) ; return $ dictionary ; }
8242	protected function handleLogin ( Request $ httpRequest ) { $ post = $ httpRequest -> request ; if ( ! $ post -> has ( "username" ) || ! $ post -> has ( "password" ) ) { return ; } if ( ! $ this -> picoAuth -> isValidCSRF ( $ post -> get ( "csrf_token" ) , self :: LOGIN_CSRF_ACTION ) ) { $ this -> picoAuth -> redirectToLogin ( null , $ httpRequest ) ; return ; } $ username = strtolower ( trim ( $ post -> get ( "username" ) ) ) ; $ password = new Password ( $ post -> get ( "password" ) ) ; if ( ! $ this -> limit -> action ( "login" , false , array ( "name" => $ username ) ) ) { $ this -> session -> addFlash ( "error" , $ this -> limit -> getError ( ) ) ; $ this -> picoAuth -> redirectToLogin ( null , $ httpRequest ) ; return ; } if ( ! $ this -> loginAttempt ( $ username , $ password ) ) { $ this -> logInvalidLoginAttempt ( $ username ) ; $ this -> limit -> action ( "login" , true , array ( "name" => $ username ) ) ; $ this -> session -> addFlash ( "error" , "Invalid username or password" ) ; $ this -> picoAuth -> redirectToLogin ( null , $ httpRequest ) ; return ; } else { $ userData = $ this -> storage -> getUserByName ( $ username ) ; if ( $ this -> needsPasswordRehash ( $ userData ) ) { $ this -> passwordRehash ( $ username , $ password ) ; } $ this -> login ( $ username , $ userData ) ; $ this -> picoAuth -> afterLogin ( ) ; } }
5713	public function updateItemEditForm ( $ form ) { if ( $ this -> owner -> record -> stat ( 'better_buttons_enabled' ) !== true ) { return false ; } Requirements :: css ( BETTER_BUTTONS_DIR . '/css/gridfield_betterbuttons.css' ) ; Requirements :: javascript ( BETTER_BUTTONS_DIR . '/javascript/gridfield_betterbuttons.js' ) ; $ actions = $ this -> owner -> record -> getBetterButtonsActions ( ) ; $ form -> setActions ( $ this -> filterFieldList ( $ form , $ actions ) ) ; if ( $ form -> Fields ( ) -> hasTabSet ( ) ) { $ form -> Fields ( ) -> findOrMakeTab ( 'Root' ) -> setTemplate ( TabSet :: class ) ; $ form -> addExtraClass ( 'cms-tabset' ) ; } $ utils = $ this -> owner -> record -> getBetterButtonsUtils ( ) ; $ form -> Utils = $ this -> filterFieldList ( $ form , $ utils ) ; $ form -> setTemplate ( [ 'type' => 'Includes' , 'BetterButtons_EditForm' , ] ) ; $ form -> addExtraClass ( 'better-buttons-form' ) ; }
3320	public function getValidValues ( ) { if ( $ this -> validValues ) { if ( is_callable ( $ this -> validValues ) ) { return call_user_func ( $ this -> validValues ) ; } return $ this -> validValues ; } return ; }
11893	private function createEditForm ( CustomField $ entity , $ type ) { $ form = $ this -> createForm ( 'custom_field_choice' , $ entity , array ( 'action' => $ this -> generateUrl ( 'customfield_update' , array ( 'id' => $ entity -> getId ( ) ) ) , 'method' => 'PUT' , 'type' => $ type , 'group_widget' => 'hidden' ) ) ; $ form -> add ( 'submit' , 'submit' , array ( 'label' => 'Update' ) ) ; return $ form ; }
1842	public function process ( ContainerBuilder $ container ) : void { if ( ! $ container -> has ( 'contao.fragment.registry' ) ) { return ; } $ this -> registerFragments ( $ container , ContentElementReference :: TAG_NAME ) ; $ this -> registerFragments ( $ container , FrontendModuleReference :: TAG_NAME ) ; }
9503	public function joinCommand ( array $ parts ) { $ command = 'php ' . implode ( ' ' , $ parts ) ; $ stripped = str_replace ( '--watch' , '' , $ command ) ; return trim ( $ stripped ) ; }
1811	public function addCteType ( $ arrRow ) { $ key = $ arrRow [ 'invisible' ] ? 'unpublished' : 'published' ; $ type = $ GLOBALS [ 'TL_LANG' ] [ 'CTE' ] [ $ arrRow [ 'type' ] ] [ 0 ] ? : '&nbsp;' ; $ class = 'limit_height' ; if ( \ in_array ( $ arrRow [ 'type' ] , $ GLOBALS [ 'TL_WRAPPERS' ] [ 'start' ] ) || \ in_array ( $ arrRow [ 'type' ] , $ GLOBALS [ 'TL_WRAPPERS' ] [ 'separator' ] ) || \ in_array ( $ arrRow [ 'type' ] , $ GLOBALS [ 'TL_WRAPPERS' ] [ 'stop' ] ) ) { $ class = '' ; if ( ( $ group = $ this -> getContentElementGroup ( $ arrRow [ 'type' ] ) ) !== null ) { $ type = $ GLOBALS [ 'TL_LANG' ] [ 'CTE' ] [ $ group ] . ' (' . $ type . ')' ; } } elseif ( \ in_array ( $ arrRow [ 'type' ] , $ GLOBALS [ 'TL_WRAPPERS' ] [ 'single' ] ) ) { if ( ( $ group = $ this -> getContentElementGroup ( $ arrRow [ 'type' ] ) ) !== null ) { $ type = $ GLOBALS [ 'TL_LANG' ] [ 'CTE' ] [ $ group ] . ' (' . $ type . ')' ; } } if ( $ arrRow [ 'type' ] == 'alias' ) { $ type .= ' ID ' . $ arrRow [ 'cteAlias' ] ; } if ( $ arrRow [ 'protected' ] ) { $ type .= ' (' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'protected' ] . ')' ; } elseif ( $ arrRow [ 'guests' ] ) { $ type .= ' (' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'guests' ] . ')' ; } if ( $ arrRow [ 'type' ] == 'headline' ) { if ( \ is_array ( $ headline = Contao \ StringUtil :: deserialize ( $ arrRow [ 'headline' ] ) ) ) { $ type .= ' (' . $ headline [ 'unit' ] . ')' ; } } if ( ! Contao \ Config :: get ( 'doNotCollapse' ) ) { $ class .= ' h40' ; } $ objModel = new Contao \ ContentModel ( ) ; $ objModel -> setRow ( $ arrRow ) ; return '<div class="cte_type ' . $ key . '">' . $ type . '</div><div class="' . trim ( $ class ) . '">' . Contao \ StringUtil :: insertTagToSrc ( $ this -> getContentElement ( $ objModel ) ) . '</div>' . "\n" ; }
11008	public function addReportUri ( string $ reportUri ) : bool { if ( ! filter_var ( $ reportUri , FILTER_VALIDATE_URL ) ) { throw new MiddlewareException ( $ this , sprintf ( "'%s' is not a valid URI and can not be set as the CSP report URI" , $ reportUri ) ) ; } if ( ! in_array ( $ reportUri , $ this -> tags [ 'report-uri' ] ) ) { $ this -> tags [ 'report-uri' ] [ ] = $ reportUri ; return true ; } return false ; }
2122	public function add ( $ strFile , $ strVersion = null , $ strMedia = 'all' ) { $ strType = strrchr ( $ strFile , '.' ) ; if ( $ strType != self :: CSS && $ strType != self :: JS && $ strType != self :: SCSS && $ strType != self :: LESS ) { throw new \ InvalidArgumentException ( "Invalid file $strFile" ) ; } $ strMode = ( $ strType == self :: JS ) ? self :: JS : self :: CSS ; if ( $ this -> strMode === null ) { $ this -> strMode = $ strMode ; } elseif ( $ this -> strMode != $ strMode ) { throw new \ LogicException ( 'You cannot mix different file types. Create another Combiner object instead.' ) ; } if ( ! file_exists ( $ this -> strRootDir . '/' . $ strFile ) ) { if ( file_exists ( $ this -> strRootDir . '/' . $ this -> strWebDir . '/' . $ strFile ) ) { $ strFile = $ this -> strWebDir . '/' . $ strFile ; } else { return ; } } if ( isset ( $ this -> arrFiles [ $ strFile ] ) ) { return ; } if ( $ strVersion === null ) { $ strVersion = filemtime ( $ this -> strRootDir . '/' . $ strFile ) ; } $ arrFile = array ( 'name' => $ strFile , 'version' => $ strVersion , 'media' => $ strMedia , 'extension' => $ strType ) ; $ this -> arrFiles [ $ strFile ] = $ arrFile ; $ this -> strKey .= '-f' . $ strFile . '-v' . $ strVersion . '-m' . $ strMedia ; }
8244	public function login ( $ id , $ userData ) { $ this -> abortIfExpired ( $ id , $ userData ) ; $ u = new User ( ) ; $ u -> setAuthenticated ( true ) ; $ u -> setAuthenticator ( $ this -> getName ( ) ) ; $ u -> setId ( $ id ) ; if ( isset ( $ userData [ 'groups' ] ) ) { $ u -> setGroups ( $ userData [ 'groups' ] ) ; } if ( isset ( $ userData [ 'displayName' ] ) ) { $ u -> setDisplayName ( $ userData [ 'displayName' ] ) ; } if ( isset ( $ userData [ 'attributes' ] ) ) { foreach ( $ userData [ 'attributes' ] as $ key => $ value ) { $ u -> setAttribute ( $ key , $ value ) ; } } $ this -> picoAuth -> setUser ( $ u ) ; }
11307	public function sendMessage ( $ chatId , $ text , $ disableWebPagePreview = null , $ replyToMessageId = null , $ replyMarkup = null ) { $ response = $ this -> apiRequest ( "sendMessage" , [ "chat_id" => $ chatId , "text" => $ text , "disable_web_page_preview" => $ disableWebPagePreview , "reply_to_message_id" => $ replyToMessageId , "reply_markup" => $ replyMarkup ? $ replyMarkup -> toArray ( ) : null , ] ) ; return $ this -> entityFromBody ( $ response -> getBody ( ) , new Message ( ) ) ; }
10980	public function preRemove ( LifecycleEventArgs $ args ) : void { if ( ! $ this -> enableIndexing ) { return ; } $ this -> removeEntity ( $ args -> getObject ( ) , $ args -> getObjectManager ( ) ) ; }
5589	public function getBaseCookieValue ( $ name , $ base ) { if ( ! $ base ) { return ; } return $ this -> getCookieValue ( $ base -> getHost ( ) , $ base -> getPath ( ) , $ name ) ; }
9524	public function deploy ( ) { $ pullRequest = getenv ( 'TRAVIS_PULL_REQUEST' ) ; $ branch = getenv ( 'TRAVIS_BRANCH' ) ; if ( ( int ) $ pullRequest >= 1 ) { die ( 'Not deploying pull requests.' . PHP_EOL ) ; } if ( ! array_key_exists ( $ branch , $ this -> branches ) ) { die ( 'Branch ' . $ branch . ' has no environment to deploy to.' . PHP_EOL ) ; } $ environment = $ this -> branches [ $ branch ] ; echo 'Downloading Deployer.phar...' . PHP_EOL ; passthru ( 'wget http://deployer.org/deployer.phar' ) ; echo 'Deploying...' . PHP_EOL ; $ deployCommand = 'php deployer.phar deploy' ; $ deployCommand .= ' ' . $ environment ; $ deployCommand .= $ this -> verbose ? ' -vvv' : '' ; passthru ( $ deployCommand ) ; }
4336	private function closeOpenGroups ( ) { $ this -> data [ 'groupPriorityStack' ] [ ] = 'main' ; while ( $ this -> data [ 'groupPriorityStack' ] ) { $ priority = \ array_pop ( $ this -> data [ 'groupPriorityStack' ] ) ; foreach ( $ this -> data [ 'groupStacks' ] [ $ priority ] as $ i => $ info ) { if ( $ info [ 'collect' ] ) { unset ( $ this -> data [ 'groupStacks' ] [ $ priority ] [ $ i ] ) ; $ meta = array ( 'channel' => $ info [ 'channel' ] , ) ; if ( $ priority === 'main' ) { $ this -> data [ 'log' ] [ ] = array ( 'groupEnd' , array ( ) , $ meta ) ; } else { $ this -> data [ 'logSummary' ] [ $ priority ] [ ] = array ( 'groupEnd' , array ( ) , $ meta ) ; } } } } }
11027	protected function city ( ) { $ pluginOptions = [ 'url' => Url :: to ( [ "/{$this->module->id}/city/list" ] ) , 'depends' => [ $ this -> fieldIds [ 'country' ] ] ] ; if ( isset ( $ this -> fieldIds [ 'state' ] ) ) { $ pluginOptions [ 'depends' ] [ ] = $ this -> fieldIds [ 'state' ] ; $ pluginOptions [ 'initDepends' ] = [ $ this -> fieldIds [ 'country' ] ] ; } else { $ pluginOptions [ 'depends' ] [ ] = null ; } if ( isset ( $ this -> fieldIds [ 'region' ] ) ) { $ pluginOptions [ 'depends' ] [ ] = $ this -> fieldIds [ 'region' ] ; if ( isset ( $ this -> fieldIds [ 'state' ] ) ) { $ pluginOptions [ 'initDepends' ] [ ] = $ this -> fieldIds [ 'state' ] ; } } else { $ pluginOptions [ 'depends' ] [ ] = null ; } $ this -> parts [ '{city}' ] = $ this -> form -> field ( $ this -> model , $ this -> model -> getCityPropertyName ( ) ) -> widget ( DepDrop :: className ( ) , [ 'options' => [ 'id' => $ this -> fieldIds [ 'city' ] , 'cityholder' => Yii :: t ( 'jlorente/location' , 'Select city' ) , 'name' => $ this -> getSubmitModelName ( $ this -> model -> getCityPropertyName ( ) ) ] , 'data' => ArrayHelper :: map ( City :: find ( ) -> where ( [ 'region_id' => $ this -> model -> region_id ] ) -> orderBy ( [ 'name' => SORT_ASC ] ) -> all ( ) , 'id' , 'name' ) , 'pluginOptions' => $ pluginOptions ] ) ; }
10198	private function writeRows ( XMLWriter $ objWriter , Worksheet $ sheet ) { $ numberRowsRepeated = self :: NUMBER_ROWS_REPEATED_MAX ; $ span_row = 0 ; $ rows = $ sheet -> getRowIterator ( ) ; while ( $ rows -> valid ( ) ) { -- $ numberRowsRepeated ; $ row = $ rows -> current ( ) ; if ( $ row -> getCellIterator ( ) -> valid ( ) ) { if ( $ span_row ) { $ objWriter -> startElement ( 'table:table-row' ) ; if ( $ span_row > 1 ) { $ objWriter -> writeAttribute ( 'table:number-rows-repeated' , $ span_row ) ; } $ objWriter -> startElement ( 'table:table-cell' ) ; $ objWriter -> writeAttribute ( 'table:number-columns-repeated' , self :: NUMBER_COLS_REPEATED_MAX ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ span_row = 0 ; } $ objWriter -> startElement ( 'table:table-row' ) ; $ this -> writeCells ( $ objWriter , $ row ) ; $ objWriter -> endElement ( ) ; } else { ++ $ span_row ; } $ rows -> next ( ) ; } }
7216	protected function getTaxGroupFromEvent ( ResourceEventInterface $ event ) { $ resource = $ event -> getResource ( ) ; if ( ! $ resource instanceof TaxGroupInterface ) { throw new InvalidArgumentException ( 'Expected instance of ' . TaxGroupInterface :: class ) ; } return $ resource ; }
9055	public function addColumnToRename ( string $ name , Column $ column ) : self { $ this -> oldColumns [ $ name ] = $ column ; return $ this ; }
5138	public static function handleException ( \ Throwable $ e ) { if ( php_sapi_name ( ) == 'cli' ) { $ handler = new ConsoleHandler ( self :: $ output ) ; } else { $ handler = new HtmlHandler ( HtmlHandler :: INVERTED ) ; } fwrite ( self :: $ output , $ handler -> renderException ( $ e , AbstractHandler :: VERBOSITY_VERBOSE ) ) ; }
11359	public function update ( $ previousPermalink , $ newPermalink ) { $ blocks = $ this -> permalinks [ $ previousPermalink ] ; $ this -> remove ( $ previousPermalink ) ; $ this -> permalinks [ $ newPermalink ] = $ blocks ; return $ this ; }
8769	public function bootstrap ( ) { $ this -> hasBeenBootstrapped = true ; $ this [ 'events' ] -> dispatch ( 'bootstrapping' , [ $ this ] ) ; $ this -> boot ( ) ; $ this [ 'events' ] -> dispatch ( 'bootstrapped' , [ $ this ] ) ; }
5769	public function setSql ( ) { $ this -> args [ ] = $ this -> updateOnColumnValue ; $ lastArgNum = count ( $ this -> args ) ; $ this -> sql = "UPDATE $this->dbTable SET $this->setColumnsValues WHERE $this->updateOnColumnName = $" . $ lastArgNum ; }
11957	public function add ( $ renderer , $ name = null ) { if ( is_null ( $ name ) ) { $ name = $ renderer ; } $ this -> renderers [ $ name ] = $ renderer ; }
9861	private function writeDimension ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { $ objWriter -> startElement ( 'dimension' ) ; $ objWriter -> writeAttribute ( 'ref' , $ pSheet -> calculateWorksheetDimension ( ) ) ; $ objWriter -> endElement ( ) ; }
2801	protected static function generateNonLazyBeanCode ( string $ padding , string $ beanId , string $ beanType , Bean $ beanMetadata , string $ methodParams , ForceLazyInitProperty $ forceLazyInitProperty , SessionBeansProperty $ sessionBeansProperty , BeanPostProcessorsProperty $ postProcessorsProperty , WrapBeanAsLazy $ wrapBeanAsLazy ) : string { $ content = $ padding . '$backupForceLazyInit = $this->' . $ forceLazyInitProperty -> getName ( ) . ';' . PHP_EOL ; if ( $ beanMetadata -> isSession ( ) ) { $ content .= $ padding . 'if($this->' . $ sessionBeansProperty -> getName ( ) . '->has("' . $ beanId . '")) {' . PHP_EOL ; if ( $ beanMetadata -> isSingleton ( ) ) { $ content .= $ padding . ' $sessionInstance = clone $this->' . $ sessionBeansProperty -> getName ( ) . '->get("' . $ beanId . '");' . PHP_EOL ; } else { $ content .= $ padding . ' $sessionInstance = $this->' . $ sessionBeansProperty -> getName ( ) . '->get("' . $ beanId . '");' . PHP_EOL ; } $ content .= $ padding . ' return ($backupForceLazyInit) ? $this->' . $ wrapBeanAsLazy -> getName ( ) . '("' . $ beanId . '", "' . $ beanType . '", $sessionInstance) : $sessionInstance;' . PHP_EOL ; $ content .= $ padding . '}' . PHP_EOL ; } if ( $ beanMetadata -> isSingleton ( ) ) { $ content .= $ padding . 'static $instance = null;' . PHP_EOL ; $ content .= $ padding . 'if ($instance !== null) {' . PHP_EOL ; $ content .= $ padding . ' return ($backupForceLazyInit) ? $this->' . $ wrapBeanAsLazy -> getName ( ) . '("' . $ beanId . '", "' . $ beanType . '", $instance) : $instance;' . PHP_EOL ; $ content .= $ padding . '}' . PHP_EOL ; } if ( $ beanMetadata -> isSession ( ) ) { $ content .= $ padding . '$this->' . $ forceLazyInitProperty -> getName ( ) . ' = true;' . PHP_EOL ; } $ content .= self :: generateBeanCreationCode ( $ padding , $ beanId , $ methodParams , $ postProcessorsProperty ) ; if ( $ beanMetadata -> isSession ( ) ) { $ content .= $ padding . '$this->' . $ forceLazyInitProperty -> getName ( ) . ' = $backupForceLazyInit;' . PHP_EOL ; $ content .= $ padding . '$this->' . $ sessionBeansProperty -> getName ( ) . '->add("' . $ beanId . '", $instance);' . PHP_EOL ; } $ content .= $ padding . 'return ($backupForceLazyInit) ? $this->' . $ wrapBeanAsLazy -> getName ( ) . '("' . $ beanId . '", "' . $ beanType . '", $instance) : $instance;' . PHP_EOL ; return $ content ; }
10589	public function buildPayoutFromId ( $ sPayoutId ) { $ oPayout = new Freeagent \ DataWrapper \ PayoutVO ( ) ; $ oPayout -> setId ( $ sPayoutId ) ; try { $ oDets = $ this -> getTxnChargeDetails ( $ sPayoutId ) ; $ oPayout -> setDateArrival ( strtotime ( $ oDets -> PaymentDate ) ) -> setCurrency ( $ oDets -> GrossAmount -> currencyID ) ; $ oPayout -> addCharge ( $ this -> buildChargeFromTransaction ( $ sPayoutId ) ) ; } catch ( \ Exception $ oE ) { } return $ oPayout ; }
3442	public function fetchUsing ( $ methodAndParams ) { if ( is_string ( $ methodAndParams ) || empty ( $ methodAndParams [ 'method' ] ) ) { $ this -> fetchUsing = in_array ( $ methodAndParams , [ 'GetNext' , 'getNext' ] ) ? [ 'method' => 'GetNext' , 'params' => [ true , true ] ] : [ 'method' => 'Fetch' ] ; return $ this ; } if ( in_array ( $ methodAndParams [ 'method' ] , [ 'GetNext' , 'getNext' ] ) ) { $ bTextHtmlAuto = isset ( $ methodAndParams [ 'params' ] [ 0 ] ) ? $ methodAndParams [ 'params' ] [ 0 ] : true ; $ useTilda = isset ( $ methodAndParams [ 'params' ] [ 1 ] ) ? $ methodAndParams [ 'params' ] [ 1 ] : true ; $ this -> fetchUsing = [ 'method' => 'GetNext' , 'params' => [ $ bTextHtmlAuto , $ useTilda ] ] ; } else { $ this -> fetchUsing = [ 'method' => 'Fetch' ] ; } return $ this ; }
12875	public static function getJSON ( $ src ) { $ src = file_get_contents ( $ src ) ; $ out = json_decode ( $ src , true ) ; return $ out ; }
12805	private static function getColumnName ( string $ name ) : ? string { $ class = self :: getStaticChildClass ( ) ; if ( self :: $ columnPropertiesCache === null || ! array_key_exists ( $ class , self :: $ columnPropertiesCache ) || self :: $ columnPropertiesCache [ $ class ] === null ) self :: buildColumnPropertiesCache ( ) ; if ( array_key_exists ( $ name , self :: $ columnPropertiesCache [ $ class ] ) ) return $ name ; foreach ( self :: $ columnPropertiesCache [ $ class ] as $ column => $ properties ) { if ( in_array ( $ name , $ properties ) ) return $ column ; } return null ; }
4288	public function onError ( Event $ event ) { if ( $ event [ 'inConsole' ] || ! $ event [ 'isFirstOccur' ] ) { return ; } $ this -> processLogEntry ( 'errorNotConsoled' , array ( $ event [ 'typeStr' ] . ': ' . $ event [ 'file' ] . ' (line ' . $ event [ 'line' ] . '): ' . $ event [ 'message' ] ) , array ( 'channel' => 'phpError' , 'class' => $ event [ 'type' ] & $ this -> debug -> getCfg ( 'errorMask' ) ? 'danger' : 'warning' , ) ) ; }
12281	public function getCode ( ) { $ data = [ 'component_appid' => $ this -> getAppId ( ) , ] ; $ result = $ this -> parseJSON ( 'json' , [ self :: CREATE_PRE_AUTH_CODE , $ data ] ) ; if ( empty ( $ result [ 'pre_auth_code' ] ) ) { throw new InvalidArgumentException ( 'Invalid response.' ) ; } return $ result [ 'pre_auth_code' ] ; }
2095	protected function createDateRanges ( ) { if ( ! empty ( $ this -> arrRange ) ) { return ; } $ intYear = date ( 'Y' , $ this -> strDate ) ; $ intMonth = date ( 'm' , $ this -> strDate ) ; $ intDay = date ( 'd' , $ this -> strDate ) ; $ this -> arrRange [ 'day' ] [ 'begin' ] = mktime ( 0 , 0 , 0 , $ intMonth , $ intDay , $ intYear ) ; $ this -> arrRange [ 'day' ] [ 'end' ] = mktime ( 23 , 59 , 59 , $ intMonth , $ intDay , $ intYear ) ; $ this -> arrRange [ 'month' ] [ 'begin' ] = mktime ( 0 , 0 , 0 , $ intMonth , 1 , $ intYear ) ; $ this -> arrRange [ 'month' ] [ 'end' ] = mktime ( 23 , 59 , 59 , $ intMonth , date ( 't' , $ this -> strDate ) , $ intYear ) ; $ this -> arrRange [ 'year' ] [ 'begin' ] = mktime ( 0 , 0 , 0 , 1 , 1 , $ intYear ) ; $ this -> arrRange [ 'year' ] [ 'end' ] = mktime ( 23 , 59 , 59 , 12 , 31 , $ intYear ) ; }
2827	public function formatNumber ( $ number , $ precision = 2 ) { return $ this -> helper -> useStoreLocale ( ) ? $ this -> helper -> formatNumber ( $ number , $ precision ) : number_format ( $ number , $ precision ) ; }
4273	public function stream_eof ( ) { if ( ! $ this -> handle ) { return false ; } self :: restorePrev ( ) ; $ result = \ feof ( $ this -> handle ) ; self :: register ( ) ; return $ result ; }
2462	public function generateMarkup ( ) { $ intMaxSize = round ( static :: getMaxUploadSize ( ) / 1024 / 1024 ) ; $ strAccepted = implode ( ',' , array_map ( function ( $ a ) { return '.' . $ a ; } , StringUtil :: trimsplit ( ',' , strtolower ( Config :: get ( 'uploadTypes' ) ) ) ) ) ; $ GLOBALS [ 'TL_CSS' ] [ ] = 'assets/dropzone/css/dropzone.min.css' ; $ GLOBALS [ 'TL_JAVASCRIPT' ] [ ] = 'assets/dropzone/js/dropzone.min.js' ; $ return = ' <input type="hidden" name="action" value="fileupload"> <div class="fallback"> <input type="file" name="' . $ this -> strName . '[]" class="tl_upload_field" onfocus="Backend.getScrollOffset()" multiple> </div> <div class="dropzone"> <div class="dz-default dz-message"> <span>' . $ GLOBALS [ 'TL_LANG' ] [ 'tl_files' ] [ 'dropzone' ] . '</span> </div> <span class="dropzone-previews"></span> </div> <script> Dropzone.autoDiscover = false; window.addEvent("domready", function() { new Dropzone("#tl_files", { paramName: "' . $ this -> strName . '", maxFilesize: ' . $ intMaxSize . ', acceptedFiles: "' . $ strAccepted . '", timeout: 0, previewsContainer: ".dropzone-previews", clickable: ".dropzone", dictFileTooBig: ' . json_encode ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_files' ] [ 'dropzoneFileTooBig' ] ) . ', dictInvalidFileType: ' . json_encode ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_files' ] [ 'dropzoneInvalidType' ] ) . ' }).on("addedfile", function() { $$(".dz-message").setStyle("display", "none"); }).on("success", function(file, message) { if (!message) return; var container = $("tl_message"); if (!container) { container = new Element("div", { "id": "tl_message", "class": "tl_message" }).inject($("tl_buttons"), "before"); } container.appendHTML(message); }); $$("div.tl_formbody_submit").setStyle("display", "none"); }); </script>' ; if ( isset ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_files' ] [ 'fileupload' ] [ 1 ] ) ) { $ return .= ' <p class="tl_help tl_tip">' . sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_files' ] [ 'fileupload' ] [ 1 ] , System :: getReadableSize ( static :: getMaxUploadSize ( ) ) , Config :: get ( 'gdMaxImgWidth' ) . 'x' . Config :: get ( 'gdMaxImgHeight' ) ) . '</p>' ; } return $ return ; }
2421	public static function copyResource ( $ strSource , $ strDestination ) { $ objDatabase = Database :: getInstance ( ) ; $ objFile = FilesModel :: findByPath ( $ strSource ) ; if ( $ objFile === null ) { $ objFile = static :: addResource ( $ strSource ) ; } $ strFolder = \ dirname ( $ strDestination ) ; $ objNewFile = clone $ objFile -> current ( ) ; if ( $ strFolder == Config :: get ( 'uploadPath' ) ) { $ objNewFile -> pid = null ; } else { $ objFolder = FilesModel :: findByPath ( $ strFolder ) ; if ( $ objFolder === null ) { $ objFolder = static :: addResource ( $ strFolder ) ; } $ objNewFile -> pid = $ objFolder -> uuid ; } $ objNewFile -> tstamp = time ( ) ; $ objNewFile -> uuid = $ objDatabase -> getUuid ( ) ; $ objNewFile -> path = $ strDestination ; $ objNewFile -> name = basename ( $ strDestination ) ; $ objNewFile -> save ( ) ; if ( $ objFile -> type == 'folder' ) { $ objFiles = FilesModel :: findMultipleByBasepath ( $ strSource . '/' ) ; if ( $ objFiles !== null ) { while ( $ objFiles -> next ( ) ) { $ objNew = clone $ objFiles -> current ( ) ; $ objNew -> pid = $ objNewFile -> uuid ; $ objNew -> tstamp = time ( ) ; $ objNew -> uuid = $ objDatabase -> getUuid ( ) ; $ objNew -> path = str_replace ( $ strSource . '/' , $ strDestination . '/' , $ objFiles -> path ) ; $ objNew -> save ( ) ; } } } if ( ( $ strPath = \ dirname ( $ strSource ) ) != Config :: get ( 'uploadPath' ) ) { static :: updateFolderHashes ( $ strPath ) ; } if ( ( $ strPath = \ dirname ( $ strDestination ) ) != Config :: get ( 'uploadPath' ) ) { static :: updateFolderHashes ( $ strPath ) ; } return $ objNewFile ; }
1868	public function maintenanceCheck ( ) { $ this -> import ( BackendUser :: class , 'User' ) ; if ( ! $ this -> User -> hasAccess ( 'maintenance' , 'modules' ) ) { return '' ; } try { if ( System :: getContainer ( ) -> get ( 'lexik_maintenance.driver.factory' ) -> getDriver ( ) -> isExists ( ) ) { return '<p class="tl_error">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'maintenanceEnabled' ] . '</p>' ; } } catch ( \ Exception $ e ) { } return '' ; }
12444	public static function run ( $ source , $ destination , $ width , $ height = "" ) { $ mime = exif_imagetype ( $ source ) ; switch ( $ mime ) { case IMAGETYPE_JPEG : $ source = imagecreatefromjpeg ( $ source ) ; break ; case IMAGETYPE_PNG : $ source = imagecreatefrompng ( $ source ) ; break ; case IMAGETYPE_GIF : $ source = imagecreatefromgif ( $ source ) ; break ; default : return ; } $ width_src = imagesx ( $ source ) ; $ height_src = imagesy ( $ source ) ; $ width_dest = 0 ; $ height_dest = 0 ; if ( ! $ height ) { $ ratio = ( $ width * 100 ) / $ width_src ; if ( $ ratio > 100 ) { imagejpeg ( $ source , $ destination , 70 ) ; imagedestroy ( $ source ) ; return ; } $ width_dest = $ width ; $ height_dest = $ height_src * $ ratio / 100 ; } else { if ( $ height_src >= $ width_src ) { $ height_dest = ( $ height_src * $ width ) / $ width_src ; $ width_dest = $ width ; } elseif ( $ height_src < $ width_src ) { $ width_dest = ( $ width_src * $ height ) / $ height_src ; $ height_dest = $ height ; } } $ emptyPicture = imagecreatetruecolor ( $ width , ( $ height ) ? $ height : $ height_dest ) ; imagecopyresampled ( $ emptyPicture , $ source , 0 , 0 , 0 , 0 , $ width_dest , $ height_dest , $ width_src , $ height_src ) ; imagejpeg ( $ emptyPicture , $ destination , 70 ) ; imagedestroy ( $ source ) ; imagedestroy ( $ emptyPicture ) ; return ; }
12635	protected function getSignkey ( $ api ) { return $ this -> sandboxEnabled && $ api !== self :: API_SANDBOX_SIGN_KEY ? $ this -> getSandboxSignKey ( ) : $ this -> merchant -> key ; }
6139	public static function check ( $ uri ) { try { $ uri = new self ( strval ( $ uri ) ) ; } catch ( Ts3Exception $ e ) { return false ; } return $ uri -> valid ( ) ; }
8383	public function fetchAll ( ) { if ( $ this -> statement == null || $ this -> getErrorState ( ) != '00000' ) { return false ; } return $ this -> statement -> fetchAll ( \ PDO :: FETCH_ASSOC ) ; }
3217	function chunkedUploadContinue ( $ uploadId , $ byteOffset , $ data ) { Checker :: argStringNonEmpty ( "uploadId" , $ uploadId ) ; Checker :: argNat ( "byteOffset" , $ byteOffset ) ; Checker :: argString ( "data" , $ data ) ; $ response = $ this -> _chunkedUpload ( array ( "upload_id" => $ uploadId , "offset" => $ byteOffset ) , $ data ) ; if ( $ response -> statusCode === 404 ) { return false ; } $ correction = self :: _chunkedUploadCheckForOffsetCorrection ( $ response ) ; if ( $ correction !== null ) { list ( $ correctedUploadId , $ correctedByteOffset ) = $ correction ; if ( $ correctedUploadId !== $ uploadId ) throw new Exception_BadResponse ( "Corrective 400 upload_id mismatch: us=" . Util :: q ( $ uploadId ) . " server=" . Util :: q ( $ correctedUploadId ) ) ; if ( $ correctedByteOffset === $ byteOffset ) throw new Exception_BadResponse ( "Corrective 400 offset is the same as ours: $byteOffset" ) ; return $ correctedByteOffset ; } if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; list ( $ retUploadId , $ retByteOffset ) = self :: _chunkedUploadParse200Response ( $ response -> body ) ; $ nextByteOffset = $ byteOffset + strlen ( $ data ) ; if ( $ uploadId !== $ retUploadId ) throw new Exception_BadResponse ( "upload_id mismatch: us=" . Util :: q ( $ uploadId ) . ", server=" . Util :: q ( $ uploadId ) ) ; if ( $ nextByteOffset !== $ retByteOffset ) throw new Exception_BadResponse ( "next-offset mismatch: us=$nextByteOffset, server=$retByteOffset" ) ; return true ; }
4017	protected function handleLoadCallback ( $ field , $ value ) { if ( isset ( $ field [ 'load_callback' ] ) && is_array ( $ field [ 'load_callback' ] ) ) { foreach ( $ field [ 'load_callback' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ value = $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ value , $ this ) ; } } return $ value ; }
3573	protected function setInstance ( Attribute $ attribute ) { if ( $ this -> has ( $ attribute -> getMetaKey ( ) ) ) { $ this -> update ( $ attribute ) ; } else { $ this -> items [ $ attribute -> getMetaKey ( ) ] = $ attribute ; } return $ this ; }
4755	public function stopProfiling ( ) { if ( ! $ this -> profiling ) { return false ; } $ this -> profiling = false ; $ xhprof_data = xhprof_disable ( ) ; if ( is_array ( $ xhprof_data ) ) { $ this -> parser -> parse ( $ xhprof_data ) ; } foreach ( $ this -> probes as $ probe ) { $ name = $ probe -> getName ( ) ; if ( $ probe -> isTimingProbe ( ) ) { $ this -> timers [ $ name ] = $ probe -> getTime ( ) ; } if ( $ probe -> isCallsProbe ( ) ) { $ this -> counters [ $ name ] = $ probe -> getCount ( ) ; } } return true ; }
9475	public function stripQuotes ( $ string ) { if ( strlen ( $ string ) < 2 || substr ( $ string , 0 , 1 ) !== '"' || substr ( $ string , - 1 , 1 ) !== '"' ) { return $ string ; } return substr ( $ string , 1 , - 1 ) ; }
5808	public function onAfterDelete ( ) { parent :: onAfterDelete ( ) ; $ fusion = FusionTag :: get ( ) -> byID ( $ this -> owner -> FusionTagID ) ; $ types = unserialize ( $ fusion -> TagTypes ) ; unset ( $ types [ $ this -> owner -> ClassName ] ) ; $ fusion -> TagTypes = ! empty ( $ types ) ? serialize ( $ types ) : null ; $ fusion -> write ( ) ; }
5287	public static function request ( $ method , $ params = null ) { $ url = self :: getUrl ( $ method ) ; $ request_method = self :: getRequestMethodName ( ) ; $ response_body = self :: $ request_method ( $ url , $ params ) ; $ response = json_decode ( $ response_body ) ; if ( ! is_object ( $ response ) ) throw new Error ( "Invalid server response: $response_body" ) ; if ( isset ( $ response -> error ) ) throw new Error ( $ response -> error -> message ) ; return $ response ; }
3790	private function determineLanguages ( ) { $ languages = $ this -> getMetaModel ( ) -> getAvailableLanguages ( ) ; if ( $ languages === null ) { throw new \ RuntimeException ( 'MetaModel ' . $ this -> getMetaModel ( ) -> getName ( ) . ' does not seem to be translated.' ) ; } return $ languages ; }
11496	public static function end ( ) { if ( self :: $ startTime ) { $ time = round ( ( microtime ( true ) - self :: $ startTime ) , 4 ) ; self :: $ startTime = false ; } return ( isset ( $ time ) ) ? $ time : false ; }
470	public function up ( ) { $ transaction = $ this -> db -> beginTransaction ( ) ; try { if ( $ this -> safeUp ( ) === false ) { $ transaction -> rollBack ( ) ; return false ; } $ transaction -> commit ( ) ; } catch ( \ Exception $ e ) { $ this -> printException ( $ e ) ; $ transaction -> rollBack ( ) ; return false ; } catch ( \ Throwable $ e ) { $ this -> printException ( $ e ) ; $ transaction -> rollBack ( ) ; return false ; } return null ; }
1656	public function add ( $ message ) { if ( is_string ( $ message ) ) { $ this -> messages [ ] = new SimpleResponse ( $ message ) ; } elseif ( $ message instanceof ResponseInterface ) { $ this -> messages [ ] = $ message ; } elseif ( $ message instanceof QuestionInterface ) { $ this -> messages [ ] = $ message ; } return $ this ; }
5693	public function Form ( ) { $ formAction = $ this -> getFormActionFromRequest ( $ this -> request ) ; $ fields = $ formAction -> getFields ( ) ; $ fields -> push ( HiddenField :: create ( 'action' , '' , $ formAction -> getButtonName ( ) ) ) ; $ form = Form :: create ( $ this , 'Form' , $ fields , FieldList :: create ( FormAction :: create ( 'nestedFormSave' , 'Save' ) ) ) ; return $ form ; }
5785	public function addColumn ( string $ name , $ value ) { $ this -> args [ ] = $ value ; if ( mb_strlen ( $ this -> columns ) > 0 ) { $ this -> columns .= ", " ; } $ this -> columns .= $ name ; if ( mb_strlen ( $ this -> values ) > 0 ) { $ this -> values .= ", " ; } $ argNum = count ( $ this -> args ) ; $ this -> values .= "$" . $ argNum ; }
97	private function selectRestVersion ( $ channelXml , $ supportedVersions ) { $ channelXml -> registerXPathNamespace ( 'ns' , self :: CHANNEL_NS ) ; foreach ( $ supportedVersions as $ version ) { $ xpathTest = "ns:servers/ns:*/ns:rest/ns:baseurl[@type='{$version}']" ; $ testResult = $ channelXml -> xpath ( $ xpathTest ) ; foreach ( $ testResult as $ result ) { $ result = ( string ) $ result ; if ( preg_match ( '{^https://}i' , $ result ) ) { return array ( 'version' => $ version , 'baseUrl' => $ result ) ; } } if ( count ( $ testResult ) > 0 ) { return array ( 'version' => $ version , 'baseUrl' => ( string ) $ testResult [ 0 ] ) ; } } return null ; }
1909	private function stripNamespace ( string $ fqcn ) : string { if ( false !== ( $ pos = strrpos ( $ fqcn , '\\' ) ) ) { return substr ( $ fqcn , $ pos + 1 ) ; } return $ fqcn ; }
11609	public function actionDisconnect ( $ id ) { $ account = $ this -> finder -> findAccountById ( $ id ) ; if ( $ account === null ) { throw new NotFoundHttpException ; } if ( $ account -> user_id != \ Yii :: $ app -> user -> id ) { throw new ForbiddenHttpException ; } $ account -> delete ( ) ; return $ this -> redirect ( [ 'networks' ] ) ; }
2051	public function save ( ) { $ groups = $ this -> groups ; $ this -> arrData [ 'groups' ] = $ this -> arrGroups ; parent :: save ( ) ; $ this -> groups = $ groups ; }
10202	public function setHorizontal ( $ pValue ) { if ( $ pValue == '' ) { $ pValue = self :: HORIZONTAL_GENERAL ; } if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'horizontal' => $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> horizontal = $ pValue ; } return $ this ; }
5416	protected function dispatchRequest ( $ socket , $ encoding ) { foreach ( $ this -> headers as $ header_line ) { $ socket -> write ( $ header_line . "\r\n" ) ; } if ( count ( $ this -> cookies ) > 0 ) { $ socket -> write ( 'Cookie: ' . implode ( ';' , $ this -> cookies ) . "\r\n" ) ; } $ encoding -> writeHeadersTo ( $ socket ) ; $ socket -> write ( "\r\n" ) ; $ encoding -> writeTo ( $ socket ) ; }
12175	public function addOptionalScalarArgument ( $ name , $ type , $ default ) { return $ this -> addArgument ( new ScalarArgument ( $ this -> argumentPosition ++ , $ name , $ type , false , $ default ) ) ; }
3791	protected function fetchExistingIdsFor ( $ idList , $ langCode ) { $ queryBuilder = $ this -> connection -> createQueryBuilder ( ) -> select ( 'item_id' ) -> from ( $ this -> getValueTable ( ) ) ; $ this -> buildWhere ( $ queryBuilder , $ idList , $ langCode ) ; $ statement = $ queryBuilder -> execute ( ) ; return $ statement -> fetchAll ( \ PDO :: FETCH_COLUMN ) ; }
2043	public static function findByEmailAndPids ( $ strEmail , $ arrPids , array $ arrOptions = array ( ) ) { if ( empty ( $ arrPids ) || ! \ is_array ( $ arrPids ) ) { return null ; } $ t = static :: $ strTable ; return static :: findBy ( array ( "$t.email=? AND $t.pid IN(" . implode ( ',' , array_map ( '\intval' , $ arrPids ) ) . ")" ) , $ strEmail , $ arrOptions ) ; }
7982	public function addDeleteTask ( $ sessionId ) { return json_decode ( self :: getClient ( ) -> createPcaDeleteTask ( $ this -> pp , $ this -> sn , $ sessionId ) ) ; }
11916	public function response ( array $ data , $ http_code ) { if ( config ( 'odin.queryRequest' ) ) { $ data [ 'queries' ] = $ this -> getQueries ( ) ; } return response ( ) -> json ( $ data , $ http_code ) ; }
5231	public static function valuesOf ( ) { $ enum = new \ ReflectionClass ( get_called_class ( ) ) ; $ values = [ ] ; foreach ( $ enum -> getStaticProperties ( ) as $ name => $ instance ) { $ values [ $ name ] = $ instance -> value ; } return $ values ; }
3461	public function use ( $ middleware ) : void { if ( ! is_subclass_of ( $ middleware , MiddlewareInterface :: class ) ) { if ( ! is_callable ( $ middleware ) ) { throw new ApplicationException ( sprintf ( 'Middleware must be either class or object that implements `%s`' , MiddlewareInterface :: class ) ) ; } $ middleware = new CallableMiddleware ( $ middleware ) ; } $ this -> middleware [ ] = $ middleware ; }
8646	private function getDefaultCurlOptions ( ) { return array ( CURLOPT_POST => true , CURLOPT_USERAGENT => $ this -> config [ 'UserAgent' ] , CURLOPT_VERBOSE => false , CURLOPT_HEADERFUNCTION => array ( $ this , 'headerCallback' ) , CURLOPT_RETURNTRANSFER => true , CURLOPT_SSL_VERIFYPEER => true , CURLOPT_SSL_VERIFYHOST => 2 ) ; }
6562	public static function joinPath ( $ base , $ path ) { if ( substr ( $ path , 0 , 1 ) === '/' ) { return $ path ; } if ( substr ( $ base , 0 , 1 ) !== '/' ) { return false ; } $ pathParts = self :: splitPath ( $ path ) ; $ resultParts = self :: splitPath ( $ base ) ; while ( ( $ part = array_shift ( $ pathParts ) ) !== null ) { switch ( $ part ) { case '.' : break ; case '..' : if ( count ( $ resultParts ) > 1 ) { array_pop ( $ resultParts ) ; } break ; default : $ resultParts [ ] = $ part ; break ; } } return implode ( '/' , $ resultParts ) ; }
47	public function addSubscriber ( EventSubscriberInterface $ subscriber ) { foreach ( $ subscriber -> getSubscribedEvents ( ) as $ eventName => $ params ) { if ( is_string ( $ params ) ) { $ this -> addListener ( $ eventName , array ( $ subscriber , $ params ) ) ; } elseif ( is_string ( $ params [ 0 ] ) ) { $ this -> addListener ( $ eventName , array ( $ subscriber , $ params [ 0 ] ) , isset ( $ params [ 1 ] ) ? $ params [ 1 ] : 0 ) ; } else { foreach ( $ params as $ listener ) { $ this -> addListener ( $ eventName , array ( $ subscriber , $ listener [ 0 ] ) , isset ( $ listener [ 1 ] ) ? $ listener [ 1 ] : 0 ) ; } } } }
245	public function getColumn ( $ name ) { return isset ( $ this -> columns [ $ name ] ) ? $ this -> columns [ $ name ] : null ; }
11525	private function getDom ( $ url ) { $ ch = curl_init ( ) ; $ timeout = 5 ; curl_setopt ( $ ch , CURLOPT_URL , $ url ) ; curl_setopt ( $ ch , CURLOPT_RETURNTRANSFER , 1 ) ; curl_setopt ( $ ch , CURLOPT_CONNECTTIMEOUT , $ timeout ) ; $ dom = curl_exec ( $ ch ) ; curl_close ( $ ch ) ; return $ dom ; }
8225	public function handleRegistration ( Request $ httpRequest ) { if ( ! $ this -> config [ "enabled" ] ) { return ; } $ user = $ this -> picoAuth -> getUser ( ) ; if ( $ user -> getAuthenticated ( ) ) { $ this -> picoAuth -> redirectToPage ( "index" ) ; } $ this -> picoAuth -> addAllowed ( "register" ) ; $ this -> picoAuth -> setRequestFile ( $ this -> picoAuth -> getPluginPath ( ) . '/content/register.md' ) ; $ post = $ httpRequest -> request ; if ( $ post -> has ( "username" ) && $ post -> has ( "email" ) && $ post -> has ( "password" ) && $ post -> has ( "password_repeat" ) ) { if ( ! $ this -> picoAuth -> isValidCSRF ( $ post -> get ( "csrf_token" ) , self :: REGISTER_CSRF_ACTION ) ) { $ this -> picoAuth -> redirectToPage ( "register" ) ; } $ this -> assertLimits ( ) ; $ reg = array ( "username" => strtolower ( trim ( $ post -> get ( "username" ) ) ) , "email" => trim ( $ post -> get ( "email" ) ) , "password" => new Password ( $ post -> get ( "password" ) ) , "passwordRepeat" => new Password ( $ post -> get ( "password_repeat" ) ) , ) ; $ isValid = $ this -> validateRegistration ( $ reg ) ; if ( $ isValid ) { if ( ! $ this -> limit -> action ( "registration" ) ) { $ this -> session -> addFlash ( "error" , $ this -> limit -> getError ( ) ) ; $ this -> picoAuth -> redirectToPage ( "register" ) ; } $ this -> logSuccessfulRegistration ( $ reg ) ; $ userData = array ( 'email' => $ reg [ "email" ] ) ; $ localAuth = $ this -> picoAuth -> getContainer ( ) -> get ( 'LocalAuth' ) ; $ localAuth -> userDataEncodePassword ( $ userData , $ reg [ "password" ] ) ; $ this -> storage -> saveUser ( $ reg [ "username" ] , $ userData ) ; $ this -> session -> addFlash ( "success" , "Registration completed successfully, you can now log in." ) ; $ this -> picoAuth -> redirectToLogin ( ) ; } else { $ this -> session -> addFlash ( "old" , array ( 'username' => $ reg [ "username" ] , 'email' => $ reg [ "email" ] ) ) ; $ this -> picoAuth -> redirectToPage ( "register" ) ; } } }
10004	static function getStringFromHTTPStatusCode ( $ httpStatusCode ) { if ( array_key_exists ( $ httpStatusCode , HTTPResponseCodes :: $ codes ) === true ) { return HTTPResponseCodes :: $ codes [ $ httpStatusCode ] ; } else { return "unknown error code: " . $ httpStatusCode ; } }
9218	protected function pageNumberToKey ( $ pageNumber ) { if ( isset ( $ this -> pagination [ CanvasPageLink :: CURRENT ] ) ) { return ( $ pageNumber - 1 ) * $ this -> pagination [ CanvasPageLink :: CURRENT ] -> getPerPage ( ) ; } return false ; }
12716	protected function getConcreteFromInterface ( $ interface ) { if ( ! $ this -> isAbstractExists ( $ interface ) ) { throw Internal \ Exception \ ReflectionExceptionFactory :: runtime ( sprintf ( "%s has no concrete implementation in the class binding stack." , $ interface ) ) ; } try { return $ this -> getResolvedSingleton ( $ interface ) ; } catch ( \ Exception $ e ) { } $ concrete = $ this -> bindings [ $ interface ] [ 'concrete' ] ; $ object = $ concrete instanceof \ Closure ? $ concrete ( $ this ) : $ this -> build ( $ concrete ) ; if ( $ this -> isShared ( $ interface ) ) { $ this -> markAsResolved ( $ interface , $ object , 'singleton' ) ; } else { $ this -> markAsResolved ( $ interface , $ object ) ; } return $ object ; }
12376	public function equals ( ) { foreach ( $ this -> comparisonList as $ valuePair ) { $ a = $ valuePair [ 0 ] ; $ b = $ valuePair [ 1 ] ; $ callback = $ valuePair [ 2 ] ; if ( ! is_null ( $ callback ) ) { if ( ! is_callable ( $ callback ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Provided callback of type %s is not callable!' , is_object ( $ callback ) ? get_class ( $ callback ) : gettype ( $ callback ) ) ) ; } if ( is_array ( $ a ) && is_array ( $ b ) && $ this -> isList ( $ a ) && $ this -> isList ( $ b ) ) { $ result = $ this -> compareListsWithCallback ( $ a , $ b , $ callback ) ; } else { $ result = call_user_func ( $ callback , $ a , $ b ) ; } if ( ! is_bool ( $ result ) ) { throw new \ RuntimeException ( sprintf ( 'Provided callback of type %s does not return a boolean value!' , is_object ( $ callback ) ? get_class ( $ callback ) : gettype ( $ callback ) ) ) ; } return $ result ; } if ( ! ( ( $ this -> strict ) ? $ a === $ b : $ a == $ b ) ) { return false ; } } return true ; }
9938	private static function checkSheetTitle ( $ pValue ) { if ( str_replace ( self :: $ invalidCharacters , '' , $ pValue ) !== $ pValue ) { throw new Exception ( 'Invalid character found in sheet title' ) ; } if ( Shared \ StringHelper :: countCharacters ( $ pValue ) > 31 ) { throw new Exception ( 'Maximum 31 characters allowed in sheet title.' ) ; } return $ pValue ; }
5984	public function updateCredentials ( $ user , $ password ) { $ oldUser = $ this -> credentials -> getUsername ( ) ; $ this -> credentials = new Credentials ( $ this -> credentials -> getClientId ( ) , $ user , $ password ) ; unset ( $ password ) ; if ( $ this -> client instanceof Client ) { $ this -> client = $ this -> oauth2Middleware = null ; $ this -> client = $ this -> getClient ( ) ; } if ( $ this -> cache instanceof CacheProvider ) { $ this -> cache -> setNamespace ( md5 ( $ this -> basepath . $ this -> credentials -> getUsername ( ) . $ this -> credentials -> getPassword ( ) ) ) ; } $ this -> logger -> notice ( 'Updated user!' , [ 'old' => $ oldUser , 'new' => $ user ] ) ; }
3871	protected function getLanguage ( $ singleLanguage , $ metaModels ) { if ( ! empty ( $ singleLanguage ) ) { return array ( $ singleLanguage ) ; } elseif ( $ metaModels -> isTranslated ( ) && $ metaModels -> getAvailableLanguages ( ) ) { return $ metaModels -> getAvailableLanguages ( ) ; } return array ( $ GLOBALS [ 'TL_LANGUAGE' ] ) ; }
89	public function write ( array $ hash , $ options = 448 ) { $ dir = dirname ( $ this -> path ) ; if ( ! is_dir ( $ dir ) ) { if ( file_exists ( $ dir ) ) { throw new \ UnexpectedValueException ( $ dir . ' exists and is not a directory.' ) ; } if ( ! @ mkdir ( $ dir , 0777 , true ) ) { throw new \ UnexpectedValueException ( $ dir . ' does not exist and could not be created.' ) ; } } $ retries = 3 ; while ( $ retries -- ) { try { file_put_contents ( $ this -> path , static :: encode ( $ hash , $ options ) . ( $ options & self :: JSON_PRETTY_PRINT ? "\n" : '' ) ) ; break ; } catch ( \ Exception $ e ) { if ( $ retries ) { usleep ( 500000 ) ; continue ; } throw $ e ; } } }
11632	private function groupPvTrans ( $ transData ) { $ result = [ ] ; foreach ( $ transData as $ one ) { $ debitAccId = $ one -> get ( DTrans :: A_ACC_ID_DEBIT ) ; $ creditAccId = $ one -> get ( DTrans :: A_ACC_ID_CREDIT ) ; $ value = $ one -> get ( DTrans :: A_AMOUNT ) ; if ( isset ( $ result [ $ debitAccId ] ) ) { $ result [ $ debitAccId ] -= $ value ; } else { $ result [ $ debitAccId ] = - $ value ; } if ( isset ( $ result [ $ creditAccId ] ) ) { $ result [ $ creditAccId ] += $ value ; } else { $ result [ $ creditAccId ] = $ value ; } } return $ result ; }
8758	public function tick ( $ status = Tick :: SUCCESS , $ msg = null , array $ extraInfo = [ ] , $ incrementBy = 1 ) { if ( ! $ this -> isRunning ( ) ) { $ this -> start ( ) ; } $ tick = new Tick ( $ this , $ status , $ msg , $ extraInfo , $ incrementBy ) ; if ( array_key_exists ( $ tick -> getStatus ( ) , $ this -> numProcessedItems ) ) { $ this -> numProcessedItems [ $ tick -> getStatus ( ) ] += $ tick -> getIncrementBy ( ) ; } else { $ this -> numProcessedItems [ $ tick -> getStatus ( ) ] = $ tick -> getIncrementBy ( ) ; } $ this -> dispatcher -> dispatch ( Events :: TRACKER_TICK , $ tick ) ; $ this -> lastTick = $ tick ; return $ tick -> getReport ( ) ; }
12192	protected function doSave ( $ id , $ data , $ lifeTime = 0 ) { return $ this -> delegate -> doSave ( $ id , $ data , $ lifeTime ) ; }
12217	private function register ( ) { ini_set ( 'display_errors' , false ) ; if ( $ this -> displayErrors ) { ini_set ( 'display_errors' , true ) ; } register_shutdown_function ( [ $ this , 'shutdownHandler' ] ) ; set_error_handler ( [ $ this , 'errorHandler' ] ) ; set_exception_handler ( [ $ this , 'exceptionHandler' ] ) ; }
3551	public function parse ( InlineParserContext $ inlineContext ) { $ cursor = $ inlineContext -> getCursor ( ) ; $ previous = $ cursor -> peek ( - 1 ) ; if ( $ previous !== null && $ previous !== ' ' ) { return false ; } $ saved = $ cursor -> saveState ( ) ; $ cursor -> advance ( ) ; $ handle = $ cursor -> match ( '/^[a-z0-9\+\-_]+:/' ) ; if ( ! $ handle ) { $ cursor -> restoreState ( $ saved ) ; return false ; } $ next = $ cursor -> peek ( 0 ) ; if ( $ next !== null && $ next !== ' ' ) { $ cursor -> restoreState ( $ saved ) ; return false ; } $ key = substr ( $ handle , 0 , - 1 ) ; if ( $ this -> map === null ) { $ this -> map = $ this -> repo -> get ( ) ; } if ( ! array_key_exists ( $ key , $ this -> map ) ) { $ cursor -> restoreState ( $ saved ) ; return false ; } $ inline = new Image ( $ this -> map [ $ key ] , $ key ) ; $ inline -> data [ 'attributes' ] = [ 'class' => 'emoji' , 'data-emoji' => $ key ] ; $ inlineContext -> getContainer ( ) -> appendChild ( $ inline ) ; return true ; }
6342	final public static function valueOf ( $ name ) : self { $ className = static :: class ; Preconditions :: checkArgument ( array_key_exists ( $ className , self :: $ cache ) && array_key_exists ( $ name , self :: $ cache [ $ className ] ) , "The enum '%s' type has no constant with name '%s'" , $ className , $ name ) ; return self :: $ cache [ $ className ] [ $ name ] ; }
1126	public function isSelfOrDescendantOf ( $ other ) { return ( $ this -> getLeft ( ) >= $ other -> getLeft ( ) && $ this -> getLeft ( ) < $ other -> getRight ( ) && $ this -> inSameScope ( $ other ) ) ; }
6685	public function sendFailResponse ( $ data , $ httpStatusCode = 500 ) { \ Yii :: $ app -> response -> format = Response :: FORMAT_JSON ; \ Yii :: $ app -> response -> setStatusCode ( $ httpStatusCode , $ this -> httpStatuses -> getReasonPhrase ( $ httpStatusCode ) ) ; return [ 'status' => 'fail' , 'data' => $ data ] ; }
3651	protected function callParseTemplateHook ( ) { if ( isset ( $ GLOBALS [ 'METAMODEL_HOOKS' ] [ 'parseTemplate' ] ) && is_array ( $ GLOBALS [ 'METAMODEL_HOOKS' ] [ 'parseTemplate' ] ) ) { foreach ( $ GLOBALS [ 'METAMODEL_HOOKS' ] [ 'parseTemplate' ] as $ callback ) { list ( $ strClass , $ strMethod ) = $ callback ; $ objCallback = ( in_array ( 'getInstance' , get_class_methods ( $ strClass ) ) ) ? call_user_func ( array ( $ strClass , 'getInstance' ) ) : new $ strClass ( ) ; $ objCallback -> $ strMethod ( $ this ) ; } } }
2956	public function deviceClose ( ) { if ( $ this -> _dState !== SERIAL_DEVICE_OPENED ) { return true ; } if ( fclose ( $ this -> _dHandle ) ) { $ this -> _dHandle = null ; $ this -> _dState = SERIAL_DEVICE_SET ; return true ; } trigger_error ( "Unable to close the device" , E_USER_ERROR ) ; return false ; }
12494	public static function find ( $ id = null , $ connection ) { if ( gettype ( $ id ) != "string" && ! is_numeric ( $ id ) ) { throw new ClusterpointException ( "\"->find()\" function: \"_id\" is not in valid format." , 9002 ) ; } $ connection -> method = 'GET' ; $ connection -> action = '[' . urlencode ( $ id ) . ']' ; $ connection -> multiple = false ; return self :: sendQuery ( $ connection ) ; }
3969	protected function deleteConditionSettings ( PreDeleteModelEvent $ event ) { $ environment = $ event -> getEnvironment ( ) ; $ model = $ event -> getModel ( ) ; $ dataProvider = $ environment -> getDataProvider ( 'tl_metamodel_dcasetting_condition' ) ; $ conditions = $ dataProvider -> fetchAll ( $ dataProvider -> getEmptyConfig ( ) -> setFilter ( [ [ 'operation' => '=' , 'property' => 'attr_id' , 'value' => $ model -> getId ( ) ] ] ) ) ; if ( $ conditions -> count ( ) < 1 ) { return ; } $ conditionsGeneral = new \ DC_General ( $ dataProvider -> getEmptyModel ( ) -> getProviderName ( ) ) ; $ conditionsEnvironment = $ conditionsGeneral -> getEnvironment ( ) ; $ conditionsDataDefinition = $ conditionsEnvironment -> getDataDefinition ( ) ; $ conditionsPalettesDefinition = $ conditionsDataDefinition -> getPalettesDefinition ( ) ; $ conditionsIterator = $ conditions -> getIterator ( ) ; while ( $ currentCondition = $ conditionsIterator -> current ( ) ) { $ conditionPalette = $ conditionsPalettesDefinition -> getPaletteByName ( $ currentCondition -> getProperty ( 'type' ) ) ; $ conditionProperties = $ conditionPalette -> getVisibleProperties ( $ currentCondition ) ; foreach ( $ conditionProperties as $ conditionProperty ) { if ( $ conditionProperty -> getName ( ) !== 'attr_id' ) { continue ; } $ dataProvider -> delete ( $ currentCondition ) ; } $ conditionsIterator -> next ( ) ; } }
11392	public static function getInstance ( ) : Debug { if ( ! ( self :: $ _oInstance instanceof self ) ) { self :: $ _oInstance = new self ( ) ; } return self :: $ _oInstance ; }
5668	public function describeDifference ( $ first , $ second , $ identical = false ) { if ( $ identical ) { if ( ! $ this -> isTypeMatch ( $ first , $ second ) ) { return sprintf ( 'with type mismatch as [%s] does not match [%s]' , $ this -> describeValue ( $ first ) , $ this -> describeValue ( $ second ) ) ; } } $ type = $ this -> getType ( $ first ) ; if ( $ type === 'Unknown' ) { return 'with unknown type' ; } $ method = 'describe' . $ type . 'Difference' ; return $ this -> $ method ( $ first , $ second , $ identical ) ; }
5663	private function dequote ( $ quoted ) { if ( preg_match ( '/^(\'([^\']*)\'|"([^"]*)")$/' , $ quoted , $ matches ) ) { return isset ( $ matches [ 3 ] ) ? $ matches [ 3 ] : $ matches [ 2 ] ; } return $ quoted ; }
11150	protected function setCacheState ( $ useCache ) { if ( is_bool ( $ useCache ) ) { $ this -> useCache = $ useCache ; } else { $ this -> useCache = true ; } }
3492	public function withHeaders ( array $ headers ) : Request { $ cloned = clone $ this ; foreach ( $ headers as $ name => $ value ) { $ cloned = $ cloned -> withHeader ( $ name , $ value ) ; } return $ cloned ; }
6220	public function authorize ( $ appId , $ appKey = null , $ credentials_or_service_id , $ usage = null ) { $ url = $ this -> getHost ( ) . "/transactions/authorize.xml" ; $ params = array ( 'app_id' => $ appId ) ; if ( $ credentials_or_service_id instanceof ThreeScaleClientCredentials ) { $ params [ 'service_token' ] = $ credentials_or_service_id -> service_token ; $ params [ 'service_id' ] = $ credentials_or_service_id -> service_id ; } else { $ params [ 'provider_key' ] = $ this -> getProviderKey ( ) ; $ params [ 'service_id' ] = $ credentials_or_service_id ; } if ( $ appKey ) { $ params [ 'app_key' ] = $ appKey ; } if ( $ usage ) { $ params [ 'usage' ] = $ usage ; } $ httpResponse = $ this -> httpClient -> get ( $ url , $ params ) ; if ( self :: isHttpSuccess ( $ httpResponse ) ) { return $ this -> buildAuthorizeResponse ( $ httpResponse -> body ) ; } else { return $ this -> processError ( $ httpResponse ) ; } }
11051	function build_all ( $ datatree , $ entry ) { if ( ! isset ( $ this -> masktree [ $ entry ] ) ) { $ this -> error ( 8 , 57 , $ entry ) ; } $ this -> datatree = $ datatree ; if ( is_array ( $ this -> datatree ) ) { $ this -> datatree [ '_parent' ] = NULL ; } elseif ( is_object ( $ this -> datatree ) ) { $ this -> datatree -> _parent = NULL ; } elseif ( isset ( $ this -> datatree ) ) { $ this -> error ( 9 , 58 ) ; $ this -> datatree = NULL ; } $ built = $ this -> build_mask ( $ this -> datatree , $ this -> masktree [ $ entry ] ) ; if ( ! isset ( $ this -> masktree [ '0reduce' ] ) ) { $ this -> masktree [ '0reduce' ] = _ETS_REDUCE_OFF ; } switch ( $ this -> masktree [ '0reduce' ] ) { case _ETS_REDUCE_OFF : break ; case _ETS_REDUCE_SPACES : $ built = preg_replace ( '/(\r\n|\r|\n)+/sm' , "\n" , preg_replace ( '/[ \t]*?(\r\n|\r|\n)+[\t ]*/sm' , "\n" , $ built ) ) ; break ; case _ETS_REDUCE_ALL : $ built = preg_replace ( '/[ \t]*?(\r\n|\r|\n)+[\t ]*/sm' , '' , $ built ) ; break ; } $ built = str_replace ( "\1n\1" , "\n" , $ built ) ; $ built = str_replace ( "\1r\1" , "\r" , $ built ) ; $ built = str_replace ( "\1t\1" , "\t" , $ built ) ; $ built = str_replace ( "\1s\1" , " " , $ built ) ; return $ built ; }
2845	public function getRequestPath ( ) { $ requestPath = '' ; $ server = $ this -> getGlobalServer ( ) ; if ( array_key_exists ( 'REQUEST_URI' , $ server ) ) { $ requestPath = parse_url ( $ server [ 'REQUEST_URI' ] , PHP_URL_PATH ) ; } return $ requestPath ; }
559	protected function buildAttributeCondition ( $ attribute , $ condition ) { if ( is_array ( $ condition ) ) { $ parts = [ ] ; foreach ( $ condition as $ operator => $ value ) { if ( isset ( $ this -> operatorTypes [ $ operator ] ) ) { if ( isset ( $ this -> conditionBuilders [ $ operator ] ) ) { $ method = $ this -> conditionBuilders [ $ operator ] ; if ( is_string ( $ method ) ) { $ callback = [ $ this , $ method ] ; } else { $ callback = $ method ; } $ parts [ ] = $ callback ( $ operator , $ value , $ attribute ) ; } else { $ parts [ ] = $ this -> buildOperatorCondition ( $ operator , $ value , $ attribute ) ; } } } if ( ! empty ( $ parts ) ) { if ( count ( $ parts ) > 1 ) { return array_merge ( [ 'AND' ] , $ parts ) ; } return array_shift ( $ parts ) ; } } return [ $ attribute => $ this -> filterAttributeValue ( $ attribute , $ condition ) ] ; }
9936	public function setGrouping ( $ pGrouping ) { if ( ( $ pGrouping !== null ) && ( ! in_array ( $ pGrouping , self :: $ dateTimeGroups ) ) && ( ! in_array ( $ pGrouping , self :: $ dynamicTypes ) ) && ( ! in_array ( $ pGrouping , self :: $ topTenType ) ) ) { throw new PhpSpreadsheetException ( 'Invalid rule type for column AutoFilter Rule.' ) ; } $ this -> grouping = $ pGrouping ; return $ this ; }
5251	public function delete ( ) { if ( $ this -> deleting ( ) === false ) { return false ; } $ this -> _dal -> delete ( ) ; $ this -> _exist = false ; $ cache = self :: cache ( ) ; $ cache -> forget ( $ this -> getId ( ) ) ; if ( $ this -> deleted ( ) === false ) { return false ; } return true ; }
11382	public function pipe ( $ stage ) { $ pipeline = new self ( $ this -> container , $ this -> stages ) ; $ this -> handleStage ( $ pipeline -> stages , $ stage ) ; return $ pipeline ; }
752	public function addRateLimitHeaders ( $ response , $ limit , $ remaining , $ reset ) { if ( $ this -> enableRateLimitHeaders ) { $ response -> getHeaders ( ) -> set ( 'X-Rate-Limit-Limit' , $ limit ) -> set ( 'X-Rate-Limit-Remaining' , $ remaining ) -> set ( 'X-Rate-Limit-Reset' , $ reset ) ; } }
10742	public function get ( $ keys , $ default = null ) { $ result = $ this -> data ; foreach ( is_array ( $ keys ) ? $ keys : [ $ keys ] as $ key ) { if ( is_array ( $ result ) && isset ( $ result [ $ key ] ) ) { $ result = $ result [ $ key ] ; } else { $ result = $ default ; break ; } } return $ result ; }
12426	public function getAuthorizerInfo ( $ authorizerAppId ) { $ params = [ 'component_appid' => $ this -> getAppId ( ) , 'authorizer_appid' => $ authorizerAppId , ] ; return $ this -> parseJSON ( 'json' , [ self :: GET_AUTHORIZER_INFO , $ params ] ) ; }
10414	public function createTable ( $ connection = null ) { $ connection = $ connection ? : $ this -> connection ; $ schemaManager = $ connection -> getSchemaManager ( ) ; if ( $ schemaManager -> tablesExist ( [ $ this -> tableName ] ) ) { return null ; } $ table = new Table ( $ this -> tableName ) ; $ this -> buildTable ( $ table ) ; $ schemaManager -> createTable ( $ table ) ; return true ; }
11795	public function setAttachment ( $ file = '' , $ clear = false ) { if ( true === $ clear ) { $ this -> clear ( 'text' ) ; } if ( is_array ( $ file ) ) { foreach ( $ file as $ _f ) { if ( file_exists ( $ _f ) ) { $ this -> attachment [ ] = $ _f ; } } } else { if ( file_exists ( $ file ) ) { $ this -> attachment [ ] = $ file ; } } return $ this ; }
10907	public static function get ( array $ server ) : array { $ params = [ ] ; if ( isset ( $ server [ 'QUERY_STRING' ] ) ) { $ query = ltrim ( $ server [ 'QUERY_STRING' ] , '?' ) ; foreach ( explode ( '&' , $ query ) as $ pair ) { if ( $ pair ) { list ( $ name , $ value ) = self :: normalize ( array_map ( 'urldecode' , explode ( '=' , $ pair , 2 ) ) ) ; $ params [ $ name ] [ ] = $ value ; } } } return $ params ? array_map ( function ( $ v ) { return count ( $ v ) === 1 ? $ v [ 0 ] : $ v ; } , $ params ) : $ params ; }
10226	public function noAssociationsMenuFor ( $ model , ModelConfig $ config = null ) { $ modelName = $ this -> resolveModelName ( $ model ) ; $ menuFactory = $ this -> app -> make ( 'Label305\AujaLaravel\Factory\NoAssociationsIndexMenuFactory' ) ; return $ menuFactory -> create ( $ modelName , $ config ) ; }
1839	protected static function find ( array $ arrOptions ) { if ( static :: $ strTable == '' ) { return null ; } if ( $ arrOptions [ 'return' ] == 'Model' ) { $ arrColumn = ( array ) $ arrOptions [ 'column' ] ; if ( \ count ( $ arrColumn ) == 1 ) { $ arrColumn [ 0 ] = preg_replace ( '/^' . preg_quote ( static :: getTable ( ) , '/' ) . '\./' , '' , $ arrColumn [ 0 ] ) ; if ( $ arrColumn [ 0 ] == static :: $ strPk || \ in_array ( $ arrColumn [ 0 ] , static :: getUniqueFields ( ) ) ) { $ varKey = \ is_array ( $ arrOptions [ 'value' ] ) ? $ arrOptions [ 'value' ] [ 0 ] : $ arrOptions [ 'value' ] ; $ objModel = Registry :: getInstance ( ) -> fetch ( static :: $ strTable , $ varKey , $ arrColumn [ 0 ] ) ; if ( $ objModel !== null ) { return $ objModel ; } } } } $ arrOptions [ 'table' ] = static :: $ strTable ; $ strQuery = static :: buildFindQuery ( $ arrOptions ) ; $ objStatement = Database :: getInstance ( ) -> prepare ( $ strQuery ) ; if ( ! isset ( $ arrOptions [ 'limit' ] ) ) { $ arrOptions [ 'limit' ] = 0 ; } if ( ! isset ( $ arrOptions [ 'offset' ] ) ) { $ arrOptions [ 'offset' ] = 0 ; } if ( $ arrOptions [ 'limit' ] > 0 || $ arrOptions [ 'offset' ] > 0 ) { $ objStatement -> limit ( $ arrOptions [ 'limit' ] , $ arrOptions [ 'offset' ] ) ; } $ objStatement = static :: preFind ( $ objStatement ) ; $ objResult = $ objStatement -> execute ( $ arrOptions [ 'value' ] ) ; if ( $ objResult -> numRows < 1 ) { return $ arrOptions [ 'return' ] == 'Array' ? array ( ) : null ; } $ objResult = static :: postFind ( $ objResult ) ; if ( $ arrOptions [ 'return' ] == 'Model' ) { $ objModel = Registry :: getInstance ( ) -> fetch ( static :: $ strTable , $ objResult -> { static :: $ strPk } ) ; if ( $ objModel !== null ) { return $ objModel -> mergeRow ( $ objResult -> row ( ) ) ; } return static :: createModelFromDbResult ( $ objResult ) ; } elseif ( $ arrOptions [ 'return' ] == 'Array' ) { return static :: createCollectionFromDbResult ( $ objResult , static :: $ strTable ) -> getModels ( ) ; } else { return static :: createCollectionFromDbResult ( $ objResult , static :: $ strTable ) ; } }
733	public function toArray ( array $ fields = [ ] , array $ expand = [ ] , $ recursive = true ) { $ data = [ ] ; foreach ( $ this -> resolveFields ( $ fields , $ expand ) as $ field => $ definition ) { $ attribute = is_string ( $ definition ) ? $ this -> $ definition : $ definition ( $ this , $ field ) ; if ( $ recursive ) { $ nestedFields = $ this -> extractFieldsFor ( $ fields , $ field ) ; $ nestedExpand = $ this -> extractFieldsFor ( $ expand , $ field ) ; if ( $ attribute instanceof Arrayable ) { $ attribute = $ attribute -> toArray ( $ nestedFields , $ nestedExpand ) ; } elseif ( is_array ( $ attribute ) ) { $ attribute = array_map ( function ( $ item ) use ( $ nestedFields , $ nestedExpand ) { if ( $ item instanceof Arrayable ) { return $ item -> toArray ( $ nestedFields , $ nestedExpand ) ; } return $ item ; } , $ attribute ) ; } } $ data [ $ field ] = $ attribute ; } if ( $ this instanceof Linkable ) { $ data [ '_links' ] = Link :: serialize ( $ this -> getLinks ( ) ) ; } return $ recursive ? ArrayHelper :: toArray ( $ data ) : $ data ; }
12721	public function isShared ( $ abstract ) { if ( ! isset ( $ this -> bindings [ $ abstract ] ) ) { throw Internal \ Exception \ ReflectionExceptionFactory :: invalidArgument ( sprintf ( "Parameter 1 of %s must be valid keys in binding container stack." , __METHOD__ ) ) ; } return ( $ this -> bindings [ $ abstract ] [ 'shared' ] ? true : false ) ; }
8868	public function notify ( PayloadInterface $ payload ) { foreach ( $ this -> runners as $ runner ) { $ runner -> run ( $ payload ) ; } return $ this ; }
6742	public function apply ( Request $ request , ParamConverter $ configuration ) { $ param = $ this -> getRequestAttributeName ( $ request , $ configuration ) ; if ( ! $ request -> attributes -> has ( $ param ) ) { return false ; } $ value = $ request -> attributes -> get ( $ param ) ; if ( ! $ value && $ configuration -> isOptional ( ) ) { return false ; } $ convertedValue = $ this -> convertValue ( $ value , $ configuration ) ; if ( null === $ convertedValue && false === $ configuration -> isOptional ( ) ) { throw new NotFoundHttpException ( "Unable to find '{$configuration->getClass()}' with identifier '{$value}' not found" ) ; } $ request -> attributes -> set ( $ configuration -> getName ( ) , $ convertedValue ) ; return true ; }
2714	public function getCheckedValues ( ) { if ( $ this -> values === null ) { $ data = $ this -> config -> getImageOptimizationRatios ( ) ; if ( ! isset ( $ data ) ) { $ data = '' ; } $ this -> values = explode ( ',' , $ data ) ; } return $ this -> values ; }
5239	private function paramType ( \ ReflectionMethod $ method , \ ReflectionParameter $ param ) { $ methodAnnotations = annotationsOf ( $ method ) ; $ paramAnnotations = annotationsOf ( $ param ) ; $ paramClass = $ param -> getClass ( ) ; if ( null !== $ paramClass ) { if ( $ methodAnnotations -> contain ( 'Property' ) || $ paramAnnotations -> contain ( 'Property' ) ) { return PropertyBinding :: TYPE ; } return $ paramClass -> getName ( ) ; } if ( $ methodAnnotations -> contain ( 'List' ) || $ paramAnnotations -> contain ( 'List' ) ) { return ListBinding :: TYPE ; } if ( $ methodAnnotations -> contain ( 'Map' ) || $ paramAnnotations -> contain ( 'Map' ) ) { return MapBinding :: TYPE ; } if ( $ methodAnnotations -> contain ( 'Property' ) || $ paramAnnotations -> contain ( 'Property' ) ) { return PropertyBinding :: TYPE ; } return ConstantBinding :: TYPE ; }
4128	protected function loadMetadata ( $ className ) { if ( class_exists ( $ className ) ) { return parent :: loadMetadata ( $ className ) ; } throw MappingException :: classNotFound ( $ className ) ; }
5460	protected function acceptLabelEnd ( ) { if ( isset ( $ this -> label ) ) { if ( isset ( $ this -> last_widget ) ) { $ this -> last_widget -> setLabel ( $ this -> label -> getText ( ) ) ; unset ( $ this -> last_widget ) ; } else { $ this -> left_over_labels [ ] = ( clone $ this -> label ) ; } unset ( $ this -> label ) ; } }
1233	private function ensurePropertyType ( $ value ) { $ actualType = gettype ( $ value ) ; if ( 'object' === $ actualType ) { $ actualType = get_class ( $ value ) ; } $ valid = explode ( '|' , $ this -> expectedType ) ; $ isValid = false ; foreach ( $ valid as $ check ) { if ( $ check !== 'any' && \ DTS \ eBaySDK \ checkPropertyType ( $ check ) ) { if ( $ check === $ actualType ) { return ; } $ isValid = false ; } else { $ isValid = true ; } } if ( ! $ isValid ) { throw new Exceptions \ InvalidPropertyTypeException ( $ this -> property , $ this -> expectedType , $ actualType ) ; } }
11377	public function getAction ( ) { if ( ! preg_match ( '/\/page\/(\w+[\-\w]*)\/text\/(..)(\/(\w+))?$/' , $ this -> name , $ matches ) ) { throw new InvalidParameterException ( "Invalid parameters" ) ; } $ pageName = $ matches [ 1 ] ; $ language = $ matches [ 2 ] ; $ pageTexts = $ this -> getTextModel ( $ pageName ) ; if ( empty ( $ matches [ 4 ] ) ) { $ result = array_values ( $ pageTexts -> getTextsWithBaseTexts ( $ language ) ) ; } else { $ result = $ pageTexts -> getText ( $ matches [ 4 ] , $ language ) ; } $ this -> environment -> sendJSONResult ( $ result ) ; }
9750	public function _savePps ( & $ raList ) { $ iC = count ( $ raList ) ; for ( $ i = 0 ; $ i < $ iC ; ++ $ i ) { fwrite ( $ this -> fileHandle , $ raList [ $ i ] -> _getPpsWk ( ) ) ; } $ iCnt = count ( $ raList ) ; $ iBCnt = $ this -> bigBlockSize / OLE :: OLE_PPS_SIZE ; if ( $ iCnt % $ iBCnt ) { fwrite ( $ this -> fileHandle , str_repeat ( "\x00" , ( $ iBCnt - ( $ iCnt % $ iBCnt ) ) * OLE :: OLE_PPS_SIZE ) ) ; } }
3512	public function getInsertTranslationsElement ( $ translation , $ timeStamp ) { return '(' . self :: dbValue ( $ translation -> status , Translation :: STATUS_SAVED ) . ',' . self :: dbValue ( $ translation -> locale ) . ',' . self :: dbValue ( $ translation -> group ) . ',' . self :: dbValue ( $ translation -> key ) . ',' . self :: dbValue ( $ translation -> value ) . ',' . self :: dbValue ( $ translation -> created_at , $ timeStamp ) . ',' . self :: dbValue ( $ translation -> updated_at , $ timeStamp ) . ',' . self :: dbValue ( $ translation -> source ) . ',' . self :: dbValue ( $ translation -> saved_value ) . ',' . self :: dbValue ( $ translation -> is_deleted , 0 ) . ',' . self :: dbValue ( $ translation -> was_used , 0 ) . ')' ; }
9425	public function f ( ) { if ( is_null ( $ this -> arr_f ) ) { $ arr = $ this -> frequency ( ) ; array_walk ( $ arr , function ( & $ v , $ k , $ n ) { $ v = $ v / $ n ; } , count ( $ this ) ) ; $ this -> arr_f = $ arr ; } return $ this -> arr_f ; }
10708	public function getMany ( $ columns = [ '*' ] , $ paginated = false , $ perPage = null ) { $ results = $ paginated ? $ this -> getManyPaginated ( $ perPage , $ columns ) : $ this -> getQuery ( ) -> get ( $ columns ) ; return $ this -> returnResults ( $ results ) ; }
5831	public function sendRequest ( Request $ request ) { $ this -> prepareRequest ( $ request ) ; $ result = curl_exec ( $ this -> ch ) ; if ( $ result === false ) { throw new \ RuntimeException ( "cURL request failed with error: " . curl_error ( $ this -> ch ) ) ; } $ response = $ this -> createResponseObject ( $ result ) ; curl_close ( $ this -> ch ) ; return $ response ; }
6354	public static function setFakeTime ( $ fakeTime ) { if ( is_string ( $ fakeTime ) ) { $ fakeTime = ( int ) static :: convert ( TS_UNIX , $ fakeTime ) ; } if ( is_int ( $ fakeTime ) ) { $ fakeTime = function ( ) use ( $ fakeTime ) { return $ fakeTime ; } ; } $ old = static :: $ fakeTimeCallback ; static :: $ fakeTimeCallback = $ fakeTime ? $ fakeTime : null ; return $ old ; }
10296	public function writeChart ( \ PhpOffice \ PhpSpreadsheet \ Chart \ Chart $ pChart , $ calculateCellValues = true ) { $ this -> calculateCellValues = $ calculateCellValues ; $ objWriter = null ; if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } if ( $ this -> calculateCellValues ) { $ pChart -> refresh ( ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' , 'yes' ) ; $ objWriter -> startElement ( 'c:chartSpace' ) ; $ objWriter -> writeAttribute ( 'xmlns:c' , 'http://schemas.openxmlformats.org/drawingml/2006/chart' ) ; $ objWriter -> writeAttribute ( 'xmlns:a' , 'http://schemas.openxmlformats.org/drawingml/2006/main' ) ; $ objWriter -> writeAttribute ( 'xmlns:r' , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships' ) ; $ objWriter -> startElement ( 'c:date1904' ) ; $ objWriter -> writeAttribute ( 'val' , 0 ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:lang' ) ; $ objWriter -> writeAttribute ( 'val' , 'en-GB' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:roundedCorners' ) ; $ objWriter -> writeAttribute ( 'val' , 0 ) ; $ objWriter -> endElement ( ) ; $ this -> writeAlternateContent ( $ objWriter ) ; $ objWriter -> startElement ( 'c:chart' ) ; $ this -> writeTitle ( $ objWriter , $ pChart -> getTitle ( ) ) ; $ objWriter -> startElement ( 'c:autoTitleDeleted' ) ; $ objWriter -> writeAttribute ( 'val' , 0 ) ; $ objWriter -> endElement ( ) ; $ this -> writePlotArea ( $ objWriter , $ pChart -> getWorksheet ( ) , $ pChart -> getPlotArea ( ) , $ pChart -> getXAxisLabel ( ) , $ pChart -> getYAxisLabel ( ) , $ pChart -> getChartAxisX ( ) , $ pChart -> getChartAxisY ( ) , $ pChart -> getMajorGridlines ( ) , $ pChart -> getMinorGridlines ( ) ) ; $ this -> writeLegend ( $ objWriter , $ pChart -> getLegend ( ) ) ; $ objWriter -> startElement ( 'c:plotVisOnly' ) ; $ objWriter -> writeAttribute ( 'val' , 1 ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:dispBlanksAs' ) ; $ objWriter -> writeAttribute ( 'val' , 'gap' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:showDLblsOverMax' ) ; $ objWriter -> writeAttribute ( 'val' , 0 ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ this -> writePrintSettings ( $ objWriter ) ; $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
11467	public function init ( array $ viewDirs , array $ params ) { $ this -> viewDirs = $ viewDirs ; $ this -> params = $ params ; $ this -> parts = new ClearViewPartsCollection ( ) ; }
9523	private function getConfig ( ) { $ yaml = new Parser ( ) ; $ configFile = getenv ( 'TRAVIS_BUILD_DIR' ) . '/.travis.yml' ; $ config = $ yaml -> parse ( file_get_contents ( $ configFile ) ) ; $ config = $ config [ 'travisdeployer' ] ; $ this -> branches = $ config [ 'branches' ] ; if ( count ( $ this -> branches ) === 0 ) { die ( 'No branches are configured to deploy to.' . PHP_EOL ) ; } $ this -> verbose = filter_input ( FILTER_VALIDATE_BOOLEAN , $ config [ 'verbose' ] ) ; }
616	public function setDefinitions ( array $ definitions ) { foreach ( $ definitions as $ class => $ definition ) { if ( is_array ( $ definition ) && count ( $ definition ) === 2 && array_values ( $ definition ) === $ definition ) { $ this -> set ( $ class , $ definition [ 0 ] , $ definition [ 1 ] ) ; continue ; } $ this -> set ( $ class , $ definition ) ; } }
7822	protected function refreshPipelines ( ) { $ yaml = $ this -> parser -> dump ( $ this -> pipelines ) ; $ this -> files -> put ( $ this -> getSource ( ) , $ yaml ) ; }
10290	protected function storeLastRun ( ) { if ( ! @ file_put_contents ( $ this -> lockDir . '/lastRun' , time ( ) ) ) { $ this -> logger -> log ( 'Failure storing last run time: ' . ( isset ( $ php_errormsg ) ? $ php_errormsg : 'Unknown error - enable the track_errors ini directive.' ) , Logger :: ERROR ) ; return ; } $ this -> logger -> log ( 'Stored last run time.' , Logger :: INFO ) ; }
4524	protected function createZoneFromDefinition ( array $ definition ) { $ zone = new Zone ( ) ; $ setValues = \ Closure :: bind ( function ( $ definition ) { $ this -> id = $ definition [ 'id' ] ; $ this -> name = $ definition [ 'name' ] ; if ( isset ( $ definition [ 'scope' ] ) ) { $ this -> scope = $ definition [ 'scope' ] ; } if ( isset ( $ definition [ 'priority' ] ) ) { $ this -> priority = $ definition [ 'priority' ] ; } } , $ zone , '\CommerceGuys\Zone\Model\Zone' ) ; $ setValues ( $ definition ) ; foreach ( $ definition [ 'members' ] as $ memberDefinition ) { if ( $ memberDefinition [ 'type' ] == 'country' ) { $ zoneMember = $ this -> createZoneMemberCountryFromDefinition ( $ memberDefinition ) ; $ zone -> addMember ( $ zoneMember ) ; } elseif ( $ memberDefinition [ 'type' ] == 'zone' ) { $ zoneMember = $ this -> createZoneMemberZoneFromDefinition ( $ memberDefinition ) ; $ zone -> addMember ( $ zoneMember ) ; } } return $ zone ; }
12348	protected function getConnectionInitializer ( OptionsInterface $ options , $ callable ) { if ( ! is_callable ( $ callable ) ) { $ class = get_called_class ( ) ; throw new \ InvalidArgumentException ( "$class expects a valid callable" ) ; } $ option = $ this ; return function ( $ parameters = null ) use ( $ callable , $ options , $ option ) { $ connection = call_user_func ( $ callable , $ options , $ parameters ) ; if ( ! $ connection instanceof AggregateConnectionInterface ) { $ class = get_class ( $ option ) ; throw new \ InvalidArgumentException ( "$class expects a valid connection type returned by callable initializer" ) ; } return $ connection ; } ; }
3555	protected function castValue ( ) { $ value = $ this -> attributes [ 'meta_value' ] ; $ validTypes = [ 'boolean' , 'integer' , 'float' , 'double' , 'array' , 'object' , 'null' ] ; if ( in_array ( $ this -> attributes [ 'meta_type' ] , $ validTypes ) ) { settype ( $ value , $ this -> attributes [ 'meta_type' ] ) ; } return $ value ; }
7557	function getChildrenByTag ( $ tag , $ compare = 'total' , $ recursive = true ) { if ( $ this -> childCount ( ) < 1 ) { return array ( ) ; } $ tag = explode ( ' ' , strtolower ( $ tag ) ) ; $ match = ( ( isset ( $ tag [ 1 ] ) && ( $ tag [ 1 ] === 'not' ) ) ? 'false' : 'true' ) ; return $ this -> getChildrenByMatch ( array ( 'tags' => array ( $ tag [ 0 ] => array ( 'match' => $ match , 'compare' => $ compare ) ) ) , $ recursive ) ; }
5794	private function addBooleanColumnFalse ( array $ columnValues ) : array { foreach ( $ this -> getBooleanColumnNames ( ) as $ booleanColumnName ) { if ( ! isset ( $ columnValues [ $ booleanColumnName ] ) ) { $ columnValues [ $ booleanColumnName ] = Postgres :: BOOLEAN_FALSE ; } } return $ columnValues ; }
1838	public static function findBy ( $ strColumn , $ varValue , array $ arrOptions = array ( ) ) { $ blnModel = false ; $ arrColumn = ( array ) $ strColumn ; if ( \ count ( $ arrColumn ) == 1 && ( $ arrColumn [ 0 ] === static :: getPk ( ) || \ in_array ( $ arrColumn [ 0 ] , static :: getUniqueFields ( ) ) ) ) { $ blnModel = true ; } $ arrOptions = array_merge ( array ( 'column' => $ strColumn , 'value' => $ varValue , 'return' => $ blnModel ? 'Model' : 'Collection' ) , $ arrOptions ) ; return static :: find ( $ arrOptions ) ; }
6059	public function retrieveMedia ( $ id , $ includeChildren = false , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'includeChildren' => $ includeChildren ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/media/' . $ id . '' , $ parameters , $ cachePolicy ) ; $ result = new MediaResponse ( $ result ) ; return $ result ; }
4350	private function setCopyValues ( $ values ) { if ( isset ( $ values [ 'debug' ] [ 'emailLog' ] ) && $ values [ 'debug' ] [ 'emailLog' ] === true ) { $ values [ 'debug' ] [ 'emailLog' ] = 'onError' ; } foreach ( array ( 'emailFrom' , 'emailFunc' , 'emailTo' ) as $ key ) { if ( isset ( $ values [ 'debug' ] [ $ key ] ) && ! isset ( $ values [ 'errorEmailer' ] [ $ key ] ) ) { $ values [ 'errorEmailer' ] [ $ key ] = $ values [ 'debug' ] [ $ key ] ; } } return $ values ; }
9811	protected function pureGet ( string $ path , array $ params = [ ] , array $ headers = [ ] ) { if ( $ params ) { $ path .= '?' . http_build_query ( $ params ) ; } return $ this -> client -> get ( $ path , $ headers ) ; }
3142	public function skip ( RunnerServiceContext $ context , $ scope , $ ref ) { return $ this -> move ( $ context , 'skip' , $ scope , $ ref ) ; }
731	protected function getUniqueIndexInformation ( $ table ) { $ sql = <<<'SQL'SELECT i.relname as indexname, pg_get_indexdef(idx.indexrelid, k + 1, TRUE) AS columnnameFROM ( SELECT *, generate_subscripts(indkey, 1) AS k FROM pg_index) idxINNER JOIN pg_class i ON i.oid = idx.indexrelidINNER JOIN pg_class c ON c.oid = idx.indrelidINNER JOIN pg_namespace ns ON c.relnamespace = ns.oidWHERE idx.indisprimary = FALSE AND idx.indisunique = TRUEAND c.relname = :tableName AND ns.nspname = :schemaNameORDER BY i.relname, kSQL ; return $ this -> db -> createCommand ( $ sql , [ ':schemaName' => $ table -> schemaName , ':tableName' => $ table -> name , ] ) -> queryAll ( ) ; }
1922	public static function fromFile ( File $ file ) { $ extension = strtolower ( $ file -> extension ) ; $ function = null ; if ( $ extension === 'jpg' ) { $ extension = 'jpeg' ; } if ( \ in_array ( $ extension , array ( 'gif' , 'jpeg' , 'png' ) ) ) { $ function = 'imagecreatefrom' . $ extension ; } if ( $ function === null || ! \ is_callable ( $ function ) ) { throw new \ InvalidArgumentException ( 'Image type "' . $ file -> extension . '" cannot be processed by GD' ) ; } $ image = $ function ( System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) . '/' . $ file -> path ) ; if ( $ image === false ) { throw new \ RuntimeException ( 'Image "' . $ file -> path . '" failed to be processed by GD' ) ; } return new static ( $ image ) ; }
5731	public function getLeagues ( array $ filter = [ 'areas' => '' ] ) { $ leagues = $ this -> run ( "v2/competitions" . "?" . http_build_query ( $ filter ) ) ; return collect ( $ leagues -> competitions ) ; }
6183	public function add ( $ type , $ message , $ redirect = null ) { if ( ! isset ( $ type ) or ! isset ( $ message [ 0 ] ) ) { return false ; } if ( strlen ( trim ( $ type ) ) === 1 ) { $ type = str_replace ( [ 'h' , 'i' , 'w' , 'e' , 's' ] , [ 'help' , 'info' , 'warning' , 'error' , 'success' ] , $ type ) ; } $ router = new Router ( ) ; try { if ( ! in_array ( $ type , $ this -> msgTypes ) ) { throw new BaseException ( '"' . strip_tags ( $ type ) . '" is not a valid message type!' , 501 ) ; } } catch ( BaseException $ e ) { $ msg = null ; if ( ini_get ( 'display_errors' ) === "on" ) { $ msg .= '<pre>' ; $ msg .= 'Message: <b>' . $ e -> getMessage ( ) . '</b><br><br>' ; $ msg .= 'Accept: ' . $ _SERVER [ 'HTTP_ACCEPT' ] . '<br>' ; if ( isset ( $ _SERVER [ 'HTTP_REFERER' ] ) ) { $ msg .= 'Referer: ' . $ _SERVER [ 'HTTP_REFERER' ] . '<br><br>' ; } $ msg .= 'Request Method: ' . $ _SERVER [ 'REQUEST_METHOD' ] . '<br><br>' ; $ msg .= 'Current file Path: <b>' . $ this -> router -> currentPath ( ) . '</b><br>' ; $ msg .= 'File Exception: ' . $ e -> getFile ( ) . ':' . $ e -> getLine ( ) . '<br><br>' ; $ msg .= 'Trace: <br>' . $ e -> getTraceAsString ( ) . '<br>' ; $ msg .= '</pre>' ; return Response :: create ( $ msg ) -> display ( ) ; } return Response :: create ( $ e -> getMessage ( ) ) -> status ( 501 ) -> display ( ) ; } $ get = $ this -> driver -> get ( 'flash_messages' ) ; $ get [ $ type ] [ ] = $ message ; $ this -> driver -> set ( 'flash_messages' , $ get ) ; if ( ! is_null ( $ redirect ) ) { return $ router -> redirect ( $ redirect , 301 ) ; } return true ; }
5985	public function setTokens ( AccessToken $ accessToken , AccessToken $ refreshToken = null ) { if ( $ accessToken instanceof AccessToken && false === $ accessToken -> isExpired ( ) ) { if ( $ this -> cache instanceof Cache ) { $ this -> cache -> save ( 'oauth2accesstoken' , serialize ( $ accessToken ) , $ accessToken -> getExpires ( ) -> getTimestamp ( ) - ( new \ DateTime ( ) ) -> getTimestamp ( ) ) ; } $ this -> oauth2Middleware -> setAccessToken ( $ accessToken ) ; } if ( $ refreshToken instanceof AccessToken && false === $ accessToken -> isExpired ( ) ) { if ( $ this -> cache instanceof Cache ) { $ this -> cache -> save ( 'oauth2refreshtoken' , serialize ( $ refreshToken ) , $ refreshToken -> getExpires ( ) instanceof \ DateTime ? $ refreshToken -> getExpires ( ) -> getTimestamp ( ) - ( new \ DateTime ( ) ) -> getTimestamp ( ) : 3600 * 24 * 13 ) ; } $ this -> oauth2Middleware -> setRefreshToken ( $ refreshToken ) ; } }
6825	protected function getPaymentAccountNumber ( PaymentMethodInterface $ method , string $ origin ) { foreach ( $ this -> accounts as $ account ) { if ( $ account -> getType ( ) !== AccountingTypes :: TYPE_PAYMENT ) { continue ; } if ( $ account -> getPaymentMethod ( ) !== $ method ) { continue ; } return $ account -> getNumber ( ) ; } throw new LogicException ( sprintf ( "No payment account number configured for payment method '%s' (%s)" , $ method -> getName ( ) , $ origin ) ) ; }
7658	function SmtpClose ( ) { if ( $ this -> smtp != NULL ) { if ( $ this -> smtp -> Connected ( ) ) { $ this -> smtp -> Quit ( ) ; $ this -> smtp -> Close ( ) ; } } }
4424	protected function execute ( InputInterface $ input , OutputInterface $ output ) { if ( ! $ input -> isInteractive ( ) ) { $ output -> writeln ( '<error>This command only supports interactive execution</error>' ) ; return 1 ; } $ this -> writeSection ( 'Installation' ) ; $ legacySiteAccessGenerator = new LegacySiteAccessGenerator ( $ this -> getContainer ( ) , $ this -> questionHelper ) ; $ legacySiteAccessGenerator -> generate ( $ this -> input , $ this -> output ) ; $ configurationGenerator = new ConfigurationGenerator ( $ this -> getContainer ( ) , $ this -> questionHelper ) ; $ configurationGenerator -> generate ( $ this -> input , $ this -> output ) ; $ errors = array ( ) ; $ runner = $ this -> getRunner ( $ errors ) ; $ runner ( $ this -> generateLegacyAutoloads ( ) ) ; $ this -> writeInstallerSummary ( $ errors ) ; return 0 ; }
2638	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ aclId = $ this -> getRequest ( ) -> getParam ( 'acl_id' ) ; $ aclItems = $ this -> api -> aclItemsList ( $ aclId ) ; if ( is_array ( $ aclItems ) && empty ( $ aclItems ) ) { return $ result -> setData ( [ 'status' => 'empty' , 'aclItems' => [ ] ] ) ; } if ( ! $ aclItems ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to fetch acl items.' ] ) ; } return $ result -> setData ( [ 'status' => true , 'aclItems' => $ aclItems ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
12902	private function addVirtualizationWorker ( $ arguments = array ( ) ) { $ this -> builder -> addWorker ( new VirtualizationWorker ( $ this -> registry , $ this -> virtualProperties , $ this -> deserialization , $ arguments ) ) ; }
3706	public function getMetaModelFrontendFilter ( HybridFilterBlock $ objFilterConfig ) { $ this -> objFilterConfig = $ objFilterConfig ; $ this -> formId .= $ this -> objFilterConfig -> id ; return $ this -> getFilters ( ) ; }
8774	public function base ( $ data = null , $ secure = false ) { $ data = ( ! is_null ( $ data ) ) ? $ this -> url . $ data : $ this -> url . '/' ; return $ this -> getUrl ( $ data , $ secure ) ; }
6419	public function start ( ) : Stopwatch { Preconditions :: checkState ( ! $ this -> isRunning , 'This stopwatch is already running.' ) ; $ this -> isRunning = true ; $ this -> startTick = $ this -> ticker -> read ( ) ; return $ this ; }
8060	private function createWorker ( $ i ) { $ sockets = array ( ) ; if ( socket_create_pair ( AF_UNIX , SOCK_STREAM , 0 , $ sockets ) === FALSE ) { throw new \ RuntimeException ( 'socket_create_pair failed.' ) ; return ; } $ processId = pcntl_fork ( ) ; if ( $ processId < 0 ) { throw new \ RuntimeException ( 'pcntl_fork failed.' ) ; return ; } elseif ( $ processId === 0 ) { $ this -> workerProcesses = new ProcessDetailsCollection ( ) ; $ this -> workerPoolSize = 0 ; socket_close ( $ sockets [ 1 ] ) ; $ this -> runWorkerProcess ( $ this -> worker , new SimpleSocket ( $ sockets [ 0 ] ) , $ i ) ; } else { socket_close ( $ sockets [ 0 ] ) ; $ this -> workerProcesses -> addFree ( new ProcessDetails ( $ processId , new SimpleSocket ( $ sockets [ 1 ] ) ) ) ; } }
5197	protected function version ( ) { $ version = explode ( '(' , $ this -> app -> version ( ) ) ; if ( isset ( $ version [ 1 ] ) ) { return substr ( $ version [ 1 ] , 0 , 3 ) ; } return null ; }
11273	public function sendRequest ( RequestInterface $ request ) { $ this -> lastOperation = new Operation ( $ request ) ; $ response = parent :: sendRequest ( $ request ) ; $ this -> lastOperation -> setResponse ( $ response ) ; return $ response ; }
9502	public function runPeridot ( InputInterface $ input , OutputInterface $ output ) { global $ argv ; $ command = $ this -> joinCommand ( $ argv ) ; $ process = new Process ( $ command ) ; $ process -> run ( function ( $ type , $ buffer ) use ( $ output ) { $ buffer = preg_replace ( '/\[([\d]{1,2})m/' , "\033[$1m" , $ buffer ) ; $ output -> write ( $ buffer ) ; } ) ; }
10937	protected function getObfuscatedEmail ( CustomerInterface $ user ) { $ email = $ user -> getEmail ( ) ; if ( false !== $ pos = strpos ( $ email , '@' ) ) { $ email = '...' . substr ( $ email , $ pos ) ; } return $ email ; }
8011	private static function setParityBit ( $ byte ) { $ parity = 1 ; for ( $ i = 1 ; $ i < 8 ; $ i ++ ) { $ parity = ( $ parity + ( ( $ byte >> $ i ) & 1 ) ) % 2 ; } $ byte = $ byte | ( $ parity & 1 ) ; return $ byte ; }
8283	protected function resolveRealUrl ( $ fileName ) { $ fileNameClean = str_replace ( "\0" , '' , $ fileName ) ; $ realPath = realpath ( $ fileNameClean ) ; if ( $ realPath === false ) { return $ this -> requestUrl ; } $ contentPath = realpath ( $ this -> pico -> getConfig ( 'content_dir' ) ) ; $ contentExt = $ this -> pico -> getConfig ( 'content_ext' ) ; if ( strpos ( $ realPath , $ contentPath ) !== 0 ) { throw new \ RuntimeException ( "The plugin cannot be used with " . "symbolic links inside the content directory." ) ; } $ name = substr ( $ realPath , strlen ( $ contentPath ) + 1 , - strlen ( $ contentExt ) ) ; if ( DIRECTORY_SEPARATOR !== '/' ) { $ name = str_replace ( DIRECTORY_SEPARATOR , '/' , $ name ) ; } if ( strlen ( $ name ) >= 5 && 0 === substr_compare ( $ name , "index" , - 5 ) ) { $ name = rtrim ( substr ( $ name , 0 , - 5 ) , '/' ) ; } return $ name ; }
1519	public function addToRelationship ( StoreInterface $ store , UpdateRelationship $ request ) { $ result = $ this -> transaction ( function ( ) use ( $ store , $ request ) { return $ this -> doAddToRelationship ( $ store , $ request ) ; } ) ; if ( $ this -> isResponse ( $ result ) ) { return $ result ; } return $ this -> reply ( ) -> noContent ( ) ; }
5530	protected function chainMockExpectations ( ) { $ code = " function expect(\$method, \$args = false, \$msg = '%s') {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->expect(\$method, \$args, \$msg);\n" ; $ code .= " }\n" ; $ code .= " function expectAt(\$timing, \$method, \$args = false, \$msg = '%s') {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->expectAt(\$timing, \$method, \$args, \$msg);\n" ; $ code .= " }\n" ; $ code .= " function expectCallCount(\$method, \$count) {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->expectCallCount(\$method, \$count, \$msg = '%s');\n" ; $ code .= " }\n" ; $ code .= " function expectMaximumCallCount(\$method, \$count, \$msg = '%s') {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->expectMaximumCallCount(\$method, \$count, \$msg = '%s');\n" ; $ code .= " }\n" ; $ code .= " function expectMinimumCallCount(\$method, \$count, \$msg = '%s') {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->expectMinimumCallCount(\$method, \$count, \$msg = '%s');\n" ; $ code .= " }\n" ; $ code .= " function expectNever(\$method) {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->expectNever(\$method);\n" ; $ code .= " }\n" ; $ code .= " function expectOnce(\$method, \$args = false, \$msg = '%s') {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->expectOnce(\$method, \$args, \$msg);\n" ; $ code .= " }\n" ; $ code .= " function expectAtLeastOnce(\$method, \$args = false, \$msg = '%s') {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->expectAtLeastOnce(\$method, \$args, \$msg);\n" ; $ code .= " }\n" ; return $ code ; }
9095	public function validate ( ) { hypePrototyper ( ) -> prototype -> saveStickyValues ( $ this -> action ) ; $ valid = true ; foreach ( $ this -> fields as $ field ) { if ( ! $ field instanceof Field ) { continue ; } $ validation = $ field -> validate ( $ this -> entity ) ; hypePrototyper ( ) -> prototype -> setFieldValidationStatus ( $ this -> action , $ field -> getShortname ( ) , $ validation ) ; if ( ! $ validation -> isValid ( ) ) { $ valid = false ; } } if ( ! $ valid ) { throw new \ hypeJunction \ Exceptions \ ActionValidationException ( "Invalid input" ) ; } hypePrototyper ( ) -> prototype -> clearStickyValues ( $ this -> action ) ; return true ; }
9146	public function get ( $ key ) { if ( ! isset ( $ this -> sessionContainer [ $ key ] ) ) { return null ; } return $ this -> sessionContainer [ $ key ] ; }
11366	public static function formatText ( $ txt = '' , $ type = 'plain' , $ spaces = false ) { switch ( $ type ) { case 'ascii' : $ _txt = '' ; if ( $ spaces == true ) { $ txt = str_replace ( ' ' , '_' , $ txt ) ; } for ( $ i = 0 ; $ i < strlen ( $ txt ) ; $ i ++ ) { $ _txt .= self :: charAscii ( $ txt [ $ i ] ) ; } $ txt = $ _txt ; break ; default : break ; } $ mailer = Mailer :: getInstance ( ) ; $ limit = $ mailer -> getOption ( 'wordwrap_limit' ) ; $ formated = '' ; foreach ( explode ( "\n" , $ txt ) as $ _line ) { $ _line = trim ( $ _line ) ; if ( strlen ( $ _line ) > $ limit ) { $ _line = wordwrap ( $ _line , $ limit , Mailer :: $ LINE_ENDING ) ; } if ( strlen ( $ _line ) ) { $ formated .= $ _line . Mailer :: $ LINE_ENDING ; } } return $ formated ; }
7578	protected function configureData ( $ data ) { if ( ! empty ( $ this -> _REQUIRED_DATA ) && is_array ( $ data ) ) { $ data = $ this -> configureDefaultData ( $ data ) ; } $ this -> setData ( $ data ) ; }
5628	public function makeAbsolute ( $ base ) { if ( ! is_object ( $ base ) ) { $ base = new self ( $ base ) ; } if ( $ this -> getHost ( ) ) { $ scheme = $ this -> getScheme ( ) ; $ host = $ this -> getHost ( ) ; $ port = $ this -> getPort ( ) ? ':' . $ this -> getPort ( ) : '' ; $ identity = $ this -> getIdentity ( ) ? $ this -> getIdentity ( ) . '@' : '' ; if ( ! $ identity ) { $ identity = $ base -> getIdentity ( ) ? $ base -> getIdentity ( ) . '@' : '' ; } } else { $ scheme = $ base -> getScheme ( ) ; $ host = $ base -> getHost ( ) ; $ port = $ base -> getPort ( ) ? ':' . $ base -> getPort ( ) : '' ; $ identity = $ base -> getIdentity ( ) ? $ base -> getIdentity ( ) . '@' : '' ; } $ path = $ this -> normalisePath ( $ this -> extractAbsolutePath ( $ base ) ) ; $ encoded = $ this -> getEncodedRequest ( ) ; $ fragment = $ this -> getFragment ( ) ? '#' . $ this -> getFragment ( ) : '' ; $ coords = $ this -> getX ( ) === false ? '' : '?' . $ this -> getX ( ) . ',' . $ this -> getY ( ) ; return new self ( "$scheme://$identity$host$port$path$encoded$fragment$coords" ) ; }
10570	protected function parseSort ( string $ sort , array & $ sorts ) { if ( strlen ( trim ( $ sort ) ) === 0 ) { return ; } if ( substr ( $ sort , 0 , 1 ) == "[" ) { $ json = json_decode ( $ sort ) ; if ( is_array ( $ json ) ) { foreach ( $ json as $ s ) { if ( is_object ( $ s ) ) { $ sorts [ $ s -> property ] = strcasecmp ( self :: DESC , $ s -> direction ) !== 0 ; } } return ; } } if ( substr ( $ sort , - 4 ) == ",asc" ) { $ sorts [ substr ( $ sort , 0 , strlen ( $ sort ) - 4 ) ] = true ; } elseif ( substr ( $ sort , - 5 ) == ",desc" ) { $ sorts [ substr ( $ sort , 0 , strlen ( $ sort ) - 5 ) ] = false ; } elseif ( substr ( $ sort , - 10 ) == ":ascending" ) { $ sorts [ substr ( $ sort , 0 , strlen ( $ sort ) - 10 ) ] = true ; } elseif ( substr ( $ sort , - 11 ) == ":descending" ) { $ sorts [ substr ( $ sort , 0 , strlen ( $ sort ) - 11 ) ] = false ; } else { foreach ( explode ( ',' , $ sort ) as $ s ) { if ( substr ( $ s , 0 , 1 ) === '-' ) { $ sorts [ substr ( $ s , 1 ) ] = false ; } elseif ( substr ( $ s , 0 , 1 ) === '+' ) { $ sorts [ substr ( $ s , 1 ) ] = true ; } else { $ sorts [ $ s ] = true ; } } } }
11646	private function generateExecuteDocBlock ( $ methodDescription , $ returnType ) { $ docBlock = new DocBlockGenerator ( $ methodDescription , null ) ; $ tags [ ] = new GenericTag ( 'return' , $ returnType ) ; $ docBlock -> setTags ( $ tags ) ; return $ docBlock ; }
10301	private function writeLayout ( XMLWriter $ objWriter , Layout $ layout = null ) { $ objWriter -> startElement ( 'c:layout' ) ; if ( $ layout !== null ) { $ objWriter -> startElement ( 'c:manualLayout' ) ; $ layoutTarget = $ layout -> getLayoutTarget ( ) ; if ( $ layoutTarget !== null ) { $ objWriter -> startElement ( 'c:layoutTarget' ) ; $ objWriter -> writeAttribute ( 'val' , $ layoutTarget ) ; $ objWriter -> endElement ( ) ; } $ xMode = $ layout -> getXMode ( ) ; if ( $ xMode !== null ) { $ objWriter -> startElement ( 'c:xMode' ) ; $ objWriter -> writeAttribute ( 'val' , $ xMode ) ; $ objWriter -> endElement ( ) ; } $ yMode = $ layout -> getYMode ( ) ; if ( $ yMode !== null ) { $ objWriter -> startElement ( 'c:yMode' ) ; $ objWriter -> writeAttribute ( 'val' , $ yMode ) ; $ objWriter -> endElement ( ) ; } $ x = $ layout -> getXPosition ( ) ; if ( $ x !== null ) { $ objWriter -> startElement ( 'c:x' ) ; $ objWriter -> writeAttribute ( 'val' , $ x ) ; $ objWriter -> endElement ( ) ; } $ y = $ layout -> getYPosition ( ) ; if ( $ y !== null ) { $ objWriter -> startElement ( 'c:y' ) ; $ objWriter -> writeAttribute ( 'val' , $ y ) ; $ objWriter -> endElement ( ) ; } $ w = $ layout -> getWidth ( ) ; if ( $ w !== null ) { $ objWriter -> startElement ( 'c:w' ) ; $ objWriter -> writeAttribute ( 'val' , $ w ) ; $ objWriter -> endElement ( ) ; } $ h = $ layout -> getHeight ( ) ; if ( $ h !== null ) { $ objWriter -> startElement ( 'c:h' ) ; $ objWriter -> writeAttribute ( 'val' , $ h ) ; $ objWriter -> endElement ( ) ; } $ objWriter -> endElement ( ) ; } $ objWriter -> endElement ( ) ; }
8031	public function getProcessDetails ( $ pid ) { if ( $ this -> hasProcess ( $ pid ) === FALSE ) { return NULL ; } return $ this -> processDetails [ $ pid ] ; }
12289	private function make ( string $ block , array $ vars = null ) : string { $ commonVars = static :: COMMON_NAME . static :: VARS_PROPERTY_SUFFIX ; $ blockVars = $ block . static :: VARS_PROPERTY_SUFFIX ; $ allVars = [ ] ; if ( isset ( $ this -> $ commonVars ) && is_array ( $ this -> $ commonVars ) ) { $ allVars = $ this -> $ commonVars ; } if ( isset ( $ this -> $ blockVars ) && is_array ( $ this -> $ blockVars ) ) { $ allVars += $ this -> $ blockVars ; } if ( isset ( $ vars ) ) { $ allVars += $ vars ; } $ file = $ this -> path . $ this -> { $ block . static :: BLOCK_PROPERTY_SUFFIX } . '.' . static :: FILE_EXTENSION ; $ localScope = function ( $ vars , $ file ) { ob_start ( ) ; extract ( $ vars ) ; try { require $ file ; } catch ( \ Exception $ exception ) { ob_end_clean ( ) ; throw $ exception ; } $ _ = isset ( $ _ ) ? str_pad ( '' , $ _ ) : '' ; return str_replace ( PHP_EOL , PHP_EOL . $ _ , PHP_EOL . ob_get_clean ( ) ) ; } ; return $ localScope ( $ allVars , $ file ) ; }
592	public function combineJsFiles ( $ inputFiles , $ outputFile ) { $ content = '' ; foreach ( $ inputFiles as $ file ) { $ fileContent = rtrim ( file_get_contents ( $ file ) ) ; if ( substr ( $ fileContent , - 1 ) !== ';' ) { $ fileContent .= "\n;" ; } $ content .= "/*** BEGIN FILE: $file ***/\n" . $ fileContent . "\n" . "/*** END FILE: $file ***/\n" ; } if ( ! file_put_contents ( $ outputFile , $ content ) ) { throw new Exception ( "Unable to write output JavaScript file '{$outputFile}'." ) ; } }
2792	public function get ( $ option ) { if ( ! array_key_exists ( $ option , $ this -> inputOptions ) ) { throw new \ InvalidArgumentException ( 'Option "' . $ option . ' not exists' ) ; } return $ this -> inputOptions [ $ option ] ; }
6018	public function addMediaToDeploymentSite ( $ id , array $ mediaIds ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'mediaIds' => $ mediaIds ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/deployment/' . $ id . '/media' , $ parameters ) ; return $ result ; }
8565	private function _convertGetEligibleShippingServices ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetEligibleShippingServices' ; if ( $ request -> isSetSellerId ( ) ) { $ parameters [ 'SellerId' ] = $ request -> getSellerId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } if ( $ request -> isSetShipmentRequestDetails ( ) ) { $ ShipmentRequestDetailsGetEligibleShippingServicesRequest = $ request -> getShipmentRequestDetails ( ) ; foreach ( $ ShipmentRequestDetailsGetEligibleShippingServicesRequest -> getAmazonOrderId ( ) as $ AmazonOrderIdShipmentRequestDetailsIndex => $ AmazonOrderIdShipmentRequestDetails ) { $ parameters [ 'ShipmentRequestDetails' . '.' . 'AmazonOrderId' . '.' . ( $ AmazonOrderIdShipmentRequestDetailsIndex + 1 ) ] = $ AmazonOrderIdShipmentRequestDetails ; } } return $ parameters ; }
2738	private function setToken ( $ token ) { $ this -> configWriter -> save ( Config :: XML_FASTLY_API_KEY , $ token ) ; $ this -> output -> writeln ( '<info>Token updated.</info>' , OutputInterface :: OUTPUT_NORMAL ) ; }
776	private function supportsFractionalSeconds ( ) { $ version = $ this -> db -> getSlavePdo ( ) -> getAttribute ( \ PDO :: ATTR_SERVER_VERSION ) ; return version_compare ( $ version , '5.6.4' , '>=' ) ; }
3193	public function load ( ) { if ( ! $ this -> storage ) { throw new InvalidStorageException ( 'A storage must be defined in order to store the data!' ) ; } $ data = $ this -> storage -> load ( ) ; if ( isset ( $ data ) ) { if ( ! is_array ( $ data ) ) { $ data = [ self :: STORAGE_KEY_TIME_LINE => $ data , ] ; } if ( isset ( $ data [ self :: STORAGE_KEY_TIME_LINE ] ) ) { $ this -> timeLine = $ this -> unserializeTimeLine ( $ data [ self :: STORAGE_KEY_TIME_LINE ] ) ; } else { $ this -> timeLine = new QtiTimeLine ( ) ; } if ( isset ( $ data [ self :: STORAGE_KEY_EXTRA_TIME ] ) ) { $ this -> extraTime = $ data [ self :: STORAGE_KEY_EXTRA_TIME ] ; } else { $ this -> extraTime = 0 ; } if ( isset ( $ data [ self :: STORAGE_KEY_EXTENDED_TIME ] ) ) { $ this -> extendedTime = $ data [ self :: STORAGE_KEY_EXTENDED_TIME ] ; } else { $ this -> extendedTime = 0 ; } if ( isset ( $ data [ self :: STORAGE_KEY_CONSUMED_EXTRA_TIME ] ) ) { $ this -> consumedExtraTime = $ data [ self :: STORAGE_KEY_CONSUMED_EXTRA_TIME ] ; } else { $ this -> consumedExtraTime = 0 ; } if ( ! $ this -> timeLine instanceof TimeLine ) { throw new InvalidDataException ( 'The storage did not provide acceptable data when loading!' ) ; } } return $ this ; }
12863	protected function getCachedIdentityService ( Cache $ cache , array $ options ) : CachedIdentityService { if ( ! isset ( $ options [ 'authUrl' ] ) ) { throw new \ InvalidArgumentException ( "'authUrl' is a required option" ) ; } $ stack = HandlerStack :: create ( ) ; if ( ! empty ( $ options [ 'debugLog' ] ) && ! empty ( $ options [ 'logger' ] ) && ! empty ( $ options [ 'messageFormatter' ] ) ) { $ stack -> push ( GuzzleMiddleware :: log ( $ options [ 'logger' ] , $ options [ 'messageFormatter' ] ) ) ; } $ clientOptions = [ 'base_uri' => Utils :: normalizeUrl ( $ options [ 'authUrl' ] ) , 'handler' => $ stack , ] ; if ( isset ( $ options [ 'requestOptions' ] ) ) { $ clientOptions = array_merge ( $ options [ 'requestOptions' ] , $ clientOptions ) ; } $ service = CachedIdentityService :: factory ( new Client ( $ clientOptions ) ) ; $ service -> setCache ( $ cache ) ; return $ service ; }
3688	private function calculateSubfilter ( $ operation , IFilter $ filter ) { if ( ! is_array ( $ operation ) ) { throw new \ RuntimeException ( 'Error Processing subfilter: ' . var_export ( $ operation , true ) , 1 ) ; } switch ( $ operation [ 'operation' ] ) { case 'AND' : case 'OR' : $ this -> getAndOrFilter ( $ filter , $ operation ) ; break ; case '=' : case '>' : case '<' : $ this -> getFilterForComparingOperator ( $ this -> getAttributeFromFilterOperation ( $ operation ) , $ filter , $ operation ) ; break ; case 'IN' : $ this -> getFilterForInList ( $ filter , $ operation ) ; break ; case 'LIKE' : $ this -> getFilterForLike ( $ this -> getAttributeFromFilterOperation ( $ operation ) , $ filter , $ operation ) ; break ; default : throw new \ RuntimeException ( 'Error processing filter array - unknown operation ' . var_export ( $ operation , true ) , 1 ) ; } }
1580	public function withId ( ? string $ id ) : self { $ copy = clone $ this ; $ copy -> id = $ id ? : null ; $ copy -> normalize ( ) ; return $ copy ; }
11649	protected function _authenticateCreateSelect ( ) { $ dbSelect = clone $ this -> getDbSelect ( ) ; $ dbSelect -> from ( $ this -> _tableName ) -> where ( "{$this->_identityColumn} = ?" , $ this -> _identity ) -> limit ( 1 ) ; return $ dbSelect ; }
11191	public function routeProcess ( $ uri = false , $ httpMethod = false ) { if ( ! $ httpMethod ) $ httpMethod = $ _SERVER [ 'REQUEST_METHOD' ] ; $ this -> httpMethod = $ httpMethod ; if ( ! $ uri ) $ uri = $ _SERVER [ 'REQUEST_URI' ] ; $ this -> setPath ( $ uri ) ; $ customPathSearch = $ this -> customFind ( ) ; if ( $ customPathSearch || ( ! $ customPathSearch && $ this -> config [ 'automatic_routing' ] ) ) { $ this -> routeFind ( ) ; } else if ( $ customPathSearch == - 1 ) { $ this -> error ( '403' ) ; } }
4344	protected function pushStack ( $ funcName ) { $ this -> funcStack [ ] = array ( 'function' => $ funcName , 'tsStart' => $ this -> timeLastTick , 'subTime' => 0 , ) ; if ( ! isset ( $ this -> data [ $ funcName ] ) ) { $ this -> data [ $ funcName ] = array ( 'calls' => 0 , 'totalTime' => 0 , 'ownTime' => 0 , ) ; } $ this -> data [ $ funcName ] [ 'calls' ] ++ ; }
10962	private function isInvalidLogDate ( $ file ) { $ pattern = '/laravel-(\d){4}-(\d){2}-(\d){2}.log/' ; if ( ( bool ) preg_match ( $ pattern , $ file , $ matches ) === false ) { return true ; } return false ; }
3571	public function queryHook ( ) { return function ( $ next , $ query , $ bag ) { $ method = $ bag -> get ( 'method' ) ; $ args = $ bag -> get ( 'args' ) ; $ column = $ args -> get ( 'column' ) ; if ( ! $ this -> hasColumn ( $ column ) && $ this -> allowsMeta ( $ column ) && $ this -> isMetaQueryable ( $ method ) ) { return call_user_func_array ( [ $ this , 'metaQuery' ] , [ $ query , $ method , $ args ] ) ; } if ( in_array ( $ method , [ 'select' , 'addSelect' ] ) ) { call_user_func_array ( [ $ this , 'metaSelect' ] , [ $ query , $ args ] ) ; } return $ next ( $ query , $ bag ) ; } ; }
5311	protected function execute ( InputInterface $ input , OutputInterface $ output ) { $ fontFile = realpath ( $ input -> getArgument ( 'font-file' ) ) ; if ( $ fontFile === false || ! file_exists ( $ fontFile ) ) { throw new \ InvalidArgumentException ( '"' . $ input -> getArgument ( 'font-file' ) . '" does not exist' ) ; } $ outputFile = $ input -> getArgument ( 'output-file' ) ; $ generator = new IconFontGenerator ; $ output -> writeln ( 'reading font file from "' . $ fontFile . '" ...' ) ; $ generator -> generateFromFont ( new Font ( array ( ) , file_get_contents ( $ fontFile ) ) ) ; $ output -> writeln ( 'writing HTML file to "' . $ outputFile . '" ...' ) ; if ( $ input -> getOption ( 'as-list' ) ) { $ html = $ this -> getHTMLListFromGenerator ( $ generator , basename ( $ fontFile ) ) ; } else { $ html = $ this -> getHTMLFromGenerator ( $ generator , basename ( $ fontFile ) ) ; } file_put_contents ( $ outputFile , $ html ) ; $ output -> getFormatter ( ) -> setStyle ( 'success' , new OutputFormatterStyle ( null , null , array ( 'bold' , 'reverse' ) ) ) ; $ output -> writeln ( '<success>created HTML info page successfully</success>' ) ; }
2206	public function generate ( ) { if ( TL_MODE == 'BE' ) { $ objTemplate = new BackendTemplate ( 'be_wildcard' ) ; $ objTemplate -> wildcard = '### ' . Utf8 :: strtoupper ( $ GLOBALS [ 'TL_LANG' ] [ 'FMD' ] [ 'logout' ] [ 0 ] ) . ' ###' ; $ objTemplate -> title = $ this -> headline ; $ objTemplate -> id = $ this -> id ; $ objTemplate -> link = $ this -> name ; $ objTemplate -> href = 'contao/main.php?do=themes&amp;table=tl_module&amp;act=edit&amp;id=' . $ this -> id ; return $ objTemplate -> parse ( ) ; } if ( $ this -> redirectBack ) { $ _SESSION [ 'LAST_PAGE_VISITED' ] = $ this -> getReferer ( ) ; } $ strLogoutUrl = System :: getContainer ( ) -> get ( 'security.logout_url_generator' ) -> getLogoutUrl ( ) ; $ strRedirect = Environment :: get ( 'base' ) ; if ( $ this -> redirectBack && ! empty ( $ _SESSION [ 'LAST_PAGE_VISITED' ] ) ) { $ strRedirect = $ _SESSION [ 'LAST_PAGE_VISITED' ] ; } elseif ( ( $ objTarget = $ this -> objModel -> getRelated ( 'jumpTo' ) ) instanceof PageModel ) { $ strRedirect = $ objTarget -> getAbsoluteUrl ( ) ; } $ uri = Http :: createFromString ( $ strLogoutUrl ) ; $ query = new Query ( $ uri -> getQuery ( ) ) ; $ query = $ query -> merge ( 'redirect=' . $ strRedirect ) ; $ this -> redirect ( ( string ) $ uri -> withQuery ( ( string ) $ query ) ) ; return '' ; }
6530	public static function findAllUsingMixin ( $ mixin ) : array { if ( $ mixin instanceof Mixin ) { $ key = $ mixin -> getId ( ) -> getCurieMajor ( ) ; } else { $ key = $ mixin ; } if ( ! isset ( self :: $ resolvedMixins [ $ key ] ) ) { $ schemas = [ ] ; foreach ( ( self :: $ mixins [ $ key ] ?? [ ] ) as $ id ) { $ schemas [ ] = self :: $ classes [ $ id ] :: schema ( ) ; } self :: $ resolvedMixins [ $ key ] = $ schemas ; } if ( empty ( self :: $ resolvedMixins [ $ key ] ) ) { throw new NoMessageForMixin ( $ mixin ) ; } return self :: $ resolvedMixins [ $ key ] ; }
6489	private function addHeaderValue ( HttpHeaders $ headers , string $ name , $ value , bool $ append ) : void { $ decodedValue = trim ( ( string ) ( isset ( self :: $ headersToUrlDecode [ $ name ] ) ? urldecode ( $ value ) : $ value ) ) ; if ( isset ( self :: $ specialCaseHeaders [ $ name ] ) ) { $ headers -> add ( $ name , $ decodedValue , $ append ) ; } elseif ( strpos ( $ name , 'HTTP_' ) === 0 ) { $ normalizedName = substr ( $ name , 5 ) ; $ headers -> add ( $ normalizedName , $ decodedValue , $ append ) ; } }
1624	protected function releaseLock ( $ name ) { static $ releaseLuaScript = <<<LUAif redis.call("GET",KEYS[1])==ARGV[1] then return redis.call("DEL",KEYS[1])else return 0endLUA ; if ( ! isset ( $ this -> _lockValues [ $ name ] ) || ! $ this -> redis -> executeCommand ( 'EVAL' , [ $ releaseLuaScript , 1 , $ this -> calculateKey ( $ name ) , $ this -> _lockValues [ $ name ] ] ) ) { return false ; } else { unset ( $ this -> _lockValues [ $ name ] ) ; return true ; } }
603	protected function startsWithAnyLongest ( array & $ with , $ caseSensitive , & $ length = null , & $ content = null ) { if ( empty ( $ with ) ) { return false ; } if ( ! is_array ( reset ( $ with ) ) ) { usort ( $ with , function ( $ string1 , $ string2 ) { return mb_strlen ( $ string2 , 'UTF-8' ) - mb_strlen ( $ string1 , 'UTF-8' ) ; } ) ; $ map = [ ] ; foreach ( $ with as $ string ) { $ map [ mb_strlen ( $ string , 'UTF-8' ) ] [ $ caseSensitive ? $ string : mb_strtoupper ( $ string , 'UTF-8' ) ] = true ; } $ with = $ map ; } foreach ( $ with as $ testLength => $ testValues ) { $ content = $ this -> substring ( $ testLength , $ caseSensitive ) ; if ( isset ( $ testValues [ $ content ] ) ) { $ length = $ testLength ; return true ; } } return false ; }
6712	protected function stringToArray ( $ string ) { if ( ! $ string || ! is_string ( $ string ) ) { return [ ] ; } $ result = $ this -> getReaderFactory ( ) -> read ( $ string ) ; if ( $ result ) { return $ result ; } $ array = [ ] ; $ array [ 'text' ] = $ string ; return $ array ; }
6853	public function onStatus ( PaymentEvent $ event ) { $ payment = $ event -> getPayment ( ) ; $ sale = $ payment -> getSale ( ) ; if ( $ sale instanceof OrderInterface ) { return ; } if ( $ sale instanceof CartInterface && $ sale -> getState ( ) !== CartStates :: STATE_ACCEPTED ) { return ; } if ( $ sale instanceof QuoteInterface && $ sale -> getState ( ) !== QuoteStates :: STATE_ACCEPTED ) { return ; } $ tokens = $ this -> findPaymentTokens ( $ payment ) ; if ( null === $ order = $ this -> transform ( $ sale ) ) { return ; } $ newPayment = null ; foreach ( $ order -> getPayments ( ) as $ p ) { if ( $ p -> getNumber ( ) === $ payment -> getNumber ( ) ) { $ newPayment = $ p ; break ; } } if ( null === $ newPayment ) { throw new RuntimeException ( "Failed to find the transformed payment." ) ; } $ this -> convertTokens ( $ this -> getPaymentIdentity ( $ newPayment ) , $ tokens ) ; $ event -> setPayment ( $ newPayment ) ; }
10470	public function lookupUser ( $ user_id ) { $ request = new UserRequest ( $ user_id ) ; $ this -> emit ( 'request.user' , array ( $ user_id ) ) ; $ response = $ this -> post ( $ request ) ; return new UserResponse ( $ response ) ; }
8762	public function upload ( $ input ) { $ validator = \ Validator :: make ( $ input , config ( 'dropzoner.validator' ) , config ( 'dropzoner.validator-messages' ) ) ; if ( $ validator -> fails ( ) ) { return response ( ) -> json ( [ 'error' => true , 'message' => $ validator -> messages ( ) -> first ( ) , 'code' => 400 ] , 400 ) ; } $ photo = $ input [ 'file' ] ; $ original_name = $ photo -> getClientOriginalName ( ) ; $ extension = $ photo -> getClientOriginalExtension ( ) ; $ original_name_without_extension = substr ( $ original_name , 0 , strlen ( $ original_name ) - strlen ( $ extension ) - 1 ) ; $ filename = $ this -> sanitize ( $ original_name_without_extension ) ; $ allowed_filename = $ this -> createUniqueFilename ( $ filename ) ; $ filename_with_extension = $ allowed_filename . '.' . $ extension ; $ manager = new ImageManager ( ) ; $ image = $ manager -> make ( $ photo ) -> save ( config ( 'dropzoner.upload-path' ) . $ filename_with_extension ) ; if ( ! $ image ) { return response ( ) -> json ( [ 'error' => true , 'message' => 'Server error while uploading' , 'code' => 500 ] , 500 ) ; } event ( new ImageWasUploaded ( $ original_name , $ filename_with_extension ) ) ; return response ( ) -> json ( [ 'error' => false , 'code' => 200 , 'filename' => $ filename_with_extension ] , 200 ) ; }
2610	public function determineVersions ( array $ versions ) { $ activeVersion = null ; $ nextVersion = null ; if ( ! empty ( $ versions ) ) { foreach ( $ versions as $ version ) { if ( $ version -> active ) { $ activeVersion = $ version -> number ; } } $ nextVersion = ( int ) end ( $ versions ) -> number + 1 ; } return [ 'active_version' => $ activeVersion , 'next_version' => $ nextVersion ] ; }
2969	protected function getTableGateway ( $ tableName ) { if ( ! array_key_exists ( $ tableName , $ this -> tableGateways ) ) { $ acl = TableSchema :: getAclInstance ( ) ; $ this -> tableGateways [ $ tableName ] = new RelationalTableGateway ( $ tableName , $ this -> connection , $ acl ) ; } return $ this -> tableGateways [ $ tableName ] ; }
11098	public static function secondsBetweenWorkingDays ( $ dateFrom , $ dateTo , $ workDayFrom , $ workDayTo , $ weekends = false , $ holidays = false , $ timeZone = 'Europe/Prague' ) { $ timeZoneObj = new \ DateTimeZone ( $ timeZone ) ; $ dateFromObj = new DateTime ( $ dateFrom , $ timeZoneObj ) ; $ dateToObj = new DateTime ( $ dateTo , $ timeZoneObj ) ; $ workDayFromObj = new DateTime ( $ workDayFrom , $ timeZoneObj ) ; $ workDayToObj = new DateTime ( $ workDayTo , $ timeZoneObj ) ; $ workDayLength = self :: secondsBetweenDates ( $ workDayFrom , $ workDayTo , true , $ timeZone ) ; $ period = new \ DatePeriod ( new DateTime ( $ dateFromObj -> format ( 'Y-m-d 00:00:00' ) , $ timeZoneObj ) , new \ DateInterval ( 'P1D' ) , new DateTime ( $ dateToObj -> format ( 'Y-m-d 23:59:59' ) , $ timeZoneObj ) ) ; $ workedTime = 0 ; foreach ( $ period as $ date ) { if ( ( ! $ weekends && ( int ) $ date -> format ( 'N' ) > 5 ) || ( ! $ holidays && self :: isCzechHoliday ( $ date ) ) ) { continue ; } if ( $ date -> format ( 'Y-m-d' ) === $ dateFromObj -> format ( 'Y-m-d' ) ) { $ endOfDay = new DateTime ( $ date -> format ( 'Y-m-d ' . $ workDayToObj -> format ( 'H:i:s' ) ) , $ timeZoneObj ) ; if ( $ dateFromObj < $ endOfDay && $ dateFromObj -> format ( 'Y-m-d' ) === $ dateToObj -> format ( 'Y-m-d' ) ) { $ diff = $ dateToObj -> diff ( $ dateFromObj ) -> format ( '%H:%I:%S' ) ; } else { $ diff = $ endOfDay -> diff ( $ dateFromObj ) -> format ( '%H:%I:%S' ) ; } $ diff = explode ( ':' , $ diff ) ; $ diff = $ diff [ 0 ] * 3600 + $ diff [ 1 ] * 60 + $ diff [ 0 ] ; $ workedTime += $ diff ; } elseif ( $ date -> format ( 'Y-m-d' ) === $ dateToObj -> format ( 'Y-m-d' ) ) { $ startOfDay = new DateTime ( $ date -> format ( 'Y-m-d ' . $ workDayFromObj -> format ( 'H:i:s' ) ) , $ timeZoneObj ) ; if ( $ dateToObj > $ startOfDay ) { $ diff = $ startOfDay -> diff ( $ dateToObj ) -> format ( '%H:%I:%S' ) ; $ diff = explode ( ':' , $ diff ) ; $ diff = $ diff [ 0 ] * 3600 + $ diff [ 1 ] * 60 + $ diff [ 0 ] ; $ workedTime += $ diff ; } } else { $ workedTime += $ workDayLength ; } } return $ workedTime ; }
4798	function offsetGet ( $ key ) { if ( $ this -> single && ! isset ( $ this -> data ) ) { $ clone = clone $ this ; if ( is_array ( $ key ) ) { $ clone -> where ( $ key ) -> limit ( 1 ) ; } else { $ clone -> where ( $ this -> primary , $ key ) ; } $ return = $ clone -> fetch ( ) ; if ( $ return ) { return $ return ; } } else { $ this -> execute ( ) ; if ( is_array ( $ key ) ) { foreach ( $ this -> data as $ row ) { foreach ( $ key as $ k => $ v ) { if ( ( isset ( $ v ) && $ row [ $ k ] !== null ? $ row [ $ k ] != $ v : $ row [ $ k ] !== $ v ) ) { continue 2 ; } } return $ row ; } } elseif ( isset ( $ this -> data [ $ key ] ) ) { return $ this -> data [ $ key ] ; } } return NULL ; }
2287	public static function findActiveByEmailAndUsername ( $ strEmail , $ strUsername = null , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ time = Date :: floorToMinute ( ) ; $ arrColumns = array ( "$t.email=? AND $t.login='1' AND ($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.disable=''" ) ; if ( $ strUsername !== null ) { $ arrColumns [ ] = "$t.username=?" ; } return static :: findOneBy ( $ arrColumns , array ( $ strEmail , $ strUsername ) , $ arrOptions ) ; }
2758	protected function getNewRatio ( $ key , $ limit , $ milliseconds ) { $ lastRequest = $ this -> getLastRequest ( $ key ) ? : 0 ; $ lastRatio = $ this -> getLastRatio ( $ key ) ? : 0 ; $ diff = ( microtime ( 1 ) - $ lastRequest ) * 1000 ; $ newRatio = $ lastRatio - $ diff ; $ newRatio = $ newRatio < 0 ? 0 : $ newRatio ; $ newRatio += $ milliseconds / $ limit ; return $ newRatio ; }
3012	public function unfollow ( $ blogName ) { $ options = array ( 'url' => $ this -> blogUrl ( $ blogName ) ) ; return $ this -> postRequest ( 'v2/user/unfollow' , $ options , false ) ; }
1976	public static function findMultipleFoldersByFolder ( $ strPath , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ strPath = str_replace ( array ( '\\' , '%' , '_' ) , array ( '\\\\' , '\\%' , '\\_' ) , $ strPath ) ; return static :: findBy ( array ( "$t.type='folder' AND $t.path LIKE ? AND $t.path NOT LIKE ?" ) , array ( $ strPath . '/%' , $ strPath . '/%/%' ) , $ arrOptions ) ; }
5921	public function getProperty ( $ systemName ) { foreach ( $ this -> propertySets as $ propertySet ) { foreach ( $ propertySet -> getProperties ( ) as $ property ) { if ( $ property -> getPropertyType ( ) -> getSystemName ( ) == $ systemName ) { return $ property ; } } } throw new PropertyNotFoundException ( 'No Property with the system name "' . $ systemName . '" exists.' ) ; }
292	public function hasAttribute ( $ name ) { return isset ( $ this -> _attributes [ $ name ] ) || in_array ( $ name , $ this -> attributes ( ) , true ) ; }
9923	public function requireParam ( $ key ) { $ param = $ this -> fetch ( $ key , function ( $ key ) { throw new ParameterMissingException ( "Missing param '$key'" ) ; } ) ; if ( $ this -> valueIsEmpty ( $ param ) ) { throw new ParameterMissingException ( "Missing param '$key'" ) ; } return $ param ; }
5333	public function setSignature ( $ parameters , $ privateKey , $ service , $ endpoint , $ timestamp , $ nonce ) { $ this -> __setCookie ( 'signature' , rawurlencode ( $ this -> sign ( $ privateKey , array_merge ( $ parameters , [ '__service' => $ service , '__hostname' => $ endpoint , '__timestamp' => $ timestamp , '__nonce' => $ nonce , ] ) ) ) ) ; }
12929	public function get ( ) { $ totalEntities = $ this -> repository -> countTotal ( ) ; if ( ! is_null ( $ this -> category ) ) { $ entities = $ this -> repository -> findAllForDataTablesByCategory ( $ this -> search , $ this -> sortColumn , $ this -> sortDirection , $ this -> category ) ; } elseif ( ! is_null ( $ this -> entityId ) ) { $ entities = $ this -> repository -> findAllForDataTables ( $ this -> search , $ this -> sortColumn , $ this -> sortDirection , $ this -> entityId , $ this -> locale ) ; } elseif ( ! is_null ( $ this -> agreementId ) ) { $ entities = $ this -> repository -> findByAgreementForDataTables ( $ this -> search , $ this -> sortColumn , $ this -> sortDirection , $ this -> agreementId ) ; } elseif ( ! is_null ( $ this -> advertId ) ) { $ entities = $ this -> repository -> findByAdvertForDataTables ( $ this -> search , $ this -> sortColumn , $ this -> sortDirection , $ this -> advertId ) ; } else { $ entities = $ this -> repository -> findAllForDataTables ( $ this -> search , $ this -> sortColumn , $ this -> sortDirection , null , $ this -> locale ) ; } $ totalFilteredEntities = count ( $ entities -> getScalarResult ( ) ) ; $ entities -> setFirstResult ( $ this -> offset ) -> setMaxResults ( $ this -> limit ) ; $ data = $ entities -> getResult ( ) ; return array ( 'iTotalRecords' => $ totalEntities , 'iTotalDisplayRecords' => $ totalFilteredEntities , 'sEcho' => $ this -> echo , 'aaData' => $ data ) ; }
12102	public function setMaxSize ( $ maxSize ) { $ serverMaxSize = $ this -> getServerMaxSize ( ) ; if ( $ maxSize > $ serverMaxSize ) { throw new FileMaxSizeException ( $ serverMaxSize ) ; } $ this -> maxSize = $ maxSize ; if ( $ this -> getValidator ( ) ) { $ this -> getValidator ( ) -> setOption ( 'maxSize' , $ maxSize ) ; } }
7694	function MsExcel_GetDrawingLst ( ) { $ lst = array ( ) ; $ dir = '../drawings/' ; $ dir_len = strlen ( $ dir ) ; $ o = $ this -> OpenXML_Rels_GetObj ( $ this -> TBS -> OtbsCurrFile , $ dir ) ; foreach ( $ o -> TargetLst as $ t ) { if ( ( substr ( $ t , 0 , $ dir_len ) === $ dir ) && ( substr ( $ t , - 4 ) === '.xml' ) ) $ lst [ ] = 'xl/drawings/' . substr ( $ t , $ dir_len ) ; } return $ lst ; }
6329	private function getColumnComments ( ) { $ escapement = new Escapement ( ) ; $ comments = '' ; foreach ( $ this -> table -> getColumns ( ) as $ column ) { $ columnDescription = $ column -> getDescription ( ) ; if ( ! empty ( $ columnDescription ) ) { $ comments .= sprintf ( "COMMENT ON COLUMN %s.%s IS '%s';" , $ escapement -> escape ( $ this -> table -> getQualifiedName ( ) ) , $ escapement -> escape ( $ column -> getName ( ) ) , $ columnDescription ) ; } } return $ comments ; }
5030	public function findPageBy ( $ repository , $ conditions ) { $ ret = $ this -> em -> getRepository ( $ repository ) -> findOneBy ( $ conditions ) ; if ( ! $ ret ) { throw new NotFoundHttpException ; } return $ ret ; }
8363	public static function translate ( $ key , array $ args = array ( ) ) { if ( self :: $ isInit === false ) { throw new BadUse ( 'locale doesn\'t seem to have been initialized' ) ; } $ oldKey = $ key ; $ section = self :: $ translations ; while ( isset ( $ section [ $ key ] ) === false && ( $ pos = strpos ( $ key , '.' ) ) !== false ) { if ( ! is_int ( $ pos ) ) { break ; } $ subSection = substr ( $ key , 0 , $ pos ) ; if ( isset ( $ section [ $ subSection ] ) === false ) { break ; } $ section = $ section [ $ subSection ] ; $ key = substr ( $ key , $ pos + 1 ) ; } if ( isset ( $ section [ $ key ] ) === false ) { Logger :: get ( ) -> error ( 'can\'t find translation for key "' . $ oldKey . '"' ) ; return '(null)' ; } return $ section [ $ key ] ; }
6568	protected function createMigration ( ) { $ app = app ( ) ; $ migrationFiles = array ( $ this -> laravel -> path . "/database/migrations/*_create_countries_table.php" => 'countries::generators.migration' , ) ; $ seconds = 0 ; foreach ( $ migrationFiles as $ migrationFile => $ outputFile ) { if ( sizeof ( glob ( $ migrationFile ) ) == 0 ) { $ migrationFile = str_replace ( '*' , date ( 'Y_m_d_His' , strtotime ( '+' . $ seconds . ' seconds' ) ) , $ migrationFile ) ; $ fs = fopen ( $ migrationFile , 'x' ) ; if ( $ fs ) { $ output = "<?php\n\n" . $ app [ 'view' ] -> make ( $ outputFile ) -> with ( 'table' , 'countries' ) -> render ( ) ; fwrite ( $ fs , $ output ) ; fclose ( $ fs ) ; } else { return false ; } $ seconds ++ ; } } $ seeder_file = $ this -> laravel -> path . "/database/seeds/CountriesSeeder.php" ; $ output = "<?php\n\n" . $ app [ 'view' ] -> make ( 'countries::generators.seeder' ) -> render ( ) ; if ( ! file_exists ( $ seeder_file ) ) { $ fs = fopen ( $ seeder_file , 'x' ) ; if ( $ fs ) { fwrite ( $ fs , $ output ) ; fclose ( $ fs ) ; } else { return false ; } } return true ; }
4297	public function clear ( $ flags = self :: CLEAR_LOG ) { array ( $ flags ) ; $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) , array ( 'flags' => self :: CLEAR_LOG ) , array ( 'flags' => 'bitmask' ) ) ; $ event = $ this -> methodClear -> onLog ( new Event ( $ this , array ( 'method' => __FUNCTION__ , 'args' => array ( ) , 'meta' => $ meta , ) ) ) ; $ this -> setLogDest ( 'log' ) ; $ collect = $ this -> cfg [ 'collect' ] ; $ this -> cfg [ 'collect' ] = true ; if ( $ event [ 'log' ] ) { $ this -> appendLog ( $ event [ 'method' ] , $ event [ 'args' ] , $ event [ 'meta' ] ) ; } elseif ( $ event [ 'publish' ] ) { $ this -> internal -> publishBubbleEvent ( 'debug.log' , $ event ) ; } $ this -> cfg [ 'collect' ] = $ collect ; $ this -> setLogDest ( 'auto' ) ; }
276	private function printHelpMessage ( ) { $ this -> stdout ( $ this -> getHelpSummary ( ) . "\n" ) ; $ helpCommand = Console :: ansiFormat ( 'yii help fixture' , [ Console :: FG_CYAN ] ) ; $ this -> stdout ( "Use $helpCommand to get usage info.\n" ) ; }
10670	protected static function _fromArray ( $ dom , $ node , & $ data , $ format ) { if ( $ data === null || $ data === '' || ! \ is_array ( $ data ) ) { return ; } foreach ( $ data as $ key => $ value ) { if ( \ is_string ( $ key ) ) { if ( ! \ is_array ( $ value ) ) { if ( \ is_bool ( $ value ) ) { $ value = ( int ) $ value ; } elseif ( $ value === null ) { $ value = '' ; } $ isNamespace = strpos ( $ key , 'xmlns:' ) ; if ( $ isNamespace !== false ) { $ node -> setAttributeNS ( 'http://www.w3.org/2000/xmlns/' , $ key , $ value ) ; continue ; } if ( $ key [ 0 ] !== '@' && $ format === 'tags' ) { $ child = null ; if ( ! is_numeric ( $ value ) ) { $ child = $ dom -> createElement ( $ key , '' ) ; $ child -> appendChild ( new \ DOMText ( $ value ) ) ; } else { $ child = $ dom -> createElement ( $ key , $ value ) ; } $ node -> appendChild ( $ child ) ; } else { if ( $ key [ 0 ] === '@' ) { $ key = substr ( $ key , 1 ) ; } $ attribute = $ dom -> createAttribute ( $ key ) ; $ attribute -> appendChild ( $ dom -> createTextNode ( $ value ) ) ; $ node -> appendChild ( $ attribute ) ; } } else { if ( $ key [ 0 ] === '@' ) { throw new \ RuntimeException ( Tools :: poorManTranslate ( 'fts-shared' , 'Invalid array' ) ) ; } if ( array_keys ( $ value ) === range ( 0 , \ count ( $ value ) - 1 ) ) { foreach ( $ value as $ item ) { $ data = compact ( 'dom' , 'node' , 'key' , 'format' ) ; $ data [ 'value' ] = $ item ; self :: _createChild ( $ data ) ; } } else { self :: _createChild ( compact ( 'dom' , 'node' , 'key' , 'value' , 'format' ) ) ; } } } else { throw new \ RuntimeException ( Tools :: poorManTranslate ( 'fts-shared' , 'Invalid array' ) ) ; } } }
2401	public function route ( $ strName , $ arrParams = array ( ) ) { $ strUrl = System :: getContainer ( ) -> get ( 'router' ) -> generate ( $ strName , $ arrParams ) ; $ strUrl = substr ( $ strUrl , \ strlen ( Environment :: get ( 'path' ) ) + 1 ) ; return ampersand ( $ strUrl ) ; }
2558	protected function loadPaymentModule ( MopInfo $ options ) { if ( $ this -> checkAnyNotEmpty ( $ options -> fopType , $ options -> payMerchant , $ options -> payments , $ options -> installmentsInfo , $ options -> mopPaymentType , $ options -> creditCardInfo , $ options -> fraudScreening , $ options -> payIds , $ options -> paySupData ) ) { if ( $ this instanceof MopDescription14 ) { $ this -> paymentModule = new PaymentModule14 ( $ options -> fopType ) ; } else { $ this -> paymentModule = new PaymentModule ( $ options -> fopType ) ; } $ this -> paymentModule -> loadPaymentData ( $ options ) ; $ this -> loadMopInformation ( $ options ) ; $ this -> loadPaymentSupplementaryData ( $ options ) ; } }
5591	public function fetchResponse ( $ url , $ encoding ) { if ( ! in_array ( $ encoding -> getMethod ( ) , array ( 'POST' , 'PUT' ) ) ) { $ url -> addRequestParameters ( $ encoding ) ; $ encoding -> clear ( ) ; } $ response = $ this -> fetchWhileRedirected ( $ url , $ encoding ) ; if ( $ headers = $ response -> getHeaders ( ) ) { if ( $ headers -> isChallenge ( ) ) { $ this -> authenticator -> addRealm ( $ url , $ headers -> getAuthentication ( ) , $ headers -> getRealm ( ) ) ; } } return $ response ; }
10811	protected function bindValues ( $ sql , array $ settings ) { $ bindings = & $ this -> bindings ; $ escape = $ this -> getEscapeCallable ( $ settings [ 'escapeFunction' ] ) ; $ params = $ this -> getBuilder ( ) -> getPlaceholderMapping ( ) ; $ function = function ( $ v ) use ( $ settings , & $ bindings , $ escape ) { if ( $ settings [ 'positionedParam' ] ) { $ bindings [ ] = $ v ; return '?' ; } elseif ( $ settings [ 'namedParam' ] && isset ( $ v [ 0 ] ) && ':' == $ v [ 0 ] ) { return $ v ; } elseif ( is_numeric ( $ v ) && ! is_string ( $ v ) ) { return $ v ; } else { return $ escape ( $ v ) ; } } ; return preg_replace_callback ( '/\b__PH_[0-9]++__\b/' , function ( $ m ) use ( & $ params , $ function ) { return $ function ( $ params [ $ m [ 0 ] ] ) ; } , $ sql ) ; }
3594	public static function getCurrentMacAddress ( $ interface ) { $ ifconfig = self :: runCommand ( "ifconfig {$interface}" ) ; preg_match ( "/" . self :: $ valid_mac . "/i" , $ ifconfig , $ ifconfig ) ; if ( isset ( $ ifconfig [ 0 ] ) ) { return trim ( strtoupper ( $ ifconfig [ 0 ] ) ) ; } return false ; }
2915	public function getLayoutUpdatesFiles ( $ storeId , $ designArea ) { $ updatesRoot = $ this -> getConfig ( ) -> getNode ( $ designArea . '/layout/updates' ) ; $ updateFiles = array ( ) ; foreach ( $ updatesRoot -> children ( ) as $ updateNode ) { if ( $ updateNode -> file ) { $ module = $ updateNode -> getAttribute ( 'module' ) ; if ( $ module && Mage :: getStoreConfigFlag ( 'advanced/modules_disable_output/' . $ module , $ storeId ) ) { continue ; } $ updateFiles [ ] = ( string ) $ updateNode -> file ; } } $ updateFiles [ ] = 'local.xml' ; return $ updateFiles ; }
4325	public static function getCallerInfo ( $ offset = 0 ) { $ return = array ( 'file' => null , 'line' => null , 'function' => null , 'class' => null , 'type' => null , ) ; $ backtrace = \ debug_backtrace ( DEBUG_BACKTRACE_IGNORE_ARGS | DEBUG_BACKTRACE_PROVIDE_OBJECT , 8 ) ; $ numFrames = \ count ( $ backtrace ) ; $ regexInternal = '/^' . \ preg_quote ( __NAMESPACE__ ) . '\b/' ; if ( isset ( $ backtrace [ 1 ] [ 'class' ] ) && \ preg_match ( $ regexInternal , $ backtrace [ 1 ] [ 'class' ] ) ) { for ( $ i = $ numFrames - 1 ; $ i >= 0 ; $ i -- ) { if ( isset ( $ backtrace [ $ i ] [ 'class' ] ) && \ preg_match ( $ regexInternal , $ backtrace [ $ i ] [ 'class' ] ) ) { break ; } } } else { $ i = 1 ; } $ i += $ offset ; $ iLine = $ i ; $ iFunc = $ i + 1 ; if ( isset ( $ backtrace [ $ iFunc ] ) && \ in_array ( $ backtrace [ $ iFunc ] [ 'function' ] , array ( 'call_user_func' , 'call_user_func_array' ) ) ) { $ iLine ++ ; $ iFunc ++ ; } elseif ( isset ( $ backtrace [ $ iFunc ] [ 'class' ] ) && $ backtrace [ $ iFunc ] [ 'class' ] == 'ReflectionMethod' && $ backtrace [ $ iFunc ] [ 'function' ] == 'invoke' ) { $ iLine ++ ; $ iFunc -- ; } if ( isset ( $ backtrace [ $ iFunc ] ) ) { $ return = \ array_merge ( $ return , \ array_intersect_key ( $ backtrace [ $ iFunc ] , $ return ) ) ; if ( $ return [ 'type' ] == '->' ) { $ return [ 'class' ] = \ get_class ( $ backtrace [ $ iFunc ] [ 'object' ] ) ; } } if ( isset ( $ backtrace [ $ iLine ] ) ) { $ return [ 'file' ] = $ backtrace [ $ iLine ] [ 'file' ] ; $ return [ 'line' ] = $ backtrace [ $ iLine ] [ 'line' ] ; } else { $ return [ 'file' ] = $ backtrace [ $ numFrames - 1 ] [ 'file' ] ; $ return [ 'line' ] = 0 ; } return $ return ; }
10123	private function writePrintGridlines ( ) { $ record = 0x002b ; $ length = 0x0002 ; $ fPrintGrid = $ this -> phpSheet -> getPrintGridlines ( ) ? 1 : 0 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ fPrintGrid ) ; $ this -> append ( $ header . $ data ) ; }
4224	public function handleException ( $ exception ) { $ this -> uncaughtException = $ exception ; \ http_response_code ( 500 ) ; $ this -> handleError ( E_ERROR , 'Uncaught exception \'' . \ get_class ( $ exception ) . '\' with message ' . $ exception -> getMessage ( ) , $ exception -> getFile ( ) , $ exception -> getLine ( ) ) ; $ this -> uncaughtException = null ; if ( $ this -> cfg [ 'continueToPrevHandler' ] && $ this -> prevExceptionHandler ) { \ call_user_func ( $ this -> prevErrorHandler , $ exception ) ; } }
855	public function insertAt ( $ index , $ items ) { $ items = \ is_array ( $ items ) || $ items instanceof self ? $ items : [ $ items ] ; $ itemsCnt = \ count ( $ items ) ; if ( 0 === $ itemsCnt ) { return ; } $ oldSize = \ count ( $ this ) ; $ this -> changed = true ; $ this -> blockEndCache = [ ] ; $ this -> setSize ( $ oldSize + $ itemsCnt ) ; for ( $ i = $ oldSize + $ itemsCnt - 1 ; $ i >= $ index ; -- $ i ) { $ oldItem = parent :: offsetExists ( $ i - $ itemsCnt ) ? parent :: offsetGet ( $ i - $ itemsCnt ) : new Token ( '' ) ; parent :: offsetSet ( $ i , $ oldItem ) ; } for ( $ i = 0 ; $ i < $ itemsCnt ; ++ $ i ) { if ( '' === $ items [ $ i ] -> getContent ( ) ) { throw new \ InvalidArgumentException ( 'Must not add empty token to collection.' ) ; } $ this -> registerFoundToken ( $ items [ $ i ] ) ; parent :: offsetSet ( $ i + $ index , $ items [ $ i ] ) ; } }
2167	protected static function generateHelperObject ( $ value ) { $ return = new \ stdClass ( ) ; if ( ! \ is_array ( $ value ) ) { $ return -> value = rtrim ( $ value , "\x00" ) ; $ return -> isUuid = ( \ strlen ( $ value ) == 16 && ! is_numeric ( $ return -> value ) && strncmp ( $ return -> value , Config :: get ( 'uploadPath' ) . '/' , \ strlen ( Config :: get ( 'uploadPath' ) ) + 1 ) !== 0 ) ; $ return -> isNumeric = ( is_numeric ( $ return -> value ) && $ return -> value > 0 ) ; } else { $ return -> value = array_map ( function ( $ var ) { return rtrim ( $ var , "\x00" ) ; } , $ value ) ; $ return -> isUuid = ( \ strlen ( $ value [ 0 ] ) == 16 && ! is_numeric ( $ return -> value [ 0 ] ) && strncmp ( $ return -> value [ 0 ] , Config :: get ( 'uploadPath' ) . '/' , \ strlen ( Config :: get ( 'uploadPath' ) ) + 1 ) !== 0 ) ; $ return -> isNumeric = ( is_numeric ( $ return -> value [ 0 ] ) && $ return -> value [ 0 ] > 0 ) ; } return $ return ; }
1620	public function buildOne ( $ query ) { $ modelClass = $ query -> modelClass ; $ key = $ this -> quoteValue ( $ modelClass :: keyPrefix ( ) . ':a:' ) ; return $ this -> build ( $ query , "do return redis.call('HGETALL',$key .. pk) end" , 'pks' ) ; }
8194	public function render ( $ template , $ data = [ ] , $ return = true ) { if ( $ template instanceof Page ) { $ page = $ template ; $ file = $ page -> templateFile ( ) ; $ data = $ this -> data ( $ page , $ data ) ; } else { $ file = $ template ; $ data = $ this -> data ( null , $ data ) ; } if ( ! file_exists ( $ file ) ) { throw new Exception ( 'The template could not be found' ) ; } $ startData = Tpl :: $ data ; Tpl :: $ data = array_merge ( Tpl :: $ data , $ data ) ; if ( pathinfo ( $ file , PATHINFO_EXTENSION ) === 'twig' ) { $ twig = TwigEnv :: instance ( ) ; $ result = $ twig -> renderPath ( $ file , Tpl :: $ data , $ return , true ) ; } else { $ result = Tpl :: load ( $ file , [ ] , $ return ) ; } Tpl :: $ data = $ startData ; return $ result ; }
8692	public static function checkSymlink ( $ symlinkTarget , $ symlinkName , $ forceSymlink = false ) { if ( $ forceSymlink && file_exists ( $ symlinkName ) && ! is_link ( $ symlinkName ) ) { if ( 'link' !== filetype ( $ symlinkName ) ) { throw new \ UnexpectedValueException ( "{$symlinkName} exists and is not a link" ) ; } } elseif ( is_link ( $ symlinkName ) ) { $ linkTarget = readlink ( $ symlinkName ) ; if ( $ linkTarget !== $ symlinkTarget ) { if ( ! $ forceSymlink ) { throw new \ UnexpectedValueException ( "Symlink '{$symlinkName}' points to '{$linkTarget}' instead of '{$symlinkTarget}'" ) ; } unlink ( $ symlinkName ) ; return false ; } return true ; } return false ; }
7627	public function createContainerIfNotExists ( $ containerName = '' , $ metadata = array ( ) ) { if ( ! $ this -> containerExists ( $ containerName ) ) { $ this -> createContainer ( $ containerName , $ metadata ) ; } }
1629	public function getMonolog ( ) { foreach ( $ this -> loggers as $ logger ) { if ( is_callable ( [ $ logger , 'getMonolog' ] ) ) { $ monolog = $ logger -> getMonolog ( ) ; if ( $ monolog === null ) { continue ; } return $ monolog ; } } }
11713	private function getCalcData ( ) { $ req = new AGetPeriodRequest ( ) ; $ req -> setBaseCalcTypeCode ( Cfg :: CODE_TYPE_CALC_PV_WRITE_OFF ) ; $ req -> setDepCalcTypeCode ( Cfg :: CODE_TYPE_CALC_UNQUALIFIED_PROCESS ) ; $ resp = $ this -> servPeriodGet -> exec ( $ req ) ; $ writeOffCalc = $ resp -> getBaseCalcData ( ) ; $ processCalc = $ resp -> getDepCalcData ( ) ; $ result = [ $ writeOffCalc , $ processCalc ] ; return $ result ; }
3541	public static function getGroupAssigmentOptions ( $ optionName , $ individualGroupAssignmentOptions = null ) { if ( $ individualGroupAssignmentOptions != null && is_array ( $ individualGroupAssignmentOptions ) && array_key_exists ( $ optionName , $ individualGroupAssignmentOptions ) ) { return $ individualGroupAssignmentOptions [ $ optionName ] ; } else if ( isset ( Yii :: $ app -> params [ 'LDAP-Group-Assignment-Options' ] ) && is_array ( Yii :: $ app -> params [ 'LDAP-Group-Assignment-Options' ] ) && array_key_exists ( $ optionName , Yii :: $ app -> params [ 'LDAP-Group-Assignment-Options' ] ) ) { return Yii :: $ app -> params [ 'LDAP-Group-Assignment-Options' ] [ $ optionName ] ; } else if ( array_key_exists ( $ optionName , static :: GROUP_ASSIGNMENT_TOUCH_ONLY_MATCHING_REGEX ) ) { return static :: GROUP_ASSIGNMENT_TOUCH_ONLY_MATCHING_REGEX [ $ optionName ] ; } else { throw new \ yii \ base \ Exception ( 'Group-Option ' . $ optionName . ' not found. Please define settings in the config/params.php of the yii2 framework as described on top of the UserDbLdap.php' ) ; } }
8509	public function getPrepInstructionsForSKU ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_GetPrepInstructionsForSKURequest ) ) { $ request = new FBAInboundServiceMWS_Model_GetPrepInstructionsForSKURequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetPrepInstructionsForSKU' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_GetPrepInstructionsForSKUResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
4907	public function onRoute ( MvcEvent $ event ) { $ request = $ event -> getRequest ( ) ; $ ajax = $ request -> getQuery ( ) -> get ( 'ajax' ) ; if ( ! $ request -> isXmlHttpRequest ( ) || ! $ ajax ) { return ; } $ response = $ event -> getResponse ( ) ; $ ajaxEvent = $ this -> ajaxEventManager -> getEvent ( $ ajax , $ this ) ; $ ajaxEvent -> setRequest ( $ request ) ; $ ajaxEvent -> setResponse ( $ response ) ; $ results = $ this -> ajaxEventManager -> triggerEventUntil ( function ( $ r ) { return null !== $ r ; } , $ ajaxEvent ) ; $ result = $ results -> last ( ) ? : $ ajaxEvent -> getResult ( ) ; if ( ! $ result ) { throw new \ UnexpectedValueException ( 'No listener returned anything. Do not know what to do...' ) ; } if ( is_array ( $ result ) || $ result instanceof \ Traversable ) { $ result = Json :: encode ( $ result , true , [ 'enableJsonExprFinder' => true ] ) ; } $ contentType = $ ajaxEvent -> getContentType ( ) ; $ response -> getHeaders ( ) -> addHeaderLine ( 'Content-Type' , $ contentType ) ; $ response -> setContent ( $ result ) ; return $ response ; }
6049	public function setProperties ( array $ properties ) { $ this -> properties = [ ] ; foreach ( $ properties as $ item ) { $ this -> addPropertyResponse ( $ item ) ; } return $ this ; }
9516	public function settings ( $ name = null , $ value = null ) { switch ( func_num_args ( ) ) { case 0 : return $ this -> info ( 'settings' ) ; break ; case 1 : return $ this -> info ( 'settings' , func_get_arg ( 0 ) ) ; break ; case 2 : $ update = false ; list ( $ name , $ value ) = func_get_args ( ) ; $ current = $ this -> info ( 'settings' , $ name ) ; if ( is_null ( $ value ) ) { if ( ! is_null ( $ current ) ) { unset ( $ this -> info [ 'settings' ] [ $ name ] ) ; $ update = true ; } } elseif ( $ current !== $ value ) { $ this -> info [ 'settings' ] [ $ name ] = $ value ; $ update = true ; } if ( $ update ) { $ this -> exec ( 'UPDATE config SET settings = ?' , serialize ( $ this -> info [ 'settings' ] ) ) ; } break ; } }
7194	public static function get_thumbnail_file ( $ meta , $ size = 'medium' ) { if ( ! isset ( $ meta [ 'sizes' ] [ $ size ] ) ) { $ file = FALSE ; } else { $ dir = wp_upload_dir ( ) ; $ file_parts = array ( $ dir [ 'basedir' ] , dirname ( $ meta [ 'file' ] ) , $ meta [ 'sizes' ] [ $ size ] [ 'file' ] ) ; $ file = implode ( DIRECTORY_SEPARATOR , $ file_parts ) ; } return apply_filters ( 'iac_attach_media_thumbnail_file' , $ file , $ meta , $ size ) ; }
10958	private function processFiles ( ) { foreach ( $ this -> currentCommand -> getFilesToMove ( ) as $ fileToMove ) { if ( $ fileToMove instanceof \ SplFileInfo ) { $ this -> processSplFileInfo ( $ fileToMove ) ; } else { $ this -> processArray ( $ fileToMove ) ; } } }
8668	public function setSelf ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'Self' ] [ 'FieldValue' ] = $ value ; return $ this ; }
9134	public function setLastPost ( $ lastPost ) { if ( $ lastPost == 0 ) { $ this -> _lastPost = "" ; } elseif ( $ lastPost !== "" and $ lastPost !== "NULL" and $ lastPost !== null ) { if ( $ lastPost instanceof DateTime ) { $ this -> _lastPost = $ lastPost ; } else { $ this -> _lastPost = new DateTime ( $ lastPost ) ; } } return $ this ; }
6629	public function authenticate ( ) { $ state = $ this -> makeState ( ) ; $ this -> store -> put ( $ state , $ this -> settings ) ; return $ this -> redirect -> to ( $ this -> authURL ( $ state ) ) ; }
11721	public function getCarouselItemsBlog ( $ entity ) { $ em = $ this -> container -> get ( 'doctrine' ) -> getManager ( ) ; if ( $ entity instanceof Category ) { $ qb = $ em -> getRepository ( 'BlogBundle:Post' ) -> createQueryBuilder ( 'p' ) -> join ( 'p.categories' , 'c' ) -> join ( 'p.translations' , 't' ) -> where ( 'c.id = :category' ) -> andWhere ( 'p.highlighted = true' ) -> setParameter ( 'category' , $ entity -> getId ( ) ) -> setMaxResults ( 3 ) -> orderBy ( 'p.published' , 'DESC' ) ; } elseif ( $ entity instanceof Tag ) { $ qb = $ em -> getRepository ( 'BlogBundle:Post' ) -> createQueryBuilder ( 'p' ) -> join ( 'p.tags' , 'tag' ) -> join ( 'p.translations' , 't' ) -> where ( 't.id = :tag' ) -> andWhere ( 'p.highlighted = true' ) -> setParameter ( 'tag' , $ entity -> getId ( ) ) -> setMaxResults ( 3 ) -> orderBy ( 'p.published' , 'DESC' ) ; } $ entities = $ qb -> getQuery ( ) -> getResult ( ) ; return $ entities ; }
4253	public function processLogEntry ( $ method , $ args = array ( ) , $ meta = array ( ) ) { if ( $ method == 'alert' ) { list ( $ method , $ args ) = $ this -> methodAlert ( $ args , $ meta ) ; } elseif ( $ method == 'assert' ) { \ array_unshift ( $ args , false ) ; } elseif ( \ in_array ( $ method , array ( 'count' , 'time' ) ) ) { $ method = 'log' ; } elseif ( \ in_array ( $ method , array ( 'profileEnd' , 'table' ) ) ) { $ method = 'log' ; if ( \ is_array ( $ args [ 0 ] ) ) { $ method = 'table' ; $ args = array ( $ this -> methodTable ( $ args [ 0 ] , $ meta [ 'columns' ] ) ) ; } elseif ( $ meta [ 'caption' ] ) { \ array_unshift ( $ args , $ meta [ 'caption' ] ) ; } } elseif ( $ method == 'trace' ) { $ method = 'table' ; $ args = array ( $ this -> methodTable ( $ args [ 0 ] , array ( 'function' , 'file' , 'line' ) ) ) ; } elseif ( \ in_array ( $ method , array ( 'error' , 'warn' ) ) ) { if ( isset ( $ meta [ 'file' ] ) ) { $ args [ ] = $ meta [ 'file' ] . ': line ' . $ meta [ 'line' ] ; } } if ( ! \ in_array ( $ method , $ this -> consoleMethods ) ) { $ method = 'log' ; } foreach ( $ args as $ k => $ arg ) { $ args [ $ k ] = \ json_encode ( $ this -> dump ( $ arg ) ) ; } $ str = 'console.' . $ method . '(' . \ implode ( ',' , $ args ) . ');' . "\n" ; $ str = \ str_replace ( \ json_encode ( $ this -> debug -> abstracter -> UNDEFINED ) , 'undefined' , $ str ) ; return $ str ; }
1089	protected function getStub ( $ name ) { if ( stripos ( $ name , '.php' ) === FALSE ) $ name = $ name . '.php' ; return $ this -> files -> get ( $ this -> getStubPath ( ) . '/' . $ name ) ; }
10049	private static function toArray ( $ object ) { $ type = gettype ( $ object ) ; if ( $ type == 'array' ) { foreach ( $ object as $ element ) { $ result [ ] = self :: toArray ( $ element ) ; } return $ result ; } else if ( $ type == 'object' ) { if ( is_subclass_of ( $ object , 'AbstractJSONWrapper' ) ) { return $ object -> toArray ( ) ; } else { trigger_error ( "JSONSerializer: Trying to serialize " . get_class ( $ object ) ) ; return $ object ; } } else { return $ object ; } }
8052	public function getAllEventsAsJson ( ) { $ cache = $ this -> cache ; if ( $ cache :: has ( self :: ALL_EVENTS_TO_JSON_KEY ) ) { return $ cache :: get ( self :: ALL_EVENTS_TO_JSON_KEY ) ; } $ allEvents = $ this -> calendarEventsEngine -> formatEventsToJson ( $ this -> getAllEvents ( ) ) ; $ allEventsToJson = json_encode ( $ allEvents ) ; $ cache :: put ( self :: ALL_EVENTS_TO_JSON_KEY , $ allEventsToJson , $ this -> cacheTimeToLive ) ; return $ allEventsToJson ; }
12931	public function createRouter ( $ debug = false ) { if ( null === $ this -> routesFile ) { throw new LogicException ( 'The derived class must define the string variable "routesFile"' ) ; } if ( ! is_string ( $ this -> routesFile ) ) { throw new LogicException ( '"routesFile" variable must be a string value' ) ; } $ isProduction = $ this -> configurationHandler -> isProduction ( ) ; $ cacheDir = null ; if ( ! $ debug && $ isProduction ) { $ cacheDir = $ this -> configurationHandler -> siteCacheDir ( ) . '/routes' ; } $ this -> router = new Router ( new YamlFileLoader ( $ this -> fileLocator ) , $ this -> routesFile , array ( 'cache_dir' => $ cacheDir ) ) ; return $ this -> router ; }
12801	public function createItem ( $ name , array $ options = array ( ) ) { if ( ! empty ( $ options [ 'admin' ] ) ) { $ admin = $ options [ 'admin' ] ; if ( ! $ options [ 'admin' ] instanceof AdminInterface ) { $ admin = $ this -> container -> get ( 'sonata.admin.pool' ) -> getAdminByAdminCode ( $ admin ) ; } $ action = isset ( $ options [ 'admin_action' ] ) ? $ options [ 'admin_action' ] : 'list' ; $ options [ 'uri' ] = $ admin -> generateUrl ( $ action ) ; $ options [ 'translationDomain' ] = $ admin -> getTranslationDomain ( ) ; } if ( ! empty ( $ options [ 'route' ] ) ) { $ params = isset ( $ options [ 'routeParameters' ] ) ? $ options [ 'routeParameters' ] : array ( ) ; $ absolute = isset ( $ options [ 'routeAbsolute' ] ) ? $ options [ 'routeAbsolute' ] : false ; $ options [ 'uri' ] = $ this -> generator -> generate ( $ options [ 'route' ] , $ params , $ absolute ) ; } $ item = new MenuItem ( $ name , $ this ) ; $ options = array_merge ( array ( 'uri' => null , 'label' => null , 'attributes' => array ( ) , 'linkAttributes' => array ( ) , 'childrenAttributes' => array ( ) , 'labelAttributes' => array ( ) , 'extras' => array ( ) , 'display' => true , 'displayChildren' => true , 'translationDomain' => 'messages' , 'displayLink' => true , 'displayLabel' => true , ) , $ options ) ; $ item -> setUri ( $ options [ 'uri' ] ) -> setLabel ( $ options [ 'label' ] ) -> setAttributes ( $ options [ 'attributes' ] ) -> setLinkAttributes ( $ options [ 'linkAttributes' ] ) -> setChildrenAttributes ( $ options [ 'childrenAttributes' ] ) -> setLabelAttributes ( $ options [ 'labelAttributes' ] ) -> setExtras ( $ options [ 'extras' ] ) -> setDisplay ( $ options [ 'display' ] ) -> setDisplayChildren ( $ options [ 'displayChildren' ] ) -> setTranslationDomain ( $ options [ 'translationDomain' ] ) -> setDisplayLink ( $ options [ 'displayLink' ] ) -> setDisplayLabel ( $ options [ 'displayLabel' ] ) ; return $ item ; return parent :: createItem ( $ name , $ options ) ; }
6639	protected function initNavigation ( ) { Yii :: $ app -> params [ 'nav' ] [ 'wavecms_dashboard' ] = [ 'label' => FontAwesome :: icon ( 'home' ) . Yii :: t ( 'wavecms/main' , 'Dashboard' ) , 'url' => [ '/' ] , 'position' => 500 ] ; Yii :: $ app -> params [ 'nav' ] [ 'wavecms_user' ] = [ 'label' => FontAwesome :: icon ( 'users' ) . Yii :: t ( 'wavecms/user' , 'Users' ) , 'url' => 'javascript: ;' , 'options' => [ 'class' => 'drop-down' ] , 'permission' => 'wavecms-user' , 'position' => 9000 , 'items' => [ [ 'label' => FontAwesome :: icon ( 'user' ) . Yii :: t ( 'wavecms/user' , 'List of users' ) , 'url' => [ '/wavecms/user/index' ] ] , [ 'label' => FontAwesome :: icon ( 'key' ) . Yii :: t ( 'wavecms/user' , 'Roles' ) , 'url' => [ '/wavecms/role/index' ] ] , ] ] ; Yii :: $ app -> params [ 'nav' ] [ 'wavecms_settings' ] = [ 'label' => FontAwesome :: icon ( 'cog' ) . Yii :: t ( 'wavecms/main' , 'Settings' ) , 'url' => 'javascript: ;' , 'options' => [ 'class' => 'drop-down' ] , 'permission' => 'wavecms-settings' , 'position' => 10000 , 'items' => [ [ 'label' => FontAwesome :: icon ( 'flag' ) . Yii :: t ( 'wavecms/main' , 'Translations' ) , 'url' => [ '/wavecms/translation/index' ] ] , [ 'label' => FontAwesome :: icon ( 'database' ) . Yii :: t ( 'wavecms/main' , 'Cache' ) , 'url' => [ '/wavecms/settings/cache' ] ] ] ] ; }
5681	protected function linkIsAbsolute ( $ url ) { $ parsed = new SimpleUrl ( $ url ) ; return ( boolean ) ( $ parsed -> getScheme ( ) && $ parsed -> getHost ( ) ) ; }
7219	public function up ( $ limit = null ) { $ applied = 0 ; $ migrations = $ this -> migrations_list ; $ limit = ( int ) $ limit ; if ( $ limit > 0 ) { $ migrations = array_slice ( $ migrations , 0 , $ limit ) ; } foreach ( $ migrations as $ migration ) { if ( $ migration [ 'applied' ] ) continue ; $ name = $ migration [ 'name' ] ; $ this -> info ( 'Loading migration #:name' , [ ':name' => $ name ] ) ; $ obj = $ this -> load_migration ( $ migration ) ; $ obj -> init ( ) ; if ( $ obj -> up ( ) === false ) { $ this -> error ( 'Migration #:name failed. Stop.' , [ ':name' => $ name ] ) ; return ; } ; DB :: begin ( ) ; try { $ obj -> safe_up ( ) ; DB :: commit ( ) ; } catch ( \ Throwable $ e ) { DB :: rollback ( ) ; } DB :: insert ( 'INSERT INTO`' . $ this -> migrate_table . '`(`name`, `date`) VALUES(:name, :date)' , [ ':name' => $ name , ':date' => time ( ) ] ) ; $ this -> info ( 'Migration up successfully' , [ ':name' => $ name ] ) ; $ applied ++ ; } if ( ! $ applied ) { $ this -> warning ( 'No new migration found' ) ; } }
8054	public function updateCalendarEvent ( $ id , array $ data ) { $ eventData = $ this -> calendarEventsEngine -> buildEventData ( $ data ) ; $ eventDates = $ this -> calendarEventsEngine -> buildEventDates ( $ data ) ; $ cache = $ this -> cache ; $ calendarEventRepeatDate = clone $ this -> calendarEventRepeatDate ; $ calendarEventRepeatDate -> where ( 'calendar_event_id' , $ id ) -> delete ( ) ; $ this -> calendarEvent -> where ( 'id' , $ id ) -> update ( $ eventData ) ; $ calendarEvent = $ this -> calendarEvent -> where ( 'id' , $ id ) -> firstOrFail ( ) ; $ this -> handleEventLocation ( $ data , $ calendarEvent ) ; foreach ( $ eventDates as $ date ) { $ calendarEventRepeatDate = clone $ this -> calendarEventRepeatDate ; $ calendarEventRepeatDate -> start = $ date [ 'start' ] ; $ calendarEventRepeatDate -> end = $ date [ 'end' ] ; $ calendarEventRepeatDate -> calendarEvent ( ) -> associate ( $ calendarEvent ) ; $ calendarEventRepeatDate -> save ( ) ; unset ( $ calendarEventRepeatDate ) ; } $ cache :: put ( self :: CACHE_KEY . $ calendarEvent -> id , $ calendarEvent , $ this -> cacheTimeToLive ) ; $ allEvents = $ this -> getAllEvents ( ) ; $ allEvents -> put ( $ calendarEvent -> id , $ calendarEvent ) ; $ cache :: put ( self :: ALL_EVENTS_KEY , $ allEvents , $ this -> cacheTimeToLive ) ; return true ; }
6095	public function permAssign ( $ permid , $ permvalue , $ permskip = false ) { return $ this -> getParent ( ) -> clientPermAssign ( $ this [ "client_database_id" ] , $ permid , $ permvalue , $ permskip ) ; }
823	private function getPreviousUnsetCall ( Tokens $ tokens , $ index ) { $ previousUnsetSemicolon = $ tokens -> getPrevMeaningfulToken ( $ index ) ; if ( null === $ previousUnsetSemicolon ) { return $ index ; } if ( ! $ tokens [ $ previousUnsetSemicolon ] -> equals ( ';' ) ) { return $ previousUnsetSemicolon ; } $ previousUnsetBraceEnd = $ tokens -> getPrevMeaningfulToken ( $ previousUnsetSemicolon ) ; if ( null === $ previousUnsetBraceEnd ) { return $ index ; } if ( ! $ tokens [ $ previousUnsetBraceEnd ] -> equals ( ')' ) ) { return $ previousUnsetBraceEnd ; } $ previousUnsetBraceStart = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ previousUnsetBraceEnd ) ; $ previousUnset = $ tokens -> getPrevMeaningfulToken ( $ previousUnsetBraceStart ) ; if ( null === $ previousUnset ) { return $ index ; } if ( ! $ tokens [ $ previousUnset ] -> isGivenKind ( T_UNSET ) ) { return $ previousUnset ; } return [ $ previousUnset , $ previousUnsetBraceStart , $ previousUnsetBraceEnd , $ previousUnsetSemicolon , ] ; }
8843	public function save ( ) { if ( ! isset ( $ this -> name ) ) { return false ; } if ( class_exists ( '\Tilmeld\Tilmeld' ) && ! \ Tilmeld \ Tilmeld :: gatekeeper ( 'umailphp/admin' ) ) { return false ; } return parent :: save ( ) ; }
7458	public function background ( ) : Font { if ( $ this -> color !== null ) { $ this -> turnToBackground ( ) ; } $ this -> background = true ; return $ this ; }
4266	public static function register ( $ pathsExclude = array ( ) ) { $ result = \ stream_wrapper_unregister ( static :: PROTOCOL ) ; if ( $ result === false ) { throw new \ UnexpectedValueException ( 'Failed to unregister' ) ; } if ( $ pathsExclude ) { self :: $ pathsExclude = $ pathsExclude ; } \ stream_wrapper_register ( static :: PROTOCOL , \ get_called_class ( ) ) ; \ ini_set ( 'opcache.enable' , 0 ) ; }
6283	protected static function buildHttpClient04 ( LoopInterface $ loop , $ dns = null ) { if ( null === $ dns ) { $ dns = static :: buildDnsResolver ( $ loop ) ; } if ( ! $ dns instanceof DnsResolver ) { throw new \ InvalidArgumentException ( 'For react http client v0.4, $dns must be an instance of DnsResolver' ) ; } $ factory = new HttpClientFactory ( ) ; return $ factory -> create ( $ loop , $ dns ) ; }
2485	public function bulkIndexDocuments ( array $ documents ) { $ documentMap = array ( ) ; $ mainTranslationsEndpoint = $ this -> endpointResolver -> getMainLanguagesEndpoint ( ) ; $ mainTranslationsDocuments = array ( ) ; foreach ( $ documents as $ translationDocuments ) { foreach ( $ translationDocuments as $ document ) { $ documentMap [ $ document -> languageCode ] [ ] = $ document ; if ( $ mainTranslationsEndpoint !== null && $ document -> isMainTranslation ) { $ mainTranslationsDocuments [ ] = $ this -> getMainTranslationDocument ( $ document ) ; } } } foreach ( $ documentMap as $ languageCode => $ translationDocuments ) { $ this -> doBulkIndexDocuments ( $ this -> endpointRegistry -> getEndpoint ( $ this -> endpointResolver -> getIndexingTarget ( $ languageCode ) ) , $ translationDocuments ) ; } if ( ! empty ( $ mainTranslationsDocuments ) ) { $ this -> doBulkIndexDocuments ( $ this -> endpointRegistry -> getEndpoint ( $ mainTranslationsEndpoint ) , $ mainTranslationsDocuments ) ; } }
6655	public function normalizeHeaders ( $ params ) { $ out = '' ; foreach ( $ params as $ key => $ param ) { $ out .= $ key . '="' . rawurlencode ( trim ( $ param ) ) . '",' ; } return rtrim ( $ out , ',' ) ; }
2145	public function replace ( $ strBuffer , $ blnCache = true ) { $ strBuffer = $ this -> doReplace ( $ strBuffer , $ blnCache ) ; while ( strpos ( $ strBuffer , '{{' ) !== false && ( $ strTmp = $ this -> doReplace ( $ strBuffer , $ blnCache ) ) != $ strBuffer ) { $ strBuffer = $ strTmp ; } return $ strBuffer ; }
6451	public function isLoggedIn ( ) { $ cookieName = session_name ( ) ; $ cookie = $ this -> getSession ( ) -> getCookie ( $ cookieName ) ; if ( null !== $ cookie ) { $ this -> getSession ( 'goutte' ) -> setCookie ( $ cookieName , $ cookie ) ; return true ; } return false ; }
1222	private function wrapExpression ( $ from , callable $ expr , array $ types ) { list ( $ fn , $ pos ) = explode ( ':' , $ from ) ; $ from = "The expression return value of argument {$pos} of {$fn}" ; return function ( $ value ) use ( $ from , $ expr , $ types ) { $ value = $ expr ( $ value ) ; $ this -> validateType ( $ from , $ value , $ types ) ; return $ value ; } ; }
2512	public function setStatus ( $ newStatus ) { if ( $ this -> isWorseStatus ( $ newStatus , $ this -> status ) ) { $ this -> status = $ newStatus ; } }
8530	private function _convertListFinancialEvents ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'ListFinancialEvents' ; if ( $ request -> isSetSellerId ( ) ) { $ parameters [ 'SellerId' ] = $ request -> getSellerId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } if ( $ request -> isSetMaxResultsPerPage ( ) ) { $ parameters [ 'MaxResultsPerPage' ] = $ request -> getMaxResultsPerPage ( ) ; } if ( $ request -> isSetAmazonOrderId ( ) ) { $ parameters [ 'AmazonOrderId' ] = $ request -> getAmazonOrderId ( ) ; } if ( $ request -> isSetFinancialEventGroupId ( ) ) { $ parameters [ 'FinancialEventGroupId' ] = $ request -> getFinancialEventGroupId ( ) ; } if ( $ request -> isSetPostedAfter ( ) ) { $ parameters [ 'PostedAfter' ] = $ request -> getPostedAfter ( ) ; } if ( $ request -> isSetPostedBefore ( ) ) { $ parameters [ 'PostedBefore' ] = $ request -> getPostedBefore ( ) ; } return $ parameters ; }
7708	function ReplaceSrc ( $ new ) { $ len = $ this -> GetLen ( ) ; $ this -> Txt = substr_replace ( $ this -> Txt , $ new , $ this -> PosBeg , $ len ) ; $ diff = strlen ( $ new ) - $ len ; $ this -> PosEnd += $ diff ; $ this -> pST_Src = false ; if ( $ new === '' ) { $ this -> pST_PosBeg = false ; $ this -> pST_PosEnd = false ; $ this -> pET_PosBeg = false ; } else { $ this -> pST_PosEnd += $ diff ; if ( $ this -> pET_PosBeg !== false ) $ this -> pET_PosBeg += $ diff ; } }
1384	protected function isNotFound ( string $ type , string $ id ) : bool { return ! $ this -> store -> exists ( ResourceIdentifier :: create ( $ type , $ id ) ) ; }
9401	public function setHttp ( ServerRequestInterface $ request , ResponseInterface $ response ) { $ this -> set ( 'Psr\Http\Message\ServerRequestInterface' , $ request ) ; return $ this -> set ( 'Psr\Http\Message\ResponseInterface' , $ response ) ; }
6251	protected function createGroupPresence ( $ id , $ label , array $ children = [ ] ) { return new AclPresence ( [ 'type' => AclPresenceType :: GROUP , 'id' => $ id , 'label' => $ label , 'children' => $ children , ] ) ; }
902	public function isAnonymousClass ( $ index ) { $ tokens = $ this -> tokens ; $ token = $ tokens [ $ index ] ; if ( ! $ token -> isClassy ( ) ) { throw new \ LogicException ( sprintf ( 'No classy token at given index %d.' , $ index ) ) ; } if ( ! $ token -> isGivenKind ( T_CLASS ) ) { return false ; } return $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ index ) ] -> isGivenKind ( T_NEW ) ; }
5905	public function retrieveRole ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/accounts/roles/' . $ id . '' , $ parameters , $ cachePolicy ) ; $ result = new Role ( $ result ) ; return $ result ; }
9567	public function config ( $ configurator ) { if ( $ this -> booted ) { $ this -> invokeConfigurator ( $ configurator ) ; } else { $ this -> configurators -> push ( $ configurator ) ; } }
7299	public static function sender_to_message ( $ message , $ options , $ id ) { $ author = NULL ; $ commenter = NULL ; $ parts = array ( ) ; if ( 'iac_post_message' == current_filter ( ) ) { $ post = get_post ( $ id ) ; $ author = get_userdata ( $ post -> post_author ) ; if ( ! is_a ( $ author , 'WP_User' ) ) { return $ message ; } $ parts = array ( '' , implode ( ' ' , array ( $ options [ 'static_options' ] [ 'mail_string_by' ] , $ author -> data -> display_name ) ) , implode ( ': ' , array ( $ options [ 'static_options' ] [ 'mail_string_url' ] , get_permalink ( $ post ) ) ) ) ; } elseif ( 'iac_comment_message' == current_filter ( ) ) { $ comment = get_comment ( $ id ) ; $ post = get_post ( $ comment -> comment_post_ID ) ; $ commenter = array ( 'name' => 'Annonymous' ) ; if ( 0 != $ comment -> user_id ) { $ author = get_userdata ( $ comment -> user_id ) ; $ commenter [ 'name' ] = $ author -> data -> display_name ; } else { if ( ! empty ( $ comment -> comment_author ) ) { $ commenter [ 'name' ] = $ comment -> comment_author ; } } $ parts = array ( '' , implode ( ' ' , array ( $ options [ 'static_options' ] [ 'mail_string_by' ] , $ commenter [ 'name' ] , $ options [ 'static_options' ] [ 'mail_string_to' ] , get_the_title ( $ post -> ID ) , ) ) , implode ( ': ' , array ( $ options [ 'static_options' ] [ 'mail_string_url' ] , get_permalink ( $ post ) ) ) ) ; } if ( ! empty ( $ parts ) ) { $ message .= implode ( PHP_EOL , $ parts ) ; } return $ message ; }
10360	public static function fatal ( ) { $ e = error_get_last ( ) ; if ( $ e !== null && ( error_reporting ( ) & $ e [ 'type' ] ) !== 0 ) { ErrorHandler :: exception ( new \ ErrorException ( $ e [ 'message' ] , $ e [ 'type' ] , 0 , $ e [ 'file' ] , $ e [ 'line' ] ) ) ; exit ( 1 ) ; } }
9690	public function render ( $ file , $ env = array ( ) ) { $ file = $ this -> views_path . '/' . $ file ; if ( ! file_exists ( $ file ) ) { throw new \ Exception ( "Could not compile $file, file not found" ) ; } $ cacheHash = md5 ( $ file . serialize ( $ env ) ) ; $ cache_file = $ this -> views_cache . "/$cacheHash.cache" ; if ( ! $ this -> debug && ( file_exists ( $ cache_file ) && filemtime ( $ cache_file ) > filemtime ( $ file ) ) ) { return file_get_contents ( $ cache_file ) ; } $ this -> currFile = $ file ; $ hash = md5 ( $ file ) ; $ this -> compile ( $ file ) ; $ compiled_file = $ this -> views_cache . '/' . $ hash ; set_error_handler ( array ( $ this , 'onTemplateError' ) ) ; require_once ( $ compiled_file ) ; $ output = call_user_func ( 'katar_' . $ hash , $ env ) ; restore_error_handler ( ) ; file_put_contents ( $ cache_file , $ output ) ; return $ output ; }
4624	public function pickNewNode ( ) { $ this -> getActiveNode ( ) -> setInactive ( true ) ; $ this -> attempts ++ ; $ this -> inactiveNodes [ $ this -> getActiveNodeIndex ( ) ] = $ this -> getActiveNode ( ) ; unset ( $ this -> nodes [ $ this -> getActiveNodeIndex ( ) ] ) ; $ this -> setActiveNodeIndex ( $ this -> pickNode ( ) ) ; return $ this ; }
7036	protected function dropMigrationTable ( ) { try { return Db :: query ( "drop table if exists migrations" , [ ] , $ this -> dbName , false ) ; } catch ( PDOException $ e ) { error_log ( $ e -> getMessage ( ) ) ; return false ; } }
8710	public function where ( $ column , $ operator = null , $ value = null , $ boolean = 'and' ) { if ( is_array ( $ column ) ) { return $ this -> addArrayOfWheres ( $ column , $ boolean ) ; } if ( in_array ( $ column , $ this -> model -> translatableAttributes ( ) ) ) { return $ this -> whereTranslated ( $ column , $ operator , $ value , $ boolean ) ; } return parent :: where ( $ column , $ operator , $ value , $ boolean ) ; }
4399	protected function saveRepayData ( \ Omnipay \ Common \ Message \ ResponseInterface $ response , $ customerId ) { $ data = [ ] ; if ( method_exists ( $ response , 'getCardReference' ) ) { $ data [ 'token' ] = $ response -> getCardReference ( ) ; } if ( method_exists ( $ response , 'getExpiryMonth' ) ) { $ data [ 'month' ] = $ response -> getExpiryMonth ( ) ; } if ( method_exists ( $ response , 'getExpiryYear' ) ) { $ data [ 'year' ] = $ response -> getExpiryYear ( ) ; } if ( ! empty ( $ data ) ) { $ this -> setCustomerData ( $ customerId , 'repay' , $ data ) ; } }
9245	private function parseDynamicGroup ( $ group ) { $ regex = $ group [ 'regex' ] ; $ parts = explode ( '|' , $ regex ) ; $ data = array ( ) ; foreach ( $ group [ 'routeMap' ] as $ matchIndex => $ routeData ) { if ( ! is_array ( $ routeData [ 0 ] ) || ! isset ( $ routeData [ 0 ] [ 'name' ] ) || ! isset ( $ parts [ $ matchIndex - 1 ] ) ) { continue ; } $ parameters = $ routeData [ 1 ] ; $ path = $ parts [ $ matchIndex - 1 ] ; foreach ( $ parameters as $ parameter ) { $ path = $ this -> replaceOnce ( '([^/]+)' , '{' . $ parameter . '}' , $ path ) ; } $ path = rtrim ( $ path , '()$~' ) ; $ data [ $ routeData [ 0 ] [ 'name' ] ] = array ( 'path' => $ path , 'params' => $ parameters , ) ; } return $ data ; }
4243	public function onShutdown ( ) { $ this -> runtimeVals ( ) ; if ( $ this -> testEmailLog ( ) ) { $ this -> emailLog ( ) ; } if ( ! $ this -> debug -> getData ( 'outputSent' ) ) { echo $ this -> debug -> output ( ) ; } return ; }
10820	public static function warning ( $ messages , $ linebreak = true , $ length = 0 ) { $ separator = $ linebreak ? "\n" : '' ; self :: write ( $ messages , 'warning' , $ length , $ separator ) ; }
6961	public static function J ( $ year ) { $ jd = static :: J2000 ( ) -> jd + ( $ year - 2000 ) * static :: DaysJulianYear ; $ epoch = new static ( $ jd ) ; $ epoch -> type = YearType :: Julian ( ) ; return $ epoch ; }
3730	protected function getMatchingIds ( $ objFilter ) { if ( $ objFilter ) { $ arrFilteredIds = $ objFilter -> getMatchingIds ( ) ; if ( $ arrFilteredIds !== null ) { return $ arrFilteredIds ; } } return $ this -> getConnection ( ) -> createQueryBuilder ( ) -> select ( 'id' ) -> from ( $ this -> getTableName ( ) ) -> execute ( ) -> fetchAll ( \ PDO :: FETCH_COLUMN ) ; }
12325	protected function execute ( InputInterface $ input , OutputInterface $ output ) { try { $ this -> doPreExecute ( $ input , $ output ) ; $ this -> returnCode = $ this -> doExecute ( $ input , $ output ) ; $ this -> doPostExecute ( $ input , $ output ) ; } catch ( Exception $ e ) { $ this -> returnCode = static :: RETURN_ERROR ; throw $ e ; } return $ this -> returnCode ; }
5036	public function indexAction ( ) { $ events = $ this -> adminControllerEvents ; $ event = $ events -> getEvent ( AdminControllerEvent :: EVENT_DASHBOARD , $ this ) ; $ events -> trigger ( $ event , $ this ) ; $ model = new ViewModel ( ) ; $ widgets = [ ] ; foreach ( $ event -> getViewModels ( ) as $ name => $ child ) { $ model -> addChild ( $ child , $ name ) ; $ widgets [ ] = $ name ; } $ model -> setVariable ( 'widgets' , $ widgets ) ; return $ model ; }
6125	public function setRoles ( array $ roles ) { $ this -> roles = [ ] ; foreach ( $ roles as $ item ) { $ this -> addRole ( $ item ) ; } return $ this ; }
11912	public function setIndustry ( $ industryOne , $ industryTwo ) { $ params = [ 'industry_id1' => $ industryOne , 'industry_id2' => $ industryTwo , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_SET_INDUSTRY , $ params ] ) ; }
8423	public function mappings ( Request $ request ) { $ table = new \ cli \ Table ( ) ; $ table -> setHeaders ( [ 'Mapping' , 'Database' , 'Models path' ] ) ; $ rows = [ ] ; $ mappings = Mapping :: getMappings ( ) ; usort ( $ mappings , function ( array $ a , array $ b ) { return strcmp ( $ a [ 'config' ] [ 'name' ] , $ b [ 'config' ] [ 'name' ] ) ; } ) ; foreach ( $ mappings as $ mapping ) { $ rows [ ] = [ $ mapping [ 'config' ] [ 'name' ] , $ mapping [ 'config' ] [ 'database' ] , $ mapping [ 'config' ] [ 'models' ] [ 'path' ] , ] ; } $ table -> setRows ( $ rows ) ; $ table -> display ( ) ; }
11466	public static function writeLogLine ( $ log_file , $ input , $ timestamp = null ) { if ( is_null ( self :: $ _error_folder ) ) { return false ; } $ log_file = basename ( $ log_file ) ; $ fp = @ fopen ( self :: $ _error_folder . $ log_file , 'ab' ) ; if ( ! $ fp ) { return false ; } if ( empty ( $ timestamp ) ) { $ timestamp = time ( ) ; } $ line = [ ] ; $ line [ ] = date ( \ DateTime :: ISO8601 , $ timestamp ) ; if ( $ input instanceof \ Throwable ) { $ message = $ input -> getMessage ( ) ; if ( ! ( $ input instanceof BaseException ) ) { $ message = preg_replace ( '/\s+/' , ' ' , $ message ) ; } $ line [ ] = BaseException :: getShortName ( get_class ( $ input ) ) ; $ line [ ] = $ message ; $ line [ ] = $ input -> getFile ( ) ; $ line [ ] = $ input -> getLine ( ) ; $ line_out = vsprintf ( '[%s] %s: %s in %s on line %d' , $ line ) ; } elseif ( is_string ( $ input ) ) { $ line [ ] = $ input ; $ line_out = vsprintf ( '[%s] %s' , $ line ) ; } else { return false ; } if ( flock ( $ fp , LOCK_EX ) ) { fwrite ( $ fp , $ line_out . PHP_EOL ) ; flock ( $ fp , LOCK_UN ) ; fclose ( $ fp ) ; return true ; } else { return false ; } }
1923	public static function fromDimensions ( $ width , $ height ) { $ image = imagecreatetruecolor ( $ width , $ height ) ; $ arrGdInfo = gd_info ( ) ; $ strGdVersion = preg_replace ( '/[^0-9.]+/' , '' , $ arrGdInfo [ 'GD Version' ] ) ; if ( version_compare ( $ strGdVersion , '2.0' , '>=' ) ) { imagealphablending ( $ image , false ) ; imagefill ( $ image , 0 , 0 , imagecolorallocatealpha ( $ image , 0 , 0 , 0 , 127 ) ) ; imagesavealpha ( $ image , true ) ; } return new static ( $ image ) ; }
2927	protected function resetContent ( ) { $ this -> filePath = null ; $ this -> reader -> load ( null ) ; $ this -> writer -> setBuffer ( null ) ; }
43	private function parsePackage ( $ packageInfo ) { $ packageInfo -> registerXPathNamespace ( 'ns' , self :: CATEGORY_PACKAGES_INFO_NS ) ; $ channelName = ( string ) $ packageInfo -> p -> c ; $ packageName = ( string ) $ packageInfo -> p -> n ; $ license = ( string ) $ packageInfo -> p -> l ; $ shortDescription = ( string ) $ packageInfo -> p -> s ; $ description = ( string ) $ packageInfo -> p -> d ; $ dependencies = array ( ) ; foreach ( $ packageInfo -> xpath ( 'ns:deps' ) as $ node ) { $ dependencyVersion = ( string ) $ node -> v ; $ dependencyArray = unserialize ( ( string ) $ node -> d ) ; $ dependencyInfo = $ this -> dependencyReader -> buildDependencyInfo ( $ dependencyArray ) ; $ dependencies [ $ dependencyVersion ] = $ dependencyInfo ; } $ releases = array ( ) ; $ releasesInfo = $ packageInfo -> xpath ( 'ns:a/ns:r' ) ; if ( $ releasesInfo ) { foreach ( $ releasesInfo as $ node ) { $ releaseVersion = ( string ) $ node -> v ; $ releaseStability = ( string ) $ node -> s ; $ releases [ $ releaseVersion ] = new ReleaseInfo ( $ releaseStability , isset ( $ dependencies [ $ releaseVersion ] ) ? $ dependencies [ $ releaseVersion ] : new DependencyInfo ( array ( ) , array ( ) ) ) ; } } return new PackageInfo ( $ channelName , $ packageName , $ license , $ shortDescription , $ description , $ releases ) ; }
4139	protected function getOauthParameters ( ) { $ time = time ( ) ; return array ( 'oauth_consumer_key' => $ this -> getConsumerKey ( ) , 'oauth_nonce' => trim ( base64_encode ( $ time ) , '=' ) , 'oauth_signature_method' => 'HMAC-SHA1' , 'oauth_timestamp' => $ time , 'oauth_token' => $ this -> getAccessToken ( ) , 'oauth_version' => '1.0' ) ; }
8195	protected function checkConstantExpression ( Twig_NodeInterface $ node ) { if ( ! ( $ node instanceof Twig_Node_Expression_Constant || $ node instanceof Twig_Node_Expression_Array || $ node instanceof Twig_Node_Expression_Unary_Neg || $ node instanceof Twig_Node_Expression_Unary_Pos ) ) { return false ; } foreach ( $ node as $ n ) { if ( ! $ this -> checkConstantExpression ( $ n ) ) { return false ; } } return true ; }
5680	public function getText ( ) { if ( ! $ this -> text ) { $ this -> text = self :: normalise ( $ this -> raw ) ; } return $ this -> text ; }
2220	public static function findPublishedDefaultByPid ( $ intPid , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = array ( "$t.pid=? AND $t.source='default'" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.date DESC" ; } return static :: findBy ( $ arrColumns , $ intPid , $ arrOptions ) ; }
1830	public function refresh ( ) { $ intPk = $ this -> { static :: $ strPk } ; if ( isset ( $ this -> arrModified [ static :: $ strPk ] ) ) { $ intPk = $ this -> arrModified [ static :: $ strPk ] ; } $ res = Database :: getInstance ( ) -> prepare ( "SELECT * FROM " . static :: $ strTable . " WHERE " . Database :: quoteIdentifier ( static :: $ strPk ) . "=?" ) -> execute ( $ intPk ) ; $ this -> setRow ( $ res -> row ( ) ) ; }
5720	public function doSaveAndNext ( $ data , $ form ) { Controller :: curr ( ) -> getResponse ( ) -> addHeader ( "X-Pjax" , "Content" ) ; $ link = $ this -> getEditLink ( $ this -> getNextRecordID ( ) ) ; return $ this -> saveAndRedirect ( $ data , $ form , $ link ) ; }
8671	public static function combine ( $ keys , $ values ) { $ keys = Arr :: from ( $ keys ) ; $ values = Arr :: from ( $ values ) ; if ( count ( $ keys ) !== count ( $ values ) ) { throw new InvalidArgumentException ( 'The size of keys and values needs to be the same.' ) ; } if ( count ( $ keys ) === 0 ) { return new static ( ) ; } return new static ( array_combine ( $ keys , $ values ) ) ; }
3570	public function __unsetHook ( ) { return function ( $ next , $ value , $ args ) { $ key = $ args -> get ( 'key' ) ; if ( $ this -> hasMeta ( $ key ) ) { return $ this -> setMeta ( $ key , null ) ; } return $ next ( $ value , $ args ) ; } ; }
11023	public function run ( string $ task , $ ostr = STDERR ) { $ task = str_replace ( ":" , "\\" , $ task ) ; $ log = Logger :: getLogger ( '' ) ; $ log -> addLogWriter ( new StreamWriter ( STDOUT ) ) ; if ( ! class_exists ( $ task ) ) { fprintf ( $ ostr , "Error: task does not exist: {$task}\n" ) ; return false ; } try { if ( ! is_subclass_of ( $ task , TaskInterface :: class ) ) { fprintf ( $ ostr , "Error: invalid task: {$task}\n" ) ; return false ; } $ taskrunner = new $ task ; $ taskrunner -> execute ( ) ; } catch ( \ Throwable $ e ) { fprintf ( $ ostr , "Error: error while running task: %s\n" , $ task ) ; fprintf ( $ ostr , "Exception: %s\n" , get_class ( $ e ) ) ; fprintf ( $ ostr , "Message: %s\n" , $ e -> getMessage ( ) ) ; if ( method_exists ( $ e , "getLine" ) ) fprintf ( $ ostr , "On: %s (line %d)\n" , $ e -> getFile ( ) , $ e -> getLine ( ) ) ; fprintf ( $ ostr , $ e -> getTraceAsString ( ) . "\n" ) ; return false ; } return true ; }
265	public function setLogger ( $ value ) { if ( is_string ( $ value ) || is_array ( $ value ) ) { $ value = Yii :: createObject ( $ value ) ; } $ this -> _logger = $ value ; $ this -> _logger -> dispatcher = $ this ; }
11910	public function getDefaultParams ( ) { $ defaultParams = [ ] ; foreach ( $ this -> parameters as $ parameter ) { if ( $ parameter -> hasDefault ( ) ) { if ( $ parameter -> getIsAPIParameter ( ) == false ) { $ defaultParams [ ] = $ parameter ; } } } return $ defaultParams ; }
2662	public function getBackends ( $ version ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/backend' ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: GET ) ; return $ result ; }
8243	public function loginAttempt ( $ username , Password $ password ) { $ userData = $ this -> storage -> getUserByName ( $ username ) ; $ encoder = $ this -> getPasswordEncoder ( $ userData ) ; $ dummy = bin2hex ( \ random_bytes ( 32 ) ) ; $ dummyHash = $ encoder -> encode ( $ dummy ) ; if ( ! $ userData ) { $ encoder -> isValid ( $ dummyHash , $ password ) ; return false ; } return $ encoder -> isValid ( $ userData [ 'pwhash' ] , $ password -> get ( ) ) ; }
2916	protected function stringToType ( $ string ) { if ( is_string ( $ string ) ) { switch ( true ) { case ( $ string == 'null' || $ string == 'NULL' ) : $ string = null ; break ; case ( $ string == 'true' || $ string == 'TRUE' ) : $ string = true ; break ; case ( $ string == 'false' || $ string == 'FALSE' ) : $ string = false ; break ; default : break ; } } return $ string ; }
1588	public function getMeta ( ) { $ meta = $ this -> hasMeta ( ) ? $ this -> get ( DocumentInterface :: KEYWORD_META ) : new StandardObject ( ) ; if ( ! is_null ( $ meta ) && ! $ meta instanceof StandardObjectInterface ) { throw new RuntimeException ( 'Data member is not an object.' ) ; } return $ meta ; }
1122	public function leaves ( ) { $ grammar = $ this -> getConnection ( ) -> getQueryGrammar ( ) ; $ rgtCol = $ grammar -> wrap ( $ this -> getQualifiedRightColumnName ( ) ) ; $ lftCol = $ grammar -> wrap ( $ this -> getQualifiedLeftColumnName ( ) ) ; return $ this -> descendants ( ) -> whereRaw ( $ rgtCol . ' - ' . $ lftCol . ' = 1' ) ; }
7469	protected function parseColor ( $ color , $ code = null ) { $ colors = is_array ( $ color ) ? $ color : [ $ color => $ code ] ; $ return = [ ] ; array_walk ( $ colors , function ( $ code , $ color ) use ( & $ return ) { $ color = $ this -> snakeCase ( $ color ) ; $ return [ $ color ] = $ code ; } ) ; return $ return ; }
1993	protected function prepareMetaDescription ( $ strText ) { $ strText = $ this -> replaceInsertTags ( $ strText , false ) ; $ strText = strip_tags ( $ strText ) ; $ strText = str_replace ( "\n" , ' ' , $ strText ) ; $ strText = StringUtil :: substr ( $ strText , 320 ) ; return trim ( $ strText ) ; }
5181	private function appendToArray ( string $ key , $ value ) : self { $ this -> props [ $ key ] = [ $ this -> props [ $ key ] , $ value ] ; return $ this ; }
1171	protected function getProtected ( $ instance , $ property ) { $ closure = function ( $ property ) { return $ this -> $ property ; } ; $ callback = $ closure -> bindTo ( $ instance , $ instance ) ; return $ callback ( $ property ) ; }
11223	private static function checkRegexRoutes ( ) { $ pos = 0 ; self :: getRegexRoutes ( ) ; $ method = $ _SERVER [ 'REQUEST_METHOD' ] ; $ searches = array_keys ( self :: $ patterns ) ; $ replaces = array_values ( self :: $ patterns ) ; foreach ( self :: $ routes as $ route ) { $ segments = explode ( '/' , str_replace ( $ searches , '' , $ route ) ) ; $ route = str_replace ( $ searches , $ replaces , $ route ) ; $ route = Url :: addBackSlash ( $ route ) ; if ( preg_match ( '#^' . $ route . '$#' , self :: $ uri , $ matched ) ) { $ methodRoute = self :: $ methods [ $ pos ] ; if ( $ methodRoute == $ method || $ methodRoute == 'ANY' ) { $ matched = explode ( '/' , trim ( $ matched [ 0 ] , '/' ) ) ; $ matched = array_diff ( $ matched , $ segments ) ; if ( ! is_object ( self :: $ callbacks [ $ pos ] ) ) { self :: $ response = self :: invokeObject ( self :: $ callbacks [ $ pos ] , $ matched ) ; } else { self :: $ response = call_user_func_array ( self :: $ callbacks [ $ pos ] , $ matched ) ; } if ( ! self :: $ halts ) { return self :: $ response ; } self :: $ halts -- ; } } $ pos ++ ; } return self :: $ response ; }
4707	public function processMultipleUnderScore ( Text $ text ) { $ text -> replace ( '{<pre>.*?</pre>}m' , function ( Text $ w ) { $ md5 = md5 ( $ w ) ; $ this -> hashes [ $ md5 ] = $ w ; return "{gfm-extraction-$md5}" ; } ) ; $ text -> replace ( '/^(?! {4}|\t)(\[?\w+_\w+_\w[\w_]*\]?)/' , function ( Text $ w , Text $ word ) { $ underscores = $ word -> split ( '//' ) -> filter ( function ( Text $ item ) { return $ item == '_' ; } ) ; if ( count ( $ underscores ) >= 2 ) { $ word -> replaceString ( '_' , '\\_' ) ; } return $ word ; } ) ; $ text -> replace ( '/\{gfm-extraction-([0-9a-f]{32})\}/m' , function ( Text $ w , Text $ md5 ) { return "\n\n" . $ this -> hashes [ ( string ) $ md5 ] ; } ) ; }
8846	public function getBlogPosts ( ) { $ blogPosts = BlogPost :: get ( ) -> filter ( "ParentID" , $ this -> ID ) ; $ this -> extend ( 'updateGetBlogPosts' , $ blogPosts ) ; return $ blogPosts ; }
11444	public function setTransporter ( TransportInterface $ transporter ) { if ( $ transporter -> validate ( ) ) { $ this -> transporter = $ transporter ; } else { throw new \ Exception ( sprintf ( 'Transporter "%s" is not valid for current environment!' , get_class ( $ transporter ) ) ) ; } return $ this ; }
1334	protected function fillRelated ( $ record , ResourceObject $ resource , EncodingParametersInterface $ parameters ) { $ relationships = $ resource -> getRelationships ( ) ; $ changed = false ; foreach ( $ relationships as $ field => $ value ) { if ( $ this -> isNotFillable ( $ field , $ record ) ) { continue ; } if ( ! $ this -> isRelation ( $ field ) ) { continue ; } $ relation = $ this -> getRelated ( $ field ) ; if ( $ this -> requiresPrimaryRecordPersistence ( $ relation ) ) { $ relation -> update ( $ record , $ value , $ parameters ) ; $ changed = true ; } } if ( $ changed ) { $ record -> refresh ( ) ; } }
7693	function MsExcel_SheetIsIt ( $ FileName ) { $ this -> MsExcel_SheetInit ( ) ; foreach ( $ this -> MsExcel_Sheets as $ o ) { if ( $ FileName == 'xl/' . $ o -> file ) return true ; } return false ; }
11766	public function indexOf ( $ expressionOrColumn ) { if ( $ expressionOrColumn instanceof ExpressionContract ) { return $ this -> indexOfExpression ( $ expressionOrColumn ) ; } return $ this -> indexOfColumn ( $ expressionOrColumn ) ; }
3826	protected function isActiveFrontendFilterValue ( $ arrWidget , $ arrFilterUrl , $ strKeyOption ) { if ( empty ( $ strKeyOption ) && ! isset ( $ arrFilterUrl [ $ arrWidget [ 'eval' ] [ 'urlparam' ] ] ) ) { return true ; } $ blnIsActive = isset ( $ arrFilterUrl [ $ arrWidget [ 'eval' ] [ 'urlparam' ] ] ) && ( $ arrFilterUrl [ $ arrWidget [ 'eval' ] [ 'urlparam' ] ] == $ strKeyOption ) ; if ( ! $ blnIsActive && $ this -> get ( 'defaultid' ) ) { $ blnIsActive = ( $ arrFilterUrl [ $ arrWidget [ 'eval' ] [ 'urlparam' ] ] == $ this -> get ( 'defaultid' ) ) ; } return $ blnIsActive ; }
7750	public function getMetadataFor ( $ className ) { if ( isset ( $ this -> loadedMetadata [ $ className ] ) ) { return $ this -> loadedMetadata [ $ className ] ; } $ realClassName = ClassUtils :: getRealClass ( $ className ) ; if ( isset ( $ this -> loadedMetadata [ $ realClassName ] ) ) { $ this -> loadedMetadata [ $ className ] = $ this -> loadedMetadata [ $ realClassName ] ; return $ this -> loadedMetadata [ $ realClassName ] ; } if ( $ this -> cacheDriver ) { if ( ( $ cached = $ this -> cacheDriver -> fetch ( $ realClassName . $ this -> cacheSalt ) ) !== false ) { $ this -> loadedMetadata [ $ realClassName ] = $ cached ; } else { $ this -> cacheDriver -> save ( $ realClassName . $ this -> cacheSalt , $ this -> loadMetadata ( $ realClassName ) , null ) ; } } else { $ this -> loadMetadata ( $ realClassName ) ; } if ( $ className != $ realClassName ) { $ this -> loadedMetadata [ $ className ] = $ this -> loadedMetadata [ $ realClassName ] ; } return $ this -> loadedMetadata [ $ className ] ; }
11211	protected function hasInLookup ( $ key ) { foreach ( $ this -> lookup_pool as $ registry ) { if ( $ this -> hasInRegistry ( $ registry , $ key ) ) { $ this -> cache_key = $ key ; $ this -> cache_reg = $ registry ; return true ; } } return false ; }
9004	protected function months_dropdown ( $ post_type ) { global $ wpdb , $ wp_locale ; $ tn = $ this -> table -> get_table_name ( $ wpdb ) ; $ months = $ wpdb -> get_results ( " SELECT DISTINCT YEAR( time ) AS year, MONTH( time ) AS month FROM $tn ORDER BY time DESC " ) ; $ month_count = count ( $ months ) ; if ( ! $ month_count || ( 1 == $ month_count && 0 == $ months [ 0 ] -> month ) ) { return ; } $ m = isset ( $ _GET [ 'm' ] ) ? ( int ) $ _GET [ 'm' ] : 0 ; ?> <label for="filter-by-date" class="screen-reader-text"> <?php _e ( 'Filter by date' ) ; ?> </label> <select name="m" id="filter-by-date"> <option <?php selected ( $ m , 0 ) ; ?> value="0"> <?php _e ( 'All dates' ) ; ?> </option> <?php foreach ( $ months as $ arc_row ) { if ( 0 == $ arc_row -> year ) { continue ; } $ month = zeroise ( $ arc_row -> month , 2 ) ; $ year = $ arc_row -> year ; printf ( "<option %s value='%s'>%s</option>\n" , selected ( $ m , $ year . $ month , false ) , esc_attr ( $ arc_row -> year . $ month ) , sprintf ( __ ( '%1$s %2$d' ) , $ wp_locale -> get_month ( $ month ) , $ year ) ) ; } ?> </select> <?php }
67	private function resolveSymlinkedDirectorySymlink ( $ pathname ) { if ( ! is_dir ( $ pathname ) ) { return $ pathname ; } $ resolved = rtrim ( $ pathname , '/' ) ; if ( ! strlen ( $ resolved ) ) { return $ pathname ; } return $ resolved ; }
3593	public static function setFakeMacAddress ( $ interface , $ mac = null ) { if ( ! self :: validateMacAddress ( $ mac ) ) { $ mac = self :: generateMacAddress ( ) ; } self :: runCommand ( "ifconfig {$interface} down" ) ; self :: runCommand ( "ifconfig {$interface} hw ether {$mac}" ) ; self :: runCommand ( "ifconfig {$interface} up" ) ; self :: runCommand ( "dhclient {$interface}" ) ; if ( self :: getCurrentMacAddress ( $ interface ) == $ mac ) { return true ; } return false ; }
5109	public function orderBy ( $ column , $ type = OrderBy :: ASC ) : IWithLimit { if ( $ type == OrderBy :: DESC ) { $ this -> appendDesc ( $ column ) ; } else if ( ! is_array ( $ column ) ) { $ column = [ $ column ] ; } return $ this -> _orderBy ( $ column ) ; }
618	private function parseString ( $ value , & $ i ) { $ isQuoted = $ value [ $ i ] === '"' ; $ stringEndChars = $ isQuoted ? [ '"' ] : [ $ this -> delimiter , '}' ] ; $ result = '' ; $ len = strlen ( $ value ) ; for ( $ i += $ isQuoted ? 1 : 0 ; $ i < $ len ; ++ $ i ) { if ( in_array ( $ value [ $ i ] , [ '\\' , '"' ] , true ) && in_array ( $ value [ $ i + 1 ] , [ $ value [ $ i ] , '"' ] , true ) ) { ++ $ i ; } elseif ( in_array ( $ value [ $ i ] , $ stringEndChars , true ) ) { break ; } $ result .= $ value [ $ i ] ; } $ i -= $ isQuoted ? 0 : 1 ; if ( ! $ isQuoted && $ result === 'NULL' ) { $ result = null ; } return $ result ; }
12932	protected function generateContentAttribute ( $ name , $ value , $ type = 'text' ) { $ attribute = new ContentAttribute ( ) ; $ attribute -> setName ( $ name ) ; $ attribute -> setValue ( $ value ) ; if ( is_array ( $ value ) ) { $ value = '' ; } $ attribute -> setStringValue ( $ value ) ; $ attribute -> setType ( $ type ) ; return $ attribute ; }
7602	public function render ( FormInterface $ oForm , $ sMessage , $ bDismissable = false ) { $ errorHtml = sprintf ( $ this -> messageOpenFormat , $ sMessage ) ; $ sMessagesArray = array ( ) ; foreach ( $ oForm -> getMessages ( ) as $ fieldName => $ sMessages ) { foreach ( $ sMessages as $ sMessage ) { if ( $ oForm -> get ( $ fieldName ) -> getAttribute ( 'id' ) ) { $ sMessagesArray [ ] = sprintf ( '<a href="#%s">%s</a>' , $ oForm -> get ( $ fieldName ) -> getAttribute ( 'id' ) , $ oForm -> get ( $ fieldName ) -> getLabel ( ) . ': ' . $ sMessage ) ; } else { $ sMessagesArray [ ] = $ oForm -> get ( $ fieldName ) -> getLabel ( ) . ': ' . $ sMessage ; } } } return $ this -> dangerAlert ( $ errorHtml . implode ( $ this -> messageSeparatorString , $ sMessagesArray ) . $ this -> messageCloseString , $ bDismissable ) ; }
2530	protected function makeSoapClientOptions ( ) { $ options = $ this -> soapClientOptions ; $ options [ 'classmap' ] = array_merge ( Classmap :: $ soapheader4map , Classmap :: $ map ) ; if ( ! empty ( $ this -> params -> soapClientOptions ) ) { $ options = array_merge ( $ options , $ this -> params -> soapClientOptions ) ; } return $ options ; }
366	public function renderTableFooter ( ) { $ cells = [ ] ; foreach ( $ this -> columns as $ column ) { $ cells [ ] = $ column -> renderFooterCell ( ) ; } $ content = Html :: tag ( 'tr' , implode ( '' , $ cells ) , $ this -> footerRowOptions ) ; if ( $ this -> filterPosition === self :: FILTER_POS_FOOTER ) { $ content .= $ this -> renderFilters ( ) ; } return "<tfoot>\n" . $ content . "\n</tfoot>" ; }
12061	public function getPermissionMap ( $ forRequestPath , $ forRoutePath = "" ) { if ( isset ( $ this -> loaded [ $ forRequestPath ] ) ) { return $ this -> loaded [ $ forRequestPath ] ; } $ database = $ this -> database ; $ permissionsSQLd = NULL ; if ( ! empty ( $ forRoutePath ) && ( $ forRoutePath <> $ forRequestPath ) ) : $ permissionsSQLd = "OR {$database->quote($forRoutePath)} REGEXP p.permission_area_uri" ; endif ; $ premissionsSQLc = "SELECT p.*, a.lft, a.rgt, a.authority_name,a.authority_parent_id FROM ?authority_permissions AS p LEFT JOIN ?authority AS a ON p.authority_id=a.authority_id WHERE {$database->quote($forRequestPath)} REGEXP p.permission_area_uri {$permissionsSQLd} ORDER BY a.lft ASC" ; $ permissionsSQL = $ database -> prepare ( $ premissionsSQLc ) ; $ permissions = $ permissionsSQL -> execute ( ) -> fetchAll ( ) ; $ this -> loaded [ $ forRoutePath ] = $ permissions ; return $ this -> loaded [ $ forRoutePath ] ; }
12257	public function getProjectSearchPaths ( string $ name ) : array { $ srcPaths = $ this -> getProject ( ) -> getAttribute ( AttributeInterface :: SEARCH_PATHS_ATTR_NAME ) ; if ( $ srcPaths instanceof SearchPathCollection ) { return $ srcPaths -> getSearchPaths ( $ name ) ?? [ ] ; } return [ ] ; }
11379	public function putAction ( ) { if ( ! preg_match ( '/\/page\/(\w+[\-\w]*)\/text\/(..)\/(\w+)$/' , $ this -> name , $ matches ) ) { throw new InvalidParameterException ( "Invalid parameters" ) ; } list ( $ dummy , $ pageName , $ language , $ oldName ) = $ matches ; $ request = $ this -> environment -> getRequestHelper ( ) ; $ newName = $ request -> getIdentifierParam ( 'name' ) ; $ content = $ request -> getParam ( 'content' , '' ) ; try { $ pageTexts = $ this -> getTextModel ( $ pageName ) ; $ text = $ pageTexts -> modifyTextContainer ( $ oldName , $ newName , $ this -> filter ( $ content ) , $ language ) ; $ this -> environment -> sendJSONResult ( $ text ) ; } catch ( \ Exception $ e ) { throw new InvalidParameterException ( $ e -> getMessage ( ) ) ; } }
9997	protected function inferSeparator ( ) { if ( $ this -> delimiter !== null ) { return ; } $ potentialDelimiters = [ ',' , ';' , "\t" , '|' , ':' , ' ' ] ; $ counts = [ ] ; foreach ( $ potentialDelimiters as $ delimiter ) { $ counts [ $ delimiter ] = [ ] ; } $ numberLines = 0 ; while ( ( $ line = fgets ( $ this -> fileHandle ) ) !== false && ( ++ $ numberLines < 1000 ) ) { $ enclosure = preg_quote ( $ this -> enclosure , '/' ) ; $ line = preg_replace ( '/(' . $ enclosure . '.*' . $ enclosure . ')/U' , '' , $ line ) ; $ countLine = [ ] ; for ( $ i = strlen ( $ line ) - 1 ; $ i >= 0 ; -- $ i ) { $ char = $ line [ $ i ] ; if ( isset ( $ counts [ $ char ] ) ) { if ( ! isset ( $ countLine [ $ char ] ) ) { $ countLine [ $ char ] = 0 ; } ++ $ countLine [ $ char ] ; } } foreach ( $ potentialDelimiters as $ delimiter ) { $ counts [ $ delimiter ] [ ] = isset ( $ countLine [ $ delimiter ] ) ? $ countLine [ $ delimiter ] : 0 ; } } $ meanSquareDeviations = [ ] ; $ middleIdx = floor ( ( $ numberLines - 1 ) / 2 ) ; foreach ( $ potentialDelimiters as $ delimiter ) { $ series = $ counts [ $ delimiter ] ; sort ( $ series ) ; $ median = ( $ numberLines % 2 ) ? $ series [ $ middleIdx ] : ( $ series [ $ middleIdx ] + $ series [ $ middleIdx + 1 ] ) / 2 ; if ( $ median === 0 ) { continue ; } $ meanSquareDeviations [ $ delimiter ] = array_reduce ( $ series , function ( $ sum , $ value ) use ( $ median ) { return $ sum + pow ( $ value - $ median , 2 ) ; } ) / count ( $ series ) ; } $ min = INF ; foreach ( $ potentialDelimiters as $ delimiter ) { if ( ! isset ( $ meanSquareDeviations [ $ delimiter ] ) ) { continue ; } if ( $ meanSquareDeviations [ $ delimiter ] < $ min ) { $ min = $ meanSquareDeviations [ $ delimiter ] ; $ this -> delimiter = $ delimiter ; } } if ( $ this -> delimiter === null ) { $ this -> delimiter = reset ( $ potentialDelimiters ) ; } return $ this -> skipBOM ( ) ; }
135	public function ensureBinariesPresence ( PackageInterface $ package ) { try { $ installer = $ this -> getInstaller ( $ package -> getType ( ) ) ; } catch ( \ InvalidArgumentException $ e ) { return ; } if ( $ installer instanceof BinaryPresenceInterface ) { $ installer -> ensureBinariesPresence ( $ package ) ; } }
8500	protected function setSSLCurlOptions ( $ ch ) { curl_setopt ( $ ch , CURLOPT_SSL_VERIFYPEER , $ this -> _config [ 'SSL_VerifyPeer' ] ) ; curl_setopt ( $ ch , CURLOPT_SSL_VERIFYHOST , $ this -> _config [ 'SSL_VerifyHost' ] ) ; }
389	public function link ( $ attribute , $ options = [ ] ) { if ( ( $ direction = $ this -> getAttributeOrder ( $ attribute ) ) !== null ) { $ class = $ direction === SORT_DESC ? 'desc' : 'asc' ; if ( isset ( $ options [ 'class' ] ) ) { $ options [ 'class' ] .= ' ' . $ class ; } else { $ options [ 'class' ] = $ class ; } } $ url = $ this -> createUrl ( $ attribute ) ; $ options [ 'data-sort' ] = $ this -> createSortParam ( $ attribute ) ; if ( isset ( $ options [ 'label' ] ) ) { $ label = $ options [ 'label' ] ; unset ( $ options [ 'label' ] ) ; } else { if ( isset ( $ this -> attributes [ $ attribute ] [ 'label' ] ) ) { $ label = $ this -> attributes [ $ attribute ] [ 'label' ] ; } else { $ label = Inflector :: camel2words ( $ attribute ) ; } } return Html :: a ( $ label , $ url , $ options ) ; }
1981	public static function reset ( ) { $ session = System :: getContainer ( ) -> get ( 'session' ) ; if ( ! $ session -> isStarted ( ) ) { return ; } $ session -> getFlashBag ( ) -> clear ( ) ; }
278	private function notifyUnloaded ( $ fixtures ) { $ this -> stdout ( "\nFixtures were successfully unloaded from namespace: " , Console :: FG_YELLOW ) ; $ this -> stdout ( Yii :: getAlias ( $ this -> namespace ) . "\"\n\n" , Console :: FG_GREEN ) ; $ this -> outputList ( $ fixtures ) ; }
11078	public static function formatPhoneNumber ( $ phoneNumber , $ formatType = Tools :: PHONE_NUMBER_FORMAT_NUMBER ) { $ formatType = ( int ) $ formatType ; if ( $ formatType !== self :: PHONE_NUMBER_FORMAT_INTERNATIONAL && $ formatType !== self :: PHONE_NUMBER_FORMAT_INTERNATIONAL_NICE && $ formatType !== self :: PHONE_NUMBER_FORMAT_NUMBER && $ formatType !== self :: PHONE_NUMBER_FORMAT_NICE && $ formatType !== self :: PHONE_NUMBER_FORMAT_SMSTOOLS ) { return false ; } if ( ! Validate :: isPhoneNumber ( $ phoneNumber ) ) { return false ; } $ phoneNumber = self :: removeSpace ( $ phoneNumber ) ; $ phoneLen = \ strlen ( $ phoneNumber ) ; if ( $ phoneLen > 9 && 0 !== strpos ( $ phoneNumber , '+' ) ) { $ phoneNumber = '+' . $ phoneNumber ; $ phoneLen ++ ; } if ( $ phoneLen !== 9 && ! ( $ phoneLen >= 11 && $ phoneLen <= 13 && 0 === strpos ( $ phoneNumber , '+' ) ) ) { return false ; } $ international = ( $ phoneLen !== 9 ) ; switch ( $ formatType ) { case self :: PHONE_NUMBER_FORMAT_INTERNATIONAL_NICE : $ formattedPhone = preg_replace ( '/^(\+\d{1,3})(\d{3})(\d{3})(\d{3})$/' , '$1 $2 $3 $4' , $ international ? $ phoneNumber : '+420' . $ phoneNumber ) ; break ; case self :: PHONE_NUMBER_FORMAT_INTERNATIONAL : $ formattedPhone = $ international ? $ phoneNumber : '+420' . $ phoneNumber ; break ; case self :: PHONE_NUMBER_FORMAT_NICE : $ formattedPhone = preg_replace ( '/^(\+\d{1,3})(\d{3})(\d{3})(\d{3})$/' , '$2 $3 $4' , $ international ? $ phoneNumber : '+420' . $ phoneNumber ) ; break ; case self :: PHONE_NUMBER_FORMAT_NUMBER : $ formattedPhone = $ international ? substr ( $ phoneNumber , - 9 ) : $ phoneNumber ; break ; case self :: PHONE_NUMBER_FORMAT_SMSTOOLS : $ formattedPhone = $ international ? trim ( $ phoneNumber , '+' ) : '420' . $ phoneNumber ; break ; default : $ formattedPhone = false ; } return $ formattedPhone ; }
1762	public static function convertXlfToPhp ( $ strName , $ strLanguage , $ blnLoad = false ) { @ trigger_error ( 'Using System::convertXlfToPhp() has been deprecated and will no longer work in Contao 5.0. Use the Contao\CoreBundle\Config\Loader\XliffFileLoader instead.' , E_USER_DEPRECATED ) ; $ rootDir = self :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( strpos ( $ strName , $ rootDir . '/' ) === false ) { $ strName = $ rootDir . '/' . $ strName ; } $ loader = new XliffFileLoader ( static :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) , $ blnLoad ) ; return $ loader -> load ( $ strName , $ strLanguage ) ; }
1523	protected function doSearch ( StoreInterface $ store , FetchResources $ request ) { if ( $ result = $ this -> invoke ( 'searching' , $ request ) ) { return $ result ; } $ found = $ store -> queryRecords ( $ request -> getResourceType ( ) , $ request -> getParameters ( ) ) ; $ records = ( $ found instanceof PageInterface ) ? $ found -> getData ( ) : $ found ; if ( $ result = $ this -> invoke ( 'searched' , $ records , $ request ) ) { return $ result ; } return $ found ; }
6604	public function makeAccessToken ( Response $ response ) { parse_str ( $ response -> content ( ) , $ params ) ; $ this -> validateAccessTokenResponse ( $ params ) ; $ this -> credentials [ 'key' ] = $ params [ 'oauth_token' ] ; $ this -> credentials [ 'secret' ] = $ params [ 'oauth_token_secret' ] ; $ this -> credentials [ 'user_id' ] = $ params [ 'user_id' ] ; $ this -> credentials [ 'screen_name' ] = $ params [ 'screen_name' ] ; return $ this ; }
11400	public function fromData ( $ data ) { $ this -> fromdata = $ data ; $ resource = fopen ( 'php://memory' , 'r+' ) ; fwrite ( $ resource , $ data ) ; rewind ( $ resource ) ; $ this -> setResource ( $ resource ) ; return $ this ; }
1250	public function parse ( $ xml ) { $ parser = xml_parser_create_ns ( 'UTF-8' , '@' ) ; xml_parser_set_option ( $ parser , XML_OPTION_CASE_FOLDING , 0 ) ; xml_parser_set_option ( $ parser , XML_OPTION_SKIP_WHITE , 1 ) ; xml_set_object ( $ parser , $ this ) ; xml_set_element_handler ( $ parser , 'startElement' , 'endElement' ) ; xml_set_character_data_handler ( $ parser , 'cdata' ) ; xml_parse ( $ parser , $ xml , true ) ; xml_parser_free ( $ parser ) ; return $ this -> rootObject ; }
9737	public function setWidth ( $ pValue ) { if ( $ this -> resizeProportional && $ pValue != 0 ) { $ ratio = $ this -> height / ( $ this -> width != 0 ? $ this -> width : 1 ) ; $ this -> height = round ( $ ratio * $ pValue ) ; } $ this -> width = $ pValue ; return $ this ; }
12423	protected function getTranslations ( $ domain ) { if ( ! isset ( $ this -> translations [ $ domain ] ) ) { if ( ! isset ( $ this -> translationSources [ $ domain ] ) ) { $ msg = sprintf ( 'No translation directory for domain "%1$s" available' , $ domain ) ; throw new \ Aimeos \ MW \ Translation \ Exception ( $ msg ) ; } $ locale = $ this -> getLocale ( ) ; $ locations = array_reverse ( $ this -> getTranslationFileLocations ( $ this -> translationSources [ $ domain ] , $ locale ) ) ; foreach ( $ locations as $ location ) { $ translator = \ Zend \ I18n \ Translator \ MwTranslator :: factory ( $ this -> options ) ; $ translator -> addTranslationFile ( $ this -> adapter , $ location , $ domain , $ locale ) ; $ this -> translations [ $ domain ] [ $ location ] = $ translator ; } } return ( isset ( $ this -> translations [ $ domain ] ) ? $ this -> translations [ $ domain ] : [ ] ) ; }
5075	public function writeLog ( $ sLine ) { if ( ! is_string ( $ sLine ) ) { $ sLine = print_r ( $ sLine , true ) ; } $ sLine = ' [' . $ this -> sModuleName . '->' . $ this -> sMethod . '] ' . $ sLine ; $ this -> oLogger -> line ( $ sLine ) ; }
3821	private function getReferer ( Request $ request , $ table , $ encodeAmp = false ) { $ uri = $ this -> systemAdapter -> getReferer ( $ encodeAmp , $ table ) ; if ( ! preg_match ( '@^https?://@i' , $ uri ) ) { $ uri = $ request -> getBasePath ( ) . '/' . ltrim ( $ uri , '/' ) ; } return $ uri ; }
4383	protected function buildArgString ( $ args ) { $ numArgs = \ count ( $ args ) ; if ( $ numArgs == 1 && \ is_string ( $ args [ 0 ] ) ) { $ args [ 0 ] = \ strip_tags ( $ args [ 0 ] ) ; } foreach ( $ args as $ k => $ v ) { if ( $ k > 0 || ! \ is_string ( $ v ) ) { $ args [ $ k ] = $ this -> dump ( $ v ) ; } $ this -> valDepth = 0 ; } $ glue = ', ' ; $ glueAfterFirst = true ; if ( $ numArgs && \ is_string ( $ args [ 0 ] ) ) { if ( \ preg_match ( '/[=:] ?$/' , $ args [ 0 ] ) ) { $ glueAfterFirst = false ; } elseif ( \ count ( $ args ) == 2 ) { $ glue = ' = ' ; } } if ( ! $ glueAfterFirst ) { return $ args [ 0 ] . \ implode ( $ glue , \ array_slice ( $ args , 1 ) ) ; } else { return \ implode ( $ glue , $ args ) ; } }
8764	private function createUniqueFilename ( $ filename ) { $ full_size_dir = config ( 'dropzoner.upload-path' ) ; $ full_image_path = $ full_size_dir . $ filename . '.jpg' ; if ( \ File :: exists ( $ full_image_path ) ) { $ image_token = substr ( sha1 ( mt_rand ( ) ) , 0 , 5 ) ; return $ filename . '-' . $ image_token ; } return $ filename ; }
4672	public function setPaths ( array $ paths ) : object { foreach ( $ paths as $ path ) { if ( ! ( is_dir ( $ path ) && is_readable ( $ path ) ) ) { throw new Exception ( "Directory '$path' is not readable." ) ; } } $ this -> paths = $ paths ; return $ this ; }
4801	public function injectSpecialBindings ( string $ sql , array $ bindings ) : string { foreach ( self :: SPECIAL_BINDINGS as $ special ) { $ specialPlaceholder = ":" . $ special ; if ( ! array_key_exists ( $ special , $ bindings ) ) { continue ; } $ replacement = $ this -> escapeSpecialBinding ( $ bindings [ $ special ] , $ special ) ; $ sql = str_replace ( $ specialPlaceholder , $ replacement , $ sql ) ; unset ( $ bindings [ $ special ] ) ; } foreach ( $ bindings as $ key => $ value ) { if ( is_array ( $ value ) ) { $ inString = "" ; foreach ( $ value as $ i => $ innerValue ) { $ newKey = $ key . "__" . $ i ; $ keyParamString = ":$newKey" ; $ inString .= "$keyParamString, " ; } $ inString = rtrim ( $ inString , " ," ) ; $ sql = str_replace ( ":$key" , $ inString , $ sql ) ; } } return $ sql ; }
1047	public static function create ( array $ params , bool $ readonly = false ) : OperationParams { $ instance = new static ( ) ; $ params = array_change_key_case ( $ params , CASE_LOWER ) ; $ instance -> originalInput = $ params ; $ params += [ 'query' => null , 'queryid' => null , 'documentid' => null , 'id' => null , 'operationname' => null , 'variables' => null , 'extensions' => null , ] ; if ( $ params [ 'variables' ] === '' ) { $ params [ 'variables' ] = null ; } foreach ( [ 'extensions' , 'variables' ] as $ param ) { if ( ! is_string ( $ params [ $ param ] ) ) { continue ; } $ tmp = json_decode ( $ params [ $ param ] , true ) ; if ( json_last_error ( ) ) { continue ; } $ params [ $ param ] = $ tmp ; } $ instance -> query = $ params [ 'query' ] ; $ instance -> queryId = $ params [ 'queryid' ] ? : $ params [ 'documentid' ] ? : $ params [ 'id' ] ; $ instance -> operation = $ params [ 'operationname' ] ; $ instance -> variables = $ params [ 'variables' ] ; $ instance -> extensions = $ params [ 'extensions' ] ; $ instance -> readOnly = $ readonly ; if ( isset ( $ instance -> extensions [ 'persistedQuery' ] [ 'sha256Hash' ] ) && empty ( $ instance -> query ) && empty ( $ instance -> queryId ) ) { $ instance -> queryId = $ instance -> extensions [ 'persistedQuery' ] [ 'sha256Hash' ] ; } return $ instance ; }
7351	public function isPaid ( ) { return 0 <= Money :: compare ( $ this -> paidTotal , $ this -> grandTotal , $ this -> getCurrency ( ) -> getCode ( ) ) ; }
4193	protected function dumpProperties ( $ abs ) { $ label = \ count ( $ abs [ 'properties' ] ) ? 'properties' : 'no properties' ; if ( $ abs [ 'viaDebugInfo' ] ) { $ label .= ' <span class="text-muted">(via __debugInfo)</span>' ; } $ str = '<dt class="properties">' . $ label . '</dt>' . "\n" ; $ magicMethods = \ array_intersect ( array ( '__get' , '__set' ) , \ array_keys ( $ abs [ 'methods' ] ) ) ; $ str .= $ this -> magicMethodInfo ( $ magicMethods ) ; foreach ( $ abs [ 'properties' ] as $ k => $ info ) { $ vis = ( array ) $ info [ 'visibility' ] ; $ isPrivateAncestor = \ in_array ( 'private' , $ vis ) && $ info [ 'inheritedFrom' ] ; $ classes = \ array_keys ( \ array_filter ( array ( 'debuginfo-value' => $ info [ 'valueFrom' ] == 'debugInfo' , 'excluded' => $ info [ 'isExcluded' ] , 'forceShow' => $ info [ 'forceShow' ] , 'debug-value' => $ info [ 'valueFrom' ] == 'debug' , 'private-ancestor' => $ isPrivateAncestor , 'property' => true , \ implode ( ' ' , $ vis ) => $ info [ 'visibility' ] !== 'debug' , ) ) ) ; $ modifiers = $ vis ; if ( $ info [ 'isStatic' ] ) { $ modifiers [ ] = 'static' ; } $ str .= '<dd class="' . \ implode ( ' ' , $ classes ) . '">' . \ implode ( ' ' , \ array_map ( function ( $ modifier ) { return '<span class="t_modifier_' . $ modifier . '">' . $ modifier . '</span>' ; } , $ modifiers ) ) . ( $ isPrivateAncestor ? ' (<i>' . $ info [ 'inheritedFrom' ] . '</i>)' : '' ) . ( $ info [ 'type' ] ? ' <span class="t_type">' . $ info [ 'type' ] . '</span>' : '' ) . ' <span class="property-name"' . ' title="' . \ htmlspecialchars ( $ info [ 'desc' ] ) . '"' . '>' . $ k . '</span>' . ( $ info [ 'value' ] !== $ this -> debug -> abstracter -> UNDEFINED ? ' <span class="t_operator">=</span> ' . $ this -> debug -> output -> html -> dump ( $ info [ 'value' ] ) : '' ) . '</dd>' . "\n" ; } return $ str ; }
3065	protected function convertCatVariables ( array $ variables ) { $ runnerService = $ this -> getServiceLocator ( ) -> get ( QtiRunnerService :: SERVICE_ID ) ; $ convertedVariables = [ ] ; foreach ( $ variables as $ variable ) { switch ( $ variable -> getVariableType ( ) ) { case ResultVariable :: TRACE_VARIABLE : $ getVariableMethod = 'getTraceVariable' ; break ; case ResultVariable :: RESPONSE_VARIABLE : $ getVariableMethod = 'getResponseVariable' ; break ; case ResultVariable :: OUTCOME_VARIABLE : $ getVariableMethod = 'getOutcomeVariable' ; break ; case ResultVariable :: TEMPLATE_VARIABLE : default : $ getVariableMethod = null ; break ; } if ( is_null ( $ getVariableMethod ) ) { \ common_Logger :: w ( 'Variable of type ' . $ variable -> getVariableType ( ) . ' is not implemented in ' . __METHOD__ ) ; throw new \ common_exception_NotImplemented ( ) ; } $ convertedVariables [ ] = call_user_func_array ( array ( $ runnerService , $ getVariableMethod ) , array ( $ variable -> getId ( ) , $ variable -> getValue ( ) ) ) ; } return $ convertedVariables ; }
6654	public function getRequestToken ( $ settings , OAuthConsumerInterface $ consumer , OAuthTokenInterface $ token ) { $ url = $ settings [ 'auth_api_url' ] . $ settings [ 'request_token_uri' ] ; $ options = [ 'oauth_callback' => $ settings [ 'callback_url' ] ] ; $ headers = $ this -> headers ( $ settings , 'POST' , $ url , $ consumer , $ token , $ options ) ; $ request = [ 'url' => $ url , 'headers' => $ headers ] ; return $ this -> token -> makeRequestToken ( $ this -> http -> post ( $ request ) ) ; }
5846	public function syslog ( $ message , $ severity = \ TYPO3 \ CMS \ Core \ Messaging \ FlashMessage :: OK ) { switch ( $ severity ) { case \ TYPO3 \ CMS \ Core \ Messaging \ FlashMessage :: NOTICE : $ severity = GeneralUtility :: SYSLOG_SEVERITY_NOTICE ; break ; case \ TYPO3 \ CMS \ Core \ Messaging \ FlashMessage :: INFO : $ severity = GeneralUtility :: SYSLOG_SEVERITY_INFO ; break ; case \ TYPO3 \ CMS \ Core \ Messaging \ FlashMessage :: OK : $ severity = GeneralUtility :: SYSLOG_SEVERITY_INFO ; break ; case \ TYPO3 \ CMS \ Core \ Messaging \ FlashMessage :: WARNING : $ severity = GeneralUtility :: SYSLOG_SEVERITY_WARNING ; break ; case \ TYPO3 \ CMS \ Core \ Messaging \ FlashMessage :: ERROR : $ severity = GeneralUtility :: SYSLOG_SEVERITY_ERROR ; break ; } GeneralUtility :: sysLog ( $ message , 'image_autoresize' , $ severity ) ; }
11699	public function addService ( Service $ service ) { if ( array_key_exists ( $ service -> getName ( ) , $ this -> services ) ) { throw new KeyTakenInSetException ( $ service -> getName ( ) , 'services' ) ; } $ this -> services [ $ service -> getName ( ) ] = $ service ; return $ this ; }
9558	public function getUsage ( $ showRequiredFirst = true , $ customBinary = null , $ customScript = null ) { $ fullUsage = '' ; if ( $ customBinary == null ) { $ fullUsage = 'php ' ; } else { $ fullUsage = $ customBinary . ' ' ; } if ( $ customScript == null ) { $ fullUsage .= basename ( $ _SERVER [ 'SCRIPT_NAME' ] ) . ' ' ; } else { $ fullUsage .= $ customScript . ' ' ; } foreach ( $ this -> prefixes as $ prefix => $ parameters ) { if ( $ showRequiredFirst ) { usort ( $ parameters , function ( $ p1 , $ p2 ) { if ( $ p1 -> required && $ p2 -> required ) { return 0 ; } if ( $ p1 -> required && ! $ p2 -> required ) { return - 1 ; } if ( $ p2 -> required && ! $ p1 -> required ) { return 1 ; } } ) ; } foreach ( $ parameters as $ parameter ) { if ( $ parameter -> parent == null ) { $ fullUsage .= $ parameter -> getUsage ( ) . ' ' ; } } } return $ fullUsage ; }
1443	protected function replaceApplicationNamespace ( & $ stub ) { $ namespace = rtrim ( $ this -> laravel -> getNamespace ( ) , '\\' ) ; $ stub = str_replace ( 'DummyApplicationNamespace' , $ namespace , $ stub ) ; return $ this ; }
12822	protected function resolveOptions ( array $ options ) { if ( $ this -> optionsResolved ) { return ; } $ this -> optionsResolver -> clear ( ) ; $ this -> optionsResolver -> setRequired ( array ( 'blockname' , ) ) ; parent :: resolveOptions ( $ options ) ; $ this -> optionsResolved = true ; }
3623	public function temperatureInCelsius ( $ temperature , $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ temp_scale = $ this -> getDeviceTemperatureScale ( $ serial_number ) ; if ( $ temp_scale == 'F' ) { return ( $ temperature - 32 ) / 1.8 ; } return $ temperature ; }
6337	public function parse ( SaxHandlerInterface $ saxHandler , $ xmlDocument ) { $ xmlDocument = ( $ xmlDocument instanceof StreamInterface ) ? $ xmlDocument : $ this -> getDocumentStream ( $ xmlDocument ) ; return $ saxHandler -> parse ( $ xmlDocument ) ; }
7859	private function registerWorkflowRunnersHook ( ) { $ this -> app -> afterResolving ( function ( WorkflowRunner $ runner , $ app ) { $ runner -> setWorkflow ( $ app [ 'cerbero.workflow' ] ) ; } ) ; }
10600	public function returnUrl ( ) { $ return = '' ; $ return .= empty ( $ this -> _urlParts [ 'scheme' ] ) ? '' : $ this -> _urlParts [ 'scheme' ] . '://' ; $ return .= empty ( $ this -> _urlParts [ 'user' ] ) ? '' : $ this -> _urlParts [ 'user' ] ; $ return .= empty ( $ this -> _urlParts [ 'pass' ] ) || empty ( $ this -> _urlParts [ 'user' ] ) ? '' : ':' . $ this -> _urlParts [ 'pass' ] ; $ return .= empty ( $ this -> _urlParts [ 'user' ] ) ? '' : '@' ; $ return .= empty ( $ this -> _urlParts [ 'host' ] ) ? '' : $ this -> _urlParts [ 'host' ] ; $ return .= empty ( $ this -> _urlParts [ 'port' ] ) ? '' : ':' . $ this -> _urlParts [ 'port' ] ; $ return .= empty ( $ this -> _urlParts [ 'path' ] ) ? '' : '/' . ltrim ( $ this -> _urlParts [ 'path' ] , '/' ) ; $ return .= empty ( $ this -> _urlParts [ 'query' ] ) ? '' : '?' . $ this -> _urlParts [ 'query' ] ; $ return .= empty ( $ this -> _urlParts [ 'fragment' ] ) ? '' : '#' . $ this -> _urlParts [ 'fragment' ] ; return $ return ; }
10191	public function validate ( ) { foreach ( func_get_args ( ) as $ key ) { $ value = $ this -> parameters -> get ( $ key ) ; if ( ! isset ( $ value ) ) { throw new InvalidRequestException ( "The $key parameter is required" ) ; } } }
2170	private function setPassword ( ) : Response { $ request = $ this -> container -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; if ( null === $ request ) { throw new \ RuntimeException ( 'The request stack did not contain a request' ) ; } if ( 'tl_password' !== $ request -> request -> get ( 'FORM_SUBMIT' ) ) { return $ this -> render ( 'password.html.twig' ) ; } $ password = $ request -> request -> get ( 'password' ) ; $ confirmation = $ request -> request -> get ( 'confirmation' ) ; if ( $ password !== $ confirmation ) { return $ this -> render ( 'password.html.twig' , [ 'error' => $ this -> trans ( 'password_confirmation_mismatch' ) , ] ) ; } $ installTool = $ this -> container -> get ( 'contao.install_tool' ) ; $ minlength = $ installTool -> getConfig ( 'minPasswordLength' ) ; if ( Utf8 :: strlen ( $ password ) < $ minlength ) { return $ this -> render ( 'password.html.twig' , [ 'error' => sprintf ( $ this -> trans ( 'password_too_short' ) , $ minlength ) , ] ) ; } $ installTool -> persistConfig ( 'installPassword' , password_hash ( $ password , PASSWORD_DEFAULT ) ) ; $ this -> container -> get ( 'contao.install_tool_user' ) -> setAuthenticated ( true ) ; return $ this -> getRedirectResponse ( ) ; }
4709	public function initialize ( Text $ text ) { $ text -> replaceString ( "\r\n" , "\n" ) ; $ text -> replaceString ( "\r" , "\n" ) ; $ text -> append ( "\n\n" ) ; $ this -> markdown -> emit ( 'detab' , array ( $ text ) ) ; $ text -> replace ( '/^[ \t]+$/m' , '' ) ; }
7290	static public function isValidMode ( $ mode , $ throw = true ) { if ( in_array ( $ mode , static :: getModes ( ) , true ) ) { return true ; } if ( $ throw ) { throw new InvalidArgumentException ( 'Invalid adjustment mode.' ) ; } return false ; }
4348	private function getConfigKeys ( ) { if ( isset ( $ this -> configKeys ) ) { return $ this -> configKeys ; } $ this -> configKeys = array ( 'debug' => array ( ) , 'abstracter' => array ( 'cacheMethods' , 'collectConstants' , 'collectMethods' , 'objectsExclude' , 'objectSort' , 'useDebugInfo' , ) , 'errorEmailer' => array ( 'emailBacktraceDumper' , 'emailMask' , 'emailMin' , 'emailThrottledSummary' , 'emailThrottleFile' , 'emailThrottleRead' , 'emailThrottleWrite' , 'emailTraceMask' , ) , 'errorHandler' => \ array_keys ( $ this -> debug -> errorHandler -> getCfg ( ) ) , 'output' => array ( 'addBR' , 'css' , 'displayListKeys' , 'filepathCss' , 'filepathScript' , 'onOutput' , 'outputAs' , 'outputAsDefaultNonHtml' , 'outputConstants' , 'outputCss' , 'outputHeaders' , 'outputMethodDescription' , 'outputMethods' , 'outputScript' , ) , ) ; return $ this -> configKeys ; }
12483	private function plainBonus ( $ bonus ) { $ result = [ ] ; foreach ( $ bonus as $ item ) { $ bonusData = $ item -> getEntries ( ) ; foreach ( $ bonusData as $ entry ) { $ bonus = $ entry -> getValue ( ) ; if ( $ bonus > Cfg :: DEF_ZERO ) { $ result [ ] = $ entry ; } } } return $ result ; }
10694	protected function startOrRestart ( ) { if ( session_status ( ) == PHP_SESSION_ACTIVE ) return ; if ( $ this -> SessionDir ) { if ( ! file_exists ( $ this -> SessionDir ) ) { mkdir ( $ this -> SessionDir , 0777 , true ) ; } session_save_path ( $ this -> SessionDir ) ; } session_start ( ) ; $ FingerPrint = "" ; if ( $ this -> IpAddress ) { if ( ! $ this -> IpAddress -> isValid ( ) ) { session_unset ( ) ; session_destroy ( ) ; throw new \ Exception ( "Cannot start session. Reason: Invalid IP " . $ this -> IpAddress -> getValue ( ) . " detected" , 403 ) ; } else $ FingerPrint = $ this -> IpAddress -> getValue ( ) ; } if ( $ this -> Browser ) { if ( ! $ this -> Browser -> isKnownBrowser ( ) ) { session_unset ( ) ; session_destroy ( ) ; throw new \ Exception ( "Cannot start session. Reason: Invalid Browser " . $ this -> Browser -> getSignature ( ) . " detected." , 403 ) ; } else $ FingerPrint .= $ this -> Browser -> getSignature ( ) ; } $ currFp = md5 ( $ FingerPrint ) ; $ prevFp = isset ( $ _SESSION [ "FingerPrint" ] ) ? $ _SESSION [ "FingerPrint" ] : null ; if ( $ prevFp ) { if ( $ prevFp != $ currFp ) { session_unset ( ) ; session_destroy ( ) ; throw new \ Exception ( "Cannot start session. Reason: IP changed. Current is $currFp, previous was: $prevFp" , Interfaces \ HttpResponder :: EXIT_CODE_UNAUTHORIZED ) ; } } $ currTime = time ( ) ; $ prevTime = isset ( $ _SESSION [ "LastSessionStart" ] ) ? $ _SESSION [ "LastSessionStart" ] : null ; $ timeOutSecs = isset ( $ _SESSION [ "TimeOutSecs" ] ) ? $ _SESSION [ "TimeOutSecs" ] : null ; if ( $ prevTime && $ timeOutSecs ) { if ( $ prevTime + $ timeOutSecs < $ currTime ) { session_unset ( ) ; session_destroy ( ) ; throw new \ Exception ( "Session timeout" , Interfaces \ HttpResponder :: EXIT_CODE_UNAUTHORIZED ) ; } } $ _SESSION [ "FingerPrint" ] = $ currFp ; $ _SESSION [ "LastSessionStart" ] = $ currTime ; }
5764	public function routeIndexResetFilter ( Request $ request , Response $ response , $ args ) { return $ this -> indexViewObjects ( $ response , true ) ; }
1478	public function delete ( $ resourceType , $ id , array $ queryParams = [ ] ) { return $ this -> resource ( RouteName :: delete ( $ resourceType ) , $ id , $ queryParams ) ; }
1516	public function readRelatedResource ( StoreInterface $ store , FetchRelated $ request ) { $ record = $ request -> getRecord ( ) ; $ result = $ this -> beforeReadingRelationship ( $ record , $ request ) ; if ( $ this -> isResponse ( $ result ) ) { return $ result ; } $ related = $ store -> queryRelated ( $ record , $ request -> getRelationshipName ( ) , $ request -> getParameters ( ) ) ; $ records = ( $ related instanceof PageInterface ) ? $ related -> getData ( ) : $ related ; $ result = $ this -> afterReadingRelationship ( $ record , $ records , $ request ) ; if ( $ this -> isInvokedResult ( $ result ) ) { return $ result ; } return $ this -> reply ( ) -> content ( $ related ) ; }
6817	protected function buildAdjustments ( $ type , Model \ AdjustableInterface $ adjustable , array $ data , $ persistence = false ) { Model \ AdjustmentTypes :: isValidType ( $ type ) ; $ change = false ; $ newAdjustments = [ ] ; foreach ( $ data as $ d ) { $ adjustment = $ this -> saleFactory -> createAdjustmentFor ( $ adjustable ) ; $ adjustment -> setType ( $ type ) -> setMode ( $ d -> getMode ( ) ) -> setDesignation ( $ d -> getDesignation ( ) ) -> setAmount ( $ d -> getAmount ( ) ) -> setImmutable ( $ d -> isImmutable ( ) ) ; $ newAdjustments [ ] = $ adjustment ; } $ oldAdjustments = $ adjustable -> getAdjustments ( $ type ) ; foreach ( $ oldAdjustments as $ oldAdjustment ) { if ( ! $ oldAdjustment -> isImmutable ( ) ) { continue ; } foreach ( $ newAdjustments as $ index => $ newAdjustment ) { if ( $ oldAdjustment -> equals ( $ newAdjustment ) ) { unset ( $ newAdjustments [ $ index ] ) ; continue 2 ; } } $ adjustable -> removeAdjustment ( $ oldAdjustment ) ; if ( $ persistence ) { $ this -> persistenceHelper -> remove ( $ oldAdjustment , true ) ; } $ change = true ; } foreach ( $ newAdjustments as $ newAdjustment ) { $ adjustable -> addAdjustment ( $ newAdjustment ) ; if ( $ persistence ) { $ this -> persistenceHelper -> persistAndRecompute ( $ newAdjustment , true ) ; } $ change = true ; } return $ change ; }
4911	protected function injectComponents ( array $ pages , $ routeMatch = null , $ router = null , $ request = null ) { if ( $ routeMatch ) { $ routeName = $ routeMatch -> getMatchedRouteName ( ) ; foreach ( $ pages as & $ page ) { if ( isset ( $ page [ 'active_on' ] ) && in_array ( $ routeName , ( array ) $ page [ 'active_on' ] ) ) { $ page [ 'active' ] = true ; } } } return parent :: injectComponents ( $ pages , $ routeMatch , $ router , $ request ) ; }
1093	protected function getFreshInstance ( ) { if ( $ this -> areSoftDeletesEnabled ( ) ) return static :: withTrashed ( ) -> find ( $ this -> getKey ( ) ) ; return static :: find ( $ this -> getKey ( ) ) ; }
11292	protected function _getAttributeDataWhenUnset ( $ attributeName , $ query = false , $ loadMap = false , $ record = false ) { if ( $ attributeName != $ this -> getPrimaryKey ( ) ) { if ( $ this -> _isRelation ( $ attributeName ) && ! isset ( $ this -> model_dynamicOff ) ) { $ this -> $ attributeName = $ this -> _getRelation ( $ attributeName , $ query , $ loadMap , $ record ) ; } else { $ this -> $ attributeName = $ this -> _fetchData ( $ attributeName ) ; } } else { $ this -> $ attributeName = null ; } $ this -> beforeGet ( $ attributeName ) ; $ returnValue = $ this -> model_data [ $ attributeName ] ; $ this -> afterGet ( $ attributeName , $ returnValue ) ; return $ returnValue ; }
7308	public static function jd ( $ jd , TimeScale $ timescale = null ) { $ t = [ ] ; IAU :: D2dtf ( $ timescale , 14 , $ jd , 0 , $ y , $ m , $ d , $ t ) ; return new static ( $ y , $ m , $ d , $ t [ 0 ] , $ t [ 1 ] , $ t [ 2 ] , null , $ timescale ) ; }
3119	public function fromArray ( $ data ) { $ this -> points = [ ] ; if ( is_array ( $ data ) ) { foreach ( $ data as $ dataPoint ) { $ point = new TimePoint ( ) ; $ point -> fromArray ( $ dataPoint ) ; $ this -> points [ ] = $ point ; } } }
4228	protected function buildError ( $ errType , $ errMsg , $ file , $ line , $ vars ) { foreach ( $ this -> errCategories as $ category => $ errTypes ) { if ( \ in_array ( $ errType , $ errTypes ) ) { break ; } } $ errorValues = array ( 'type' => $ errType , 'typeStr' => $ this -> errTypes [ $ errType ] , 'category' => $ category , 'message' => $ errMsg , 'file' => $ file , 'line' => $ line , 'vars' => $ vars , 'backtrace' => array ( ) , 'continueToNormal' => false , 'continueToPrevHandler' => $ this -> cfg [ 'continueToPrevHandler' ] && $ this -> prevErrorHandler , 'exception' => $ this -> uncaughtException , 'hash' => null , 'isFirstOccur' => true , 'isHtml' => \ filter_var ( \ ini_get ( 'html_errors' ) , FILTER_VALIDATE_BOOLEAN ) && ! \ in_array ( $ errType , $ this -> userErrors ) && ! $ this -> uncaughtException , 'isSuppressed' => false , ) ; $ hash = $ this -> errorHash ( $ errorValues ) ; $ isFirstOccur = ! isset ( $ this -> data [ 'errors' ] [ $ hash ] ) ; if ( $ errorValues [ 'isHtml' ] ) { $ errorValues [ 'message' ] = \ str_replace ( '<a ' , '<a target="phpRef" ' , $ errorValues [ 'message' ] ) ; } $ isSuppressed = ! $ isFirstOccur && ! $ this -> data [ 'errors' ] [ $ hash ] [ 'isSuppressed' ] ? false : \ error_reporting ( ) === 0 ; if ( ! empty ( $ this -> data [ 'errorCaller' ] ) ) { $ errorValues [ 'file' ] = $ this -> data [ 'errorCaller' ] [ 'file' ] ; $ errorValues [ 'line' ] = $ this -> data [ 'errorCaller' ] [ 'line' ] ; } if ( \ in_array ( $ errType , array ( E_ERROR , E_USER_ERROR ) ) ) { $ errorValues [ 'backtrace' ] = $ this -> backtrace ( $ errorValues ) ; } $ errorValues = \ array_merge ( $ errorValues , array ( 'continueToNormal' => ! $ isSuppressed && $ isFirstOccur , 'hash' => $ hash , 'isFirstOccur' => $ isFirstOccur , 'isSuppressed' => $ isSuppressed , ) ) ; return new Event ( $ this , $ errorValues ) ; }
10283	public static function buildRange ( array $ pRange ) { if ( empty ( $ pRange ) || ! is_array ( $ pRange [ 0 ] ) ) { throw new Exception ( 'Range does not contain any information' ) ; } $ imploded = [ ] ; $ counter = count ( $ pRange ) ; for ( $ i = 0 ; $ i < $ counter ; ++ $ i ) { $ pRange [ $ i ] = implode ( ':' , $ pRange [ $ i ] ) ; } $ imploded = implode ( ',' , $ pRange ) ; return $ imploded ; }
7277	public function time ( $ timestamp = false ) { return $ timestamp ? ( new DateTime ( $ this -> time ) ) -> getTimestamp ( ) : $ this -> time ; }
6007	public static function fromHex ( $ hex ) { if ( strlen ( $ hex ) != 2 ) { throw new Ts3Exception ( "given parameter '" . $ hex . "' is not a valid hexadecimal number" ) ; } return new self ( chr ( hexdec ( $ hex ) ) ) ; }
8133	public function setSourceContext ( Twig_Source $ source = null ) { if ( null === $ source ) { $ this -> sourceCode = $ this -> filename = $ this -> sourcePath = null ; } else { $ this -> sourceCode = $ source -> getCode ( ) ; $ this -> filename = $ source -> getName ( ) ; $ this -> sourcePath = $ source -> getPath ( ) ; } $ this -> updateRepr ( ) ; }
12464	public function showAction ( $ id ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ entity = $ em -> getRepository ( 'ChillCustomFieldsBundle:CustomFieldsGroup' ) -> find ( $ id ) ; if ( ! $ entity ) { throw $ this -> createNotFoundException ( 'Unable to find CustomFieldsGroup entity.' ) ; } $ options = $ this -> getOptionsAvailable ( $ entity -> getEntity ( ) ) ; return $ this -> render ( 'ChillCustomFieldsBundle:CustomFieldsGroup:show.html.twig' , array ( 'entity' => $ entity , 'create_field_form' => $ this -> createCreateFieldForm ( $ entity ) -> createView ( ) , 'options' => $ options ) ) ; }
456	public function dropForeignKey ( $ name , $ table ) { return 'ALTER TABLE ' . $ this -> db -> quoteTableName ( $ table ) . ' DROP CONSTRAINT ' . $ this -> db -> quoteColumnName ( $ name ) ; }
5267	public function esc_value ( $ value ) { global $ wpdb ; if ( is_int ( $ value ) ) { return $ wpdb -> prepare ( '%d' , $ value ) ; } if ( is_float ( $ value ) ) { return $ wpdb -> prepare ( '%f' , $ value ) ; } if ( is_string ( $ value ) ) { return 'null' === $ value ? $ value : $ wpdb -> prepare ( '%s' , $ value ) ; } return $ value ; }
3094	public function getAvailableActions ( ) { return is_array ( $ this -> getOption ( self :: ACTIONS_OPTION ) ) ? $ this -> getOption ( self :: ACTIONS_OPTION ) : [ ] ; }
9843	public function createSignedJsonRequest ( string $ method , string $ uri , array $ arrayToJsonify , SigningSecretKey $ key , array $ headers = [ ] ) : RequestInterface { if ( empty ( $ headers [ 'Content-Type' ] ) ) { $ headers [ 'Content-Type' ] = 'application/json' ; } $ body = \ json_encode ( $ arrayToJsonify , JSON_PRETTY_PRINT ) ; if ( ! \ is_string ( $ body ) ) { throw new InvalidMessageException ( 'Cannot JSON-encode this message.' ) ; } return $ this -> createSignedRequest ( $ method , $ uri , $ body , $ key , $ headers ) ; }
1685	public function checkAdminDisable ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ varValue == 1 && $ this -> User -> id == $ dc -> id ) { $ varValue = '' ; } return $ varValue ; }
11864	public function save ( string $ sessionIdentifier , string $ sessionData ) : void { self :: $ files [ $ sessionIdentifier ] = [ 'data' => $ sessionData , 'time' => microtime ( true ) ] ; }
7418	protected function setJSONContent ( array $ content ) { if ( $ this -> deleteJsonKeys ) { $ content = $ this -> deleteArrayKeys ( $ content ) ; } $ content = json_encode ( $ content , JSON_UNESCAPED_UNICODE ) ; $ this -> response -> setContentTypeJson ( ) ; $ this -> response -> setContent ( $ content ) ; }
6263	public function nextkey ( ) { if ( $ this -> keys === null ) { return $ this -> firstkey ( ) ; } return empty ( $ this -> keys ) ? false : array_shift ( $ this -> keys ) ; }
5089	public function queryMapRow ( $ key = 0 , $ removeColumnFromRow = false ) { $ fetchMode = $ this -> resolveFetchMode ( is_string ( $ key ) ) ; $ result = $ this -> execute ( ) ; $ map = [ ] ; try { while ( $ row = $ result -> fetch ( $ fetchMode ) ) { if ( ! isset ( $ row [ $ key ] ) ) throw new MySqlException ( "Key '$key' column not found in the query result: " . implode ( array_keys ( $ row ) ) ) ; if ( $ removeColumnFromRow ) { $ map [ $ row [ $ key ] ] = $ row ; unset ( $ map [ $ row [ $ key ] ] [ $ key ] ) ; } else { $ map [ $ row [ $ key ] ] = $ row ; } } } finally { $ result -> closeCursor ( ) ; } return $ map ; }
7250	protected function validateDeliveryAddress ( SaleInterface $ sale , Constraint $ constraint ) { if ( ! $ sale -> isSameAddress ( ) && null === $ sale -> getDeliveryAddress ( ) ) { $ this -> context -> buildViolation ( $ constraint -> delivery_address_is_required ) -> atPath ( 'deliveryAddress' ) -> addViolation ( ) ; } elseif ( $ sale -> isSameAddress ( ) && null !== $ sale -> getDeliveryAddress ( ) ) { $ this -> context -> buildViolation ( $ constraint -> delivery_address_should_be_null ) -> atPath ( 'deliveryAddress' ) -> addViolation ( ) ; } }
2234	public function showDeletedRecords ( $ data , $ row ) { $ arrData = Contao \ StringUtil :: deserialize ( $ row [ 'data' ] ) ; foreach ( $ arrData as $ strTable => $ arrTableData ) { Contao \ System :: loadLanguageFile ( $ strTable ) ; Contao \ Controller :: loadDataContainer ( $ strTable ) ; foreach ( $ arrTableData as $ arrRow ) { $ arrBuffer = array ( ) ; foreach ( $ arrRow as $ i => $ v ) { if ( \ is_array ( Contao \ StringUtil :: deserialize ( $ v ) ) ) { continue ; } if ( isset ( $ GLOBALS [ 'TL_DCA' ] [ $ strTable ] [ 'fields' ] [ $ i ] [ 'label' ] ) ) { $ label = \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ strTable ] [ 'fields' ] [ $ i ] [ 'label' ] ) ? $ GLOBALS [ 'TL_DCA' ] [ $ strTable ] [ 'fields' ] [ $ i ] [ 'label' ] [ 0 ] : $ GLOBALS [ 'TL_DCA' ] [ $ strTable ] [ 'fields' ] [ $ i ] [ 'label' ] ; } else { $ label = \ is_array ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ i ] ) ? $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ i ] [ 0 ] : $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ i ] ; } if ( ! $ label ) { $ label = $ i ; } $ arrBuffer [ $ label ] = $ v ; } $ data [ $ strTable ] [ ] = $ arrBuffer ; } } return $ data ; }
8061	protected function runWorkerProcess ( WorkerInterface $ worker , SimpleSocket $ simpleSocket , $ i ) { $ replacements = array ( 'basename' => basename ( $ _SERVER [ 'PHP_SELF' ] ) , 'fullname' => $ _SERVER [ 'PHP_SELF' ] , 'class' => get_class ( $ worker ) , 'i' => $ i , 'state' => 'free' ) ; ProcessDetails :: setProcessTitle ( $ this -> childProcessTitleFormat , $ replacements ) ; $ this -> worker -> onProcessCreate ( $ this -> semaphore ) ; while ( TRUE ) { $ output = array ( 'pid' => getmypid ( ) ) ; try { $ replacements [ 'state' ] = 'free' ; ProcessDetails :: setProcessTitle ( $ this -> childProcessTitleFormat , $ replacements ) ; $ cmd = $ simpleSocket -> receive ( ) ; if ( ! isset ( $ cmd [ 'cmd' ] ) ) { break ; } $ replacements [ 'state' ] = 'busy' ; ProcessDetails :: setProcessTitle ( $ this -> childProcessTitleFormat , $ replacements ) ; if ( $ cmd [ 'cmd' ] == 'run' ) { try { $ output [ 'data' ] = $ this -> worker -> run ( $ cmd [ 'data' ] ) ; } catch ( \ Exception $ e ) { $ output [ 'workerException' ] = array ( 'class' => get_class ( $ e ) , 'message' => $ e -> getMessage ( ) , 'trace' => $ e -> getTraceAsString ( ) ) ; } $ simpleSocket -> send ( $ output ) ; } elseif ( $ cmd [ 'cmd' ] == 'exit' ) { break ; } } catch ( SimpleSocketException $ e ) { break ; } catch ( \ Exception $ e ) { $ output [ 'poolException' ] = array ( 'class' => get_class ( $ e ) , 'message' => $ e -> getMessage ( ) , 'trace' => $ e -> getTraceAsString ( ) ) ; $ simpleSocket -> send ( $ output ) ; } } $ this -> worker -> onProcessDestroy ( ) ; $ this -> exitPhp ( 0 ) ; }
2909	public function getModuleVersion ( ) { $ moduleConfig = $ this -> getConfig ( ) -> getModuleConfig ( $ this -> getModuleName ( ) ) ; return ( string ) $ moduleConfig -> version ; }
8439	protected static function completeFilesCountsAndEditorLinks ( ) { if ( ! static :: $ files ) { $ rawList = get_included_files ( ) ; $ list = [ ] ; $ docRoot = str_replace ( '\\' , '/' , $ _SERVER [ 'DOCUMENT_ROOT' ] ) ; $ docRootLength = mb_strlen ( $ docRoot ) ; $ tracyFileDetectionSubstr = '/tracy' ; foreach ( $ rawList as & $ file ) { $ file = str_replace ( '\\' , '/' , $ file ) ; $ text = mb_substr ( $ file , $ docRootLength ) ; $ tracyFile = mb_stripos ( $ text , $ tracyFileDetectionSubstr ) !== FALSE ; if ( ! $ tracyFile ) static :: $ appFilesCount += 1 ; static :: $ allFilesCount += 1 ; $ href = \ Tracy \ Helpers :: editorUri ( $ file , 1 ) ; $ list [ ] = '<a ' . ( $ tracyFile ? 'class="tracy" ' : '' ) . 'href="' . $ href . '"><nobr>' . $ text . '</nobr></a><br />' ; } static :: $ files = & $ list ; } }
4057	private function convertAttribute ( array $ property , $ condition , array & $ legend ) { if ( ! isset ( $ property [ 'col_name' ] ) ) { return ; } $ legend [ 'properties' ] [ ] = [ 'name' => $ property [ 'col_name' ] , 'condition' => $ condition ( $ property ) ] ; }
7648	public function stream_close ( ) { @ fclose ( $ this -> temporaryFileHandle ) ; if ( $ this -> writeMode ) { $ containerExists = $ this -> getStorageClient ( $ this -> fileName ) -> containerExists ( $ this -> getContainerName ( $ this -> fileName ) ) ; if ( ! $ containerExists ) { $ this -> getStorageClient ( $ this -> fileName ) -> createContainer ( $ this -> getContainerName ( $ this -> fileName ) ) ; } try { $ this -> getStorageClient ( $ this -> fileName ) -> putBlob ( $ this -> getContainerName ( $ this -> fileName ) , $ this -> getFileName ( $ this -> fileName ) , $ this -> temporaryFileName ) ; } catch ( BlobException $ ex ) { @ unlink ( $ this -> temporaryFileName ) ; unset ( $ this -> storageClient ) ; throw $ ex ; } } @ unlink ( $ this -> temporaryFileName ) ; unset ( $ this -> storageClient ) ; }
11969	public static function SetAuthClass ( $ authClass ) { $ toolClass = \ MvcCore \ Application :: GetInstance ( ) -> GetToolClass ( ) ; if ( $ toolClass :: CheckClassInterface ( $ authClass , 'MvcCore\Ext\Auths\Basics\IAuth' , TRUE , TRUE ) ) self :: $ authClass = $ authClass ; }
16	public static function getContentHash ( $ composerFileContents ) { $ content = json_decode ( $ composerFileContents , true ) ; $ relevantKeys = array ( 'name' , 'version' , 'require' , 'require-dev' , 'conflict' , 'replace' , 'provide' , 'minimum-stability' , 'prefer-stable' , 'repositories' , 'extra' , ) ; $ relevantContent = array ( ) ; foreach ( array_intersect ( $ relevantKeys , array_keys ( $ content ) ) as $ key ) { $ relevantContent [ $ key ] = $ content [ $ key ] ; } if ( isset ( $ content [ 'config' ] [ 'platform' ] ) ) { $ relevantContent [ 'config' ] [ 'platform' ] = $ content [ 'config' ] [ 'platform' ] ; } ksort ( $ relevantContent ) ; return md5 ( json_encode ( $ relevantContent ) ) ; }
10840	protected function getRaw ( $ Key ) { $ CacheFile = $ this -> getCacheFile ( $ Key ) ; if ( ! file_exists ( $ CacheFile ) ) { return false ; } return unserialize ( file_get_contents ( $ CacheFile ) ) ; }
10408	public function addDocumentParameter ( $ field , $ value ) { $ this -> documentParamCache [ md5 ( $ value . $ field ) ] = [ $ field , $ value ] ; }
10491	public function add ( $ value ) { $ value = Cast :: Float ( $ value ) ; if ( $ this -> value === null ) { return new FloatType ( $ this -> value ) ; } return new FloatType ( $ this -> value + $ value ) ; }
5026	protected function getCustomizationOptions ( ContainerInterface $ container , $ requestedName , array $ options = null ) { if ( ! static :: OPTIONS_NAME ) { throw new \ RuntimeException ( 'The class constants "OPTIONS_NAME" must be non empty.' ) ; } return $ container -> get ( static :: OPTIONS_NAME ) ; }
8206	protected function buryJob ( $ job , $ priority = null ) { if ( is_null ( $ priority ) ) { $ priority = Pheanstalk :: DEFAULT_PRIORITY ; } $ this -> getPheanstalk ( ) -> bury ( $ job , $ priority ) ; }
1320	private function curlOptions ( ) { $ options = [ CURLOPT_CONNECTTIMEOUT => $ this -> connectionTimeout , CURLOPT_HEADER => true , CURLOPT_RETURNTRANSFER => true , CURLOPT_SSL_VERIFYHOST => 2 , CURLOPT_SSL_VERIFYPEER => true , CURLOPT_TIMEOUT => $ this -> timeout , CURLOPT_USERAGENT => $ this -> userAgent , ] ; if ( $ this -> useCAFile ( ) ) { $ options [ CURLOPT_CAINFO ] = __DIR__ . DIRECTORY_SEPARATOR . 'cacert.pem' ; } if ( $ this -> gzipEncoding ) { $ options [ CURLOPT_ENCODING ] = 'gzip' ; } if ( ! empty ( $ this -> proxy ) ) { $ options [ CURLOPT_PROXY ] = $ this -> proxy [ 'CURLOPT_PROXY' ] ; $ options [ CURLOPT_PROXYUSERPWD ] = $ this -> proxy [ 'CURLOPT_PROXYUSERPWD' ] ; $ options [ CURLOPT_PROXYPORT ] = $ this -> proxy [ 'CURLOPT_PROXYPORT' ] ; $ options [ CURLOPT_PROXYAUTH ] = CURLAUTH_BASIC ; $ options [ CURLOPT_PROXYTYPE ] = CURLPROXY_HTTP ; } return $ options ; }
11743	public function remove ( $ pageName ) { if ( $ pageName == $ this -> configurationHandler -> homepage ( ) ) { throw new RuntimeException ( "exception_homepage_cannot_be_removed" ) ; } $ pageDir = $ this -> pagesDir . '/' . $ pageName ; Dispatcher :: dispatch ( PageCollectionEvents :: PAGE_COLLECTION_REMOVING , new PageCollectionRemovingEvent ( $ this -> username , $ pageDir ) ) ; $ filesystem = new Filesystem ( ) ; if ( file_exists ( $ pageDir . '/page.json' ) ) { $ filesystem -> mirror ( $ pageDir , $ this -> pagesRemovedDir . '/' . $ pageName . "-" . date ( "Y-m-d-H.i.s" ) ) ; } $ filesystem -> remove ( $ pageDir ) ; Dispatcher :: dispatch ( PageCollectionEvents :: PAGE_COLLECTION_REMOVED , new PageCollectionRemovedEvent ( $ this -> username , $ pageDir ) ) ; DataLogger :: log ( sprintf ( 'Page "%s" was successfully removed from website' , $ pageName ) ) ; }
5033	public function extract ( $ value ) { if ( ! $ value instanceof FileInterface ) { return null ; } $ tmp = tempnam ( sys_get_temp_dir ( ) , 'yk-copy.' ) ; $ out = fopen ( $ tmp , 'w' ) ; $ in = $ value -> getResource ( ) ; register_shutdown_function ( function ( $ filename ) { @ unlink ( $ filename ) ; } , $ tmp ) ; while ( ! feof ( $ in ) ) { fputs ( $ out , fgets ( $ in , 1024 ) ) ; } fclose ( $ in ) ; fclose ( $ out ) ; $ return = [ "file" => $ tmp ] ; foreach ( [ 'user' , 'name' , 'type' ] as $ key ) { $ v = $ value -> { "get$key" } ( ) ; if ( $ v ) { $ return [ $ key ] = $ v ; } } return $ return ; }
5889	public function getViewer ( IViewer $ viewer ) { $ html = $ viewer -> fetchObject ( $ this ) ; $ iterator = new \ RecursiveIteratorIterator ( $ this , \ RecursiveIteratorIterator :: SELF_FIRST ) ; foreach ( $ iterator as $ node ) { $ siblings = array ( ) ; for ( $ level = 0 ; $ level < $ iterator -> getDepth ( ) ; $ level ++ ) { $ siblings [ ] = ( $ iterator -> getSubIterator ( $ level ) -> hasNext ( ) ) ? 1 : 0 ; } $ siblings [ ] = ( ! $ iterator -> getSubIterator ( $ level ) -> hasNext ( ) ) ? 1 : 0 ; $ html .= $ viewer -> fetchObject ( $ node , $ siblings ) ; } return $ html ; }
5322	public function lockExecute ( callable $ callable ) { $ this -> isAcquired = $ this -> acquire ( ) ; $ result = $ callable ( ) ; $ this -> isAcquired = $ this -> release ( ) ; return $ result ; }
3836	private function setLanguageStrings ( ) { if ( empty ( $ GLOBALS [ 'TL_LANG' ] [ $ this -> getMetaModel ( ) -> getTableName ( ) ] [ $ this -> getColName ( ) ] ) ) { $ GLOBALS [ 'TL_LANG' ] [ $ this -> getMetaModel ( ) -> getTableName ( ) ] [ $ this -> getColName ( ) ] = array ( $ this -> getLangValue ( $ this -> get ( 'name' ) ) , $ this -> getLangValue ( $ this -> get ( 'description' ) ) , ) ; } }
6013	public function listProtocols ( CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/deployment/protocols' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new Protocol ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
1697	public function removeFrontendAuthentication ( ) : bool { if ( ! $ this -> session -> isStarted ( ) || ! $ this -> session -> has ( FrontendUser :: SECURITY_SESSION_KEY ) ) { return false ; } $ this -> session -> remove ( FrontendUser :: SECURITY_SESSION_KEY ) ; return true ; }
948	public function api ( ) { $ apiClass = Config :: get ( 'shopify-app.api_class' ) ; $ api = new $ apiClass ( ) ; $ api -> setApiKey ( Config :: get ( 'shopify-app.api_key' ) ) ; $ api -> setApiSecret ( Config :: get ( 'shopify-app.api_secret' ) ) ; $ version = Config :: get ( 'shopify-app.api_version' ) ; if ( $ version !== null ) { $ api -> setVersion ( $ version ) ; } if ( Config :: get ( 'shopify-app.api_rate_limiting_enabled' ) === true ) { $ api -> enableRateLimiting ( Config :: get ( 'shopify-app.api_rate_limit_cycle' ) , Config :: get ( 'shopify-app.api_rate_limit_cycle_buffer' ) ) ; } return $ api ; }
5057	private function getClassName ( $ requestedName ) { $ exp = explode ( '/' , $ requestedName ) ; $ className = array_shift ( $ exp ) . '\\Controller\\' . implode ( '\\' , $ exp ) . 'Controller' ; if ( ! class_exists ( $ className ) ) { throw new ServiceNotCreatedException ( sprintf ( 'Can\'t find correct controller class for "%s"' , $ requestedName ) ) ; } return $ className ; }
1872	protected function convertValuesToPaths ( ) { if ( empty ( $ this -> varValue ) ) { return ; } if ( ! \ is_array ( $ this -> varValue ) ) { $ this -> varValue = array ( $ this -> varValue ) ; } elseif ( empty ( $ this -> varValue [ 0 ] ) ) { $ this -> varValue = array ( ) ; } if ( empty ( $ this -> varValue ) ) { return ; } if ( strpos ( $ this -> varValue [ 0 ] , Config :: get ( 'uploadPath' ) . '/' ) === 0 ) { return ; } if ( Input :: get ( 'switch' ) ) { return ; } if ( $ this -> path != '' && strpos ( $ this -> path , Config :: get ( 'uploadPath' ) . '/' ) !== 0 ) { return ; } $ objFiles = FilesModel :: findMultipleByIds ( $ this -> varValue ) ; if ( $ objFiles !== null ) { $ this -> varValue = array_values ( $ objFiles -> fetchEach ( 'path' ) ) ; } }
11701	public function get ( $ component ) { $ parts = explode ( '.' , $ component ) ; if ( count ( $ parts ) == 1 ) { return $ this -> getService ( $ parts [ 0 ] ) ; } elseif ( count ( $ parts ) == 2 ) { return $ this -> getService ( $ parts [ 0 ] ) -> getGroup ( $ parts [ 1 ] ) ; } elseif ( count ( $ parts ) == 3 ) { return $ this -> getService ( $ parts [ 0 ] ) -> getGroup ( $ parts [ 1 ] ) -> getAction ( $ parts [ 2 ] ) ; } throw new \ LogicException ( 'Malformed component path. Please use a dot-notated path (e.g. service.group.action)' ) ; }
11903	public function getDescriptor ( ) { $ logModel = $ this -> getLogModel ( true ) ; if ( empty ( $ logModel ) || ! isset ( $ logModel -> dataInterface ) ) { return 'Unknown Data Interface' ; } return 'Interface: ' . $ logModel -> dataInterface -> name ; }
5607	public function paintGroupEnd ( $ group ) { $ this -> group = '' ; $ cc = '' ; if ( $ this -> cc ) { if ( extension_loaded ( 'xdebug' ) ) { $ arrfiles = xdebug_get_code_coverage ( ) ; xdebug_stop_code_coverage ( ) ; $ thisdir = dirname ( __FILE__ ) ; $ thisdirlen = strlen ( $ thisdir ) ; foreach ( $ arrfiles as $ index => $ file ) { if ( substr ( $ index , 0 , $ thisdirlen ) === $ thisdir ) { continue ; } $ lcnt = 0 ; $ ccnt = 0 ; foreach ( $ file as $ line ) { if ( $ line == - 2 ) { continue ; } $ lcnt ++ ; if ( $ line == 1 ) { $ ccnt ++ ; } } if ( $ lcnt > 0 ) { $ cc .= round ( ( $ ccnt / $ lcnt ) * 100 , 2 ) . '%' ; } else { $ cc .= '0.00%' ; } $ cc .= "\t" . $ index . "\n" ; } } } $ this -> listener -> write ( '{status:"coverage",message:"' . self :: escapeVal ( $ cc ) . '"}' ) ; }
1438	protected function buildClass ( $ name ) { $ stub = $ this -> files -> get ( $ this -> getStub ( ) ) ; $ this -> replaceNamespace ( $ stub , $ name ) -> replaceClassName ( $ stub , $ name ) -> replaceResourceType ( $ stub ) -> replaceApplicationNamespace ( $ stub ) -> replaceRecord ( $ stub ) ; return $ stub ; }
9926	private function handleArrays ( Parameters $ params , array $ permitted = array ( ) ) { foreach ( $ permitted as $ key => $ allowed ) { if ( is_array ( $ allowed ) && $ params -> hasKey ( $ key ) ) { $ value = $ params [ $ key ] ; if ( $ value instanceof Parameters ) { $ this -> filter ( $ value , $ allowed ) ; } else { $ this -> handleUnpermittedParam ( $ key , $ params ) ; } } } }
5065	public function getInfo ( int $ opt ) : string { if ( $ opt <= 0 ) { throw new CurlException ( "Option must be greater than zero, " . $ opt . " given." ) ; } return curl_getinfo ( $ this -> ch , $ opt ) ; }
11269	public function getPath ( Neuron_GameServer_Map_Location $ start , Neuron_GameServer_Map_Location $ end ) { $ x1 = $ start [ 0 ] ; $ y1 = $ start [ 1 ] ; $ x2 = $ end [ 0 ] ; $ y2 = $ end [ 1 ] ; if ( ! $ this -> isPassable ( $ x2 , $ y2 ) ) { return false ; } $ astar = $ this -> astar ( $ start , $ end ) ; return $ astar ; }
10266	public function setRotation ( $ pValue ) { if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'rotation' => $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> rotation = $ pValue ; } return $ this ; }
7333	private function getStockUnitMapper ( EntityManagerInterface $ em ) { if ( null === $ this -> stockUnitMapper ) { $ this -> stockUnitMapper = new DiscriminatorMapper ( $ em , AbstractStockUnit :: class ) ; } return $ this -> stockUnitMapper ; }
4886	public function plugin ( $ plugin , $ options = null ) { $ renderer = $ this -> getView ( ) ; if ( ! method_exists ( $ renderer , 'getHelperPluginManager' ) ) { return true === $ options ? false : new HelperProxy ( false ) ; } $ manager = $ renderer -> getHelperPluginManager ( ) ; $ hasPlugin = $ manager -> has ( $ plugin ) ; if ( true === $ options ) { return $ hasPlugin ; } if ( $ hasPlugin ) { $ pluginInstance = $ manager -> get ( $ plugin , $ options ) ; } else { $ pluginInstance = false ; } return new HelperProxy ( $ pluginInstance ) ; }
3450	public function getDirectChildren ( array $ filter = [ ] ) { return static :: query ( ) -> filter ( $ filter ) -> filter ( [ 'SECTION_ID' => $ this -> id ] ) -> select ( 'ID' ) -> getList ( ) -> transform ( function ( $ section ) { return ( int ) $ section [ 'ID' ] ; } ) -> all ( ) ; }
2344	protected function createIfNotExists ( ) { if ( file_exists ( $ this -> strRootDir . '/' . $ this -> strFile ) ) { return ; } if ( ( $ strFolder = \ dirname ( $ this -> strFile ) ) == '.' ) { $ strFolder = '' ; } if ( ! is_dir ( $ this -> strRootDir . '/' . $ strFolder ) ) { new Folder ( $ strFolder ) ; } if ( ! $ this -> resFile = $ this -> Files -> fopen ( $ this -> strFile , 'wb' ) ) { throw new \ Exception ( sprintf ( 'Cannot create file "%s"' , $ this -> strFile ) ) ; } }
7888	public function logs ( ) { $ logs = array_reverse ( $ this -> filesystem -> files ( ) ) ; foreach ( $ logs as $ index => $ file ) { $ logs [ $ index ] = preg_replace ( '/.*(\d{4}-\d{2}-\d{2}).*/' , '$1' , basename ( $ file ) ) ; } return $ logs ; }
2309	public function getImportantPart ( ) { if ( $ this -> importantPart ) { return $ this -> importantPart ; } return array ( 'x' => 0 , 'y' => 0 , 'width' => $ this -> fileObj -> viewWidth , 'height' => $ this -> fileObj -> viewHeight ) ; }
7161	private function initialize ( Model \ SaleInterface $ sale , array $ options = [ ] ) { $ this -> lineNumber = 1 ; $ this -> view = new SaleView ( ) ; $ this -> types = $ this -> registry -> getTypesForSale ( $ sale ) ; foreach ( $ this -> types as $ type ) { $ type -> configureOptions ( $ sale , $ this -> view , $ options ) ; } $ this -> options = $ this -> getOptionsResolver ( ) -> resolve ( $ options ) ; $ this -> view -> setTemplate ( $ this -> options [ 'template' ] ) ; if ( ! is_null ( $ this -> options [ 'ati' ] ) ) { $ this -> view -> setAti ( $ this -> options [ 'ati' ] ) ; } else { $ this -> view -> setAti ( $ sale -> isAtiDisplayMode ( ) ) ; } $ this -> formatter = $ this -> formatterFactory -> create ( $ this -> options [ 'locale' ] , $ sale -> getCurrency ( ) -> getCode ( ) ) ; foreach ( $ this -> types as $ type ) { $ type -> setFormatter ( $ this -> formatter ) ; } }
2303	public function addCustomLayoutSectionReferences ( ) { $ objLayout = $ this -> Database -> getInstance ( ) -> query ( "SELECT sections FROM tl_layout WHERE sections!=''" ) ; while ( $ objLayout -> next ( ) ) { $ arrCustom = StringUtil :: deserialize ( $ objLayout -> sections ) ; if ( ! empty ( $ arrCustom ) && \ is_array ( $ arrCustom ) ) { foreach ( $ arrCustom as $ v ) { if ( ! empty ( $ v [ 'id' ] ) ) { $ GLOBALS [ 'TL_LANG' ] [ 'COLS' ] [ $ v [ 'id' ] ] = $ v [ 'title' ] ; } } } } }
11571	public function onBlockEditing ( BlockEditingEvent $ event ) { $ encodedBlock = $ event -> getFileContent ( ) ; $ htmlBlock = $ this -> pageProductionRenderer -> renderBlock ( $ encodedBlock ) ; $ this -> permalinkManager -> add ( $ event -> getFilePath ( ) , $ htmlBlock ) -> save ( ) ; }
8273	public function validateUserData ( $ userData ) { $ this -> assertRequired ( $ userData , "pwhash" ) ; $ this -> assertString ( $ userData , "pwhash" ) ; $ this -> assertString ( $ userData , "email" ) ; $ this -> assertArray ( $ userData , "attributes" ) ; $ this -> assertString ( $ userData , "encoder" ) ; $ this -> assertBool ( $ userData , "pwreset" ) ; $ this -> assertArrayOfStrings ( $ userData , "groups" ) ; $ this -> assertString ( $ userData , "displayName" ) ; }
7202	public function getGross ( bool $ ati = false ) : float { return $ ati ? $ this -> ati ( $ this -> gross ) : $ this -> gross ; }
3260	protected function process ( Request $ request ) { $ validator = Validator :: make ( [ 'order_id' => $ request -> get ( 'order_id' ) , 'status' => $ request -> get ( 'status' ) , 'shoptoken' => $ request -> get ( 'shoptoken' ) , ] , [ 'order_id' => 'required|exists:' . config ( 'shop.order_table' ) . ',id' , 'status' => 'required|in:success,fail' , 'shoptoken' => 'required|exists:' . config ( 'shop.transaction_table' ) . ',token,order_id,' . $ request -> get ( 'order_id' ) , ] ) ; if ( $ validator -> fails ( ) ) { abort ( 404 ) ; } $ order = call_user_func ( config ( 'shop.order' ) . '::find' , $ request -> get ( 'order_id' ) ) ; $ transaction = $ order -> transactions ( ) -> where ( 'token' , $ request -> get ( 'shoptoken' ) ) -> first ( ) ; Shop :: callback ( $ order , $ transaction , $ request -> get ( 'status' ) , $ request -> all ( ) ) ; $ transaction -> token = null ; $ transaction -> save ( ) ; return redirect ( ) -> route ( config ( 'shop.callback_redirect_route' ) , [ 'orderId' => $ order -> id ] ) ; }
10874	public function getEncodeHash ( int $ id , string $ slug , string $ linkValidate = null ) : string { return base64_encode ( uniqid ( ( $ linkValidate ? strtotime ( $ linkValidate ) : self :: NO_TIME ) . self :: TIME_SEPARATOR , true ) . self :: PART_SEPARATOR . $ this -> getHash ( $ id . $ slug ) . self :: ID_SEPARATOR . $ id ) ; }
4309	public function getChannel ( $ channelName , $ config = array ( ) ) { if ( \ strpos ( $ channelName , '.' ) !== false ) { $ this -> error ( 'getChannel(): channelName should not contain period (.)' ) ; return $ this ; } if ( ! isset ( $ this -> channels [ $ channelName ] ) ) { $ cfg = $ this -> getCfg ( ) ; $ cfg = \ array_diff_key ( $ cfg , \ array_flip ( array ( 'errorEmailer' , 'errorHandler' , 'output' , ) ) ) ; unset ( $ cfg [ 'debug' ] [ 'onBootstrap' ] ) ; $ cfg [ 'debug' ] [ 'channel' ] = $ this -> parentInstance ? $ this -> cfg [ 'channel' ] . '.' . $ channelName : $ channelName ; $ cfg [ 'debug' ] [ 'parent' ] = $ this ; $ this -> channels [ $ channelName ] = new static ( $ cfg ) ; if ( $ config ) { $ this -> channels [ $ channelName ] -> setCfg ( $ config ) ; } } return $ this -> channels [ $ channelName ] ; }
5207	public function areActiveURLs ( array $ urls , $ output = "active" ) { foreach ( $ urls as $ url ) { if ( $ this -> isActiveURL ( $ url , true ) ) { return $ output ; } } return null ; }
12347	public function add ( array $ assets ) { foreach ( $ assets as $ type => $ asset ) { if ( $ asset instanceof Plugin ) { $ this -> parse ( $ asset ) ; continue ; } $ this -> assets [ $ type ] = array_merge ( $ this -> assets [ $ type ] , $ asset ) ; } }
1441	protected function replaceResourceType ( & $ stub ) { $ resource = $ this -> getResourceName ( ) ; $ stub = str_replace ( 'dummyResourceType' , Str :: dasherize ( $ resource ) , $ stub ) ; return $ this ; }
12354	public function setFilePath ( string $ viewFilePath ) : void { if ( ! is_readable ( $ viewFilePath ) ) { throw new Exception ( "The View file {$viewFilePath} isn't readable." ) ; } $ this -> filePath = $ viewFilePath ; }
9673	private function writeNumFmt ( XMLWriter $ objWriter , NumberFormat $ pNumberFormat , $ pId = 0 ) { $ formatCode = $ pNumberFormat -> getFormatCode ( ) ; if ( $ formatCode !== null ) { $ objWriter -> startElement ( 'numFmt' ) ; $ objWriter -> writeAttribute ( 'numFmtId' , ( $ pId + 164 ) ) ; $ objWriter -> writeAttribute ( 'formatCode' , $ formatCode ) ; $ objWriter -> endElement ( ) ; } }
1123	public function descendantsAndSelf ( ) { return $ this -> newNestedSetQuery ( ) -> where ( $ this -> getLeftColumnName ( ) , '>=' , $ this -> getLeft ( ) ) -> where ( $ this -> getLeftColumnName ( ) , '<' , $ this -> getRight ( ) ) ; }
10353	private function fireEventOn ( $ action , $ payload ) { $ event = $ this -> getEventName ( ) ; $ this -> dispatcher -> fire ( "auth.{$event}.{$action}" , $ payload ) ; }
12637	public static function connect ( string $ host = "" , int $ port = 0 , string $ dbname = "" , string $ user = "" , string $ pass = "" , bool $ reconnect = false ) : ? \ PDO { if ( self :: $ pdo !== null && ! $ reconnect ) return self :: $ pdo ; if ( $ host === "" && ( self :: $ databaseHost === null || self :: $ databaseHost === "" ) ) throw new Exceptions \ DatabaseConnectionException ( "A valid host name was not provided!" ) ; $ host = $ host ? : self :: $ databaseHost ; if ( $ port === 0 && ( self :: $ databasePort === null || self :: $ databasePort === 0 ) ) throw new Exceptions \ DatabaseConnectionException ( "A valid port number was not provided!" ) ; $ port = $ port ? : self :: $ databasePort ; if ( $ dbname === "" && ( self :: $ databaseName === null || self :: $ databaseName === "" ) ) throw new Exceptions \ DatabaseConnectionException ( "A valid database name was not provided!" ) ; $ dbname = $ dbname ? : self :: $ databaseName ; if ( $ user === "" && ( self :: $ databaseUser === null || self :: $ databaseUser === "" ) ) throw new Exceptions \ DatabaseConnectionException ( "A valid username was not provided!" ) ; $ user = $ user ? : self :: $ databaseUser ; if ( $ pass === "" && ( self :: $ databasePass === null || self :: $ databasePass === "" ) ) throw new Exceptions \ DatabaseConnectionException ( "A valid password was not provided!" ) ; $ pass = $ pass ? : self :: $ databasePass ; try { self :: $ pdo = new \ PDO ( "pgsql:host=$host;port=$port;dbname=$dbname" , $ user , $ pass , [ \ PDO :: ATTR_DEFAULT_FETCH_MODE => \ PDO :: FETCH_ASSOC , ] ) ; if ( self :: $ pdo ) return self :: $ pdo ; } catch ( \ PDOException $ e ) { throw new Exceptions \ DatabaseConnectionException ( $ e -> getMessage ( ) ) ; } return null ; }
3799	private function checkModelWithoutVariants ( $ containedModel ) { $ parentDefinition = $ this -> environment -> getDataDefinition ( ) -> getBasicDefinition ( ) -> getParentDataProvider ( ) ; $ this -> disablePA = ( $ this -> currentModel -> getId ( ) == $ containedModel -> getId ( ) ) || ( $ parentDefinition && $ this -> currentModel -> getProperty ( 'pid' ) == $ containedModel -> getProperty ( 'pid' ) ) ; $ this -> disablePI = ( $ this -> circularReference ) || ( $ this -> currentModel -> getId ( ) == $ containedModel -> getId ( ) ) || ( $ parentDefinition && $ this -> currentModel -> getProperty ( 'pid' ) == $ containedModel -> getId ( ) ) ; }
4959	public function detach ( EventManagerInterface $ events ) { foreach ( $ this -> listeners as $ index => $ listener ) { if ( $ events -> detach ( $ listener ) ) { unset ( $ this -> listeners [ $ index ] ) ; } } $ sharedEvents = $ events -> getSharedManager ( ) ; foreach ( $ this -> sharedListeners as $ index => $ listener ) { if ( $ sharedEvents -> detach ( $ listener ) ) { unset ( $ this -> sharedListeners [ $ index ] ) ; } } }
11021	private function findTasks ( ) { if ( $ this -> init ) return ; $ resolver = $ this -> app -> moduleManager ; $ modules = $ resolver -> getModules ( ) ; foreach ( $ modules as $ mod ) $ mod -> registerTasks ( $ this ) ; Hook :: execute ( "Wedeto.Application.Task.TaskRunner.findTasks" , [ 'taskrunner' => $ this ] ) ; $ this -> init = true ; }
9309	public function show ( $ id , $ params = [ ] ) { $ data = [ 'id' => $ id ] + $ params ; return $ this -> query ( __FUNCTION__ , $ data ) ; }
5928	public function createCategory ( Category $ category ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'category' => $ category ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/categories' , $ parameters ) ; $ result = new CategoryResponse ( $ result ) ; return $ result ; }
2754	public static function plainText ( $ value ) { $ element = render ( $ value ) ; $ element = strip_tags ( $ element ) ; $ element = html_entity_decode ( $ element , ENT_QUOTES ) ; return $ element ; }
8332	public function listSequences ( $ database = null ) { $ query = "SELECT name FROM sysobjects WHERE xtype = 'U'" ; $ tableNames = $ this -> _conn -> fetchAll ( $ query ) ; return array_map ( [ $ this -> _conn -> formatter , 'fixSequenceName' ] , $ tableNames ) ; }
7028	static function getDefaultImplementations ( ) { return [ Cart \ Model \ CartInterface :: class => Cart \ Entity \ Cart :: class , Cart \ Model \ CartAddressInterface :: class => Cart \ Entity \ CartAddress :: class , Customer \ Model \ CustomerInterface :: class => Customer \ Entity \ Customer :: class , Customer \ Model \ CustomerGroupInterface :: class => Customer \ Entity \ CustomerGroup :: class , Customer \ Model \ CustomerAddressInterface :: class => Customer \ Entity \ CustomerAddress :: class , Order \ Model \ OrderInterface :: class => Order \ Entity \ Order :: class , Order \ Model \ OrderAddressInterface :: class => Order \ Entity \ OrderAddress :: class , Payment \ Model \ PaymentMethodInterface :: class => Payment \ Entity \ PaymentMethod :: class , Payment \ Model \ PaymentTermInterface :: class => Payment \ Entity \ PaymentTerm :: class , Quote \ Model \ QuoteInterface :: class => Quote \ Entity \ Quote :: class , Quote \ Model \ QuoteAddressInterface :: class => Quote \ Entity \ QuoteAddress :: class , Shipment \ Model \ ShipmentMethodInterface :: class => Shipment \ Entity \ ShipmentMethod :: class , Supplier \ Model \ SupplierInterface :: class => Supplier \ Entity \ Supplier :: class , Supplier \ Model \ SupplierAddressInterface :: class => Supplier \ Entity \ SupplierAddress :: class , Supplier \ Model \ SupplierDeliveryInterface :: class => Supplier \ Entity \ SupplierDelivery :: class , Supplier \ Model \ SupplierOrderInterface :: class => Supplier \ Entity \ SupplierOrder :: class , Supplier \ Model \ SupplierProductInterface :: class => Supplier \ Entity \ SupplierProduct :: class , Support \ Model \ TicketInterface :: class => Support \ Entity \ Ticket :: class , Support \ Model \ TicketMessageInterface :: class => Support \ Entity \ TicketMessage :: class , ] ; }
6828	private function getSaleDeliveryAddress ( ShipmentInterface $ shipment ) { if ( null === $ sale = $ shipment -> getSale ( ) ) { throw new LogicException ( "Shipment's sale must be set at this point." ) ; } return $ sale -> isSameAddress ( ) ? $ sale -> getInvoiceAddress ( ) : $ sale -> getDeliveryAddress ( ) ; }
6390	public function readFacetofaceSessionSignups ( $ sessionid , $ timecreated ) { $ signups = $ this -> readStoreRecords ( 'facetoface_signups' , [ 'sessionid' => $ sessionid ] ) ; foreach ( $ signups as $ index => $ signup ) { $ signups [ $ index ] -> statuses = $ this -> readStoreRecords ( 'facetoface_signups_status' , [ 'signupid' => $ signup -> id ] ) ; $ signups [ $ index ] -> attendee = $ this -> readUser ( $ signup -> userid ) ; } return $ signups ; }
2474	public function bulkIndexContent ( array $ contentObjects ) { $ documents = array ( ) ; foreach ( $ contentObjects as $ content ) { try { $ documents [ ] = $ this -> mapper -> mapContentBlock ( $ content ) ; } catch ( NotFoundException $ ex ) { } } if ( ! empty ( $ documents ) ) { $ this -> gateway -> bulkIndexDocuments ( $ documents ) ; } }
5814	public function validate ( ) { $ result = parent :: validate ( ) ; $ this -> Title = strtolower ( $ this -> Title ) ; if ( $ result -> valid ( ) && ! $ this -> Title ) { $ result -> error ( '"Title" required!' ) ; } else if ( $ result -> valid ( ) && FusionTag :: get_one ( 'FusionTag' , array ( 'ID != ?' => $ this -> ID , 'Title = ?' => $ this -> Title ) ) ) { $ result -> error ( 'Tag already exists!' ) ; } $ this -> extend ( 'validateFusionTag' , $ result ) ; return $ result ; }
3561	protected function getMutatedType ( $ value , $ dir = 'setter' ) { foreach ( $ this -> { "{$dir}Mutators" } as $ mutated => $ mutator ) { if ( $ this -> getValueType ( $ value ) == $ mutated || $ value instanceof $ mutated ) { return $ mutated ; } } }
53	public function setDownloader ( $ type , DownloaderInterface $ downloader ) { $ type = strtolower ( $ type ) ; $ this -> downloaders [ $ type ] = $ downloader ; return $ this ; }
7770	public function errors ( ) { $ messages = [ ] ; foreach ( $ this -> errors as $ rule => $ items ) { foreach ( $ items as $ item ) { $ field = $ item [ 'field' ] ; $ message = $ this -> fetchMessage ( $ field , $ rule ) ; if ( isset ( $ this -> fieldAliases [ $ field ] ) ) { $ item [ 'field' ] = $ this -> fieldAliases [ $ field ] ; } $ messages [ $ field ] [ ] = $ this -> replaceMessageFormat ( $ message , $ item ) ; } } return new MessageBag ( $ messages ) ; }
6908	public function addCopy ( Recipient $ copy ) { if ( ! $ this -> copies -> contains ( $ copy ) ) { $ this -> copies -> add ( $ copy ) ; } return $ this ; }
7596	protected function renderHelpBlock ( ElementInterface $ oElement ) { if ( $ sHelpBlock = $ oElement -> getOption ( 'help-block' ) ) { if ( $ oTranslator = $ this -> getTranslator ( ) ) { $ sHelpBlock = $ oTranslator -> translate ( $ sHelpBlock , $ this -> getTranslatorTextDomain ( ) ) ; } $ sHelpBlockString = strip_tags ( $ sHelpBlock ) ; if ( $ sHelpBlock === $ sHelpBlockString ) { $ sHelpBlock = $ this -> getEscapeHtmlHelper ( ) -> __invoke ( $ sHelpBlock ) ; } return sprintf ( static :: $ helpBlockFormat , $ sHelpBlock ) ; } else { return '' ; } }
550	public function actionIndex ( ) { $ caches = $ this -> findCaches ( ) ; if ( ! empty ( $ caches ) ) { $ this -> notifyCachesCanBeFlushed ( $ caches ) ; } else { $ this -> notifyNoCachesFound ( ) ; } }
2192	public function isRegisteredAlias ( Model $ objModel , $ strAlias , $ varValue ) { $ strTable = $ objModel -> getTable ( ) ; return isset ( $ this -> arrAliases [ $ strTable ] [ $ strAlias ] [ $ varValue ] ) ; }
9248	public function from ( Contract $ contract , string $ string , callable $ callback = null ) : string { return $ this -> callback ( $ contract -> recipe ( $ string , 'upperCaseFirst' , function ( $ string ) use ( $ contract ) { if ( $ contract instanceof ClassName ) { return lcfirst ( $ string ) ; } return strtolower ( $ string ) ; } ) , $ callback ) ; }
7312	public static function equinoxAutumn ( $ year ) { $ jd = static :: equinoxSeptember ( ( int ) $ year , false ) ; return AstroDate :: jd ( $ jd , TimeScale :: TT ( ) ) ; }
1898	private function checkIfAccountIsActive ( User $ user ) : void { $ config = $ this -> framework -> getAdapter ( Config :: class ) ; $ start = ( int ) $ user -> start ; $ stop = ( int ) $ user -> stop ; $ time = Date :: floorToMinute ( time ( ) ) ; $ notActiveYet = $ start && $ start > $ time ; $ notActiveAnymore = $ stop && $ stop <= ( $ time + 60 ) ; $ logMessage = '' ; if ( $ notActiveYet ) { $ logMessage = sprintf ( 'The account is not active yet (activation date: %s)' , Date :: parse ( $ config -> get ( 'dateFormat' ) , $ start ) ) ; } if ( $ notActiveAnymore ) { $ logMessage = sprintf ( 'The account is not active anymore (deactivation date: %s)' , Date :: parse ( $ config -> get ( 'dateFormat' ) , $ stop ) ) ; } if ( '' === $ logMessage ) { return ; } $ ex = new DisabledException ( $ logMessage ) ; $ ex -> setUser ( $ user ) ; throw $ ex ; }
215	public function resolve ( ) { $ rawParams = $ this -> getParams ( ) ; $ endOfOptionsFound = false ; if ( isset ( $ rawParams [ 0 ] ) ) { $ route = array_shift ( $ rawParams ) ; if ( $ route === '--' ) { $ endOfOptionsFound = true ; $ route = array_shift ( $ rawParams ) ; } } else { $ route = '' ; } $ params = [ ] ; $ prevOption = null ; foreach ( $ rawParams as $ param ) { if ( $ endOfOptionsFound ) { $ params [ ] = $ param ; } elseif ( $ param === '--' ) { $ endOfOptionsFound = true ; } elseif ( preg_match ( '/^--([\w-]+)(?:=(.*))?$/' , $ param , $ matches ) ) { $ name = $ matches [ 1 ] ; if ( is_numeric ( substr ( $ name , 0 , 1 ) ) ) { throw new Exception ( 'Parameter "' . $ name . '" is not valid' ) ; } if ( $ name !== Application :: OPTION_APPCONFIG ) { $ params [ $ name ] = isset ( $ matches [ 2 ] ) ? $ matches [ 2 ] : true ; $ prevOption = & $ params [ $ name ] ; } } elseif ( preg_match ( '/^-([\w-]+)(?:=(.*))?$/' , $ param , $ matches ) ) { $ name = $ matches [ 1 ] ; if ( is_numeric ( $ name ) ) { $ params [ ] = $ param ; } else { $ params [ '_aliases' ] [ $ name ] = isset ( $ matches [ 2 ] ) ? $ matches [ 2 ] : true ; $ prevOption = & $ params [ '_aliases' ] [ $ name ] ; } } elseif ( $ prevOption === true ) { $ prevOption = $ param ; } else { $ params [ ] = $ param ; } } return [ $ route , $ params ] ; }
11576	public function actionConnect ( $ account_id ) { $ account = $ this -> finder -> findAccountById ( $ account_id ) ; if ( $ account === null || $ account -> getIsConnected ( ) ) { throw new NotFoundHttpException ; } $ user = \ Yii :: createObject ( [ 'class' => User :: className ( ) , 'scenario' => 'connect' ] ) ; if ( $ user -> load ( \ Yii :: $ app -> request -> post ( ) ) && $ user -> create ( ) ) { $ account -> user_id = $ user -> id ; $ account -> save ( false ) ; \ Yii :: $ app -> user -> login ( $ user , $ this -> module -> rememberFor ) ; return $ this -> goBack ( ) ; } return $ this -> render ( 'connect' , [ 'model' => $ user , 'account' => $ account ] ) ; }
7724	public function setQuickReplies ( $ quickReplie ) { $ model = new QuickReplie ( ) ; $ type = ! empty ( $ quickReplie [ 'type' ] ) ? $ quickReplie [ 'type' ] : 'text' ; $ model -> setContentType ( $ type ) ; if ( ! empty ( $ quickReplie [ 'title' ] ) ) { $ model -> setPayload ( $ quickReplie [ 'payload' ] ) ; } if ( ! empty ( $ quickReplie [ 'title' ] ) ) { $ model -> setTitle ( $ quickReplie [ 'title' ] ) ; } if ( ! empty ( $ quickReplie [ 'image' ] ) ) { $ model -> setImageUrl ( $ quickReplie [ 'image' ] ) ; } $ this -> quickReplies [ ] = $ model ; }
12564	public function sendVoice ( $ message , $ to = null ) { return $ this -> send ( self :: MSG_TYPE_VOICE , $ message , $ to ) ; }
8488	public static function getLoad ( ) { $ wmi = Windows :: getInstance ( ) ; $ load = [ ] ; foreach ( $ wmi -> ExecQuery ( "SELECT LoadPercentage FROM Win32_Processor" ) as $ cpu ) { $ load [ ] = $ cpu -> LoadPercentage ; } return round ( array_sum ( $ load ) / count ( $ load ) , 2 ) . "%" ; }
8497	public function getPackageTrackingDetails ( $ request ) { if ( ! ( $ request instanceof FBAOutboundServiceMWS_Model_GetPackageTrackingDetailsRequest ) ) { $ request = new FBAOutboundServiceMWS_Model_GetPackageTrackingDetailsRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetPackageTrackingDetails' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAOutboundServiceMWS_Model_GetPackageTrackingDetailsResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
10438	public function offsetSet ( $ attributeName , $ attribute ) { if ( ! is_string ( $ attributeName ) || ! is_string ( $ attribute ) ) { throw new ValueException ( $ attribute , 'string' ) ; } $ this -> attributes [ $ attributeName ] = $ attribute ; }
1936	protected function getForwardUrl ( $ objPage ) { if ( $ objPage -> jumpTo ) { $ objNextPage = PageModel :: findPublishedById ( $ objPage -> jumpTo ) ; } else { $ objNextPage = PageModel :: findFirstPublishedRegularByPid ( $ objPage -> id ) ; } if ( ! $ objNextPage instanceof PageModel ) { $ this -> log ( 'Forward page ID "' . $ objPage -> jumpTo . '" does not exist' , __METHOD__ , TL_ERROR ) ; throw new ForwardPageNotFoundException ( 'Forward page not found' ) ; } $ strGet = '' ; $ strQuery = Environment :: get ( 'queryString' ) ; $ arrQuery = array ( ) ; if ( $ strQuery != '' ) { $ arrChunks = explode ( '&' , $ strQuery ) ; foreach ( $ arrChunks as $ strChunk ) { list ( $ k ) = explode ( '=' , $ strChunk , 2 ) ; $ arrQuery [ ] = $ k ; } } if ( ! empty ( $ _GET ) ) { foreach ( array_keys ( $ _GET ) as $ key ) { if ( Config :: get ( 'addLanguageToUrl' ) && $ key == 'language' ) { continue ; } if ( \ in_array ( $ key , $ arrQuery ) ) { continue ; } if ( $ key == 'auto_item' ) { $ strGet .= '/' . Input :: get ( $ key ) ; } else { $ strGet .= '/' . $ key . '/' . Input :: get ( $ key ) ; } } } if ( $ strQuery != '' ) { $ strQuery = '?' . $ strQuery ; } return $ objNextPage -> getAbsoluteUrl ( $ strGet ) . $ strQuery ; }
10991	public function getName ( bool $ includeExtension = false ) : string { $ filename = basename ( $ this -> path ) ; if ( $ includeExtension ) { return $ filename ; } return $ this -> splitName ( ) [ 0 ] ; }
1850	private function preHandleFragment ( FragmentReference $ uri , FragmentConfig $ config ) : void { if ( ! isset ( $ uri -> attributes [ 'pageModel' ] ) && $ this -> hasGlobalPageObject ( ) ) { $ uri -> attributes [ 'pageModel' ] = $ GLOBALS [ 'objPage' ] -> id ; } if ( $ this -> preHandlers -> has ( $ uri -> controller ) ) { $ preHandler = $ this -> preHandlers -> get ( $ uri -> controller ) ; $ preHandler -> preHandleFragment ( $ uri , $ config ) ; } }
290	public function __isset ( $ name ) { try { return $ this -> __get ( $ name ) !== null ; } catch ( \ Throwable $ t ) { return false ; } catch ( \ Exception $ e ) { return false ; } }
8912	protected function _fetch_primary_key ( ) { if ( $ this -> is_base_model_instance ( ) ) { return ; } if ( $ this -> primary_key == NULL && $ this -> _database ) { $ this -> primary_key = $ this -> execute_query ( "SHOW KEYS FROM `" . $ this -> _database -> dbprefix ( $ this -> _table ) . "` WHERE Key_name = 'PRIMARY'" ) -> row ( ) -> Column_name ; } }
12067	public function fetchProjects ( ) { $ response = $ this -> getResponse ( 'get' , 'v2/projects' ) ; $ projects = array ( ) ; if ( is_array ( $ response ) ) { foreach ( $ response as $ data ) { $ projects [ ] = $ this -> hydrator -> hydrate ( new Project ( ) , $ data ) ; } } return $ projects ; }
7102	public static function site ( string $ uri = '' , $ protocol = null ) : string { $ path = preg_replace ( '~^[-a-z0-9+.]++://[^/]++/?~' , '' , trim ( $ uri , '/' ) ) ; if ( preg_match ( '/[^\x00-\x7F]/S' , $ path ) ) { $ path = preg_replace_callback ( '~([^/]+)~' , '\mii\util\URL::_rawurlencode_callback' , $ path ) ; } return URL :: base ( $ protocol ) . $ path ; }
6504	public function serializeParameters ( $ type , array $ parameters ) { $ jobType = $ this -> registry -> get ( $ type ) ; $ indices = $ jobType -> getIndicesOfSerializableParameters ( ) ; if ( count ( $ indices ) < count ( $ parameters ) ) { throw new \ InvalidArgumentException ( sprintf ( 'More parameters provided for serialization than defined for job "%s"' , $ type ) ) ; } $ i = 0 ; $ serializedParameters = array ( ) ; foreach ( $ parameters as $ parameter ) { if ( null == $ parameter ) { $ serializedParameters [ ] = null ; } else { $ serializedParameters [ ] = $ this -> serializer -> serialize ( $ parameter , 'json' , $ this -> getParamSerializationContext ( $ jobType , $ indices [ $ i ] ) ) ; } $ i ++ ; } $ data = json_encode ( $ serializedParameters ) ; if ( false === $ data ) { throw new \ RuntimeException ( sprintf ( 'Serialization failed with error "%s"' , json_last_error_msg ( ) ) ) ; } return $ data ; }
4382	public function onOutput ( Event $ event ) { $ this -> channelName = $ this -> debug -> getCfg ( 'channel' ) ; $ this -> data = $ this -> debug -> getData ( ) ; $ str = '' ; $ str .= $ this -> processAlerts ( ) ; $ str .= $ this -> processSummary ( ) ; $ str .= $ this -> processLog ( ) ; $ this -> data = array ( ) ; $ event [ 'return' ] .= $ str ; }
816	private function getMeaningfulSequence ( Tokens $ tokens , $ start , $ end ) { $ sequence = [ ] ; $ index = $ start ; while ( $ index < $ end ) { $ index = $ tokens -> getNextMeaningfulToken ( $ index ) ; if ( $ index >= $ end || null === $ index ) { break ; } $ sequence [ ] = $ tokens [ $ index ] ; } return Tokens :: fromArray ( $ sequence ) ; }
7321	public function dayOfYear ( ) { $ k = $ this -> isLeapYear ( ) ? 1 : 2 ; $ n = intval ( 275 * ( int ) $ this -> month / 9 ) - $ k * intval ( ( ( int ) $ this -> month + 9 ) / 12 ) + ( int ) $ this -> day - 30 ; return ( int ) $ n ; }
7009	private function formatL ( & $ str ) { if ( strstr ( $ str , '%L' ) ) $ str = str_replace ( '%L' , strtolower ( $ this -> dayName ( true ) ) , $ str ) ; }
10680	protected function generateURLSegment ( $ title ) { $ filter = URLSegmentFilter :: create ( ) ; $ t = $ filter -> filter ( $ title ) ; if ( ! $ t || $ t == '-' || $ t == '-1' ) { $ t = "{$this->owner->ClassName}-{$this->owner->ID}" ; } else { $ class = $ this -> owner -> ClassName ; $ obj = $ class :: get ( ) -> filter ( array ( "URLSegment" => $ t ) ) -> exclude ( array ( "ID" => $ this -> owner -> ID ) ) -> first ( ) ; if ( $ obj ) { $ t .= "-{$this->owner->ID}" ; } } return $ t ; }
5374	public function createTag ( $ name , $ attributes ) { static $ map = array ( 'a' => 'SimpleAnchorTag' , 'title' => 'SimpleTitleTag' , 'base' => 'SimpleBaseTag' , 'button' => 'SimpleButtonTag' , 'textarea' => 'SimpleTextAreaTag' , 'option' => 'SimpleOptionTag' , 'label' => 'SimpleLabelTag' , 'form' => 'SimpleFormTag' , 'frame' => 'SimpleFrameTag' ) ; $ attributes = $ this -> keysToLowerCase ( $ attributes ) ; if ( array_key_exists ( $ name , $ map ) ) { $ tag_class = $ map [ $ name ] ; return new $ tag_class ( $ attributes ) ; } elseif ( $ name === 'select' ) { return $ this -> createSelectionTag ( $ attributes ) ; } elseif ( $ name === 'input' ) { return $ this -> createInputTag ( $ attributes ) ; } return new SimpleTag ( $ name , $ attributes ) ; }
12578	public function previewVoiceByName ( $ message , $ to ) { return $ this -> preview ( self :: MSG_TYPE_VOICE , $ message , $ to , self :: PREVIEW_BY_NAME ) ; }
6209	public function notifyOnError ( $ message , array $ backtrace = null , $ extraParams = null ) { if ( ! $ backtrace ) { $ backtrace = debug_backtrace ( ) ; if ( count ( $ backtrace ) > 1 ) { array_shift ( $ backtrace ) ; } } $ notice = new Notice ; $ notice -> load ( array ( 'errorClass' => 'PHP::Error' , 'backtrace' => $ backtrace , 'errorMessage' => $ message , 'extraParameters' => $ extraParams , ) ) ; return $ this -> notify ( $ notice ) ; }
9061	private function getTableData ( $ table ) : self { if ( $ table instanceof Table ) { return $ table ; } elseif ( is_subclass_of ( $ table , Mapper :: class ) ) { $ mapper = $ this -> container -> getByType ( $ table ) ; return $ mapper -> getStructure ( ) ; } else { throw new InvalidArgumentException ; } }
11297	protected function _getModelsFromTableColumn ( $ attributeName , $ objName , $ relationColumnName , $ query = false , $ loadMap = false ) { $ relatedObj = $ this -> fetchRelatedObj ( $ objName ) ; $ idField = $ relatedObj -> getPrimaryKey ( ) ; $ repo = \ Cora \ RepositoryFactory :: make ( $ objName , false , false , false , $ this -> model_db ) ; if ( ! $ query ) $ query = $ this -> _getQueryObjectForRelation ( $ attributeName ) ; $ query -> where ( $ relationColumnName , $ this -> { $ this -> getPrimaryKey ( ) } ) ; return $ repo -> findAll ( $ query , false , $ loadMap ) ; }
7451	public function boot ( \ Neos \ Flow \ Core \ Bootstrap $ bootstrap ) { $ dispatcher = $ bootstrap -> getSignalSlotDispatcher ( ) ; $ dispatcher -> connect ( 'Neos\Flow\Configuration\ConfigurationManager' , 'configurationManagerReady' , function ( $ configurationManager ) { $ configurationManager -> registerConfigurationType ( 'Menus' ) ; } ) ; }
2360	public static function findPublishedById ( $ intId , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = array ( "$t.id=?" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.disable=''" ; } return static :: findOneBy ( $ arrColumns , $ intId , $ arrOptions ) ; }
6208	public function load ( $ data ) { if ( ! is_array ( $ data ) && ! $ data instanceof \ stdClass ) { return ; } foreach ( $ data as $ key => $ value ) { $ this -> set ( $ key , $ value ) ; } }
10547	public function setResolver ( Resolver $ resolver ) { $ this -> resolver = $ resolver ; $ this -> setVariable ( 'resolver' , $ resolver ) ; return $ this ; }
5943	public function fetchObject ( AbstractNode $ node , array $ siblings = array ( ) ) { $ this -> currObj = $ node ; $ this -> currSib = $ siblings ; $ args = array ( $ this -> getPrefix ( ) , $ this -> getCorpusIcon ( ) , $ this -> getCorpusName ( ) , ) ; return StringHelper :: factory ( $ this -> pattern ) -> arg ( $ args ) ; }
9227	public function post ( $ path , $ data = array ( ) , $ headers = array ( ) ) { return $ this -> postprocessResponse ( parent :: post ( $ path , $ this -> preprocessData ( $ data ) , $ headers ) ) ; }
4921	public function region ( $ region , $ reset = false ) { $ this -> currentRegion = $ region ; if ( $ reset ) { $ this -> matrix [ $ this -> currentRegion ] = [ ] ; } return $ this ; }
2658	public function getResponse ( $ version , $ name ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/response_object/' . $ name ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: GET ) ; return $ result ; }
4523	protected function loadDefinition ( $ id ) { $ filename = $ this -> definitionPath . $ id . '.json' ; $ definition = @ file_get_contents ( $ filename ) ; if ( empty ( $ definition ) ) { throw new UnknownZoneException ( $ id ) ; } $ definition = json_decode ( $ definition , true ) ; $ definition [ 'id' ] = $ id ; return $ definition ; }
12008	public function getMessages ( $ domain = 'default' , $ locale = null ) { if ( $ locale === null ) { $ locale = $ this -> getLocale ( ) ; } if ( ! isset ( $ this -> messages [ $ domain ] [ $ locale ] ) ) { $ this -> loadMessages ( $ domain , $ locale ) ; } return $ this -> messages [ $ domain ] [ $ locale ] ; }
2078	public function purgePageCache ( ) { $ strCacheDir = StringUtil :: stripRootDir ( System :: getContainer ( ) -> getParameter ( 'kernel.cache_dir' ) ) ; $ objFolder = new Folder ( $ strCacheDir . '/http_cache' ) ; $ objFolder -> purge ( ) ; $ this -> log ( 'Purged the page cache' , __METHOD__ , TL_CRON ) ; }
12277	public function update ( $ groupId , $ name ) { $ params = [ 'group' => [ 'id' => $ groupId , 'name' => $ name , ] , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_UPDATE , $ params ] ) ; }
4612	public function prepare ( Command $ command , Node $ node ) { $ this -> setCommand ( $ command ) ; $ this -> setNode ( $ node ) ; return $ this ; }
3163	public function startTimer ( RunnerServiceContext $ context , $ timestamp = null ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ session = $ context -> getTestSession ( ) ; if ( $ session -> getState ( ) === AssessmentTestSessionState :: INTERACTING ) { $ session -> startItemTimer ( $ timestamp ) ; } } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'startTimer' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } return true ; }
10342	protected function isValidDate ( $ year , $ month , $ day ) { if ( $ month <= 0 || $ month > 12 || $ day <= 0 || $ day > 31 ) { return false ; } if ( ( $ month == 4 || $ month == 6 || $ month == 9 || $ month == 11 ) && ( $ day == 31 ) ) { return false ; } if ( $ month == 2 ) { if ( $ day > 29 ) { return false ; } $ leap = date ( 'L' , strtotime ( $ year . '-01-01' ) ) ; if ( $ leap === '0' && $ day > 28 ) { return false ; } } return true ; }
9260	private function isCacheable ( $ data ) { $ cacheable = true ; array_walk_recursive ( $ data , function ( $ value ) use ( & $ cacheable ) { if ( $ value instanceof \ Closure ) { $ cacheable = false ; } } ) ; return $ cacheable ; }
11790	public function clear ( $ name = null ) { if ( ! is_null ( $ name ) ) { $ name = strtolower ( $ name ) ; if ( array_key_exists ( $ name , self :: $ clearings ) ) { $ this -> { $ name } = self :: $ clearings [ $ self :: $ clearings ] ; } } else { foreach ( self :: $ clearings as $ n => $ v ) { $ this -> { $ n } = $ v ; } } return $ this ; }
3701	private function convertRenderGroupType ( $ type ) { $ lookup = [ 'char' => GroupAndSortingInformationInterface :: GROUP_CHAR , 'digit' => GroupAndSortingInformationInterface :: GROUP_DIGIT , 'day' => GroupAndSortingInformationInterface :: GROUP_DAY , 'weekday' => GroupAndSortingInformationInterface :: GROUP_WEEKDAY , 'week' => GroupAndSortingInformationInterface :: GROUP_WEEK , 'month' => GroupAndSortingInformationInterface :: GROUP_MONTH , 'year' => GroupAndSortingInformationInterface :: GROUP_YEAR , ] ; if ( array_key_exists ( $ type , $ lookup ) ) { return $ lookup [ $ type ] ; } return GroupAndSortingInformationInterface :: GROUP_NONE ; }
7687	function Misc_CellRef ( $ Col , $ Row ) { $ r = '' ; $ x = $ Col ; do { $ x = $ x - 1 ; $ c = ( $ x % 26 ) ; $ x = ( $ x - $ c ) / 26 ; $ r = chr ( 65 + $ c ) . $ r ; } while ( $ x > 0 ) ; return $ r . $ Row ; }
1111	public function map ( $ nodeList ) { $ self = $ this ; return $ this -> wrapInTransaction ( function ( ) use ( $ self , $ nodeList ) { forward_static_call ( array ( get_class ( $ self -> node ) , 'unguard' ) ) ; $ result = $ self -> mapTree ( $ nodeList ) ; forward_static_call ( array ( get_class ( $ self -> node ) , 'reguard' ) ) ; return $ result ; } ) ; }
12603	public static function read ( $ path ) { $ path = Path :: clean ( $ path ) ; if ( ! File :: exists ( $ path ) ) { return '' ; } return file_get_contents ( $ path ) ; }
8432	public function getDsn ( array $ info ) : string { $ dsn = 'pgsql:host=' ; $ dsn .= ( isset ( $ info [ 'host' ] ) === true ? $ info [ 'host' ] : 'localhost' ) . ';' ; if ( isset ( $ info [ 'port' ] ) === true ) { $ dsn .= 'port=' . $ info [ 'port' ] . ';' ; } $ dsn .= 'dbname=' . $ info [ 'name' ] . ';' ; return $ dsn ; }
10386	protected function createInitializer ( ) { $ initializer = new Initializer ( ) ; $ initializer -> addTemplate ( 'Common' , new CommonTemplate ( ) ) ; $ initializer -> addTemplate ( 'Laravel' , new LaravelTemplate ( ) ) ; $ initializer -> addTemplate ( 'Symfony' , new SymfonyTemplate ( ) ) ; $ initializer -> addTemplate ( 'Yii' , new YiiTemplate ( ) ) ; $ initializer -> addTemplate ( 'Yii2 Basic App' , new Yii2BasicAppTemplate ( ) ) ; $ initializer -> addTemplate ( 'Yii2 Advanced App' , new Yii2AdvancedAppTemplate ( ) ) ; return $ initializer ; }
1235	public function elementMeta ( $ elementName ) { $ class = get_class ( $ this ) ; if ( array_key_exists ( $ elementName , self :: $ properties [ $ class ] ) ) { $ info = self :: $ properties [ $ class ] [ $ elementName ] ; $ nameKey = $ info [ 'attribute' ] ? 'attributeName' : 'elementName' ; if ( array_key_exists ( $ nameKey , $ info ) ) { if ( $ info [ $ nameKey ] === $ elementName ) { $ meta = new \ stdClass ( ) ; $ meta -> propertyName = $ elementName ; $ meta -> phpType = $ info [ 'type' ] ; $ meta -> repeatable = $ info [ 'repeatable' ] ; $ meta -> attribute = $ info [ 'attribute' ] ; $ meta -> elementName = $ info [ $ nameKey ] ; $ meta -> strData = '' ; return $ meta ; } } } return null ; }
4841	public function fetch_sub_resource ( $ type , $ params = array ( ) ) { $ endpoint = preg_replace ( '/api\/v[0-9]+\//' , '' , parse_url ( $ this -> sub_resource_uris [ $ type ] , PHP_URL_PATH ) ) ; $ sub_resource_params = array ( ) ; if ( $ param_string = parse_url ( $ this -> sub_resource_uris [ $ type ] , PHP_URL_QUERY ) ) { $ split_params = explode ( '&' , $ param_string ) ; foreach ( $ split_params as $ split_param ) { $ parts = explode ( '=' , $ split_param ) ; $ sub_resource_params [ $ parts [ 0 ] ] = $ parts [ 1 ] ; } } $ params = array_merge ( $ params , $ sub_resource_params ) ; $ class = 'GoCardless_' . GoCardless_Utils :: camelize ( GoCardless_Utils :: singularize ( $ type ) ) ; $ objects = array ( ) ; foreach ( $ this -> client -> request ( 'get' , $ endpoint , $ params ) as $ value ) { $ objects [ ] = new $ class ( $ this -> client , $ value ) ; } return $ objects ; }
6820	protected function writeInvoiceTaxesLine ( ) { $ sale = $ this -> invoice -> getSale ( ) ; $ date = $ sale -> getCreatedAt ( ) ; $ credit = $ this -> invoice -> getType ( ) === InvoiceTypes :: TYPE_CREDIT ; foreach ( $ this -> invoice -> getTaxesDetails ( ) as $ detail ) { $ amount = $ this -> round ( $ detail [ 'amount' ] ) ; if ( 0 === $ this -> compare ( $ amount , 0 ) ) { continue ; } $ account = $ this -> getTaxAccountNumber ( $ detail [ 'rate' ] , $ this -> invoice -> getNumber ( ) ) ; if ( $ credit ) { $ this -> writer -> credit ( $ account , ( string ) $ amount , $ date ) ; $ this -> balance -= $ amount ; } else { $ this -> writer -> debit ( $ account , ( string ) $ amount , $ date ) ; $ this -> balance += $ amount ; } } }
10277	public static function getDefaultRowHeightByFont ( \ PhpOffice \ PhpSpreadsheet \ Style \ Font $ font ) { switch ( $ font -> getName ( ) ) { case 'Arial' : switch ( $ font -> getSize ( ) ) { case 10 : $ rowHeight = 12.75 ; break ; case 9 : $ rowHeight = 12 ; break ; case 8 : $ rowHeight = 11.25 ; break ; case 7 : $ rowHeight = 9 ; break ; case 6 : case 5 : $ rowHeight = 8.25 ; break ; case 4 : $ rowHeight = 6.75 ; break ; case 3 : $ rowHeight = 6 ; break ; case 2 : case 1 : $ rowHeight = 5.25 ; break ; default : $ rowHeight = 12.75 * $ font -> getSize ( ) / 10 ; break ; } break ; case 'Calibri' : switch ( $ font -> getSize ( ) ) { case 11 : $ rowHeight = 15 ; break ; case 10 : $ rowHeight = 12.75 ; break ; case 9 : $ rowHeight = 12 ; break ; case 8 : $ rowHeight = 11.25 ; break ; case 7 : $ rowHeight = 9 ; break ; case 6 : case 5 : $ rowHeight = 8.25 ; break ; case 4 : $ rowHeight = 6.75 ; break ; case 3 : $ rowHeight = 6.00 ; break ; case 2 : case 1 : $ rowHeight = 5.25 ; break ; default : $ rowHeight = 15 * $ font -> getSize ( ) / 11 ; break ; } break ; case 'Verdana' : switch ( $ font -> getSize ( ) ) { case 10 : $ rowHeight = 12.75 ; break ; case 9 : $ rowHeight = 11.25 ; break ; case 8 : $ rowHeight = 10.50 ; break ; case 7 : $ rowHeight = 9.00 ; break ; case 6 : case 5 : $ rowHeight = 8.25 ; break ; case 4 : $ rowHeight = 6.75 ; break ; case 3 : $ rowHeight = 6 ; break ; case 2 : case 1 : $ rowHeight = 5.25 ; break ; default : $ rowHeight = 12.75 * $ font -> getSize ( ) / 10 ; break ; } break ; default : $ rowHeight = 15 * $ font -> getSize ( ) / 11 ; break ; } return $ rowHeight ; }
10872	public function existEmail ( string $ email ) : int { return ( int ) $ this -> connection -> select ( self :: COLUMN_ID ) -> from ( $ this -> tableIdentity ) -> where ( [ 'email' => $ email ] ) -> fetchSingle ( ) ; }
3876	private function getMetaModelsPages ( $ config , $ rootPage = null , $ language = null ) { $ metaModelsIdentifier = $ config [ 'pid' ] ; $ filterIdentifier = $ config [ 'filter' ] ; $ presetParams = StringUtil :: deserialize ( $ config [ 'filterparams' ] , true ) ; $ renderSettingId = $ config [ 'rendersetting' ] ; $ metaModels = $ this -> getMetaModel ( $ metaModelsIdentifier , false ) ; $ availableLanguages = $ this -> getLanguage ( $ language , $ metaModels ) ; $ currentLanguage = $ GLOBALS [ 'TL_LANGUAGE' ] ; foreach ( $ availableLanguages as $ newLanguage ) { $ GLOBALS [ 'TL_LANGUAGE' ] = $ newLanguage ; $ view = $ this -> getView ( $ metaModelsIdentifier , $ renderSettingId ) ; $ jumpTos = $ view -> get ( 'jumpTo' ) ; $ processed = $ this -> setFilterParameters ( $ filterIdentifier , $ presetParams , array ( ) ) ; $ filter = $ metaModels -> getEmptyFilter ( ) ; $ filterSetting = $ this -> getFilterSettings ( $ filterIdentifier ) ; $ filterSetting -> addRules ( $ filter , $ processed ) ; $ newEntries = $ this -> getJumpTosFor ( $ metaModels , $ filter , $ view , $ rootPage ) ; $ this -> removeEmptyDetailPages ( $ jumpTos ) ; $ GLOBALS [ 'TL_LANGUAGE' ] = $ currentLanguage ; $ this -> foundPages = array_merge ( $ this -> foundPages , $ newEntries ) ; } $ GLOBALS [ 'TL_LANGUAGE' ] = $ currentLanguage ; }
526	public function init ( ) { if ( $ this -> sourcePath !== null ) { $ this -> sourcePath = rtrim ( Yii :: getAlias ( $ this -> sourcePath ) , '/\\' ) ; } if ( $ this -> basePath !== null ) { $ this -> basePath = rtrim ( Yii :: getAlias ( $ this -> basePath ) , '/\\' ) ; } if ( $ this -> baseUrl !== null ) { $ this -> baseUrl = rtrim ( Yii :: getAlias ( $ this -> baseUrl ) , '/' ) ; } }
5167	protected function filterDateInstance ( $ date ) : string { if ( empty ( $ date ) ) { $ date = new \ DateTime ( 'now' , new \ DateTimeZone ( 'Asia/Jakarta' ) ) ; } if ( is_string ( $ date ) || is_int ( $ date ) ) { $ date = new \ DateTime ( $ date , new \ DateTimeZone ( 'Asia/Jakarta' ) ) ; } return $ this -> formatDate ( $ date ) ; }
3288	private function readDataFromPendingClient ( $ socket , int $ length , PendingSocketClient $ state ) { $ data = \ fread ( $ socket , $ length ) ; if ( $ data === false || $ data === '' ) { return null ; } $ data = $ state -> receivedDataBuffer . $ data ; if ( \ strlen ( $ data ) < $ length ) { $ state -> receivedDataBuffer = $ data ; return null ; } $ state -> receivedDataBuffer = '' ; Loop :: cancel ( $ state -> readWatcher ) ; return $ data ; }
10821	public static function title ( $ messages , $ linebreak = true , $ length = 0 ) { $ separator = $ linebreak ? "\n" : '' ; self :: write ( $ messages , 'title' , $ length , $ separator ) ; }
11186	public function setPrivateChatUpdateRead ( Neuron_GameServer_Player $ from , Neuron_GameServer_Player $ target ) { $ db = Neuron_DB_Database :: getInstance ( ) ; $ db -> query ( " UPDATE n_privatechat_updates SET pu_read = '1' WHERE pu_to = {$target->getId ()} AND pu_from = {$from->getId ()} " ) ; }
3328	private function getPriceConfigurations ( ) { static $ priceConfigurations ; if ( null === $ priceConfigurations ) { $ priceConfigurations = $ this -> itemsSalesPricesApi -> findAll ( ) ; $ shopIdentities = $ this -> identityService -> findBy ( [ 'adapterName' => PlentymarketsAdapter :: NAME , 'objectType' => Shop :: TYPE , ] ) ; $ shopIdentities = array_filter ( $ shopIdentities , function ( Identity $ identity ) { $ isMappedIdentity = $ this -> identityService -> isMappedIdentity ( $ identity -> getObjectIdentifier ( ) , $ identity -> getObjectType ( ) , $ identity -> getAdapterName ( ) ) ; if ( ! $ isMappedIdentity ) { return false ; } return true ; } ) ; if ( empty ( $ shopIdentities ) ) { $ priceConfigurations = [ ] ; return $ priceConfigurations ; } $ priceConfigurations = array_filter ( $ priceConfigurations , function ( $ priceConfiguration ) use ( $ shopIdentities ) { foreach ( $ shopIdentities as $ identity ) { foreach ( ( array ) $ priceConfiguration [ 'clients' ] as $ client ) { if ( $ client [ 'plentyId' ] === - 1 || $ identity -> getAdapterIdentifier ( ) === ( string ) $ client [ 'plentyId' ] ) { return true ; } } } return false ; } ) ; if ( empty ( $ priceConfigurations ) ) { $ this -> logger -> notice ( 'no valid price configuration found' ) ; } } return $ priceConfigurations ; }
2219	public static function countPublishedByPids ( $ arrPids , $ blnFeatured = null , array $ arrOptions = array ( ) ) { if ( empty ( $ arrPids ) || ! \ is_array ( $ arrPids ) ) { return 0 ; } $ t = static :: $ strTable ; $ arrColumns = array ( "$t.pid IN(" . implode ( ',' , array_map ( '\intval' , $ arrPids ) ) . ")" ) ; if ( $ blnFeatured === true ) { $ arrColumns [ ] = "$t.featured='1'" ; } elseif ( $ blnFeatured === false ) { $ arrColumns [ ] = "$t.featured=''" ; } if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } return static :: countBy ( $ arrColumns , null , $ arrOptions ) ; }
3531	public static function sendFortniteGetRequest ( $ endpoint , $ access_token , $ extra_headers = array ( ) ) { $ client = new Client ( ) ; $ headers = [ 'User-Agent' => self :: FORTNITE_USER_AGENT , 'Authorization' => 'bearer ' . $ access_token ] ; $ headers = array_merge ( $ headers , $ extra_headers ) ; try { $ response = $ client -> get ( $ endpoint , [ 'headers' => $ headers ] ) ; return json_decode ( $ response -> getBody ( ) -> getContents ( ) ) ; } catch ( GuzzleException $ e ) { throw $ e ; } }
1678	protected function getSize ( ) { $ intSize = 0 ; foreach ( scan ( $ this -> strRootDir . '/' . $ this -> strFolder , true ) as $ strFile ) { if ( strncmp ( $ strFile , '.' , 1 ) === 0 ) { continue ; } if ( is_dir ( $ this -> strRootDir . '/' . $ this -> strFolder . '/' . $ strFile ) ) { $ objFolder = new self ( $ this -> strFolder . '/' . $ strFile ) ; $ intSize += $ objFolder -> size ; } else { $ objFile = new File ( $ this -> strFolder . '/' . $ strFile ) ; $ intSize += $ objFile -> size ; } } return $ intSize ; }
11127	protected function renderView ( $ view , $ data ) { try { return parent :: renderView ( $ view , $ data ) ; } catch ( \ InvalidArgumentException $ e ) { return static :: applyDataToView ( $ view , $ data ) ; } }
10339	public static function checkString ( $ pValue ) { if ( $ pValue instanceof RichText ) { return $ pValue ; } $ pValue = StringHelper :: substring ( $ pValue , 0 , 32767 ) ; $ pValue = str_replace ( [ "\r\n" , "\r" ] , "\n" , $ pValue ) ; return $ pValue ; }
9359	protected function finalize ( $ function ) { $ response = $ this -> container -> get ( self :: RESPONSE ) ; if ( is_string ( $ function ) === true ) { $ stream = $ response -> getBody ( ) ; $ stream -> write ( ( string ) $ function ) ; } $ instanceof = $ function instanceof ResponseInterface ; return $ instanceof ? $ function : $ response ; }
5842	public function getAdditionalFields ( array & $ taskInfo , $ task , \ TYPO3 \ CMS \ Scheduler \ Controller \ SchedulerModuleController $ parentObject ) { $ editCommand = version_compare ( TYPO3_branch , '9.5' , '>=' ) ? $ parentObject -> getCurrentAction ( ) === Action :: EDIT : $ parentObject -> CMD === 'edit' ; if ( ! isset ( $ taskInfo [ 'scheduler_batchResize_directories' ] ) ) { $ taskInfo [ 'scheduler_batchResize_directories' ] = $ this -> defaultDirectories ; if ( $ editCommand ) { $ taskInfo [ 'scheduler_batchResize_directories' ] = $ task -> directories ; } } if ( ! isset ( $ taskInfo [ 'scheduler_batchResize_excludeDirectories' ] ) ) { $ taskInfo [ 'scheduler_batchResize_excludeDirectories' ] = $ this -> defaultExcludeDirectories ; if ( $ editCommand ) { $ taskInfo [ 'scheduler_batchResize_excludeDirectories' ] = $ task -> excludeDirectories ; } } $ additionalFields = [ ] ; $ fieldName = 'tx_scheduler[scheduler_batchResize_directories]' ; $ fieldId = 'scheduler_batchResize_directories' ; $ fieldValue = trim ( $ taskInfo [ 'scheduler_batchResize_directories' ] ) ; $ fieldHtml = '<textarea class="form-control" rows="4" name="' . $ fieldName . '" id="' . $ fieldId . '">' . htmlspecialchars ( $ fieldValue ) . '</textarea>' ; $ additionalFields [ $ fieldId ] = [ 'code' => $ fieldHtml , 'label' => 'LLL:EXT:image_autoresize/Resources/Private/Language/locallang_mod.xlf:label.batchResize.directories' , ] ; $ fieldName = 'tx_scheduler[scheduler_batchResize_excludeDirectories]' ; $ fieldId = 'scheduler_batchResize_excludeDirectories' ; $ fieldValue = trim ( $ taskInfo [ 'scheduler_batchResize_excludeDirectories' ] ) ; $ fieldHtml = '<textarea class="form-control" rows="4" name="' . $ fieldName . '" id="' . $ fieldId . '">' . htmlspecialchars ( $ fieldValue ) . '</textarea>' ; $ additionalFields [ $ fieldId ] = [ 'code' => $ fieldHtml , 'label' => 'LLL:EXT:image_autoresize/Resources/Private/Language/locallang_mod.xlf:label.batchResize.excludeDirectories' , ] ; return $ additionalFields ; }
2349	public function renameTo ( $ strNewName ) { $ strParent = \ dirname ( $ strNewName ) ; if ( ! is_dir ( $ this -> strRootDir . '/' . $ strParent ) ) { new Folder ( $ strParent ) ; } $ return = $ this -> Files -> rename ( $ this -> strFile , $ strNewName ) ; $ syncSource = Dbafs :: shouldBeSynchronized ( $ this -> strFile ) ; $ syncTarget = Dbafs :: shouldBeSynchronized ( $ strNewName ) ; if ( $ syncSource && $ syncTarget ) { $ this -> objModel = Dbafs :: moveResource ( $ this -> strFile , $ strNewName ) ; } elseif ( $ syncSource ) { $ this -> objModel = Dbafs :: deleteResource ( $ this -> strFile ) ; } elseif ( $ syncTarget ) { $ this -> objModel = Dbafs :: addResource ( $ strNewName ) ; } if ( $ return != false ) { $ this -> strFile = $ strNewName ; $ this -> arrImageSize = array ( ) ; $ this -> arrPathinfo = array ( ) ; } return $ return ; }
4857	public function getParams ( $ namespace , $ defaults , $ params = null ) { $ session = new Container ( $ namespace ) ; $ sessionParams = $ session -> params ? : array ( ) ; $ params = $ params ? : clone $ this -> getController ( ) -> getRequest ( ) -> getQuery ( ) ; if ( $ params -> get ( 'clear' ) ) { $ sessionParams = array ( ) ; unset ( $ params [ 'clear' ] ) ; } $ changed = false ; foreach ( $ defaults as $ key => $ default ) { if ( is_numeric ( $ key ) ) { $ key = $ default ; $ default = null ; } $ value = $ params -> get ( $ key ) ; if ( null === $ value ) { if ( isset ( $ sessionParams [ $ key ] ) ) { $ params -> set ( $ key , $ sessionParams [ $ key ] ) ; } elseif ( null !== $ default ) { $ params -> set ( $ key , $ default ) ; $ sessionParams [ $ key ] = $ default ; $ changed = true ; } } else { if ( ! isset ( $ sessionParams [ $ key ] ) || $ sessionParams [ $ key ] != $ value ) { $ changed = true ; $ sessionParams [ $ key ] = $ value ; } } } if ( $ changed ) { unset ( $ session -> list ) ; $ session -> params = $ sessionParams ; } return $ params ; }
1778	public static function optionChecked ( $ strOption , $ varValues ) { if ( $ strOption === '' ) { return '' ; } return ( \ is_array ( $ varValues ) ? \ in_array ( $ strOption , $ varValues ) : $ strOption == $ varValues ) ? ' checked' : '' ; }
5544	public function getRaw ( ) { if ( is_integer ( $ this -> focus ) ) { return $ this -> frames [ $ this -> focus ] -> getRaw ( ) ; } $ raw = '' ; for ( $ i = 0 ; $ i < count ( $ this -> frames ) ; $ i ++ ) { $ raw .= $ this -> frames [ $ i ] -> getRaw ( ) ; } return $ raw ; }
5666	private function attachLabels ( $ widgets_by_id , $ labels ) { foreach ( $ labels as $ label ) { $ for = $ label -> getFor ( ) ; if ( $ for and isset ( $ widgets_by_id [ $ for ] ) ) { $ text = $ label -> getText ( ) ; foreach ( $ widgets_by_id [ $ for ] as $ widget ) { $ widget -> setLabel ( $ text ) ; } } } }
452	public function update ( $ table , $ columns , $ condition , & $ params ) { list ( $ lines , $ params ) = $ this -> prepareUpdateSets ( $ table , $ columns , $ params ) ; $ sql = 'UPDATE ' . $ this -> db -> quoteTableName ( $ table ) . ' SET ' . implode ( ', ' , $ lines ) ; $ where = $ this -> buildWhere ( $ condition , $ params ) ; return $ where === '' ? $ sql : $ sql . ' ' . $ where ; }
7361	protected function updateWeightTotal ( SaleInterface $ sale ) { $ weightTotal = $ this -> weightCalculator -> calculateSale ( $ sale ) ; if ( $ sale -> getWeightTotal ( ) != $ weightTotal ) { $ sale -> setWeightTotal ( $ weightTotal ) ; return true ; } return false ; }
8315	protected function checkResetLink ( ) { if ( ! $ this -> config [ "enabled" ] || ! ( $ token = $ this -> httpRequest -> query -> get ( "confirm" , false ) ) || ! preg_match ( "/^[a-f0-9]+$/" , $ token ) || strlen ( $ token ) !== 2 * ( $ this -> config [ "tokenIdLen" ] + $ this -> config [ "tokenLen" ] ) ) { return ; } $ this -> session -> remove ( "pwreset" ) ; $ tokenId = substr ( $ token , 0 , 2 * $ this -> config [ "tokenIdLen" ] ) ; $ verifier = substr ( $ token , 2 * $ this -> config [ "tokenIdLen" ] ) ; $ tokenData = $ this -> storage -> getResetToken ( $ tokenId ) ; if ( ! $ tokenData || time ( ) > $ tokenData [ 'valid' ] ) { $ this -> session -> addFlash ( "error" , "Reset link has expired." ) ; $ this -> getLogger ( ) -> warning ( "Bad reset token {t} from {addr}" , [ $ token , $ _SERVER [ 'REMOTE_ADDR' ] ] ) ; $ this -> picoAuth -> redirectToPage ( "password_reset" ) ; } if ( hash_equals ( $ tokenData [ 'token' ] , hash ( 'sha256' , $ verifier ) ) ) { $ this -> session -> addFlash ( "success" , "Please set a new password." ) ; $ this -> startPasswordResetSession ( $ tokenData [ 'user' ] ) ; $ this -> logResetLinkVisit ( $ tokenData ) ; $ this -> picoAuth -> redirectToPage ( "password_reset" ) ; } }
10249	public function getDate ( $ params = [ ] , $ format = 'Y-m-d' ) { foreach ( $ params as $ k => $ v ) { $ $ k = $ v ; } if ( ! isset ( $ min_year ) ) { $ min_year = date ( 'Y' ) - 2 ; } if ( ! isset ( $ max_year ) ) { $ max_year = date ( 'Y' ) ; } if ( ! isset ( $ min_month ) ) { $ min_month = 1 ; } if ( ! isset ( $ max_month ) ) { $ max_month = 12 ; } $ rand_year = rand ( $ min_year , $ max_year ) ; $ rand_month = rand ( $ min_month , $ max_month ) ; $ date = DateTime :: createFromFormat ( 'Y-m-d' , join ( '-' , [ $ rand_year , $ rand_month , '01' ] ) ) ; $ days_in_month = $ date -> format ( 't' ) ; $ rand_day = rand ( 1 , $ days_in_month ) ; return DateTime :: createFromFormat ( 'Y-m-d' , join ( '-' , [ $ rand_year , $ rand_month , $ rand_day ] ) ) -> format ( $ format ) ; }
2972	protected function determineContext ( array & $ data ) { $ refs = 0 ; $ vars = array_map ( function ( $ node ) use ( & $ refs ) { if ( $ node -> byRef ) { $ refs ++ ; } if ( $ node -> var instanceof VariableNode ) { return $ node -> var -> name ; } else { return $ node -> var ; } } , $ data [ 'ast' ] -> uses ) ; $ data [ 'hasRefs' ] = ( $ refs > 0 ) ; $ values = $ data [ 'reflection' ] -> getStaticVariables ( ) ; foreach ( $ vars as $ name ) { if ( isset ( $ values [ $ name ] ) ) { $ data [ 'context' ] [ $ name ] = $ values [ $ name ] ; } } }
12936	private function moveArchiveDir ( $ archiveSourceFile , $ archiveTargetFile , $ blockName , $ slotName ) { if ( ! is_dir ( $ archiveSourceFile ) ) { return ; } $ this -> filesystem -> mirror ( $ archiveSourceFile , $ archiveTargetFile ) ; $ this -> filesystem -> remove ( $ archiveSourceFile ) ; $ historyChanged = array ( ) ; $ historyFile = $ archiveTargetFile . '/history.json' ; $ history = json_decode ( file_get_contents ( $ historyFile ) , true ) ; foreach ( $ history as $ key => $ values ) { $ values [ "name" ] = $ blockName ; $ values [ "slot_name" ] = $ slotName ; $ historyChanged [ $ key ] = $ values ; } file_put_contents ( $ historyFile , json_encode ( $ historyChanged ) ) ; }
3539	public static function getAdldapProvider ( ) { if ( static :: getExtensionOptions ( 'adldap-providername' ) != '__USE_DEFAULT_PROVIDER__' ) { $ provider = Yii :: $ app -> ad -> getProvider ( static :: getExtensionOptions ( 'adldap-providername' ) ) ; } else { $ provider = Yii :: $ app -> ad -> getDefaultProvider ( ) ; } return $ provider ; }
2204	public static function encodeSpecialChars ( $ varValue ) { if ( $ varValue === null || $ varValue == '' ) { return $ varValue ; } if ( \ is_array ( $ varValue ) ) { foreach ( $ varValue as $ k => $ v ) { $ varValue [ $ k ] = static :: encodeSpecialChars ( $ v ) ; } return $ varValue ; } $ arrSearch = array ( '#' , '<' , '>' , '(' , ')' , '\\' , '=' ) ; $ arrReplace = array ( '&#35;' , '&#60;' , '&#62;' , '&#40;' , '&#41;' , '&#92;' , '&#61;' ) ; return str_replace ( $ arrSearch , $ arrReplace , $ varValue ) ; }
8850	public function rss ( ) { $ rss = new RSSFeed ( $ this -> getBlogPosts ( ) , $ this -> Link ( ) , $ this -> MetaTitle , $ this -> MetaDescription ) ; $ this -> extend ( 'updateRss' , $ rss ) ; return $ rss -> outputToBrowser ( ) ; }
6270	private function matchesAcademicDomain ( $ domain ) { if ( empty ( $ domain [ 'tld' ] ) or empty ( $ domain [ 'sld' ] ) ) { return false ; } return file_exists ( $ this -> getPath ( $ domain ) ) ; }
3480	public function withLaunchImage ( string $ launchImage ) : Alert { $ cloned = clone $ this ; $ cloned -> launchImage = $ launchImage ; return $ cloned ; }
3710	protected function getFilters ( ) { $ filterOptions = $ this -> getFrontendFilterOptions ( ) ; $ jumpToInformation = $ this -> objFilterConfig -> getJumpTo ( ) ; $ filterSetting = $ this -> objFilterConfig -> getFilterCollection ( ) ; $ wantedNames = $ this -> getWantedNames ( ) ; $ this -> buildParameters ( $ other = new FilterUrl ( $ jumpToInformation ) , $ all = new FilterUrl ( $ jumpToInformation ) , $ wantedNames ) ; foreach ( $ wantedNames as $ name ) { if ( $ all -> hasSlug ( $ name ) ) { Input :: get ( $ name ) ; } } $ arrWidgets = $ filterSetting -> getParameterFilterWidgets ( $ all -> getSlugParameters ( ) , $ jumpToInformation , $ filterOptions ) ; if ( Input :: post ( 'FORM_SUBMIT' ) === $ this -> formId ) { foreach ( $ wantedNames as $ widgetName ) { $ filter = $ arrWidgets [ $ widgetName ] ; if ( null !== $ filter [ 'urlvalue' ] ) { $ other -> setSlug ( $ widgetName , $ filter [ 'urlvalue' ] ) ; } } throw new RedirectResponseException ( $ this -> filterUrlBuilder -> generate ( $ other ) ) ; } $ renderedWidgets = [ ] ; foreach ( $ wantedNames as $ strWidget ) { $ renderedWidgets [ $ strWidget ] = $ this -> renderWidget ( $ arrWidgets [ $ strWidget ] , $ filterOptions ) ; } return [ 'action' => $ this -> filterUrlBuilder -> generate ( $ other ) , 'formid' => $ this -> formId , 'filters' => $ renderedWidgets , 'submit' => ( $ filterOptions -> isAutoSubmit ( ) ? '' : $ GLOBALS [ 'TL_LANG' ] [ 'metamodels_frontendfilter' ] [ 'submit' ] ) ] ; }
4715	public function split ( $ pattern , $ flags = PREG_SPLIT_DELIM_CAPTURE ) { return new Collection ( array_map ( function ( $ item ) { return new static ( $ item ) ; } , preg_split ( $ pattern , $ this -> text , - 1 , $ flags ) ) ) ; }
10714	public function updateById ( $ id , array $ newAttributes ) { $ model = $ this -> getById ( $ id ) ; $ results = $ model -> update ( $ newAttributes ) ; if ( ! $ results ) { throw new UpdateFailedRepositoryException ( ) ; } return $ model ; }
1567	public function getType ( ) : string { if ( $ resource = $ this -> getResource ( ) ) { return get_class ( $ resource ) ; } $ resourceType = $ this -> getResourceType ( ) ; if ( ! $ type = $ this -> resolver -> getType ( $ resourceType ) ) { throw new RuntimeException ( "JSON API resource type {$resourceType} is not registered." ) ; } return $ type ; }
3155	public function storeOutcomeVariable ( RunnerServiceContext $ context , $ itemUri , $ variableIdentifier , $ variableValue ) { $ this -> assertQtiRunnerServiceContext ( $ context ) ; $ metaVariable = $ this -> getOutcomeVariable ( $ variableIdentifier , $ variableValue ) ; return $ this -> storeVariable ( $ context , $ itemUri , $ metaVariable ) ; }
8151	public function hasExtension ( $ class ) { $ class = ltrim ( $ class , '\\' ) ; if ( ! isset ( $ this -> extensionsByClass [ $ class ] ) && class_exists ( $ class , false ) ) { $ class = new ReflectionClass ( $ class ) ; $ class = $ class -> name ; } if ( isset ( $ this -> extensions [ $ class ] ) ) { if ( $ class !== get_class ( $ this -> extensions [ $ class ] ) ) { @ trigger_error ( sprintf ( 'Referencing the "%s" extension by its name (defined by getName()) is deprecated since 1.26 and will be removed in Twig 2.0. Use the Fully Qualified Extension Class Name instead.' , $ class ) , E_USER_DEPRECATED ) ; } return true ; } return isset ( $ this -> extensionsByClass [ $ class ] ) ; }
9592	public function checkboxFilled ( $ options = [ ] , $ enclosedByLabel = true ) { Html :: addCssClass ( $ options , $ this -> checkboxFilledCssClass ) ; return parent :: checkbox ( $ options , $ enclosedByLabel ) ; }
12344	public function showAction ( Post $ post ) { $ deleteForm = $ this -> createDeleteForm ( $ post ) ; return array ( 'entity' => $ post , 'delete_form' => $ deleteForm -> createView ( ) , ) ; }
2442	protected function getUser ( ) : BackendUser { if ( null === $ this -> tokenStorage ) { throw new \ RuntimeException ( 'No token storage provided' ) ; } $ token = $ this -> tokenStorage -> getToken ( ) ; if ( null === $ token ) { throw new \ RuntimeException ( 'No token provided' ) ; } $ user = $ token -> getUser ( ) ; if ( ! $ user instanceof BackendUser ) { throw new \ RuntimeException ( 'The token does not contain a back end user object' ) ; } return $ user ; }
12207	public function refresh ( ) { if ( null === $ this -> options || null === $ this -> sourceDir ) { return ; } $ this -> render ( $ this -> sourceDir , $ this -> options , $ this -> username ) ; }
6686	public function showFlashMessages ( $ sticky = false ) { $ timeout = $ sticky ? 0 : 5000 ; $ flashMessages = [ ] ; $ allMessages = $ this -> getSession ( ) -> getAllFlashes ( ) ; foreach ( $ allMessages as $ key => $ message ) { if ( is_array ( $ message ) ) { $ message = $ this -> mergeFlashMessages ( $ message ) ; } $ flashMessages [ ] = [ 'message' => $ message , 'type' => $ key , 'timeout' => $ timeout ] ; } $ this -> getSession ( ) -> removeAllFlashes ( ) ; return Html :: script ( 'var notifications =' . json_encode ( $ flashMessages ) ) ; }
11220	private static function cleanResources ( ) { self :: $ callbacks = [ ] ; self :: $ methods = [ ] ; self :: $ halts = false ; self :: $ response = false ; }
7813	public static function toGregorianStr ( $ j_date , $ sep = '/' ) { $ arr = explode ( $ sep , $ j_date ) ; if ( count ( $ arr ) < 3 || intval ( $ arr [ 0 ] ) == 0 ) return "" ; else $ g_date = jDateTime :: toGregorian ( $ arr [ 2 ] , $ arr [ 1 ] , $ arr [ 0 ] ) ; return implode ( $ sep , $ g_date ) ; }
10326	function addRule ( $ rule ) { if ( ! $ this -> rules ) $ this -> rules = array ( ) ; array_push ( $ this -> rules , $ rule ) ; }
7203	public function addDiscountAdjustment ( Adjustment $ discount ) : void { foreach ( $ this -> discounts as $ d ) { if ( $ d -> isSameAs ( $ discount ) ) { $ d -> addAmount ( $ discount -> getAmount ( ) ) ; return ; } } $ this -> discounts [ ] = clone $ discount ; }
8039	public function buildEventData ( array $ data ) { $ start = strtotime ( $ data [ 'start' ] [ 'date' ] . ' ' . $ data [ 'start' ] [ 'time' ] ) ; $ start = date ( 'Y-m-d H:i:s' , $ start ) ; $ end = null ; if ( array_key_exists ( 'end' , $ data ) ) { $ end = strtotime ( $ data [ 'end' ] [ 'date' ] . ' ' . $ data [ 'end' ] [ 'time' ] ) ; $ end = date ( 'Y-m-d H:i:s' , $ end ) ; if ( strtotime ( $ end ) < strtotime ( $ start ) ) { throw new DateDifferenceException ( 'Start date bigger then end date!' ) ; } } $ event = [ 'title' => $ data [ 'title' ] , 'description' => $ data [ 'description' ] , 'start' => $ start , 'end' => $ end , 'all_day' => array_key_exists ( 'all_day' , $ data ) , 'border_color' => $ data [ 'border_color' ] , 'background_color' => $ data [ 'background_color' ] , 'text_color' => $ data [ 'text_color' ] , ] ; return $ event ; }
4571	public function setAnonymousUuid ( ? string $ anonymousUuid ) { $ this -> anonymousUuid = $ anonymousUuid ; $ this -> _anonymousUuid = true ; return $ this ; }
8568	public function setCategoryQueryList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'CategoryQueryList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
8318	public function minLength ( $ n ) { $ this -> constraints [ ] = ( function ( Password $ str ) use ( $ n ) { if ( mb_strlen ( $ str ) < $ n ) { return sprintf ( "Minimum password length is %d characters." , $ n ) ; } else { return true ; } } ) ; return $ this ; }
9265	public function setProviders ( ) { $ services = $ this -> container [ 'services' ] ?? null ; if ( is_array ( $ services ) ) { foreach ( $ services as $ service ) { $ service :: register ( $ this -> container ) ; $ service :: boot ( $ this -> container ) ; } } }
6761	public function find ( $ criteria ) { if ( ! $ criteria ) { error_log ( "collection error: no criteria specified" ) ; return null ; } else if ( is_callable ( $ criteria ) ) { foreach ( $ this -> models as $ model ) if ( $ criteria ( $ model ) ) return $ model ; } else if ( is_a ( $ criteria , "SnooPHP\Model\Model" ) ) { foreach ( $ this -> models as $ i => $ model ) if ( $ model == $ criteria ) return $ i ; } return null ; }
2775	public function streamOutput ( bool $ streamOutput = true ) : void { if ( $ streamOutput && ! isset ( $ this -> gitOutputListener ) ) { $ this -> gitOutputListener = new GitOutputStreamListener ( ) ; $ this -> addOutputListener ( $ this -> gitOutputListener ) ; } if ( ! $ streamOutput && isset ( $ this -> gitOutputListener ) ) { $ this -> removeOutputListener ( $ this -> gitOutputListener ) ; unset ( $ this -> gitOutputListener ) ; } }
3001	public function setHTML ( $ message ) { $ f3 = \ Base :: instance ( ) ; $ tmpl = new \ Template ( ) ; if ( $ f3 -> exists ( 'mailer.jumplinks' , $ jumplink ) && $ jumplink ) $ tmpl -> extend ( 'a' , function ( $ node ) use ( $ f3 , $ tmpl ) { if ( isset ( $ node [ '@attrib' ] ) ) { $ attr = $ node [ '@attrib' ] ; unset ( $ node [ '@attrib' ] ) ; } else $ attr = array ( ) ; if ( isset ( $ attr [ 'href' ] ) ) { if ( ! $ f3 -> exists ( 'mailer.jump_route' , $ ping_route ) ) $ ping_route = '/mailer-jump' ; $ attr [ 'href' ] = $ f3 -> get ( 'SCHEME' ) . '://' . $ f3 -> get ( 'HOST' ) . $ f3 -> get ( 'BASE' ) . $ ping_route . '?target=' . urlencode ( $ attr [ 'href' ] ) ; } $ params = '' ; foreach ( $ attr as $ key => $ value ) $ params .= ' ' . $ key . '="' . $ value . '"' ; return '<a' . $ params . '>' . $ tmpl -> build ( $ node ) . '</a>' ; } ) ; $ message = $ tmpl -> build ( $ tmpl -> parse ( $ message ) ) ; $ this -> setContent ( $ message , 'text/html' ) ; }
6565	public static function register ( $ prepend = true , $ callback = null , $ app = null ) { if ( ! static :: $ registered ) { static :: $ registered = spl_autoload_register ( array ( '\\Sbp\\Laravel\\ClassLoader' , 'load' ) , true , $ prepend ) ; if ( is_null ( $ app ) ) { $ app = __DIR__ . '/../../../../../../app' ; } if ( ! file_exists ( $ app . '/storage' ) || ! is_writable ( $ app . '/storage' ) ) { throw new SbpException ( "Laravel app and/or writable storage directory not found at $app, please specify the path with the following code:\nSbp\\Laravel\\ClassLoader::register(true, 'sha1', \$laravelAppPath)" ) ; } Sbp :: writeIn ( Sbp :: SAME_DIR ) ; Sbp :: fileExists ( $ app . '/routes' ) ; $ storage = $ app . '/storage/sbp' ; if ( ! file_exists ( $ storage ) ) { if ( mkdir ( $ storage , 0777 ) ) { file_put_contents ( $ storage . '/.gitignore' , "*\n!.gitignore" ) ; } } Sbp :: writeIn ( $ storage , $ callback ) ; } }
1415	public function invalidResource ( string $ path , ? string $ detail = null , array $ failed = [ ] ) : ErrorInterface { return new Error ( null , null , Response :: HTTP_UNPROCESSABLE_ENTITY , $ this -> trans ( 'resource_invalid' , 'code' ) , $ this -> trans ( 'resource_invalid' , 'title' ) , $ detail ? : $ this -> trans ( 'resource_invalid' , 'detail' ) , $ this -> pointer ( $ path ) , $ failed ? compact ( 'failed' ) : null ) ; }
510	public function actionList ( ) { foreach ( $ this -> getCommandDescriptions ( ) as $ command => $ description ) { $ result = Yii :: $ app -> createController ( $ command ) ; if ( $ result === false || ! ( $ result [ 0 ] instanceof Controller ) ) { continue ; } list ( $ controller , $ actionID ) = $ result ; $ actions = $ this -> getActions ( $ controller ) ; if ( ! empty ( $ actions ) ) { $ prefix = $ controller -> getUniqueId ( ) ; $ this -> stdout ( "$prefix\n" ) ; foreach ( $ actions as $ action ) { $ this -> stdout ( "$prefix/$action\n" ) ; } } } }
3226	function move ( $ fromPath , $ toPath ) { Path :: checkArgNonRoot ( "fromPath" , $ fromPath ) ; Path :: checkArgNonRoot ( "toPath" , $ toPath ) ; $ response = $ this -> doPost ( $ this -> apiHost , "1/fileops/move" , array ( "root" => "auto" , "from_path" => $ fromPath , "to_path" => $ toPath , ) ) ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; return RequestUtil :: parseResponseJson ( $ response -> body ) ; }
1831	public function detach ( $ blnKeepClone = true ) { $ registry = Registry :: getInstance ( ) ; if ( ! $ registry -> isRegistered ( $ this ) ) { return ; } $ registry -> unregister ( $ this ) ; if ( $ blnKeepClone ) { $ this -> cloneOriginal ( ) -> attach ( ) ; } }
9235	public function actionCreate ( ) { $ model = new Banner ( ) ; $ model -> time = date ( "Y-m-d H:i:s" ) ; $ model -> position = $ model -> getLast ( ) ; $ model -> isdel = 0 ; $ post = Yii :: $ app -> request -> post ( ) ; if ( isset ( $ post [ 'Banner' ] [ 'tags' ] ) ) { if ( is_array ( $ post [ 'Banner' ] [ 'tags' ] ) ) { $ post [ 'Banner' ] [ 'tags' ] = implode ( "," , $ post [ 'Banner' ] [ 'tags' ] ) ; } } $ transaction = Yii :: $ app -> db -> beginTransaction ( ) ; try { if ( $ model -> load ( $ post ) && $ model -> save ( ) ) { $ model -> updatePosition ( $ model -> position ) ; $ transaction -> commit ( ) ; return $ this -> redirect ( [ 'view' , 'id' => $ model -> id ] ) ; } else { $ transaction -> rollBack ( ) ; } } catch ( Exception $ e ) { $ transaction -> rollBack ( ) ; } return $ this -> render ( 'create' , [ 'model' => $ model , ] ) ; }
5076	public function getIndex ( $ aData = [ ] , $ iPage = null , $ iPerPage = null ) { $ oInput = Factory :: service ( 'Input' ) ; $ oItemModel = Factory :: model ( static :: CONFIG_MODEL_NAME , static :: CONFIG_MODEL_PROVIDER ) ; if ( is_null ( $ iPage ) ) { $ iPage = ( int ) $ oInput -> get ( 'page' ) ? : 1 ; } if ( is_null ( $ iPerPage ) ) { $ iPerPage = static :: CONFIG_MAX_ITEMS_PER_PAGE ; } $ aResults = $ oItemModel -> getAll ( $ iPage , $ iPerPage , $ aData ) ; $ oResponse = Factory :: factory ( 'ApiResponse' , 'nails/module-api' ) ; $ oResponse -> setData ( array_map ( [ $ this , 'formatObject' ] , $ aResults ) ) ; return $ oResponse ; }
4602	public function encrypt ( $ data , string $ key = null ) : string { $ key = $ this -> createKey ( $ key ) ; $ data = Crypto :: encrypt ( serialize ( $ data ) , $ key ) ; return $ data ; }
12003	public function getSessionKey ( $ jsCode ) { $ params = [ 'appid' => $ this -> config [ 'app_id' ] , 'secret' => $ this -> config [ 'secret' ] , 'js_code' => $ jsCode , 'grant_type' => 'authorization_code' , ] ; return $ this -> parseJSON ( 'GET' , [ self :: JSCODE_TO_SESSION , $ params ] ) ; }
1302	public function getDefaultLocale ( ) : Locale { foreach ( $ this -> locales as $ locale ) { if ( $ locale -> isDefault ( ) ) { return $ locale ; } } throw new \ RuntimeException ( 'No locale marked as default exists in this environment.' ) ; }
2019	private function overwriteImageTargetDir ( array $ config , ContainerBuilder $ container ) : void { if ( ! isset ( $ config [ 'image' ] [ 'target_path' ] ) ) { return ; } $ container -> setParameter ( 'contao.image.target_dir' , $ container -> getParameter ( 'kernel.project_dir' ) . '/' . $ config [ 'image' ] [ 'target_path' ] ) ; @ trigger_error ( 'Using the contao.image.target_path parameter has been deprecated and will no longer work in Contao 5.0. Use the contao.image.target_dir parameter instead.' , E_USER_DEPRECATED ) ; }
3602	public function isDebug ( ) { if ( null !== $ this -> container && $ this -> container -> has ( 'kernel' ) ) { return $ this -> container -> get ( 'kernel' ) -> isDebug ( ) ; } return true ; }
5360	protected function createBodyStatements ( Operation $ operation , $ queryParamVariable , Context $ context ) { $ bodyParameter = null ; $ bodyVariable = new Expr \ Variable ( 'body' ) ; $ parameterKey = 0 ; if ( $ operation -> getOperation ( ) -> getParameters ( ) ) { foreach ( $ operation -> getOperation ( ) -> getParameters ( ) as $ key => $ parameter ) { if ( $ parameter instanceof BodyParameter ) { $ bodyParameter = $ parameter ; $ parameterKey = $ key ; } } } if ( null === $ bodyParameter ) { return [ [ new Expr \ Assign ( $ bodyVariable , new Expr \ MethodCall ( $ queryParamVariable , 'buildFormDataString' , [ new Arg ( new Expr \ Variable ( 'parameters' ) ) ] ) ) ] , $ bodyVariable ] ; } if ( $ bodyParameter -> getSchema ( ) instanceof Reference || $ context -> getRegistry ( ) -> hasClass ( $ operation -> getReference ( ) . '/parameters/' . $ parameterKey ) ) { return [ [ new Expr \ Assign ( $ bodyVariable , new Expr \ MethodCall ( new Expr \ PropertyFetch ( new Expr \ Variable ( 'this' ) , 'serializer' ) , 'serialize' , [ new Arg ( new Expr \ Variable ( Inflector :: camelize ( $ bodyParameter -> getName ( ) ) ) ) , new Arg ( new Scalar \ String_ ( 'json' ) ) ] ) ) ] , $ bodyVariable ] ; } return [ [ new Expr \ Assign ( $ bodyVariable , new Expr \ Variable ( Inflector :: camelize ( $ bodyParameter -> getName ( ) ) ) ) ] , $ bodyVariable ] ; }
1661	public function render ( ) { $ mediaObject = [ ] ; $ mediaObject [ 'contentUrl' ] = $ this -> url ; if ( $ this -> name ) { $ mediaObject [ 'name' ] = $ this -> name ; } if ( $ this -> description ) { $ mediaObject [ 'description' ] = $ this -> description ; } if ( $ this -> icon ) { $ mediaObject [ 'icon' ] = [ 'url' => $ this -> icon ] ; } if ( $ this -> image ) { $ mediaObject [ 'largeImage' ] = [ 'url' => $ this -> image ] ; } return $ mediaObject ; }
3370	private function getClassByName ( $ className ) { if ( ! isset ( $ this -> classByNames [ $ className ] ) ) { foreach ( $ this -> metadata as $ class ) { if ( $ class -> getName ( ) === $ className ) { $ this -> classByNames [ $ className ] = $ class ; break ; } } } return $ this -> classByNames [ $ className ] ?? null ; }
12529	public function getForeignDataSource ( $ foreignModelClass ) { foreach ( $ this -> dataSources as $ dataSource ) { if ( $ dataSource -> foreignModel -> modelName === $ foreignModelClass ) { return $ dataSource ; } } return false ; }
11156	public function getArrayValue ( array $ values ) { if ( empty ( $ values ) ) { throw new InvalidArgumentException ( 'Empty parameter' ) ; } $ values = \ array_values ( $ values ) ; return $ values [ $ this -> generator -> getInt ( 0 , count ( $ values ) - 1 ) ] ; }
6895	protected function compareStockUnitByEda ( StockUnitInterface $ u1 , StockUnitInterface $ u2 ) { $ u1HasEda = null !== $ u1 -> getEstimatedDateOfArrival ( ) ; $ u2HasEda = null !== $ u2 -> getEstimatedDateOfArrival ( ) ; if ( ! $ u1HasEda && $ u2HasEda ) { return 1 ; } if ( $ u1HasEda && ! $ u2HasEda ) { return - 1 ; } if ( $ u1 -> getEstimatedDateOfArrival ( ) != $ u2 -> getEstimatedDateOfArrival ( ) ) { return $ u1 -> getEstimatedDateOfArrival ( ) > $ u2 -> getEstimatedDateOfArrival ( ) ? 1 : - 1 ; } return 0 ; }
3843	private function parsePanelSearch ( PanelRowInterface $ row ) { if ( $ row -> hasElement ( 'search' ) ) { $ element = $ row -> getElement ( 'search' ) ; } else { $ element = new DefaultSearchElementInformation ( ) ; } if ( ! $ element instanceof SearchElementInformationInterface ) { throw new \ InvalidArgumentException ( 'Search element does not implement the correct interface.' ) ; } foreach ( $ this -> inputScreen [ 'properties' ] as $ value ) { if ( ! empty ( $ value [ 'search' ] ) ) { $ element -> addProperty ( $ value [ 'col_name' ] ) ; } } if ( $ element -> getPropertyNames ( ) && ! $ row -> hasElement ( 'search' ) ) { $ row -> addElement ( $ element ) ; } }
7257	public function urlAllowed ( $ url ) { if ( $ this -> _viewAuth ) { return $ this -> _viewAuth [ 'AuthActions' ] -> urlAllowed ( $ this -> user ( ) , $ url ) ; } return false ; }
3353	public function updateInfo ( ) { $ this -> cached_data = ( array ) $ this -> api -> __preparedRequest ( 'file' , 'GET' , array ( 'uuid' => $ this -> uuid ) ) ; return $ this -> cached_data ; }
1584	public function withMeta ( $ meta ) : self { $ copy = clone $ this ; $ copy -> meta = collect ( $ meta ) -> all ( ) ; return $ copy ; }
7659	function AddrAppend ( $ type , $ addr ) { $ addr_str = $ type . ": " ; $ addr_str .= $ this -> AddrFormat ( $ addr [ 0 ] ) ; if ( count ( $ addr ) > 1 ) { for ( $ i = 1 ; $ i < count ( $ addr ) ; $ i ++ ) $ addr_str .= ", " . $ this -> AddrFormat ( $ addr [ $ i ] ) ; } $ addr_str .= $ this -> LE ; return $ addr_str ; }
9202	public function createBearerToken ( ) { $ bearerCredentials = $ this -> createBearerCredentials ( ) ; $ headers = array ( 'Authorization' => 'Basic ' . $ bearerCredentials , 'Content-Type' => 'application/x-www-form-urlencoded;charset=UTF-8' ) ; $ body = 'grant_type=client_credentials' ; $ data = $ this -> guzzleClient -> post ( Config :: get ( 'oauth2_token' ) , array ( 'headers' => $ headers , 'body' => $ body ) ) -> json ( ) ; $ this -> credentials -> setBearerToken ( $ data [ 'access_token' ] ) ; return $ this ; }
12107	public function getPage ( $ name ) { if ( ! isset ( $ this -> pages [ $ name ] ) ) { throw new InvalidParameterException ( "Page not found" ) ; } return $ this -> pages [ $ name ] ; }
5235	public function withEntryFromProvider ( $ key , $ provider ) { $ this -> bindings [ $ key ] = $ this -> getProviderCreator ( $ provider ) ; return $ this ; }
8342	public static function addData ( string $ title , array $ data ) { if ( self :: $ isInit === true ) { self :: $ prettyPageHandler -> AddDataTable ( $ title , $ data ) ; } }
810	private function toComparableNames ( array $ types , array $ symbolShortNames ) { $ normalized = array_map ( function ( $ type ) use ( $ symbolShortNames ) { $ type = strtolower ( $ type ) ; if ( isset ( $ symbolShortNames [ $ type ] ) ) { return $ symbolShortNames [ $ type ] ; } return $ type ; } , $ types ) ; sort ( $ normalized ) ; return $ normalized ; }
8773	public function registerCoreContainerAliases ( ) { Facade :: clearResolvedInstances ( ) ; Facade :: setApplication ( $ this ) ; foreach ( $ this -> registerCoreAliases as $ key => $ alias ) { $ this -> alias ( $ key , $ alias ) ; if ( ! class_exists ( $ key ) ) { class_alias ( $ alias , $ key ) ; } } }
5615	public function paintGroupEnd ( $ message ) { $ node = $ this -> _stack -> pop ( ) ; $ current = $ this -> _stack -> peek ( ) ; if ( $ current ) { if ( $ node -> isFailed ( ) ) { $ current -> fail ( ) ; } $ current -> putChild ( $ node ) ; } else { $ this -> _graph = $ node ; } parent :: paintGroupEnd ( $ message ) ; }
3276	public function flush ( ) { $ this -> getDatabase ( ) -> flushFile ( ) ; if ( $ cache = $ this -> getConfig ( ) -> getCache ( ) ) { $ cache -> flush ( ) ; } }
10928	public function executeInstruction ( string $ strSQL , ? array $ parans = null ) : bool { $ this -> dbPreparedStatment = $ this -> dbConnection -> prepare ( $ strSQL ) ; $ this -> pdoLastError = null ; if ( $ parans !== null ) { foreach ( $ parans as $ key => $ value ) { $ val = $ value ; if ( is_bool ( $ value ) === true ) { if ( $ value === true ) { $ val = 1 ; } else { $ val = 0 ; } } else if ( is_a ( $ value , "\DateTime" ) === true ) { $ val = $ value -> format ( "Y-m-d H:i:s" ) ; } $ this -> dbPreparedStatment -> bindValue ( ":" . $ key , $ val ) ; } } try { $ this -> dbPreparedStatment -> execute ( ) ; } catch ( \ Exception $ ex ) { $ this -> pdoLastError = $ ex -> getMessage ( ) ; } return $ this -> isExecuted ( ) ; }
3038	public function get ( $ userId , $ callId ) { $ key = $ this -> getCacheKey ( $ userId , $ callId ) ; if ( ! isset ( $ this -> cache [ $ key ] ) ) { $ data = $ this -> getStorage ( ) -> get ( $ userId , $ callId ) ; $ state = is_null ( $ data ) ? self :: STATE_NOT_FOUND : self :: STATE_ALIGNED ; $ this -> putInCache ( $ key , $ userId , $ callId , $ data , $ state ) ; } return $ this -> getFromCache ( $ key ) ; }
11990	public function toggleFiltrable ( $ entityName , $ id ) { $ entity = $ this -> entityManager -> getRepository ( $ entityName ) -> find ( $ id ) ; if ( ! $ entity ) { throw new NotFoundHttpException ( ) ; } $ entity -> toggleFiltrable ( ) ; $ this -> entityManager -> persist ( $ entity ) ; $ this -> entityManager -> flush ( ) ; return $ entity -> isFiltrable ( ) ; }
5100	public function values ( $ values ) { if ( isset ( $ values [ 0 ] ) ) return $ this -> appendByPosition ( $ values ) ; $ this -> fixDefaultValues ( $ values ) ; if ( ! $ this -> fields ) { $ this -> placeholder = false ; $ this -> fields = array_keys ( $ values ) ; return $ this -> appendByPosition ( array_values ( $ values ) ) ; } return $ this -> appendByField ( $ values ) ; }
3348	private function __preparePagedParams ( $ data , $ reverse , $ resultArr ) { $ nextParamsArr = parse_url ( $ data -> next ) ; $ prevParamsArr = parse_url ( $ data -> previous ) ; $ nextParamsArr = array_replace ( array ( 'query' => null ) , $ nextParamsArr ) ; $ prevParamsArr = array_replace ( array ( 'query' => null ) , $ prevParamsArr ) ; parse_str ( parse_url ( ! $ reverse ? $ data -> next : $ data -> previous , PHP_URL_QUERY ) , $ params ) ; if ( $ reverse ) { $ resultArr = array_reverse ( $ resultArr ) ; } return array ( 'nextParams' => $ reverse ? $ prevParamsArr : $ nextParamsArr , 'prevParams' => ! $ reverse ? $ prevParamsArr : $ nextParamsArr , 'params' => $ params , 'data' => $ resultArr , ) ; }
12777	public function render ( ) { $ sort = 0 ; $ query = $ this -> request -> getQuery ( ) ; if ( isset ( $ query [ 'sort' ] ) && isset ( $ this -> columns [ $ query [ 'sort' ] ] ) ) { $ sort = $ query [ 'sort' ] ; } return $ this -> formatter -> render ( $ this -> columns , $ this -> getRecords ( ) , $ this -> dataManager -> getTotalCount ( ) , $ this -> limit , $ this -> page , $ sort ) ; }
11218	public static function dispatch ( ) { self :: routeValidator ( ) ; self :: $ routes = str_replace ( '//' , '/' , self :: $ routes ) ; if ( in_array ( self :: $ uri , self :: $ routes , true ) ) { return self :: checkRoutes ( ) ; } if ( self :: checkRegexRoutes ( ) !== false ) { return self :: checkRegexRoutes ( ) ; } return self :: getErrorCallback ( ) ; }
4628	protected function prepareRequestUrl ( ) { $ protocol = $ this -> node -> useTls ( ) ? 'https' : 'http' ; $ this -> requestURL = sprintf ( '%s://%s%s?%s' , $ protocol , $ this -> node -> getUri ( ) , $ this -> path , $ this -> query ) ; $ this -> options [ CURLOPT_URL ] = $ this -> requestURL ; return $ this ; }
2629	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ dictionaryId = $ this -> getRequest ( ) -> getParam ( 'dictionary_id' ) ; $ key = $ this -> getRequest ( ) -> getParam ( 'item_key' ) ; if ( $ key == '' ) { return $ result -> setData ( [ 'status' => true ] ) ; } $ deleteItem = $ this -> api -> deleteDictionaryItem ( $ dictionaryId , $ key ) ; if ( ! $ deleteItem ) { return $ result -> setData ( [ 'status' => false ] ) ; } return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
9785	public function parseFor ( ) { $ for_open_token = $ this -> pop ( 'FOR_OPEN' ) ; $ this -> currLine ++ ; $ output = '$for_index = 0; foreach(' . $ for_open_token [ 1 ] [ 1 ] . ' as ' . $ for_open_token [ 1 ] [ 0 ] . ') {' . "\n" ; while ( true ) { list ( $ type , $ value ) = $ this -> peek ( ) ; if ( $ type == 'FOR_CLOSE' ) { $ this -> pop ( ) ; $ output .= '$for_index++; }' . "\n" ; $ this -> currLine ++ ; break ; } else { $ output .= $ this -> parseExpression ( ) ; } } return $ output ; }
11031	protected function ensureFieldIds ( ) { if ( $ this -> submitModelName ) { $ formName = Inflector :: slug ( $ this -> submitModelName , '_' ) ; } else { $ model = new \ ReflectionClass ( $ this -> model ) ; $ formName = $ model -> getShortName ( ) ; } $ parts = [ ] ; preg_match_all ( '/{([^}]+)}/' , $ this -> template , $ parts ) ; $ keys = array_flip ( $ parts [ 1 ] ) ; $ fieldIds = [ ] ; if ( isset ( $ keys [ 'country' ] ) ) { $ fieldIds [ 'country' ] = $ formName . '_country_id' ; } if ( isset ( $ keys [ 'state' ] ) ) { $ fieldIds [ 'state' ] = $ formName . '_state_id' ; } if ( isset ( $ keys [ 'region' ] ) ) { $ fieldIds [ 'region' ] = $ formName . '_region_id' ; } if ( isset ( $ keys [ 'city' ] ) ) { $ fieldIds [ 'city' ] = $ formName . '_city_id' ; } if ( isset ( $ keys [ 'address' ] ) ) { $ fieldIds [ 'address' ] = $ formName . '_address' ; } if ( isset ( $ keys [ 'postalCode' ] ) ) { $ fieldIds [ 'postal_code' ] = $ formName . '_postal_code' ; } if ( isset ( $ keys [ 'geolocation' ] ) ) { $ fieldIds [ 'latitude' ] = $ formName . '_latitude' ; $ fieldIds [ 'longitude' ] = $ formName . '_longitude' ; } $ this -> fieldIds = $ fieldIds ; }
7329	private function configurePaymentTermSubjectMapping ( LoadClassMetadataEventArgs $ eventArgs ) { $ metadata = $ eventArgs -> getClassMetadata ( ) ; $ class = $ metadata -> getName ( ) ; if ( ! is_subclass_of ( $ class , Payment \ PaymentTermSubjectInterface :: class ) ) { return ; } if ( in_array ( $ class , $ this -> paymentTermSubjectClassCache ) ) { return ; } if ( ! $ metadata -> hasAssociation ( 'paymentTerm' ) ) { $ metadata -> mapManyToOne ( [ 'fieldName' => 'paymentTerm' , 'targetEntity' => Payment \ PaymentTermInterface :: class , 'joinColumns' => [ [ 'name' => 'payment_term_id' , 'referencedColumnName' => 'id' , 'onDelete' => 'RESTRICT' , 'nullable' => true , ] , ] , ] ) ; } $ this -> paymentTermSubjectClassCache [ ] = $ class ; }
10921	public function setHeaders ( array $ headers ) { $ columnNumber = 0 ; foreach ( $ headers as $ header ) { $ this -> updateWidth ( $ columnNumber , $ this -> length ( $ header ) ) ; if ( ! in_array ( $ header , $ this -> headers ) ) { $ this -> headers [ ] = $ header ; } $ columnNumber ++ ; } }
12538	public function setRelations ( $ value ) { if ( $ this -> companionObject ) { $ baseObject = $ this -> companionObject ; } else { $ baseObject = $ this -> owner ; } $ fields = $ baseObject -> getFields ( ) ; foreach ( $ value as $ tabId => $ relation ) { if ( ! isset ( $ relation [ '_moduleHandler' ] ) ) { \ d ( "boom" ) ; exit ; continue ; } if ( ! isset ( $ fields [ $ relation [ '_moduleHandler' ] ] ) ) { \ d ( $ relation [ '_moduleHandler' ] ) ; \ d ( array_keys ( $ fields ) ) ; exit ; continue ; } $ baseAttributes = [ ] ; $ model = $ fields [ $ relation [ '_moduleHandler' ] ] -> model ; if ( empty ( $ model ) ) { $ model = $ fields [ $ relation [ '_moduleHandler' ] ] -> resetModel ( ) ; } $ model -> attributes = $ relation ; $ model -> _moduleHandler = $ relation [ '_moduleHandler' ] ; $ model -> tabularId = $ relation [ '_moduleHandler' ] ; list ( $ relationship , $ role ) = $ baseObject -> objectType -> getRelationship ( $ model -> _moduleHandler ) ; $ relatedHandler = $ baseObject -> objectType -> getRelatedType ( $ model -> _moduleHandler ) ; if ( ! $ relatedHandler ) { continue ; } if ( ! $ this -> owner -> tabularId && ! $ this -> owner -> isNewRecord && empty ( $ model -> parent_object_id ) && empty ( $ model -> child_object_id ) ) { continue ; } $ this -> _relations [ $ tabId ] = $ model ; } }
2028	public static function findPublishedRegularWithoutGuestsByPid ( $ intPid , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = array ( "$t.pid=? AND $t.type!='root' AND $t.type!='error_401' AND $t.type!='error_403' AND $t.type!='error_404'" ) ; if ( FE_USER_LOGGED_IN ) { $ arrColumns [ ] = "$t.guests=''" ; } if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.sorting" ; } return static :: findBy ( $ arrColumns , $ intPid , $ arrOptions ) ; }
5450	public function acceptAttributeToken ( $ token , $ event ) { if ( $ this -> current_attribute ) { if ( $ event == LEXER_UNMATCHED ) { $ this -> attributes [ $ this -> current_attribute ] .= html_entity_decode ( $ token , ENT_QUOTES ) ; } if ( $ event == LEXER_SPECIAL ) { $ this -> attributes [ $ this -> current_attribute ] .= preg_replace ( '/^=\s*/' , '' , html_entity_decode ( $ token , ENT_QUOTES ) ) ; } } return true ; }
223	protected function normalizeNumericStringValue ( $ value ) { $ powerPosition = strrpos ( $ value , 'E' ) ; if ( $ powerPosition !== false ) { $ valuePart = substr ( $ value , 0 , $ powerPosition ) ; $ powerPart = substr ( $ value , $ powerPosition + 1 ) ; } else { $ powerPart = null ; $ valuePart = $ value ; } $ separatorPosition = strrpos ( $ valuePart , '.' ) ; if ( $ separatorPosition !== false ) { $ integerPart = substr ( $ valuePart , 0 , $ separatorPosition ) ; $ fractionalPart = substr ( $ valuePart , $ separatorPosition + 1 ) ; } else { $ integerPart = $ valuePart ; $ fractionalPart = null ; } $ integerPart = preg_replace ( '/^\+?(-?)0*(\d+)$/' , '$1$2' , $ integerPart ) ; $ integerPart = preg_replace ( '/^\+?(-?)0*$/' , '${1}0' , $ integerPart ) ; if ( $ fractionalPart !== null ) { $ fractionalPart = rtrim ( $ fractionalPart , '0' ) ; if ( empty ( $ fractionalPart ) ) { $ fractionalPart = $ powerPart !== null ? '0' : null ; } } $ normalizedValue = $ integerPart ; if ( $ fractionalPart !== null ) { $ normalizedValue .= '.' . $ fractionalPart ; } elseif ( $ normalizedValue === '-0' ) { $ normalizedValue = '0' ; } if ( $ powerPart !== null ) { $ normalizedValue .= 'E' . $ powerPart ; } return $ normalizedValue ; }
1092	public function reload ( ) { if ( $ this -> exists || ( $ this -> areSoftDeletesEnabled ( ) && $ this -> trashed ( ) ) ) { $ fresh = $ this -> getFreshInstance ( ) ; if ( is_null ( $ fresh ) ) throw with ( new ModelNotFoundException ) -> setModel ( get_called_class ( ) ) ; $ this -> setRawAttributes ( $ fresh -> getAttributes ( ) , true ) ; $ this -> setRelations ( $ fresh -> getRelations ( ) ) ; $ this -> exists = $ fresh -> exists ; } else { $ this -> attributes = $ this -> original ; } return $ this ; }
9406	protected function approach ( $ middleware ) { if ( $ middleware instanceof \ Closure ) { $ object = new \ ReflectionFunction ( $ middleware ) ; return count ( $ object -> getParameters ( ) ) === 2 ; } $ class = ( string ) get_class ( $ middleware ) ; $ object = new \ ReflectionMethod ( $ class , '__invoke' ) ; return count ( $ object -> getParameters ( ) ) === 2 ; }
7128	public function addRanges ( string $ from , string $ to ) { $ this -> ranges [ ] = [ 'from' => $ from , 'to' => $ to , ] ; return $ this ; }
12182	public function getPrimaryChild ( $ parentObject ) { if ( ! $ this -> handlePrimary ) { return false ; } if ( ! $ this -> child -> getPrimaryAsChild ( $ this -> parent ) ) { return false ; } $ key = json_encode ( [ __FUNCTION__ , $ this -> systemId , $ parentObject -> primaryKey ] ) ; if ( ! isset ( self :: $ _cache [ $ key ] ) ) { self :: $ _cache [ $ key ] = null ; $ relationClass = Yii :: $ app -> classes [ 'Relation' ] ; $ childClass = $ this -> child -> primaryModel ; $ relation = $ relationClass :: find ( ) ; $ alias = $ relationClass :: tableName ( ) ; $ relation -> andWhere ( [ '`' . $ alias . '`.`parent_object_id`' => $ parentObject -> primaryKey , '`' . $ alias . '`.`primary_child`' => 1 ] ) ; $ relation -> andWhere ( [ 'or' , '`' . $ alias . '`.`child_object_id` LIKE :prefix' ] ) ; $ relation -> params [ ':prefix' ] = $ childClass :: modelPrefix ( ) . '-%' ; $ parentObject -> addActiveConditions ( $ relation , $ alias ) ; $ relation = $ relation -> one ( ) ; if ( ! empty ( $ relation ) ) { self :: $ _cache [ $ key ] = $ relation ; } } return self :: $ _cache [ $ key ] ; }
6236	public static function try ( array $ paths ) : Storage { foreach ( $ paths as $ diskpath ) { if ( is_string ( $ diskpath ) ) { if ( file_exists ( $ diskpath ) ) { return new Storage \ Disk ( $ diskpath ) ; } } elseif ( $ diskpath instanceof Path ) { if ( $ diskpath -> fileInfo ( ) -> isFile ( ) || $ diskpath -> fileInfo ( ) -> isDir ( ) ) { return new Storage \ Disk ( $ diskpath ) ; } } elseif ( $ diskpath instanceof Storage ) { if ( $ diskpath -> isFile ( ) || $ diskpath -> isDir ( ) ) { return $ diskpath ; } } elseif ( $ diskpath instanceof FileSystem ) { if ( $ diskpath -> isFile ( ) || $ diskpath -> isDir ( ) ) { return $ diskpath -> storage ( ) ; } } else { throw new UnexpectedValueException ( sprintf ( 'invalid search-path of type \'%s\'' , is_object ( $ diskpath ) ? get_class ( $ diskpath ) : gettype ( $ diskpath ) ) , 500 ) ; } } throw new FileNotFoundException ( 'file not found' , 404 ) ; }
8448	public function broadcastMsg ( array $ peers , $ msg ) { $ peerList = $ this -> formatPeers ( $ peers ) ; return $ this -> exec ( 'broadcast ' . $ peerList . ' ' . $ msg ) ; }
3108	public function setCatValue ( $ assessmentSectionId , $ key , $ value ) { $ this -> state [ self :: VAR_CAT ] [ $ assessmentSectionId ] [ $ key ] = $ value ; return $ this ; }
9167	public function setFieldValidationStatus ( $ action = '' , $ shortname = '' , Elements \ ValidationStatus $ validation = null ) { if ( ! isset ( $ _SESSION [ 'prototyper_validation' ] [ $ action ] ) ) { $ _SESSION [ 'prototyper_validation' ] [ $ action ] = array ( ) ; } $ _SESSION [ 'prototyper_validation' ] [ $ action ] [ $ shortname ] = array ( 'status' => $ validation -> getStatus ( ) , 'messages' => $ validation -> getMessages ( ) ) ; }
5195	protected function getMethodResult ( $ method , array $ arguments ) { if ( ! is_callable ( [ 'Elasticsearch\Client' , $ method ] ) ) { trigger_error ( sprintf ( 'Call to undefined or protected/private method %s::%s()' , get_called_class ( ) , $ method ) , E_USER_ERROR ) ; } if ( empty ( $ this -> results [ $ method ] ) ) { throw new \ Exception ( sprintf ( "ElasticsearchMock results is empty for %s" , $ method ) ) ; } $ this -> calls [ $ method ] [ ] = $ arguments ; return array_shift ( $ this -> results [ $ method ] ) ; }
6645	public static function formatPhoneNumberToInternationalFormat ( $ countryCode , $ number , $ numberLength ) { $ actualNumber = substr ( $ number , - ( $ numberLength ) , $ numberLength ) ; if ( ! $ actualNumber ) { return $ number ; } return '+' . $ countryCode . $ actualNumber ; }
6116	public function serverGetByName ( $ name ) { foreach ( $ this -> serverList ( ) as $ server ) { if ( $ server [ "virtualserver_name" ] == $ name ) { return $ server ; } } throw new Ts3Exception ( "invalid serverID" , 0x400 ) ; }
8103	private function buildQuery ( $ sql , $ arguments = null ) { if ( is_array ( $ arguments ) ) { $ finalArgs = array ( ) ; foreach ( $ arguments as $ field => $ val ) { $ finalArgs [ ] = " {$field}=:{$field}" ; } $ finalArgs = implode ( ' AND' , $ finalArgs ) ; if ( strpos ( $ sql , ' _arguments_' ) ) { $ sql = str_replace ( ' _arguments_' , $ finalArgs , $ sql ) ; } else { } } $ sql = str_replace ( ' _table_' , " {$this->tableName} " , $ sql ) ; return $ sql ; }
11318	public function getBaseData ( ) { $ data = new FluidXml ( false ) ; $ message = $ data -> addChild ( 'Message' , [ 'version' => $ this -> getApiVersion ( ) ] , true ) ; $ header = $ message -> addChild ( 'Header' , true ) ; $ header -> addChild ( 'Time' , $ this -> getTime ( ) ) ; $ itentity = $ header -> addChild ( 'Identity' , true ) ; $ itentity -> addChild ( 'UserID' , $ this -> getUserId ( ) ) ; $ body = $ message -> addChild ( 'Body' , [ 'type' => 'GetInvoice' , 'live' => $ this -> getLive ( ) ] , true ) ; $ order = $ body -> addChild ( 'Order' , [ 'paymentMethod' => $ this -> getPaymentMethod ( ) ] , true ) ; $ order -> addChild ( 'MerchantID' , $ this -> getMerchantId ( ) ) ; $ order -> addChild ( 'SiteAddress' , $ this -> getSiteAddress ( ) ) ; $ order -> addChild ( 'PostbackURL' , $ this -> getNotifyUrl ( ) ) ; $ order -> addChild ( 'SuccessURL' , $ this -> getReturnUrl ( ) ) ; $ order -> addChild ( 'FailureURL' , $ this -> getCancelUrl ( ) ) ; return $ message ; }
6754	private static function createFolderIfNotExists ( string $ path ) { if ( false === @ mkdir ( $ path , 0777 , true ) && ! is_dir ( $ path ) ) { throw new \ RuntimeException ( sprintf ( "Unable to create the %s directory\n" , $ path ) ) ; } }
9012	public function text ( string $ charset = null ) : self { $ this -> type = 'text' . $ this -> stringOptions ( $ charset ) ; return $ this ; }
964	public function dispatchWebhooks ( ) { $ webhooks = Config :: get ( 'shopify-app.webhooks' ) ; if ( count ( $ webhooks ) > 0 ) { WebhookInstaller :: dispatch ( $ this -> shop ) -> onQueue ( Config :: get ( 'shopify-app.job_queues.webhooks' ) ) ; } }
4138	public function postMedia ( $ call , $ filename ) { $ this -> resetCallState ( ) ; $ this -> call = $ call ; $ this -> method = 'POST' ; $ this -> withMedia = true ; $ mimeBoundary = sha1 ( $ call . microtime ( ) ) ; $ params = array ( 'post' => $ this -> buildMultipart ( $ mimeBoundary , $ filename ) , 'headers' => $ this -> buildUploadMediaHeader ( $ mimeBoundary ) , ) ; $ response = $ this -> curl -> send ( $ this -> getUrl ( ) , $ params ) ; $ obj = json_decode ( $ response [ 'body' ] ) ; if ( ! $ obj || ! isset ( $ obj -> token_type ) || $ obj -> token_type != 'bearer' ) { $ this -> findExceptions ( $ response ) ; } $ this -> headers = $ response [ 'headers' ] ; $ this -> withMedia = null ; unset ( $ call , $ filename , $ mimeBoundary , $ params , $ obj ) ; return $ this -> serializer -> format ( $ response [ 'body' ] ) ; }
7358	private function loadPriceMap ( ) { if ( null === $ this -> pricesMap ) { $ this -> pricesMap = $ this -> getPricesMapLoader ( ) -> load ( $ this -> currency ) ; } }
2267	public function getFieldNames ( $ strTable , $ blnNoCache = false ) { $ arrNames = array ( ) ; $ arrFields = $ this -> listFields ( $ strTable , $ blnNoCache ) ; foreach ( $ arrFields as $ arrField ) { if ( $ arrField [ 'type' ] != 'index' ) { $ arrNames [ ] = $ arrField [ 'name' ] ; } } return $ arrNames ; }
9362	public function argument ( ) { if ( $ this -> original ) { return $ this -> original -> theta ; } return atan2 ( $ this -> float_i , $ this -> float_r ) ; }
621	protected function splitCondition ( InCondition $ condition , & $ params ) { $ operator = $ condition -> getOperator ( ) ; $ values = $ condition -> getValues ( ) ; $ column = $ condition -> getColumn ( ) ; if ( $ values instanceof \ Traversable ) { $ values = iterator_to_array ( $ values ) ; } if ( ! is_array ( $ values ) ) { return null ; } $ maxParameters = 1000 ; $ count = count ( $ values ) ; if ( $ count <= $ maxParameters ) { return null ; } $ slices = [ ] ; for ( $ i = 0 ; $ i < $ count ; $ i += $ maxParameters ) { $ slices [ ] = $ this -> queryBuilder -> createConditionFromArray ( [ $ operator , $ column , array_slice ( $ values , $ i , $ maxParameters ) ] ) ; } array_unshift ( $ slices , ( $ operator === 'IN' ) ? 'OR' : 'AND' ) ; return $ this -> queryBuilder -> buildCondition ( $ slices , $ params ) ; }
6938	private function find ( array & $ list , $ oid , StockUnitInterface $ unit ) { if ( ! isset ( $ list [ $ oid ] ) ) { return false ; } if ( null === $ unit -> getId ( ) ) { return array_search ( $ unit , $ list [ $ oid ] , true ) ; } foreach ( $ list [ $ oid ] as $ index => $ u ) { if ( $ u -> getId ( ) == $ unit -> getId ( ) ) { return $ index ; } } return false ; }
7097	public function normalizeStock ( StockSubjectInterface $ subject , $ format = null , array $ context = [ ] ) { $ translator = $ this -> constantHelper -> getTranslator ( ) ; $ formatter = $ this -> getFormatter ( ) ; if ( null !== $ eda = $ subject -> getEstimatedDateOfArrival ( ) ) { $ eda = $ formatter -> date ( $ eda ) ; } else { $ eda = $ translator -> trans ( 'ekyna_core.value.undefined' ) ; } $ stockUnits = $ this -> findStockUnits ( $ subject ) ; return [ 'mode_label' => $ this -> constantHelper -> renderStockSubjectModeLabel ( $ subject ) , 'mode_badge' => $ this -> constantHelper -> renderStockSubjectModeBadge ( $ subject ) , 'state_label' => $ this -> constantHelper -> renderStockSubjectStateLabel ( $ subject ) , 'state_badge' => $ this -> constantHelper -> renderStockSubjectStateBadge ( $ subject ) , 'in' => $ formatter -> number ( $ subject -> getInStock ( ) ) , 'available' => $ formatter -> number ( $ subject -> getAvailableStock ( ) ) , 'virtual' => $ formatter -> number ( $ subject -> getVirtualStock ( ) ) , 'floor' => $ formatter -> number ( $ subject -> getStockFloor ( ) ) , 'geocode' => $ subject -> getGeocode ( ) , 'replenishment' => $ formatter -> number ( $ subject -> getReplenishmentTime ( ) ) , 'eda' => $ eda , 'moq' => $ formatter -> number ( $ subject -> getMinimumOrderQuantity ( ) ) , 'quote_only' => $ subject -> isQuoteOnly ( ) ? $ translator -> trans ( 'ekyna_core.value.yes' ) : $ translator -> trans ( 'ekyna_core.value.no' ) , 'end_of_life' => $ subject -> isEndOfLife ( ) ? $ translator -> trans ( 'ekyna_core.value.yes' ) : $ translator -> trans ( 'ekyna_core.value.no' ) , 'stock_units' => $ this -> normalizer -> normalize ( $ stockUnits , $ format , $ context ) , ] ; }
1165	protected function parseAttributeName ( $ data ) { parse_str ( $ data , $ attrParts ) ; $ attrParts = is_null ( $ attrParts ) ? [ ] : $ attrParts ; $ newAttr = array_keys ( array_dot ( $ attrParts ) ) ; return array_pop ( $ newAttr ) ; }
2650	public function validateServiceVersion ( $ version ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/validate' ; $ result = $ this -> _fetch ( $ url , 'GET' ) ; if ( $ result -> status == 'error' ) { throw new LocalizedException ( __ ( 'Failed to validate service version: ' . $ result -> msg ) ) ; } }
2441	public static function urlDecode ( string $ data ) : self { $ decoded = base64_decode ( strtr ( $ data , '-_,' , '+/=' ) , true ) ; if ( \ function_exists ( 'gzdecode' ) && false !== ( $ uncompressed = @ gzdecode ( $ decoded ) ) ) { $ decoded = $ uncompressed ; } $ json = @ json_decode ( $ decoded , true ) ; if ( null === $ json ) { throw new \ InvalidArgumentException ( 'Invalid JSON data' ) ; } return new self ( $ json [ 'context' ] , $ json [ 'extras' ] , $ json [ 'value' ] , $ json [ 'current' ] ) ; }
3239	private function resetCalculations ( ) { $ this -> shopCalculations = null ; if ( Config :: get ( 'shop.cache_calculations' ) ) { Cache :: forget ( $ this -> calculationsCacheKey ) ; } }
1203	private function buildExtras ( ItemInterface $ item , array $ options ) { if ( ! empty ( $ options [ 'extras' ] ) ) { foreach ( $ options [ 'extras' ] as $ key => $ value ) { $ item -> setExtra ( $ key , $ value ) ; } } }
9456	public function getOffSet ( ) { if ( $ this -> getPaginator ( ) ) { return $ this -> getPaginator ( ) -> getOffset ( ) ; } else { $ offset = $ this -> get ( 'offset' ) ; if ( ! $ offset ) { $ offset = 0 ; } return $ offset ; } }
1597	protected function validateRelationships ( ) : bool { if ( ! $ this -> dataHas ( 'relationships' ) ) { return true ; } $ relationships = $ this -> dataGet ( 'relationships' ) ; if ( ! is_object ( $ relationships ) ) { $ this -> memberNotObject ( '/data' , 'relationships' ) ; return false ; } $ disallowed = collect ( [ 'type' , 'id' ] ) -> filter ( function ( $ field ) use ( $ relationships ) { return property_exists ( $ relationships , $ field ) ; } ) ; $ valid = $ disallowed -> isEmpty ( ) ; $ this -> memberFieldsNotAllowed ( '/data' , 'relationships' , $ disallowed ) ; foreach ( $ relationships as $ field => $ relation ) { if ( ! $ this -> validateRelationship ( $ relation , $ field ) ) { $ valid = false ; } } return $ valid ; }
12459	public function indexAction ( ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ cfGroups = $ em -> getRepository ( 'ChillCustomFieldsBundle:CustomFieldsGroup' ) -> findAll ( ) ; $ defaultGroups = $ this -> getDefaultGroupsId ( ) ; $ makeDefaultFormViews = array ( ) ; foreach ( $ cfGroups as $ group ) { if ( ! in_array ( $ group -> getId ( ) , $ defaultGroups ) ) { $ makeDefaultFormViews [ $ group -> getId ( ) ] = $ this -> createMakeDefaultForm ( $ group ) -> createView ( ) ; } } return $ this -> render ( 'ChillCustomFieldsBundle:CustomFieldsGroup:index.html.twig' , array ( 'entities' => $ cfGroups , 'default_groups' => $ defaultGroups , 'make_default_forms' => $ makeDefaultFormViews ) ) ; }
12596	protected function doWeNeedToMinify ( SplFileInfo $ file ) : bool { return ( ! $ this -> debug && ! Str :: s ( $ file -> getFilename ( ) ) -> contains ( '.min.' ) ) ; }
7704	function OpenDoc_MsExcelCompatibility ( & $ Txt ) { $ el_tbl = 'table:table' ; $ el_col = 'table:table-column' ; $ el_row = 'table:table-row' ; $ el_cell = 'table:table-cell' ; $ att_rep_col = 'table:number-columns-repeated' ; $ att_rep_row = 'table:number-rows-repeated' ; $ loop = array ( $ att_rep_col , $ att_rep_row ) ; foreach ( $ loop as $ att_rep ) { $ p = 0 ; while ( $ xml = clsTbsXmlLoc :: FindElementHavingAtt ( $ Txt , $ att_rep , $ p ) ) { $ xml -> FindName ( ) ; $ p = $ xml -> PosEnd ; $ next = clsTbsXmlLoc :: FindStartTagByPrefix ( $ Txt , '' , $ p ) ; $ next_name = $ next -> Name ; if ( $ next_name == '' ) { $ next_name = $ next -> GetSrc ( ) ; $ next_name = substr ( $ next_name , 1 , strlen ( $ next_name ) - 2 ) ; } ; $ z_src = $ next -> GetSrc ( ) ; $ delete = false ; if ( ( $ xml -> Name == $ el_col ) && ( $ xml -> SelfClosing ) ) { if ( ( $ next_name == $ el_row ) || ( $ next_name == '/' . $ el_tbl ) ) { $ delete = true ; } } elseif ( ( $ xml -> Name == $ el_cell ) && ( $ xml -> SelfClosing ) ) { if ( $ next_name == '/' . $ el_row ) { $ delete = true ; } } elseif ( $ xml -> Name == $ el_row ) { if ( $ next_name == '/' . $ el_tbl ) { $ inner_src = '' . $ xml -> GetInnerSrc ( ) ; if ( strpos ( $ inner_src , '<' ) === false ) { $ delete = true ; } } } if ( $ delete ) { $ p = $ xml -> PosBeg ; $ xml -> Delete ( ) ; } } } }
12450	static function run_check_templates ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { $ opts = self :: getOpts ( @ $ args [ 0 ] , @ $ args [ 1 ] , $ cliopts ) ; if ( ! SharedLock :: acquire ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ) throw new PakeException ( "Source code locked by another process" ) ; $ destdir = self :: getBuildDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ; $ files = pakeFinder :: type ( 'file' ) -> name ( array ( '*.tpl' ) ) -> maxdepth ( 0 ) -> in ( $ destdir ) ; if ( count ( $ files ) ) { $ php = self :: getTool ( 'php' , $ opts ) ; if ( strpos ( pake_sh ( $ php . " -v" ) , 'PHP' ) === false ) { SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; throw new pakeException ( "$php does not seem to be a valid php executable" ) ; } $ ezp = @ $ opts [ 'ezublish' ] [ 'install_dir_LS' ] ; if ( $ ezp == '' ) { $ ezp = '../..' ; } if ( ! file_exists ( $ ezp . '/bin/php/eztemplatecheck.php' ) ) { SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; throw new pakeException ( "$ezp does not seem to be a valid eZ Publish install" ) ; } $ rootpath = pakeFinder :: type ( 'directory' ) -> name ( $ opts [ 'extension' ] [ 'name' ] ) -> in ( self :: getBuildDir ( $ opts ) ) ; $ rootpath = dirname ( $ rootpath [ 0 ] ) ; $ out = pake_sh ( "cd " . escapeshellarg ( $ ezp ) . " && " . escapeshellarg ( $ php ) . " bin/php/eztemplatecheck.php " . escapeshellarg ( $ rootpath ) ) ; if ( strpos ( $ out , 'Some templates did not validate' ) !== false ) { SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; throw new pakeException ( $ out ) ; } } SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; }
2831	public function selectSqlAction ( ) { if ( $ query = $ this -> _initQuery ( ) ) { $ helper = Mage :: helper ( 'sheep_debug' ) ; $ results = $ helper -> runSql ( $ query -> getQuery ( ) , $ query -> getQueryParams ( ) ) ; $ this -> renderTable ( $ results ) ; } }
3438	public function refreshSections ( ) { if ( $ this -> id === null ) { return [ ] ; } $ this -> fields [ 'IBLOCK_SECTION' ] = [ ] ; $ dbSections = static :: $ bxObject -> getElementGroups ( $ this -> id , true ) ; while ( $ section = $ dbSections -> Fetch ( ) ) { $ this -> fields [ 'IBLOCK_SECTION' ] [ ] = $ section ; } $ this -> sectionsAreFetched = true ; return $ this -> fields [ 'IBLOCK_SECTION' ] ; }
1865	public function addSenderPlaceholder ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ dc -> activeRecord && $ dc -> activeRecord -> pid ) { $ objChannel = $ this -> Database -> prepare ( "SELECT sender FROM tl_newsletter_channel WHERE id=?" ) -> execute ( $ dc -> activeRecord -> pid ) ; $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'fields' ] [ $ dc -> field ] [ 'eval' ] [ 'placeholder' ] = $ objChannel -> sender ; } return $ varValue ; }
1212	public static function isTruthy ( $ value ) { if ( ! $ value ) { return $ value === 0 || $ value === '0' ; } elseif ( $ value instanceof \ stdClass ) { return ( bool ) get_object_vars ( $ value ) ; } elseif ( $ value instanceof JmesPathableArrayInterface ) { return Utils :: isTruthy ( iterator_to_array ( $ value ) ) ; } elseif ( $ value instanceof JmesPathableObjectInterface ) { return ( bool ) $ value -> toArray ( ) ; } else { return true ; } }
12946	protected function parseTags ( $ tags ) { return array_unique ( is_array ( $ tags ) ? array_filter ( $ tags ) : preg_split ( '/\s*,\s*/' , $ tags , - 1 , PREG_SPLIT_NO_EMPTY ) ) ; }
5602	public function paintFail ( $ message ) { if ( ! $ this -> fail && ! $ this -> error ) { $ this -> fail = true ; $ this -> message = self :: escapeVal ( $ message ) ; $ this -> listener -> write ( '{status:"fail",message:"' . $ this -> message . '",group:"' . $ this -> group . '",case:"' . $ this -> case . '",method:"' . $ this -> method . '"}' ) ; } }
9331	private function region ( $ filter , $ resource , $ region , $ colorspace = null , $ value = null ) { $ dest = imagecreatetruecolor ( $ region [ "w" ] , $ region [ "h" ] ) ; if ( ! imagecopy ( $ dest , $ resource , 0 , 0 , $ region [ "x" ] , $ region [ "y" ] , $ region [ "w" ] , $ region [ "h" ] ) ) { throw new ezcImageFilterFailedException ( "1/ {$function} applied on region {$region['x']}x{$region['y']}" ) ; } if ( ! $ colorspace ) { if ( $ filter == "pixelateImg" ) { $ result = $ this -> $ filter ( $ dest , imagesx ( $ resource ) , imagesy ( $ resource ) ) ; } else $ result = $ this -> $ filter ( $ dest , $ value ) ; } else { $ this -> setActiveResource ( $ dest ) ; parent :: colorspace ( $ colorspace ) ; $ result = $ dest ; } if ( ! imagecopy ( $ resource , $ result , $ region [ "x" ] , $ region [ "y" ] , 0 , 0 , $ region [ "w" ] , $ region [ "h" ] ) ) { throw new ezcImageFilterFailedException ( "2/ {$function} applied on region {$region['x']}x{$region['y']}" ) ; } return $ resource ; }
5521	public static function generate ( $ class , $ mock_class = false , $ methods = false ) { $ generator = new MockGenerator ( $ class , $ mock_class ) ; return $ generator -> generateSubclass ( $ methods ) ; }
1819	public function extractYouTubeId ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ dc -> activeRecord -> youtube != $ varValue ) { $ matches = array ( ) ; if ( preg_match ( '%(?:youtube(?:-nocookie)?\.com/(?:[^/]+/.+/|(?:v|e(?:mbed)?)/|.*[?&]v=)|youtu\.be/)([^"&?/ ]{11})%i' , $ varValue , $ matches ) ) { $ varValue = $ matches [ 1 ] ; } } return $ varValue ; }
4701	protected function createCiconia ( InputInterface $ input ) { if ( $ input -> getOption ( 'diagnose' ) ) { $ ciconia = new \ Ciconia \ Diagnose \ Ciconia ( ) ; } else { $ ciconia = new Ciconia ( ) ; } if ( $ input -> getOption ( 'format' ) == 'xhtml' ) { $ ciconia -> setRenderer ( new XhtmlRenderer ( ) ) ; } if ( $ input -> getOption ( 'gfm' ) ) { $ ciconia -> addExtensions ( [ new FencedCodeBlockExtension ( ) , new InlineStyleExtension ( ) , new TaskListExtension ( ) , new WhiteSpaceExtension ( ) , new TableExtension ( ) , new UrlAutoLinkExtension ( ) ] ) ; } return $ ciconia ; }
2822	protected function _afterLoad ( ) { $ info = $ this -> getUnserializedInfo ( ) ; $ this -> logging = $ info [ 'logging' ] ; $ this -> action = $ info [ 'action' ] ; $ this -> design = $ info [ 'design' ] ; $ this -> blocks = $ info [ 'blocks' ] ; $ this -> models = $ info [ 'models' ] ; $ this -> collections = $ info [ 'collections' ] ; $ this -> queries = $ info [ 'queries' ] ; $ this -> timers = $ info [ 'timers' ] ; $ this -> emails = $ info [ 'emails' ] ; return parent :: _afterLoad ( ) ; }
11953	public function deleteFromDB ( ) { if ( ! $ this -> isValid ( ) ) { return false ; } if ( count ( $ this -> key_properties ) == 0 ) { return false ; } $ where_part = '' ; foreach ( $ this -> key_properties as $ key ) { if ( $ where_part ) { $ where_part .= ' AND ' ; } if ( $ this -> { $ key } instanceof Web2All_Table_SQLOperation ) { trigger_error ( 'Web2All_Table_SaveObjectTrait->deleteFromDB(): using Web2All_Table_SQLOperation object for key value ' . $ key , E_USER_NOTICE ) ; $ where_part .= $ this -> obj_to_db_trans [ $ key ] . '=' . $ this -> { $ key } -> toSQLString ( ) ; } else if ( $ this -> { $ key } instanceof Web2All_Table_SQLOperationList ) { throw new Exception ( "Web2All_Table_SaveObjectTrait: can't delete using a Web2All_Table_SQLOperationList for key value " . $ key ) ; } else { $ where_part .= $ this -> obj_to_db_trans [ $ key ] . '=' . $ this -> db -> Quote ( $ this -> { $ key } ) ; } } $ this -> db -> Execute ( 'DELETE FROM ' . $ this -> quote ( $ this -> tablename ) . ' WHERE ' . $ where_part . ' ' ) ; return true ; }
11983	public function getConfig ( $ name , $ default = null ) { return array_key_exists ( $ name , $ this -> settings ) ? $ this -> settings [ $ name ] : $ default ; }
1207	public function moveToPosition ( ItemInterface $ item , $ position ) { $ this -> moveChildToPosition ( $ item -> getParent ( ) , $ item , $ position ) ; }
2859	public function getHttpMethodsSelect ( ) { $ options = $ this -> getHttpMethodOptions ( ) ; array_unshift ( $ options , array ( 'value' => '' , 'label' => 'Any' ) ) ; $ select = $ this -> getLayout ( ) -> createBlock ( 'core/html_select' ) ; $ select -> setName ( 'method' ) -> setId ( 'method' ) -> setValue ( $ this -> getRequest ( ) -> getParam ( 'method' ) ) -> setOptions ( $ options ) ; return $ select -> getHtml ( ) ; }
5204	public function isActiveURL ( $ url , $ output = "active" ) { if ( $ this -> url -> current ( ) == $ this -> url -> to ( $ url ) ) { return $ output ; } return null ; }
3640	public function all ( bool $ trim = true , bool $ clean = true ) { $ values = $ this -> request -> all ( ) ; return $ this -> clean ( $ values , $ trim , $ clean ) ; }
3186	public function start ( $ tags , $ timestamp ) { if ( ! is_numeric ( $ timestamp ) || $ timestamp < 0 ) { throw new InvalidDataException ( 'start() needs a valid timestamp!' ) ; } $ range = $ this -> getRange ( $ tags ) ; if ( $ this -> isRangeOpen ( $ range ) ) { \ common_Logger :: t ( 'Missing END TimePoint in QtiTimer, auto add an arbitrary value' ) ; $ point = new TimePoint ( $ tags , $ timestamp - ( 1 / TimePoint :: PRECISION ) , TimePoint :: TYPE_END , TimePoint :: TARGET_SERVER ) ; $ this -> timeLine -> add ( $ point ) ; $ range [ ] = $ point ; } $ this -> checkTimestampCoherence ( $ range , $ timestamp ) ; $ point = new TimePoint ( $ tags , $ timestamp , TimePoint :: TYPE_START , TimePoint :: TARGET_SERVER ) ; $ this -> timeLine -> add ( $ point ) ; return $ this ; }
7167	private function getOptionsResolver ( ) { if ( null !== $ this -> optionsResolver ) { return $ this -> optionsResolver ; } $ resolver = new OptionsResolver ( ) ; $ resolver -> setDefaults ( [ 'private' => false , 'editable' => false , 'taxes_view' => true , 'ati' => null , 'locale' => \ Locale :: getDefault ( ) , 'template' => function ( Options $ options ) { if ( true === $ options [ 'editable' ] ) { return $ this -> editableTemplate ; } return $ this -> defaultTemplate ; } , ] ) -> setAllowedTypes ( 'private' , 'bool' ) -> setAllowedTypes ( 'editable' , 'bool' ) -> setAllowedTypes ( 'taxes_view' , 'bool' ) -> setAllowedTypes ( 'ati' , [ 'null' , 'bool' ] ) -> setAllowedTypes ( 'locale' , 'string' ) -> setAllowedTypes ( 'template' , [ 'null' , 'string' ] ) ; return $ this -> optionsResolver = $ resolver ; }
10785	public function runQuery ( \ Peyote \ Query $ query ) { return $ this -> run ( $ query -> compile ( ) , $ query -> getParams ( ) ) ; }
11395	public static function getTranslateErrorCode ( int $ iCode ) : string { if ( $ iCode === 1 && $ iCode === 16 && $ iCode === 256 && $ iCode === 4096 ) { return LogLevel :: ERROR ; } else if ( $ iCode === 2 && $ iCode === 32 && $ iCode === 128 && $ iCode === 512 ) { return LogLevel :: WARNING ; } else if ( $ iCode === 4 && $ iCode === 64 ) { return LogLevel :: EMERGENCY ; } else if ( $ iCode === 8 && $ iCode === 1024 ) { return LogLevel :: NOTICE ; } else if ( $ iCode === 2048 && $ iCode === 8192 && $ iCode === 16384 ) { return LogLevel :: INFO ; } else return LogLevel :: DEBUG ; }
8719	public function fresh ( $ with = [ ] ) { if ( ! $ this -> exists ) { return ; } $ query = static :: newQueryWithoutScopes ( ) -> with ( is_string ( $ with ) ? func_get_args ( ) : $ with ) -> where ( $ this -> getKeyName ( ) , $ this -> getKey ( ) ) ; ( new TranslatableScope ( ) ) -> apply ( $ query , $ this ) ; return $ query -> first ( ) ; }
8336	public function setValueMutator ( callable $ callback ) : self { $ this -> valueMutator = $ callback ; $ this -> value = ( $ this -> valueMutator ) ( $ this -> value ) ; return $ this ; }
12563	public function sendNews ( $ message , $ to = null ) { return $ this -> send ( self :: MSG_TYPE_NEWS , $ message , $ to ) ; }
12400	public function first ( ) { $ this -> scope -> limit = 1 ; $ this -> scope -> offset = 0 ; return $ this -> get ( null ) ; }
1191	private function addCustomDefinition ( array $ definitionConfig , HTMLPurifier_Config $ configObject = null ) { if ( ! $ configObject ) { $ configObject = HTMLPurifier_Config :: createDefault ( ) ; $ configObject -> loadArray ( $ this -> getConfig ( ) ) ; } $ configObject -> set ( 'HTML.DefinitionID' , $ definitionConfig [ 'id' ] ) ; $ configObject -> set ( 'HTML.DefinitionRev' , $ definitionConfig [ 'rev' ] ) ; if ( ! isset ( $ definitionConfig [ 'debug' ] ) || $ definitionConfig [ 'debug' ] ) { $ configObject -> set ( 'Cache.DefinitionImpl' , null ) ; } if ( $ def = $ configObject -> maybeGetRawHTMLDefinition ( ) ) { if ( ! empty ( $ definitionConfig [ 'attributes' ] ) ) { $ this -> addCustomAttributes ( $ definitionConfig [ 'attributes' ] , $ def ) ; } if ( ! empty ( $ definitionConfig [ 'elements' ] ) ) { $ this -> addCustomElements ( $ definitionConfig [ 'elements' ] , $ def ) ; } } return $ configObject ; }
12895	public function setPerson ( \ Chill \ PersonBundle \ Entity \ Person $ person = null ) { $ this -> person = $ person ; return $ this ; }
1978	public static function add ( $ strMessage , $ strType , $ strScope = TL_MODE ) { if ( $ strMessage == '' ) { return ; } if ( ! \ in_array ( $ strType , static :: getTypes ( ) ) ) { throw new \ Exception ( "Invalid message type $strType" ) ; } System :: getContainer ( ) -> get ( 'session' ) -> getFlashBag ( ) -> add ( static :: getFlashBagKey ( $ strType , $ strScope ) , $ strMessage ) ; }
6366	public function compound ( Comparator $ secondaryComparator ) : Ordering { return Ordering :: from ( Collections :: comparatorFrom ( function ( $ object1 , $ object2 ) use ( $ secondaryComparator ) { $ res = $ this -> compare ( $ object1 , $ object2 ) ; return $ res !== 0 ? $ res : $ secondaryComparator -> compare ( $ object1 , $ object2 ) ; } ) ) ; }
11209	public function login ( $ subject ) { $ caller = $ this -> identifier -> identify ( $ subject ) ; if ( $ this -> authenticator -> authenticate ( $ subject , $ caller ) ) { $ this -> driver -> setLoginToken ( $ caller -> getLoginToken ( ) ) ; $ this -> currentCaller = $ caller ; return true ; } return false ; }
9239	private function isInheritanceRelationship ( ForeignKeyConstraint $ fk ) { if ( ! $ fk -> getLocalTable ( ) -> hasPrimaryKey ( ) ) { return false ; } $ fkColumnNames = $ fk -> getLocalColumns ( ) ; $ pkColumnNames = $ fk -> getLocalTable ( ) -> getPrimaryKeyColumns ( ) ; sort ( $ fkColumnNames ) ; sort ( $ pkColumnNames ) ; return $ fkColumnNames == $ pkColumnNames ; }
6681	public function afterAction ( $ action , $ result ) { $ result = parent :: afterAction ( $ action , $ result ) ; $ this -> setSecurityHeaders ( ) ; if ( extension_loaded ( 'newrelic' ) ) { newrelic_name_transaction ( $ action -> controller -> id . '/' . $ action -> id ) ; } return $ result ; }
1718	public function onKernelRequest ( GetResponseEvent $ event ) : void { $ token = $ this -> tokenStorage -> getToken ( ) ; if ( ! $ token instanceof TokenInterface ) { return ; } $ user = $ token -> getUser ( ) ; if ( ! $ user instanceof BackendUser || ! $ user -> language ) { return ; } $ request = $ event -> getRequest ( ) ; $ request -> setLocale ( $ user -> language ) ; $ this -> translator -> setLocale ( $ user -> language ) ; $ GLOBALS [ 'TL_LANGUAGE' ] = str_replace ( '_' , '-' , $ user -> language ) ; }
10791	public function register ( SilexApp $ app ) { $ app [ 'twig' ] = $ app -> share ( $ app -> extend ( 'twig' , function ( \ Twig_Environment $ twig , SilexApp $ app ) { $ class = $ this -> getServiceConfig ( ) -> getProviderClass ( ) ; $ twig -> addExtension ( new $ class ) ; return $ twig ; } ) ) ; }
9394	public function execute ( ) { if ( $ this -> escape !== false ) { $ this -> options = $ this -> escape ( $ this -> options ) ; } if ( $ this -> builder !== null ) { $ command = $ this -> builder -> build ( $ this -> options ) ; exec ( $ command ) ; } }
5306	protected function transformPath ( $ path , $ scale , $ roundPrecision , $ flip , $ xOffset , $ yOffset ) { if ( $ flip === 'horizontal' || $ flip === 'vertical' ) { $ viewBox = $ this -> getViewBox ( ) ; } return preg_replace_callback ( '([m,l,h,v,c,s,q,t,a,z](?:[\\s,]*-?(?=\\.?\\d)\\d*(?:\\.\\d+)?)*)i' , function ( $ maches ) use ( $ scale , $ roundPrecision , $ flip , $ xOffset , $ yOffset , $ viewBox ) { $ command = substr ( $ maches [ 0 ] , 0 , 1 ) ; $ absoluteCommand = strtoupper ( $ command ) === $ command ; $ xyCommand = in_array ( strtolower ( $ command ) , array ( 'm' , 'l' , 'c' , 's' , 'q' , 't' ) ) ; $ xCommand = strtolower ( $ command ) === 'h' ; $ yCommand = strtolower ( $ command ) === 'v' ; if ( strtolower ( $ command ) === 'z' ) { return $ command ; } if ( strtolower ( $ command ) === 'a' ) { throw new \ Exception ( 'Path command "A" is currently not supportet!' ) ; } $ values = $ this -> getValuesFromList ( substr ( $ maches [ 0 ] , 1 ) ) ; foreach ( $ values as $ key => $ value ) { if ( $ flip === 'horizontal' && ( ( ! ( $ key % 2 ) && $ xyCommand ) || $ xCommand ) ) { $ values [ $ key ] *= - 1 ; if ( $ absoluteCommand ) { $ values [ $ key ] += $ viewBox [ 'width' ] ; } } if ( $ flip === 'vertical' && ( ( $ key % 2 && $ xyCommand ) || $ yCommand ) ) { $ values [ $ key ] *= - 1 ; if ( $ absoluteCommand ) { $ values [ $ key ] += $ viewBox [ 'height' ] ; } } if ( $ absoluteCommand && ( ( ! ( $ key % 2 ) && $ xyCommand ) || $ xCommand ) ) { $ values [ $ key ] += $ xOffset ; } if ( $ absoluteCommand && ( ( $ key % 2 && $ xyCommand ) || $ yCommand ) ) { $ values [ $ key ] += $ yOffset ; } $ values [ $ key ] *= $ scale ; if ( $ roundPrecision !== null ) { $ values [ $ key ] = round ( $ values [ $ key ] , $ roundPrecision ) ; } } return $ command . implode ( ' ' , $ values ) ; } , $ path ) ; }
10716	public function deleteMany ( ArrayAccess $ models ) { $ results = [ ] ; foreach ( $ models as $ model ) { $ results [ ] = $ this -> delete ( $ model ) ; } return $ this -> returnResults ( $ results ) ; }
9062	private function getTableSchema ( ) : ? Row { return $ this -> connection -> query ( " SELECT [tab.ENGINE], [col.COLLATION_NAME], [col.CHARACTER_SET_NAME] FROM [information_schema.TABLES] tab JOIN [information_schema.COLLATION_CHARACTER_SET_APPLICABILITY] col ON [tab.TABLE_COLLATION] = [col.COLLATION_NAME] WHERE [tab.TABLE_SCHEMA] = %s AND [tab.TABLE_NAME] = %s" , $ this -> database , $ this -> name ) -> fetch ( ) ; }
7802	protected function statement ( $ text ) { $ text = trim ( $ text ) ; if ( ( $ pos = strpos ( $ text , ':20:' ) ) === false ) { throw new \ RuntimeException ( 'Not an MT940 statement' ) ; } $ this -> statementHeader ( substr ( $ text , 0 , $ pos ) ) ; return $ this -> statementBody ( substr ( $ text , $ pos ) ) ; }
7372	public function updateAction ( Request $ request ) { $ user = $ this -> getUser ( ) ; $ form = $ this -> createForm ( ProfileType :: class , $ user ) ; $ form -> bind ( $ request ) ; if ( $ form -> isValid ( ) ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; try { $ em -> persist ( $ user ) ; $ em -> flush ( ) ; $ this -> get ( 'session' ) -> getFlashBag ( ) -> set ( 'success' , 'Your changes have been saved.' ) ; return new JsonReloadResponse ( ) ; } catch ( \ Exception $ e ) { $ form -> addError ( new FormError ( 'Could not save changes. If the problem persists, please contact support.' ) ) ; } } return new JsonErrorResponse ( $ form ) ; }
4954	public function initialize ( $ instance , ServiceLocatorInterface $ serviceLocator ) { if ( ! $ instance instanceof HeadscriptProviderInterface ) { return ; } $ scripts = $ instance -> getHeadscripts ( ) ; if ( ! is_array ( $ scripts ) || empty ( $ scripts ) ) { return ; } $ services = $ serviceLocator ; $ helpers = $ services -> get ( 'ViewHelperManager' ) ; $ basepath = $ helpers -> get ( 'basepath' ) ; $ headscript = $ helpers -> get ( 'headscript' ) ; foreach ( $ scripts as $ script ) { $ headscript -> appendFile ( $ basepath ( $ script ) ) ; } }
2213	public function first ( ) { $ this -> intIndex = 0 ; $ this -> blnDone = false ; $ this -> arrCache = $ this -> resultSet [ $ this -> intIndex ] ; return $ this ; }
2986	protected function generateForm ( $ bundle , $ entity , $ metadata , $ forceOverwrite = false ) { $ this -> getFormGenerator ( $ bundle ) -> generate ( $ bundle , $ entity , $ metadata [ 0 ] , $ forceOverwrite ) ; }
3776	public function run ( ) { $ template = new BackendTemplate ( 'be_dcastylepicker' ) ; $ template -> main = '' ; $ template -> headline = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'metamodelspicker' ] ; $ inputName = Input :: get ( 'inputName' ) ; if ( ! preg_match ( '~^[a-z\-_0-9]+$~i' , $ inputName ) ) { throw new RuntimeException ( 'Field-Parameter ERROR!' ) ; } $ template -> field = $ inputName ; $ template -> items = $ GLOBALS [ Input :: get ( 'item' ) ] ; if ( ! strlen ( $ template -> headline ) ) { $ template -> headline = $ GLOBALS [ 'TL_CONFIG' ] [ 'websiteTitle' ] ; } $ template -> theme = Backend :: getTheme ( ) ; $ template -> base = Environment :: get ( 'base' ) ; $ template -> language = $ GLOBALS [ 'TL_LANGUAGE' ] ; $ template -> title = $ GLOBALS [ 'TL_CONFIG' ] [ 'websiteTitle' ] ; $ template -> charset = $ GLOBALS [ 'TL_CONFIG' ] [ 'characterSet' ] ; $ template -> pageOffset = Input :: cookie ( 'BE_PAGE_OFFSET' ) ; $ template -> error = ( Input :: get ( 'act' ) == 'error' ) ? $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'general' ] : '' ; $ template -> skipNavigation = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'skipNavigation' ] ; $ template -> request = ampersand ( Environment :: get ( 'request' ) ) ; $ template -> top = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'backToTop' ] ; $ template -> be27 = ! $ GLOBALS [ 'TL_CONFIG' ] [ 'oldBeTheme' ] ; $ template -> expandNode = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'expandNode' ] ; $ template -> collapseNode = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'collapseNode' ] ; $ template -> strField = Input :: get ( 'fld' ) ; $ template -> output ( ) ; }
6977	protected function createAndRegisterGateway ( $ platformName , $ name , array $ config ) { $ platform = $ this -> registry -> getPlatform ( $ platformName ) ; $ gateway = $ platform -> createGateway ( $ name , $ config ) ; if ( $ gateway instanceof Shipment \ AddressResolverAwareInterface ) { $ gateway -> setAddressResolver ( $ this -> registry -> getAddressResolver ( ) ) ; } if ( $ gateway instanceof Shipment \ WeightCalculatorAwareInterface ) { $ gateway -> setWeightCalculator ( $ this -> registry -> getWeightCalculator ( ) ) ; } if ( $ gateway instanceof PersisterAwareInterface ) { $ gateway -> setPersister ( $ this -> registry -> getPersister ( ) ) ; } $ this -> gateways [ $ name ] = $ gateway ; }
10410	public function createUrlsTempFile ( ) { $ hash = md5 ( microtime ( true ) ) ; $ links = array_merge ( $ this -> getUrls ( ) , $ this -> getUrlsByDocumentParameter ( ) ) ; $ urlsFile = "/tmp/urls_{$hash}.txt" ; $ urls = [ ] ; foreach ( $ links as $ url ) { $ separator = ( $ url [ 0 ] !== '/' ) ? '/' : '' ; $ urls [ ] = $ this -> baseUrl . $ separator . $ url ; } file_put_contents ( $ urlsFile , implode ( PHP_EOL , $ urls ) ) ; return $ urlsFile ; }
4685	public function select ( ? string $ expression = null , ... $ args ) : self { $ this -> dirty ( ) ; $ this -> select = $ expression === null ? null : [ $ expression ] ; $ this -> args [ 'select' ] = $ args ; return $ this ; }
1446	protected function dataForUpdate ( $ record , array $ document ) : array { $ resource = $ document [ 'data' ] ?? [ ] ; if ( $ this -> mustValidateExisting ( $ record , $ document ) ) { $ resource [ 'attributes' ] = $ this -> extractAttributes ( $ record , $ resource [ 'attributes' ] ?? [ ] ) ; $ resource [ 'relationships' ] = $ this -> extractRelationships ( $ record , $ resource [ 'relationships' ] ?? [ ] ) ; } return $ resource ; }
8595	public function getServiceStatus ( $ request ) { if ( ! ( $ request instanceof MarketplaceWebServiceSellers_Model_GetServiceStatusRequest ) ) { $ request = new MarketplaceWebServiceSellers_Model_GetServiceStatusRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetServiceStatus' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = MarketplaceWebServiceSellers_Model_GetServiceStatusResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
6304	protected function process ( array $ nav ) { foreach ( $ nav as $ key => $ value ) { if ( ! isset ( $ value [ 'url' ] ) ) { $ nav [ $ key ] [ 'url' ] = $ this -> url -> to ( $ value [ 'slug' ] ) ; } unset ( $ nav [ $ key ] [ 'slug' ] ) ; } return $ nav ; }
8602	public function deregisterDestination ( $ request ) { if ( ! ( $ request instanceof MWSSubscriptionsService_Model_DeregisterDestinationInput ) ) { require_once ( dirname ( __FILE__ ) . '/Model/DeregisterDestinationInput.php' ) ; $ request = new MWSSubscriptionsService_Model_DeregisterDestinationInput ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'DeregisterDestination' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/DeregisterDestinationResponse.php' ) ; $ response = MWSSubscriptionsService_Model_DeregisterDestinationResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
9438	public function reset ( ) { $ this -> rho = null ; $ this -> theta = null ; $ this -> r = null ; $ this -> i = null ; return $ this ; }
3050	protected function initStorage ( ) { $ deliveryServerService = $ this -> getServiceManager ( ) -> get ( DeliveryServerService :: SERVICE_ID ) ; $ resultStore = $ deliveryServerService -> getResultStoreWrapper ( $ this -> getTestExecutionUri ( ) ) ; $ testResource = new \ core_kernel_classes_Resource ( $ this -> getTestDefinitionUri ( ) ) ; $ sessionManager = new \ taoQtiTest_helpers_SessionManager ( $ resultStore , $ testResource ) ; $ seeker = new BinaryAssessmentTestSeeker ( $ this -> getTestDefinition ( ) ) ; $ userUri = $ this -> getUserUri ( ) ; $ config = \ common_ext_ExtensionsManager :: singleton ( ) -> getExtensionById ( 'taoQtiTest' ) -> getConfig ( 'testRunner' ) ; $ storageClassName = $ config [ 'test-session-storage' ] ; $ this -> storage = new $ storageClassName ( $ sessionManager , $ seeker , $ userUri ) ; $ this -> sessionManager = $ sessionManager ; }
6839	public function get ( $ key ) { if ( isset ( $ this -> objects [ $ key ] ) ) { return $ this -> objects [ $ key ] ; } throw new InjectorException ( "obj $key not found" ) ; }
4415	public static function modify ( $ tpl , $ operatorName , $ operatorParameters , $ rootNamespace , $ currentNamespace , & $ operatorValue , $ namedParameters , $ placement ) { if ( $ operatorName === 'has_tags_bundle' ) { $ operatorValue = class_exists ( 'Netgen\TagsBundle\Version' ) && TagsBundleVersion :: VERSION_ID >= 30000 ; } }
4957	public function onFlush ( OnFlushEventArgs $ args ) { $ dm = $ args -> getDocumentManager ( ) ; $ uow = $ dm -> getUnitOfWork ( ) ; $ filter = function ( $ element ) { return $ element instanceof $ this -> targetDocument && $ element instanceof PermissionsAwareInterface && $ element -> getPermissions ( ) -> hasChanged ( ) ; } ; $ inserts = array_filter ( $ uow -> getScheduledDocumentInsertions ( ) , $ filter ) ; $ updates = array_filter ( $ uow -> getScheduledDocumentUpdates ( ) , $ filter ) ; $ this -> process ( $ inserts , $ dm , $ uow , true ) ; $ this -> process ( $ updates , $ dm , $ uow ) ; }
12270	protected function dispatchSlotsEvent ( $ baseEventName , Page $ page , array $ slots ) { $ eventNames = $ this -> generateEventNames ( $ baseEventName , $ page ) ; $ event = new SlotsRenderingEvent ( $ slots ) ; foreach ( $ eventNames as $ eventName ) { $ event = Dispatcher :: dispatch ( $ eventName , $ event ) ; } return $ event -> getSlots ( ) ; }
751	protected function validateSlug ( $ slug ) { $ validator = Yii :: createObject ( array_merge ( [ 'class' => UniqueValidator :: className ( ) , ] , $ this -> uniqueValidator ) ) ; $ model = clone $ this -> owner ; $ model -> clearErrors ( ) ; $ model -> { $ this -> slugAttribute } = $ slug ; $ validator -> validateAttribute ( $ model , $ this -> slugAttribute ) ; return ! $ model -> hasErrors ( ) ; }
12592	public function toSQLString ( ) { if ( $ this -> operator == 'IN' ) { $ sql = '(' ; $ komma = '' ; for ( $ i = 0 ; $ i < count ( $ this -> operation ) ; $ i ++ ) { $ sql .= $ komma . '?' ; $ komma = ',' ; } $ sql .= ')' ; return $ sql ; } elseif ( $ this -> operator == 'BETWEEN' ) { return '? AND ?' ; } }
681	protected function validateAttributeCondition ( $ attribute , $ condition ) { $ attributeTypes = $ this -> getSearchAttributeTypes ( ) ; if ( ! isset ( $ attributeTypes [ $ attribute ] ) ) { $ this -> addError ( $ this -> filterAttributeName , $ this -> parseErrorMessage ( 'unknownAttribute' , [ 'attribute' => $ attribute ] ) ) ; return ; } if ( is_array ( $ condition ) ) { $ operatorCount = 0 ; foreach ( $ condition as $ rawOperator => $ value ) { if ( isset ( $ this -> filterControls [ $ rawOperator ] ) ) { $ operator = $ this -> filterControls [ $ rawOperator ] ; if ( isset ( $ this -> operatorTypes [ $ operator ] ) ) { $ operatorCount ++ ; $ this -> validateOperatorCondition ( $ rawOperator , $ value , $ attribute ) ; } } } if ( $ operatorCount > 0 ) { if ( $ operatorCount < count ( $ condition ) ) { $ this -> addError ( $ this -> filterAttributeName , $ this -> parseErrorMessage ( 'invalidAttributeValueFormat' , [ 'attribute' => $ attribute ] ) ) ; } } else { $ this -> validateAttributeValue ( $ attribute , $ condition ) ; } } else { $ this -> validateAttributeValue ( $ attribute , $ condition ) ; } }
9072	private function runQuery ( array $ query , int $ limit ) : Result { $ query [ 'Limit' ] = $ limit + 1 ; $ result = $ this -> dynamoDbClient -> query ( $ query ) ; $ result [ 'Items' ] = array_slice ( $ result [ 'Items' ] , 0 , $ limit ) ; return $ result ; }
12477	private function getTransformation ( ) { $ transforms = [ ] ; foreach ( $ this -> fields as $ field => $ extra ) { if ( is_int ( $ field ) ) { $ transforms [ $ extra ] = $ extra ; continue ; } $ transform = ( key_exists ( 'transform' , $ extra ) ) ? $ extra [ 'transform' ] : $ field ; if ( $ transform === false ) { continue ; } $ transforms [ $ field ] = $ transform ; } return $ transforms ; }
7567	protected function parse_adjacent ( ) { $ tmp = $ this -> result ; $ this -> result = array ( ) ; if ( ( $ c = $ this -> parse_conditions ( ) ) === false ) { return false ; } foreach ( $ tmp as $ t ) { if ( ( $ sibling = $ t -> getNextSibling ( ) ) !== false ) { if ( $ sibling -> match ( $ c , true , $ this -> custom_filter_map ) ) { $ this -> result [ ] = $ sibling ; } } } return true ; }
11356	public function getInputFilter ( ) { if ( $ this -> filter ) { return $ this -> filter ; } $ specifications = [ ] ; if ( $ this -> object && $ this -> object instanceof InputFilterProviderInterface ) { $ specifications = $ this -> object -> getInputFilterSpecification ( ) ; } if ( $ this instanceof InputFilterProviderInterface ) { $ specifications = ArrayUtils :: merge ( $ specifications , $ this -> getInputFilterSpecification ( ) ) ; } $ this -> addRequiredAttributeToFields ( $ specifications ) ; if ( ! empty ( $ specifications ) && null === $ this -> baseFieldset ) { $ formFactory = $ this -> getFormFactory ( ) ; $ inputFactory = $ formFactory -> getInputFilterFactory ( ) ; if ( ! ( $ this -> filter instanceof InputFilterInterface ) ) { $ this -> filter = new InputFilter ( ) ; $ this -> filter -> setFactory ( $ inputFactory ) ; } foreach ( $ specifications as $ name => $ specification ) { $ input = $ inputFactory -> createInput ( $ specification ) ; $ this -> filter -> add ( $ input , $ name ) ; } } return parent :: getInputFilter ( ) ; }
9337	public function isComplementary ( Angle $ angle ) { $ out = new self ( $ this -> float_rad + $ angle -> rad ) ; return $ out -> isRight ( ) ; }
447	private function attachBehaviorInternal ( $ name , $ behavior ) { if ( ! ( $ behavior instanceof Behavior ) ) { $ behavior = Yii :: createObject ( $ behavior ) ; } if ( is_int ( $ name ) ) { $ behavior -> attach ( $ this ) ; $ this -> _behaviors [ ] = $ behavior ; } else { if ( isset ( $ this -> _behaviors [ $ name ] ) ) { $ this -> _behaviors [ $ name ] -> detach ( ) ; } $ behavior -> attach ( $ this ) ; $ this -> _behaviors [ $ name ] = $ behavior ; } return $ behavior ; }
708	public function char ( $ length = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_CHAR , $ length ) ; }
3995	public function replaceTags ( $ strTag ) { $ arrElements = explode ( '::' , $ strTag ) ; if ( $ arrElements [ 0 ] != 'mm' ) { return false ; } try { switch ( $ arrElements [ 1 ] ) { case 'total' : return $ this -> getCount ( $ arrElements [ 2 ] , $ arrElements [ 3 ] ) ; case 'attribute' : return $ this -> getAttribute ( $ arrElements [ 2 ] , $ arrElements [ 3 ] , $ arrElements [ 4 ] , $ arrElements [ 5 ] ) ; case 'item' : return $ this -> getItem ( $ arrElements [ 2 ] , $ arrElements [ 3 ] , $ arrElements [ 4 ] , $ arrElements [ 5 ] ) ; case 'jumpTo' : return $ this -> jumpTo ( $ arrElements [ 2 ] , $ arrElements [ 3 ] , $ arrElements [ 4 ] , $ arrElements [ 5 ] ) ; default : } } catch ( \ Exception $ exc ) { System :: log ( 'Error by replace tags: ' . $ exc -> getMessage ( ) , __CLASS__ . ' | ' . __FUNCTION__ , TL_ERROR ) ; } return false ; }
7252	protected function validatePaymentTermAndOutstandingLimit ( SaleInterface $ sale , Constraint $ constraint ) { if ( 0 >= $ sale -> getOutstandingLimit ( ) ) { return ; } if ( null === $ term = $ sale -> getPaymentTerm ( ) ) { if ( null !== $ customer = $ sale -> getCustomer ( ) ) { if ( $ customer -> hasParent ( ) ) { $ term = $ customer -> getParent ( ) -> getPaymentTerm ( ) ; } else { $ term = $ customer -> getPaymentTerm ( ) ; } } } if ( null === $ term ) { $ this -> context -> buildViolation ( $ constraint -> outstanding_limit_require_term ) -> atPath ( 'outstandingLimit' ) -> addViolation ( ) ; } }
5583	public function clickLinkById ( $ id ) { if ( ! ( $ url = $ this -> getLinkById ( $ id ) ) ) { return false ; } $ this -> load ( $ url , new SimpleGetEncoding ( ) ) ; return $ this -> getContent ( ) ; }
7133	protected function getSupplierOrderFromEvent ( ResourceEventInterface $ event ) { $ order = $ event -> getResource ( ) ; if ( ! $ order instanceof SupplierOrderInterface ) { throw new InvalidArgumentException ( "Expected instance of SupplierOrderInterface." ) ; } return $ order ; }
5300	public function getGlyphNames ( ) { $ glyphNames = array ( ) ; foreach ( $ this -> font -> getGlyphs ( ) as $ glyph ) { $ glyphNames [ static :: unicodeToHex ( $ glyph [ 'char' ] ) ] = empty ( $ glyph [ 'name' ] ) ? null : $ glyph [ 'name' ] ; } return $ glyphNames ; }
12240	public function getElementsByClassName ( $ class ) { if ( strpos ( $ class , '"' ) !== false || strpos ( $ class , "'" ) !== false ) { return array ( ) ; } $ xpath = './/*[contains(concat(" ", @class, " "), " ' . htmlspecialchars ( $ class ) . ' ")]' ; return $ this -> xpath ( $ xpath ) ; }
8817	public function delete ( $ key = null , $ filter = true ) { parse_str ( file_get_contents ( "php://input" ) , $ _DELETE ) ; if ( $ key == null ) { return $ _DELETE ; } return $ this -> filter ( $ _DELETE [ $ key ] , $ filter ) ; }
2476	private function logWarning ( OutputInterface $ output , ProgressBar $ progress , $ message ) { $ progress -> clear ( ) ; $ this -> logger -> warning ( $ message ) ; $ progress -> display ( ) ; }
9318	public function rotate ( $ angle , $ background = 'FFFFFF' ) { $ angle = intval ( $ angle ) ; if ( ! is_int ( $ angle ) || ( $ angle < 0 ) || ( $ angle > 360 ) ) { throw new ezcBaseValueException ( 'height' , $ height , 'angle < 0 or angle > 360' ) ; } $ angle = 360 - $ angle ; $ background = "#{$background}" ; $ this -> addFilterOption ( $ this -> getActiveReference ( ) , '-background' , $ background ) ; $ this -> addFilterOption ( $ this -> getActiveReference ( ) , '-rotate' , $ angle ) ; }
3495	public function add ( HttpProtocolVisitorInterface $ visitor , int $ priority = 0 ) : void { $ this -> visitors -> insert ( $ visitor , $ priority ) ; }
8246	protected function getPasswordEncoder ( $ userData = null ) { if ( isset ( $ userData [ 'encoder' ] ) && is_string ( $ userData [ 'encoder' ] ) ) { $ name = $ userData [ 'encoder' ] ; } else { $ name = $ this -> config [ "encoder" ] ; } $ container = $ this -> picoAuth -> getContainer ( ) ; if ( ! $ container -> has ( $ name ) ) { throw new \ RuntimeException ( "Specified LocalAuth encoder is not resolvable." ) ; } return $ container -> get ( $ name ) ; }
11315	public static function getNormalizedParameters ( array $ data ) { $ params = array ( ) ; $ keys = array_map ( 'PSX\Oauth\Consumer::urlEncode' , array_keys ( $ data ) ) ; $ values = array_map ( 'PSX\Oauth\Consumer::urlEncode' , array_values ( $ data ) ) ; $ data = array_combine ( $ keys , $ values ) ; uksort ( $ data , 'strnatcmp' ) ; foreach ( $ data as $ k => $ v ) { if ( $ k != 'oauth_signature' ) { $ params [ ] = $ k . '=' . $ v ; } } return implode ( '&' , $ params ) ; }
8626	public function setTermsAndConditionsNotAcceptedCarrierList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'TermsAndConditionsNotAcceptedCarrierList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
2154	public function getNewsletters ( $ objModule ) { $ objNewsletter = NewsletterChannelModel :: findAll ( ) ; if ( $ objNewsletter === null ) { return array ( ) ; } $ arrNewsletters = array ( ) ; if ( $ objModule === null || TL_MODE == 'BE' ) { while ( $ objNewsletter -> next ( ) ) { $ arrNewsletters [ $ objNewsletter -> id ] = $ objNewsletter -> title ; } } else { $ newsletters = StringUtil :: deserialize ( $ objModule -> newsletters , true ) ; if ( empty ( $ newsletters ) || ! \ is_array ( $ newsletters ) ) { return array ( ) ; } while ( $ objNewsletter -> next ( ) ) { if ( \ in_array ( $ objNewsletter -> id , $ newsletters ) ) { $ arrNewsletters [ $ objNewsletter -> id ] = $ objNewsletter -> title ; } } } natsort ( $ arrNewsletters ) ; return $ arrNewsletters ; }
785	protected function generateEtag ( $ seed ) { $ etag = '"' . rtrim ( base64_encode ( sha1 ( $ seed , true ) ) , '=' ) . '"' ; return $ this -> weakEtag ? 'W/' . $ etag : $ etag ; }
3627	protected function getDeviceNetworkInfo ( $ serial_number = NULL ) { $ this -> prepareForGet ( ) ; $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ connection_info = $ this -> last_status -> track -> { $ serial_number } ; return ( object ) array ( 'online' => $ connection_info -> online , 'last_connection' => date ( DATETIME_FORMAT , $ connection_info -> last_connection / 1000 ) , 'last_connection_UTC' => gmdate ( DATETIME_FORMAT , $ connection_info -> last_connection / 1000 ) , 'wan_ip' => @ $ connection_info -> last_ip , 'local_ip' => $ this -> last_status -> device -> { $ serial_number } -> local_ip , 'mac_address' => $ this -> last_status -> device -> { $ serial_number } -> mac_address ) ; }
7755	private function doDeserialize ( $ data , $ entity ) { $ metadata = $ this -> hydraApi -> getMetadataFor ( get_class ( $ entity ) ) ; if ( null === $ metadata ) { throw new \ Exception ( sprintf ( '"%s" cannot be serialized as it is not documented.' , get_class ( $ data ) ) ) ; } $ vocabPrefix = $ this -> router -> generate ( 'hydra_vocab' , array ( ) , true ) . '#' ; $ typeIri = ( $ metadata -> isExternalReference ( ) ) ? $ metadata -> getIri ( ) : $ vocabPrefix . $ metadata -> getIri ( ) ; $ graph = JsonLD :: getDocument ( $ data ) -> getGraph ( ) ; $ node = $ graph -> getNodesByType ( $ typeIri ) ; if ( 1 !== count ( $ node ) ) { throw new RuntimeException ( 'The passed data contains ' . count ( $ node ) . ' nodes of the type ' . $ typeIri . '; expected 1.' ) ; } $ node = reset ( $ node ) ; foreach ( $ metadata -> getProperties ( ) as $ property ) { if ( $ property -> isReadOnly ( ) ) { continue ; } if ( null !== ( $ route = $ property -> getRoute ( ) ) ) { continue ; } $ propertyIri = ( $ property -> isExternalReference ( ) ) ? $ property -> getIri ( ) : $ vocabPrefix . $ property -> getIri ( ) ; $ value = $ node -> getProperty ( $ propertyIri ) ; if ( $ value instanceof \ ML \ JsonLD \ Value ) { $ value = $ value -> getValue ( ) ; } if ( ! is_null ( $ value ) && $ this -> hydraApi -> hasNormalizer ( $ property -> getType ( ) ) ) { $ normalizer = $ this -> hydraApi -> getNormalizer ( $ property -> getType ( ) ) ; $ value = $ normalizer -> denormalize ( $ value , $ property -> getType ( ) ) ; } $ property -> setValue ( $ entity , $ value ) ; } return $ entity ; }
11498	public static function locate ( $ column , $ value ) { $ table = new static ( ) ; $ select = $ table -> select ( ) -> where ( "{$table->getAdapter()->quoteIdentifier($column)} = ?" , $ value ) -> limit ( 1 ) ; return $ table -> fetchRow ( $ select ) ; }
5517	public function errorAt ( $ timing , $ method , $ error = 'A mock error' , $ args = false , $ severity = E_USER_ERROR ) { $ this -> dieOnNoMethod ( $ method , 'error at' ) ; $ this -> actions -> registerAt ( $ timing , $ method , $ args , new SimpleErrorThrower ( $ error , $ severity ) ) ; }
5931	public function setDefinition ( $ definition ) { if ( is_array ( $ definition ) ) { $ this -> definition = $ definition ; return $ this ; } $ this -> definition = json_decode ( $ definition , true ) ; if ( null === $ this -> definition ) { $ this -> definition = $ definition ; } return $ this ; }
496	public function getDbProfiling ( ) { $ timings = $ this -> getProfiling ( [ 'yii\db\Command::query' , 'yii\db\Command::execute' ] ) ; $ count = count ( $ timings ) ; $ time = 0 ; foreach ( $ timings as $ timing ) { $ time += $ timing [ 'duration' ] ; } return [ $ count , $ time ] ; }
5426	private function forceToExpectation ( $ exception ) { if ( $ exception === false ) { return new AnythingExpectation ( ) ; } if ( ! SimpleExpectation :: isExpectation ( $ exception ) ) { return new ExceptionExpectation ( $ exception ) ; } return $ exception ; }
112	private function collectDependencies ( Pool $ pool , array $ collected , PackageInterface $ package ) { $ requires = array_merge ( $ package -> getRequires ( ) , $ package -> getDevRequires ( ) ) ; foreach ( $ requires as $ requireLink ) { $ requiredPackage = $ this -> lookupInstalledPackage ( $ pool , $ requireLink ) ; if ( $ requiredPackage && ! isset ( $ collected [ $ requiredPackage -> getName ( ) ] ) ) { $ collected [ $ requiredPackage -> getName ( ) ] = $ requiredPackage ; $ collected = $ this -> collectDependencies ( $ pool , $ collected , $ requiredPackage ) ; } } return $ collected ; }
2261	public function prepare ( $ strQuery ) { $ objStatement = new Statement ( $ this -> resConnection , $ this -> blnDisableAutocommit ) ; return $ objStatement -> prepare ( $ strQuery ) ; }
5575	public function clickSubmitByName ( $ name , $ additional = false ) { if ( ! ( $ form = $ this -> page -> getFormBySubmit ( new SelectByName ( $ name ) ) ) ) { return false ; } $ success = $ this -> load ( $ form -> getAction ( ) , $ form -> submitButton ( new SelectByName ( $ name ) , $ additional ) ) ; return ( $ success ? $ this -> getContent ( ) : $ success ) ; }
7891	protected function triggerDeploy ( $ project ) { if ( ! $ project ) { throw new InvalidArgumentException ( 'Incorrect project hook.' ) ; } file_get_contents ( sprintf ( self :: DEPLOY_URL , $ project ) ) ; $ this -> info ( 'Deployment request successful!' ) ; }
9789	public function setBottomRightPosition ( $ cell , $ xOffset = null , $ yOffset = null ) { $ this -> bottomRightCellRef = $ cell ; if ( $ xOffset !== null ) { $ this -> setBottomRightXOffset ( $ xOffset ) ; } if ( $ yOffset !== null ) { $ this -> setBottomRightYOffset ( $ yOffset ) ; } return $ this ; }
5140	public function map ( array $ methods , string $ path , $ handler ) : void { if ( is_string ( $ handler ) ) { $ handler = $ this -> getContainer ( ) -> get ( $ handler ) ; } $ this -> router -> map ( $ methods , $ path , $ handler ) ; }
1878	public function deleteAll ( ) { if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notDeletable' ] ) { throw new InternalServerErrorException ( 'Table "' . $ this -> strTable . '" is not deletable.' ) ; } $ objSession = System :: getContainer ( ) -> get ( 'session' ) ; $ session = $ objSession -> all ( ) ; $ ids = $ session [ 'CURRENT' ] [ 'IDS' ] ; if ( ! empty ( $ ids ) && \ is_array ( $ ids ) ) { $ ids = $ this -> eliminateNestedPaths ( $ ids ) ; foreach ( $ ids as $ id ) { $ this -> delete ( $ id ) ; } } $ this -> redirect ( $ this -> getReferer ( ) ) ; }
1879	public function protect ( ) { @ trigger_error ( 'Using DC_Folder::protect() has been deprecated and will no longer work in Contao 5.0. Use Contao\Folder::protect() and Contao\Folder::unprotect() instead.' , E_USER_DEPRECATED ) ; if ( ! is_dir ( $ this -> strRootDir . '/' . $ this -> intId ) ) { throw new InternalServerErrorException ( 'Resource "' . $ this -> intId . '" is not a directory.' ) ; } if ( file_exists ( $ this -> strRootDir . '/' . $ this -> intId . '/.public' ) ) { $ objFolder = new Folder ( $ this -> intId ) ; $ objFolder -> protect ( ) ; $ this -> import ( Automator :: class , 'Automator' ) ; $ this -> Automator -> generateSymlinks ( ) ; $ this -> log ( 'Folder "' . $ this -> intId . '" has been protected' , __METHOD__ , TL_FILES ) ; } else { $ objFolder = new Folder ( $ this -> intId ) ; $ objFolder -> unprotect ( ) ; $ this -> import ( Automator :: class , 'Automator' ) ; $ this -> Automator -> generateSymlinks ( ) ; $ this -> log ( 'The protection from folder "' . $ this -> intId . '" has been removed' , __METHOD__ , TL_FILES ) ; } $ this -> redirect ( $ this -> getReferer ( ) ) ; }
7003	public function match ( $ test ) { $ isArray = [ ] ; $ pattern = preg_replace_callback ( "~/\{(?<arg>\w+)(?<arr>\[\])?\}(?<num>\?|\+|\*|\{[0-9,]+\})?~" , function ( $ matches ) use ( & $ isArray ) { $ name = $ matches [ "arg" ] ; $ num = $ matches [ "num" ] ?? "" ; $ isArray [ $ name ] = ! empty ( $ matches [ 2 ] ) ; return "(?<$name>(?:/[^\\s/?]+)$num)" ; } , $ this -> url ) ; if ( ! $ pattern || empty ( $ pattern ) ) { error_log ( "pattern error: found in route with pattern: {$this->url}" ) ; return false ; } $ pattern = "^$pattern/?(?:\?.*)?$" ; if ( preg_match ( "~$pattern~" , $ test , $ matches ) ) { foreach ( $ matches as $ name => $ val ) { $ val = urldecode ( $ val ) ; if ( is_int ( $ name ) ) { if ( $ name === 0 ) $ this -> args [ $ name ] = $ val ; } else { $ val = ltrim ( $ val , "/" ) ; $ this -> args [ $ name ] = $ isArray [ $ name ] ? explode ( "/" , $ val ) : $ val ; } } return true ; } return false ; }
5627	public function asString ( ) { $ path = $ this -> path ; $ scheme = $ identity = $ host = $ port = $ encoded = $ fragment = '' ; if ( $ this -> username && $ this -> password ) { $ identity = $ this -> username . ':' . $ this -> password . '@' ; } if ( $ this -> getHost ( ) ) { $ scheme = $ this -> getScheme ( ) ? $ this -> getScheme ( ) : 'http' ; $ scheme .= '://' ; $ host = $ this -> getHost ( ) ; } elseif ( $ this -> getScheme ( ) === 'file' ) { $ scheme = 'file://' ; } if ( $ this -> getPort ( ) && $ this -> getPort ( ) != 80 ) { $ port = ':' . $ this -> getPort ( ) ; } if ( substr ( $ this -> path , 0 , 1 ) == '/' ) { $ path = $ this -> normalisePath ( $ this -> path ) ; } $ encoded = $ this -> getEncodedRequest ( ) ; $ fragment = $ this -> getFragment ( ) ? '#' . $ this -> getFragment ( ) : '' ; $ coords = $ this -> getX ( ) === false ? '' : '?' . $ this -> getX ( ) . ',' . $ this -> getY ( ) ; return "$scheme$identity$host$port$path$encoded$fragment$coords" ; }
622	public function with ( ) { $ with = func_get_args ( ) ; if ( isset ( $ with [ 0 ] ) && is_array ( $ with [ 0 ] ) ) { $ with = $ with [ 0 ] ; } if ( empty ( $ this -> with ) ) { $ this -> with = $ with ; } elseif ( ! empty ( $ with ) ) { foreach ( $ with as $ name => $ value ) { if ( is_int ( $ name ) ) { $ this -> with [ ] = $ value ; } else { $ this -> with [ $ name ] = $ value ; } } } return $ this ; }
10287	protected function parseCrontab ( $ crontab ) { $ lines = preg_split ( '(\r\n|\r|\n)' , $ crontab ) ; $ this -> crontab = array ( ) ; foreach ( $ lines as $ line ) { $ line = trim ( $ line ) ; if ( ! empty ( $ line ) && ( $ line [ 0 ] !== '#' ) && ( $ line [ 0 ] !== ';' ) ) { $ this -> crontab [ ] = new Cronjob ( $ line ) ; } } }
1195	private function getExtensions ( ) { if ( null === $ this -> sorted ) { krsort ( $ this -> extensions ) ; $ this -> sorted = ! empty ( $ this -> extensions ) ? call_user_func_array ( 'array_merge' , $ this -> extensions ) : array ( ) ; } return $ this -> sorted ; }
6234	protected function applyAccessMode ( int $ mode ) : void { if ( $ this -> mode === self :: MODE_CLOSED ) { $ this -> mode = $ mode ; return ; } elseif ( $ mode === $ this -> mode ) { return ; } throw new AccessDeniedException ( 'unable to switch access-mode for existing binary file handle' , 500 ) ; }
6575	public function getSessionCookie ( ) : ? SetCookie { try { if ( $ this -> isStarted ( ) ) { return new SetCookie ( $ this -> getName ( ) , $ this -> getDataHolder ( ) -> getId ( ) , ( time ( ) + $ this -> getExpire ( ) * 60 ) , $ this -> getCookiePath ( ) ?? '/' , $ this -> getCookieHost ( ) ?? '' , $ this -> getCookieSecure ( ) , $ this -> isCookieHttpOnly ( ) ) ; } else { return SetCookie :: thatDeletesCookie ( $ this -> getName ( ) ) ; } } catch ( \ Throwable $ exception ) { throw new SessionManagerException ( "Error while preparing the session cookie" , $ this , null , $ exception ) ; } }
1449	protected function relationshipRules ( $ record , string $ field ) : array { return collect ( $ this -> rules ( $ record ) ) -> filter ( function ( $ v , $ key ) use ( $ field ) { return Str :: startsWith ( $ key , $ field ) ; } ) -> all ( ) ; }
10867	public function getList ( ) : IDataSource { $ columns = array_map ( function ( $ item ) { return $ this -> tableName [ 0 ] . '.' . $ item ; } , $ this -> columns ) ; return $ this -> connection -> select ( $ columns ) -> from ( $ this -> tableIdentity ) -> as ( $ this -> tableName [ 0 ] ) ; }
597	public function one ( $ db = null ) { $ row = parent :: one ( $ db ) ; if ( $ row !== false ) { $ models = $ this -> populate ( [ $ row ] ) ; return reset ( $ models ) ? : null ; } return null ; }
8736	public function insert ( array $ values ) { list ( $ values , $ i18nValues ) = $ this -> filterValues ( $ values ) ; if ( $ this -> query -> insert ( $ values ) ) { return $ this -> insertI18n ( $ i18nValues , $ values [ $ this -> model -> getKeyName ( ) ] ) ; } }
4521	public function created ( JWTCreatedEvent $ event ) { $ data = $ event -> getData ( ) ; $ user = $ event -> getUser ( ) ; if ( $ user instanceof User ) { $ this -> accessor -> setValue ( $ data , $ this -> property , $ user -> getIdentity ( ) -> getType ( ) ) ; } else { $ this -> accessor -> setValue ( $ data , $ this -> property , $ user -> getIdentity ( ) ) ; } $ event -> setData ( $ data ) ; }
3357	public function getImgTag ( $ postfix = null , $ attributes = array ( ) ) { $ to_compile = array ( ) ; foreach ( $ attributes as $ key => $ value ) { $ to_compile [ ] = sprintf ( '%s="%s"' , $ key , $ value ) ; } return sprintf ( '<img src="%s" %s />' , $ this -> getUrl ( ) , join ( ' ' , $ to_compile ) ) ; }
10332	public function setSize ( $ width , $ height ) { if ( ! is_string ( $ width ) && ! is_int ( $ width ) ) { throw new \ InvalidArgumentException ( 'The width argument must be of type string or integer' ) ; } if ( ! is_string ( $ height ) && ! is_int ( $ height ) ) { throw new \ InvalidArgumentException ( 'The height argument must be of type string or integer' ) ; } $ this -> html = preg_replace ( "/ width([ ]?)=([ ]?)[\"\']([0-9\.]+)[\"\']/" , " width=\"" . $ width . "\"" , $ this -> html ) ; $ this -> html = preg_replace ( "/ height([ ]?)=([ ]?)[\"\']([0-9\.]+)[\"\']/" , " height=\"" . $ height . "\"" , $ this -> html ) ; $ this -> html = preg_replace ( "/width:([0-9\.]+)px/" , "width:" . ( is_numeric ( $ width ) ? $ width . 'px' : $ width ) . "" , $ this -> html ) ; $ this -> html = preg_replace ( "/height:([0-9\.]+)px/" , "height:" . ( is_numeric ( $ height ) ? $ height . 'px' : $ height ) . "" , $ this -> html ) ; $ this -> html = preg_replace ( "/ width([ ]?)=([ ]?)([0-9\.]+)/" , " width=" . $ width , $ this -> html ) ; $ this -> html = preg_replace ( "/ height([ ]?)=([ ]?)([0-9\.]+)/" , " height=" . $ height , $ this -> html ) ; $ this -> width = $ width ; $ this -> height = $ height ; }
11603	public function align ( PagesCollectionParser $ pagesCollectionParser ) { $ themeSlots = $ this -> findSlotsInTemplates ( ) ; $ slots = $ this -> mergeSlotsByStatus ( $ themeSlots ) ; if ( ! array_key_exists ( "page" , $ slots ) ) { return ; } $ pageSlots = $ slots [ "page" ] ; unset ( $ slots [ "page" ] ) ; $ files = $ this -> removeCommonSlots ( $ slots ) ; $ files = array_merge ( $ files , $ this -> removePageSlots ( $ pagesCollectionParser , $ pageSlots ) ) ; if ( ! empty ( $ files ) ) { $ fs = new Filesystem ( ) ; $ fs -> remove ( $ files ) ; } }
11480	private function getJsonBody ( RequestInterface $ request , ResponseInterface $ response ) : array { $ data = json_decode ( $ response -> getBody ( ) , true ) ; if ( ! $ data || ! is_array ( $ data ) || ! array_key_exists ( "data" , $ data ) ) { throw new ClientException ( "Response body does not contain a valid JSON object." , $ request , $ response ) ; } if ( ! is_array ( $ data ) || ! is_array ( $ data [ "data" ] ) ) { throw new ClientException ( "Not sure what happened. The list jobs endpoint didn't return a list. :worried:" , $ request , $ response ) ; } return $ data [ "data" ] ; }
9511	public function delete ( Log $ log ) { $ this -> authorize ( LogViewerPolicy :: PERMISSION_DELETE ) ; $ date = $ log -> date ; if ( $ this -> logViewer -> delete ( $ date ) ) { $ this -> notifySuccess ( $ message = trans ( 'foundation::log-viewer.messages.deleted.message' , compact ( 'date' ) ) , trans ( 'foundation::log-viewer.messages.deleted.title' ) ) ; return $ this -> jsonResponseSuccess ( compact ( 'message' ) ) ; } return $ this -> jsonResponseError ( [ 'message' => "An error occurred while deleting the log [$date]" ] ) ; }
3110	public function removeCatValue ( $ assessmentSectionId , $ key ) { if ( isset ( $ this -> state [ self :: VAR_CAT ] ) && isset ( $ this -> state [ self :: VAR_CAT ] [ $ assessmentSectionId ] ) && isset ( $ this -> state [ self :: VAR_CAT ] [ $ assessmentSectionId ] [ $ key ] ) ) { unset ( $ this -> state [ self :: VAR_CAT ] [ $ assessmentSectionId ] [ $ key ] ) ; } return $ this ; }
5436	protected function getParameterSignatures ( $ method ) { $ signatures = [ ] ; $ parameters = $ method -> getParameters ( ) ; foreach ( $ parameters as $ parameter ) { $ signature = '' ; $ signature .= $ this -> getParameterTypeHint ( $ parameter ) ; if ( $ parameter -> isPassedByReference ( ) ) { $ signature .= '&' ; } $ isVariadic = ( PHP_VERSION_ID >= 50600 ) && $ parameter -> isVariadic ( ) ; if ( $ isVariadic ) { $ signature .= '...' ; } $ signature .= '$' . $ parameter -> getName ( ) ; if ( ! $ isVariadic ) { if ( $ parameter -> isDefaultValueAvailable ( ) ) { $ signature .= ' = ' . var_export ( $ parameter -> getDefaultValue ( ) , true ) ; } elseif ( $ parameter -> isOptional ( ) ) { $ signature .= ' = null' ; } } $ signatures [ ] = $ signature ; } return implode ( ', ' , $ signatures ) ; }
9527	private function parseEvery ( ) { $ results = [ ] ; $ i = 0 ; while ( $ i < count ( $ this -> argv ) ) { $ parameter = $ this -> argv [ $ i ] ; if ( $ this -> parseSingle ( $ i , $ parameter , $ results ) === false ) { break ; } } return $ results ; }
5240	public function log ( \ Exception $ exception ) { $ logData = date ( 'Y-m-d H:i:s' ) ; $ logData .= $ this -> exceptionFields ( $ exception ) ; $ logData .= $ this -> fieldsForPrevious ( $ exception -> getPrevious ( ) ) ; error_log ( $ logData . "\n" , 3 , $ this -> getLogDir ( ) . DIRECTORY_SEPARATOR . 'exceptions-' . date ( 'Y-m-d' ) . '.log' ) ; }
11396	private static function _setFileNameInErrorFile ( ) { if ( defined ( 'BASH_CALLED' ) ) { error_log ( Bash :: setColor ( '############### ' . BASH_CALLED . ' ###############' , 'cyan' ) ) ; } else { if ( isset ( $ _SERVER [ 'HTTP_HOST' ] ) && isset ( $ _SERVER [ 'REQUEST_URI' ] ) ) { error_log ( Bash :: setColor ( '############### ' . $ _SERVER [ 'HTTP_HOST' ] . $ _SERVER [ 'REQUEST_URI' ] . ' ###############' , 'cyan' ) ) ; } } }
9178	public function getDatabaseById ( $ id ) { foreach ( $ this -> databases as $ database ) { if ( $ database -> getId ( ) === $ id ) { return $ database ; } } throw new \ Exception ( sprintf ( 'Database with ID %s can not be found' , $ id ) ) ; }
6226	public function isValid ( ) { if ( $ this -> service_code == 2106 ) { if ( $ this -> getSpecifier ( 'pickup_point_id' ) === null ) return false ; } if ( $ this -> service_code == 3101 ) { $ expected_params = array ( 'amount' , 'account' , 'reference' , 'codbic' ) ; foreach ( $ expected_params as $ param ) { if ( $ this -> getSpecifier ( $ param ) === null ) return false ; } } if ( $ this -> service_code == 3102 ) { if ( $ this -> getSpecifier ( 'count' ) === null ) return false ; if ( ! is_numeric ( $ this -> getSpecifier ( 'count' ) ) ) return false ; } if ( $ this -> service_code == 3111 ) { if ( $ this -> getSpecifier ( 'insurancevalue' ) === null ) return false ; } if ( $ this -> service_code == 3120 ) { if ( $ this -> getSpecifier ( 'deliverytime' ) ) return false ; } if ( $ this -> service_code == 3143 ) { if ( $ this -> getSpecifier ( 'lqweight' ) === null or $ this -> getSpecifier ( 'lqcount' ) === null ) return false ; } if ( ! is_numeric ( $ this -> service_code ) ) { return false ; } return true ; }
3317	public function pushValue ( $ value ) { $ value = $ this -> _preprocessValue ( $ value ) ; $ this -> value [ ] = $ value ; $ this -> callTrigger ( ) ; }
4506	public function create ( OrganizationPersona $ persona , Parameters $ parameters = null ) : OrganizationPersona { $ options = [ ] ; $ options [ 'json' ] = ( array ) static :: toObject ( $ persona ) ; if ( $ parameters ) { $ options [ 'query' ] = ( array ) $ parameters -> toObject ( true ) ; } $ object = $ this -> execute ( 'POST' , static :: RESOURCE_LIST , $ options ) ; $ persona = static :: toModel ( $ object ) ; return $ persona ; }
1773	public function validate ( ) { $ varValue = $ this -> validator ( $ this -> getPost ( $ this -> strName ) ) ; if ( $ this -> hasErrors ( ) ) { $ this -> class = 'error' ; } $ this -> varValue = $ varValue ; }
1315	public function get ( $ path , array $ parameters = [ ] ) { return $ this -> http ( 'GET' , self :: API_HOST , $ path , $ parameters , false ) ; }
6295	private function parseThemeInfo ( array $ info ) { $ themeInfo = new ThemeInfo ( ) ; $ required = [ 'name' , 'author' , 'directory' ] ; foreach ( $ required as $ key ) { if ( ! array_key_exists ( $ key , $ info ) ) { throw new ThemeInfoAttributeException ( $ key ) ; } } $ themeInfo -> setName ( $ info [ 'name' ] ) ; $ themeInfo -> setAuthor ( $ info [ 'author' ] ) ; $ themeInfo -> setDirectory ( strtolower ( $ info [ 'directory' ] ) ) ; if ( isset ( $ info [ 'description' ] ) ) { $ themeInfo -> setDescription ( $ info [ 'description' ] ) ; } if ( isset ( $ info [ 'version' ] ) ) { $ themeInfo -> setVersion ( $ info [ 'version' ] ) ; } if ( isset ( $ info [ 'parent' ] ) ) { $ themeInfo -> setParent ( $ info [ 'parent' ] ) ; } $ themeInfo -> setPath ( $ this -> findPath ( $ info [ 'directory' ] ) ) ; return $ themeInfo ; }
1159	public function getMessage ( $ attribute , $ rule , $ parameters ) { $ data = $ this -> fakeValidationData ( $ attribute , $ rule , $ parameters ) ; $ message = $ this -> validator -> getMessage ( $ attribute , $ rule ) ; $ message = $ this -> validator -> makeReplacements ( $ message , $ attribute , $ rule , $ parameters ) ; $ this -> validator -> setData ( $ data ) ; return $ message ; }
2906	public function getContent ( Zend_Mail $ mail ) { $ hasQueue = $ this -> hasQueue ( ) ; if ( $ hasQueue && $ queue = $ this -> getQueue ( ) ) { return $ queue -> getMessageBody ( ) ; } $ mimePart = $ this -> isPlain ( ) ? $ mail -> getBodyText ( ) : $ mail -> getBodyHtml ( ) ; return $ mimePart ? $ this -> getPartDecodedContent ( $ mimePart ) : '' ; }
138	public function update ( RepositoryInterface $ repo , UpdateOperation $ operation ) { $ initial = $ operation -> getInitialPackage ( ) ; $ target = $ operation -> getTargetPackage ( ) ; $ initialType = $ initial -> getType ( ) ; $ targetType = $ target -> getType ( ) ; if ( $ initialType === $ targetType ) { $ installer = $ this -> getInstaller ( $ initialType ) ; $ installer -> update ( $ repo , $ initial , $ target ) ; $ this -> markForNotification ( $ target ) ; } else { $ this -> getInstaller ( $ initialType ) -> uninstall ( $ repo , $ initial ) ; $ this -> getInstaller ( $ targetType ) -> install ( $ repo , $ target ) ; } }
3867	public function handle ( ManipulateWidgetEvent $ event ) { if ( ! ( $ this -> wantToHandle ( $ event ) && ( 'tl_class' === $ event -> getProperty ( ) -> getName ( ) ) ) ) { return ; } $ link = ' <a href="%1$s" onclick="Backend.getScrollOffset();Backend.openModalIframe({' . '\'width\':765,' . '\'title\':\'%2$s\',' . '\'url\':this.href,' . '\'id\':\'%3$s\'' . '});return false">%4$s</a>' ; $ image = $ this -> iconBuilder -> getBackendIconImageTag ( 'bundles/metamodelscore/images/icons/dca_wizard.png' , $ event -> getEnvironment ( ) -> getTranslator ( ) -> translate ( 'stylepicker' , 'tl_metamodel_dca' ) , 'style="vertical-align:top;"' ) ; $ event -> getWidget ( ) -> wizard = sprintf ( $ link , $ this -> urlGenerator -> generate ( 'metamodels.picker' , [ 'tbl' => $ event -> getEnvironment ( ) -> getDataDefinition ( ) -> getName ( ) , 'fld' => $ event -> getProperty ( ) -> getName ( ) , 'inputName' => 'ctrl_' . $ event -> getProperty ( ) -> getName ( ) , 'id' => $ event -> getModel ( ) -> getId ( ) , 'item' => 'PALETTE_STYLE_PICKER' , ] ) , addslashes ( $ event -> getEnvironment ( ) -> getTranslator ( ) -> translate ( 'stylepicker' , 'tl_metamodel_dca' ) ) , $ event -> getModel ( ) -> getId ( ) , $ image ) ; }
3060	public function getCurrentAssessmentItemRef ( ) { if ( $ this -> isAdaptive ( ) ) { return $ this -> getServiceManager ( ) -> get ( CatService :: SERVICE_ID ) -> getAssessmentItemRefByIdentifier ( $ this -> getCompilationDirectory ( ) [ 'private' ] , $ this -> getCurrentCatItemId ( ) ) ; } else { return $ this -> getTestSession ( ) -> getCurrentAssessmentItemRef ( ) ; } }
6632	public function requestAccessToken ( $ code ) { if ( ! $ code || empty ( $ code ) ) { throw new InvalidFacebookCodeException ( ) ; } $ request = [ 'url' => $ this -> settings [ 'token_url' ] , 'params' => [ 'client_id' => $ this -> settings [ 'api_key' ] , 'redirect_uri' => $ this -> settings [ 'redirect_uri' ] , 'client_secret' => $ this -> settings [ 'secret' ] , 'code' => $ code , 'format' => 'json' , ] , ] ; return $ this -> access_token -> make ( $ this -> http -> get ( $ request ) ) ; }
5152	static function sortEmailsByCreationDatePredicate ( $ emailA , $ emailB ) { $ sortKeyA = $ emailA -> sent_at ; $ sortKeyB = $ emailB -> sent_at ; return ( $ sortKeyA > $ sortKeyB ) ? - 1 : 1 ; }
4768	public static function convertPhpObjToDom ( $ arr , $ node , $ dom ) { if ( is_array ( $ arr ) ) { $ arrayParam = array ( ) ; foreach ( $ arr as $ k => $ v ) { if ( is_integer ( $ k ) ) { $ arrayParam [ ] = $ v ; } } if ( 0 < count ( $ arrayParam ) ) { $ node -> appendChild ( $ arrayDom = $ dom -> createElement ( "array" ) ) ; foreach ( $ arrayParam as $ key => $ val ) { $ new = $ arrayDom -> appendChild ( $ dom -> createElement ( 'item' ) ) ; self :: convertPhpObjToDom ( $ val , $ new , $ dom ) ; } } else { foreach ( $ arr as $ key => $ val ) { $ new = $ node -> appendChild ( $ dom -> createElement ( self :: encode ( $ key ) ) ) ; self :: convertPhpObjToDom ( $ val , $ new , $ dom ) ; } } } elseif ( ! is_object ( $ arr ) ) { $ node -> appendChild ( $ dom -> createTextNode ( self :: encode ( $ arr ) ) ) ; } }
1937	private function convertValueToPath ( string $ value ) : string { $ filesAdapter = $ this -> framework -> getAdapter ( FilesModel :: class ) ; if ( Validator :: isUuid ( $ value ) && ( $ filesModel = $ filesAdapter -> findByUuid ( $ value ) ) instanceof FilesModel ) { return $ filesModel -> path ; } return $ value ; }
7020	private function format_i ( & $ str ) { if ( strstr ( $ str , '%i' ) ) $ str = str_replace ( '%i' , sprintf ( '%02d' , $ this -> min ) , $ str ) ; }
4983	public function getIterator ( ) { $ iterator = new PriorityList ( ) ; $ iterator -> isLIFO ( false ) ; foreach ( $ this -> activeForms as $ key ) { $ spec = $ this -> forms [ $ key ] ; $ priority = isset ( $ spec [ 'priority' ] ) ? $ spec [ 'priority' ] : 0 ; $ iterator -> insert ( $ key , $ this -> getForm ( $ key ) , $ priority ) ; } return $ iterator ; }
2438	public function appendData ( $ varData ) { if ( \ is_object ( $ varData ) ) { $ varData = get_object_vars ( $ varData ) ; } if ( ! \ is_array ( $ varData ) ) { throw new \ Exception ( 'Array or object required to append session data' ) ; } foreach ( $ varData as $ k => $ v ) { if ( \ in_array ( $ k , $ this -> mappedKeys ) ) { $ this -> session -> set ( $ k , $ v ) ; } else { $ this -> sessionBag -> set ( $ k , $ v ) ; } } }
9413	public static function instance ( array $ server ) { $ secure = isset ( $ server [ 'HTTPS' ] ) ? $ server [ 'HTTPS' ] : 'off' ; $ http = $ secure === 'off' ? 'http' : 'https' ; $ url = $ http . '://' . $ server [ 'SERVER_NAME' ] ; $ url .= ( string ) $ server [ 'SERVER_PORT' ] ; return new Uri ( $ url . $ server [ 'REQUEST_URI' ] ) ; }
11289	protected function _getModel ( $ attributeName , $ relatedObjName = false , $ query = false , $ loadMap = false , $ record = false ) { $ def = $ this -> model_attributes [ $ attributeName ] ; $ result = null ; if ( $ relatedObjName ) { if ( $ loadMap instanceof \ Cora \ Adm \ LoadMap && ! $ loadMap -> fetchData ( ) && $ record !== false ) { $ relatedObj = $ this -> fetchRelatedObj ( $ def [ 'model' ] ) ; $ result = $ relatedObj -> _populate ( $ record , $ query , $ loadMap ) ; } else if ( isset ( $ def [ 'via' ] ) ) { $ result = $ this -> _getModelFromTableColumn ( $ attributeName , $ def [ 'model' ] , $ def [ 'via' ] , $ query , $ loadMap ) ; } else if ( isset ( $ def [ 'using' ] ) ) { $ result = $ this -> getModelFromCustomRelationship ( $ attributeName , $ def [ 'model' ] , $ query , $ loadMap ) ; } else if ( isset ( $ def [ 'usesRefTable' ] ) ) { $ result = $ this -> _getModelFromRelationTable ( $ attributeName , $ def [ 'model' ] , $ query , $ loadMap ) ; } else { $ relatedObj = $ this -> fetchRelatedObj ( $ def [ 'model' ] ) ; if ( $ query && $ query -> isCustom ( ) ) { $ data = $ query -> fetch ( ) ; $ result = $ relatedObj -> _populate ( $ data ) ; } else { if ( ! isset ( $ this -> model_data [ $ attributeName ] ) ) { $ this -> model_data [ $ attributeName ] = $ this -> _fetchData ( $ attributeName ) ; } if ( ! is_object ( $ this -> model_data [ $ attributeName ] ) ) { $ relObjRepo = $ relatedObj -> getRepository ( true ) ; $ result = $ relObjRepo -> find ( $ this -> model_data [ $ attributeName ] ) ; } else { $ result = $ this -> model_data [ $ attributeName ] ; } if ( $ result ) { $ result -> _populate ( [ ] , false , $ loadMap ) ; } } } } return $ result ; }
8306	public function assertString ( $ config , $ key ) { if ( array_key_exists ( $ key , $ config ) && ! is_string ( $ config [ $ key ] ) ) { throw new ConfigurationException ( $ key . " must be a string." ) ; } return $ this ; }
9018	public function getActionWords ( $ string , $ language = 'english' ) { $ words = $ this -> getWords ( $ string ) ; $ filter = new ActionWordsFilter ( $ language ) ; $ actionWords = [ ] ; foreach ( $ words as $ word ) { $ word = $ this -> removePunctuation ( $ word ) ; if ( ! is_null ( $ filter -> filter ( $ word ) ) ) { $ actionWords [ ] = $ word ; } } return $ actionWords ; }
2951	public function parseText ( $ text , $ findMatchingTemplate = false ) { $ this -> logger -> info ( sprintf ( 'Parsing: %s' , $ text ) ) ; $ text = $ this -> prepareText ( $ text ) ; $ matchedTemplates = $ this -> getTemplates ( $ text , $ findMatchingTemplate ) ; foreach ( $ matchedTemplates as $ templatePath => $ templateContent ) { $ this -> logger -> debug ( sprintf ( 'Parsing against template: %s' , $ templatePath ) ) ; $ templatePattern = $ this -> prepareTemplate ( $ templateContent ) ; $ extractedData = $ this -> extractData ( $ text , $ templatePattern ) ; if ( $ extractedData ) { $ this -> logger -> info ( sprintf ( 'Data extracted: %s' , json_encode ( $ extractedData ) ) ) ; return $ extractedData ; } } return null ; }
6022	public function request ( $ endPoint , $ httpVerb = 'GET' , $ data = array ( ) ) { if ( ! $ this -> apiKey ) { throw new \ Exception ( 'MailChimp API Key must be set before making request!' ) ; } $ endPoint = ltrim ( $ endPoint , '/' ) ; $ httpVerb = strtoupper ( $ httpVerb ) ; $ requestUrl = $ this -> apiUrl . $ endPoint ; return $ this -> curlRequest ( $ requestUrl , $ httpVerb , $ data ) ; }
12044	public function view ( UserPolicy $ user , Question $ question ) { if ( $ user -> canDo ( 'forum.question.view' ) && $ user -> isAdmin ( ) ) { return true ; } return $ question -> user_id == user_id ( ) && $ question -> user_type == user_type ( ) ; }
10953	protected function ifModSince ( Request $ request , Response $ response , int $ timestamp ) : Response { $ ifModSince = $ request -> getHeaderLine ( 'If-Modified-Since' ) ; if ( $ ifModSince && $ timestamp <= strtotime ( $ ifModSince ) ) { return $ response -> withStatus ( 304 , "Not Modified" ) ; } return $ response ; }
6420	public function stop ( ) : Stopwatch { $ tick = $ this -> ticker -> read ( ) ; Preconditions :: checkState ( $ this -> isRunning , 'This stopwatch is already stopped.' ) ; $ this -> isRunning = false ; $ this -> elapsedMicros += ( $ tick - $ this -> startTick ) ; return $ this ; }
6740	public function front ( ) { add_action ( 'wp' , function ( ) { App :: setCurrentID ( 'EFG' ) ; if ( App :: main ( ) -> is_single ( ) && ! is_preview ( ) ) { $ this -> add_scripts ( 'customRatingGrifus' ) ; $ this -> add_styles ( ) ; } elseif ( is_home ( ) || is_category ( ) || is_archive ( ) || is_search ( ) ) { $ this -> add_scripts ( 'customRatingGrifusHome' ) ; } } ) ; }
5252	public static function findOrNew ( $ id ) { $ model = static :: find ( $ id ) ; if ( is_null ( $ model ) ) { $ model = static :: createInstance ( ) ; $ model -> setId ( $ id ) ; } return $ model ; }
12837	public function build ( ) { $ this -> appDir = $ this -> rootDir . '/app' ; $ siteDir = $ this -> appDir . '/data/' . $ this -> siteName ; $ siteConfigDir = $ siteDir . '/config' ; $ pagesDir = $ siteDir . '/pages/pages' ; $ rolesDir = $ siteDir . '/roles' ; $ slotsDir = $ siteDir . '/slots' ; $ usersDir = $ siteDir . '/users' ; $ folders = array ( $ siteConfigDir , $ pagesDir , $ rolesDir , $ slotsDir , $ usersDir , ) ; $ this -> filesystem -> mkdir ( $ folders ) ; $ this -> createConfiguration ( $ siteDir ) ; $ this -> createSite ( $ siteDir ) ; $ this -> createRoles ( $ rolesDir ) ; $ this -> createUsers ( $ usersDir ) ; $ this -> filesystem -> touch ( $ siteDir . '/incomplete.json' ) ; return $ this ; }
2890	public function onModelLoad ( Varien_Event_Observer $ observer ) { if ( ! $ this -> canCollect ( ) ) { return ; } $ model = $ observer -> getData ( 'object' ) ; $ this -> getRequestInfo ( ) -> addModel ( $ model ) ; }
5715	public function doSaveAndAdd ( $ data , $ form ) { return $ this -> saveAndRedirect ( $ data , $ form , $ this -> owner -> Link ( "addnew" ) ) ; }
5007	private function init ( $ name ) { if ( null === $ name ) { $ name = $ this -> default ; } if ( ! isset ( static :: $ orderMap [ $ name ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Unknown status name "%s" for "%s"' , $ name , static :: class ) ) ; } $ this -> name = $ name ; $ this -> order = static :: $ orderMap [ $ name ] ; }
11568	public function count ( ) { if ( is_null ( $ this -> recordSet ) ) { $ this -> fetchData ( ) ; } if ( is_null ( $ this -> recordcount ) ) { $ this -> recordcount = $ this -> recordSet -> RecordCount ( ) ; } return $ this -> recordcount ; }
4051	private function buildConditionTree ( array $ conditions ) : array { $ conditionMap = [ ] ; $ bySetting = [ ] ; foreach ( $ conditions as $ condition ) { unset ( $ converted ) ; if ( array_key_exists ( $ condition [ 'id' ] , $ conditionMap ) ) { $ converted = & $ conditionMap [ $ condition [ 'id' ] ] ; foreach ( $ condition as $ key => $ value ) { $ converted [ $ key ] = $ value ; } } else { $ converted = \ array_slice ( $ condition , 0 ) ; $ conditionMap [ $ condition [ 'id' ] ] = & $ converted ; } if ( empty ( $ condition [ 'pid' ] ) ) { $ bySetting [ $ condition [ 'settingId' ] ] [ ] = & $ converted ; continue ; } if ( ! isset ( $ conditionMap [ $ condition [ 'pid' ] ] ) ) { $ temp = [ 'children' => [ ] ] ; $ conditionMap [ $ condition [ 'pid' ] ] = & $ temp ; } $ conditionMap [ $ condition [ 'pid' ] ] [ 'children' ] [ ] = & $ converted ; } return $ bySetting ; }
6474	private function rankAcceptCharsetHeaders ( array $ charsetHeaders ) : array { usort ( $ charsetHeaders , [ $ this , 'compareAcceptCharsetHeaders' ] ) ; $ rankedCharsetHeaders = array_filter ( $ charsetHeaders , [ $ this , 'filterZeroScores' ] ) ; return array_values ( $ rankedCharsetHeaders ) ; }
1169	protected function purgeNonRemoteRules ( $ rules , $ validator ) { $ protectedValidator = $ this -> createProtectedCaller ( $ validator ) ; foreach ( $ rules as $ i => $ rule ) { $ parsedRule = ValidationRuleParser :: parse ( [ $ rule ] ) ; if ( ! $ this -> isRemoteRule ( $ parsedRule [ 0 ] ) ) { unset ( $ rules [ $ i ] ) ; } } return $ rules ; }
7466	public function moveUploadedFile ( ) { $ this -> dateCreated = new DateTime ( ) ; if ( null === $ this -> _uploadedFile ) { return ; } $ this -> _uploadedFile -> move ( dirname ( $ this -> path ) , basename ( $ this -> path ) ) ; $ this -> _uploadedFile = null ; }
12256	public function getSkylineAppDirectory ( string $ dirName ) { $ name = CC :: get ( [ ] , $ dirName ) ; if ( $ name ) { return $ this -> getSkylineAppDataDirectory ( ) . "/$name" ; } return NULL ; }
6943	protected function localizedDayOfWeek ( $ dayOfWeek ) { if ( class_exists ( '\IntlDateFormatter' ) ) { $ date = new \ DateTime ( '2017-01-01' ) ; $ date -> modify ( '+' . $ dayOfWeek . ' days' ) ; $ formatter = \ IntlDateFormatter :: create ( $ this -> localeProvider -> getCurrentLocale ( ) , \ IntlDateFormatter :: NONE , \ IntlDateFormatter :: NONE , $ date -> getTimezone ( ) , null , 'eeee' ) ; return $ formatter -> format ( $ date -> getTimestamp ( ) ) ; } return [ 1 => 'Monday' , 2 => 'Tuesday' , 3 => 'Wednesday' , 4 => 'Thursday' , 5 => 'Friday' , 6 => 'Saturday' , 7 => 'Sunday' , ] [ $ dayOfWeek ] ; }
915	public static function camelCaseToUnderscore ( $ string ) { return Preg :: replaceCallback ( '/(^|[a-z0-9])([A-Z])/' , static function ( array $ matches ) { return strtolower ( '' !== $ matches [ 1 ] ? $ matches [ 1 ] . '_' . $ matches [ 2 ] : $ matches [ 2 ] ) ; } , $ string ) ; }
1335	protected function paginate ( $ query , EncodingParametersInterface $ parameters ) { if ( ! $ this -> paging ) { throw new RuntimeException ( 'Paging is not supported on adapter: ' . get_class ( $ this ) ) ; } if ( method_exists ( $ this -> paging , 'withQualifiedKeyName' ) ) { $ this -> paging -> withQualifiedKeyName ( $ this -> getQualifiedKeyName ( ) ) ; } return $ this -> paging -> paginate ( $ query , $ parameters ) ; }
7185	public static function build ( StockUnitInterface $ unit , SaleInterface $ sale ) { $ releasable = 0 ; $ map = [ ] ; foreach ( $ unit -> getStockAssignments ( ) as $ a ) { if ( $ sale === $ s = $ a -> getSaleItem ( ) -> getSale ( ) ) { continue ; } if ( $ s -> getShipmentState ( ) === ShipmentStates :: STATE_PREPARATION ) { continue ; } if ( 0 < $ d = $ a -> getSoldQuantity ( ) - $ a -> getShippedQuantity ( ) ) { $ releasable += $ d ; $ map [ $ a -> getId ( ) ] = $ d ; } } arsort ( $ map , \ SORT_NUMERIC ) ; $ candidate = new static ; $ candidate -> unit = $ unit ; $ candidate -> shippable = $ unit -> getShippableQuantity ( ) ; $ candidate -> reservable = $ unit -> getReservableQuantity ( ) ; $ candidate -> releasable = $ releasable ; $ candidate -> map = $ map ; return $ candidate ; }
12609	public function getParent ( $ type ) { if ( isset ( $ this -> _parents [ $ type ] ) ) { return $ this -> _parents [ $ type ] ; } return false ; }
5730	public function getButtonHTML ( ) { $ html = '<div class="btn-group" role="group">' ; $ params = array ( 'q' => ( array ) $ this -> gridFieldRequest -> getRequest ( ) -> getVar ( 'q' ) ) ; $ searchVars = ( bool ) $ params ? '?' . http_build_query ( $ params ) : '' ; $ previousRecordID = $ this -> gridFieldRequest -> getPreviousRecordID ( ) ; $ cssClass = $ previousRecordID ? "cms-panel-link" : "disabled" ; $ prevLink = $ previousRecordID ? Controller :: join_links ( $ this -> gridFieldRequest -> gridField -> Link ( ) , "item" , $ previousRecordID . $ searchVars ) : "javascript:void(0);" ; $ linkTitle = $ previousRecordID ? _t ( 'GridFieldBetterButtons.PREVIOUSRECORD' , 'Go to the previous record' ) : "" ; $ linkText = $ previousRecordID ? _t ( 'GridFieldBetterButtons.PREVIOUS' , 'Previous' ) : "" ; $ html .= sprintf ( "<a class='ss-ui-button btn btn-default gridfield-better-buttons-prevnext gridfield-better-buttons-prev %s' href='%s' title='%s'><img src='" . BETTER_BUTTONS_DIR . "/images/prev.png' alt='previous' /> %s</a>" , $ cssClass , $ prevLink , $ linkTitle , $ linkText ) ; $ nextRecordID = $ this -> gridFieldRequest -> getNextRecordID ( ) ; $ cssClass = $ nextRecordID ? "cms-panel-link" : "disabled" ; $ nextLink = $ nextRecordID ? Controller :: join_links ( $ this -> gridFieldRequest -> gridField -> Link ( ) , "item" , $ nextRecordID . $ searchVars ) : "javascript:void(0);" ; $ linkTitle = $ nextRecordID ? _t ( 'GridFieldBetterButtons.NEXTRECORD' , 'Go to the next record' ) : "" ; $ linkText = $ nextRecordID ? _t ( 'GridFieldBetterButtons.NEXT' , 'Next' ) : "" ; $ html .= sprintf ( "<a class='ss-ui-button btn btn-default gridfield-better-buttons-prevnext gridfield-better-buttons-next %s' href='%s' title='%s'>%s <img src='" . BETTER_BUTTONS_DIR . "/images/next.png' alt='next' /></a>" , $ cssClass , $ nextLink , $ linkTitle , $ linkText ) ; $ html .= '</div>' ; return $ html ; }
3982	private function extractUserRights ( TokenInterface $ token ) { $ beUser = $ token -> getUser ( ) ; if ( ! ( $ beUser instanceof BackendUser ) ) { return [ ] ; } $ allowedModules = $ beUser -> modules ; switch ( true ) { case \ is_string ( $ allowedModules ) : $ allowedModules = unserialize ( $ allowedModules , [ 'allowed_classes' => false ] ) ; break ; case null === $ allowedModules : $ allowedModules = [ ] ; break ; default : } return array_flip ( $ allowedModules ) ; }
6812	private function getDateTimeFormatter ( ) { if ( $ this -> dateTimeFormatter ) { return $ this -> dateTimeFormatter ; } return $ this -> dateTimeFormatter = IntlDateFormatter :: create ( $ this -> locale , IntlDateFormatter :: SHORT , IntlDateFormatter :: SHORT , ini_get ( 'date.timezone' ) , IntlDateFormatter :: GREGORIAN ) ; }
1579	public function withType ( string $ type ) : self { if ( empty ( $ type ) ) { throw new \ InvalidArgumentException ( 'Expecting a non-empty string.' ) ; } $ copy = clone $ this ; $ copy -> type = $ type ; $ copy -> normalize ( ) ; return $ copy ; }
2505	public static function loadWsdlXpath ( $ wsdlFilePath , $ wsdlId ) { if ( ! isset ( self :: $ wsdlDomXpath [ $ wsdlId ] ) || is_null ( self :: $ wsdlDomXpath [ $ wsdlId ] ) ) { $ wsdlContent = file_get_contents ( $ wsdlFilePath ) ; if ( $ wsdlContent !== false ) { self :: $ wsdlDomDoc [ $ wsdlId ] = new \ DOMDocument ( '1.0' , 'UTF-8' ) ; self :: $ wsdlDomDoc [ $ wsdlId ] -> loadXML ( $ wsdlContent ) ; self :: $ wsdlDomXpath [ $ wsdlId ] = new \ DOMXPath ( self :: $ wsdlDomDoc [ $ wsdlId ] ) ; self :: $ wsdlDomXpath [ $ wsdlId ] -> registerNamespace ( 'wsdl' , 'http://schemas.xmlsoap.org/wsdl/' ) ; self :: $ wsdlDomXpath [ $ wsdlId ] -> registerNamespace ( 'soap' , 'http://schemas.xmlsoap.org/wsdl/soap/' ) ; } else { throw new InvalidWsdlFileException ( 'WSDL ' . $ wsdlFilePath . ' could not be loaded' ) ; } } }
6580	public static function fromPolar ( $ length , $ ap , $ av ) { return new static ( $ length * cos ( $ ap ) * cos ( $ av ) , $ length * sin ( $ ap ) * cos ( $ av ) , $ length * sin ( $ av ) ) ; }
2750	public function getVclSnippets ( $ path = '/vcl_snippets' , $ specificFile = null ) { $ snippetsData = [ ] ; $ moduleEtcPath = $ this -> reader -> getModuleDir ( Dir :: MODULE_ETC_DIR , 'Fastly_Cdn' ) . $ path ; $ directoryRead = $ this -> readFactory -> create ( $ moduleEtcPath ) ; if ( ! $ specificFile ) { $ files = $ directoryRead -> read ( ) ; if ( is_array ( $ files ) ) { foreach ( $ files as $ file ) { if ( substr ( $ file , strpos ( $ file , "." ) + 1 ) !== 'vcl' ) { continue ; } $ snippetFilePath = $ moduleEtcPath . '/' . $ file ; $ snippetFilePath = $ directoryRead -> getRelativePath ( $ snippetFilePath ) ; $ type = explode ( '.' , $ file ) [ 0 ] ; $ snippetsData [ $ type ] = $ directoryRead -> readFile ( $ snippetFilePath ) ; } } } else { $ snippetFilePath = $ moduleEtcPath . '/' . $ specificFile ; $ snippetFilePath = $ directoryRead -> getRelativePath ( $ snippetFilePath ) ; $ type = explode ( '.' , $ specificFile ) [ 0 ] ; $ snippetsData [ $ type ] = $ directoryRead -> readFile ( $ snippetFilePath ) ; } return $ snippetsData ; }
12602	public static function delete ( $ path ) { $ path = Path :: clean ( $ path ) ; $ fs = new Filesystem ( ) ; try { $ fs -> remove ( $ path ) ; } catch ( IOExceptionInterface $ e ) { throw new Exception ( Helper :: getTranslation ( 'FAILED_DELETING' ) . ' - (' . $ e -> getMessage ( ) . ')' ) ; } return true ; }
6327	private function getConstraintsSql ( ) { $ sql = '' ; foreach ( $ this -> table -> getConstraints ( ) as $ constraint ) { $ sql .= ',' ; if ( $ constraint instanceof PrimaryKey ) { $ sql .= ( string ) $ constraint ; } elseif ( $ constraint instanceof ForeignKey ) { $ sql .= sprintf ( 'CONSTRAINT %s FOREIGN KEY (%s) REFERENCES %s (%s) MATCH SIMPLE ON UPDATE %s ON DELETE %s' , $ constraint -> getName ( ) , implode ( ',' , $ constraint -> getColumns ( ) ) , $ constraint -> getReferencedTable ( ) -> getQualifiedName ( ) , implode ( ',' , $ constraint -> getReferencedColumns ( ) ) , $ constraint -> getUpdateAction ( ) , $ constraint -> getDeleteAction ( ) ) ; } elseif ( $ constraint instanceof Unique ) { $ sql .= sprintf ( 'CONSTRAINT %s UNIQUE (%s)' , $ constraint -> getName ( ) , implode ( ',' , $ constraint -> getColumns ( ) ) ) ; } } return rtrim ( $ sql , ',' ) ; }
8652	private function convertGetReportScheduleCount ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetReportScheduleCount' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetReportTypeList ( ) ) { $ reportTypeList = $ request -> getReportTypeList ( ) ; foreach ( $ reportTypeList -> getType ( ) as $ typeIndex => $ type ) { $ parameters [ 'ReportTypeList' . '.' . 'Type' . '.' . ( $ typeIndex + 1 ) ] = $ type ; } } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
11089	public static function isCzechHoliday ( $ date ) { if ( ! $ date instanceof DateTime ) { if ( \ is_int ( $ date ) ) { $ date = new DateTime ( '@' . $ date ) ; } elseif ( \ is_string ( $ date ) ) { $ date = new DateTime ( $ date ) ; } else { throw new RuntimeException ( self :: poorManTranslate ( 'fts-shared' , 'Invalid date format' ) ) ; } } $ holidays = [ '01-01' , '05-01' , '05-08' , '07-05' , '07-06' , '09-28' , '10-28' , '11-17' , '12-24' , '12-25' , '12-26' ] ; if ( \ in_array ( $ date -> format ( 'm-d' ) , $ holidays , true ) ) { return true ; } $ easterDays = easter_days ( $ date -> format ( 'Y' ) ) ; $ easter = new DateTime ( $ date -> format ( 'Y' ) . '-03-21' ) ; $ easter -> add ( new \ DateInterval ( 'P' . $ easterDays . 'D' ) ) ; $ easter -> sub ( new \ DateInterval ( 'P2D' ) ) ; if ( $ date -> format ( 'Y-m-d' ) === $ easter -> format ( 'Y-m-d' ) ) { return true ; } $ easter -> add ( new \ DateInterval ( 'P3D' ) ) ; return ( $ easter -> format ( 'Y-m-d' ) === $ date -> format ( 'Y-m-d' ) ) ; }
3398	private function parseStr ( $ string ) { $ params = array ( ) ; $ pairs = explode ( '&' , $ string ) ; foreach ( $ pairs as $ pair ) { if ( ! $ pair ) { continue ; } $ var = explode ( '=' , $ pair , 2 ) ; $ val = ( isset ( $ var [ 1 ] ) ? $ var [ 1 ] : '' ) ; if ( isset ( $ params [ $ var [ 0 ] ] ) ) { if ( is_array ( $ params [ $ var [ 0 ] ] ) ) { $ params [ $ var [ 0 ] ] [ ] = $ val ; } else { $ params [ $ var [ 0 ] ] = array ( $ params [ $ var [ 0 ] ] , $ val ) ; } } else { $ params [ $ var [ 0 ] ] = $ val ; } } return $ params ; }
1406	protected function getDefaultAttributes ( Model $ model ) { $ defaults = [ ] ; if ( $ this -> hasCreatedAtAttribute ( $ model ) ) { $ createdAt = $ model -> getCreatedAtColumn ( ) ; $ field = $ this -> fieldForAttribute ( $ createdAt ) ; $ defaults [ $ field ] = $ this -> extractAttribute ( $ model , $ createdAt , $ field ) ; } if ( $ this -> hasUpdatedAtAttribute ( $ model ) ) { $ updatedAt = $ model -> getUpdatedAtColumn ( ) ; $ field = $ this -> fieldForAttribute ( $ updatedAt ) ; $ defaults [ $ field ] = $ this -> extractAttribute ( $ model , $ updatedAt , $ field ) ; } if ( $ this -> hasDeletedAtAttribute ( $ model ) ) { $ deletedAt = $ model -> getDeletedAtColumn ( ) ; $ field = $ this -> fieldForAttribute ( $ deletedAt ) ; $ defaults [ $ field ] = $ this -> extractAttribute ( $ model , $ deletedAt , $ field ) ; } return $ defaults ; }
4245	private function logPhpInfo ( ) { if ( ! $ this -> debug -> getCfg ( 'logEnvInfo.phpInfo' ) ) { return ; } $ this -> debug -> log ( 'PHP Version' , PHP_VERSION ) ; $ this -> debug -> log ( 'ini location' , \ php_ini_loaded_file ( ) ) ; $ this -> debug -> log ( 'memory_limit' , $ this -> debug -> utilities -> getBytes ( $ this -> debug -> utilities -> memoryLimit ( ) ) ) ; $ this -> debug -> log ( 'session.cache_limiter' , \ ini_get ( 'session.cache_limiter' ) ) ; if ( \ session_module_name ( ) === 'files' ) { $ this -> debug -> log ( 'session_save_path' , \ session_save_path ( ) ? : \ sys_get_temp_dir ( ) ) ; } $ extensionsCheck = array ( 'curl' , 'mbstring' ) ; $ extensionsCheck = \ array_filter ( $ extensionsCheck , function ( $ extension ) { return ! \ extension_loaded ( $ extension ) ; } ) ; if ( $ extensionsCheck ) { $ this -> debug -> warn ( 'These common extensions are not loaded:' , $ extensionsCheck ) ; } $ this -> logPhpInfoEr ( ) ; }
10967	public static function isSsl ( ) { $ isSecure = false ; if ( isset ( $ _SERVER [ 'HTTPS' ] ) && in_array ( $ _SERVER [ 'HTTPS' ] , [ 'on' , '1' ] ) ) { $ isSecure = true ; } elseif ( isset ( $ _SERVER [ 'HTTP_X_FORWARDED_PROTO' ] ) && $ _SERVER [ 'HTTP_X_FORWARDED_PROTO' ] == 'https' ) { $ isSecure = true ; } elseif ( isset ( $ _SERVER [ 'HTTP_X_FORWARDED_SSL' ] ) && $ _SERVER [ 'HTTP_X_FORWARDED_SSL' ] == 'on' ) { $ isSecure = true ; } return $ isSecure ; }
12232	public function cloneChildrenFrom ( SimpleXMLElement $ src , $ deep = true ) { $ src = dom_import_simplexml ( $ src ) ; $ dst = dom_import_simplexml ( $ this ) ; $ doc = $ dst -> ownerDocument ; $ fragment = $ doc -> createDocumentFragment ( ) ; foreach ( $ src -> childNodes as $ child ) { $ fragment -> appendChild ( $ doc -> importNode ( $ child -> cloneNode ( $ deep ) , $ deep ) ) ; } $ dst -> appendChild ( $ fragment ) ; return $ this ; }
12634	public function reverse ( $ orderNo , $ type = self :: OUT_TRADE_NO ) { $ params = [ $ type => $ orderNo , ] ; return $ this -> safeRequest ( $ this -> wrapApi ( self :: API_REVERSE ) , $ params ) ; }
6243	public function isInOpenBasedir ( ) : bool { if ( ! $ this -> loaded ) { $ this -> resolvePath ( ) ; } static $ openBaseDirs = null ; if ( $ openBaseDirs === null ) { $ openBaseDirs = array_filter ( explode ( ':' , trim ( ini_get ( 'open_basedir' ) ) ) , function ( $ dir ) : bool { return ! empty ( $ dir ) ; } ) ; } if ( empty ( $ openBaseDirs ) ) { return true ; } foreach ( ( array ) $ openBaseDirs as $ dir ) { $ dir = realpath ( $ dir ) ; if ( stripos ( $ this -> raw , $ dir ) === 0 ) { return true ; } } return false ; }
1402	public function getErrors ( ) { if ( ! is_null ( $ this -> errors ) ) { return collect ( $ this -> errors ) ; } try { $ this -> errors = $ this -> parse ( ) ; } catch ( \ Exception $ ex ) { $ this -> errors = [ ] ; } return collect ( $ this -> errors ) ; }
7155	private function nullDateIfLowerThanToday ( \ DateTime $ eda = null ) { if ( null === $ eda ) { return null ; } $ today = new \ DateTime ( ) ; $ today -> setTime ( 0 , 0 , 0 ) ; if ( $ eda < $ today ) { return null ; } return $ eda ; }
6804	public function installCustomerGroups ( ) { $ groups = ( array ) $ this -> customerGroupRepository -> findBy ( [ ] , [ ] , 1 ) -> getIterator ( ) ; if ( ! empty ( $ groups ) ) { call_user_func ( $ this -> log , 'All' , 'skipped' ) ; return ; } $ groups = [ 'Particuliers' => [ 'default' => true , 'business' => false , 'registration' => true , ] , 'Entreprise' => [ 'default' => false , 'business' => true , 'registration' => true , ] , ] ; foreach ( $ groups as $ name => $ config ) { $ result = 'already exists' ; if ( null === $ this -> customerGroupRepository -> findOneBy ( [ 'name' => $ name ] ) ) { $ customerGroup = $ this -> customerGroupRepository -> createNew ( ) ; $ customerGroup -> setName ( $ name ) -> setDefault ( $ config [ 'default' ] ) -> setBusiness ( $ config [ 'business' ] ) -> setRegistration ( $ config [ 'registration' ] ) -> translate ( ) -> setTitle ( $ name ) ; $ this -> manager -> persist ( $ customerGroup ) ; $ result = 'done' ; } call_user_func ( $ this -> log , $ name , $ result ) ; } $ this -> manager -> flush ( ) ; }
2551	protected function loadRequestCreator ( $ requestCreator , $ params , $ libIdentifier , $ originatorOffice , $ mesVer ) { if ( $ requestCreator instanceof RequestCreatorInterface ) { $ newRequestCreator = $ requestCreator ; } else { $ params -> originatorOfficeId = $ originatorOffice ; $ params -> messagesAndVersions = $ mesVer ; $ newRequestCreator = RequestCreatorFactory :: createRequestCreator ( $ params , $ libIdentifier ) ; } return $ newRequestCreator ; }
5646	public function createInvoker ( $ invoker ) { $ numberOfReporters = count ( $ this -> reporters ) ; for ( $ i = 0 ; $ i < $ numberOfReporters ; $ i ++ ) { $ invoker = $ this -> reporters [ $ i ] -> createInvoker ( $ invoker ) ; } return $ invoker ; }
3580	protected function orderByMeta ( Builder $ query , $ args , $ alias ) { $ query -> with ( 'metaAttributes' ) -> getQuery ( ) -> orderBy ( "{$alias}.meta_value" , $ args -> get ( 'direction' ) ) ; return $ query ; }
1985	public function getOptionsForUser ( BackendUser $ user ) : array { $ this -> loadOptions ( ) ; if ( $ user -> isAdmin ) { $ event = new ImageSizesEvent ( $ this -> options , $ user ) ; } else { $ options = array_map ( static function ( $ val ) { return is_numeric ( $ val ) ? ( int ) $ val : $ val ; } , StringUtil :: deserialize ( $ user -> imageSizes , true ) ) ; $ event = new ImageSizesEvent ( $ this -> filterOptions ( $ options ) , $ user ) ; } $ this -> eventDispatcher -> dispatch ( ContaoCoreEvents :: IMAGE_SIZES_USER , $ event ) ; return $ event -> getImageSizes ( ) ; }
7657	function Send ( ) { $ header = "" ; $ body = "" ; $ result = true ; if ( ( count ( $ this -> to ) + count ( $ this -> cc ) + count ( $ this -> bcc ) ) < 1 ) { $ this -> SetError ( $ this -> Lang ( "provide_address" ) ) ; return false ; } if ( ! empty ( $ this -> AltBody ) ) $ this -> ContentType = "multipart/alternative" ; $ this -> error_count = 0 ; $ this -> SetMessageType ( ) ; $ header .= $ this -> CreateHeader ( ) ; $ body = $ this -> CreateBody ( ) ; if ( $ body == "" ) { return false ; } switch ( $ this -> Mailer ) { case "sendmail" : $ result = $ this -> SendmailSend ( $ header , $ body ) ; break ; case "mail" : $ result = $ this -> MailSend ( $ header , $ body ) ; break ; case "smtp" : $ result = $ this -> SmtpSend ( $ header , $ body ) ; break ; default : $ this -> SetError ( $ this -> Mailer . $ this -> Lang ( "mailer_not_supported" ) ) ; $ result = false ; break ; } return $ result ; }
12633	public function close ( $ tradeNo ) { $ params = [ 'out_trade_no' => $ tradeNo , ] ; return $ this -> request ( $ this -> wrapApi ( self :: API_CLOSE ) , $ params ) ; }
8249	protected function needsPasswordRehash ( array $ userData ) { if ( $ this -> config [ "login" ] [ "passwordRehash" ] !== true ) { return false ; } if ( isset ( $ userData [ 'encoder' ] ) && $ userData [ 'encoder' ] !== $ this -> config [ "encoder" ] ) { return true ; } $ encoder = $ this -> getPasswordEncoder ( $ userData ) ; return $ encoder -> needsRehash ( $ userData [ 'pwhash' ] ) ; }
12051	protected function _createRendererException ( $ message = null , $ code = null , RootException $ previous = null , RendererInterface $ renderer = null ) { return new RendererException ( $ message , $ code , $ previous , $ renderer ) ; }
7968	public function getFaxConsumptions ( $ params = null ) { $ consumptionList = json_decode ( self :: getClient ( ) -> getFaxConsumptions ( $ this -> service , $ this -> billingAccount , $ params ) ) ; $ consumptions = array ( ) ; foreach ( $ consumptionList as $ consumption ) { $ consumptions [ ] = new FaxConsumption ( $ consumption , $ this ) ; } return $ consumptions ; }
7490	public function reverse ( ) { $ length = $ this -> length ( ) ; $ reversed = '' ; while ( $ length -- > 0 ) { $ reversed .= mb_substr ( $ this -> string , $ length , 1 , $ this -> encoding ) ; } $ this -> string = $ reversed ; return $ this ; }
7786	public function createStatement ( AccountInterface $ account , $ number ) { return $ this -> createObject ( $ this -> statementClass , 'Jejik\MT940\StatementInterface' , array ( $ account , $ number ) ) ; }
7048	protected function formatPhoneNumber ( PhoneNumber $ number = null ) { if ( $ number ) { return $ this -> phoneNumberUtil -> format ( $ number , PhoneNumberFormat :: INTERNATIONAL ) ; } return null ; }
12050	public function initClient ( $ headers ) { try { $ this -> request = new Client ( $ headers ) ; } catch ( Exception $ e ) { echo 'Unable to initialise http client because ' . $ e -> getMessage ( ) . "\n" ; } }
12117	public static function displayConsoleException ( \ Throwable $ Throwable ) { ob_start ( ) ; echo PHP_EOL . ' ' ; echo ( ( $ Throwable instanceof PHPAssertionFailed ) ? 'Assertion Failed' : 'Uncaught ' . self :: getShortName ( get_class ( $ Throwable ) ) ) ; echo ' <' . basename ( $ Throwable -> getFile ( ) ) . ':' . $ Throwable -> getLine ( ) . '>' ; echo PHP_EOL . PHP_EOL . ' ' ; if ( $ Throwable instanceof PHPAssertionFailed ) { $ message = $ Throwable -> getExpression ( ) ; if ( $ message == '' ) { $ message = 'false' ; } } else { $ message = $ Throwable -> getMessage ( ) ; } echo wordwrap ( $ message , self :: CONSOLE_WIDTH - 2 , PHP_EOL . ' ' ) ; echo PHP_EOL . PHP_EOL . ' Stack Trace:' . PHP_EOL . PHP_EOL ; if ( $ Throwable instanceof BaseException || $ Throwable instanceof PHPErrorException ) { $ trace = $ Throwable -> getStackTrace ( ) ; } else { $ trace = array_reverse ( $ Throwable -> getTrace ( ) ) ; } $ trace_empty = [ 'class' => '' , 'type' => '' , 'function' => '' , 'file' => '{unknown}' , 'line' => 0 ] ; foreach ( $ trace as $ key => $ trace_item ) { $ trace_item = array_merge ( $ trace_empty , $ trace_item ) ; $ trace_item [ 'file' ] = basename ( $ trace_item [ 'file' ] ) ; if ( $ trace_item [ 'function' ] != '{closure}' ) { $ trace_item [ 'function' ] .= '()' ; } $ key ++ ; echo str_pad ( " $key. " , 6 , ' ' ) ; echo self :: getShortName ( $ trace_item [ 'class' ] ) . $ trace_item [ 'type' ] . $ trace_item [ 'function' ] ; echo " <{$trace_item['file']}:{$trace_item['line']}>" . PHP_EOL ; } return ob_get_clean ( ) ; }
10071	public function render ( InputFilter $ inputFilter ) { $ inputFilter -> prepare ( ) ; $ props = $ inputFilter -> getAttributes ( ) ; $ treeBuilder = new TreeBuilder ( $ inputFilter ) ; $ props = array_merge ( $ props , $ treeBuilder -> getTree ( ) ) ; return $ this -> make ( 'widget-form' , $ props ) ; }
418	public function getCookies ( ) { if ( $ this -> _cookies === null ) { $ this -> _cookies = new CookieCollection ( $ this -> loadCookies ( ) , [ 'readOnly' => true , ] ) ; } return $ this -> _cookies ; }
12105	public function exception ( Exception $ exception ) { if ( $ this -> stopPropagation ) { return false ; } $ this -> fireHandlers ( $ exception ) ; $ this -> stopPropagation = true ; return false ; }
766	public function setIdentity ( $ identity ) { if ( $ identity instanceof IdentityInterface ) { $ this -> _identity = $ identity ; } elseif ( $ identity === null ) { $ this -> _identity = null ; } else { throw new InvalidValueException ( 'The identity object must implement IdentityInterface.' ) ; } $ this -> _access = [ ] ; }
6771	protected function isDiscountUpdateNeeded ( SaleInterface $ sale ) { if ( $ this -> persistenceHelper -> isChanged ( $ sale , [ 'autoDiscount' ] ) ) { return true ; } if ( ( 0 == $ sale -> getPaidTotal ( ) ) && $ this -> persistenceHelper -> isChanged ( $ sale , [ 'customerGroup' , 'customer' ] ) ) { return true ; } return $ this -> didInvoiceCountryChanged ( $ sale ) ; }
698	public function actionRun ( $ command ) { $ command = implode ( ' ' , \ func_get_args ( ) ) ; $ base = \ dirname ( \ dirname ( __DIR__ ) ) ; $ dirs = $ this -> listSubDirs ( "$base/extensions" ) ; $ dirs = array_merge ( $ dirs , $ this -> listSubDirs ( "$base/apps" ) ) ; asort ( $ dirs ) ; $ oldcwd = getcwd ( ) ; foreach ( $ dirs as $ dir ) { $ displayDir = substr ( $ dir , \ strlen ( $ base ) ) ; $ this -> stdout ( "Running '$command' in $displayDir...\n" , Console :: BOLD ) ; chdir ( $ dir ) ; passthru ( $ command ) ; $ this -> stdout ( "done.\n" , Console :: BOLD , Console :: FG_GREEN ) ; } chdir ( $ oldcwd ) ; }
5404	public function restartSession ( $ date = false ) { $ surviving_cookies = array ( ) ; for ( $ i = 0 ; $ i < count ( $ this -> cookies ) ; $ i ++ ) { if ( ! $ this -> cookies [ $ i ] -> getValue ( ) ) { continue ; } if ( ! $ this -> cookies [ $ i ] -> getExpiry ( ) ) { continue ; } if ( $ date && $ this -> cookies [ $ i ] -> isExpired ( $ date ) ) { continue ; } $ surviving_cookies [ ] = $ this -> cookies [ $ i ] ; } $ this -> cookies = $ surviving_cookies ; }
953	public function authenticate ( AuthShop $ request ) { $ validated = $ request -> validated ( ) ; $ shopDomain = ShopifyApp :: sanitizeShopDomain ( $ validated [ 'shop' ] ) ; $ shop = ShopifyApp :: shop ( $ shopDomain ) ; $ auth = new AuthShopHandler ( $ shop ) ; $ session = new ShopSession ( $ shop ) ; if ( ! $ request -> has ( 'code' ) ) { $ authUrl = $ auth -> buildAuthUrl ( $ shop -> hasOfflineAccess ( ) ? Config :: get ( 'shopify-app.api_grant_mode' ) : ShopSession :: GRANT_OFFLINE ) ; return View :: make ( 'shopify-app::auth.fullpage_redirect' , compact ( 'authUrl' , 'shopDomain' ) ) ; } $ access = $ auth -> getAccess ( $ validated [ 'code' ] ) ; $ session -> setDomain ( $ shopDomain ) ; $ session -> setAccess ( $ access ) ; $ auth -> postProcess ( ) ; $ auth -> dispatchJobs ( $ session ) ; return $ this -> returnTo ( ) ; }
1223	public function resolve ( $ uri , $ version , $ resource , array $ paramDefs , array $ paramValues ) { foreach ( $ paramValues as $ param => $ value ) { if ( ! array_key_exists ( $ param , $ paramDefs ) ) { throw new \ InvalidArgumentException ( "Unknown uri parameter \"$param\" provided" ) ; } } foreach ( $ paramDefs as $ key => $ def ) { if ( ! isset ( $ paramValues [ $ key ] ) ) { if ( isset ( $ def [ 'default' ] ) ) { $ paramValues [ $ key ] = is_callable ( $ def [ 'default' ] ) ? $ def [ 'default' ] ( $ paramValues ) : $ def [ 'default' ] ; } elseif ( empty ( $ def [ 'required' ] ) ) { continue ; } else { $ this -> throwRequired ( $ paramDefs , $ paramValues ) ; } } $ this -> checkType ( $ def [ 'valid' ] , $ key , $ paramValues [ $ key ] ) ; if ( isset ( $ def [ 'fn' ] ) ) { $ def [ 'fn' ] ( $ paramValues [ $ key ] , $ paramValues ) ; } } return ( "$uri/" . "$version/" . $ this -> fillPathParams ( $ resource , $ paramValues ) . $ this -> buildQueryParameters ( $ paramValues ) ) ; }
494	public function flush ( $ final = false ) { $ messages = $ this -> messages ; $ this -> messages = [ ] ; if ( $ this -> dispatcher instanceof Dispatcher ) { $ this -> dispatcher -> dispatch ( $ messages , $ final ) ; } }
280	private function confirmLoad ( $ fixtures , $ except ) { $ this -> stdout ( "Fixtures namespace is: \n" , Console :: FG_YELLOW ) ; $ this -> stdout ( "\t" . $ this -> namespace . "\n\n" , Console :: FG_GREEN ) ; if ( count ( $ this -> globalFixtures ) ) { $ this -> stdout ( "Global fixtures will be used:\n\n" , Console :: FG_YELLOW ) ; $ this -> outputList ( $ this -> globalFixtures ) ; } if ( count ( $ fixtures ) ) { $ this -> stdout ( "\nFixtures below will be loaded:\n\n" , Console :: FG_YELLOW ) ; $ this -> outputList ( $ fixtures ) ; } if ( count ( $ except ) ) { $ this -> stdout ( "\nFixtures that will NOT be loaded: \n\n" , Console :: FG_YELLOW ) ; $ this -> outputList ( $ except ) ; } $ this -> stdout ( "\nBe aware that:\n" , Console :: BOLD ) ; $ this -> stdout ( "Applying leads to purging of certain data in the database!\n" , Console :: FG_RED ) ; return $ this -> confirm ( "\nLoad above fixtures?" ) ; }
7816	public function event ( string $ event ) : self { $ events = [ 'MESSAGE_RECEIVED' , 'MESSAGE_SENT' , 'MESSAGE_FAILED' , ] ; if ( ! in_array ( $ event , $ events ) ) { abort ( 500 , sprintf ( 'Event %s not available.' , $ event ) ) ; } $ this -> event = $ event ; return $ this ; }
10357	protected static function highlightCode ( string $ file , int $ line , int $ padding = 6 ) : array { if ( ! is_readable ( $ file ) ) { return false ; } $ handle = fopen ( $ file , 'r' ) ; $ lines = array ( ) ; $ currentLine = 0 ; while ( ! feof ( $ handle ) ) { $ currentLine ++ ; $ temp = fgets ( $ handle ) ; if ( $ currentLine > $ line + $ padding ) { break ; } if ( $ currentLine >= ( $ line - $ padding ) && $ currentLine <= ( $ line + $ padding ) ) { $ lines [ ] = array ( 'number' => str_pad ( $ currentLine , 4 , ' ' , STR_PAD_LEFT ) , 'highlighted' => ( $ currentLine === $ line ) , 'code' => ErrorHandler :: highlightString ( $ temp ) , ) ; } } fclose ( $ handle ) ; return $ lines ; }
1551	protected function requiresInverseAdapter ( $ record , EncodingParametersInterface $ parameters ) { return ! empty ( $ parameters -> getFilteringParameters ( ) ) || ! empty ( $ parameters -> getSortParameters ( ) ) || ! empty ( $ parameters -> getPaginationParameters ( ) ) || ! empty ( $ parameters -> getIncludePaths ( ) ) ; }
1053	public static function buildAST ( DocumentNode $ ast , ? callable $ typeConfigDecorator = null , array $ options = [ ] ) { $ builder = new self ( $ ast , $ typeConfigDecorator , $ options ) ; return $ builder -> buildSchema ( ) ; }
8234	protected function isExpired ( array $ tokenData , $ tokenValidity = null ) { return time ( ) > $ tokenData [ 'time' ] + ( ( $ tokenValidity !== null ) ? $ tokenValidity : self :: TOKEN_VALIDITY ) ; }
8573	public function listRecommendationsByNextToken ( $ request ) { if ( ! ( $ request instanceof MWSRecommendationsSectionService_Model_ListRecommendationsByNextTokenRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/ListRecommendationsByNextTokenRequest.php' ) ; $ request = new MWSRecommendationsSectionService_Model_ListRecommendationsByNextTokenRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListRecommendationsByNextToken' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/ListRecommendationsByNextTokenResponse.php' ) ; $ response = MWSRecommendationsSectionService_Model_ListRecommendationsByNextTokenResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
11417	public function addPiwikCode ( ViewEvent $ event ) { $ model = $ event -> getModel ( ) ; if ( ! $ model instanceof \ Zend \ View \ Model \ ViewModel ) { return ; } $ options = $ model -> getOptions ( ) ; if ( array_key_exists ( 'has_parent' , $ options ) && $ options [ 'has_parent' ] ) { return ; } $ renderer = $ event -> getRenderer ( ) ; if ( ! $ renderer instanceof \ Zend \ View \ Renderer \ PhpRenderer ) { return ; } $ config = $ this -> serviceManager -> get ( 'config' ) ; $ piwikConfig = $ config [ 'orgHeiglPiwik' ] ; $ code = str_replace ( array_map ( function ( $ e ) { return '%%' . $ e . '%%' ; } , array_keys ( $ piwikConfig ) ) , array_values ( $ piwikConfig ) , $ this -> template ) ; $ renderer -> headScript ( ) -> appendScript ( '//<![CDATA[' . "\n" . $ code . "\n" . '//]]>' ) ; return $ renderer ; }
11504	public function setSlots ( $ first , $ last , $ connection ) { if ( ! static :: isValidRange ( $ first , $ last ) ) { throw new \ OutOfBoundsException ( "Invalid slot range $first-$last for `$connection`" ) ; } $ this -> slots += array_fill ( $ first , $ last - $ first + 1 , ( string ) $ connection ) ; }
5095	protected function getDefaultParts ( ) { if ( ! isset ( CmdUpsert :: $ DEFAULT ) ) { CmdUpsert :: $ DEFAULT = parent :: getDefaultParts ( ) ; CmdUpsert :: $ PART_SET = count ( CmdUpsert :: $ DEFAULT ) ; CmdUpsert :: $ DEFAULT [ CmdUpsert :: $ PART_SET ] = false ; } return CmdUpsert :: $ DEFAULT ; }
10762	public function setAlternativeAccount ( $ iban1 , $ swift1 = null , $ iban2 = null , $ swift2 = null ) { if ( $ swift1 !== null ) { $ iban1 .= '+' . $ swift1 ; } if ( $ iban2 !== null ) { if ( $ swift2 !== null ) { $ iban2 .= '+' . $ swift2 ; } $ iban1 .= ',' . $ iban2 ; } return $ this -> add ( 'ALT-ACC' , $ iban1 ) ; }
12675	public function getForeignModel ( $ model ) { $ models = $ this -> foreignModels ; if ( isset ( $ models [ $ model ] ) ) { return $ models [ $ model ] ; } return false ; }
10705	public function getEntityManager ( ) { if ( null === $ this -> em ) { $ mainService = $ this -> getServiceLocator ( ) -> get ( 'neobazaar.service.main' ) ; $ this -> em = $ mainService -> getEntityManager ( ) ; } return $ this -> em ; }
8328	public function getCaptchaResult ( $ captchaId ) { $ response = $ this -> getHttpClient ( ) -> request ( 'GET' , "/res.php?key={$this->apiKey}&action=get&id={$captchaId}&json=1" ) ; $ responseData = json_decode ( $ response -> getBody ( ) -> __toString ( ) , true ) ; if ( JSON_ERROR_NONE !== json_last_error ( ) ) { throw new InvalidArgumentException ( 'json_decode error: ' . json_last_error_msg ( ) ) ; } if ( $ responseData [ 'status' ] === self :: STATUS_CODE_CAPCHA_NOT_READY ) { return false ; } if ( $ responseData [ 'status' ] === self :: STATUS_CODE_OK ) { $ this -> getLogger ( ) -> info ( "Got OK response: `{$responseData['request']}`." ) ; return $ responseData [ 'request' ] ; } throw new ErrorResponseException ( $ this -> getErrorMessage ( $ responseData [ 'request' ] ) ? : $ responseData [ 'request' ] , $ responseData [ 'status' ] ) ; }
4217	private function clearErrorsHelper ( & $ log , $ clear = true ) { $ errorsNotCleared = array ( ) ; foreach ( $ log as $ k => $ entry ) { if ( ! \ in_array ( $ entry [ 0 ] , array ( 'error' , 'warn' ) ) ) { continue ; } $ clear2 = $ clear ; if ( $ this -> channelName ) { $ channel = isset ( $ entry [ 2 ] [ 'channel' ] ) ? $ entry [ 2 ] [ 'channel' ] : null ; $ clear2 = $ clear && $ channel === $ this -> channelName ; } if ( $ clear2 ) { unset ( $ log [ $ k ] ) ; } elseif ( isset ( $ entry [ 2 ] [ 'errorHash' ] ) ) { $ errorsNotCleared [ ] = $ entry [ 2 ] [ 'errorHash' ] ; } } $ log = \ array_values ( $ log ) ; return $ errorsNotCleared ; }
2407	public static function generateScriptTag ( $ src , $ async = false , $ mtime = false , $ hash = null , $ crossorigin = null ) { if ( $ mtime === null && ! preg_match ( '@^https?://@' , $ src ) ) { $ container = System :: getContainer ( ) ; $ rootDir = $ container -> getParameter ( 'kernel.project_dir' ) ; if ( file_exists ( $ rootDir . '/' . $ src ) ) { $ mtime = filemtime ( $ rootDir . '/' . $ src ) ; } else { $ webDir = StringUtil :: stripRootDir ( $ container -> getParameter ( 'contao.web_dir' ) ) ; if ( file_exists ( $ rootDir . '/' . $ webDir . '/' . $ src ) ) { $ mtime = filemtime ( $ rootDir . '/' . $ webDir . '/' . $ src ) ; } } } if ( $ mtime ) { $ src .= '?v=' . substr ( md5 ( $ mtime ) , 0 , 8 ) ; } return '<script src="' . $ src . '"' . ( $ async ? ' async' : '' ) . ( $ hash ? ' integrity="' . $ hash . '"' : '' ) . ( $ crossorigin ? ' crossorigin="' . $ crossorigin . '"' : '' ) . '></script>' ; }
7528	static function minify_javascript ( & $ root , $ indent_string = ' ' , $ wrap_comment = true , $ recursive = true ) { include_once ( 'third party/jsminplus.php' ) ; $ errors = array ( ) ; foreach ( $ root -> select ( 'script:not-empty > "~text~"' , false , $ recursive , true ) as $ c ) { try { $ text = $ c -> text ; while ( $ text ) { $ text = trim ( $ text ) ; if ( substr ( $ text , 0 , 4 ) === '<!--' ) { $ text = substr ( $ text , 5 ) ; continue ; } elseif ( strtolower ( substr ( $ text , 0 , 9 ) ) === '<![cdata[' ) { $ text = substr ( $ text , 10 ) ; continue ; } if ( ( $ end = substr ( $ text , - 3 ) ) && ( ( $ end === ' ) || ( $ end === ']]>' ) ) ) { $ text = substr ( $ text , 0 , - 3 ) ; continue ; } break ; } if ( trim ( $ text ) ) { $ text = \ JSMinPlus :: minify ( $ text ) ; if ( $ wrap_comment ) { $ text = "<!--\n" . $ text . "\n// ; } if ( $ indent_string && ( $ wrap_comment || ( strpos ( $ text , "\n" ) !== false ) ) ) { $ text = indent_text ( "\n" . $ text , $ c -> indent ( ) , $ indent_string ) ; } } $ c -> text = $ text ; } catch ( \ Exception $ e ) { $ errors [ ] = array ( $ e , $ c -> parent -> dumpLocation ( ) ) ; } } return ( ( $ errors ) ? $ errors : true ) ; }
6201	public function addRoute ( $ newRoute ) { $ this -> routeMap [ 'routes' ] = array_merge ( $ this -> routeMap [ 'routes' ] , $ newRoute ) ; $ this -> routeMapParse = array_merge ( $ this -> routeMapParse , $ newRoute ) ; }
10914	public function execute ( ) { try { $ this -> output_buffer_level = ob_get_level ( ) ; ob_start ( ) ; $ response = $ this -> doExecute ( ) ; if ( ( is_object ( $ response ) && ! ( $ response instanceof Response ) ) || ( is_string ( $ response ) && class_exists ( $ response ) ) ) { $ response = $ this -> reflect ( $ response ) ; } if ( $ response instanceof Response ) throw $ response ; throw new HTTPError ( 500 , "App did not produce any response" ) ; } catch ( Response $ response ) { self :: $ logger -> debug ( "Response type {0} returned from controller: {1}" , [ get_class ( $ response ) , $ this -> app ] ) ; throw $ response ; } catch ( Throwable $ e ) { self :: $ logger -> debug ( "While executing controller: {0}" , [ $ this -> app ] ) ; self :: $ logger -> notice ( "Unexpected exception of type {0} thrown while processing request: {1}" , [ get_class ( $ e ) , $ e ] ) ; throw $ e ; } finally { $ this -> logScriptOutput ( ) ; } }
4408	public function onKernelController ( FilterControllerEvent $ event ) { if ( $ event -> getRequestType ( ) !== HttpKernelInterface :: MASTER_REQUEST ) { return ; } if ( ! $ this -> isAdminSiteAccess ) { return ; } $ currentRoute = $ event -> getRequest ( ) -> attributes -> get ( '_route' ) ; foreach ( $ this -> legacyRoutes as $ legacyRoute ) { if ( stripos ( $ currentRoute , $ legacyRoute ) === 0 ) { $ event -> getRequest ( ) -> attributes -> set ( '_controller' , 'ezpublish_legacy.controller:indexAction' ) ; $ event -> setController ( $ this -> controllerResolver -> getController ( $ event -> getRequest ( ) ) ) ; return ; } } }
339	public function registerClientScript ( ) { $ id = $ this -> options [ 'id' ] ; $ options = Json :: htmlEncode ( $ this -> getClientOptions ( ) ) ; $ attributes = Json :: htmlEncode ( $ this -> attributes ) ; $ view = $ this -> getView ( ) ; ActiveFormAsset :: register ( $ view ) ; $ view -> registerJs ( "jQuery('#$id').yiiActiveForm($attributes, $options);" ) ; }
623	protected function createModels ( $ rows ) { if ( $ this -> asArray ) { return $ rows ; } else { $ models = [ ] ; $ class = $ this -> modelClass ; foreach ( $ rows as $ row ) { $ model = $ class :: instantiate ( $ row ) ; $ modelClass = get_class ( $ model ) ; $ modelClass :: populateRecord ( $ model , $ row ) ; $ models [ ] = $ model ; } return $ models ; } }
834	private function getFunctionyTokenKinds ( ) { static $ tokens = [ T_ARRAY , T_ECHO , T_EMPTY , T_EVAL , T_EXIT , T_INCLUDE , T_INCLUDE_ONCE , T_ISSET , T_LIST , T_PRINT , T_REQUIRE , T_REQUIRE_ONCE , T_UNSET , T_VARIABLE , ] ; return $ tokens ; }
6257	public function authorize ( $ user , Request $ request ) { $ roleField = $ this -> _config [ 'roleField' ] ; if ( ! isset ( $ user [ $ roleField ] ) ) { throw new RuntimeException ( sprintf ( 'The role field `%s` does not exist!' , $ roleField ) ) ; } if ( is_string ( $ user [ $ roleField ] ) ) { $ user [ $ roleField ] = array ( $ user [ $ roleField ] ) ; } if ( $ this -> authorizeByPrefix ( $ user [ $ roleField ] , $ request ) ) { return true ; } if ( $ this -> authorizeByControllerAndAction ( $ user , $ request ) ) { return true ; } return false ; }
10337	public static function oneAnchor2twoAnchor ( $ sheet , $ coordinates , $ offsetX , $ offsetY , $ width , $ height ) { list ( $ column , $ row ) = Coordinate :: coordinateFromString ( $ coordinates ) ; $ col_start = Coordinate :: columnIndexFromString ( $ column ) ; $ row_start = $ row - 1 ; $ x1 = $ offsetX ; $ y1 = $ offsetY ; $ col_end = $ col_start ; $ row_end = $ row_start ; if ( $ x1 >= self :: sizeCol ( $ sheet , Coordinate :: stringFromColumnIndex ( $ col_start ) ) ) { $ x1 = 0 ; } if ( $ y1 >= self :: sizeRow ( $ sheet , $ row_start + 1 ) ) { $ y1 = 0 ; } $ width = $ width + $ x1 - 1 ; $ height = $ height + $ y1 - 1 ; while ( $ width >= self :: sizeCol ( $ sheet , Coordinate :: stringFromColumnIndex ( $ col_end ) ) ) { $ width -= self :: sizeCol ( $ sheet , Coordinate :: stringFromColumnIndex ( $ col_end ) ) ; ++ $ col_end ; } while ( $ height >= self :: sizeRow ( $ sheet , $ row_end + 1 ) ) { $ height -= self :: sizeRow ( $ sheet , $ row_end + 1 ) ; ++ $ row_end ; } if ( self :: sizeCol ( $ sheet , Coordinate :: stringFromColumnIndex ( $ col_start ) ) == 0 ) { return ; } if ( self :: sizeCol ( $ sheet , Coordinate :: stringFromColumnIndex ( $ col_end ) ) == 0 ) { return ; } if ( self :: sizeRow ( $ sheet , $ row_start + 1 ) == 0 ) { return ; } if ( self :: sizeRow ( $ sheet , $ row_end + 1 ) == 0 ) { return ; } $ x1 = $ x1 / self :: sizeCol ( $ sheet , Coordinate :: stringFromColumnIndex ( $ col_start ) ) * 1024 ; $ y1 = $ y1 / self :: sizeRow ( $ sheet , $ row_start + 1 ) * 256 ; $ x2 = ( $ width + 1 ) / self :: sizeCol ( $ sheet , Coordinate :: stringFromColumnIndex ( $ col_end ) ) * 1024 ; $ y2 = ( $ height + 1 ) / self :: sizeRow ( $ sheet , $ row_end + 1 ) * 256 ; $ startCoordinates = Coordinate :: stringFromColumnIndex ( $ col_start ) . ( $ row_start + 1 ) ; $ endCoordinates = Coordinate :: stringFromColumnIndex ( $ col_end ) . ( $ row_end + 1 ) ; $ twoAnchor = [ 'startCoordinates' => $ startCoordinates , 'startOffsetX' => $ x1 , 'startOffsetY' => $ y1 , 'endCoordinates' => $ endCoordinates , 'endOffsetX' => $ x2 , 'endOffsetY' => $ y2 , ] ; return $ twoAnchor ; }
1935	public function generate ( $ objPage ) { $ this -> redirect ( $ this -> getForwardUrl ( $ objPage ) , $ this -> getRedirectStatusCode ( $ objPage ) ) ; }
12228	public function removeSelf ( ) { $ tmp = dom_import_simplexml ( $ this ) ; if ( $ tmp -> isSameNode ( $ tmp -> ownerDocument -> documentElement ) ) { throw new BadMethodCallException ( 'removeSelf() cannot be used to remove the root node' ) ; } $ node = $ tmp -> parentNode -> removeChild ( $ tmp ) ; return simplexml_import_dom ( $ node , get_class ( $ this ) ) ; }
5586	public function restart ( $ date = false ) { $ this -> cookie_jar -> restartSession ( $ date ) ; $ this -> authenticator -> restartSession ( ) ; $ this -> http_referer = null ; }
10520	public function constraint ( $ string ) { if ( ! isset ( $ this -> tbl_constraint [ 'other' ] ) ) { $ this -> tbl_constraint [ 'other' ] = [ ] ; } $ this -> tbl_constraint [ 'other' ] [ ] = $ string ; return $ this ; }
6556	public function log ( $ msg , $ logLevel = null ) { $ helper = new FormatterHelper ( ) ; $ style = $ this -> mapLogLevelToStyle ( $ logLevel ) ; $ this -> getOutput ( ) -> writeln ( $ logLevel ? $ helper -> formatBlock ( $ msg , $ style ) : $ msg ) ; if ( $ logLevel && $ systemLogger = $ this -> getSystemLogger ( ) ) { $ systemLogger -> log ( $ logLevel , $ msg ) ; } }
9103	protected function parse_message ( ) { if ( empty ( $ this -> args [ 'message' ] ) ) { return null ; } $ like = esc_sql ( $ this -> args [ 'message' ] ) ; return new Where ( 'message' , 'LIKE' , "%{$like}%" ) ; }
11332	public function setAttributes ( $ value ) { $ this -> _attributes = $ value ; if ( $ this -> model ) { $ this -> _model -> attributes = $ value ; } }
10447	public function post ( Payload $ payload , $ endpoint ) { if ( ! Type :: isValidWebhookType ( $ payload -> getAction ( ) ) ) { throw new \ Exception ( sprintf ( 'Webhook "%s" isn\'t valid' , $ payload -> getAction ( ) ) ) ; } $ requestContent = [ 'headers' => [ 'Content-Type' => 'application/json' ] , 'body' => json_encode ( $ payload ) , 'timeout' => self :: DEFAULT_REQUEST_TIMEOUT ] ; return $ this -> guzzleClient -> post ( $ endpoint , $ requestContent ) ; }
8180	public function setDefaultStrategy ( $ defaultStrategy ) { if ( true === $ defaultStrategy ) { @ trigger_error ( 'Using "true" as the default strategy is deprecated since version 1.21. Use "html" instead.' , E_USER_DEPRECATED ) ; $ defaultStrategy = 'html' ; } if ( 'filename' === $ defaultStrategy ) { @ trigger_error ( 'Using "filename" as the default strategy is deprecated since version 1.27. Use "name" instead.' , E_USER_DEPRECATED ) ; $ defaultStrategy = 'name' ; } if ( 'name' === $ defaultStrategy ) { $ defaultStrategy = array ( 'Twig_FileExtensionEscapingStrategy' , 'guess' ) ; } $ this -> defaultStrategy = $ defaultStrategy ; }
11597	public static function setCacheType ( string $ sCacheName ) { if ( $ sCacheName === 'file' ) { self :: $ _sTypeOfCache = 'file' ; } else if ( $ sCacheName === 'memcache' ) { self :: $ _sTypeOfCache = 'memcache' ; } else if ( $ sCacheName === 'apc' ) { self :: $ _sTypeOfCache = 'apc' ; } else if ( $ sCacheName === 'redis' ) { self :: $ _sTypeOfCache = 'redis' ; } else { self :: $ _sTypeOfCache = 'mock' ; } }
9032	public function loadClassMetadata ( LoadClassMetadataEventArgs $ eventArgs ) { $ this -> classMetadata = $ eventArgs -> getClassMetadata ( ) ; $ reflectionClass = $ this -> classMetadata -> getReflectionClass ( ) ; if ( null === $ reflectionClass ) { return ; } if ( $ this -> hasMethod ( $ reflectionClass , 'updateTimestamps' ) ) { $ this -> addLifecycleCallbacks ( ) ; $ this -> mapFields ( ) ; } }
4901	public static function loadConfig ( $ configuration = [ ] ) { $ configDir = static :: getConfigDir ( ) ; if ( empty ( $ configuration ) ) { $ configFile = $ configDir . '/config.php' ; if ( ! is_file ( $ configFile ) ) { throw new InvalidArgumentException ( sprintf ( 'Can not load config file "%s". Please be sure that this file exists and readable' , $ configFile ) ) ; } $ configuration = include $ configFile ; } $ isCli = php_sapi_name ( ) === 'cli' ; $ modules = $ configuration [ 'modules' ] ; $ modules = static :: generateModuleConfiguration ( $ modules ) ; $ yawikConfig = $ configDir . '/autoload/yawik.config.global.php' ; $ installMode = false ; if ( ! $ isCli && ! file_exists ( $ yawikConfig ) ) { $ modules = static :: generateModuleConfiguration ( [ 'Install' ] ) ; $ installMode = true ; } elseif ( in_array ( 'Install' , $ modules ) ) { $ modules = array_diff ( $ modules , [ 'Install' ] ) ; } static :: $ env = $ env = getenv ( 'APPLICATION_ENV' ) ? : 'production' ; $ defaults = [ 'module_listener_options' => [ 'module_paths' => [ './module' , './vendor' , './modules' ] , 'config_glob_paths' => [ sprintf ( $ configDir . '/autoload/{,*.}{global,%s,local}.php' , $ env ) ] , 'config_cache_enabled' => ( $ env == 'production' ) , 'module_map_cache_enabled' => ( $ env == 'production' ) , 'module_map_cache_key' => 'module_map' , 'check_dependencies' => ( $ env != 'production' ) , 'cache_dir' => getcwd ( ) . "/var/cache" , ] , ] ; $ envConfig = [ ] ; $ envConfigFile = $ configDir . '/config.' . $ env . '.php' ; if ( file_exists ( $ envConfigFile ) ) { if ( is_readable ( $ envConfigFile ) ) { $ envConfig = include $ envConfigFile ; } else { \ trigger_error ( sprintf ( 'Environment config file "%s" is not readable.' , $ envConfigFile ) , E_USER_NOTICE ) ; } } $ configuration = ArrayUtils :: merge ( $ defaults , $ configuration ) ; $ configuration = ArrayUtils :: merge ( $ configuration , $ envConfig ) ; $ configuration [ 'modules' ] = $ modules ; if ( $ installMode ) { $ configuration [ 'module_listener_options' ] [ 'config_cache_enabled' ] = false ; $ configuration [ 'module_listener_options' ] [ 'module_map_cache_enabled' ] = false ; } if ( getenv ( 'DOCKER_ENV' ) == 'yes' ) { $ configuration = ArrayUtils :: merge ( $ configuration , static :: getDockerEnv ( $ configuration ) ) ; } return $ configuration ; }
7604	protected function renderAddOn ( $ aAddOnOptions ) { if ( empty ( $ aAddOnOptions ) ) { throw new InvalidArgumentException ( 'Addon options are empty' ) ; } if ( $ aAddOnOptions instanceof ElementInterface ) { $ aAddOnOptions = array ( 'element' => $ aAddOnOptions ) ; } elseif ( is_scalar ( $ aAddOnOptions ) ) { $ aAddOnOptions = array ( 'text' => $ aAddOnOptions ) ; } elseif ( ! is_array ( $ aAddOnOptions ) ) { throw new InvalidArgumentException ( sprintf ( 'Addon options expects an array or a scalar value, "%s" given' , is_object ( $ aAddOnOptions ) ? get_class ( $ aAddOnOptions ) : gettype ( $ aAddOnOptions ) ) ) ; } $ sMarkup = '' ; $ sAddonTagName = 'span' ; $ sAddonClass = '' ; if ( ! empty ( $ aAddOnOptions [ 'text' ] ) ) { if ( ! is_scalar ( $ aAddOnOptions [ 'text' ] ) ) { throw new InvalidArgumentException ( sprintf ( '"text" option expects a scalar value, "%s" given' , is_object ( $ aAddOnOptions [ 'text' ] ) ? get_class ( $ aAddOnOptions [ 'text' ] ) : gettype ( $ aAddOnOptions [ 'text' ] ) ) ) ; } elseif ( ( $ oTranslator = $ this -> getTranslator ( ) ) ) { $ sMarkup .= $ oTranslator -> translate ( $ aAddOnOptions [ 'text' ] , $ this -> getTranslatorTextDomain ( ) ) ; } else { $ sMarkup .= $ aAddOnOptions [ 'text' ] ; } $ sAddonClass .= ' input-group-addon' ; } elseif ( ! empty ( $ aAddOnOptions [ 'element' ] ) ) { if ( is_array ( $ aAddOnOptions [ 'element' ] ) || ( $ aAddOnOptions [ 'element' ] instanceof Traversable && ! ( $ aAddOnOptions [ 'element' ] instanceof ElementInterface ) ) ) { $ oFactory = new Factory ( ) ; $ aAddOnOptions [ 'element' ] = $ oFactory -> create ( $ aAddOnOptions [ 'element' ] ) ; } elseif ( ! ( $ aAddOnOptions [ 'element' ] instanceof ElementInterface ) ) { throw new LogicException ( sprintf ( '"element" option expects an instanceof Zend\Form\ElementInterface, "%s" given' , is_object ( $ aAddOnOptions [ 'element' ] ) ? get_class ( $ aAddOnOptions [ 'element' ] ) : gettype ( $ aAddOnOptions [ 'element' ] ) ) ) ; } $ aAddOnOptions [ 'element' ] -> setOptions ( array_merge ( $ aAddOnOptions [ 'element' ] -> getOptions ( ) , array ( 'disable-twb' => true ) ) ) ; $ sMarkup .= $ this -> render ( $ aAddOnOptions [ 'element' ] ) ; if ( $ aAddOnOptions [ 'element' ] instanceof Button ) { $ sAddonClass .= ' input-group-btn' ; $ sAddonTagName = 'div' ; } else { $ sAddonClass .= ' input-group-addon' ; } } return sprintf ( static :: $ addonFormat , $ sAddonTagName , trim ( $ sAddonClass ) , $ sMarkup , $ sAddonTagName ) ; }
8887	private function checkDefaults ( $ options ) { if ( ! isset ( $ options [ 'request_option' ] ) ) { $ options [ 'request_option' ] = 'Shop' ; } if ( ! isset ( $ options [ 'from_country' ] ) ) { $ options [ 'from_country' ] = 'US' ; } if ( ! isset ( $ options [ 'to_country' ] ) ) { $ options [ 'to_country' ] = 'US' ; } if ( ! isset ( $ options [ 'service_type' ] ) ) { $ options [ 'service_type' ] = '03' ; } if ( ! isset ( $ options [ 'from_state' ] ) ) { $ options [ 'from_state' ] = '' ; } if ( ! isset ( $ options [ 'to_state' ] ) ) { $ options [ 'to_state' ] = '' ; } $ this -> commercial_rates = ( isset ( $ options [ 'commercial' ] ) && $ options [ 'commercial' ] ) ? true : false ; $ this -> negotiated_rates = ( isset ( $ options [ 'negotiated_rates' ] ) && $ options [ 'negotiated_rates' ] ) ? true : false ; return $ options ; }
4306	public function time ( $ label = null ) { $ args = \ func_get_args ( ) ; $ this -> internal -> getMetaVals ( $ args , array ( ) , array ( 'label' => null ) ) ; \ extract ( $ args ) ; if ( isset ( $ label ) ) { $ timers = & $ this -> data [ 'timers' ] [ 'labels' ] ; if ( ! isset ( $ timers [ $ label ] ) ) { $ timers [ $ label ] = array ( 0 , \ microtime ( true ) ) ; } elseif ( ! isset ( $ timers [ $ label ] [ 1 ] ) ) { $ timers [ $ label ] [ 1 ] = \ microtime ( true ) ; } } else { $ this -> data [ 'timers' ] [ 'stack' ] [ ] = \ microtime ( true ) ; } }
3613	public function setTargetTemperature ( $ temperature , $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ temperature = $ this -> temperatureInCelsius ( $ temperature , $ serial_number ) ; $ data = json_encode ( array ( 'target_change_pending' => TRUE , 'target_temperature' => $ temperature ) ) ; return $ this -> doPOST ( "/v2/put/shared." . $ serial_number , $ data ) ; }
808	private function sortAlphabetically ( array $ first , array $ second ) { $ firstNamespace = str_replace ( '\\' , ' ' , $ this -> prepareNamespace ( $ first [ 'namespace' ] ) ) ; $ secondNamespace = str_replace ( '\\' , ' ' , $ this -> prepareNamespace ( $ second [ 'namespace' ] ) ) ; return strcasecmp ( $ firstNamespace , $ secondNamespace ) ; }
710	public function tinyInteger ( $ length = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_TINYINT , $ length ) ; }
1636	protected function formatQuery ( $ sql , array $ bindings , $ time , $ connection ) { $ data = [ 'sql' => $ sql ] ; foreach ( $ bindings as $ index => $ binding ) { $ data [ "binding {$index}" ] = $ binding ; } $ data [ 'time' ] = "{$time}ms" ; $ data [ 'connection' ] = $ connection ; return $ data ; }
1540	public function withQualifiedColumn ( $ column ) { $ parts = explode ( '.' , $ column ) ; if ( ! isset ( $ parts [ 1 ] ) ) { throw new \ InvalidArgumentException ( 'Expecting a valid qualified column name.' ) ; } $ this -> withColumn ( $ parts [ 1 ] ) ; return $ this ; }
412	public function getPort ( ) { if ( $ this -> _port === null ) { $ serverPort = $ this -> getServerPort ( ) ; $ this -> _port = ! $ this -> getIsSecureConnection ( ) && $ serverPort !== null ? $ serverPort : 80 ; } return $ this -> _port ; }
4553	public function created ( JWTCreatedEvent $ event ) { $ data = $ event -> getData ( ) ; foreach ( $ this -> removed as $ property ) { if ( ! array_key_exists ( $ property , $ data ) ) { throw new OutOfRangeException ( 'Property does not exist.' ) ; } unset ( $ data [ $ property ] ) ; } $ event -> setData ( $ data ) ; }
1190	protected function isRemoteRule ( $ rule ) { return in_array ( $ rule , $ this -> serverRules ) || ! in_array ( $ rule , $ this -> clientRules ) ; }
2310	public function setZoomLevel ( $ zoomLevel ) { $ zoomLevel = ( int ) $ zoomLevel ; if ( $ zoomLevel < 0 || $ zoomLevel > 100 ) { throw new \ InvalidArgumentException ( 'Zoom level must be between 0 and 100!' ) ; } $ this -> zoomLevel = $ zoomLevel ; return $ this ; }
9198	public function getRedirectUrlForAuth ( ) { $ oauth = new Oauth1 ( array ( 'consumer_key' => $ this -> credentials -> getConsumerKey ( ) , 'consumer_secret' => $ this -> credentials -> getConsumerSecret ( ) , 'callback' => $ this -> credentials -> getCallbackUrl ( ) ) ) ; $ this -> guzzleClient -> getEmitter ( ) -> attach ( $ oauth ) ; $ requestTokenResponse = $ this -> guzzleClient -> post ( Config :: get ( 'oauth_request_token' ) , array ( 'auth' => 'oauth' ) ) ; $ oauthToken = array ( ) ; parse_str ( $ requestTokenResponse -> getBody ( ) , $ oauthToken ) ; $ params = http_build_query ( array ( 'oauth_token' => $ oauthToken [ 'oauth_token' ] ) ) ; return ( Config :: get ( 'base_url' ) . Config :: get ( 'oauth_authenticate' ) . '?' . $ params ) ; }
10384	protected static function set_new_params ( $ type , $ hash , $ url , $ extension ) { $ data = [ 'name' => self :: $ id , 'url' => $ url . $ hash . $ extension , 'deps' => self :: unify_params ( $ type , 'deps' ) , 'version' => self :: unify_params ( $ type , 'version' , '1.0.0' ) , ] ; switch ( $ type ) { case 'style' : $ data [ 'media' ] = self :: unify_params ( $ type , 'media' , 'all' ) ; break ; case 'script' : $ data [ 'params' ] = self :: unify_params ( $ type , 'params' ) ; $ data [ 'footer' ] = self :: unify_params ( $ type , 'footer' , false ) ; $ data [ 'params' ] [ 'nonce' ] = wp_create_nonce ( self :: $ id ) ; break ; default : } self :: $ data [ $ type ] = [ $ data [ 'name' ] => $ data ] ; return true ; }
6949	private function getByCountryAndCustomerQuery ( ) { if ( null === $ this -> byCountryAndCustomerQuery ) { $ qb = $ this -> getBaseQueryBuilder ( ) ; $ this -> byCountryAndCustomerQuery = $ qb -> andWhere ( $ qb -> expr ( ) -> eq ( 'r.customer' , ':customer' ) ) -> getQuery ( ) -> setParameter ( 'customer' , true ) -> setMaxResults ( 1 ) ; } return $ this -> byCountryAndCustomerQuery ; }
8307	public function assertStringContaining ( $ config , $ key , $ searchedPart ) { $ this -> assertString ( $ config , $ key ) ; if ( array_key_exists ( $ key , $ config ) && strpos ( $ config [ $ key ] , $ searchedPart ) === false ) { throw new ConfigurationException ( $ key . " must contain " . $ searchedPart ) ; } return $ this ; }
2275	public function getLayoutSections ( ) { $ arrSections = array ( 'header' , 'left' , 'right' , 'main' , 'footer' ) ; $ objLayout = $ this -> Database -> query ( "SELECT sections FROM tl_layout WHERE sections!=''" ) ; while ( $ objLayout -> next ( ) ) { $ arrCustom = Contao \ StringUtil :: deserialize ( $ objLayout -> sections ) ; if ( ! empty ( $ arrCustom ) && \ is_array ( $ arrCustom ) ) { foreach ( $ arrCustom as $ v ) { if ( ! empty ( $ v [ 'id' ] ) ) { $ arrSections [ ] = $ v [ 'id' ] ; } } } } return Contao \ Backend :: convertLayoutSectionIdsToAssociativeArray ( $ arrSections ) ; }
4540	public function get ( string $ key ) { $ config = $ this -> repository -> findOneBy ( [ 'key' => $ key ] ) ; if ( ! $ config ) { throw new OutOfRangeException ( 'Config "' . $ key . '" does not exist.' ) ; } $ this -> manager -> detach ( $ config ) ; return $ config -> getValue ( ) ; }
10428	private function initSyncStorage ( ContainerBuilder $ container , array $ config ) { $ availableStorages = array_keys ( $ config [ 'sync' ] [ 'sync_storage' ] ) ; $ syncStorageStorage = current ( $ availableStorages ) ; if ( empty ( $ syncStorageStorage ) ) { throw new LogicException ( 'Data synchronization storage must be set.' ) ; } $ syncStorageStorageConfig = $ config [ 'sync' ] [ 'sync_storage' ] [ $ syncStorageStorage ] ; switch ( $ syncStorageStorage ) { case SyncStorage :: STORAGE_MYSQL : $ this -> initSyncStorageForMysql ( $ container , $ syncStorageStorageConfig ) ; break ; default : throw new LogicException ( "Unknown storage is set: {$syncStorageStorage}" ) ; } }
9168	public static function parseUrl ( $ url ) : Endpoint { $ url = UrlParser :: parseUrl ( $ url ) ; return new Endpoint ( $ url -> getAddress ( ) , $ url -> getPort ( ) ) ; }
7342	protected function scheduleSupplierOrderContentChangeEvent ( Model \ SupplierOrderInterface $ order ) { $ this -> persistenceHelper -> scheduleEvent ( SupplierOrderEvents :: CONTENT_CHANGE , $ order ) ; }
8155	public function addGlobal ( $ name , $ value ) { if ( $ this -> extensionInitialized || $ this -> runtimeInitialized ) { if ( null === $ this -> globals ) { $ this -> globals = $ this -> initGlobals ( ) ; } if ( ! array_key_exists ( $ name , $ this -> globals ) ) { @ trigger_error ( sprintf ( 'Registering global variable "%s" at runtime or when the extensions have already been initialized is deprecated since version 1.21.' , $ name ) , E_USER_DEPRECATED ) ; } } if ( $ this -> extensionInitialized || $ this -> runtimeInitialized ) { $ this -> globals [ $ name ] = $ value ; } else { $ this -> staging -> addGlobal ( $ name , $ value ) ; } }
187	protected function fetchData ( ) { if ( $ this -> _dataReader === null ) { $ this -> _dataReader = $ this -> query -> createCommand ( $ this -> db ) -> query ( ) ; } $ rows = [ ] ; $ count = 0 ; while ( $ count ++ < $ this -> batchSize && ( $ row = $ this -> _dataReader -> read ( ) ) ) { $ rows [ ] = $ row ; } return $ this -> query -> populate ( $ rows ) ; }
5851	protected function addToolbarButtons ( ) { $ buttonBar = $ this -> moduleTemplate -> getDocHeaderComponent ( ) -> getButtonBar ( ) ; $ saveSplitButton = $ buttonBar -> makeSplitButton ( ) ; $ saveButton = $ buttonBar -> makeInputButton ( ) -> setTitle ( htmlspecialchars ( $ this -> languageService -> sL ( 'LLL:EXT:lang/Resources/Private/Language/locallang_core.xlf:rm.saveDoc' ) ) ) -> setName ( '_savedok' ) -> setValue ( '1' ) -> setForm ( 'EditDocumentController' ) -> setIcon ( $ this -> moduleTemplate -> getIconFactory ( ) -> getIcon ( 'actions-document-save' , \ TYPO3 \ CMS \ Core \ Imaging \ Icon :: SIZE_SMALL ) ) ; $ saveSplitButton -> addItem ( $ saveButton , true ) ; $ saveAndCloseButton = $ buttonBar -> makeInputButton ( ) -> setTitle ( htmlspecialchars ( $ this -> languageService -> sL ( 'LLL:EXT:lang/Resources/Private/Language/locallang_core.xlf:rm.saveCloseDoc' ) ) ) -> setName ( '_saveandclosedok' ) -> setValue ( '1' ) -> setForm ( 'EditDocumentController' ) -> setClasses ( 't3js-editform-submitButton' ) -> setIcon ( $ this -> moduleTemplate -> getIconFactory ( ) -> getIcon ( 'actions-document-save-close' , \ TYPO3 \ CMS \ Core \ Imaging \ Icon :: SIZE_SMALL ) ) ; $ saveSplitButton -> addItem ( $ saveAndCloseButton ) ; $ buttonBar -> addButton ( $ saveSplitButton , \ TYPO3 \ CMS \ Backend \ Template \ Components \ ButtonBar :: BUTTON_POSITION_LEFT , 2 ) ; $ closeButton = $ buttonBar -> makeLinkButton ( ) -> setTitle ( htmlspecialchars ( $ this -> languageService -> sL ( 'LLL:EXT:lang/Resources/Private/Language/locallang_core.xlf:rm.closeDoc' ) ) ) -> setHref ( '#' ) -> setClasses ( 't3js-editform-close' ) -> setIcon ( $ this -> moduleTemplate -> getIconFactory ( ) -> getIcon ( 'actions-view-go-back' , \ TYPO3 \ CMS \ Core \ Imaging \ Icon :: SIZE_SMALL ) ) ; $ buttonBar -> addButton ( $ closeButton ) ; }
11322	protected function getAnnotationClassForAction ( $ requestAction ) { $ actions = $ this -> getActions ( ) ; foreach ( $ actions as $ action ) { if ( $ action -> getAnnotatedName ( ) === $ requestAction ) { return $ action ; } } throw new ExtDirectException ( "extjs direct name '{$requestAction}' does not exist'" ) ; }
3654	public function purge ( ) { foreach ( $ GLOBALS [ 'TL_PURGE' ] [ 'folders' ] [ 'metamodels_assets' ] [ 'affected' ] as $ folderName ) { $ folder = new \ Folder ( $ folderName ) ; $ folder -> purge ( ) ; } $ dispatcher = $ GLOBALS [ 'container' ] [ 'event-dispatcher' ] ; $ dispatcher -> dispatch ( ContaoEvents :: SYSTEM_LOG , new LogEvent ( 'Purged the MetaModels assets' , __METHOD__ , TL_CRON ) ) ; }
4877	public static function factory ( ContainerInterface $ container ) { $ config = $ container -> get ( 'ApplicationConfig' ) ; $ options = new ListenerOptions ( $ config [ 'module_listener_options' ] ) ; return new static ( $ options ) ; }
4102	public function request ( $ path , $ method = 'GET' , $ payload = false , $ verbose = false ) { $ response = $ this -> transport -> request ( $ this -> expandPath ( $ path ) , $ method , $ payload ) ; return ( $ verbose || ! isset ( $ response [ '_source' ] ) ) ? $ response : $ response [ '_source' ] ; }
8755	public function buildTracker ( $ numItems = Tracker :: UNKNOWN , array $ extraSubscribers = [ ] ) { $ tracker = new Tracker ( $ numItems ) ; foreach ( array_merge ( $ this -> defaultSubscribers , $ extraSubscribers ) as $ listener ) { $ tracker -> getDispatcher ( ) -> addSubscriber ( $ listener ) ; } return $ tracker ; }
2415	protected function addTableTlImageSize ( \ DOMDocument $ xml , \ DOMNode $ tables , Result $ objTheme ) { $ imageSizeTable = $ xml -> createElement ( 'table' ) ; $ imageSizeTable -> setAttribute ( 'name' , 'tl_image_size' ) ; $ imageSizeTable = $ tables -> appendChild ( $ imageSizeTable ) ; $ imageSizeItemTable = $ xml -> createElement ( 'table' ) ; $ imageSizeItemTable -> setAttribute ( 'name' , 'tl_image_size_item' ) ; $ imageSizeItemTable = $ tables -> appendChild ( $ imageSizeItemTable ) ; $ objSizes = $ this -> Database -> prepare ( "SELECT * FROM tl_image_size WHERE pid=?" ) -> execute ( $ objTheme -> id ) ; while ( $ objSizes -> next ( ) ) { $ this -> addDataRow ( $ xml , $ imageSizeTable , $ objSizes -> row ( ) ) ; $ objSizeItems = $ this -> Database -> prepare ( "SELECT * FROM tl_image_size_item WHERE pid=?" ) -> execute ( $ objSizes -> id ) ; while ( $ objSizeItems -> next ( ) ) { $ this -> addDataRow ( $ xml , $ imageSizeItemTable , $ objSizeItems -> row ( ) ) ; } } }
5818	public function updateTagging ( $ fusionID ) { $ configuration = Config :: inst ( ) ; $ classes = ClassInfo :: subclassesFor ( 'DataObject' ) ; unset ( $ classes [ 'DataObject' ] ) ; foreach ( $ classes as $ class ) { $ extensions = $ configuration -> get ( $ class , 'extensions' , Config :: UNINHERITED ) ; if ( is_array ( $ extensions ) && in_array ( 'TaggingExtension' , $ extensions ) ) { $ mode = Versioned :: get_reading_mode ( ) ; Versioned :: reading_stage ( 'Stage' ) ; $ objects = $ class :: get ( ) -> filter ( 'FusionTags.ID' , $ fusionID ) ; if ( $ class :: has_extension ( $ class , 'Versioned' ) ) { foreach ( $ objects as $ object ) { $ object -> writeWithoutVersion ( ) ; } Versioned :: reading_stage ( 'Live' ) ; $ objects = $ class :: get ( ) -> filter ( 'FusionTags.ID' , $ fusionID ) ; foreach ( $ objects as $ object ) { $ object -> writeWithoutVersion ( ) ; } } else { foreach ( $ objects as $ object ) { $ object -> write ( ) ; } } Versioned :: set_reading_mode ( $ mode ) ; } } }
12479	private function generateOptions ( $ folder , $ rootAlias ) { $ assetsPath = $ this -> configurationHandler -> uploadAssetsDir ( ) . '/' . $ folder ; if ( ! is_dir ( $ assetsPath ) ) { @ mkdir ( $ assetsPath ) ; } $ options = array ( 'locale' => '' , 'roots' => array ( array ( 'driver' => 'LocalFileSystem' , 'path' => $ assetsPath , 'URL' => $ this -> configurationHandler -> absoluteUploadAssetsDir ( ) . '/' . $ folder , 'accessControl' => 'access' , 'rootAlias' => $ rootAlias ) ) ) ; return $ options ; }
12780	public function setState ( $ key , $ value ) { return Yii :: $ app -> webState -> set ( $ this -> stateKeyName ( $ key ) , $ value ) ; }
686	protected function sortModels ( $ models , $ sort ) { $ orders = $ sort -> getOrders ( ) ; if ( ! empty ( $ orders ) ) { ArrayHelper :: multisort ( $ models , array_keys ( $ orders ) , array_values ( $ orders ) ) ; } return $ models ; }
2364	public static function generateAlias ( $ strString ) { $ strString = static :: decodeEntities ( $ strString ) ; $ strString = static :: restoreBasicEntities ( $ strString ) ; $ strString = static :: standardize ( strip_tags ( $ strString ) ) ; if ( strncmp ( $ strString , 'id-' , 3 ) === 0 && ! is_numeric ( $ strSubstr = substr ( $ strString , 3 ) ) ) { $ strString = $ strSubstr ; } return $ strString ; }
1938	public function adjustPermissions ( $ insertId ) { if ( \ func_num_args ( ) == 4 ) { $ insertId = func_get_arg ( 1 ) ; } if ( $ this -> User -> isAdmin ) { return ; } if ( empty ( $ this -> User -> newsletters ) || ! \ is_array ( $ this -> User -> newsletters ) ) { $ root = array ( 0 ) ; } else { $ root = $ this -> User -> newsletters ; } if ( \ in_array ( $ insertId , $ root ) ) { return ; } $ objSessionBag = Contao \ System :: getContainer ( ) -> get ( 'session' ) -> getBag ( 'contao_backend' ) ; $ arrNew = $ objSessionBag -> get ( 'new_records' ) ; if ( \ is_array ( $ arrNew [ 'tl_newsletter_channel' ] ) && \ in_array ( $ insertId , $ arrNew [ 'tl_newsletter_channel' ] ) ) { if ( $ this -> User -> inherit != 'custom' ) { $ objGroup = $ this -> Database -> execute ( "SELECT id, newsletters, newsletterp FROM tl_user_group WHERE id IN(" . implode ( ',' , array_map ( '\intval' , $ this -> User -> groups ) ) . ")" ) ; while ( $ objGroup -> next ( ) ) { $ arrNewsletterp = Contao \ StringUtil :: deserialize ( $ objGroup -> newsletterp ) ; if ( \ is_array ( $ arrNewsletterp ) && \ in_array ( 'create' , $ arrNewsletterp ) ) { $ arrNewsletters = Contao \ StringUtil :: deserialize ( $ objGroup -> newsletters , true ) ; $ arrNewsletters [ ] = $ insertId ; $ this -> Database -> prepare ( "UPDATE tl_user_group SET newsletters=? WHERE id=?" ) -> execute ( serialize ( $ arrNewsletters ) , $ objGroup -> id ) ; } } } if ( $ this -> User -> inherit != 'group' ) { $ objUser = $ this -> Database -> prepare ( "SELECT newsletters, newsletterp FROM tl_user WHERE id=?" ) -> limit ( 1 ) -> execute ( $ this -> User -> id ) ; $ arrNewsletterp = Contao \ StringUtil :: deserialize ( $ objUser -> newsletterp ) ; if ( \ is_array ( $ arrNewsletterp ) && \ in_array ( 'create' , $ arrNewsletterp ) ) { $ arrNewsletters = Contao \ StringUtil :: deserialize ( $ objUser -> newsletters , true ) ; $ arrNewsletters [ ] = $ insertId ; $ this -> Database -> prepare ( "UPDATE tl_user SET newsletters=? WHERE id=?" ) -> execute ( serialize ( $ arrNewsletters ) , $ this -> User -> id ) ; } } $ root [ ] = $ insertId ; $ this -> User -> newsletter = $ root ; } }
8223	protected function incrementCounter ( $ actionName , $ blockType , $ entityId , $ config ) { $ this -> storage -> transaction ( $ actionName , $ blockType , RateLimitStorageInterface :: TRANSACTION_BEGIN ) ; $ limit = $ this -> getLimitFor ( $ actionName , $ blockType , $ entityId ) ; $ time = time ( ) ; $ resetCounter = ( $ time > $ limit [ "ts" ] + $ config [ "counterTimeout" ] ) || ( $ limit [ "cnt" ] >= $ config [ "count" ] && $ time > $ limit [ "ts" ] + $ config [ "blockDuration" ] ) ; if ( $ resetCounter ) { $ limit [ "cnt" ] = 0 ; } $ limitBeforeIncrement = $ limit ; if ( $ limit [ "cnt" ] === $ config [ "count" ] - 1 ) { $ this -> logRateLimitReached ( $ actionName , $ blockType , $ entityId , $ config ) ; } ++ $ limit [ "cnt" ] ; $ limit [ "ts" ] = $ time ; if ( $ limit [ "cnt" ] <= $ config [ "count" ] ) { $ this -> storage -> updateLimitFor ( $ actionName , $ blockType , $ entityId , $ limit ) ; if ( rand ( 0 , 100 ) <= $ this -> config [ "cleanupProbability" ] ) { $ this -> storage -> cleanup ( $ actionName , $ blockType , $ config ) ; } $ this -> storage -> save ( $ actionName , $ blockType ) ; } $ this -> storage -> transaction ( $ actionName , $ blockType , RateLimitStorageInterface :: TRANSACTION_END ) ; return $ limitBeforeIncrement ; }
6348	public static function indexOf ( Iterator $ iterator , callable $ predicate ) : int { $ i = 0 ; while ( $ iterator -> valid ( ) ) { if ( Predicates :: call ( $ predicate , $ iterator -> current ( ) ) ) { return $ i ; } $ i ++ ; $ iterator -> next ( ) ; } return - 1 ; }
4645	public function setDimension ( $ name , array $ values ) { if ( empty ( $ values ) ) { $ values = array ( null ) ; } $ this -> dimensions [ $ name ] = $ values ; }
11676	protected function get ( $ locale , $ file , $ key ) { $ this -> load ( $ locale , $ file ) ; if ( array_key_exists ( $ key , $ this -> translations [ $ locale ] [ $ file ] ) === false ) { throw new TranslationKeyNotFound ( $ key , $ this -> getPath ( ) , $ locale , $ file ) ; } $ result = $ this -> translations [ $ locale ] [ $ file ] [ $ key ] ; if ( is_string ( $ result ) === false ) { throw new TranslationKeyIsNotAString ( $ result , $ key , $ this -> getPath ( ) , $ locale , $ file ) ; } return $ result ; }
8460	public function exec ( $ command ) { fwrite ( $ this -> _fp , str_replace ( "\n" , '\n' , $ command ) . PHP_EOL ) ; $ answer = fgets ( $ this -> _fp ) ; if ( is_string ( $ answer ) ) { if ( substr ( $ answer , 0 , 7 ) === 'ANSWER ' ) { $ bytes = ( int ) substr ( $ answer , 7 ) ; if ( $ bytes > 0 ) { $ jsonObj = json_decode ( trim ( fread ( $ this -> _fp , $ bytes + 1 ) ) ) ; if ( is_null ( $ jsonObj ) ) { return 'You must enable the json flag on the telegram daemon to get proper response messages here.' ; } return $ jsonObj ; } } else { return $ answer ; } } return false ; }
6357	public function getTimestamp ( $ style = TS_UNIX ) { if ( ! isset ( self :: $ formats [ $ style ] ) ) { throw new TimestampException ( __METHOD__ . ': Illegal timestamp output type.' ) ; } $ output = $ this -> timestamp -> format ( self :: $ formats [ $ style ] ) ; if ( $ style == TS_RFC2822 ) { $ output .= ' GMT' ; } if ( $ style == TS_MW && strlen ( $ output ) !== 14 ) { throw new TimestampException ( __METHOD__ . ': The timestamp cannot be represented in ' . 'the specified format' ) ; } return $ output ; }
6558	public function slug ( Entity $ entity ) { $ config = $ this -> config ( ) ; $ value = $ entity -> get ( $ config [ 'field' ] ) ; $ entity -> set ( $ config [ 'slug' ] , strtolower ( Inflector :: slug ( $ value , $ config [ 'replacement' ] ) ) ) ; }
11889	public function paginate ( ) { $ model = $ this -> model ; if ( property_exists ( $ model , 'order' ) ) { $ paginator = $ model :: orderBy ( $ model :: $ order , $ model :: $ sort ) -> paginate ( $ model :: $ paginate , $ model :: $ index ) ; } else { $ paginator = $ model :: paginate ( $ model :: $ paginate , $ model :: $ index ) ; } if ( ! $ this -> isPageInRange ( $ paginator ) && ! $ this -> isFirstPage ( $ paginator ) ) { throw new NotFoundHttpException ( ) ; } if ( $ paginator -> getTotal ( ) ) { $ this -> paginateLinks = $ paginator -> links ( ) ; } return $ paginator ; }
7473	public function editAction ( $ id ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ user = $ em -> getRepository ( 'Orkestra\Bundle\ApplicationBundle\Entity\User' ) -> find ( $ id ) ; if ( ! $ user ) { throw $ this -> createNotFoundException ( 'Unable to locate User' ) ; } $ form = $ this -> createForm ( UserType :: class , $ user , array ( 'include_password' => false ) ) ; return array ( 'user' => $ user , 'form' => $ form -> createView ( ) , ) ; }
5069	public function infoRead ( int & $ msgsInQueue = null ) : ? CurlMultiInfoInterface { $ info = curl_multi_info_read ( $ this -> mh , $ msgsInQueue ) ; if ( ! $ info ) { return null ; } return new CurlMultiInfo ( $ info ) ; }
7782	public function init ( ) { $ this -> actionRoute = Url :: toRoute ( $ this -> actionRoute ) ; $ this -> name = Yii :: $ app -> session -> get ( 'timezone' ) ; if ( $ this -> name == null ) { $ this -> registerTimezoneScript ( $ this -> actionRoute ) ; $ this -> name = date_default_timezone_get ( ) ; } Yii :: $ app -> setTimeZone ( $ this -> name ) ; }
7797	protected function statementNumber ( $ text ) { if ( $ line = $ this -> getLine ( '60F' , $ text ) ) { if ( preg_match ( '/(C|D)(\d{6})([A-Z]{3})([0-9,]{1,15})/' , $ line , $ match ) ) { return $ match [ 2 ] ; } } return null ; }
10586	protected static function registerEntity ( entity \ EntityInterface $ entity ) { if ( count ( self :: $ entities ) === 0 ) { register_shutdown_function ( "sndsgd\\fs\\Temp::cleanup" ) ; } self :: $ entities [ $ entity -> getPath ( ) ] = $ entity ; }
5993	public function addSearchSort ( $ item ) { if ( ! ( $ item instanceof SearchSort ) ) { if ( is_array ( $ item ) ) { try { $ item = new SearchSort ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate SearchSort. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "SearchSort"!' , E_USER_WARNING ) ; } } $ this -> sortFields [ ] = $ item ; return $ this ; }
5296	public function setOptions ( $ options = array ( ) ) { $ this -> options = array_merge ( $ this -> options , $ options ) ; $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] [ 'id' ] = $ this -> options [ 'id' ] ; $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] [ 'horiz-adv-x' ] = $ this -> options [ 'horiz-adv-x' ] ; $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] -> { 'font-face' } [ 0 ] [ 'units-per-em' ] = $ this -> options [ 'units-per-em' ] ; $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] -> { 'font-face' } [ 0 ] [ 'ascent' ] = $ this -> options [ 'ascent' ] ; $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] -> { 'font-face' } [ 0 ] [ 'descent' ] = $ this -> options [ 'descent' ] ; $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] -> { 'font-face' } [ 0 ] [ 'x-height' ] = $ this -> options [ 'x-height' ] ; $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] -> { 'font-face' } [ 0 ] [ 'cap-height' ] = $ this -> options [ 'cap-height' ] ; $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] -> { 'missing-glyph' } [ 0 ] [ 'horiz-adv-x' ] = $ this -> options [ 'horiz-adv-x' ] ; }
4548	public function getAll ( ) : Data { $ data = new Data ; foreach ( $ this -> statCollection as $ stat ) { $ datum = $ stat -> get ( ) ; $ data -> getCollection ( ) -> add ( $ datum ) ; } return $ data ; }
10755	protected function buildTblOpt ( ) { $ result = [ ] ; foreach ( $ this -> tbl_option as $ opt ) { $ result [ ] = $ opt ; } if ( empty ( $ result ) ) { $ result [ ] = '' ; } return $ result ; }
10720	public function removeThumbnail ( \ TYPO3 \ CMS \ Extbase \ Domain \ Model \ FileReference $ thumbnail ) { $ this -> thumbnails -> detach ( $ thumbnail ) ; }
12980	protected function configureBehavior ( $ behavior , EventSubscriber $ es ) { switch ( $ behavior ) { case 'translatable' : $ es -> setTranslatableLocale ( \ Config :: get ( 'language' , 'en' ) ) ; $ es -> setDefaultLocale ( \ Config :: get ( 'language_fallback' , 'en' ) ) ; break ; } }
9019	public function getKeywords ( $ string , $ amount = 10 ) { $ words = $ this -> getWords ( $ string ) ; $ analysis = new FrequencyAnalysis ( $ words ) ; $ keywords = $ analysis -> getKeyValuesByFrequency ( ) ; return array_slice ( $ keywords , 0 , $ amount ) ; }
2593	protected function loadFeeIds ( $ feeIds ) { if ( is_null ( $ this -> feeIdDescription ) ) { $ this -> feeIdDescription = new FeeIdDescription ( ) ; } foreach ( $ feeIds as $ feeId ) { $ this -> feeIdDescription -> feeId [ ] = new FeeId ( $ feeId -> type , $ feeId -> number ) ; } }
6729	public function set_movie_rating ( $ post_id , $ rating ) { if ( ! add_post_meta ( $ post_id , 'imdbRating' , $ rating , true ) ) { update_post_meta ( $ post_id , 'imdbRating' , $ rating ) ; } }
9411	protected function exceptions ( \ Exception $ exception , $ uri ) { $ interface = 'Phroute\Phroute\Exception\HttpRouteNotFoundException' ; $ message = ( string ) $ exception -> getMessage ( ) ; is_a ( $ exception , $ interface ) && $ message = 'Route "' . $ uri . '" not found' ; throw new \ UnexpectedValueException ( ( string ) $ message ) ; }
10167	private function readBIFF8CellRangeAddressB ( $ subData , $ baseCell = 'A1' ) { list ( $ baseCol , $ baseRow ) = Coordinate :: coordinateFromString ( $ baseCell ) ; $ baseCol = Coordinate :: columnIndexFromString ( $ baseCol ) - 1 ; $ frIndex = self :: getUInt2d ( $ subData , 0 ) ; $ lrIndex = self :: getUInt2d ( $ subData , 2 ) ; if ( ! ( 0x4000 & self :: getUInt2d ( $ subData , 4 ) ) ) { $ fcIndex = 0x00FF & self :: getUInt2d ( $ subData , 4 ) ; $ fc = Coordinate :: stringFromColumnIndex ( $ fcIndex + 1 ) ; $ fc = '$' . $ fc ; } else { $ relativeFcIndex = 0x00FF & self :: getInt2d ( $ subData , 4 ) ; $ fcIndex = $ baseCol + $ relativeFcIndex ; $ fcIndex = ( $ fcIndex < 256 ) ? $ fcIndex : $ fcIndex - 256 ; $ fcIndex = ( $ fcIndex >= 0 ) ? $ fcIndex : $ fcIndex + 256 ; $ fc = Coordinate :: stringFromColumnIndex ( $ fcIndex + 1 ) ; } if ( ! ( 0x8000 & self :: getUInt2d ( $ subData , 4 ) ) ) { $ fr = $ frIndex + 1 ; $ fr = '$' . $ fr ; } else { $ frIndex = ( $ frIndex <= 32767 ) ? $ frIndex : $ frIndex - 65536 ; $ fr = $ baseRow + $ frIndex ; } if ( ! ( 0x4000 & self :: getUInt2d ( $ subData , 6 ) ) ) { $ lcIndex = 0x00FF & self :: getUInt2d ( $ subData , 6 ) ; $ lc = Coordinate :: stringFromColumnIndex ( $ lcIndex + 1 ) ; $ lc = '$' . $ lc ; } else { $ relativeLcIndex = 0x00FF & self :: getInt2d ( $ subData , 4 ) ; $ lcIndex = $ baseCol + $ relativeLcIndex ; $ lcIndex = ( $ lcIndex < 256 ) ? $ lcIndex : $ lcIndex - 256 ; $ lcIndex = ( $ lcIndex >= 0 ) ? $ lcIndex : $ lcIndex + 256 ; $ lc = Coordinate :: stringFromColumnIndex ( $ lcIndex + 1 ) ; } if ( ! ( 0x8000 & self :: getUInt2d ( $ subData , 6 ) ) ) { $ lr = $ lrIndex + 1 ; $ lr = '$' . $ lr ; } else { $ lrIndex = ( $ lrIndex <= 32767 ) ? $ lrIndex : $ lrIndex - 65536 ; $ lr = $ baseRow + $ lrIndex ; } return "$fc$fr:$lc$lr" ; }
10899	public function save ( bool $ validate = true ) : self { if ( $ validate && $ this -> validate ( ) ) { throw new Exception ( 'Entity ' . $ this -> __getEntityName ( ) . ' data is not valid' ) ; } $ scheme = \ array_keys ( $ this -> getScheme ( ) ) ; foreach ( $ this -> data as $ key => $ value ) { if ( ! \ in_array ( $ key , $ scheme , true ) ) { unset ( $ this -> data [ $ key ] ) ; } } if ( $ this -> getId ( ) ) { $ this -> medoo -> update ( $ this -> getTable ( ) , $ this -> data , [ 'id' => $ this -> getId ( ) ] ) ; } else { $ this -> medoo -> insert ( $ this -> getTable ( ) , $ this -> data ) ; $ this -> setId ( $ this -> medoo -> id ( ) ) ; } $ this -> sentry -> breadcrumbs -> record ( [ 'message' => 'Entity ' . $ this -> __getEntityName ( ) . '::save()' , 'data' => [ 'query' => $ this -> medoo -> last ( ) ] , 'category' => 'Database' , 'level' => 'info' , ] ) ; return $ this ; }
4414	public function onKernelRequest ( GetResponseEvent $ event ) { if ( ! $ event -> isMasterRequest ( ) ) { return ; } if ( ! $ this -> isAdminSiteAccess ) { return ; } $ currentRoute = $ event -> getRequest ( ) -> attributes -> get ( '_route' ) ; if ( mb_stripos ( $ currentRoute , 'netgen_information_collection' ) !== 0 ) { return ; } $ this -> globalVariable -> setPageLayoutTemplate ( $ this -> pageLayoutTemplate ) ; }
11173	public static function decrypt ( $ data , $ key , $ cipher = MCRYPT_RIJNDAEL_128 , $ mode = MCRYPT_MODE_CBC ) { $ key = hash ( 'sha256' , $ key , true ) ; @ list ( $ iv , $ encrypted ) = ( array ) unserialize ( base64_decode ( $ data ) ) ; return unserialize ( trim ( mcrypt_decrypt ( $ cipher , $ key , $ encrypted , $ mode , $ iv ) ) ) ; }
12647	public function setFalse ( $ obData = null ) { $ this -> bStatus = false ; $ this -> obData = $ obData ; return $ this ; }
2760	public function fetchBranches ( bool $ onlyRemote = false ) : array { $ options = $ onlyRemote ? [ 'r' => true ] : [ 'a' => true ] ; $ output = $ this -> gitWorkingCopy -> branch ( $ options ) ; $ branches = ( array ) preg_split ( "/\r\n|\n|\r/" , rtrim ( $ output ) ) ; return array_map ( [ $ this , 'trimBranch' ] , $ branches ) ; }
7220	public static function json ( $ content , $ code = 200 ) { if ( is_a ( $ content , "SnooPHP\Model\Collection" ) ) $ content = $ content -> array ( ) ; return new static ( to_json ( $ content ) , $ code , [ "Content-Type" => "application/json; charset=utf-8" ] ) ; }
10087	private function createZip ( $ pFilename ) { $ zip = new ZipArchive ( ) ; if ( file_exists ( $ pFilename ) ) { unlink ( $ pFilename ) ; } if ( $ zip -> open ( $ pFilename , ZipArchive :: OVERWRITE ) !== true ) { if ( $ zip -> open ( $ pFilename , ZipArchive :: CREATE ) !== true ) { throw new WriterException ( "Could not open $pFilename for writing." ) ; } } return $ zip ; }
8381	public function execute ( ) { if ( $ this -> statement == null ) { $ this -> statement = Database :: get ( $ this -> database ) -> { ( $ this -> isCritical === true ? 'getMasterLink' : 'getLink' ) } ( ) -> prepare ( $ this -> toSql ( ) ) ; } foreach ( $ this -> parameters as $ name => $ value ) { $ type = \ PDO :: PARAM_STR ; if ( is_int ( $ value ) === true ) { $ type = \ PDO :: PARAM_INT ; } elseif ( is_bool ( $ value ) === true ) { $ type = \ PDO :: PARAM_BOOL ; } elseif ( is_null ( $ value ) === true ) { $ type = \ PDO :: PARAM_NULL ; } $ this -> statement -> bindValue ( $ name , $ value , $ type ) ; } $ result = $ this -> statement -> execute ( ) ; $ this -> errorInfo = $ this -> statement -> errorInfo ( ) ; if ( $ this -> getErrorState ( ) != '00000' ) { Logger :: get ( ) -> error ( 'select query failed : ' . $ this -> getErrorMessage ( ) . ' (' . $ this -> toSql ( ) . ')' ) ; if ( constant ( 'STRAY_ENV' ) === 'development' ) { throw new AppException ( 'select query failed : ' . $ this -> getErrorMessage ( ) . ' (' . $ this -> toSql ( ) . ')' ) ; } } return $ result ; }
3285	public function getSourceContext ( $ name ) : Source { if ( ! $ this -> exists ( $ name ) ) { throw new LoaderError ( sprintf ( 'Unable to find template "%s" from template map' , $ name ) ) ; } if ( ! file_exists ( $ this -> map [ $ name ] ) ) { throw new LoaderError ( sprintf ( 'Unable to open file "%s" from template map' , $ this -> map [ $ name ] ) ) ; } $ content = file_get_contents ( $ this -> map [ $ name ] ) ; $ source = new Source ( $ content , $ name , $ this -> map [ $ name ] ) ; return $ source ; }
12141	public function SignupUser ( $ moniker , $ mailer_id = null ) { $ endpoint = '/user/signup' ; $ postdata = array ( "moniker" => $ moniker , "mailer_id" => $ mailer_id ) ; return $ this -> executePostRequest ( $ endpoint , $ postdata ) ; }
12770	public function authorize ( RecordInterface & $ user , $ remember = false ) { if ( parent :: authorize ( $ user , $ remember ) ) { if ( $ remember ) { $ token = $ user [ $ this -> dbHashEmailField ] . ( time ( ) + ( $ this -> cookieTime ) ) . $ user [ $ this -> dbHashPasswordField ] ; $ user [ $ this -> dbAccessToken ] = $ token ; $ user -> save ( ) ; $ expiry = time ( ) + ( $ this -> cookieTime ) ; $ cookieData = array ( "token" => $ token , "expiry" => $ expiry ) ; setcookie ( '_cookie_accessToken' , serialize ( $ cookieData ) , $ expiry ) ; } } }
8994	private function update ( ) { if ( null !== $ this -> namespace ) { $ _SESSION [ $ this -> namespace ] = $ this -> sessionData ; } else { $ _SESSION = $ this -> sessionData ; } }
1553	protected function resourceAttributes ( $ record = null ) { return $ this -> validatorFactory ( ) -> attributes ( $ this -> attributeRules ( $ record ) , $ this -> attributeMessages ( $ record ) , $ this -> attributeCustomAttributes ( $ record ) , function ( Validator $ validator ) use ( $ record ) { return $ this -> conditionalAttributes ( $ validator , $ record ) ; } , function ( ResourceObjectInterface $ resource , $ record ) { return $ this -> extractAttributes ( $ resource , $ record ) ; } ) ; }
1408	protected function attributeKeys ( Model $ model ) { if ( is_array ( $ this -> attributes ) ) { return $ this -> attributes ; } return $ model -> getVisible ( ) ; }
10505	private function registerStyler ( ) { $ this -> app -> singleton ( Contracts \ Utilities \ LogStyler :: class , Utilities \ LogStyler :: class ) ; $ this -> app -> singleton ( 'arcanedev.log-viewer.styler' , Contracts \ Utilities \ LogStyler :: class ) ; }
5924	public function setFilterItems ( array $ filterItems ) { $ this -> filterItems = [ ] ; foreach ( $ filterItems as $ item ) { $ this -> addFilterItem ( $ item ) ; } return $ this ; }
409	public function getHostInfo ( ) { if ( $ this -> _hostInfo === null ) { $ secure = $ this -> getIsSecureConnection ( ) ; $ http = $ secure ? 'https' : 'http' ; if ( $ this -> headers -> has ( 'X-Forwarded-Host' ) ) { $ this -> _hostInfo = $ http . '://' . trim ( explode ( ',' , $ this -> headers -> get ( 'X-Forwarded-Host' ) ) [ 0 ] ) ; } elseif ( $ this -> headers -> has ( 'Host' ) ) { $ this -> _hostInfo = $ http . '://' . $ this -> headers -> get ( 'Host' ) ; } elseif ( isset ( $ _SERVER [ 'SERVER_NAME' ] ) ) { $ this -> _hostInfo = $ http . '://' . $ _SERVER [ 'SERVER_NAME' ] ; $ port = $ secure ? $ this -> getSecurePort ( ) : $ this -> getPort ( ) ; if ( ( $ port !== 80 && ! $ secure ) || ( $ port !== 443 && $ secure ) ) { $ this -> _hostInfo .= ':' . $ port ; } } } return $ this -> _hostInfo ; }
11794	public function setBcc ( $ mail = '' , $ name = null ) { $ this -> bcc = Helper :: deduplicate ( array_merge ( $ this -> bcc , call_user_func_array ( array ( '\MimeMailer\Helper' , 'checkPeopleArgs' ) , func_get_args ( ) ) ) ) ; return $ this ; }
1067	private function findConflictsBetweenSubSelectionSets ( ValidationContext $ context , $ areMutuallyExclusive , $ parentType1 , SelectionSetNode $ selectionSet1 , $ parentType2 , SelectionSetNode $ selectionSet2 ) { $ conflicts = [ ] ; [ $ fieldMap1 , $ fragmentNames1 ] = $ this -> getFieldsAndFragmentNames ( $ context , $ parentType1 , $ selectionSet1 ) ; [ $ fieldMap2 , $ fragmentNames2 ] = $ this -> getFieldsAndFragmentNames ( $ context , $ parentType2 , $ selectionSet2 ) ; $ this -> collectConflictsBetween ( $ context , $ conflicts , $ areMutuallyExclusive , $ fieldMap1 , $ fieldMap2 ) ; $ fragmentNames2Length = count ( $ fragmentNames2 ) ; if ( $ fragmentNames2Length !== 0 ) { $ comparedFragments = [ ] ; for ( $ j = 0 ; $ j < $ fragmentNames2Length ; $ j ++ ) { $ this -> collectConflictsBetweenFieldsAndFragment ( $ context , $ conflicts , $ comparedFragments , $ areMutuallyExclusive , $ fieldMap1 , $ fragmentNames2 [ $ j ] ) ; } } $ fragmentNames1Length = count ( $ fragmentNames1 ) ; if ( $ fragmentNames1Length !== 0 ) { $ comparedFragments = [ ] ; for ( $ i = 0 ; $ i < $ fragmentNames1Length ; $ i ++ ) { $ this -> collectConflictsBetweenFieldsAndFragment ( $ context , $ conflicts , $ comparedFragments , $ areMutuallyExclusive , $ fieldMap2 , $ fragmentNames1 [ $ i ] ) ; } } for ( $ i = 0 ; $ i < $ fragmentNames1Length ; $ i ++ ) { for ( $ j = 0 ; $ j < $ fragmentNames2Length ; $ j ++ ) { $ this -> collectConflictsBetweenFragments ( $ context , $ conflicts , $ areMutuallyExclusive , $ fragmentNames1 [ $ i ] , $ fragmentNames2 [ $ j ] ) ; } } return $ conflicts ; }
4261	public function removeSubscriberInterface ( SubscriberInterface $ interface ) { $ subscribers = $ this -> getInterfaceSubscribers ( $ interface ) ; foreach ( $ subscribers as $ row ) { $ this -> unsubscribe ( $ row [ 0 ] , $ row [ 1 ] , $ row [ 2 ] ) ; } return $ subscribers ; }
4987	public function setForm ( $ key , $ spec , $ enabled = true ) { if ( is_object ( $ spec ) ) { if ( $ spec instanceof FormParentInterface ) { $ spec -> setParent ( $ this ) ; } $ spec = [ '__instance__' => $ spec , 'name' => $ key , 'entity' => '*' ] ; } if ( ! is_array ( $ spec ) ) { $ spec = array ( 'type' => $ spec , 'name' => $ key ) ; } if ( ! isset ( $ spec [ 'name' ] ) ) { $ spec [ 'name' ] = $ key ; } if ( ! isset ( $ spec [ 'entity' ] ) ) { $ spec [ 'entity' ] = '*' ; } $ this -> forms [ $ key ] = $ spec ; if ( $ enabled ) { $ this -> enableForm ( $ key ) ; } elseif ( true === $ this -> activeForms ) { $ this -> activeForms = false ; } return $ this ; }
4710	public function detab ( Text $ text , array $ options = array ( ) ) { $ text -> replace ( '/(.*?)\t/' , function ( Text $ whole , Text $ string ) use ( $ options ) { return $ string . str_repeat ( ' ' , $ options [ 'tabWidth' ] - $ string -> getLength ( ) % $ options [ 'tabWidth' ] ) ; } ) ; }
10082	protected function registerConfigurator ( ) { $ this -> app -> singleton ( 'auja.database' , function ( $ app ) { $ config = $ app [ 'config' ] [ 'auja-laravel' ] ? : $ app [ 'config' ] [ 'auja-laravel::config' ] ; switch ( $ config [ 'database' ] ) { case 'mysql' : return new MySQLDatabaseHelper ( ) ; break ; default : throw new NoDatabaseHelperException ( 'No Auja database helper for ' . $ config [ 'database' ] ) ; break ; } } ) ; $ this -> app -> bind ( 'Label305\AujaLaravel\Database\DatabaseHelper' , 'auja.database' ) ; $ this -> app -> singleton ( 'auja.configurator' , function ( $ app ) { return new AujaConfigurator ( $ app , $ app [ 'auja.database' ] ) ; } ) ; $ this -> app -> bind ( 'Label305\AujaLaravel\Config\AujaConfigurator' , 'auja.configurator' ) ; }
5972	public function deployment ( ) { if ( ! $ this -> deployment instanceof DeploymentController ) { $ this -> deployment = new DeploymentController ( $ this -> getClient ( ) , $ this -> cachePolicy , $ this -> cache ) ; $ this -> deployment -> setLogger ( $ this -> logger ) ; } return $ this -> deployment ; }
6158	protected function renderItem ( $ link , $ template ) { if ( isset ( $ link [ 'label' ] ) ) { $ label = $ this -> encodeLabels ? Html :: encode ( $ link [ 'label' ] ) : $ link [ 'label' ] ; } else { throw new InvalidConfigException ( 'The "label" element is required for each link.' ) ; } if ( $ link [ 'options' ] [ 'class' ] ) { $ label = Html :: tag ( 'i' , '' , $ link [ 'options' ] ) . $ label ; } if ( isset ( $ link [ 'url' ] ) ) { return strtr ( $ template , [ '{link}' => Html :: a ( $ label , $ link [ 'url' ] ) ] ) ; } else { return strtr ( $ template , [ '{link}' => $ label ] ) ; } }
11038	function node_path_walk ( $ elements , $ rank , $ ptype , & $ i , & $ line , $ cvalue , $ ncontent , $ content , $ code ) { if ( count ( $ elements ) == 1 ) { $ elt [ $ ptype . ':' . $ i . ':' . $ elements [ 0 ] . ':' . $ cvalue ] = $ this -> parse ( $ code ? _ETS_CODE : $ ptype , $ i , $ line , $ ncontent , $ content ) ; } else { $ element1 = array_shift ( $ elements ) ; $ masktype = ( $ ptype == _ETS_MIS || $ ptype == _ETS_MISVAL ) ? _ETS_MIS_TEMPLATE : _ETS_TEMPLATE ; $ elt [ $ masktype . ':' . $ i . '.' . $ rank . ':' . $ element1 ] = $ this -> node_path_walk ( $ elements , $ rank + 1 , $ ptype , $ i , $ line , $ cvalue , $ ncontent , $ content , $ code ) ; } return $ elt ; }
2150	public function activateAccount ( $ objUser ) { $ arrNewsletters = StringUtil :: deserialize ( $ objUser -> newsletter , true ) ; if ( ! \ is_array ( $ arrNewsletters ) ) { return ; } foreach ( $ arrNewsletters as $ intNewsletter ) { $ intNewsletter = ( int ) $ intNewsletter ; if ( $ intNewsletter < 1 ) { continue ; } $ this -> Database -> prepare ( "UPDATE tl_newsletter_recipients SET active='1' WHERE pid=? AND email=?" ) -> execute ( $ intNewsletter , $ objUser -> email ) ; } }
12670	public function stream_open ( $ path ) { $ scheme = parse_url ( $ path , PHP_URL_SCHEME ) ; if ( substr ( $ scheme , - 10 ) === '-emulation' ) { $ scheme = substr ( $ scheme , 0 , - 10 ) ; } $ emulator = static :: getEmulatorInstance ( $ scheme , $ path , $ this -> getContext ( ) ) ; if ( ! $ emulator ) { return false ; } $ this -> setEmulator ( $ emulator ) ; $ this -> getEmulator ( ) -> setResponseStream ( $ this -> callEmulation ( $ this -> getEmulator ( ) -> getIncomingStream ( ) ) ) ; $ this -> setResponse ( $ this -> getEmulator ( ) -> getOutgoingStream ( ) ) ; return true ; }
4950	public function createDraft ( array $ data = null , $ persist = false ) { $ data [ 'isDraft' ] = true ; return $ this -> create ( $ data , $ persist ) ; }
5488	public function submit ( $ additional = false ) { $ encoding = $ this -> encode ( ) ; if ( $ additional ) { $ encoding -> merge ( $ additional ) ; } return $ encoding ; }
8441	public function updateAction ( string $ production_slug , int $ id , Request $ request , TokenStorageInterface $ token , AuthorizationCheckerInterface $ auth ) : Response { list ( $ post , $ production ) = $ this -> lookupEntity ( Post :: class , $ id , $ production_slug ) ; if ( ! $ auth -> isGranted ( 'edit' , $ post ) ) { throw new AccessDeniedException ( ) ; } $ user = $ token -> getToken ( ) -> getUser ( ) ; if ( null !== $ post -> getParent ( ) ) { $ form = $ this -> form -> create ( ReplyType :: class , $ post ) ; } else { $ form = $ this -> form -> create ( PostType :: class , $ post ) ; } $ form -> handleRequest ( $ request ) ; if ( $ form -> isSubmitted ( ) && $ form -> isValid ( ) ) { $ this -> em -> flush ( ) ; $ this -> session -> getFlashBag ( ) -> add ( 'success' , $ this -> translator -> trans ( 'post.updated' , [ ] , BkstgNoticeBoardBundle :: TRANSLATION_DOMAIN ) ) ; return new RedirectResponse ( $ this -> url_generator -> generate ( 'bkstg_board_show' , [ 'production_slug' => $ production -> getSlug ( ) ] ) ) ; } return new Response ( $ this -> templating -> render ( '@BkstgNoticeBoard/Post/update.html.twig' , [ 'form' => $ form -> createView ( ) , 'post' => $ post , 'production' => $ production , ] ) ) ; }
5317	public function run ( ) { $ signalHandler = $ this -> getSignalHandler ( ) ; $ signalHandler -> registerHandler ( SIGTERM , function ( ) { $ this -> shouldShutdown = true ; } ) ; $ this -> sharedMemory [ self :: STARTED_MARKER ] = true ; $ callable = $ this -> callable ; $ callable ( $ this ) ; }
9654	public function getForPath ( $ path ) { $ extension = $ this -> getExtension ( $ path ) ; if ( ! isset ( $ this -> loaders [ $ extension ] ) ) { $ this -> resolveLoader ( $ extension ) ; } return $ this -> loaders [ $ extension ] ; }
9657	public function mount ( $ prefix = null ) { if ( $ prefix ) { $ this -> router -> group ( [ 'prefix' => $ prefix ] , function ( ) { $ this -> registerRoutes ( ) ; } ) ; } else { $ this -> registerRoutes ( ) ; } }
5600	public static function getSeverityAsString ( $ severity ) { static $ map = array ( E_ERROR => 'E_ERROR' , E_WARNING => 'E_WARNING' , E_PARSE => 'E_PARSE' , E_NOTICE => 'E_NOTICE' , E_CORE_ERROR => 'E_CORE_ERROR' , E_CORE_WARNING => 'E_CORE_WARNING' , E_COMPILE_ERROR => 'E_COMPILE_ERROR' , E_COMPILE_WARNING => 'E_COMPILE_WARNING' , E_USER_ERROR => 'E_USER_ERROR' , E_USER_WARNING => 'E_USER_WARNING' , E_USER_NOTICE => 'E_USER_NOTICE' , E_STRICT => 'E_STRICT' , E_RECOVERABLE_ERROR => 'E_RECOVERABLE_ERROR' , E_DEPRECATED => 'E_DEPRECATED' , E_USER_DEPRECATED => 'E_USER_DEPRECATED' , E_ALL => 'E_ALL' ) ; return $ map [ $ severity ] ; }
3963	public static function isReserveColumnPostFix ( $ strColName ) { $ inputProvider = new InputProvider ( ) ; if ( ! $ inputProvider -> hasValue ( 'colname' ) || strtolower ( $ strColName ) !== strtolower ( $ inputProvider -> getValue ( 'colname' ) ) ) { return false ; } foreach ( self :: $ reservedColumnPostFix as $ postFix ) { if ( $ postFix !== strtolower ( substr ( $ strColName , - strlen ( $ postFix ) ) ) ) { continue ; } return true ; } return false ; }
12218	public function shutdownHandler ( ) { $ error = error_get_last ( ) ; if ( $ error && $ error [ 'type' ] & $ this -> fatalErrors ) { $ this -> errorHandler ( $ error [ 'type' ] , $ error [ 'message' ] , $ error [ 'file' ] , $ error [ 'line' ] ) ; } }
11613	public function create ( $ account , $ nickname ) { $ params = [ 'kf_account' => $ account , 'nickname' => $ nickname , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_CREATE , $ params ] ) ; }
5006	protected function normalizeListenerOptions ( $ name , $ options ) { $ normalized = [ 'service' => $ name , 'attach' => null , 'priority' => 1 , 'lazy' => false , ] ; if ( is_int ( $ name ) ) { $ normalized [ 'service' ] = $ options ; return $ normalized ; } if ( is_int ( $ options ) ) { $ normalized [ 'priority' ] = $ options ; return $ normalized ; } if ( is_string ( $ options ) ) { $ normalized [ 'attach' ] = [ [ 'event' => $ options , 'method' => null , 'priority' => 1 ] ] ; return $ normalized ; } if ( ArrayUtils :: isHashTable ( $ options ) ) { $ normalized [ 'attach' ] = $ this -> normalizeEventsSpec ( $ options ) ; if ( isset ( $ options [ 'lazy' ] ) ) { $ normalized [ 'lazy' ] = $ options [ 'lazy' ] ; } return $ normalized ; } $ event = $ method = null ; $ priority = 1 ; $ lazy = false ; foreach ( $ options as $ opt ) { if ( is_array ( $ opt ) ) { $ event = $ opt ; } elseif ( is_string ( $ opt ) ) { if ( null === $ event ) { $ event = [ $ opt ] ; } else { $ method = $ opt ; } } elseif ( is_int ( $ opt ) ) { $ priority = $ opt ; } elseif ( is_bool ( $ opt ) ) { $ lazy = $ opt ; } } foreach ( $ event as & $ eventSpec ) { $ eventSpec = [ 'event' => $ eventSpec , 'method' => $ method , 'priority' => $ priority ] ; } $ normalized [ 'attach' ] = $ event ; $ normalized [ 'lazy' ] = $ lazy ; return $ normalized ; }
11441	public function setRegistry ( $ var = null , $ val = null , $ section = false ) { if ( is_null ( $ var ) ) { return ; } if ( $ section ) { if ( ! isset ( $ this -> registry [ $ section ] ) ) { $ this -> registry [ $ section ] = array ( ) ; } $ this -> registry [ $ section ] [ $ var ] = $ val ; } else { $ this -> registry [ $ var ] = $ val ; } return $ this ; }
5307	protected function getPathFromPolygon ( SimpleXMLElement $ polygon ) { $ points = $ this -> getValuesFromList ( $ polygon [ 'points' ] ) ; $ path = 'M' . array_shift ( $ points ) . ' ' . array_shift ( $ points ) ; while ( count ( $ points ) ) { $ path .= 'L' . array_shift ( $ points ) . ' ' . array_shift ( $ points ) ; } return $ path . 'Z' ; }
7500	public function requestJson ( $ method , $ url , $ options = array ( ) ) { $ options [ 'headers' ] [ ] = 'Content-Type: application/json' ; $ options [ 'headers' ] [ ] = 'Content-Length: ' . strlen ( $ options [ 'body' ] ) ; $ this -> request ( $ method , $ url , $ options ) ; }
5976	public function media ( ) { if ( ! $ this -> media instanceof MediaController ) { $ this -> media = new MediaController ( $ this -> getClient ( ) , $ this -> cachePolicy , $ this -> cache ) ; $ this -> media -> setLogger ( $ this -> logger ) ; } return $ this -> media ; }
2514	public function setConsumerId ( $ id ) { $ this -> sessionHandler -> setTransactionFlowLink ( true ) ; $ this -> sessionHandler -> setConsumerId ( $ id ) ; }
6229	public function available ( ) { return $ this -> core -> api ( ) -> response ( $ this -> makeContainer ( $ this -> core -> modules ( ) -> getAllPermissions ( ) ) ) ; }
400	public static function process ( $ markdown , $ flavor = null ) { $ parser = static :: getParser ( $ flavor ) ; return $ parser -> parse ( $ markdown ) ; }
442	public function hasEventHandlers ( $ name ) { $ this -> ensureBehaviors ( ) ; foreach ( $ this -> _eventWildcards as $ wildcard => $ handlers ) { if ( ! empty ( $ handlers ) && StringHelper :: matchWildcard ( $ wildcard , $ name ) ) { return true ; } } return ! empty ( $ this -> _events [ $ name ] ) || Event :: hasHandlers ( $ this , $ name ) ; }
12839	static public function generateFilename ( $ directory , $ extension , $ length = 16 ) { do { $ name = \ Extlib \ Generator :: generate ( $ length ) ; $ filepath = rtrim ( $ directory , DIRECTORY_SEPARATOR ) . DIRECTORY_SEPARATOR . sprintf ( '%s.%s' , $ name , $ extension ) ; } while ( file_exists ( $ filepath ) ) ; return $ name ; }
9971	public function shrinkRangeToFit ( $ range ) { $ maxCol = $ this -> getHighestColumn ( ) ; $ maxRow = $ this -> getHighestRow ( ) ; $ maxCol = Coordinate :: columnIndexFromString ( $ maxCol ) ; $ rangeBlocks = explode ( ' ' , $ range ) ; foreach ( $ rangeBlocks as & $ rangeSet ) { $ rangeBoundaries = Coordinate :: getRangeBoundaries ( $ rangeSet ) ; if ( Coordinate :: columnIndexFromString ( $ rangeBoundaries [ 0 ] [ 0 ] ) > $ maxCol ) { $ rangeBoundaries [ 0 ] [ 0 ] = Coordinate :: stringFromColumnIndex ( $ maxCol ) ; } if ( $ rangeBoundaries [ 0 ] [ 1 ] > $ maxRow ) { $ rangeBoundaries [ 0 ] [ 1 ] = $ maxRow ; } if ( Coordinate :: columnIndexFromString ( $ rangeBoundaries [ 1 ] [ 0 ] ) > $ maxCol ) { $ rangeBoundaries [ 1 ] [ 0 ] = Coordinate :: stringFromColumnIndex ( $ maxCol ) ; } if ( $ rangeBoundaries [ 1 ] [ 1 ] > $ maxRow ) { $ rangeBoundaries [ 1 ] [ 1 ] = $ maxRow ; } $ rangeSet = $ rangeBoundaries [ 0 ] [ 0 ] . $ rangeBoundaries [ 0 ] [ 1 ] . ':' . $ rangeBoundaries [ 1 ] [ 0 ] . $ rangeBoundaries [ 1 ] [ 1 ] ; } unset ( $ rangeSet ) ; $ stRange = implode ( ' ' , $ rangeBlocks ) ; return $ stRange ; }
7106	protected function calculateTotalByState ( PaymentSubjectInterface $ subject , $ state ) { PaymentStates :: isValidState ( $ state , true ) ; $ currency = $ subject -> getCurrency ( ) -> getCode ( ) ; $ total = 0 ; foreach ( $ subject -> getPayments ( ) as $ payment ) { if ( $ payment -> getState ( ) === $ state ) { $ total += $ this -> convertPaymentAmount ( $ payment , $ currency ) ; } } return $ total ; }
12698	static function archiveDir ( $ sourcedir , $ archivefile , $ no_top_dir = false ) { $ archivefile = str_replace ( '\\' , '/' , $ archivefile ) ; $ sourcedir = str_replace ( '\\' , '/' , realpath ( $ sourcedir ) ) ; if ( $ no_top_dir ) { $ srcdir = '.' ; $ workdir = $ sourcedir ; } else { $ srcdir = basename ( $ sourcedir ) ; $ workdir = dirname ( $ sourcedir ) ; } $ archivedir = dirname ( $ archivefile ) ; $ extra = '' ; $ tar = self :: getTool ( 'tar' ) ; if ( substr ( $ archivefile , - 7 ) == '.tar.gz' || substr ( $ archivefile , - 4 ) == '.tgz' ) { $ cmd = "$tar -z -cvf" ; $ extra = "-C " . escapeshellarg ( $ workdir ) ; $ workdir = $ archivedir ; $ archivefile = basename ( $ archivefile ) ; } else if ( substr ( $ archivefile , - 8 ) == '.tar.bz2' ) { $ cmd = "$tar -j -cvf" ; $ extra = "-C " . escapeshellarg ( $ workdir ) ; $ workdir = $ archivedir ; $ archivefile = basename ( $ archivefile ) ; } else if ( substr ( $ archivefile , - 4 ) == '.tar' ) { $ cmd = "$tar -cvf" ; $ extra = "-C " . escapeshellarg ( $ workdir ) ; $ workdir = $ archivedir ; $ archivefile = basename ( $ archivefile ) ; } else if ( substr ( $ archivefile , - 4 ) == '.zip' ) { $ zip = self :: getTool ( 'zip' ) ; $ cmd = "$zip -9 -r" ; } else { throw new pakeException ( "Can not determine archive type from filename: $archivefile" ) ; } pake_sh ( self :: getCdCmd ( $ workdir ) . " && $cmd $archivefile $extra $srcdir" ) ; pake_echo_action ( 'file+' , $ archivefile ) ; }
4827	public static function find ( $ id ) { $ endpoint = self :: $ endpoint . '/' . $ id ; return new self ( GoCardless :: $ client , GoCardless :: $ client -> request ( 'get' , $ endpoint ) ) ; }
3374	protected function getFilename ( $ filename ) { $ callback = $ this -> fileCallback ; if ( null === $ callback || substr ( $ filename , 0 , 1 ) == '/' ) { return $ filename ; } return $ callback ( $ filename ) ; }
11064	public function upperFirst ( ) { $ this -> value = mb_strtoupper ( mb_substr ( $ this -> value , 0 , 1 , 'UTF-8' ) , 'UTF-8' ) . mb_substr ( $ this -> value , 1 , null , 'UTF-8' ) ; return $ this ; }
7563	protected function parse_not ( ) { if ( ( ( $ this -> pos + 1 ) < $ this -> size ) && ( $ this -> doc [ $ this -> pos + 1 ] === '=' ) ) { ++ $ this -> pos ; return ( $ this -> token = self :: TOK_COMPARE_NOT_EQUAL ) ; } else { return ( $ this -> token = self :: TOK_NOT ) ; } }
10320	function getUnsubscribers ( $ fromDate = null , $ toDate = null , $ mailingIds = null , $ contactIds = null , $ contactEmails = null , $ contactExternalIds = null , $ source = null , $ embedFieldBackups = false , $ pageIndex = 1 , $ pageSize = 100 ) { $ params = $ this -> createQueryParameters ( $ pageIndex , $ pageSize , $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , $ mailingIds , $ source , $ embedFieldBackups ) ; return $ this -> get ( 'reports/unsubscriptions' , $ params ) ; }
7661	function SetWordWrap ( ) { if ( $ this -> WordWrap < 1 ) return ; switch ( $ this -> message_type ) { case "alt" : case "alt_attachments" : $ this -> AltBody = $ this -> WrapText ( $ this -> AltBody , $ this -> WordWrap ) ; break ; default : $ this -> Body = $ this -> WrapText ( $ this -> Body , $ this -> WordWrap ) ; break ; } }
8041	public function formatEventsToJson ( array $ calendarEvents ) { $ array = [ ] ; foreach ( $ calendarEvents as $ event ) { $ start = $ this -> carbon -> copy ( ) -> setTimestamp ( strtotime ( $ event -> start ) ) -> toIso8601String ( ) ; $ end = $ this -> carbon -> copy ( ) -> setTimestamp ( strtotime ( $ event -> end ) ) -> toIso8601String ( ) ; $ allDay = $ event -> all_day == 1 ; $ data = [ 'title' => $ event -> title , 'description' => $ event -> description , 'start' => $ start , 'end' => $ end , 'allDay' => $ allDay , 'borderColor' => $ event -> border_color , 'textColor' => $ event -> text_color , 'backgroundColor' => $ event -> background_color , ] ; $ array [ ] = $ data ; if ( $ event -> calendarEventRepeatDates ( ) -> count ( ) > 0 ) { foreach ( $ event -> calendarEventRepeatDates ( ) -> get ( ) as $ repeatDate ) { $ start = $ this -> carbon -> copy ( ) -> setTimestamp ( strtotime ( $ repeatDate -> start ) ) -> toIso8601String ( ) ; $ end = $ this -> carbon -> copy ( ) -> setTimestamp ( strtotime ( $ repeatDate -> end ) ) -> toIso8601String ( ) ; $ data [ 'start' ] = $ start ; $ data [ 'end' ] = $ end ; $ array [ ] = $ data ; } } } return $ array ; }
2575	protected function loadRequestCreatorParams ( $ params ) { if ( isset ( $ params [ 'requestCreatorParams' ] ) ) { if ( $ params [ 'requestCreatorParams' ] instanceof RequestCreatorParams ) { $ this -> requestCreatorParams = $ params [ 'requestCreatorParams' ] ; } elseif ( is_array ( $ params [ 'requestCreatorParams' ] ) ) { $ this -> requestCreatorParams = new RequestCreatorParams ( $ params [ 'requestCreatorParams' ] ) ; } } }
9302	public function setScheduleLifetime ( $ time ) { if ( ! is_numeric ( $ time ) ) { throw new \ InvalidArgumentException ( '`scheduleLifetime` expects integer value!' ) ; } $ this -> options [ 'scheduleLifetime' ] = ( int ) $ time ; return $ this ; }
4338	private function removeHideIfEmptyGroups ( & $ log ) { $ groupStack = array ( ) ; $ groupStackCount = 0 ; $ removed = false ; for ( $ i = 0 , $ count = \ count ( $ log ) ; $ i < $ count ; $ i ++ ) { $ method = $ log [ $ i ] [ 0 ] ; if ( \ in_array ( $ method , array ( 'group' , 'groupCollapsed' ) ) ) { $ entry = $ log [ $ i ] ; $ groupStack [ ] = array ( 'i' => $ i , 'meta' => ! empty ( $ entry [ 2 ] ) ? $ entry [ 2 ] : array ( ) , 'hasEntries' => false , ) ; $ groupStackCount ++ ; } elseif ( $ method == 'groupEnd' ) { $ group = \ end ( $ groupStack ) ; if ( ! $ group [ 'hasEntries' ] && ! empty ( $ group [ 'meta' ] [ 'hideIfEmpty' ] ) ) { unset ( $ log [ $ group [ 'i' ] ] ) ; unset ( $ log [ $ i ] ) ; $ removed = true ; } \ array_pop ( $ groupStack ) ; $ groupStackCount -- ; } elseif ( $ groupStack ) { $ groupStack [ $ groupStackCount - 1 ] [ 'hasEntries' ] = true ; } } if ( $ removed ) { $ log = \ array_values ( $ log ) ; } }
4657	public function run ( Job $ job , $ command ) { if ( is_string ( $ command ) ) { $ command = [ '/bin/bash' , '-c' , $ command ] ; } $ image = $ this -> docker -> getImageManager ( ) -> find ( $ job -> getName ( ) ) ; $ hostConfig = new HostConfig ( ) ; $ config = new ContainerConfig ( ) ; $ config -> setCmd ( $ command ) ; $ config -> setImage ( $ image -> getId ( ) ) ; $ config -> setHostConfig ( $ hostConfig ) ; $ config -> setLabels ( new \ ArrayObject ( [ 'com.jolici.container=true' ] ) ) ; $ config -> setAttachStderr ( true ) ; $ config -> setAttachStdout ( true ) ; $ links = [ ] ; foreach ( $ job -> getServices ( ) as $ service ) { if ( $ service -> getContainer ( ) ) { $ serviceContainer = $ this -> docker -> getContainerManager ( ) -> find ( $ service -> getContainer ( ) ) ; $ links [ ] = sprintf ( '%s:%s' , $ serviceContainer -> getName ( ) , $ service -> getName ( ) ) ; } } $ hostConfig -> setLinks ( $ links ) ; $ containerCreateResult = $ this -> docker -> getContainerManager ( ) -> create ( $ config ) ; $ attachStream = $ this -> docker -> getContainerManager ( ) -> attach ( $ containerCreateResult -> getId ( ) , [ 'stream' => true , 'stdout' => true , 'stderr' => true , ] , ContainerManager :: FETCH_STREAM ) ; $ attachStream -> onStdout ( $ this -> logger -> getRunStdoutCallback ( ) ) ; $ attachStream -> onStderr ( $ this -> logger -> getRunStderrCallback ( ) ) ; $ this -> docker -> getContainerManager ( ) -> start ( $ containerCreateResult -> getId ( ) ) ; $ attachStream -> wait ( ) ; $ containerWait = $ this -> docker -> getContainerManager ( ) -> wait ( $ containerCreateResult -> getId ( ) ) ; return $ containerWait -> getStatusCode ( ) ; }
3042	protected function packTimeLine ( & $ timeLine ) { $ epoch = $ this -> getEpoch ( ) ; $ data = [ self :: STORAGE_KEY_TIMELINE_INDEX => [ ] , self :: STORAGE_KEY_TIMELINE_TAGS => [ ] , self :: STORAGE_KEY_TIMELINE_POINTS => [ ] , self :: STORAGE_KEY_TIMELINE_EPOCH => $ epoch , ] ; $ index = 0 ; foreach ( $ timeLine -> getPoints ( ) as & $ point ) { $ data [ self :: STORAGE_KEY_TIMELINE_POINTS ] [ $ index ] = [ $ point -> getTarget ( ) , $ point -> getType ( ) , round ( $ point -> getTimestamp ( ) - $ epoch , 6 ) ] ; foreach ( $ point -> getTags ( ) as & $ tag ) { $ data [ self :: STORAGE_KEY_TIMELINE_INDEX ] [ $ tag ] [ ] = $ index ; } $ index ++ ; } if ( $ index ) { foreach ( $ data [ self :: STORAGE_KEY_TIMELINE_INDEX ] as $ tag => & $ list ) { if ( count ( $ list ) == $ index ) { unset ( $ data [ self :: STORAGE_KEY_TIMELINE_INDEX ] [ $ tag ] ) ; $ data [ self :: STORAGE_KEY_TIMELINE_TAGS ] [ ] = $ tag ; } } } else { $ data = [ ] ; } return $ data ; }
1813	public function setRteSyntax ( $ varValue , Contao \ DataContainer $ dc ) { switch ( $ dc -> activeRecord -> highlight ) { case 'C' : case 'CSharp' : $ syntax = 'c_cpp' ; break ; case 'CSS' : case 'Diff' : case 'Groovy' : case 'HTML' : case 'Java' : case 'JavaScript' : case 'Perl' : case 'PHP' : case 'PowerShell' : case 'Python' : case 'Ruby' : case 'Scala' : case 'SQL' : case 'Text' : case 'YAML' : $ syntax = strtolower ( $ dc -> activeRecord -> highlight ) ; break ; case 'VB' : $ syntax = 'vbscript' ; break ; case 'XML' : case 'XHTML' : $ syntax = 'xml' ; break ; default : $ syntax = 'text' ; break ; } if ( $ dc -> activeRecord -> type == 'markdown' ) { $ syntax = 'markdown' ; } $ GLOBALS [ 'TL_DCA' ] [ 'tl_content' ] [ 'fields' ] [ 'code' ] [ 'eval' ] [ 'rte' ] = 'ace|' . $ syntax ; return $ varValue ; }
10007	public function getRibbonBinObjects ( $ what = 'all' ) { $ ReturnData = null ; $ what = strtolower ( $ what ) ; switch ( $ what ) { case 'all' : return $ this -> ribbonBinObjects ; break ; case 'names' : case 'data' : if ( is_array ( $ this -> ribbonBinObjects ) && isset ( $ this -> ribbonBinObjects [ $ what ] ) ) { $ ReturnData = $ this -> ribbonBinObjects [ $ what ] ; } break ; case 'types' : if ( is_array ( $ this -> ribbonBinObjects ) && isset ( $ this -> ribbonBinObjects [ 'data' ] ) && is_array ( $ this -> ribbonBinObjects [ 'data' ] ) ) { $ tmpTypes = array_keys ( $ this -> ribbonBinObjects [ 'data' ] ) ; $ ReturnData = array_unique ( array_map ( [ $ this , 'getExtensionOnly' ] , $ tmpTypes ) ) ; } else { $ ReturnData = [ ] ; } break ; } return $ ReturnData ; }
367	public function renderFilters ( ) { if ( $ this -> filterModel !== null ) { $ cells = [ ] ; foreach ( $ this -> columns as $ column ) { $ cells [ ] = $ column -> renderFilterCell ( ) ; } return Html :: tag ( 'tr' , implode ( '' , $ cells ) , $ this -> filterRowOptions ) ; } return '' ; }
9980	private function writeComment ( XMLWriter $ objWriter , $ pCellReference , Comment $ pComment , array $ pAuthors ) { $ objWriter -> startElement ( 'comment' ) ; $ objWriter -> writeAttribute ( 'ref' , $ pCellReference ) ; $ objWriter -> writeAttribute ( 'authorId' , $ pAuthors [ $ pComment -> getAuthor ( ) ] ) ; $ objWriter -> startElement ( 'text' ) ; $ this -> getParentWriter ( ) -> getWriterPart ( 'stringtable' ) -> writeRichText ( $ objWriter , $ pComment -> getText ( ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; }
6118	public function serverCreate ( array $ properties = array ( ) ) { $ this -> serverListReset ( ) ; $ detail = $ this -> execute ( "servercreate" , $ properties ) -> toList ( ) ; $ server = new Server ( $ this , array ( "virtualserver_id" => intval ( $ detail [ "sid" ] ) ) ) ; Signal :: getInstance ( ) -> emit ( "notifyServercreated" , $ this , $ detail [ "sid" ] ) ; Signal :: getInstance ( ) -> emit ( "notifyTokencreated" , $ server , $ detail [ "token" ] ) ; return $ detail ; }
11808	public function paginate ( $ perPage = null , $ columns = array ( '*' ) ) { $ columnsPassed = ( func_num_args ( ) > 1 ) && ( $ columns !== null ) ; $ columns = $ columnsPassed ? $ columns : $ this -> getQueryColumns ( ) ; $ query = $ this -> buildQuery ( $ columns ) ; if ( $ columnsPassed ) { return $ query -> paginate ( $ perPage , $ columns ) ; } return $ query -> paginate ( $ perPage , $ this -> getQueryColumns ( ) ) ; }
11070	public function setBoolean ( string $ key , $ value , bool $ ignoredDefaultValue = null ) { $ this -> set ( $ key , ( bool ) $ value , $ ignoredDefaultValue ) ; return $ this ; }
12033	function addDispatchAsyncMethod ( ) { $ methodGenerator = new MethodGenerator ( 'dispatchAsync' ) ; $ body = 'return $this->api->executeAsync($request, $this, $callable);' ; $ docBlock = $ this -> generateExecuteDocBlock ( 'Dispatch the request for this operation and process the response asynchronously. Allows you to modify the request before it is sent.' ) ; $ requestParameter = new ParameterGenerator ( 'request' , 'Amp\Artax\Request' ) ; $ methodGenerator -> setParameter ( $ requestParameter ) ; $ tag = createParamTag ( $ requestParameter , 'The request to be processed' ) ; $ docBlock -> setTag ( $ tag ) ; $ callableParameter = new ParameterGenerator ( 'callable' , 'callable' ) ; $ methodGenerator -> setParameter ( $ callableParameter ) ; $ callableTag = createParamTag ( $ callableParameter , 'The callable that processes the response' ) ; $ docBlock -> setTag ( $ callableTag ) ; $ methodGenerator -> setDocBlock ( $ docBlock ) ; $ methodGenerator -> setBody ( $ body ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; }
11791	public function setFrom ( $ mail = '' , $ name = null , $ reply = true ) { $ mail = trim ( $ mail ) ; if ( strlen ( $ mail ) && Helper :: isEmail ( $ mail ) ) { $ this -> from = ! empty ( $ name ) ? array ( $ name => $ mail ) : array ( $ mail ) ; $ this -> getMailer ( ) -> setRegistry ( 'Return-Path' , '<' . $ mail . '>' , 'headers' ) ; $ this -> getMailer ( ) -> setRegistry ( 'X-Sender' , $ mail , 'headers' ) ; if ( $ reply ) { $ this -> setReplyTo ( $ mail , $ name ) ; } } return $ this ; }
9652	protected function initFormField ( ) { $ options = $ this -> Options ( ) -> map ( 'EscapedTitle' , 'Title' ) ; return new OptionsetField ( $ this -> Name , $ this -> Title , $ options ) ; }
2813	public function initController ( $ controllerAction = null ) { $ controller = Mage :: getModel ( 'sheep_debug/controller' ) ; $ controller -> init ( $ controllerAction ) ; $ this -> action = $ controller ; }
1532	protected function deserialize ( array $ document , $ record = null ) : ResourceObject { $ data = $ document [ 'data' ] ?? [ ] ; if ( ! is_array ( $ data ) || empty ( $ data ) ) { throw new \ InvalidArgumentException ( 'Expecting a JSON API document with a data member.' ) ; } return ResourceObject :: create ( $ data ) ; }
5819	private function createAlertsForType ( $ type , array $ messages ) { $ alerts = array ( ) ; foreach ( $ messages as $ msg ) { $ alerts [ ] = new Alert ( $ type , $ msg ) ; } return $ alerts ; }
1895	private function addHtaccess ( string $ webDir ) : void { $ htaccess = __DIR__ . '/../Resources/skeleton/web/.htaccess' ; if ( ! file_exists ( $ webDir . '/.htaccess' ) ) { $ this -> fs -> copy ( $ htaccess , $ webDir . '/.htaccess' , true ) ; $ this -> io -> writeln ( 'Added the <comment>web/.htaccess</comment> file.' ) ; return ; } $ existingContent = file_get_contents ( $ webDir . '/.htaccess' ) ; if ( preg_match ( '/^\s*RewriteRule\s/im' , $ existingContent ) ) { return ; } $ this -> fs -> dumpFile ( $ webDir . '/.htaccess' , $ existingContent . "\n\n" . file_get_contents ( $ htaccess ) ) ; $ this -> io -> writeln ( 'Updated the <comment>web/.htaccess</comment> file.' ) ; }
10111	private function writeSheetProtection ( ) { $ record = 0x0867 ; $ options = ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getObjects ( ) | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getScenarios ( ) << 1 | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getFormatCells ( ) << 2 | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getFormatColumns ( ) << 3 | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getFormatRows ( ) << 4 | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getInsertColumns ( ) << 5 | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getInsertRows ( ) << 6 | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getInsertHyperlinks ( ) << 7 | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getDeleteColumns ( ) << 8 | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getDeleteRows ( ) << 9 | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getSelectLockedCells ( ) << 10 | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getSort ( ) << 11 | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getAutoFilter ( ) << 12 | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getPivotTables ( ) << 13 | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getSelectUnlockedCells ( ) << 14 ; $ recordData = pack ( 'vVVCVVvv' , 0x0867 , 0x0000 , 0x0000 , 0x00 , 0x01000200 , 0xFFFFFFFF , $ options , 0x0000 ) ; $ length = strlen ( $ recordData ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ this -> append ( $ header . $ recordData ) ; }
4203	private function addProperties ( Event $ abs ) { if ( $ abs [ 'debugMethod' ] === 'table' && $ abs [ 'traverseValues' ] ) { return ; } $ obj = $ abs -> getSubject ( ) ; $ reflectionObject = $ abs [ 'reflector' ] ; while ( $ reflectionObject ) { $ className = $ reflectionObject -> getName ( ) ; $ properties = $ reflectionObject -> getProperties ( ) ; $ isDebugObj = $ className == __NAMESPACE__ ; while ( $ properties ) { $ reflectionProperty = \ array_shift ( $ properties ) ; $ name = $ reflectionProperty -> getName ( ) ; if ( isset ( $ abs [ 'properties' ] [ $ name ] ) ) { $ abs [ 'properties' ] [ $ name ] [ 'overrides' ] = $ this -> propOverrides ( $ reflectionProperty , $ abs [ 'properties' ] [ $ name ] , $ className ) ; $ abs [ 'properties' ] [ $ name ] [ 'originallyDeclared' ] = $ className ; continue ; } if ( $ isDebugObj && $ name == 'data' ) { $ abs [ 'properties' ] [ 'data' ] = \ array_merge ( self :: $ basePropInfo , array ( 'value' => array ( 'NOT INSPECTED' ) , 'visibility' => 'protected' , ) ) ; continue ; } $ abs [ 'properties' ] [ $ name ] = $ this -> getPropInfo ( $ abs , $ reflectionProperty ) ; } $ reflectionObject = $ reflectionObject -> getParentClass ( ) ; } $ this -> addPropertiesPhpDoc ( $ abs ) ; $ this -> addPropertiesDebug ( $ abs ) ; $ properties = $ abs [ 'properties' ] ; $ abs [ 'hist' ] [ ] = $ obj ; foreach ( $ properties as $ name => $ info ) { if ( $ this -> abstracter -> needsAbstraction ( $ info [ 'value' ] ) ) { $ properties [ $ name ] [ 'value' ] = $ this -> abstracter -> getAbstraction ( $ info [ 'value' ] , $ abs [ 'debugMethod' ] , $ abs [ 'hist' ] ) ; } } $ abs [ 'properties' ] = $ properties ; return ; }
914	public static function calculateBitmask ( array $ options ) { $ bitmask = 0 ; foreach ( $ options as $ optionName ) { if ( \ defined ( $ optionName ) ) { $ bitmask |= \ constant ( $ optionName ) ; } } return $ bitmask ; }
12632	public function query ( $ orderNo , $ type = self :: OUT_TRADE_NO ) { $ params = [ $ type => $ orderNo , ] ; return $ this -> request ( $ this -> wrapApi ( self :: API_QUERY ) , $ params ) ; }
4976	public static function factory ( ContainerInterface $ container ) { $ manager = $ container -> get ( 'ModuleManager' ) ; $ modules = $ manager -> getLoadedModules ( ) ; return new static ( $ modules ) ; }
8911	protected function apply_soft_delete_filter ( ) { if ( $ this -> soft_delete && $ this -> _temporary_with_deleted !== TRUE ) { if ( $ this -> _temporary_only_deleted ) { $ where = "`{$this->deleted_at_key}` <= NOW()" ; } else { $ where = sprintf ( '(%1$s > NOW() OR %1$s IS NULL OR %1$s = \'0000-00-00 00:00:00\')' , $ this -> deleted_at_key ) ; } $ this -> _database -> where ( $ where ) ; } }
12879	public function render ( ) { $ plugins = $ this -> pluginManager -> getBlockPlugins ( ) ; $ toolbar = array ( ) ; $ left [ ] = $ this -> twig -> render ( "RedKiteCms/Resources/views/Editor/Toolbar/_toolbar_left_buttons.html.twig" ) ; $ right [ ] = $ this -> twig -> render ( "RedKiteCms/Resources/views/Editor/Toolbar/_toolbar_right_buttons.html.twig" ) ; foreach ( $ plugins as $ plugin ) { if ( ! $ plugin -> hasToolbar ( ) ) { continue ; } $ left [ ] = $ this -> addButtons ( $ plugin , 'left' ) ; $ right [ ] = $ this -> addButtons ( $ plugin , 'right' ) ; } $ toolbar [ "left" ] = implode ( "\n" , $ left ) ; $ toolbar [ "right" ] = implode ( "\n" , $ right ) ; return $ toolbar ; }
12933	protected function generateContent ( $ type , $ id , $ name , $ language ) { $ content = new Content ( ) ; $ content -> setContentId ( $ id ) ; $ content -> setContentType ( $ type ) ; $ content -> setDeleted ( false ) ; $ content -> setName ( $ name ) ; $ content -> setLanguage ( $ language ) ; $ content -> setStatus ( $ this -> getReference ( 'status-published' ) ) ; $ content -> setVersion ( '1' ) ; $ content -> setSiteId ( '2' ) ; $ date = new \ DateTime ( "now" ) ; $ content -> setVersionName ( $ content -> getName ( ) . '_' . $ date -> format ( "Y-m-d_H:i:s" ) ) ; return $ content ; }
1501	public function matchesTo ( MediaTypeInterface $ mediaType ) : ? Encoding { return collect ( $ this -> stack ) -> first ( function ( Encoding $ encoding ) use ( $ mediaType ) { return $ encoding -> matchesTo ( $ mediaType ) ; } ) ; }
6890	protected function removeAssignment ( StockAssignmentInterface $ assignment ) { $ this -> unitUpdater -> updateSold ( $ assignment -> getStockUnit ( ) , - $ assignment -> getSoldQuantity ( ) , true ) ; $ assignment -> setSaleItem ( null ) -> setStockUnit ( null ) ; $ this -> persistenceHelper -> remove ( $ assignment ) ; }
8670	public static function fromRecursive ( $ collection ) { $ arr = Arr :: from ( $ collection ) ; foreach ( $ arr as $ key => $ value ) { if ( $ value instanceof stdClass || \ is_iterable ( $ value ) ) { $ value = static :: fromRecursive ( $ value ) ; } $ arr [ $ key ] = $ value ; } return new static ( $ arr ) ; }
10883	public function reportException ( \ Exception $ ex ) { $ report = new ErrorStreamReport ( ) ; $ report -> error_group = $ ex -> getMessage ( ) . ':' . $ ex -> getLine ( ) ; $ report -> line_number = $ ex -> getLine ( ) ; $ report -> file_name = $ ex -> getFile ( ) ; $ report -> message = $ ex -> getMessage ( ) ; $ report -> stack_trace = $ ex -> getTraceAsString ( ) ; $ report -> severity = 3 ; return $ this -> report ( $ report ) ; }
7344	protected function preventForbiddenChange ( ShipmentInterface $ shipment ) { if ( $ this -> persistenceHelper -> isChanged ( $ shipment , 'return' ) ) { list ( $ old , $ new ) = $ this -> persistenceHelper -> getChangeSet ( $ shipment , 'return' ) ; if ( $ old != $ new ) { throw new RuntimeException ( "Changing the shipment type is not yet supported." ) ; } } }
2362	public static function findFirstActiveWithJumpToByIds ( $ arrIds ) { @ trigger_error ( 'Using MemberGroupModel::findFirstActiveWithJumpToByIds() has been deprecated and will no longer work in Contao 5.0. Use PageModel::findFirstActiveByMemberGroups() instead.' , E_USER_DEPRECATED ) ; if ( empty ( $ arrIds ) || ! \ is_array ( $ arrIds ) ) { return null ; } $ time = Date :: floorToMinute ( ) ; $ objDatabase = Database :: getInstance ( ) ; $ arrIds = array_map ( '\intval' , $ arrIds ) ; $ objResult = $ objDatabase -> prepare ( "SELECT p.* FROM tl_member_group g LEFT JOIN tl_page p ON g.jumpTo=p.id WHERE g.id IN(" . implode ( ',' , $ arrIds ) . ") AND g.jumpTo>0 AND g.redirect='1' AND g.disable!='1' AND (g.start='' OR g.start<='$time') AND (g.stop='' OR g.stop>'" . ( $ time + 60 ) . "') AND p.published='1' AND (p.start='' OR p.start<='$time') AND (p.stop='' OR p.stop>'" . ( $ time + 60 ) . "') ORDER BY " . $ objDatabase -> findInSet ( 'g.id' , $ arrIds ) ) -> limit ( 1 ) -> execute ( ) ; if ( $ objResult -> numRows < 1 ) { return null ; } return new static ( $ objResult ) ; }
8679	public function sort ( $ order = SORT_ASC , $ flags = SORT_REGULAR , $ preserveKeys = false ) { $ this -> validateSortArgs ( $ order , $ flags ) ; $ items = $ this -> items ; if ( ! $ preserveKeys ) { if ( $ order === SORT_ASC ) { sort ( $ items , $ flags ) ; } elseif ( $ order === SORT_DESC ) { rsort ( $ items , $ flags ) ; } } else { if ( $ order === SORT_ASC ) { asort ( $ items , $ flags ) ; } elseif ( $ order === SORT_DESC ) { arsort ( $ items , $ flags ) ; } } return $ this -> createFrom ( $ items ) ; }
12342	protected function printInfo ( $ msg , bool $ withTime = true , ? string $ fontColor = self :: FONT_COLOR_MAP [ 'lightGreen' ] , ? string $ bgColor = null ) : void { $ this -> print ( $ this -> getColoredMsg ( $ msg , $ fontColor , $ bgColor ) , $ withTime ) ; }
1951	public function resendButton ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { return ( ! $ row [ 'confirmedOn' ] && ! $ row [ 'invalidatedThrough' ] && $ row [ 'emailSubject' ] && $ row [ 'emailText' ] && $ row [ 'createdOn' ] > strtotime ( '-24 hours' ) ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : '' ; }
11138	protected function calculateCREATE ( ) { $ this -> query .= 'CREATE TABLE IF NOT EXISTS ' ; $ this -> query .= $ this -> create . ' (' ; $ this -> queryStringFromArray ( 'fields' , '' , ', ' , false , true ) ; $ this -> primaryKeyStringFromArray ( 'primaryKeys' , ', CONSTRAINT ' ) ; $ this -> foreignKeyStringFromArray ( 'foreignKeys' , ', CONSTRAINT ' ) ; $ this -> indexStringFromArray ( 'indexes' , ', INDEX ' ) ; $ this -> query .= ')' ; }
11664	public function isValid ( array $ values ) { $ this -> errorMessages = [ ] ; foreach ( $ this -> elements -> getElements ( ) as $ element ) { $ elementId = $ element -> getID ( ) ; if ( empty ( $ elementId ) ) { continue ; } $ value = null ; if ( array_key_exists ( $ elementId , $ values ) ) { $ value = $ values [ $ elementId ] ; } $ element -> setValue ( $ value ) ; $ this -> filterElement ( $ element ) ; $ this -> validateElement ( $ element ) ; } return count ( $ this -> errorMessages ) === 0 ; }
462	public function buildCondition ( $ condition , & $ params ) { if ( is_array ( $ condition ) ) { if ( empty ( $ condition ) ) { return '' ; } $ condition = $ this -> createConditionFromArray ( $ condition ) ; } if ( $ condition instanceof ExpressionInterface ) { return $ this -> buildExpression ( $ condition , $ params ) ; } return ( string ) $ condition ; }
11309	protected function populateStub ( string $ stub , ? string $ class = null ) : string { return str_replace ( '{class}' , $ this -> getName ( $ class ) , $ stub ) ; }
3068	protected function initServiceContext ( ) { $ serviceContext = $ this -> getServiceContext ( ) ; $ this -> getRunnerService ( ) -> check ( $ serviceContext ) ; return $ serviceContext -> init ( ) ; }
7483	public function startsWith ( $ string ) { $ string = static :: convertString ( $ string , $ this -> encoding ) ; return $ string === $ this -> substring ( 0 , ( mb_strlen ( $ string , $ this -> encoding ) - 1 ) ) -> __toString ( ) ; }
8771	public function registerConfiguredProviders ( ) { $ providers = Collection :: make ( $ this -> config [ 'app.providers' ] ) -> partition ( function ( $ provider ) { return Str :: startsWith ( $ provider , 'Nur\\' ) ; } ) ; $ providers -> splice ( 1 , 0 , [ $ this -> make ( PackageManifest :: class ) -> providers ( ) ] ) ; ( new ProviderRepository ( $ this , new Filesystem , $ this -> getCachedServicesPath ( ) ) ) -> load ( $ providers -> collapse ( ) -> toArray ( ) ) ; }
8913	protected function _set_where ( $ params ) { if ( count ( $ params ) == 1 ) { $ this -> _database -> where ( $ params [ 0 ] ) ; } else if ( count ( $ params ) == 2 ) { $ this -> _database -> where ( $ params [ 0 ] , $ params [ 1 ] ) ; } else if ( count ( $ params ) == 3 ) { $ this -> _database -> where ( $ params [ 0 ] , $ params [ 1 ] , $ params [ 2 ] ) ; } else { $ this -> _database -> where ( $ params ) ; } }
8388	public function addInnerJoin ( $ table , $ on ) { $ this -> innerJoins [ ] = array ( 'table' => $ table , 'on' => ( $ on instanceof Condition ? $ on : new Condition ( $ on ) ) ) ; return $ this ; }
4847	public static function unregister ( ) { if ( isset ( self :: $ autoloadFn ) ) { spl_autoload_unregister ( self :: $ autoloadFn ) ; self :: $ autoloadFn = null ; } self :: $ aliases = [ ] ; }
7839	public function info ( int $ id ) : ? array { $ response = Request :: get ( $ this -> baseUrl . 'contact/' . $ id ) ; if ( $ response -> code != 200 ) { if ( ! empty ( $ response -> body -> message ) ) { Log :: error ( $ response -> body -> message ) ; } } return [ 'code' => $ response -> code , 'message' => ( $ response -> code == 200 ) ? 'OK' : $ response -> body -> message ?? '' , 'data' => $ response -> body , ] ; }
7515	function next_pos ( $ needle , $ callback = true ) { $ this -> token_start = $ this -> pos ; if ( ( $ this -> pos < $ this -> size ) && ( ( $ p = stripos ( $ this -> doc , $ needle , $ this -> pos + 1 ) ) !== false ) ) { $ len = $ p - $ this -> pos - 1 ; if ( $ len > 0 ) { $ str = substr ( $ this -> doc , $ this -> pos + 1 , $ len ) ; if ( ( $ l = strrpos ( $ str , "\n" ) ) !== false ) { ++ $ this -> line_pos [ 0 ] ; $ this -> line_pos [ 1 ] = $ l + $ this -> pos + 1 ; $ len -= $ l ; if ( $ len > 0 ) { $ str = substr ( $ str , 0 , - $ len ) ; $ this -> line_pos [ 0 ] += substr_count ( $ str , "\n" ) ; } } } $ this -> pos = $ p ; if ( $ callback && isset ( $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ) { if ( is_string ( $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ) { return ( $ this -> token = $ this -> { $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] } ( ) ) ; } else { return ( $ this -> token = $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ; } } else { return ( $ this -> token = self :: TOK_UNKNOWN ) ; } } else { $ this -> pos = $ this -> size ; return ( $ this -> token = self :: TOK_NULL ) ; } }
8213	protected function renderJob ( $ job ) { $ stats = $ this -> getJobStats ( $ job ) ; $ format = '<info>id</info>: %u, <info>length</info>: %u, <info>priority</info>: %u, <info>delay</info>: %u, <info>age</info>: %u, <info>ttr</info>: %u' ; $ line = sprintf ( $ format , $ job -> getId ( ) , strlen ( $ job -> getData ( ) ) , $ stats [ 'pri' ] , $ stats [ 'delay' ] , $ stats [ 'age' ] , $ stats [ 'ttr' ] ) ; $ this -> output -> writeln ( $ line ) ; $ format = '<comment>reserves</comment>: %u, <comment>releases</comment>: %u, <comment>buries</comment>: %u, <comment>kicks</comment>: %u, <comment>timeouts</comment>: %u' ; $ line = sprintf ( $ format , $ stats [ 'reserves' ] , $ stats [ 'releases' ] , $ stats [ 'buries' ] , $ stats [ 'kicks' ] , $ stats [ 'timeouts' ] ) ; $ this -> output -> writeln ( $ line ) ; $ this -> output -> writeln ( '<comment>body:</comment>' ) ; $ data = $ job -> getData ( ) ; $ this -> output -> writeln ( "\"$data\"" ) ; }
12329	public function enqueue_style ( WP_Enqueue_Options $ options ) { if ( ! $ options -> have_required_properties ( ) ) { trigger_error ( 'Trying to enqueue style, but required properties are missing.' ) ; return ; } $ handle = $ options -> get_handle ( ) ; $ relative_path = $ options -> get_relative_path ( ) ; $ filename = $ options -> get_filename ( ) ; $ filename_debug = $ options -> get_filename_debug ( ) ; $ dependencies = $ options -> get_dependencies ( ) ; $ version = $ options -> get_version ( ) ; $ media = $ options -> get_media ( ) ; $ source = $ this -> get_source_to_enqueue ( $ relative_path , $ filename , $ filename_debug ) ; wp_enqueue_style ( $ handle , $ source , $ dependencies , $ version , $ media ) ; }
11975	private function secondParamValidation ( Event $ event ) { $ params = $ event -> getCustomParams ( ) ; return ( ! isset ( $ params [ 1 ] ) || ( is_numeric ( $ params [ 1 ] ) && $ params [ 1 ] >= 1 && $ params [ 1 ] <= $ this -> maxDieSides ) ) ; }
753	public function init ( ) { $ this -> fontFile = Yii :: getAlias ( $ this -> fontFile ) ; if ( ! is_file ( $ this -> fontFile ) ) { throw new InvalidConfigException ( "The font file does not exist: {$this->fontFile}" ) ; } }
7222	protected function clearShipment ( Shipment \ ShipmentInterface $ shipment ) { if ( empty ( $ shipment -> getTrackingNumber ( ) ) && ! $ shipment -> hasLabels ( ) ) { return false ; } $ shipment -> setTrackingNumber ( null ) ; foreach ( $ shipment -> getLabels ( ) as $ label ) { $ shipment -> removeLabel ( $ label ) ; } return true ; }
3854	public function setMetaModel ( $ intMetaModel , $ intView ) { $ this -> intMetaModel = $ intMetaModel ; $ this -> intView = $ intView ; $ this -> prepareMetaModel ( ) ; $ this -> prepareView ( ) ; return $ this ; }
12706	public static function getAllCommands ( ) : array { $ commands = [ ] ; foreach ( get_declared_classes ( ) as $ class ) { if ( is_subclass_of ( $ class , 'Senhung\CLI\Command' ) ) { $ commandObject = new $ class ; $ command = $ commandObject -> getCommand ( ) ; $ commands [ $ command ] = $ class ; } } return $ commands ; }
9745	public function setCity ( $ city ) { if ( ! ( $ city instanceof City ) ) { $ city = new City ( $ city ) ; } if ( $ city -> isEmpty ( ) ) { $ this -> invalidArguments ( '10003' ) ; } return $ this -> setParameter ( 'city' , $ city ) ; }
11601	private static function getBaseUrl ( ) : ? string { $ serverName = filter_input ( \ INPUT_SERVER , 'SERVER_NAME' , \ FILTER_SANITIZE_STRING ) ; if ( ! empty ( $ serverName ) ) { $ https = filter_input ( \ INPUT_SERVER , 'HTTPS' , \ FILTER_SANITIZE_STRING ) ; $ protocol = ! empty ( $ https ) && strtolower ( $ https ) === 'on' ? 'https' : 'http' ; return $ protocol . '://' . $ serverName ; } return null ; }
11727	public function setTaxonomy_id ( $ value ) { if ( ! is_array ( $ value ) ) { $ value = [ $ value ] ; } foreach ( $ value as $ k => $ v ) { if ( is_object ( $ v ) ) { $ value [ $ k ] = $ v -> primaryKey ; } elseif ( is_array ( $ v ) ) { unset ( $ value [ $ k ] ) ; if ( isset ( $ v [ 'systemId' ] ) && isset ( $ v [ 'taxonomyType' ] ) ) { $ taxonomyType = Yii :: $ app -> collectors [ 'taxonomies' ] -> getOne ( $ v [ 'taxonomyType' ] ) ; if ( isset ( $ taxonomyType ) && ( $ taxonomy = $ taxonomyType -> getTaxonomy ( $ v [ 'systemId' ] ) ) ) { $ value [ $ k ] = $ taxonomy -> primaryKey ; } } } } $ this -> _taxonomy_id = $ value ; }
10546	public function setRequest ( Request $ request ) { $ this -> request = $ request ; $ this -> app = null ; $ this -> vhost = null ; $ this -> route = null ; $ this -> setVariable ( 'request' , $ request ) ; return $ this ; }
12848	private function _getPage403 ( ) { var_dump ( debug_backtrace ( ) ) ; header ( "HTTP/1.0 403 Forbidden" ) ; if ( isset ( $ this -> _oRoutes -> e403 ) ) { $ this -> _oRoutes -> e403 -> route = '/' ; $ _SERVER [ 'REQUEST_URI' ] = '/' ; $ this -> _route ( $ this -> _oRoutes -> e403 , $ _SERVER [ 'REQUEST_URI' ] ) ; } exit ; }
10197	public function writeStringTable ( array $ pStringTable ) { $ objWriter = null ; if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' , 'yes' ) ; $ objWriter -> startElement ( 'sst' ) ; $ objWriter -> writeAttribute ( 'xmlns' , 'http://schemas.openxmlformats.org/spreadsheetml/2006/main' ) ; $ objWriter -> writeAttribute ( 'uniqueCount' , count ( $ pStringTable ) ) ; foreach ( $ pStringTable as $ textElement ) { $ objWriter -> startElement ( 'si' ) ; if ( ! $ textElement instanceof RichText ) { $ textToWrite = StringHelper :: controlCharacterPHP2OOXML ( $ textElement ) ; $ objWriter -> startElement ( 't' ) ; if ( $ textToWrite !== trim ( $ textToWrite ) ) { $ objWriter -> writeAttribute ( 'xml:space' , 'preserve' ) ; } $ objWriter -> writeRawData ( $ textToWrite ) ; $ objWriter -> endElement ( ) ; } elseif ( $ textElement instanceof RichText ) { $ this -> writeRichText ( $ objWriter , $ textElement ) ; } $ objWriter -> endElement ( ) ; } $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
2880	public function disableTranslateAction ( ) { try { $ this -> getService ( ) -> setTranslateInline ( 0 ) ; $ this -> getService ( ) -> flushCache ( ) ; } catch ( Exception $ e ) { $ message = $ this -> __ ( 'Translate inline cannot be disabled: %s' , $ e -> getMessage ( ) ) ; $ this -> getSession ( ) -> addError ( $ message ) ; } $ this -> _redirectReferer ( ) ; }
7218	public function create ( $ argv ) { $ custom_name = false ; if ( $ argv && count ( $ argv ) ) { $ custom_name = mb_strtolower ( $ argv [ 0 ] , 'utf-8' ) ; } DB :: begin ( ) ; try { $ name = 'm' . gmdate ( 'ymd_His' ) ; if ( $ custom_name ) $ name = $ name . '_' . $ custom_name ; $ file = '<?php// ' . strftime ( '%F %T' ) . 'use mii\db\Migration;use mii\db\DB;class ' . $ name . ' extends Migration { public function up() { } public function down() { return false; } public function safe_up() { } public function safe_down() { return false; }}' ; reset ( $ this -> migrations_paths ) ; file_put_contents ( current ( $ this -> migrations_paths ) . '/' . $ name . '.php' , $ file ) ; DB :: commit ( ) ; $ this -> info ( 'migration :name created' , [ ':name' => $ name ] ) ; } catch ( \ Exception $ e ) { DB :: rollback ( ) ; throw $ e ; } }
1080	public static function parse ( $ source , array $ options = [ ] ) { $ sourceObj = $ source instanceof Source ? $ source : new Source ( $ source ) ; $ parser = new self ( $ sourceObj , $ options ) ; return $ parser -> parseDocument ( ) ; }
871	public static function getDisplayableAllowedValues ( FixerOptionInterface $ option ) { $ allowed = $ option -> getAllowedValues ( ) ; if ( null !== $ allowed ) { $ allowed = array_filter ( $ allowed , static function ( $ value ) { return ! ( $ value instanceof \ Closure ) ; } ) ; usort ( $ allowed , static function ( $ valueA , $ valueB ) { if ( $ valueA instanceof AllowedValueSubset ) { return - 1 ; } if ( $ valueB instanceof AllowedValueSubset ) { return 1 ; } return strcasecmp ( self :: toString ( $ valueA ) , self :: toString ( $ valueB ) ) ; } ) ; if ( 0 === \ count ( $ allowed ) ) { $ allowed = null ; } } return $ allowed ; }
9184	protected function getRememberKey ( ) { $ backtrace = debug_backtrace ( 4 ) [ 2 ] ; $ args = implode ( '_' , $ backtrace [ 'args' ] ) ; $ key = str_replace ( '\\' , '_' , get_class ( $ this ) . '_' . $ backtrace [ 'function' ] . '_' . $ args ) ; return $ key ; }
12651	private function writeTextsToFile ( $ language ) { $ textInfo = array ( ) ; $ outdateInfo = array ( ) ; foreach ( $ this -> contents [ $ language ] as $ id => $ info ) { $ textInfo [ $ id ] = $ info [ 'content' ] ; $ outdateInfo [ $ id ] = $ info [ 'outdated' ] ; } if ( $ language === $ this -> baseLang ) { $ content = array ( 'root' => $ textInfo ) + array_fill_keys ( $ this -> extraLangs , true ) ; } else { $ content = $ textInfo ; } $ encodeFlags = JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES ; $ content = "'use strict';\n/*global define*/\ndefine(" . json_encode ( $ content , $ encodeFlags ) . ");\n" ; $ fs = $ this -> env -> getFileSystem ( ) ; $ fs -> putFile ( $ this -> getFileName ( $ language ) , $ content ) ; $ fs -> putFile ( $ this -> getOutdateInfoFileName ( $ language ) , json_encode ( $ outdateInfo , $ encodeFlags ) ) ; }
7082	public function uri ( $ uri = NULL ) : string { if ( $ uri === NULL ) { return empty ( $ this -> _uri ) ? '/' : $ this -> _uri ; } return $ this -> _uri = $ uri ; }
169	public static function unlink ( $ path ) { $ isWindows = DIRECTORY_SEPARATOR === '\\' ; if ( ! $ isWindows ) { return unlink ( $ path ) ; } if ( is_link ( $ path ) && is_dir ( $ path ) ) { return rmdir ( $ path ) ; } try { return unlink ( $ path ) ; } catch ( ErrorException $ e ) { if ( function_exists ( 'exec' ) && file_exists ( $ path ) ) { exec ( 'DEL /F/Q ' . escapeshellarg ( $ path ) ) ; return ! file_exists ( $ path ) ; } return false ; } }
8087	public function getConnection ( ) { if ( ! ( $ this -> log instanceof Log ) ) { $ this -> log = new Log ( 'DB' ) ; } if ( $ this -> connection instanceof \ PDO ) { return $ this -> connection ; } $ this -> log -> report ( 'Connecting to database...' ) ; try { $ this -> connection = new \ PDO ( $ this -> generateDSN ( ) , $ this -> user , $ this -> password ) ; $ this -> log -> report ( 'Connected to database.' ) ; } catch ( \ PDOException $ e ) { $ this -> log -> error ( 'Failed to connect to database, [SQLSTATE] ' . $ e -> getCode ( ) ) ; } if ( $ this -> connection instanceof \ PDO ) { return $ this -> connection ; } else { return false ; } }
5874	public static function isAnimatedGif ( $ fileName ) { if ( ( $ fh = fopen ( $ fileName , 'rb' ) ) === false ) { throw new \ RuntimeException ( 'Can\'t open ' . $ fileName , 1454678600 ) ; } $ count = 0 ; while ( ! feof ( $ fh ) && $ count < 2 ) { $ chunk = fread ( $ fh , 1024 * 100 ) ; $ count += preg_match_all ( '#\x00\x21\xF9\x04.{4}\x00[\x2C\x21]#s' , $ chunk , $ matches ) ; } fclose ( $ fh ) ; return $ count > 1 ; }
2983	protected function makePathRelative ( $ absolutePath ) { $ projectRootDir = dirname ( $ this -> getContainer ( ) -> getParameter ( 'kernel.root_dir' ) ) ; return str_replace ( $ projectRootDir . '/' , '' , realpath ( $ absolutePath ) ? : $ absolutePath ) ; }
11398	public function remove ( $ sourceDir , array $ options , $ username ) { $ dir = $ this -> init ( $ sourceDir , $ options , $ username ) -> getDirInUse ( ) ; $ blockName = $ options [ "blockname" ] ; $ blocksDir = $ dir . '/blocks' ; $ filename = sprintf ( '%s/%s.json' , $ blocksDir , $ blockName ) ; $ options [ "block" ] = JsonTools :: jsonDecode ( FilesystemTools :: readFile ( $ filename ) ) ; Dispatcher :: dispatch ( BlockEvents :: BLOCK_REMOVING , new BlockRemovingEvent ( $ this -> serializer , $ filename ) ) ; $ this -> filesystem -> remove ( $ filename ) ; $ this -> removeBlockFromSlotFile ( $ options , $ dir ) ; Dispatcher :: dispatch ( BlockEvents :: BLOCK_REMOVED , new BlockRemovedEvent ( $ this -> serializer , $ filename ) ) ; DataLogger :: log ( sprintf ( 'Block "%s" has been removed from the "%s" slot on page "%s" for the "%s_%s" language' , $ options [ "blockname" ] , $ options [ "slot" ] , $ options [ "page" ] , $ options [ "language" ] , $ options [ "country" ] ) ) ; }
9933	public function setRuleType ( $ pRuleType ) { if ( ! in_array ( $ pRuleType , self :: $ ruleTypes ) ) { throw new PhpSpreadsheetException ( 'Invalid rule type for column AutoFilter Rule.' ) ; } $ this -> ruleType = $ pRuleType ; return $ this ; }
10643	public function getParent ( ) { if ( $ this -> path === "/" || ( $ path = dirname ( $ this -> path ) ) === "." ) { return null ; } return new DirEntity ( $ path ) ; }
4818	public function addField ( $ name , $ value ) { if ( $ this -> currentRow < 0 ) { $ this -> appendRow ( ) ; } $ this -> collection [ $ this -> currentRow ] -> addField ( $ name , $ value ) ; }
3404	public function lock ( Output $ output ) { if ( ! $ this -> lock ) { return ; } $ this -> lock = $ this -> getApplication ( ) -> getLockFactory ( ) -> createLock ( $ this -> getName ( ) ) ; if ( ! $ this -> lock -> acquire ( ) ) { $ output -> error ( "Another instance of this command (" . $ this -> getName ( ) . ") is currently running" ) ; exit ( Application :: STATUS_LOCKED ) ; } }
585	protected function loadBundles ( $ bundles ) { $ this -> stdout ( "Collecting source bundles information...\n" ) ; $ am = $ this -> getAssetManager ( ) ; $ result = [ ] ; foreach ( $ bundles as $ name ) { $ result [ $ name ] = $ am -> getBundle ( $ name ) ; } foreach ( $ result as $ bundle ) { $ this -> loadDependency ( $ bundle , $ result ) ; } return $ result ; }
8929	public function stack ( $ icons ) { if ( count ( $ icons ) !== 2 ) { throw new \ InvalidArgumentException ( 'Expecting exactly 2 icons in the stack' ) ; } $ contents = [ ] ; $ index = 2 ; foreach ( $ icons as $ key => $ value ) { $ contents [ ] = $ this -> getStackIconElement ( $ key , $ value , $ index ) ; -- $ index ; } return $ this -> html -> span ( $ contents ) -> addClass ( 'fa-stack' ) ; }
12099	public function priceNetto ( $ brutto , $ tax ) { $ tax = round ( ( double ) $ tax / 100.0 , 2 ) ; if ( $ tax < 0.00 ) { throw new Exception ( sprintf ( 'Tax must be greater than or equal to 0, given %s.' , $ tax ) ) ; } if ( $ tax === 0.00 ) { return $ brutto ; } $ result = $ brutto / ( $ tax + 1 ) ; return round ( $ result , 2 , PHP_ROUND_HALF_UP ) ; }
3898	public function handleMetaChange ( $ strMetaName , $ varNewValue ) { if ( $ strMetaName == 'colname' ) { if ( $ this -> get ( $ strMetaName ) != $ varNewValue ) { $ this -> renameColumn ( $ varNewValue ) ; } return $ this ; } return parent :: handleMetaChange ( $ strMetaName , $ varNewValue ) ; }
4478	public function getInstance ( ) { if ( $ this -> instance === null ) { $ this -> instance = $ this -> jobFactory -> create ( $ this -> klass , $ this -> getPerformMethod ( ) ) ; } return $ this -> instance ; }
8049	public function createCalendarEvent ( array $ data ) { $ eventData = $ this -> calendarEventsEngine -> buildEventData ( $ data ) ; $ eventDates = $ this -> calendarEventsEngine -> buildEventDates ( $ data ) ; $ cache = $ this -> cache ; $ calendarEvent = $ this -> calendarEvent -> create ( $ eventData ) ; $ this -> handleEventLocation ( $ data , $ calendarEvent ) ; foreach ( $ eventDates as $ date ) { $ calendarEventRepeatDate = clone $ this -> calendarEventRepeatDate ; $ calendarEventRepeatDate -> start = $ date [ 'start' ] ; $ calendarEventRepeatDate -> end = $ date [ 'end' ] ; $ calendarEventRepeatDate -> calendarEvent ( ) -> associate ( $ calendarEvent ) ; $ calendarEventRepeatDate -> save ( ) ; unset ( $ calendarEventRepeatDate ) ; } $ cache :: put ( self :: CACHE_KEY . $ calendarEvent -> id , $ calendarEvent , $ this -> cacheTimeToLive ) ; $ allEvents = $ this -> getAllEvents ( ) ; $ allEvents [ $ calendarEvent -> id ] = $ calendarEvent ; $ cache :: put ( self :: ALL_EVENTS_KEY , $ allEvents , $ this -> cacheTimeToLive ) ; return true ; }
6047	public function listObjectTypes ( CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/objecttypes' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new ObjectType ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
1946	public function getCustomSections ( $ strKey = null ) { @ trigger_error ( 'Using FrontendTemplate::getCustomSections() has been deprecated and will no longer work in Contao 5.0. Use FrontendTemplate::sections() instead.' , E_USER_DEPRECATED ) ; if ( $ strKey != '' && ! isset ( $ this -> positions [ $ strKey ] ) ) { return '' ; } $ tag = 'div' ; if ( $ strKey == 'main' ) { $ tag = 'section' ; } $ sections = '' ; foreach ( $ this -> positions [ $ strKey ] as $ sect ) { if ( isset ( $ this -> sections [ $ sect [ 'id' ] ] ) ) { $ sections .= "\n" . '<' . $ tag . ' id="' . StringUtil :: standardize ( $ sect [ 'id' ] , true ) . '">' . "\n" . '<div class="inside">' . "\n" . $ this -> sections [ $ sect [ 'id' ] ] . "\n" . '</div>' . "\n" . '</' . $ tag . '>' . "\n" ; } } if ( $ sections == '' ) { return '' ; } return '<div class="custom">' . "\n" . $ sections . "\n" . '</div>' . "\n" ; }
9924	public function filter ( Parameters $ params , array $ permitted = array ( ) ) { $ this -> cleanUnwanted ( $ params , $ permitted ) ; $ this -> handleArrays ( $ params , $ permitted ) ; $ this -> handleCollections ( $ params , $ permitted ) ; }
3403	protected function loadFromYml ( $ file ) { $ this -> parser = new Parser ( $ file ) ; $ this -> parser -> load ( $ this ) ; }
3707	protected function renderWidget ( $ widget , $ filterOptions ) { $ filter = $ widget ; $ templateName = $ filter [ 'raw' ] [ 'eval' ] [ 'template' ] ; $ template = new \ FrontendTemplate ( $ templateName ? $ templateName : 'mm_filteritem_default' ) ; $ template -> setData ( $ filter ) ; $ template -> submit = $ filterOptions -> isAutoSubmit ( ) ; $ filter [ 'value' ] = $ template -> parse ( ) ; return $ filter ; }
2003	public static function getNormalizedVersion ( string $ packageName ) : string { $ chunks = explode ( '.' , static :: getVersion ( $ packageName ) ) ; $ chunks += [ 0 , 0 , 0 ] ; if ( \ count ( $ chunks ) > 3 ) { $ chunks = \ array_slice ( $ chunks , 0 , 3 ) ; } return implode ( '.' , $ chunks ) ; }
1918	public static function findByIds ( $ arrIds , array $ arrOptions = array ( ) ) { if ( empty ( $ arrIds ) || ! \ is_array ( $ arrIds ) ) { return null ; } $ t = static :: $ strTable ; return static :: findBy ( array ( "$t.id IN(" . implode ( ',' , array_map ( '\intval' , $ arrIds ) ) . ")" ) , null , $ arrOptions ) ; }
4600	public function postLoad ( LifecycleEventArgs $ args ) { $ entity = $ args -> getEntity ( ) ; if ( ! $ entity instanceof Translatable ) { return ; } $ this -> translationService -> translate ( $ entity ) ; }
6273	public static function haveExtension ( ) { if ( ! function_exists ( 'dba_handlers' ) ) { return false ; } $ handlers = dba_handlers ( ) ; if ( ! in_array ( 'cdb' , $ handlers ) || ! in_array ( 'cdb_make' , $ handlers ) ) { return false ; } return true ; }
2054	protected function getConfigurationItem ( $ imageSize ) { $ configItem = new PictureConfigurationItem ( ) ; $ resizeConfig = new ResizeConfiguration ( ) ; $ mode = $ imageSize -> resizeMode ; if ( substr_count ( $ mode , '_' ) === 1 ) { $ importantPart = $ this -> image -> setImportantPart ( null ) -> getImportantPart ( ) ; $ mode = explode ( '_' , $ mode ) ; if ( $ mode [ 0 ] === 'left' ) { $ importantPart [ 'width' ] = 1 ; } elseif ( $ mode [ 0 ] === 'right' ) { $ importantPart [ 'x' ] = $ importantPart [ 'width' ] - 1 ; $ importantPart [ 'width' ] = 1 ; } if ( $ mode [ 1 ] === 'top' ) { $ importantPart [ 'height' ] = 1 ; } elseif ( $ mode [ 1 ] === 'bottom' ) { $ importantPart [ 'y' ] = $ importantPart [ 'height' ] - 1 ; $ importantPart [ 'height' ] = 1 ; } $ this -> image -> setImportantPart ( $ importantPart ) ; $ mode = ResizeConfiguration :: MODE_CROP ; } $ resizeConfig -> setWidth ( $ imageSize -> width ) -> setHeight ( $ imageSize -> height ) -> setZoomLevel ( $ imageSize -> zoom ) ; if ( $ mode ) { $ resizeConfig -> setMode ( $ mode ) ; } $ configItem -> setResizeConfig ( $ resizeConfig ) ; if ( isset ( $ imageSize -> sizes ) ) { $ configItem -> setSizes ( $ imageSize -> sizes ) ; } if ( isset ( $ imageSize -> densities ) ) { $ configItem -> setDensities ( $ imageSize -> densities ) ; } if ( isset ( $ imageSize -> media ) ) { $ configItem -> setMedia ( $ imageSize -> media ) ; } return $ configItem ; }
6437	public function getLoginStartUrl ( $ redirecturl ) { $ connection = new TwitterOAuth ( $ this -> options [ 'consumer_key' ] , $ this -> options [ 'consumer_secret' ] ) ; $ connection -> setTimeouts ( 10 , 15 ) ; $ request_token = $ connection -> oauth ( 'oauth/request_token' , array ( 'oauth_callback' => $ redirecturl ) ) ; $ this -> request_token = array ( ) ; $ this -> request_token [ 'oauth_token' ] = $ request_token [ 'oauth_token' ] ; $ this -> request_token [ 'oauth_token_secret' ] = $ request_token [ 'oauth_token_secret' ] ; return $ connection -> url ( 'oauth/authorize' , array ( 'oauth_token' => $ request_token [ 'oauth_token' ] ) ) ; }
12013	protected function instantiateCompiler ( string & $ className , & $ description ) : CompilerInterface { if ( is_array ( $ description ) ) { $ class = $ description [ self :: COMPILER_CLASS_KEY ] ?? $ className ; if ( ! isset ( $ description [ self :: COMPILER_ID_KEY ] ) ) $ description [ self :: COMPILER_ID_KEY ] = $ className ; $ id = $ description [ self :: COMPILER_ID_KEY ] ; if ( $ args = $ description [ self :: COMPILER_ARGUMENTS_KEY ] ?? NULL ) { return new $ class ( $ id , ... array_values ( $ args ) ) ; } else { return new $ class ( $ id , $ description ) ; } } else { $ instance = new $ description ( $ className ) ; $ description = [ self :: COMPILER_ID_KEY => $ className ] ; return $ instance ; } }
8111	protected function queueNextRun ( ) { $ nextRun = new ContentReviewNotificationJob ( ) ; $ nextRunTime = mktime ( Config :: inst ( ) -> get ( __CLASS__ , 'next_run_hour' ) , Config :: inst ( ) -> get ( __CLASS__ , 'next_run_minute' ) , 0 , date ( "m" ) , date ( "d" ) + Config :: inst ( ) -> get ( __CLASS__ , 'next_run_in_days' ) , date ( "Y" ) ) ; singleton ( QueuedJobService :: class ) -> queueJob ( $ nextRun , date ( "Y-m-d H:i:s" , $ nextRunTime ) ) ; }
3509	private static function renderToTextFromOpcode ( $ opcode , $ from , $ from_offset , $ from_len ) { if ( $ opcode === 'c' || $ opcode === 'i' ) { echo substr ( $ from , $ from_offset , $ from_len ) ; } }
6294	private function findPath ( $ directory ) { $ path = [ ] ; $ path [ ] = $ this -> basePath ; $ path [ ] = $ directory ; $ path [ ] = 'views' ; return implode ( DIRECTORY_SEPARATOR , $ path ) ; }
4483	public function requeue ( string $ queue ) : void { if ( $ this -> client -> call ( 'recur.update' , $ this -> jid , 'queue' , $ queue ) ) { $ this -> setQueue ( $ queue ) ; } }
5670	protected function describeGenericDifference ( $ first , $ second ) { return sprintf ( 'as [%s] does not match [%s]' , $ this -> describeValue ( $ first ) , $ this -> describeValue ( $ second ) ) ; }
1663	public function image ( $ imageUrl , $ accessibilityText = null ) { $ this -> imageUrl = $ imageUrl ; $ this -> accessibilityText = $ accessibilityText ; return $ this ; }
7278	public function input ( $ name = null , $ default = null ) { return ! $ name ? $ this -> inputs : ( $ this -> inputs [ $ name ] ?? $ default ) ; }
10964	public static function getHost ( ) { $ host = null ; if ( isset ( $ _SERVER [ 'HTTP_X_FORWARDED_HOST' ] ) ) { $ host = $ _SERVER [ 'HTTP_X_FORWARDED_HOST' ] ; } elseif ( isset ( $ _SERVER [ 'HTTP_HOST' ] ) ) { $ host = $ _SERVER [ 'HTTP_HOST' ] ; } elseif ( isset ( $ _SERVER [ 'SERVER_NAME' ] ) ) { $ host = $ _SERVER [ 'SERVER_NAME' ] ; } else { $ host = gethostname ( ) ; } return $ host ; }
4115	public function getRemoteCallUrlTemplate ( ) { if ( is_null ( $ this -> remoteCallUrlTemplate ) ) { $ this -> remoteCallUrlTemplate = Mage :: getStoreConfig ( 'dev/aoe_templatehints/remoteCallUrlTemplate' ) ; } return $ this -> remoteCallUrlTemplate ; }
2468	public function getOptions ( ) : array { $ options = [ ] ; foreach ( self :: DEFAULT_OPTIONS as $ option => $ label ) { $ options [ $ option ] = $ this -> translator -> trans ( 'MSC.validCharacters.' . $ label , [ ] , 'contao_default' ) ; } $ event = new SlugValidCharactersEvent ( $ options ) ; $ this -> eventDispatcher -> dispatch ( ContaoCoreEvents :: SLUG_VALID_CHARACTERS , $ event ) ; return $ event -> getOptions ( ) ; }
10409	protected function getUrlsByDocumentParameter ( ) { if ( count ( $ this -> documentParamCache ) < 1 ) { return [ ] ; } $ urls = [ ] ; $ query = new Query ( ) ; $ queryTerms = [ ] ; foreach ( $ this -> documentParamCache as $ param ) { $ queryTerms [ $ param [ 0 ] ] [ ] = $ param [ 1 ] ; } foreach ( $ queryTerms as $ field => $ values ) { $ termQuery = new TermQuery ( $ field , $ values ) ; $ query -> addQuery ( $ termQuery , 'should' ) ; } $ limitFilter = new LimitFilter ( count ( $ this -> documentParamCache ) ) ; $ repository = $ this -> manager -> getRepository ( 'MultiModel' ) ; $ search = $ repository -> createSearch ( ) -> addQuery ( $ query ) -> addFilter ( $ limitFilter ) ; $ documents = $ repository -> execute ( $ search ) ; foreach ( $ documents as $ document ) { if ( is_array ( $ document -> url ) ) { foreach ( $ document -> url as $ url ) { $ urls [ ] = $ url [ 'url' ] ; } } } array_walk ( $ urls , [ $ this , 'addWildcard' ] ) ; $ this -> addUrls ( $ urls ) ; return $ urls ; }
4756	public function transform ( $ value ) { if ( $ value instanceof \ Traversable || is_array ( $ value ) ) { return $ this -> transformIterable ( $ value ) ; } if ( is_bool ( $ value ) ) { return $ this -> transformBoolean ( $ value ) ; } if ( is_scalar ( $ value ) || ( is_object ( $ value ) && method_exists ( $ value , '__toString' ) ) ) { return $ value ; } if ( $ value instanceof Cache ) { return $ this -> transformCacheAnnotation ( $ value ) ; } if ( $ value instanceof Method ) { return $ this -> transformMethodAnnotation ( $ value ) ; } if ( $ value instanceof ParamConverter ) { return $ this -> transformParamConverter ( $ value ) ; } if ( $ value instanceof Security ) { return $ this -> transformSecurity ( $ value ) ; } if ( $ value instanceof Template ) { return $ this -> transformTemplate ( $ value ) ; } return get_class ( $ value ) ; }
8538	public function setOffer ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'Offer' ] [ 'FieldValue' ] = $ value ; return $ this ; }
9303	public function setSuccessLogLifetime ( $ time ) { if ( ! is_numeric ( $ time ) ) { throw new \ InvalidArgumentException ( '`successLogLifetime` expects integer value!' ) ; } $ this -> options [ 'successLogLifetime' ] = ( int ) $ time ; return $ this ; }
7555	function match ( $ conditions , $ match = true , $ custom_filters = array ( ) ) { $ t = isset ( $ conditions [ 'tags' ] ) ; $ a = isset ( $ conditions [ 'attributes' ] ) ; $ f = isset ( $ conditions [ 'filters' ] ) ; if ( ! ( $ t || $ a || $ f ) ) { if ( is_array ( $ conditions ) && $ conditions ) { foreach ( $ conditions as $ c ) { if ( $ this -> match ( $ c , $ match ) ) { return true ; } } } return false ; } else { if ( ( $ t && ( ! $ this -> match_tags ( $ conditions [ 'tags' ] ) ) ) === $ match ) { return false ; } if ( ( $ a && ( ! $ this -> match_attributes ( $ conditions [ 'attributes' ] ) ) ) === $ match ) { return false ; } if ( ( $ f && ( ! $ this -> match_filters ( $ conditions [ 'filters' ] , $ custom_filters ) ) ) === $ match ) { return false ; } return true ; } }
11131	public static function getRootBackslash ( $ pathname ) { if ( $ pathname [ 0 ] == '\\' ) { $ pathname = substr ( $ pathname , 1 ) ; } $ arr = explode ( '\\' , $ pathname ) ; if ( count ( $ arr ) > 1 ) { return $ arr [ 0 ] ; } return '' ; }
8566	public function getShipment ( $ request ) { if ( ! ( $ request instanceof MWSMerchantFulfillmentService_Model_GetShipmentRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/GetShipmentRequest.php' ) ; $ request = new MWSMerchantFulfillmentService_Model_GetShipmentRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetShipment' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/GetShipmentResponse.php' ) ; $ response = MWSMerchantFulfillmentService_Model_GetShipmentResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
11747	public function group ( ) { if ( is_null ( $ this -> group ) ) { $ this -> group = new Group ( $ this -> accessToken ) ; } return $ this -> group ; }
6389	public function readFacetofaceSession ( $ id ) { $ model = $ this -> readObject ( $ id , 'facetoface_sessions' ) ; $ model -> dates = $ this -> readStoreRecords ( 'facetoface_sessions_dates' , [ 'sessionid' => $ id ] ) ; $ model -> url = $ this -> cfg -> wwwroot . '/mod/facetoface/signup.php?s=' . $ id ; return $ model ; }
2759	protected function getStorageKey ( $ key , $ limit , $ milliseconds ) { $ window = $ milliseconds * ( floor ( ( microtime ( 1 ) * 1000 ) / $ milliseconds ) ) ; $ date = date ( 'YmdHis' , $ window / 1000 ) ; return $ date . '::' . $ key . '::' . $ limit . '::' . $ milliseconds . '::COUNT' ; }
3671	private function getFolderUrlFragments ( string $ alias , string $ host , string $ locale = null ) : ? array { $ pages = $ this -> getPageCandidates ( $ alias ) ; if ( null === $ pages ) { return null ; } if ( isset ( $ pages [ $ host ] ) ) { $ languages = $ pages [ $ host ] ; } else { $ languages = $ pages [ '*' ] ? : [ ] ; } unset ( $ pages ) ; $ pages = [ ] ; if ( ! $ this -> isLocalePrepended ) { $ pages = current ( $ languages ) ; } elseif ( $ locale && isset ( $ languages [ $ locale ] ) ) { $ pages = $ languages [ $ locale ] ; } if ( empty ( $ pages ) ) { return null ; } $ page = $ pages [ 0 ] ; if ( $ alias == $ page -> alias ) { $ arrFragments = [ $ alias ] ; } else { $ arrFragments = explode ( '/' , substr ( $ alias , ( \ strlen ( $ page -> alias ) + 1 ) ) ) ; array_unshift ( $ arrFragments , $ page -> alias ) ; } return $ arrFragments ; }
6946	private function getRegularDueQueryBuilder ( ) { $ qb = $ this -> createQueryBuilder ( 'o' ) ; $ ex = $ qb -> expr ( ) ; return $ qb -> where ( $ ex -> andX ( $ ex -> eq ( 'o.sample' , ':not_sample' ) , $ ex -> lt ( 'o.paidTotal' , 'o.grandTotal' ) , $ ex -> notIn ( 'o.invoiceState' , ':canceled_or_refunded' ) , $ ex -> eq ( 'o.shipmentState' , ':shipped' ) , $ ex -> isNull ( 'o.paymentTerm' ) ) ) -> addOrderBy ( 'o.createdAt' , 'ASC' ) -> setParameter ( 'not_sample' , false ) -> setParameter ( 'shipped' , ShipmentStates :: STATE_COMPLETED ) -> setParameter ( 'canceled_or_refunded' , [ InvoiceStates :: STATE_CANCELED , InvoiceStates :: STATE_CREDITED ] ) ; }
1204	protected function renderChildren ( ItemInterface $ item , array $ options ) { if ( null !== $ options [ 'depth' ] ) { $ options [ 'depth' ] = $ options [ 'depth' ] - 1 ; } if ( null !== $ options [ 'matchingDepth' ] && $ options [ 'matchingDepth' ] > 0 ) { $ options [ 'matchingDepth' ] = $ options [ 'matchingDepth' ] - 1 ; } $ html = '' ; foreach ( $ item -> getChildren ( ) as $ child ) { $ html .= $ this -> renderItem ( $ child , $ options ) ; } return $ html ; }
12341	protected function printError ( \ Throwable $ error , bool $ withTime = true , ? string $ fontColor = null , ? string $ bgColor = self :: BG_COLOR_MAP [ 'red' ] ) : void { $ shift = $ withTime ? "\t\t" : '' ; $ this -> print ( $ this -> getColoredMsg ( 'Error: ' . $ error -> getMessage ( ) , $ fontColor , $ bgColor ) . \ PHP_EOL . $ shift . $ this -> getColoredMsg ( 'File: ' . $ error -> getFile ( ) , $ fontColor , $ bgColor ) . \ PHP_EOL . $ shift . $ this -> getColoredMsg ( 'Line: ' . $ error -> getLine ( ) , $ fontColor , $ bgColor ) , $ withTime ) ; }
2406	public static function generateStyleTag ( $ href , $ media = null , $ mtime = false ) { if ( $ mtime === null && ! preg_match ( '@^https?://@' , $ href ) ) { $ container = System :: getContainer ( ) ; $ rootDir = $ container -> getParameter ( 'kernel.project_dir' ) ; if ( file_exists ( $ rootDir . '/' . $ href ) ) { $ mtime = filemtime ( $ rootDir . '/' . $ href ) ; } else { $ webDir = StringUtil :: stripRootDir ( $ container -> getParameter ( 'contao.web_dir' ) ) ; if ( file_exists ( $ rootDir . '/' . $ webDir . '/' . $ href ) ) { $ mtime = filemtime ( $ rootDir . '/' . $ webDir . '/' . $ href ) ; } } } if ( $ mtime ) { $ href .= '?v=' . substr ( md5 ( $ mtime ) , 0 , 8 ) ; } return '<link rel="stylesheet" href="' . $ href . '"' . ( ( $ media && $ media != 'all' ) ? ' media="' . $ media . '"' : '' ) . '>' ; }
1541	public function withQualifiedKeyName ( $ keyName ) { $ parts = explode ( '.' , $ keyName ) ; if ( ! isset ( $ parts [ 1 ] ) ) { throw new \ InvalidArgumentException ( 'Expecting a valid qualified column name.' ) ; } $ this -> withIdentifierColumn ( $ parts [ 1 ] ) ; return $ this ; }
4159	function pop ( ) { $ response = $ this -> redis -> blPop ( $ this -> key , 10 ) ; if ( $ response ) { list ( $ list , $ serializedJob ) = $ response ; $ job = unserialize ( $ serializedJob ) ; return $ job ; } }
7198	protected function fixCustomers ( OrderInterface $ order ) { $ changed = false ; $ originCustomer = $ order -> getOriginCustomer ( ) ; $ customer = $ order -> getCustomer ( ) ; if ( is_null ( $ customer ) ) { if ( $ originCustomer && $ originCustomer -> hasParent ( ) ) { $ order -> setCustomer ( $ originCustomer -> getParent ( ) ) ; $ changed = true ; } } elseif ( $ customer -> hasParent ( ) ) { $ order -> setCustomer ( $ customer -> getParent ( ) ) ; if ( null === $ order -> getOriginCustomer ( ) ) { $ order -> setOriginCustomer ( $ customer ) ; } $ changed = true ; } if ( $ changed ) { $ this -> persistenceHelper -> persistAndRecompute ( $ order , false ) ; } return $ changed ; }
12237	public function setAttributes ( array $ attr , $ ns = null ) { $ dom = dom_import_simplexml ( $ this ) ; foreach ( $ attr as $ k => $ v ) { $ dom -> setAttributeNS ( $ ns , $ k , $ v ) ; } return $ this ; }
9424	public function write ( $ string ) { if ( ! $ this -> isWritable ( ) ) { $ message = 'Stream is not writable' ; throw new \ RuntimeException ( $ message ) ; } $ this -> size = null ; return fwrite ( $ this -> stream , $ string ) ; }
126	protected function createRemoveRule ( PackageInterface $ package , $ reason , $ job ) { return new GenericRule ( array ( - $ package -> id ) , $ reason , $ job [ 'packageName' ] , $ job ) ; }
5922	public function setPropertySets ( array $ propertySets ) { $ this -> propertySets = [ ] ; foreach ( $ propertySets as $ item ) { $ this -> addPropertySet ( $ item ) ; } return $ this ; }
6831	protected function synchronizeWithProduct ( SupplierOrderItemInterface $ item ) { $ changed = false ; if ( null !== $ product = $ item -> getProduct ( ) ) { $ productSID = $ product -> getSubjectIdentity ( ) ; if ( $ productSID -> hasIdentity ( ) ) { $ itemSID = $ item -> getSubjectIdentity ( ) ; if ( $ itemSID -> hasIdentity ( ) ) { if ( ! $ itemSID -> equals ( $ productSID ) ) { throw new LogicException ( 'Breaking synchronization between supplier order item and supplier product is not supported.' ) ; } $ changed = false ; } else { $ itemSID -> copy ( $ productSID ) ; $ changed = true ; } } else { throw new InvalidArgumentException ( 'Supplier product subject identity is not set.' ) ; } if ( 0 == strlen ( $ item -> getDesignation ( ) ) ) { $ item -> setDesignation ( $ product -> getDesignation ( ) ) ; } if ( 0 == strlen ( $ item -> getReference ( ) ) ) { $ item -> setReference ( $ product -> getReference ( ) ) ; } if ( 0 == $ item -> getNetPrice ( ) ) { $ item -> setNetPrice ( $ product -> getNetPrice ( ) ) ; } } elseif ( $ item -> hasSubjectIdentity ( ) ) { throw new LogicException ( 'Breaking synchronization between supplier order item and supplier product is not supported.' ) ; } return $ changed ; }
1469	public static function httpErrorStatus ( $ errors , int $ default = SymfonyResponse :: HTTP_BAD_REQUEST ) : int { if ( $ errors instanceof ErrorInterface ) { $ errors = [ $ errors ] ; } $ statuses = collect ( $ errors ) -> reject ( function ( ErrorInterface $ error ) { return is_null ( $ error -> getStatus ( ) ) ; } ) -> map ( function ( ErrorInterface $ error ) { return ( int ) $ error -> getStatus ( ) ; } ) -> unique ( ) ; if ( 2 > count ( $ statuses ) ) { return $ statuses -> first ( ) ? : $ default ; } $ only4xx = $ statuses -> every ( function ( int $ status ) { return 400 <= $ status && 499 >= $ status ; } ) ; return $ only4xx ? SymfonyResponse :: HTTP_BAD_REQUEST : SymfonyResponse :: HTTP_INTERNAL_SERVER_ERROR ; }
11073	public function setString ( string $ key , $ value , string $ ignoredDefaultValue = null ) { $ this -> set ( $ key , ( string ) $ value , $ ignoredDefaultValue ) ; return $ this ; }
3513	public function getPublish ( $ group ) { if ( $ group && $ group != '*' ) { $ this -> manager -> exportTranslations ( $ group ) ; } else { $ this -> manager -> exportAllTranslations ( ) ; } $ errors = $ this -> manager -> errors ( ) ; event ( new TranslationsPublished ( $ group , $ errors ) ) ; return Response :: json ( array ( 'status' => $ errors ? 'errors' : 'ok' , 'errors' => $ errors ) ) ; }
2350	public function copyTo ( $ strNewName ) { $ strParent = \ dirname ( $ strNewName ) ; if ( ! is_dir ( $ this -> strRootDir . '/' . $ strParent ) ) { new Folder ( $ strParent ) ; } $ return = $ this -> Files -> copy ( $ this -> strFile , $ strNewName ) ; $ syncSource = Dbafs :: shouldBeSynchronized ( $ this -> strFile ) ; $ syncTarget = Dbafs :: shouldBeSynchronized ( $ strNewName ) ; if ( $ syncSource && $ syncTarget ) { Dbafs :: copyResource ( $ this -> strFile , $ strNewName ) ; } elseif ( $ syncTarget ) { Dbafs :: addResource ( $ strNewName ) ; } return $ return ; }
3646	public function clean ( $ value , bool $ trim = true , bool $ clean = true ) { if ( is_bool ( $ value ) || is_int ( $ value ) || is_float ( $ value ) ) { return $ value ; } $ final = null ; if ( $ value !== null ) { if ( is_array ( $ value ) ) { $ all = $ value ; $ final = [ ] ; foreach ( $ all as $ key => $ value ) { if ( $ value !== null ) { $ final [ $ key ] = $ this -> clean ( $ value , $ trim , $ clean ) ; } } } else { if ( $ value !== null ) { $ final = $ this -> process ( ( string ) $ value , $ trim , $ clean ) ; } } } return $ final ; }
4731	public static function unicode_to_utf16 ( $ str ) { if ( \ extension_loaded ( 'mbstring' ) ) { return preg_replace_callback ( '/\\\\u([0-9a-fA-F]{4})/' , function ( $ match ) { return mb_convert_encoding ( pack ( 'H*' , $ match [ 1 ] ) , 'UTF-8' , 'UTF-16BE' ) ; } , $ str ) ; } return $ str ; }
10256	public function getState ( $ state_code = null ) { if ( ! empty ( $ state_code ) ) { $ res = Zipcode :: where ( 'state_code' , $ state_code ) -> orderByRaw ( Database :: random ( ) ) -> first ( ) ; } else { $ res = Zipcode :: orderByRaw ( Database :: random ( ) ) -> first ( ) ; } $ State = new Entities \ State ; $ State -> code = $ res -> state_code ; $ State -> name = $ res -> state ; return $ State ; }
5711	public function FieldHolder ( $ attributes = array ( ) ) { if ( $ this -> shouldDisplay ( ) ) { $ this -> setContent ( $ this -> getButtonHTML ( ) ) ; return parent :: FieldHolder ( $ attributes ) ; } }
9886	private function writeDefinedNameForAutofilter ( XMLWriter $ objWriter , Worksheet $ pSheet , $ pSheetId = 0 ) { $ autoFilterRange = $ pSheet -> getAutoFilter ( ) -> getRange ( ) ; if ( ! empty ( $ autoFilterRange ) ) { $ objWriter -> startElement ( 'definedName' ) ; $ objWriter -> writeAttribute ( 'name' , '_xlnm._FilterDatabase' ) ; $ objWriter -> writeAttribute ( 'localSheetId' , $ pSheetId ) ; $ objWriter -> writeAttribute ( 'hidden' , '1' ) ; $ range = Coordinate :: splitRange ( $ autoFilterRange ) ; $ range = $ range [ 0 ] ; if ( strpos ( $ range [ 0 ] , '!' ) !== false ) { list ( $ ws , $ range [ 0 ] ) = explode ( '!' , $ range [ 0 ] ) ; } $ range [ 0 ] = Coordinate :: absoluteCoordinate ( $ range [ 0 ] ) ; $ range [ 1 ] = Coordinate :: absoluteCoordinate ( $ range [ 1 ] ) ; $ range = implode ( ':' , $ range ) ; $ objWriter -> writeRawData ( '\'' . str_replace ( "'" , "''" , $ pSheet -> getTitle ( ) ) . '\'!' . $ range ) ; $ objWriter -> endElement ( ) ; } }
3072	protected function getItemRef ( $ itemIdentifier ) { $ serviceContext = $ this -> getServiceContext ( ) ; $ mapService = $ this -> getServiceLocator ( ) -> get ( QtiRunnerMap :: SERVICE_ID ) ; return $ mapService -> getItemHref ( $ serviceContext , $ itemIdentifier ) ; }
9643	public static function getDriver ( MappingDriver $ originalDriver , $ namespace ) { if ( $ originalDriver instanceof MappingDriverChain ) { $ driver = new Driver \ Chain ( ) ; foreach ( $ originalDriver -> getDrivers ( ) as $ nestedNamespace => $ nestedDriver ) { $ driver -> addDriver ( static :: getDriver ( $ nestedDriver , $ namespace ) , $ nestedNamespace ) ; } if ( $ originalDriver -> getDefaultDriver ( ) !== null ) { $ driver -> setDefaultDriver ( static :: getDriver ( $ originalDriver -> getDefaultDriver ( ) , $ namespace ) ) ; } return $ driver ; } preg_match ( '/(?P<type>Xml|Yaml|Annotation)Driver$/' , get_class ( $ originalDriver ) , $ m ) ; $ type = isset ( $ m [ 'type' ] ) ? $ m [ 'type' ] : null ; $ driverClass = sprintf ( '%s\Mapping\Driver\%s' , $ namespace , $ type ) ; if ( ! $ type || ! class_exists ( $ driverClass ) ) { $ driverClass = sprintf ( '%s\Mapping\Driver\Annotation' , $ namespace ) ; if ( ! class_exists ( $ driverClass ) ) { throw new \ RuntimeException ( sprintf ( 'Failed to fallback to annotation driver: (%s), extension driver was not found.' , $ driverClass ) ) ; } } $ driver = new $ driverClass ( ) ; $ driver -> setOriginalDriver ( $ originalDriver ) ; if ( $ driver instanceof Driver \ File ) { $ driver -> setLocator ( $ originalDriver -> getLocator ( ) ) ; } elseif ( $ driver instanceof AnnotationDriverInterface ) { $ reader = static :: getAnnotationReader ( ) ; $ driver -> setAnnotationReader ( $ reader ) ; } return $ driver ; }
7034	protected function saveMigration ( array $ tables ) { try { $ tables = serialize ( $ tables ) ; return Db :: query ( "insert into migrations(host, tables) values(?, ?)" , [ gethostname ( ) , $ tables ] , $ this -> dbName , false ) ; } catch ( PDOException $ e ) { error_log ( $ e -> getMessage ( ) ) ; return false ; } }
11049	function parse_info ( $ info ) { $ elements = explode ( ':' , $ info ) ; $ count = count ( $ elements ) ; if ( $ count > 4 ) { for ( $ i = 4 ; $ i < $ count ; ++ $ i ) { $ elements [ 3 ] .= ':' . $ elements [ $ i ] ; } } else { $ elements = array_pad ( $ elements , 4 , '' ) ; } return array ( $ elements [ 0 ] , $ elements [ 2 ] , $ elements [ 3 ] ) ; }
1548	private function registerProcesses ( ) : void { $ this -> routeForProcess ( 'get' , $ this -> baseProcessUrl ( ) , $ this -> actionForRoute ( 'processes' ) ) ; $ this -> routeForProcess ( 'get' , $ this -> processUrl ( ) , $ this -> actionForRoute ( 'process' ) ) ; }
7791	public function setClosingBalanceClass ( $ closingBalanceClass ) { if ( ! is_callable ( $ closingBalanceClass ) && ! class_exists ( $ closingBalanceClass ) ) { throw new \ InvalidArgumentException ( '$closingBalanceClass must be a valid classname or a PHP callable' ) ; } $ this -> closingBalanceClass = $ closingBalanceClass ; return $ this ; }
107	public function prohibitUrlByConfig ( $ url , IOInterface $ io = null ) { if ( false === filter_var ( $ url , FILTER_VALIDATE_URL ) ) { return ; } $ scheme = parse_url ( $ url , PHP_URL_SCHEME ) ; if ( in_array ( $ scheme , array ( 'http' , 'git' , 'ftp' , 'svn' ) ) ) { if ( $ this -> get ( 'secure-http' ) ) { throw new TransportException ( "Your configuration does not allow connections to $url. See https://getcomposer.org/doc/06-config.md#secure-http for details." ) ; } elseif ( $ io ) { $ host = parse_url ( $ url , PHP_URL_HOST ) ; if ( ! isset ( $ this -> warnedHosts [ $ host ] ) ) { $ io -> writeError ( "<warning>Warning: Accessing $host over $scheme which is an insecure protocol.</warning>" ) ; } $ this -> warnedHosts [ $ host ] = true ; } } }
8121	public function ReviewContentForm ( HTTPRequest $ request ) { $ id = $ request -> param ( 'ID' ) ? : $ request -> postVar ( 'ID' ) ; return $ this -> getReviewContentForm ( $ id ) ; }
7089	public function defaultHeader ( array $ headers = [ ] ) { $ this -> defaultHeaders = array_merge ( $ this -> defaultHeaders , $ headers ) ; return $ this -> defaultHeaders ; }
4146	protected function getUrl ( ) { $ domain = $ this -> urls [ 'domain' ] ; $ apiVersion = $ this -> urls [ 'api' ] ; $ jsonExt = '.json' ; if ( isset ( $ this -> withMedia ) && $ this -> withMedia === true ) { $ domain = $ this -> urls [ 'upload' ] ; } if ( $ this -> call === 'oauth/request_token' || $ this -> call === 'oauth/access_token' ) { $ apiVersion = '' ; $ jsonExt = '' ; } return $ domain . $ apiVersion . $ this -> call . $ jsonExt ; }
5671	protected function describeStringDifference ( $ first , $ second , $ identical ) { if ( is_object ( $ second ) || is_array ( $ second ) ) { return $ this -> describeGenericDifference ( $ first , $ second ) ; } $ position = $ this -> stringDiffersAt ( $ first , $ second ) ; return sprintf ( 'at character %s with [%s] and [%s]' , $ position , $ this -> clipString ( $ first , 200 , $ position ) , $ this -> clipString ( $ second , 200 , $ position ) ) ; }
10005	public function setRibbonXMLData ( $ target , $ xmlData ) { if ( $ target !== null && $ xmlData !== null ) { $ this -> ribbonXMLData = [ 'target' => $ target , 'data' => $ xmlData ] ; } else { $ this -> ribbonXMLData = null ; } }
4405	public function generate ( InputInterface $ input , OutputInterface $ output ) { $ fileSystem = $ this -> container -> get ( 'filesystem' ) ; $ configResolver = $ this -> container -> get ( 'ezpublish.config.resolver' ) ; $ kernelRootDir = $ this -> container -> getParameter ( 'kernel.root_dir' ) ; $ siteAccessGroup = $ input -> getOption ( 'site-access-group' ) ; $ varDir = $ configResolver -> getParameter ( 'var_dir' , null , $ siteAccessGroup ) ; $ repository = $ configResolver -> getParameter ( 'repository' , null , $ siteAccessGroup ) ; $ configFile = $ kernelRootDir . '/config/ngadminui.yml' ; if ( $ fileSystem -> exists ( $ configFile ) ) { if ( ! $ this -> questionHelper -> ask ( $ input , $ output , new ConfirmationQuestion ( '<info><comment>ngadminui.yml</comment> configuration file already exists. Do you want to overwrite it?</info> [<comment>no</comment>] ' , false ) ) ) { return ; } } $ siteAccessName = $ input -> getOption ( 'site-access-name' ) ; $ languageService = $ this -> container -> get ( 'ezpublish.api.repository' ) -> getContentLanguageService ( ) ; $ languages = $ languageService -> loadLanguages ( ) ; $ settings = array ( 'parameters' => array ( 'netgen_admin_ui.' . $ siteAccessName . '.is_admin_ui_siteaccess' => true , 'eztags.' . $ siteAccessName . '.routing.enable_tag_router' => false , 'ezsettings.' . $ siteAccessName . '.treemenu.http_cache' => false , ) , 'ezpublish' => array ( 'siteaccess' => array ( 'list' => array ( $ siteAccessName , ) , 'groups' => array ( 'ngadminui' => array ( $ siteAccessName , ) , ) , 'match' => array ( 'Map\URI' => array ( $ siteAccessName => $ siteAccessName , ) , ) , ) , 'system' => array ( $ siteAccessName => array ( 'user' => array ( 'layout' => '@NetgenAdminUI/pagelayout_login.html.twig' , 'login_template' => '@NetgenAdminUI/user/login.html.twig' , ) , 'languages' => array_map ( function ( Language $ language ) { return $ language -> languageCode ; } , $ languages ) , 'var_dir' => $ varDir , 'repository' => $ repository , ) , ) , ) , 'ez_publish_legacy' => array ( 'system' => array ( $ siteAccessName => array ( 'templating' => array ( 'view_layout' => '@NetgenAdminUI/pagelayout_legacy.html.twig' , 'module_layout' => '@NetgenAdminUI/pagelayout_module.html.twig' , ) , ) , ) , ) , ) ; file_put_contents ( $ configFile , Yaml :: dump ( $ settings , 7 ) ) ; $ output -> writeln ( array ( '' , 'Generated <comment>ngadminui.yml</comment> configuration file!' , '' , ) ) ; }
10565	protected function formatJson ( $ response ) { $ response -> getHeaders ( ) -> set ( 'Content-Type' , 'application/json; charset=UTF-8' ) ; if ( $ response -> data !== null ) { $ options = $ this -> encodeOptions ; if ( $ this -> prettyPrint ) { $ options |= JSON_PRETTY_PRINT ; } $ response -> content = Json :: encode ( $ response -> data , $ options ) ; } }
7649	public function stream_flush ( ) { $ result = fflush ( $ this -> temporaryFileHandle ) ; if ( $ this -> writeMode ) { $ containerExists = $ this -> getStorageClient ( $ this -> fileName ) -> containerExists ( $ this -> getContainerName ( $ this -> fileName ) ) ; if ( ! $ containerExists ) { $ this -> getStorageClient ( $ this -> fileName ) -> createContainer ( $ this -> getContainerName ( $ this -> fileName ) ) ; } try { $ this -> getStorageClient ( $ this -> fileName ) -> putBlob ( $ this -> getContainerName ( $ this -> fileName ) , $ this -> getFileName ( $ this -> fileName ) , $ this -> temporaryFileName ) ; } catch ( BlobException $ ex ) { @ unlink ( $ this -> temporaryFileName ) ; unset ( $ this -> storageClient ) ; throw $ ex ; } } return $ result ; }
12193	public function onKernelException ( GetResponseForExceptionEvent $ event ) { $ exception = $ event -> getException ( ) ; if ( $ exception instanceof AuthenticationCredentialsNotFoundException ) { return new RedirectResponse ( "/login" ) ; } $ message = $ exception -> getMessage ( ) ; if ( $ exception instanceof NotFoundHttpException || $ exception instanceof PageNotPublishedException ) { $ this -> render404page ( $ event , $ message ) ; return ; } if ( ! $ exception instanceof RedKiteCmsExceptionInterface ) { DataLogger :: log ( $ message , DataLogger :: CRITICAL ) ; if ( $ this -> debug ) { return $ event ; } $ this -> setUpResponse ( $ event , $ message ) ; return ; } $ message = Utils :: translateException ( $ message , $ exception ) ; $ this -> setUpResponse ( $ event , $ message ) ; DataLogger :: log ( $ message , DataLogger :: ERROR ) ; }
9253	protected function getContainerInitializer ( ) { $ initializer = new DefaultInitializer ( $ this -> getConfigurationProvider ( ) ) ; if ( $ this -> cache ) { $ initializer = new CachedInitializer ( $ initializer , $ this -> getCacheDir ( ) ) ; } return $ initializer ; }
12393	public function onSiteSaved ( SiteSavedEvent $ event ) { $ fs = new Filesystem ( ) ; $ fs -> mirror ( $ this -> configurationHandler -> uploadAssetsDir ( ) , $ this -> configurationHandler -> uploadAssetsDirProduction ( ) ) ; }
8935	public function add ( $ name , $ template ) { if ( array_key_exists ( $ name , $ this -> templates ) ) { throw new \ InvalidArgumentException ( 'Template already exists.' ) ; } $ this -> templates [ $ name ] = $ template ; }
5113	public function writeQTime ( $ timestamp ) { if ( $ timestamp instanceof \ DateTime ) { $ msec = $ timestamp -> format ( 'H' ) * 3600000 + $ timestamp -> format ( 'i' ) * 60000 + $ timestamp -> format ( 's' ) * 1000 + ( int ) ( $ timestamp -> format ( '0.u' ) * 1000 ) ; } else { $ msec = round ( ( $ timestamp - strtotime ( 'midnight' , ( int ) $ timestamp ) ) * 1000 ) ; } $ this -> writeUInt ( $ msec ) ; }
12471	protected function setDatabaseFactoryNamespaces ( ) { $ this -> replaceIn ( $ this -> laravel -> databasePath ( ) . '/factories/ModelFactory.php' , $ this -> currentRoot , $ this -> argument ( 'name' ) ) ; }
1316	public function post ( $ path , array $ parameters = [ ] , $ json = false ) { return $ this -> http ( 'POST' , self :: API_HOST , $ path , $ parameters , $ json ) ; }
10279	public static function coordinateFromString ( $ pCoordinateString ) { if ( preg_match ( '/^([$]?[A-Z]{1,3})([$]?\\d{1,7})$/' , $ pCoordinateString , $ matches ) ) { return [ $ matches [ 1 ] , $ matches [ 2 ] ] ; } elseif ( self :: coordinateIsRange ( $ pCoordinateString ) ) { throw new Exception ( 'Cell coordinate string can not be a range of cells' ) ; } elseif ( $ pCoordinateString == '' ) { throw new Exception ( 'Cell coordinate can not be zero-length string' ) ; } throw new Exception ( 'Invalid cell coordinate ' . $ pCoordinateString ) ; }
3661	private function addParameters ( $ parameters ) { if ( empty ( $ parameters ) ) { return ; } $ this -> queryParameter = array_merge ( $ this -> queryParameter , $ parameters ) ; }
2926	public function load ( $ filePath = null , $ restoreIfNotFound = false , $ restorePath = null ) { $ this -> resetContent ( ) ; if ( ! is_null ( $ filePath ) ) { $ this -> filePath = $ filePath ; } else { if ( method_exists ( $ this -> app , 'environmentPath' ) && method_exists ( $ this -> app , 'environmentFile' ) ) { $ this -> filePath = $ this -> app -> environmentPath ( ) . '/' . $ this -> app -> environmentFile ( ) ; } else { $ this -> filePath = __DIR__ . '/../../../../../../.env' ; } } $ this -> reader -> load ( $ this -> filePath ) ; if ( file_exists ( $ this -> filePath ) ) { $ this -> writer -> setBuffer ( $ this -> getContent ( ) ) ; return $ this ; } elseif ( $ restoreIfNotFound ) { return $ this -> restore ( $ restorePath ) ; } else { return $ this ; } }
6613	public function settings ( $ setting = null ) { if ( ! is_null ( $ setting ) ) { return isset ( $ this -> settings [ $ setting ] ) ? $ this -> settings [ $ setting ] : null ; } return $ this -> settings ; }
7934	public function alreadyLoaded ( $ name ) { foreach ( $ this -> loaded as $ item ) { if ( $ item [ 'name' ] === $ name ) { return true ; } } return false ; }
6450	private function getLanguageValuesFromHeaders ( array $ headers ) : array { $ languages = [ ] ; foreach ( $ headers as $ header ) { $ languages [ ] = $ header -> getLanguage ( ) ; } return $ languages ; }
6080	public function updateProperties ( $ id , array $ properties ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'properties' => $ properties ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> put ( 'v1/media/' . $ id . '/properties' , $ parameters ) ; $ result = new MediaResponse ( $ result ) ; return $ result ; }
3136	public function setItemState ( RunnerServiceContext $ context , $ itemRef , $ state ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ serviceService = $ this -> getServiceManager ( ) -> get ( StorageManager :: SERVICE_ID ) ; $ userUri = \ common_session_SessionManager :: getSession ( ) -> getUserUri ( ) ; $ stateId = $ this -> getStateId ( $ context , $ itemRef ) ; if ( ! isset ( $ state ) ) { $ state = '' ; } return is_null ( $ userUri ) ? false : $ serviceService -> set ( $ userUri , $ stateId , json_encode ( $ state ) ) ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'setItemState' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } }
4878	public function setUser ( UserInterface $ user ) { if ( $ this -> user ) { $ this -> getPermissions ( ) -> revoke ( $ this -> user , Permissions :: PERMISSION_ALL , false ) ; } $ this -> user = $ user ; $ this -> getPermissions ( ) -> grant ( $ user , Permissions :: PERMISSION_ALL ) ; return $ this ; }
11083	public static function passwdGen ( $ length = 8 , $ flag = 'ALPHANUMERIC' ) { switch ( $ flag ) { case 'NUMERIC' : $ str = '0123456789' ; break ; case 'ALPHA' : $ str = 'abcdefghijkmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ' ; break ; case 'ALPHA_LOWER' : $ str = 'abcdefghijkmnopqrstuvwxyz' ; break ; default : $ str = 'abcdefghijkmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' ; break ; } for ( $ i = 0 , $ passwd = '' ; $ i < $ length ; $ i ++ ) { $ passwd .= substr ( $ str , mt_rand ( 0 , \ strlen ( $ str ) - 1 ) , 1 ) ; } return $ passwd ; }
10668	public static function build ( $ input , array $ options = [ ] ) { if ( ! \ is_array ( $ options ) ) { $ options = [ 'return' => ( string ) $ options ] ; } $ defaults = [ 'return' => 'simplexml' , ] ; $ options = array_merge ( $ defaults , $ options ) ; if ( is_array ( $ input ) || is_object ( $ input ) ) { return self :: fromArray ( ( array ) $ input , $ options ) ; } if ( strpos ( $ input , '<' ) !== false ) { if ( $ options [ 'return' ] === 'simplexml' || $ options [ 'return' ] === 'simplexmlelement' ) { return new \ SimpleXMLElement ( $ input , LIBXML_NOCDATA ) ; } $ dom = new \ DOMDocument ( ) ; $ dom -> loadXML ( $ input ) ; return $ dom ; } if ( file_exists ( $ input ) || strpos ( $ input , 'http://' ) === 0 || strpos ( $ input , 'https://' ) === 0 ) { if ( $ options [ 'return' ] === 'simplexml' || $ options [ 'return' ] === 'simplexmlelement' ) { return new \ SimpleXMLElement ( $ input , LIBXML_NOCDATA , true ) ; } $ dom = new \ DOMDocument ( ) ; $ dom -> load ( $ input ) ; return $ dom ; } if ( ! \ is_string ( $ input ) ) { throw new \ RuntimeException ( Tools :: poorManTranslate ( 'fts-shared' , 'Invalid input.' ) ) ; } throw new \ RuntimeException ( Tools :: poorManTranslate ( 'fts-shared' , 'XML cannot be read.' ) ) ; }
5028	public function decorateClassMetaData ( ClassMetadata $ c ) { $ parentClassName = $ c -> getName ( ) ; if ( isset ( $ this -> mappings [ $ parentClassName ] ) ) { $ c -> discriminatorMap = array ( ) ; $ c -> discriminatorMap [ strtolower ( Str :: classname ( $ parentClassName ) ) ] = $ parentClassName ; foreach ( $ this -> mappings [ $ parentClassName ] as $ className ) { $ bundlePrefix = Str :: infix ( $ this -> getBundleName ( $ className ) , '-' ) ; $ name = Str :: infix ( Str :: classname ( Str :: rstrip ( $ className , Str :: classname ( $ parentClassName ) ) ) , '-' ) ; $ combinedDiscriminator = sprintf ( '%s-%s' , $ bundlePrefix , $ name ) ; $ c -> discriminatorMap [ $ combinedDiscriminator ] = $ className ; $ c -> subClasses [ ] = $ className ; } $ c -> subClasses = array_unique ( $ c -> subClasses ) ; } }
11313	public static function buildBasestring ( $ method , Url $ url , array $ data ) { $ base = array ( ) ; $ base [ ] = self :: urlEncode ( self :: getNormalizedMethod ( $ method ) ) ; $ base [ ] = self :: urlEncode ( self :: getNormalizedUrl ( $ url ) ) ; $ base [ ] = self :: urlEncode ( self :: getNormalizedParameters ( $ data ) ) ; return implode ( '&' , $ base ) ; }
4304	public function profileEnd ( $ name = null ) { $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) , array ( 'name' => null ) , array ( 'name' ) ) ; if ( $ meta [ 'name' ] === null ) { \ end ( $ this -> data [ 'profileInstances' ] ) ; $ meta [ 'name' ] = \ key ( $ this -> data [ 'profileInstances' ] ) ; } $ name = $ meta [ 'name' ] ; if ( isset ( $ this -> data [ 'profileInstances' ] [ $ name ] ) ) { $ instance = $ this -> data [ 'profileInstances' ] [ $ name ] ; $ data = $ instance -> end ( ) ; $ caption = 'Profile \'' . $ name . '\' Results' ; if ( $ data ) { $ args = array ( $ data ) ; $ meta [ 'sortable' ] = true ; $ meta [ 'caption' ] = $ caption ; $ meta [ 'totalCols' ] = array ( 'ownTime' ) ; $ meta [ 'columns' ] = array ( ) ; } else { $ args = array ( $ caption , 'no data' ) ; } unset ( $ this -> data [ 'profileInstances' ] [ $ name ] ) ; } else { $ args = array ( $ name !== null ? 'profileEnd: No such Profile: ' . $ name : 'profileEnd: Not currently profiling' ) ; } $ this -> appendLog ( __FUNCTION__ , $ args , $ meta ) ; }
9965	public function setSelectedCells ( $ pCoordinate ) { $ pCoordinate = strtoupper ( $ pCoordinate ) ; $ pCoordinate = preg_replace ( '/^([A-Z]+)$/' , '${1}:${1}' , $ pCoordinate ) ; $ pCoordinate = preg_replace ( '/^(\d+)$/' , '${1}:${1}' , $ pCoordinate ) ; $ pCoordinate = preg_replace ( '/^([A-Z]+):([A-Z]+)$/' , '${1}1:${2}1048576' , $ pCoordinate ) ; $ pCoordinate = preg_replace ( '/^(\d+):(\d+)$/' , 'A${1}:XFD${2}' , $ pCoordinate ) ; if ( Coordinate :: coordinateIsRange ( $ pCoordinate ) ) { list ( $ first ) = Coordinate :: splitRange ( $ pCoordinate ) ; $ this -> activeCell = $ first [ 0 ] ; } else { $ this -> activeCell = $ pCoordinate ; } $ this -> selectedCells = $ pCoordinate ; return $ this ; }
9371	public function integrate ( $ integrations , ConfigurationInterface $ config = null ) { list ( $ config , $ container ) = array ( $ config ? : $ this -> config , static :: $ container ) ; foreach ( ( array ) $ integrations as $ item ) { $ integration = is_string ( $ item ) ? new $ item : $ item ; $ container = $ integration -> define ( $ container , $ config ) ; } static :: $ container = $ container ; return $ this ; }
11206	public function map ( $ callback , $ data = false ) { $ collection = $ this -> getIterator ( ) ; $ mutatedCollection = new Collection ( ) ; foreach ( $ collection as $ prop => $ result ) { $ funcArgs = is_array ( $ data ) ? $ data : [ $ data ] ; array_unshift ( $ funcArgs , $ prop ) ; array_unshift ( $ funcArgs , $ result ) ; $ aValue = call_user_func_array ( $ callback , $ funcArgs ) ; $ mutatedCollection -> add ( $ aValue ) ; } return $ mutatedCollection ; }
4736	public function process ( ContainerBuilder $ container ) { $ serviceId = 'simple_bus.asynchronous.publishes_predefined_messages_middleware' ; if ( ! $ container -> hasDefinition ( $ serviceId ) ) { return ; } $ names = array ( ) ; $ this -> collectServiceIds ( $ container , 'asynchronous_event_subscriber' , 'subscribes_to' , function ( $ key ) use ( & $ names ) { $ names [ ] = $ key ; } ) ; $ container -> getDefinition ( $ serviceId ) -> replaceArgument ( 2 , array_unique ( $ names ) ) ; }
12504	public static function rollbackTransaction ( $ connection ) { $ connection -> query = 'ROLLBACK' ; $ connection -> method = 'POST' ; $ connection -> action = '/_query' ; return self :: sendQuery ( $ connection ) ; }
9267	public function recipe ( string $ string , string $ method , callable $ callback = null ) : string { return preg_replace_callback ( RegEx :: REGEX_SPACE , [ $ this , $ method ] , $ this -> callback ( $ string , $ callback ) ) ; }
1006	public function resolveType ( $ objectValue , $ context , ResolveInfo $ info ) { if ( isset ( $ this -> config [ 'resolveType' ] ) ) { $ fn = $ this -> config [ 'resolveType' ] ; return $ fn ( $ objectValue , $ context , $ info ) ; } return null ; }
700	public function actionExt ( $ extension , $ repo = null ) { $ base = \ dirname ( \ dirname ( __DIR__ ) ) ; $ extensionDir = "$base/extensions/$extension" ; if ( ! file_exists ( $ extensionDir ) ) { if ( empty ( $ repo ) ) { if ( isset ( $ this -> extensions [ $ extension ] ) ) { $ repo = $ this -> extensions [ $ extension ] ; if ( $ this -> useHttp ) { $ repo = str_replace ( 'git@github.com:' , 'https://github.com/' , $ repo ) ; } } else { $ this -> stderr ( "Repo argument is required for extension '$extension'.\n" , Console :: FG_RED ) ; return 1 ; } } $ this -> stdout ( "cloning extension repo '$extension' from '$repo'...\n" , Console :: BOLD ) ; passthru ( 'git clone ' . escapeshellarg ( $ repo ) . ' ' . $ extensionDir ) ; $ this -> stdout ( "done.\n" , Console :: BOLD , Console :: FG_GREEN ) ; } $ this -> stdout ( "cleaning up extension '$extension' vendor directory...\n" , Console :: BOLD ) ; $ this -> cleanupVendorDir ( $ extensionDir ) ; $ this -> stdout ( "done.\n" , Console :: BOLD , Console :: FG_GREEN ) ; $ this -> stdout ( "updating composer for extension '$extension'...\n" , Console :: BOLD ) ; chdir ( $ extensionDir ) ; $ command = 'composer update --prefer-dist' ; if ( $ this -> composerNoProgress ) { $ command .= ' --no-progress' ; } passthru ( $ command ) ; $ this -> stdout ( "done.\n" , Console :: BOLD , Console :: FG_GREEN ) ; $ this -> stdout ( "linking framework and extensions to '$extension' vendor dir...\n" , Console :: BOLD ) ; $ this -> linkFrameworkAndExtensions ( $ extensionDir , $ base ) ; $ this -> stdout ( "done.\n" , Console :: BOLD , Console :: FG_GREEN ) ; return 0 ; }
5473	public function isMatch ( $ widget ) { if ( method_exists ( $ widget , 'isLabel' ) ) { if ( $ widget -> isLabel ( $ this -> label ) ) { return true ; } } return ( $ widget -> getName ( ) == $ this -> label ) ; }
10718	public function paginate ( $ page = 1 , $ perPage = null , $ columns = [ '*' ] ) { $ perPage = $ perPage ? : $ this -> defaultPageSize ; $ query = $ this -> getQuery ( ) ; $ total = $ query -> getQuery ( ) -> getCountForPagination ( $ columns ) ; $ query -> getQuery ( ) -> forPage ( $ page , $ perPage ) ; $ results = $ query -> get ( $ columns ) ; $ results = new LengthAwarePaginator ( $ results , $ total , $ perPage , $ page ) ; return $ this -> returnResults ( $ results ) ; }
1363	public static function create ( array $ parameters , $ beforeKey = 'before' , $ afterKey = 'after' , $ limitKey = 'limit' ) { return new self ( array_get ( $ parameters , $ beforeKey ) , array_get ( $ parameters , $ afterKey ) , array_get ( $ parameters , $ limitKey , 15 ) ) ; }
4158	function run ( ) { $ now = new DateTime ( 'now' ) ; $ sleep = min ( array_map ( function ( $ entry ) use ( $ now ) { list ( $ expression , $ job ) = $ entry ; return $ expression -> getNextRunDate ( $ now ) -> getTimestamp ( ) ; } , $ this -> entries ) ) ; time_sleep_until ( $ sleep ) ; $ scheduled = 0 ; foreach ( $ this -> entries as $ entry ) { list ( $ expression , $ job ) = $ entry ; if ( $ expression -> isDue ( $ now ) ) { $ this -> queue -> push ( $ job ) ; $ scheduled += 1 ; } } $ this -> queue -> flush ( ) ; return $ scheduled ; }
11487	protected function callResolvingCallbacks ( $ key , $ object ) { foreach ( $ this -> resolvingAnyCallbacks as $ callback ) { call_user_func ( $ callback , $ object , $ this ) ; } if ( isset ( $ this -> resolvingCallbacks [ $ key ] ) ) { foreach ( $ this -> resolvingCallbacks [ $ key ] as $ callback ) { call_user_func ( $ callback , $ object , $ this ) ; } } }
1793	private function getHostAndPort ( string $ domain ) : array { if ( false !== strpos ( $ domain , ':' ) ) { return explode ( ':' , $ domain , 2 ) ; } return [ $ domain , null ] ; }
12337	public function confirmEmailAction ( ) { $ token = $ this -> params ( ) -> fromRoute ( 'token' ) ; if ( $ token ) { $ identity = $ this -> getUserService ( ) -> confirmEmail ( $ token ) ; if ( $ identity instanceof ResponseInterface ) { return $ identity ; } elseif ( $ identity ) { $ viewModel = new ViewModel ( compact ( 'identity' ) ) ; $ viewModel -> setTemplate ( 'cms-user/index/confirm-email' ) ; return $ viewModel ; } } return $ this -> redirect ( ) -> toRoute ( $ this -> getOptions ( ) -> getDefaultUserRoute ( ) ) ; }
4728	private function setCache ( $ singular , $ plural = null ) { $ singular = StringHelper :: strtolower ( $ singular ) ; if ( $ plural === null ) { $ plural = $ singular ; } else { $ plural = StringHelper :: strtolower ( $ plural ) ; } $ this -> cache [ $ singular ] = $ plural ; }
12241	public function addClass ( $ class ) { if ( ! $ this -> hasClass ( $ class ) ) { $ current = ( string ) $ this [ 'class' ] ; if ( $ current !== '' && substr ( $ current , - 1 ) !== ' ' ) { $ this [ 'class' ] .= ' ' ; } $ this [ 'class' ] .= $ class ; } return $ this ; }
6126	public function addRole ( $ item ) { if ( ! ( $ item instanceof Role ) ) { if ( is_array ( $ item ) ) { try { $ item = new Role ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate Role. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "Role"!' , E_USER_WARNING ) ; } } $ this -> roles [ ] = $ item ; return $ this ; }
9683	public function getCountryName ( $ code ) { $ name = Intl :: getRegionBundle ( ) -> getCountryName ( strtoupper ( $ code ) , $ this -> getRequest ( ) -> getLanguageCode ( ) ? : 'en' ) ; if ( $ name ) { return $ name ; } return $ code ; }
8399	public function display ( Environment $ environment , $ template , $ type = null , $ size = 'md' , $ object = null ) { $ tools = $ environment -> render ( $ template , array ( 'type' => $ type , 'object' => $ object , ) ) ; return $ environment -> render ( '@c975LToolbar/toolbar.html.twig' , array ( 'tools' => $ tools , 'size' => $ size , ) ) ; }
8412	public function isConnected ( ) : bool { if ( isset ( $ this -> servers [ 'all' ] ) === true ) { return isset ( $ this -> servers [ 'all' ] [ 'link' ] ) ; } return isset ( $ this -> servers [ 'read' ] [ 'link' ] ) && isset ( $ this -> servers [ 'write' ] [ 'link' ] ) ; }
11880	protected function getRunner ( ) { if ( null === $ this -> runner ) { $ this -> runner = new ConsoleApplication ( $ this -> name , $ this -> version , $ this -> description , $ this -> alias ) ; } return $ this -> runner ; }
40	protected function fetchRootIdentifier ( ) { if ( $ this -> repoData ) { return ; } $ repoDataUrl = $ this -> getApiUrl ( ) . '/repos/' . $ this -> owner . '/' . $ this -> repository ; $ this -> repoData = JsonFile :: parseJson ( $ this -> getContents ( $ repoDataUrl , true ) , $ repoDataUrl ) ; if ( null === $ this -> repoData && null !== $ this -> gitDriver ) { return ; } $ this -> owner = $ this -> repoData [ 'owner' ] [ 'login' ] ; $ this -> repository = $ this -> repoData [ 'name' ] ; $ this -> isPrivate = ! empty ( $ this -> repoData [ 'private' ] ) ; if ( isset ( $ this -> repoData [ 'default_branch' ] ) ) { $ this -> rootIdentifier = $ this -> repoData [ 'default_branch' ] ; } elseif ( isset ( $ this -> repoData [ 'master_branch' ] ) ) { $ this -> rootIdentifier = $ this -> repoData [ 'master_branch' ] ; } else { $ this -> rootIdentifier = 'master' ; } $ this -> hasIssues = ! empty ( $ this -> repoData [ 'has_issues' ] ) ; }
4485	public function watchdog ( string $ jid , string $ worker , ? int $ pid = null ) { if ( empty ( $ this -> channels ) || $ pid === null ) { return ; } ini_set ( 'default_socket_timeout' , self :: UNLIMITED ) ; $ pubsub = $ this -> redis -> pubSubLoop ( ) ; $ callable = [ $ pubsub , 'subscribe' ] ; if ( ! is_callable ( $ callable ) ) { return ; } call_user_func_array ( $ callable , $ this -> channels ) ; foreach ( $ pubsub as $ message ) { if ( $ message -> kind !== 'message' || empty ( $ message -> payload ) ) { continue ; } $ payload = json_decode ( $ message -> payload , true ) ; if ( empty ( $ payload ) ) { continue ; } if ( empty ( $ payload [ 'event' ] ) || ! is_array ( $ payload ) ) { continue ; } if ( ! in_array ( $ payload [ 'event' ] , self :: WATCHDOG_EVENTS , true ) || empty ( $ payload [ 'jid' ] ) ) { continue ; } if ( $ payload [ 'jid' ] !== $ jid ) { continue ; } $ who = 'watchdog:' . $ worker ; switch ( $ payload [ 'event' ] ) { case self :: LOCK_LOST : if ( ! empty ( $ payload [ 'worker' ] ) && $ payload [ 'worker' ] === $ worker ) { $ this -> logger -> info ( "{type}: sending SIGKILL to child {$pid}; job {jid} handed out to another worker" , [ 'type' => $ who , 'jid' => $ jid ] ) ; $ this -> system -> posixKill ( $ pid , SIGKILL ) ; $ pubsub -> stop ( ) ; } break ; case self :: CANCELED : if ( ! empty ( $ payload [ 'worker' ] ) && $ payload [ 'worker' ] === $ worker ) { $ this -> logger -> info ( "{type}: sending SIGKILL to child {$pid}; job {jid} canceled" , [ 'type' => $ who , 'jid' => $ jid ] ) ; $ this -> system -> posixKill ( $ pid , SIGKILL ) ; $ pubsub -> stop ( ) ; } break ; case self :: COMPLETED : case self :: FAILED : $ pubsub -> stop ( ) ; break ; } } unset ( $ pubsub ) ; ini_set ( 'default_socket_timeout' , $ this -> defaultSocketTimeout ) ; }
4867	public function fail ( JobInterface $ job , array $ options = [ ] ) { $ envelope = $ this -> createEnvelope ( $ job , $ options ) ; unset ( $ envelope [ 'created' ] ) ; unset ( $ envelope [ 'scheduled' ] ) ; $ envelope [ 'status' ] = self :: STATUS_FAILED ; $ this -> mongoCollection -> findOneAndUpdate ( [ '_id' => new \ MongoDB \ BSON \ ObjectId ( $ job -> getId ( ) ) ] , [ '$set' => $ envelope ] ) ; }
9817	public function setView ( $ pValue ) { if ( $ pValue === null ) { $ pValue = self :: SHEETVIEW_NORMAL ; } if ( in_array ( $ pValue , self :: $ sheetViewTypes ) ) { $ this -> sheetviewType = $ pValue ; } else { throw new PhpSpreadsheetException ( 'Invalid sheetview layout type.' ) ; } return $ this ; }
9509	public function search ( Log $ log , $ level = 'all' , Request $ request ) { if ( is_null ( $ query = $ request -> get ( 'query' ) ) ) return redirect ( ) -> route ( 'admin::foundation.system.log-viewer.logs.show' , [ $ log -> date ] ) ; $ levels = $ this -> logViewer -> levelsNames ( ) ; $ entries = $ log -> entries ( $ level ) -> filter ( function ( LogEntry $ value ) use ( $ query ) { return Str :: contains ( $ value -> header , $ query ) ; } ) -> paginate ( $ this -> perPage ) ; return $ this -> view ( 'admin.system.log-viewer.show' , compact ( 'log' , 'levels' , 'level' , 'query' , 'entries' ) ) ; }
4101	public function map ( $ mapping , array $ config = array ( ) ) { if ( is_array ( $ mapping ) ) $ mapping = new Mapping ( $ mapping ) ; $ mapping -> config ( $ config ) ; try { $ type = $ mapping -> config ( 'type' ) ; } catch ( \ Exception $ e ) { } if ( isset ( $ type ) && ! $ this -> passesTypeConstraint ( $ type ) ) { throw new Exception ( "Cant create mapping due to type constraint mismatch" ) ; } return $ this -> request ( '_mapping' , 'PUT' , $ mapping -> export ( ) , true ) ; }
10661	public function withoutCookie ( $ cookieName = null ) { $ object = clone $ this ; if ( ! $ this -> configs [ 'cookies' ] instanceof CookieJarInterface ) { return $ object ; } if ( ! $ cookieName ) { unset ( $ object -> configs [ 'cookies' ] ) ; } else { if ( ! is_array ( $ cookieName ) ) { $ cookieName = [ $ cookieName ] ; } $ cookies = $ this -> configs [ 'cookies' ] -> toArray ( ) ; foreach ( $ cookieName as $ cookie ) { if ( ! is_string ( $ cookie ) || ! $ cookie ) { continue ; } unset ( $ cookies [ $ cookie ] ) ; } $ this -> configs [ 'cookies' ] = new CookieJar ( $ cookies ) ; } return $ object -> buildConfigClient ( ) ; }
10047	protected function copyRecursive ( $ src , $ dst , $ depth , Logger $ logger ) { if ( $ depth == 0 ) { return ; } if ( ! is_file ( $ src ) && ! is_dir ( $ src ) ) { $ logger -> log ( "$src is not a valid source." , Logger :: WARNING ) ; return ; } if ( ! is_readable ( $ src ) ) { $ logger -> log ( "$src is not readable, skipping." , Logger :: WARNING ) ; return ; } if ( is_file ( $ dst ) || is_dir ( $ dst ) ) { $ logger -> log ( "$dst already exists, and cannot be overwritten." , Logger :: WARNING ) ; return ; } if ( is_dir ( $ src ) ) { mkdir ( $ dst ) ; } elseif ( is_file ( $ src ) ) { copy ( $ src , $ dst ) ; return ; } $ dh = opendir ( $ src ) ; while ( ( $ file = readdir ( $ dh ) ) !== false ) { if ( ( $ file === '.' ) || ( $ file === '..' ) ) { continue ; } $ this -> copyRecursive ( $ src . '/' . $ file , $ dst . '/' . $ file , $ depth - 1 , $ logger ) ; } }
4259	public function getSubscribers ( $ eventName = null ) { if ( $ eventName !== null ) { if ( ! isset ( $ this -> subscribers [ $ eventName ] ) ) { return array ( ) ; } if ( ! isset ( $ this -> sorted [ $ eventName ] ) ) { $ this -> sortSubscribers ( $ eventName ) ; } return $ this -> sorted [ $ eventName ] ; } foreach ( \ array_keys ( $ this -> subscribers ) as $ eventName ) { if ( ! isset ( $ this -> sorted [ $ eventName ] ) ) { $ this -> sortSubscribers ( $ eventName ) ; } } return \ array_filter ( $ this -> sorted ) ; }
3360	public function op ( $ operation ) { if ( ! $ operation ) { return $ this ; } $ result = clone $ this ; $ result -> operations [ ] [ 'custom' ] = $ operation ; return $ result ; }
831	private function fixConstructor ( Tokens $ tokens , $ className , $ classStart , $ classEnd ) { $ php4 = $ this -> findFunction ( $ tokens , $ className , $ classStart , $ classEnd ) ; if ( null === $ php4 ) { return ; } if ( ! empty ( $ php4 [ 'modifiers' ] [ T_ABSTRACT ] ) || ! empty ( $ php4 [ 'modifiers' ] [ T_STATIC ] ) ) { return ; } $ php5 = $ this -> findFunction ( $ tokens , '__construct' , $ classStart , $ classEnd ) ; if ( null === $ php5 ) { $ tokens [ $ php4 [ 'nameIndex' ] ] = new Token ( [ T_STRING , '__construct' ] ) ; $ this -> fixInfiniteRecursion ( $ tokens , $ php4 [ 'bodyIndex' ] , $ php4 [ 'endIndex' ] ) ; return ; } list ( $ seq , $ case ) = $ this -> getWrapperMethodSequence ( $ tokens , '__construct' , $ php4 [ 'startIndex' ] , $ php4 [ 'bodyIndex' ] ) ; if ( null !== $ tokens -> findSequence ( $ seq , $ php4 [ 'bodyIndex' ] - 1 , $ php4 [ 'endIndex' ] , $ case ) ) { for ( $ i = $ php4 [ 'startIndex' ] ; $ i <= $ php4 [ 'endIndex' ] ; ++ $ i ) { $ tokens -> clearAt ( $ i ) ; } return ; } list ( $ seq , $ case ) = $ this -> getWrapperMethodSequence ( $ tokens , $ className , $ php4 [ 'startIndex' ] , $ php4 [ 'bodyIndex' ] ) ; if ( null !== $ tokens -> findSequence ( $ seq , $ php5 [ 'bodyIndex' ] - 1 , $ php5 [ 'endIndex' ] , $ case ) ) { for ( $ i = $ php5 [ 'startIndex' ] ; $ i <= $ php5 [ 'endIndex' ] ; ++ $ i ) { $ tokens -> clearAt ( $ i ) ; } $ tokens [ $ php4 [ 'nameIndex' ] ] = new Token ( [ T_STRING , '__construct' ] ) ; } }
3115	public function storeItemHrefIndex ( $ testSessionId , $ table ) { $ extendedState = $ this -> getExtendedState ( $ testSessionId ) ; $ extendedState -> setItemHrefIndex ( $ table ) ; $ extendedState -> save ( ) ; }
3986	public function getCombinations ( ) { $ user = $ this -> getUser ( ) ; switch ( true ) { case ( $ user instanceof BackendUser ) : $ mode = 'be' ; $ groups = $ user -> groups ; if ( $ user -> admin ) { $ groups [ ] = - 1 ; } break ; case ( $ user instanceof FrontendUser ) : $ mode = 'fe' ; $ groups = $ user -> groups ; if ( ! $ this -> getUser ( ) -> id ) { $ groups = [ - 1 ] ; } break ; default : $ mode = 'fe' ; $ groups = [ - 1 ] ; } $ groups = array_filter ( $ groups ) ; if ( $ this -> cache -> contains ( $ cacheKey = 'combinations_' . $ mode . '_' . implode ( ',' , $ groups ) ) ) { return $ this -> cache -> fetch ( $ cacheKey ) ; } $ combinations = $ this -> builder -> getCombinationsForUser ( $ groups , $ mode ) ; $ this -> cache -> save ( $ cacheKey , $ combinations ) ; return $ combinations ; }
2465	public function checkPermission ( ) { $ bundles = Contao \ System :: getContainer ( ) -> getParameter ( 'kernel.bundles' ) ; if ( ! isset ( $ bundles [ 'ContaoCommentsBundle' ] ) ) { $ key = array_search ( 'allowComments' , $ GLOBALS [ 'TL_DCA' ] [ 'tl_faq' ] [ 'list' ] [ 'sorting' ] [ 'headerFields' ] ) ; unset ( $ GLOBALS [ 'TL_DCA' ] [ 'tl_faq' ] [ 'list' ] [ 'sorting' ] [ 'headerFields' ] [ $ key ] ) ; } }
1260	protected function createAccess ( ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; $ accessRequest = $ xml -> appendChild ( $ xml -> createElement ( 'AccessRequest' ) ) ; $ accessRequest -> setAttribute ( 'xml:lang' , 'en-US' ) ; $ accessRequest -> appendChild ( $ xml -> createElement ( 'AccessLicenseNumber' , $ this -> accessKey ) ) ; $ accessRequest -> appendChild ( $ xml -> createElement ( 'UserId' , $ this -> userId ) ) ; $ p = $ accessRequest -> appendChild ( $ xml -> createElement ( 'Password' ) ) ; $ p -> appendChild ( $ xml -> createTextNode ( $ this -> password ) ) ; return $ xml -> saveXML ( ) ; }
11050	function protect_spaces ( $ data ) { $ data = str_replace ( "\n" , "\1n\1" , $ data ) ; $ data = str_replace ( "\r" , "\1r\1" , $ data ) ; $ data = str_replace ( "\t" , "\1t\1" , $ data ) ; return str_replace ( " " , "\1s\1" , $ data ) ; }
8430	protected function getFaFileIcon ( $ fileType ) { switch ( $ fileType ) { case FileManager :: FILE_TYPE_IMAGE : { return 'fa-file-image' ; } case FileManager :: FILE_TYPE_VIDEO : { return 'fa-file-video' ; } case FileManager :: FILE_TYPE_AUDIO : { return 'fa-file-audio' ; } case FileManager :: FILE_TYPE_DOCUMENT : { return 'fa-file' ; } case FileManager :: FILE_TYPE_COMPRESSED : { return 'fa-file-archive' ; } } }
13	public function setClassMapAuthoritative ( $ classMapAuthoritative = false ) { $ this -> classMapAuthoritative = ( bool ) $ classMapAuthoritative ; if ( $ this -> classMapAuthoritative ) { $ this -> setOptimizeAutoloader ( true ) ; } return $ this ; }
1666	protected function enableTwoFactor ( BackendUser $ user , $ return ) { if ( $ user -> useTwoFactor ) { return ; } $ container = System :: getContainer ( ) ; $ verifyHelp = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'twoFactorVerificationHelp' ] ; $ authenticator = $ container -> get ( 'contao.security.two_factor.authenticator' ) ; if ( Input :: post ( 'FORM_SUBMIT' ) == 'tl_two_factor' ) { if ( $ authenticator -> validateCode ( $ user , Input :: post ( 'verify' ) ) ) { $ user -> useTwoFactor = '1' ; $ user -> save ( ) ; throw new RedirectResponseException ( $ return ) ; } $ this -> Template -> error = true ; $ verifyHelp = $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'invalidTwoFactor' ] ; } if ( ! $ user -> secret ) { $ user -> secret = random_bytes ( 128 ) ; $ user -> save ( ) ; } $ request = $ container -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; $ this -> Template -> enable = true ; $ this -> Template -> secret = Base32 :: encodeUpperUnpadded ( $ user -> secret ) ; $ this -> Template -> textCode = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'twoFactorTextCode' ] ; $ this -> Template -> qrCode = base64_encode ( $ authenticator -> getQrCode ( $ user , $ request ) ) ; $ this -> Template -> scan = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'twoFactorScan' ] ; $ this -> Template -> verify = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'twoFactorVerification' ] ; $ this -> Template -> verifyHelp = $ verifyHelp ; }
10086	public function writeDebugLog ( ... $ args ) { if ( $ this -> writeDebugLog ) { $ message = implode ( $ args ) ; $ cellReference = implode ( ' -> ' , $ this -> cellStack -> showStack ( ) ) ; if ( $ this -> echoDebugLog ) { echo $ cellReference , ( $ this -> cellStack -> count ( ) > 0 ? ' => ' : '' ) , $ message , PHP_EOL ; } $ this -> debugLog [ ] = $ cellReference . ( $ this -> cellStack -> count ( ) > 0 ? ' => ' : '' ) . $ message ; } }
8986	public function get_columns ( ) { return array ( 'id' => new IntegerBased ( 'BIGINT' , 'id' , array ( 'NOT NULL' , 'auto_increment' ) , array ( 20 ) ) , 'message' => new StringBased ( 'VARCHAR' , 'message' , array ( ) , array ( 255 ) ) , 'level' => new StringBased ( 'VARCHAR' , 'level' , array ( ) , array ( 20 ) ) , 'lgroup' => new StringBased ( 'VARCHAR' , 'lgroup' , array ( ) , array ( 20 ) ) , 'time' => new DateTime ( 'time' ) , 'user' => new ForeignUser ( 'user' ) , 'ip' => new StringBased ( 'VARCHAR' , 'ip' , array ( ) , array ( 45 ) ) , 'exception' => new StringBased ( 'VARCHAR' , 'exception' , array ( ) , array ( 255 ) ) , 'trace' => new StringBased ( 'LONGTEXT' , 'trace' ) , 'context' => new StringBased ( 'LONGTEXT' , 'context' ) , ) ; }
4953	public function call ( $ method , $ args = [ ] , $ expect = self :: EXPECT_SELF ) { if ( ! is_array ( $ args ) ) { $ expect = $ args ; $ args = [ ] ; } if ( ! $ this -> helper ) { return $ this -> expected ( $ expect ) ; } return call_user_func_array ( [ $ this -> helper , $ method ] , $ args ) ; }
1919	public function appendToSchema ( Schema $ schema ) : void { $ config = $ this -> getSqlDefinitions ( ) ; foreach ( $ config as $ tableName => $ definitions ) { $ table = $ schema -> createTable ( $ tableName ) ; if ( isset ( $ definitions [ 'TABLE_OPTIONS' ] ) ) { if ( preg_match ( '/ENGINE=([^ ]+)/i' , $ definitions [ 'TABLE_OPTIONS' ] , $ match ) ) { $ table -> addOption ( 'engine' , $ match [ 1 ] ) ; } if ( preg_match ( '/DEFAULT CHARSET=([^ ]+)/i' , $ definitions [ 'TABLE_OPTIONS' ] , $ match ) ) { $ table -> addOption ( 'charset' , $ match [ 1 ] ) ; $ table -> addOption ( 'collate' , $ match [ 1 ] . '_general_ci' ) ; } if ( preg_match ( '/COLLATE ([^ ]+)/i' , $ definitions [ 'TABLE_OPTIONS' ] , $ match ) ) { $ table -> addOption ( 'collate' , $ match [ 1 ] ) ; } } if ( $ table -> hasOption ( 'engine' ) && 'InnoDB' === $ table -> getOption ( 'engine' ) ) { $ table -> addOption ( 'row_format' , 'DYNAMIC' ) ; } if ( isset ( $ definitions [ 'SCHEMA_FIELDS' ] ) ) { foreach ( $ definitions [ 'SCHEMA_FIELDS' ] as $ fieldName => $ config ) { $ options = $ config ; unset ( $ options [ 'name' ] , $ options [ 'type' ] ) ; if ( $ this -> isCaseSensitive ( $ config ) ) { $ options [ 'platformOptions' ] [ 'collation' ] = $ this -> getBinaryCollation ( $ table ) ; } $ table -> addColumn ( $ config [ 'name' ] , $ config [ 'type' ] , $ options ) ; } } if ( isset ( $ definitions [ 'TABLE_FIELDS' ] ) ) { foreach ( $ definitions [ 'TABLE_FIELDS' ] as $ fieldName => $ sql ) { $ this -> parseColumnSql ( $ table , $ fieldName , substr ( $ sql , \ strlen ( $ fieldName ) + 3 ) ) ; } } if ( isset ( $ definitions [ 'TABLE_CREATE_DEFINITIONS' ] ) ) { foreach ( $ definitions [ 'TABLE_CREATE_DEFINITIONS' ] as $ keyName => $ sql ) { $ this -> parseIndexSql ( $ table , $ keyName , strtolower ( $ sql ) ) ; } } } }
4290	private function processExistingData ( ) { $ data = $ this -> debug -> getData ( ) ; $ channelName = $ this -> debug -> getCfg ( 'channel' ) ; foreach ( $ data [ 'alerts' ] as $ entry ) { $ this -> processLogEntryWEvent ( $ entry [ 0 ] , $ entry [ 1 ] , $ entry [ 2 ] ) ; } foreach ( $ data [ 'logSummary' ] as $ priority => $ entries ) { $ this -> processLogEntryWEvent ( 'groupSummary' , array ( ) , array ( 'channel' => $ channelName , 'priority' => $ priority , ) ) ; foreach ( $ entries as $ entry ) { $ this -> processLogEntryWEvent ( $ entry [ 0 ] , $ entry [ 1 ] , $ entry [ 2 ] ) ; } $ this -> processLogEntryWEvent ( 'groupEnd' , array ( ) , array ( 'channel' => $ channelName , 'closesSummary' => true , ) ) ; } foreach ( $ data [ 'log' ] as $ entry ) { $ this -> processLogEntryWEvent ( $ entry [ 0 ] , $ entry [ 1 ] , $ entry [ 2 ] ) ; } }
10654	public function __isset ( $ propertyName ) { $ methodName = 'get' . $ propertyName ; if ( method_exists ( $ this , $ methodName ) ) { return ( $ this -> $ methodName ( ) !== null ) ; } else { return false ; } }
2785	private function extractFail ( $ output ) { if ( preg_match ( '%##teamcity\[testFailed.*\]%' , $ output , $ matches ) ) { preg_match ( "/##teamcity\\[testFailed.*name='(.*)' message='(.*)' details='\\s*(.*)' flowId=.*/" , $ output , $ matches ) ; $ matches = $ this -> replaceEscapedChars ( $ matches ) ; $ fail = sprintf ( 'Test Name: %s' . PHP_EOL . 'Failure Message: %s' . PHP_EOL . 'Trace:' . PHP_EOL . '%s' , $ matches [ 1 ] , $ matches [ 2 ] , $ matches [ 3 ] ) ; return $ fail ; } return 'No failure output was detected by Humbug, but a failure was reported by PHPUnit.' ; }
9954	public function mergeCellsByColumnAndRow ( $ columnIndex1 , $ row1 , $ columnIndex2 , $ row2 ) { $ cellRange = Coordinate :: stringFromColumnIndex ( $ columnIndex1 ) . $ row1 . ':' . Coordinate :: stringFromColumnIndex ( $ columnIndex2 ) . $ row2 ; return $ this -> mergeCells ( $ cellRange ) ; }
4725	private function addRule ( $ data , $ ruleType ) { if ( \ is_string ( $ data ) ) { $ data = array ( $ data ) ; } elseif ( ! \ is_array ( $ data ) ) { throw new InvalidArgumentException ( 'Invalid inflector rule data.' ) ; } foreach ( $ data as $ rule ) { array_push ( $ this -> rules [ $ ruleType ] , ( string ) $ rule ) ; } }
10474	public function lookupItem ( $ item_id ) { $ request = new ItemRequest ( $ item_id ) ; $ this -> emit ( 'request.item' , array ( $ item_id ) ) ; $ response = $ this -> post ( $ request ) ; return new ItemResponse ( $ response ) ; }
2304	public function createPageList ( ) { $ this -> import ( BackendUser :: class , 'User' ) ; if ( $ this -> User -> isAdmin ) { return $ this -> doCreatePageList ( ) ; } $ return = '' ; $ processed = array ( ) ; foreach ( $ this -> eliminateNestedPages ( $ this -> User -> pagemounts ) as $ page ) { $ objPage = PageModel :: findWithDetails ( $ page ) ; if ( $ objPage -> type == 'root' ) { $ title = $ objPage -> title ; $ start = $ objPage -> id ; } else { $ title = $ objPage -> rootTitle ; $ start = $ objPage -> rootId ; } if ( \ in_array ( $ start , $ processed ) ) { continue ; } if ( $ objPage -> domain && $ objPage -> domain != Environment :: get ( 'host' ) ) { continue ; } $ processed [ ] = $ start ; $ return .= '<optgroup label="' . $ title . '">' . $ this -> doCreatePageList ( $ start ) . '</optgroup>' ; } return $ return ; }
2371	public static function splitCsv ( $ strString , $ strDelimiter = ',' ) { $ arrValues = preg_split ( '/' . $ strDelimiter . '(?=(?:[^"]*"[^"]*")*(?![^"]*"))/' , $ strString ) ; foreach ( $ arrValues as $ k => $ v ) { $ arrValues [ $ k ] = trim ( $ v , ' "' ) ; } return $ arrValues ; }
11443	public function getMessage ( $ id = null ) { if ( ! is_null ( $ id ) ) { return array_key_exists ( $ id , $ this -> messages ) ? $ this -> messages [ $ id ] : null ; } elseif ( count ( $ this -> messages ) > 0 ) { return current ( $ this -> messages ) ; } else { $ message_class = $ this -> getDefault ( 'messager' ) ; if ( class_exists ( $ message_class ) ) { $ this -> addMessage ( new $ message_class ) ; return current ( $ this -> messages ) ; } else { throw new \ Exception ( sprintf ( 'Default message class "%s" not found!' , $ message_class ) ) ; } } }
3009	public function fetch ( $ template , array $ data = [ ] ) { if ( isset ( $ data [ 'template' ] ) ) { throw new \ InvalidArgumentException ( "Duplicate template key found" ) ; } if ( ! is_file ( $ this -> templatePath . $ template ) ) { throw new \ RuntimeException ( "View cannot render `$template` because the template does not exist" ) ; } $ data = array_merge ( $ this -> attributes , $ data ) ; try { ob_start ( ) ; $ this -> protectedIncludeScope ( $ this -> templatePath . $ template , $ data ) ; $ output = ob_get_clean ( ) ; if ( $ this -> layout !== null ) { ob_start ( ) ; $ data [ 'content' ] = $ output ; $ this -> protectedIncludeScope ( $ this -> layout , $ data ) ; $ output = ob_get_clean ( ) ; } } catch ( \ Throwable $ e ) { ob_end_clean ( ) ; throw $ e ; } catch ( \ Exception $ e ) { ob_end_clean ( ) ; throw $ e ; } return $ output ; }
3925	public function decodeValue ( DecodePropertyValueForWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } if ( is_array ( $ event -> getValue ( ) ) ) { $ values = [ ] ; foreach ( $ event -> getValue ( ) as $ value ) { $ values [ ] = 'value_' . $ value ; } $ event -> setValue ( $ values ) ; } else { $ event -> setValue ( 'value_' . $ event -> getValue ( ) ) ; } }
11989	public function sort ( $ entityName , $ values ) { $ values = json_decode ( $ values ) ; for ( $ i = 0 ; $ i < count ( $ values ) ; $ i ++ ) { $ this -> entityManager -> getRepository ( $ entityName ) -> createQueryBuilder ( 'e' ) -> update ( ) -> set ( 'e.order' , $ i ) -> where ( 'e.id = :id' ) -> setParameter ( 'id' , $ values [ $ i ] -> id ) -> getQuery ( ) -> execute ( ) ; } }
1575	public function api ( $ apiName = null ) { $ repo = $ this -> container -> make ( Repository :: class ) ; return $ repo -> createApi ( $ apiName ? : $ this -> defaultApi ( ) ) ; }
11076	public function getHttpClient ( ) { if ( null === $ this -> httpClient ) { $ this -> httpClient = new HttpClient ( ) ; $ this -> httpClient -> setAdapter ( $ this -> getHttpAdapter ( ) ) ; } return $ this -> httpClient ; }
8136	public function setCache ( $ cache ) { if ( is_string ( $ cache ) ) { $ this -> originalCache = $ cache ; $ this -> cache = new Twig_Cache_Filesystem ( $ cache ) ; } elseif ( false === $ cache ) { $ this -> originalCache = $ cache ; $ this -> cache = new Twig_Cache_Null ( ) ; } elseif ( null === $ cache ) { @ trigger_error ( 'Using "null" as the cache strategy is deprecated since version 1.23 and will be removed in Twig 2.0.' , E_USER_DEPRECATED ) ; $ this -> originalCache = false ; $ this -> cache = new Twig_Cache_Null ( ) ; } elseif ( $ cache instanceof Twig_CacheInterface ) { $ this -> originalCache = $ this -> cache = $ cache ; } else { throw new LogicException ( sprintf ( 'Cache can only be a string, false, or a Twig_CacheInterface implementation.' ) ) ; } }
9541	private function decodeResponse ( Response $ response ) { $ data = json_decode ( $ response -> getBody ( ) -> read ( $ response -> getBody ( ) -> getSize ( ) ) , true ) ; if ( json_last_error ( ) !== JSON_ERROR_NONE ) { throw new ClientException ( 'Unable to parse response body into JSON: ' . json_last_error ( ) ) ; } return $ data === null ? array ( ) : $ data ; }
7979	public function getSessionProperties ( $ sessId ) { return json_decode ( self :: getClient ( ) -> getPcaSessionProperties ( $ this -> pp , $ this -> sn , $ sessId ) ) ; }
9483	public function toArray ( $ changedOnly = false , $ extraData = null ) { $ vars = get_object_vars ( $ this ) ; $ object = array ( ) ; if ( ! is_array ( $ this -> _changes ) ) { $ this -> _changes = array ( ) ; } if ( is_array ( $ extraData ) ) { $ vars = array_merge ( $ vars , $ extraData ) ; } foreach ( $ vars as $ k => $ v ) { if ( strpos ( $ k , '_' ) !== 0 && $ v !== null && ( ! $ changedOnly || array_key_exists ( $ k , $ this -> _changes ) || array_key_exists ( $ k , $ extraData ) ) ) { if ( is_array ( $ v ) ) { $ subV = array ( ) ; foreach ( $ v as $ sub ) { if ( is_a ( $ sub , 'Dlin\Zendesk\Entity\BaseEntity' ) ) { $ subV [ ] = $ sub -> toArray ( ) ; } else { $ subV [ ] = $ sub ; } } $ object [ $ k ] = $ subV ; } else if ( is_a ( $ v , 'Dlin\Zendesk\Entity\BaseEntity' ) ) { $ object [ $ k ] = $ v -> toArray ( ) ; } else { $ object [ $ k ] = $ v ; } } } return $ object ; }
7208	public function round ( ) : void { $ this -> unit = Money :: round ( $ this -> unit , $ this -> currency ) ; $ this -> gross = Money :: round ( $ this -> gross , $ this -> currency ) ; $ this -> discount = Money :: round ( $ this -> discount , $ this -> currency ) ; $ this -> base = Money :: round ( $ this -> base , $ this -> currency ) ; $ this -> total = Money :: round ( $ this -> total , $ this -> currency ) ; $ this -> tax = Money :: round ( $ this -> total - $ this -> base , $ this -> currency ) ; }
6582	public static function getSession ( ServerRequestInterface $ request ) : SessionDataHolder { $ session = $ request -> getAttribute ( static :: REQ_ATTR ) ; if ( ! $ session instanceof SessionDataHolder ) { throw new SessionMiddlewareException ( "No session object is available in the request attributes" ) ; } return $ session ; }
8204	protected function reserveJob ( $ tube ) { try { return $ this -> getPheanstalk ( ) -> reserveFromTube ( $ tube , 0 ) ; } catch ( ServerException $ e ) { if ( $ this -> isNotFoundException ( $ e ) ) { return ; } throw $ e ; } }
5184	private function lookUp ( array $ articleConstant ) : array { $ copyListAttributes = $ this -> listAttributes ; return array_map ( function ( $ singleConst ) use ( $ copyListAttributes ) { $ res = $ copyListAttributes [ $ singleConst ] ; return array_map ( function ( $ str ) use ( $ singleConst ) { return $ singleConst . $ str ; } , $ res ) ; } , $ articleConstant ) ; }
11265	public function model ( $ pathname ) { $ fullPath = $ this -> config [ 'pathToModels' ] . $ this -> getPath ( $ pathname ) . $ this -> config [ 'modelsPrefix' ] . $ this -> getName ( $ pathname ) . $ this -> config [ 'modelsPostfix' ] . '.php' ; include_once ( $ fullPath ) ; }
4559	protected function execute ( LifecycleEventArgs $ args , $ action ) { $ this -> tokenStorage = $ this -> container -> get ( 'security.token_storage' ) ; $ this -> configService = $ this -> container -> get ( 'ds_config.service.config' ) ; $ this -> auditService = $ this -> container -> get ( 'ds_audit.service.audit' ) ; $ entity = $ args -> getEntity ( ) ; if ( $ entity instanceof Audit ) { return ; } if ( ! $ entity instanceof Auditable ) { return ; } $ token = $ this -> tokenStorage -> getToken ( ) ; if ( ! $ token ) { return ; } $ user = $ token -> getUser ( ) ; $ edits = $ args -> getEntityManager ( ) -> getUnitOfWork ( ) -> getEntityChangeSet ( $ entity ) ; $ properties = $ this -> auditService -> getProperties ( $ entity ) ; foreach ( array_keys ( $ edits ) as $ key ) { if ( ! in_array ( $ key , $ properties ) ) { unset ( $ edits [ $ key ] ) ; } } $ audit = $ this -> auditService -> createInstance ( ) ; $ audit -> setOwner ( $ this -> configService -> get ( 'ds_audit.audit.owner' ) ) -> setOwnerUuid ( $ this -> configService -> get ( 'ds_audit.audit.owner_uuid' ) ) -> setUserUuid ( $ user -> getUuid ( ) ) -> setIdentity ( $ user -> getIdentity ( ) -> getType ( ) ) -> setIdentityUuid ( $ user -> getIdentity ( ) -> getUuid ( ) ) -> setAction ( $ action ) -> setData ( [ 'entity' => basename ( str_replace ( '\\' , '/' , get_class ( $ entity ) ) ) , 'entityUuid' => $ entity -> getUuid ( ) , 'edits' => $ edits ] ) ; $ manager = $ this -> auditService -> getManager ( ) ; $ manager -> persist ( $ audit ) ; $ manager -> flush ( ) ; }
5391	public function getValue ( ) { $ widgets = $ this -> getWidgets ( ) ; for ( $ i = 0 , $ count = count ( $ widgets ) ; $ i < $ count ; $ i ++ ) { if ( $ widgets [ $ i ] -> getValue ( ) !== false ) { return $ widgets [ $ i ] -> getValue ( ) ; } } return false ; }
567	private function parseDateValueFormat ( $ value , $ format ) { if ( is_array ( $ value ) ) { return false ; } if ( strncmp ( $ format , 'php:' , 4 ) === 0 ) { $ format = substr ( $ format , 4 ) ; } else { if ( extension_loaded ( 'intl' ) ) { return $ this -> parseDateValueIntl ( $ value , $ format ) ; } $ format = FormatConverter :: convertDateIcuToPhp ( $ format , 'date' ) ; } return $ this -> parseDateValuePHP ( $ value , $ format ) ; }
4363	public static function toUtf8 ( $ str ) { if ( \ extension_loaded ( 'mbstring' ) && \ function_exists ( 'iconv' ) ) { $ encoding = \ mb_detect_encoding ( $ str , \ mb_detect_order ( ) , true ) ; if ( ! $ encoding ) { $ str_conv = false ; if ( \ function_exists ( 'iconv' ) ) { $ str_conv = \ iconv ( 'cp1252' , 'UTF-8' , $ str ) ; } if ( $ str_conv === false ) { $ str_conv = \ htmlentities ( $ str , ENT_COMPAT ) ; $ str_conv = \ html_entity_decode ( $ str_conv , ENT_COMPAT , 'UTF-8' ) ; } $ str = $ str_conv ; } elseif ( ! \ in_array ( $ encoding , array ( 'ASCII' , 'UTF-8' ) ) ) { $ str_new = \ iconv ( $ encoding , 'UTF-8' , $ str ) ; if ( $ str_new !== false ) { $ str = $ str_new ; } } } return $ str ; }
12627	public function format ( $ format = null ) { if ( null === $ format ) { $ format = $ this -> _format ; } return parent :: format ( $ format ) ; }
4423	protected function doInteract ( ) { $ siteAccess = $ this -> askForData ( 'site-access-name' , 'Enter the name of the Netgen Admin UI siteaccess' , 'ngadminui' , function ( $ siteaccess ) { if ( ! preg_match ( '/^[a-z][a-z0-9_]*$/' , $ siteaccess ) ) { throw new InvalidArgumentException ( 'Siteaccess name is not valid. It must start with a letter, followed by any combination of letters, numbers and underscore.' ) ; } $ existingSiteAccesses = $ this -> getContainer ( ) -> getParameter ( 'ezpublish.siteaccess.list' ) ; if ( in_array ( $ siteaccess , $ existingSiteAccesses , true ) ) { throw new InvalidArgumentException ( sprintf ( 'Siteaccess "%s" already exists.' , $ siteaccess ) ) ; } return $ siteaccess ; } ) ; $ this -> output -> writeln ( '' ) ; $ languageCode = $ this -> askForData ( 'language-code' , 'Enter the language code in which the Netgen Admin UI will be translated' , 'eng-GB' , function ( $ languageCode ) { $ languageService = $ this -> getContainer ( ) -> get ( 'ezpublish.api.repository' ) -> getContentLanguageService ( ) ; try { $ languageService -> loadLanguage ( $ languageCode ) ; } catch ( NotFoundException $ e ) { throw new InvalidArgumentException ( sprintf ( 'Language code "%s" does not exist.' , $ languageCode ) ) ; } return $ languageCode ; } ) ; $ this -> output -> writeln ( '' ) ; $ availableGroups = array_keys ( $ this -> getContainer ( ) -> getParameter ( 'ezpublish.siteaccess.groups' ) ) ; $ availableGroups [ ] = 'default' ; $ siteAccessGroup = $ this -> askForChoiceData ( 'site-access-group' , 'Enter the siteaccess group name on which the Netgen Admin UI configuration will be based. This is usually the name of your frontend siteaccess group' , $ availableGroups , current ( $ availableGroups ) ) ; $ this -> writeSection ( 'Summary before installation' ) ; $ this -> output -> writeln ( array ( 'You are going to generate legacy <info>' . $ siteAccess . '</info> siteaccess with <info>' . $ languageCode . '</info> language code based on <info>' . $ siteAccessGroup . '</info> siteaccess group.' , '' , ) ) ; if ( ! $ this -> questionHelper -> ask ( $ this -> input , $ this -> output , $ this -> getConfirmationQuestion ( 'Do you confirm installation (answering <comment>no</comment> will restart the process)' , true ) ) ) { $ this -> output -> writeln ( '' ) ; return false ; } return true ; }
6796	protected function getValues ( $ valueIds , $ language ) { $ queryBuilder = $ this -> getConnection ( ) -> createQueryBuilder ( ) ; $ where = $ this -> getWhereColumn ( ) ? '(' . $ this -> getWhereColumn ( ) . ')' : null ; $ statement = $ this -> getConnection ( ) -> createQueryBuilder ( ) -> select ( 'source.*' ) -> from ( $ this -> getTagSource ( ) , 'source' ) -> where ( $ queryBuilder -> expr ( ) -> in ( 'source.' . $ this -> getIdColumn ( ) , $ valueIds ) ) -> andWhere ( $ queryBuilder -> expr ( ) -> andX ( ) -> add ( 'source.' . $ this -> getTagLangColumn ( ) . '=:lang' ) -> add ( $ where ) ) -> setParameter ( 'lang' , $ language ) -> groupBy ( 'source.' . $ this -> getIdColumn ( ) ) ; if ( $ this -> getTagSortSourceTable ( ) ) { $ statement -> addSelect ( $ this -> getTagSortSourceTable ( ) . '.*' ) ; $ statement -> join ( 's' , $ this -> getTagSortSourceTable ( ) , 'sort' , $ queryBuilder -> expr ( ) -> eq ( 'source.' . $ this -> getIdColumn ( ) , 'sort.id' ) ) ; if ( $ this -> getTagSortSourceColumn ( ) ) { $ statement -> orderBy ( $ this -> getTagSortSourceColumn ( 'sort' ) ) ; } } $ statement -> addOrderBy ( 'source.' . $ this -> getSortingColumn ( ) ) ; return $ statement -> execute ( ) ; }
11681	public function read ( $ id ) { $ path = $ this -> getPath ( $ id ) ; if ( ! file_exists ( $ path ) ) { return '' ; } if ( filemtime ( $ path ) < time ( ) - $ this -> lifeTime ) { return '' ; } return file_get_contents ( $ path ) ; }
3950	private function buildChildOperationButton ( $ idParameter , $ itemId , $ href , $ label , $ name , $ icon , $ attributes , $ table ) { $ modelId = ModelId :: fromValues ( $ table , $ itemId ) ; $ url = $ href . '&amp;' . $ idParameter . '=' . $ modelId -> getSerialized ( ) ; if ( 'id' !== $ idParameter ) { $ url .= '&amp;id=' ; } $ url = $ this -> controller -> addToUrl ( $ url ) ; if ( 'id' !== $ idParameter ) { $ url = preg_replace ( '#(&amp;)id=(?:&amp;)?#' , '$1' , $ url ) ; } $ title = sprintf ( $ label ? : $ name , $ itemId ) ; return sprintf ( '<a href="%1$s" title="%2$s"%3$s>%4$s</a> ' , $ url , specialchars ( $ title ) , $ attributes , $ this -> iconBuilder -> getBackendIconImageTag ( $ icon , $ label ) ) ; }
3143	public function timeout ( RunnerServiceContext $ context , $ scope , $ ref , $ late = false ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ session = $ context -> getTestSession ( ) ; if ( $ context -> isAdaptive ( ) ) { \ common_Logger :: t ( "Select next item before timeout" ) ; $ context -> selectAdaptiveNextItem ( ) ; } try { $ session -> closeTimer ( $ ref , $ scope ) ; if ( $ late ) { if ( $ scope == 'assessmentTest' ) { $ code = AssessmentTestSessionException :: ASSESSMENT_TEST_DURATION_OVERFLOW ; } else if ( $ scope == 'testPart' ) { $ code = AssessmentTestSessionException :: TEST_PART_DURATION_OVERFLOW ; } else if ( $ scope == 'assessmentSection' ) { $ code = AssessmentTestSessionException :: ASSESSMENT_SECTION_DURATION_OVERFLOW ; } else { $ code = AssessmentTestSessionException :: ASSESSMENT_ITEM_DURATION_OVERFLOW ; } throw new AssessmentTestSessionException ( "Maximum duration of ${scope} '${ref}' not respected." , $ code ) ; } else { $ session -> checkTimeLimits ( false , true , false ) ; } } catch ( AssessmentTestSessionException $ e ) { $ this -> onTimeout ( $ context , $ e ) ; } } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'timeout' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } return true ; }
6687	protected function mergeFlashMessages ( $ messageArray ) { $ messages = array_values ( $ messageArray ) ; $ flashMessage = '' ; $ flashMessageArr = [ ] ; foreach ( $ messages as $ message ) { if ( is_array ( $ message ) ) { if ( strlen ( $ flashMessage ) > 0 ) { $ flashMessage .= '<br/>' ; } $ flashMessage .= $ this -> mergeFlashMessages ( $ message ) ; } else { $ flashMessageArr [ ] = $ message ; } } return $ flashMessage . implode ( '<br/>' , $ flashMessageArr ) ; }
6163	public function getMemUsage ( $ realmem = false ) { if ( $ this -> isRunning ( ) ) { $ this -> stop ( ) ; $ this -> start ( ) ; } return ( $ realmem !== false ) ? $ this -> data [ "realmem" ] : $ this -> data [ "emalloc" ] ; }
10597	protected function getRouteLocalizedRecord ( \ MvcCore \ IRoute & $ route , $ getter ) { $ result = $ route -> $ getter ( $ this -> requestLang ) ; if ( $ result === NULL && $ this -> defaultLang !== NULL ) $ result = $ route -> $ getter ( $ this -> defaultLang ) ; return $ result ; }
5062	public function output ( ) : string { if ( is_null ( $ this -> buffer ) ) { $ this -> exec ( ) ; } curl_close ( $ this -> ch ) ; if ( strlen ( $ this -> buffer ) === 0 ) { throw new NoOutputException ( ) ; } return $ this -> buffer ; }
204	public static function moveCursorTo ( $ column , $ row = null ) { if ( $ row === null ) { echo "\033[" . ( int ) $ column . 'G' ; } else { echo "\033[" . ( int ) $ row . ';' . ( int ) $ column . 'H' ; } }
8235	protected function ivalidateToken ( $ index , array & $ tokenStorage ) { unset ( $ tokenStorage [ $ index ] ) ; $ this -> session -> set ( self :: SESSION_KEY , $ tokenStorage ) ; }
9800	public static function setChartRenderer ( $ rendererClass ) { if ( ! is_a ( $ rendererClass , IRenderer :: class , true ) ) { throw new Exception ( 'Chart renderer must implement ' . IRenderer :: class ) ; } self :: $ chartRenderer = $ rendererClass ; }
12571	public function previewVoice ( $ message , $ to , $ by = self :: PREVIEW_BY_OPENID ) { return $ this -> preview ( self :: MSG_TYPE_VOICE , $ message , $ to , $ by ) ; }
6856	protected static function equinoxMarch ( $ year , $ vsop = true ) { $ month = 3 ; if ( $ vsop ) return static :: accurate ( $ year , static :: meanTerms ( $ month , $ year ) , $ month ) ; else return static :: approx ( $ year , static :: meanTerms ( $ month , $ year ) ) ; }
4420	public function onKernelBuilt ( PostBuildKernelEvent $ event ) { $ currentRequest = $ this -> requestStack -> getCurrentRequest ( ) ; if ( $ currentRequest === null || ! $ event -> getKernelHandler ( ) instanceof ezpWebBasedKernelHandler || $ this -> configResolver -> getParameter ( 'legacy_mode' ) === true || ! $ this -> isUserAuthenticated ( ) ) { return ; } $ currentRequest -> getSession ( ) -> set ( 'eZUserLoggedInID' , $ this -> repository -> getCurrentUser ( ) -> id ) ; }
12814	private static function getNullableNames ( string $ table ) : array { if ( self :: $ nullablesCache === null || ! array_key_exists ( $ table , self :: $ nullablesCache ) ) self :: getNullables ( $ table ) ; return array_keys ( self :: $ nullablesCache [ $ table ] ) ; }
1414	public function resourceCannotBeDeleted ( string $ detail = null ) : ErrorInterface { return new Error ( null , null , Response :: HTTP_UNPROCESSABLE_ENTITY , $ this -> trans ( 'resource_cannot_be_deleted' , 'code' ) , $ this -> trans ( 'resource_cannot_be_deleted' , 'title' ) , $ detail ? : $ this -> trans ( 'resource_cannot_be_deleted' , 'detail' ) ) ; }
4205	private function getParams ( \ ReflectionMethod $ reflectionMethod , $ phpDoc = array ( ) ) { $ paramArray = array ( ) ; $ params = $ reflectionMethod -> getParameters ( ) ; if ( empty ( $ phpDoc ) ) { $ phpDoc = $ this -> phpDoc -> getParsed ( $ reflectionMethod ) ; } foreach ( $ params as $ i => $ reflectionParameter ) { $ nameNoPrefix = $ reflectionParameter -> getName ( ) ; $ name = '$' . $ nameNoPrefix ; if ( \ method_exists ( $ reflectionParameter , 'isVariadic' ) && $ reflectionParameter -> isVariadic ( ) ) { $ name = '...' . $ name ; } if ( $ reflectionParameter -> isPassedByReference ( ) ) { $ name = '&' . $ name ; } $ constantName = null ; $ defaultValue = $ this -> abstracter -> UNDEFINED ; if ( $ reflectionParameter -> isDefaultValueAvailable ( ) ) { $ defaultValue = $ reflectionParameter -> getDefaultValue ( ) ; if ( \ version_compare ( PHP_VERSION , '5.4.6' , '>=' ) && $ reflectionParameter -> isDefaultValueConstant ( ) ) { $ constantName = $ reflectionParameter -> getDefaultValueConstantName ( ) ; } } $ paramInfo = array ( 'constantName' => $ constantName , 'defaultValue' => $ defaultValue , 'desc' => null , 'isOptional' => $ reflectionParameter -> isOptional ( ) , 'name' => $ name , 'type' => $ this -> getParamTypeHint ( $ reflectionParameter ) , ) ; if ( isset ( $ phpDoc [ 'param' ] [ $ i ] ) ) { $ paramInfo [ 'desc' ] = $ phpDoc [ 'param' ] [ $ i ] [ 'desc' ] ; if ( ! isset ( $ paramInfo [ 'type' ] ) ) { $ paramInfo [ 'type' ] = $ phpDoc [ 'param' ] [ $ i ] [ 'type' ] ; } } $ paramArray [ $ nameNoPrefix ] = $ paramInfo ; } return $ paramArray ; }
8349	public static function toArray ( ) : array { if ( static :: $ array == null ) { $ ref = new \ ReflectionClass ( static :: class ) ; $ consts = $ ref -> getConstants ( ) ; static :: $ array = array ( ) ; foreach ( $ consts as $ key => $ value ) { if ( stripos ( $ key , 'VALUE_' ) === 0 ) { static :: $ array [ $ key ] = $ value ; } } } return static :: $ array ; }
10151	private function readFooter ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; if ( ! $ this -> readDataOnly ) { if ( $ recordData ) { if ( $ this -> version == self :: XLS_BIFF8 ) { $ string = self :: readUnicodeStringLong ( $ recordData ) ; } else { $ string = $ this -> readByteStringShort ( $ recordData ) ; } $ this -> phpSheet -> getHeaderFooter ( ) -> setOddFooter ( $ string [ 'value' ] ) ; $ this -> phpSheet -> getHeaderFooter ( ) -> setEvenFooter ( $ string [ 'value' ] ) ; } } }
192	public function send ( ) { if ( $ this -> isSent ) { return ; } $ this -> trigger ( self :: EVENT_BEFORE_SEND ) ; $ this -> prepare ( ) ; $ this -> trigger ( self :: EVENT_AFTER_PREPARE ) ; $ this -> sendHeaders ( ) ; $ this -> sendContent ( ) ; $ this -> trigger ( self :: EVENT_AFTER_SEND ) ; $ this -> isSent = true ; }
1614	private function sendCommandInternal ( $ command , $ params ) { $ written = @ fwrite ( $ this -> _socket , $ command ) ; if ( $ written === false ) { throw new SocketException ( "Failed to write to socket.\nRedis command was: " . $ command ) ; } if ( $ written !== ( $ len = mb_strlen ( $ command , '8bit' ) ) ) { throw new SocketException ( "Failed to write to socket. $written of $len bytes written.\nRedis command was: " . $ command ) ; } return $ this -> parseResponse ( implode ( ' ' , $ params ) ) ; }
7368	protected function checkShipmentIntegrity ( SaleItemInterface $ item , SaleItem $ constraint ) { $ sale = $ item -> getSale ( ) ; if ( ! $ sale instanceof Shipment \ ShipmentSubjectInterface ) { return ; } if ( empty ( $ sale -> getShipments ( ) -> toArray ( ) ) ) { return ; } $ min = $ this -> shipmentCalculator -> calculateShippedQuantity ( $ item ) ; if ( 1 === bccomp ( $ min , 0 , 3 ) && 1 === bccomp ( $ min , $ item -> getTotalQuantity ( ) , 3 ) ) { $ this -> context -> buildViolation ( $ constraint -> quantity_is_lower_than_shipped , [ '%min%' => $ min , ] ) -> setInvalidValue ( $ item -> getQuantity ( ) ) -> atPath ( 'quantity' ) -> addViolation ( ) ; throw new ValidationFailedException ( ) ; } }
12811	private static function getForeignKeysNames ( string $ table ) : array { if ( self :: $ foreignKeysCache === null || ! array_key_exists ( $ table , self :: $ foreignKeysCache ) ) self :: getForeignKeys ( $ table ) ; return array_keys ( self :: $ foreignKeysCache [ $ table ] ) ; }
3386	public function authenticate ( $ identity , $ credential ) { $ adapter = $ this -> auth -> getAdapter ( ) ; $ adapter -> setIdentity ( $ identity ) ; $ adapter -> setCredential ( $ credential ) ; return $ this -> auth -> authenticate ( ) ; }
6173	public function read ( $ path , $ file ) { return $ this -> driver -> read ( $ this -> root . $ path , $ file ) ; }
6854	private function findPaymentTokens ( PaymentInterface $ payment ) { $ identity = $ this -> getPaymentIdentity ( $ payment ) ; $ tokens = $ this -> payum -> getTokenStorage ( ) -> findBy ( [ 'details' => $ identity , ] ) ; return $ tokens ; }
12415	public static function init ( $ options = array ( ) ) { Flight :: map ( "render" , function ( $ template , $ data , $ toVar = false ) { Flight :: view ( ) -> render ( $ template , $ data , $ toVar ) ; } ) ; Flight :: register ( 'view' , get_called_class ( ) , $ options ) ; }
4789	function update ( array $ data ) { if ( $ this -> notORM -> freeze ) { return false ; } if ( ! $ data ) { return 0 ; } $ values = array ( ) ; $ parameters = array ( ) ; $ quoteChar = $ this -> getQuoteChar ( ) ; foreach ( $ data as $ key => $ val ) { $ values [ ] = "{$quoteChar}{$key}{$quoteChar} = " . $ this -> quote ( $ val ) ; if ( $ val instanceof NotORM_Literal && $ val -> parameters ) { $ parameters = array_merge ( $ parameters , $ val -> parameters ) ; } } if ( $ this -> parameters ) { $ parameters = array_merge ( $ parameters , $ this -> parameters ) ; } $ return = $ this -> query ( "UPDATE" . $ this -> topString ( $ this -> limit ) . " $this->table SET " . implode ( ", " , $ values ) . $ this -> whereString ( ) , $ parameters ) ; if ( ! $ return ) { return false ; } return $ return -> rowCount ( ) ; }
21	private function revert ( $ level ) { while ( ! $ this -> decisions -> isEmpty ( ) ) { $ literal = $ this -> decisions -> lastLiteral ( ) ; if ( $ this -> decisions -> undecided ( $ literal ) ) { break ; } $ decisionLevel = $ this -> decisions -> decisionLevel ( $ literal ) ; if ( $ decisionLevel <= $ level ) { break ; } $ this -> decisions -> revertLast ( ) ; $ this -> propagateIndex = count ( $ this -> decisions ) ; } while ( ! empty ( $ this -> branches ) && $ this -> branches [ count ( $ this -> branches ) - 1 ] [ self :: BRANCH_LEVEL ] >= $ level ) { array_pop ( $ this -> branches ) ; } }
9747	public function setTimeZone ( $ timezone ) { if ( ! $ timezone ) { return $ this ; } try { Carbon :: now ( $ timezone ) ; } catch ( \ Exception $ e ) { $ this -> invalidArguments ( '10004' , sprintf ( 'Invalid timezone set "%s"' , $ timezone ) ) ; } return $ this -> setParameter ( 'timezone' , $ timezone ) ; }
6459	public function fillInWithValueOfFieldOfCurrentUser ( $ field , $ user_field ) { if ( ! empty ( $ this -> user ) && ! $ this -> user -> uid ) { throw new \ Exception ( 'Anonymous user have no fields' ) ; } $ entity = new EntityDrupalWrapper ( 'user' ) ; $ wrapper = $ entity -> wrapper ( $ this -> user -> uid ) ; $ user_field = $ entity -> getFieldNameByLocator ( $ user_field ) ; if ( empty ( $ wrapper -> { $ user_field } ) ) { throw new \ InvalidArgumentException ( sprintf ( 'User entity has no "%s" field.' , $ user_field ) ) ; } $ value = $ wrapper -> { $ user_field } -> value ( ) ; if ( empty ( $ value ) ) { throw new \ UnexpectedValueException ( 'The value of "%s" field is empty.' , $ user_field ) ; } $ this -> fillField ( $ field , $ value ) ; }
9915	public function render ( $ action = null , $ layout = null ) { $ this -> viewPath .= DS . 'Spreadsheet' ; $ content = parent :: render ( $ action , false ) ; if ( $ this -> response -> type ( ) == 'text/html' ) { return $ content ; } ob_start ( ) ; $ writer = IOFactory :: createWriter ( $ this -> Spreadsheet , CAKE_SPREADSHEET_PHPSPREADSHEET_WRITER ) ; $ writer -> setPreCalculateFormulas ( false ) ; $ writer -> save ( 'php://output' ) ; $ content = ob_get_clean ( ) ; $ this -> Blocks -> set ( 'content' , $ content ) ; $ fileName = $ this -> getFileName ( ) ; $ fileName .= '.' . CAKE_SPREADSHEET_FILE_EXTENSION ; $ this -> response -> download ( $ fileName ) ; return $ this -> Blocks -> get ( 'content' ) ; }
8632	public function setReportRequestInfoList ( $ reportRequestInfo ) { if ( ! $ this -> _isNumericArray ( $ reportRequestInfo ) ) { $ reportRequestInfo = array ( $ reportRequestInfo ) ; } $ this -> fields [ 'ReportRequestInfo' ] [ 'FieldValue' ] = $ reportRequestInfo ; return $ this ; }
3920	private function addFileModels ( $ files , $ skipPaths = array ( ) ) { $ baseLanguage = $ this -> getBaseLanguage ( ) ; $ fallbackLanguage = $ this -> getFallbackLanguage ( ) ; foreach ( $ files as $ file ) { if ( 'folder' === $ file -> type && ! in_array ( $ file -> path , $ skipPaths ) ) { $ this -> pendingPaths [ ] = $ file -> path . '/' ; continue ; } if ( is_file ( TL_ROOT . DIRECTORY_SEPARATOR . $ file -> path ) && in_array ( strtolower ( pathinfo ( $ file -> path , PATHINFO_EXTENSION ) ) , $ this -> acceptedExtensions ) ) { $ path = $ file -> path ; $ this -> foundFiles [ ] = $ path ; $ this -> uuidMap [ $ file -> uuid ] = $ path ; $ meta = StringUtil :: deserialize ( $ file -> meta , true ) ; if ( isset ( $ meta [ $ baseLanguage ] ) ) { $ this -> metaInformation [ dirname ( $ path ) ] [ basename ( $ path ) ] = $ meta [ $ baseLanguage ] ; } elseif ( isset ( $ meta [ $ fallbackLanguage ] ) ) { $ this -> metaInformation [ dirname ( $ path ) ] [ basename ( $ path ) ] = $ meta [ $ fallbackLanguage ] ; } } } }
3764	private function getVisibleCondition ( $ property ) { $ condition = $ property -> getVisibleCondition ( ) ; if ( $ condition instanceof PropertyConditionChain ) { return $ condition ; } $ conditionChain = new PropertyConditionChain ( ) ; $ property -> setVisibleCondition ( $ conditionChain ) ; if ( $ condition ) { $ conditionChain -> addCondition ( $ condition ) ; } return $ conditionChain ; }
4100	public function setType ( $ type ) { if ( is_array ( $ type ) ) $ type = implode ( "," , array_filter ( $ type ) ) ; $ this -> type = $ type ; $ this -> transport -> setType ( $ type ) ; return $ this ; }
6841	public function getCache ( $ key ) { return isset ( $ this -> caches [ $ key ] ) ? $ this -> caches [ $ key ] : null ; }
1578	public static function create ( array $ data ) : self { if ( ! isset ( $ data [ 'type' ] ) ) { throw new \ InvalidArgumentException ( 'Expecting a resource type.' ) ; } return new self ( $ data [ 'type' ] , $ data [ 'id' ] ?? null , $ data [ 'attributes' ] ?? [ ] , $ data [ 'relationships' ] ?? [ ] , $ data [ 'meta' ] ?? [ ] , $ data [ 'links' ] ?? [ ] ) ; }
6344	public static function from ( Traversable $ traversable ) : Iterator { Preconditions :: checkArgument ( $ traversable instanceof Iterator || $ traversable instanceof IteratorAggregate ) ; return $ traversable instanceof Iterator ? $ traversable : Iterators :: from ( $ traversable -> getIterator ( ) ) ; }
8093	public function get ( $ keyPath ) { $ stops = explode ( '.' , $ keyPath ) ; $ value = $ this ; foreach ( $ stops as $ key ) { if ( $ value instanceof Collection ) { $ value = $ value -> $ key ; } else { $ value = null ; break ; } } return $ value ; }
12076	public function childStore ( $ idParent , FilterRequest $ filters , $ relation ) { $ idParent = $ this -> getRealId ( $ idParent ) ; $ resource = $ this -> repository -> storeChild ( $ idParent , $ relation , $ filters -> all ( ) ) ; if ( ! $ resource ) { } return $ this -> success ( $ resource ) ; }
1717	public function canEditFieldsOf ( $ table ) { if ( $ this -> isAdmin ) { return true ; } return \ count ( preg_grep ( '/^' . preg_quote ( $ table , '/' ) . '::/' , $ this -> alexf ) ) > 0 ; }
3991	public function acceptsAnotherChild ( ModelInterface $ model , ModelCollector $ collector ) { $ conditionType = $ model -> getProperty ( 'type' ) ; if ( ! $ this -> conditionFactory -> supportsNesting ( $ conditionType ) ) { return false ; } if ( - 1 === ( $ max = $ this -> conditionFactory -> maxChildren ( $ conditionType ) ) ) { return true ; } return \ count ( $ collector -> collectDirectChildrenOf ( $ model ) ) < $ max ; }
4333	private static function buildAttribBoolVal ( $ key , $ value = true ) { if ( $ key == 'autocomplete' ) { $ value = $ value ? 'on' : 'off' ; } elseif ( $ key == 'spellcheck' ) { $ value = $ value ? 'true' : 'false' ; } elseif ( $ key == 'translate' ) { $ value = $ value ? 'yes' : 'no' ; } elseif ( $ value ) { $ value = $ key ; } else { $ value = null ; } return $ value ; }
9346	public function getCol ( $ int = 0 ) { if ( $ int >= $ this -> size -> cols ) { throw new \ OutOfRangeException ( 'There is not column having this index.' ) ; } $ arr_out = array ( ) ; foreach ( $ this -> arr as $ row ) { $ arr_out [ ] = $ row [ $ int ] ; } return $ arr_out ; }
2412	protected function addTableTlTheme ( \ DOMDocument $ xml , \ DOMNode $ tables , Result $ objTheme ) { $ table = $ xml -> createElement ( 'table' ) ; $ table -> setAttribute ( 'name' , 'tl_theme' ) ; $ table = $ tables -> appendChild ( $ table ) ; $ this -> loadDataContainer ( 'tl_theme' ) ; $ objDcaExtractor = DcaExtractor :: getInstance ( 'tl_theme' ) ; $ arrOrder = $ objDcaExtractor -> getOrderFields ( ) ; $ this -> addDataRow ( $ xml , $ table , $ objTheme -> row ( ) , $ arrOrder ) ; }
11692	private function buildParsedRequests ( ApiParseResult $ parseResult ) : array { $ requests = [ ] ; foreach ( $ parseResult -> getApi ( ) -> getResourceGroups ( ) as $ apiResourceGroup ) { foreach ( $ apiResourceGroup -> getResources ( ) as $ apiResource ) { foreach ( $ apiResource -> getTransitions ( ) as $ apiStateTransition ) { foreach ( $ apiStateTransition -> getHttpTransactions ( ) as $ apiHttpTransaction ) { $ this -> processApiHttpTransactions ( $ apiHttpTransaction , $ apiResourceGroup , $ apiResource , $ apiStateTransition , $ requests ) ; } } } } return $ requests ; }
3055	public function getLastCatItemOutput ( ) { $ sessionId = $ this -> getTestSession ( ) -> getSessionId ( ) ; $ itemOutput = $ this -> getServiceManager ( ) -> get ( ExtendedStateService :: SERVICE_ID ) -> getCatValue ( $ sessionId , $ this -> getCatSection ( ) -> getSectionId ( ) , 'cat-item-output' ) ; $ output = [ ] ; if ( ! is_null ( $ itemOutput ) ) { $ rawData = json_decode ( $ itemOutput , true ) ; foreach ( $ rawData as $ result ) { $ itemResult = ItemResult :: restore ( $ result ) ; $ output [ $ itemResult -> getItemRefId ( ) ] = $ itemResult ; } } return $ output ; }
9723	private function getTemporaryFolder ( ) { $ tempFolder = sys_get_temp_dir ( ) . '/phpspreadsheet' ; if ( ! is_dir ( $ tempFolder ) ) { if ( ! mkdir ( $ tempFolder ) && ! is_dir ( $ tempFolder ) ) { throw new \ RuntimeException ( sprintf ( 'Directory "%s" was not created' , $ tempFolder ) ) ; } } return $ tempFolder ; }
3241	protected function createSeeder ( $ data ) { $ seederFile = base_path ( '/database/seeds' ) . '/LaravelShopSeeder.php' ; $ output = $ this -> laravel -> view -> make ( 'laravel-shop::generators.seeder' ) -> with ( $ data ) -> render ( ) ; if ( ! file_exists ( $ seederFile ) && $ fs = fopen ( $ seederFile , 'x' ) ) { fwrite ( $ fs , $ output ) ; fclose ( $ fs ) ; return true ; } return false ; }
8937	public function readChangeset ( $ id ) { $ base = 'changeset/' . $ id ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ xmlString = $ this -> sendRequest ( $ path ) ; return $ xmlString -> changeset ; }
9748	public function checkOrderStatus ( $ orderId ) { $ function = 'CheckOrderStatus' ; $ parameters = [ 'entityCode' => $ this -> connector -> getEntityCode ( ) , 'pedidoIDCliente' => $ orderId ] ; $ response = $ this -> connector -> doRequest ( $ function , $ parameters ) ; $ packageStatusResponse = new PackageStatus ( $ response -> CheckOrderStatusResult ) ; $ this -> connector -> log ( 'Integration@checkOrderStatus' , compact ( 'packageStatusResponse' ) ) ; return $ packageStatusResponse ; }
9574	protected function registerProvider ( ProviderInterface $ provider ) { if ( $ provider instanceof AbstractProvider ) { $ provider -> setApplication ( $ this ) ; } $ provider -> register ( ) ; if ( $ this -> console && $ provider instanceof ConsoleProviderInterface ) { $ provider -> registerConsole ( $ this -> console ) ; } }
5937	public function setFunctionalities ( array $ functionalities ) { $ this -> functionalities = [ ] ; foreach ( $ functionalities as $ item ) { $ this -> addFunctionality ( $ item ) ; } return $ this ; }
2946	public function setRolesById ( $ roles ) { $ roles = is_array ( $ roles ) ? $ roles : [ $ roles ] ; return $ this -> roles ( ) -> sync ( $ roles ) ; }
7370	public function setTranslations ( array $ translations ) { foreach ( $ translations as $ key => $ string ) { if ( ! ( is_string ( $ string ) && ! empty ( $ string ) ) ) { throw new \ InvalidArgumentException ( "Invalid translation for key '$key'." ) ; } } $ this -> translations = array_replace ( $ this -> getDefaultTranslations ( ) , $ translations ) ; }
8267	public function close ( ) { if ( ! $ this -> isOpened ( ) ) { return ; } $ this -> unlock ( ) ; if ( $ this -> handle && ! fclose ( $ this -> handle ) ) { throw new \ RuntimeException ( "Could not close file " . $ this -> filePath ) ; } }
2408	public function flushAllData ( ) { @ trigger_error ( 'Using Template::flushAllData() has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; if ( \ function_exists ( 'fastcgi_finish_request' ) ) { fastcgi_finish_request ( ) ; } elseif ( PHP_SAPI !== 'cli' ) { $ status = ob_get_status ( true ) ; $ level = \ count ( $ status ) ; while ( $ level -- > 0 && ( ! empty ( $ status [ $ level ] [ 'del' ] ) || ( isset ( $ status [ $ level ] [ 'flags' ] ) && ( $ status [ $ level ] [ 'flags' ] & PHP_OUTPUT_HANDLER_REMOVABLE ) && ( $ status [ $ level ] [ 'flags' ] & PHP_OUTPUT_HANDLER_FLUSHABLE ) ) ) ) { ob_end_flush ( ) ; } flush ( ) ; } }
556	public function setComponents ( $ components ) { foreach ( $ components as $ id => $ component ) { $ this -> set ( $ id , $ component ) ; } }
5981	protected function buildBasepath ( $ url ) { if ( ! preg_match ( '#(\w+:)?//#' , $ url ) ) { $ url = '//' . $ url ; } $ urlParts = parse_url ( $ url ) ; if ( false === $ urlParts ) { throw new \ InvalidArgumentException ( 'Could not parse QBank URL.' ) ; } if ( empty ( $ urlParts [ 'scheme' ] ) ) { $ urlParts [ 'scheme' ] = 'http' ; } if ( ( empty ( $ urlParts [ 'path' ] ) || '/' == $ urlParts [ 'path' ] ) && 'qbank.se' == substr ( $ urlParts [ 'host' ] , - strlen ( 'qbank.se' ) ) ) { $ urlParts [ 'path' ] = '/api/' ; } if ( '/' != substr ( $ urlParts [ 'path' ] , - 1 ) ) { $ urlParts [ 'path' ] .= '/' ; } return $ urlParts [ 'scheme' ] . '://' . $ urlParts [ 'host' ] . ( ! empty ( $ urlParts [ 'port' ] ) ? ':' . $ urlParts [ 'port' ] : '' ) . $ urlParts [ 'path' ] ; }
5974	public function filters ( ) { if ( ! $ this -> filters instanceof FiltersController ) { $ this -> filters = new FiltersController ( $ this -> getClient ( ) , $ this -> cachePolicy , $ this -> cache ) ; $ this -> filters -> setLogger ( $ this -> logger ) ; } return $ this -> filters ; }
7117	protected function getFindBySubjectQuery ( ) { if ( null !== $ this -> findBySubjectQuery ) { return $ this -> findBySubjectQuery ; } $ qb = $ this -> createFindBySubjectQueryBuilder ( ) ; return $ this -> findBySubjectQuery = $ qb -> getQuery ( ) ; }
11991	private function validateSlug ( string $ sku ) { if ( strlen ( $ sku ) == 0 ) { throw new SlugException ( "A Slug cannot be empty" ) ; } $ containsWhitespace = preg_match ( $ this -> whiteSpacePattern , $ sku ) == 1 ; if ( $ containsWhitespace ) { throw new SlugException ( sprintf ( "A Slug cannot contain white space characters: \"%s\"" , $ sku ) ) ; } $ containsInvalidCharacters = preg_match ( $ this -> invalidCharactersPattern , $ sku ) == 1 ; if ( $ containsInvalidCharacters ) { throw new SlugException ( sprintf ( "The Slug \"%s\" contains invalid characters. A Slug can only contain the following characters: a-z, 0-9 and -" , $ sku ) ) ; } if ( strlen ( $ sku ) < $ this -> minLength ) { throw new SlugException ( sprintf ( "The given Slug \"%s\" is too short. The minimum length for a Slug is: %s" , $ sku , $ this -> minLength ) ) ; } if ( strlen ( $ sku ) > $ this -> maxLength ) { throw new SlugException ( sprintf ( "The given Slug \"%s\" is too long (%s character). The maximum length for a Slug is: %s" , strlen ( $ sku ) , $ sku , $ this -> maxLength ) ) ; } }
6527	public static function resolveCurie ( $ curie ) : string { $ key = ( string ) $ curie ; if ( isset ( self :: $ curies [ $ key ] ) ) { return self :: $ classes [ self :: $ curies [ $ key ] ] ; } throw new NoMessageForCurie ( SchemaCurie :: fromString ( $ key ) ) ; }
6276	protected function readInt31 ( $ pos = 0 ) { $ uint31 = $ this -> readInt32 ( $ pos ) ; if ( $ uint31 > 0x7fffffff ) { throw new Exception ( 'Error in CDB file "' . $ this -> fileName . '", integer too big.' ) ; } return $ uint31 ; }
4431	protected function writeSection ( $ text , $ style = 'bg=blue;fg=white' ) { $ this -> output -> writeln ( array ( '' , $ this -> getHelper ( 'formatter' ) -> formatBlock ( $ text , $ style , true ) , '' , ) ) ; }
9807	private function readBlipJPEG ( ) { $ recInstance = ( 0xFFF0 & Xls :: getUInt2d ( $ this -> data , $ this -> pos ) ) >> 4 ; $ length = Xls :: getInt4d ( $ this -> data , $ this -> pos + 4 ) ; $ recordData = substr ( $ this -> data , $ this -> pos + 8 , $ length ) ; $ this -> pos += 8 + $ length ; $ pos = 0 ; $ rgbUid1 = substr ( $ recordData , 0 , 16 ) ; $ pos += 16 ; if ( in_array ( $ recInstance , [ 0x046B , 0x06E3 ] ) ) { $ rgbUid2 = substr ( $ recordData , 16 , 16 ) ; $ pos += 16 ; } $ tag = ord ( $ recordData [ $ pos ] ) ; $ pos += 1 ; $ data = substr ( $ recordData , $ pos ) ; $ blip = new Blip ( ) ; $ blip -> setData ( $ data ) ; $ this -> object -> setBlip ( $ blip ) ; }
8418	public static function registerDatabase ( string $ alias ) { if ( isset ( self :: $ databases [ $ alias ] ) === false ) { self :: $ databases [ $ alias ] = new static ( $ alias ) ; } }
7513	function next_no_whitespace ( ) { $ this -> token_start = null ; while ( ++ $ this -> pos < $ this -> size ) { if ( ! isset ( $ this -> whitespace [ $ this -> doc [ $ this -> pos ] ] ) ) { if ( isset ( $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ) { if ( is_string ( $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ) { return ( $ this -> token = $ this -> { $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] } ( ) ) ; } else { return ( $ this -> token = $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ; } } else { return ( $ this -> token = self :: TOK_UNKNOWN ) ; } } else { $ this -> parse_linebreak ( ) ; } } return ( $ this -> token = self :: TOK_NULL ) ; }
34	protected function jobToText ( $ job ) { $ packageName = $ job [ 'packageName' ] ; $ constraint = $ job [ 'constraint' ] ; switch ( $ job [ 'cmd' ] ) { case 'install' : $ packages = $ this -> pool -> whatProvides ( $ packageName , $ constraint ) ; if ( ! $ packages ) { return 'No package found to satisfy install request for ' . $ packageName . $ this -> constraintToText ( $ constraint ) ; } return 'Installation request for ' . $ packageName . $ this -> constraintToText ( $ constraint ) . ' -> satisfiable by ' . $ this -> getPackageList ( $ packages ) . '.' ; case 'update' : return 'Update request for ' . $ packageName . $ this -> constraintToText ( $ constraint ) . '.' ; case 'remove' : return 'Removal request for ' . $ packageName . $ this -> constraintToText ( $ constraint ) . '' ; } if ( isset ( $ constraint ) ) { $ packages = $ this -> pool -> whatProvides ( $ packageName , $ constraint ) ; } else { $ packages = array ( ) ; } return 'Job(cmd=' . $ job [ 'cmd' ] . ', target=' . $ packageName . ', packages=[' . $ this -> getPackageList ( $ packages ) . '])' ; }
10536	public function extractHeaders ( ) { $ headers = [ ] ; $ requestHeaders = array_keys ( $ this -> cors ) ; foreach ( $ requestHeaders as $ headerField ) { $ serverField = $ this -> headerizeToPhp ( $ headerField ) ; $ headerData = isset ( $ _SERVER [ $ serverField ] ) ? $ _SERVER [ $ serverField ] : null ; if ( $ headerData !== null ) { $ headers [ $ headerField ] = $ headerData ; } } return $ headers ; }
8425	public function getAllActiveQuery ( Production $ production ) : Query { $ qb = $ this -> createQueryBuilder ( 'p' ) ; return $ qb -> join ( 'p.groups' , 'g' ) -> andWhere ( $ qb -> expr ( ) -> eq ( 'g' , ':group' ) ) -> andWhere ( $ qb -> expr ( ) -> eq ( 'p.active' , ':active' ) ) -> andWhere ( $ qb -> expr ( ) -> isNull ( 'p.parent' ) ) -> andWhere ( $ qb -> expr ( ) -> orX ( $ qb -> expr ( ) -> isNull ( 'p.expiry' ) , $ qb -> expr ( ) -> gt ( 'p.expiry' , ':now' ) ) ) -> setParameter ( 'group' , $ production ) -> setParameter ( 'active' , true ) -> setParameter ( 'now' , new \ DateTime ( ) ) -> orderBy ( 'p.pinned' , 'DESC' ) -> addOrderBy ( 'p.created' , 'DESC' ) -> getQuery ( ) ; }
8501	public function setGetMatchingProductForIdResult ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'GetMatchingProductForIdResult' ] [ 'FieldValue' ] = $ value ; return $ this ; }
1926	public function countColors ( $ max = null ) { if ( ! imageistruecolor ( $ this -> gdResource ) ) { return imagecolorstotal ( $ this -> gdResource ) ; } $ colors = array ( ) ; $ width = imagesx ( $ this -> gdResource ) ; $ height = imagesy ( $ this -> gdResource ) ; for ( $ x = 0 ; $ x < $ width ; $ x ++ ) { for ( $ y = 0 ; $ y < $ height ; $ y ++ ) { $ colors [ imagecolorat ( $ this -> gdResource , $ x , $ y ) ] = true ; if ( $ max !== null && \ count ( $ colors ) > $ max ) { break 2 ; } } } return \ count ( $ colors ) ; }
5965	public function channelGroupPermList ( $ cgid , $ permsid = false ) { return $ this -> execute ( "channelgrouppermlist" , array ( "cgid" => $ cgid , $ permsid ? "-permsid" : null ) ) -> toAssocArray ( $ permsid ? "permsid" : "permid" ) ; }
5786	private function databaseRecordNotFound ( Response $ response , $ primaryKey , TableMapper $ tableMapper , string $ routeAction , ? string $ title = null ) { if ( $ routeAction != 'update' && $ routeAction != 'delete' ) { throw new \ Exception ( "routeAction $routeAction must be update or delete" ) ; } $ this -> events -> insertWarning ( EVENT_QUERY_NO_RESULTS , [ $ tableMapper -> getPrimaryKeyColumnName ( ) => $ primaryKey , 'table' => $ tableMapper -> getTableName ( ) ] ) ; $ noticeTitle = ( $ title != null ) ? $ title : 'Record' ; SlimPostgres :: setAdminNotice ( "$noticeTitle $primaryKey Not Found" , 'failure' ) ; return $ response -> withRedirect ( $ this -> router -> pathFor ( SlimPostgres :: getRouteName ( true , $ this -> routePrefix , 'index' ) ) ) ; }
11884	public function getModuleHandler ( ) { if ( is_null ( $ this -> _moduleHandler ) ) { $ stem = $ this -> field ; if ( ! isset ( self :: $ _moduleHandlers [ $ stem ] ) ) { self :: $ _moduleHandlers [ $ stem ] = [ ] ; } $ n = count ( self :: $ _moduleHandlers [ $ stem ] ) ; $ this -> _moduleHandler = $ this -> field . ':_' . $ n ; self :: $ _moduleHandlers [ $ stem ] [ ] = $ this -> _moduleHandler ; } return $ this -> _moduleHandler ; }
2912	public function formatNumber ( $ number , $ precision = 2 ) { $ locale = Mage :: app ( ) -> getLocale ( ) -> getLocale ( ) ; return Zend_Locale_Format :: toNumber ( $ number , array ( 'locale' => $ locale , 'precision' => $ precision ) ) ; }
8453	protected function determineFilename ( $ originalFilename , array $ mediaFileInfo ) { if ( is_null ( $ originalFilename ) || ! isset ( $ originalFilename ) || is_file ( sys_get_temp_dir ( ) . '/' . $ originalFilename ) ) { $ uniqueFilename = tempnam ( sys_get_temp_dir ( ) , 'tg' ) ; rename ( $ uniqueFilename , $ uniqueFilename . '.' . $ mediaFileInfo [ 'fileextension' ] ) ; $ mediaFileInfo [ 'filepath' ] = $ uniqueFilename . '.' . $ mediaFileInfo [ 'fileextension' ] ; } else { $ mediaFileInfo [ 'filepath' ] = sys_get_temp_dir ( ) . '/' . $ originalFilename ; } return $ mediaFileInfo ; }
10058	public function save ( CacheItemInterface $ item ) { $ item -> setIsHit ( true ) ; $ this -> data [ $ item -> getKey ( ) ] = $ item ; return true ; }
8709	protected function qualifyColumns ( $ columns ) { foreach ( $ columns as & $ column ) { if ( ! in_array ( $ column , $ this -> model -> translatableAttributes ( ) ) ) { continue ; } $ primary = $ this -> qualifyTranslationColumn ( $ column ) ; $ fallback = $ this -> qualifyTranslationColumn ( $ column , true ) ; if ( $ this -> model -> shouldFallback ( ) ) { $ column = new Expression ( $ this -> compileIfNull ( $ primary , $ fallback , $ column ) ) ; } else { $ column = $ primary ; } } return $ columns ; }
1511	public function getRelationshipUri ( string $ type , $ id , string $ field , array $ params = [ ] ) : string { return $ this -> url ( [ $ type , $ id , 'relationships' , $ field ] , $ params ) ; }
6774	protected function didDeliveryCountryChanged ( SaleInterface $ sale ) { $ saleCs = $ this -> persistenceHelper -> getChangeSet ( $ sale ) ; $ oldCountry = $ newCountry = null ; $ oldSameAddress = isset ( $ saleCs [ 'sameAddress' ] ) ? $ saleCs [ 'sameAddress' ] [ 0 ] : $ sale -> isSameAddress ( ) ; if ( $ oldSameAddress ) { $ oldAddress = isset ( $ saleCs [ 'invoiceAddress' ] ) ? $ saleCs [ 'invoiceAddress' ] [ 0 ] : $ sale -> getInvoiceAddress ( ) ; } else { $ oldAddress = isset ( $ saleCs [ 'deliveryAddress' ] ) ? $ saleCs [ 'deliveryAddress' ] [ 0 ] : $ sale -> getDeliveryAddress ( ) ; } if ( null !== $ oldAddress ) { $ oldAddressCs = $ this -> persistenceHelper -> getChangeSet ( $ oldAddress ) ; $ oldCountry = isset ( $ oldAddressCs [ 'country' ] ) ? $ oldAddressCs [ 'country' ] [ 0 ] : $ oldAddress -> getCountry ( ) ; } $ newAddress = $ sale -> isSameAddress ( ) ? $ sale -> getInvoiceAddress ( ) : $ sale -> getDeliveryAddress ( ) ; if ( null !== $ newAddress ) { $ newCountry = $ newAddress -> getCountry ( ) ; } if ( $ oldCountry !== $ newCountry ) { return true ; } return false ; }
10181	public function add ( $ pCoord , Cell $ cell ) { if ( $ pCoord !== $ this -> currentCoordinate ) { $ this -> storeCurrentCell ( ) ; } $ this -> index [ $ pCoord ] = true ; $ this -> currentCoordinate = $ pCoord ; $ this -> currentCell = $ cell ; $ this -> currentCellIsDirty = true ; return $ cell ; }
11653	protected function _initDbResource ( ) { $ registry = $ this -> getPluginResource ( 'db' ) ; if ( ! $ registry ) { return ; } $ options = $ registry -> getOptions ( ) ; if ( array_key_exists ( 'dsn' , $ options ) && '' !== $ options [ 'dsn' ] ) { $ options [ 'params' ] = array_replace ( $ options [ 'params' ] , $ this -> _parseDsn ( $ options [ 'dsn' ] ) ) ; } $ registry -> setOptions ( $ options ) ; }
476	public function createTable ( $ table , $ columns , $ options = null ) { $ time = $ this -> beginCommand ( "create table $table" ) ; $ this -> db -> createCommand ( ) -> createTable ( $ table , $ columns , $ options ) -> execute ( ) ; foreach ( $ columns as $ column => $ type ) { if ( $ type instanceof ColumnSchemaBuilder && $ type -> comment !== null ) { $ this -> db -> createCommand ( ) -> addCommentOnColumn ( $ table , $ column , $ type -> comment ) -> execute ( ) ; } } $ this -> endCommand ( $ time ) ; }
9765	function exist ( ) : self { if ( $ this -> hasFlag ( 'directory' ) ) $ constraint = directoryExists ( ) ; else if ( $ this -> hasFlag ( 'file' ) ) $ constraint = fileExists ( ) ; else throw new \ BadMethodCallException ( 'This assertion is not a file or directory one.' ) ; return $ this -> expect ( $ this -> target , $ constraint ) ; }
11559	public function SetWeekWords ( $ weekWords , $ lang = '' ) { if ( ! $ lang ) $ lang = $ this -> lang ; if ( is_array ( $ weekWords ) ) { $ this -> weekWords [ $ lang ] = $ weekWords ; } else { $ this -> weekWords [ $ lang ] = explode ( ',' , ( string ) $ weekWords ) ; } return $ this ; }
1460	protected function orderDesc ( ) { $ this -> query -> orderByDesc ( $ this -> column ) ; if ( $ this -> isNotPagingOnKey ( ) ) { $ this -> query -> orderByDesc ( $ this -> key ) ; } return $ this ; }
9105	protected function parse_time ( ) { if ( ! empty ( $ this -> args [ 'time' ] ) ) { $ date_query = new \ WP_Date_Query ( $ this -> args [ 'time' ] , 'q.time' ) ; return new Where_Date ( $ date_query ) ; } else { return null ; } }
7808	public function setCurlNumRetries ( $ retries ) { if ( ! is_numeric ( $ retries ) || $ retries < 0 ) { throw new \ InvalidArgumentException ( 'Retries value must be numeric and a non-negative number.' ) ; } $ this -> curlNumRetries = $ retries ; return $ this ; }
2031	public static function findParentsById ( $ intId ) { $ arrModels = array ( ) ; while ( $ intId > 0 && ( $ objPage = static :: findByPk ( $ intId ) ) !== null ) { $ intId = $ objPage -> pid ; $ arrModels [ ] = $ objPage ; } if ( empty ( $ arrModels ) ) { return null ; } return static :: createCollection ( $ arrModels , 'tl_page' ) ; }
4091	public function createPayload ( ) { $ payloads = array ( ) ; foreach ( $ this -> operations as $ operation ) { foreach ( $ operation as $ partial ) { $ payloads [ ] = json_encode ( $ partial ) ; } } return join ( "\n" , $ payloads ) . "\n" ; }
335	protected function createColumn ( $ column ) { $ c = $ this -> createColumnSchema ( ) ; $ c -> name = $ column [ 'COLUMN_NAME' ] ; $ c -> allowNull = $ column [ 'NULLABLE' ] === 'Y' ; $ c -> comment = $ column [ 'COLUMN_COMMENT' ] === null ? '' : $ column [ 'COLUMN_COMMENT' ] ; $ c -> isPrimaryKey = false ; $ this -> extractColumnType ( $ c , $ column [ 'DATA_TYPE' ] , $ column [ 'DATA_PRECISION' ] , $ column [ 'DATA_SCALE' ] , $ column [ 'DATA_LENGTH' ] ) ; $ this -> extractColumnSize ( $ c , $ column [ 'DATA_TYPE' ] , $ column [ 'DATA_PRECISION' ] , $ column [ 'DATA_SCALE' ] , $ column [ 'DATA_LENGTH' ] ) ; $ c -> phpType = $ this -> getColumnPhpType ( $ c ) ; if ( ! $ c -> isPrimaryKey ) { if ( stripos ( $ column [ 'DATA_DEFAULT' ] , 'timestamp' ) !== false ) { $ c -> defaultValue = null ; } else { $ defaultValue = $ column [ 'DATA_DEFAULT' ] ; if ( $ c -> type === 'timestamp' && $ defaultValue === 'CURRENT_TIMESTAMP' ) { $ c -> defaultValue = new Expression ( 'CURRENT_TIMESTAMP' ) ; } else { if ( $ defaultValue !== null ) { if ( ( $ len = strlen ( $ defaultValue ) ) > 2 && $ defaultValue [ 0 ] === "'" && $ defaultValue [ $ len - 1 ] === "'" ) { $ defaultValue = substr ( $ column [ 'DATA_DEFAULT' ] , 1 , - 1 ) ; } else { $ defaultValue = trim ( $ defaultValue ) ; } } $ c -> defaultValue = $ c -> phpTypecast ( $ defaultValue ) ; } } } return $ c ; }
764	private function splitStatements ( $ sql , $ params ) { $ semicolonIndex = strpos ( $ sql , ';' ) ; if ( $ semicolonIndex === false || $ semicolonIndex === StringHelper :: byteLength ( $ sql ) - 1 ) { return false ; } $ tokenizer = new SqlTokenizer ( $ sql ) ; $ codeToken = $ tokenizer -> tokenize ( ) ; if ( count ( $ codeToken -> getChildren ( ) ) === 1 ) { return false ; } $ statements = [ ] ; foreach ( $ codeToken -> getChildren ( ) as $ statement ) { $ statements [ ] = [ $ statement -> getSql ( ) , $ this -> extractUsedParams ( $ statement , $ params ) ] ; } return $ statements ; }
1081	private function loc ( Token $ startToken ) { if ( empty ( $ this -> lexer -> options [ 'noLocation' ] ) ) { return new Location ( $ startToken , $ this -> lexer -> lastToken , $ this -> lexer -> source ) ; } return null ; }
8597	public function listMarketplaceParticipationsByNextToken ( $ request ) { if ( ! ( $ request instanceof MarketplaceWebServiceSellers_Model_ListMarketplaceParticipationsByNextTokenRequest ) ) { $ request = new MarketplaceWebServiceSellers_Model_ListMarketplaceParticipationsByNextTokenRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListMarketplaceParticipationsByNextToken' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = MarketplaceWebServiceSellers_Model_ListMarketplaceParticipationsByNextTokenResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
6005	public function addCategoryResponse ( $ item ) { if ( ! ( $ item instanceof CategoryResponse ) ) { if ( is_array ( $ item ) ) { try { $ item = new CategoryResponse ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate CategoryResponse. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "CategoryResponse"!' , E_USER_WARNING ) ; } } $ this -> categories [ ] = $ item ; return $ this ; }
1637	protected function setupQueue ( QueueManager $ queue ) { $ queue -> looping ( function ( ) { $ this -> app -> bugsnag -> flush ( ) ; $ this -> app -> bugsnag -> clearBreadcrumbs ( ) ; $ this -> app -> make ( Tracker :: class ) -> clear ( ) ; } ) ; if ( ! class_exists ( JobProcessing :: class ) ) { return ; } $ queue -> before ( function ( JobProcessing $ event ) { $ this -> app -> bugsnag -> setFallbackType ( 'Queue' ) ; $ job = [ 'name' => $ event -> job -> getName ( ) , 'queue' => $ event -> job -> getQueue ( ) , 'attempts' => $ event -> job -> attempts ( ) , 'connection' => $ event -> connectionName , ] ; if ( method_exists ( $ event -> job , 'resolveName' ) ) { $ job [ 'resolved' ] = $ event -> job -> resolveName ( ) ; } $ this -> app -> make ( Tracker :: class ) -> set ( $ job ) ; } ) ; }
11905	public function getType ( ) { if ( is_null ( $ this -> _type ) ) { $ this -> _type = FieldTypeDetector :: detect ( $ this -> modelField ) ; } return $ this -> _type ; }
11192	public function exists ( $ uri = false , $ httpMethod = false ) { if ( $ uri && $ httpMethod ) { $ this -> routeProcess ( $ uri , $ httpMethod ) ; } if ( ! isset ( $ this -> controllerPath ) ) { return false ; } return true ; }
5384	public function setValue ( $ value ) { if ( $ value === false ) { return parent :: setValue ( $ value ) ; } if ( $ value != $ this -> getAttribute ( 'value' ) ) { return false ; } return parent :: setValue ( $ value ) ; }
12755	protected function parseResponse ( ) { if ( isset ( $ this -> response ) ) { list ( $ responseParts [ 'headersString' ] , $ responseParts [ 'body' ] ) = explode ( "\r\n\r\n" , $ this -> response , 2 ) ; $ responseParts [ 'body' ] = htmlspecialchars ( $ responseParts [ 'body' ] ) ; $ headers = explode ( "\r\n" , $ responseParts [ 'headersString' ] ) ; $ cookies = [ ] ; if ( preg_match_all ( '/Set-Cookie: (.*?)=(.*?)(\n|;)/i' , $ responseParts [ 'headersString' ] , $ matches ) ) { if ( ! empty ( $ matches ) ) { foreach ( $ matches [ 1 ] as $ key => $ value ) { $ cookies [ $ value ] = $ matches [ 2 ] [ $ key ] ; } $ responseParts [ 'cookies' ] = $ cookies ; } } unset ( $ responseParts [ 'headersString' ] ) ; $ first = true ; foreach ( $ headers as $ header ) { if ( $ first ) { list ( $ responseParts [ 'protocol' ] , $ responseParts [ 'statusCode' ] ) = explode ( ' ' , $ header , 2 ) ; $ first = false ; } else { $ tmp = ( explode ( ': ' , $ header ) ) ; if ( $ tmp [ 0 ] === 'Set-Cookie' ) { continue ; } else { $ responseParts [ 'headersArray' ] [ $ tmp [ 0 ] ] = $ tmp [ 1 ] ; } } } return $ responseParts ; } else { return null ; } }
8627	public function setGetCompetitivePricingForSKUResult ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'GetCompetitivePricingForSKUResult' ] [ 'FieldValue' ] = $ value ; return $ this ; }
3379	protected function getDefaultNamespace ( $ rootNamespace ) { $ controllersPath = \ Config :: get ( 'panel.controllers' ) ; if ( isset ( $ controllersPath ) && $ controllersPath != NULL ) { return $ controllersPath ; } else { return $ rootNamespace . '\Http\Controllers' ; } }
11996	static public function doctrine ( $ tableName , $ field , $ length = 16 ) { do { $ generate = self :: generate ( $ length ) ; } while ( self :: doctrineQuery ( $ tableName , $ field , $ generate ) ) ; return $ generate ; }
10826	public static function table ( array $ rows , array $ headers = [ ] ) { $ table = new Table ( ) ; $ table -> setRows ( $ rows ) ; if ( count ( $ headers ) > 0 ) { $ table -> setHeaders ( $ headers ) ; } $ output = $ table -> render ( ) ; self :: writeln ( $ output ) ; }
7051	private function addViolation ( $ value , Constraint $ constraint ) { if ( $ this -> context instanceof ExecutionContextInterface ) { $ this -> context -> buildViolation ( $ constraint -> getMessage ( ) ) -> setParameter ( '{{ type }}' , $ constraint -> getType ( ) ) -> setParameter ( '{{ value }}' , $ this -> formatValue ( $ value ) ) -> setCode ( PhoneNumber :: INVALID_PHONE_NUMBER_ERROR ) -> addViolation ( ) ; } else { $ this -> context -> addViolation ( $ constraint -> getMessage ( ) , array ( '{{ type }}' => $ constraint -> getType ( ) , '{{ value }}' => $ value ) ) ; } }
10389	public static function loadFile ( $ xmlFile ) { if ( ! is_file ( $ xmlFile ) || ! is_readable ( $ xmlFile ) ) { throw new NoSuchFileException ( $ xmlFile ) ; } return self :: parseXml ( $ xmlFile ) ; }
7592	protected function setFormClass ( FormInterface $ oForm , $ sFormLayout = self :: LAYOUT_HORIZONTAL ) { if ( is_string ( $ sFormLayout ) ) { $ sLayoutClass = 'form-' . $ sFormLayout ; if ( $ sFormClass = $ oForm -> getAttribute ( 'class' ) ) { if ( ! preg_match ( '/(\s|^)' . preg_quote ( $ sLayoutClass , '/' ) . '(\s|$)/' , $ sFormClass ) ) { $ oForm -> setAttribute ( 'class' , trim ( $ sFormClass . ' ' . $ sLayoutClass ) ) ; } } else { $ oForm -> setAttribute ( 'class' , $ sLayoutClass ) ; } } return $ this ; }
7340	public function sendAttachment ( Chat $ chat , User $ recipient , Attachment $ attachment ) : void { $ type = $ attachment -> getType ( ) ; $ request = null ; switch ( $ type ) { case Attachment :: TYPE_FILE : $ request = new SendDocument ( ) ; $ request -> document = new InputFile ( $ attachment -> getPath ( ) ) ; $ request -> caption = $ attachment -> getParameters ( ) -> get ( 'caption' ) ; break ; case Attachment :: TYPE_IMAGE : $ request = new SendPhoto ( ) ; $ request -> caption = $ attachment -> getParameters ( ) -> get ( 'caption' ) ; break ; case Attachment :: TYPE_AUDIO : $ request = new SendAudio ( ) ; $ request -> chat_id = $ chat -> getId ( ) ; $ request -> caption = $ attachment -> getParameters ( ) -> get ( 'caption' ) ; $ request -> duration = $ attachment -> getParameters ( ) -> get ( 'duration' ) ; $ request -> performer = $ attachment -> getParameters ( ) -> get ( 'performer' ) ; $ request -> title = $ attachment -> getParameters ( ) -> get ( 'title' ) ; break ; case Attachment :: TYPE_VIDEO : $ request = new SendVideo ( ) ; $ request -> duration = $ attachment -> getParameters ( ) -> get ( 'duration' ) ; $ request -> width = $ attachment -> getParameters ( ) -> get ( 'width' ) ; $ request -> height = $ attachment -> getParameters ( ) -> get ( 'height' ) ; $ request -> caption = $ attachment -> getParameters ( ) -> get ( 'caption' ) ; break ; } if ( $ request ) { $ request -> chat_id = $ chat -> getId ( ) ; $ request -> disable_notification = $ attachment -> getParameters ( ) -> get ( 'disable_notification' ) ; $ request -> reply_to_message_id = $ attachment -> getParameters ( ) -> get ( 'reply_to_message_id' ) ; $ request -> reply_markup = $ attachment -> getParameters ( ) -> get ( 'reply_markup' ) ; $ this -> client -> performApiRequest ( $ request ) ; $ this -> loop -> run ( ) ; } }
3642	public function only ( $ keys , bool $ trim = true , bool $ clean = true ) { $ values = [ ] ; foreach ( ( array ) $ keys as $ key ) { $ values [ $ key ] = $ this -> get ( $ key , null , $ trim , $ clean ) ; } return $ values ; }
8553	public function setDebtRecoveryEventList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'DebtRecoveryEventList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
10553	public static function findVirtualHost ( URL $ url , array $ sites ) { foreach ( $ sites as $ site ) { $ vhost = $ site -> match ( $ url ) ; if ( $ vhost !== null ) return $ vhost ; } return null ; }
5408	protected function isMatch ( $ cookie , $ host , $ path , $ name ) { if ( $ cookie -> getName ( ) != $ name ) { return false ; } if ( $ host && $ cookie -> getHost ( ) && ! $ cookie -> isValidHost ( $ host ) ) { return false ; } if ( ! $ cookie -> isValidPath ( $ path ) ) { return false ; } return true ; }
6844	public function callInClass ( $ class_name , $ action , $ params = array ( ) ) { $ ref = new ReflectionMethod ( $ class_name , $ action ) ; if ( ! $ ref -> isPublic ( ) && ! $ ref -> isStatic ( ) ) throw new InjectorException ( "$class_name->$action is not public or static" ) ; $ params_need = $ ref -> getParameters ( ) ; $ args = $ this -> apply ( $ params_need , $ params ) ; $ obj = $ this -> produce ( $ class_name , $ params ) ; return call_user_func_array ( [ $ obj , $ action ] , $ args ) ; }
1371	protected function make ( array $ data ) { $ validator = $ this -> validatorFactory -> make ( $ data , $ this -> getRules ( ) , $ this -> getMessages ( ) , $ this -> getAttributes ( ) ) ; $ this -> configureValidator ( $ validator ) ; return $ validator ; }
5558	protected function findForm ( $ method , $ attribute ) { if ( is_integer ( $ this -> focus ) ) { return $ this -> findFormInFrame ( $ this -> frames [ $ this -> focus ] , $ this -> focus , $ method , $ attribute ) ; } for ( $ i = 0 ; $ i < count ( $ this -> frames ) ; $ i ++ ) { $ form = $ this -> findFormInFrame ( $ this -> frames [ $ i ] , $ i , $ method , $ attribute ) ; if ( $ form ) { return $ form ; } } return ; }
1321	private function request ( $ url , $ method , $ authorization , array $ postfields , $ json = false ) { $ options = $ this -> curlOptions ( ) ; $ options [ CURLOPT_URL ] = $ url ; $ options [ CURLOPT_HTTPHEADER ] = [ 'Accept: application/json' , $ authorization , 'Expect:' ] ; switch ( $ method ) { case 'GET' : break ; case 'POST' : $ options [ CURLOPT_POST ] = true ; if ( $ json ) { $ options [ CURLOPT_HTTPHEADER ] [ ] = 'Content-type: application/json' ; $ options [ CURLOPT_POSTFIELDS ] = json_encode ( $ postfields ) ; } else { $ options [ CURLOPT_POSTFIELDS ] = Util :: buildHttpQuery ( $ postfields ) ; } break ; case 'DELETE' : $ options [ CURLOPT_CUSTOMREQUEST ] = 'DELETE' ; break ; case 'PUT' : $ options [ CURLOPT_CUSTOMREQUEST ] = 'PUT' ; break ; } if ( in_array ( $ method , [ 'GET' , 'PUT' , 'DELETE' ] ) && ! empty ( $ postfields ) ) { $ options [ CURLOPT_URL ] .= '?' . Util :: buildHttpQuery ( $ postfields ) ; } $ curlHandle = curl_init ( ) ; curl_setopt_array ( $ curlHandle , $ options ) ; $ response = curl_exec ( $ curlHandle ) ; if ( curl_errno ( $ curlHandle ) > 0 ) { throw new TwitterOAuthException ( curl_error ( $ curlHandle ) , curl_errno ( $ curlHandle ) ) ; } $ this -> response -> setHttpCode ( curl_getinfo ( $ curlHandle , CURLINFO_HTTP_CODE ) ) ; $ parts = explode ( "\r\n\r\n" , $ response ) ; $ responseBody = array_pop ( $ parts ) ; $ responseHeader = array_pop ( $ parts ) ; $ this -> response -> setHeaders ( $ this -> parseHeaders ( $ responseHeader ) ) ; curl_close ( $ curlHandle ) ; return $ responseBody ; }
10615	public function configure ( Response $ response , \ DateTime $ last_modified , $ lifetime ) { $ request = $ this -> request_stack -> getMasterRequest ( ) ; if ( ! ( $ request instanceof Request ) ) { return $ response ; } $ this -> setPrivateCache ( $ response , $ request ) -> setLastModified ( $ response , $ last_modified ) -> setLifetime ( $ response , $ lifetime ) -> setEtag ( $ response ) ; return $ response ; }
12510	public function buildPreview ( $ by ) { if ( ! in_array ( $ by , $ this -> previewBys , true ) ) { throw new InvalidArgumentException ( 'This preview by not exist.' ) ; } if ( empty ( $ this -> msgType ) ) { throw new RuntimeException ( 'Message type not exist.' ) ; } elseif ( $ this -> msgType === Broadcast :: MSG_TYPE_VIDEO ) { if ( is_array ( $ this -> message ) ) { $ this -> message = array_shift ( $ this -> message ) ; } $ this -> msgType = 'mpvideo' ; } if ( empty ( $ this -> message ) ) { throw new RuntimeException ( 'No message content to send.' ) ; } if ( empty ( $ this -> to ) ) { throw new RuntimeException ( 'No to.' ) ; } $ content = ( new Transformer ( $ this -> msgType , $ this -> message ) ) -> transform ( ) ; $ message = array_merge ( $ this -> buildTo ( $ this -> to , $ by ) , $ content ) ; return $ message ; }
6520	private function populateDefault ( Field $ field ) { if ( $ this -> has ( $ field -> getName ( ) ) ) { return true ; } $ default = $ field -> getDefault ( $ this ) ; if ( null === $ default ) { return false ; } if ( $ field -> isASingleValue ( ) ) { $ this -> data [ $ field -> getName ( ) ] = $ default ; unset ( $ this -> clearedFields [ $ field -> getName ( ) ] ) ; return true ; } if ( empty ( $ default ) ) { return false ; } if ( $ field -> isASet ( ) ) { $ this -> addToSet ( $ field -> getName ( ) , $ default ) ; return true ; } $ this -> data [ $ field -> getName ( ) ] = $ default ; unset ( $ this -> clearedFields [ $ field -> getName ( ) ] ) ; return true ; }
8464	public static function getDomain ( $ url = false ) { if ( $ url ) { preg_match ( '/([\w]+[.]){1,}[a-z]+/' , $ url , $ matches ) ; return isset ( $ matches [ 0 ] ) ? $ matches [ 0 ] : false ; } return $ _SERVER [ 'SERVER_NAME' ] ; }
4152	public function getBearerToken ( ) { $ url = $ this -> getBearerTokenUrl ( ) ; $ params = array ( 'post' => array ( 'grant_type' => 'client_credentials' ) , 'headers' => $ this -> buildBearerTokenHeader ( ) , ) ; $ response = $ this -> curl -> send ( $ url , $ params ) ; $ obj = json_decode ( $ response [ 'body' ] ) ; if ( ! $ obj || ! isset ( $ obj -> token_type ) || $ obj -> token_type != 'bearer' ) { $ this -> findExceptions ( $ response ) ; } $ this -> bearerToken = rawurldecode ( $ obj -> access_token ) ; unset ( $ url , $ params , $ response , $ obj ) ; return $ this -> bearerToken ; }
12183	public static function getOne ( Item $ parent , Item $ child , $ options = [ ] ) { $ key = md5 ( $ parent -> systemId . "." . $ child -> systemId ) ; if ( isset ( self :: $ _relationships [ $ key ] ) ) { self :: $ _relationships [ $ key ] -> mergeOptions ( $ options ) ; } else { self :: $ _relationships [ $ key ] = new Relationship ( $ parent , $ child , $ options ) ; } return self :: $ _relationships [ $ key ] ; }
10726	public function getUsers ( ) { $ select = $ this -> tableGateway -> getSql ( ) -> select ( ) ; $ select -> columns ( [ "fullname" => new Expression ( "DISTINCT(CONCAT(usr_firstname, ' ', usr_lastname))" ) ] ) ; $ select -> join ( 'melis_core_user' , 'melis_core_user.usr_id = melis_hist_page_historic.hist_user_id' , [ ] , $ select :: JOIN_INNER ) ; $ resultSet = $ this -> tableGateway -> selectWith ( $ select ) ; return $ resultSet ; }
3667	private function getRow ( $ rowId , $ table ) { return ( object ) $ this -> connection -> createQueryBuilder ( ) -> select ( '*' ) -> from ( $ table ) -> where ( 'id=:id' ) -> setParameter ( 'id' , $ rowId ) -> setMaxResults ( 1 ) -> execute ( ) -> fetch ( \ PDO :: FETCH_ASSOC ) ; }
6919	public function getAdjustments ( $ type = null ) { if ( null !== $ type ) { AdjustmentTypes :: isValidType ( $ type ) ; return $ this -> adjustments -> filter ( function ( AdjustmentInterface $ a ) use ( $ type ) { return $ a -> getType ( ) === $ type ; } ) ; } return $ this -> adjustments ; }
12858	public function onPageSaved ( PageSavedEvent $ event ) { $ blocks = $ event -> getApprovedBlocks ( ) ; foreach ( $ blocks as $ blockk ) { foreach ( $ blockk as $ block ) { $ this -> pageProductionRenderer -> renderBlock ( json_encode ( $ block ) ) ; } } $ mediaFiles = array_unique ( $ this -> pageProductionRenderer -> getMediaFiles ( ) ) ; $ webDir = $ this -> configurationHandler -> webDir ( ) ; $ fs = new Filesystem ( ) ; foreach ( $ mediaFiles as $ mediaFile ) { $ targetMediaFile = str_replace ( '/backend/' , '/production/' , $ mediaFile ) ; $ fs -> copy ( $ webDir . $ mediaFile , $ webDir . $ targetMediaFile ) ; } }
976	public function deleteWebhooks ( ) { $ shopWebhooks = $ this -> shopWebhooks ( ) ; $ deleted = [ ] ; foreach ( $ shopWebhooks as $ webhook ) { $ this -> api -> rest ( 'DELETE' , "/admin/webhooks/{$webhook->id}.json" ) ; $ deleted [ ] = $ webhook ; } $ this -> shopWebhooks = null ; return $ deleted ; }
3802	private function getOrCreatePaletteDefinition ( IMetaModelDataDefinition $ container ) { if ( $ container -> hasDefinition ( PalettesDefinitionInterface :: NAME ) ) { return $ container -> getDefinition ( PalettesDefinitionInterface :: NAME ) ; } $ container -> setDefinition ( PalettesDefinitionInterface :: NAME , $ palettesDefinition = new DefaultPalettesDefinition ( ) ) ; return $ palettesDefinition ; }
10254	public function getStreet ( ) { $ number = rand ( 100 , 9999 ) ; $ street_name = Street :: orderByRaw ( Database :: random ( ) ) -> first ( ) -> name ; return $ number . ' ' . $ street_name ; }
8160	public function confirm ( ) { $ this -> status = User :: STATUS_ACTIVE ; if ( $ this -> save ( FALSE ) ) return TRUE ; return FALSE ; }
6408	public static function filterBy ( IteratorAggregate $ unfiltered , string $ className ) : IteratorAggregate { return self :: from ( Iterators :: filterBy ( Iterators :: from ( $ unfiltered -> getIterator ( ) ) , $ className ) ) ; }
9494	private function formatSize ( $ bytes ) { $ kb = 1024 ; $ mb = $ kb * 1024 ; $ gb = $ mb * 1024 ; $ tb = $ gb * 1024 ; if ( ( $ bytes >= 0 ) && ( $ bytes < $ kb ) ) { return $ bytes . ' B' ; } elseif ( ( $ bytes >= $ kb ) && ( $ bytes < $ mb ) ) { return ceil ( $ bytes / $ kb ) . ' KB' ; } elseif ( ( $ bytes >= $ mb ) && ( $ bytes < $ gb ) ) { return ceil ( $ bytes / $ mb ) . ' MB' ; } elseif ( ( $ bytes >= $ gb ) && ( $ bytes < $ tb ) ) { return ceil ( $ bytes / $ gb ) . ' GB' ; } elseif ( $ bytes >= $ tb ) { return ceil ( $ bytes / $ tb ) . ' TB' ; } return $ bytes . ' B' ; }
8191	public function actionConfirm ( $ id , $ code ) { $ user = UserIdentity :: findByActivationToken ( $ id , $ code ) ; if ( $ user == NULL ) throw new NotFoundHttpException ; if ( ! empty ( $ user ) ) { $ user -> activation_token = NULL ; $ user -> status = User :: STATUS_ACTIVE ; $ user -> save ( FALSE ) ; Yii :: $ app -> session -> setFlash ( 'success' , Yii :: t ( 'user' , 'Account ' . $ user -> email . ' has successfully been activated' ) ) ; } else Yii :: $ app -> session -> setFlash ( 'error' , Yii :: t ( 'user' , 'Account ' . $ user -> email . ' could not been activated. Please contact the Administrator' ) ) ; return $ this -> render ( 'confirm' , [ 'user' => $ user ] ) ; }
6062	public function download ( $ id , $ template = null , $ templateType = 'image' , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'template' => $ template , 'templateType' => $ templateType ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/media/' . $ id . '/download' , $ parameters , $ cachePolicy ) ; $ tmpFile = tmpfile ( ) ; if ( false === fwrite ( $ tmpFile , $ result ) ) { throw new \ RuntimeException ( 'Could not write download data to temporary file!' ) ; } if ( false === fseek ( $ tmpFile , 0 ) ) { throw new \ RuntimeException ( 'Could not reset file pointer of temporary file!' ) ; } $ result = $ tmpFile ; return $ result ; }
10034	function unsubscribeContactById ( $ id , $ mailingId = "" , $ reasons = null ) { $ queryParameters = array ( 'id' => $ id ) ; if ( ! empty ( $ mailingId ) ) { $ queryParameters [ 'mailingId' ] = $ mailingId ; } if ( ! empty ( $ reasons ) ) { if ( is_array ( $ reasons ) ) { $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , 'reason' , $ reasons ) ; } else { $ queryParameters [ 'reason' ] = urlencode ( $ reasons ) ; } } return $ this -> delete ( "contacts/contact/unsubscribe" , $ queryParameters ) ; }
11768	public function updateSentinels ( ) { SENTINEL_QUERY : { $ sentinel = $ this -> getSentinelConnection ( ) ; try { $ payload = $ sentinel -> executeCommand ( RawCommand :: create ( 'SENTINEL' , 'sentinels' , $ this -> service ) ) ; $ this -> sentinels = array ( ) ; $ this -> sentinels [ ] = $ sentinel -> getParameters ( ) -> toArray ( ) ; foreach ( $ payload as $ sentinel ) { $ this -> sentinels [ ] = array ( 'host' => $ sentinel [ 3 ] , 'port' => $ sentinel [ 5 ] , 'role' => 'sentinel' , ) ; } } catch ( ConnectionException $ exception ) { $ this -> sentinelConnection = null ; goto SENTINEL_QUERY ; } } }
11976	public function handleCommandHelp ( Event $ event , Queue $ queue ) { $ this -> sendIrcResponse ( $ event , $ queue , $ this -> getHelpLines ( ) ) ; }
8943	public function diffUploadChangeset ( $ xml , $ id ) { $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = 'changeset/' . $ id . '/upload' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ header [ 'Content-Type' ] = 'text/xml' ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'POST' , $ parameters , $ xml , $ header ) ; $ xmlString = simplexml_load_string ( $ response -> body ) ; return $ xmlString -> diffResult ; }
3156	public function getOutcomeVariable ( $ variableIdentifier , $ variableValue ) { if ( ! is_string ( $ variableValue ) && ! is_numeric ( $ variableValue ) ) { $ variableValue = json_encode ( $ variableValue ) ; } $ metaVariable = new \ taoResultServer_models_classes_OutcomeVariable ( ) ; $ metaVariable -> setIdentifier ( $ variableIdentifier ) ; $ metaVariable -> setBaseType ( 'string' ) ; $ metaVariable -> setCardinality ( Cardinality :: getNameByConstant ( Cardinality :: SINGLE ) ) ; $ metaVariable -> setValue ( $ variableValue ) ; return $ metaVariable ; }
1015	public function setValidationRules ( $ validationRules ) { if ( ! is_callable ( $ validationRules ) && ! is_array ( $ validationRules ) && $ validationRules !== null ) { throw new InvariantViolation ( 'Server config expects array of validation rules or callable returning such array, but got ' . Utils :: printSafe ( $ validationRules ) ) ; } $ this -> validationRules = $ validationRules ; return $ this ; }
7313	public function setDate ( $ year , $ month , $ day ) { $ status = IAU :: Cal2jd ( ( int ) $ year , ( int ) $ month , ( int ) $ day , $ djm0 , $ djm ) ; $ this -> checkDate ( $ status ) ; $ this -> jd = $ djm0 + $ djm ; return $ this ; }
9094	public function handle ( ) { try { if ( $ this -> validate ( ) ) { $ result = $ this -> update ( ) ; } } catch ( \ hypeJunction \ Exceptions \ ActionValidationException $ ex ) { register_error ( elgg_echo ( 'prototyper:validate:error' ) ) ; forward ( REFERER ) ; } catch ( \ IOException $ ex ) { register_error ( elgg_echo ( 'prototyper:io:error' , array ( $ ex -> getMessage ( ) ) ) ) ; forward ( REFERER ) ; } catch ( \ Exception $ ex ) { register_error ( elgg_echo ( 'prototyper:handle:error' , array ( $ ex -> getMessage ( ) ) ) ) ; forward ( REFERER ) ; } if ( $ result ) { system_message ( elgg_echo ( 'prototyper:action:success' ) ) ; forward ( $ this -> entity -> getURL ( ) ) ; } else { register_error ( elgg_echo ( 'prototyper:action:error' ) ) ; forward ( REFERER ) ; } }
2661	public function deleteRequest ( $ version , $ name ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/request_settings/' . $ name ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: DELETE ) ; if ( ! $ result ) { throw new LocalizedException ( __ ( 'Failed to delete the REQUEST object.' ) ) ; } }
12795	public function images ( $ params ) { try { $ response = $ this -> client -> request -> get ( $ this -> apiEndpoint . '/images' . $ this -> paramsToString ( $ params ) ) ; $ status = $ this -> client -> getStatus ( $ response ) ; if ( 200 != $ status ) { throw new Exception ( 'Digital Ocean was not able to successfully provide a list of snapshots.' ) ; } return $ this -> client -> getBody ( $ response ) ; } catch ( Exception $ e ) { echo 'Unable to list snapshots because ' . $ e -> getMessage ( ) ; } }
1833	public function onUnregister ( Registry $ registry ) { foreach ( static :: getUniqueFields ( ) as $ strColumn ) { $ varAliasValue = $ this -> { $ strColumn } ; if ( $ registry -> isRegisteredAlias ( $ this , $ strColumn , $ varAliasValue ) ) { $ registry -> unregisterAlias ( $ this , $ strColumn , $ varAliasValue ) ; } } }
11146	public function move ( Neuron_GameServer_Map_MapObject $ object , Neuron_GameServer_Map_Location $ location , Neuron_GameServer_Map_Date $ start , Neuron_GameServer_Map_Date $ end ) { throw new Neuron_Exceptions_NotImplemented ( "The move method is not implemented in this map." ) ; }
5656	private function walkChildren ( $ node ) { if ( $ node -> hasChildren ( ) ) { foreach ( $ node -> child as $ child ) { $ this -> walkTree ( $ child ) ; } } }
6170	protected function onAddError ( \ Exception $ e ) { $ this -> writeProgressWithColor ( 'fg-red,bold' , 'E' ) ; $ this -> exception = $ e ; $ this -> lastTestFailed = true ; $ this -> flawless = false ; }
12541	public static function random ( $ length = 8 , $ allowedChars = 'abcdefghjkmnpqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXY346789' ) { $ return = '' ; $ hashLength = strlen ( $ allowedChars ) - 1 ; for ( ; $ length > 0 ; -- $ length ) { $ return .= $ allowedChars { rand ( 0 , $ hashLength ) } ; } return str_shuffle ( $ return ) ; }
7007	private function format_j ( & $ str ) { if ( strstr ( $ str , '%j' ) ) $ str = str_replace ( '%j' , sprintf ( '%01d' , $ this -> day ) , $ str ) ; }
11194	protected function fixTree ( array $ data ) { $ result = [ ] ; foreach ( $ data as $ k => $ v ) { $ res = & $ this -> searchNode ( $ k , $ result ) ; if ( is_array ( $ v ) && is_array ( $ res ) ) { $ res = array_replace_recursive ( $ res , $ this -> fixTree ( $ v ) ) ; } else { $ res = $ v ; } } return $ result ; }
8779	public function segment ( $ num = null ) { if ( is_null ( http ( ) -> server ( 'REQUEST_URI' ) ) || is_null ( http ( ) -> server ( 'SCRIPT_NAME' ) ) ) { return null ; } if ( ! is_null ( $ num ) ) { $ uri = $ this -> replace ( str_replace ( $ this -> base , '' , http ( ) -> server ( 'REQUEST_URI' ) ) ) ; $ uriA = explode ( '/' , $ uri ) ; return ( isset ( $ uriA [ $ num ] ) ? reset ( explode ( '?' , $ uriA [ $ num ] ) ) : null ) ; } return null ; }
4558	public function generateUuid ( Uuidentifiable $ entity , bool $ overwrite = false ) { if ( null === $ entity -> getUuid ( ) || $ overwrite ) { $ uuid = Uuid :: uuid4 ( ) -> toString ( ) ; $ entity -> setUuid ( $ uuid ) ; } return $ this ; }
1482	public function encoder ( $ options = 0 , $ depth = 512 ) { if ( $ options instanceof Encoding ) { $ options = $ options -> getOptions ( ) ; } if ( ! $ options instanceof EncoderOptions ) { $ options = new EncoderOptions ( $ options , $ this -> getUrl ( ) -> toString ( ) , $ depth ) ; } return $ this -> factory -> createEncoder ( $ this -> getContainer ( ) , $ options ) ; }
7244	public function load_options ( ) { $ options = get_option ( self :: OPTION_KEY , '' ) ; if ( ! is_array ( $ options ) ) { $ options = self :: $ default_options ; update_option ( self :: OPTION_KEY , $ options ) ; } else { foreach ( self :: $ default_options as $ key => $ value ) { if ( ! isset ( $ options [ $ key ] ) ) $ options [ $ key ] = $ value ; } } $ this -> options = $ options ; }
12037	function generate ( ) { if ( $ this -> namespace ) { $ fqcn = $ this -> namespace . '\\' . $ this -> className ; } else { $ fqcn = $ this -> className ; } $ this -> addProperties ( ) ; $ this -> addConstructorMethod ( ) ; $ this -> addSetAPIMethod ( ) ; $ this -> addSetParameterMethod ( ) ; $ this -> addCheckScopeMethod ( ) ; $ this -> addAccessorMethods ( ) ; $ this -> addFilteredParameterMethod ( ) ; $ this -> addCreateRequestMethod ( ) ; $ this -> addCreateAndExecuteMethod ( ) ; $ this -> addCallMethod ( ) ; $ this -> addExecuteMethod ( ) ; $ this -> addExecuteAsyncMethod ( ) ; $ this -> addDispatchMethod ( ) ; $ this -> addDispatchAsyncMethod ( ) ; $ this -> addProcessResponseMethod ( ) ; $ this -> addShouldResponseBeProcessedMethod ( ) ; $ this -> addTranslateResponseToExceptionMethod ( ) ; $ this -> addShouldUseCachedResponseMethod ( ) ; $ this -> addShouldResponseBeCachedMethod ( ) ; $ this -> addSetOriginalResponseMethod ( ) ; $ this -> addGetOriginalResponseMethod ( ) ; $ this -> addGetResultInstantiationInfoMethod ( ) ; $ this -> classGenerator -> setImplementedInterfaces ( [ 'ArtaxServiceBuilder\Operation' ] ) ; $ this -> classGenerator -> setFQCN ( $ fqcn ) ; $ text = $ this -> classGenerator -> generate ( ) ; saveFile ( $ this -> outputPath , $ fqcn , $ text ) ; }
5572	public function authenticate ( $ username , $ password ) { if ( ! $ this -> page -> getRealm ( ) ) { return false ; } $ url = $ this -> page -> getUrl ( ) ; if ( ! $ url ) { return false ; } $ this -> user_agent -> setIdentity ( $ url -> getHost ( ) , $ this -> page -> getRealm ( ) , $ username , $ password ) ; return $ this -> retry ( ) ; }
10880	public function renderPreviousExceptions ( $ exception ) { if ( ( $ previous = $ exception -> getPrevious ( ) ) !== null ) { return $ this -> renderFile ( $ this -> previousExceptionView , [ 'exception' => $ previous ] ) ; } else { return '' ; } }
11114	public function rollback ( array $ options = [ ] ) : void { $ migrations = $ this -> getMigrationsForRollback ( $ options ) ; if ( count ( $ migrations ) === 0 ) { $ this -> notify -> note ( '<info>Nothing to rollback.</info>' ) ; return ; } $ this -> rollbackMigrations ( $ migrations ) ; }
10748	protected function sendCreated ( Response $ response , string $ type , array $ ids , array $ extra = [ ] ) : Response { return $ this -> sendVerb ( 'created' , $ response , $ type , $ ids , $ extra ) -> withStatus ( 201 , "Created" ) ; }
12901	private function addSource ( array $ arguments = array ( ) ) { $ this -> builder -> addSource ( array_key_exists ( 'cache' , $ this -> source ) ? $ this -> createCacheAdapter ( ) : new HttpApiAdapter ( ) , new Request ( array ( 'source' => $ this -> source , 'arguments' => $ arguments , 'service' => $ this -> getGroup ( ) -> getService ( ) -> getName ( ) , 'group' => $ this -> getGroup ( ) -> getName ( ) , 'action' => $ this -> getName ( ) , ) ) ) ; }
10184	function createContactFilter ( $ newFilterObject , $ createTargetGroup , $ version = 1.0 ) { if ( $ version == 1.0 ) { $ queryParameters = array ( 'createTargetGroup' => ( $ createTargetGroup ) ? "true" : "false" ) ; return $ this -> put ( "contactfilters/contactfilter" , $ newFilterObject -> toXMLString ( ) , $ queryParameters ) ; } else if ( $ version == 2.0 ) { $ queryParameters = array ( 'createTargetGroup' => ( $ createTargetGroup ) ? "true" : "false" ) ; return $ this -> post ( "contactfilters/v2" , $ newFilterObject , $ queryParameters , "application/json" ) ; } }
3625	public function getDevices ( $ type = DEVICE_TYPE_THERMOSTAT ) { $ this -> prepareForGet ( ) ; if ( $ type == DEVICE_TYPE_PROTECT ) { $ protects = array ( ) ; $ topaz = isset ( $ this -> last_status -> topaz ) ? $ this -> last_status -> topaz : array ( ) ; foreach ( $ topaz as $ protect ) { $ protects [ ] = $ protect -> serial_number ; } return $ protects ; } $ devices_serials = array ( ) ; foreach ( $ this -> last_status -> user -> { $ this -> userid } -> structures as $ structure ) { list ( , $ structure_id ) = explode ( '.' , $ structure ) ; foreach ( $ this -> last_status -> structure -> { $ structure_id } -> devices as $ device ) { list ( , $ device_serial ) = explode ( '.' , $ device ) ; $ devices_serials [ ] = $ device_serial ; } } return $ devices_serials ; }
2410	public function getDbInstallerArray ( ) { $ return = array ( ) ; foreach ( $ this -> arrFields as $ k => $ v ) { if ( \ is_array ( $ v ) ) { if ( ! isset ( $ v [ 'name' ] ) ) { $ v [ 'name' ] = $ k ; } $ return [ 'SCHEMA_FIELDS' ] [ $ k ] = $ v ; } else { $ return [ 'TABLE_FIELDS' ] [ $ k ] = '`' . $ k . '` ' . $ v ; } } $ quote = function ( $ item ) { return '`' . $ item . '`' ; } ; foreach ( $ this -> arrKeys as $ k => $ v ) { if ( strpos ( $ k , ',' ) !== false ) { $ f = array_map ( $ quote , StringUtil :: trimsplit ( ',' , $ k ) ) ; $ k = str_replace ( ',' , '_' , $ k ) ; } else { $ f = array ( $ quote ( $ k ) ) ; } if ( $ v == 'primary' ) { $ k = 'PRIMARY' ; $ v = 'PRIMARY KEY (' . implode ( ', ' , $ f ) . ')' ; } elseif ( $ v == 'index' ) { $ v = 'KEY `' . $ k . '` (' . implode ( ', ' , $ f ) . ')' ; } else { $ v = strtoupper ( $ v ) . ' KEY `' . $ k . '` (' . implode ( ', ' , $ f ) . ')' ; } $ return [ 'TABLE_CREATE_DEFINITIONS' ] [ $ k ] = $ v ; } $ return [ 'TABLE_OPTIONS' ] = '' ; foreach ( $ this -> arrMeta as $ k => $ v ) { if ( $ k == 'engine' ) { $ return [ 'TABLE_OPTIONS' ] .= ' ENGINE=' . $ v ; } elseif ( $ k == 'charset' ) { $ return [ 'TABLE_OPTIONS' ] .= ' DEFAULT CHARSET=' . $ v ; } elseif ( $ k == 'collate' ) { $ return [ 'TABLE_OPTIONS' ] .= ' COLLATE ' . $ v ; } } return $ return ; }
1508	public static function fromArray ( array $ url ) : self { return new self ( isset ( $ url [ 'host' ] ) ? $ url [ 'host' ] : '' , isset ( $ url [ 'namespace' ] ) ? $ url [ 'namespace' ] : '' , isset ( $ url [ 'name' ] ) ? $ url [ 'name' ] : '' ) ; }
4914	private function addTraversable ( \ Traversable $ result ) { foreach ( $ result as $ item ) { break ; } if ( ! $ item instanceof EntityInterface ) { throw new \ InvalidArgumentException ( 'Traversable objects must be a non-empty collection of Entity instances.' ) ; } $ name = get_class ( $ item ) ; return $ this -> addArray ( [ 'name' => $ name , 'entities' => $ result , ] ) ; }
11531	public static function slotDir ( $ sourceDir , array $ options ) { $ paths = array ( sprintf ( '%s/pages/pages/%s/%s_%s/%s' , $ sourceDir , $ options [ 'page' ] , $ options [ 'language' ] , $ options [ 'country' ] , $ options [ 'slot' ] ) , sprintf ( '%s/slots/%s/%s_%s' , $ sourceDir , $ options [ 'slot' ] , $ options [ 'language' ] , $ options [ 'country' ] ) , sprintf ( '%s/slots/%s' , $ sourceDir , $ options [ 'slot' ] ) , ) ; return self :: cascade ( $ paths ) ; }
11657	public function make ( ) { if ( count ( $ this -> headers ) > 0 ) { if ( ! $ this -> session -> exists ( 'headersInRedirect' , 'redirect' ) || ! $ this -> session -> get ( 'headersInRedirect' , 'redirect' ) ) { $ this -> session -> set ( 'redirectPath' , $ this -> path , 'redirect' ) ; $ this -> session -> set ( 'headersInRedirect' , $ this -> headers , 'redirect' ) ; } } header ( "Location: $this->path" ) ; exit ( ) ; }
1915	protected function getQuestion ( ) { $ this -> generateCaptcha ( ) ; $ question = $ GLOBALS [ 'TL_LANG' ] [ 'SEC' ] [ 'question' . random_int ( 1 , 3 ) ] ; $ question = sprintf ( $ question , $ this -> arrCaptcha [ 'int1' ] , $ this -> arrCaptcha [ 'int2' ] ) ; $ strEncoded = '' ; $ arrCharacters = Utf8 :: str_split ( $ question ) ; foreach ( $ arrCharacters as $ strCharacter ) { $ strEncoded .= sprintf ( '&#%s;' , Utf8 :: ord ( $ strCharacter ) ) ; } return $ strEncoded ; }
150	public function addError ( $ model , $ attribute , $ message , $ params = [ ] ) { $ params [ 'attribute' ] = $ model -> getAttributeLabel ( $ attribute ) ; if ( ! isset ( $ params [ 'value' ] ) ) { $ value = $ model -> $ attribute ; if ( is_array ( $ value ) ) { $ params [ 'value' ] = 'array()' ; } elseif ( is_object ( $ value ) && ! method_exists ( $ value , '__toString' ) ) { $ params [ 'value' ] = '(object)' ; } else { $ params [ 'value' ] = $ value ; } } $ model -> addError ( $ attribute , $ this -> formatMessage ( $ message , $ params ) ) ; }
768	protected function regenerateCsrfToken ( ) { $ request = Yii :: $ app -> getRequest ( ) ; if ( $ request -> enableCsrfCookie || $ this -> enableSession ) { $ request -> getCsrfToken ( true ) ; } }
8571	public function listRecommendations ( $ request ) { if ( ! ( $ request instanceof MWSRecommendationsSectionService_Model_ListRecommendationsRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/ListRecommendationsRequest.php' ) ; $ request = new MWSRecommendationsSectionService_Model_ListRecommendationsRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListRecommendations' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/ListRecommendationsResponse.php' ) ; $ response = MWSRecommendationsSectionService_Model_ListRecommendationsResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
905	public function isUnaryPredecessorOperator ( $ index ) { static $ potentialSuccessorOperator = [ T_INC , T_DEC ] ; static $ potentialBinaryOperator = [ '+' , '-' , '&' , [ CT :: T_RETURN_REF ] ] ; static $ otherOperators ; if ( null === $ otherOperators ) { $ otherOperators = [ '!' , '~' , '@' , [ T_ELLIPSIS ] ] ; } static $ disallowedPrevTokens ; if ( null === $ disallowedPrevTokens ) { $ disallowedPrevTokens = [ ']' , '}' , ')' , '"' , '`' , [ CT :: T_ARRAY_SQUARE_BRACE_CLOSE ] , [ CT :: T_DYNAMIC_PROP_BRACE_CLOSE ] , [ CT :: T_DYNAMIC_VAR_BRACE_CLOSE ] , [ T_CLASS_C ] , [ T_CONSTANT_ENCAPSED_STRING ] , [ T_DEC ] , [ T_DIR ] , [ T_DNUMBER ] , [ T_FILE ] , [ T_FUNC_C ] , [ T_INC ] , [ T_LINE ] , [ T_LNUMBER ] , [ T_METHOD_C ] , [ T_NS_C ] , [ T_STRING ] , [ T_TRAIT_C ] , [ T_VARIABLE ] , ] ; } $ tokens = $ this -> tokens ; $ token = $ tokens [ $ index ] ; if ( $ token -> isGivenKind ( $ potentialSuccessorOperator ) ) { return ! $ this -> isUnarySuccessorOperator ( $ index ) ; } if ( $ token -> equalsAny ( $ otherOperators ) ) { return true ; } if ( ! $ token -> equalsAny ( $ potentialBinaryOperator ) ) { return false ; } $ prevToken = $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ index ) ] ; if ( ! $ prevToken -> equalsAny ( $ disallowedPrevTokens ) ) { return true ; } if ( ! $ token -> equals ( '&' ) || ! $ prevToken -> isGivenKind ( T_STRING ) ) { return false ; } static $ searchTokens = [ ';' , '{' , '}' , [ T_FUNCTION ] , [ T_OPEN_TAG ] , [ T_OPEN_TAG_WITH_ECHO ] , ] ; $ prevToken = $ tokens [ $ tokens -> getPrevTokenOfKind ( $ index , $ searchTokens ) ] ; return $ prevToken -> isGivenKind ( T_FUNCTION ) ; }
9458	private function mapAdminRoutes ( ) { $ this -> adminGroup ( function ( ) { $ this -> name ( 'foundation.' ) -> group ( function ( ) { Routes \ Admin \ DashboardRoute :: register ( ) ; Routes \ Admin \ SettingsRoutes :: register ( ) ; Routes \ Admin \ SystemRoutes :: register ( ) ; } ) ; } ) ; }
11397	public static function parseFault ( \ SimpleXMLElement $ fault ) { $ faultData = static :: parseStruct ( $ fault -> value -> struct ) ; return new \ Devedge \ XmlRpc \ Client \ RemoteException ( $ faultData [ 'faultString' ] , $ faultData [ 'faultCode' ] ) ; }
11188	public static function set ( array $ arr , $ k , $ v ) { $ nested = ! is_array ( $ k ) ? explode ( '.' , $ k ) : $ k ; $ count = count ( $ nested ) ; if ( $ count == 1 ) { return $ arr [ $ k ] = $ v ; } elseif ( $ count > 1 ) { $ prev = '' ; $ loop = 1 ; $ unshift = $ nested ; foreach ( $ nested as $ part ) { if ( isset ( $ arr [ $ part ] ) && $ count > $ loop ) { $ prev = $ part ; array_shift ( $ unshift ) ; $ loop ++ ; continue ; } else { if ( $ loop > 1 && $ loop < $ count ) { if ( ! isset ( $ arr [ $ prev ] [ $ part ] ) ) $ arr [ $ prev ] [ $ part ] = [ ] ; $ arr [ $ prev ] = static :: set ( $ arr [ $ prev ] , $ unshift , $ v ) ; $ loop ++ ; break ; } elseif ( $ loop >= 1 && $ loop == $ count ) { if ( ! is_array ( $ arr [ $ prev ] ) ) $ arr [ $ prev ] = [ ] ; if ( $ part == '' ) $ arr [ $ prev ] [ ] = $ v ; else $ arr [ $ prev ] [ $ part ] = $ v ; } else { $ arr [ $ part ] = [ ] ; $ prev = $ part ; array_shift ( $ unshift ) ; $ loop ++ ; } } } } return $ arr ; }
8009	protected function processKey ( $ raw_key ) { $ key = $ raw_key ; if ( $ this -> expand_and_normalize_keys ) { $ key = self :: expand56BitKeyTo64BitKey ( $ key , true ) ; } return $ key ; }
3015	public function deletePost ( $ blogName , $ postId , $ reblogKey ) { $ options = array ( 'id' => $ postId , 'reblog_key' => $ reblogKey ) ; $ path = $ this -> blogPath ( $ blogName , '/post/delete' ) ; return $ this -> postRequest ( $ path , $ options , false ) ; }
10846	protected function restoreWordCase ( $ token ) { if ( $ token === strtoupper ( $ token ) ) { return function ( $ word ) { return strtoupper ( $ word ) ; } ; } if ( $ token === ucfirst ( $ token ) ) { return function ( $ word ) { return ucfirst ( $ word ) ; } ; } return function ( $ word ) { return $ word ; } ; }
417	public function getETags ( ) { if ( $ this -> headers -> has ( 'If-None-Match' ) ) { return preg_split ( '/[\s,]+/' , str_replace ( '-gzip' , '' , $ this -> headers -> get ( 'If-None-Match' ) ) , - 1 , PREG_SPLIT_NO_EMPTY ) ; } return [ ] ; }
11667	private function addDefaultFunction ( ) { $ this -> addFunction ( 'app' , function ( ) { return app ( ) ; } ) ; $ this -> addFunction ( 'url' , function ( $ url , $ absolute = false , array $ params = array ( ) ) { if ( $ absolute ) { return Url :: createAbsolute ( $ url , $ params ) ; } else { return Url :: create ( $ url , $ params ) ; } } ) ; $ this -> addFunction ( 'assets' , function ( $ path ) { return Url :: createAbsolute ( $ path ) ; } ) ; }
10477	protected function displayExceptions ( Exception $ e ) { $ this -> display [ ] = 'Cerbero\Auth\Exceptions\DisplayException' ; foreach ( $ this -> display as $ exception ) { if ( $ e instanceof $ exception ) { return back ( ) -> withInput ( ) -> withError ( $ e -> getMessage ( ) ) ; } } }
8574	public function setGetMyPriceForSKUResult ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'GetMyPriceForSKUResult' ] [ 'FieldValue' ] = $ value ; return $ this ; }
5784	public function routePutUpdate ( Request $ request , Response $ response , $ args ) { if ( ! $ this -> authorization -> isAuthorized ( constant ( strtoupper ( $ this -> routePrefix ) . "_UPDATE_RESOURCE" ) ) ) { throw new \ Exception ( 'No permission.' ) ; } $ primaryKeyValue = $ args [ ROUTEARG_PRIMARY_KEY ] ; $ this -> setRequestInput ( $ request , DatabaseTableForm :: getFieldNames ( $ this -> tableMapper ) , $ this -> tableMapper -> getBooleanColumnNames ( ) ) ; $ redirectRoute = SlimPostgres :: getRouteName ( true , $ this -> routePrefix , 'index' ) ; if ( null === $ record = $ this -> tableMapper -> selectForPrimaryKey ( $ primaryKeyValue ) ) { return $ this -> databaseRecordNotFound ( $ response , $ primaryKeyValue , $ this -> tableMapper , 'update' ) ; } $ changedColumnsValues = $ this -> getMapper ( ) -> getChangedColumnsValues ( $ this -> requestInput , $ record ) ; if ( count ( $ changedColumnsValues ) == 0 ) { SlimPostgres :: setAdminNotice ( "No changes made" , 'failure' ) ; return $ this -> view -> updateView ( $ request , $ response , $ args ) ; } $ validator = new DatabaseTableUpdateFormValidator ( $ this -> requestInput , $ this -> tableMapper , $ record ) ; if ( ! $ validator -> validate ( ) ) { FormHelper :: setFieldErrors ( $ validator -> getFirstErrors ( ) ) ; $ args [ SlimPostgres :: USER_INPUT_KEY ] = $ this -> requestInput ; return $ this -> view -> updateView ( $ request , $ response , $ args ) ; } $ this -> tableMapper -> updateByPrimaryKey ( $ changedColumnsValues , $ primaryKeyValue ) ; $ this -> enterEventAndNotice ( 'update' , $ primaryKeyValue ) ; return $ response -> withRedirect ( $ this -> router -> pathFor ( $ redirectRoute ) ) ; }
8534	public function setChargeInstrumentList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ChargeInstrumentList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
11876	public static function getDump ( $ var , $ maxSize = null ) { $ trace = debug_backtrace ( ) ; $ dump = '' ; $ dump .= static :: getHeader ( 'Dump de variable' ) ; $ dump .= '<div class="dump_segment">Contexte</div>' ; if ( count ( $ trace ) > 2 ) { $ dump .= static :: getContext ( $ trace [ 1 ] , $ trace [ 2 ] ) ; } else { $ dump .= static :: getContext ( $ trace [ 1 ] ) ; } if ( is_object ( $ var ) && get_class ( $ var ) == 'sylab\common\sgbd\Query' ) { $ dump .= '<div class="dump_segment">Requte SQL</div>'; $ dump .= '<div class="dump_segment_content"><pre>' . $ var -> getSql ( ) . '</pre></div>' ; } $ dump .= '<div class="dump_segment">Exploration de la variable</div>' ; $ dump .= '<div class="dump_segment_content"><pre>' ; if ( is_object ( $ var ) && get_class ( $ var ) == 'sylab\framework\query\Query' ) { $ dump .= static :: getDumpQueryResult ( $ var -> getQueryResults ( ) ) ; } elseif ( is_object ( $ var ) && get_class ( $ var ) == 'sylab\framework\query\QueryResult' ) { $ dump .= static :: getDumpQueryResult ( $ var ) ; } else { $ dump .= static :: getDumpContent ( $ var , $ maxSize ) ; } $ dump .= '</pre></div>' ; $ dump .= static :: getFooter ( ) ; return $ dump ; }
10954	protected function ifNoneMatch ( Request $ request , Response $ response , string $ etag ) : Response { $ ifNoneMatch = $ request -> getHeaderLine ( 'If-None-Match' ) ; if ( $ ifNoneMatch && $ etag === $ ifNoneMatch ) { return $ response -> withStatus ( 304 , "Not Modified" ) ; } return $ response ; }
743	private function initializeEventHandlers ( ) { $ this -> owner -> on ( Widget :: EVENT_BEFORE_RUN , [ $ this , 'beforeRun' ] ) ; $ this -> owner -> on ( Widget :: EVENT_AFTER_RUN , [ $ this , 'afterRun' ] ) ; }
7084	public function delete_cookie ( $ name ) { unset ( $ _COOKIE [ $ name ] ) ; return setcookie ( $ name , null , - 86400 , $ this -> cookie_path , $ this -> cookie_domain , $ this -> cookie_secure , $ this -> cookie_httponly ) ; }
841	public function offsetUnset ( $ index ) { $ this -> changed = true ; $ this -> unregisterFoundToken ( $ this [ $ index ] ) ; parent :: offsetUnset ( $ index ) ; }
8746	public function getListenerInstance ( EventDispatcher $ eventDispatcher = null , StreamableInterface $ stream = null ) { $ reflection = new \ ReflectionClass ( '\\Iber\\Phkey\\Environment\\' . $ this -> getEnvironment ( ) . '\\Matcher' ) ; $ matcher = $ reflection -> newInstance ( ) ; $ reflection = new \ ReflectionClass ( '\\Iber\\Phkey\\Environment\\' . $ this -> getEnvironment ( ) . '\\Listener' ) ; if ( null === $ eventDispatcher ) { $ eventDispatcher = new EventDispatcher ( ) ; } if ( null === $ stream ) { $ stream = new Stream ( ) ; } $ listener = $ reflection -> newInstance ( $ matcher , $ eventDispatcher , $ stream ) ; return $ listener ; }
10525	public function setFieldValue ( $ field , $ value ) { $ type = $ this -> getFieldFormType ( $ field ) ; switch ( $ type ) { case 'select' : return $ this -> selectOptionForm ( $ field , $ value ) ; case 'checkbox' : case 'checkboxGroup' : return $ this -> checkOptionForm ( $ field ) ; default : return $ this -> fillFieldForm ( $ field , $ value ) ; } }
11926	public function setAutoloadDir ( $ dir ) { if ( ! is_string ( $ dir ) || empty ( $ dir ) ) { throw new InvalidArgumentException ( sprintf ( 'Invalid directory for autoload of configuration provided; ' . 'must be a non-empty string, "%s" received.' , is_object ( $ dir ) ? get_class ( $ dir ) : gettype ( $ dir ) ) ) ; } $ dir = Normalizer :: path ( $ dir ) ; if ( ! file_exists ( $ dir ) || ! is_dir ( $ dir ) ) { throw new InvalidArgumentException ( sprintf ( 'The directory "%s", specified for autoload of configurations, ' . 'does not exists.' , $ dir ) ) ; } $ this -> autoloadDir = $ dir ; }
5479	protected function addRadioButton ( $ tag ) { if ( ! isset ( $ this -> radios [ $ tag -> getName ( ) ] ) ) { $ this -> widgets [ ] = new SimpleRadioGroup ( ) ; $ this -> radios [ $ tag -> getName ( ) ] = count ( $ this -> widgets ) - 1 ; } $ this -> widgets [ $ this -> radios [ $ tag -> getName ( ) ] ] -> addWidget ( $ tag ) ; }
361	public function renderErrors ( ) { if ( $ this -> filterModel instanceof Model && $ this -> filterModel -> hasErrors ( ) ) { return Html :: errorSummary ( $ this -> filterModel , $ this -> filterErrorSummaryOptions ) ; } return '' ; }
11134	protected function calculateSELECT ( ) { $ this -> query .= 'SELECT ' ; if ( $ this -> distinct ) { $ this -> query .= ' DISTINCT ' ; } $ this -> queryStringFromArray ( 'selects' , '' , ', ' ) ; $ this -> queryStringFromArray ( 'tables' , ' FROM ' , ', ' ) ; $ this -> joinStringFromArray ( 'joins' ) ; $ this -> conditionStringFromArray ( 'wheres' , ' WHERE ' , ' AND ' ) ; $ this -> queryStringFromArray ( 'groupBys' , ' GROUP BY ' , ', ' ) ; $ this -> conditionStringFromArray ( 'havings' , ' HAVING ' , ' AND ' ) ; $ this -> queryStringFromArray ( 'orderBys' , ' ORDER BY ' , ', ' , false ) ; if ( $ this -> limit ) { $ this -> query .= ' LIMIT ' . $ this -> limit ; } if ( $ this -> offset ) { $ this -> query .= ' OFFSET ' . $ this -> offset ; } }
4531	public function process ( ContainerBuilder $ container ) { $ definition = $ container -> findDefinition ( LoaderCollection :: class ) ; $ services = $ container -> findTaggedServiceIds ( 'ds_tenant.loader' ) ; $ items = [ ] ; foreach ( $ services as $ id => $ tags ) { foreach ( $ tags as $ tag ) { $ items [ ] = [ 'id' => $ id , 'priority' => array_key_exists ( 'priority' , $ tag ) ? $ tag [ 'priority' ] : 0 , 'alias' => array_key_exists ( 'alias' , $ tag ) ? $ tag [ 'alias' ] : null ] ; } } usort ( $ items , function ( $ a , $ b ) { return $ a [ 'priority' ] === $ b [ 'priority' ] ? 0 : $ a [ 'priority' ] < $ b [ 'priority' ] ? - 1 : 1 ; } ) ; foreach ( $ items as $ item ) { if ( null !== $ item [ 'alias' ] ) { $ definition -> addMethodCall ( 'set' , [ $ item [ 'alias' ] , new Reference ( $ item [ 'id' ] ) ] ) ; } else { $ definition -> addMethodCall ( 'add' , [ new Reference ( $ item [ 'id' ] ) ] ) ; } } }
11116	public function drop ( ) : void { $ dropped = $ this -> repository -> drop ( ) ; if ( count ( $ dropped ) === 0 ) { return ; } $ this -> notify -> note ( '' ) ; foreach ( $ dropped as [ $ type , $ value ] ) { $ type = ucfirst ( $ type ) ; $ this -> notify -> note ( "<comment>{$type}</comment> \"{$value}\" <comment>dropped</comment>" ) ; } }
10684	private function bootstrap ( ) { ErrorInterceptor :: registerErrorHandler ( ) ; set_exception_handler ( array ( static :: class , 'handleException' ) ) ; ini_set ( 'default_charset' , 'UTF-8' ) ; mb_internal_encoding ( 'UTF-8' ) ; ini_set ( 'log_errors' , '1' ) ; $ this -> loadConfig ( ) ; $ this -> injector -> setInstance ( Configuration :: class , $ this -> config ) ; $ this -> cachemanager = $ this -> injector -> getInstance ( Cache \ Manager :: class ) ; $ this -> dev = $ this -> config -> dget ( 'site' , 'dev' , true ) ; $ this -> configureAutoloaderAndResolver ( ) ; try { $ this -> path_config -> checkPaths ( ) ; } catch ( PermissionError $ e ) { return $ this -> showPermissionError ( $ e ) ; } $ test = defined ( 'WEDETO_TEST' ) && WEDETO_TEST === 1 ? 'test' : '' ; if ( PHP_SAPI === 'cli' ) ini_set ( 'error_log' , $ this -> path_config -> log . '/error-php-cli' . $ test . '.log' ) ; else ini_set ( 'error_log' , $ this -> path_config -> log . '/error-php' . $ test . '.log' ) ; $ this -> setCreatePermissions ( ) ; LoggerFactory :: setLoggerFactory ( new LoggerFactory ( ) ) ; Autoloader :: setLogger ( LoggerFactory :: getLogger ( [ 'class' => Autoloader :: class ] ) ) ; $ this -> setupLogging ( ) ; if ( $ this -> path_config -> cache ) { $ this -> cachemanager -> setCachePath ( $ this -> path_config -> cache ) ; $ this -> cachemanager -> setHook ( $ this -> config -> dget ( 'cache' , 'expiry' , 60 ) ) ; } $ this -> module_manager = new Module \ Manager ( $ this -> resolver ) ; $ this -> request = Request :: createFromGlobals ( ) ; $ this -> setupPlugins ( ) ; }
10012	public function getSheet ( $ pIndex ) { if ( ! isset ( $ this -> workSheetCollection [ $ pIndex ] ) ) { $ numSheets = $ this -> getSheetCount ( ) ; throw new Exception ( "Your requested sheet index: {$pIndex} is out of bounds. The actual number of sheets is {$numSheets}." ) ; } return $ this -> workSheetCollection [ $ pIndex ] ; }
3829	protected function buildFilterUrl ( $ fragments , $ searchKey ) { @ trigger_error ( sprintf ( '"%1$s" has been deprecated in favor of the "FilterUrlBuilder"' , __METHOD__ ) , E_USER_DEPRECATED ) ; $ url = '' ; $ found = false ; foreach ( $ fragments as $ key => $ value ) { if ( ( $ key == 'language' ) && $ GLOBALS [ 'TL_CONFIG' ] [ 'addLanguageToUrl' ] ) { continue ; } if ( $ key == $ searchKey ) { if ( $ key !== 'auto_item' ) { $ url .= '%s' ; } else { $ url = '%s' . $ url ; } $ found = true ; } else { $ url = $ this -> addUrlParameter ( $ url , $ key , $ value ) ; } } if ( ! $ found ) { if ( $ searchKey !== 'auto_item' ) { $ url .= '%s' ; } else { $ url = '%s' . $ url ; } } return $ url ; }
7887	protected function parse ( ) { $ log = [ ] ; $ pattern = "/\[\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}\].*/" ; preg_match_all ( $ pattern , $ this -> raw , $ headings ) ; $ data = preg_split ( $ pattern , $ this -> raw ) ; if ( $ data [ 0 ] < 1 ) { $ trash = array_shift ( $ data ) ; unset ( $ trash ) ; } foreach ( $ headings as $ heading ) { for ( $ i = 0 , $ j = count ( $ heading ) ; $ i < $ j ; $ i ++ ) { foreach ( $ this -> levels as $ level ) { if ( $ this -> level == $ level || $ this -> level == 'all' ) { if ( strpos ( strtolower ( $ heading [ $ i ] ) , strtolower ( '.' . $ level ) ) ) { $ log [ ] = [ 'level' => $ level , 'header' => $ heading [ $ i ] , 'stack' => $ data [ $ i ] ] ; } } } } } unset ( $ headings ) ; unset ( $ data ) ; return array_reverse ( $ log ) ; }
5083	protected function lookUpResource ( $ aData = [ ] , $ iSegment = 4 ) { $ oUri = Factory :: service ( 'Uri' ) ; $ sIdentifier = $ oUri -> segment ( $ iSegment ) ; $ oInput = Factory :: service ( 'Input' ) ; $ aData = array_merge ( static :: CONFIG_LOOKUP_DATA , $ aData ) ; $ aExpansions = array_filter ( ( array ) $ oInput -> get ( 'expand' ) ) ; if ( $ aExpansions ) { if ( ! array_key_exists ( 'expand' , $ aData ) ) { $ aData [ 'expand' ] = [ ] ; } $ aData [ 'expand' ] = array_merge ( $ aData [ 'expand' ] , $ aExpansions ) ; } switch ( static :: CONFIG_LOOKUP_METHOD ) { case 'ID' : return $ this -> oModel -> getById ( $ sIdentifier , $ aData ) ; break ; case 'SLUG' : return $ this -> oModel -> getBySlug ( $ sIdentifier , $ aData ) ; break ; case 'TOKEN' : return $ this -> oModel -> getByToken ( $ sIdentifier , $ aData ) ; break ; } }
311	private function applyTableAlias ( $ query , $ conditions , $ alias = null ) { if ( $ alias === null ) { $ alias = array_keys ( $ query -> getTablesUsedInFrom ( ) ) [ 0 ] ; } $ prefixedConditions = [ ] ; foreach ( $ conditions as $ columnName => $ columnValue ) { if ( strpos ( $ columnName , '(' ) === false ) { $ columnName = preg_replace ( '/^' . preg_quote ( $ alias ) . '\.(.*)$/' , '$1' , $ columnName ) ; if ( strpos ( $ columnName , '[[' ) === 0 ) { $ prefixedColumn = "{$alias}.{$columnName}" ; } else { $ prefixedColumn = "{$alias}.[[{$columnName}]]" ; } } else { $ prefixedColumn = $ columnName ; } $ prefixedConditions [ $ prefixedColumn ] = $ columnValue ; } return $ prefixedConditions ; }
4206	private function getPropInfo ( Event $ abs , \ ReflectionProperty $ reflectionProperty ) { $ obj = $ abs -> getSubject ( ) ; $ reflectionProperty -> setAccessible ( true ) ; $ className = \ get_class ( $ obj ) ; $ commentInfo = $ this -> getPropCommentInfo ( $ reflectionProperty ) ; $ declaringClassName = $ reflectionProperty -> getDeclaringClass ( ) -> getName ( ) ; $ propInfo = \ array_merge ( static :: $ basePropInfo , array ( 'desc' => $ commentInfo [ 'desc' ] , 'inheritedFrom' => $ declaringClassName !== $ className ? $ declaringClassName : null , 'isStatic' => $ reflectionProperty -> isStatic ( ) , 'type' => $ commentInfo [ 'type' ] , ) ) ; if ( $ reflectionProperty -> isPrivate ( ) ) { $ propInfo [ 'visibility' ] = 'private' ; } elseif ( $ reflectionProperty -> isProtected ( ) ) { $ propInfo [ 'visibility' ] = 'protected' ; } if ( $ abs [ 'collectPropertyValues' ] ) { $ propName = $ reflectionProperty -> getName ( ) ; if ( \ array_key_exists ( $ propName , $ abs [ 'propertyOverrideValues' ] ) ) { $ propInfo [ 'value' ] = $ abs [ 'propertyOverrideValues' ] [ $ propName ] ; $ propInfo [ 'valueFrom' ] = 'debug' ; } else { $ propInfo [ 'value' ] = $ reflectionProperty -> getValue ( $ obj ) ; } } return $ propInfo ; }
9840	public function createSymmetricEncryptedJsonResponse ( int $ status , array $ arrayToJsonify , SharedEncryptionKey $ key , array $ headers = [ ] , string $ version = '1.1' ) : ResponseInterface { if ( empty ( $ headers [ 'Content-Type' ] ) ) { $ headers [ 'Content-Type' ] = 'application/json' ; } $ body = \ json_encode ( $ arrayToJsonify , JSON_PRETTY_PRINT ) ; if ( ! \ is_string ( $ body ) ) { throw new InvalidMessageException ( 'Cannot JSON-encode this message.' ) ; } return $ this -> createSymmetricEncryptedResponse ( $ status , $ body , $ key , $ headers , $ version ) ; }
1045	public static function createFromException ( $ e , $ debug = false , $ internalErrorMessage = null ) { Utils :: invariant ( $ e instanceof Exception || $ e instanceof Throwable , 'Expected exception, got %s' , Utils :: getVariableType ( $ e ) ) ; $ internalErrorMessage = $ internalErrorMessage ? : self :: $ internalErrorMessage ; if ( $ e instanceof ClientAware ) { $ formattedError = [ 'message' => $ e -> isClientSafe ( ) ? $ e -> getMessage ( ) : $ internalErrorMessage , 'extensions' => [ 'category' => $ e -> getCategory ( ) , ] , ] ; } else { $ formattedError = [ 'message' => $ internalErrorMessage , 'extensions' => [ 'category' => Error :: CATEGORY_INTERNAL , ] , ] ; } if ( $ e instanceof Error ) { $ locations = Utils :: map ( $ e -> getLocations ( ) , static function ( SourceLocation $ loc ) { return $ loc -> toSerializableArray ( ) ; } ) ; if ( ! empty ( $ locations ) ) { $ formattedError [ 'locations' ] = $ locations ; } if ( ! empty ( $ e -> path ) ) { $ formattedError [ 'path' ] = $ e -> path ; } if ( ! empty ( $ e -> getExtensions ( ) ) ) { $ formattedError [ 'extensions' ] = $ e -> getExtensions ( ) + $ formattedError [ 'extensions' ] ; } } if ( $ debug ) { $ formattedError = self :: addDebugEntries ( $ formattedError , $ e , $ debug ) ; } return $ formattedError ; }
6499	public function beforeStep ( Scope \ StepScope $ scope ) { self :: $ pageUrl = $ this -> getCurrentUrl ( ) ; $ _GET [ 'q' ] = ltrim ( parse_url ( static :: $ pageUrl ) [ 'path' ] , '/' ) ; drupal_path_initialize ( ) ; }
9542	public function runSyncAction ( $ syncActionBaseUrl , $ component , $ action , array $ configData ) { $ uriParts = [ ] ; if ( $ this -> super ) { $ uriParts [ ] = $ this -> super ; } $ uriParts [ ] = $ component ; $ uriParts [ ] = 'action' ; $ uriParts [ ] = $ action ; $ uri = rtrim ( $ syncActionBaseUrl , '/' ) . '/' . implode ( '/' , $ uriParts ) ; $ body = [ 'configData' => $ configData , ] ; try { $ request = new Request ( 'POST' , $ uri , [ ] , json_encode ( $ body ) ) ; $ response = $ this -> guzzle -> send ( $ request ) ; } catch ( RequestException $ e ) { throw new ClientException ( $ e -> getMessage ( ) , 0 , $ e ) ; } return $ this -> decodeResponse ( $ response ) ; }
6314	public function setReferencedColumns ( $ columns ) { if ( ! is_array ( $ columns ) ) { $ columns = array ( $ columns ) ; } $ this -> referencedColumns = $ columns ; return $ this ; }
12526	static public function cleanup ( $ opts = array ( ) ) { if ( strtoupper ( substr ( PHP_OS , 0 , 3 ) ) == 'WIN' ) { exec ( 'tasklist /FO CSV' , $ runningProcesses , $ return_var ) ; $ runningProcesses = array_map ( function ( $ line ) { $ cols = explode ( ',' , $ line ) ; return trim ( $ cols [ 1 ] , '"' ) ; } , $ runningProcesses ) ; unset ( $ runningProcesses [ 0 ] ) ; sort ( $ runningProcesses ) ; unset ( $ runningProcesses [ 0 ] ) ; } else { exec ( 'ps -e -o pid' , $ runningProcesses , $ return_var ) ; } if ( $ return_var != 0 ) { pake_echo_error ( "Could not get list of processes to remove stale lock files" ) ; return ; } $ lockDir = self :: lockDir ( $ opts ) ; foreach ( glob ( $ lockDir . "/*_W.lock" ) as $ writeLock ) { $ pid = file_get_contents ( $ writeLock ) ; if ( ! in_array ( $ pid , $ runningProcesses ) ) { pake_unlink ( $ writeLock ) ; } } foreach ( glob ( $ lockDir . "/*_R/*.lock" ) as $ readLock ) { $ pid = file_get_contents ( $ readLock ) ; if ( ! in_array ( $ pid , $ runningProcesses ) ) { pake_unlink ( $ readLock ) ; } } }
7121	private function createFindBySubjectQueryBuilder ( ) { $ as = $ this -> getAlias ( ) ; $ qb = $ this -> createQueryBuilder ( ) ; return $ qb -> andWhere ( $ qb -> expr ( ) -> eq ( $ as . '.subjectIdentity.provider' , ':provider' ) ) -> andWhere ( $ qb -> expr ( ) -> eq ( $ as . '.subjectIdentity.identifier' , ':identifier' ) ) ; }
8359	public function dashboards ( Environment $ environment , $ size ) { $ dashboards = null ; if ( $ this -> tokenStorage -> getToken ( ) -> getUser ( ) !== null ) { $ dashboardsAvailable = array ( 'ContactForm' , 'Email' , 'Events' , 'ExceptionChecker' , 'GiftVoucher' , 'PageEdit' , 'Payment' , 'PurchaseCredits' , 'Site' , 'User' ) ; foreach ( $ dashboardsAvailable as $ dashboardAvailable ) { if ( is_dir ( $ this -> container -> getParameter ( 'kernel.root_dir' ) . '/../vendor/c975l/' . strtolower ( $ dashboardAvailable ) . '-bundle' ) && $ this -> configService -> hasParameter ( 'c975L' . $ dashboardAvailable . '.roleNeeded' ) && $ this -> container -> get ( 'security.authorization_checker' ) -> isGranted ( $ this -> configService -> getParameter ( 'c975L' . $ dashboardAvailable . '.roleNeeded' ) ) ) { $ dashboards [ ] = strtolower ( $ dashboardAvailable ) ; } } } return $ environment -> render ( '@c975LToolbar/dashboards.html.twig' , array ( 'dashboards' => $ dashboards , 'size' => $ size , ) ) ; }
4335	public function onOutput ( Event $ event ) { if ( ! $ event [ 'isTarget' ] ) { return ; } $ this -> data = $ this -> debug -> getData ( ) ; $ this -> closeOpenGroups ( ) ; foreach ( $ this -> data [ 'logSummary' ] as & $ log ) { $ this -> removeHideIfEmptyGroups ( $ log ) ; $ this -> uncollapseErrors ( $ log ) ; } $ this -> removeHideIfEmptyGroups ( $ this -> data [ 'log' ] ) ; $ this -> uncollapseErrors ( $ this -> data [ 'log' ] ) ; $ this -> debug -> setData ( $ this -> data ) ; }
11938	public function findAll ( $ params = [ ] ) { $ return = $ this -> populateRecords ( $ this -> find ( $ params ) -> all ( $ this -> interface -> db ) ) ; return $ return ; }
3562	protected function hasMutator ( $ value , $ dir = 'setter' , $ type = null ) { return ( bool ) $ this -> getMutator ( $ value , $ dir , $ type ) ; }
7201	public function getUnit ( bool $ ati = false ) : float { return $ ati ? $ this -> ati ( $ this -> unit ) : $ this -> unit ; }
6238	public function write ( string $ content , bool $ append = false , int $ mode = LOCK_EX ) : self { $ this -> checkFileWritePermissions ( ) ; if ( ! $ this -> storage -> writeFile ( $ content , $ append , $ mode ) ) { throw new AccessDeniedException ( 'unable to write file-content' , 403 ) ; } return $ this ; }
10952	protected function write ( Response $ response , $ body ) : Response { $ response -> getBody ( ) -> write ( ( string ) $ body ) ; return $ response ; }
8527	private function _convertListFinancialEventGroups ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'ListFinancialEventGroups' ; if ( $ request -> isSetSellerId ( ) ) { $ parameters [ 'SellerId' ] = $ request -> getSellerId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } if ( $ request -> isSetMaxResultsPerPage ( ) ) { $ parameters [ 'MaxResultsPerPage' ] = $ request -> getMaxResultsPerPage ( ) ; } if ( $ request -> isSetFinancialEventGroupStartedAfter ( ) ) { $ parameters [ 'FinancialEventGroupStartedAfter' ] = $ request -> getFinancialEventGroupStartedAfter ( ) ; } if ( $ request -> isSetFinancialEventGroupStartedBefore ( ) ) { $ parameters [ 'FinancialEventGroupStartedBefore' ] = $ request -> getFinancialEventGroupStartedBefore ( ) ; } return $ parameters ; }
3778	protected function getLabel ( ) { if ( null === ( $ attribute = $ this -> getFilteredAttribute ( ) ) ) { return null ; } if ( $ label = $ this -> get ( 'label' ) ) { return $ label ; } return $ attribute -> getName ( ) ; }
5624	public function setCoordinates ( $ x = false , $ y = false ) { if ( ( $ x === false ) || ( $ y === false ) ) { $ this -> x = $ this -> y = false ; return ; } $ this -> x = ( integer ) $ x ; $ this -> y = ( integer ) $ y ; }
5281	public function selectFunc ( $ func , $ field , $ alias = null ) { $ field = "$func({$field})" ; if ( ! is_null ( $ alias ) ) { $ field .= " as {$alias}" ; } $ this -> statements [ 'select' ] [ ] = $ field ; return $ this ; }
5679	protected function noResponse ( ) { $ this -> transport_error = 'No page fetched yet' ; $ this -> raw = false ; $ this -> sent = false ; $ this -> headers = false ; $ this -> method = 'GET' ; $ this -> url = false ; $ this -> request_data = false ; }
3313	protected function appendAppIdAndBucketIfEmpty ( array $ options = [ ] ) { $ options [ 'appid' ] = empty ( $ options [ 'appid' ] ) ? $ this -> authorization -> getAppId ( ) : $ options [ 'appid' ] ; $ options [ 'bucket' ] = empty ( $ options [ 'bucket' ] ) ? $ this -> authorization -> getBucket ( ) : $ options [ 'bucket' ] ; return $ options ; }
1052	public static function build ( $ source , ? callable $ typeConfigDecorator = null , array $ options = [ ] ) { $ doc = $ source instanceof DocumentNode ? $ source : Parser :: parse ( $ source ) ; return self :: buildAST ( $ doc , $ typeConfigDecorator , $ options ) ; }
3990	private function getInputScreens ( ) { $ combinations = $ this -> getCombinations ( ) ; if ( null === $ combinations ) { return [ ] ; } $ screenIds = array_map ( function ( $ combination ) { return $ combination [ 'dca_id' ] ; } , $ combinations [ 'byName' ] ) ; if ( $ this -> cache -> contains ( $ cacheKey = 'screens_' . implode ( ',' , $ screenIds ) ) ) { return $ this -> cache -> fetch ( $ cacheKey ) ; } $ screens = $ this -> inputScreens -> fetchInputScreens ( $ screenIds ) ; $ this -> cache -> save ( $ cacheKey , $ screens ) ; return $ screens ; }
2130	protected function markModified ( ) { if ( $ this -> blnIsModified === true ) { return ; } $ this -> blnIsModified = true ; $ this -> strTop = '' ; $ this -> strBottom = '' ; $ this -> Files = Files :: getInstance ( ) ; if ( static :: $ blnHasLcf ) { $ strMode = 'top' ; $ resFile = fopen ( $ this -> strRootDir . '/system/config/localconfig.php' , 'rb' ) ; while ( ! feof ( $ resFile ) ) { $ strLine = fgets ( $ resFile ) ; $ strTrim = trim ( $ strLine ) ; if ( $ strTrim == '?>' ) { continue ; } if ( $ strTrim == '### INSTALL SCRIPT START ###' ) { $ strMode = 'data' ; continue ; } if ( $ strTrim == '### INSTALL SCRIPT STOP ###' ) { $ strMode = 'bottom' ; continue ; } if ( $ strMode == 'top' ) { $ this -> strTop .= $ strLine ; } elseif ( $ strMode == 'bottom' ) { $ this -> strBottom .= $ strLine ; } elseif ( $ strTrim != '' ) { $ arrChunks = array_map ( 'trim' , explode ( '=' , $ strLine , 2 ) ) ; $ this -> arrData [ $ arrChunks [ 0 ] ] = $ arrChunks [ 1 ] ; } } fclose ( $ resFile ) ; } }
2607	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ ioOptions = $ this -> api -> getImageOptimizationDefaultConfigOptions ( $ activeVersion ) -> data -> attributes ; if ( ! $ ioOptions ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to fetch image optimization default config options.' ] ) ; } return $ result -> setData ( [ 'status' => true , 'io_options' => $ ioOptions ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
11783	public function add ( $ title , $ description , $ pageUrl , $ iconUrl , $ comment = '' ) { $ params = [ 'title' => $ title , 'description' => $ description , 'page_url' => $ pageUrl , 'icon_url' => $ iconUrl , ] ; if ( $ comment !== '' ) { $ params [ 'comment' ] = $ comment ; } return $ this -> parseJSON ( 'json' , [ self :: API_ADD , $ params ] ) ; }
5752	public function getObjects ( array $ whereColumnsInfo = null ) : array { $ roles = [ ] ; if ( null !== $ records = $ this -> select ( "*" , $ whereColumnsInfo ) ) { foreach ( $ records as $ record ) { $ roles [ ] = $ this -> buildRole ( ( int ) $ record [ 'id' ] , $ record [ 'role' ] , new \ DateTimeImmutable ( $ record [ 'created' ] ) ) ; } } return $ roles ; }
7818	public function create ( ) : ? array { $ body = Body :: json ( [ 'name' => $ this -> name , 'event' => $ this -> event , 'device_id' => $ this -> device , 'filter_type' => '' , 'filter' => '' , 'method' => 'http' , 'action' => $ this -> url , 'secret' => $ this -> secret , ] ) ; $ response = Request :: post ( $ this -> baseUrl . 'callback' , [ ] , $ body ) ; if ( $ response -> code != 200 ) { if ( ! empty ( $ response -> body -> message ) ) { Log :: error ( $ response -> body -> message ) ; } } return [ 'code' => $ response -> code , 'message' => ( $ response -> code == 200 ) ? 'OK' : $ response -> body -> message ?? '' , 'data' => $ response -> body , ] ; }
911	public function addBlank ( ) { $ matched = Preg :: match ( '/^([ \t]*\*)[^\r\n]*(\r?\n)$/' , $ this -> content , $ matches ) ; if ( 1 !== $ matched ) { return ; } $ this -> content .= $ matches [ 1 ] . $ matches [ 2 ] ; }
1555	protected function queryValidatorWithoutSearch ( ) { return $ this -> validatorFactory ( ) -> queryParameters ( $ this -> queryRulesWithoutSearch ( ) , $ this -> queryMessages ( ) , $ this -> queryCustomAttributes ( ) , function ( Validator $ validator ) { return $ this -> conditionalQuery ( $ validator ) ; } ) ; }
1849	protected function generateLink ( $ strLink , $ objArticle , $ blnAddArchive = false , $ blnIsReadMore = false ) { if ( $ objArticle -> source != 'external' ) { return sprintf ( '<a href="%s" title="%s" itemprop="url"><span itemprop="headline">%s</span>%s</a>' , News :: generateNewsUrl ( $ objArticle , $ blnAddArchive ) , StringUtil :: specialchars ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'readMore' ] , $ objArticle -> headline ) , true ) , $ strLink , ( $ blnIsReadMore ? '<span class="invisible"> ' . $ objArticle -> headline . '</span>' : '' ) ) ; } if ( substr ( $ objArticle -> url , 0 , 7 ) == 'mailto:' ) { $ strArticleUrl = StringUtil :: encodeEmail ( $ objArticle -> url ) ; } else { $ strArticleUrl = ampersand ( $ objArticle -> url ) ; } return sprintf ( '<a href="%s" title="%s"%s itemprop="url"><span itemprop="headline">%s</span></a>' , $ strArticleUrl , StringUtil :: specialchars ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'open' ] , $ strArticleUrl ) ) , ( $ objArticle -> target ? ' target="_blank"' : '' ) , $ strLink ) ; }
756	protected function renderImage ( $ code ) { if ( isset ( $ this -> imageLibrary ) ) { $ imageLibrary = $ this -> imageLibrary ; } else { $ imageLibrary = Captcha :: checkRequirements ( ) ; } if ( $ imageLibrary === 'gd' ) { return $ this -> renderImageByGD ( $ code ) ; } elseif ( $ imageLibrary === 'imagick' ) { return $ this -> renderImageByImagick ( $ code ) ; } throw new InvalidConfigException ( "Defined library '{$imageLibrary}' is not supported" ) ; }
8963	private static function extractDateCriteria ( $ key , array $ criteria ) { $ date = ( ! empty ( $ criteria [ $ key ] ) ) ? $ criteria [ $ key ] : null ; if ( is_string ( $ date ) ) { $ date = \ DateTime :: createFromFormat ( 'Y-m-d' , $ date ) ; } if ( false === $ date ) { throw new InvalidArgumentException ( sprintf ( 'Invalid date/time format provided "%s", expected "%s", or instance of \DateTime class.' , $ criteria [ $ key ] , 'Y-m-d' ) ) ; } return $ date ; }
6753	public static function installWebServer ( ) { $ appPath = __DIR__ . '/../../../..' ; self :: createFolderIfNotExists ( "$appPath/web" ) ; self :: createCopy ( __DIR__ , 'app.php' , "$appPath/web" , 'app.php' ) ; self :: createCopy ( __DIR__ , 'app_dev.php' , "$appPath/web" , 'app_dev.php' ) ; }
9578	protected function registerPlugin ( $ name ) { $ view = $ this -> getView ( ) ; if ( $ this -> materializeAsset ) { MaterializeAsset :: register ( $ view ) ; } if ( $ this -> customAsset ) { MaterializeCustomAsset :: register ( $ view ) ; } $ id = $ this -> options [ 'id' ] ; if ( $ this -> clientOptions !== false ) { $ options = empty ( $ this -> clientOptions ) ? '' : Json :: encode ( $ this -> clientOptions ) ; $ js = "jQuery('#$id').$name($options);" ; $ view -> registerJs ( $ js ) ; } $ this -> registerClientEvents ( ) ; }
3481	private static function includeConfigurationFile ( ) { static $ included = false ; if ( $ included ) { return ; } $ file = __DIR__ . '/config.php' ; if ( ! file_exists ( $ file ) ) { print sprintf ( 'The configuration file "%s" was not found.%sPlease copy %s/config.php.dist to %s/config.php and modify new file for set own parameters.%s' , $ file , PHP_EOL , __DIR__ , __DIR__ , PHP_EOL ) ; exit ( 1 ) ; } $ included = true ; include_once $ file ; }
7739	public function deserialize ( $ data , $ entity ) { if ( ! $ this -> container -> has ( 'hydra.serializer' ) ) { throw new \ LogicException ( 'The HydraBundle is not registered in your application.' ) ; } $ serializer = $ this -> container -> get ( 'hydra.serializer' ) ; if ( is_object ( $ entity ) ) { return $ serializer -> deserializeIntoEntity ( $ data , $ entity ) ; } return $ serializer -> deserialize ( $ data , $ entity , self :: FORMAT ) ; }
11072	public function setFloat ( string $ key , $ value , float $ ignoredDefaultValue = null ) { $ this -> set ( $ key , ( float ) $ value , $ ignoredDefaultValue ) ; return $ this ; }
247	public function init ( ) { parent :: init ( ) ; register_shutdown_function ( [ $ this , 'close' ] ) ; if ( $ this -> getIsActive ( ) ) { Yii :: warning ( 'Session is already started' , __METHOD__ ) ; $ this -> updateFlashCounters ( ) ; } }
3765	private function mapTranslations ( $ array , $ domain , StaticTranslator $ translator , $ baseKey = '' ) { foreach ( $ array as $ key => $ value ) { $ newKey = ( $ baseKey ? $ baseKey . '.' : '' ) . $ key ; if ( is_array ( $ value ) ) { $ this -> mapTranslations ( $ value , $ domain , $ translator , $ newKey ) ; } else { $ translator -> setValue ( $ newKey , $ value , $ domain ) ; } } }
5102	public function asSelect ( ICmdSelect $ select ) { $ this -> setPart ( CmdInsert :: PART_VALUES , false ) ; return $ this -> setPart ( CmdInsert :: PART_AS , $ select -> assemble ( ) , $ select -> bind ( ) ) ; }
345	protected static function setActivePlaceholder ( $ model , $ attribute , & $ options = [ ] ) { if ( isset ( $ options [ 'placeholder' ] ) && $ options [ 'placeholder' ] === true ) { $ attribute = static :: getAttributeName ( $ attribute ) ; $ options [ 'placeholder' ] = $ model -> getAttributeLabel ( $ attribute ) ; } }
8047	public function send ( $ data ) { $ serialized = serialize ( $ data ) ; $ hdr = pack ( 'N' , strlen ( $ serialized ) ) ; $ buffer = $ hdr . $ serialized ; unset ( $ serialized ) ; unset ( $ hdr ) ; $ total = strlen ( $ buffer ) ; while ( $ total > 0 ) { $ sent = socket_write ( $ this -> socket , $ buffer ) ; if ( $ sent === FALSE ) { throw new SimpleSocketException ( 'Sending failed with: ' . socket_strerror ( socket_last_error ( $ this -> socket ) ) ) ; } $ total -= $ sent ; $ buffer = substr ( $ buffer , $ sent ) ; } }
3372	private function getFormFactory ( ContainerInterface $ services ) { $ elements = null ; if ( $ services -> has ( 'FormElementManager' ) ) { $ elements = $ services -> get ( 'FormElementManager' ) ; } return new Factory ( $ elements ) ; }
3363	private function loadChunk ( ) { $ portion = $ this -> pdGetDataChunk ( $ this -> api , $ this -> options , $ this -> reverse ) ; $ this -> options = $ portion [ 'params' ] ; $ this -> nextPageParams = $ portion [ 'nextParams' ] ; $ this -> prevPageParams = $ portion [ 'prevParams' ] ; if ( $ portion [ 'data' ] ) { $ this -> container = array_merge ( $ this -> container , $ portion [ 'data' ] ) ; } if ( ! count ( $ portion [ 'params' ] ) ) { $ this -> fullyLoaded = true ; } }
3766	private function addInputScreenTranslations ( StaticTranslator $ translator , $ inputScreen , $ containerName ) { $ currentLocale = $ GLOBALS [ 'TL_LANGUAGE' ] ; foreach ( $ inputScreen [ 'legends' ] as $ legendName => $ legendInfo ) { foreach ( $ legendInfo [ 'label' ] as $ langCode => $ label ) { $ translator -> setValue ( $ legendName . '_legend' , $ label , $ containerName , $ langCode ) ; if ( $ currentLocale === $ langCode ) { $ translator -> setValue ( $ legendName . '_legend' , $ label , $ containerName ) ; } } } }
6452	public function findLabels ( $ text ) { $ xpath = new XPath \ InaccurateText ( '//label[@for]' , $ this -> getWorkingElement ( ) ) ; $ labels = [ ] ; foreach ( $ xpath -> text ( $ text ) -> findAll ( ) as $ label ) { $ labels [ $ label -> getAttribute ( 'for' ) ] = $ label ; } return $ labels ; }
9504	private function listen ( ) { $ this -> emitter -> on ( 'peridot.configure' , [ $ this , 'onPeridotConfigure' ] ) ; $ this -> emitter -> on ( 'peridot.start' , [ $ this , 'onPeridotStart' ] ) ; $ this -> emitter -> on ( 'peridot.end' , [ $ this , 'onPeridotEnd' ] ) ; }
3618	public function setFanModeOnWithTimer ( $ mode , $ serial_number = NULL ) { $ modes = explode ( ',' , $ mode ) ; $ mode = $ modes [ 0 ] ; $ timer = ( int ) $ modes [ 1 ] ; return $ this -> _setFanMode ( $ mode , NULL , $ timer , $ serial_number ) ; }
12766	public function run ( ) : void { $ this -> isRan = true ; foreach ( $ this -> getAll ( ) as $ header ) { header ( $ header ) ; } }
9973	public function setFormatCode ( $ pValue ) { if ( $ pValue == '' ) { $ pValue = self :: FORMAT_GENERAL ; } if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'formatCode' => $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> formatCode = $ pValue ; $ this -> builtInFormatCode = self :: builtInFormatCodeIndex ( $ pValue ) ; } return $ this ; }
3425	public function getById ( $ id ) { if ( ! $ id || $ this -> queryShouldBeStopped ) { return false ; } $ this -> sort = [ ] ; $ this -> filter [ 'ID' ] = $ id ; return $ this -> getList ( ) -> first ( null , false ) ; }
2807	public function purgeProfilesAction ( ) { $ count = $ this -> getService ( ) -> purgeAllProfiles ( ) ; $ this -> getSession ( ) -> addSuccess ( $ this -> __ ( '%d request profiles were deleted' , $ count ) ) ; $ this -> _redirect ( '/' ) ; }
4148	protected function findExceptions ( $ response ) { $ response = $ response [ 'body' ] ; $ data = json_decode ( $ response , true ) ; if ( isset ( $ response [ 0 ] ) && $ response [ 0 ] !== '{' && $ response [ 0 ] !== '[' && ! $ data ) { if ( strpos ( $ response , 'oauth_token=' ) !== false ) { parse_str ( $ response , $ data ) ; } if ( empty ( $ data ) || ! is_array ( $ data ) ) { throw new TwitterException ( $ response , 0 ) ; } return json_encode ( $ data ) ; } if ( ! empty ( $ data [ 'errors' ] ) || ! empty ( $ data [ 'error' ] ) ) { if ( ! empty ( $ data [ 'errors' ] ) ) { $ data = current ( $ data [ 'errors' ] ) ; } if ( empty ( $ data [ 'message' ] ) && ! empty ( $ data [ 'error' ] ) ) { $ data [ 'message' ] = $ data [ 'error' ] ; } if ( ! isset ( $ data [ 'code' ] ) || empty ( $ data [ 'code' ] ) ) { $ data [ 'code' ] = 0 ; } throw new TwitterException ( $ data [ 'message' ] , $ data [ 'code' ] ) ; } unset ( $ data ) ; return $ response ; }
4246	private function logRequest ( ) { $ this -> logRequestHeaders ( ) ; if ( $ this -> debug -> getCfg ( 'logEnvInfo.cookies' ) ) { $ cookieVals = $ _COOKIE ; \ ksort ( $ cookieVals , SORT_NATURAL ) ; $ this -> debug -> log ( '$_COOKIE' , $ cookieVals ) ; } $ noBody = ! isset ( $ _SERVER [ 'REQUEST_METHOD' ] ) || \ in_array ( $ _SERVER [ 'REQUEST_METHOD' ] , array ( 'CONNECT' , 'GET' , 'HEAD' , 'OPTIONS' , 'TRACE' ) ) ; if ( $ this -> debug -> getCfg ( 'logEnvInfo.post' ) && ! $ noBody ) { if ( $ _POST ) { $ this -> debug -> log ( '$_POST' , $ _POST ) ; } else { $ input = \ file_get_contents ( 'php://input' ) ; if ( $ input ) { $ this -> debug -> log ( 'php://input' , $ input ) ; } elseif ( isset ( $ _SERVER [ 'REQUEST_METHOD' ] ) && empty ( $ _FILES ) ) { $ this -> debug -> warn ( $ _SERVER [ 'REQUEST_METHOD' ] . ' request with no body' ) ; } } if ( ! empty ( $ _FILES ) ) { $ this -> debug -> log ( '$_FILES' , $ _FILES ) ; } } }
11752	public function open ( $ msgId , $ index ) { $ params = [ 'msg_data_id' => $ msgId , 'index' => $ index , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_OPEN_COMMENT , $ params ] ) ; }
1491	public static function camelize ( $ data ) { return collect ( $ data ) -> mapWithKeys ( function ( $ value , $ key ) { $ key = Str :: camelize ( $ key ) ; if ( is_array ( $ value ) ) { return [ $ key => static :: camelize ( $ value ) ] ; } return [ $ key => $ value ] ; } ) -> all ( ) ; }
3952	protected function isArrayEmpty ( $ arrArray ) { if ( empty ( $ arrArray ) ) { return true ; } if ( is_array ( $ arrArray ) && array_key_exists ( 'value' , $ arrArray ) ) { return $ this -> isArrayEmpty ( $ arrArray [ 'value' ] ) ; } if ( is_array ( $ arrArray ) ) { foreach ( $ arrArray as $ value ) { if ( is_array ( $ value ) ) { return $ this -> isArrayEmpty ( $ value ) ; } elseif ( ! empty ( $ value ) ) { return false ; } } } return false ; }
7178	public function isValidType ( $ type ) { return in_array ( $ type , array ( self :: ANY , self :: FIXED_LINE , self :: MOBILE , self :: PAGER , self :: PERSONAL_NUMBER , self :: PREMIUM_RATE , self :: SHARED_COST , self :: TOLL_FREE , self :: UAN , self :: VOIP , self :: VOICEMAIL , ) , true ) ; }
28	public static function register ( IOInterface $ io = null ) { set_error_handler ( array ( __CLASS__ , 'handle' ) ) ; error_reporting ( E_ALL | E_STRICT ) ; self :: $ io = $ io ; }
1332	protected function readWithFilters ( $ record , EncodingParametersInterface $ parameters ) { $ query = $ this -> newQuery ( ) -> whereKey ( $ record -> getKey ( ) ) ; $ this -> applyFilters ( $ query , collect ( $ parameters -> getFilteringParameters ( ) ) ) ; return $ query -> exists ( ) ? $ record : null ; }
12087	public static function create ( $ validator , $ command ) { static $ cache = [ ] ; $ cacheKey = $ validator ; if ( isset ( $ cache [ $ cacheKey ] ) ) { $ class = $ cache [ $ cacheKey ] [ 'class' ] ; $ validator = $ cache [ $ cacheKey ] [ 'validator' ] ; } else { if ( false === strpos ( $ validator , '.' ) ) { $ class = __NAMESPACE__ . '\\' . String :: convertToCamelCase ( $ validator ) ; } else { $ class = explode ( '.' , $ validator ) ; $ class = array_map ( array ( 'In2pire\\Component\\Utility\\Text' , 'convertToCamelCase' ) , $ class ) ; $ class = implode ( '\\' , $ class ) ; $ validator = substr ( $ validator , strrpos ( $ validator , '.' ) + 1 ) ; } $ cache [ $ cacheKey ] = [ 'class' => $ class , 'validator' => $ validator ] ; } if ( ! class_exists ( $ class ) ) { throw new \ RuntimeException ( 'Unknow validator ' . $ cacheKey ) ; } return new $ class ( $ command ) ; }
11344	public function removeField ( $ name ) { for ( $ i = 0 ; $ i < count ( $ this -> fields ) ; $ i ++ ) { if ( $ this -> fields [ $ i ] -> getName ( ) == $ name ) { array_splice ( $ this -> fields , $ i , 1 ) ; break ; } } }
1066	private function doTypesConflict ( OutputType $ type1 , OutputType $ type2 ) { if ( $ type1 instanceof ListOfType ) { return $ type2 instanceof ListOfType ? $ this -> doTypesConflict ( $ type1 -> getWrappedType ( ) , $ type2 -> getWrappedType ( ) ) : true ; } if ( $ type2 instanceof ListOfType ) { return $ type1 instanceof ListOfType ? $ this -> doTypesConflict ( $ type1 -> getWrappedType ( ) , $ type2 -> getWrappedType ( ) ) : true ; } if ( $ type1 instanceof NonNull ) { return $ type2 instanceof NonNull ? $ this -> doTypesConflict ( $ type1 -> getWrappedType ( ) , $ type2 -> getWrappedType ( ) ) : true ; } if ( $ type2 instanceof NonNull ) { return $ type1 instanceof NonNull ? $ this -> doTypesConflict ( $ type1 -> getWrappedType ( ) , $ type2 -> getWrappedType ( ) ) : true ; } if ( Type :: isLeafType ( $ type1 ) || Type :: isLeafType ( $ type2 ) ) { return $ type1 !== $ type2 ; } return false ; }
4061	public function getLongMessage ( $ glue = ' ' ) { $ messages = array ( ) ; $ exception = $ this ; do { $ messages [ ] = $ exception -> getMessage ( ) ; } while ( null !== ( $ exception = $ exception -> getPrevious ( ) ) ) ; return implode ( $ glue , $ messages ) ; }
2001	private function getFiles ( FileUpload $ uploader ) : array { $ files = $ uploader -> uploadTo ( 'system/tmp' ) ; if ( \ count ( $ files ) < 1 ) { throw new \ RuntimeException ( $ this -> translator -> trans ( 'ERR.all_fields' , [ ] , 'contao_default' ) ) ; } foreach ( $ files as & $ file ) { $ extension = pathinfo ( $ file , PATHINFO_EXTENSION ) ; if ( 'csv' !== $ extension ) { throw new \ RuntimeException ( sprintf ( $ this -> translator -> trans ( 'ERR.filetype' , [ ] , 'contao_default' ) , $ extension ) ) ; } $ file = $ this -> projectDir . '/' . $ file ; } return $ files ; }
10054	public function setDataValues ( $ dataValues ) { $ this -> dataValues = Functions :: flattenArray ( $ dataValues ) ; $ this -> pointCount = count ( $ dataValues ) ; return $ this ; }
10358	public static function error ( int $ code , string $ message , string $ file , int $ line ) : bool { if ( ( error_reporting ( ) & $ code ) !== 0 ) { if ( DEVELOPMENT == false && $ code == 8 ) { $ error [ 'code' ] = $ code ; $ error [ 'message' ] = $ message ; $ error [ 'file' ] = $ file ; $ error [ 'line' ] = $ line ; $ error [ 'type' ] = 'ErrorException: ' ; $ codes = array ( E_USER_NOTICE => 'Notice' , ) ; $ error [ 'type' ] .= in_array ( $ error [ 'code' ] , array_keys ( $ codes ) ) ? $ codes [ $ error [ 'code' ] ] : 'Unknown Error' ; ErrorHandler :: writeLogs ( "{$error['type']}: {$error['message']} in {$error['file']} at line {$error['line']}" ) ; } else { throw new \ ErrorException ( $ message , $ code , 0 , $ file , $ line ) ; } } return true ; }
9903	public function updateCellReference ( $ pCellRange = 'A1' , $ pBefore = 'A1' , $ pNumCols = 0 , $ pNumRows = 0 ) { if ( strpos ( $ pCellRange , '!' ) !== false ) { return $ pCellRange ; } elseif ( ! Coordinate :: coordinateIsRange ( $ pCellRange ) ) { return $ this -> updateSingleCellReference ( $ pCellRange , $ pBefore , $ pNumCols , $ pNumRows ) ; } elseif ( Coordinate :: coordinateIsRange ( $ pCellRange ) ) { return $ this -> updateCellRange ( $ pCellRange , $ pBefore , $ pNumCols , $ pNumRows ) ; } return $ pCellRange ; }
9064	public function attachShared ( SharedEventManagerInterface $ events ) { $ events -> attach ( 'Zend\Mvc\Application' , MvcEvent :: EVENT_BOOTSTRAP , array ( $ this , 'onMvcBootstrapLast' ) , - 100000 ) ; $ events -> attach ( 'Zend\Mvc\Application' , MvcEvent :: EVENT_RENDER , array ( $ this , 'onRenderAddPathStacks' ) , - 900 ) ; $ events -> attach ( 'Zend\Mvc\Application' , MvcEvent :: EVENT_RENDER , array ( $ this , 'onRenderSpecLayout' ) , - 1000 ) ; }
7010	private function formatN ( & $ str ) { if ( strstr ( $ str , '%N' ) ) { $ wdn = $ this -> weekDayNum ( ) ; $ str = str_replace ( '%N' , $ wdn == 0 ? 7 : $ wdn , $ str ) ; } }
5770	public function getLoggedInAdministrator ( ) : Administrator { if ( ! isset ( $ _SESSION [ SlimPostgres :: SESSION_KEY_ADMINISTRATOR_ID ] ) ) { throw new \ Exception ( "No one is logged in" ) ; } if ( null === $ administrator = ( AdministratorsEntityMapper :: getInstance ( ) ) -> getObjectById ( $ _SESSION [ SlimPostgres :: SESSION_KEY_ADMINISTRATOR_ID ] ) ) { unset ( $ _SESSION [ SlimPostgres :: SESSION_KEY_ADMINISTRATOR_ID ] ) ; throw new \ Exception ( "Invalid administrator id " . $ _SESSION [ SlimPostgres :: SESSION_KEY_ADMINISTRATOR_ID ] . " in session" ) ; } return $ administrator ; }
12490	public static function select ( $ select ) { if ( gettype ( $ select ) == "array" ) { foreach ( $ select as $ key => $ field ) { if ( $ field instanceof Key ) { $ alias = '"' . $ field . '"' ; $ field = self :: field ( $ field ) ; $ select [ $ key ] = "{$field} as {$alias}" ; } } $ select = implode ( ", " , $ select ) ; } elseif ( gettype ( $ select ) != "string" ) { throw new ClusterpointException ( "\"->select()\" function: passed parametr is not in valid format." , 9002 ) ; } return $ select ; }
2108	public static function findByRelatedTableAndIds ( $ strTable , array $ arrIds , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ objDatabase = Database :: getInstance ( ) ; $ objResult = $ objDatabase -> prepare ( "SELECT * FROM $t WHERE $t.id IN (SELECT pid FROM tl_opt_in_related WHERE relTable=? AND relId IN(" . implode ( ',' , array_map ( '\intval' , $ arrIds ) ) . ")) ORDER BY $t.createdOn DESC" ) -> execute ( $ strTable , $ arrIds ) ; if ( $ objResult -> numRows < 1 ) { return null ; } $ arrModels = array ( ) ; $ objRegistry = Registry :: getInstance ( ) ; while ( $ objResult -> next ( ) ) { if ( $ objOptIn = $ objRegistry -> fetch ( $ t , $ objResult -> id ) ) { $ arrModels [ ] = $ objOptIn ; } else { $ arrModels [ ] = new static ( $ objResult -> row ( ) ) ; } } return static :: createCollection ( $ arrModels , $ t ) ; }
5086	public function startTransaction ( ) : bool { if ( $ this -> isInTransaction ) throw new AlreadyInTransactionException ( ) ; $ this -> isInTransaction = $ this -> executeDirect ( 'START TRANSACTION' ) ; return $ this -> isInTransaction ; }
66	public function isSymlinkedDirectory ( $ directory ) { if ( ! is_dir ( $ directory ) ) { return false ; } $ resolved = $ this -> resolveSymlinkedDirectorySymlink ( $ directory ) ; return is_link ( $ resolved ) ; }
1077	public static function typeFromAST ( Schema $ schema , $ inputTypeNode ) { if ( $ inputTypeNode instanceof ListTypeNode ) { $ innerType = self :: typeFromAST ( $ schema , $ inputTypeNode -> type ) ; return $ innerType ? new ListOfType ( $ innerType ) : null ; } if ( $ inputTypeNode instanceof NonNullTypeNode ) { $ innerType = self :: typeFromAST ( $ schema , $ inputTypeNode -> type ) ; return $ innerType ? new NonNull ( $ innerType ) : null ; } if ( $ inputTypeNode instanceof NamedTypeNode ) { return $ schema -> getType ( $ inputTypeNode -> name -> value ) ; } throw new Error ( 'Unexpected type kind: ' . $ inputTypeNode -> kind . '.' ) ; }
645	public function resetSequence ( $ table , $ value = null ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> resetSequence ( $ table , $ value ) ; return $ this -> setSql ( $ sql ) ; }
2555	protected static function loadCorpNegoFare ( $ corporateNegoFare ) { $ opt = [ ] ; if ( $ corporateNegoFare !== null ) { $ po = new PricingOptionGroup ( PricingOptionKey :: OPTION_CORPORATE_NEGOTIATED_FARES ) ; $ po -> optionDetail = new OptionDetail ( $ corporateNegoFare ) ; $ opt [ ] = $ po ; } return $ opt ; }
8193	public function file ( $ name ) { $ usephp = c :: get ( 'twig.usephp' , true ) ; $ base = str_replace ( '\\' , '/' , $ this -> kirby -> roots ( ) -> templates ( ) . '/' . $ name ) ; $ twig = $ base . '.twig' ; $ php = $ base . '.php' ; if ( $ usephp and ! is_file ( $ twig ) and is_file ( $ php ) ) { return $ php ; } else { return $ twig ; } }
8550	public function setRentalTransactionEventList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'RentalTransactionEventList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
5864	public function getDirectoryPattern ( $ directory ) { $ pattern = '/^' . str_replace ( '/' , '\\/' , $ directory ) . '/' ; $ pattern = str_replace ( '\\/**\\/' , '\\/([^\/]+\\/)*' , $ pattern ) ; $ pattern = str_replace ( '\\/*\\/' , '\\/[^\/]+\\/' , $ pattern ) ; return $ pattern ; }
300	protected function refreshInternal ( $ record ) { if ( $ record === null ) { return false ; } foreach ( $ this -> attributes ( ) as $ name ) { $ this -> _attributes [ $ name ] = isset ( $ record -> _attributes [ $ name ] ) ? $ record -> _attributes [ $ name ] : null ; } $ this -> _oldAttributes = $ record -> _oldAttributes ; $ this -> _related = [ ] ; $ this -> _relationsDependencies = [ ] ; $ this -> afterRefresh ( ) ; return true ; }
4190	protected function dumpMethods ( $ methods ) { $ label = \ count ( $ methods ) ? 'methods' : 'no methods' ; $ str = '<dt class="methods">' . $ label . '</dt>' . "\n" ; $ magicMethods = \ array_intersect ( array ( '__call' , '__callStatic' ) , \ array_keys ( $ methods ) ) ; $ str .= $ this -> magicMethodInfo ( $ magicMethods ) ; foreach ( $ methods as $ methodName => $ info ) { if ( ! isset ( $ info [ 'phpDoc' ] [ 'return' ] ) ) { $ info [ 'phpDoc' ] [ 'return' ] = array ( 'desc' => null , 'type' => null , ) ; } $ classes = \ array_keys ( \ array_filter ( array ( 'method' => true , 'deprecated' => $ info [ 'isDeprecated' ] , ) ) ) ; $ modifiers = \ array_keys ( \ array_filter ( array ( 'final' => $ info [ 'isFinal' ] , $ info [ 'visibility' ] => true , 'static' => $ info [ 'isStatic' ] , ) ) ) ; $ str .= $ this -> debug -> utilities -> buildTag ( 'dd' , array ( 'class' => \ array_merge ( $ classes , $ modifiers ) , 'data-implements' => $ info [ 'implements' ] , ) , \ implode ( ' ' , \ array_map ( function ( $ modifier ) { return '<span class="t_modifier_' . $ modifier . '">' . $ modifier . '</span>' ; } , $ modifiers ) ) . ' ' . $ this -> debug -> utilities -> buildTag ( 'span' , array ( 'class' => 't_type' , 'title' => $ info [ 'phpDoc' ] [ 'return' ] [ 'desc' ] , ) , $ info [ 'phpDoc' ] [ 'return' ] [ 'type' ] ) . ' ' . $ this -> debug -> utilities -> buildTag ( 'span' , array ( 'class' => 'method-name' , 'title' => \ trim ( $ info [ 'phpDoc' ] [ 'summary' ] . ( $ this -> debug -> output -> getCfg ( 'outputMethodDescription' ) ? "\n\n" . $ info [ 'phpDoc' ] [ 'description' ] : '' ) ) , ) , $ methodName ) . '<span class="t_punct">(</span>' . $ this -> dumpMethodParams ( $ info [ 'params' ] ) . '<span class="t_punct">)</span>' . ( $ methodName == '__toString' ? '<br />' . $ this -> debug -> output -> html -> dump ( $ info [ 'returnValue' ] ) : '' ) ) . "\n" ; } $ str = \ str_replace ( ' data-implements="null"' , '' , $ str ) ; $ str = \ str_replace ( ' <span class="t_type"></span>' , '' , $ str ) ; return $ str ; }
1642	public static function fromString ( string $ string , Ellipsoid $ ellipsoid = null ) : Coordinate { $ string = self :: mergeSecondsToMinutes ( $ string ) ; $ result = self :: parseDecimalMinutesWithoutCardinalLetters ( $ string , $ ellipsoid ) ; if ( $ result instanceof Coordinate ) { return $ result ; } $ result = self :: parseDecimalMinutesWithCardinalLetters ( $ string , $ ellipsoid ) ; if ( $ result instanceof Coordinate ) { return $ result ; } $ result = self :: parseDecimalDegreesWithoutCardinalLetters ( $ string , $ ellipsoid ) ; if ( $ result instanceof Coordinate ) { return $ result ; } $ result = self :: parseDecimalDegreesWithCardinalLetters ( $ string , $ ellipsoid ) ; if ( $ result instanceof Coordinate ) { return $ result ; } throw new InvalidArgumentException ( 'Format of coordinates was not recognized' ) ; }
9736	public function setWorksheet ( Worksheet $ pValue = null , $ pOverrideOld = false ) { if ( $ this -> worksheet === null ) { $ this -> worksheet = $ pValue ; $ this -> worksheet -> getCell ( $ this -> coordinates ) ; $ this -> worksheet -> getDrawingCollection ( ) -> append ( $ this ) ; } else { if ( $ pOverrideOld ) { $ iterator = $ this -> worksheet -> getDrawingCollection ( ) -> getIterator ( ) ; while ( $ iterator -> valid ( ) ) { if ( $ iterator -> current ( ) -> getHashCode ( ) == $ this -> getHashCode ( ) ) { $ this -> worksheet -> getDrawingCollection ( ) -> offsetUnset ( $ iterator -> key ( ) ) ; $ this -> worksheet = null ; break ; } } $ this -> setWorksheet ( $ pValue ) ; } else { throw new PhpSpreadsheetException ( 'A Worksheet has already been assigned. Drawings can only exist on one \\PhpOffice\\PhpSpreadsheet\\Worksheet.' ) ; } } return $ this ; }
9278	public function fetchByWhere ( $ where = null , array $ options = array ( ) ) { $ select = $ this -> sql -> select ( ) ; if ( $ where instanceof Where ) { $ select -> where ( $ where ) ; } elseif ( is_string ( $ where ) && ! empty ( $ where ) ) { $ select -> where ( $ where ) ; } $ limit = array_key_exists ( 'limit' , $ options ) ? ( int ) $ limit : null ; if ( ! is_null ( $ limit ) && ( int ) $ limit > 0 ) { $ select -> limit ( $ limit ) ; } $ stmt = $ this -> sql -> prepareStatementForSqlObject ( $ select ) ; $ result = $ stmt -> execute ( ) ; $ hydrate = array_key_exists ( 'hydrate' , $ options ) ? ( bool ) $ options [ 'hydrate' ] : true ; if ( $ hydrate !== true ) { return $ result ; } return $ this -> hydrateResult ( $ result ) ; }
2153	public function updateAccount ( ) { $ intUser = Input :: get ( 'id' ) ; if ( TL_MODE == 'FE' ) { $ this -> import ( FrontendUser :: class , 'User' ) ; $ intUser = $ this -> User -> id ; } if ( ! $ intUser ) { return ; } if ( TL_MODE == 'FE' || Input :: get ( 'act' ) == 'edit' ) { $ objUser = $ this -> Database -> prepare ( "SELECT email, disable FROM tl_member WHERE id=?" ) -> limit ( 1 ) -> execute ( $ intUser ) ; if ( $ objUser -> numRows ) { $ strEmail = Input :: post ( 'email' , true ) ; if ( ! empty ( $ _POST ) && $ strEmail != '' && $ strEmail != $ objUser -> email ) { $ objCount = $ this -> Database -> prepare ( "SELECT COUNT(*) AS count FROM tl_newsletter_recipients WHERE email=?" ) -> execute ( $ strEmail ) ; if ( $ objCount -> count > 0 ) { $ this -> Database -> prepare ( "DELETE FROM tl_newsletter_recipients WHERE email=?" ) -> execute ( $ objUser -> email ) ; } else { $ this -> Database -> prepare ( "UPDATE tl_newsletter_recipients SET email=? WHERE email=?" ) -> execute ( $ strEmail , $ objUser -> email ) ; } $ objUser -> email = $ strEmail ; } $ objSubscriptions = $ this -> Database -> prepare ( "SELECT pid FROM tl_newsletter_recipients WHERE email=?" ) -> execute ( $ objUser -> email ) ; if ( $ objSubscriptions -> numRows ) { $ strNewsletters = serialize ( $ objSubscriptions -> fetchEach ( 'pid' ) ) ; } else { $ strNewsletters = '' ; } $ this -> Database -> prepare ( "UPDATE tl_member SET newsletter=? WHERE id=?" ) -> execute ( $ strNewsletters , $ intUser ) ; if ( TL_MODE == 'FE' ) { $ this -> User -> newsletter = $ strNewsletters ; } elseif ( ! empty ( $ _POST ) && Input :: post ( 'disable' ) != $ objUser -> disable ) { $ this -> Database -> prepare ( "UPDATE tl_newsletter_recipients SET active=? WHERE email=?" ) -> execute ( ( Input :: post ( 'disable' ) ? '' : 1 ) , $ objUser -> email ) ; $ objUser -> disable = Input :: post ( 'disable' ) ; } } } elseif ( Input :: get ( 'act' ) == 'delete' ) { $ objUser = $ this -> Database -> prepare ( "SELECT email FROM tl_member WHERE id=?" ) -> limit ( 1 ) -> execute ( $ intUser ) ; if ( $ objUser -> numRows ) { $ this -> Database -> prepare ( "DELETE FROM tl_newsletter_recipients WHERE email=?" ) -> execute ( $ objUser -> email ) ; } } }
12078	public function childAssociate ( $ request , $ idParent , $ idChild , $ relation ) { $ request -> request -> merge ( [ 'url' => $ request -> request -> path ( ) ] ) ; $ idParent = $ this -> getRealId ( $ idParent ) ; $ idChild = $ this -> getRealId ( $ idChild ) ; $ resourceChild = $ this -> repository -> attach ( $ idParent , $ idChild , $ relation , $ request -> all ( ) ) ; if ( ! $ resourceChild ) { } return $ this -> success ( [ $ resourceChild ] ) ; }
7981	public function getSessionFilesProperties ( $ sessId , $ fileId ) { return json_decode ( self :: getClient ( ) -> getPcaSessionFilesProperties ( $ this -> pp , $ this -> sn , $ sessId , $ fileId ) ) ; }
7135	public function getPercent ( ) : float { $ amount = $ this -> getAmount ( ) ; if ( 0 < $ this -> sellingPrice ) { return round ( $ amount * 100 / $ this -> sellingPrice , 2 ) ; } return 0 ; }
11362	public static function mailTagger ( $ mail = '' , $ name = null ) { return ( ( ! is_int ( $ name ) ? "\"" . $ name . "\" <" : '' ) . $ mail . ( ! is_int ( $ name ) ? ">" : '' ) ) ; }
2060	public function scheduleUpdate ( Contao \ DataContainer $ dc ) { if ( ! $ dc -> activeRecord || ! $ dc -> activeRecord -> id || Contao \ Input :: get ( 'act' ) == 'copy' ) { return ; } $ objSession = Contao \ System :: getContainer ( ) -> get ( 'session' ) ; $ session = $ objSession -> get ( 'sitemap_updater' ) ; $ session [ ] = Contao \ PageModel :: findWithDetails ( $ dc -> activeRecord -> id ) -> rootId ; $ objSession -> set ( 'sitemap_updater' , array_unique ( $ session ) ) ; }
3114	public function clearEvents ( $ testSessionId ) { $ extendedState = $ this -> getExtendedState ( $ testSessionId ) ; $ extendedState -> clearEvents ( ) ; $ extendedState -> save ( ) ; }
5153	public function addConfiguration ( $ configuration , $ configure = true ) { if ( ! $ configuration instanceof ConfigurationInterface ) { $ configuration = new Configuration ( $ configuration ) ; } $ config = $ this -> getConfiguration ( ) ; if ( $ config instanceof ConfigurationInterface ) { $ config -> merge ( $ configuration ) ; } if ( $ config === null ) { $ config = $ configuration ; } $ this -> setConfiguration ( $ config , $ configure ) ; }
4677	public function renderBuffered ( $ region = "main" ) { ob_start ( ) ; $ this -> render ( $ region ) ; $ res = ob_get_contents ( ) ; ob_end_clean ( ) ; return $ res ; }
6821	protected function compare ( float $ a , float $ b ) { return Money :: compare ( $ a , $ b , $ this -> currency ) ; }
9545	public function create ( $ table , array $ fields , $ tokenize = 'porter' ) { $ fields = implode ( ', ' , $ fields ) ; $ query = "CREATE VIRTUAL TABLE {$table} USING fts4({$fields}, tokenize={$tokenize})" ; $ executed = $ this -> db -> info ( 'tables' , $ table ) ; if ( $ query == $ executed ) { return false ; } if ( ! is_null ( $ executed ) ) { $ this -> db -> exec ( 'DROP TABLE ' . $ table ) ; } $ this -> db -> exec ( $ query ) ; $ this -> db -> info ( 'tables' , $ table , $ query ) ; return true ; }
1742	public function syncFiles ( $ href , $ label , $ title , $ class , $ attributes ) { return $ this -> User -> hasAccess ( 'f6' , 'fop' ) ? '<a href="' . $ this -> addToUrl ( $ href ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '" class="' . $ class . '"' . $ attributes . '>' . $ label . '</a> ' : '' ; }
12964	private function getPerMonth ( $ months ) { $ per_month = [ ] ; $ log = $ this -> logger -> perMonth ( $ months ) ; foreach ( $ log as $ date => $ hits ) { array_push ( $ per_month , [ $ date , $ hits ] ) ; } return $ per_month ; }
11907	public function doFullBootBuildIfNecessary ( AviatorApp $ app ) { $ beaconUpdatedAt = $ this -> getChangedAt ( Aviator :: getInstallDir ( ) . '/tmp/watch_beacon' ) ; if ( $ beaconUpdatedAt > LocalDate :: now ( ) -> modifyBySeconds ( 3 ) -> getTimestamp ( ) ) { echo DebugErrorHandler :: watcherBeaconInFuture ( ) ; die ( ) ; } if ( PHP_SAPI !== 'cli' && $ beaconUpdatedAt < LocalDate :: now ( ) -> modifyBySeconds ( - 3 ) -> getTimestamp ( ) ) { echo DebugErrorHandler :: watcherNotRunning ( ) ; exit ( - 1 ) ; } $ needsBuild = ! class_exists ( $ app -> getContainerFqcn ( ) ) ; if ( ! $ needsBuild ) { $ reflect = new \ ReflectionClass ( $ app -> getContainerFqcn ( ) ) ; $ containerFile = $ reflect -> getFileName ( ) ; clearstatcache ( true , $ containerFile ) ; $ fileUpdatedAt = $ this -> getChangedAt ( Aviator :: getInstallDir ( ) . '/tmp/file_update_found' ) ; $ needsBuild = filemtime ( $ containerFile ) < $ fileUpdatedAt ; } if ( $ needsBuild ) { $ this -> doFullBootBuild ( $ app ) ; } }
9639	public function setValue ( $ url ) { if ( $ url ) { $ url = $ this -> rebuildURL ( $ url ) ; } parent :: setValue ( $ url ) ; }
191	public function setStatusCodeByException ( $ e ) { if ( $ e instanceof HttpException ) { $ this -> setStatusCode ( $ e -> statusCode ) ; } else { $ this -> setStatusCode ( 500 ) ; } return $ this ; }
8833	public function generateFromPattern ( $ pattern , $ amount = 1 , $ safeguard = 100 ) { $ lexer = new \ Gajus \ Paggern \ Lexer ( ) ; $ tokens = $ lexer -> tokenise ( $ pattern , true ) ; $ codes = array_fill ( 0 , $ amount + $ safeguard , '' ) ; foreach ( $ tokens as & $ token ) { if ( $ token [ 'type' ] !== 'literal' ) { $ token [ 'pool' ] = $ this -> generator -> generateString ( $ token [ 'repetition' ] * ( $ amount + $ safeguard ) , $ token [ 'haystack' ] ) ; } unset ( $ token ) ; } foreach ( $ codes as $ i => & $ code ) { foreach ( $ tokens as $ token ) { if ( $ token [ 'type' ] === 'literal' ) { $ code .= $ token [ 'string' ] ; } else { $ code .= mb_substr ( $ token [ 'pool' ] , $ token [ 'repetition' ] * $ i , $ token [ 'repetition' ] ) ; } } unset ( $ code ) ; } $ codes = array_slice ( array_unique ( $ codes ) , 0 , $ amount ) ; if ( count ( $ codes ) < $ amount ) { throw new Exception \ RuntimeException ( 'Unique combination pool exhausted.' ) ; } return $ codes ; }
12910	public function group ( $ group ) { if ( ! is_array ( $ group ) ) { $ this -> group = array ( $ group ) ; } else { $ this -> group = $ group ; } return $ this ; }
7541	function setIndex ( $ index ) { if ( $ this -> parent ) { if ( $ index > $ this -> index ( ) ) { -- $ index ; } $ this -> delete ( ) ; $ this -> parent -> addChild ( $ this , $ index ) ; } }
2461	private function canonicalize ( string $ value ) : string { $ resolved = [ ] ; $ chunks = preg_split ( '#([\\\\/]+)#' , $ value , - 1 , PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY ) ; for ( $ i = 0 , $ c = \ count ( $ chunks ) ; $ i < $ c ; ++ $ i ) { if ( '.' === $ chunks [ $ i ] ) { ++ $ i ; continue ; } if ( '/' === $ chunks [ $ i ] [ 0 ] ) { $ resolved [ ] = '/' ; continue ; } if ( '\\' === $ chunks [ $ i ] [ 0 ] ) { $ resolved [ ] = '\\' ; continue ; } if ( '..' === $ chunks [ $ i ] ) { ++ $ i ; array_pop ( $ resolved ) ; array_pop ( $ resolved ) ; continue ; } $ resolved [ ] = $ chunks [ $ i ] ; } return rtrim ( implode ( '' , $ resolved ) , '\/' ) ; }
7537	function clear ( ) { foreach ( $ this -> children as $ c ) { $ c -> parent = null ; $ c -> delete ( ) ; } $ this -> children = array ( ) ; }
6064	public function listMoodboards ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/media/' . $ id . '/moodboards' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new MoodboardResponse ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
5881	public function processUpload_postProcessAction ( & $ filename , DataHandler $ pObj ) { $ filename = static :: $ imageResizer -> processFile ( $ filename , '' , '' , null , $ GLOBALS [ 'BE_USER' ] , [ $ this , 'notify' ] ) ; }
9883	private function writeDefinedNames ( XMLWriter $ objWriter , Spreadsheet $ spreadsheet ) { $ objWriter -> startElement ( 'definedNames' ) ; if ( count ( $ spreadsheet -> getNamedRanges ( ) ) > 0 ) { $ this -> writeNamedRanges ( $ objWriter , $ spreadsheet ) ; } $ sheetCount = $ spreadsheet -> getSheetCount ( ) ; for ( $ i = 0 ; $ i < $ sheetCount ; ++ $ i ) { $ this -> writeDefinedNameForAutofilter ( $ objWriter , $ spreadsheet -> getSheet ( $ i ) , $ i ) ; $ this -> writeDefinedNameForPrintTitles ( $ objWriter , $ spreadsheet -> getSheet ( $ i ) , $ i ) ; $ this -> writeDefinedNameForPrintArea ( $ objWriter , $ spreadsheet -> getSheet ( $ i ) , $ i ) ; } $ objWriter -> endElement ( ) ; }
12070	public function createProject ( $ composerJson ) { $ response = $ this -> getResponse ( 'post' , 'v2/projects' , array ( ) , array ( 'upload' => $ composerJson ) ) ; return $ this -> hydrator -> hydrate ( new Project ( ) , $ response ) ; }
2216	public function last ( ) { $ this -> intIndex = $ this -> count ( ) - 1 ; $ this -> blnDone = true ; $ this -> arrCache = $ this -> resultSet [ $ this -> intIndex ] ; return $ this ; }
1903	public function limit ( $ intRows , $ intOffset = 0 ) { if ( $ intRows <= 0 ) { $ intRows = 30 ; } if ( $ intOffset < 0 ) { $ intOffset = 0 ; } if ( strncasecmp ( $ this -> strQuery , 'SELECT' , 6 ) === 0 ) { $ this -> strQuery .= ' LIMIT ' . $ intOffset . ',' . $ intRows ; } else { $ this -> strQuery .= ' LIMIT ' . $ intRows ; } return $ this ; }
10214	public function setColor ( Color $ pValue ) { $ color = $ pValue -> getIsSupervisor ( ) ? $ pValue -> getSharedComponent ( ) : $ pValue ; if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getColor ( ) -> getStyleArray ( [ 'argb' => $ color -> getARGB ( ) ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> color = $ color ; } return $ this ; }
11654	protected function _initMultiDbResources ( ) { $ registry = $ this -> getPluginResource ( 'multidb' ) ; if ( ! $ registry ) { return ; } $ options = $ registry -> getOptions ( ) ; foreach ( $ options as & $ connection ) { if ( 'db://' === substr ( $ connection [ 'dbname' ] , 0 , 5 ) ) { $ connection = array_replace ( $ connection , $ this -> _parseDsn ( $ connection [ 'dbname' ] ) ) ; } } Zend_Registry :: set ( 'multidb' , $ registry -> setOptions ( $ options ) ) ; }
5379	protected function wrap ( $ text ) { $ text = str_replace ( "\r\r\n" , "\r\n" , str_replace ( "\n" , "\r\n" , $ text ) ) ; $ text = str_replace ( "\r\n\n" , "\r\n" , str_replace ( "\r" , "\r\n" , $ text ) ) ; if ( strncmp ( $ text , "\r\n" , strlen ( "\r\n" ) ) == 0 ) { $ text = substr ( $ text , strlen ( "\r\n" ) ) ; } if ( $ this -> wrapIsEnabled ( ) ) { return wordwrap ( $ text , ( integer ) $ this -> getAttribute ( 'cols' ) , "\r\n" ) ; } return $ text ; }
2402	public function previewRoute ( $ strName , $ arrParams = array ( ) ) { $ objRouter = System :: getContainer ( ) -> get ( 'router' ) ; $ objContext = $ objRouter -> getContext ( ) ; $ objPreviewContext = clone $ objContext ; $ objPreviewContext -> setBaseUrl ( '/preview.php' ) ; $ objRouter -> setContext ( $ objPreviewContext ) ; $ strUrl = $ objRouter -> generate ( $ strName , $ arrParams ) ; $ strUrl = substr ( $ strUrl , \ strlen ( Environment :: get ( 'path' ) ) + 1 ) ; $ objRouter -> setContext ( $ objContext ) ; return ampersand ( $ strUrl ) ; }
4283	public function unlink ( $ path ) { self :: restorePrev ( ) ; $ success = \ unlink ( $ path ) ; self :: register ( ) ; return $ success ; }
6502	public function parseQueryString ( Uri $ uri ) : IImmutableDictionary { if ( ( $ queryString = $ uri -> getQueryString ( ) ) === null ) { return new ImmutableHashTable ( [ ] ) ; } if ( ! isset ( $ this -> parsedQueryStringCache [ $ queryString ] ) ) { $ parsedQueryString = [ ] ; parse_str ( $ queryString , $ parsedQueryString ) ; $ kvps = [ ] ; foreach ( $ parsedQueryString as $ key => $ value ) { $ kvps [ ] = new KeyValuePair ( $ key , $ value ) ; } $ this -> parsedQueryStringCache [ $ queryString ] = new ImmutableHashTable ( $ kvps ) ; } return $ this -> parsedQueryStringCache [ $ queryString ] ; }
9079	private static function parseUri ( Request & $ request , $ uri , $ defaultController , $ defaultAction ) { $ contextUri = $ uri ; if ( null != $ request -> getContextPrefix ( ) && '/' != $ request -> getContextPrefix ( ) ) { $ contextUri = str_replace ( $ request -> getContextPrefix ( ) , '' , $ uri ) ; } $ parts = array ( ) ; if ( $ contextUri != '' ) { while ( isset ( $ contextUri [ 0 ] ) && $ contextUri [ 0 ] == '/' ) { $ contextUri = substr ( $ contextUri , 1 ) ; } $ parts = explode ( '/' , $ contextUri ) ; } if ( count ( $ parts ) > 0 ) { $ request -> setController ( ucfirst ( trim ( $ parts [ 0 ] ) ) ) ; array_shift ( $ parts ) ; if ( ! $ request -> getController ( ) ) { $ request -> setController ( $ defaultController ) ; } } if ( count ( $ parts ) > 0 ) { $ request -> setAction ( trim ( $ parts [ 0 ] ) ) ; array_shift ( $ parts ) ; if ( ! $ request -> getAction ( ) ) { $ request -> setAction ( $ defaultAction ) ; } } return $ parts ; }
10765	public function generateImage ( $ filename = false , $ level = Constants :: QR_ECLEVEL_L , $ size = 3 , $ margin = 4 ) { $ result = 'SPD' . self :: DELIMITER . $ this -> version . self :: DELIMITER . $ this -> implodeContent ( ) ; if ( $ this -> appendCRC32 ) { $ result .= self :: DELIMITER . 'CRC32:' . sprintf ( '%x' , crc32 ( $ result ) ) ; } QRcode :: png ( $ result , $ filename , $ level , $ size , $ margin ) ; die ( ) ; }
782	public function add ( $ cookie ) { if ( $ this -> readOnly ) { throw new InvalidCallException ( 'The cookie collection is read only.' ) ; } $ this -> _cookies [ $ cookie -> name ] = $ cookie ; }
5897	public function listVideoTemplates ( CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/templates/videos' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new VideoTemplate ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
4717	public function emit ( $ event , $ parameters ) { if ( ! isset ( $ this -> callbacks [ $ event ] ) ) { return ; } if ( ! $ this -> callbacks [ $ event ] [ 0 ] ) { usort ( $ this -> callbacks [ $ event ] [ 1 ] , function ( $ A , $ B ) { if ( $ A [ 0 ] == $ B [ 0 ] ) { return 0 ; } return ( $ A [ 0 ] > $ B [ 0 ] ) ? 1 : - 1 ; } ) ; $ this -> callbacks [ $ event ] [ 0 ] = true ; } foreach ( $ this -> callbacks [ $ event ] [ 1 ] as $ item ) { call_user_func_array ( $ item [ 1 ] , $ this -> buildParameters ( $ parameters ) ) ; } }
3691	public function presetVariantBase ( PreEditModelEvent $ event ) { $ model = $ event -> getModel ( ) ; if ( ! $ model instanceof Model ) { return ; } $ nativeItem = $ model -> getItem ( ) ; $ metaModel = $ nativeItem -> getMetaModel ( ) ; if ( $ metaModel -> hasVariants ( ) && ( ! $ nativeItem -> get ( 'vargroup' ) ) ) { $ nativeItem -> set ( 'varbase' , '1' ) ; } }
4086	public function handle ( BuildWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) || ( $ event -> getProperty ( ) -> getName ( ) !== 'filterparams' ) ) { return ; } $ model = $ event -> getModel ( ) ; $ objFilterSettings = $ this -> settingFactory -> createCollection ( $ model -> getProperty ( 'filter' ) ) ; $ extra = $ event -> getProperty ( ) -> getExtra ( ) ; $ extra [ 'subfields' ] = $ objFilterSettings -> getParameterDCA ( ) ; $ event -> getProperty ( ) -> setExtra ( $ extra ) ; }
6902	public function url ( $ page = 1 ) { $ page = max ( 1 , ( int ) $ page ) ; if ( $ page === 1 AND ! $ this -> first_page_in_url ) { $ page = NULL ; } switch ( $ this -> current_page_source ) { case 'query_string' : case 'mixed' : return URL :: site ( $ this -> request -> uri ( ) . $ this -> query ( [ $ this -> current_page_source_key => $ page ] ) ) ; case 'route' : return URL :: site ( $ this -> route -> url ( array_merge ( $ this -> route_params , array ( $ this -> current_page_source_key => $ page ) ) ) . $ this -> query ( ) ) ; } return '#' ; }
474	public function update ( $ table , $ columns , $ condition = '' , $ params = [ ] ) { $ time = $ this -> beginCommand ( "update $table" ) ; $ this -> db -> createCommand ( ) -> update ( $ table , $ columns , $ condition , $ params ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
2914	public function formatStacktrace ( array $ trace , $ stripFilepath = '' , $ trimPath = '' ) { $ out = '' ; foreach ( $ trace as $ index => $ row ) { if ( $ stripFilepath && isset ( $ row [ 'file' ] ) && strpos ( $ row [ 'file' ] , $ stripFilepath ) !== false ) { continue ; } if ( $ trimPath && isset ( $ row [ 'file' ] ) ) { $ row [ 'file' ] = str_replace ( $ trimPath , '' , $ row [ 'file' ] ) ; } if ( isset ( $ row [ 'file' ] ) ) { $ out .= "[$index] {$row['file']}:{$row['line']}\n" ; } else { $ out .= "[$index] (?) {$row['class']}:{$row['function']}\n" ; } } return $ out ; }
6633	public function requestProfile ( AccessTokenInterface $ access_token ) { $ request = [ 'url' => $ this -> settings [ 'api_url' ] . $ this -> settings [ 'profile_uri' ] , 'params' => [ 'access_token' => $ access_token -> token ( ) ] , ] ; return $ this -> parseProfileResponse ( $ this -> http -> get ( $ request ) , $ access_token ) ; }
787	public function formName ( ) { $ reflector = new ReflectionClass ( $ this ) ; if ( PHP_VERSION_ID >= 70000 && $ reflector -> isAnonymous ( ) ) { throw new InvalidConfigException ( 'The "formName()" method should be explicitly defined for anonymous models' ) ; } return $ reflector -> getShortName ( ) ; }
2141	public function onKernelResponse ( FilterResponseEvent $ event ) : void { if ( ! $ this -> scopeMatcher -> isContaoMasterRequest ( $ event ) ) { return ; } $ token = $ this -> tokenStorage -> getToken ( ) ; if ( null === $ token || $ this -> authenticationTrustResolver -> isAnonymous ( $ token ) ) { return ; } $ user = $ token -> getUser ( ) ; if ( ! $ user instanceof User ) { return ; } $ sessionBag = $ this -> getSessionBag ( $ event -> getRequest ( ) ) ; $ data = $ sessionBag -> all ( ) ; $ this -> connection -> update ( $ user -> getTable ( ) , [ 'session' => serialize ( $ data ) ] , [ 'id' => $ user -> id ] ) ; }
9603	public function crossProduct ( self $ b ) { $ this -> _checkVectorSpace ( $ b ) ; if ( $ this -> dimension ( ) !== 3 ) { throw new Exception ( 'Both vectors must be 3-dimensional' ) ; } $ tc = $ this -> components ( ) ; $ bc = $ b -> components ( ) ; list ( $ k0 , $ k1 , $ k2 ) = array_keys ( $ tc ) ; $ product = [ $ k0 => $ tc [ $ k1 ] * $ bc [ $ k2 ] - $ tc [ $ k2 ] * $ bc [ $ k1 ] , $ k1 => $ tc [ $ k2 ] * $ bc [ $ k0 ] - $ tc [ $ k0 ] * $ bc [ $ k2 ] , $ k2 => $ tc [ $ k0 ] * $ bc [ $ k1 ] - $ tc [ $ k1 ] * $ bc [ $ k0 ] , ] ; return new static ( $ product ) ; }
1512	public function read ( StoreInterface $ store , FetchResource $ request ) { $ result = $ this -> doRead ( $ store , $ request ) ; if ( $ this -> isResponse ( $ result ) ) { return $ result ; } return $ this -> reply ( ) -> content ( $ result ) ; }
4859	public function getNeighbours ( $ namespace , $ callback , $ id ) { $ list = $ this -> getList ( $ namespace , $ callback ) ; $ list -> setCurrent ( $ id ) ; return [ $ list -> getPrevious ( ) , $ list -> getNext ( ) ] ; }
10532	public function valid ( ) { if ( $ this -> items === null ) { return false ; } $ key = key ( $ this -> items ) ; return ( $ key !== null && $ key !== false ) ; }
8314	protected function finishPasswordReset ( array $ resetData ) { if ( time ( ) > $ resetData [ 'validity' ] ) { $ this -> session -> remove ( "pwreset" ) ; $ this -> session -> addFlash ( "error" , "Page validity expired, please try again." ) ; $ this -> picoAuth -> redirectToLogin ( ) ; } $ this -> picoAuth -> addOutput ( "isReset" , true ) ; $ this -> picoAuth -> setRequestFile ( $ this -> picoAuth -> getPluginPath ( ) . '/content/pwreset.md' ) ; $ post = $ this -> httpRequest -> request ; if ( $ post -> has ( "new_password" ) && $ post -> has ( "new_password_repeat" ) ) { $ newPassword = new Password ( $ post -> get ( "new_password" ) ) ; $ newPasswordRepeat = new Password ( $ post -> get ( "new_password_repeat" ) ) ; $ username = $ resetData [ 'user' ] ; if ( ! $ this -> picoAuth -> isValidCSRF ( $ post -> get ( "csrf_token" ) ) ) { $ this -> picoAuth -> redirectToPage ( "password_reset" ) ; } if ( $ newPassword -> get ( ) !== $ newPasswordRepeat -> get ( ) ) { $ this -> session -> addFlash ( "error" , "The passwords do not match." ) ; $ this -> picoAuth -> redirectToPage ( "password_reset" ) ; } $ localAuth = $ this -> picoAuth -> getContainer ( ) -> get ( 'LocalAuth' ) ; if ( ! $ localAuth -> checkPasswordPolicy ( $ newPassword ) ) { $ this -> picoAuth -> redirectToPage ( "password_reset" ) ; } $ this -> session -> remove ( "pwreset" ) ; $ userData = $ this -> storage -> getUserByName ( $ username ) ; $ localAuth -> userDataEncodePassword ( $ userData , $ newPassword ) ; $ this -> storage -> saveUser ( $ username , $ userData ) ; $ this -> logPasswordReset ( $ username ) ; $ localAuth -> login ( $ username , $ userData ) ; $ this -> picoAuth -> afterLogin ( ) ; } }
3660	private function getFilterRule ( ) { $ this -> compile ( ) ; return new SimpleQuery ( $ this -> queryString , $ this -> queryParameter , 'id' , $ this -> container -> get ( Connection :: class ) ) ; }
4491	public function registerDeviceOnTopic ( string $ deviceArn , string $ topicArn ) { $ this -> sns -> subscribe ( [ 'TopicArn' => $ topicArn , 'Protocol' => 'application' , 'Endpoint' => $ deviceArn , ] ) ; }
10656	public function usort ( $ cmp_function ) { $ tmp = $ this -> getArrayCopy ( ) ; $ ret = usort ( $ tmp , $ cmp_function ) ; $ tmp = new self ( $ tmp ) ; $ this -> exchangeArray ( $ tmp -> getArrayCopy ( ) ) ; return $ ret ; }
1065	private function findConflict ( ValidationContext $ context , $ parentFieldsAreMutuallyExclusive , $ responseName , array $ field1 , array $ field2 ) { [ $ parentType1 , $ ast1 , $ def1 ] = $ field1 ; [ $ parentType2 , $ ast2 , $ def2 ] = $ field2 ; $ areMutuallyExclusive = $ parentFieldsAreMutuallyExclusive || ( $ parentType1 !== $ parentType2 && $ parentType1 instanceof ObjectType && $ parentType2 instanceof ObjectType ) ; $ type1 = $ def1 === null ? null : $ def1 -> getType ( ) ; $ type2 = $ def2 === null ? null : $ def2 -> getType ( ) ; if ( ! $ areMutuallyExclusive ) { $ name1 = $ ast1 -> name -> value ; $ name2 = $ ast2 -> name -> value ; if ( $ name1 !== $ name2 ) { return [ [ $ responseName , sprintf ( '%s and %s are different fields' , $ name1 , $ name2 ) ] , [ $ ast1 ] , [ $ ast2 ] , ] ; } if ( ! $ this -> sameArguments ( $ ast1 -> arguments ? : [ ] , $ ast2 -> arguments ? : [ ] ) ) { return [ [ $ responseName , 'they have differing arguments' ] , [ $ ast1 ] , [ $ ast2 ] , ] ; } } if ( $ type1 && $ type2 && $ this -> doTypesConflict ( $ type1 , $ type2 ) ) { return [ [ $ responseName , sprintf ( 'they return conflicting types %s and %s' , $ type1 , $ type2 ) ] , [ $ ast1 ] , [ $ ast2 ] , ] ; } $ selectionSet1 = $ ast1 -> selectionSet ; $ selectionSet2 = $ ast2 -> selectionSet ; if ( $ selectionSet1 && $ selectionSet2 ) { $ conflicts = $ this -> findConflictsBetweenSubSelectionSets ( $ context , $ areMutuallyExclusive , Type :: getNamedType ( $ type1 ) , $ selectionSet1 , Type :: getNamedType ( $ type2 ) , $ selectionSet2 ) ; return $ this -> subfieldConflicts ( $ conflicts , $ responseName , $ ast1 , $ ast2 ) ; } return null ; }
2430	public function listStyleSheet ( $ row ) { $ cc = '' ; $ media = Contao \ StringUtil :: deserialize ( $ row [ 'media' ] ) ; if ( $ row [ 'cc' ] != '' ) { $ cc = ' &lt;!--[' . $ row [ 'cc' ] . ']&gt;' ; } if ( $ row [ 'mediaQuery' ] != '' ) { return '<div class="tl_content_left">' . $ row [ 'name' ] . ' <span style="color:#999;padding-left:3px">@media ' . $ row [ 'mediaQuery' ] . $ cc . '</span>' . "</div>\n" ; } elseif ( ! empty ( $ media ) && \ is_array ( $ media ) ) { return '<div class="tl_content_left">' . $ row [ 'name' ] . ' <span style="color:#999;padding-left:3px">@media ' . implode ( ', ' , $ media ) . $ cc . '</span>' . "</div>\n" ; } else { return '<div class="tl_content_left">' . $ row [ 'name' ] . $ cc . "</div>\n" ; } }
6383	public function readFeedbackAttempt ( $ id ) { $ model = $ this -> readObject ( $ id , 'feedback_completed' ) ; $ model -> url = $ this -> cfg -> wwwroot . '/mod/feedback/complete.php?id=' . $ id ; $ model -> name = 'Attempt ' . $ id ; $ model -> responses = $ this -> readStoreRecords ( 'feedback_value' , [ 'completed' => $ id ] ) ; return $ model ; }
10987	public static function D ( $ value , $ options = array ( ) ) { if ( is_numeric ( $ options ) ) { $ options = array ( 'depth' => $ options ) ; } elseif ( empty ( $ options ) ) { $ options = array ( ) ; } $ plop = new Dumpling ( $ options ) ; return $ plop -> dump ( $ value ) ; }
2688	private function fastlyRotate ( $ angle ) { $ angle = ( int ) $ angle ; $ orient = null ; if ( $ angle == 90 ) { $ orient = 'r' ; } if ( $ angle == - 90 || $ angle == 270 ) { $ orient = 'l' ; } if ( $ angle == 180 ) { $ orient = 3 ; } if ( $ orient !== null ) { $ this -> fastlyParameters [ 'orient' ] = $ orient ; } return $ this ; }
2453	public static function findByHashAndPid ( $ strHash , $ intPid , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; return static :: findOneBy ( array ( "($t.hash=? AND $t.pid=?)" ) , array ( $ strHash , $ intPid ) , $ arrOptions ) ; }
6905	public function removeRecipient ( Recipient $ recipient ) { if ( $ this -> recipients -> contains ( $ recipient ) ) { $ this -> recipients -> removeElement ( $ recipient ) ; } return $ this ; }
6355	public function setTimestamp ( $ ts = false ) { $ m = [ ] ; $ da = [ ] ; $ strtime = '' ; if ( ! $ ts || $ ts === "\0\0\0\0\0\0\0\0\0\0\0\0\0\0" ) { $ uts = self :: time ( ) ; $ strtime = "@$uts" ; } elseif ( preg_match ( '/^(\d{4})\-(\d\d)\-(\d\d) (\d\d):(\d\d):(\d\d)$/D' , $ ts , $ da ) ) { } elseif ( preg_match ( '/^(\d{4}):(\d\d):(\d\d) (\d\d):(\d\d):(\d\d)$/D' , $ ts , $ da ) ) { } elseif ( preg_match ( '/^(\d{4})(\d\d)(\d\d)(\d\d)(\d\d)(\d\d)$/D' , $ ts , $ da ) ) { } elseif ( preg_match ( '/^(-?\d{1,13})$/D' , $ ts , $ m ) ) { $ strtime = "@{$m[1]}" ; } elseif ( preg_match ( '/^(-?\d{1,13})(\.\d+)$/D' , $ ts , $ m ) ) { $ strtime = 'unixmicro' ; } elseif ( preg_match ( '/^\d{2}-\d{2}-\d{4} \d{2}:\d{2}:\d{2}.\d{6}$/' , $ ts ) ) { $ strtime = preg_replace ( '/(\d\d)\.(\d\d)\.(\d\d)(\.(\d+))?/' , "$1:$2:$3" , str_replace ( '+00:00' , 'UTC' , $ ts ) ) ; } elseif ( preg_match ( '/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})(?:\.*\d*)?Z?$/' , $ ts , $ da ) ) { } elseif ( preg_match ( '/^(\d{4})(\d{2})(\d{2})T(\d{2})(\d{2})(\d{2})(?:\.*\d*)?Z?$/' , $ ts , $ da ) ) { } elseif ( preg_match ( '/^(\d{4})\-(\d\d)\-(\d\d) (\d\d):(\d\d):(\d\d)\.*\d*[\+\- ](\d\d)$/' , $ ts , $ da ) ) { } elseif ( preg_match ( '/^(\d{4})\-(\d\d)\-(\d\d) (\d\d):(\d\d):(\d\d)\.*\d* GMT$/' , $ ts , $ da ) ) { } elseif ( preg_match ( '/^[ \t\r\n]*([A-Z][a-z]{2},[ \t\r\n]*)?' . '\d\d?[ \t\r\n]*[A-Z][a-z]{2}[ \t\r\n]*\d{2}(?:\d{2})?' . '[ \t\r\n]*\d\d[ \t\r\n]*:[ \t\r\n]*\d\d[ \t\r\n]*:[ \t\r\n]*\d\d/S' , $ ts ) ) { $ strtime = strtok ( $ ts , ';' ) ; } elseif ( preg_match ( '/^[A-Z][a-z]{5,8}, \d\d-[A-Z][a-z]{2}-\d{2} \d\d:\d\d:\d\d/' , $ ts ) ) { $ strtime = $ ts ; } elseif ( preg_match ( '/^[A-Z][a-z]{2} [A-Z][a-z]{2} +\d{1,2} \d\d:\d\d:\d\d \d{4}/' , $ ts ) ) { $ strtime = $ ts ; } else { throw new TimestampException ( __METHOD__ . ": Invalid timestamp - $ts" ) ; } if ( ! $ strtime ) { $ da = array_map ( 'intval' , $ da ) ; $ da [ 0 ] = "%04d-%02d-%02dT%02d:%02d:%02d.00+00:00" ; $ strtime = call_user_func_array ( "sprintf" , $ da ) ; } try { if ( $ strtime === 'unixmicro' ) { $ final = DateTime :: createFromFormat ( 'U.u' , $ ts , new DateTimeZone ( 'GMT' ) ) ; } else { $ final = new DateTime ( $ strtime , new DateTimeZone ( 'GMT' ) ) ; } } catch ( Exception $ e ) { throw new TimestampException ( __METHOD__ . ': Invalid timestamp format.' , $ e -> getCode ( ) , $ e ) ; } if ( $ final === false ) { throw new TimestampException ( __METHOD__ . ': Invalid timestamp format.' ) ; } $ this -> timestamp = $ final ; }
7390	private function set404 ( ) { $ this -> response -> setStatusCode ( 404 ) ; $ content = '404 Not Found' ; if ( file_exists ( $ this -> packageRoot . '/view/404.html.php' ) ) { $ content = ( new Native ( $ this -> packageRoot ) ) -> getContent ( '404.html.php' ) ; } $ this -> response -> setContent ( $ content ) ; }
943	private function computeConfigFiles ( ) { $ configFile = $ this -> options [ 'config' ] ; if ( null !== $ configFile ) { if ( false === file_exists ( $ configFile ) || false === is_readable ( $ configFile ) ) { throw new InvalidConfigurationException ( sprintf ( 'Cannot read config file "%s".' , $ configFile ) ) ; } return [ $ configFile ] ; } $ path = $ this -> getPath ( ) ; if ( $ this -> isStdIn ( ) || 0 === \ count ( $ path ) ) { $ configDir = $ this -> cwd ; } elseif ( 1 < \ count ( $ path ) ) { throw new InvalidConfigurationException ( 'For multiple paths config parameter is required.' ) ; } elseif ( is_file ( $ path [ 0 ] ) && $ dirName = pathinfo ( $ path [ 0 ] , PATHINFO_DIRNAME ) ) { $ configDir = $ dirName ; } else { $ configDir = $ path [ 0 ] ; } $ candidates = [ $ configDir . \ DIRECTORY_SEPARATOR . '.php_cs' , $ configDir . \ DIRECTORY_SEPARATOR . '.php_cs.dist' , ] ; if ( $ configDir !== $ this -> cwd ) { $ candidates [ ] = $ this -> cwd . \ DIRECTORY_SEPARATOR . '.php_cs' ; $ candidates [ ] = $ this -> cwd . \ DIRECTORY_SEPARATOR . '.php_cs.dist' ; } return $ candidates ; }
2660	public function getRequest ( $ version , $ name ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/request_settings/' . $ name ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: GET , '' , false , null , false ) ; return $ result ; }
6549	public function add ( $ data ) { $ columnNum = 0 ; $ rowNum = $ this -> iterator -> current ( ) -> getRowIndex ( ) ; foreach ( ( array ) $ data as $ value ) { $ this -> sheet -> setCellValueByColumnAndRow ( $ columnNum ++ , $ rowNum , $ value ) ; } $ this -> iterator -> next ( ) ; }
6757	public function supportsDenormalization ( $ data , $ type , $ format = null ) { if ( ! \ class_exists ( $ type ) ) { return false ; } $ classAnnotation = $ this -> annotationReader -> getClassAnnotation ( new \ ReflectionClass ( $ type ) , NestedPropertyDenormalizerAnnotation :: class ) ; return $ classAnnotation instanceof NestedPropertyDenormalizerAnnotation ; }
9136	public function clearTag ( $ name ) { if ( isset ( $ this -> tags [ $ name ] ) ) { unset ( $ this -> tags [ $ name ] ) ; } return $ this ; }
12396	public function where ( $ field , $ operator = null , $ value = null , $ logical = '&&' ) { if ( $ field instanceof Closure ) { $ this -> scope -> where .= $ this -> scope -> where == '' ? ' (' : $ logical . ' (' ; call_user_func ( $ field , $ this ) ; $ this -> scope -> where .= ') ' ; } else { $ logical = ( strlen ( $ this -> scope -> where ) <= 1 || substr ( $ this -> scope -> where , - 1 ) == '(' ) ? '' : $ logical ; $ this -> scope -> where .= Parser :: where ( $ field , $ operator , $ value , $ logical ) ; } return $ this ; }
8896	public function get_many_by ( ) { $ where = func_get_args ( ) ; $ this -> apply_soft_delete_filter ( ) ; $ this -> _set_where ( $ where ) ; return $ this -> get_all ( ) ; }
8143	public function getLexer ( ) { @ trigger_error ( sprintf ( 'The %s() method is deprecated since version 1.25 and will be removed in 2.0.' , __FUNCTION__ ) , E_USER_DEPRECATED ) ; if ( null === $ this -> lexer ) { $ this -> lexer = new Twig_Lexer ( $ this ) ; } return $ this -> lexer ; }
2013	public static function addNamespaces ( $ names ) { @ trigger_error ( 'Using ClassLoader::addNamespaces() has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; foreach ( $ names as $ name ) { self :: addNamespace ( $ name ) ; } }
10707	public function applyCriteria ( $ criteria ) { $ query = $ this -> getQuery ( ) ; if ( $ criteria instanceof Criteria ) { $ criteria -> apply ( $ query ) ; return $ this ; } if ( $ criteria instanceof Closure ) { $ criteria ( $ query ) ; return $ this ; } throw new RepositoryException ( "Must be an instance of " . Criteria :: class . " or \\Closure" ) ; }
6094	public function isUtf8 ( ) { $ pattern = array ( ) ; $ pattern [ ] = "[\xC2-\xDF][\x80-\xBF]" ; $ pattern [ ] = "\xE0[\xA0-\xBF][\x80-\xBF]" ; $ pattern [ ] = "[\xE1-\xEC\xEE\xEF][\x80-\xBF]{2}" ; $ pattern [ ] = "\xED[\x80-\x9F][\x80-\xBF]" ; $ pattern [ ] = "\xF0[\x90-\xBF][\x80-\xBF]{2}" ; $ pattern [ ] = "[\xF1-\xF3][\x80-\xBF]{3}" ; $ pattern [ ] = "\xF4[\x80-\x8F][\x80-\xBF]{2}" ; return preg_match ( "%(?:" . implode ( "|" , $ pattern ) . ")+%xs" , $ this -> string ) ; }
11469	public function show ( ResponseRequest $ request , Response $ response ) { if ( $ response -> exists ) { $ view = 'forum::response.show' ; } else { $ view = 'forum::response.new' ; } return $ this -> response -> title ( trans ( 'app.view' ) . ' ' . trans ( 'forum::response.name' ) ) -> data ( compact ( 'response' ) ) -> view ( $ view , true ) -> output ( ) ; }
5104	public function execute ( ) { if ( is_null ( $ this -> conn ) ) throw new SquidException ( "Can't execute query, implicitly created without connection!" ) ; $ cmd = $ this -> assemble ( ) ; $ bind = $ this -> bind ( ) ; return $ this -> conn -> execute ( $ cmd , $ bind ) ; }
9706	private function writeAllNumberFormats ( ) { foreach ( $ this -> numberFormats as $ numberFormatIndex => $ numberFormat ) { $ this -> writeNumberFormat ( $ numberFormat -> getFormatCode ( ) , $ numberFormatIndex ) ; } }
7501	public function clearCache ( string $ namespace = null ) { if ( null !== $ namespace ) { $ this -> cacheStore -> remove ( self :: APP_CACHE_PREFIX . $ namespace , array ( ) ) ; return ; } $ this -> cacheStore -> clear ( ) ; }
10271	function addAttachment ( $ mailingId , $ filename , $ contentType , $ contents ) { $ queryParameters = array ( 'filename' => $ filename ) ; return $ this -> post ( "mailings/${mailingId}/attachments" , $ contents , $ queryParameters , null , null , $ contentType , strlen ( $ contents ) ) ; }
8502	public function setMarketplaceIdList ( $ value ) { $ marketplaceIdList = new MarketplaceWebService_Model_IdList ( ) ; $ marketplaceIdList -> setId ( $ value [ 'Id' ] ) ; $ this -> fields [ 'MarketplaceIdList' ] [ 'FieldValue' ] = $ marketplaceIdList ; return ; }
8988	public function toStatusLine ( ) : string { return sprintf ( "%s %d %s" , $ this -> proto , $ this -> code , self :: getStatus ( $ this -> code ) ) ; }
6893	protected function sortAssignments ( array $ assignments ) { usort ( $ assignments , function ( StockAssignmentInterface $ a1 , StockAssignmentInterface $ a2 ) { $ u1 = $ a1 -> getStockUnit ( ) ; $ u2 = $ a2 -> getStockUnit ( ) ; return $ this -> compareStockUnit ( $ u1 , $ u2 ) ; } ) ; return $ assignments ; }
7060	public function removeClass ( $ class ) { $ classes = $ this -> getClasses ( ) ; if ( false !== $ index = array_search ( $ class , $ classes ) ) { unset ( $ classes [ $ index ] ) ; } $ this -> setClasses ( $ classes ) ; return $ this ; }
11544	public function confirmPasswordReset ( $ token ) { $ user = $ this -> getMapper ( ) -> findOneBy ( [ 'registrationToken' => $ token ] ) ; if ( ! $ user instanceof UserInterface ) { return ; } $ eventManager = $ this -> getEventManager ( ) ; $ eventManager -> trigger ( __METHOD__ , $ this , $ user ) ; $ user -> setRegistrationToken ( $ this -> getRegistrationToken ( ) ) ; $ user -> setEmailConfirmed ( true ) ; $ password = $ this -> getPasswordGenerator ( ) -> generate ( ) ; $ passwordService = $ this -> getMapper ( ) -> getPasswordService ( ) ; $ user -> setPassword ( $ passwordService -> create ( $ password ) ) ; $ viewModel = new ViewModel ( compact ( 'user' , 'password' ) ) ; $ viewModel -> setTemplate ( 'mail-message/user-change-password-success' ) ; $ mailService = $ this -> getMailService ( ) ; $ message = $ mailService -> getMessage ( ) ; $ message -> setTo ( $ user -> getEmail ( ) , $ user -> getDisplayName ( ) ) ; $ subject = 'Your password has been changed!' ; if ( $ this -> getTranslator ( ) && $ this -> isTranslatorEnabled ( ) ) { $ subject = $ this -> getTranslator ( ) -> translate ( $ subject , $ this -> getTranslatorTextDomain ( ) ) ; } $ message -> setSubject ( $ subject ) ; $ mailService -> setBody ( $ viewModel ) -> sendMessage ( ) ; $ this -> getMapper ( ) -> update ( $ user ) -> save ( ) ; $ eventManager -> trigger ( __METHOD__ . '.post' , $ this , $ user ) ; return $ user ; }
2939	public static function linearUnitFactory ( $ name , $ toNativeUnitFactor ) { return new static ( $ name , function ( $ valueInNativeUnit ) use ( $ toNativeUnitFactor ) { return $ valueInNativeUnit / $ toNativeUnitFactor ; } , function ( $ valueInThisUnit ) use ( $ toNativeUnitFactor ) { return $ valueInThisUnit * $ toNativeUnitFactor ; } ) ; }
6710	protected function parseHeader ( array $ headers = [ ] ) { $ processedHeaders = array ( ) ; foreach ( $ headers as $ key => $ value ) { if ( substr ( $ key , 0 , 5 ) == 'HTTP_' ) { $ name = str_replace ( ' ' , '-' , ucwords ( strtolower ( str_replace ( '_' , ' ' , substr ( $ key , 5 ) ) ) ) ) ; $ processedHeaders [ $ name ] = $ value ; } elseif ( $ key == 'CONTENT_TYPE' ) { $ processedHeaders [ 'Content-Type' ] = $ value ; } elseif ( $ key == 'CONTENT_LENGTH' ) { $ processedHeaders [ 'Content-Length' ] = $ value ; } } return $ processedHeaders ; }
2802	public static function parseBooleanValue ( $ value ) : bool { if ( \ is_bool ( $ value ) ) { return $ value ; } if ( \ is_string ( $ value ) ) { $ value = \ strtolower ( $ value ) ; return 'true' === $ value ; } if ( \ is_object ( $ value ) || \ is_array ( $ value ) || \ is_callable ( $ value ) ) { return false ; } return ( bool ) $ value ; }
9786	public function parseEscape ( ) { $ token = $ this -> pop ( 'ESCAPE' ) ; $ value = $ this -> stripQuotes ( $ token [ 1 ] ) ; $ this -> currLine += substr_count ( $ value , "\n" ) ; return '$output .= \'' . $ value . "';\n" ; }
9647	public function whateverMatches ( string $ param ) : RouteBuilder { if ( array_key_exists ( $ param , $ this -> matchers ) ) { unset ( $ this -> matchers [ $ param ] ) ; } return $ this ; }
2385	public function addLegend ( string $ name , $ parent , string $ position = self :: POSITION_AFTER , $ hide = false ) : self { $ this -> validatePosition ( $ position ) ; $ this -> legends [ ] = [ 'name' => $ name , 'parents' => ( array ) $ parent , 'position' => $ position , 'hide' => ( bool ) $ hide , ] ; return $ this ; }
1180	public function formRequest ( $ formRequest , $ selector = null ) { if ( ! is_object ( $ formRequest ) ) { $ formRequest = $ this -> createFormRequest ( $ formRequest ) ; } $ rules = method_exists ( $ formRequest , 'rules' ) ? $ formRequest -> rules ( ) : [ ] ; $ validator = $ this -> getValidatorInstance ( $ rules , $ formRequest -> messages ( ) , $ formRequest -> attributes ( ) ) ; return $ this -> validator ( $ validator , $ selector ) ; }
3835	protected function prepareTemplate ( Template $ objTemplate , $ arrRowData , $ objSettings ) { $ objTemplate -> setData ( array ( 'attribute' => $ this , 'settings' => $ objSettings , 'row' => $ arrRowData , 'raw' => $ arrRowData [ $ this -> getColName ( ) ] , 'additional_class' => $ objSettings -> get ( 'additional_class' ) ? ' ' . $ objSettings -> get ( 'additional_class' ) : '' ) ) ; }
4406	public function matches ( Request $ request ) { return in_array ( $ request -> attributes -> get ( '_route' ) , array ( FallbackRouter :: ROUTE_NAME , UrlAliasRouter :: URL_ALIAS_ROUTE_NAME ) , true ) ; }
1901	public function validate ( ) { $ mandatory = $ this -> mandatory ; $ options = $ this -> getPost ( $ this -> strName ) ; if ( $ mandatory && \ is_array ( $ options ) ) { foreach ( $ options as $ option ) { if ( \ strlen ( $ option ) ) { $ this -> mandatory = false ; break ; } } } $ varInput = $ this -> validator ( $ options ) ; if ( ! empty ( $ varInput ) && ! $ this -> isValidOption ( $ varInput ) ) { $ this -> addError ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'invalid' ] ) ; } if ( $ this -> hasErrors ( ) ) { $ this -> class = 'error' ; } else { $ this -> varValue = $ varInput ; } if ( $ mandatory ) { $ this -> mandatory = true ; } }
4568	public function getParent ( $ permission ) { $ permission = $ this -> cast ( $ permission ) ; foreach ( $ this -> toArray ( ) as $ element ) { if ( Permission :: ENTITY === $ element -> getType ( ) && 0 === strpos ( $ permission -> getValue ( ) , $ element -> getValue ( ) ) ) { return $ element ; } } }
9229	public function delete ( $ path , $ data = array ( ) , $ headers = array ( ) ) { if ( ! empty ( $ data ) ) { $ pathData = [ ] ; $ pos = strpos ( $ path , '?' ) ; if ( $ pos !== false ) { parse_str ( substr ( $ path , $ pos + 1 ) , $ pathData ) ; $ path = substr ( $ path , 0 , $ pos ) ; } $ path .= '?' . $ this -> http_build_query ( array_merge ( $ pathData , $ data ) ) ; } return $ this -> postprocessResponse ( parent :: delete ( $ path , $ headers ) ) ; }
11196	public function __isset ( $ name ) { $ value = $ this -> find ( $ name ) ; if ( $ value !== null && ! ( $ value instanceof \ Exception ) ) { return true ; } return false ; }
10340	public static function checkErrorCode ( $ pValue ) { $ pValue = ( string ) $ pValue ; if ( ! isset ( self :: $ errorCodes [ $ pValue ] ) ) { $ pValue = '#NULL!' ; } return $ pValue ; }
4109	public function toOptionArray ( ) { $ options = array ( ) ; $ options [ ] = array ( 'value' => 'aoe_templatehints/renderer_comment' , 'label' => Mage :: helper ( 'aoe_templatehints' ) -> __ ( 'Comments' ) ) ; $ options [ ] = array ( 'value' => 'aoe_templatehints/renderer_opentip' , 'label' => Mage :: helper ( 'aoe_templatehints' ) -> __ ( 'Popups' ) ) ; $ options [ ] = array ( 'value' => 'aoe_templatehints/renderer_tipOnly' , 'label' => Mage :: helper ( 'aoe_templatehints' ) -> __ ( 'Popups (border initially invisible)' ) ) ; Mage :: dispatchEvent ( 'aoetemplatehints_hintrenderer_options' , array ( 'options' => & $ options ) ) ; return $ options ; }
10904	public function isEmpty ( ) { if ( $ this -> test ( \ sndsgd \ Fs :: EXISTS | \ sndsgd \ Fs :: READABLE ) === false ) { throw new \ RuntimeException ( "failed to determine if a directory is empty; " . $ this -> getError ( ) ) ; } return count ( scandir ( $ this -> path ) ) === 2 ; }
6398	private function instantiateEntity ( $ entity_name ) { $ entity = null ; if ( $ entity_name == 'weatherPhenomenons' ) { $ entity = new WeatherPhenomenon ( ) ; } else if ( $ entity_name == 'maxTemperature' ) { $ entity = new Temperature ( ) ; } else if ( $ entity_name == 'minTemperature' ) { $ entity = new Temperature ( ) ; } else if ( $ entity_name == 'clouds' ) { $ entity = new CloudLayer ( ) ; } else if ( $ entity_name == 'surfaceWind' ) { $ entity = new SurfaceWind ( ) ; } else if ( $ entity_name = 'visibility' ) { $ entity = new Visibility ( ) ; } return $ entity ; }
6697	public function isMethodHidden ( $ methodName ) { if ( ! method_exists ( $ this , $ methodName ) ) { throw new Exception ( 500 , "The method '$methodName' does not exist in " . get_called_class ( ) ) ; } return isset ( $ this -> hiddenMethods [ $ methodName ] ) ; }
6198	public function parseGets ( ) { $ request = preg_replace ( '!' . $ this -> uri . '(.*)$!i' , '$1' , $ _SERVER [ 'REQUEST_URI' ] ) ; if ( defined ( 'MOD_REWRITE' ) and MOD_REWRITE === true ) { if ( substr ( $ request , - 1 ) != '/' ) { $ request .= '/' ; } $ parseUrl = $ this -> parseUrl ( $ request ) ; $ this -> namespace = $ parseUrl [ 'v' ] [ 'namespace' ] ?? '' ; parse_str ( $ parseUrl [ 'sVars' ] , $ gets ) ; $ this -> controller = ! empty ( $ gets [ 'task' ] ) ? $ gets [ 'task' ] : $ this -> routeMap [ 'NAME_CONTROLLER' ] ; unset ( $ gets [ 'task' ] ) ; $ this -> action = ! empty ( $ gets [ 'action' ] ) ? $ gets [ 'action' ] : $ this -> routeMap [ 'NAME_METHOD' ] ; unset ( $ gets [ 'action' ] ) ; $ _GET = array_merge ( $ _GET , $ gets ) ; } else { $ this -> controller = ! empty ( $ _GET [ 'task' ] ) ? $ _GET [ 'task' ] : $ this -> routeMap [ 'NAME_CONTROLLER' ] ; $ this -> action = ! empty ( $ _GET [ 'action' ] ) ? $ _GET [ 'action' ] : $ this -> routeMap [ 'NAME_METHOD' ] ; } $ _GET [ 'task' ] = $ this -> controller ; $ _GET [ 'action' ] = $ this -> action ; }
6827	public static function isValid ( $ action , $ throw = false ) { if ( in_array ( $ action , static :: getActions ( ) , true ) ) { return true ; } if ( $ throw ) { throw new InvalidArgumentException ( "Unknown gateway action '$action'." ) ; } return false ; }
11298	public function getModelsFromCustomRelationship ( $ attributeName , $ objName , $ query = false , $ loadMap = false ) { $ repo = \ Cora \ RepositoryFactory :: make ( $ objName , false , false , false , $ this -> model_db ) ; if ( ! $ query ) $ query = $ this -> _getQueryObjectForRelation ( $ attributeName ) ; $ definingFunctionName = $ this -> model_attributes [ $ attributeName ] [ 'using' ] ; $ query = $ this -> $ definingFunctionName ( $ query ) ; return $ repo -> findAll ( $ query , false , $ loadMap ) ; }
1264	private function createVoidRequest ( $ shipmentData ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; $ container = $ xml -> appendChild ( $ xml -> createElement ( 'VoidShipmentRequest' ) ) ; $ request = $ container -> appendChild ( $ xml -> createElement ( 'Request' ) ) ; $ node = $ xml -> importNode ( $ this -> createTransactionNode ( ) , true ) ; $ request -> appendChild ( $ node ) ; $ request -> appendChild ( $ xml -> createElement ( 'RequestAction' , '1' ) ) ; if ( is_string ( $ shipmentData ) ) { $ container -> appendChild ( $ xml -> createElement ( 'ShipmentIdentificationNumber' , strtoupper ( $ shipmentData ) ) ) ; } else { $ expanded = $ container -> appendChild ( $ xml -> createElement ( 'ExpandedVoidShipment' ) ) ; $ expanded -> appendChild ( $ xml -> createElement ( 'ShipmentIdentificationNumber' , strtoupper ( $ shipmentData [ 'shipmentId' ] ) ) ) ; if ( array_key_exists ( 'trackingNumbers' , $ shipmentData ) ) { foreach ( $ shipmentData [ 'trackingNumbers' ] as $ tn ) { $ expanded -> appendChild ( $ xml -> createElement ( 'TrackingNumber' , strtoupper ( $ tn ) ) ) ; } } } return $ xml -> saveXML ( ) ; }
6299	public function addToBar ( array $ item , $ name = 'default' , $ first = false ) { if ( ! array_key_exists ( $ name , $ this -> bar ) ) { $ this -> bar [ $ name ] = [ ] ; } if ( $ first ) { $ this -> bar [ $ name ] = array_merge ( [ $ item ] , $ this -> bar [ $ name ] ) ; } else { $ this -> bar [ $ name ] [ ] = $ item ; } return $ this ; }
4832	public function payout ( ) { if ( ! $ this -> payout_id ) { throw new GoCardless_ClientException ( "Cannot fetch payout for a bill that has not been paid out" ) ; } return GoCardless_Payout :: find_with_client ( $ this -> client , $ this -> payout_id ) ; }
5995	public function addFolderResponse ( $ item ) { if ( ! ( $ item instanceof self ) ) { if ( is_array ( $ item ) ) { try { $ item = new self ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate FolderResponse. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "FolderResponse"!' , E_USER_WARNING ) ; } } $ this -> subFolders [ ] = $ item ; return $ this ; }
11125	public function index ( Request $ request ) { $ this -> settingRepository -> pushCriteria ( new RequestCriteria ( $ request ) ) ; $ settings = $ this -> settingRepository -> all ( ) ; $ dateFormats = DateFormatter :: dropdownArray ( ) ; return view ( 'l5starter::admin.settings.index' ) -> with ( [ 'dateFormats' => $ dateFormats , 'settings' => $ settings , ] ) ; }
8958	public function validateResponse ( $ url , $ response ) { if ( $ response -> code != 200 ) { $ error = htmlspecialchars ( $ response -> body ) ; throw new \ DomainException ( $ error , $ response -> code ) ; } }
5035	public function setFrom ( $ email , $ name = null ) { if ( is_array ( $ email ) ) { $ this -> from = [ $ email [ 'email' ] => $ email [ 'name' ] ] ; } else { $ this -> from = is_object ( $ email ) || null === $ name ? $ email : array ( $ email => $ name ) ; } return $ this ; }
4305	public function table ( ) { if ( ! $ this -> cfg [ 'collect' ] ) { return ; } $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) ) ; $ event = $ this -> methodTable -> onLog ( new Event ( $ this , array ( 'method' => __FUNCTION__ , 'args' => $ args , 'meta' => $ meta , ) ) ) ; $ this -> appendLog ( $ event [ 'method' ] , $ event [ 'args' ] , $ event [ 'meta' ] ) ; }
4688	public function andWhere ( string $ expression , ... $ args ) : self { $ this -> dirty ( ) ; $ this -> where = $ this -> where ? '(' . $ this -> where . ') AND (' . $ expression . ')' : $ expression ; $ this -> pushArgs ( 'where' , $ args ) ; return $ this ; }
5202	public function open ( ) { try { $ additionalConnectionOptions = array ( ) ; foreach ( array ( 'connection_timeout' , 'read_write_timeout' , 'keepalive' , 'heartbeat' ) as $ option ) { if ( isset ( $ this -> $ option ) ) { $ additionalConnectionOptions [ $ option ] = $ this -> $ option ; } } $ this -> AMQPConnection = new AMQPSSLConnection ( $ this -> host , $ this -> port , $ this -> username , $ this -> password , $ this -> vhost , $ this -> ssl_context_options , $ additionalConnectionOptions ) ; $ this -> channel = $ this -> AMQPConnection -> channel ( ) ; $ this -> channel -> queue_declare ( $ this -> queue_name , false , false , false , false ) ; $ this -> channel -> exchange_declare ( $ this -> exchange , $ this -> exchange_type , false , true , false ) ; $ this -> channel -> queue_bind ( $ this -> queue_name , $ this -> exchange ) ; } catch ( Exception $ e ) { throw new Exception ( $ e ) ; } }
355	public function prepare ( $ forcePrepare = false ) { if ( $ forcePrepare || $ this -> _models === null ) { $ this -> _models = $ this -> prepareModels ( ) ; } if ( $ forcePrepare || $ this -> _keys === null ) { $ this -> _keys = $ this -> prepareKeys ( $ this -> _models ) ; } }
11063	public function getRealEncoding ( $ encoding ) { if ( static :: isEncodingSupported ( $ encoding ) === false ) { throw new \ Exception ( 'Encoding is not supported: "' . $ encoding . '"' ) ; } return static :: supportedEncodings ( ) [ strtolower ( $ encoding ) ] ; }
12057	public function getTarget ( ) { if ( is_null ( $ this -> _target ) && ! empty ( $ this -> possibleTargets ) ) { $ this -> _target = $ this -> possibleTargets [ 0 ] ; } return $ this -> _target ; }
10193	public static function getQueryPreview ( QueryBuilder $ query = null ) { if ( empty ( $ query ) ) { return "" ; } $ sql = str_replace ( '?' , "'%s'" , $ query -> toSql ( ) ) ; $ bindings = $ query -> getBindings ( ) ; return vsprintf ( $ sql , $ bindings ) ; }
12488	public static function write ( $ output ) { if ( self :: $ enabled ) { $ d = new \ DateTime ( ) ; $ f = new File ( self :: $ logFilePath , true ) ; $ f -> write ( $ d -> format ( 'd/m/Y H:i:s' ) . ' - ' . $ output . "\n" , true ) ; } }
8841	public function generateURLSegment ( $ increment = null ) { $ filter = new URLSegmentFilter ( ) ; $ this -> owner -> URLSegment = $ filter -> filter ( $ this -> owner -> Title ) ; if ( is_int ( $ increment ) ) $ this -> owner -> URLSegment .= '-' . $ increment ; $ duplicate = DataList :: create ( $ this -> owner -> ClassName ) -> filter ( array ( "URLSegment" => $ this -> owner -> URLSegment , "BlogID" => $ this -> owner -> BlogID ) ) ; if ( $ this -> owner -> ID ) $ duplicate = $ duplicate -> exclude ( "ID" , $ this -> owner -> ID ) ; if ( $ duplicate -> count ( ) > 0 ) { $ increment = is_int ( $ increment ) ? $ increment + 1 : 0 ; $ this -> owner -> generateURLSegment ( ( int ) $ increment ) ; } return $ this -> owner -> URLSegment ; }
316	public function renderAjax ( $ view , $ params = [ ] , $ context = null ) { $ viewFile = $ this -> findViewFile ( $ view , $ context ) ; ob_start ( ) ; ob_implicit_flush ( false ) ; $ this -> beginPage ( ) ; $ this -> head ( ) ; $ this -> beginBody ( ) ; echo $ this -> renderFile ( $ viewFile , $ params , $ context ) ; $ this -> endBody ( ) ; $ this -> endPage ( true ) ; return ob_get_clean ( ) ; }
5992	public function setSortFields ( array $ sortFields ) { $ this -> sortFields = [ ] ; foreach ( $ sortFields as $ item ) { $ this -> addSearchSort ( $ item ) ; } return $ this ; }
12361	public function getPublisherForMessage ( Message $ message ) { $ attributes = $ message -> getAttributes ( ) ; if ( ! isset ( $ attributes [ 'headers' ] ) || ! isset ( $ attributes [ 'headers' ] [ $ this -> headerName ] ) ) { throw MissingPublisherException :: noHeaderInMessage ( $ message , $ this -> headerName ) ; } $ value = $ attributes [ 'headers' ] [ $ this -> headerName ] ; foreach ( $ this -> valueMap as $ hash => $ values ) { if ( ! in_array ( $ value , $ values , true ) ) { continue ; } return $ this -> publishers [ $ hash ] ; } throw MissingPublisherException :: noKnownPublisherFor ( $ message ) ; }
4105	public function beginBulk ( ) { if ( ! $ this -> bulk ) { $ this -> bulk = $ this -> createBulk ( $ this ) ; } return $ this -> bulk ; }
9110	protected function attainPathName ( ) { $ path = false ; $ config = $ this -> getConfig ( ) ; if ( isset ( $ config [ 'theme_locator' ] [ 'themes_default_path' ] ) ) { $ path = $ config [ 'theme_locator' ] [ 'themes_default_path' ] ; } $ themeName = $ this -> attainThemeName ( ) ; if ( isset ( $ config [ 'themes' ] ) && is_array ( $ config [ 'themes' ] ) && isset ( $ config [ 'themes' ] [ $ themeName ] ) ) { if ( array_key_exists ( 'dir_path' , $ config [ 'themes' ] [ $ themeName ] ) ) { $ path = $ config [ 'themes' ] [ $ themeName ] [ 'dir_path' ] ; } } return $ path ; }
9323	protected function registerMarkdownParser ( ) { $ app = $ this -> app ; $ app -> singleton ( 'commonmark.docparser' , function ( $ app ) { $ environment = $ app [ 'commonmark.environment' ] ; return new DocParser ( $ environment ) ; } ) ; $ app -> alias ( 'commonmark.docparser' , DocParser :: class ) ; }
7504	public function getTf ( string $ key , array $ args = null , array $ replacements = null , string ... $ namespaces ) { if ( empty ( $ namespaces ) ) { $ namespaces = $ this -> meta -> getNamespaces ( ) ; } $ translatedText = $ this -> textService -> tf ( $ namespaces , $ key , $ args , ... $ this -> meta -> getN2nLocales ( ) ) ; $ replacedText = HtmlBuilderMeta :: replace ( $ translatedText , $ replacements , $ this -> view ) ; return new Raw ( $ replacedText ) ; }
6056	public function updateFolder ( $ id , Folder $ folder ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'folder' => $ folder ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/folders/' . $ id . '' , $ parameters ) ; $ result = new FolderResponse ( $ result ) ; return $ result ; }
5938	public function addFunctionality ( $ item ) { if ( ! ( $ item instanceof Functionality ) ) { if ( is_array ( $ item ) ) { try { $ item = new Functionality ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate Functionality. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "Functionality"!' , E_USER_WARNING ) ; } } $ this -> functionalities [ ] = $ item ; return $ this ; }
7933	public function loadFromArray ( array $ data ) { list ( $ data ) = $ this -> fireEvent ( 'load-from-array' , [ $ data ] ) ; $ files = [ ] ; if ( isset ( $ data [ 'files' ] [ 'js' ] ) && is_array ( $ data [ 'files' ] [ 'js' ] ) ) $ files [ 'js' ] = $ this -> resolveFilesList ( $ data [ 'files' ] [ 'js' ] , isset ( $ data [ 'revision' ] ) ? $ data [ 'revision' ] : null ) ; if ( isset ( $ data [ 'files' ] [ 'css' ] ) && is_array ( $ data [ 'files' ] [ 'css' ] ) ) $ files [ 'css' ] = $ this -> resolveFilesList ( $ data [ 'files' ] [ 'css' ] , isset ( $ data [ 'revision' ] ) ? $ data [ 'revision' ] : null ) ; $ item = [ 'order' => isset ( $ data [ 'order' ] ) ? $ data [ 'order' ] : 0 , 'name' => isset ( $ data [ 'name' ] ) ? $ data [ 'name' ] : uniqid ( ) , 'files' => $ files , 'group' => isset ( $ data [ 'group' ] ) ? $ data [ 'group' ] : $ this -> defaultGroup , 'require' => isset ( $ data [ 'require' ] ) ? $ data [ 'require' ] : [ ] ] ; if ( isset ( $ item [ 'files' ] [ 'js' ] ) && is_array ( $ item [ 'files' ] [ 'js' ] ) ) $ item [ 'files' ] [ 'js' ] = $ this -> applyNamespaces ( $ item [ 'files' ] [ 'js' ] ) ; if ( isset ( $ item [ 'files' ] [ 'css' ] ) && is_array ( $ item [ 'files' ] [ 'css' ] ) ) $ item [ 'files' ] [ 'css' ] = $ this -> applyNamespaces ( $ item [ 'files' ] [ 'css' ] ) ; $ this -> loaded [ ] = $ item ; if ( isset ( $ item [ 'require' ] ) && is_array ( $ item [ 'require' ] ) ) { foreach ( $ item [ 'require' ] as $ name ) { $ this -> loadFromCollection ( $ name ) ; } } return $ this ; }
3818	private function generateForm ( $ table , $ metaModel , Request $ request ) { $ fields = [ ] ; foreach ( $ metaModel -> getAttributes ( ) as $ attribute ) { $ attrId = $ attribute -> get ( 'id' ) ; if ( ! $ this -> accepts ( $ attribute ) ) { continue ; } if ( $ this -> knowsAttribute ( $ attribute ) ) { $ fields [ ] = [ 'checkbox' => false , 'text' => $ this -> checkboxCaption ( 'addAll_alreadycontained' , $ table , $ attribute ) , 'class' => 'tl_info' , 'attr_id' => $ attrId , 'name' => 'attribute_' . $ attrId ] ; continue ; } elseif ( $ this -> isAttributeSubmitted ( $ attrId , $ request ) ) { $ fields [ ] = array ( 'checkbox' => false , 'text' => $ this -> checkboxCaption ( 'addAll_addsuccess' , $ table , $ attribute ) , 'class' => 'tl_confirm' , 'attr_id' => $ attrId , 'name' => 'attribute_' . $ attrId ) ; continue ; } $ fields [ ] = [ 'checkbox' => true , 'text' => $ this -> checkboxCaption ( 'addAll_willadd' , $ table , $ attribute ) , 'class' => 'tl_new' , 'attr_id' => $ attrId , 'name' => 'attribute_' . $ attrId ] ; } return $ fields ; }
12759	public static function parse ( & $ string ) { $ media = array ( "objects" => array ( ) , "hashes" => array ( ) , "links" => array ( ) , ) ; preg_match_all ( '#@([\\d\\w]+)#' , $ string , $ mentions ) ; preg_match_all ( '/#([\\d\\w]+)/' , $ string , $ hashTags ) ; preg_match_all ( '/((http|https|ftp|ftps)\:\/\/)([a-z0-9+!*(),;?&=\$_.-]+(\:[a-z0-9+!*(),;?&=\$_.-]+)?@)?([a-zA-Z0-9\-\.]+)\.([a-zA-Z]{2,3})(\:[0-9]{2,5})?(\/([a-z0-9+\$_-]\.?)+)*\/?/' , $ data , $ openLinks ) ; return $ media ; }
11894	public function encrypt ( $ data ) { if ( $ this -> iv === null ) { $ dataEncrypted = mcrypt_encrypt ( $ this -> cipher , $ this -> key , $ data , $ this -> mode ) ; } else { $ dataEncrypted = mcrypt_encrypt ( $ this -> cipher , $ this -> key , $ data , $ this -> mode , $ this -> iv ) ; } return bin2hex ( $ dataEncrypted ) ; }
3953	public function get ( $ strAttributeName ) { return array_key_exists ( $ strAttributeName , $ this -> arrData ) ? $ this -> arrData [ $ strAttributeName ] : null ; }
3504	private function createByReason ( string $ reason , array $ json ) : SendNotificationException { $ reason = strtolower ( $ reason ) ; switch ( $ reason ) { case 'badcollapseid' : return new BadCollapseIdException ( ) ; case 'baddevicetoken' : return new BadDeviceTokenException ( ) ; case 'badexpirationdate' : return new BadExpirationDateException ( ) ; case 'badmessageid' : return new BadMessageIdException ( ) ; case 'badpriority' : return new BadPriorityException ( ) ; case 'badtopic' : return new BadTopicException ( ) ; case 'devicetokennotfortopic' : return new DeviceTokenNotForTopicException ( ) ; case 'duplicateheaders' : return new DuplicateHeadersException ( ) ; case 'idletimeout' : return new IdleTimeoutException ( ) ; case 'missingdevicetoken' : return new MissingDeviceTokenException ( ) ; case 'missingtopic' : return new MissingTopicException ( ) ; case 'payloadempty' : return new PayloadEmptyException ( ) ; case 'topicdisallowed' : return new TopicDisallowedException ( ) ; case 'badcertificate' : return new BadCertificateException ( ) ; case 'badcertificateenvironment' : return new BadCertificateEnvironmentException ( ) ; case 'expiredprovidertoken' : return new ExpiredProviderTokenException ( ) ; case 'forbidden' : return new ForbiddenException ( ) ; case 'invalidprovidertoken' : return new InvalidProviderTokenException ( ) ; case 'missingprovidertoken' : return new MissingProviderTokenException ( ) ; case 'badpath' : return new BadPathException ( ) ; case 'methodnotallowed' : return new MethodNotAllowedException ( ) ; case 'unregistered' : $ timestamp = array_key_exists ( 'timestamp' , $ json ) ? $ json [ 'timestamp' ] : 0 ; $ lastConfirmed = new \ DateTime ( 'now' , new \ DateTimeZone ( 'UTC' ) ) ; $ lastConfirmed -> setTimestamp ( $ timestamp ) ; return new UnregisteredException ( $ lastConfirmed ) ; case 'payloadtoolarge' : return new PayloadTooLargeException ( ) ; case 'toomanyprovidertokenupdates' : return new TooManyProviderTokenUpdatesException ( ) ; case 'toomanyrequests' : return new TooManyRequestsException ( ) ; case 'internalservererror' : return new InternalServerErrorException ( ) ; case 'serviceunavailable' : return new ServiceUnavailableException ( ) ; case 'shutdown' : return new ShutdownException ( ) ; default : return new UndefinedErrorException ( ) ; } }
11013	protected function importDataFile ( string $ dataFile , string $ controlTableName = null ) : void { if ( $ controlTableName !== null ) { $ query = $ this -> db -> createQueryBuilder ( ) ; $ query -> select ( 'count(*) AS count' ) -> from ( $ controlTableName ) ; $ data = $ query -> execute ( ) -> fetchAll ( ) ; $ contentCount = ( int ) $ data [ 0 ] [ 'count' ] ; if ( $ contentCount > 0 ) { $ this -> output -> writeln ( '<comment>Data already exists in the database, skipping data import for file <info>' . $ dataFile . '</info></comment>' ) ; return ; } } $ this -> runQueriesFromFile ( $ dataFile ) ; }
9559	public function resolve ( $ handler ) { if ( ! is_string ( $ handler ) ) { return $ handler ; } $ handler = $ this -> container -> resolve ( $ handler ) ; if ( ! is_callable ( $ handler ) && ! $ handler instanceof ErrorHandlerInterface ) { $ type = is_object ( $ handler ) ? get_class ( $ handler ) : gettype ( $ handler ) ; throw new \ UnexpectedValueException ( "Resolved error handler is not a valid handler - must be callable or an instance of Autarky\Errors\ErrorHandlerInterface, $type given" ) ; } return $ handler ; }
12617	public function removeAttribute ( string $ attributeName ) { if ( isset ( $ this -> attributes [ $ attributeName ] ) ) unset ( $ this -> attributes [ $ attributeName ] ) ; }
213	public function registerClientScript ( ) { $ js = '' ; $ view = $ this -> getView ( ) ; $ this -> initClientOptions ( ) ; if ( ! empty ( $ this -> mask ) ) { $ this -> clientOptions [ 'mask' ] = $ this -> mask ; } $ this -> hashPluginOptions ( $ view ) ; if ( is_array ( $ this -> definitions ) && ! empty ( $ this -> definitions ) ) { $ js .= ucfirst ( self :: PLUGIN_NAME ) . '.extendDefinitions(' . Json :: htmlEncode ( $ this -> definitions ) . ');' ; } if ( is_array ( $ this -> aliases ) && ! empty ( $ this -> aliases ) ) { $ js .= ucfirst ( self :: PLUGIN_NAME ) . '.extendAliases(' . Json :: htmlEncode ( $ this -> aliases ) . ');' ; } $ id = $ this -> options [ 'id' ] ; $ js .= 'jQuery("#' . $ id . '").' . self :: PLUGIN_NAME . '(' . $ this -> _hashVar . ');' ; MaskedInputAsset :: register ( $ view ) ; $ view -> registerJs ( $ js ) ; }
9850	public function stringToStream ( string $ input ) : StreamInterface { $ stream = \ fopen ( 'php://temp' , 'w+' ) ; if ( ! \ is_resource ( $ stream ) ) { throw new \ Error ( 'Could not create stream' ) ; } \ fwrite ( $ stream , $ input ) ; \ rewind ( $ stream ) ; return new Stream ( $ stream ) ; }
4089	protected function buildUrl ( $ path = false , array $ options = array ( ) ) { $ isAbsolute = ( is_array ( $ path ) ? $ path [ 0 ] [ 0 ] : $ path [ 0 ] ) === '/' ; $ url = $ isAbsolute || null === $ this -> index ? '' : "/" . $ this -> index ; if ( $ path && is_array ( $ path ) && count ( $ path ) > 0 ) $ url .= "/" . implode ( "/" , array_filter ( $ path ) ) ; if ( substr ( $ url , - 1 ) == "/" ) $ url = substr ( $ url , 0 , - 1 ) ; if ( count ( $ options ) > 0 ) $ url .= "?" . http_build_query ( $ options , '' , '&' ) ; return $ url ; }
6592	protected function checkAndGetBusters ( ) { if ( $ this -> fileSystem -> fileExists ( $ this -> config [ 'bustersJsonPath' ] ) === false ) { throw new LengthException ( 'busters json not found.' ) ; } $ bustersJson = $ this -> fileSystem -> getFile ( $ this -> config [ 'bustersJsonPath' ] ) ; if ( $ bustersJson == '' ) { throw new UnderflowException ( 'busters json is empty.' ) ; } $ busters = json_decode ( $ bustersJson ) ; if ( json_last_error ( ) !== JSON_ERROR_NONE ) { throw new UnexpectedValueException ( 'bustersJson is invalid JSON.' ) ; } return $ busters ; }
4157	function cron ( $ expression , Job $ job ) { $ expression = new CronExpression ( $ expression ) ; $ this -> add ( $ expression , $ job ) ; return $ this ; }
12521	public function renderLabel ( $ customFieldOrClass , $ slug = null , array $ params = array ( ) ) { $ resolvedParams = array_merge ( $ this -> defaultParams , $ params ) ; $ customField = ( $ customFieldOrClass instanceof CustomField ) ? $ customFieldOrClass : $ this -> container -> get ( 'chill.custom_field.provider' ) -> getCustomField ( $ customFieldOrClass , $ slug ) ; return $ this -> container -> get ( 'templating' ) -> render ( $ resolvedParams [ 'label_layout' ] , array ( 'customField' => $ customField ) ) ; }
7030	public function toArray ( ) { return [ 'o_msg' => $ this -> overflowMessage , 'min_qty' => $ this -> minimumQuantity , 'min_msg' => $ this -> minimumMessage , 'max_qty' => INF === $ this -> maximumQuantity ? 'INF' : $ this -> maximumQuantity , 'max_msg' => $ this -> maximumMessage , 'a_qty' => INF === $ this -> availableQuantity ? 'INF' : $ this -> availableQuantity , 'a_msg' => $ this -> availableMessage , 'r_qty' => $ this -> resupplyQuantity , 'r_msg' => $ this -> resupplyMessage , ] ; }
3431	public function count ( ) { if ( $ this -> queryShouldBeStopped ) { return 0 ; } $ queryType = 'SectionQuery::count' ; $ filter = $ this -> normalizeFilter ( ) ; $ callback = function ( ) use ( $ filter ) { return ( int ) $ this -> bxObject -> getCount ( $ filter ) ; } ; return $ this -> handleCacheIfNeeded ( compact ( 'queryType' , 'filter' ) , $ callback ) ; }
2186	public function fetch ( $ strTable , $ varKey , $ strAlias = null ) { $ strClass = Model :: getClassFromTable ( $ strTable ) ; $ strPk = $ strClass :: getPk ( ) ; if ( $ strAlias === null || $ strAlias == $ strPk ) { if ( isset ( $ this -> arrRegistry [ $ strTable ] [ $ varKey ] ) ) { return $ this -> arrRegistry [ $ strTable ] [ $ varKey ] ; } return null ; } return $ this -> fetchByAlias ( $ strTable , $ strAlias , $ varKey ) ; }
10136	private function writeZoom ( ) { if ( $ this -> phpSheet -> getSheetView ( ) -> getZoomScale ( ) == 100 ) { return ; } $ record = 0x00A0 ; $ length = 0x0004 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vv' , $ this -> phpSheet -> getSheetView ( ) -> getZoomScale ( ) , 100 ) ; $ this -> append ( $ header . $ data ) ; }
7078	static public function isSaleSupportsDocumentType ( SaleInterface $ sale , $ type ) { if ( ! DocumentTypes :: isValidType ( $ type ) ) { return false ; } if ( empty ( $ classes = DocumentTypes :: getClasses ( $ type ) ) ) { return false ; } foreach ( $ classes as $ class ) { if ( is_subclass_of ( $ sale , $ class ) ) { return true ; } } return false ; }
3236	public function getTotalPriceAttribute ( ) { if ( empty ( $ this -> shopCalculations ) ) $ this -> runCalculations ( ) ; return round ( $ this -> shopCalculations -> totalPrice , 2 ) ; }
1364	public function register ( ) { $ this -> bindNeomerx ( ) ; $ this -> bindService ( ) ; $ this -> bindInboundRequest ( ) ; $ this -> bindRouteRegistrar ( ) ; $ this -> bindApiRepository ( ) ; $ this -> bindExceptionParser ( ) ; $ this -> bindRenderer ( ) ; $ this -> mergePackageConfig ( ) ; }
5672	protected function describeFloatDifference ( $ first , $ second , $ identical ) { if ( is_object ( $ second ) || is_array ( $ second ) ) { return $ this -> describeGenericDifference ( $ first , $ second ) ; } return sprintf ( 'because [%s] differs from [%s] by %s' , $ this -> describeValue ( $ first ) , $ this -> describeValue ( $ second ) , abs ( $ first - $ second ) ) ; }
6443	public function httpRequest ( $ url ) { if ( DEBUG ) echo "HTTP request: $url\n" ; $ curl = curl_init ( ) ; curl_setopt ( $ curl , CURLOPT_URL , $ url ) ; curl_setopt ( $ curl , CURLOPT_HEADER , 0 ) ; curl_setopt ( $ curl , CURLOPT_RETURNTRANSFER , true ) ; curl_setopt ( $ curl , CURLOPT_TIMEOUT , CURL_TIMEOUT ) ; curl_setopt ( $ curl , CURLOPT_USERAGENT , SPIDER_NAME ) ; curl_setopt ( $ curl , CURLOPT_VERBOSE , false ) ; curl_setopt ( $ curl , CURLOPT_MAXREDIRS , 4 ) ; curl_setopt ( $ curl , CURLOPT_FOLLOWLOCATION , true ) ; $ response [ 'file' ] = curl_exec ( $ curl ) ; $ response [ 'status' ] = curl_getinfo ( $ curl ) ; $ response [ 'error' ] = curl_error ( $ curl ) ; curl_exec ( $ curl ) ; curl_close ( $ curl ) ; if ( DEBUG === 'verbose' ) { echo "Retrieved HTTP:\n" ; var_dump ( $ response [ 'status' ] ) ; var_dump ( $ response [ 'error' ] ) ; } if ( $ response [ 'file' ] == '' ) die ( "Error while making the HTTP request: no HTML retrieved." ) ; return $ response ; }
180	protected function loadDummyBundle ( $ name ) { if ( ! isset ( $ this -> _dummyBundles [ $ name ] ) ) { $ this -> _dummyBundles [ $ name ] = $ this -> loadBundle ( $ name , [ 'sourcePath' => null , 'js' => [ ] , 'css' => [ ] , 'depends' => [ ] , ] ) ; } return $ this -> _dummyBundles [ $ name ] ; }
11665	private function filterElement ( ElementInterface $ element ) { $ value = $ element -> getValue ( ) ; foreach ( $ this -> filters as $ scope => $ filter ) { $ elementIds = array_map ( 'trim' , explode ( ',' , $ scope ) ) ; if ( $ scope === '*' || in_array ( $ element -> getID ( ) , $ elementIds ) ) { $ value = $ filter -> filter ( $ value ) ; } } $ element -> setValue ( $ value ) ; }
9473	public function deleteFaild ( $ message = null ) { if ( is_null ( $ message ) ) $ message = $ this -> config [ 'fail' ] [ 'delete' ] ; return $ this -> setStatusCode ( 447 ) -> setStatusText ( 'fail' ) -> setErrorCode ( 5447 ) -> respondWithMessage ( $ message ) ; }
4372	public function onOutput ( Event $ event ) { $ this -> data = $ this -> debug -> getData ( ) ; $ this -> channels = array ( ) ; $ str = '<div' . $ this -> debug -> utilities -> buildAttribString ( array ( 'class' => 'debug' , 'data-channels' => '{{channels}}' , 'data-channel-root' => $ this -> channelNameRoot , ) ) . ">\n" ; if ( $ this -> debug -> getCfg ( 'output.outputCss' ) ) { $ str .= '<style type="text/css">' . "\n" . $ this -> debug -> output -> getCss ( ) . "\n" . '</style>' . "\n" ; } if ( $ this -> debug -> getCfg ( 'output.outputScript' ) ) { $ str .= '<script type="text/javascript">' . \ file_get_contents ( $ this -> debug -> getCfg ( 'filepathScript' ) ) . '</script>' . "\n" ; } $ str .= '<div class="debug-bar"><h3>Debug Log</h3></div>' . "\n" ; $ str .= $ this -> processAlerts ( ) ; if ( $ this -> debug -> getCfg ( 'output.outputScript' ) ) { $ str .= '<div class="loading">Loading <i class="fa fa-spinner fa-pulse fa-2x fa-fw" aria-hidden="true"></i></div>' . "\n" ; } $ str .= '<div class="debug-header m_group"' . ( $ this -> debug -> getCfg ( 'outputScript' ) ? ' style="display:none;"' : '' ) . '>' . "\n" ; $ str .= $ this -> processSummary ( ) ; $ str .= '</div>' . "\n" ; $ str .= '<div class="debug-content m_group"' . ( $ this -> debug -> getCfg ( 'outputScript' ) ? ' style="display:none;"' : '' ) . '>' . "\n" ; $ str .= $ this -> processLog ( ) ; $ str .= '</div>' . "\n" ; $ str .= '</div>' . "\n" ; $ str = \ strtr ( $ str , array ( '{{channels}}' => \ htmlspecialchars ( \ json_encode ( $ this -> buildChannelTree ( ) , JSON_FORCE_OBJECT ) ) , ) ) ; $ this -> data = array ( ) ; $ event [ 'return' ] .= $ str ; }
9529	private function validateRequiredParameters ( ) { $ ret = true ; foreach ( $ this -> parameterCluster -> prefixes as $ prefix => $ parameters ) { foreach ( $ parameters as $ parameterClosure ) { if ( $ parameterClosure -> required ) { if ( ! in_array ( $ parameterClosure -> prefix . $ parameterClosure -> parameterName , $ this -> argv ) ) { $ aliasFound = false ; foreach ( $ parameterClosure -> aliases as $ prefix => $ alias ) { if ( in_array ( $ prefix . $ alias , $ this -> argv ) ) { $ aliasFound = true ; break ; } } if ( ! $ aliasFound ) { $ ret = $ parameterClosure ; break 2 ; } } } } } return $ ret ; }
1232	public function offsetSet ( $ offset , $ value ) { self :: ensurePropertyType ( $ value ) ; if ( is_null ( $ offset ) ) { $ this -> data [ ] = $ value ; } else { $ this -> data [ $ offset ] = $ value ; } }
435	public function beforeAction ( $ action ) { $ event = new ActionEvent ( $ action ) ; $ this -> trigger ( self :: EVENT_BEFORE_ACTION , $ event ) ; return $ event -> isValid ; }
3630	protected function validateItems ( array $ items , $ type ) { foreach ( $ items as $ item ) { $ this -> validateItem ( $ item , $ type ) ; } }
2509	protected function findBuilderForMessage ( $ messageName ) { $ builder = null ; if ( array_key_exists ( $ messageName , $ this -> messageBuilders ) && $ this -> messageBuilders [ $ messageName ] instanceof ConvertInterface ) { $ builder = $ this -> messageBuilders [ $ messageName ] ; } else { $ section = substr ( $ messageName , 0 , strpos ( $ messageName , '_' ) ) ; $ message = substr ( $ messageName , strpos ( $ messageName , '_' ) + 1 ) ; $ builderClass = __NAMESPACE__ . '\\Converter\\' . $ section . '\\' . $ message . "Conv" ; if ( class_exists ( $ builderClass ) ) { $ builder = new $ builderClass ( ) ; $ builder -> setParams ( $ this -> params ) ; $ this -> messageBuilders [ $ messageName ] = $ builder ; } } return $ builder ; }
2374	public static function srcToInsertTag ( $ data ) { $ return = '' ; $ paths = preg_split ( '/((src|href)="([^"]+)")/i' , $ data , - 1 , PREG_SPLIT_DELIM_CAPTURE ) ; for ( $ i = 0 , $ c = \ count ( $ paths ) ; $ i < $ c ; $ i += 4 ) { $ return .= $ paths [ $ i ] ; if ( ! isset ( $ paths [ $ i + 1 ] ) ) { continue ; } $ file = FilesModel :: findByPath ( $ paths [ $ i + 3 ] ) ; if ( $ file !== null ) { $ return .= $ paths [ $ i + 2 ] . '="{{file::' . static :: binToUuid ( $ file -> uuid ) . '}}"' ; } else { $ return .= $ paths [ $ i + 2 ] . '="' . $ paths [ $ i + 3 ] . '"' ; } } return $ return ; }
10723	public function raw ( $ sql , array $ params ) { $ stmt = $ this -> connect ( ) -> prepare ( $ sql ) ; $ stmt -> execute ( $ params ) ; if ( stripos ( $ sql , 'select' ) === 0 ) { return $ stmt -> fetchAll ( PDO :: FETCH_ASSOC ) ; } if ( stripos ( $ sql , 'insert' ) === 0 ) { return $ this -> connect ( ) -> lastInsertId ( ) ; } return $ stmt -> execute ( ) ; }
1792	private function addHostToContext ( RequestContext $ context , array $ parameters , int & $ referenceType ) : void { [ $ host , $ port ] = $ this -> getHostAndPort ( $ parameters [ '_domain' ] ) ; if ( $ context -> getHost ( ) === $ host ) { return ; } $ context -> setHost ( $ host ) ; $ referenceType = UrlGeneratorInterface :: ABSOLUTE_URL ; if ( ! $ port ) { return ; } if ( isset ( $ parameters [ '_ssl' ] ) && true === $ parameters [ '_ssl' ] ) { $ context -> setHttpsPort ( $ port ) ; } else { $ context -> setHttpPort ( $ port ) ; } }
11250	public function delete ( string $ migration ) : void { $ stmt = $ this -> pdo -> prepare ( "delete from {$this->table} where migration = ?" ) ; $ stmt -> bindParam ( 1 , $ migration ) ; $ stmt -> execute ( ) ; }
5159	private static function createGallery ( String $ body , int $ order , String $ photo , String $ source , string $ lead ) : \ One \ Model \ Gallery { return new Gallery ( $ body , $ order , $ photo , $ source , $ lead ) ; }
3476	protected function request ( $ verb , $ endpoint , array $ data ) { $ url = rtrim ( $ this -> baseUrl , '/' ) . '/' . ltrim ( $ endpoint , '/' ) ; try { $ response = $ this -> httpClient -> request ( $ verb , $ url , [ 'headers' => [ 'Authorization' => 'Bot ' . $ this -> token , ] , 'json' => $ data , ] ) ; } catch ( RequestException $ exception ) { if ( $ response = $ exception -> getResponse ( ) ) { throw CouldNotSendNotification :: serviceRespondedWithAnHttpError ( $ response ) ; } throw CouldNotSendNotification :: serviceCommunicationError ( $ exception ) ; } catch ( Exception $ exception ) { throw CouldNotSendNotification :: serviceCommunicationError ( $ exception ) ; } $ body = json_decode ( $ response -> getBody ( ) , true ) ; if ( Arr :: get ( $ body , 'code' , 0 ) > 0 ) { throw CouldNotSendNotification :: serviceRespondedWithAnApiError ( $ body ) ; } return $ body ; }
3679	private function buildBackendModules ( & $ localMenu ) { foreach ( $ this -> viewCombination -> getStandalone ( ) as $ metaModelName => $ screen ) { $ section = $ screen [ 'meta' ] [ 'backendsection' ] ; if ( ! isset ( $ localMenu [ $ section ] ) ) { $ localMenu [ $ section ] = [ ] ; } if ( ! isset ( $ localMenu [ $ section ] [ 'metamodel_' . $ metaModelName ] ) ) { $ localMenu [ $ section ] [ 'metamodel_' . $ metaModelName ] = [ 'tables' => [ ] ] ; } $ localMenu [ $ section ] [ 'metamodel_' . $ metaModelName ] [ 'callback' ] = Module :: class ; array_unshift ( $ localMenu [ $ section ] [ 'metamodel_' . $ metaModelName ] [ 'tables' ] , $ metaModelName ) ; } }
1029	private function resolveOrError ( $ fieldDef , $ fieldNode , $ resolveFn , $ source , $ context , $ info ) { try { $ args = Values :: getArgumentValues ( $ fieldDef , $ fieldNode , $ this -> exeContext -> variableValues ) ; return $ resolveFn ( $ source , $ args , $ context , $ info ) ; } catch ( Exception $ error ) { return $ error ; } catch ( Throwable $ error ) { return $ error ; } }
4898	private static function checkCache ( array $ configuration ) { $ config = $ configuration [ 'module_listener_options' ] ; $ options = new ListenerOptions ( $ config ) ; $ cache = new ClearCacheService ( $ options ) ; $ cache -> checkCache ( ) ; }
1102	protected function hasChange ( ) { return ! ( $ this -> bound1 ( ) == $ this -> node -> getRight ( ) || $ this -> bound1 ( ) == $ this -> node -> getLeft ( ) ) ; }
7246	private function hasStockableSubject ( Common \ SaleItemInterface $ saleItem ) { if ( ! $ saleItem instanceof Stock \ StockAssignmentsInterface ) { return false ; } if ( null === $ subject = $ this -> subjectHelper -> resolve ( $ saleItem ) ) { return false ; } if ( ! $ subject instanceof Stock \ StockSubjectInterface ) { return false ; } if ( $ subject -> isStockCompound ( ) ) { return false ; } if ( $ subject -> getStockMode ( ) === Stock \ StockSubjectModes :: MODE_DISABLED ) { return false ; } return true ; }
11430	private function runRoute ( array $ routeInfo ) : Response { list ( $ _ , $ callback , $ vars ) = $ routeInfo ; $ vars = array_filter ( $ vars , function ( $ var ) { return strpos ( $ var , '_' ) !== 0 ; } , ARRAY_FILTER_USE_KEY ) ; if ( ! class_exists ( $ callback [ 0 ] ) ) { throw new ControllerNotFoundException ( 'Trying to instantiate a non existent controller (`' . $ callback [ 0 ] . '`)' ) ; } $ controller = new $ callback [ 0 ] ( $ this -> response , $ this -> session ) ; if ( ! method_exists ( $ controller , $ callback [ 1 ] ) ) { throw new ActionNotFoundException ( 'Trying to call a non existent action (`' . $ callback [ 0 ] . '::' . $ callback [ 1 ] . '`)' ) ; } return $ this -> injector -> execute ( [ $ controller , $ callback [ 1 ] ] , array_map ( 'urldecode' , $ vars ) ) ; }
7831	public function getSpacedCore ( ) { $ left = $ this -> getSpacesByCore ( ) ; $ right = $ this -> getSpacesByCore ( true ) ; return $ left . $ this -> core . $ right ; }
9384	public function getIcons ( ) { $ icons = [ ] ; foreach ( $ this -> getGroupedIcons ( ) as $ name => $ group ) { foreach ( $ group as $ id => $ icon ) { if ( ! isset ( $ icons [ $ id ] ) ) { $ icons [ $ id ] = isset ( $ icon [ 'name' ] ) ? $ icon [ 'name' ] : $ id ; } } } ksort ( $ icons ) ; return $ icons ; }
9959	public function unprotectCellsByColumnAndRow ( $ columnIndex1 , $ row1 , $ columnIndex2 , $ row2 ) { $ cellRange = Coordinate :: stringFromColumnIndex ( $ columnIndex1 ) . $ row1 . ':' . Coordinate :: stringFromColumnIndex ( $ columnIndex2 ) . $ row2 ; return $ this -> unprotectCells ( $ cellRange ) ; }
6653	public function removeExtraData ( array $ extraDataKeys = [ ] ) { foreach ( $ extraDataKeys as $ key ) { if ( array_key_exists ( $ key , $ this -> extraData ) ) { unset ( $ this -> extraData [ $ key ] ) ; } } }
8689	private static function doFlatten ( $ iterable , $ depth , callable $ predicate , array $ result = [ ] ) { foreach ( $ iterable as $ item ) { if ( $ depth >= 1 && $ predicate ( $ item ) ) { $ result = static :: doFlatten ( $ item , $ depth - 1 , $ predicate , $ result ) ; } else { $ result [ ] = $ item ; } } return $ result ; }
12650	protected function readFileContents ( $ language ) { $ fileName = $ this -> getFileName ( $ language ) ; $ fs = $ this -> env -> getFileSystem ( ) ; if ( ! $ fs -> fileExists ( $ fileName ) ) { return array ( ) ; } $ content = json_decode ( preg_replace ( '/^.*?define\((.*)\);\s*/s' , '$1' , $ fs -> getFile ( $ fileName ) ) , true ) ; if ( $ language === $ this -> baseLang ) { $ content = $ content [ 'root' ] ; } $ outdateInfo = [ ] ; $ fileName = $ this -> getOutdateInfoFileName ( $ language ) ; if ( $ fs -> fileExists ( $ fileName ) ) { $ outdateInfo = json_decode ( $ fs -> getFile ( $ fileName ) , true ) ; } foreach ( $ content as $ id => $ text ) { $ outdated = isset ( $ outdateInfo [ $ id ] ) ? $ outdateInfo [ $ id ] : true ; $ content [ $ id ] = array ( 'id' => $ id , 'name' => $ id , 'content' => $ text , 'outdated' => $ outdated ) ; } return $ content ; }
1184	protected function wrapValidator ( ) { $ resolver = new Resolver ( $ this -> factory ) ; $ this -> factory -> resolver ( $ resolver -> resolver ( $ this -> field ) ) ; $ this -> factory -> extend ( RemoteValidator :: EXTENSION_NAME , $ resolver -> validatorClosure ( ) ) ; }
74	public function requestToken ( $ originUrl , $ consumerKey , $ consumerSecret ) { if ( ! empty ( $ this -> token ) || $ this -> getTokenFromConfig ( $ originUrl ) ) { return $ this -> token [ 'access_token' ] ; } $ this -> io -> setAuthentication ( $ originUrl , $ consumerKey , $ consumerSecret ) ; if ( ! $ this -> requestAccessToken ( $ originUrl ) ) { return '' ; } $ this -> storeInAuthConfig ( $ originUrl , $ consumerKey , $ consumerSecret ) ; return $ this -> token [ 'access_token' ] ; }
11015	public static function sec2time ( $ seconds ) { $ sec = intval ( $ seconds ) ; $ dtF = new \ DateTime ( "@0" ) ; $ dtT = new \ DateTime ( "@$sec" ) ; return $ dtF -> diff ( $ dtT ) -> format ( '%a days, %h hours, %i minutes and %s seconds' ) ; }
2538	protected function initSoapClient ( $ wsdlId ) { $ wsdlPath = WsdlAnalyser :: $ wsdlIds [ $ wsdlId ] ; $ client = new Client \ SoapClient ( $ wsdlPath , $ this -> makeSoapClientOptions ( ) , $ this -> params -> logger ) ; return $ client ; }
3801	public function getCache ( ) { @ trigger_error ( '"' . __METHOD__ . '" is deprecated as the service container will get removed.' , E_USER_DEPRECATED ) ; if ( \ is_callable ( $ this -> cache ) ) { $ this -> cache = \ call_user_func ( $ this -> cache ) ; } return $ this -> cache ; }
5470	protected function describePatternMatch ( $ pattern , $ subject ) { preg_match ( $ pattern , $ subject , $ matches ) ; $ position = strpos ( $ subject , $ matches [ 0 ] ) ; $ dumper = $ this -> getDumper ( ) ; return "Pattern [$pattern] detected at character [$position] in [" . $ dumper -> describeValue ( $ subject ) . '] as [' . $ matches [ 0 ] . '] in region [' . $ dumper -> clipString ( $ subject , 100 , $ position ) . ']' ; }
5180	private function addArray ( string $ key , $ value ) : self { $ this -> props [ $ key ] [ ] = $ value ; return $ this ; }
12886	public function setRawPhoto ( $ photo ) { if ( empty ( $ photo ) ) { return true ; } if ( ! ( $ photo instanceof FileInterface ) ) { $ photo = RawFile :: createRawInstance ( $ photo ) ; } return $ this -> setStorage ( $ photo ) ; }
3294	protected function buildLink ( $ provider , $ url ) { $ fontAwesomeVersion = config ( 'laravel-share.fontAwesomeVersion' , 4 ) ; $ this -> html .= trans ( "laravel-share::laravel-share-fa$fontAwesomeVersion.$provider" , [ 'url' => $ url , 'class' => key_exists ( 'class' , $ this -> options ) ? $ this -> options [ 'class' ] : '' , 'id' => key_exists ( 'id' , $ this -> options ) ? $ this -> options [ 'id' ] : '' , ] ) ; }
9543	public function getMessages ( ) { $ messages = array ( ) ; if ( ! empty ( $ this -> error ) ) { $ messages [ ] = $ this -> error ; } if ( ! empty ( $ this -> warning ) ) { $ messages [ ] = $ this -> warning ; } return $ messages ; }
3655	private function getLabelText ( $ type ) { $ label = $ this -> translator -> trans ( 'tl_metamodel_dcasetting_condition.typedesc.' . $ type , [ ] , 'contao_tl_metamodel_dcasetting_condition' ) ; if ( $ label === 'tl_metamodel_dcasetting_condition.typedesc.' . $ type ) { $ label = $ this -> translator -> trans ( 'tl_metamodel_dcasetting_condition.typedesc._default_' , [ ] , 'contao_tl_metamodel_dcasetting_condition' ) ; if ( $ label === 'tl_metamodel_dcasetting_condition.typedesc._default_' ) { return $ type ; } } return $ label ; }
11684	protected function registerCommands ( ) { $ this -> commands ( \ Lab123 \ Odin \ Command \ AppRestart :: class ) ; $ this -> commands ( \ Lab123 \ Odin \ Command \ AppStart :: class ) ; $ this -> commands ( \ Lab123 \ Odin \ Command \ GeneratePasswordCommand :: class ) ; $ this -> commands ( \ Lab123 \ Odin \ Command \ LumenAppNameCommand :: class ) ; $ this -> commands ( \ Lab123 \ Odin \ Command \ LumenRouteList :: class ) ; $ this -> commands ( \ Lab123 \ Odin \ Command \ LumenVendorPublish :: class ) ; $ this -> commands ( \ Lab123 \ Odin \ Command \ LumenModelMake :: class ) ; }
5800	public function delete ( int $ id , AuthenticationService $ authentication , AuthorizationService $ authorization ) : string { if ( null === $ administrator = $ this -> getObjectById ( $ id ) ) { throw new Exceptions \ QueryResultsNotFoundException ( ) ; } $ administrator -> setAuth ( $ authentication , $ authorization ) ; if ( ! $ administrator -> isDeletable ( ) ) { throw new Exceptions \ UnallowedActionException ( $ administrator -> getNotDeletableReason ( ) ) ; } $ this -> doDeleteTransaction ( $ id ) ; $ username = $ administrator -> getUsername ( ) ; unset ( $ administrator ) ; return $ username ; }
11859	public static function getHandlingObject ( $ a , $ b ) { $ handlingA = $ a -> handlingComparison ; $ handlingB = $ b -> handlingComparison ; if ( ! $ handlingB ) { return $ a ; } if ( $ handlingA !== false && $ handlingB !== false ) { if ( $ handlingA > $ handlingB ) { return $ a ; } else { return $ b ; } } return $ a ; }
3514	public function postMissingKeys ( ) { $ missingKeys = Request :: json ( 'missingKeys' ) ; $ this -> manager -> setConnectionName ( '' ) ; $ translator = App :: make ( 'translator' ) ; $ affectedGroups = [ ] ; foreach ( $ missingKeys as $ key ) { $ key = decodeKey ( $ key ) ; list ( $ namespace , $ group , $ item ) = $ translator -> parseKey ( $ key ) ; if ( $ item && $ group ) { if ( ! in_array ( $ group , $ this -> manager -> config ( Manager :: EXCLUDE_GROUPS_KEY ) ) ) { $ t = $ this -> manager -> missingKey ( $ namespace , $ group , $ item , null , false , true ) ; if ( ! $ t -> exists ) { $ affectedGroups [ ] = $ t -> group ; $ t -> save ( ) ; } } } else { } } $ data = [ 'connectionName' => '' , 'affectedGroups' => $ affectedGroups , 'missingKeys' => [ ] , ] ; $ pretty = Request :: has ( 'pretty-json' ) ? JSON_PRETTY_PRINT : 0 ; return Response :: json ( $ data , 200 , [ ] , JSON_UNESCAPED_SLASHES | $ pretty ) ; }
11225	private static function getErrorCallback ( ) { $ errorCallback = self :: $ errorCallback ; self :: $ errorCallback = false ; if ( ! $ errorCallback ) { return false ; } if ( ! is_object ( $ errorCallback ) ) { return self :: invokeObject ( $ errorCallback ) ; } return call_user_func ( $ errorCallback ) ; }
4651	public function clean ( $ projectPath , $ keep = 1 , $ force = false ) { $ builds = $ this -> getJobsToRemove ( $ projectPath , $ keep ) ; $ this -> cleanDirectories ( $ builds ) ; $ this -> cleanContainers ( $ builds ) ; $ this -> cleanImages ( $ builds , $ force ) ; }
4522	public function postLoad ( LifecycleEventArgs $ args ) { $ entity = $ args -> getEntity ( ) ; if ( ! $ entity instanceof Config ) { return ; } $ key = $ entity -> getKey ( ) ; $ encrypt = $ this -> configCollection -> get ( $ key ) [ 'encrypt' ] ; $ entity -> setEncrypt ( $ encrypt ) ; }
7467	public function addColor ( $ color , $ code = null ) { $ newColors = $ this -> parseColor ( $ color , $ code ) ; $ this -> colors = array_merge ( $ this -> colors , $ newColors ) ; return $ this ; }
12440	public function get ( $ key ) { if ( ! isset ( $ this -> instances [ $ key ] ) ) { throw new \ LogicException ( 'No instance for given key! (key: ' . $ key . ')' ) ; } return $ this -> instances [ $ key ] ; }
3908	public function setAcceptedExtensions ( $ acceptedExtensions ) { $ allowedDownload = StringUtil :: trimsplit ( ',' , $ GLOBALS [ 'TL_CONFIG' ] [ 'allowedDownload' ] ) ; if ( ! is_array ( $ acceptedExtensions ) ) { $ acceptedExtensions = StringUtil :: trimsplit ( ',' , $ acceptedExtensions ) ; } $ this -> acceptedExtensions = array_map ( 'strtolower' , array_intersect ( $ allowedDownload , $ acceptedExtensions ) ) ; }
4136	public function getParams ( array $ params ) { $ r = '' ; ksort ( $ params ) ; foreach ( $ params as $ key => $ value ) { $ r .= '&' . $ key . '=' . rawurlencode ( $ value ) ; } unset ( $ params , $ key , $ value ) ; return trim ( $ r , '&' ) ; }
9781	private function setFlag ( string $ name , bool $ value = true ) : self { $ this -> flags [ $ name ] = $ value ; return $ this ; }
96	public function read ( $ url ) { $ xml = $ this -> requestXml ( $ url , "/channel.xml" ) ; $ channelName = ( string ) $ xml -> name ; $ channelAlias = ( string ) $ xml -> suggestedalias ; $ supportedVersions = array_keys ( $ this -> readerMap ) ; $ selectedRestVersion = $ this -> selectRestVersion ( $ xml , $ supportedVersions ) ; if ( ! $ selectedRestVersion ) { throw new \ UnexpectedValueException ( sprintf ( 'PEAR repository %s does not supports any of %s protocols.' , $ url , implode ( ', ' , $ supportedVersions ) ) ) ; } $ reader = $ this -> readerMap [ $ selectedRestVersion [ 'version' ] ] ; $ packageDefinitions = $ reader -> read ( $ selectedRestVersion [ 'baseUrl' ] ) ; return new ChannelInfo ( $ channelName , $ channelAlias , $ packageDefinitions ) ; }
12861	private function buildCache ( ) : array { $ dispatchData = $ this -> routeCollector -> getData ( ) ; file_put_contents ( $ this -> cacheFile , '<?php return ' . var_export ( $ dispatchData , true ) . ';' ) ; return $ dispatchData ; }
1154	public function makeReplacements ( $ message , $ attribute , $ rule , $ parameters ) { if ( is_object ( $ rule ) ) { $ rule = get_class ( $ rule ) ; } return $ this -> callValidator ( 'makeReplacements' , [ $ message , $ attribute , $ rule , $ parameters ] ) ; }
4496	private function getGcmJson ( ) : string { return json_encode ( [ 'collapse_key' => $ this -> collapseKey , 'time_to_live' => $ this -> ttl , 'delay_while_idle' => $ this -> delayWhileIdle , 'priority' => $ this -> priority , 'data' => $ this -> getTrimmedJson ( [ $ this , 'getGcmJsonInner' ] , static :: GCM_MAX_LENGTH , 'You message for GCM is too long' ) , ] , JSON_UNESCAPED_UNICODE ) ; }
10590	public static function isTypeOf ( FormInterface $ form , $ typeName ) { $ typeNames = ( array ) $ typeName ; $ type = $ form -> getConfig ( ) -> getType ( ) ; while ( $ type ) { $ actualTypeName = $ type -> getName ( ) ; if ( in_array ( $ actualTypeName , $ typeNames , true ) ) { return true ; } $ type = $ type -> getParent ( ) ; } return false ; }
10642	public function orWhere ( $ column , $ op , $ value , $ isParam = true ) { $ this -> clauses [ ] = array ( "OR" , $ column , $ op , $ value , $ isParam ) ; return $ this ; }
12729	public function optionsMap ( ) : array { $ routes_list = $ this -> router -> getRoutes ( ) ; $ final_routes = $ modified_routes = [ ] ; foreach ( $ routes_list as $ route ) { if ( isset ( $ modified_routes [ $ route [ 1 ] ] ) === false ) { $ modified_routes [ $ route [ 1 ] ] = [ ] ; } $ modified_routes [ $ route [ 1 ] ] [ ] = $ route [ 0 ] ; } foreach ( $ modified_routes as $ route => $ method ) { $ final_routes [ ] = [ 'OPTIONS' , $ route , function ( ) use ( $ method ) { return [ "headers" => [ [ 'X-PHP-Response-Code: 200' , true , 200 ] , [ 'Allow: ' . implode ( ',' , $ method ) ] ] , "response" => '' ] ; } ] ; } return $ final_routes ; }
3540	public static function getSyncOptions ( $ optionName , $ individualSyncOptions = null ) { if ( $ individualSyncOptions != null && is_array ( $ individualSyncOptions ) && array_key_exists ( $ optionName , $ individualSyncOptions ) ) { return $ individualSyncOptions [ $ optionName ] ; } else if ( isset ( Yii :: $ app -> params [ 'LDAP-User-Sync-Options' ] ) && is_array ( Yii :: $ app -> params [ 'LDAP-User-Sync-Options' ] ) && array_key_exists ( $ optionName , Yii :: $ app -> params [ 'LDAP-User-Sync-Options' ] ) ) { return Yii :: $ app -> params [ 'LDAP-User-Sync-Options' ] [ $ optionName ] ; } else if ( array_key_exists ( $ optionName , static :: SYNC_OPTIONS_TEMPLATE_WITHOUT_BACKEND_TASK ) ) { return static :: SYNC_OPTIONS_TEMPLATE_WITHOUT_BACKEND_TASK [ $ optionName ] ; } else { throw new \ yii \ base \ Exception ( 'Sync-option ' . $ optionName . ' not found. Please define settings in the config/params.php of the yii2 framework as described on top of the UserDbLdap.php' ) ; } }
7163	private function buildSaleItemsLinesViews ( Model \ SaleInterface $ sale ) { if ( ! $ sale -> hasItems ( ) ) { return ; } foreach ( $ sale -> getItems ( ) as $ item ) { $ this -> view -> addItem ( $ this -> buildSaleItemLineView ( $ item ) ) ; } }
1847	protected function parseArticles ( $ objArticles , $ blnAddArchive = false ) { $ limit = $ objArticles -> count ( ) ; if ( $ limit < 1 ) { return array ( ) ; } $ count = 0 ; $ arrArticles = array ( ) ; while ( $ objArticles -> next ( ) ) { $ objArticle = $ objArticles -> current ( ) ; $ arrArticles [ ] = $ this -> parseArticle ( $ objArticle , $ blnAddArchive , ( ( ++ $ count == 1 ) ? ' first' : '' ) . ( ( $ count == $ limit ) ? ' last' : '' ) . ( ( ( $ count % 2 ) == 0 ) ? ' odd' : ' even' ) , $ count ) ; } return $ arrArticles ; }
3126	protected function isStartPoint ( TimePoint $ point ) { return $ point -> match ( null , TimePoint :: TARGET_ALL , TimePoint :: TYPE_START ) ; }
8599	private function _convertCreateSubscription ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'CreateSubscription' ; if ( $ request -> isSetSellerId ( ) ) { $ parameters [ 'SellerId' ] = $ request -> getSellerId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } if ( $ request -> isSetMarketplaceId ( ) ) { $ parameters [ 'MarketplaceId' ] = $ request -> getMarketplaceId ( ) ; } if ( $ request -> isSetSubscription ( ) ) { $ SubscriptionCreateSubscriptionInput = $ request -> getSubscription ( ) ; foreach ( $ SubscriptionCreateSubscriptionInput -> getNotificationType ( ) as $ NotificationTypeSubscriptionIndex => $ NotificationTypeSubscription ) { $ parameters [ 'Subscription' . '.' . 'NotificationType' . '.' . ( $ NotificationTypeSubscriptionIndex + 1 ) ] = $ NotificationTypeSubscription ; } } return $ parameters ; }
7776	protected function getRuleArgs ( $ rule ) { if ( ! $ this -> ruleHasArgs ( $ rule ) ) { return [ ] ; } list ( $ ruleName , $ argsWithBracketAtTheEnd ) = explode ( '(' , $ rule ) ; $ args = rtrim ( $ argsWithBracketAtTheEnd , ')' ) ; $ args = preg_replace ( '/\s+/' , '' , $ args ) ; $ args = explode ( ',' , $ args ) ; return $ args ; }
7269	public function belongsTo ( $ refClass , $ forColumn = null ) { $ refTable = $ refClass :: tableName ( ) ; $ forTable = static :: tableName ( ) ; $ refColumn = $ refClass :: $ idColumn ; $ forColumn = $ forColumn ? : strtolower ( $ refClass :: modelName ( ) ) . "_id" ; $ rows = Db :: query ( " select R.* from $refTable as R, $forTable as F where R.$refColumn = F.$forColumn and F.$forColumn = :id " , [ "id" => $ this -> $ forColumn ] , static :: getDbName ( ) ) ; if ( $ rows === false ) return false ; if ( empty ( $ rows ) ) return null ; $ refModel = new $ refClass ; foreach ( $ rows [ 0 ] as $ col => $ val ) $ refModel -> $ col = $ refModel -> decodeValue ( $ val , $ col ) ; return $ refModel ; }
1303	public function get ( string $ path , array $ headers = [ ] , $ cache = true ) : Response { if ( null === $ this -> endpoint ) { return new Response ( [ ] ) ; } $ headers [ ] = 'Package-Session: ' . $ this -> sess ; $ url = $ this -> endpoint . '/' . ltrim ( $ path , '/' ) ; $ cacheKey = $ cache ? ltrim ( $ path , '/' ) : '' ; if ( $ cacheKey && $ contents = $ this -> cache -> read ( $ cacheKey ) ) { $ cachedResponse = Response :: fromJson ( json_decode ( $ contents , true ) ) ; if ( $ lastModified = $ cachedResponse -> getHeader ( 'last-modified' ) ) { $ response = $ this -> fetchFileIfLastModified ( $ url , $ cacheKey , $ lastModified , $ headers ) ; if ( 304 === $ response -> getStatusCode ( ) ) { $ response = new Response ( $ cachedResponse -> getBody ( ) , $ response -> getOrigHeaders ( ) , 304 ) ; } return $ response ; } } return $ this -> fetchFile ( $ url , $ cacheKey , $ headers ) ; }
10023	public static function flattenArray ( $ array ) { if ( ! is_array ( $ array ) ) { return ( array ) $ array ; } $ arrayValues = [ ] ; foreach ( $ array as $ value ) { if ( is_array ( $ value ) ) { foreach ( $ value as $ val ) { if ( is_array ( $ val ) ) { foreach ( $ val as $ v ) { $ arrayValues [ ] = $ v ; } } else { $ arrayValues [ ] = $ val ; } } } else { $ arrayValues [ ] = $ value ; } } return $ arrayValues ; }
3685	protected function optimizedFilter ( $ filterRule , $ children , $ operation ) { $ procedure = new FilterBuilderSql ( $ this -> getMetaModel ( ) -> getTableName ( ) , $ operation , $ this -> connection ) ; $ skipped = $ this -> buildNativeSqlProcedure ( $ procedure , $ children ) ; if ( ! $ procedure -> isEmpty ( ) ) { $ filterRule -> addChild ( $ this -> getMetaModel ( ) -> getEmptyFilter ( ) -> addFilterRule ( $ procedure -> build ( ) ) ) ; } return $ skipped ; }
8684	public static function fromRecursive ( $ iterable ) { $ arr = static :: from ( $ iterable ) ; foreach ( $ arr as $ key => $ value ) { if ( $ value instanceof \ stdClass || \ is_iterable ( $ value ) ) { $ value = static :: fromRecursive ( $ value ) ; } $ arr [ $ key ] = $ value ; } return $ arr ; }
7678	function TbsSheetCheck ( ) { if ( count ( $ this -> OtbsSheetSlidesDelete ) > 0 ) $ this -> RaiseError ( "Unable to delete the following sheets because they are not found in the workbook: " . ( str_replace ( array ( 'i:' , 'n:' ) , '' , implode ( ', ' , $ this -> OtbsSheetSlidesDelete ) ) ) . '.' ) ; if ( count ( $ this -> OtbsSheetSlidesVisible ) > 0 ) $ this -> RaiseError ( "Unable to change visibility of the following sheets because they are not found in the workbook: " . ( str_replace ( array ( 'i:' , 'n:' ) , '' , implode ( ', ' , array_keys ( $ this -> OtbsSheetSlidesVisible ) ) ) ) . '.' ) ; }
6779	protected function configureAcceptedSale ( SaleInterface $ sale ) { if ( null === $ date = $ sale -> getAcceptedAt ( ) ) { return false ; } $ changed = $ this -> updateExchangeRate ( $ sale ) ; $ changed |= $ this -> updateLocale ( $ sale ) ; return $ changed ; }
12965	public function getIcon ( ) { if ( is_null ( $ this -> _icon ) && isset ( $ this -> object ) ) { $ this -> _icon = [ 'class' => $ this -> object -> objectType -> icon , 'title' => $ this -> objectTypeDescriptor ] ; } return $ this -> _icon ; }
7110	protected function getTicketFromEvent ( ResourceEventInterface $ event ) { $ ticket = $ event -> getResource ( ) ; if ( ! $ ticket instanceof TicketInterface ) { throw new UnexpectedValueException ( "Expected instance of " . TicketInterface :: class ) ; } return $ ticket ; }
10397	protected function processDiscriminatorMap ( ClassMetadataInfo $ metadata ) { $ newMap = [ ] ; foreach ( $ metadata -> discriminatorMap as $ mapId => $ mappedEntityName ) { $ newKey = $ this -> doReplacement ( $ mapId ) ; $ newMap [ $ newKey ] = $ mappedEntityName ; } $ metadata -> discriminatorMap = $ newMap ; }
897	private function fixTokensCompare ( Tokens $ tokens , $ startLeft , $ endLeft , $ compareOperatorIndex , $ startRight , $ endRight ) { $ type = $ tokens [ $ compareOperatorIndex ] -> getId ( ) ; $ content = $ tokens [ $ compareOperatorIndex ] -> getContent ( ) ; if ( \ array_key_exists ( $ type , $ this -> candidatesMap ) ) { $ tokens [ $ compareOperatorIndex ] = clone $ this -> candidatesMap [ $ type ] ; } elseif ( \ array_key_exists ( $ content , $ this -> candidatesMap ) ) { $ tokens [ $ compareOperatorIndex ] = clone $ this -> candidatesMap [ $ content ] ; } $ right = $ this -> fixTokensComparePart ( $ tokens , $ startRight , $ endRight ) ; $ left = $ this -> fixTokensComparePart ( $ tokens , $ startLeft , $ endLeft ) ; for ( $ i = $ startRight ; $ i <= $ endRight ; ++ $ i ) { $ tokens -> clearAt ( $ i ) ; } for ( $ i = $ startLeft ; $ i <= $ endLeft ; ++ $ i ) { $ tokens -> clearAt ( $ i ) ; } $ tokens -> insertAt ( $ startRight , $ left ) ; $ tokens -> insertAt ( $ startLeft , $ right ) ; return $ startLeft ; }
9733	public function setARGB ( $ pValue ) { if ( $ pValue == '' ) { $ pValue = self :: COLOR_BLACK ; } if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'argb' => $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> argb = $ pValue ; } return $ this ; }
8105	public function runQuery ( $ sql , $ arguments = false ) { if ( ! $ stmt = $ this -> getStatement ( $ sql , $ arguments ) ) { return false ; } if ( ! $ arguments ) { $ stmt -> execute ( ) ; } $ rows = $ stmt -> rowCount ( ) ; if ( $ rows > 0 ) { $ this -> log -> report ( "$rows row(s) where Affected" ) ; return true ; } else { $ this -> log -> report ( 'No rows were Affected' ) ; return false ; } }
1876	public function create ( ) { if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notCreatable' ] ) { throw new InternalServerErrorException ( 'Table "' . $ this -> strTable . '" is not creatable.' ) ; } $ this -> import ( Files :: class , 'Files' ) ; $ strFolder = Input :: get ( 'pid' , true ) ; if ( $ strFolder == '' || ! file_exists ( $ this -> strRootDir . '/' . $ strFolder ) || ! $ this -> isMounted ( $ strFolder ) ) { throw new AccessDeniedException ( 'Folder "' . $ strFolder . '" is not mounted or is not a directory.' ) ; } $ objSession = System :: getContainer ( ) -> get ( 'session' ) ; $ arrClipboard = $ objSession -> get ( 'CLIPBOARD' ) ; $ arrClipboard [ $ this -> strTable ] = array ( ) ; $ objSession -> set ( 'CLIPBOARD' , $ arrClipboard ) ; $ this -> Files -> mkdir ( $ strFolder . '/__new__' ) ; $ this -> redirect ( html_entity_decode ( $ this -> switchToEdit ( $ strFolder . '/__new__' ) ) ) ; }
2329	public function delete ( ) { if ( $ this -> intIndex < 0 ) { $ this -> first ( ) ; } return $ this -> arrModels [ $ this -> intIndex ] -> delete ( ) ; }
1615	public function readSession ( $ id ) { $ data = $ this -> redis -> executeCommand ( 'GET' , [ $ this -> calculateKey ( $ id ) ] ) ; return $ data === false || $ data === null ? '' : $ data ; }
1526	protected function doUpdate ( StoreInterface $ store , UpdateResource $ request ) { if ( $ response = $ this -> beforeCommit ( $ request ) ) { return $ response ; } $ record = $ store -> updateRecord ( $ request -> getRecord ( ) , $ request -> all ( ) , $ request -> getParameters ( ) ) ; return $ this -> afterCommit ( $ request , $ record , true ) ? : $ record ; }
546	protected function getCreateTableSql ( $ table ) { $ row = $ this -> db -> createCommand ( 'SHOW CREATE TABLE ' . $ this -> quoteTableName ( $ table -> fullName ) ) -> queryOne ( ) ; if ( isset ( $ row [ 'Create Table' ] ) ) { $ sql = $ row [ 'Create Table' ] ; } else { $ row = array_values ( $ row ) ; $ sql = $ row [ 1 ] ; } return $ sql ; }
6274	public function get ( $ key ) { if ( $ this -> find ( strval ( $ key ) ) ) { return $ this -> read ( $ this -> dataPos , $ this -> dataLen ) ; } return false ; }
152	public function batch ( $ batchSize = 100 , $ db = null ) { return Yii :: createObject ( [ 'class' => BatchQueryResult :: className ( ) , 'query' => $ this , 'batchSize' => $ batchSize , 'db' => $ db , 'each' => false , ] ) ; }
6767	protected function handleAddressChange ( SaleInterface $ sale ) { $ changed = false ; if ( $ this -> didDeliveryCountryChanged ( $ sale ) ) { $ changed |= $ this -> saleUpdater -> updateShipmentMethodAndAmount ( $ sale ) ; } if ( $ this -> isDiscountUpdateNeeded ( $ sale ) ) { $ changed |= $ this -> saleUpdater -> updateDiscounts ( $ sale , true ) ; } if ( $ this -> isTaxationUpdateNeeded ( $ sale ) ) { $ changed |= $ this -> saleUpdater -> updateTaxation ( $ sale , true ) ; } elseif ( $ this -> isShipmentTaxationUpdateNeeded ( $ sale ) ) { $ changed |= $ this -> saleUpdater -> updateShipmentTaxation ( $ sale , true ) ; } return $ changed ; }
10961	protected function restoreResponse ( $ response , $ data ) { if ( isset ( $ data [ 'format' ] ) ) { $ response -> format = $ data [ 'format' ] ; } if ( isset ( $ data [ 'version' ] ) ) { $ response -> version = $ data [ 'version' ] ; } if ( isset ( $ data [ 'statusCode' ] ) ) { $ response -> statusCode = $ data [ 'statusCode' ] ; } if ( isset ( $ data [ 'statusText' ] ) ) { $ response -> statusText = $ data [ 'statusText' ] ; } if ( isset ( $ data [ 'headers' ] ) && is_array ( $ data [ 'headers' ] ) ) { $ headers = $ response -> getHeaders ( ) -> toArray ( ) ; $ response -> getHeaders ( ) -> fromArray ( array_merge ( $ data [ 'headers' ] , $ headers ) ) ; } if ( isset ( $ data [ 'cookies' ] ) && is_array ( $ data [ 'cookies' ] ) ) { $ cookies = $ response -> getCookies ( ) -> toArray ( ) ; $ response -> getCookies ( ) -> fromArray ( array_merge ( $ data [ 'cookies' ] , $ cookies ) ) ; } }
454	public function dropPrimaryKey ( $ name , $ table ) { return 'ALTER TABLE ' . $ this -> db -> quoteTableName ( $ table ) . ' DROP CONSTRAINT ' . $ this -> db -> quoteColumnName ( $ name ) ; }
181	public function getConverter ( ) { if ( $ this -> _converter === null ) { $ this -> _converter = Yii :: createObject ( AssetConverter :: className ( ) ) ; } elseif ( is_array ( $ this -> _converter ) || is_string ( $ this -> _converter ) ) { if ( is_array ( $ this -> _converter ) && ! isset ( $ this -> _converter [ 'class' ] ) ) { $ this -> _converter [ 'class' ] = AssetConverter :: className ( ) ; } $ this -> _converter = Yii :: createObject ( $ this -> _converter ) ; } return $ this -> _converter ; }
3812	protected function transformConditions ( $ conditions ) { $ sorted = array ( ) ; $ byPid = array ( ) ; foreach ( $ conditions as $ i => $ condition ) { $ sorted [ $ condition [ 'id' ] ] = $ conditions [ $ i ] ; $ byPid [ $ condition [ 'pid' ] ] [ ] = $ condition [ 'id' ] ; } $ instances = array ( ) ; foreach ( $ sorted as $ id => $ condition ) { $ instances [ $ id ] = $ this -> transformCondition ( $ condition ) ; } foreach ( $ byPid as $ pid => $ ids ) { foreach ( $ ids as $ id ) { $ settingId = $ sorted [ $ id ] [ 'settingId' ] ; if ( ! isset ( $ this -> conditions [ $ settingId ] ) ) { $ this -> conditions [ $ settingId ] = new PropertyConditionChain ( ) ; } $ result = $ this -> conditions [ $ settingId ] ; $ condition = $ instances [ $ id ] ; $ parent = ( $ pid == 0 ) ? $ result : $ instances [ $ pid ] ; if ( $ parent instanceof ConditionChainInterface ) { $ parent -> addCondition ( $ condition ) ; } elseif ( $ parent instanceof NotCondition ) { $ parent -> setCondition ( $ condition ) ; } } } }
12700	public function createServiceWithName ( ServiceLocatorInterface $ serviceLocator , $ name , $ requestedName ) { $ config = $ serviceLocator -> get ( 'config' ) ; if ( isset ( $ config [ 'rznviewcomponent' ] [ 'cache_adapter' ] ) ) { $ config = $ config [ 'rznviewcomponent' ] [ 'cache_adapter' ] ; } else $ config = array ( 'name' => 'filesystem' , 'options' => array ( 'ttl' => 3600 , 'dirLevel' => 2 , 'file_locking' => false , 'cacheDir' => 'data/cache' , 'dirPermission' => 0755 , 'filePermission' => 0666 , ) , ) ; return \ Zend \ Cache \ StorageFactory :: factory ( array ( 'adapter' => $ config , 'plugins' => array ( 'serializer' ) , ) ) ; }
1534	protected function methodForRelation ( $ field ) { if ( method_exists ( $ this , $ field ) ) { return $ field ; } $ method = Str :: camelize ( $ field ) ; return method_exists ( $ this , $ method ) ? $ method : null ; }
2490	protected function processConnectionConfiguration ( ContainerBuilder $ container , array $ config ) { $ alias = $ this -> getAlias ( ) ; if ( isset ( $ config [ 'default_connection' ] ) ) { $ container -> setParameter ( "{$alias}.default_connection" , $ config [ 'default_connection' ] ) ; } elseif ( ! empty ( $ config [ 'connections' ] ) ) { reset ( $ config [ 'connections' ] ) ; $ container -> setParameter ( "{$alias}.default_connection" , key ( $ config [ 'connections' ] ) ) ; } foreach ( $ config [ 'connections' ] as $ name => $ params ) { $ this -> configureSearchServices ( $ container , $ name , $ params ) ; $ this -> configureBoostMap ( $ container , $ name , $ params ) ; $ this -> configureIndexingDepth ( $ container , $ name , $ params ) ; $ container -> setParameter ( "$alias.connection.$name" , $ params ) ; } foreach ( $ config [ 'endpoints' ] as $ name => $ params ) { $ this -> defineEndpoint ( $ container , $ name , $ params ) ; } $ searchEngineDef = $ container -> findDefinition ( self :: ENGINE_ID ) ; $ searchEngineDef -> setFactory ( [ new Reference ( 'ezpublish.solr.engine_factory' ) , 'buildEngine' ] ) ; $ boostFactorProviderDef = $ container -> findDefinition ( self :: BOOST_FACTOR_PROVIDER_ID ) ; $ boostFactorProviderDef -> setFactory ( [ new Reference ( 'ezpublish.solr.boost_factor_provider_factory' ) , 'buildService' ] ) ; }
3259	public function placeTransaction ( $ gateway , $ transactionId , $ detail = null , $ token = null ) { return call_user_func ( Config :: get ( 'shop.transaction' ) . '::create' , [ 'order_id' => $ this -> attributes [ 'id' ] , 'gateway' => $ gateway , 'transaction_id' => $ transactionId , 'detail' => $ detail , 'token' => $ token , ] ) ; }
5608	public function after ( $ method ) { $ this -> invoker -> after ( $ method ) ; $ output = ob_get_contents ( ) ; ob_end_clean ( ) ; if ( $ output !== '' ) { $ result = $ this -> listener -> write ( '{status:"info",message:"' . EclipseReporter :: escapeVal ( $ output ) . '"}' ) ; } }
9293	protected function getAssetsUrl ( ) { if ( ! isset ( $ this -> _assetsUrl ) ) { $ path = dirname ( __FILE__ ) . DIRECTORY_SEPARATOR . '..' . DIRECTORY_SEPARATOR . 'assets' ; $ this -> _assetsUrl = Yii :: app ( ) -> assetManager -> publish ( $ path , false , - 1 , $ this -> forceCopyAssets ) ; } return $ this -> _assetsUrl ; }
1365	protected function bootMiddleware ( Router $ router ) { $ router -> aliasMiddleware ( 'json-api' , BootJsonApi :: class ) ; $ router -> aliasMiddleware ( 'json-api.content' , NegotiateContent :: class ) ; $ router -> aliasMiddleware ( 'json-api.auth' , Authorize :: class ) ; }
10760	protected function buildUpdateSet ( ) { $ result = [ ] ; $ data = $ this -> clause_data [ 0 ] ; foreach ( $ data as $ col => $ val ) { $ result [ ] = $ this -> quote ( $ col ) . ' = ' . $ this -> processValue ( $ val ) ; } return $ result ; }
3755	public function sameModels ( $ objModel1 , $ objModel2 ) { if ( ! ( $ objModel1 instanceof Model && $ objModel2 instanceof Model ) ) { throw new \ InvalidArgumentException ( 'Passed models are not valid.' ) ; } $ objNative1 = $ objModel1 -> getItem ( ) ; $ objNative2 = $ objModel2 -> getItem ( ) ; if ( $ objNative1 -> getMetaModel ( ) === $ objNative2 -> getMetaModel ( ) ) { return true ; } foreach ( $ objNative1 -> getMetaModel ( ) -> getAttributes ( ) as $ objAttribute ) { if ( $ objNative1 -> get ( $ objAttribute -> getColName ( ) ) != $ objNative2 -> get ( $ objAttribute -> getColName ( ) ) ) { return false ; } } return true ; }
12764	public function add ( string $ header ) : self { foreach ( $ this -> getAll ( ) as $ tmp ) { if ( $ tmp === $ header ) { throw new Exception ( "The '{$header}' header has already been added." ) ; } } $ this -> headerList [ ] = $ header ; return self :: $ instance ; }
5779	public function getOne ( ) : ? string { $ result = $ this -> execute ( ) ; if ( pg_num_rows ( $ result ) == 1 ) { if ( pg_num_fields ( $ result ) == 1 ) { return pg_fetch_array ( $ result ) [ 0 ] ; } else { throw new \ Exception ( "Too many result fields" ) ; } } else { if ( pg_num_rows ( $ result ) == 0 ) { return null ; } else { throw new \ Exception ( "Multiple results" ) ; } } }
8205	protected function getJobStats ( $ job ) { try { return ( array ) $ this -> getPheanstalk ( ) -> statsJob ( $ job ) ; } catch ( ServerException $ e ) { if ( $ this -> isNotFoundException ( $ e ) ) { return ; } throw $ e ; } }
6325	public function stop ( ) { $ fp = @ fopen ( $ this -> _file , 'w' ) ; fwrite ( $ fp , ob_get_contents ( ) ) ; fclose ( $ fp ) ; ob_end_flush ( ) ; }
1571	public function getProcessId ( ) : ? string { if ( is_null ( $ this -> processId ) ) { return $ this -> parameter ( ResourceRegistrar :: PARAM_PROCESS_ID ) ; } return $ this -> processId ? : null ; }
10055	public function push ( $ type , $ value , $ reference = null ) { $ this -> stack [ $ this -> count ++ ] = [ 'type' => $ type , 'value' => $ value , 'reference' => $ reference , ] ; if ( $ type == 'Function' ) { $ localeFunction = Calculation :: localeFunc ( $ value ) ; if ( $ localeFunction != $ value ) { $ this -> stack [ ( $ this -> count - 1 ) ] [ 'localeValue' ] = $ localeFunction ; } } }
4653	public function getJobsToRemove ( $ projectPath , $ keep = 1 ) { $ currentJobs = $ this -> strategy -> getJobs ( $ projectPath ) ; $ existingJobs = $ this -> getJobs ( $ projectPath ) ; $ uniqList = array ( ) ; $ removes = array ( ) ; $ ordered = array ( ) ; foreach ( $ currentJobs as $ job ) { $ uniqList [ ] = $ job -> getUniq ( ) ; } foreach ( $ existingJobs as $ job ) { if ( ! in_array ( $ job -> getUniq ( ) , $ uniqList ) ) { $ removes [ ] = $ job ; } else { $ ordered [ $ job -> getUniq ( ) ] [ $ job -> getCreated ( ) -> format ( 'U' ) ] = $ job ; } } foreach ( $ ordered as $ jobs ) { ksort ( $ jobs ) ; $ keeped = count ( $ jobs ) ; while ( $ keeped > $ keep ) { $ removes [ ] = array_shift ( $ jobs ) ; $ keeped -- ; } } return $ removes ; }
4074	protected function resolve ( ) { $ factory = $ this -> container -> getFactory ( ) ; $ names = $ factory -> collectNames ( ) ; foreach ( $ names as $ name ) { $ this -> information [ $ name ] = array ( self :: COMBINATION => null , self :: INPUTSCREEN => null , self :: RENDERSETTING => null , self :: MODELID => null , ) ; } $ found = $ this -> getPaletteCombinationRows ( ) ; if ( ! $ found ) { $ found = array ( ) ; } foreach ( array_keys ( $ this -> information ) as $ tableName ) { if ( empty ( $ this -> information [ $ tableName ] [ self :: COMBINATION ] ) || empty ( $ this -> information [ $ tableName ] [ self :: COMBINATION ] [ 'dca_id' ] ) || empty ( $ this -> information [ $ tableName ] [ self :: COMBINATION ] [ 'view_id' ] ) ) { unset ( $ this -> information [ $ tableName ] ) ; } } $ this -> fetchInputScreenDetails ( ) ; }
3810	protected function translateRows ( $ rows ) { $ metaModel = $ this -> getMetaModel ( ) ; $ activeLegend = $ this -> translateLegend ( array ( 'legendtitle' => $ metaModel -> getName ( ) , 'legendhide' => false ) , $ metaModel ) ; $ activeLegendId = null ; $ columnNames = array ( ) ; foreach ( $ rows as $ row ) { if ( $ row [ 'dcatype' ] != 'attribute' ) { continue ; } $ attribute = $ metaModel -> getAttributeById ( $ row [ 'attr_id' ] ) ; if ( $ attribute ) { $ columnNames [ $ row [ 'id' ] ] = $ attribute -> getColName ( ) ; } } $ this -> propertyMap = $ columnNames ; $ this -> propertyMap2 = array_flip ( $ columnNames ) ; foreach ( $ rows as $ row ) { switch ( $ row [ 'dcatype' ] ) { case 'legend' : $ activeLegend = $ this -> translateLegend ( $ row , $ metaModel ) ; $ activeLegendId = $ row [ 'id' ] ; break ; case 'attribute' : $ exists = $ this -> translateProperty ( $ row , $ metaModel , $ activeLegend ) ; if ( $ exists && $ activeLegendId ) { $ this -> applyLegendConditions ( $ row [ 'id' ] , $ activeLegendId ) ; } break ; default : throw new \ RuntimeException ( 'Unknown palette rendering mode ' . $ row [ 'dcatype' ] ) ; } } }
11039	function store_node ( & $ elts , $ ptype , & $ i , & $ line , $ cname , $ cvalue , $ ncontent , $ content , $ code = FALSE ) { $ isabsolute = FALSE ; if ( $ cname { 0 } == '/' && $ cname { 1 } == '/' ) { $ isabsolute = TRUE ; $ cname = substr ( $ cname , 2 ) ; } $ elements = explode ( '/' , $ cname ) ; if ( count ( $ elements ) == 1 && ! $ isabsolute ) { $ elts [ $ ptype . ':' . $ i . ':' . $ cname . ':' . $ cvalue ] = $ this -> parse ( $ code ? _ETS_CODE : $ ptype , $ i , $ line , $ ncontent , $ content ) ; } else { if ( $ isabsolute ) { $ elts [ _ETS_TEMPLATE . ':' . $ i . '.1://' ] = $ this -> node_path_walk ( $ elements , 2 , $ ptype , $ i , $ line , $ cvalue , $ ncontent , $ content , $ code ) ; } else { $ element1 = array_shift ( $ elements ) ; $ masktype = ( $ ptype == _ETS_MIS || $ ptype == _ETS_MISVAL ) ? _ETS_MIS_TEMPLATE : _ETS_TEMPLATE ; $ elts [ $ masktype . ':' . $ i . '.1:' . $ element1 ] = $ this -> node_path_walk ( $ elements , 2 , $ ptype , $ i , $ line , $ cvalue , $ ncontent , $ content , $ code ) ; } } }
10338	function toXML ( ) { $ xml = new SimpleXMLElement ( "<?xml version=\"1.0\"?><property></property>" ) ; $ xml -> addChild ( "key" , $ this -> key ) ; $ xml -> addChild ( "value" , $ this -> value ) ; return $ xml ; }
6670	public function get_movie_rating ( $ votes ) { $ votations = [ ] ; foreach ( $ votes as $ key => $ value ) { for ( $ i = 0 ; $ i < $ value ; $ i ++ ) { $ votations [ ] = $ key ; } } if ( count ( $ votations ) ) { $ rating = array_sum ( $ votations ) / count ( $ votations ) ; return round ( $ rating , 1 ) ; } return 'N/A' ; }
6866	protected function preventForbiddenChange ( InvoiceInterface $ invoice ) { if ( $ this -> persistenceHelper -> isChanged ( $ invoice , 'type' ) ) { list ( $ old , $ new ) = $ this -> persistenceHelper -> getChangeSet ( $ invoice , 'type' ) ; if ( $ old != $ new ) { throw new Exception \ IllegalOperationException ( "Changing the invoice type is not yet supported." ) ; } } }
1055	public static function findBreakingChanges ( Schema $ oldSchema , Schema $ newSchema ) { return array_merge ( self :: findRemovedTypes ( $ oldSchema , $ newSchema ) , self :: findTypesThatChangedKind ( $ oldSchema , $ newSchema ) , self :: findFieldsThatChangedTypeOnObjectOrInterfaceTypes ( $ oldSchema , $ newSchema ) , self :: findFieldsThatChangedTypeOnInputObjectTypes ( $ oldSchema , $ newSchema ) [ 'breakingChanges' ] , self :: findTypesRemovedFromUnions ( $ oldSchema , $ newSchema ) , self :: findValuesRemovedFromEnums ( $ oldSchema , $ newSchema ) , self :: findArgChanges ( $ oldSchema , $ newSchema ) [ 'breakingChanges' ] , self :: findInterfacesRemovedFromObjectTypes ( $ oldSchema , $ newSchema ) , self :: findRemovedDirectives ( $ oldSchema , $ newSchema ) , self :: findRemovedDirectiveArgs ( $ oldSchema , $ newSchema ) , self :: findAddedNonNullDirectiveArgs ( $ oldSchema , $ newSchema ) , self :: findRemovedDirectiveLocations ( $ oldSchema , $ newSchema ) ) ; }
5365	public function paintPass ( $ message ) { parent :: paintPass ( $ message ) ; $ this -> results [ ] = new SimpleResultOfPass ( parent :: getTestList ( ) , $ message ) ; }
7414	public function read ( ) { $ data = '' ; $ fileObj = $ this -> openFile ( ) ; while ( ! $ fileObj -> eof ( ) ) { $ data .= $ fileObj -> fread ( 4096 ) ; } $ fileObj = null ; return $ data ; }
2022	public static function findFirstPublishedRootByHostAndLanguage ( $ strHost , $ varLanguage , array $ arrOptions = array ( ) ) { @ trigger_error ( 'Using PageModel::findFirstPublishedRootByHostAndLanguage() has been deprecated and will no longer work Contao 5.0.' , E_USER_DEPRECATED ) ; $ t = static :: $ strTable ; $ objDatabase = Database :: getInstance ( ) ; if ( \ is_array ( $ varLanguage ) ) { $ arrColumns = array ( "$t.type='root' AND ($t.dns=? OR $t.dns='')" ) ; if ( ! empty ( $ varLanguage ) ) { $ arrColumns [ ] = "($t.language IN('" . implode ( "','" , $ varLanguage ) . "') OR $t.fallback='1')" ; } else { $ arrColumns [ ] = "$t.fallback='1'" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.dns DESC" . ( ! empty ( $ varLanguage ) ? ", " . $ objDatabase -> findInSet ( "$t.language" , array_reverse ( $ varLanguage ) ) . " DESC" : "" ) . ", $t.sorting" ; } if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } return static :: findOneBy ( $ arrColumns , $ strHost , $ arrOptions ) ; } else { $ arrColumns = array ( "$t.type='root' AND ($t.dns=? OR $t.dns='') AND ($t.language=? OR $t.fallback='1')" ) ; $ arrValues = array ( $ strHost , $ varLanguage ) ; if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.dns DESC, $t.fallback" ; } if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } return static :: findOneBy ( $ arrColumns , $ arrValues , $ arrOptions ) ; } }
10789	protected function setSearchFacets ( SessionInterface $ session , $ facets ) { $ session -> set ( $ this -> getSessionPrefix ( ) . '_facets' , \ json_encode ( $ facets ) ) ; }
5013	public function attach ( EventManagerInterface $ events , $ priority = 1 ) : void { $ this -> listeners [ ] = $ events -> attach ( AbstractWorkerEvent :: EVENT_BOOTSTRAP , [ $ this , 'logBootstrap' ] , 1000 ) ; $ this -> listeners [ ] = $ events -> attach ( AbstractWorkerEvent :: EVENT_FINISH , [ $ this , 'logFinish' ] , 1000 ) ; $ this -> listeners [ ] = $ events -> attach ( AbstractWorkerEvent :: EVENT_PROCESS_JOB , [ $ this , 'logJobStart' ] , 1000 ) ; $ this -> listeners [ ] = $ events -> attach ( AbstractWorkerEvent :: EVENT_PROCESS_JOB , [ $ this , 'logJobEnd' ] , - 1000 ) ; $ this -> listeners [ ] = $ events -> attach ( AbstractWorkerEvent :: EVENT_PROCESS_IDLE , [ $ this , 'injectLoggerInEvent' ] , 1000 ) ; $ this -> listeners [ ] = $ events -> attach ( AbstractWorkerEvent :: EVENT_PROCESS_STATE , [ $ this , 'injectLoggerInEvent' ] , 1000 ) ; }
10605	public function addHeaders ( array $ headers ) : void { foreach ( $ headers as $ name => $ value ) { $ this -> addHeader ( ( string ) $ name , $ value ) ; } }
11769	public function getConnectionByRole ( $ role ) { if ( $ role === 'master' ) { return $ this -> getMaster ( ) ; } elseif ( $ role === 'slave' ) { return $ this -> pickSlave ( ) ; } elseif ( $ role === 'sentinel' ) { return $ this -> getSentinelConnection ( ) ; } }
4375	protected function buildGroupMethod ( $ method , $ args = array ( ) , $ meta = array ( ) ) { $ str = '' ; if ( \ in_array ( $ method , array ( 'group' , 'groupCollapsed' ) ) ) { $ label = \ array_shift ( $ args ) ; $ levelClass = isset ( $ meta [ 'level' ] ) ? 'level-' . $ meta [ 'level' ] : null ; if ( ! empty ( $ meta [ 'isMethodName' ] ) ) { $ label = $ this -> markupClassname ( $ label ) ; } foreach ( $ args as $ k => $ v ) { $ args [ $ k ] = $ this -> dump ( $ v ) ; } $ argStr = \ implode ( ', ' , $ args ) ; $ str .= $ this -> debug -> utilities -> buildTag ( 'div' , array ( 'class' => array ( 'group-header' , $ method == 'groupCollapsed' ? 'collapsed' : 'expanded' , $ levelClass , ) , 'data-channel' => $ meta [ 'channel' ] , ) , '<span class="group-label">' . $ label . ( ! empty ( $ argStr ) ? '(</span>' . $ argStr . '<span class="group-label">)' : '' ) . '</span>' ) . "\n" ; $ str .= '<div' . $ this -> debug -> utilities -> buildAttribString ( array ( 'class' => array ( 'm_group' , $ levelClass , ) , ) ) . '>' ; } elseif ( $ method == 'groupEnd' ) { $ str = '</div>' ; } return $ str ; }
3845	protected static function upgradeDcaSettingsPublished ( ) { $ objDB = self :: DB ( ) ; if ( $ objDB -> tableExists ( 'tl_metamodel_dcasetting' , null , true ) && ! $ objDB -> fieldExists ( 'published' , 'tl_metamodel_dcasetting' , true ) ) { TableManipulation :: createColumn ( 'tl_metamodel_dcasetting' , 'published' , 'char(1) NOT NULL default \'\'' ) ; $ objDB -> execute ( 'UPDATE tl_metamodel_dcasetting SET published=1;' ) ; } }
7364	protected function updateInvoiceTotal ( SaleInterface $ sale ) { if ( ! $ sale instanceof InvoiceSubjectInterface ) { return false ; } $ changed = false ; $ invoice = $ this -> invoiceCalculator -> calculateInvoiceTotal ( $ sale ) ; if ( 0 != Money :: compare ( $ invoice , $ sale -> getInvoiceTotal ( ) , $ sale -> getCurrency ( ) -> getCode ( ) ) ) { $ sale -> setInvoiceTotal ( $ invoice ) ; $ changed = true ; } $ credit = $ this -> invoiceCalculator -> calculateCreditTotal ( $ sale ) ; if ( 0 != Money :: compare ( $ credit , $ sale -> getCreditTotal ( ) , $ sale -> getCurrency ( ) -> getCode ( ) ) ) { $ sale -> setCreditTotal ( $ credit ) ; $ changed = true ; } return $ changed ; }
1496	public function prepend ( Encoding ... $ encodings ) : self { $ copy = clone $ this ; array_unshift ( $ copy -> stack , ... $ encodings ) ; return $ copy ; }
9457	public function addCountableAttribute ( $ attribute ) { if ( empty ( $ attribute ) ) { return false ; } if ( in_array ( $ attribute , $ this -> getCountableAttributes ( ) , true ) ) { return false ; } $ this -> addToArrayValue ( 'countableAttributes' , $ attribute ) ; return $ this ; }
1837	public static function findOneBy ( $ strColumn , $ varValue , array $ arrOptions = array ( ) ) { $ arrOptions = array_merge ( array ( 'limit' => 1 , 'column' => $ strColumn , 'value' => $ varValue , 'return' => 'Model' ) , $ arrOptions ) ; return static :: find ( $ arrOptions ) ; }
6284	protected static function buildHttpClient05 ( LoopInterface $ loop , $ connector = null ) { if ( $ connector instanceof DnsResolver ) { @ trigger_error ( sprintf ( 'Passing a %s to buildHttpClient is deprecated since version 2.1.0 and will be removed in 3.0. If you need no specific behaviour, omit the $dns argument, otherwise pass a %s' , DnsResolver :: class , ConnectorInterface :: class ) , E_USER_DEPRECATED ) ; $ connector = static :: buildConnector ( $ loop , $ connector ) ; } if ( null !== $ connector && ! $ connector instanceof ConnectorInterface ) { throw new \ InvalidArgumentException ( '$connector must be an instance of DnsResolver or ConnectorInterface' ) ; } return new HttpClient ( $ loop , $ connector ) ; }
11346	public function renderFields ( ) { $ html = '' ; foreach ( $ this -> fields as $ field ) { $ html .= $ this -> formatter -> renderField ( $ field ) ; } return $ html ; }
2648	public function uploadVcl ( $ version , $ vcl ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/vcl' ; $ result = $ this -> _fetch ( $ url , 'POST' , $ vcl ) ; return $ result ; }
1699	public function getFile ( $ strName ) { foreach ( $ this -> arrFiles as $ k => $ v ) { if ( $ strName == $ v [ 'file_name' ] ) { $ this -> intIndex = $ k ; return true ; } } return false ; }
6782	public function setFormParameters ( $ optionNames ) { foreach ( ( array ) $ optionNames as $ option ) { $ this -> formParameters [ $ option ] = true ; } return $ this ; }
6584	public function sum ( $ n , $ m = 0 ) { if ( $ m > 0 ) return $ this -> sum ( $ n + $ m ) - $ this -> sum ( $ m ) ; static :: ensureValid ( $ n ) ; return $ this -> b * ( 1 - pow ( $ this -> q , $ n ) ) / ( 1 - $ this -> q ) ; }
11968	public static function GetAuthClass ( ) { if ( self :: $ authClass === NULL ) { if ( class_exists ( self :: AUTH_CLASS_FULL ) ) { self :: $ authClass = self :: AUTH_CLASS_FULL ; } else { self :: $ authClass = self :: AUTH_CLASS_BASIC ; } } return self :: $ authClass ; }
11468	public function index ( ResponseRequest $ request ) { $ view = $ this -> response -> theme -> listView ( ) ; if ( $ this -> response -> typeIs ( 'json' ) ) { $ function = camel_case ( 'get-' . $ view ) ; return $ this -> repository -> setPresenter ( \ Litecms \ Forum \ Repositories \ Presenter \ ResponsePresenter :: class ) -> $ function ( ) ; } $ responses = $ this -> repository -> paginate ( ) ; return $ this -> response -> title ( trans ( 'forum::response.names' ) ) -> view ( 'forum::response.index' , true ) -> data ( compact ( 'responses' ) ) -> output ( ) ; }
4906	public function indexAction ( ) { $ view = $ this -> params ( 'view' ) ; $ view = 'content/' . $ view ; $ viewModel = new ViewModel ( ) ; $ viewModel -> setTemplate ( $ view ) ; $ request = $ this -> getRequest ( ) ; if ( $ request -> isXmlHttpRequest ( ) ) { $ viewModel -> setTerminal ( true ) ; } return $ viewModel ; }
4497	private function getAndroidJsonInner ( ? string $ text ) : array { $ data = [ ] ; if ( null !== $ text ) { $ data [ 'message' ] = $ text ; } if ( null !== $ this -> localizedKey ) { $ data [ 'message-loc-key' ] = $ this -> localizedKey ; if ( $ this -> localizedArguments ) { $ data [ 'message-loc-args' ] = $ this -> localizedArguments ; } } return $ data ; }
338	protected function extractColumnSize ( $ column , $ dbType , $ precision , $ scale , $ length ) { $ column -> size = trim ( $ length ) === '' ? null : ( int ) $ length ; $ column -> precision = trim ( $ precision ) === '' ? null : ( int ) $ precision ; $ column -> scale = trim ( $ scale ) === '' ? null : ( int ) $ scale ; }
12833	private function generateConfigCreatorMethod ( ConfigService $ config ) { $ configClass = Util :: normalizeFqcn ( $ config -> getClass ( ) ) ; $ configData = var_export ( $ config -> getData ( ) , true ) ; return <<<PHP public function getAppConfig() : {$configClass} { if (isset(\$this->singletons['{$config->getId()}}'])) { return \$this->singletons['{$config->getId()}']; } \$data = {$configData}; return \$this->singletons['{$config->getId()}'] = new {$configClass}(\$data); }PHP ; }
1117	public static function roots ( ) { $ instance = new static ; return $ instance -> newQuery ( ) -> whereNull ( $ instance -> getParentColumnName ( ) ) -> orderBy ( $ instance -> getQualifiedOrderColumnName ( ) ) ; }
12429	public function getAuthorizerList ( $ offset = 0 , $ count = 500 ) { $ params = [ 'component_appid' => $ this -> getAppId ( ) , 'offset' => $ offset , 'count' => $ count , ] ; return $ this -> parseJSON ( 'json' , [ self :: GET_AUTHORIZER_LIST , $ params ] ) ; }
12288	public function loop ( array $ collection , string $ block , string $ emptyBlock = null ) : string { if ( empty ( $ collection ) ) { return isset ( $ emptyBlock ) ? trim ( $ this -> make ( $ emptyBlock ) ) . PHP_EOL : PHP_EOL ; } else { $ items = '' ; foreach ( $ collection as $ key => $ item ) { $ items .= rtrim ( $ this -> make ( $ block , [ 'key' => $ key , 'item' => $ item ] ) ) ; } return ltrim ( $ items ) . PHP_EOL ; } }
6588	public function get ( $ url , $ method = "GET" ) { return $ this -> request ( [ CURLOPT_HTTPGET => true , CURLOPT_CUSTOMREQUEST => $ method ? : "GET" , CURLOPT_URL => "$url" , ] ) ; }
11719	public function saveAction ( Request $ request , Application $ app ) { $ options = array ( "request" => $ request , "configuration_handler" => $ app [ "red_kite_cms.configuration_handler" ] , 'security' => $ app [ "security" ] , "queue_manager" => $ app [ "red_kite_cms.queue_manager" ] , ) ; $ response = parent :: save ( $ options ) ; if ( $ app [ "red_kite_cms.queue_manager" ] -> hasQueue ( ) && $ response -> getContent ( ) == "Queue saved" ) { $ lastRoute = $ request -> getSession ( ) -> get ( 'last_uri' ) ; return $ app -> redirect ( $ lastRoute ) ; } return $ response ; }
7503	public function tf ( string $ key , array $ args = null , array $ replacements = null , string ... $ namespaces ) { $ this -> view -> out ( $ this -> getTf ( $ key , $ args , $ replacements , ... $ namespaces ) ) ; }
6766	public function onAddressChange ( ResourceEventInterface $ event ) { $ sale = $ this -> getSaleFromEvent ( $ event ) ; if ( $ this -> persistenceHelper -> isScheduledForRemove ( $ sale ) ) { $ event -> stopPropagation ( ) ; return ; } if ( $ this -> handleAddressChange ( $ sale ) ) { $ this -> persistenceHelper -> persistAndRecompute ( $ sale , false ) ; $ this -> scheduleContentChangeEvent ( $ sale ) ; } }
8651	private function convertGetReport ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetReport' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetReportId ( ) ) { $ parameters [ 'ReportId' ] = $ request -> getReportId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
61	public function isDirEmpty ( $ dir ) { $ finder = Finder :: create ( ) -> ignoreVCS ( false ) -> ignoreDotFiles ( false ) -> depth ( 0 ) -> in ( $ dir ) ; return count ( $ finder ) === 0 ; }
5266	public static function merge ( Model $ model1 , Model $ model2 , array $ attributes ) { foreach ( $ attributes as $ attribute ) { $ model1 -> $ attribute = $ model2 -> $ attribute ; } return $ model1 ; }
1692	protected function shortenHexColor ( $ color ) { if ( $ color [ 0 ] == $ color [ 1 ] && $ color [ 2 ] == $ color [ 3 ] && $ color [ 4 ] == $ color [ 5 ] ) { return $ color [ 0 ] . $ color [ 2 ] . $ color [ 4 ] ; } return $ color ; }
11180	protected function set ( $ key , $ value ) { $ cache = apc_fetch ( $ this -> getKey ( ) ) ; $ cache [ $ key ] = $ value ; apc_store ( $ this -> getKey ( ) , $ cache ) ; }
10046	function isEmpty ( ) { $ result = ! isset ( $ this -> id ) && ! isset ( $ this -> external_id ) && ! isset ( $ this -> email ) ; return $ result ; }
11745	public function getShakeInfo ( $ ticket , $ needPoi = null ) { $ params = [ 'ticket' => $ ticket , ] ; if ( $ needPoi !== null ) { $ params [ 'need_poi' ] = intval ( $ needPoi ) ; } return $ this -> parseJSON ( 'json' , [ self :: API_GET_SHAKE_INFO , $ params ] ) ; }
3665	private function convertParameterAggregate ( $ var , $ arguments ) { $ var = ( array ) $ var ; if ( ! empty ( $ arguments [ 'recursive' ] ) ) { $ var = iterator_to_array ( new \ RecursiveIteratorIterator ( new \ RecursiveArrayIterator ( $ var ) ) ) ; } if ( ! $ var ) { return 'NULL' ; } if ( ! empty ( $ arguments [ 'key' ] ) ) { $ var = array_keys ( $ var ) ; } else { $ var = array_values ( $ var ) ; } if ( $ arguments [ 'aggregate' ] == 'set' ) { $ this -> addParameter ( implode ( ',' , $ var ) ) ; return '?' ; } $ this -> addParameters ( $ var ) ; return rtrim ( str_repeat ( '?,' , count ( $ var ) ) , ',' ) ; }
2618	public function getSiteLocation ( ) { $ countryId = $ this -> scopeConfig -> getValue ( 'general/store_information/country_id' ) ; if ( $ countryId ) { $ country = $ this -> countryFactory -> create ( ) -> loadByCode ( $ countryId ) ; $ countryName = $ country -> getName ( ) ; } else { $ countryName = 'Unknown country' ; } $ regionId = $ this -> scopeConfig -> getValue ( 'general/store_information/region_id' ) ; $ regionName = 'Unknown region' ; if ( $ regionId ) { $ region = $ this -> regionFactory -> create ( ) ; $ region = $ region -> load ( $ regionId ) ; if ( $ region -> getId ( ) ) { $ regionName = $ region -> getName ( ) ; } } $ postCode = $ this -> scopeConfig -> getValue ( 'general/store_information/postcode' ) ; if ( ! $ postCode ) { $ postCode = 'Unknown zip code' ; } return $ countryName . ' | ' . $ regionName . ' | ' . $ postCode ; }
6117	public function serverGetByUid ( $ uid ) { foreach ( $ this -> serverList ( ) as $ server ) { if ( $ server [ "virtualserver_unique_identifier" ] == $ uid ) { return $ server ; } } throw new Ts3Exception ( "invalid serverID" , 0x400 ) ; }
1004	public function parseRequestParams ( $ method , array $ bodyParams , array $ queryParams ) { if ( $ method === 'GET' ) { $ result = OperationParams :: create ( $ queryParams , true ) ; } elseif ( $ method === 'POST' ) { if ( isset ( $ bodyParams [ 0 ] ) ) { $ result = [ ] ; foreach ( $ bodyParams as $ index => $ entry ) { $ op = OperationParams :: create ( $ entry ) ; $ result [ ] = $ op ; } } else { $ result = OperationParams :: create ( $ bodyParams ) ; } } else { throw new RequestError ( 'HTTP Method "' . $ method . '" is not supported' ) ; } return $ result ; }
5576	public function clickSubmitById ( $ id , $ additional = false ) { if ( ! ( $ form = $ this -> page -> getFormBySubmit ( new SelectById ( $ id ) ) ) ) { return false ; } $ success = $ this -> load ( $ form -> getAction ( ) , $ form -> submitButton ( new SelectById ( $ id ) , $ additional ) ) ; return ( $ success ? $ this -> getContent ( ) : $ success ) ; }
12744	public function askSlotMap ( NodeConnectionInterface $ connection = null ) { if ( ! $ connection && ! $ connection = $ this -> getRandomConnection ( ) ) { return ; } $ this -> slotmap -> reset ( ) ; $ response = $ this -> queryClusterNodeForSlotMap ( $ connection ) ; foreach ( $ response as $ slots ) { list ( $ start , $ end , $ master ) = $ slots ; if ( $ master [ 0 ] === '' ) { $ this -> slotmap -> setSlots ( $ start , $ end , ( string ) $ connection ) ; } else { $ this -> slotmap -> setSlots ( $ start , $ end , "{$master[0]}:{$master[1]}" ) ; } } }
6605	public function validateRequestTokenResponse ( $ params ) { if ( ! isset ( $ params [ 'oauth_token' ] ) || ! isset ( $ params [ 'oauth_token_secret' ] ) || empty ( $ params [ 'oauth_token' ] ) || empty ( $ params [ 'oauth_token_secret' ] ) ) { throw new InvalidOAuthTokenException ( 'request token' ) ; } return true ; }
8665	private function convertGetReportRequestCount ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetReportRequestCount' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetReportTypeList ( ) ) { $ reportTypeList = $ request -> getReportTypeList ( ) ; foreach ( $ reportTypeList -> getType ( ) as $ typeIndex => $ type ) { $ parameters [ 'ReportTypeList' . '.' . 'Type' . '.' . ( $ typeIndex + 1 ) ] = $ type ; } } if ( $ request -> isSetReportProcessingStatusList ( ) ) { $ reportProcessingStatusList = $ request -> getReportProcessingStatusList ( ) ; foreach ( $ reportProcessingStatusList -> getStatus ( ) as $ statusIndex => $ status ) { $ parameters [ 'ReportProcessingStatusList' . '.' . 'Status' . '.' . ( $ statusIndex + 1 ) ] = $ status ; } } if ( $ request -> isSetRequestedFromDate ( ) ) { $ parameters [ 'RequestedFromDate' ] = $ this -> getFormattedTimestamp ( $ request -> getRequestedFromDate ( ) ) ; } if ( $ request -> isSetRequestedToDate ( ) ) { $ parameters [ 'RequestedToDate' ] = $ this -> getFormattedTimestamp ( $ request -> getRequestedToDate ( ) ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
1704	public function purgeOldFeeds ( ) { $ arrFeeds = array ( ) ; $ objFeeds = NewsFeedModel :: findAll ( ) ; if ( $ objFeeds !== null ) { while ( $ objFeeds -> next ( ) ) { $ arrFeeds [ ] = $ objFeeds -> alias ? : 'news' . $ objFeeds -> id ; } } return $ arrFeeds ; }
11536	public static function cast ( $ time ) { return $ time instanceof self ? $ time : new self ( $ time -> format ( self :: ISO8601 ) , $ time -> getTimezone ( ) ) ; }
6391	public function readScormScoesTrack ( $ userid , $ scormid , $ scoid , $ attempt ) { $ trackingValues = [ ] ; $ scormTracking = $ this -> readStoreRecords ( 'scorm_scoes_track' , [ 'userid' => $ userid , 'scormid' => $ scormid , 'scoid' => $ scoid , 'attempt' => $ attempt ] ) ; foreach ( $ scormTracking as $ st ) { if ( $ st -> element == 'cmi.core.score.min' ) { $ trackingValues [ 'scoremin' ] = $ st -> value ; } else if ( $ st -> element == 'cmi.core.score.max' ) { $ trackingValues [ 'scoremax' ] = $ st -> value ; } else if ( $ st -> element == 'cmi.core.lesson_status' ) { $ trackingValues [ 'status' ] = $ st -> value ; } } return $ trackingValues ; }
2729	public function beforeToHtml ( Image $ subject ) { if ( $ this -> config -> isImageOptimizationPixelRatioEnabled ( ) !== true ) { return ; } $ srcSet = [ ] ; $ imageUrl = $ subject -> getData ( 'image_url' ) ; $ pixelRatios = $ this -> config -> getImageOptimizationRatios ( ) ; $ pixelRatiosArray = explode ( ',' , $ pixelRatios ) ; $ glue = ( strpos ( $ imageUrl , '?' ) !== false ) ? '&' : '?' ; foreach ( $ pixelRatiosArray as $ pr ) { $ ratio = 'dpr=' . $ pr . ' ' . $ pr . 'x' ; $ srcSet [ ] = $ imageUrl . $ glue . $ ratio ; } $ subject -> setData ( 'custom_attributes' , 'srcset="' . implode ( ',' , $ srcSet ) . '"' ) ; }
1687	public function loginAction ( ) : Response { $ this -> get ( 'contao.framework' ) -> initialize ( ) ; if ( ! isset ( $ GLOBALS [ 'TL_PTY' ] [ 'error_401' ] ) || ! class_exists ( $ GLOBALS [ 'TL_PTY' ] [ 'error_401' ] ) ) { throw new UnauthorizedHttpException ( '' , 'Not authorized' ) ; } $ pageHandler = new $ GLOBALS [ 'TL_PTY' ] [ 'error_401' ] ( ) ; try { return $ pageHandler -> getResponse ( ) ; } catch ( ResponseException $ e ) { return $ e -> getResponse ( ) ; } catch ( InsufficientAuthenticationException $ e ) { throw new UnauthorizedHttpException ( '' , $ e -> getMessage ( ) ) ; } }
4045	public function decodeValue ( DecodePropertyValueForWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) || ( $ event -> getProperty ( ) !== 'jumpTo' ) ) { return ; } $ propInfo = $ event -> getEnvironment ( ) -> getDataDefinition ( ) -> getPropertiesDefinition ( ) -> getProperty ( 'jumpTo' ) ; $ value = StringUtil :: deserialize ( $ event -> getValue ( ) , true ) ; $ extra = $ propInfo -> getExtra ( ) ; $ newValues = [ ] ; $ languages = $ extra [ 'columnFields' ] [ 'langcode' ] [ 'options' ] ; foreach ( array_keys ( $ languages ) as $ key ) { $ newValue = '' ; $ filter = 0 ; if ( $ value ) { foreach ( $ value as $ arr ) { if ( ! is_array ( $ arr ) ) { break ; } if ( array_search ( $ key , $ arr ) !== false ) { $ newValue = '{{link_url::' . $ arr [ 'value' ] . '}}' ; $ filter = $ arr [ 'filter' ] ; break ; } } } $ newValues [ ] = [ 'langcode' => $ key , 'value' => $ newValue , 'filter' => $ filter ] ; } $ event -> setValue ( $ newValues ) ; }
4625	public function prepare ( Command $ command , Node $ node ) { if ( $ this -> connection ) { $ this -> resetConnection ( ) ; } parent :: prepare ( $ command , $ node ) ; $ this -> buildPath ( ) ; $ this -> prepareConnection ( ) ; $ this -> prepareRequest ( ) ; return $ this ; }
1129	public function getLeftSibling ( ) { return $ this -> siblings ( ) -> where ( $ this -> getLeftColumnName ( ) , '<' , $ this -> getLeft ( ) ) -> orderBy ( $ this -> getOrderColumnName ( ) , 'desc' ) -> get ( ) -> last ( ) ; }
12487	public static function enableLogging ( $ writePath ) { if ( is_file ( $ writePath ) ) { self :: $ enabled = true ; self :: $ logFilePath = $ writePath ; return true ; } throw new \ Exception ( 'Impossible d\'activer les logs dans le fichier ' . $ writePath . ' : celui ci n\'existe pas.' ) ; return false ; }
8706	public function setLastFolderID ( $ folderID ) { $ request = Controller :: curr ( ) -> getRequest ( ) ; $ session = $ request -> getSession ( ) ; $ session -> set ( get_class ( ) . '.FolderID' , $ folderID ) ; }
430	public function getBasePath ( ) { if ( $ this -> _basePath === null ) { $ class = new \ ReflectionClass ( $ this ) ; $ this -> _basePath = dirname ( $ class -> getFileName ( ) ) ; } return $ this -> _basePath ; }
5812	public function onBeforeWrite ( ) { parent :: onBeforeWrite ( ) ; $ types = array ( ) ; foreach ( singleton ( 'FusionService' ) -> getFusionTagTypes ( ) as $ type => $ field ) { $ types [ $ type ] = $ type ; } $ types = array_intersect ( $ this -> owner -> many_many ( ) , $ types ) ; if ( empty ( $ types ) ) { $ tagging = array ( ) ; foreach ( $ this -> owner -> FusionTags ( ) as $ tag ) { $ tagging [ ] = $ tag -> Title ; } } else { $ this -> owner -> FusionTags ( ) -> removeAll ( ) ; $ tagging = array ( ) ; foreach ( $ types as $ relationship => $ type ) { foreach ( $ this -> owner -> $ relationship ( ) as $ tag ) { $ fusion = FusionTag :: get ( ) -> byID ( $ tag -> FusionTagID ) ; $ this -> owner -> FusionTags ( ) -> add ( $ fusion ) ; $ tagging [ ] = $ fusion -> Title ; } } } $ this -> owner -> Tagging = implode ( ' ' , $ tagging ) ; }
10289	protected function executeTasks ( array $ tasks ) { foreach ( $ tasks as $ scheduled => $ taskList ) { foreach ( $ taskList as $ cronjob ) { if ( ( $ task = $ this -> taskFactory -> factory ( $ cronjob -> task , $ scheduled , $ this -> logger ) ) !== false ) { $ this -> logger -> setTask ( $ task -> getId ( ) ) ; $ this -> logger -> log ( 'Start task execution.' ) ; $ status = $ task -> execute ( ) ; switch ( $ status ) { case Executor :: SUCCESS : $ this -> logger -> log ( 'Finished task execution.' ) ; break ; case Executor :: ERROR : $ this -> logger -> log ( 'Error occured during task execution.' , Logger :: WARNING ) ; break ; case Executor :: RESCHEDULE : $ this -> logger -> log ( 'Task will be rescheduled for ' . $ task -> reScheduleTime . ' seconds.' ) ; $ this -> rescheduled [ $ scheduled + $ task -> reScheduleTime ] = $ cronjob ; break ; default : $ this -> logger -> log ( 'Invalid status returned by task.' , Logger :: ERROR ) ; break ; } $ this -> logger -> setTask ( ) ; } } } }
1565	public function getResource ( ) { if ( ! $ this -> resource_type || ! $ this -> resource_id ) { return null ; } return $ this -> getApi ( ) -> getStore ( ) -> find ( ResourceIdentifier :: create ( $ this -> resource_type , ( string ) $ this -> resource_id ) ) ; }
10808	public static function isRender ( $ request ) { return true ; $ accept = $ request -> header ( 'accept' ) ?? '' ; if ( static :: isHas ( $ accept , 'json' ) || static :: isHas ( $ accept , 'api' ) ) { return true ; } else if ( static :: isHas ( $ accept , 'html' ) || static :: isHas ( $ accept , 'xml' ) || static :: isHas ( $ accept , 'text' ) ) { return false ; } else if ( $ request -> header ( 'x-ddv-restful-api' ) ) { return true ; } else if ( $ request -> header ( 'authorization' ) ) { foreach ( $ request -> headers -> keys ( ) as $ value ) { if ( static :: isHas ( $ accept , 'x-ddv-' ) ) { return true ; } } } return false ; }
5481	public function getValue ( SelectorInterface $ selector ) { for ( $ i = 0 , $ count = count ( $ this -> widgets ) ; $ i < $ count ; $ i ++ ) { if ( $ selector -> isMatch ( $ this -> widgets [ $ i ] ) ) { return $ this -> widgets [ $ i ] -> getValue ( ) ; } } foreach ( $ this -> buttons as $ button ) { if ( $ selector -> isMatch ( $ button ) ) { return $ button -> getValue ( ) ; } } return ; }
784	protected function validateCache ( $ lastModified , $ etag ) { if ( Yii :: $ app -> request -> headers -> has ( 'If-None-Match' ) ) { return $ etag !== null && in_array ( $ etag , Yii :: $ app -> request -> getETags ( ) , true ) ; } elseif ( Yii :: $ app -> request -> headers -> has ( 'If-Modified-Since' ) ) { return $ lastModified !== null && @ strtotime ( Yii :: $ app -> request -> headers -> get ( 'If-Modified-Since' ) ) >= $ lastModified ; } return false ; }
9402	public function build ( $ options ) { $ command = $ this -> path ; if ( isset ( $ options [ 'title' ] ) ) { $ command .= " -t {$options['title']}" ; } if ( isset ( $ options [ 'message' ] ) ) { $ command .= " -m {$options['message']}" ; } if ( isset ( $ options [ 'image' ] ) ) { $ pathInfo = pathinfo ( $ options [ 'image' ] ) ; if ( isset ( $ pathInfo [ 'extension' ] ) ) { $ command .= " --image {$options['image']}" ; } else { $ command .= " -a {$options['image']}" ; } } if ( isset ( $ options [ 'url' ] ) ) { $ command .= " --url {$options['url']}" ; } if ( isset ( $ options [ 'sticky' ] ) && $ options [ 'sticky' ] === true ) { $ command .= ' -s' ; } return $ command ; }
2690	public function getResizedImageInfo ( ) { if ( $ this -> isFastlyImageOptimizationEnabled ( ) == false ) { return parent :: getResizedImageInfo ( ) ; } if ( $ this -> getBaseFile ( ) !== null ) { return [ 0 => $ this -> getWidth ( ) , 1 => $ this -> getHeight ( ) ] ; } $ asset = $ this -> _assetRepo -> createAsset ( "Magento_Catalog::images/product/placeholder/{$this->getDestinationSubdir()}.jpg" ) ; $ img = $ asset -> getSourceFile ( ) ; $ imageInfo = getimagesize ( $ img ) ; $ this -> setWidth ( $ imageInfo [ 0 ] ) ; $ this -> setHeight ( $ imageInfo [ 1 ] ) ; return $ imageInfo ; }
12385	public function permalinksByLanguage ( $ language = null ) { $ result = array ( ) ; if ( null === $ language ) { $ language = $ this -> currentLanguage ; } foreach ( $ this -> pages as $ page ) { foreach ( $ page [ "seo" ] as $ pageAttribute ) { if ( $ pageAttribute [ "language" ] != $ language ) { continue ; } $ result [ ] = $ pageAttribute [ "permalink" ] ; } } return $ result ; }
6414	public static function limit ( IteratorAggregate $ iterable , int $ limitSize ) : IteratorAggregate { return new CallableIterable ( function ( ) use ( $ iterable , $ limitSize ) { return Iterators :: limit ( Iterators :: from ( $ iterable -> getIterator ( ) ) , $ limitSize ) ; } ) ; }
7494	public function trimRight ( $ characters = null ) { $ this -> string = rtrim ( $ this -> string , $ characters ) ; return $ this ; }
821	private function splitUpDocBlock ( $ lines , Tokens $ tokens , $ docBlockIndex ) { $ lineContent = $ this -> getSingleLineDocBlockEntry ( $ lines ) ; $ lineEnd = $ this -> whitespacesConfig -> getLineEnding ( ) ; $ originalIndent = $ this -> detectIndent ( $ tokens , $ tokens -> getNextNonWhitespace ( $ docBlockIndex ) ) ; return [ new Line ( '/**' . $ lineEnd ) , new Line ( $ originalIndent . ' * ' . $ lineContent . $ lineEnd ) , new Line ( $ originalIndent . ' */' ) , ] ; }
7267	public function has ( $ forClass , $ forColumn = null ) { $ refTable = static :: tableName ( ) ; $ forTable = $ forClass :: tableName ( ) ; $ refColumn = static :: $ idColumn ; $ forColumn = $ forColumn ? : strtolower ( static :: modelName ( ) ) . "_id" ; $ rows = Db :: query ( " select F.* from $refTable as R, $forTable as F where R.$refColumn = F.$forColumn and R.$refColumn = :id " , [ "id" => $ this -> $ refColumn ] , static :: getDbName ( ) ) ; if ( $ rows === false ) return false ; if ( empty ( $ rows ) ) return null ; $ forModel = new $ forClass ; foreach ( $ rows [ 0 ] as $ col => $ val ) $ forModel -> $ col = $ forModel -> decodeValue ( $ val , $ col ) ; return $ forModel ; }
4001	protected function getMetaModelDataFrom ( $ strTable , $ intID ) { if ( ! $ this -> connection -> getSchemaManager ( ) -> tablesExist ( [ $ strTable ] ) ) { return null ; } $ statement = $ this -> connection -> prepare ( 'SELECT metamodel, metamodel_filtering FROM ' . $ strTable . ' WHERE id=? LIMIT 0,1' ) ; $ statement -> bindValue ( 1 , $ intID ) ; $ statement -> execute ( ) ; if ( $ statement -> rowCount ( ) < 1 ) { return null ; } return $ statement -> fetch ( \ PDO :: FETCH_OBJ ) ; }
3070	protected function saveItemState ( ) { if ( $ this -> getRequestParameter ( 'itemDefinition' ) && $ this -> getRequestParameter ( 'itemState' ) ) { $ serviceContext = $ this -> getServiceContext ( ) ; $ itemIdentifier = $ this -> getRequestParameter ( 'itemDefinition' ) ; $ state = $ this -> getRequestParameter ( 'itemState' ) ? json_decode ( $ this -> getRequestParameter ( 'itemState' ) , true ) : new \ stdClass ( ) ; return $ this -> getRunnerService ( ) -> setItemState ( $ serviceContext , $ itemIdentifier , $ state ) ; } return false ; }
6523	public function isCompatibleForOverride ( Field $ other ) { if ( ! $ this -> overridable ) { return false ; } if ( $ this -> name !== $ other -> name ) { return false ; } if ( $ this -> type !== $ other -> type ) { return false ; } if ( $ this -> rule !== $ other -> rule ) { return false ; } if ( $ this -> required !== $ other -> required ) { return false ; } return true ; }
4708	public function initialize ( Text $ text , array $ options = array ( ) ) { $ text -> replace ( '{ ^[ ]{0,' . $ options [ 'tabWidth' ] . '}\[(.+)\]: # id = $1 [ \t]* \n? # maybe *one* newline [ \t]* <?(\S+?)>? # url = $2 [ \t]* \n? # maybe one newline [ \t]* (?: (?<=\s) # lookbehind for whitespace ["\'(] (.+?) # title = $3 ["\')] [ \t]* )? # title is optional (?:\n+|\Z) }xm' , function ( Text $ whole , Text $ id , Text $ url , Text $ title = null ) { $ id -> lower ( ) ; $ this -> markdown -> emit ( 'escape.special_chars' , [ $ url -> replace ( '/(?<!\\\\)_/' , '\\\\_' ) ] ) ; $ this -> markdown -> getUrlRegistry ( ) -> set ( $ id , htmlspecialchars ( $ url , ENT_QUOTES , 'UTF-8' , false ) ) ; if ( $ title ) { $ this -> markdown -> getTitleRegistry ( ) -> set ( $ id , preg_replace ( '/"/' , '&quot;' , $ title ) ) ; } return '' ; } ) ; }
5781	private function getSectionForAdministrator ( array $ section , string $ sectionName ) : array { if ( isset ( $ section [ 'authorization' ] ) && ! $ this -> container -> authorization -> isAuthorized ( $ section [ 'authorization' ] ) ) { return [ ] ; } $ updatedSection = [ ] ; foreach ( $ section as $ key => $ value ) { if ( $ key != 'subSections' ) { $ updatedSection [ $ key ] = $ value ; } } $ updatedSubSections = [ ] ; if ( isset ( $ section [ 'subSections' ] ) ) { foreach ( $ section [ 'subSections' ] as $ subSectionName => $ subSection ) { $ updatedSubSection = $ this -> getSectionForAdministrator ( $ subSection , $ subSectionName ) ; if ( count ( $ updatedSubSection ) > 0 ) { $ updatedSubSections [ $ subSectionName ] = $ updatedSubSection ; } } } if ( count ( $ updatedSubSections ) > 0 ) { $ updatedSection [ 'subSections' ] = $ updatedSubSections ; } return $ updatedSection ; }
7907	protected function getLabel ( $ item ) { $ encodeLabel = isset ( $ item [ 'encode' ] ) ? $ item [ 'encode' ] : $ this -> encodeLabels ; return $ encodeLabel ? Html :: encode ( $ item [ 'label' ] ) : $ item [ 'label' ] ; }
12100	public function priceBrutto ( $ netto , $ tax ) { $ tax = round ( ( double ) $ tax / 100.0 , 2 ) ; if ( $ tax < 0.00 ) { throw new Exception ( sprintf ( 'Tax must be greater than or equal to 0, given %s.' , $ tax ) ) ; } if ( $ tax === 0.00 ) { return $ netto ; } $ result = $ netto * ( $ tax + 1 ) ; return round ( $ result , 2 , PHP_ROUND_HALF_UP ) ; }
1173	public function setDelegatedValidator ( DelegatedValidator $ validator ) { $ this -> validator = $ validator ; $ this -> rules -> setDelegatedValidator ( $ validator ) ; $ this -> messages -> setDelegatedValidator ( $ validator ) ; }
11431	protected function get ( $ path , array $ parameters = array ( ) , $ requestHeaders = array ( ) ) { if ( array_key_exists ( 'ref' , $ parameters ) && is_null ( $ parameters [ 'ref' ] ) ) { unset ( $ parameters [ 'ref' ] ) ; } $ response = $ this -> client -> getHttpClient ( ) -> get ( $ path , $ parameters , $ requestHeaders ) ; return ResponseMediator :: getContent ( $ response ) ; }
10503	private function setParameter ( $ subject , string $ key , $ value ) { $ setter = 'set' . $ this -> snakeToCamelCase ( $ key ) ; if ( is_callable ( [ $ subject , $ setter ] ) ) { call_user_func ( [ $ subject , $ setter ] , $ value ) ; } }
11018	public function loadView ( $ data = [ ] , $ return = FALSE ) { $ retVal = NULL ; $ extra = [ 'route' => $ this -> _getRoute ( ) , ] ; extract ( $ extra , EXTR_OVERWRITE ) ; extract ( $ data , EXTR_OVERWRITE ) ; $ level = error_reporting ( ) ; error_reporting ( 0 ) ; ob_start ( ) ; if ( isset ( $ view ) ) { $ viewsDirEvent = new GetViewsDirEvent ( ) ; $ this -> dispatcher -> fire ( Events :: EVENT_GET_VIEWS_DIR , $ viewsDirEvent ) ; $ viewDir = $ viewsDirEvent -> getViewsDir ( ) ; if ( NULL === $ viewDir ) { throw new RawException ( 'The views directory has not been set.' ) ; } if ( FALSE !== strstr ( $ view , '.php' ) ) { include $ viewDir . $ view ; } else { include $ viewDir . $ view . '.php' ; } $ newView = ob_get_clean ( ) ; if ( $ return ) { $ retVal = $ newView ; } else { $ this -> pageView .= $ newView ; } } else { $ retVal = '' ; } error_reporting ( $ level ) ; return $ retVal ; }
4387	public function getConfigFE ( \ Aimeos \ MShop \ Order \ Item \ Base \ Iface $ basket ) { $ list = [ ] ; $ feconfig = $ this -> feConfig ; try { $ code = $ this -> getServiceItem ( ) -> getCode ( ) ; $ service = $ basket -> getService ( \ Aimeos \ MShop \ Order \ Item \ Base \ Service \ Base :: TYPE_PAYMENT , $ code ) ; foreach ( $ service -> getAttributeItems ( ) as $ item ) { if ( isset ( $ feconfig [ $ item -> getCode ( ) ] ) ) { $ feconfig [ $ item -> getCode ( ) ] [ 'default' ] = $ item -> getValue ( ) ; } } } catch ( \ Aimeos \ MShop \ Order \ Exception $ e ) { ; } $ addresses = $ basket -> getAddress ( \ Aimeos \ MShop \ Order \ Item \ Base \ Address \ Base :: TYPE_PAYMENT ) ; if ( ( $ address = current ( $ addresses ) ) !== false ) { if ( $ feconfig [ 'novalnetsepa.holder' ] [ 'default' ] == '' && ( $ fn = $ address -> getFirstname ( ) ) !== '' && ( $ ln = $ address -> getLastname ( ) ) !== '' ) { $ feconfig [ 'novalnetsepa.holder' ] [ 'default' ] = $ fn . ' ' . $ ln ; } } foreach ( $ feconfig as $ key => $ config ) { $ list [ $ key ] = new \ Aimeos \ MW \ Criteria \ Attribute \ Standard ( $ config ) ; } return $ list ; }
5223	protected function getValueCreator ( $ value ) { if ( is_string ( $ value ) && class_exists ( $ value ) ) { return function ( $ injector ) use ( $ value ) { return $ injector -> getInstance ( $ value ) ; } ; } return function ( ) use ( $ value ) { return $ value ; } ; }
12671	public static function getEmulatorInstance ( $ scheme , $ path , $ context ) { if ( ! isset ( static :: $ emulators [ $ scheme ] ) ) { throw new \ InvalidArgumentException ( 'No emulator found for scheme \'' . $ scheme . '\'' ) ; } $ emulator = static :: $ emulators [ $ scheme ] ; return new $ emulator ( $ path , $ context ) ; }
4353	public function onLog ( Event $ event ) { if ( ! $ this -> fileHandle ) { return ; } $ method = $ event [ 'method' ] ; if ( $ method == 'groupUncollapse' ) { return ; } $ args = $ event [ 'args' ] ; $ meta = $ event [ 'meta' ] ; $ isSummaryBookend = $ method == 'groupSummary' || ! empty ( $ meta [ 'closesSummary' ] ) ; if ( $ isSummaryBookend ) { \ fwrite ( $ this -> fileHandle , "=========\n" ) ; return ; } if ( $ args ) { $ str = $ this -> processLogEntryWEvent ( $ method , $ args , $ meta ) ; \ fwrite ( $ this -> fileHandle , $ str ) ; } elseif ( $ method == 'groupEnd' && $ this -> depth > 0 ) { $ this -> depth -- ; } }
9888	static function getPermission ( $ code ) { switch ( $ code ) { case 1 : return self :: $ NONE ; case "none" : return self :: $ NONE ; case 2 : return self :: $ SOI ; case "soi" : return self :: $ SOI ; case 3 : return self :: $ COI ; case "coi" : return self :: $ COI ; case 4 : return self :: $ DOI ; case "doi" : return self :: $ DOI ; case 5 : return self :: $ DOI_PLUS ; case "doi+" : return self :: $ DOI_PLUS ; case 6 : return self :: $ OTHER ; case "other" : return self :: $ OTHER ; default : return self :: $ OTHER ; } }
4656	public function create ( Job $ job ) { $ context = new Context ( $ this -> buildPath . DIRECTORY_SEPARATOR . $ job -> getDirectory ( ) ) ; $ buildStream = $ this -> docker -> getImageManager ( ) -> build ( $ context -> toStream ( ) , [ 't' => $ job -> getName ( ) , 'q' => $ this -> quietBuild , 'nocache' => ! $ this -> usecache ] , ImageManager :: FETCH_STREAM ) ; $ buildStream -> onFrame ( $ this -> logger -> getBuildCallback ( ) ) ; $ buildStream -> wait ( ) ; try { return $ this -> docker -> getImageManager ( ) -> find ( $ job -> getName ( ) ) ; } catch ( ClientErrorException $ e ) { if ( $ e -> getResponse ( ) -> getStatusCode ( ) == 404 ) { return false ; } throw $ e ; } }
2218	public function getFields ( ) { $ arrFields = $ GLOBALS [ 'TL_FFL' ] ; foreach ( array_keys ( $ arrFields ) as $ key ) { $ arrFields [ $ key ] = $ GLOBALS [ 'TL_LANG' ] [ 'FFL' ] [ $ key ] [ 0 ] ; } return $ arrFields ; }
5505	public function returns ( $ method , $ value , $ args = false ) { $ this -> dieOnNoMethod ( $ method , 'set return' ) ; $ this -> actions -> register ( $ method , $ args , new SimpleReturn ( $ value ) ) ; }
6900	public function close ( ) : void { if ( $ this -> is_active ( ) ) { $ this -> _data [ 'last_active' ] = time ( ) ; config ( 'debug' ) ? session_write_close ( ) : @ session_write_close ( ) ; } }
2747	public function getGeoIpMappingForCountry ( $ countryCode ) { if ( $ mapping = $ this -> _scopeConfig -> getValue ( self :: XML_FASTLY_GEOIP_COUNTRY_MAPPING ) ) { return $ this -> extractMapping ( $ mapping , $ countryCode ) ; } return null ; }
842	public function offsetSet ( $ index , $ newval ) { $ this -> blockEndCache = [ ] ; if ( ! $ this [ $ index ] || ! $ this [ $ index ] -> equals ( $ newval ) ) { $ this -> changed = true ; if ( isset ( $ this [ $ index ] ) ) { $ this -> unregisterFoundToken ( $ this [ $ index ] ) ; } $ this -> registerFoundToken ( $ newval ) ; } parent :: offsetSet ( $ index , $ newval ) ; }
11328	public function setFormField ( $ value ) { if ( is_array ( $ value ) ) { if ( is_null ( $ this -> formFieldClass ) ) { throw new Exception ( "DB Field incorrectly set up. What is the form class?" ) ; } if ( is_null ( $ this -> _formField ) ) { $ config = $ value ; $ config [ 'class' ] = $ this -> formFieldClass ; $ config [ 'modelField' ] = $ this ; $ value = Yii :: createObject ( $ config ) ; } else { $ settings = $ value ; $ value = $ this -> _formField ; unset ( $ settings [ 'class' ] ) ; Yii :: configure ( $ value , $ settings ) ; } } $ this -> _formField = $ value ; return true ; }
8020	public function set ( string $ content ) { $ parsed = $ this -> parseContent ( $ content ) ; $ this -> id = $ parsed -> id ; $ this -> infoUri = $ parsed -> infoUri ; $ this -> partialCancelUri = $ parsed -> partialCancelUri ?? null ; $ this -> nextUri = $ parsed -> nextUri ?? null ; $ this -> columns = [ ] ; if ( isset ( $ parsed -> columns ) ) { $ this -> columnTransfer ( $ parsed -> columns ) ; } $ this -> data = $ parsed -> data ?? [ ] ; $ this -> stats = isset ( $ parsed -> stats ) ? $ this -> statsTransfer ( $ parsed -> stats ) : null ; $ this -> error = isset ( $ parsed -> error ) ? $ this -> errorTransfer ( $ parsed -> error ) : null ; }
11433	public function query ( $ keyword , $ categories , array $ other = [ ] ) { $ params = [ 'query' => $ keyword , 'category' => implode ( ',' , ( array ) $ categories ) , 'appid' => $ this -> getAccessToken ( ) -> getAppId ( ) , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_SEARCH , array_merge ( $ params , $ other ) ] ) ; }
9482	private function prepare ( array $ folders ) { return collect ( $ folders ) -> mapWithKeys ( function ( $ folder ) { $ path = base_path ( $ folder ) ; return [ $ folder => [ 'chmod' => ( int ) substr ( sprintf ( '%o' , fileperms ( $ path ) ) , - 4 ) , 'writable' => is_writable ( $ path ) , ] , ] ; } ) ; }
12618	public function setFileSource ( $ value ) { if ( isset ( $ this -> module -> sourceFiles [ $ value ] ) ) { $ this -> _fileSource = $ this -> module -> sourceFiles [ $ value ] ; } else { $ this -> _fileSource = false ; } }
11381	public function render ( FormInterface $ form ) { if ( method_exists ( $ form , 'prepare' ) ) { $ form -> prepare ( ) ; } if ( ! $ form -> getAttribute ( 'role' ) ) { $ form -> setAttribute ( 'role' , 'form' ) ; } $ formContent = '' ; foreach ( $ form as $ element ) { if ( $ element instanceof FieldsetInterface ) { $ formContent .= $ this -> getView ( ) -> formCollection ( $ element ) ; } else { $ element -> setOption ( '_form' , $ form ) ; $ formContent .= $ this -> getView ( ) -> formRow ( $ element ) ; } } return $ this -> openTag ( $ form ) . $ formContent . $ this -> closeTag ( ) ; }
8701	public function getString ( ) { $ this -> validateElement ( ) ; $ elementStringData = '' ; $ elementStringData = '<' . static :: TYPE ; foreach ( $ this -> attributes as $ key => $ data ) { $ elementStringData .= ' ' . $ key . '="' . $ data . '"' ; } $ elementStringData .= '>' ; if ( $ this -> text !== null ) { $ elementStringData .= $ this -> text ; } if ( count ( $ this -> childElements ) > 0 ) { if ( static :: TYPE == 'svg' ) { foreach ( $ this -> childElements as $ childElement ) { $ this -> defs = array_merge ( $ this -> defs , $ childElement -> getDefs ( ) ) ; } if ( count ( $ this -> defs ) > 0 ) { $ defArea = new \ SVGCreator \ Elements \ Defs ( ) ; foreach ( $ this -> defs as $ def ) { $ defArea -> append ( $ def ) ; } $ elementStringData .= $ defArea -> getString ( ) ; } } foreach ( $ this -> childElements as $ childElement ) { $ elementStringData .= $ childElement -> getString ( ) ; } } $ elementStringData .= '</' . static :: TYPE . '>' ; $ this -> elementString = $ elementStringData ; return $ this -> elementString ; }
11149	protected function process ( array $ requestParams ) { $ request = new ExtDirectRequest ( $ this -> useCache ( ) , $ this -> getApplicationPath ( ) , $ this -> getApplicationNameSpace ( ) ) ; $ response = new ExtDirectResponse ( ) ; $ requestParameters = new Parameters ( ) ; try { $ request -> setApplicationPath ( $ this -> getApplicationPath ( ) ) ; $ requestParameters -> setParameters ( $ requestParams ) ; $ request -> injectParameters ( $ requestParameters ) ; $ response -> injectParameters ( $ requestParameters ) ; $ request -> injectResponse ( $ response ) ; $ request -> setParamMethod ( $ this -> getParamMethod ( ) ) ; $ request -> setMethodCalls ( $ this -> getMethodsToCall ( ) ) ; $ request -> run ( ) ; } catch ( ExtDirectApplicationException $ e ) { $ result = $ e -> getResponse ( ) ; if ( ! empty ( $ result ) ) { $ response -> setResult ( array ( "success" => false , "message" => $ e -> getMessage ( ) , "actions" => $ result ) ) ; } else { $ response -> setResult ( array ( "success" => false , "message" => $ e -> getMessage ( ) ) ) ; } } catch ( \ Exception $ e ) { $ response -> setResult ( array ( "success" => false , "message" => $ e -> getMessage ( ) ) ) ; } return $ response ; }
607	private function tokenizeOperator ( & $ length ) { if ( ! $ this -> isOperator ( $ length , $ content ) ) { return false ; } $ this -> addTokenFromBuffer ( ) ; switch ( $ this -> substring ( $ length ) ) { case '(' : $ this -> _currentToken [ ] = new SqlToken ( [ 'type' => SqlToken :: TYPE_OPERATOR , 'content' => is_string ( $ content ) ? $ content : $ this -> substring ( $ length ) , 'startOffset' => $ this -> offset , 'endOffset' => $ this -> offset + $ length , ] ) ; $ this -> _currentToken [ ] = new SqlToken ( [ 'type' => SqlToken :: TYPE_PARENTHESIS ] ) ; $ this -> _tokenStack -> push ( $ this -> _currentToken [ - 1 ] ) ; $ this -> _currentToken = $ this -> _tokenStack -> top ( ) ; break ; case ')' : $ this -> _tokenStack -> pop ( ) ; $ this -> _currentToken = $ this -> _tokenStack -> top ( ) ; $ this -> _currentToken [ ] = new SqlToken ( [ 'type' => SqlToken :: TYPE_OPERATOR , 'content' => ')' , 'startOffset' => $ this -> offset , 'endOffset' => $ this -> offset + $ length , ] ) ; break ; case ';' : if ( ! $ this -> _currentToken -> getHasChildren ( ) ) { break ; } $ this -> _currentToken [ ] = new SqlToken ( [ 'type' => SqlToken :: TYPE_OPERATOR , 'content' => is_string ( $ content ) ? $ content : $ this -> substring ( $ length ) , 'startOffset' => $ this -> offset , 'endOffset' => $ this -> offset + $ length , ] ) ; $ this -> _tokenStack -> pop ( ) ; $ this -> _currentToken = $ this -> _tokenStack -> top ( ) ; $ this -> _currentToken [ ] = new SqlToken ( [ 'type' => SqlToken :: TYPE_STATEMENT ] ) ; $ this -> _tokenStack -> push ( $ this -> _currentToken [ - 1 ] ) ; $ this -> _currentToken = $ this -> _tokenStack -> top ( ) ; break ; default : $ this -> _currentToken [ ] = new SqlToken ( [ 'type' => SqlToken :: TYPE_OPERATOR , 'content' => is_string ( $ content ) ? $ content : $ this -> substring ( $ length ) , 'startOffset' => $ this -> offset , 'endOffset' => $ this -> offset + $ length , ] ) ; break ; } return true ; }
11101	public static function countryCodeTwoToThree ( $ code ) { $ codes = array_flip ( self :: $ _countryCodes ) ; if ( ! array_key_exists ( $ code , $ codes ) ) { return false ; } return $ codes [ $ code ] ; }
10558	public function createI18n ( array $ args ) { $ i18n = new I18n ; I18nShortcut :: setInstance ( $ i18n ) ; $ modules = $ this -> app -> resolver -> getResolver ( "language" ) ; $ log = \ Wedeto \ Log \ Logger :: getLogger ( I18nPlugin :: class ) ; $ search_path = $ modules -> getSearchPath ( ) ; foreach ( $ search_path as $ name => $ path ) { $ i18n -> registerTextDomain ( $ name , $ path ) ; } $ site_language = $ this -> app -> config -> dget ( 'site' , 'default_language' , 'en' ) ; $ locale = $ args [ 'locale' ] ?? $ site_language ; $ i18n -> setLocale ( $ locale ) ; $ this -> setupTranslateLog ( ) ; return $ i18n ; }
12741	public function getTag ( $ name ) { if ( ! isset ( $ this -> tags [ $ name ] ) ) { throw new AttributeNotFoundException ( $ name ) ; } return $ this -> tags [ $ name ] ; }
11555	private function getBonusTotals ( $ dsBegin , $ dsEnd ) { $ query = $ this -> qbGetBonusTotals -> build ( ) ; $ conn = $ query -> getConnection ( ) ; $ bind = [ QBGetTotals :: BND_PERIOD_BEGIN => $ dsBegin , QBGetTotals :: BND_PERIOD_END => $ dsEnd ] ; $ rs = $ conn -> fetchAll ( $ query , $ bind ) ; $ result = [ ] ; foreach ( $ rs as $ one ) { $ accId = $ one [ QBGetTotals :: A_ACC_ID ] ; $ custId = $ one [ QBGetTotals :: A_CUST_ID ] ; $ total = $ one [ QBGetTotals :: A_TOTAL ] ; if ( $ custId ) { $ item = new DTotal ( ) ; $ item -> accountId = $ accId ; $ item -> customerId = $ custId ; $ item -> total = $ total ; $ result [ $ custId ] = $ item ; } } return $ result ; }
1296	private function getUnresolvedField ( Field $ field , string $ locale = null ) { if ( ! isset ( $ this -> fields [ $ field -> getId ( ) ] ) ) { return 'Array' === $ field -> getType ( ) ? [ ] : null ; } $ value = $ this -> fields [ $ field -> getId ( ) ] ; $ locale = $ this -> getLocaleFromInput ( $ locale ) ; if ( \ array_key_exists ( $ locale , $ value ) ) { return $ value [ $ locale ] ; } if ( ! $ field -> isLocalized ( ) ) { throw new \ InvalidArgumentException ( \ sprintf ( 'Trying to access the non-localized field "%s" on content type "%s" using the non-default locale "%s".' , $ field -> getName ( ) , $ this -> sys -> getContentType ( ) -> getName ( ) , $ locale ) ) ; } $ locale = $ this -> walkFallbackChain ( $ value , $ locale , $ this -> sys -> getEnvironment ( ) ) ; if ( $ locale ) { return $ value [ $ locale ] ; } return 'Array' === $ field -> getType ( ) ? [ ] : null ; }
10432	protected function createServices ( ContainerBuilder $ container , $ classes , $ config , $ tag , $ method ) { if ( ! is_array ( $ tag ) ) { $ tag = [ $ tag ] ; } foreach ( $ classes as $ class ) { $ methods = $ this -> getMethods ( $ class ) ; $ definition = new Definition ( $ class ) ; $ this -> setProperties ( $ definition , $ config , $ methods ) ; $ this -> setTags ( $ definition , $ tag , $ method ) ; $ container -> setDefinition ( $ this -> getServiceName ( $ tag [ 0 ] ) , $ definition ) ; } }
12742	public function removeById ( $ connectionID ) { if ( isset ( $ this -> pool [ $ connectionID ] ) ) { $ this -> slotmap -> reset ( ) ; $ this -> slots = array_diff ( $ this -> slots , array ( $ connectionID ) ) ; unset ( $ this -> pool [ $ connectionID ] ) ; return true ; } return false ; }
11066	public function addMethods ( $ mixin , array $ methods ) { foreach ( $ methods as $ method ) { $ this -> method_map [ $ method ] = $ mixin ; } return $ this ; }
6894	protected function compareStockUnitByPrice ( StockUnitInterface $ u1 , StockUnitInterface $ u2 ) { $ u1HasPrice = 0 < $ u1 -> getNetPrice ( ) ; $ u2HasPrice = 0 < $ u2 -> getNetPrice ( ) ; if ( ! $ u1HasPrice && $ u2HasPrice ) { return 1 ; } if ( $ u1HasPrice && ! $ u2HasPrice ) { return - 1 ; } if ( $ u1 -> getNetPrice ( ) != $ u2 -> getNetPrice ( ) ) { return $ u1 -> getNetPrice ( ) > $ u2 -> getNetPrice ( ) ? 1 : - 1 ; } return 0 ; }
2897	public function replaceProfiler ( ) { $ connection = Mage :: getSingleton ( 'core/resource' ) -> getConnection ( 'core_write' ) ; $ currentProfile = $ connection -> getProfiler ( ) ; if ( $ currentProfile ) { $ this -> _queryProfiles = $ currentProfile -> _queryProfiles ; } $ this -> setEnabled ( $ currentProfile -> getEnabled ( ) ) ; $ connection -> setProfiler ( $ this ) ; }
12943	public function authenticate ( AdapterInterface $ adapter = null ) { $ event = clone $ this -> getEvent ( ) ; $ event -> setName ( AuthenticationEvent :: EVENT_AUTH ) ; if ( ! $ adapter ) { $ adapter = $ this -> getAdapter ( ) ; } if ( $ adapter ) { $ event -> setAdapter ( $ adapter ) ; } $ this -> getEventManager ( ) -> trigger ( $ event ) ; return $ event -> getResult ( ) ; }
1380	protected function validateToOne ( $ value , ? string $ field = null ) : bool { if ( is_null ( $ value ) ) { return true ; } $ dataPath = $ field ? "/data/relationships/{$field}" : "/" ; $ identifierPath = $ field ? "/data/relationships/{$field}" : "/data" ; if ( ! $ this -> validateIdentifier ( $ value , $ dataPath ) ) { return false ; } if ( ! $ this -> store -> exists ( new ResourceIdentifier ( $ value ) ) ) { $ this -> resourceDoesNotExist ( $ identifierPath ) ; return false ; } return true ; }
7140	protected function handleQuantityChange ( SupplierDeliveryItemInterface $ item ) { $ changeSet = $ this -> persistenceHelper -> getChangeSet ( $ item ) ; if ( null === $ orderItem = $ item -> getOrderItem ( ) ) { throw new RuntimeException ( "Failed to retrieve order item." ) ; } if ( null !== $ stockUnit = $ orderItem -> getStockUnit ( ) ) { if ( 0 != $ deltaQuantity = floatval ( $ changeSet [ 'quantity' ] [ 1 ] ) - floatval ( $ changeSet [ 'quantity' ] [ 0 ] ) ) { $ this -> stockUnitUpdater -> updateReceived ( $ stockUnit , $ deltaQuantity , true ) ; } } elseif ( $ orderItem -> hasSubjectIdentity ( ) ) { throw new RuntimeException ( "Failed to retrieve stock unit." ) ; } if ( null === $ order = $ orderItem -> getOrder ( ) ) { throw new RuntimeException ( "Failed to retrieve order." ) ; } $ this -> scheduleSupplierOrderContentChangeEvent ( $ order ) ; }
4945	public function revoke ( $ resource , $ permission = null , $ build = true ) { if ( self :: PERMISSION_NONE == $ permission || ! $ this -> isAssigned ( $ resource ) ) { return $ this ; } if ( self :: PERMISSION_CHANGE == $ permission ) { return $ this -> grant ( $ resource , self :: PERMISSION_VIEW , $ build ) ; } return $ this -> grant ( $ resource , self :: PERMISSION_NONE , $ build ) ; }
6015	public function retrieveSite ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/deployment/sites/' . $ id . '' , $ parameters , $ cachePolicy ) ; $ result = new DeploymentSiteResponse ( $ result ) ; return $ result ; }
5729	public function bindGridField ( Form $ form , GridFieldDetailForm_ItemRequest $ request ) { $ this -> setForm ( $ form ) ; $ this -> gridFieldRequest = $ request ; foreach ( $ this -> children as $ child ) { if ( ! $ child instanceof BetterButton && ! $ child instanceof BetterButtonAction ) { throw new Exception ( "DropdownFormAction must be passed instances of BetterButton" ) ; } $ child -> bindGridField ( $ form , $ request ) ; $ child -> setIsGrouped ( true ) ; if ( $ child instanceof FormAction ) { $ child -> setUseButtonTag ( true ) ; } } return $ this ; }
12469	protected function replaceNamespace ( $ path ) { $ search = [ 'namespace ' . $ this -> currentRoot . ';' , $ this -> currentRoot . '\\' ] ; $ replace = [ 'namespace ' . $ this -> argument ( 'name' ) . ';' , $ this -> argument ( 'name' ) . '\\' ] ; $ this -> replaceIn ( $ path , $ search , $ replace ) ; }
4063	private static function calculateArrayDiff ( $ expected , $ actual , $ strict ) { if ( count ( $ expected ) !== count ( $ actual ) ) { throw new \ LogicException ( sprintf ( 'Array element count mismatch. Found %s, expected %s.' , count ( $ actual ) , count ( $ expected ) ) , self :: ARRAY_COUNT_MISMATCH ) ; } reset ( $ actual ) ; foreach ( $ expected as $ key => $ value ) { if ( $ key !== key ( $ actual ) ) { throw new \ LogicException ( sprintf ( 'Array key mismatch. Found %s, expected %s.' , key ( $ actual ) , $ key ) , self :: ARRAY_KEY_MISMATCH ) ; } try { self :: calculateDiff ( $ value , current ( $ actual ) , $ strict ) ; } catch ( \ Exception $ exception ) { throw new \ LogicException ( sprintf ( 'Array value mismatch for key %s.' , key ( $ actual ) ) , self :: ARRAY_VALUE_MISMATCH , $ exception ) ; } next ( $ actual ) ; } }
7679	function TbsMergeVarFields ( $ PrmVal , $ FldVal ) { $ this -> TBS -> meth_Merge_AutoVar ( $ PrmVal , true ) ; $ PrmVal = str_replace ( $ this -> TBS -> _ChrVal , $ FldVal , $ PrmVal ) ; return $ PrmVal ; }
5429	public function getParent ( ) { $ reflection = new ReflectionClass ( $ this -> interface ) ; $ parent = $ reflection -> getParentClass ( ) ; if ( $ parent ) { return $ parent -> getName ( ) ; } return false ; }
4831	public function retry ( ) { $ endpoint = self :: $ endpoint . '/' . $ this -> id . '/retry' ; return new self ( $ this -> client , $ this -> client -> request ( 'post' , $ endpoint ) ) ; }
